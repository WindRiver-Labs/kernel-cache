From 2e0ca27cea5944b5d390d4b173c346d04dc5fa22 Mon Sep 17 00:00:00 2001
From: Kevin Hao <kexin.hao@windriver.com>
Date: Tue, 22 Sep 2009 16:30:13 +0800
Subject: [PATCH 21/52] crypto: add driver for Freescale's Cryptographic Accelerator and Assurance Module

Signed-off-by: Geoff Thorpe <geoff@geoffthorpe.net>
Signed-off-by: Kim Phillips <kim.phillips@freescale.com>
Signed-off-by: Steve Cornelius <steve.cornelius@freescale.com>
[KevinHao: Original headerless patch (p4080_1-2-rc1-drivers_crypto.patch)
taken from Freescale rev 1.2 board support ISO image for p4080]
Integrated-by: Kevin Hao <kexin.hao@windriver.com>
---
 drivers/crypto/Kconfig                    |    2 +
 drivers/crypto/Makefile                   |    1 +
 drivers/crypto/caam/Kconfig               |   53 ++
 drivers/crypto/caam/Makefile              |   14 +
 drivers/crypto/caam/algapi.c              | 1073 ++++++++++++++++++++++++++
 drivers/crypto/caam/compat.h              |   64 ++
 drivers/crypto/caam/ctrl.c                |  239 ++++++
 drivers/crypto/caam/dcl/Makefile          |   14 +
 drivers/crypto/caam/dcl/cmdgen.c          |  335 +++++++++
 drivers/crypto/caam/dcl/dcl.h             |  625 ++++++++++++++++
 drivers/crypto/caam/dcl/disasm.c          |  776 +++++++++++++++++++
 drivers/crypto/caam/dcl/jobdesc.c         |   74 ++
 drivers/crypto/caam/dcl/protoshared.c     |  259 +++++++
 drivers/crypto/caam/desc.h                | 1158 +++++++++++++++++++++++++++++
 drivers/crypto/caam/intern.h              |  109 +++
 drivers/crypto/caam/jq.c                  |  452 +++++++++++
 drivers/crypto/caam/jq.h                  |   42 +
 drivers/crypto/caam/jq_test/Makefile      |    4 +
 drivers/crypto/caam/jq_test/caam_jqtest.c |  106 +++
 drivers/crypto/caam/jq_test/caam_jqtest.h |   43 ++
 drivers/crypto/caam/jq_test/jq_ipsec.c    |  162 ++++
 drivers/crypto/caam/regs.h                |  627 ++++++++++++++++
 22 files changed, 6232 insertions(+), 0 deletions(-)
 create mode 100644 drivers/crypto/caam/Kconfig
 create mode 100644 drivers/crypto/caam/Makefile
 create mode 100644 drivers/crypto/caam/algapi.c
 create mode 100644 drivers/crypto/caam/compat.h
 create mode 100644 drivers/crypto/caam/ctrl.c
 create mode 100644 drivers/crypto/caam/dcl/Makefile
 create mode 100644 drivers/crypto/caam/dcl/cmdgen.c
 create mode 100644 drivers/crypto/caam/dcl/dcl.h
 create mode 100644 drivers/crypto/caam/dcl/disasm.c
 create mode 100644 drivers/crypto/caam/dcl/jobdesc.c
 create mode 100644 drivers/crypto/caam/dcl/protoshared.c
 create mode 100644 drivers/crypto/caam/desc.h
 create mode 100644 drivers/crypto/caam/intern.h
 create mode 100644 drivers/crypto/caam/jq.c
 create mode 100644 drivers/crypto/caam/jq.h
 create mode 100644 drivers/crypto/caam/jq_test/Makefile
 create mode 100644 drivers/crypto/caam/jq_test/caam_jqtest.c
 create mode 100644 drivers/crypto/caam/jq_test/caam_jqtest.h
 create mode 100644 drivers/crypto/caam/jq_test/jq_ipsec.c
 create mode 100644 drivers/crypto/caam/regs.h

diff --git a/drivers/crypto/Kconfig b/drivers/crypto/Kconfig
index aace0eb..11b59a1 100644
--- a/drivers/crypto/Kconfig
+++ b/drivers/crypto/Kconfig
@@ -181,6 +181,8 @@ config CRYPTO_DEV_HIFN_795X_RNG
 	  Select this option if you want to enable the random number generator
 	  on the HIFN 795x crypto adapters.
 
+source drivers/crypto/caam/Kconfig
+
 config CRYPTO_DEV_TALITOS
 	tristate "Talitos Freescale Security Engine (SEC)"
 	select CRYPTO_ALGAPI
diff --git a/drivers/crypto/Makefile b/drivers/crypto/Makefile
index e6095f0..2fd6577 100644
--- a/drivers/crypto/Makefile
+++ b/drivers/crypto/Makefile
@@ -6,3 +6,4 @@ obj-$(CONFIG_CRYPTO_DEV_HIFN_795X) += hifn_795x.o
 obj-$(CONFIG_CRYPTO_DEV_TALITOS) += talitos.o
 obj-$(CONFIG_CRYPTO_DEV_IXP4XX) += ixp4xx_crypto.o
 obj-$(CONFIG_CRYPTO_DEV_PPC4XX) += amcc/
+obj-$(CONFIG_CRYPTO_DEV_FSL_CAAM) += caam/
diff --git a/drivers/crypto/caam/Kconfig b/drivers/crypto/caam/Kconfig
new file mode 100644
index 0000000..a126969
--- /dev/null
+++ b/drivers/crypto/caam/Kconfig
@@ -0,0 +1,53 @@
+config CRYPTO_DEV_FSL_CAAM
+	tristate "Freescale CAAM-Multicore driver backend (EXPERIMENTAL)"
+	depends on FSL_SOC
+	help
+	  Enables the driver module for Freescale's Cryptographic Accelerator
+	  and Assurance Module (CAAM). This module adds support for scatterlist
+	  crypto API, and also configures CAAM to operate as a DPAA component.
+
+config CRYPTO_DEV_FSL_CAAM_RINGSIZE
+	int "Job Queue ring size"
+	depends on CRYPTO_DEV_FSL_CAAM
+	range 2 10
+	default "8"
+	help
+	  Select size of Job Queue rings as a power of 2, within the
+	  range 2-10 (ring size 4-1024).
+	  Examples:
+		2 => 4
+		3 => 8
+		4 => 16
+		5 => 32
+		6 => 64
+		7 => 128
+		8 => 256
+		9 => 512
+		10 => 1024
+
+config CRYPTO_DEV_FSL_CAAM_DC_LIB
+	tristate "Freescale CAAM Descriptor Library (EXPERIMENTAL)"
+	depends on CRYPTO_DEV_FSL_CAAM
+	help
+	  Enables the Descriptor Construction Library for use with
+	  Freescale's Cryptographic Accelerator and Assurance Module (CAAM).
+
+config CRYPTO_DEV_FSL_CAAM_CRYPTO_API
+	tristate "Linux Kernel Scatterlist Crypto API support"
+	depends on CRYPTO_DEV_FSL_CAAM_DC_LIB
+	select CRYPTO_ALGAPI
+	select CRYPTO_AUTHENC
+	help
+	  Selecting this will offload crypto for users of the
+	  scatterlist crypto API (such as the linux native IPSec
+	  stack NETKEY) to the SEC4 via a job queue.
+
+config CRYPTO_DEV_FSL_CAAM_JQ_TEST
+	tristate "Freescale CAAM-Multicore JobQ Test (EXPERIMENTAL)"
+	depends on CRYPTO_DEV_FSL_CAAM
+	depends on CRYPTO_DEV_FSL_CAAM_DC_LIB
+	help
+	  Enables a test module for to exercise CAAM through a
+	  native job queue.
+
+
diff --git a/drivers/crypto/caam/Makefile b/drivers/crypto/caam/Makefile
new file mode 100644
index 0000000..ceddfed
--- /dev/null
+++ b/drivers/crypto/caam/Makefile
@@ -0,0 +1,14 @@
+
+#
+# Makefile for the CAAM backend and dependent components, including:
+#   Descriptor builder library (for inside the Kernel)
+#   Datapath test module
+#
+
+obj-$(CONFIG_CRYPTO_DEV_FSL_CAAM) += caam.o
+
+obj-$(CONFIG_CRYPTO_DEV_FSL_CAAM_DC_LIB) += dcl/
+obj-$(CONFIG_CRYPTO_DEV_FSL_CAAM_CRYPTO_API) += algapi.o
+obj-$(CONFIG_CRYPTO_DEV_FSL_CAAM_JQ_TEST) += jq_test/
+
+caam-objs := ctrl.o jq.o
diff --git a/drivers/crypto/caam/algapi.c b/drivers/crypto/caam/algapi.c
new file mode 100644
index 0000000..03c86a1
--- /dev/null
+++ b/drivers/crypto/caam/algapi.c
@@ -0,0 +1,1073 @@
+/*
+ * caam - Freescale Integrated Security Engine (SEC) device driver
+ *
+ * Copyright (c) 2008,2009 Freescale Semiconductor, Inc.
+ *
+ * Based on talitos Scatterlist Crypto API driver.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * relationship of job descriptors to shared descriptors (SteveC Dec 10 2008):
+ *
+ * ---------------                     ---------------
+ * | JobDesc #1  |-------------------->|  ShareDesc  |
+ * | *(packet 1) |                     |   (PDB)     |
+ * ---------------      |------------->|  (hashKey)  |
+ *       .              |              | (cipherKey) |
+ *       .              |    |-------->| (operation) |
+ * ---------------      |    |         ---------------
+ * | JobDesc #2  |------|    |
+ * | *(packet 2) |           |
+ * ---------------           |
+ *       .                   |
+ *       .                   |
+ * ---------------           |
+ * | JobDesc #3  |------------
+ * | *(packet 3) |
+ * ---------------
+ *
+ * The SharedDesc never changes for a connection unless rekeyed, but
+ * each packet will likely be in a different place. So all we need
+ * to know to process the packet is where the input is, where the
+ * output goes, and what context we want to process with. Context is
+ * in the SharedDesc, packet references in the JobDesc.
+ *
+ * So, a job desc looks like:
+ *
+ * ---------------------
+ * | Header            |
+ * | ShareDesc Pointer |
+ * | SEQ_OUT_PTR       |
+ * | (output buffer)   |
+ * | SEQ_IN_PTR        |
+ * | (input buffer)    |
+ * | LOAD (to DECO)    |
+ * ---------------------
+ */
+
+#include "compat.h"
+#include "regs.h"
+#include "intern.h"
+#include "desc.h"
+#include "jq.h"
+#include "dcl/dcl.h"
+
+/*
+ * crypto alg
+ */
+#define CAAM_CRA_PRIORITY		3000
+#define CAAM_MAX_KEY_SIZE		64
+/* max IV is max of AES_BLOCK_SIZE, DES3_EDE_BLOCK_SIZE */
+#define CAAM_MAX_IV_LENGTH		16
+
+/* hardcoded for now, should probably get from packet data IHL field */
+#define ALGAPI_IP_HDR_LEN 20
+
+#ifdef DEBUG
+/* for print_hex_dumps with line references */
+#define xstr(s) str(s)
+#define str(s) #s
+#define debug(format, arg...) printk(format, arg)
+#else
+#define debug(format, arg...)
+#endif
+
+/*
+ * per-session context
+ */
+struct caam_ctx {
+	struct device *dev;
+	int class1_alg_type;
+	int class2_alg_type;
+	u8 key[CAAM_MAX_KEY_SIZE];
+	unsigned int keylen;
+	unsigned int enckeylen;
+	unsigned int authkeylen;
+	unsigned int authsize;
+	u32 *shared_desc_encap;
+	u32 *shared_desc_decap;
+	u32 shared_desc_encap_phys;
+	u32 shared_desc_decap_phys;
+	int shared_desc_encap_len;
+	int shared_desc_decap_len;
+	spinlock_t first_lock;
+};
+
+static int aead_authenc_setauthsize(struct crypto_aead *authenc,
+				    unsigned int authsize)
+{
+	struct caam_ctx *ctx = crypto_aead_ctx(authenc);
+
+	debug("setauthsize: authsize %d\n", authsize);
+
+	switch (authsize) {
+	case 12: ctx->class2_alg_type = AUTH_TYPE_IPSEC_SHA1HMAC_96;
+		 break;
+	case 20: ctx->class2_alg_type = AUTH_TYPE_IPSEC_SHA1HMAC_160;
+		 break;
+	}
+
+	ctx->authsize = authsize;
+
+	return 0;
+}
+
+static int build_protocol_desc_ipsec_decap(struct caam_ctx *ctx,
+					   struct aead_request *req)
+{
+	gfp_t flags = req->base.flags & CRYPTO_TFM_REQ_MAY_SLEEP ? GFP_KERNEL :
+		      GFP_ATOMIC;
+	u32 *shdesc, *shdescptr;
+	int startidx, endidx;
+
+	/* build shared descriptor for this session */
+	shdesc = kzalloc(36 /* minimum for this protocol */ +
+			 (sizeof(u32) + CAAM_MAX_KEY_SIZE) * 2 +
+			 ALGAPI_IP_HDR_LEN, GFP_DMA | flags);
+	if (!shdesc) {
+		dev_err(ctx->dev, "could not allocate shared descriptor\n");
+		return -ENOMEM;
+	}
+
+	shdescptr = shdesc;
+
+	/* skip shared header (filled in last) */
+	shdescptr++;
+
+	/*
+	 * options byte:
+	 * ipv4
+	 * ip hdr len: fixed 20.
+	 * next hdr offset: fixed 9.
+	 * linux doesn't support Extended Sequence Numbers
+	 * as of time of writing: PDBOPTS_ESPCBC_ESN not set.
+	 */
+	*shdescptr++ = ALGAPI_IP_HDR_LEN << 16 |
+		       9 << 8 | /* next hdr offset (9 bytes in) */
+		       PDBOPTS_ESPCBC_OUTFMT | /* decapsulated output only */
+		       PDBOPTS_ESPCBC_TUNNEL; /* transport not supported yet */
+	/*
+	 * our choice of protocol operation descriptor command
+	 * requires we pretend we have a full-fledged, 36-byte pdb
+	 */
+
+	/* Skip reserveds */
+	shdescptr += 2;
+
+	/* Skip optional ESN */
+	shdescptr++;
+
+	/* copy Seq. Num */
+	*shdescptr++ = (u32 *)((u32 *)sg_virt(req->assoc) + 1);
+
+	/* Skip ARS */
+	shdescptr += 2;
+
+	/* Save current location for computing start index */
+	startidx = shdescptr - shdesc;
+
+	/*
+	 * process keys, starting with class 2/authentication
+	 * This is assuming keys are immediate for sharedesc
+	 */
+	shdescptr = cmd_insert_key(shdescptr, ctx->key,
+				   ctx->authkeylen * 8, PTR_DIRECT,
+				   KEYDST_KEYREG, KEY_CLEAR, ITEM_INLINE,
+				   ITEM_CLASS2);
+
+	/* class 1/cipher key */
+	shdescptr = cmd_insert_key(shdescptr, ctx->key + ctx->authkeylen,
+				   ctx->enckeylen * 8, PTR_DIRECT,
+				   KEYDST_KEYREG, KEY_CLEAR, ITEM_INLINE,
+				   ITEM_CLASS1);
+
+	/* insert the operation command */
+	shdescptr = cmd_insert_proto_op_ipsec(shdescptr, ctx->class1_alg_type,
+					      ctx->class2_alg_type, DIR_DECAP);
+
+	/* update the header with size/offsets */
+	endidx = shdescptr - shdesc + 1; /* add 1 to include header */
+
+	cmd_insert_shared_hdr(shdesc, startidx, endidx, CTX_ERASE, SHR_SERIAL);
+
+#ifdef DEBUG
+	print_hex_dump(KERN_ERR, "shrdesc@"xstr(__LINE__)": ",
+		       DUMP_PREFIX_ADDRESS, 16, 4, shdesc,
+		       (shdescptr - shdesc + 1) * 4, 1);
+	caam_desc_disasm(shdesc);
+#endif
+
+	ctx->shared_desc_decap_len = endidx * sizeof(u32);
+
+	/* now we know the length, stop wasting preallocated shdesc space */
+	ctx->shared_desc_decap = krealloc(shdesc, ctx->shared_desc_decap_len,
+					  GFP_DMA | flags);
+
+	ctx->shared_desc_decap_phys = dma_map_single(ctx->dev, shdesc,
+						     endidx * sizeof(u32),
+						     DMA_BIDIRECTIONAL);
+	if (dma_mapping_error(ctx->dev, ctx->shared_desc_decap_phys)) {
+		dev_err(ctx->dev, "unable to map shared descriptor\n");
+		kfree(ctx->shared_desc_decap);
+		return -ENOMEM;
+	}
+
+	return 0;
+}
+
+static int build_protocol_desc_ipsec_encap(struct caam_ctx *ctx,
+					   struct aead_request *areq)
+{
+	gfp_t flags = areq->base.flags & CRYPTO_TFM_REQ_MAY_SLEEP ? GFP_KERNEL :
+		      GFP_ATOMIC;
+	int  startidx, endidx;
+	u32 *shdesc, *shdescptr;
+
+	/* build shared descriptor for this session */
+	shdesc = kzalloc(36 /* minimum for this protocol */ +
+			 (sizeof(u32) + CAAM_MAX_KEY_SIZE) * 2 +
+			 ALGAPI_IP_HDR_LEN, GFP_DMA | flags);
+	if (!shdesc) {
+		dev_err(ctx->dev, "could not allocate shared descriptor\n");
+		return -ENOMEM;
+	}
+
+	shdescptr = shdesc;
+
+	/* skip shared header (filled in last) */
+	shdescptr++;
+
+	/*
+	 * next header is IPv4 (fixed for tunnel mode)
+	 * options byte: IVsrc is RNG
+         * we do not Prepend IP header to output frame
+	 */
+	*shdescptr++ = 4 << 16 | /* next hdr = IPv4 */
+		       9 << 8 | /* next hdr offset (9 bytes in) */
+		       PDBOPTS_ESPCBC_IPHDRSRC | /* IP header comes from PDB */
+#if !defined(DEBUG)
+		       PDBOPTS_ESPCBC_IVSRC  | /* IV src is RNG */
+#endif
+		       PDBOPTS_ESPCBC_TUNNEL; /* transport not supported yet */
+	/*
+	 * need to pretend we have a full fledged pdb, otherwise get:
+	 * [caam error] IPsec encapsulation: PDB is only 4 bytes, \
+	 * expected at least 36 bytes
+	 */
+
+	/* Skip sequence numbers */
+	shdescptr += 2;
+
+	/* Skip IV */
+#ifdef DEBUG
+	memcpy(shdesc + 4, "myivmyivmyivmyiv", 16);
+#endif
+	shdescptr += 4;
+
+	/* Skip SPI */
+	shdescptr++;
+
+	/* fixed IP header length */
+	*shdescptr++ = ALGAPI_IP_HDR_LEN;
+
+	shdescptr += ALGAPI_IP_HDR_LEN / sizeof(u32);
+
+	/* </pretention> */
+
+	/* Save current location for computing start index */
+	startidx = shdescptr - shdesc;
+
+	/* process keys, starting with class 2/authentication */
+	/* This is assuming keys are immediate for sharedesc */
+	shdescptr = cmd_insert_key(shdescptr, ctx->key, ctx->authkeylen * 8,
+				   PTR_DIRECT, KEYDST_KEYREG, KEY_CLEAR,
+				   ITEM_INLINE, ITEM_CLASS2);
+
+	/* class 1/cipher key */
+	shdescptr = cmd_insert_key(shdescptr, ctx->key + ctx->authkeylen,
+				   ctx->enckeylen * 8, PTR_DIRECT,
+				   KEYDST_KEYREG, KEY_CLEAR, ITEM_INLINE,
+				   ITEM_CLASS1);
+
+	/* insert the operation command */
+	shdescptr = cmd_insert_proto_op_ipsec(shdescptr, ctx->class1_alg_type,
+					      ctx->class2_alg_type, DIR_ENCAP);
+
+	/* update the header with size/offsets */
+	endidx = shdescptr - shdesc + 1; /* add 1 to include header */
+
+	/* get spec-viol with CTX_SAVE here:
+	 * [caam spec-viol] shared descriptor with INIT=1
+	 */
+	cmd_insert_shared_hdr(shdesc, startidx, endidx, CTX_ERASE,
+			      SHR_SERIAL);
+
+#ifdef DEBUG
+	print_hex_dump(KERN_ERR, "shrdesc@"xstr(__LINE__)": ",
+		       DUMP_PREFIX_ADDRESS, 16, 4, shdesc,
+		       (shdescptr - shdesc + 1) * 4, 1);
+	caam_desc_disasm(shdesc);
+#endif
+
+	ctx->shared_desc_encap_len = endidx * sizeof(u32);
+
+	/* now we know the length, stop wasting preallocated shdesc space */
+	ctx->shared_desc_encap = krealloc(shdesc, ctx->shared_desc_encap_len,
+					  GFP_DMA | flags);
+
+	ctx->shared_desc_encap_phys = dma_map_single(ctx->dev, shdesc,
+						     endidx * sizeof(u32),
+						     DMA_BIDIRECTIONAL);
+	if (dma_mapping_error(ctx->dev, ctx->shared_desc_encap_phys)) {
+		dev_err(ctx->dev, "unable to map shared descriptor\n");
+		kfree(ctx->shared_desc_encap);
+		return -ENOMEM;
+	}
+
+	return 0;
+}
+
+static int aead_authenc_setkey(struct crypto_aead *aead,
+			       const u8 *key, unsigned int keylen)
+{
+	struct caam_ctx *ctx = crypto_aead_ctx(aead);
+	struct rtattr *rta = (void *)key;
+	struct crypto_authenc_key_param *param;
+	unsigned int authkeylen;
+	unsigned int enckeylen;
+
+	if (!RTA_OK(rta, keylen))
+		goto badkey;
+
+	if (rta->rta_type != CRYPTO_AUTHENC_KEYA_PARAM)
+		goto badkey;
+
+	if (RTA_PAYLOAD(rta) < sizeof(*param))
+		goto badkey;
+
+	param = RTA_DATA(rta);
+	enckeylen = be32_to_cpu(param->enckeylen);
+
+	key += RTA_ALIGN(rta->rta_len);
+	keylen -= RTA_ALIGN(rta->rta_len);
+
+	if (keylen < enckeylen)
+		goto badkey;
+
+	authkeylen = keylen - enckeylen;
+
+	if (keylen > CAAM_MAX_KEY_SIZE)
+		goto badkey;
+
+	memcpy(&ctx->key, key, keylen);
+
+	ctx->keylen = keylen;
+	ctx->enckeylen = enckeylen;
+	ctx->authkeylen = authkeylen;
+
+	return 0;
+badkey:
+	crypto_aead_set_flags(aead, CRYPTO_TFM_RES_BAD_KEY_LEN);
+	return -EINVAL;
+}
+
+/*
+ * ipsec_esp_edesc - s/w-extended ipsec_esp descriptor
+ * @src_nents: number of segments in input scatterlist
+ * @dst_nents: number of segments in output scatterlist
+ * @assoc_nents: number of segments in associated data (SPI+Seq) scatterlist
+ * @desc: h/w descriptor (variable length; must not exceed MAX_CAAM_DESCSIZE)
+ * @flatbed_phys: bus physical mapped address of flatbed
+ * @flatbed: space for flattened i/o data (if {src,dst}_nents > 1)
+ *           (until s-g support added)
+ * @dma_len: length of dma mapped flatbed space
+ */
+struct ipsec_esp_edesc {
+	int src_nents;
+	int dst_nents;
+	int assoc_nents;
+	u32 desc[MAX_CAAM_DESCSIZE];
+	int dma_len;
+	u32 *flatbed_phys;
+	u8 flatbed[0];
+};
+
+static void ipsec_esp_unmap(struct device *dev,
+			    struct ipsec_esp_edesc *edesc,
+			    struct aead_request *areq)
+{
+	dma_unmap_sg(dev, areq->assoc, edesc->assoc_nents, DMA_TO_DEVICE);
+
+	dma_unmap_sg(dev, areq->src, edesc->src_nents ? : 1,
+		     DMA_BIDIRECTIONAL);
+
+	if (edesc->dma_len)
+		dma_unmap_single(dev, edesc->flatbed_phys, edesc->dma_len,
+				 DMA_BIDIRECTIONAL);
+}
+
+/*
+ * ipsec_esp descriptor callbacks
+ */
+static void ipsec_esp_encrypt_done(struct device *dev, void *desc,
+				   int err, void *context)
+{
+	struct ipsec_esp_edesc *edesc =
+		 container_of(desc, struct ipsec_esp_edesc, desc);
+	struct aead_request *areq = context;
+	struct crypto_aead *aead = crypto_aead_reqtfm(areq);
+	struct caam_ctx *ctx = crypto_aead_ctx(aead);
+	int ivsize = crypto_aead_ivsize(aead);
+
+	ipsec_esp_unmap(dev, edesc, areq);
+
+	if (!err && edesc->dma_len) {
+#ifdef DEBUG
+		print_hex_dump(KERN_ERR, "flatbed@"xstr(__LINE__)": ",
+			       DUMP_PREFIX_ADDRESS, 16, 4, &edesc->flatbed[0],
+			       areq->assoclen + 36 + areq->cryptlen +
+			       ctx->authsize, 1);
+#endif
+		/* copy IV to giv */
+		memcpy(sg_virt(areq->assoc) + areq->assoclen,
+		       &edesc->flatbed[areq->assoclen], ivsize);
+
+		/* copy ciphertext and generated ICV to dst */
+		sg_copy_from_buffer(areq->dst, edesc->dst_nents ? : 1,
+				    &edesc->flatbed[areq->assoclen + ivsize],
+				    areq->cryptlen + ctx->authsize);
+#ifdef DEBUG
+		print_hex_dump(KERN_ERR, "assocout@"xstr(__LINE__)": ",
+			       DUMP_PREFIX_ADDRESS, 16, 4, sg_virt(areq->assoc),
+			       areq->assoclen + areq->cryptlen +
+			       ctx->authsize + 36, 1);
+#endif
+	}
+
+	kfree(edesc);
+
+	aead_request_complete(areq, err);
+}
+
+static void ipsec_esp_decrypt_done(struct device *dev, void *desc, int err,
+				   void *context)
+{
+	struct ipsec_esp_edesc *edesc =
+		 container_of(desc, struct ipsec_esp_edesc, desc);
+	struct aead_request *areq = context;
+	struct crypto_aead *aead = crypto_aead_reqtfm(areq);
+	struct caam_ctx *ctx = crypto_aead_ctx(aead);
+	int ivsize = crypto_aead_ivsize(aead);
+
+	ipsec_esp_unmap(dev, edesc, areq);
+
+	if (!err && edesc->dma_len) {
+#ifdef DEBUG
+		print_hex_dump(KERN_ERR, "flatbed@"xstr(__LINE__)": ",
+			       DUMP_PREFIX_ADDRESS, 16, 4, &edesc->flatbed[0],
+			       areq->assoclen + 36 + areq->cryptlen +
+			       ctx->authsize, 1);
+#endif
+		/* copy ciphertext and generated ICV to dst */
+		sg_copy_from_buffer(areq->dst, edesc->dst_nents ? : 1,
+				    &edesc->flatbed[ALGAPI_IP_HDR_LEN +
+				                    areq->assoclen + ivsize],
+				    areq->cryptlen + ctx->authsize);
+#ifdef DEBUG
+		print_hex_dump(KERN_ERR, "assocout@"xstr(__LINE__)": ",
+			       DUMP_PREFIX_ADDRESS, 16, 4, sg_virt(areq->assoc),
+			       areq->assoclen + areq->cryptlen +
+			       ctx->authsize + 36, 1);
+#endif
+	}
+
+	/*
+	 * verify hw auth check passed else return -EBADMSG
+	 */
+	debug("err 0x%08x\n", err);
+	if ((err & JQSTA_CCBERR_ERRID_MASK) == JQSTA_CCBERR_ERRID_ICVCHK)
+		err = -EBADMSG;
+
+
+	kfree(edesc);
+
+	aead_request_complete(areq, err);
+}
+
+/*
+ * fill in and submit ipsec_esp job descriptor
+ */
+static int ipsec_esp(struct ipsec_esp_edesc *edesc, struct aead_request *areq,
+		     u8 *giv, enum protdir direction,
+		     void (*callback) (struct device *dev, void *desc, int err,
+				       void *context))
+{
+	struct crypto_aead *aead = crypto_aead_reqtfm(areq);
+	struct caam_ctx *ctx = crypto_aead_ctx(aead);
+	struct device *dev = ctx->dev;
+	u32 *desc = &edesc->desc[0];
+	u32 *descptr = desc;
+	int startidx, endidx, ret, sg_count, assoc_sg_count, len, padlen;
+	int nbytes, pos, ivsize = crypto_aead_ivsize(aead);
+	u8 *ptr;
+
+#ifdef DEBUG
+	debug("assoclen %d cryptlen %d authsize %d\n",
+	      areq->assoclen, areq->cryptlen,ctx->authsize);
+	print_hex_dump(KERN_ERR, "ipv4hdr@"xstr(__LINE__)": ",
+		       DUMP_PREFIX_ADDRESS, 16, 4,
+		       ((char *)sg_virt(areq->assoc) - ALGAPI_IP_HDR_LEN),
+		       ALGAPI_IP_HDR_LEN, 1);
+	print_hex_dump(KERN_ERR, "inassoc@"xstr(__LINE__)": ",
+		       DUMP_PREFIX_ADDRESS, 16, 4, sg_virt(areq->assoc),
+		       areq->assoclen + ivsize + areq->cryptlen + ctx->authsize, 1);
+#endif
+
+	/* skip job header (filled in last) */
+	descptr++;
+
+	/* skip shared descriptor pointer (filled in later) */
+	descptr++;
+
+	/* Save current location for computing start index later */
+	startidx = descptr - desc;
+
+	/*
+	 * insert the SEQ IN (data in) command
+	 * assoc is bidirectional because we're using the protocol descriptor
+	 * and encap takes SPI + seq from PDB.
+	 */
+	assoc_sg_count = dma_map_sg(dev, areq->assoc, edesc->assoc_nents ? : 1,
+				    DMA_BIDIRECTIONAL);
+	if (areq->src == areq->dst)
+		sg_count = dma_map_sg(dev, areq->src, edesc->src_nents ? : 1,
+				      DMA_BIDIRECTIONAL);
+	else
+		sg_count = dma_map_sg(dev, areq->src, edesc->src_nents ? : 1,
+				      DMA_TO_DEVICE);
+	if (direction == DIR_ENCAP) {
+		if (!edesc->dma_len) {
+			ptr = (u8 *)sg_dma_address(areq->src);
+			padlen = *(u8 *)((u8 *)sg_virt(areq->src)
+					 + areq->cryptlen - 2);
+		} else {
+			/* we might want to cp this to the PDB instead */
+			nbytes = sg_copy_to_buffer(areq->assoc,
+						   assoc_sg_count,
+						   &edesc->flatbed[0 /*pos*/],
+						   areq->assoclen);
+			BUG_ON(nbytes != areq->assoclen);
+			pos = nbytes;
+			pos += ivsize; /* leave in-place space for output IV */
+			nbytes = sg_copy_to_buffer(areq->src,
+						   sg_count,
+						   &edesc->flatbed[pos],
+						   areq->cryptlen +
+						   ctx->authsize);
+			BUG_ON(nbytes != areq->cryptlen + ctx->authsize);
+#ifdef DEBUG
+			print_hex_dump(KERN_ERR, "flatbed@"xstr(__LINE__)": ",
+				       DUMP_PREFIX_ADDRESS, 16, 4,
+				       &edesc->flatbed[0], areq->assoclen +
+				       ivsize + areq->cryptlen + ctx->authsize
+				       + 16, 1);
+#endif
+			ptr = (u8 *)dma_map_single(dev,
+						   &edesc->flatbed[areq->
+							assoclen + ivsize],
+						   edesc->dma_len,
+						   DMA_BIDIRECTIONAL);
+			edesc->flatbed_phys = ptr;
+			padlen = edesc->flatbed[pos + areq->cryptlen - 2];
+		}
+		debug("padlen is %d\n",padlen);
+		/* cryptlen includes padlen / is blocksize aligned */
+		len = areq->cryptlen - padlen - 2;
+	} else {
+		debug("seq.num %d\n",
+		      *(u32 *)((u32 *)sg_virt(areq->assoc) + 1));
+#undef INJECT_ICV_CHECK_FAILURE
+#ifdef INJECT_ICV_CHECK_FAILURE
+		/*
+		 * intentionally tamper with every 13th packet's data
+		 * to verify proper ICV check result propagation
+		 */
+		if((*(u32 *)((u32 *)sg_virt(areq->assoc) + 1)) &&
+		   (((*(u32 *)((u32 *)sg_virt(areq->assoc) + 1) % 13) == 0))) {
+			dev_warn(dev, "foiling packet data\n");
+			(*(u32 *)((u32 *)sg_virt(areq->assoc) + 13))++;
+		}
+#endif
+		if (!edesc->dma_len) {
+			ptr = (u8 *)sg_dma_address(areq->src) - ivsize -
+			      areq->assoclen - ALGAPI_IP_HDR_LEN;
+		} else {
+			/* manually copy input skb to flatbed */
+			memcpy(&edesc->flatbed[0], sg_virt(areq->assoc)
+			       - ALGAPI_IP_HDR_LEN, ALGAPI_IP_HDR_LEN);
+			pos = ALGAPI_IP_HDR_LEN;
+			/* SPI and sequence number */
+			nbytes = sg_copy_to_buffer(areq->assoc,
+						   assoc_sg_count,
+						   &edesc->flatbed[pos],
+						   areq->assoclen);
+			BUG_ON(nbytes != areq->assoclen);
+			pos += nbytes;
+			/* the IV */
+			memcpy(&edesc->flatbed[pos], (u8 *)sg_virt(areq->assoc)
+			       + areq->assoclen, ivsize);
+			pos += ivsize;
+			/* and the payload */
+			nbytes = sg_copy_to_buffer(areq->src,
+						   sg_count,
+						   &edesc->flatbed[pos],
+						   areq->cryptlen +
+						   ctx->authsize);
+			BUG_ON(nbytes != areq->cryptlen + ctx->authsize);
+#ifdef DEBUG
+			print_hex_dump(KERN_ERR, "flatbed@"xstr(__LINE__)": ",
+				       DUMP_PREFIX_ADDRESS, 16, 4,
+				       &edesc->flatbed[0], areq->assoclen + ivsize +
+				       areq->cryptlen + ctx->authsize + 16, 1);
+#endif
+			ptr = (u8 *)dma_map_single(dev, &edesc->flatbed[0],
+						   edesc->dma_len,
+						   DMA_BIDIRECTIONAL);
+			edesc->flatbed_phys = ptr;
+		}
+		len =  ALGAPI_IP_HDR_LEN + areq->assoclen + ivsize +
+		       areq->cryptlen + ctx->authsize;
+	}
+	descptr = cmd_insert_seq_in_ptr(descptr, ptr, len, PTR_DIRECT);
+
+	/* insert the SEQ OUT (data out) command */
+	sg_count = dma_map_sg(dev, areq->dst, edesc->dst_nents ? : 1,
+			      DMA_BIDIRECTIONAL);
+
+	if (direction == DIR_ENCAP) {
+		len = areq->assoclen + ivsize + areq->cryptlen + ctx->authsize;
+		/*
+		 * if flattening, adjust phys addr to offset of iv data
+		 * within same flatbed
+		 */
+		if (!edesc->dma_len)
+			ptr = (u8 *) sg_dma_address(areq->assoc);
+		else
+			ptr -= areq->assoclen + ivsize;
+	} else {
+		len = areq->cryptlen + ctx->authsize;
+		if (!edesc->dma_len)
+			ptr = (u8 *) sg_dma_address(areq->dst);
+		else
+			ptr += ALGAPI_IP_HDR_LEN + areq->assoclen + ivsize;
+	}
+
+	descptr = cmd_insert_seq_out_ptr(descptr, ptr, len ,PTR_DIRECT);
+
+	/*
+	 * write the job descriptor header with shared descriptor length,
+	 * reverse order execution, and size/offsets.
+	 */
+	endidx = descptr - desc;
+
+	len = (direction == DIR_ENCAP) ? ctx->shared_desc_encap_len
+				       : ctx->shared_desc_decap_len;
+	cmd_insert_hdr(desc, len / sizeof(u32),
+		       endidx, SHR_SERIAL, SHRNXT_SHARED /* has_shared */,
+		       ORDER_REVERSE, DESC_STD /*don't make trusted*/);
+#ifdef DEBUG
+	print_hex_dump(KERN_ERR, "jobdesc@"xstr(__LINE__)": ",
+		       DUMP_PREFIX_ADDRESS, 16, 4, desc,
+		       (descptr - desc + 1) * 4, 1);
+	caam_desc_disasm(desc);
+#endif
+
+	ret = caam_jq_enqueue(ctx->dev, desc, callback, areq);
+	if (!ret)
+		ret = -EINPROGRESS;
+	else {
+		ipsec_esp_unmap(dev, edesc, areq);
+		kfree(edesc);
+	}
+
+	return ret;
+}
+
+/*
+ * derive number of elements in scatterlist
+ */
+static int sg_count(struct scatterlist *sg_list, int nbytes)
+{
+	struct scatterlist *sg = sg_list;
+	int sg_nents = 0;
+
+	while (nbytes) {
+		sg_nents++;
+		nbytes -= sg->length;
+		sg = sg_next(sg);
+	}
+
+	return sg_nents;
+}
+
+/*
+ * allocate and map the ipsec_esp extended descriptor
+ */
+static struct ipsec_esp_edesc *ipsec_esp_edesc_alloc(struct aead_request *areq,
+						     enum protdir direction)
+{
+	struct crypto_aead *aead = crypto_aead_reqtfm(areq);
+	struct caam_ctx *ctx = crypto_aead_ctx(aead);
+	int ivsize = crypto_aead_ivsize(aead);
+	gfp_t flags = areq->base.flags & CRYPTO_TFM_REQ_MAY_SLEEP ? GFP_KERNEL :
+		      GFP_ATOMIC;
+	int assoc_nents, src_nents, dst_nents, alloc_len, dma_len = 0;
+	struct ipsec_esp_edesc *edesc;
+
+	assoc_nents = sg_count(areq->assoc, areq->assoclen);
+	assoc_nents = (assoc_nents == 1) ? 0 : assoc_nents;
+
+	src_nents = sg_count(areq->src, areq->cryptlen + ctx->authsize);
+	src_nents = (src_nents == 1) ? 0 : src_nents;
+
+	if (areq->dst == areq->src) {
+		dst_nents = src_nents;
+	} else {
+		dev_err(ctx->dev, "src!=dst case not handled\n");
+		BUG();
+		dst_nents = sg_count(areq->dst, areq->cryptlen + ctx->authsize);
+		dst_nents = (dst_nents == 1) ? 0 : dst_nents;
+	}
+
+	/*
+	 * allocate space for base edesc plus the link tables,
+	 * allowing for two separate entries for ICV and generated ICV (+ 2),
+	 * and the ICV data itself
+	 */
+	alloc_len = sizeof(struct ipsec_esp_edesc);
+	if (assoc_nents || src_nents || dst_nents) {
+		/* size for worst case (encap/decap) */
+		dma_len = ALGAPI_IP_HDR_LEN + areq->assoclen + ivsize +
+			  areq->cryptlen + ivsize /* no max - we know the pad */
+			  + ctx->authsize;
+	}
+
+	edesc = kmalloc(sizeof(struct ipsec_esp_edesc) + dma_len,
+		        GFP_DMA | flags);
+	if (!edesc) {
+		dev_err(ctx->dev, "could not allocate extended descriptor\n");
+		return ERR_PTR(-ENOMEM);
+	}
+
+	edesc->assoc_nents = assoc_nents;
+	edesc->src_nents = src_nents;
+	edesc->dst_nents = dst_nents;
+	edesc->dma_len = dma_len;
+
+	return edesc;
+}
+
+static int aead_authenc_encrypt(struct aead_request *req)
+{
+	printk("%s unimplemented\n", __FUNCTION__);
+
+	return -EINVAL;
+}
+
+static int aead_authenc_encrypt_first(struct aead_request *req)
+{
+	printk("%s unimplemented\n", __FUNCTION__);
+
+	return -EINVAL;
+}
+
+static int aead_authenc_decrypt(struct aead_request *req)
+{
+	struct crypto_aead *aead = crypto_aead_reqtfm(req);
+	struct caam_ctx *ctx = crypto_aead_ctx(aead);
+	struct ipsec_esp_edesc *edesc;
+
+	req->cryptlen -= ctx->authsize;
+
+	/* allocate extended descriptor */
+	edesc = ipsec_esp_edesc_alloc(req, DIR_DECAP);
+	if (IS_ERR(edesc))
+		return PTR_ERR(edesc);
+
+	/* insert shared descriptor pointer */
+	edesc->desc[1] = ctx->shared_desc_decap_phys;
+
+	return ipsec_esp(edesc, req, NULL, DIR_DECAP, ipsec_esp_decrypt_done);
+}
+
+static int aead_authenc_decrypt_first(struct aead_request *req)
+{
+	struct crypto_aead *aead = crypto_aead_reqtfm(req);
+	struct caam_ctx *ctx = crypto_aead_ctx(aead);
+	int err;
+
+        spin_lock_bh(&ctx->first_lock);
+        if (crypto_aead_crt(aead)->decrypt != aead_authenc_decrypt_first)
+                goto unlock;
+
+	err = build_protocol_desc_ipsec_decap(ctx, req);
+	if (err) {
+		spin_unlock_bh(&ctx->first_lock);
+		return err;
+	}
+
+	/* copy sequence number to PDB */
+	*(u32 *)(ctx->shared_desc_decap + 5) =
+		*(u32 *)((u32 *)sg_virt(req->assoc) + 1);
+
+        crypto_aead_crt(aead)->decrypt = aead_authenc_decrypt;
+unlock:
+        spin_unlock_bh(&ctx->first_lock);
+
+	return aead_authenc_decrypt(req);
+}
+
+static int aead_authenc_givencrypt(struct aead_givcrypt_request *req)
+{
+	struct aead_request *areq = &req->areq;
+	struct crypto_aead *aead = crypto_aead_reqtfm(areq);
+	struct caam_ctx *ctx = crypto_aead_ctx(aead);
+	struct ipsec_esp_edesc *edesc;
+
+	/* allocate extended descriptor */
+	edesc = ipsec_esp_edesc_alloc(areq, DIR_ENCAP);
+	if (IS_ERR(edesc))
+		return PTR_ERR(edesc);
+
+	/* insert shared descriptor pointer */
+	edesc->desc[1] = ctx->shared_desc_encap_phys;
+
+	return ipsec_esp(edesc, areq, req->giv, DIR_ENCAP,
+			 ipsec_esp_encrypt_done);
+}
+
+static int aead_authenc_givencrypt_first(struct aead_givcrypt_request *req)
+{
+	struct aead_request *areq = &req->areq;
+	struct crypto_aead *aead = crypto_aead_reqtfm(areq);
+	struct caam_ctx *ctx = crypto_aead_ctx(aead);
+	int err;
+
+        spin_lock_bh(&ctx->first_lock);
+        if (crypto_aead_crt(aead)->givencrypt != aead_authenc_givencrypt_first)
+                goto unlock;
+
+	err = build_protocol_desc_ipsec_encap(ctx, areq);
+	if (err) {
+		spin_unlock_bh(&ctx->first_lock);
+		return err;
+	}
+
+	/* copy sequence number to PDB */
+	*(u64 *)(ctx->shared_desc_encap + 2) = req->seq;
+
+	/* and the SPI */
+	*(ctx->shared_desc_encap + 8) = *((u32 *)sg_virt(areq->assoc));
+
+        crypto_aead_crt(aead)->givencrypt = aead_authenc_givencrypt;
+unlock:
+        spin_unlock_bh(&ctx->first_lock);
+
+	return aead_authenc_givencrypt(req);
+}
+
+struct caam_alg_template {
+	char name[CRYPTO_MAX_ALG_NAME];
+	char driver_name[CRYPTO_MAX_ALG_NAME];
+	unsigned int blocksize;
+	struct aead_alg aead;
+	struct device *dev;
+	int class1_alg_type;
+	int class2_alg_type;
+};
+
+static struct caam_alg_template driver_algs[] = {
+	/* single-pass ipsec_esp descriptor */
+	{
+		.name = "authenc(hmac(sha1),cbc(aes))",
+		.driver_name = "authenc-hmac-sha1-cbc-aes-caam",
+		.blocksize = AES_BLOCK_SIZE,
+		.aead = {
+			.setkey = aead_authenc_setkey,
+			.setauthsize = aead_authenc_setauthsize,
+			.encrypt = aead_authenc_encrypt_first,
+			.decrypt = aead_authenc_decrypt_first,
+			.givencrypt = aead_authenc_givencrypt_first,
+			.geniv = "<built-in>",
+			.ivsize = AES_BLOCK_SIZE,
+			.maxauthsize = SHA1_DIGEST_SIZE,
+			},
+		.class1_alg_type = CIPHER_TYPE_IPSEC_AESCBC,
+		.class2_alg_type = AUTH_TYPE_IPSEC_SHA1HMAC_96,
+	},
+	{
+		.name = "authenc(hmac(sha1),cbc(des))",
+		.driver_name = "authenc-hmac-sha1-cbc-des-caam",
+		.blocksize = DES_BLOCK_SIZE,
+		.aead = {
+			.setkey = aead_authenc_setkey,
+			.setauthsize = aead_authenc_setauthsize,
+			.encrypt = aead_authenc_encrypt_first,
+			.decrypt = aead_authenc_decrypt_first,
+			.givencrypt = aead_authenc_givencrypt_first,
+			.geniv = "<built-in>",
+			.ivsize = DES_BLOCK_SIZE,
+			.maxauthsize = SHA1_DIGEST_SIZE,
+			},
+		.class1_alg_type = CIPHER_TYPE_IPSEC_DESCBC,
+		.class2_alg_type = AUTH_TYPE_IPSEC_SHA1HMAC_96,
+	},
+};
+
+struct caam_crypto_alg {
+	struct list_head entry;
+	struct device *dev;
+	int class1_alg_type;
+	int class2_alg_type;
+	struct crypto_alg crypto_alg;
+};
+
+static int caam_cra_init(struct crypto_tfm *tfm)
+{
+	struct crypto_alg *alg = tfm->__crt_alg;
+	struct caam_crypto_alg *caam_alg =
+		 container_of(alg, struct caam_crypto_alg, crypto_alg);
+	struct caam_ctx *ctx = crypto_tfm_ctx(tfm);
+
+	/* update context with ptr to dev */
+	ctx->dev = caam_alg->dev;
+
+	/* copy descriptor header template value */
+	ctx->class1_alg_type = caam_alg->class1_alg_type;
+	ctx->class2_alg_type = caam_alg->class2_alg_type;
+
+	spin_lock_init(&ctx->first_lock);
+
+	return 0;
+}
+
+static void caam_cra_exit(struct crypto_tfm *tfm)
+{
+	struct caam_ctx *ctx = crypto_tfm_ctx(tfm);
+
+	if (!dma_mapping_error(ctx->dev, ctx->shared_desc_encap_phys))
+		dma_unmap_single(ctx->dev, ctx->shared_desc_encap_phys,
+				 ctx->shared_desc_encap_len, DMA_BIDIRECTIONAL);
+	kfree(ctx->shared_desc_encap);
+
+	if (!dma_mapping_error(ctx->dev, ctx->shared_desc_decap_phys))
+		dma_unmap_single(ctx->dev, ctx->shared_desc_decap_phys,
+				 ctx->shared_desc_decap_len, DMA_BIDIRECTIONAL);
+	kfree(ctx->shared_desc_decap);
+}
+
+void caam_algapi_remove(struct device *dev)
+{
+	struct caam_drv_private *priv = dev_get_drvdata(dev);
+	struct caam_crypto_alg *t_alg, *n;
+
+	if (!priv->alg_list.next)
+		return;
+
+	list_for_each_entry_safe(t_alg, n, &priv->alg_list, entry) {
+		crypto_unregister_alg(&t_alg->crypto_alg);
+		list_del(&t_alg->entry);
+		kfree(t_alg);
+	}
+}
+
+static struct caam_crypto_alg *caam_alg_alloc(struct device *dev,
+					      struct caam_alg_template
+					      *template)
+{
+	struct caam_crypto_alg *t_alg;
+	struct crypto_alg *alg;
+
+	t_alg = kzalloc(sizeof(struct caam_crypto_alg), GFP_KERNEL);
+	if (!t_alg) {
+		dev_err(dev, "failed to allocate t_alg\n");
+		return ERR_PTR(-ENOMEM);
+	}
+
+	alg = &t_alg->crypto_alg;
+
+	snprintf(alg->cra_name, CRYPTO_MAX_ALG_NAME, "%s", template->name);
+	snprintf(alg->cra_driver_name, CRYPTO_MAX_ALG_NAME, "%s",
+		 template->driver_name);
+	alg->cra_module = THIS_MODULE;
+	alg->cra_init = caam_cra_init;
+	alg->cra_exit = caam_cra_exit;
+	alg->cra_priority = CAAM_CRA_PRIORITY;
+	alg->cra_flags = CRYPTO_ALG_TYPE_AEAD | CRYPTO_ALG_ASYNC;
+	alg->cra_blocksize = template->blocksize;
+	alg->cra_alignmask = 0;
+	alg->cra_type = &crypto_aead_type;
+	alg->cra_ctxsize = sizeof(struct caam_ctx);
+	alg->cra_u.aead = template->aead;
+
+	t_alg->class1_alg_type = template->class1_alg_type;
+	t_alg->class2_alg_type = template->class2_alg_type;
+	t_alg->dev = dev;
+
+	return t_alg;
+}
+
+void caam_jq_algapi_init(struct device *ctrldev)
+{
+	struct caam_drv_private *priv = dev_get_drvdata(ctrldev);
+	struct device *dev;
+	int i, err;
+
+	INIT_LIST_HEAD(&priv->alg_list);
+
+	err = caam_jq_register(ctrldev, &dev);
+	if (err) {
+		dev_err(ctrldev, "algapi error in job queue registration: %d\n",
+			err);
+		return;
+	}
+
+	/* register crypto algorithms the device supports */
+	for (i = 0; i < ARRAY_SIZE(driver_algs); i++) {
+		/* TODO: check if h/w supports alg */
+		struct caam_crypto_alg *t_alg;
+
+		t_alg = caam_alg_alloc(dev, &driver_algs[i]);
+		if (IS_ERR(t_alg)) {
+			err = PTR_ERR(t_alg);
+			dev_warn(dev, "%s alg registration failed\n",
+				t_alg->crypto_alg.cra_driver_name);
+			continue;
+		}
+
+		err = crypto_register_alg(&t_alg->crypto_alg);
+		if (err) {
+			dev_warn(dev, "%s alg registration failed\n",
+				t_alg->crypto_alg.cra_driver_name);
+			kfree(t_alg);
+		} else {
+			list_add_tail(&t_alg->entry, &priv->alg_list);
+			dev_info(dev, "%s\n",
+				 t_alg->crypto_alg.cra_driver_name);
+		}
+	}
+
+	priv->algapi_jq = dev;
+}
diff --git a/drivers/crypto/caam/compat.h b/drivers/crypto/caam/compat.h
new file mode 100644
index 0000000..b44d0ec
--- /dev/null
+++ b/drivers/crypto/caam/compat.h
@@ -0,0 +1,64 @@
+/*
+ * CAAM Descriptor Construction Library
+ * Application level usage definitions and prototypes
+ *
+ * Copyright (c) 2008, 2009, Freescale Semiconductor, Inc.
+ * All Rights Reserved
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef CAAM_COMPAT_H
+#define CAAM_COMPAT_H
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/mod_devicetable.h>
+#include <linux/device.h>
+#include <linux/interrupt.h>
+#include <linux/crypto.h>
+#include <linux/hw_random.h>
+#include <linux/of_platform.h>
+#include <linux/dma-mapping.h>
+#include <linux/io.h>
+#include <linux/spinlock.h>
+#include <linux/rtnetlink.h>
+#include <linux/in.h>
+#include <linux/slab.h>
+#include <linux/types.h>
+
+#include <crypto/algapi.h>
+#include <crypto/aes.h>
+#include <crypto/des.h>
+#include <crypto/sha.h>
+#include <crypto/aead.h>
+#include <crypto/authenc.h>
+
+#define PRINT(format, arg...) printk(format, ##arg)
+
+#endif /* !defined(CAAM_COMPAT_H) */
diff --git a/drivers/crypto/caam/ctrl.c b/drivers/crypto/caam/ctrl.c
new file mode 100644
index 0000000..8360dd5
--- /dev/null
+++ b/drivers/crypto/caam/ctrl.c
@@ -0,0 +1,239 @@
+/*
+ * CAAM control-plane driver backend
+ * Controller-level driver, kernel property detection, initialization
+ *
+ * Copyright (c) 2008, 2009, Freescale Semiconductor, Inc.
+ * All Rights Reserved
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <linux/of_platform.h>
+#include <linux/interrupt.h>
+
+#include "regs.h"
+#include "intern.h"
+#include "jq.h"
+
+/*
+ * Use of CONFIG_PPC throughout is used to switch in code
+ * native to Power, which is all that's implemented or tested at
+ * this time. Of particular note, this turns on large proportion
+ * of Power-specific fdt probe and detection code.
+ *
+ * Future variants of this driver will also be ported to ARM
+ * architectures, which will lack the fdt-dependent constructs.
+ * Therefore, they will have their own probe/initialization code
+ * inserted at that time. For now, CONFIG_PPC will be used to
+ * switch in sections that are known fdt-dependent, although
+ * these may need to transition to CONFIG_OF if ARM architectures
+ * were to take up use of an fdt.
+ */
+
+#ifdef CONFIG_PPC
+
+int caam_jq_shutdown(struct device *dev);
+
+static int caam_remove(struct of_device *ofdev)
+{
+	struct device *ctrldev;
+	struct caam_drv_private *ctrlpriv;
+	struct caam_drv_private_jq *jqpriv;
+	int q;
+
+	ctrldev = &ofdev->dev;
+	ctrlpriv = dev_get_drvdata(ctrldev);
+
+	/* shut down JobQs */
+	for (q = 0; q < ctrlpriv->total_jobqs; q++) {
+		caam_jq_shutdown(ctrlpriv->jqdev[q]);
+		jqpriv = dev_get_drvdata(ctrlpriv->jqdev[q]);
+		irq_dispose_mapping(jqpriv->irq);
+	}
+
+	/* Disconnect QI */
+	if (ctrlpriv->qi_present)
+		wr_reg32(&ctrlpriv->qi->qi_control_lo, QICTL_STOP);
+
+	/* Unmap controller region */
+	iounmap(&ctrlpriv->ctrl);
+
+	kfree(ctrlpriv->jqdev);
+	kfree(ctrlpriv);
+
+	return 0;
+}
+
+
+int caam_jq_probe(struct of_device *ofdev,
+		  struct device_node *np,
+		  int q);
+
+/* Probe routine for CAAM top (controller) level */
+static int caam_probe(struct of_device *ofdev,
+		      const struct of_device_id *devmatch)
+{
+	int d, q, qspec;
+	const unsigned int *pty;
+	struct device *dev;
+	struct device_node *nprop, *np;
+	struct caam_full *topregs;
+	struct caam_drv_private *ctrlpriv;
+
+	ctrlpriv = kzalloc(sizeof(struct caam_drv_private), GFP_KERNEL);
+	if (!ctrlpriv)
+		return -ENOMEM;
+
+	dev = &ofdev->dev;
+	dev_set_drvdata(dev, ctrlpriv);
+	ctrlpriv->ofdev = ofdev;
+	nprop = ofdev->node;
+
+	/* Get configuration properties from device tree */
+	/* First, get register page */
+	ctrlpriv->ctrl = of_iomap(nprop, 0);
+	if (ctrlpriv->ctrl == NULL) {
+		dev_err(dev, "caam: of_iomap() failed\n");
+		return -ENOMEM;
+	}
+
+	/* topregs used to derive pointers to CAAM sub-blocks only */
+	topregs = (struct caam_full *)ctrlpriv->ctrl;
+
+	/* Get the IRQ of the controller (for security violations only) */
+	ctrlpriv->secvio_irq = of_irq_to_resource(nprop, 0, NULL);
+
+	/*
+	 * Device tree provides no information on the actual number
+	 * of DECOs instantiated in the device. Total available will
+	 * have to be version-register-derived.
+	 *
+	 * In practice, their only practical use is as a debug tool.
+	 * Since the controller iomaps all possible CAAM registers,
+	 * this just calculates handy pointers to deco registers in
+	 * pre-mapped space.
+	 */
+	for (d = 0; d < 5; d++)
+		ctrlpriv->deco[d] = &topregs->deco[d];
+
+	/*
+	 * Detect and enable JobQs
+	 * First, find out how many queues spec'ed, allocate references
+	 * for all, then go probe each one.
+	 */
+	qspec = 0;
+	for_each_compatible_node(np, NULL, "fsl,sec4.0-job-queue")
+		qspec++;
+	ctrlpriv->jqdev = kzalloc(sizeof(struct device *) * qspec, GFP_KERNEL);
+	if (ctrlpriv->jqdev == NULL) {
+		iounmap(&ctrlpriv->ctrl);
+		return -ENOMEM;
+	}
+
+	q = 0;
+	ctrlpriv->total_jobqs = 0;
+	for_each_compatible_node(np, NULL, "fsl,sec4.0-job-queue") {
+		caam_jq_probe(ofdev, np, q);
+		ctrlpriv->total_jobqs++;
+		q++;
+	}
+
+	/* Check to see if QI present. If so, enable */
+	pty = of_get_property(nprop, "fsl,qi-spids", NULL);
+	if (pty) {
+		ctrlpriv->qi_present = 1;
+		ctrlpriv->qi_spids = *pty;
+		ctrlpriv->qi = &topregs->qi;
+		/* This is all that's reqired to physically enable QI */
+		wr_reg32(&ctrlpriv->qi->qi_control_lo, QICTL_DQEN);
+	} else {
+		ctrlpriv->qi_present = 0;
+		ctrlpriv->qi_spids = 0;
+	}
+
+	/* If no QI and no queues specified, quit and go home */
+	if ((!ctrlpriv->qi_present) && (!ctrlpriv->total_jobqs)) {
+		dev_err(dev, "no queues configured, terminating\n");
+		caam_remove(ofdev);
+		return -ENOMEM;
+	}
+
+	/* NOTE: RTIC detection ought to go here, around Si time */
+
+	/* Initialize queue allocator lock */
+	spin_lock_init(&ctrlpriv->jq_alloc_lock);
+
+	/* Report "alive" for developer to see */
+	dev_info(dev, "device ID = 0x%016llx\n",
+		 rd_reg64(&ctrlpriv->ctrl->perfmon.caam_id));
+	dev_info(dev, "job queues = %d, qi = %d\n",
+		 ctrlpriv->total_jobqs, ctrlpriv->qi_present);
+
+#ifdef CONFIG_CRYPTO_DEV_FSL_CAAM_CRYPTO_API
+	/* register algorithms with scatterlist crypto API */
+	caam_jq_algapi_init(dev);
+#endif
+
+	return 0;
+}
+
+static struct of_device_id caam_match[] = {
+	{
+		.compatible = "fsl,sec4.0",
+	},
+	{},
+};
+MODULE_DEVICE_TABLE(of, caam_match);
+
+static struct of_platform_driver caam_driver = {
+	.name        = "caam",
+	.match_table = caam_match,
+	.probe       = caam_probe,
+	.remove      = __devexit_p(caam_remove),
+};
+
+static int __init caam_base_init(void)
+{
+	return of_register_platform_driver(&caam_driver);
+}
+
+static void __exit caam_base_exit(void)
+{
+	return of_unregister_platform_driver(&caam_driver);
+}
+#else /* not CONFIG_PPC */
+      /* need ARM-specific probe/detect/map/initialize/shutdown */
+#endif
+
+module_init(caam_base_init);
+module_exit(caam_base_exit);
+
+MODULE_LICENSE("Dual BSD/GPL");
+MODULE_DESCRIPTION("FSL CAAM request backend");
+MODULE_AUTHOR("Freescale Semiconductor - NMG/STC");
diff --git a/drivers/crypto/caam/dcl/Makefile b/drivers/crypto/caam/dcl/Makefile
new file mode 100644
index 0000000..2640007
--- /dev/null
+++ b/drivers/crypto/caam/dcl/Makefile
@@ -0,0 +1,14 @@
+
+#
+# Makefile for CAAM descriptor builder library
+#
+# NOTE: at this point in time, this simply builds objects to link
+# into the kernel as-is. This could be reconfigured as a library at
+# some point in time, especially if a means to share that library
+# with LWE becomes practical.
+#
+#
+obj-$(CONFIG_CRYPTO_DEV_FSL_CAAM_DC_LIB) += caam_dcl.o
+
+caam_dcl-objs := disasm.o protoshared.o cmdgen.o jobdesc.o
+
diff --git a/drivers/crypto/caam/dcl/cmdgen.c b/drivers/crypto/caam/dcl/cmdgen.c
new file mode 100644
index 0000000..f3b2d10
--- /dev/null
+++ b/drivers/crypto/caam/dcl/cmdgen.c
@@ -0,0 +1,335 @@
+/*
+ * CAAM Descriptor Construction Library
+ * Descriptor Command Generator
+ *
+ * Copyright (c) 2008, 2009, Freescale Semiconductor, Inc.
+ * All Rights Reserved
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "../compat.h"
+#include "dcl.h"
+
+/*
+ * NOTE: CAAM can be configured for either 32-bit mode or 36-bit mode
+ * at core initialization time. At this time, cmdgen assumes 32-bit
+ * mode, but an option to handle either case needs to be added to it,
+ * either as a build-time or run-time option.
+ */
+
+
+u_int32_t *cmd_insert_shared_hdr(u_int32_t *descwd, u_int8_t startidx,
+				 u_int8_t desclen, enum ctxsave ctxsave,
+				 enum shrst share)
+{
+	*descwd = CMD_SHARED_DESC_HDR | HDR_ONE |
+		  ((startidx & HDR_START_IDX_MASK) << HDR_START_IDX_SHIFT) |
+		  (desclen & HDR_DESCLEN_SHR_MASK) |
+		  (share << HDR_SD_SHARE_SHIFT) |
+		  ((ctxsave == CTX_SAVE) ? HDR_SAVECTX : 0);
+
+	return descwd + 1;
+}
+
+u_int32_t *cmd_insert_hdr(u_int32_t *descwd, u_int8_t startidx,
+			  u_int8_t desclen, enum shrst share,
+			  enum shrnext sharenext, enum execorder reverse,
+			  enum mktrust mktrusted)
+{
+	*descwd = CMD_DESC_HDR | HDR_ONE |
+		  ((startidx & HDR_START_IDX_MASK) << HDR_START_IDX_SHIFT) |
+		  (desclen & HDR_DESCLEN_MASK) |
+		  (share << HDR_SD_SHARE_SHIFT) |
+		  ((sharenext == SHRNXT_SHARED) ? HDR_SHARED : 0) |
+		  ((reverse == ORDER_REVERSE) ? HDR_REVERSE : 0) |
+		  ((mktrusted = DESC_SIGN) ? HDR_MAKE_TRUSTED : 0);
+
+	return descwd + 1;
+}
+
+u_int32_t *cmd_insert_key(u_int32_t *descwd, u_int8_t *key, u_int32_t keylen,
+			  enum ref_type sgref, enum key_dest dest,
+			  enum key_cover cover, enum item_inline imm,
+			  enum item_purpose purpose)
+{
+	u_int32_t *nextwd, *keybuf;
+	u_int32_t  keysz, keywds;
+
+	if ((!descwd) || (!key))
+		return 0;
+
+	/* If PK 'e' or AF SBOX load, can't be class 2 key */
+	if (((dest == KEYDST_PK_E) || (dest == KEYDST_AF_SBOX)) &&
+	    (purpose == ITEM_CLASS2))
+		return 0;
+
+	/* sg table can't be inlined */
+	if ((sgref == PTR_SGLIST) && (imm == ITEM_INLINE))
+		return 0;
+
+	nextwd = descwd;
+
+	/* Convert size (in bits) to adequate byte length */
+	keysz = ((keylen & KEY_LENGTH_MASK) >> 3);
+	if (keylen & 0x00000007)
+		keysz++;
+
+	/* Build command word */
+	*nextwd = CMD_KEY;
+	switch (dest) {
+	case KEYDST_KEYREG:
+		*nextwd |= KEY_DEST_CLASS_REG;
+		break;
+
+	case KEYDST_PK_E:
+		*nextwd |= KEY_DEST_PKHA_E;
+		break;
+
+	case KEYDST_AF_SBOX:
+		*nextwd |= KEY_DEST_AFHA_SBOX;
+		break;
+
+	case KEYDST_MD_SPLIT:
+		*nextwd |= KEY_DEST_MDHA_SPLIT;
+		break;
+	}
+
+	if (cover == KEY_COVERED)
+		*nextwd |= KEY_ENC;
+
+	if (imm == ITEM_INLINE)
+		*nextwd |= KEY_IMM;
+
+	switch (purpose) {
+	case ITEM_CLASS1:
+		*nextwd |= CLASS_1;
+		break;
+
+	case ITEM_CLASS2:
+		*nextwd |= CLASS_2;
+		break;
+
+	default:
+		return 0;
+	};
+	if (sgref == PTR_SGLIST)
+		*nextwd |= KEY_SGF;
+
+	*nextwd++ |= keysz;
+
+	if (imm == ITEM_INLINE) {
+		keywds = keysz >> 2;
+		keybuf = (u_int32_t *)key;
+		while (keywds) {
+			*nextwd++ = *keybuf++;
+			keywds--;
+		}
+	} else
+		*nextwd++ = (u_int32_t)key;
+	return nextwd;
+}
+
+u_int32_t *cmd_insert_proto_op_ipsec(u_int32_t *descwd, u_int8_t cipheralg,
+				     u_int8_t authalg, enum protdir dir)
+{
+	*descwd = CMD_OPERATION | OP_PCLID_IPSEC;
+
+	switch (dir) {
+	case DIR_ENCAP:
+		*descwd |= OP_TYPE_ENCAP_PROTOCOL;
+		break;
+
+	case DIR_DECAP:
+		*descwd |= OP_TYPE_DECAP_PROTOCOL;
+		break;
+
+	default:
+		return 0;
+	}
+
+	/*
+	 * Note that these cipher selectors match the PFKEY selectors
+	 * almost 1 for 1, so this is really little more than an error
+	 * check
+	 */
+	switch (cipheralg) {
+	case CIPHER_TYPE_IPSEC_DESCBC:
+		*descwd |= OP_PCL_IPSEC_DES;
+		break;
+
+	case CIPHER_TYPE_IPSEC_3DESCBC:
+		*descwd |= OP_PCL_IPSEC_3DES;
+		break;
+
+	case CIPHER_TYPE_IPSEC_AESCBC:
+		*descwd |= OP_PCL_IPSEC_AES_CBC;
+		break;
+
+	case CIPHER_TYPE_IPSEC_AESCTR:
+		*descwd |= OP_PCL_IPSEC_AES_CTR;
+		break;
+
+	case CIPHER_TYPE_IPSEC_AES_CCM_ICV8:
+		*descwd |= OP_PCL_IPSEC_AES_CCM8;
+		break;
+
+	case CIPHER_TYPE_IPSEC_AES_CCM_ICV12:
+		*descwd |= OP_PCL_IPSEC_AES_CCM12;
+		break;
+
+	case CIPHER_TYPE_IPSEC_AES_CCM_ICV16:
+		*descwd |= OP_PCL_IPSEC_AES_CCM16;
+		break;
+
+	case CIPHER_TYPE_IPSEC_AES_GCM_ICV8:
+		*descwd |= OP_PCL_IPSEC_AES_GCM8;
+		break;
+
+	case CIPHER_TYPE_IPSEC_AES_GCM_ICV12:
+		*descwd |= OP_PCL_IPSEC_AES_GCM12;
+		break;
+
+	case CIPHER_TYPE_IPSEC_AES_GCM_ICV16:
+		*descwd |= OP_PCL_IPSEC_AES_GCM16;
+		break;
+
+	default:
+		return 0;
+	}
+
+	/*
+	 * Authentication selectors. These do not match the PFKEY
+	 * selectors
+	 */
+
+	switch (authalg) {
+	case AUTH_TYPE_IPSEC_MD5HMAC_96:
+		*descwd |= OP_PCL_IPSEC_HMAC_MD5_96;
+		break;
+
+	case AUTH_TYPE_IPSEC_SHA1HMAC_96:
+		*descwd |= OP_PCL_IPSEC_HMAC_SHA1_96;
+		break;
+
+	case AUTH_TYPE_IPSEC_AESXCBCMAC_96:
+		*descwd |= OP_PCL_IPSEC_AES_XCBC_MAC_96;
+		break;
+
+	case AUTH_TYPE_IPSEC_SHA1HMAC_160:
+		*descwd |= OP_PCL_IPSEC_HMAC_SHA1_160;
+		break;
+
+	case AUTH_TYPE_IPSEC_SHA2HMAC_256:
+		*descwd |= OP_PCL_IPSEC_HMAC_SHA2_256_128;
+		break;
+
+	case AUTH_TYPE_IPSEC_SHA2HMAC_384:
+		*descwd |= OP_PCL_IPSEC_HMAC_SHA2_384_192;
+		break;
+
+	case AUTH_TYPE_IPSEC_SHA2HMAC_512:
+		*descwd |= OP_PCL_IPSEC_HMAC_SHA2_512_256;
+		break;
+
+	default:
+		return 0;
+	}
+
+	return descwd++;
+}
+
+/*
+ * FIXME: the following two functions are functionally identical
+ * 	  and need refactoring, including macro definitions - e.g,
+ * 	  the SGF bit doesn't change among commands.
+ */
+int *cmd_insert_seq_in_ptr(u_int32_t *descwd, u_int32_t *ptr, u_int32_t len,
+			   enum ref_type sgref)
+{
+	*descwd = CMD_SEQ_IN_PTR | ((sgref == PTR_SGLIST) ? SQIN_SGF : 0) | len;
+
+	*(descwd + 1) = (u_int32_t)ptr;
+
+	if (len > 0xffff) {
+		*descwd |= SQIN_EXT;
+		*(descwd + 2) = len;
+		return descwd + 3;
+	}
+
+	return descwd + 2;
+}
+
+int *cmd_insert_seq_out_ptr(u_int32_t *descwd, u_int32_t *ptr, u_int32_t len,
+			    enum ref_type sgref)
+{
+	*descwd = CMD_SEQ_OUT_PTR | ((sgref == PTR_SGLIST) ? SQOUT_SGF : 0) |
+		  len;
+
+	*(descwd + 1) = (u_int32_t)ptr;
+
+	if (len > 0xffff) {
+		*descwd |= SQOUT_EXT;
+		*(descwd + 2) = len;
+		return descwd + 3;
+	}
+
+	return descwd + 2;
+}
+
+int *cmd_insert_seq_load(u_int32_t *descwd, unsigned int class_access,
+			 int variable_len_flag, unsigned char dest,
+			 unsigned char offset, unsigned char len)
+{
+	*descwd = CMD_SEQ_LOAD | (class_access & CLASS_MASK) |
+		  (variable_len_flag ? LDST_SGF : 0) |
+		  ((dest & LDST_SRCDST_MASK) << LDST_SRCDST_SHIFT) |
+		  ((offset & LDST_OFFSET_MASK) << LDST_OFFSET_SHIFT) |
+		  ((len & LDST_LEN_MASK) << LDST_LEN_SHIFT);
+
+	return descwd + 1;
+}
+
+int *cmd_insert_seq_fifo_load(u_int32_t *descwd, unsigned int class_access,
+			      int variable_len_flag, unsigned char data_type,
+			      u_int32_t len, u_int32_t *ptr)
+{
+	*descwd = CMD_SEQ_FIFO_LOAD | (class_access & CLASS_MASK) |
+		  (variable_len_flag ? FIFOLDST_SGF : 0) |
+		  data_type | ((len & LDST_LEN_MASK) << LDST_LEN_SHIFT);
+
+	*(descwd + 1) = (u_int32_t)ptr;
+
+	if (len > 0xffff) {
+		*descwd |= FIFOLDST_EXT;
+		*(descwd + 2) = len;
+		return descwd + 3;
+	}
+
+	return descwd + 2;
+}
diff --git a/drivers/crypto/caam/dcl/dcl.h b/drivers/crypto/caam/dcl/dcl.h
new file mode 100644
index 0000000..5183d2a
--- /dev/null
+++ b/drivers/crypto/caam/dcl/dcl.h
@@ -0,0 +1,625 @@
+/*
+ * CAAM Descriptor Construction Library
+ * Application level usage definitions and prototypes
+ *
+ * Copyright (c) 2008, 2009, Freescale Semiconductor, Inc.
+ * All Rights Reserved
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef DCL_H
+#define DCL_H
+
+#include "../desc.h"
+
+/*
+ * Section 1 - Descriptor command construction definitions
+ * Under development and NOT to be used at present, these are
+ * almost guaranteed to change upon review.
+ */
+
+enum key_dest {
+	KEYDST_KEYREG,
+	KEYDST_PK_E,
+	KEYDST_AF_SBOX,
+	KEYDST_MD_SPLIT
+};
+
+enum key_cover {
+	KEY_CLEAR,
+	KEY_COVERED
+};
+
+enum item_inline {
+	ITEM_REFERENCE,
+	ITEM_INLINE
+};
+
+enum item_purpose {
+	ITEM_CLASS1,
+	ITEM_CLASS2
+};
+
+enum ref_type {
+	PTR_DIRECT,
+	PTR_SGLIST
+};
+
+enum ctxsave {
+	CTX_SAVE,
+	CTX_ERASE
+};
+
+enum shrnext {
+	SHRNXT_SHARED,
+	SHRNXT_LENGTH
+};
+
+enum execorder {
+	ORDER_REVERSE,
+	ORDER_FORWARD
+};
+
+enum shrst {
+	SHR_NEVER,
+	SHR_WAIT,
+	SHR_SERIAL,
+	SHR_ALWAYS,
+	SHR_DEFER
+};
+
+enum protdir {
+	DIR_ENCAP,
+	DIR_DECAP
+};
+
+enum mktrust {
+	DESC_SIGN,
+	DESC_STD
+};
+
+/*
+ * Type selectors for cipher types in IPSec
+ */
+#define CIPHER_TYPE_IPSEC_DESCBC              2
+#define CIPHER_TYPE_IPSEC_3DESCBC             3
+#define CIPHER_TYPE_IPSEC_AESCBC              12
+#define CIPHER_TYPE_IPSEC_AESCTR              13
+#define CIPHER_TYPE_IPSEC_AES_CCM_ICV8        14
+#define CIPHER_TYPE_IPSEC_AES_CCM_ICV12       15
+#define CIPHER_TYPE_IPSEC_AES_CCM_ICV16       16
+#define CIPHER_TYPE_IPSEC_AES_GCM_ICV8        18
+#define CIPHER_TYPE_IPSEC_AES_GCM_ICV12       19
+#define CIPHER_TYPE_IPSEC_AES_GCM_ICV16       20
+
+/*
+ * Type selectors for authentication in IPSec
+ */
+
+#define AUTH_TYPE_IPSEC_MD5HMAC_96            1
+#define AUTH_TYPE_IPSEC_SHA1HMAC_96           2
+#define AUTH_TYPE_IPSEC_AESXCBCMAC_96         6
+#define AUTH_TYPE_IPSEC_SHA1HMAC_160          7
+#define AUTH_TYPE_IPSEC_SHA2HMAC_256          12
+#define AUTH_TYPE_IPSEC_SHA2HMAC_384          13
+#define AUTH_TYPE_IPSEC_SHA2HMAC_512          14
+
+/*
+ * Insert a shared descriptor header into a descriptor
+ *
+ * Inputs:
+ * + descwd   = pointer to target descriptor word to hold this command.
+ *              Note that this should always be the first word of a
+ *              descriptor.
+ *
+ * + startidx = index to continuation of descriptor data, normally the
+ *              first descriptor word past a PDB. This tells DECO what
+ *              to skip over.
+ *
+ * + desclen  = length of descriptor in words, including header.
+ *
+ * + ctxsave  = Saved or erases context when a descriptor is self-shared
+ *              - CTX_SAVE  = context saved between iterations
+ *              - CTX_ERASE = context is erased
+ *
+ * + share    = Share state of this descriptor:
+ *              - SHR_NEVER  = Never share. Fetching is repeated for each
+ *                             processing pass.
+ *              - SHR_WAIT   = Share once processing starts.
+ *              - SHR_SERIAL = Share once completed.
+ *              - SHR_ALWAYS = Always share (except keys)
+ *
+ * Returns:
+ * + Pointer to next incremental descriptor word past the header just
+ *   constructed. If an error occurred, returns 0.
+ *
+ * Note: Headers should normally be constructed as the final operation
+ *       in the descriptor construction, because the start index and
+ *       overall descriptor length will likely not be known until
+ *       construction is complete. For this reason, there is little use
+ *       to the "incremental pointer" convention. The exception is probably
+ *       in the construction of simple descriptors where the size is easily
+ *       known early in the construction process.
+ */
+u_int32_t *cmd_insert_shared_hdr(u_int32_t    *descwd,
+				 u_int8_t      startidx,
+				 u_int8_t      desclen,
+				 enum ctxsave  ctxsave,
+				 enum shrst    share);
+
+/*
+ * Insert a standard descriptor header into a descriptor
+ *
+ * Inputs:
+ * + descwd   = pointer to target descriptor word to hold this command.
+ *              Note that this should always be the first word of a
+ *              descriptor.
+ *
+ * + startidx = index to continuation of descriptor data, or if
+ *              sharenext = SHRNXT_SHARED, then specifies the size
+ *              of the associated shared descriptor referenced in
+ *              the following instruction.
+ *
+ * + desclen  = length of descriptor in words, including header
+ *
+ * + share    = Share state for this descriptor:
+ *              - SHR_NEVER  = Never share. Fetching is repeated for each
+ *                             processing pass.
+ *              - SHR_WAIT   = Share once processing starts.
+ *              - SHR_SERIAL = Share once completed.
+ *              - SHR_ALWAYS = Always share (except keys)
+ *              - SHR_DEFER  = Use the referenced sharedesc to determine
+ *                             sharing intent
+ *
+ * + sharenext = Control state of shared descriptor processing
+ *              - SHRNXT_SHARED = This is a job descriptor consisting
+ *                                of a header and a pointer to a shared
+ *                                descriptor only.
+ *              - SHRNXT_LENGTH = This is a detailed job descriptor, thus
+ *                                desclen refers to the full length of this
+ *                                descriptor.
+ *
+ * + reverse   = Reverse execution order between this job descriptor, and
+ *               an associated shared descriptor:
+ *              - ORDER_REVERSE - execute this descriptor before the shared
+ *                                descriptor referenced.
+ *              - ORDER_FORWARD - execute the shared descriptor, then this
+ *                                descriptor.
+ *
+ * + mktrusted = DESC_SIGN - sign this descriptor prior to execuition
+ *               DESC_STD  - leave descriptor non-trusted
+ *
+ */
+u_int32_t *cmd_insert_hdr(u_int32_t *descwd, u_int8_t startidx,
+			  u_int8_t desclen, enum shrst share,
+			  enum shrnext sharenext, enum execorder reverse,
+			  enum mktrust mktrusted);
+
+/*
+ * Insert a key command into a descriptor
+ *
+ * Inputs:
+ * + descwd  = pointer to target descriptor word to hold this command
+ *
+ * + key     = pointer to key data as an array of bytes.
+ *
+ * + keylen  = pointer to key size, expressed in bits.
+ *
+ * + sgref   = pointer is actual data, or a scatter-gather list
+ *             representing the key:
+ *             - PTR_DIRECT = points to data
+ *             - PTR_SGLIST = points to CAAM-specific scatter gather
+ *               table. Cannot use if imm = ITEM_INLINE.
+ *
+ * + dest    = target destination in CAAM to receive the key. This may be:
+ *             - KEYDST_KEYREG   = Key register in the CHA selected by an
+ *                                 OPERATION command.
+ *             - KEYDST_PK_E     = The 'e' register in the public key block
+ *             - KEYDST_AF_SBOX  = Direct SBOX load if ARC4 is selected
+ *             - KEYDST_MD_SPLIT = Message digest IPAD/OPAD direct load.
+ *
+ * + cover   = Key was encrypted, and must be decrypted during the load.
+ *             If trusted descriptor, use TDEK, else use JDEK to decrypt.
+ *             - KEY_CLEAR   = key is cleartext, no decryption needed
+ *             - KEY_COVERED = key is ciphertext, decrypt.
+ *
+ * + imm     = Key can either be referenced, or loaded into the descriptor
+ *             immediately following the command for improved performance.
+ *             - ITEM_REFERENCE = a pointer follows the command.
+ *             - ITEM_INLINE    = key data follows the command, padded out
+ *                                to a descriptor word boundary.
+ *
+ * + purpose = Sends the key to the class 1 or 2 CHA as selected by an
+ *             OPERATION command. If dest is KEYDST_PK_E or KEYDST_AF_SBOX,
+ *             then this must be ITEM_CLASS1.
+ *
+ * Returns:
+ * + If successful, returns a pointer to the target word incremented
+ *   past the newly-inserted command (including item pointer or inlined
+ *   data). Effectively, this becomes a pointer to the next word to receive
+ *   a new command in this descriptor.
+ *
+ * + If error, returns 0
+ */
+u_int32_t *cmd_insert_key(u_int32_t        *descwd,
+			  u_int8_t         *key,
+			  u_int32_t         keylen,
+			  enum ref_type     sgref,
+			  enum key_dest     dest,
+			  enum key_cover    cover,
+			  enum item_inline  imm,
+			  enum item_purpose purpose);
+
+/*
+ * Insert an IPSec protocol operation command into a descriptor
+ *
+ * Inputs:
+ * + descwd    = pointer to target descriptor word intended to hold
+ *               this command. For an OPERATION command, this is normally
+ *               the final word of a single descriptor.
+ *
+ * + cipheralg = blockcipher selection for this protocol descriptor.
+ *               This should be one of CIPHER_TYPE_IPSEC_.
+ *
+ * + authalg   = authentication selection for this protocol descriptor.
+ *               This should be one of AUTH_TYPE_IPSEC_.
+ *
+ * + dir       = Select DIR_ENCAP for encapsulation, or DIR_DECAP for
+ *               decapsulation operations.
+ *
+ * Returns:
+ * + Pointer to next incremental descriptor word past the command
+ *   just constructed. If an error occurred, returns 0;
+ */
+u_int32_t *cmd_insert_proto_op_ipsec(u_int32_t   *descwd,
+				     u_int8_t     cipheralg,
+				     u_int8_t     authalg,
+				     enum protdir dir);
+
+/*
+ * Insert an SEQ IN PTR command into a descriptor
+ *
+ * Inputs:
+ * + descwd    = pointer to target descriptor word intended to hold
+ *               this command. For an OPERATION command, this is normally
+ *               the final word of a single descriptor.
+ * + ptr       = bus address pointing to the input data buffer
+ * + len       = input length
+ * + sgref     = pointer is actual data, or a scatter-gather list
+ *               representing the key:
+ *               - PTR_DIRECT = points to data
+ *               - PTR_SGLIST = points to CAAM-specific scatter gather
+ *                 table.
+ *
+ * Returns:
+ * + Pointer to next incremental descriptor word past the command
+ *   just constructed. If an error occurred, returns 0;
+ */
+int *cmd_insert_seq_in_ptr(u_int32_t *descwd, u_int32_t *ptr, u_int32_t len,
+			   enum ref_type sgref);
+
+/*
+ * Insert an SEQ OUT PTR command into a descriptor
+ *
+ * Inputs:
+ * + descwd    = pointer to target descriptor word intended to hold
+ *               this command. For an OPERATION command, this is normally
+ *               the final word of a single descriptor.
+ * + ptr       = bus address pointing to the output data buffer
+ * + len       = output length
+ * + sgref     = pointer is actual data, or a scatter-gather list
+ *               representing the key:
+ *               - PTR_DIRECT = points to data
+ *               - PTR_SGLIST = points to CAAM-specific scatter gather
+ *                 table.
+ *
+ * Returns:
+ * + Pointer to next incremental descriptor word past the command
+ *   just constructed. If an error occurred, returns 0;
+ */
+int *cmd_insert_seq_out_ptr(u_int32_t *descwd, u_int32_t *ptr, u_int32_t len,
+			    enum ref_type sgref);
+
+/*
+ * Insert an SEQ LOAD command into a descriptor
+ *
+ * Inputs:
+ * descwd       = pointer to target descriptor word intended to hold
+ *                this command. For an OPERATION command, this is normally
+ *                the final word of a single descriptor.
+ * class_access = LDST_CLASS_IND_CCB = access class-independent objects in CCB
+ *              = LDST_CLASS_1_CCB   = access class 1 objects in CCB
+ *              = LDST_CLASS_2_CCB   = access class 2 objects in CCB
+ *              = LDST_CLASS_DECO    = access DECO objects
+ * variable_len_flag = use the variable input sequence length
+ * dest         = destination
+ * offset       = the start point for writing in the destination
+ * len          = length of data in bytes
+ *
+ * Returns:
+ * + Pointer to next incremental descriptor word past the command
+ *   just constructed. If an error occurred, returns 0;
+ */
+int *cmd_insert_seq_load(u_int32_t *descwd, unsigned int class_access,
+			 int variable_len_flag, unsigned char dest,
+			 unsigned char offset, unsigned char len);
+
+/*
+ * Insert an SEQ FIFO LOAD command into a descriptor
+ *
+ * Inputs:
+ * + descwd    = pointer to target descriptor word intended to hold
+ *               this command. For an OPERATION command, this is normally
+ *               the final word of a single descriptor.
+ * class_access = LDST_CLASS_IND_CCB = access class-independent objects in CCB
+ *              = LDST_CLASS_1_CCB   = access class 1 objects in CCB
+ *              = LDST_CLASS_2_CCB   = access class 2 objects in CCB
+ *              = LDST_CLASS_DECO    = access DECO objects
+ * variable_len_flag = use the variable input sequence length
+ * data_type    = FIFO input data type (FIFOLD_TYPE_* in caam_desc.h)
+ * len          = output length
+ * ptr          = bus address pointing to the output data buffer
+ *
+ * Returns:
+ * + Pointer to next incremental descriptor word past the command
+ *   just constructed. If an error occurred, returns 0;
+ */
+int *cmd_insert_seq_fifo_load(u_int32_t *descwd, unsigned int class_access,
+			      int variable_len_flag, unsigned char data_type,
+			      u_int32_t len, u_int32_t *ptr);
+
+/*
+ * Section 2 - Simple descriptor construction definitions
+ */
+
+/*
+ * Construct simple sequence job descriptor
+ *
+ * Constructs a simple job descriptor that contains 3 references:
+ *   (1) A pointer to a shared descriptor to do the work. This is
+ *       normally assumed to be some sort of a protocol sharedesc,
+ *       but doesn't have to be.
+ *   (2) A pointer to a packet/frame for input data
+ *   (3) A pointer to a packet/frame for output data
+ *
+ * This descriptor is always a simple reverse-order descriptor,
+ * and has no provisions for other content specifications.
+ *
+ * Inputs:
+ *
+ */
+int cnstr_seq_jobdesc(u_int32_t *jobdesc, unsigned short *jobdescsz,
+		      u_int32_t *shrdesc, unsigned short shrdescsize,
+		      unsigned char *inbuf, unsigned long insize,
+		      unsigned char *outbuf, unsigned long outsize);
+
+/*
+ * Section 3 - Single-pass descriptor construction definitions
+ */
+
+/*
+ * Section 4 - Protocol descriptor construction definitions
+ */
+
+/* If protocol descriptor, IPV4 or 6? */
+enum protocolvers {
+	PDB_IPV4,
+	PDB_IPV6
+};
+
+/* If antireplay in PDB, how big? */
+enum antirply_winsiz {
+	PDB_ANTIRPLY_NONE,
+	PDB_ANTIRPLY_32,
+	PDB_ANTIRPLY_64
+};
+
+/* Tunnel or Transport (for next-header byte) ? */
+enum connect_type {
+	PDB_TUNNEL,
+	PDB_TRANSPORT
+};
+
+/* Extended sequence number support? */
+enum esn {
+	PDB_NO_ESN,
+	PDB_INCLUDE_ESN
+};
+
+/* Decapsulation output format */
+enum decap_out {
+	PDB_OUTPUT_COPYALL,
+	PDB_OUTPUT_DECAP_PDU
+};
+
+/* IV source */
+enum ivsrc {
+	PDB_IV_FROM_PDB,
+	PDB_IV_FROM_RNG
+};
+
+/*
+ * Request parameters for specifying authentication data
+ * for a single-pass or protocol descriptor
+ */
+struct authparams {
+	u_int8_t   algtype;  /* Select algorithm */
+	u_int8_t  *key;      /* Key as an array of bytes */
+	u_int32_t  keylen;   /* Length of key in bits */
+};
+
+/*
+ * Request parameters for specifying blockcipher data
+ * for a single-pass or protocol descriptor
+ */
+struct cipherparams {
+	u_int8_t   algtype;
+	u_int8_t  *key;
+	u_int32_t  keylen;
+};
+
+/*
+ * A collection of common definitions for the contents
+ * of a Protocol Data Block. At this point in time,
+ * it only reflects common data used in IPSec-CBC
+ * descriptor construction
+ *
+ * This could possibly use some seed values for SN/ESN,
+ * IV, etc.
+ */
+struct seqnum {
+	enum esn              esn;
+	enum antirply_winsiz  antirplysz;
+};
+
+struct pdbcont {
+	u_int16_t             opthdrlen;
+	u_int8_t             *opthdr;
+	enum connect_type     transmode;
+	enum protocolvers     pclvers;
+	enum decap_out        outfmt;
+	enum ivsrc            ivsrc;
+	struct seqnum         seq;
+};
+
+/*
+ * Protocol-level shared descriptor constructors
+ *
+ * These build a full protocol-level shared descriptor for semi-autonomous
+ * processing of secured traffic through CAAM. Such descriptors function
+ * as single-pass processors (integrating cipher and authentication
+ * functions into a single logical step) with the added factor of
+ * performing protocol-level packet manipulation in the same step
+ * in the packet-handling process, by maintaining protocol-level
+ * connection state information within the descriptor itself.
+ *
+ * For each function, the arguments are uniform:
+ *
+ * Inputs:
+ *
+ *    * descbuf    = Points to a buffer to construct the descriptor in.
+ *                   All CAAM descriptors are built of an array of up to
+ *                   63 32-bit words. If the caller wishes to construct
+ *                   a descriptor directly in the executable buffer, then
+ *                   that buffer must be hardware DMA-able, and physically
+ *                   contiguous.
+ *
+ *    * bufsize    = Points to an unsigned 16-bit word with the max length
+ *                   of the buffer to hold the descriptor. This will be
+ *                   written back to with the actual size of the descriptor
+ *                   once constructed. (Note: bounds checking not yet
+ *                   implemented).
+ *
+ *    * pdb        = Points to a block of data (struct pdbcont) used to
+ *                   describe the content if the Protocol Data Block to be
+ *                   maintained inside the descriptor. PDB content is
+ *                   protocol and mode specific.
+ *
+ *    * cipherdata = Points to a block of data used to describe the cipher
+ *                   information for encryption/decryption of packet
+ *                   content:
+ *                   - algtype = one of CIPHER_TYPE_IPSEC_xxx
+ *                   - key     = pointer to the cipher key data
+ *                   - keydata = size of the key data in bits
+ *
+ *    * authdata   = Points to a block of data used to describe the
+ *                   authentication information for validating the
+ *                   authenticity of the packet source.
+ *                   - algtype = one of AUTH_TYPE_IPSEC_xxx
+ *                   - key     = pointer to the HMAC key data
+ *                   - keydata = size of the key data in bits
+ *
+ *    * clear      = If nonzero, buffer is cleared before writing
+ *
+ * Returns:
+ *
+ *    * -1 if the descriptor creation failed for any reason, zero
+ *      if creation succeeded.
+ *
+ */
+
+
+/*
+ * IPSec ESP CBC decapsulation case:
+ *
+ * pdb.opthdrlen      = Size of inbound header to skip over.
+ * pdb.transmode      = PDB_TUNNEL/PDB_TRANSPORT for tunnel or transport
+ *                      handling for the next header.
+ * pdb.pclvers        = PDB_IPV4/PDB_IPV6 as appropriate for this connection.
+ * pdb.seq.esn        = PDB_NO_ESN unless extended sequence numbers are to
+ *                      be supported, then PDB_INCLUDE_ESN.
+ * pdb.seq/antirplysz = PDB_ANTIRPLY_NONE if no antireplay window is to be
+ *                      maintained in the PDB. Otherwise may be
+ *                      PDB_ANTIRPLY_32 for a 32-entry window, or
+ *                      PDB_ANTIRPLY_64 for a 64-entry window.
+ *
+ */
+int32_t cnstr_pcl_shdsc_ipsec_cbc_decap(u_int32_t           *descbuf,
+					u_int16_t           *bufsize,
+					struct pdbcont      *pdb,
+					struct cipherparams *cipherdata,
+					struct authparams   *authdata,
+					u_int8_t             clear);
+
+/*
+ * IPSec ESP CBC encapsulation case:
+ *
+ * pdbinfo.opthdrlen = Size of outbound IP header to be prepended to
+ *                     output.
+ * pdbinfo.opthdr    = Pointer to the IP header to be prepended to the
+ *                     output, of size opthdrlen.
+ * pdbinfo.transmode = PDB_TUNNEL/PDB_TRANSPORT for tunnel/transport
+ *                     handling for the next header.
+ * pdbinfo.pclvers   = PDB_IPV4/PDB_IPV6 as appropriate for this connection.
+ * pdbinfo.seq.esn   = PDB_NO_ESN unless extended sequence numbers are to
+ *                     be supported, then PDB_INCLUDE_ESN.
+ * pdbinfo.ivsrc     = PDB_IV_FROM_PDB if the IV is to be maintained in
+ *                     the PDB, else PDB_IV_FROM_RNG if the IV is to
+ *                     be generated internally by CAAM's random number
+ *                     generator.
+ *
+ */
+int32_t cnstr_pcl_shdsc_ipsec_cbc_encap(u_int32_t           *descbuf,
+					u_int16_t           *bufsize,
+					struct pdbcont      *pdb,
+					struct cipherparams *cipherdata,
+					struct authparams   *authdata,
+					u_int8_t             clear);
+
+/*
+ * Section 5 - disassembler definitions
+ */
+void desc_hexdump(u_int32_t *descdata,
+		  u_int32_t  size,
+		  u_int32_t  wordsperline,
+		  int8_t    *indentstr);
+
+void caam_desc_disasm(u_int32_t *desc);
+
+#endif /* DCL_H */
diff --git a/drivers/crypto/caam/dcl/disasm.c b/drivers/crypto/caam/dcl/disasm.c
new file mode 100644
index 0000000..60732ee
--- /dev/null
+++ b/drivers/crypto/caam/dcl/disasm.c
@@ -0,0 +1,776 @@
+/*
+ * CAAM Descriptor Construction Library
+ * Descriptor Disassembler
+ *
+ * This is EXPERIMENTAL and incomplete code. It assumes BE32 for the
+ * moment, and much functionality remains to be filled in
+ *
+ * Copyright (c) 2008, 2009, Freescale Semiconductor, Inc.
+ * All Rights Reserved
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "../compat.h"
+#include "dcl.h"
+
+#define NULL_LEADER (int8_t *)"            "
+
+/*
+ * Simple hexdumper for use by the disassembler. Displays 32-bit
+ * words on a line-by-line bases with an offset shown,. and an
+ * optional indentation/description string to prefix each line with.
+ *
+ * descdata     - data to dump
+ * size         - size of buffer in words
+ * wordsperline - number of words to display per line, minimum 1.
+ *                4 is a practical maximum using an 80-character line
+ * indentstr    - points to a string to ident or identify each line
+ */
+void desc_hexdump(u_int32_t *descdata,
+		  u_int32_t  size,
+		  u_int32_t  wordsperline,
+		  int8_t    *indentstr)
+{
+	int i, idx, rem, line;
+
+	idx = 0;
+	rem = size;
+
+	while (rem) {
+		PRINT("%s[%02d] ", indentstr, idx);
+		if (rem <= wordsperline)
+			line = rem;
+		else
+			line = wordsperline;
+
+		for (i = 0; i < line; i++) {
+			PRINT("0x%08x ", descdata[idx]);
+			rem--; idx++;
+		}
+		PRINT("\n");
+	};
+
+}
+EXPORT_SYMBOL(desc_hexdump);
+
+
+/*
+ * FIXME: in general, this should be reworked to eschew cases
+ */
+
+static void show_shrhdr(u_int32_t *hdr)
+{
+	PRINT("   shrdesc: stidx=%d len=%d ",
+	       (*hdr >> HDR_START_IDX_SHIFT) & HDR_START_IDX_MASK,
+	       *hdr & HDR_DESCLEN_SHR_MASK);
+
+	switch (*hdr & (HDR_SD_SHARE_MASK << HDR_SD_SHARE_SHIFT)) {
+	case HDR_SHARE_NEVER:
+		PRINT("share-never ");
+		break;
+
+	case HDR_SHARE_WAIT:
+		PRINT("share-wait ");
+		break;
+
+	case HDR_SHARE_SERIAL:
+		PRINT("share-serial ");
+		break;
+
+	case HDR_SHARE_ALWAYS:
+		PRINT("share-always ");
+		break;
+	}
+
+	if (*hdr & HDR_DNR)
+		PRINT("noreplay ");
+
+	if (*hdr & HDR_SAVECTX)
+		PRINT("savectx ");
+
+	if (*hdr & HDR_PROP_DNR)
+		PRINT("propdnr ");
+
+	PRINT("\n");
+}
+
+static void show_hdr(u_int32_t *hdr)
+{
+	if (*hdr & HDR_SHARED) {
+		PRINT("   jobdesc: shrsz=%d len=%d ",
+		      (*hdr >> HDR_START_IDX_SHIFT) & HDR_START_IDX_MASK,
+		      *hdr & HDR_DESCLEN_MASK);
+	} else {
+		PRINT("   jobdesc: stidx=%d len=%d ",
+		      (*hdr >> HDR_START_IDX_SHIFT) & HDR_START_IDX_MASK,
+		      *hdr & HDR_DESCLEN_MASK);
+	}
+	switch (*hdr & (HDR_JD_SHARE_MASK << HDR_JD_SHARE_SHIFT)) {
+	case HDR_SHARE_NEVER:
+		PRINT("share-never ");
+		break;
+
+	case HDR_SHARE_WAIT:
+		PRINT("share-wait ");
+		break;
+
+	case HDR_SHARE_SERIAL:
+		PRINT("share-serial ");
+		break;
+
+	case HDR_SHARE_ALWAYS:
+		PRINT("share-always ");
+		break;
+
+	case HDR_SHARE_DEFER:
+		PRINT("share-defer ");
+		break;
+	}
+
+	if (*hdr & HDR_DNR)
+		PRINT("noreplay ");
+
+	if (*hdr & HDR_TRUSTED)
+		PRINT("trusted ");
+
+	if (*hdr & HDR_MAKE_TRUSTED)
+		PRINT("mktrusted ");
+
+	if (*hdr & HDR_SHARED)
+		PRINT("getshared ");
+
+	if (*hdr & HDR_REVERSE)
+		PRINT("reversed ");
+
+	PRINT("\n");
+}
+
+static void show_key(u_int32_t *cmd, u_int8_t *idx)
+{
+	u_int32_t keylen, *keydata;
+
+	keylen  = *cmd & KEY_LENGTH_MASK;
+	keydata = cmd + 1; /* point to key or pointer */
+
+	PRINT("       key: len=%d ", keylen);
+
+	switch (*cmd & CLASS_MASK) {
+	case CLASS_1:
+		PRINT("class1");
+		break;
+
+	case CLASS_2:
+		PRINT("class2");
+		break;
+
+	}
+
+	switch (*cmd & KEY_DEST_MASK) {
+	case KEY_DEST_CLASS_REG:
+		PRINT("->keyreg ");
+		break;
+
+	case KEY_DEST_PKHA_E:
+		PRINT("->pk-e ");
+		break;
+
+	case KEY_DEST_AFHA_SBOX:
+		PRINT("->af-sbox ");
+		break;
+
+	case KEY_DEST_MDHA_SPLIT:
+		PRINT("->md-split ");
+		break;
+	}
+
+	if (*cmd & KEY_SGF)
+		PRINT("scattered ");
+
+	if (*cmd & KEY_ENC)
+		PRINT("encrypted ");
+
+	if (*cmd & KEY_IMM)
+		PRINT("inline ");
+
+	PRINT("\n");
+
+	(*idx)++;
+
+	if (*cmd & KEY_IMM) {
+		desc_hexdump(keydata, keylen >> 2, 4, NULL_LEADER);
+		(*idx) += keylen >> 2;
+	} else {
+		PRINT("          : @0x%08x\n", *keydata);
+		(*idx)++;
+	}
+}
+
+static void show_seq_key(u_int32_t *cmd, u_int8_t *idx)
+{
+	PRINT("    seqkey: ");
+	PRINT("\n");
+	(*idx)++;
+}
+
+static void show_load(u_int32_t *cmd, u_int8_t *idx)
+{
+	PRINT("        ld: ");
+	PRINT("\n");
+	(*idx)++;
+}
+
+static void show_seq_load(u_int32_t *cmd, u_int8_t *idx)
+{
+	PRINT("     seqld: ");
+
+	switch (*cmd & CLASS_MASK) {
+	case LDST_CLASS_IND_CCB:
+		PRINT("CCB class-indep. access");
+		break;
+
+	case LDST_CLASS_1_CCB:
+		PRINT("CCB class 1 access");
+		break;
+
+	case LDST_CLASS_2_CCB:
+		PRINT("CCB class 2 access");
+		break;
+
+	case LDST_CLASS_DECO:
+		PRINT("DECO access");
+		break;
+	}
+
+	if (*cmd & LDST_SGF)
+		PRINT(" scatter-gather");
+
+	PRINT(" dest=%d offset=%d len=%d",
+	      (*cmd >> LDST_SRCDST_SHIFT) & LDST_SRCDST_MASK,
+	      (*cmd >> LDST_OFFSET_SHIFT) & LDST_OFFSET_MASK,
+	      *cmd & LDST_LEN_MASK);
+
+	PRINT("\n");
+	(*idx)++;
+}
+
+static void show_fifo_load(u_int32_t *cmd, u_int8_t *idx)
+{
+	PRINT("    fifold: ");
+	PRINT("\n");
+	(*idx)++;
+}
+
+static void show_seq_fifo_load(u_int32_t *cmd, u_int8_t *idx)
+{
+	PRINT(" seqfifold: ");
+	PRINT("\n");
+	(*idx)++;
+}
+
+static void show_store(u_int32_t *cmd, u_int8_t *idx)
+{
+	PRINT("       str: ");
+	PRINT("\n");
+	(*idx)++;
+}
+
+static void show_seq_store(u_int32_t *cmd, u_int8_t *idx)
+{
+	PRINT("    seqstr: ");
+	PRINT("\n");
+	(*idx)++;
+}
+
+static void show_fifo_store(u_int32_t *cmd, u_int8_t *idx)
+{
+	PRINT("   fifostr: ");
+	PRINT("\n");
+	(*idx)++;
+}
+
+static void show_seq_fifo_store(u_int32_t *cmd, u_int8_t *idx)
+{
+	PRINT("seqfifostr: ");
+	PRINT("\n");
+	(*idx)++;
+}
+
+static void show_move(u_int32_t *cmd, u_int8_t *idx)
+{
+	PRINT("      move: ");
+	PRINT("\n");
+	(*idx)++;
+}
+
+static void decode_unidir_pcl_op(u_int32_t *cmd)
+{
+	switch (*cmd & OP_PCLID_MASK) {
+	case OP_PCLID_IKEV1_PRF:
+		PRINT("ike_v1_prf ");
+		break;
+	case OP_PCLID_IKEV2_PRF:
+		PRINT("ike_v2_prf ");
+		break;
+	case OP_PCLID_SSL30_PRF:
+		PRINT("ssl3.0_prf ");
+		break;
+	case OP_PCLID_TLS10_PRF:
+		PRINT("tls1.0_prf ");
+		break;
+	case OP_PCLID_TLS11_PRF:
+		PRINT("tls1.1_prf ");
+		break;
+	case OP_PCLID_DTLS10_PRF:
+		PRINT("dtls1.0_prf ");
+		break;
+	}
+}
+
+static void decode_ipsec_pclinfo(u_int32_t *cmd)
+{
+	switch (*cmd & OP_PCL_IPSEC_CIPHER_MASK) {
+	case OP_PCL_IPSEC_DES_IV64:
+		PRINT("des-iv64 ");
+		break;
+
+	case OP_PCL_IPSEC_DES:
+		PRINT("des ");
+		break;
+
+	case OP_PCL_IPSEC_3DES:
+		PRINT("3des ");
+		break;
+
+	case OP_PCL_IPSEC_AES_CBC:
+		PRINT("aes-cbc ");
+		break;
+
+	case OP_PCL_IPSEC_AES_CTR:
+		PRINT("aes-ctr ");
+		break;
+
+	case OP_PCL_IPSEC_AES_XTS:
+		PRINT("aes-xts ");
+		break;
+
+	case OP_PCL_IPSEC_AES_CCM8:
+		PRINT("aes-ccm8 ");
+		break;
+
+	case OP_PCL_IPSEC_AES_CCM12:
+		PRINT("aes-ccm12 ");
+		break;
+
+	case OP_PCL_IPSEC_AES_CCM16:
+		PRINT("aes-ccm16 ");
+		break;
+
+	case OP_PCL_IPSEC_AES_GCM8:
+		PRINT("aes-ccm8 ");
+		break;
+
+	case OP_PCL_IPSEC_AES_GCM12:
+		PRINT("aes-ccm12 ");
+		break;
+
+	case OP_PCL_IPSEC_AES_GCM16:
+		PRINT("aes-ccm16 ");
+		break;
+	}
+
+	switch (*cmd & OP_PCL_IPSEC_AUTH_MASK) {
+	case OP_PCL_IPSEC_HMAC_NULL:
+		PRINT("hmac-null ");
+		break;
+
+	case OP_PCL_IPSEC_HMAC_MD5_96:
+		PRINT("hmac-md5-96 ");
+		break;
+
+	case OP_PCL_IPSEC_HMAC_SHA1_96:
+		PRINT("hmac-sha1-96 ");
+		break;
+
+	case OP_PCL_IPSEC_AES_XCBC_MAC_96:
+		PRINT("aes-xcbcmac-96 ");
+		break;
+
+	case OP_PCL_IPSEC_HMAC_MD5_128:
+		PRINT("hmac-md5-128 ");
+		break;
+
+	case OP_PCL_IPSEC_HMAC_SHA1_160:
+		PRINT("hmac-sha1-160 ");
+		break;
+
+	case OP_PCL_IPSEC_HMAC_SHA2_256_128:
+		PRINT("hmac-sha2-256-128 ");
+		break;
+
+	case OP_PCL_IPSEC_HMAC_SHA2_384_192:
+		PRINT("hmac-sha2-384-192 ");
+		break;
+
+	case OP_PCL_IPSEC_HMAC_SHA2_512_256:
+		PRINT("hmac-sha2-512-256 ");
+		break;
+	}
+}
+
+/* need a BUNCH of these decoded... */
+static void decode_bidir_pcl_op(u_int32_t *cmd)
+{
+	switch (*cmd & OP_PCLID_MASK) {
+	case OP_PCLID_IPSEC:
+		PRINT("ipsec ");
+		decode_ipsec_pclinfo(cmd);
+		break;
+
+	case OP_PCLID_SRTP:
+		PRINT("srtp ");
+		PRINT("pclinfo=0x%04x ", *cmd & OP_PCLINFO_MASK);
+		break;
+
+	case OP_PCLID_MACSEC:
+		PRINT("macsec ");
+		PRINT("pclinfo=0x%04x ", *cmd & OP_PCLINFO_MASK);
+		break;
+
+	case OP_PCLID_WIFI:
+		PRINT("wifi ");
+		PRINT("pclinfo=0x%04x ", *cmd & OP_PCLINFO_MASK);
+		break;
+
+	case OP_PCLID_WIMAX:
+		PRINT("wimax ");
+		PRINT("pclinfo=0x%04x ", *cmd & OP_PCLINFO_MASK);
+		break;
+
+	case OP_PCLID_SSL30:
+		PRINT("ssl3.0 ");
+		PRINT("pclinfo=0x%04x ", *cmd & OP_PCLINFO_MASK);
+		break;
+
+	case OP_PCLID_TLS10:
+		PRINT("tls1.0 ");
+		PRINT("pclinfo=0x%04x ", *cmd & OP_PCLINFO_MASK);
+		break;
+
+	case OP_PCLID_TLS11:
+		PRINT("tls1.1 ");
+		PRINT("pclinfo=0x%04x ", *cmd & OP_PCLINFO_MASK);
+		break;
+
+	case OP_PCLID_TLS12:
+		PRINT("tls1.2 ");
+		PRINT("pclinfo=0x%04x ", *cmd & OP_PCLINFO_MASK);
+		break;
+
+	case OP_PCLID_DTLS:
+		PRINT("dtls ");
+		PRINT("pclinfo=0x%04x ", *cmd & OP_PCLINFO_MASK);
+		break;
+	}
+}
+
+static void decode_pk_op(u_int32_t *cmd)
+{
+	switch (*cmd & OP_PCLID_MASK) {
+	case OP_PCLID_PRF:
+		PRINT("prf ");
+		break;
+	case OP_PCLID_BLOB:
+		PRINT("sm-blob ");
+		break;
+	case OP_PCLID_SECRETKEY:
+		PRINT("secret-key ");
+		break;
+	case OP_PCLID_PUBLICKEYPAIR:
+		PRINT("pk-pair ");
+		break;
+	case OP_PCLID_DSASIGN:
+		PRINT("dsa-sign ");
+		break;
+	case OP_PCLID_DSAVERIFY:
+		PRINT("dsa-verify ");
+		break;
+	}
+}
+
+static void decode_class1_op(u_int32_t *cmd)
+{
+}
+
+static void decode_class2_op(u_int32_t *cmd)
+{
+}
+
+static void show_op(u_int32_t *cmd, u_int8_t *idx)
+{
+	PRINT(" operation: type=");
+
+	switch (*cmd & OP_TYPE_MASK) {
+	case OP_TYPE_UNI_PROTOCOL:
+		PRINT("unidir-pcl ");
+		decode_unidir_pcl_op(cmd);
+		break;
+
+	case OP_TYPE_PK:
+		PRINT("public-key ");
+		decode_pk_op(cmd);
+		break;
+
+	case OP_TYPE_CLASS1_ALG:
+		PRINT("class1-op ");
+		decode_class1_op(cmd);
+		break;
+
+	case OP_TYPE_CLASS2_ALG:
+		PRINT("class2-op ");
+		decode_class2_op(cmd);
+		break;
+
+	case OP_TYPE_DECAP_PROTOCOL:
+		PRINT("decap-pcl ");
+		decode_bidir_pcl_op(cmd);
+		break;
+
+	case OP_TYPE_ENCAP_PROTOCOL:
+		PRINT("encap-pcl ");
+		decode_bidir_pcl_op(cmd);
+		break;
+	}
+	PRINT("\n");
+	(*idx)++;
+}
+
+static void show_signature(u_int32_t *cmd, u_int8_t *idx)
+{
+	PRINT(" signature: ");
+	PRINT("\n");
+	(*idx)++;
+}
+
+static void show_jump(u_int32_t *cmd, u_int8_t *idx)
+{
+	PRINT("      jump: ");
+	PRINT("\n");
+	(*idx)++;
+}
+
+static void show_math(u_int32_t *cmd, u_int8_t *idx)
+{
+	PRINT("      math: ");
+	PRINT("\n");
+	(*idx)++;
+}
+
+static void show_seq_in_ptr(u_int32_t *cmd, u_int8_t *idx)
+{
+	PRINT("  seqinptr:");
+	if (*cmd & SQIN_RBS)
+		PRINT(" release buf");
+	if (*cmd & SQIN_INL)
+		PRINT(" inline");
+	if (*cmd & SQIN_SGF)
+		PRINT(" scatter-gather");
+	if (*cmd & SQIN_PRE) {
+		PRINT(" PRE");
+	} else {
+		PRINT(" ptr=0x%08x", *(cmd + 1));
+		(*idx)++;
+	}
+	if (*cmd & SQIN_EXT)
+		PRINT(" EXT");
+	else
+		PRINT(" len=%d", *cmd & 0xffff);
+	if (*cmd & SQIN_RTO)
+		PRINT(" RTO");
+	PRINT("\n");
+	(*idx)++;
+}
+
+static void show_seq_out_ptr(u_int32_t *cmd, u_int8_t *idx)
+{
+	PRINT(" seqoutptr:");
+	if (*cmd & SQOUT_SGF)
+		PRINT(" scatter-gather");
+	if (*cmd & SQOUT_PRE) {
+		PRINT(" PRE");
+	} else {
+		PRINT(" ptr=0x%08x", *(cmd + 1));
+		(*idx)++;
+	}
+	if (*cmd & SQOUT_EXT)
+		PRINT(" EXT");
+	else
+		PRINT(" len=%d", *cmd & 0xffff);
+	PRINT("\n");
+	(*idx)++;
+}
+
+/*
+ * Top-level descriptor disassembler
+ *
+ * desc - points to the descriptor to disassemble. First command
+ *        must be a header, or shared header, and the overall size
+ *        is determined by this. Does not handle a QI preheader as
+ *        it's first command, and cannot yet follow links in a list
+ *        of descriptors
+ */
+void caam_desc_disasm(u_int32_t *desc)
+{
+	u_int8_t   len, idx, stidx;
+
+	stidx  = 0;
+
+	/*
+	 * First word must be header or shared header, or we're done
+	 * If we have a valid header, save off indices and size for
+	 * determining descriptor area boundaries
+	 */
+	switch (*desc & CMD_MASK) {
+	case CMD_SHARED_DESC_HDR:
+		len   = *desc & HDR_DESCLEN_SHR_MASK;
+		/* if shared, stidx becomes size of PDB space */
+		stidx = (*desc >> HDR_START_IDX_SHIFT) &
+			HDR_START_IDX_MASK;
+		show_shrhdr(desc);
+		break;
+
+	case CMD_DESC_HDR:
+		len   = *desc & HDR_DESCLEN_MASK;
+		/* if std header, stidx is size of sharedesc */
+		stidx = (*desc >> HDR_START_IDX_SHIFT) &
+			HDR_START_IDX_MASK;
+
+		show_hdr(desc);
+
+		if (*desc & HDR_SHARED) {
+			stidx = 2; /* just skip past sharedesc ptr */
+			PRINT("            sharedesc->0x%08x\n", desc[1]);
+		}
+		break;
+
+	default:
+		PRINT("caam_desc_disasm() no initial header: 0x%08x\n",
+		      *desc);
+		return;
+	}
+
+	/*
+	 * Show PDB area (that between header and startindex)
+	 * Improve PDB content dumps later...
+	 */
+	desc_hexdump(&desc[1], stidx - 1, 4, (int8_t *)"     (pdb): ");
+
+	/*
+	 * Now go process remaining commands in sequence
+	 */
+
+	idx = stidx;
+
+	while (idx < len) {
+		switch (desc[idx] & CMD_MASK) {
+		case CMD_KEY:
+			show_key(&desc[idx], &idx);
+			break;
+
+		case CMD_SEQ_KEY:
+			show_seq_key(&desc[idx], &idx);
+			break;
+
+		case CMD_LOAD:
+			show_load(&desc[idx], &idx);
+			break;
+
+		case CMD_SEQ_LOAD:
+			show_seq_load(&desc[idx], &idx);
+			break;
+
+		case CMD_FIFO_LOAD:
+			show_fifo_load(&desc[idx], &idx);
+			break;
+
+		case CMD_SEQ_FIFO_LOAD:
+			show_seq_fifo_load(&desc[idx], &idx);
+			break;
+
+		case CMD_STORE:
+			show_store(&desc[idx], &idx);
+			break;
+
+		case CMD_SEQ_STORE:
+			show_seq_store(&desc[idx], &idx);
+			break;
+
+		case CMD_FIFO_STORE:
+			show_fifo_store(&desc[idx], &idx);
+			break;
+
+		case CMD_SEQ_FIFO_STORE:
+			show_seq_fifo_store(&desc[idx], &idx);
+			break;
+
+		case CMD_MOVE:
+			show_move(&desc[idx], &idx);
+			break;
+
+		case CMD_OPERATION:
+			show_op(&desc[idx], &idx);
+			break;
+
+		case CMD_SIGNATURE:
+			show_signature(&desc[idx], &idx);
+			break;
+
+		case CMD_JUMP:
+			show_jump(&desc[idx], &idx);
+			break;
+
+		case CMD_MATH:
+			show_math(&desc[idx], &idx);
+			break;
+
+		case CMD_SEQ_IN_PTR:
+			show_seq_in_ptr(&desc[idx], &idx);
+			break;
+
+		case CMD_SEQ_OUT_PTR:
+			show_seq_out_ptr(&desc[idx], &idx);
+			break;
+
+		default:
+			PRINT("<unrecognized command>: 0x%08x\n",
+			      desc[idx++]);
+			break;
+		}
+	}
+}
+EXPORT_SYMBOL(caam_desc_disasm);
diff --git a/drivers/crypto/caam/dcl/jobdesc.c b/drivers/crypto/caam/dcl/jobdesc.c
new file mode 100644
index 0000000..3cf1a32
--- /dev/null
+++ b/drivers/crypto/caam/dcl/jobdesc.c
@@ -0,0 +1,74 @@
+/*
+ * CAAM Descriptor Construction Library
+ * Basic job descriptor construction
+ *
+ * Copyright (c) 2009, Freescale Semiconductor, Inc.
+ * All Rights Reserved
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "../compat.h"
+#include "dcl.h"
+
+
+int cnstr_seq_jobdesc(u_int32_t *jobdesc, unsigned short *jobdescsz,
+		      u_int32_t *shrdesc, unsigned short shrdescsz,
+		      unsigned char *inbuf, unsigned long insize,
+		      unsigned char *outbuf, unsigned long outsize)
+{
+	u_int32_t *next;
+
+	/*
+	 * Basic structure is
+	 * - header (assume sharing, reverse order)
+	 * - sharedesc physical address
+	 * - SEQ_OUT_PTR
+	 * - SEQ_IN_PTR
+	 */
+
+	/* Make running pointer past where header will go */
+	next = jobdesc;
+	next++;
+
+	/* Insert sharedesc */
+	*next++ = (u_int32_t)shrdesc;
+
+	/* Sequence pointers */
+	next = cmd_insert_seq_out_ptr(next, (void *)outbuf, outsize,
+				      PTR_DIRECT);
+	next = cmd_insert_seq_in_ptr(next, (void *)inbuf, insize,
+				     PTR_DIRECT);
+
+	/* Now update header */
+	*jobdescsz = next - jobdesc; /* add 1 to include header */
+	cmd_insert_hdr(jobdesc, shrdescsz, *jobdescsz, SHR_SERIAL,
+		       SHRNXT_SHARED, ORDER_REVERSE, DESC_STD);
+
+	return 0;
+}
diff --git a/drivers/crypto/caam/dcl/protoshared.c b/drivers/crypto/caam/dcl/protoshared.c
new file mode 100644
index 0000000..dbf896e
--- /dev/null
+++ b/drivers/crypto/caam/dcl/protoshared.c
@@ -0,0 +1,259 @@
+/*
+ * CAAM Descriptor Construction Library
+ * Protocol-level Shared Descriptor Constructors
+ *
+ * Copyright (c) 2008, 2009, Freescale Semiconductor, Inc.
+ * All Rights Reserved
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "../compat.h"
+#include "dcl.h"
+
+int32_t cnstr_pcl_shdsc_ipsec_cbc_decap(u_int32_t           *descbuf,
+					u_int16_t           *bufsize,
+					struct pdbcont      *pdb,
+					struct cipherparams *cipherdata,
+					struct authparams   *authdata,
+					u_int8_t             clear)
+{
+	u_int32_t *start;
+	u_int8_t   pdbopts;
+	u_int16_t  startidx, endidx;
+
+	start = descbuf++; /* save start for eventual header write */
+			   /* bump to first word of PDB */
+
+	/* first, got to have clean buffer */
+	if (!descbuf)
+		return -1;
+
+	/* Prove other arguments */
+	if (!authdata->key)
+		return -3;
+
+	if (!cipherdata->key)
+		return -4;
+
+	if (!authdata->keylen)
+		return -5;
+
+	if (!cipherdata->keylen)
+		return -6;
+
+	/* If user requested a buffer clear, do it from the start */
+	if (clear)
+		memset(start, 0, (*bufsize * sizeof(u_int32_t)));
+
+	/* Build PDB, beginning with length and options */
+	pdbopts = 0;
+
+	if (pdb->transmode == PDB_TUNNEL)
+		pdbopts |= PDBOPTS_ESPCBC_TUNNEL;
+
+	if (pdb->pclvers == PDB_IPV6)
+		pdbopts |= PDBOPTS_ESPCBC_IPVSN;
+
+	if (pdb->outfmt == PDB_OUTPUT_DECAP_PDU)
+		pdbopts |= PDBOPTS_ESPCBC_OUTFMT;
+
+	if (pdb->seq.esn == PDB_INCLUDE_ESN)
+		pdbopts |= PDBOPTS_ESPCBC_ESN;
+
+	switch (pdb->seq.antirplysz) {
+	case PDB_ANTIRPLY_32:
+		pdbopts |= PDBOPTS_ESPCBC_ARS32;
+		break;
+
+	case PDB_ANTIRPLY_64:
+		pdbopts |= PDBOPTS_ESPCBC_ARS64;
+		break;
+
+	case PDB_ANTIRPLY_NONE:
+	default:
+		pdbopts |= PDBOPTS_ESPCBC_ARSNONE;
+		break;
+	}
+
+	*descbuf++ = (pdb->opthdrlen << 16) | pdbopts;
+
+	/* Skip reserved section */
+	descbuf += 2;
+
+	/* Skip DECO writeback part */
+	descbuf += 4;
+
+	/* Save current location for computing start index */
+	startidx = descbuf - start;
+
+	/*
+	 * PDB now complete
+	 * Now process keys, starting with class 2/authentication
+	 * This is assuming keys are immediate for sharedesc
+	 */
+	descbuf = cmd_insert_key(descbuf, authdata->key, authdata->keylen,
+				 PTR_DIRECT, KEYDST_KEYREG, KEY_CLEAR,
+				 ITEM_INLINE, ITEM_CLASS2);
+
+	/* Now the class 1/cipher key */
+	descbuf = cmd_insert_key(descbuf, cipherdata->key, cipherdata->keylen,
+				 PTR_DIRECT, KEYDST_KEYREG, KEY_CLEAR,
+				 ITEM_INLINE, ITEM_CLASS1);
+
+
+	/* Insert the operation command */
+	descbuf = cmd_insert_proto_op_ipsec(descbuf,
+					    cipherdata->algtype,
+					    authdata->algtype,
+					    DIR_DECAP);
+
+	/* Now update the header with size/offsets */
+	endidx = descbuf - start + 1; /* add 1 to include header */
+
+	cmd_insert_shared_hdr(start, startidx, endidx, CTX_ERASE, SHR_ALWAYS);
+
+	*bufsize = endidx;
+
+	return 0;
+}
+EXPORT_SYMBOL(cnstr_pcl_shdsc_ipsec_cbc_decap);
+
+int32_t cnstr_pcl_shdsc_ipsec_cbc_encap(u_int32_t           *descbuf,
+					u_int16_t           *bufsize,
+					struct pdbcont      *pdb,
+					struct cipherparams *cipherdata,
+					struct authparams   *authdata,
+					u_int8_t             clear)
+{
+	u_int32_t *start;
+	u_int8_t   pdbopts;
+	u_int16_t  hdrwds, startidx, endidx;
+	u_int32_t *hdrbuf;
+
+	start = descbuf++; /* save start for eventual header write */
+			   /* bump to first word of PDB */
+
+	/* Verify a clean buffer */
+	if (!descbuf)
+		return -1;
+
+	/* Verify other pertinent arguments */
+	if (!authdata->key)
+		return -3;
+
+	if (!cipherdata->key)
+		return -4;
+
+	if (!authdata->keylen)
+		return -5;
+
+	if (!cipherdata->keylen)
+		return -6;
+
+	/* If user requested a buffer clear, do it from the start */
+	if (clear)
+		memset(start, 0, (*bufsize * sizeof(u_int32_t)));
+
+	/* Construct PDB, starting with options word */
+	pdbopts = 0;
+
+	if (pdb->transmode == PDB_TUNNEL)
+		pdbopts |= PDBOPTS_ESPCBC_TUNNEL;
+
+	if (pdb->opthdrlen)
+		pdbopts |= PDBOPTS_ESPCBC_INCIPHDR | PDBOPTS_ESPCBC_IPHDRSRC;
+
+	if (pdb->pclvers == PDB_IPV6)
+		pdbopts |= PDBOPTS_ESPCBC_IPVSN;
+
+	if (pdb->seq.esn == PDB_INCLUDE_ESN)
+		pdbopts |= PDBOPTS_ESPCBC_ESN;
+
+	if (pdb->ivsrc == PDB_IV_FROM_RNG)
+		pdbopts |= PDBOPTS_ESPCBC_IVSRC;
+
+	*descbuf++ = pdbopts;
+
+	/* Skip sequence numbers */
+	descbuf += 2;
+
+	/* Skip IV */
+	descbuf += 4;
+
+	/* Skip SPI */
+	descbuf++;
+
+		*descbuf++ = pdb->opthdrlen;
+	/* If PDB-resident IPHeader, set size and append it */
+	if (pdb->opthdr && pdb->opthdrlen) {
+		hdrwds = pdb->opthdrlen >> 2;
+		hdrbuf = (u_int32_t *)pdb->opthdr;
+		while (hdrwds) {
+			*descbuf++ = *hdrbuf++;
+			hdrwds--;
+		}
+	}
+
+
+	/* Save current location for computing start index */
+	startidx = descbuf - start;
+
+	/*
+	 * Now process keys, starting with class 2/authentication
+	 * This is assuming keys are immediate for sharedesc
+	 */
+	descbuf = cmd_insert_key(descbuf, authdata->key, authdata->keylen,
+				 PTR_DIRECT, KEYDST_KEYREG, KEY_CLEAR,
+				 ITEM_INLINE, ITEM_CLASS2);
+
+	/* Now the class 1/cipher key */
+	descbuf = cmd_insert_key(descbuf, cipherdata->key, cipherdata->keylen,
+				 PTR_DIRECT, KEYDST_KEYREG, KEY_CLEAR,
+				 ITEM_INLINE, ITEM_CLASS1);
+
+
+	/* Now insert the operation command */
+	descbuf = cmd_insert_proto_op_ipsec(descbuf,
+					    cipherdata->algtype,
+					    authdata->algtype,
+					    DIR_ENCAP);
+
+	/*
+	 * Now update the header with size/offsets
+	 * add 1 to include header
+	 */
+	endidx = descbuf - start + 1;
+
+	cmd_insert_shared_hdr(start, startidx, endidx, CTX_ERASE, SHR_ALWAYS);
+
+	*bufsize = endidx;
+
+	return 0;
+}
+EXPORT_SYMBOL(cnstr_pcl_shdsc_ipsec_cbc_encap);
diff --git a/drivers/crypto/caam/desc.h b/drivers/crypto/caam/desc.h
new file mode 100644
index 0000000..e433bfd
--- /dev/null
+++ b/drivers/crypto/caam/desc.h
@@ -0,0 +1,1158 @@
+/*
+ * CAAM descriptor composition header
+ * Definitions to support CAAM descriptor instruction generation
+ *
+ * Copyright (c) 2008, 2009, Freescale Semiconductor, Inc.
+ * All Rights Reserved
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef DESC_H
+#define DESC_H
+
+/* Max size of any CAAM descriptor in 32-bit words */
+#define MAX_CAAM_DESCSIZE       63
+
+/*
+ * Supported descriptor command types as they show up
+ * inside a descriptor command word.
+ */
+#define CMD_SHIFT               27
+#define CMD_MASK                0xf8000000
+
+#define CMD_KEY                 (0x00 << CMD_SHIFT)
+#define CMD_SEQ_KEY             (0x01 << CMD_SHIFT)
+#define CMD_LOAD                (0x02 << CMD_SHIFT)
+#define CMD_SEQ_LOAD            (0x03 << CMD_SHIFT)
+#define CMD_FIFO_LOAD           (0x04 << CMD_SHIFT)
+#define CMD_SEQ_FIFO_LOAD       (0x05 << CMD_SHIFT)
+#define CMD_STORE               (0x0a << CMD_SHIFT)
+#define CMD_SEQ_STORE           (0x0b << CMD_SHIFT)
+#define CMD_FIFO_STORE          (0x0c << CMD_SHIFT)
+#define CMD_SEQ_FIFO_STORE      (0x0d << CMD_SHIFT)
+#define CMD_MOVE                (0x0f << CMD_SHIFT)
+#define CMD_OPERATION           (0x10 << CMD_SHIFT)
+#define CMD_SIGNATURE           (0x12 << CMD_SHIFT)
+#define CMD_JUMP                (0x14 << CMD_SHIFT)
+#define CMD_MATH                (0x15 << CMD_SHIFT)
+#define CMD_DESC_HDR            (0x16 << CMD_SHIFT)
+#define CMD_SHARED_DESC_HDR     (0x17 << CMD_SHIFT)
+#define CMD_SEQ_IN_PTR          (0x1e << CMD_SHIFT)
+#define CMD_SEQ_OUT_PTR         (0x1f << CMD_SHIFT)
+
+/* General-purpose class selector for all commands */
+#define CLASS_SHIFT             25
+#define CLASS_MASK              (0x03 << CLASS_SHIFT)
+
+#define CLASS_NONE              (0x00 << CLASS_SHIFT)
+#define CLASS_1                 (0x01 << CLASS_SHIFT)
+#define CLASS_2                 (0x02 << CLASS_SHIFT)
+#define CLASS_BOTH              (0x03 << CLASS_SHIFT)
+
+/*
+ * Descriptor header command constructs
+ * Covers shared, job, and trusted descriptor headers
+ */
+
+/*
+ * Do Not Run - marks a descriptor inexecutable if there was
+ * a preceding error somewhere
+ */
+#define HDR_DNR                 0x01000000
+
+/*
+ * One - should always be set. Combination of ONE (always
+ * set) and ZRO (always clear) forms an endianness sanity check
+ */
+#define HDR_ONE                 0x00800000
+
+/* Start Index or SharedDesc Length */
+#define HDR_START_IDX_MASK      0x3f
+#define HDR_START_IDX_SHIFT     16
+
+/* If shared descriptor header, 6-bit length */
+#define HDR_DESCLEN_SHR_MASK  0x3f
+
+/* If non-shared header, 7-bit length */
+#define HDR_DESCLEN_MASK      0x7f
+
+/* This is a TrustedDesc (if not SharedDesc) */
+#define HDR_TRUSTED             0x00004000
+
+/* Make into TrustedDesc (if not SharedDesc) */
+#define HDR_MAKE_TRUSTED        0x00002000
+
+/* Save context if self-shared (if SharedDesc) */
+#define HDR_SAVECTX             0x00001000
+
+/* Next item points to SharedDesc */
+#define HDR_SHARED              0x00001000
+
+/*
+ * Reverse Execution Order - execute JobDesc first, then
+ * execute SharedDesc (normally SharedDesc goes first).
+ */
+#define HDR_REVERSE             0x00000800
+
+/* Propogate DNR property to SharedDesc */
+#define HDR_PROP_DNR            0x00000800
+
+/* JobDesc/SharedDesc share property */
+#define HDR_SD_SHARE_MASK       0x03
+#define HDR_SD_SHARE_SHIFT      8
+#define HDR_JD_SHARE_MASK       0x07
+#define HDR_JD_SHARE_SHIFT      8
+
+#define HDR_SHARE_NEVER         (0x00 << HDR_SD_SHARE_SHIFT)
+#define HDR_SHARE_WAIT          (0x01 << HDR_SD_SHARE_SHIFT)
+#define HDR_SHARE_SERIAL        (0x02 << HDR_SD_SHARE_SHIFT)
+#define HDR_SHARE_ALWAYS        (0x03 << HDR_SD_SHARE_SHIFT)
+#define HDR_SHARE_DEFER         (0x04 << HDR_SD_SHARE_SHIFT)
+
+/* JobDesc/SharedDesc descriptor length */
+#define HDR_JD_LENGTH_MASK      0x7f
+#define HDR_SD_LENGTH_MASK      0x3f
+
+/*
+ * KEY/SEQ_KEY Command Constructs
+ */
+
+/* Key Destination Class: 01 = Class 1, 02 - Class 2  */
+#define KEY_DEST_CLASS_SHIFT    25  /* use CLASS_1 or CLASS_2 */
+#define KEY_DEST_CLASS_MASK     (0x03 << KEY_DEST_CLASS_SHIFT)
+
+/* Scatter-Gather Table/Variable Length Field */
+#define KEY_SGF                 0x01000000
+
+/* Immediate - Key follows command in the descriptor */
+#define KEY_IMM                 0x00800000
+
+/*
+ * Encrypted - Key is encrypted either with the KEK, or
+ * with the TDKEK if this descriptor is trusted
+ */
+#define KEY_ENC                 0x00400000
+
+/*
+ * KDEST - Key Destination: 0 - class key register,
+ * 1 - PKHA 'e', 2 - AFHA Sbox, 3 - MDHA split-key
+ */
+#define KEY_DEST_SHIFT          16
+#define KEY_DEST_MASK           (0x03 << KEY_DEST_SHIFT)
+
+#define KEY_DEST_CLASS_REG      (0x00 << KEY_DEST_SHIFT)
+#define KEY_DEST_PKHA_E         (0x01 << KEY_DEST_SHIFT)
+#define KEY_DEST_AFHA_SBOX      (0x02 << KEY_DEST_SHIFT)
+#define KEY_DEST_MDHA_SPLIT     (0x03 << KEY_DEST_SHIFT)
+
+/* Length in bytes */
+#define KEY_LENGTH_MASK         0x000003ff
+
+/*
+ * LOAD/SEQ_LOAD/STORE/SEQ_STORE Command Constructs
+ */
+
+/*
+ * Load/Store Destination: 0 = class independent CCB,
+ * 1 = class 1 CCB, 2 = class 2 CCB, 3 = DECO
+ */
+#define LDST_CLASS_SHIFT        25
+#define LDST_CLASS_IND_CCB      (0x00 << LDST_CLASS_SHIFT)
+#define LDST_CLASS_1_CCB        (0x01 << LDST_CLASS_SHIFT)
+#define LDST_CLASS_2_CCB        (0x02 << LDST_CLASS_SHIFT)
+#define LDST_CLASS_DECO         (0x03 << LDST_CLASS_SHIFT)
+
+/* Scatter-Gather Table/Variable Length Field */
+#define LDST_SGF                0x01000000
+
+/* Immediate - Key follows this command in descriptor    */
+#define LDST_IMM                0x00800000
+
+/* SRC/DST - Destination for LOAD, Source for STORE   */
+#define LDST_SRCDST_MASK        0x7f
+#define LDST_SRCDST_SHIFT       16
+
+/* Offset in source/destination                        */
+#define LDST_OFFSET_MASK        0xff
+#define LDST_OFFSET_SHIFT       8
+
+/* Data length in bytes                                 */
+#define LDST_LEN_MASK           0xff
+#define LDST_LEN_SHIFT          0
+
+/*
+ * FIFO_LOAD/FIFO_STORE/SEQ_FIFO_LOAD/SEQ_FIFO_STORE
+ * Command Constructs
+ */
+
+/*
+ * Load Destination: 0 = skip (SEQ_FIFO_LOAD only),
+ * 1 = Load for Class1, 2 = Load for Class2, 3 = Load both
+ * Store Source: 0 = normal, 1 = Class1key, 2 = Class2key
+ */
+#define FIFOLD_CLASS_SHIFT      25
+#define FIFOLD_CLASS_SKIP       (0x00 << FIFOLD_CLASS_SHIFT)
+#define FIFOLD_CLASS_CLASS1     (0x01 << FIFOLD_CLASS_SHIFT)
+#define FIFOLD_CLASS_CLASS2     (0x02 << FIFOLD_CLASS_SHIFT)
+#define FIFOLD_CLASS_BOTH       (0x03 << FIFOLD_CLASS_SHIFT)
+
+#define FIFOST_CLASS_NORMAL     (0x00 << FIFOLD_CLASS_SHIFT)
+#define FIFOST_CLASS_CLASS1KEY  (0x01 << FIFOLD_CLASS_SHIFT)
+#define FIFOST_CLASS_CLASS2KEY  (0x02 << FIFOLD_CLASS_SHIFT)
+
+/*
+ * Scatter-Gather Table/Variable Length Field
+ * If set for FIFO_LOAD, refers to a SG table. Within
+ * SEQ_FIFO_LOAD, is variable input sequence
+ */
+#define FIFOLDST_SGF            0x01000000
+
+/* Immediate - Key follows command in descriptor */
+#define FIFOLDST_IMM            0x00800000
+
+/*
+ * Extended Length - use 32-bit extended length that
+ * follows the pointer field. Illegal with IMM set
+ */
+#define FIFOLDST_EXT            0x00400000
+
+/* Input data type.*/
+#define FIFOLD_TYPE_SHIFT       16
+
+/* PK types */
+#define FIFOLD_TYPE_PK_A0       (0x00 << FIFOLD_TYPE_SHIFT)
+#define FIFOLD_TYPE_PK_A1       (0x01 << FIFOLD_TYPE_SHIFT)
+#define FIFOLD_TYPE_PK_A2       (0x02 << FIFOLD_TYPE_SHIFT)
+#define FIFOLD_TYPE_PK_A3       (0x03 << FIFOLD_TYPE_SHIFT)
+#define FIFOLD_TYPE_PK_B0       (0x04 << FIFOLD_TYPE_SHIFT)
+#define FIFOLD_TYPE_PK_B1       (0x05 << FIFOLD_TYPE_SHIFT)
+#define FIFOLD_TYPE_PK_B2       (0x06 << FIFOLD_TYPE_SHIFT)
+#define FIFOLD_TYPE_PK_B3       (0x07 << FIFOLD_TYPE_SHIFT)
+#define FIFOLD_TYPE_PK_N        (0x08 << FIFOLD_TYPE_SHIFT)
+#define FIFOLD_TYPE_PK_A        (0x0c << FIFOLD_TYPE_SHIFT)
+#define FIFOLD_TYPE_PK_B        (0x0d << FIFOLD_TYPE_SHIFT)
+
+/* Other types. Need to OR in last/flush bits as desired */
+#define FIFOLD_TYPE_MSG         (0x10 << FIFOLD_TYPE_SHIFT)
+#define FIFOLD_TYPE_MSG1OUT2    (0x18 << FIFOLD_TYPE_SHIFT)
+#define FIFOLD_TYPE_IV          (0x20 << FIFOLD_TYPE_SHIFT)
+#define FIFOLD_TYPE_BITDATA     (0x28 << FIFOLD_TYPE_SHIFT)
+#define FIFOLD_TYPE_AAD         (0x30 << FIFOLD_TYPE_SHIFT)
+#define FIFOLD_TYPE_ICV         (0x38 << FIFOLD_TYPE_SHIFT)
+
+/* Last/Flush bits for use with "other" types above */
+#define FIFOLD_TYPE_NOACTION    (0x00 << FIFOLD_TYPE_SHIFT)
+#define FIFOLD_TYPE_FLUSH1      (0x01 << FIFOLD_TYPE_SHIFT)
+#define FIFOLD_TYPE_LAST1       (0x02 << FIFOLD_TYPE_SHIFT)
+#define FIFOLD_TYPE_LAST2FLUSH  (0x03 << FIFOLD_TYPE_SHIFT)
+#define FIFOLD_TYPE_LAST2       (0x04 << FIFOLD_TYPE_SHIFT)
+#define FIFOLD_TYPE_LAST2FLUSH1 (0x05 << FIFOLD_TYPE_SHIFT)
+#define FIFOLD_TYPE_LASTBOTH    (0x06 << FIFOLD_TYPE_SHIFT)
+#define FIFOLD_TYPE_LASTBOTHFL  (0x07 << FIFOLD_TYPE_SHIFT)
+
+/*
+ * OPERATION Command Constructs
+ */
+
+/* Operation type selectors - OP TYPE */
+#define OP_TYPE_SHIFT           24
+#define OP_TYPE_MASK            (0x07 << OP_TYPE_SHIFT)
+
+#define OP_TYPE_UNI_PROTOCOL    (0x00 << OP_TYPE_SHIFT)
+#define OP_TYPE_PK              (0x01 << OP_TYPE_SHIFT)
+#define OP_TYPE_CLASS1_ALG      (0x02 << OP_TYPE_SHIFT)
+#define OP_TYPE_CLASS2_ALG      (0x04 << OP_TYPE_SHIFT)
+#define OP_TYPE_DECAP_PROTOCOL  (0x06 << OP_TYPE_SHIFT)
+#define OP_TYPE_ENCAP_PROTOCOL  (0x07 << OP_TYPE_SHIFT)
+
+/* ProtocolID selectors - PROTID */
+#define OP_PCLID_SHIFT          16
+#define OP_PCLID_MASK           (0xff << 16)
+
+/* Assuming OP_TYPE = OP_TYPE_UNI_PROTOCOL */
+#define OP_PCLID_IKEV1_PRF      (0x01 << OP_PCLID_SHIFT)
+#define OP_PCLID_IKEV2_PRF      (0x02 << OP_PCLID_SHIFT)
+#define OP_PCLID_SSL30_PRF      (0x08 << OP_PCLID_SHIFT)
+#define OP_PCLID_TLS10_PRF      (0x09 << OP_PCLID_SHIFT)
+#define OP_PCLID_TLS11_PRF      (0x0a << OP_PCLID_SHIFT)
+#define OP_PCLID_DTLS10_PRF     (0x0c << OP_PCLID_SHIFT)
+
+/* Assuming OP_TYPE = OP_TYPE_DECAP_PROTOCOL/ENCAP_PROTOCOL */
+#define OP_PCLID_IPSEC          (0x01 << OP_PCLID_SHIFT)
+#define OP_PCLID_SRTP           (0x02 << OP_PCLID_SHIFT)
+#define OP_PCLID_MACSEC         (0x03 << OP_PCLID_SHIFT)
+#define OP_PCLID_WIFI           (0x04 << OP_PCLID_SHIFT)
+#define OP_PCLID_WIMAX          (0x05 << OP_PCLID_SHIFT)
+#define OP_PCLID_SSL30          (0x08 << OP_PCLID_SHIFT)
+#define OP_PCLID_TLS10          (0x09 << OP_PCLID_SHIFT)
+#define OP_PCLID_TLS11          (0x0a << OP_PCLID_SHIFT)
+#define OP_PCLID_TLS12          (0x0b << OP_PCLID_SHIFT)
+#define OP_PCLID_DTLS           (0x0c << OP_PCLID_SHIFT)
+
+/* Assuming OP_TYPE = other... */
+#define OP_PCLID_PRF            (0x06 << OP_PCLID_SHIFT)
+#define OP_PCLID_BLOB           (0x0d << OP_PCLID_SHIFT)
+#define OP_PCLID_SECRETKEY      (0x11 << OP_PCLID_SHIFT)
+#define OP_PCLID_PUBLICKEYPAIR  (0x14 << OP_PCLID_SHIFT)
+#define OP_PCLID_DSASIGN        (0x15 << OP_PCLID_SHIFT)
+#define OP_PCLID_DSAVERIFY      (0x16 << OP_PCLID_SHIFT)
+
+/*
+ * ProtocolInfo selectors
+ */
+#define OP_PCLINFO_MASK                          0xffff
+
+/* for OP_PCLID_IPSEC */
+#define OP_PCL_IPSEC_CIPHER_MASK                 0xff00
+#define OP_PCL_IPSEC_AUTH_MASK                   0x00ff
+
+#define OP_PCL_IPSEC_DES_IV64                    0x0100
+#define OP_PCL_IPSEC_DES                         0x0200
+#define OP_PCL_IPSEC_3DES                        0x0300
+#define OP_PCL_IPSEC_AES_CBC                     0x0c00
+#define OP_PCL_IPSEC_AES_CTR                     0x0d00
+#define OP_PCL_IPSEC_AES_XTS                     0x1600
+#define OP_PCL_IPSEC_AES_CCM8                    0x0e00
+#define OP_PCL_IPSEC_AES_CCM12                   0x0f00
+#define OP_PCL_IPSEC_AES_CCM16                   0x1000
+#define OP_PCL_IPSEC_AES_GCM8                    0x1200
+#define OP_PCL_IPSEC_AES_GCM12                   0x1300
+#define OP_PCL_IPSEC_AES_GCM16                   0x1400
+
+#define OP_PCL_IPSEC_HMAC_NULL                   0x0000
+#define OP_PCL_IPSEC_HMAC_MD5_96                 0x0001
+#define OP_PCL_IPSEC_HMAC_SHA1_96                0x0002
+#define OP_PCL_IPSEC_AES_XCBC_MAC_96             0x0005
+#define OP_PCL_IPSEC_HMAC_MD5_128                0x0006
+#define OP_PCL_IPSEC_HMAC_SHA1_160               0x0007
+#define OP_PCL_IPSEC_HMAC_SHA2_256_128           0x000c
+#define OP_PCL_IPSEC_HMAC_SHA2_384_192           0x000d
+#define OP_PCL_IPSEC_HMAC_SHA2_512_256           0x000e
+
+/* For SRTP - OP_PCLID_SRTP */
+#define OP_PCL_SRTP_CIPHER_MASK                  0xff00
+#define OP_PCL_SRTP_AUTH_MASK                    0x00ff
+
+#define OP_PCL_SRTP_AES_CTR                      0x0d00
+
+#define OP_PCL_SRTP_HMAC_SHA1_160                0x0007
+
+/* For SSL 3.0 - OP_PCLID_SSL30 */
+#define OP_PCL_SSL30_AES_128_CBC_SHA             0x002f
+#define OP_PCL_SSL30_AES_128_CBC_SHA_2           0x0030
+#define OP_PCL_SSL30_AES_128_CBC_SHA_3           0x0031
+#define OP_PCL_SSL30_AES_128_CBC_SHA_4           0x0032
+#define OP_PCL_SSL30_AES_128_CBC_SHA_5           0x0033
+#define OP_PCL_SSL30_AES_128_CBC_SHA_6           0x0034
+#define OP_PCL_SSL30_AES_128_CBC_SHA_7           0x008c
+#define OP_PCL_SSL30_AES_128_CBC_SHA_8           0x0090
+#define OP_PCL_SSL30_AES_128_CBC_SHA_9           0x0094
+#define OP_PCL_SSL30_AES_128_CBC_SHA_10          0xc004
+#define OP_PCL_SSL30_AES_128_CBC_SHA_11          0xc009
+#define OP_PCL_SSL30_AES_128_CBC_SHA_12          0xc00e
+#define OP_PCL_SSL30_AES_128_CBC_SHA_13          0xc013
+#define OP_PCL_SSL30_AES_128_CBC_SHA_14          0xc018
+#define OP_PCL_SSL30_AES_128_CBC_SHA_15          0xc01d
+#define OP_PCL_SSL30_AES_128_CBC_SHA_16          0xc01e
+#define OP_PCL_SSL30_AES_128_CBC_SHA_17          0xc01f
+
+#define OP_PCL_SSL30_AES_256_CBC_SHA             0x0035
+#define OP_PCL_SSL30_AES_256_CBC_SHA_2           0x0036
+#define OP_PCL_SSL30_AES_256_CBC_SHA_3           0x0037
+#define OP_PCL_SSL30_AES_256_CBC_SHA_4           0x0038
+#define OP_PCL_SSL30_AES_256_CBC_SHA_5           0x0039
+#define OP_PCL_SSL30_AES_256_CBC_SHA_6           0x003a
+#define OP_PCL_SSL30_AES_256_CBC_SHA_7           0x008d
+#define OP_PCL_SSL30_AES_256_CBC_SHA_8           0x0091
+#define OP_PCL_SSL30_AES_256_CBC_SHA_9           0x0095
+#define OP_PCL_SSL30_AES_256_CBC_SHA_10          0xc005
+#define OP_PCL_SSL30_AES_256_CBC_SHA_11          0xc00a
+#define OP_PCL_SSL30_AES_256_CBC_SHA_12          0xc00f
+#define OP_PCL_SSL30_AES_256_CBC_SHA_13          0xc014
+#define OP_PCL_SSL30_AES_256_CBC_SHA_14          0xc019
+#define OP_PCL_SSL30_AES_256_CBC_SHA_15          0xc020
+#define OP_PCL_SSL30_AES_256_CBC_SHA_16          0xc021
+#define OP_PCL_SSL30_AES_256_CBC_SHA_17          0xc022
+
+#define OP_PCL_SSL30_3DES_EDE_CBC_MD5            0x0023
+
+#define OP_PCL_SSL30_3DES_EDE_CBC_SHA            0x001f
+#define OP_PCL_SSL30_3DES_EDE_CBC_SHA_2          0x008b
+#define OP_PCL_SSL30_3DES_EDE_CBC_SHA_3          0x008f
+#define OP_PCL_SSL30_3DES_EDE_CBC_SHA_4          0x0093
+#define OP_PCL_SSL30_3DES_EDE_CBC_SHA_5          0x000a
+#define OP_PCL_SSL30_3DES_EDE_CBC_SHA_6          0x000d
+#define OP_PCL_SSL30_3DES_EDE_CBC_SHA_7          0x0010
+#define OP_PCL_SSL30_3DES_EDE_CBC_SHA_8          0x0013
+#define OP_PCL_SSL30_3DES_EDE_CBC_SHA_9          0x0016
+#define OP_PCL_SSL30_3DES_EDE_CBC_SHA_10         0x001b
+#define OP_PCL_SSL30_3DES_EDE_CBC_SHA_11         0xc003
+#define OP_PCL_SSL30_3DES_EDE_CBC_SHA_12         0xc008
+#define OP_PCL_SSL30_3DES_EDE_CBC_SHA_13         0xc00d
+#define OP_PCL_SSL30_3DES_EDE_CBC_SHA_14         0xc012
+#define OP_PCL_SSL30_3DES_EDE_CBC_SHA_15         0xc017
+#define OP_PCL_SSL30_3DES_EDE_CBC_SHA_16         0xc01a
+#define OP_PCL_SSL30_3DES_EDE_CBC_SHA_17         0xc01b
+#define OP_PCL_SSL30_3DES_EDE_CBC_SHA_18         0xc01c
+
+#define OP_PCL_SSL30_DES40_CBC_MD5               0x0029
+
+#define OP_PCL_SSL30_DES_CBC_MD5                 0x0022
+
+#define OP_PCL_SSL30_DES40_CBC_SHA               0x0008
+#define OP_PCL_SSL30_DES40_CBC_SHA_2             0x000b
+#define OP_PCL_SSL30_DES40_CBC_SHA_3             0x000e
+#define OP_PCL_SSL30_DES40_CBC_SHA_4             0x0011
+#define OP_PCL_SSL30_DES40_CBC_SHA_5             0x0014
+#define OP_PCL_SSL30_DES40_CBC_SHA_6             0x0019
+#define OP_PCL_SSL30_DES40_CBC_SHA_7             0x0026
+
+#define OP_PCL_SSL30_DES_CBC_SHA                 0x001e
+#define OP_PCL_SSL30_DES_CBC_SHA_2               0x0009
+#define OP_PCL_SSL30_DES_CBC_SHA_3               0x000c
+#define OP_PCL_SSL30_DES_CBC_SHA_4               0x000f
+#define OP_PCL_SSL30_DES_CBC_SHA_5               0x0012
+#define OP_PCL_SSL30_DES_CBC_SHA_6               0x0015
+#define OP_PCL_SSL30_DES_CBC_SHA_7               0x001a
+
+#define OP_PCL_SSL30_RC4_128_MD5                 0x0024
+#define OP_PCL_SSL30_RC4_128_MD5_2               0x0004
+#define OP_PCL_SSL30_RC4_128_MD5_3               0x0018
+
+#define OP_PCL_SSL30_RC4_40_MD5                  0x002b
+#define OP_PCL_SSL30_RC4_40_MD5_2                0x0003
+#define OP_PCL_SSL30_RC4_40_MD5_3                0x0017
+
+#define OP_PCL_SSL30_RC4_128_SHA                 0x0020
+#define OP_PCL_SSL30_RC4_128_SHA_2               0x008a
+#define OP_PCL_SSL30_RC4_128_SHA_3               0x008e
+#define OP_PCL_SSL30_RC4_128_SHA_4               0x0092
+#define OP_PCL_SSL30_RC4_128_SHA_5               0x0005
+#define OP_PCL_SSL30_RC4_128_SHA_6               0xc002
+#define OP_PCL_SSL30_RC4_128_SHA_7               0xc007
+#define OP_PCL_SSL30_RC4_128_SHA_8               0xc00c
+#define OP_PCL_SSL30_RC4_128_SHA_9               0xc011
+#define OP_PCL_SSL30_RC4_128_SHA_10              0xc016
+
+#define OP_PCL_SSL30_RC4_40_SHA                  0x0028
+
+
+/* For TLS 1.0 - OP_PCLID_TLS10 */
+#define OP_PCL_TLS10_AES_128_CBC_SHA             0x002f
+#define OP_PCL_TLS10_AES_128_CBC_SHA_2           0x0030
+#define OP_PCL_TLS10_AES_128_CBC_SHA_3           0x0031
+#define OP_PCL_TLS10_AES_128_CBC_SHA_4           0x0032
+#define OP_PCL_TLS10_AES_128_CBC_SHA_5           0x0033
+#define OP_PCL_TLS10_AES_128_CBC_SHA_6           0x0034
+#define OP_PCL_TLS10_AES_128_CBC_SHA_7           0x008c
+#define OP_PCL_TLS10_AES_128_CBC_SHA_8           0x0090
+#define OP_PCL_TLS10_AES_128_CBC_SHA_9           0x0094
+#define OP_PCL_TLS10_AES_128_CBC_SHA_10          0xc004
+#define OP_PCL_TLS10_AES_128_CBC_SHA_11          0xc009
+#define OP_PCL_TLS10_AES_128_CBC_SHA_12          0xc00e
+#define OP_PCL_TLS10_AES_128_CBC_SHA_13          0xc013
+#define OP_PCL_TLS10_AES_128_CBC_SHA_14          0xc018
+#define OP_PCL_TLS10_AES_128_CBC_SHA_15          0xc01d
+#define OP_PCL_TLS10_AES_128_CBC_SHA_16          0xc01e
+#define OP_PCL_TLS10_AES_128_CBC_SHA_17          0xc01f
+
+#define OP_PCL_TLS10_AES_256_CBC_SHA             0x0035
+#define OP_PCL_TLS10_AES_256_CBC_SHA_2           0x0036
+#define OP_PCL_TLS10_AES_256_CBC_SHA_3           0x0037
+#define OP_PCL_TLS10_AES_256_CBC_SHA_4           0x0038
+#define OP_PCL_TLS10_AES_256_CBC_SHA_5           0x0039
+#define OP_PCL_TLS10_AES_256_CBC_SHA_6           0x003a
+#define OP_PCL_TLS10_AES_256_CBC_SHA_7           0x008d
+#define OP_PCL_TLS10_AES_256_CBC_SHA_8           0x0091
+#define OP_PCL_TLS10_AES_256_CBC_SHA_9           0x0095
+#define OP_PCL_TLS10_AES_256_CBC_SHA_10          0xc005
+#define OP_PCL_TLS10_AES_256_CBC_SHA_11          0xc00a
+#define OP_PCL_TLS10_AES_256_CBC_SHA_12          0xc00f
+#define OP_PCL_TLS10_AES_256_CBC_SHA_13          0xc014
+#define OP_PCL_TLS10_AES_256_CBC_SHA_14          0xc019
+#define OP_PCL_TLS10_AES_256_CBC_SHA_15          0xc020
+#define OP_PCL_TLS10_AES_256_CBC_SHA_16          0xc021
+#define OP_PCL_TLS10_AES_256_CBC_SHA_17          0xc022
+
+/* #define OP_PCL_TLS10_3DES_EDE_CBC_MD5            0x0023 */
+
+#define OP_PCL_TLS10_3DES_EDE_CBC_SHA            0x001f
+#define OP_PCL_TLS10_3DES_EDE_CBC_SHA_2          0x008b
+#define OP_PCL_TLS10_3DES_EDE_CBC_SHA_3          0x008f
+#define OP_PCL_TLS10_3DES_EDE_CBC_SHA_4          0x0093
+#define OP_PCL_TLS10_3DES_EDE_CBC_SHA_5          0x000a
+#define OP_PCL_TLS10_3DES_EDE_CBC_SHA_6          0x000d
+#define OP_PCL_TLS10_3DES_EDE_CBC_SHA_7          0x0010
+#define OP_PCL_TLS10_3DES_EDE_CBC_SHA_8          0x0013
+#define OP_PCL_TLS10_3DES_EDE_CBC_SHA_9          0x0016
+#define OP_PCL_TLS10_3DES_EDE_CBC_SHA_10         0x001b
+#define OP_PCL_TLS10_3DES_EDE_CBC_SHA_11         0xc003
+#define OP_PCL_TLS10_3DES_EDE_CBC_SHA_12         0xc008
+#define OP_PCL_TLS10_3DES_EDE_CBC_SHA_13         0xc00d
+#define OP_PCL_TLS10_3DES_EDE_CBC_SHA_14         0xc012
+#define OP_PCL_TLS10_3DES_EDE_CBC_SHA_15         0xc017
+#define OP_PCL_TLS10_3DES_EDE_CBC_SHA_16         0xc01a
+#define OP_PCL_TLS10_3DES_EDE_CBC_SHA_17         0xc01b
+#define OP_PCL_TLS10_3DES_EDE_CBC_SHA_18         0xc01c
+
+#define OP_PCL_TLS10_DES40_CBC_MD5               0x0029
+
+#define OP_PCL_TLS10_DES_CBC_MD5                 0x0022
+
+#define OP_PCL_TLS10_DES40_CBC_SHA               0x0008
+#define OP_PCL_TLS10_DES40_CBC_SHA_2             0x000b
+#define OP_PCL_TLS10_DES40_CBC_SHA_3             0x000e
+#define OP_PCL_TLS10_DES40_CBC_SHA_4             0x0011
+#define OP_PCL_TLS10_DES40_CBC_SHA_5             0x0014
+#define OP_PCL_TLS10_DES40_CBC_SHA_6             0x0019
+#define OP_PCL_TLS10_DES40_CBC_SHA_7             0x0026
+
+
+#define OP_PCL_TLS10_DES_CBC_SHA                 0x001e
+#define OP_PCL_TLS10_DES_CBC_SHA_2               0x0009
+#define OP_PCL_TLS10_DES_CBC_SHA_3               0x000c
+#define OP_PCL_TLS10_DES_CBC_SHA_4               0x000f
+#define OP_PCL_TLS10_DES_CBC_SHA_5               0x0012
+#define OP_PCL_TLS10_DES_CBC_SHA_6               0x0015
+#define OP_PCL_TLS10_DES_CBC_SHA_7               0x001a
+
+#define OP_PCL_TLS10_RC4_128_MD5                 0x0024
+#define OP_PCL_TLS10_RC4_128_MD5_2               0x0004
+#define OP_PCL_TLS10_RC4_128_MD5_3               0x0018
+
+#define OP_PCL_TLS10_RC4_40_MD5                  0x002b
+#define OP_PCL_TLS10_RC4_40_MD5_2                0x0003
+#define OP_PCL_TLS10_RC4_40_MD5_3                0x0017
+
+#define OP_PCL_TLS10_RC4_128_SHA                 0x0020
+#define OP_PCL_TLS10_RC4_128_SHA_2               0x008a
+#define OP_PCL_TLS10_RC4_128_SHA_3               0x008e
+#define OP_PCL_TLS10_RC4_128_SHA_4               0x0092
+#define OP_PCL_TLS10_RC4_128_SHA_5               0x0005
+#define OP_PCL_TLS10_RC4_128_SHA_6               0xc002
+#define OP_PCL_TLS10_RC4_128_SHA_7               0xc007
+#define OP_PCL_TLS10_RC4_128_SHA_8               0xc00c
+#define OP_PCL_TLS10_RC4_128_SHA_9               0xc011
+#define OP_PCL_TLS10_RC4_128_SHA_10              0xc016
+
+#define OP_PCL_TLS10_RC4_40_SHA                  0x0028
+
+#define OP_PCL_TLS10_3DES_EDE_CBC_MD5            0xff23
+#define OP_PCL_TLS10_3DES_EDE_CBC_SHA160         0xff30
+#define OP_PCL_TLS10_3DES_EDE_CBC_SHA224         0xff34
+#define OP_PCL_TLS10_3DES_EDE_CBC_SHA256         0xff36
+#define OP_PCL_TLS10_3DES_EDE_CBC_SHA384         0xff33
+#define OP_PCL_TLS10_3DES_EDE_CBC_SHA512         0xff35
+#define OP_PCL_TLS10_AES_128_CBC_SHA160          0xff80
+#define OP_PCL_TLS10_AES_128_CBC_SHA224          0xff84
+#define OP_PCL_TLS10_AES_128_CBC_SHA256          0xff86
+#define OP_PCL_TLS10_AES_128_CBC_SHA384          0xff83
+#define OP_PCL_TLS10_AES_128_CBC_SHA512          0xff85
+#define OP_PCL_TLS10_AES_192_CBC_SHA160          0xff20
+#define OP_PCL_TLS10_AES_192_CBC_SHA224          0xff24
+#define OP_PCL_TLS10_AES_192_CBC_SHA256          0xff26
+#define OP_PCL_TLS10_AES_192_CBC_SHA384          0xff23
+#define OP_PCL_TLS10_AES_192_CBC_SHA512          0xff25
+#define OP_PCL_TLS10_AES_256_CBC_SHA160          0xff60
+#define OP_PCL_TLS10_AES_256_CBC_SHA224          0xff64
+#define OP_PCL_TLS10_AES_256_CBC_SHA256          0xff66
+#define OP_PCL_TLS10_AES_256_CBC_SHA384          0xff63
+#define OP_PCL_TLS10_AES_256_CBC_SHA512          0xff65
+
+
+
+/* For TLS 1.1 - OP_PCLID_TLS11 */
+#define OP_PCL_TLS11_AES_128_CBC_SHA             0x002f
+#define OP_PCL_TLS11_AES_128_CBC_SHA_2           0x0030
+#define OP_PCL_TLS11_AES_128_CBC_SHA_3           0x0031
+#define OP_PCL_TLS11_AES_128_CBC_SHA_4           0x0032
+#define OP_PCL_TLS11_AES_128_CBC_SHA_5           0x0033
+#define OP_PCL_TLS11_AES_128_CBC_SHA_6           0x0034
+#define OP_PCL_TLS11_AES_128_CBC_SHA_7           0x008c
+#define OP_PCL_TLS11_AES_128_CBC_SHA_8           0x0090
+#define OP_PCL_TLS11_AES_128_CBC_SHA_9           0x0094
+#define OP_PCL_TLS11_AES_128_CBC_SHA_10          0xc004
+#define OP_PCL_TLS11_AES_128_CBC_SHA_11          0xc009
+#define OP_PCL_TLS11_AES_128_CBC_SHA_12          0xc00e
+#define OP_PCL_TLS11_AES_128_CBC_SHA_13          0xc013
+#define OP_PCL_TLS11_AES_128_CBC_SHA_14          0xc018
+#define OP_PCL_TLS11_AES_128_CBC_SHA_15          0xc01d
+#define OP_PCL_TLS11_AES_128_CBC_SHA_16          0xc01e
+#define OP_PCL_TLS11_AES_128_CBC_SHA_17          0xc01f
+
+#define OP_PCL_TLS11_AES_256_CBC_SHA             0x0035
+#define OP_PCL_TLS11_AES_256_CBC_SHA_2           0x0036
+#define OP_PCL_TLS11_AES_256_CBC_SHA_3           0x0037
+#define OP_PCL_TLS11_AES_256_CBC_SHA_4           0x0038
+#define OP_PCL_TLS11_AES_256_CBC_SHA_5           0x0039
+#define OP_PCL_TLS11_AES_256_CBC_SHA_6           0x003a
+#define OP_PCL_TLS11_AES_256_CBC_SHA_7           0x008d
+#define OP_PCL_TLS11_AES_256_CBC_SHA_8           0x0091
+#define OP_PCL_TLS11_AES_256_CBC_SHA_9           0x0095
+#define OP_PCL_TLS11_AES_256_CBC_SHA_10          0xc005
+#define OP_PCL_TLS11_AES_256_CBC_SHA_11          0xc00a
+#define OP_PCL_TLS11_AES_256_CBC_SHA_12          0xc00f
+#define OP_PCL_TLS11_AES_256_CBC_SHA_13          0xc014
+#define OP_PCL_TLS11_AES_256_CBC_SHA_14          0xc019
+#define OP_PCL_TLS11_AES_256_CBC_SHA_15          0xc020
+#define OP_PCL_TLS11_AES_256_CBC_SHA_16          0xc021
+#define OP_PCL_TLS11_AES_256_CBC_SHA_17          0xc022
+
+/* #define OP_PCL_TLS11_3DES_EDE_CBC_MD5            0x0023 */
+
+#define OP_PCL_TLS11_3DES_EDE_CBC_SHA            0x001f
+#define OP_PCL_TLS11_3DES_EDE_CBC_SHA_2          0x008b
+#define OP_PCL_TLS11_3DES_EDE_CBC_SHA_3          0x008f
+#define OP_PCL_TLS11_3DES_EDE_CBC_SHA_4          0x0093
+#define OP_PCL_TLS11_3DES_EDE_CBC_SHA_5          0x000a
+#define OP_PCL_TLS11_3DES_EDE_CBC_SHA_6          0x000d
+#define OP_PCL_TLS11_3DES_EDE_CBC_SHA_7          0x0010
+#define OP_PCL_TLS11_3DES_EDE_CBC_SHA_8          0x0013
+#define OP_PCL_TLS11_3DES_EDE_CBC_SHA_9          0x0016
+#define OP_PCL_TLS11_3DES_EDE_CBC_SHA_10         0x001b
+#define OP_PCL_TLS11_3DES_EDE_CBC_SHA_11         0xc003
+#define OP_PCL_TLS11_3DES_EDE_CBC_SHA_12         0xc008
+#define OP_PCL_TLS11_3DES_EDE_CBC_SHA_13         0xc00d
+#define OP_PCL_TLS11_3DES_EDE_CBC_SHA_14         0xc012
+#define OP_PCL_TLS11_3DES_EDE_CBC_SHA_15         0xc017
+#define OP_PCL_TLS11_3DES_EDE_CBC_SHA_16         0xc01a
+#define OP_PCL_TLS11_3DES_EDE_CBC_SHA_17         0xc01b
+#define OP_PCL_TLS11_3DES_EDE_CBC_SHA_18         0xc01c
+
+#define OP_PCL_TLS11_DES40_CBC_MD5               0x0029
+
+#define OP_PCL_TLS11_DES_CBC_MD5                 0x0022
+
+#define OP_PCL_TLS11_DES40_CBC_SHA               0x0008
+#define OP_PCL_TLS11_DES40_CBC_SHA_2             0x000b
+#define OP_PCL_TLS11_DES40_CBC_SHA_3             0x000e
+#define OP_PCL_TLS11_DES40_CBC_SHA_4             0x0011
+#define OP_PCL_TLS11_DES40_CBC_SHA_5             0x0014
+#define OP_PCL_TLS11_DES40_CBC_SHA_6             0x0019
+#define OP_PCL_TLS11_DES40_CBC_SHA_7             0x0026
+
+#define OP_PCL_TLS11_DES_CBC_SHA                 0x001e
+#define OP_PCL_TLS11_DES_CBC_SHA_2               0x0009
+#define OP_PCL_TLS11_DES_CBC_SHA_3               0x000c
+#define OP_PCL_TLS11_DES_CBC_SHA_4               0x000f
+#define OP_PCL_TLS11_DES_CBC_SHA_5               0x0012
+#define OP_PCL_TLS11_DES_CBC_SHA_6               0x0015
+#define OP_PCL_TLS11_DES_CBC_SHA_7               0x001a
+
+#define OP_PCL_TLS11_RC4_128_MD5                 0x0024
+#define OP_PCL_TLS11_RC4_128_MD5_2               0x0004
+#define OP_PCL_TLS11_RC4_128_MD5_3               0x0018
+
+#define OP_PCL_TLS11_RC4_40_MD5                  0x002b
+#define OP_PCL_TLS11_RC4_40_MD5_2                0x0003
+#define OP_PCL_TLS11_RC4_40_MD5_3                0x0017
+
+#define OP_PCL_TLS11_RC4_128_SHA                 0x0020
+#define OP_PCL_TLS11_RC4_128_SHA_2               0x008a
+#define OP_PCL_TLS11_RC4_128_SHA_3               0x008e
+#define OP_PCL_TLS11_RC4_128_SHA_4               0x0092
+#define OP_PCL_TLS11_RC4_128_SHA_5               0x0005
+#define OP_PCL_TLS11_RC4_128_SHA_6               0xc002
+#define OP_PCL_TLS11_RC4_128_SHA_7               0xc007
+#define OP_PCL_TLS11_RC4_128_SHA_8               0xc00c
+#define OP_PCL_TLS11_RC4_128_SHA_9               0xc011
+#define OP_PCL_TLS11_RC4_128_SHA_10              0xc016
+
+#define OP_PCL_TLS11_RC4_40_SHA                  0x0028
+
+#define OP_PCL_TLS11_3DES_EDE_CBC_MD5            0xff23
+#define OP_PCL_TLS11_3DES_EDE_CBC_SHA160         0xff30
+#define OP_PCL_TLS11_3DES_EDE_CBC_SHA224         0xff34
+#define OP_PCL_TLS11_3DES_EDE_CBC_SHA256         0xff36
+#define OP_PCL_TLS11_3DES_EDE_CBC_SHA384         0xff33
+#define OP_PCL_TLS11_3DES_EDE_CBC_SHA512         0xff35
+#define OP_PCL_TLS11_AES_128_CBC_SHA160          0xff80
+#define OP_PCL_TLS11_AES_128_CBC_SHA224          0xff84
+#define OP_PCL_TLS11_AES_128_CBC_SHA256          0xff86
+#define OP_PCL_TLS11_AES_128_CBC_SHA384          0xff83
+#define OP_PCL_TLS11_AES_128_CBC_SHA512          0xff85
+#define OP_PCL_TLS11_AES_192_CBC_SHA160          0xff20
+#define OP_PCL_TLS11_AES_192_CBC_SHA224          0xff24
+#define OP_PCL_TLS11_AES_192_CBC_SHA256          0xff26
+#define OP_PCL_TLS11_AES_192_CBC_SHA384          0xff23
+#define OP_PCL_TLS11_AES_192_CBC_SHA512          0xff25
+#define OP_PCL_TLS11_AES_256_CBC_SHA160          0xff60
+#define OP_PCL_TLS11_AES_256_CBC_SHA224          0xff64
+#define OP_PCL_TLS11_AES_256_CBC_SHA256          0xff66
+#define OP_PCL_TLS11_AES_256_CBC_SHA384          0xff63
+#define OP_PCL_TLS11_AES_256_CBC_SHA512          0xff65
+
+
+/* For TLS 1.2 - OP_PCLID_TLS12 */
+#define OP_PCL_TLS12_AES_128_CBC_SHA             0x002f
+#define OP_PCL_TLS12_AES_128_CBC_SHA_2           0x0030
+#define OP_PCL_TLS12_AES_128_CBC_SHA_3           0x0031
+#define OP_PCL_TLS12_AES_128_CBC_SHA_4           0x0032
+#define OP_PCL_TLS12_AES_128_CBC_SHA_5           0x0033
+#define OP_PCL_TLS12_AES_128_CBC_SHA_6           0x0034
+#define OP_PCL_TLS12_AES_128_CBC_SHA_7           0x008c
+#define OP_PCL_TLS12_AES_128_CBC_SHA_8           0x0090
+#define OP_PCL_TLS12_AES_128_CBC_SHA_9           0x0094
+#define OP_PCL_TLS12_AES_128_CBC_SHA_10          0xc004
+#define OP_PCL_TLS12_AES_128_CBC_SHA_11          0xc009
+#define OP_PCL_TLS12_AES_128_CBC_SHA_12          0xc00e
+#define OP_PCL_TLS12_AES_128_CBC_SHA_13          0xc013
+#define OP_PCL_TLS12_AES_128_CBC_SHA_14          0xc018
+#define OP_PCL_TLS12_AES_128_CBC_SHA_15          0xc01d
+#define OP_PCL_TLS12_AES_128_CBC_SHA_16          0xc01e
+#define OP_PCL_TLS12_AES_128_CBC_SHA_17          0xc01f
+
+#define OP_PCL_TLS12_AES_256_CBC_SHA             0x0035
+#define OP_PCL_TLS12_AES_256_CBC_SHA_2           0x0036
+#define OP_PCL_TLS12_AES_256_CBC_SHA_3           0x0037
+#define OP_PCL_TLS12_AES_256_CBC_SHA_4           0x0038
+#define OP_PCL_TLS12_AES_256_CBC_SHA_5           0x0039
+#define OP_PCL_TLS12_AES_256_CBC_SHA_6           0x003a
+#define OP_PCL_TLS12_AES_256_CBC_SHA_7           0x008d
+#define OP_PCL_TLS12_AES_256_CBC_SHA_8           0x0091
+#define OP_PCL_TLS12_AES_256_CBC_SHA_9           0x0095
+#define OP_PCL_TLS12_AES_256_CBC_SHA_10          0xc005
+#define OP_PCL_TLS12_AES_256_CBC_SHA_11          0xc00a
+#define OP_PCL_TLS12_AES_256_CBC_SHA_12          0xc00f
+#define OP_PCL_TLS12_AES_256_CBC_SHA_13          0xc014
+#define OP_PCL_TLS12_AES_256_CBC_SHA_14          0xc019
+#define OP_PCL_TLS12_AES_256_CBC_SHA_15          0xc020
+#define OP_PCL_TLS12_AES_256_CBC_SHA_16          0xc021
+#define OP_PCL_TLS12_AES_256_CBC_SHA_17          0xc022
+
+/* #define OP_PCL_TLS12_3DES_EDE_CBC_MD5            0x0023 */
+
+#define OP_PCL_TLS12_3DES_EDE_CBC_SHA            0x001f
+#define OP_PCL_TLS12_3DES_EDE_CBC_SHA_2          0x008b
+#define OP_PCL_TLS12_3DES_EDE_CBC_SHA_3          0x008f
+#define OP_PCL_TLS12_3DES_EDE_CBC_SHA_4          0x0093
+#define OP_PCL_TLS12_3DES_EDE_CBC_SHA_5          0x000a
+#define OP_PCL_TLS12_3DES_EDE_CBC_SHA_6          0x000d
+#define OP_PCL_TLS12_3DES_EDE_CBC_SHA_7          0x0010
+#define OP_PCL_TLS12_3DES_EDE_CBC_SHA_8          0x0013
+#define OP_PCL_TLS12_3DES_EDE_CBC_SHA_9          0x0016
+#define OP_PCL_TLS12_3DES_EDE_CBC_SHA_10         0x001b
+#define OP_PCL_TLS12_3DES_EDE_CBC_SHA_11         0xc003
+#define OP_PCL_TLS12_3DES_EDE_CBC_SHA_12         0xc008
+#define OP_PCL_TLS12_3DES_EDE_CBC_SHA_13         0xc00d
+#define OP_PCL_TLS12_3DES_EDE_CBC_SHA_14         0xc012
+#define OP_PCL_TLS12_3DES_EDE_CBC_SHA_15         0xc017
+#define OP_PCL_TLS12_3DES_EDE_CBC_SHA_16         0xc01a
+#define OP_PCL_TLS12_3DES_EDE_CBC_SHA_17         0xc01b
+#define OP_PCL_TLS12_3DES_EDE_CBC_SHA_18         0xc01c
+
+#define OP_PCL_TLS12_DES40_CBC_MD5               0x0029
+
+#define OP_PCL_TLS12_DES_CBC_MD5                 0x0022
+
+#define OP_PCL_TLS12_DES40_CBC_SHA               0x0008
+#define OP_PCL_TLS12_DES40_CBC_SHA_2             0x000b
+#define OP_PCL_TLS12_DES40_CBC_SHA_3             0x000e
+#define OP_PCL_TLS12_DES40_CBC_SHA_4             0x0011
+#define OP_PCL_TLS12_DES40_CBC_SHA_5             0x0014
+#define OP_PCL_TLS12_DES40_CBC_SHA_6             0x0019
+#define OP_PCL_TLS12_DES40_CBC_SHA_7             0x0026
+
+#define OP_PCL_TLS12_DES_CBC_SHA                 0x001e
+#define OP_PCL_TLS12_DES_CBC_SHA_2               0x0009
+#define OP_PCL_TLS12_DES_CBC_SHA_3               0x000c
+#define OP_PCL_TLS12_DES_CBC_SHA_4               0x000f
+#define OP_PCL_TLS12_DES_CBC_SHA_5               0x0012
+#define OP_PCL_TLS12_DES_CBC_SHA_6               0x0015
+#define OP_PCL_TLS12_DES_CBC_SHA_7               0x001a
+
+#define OP_PCL_TLS12_RC4_128_MD5                 0x0024
+#define OP_PCL_TLS12_RC4_128_MD5_2               0x0004
+#define OP_PCL_TLS12_RC4_128_MD5_3               0x0018
+
+#define OP_PCL_TLS12_RC4_40_MD5                  0x002b
+#define OP_PCL_TLS12_RC4_40_MD5_2                0x0003
+#define OP_PCL_TLS12_RC4_40_MD5_3                0x0017
+
+#define OP_PCL_TLS12_RC4_128_SHA                 0x0020
+#define OP_PCL_TLS12_RC4_128_SHA_2               0x008a
+#define OP_PCL_TLS12_RC4_128_SHA_3               0x008e
+#define OP_PCL_TLS12_RC4_128_SHA_4               0x0092
+#define OP_PCL_TLS12_RC4_128_SHA_5               0x0005
+#define OP_PCL_TLS12_RC4_128_SHA_6               0xc002
+#define OP_PCL_TLS12_RC4_128_SHA_7               0xc007
+#define OP_PCL_TLS12_RC4_128_SHA_8               0xc00c
+#define OP_PCL_TLS12_RC4_128_SHA_9               0xc011
+#define OP_PCL_TLS12_RC4_128_SHA_10              0xc016
+
+#define OP_PCL_TLS12_RC4_40_SHA                  0x0028
+
+/* #define OP_PCL_TLS12_AES_128_CBC_SHA256          0x003c */
+#define OP_PCL_TLS12_AES_128_CBC_SHA256_2        0x003e
+#define OP_PCL_TLS12_AES_128_CBC_SHA256_3        0x003f
+#define OP_PCL_TLS12_AES_128_CBC_SHA256_4        0x0040
+#define OP_PCL_TLS12_AES_128_CBC_SHA256_5        0x0067
+#define OP_PCL_TLS12_AES_128_CBC_SHA256_6        0x006c
+
+/* #define OP_PCL_TLS12_AES_256_CBC_SHA256          0x003d */
+#define OP_PCL_TLS12_AES_256_CBC_SHA256_2        0x0068
+#define OP_PCL_TLS12_AES_256_CBC_SHA256_3        0x0069
+#define OP_PCL_TLS12_AES_256_CBC_SHA256_4        0x006a
+#define OP_PCL_TLS12_AES_256_CBC_SHA256_5        0x006b
+#define OP_PCL_TLS12_AES_256_CBC_SHA256_6        0x006d
+
+/* AEAD_AES_xxx_CCM/GCM remain to be defined... */
+
+#define OP_PCL_TLS12_3DES_EDE_CBC_MD5            0xff23
+#define OP_PCL_TLS12_3DES_EDE_CBC_SHA160         0xff30
+#define OP_PCL_TLS12_3DES_EDE_CBC_SHA224         0xff34
+#define OP_PCL_TLS12_3DES_EDE_CBC_SHA256         0xff36
+#define OP_PCL_TLS12_3DES_EDE_CBC_SHA384         0xff33
+#define OP_PCL_TLS12_3DES_EDE_CBC_SHA512         0xff35
+#define OP_PCL_TLS12_AES_128_CBC_SHA160          0xff80
+#define OP_PCL_TLS12_AES_128_CBC_SHA224          0xff84
+#define OP_PCL_TLS12_AES_128_CBC_SHA256          0xff86
+#define OP_PCL_TLS12_AES_128_CBC_SHA384          0xff83
+#define OP_PCL_TLS12_AES_128_CBC_SHA512          0xff85
+#define OP_PCL_TLS12_AES_192_CBC_SHA160          0xff20
+#define OP_PCL_TLS12_AES_192_CBC_SHA224          0xff24
+#define OP_PCL_TLS12_AES_192_CBC_SHA256          0xff26
+#define OP_PCL_TLS12_AES_192_CBC_SHA384          0xff23
+#define OP_PCL_TLS12_AES_192_CBC_SHA512          0xff25
+#define OP_PCL_TLS12_AES_256_CBC_SHA160          0xff60
+#define OP_PCL_TLS12_AES_256_CBC_SHA224          0xff64
+#define OP_PCL_TLS12_AES_256_CBC_SHA256          0xff66
+#define OP_PCL_TLS12_AES_256_CBC_SHA384          0xff63
+#define OP_PCL_TLS12_AES_256_CBC_SHA512          0xff65
+
+/* For DTLS - OP_PCLID_DTLS */
+
+#define OP_PCL_DTLS_AES_128_CBC_SHA              0x002f
+#define OP_PCL_DTLS_AES_128_CBC_SHA_2            0x0030
+#define OP_PCL_DTLS_AES_128_CBC_SHA_3            0x0031
+#define OP_PCL_DTLS_AES_128_CBC_SHA_4            0x0032
+#define OP_PCL_DTLS_AES_128_CBC_SHA_5            0x0033
+#define OP_PCL_DTLS_AES_128_CBC_SHA_6            0x0034
+#define OP_PCL_DTLS_AES_128_CBC_SHA_7            0x008c
+#define OP_PCL_DTLS_AES_128_CBC_SHA_8            0x0090
+#define OP_PCL_DTLS_AES_128_CBC_SHA_9            0x0094
+#define OP_PCL_DTLS_AES_128_CBC_SHA_10           0xc004
+#define OP_PCL_DTLS_AES_128_CBC_SHA_11           0xc009
+#define OP_PCL_DTLS_AES_128_CBC_SHA_12           0xc00e
+#define OP_PCL_DTLS_AES_128_CBC_SHA_13           0xc013
+#define OP_PCL_DTLS_AES_128_CBC_SHA_14           0xc018
+#define OP_PCL_DTLS_AES_128_CBC_SHA_15           0xc01d
+#define OP_PCL_DTLS_AES_128_CBC_SHA_16           0xc01e
+#define OP_PCL_DTLS_AES_128_CBC_SHA_17           0xc01f
+
+#define OP_PCL_DTLS_AES_256_CBC_SHA              0x0035
+#define OP_PCL_DTLS_AES_256_CBC_SHA_2            0x0036
+#define OP_PCL_DTLS_AES_256_CBC_SHA_3            0x0037
+#define OP_PCL_DTLS_AES_256_CBC_SHA_4            0x0038
+#define OP_PCL_DTLS_AES_256_CBC_SHA_5            0x0039
+#define OP_PCL_DTLS_AES_256_CBC_SHA_6            0x003a
+#define OP_PCL_DTLS_AES_256_CBC_SHA_7            0x008d
+#define OP_PCL_DTLS_AES_256_CBC_SHA_8            0x0091
+#define OP_PCL_DTLS_AES_256_CBC_SHA_9            0x0095
+#define OP_PCL_DTLS_AES_256_CBC_SHA_10           0xc005
+#define OP_PCL_DTLS_AES_256_CBC_SHA_11           0xc00a
+#define OP_PCL_DTLS_AES_256_CBC_SHA_12           0xc00f
+#define OP_PCL_DTLS_AES_256_CBC_SHA_13           0xc014
+#define OP_PCL_DTLS_AES_256_CBC_SHA_14           0xc019
+#define OP_PCL_DTLS_AES_256_CBC_SHA_15           0xc020
+#define OP_PCL_DTLS_AES_256_CBC_SHA_16           0xc021
+#define OP_PCL_DTLS_AES_256_CBC_SHA_17           0xc022
+
+/* #define OP_PCL_DTLS_3DES_EDE_CBC_MD5             0x0023 */
+
+#define OP_PCL_DTLS_3DES_EDE_CBC_SHA             0x001f
+#define OP_PCL_DTLS_3DES_EDE_CBC_SHA_2           0x008b
+#define OP_PCL_DTLS_3DES_EDE_CBC_SHA_3           0x008f
+#define OP_PCL_DTLS_3DES_EDE_CBC_SHA_4           0x0093
+#define OP_PCL_DTLS_3DES_EDE_CBC_SHA_5           0x000a
+#define OP_PCL_DTLS_3DES_EDE_CBC_SHA_6           0x000d
+#define OP_PCL_DTLS_3DES_EDE_CBC_SHA_7           0x0010
+#define OP_PCL_DTLS_3DES_EDE_CBC_SHA_8           0x0013
+#define OP_PCL_DTLS_3DES_EDE_CBC_SHA_9           0x0016
+#define OP_PCL_DTLS_3DES_EDE_CBC_SHA_10          0x001b
+#define OP_PCL_DTLS_3DES_EDE_CBC_SHA_11          0xc003
+#define OP_PCL_DTLS_3DES_EDE_CBC_SHA_12          0xc008
+#define OP_PCL_DTLS_3DES_EDE_CBC_SHA_13          0xc00d
+#define OP_PCL_DTLS_3DES_EDE_CBC_SHA_14          0xc012
+#define OP_PCL_DTLS_3DES_EDE_CBC_SHA_15          0xc017
+#define OP_PCL_DTLS_3DES_EDE_CBC_SHA_16          0xc01a
+#define OP_PCL_DTLS_3DES_EDE_CBC_SHA_17          0xc01b
+#define OP_PCL_DTLS_3DES_EDE_CBC_SHA_18          0xc01c
+
+#define OP_PCL_DTLS_DES40_CBC_MD5                0x0029
+
+#define OP_PCL_DTLS_DES_CBC_MD5                  0x0022
+
+#define OP_PCL_DTLS_DES40_CBC_SHA                0x0008
+#define OP_PCL_DTLS_DES40_CBC_SHA_2              0x000b
+#define OP_PCL_DTLS_DES40_CBC_SHA_3              0x000e
+#define OP_PCL_DTLS_DES40_CBC_SHA_4              0x0011
+#define OP_PCL_DTLS_DES40_CBC_SHA_5              0x0014
+#define OP_PCL_DTLS_DES40_CBC_SHA_6              0x0019
+#define OP_PCL_DTLS_DES40_CBC_SHA_7              0x0026
+
+
+#define OP_PCL_DTLS_DES_CBC_SHA                  0x001e
+#define OP_PCL_DTLS_DES_CBC_SHA_2                0x0009
+#define OP_PCL_DTLS_DES_CBC_SHA_3                0x000c
+#define OP_PCL_DTLS_DES_CBC_SHA_4                0x000f
+#define OP_PCL_DTLS_DES_CBC_SHA_5                0x0012
+#define OP_PCL_DTLS_DES_CBC_SHA_6                0x0015
+#define OP_PCL_DTLS_DES_CBC_SHA_7                0x001a
+
+
+#define OP_PCL_DTLS_3DES_EDE_CBC_MD5             0xff23
+#define OP_PCL_DTLS_3DES_EDE_CBC_SHA160          0xff30
+#define OP_PCL_DTLS_3DES_EDE_CBC_SHA224          0xff34
+#define OP_PCL_DTLS_3DES_EDE_CBC_SHA256          0xff36
+#define OP_PCL_DTLS_3DES_EDE_CBC_SHA384          0xff33
+#define OP_PCL_DTLS_3DES_EDE_CBC_SHA512          0xff35
+#define OP_PCL_DTLS_AES_128_CBC_SHA160           0xff80
+#define OP_PCL_DTLS_AES_128_CBC_SHA224           0xff84
+#define OP_PCL_DTLS_AES_128_CBC_SHA256           0xff86
+#define OP_PCL_DTLS_AES_128_CBC_SHA384           0xff83
+#define OP_PCL_DTLS_AES_128_CBC_SHA512           0xff85
+#define OP_PCL_DTLS_AES_192_CBC_SHA160           0xff20
+#define OP_PCL_DTLS_AES_192_CBC_SHA224           0xff24
+#define OP_PCL_DTLS_AES_192_CBC_SHA256           0xff26
+#define OP_PCL_DTLS_AES_192_CBC_SHA384           0xff23
+#define OP_PCL_DTLS_AES_192_CBC_SHA512           0xff25
+#define OP_PCL_DTLS_AES_256_CBC_SHA160           0xff60
+#define OP_PCL_DTLS_AES_256_CBC_SHA224           0xff64
+#define OP_PCL_DTLS_AES_256_CBC_SHA256           0xff66
+#define OP_PCL_DTLS_AES_256_CBC_SHA384           0xff63
+#define OP_PCL_DTLS_AES_256_CBC_SHA512           0xff65
+
+/*
+ * SEQ_IN_PTR Command Constructs
+ */
+
+/* Release Buffers */
+#define SQIN_RBS               0x04000000
+
+/* Sequence pointer is really a descriptor */
+#define SQIN_INL               0x02000000
+
+/* Sequence pointer is a scatter-gather table */
+#define SQIN_SGF               0x01000000
+
+/* Appends to a previous pointer */
+#define SQIN_PRE               0x00800000
+
+/* Use extended length following pointer */
+#define SQIN_EXT               0x00400000
+
+/* Restore sequence with pointer/length */
+#define SQIN_RTO               0x00200000
+
+/*
+ * SEQ_OUT_PTR Command Constructs
+ */
+
+/* Sequence pointer is a scatter-gather table */
+#define SQOUT_SGF              0x01000000
+
+/* Appends to a previous pointer */
+#define SQOUT_PRE              0x00800000
+
+/* Use extended length following pointer */
+#define SQOUT_EXT              0x00400000
+
+/*
+ * SIGNATURE Command Constructs
+ */
+
+/* TYPE field is all that's relevant */
+#define SIGN_TYPE_SHIFT         16
+
+#define SIGN_TYPE_FINAL         (0x00 << SIGN_TYPE_SHIFT)
+#define SIGN_TYPE_FINAL_RESTORE (0x01 << SIGN_TYPE_SHIFT)
+#define SIGN_TYPE_FINAL_NONZERO (0x02 << SIGN_TYPE_SHIFT)
+#define SIGN_TYPE_IMM_2         (0x0a << SIGN_TYPE_SHIFT)
+#define SIGN_TYPE_IMM_3         (0x0b << SIGN_TYPE_SHIFT)
+#define SIGN_TYPE_IMM_4         (0x0c << SIGN_TYPE_SHIFT)
+
+/*
+ * MOVE Command Constructs
+ */
+
+#define MOVE_AUX_SHIFT          25
+
+#define MOVE_WAITCOMP           0x01000000
+
+#define MOVE_SRC_SHIFT          20
+#define MOVE_SRC_CLASS1CTX      (0x00 << MOVE_SRC_SHIFT)
+#define MOVE_SRC_CLASS2CTX      (0x01 << MOVE_SRC_SHIFT)
+#define MOVE_SRC_OUTFIFO        (0x02 << MOVE_SRC_SHIFT)
+#define MOVE_SRC_DESCBUF        (0x03 << MOVE_SRC_SHIFT)
+#define MOVE_SRC_MATH0          (0x04 << MOVE_SRC_SHIFT)
+#define MOVE_SRC_MATH1          (0x05 << MOVE_SRC_SHIFT)
+#define MOVE_SRC_MATH2          (0x06 << MOVE_SRC_SHIFT)
+#define MOVE_SRC_MATH3          (0x07 << MOVE_SRC_SHIFT)
+#define MOVE_SRC_INFIFO         (0x08 << MOVE_SRC_SHIFT)
+
+#define MOVE_DEST_SHIFT         16
+#define MOVE_DEST_CLASS1CTX     (0x00 << MOVE_DEST_SHIFT)
+#define MOVE_DEST_CLASS2CTX     (0x01 << MOVE_DEST_SHIFT)
+#define MOVE_DEST_OUTFIFO       (0x02 << MOVE_DEST_SHIFT)
+#define MOVE_DEST_DESCBUF       (0x03 << MOVE_DEST_SHIFT)
+#define MOVE_DEST_MATH0         (0x04 << MOVE_DEST_SHIFT)
+#define MOVE_DEST_MATH1         (0x05 << MOVE_DEST_SHIFT)
+#define MOVE_DEST_MATH2         (0x06 << MOVE_DEST_SHIFT)
+#define MOVE_DEST_MATH3         (0x07 << MOVE_DEST_SHIFT)
+#define MOVE_DEST_CLASS1INFIFO  (0x08 << MOVE_DEST_SHIFT)
+#define MOVE_DEST_CLASS2INFIFO  (0x09 << MOVE_DEST_SHIFT)
+#define MOVE_DEST_PK_A          (0x0c << MOVE_DEST_SHIFT)
+#define MOVE_DEST_CLASS1KEY     (0x0d << MOVE_DEST_SHIFT)
+#define MOVE_DEST_CLASS2KEY     (0x0e << MOVE_DEST_SHIFT)
+
+#define MOVE_OFFSET_SHIFT       8
+#define MOVE_OFFSET_MASK        0xff
+
+#define MOVE_LEN_MASK           0xff
+
+/*
+ * MATH Command Constructs
+ */
+
+#define MATH_IFB                0x04000000
+#define MATH_NFU                0x02000000
+#define MATH_STL                0x01000000
+
+/* Function selectors */
+#define MATH_FUN_SHIFT          20
+#define MATH_FUN_ADD            (0x00 << MATH_FUN_SHIFT)
+#define MATH_FUN_ADDC           (0x01 << MATH_FUN_SHIFT)
+#define MATH_FUN_SUB            (0x02 << MATH_FUN_SHIFT)
+#define MATH_FUN_SUBB           (0x03 << MATH_FUN_SHIFT)
+#define MATH_FUN_OR             (0x04 << MATH_FUN_SHIFT)
+#define MATH_FUN_AND            (0x05 << MATH_FUN_SHIFT)
+#define MATH_FUN_XOR            (0x06 << MATH_FUN_SHIFT)
+#define MATH_FUN_LSHIFT         (0x07 << MATH_FUN_SHIFT)
+#define MATH_FUN_RSHIFT         (0x08 << MATH_FUN_SHIFT)
+#define MATH_FUN_SHLD           (0x09 << MATH_FUN_SHIFT)
+
+/* Source 0 selectors */
+#define MATH_SRC0_SHIFT         16
+#define MATH_SRC0_REG0          (0x00 << MATH_SRC0_SHIFT)
+#define MATH_SRC0_REG1          (0x01 << MATH_SRC0_SHIFT)
+#define MATH_SRC0_REG2          (0x02 << MATH_SRC0_SHIFT)
+#define MATH_SRC0_REG3          (0x03 << MATH_SRC0_SHIFT)
+#define MATH_SRC0_IMM           (0x04 << MATH_SRC0_SHIFT)
+#define MATH_SRC0_SEQINLEN      (0x08 << MATH_SRC0_SHIFT)
+#define MATH_SRC0_SEQOUTLEN     (0x09 << MATH_SRC0_SHIFT)
+#define MATH_SRC0_VARSEQINLEN   (0x0a << MATH_SRC0_SHIFT)
+#define MATH_SRC0_VARSEQOUTLEN  (0x0b << MATH_SRC0_SHIFT)
+#define MATH_SRC0_ZERO          (0x0c << MATH_SRC0_SHIFT)
+
+/* Source 1 selectors */
+#define MATH_SRC1_SHIFT         12
+#define MATH_SRC1_REG0          (0x00 << MATH_SRC1_SHIFT)
+#define MATH_SRC1_REG1          (0x01 << MATH_SRC1_SHIFT)
+#define MATH_SRC1_REG2          (0x02 << MATH_SRC1_SHIFT)
+#define MATH_SRC1_REG3          (0x03 << MATH_SRC1_SHIFT)
+#define MATH_SRC1_IMM           (0x04 << MATH_SRC1_SHIFT)
+#define MATH_SRC1_INFIFO        (0x0a << MATH_SRC1_SHIFT)
+#define MATH_SRC1_OUTFIFO       (0x0b << MATH_SRC1_SHIFT)
+#define MATH_SRC1_ONE           (0x0c << MATH_SRC1_SHIFT)
+
+/* Destination selectors */
+#define MATH_DEST_SHIFT         8
+#define MATH_DEST_REG0          (0x00 << MATH_DEST_SHIFT)
+#define MATH_DEST_REG1          (0x01 << MATH_DEST_SHIFT)
+#define MATH_DEST_REG2          (0x02 << MATH_DEST_SHIFT)
+#define MATH_DEST_REG3          (0x03 << MATH_DEST_SHIFT)
+#define MATH_DEST_SEQINLEN      (0x08 << MATH_DEST_SHIFT)
+#define MATH_DEST_SEQOUTLEN     (0x09 << MATH_DEST_SHIFT)
+#define MATH_DEST_VARSEQINLEN   (0x0a << MATH_DEST_SHIFT)
+#define MATH_DEST_VARSEQOUTLEN  (0x0b << MATH_DEST_SHIFT)
+#define MATH_DEST_NONE          (0x0f << MATH_DEST_SHIFT)
+
+/* Length selectors */
+#define MATH_LEN_1BYTE          0x01
+#define MATH_LEN_2BYTE          0x02
+#define MATH_LEN_4BYTE          0x04
+#define MATH_LEN_8BYTE          0x08
+
+/*
+ * JUMP Command Constructs
+ */
+
+#define JUMP_CLASS_SHIFT        25 /* General class selectors OK */
+
+#define JUMP_JSL                0x01000000
+
+#define JUMP_TYPE_SHIFT         22
+#define JUMP_TYPE_LOCAL         (0x00 << JUMP_TYPE_SHIFT)
+#define JUMP_TYPE_NONLOCAL      (0x01 << JUMP_TYPE_SHIFT)
+#define JUMP_TYPE_HALT          (0x02 << JUMP_TYPE_SHIFT)
+#define JUMP_TYPE_HALT_USER     (0x03 << JUMP_TYPE_SHIFT)
+
+#define JUMP_TEST_SHIFT         16
+#define JUMP_TEST_ALL           (0x00 << JUMP_TEST_SHIFT)
+#define JUMP_TEST_INVALL        (0x01 << JUMP_TEST_SHIFT)
+#define JUMP_TEST_ANY           (0x02 << JUMP_TEST_SHIFT)
+#define JUMP_TEST_INVANY        (0x03 << JUMP_TEST_SHIFT)
+
+/* If JUMP_JSL clear, these condition codes apply */
+#define JUMP_COND_PK_0          0x00008000
+#define JUMP_COND_PK_GCD_1      0x00004000
+#define JUMP_COND_PK_PRIME      0x00002000
+#define JUMP_COND_MATH_N        0x00000800
+#define JUMP_COND_MATH_Z        0x00000400
+#define JUMP_COND_MATH_C        0x00000200
+#define JUMP_COND_MATH_NV       0x00000100
+
+/* If JUMP_JSL set, these condition codes apply */
+#define JUMP_COND_JQP           0x00008000
+#define JUMP_COND_SHRD          0x00004000
+#define JUMP_COND_SELF          0x00002000
+#define JUMP_COND_CALM          0x00001000
+#define JUMP_COND_NIP           0x00000800
+#define JUMP_COND_NIFP          0x00000400
+#define JUMP_COND_NOP           0x00000200
+#define JUMP_COND_NCP           0x00000100
+
+/*
+ * PDB internal definitions
+ */
+
+/* IPSec ESP CBC Encap/Decap Options */
+#define PDBOPTS_ESPCBC_ARSNONE  0x00   /* no antireplay window              */
+#define PDBOPTS_ESPCBC_ARS32    0x40   /* 32-entry antireplay window        */
+#define PDBOPTS_ESPCBC_ARS64    0xc0   /* 64-entry antireplay window        */
+#define PDBOPTS_ESPCBC_IVSRC    0x20   /* IV comes from internal random gen */
+#define PDBOPTS_ESPCBC_ESN      0x10   /* extended sequence included        */
+#define PDBOPTS_ESPCBC_OUTFMT   0x08   /* output only decapsulation (decap) */
+#define PDBOPTS_ESPCBC_IPHDRSRC 0x08   /* IP header comes from PDB (encap)  */
+#define PDBOPTS_ESPCBC_INCIPHDR 0x04   /* Prepend IP header to output frame */
+#define PDBOPTS_ESPCBC_IPVSN    0x02   /* process IPv6 header               */
+#define PDBOPTS_ESPCBC_TUNNEL   0x01   /* tunnel mode next-header byte      */
+
+#endif /* DESC_H */
diff --git a/drivers/crypto/caam/intern.h b/drivers/crypto/caam/intern.h
new file mode 100644
index 0000000..e60753a
--- /dev/null
+++ b/drivers/crypto/caam/intern.h
@@ -0,0 +1,109 @@
+/*
+ * CAAM/SEC 4.x driver backend
+ * Private/internal definitions between modules
+ *
+ * Copyright (c) 2008, 2009, Freescale Semiconductor, Inc.
+ * All Rights Reserved
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef INTERN_H
+#define INTERN_H
+
+#define JOBQ_UNASSIGNED 0
+#define JOBQ_ASSIGNED 1
+
+/* Currently comes from Kconfig param as a ^2 (driver-required) */
+#define JOBQ_DEPTH (1 << CONFIG_CRYPTO_DEV_FSL_CAAM_RINGSIZE)
+
+/*
+ * Storage for tracking each in-process entry moving across a queue
+ * Each entry on an output ring needs one of these
+ */
+struct caam_jqentry_info {
+	void (*callbk)(struct device *dev, u32 *desc, u32 status, void *arg);
+	void *cbkarg;	/* Argument per ring entry */
+	u32 *desc_addr_virt;	/* Stored virt addr for postprocessing */
+	u32 desc_size;	/* Stored size for postprocessing, header derived */
+};
+
+/* Private sub-storage for a single JobQ */
+struct caam_drv_private_jq {
+	struct device *parentdev;	/* points back to controller dev */
+	int qidx;
+	struct caam_job_queue *qregs;	/* points to JobQ's register space */
+	struct tasklet_struct irqtask;
+	int irq;			/* One per queue */
+	int assign;			/* busy/free */
+
+	/* Job ring info */
+	int ringsize;	/* Size of rings (assume input = output) */
+	int inp_ring_write_index;	/* Input index "tail" */
+	int out_ring_read_index;	/* Output index "tail" */
+	int *inpring;	/* Base of input ring, alloc DMA-safe */
+	struct jq_outentry *outring;	/* Base of output ring, DMA-safe */
+	struct caam_jqentry_info *entinfo; 	/* Alloc'ed 1 per ring entry */
+	spinlock_t inplock;	/* Input ring index lock */
+	spinlock_t outlock;	/* Output ring index lock */
+
+};
+
+/*
+ * Driver-private storage for a single CAAM block instance
+ */
+struct caam_drv_private {
+
+	struct device *dev;
+	struct device **jqdev; /* Alloc'ed array per sub-device */
+	spinlock_t jq_alloc_lock;
+#ifdef CONFIG_OF
+	struct of_device *ofdev;
+#else
+	/* Non-OF-specific defs */
+#endif
+
+	/* Physical-presence section */
+	struct caam_ctrl *ctrl; /* controller region */
+	struct caam_deco *deco[5]; /* DECO/CCB views */
+	struct caam_assurance *ac;
+	struct caam_queue_if *qi; /* QI control region */
+
+	/*
+	 * Detected geometry block. Filled in from device tree if powerpc,
+	 * or from register-based version detection code
+	 */
+	u8 total_jobqs;		/* Total Job Queues in device */
+	u8 qi_present;		/* Nonzero if QI present in device */
+	u8 qi_spids;		/* Number subportal IDs in use */
+	int secvio_irq;		/* Security violation interrupt number */
+
+	/* which jq allocated to scatterlist crypto */
+	struct device *algapi_jq;
+	/* list of registered crypto algorithms (mk generic context handle?) */
+	struct list_head alg_list;
+};
+
+void caam_jq_algapi_init(struct device *dev);
+void caam_jq_algapi_remove(struct device *dev);
+#endif /* INTERN_H */
diff --git a/drivers/crypto/caam/jq.c b/drivers/crypto/caam/jq.c
new file mode 100644
index 0000000..8edfcc7
--- /dev/null
+++ b/drivers/crypto/caam/jq.c
@@ -0,0 +1,452 @@
+/*
+ * CAAM/SEC 4.x transport/backend driver (prototype)
+ * JobQ backend functionality
+ *
+ * Copyright (c) 2008, 2009, Freescale Semiconductor, Inc.
+ * All Rights Reserved
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#include <linux/interrupt.h>
+#include <linux/dma-mapping.h>
+#include <linux/of_platform.h>
+
+#include "regs.h"
+#include "jq.h"
+#include "desc.h"
+#include "intern.h"
+
+/* Main per-queue interrupt handler */
+irqreturn_t caam_jq_interrupt(int irq, void *st_dev)
+{
+	struct device *dev = st_dev;
+	struct caam_drv_private_jq *jqp = dev_get_drvdata(dev);
+	u32 irqstate;
+
+	/*
+	 * Check the output ring for ready responses, kick
+	 * tasklet if jobs done.
+	 */
+	irqstate = rd_reg32(&jqp->qregs->jqintstatus);
+	if (!irqstate)
+		return IRQ_NONE;
+
+	/*
+	 * If JobQ error, we got more development work to do
+	 * Flag a bug now, but we really need to shut down and
+	 * restart the queue (and fix code).
+	 */
+	BUG_ON(irqstate & JQINT_JQ_ERROR);
+
+	/* Have valid interrupt at this point, just ACK and trigger */
+	wr_reg32(&jqp->qregs->jqintstatus, irqstate);
+	tasklet_schedule(&jqp->irqtask);
+
+	return IRQ_HANDLED;
+}
+
+/* Deferred service handler, run as interrupt-fired tasklet */
+void caam_jq_dequeue(unsigned long devarg)
+{
+	int idx;
+	struct device *dev = (struct device *)devarg;
+	struct caam_drv_private_jq *jqp = dev_get_drvdata(dev);
+	void (*usercall)(struct device *dev, u32 *desc, u32 status, void *arg);
+	u32 *userdesc, userstatus;
+	void *userarg;
+
+	/* Processing single output entries at this time */
+	while (rd_reg32(&jqp->qregs->outring_used)) {
+		spin_lock(&jqp->outlock);
+		idx = jqp->out_ring_read_index;
+		BUG_ON((idx > JOBQ_DEPTH) || (idx < 0));
+
+		/* Unmap just-run descriptor so we can post-process */
+		dma_unmap_single(dev, (u32)jqp->outring[idx].desc,
+				 jqp->entinfo[idx].desc_size,
+				 DMA_BIDIRECTIONAL);
+
+		/* Stash callback params for use outside of lock */
+		usercall = jqp->entinfo[idx].callbk;
+		userarg = jqp->entinfo[idx].cbkarg;
+		userdesc = jqp->entinfo[idx].desc_addr_virt;
+		userstatus = jqp->outring[idx].jqstatus;
+
+		/* Remove entry from ring */
+		jqp->out_ring_read_index++;
+		jqp->out_ring_read_index &= (JOBQ_DEPTH - 1);
+		wr_reg32(&jqp->qregs->outring_rmvd, 1);
+		spin_unlock(&jqp->outlock);
+
+		/* Finally, execute user's callback */
+		usercall(dev, userdesc, userstatus, userarg);
+	}
+}
+
+/**
+ * caam_jq_register() - Alloc a queue for someone to use as needed. Returns
+ * an ordinal of the queue allocated, else returns -ENODEV if no queues
+ * are available.
+ * @ctrldev: points to the controller level dev (parent) that
+ *           owns queues available for use.
+ * @dev:     points to where a pointer to the newly allocated queue's
+ *           dev can be written to if successful.
+ *
+ * NOTE: this scheme needs re-evaluated in the 1.2+ timeframe
+ **/
+int caam_jq_register(struct device *ctrldev, struct device **qdev)
+{
+	struct caam_drv_private *ctrlpriv;
+	struct caam_drv_private_jq *jqpriv;
+	int q;
+
+	jqpriv = NULL;
+	ctrlpriv = dev_get_drvdata(ctrldev);
+
+
+	/* Lock, if free queue - assign, unlock */
+	spin_lock(&ctrlpriv->jq_alloc_lock);
+	for (q = 0; q < ctrlpriv->total_jobqs; q++) {
+		jqpriv = dev_get_drvdata(ctrlpriv->jqdev[q]);
+		if (jqpriv->assign == JOBQ_UNASSIGNED) {
+			jqpriv->assign = JOBQ_ASSIGNED;
+			*qdev = ctrlpriv->jqdev[q];
+			spin_unlock(&ctrlpriv->jq_alloc_lock);
+			return q;
+		}
+	}
+
+	/* If assigned, write dev where caller needs it */
+	spin_unlock(&ctrlpriv->jq_alloc_lock);
+	*qdev = NULL;
+	return -ENODEV;
+}
+EXPORT_SYMBOL(caam_jq_register);
+
+/**
+ * caam_jq_deregister() - Deregister an API and release the queue.
+ * Returns 0 if OK, -EBUSY if queue still contains pending entries
+ * or unprocessed results at the time of the call
+ * @dev     - points to the dev that identifies the queue to
+ *            be released.
+ **/
+int caam_jq_deregister(struct device *qdev)
+{
+	struct caam_drv_private_jq *jqpriv = dev_get_drvdata(qdev);
+	struct caam_drv_private *ctrlpriv;
+
+	/* Get the owning controller's private space */
+	ctrlpriv = dev_get_drvdata(jqpriv->parentdev);
+
+	/*
+	 * Make sure queue empty before release
+	 */
+	if ((jqpriv->qregs->outring_used) ||
+	    (jqpriv->qregs->inpring_avail != JOBQ_DEPTH))
+		return -EBUSY;
+
+	/* Release queue */
+	spin_lock(&ctrlpriv->jq_alloc_lock);
+	jqpriv->assign = JOBQ_UNASSIGNED;
+	spin_unlock(&ctrlpriv->jq_alloc_lock);
+
+	return 0;
+}
+EXPORT_SYMBOL(caam_jq_deregister);
+
+/**
+ * caam_jq_enqueue() - Enqueue a job descriptor head. Returns 0 if OK,
+ * -EBUSY if the queue is full, -EIO if it cannot map the caller's
+ * descriptor.
+ * @dev:  device of the job queue to be used. This device should have
+ *        been assigned prior by caam_jq_register().
+ * @desc: points to a job descriptor that execute our request. All
+ *        descriptors (and all referenced data) must be in a DMAable
+ *        region, and all data references must be physical addresses
+ *        accessible to CAAM (i.e. within a PAMU window granted
+ *        to it).
+ * @cbk:  pointer to a callback function to be invoked upon completion
+ *        of this request. This has the form:
+ *        callback(struct device *dev, u32 *desc, u32 stat, void *arg)
+ *        where:
+ *        @dev:    contains the job queue device that processed this
+ *                 response.
+ *        @desc:   descriptor that initiated the request, same as
+ *                 "desc" being argued to caam_jq_enqueue().
+ *        @status: untranslated status received from CAAM. See the
+ *                 reference manual for a detailed description of
+ *                 error meaning, or see the JQSTA definitions in the
+ *                 register header file
+ *        @areq:   optional pointer to an argument passed with the
+ *                 original request
+ * @areq: optional pointer to a user argument for use at callback
+ *        time.
+ **/
+ int caam_jq_enqueue(struct device *dev, u32 *desc,
+		    void (*cbk)(struct device *dev, u32 *desc,
+				u32 status, void *areq),
+		    void *areq)
+{
+	struct caam_drv_private_jq *jqp;
+	int idx;
+
+	jqp = dev_get_drvdata(dev);
+
+	/*
+	 * Write the entry to the ring and update the index
+	 * Note that the index is hardware-calculated
+	 */
+
+	if (!rd_reg32(&jqp->qregs->inpring_avail))
+		return -EBUSY; /* No room */
+
+	/*
+	 * Write entry to the tail, and "start" it
+	 * TODO: should be able to walk a list, but maps only
+	 * one jobdesc at a time for now
+	 */
+	spin_lock(&jqp->inplock);
+	BUG_ON((jqp->inp_ring_write_index > JOBQ_DEPTH) ||
+	       (jqp->inp_ring_write_index < 0));
+	idx = jqp->inp_ring_write_index;
+
+	/* Store off info that the tasklet will need */
+	jqp->entinfo[idx].desc_addr_virt = desc;
+	jqp->entinfo[idx].desc_size = (*desc & HDR_JD_LENGTH_MASK) *
+				       sizeof(u32);
+	jqp->entinfo[idx].callbk = (void *)cbk;
+	jqp->entinfo[idx].cbkarg = areq;
+
+	/* Map and start descriptor */
+	jqp->inpring[idx] = dma_map_single(dev, desc,
+					   (*desc & HDR_JD_LENGTH_MASK) *
+					    sizeof(u32),
+					   DMA_BIDIRECTIONAL);
+	if (dma_mapping_error(dev, jqp->inpring[idx])) {
+		dev_err(dev,
+			"caam_jq_enqueue(): can't map jobdesc\n");
+		spin_unlock(&jqp->inplock);
+		return -EIO;
+	}
+	wr_reg32(&jqp->qregs->inpring_jobadd, 1);
+
+	/* Bump/wrap index and unlock */
+	jqp->inp_ring_write_index++;
+	jqp->inp_ring_write_index &= (JOBQ_DEPTH - 1);
+	spin_unlock(&jqp->inplock);
+
+	return 0;
+}
+EXPORT_SYMBOL(caam_jq_enqueue);
+
+/*
+ * Init JobQ independent of platform property detection
+ */
+int caam_jq_init(struct device *dev)
+{
+	struct caam_drv_private_jq *jqp;
+	u32 inpbusaddr, outbusaddr;
+	int error;
+
+	jqp = dev_get_drvdata(dev);
+
+	jqp->inpring = kzalloc(sizeof(u32 *) * JOBQ_DEPTH,
+			       GFP_KERNEL | GFP_DMA);
+	jqp->outring = kzalloc(sizeof(struct jq_outentry) *
+			       JOBQ_DEPTH, GFP_KERNEL | GFP_DMA);
+
+	jqp->entinfo = kzalloc(sizeof(struct caam_jqentry_info) * JOBQ_DEPTH,
+			       GFP_KERNEL);
+
+	if ((jqp->inpring == NULL) || (jqp->outring == NULL) ||
+	    (jqp->entinfo == NULL)) {
+		dev_err(dev, "can't allocate job rings for %d\n",
+			jqp->qidx);
+		return -ENOMEM;
+	}
+
+	/* Setup rings */
+	inpbusaddr = dma_map_single(dev, jqp->inpring,
+				    sizeof(u32 *) * JOBQ_DEPTH,
+				    DMA_BIDIRECTIONAL);
+	if (dma_mapping_error(dev, inpbusaddr)) {
+		dev_err(dev, "caam_jq_init(): can't map input ring\n");
+		kfree(jqp->inpring);
+		kfree(jqp->outring);
+		kfree(jqp->entinfo);
+		return -EIO;
+	}
+
+	outbusaddr = dma_map_single(dev, jqp->outring,
+				    sizeof(struct jq_outentry) * JOBQ_DEPTH,
+				    DMA_BIDIRECTIONAL);
+	if (dma_mapping_error(dev, outbusaddr)) {
+		dev_err(dev, "caam_jq_init(): can't map output ring\n");
+			dma_unmap_single(dev, inpbusaddr,
+					 sizeof(u32 *) * JOBQ_DEPTH,
+					 DMA_BIDIRECTIONAL);
+		kfree(jqp->inpring);
+		kfree(jqp->outring);
+		kfree(jqp->entinfo);
+		return -EIO;
+	}
+
+	jqp->inp_ring_write_index = 0;
+	jqp->out_ring_read_index = 0;
+
+	wr_reg64(&jqp->qregs->inpring_base, inpbusaddr);
+	wr_reg64(&jqp->qregs->outring_base, outbusaddr);
+	wr_reg32(&jqp->qregs->inpring_size, JOBQ_DEPTH);
+	wr_reg32(&jqp->qregs->outring_size, JOBQ_DEPTH);
+
+	jqp->ringsize = JOBQ_DEPTH;
+
+	spin_lock_init(&jqp->inplock);
+	spin_lock_init(&jqp->outlock);
+
+	/* Connect job queue interrupt handler. No coalescing yet */
+	tasklet_init(&jqp->irqtask, caam_jq_dequeue, (u32)dev);
+	error = request_irq(jqp->irq, caam_jq_interrupt, 0,
+			    "caam-jobq", dev);
+	if (error) {
+		dev_err(dev, "can't connect JobQ %d interrupt (%d)\n",
+			jqp->qidx, jqp->irq);
+			irq_dispose_mapping(jqp->irq);
+			jqp->irq = 0;
+			dma_unmap_single(dev, inpbusaddr,
+					 sizeof(u32 *) * JOBQ_DEPTH,
+					 DMA_BIDIRECTIONAL);
+			dma_unmap_single(dev, outbusaddr,
+					 sizeof(u32 *) * JOBQ_DEPTH,
+					 DMA_BIDIRECTIONAL);
+			kfree(jqp->inpring);
+			kfree(jqp->outring);
+			kfree(jqp->entinfo);
+			return -EINVAL;
+	}
+
+	jqp->assign = JOBQ_UNASSIGNED;
+	return 0;
+}
+
+/*
+ * Shutdown JobQ independent of platform property code
+ */
+int caam_jq_shutdown(struct device *dev)
+{
+	struct caam_drv_private_jq *jqp;
+	u32 used;
+
+	jqp = dev_get_drvdata(dev);
+
+	/* Stop ring. This just does a blunt flush of output entries */
+	wr_reg32(&jqp->qregs->qconfig_lo, JQCFG_IMSK);
+	wr_reg32(&jqp->qregs->jqcommand, JQCR_RESET); /* initiate flush */
+	used = rd_reg32(&jqp->qregs->outring_used);
+	wr_reg32(&jqp->qregs->outring_rmvd, used);
+	wr_reg32(&jqp->qregs->jqcommand, JQCR_RESET); /* complete flush */
+
+	/* Release interrupt */
+	free_irq(jqp->irq, dev);
+
+	/* Free rings */
+	dma_unmap_single(dev, (u32)jqp->outring,
+			 sizeof(struct jq_outentry) * JOBQ_DEPTH,
+			 DMA_BIDIRECTIONAL);
+	dma_unmap_single(dev, (u32)jqp->inpring, sizeof(u32 *) * JOBQ_DEPTH,
+			 DMA_BIDIRECTIONAL);
+	kfree(jqp->outring);
+	kfree(jqp->inpring);
+	kfree(jqp->entinfo);
+
+	return 0;
+}
+
+/*
+ * Probe routine for each detected JobQ subsystem. It assumes that
+ * property detection was picked up externally.
+ */
+int caam_jq_probe(struct of_device *ofdev,
+		  struct device_node *np,
+		  int q)
+{
+	struct device *ctrldev, *jqdev;
+	struct of_device *jq_ofdev;
+	struct caam_drv_private *ctrlpriv;
+	struct caam_drv_private_jq *jqpriv;
+	u32 *jqoffset;
+	int error;
+
+	ctrldev = &ofdev->dev;
+	ctrlpriv = dev_get_drvdata(ctrldev);
+
+	jqpriv = kmalloc(sizeof(struct caam_drv_private_jq),
+			 GFP_KERNEL);
+	if (jqpriv == NULL) {
+		dev_err(ctrldev, "can't alloc private mem for job queue %d\n",
+			q);
+		return -ENOMEM;
+	}
+	jqpriv->parentdev = ctrldev; /* point back to parent */
+	jqpriv->qidx = q; /* save queue identity relative to detection */
+
+	/*
+	 * Derive a pointer to the detected JobQs regs
+	 * Driver has already iomapped the entire space, we just
+	 * need to add in the offset to this JobQ. Don't know if I
+	 * like this long-term, but it'll run
+	 */
+	jqoffset = (u32 *)of_get_property(np, "reg", NULL);
+	jqpriv->qregs = (struct caam_job_queue *)((u32)ctrlpriv->ctrl +
+						  *jqoffset);
+
+	/* Build a local dev for each detected queue */
+	jq_ofdev = of_platform_device_create(np, NULL, ctrldev);
+	if (jq_ofdev == NULL) {
+		kfree(jqpriv);
+		return -EINVAL;
+	}
+	jqdev = &jq_ofdev->dev;
+	dev_set_drvdata(jqdev, jqpriv);
+	ctrlpriv->jqdev[q] = jqdev;
+
+	/* FIXME: temporary detective code */
+	dev_info(jqdev,
+		 "caam_jq_probe: dev[%d] %08x, priv %08x, reg %08x\n",
+		 q, (u32)jqdev, (u32)jqpriv, (u32)jqpriv->qregs);
+
+	/* Identify the interrupt */
+	jqpriv->irq = of_irq_to_resource(np, 0, NULL);
+
+	/* Now do the platform independent part */
+	error = caam_jq_init(jqdev); /* now turn on hardware */
+	if (error) {
+		kfree(jqpriv);
+		return error;
+	}
+
+	return error;
+}
+
diff --git a/drivers/crypto/caam/jq.h b/drivers/crypto/caam/jq.h
new file mode 100644
index 0000000..7a30313
--- /dev/null
+++ b/drivers/crypto/caam/jq.h
@@ -0,0 +1,42 @@
+/*
+ * CAAM public-level include definitions for the JobQ backend
+ *
+ * Copyright (c) 2008, 2009, Freescale Semiconductor, Inc.
+ * All Rights Reserved
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef JQ_H
+#define JQ_H
+
+/* Prototypes for backend-level services exposed to APIs */
+int caam_jq_register(struct device *ctrldev, struct device **qdev);
+int caam_jq_deregister(struct device *qdev);
+int caam_jq_enqueue(struct device *dev, u32 *desc,
+		    void (*cbk)(struct device *dev, u32 *desc, u32 status,
+				void *areq),
+		    void *areq);
+
+#endif /* JQ_H */
diff --git a/drivers/crypto/caam/jq_test/Makefile b/drivers/crypto/caam/jq_test/Makefile
new file mode 100644
index 0000000..c89c221
--- /dev/null
+++ b/drivers/crypto/caam/jq_test/Makefile
@@ -0,0 +1,4 @@
+
+obj-$(CONFIG_CRYPTO_DEV_FSL_CAAM_JQ_TEST) += caam_jq_test.o
+
+caam_jq_test-objs := caam_jqtest.o jq_ipsec.o
diff --git a/drivers/crypto/caam/jq_test/caam_jqtest.c b/drivers/crypto/caam/jq_test/caam_jqtest.c
new file mode 100644
index 0000000..60b672a
--- /dev/null
+++ b/drivers/crypto/caam/jq_test/caam_jqtest.c
@@ -0,0 +1,106 @@
+/*
+ * caam_jqtest.c - Top-level code for a JobQ unit test
+ *
+ * Copyright (c) 2008, 2009, Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+
+#include "caam_jqtest.h"
+
+wait_queue_head_t jqtest_wq;
+wait_queue_t jqtest_wqentry;
+
+static int __init caam_jqtest(void)
+{
+	int stat, i, q, owned_queues, qid[4];
+	struct device *qdev[4], *ctrldev;
+	struct device_node *ctrlnode;
+	struct of_device *ofdev;
+
+
+	/* Find a CAAM instance via device tree */
+	ctrlnode = of_find_compatible_node(NULL, NULL, "fsl,sec4.0");
+	if (ctrlnode == NULL) {
+		printk(KERN_INFO "caam_jqtest: no compatible node found\n");
+		return -1;
+	}
+	ofdev = of_find_device_by_node(ctrlnode);
+	if (ofdev == NULL) {
+		printk(KERN_INFO "caam_jqtest: no device found\n");
+		return -1;
+	}
+	ctrldev = &ofdev->dev;
+
+	/* Get all the queues available */
+	owned_queues = 0;
+	for (q = 0; q < 4; q++) {
+		qid[q] = caam_jq_register(ctrldev, &qdev[q]);
+		if (qid[q] >= 0)
+			owned_queues++;
+	}
+
+	if (!owned_queues) {
+		printk(KERN_INFO "caam_jqtest: no queues available\n");
+		return -1;
+	}
+
+	/* Have a device queue for us to use. Set up waitqueue */
+	init_waitqueue_head(&jqtest_wq);
+	init_waitqueue_entry(&jqtest_wqentry, current);
+	add_wait_queue(&jqtest_wq, &jqtest_wqentry);
+
+	/* Now run cases */
+	printk(KERN_INFO "caam_jqtest: running cases on %d available queues\n",
+	       owned_queues);
+	for (q = 0; q < owned_queues; q++) {
+		for (i = 0; i < 300; i++) {
+			stat = jq_ipsec_esp_no_term(qdev[q], NO_SHOW_DESC);
+			if (stat)
+				printk(KERN_INFO
+				       "jq_ipsec_esp_noterm: fail queue %d\n",
+				       qid[q]);
+		}
+		printk(KERN_INFO "caam_jqtest: %d cycles on queue %d\n", i, q);
+	}
+
+	/* Deregister, release queues */
+	for (q = 0; q < owned_queues; q++)
+		caam_jq_deregister(qdev[q]);
+
+	return 0;
+}
+
+static void __exit caam_jqtest_remove(void)
+{
+	return;
+}
+
+module_init(caam_jqtest);
+module_exit(caam_jqtest_remove);
+
+MODULE_LICENSE("BSD");
+MODULE_DESCRIPTION("FSL CAAM JobQ Test Module");
+MODULE_AUTHOR("Freescale Semiconductor - NMG/STC");
diff --git a/drivers/crypto/caam/jq_test/caam_jqtest.h b/drivers/crypto/caam/jq_test/caam_jqtest.h
new file mode 100644
index 0000000..ba56f40
--- /dev/null
+++ b/drivers/crypto/caam/jq_test/caam_jqtest.h
@@ -0,0 +1,43 @@
+/*
+ * caam_jqtest.h - central header for the JobQ unit test module
+ *
+ * Copyright (c) 2008, 2009, Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef CAAM_JQTEST_H
+#define CAAM_JQTEST_H
+
+#include "../compat.h"
+#include "../desc.h"
+#include "../dcl/dcl.h"
+#include "../jq.h"
+
+#define SHOW_DESC 1
+#define NO_SHOW_DESC 0
+
+int jq_ipsec_esp_no_term(struct device *dev, int showdesc);
+
+#endif /* CAAM_JQTEST_H */
diff --git a/drivers/crypto/caam/jq_test/jq_ipsec.c b/drivers/crypto/caam/jq_test/jq_ipsec.c
new file mode 100644
index 0000000..f478f22
--- /dev/null
+++ b/drivers/crypto/caam/jq_test/jq_ipsec.c
@@ -0,0 +1,162 @@
+/*
+ * jq_ipsec.c - JobQ unit test for termination-less IPSec examples
+ *
+ * Copyright (c) 2008, 2009, Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "caam_jqtest.h"
+
+
+
+static u8 class_2_key[] = {
+	0x00, 0xe0, 0xf0, 0xa0,
+	0x00, 0xd0, 0xf0, 0xa0,
+	0x0a, 0xd0, 0xf0, 0xa0,
+	0x0b, 0xd0, 0xf0, 0xa0,
+	0x0f, 0xd0, 0xf0, 0xa0 };
+
+static u8 class_1_key[] = {
+	0x00, 0x0e, 0x0f, 0x00,
+	0x0c, 0x0f, 0x0a, 0x00,
+	0x0a, 0x0f, 0x0a, 0x00,
+	0x0b, 0x0f, 0x0a, 0x00 };
+
+
+extern wait_queue_head_t jqtest_wq;
+
+void jq_ipsec_done(struct device *dev, u32 *head, u32 status, void *auxarg)
+{
+	/* Bump volatile completion test value and wake calling thread */
+	(*(int *)auxarg)++;
+	wake_up_interruptible(&jqtest_wq);
+}
+
+
+int jq_ipsec_esp_no_term(struct device *dev, int show)
+{
+	int stat, exit, rtnval = 0;
+	u32 *sdesc, *jdesc, *sdmap, *jdmap;
+	u8 *inbuf, *outbuf, *inmap, *outmap;
+	u16 sdsz, jdsz, inbufsz, outbufsz;
+	int jqarg;
+	struct pdbcont pdb;
+	struct cipherparams cipher;
+	struct authparams auth;
+
+	jqarg = 0;
+
+	/* Allocate more than necessary for both descs */
+	sdsz = 64 * sizeof(u32);
+	jdsz = 16 * sizeof(u32);
+	sdesc = kzalloc(sdsz, GFP_KERNEL | GFP_DMA);
+	jdesc = kzalloc(jdsz, GFP_KERNEL | GFP_DMA);
+
+	/* Allocate buffers */
+	inbufsz = 64;
+	outbufsz = 116;
+	inbuf = kmalloc(inbufsz, GFP_KERNEL | GFP_DMA);
+	outbuf = kmalloc(outbufsz, GFP_KERNEL | GFP_DMA);
+
+	if ((sdesc == NULL) || (jdesc == NULL) ||
+	    (inbuf == NULL) || (outbuf == NULL)) {
+		printk(KERN_INFO "jq_ipsec_esp_no_term: can't get buffers\n");
+		kfree(sdesc);
+		kfree(jdesc);
+		kfree(inbuf);
+		kfree(outbuf);
+		return -1;
+	};
+
+	/* Fill out PDB options, no optional header */
+	pdb.opthdrlen = 0;
+	pdb.opthdr = NULL;
+	pdb.transmode = PDB_TUNNEL;
+	pdb.pclvers = PDB_IPV4;
+	pdb.outfmt = PDB_OUTPUT_COPYALL;
+	pdb.ivsrc = PDB_IV_FROM_RNG;
+	pdb.seq.esn = PDB_NO_ESN;
+	pdb.seq.antirplysz = PDB_ANTIRPLY_NONE;
+
+	/* Do transforms */
+	cipher.algtype = CIPHER_TYPE_IPSEC_AESCBC;
+	cipher.key = class_1_key;
+	cipher.keylen = 16 * 8; /* AES keysize in bits */
+
+	auth.algtype = AUTH_TYPE_IPSEC_SHA1HMAC_96;
+	auth.key = class_2_key;
+	auth.keylen = 20 * 8; /* SHA1 keysize in bits */
+
+	/* Now construct */
+	stat = cnstr_pcl_shdsc_ipsec_cbc_encap(sdesc, &sdsz, &pdb, &cipher,
+					       &auth, 0);
+	if (stat) {
+		printk(KERN_INFO
+		       "jq_ipsec_esp_no_term: sharedesc construct failed\n");
+		kfree(sdesc);
+		kfree(jdesc);
+		return -1;
+	};
+
+	/* Map data prior to jobdesc build */
+	sdmap = (u32 *)dma_map_single(dev, sdesc, sdsz, DMA_BIDIRECTIONAL);
+	inmap = (u8 *)dma_map_single(dev, inbuf, inbufsz, DMA_TO_DEVICE);
+	outmap = (u8 *)dma_map_single(dev, outbuf, outbufsz, DMA_FROM_DEVICE);
+
+	/* build jobdesc */
+	cnstr_seq_jobdesc(jdesc, &jdsz, sdmap, sdsz, inmap, inbufsz,
+			  outmap, outbufsz);
+
+	/* map jobdesc */
+	jdmap = (u32 *)dma_map_single(dev, jdesc, jdsz, DMA_TO_DEVICE);
+
+	/* Show it before we run it */
+	if (show == SHOW_DESC) {
+		caam_desc_disasm(jdesc);
+		caam_desc_disasm(sdesc);
+	}
+
+	/* Enqueue and block*/
+	stat = caam_jq_enqueue(dev, jdesc, jq_ipsec_done, (void *)&jqarg);
+	if (stat) {
+		printk(KERN_INFO "jq_ipsec_esp_no_term: can't enqueue\n");
+		rtnval = -1;
+	}
+	exit = wait_event_interruptible(jqtest_wq, (jqarg));
+	if (exit)
+		printk(KERN_INFO "jq_ipsec_esp_no_term: interrupted\n");
+
+
+	dma_unmap_single(dev, (u32)sdmap, sdsz, DMA_BIDIRECTIONAL);
+	dma_unmap_single(dev, (u32)jdmap, jdsz, DMA_TO_DEVICE);
+	dma_unmap_single(dev, (u32)inmap, inbufsz, DMA_TO_DEVICE);
+	dma_unmap_single(dev, (u32)outmap, outbufsz, DMA_FROM_DEVICE);
+	kfree(sdesc);
+	kfree(jdesc);
+	kfree(inbuf);
+	kfree(outbuf);
+
+	return rtnval;
+}
diff --git a/drivers/crypto/caam/regs.h b/drivers/crypto/caam/regs.h
new file mode 100644
index 0000000..01a22da
--- /dev/null
+++ b/drivers/crypto/caam/regs.h
@@ -0,0 +1,627 @@
+/*
+ * CAAM hardware register-level view
+ *
+ * Copyright (c) 2008, 2009, Freescale Semiconductor, Inc.
+ * All Rights Reserved
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef REGS_H
+#define REGS_H
+
+#include <linux/types.h>
+#include <linux/io.h>
+
+/*
+ * Architecture-specific register access methods
+ *
+ * CAAM's bus-addressable registers are 64 bits internally.
+ * They have been wired to be safely accessible on 32-bit
+ * architectures, however. Registers were organized such
+ * that (a) they can be contained in 32 bits, (b) if not, then they
+ * can be treated as two 32-bit entities, or finally (c) if they
+ * must be treated as a single 64-bit value, then this can safely
+ * be done with two 32-bit cycles.
+ *
+ * At the present time, the code is only written and tested for
+ * a BE32 architecture (Power32), but a LE32 architecture (ARM) will
+ * be ported soon, and a 64-bit Power variant is expected within the
+ * architectural lifecycle of this device.
+ *
+ * For 32-bit operations on 64-bit values, CAAM follows the same
+ * 64-bit register access conventions as it's predecessors, in that
+ * writes are "triggered" by a write to the register at the numerically
+ * higher address, thus, a full 64-bit write cycle requires a write
+ * to the lower address, followed by a write to the higher address,
+ * which will latch/execute the write cycle.
+ *
+ * For example, let's assume a SW reset of CAAM through the master
+ * configuration register.
+ * - SWRST is in bit 31 of MCFG.
+ * - MCFG begins at base+0x0000.
+ * - Bits 63-32 are a 32-bit word at base+0x0000 (numerically-lower)
+ * - Bits 31-0 are a 32-bit word at base+0x0004 (numerically-higher)
+ *
+ * (and on Power, the convention is 0-31, 32-63, I know...)
+ *
+ * Assuming a 64-bit write to this MCFG to perform a software reset
+ * would then require a write of 0 to base+0x0000, followed by a
+ * write of 0x80000000 to base+0x0004, which would "execute" the
+ * reset.
+ *
+ * Of course, since MCFG 63-32 is all zero, we could cheat and simply
+ * write 0x8000000 to base+0x0004, and the reset would work fine.
+ * However, since CAAM does contain some write-and-read-intended
+ * 64-bit registers, this code defines 64-bit access methods for
+ * the sake of internal consistency and simplicity, and so that a
+ * clean transition to 64-bit is possible when it becomes necessary.
+ *
+ * There are limitations to this that the developer must recognize.
+ * 32-bit architectures cannot enforce an atomic-64 operation,
+ * Therefore:
+ *
+ * - On writes, since the HW is assumed to latch the cycle on the
+ *   write of the higher-numeric-address word, then ordered
+ *   writes work OK.
+ *
+ * - For reads, where a register contains a relevant value of more
+ *   that 32 bits, the hardware employs logic to latch the other
+ *   "half" of the data until read, ensuring an accurate value.
+ *   This is of particular relevance when dealing with CAAM's
+ *   performance counters.
+ *
+ */
+
+#ifdef CONFIG_PPC32 /* normally BE32 */
+static inline void wr_reg64(__be64 *reg, __be64 data)
+{
+	out_be32((__be32 *)reg, ((data & 0xffffffff00000000ull) >> 32));
+	out_be32((__be32 *)reg + 1, (data & 0x00000000ffffffffull));
+}
+
+static inline __be64 rd_reg64(__be64 *reg)
+{
+	return (((u64)in_be32((__be32 *)reg)) << 32) |
+		((u64)in_be32((__be32 *)reg + 1));
+}
+
+#define wr_reg32(reg, data) out_be32(reg, data)
+#define rd_reg32(reg) in_be32(reg)
+#define wr_reg16(reg, data) out_be16(reg, data)
+#define rd_reg16(reg) in_be16(reg)
+#else /* !CONFIG_PPC32 */
+	/* TODO: define little-endian variant */
+#endif
+
+
+/*
+ * jq_outentry
+ * Represents each entry in a JobQ output ring
+ */
+struct jq_outentry {
+	u32 *desc;	/* Pointer to completed descriptor */
+	u32 jqstatus;	/* Status for completed descriptor */
+};
+
+/*
+ * caam_mstraccess - Arrayed Secure Memory Partition Access
+ *
+ * Used to control access to 1-16 SM partitions per Job Queue
+ */
+struct caam_mstraccess {
+	__be32 rsvd1;
+	__be32 mstrperm;   /* Master Access Permissions/Partition  */
+	__be32 rsvd2;
+	__be32 mstrid;     /* Allowed Master ID/Partition          */
+};
+
+/*
+ * caam_perfmon - Performance Monitor/Secure Memory Status/
+ *                CAAM Global Status/Component Version IDs
+ *
+ * Spans f00-fff wherever instantiated
+ */
+struct caam_perfmon {
+	/* Performance Monitor Registers                        f00-f38 */
+	__be64 req_dequeued;   /* Dequeued Requests         */
+	__be64 ob_enc_req;     /* Outbound Encrypt Requests */
+	__be64 ib_dec_req;     /* Inbound Decrypt Requests  */
+	__be64 ob_enc_bytes;   /* Outbound Bytes Encrypted  */
+	__be64 ob_prot_bytes;  /* Outbound Bytes Protected  */
+	__be64 ib_dec_bytes;   /* Inbound Bytes Decrypted   */
+	__be64 ib_valid_bytes; /* Inbound Bytes Validated   */
+	__be64 rsvd[15];
+
+	/* Secure Memory                                        fb0-fbf */
+	__be64 smstatus;     /* SMSTA - Secure Memory Status      */
+	__be64 smpartowner;  /* SMPO  - SM Partition Owner        */
+
+	/* CAAM Global Status                                   fc0-fd7 */
+	__be64 faultaddr;    /* CFAR  - CAAM Fault Address        */
+	__be32 rsvd1;
+	__be32 faultdetail;  /* CFADR - CAAM Fault Addr Detail    */
+	__be32 rsvd2;
+	__be32 status;       /* CSTA  - CAAM Status               */
+
+	/* Component ID Space                                   fd8-fff */
+	__be64 sm_id;        /* SMVID - Secure Memory Version ID  */
+	__be64 ccb_id;       /* CCBVID - CCB Version ID           */
+	__be64 cha_id;       /* CHAVID - CHA Version ID           */
+	__be64 rtic_id;      /* RVID - RTIC Version ID            */
+	__be64 caam_id;      /* CAAMVID - CAAM Version ID         */
+};
+
+
+/* Master ID for DMA configuration */
+struct masterid {
+	__be32 rsvd1;
+	__be32 midr;	/* master ID, JobQ or RTIC */
+};
+
+/* Partition ID for DMA configuration */
+struct partid {
+	__be32 rsvd1;
+	__be32 pidr;	/* partition ID, DECO */
+};
+
+/* RNG test mode (replicated twice in some configurations) */
+/* Padded out to 0x100 */
+struct rngtst {
+	__be32 mode;		/* Test mode */
+	__be32 rsvd1[3];
+	__be32 reset;		/* Test reset control */
+	__be32 rsvd2[3];
+	__be32 status;		/* Test status */
+	__be32 rsvd3;
+	__be32 errstat;	/* Test error status */
+	__be32 rsvd4;
+	__be32 errctl;		/* Test error control */
+	__be32 rsvd5;
+	__be32 entropy;	/* Test entropy */
+	__be32 rsvd6[15];
+	__be32 verifctl;	/* Test verification control */
+	__be32 rsvd7;
+	__be32 verifstat;	/* Test verification status */
+	__be32 rsvd8;
+	__be32 verifdata;	/* Test verification data */
+	__be32 rsvd9;
+	__be32 xkey;		/* Test XKEY */
+	__be32 rsvd10;
+	__be32 oscctctl;	/* Test oscillator counter control */
+	__be32 rsvd11;
+	__be32 oscct;		/* Test oscillator counter */
+	__be32 rsvd12;
+	__be32 oscctstat;	/* Test oscillator counter status */
+	__be32 rsvd13[2];
+	__be32 ofifo[4];	/* Test output FIFO */
+	__be32 rsvd14[15];
+};
+
+/*
+ * caam_ctrl - basic core configuration
+ * starts base + 0x0000 padded out to 0x1000
+ */
+
+struct caam_ctrl {
+	/* Basic Configuration Section                          000-02f */
+	/* Read/Writable                                                */
+	__be32 rsvd1;
+	__be32 mcr;		/* MCFG      Master Config Register  */
+	__be32 rsvd2[2];
+
+	/* Bus Access Configuration Section                     090-0c7 */
+	/* Read/Writable                                                */
+	struct masterid jq_mid[4];	/* JQ0MIDx - 1 per queue */
+	__be32 rsvd3[12];
+	struct masterid rtic_mid[4];	/* RTICMID   RTIC Bus Master ID */
+	__be32 rsvd4[7];
+	__be32 deco_rq;			/* DECORR    DECO Request */
+	struct partid deco_mid[5];	/* DECOMIDx - 1 per DECO */
+	__be32 rsvd5[206];
+
+	/* Key Encryption/Decryption Configuration              400-47f */
+	/* Read/Writable only while in Non-secure mode                  */
+	__be32 kek[8];		/* KEK - Key Encryption Key */
+	__be32 tkek[8];		/* TKEK - Trusted Key Encryption Key */
+	__be32 tdsk[8];		/* TDSK - Trusted Desc Signing Key */
+	__be32 rsvd6[104];
+
+	/* RNG Test/Verification/Debug Access                   600-6b7 */
+	/* (Useful in Test/Debug modes only...)                         */
+	struct rngtst rtst[2];
+
+	/* LIODN Accessibility Mapping                          800-9ff */
+	__be16 pidmap[64];   /* CPIDMR - PID/LIODN Mapping        */
+	__be32 rsvd7[416];
+
+	/* Performance Monitor                                  f00-fff */
+	struct caam_perfmon perfmon;
+};
+
+/*
+ * caam_job_queue - direct job queue setup
+ * 1-4 possible per instantiation, base + 1000/2000/3000/4000
+ * Padded out to 0x1000
+ */
+struct caam_job_queue {
+	/* Input ring */
+	__be64 inpring_base;	/* Input desc ring baseaddr */
+	__be32 rsvd1;
+	__be32 inpring_size;	/* Input ring size */
+	__be32 rsvd2;
+	__be32 inpring_avail;	/* Input ring room remaining */
+	__be32 rsvd3;
+	__be32 inpring_jobadd;	/* Input ring jobs added */
+
+	/* Output Ring */
+	__be64 outring_base;	/* Output status ring base addr */
+	__be32 rsvd4;
+	__be32 outring_size;	/* Output ring size */
+	__be32 rsvd5;
+	__be32 outring_rmvd;	/* Output ring jobs removed */
+	__be32 rsvd6;
+	__be32 outring_used;	/* Output ring slots full */
+
+	/* Status/Configuration */
+	__be32 rsvd7;
+	__be32 jqoutstatus;	/* JobQ output status */
+	__be32 rsvd8;
+	__be32 jqintstatus;	/* JobQ interrupt status */
+	__be32 qconfig_hi;	/* Queue configuration */
+	__be32 qconfig_lo;
+
+	/* Indices. CAAM maintains as "heads" of each queue */
+	__be32 rsvd9;
+	__be32 inp_rdidx;	/* Input ring read index */
+	__be32 rsvd10;
+	__be32 out_wtidx;	/* Output ring write index */
+
+	/* Command/control */
+	__be32 rsvd11;
+	__be32 jqcommand;	/* JobQ command */
+
+	__be32 rsvd12[128];
+
+	/* Secure Memory Access Configuration */
+	__be32 rsvd13;
+	__be32 smemcmd;         /* Secure Memory Command */
+	__be32 rsvd14;
+	__be32 smemstatus;      /* Secure Memory Command Status */
+	struct caam_mstraccess access[16]; /* SM Partition Access Perms */
+
+	__be32 rsvd15[800];
+};
+
+#define JQ_RINGSIZE_MASK	0x03ff
+/*
+ * jqstatus - Job Queue Output Status
+ * All values in lo word
+ * Also note, same values written out as status through QI
+ * in the command/status field of a frame descriptor
+ */
+#define JQSTA_SSRC_MASK             0xf0000000
+
+#define JQSTA_SSRC_NONE             0x00000000
+#define JQSTA_SSRC_CCB_ERROR        0x20000000
+#define JQSTA_SSRC_JUMP_HALT_USER   0x30000000
+#define JQSTA_SSRC_DECO             0x40000000
+#define JQSTA_SSRC_JQERROR          0x60000000
+#define JQSTA_SSRC_JUMP_HALT_CC     0x70000000
+
+#define JQSTA_DECOERR_JUMP          0x08000000
+#define JQSTA_DECOERR_INDEX_MASK    0xff00
+#define JQSTA_DECOERR_ERROR_MASK    0x00ff
+
+#define JQSTA_DECOERR_NONE          0x00
+#define JQSTA_DECOERR_LINKLEN       0x01
+#define JQSTA_DECOERR_LINKPTR       0x02
+#define JQSTA_DECOERR_JQCTRL        0x03
+#define JQSTA_DECOERR_DESCCMD       0x04
+#define JQSTA_DECOERR_ORDER         0x05
+#define JQSTA_DECOERR_KEYCMD        0x06
+#define JQSTA_DECOERR_LOADCMD       0x07
+#define JQSTA_DECOERR_STORECMD      0x08
+#define JQSTA_DECOERR_OPCMD         0x09
+#define JQSTA_DECOERR_FIFOLDCMD     0x0a
+#define JQSTA_DECOERR_FIFOSTCMD     0x0b
+#define JQSTA_DECOERR_MOVECMD       0x0c
+#define JQSTA_DECOERR_JUMPCMD       0x0d
+#define JQSTA_DECOERR_MATHCMD       0x0e
+#define JQSTA_DECOERR_SHASHCMD      0x0f
+#define JQSTA_DECOERR_SEQCMD        0x10
+#define JQSTA_DECOERR_DECOINTERNAL  0x11
+#define JQSTA_DECOERR_SHDESCHDR     0x12
+#define JQSTA_DECOERR_HDRLEN        0x13
+#define JQSTA_DECOERR_BURSTER       0x14
+#define JQSTA_DECOERR_DESCSIGNATURE 0x15
+#define JQSTA_DECOERR_DMA           0x16
+#define JQSTA_DECOERR_BURSTFIFO     0x17
+#define JQSTA_DECOERR_JQRESET       0x1a
+#define JQSTA_DECOERR_JOBFAIL       0x1b
+#define JQSTA_DECOERR_DNRERR        0x80
+#define JQSTA_DECOERR_UNDEFPCL      0x81
+#define JQSTA_DECOERR_PDBERR        0x82
+#define JQSTA_DECOERR_ANRPLY_LATE   0x83
+#define JQSTA_DECOERR_ANRPLY_REPLAY 0x84
+#define JQSTA_DECOERR_SEQOVF        0x85
+#define JQSTA_DECOERR_INVSIGN       0x86
+#define JQSTA_DECOERR_DSASIGN       0x87
+
+#define JQSTA_CCBERR_JUMP           0x08000000
+#define JQSTA_CCBERR_INDEX_MASK     0xff00
+#define JQSTA_CCBERR_INDEX_SHIFT    8
+#define JQSTA_CCBERR_CHAID_MASK     0x00f0
+#define JQSTA_CCBERR_CHAID_SHIFT    4
+#define JQSTA_CCBERR_ERRID_MASK     0x000f
+
+#define JQSTA_CCBERR_CHAID_AES      (0x01 << JQSTA_CCBERR_CHAID_SHIFT)
+#define JQSTA_CCBERR_CHAID_DES      (0x02 << JQSTA_CCBERR_CHAID_SHIFT)
+#define JQSTA_CCBERR_CHAID_ARC4     (0x03 << JQSTA_CCBERR_CHAID_SHIFT)
+#define JQSTA_CCBERR_CHAID_MD       (0x04 << JQSTA_CCBERR_CHAID_SHIFT)
+#define JQSTA_CCBERR_CHAID_RNG      (0x05 << JQSTA_CCBERR_CHAID_SHIFT)
+#define JQSTA_CCBERR_CHAID_SNOW     (0x06 << JQSTA_CCBERR_CHAID_SHIFT)
+#define JQSTA_CCBERR_CHAID_KASUMI   (0x07 << JQSTA_CCBERR_CHAID_SHIFT)
+#define JQSTA_CCBERR_CHAID_PK       (0x08 << JQSTA_CCBERR_CHAID_SHIFT)
+#define JQSTA_CCBERR_CHAID_CRC      (0x09 << JQSTA_CCBERR_CHAID_SHIFT)
+
+#define JQSTA_CCBERR_ERRID_NONE     0x00
+#define JQSTA_CCBERR_ERRID_MODE     0x01
+#define JQSTA_CCBERR_ERRID_DATASIZ  0x02
+#define JQSTA_CCBERR_ERRID_KEYSIZ   0x03
+#define JQSTA_CCBERR_ERRID_PKAMEMSZ 0x04
+#define JQSTA_CCBERR_ERRID_PKBMEMSZ 0x05
+#define JQSTA_CCBERR_ERRID_SEQUENCE 0x06
+#define JQSTA_CCBERR_ERRID_PKDIVZRO 0x07
+#define JQSTA_CCBERR_ERRID_PKMODEVN 0x08
+#define JQSTA_CCBERR_ERRID_KEYPARIT 0x09
+#define JQSTA_CCBERR_ERRID_ICVCHK   0x0a
+#define JQSTA_CCBERR_ERRID_HARDWARE 0x0b
+#define JQSTA_CCBERR_ERRID_CCMAAD   0x0c
+#define JQSTA_CCBERR_ERRID_INVCHA   0x0f
+
+#define JQINT_ERR_INDEX_MASK        0x3fff0000
+#define JQINT_ERR_INDEX_SHIFT       16
+#define JQINT_ERR_TYPE_MASK         0xf00
+#define JQINT_ERR_TYPE_SHIFT        8
+#define JQINT_ERR_HALT_MASK         0x0c
+#define JQINT_ERR_HALT_SHIFT        2
+#define JQINT_JQ_ERROR              0x02
+#define JQINT_JQ_INT                0x01
+
+#define JQINT_ERR_TYPE_WRITE        1
+#define JQINT_ERR_TYPE_BAD_INPADDR  3
+#define JQINT_ERR_TYPE_BAD_OUTADDR  4
+#define JQINT_ERR_TYPE_INV_INPWRT   5
+#define JQINT_ERR_TYPE_INV_OUTWRT   6
+#define JQINT_ERR_TYPE_RESET        7
+#define JQINT_ERR_TYPE_REMOVE_OFL   8
+#define JQINT_ERR_TYPE_ADD_OFL      9
+
+#define JQCFG_SOE                   0x04
+#define JQCFG_ICEN                  0x02
+#define JQCFG_IMSK                  0x01
+
+#define JQCR_RESET                  0x01
+
+/*
+ * caam_assurance - Assurance Controller View
+ * base + 0x6000 padded out to 0x1000
+ */
+
+struct rtic_element {
+	__be64 address;
+	__be32 rsvd;
+	__be32 length;
+};
+
+struct rtic_block {
+	struct rtic_element element[2];
+};
+
+struct rtic_memhash {
+	__be32 memhash_be[32];
+	__be32 memhash_le[32];
+};
+
+struct caam_assurance {
+    /* Status/Command/Watchdog */
+	__be32 rsvd1;
+	__be32 status;		/* RTIC Status                     */
+	__be32 rsvd2;
+	__be32 cmd;		/* RTIC Command                    */
+	__be32 rsvd3;
+	__be32 ctrl;		/* RTIC Control                    */
+	__be32 rsvd4;
+	__be32 throttle;	/* RTIC Throttle                   */
+	__be32 rsvd5;
+	__be64 watchdog;	/* RTIC Watchdog Timer             */
+	__be32 rsvd6;
+	__be32 rend;		/* Endian corrections */
+	__be32 rsvd7[50];
+
+	/* Block access/configuration @ 100/110/120/130 */
+	struct rtic_block memblk[4];	/* RTIC Memory Blocks A-D */
+	__be32 rsvd8[32];
+
+	/* Block hashes @ 200/300/400/500 */
+	struct rtic_memhash hash[4];	/* Block hash values A-D */
+	__be32 rsvd_3[640];
+};
+
+/*
+ * caam_queue_if - QI configuration and control
+ * starts base + 0x7000, padded out to 0x1000 long
+ */
+
+struct caam_queue_if {
+	__be32 qi_control_hi;	/* QICTL  - QI Control */
+	__be32 qi_control_lo;
+	__be32 rsvd1;
+	__be32 qi_status;	/* QISTA  - QI Status */
+	__be32 qi_deq_cfg_hi;	/* QIDQC  - QI Dequeue Configuration */
+	__be32 qi_deq_cfg_lo;
+	__be32 qi_enq_cfg_hi;	/* QISEQC - QI Enqueue Command     */
+	__be32 qi_enq_cfg_lo;
+	__be32 rsvd2[1016];
+};
+
+/* QI control bits - low word */
+#define QICTL_DQEN      0x01              /* Enable frame pop          */
+#define QICTL_STOP      0x02              /* Stop dequeue/enqueue      */
+#define QICTL_SOE       0x04              /* Stop on error             */
+
+/* QI control bits - high word */
+#define QICTL_MBSI	0x01
+#define QICTL_MHWSI	0x02
+#define QICTL_MWSI	0x04
+#define QICTL_MDWSI	0x08
+#define QICTL_CBSI	0x10		/* CtrlDataByteSwapInput     */
+#define QICTL_CHWSI	0x20		/* CtrlDataHalfSwapInput     */
+#define QICTL_CWSI	0x40		/* CtrlDataWordSwapInput     */
+#define QICTL_CDWSI	0x80		/* CtrlDataDWordSwapInput    */
+#define QICTL_MBSO	0x0100
+#define QICTL_MHWSO	0x0200
+#define QICTL_MWSO	0x0400
+#define QICTL_MDWSO	0x0800
+#define QICTL_CBSO	0x1000		/* CtrlDataByteSwapOutput    */
+#define QICTL_CHWSO	0x2000		/* CtrlDataHalfSwapOutput    */
+#define QICTL_CWSO	0x4000		/* CtrlDataWordSwapOutput    */
+#define QICTL_CDWSO     0x8000		/* CtrlDataDWordSwapOutput   */
+#define QICTL_DMBS	0x010000
+#define QICTL_EPO	0x020000
+
+/* QI status bits */
+#define QISTA_PHRDERR   0x01              /* PreHeader Read Error      */
+#define QISTA_CFRDERR   0x02              /* Compound Frame Read Error */
+#define QISTA_OFWRERR   0x04              /* Output Frame Read Error   */
+#define QISTA_BPDERR    0x08              /* Buffer Pool Depleted      */
+#define QISTA_BTSERR    0x10              /* Buffer Undersize          */
+#define QISTA_CFWRERR   0x20              /* Compound Frame Write Err  */
+#define QISTA_STOPD     0x80000000        /* QI Stopped (see QICTL)    */
+
+/*
+ * caam_deco - descriptor controller - CHA cluster block
+ *
+ * Only accessible when direct DECO access is turned on
+ * (done in DECORR, via MID programmed in DECOxMID
+ *
+ * 5 typical, base + 0x8000/9000/a000/b000
+ * Padded out to 0x1000 long
+ */
+struct caam_deco {
+	__be32 rsvd1;
+	__be32 cls1_mode;	/* Class 1 Mode */
+	__be32 rsvd2;
+	__be32 cls1_keysize;	/* Class 1 Key Size */
+	__be32 cls1_datasize_hi;	/* Class 1 Data Size */
+	__be32 cls1_datasize_lo;
+	__be32 rsvd3;
+	__be32 cls1_icvsize;	/* Class 1 ICV size */
+	__be32 rsvd4[5];
+	__be32 cha_ctrl;	/* CHA control */
+	__be32 rsvd5;
+	__be32 irq_crtl;	/* CCB interrupt done/error/clear */
+	__be32 rsvd6;
+	__be32 clr_written;	/* Clear-Written */
+	__be32 ccb_status_hi;	/* CCB Status */
+	__be32 ccb_status_lo;
+	__be32 rsvd7[3];
+	__be32 aad_size;	/* Current AAD Size */
+	__be32 rsvd8;
+	__be32 cls1_iv_size;	/* Current Class 1 IV Size */
+	__be32 rsvd9[7];
+	__be32 pkha_a_size;	/* Size of PKHA A */
+	__be32 rsvd10;
+	__be32 pkha_b_size;	/* Size of PKHA B */
+	__be32 rsvd11;
+	__be32 pkha_n_size;	/* Size of PKHA N */
+	__be32 rsvd12;
+	__be32 pkha_e_size;	/* Size of PKHA E */
+	__be32 rsvd13[24];
+	__be32 cls1_ctx[16];	/* Class 1 Context @100 */
+	__be32 rsvd14[48];
+	__be32 cls1_key[8];	/* Class 1 Key @200 */
+	__be32 rsvd15[121];
+	__be32 cls2_mode;	/* Class 2 Mode */
+	__be32 rsvd16;
+	__be32 cls2_keysize;	/* Class 2 Key Size */
+	__be32 cls2_datasize_hi;	/* Class 2 Data Size */
+	__be32 cls2_datasize_lo;
+	__be32 rsvd17;
+	__be32 cls2_icvsize;	/* Class 2 ICV Size */
+	__be32 rsvd18[56];
+	__be32 cls2_ctx[18];	/* Class 2 Context @500 */
+	__be32 rsvd19[46];
+	__be32 cls2_key[32];	/* Class2 Key @600 */
+	__be32 rsvd20[84];
+	__be32 inp_infofifo;	/* Input Info FIFO @7d0 */
+	__be32 rsvd21[3];
+	__be32 inp_datafifo;	/* Input Data FIFO */
+	__be32 rsvd22[3];
+	__be64 out_datafifo;	/* Output Data FIFO */
+	__be32 rsvd23[2];
+	__be32 jq_ctl_hi;	/* JobQ Control Register      @800 */
+	__be32 jq_ctl_lo;
+	__be64 jq_descaddr;	/* JobQ Descriptor Address */
+	__be32 op_status_hi;	/* DECO Operation Status */
+	__be32 op_status_lo;
+	__be32 rsvd24[10];
+	__be64 math[4];		/* Math register */
+	__be32 rsvd25[104];
+	__be32 descbuf[64];	/* Descriptor buffer */
+	__be32 rsvd26[320];
+};
+
+/*
+ * Current top-level view of memory map is:
+ *
+ * 0x0000 - 0x0fff - CAAM Top-Level Control
+ * 0x1000 - 0x1fff - Job Queue 0
+ * 0x2000 - 0x2fff - Job Queue 1
+ * 0x3000 - 0x3fff - Job Queue 2
+ * 0x4000 - 0x4fff - Job Queue 3
+ * 0x5000 - 0x5fff - (unused)
+ * 0x6000 - 0x6fff - Assurance Controller
+ * 0x7000 - 0x7fff - Queue Interface
+ * 0x8000 - 0x8fff - DECO-CCB 0
+ * 0x9000 - 0x9fff - DECO-CCB 1
+ * 0xa000 - 0xafff - DECO-CCB 2
+ * 0xb000 - 0xbfff - DECO-CCB 3
+ * 0xc000 - 0xcfff - DECO-CCB 4
+ *
+ * caam_full describes the full register view of CAAM if useful,
+ * although many configurations may choose to implement parts of
+ * the register map separately, in differing privilege regions
+ */
+struct caam_full {
+    struct caam_ctrl ctrl;
+    struct caam_job_queue jq[4];
+    __be64 rsvd[512];
+    struct caam_assurance assure;
+    struct caam_queue_if qi;
+    struct caam_deco deco[5];
+};
+
+#endif /* REGS_H */
-- 
1.6.3.3

