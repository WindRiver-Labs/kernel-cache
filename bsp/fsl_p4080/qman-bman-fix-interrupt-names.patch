From 1756c2c9a9e2327f85c82eb773dfdc1712dee8fd Mon Sep 17 00:00:00 2001
From: Geoff Thorpe <Geoff.Thorpe@freescale.com>
Date: Wed, 11 Nov 2009 21:26:55 -0500
Subject: [PATCH 096/148] qman/bman: fix interrupt names.

Signed-off-by: Geoff Thorpe <Geoff.Thorpe@freescale.com>
[Applied FSL SDK 2.0.3 patch
"kernel-2.6.30-qman-bman-fix-interrupt-names.patch"]
Integrated-by: Yuri Nedel <Yuri.Nedel@windriver.com>
---
 drivers/hwalloc/bman_high.c |    6 +++++-
 drivers/hwqueue/qman_high.c |    7 +++++--
 2 files changed, 10 insertions(+), 3 deletions(-)

diff --git a/drivers/hwalloc/bman_high.c b/drivers/hwalloc/bman_high.c
index b74ddf6..c5f992a 100644
--- a/drivers/hwalloc/bman_high.c
+++ b/drivers/hwalloc/bman_high.c
@@ -40,6 +40,8 @@
 /* Compilation constants */
 #define RCR_THRESH	2	/* reread h/w CI when running out of space */
 #define RCR_ITHRESH	4	/* if RCR congests, interrupt threshold */
+#define IRQNAME		"BMan portal %d"
+#define MAX_IRQNAME	16	/* big enough for "BMan portal %d" */
 
 /**************/
 /* Portal API */
@@ -62,6 +64,7 @@ struct bman_portal {
 	 * BTW, with 64 entries in the hash table and 64 buffer pools to track,
 	 * you'll never guess the hash-function ... */
 	struct bman_pool *cb[64];
+	char irqname[MAX_IRQNAME];
 };
 
 /* GOTCHA: this object type refers to a pool, it isn't *the* pool. There may be
@@ -185,7 +188,8 @@ struct bman_portal *bman_create_portal(struct bm_portal *__p,
 	bm_isr_enable_write(portal->p, BM_PIRQ_RCRI | BM_PIRQ_BSCN);
 	bm_isr_status_clear(portal->p, 0xffffffff);
 #ifdef CONFIG_FSL_BMAN_HAVE_IRQ
-	if (request_irq(config->irq, portal_isr, 0, "Bman portal 0", portal)) {
+	snprintf(portal->irqname, MAX_IRQNAME, IRQNAME, config->cpu);
+	if (request_irq(config->irq, portal_isr, 0, portal->irqname, portal)) {
 		pr_err("request_irq() failed\n");
 		goto fail_irq;
 	}
diff --git a/drivers/hwqueue/qman_high.c b/drivers/hwqueue/qman_high.c
index 987a8dd..2b4aa13 100644
--- a/drivers/hwqueue/qman_high.c
+++ b/drivers/hwqueue/qman_high.c
@@ -44,6 +44,8 @@
 #define EQCR_THRESH	1	/* reread h/w CI when running out of space */
 #define EQCR_ITHRESH	4	/* if EQCR congests, interrupt threshold */
 #define RECOVER_MSLEEP	100	/* DQRR and MR need to be empty for 0.1s */
+#define IRQNAME		"QMan portal %d"
+#define MAX_IRQNAME	16	/* big enough for "QMan portal %d" */
 
 /* Lock/unlock frame queues, subject to the "LOCKED" flag. This is about
  * inter-processor locking only. Note, FQLOCK() is always called either under a
@@ -117,6 +119,7 @@ struct qman_portal {
 	/* This is needed for providing a non-NULL device to dma_map_***() */
 	struct platform_device *pdev;
 	struct qman_rbtree retire_table;
+	char irqname[MAX_IRQNAME];
 };
 
 /* This gives a FQID->FQ lookup to cover the fact that we can't directly demux
@@ -296,8 +299,8 @@ struct qman_portal *qman_create_portal(struct qm_portal *__p, u32 flags,
 		QM_PIRQ_MRI | (cgrs ? QM_PIRQ_CSCI : 0));
 	qm_isr_status_clear(portal->p, 0xffffffff);
 #ifdef CONFIG_FSL_QMAN_HAVE_IRQ
-	if (request_irq(config->irq, portal_isr, 0, "Qman portal 0",
-					portal)) {
+	snprintf(portal->irqname, MAX_IRQNAME, IRQNAME, config->cpu);
+	if (request_irq(config->irq, portal_isr, 0, portal->irqname, portal)) {
 		pr_err("request_irq() failed\n");
 		goto fail_irq;
 	}
-- 
1.6.5.2

