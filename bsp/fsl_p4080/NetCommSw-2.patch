From 4a358c953cdc064ffa6071ac00570dab052d1b5b Mon Sep 17 00:00:00 2001
From: Timur Tabi <timur@freescale.com>
Date: Fri, 16 Apr 2010 11:29:11 -0400
Subject: [PATCH] NetCommSw

drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/integrations/P4080/integration_ioctls.h
 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/ioctls.h
 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/net_ioctls.h
 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/Peripherals/fm_ioctls.h
 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/Peripherals/fm_pcd_ioctls.h
 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/Peripherals/fm_port_ioctls.h
 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/Peripherals/fm_test_ioctls.h
 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/procbuff_ext.h
 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/system/platform_ext.h
 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/system/platform_p4080_ds_ext.h
 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/system/sys_ext.h
 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/system/sys_io_ext.h
 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/types_linux.h
 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/wrappers/Peripherals/fsl_fman.h
 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/wrappers/Peripherals/fsl_fman_test.h
 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/wrappers/Peripherals/lnxwrp_fm_ext.h
 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/Makefile
 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/modules/integrations/P4080/FM/fmm.c
 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/modules/integrations/P4080/FM/Makefile
 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/modules/integrations/P4080/FM/mod_config.h
 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/system/Makefile
 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/system/platform/P4080/Makefile
 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/system/platform/P4080/platform_p4080_ds.c
 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/system/sys_init.c
 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/system/sys_io.c
 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/util/Makefile
 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/util/procbuff.c
 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/util/procbuff.h
 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/fman_test.c
 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/lnxwrp_fm.c
 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/lnxwrp_fm.h
 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/lnxwrp_fm_ioctls.c
 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/Makefile
 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/xx/ctype.c
 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/xx/integrations/Makefile
 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/xx/integrations/P4080/Makefile
 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/xx/integrations/P4080/xx_integration.c
 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/xx/Makefile
 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/xx/stdlib.c
 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/xx/udivdi3.c
 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/xx/xx.h
 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/xx/xx_linux.c

Signed-off-by: Donio Ron <rdonio@freescale.com>
Signed-off-by: Emil Medve <Emilian.Medve@Freescale.com>
Signed-off-by: Geoff Thorpe <Geoff.Thorpe@freescale.com>
Signed-off-by: Kumar Gala <galak@kernel.crashing.org>
Signed-off-by: Shlomi Gridish <gridish@freescale.com>
Signed-off-by: Timur Tabi <timur@freescale.com>

[Cleanly applied the FSL SDK 2.0.3 patch:
"p4080_1-2-rc1-linux-netcomm_user-2.patch",
original had no commit log text]
Integrated-by: Yuri Nedel <Yuri.Nedel@windriver.com>
---
 .../NetCommSw/user/env/linux/kernel/2.6/Makefile   |   13 +
 .../kernel/2.6/inc/ioctl/Peripherals/fm_ioctls.h   |  293 ++++
 .../2.6/inc/ioctl/Peripherals/fm_pcd_ioctls.h      | 1498 +++++++++++++++++
 .../2.6/inc/ioctl/Peripherals/fm_port_ioctls.h     |  592 +++++++
 .../2.6/inc/ioctl/Peripherals/fm_test_ioctls.h     |  159 ++
 .../ioctl/integrations/P4080/integration_ioctls.h  |   47 +
 .../user/env/linux/kernel/2.6/inc/ioctl/ioctls.h   |   84 +
 .../env/linux/kernel/2.6/inc/ioctl/net_ioctls.h    |  365 ++++
 .../user/env/linux/kernel/2.6/inc/procbuff_ext.h   |   58 +
 .../env/linux/kernel/2.6/inc/system/platform_ext.h |  126 ++
 .../kernel/2.6/inc/system/platform_p4080_ds_ext.h  |   64 +
 .../user/env/linux/kernel/2.6/inc/system/sys_ext.h |  290 ++++
 .../env/linux/kernel/2.6/inc/system/sys_io_ext.h   |   46 +
 .../user/env/linux/kernel/2.6/inc/types_linux.h    |  197 +++
 .../kernel/2.6/inc/wrappers/Peripherals/fsl_fman.h |  254 +++
 .../2.6/inc/wrappers/Peripherals/fsl_fman_test.h   |   68 +
 .../2.6/inc/wrappers/Peripherals/lnxwrp_fm_ext.h   |  161 ++
 .../2.6/modules/integrations/P4080/FM/Makefile     |   11 +
 .../kernel/2.6/modules/integrations/P4080/FM/fmm.c |  205 +++
 .../2.6/modules/integrations/P4080/FM/mod_config.h |   41 +
 .../user/env/linux/kernel/2.6/system/Makefile      |   13 +
 .../kernel/2.6/system/platform/P4080/Makefile      |    9 +
 .../2.6/system/platform/P4080/platform_p4080_ds.c  |  124 ++
 .../user/env/linux/kernel/2.6/system/sys_init.c    |   48 +
 .../user/env/linux/kernel/2.6/system/sys_io.c      |  179 ++
 .../user/env/linux/kernel/2.6/util/Makefile        |   11 +
 .../user/env/linux/kernel/2.6/util/procbuff.c      |  116 ++
 .../user/env/linux/kernel/2.6/util/procbuff.h      |   48 +
 .../kernel/2.6/wrappers/Peripherals/FM/Makefile    |   15 +
 .../kernel/2.6/wrappers/Peripherals/FM/fman_test.c |  610 +++++++
 .../kernel/2.6/wrappers/Peripherals/FM/lnxwrp_fm.c | 1743 ++++++++++++++++++++
 .../kernel/2.6/wrappers/Peripherals/FM/lnxwrp_fm.h |  189 +++
 .../2.6/wrappers/Peripherals/FM/lnxwrp_fm_ioctls.c | 1012 ++++++++++++
 .../user/env/linux/kernel/2.6/xx/Makefile          |   17 +
 .../NetCommSw/user/env/linux/kernel/2.6/xx/ctype.c |   67 +
 .../env/linux/kernel/2.6/xx/integrations/Makefile  |    9 +
 .../kernel/2.6/xx/integrations/P4080/Makefile      |   13 +
 .../2.6/xx/integrations/P4080/xx_integration.c     |  165 ++
 .../user/env/linux/kernel/2.6/xx/stdlib.c          |  264 +++
 .../user/env/linux/kernel/2.6/xx/udivdi3.c         |  132 ++
 .../NetCommSw/user/env/linux/kernel/2.6/xx/xx.h    |   43 +
 .../user/env/linux/kernel/2.6/xx/xx_linux.c        |  924 +++++++++++
 42 files changed, 10323 insertions(+), 0 deletions(-)
 create mode 100644 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/Makefile
 create mode 100644 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/Peripherals/fm_ioctls.h
 create mode 100644 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/Peripherals/fm_pcd_ioctls.h
 create mode 100644 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/Peripherals/fm_port_ioctls.h
 create mode 100644 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/Peripherals/fm_test_ioctls.h
 create mode 100644 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/integrations/P4080/integration_ioctls.h
 create mode 100644 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/ioctls.h
 create mode 100644 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/net_ioctls.h
 create mode 100644 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/procbuff_ext.h
 create mode 100644 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/system/platform_ext.h
 create mode 100644 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/system/platform_p4080_ds_ext.h
 create mode 100644 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/system/sys_ext.h
 create mode 100644 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/system/sys_io_ext.h
 create mode 100644 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/types_linux.h
 create mode 100644 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/wrappers/Peripherals/fsl_fman.h
 create mode 100644 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/wrappers/Peripherals/fsl_fman_test.h
 create mode 100644 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/wrappers/Peripherals/lnxwrp_fm_ext.h
 create mode 100644 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/modules/integrations/P4080/FM/Makefile
 create mode 100644 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/modules/integrations/P4080/FM/fmm.c
 create mode 100644 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/modules/integrations/P4080/FM/mod_config.h
 create mode 100644 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/system/Makefile
 create mode 100644 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/system/platform/P4080/Makefile
 create mode 100644 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/system/platform/P4080/platform_p4080_ds.c
 create mode 100644 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/system/sys_init.c
 create mode 100644 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/system/sys_io.c
 create mode 100644 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/util/Makefile
 create mode 100644 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/util/procbuff.c
 create mode 100644 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/util/procbuff.h
 create mode 100644 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/Makefile
 create mode 100644 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/fman_test.c
 create mode 100644 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/lnxwrp_fm.c
 create mode 100644 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/lnxwrp_fm.h
 create mode 100644 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/lnxwrp_fm_ioctls.c
 create mode 100644 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/xx/Makefile
 create mode 100644 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/xx/ctype.c
 create mode 100644 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/xx/integrations/Makefile
 create mode 100644 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/xx/integrations/P4080/Makefile
 create mode 100644 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/xx/integrations/P4080/xx_integration.c
 create mode 100644 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/xx/stdlib.c
 create mode 100644 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/xx/udivdi3.c
 create mode 100644 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/xx/xx.h
 create mode 100644 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/xx/xx_linux.c

diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/Makefile b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/Makefile
new file mode 100644
index 0000000..902fe6e
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/Makefile
@@ -0,0 +1,13 @@
+#
+# Makefile for the Freescale Ethernet controllers
+#
+EXTRA_CFLAGS           += -DVERSION=\"\"
+#
+#Include netcomm SW specific definitions
+include $(srctree)/drivers/net/dpa/NetCommSw/ncsw_config.mk
+#
+obj-y		+= modules/integrations/P4080/FM/
+obj-y		+= system/
+obj-y		+= util/
+obj-y		+= wrappers/Peripherals/FM/
+obj-y		+= xx/
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/Peripherals/fm_ioctls.h b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/Peripherals/fm_ioctls.h
new file mode 100644
index 0000000..95abf75
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/Peripherals/fm_ioctls.h
@@ -0,0 +1,293 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**************************************************************************//**
+ @File          fm_ioctls.h
+
+ @Description   FM Char device ioctls
+*//***************************************************************************/
+#ifndef __FM_IOCTLS_H
+#define __FM_IOCTLS_H
+
+
+/**************************************************************************//**
+ @Group         lnx_ioctl_FM_grp Frame Manager Linux IOCTL API
+
+ @Description   FM Linux ioctls definitions and enums
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Collection    FM IOCTL device ('/dev') definitions
+*//***************************************************************************/
+#define DEV_FM_NAME                 "fm" /**< Name of the FM chardev */
+
+#define DEV_FM_MINOR_BASE           0
+#define DEV_FM_PCD_MINOR_BASE       (DEV_FM_MINOR_BASE + 1)
+#define DEV_FM_HC_PORT_MINOR_BASE   (DEV_FM_PCD_MINOR_BASE + 1)
+#define DEV_FM_OP_PORTS_MINOR_BASE  (DEV_FM_HC_PORT_MINOR_BASE + 1)
+#define DEV_FM_RX_PORTS_MINOR_BASE  (DEV_FM_OP_PORTS_MINOR_BASE + 6)
+#define DEV_FM_TX_PORTS_MINOR_BASE  (DEV_FM_RX_PORTS_MINOR_BASE + 5)
+#define DEV_FM_MAX_MINORS           (DEV_FM_TX_PORTS_MINOR_BASE + 5)
+
+#define FM_IOC_NUM(n)       n
+#define FM_PCD_IOC_NUM(n)   (n+20)
+#define FM_PORT_IOC_NUM(n)  (n+50)
+/* @} */
+
+#define IOC_FM_MAX_NUM_OF_PORTS         64
+
+/**************************************************************************//**
+ @Collection   FM Frame error
+*//***************************************************************************/
+typedef uint32_t    ioc_fm_port_frame_err_select_t;                     /**< typedef for defining Frame Descriptor errors */
+
+#define IOC_FM_PORT_FRM_ERR_DMA                             0x01000000  /**< DMA Data error */
+#define IOC_FM_PORT_FRM_ERR_PHYSICAL                        0x00080000  /**< Rx FIFO overflow, FCS error, code error, running disparity
+                                                                             error (SGMII and TBI modes), FIFO parity error. PHY
+                                                                             Sequence error, PHY error control character detected. */
+#define IOC_FM_PORT_FRM_ERR_SIZE                            0x00040000  /**< Frame too long OR Frame size exceeds max_length_frame  */
+#define IOC_FM_PORT_FRM_ERR_CLS_DISCARD                     0x00020000  /**< classification discard */
+#define IOC_FM_PORT_FRM_ERR_EXTRACTION                      0x00008000  /**< Extract Out of Frame */
+#define IOC_FM_PORT_FRM_ERR_NO_SCHEME                       0x00004000  /**< No Scheme Selected */
+#define IOC_FM_PORT_FRM_ERR_KEYSIZE_OVERFLOW                0x00002000  /**< No Scheme Selected */
+#define IOC_FM_PORT_FRM_ERR_COLOR_YELLOW                    0x00000400
+#define IOC_FM_PORT_FRM_ERR_COLOR_RED                       0x00000800
+#define IOC_FM_PORT_FRM_ERR_ILL_PLCR                        0x00000200  /**< Illegal Policer Profile selected */
+#define IOC_FM_PORT_FRM_ERR_PLCR_FRAME_LEN                  0x00000100  /**< Illegal Policer Profile selected */
+#define IOC_FM_PORT_FRM_ERR_PRS_TIMEOUT                     0x00000080  /**< Parser Time out Exceed */
+#define IOC_FM_PORT_FRM_ERR_PRS_ILL_INSTRUCT                0x00000040  /**< Invalid Soft Parser instruction */
+#define IOC_FM_PORT_FRM_ERR_PRS_HDR_ERR                     0x00000020  /**< Header error was identified during parsing */
+#define IOC_FM_PORT_FRM_ERR_PROCESS_TIMEOUT                 0x00000001  /**< FPT Frame Processing Timeout Exceeded */
+#define IOC_FM_PORT_FRM_ERR_LENGTH                          0x02000000  /**< Offline parsing only! Length Error */
+#define IOC_FM_PORT_FRM_ERR_UNSUPPORTED_FORMAT              0x04000000  /**< Offline parsing only! Unsupported Format */
+/* @} */
+
+
+/**************************************************************************//**
+ @Description   enum for defining port types
+*//***************************************************************************/
+typedef enum ioc_fm_port_type {
+    e_IOC_FM_PORT_TYPE_OFFLINE_PARSING, /**< Offline parsing port (id's: 0-6, share id's with
+                                             host command, so must have exclusive id) */
+    e_IOC_FM_PORT_TYPE_HOST_COMMAND,    /**< Host command port (id's: 0-6, share id's with
+                                             offline parsing ports, so must have exclusive id) */
+    e_IOC_FM_PORT_TYPE_RX,              /**< 1G Rx port (id's: 0-3) */
+    e_IOC_FM_PORT_TYPE_RX_10G,          /**< 10G Rx port (id's: 0) */
+    e_IOC_FM_PORT_TYPE_TX,              /**< 1G Tx port (id's: 0-3) */
+    e_IOC_FM_PORT_TYPE_TX_10G,          /**< 10G Tx port (id's: 0) */
+    e_IOC_FM_PORT_TYPE_DUMMY
+} ioc_fm_port_type;
+
+
+/**************************************************************************//**
+ @Group         lnx_ioctl_FM_lib_grp FM library
+
+ @Description   FM API functions, definitions and enums
+                The FM module is the main driver module and is a mandatory module
+                for FM driver users. Before any further module initialization,
+                this module must be initialized.
+                The FM is a "single-tone" module. It is responsible of the common
+                HW modules: FPM, DMA, common QMI, common BMI initializations and
+                run-time control routines. This module must be initialized always
+                when working with any of the FM modules.
+                NOTE - We assumes that the FML will be initialize only by core No. 0!
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description   FM Exceptions
+*//***************************************************************************/
+typedef enum ioc_fm_exceptions {
+    e_IOC_FM_EX_DMA_BUS_ERROR,              /**< DMA bus error. */
+    e_IOC_FM_EX_DMA_READ_ECC,               /**< Read Buffer ECC error */
+    e_IOC_FM_EX_DMA_SYSTEM_WRITE_ECC,       /**< Write Buffer ECC error on system side */
+    e_IOC_FM_EX_DMA_FM_WRITE_ECC,           /**< Write Buffer ECC error on FM side */
+    e_IOC_FM_EX_FPM_STALL_ON_TASKS ,        /**< Stall of tasks on FPM */
+    e_IOC_FM_EX_FPM_SINGLE_ECC,             /**< Single ECC on FPM. */
+    e_IOC_FM_EX_FPM_DOUBLE_ECC,             /**< Double ECC error on FPM ram access */
+    e_IOC_FM_EX_QMI_SINGLE_ECC,             /**< Single ECC on QMI. */
+    e_IOC_FM_EX_QMI_DOUBLE_ECC,             /**< Double bit ECC occured on QMI */
+    e_IOC_FM_EX_QMI_DEQ_FROM_DEFQ,          /**< Dequeu from default queue id, as a result
+                                                 of invalid port id. */
+    e_IOC_FM_EX_BMI_LIST_RAM_ECC,           /**< Linked List RAM ECC error */
+    e_IOC_FM_EX_BMI_PIPELINE_ECC,           /**< Pipeline Table ECC Error */
+    e_IOC_FM_EX_BMI_STATISTICS_RAM_ECC,     /**< Statistics Count RAM ECC Error Enable */
+    e_IOC_FM_EX_IRAM_ECC,                   /**< Double bit ECC occured on IRAM*/
+    e_IOC_FM_EX_MURAM_ECC                   /**< Double bit ECC occured on MURAM*/
+} ioc_fm_exceptions;
+
+
+/**************************************************************************//**
+ @Group         lnx_ioctl_FM_runtime_control_grp FM Runtime Control Unit
+
+ @Description   FM Runtime control unit API functions, definitions and enums.
+                The FM driver provides a set of control routines for each module.
+                These routines may only be called after the module was fully
+                initialized (both configuration and initialization routines were
+                called). They are typically used to get information from hardware
+                (status, counters/statistics, revision etc.), to modify a current
+                state or to force/enable a required action. Run-time control may
+                be called whenever necessary and as many times as needed.
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Collection   General FM defines.
+*//***************************************************************************/
+#define IOC_FM_NUM_OF_PORT_TYPES            e_IOC_FM_PORT_TYPE_DUMMY
+#define IOC_FM_MAX_NUM_OF_PORTS_PER_TYPE    7
+/* @} */
+
+/**************************************************************************//**
+ @Description   Port id by type and relative id
+*//***************************************************************************/
+typedef uint8_t ioc_ports_param_t[IOC_FM_NUM_OF_PORT_TYPES][IOC_FM_MAX_NUM_OF_PORTS_PER_TYPE];
+
+/**************************************************************************//**
+ @Description   enum for defining FM counters
+*//***************************************************************************/
+typedef enum ioc_fm_counters {
+    e_IOC_FM_COUNTERS_ENQ_TOTAL_FRAME,              /**< QMI total enqueued frames counter */
+    e_IOC_FM_COUNTERS_DEQ_TOTAL_FRAME,              /**< QMI total dequeued frames counter */
+    e_IOC_FM_COUNTERS_DEQ_0,                        /**< QMI 0 frames from QMan counter */
+    e_IOC_FM_COUNTERS_DEQ_1,                        /**< QMI 1 frames from QMan counter */
+    e_IOC_FM_COUNTERS_DEQ_2,                        /**< QMI 2 frames from QMan counter */
+    e_IOC_FM_COUNTERS_DEQ_3,                        /**< QMI 3 frames from QMan counter */
+    e_IOC_FM_COUNTERS_DEQ_FROM_DEFAULT,             /**< QMI dequeue from default queue counter */
+    e_IOC_FM_COUNTERS_DEQ_FROM_CONTEXT,             /**< QMI dequeue from FQ context counter */
+    e_IOC_FM_COUNTERS_DEQ_FROM_FD,                  /**< QMI dequeue from FD command field counter */
+    e_IOC_FM_COUNTERS_DEQ_CONFIRM,                  /**< QMI dequeue confirm counter */
+    e_IOC_FM_COUNTERS_SEMAPHOR_ENTRY_FULL_REJECT,   /**< DMA semaphor reject due to full entry counter */
+    e_IOC_FM_COUNTERS_SEMAPHOR_QUEUE_FULL_REJECT,   /**< DMA semaphor reject due to full CAM queue counter */
+    e_IOC_FM_COUNTERS_SEMAPHOR_SYNC_REJECT          /**< DMA semaphor reject due to sync counter */
+} ioc_fm_counters;
+
+typedef struct ioc_fm_obj_t {
+    void            *obj;
+} ioc_fm_obj_t;
+
+/**************************************************************************//**
+ @Description   structure for returning revision information
+*//***************************************************************************/
+typedef struct ioc_fm_revision_info_t {
+    uint8_t         major;               /**< Major revision */
+    uint8_t         minor;               /**< Minor revision */
+} ioc_fm_revision_info_t;
+
+/**************************************************************************//**
+ @Description   structure for FM counters
+*//***************************************************************************/
+typedef struct ioc_fm_counters_params_t {
+    ioc_fm_counters cnt;                /**< The requested counter */
+    uint32_t        val;                /**< The requested value to get/set from/into the counter */
+} ioc_fm_counters_params_t;
+
+
+/**************************************************************************//**
+ @Function      FM_IOC_SET_PORTS_BANDWIDTH
+
+ @Description   Sets relative weights between ports when accessing common resources.
+
+ @Param[in]     ioc_ports_param_t   A table of ports bandwidth in percentage, i.e.
+                                    total must equal 100.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Init().
+*//***************************************************************************/
+#define FM_IOC_SET_PORTS_BANDWIDTH                             _IOW(FM_IOC_TYPE_BASE, FM_IOC_NUM(2), ioc_ports_param_t)
+
+/**************************************************************************//**
+ @Function      FM_IOC_GET_REVISION
+
+ @Description   Returns the FM revision
+
+ @Param[out]    ioc_fm_revision_info_t  A structure of revision information parameters.
+
+ @Return        None.
+
+ @Cautions      Allowed only following FM_Init().
+*//***************************************************************************/
+#define FM_IOC_GET_REVISION                                    _IOR(FM_IOC_TYPE_BASE, FM_IOC_NUM(3), ioc_fm_revision_info_t)
+
+/**************************************************************************//**
+ @Function      FM_IOC_GET_COUNTER
+
+ @Description   Reads one of the FM counters.
+
+ @Param[in,out] ioc_fm_counters_params_t The requested counter parameters.
+
+ @Return        Counter's current value.
+
+ @Cautions      Allowed only following FM_Init().
+                Note that it is user's responsibilty to call this routine only
+                for enabled counters, and there will be no indication if a
+                disabled counter is accessed.
+*//***************************************************************************/
+#define FM_IOC_GET_COUNTER                                    _IOWR(FM_IOC_TYPE_BASE, FM_IOC_NUM(4), ioc_fm_counters_params_t)
+
+/**************************************************************************//**
+ @Function      FM_IOC_SET_COUNTER
+
+ @Description   Sets a value to an enabled counter. Use "0" to reset the counter.
+
+ @Param[in]     ioc_fm_counters_params_t The requested counter parameters.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Init().
+*//***************************************************************************/
+#define FM_IOC_SET_COUNTER                                    _IOW(FM_IOC_TYPE_BASE, FM_IOC_NUM(5), ioc_fm_counters_params_t)
+
+/**************************************************************************//**
+ @Function      FM_IOC_FORCE_INTR
+
+ @Description   Causes an interrupt event on the requested source.
+
+ @Param[in]     ioc_fm_exceptions   An exception to be forced.
+
+ @Return        E_OK on success; Error code if the exception is not enabled,
+                or is not able to create interrupt.
+
+ @Cautions      Allowed only following FM_Init().
+*//***************************************************************************/
+#define FM_IOC_FORCE_INTR                                    _IOW(FM_IOC_TYPE_BASE, FM_IOC_NUM(6), ioc_fm_exceptions)
+
+/** @} */ /* end of lnx_ioctl_FM_runtime_control_grp group */
+/** @} */ /* end of lnx_ioctl_FM_lib_grp group */
+/** @} */ /* end of lnx_ioctl_FM_grp */
+
+
+#endif /* __FM_IOCTLS_H */
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/Peripherals/fm_pcd_ioctls.h b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/Peripherals/fm_pcd_ioctls.h
new file mode 100644
index 0000000..170a2fa
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/Peripherals/fm_pcd_ioctls.h
@@ -0,0 +1,1498 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/******************************************************************************
+ @File          fm_pcd_ioctls.h
+
+ @Description   FM PCD ...
+*//***************************************************************************/
+#ifndef __FM_PCD_IOCTLS_H
+#define __FM_PCD_IOCTLS_H
+
+#include "net_ioctls.h"
+#include "fm_ioctls.h"
+
+
+/**************************************************************************//**
+ @Group         lnx_ioctl_FM_grp Frame Manager Linux IOCTL API
+
+ @Description   FM Linux ioctls definitions and enums
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Group         lnx_ioctl_FM_PCD_grp FM PCD
+
+ @Description   FM PCD API functions, definitions and enums
+
+                The FM PCD module is responsible for the initialization of all
+                global classifying FM modules. This includes the parser general and
+                common registers, the key generator global and common registers,
+                and the Policer global and common registers.
+                In addition, the FM PCD SW module will initialize all required
+                key generator schemes, coarse classification flows, and Policer
+                profiles. When An FM module is configured to work with one of these
+                entities, it will register to it using the FM PORT API. The PCD
+                module will manage the PCD resources - i.e. resource management of
+                Keygen schemes, etc.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Collection    General PCD defines
+*//***************************************************************************/
+#define IOC_FM_PCD_MAX_NUM_OF_PRIVATE_HDRS              3                   /**< Number of units/headers saved for user */
+
+#define IOC_FM_PCD_PRS_NUM_OF_HDRS                      16                  /**< Number of headers supported by HW parser */
+#define IOC_FM_PCD_KG_NUM_OF_SCHEMES                    32                  /**< Total number of KG schemes */
+#define IOC_FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS         (32 - IOC_FM_PCD_MAX_NUM_OF_PRIVATE_HDRS)
+                                                                            /**< Maximum number of netenv distinction units */
+#define IOC_FM_PCD_MAX_NUM_OF_OPTIONS                   8                   /**< Maximum number of netenv distinction units options */
+#define IOC_FM_PCD_MAX_NUM_OF_INTERCHANGABLE_HDRS       4                   /**< Maximum number of interchangable headers in a distinction unit */
+#define IOC_FM_PCD_KG_NUM_OF_GENERIC_REGS               8                   /**< Total number of generic KG registers */
+#define IOC_FM_PCD_KG_MAX_NUM_OF_EXTRACTS_PER_KEY       35                  /**< Max number allowed on any configuration.
+                                                                                 For reason of HW implemetation, in most
+                                                                                 cases less than this will be allowed. The
+                                                                                 driver will return error in initialization
+                                                                                 time if resource is overused. */
+#define IOC_FM_PCD_MAX_NUM_OF_CLS_PLANS                 256                 /**< Number of classification plan entries. */
+#define IOC_FM_PCD_KG_NUM_OF_EXTRACT_MASKS              4                   /**< Total number of masks allowed on KG extractions. */
+#define IOC_FM_PCD_KG_NUM_OF_DEFAULT_GROUPS             16                  /**< Number of default value logical groups */
+
+#define IOC_FM_PCD_PRS_NUM_OF_LABELS                    32                  /**< Max number of SW parser label */
+/* @} */
+
+/**************************************************************************//**
+ @Group         lnx_ioctl_FM_PCD_Runtime_grp FM PCD Runtime Unit
+
+ @Description   FM PCD Runtime Unit
+
+                The runtime control allows creation of PCD infrastructure modules
+                such as Network Environment Characteristics, Classification Plan
+                Groups and Coarse Classification Trees.
+                It also allows on-the-fly initialization, modification and removal
+                of PCD modules such as Keygen schemes, coarse classification nodes
+                and Policer profiles.
+
+
+                In order to explain the programming model of the PCD driver interface
+                a few terms should be explained, and will be used below.
+                  * Distinction Header - One of the 16 protocols supported by the FM parser,
+                    or one of the shim headers (1-3). May be a header with a special
+                    option (see below).
+                  * Interchangeable Headers Group- This is a group of Headers recognized
+                    by either one of them. For example, if in a specific context the user
+                    chooses to treat IPv4 and IPV6 in the same way, they may create an
+                    Interchangable Headers Unit consisting of these 2 headers.
+                  * A Distinction Unit - a Distinction Header or an Interchangeable Headers
+                    Group.
+                  * Header with special option - applies to ethernet, mpls, vlan, ipv4 and
+                    ipv6, includes multicast, broadcast and other protocol specific options.
+                    In terms of hardware it relates to the options available in the classification
+                    plan.
+                  * Network Environment Characteristics - a set of Distinction Units that define
+                    the total recognizable header selection for a certain environment. This is
+                    NOT the list of all headers that will ever appear in a flow, but rather
+                    everything that needs distinction in a flow, where distinction is made by keygen
+                    schemes and coarse classification action descriptors.
+
+                The PCD runtime modules initialization is done in stages. The first stage after
+                initializing the PCD module itself is to establish a Network Flows Environment
+                Definition. The application may choose to establish one or more such environments.
+                Later, when needed, the application will have to state, for some of its modules,
+                to which single environment it belongs.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description   PCD counters
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_counters {
+    e_IOC_FM_PCD_KG_COUNTERS_TOTAL,                                 /**< Policer counter */
+    e_IOC_FM_PCD_PLCR_COUNTERS_YELLOW,                              /**< Policer counter */
+    e_IOC_FM_PCD_PLCR_COUNTERS_RED,                                 /**< Policer counter */
+    e_IOC_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_RED,                    /**< Policer counter */
+    e_IOC_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_YELLOW,                 /**< Policer counter */
+    e_IOC_FM_PCD_PLCR_COUNTERS_TOTAL,                               /**< Policer counter */
+    e_IOC_FM_PCD_PLCR_COUNTERS_LENGTH_MISMATCH,                     /**< Policer counter */
+    e_IOC_FM_PCD_PRS_COUNTERS_PARSE_DISPATCH,                       /**< Parser counter */
+    e_IOC_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED,             /**< Parser counter */
+    e_IOC_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED,             /**< Parser counter */
+    e_IOC_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED,             /**< Parser counter */
+    e_IOC_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED,           /**< Parser counter */
+    e_IOC_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED_WITH_ERR,    /**< Parser counter */
+    e_IOC_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED_WITH_ERR,    /**< Parser counter */
+    e_IOC_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED_WITH_ERR,    /**< Parser counter */
+    e_IOC_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED_WITH_ERR,  /**< Parser counter */
+    e_IOC_FM_PCD_PRS_COUNTERS_SOFT_PRS_CYCLES,                      /**< Parser counter */
+    e_IOC_FM_PCD_PRS_COUNTERS_SOFT_PRS_STALL_CYCLES,                /**< Parser counter */
+    e_IOC_FM_PCD_PRS_COUNTERS_HARD_PRS_CYCLE_INCL_STALL_CYCLES,     /**< Parser counter */
+    e_IOC_FM_PCD_PRS_COUNTERS_MURAM_READ_CYCLES,                    /**< MURAM counter */
+    e_IOC_FM_PCD_PRS_COUNTERS_MURAM_READ_STALL_CYCLES,              /**< MURAM counter */
+    e_IOC_FM_PCD_PRS_COUNTERS_MURAM_WRITE_CYCLES,                   /**< MURAM counter */
+    e_IOC_FM_PCD_PRS_COUNTERS_MURAM_WRITE_STALL_CYCLES,             /**< MURAM counter */
+    e_IOC_FM_PCD_PRS_COUNTERS_FPM_COMMAND_STALL_CYCLES              /**< FPM counter */
+} ioc_fm_pcd_counters;
+
+/**************************************************************************//**
+ @Description   PCD interrupts
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_exceptions {
+    e_IOC_FM_PCD_KG_ERR_EXCEPTION_DOUBLE_ECC,                   /**< Keygen ECC error */
+    e_IOC_FM_PCD_PLCR_ERR_EXCEPTION_DOUBLE_ECC,                 /**< Read Buffer ECC error */
+    e_IOC_FM_PCD_KG_ERR_EXCEPTION_KEYSIZE_OVERFLOW,             /**< Write Buffer ECC error on system side */
+    e_IOC_FM_PCD_PLCR_ERR_EXCEPTION_INIT_ENTRY_ERROR,           /**< Write Buffer ECC error on FM side */
+    e_IOC_FM_PCD_PLCR_EXCEPTION_PRAM_SELF_INIT_COMPLETE,        /**< Self init complete */
+    e_IOC_FM_PCD_PLCR_EXCEPTION_ATOMIC_ACTION_COMPLETE,         /**< Atomic action complete */
+    e_IOC_FM_PCD_PRS_EXCEPTION_DOUBLE_ECC,                      /**< Parser ECC error */
+    e_IOC_FM_PCD_PRS_EXCEPTION_SINGLE_ECC,                      /**< Parser single ECC */
+    e_IOC_FM_PCD_PRS_EXCEPTION_ILLEGAL_ACCESS,                  /**< Parser illegal access */
+    e_IOC_FM_PCD_PRS_EXCEPTION_PORT_ILLEGAL_ACCESS              /**< Parser port illegal access */
+} ioc_fm_pcd_exceptions;
+
+/**************************************************************************//**
+ @Description   structure for FM counters
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_counters_params_t {
+    ioc_fm_pcd_counters cnt;                /**< The requested counter */
+    uint32_t            val;                /**< The requested value to get/set from/into the counter */
+} ioc_fm_pcd_counters_params_t;
+
+/**************************************************************************//**
+ @Description   structure for FM exception definitios
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_exception_params_t {
+    ioc_fm_pcd_exceptions exception;        /**< The requested exception */
+    bool                  enable;           /**< TRUE to enable interrupt, FALSE to mask it. */
+} ioc_fm_pcd_exception_params_t;
+
+/**************************************************************************//**
+ @Description   A structure for sw parser labels
+ *//***************************************************************************/
+typedef struct ioc_fm_pcd_prs_label_params_t {
+    uint32_t                instruction_offset;             /**< SW parser label instruction offset (2 bytes
+                                                                 resolution), relative to Parser RAM. */
+    ioc_net_header_type     hdr;                            /**< The existance of this header will envoke
+                                                                 the sw parser code. */
+    uint8_t                 index_per_hdr;                  /**< Normally 0, if more than one sw parser
+                                                                 attachments for the same header, use this
+                                                                 index to distinguish between them. */
+} ioc_fm_pcd_prs_label_params_t;
+
+/**************************************************************************//**
+ @Description   A structure for sw parser
+ *//***************************************************************************/
+typedef struct ioc_fm_pcd_prs_sw_params_t {
+    bool                            override;           /**< FALSE to invoke a check that nothing else
+                                                             was loaded to this address, including
+                                                             internal patched.
+                                                             TRUE to override any existing code.*/
+    uint32_t                        size;               /**< SW parser code size */
+    uint16_t                        base;               /**< SW parser base (in instruction counts!
+                                                             muat be larger than 0x20)*/
+    uint8_t                         *p_code;            /**< SW parser code */
+    uint32_t                        sw_prs_data_params[IOC_FM_PCD_PRS_NUM_OF_HDRS];
+                                                        /**< SW parser data (parameters) */
+    uint8_t                         num_of_labels;      /**< Number of labels for SW parser. */
+    ioc_fm_pcd_prs_label_params_t   labels_table[IOC_FM_PCD_PRS_NUM_OF_LABELS];
+                                                        /**< SW parser labels table, containing n
+                                                             umOfLabels entries */
+} ioc_fm_pcd_prs_sw_params_t;
+
+typedef struct ioc_fm_pcd_kg_dflt_value_params_t {
+    uint8_t                         valueId;                /**< 0,1 - one of 2 global default values */
+    uint32_t                        value;                  /**< The requested default value */
+} ioc_fm_pcd_kg_dflt_value_params_t;
+
+
+/**************************************************************************//**
+ @Function      FM_PCD_IOC_ENABLE
+
+ @Description   This routine should be called after PCD is initialized for enabling all
+                PCD engines according to their existing configuration.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following PCD_Init() and when PCD is disabled.
+*//***************************************************************************/
+#define FM_PCD_IOC_ENABLE  _IO(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(1))
+
+/**************************************************************************//**
+ @Function      FM_PCD_IOC_DISABLE
+
+ @Description   This routine may be called when PCD is enabled in order to
+                disable all PCD engines. It may be called
+                only when none of the ports in the system are using the PCD.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following PCD_Init() and when PCD is enabled.
+*//***************************************************************************/
+#define FM_PCD_IOC_DISABLE  _IO(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(2))
+
+ /**************************************************************************//**
+ @Function      FM_PCD_IOC_PRS_LOAD_SW
+
+ @Description   This routine may be called only when all ports in the
+                system are actively using the classification plan scheme.
+                In such cases it is recommended in order to save resources.
+                The driver automatically saves 8 classification plans for
+                ports that do NOT use the classification plan mechanism, to
+                avoid this (in order to save those entries) this routine may
+                be called.
+
+ @Param[in]     ioc_fm_pcd_prs_sw_params_t  A pointer to the image of the software parser code.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following PCD_Init() and when PCD is disabled.
+*//***************************************************************************/
+#define FM_PCD_IOC_PRS_LOAD_SW  _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(3), ioc_fm_pcd_prs_sw_params_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_IOC_KG_SET_EMPTY_CLS_PLAN_GRP
+
+ @Description   This routine may always be called, and MUST be called when
+                not all ports in the partition are actively using the classification
+                plan mechanism.
+                When called, the driver automatically saves 8 classification
+                plans for ports that do NOT use the classification plan mechanism, to
+                avoid this (in order to save those entries) this routine may
+                be ommited when all ports are using the classification
+                plan machanism.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following PCD_Init().
+ *//***************************************************************************/
+#define FM_PCD_IOC_KG_SET_EMPTY_CLS_PLAN_GRP  _IO(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(4))
+
+/**************************************************************************//**
+ @Function      FM_PCD_IOC_KG_DELETE_EMPTY_CLS_PLAN_GRP
+
+ @Description   This routine may be called only when all ports in the
+                system are actively using the classification plan scheme.
+                In such cases, if empty clsPlan was already set,
+                it is recommended in order to save resources.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following PCD_Init().
+                Note that this routine may not be called if any of the FM ports
+                is not using the classification plan mechanism.
+*//***************************************************************************/
+#define FM_PCD_IOC_KG_DELETE_EMPTY_CLS_PLAN_GRP  _IO(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(5))
+
+/**************************************************************************//**
+ @Function      FM_PCD_IOC_KG_SET_DFLT_VALUE
+
+ @Description   Calling this routine sets a global default value to be used
+                by the keygen when parser does not recognize a required
+                field/header.
+                By default default values are 0.
+
+ @Param[in]     ioc_fm_pcd_kg_dflt_value_params_t   TBD
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following PCD_Init() and when PCD is disabled.
+*//***************************************************************************/
+#define FM_PCD_IOC_KG_SET_DFLT_VALUE  _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(6), ioc_fm_pcd_kg_dflt_value_params_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_IOC_KG_SET_ADDITIONAL_DATA_AFTER_PARSING
+
+ @Description   Calling this routine allows the keygen to access data past
+                the parser finidhing point.
+
+ @Param[in]     uint8_t   payload-offset; the number of bytes beyond the parser location.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following PCD_Init() and when PCD is disabled.
+
+*//***************************************************************************/
+#define FM_PCD_IOC_KG_SET_ADDITIONAL_DATA_AFTER_PARSING  _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(7), uint8_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_IOC_SET_EXCEPTION
+
+ @Description   Calling this routine enables/disables PCD interrupts.
+
+ @Param[in]     h_FmPcd         FM PCD module descriptor.
+ @Param[in]     ioc_fm_pcd_exception_params_t     The exception to be selected.
+ @Param[in]     enable          TRUE to enable interrupt, FALSE to mask it.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following PCD_Init().
+*//***************************************************************************/
+#define FM_PCD_IOC_SET_EXCEPTION _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(8), ioc_fm_pcd_exception_params_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_IOC_GET_COUNTER
+
+ @Description   Reads one of the FM PCD counters.
+
+ @Param[in,out] ioc_fm_pcd_counters_params_t The requested counter parameters.
+
+ @Return        Counter's current value.
+
+ @Cautions      Allowed only following FM_PCD_Init().
+                Note that it is user's responsibilty to call this routine only
+                for enabled counters, and there will be no indication if a
+                disabled counter is accessed.
+*//***************************************************************************/
+#define FM_PCD_IOC_GET_COUNTER  _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(9), ioc_fm_pcd_counters_params_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_IOC_SET_COUNTER
+
+ @Description   Sets a value to an enabled counter. Use "0" to reset the counter.
+
+ @Param[in]     ioc_fm_pcd_counters_params_t The requested counter parameters.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following PCD_Init().
+*//***************************************************************************/
+#define FM_PCD_IOC_SET_COUNTER  _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(10), ioc_fm_pcd_counters_params_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_IOC_FORCE_INTR
+
+ @Description   Causes an interrupt event on the requested source.
+
+ @Param[in]     ioc_fm_pcd_exceptions    An exception to be forced.
+
+ @Return        E_OK on success; Error code if the exception is not enabled,
+                or is not able to create interrupt.
+
+ @Cautions      Allowed only following PCD_Init().
+*//***************************************************************************/
+#define FM_PCD_IOC_FORCE_INTR _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(11), ioc_fm_pcd_exceptions)
+
+/**************************************************************************//**
+ @Collection    Definitions of coarse classification
+                parameters as required by keygen (when coarse classification
+                is the next engine after this scheme).
+*//***************************************************************************/
+#define IOC_FM_PCD_MAX_NUM_OF_PCD_CC_NODES     255
+#define IOC_FM_PCD_MAX_NUM_OF_PCD_CC_TREES     8
+#define IOC_FM_PCD_MAX_NUM_OF_PCD_CC_GROUP     16
+#define IOC_FM_PCD_MAX_NUM_OF_CC_UNITS         4
+#define IOC_FM_PCD_MAX_NUM_OF_KEYS             256
+#define IOC_FM_PCD_MAX_SIZE_OF_KEY             56
+/* @} */
+
+/**************************************************************************//**
+ @Collection    A set of definitions to allow protocol
+                special option description.
+*//***************************************************************************/
+typedef uint32_t            ioc_protocol_opt_t;      /**< A general type to define a protocol option. */
+
+typedef ioc_protocol_opt_t  ioc_eth_protocol_opt_t;  /**< Ethernet protocol options. */
+#define IOC_ETH_BROADCAST               0x80000000   /**< Ethernet Broadcast. */
+#define IOC_ETH_MULTICAST               0x40000000   /**< Ethernet Multicast. */
+
+typedef ioc_protocol_opt_t  ioc_vlan_protocol_opt_t; /**< Vlan protocol options. */
+#define IOC_VLAN_STACKED                0x20000000   /**< Vlan Stacked. */
+
+typedef ioc_protocol_opt_t  ioc_mpls_protocol_opt_t; /**< MPLS protocol options. */
+#define IOC_MPLS_STACKED                0x10000000   /**< MPLS Stacked. */
+
+typedef ioc_protocol_opt_t  ioc_ipv4_protocol_opt_t; /**< IPv4 protocol options. */
+#define IOC_IPV4_BROADCAST_1            0x08000000   /**< IPv4 Broadcast. */
+#define IOC_IPV4_MULTICAST_1            0x04000000   /**< IPv4 Multicast. */
+#define IOC_IPV4_UNICAST_2              0x02000000   /**< Tunneled IPv4 - Unicast. */
+#define IOC_IPV4_MULTICAST_BROADCAST_2  0x01000000   /**< Tunneled IPv4 - Broadcast/Multicast. */
+
+typedef ioc_protocol_opt_t  ioc_ipv6_protocol_opt_t; /**< IPv6 protocol options. */
+#define IOC_IPV6_MULTICAST_1            0x00800000   /**< IPv6 Multicast. */
+#define IOC_IPV6_UNICAST_2              0x00400000   /**< Tunneled IPv6 - Unicast. */
+#define IOC_IPV6_MULTICAST_2            0x00200000   /**< Tunneled IPv6 - Multicast. */
+/* @} */
+
+/**************************************************************************//**
+ @Description   All PCD engines
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_engine {
+    e_IOC_FM_PCD_DONE,      /**< No PCD Engine indicated */
+    e_IOC_FM_PCD_KG,        /**< Parser indicated */
+    e_IOC_FM_PCD_CC,        /**< Keygen indicated */
+    e_IOC_FM_PCD_PLCR,      /**< Coarse classification indicated */
+    e_IOC_FM_PCD_PRS        /**< Policer indicated */
+} ioc_fm_pcd_engine;
+
+/**************************************************************************//**
+ @Description   An enum for selecting extraction by header types
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_extract_by_hdr_type {
+    e_IOC_FM_PCD_EXTRACT_FROM_HDR,      /**< Extract bytes from header */
+    e_IOC_FM_PCD_EXTRACT_FROM_FIELD,    /**< Extract bytes from header field */
+    e_IOC_FM_PCD_EXTRACT_FULL_FIELD     /**< Extract a full field */
+} ioc_fm_pcd_extract_by_hdr_type;
+
+/**************************************************************************//**
+ @Description   An enum for selecting extraction source
+                (when it is not the header)
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_extract_from {
+    e_IOC_FM_PCD_EXTRACT_FROM_FRAME_START,          /**< Extract from beginning of frame */
+    e_IOC_FM_PCD_KG_EXTRACT_FROM_DFLT_VALUE,        /**< Extract from a default value */
+    e_IOC_FM_PCD_KG_EXTRACT_FROM_PARSE_RESULT,      /**< Extract from the parser result */
+    e_IOC_FM_PCD_KG_EXTRACT_FROM_CURR_END_OF_PARSE  /**< Extract from the point where parsing had finished */
+} ioc_fm_pcd_extract_from;
+
+/**************************************************************************//**
+ @Description   An enum for selecting extraction type
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_extract_type {
+    e_IOC_FM_PCD_EXTRACT_BY_HDR,                /**< Extract according to header */
+    e_IOC_FM_PCD_EXTRACT_NON_HDR,               /**< Extract from data that is not the header */
+    e_IOC_FM_PCD_KG_EXTRACT_PORT_PRIVATE_INFO   /**< Extract private info as specified by user */
+} ioc_fm_pcd_extract_type;
+
+/**************************************************************************//**
+ @Description   An enum for selecting a default
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_kg_extract_dflt_select {
+    e_IOC_FM_PCD_KG_DFLT_GBL_0,          /**< Default selection is KG register 0 */
+    e_IOC_FM_PCD_KG_DFLT_GBL_1,          /**< Default selection is KG register 1 */
+    e_IOC_FM_PCD_KG_DFLT_PRIVATE_0,      /**< Default selection is a per scheme register 0 */
+    e_IOC_FM_PCD_KG_DFLT_PRIVATE_1,      /**< Default selection is a per scheme register 1 */
+    e_IOC_FM_PCD_KG_DFLT_ILLEGAL         /**< Illegal selection */
+} ioc_fm_pcd_kg_extract_dflt_select;
+
+/**************************************************************************//**
+ @Description   An enum defining all default groups -
+                each group shares a default value, one of 4 user
+                initialized values.
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_kg_known_fields_dflt_types {
+    e_IOC_FM_PCD_KG_MAC_ADDR,               /**< MAC Address */
+    e_IOC_FM_PCD_KG_TCI,                    /**< TCI field */
+    e_IOC_FM_PCD_KG_ENET_TYPE,              /**< ENET Type */
+    e_IOC_FM_PCD_KG_PPP_SESSION_ID,         /**< PPP Session id */
+    e_IOC_FM_PCD_KG_PPP_PROTOCOL_ID,        /**< PPP Protocol id */
+    e_IOC_FM_PCD_KG_MPLS_LABEL,             /**< MPLS label */
+    e_IOC_FM_PCD_KG_IP_ADDR,                /**< IP addr */
+    e_IOC_FM_PCD_KG_PROTOCOL_TYPE,          /**< Protocol type */
+    e_IOC_FM_PCD_KG_IP_TOS_TC,              /**< TOS or TC */
+    e_IOC_FM_PCD_KG_IPV6_FLOW_LABEL,        /**< IPV6 flow label */
+    e_IOC_FM_PCD_KG_IPSEC_SPI,              /**< IPSEC SPI */
+    e_IOC_FM_PCD_KG_L4_PORT,                /**< L4 Port */
+    e_IOC_FM_PCD_KG_TCP_FLAG,               /**< TCP Flag */
+    e_IOC_FM_PCD_KG_GENERIC_FROM_DATA,      /**< grouping implemented by sw,
+                                                 any data extraction that is not the full
+                                                 field described above  */
+    e_IOC_FM_PCD_KG_GENERIC_FROM_DATA_NO_V, /**< grouping implemented by sw,
+                                                 any data extraction without validation */
+    e_IOC_FM_PCD_KG_GENERIC_NOT_FROM_DATA   /**< grouping implemented by sw,
+                                                 extraction from parser result or
+                                                 direct use of default value  */
+} ioc_fm_pcd_kg_known_fields_dflt_types;
+
+/**************************************************************************//**
+ @Description   enum for defining header index when headers may repeat
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_hdr_index {
+    e_IOC_FM_PCD_HDR_INDEX_NONE     =   0,      /**< used when multiple headers not used, also
+                                                     to specify regular IP (not tunneled). */
+    e_IOC_FM_PCD_HDR_INDEX_1,                   /**< may be used for VLAN, MPLS, tunneled IP */
+    e_IOC_FM_PCD_HDR_INDEX_2,                   /**< may be used for MPLS, tunneled IP */
+    e_IOC_FM_PCD_HDR_INDEX_3,                   /**< may be used for MPLS */
+    e_IOC_FM_PCD_HDR_INDEX_LAST     =   0xFF    /**< may be used for VLAN, MPLS */
+} ioc_fm_pcd_hdr_index;
+
+/**************************************************************************//**
+ @Description   A structure for selcting the policer profile functional type
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_profile_type_selection {
+    e_IOC_FM_PCD_PLCR_PORT_PRIVATE,             /**< Port dedicated profile */
+    e_IOC_FM_PCD_PLCR_SHARED                    /**< Shared profile (shared within partition) */
+} ioc_fm_pcd_profile_type_selection;
+
+/**************************************************************************//**
+ @Description   A structure for selcting the policer profile algorithem
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_plcr_algorithm_selection {
+    e_IOC_FM_PCD_PLCR_PASS_THROUGH, /**< Policer pass through */
+    e_IOC_FM_PCD_PLCR_RFC_2698,     /**< Policer algorythm RFC 2698 */
+    e_IOC_FM_PCD_PLCR_RFC_4115      /**< Policer algorythm RFC 4115 */
+} ioc_fm_pcd_plcr_algorithm_selection;
+
+/**************************************************************************//**
+ @Description   A structure for selcting the policer profile color mode
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_plcr_color_mode {
+    e_IOC_FM_PCD_PLCR_COLOR_BLIND,  /**< Color blind */
+    e_IOC_FM_PCD_PLCR_COLOR_AWARE   /**< Color aware */
+} ioc_fm_pcd_plcr_color_mode;
+
+/**************************************************************************//**
+ @Description   A structure for selcting the policer profile color functional mode
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_plcr_color {
+    e_IOC_FM_PCD_PLCR_GREEN,    /**< Green */
+    e_IOC_FM_PCD_PLCR_YELLOW,   /**< Yellow */
+    e_IOC_FM_PCD_PLCR_RED,      /**< Red */
+    e_IOC_FM_PCD_PLCR_OVERRIDE  /**< Color override */
+} ioc_fm_pcd_plcr_color;
+
+/**************************************************************************//**
+ @Description   A structure for selcting the policer profile packet frame length selector
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_plcr_frame_length_select {
+  e_IOC_FM_PCD_PLCR_L2_FRM_LEN,     /**< L2 frame length */
+  e_IOC_FM_PCD_PLCR_L3_FRM_LEN,     /**< L3 frame length */
+  e_IOC_FM_PCD_PLCR_L4_FRM_LEN,     /**< L4 frame length */
+  e_IOC_FM_PCD_PLCR_FULL_FRM_LEN    /**< Full frame length */
+} ioc_fm_pcd_plcr_frame_length_select;
+
+/**************************************************************************//**
+ @Description   An enum for selecting rollback frame
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_plcr_roll_back_frame_select {
+  e_IOC_FM_PCD_PLCR_ROLLBACK_L2_FRM_LEN,    /**< Rollback L2 frame length */
+  e_IOC_FM_PCD_PLCR_ROLLBACK_FULL_FRM_LEN   /**< Rollback Full frame length */
+} ioc_fm_pcd_plcr_roll_back_frame_select;
+
+/**************************************************************************//**
+ @Description   A structure for selcting the policer profile packet or byte mode
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_plcr_rate_mode {
+    e_IOC_FM_PCD_PLCR_BYTE_MODE,    /**< Byte mode */
+    e_IOC_FM_PCD_PLCR_PACKET_MODE   /**< Packet mode */
+} ioc_fm_pcd_plcr_rate_mode;
+
+/**************************************************************************//**
+ @Description   An enum for defining action of frame
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_plcr_done_action {
+    e_IOC_FM_PCD_PLCR_ENQ_FRAME,    /**< Enqueue frame */
+    e_IOC_FM_PCD_PLCR_DROP_FRAME    /**< Drop frame */
+} ioc_fm_pcd_plcr_done_action;
+
+/**************************************************************************//**
+ @Description   A structure for selcting the policer counter
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_plcr_profile_counters {
+    e_IOC_FM_PCD_PLCR_PROFILE_GREEN_PACKET_TOTAL_COUNTER,               /**< Green packets counter */
+    e_IOC_FM_PCD_PLCR_PROFILE_YELLOW_PACKET_TOTAL_COUNTER,              /**< Yellow packets counter */
+    e_IOC_FM_PCD_PLCR_PROFILE_RED_PACKET_TOTAL_COUNTER,                 /**< Red packets counter */
+    e_IOC_FM_PCD_PLCR_PROFILE_RECOLOURED_YELLOW_PACKET_TOTAL_COUNTER,   /**< Recolored yellow packets counter */
+    e_IOC_FM_PCD_PLCR_PROFILE_RECOLOURED_RED_PACKET_TOTAL_COUNTER       /**< Recolored red packets counter */
+} ioc_fm_pcd_plcr_profile_counters;
+
+/**************************************************************************//**
+ @Description   A type used for returning the order of the key extraction.
+                each value in this array represents the index of the extraction
+                command as defined by the user in the initialization extraction array.
+                The valid size of this array is the user define number of extractions
+                required (also marked by the second '0' in this array).
+*//***************************************************************************/
+typedef    uint8_t    ioc_fm_pcd_kg_key_order_t [IOC_FM_PCD_KG_MAX_NUM_OF_EXTRACTS_PER_KEY];
+
+/**************************************************************************//**
+ @Description   A Union of protocol dependent special options
+*//***************************************************************************/
+typedef union ioc_fm_pcd_hdr_protocol_opt_u {
+    ioc_eth_protocol_opt_t    eth_opt;     /**< Ethernet options */
+    ioc_vlan_protocol_opt_t   vlan_opt;    /**< Vlan options */
+    ioc_mpls_protocol_opt_t   mpls_opt;    /**< MPLS options */
+    ioc_ipv4_protocol_opt_t   ipv4_opt;    /**< IPv4 options */
+    ioc_ipv6_protocol_opt_t   ipv6_opt;    /**< IPv6 options */
+} ioc_fm_pcd_hdr_protocol_opt_u;
+
+/**************************************************************************//**
+ @Description   A union holding all known protocol fields
+*//***************************************************************************/
+typedef union ioc_fm_pcd_fields_u {
+    ioc_header_field_eth_t        eth;        /**< eth      */
+    ioc_header_field_vlan_t       vlan;       /**< vlan     */
+    ioc_header_field_llc_snap_t   llc_snap;   /**< llcSnap  */
+    ioc_header_field_pppoe_t      pppoe;      /**< pppoe    */
+    ioc_header_field_mpls_t       mpls;       /**< mpls     */
+    ioc_header_field_ipv4_t       ipv4;       /**< ipv4     */
+    ioc_header_field_ipv6_t       ipv6;       /**< ipv6     */
+    ioc_header_field_udp_t        udp;        /**< udp      */
+    ioc_header_field_tcp_t        tcp;        /**< tcp      */
+    ioc_header_field_sctp_t       sctp;       /**< sctp     */
+    ioc_header_field_dccp_t       dccp;       /**< dccp     */
+    ioc_header_field_gre_t        gre;        /**< gre      */
+    ioc_header_field_minencap_t   minencap;   /**< minencap */
+    ioc_header_field_ipsec_ah_t   ipsec_ah;   /**< ipsecAh  */
+    ioc_header_field_ipsec_esp_t  ipsec_esp;  /**< ipsecEsp */
+} ioc_fm_pcd_fields_u;
+
+/**************************************************************************//**
+ @Description   structure for defining header extraction for key generation
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_from_hdr_t {
+    uint8_t             size;           /**< Size in byte */
+    uint8_t             offset;         /**< Byte offset */
+} ioc_fm_pcd_from_hdr_t;
+
+/**************************************************************************//**
+ @Description   structure for defining field extraction for key generation
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_from_field_t {
+    ioc_fm_pcd_fields_u field;          /**< Field selection */
+    uint8_t             size;           /**< Size in byte */
+    uint8_t             offset;         /**< Byte offset */
+} ioc_fm_pcd_from_field_t;
+
+/**************************************************************************//**
+ @Description   A structure of parameters used to define a single network
+                environment unit.
+                A unit should be defined if it will later be used by one or
+                more PCD engines to distinguich between flows.
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_distinction_unit_t {
+    struct {
+        ioc_net_header_type             hdr;            /**< One of the headers supported by the FM */
+        ioc_fm_pcd_hdr_protocol_opt_u   opt;            /**< only one option !! */
+    } hdrs[IOC_FM_PCD_MAX_NUM_OF_INTERCHANGABLE_HDRS];
+} ioc_fm_pcd_distinction_unit_t;
+
+/**************************************************************************//**
+ @Description   A structure of parameters used to define the different
+                units supported by a specific PCD Network Environment
+                Characteristics module. Each unit represent
+                a protocol or a group of protocols that may be used later
+                by the different PCD engined to distinguich between flows.
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_net_env_params_t {
+    uint8_t                         num_of_distinction_units;   /**< Number of different units to be identified */
+    ioc_fm_pcd_distinction_unit_t   units[IOC_FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS];
+                                                                /**< An array of numOfDistinctionUnits of the
+                                                                     different units to be identified */
+    void                            *id;                        /**< output parameter; Returns the net-env Id to be used */
+} ioc_fm_pcd_net_env_params_t;
+
+/**************************************************************************//**
+ @Description   structure for defining a single extraction action
+                when creating a key
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_extract_entry_t {
+    ioc_fm_pcd_extract_type                 type;           /**< Extraction type select */
+    union {
+        struct {                            /**< used when type = e_IOC_FM_PCD_KG_EXTRACT_BY_HDR */
+            ioc_net_header_type             hdr;            /**< Header selection */
+            bool                            ignore_protocol_validation; /**< Ignore protocol validation */
+            ioc_fm_pcd_hdr_index            hdr_index;       /**< Relevant only for MPLS, VLAN and tunneled
+                                                                  IP. Otherwise should be cleared.*/
+            ioc_fm_pcd_extract_by_hdr_type  type;            /**< Header extraction type select */
+            union {
+                ioc_fm_pcd_from_hdr_t       from_hdr;        /**< Extract bytes from header parameters */
+                ioc_fm_pcd_from_field_t     from_field;      /**< Extract bytes from field parameters*/
+                ioc_fm_pcd_fields_u         full_field;      /**< Extract full filed parameters*/
+            } extract_by_hdr_type;
+        } extract_by_hdr;
+        struct{                       /**< used when type = e_IOC_FM_PCD_KG_EXTRACT_NON_HDR */
+            ioc_fm_pcd_extract_from         src;            /**< Non-header extraction source */
+            uint8_t                         offset;         /**< Byte offset */
+            uint8_t                         size;           /**< Size in byte */
+        } extract_non_hdr;
+    } extract_params;
+} ioc_fm_pcd_extract_entry_t;
+
+/**************************************************************************//**
+ @Description   A structure for defining masks for each extracted
+                field in the key.
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_kg_extract_mask_t {
+    uint8_t                extract_array_index;         /**< Index in the extraction array, as initialized by user */
+    uint8_t                offset;                      /**< Byte offset */
+    uint8_t                mask;                        /**< A byte mask (selected bits will be ignored) */
+} ioc_fm_pcd_kg_extract_mask_t;
+
+/**************************************************************************//**
+ @Description   A structure for defining default selection per groups
+                of fields
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_kg_extract_dflt_t {
+    ioc_fm_pcd_kg_known_fields_dflt_types    type;          /**< Default type select*/
+    ioc_fm_pcd_kg_extract_dflt_select        dflt_select;   /**< Default register select */
+} ioc_fm_pcd_kg_extract_dflt_t;
+
+/**************************************************************************//**
+ @Description   A structure for defining all parameters needed for
+                generation a key and using a hash function
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_kg_key_extract_and_hash_params_t {
+    uint32_t                            private_dflt0;               /**< Scheme default register 0 */
+    uint32_t                            private_dflt1;               /**< Scheme default register 1 */
+    uint8_t                             num_of_used_extracts;           /**< defines the valid size of the following array */
+    ioc_fm_pcd_extract_entry_t          extract_array [IOC_FM_PCD_KG_MAX_NUM_OF_EXTRACTS_PER_KEY];
+    uint8_t                             num_of_used_dflt;           /**< defines the valid size of the following array */
+    ioc_fm_pcd_kg_extract_dflt_t        dflts[IOC_FM_PCD_KG_NUM_OF_DEFAULT_GROUPS];
+    uint8_t                             num_of_used_masks;              /**< defines the valid size of the following array */
+    ioc_fm_pcd_kg_extract_mask_t        masks[IOC_FM_PCD_KG_NUM_OF_EXTRACT_MASKS];
+    uint8_t                             hash_shift;                     /**< Select the 24 bits out of the 64 hash result */
+    uint32_t                            hash_distribution_num_of_fqids; /**< must be > 1 and a power of 2. Represents the range
+                                                                             of queues for the key and hash functionality */
+    uint8_t                             hash_distribution_fqids_shift;  /**< selects the FQID bits that will be effected by the hash */
+} ioc_fm_pcd_kg_key_extract_and_hash_params_t;
+
+/**************************************************************************//**
+ @Description   A structure of parameters for defining a single
+                Qid mask (extracted OR).
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_kg_extracted_or_for_fqid_t {
+    ioc_fm_pcd_extract_type                 type;               /**< Extraction type select */
+    union{
+        struct{                                                 /**< used when type = e_IOC_FM_PCD_KG_EXTRACT_BY_HDR */
+            ioc_net_header_type             hdr;
+            ioc_fm_pcd_hdr_index            hdr_index;          /**< Relevant only for MPLS, VLAN and tunneled
+                                                                     IP. Otherwise should be cleared.*/
+            bool                            ignore_protocol_validation;
+        } extract_by_hdr;
+        ioc_fm_pcd_extract_from             src;                /**< used when type = e_IOC_FM_PCD_KG_EXTRACT_NON_HDR */
+    } extract_params;
+    uint8_t                                 extraction_offset;  /**< Offset for extraction */
+    ioc_fm_pcd_kg_extract_dflt_select       dflt_value;         /**< Select register from which extraction is taken if
+                                                                     field not found */
+    uint8_t                                 mask;               /**< Mask LSB byte of extraction (specified bits are ignored) */
+    uint8_t                                 bit_offset_in_fqid; /**< out of 24 bits Qid  (max offset = 16) */
+} ioc_fm_pcd_kg_extracted_or_for_fqid_t;
+
+/**************************************************************************//**
+ @Description   A structure for configuring scheme counter
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_kg_scheme_counter_t {
+    bool        update;     /**< FALSE to keep the current counter state
+                                 and continue from that point, TRUE to update/reset
+                                 the counter when the scheme is written. */
+    uint32_t    value;      /**< If update=TRUE, this value will be written into the
+                                 counter. clear this field to reset the counter. */
+} ioc_fm_pcd_kg_scheme_counter_t;
+
+/**************************************************************************//**
+ @Description   A structure for defining policer profile
+                parameters as required by keygen (when policer
+                is the next engine after this scheme).
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_kg_plcr_profile_t {
+    bool                shared_profile;                 /**< TRUE if this profile is shared between ports
+                                                             (i.e. managed by master partition) May not be TRUE
+                                                             if profile is after Coarse Classification*/
+    bool                direct;                         /**< if TRUE, directRelativeProfileId only selects the profile
+                                                             id, if FALSE fqidOffsetRelativeProfileIdBase is used
+                                                             together with fqidOffsetShift and numOfProfiles
+                                                             parameters, to define a range of profiles from
+                                                             which the keygen result will determine the
+                                                             destination policer profile.  */
+    union{
+        uint16_t        direct_relative_profile_id;     /**< Used if 'direct' is TRUE, to select policer profile.
+                                                             This parameter should
+                                                             indicate the policer profile offset within the port's
+                                                             policer profiles or SHARED window. */
+        struct {
+            uint8_t     fqid_offset_shift;              /**< shift of KG results without the qid base */
+            uint8_t     fqid_offset_relative_profile_id_base;/**< OR of KG results without the qid base
+                                                             This parameter should
+                                                             indicate the policer profile offset within the port's
+                                                             policer profiles windowor SHARED window depends on sharedProfile */
+            uint8_t     num_of_profiles;                /**< Range of profiles starting at base */
+        } indirect_profile_id;
+    } profile_select;
+} ioc_fm_pcd_kg_plcr_profile_t;
+
+/**************************************************************************//**
+ @Description   A structure for CC parameters if CC is the next engine after KG
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_kg_cc_t {
+    void                            *tree_id;           /**< CC Tree id */
+    uint8_t                         grp_id;             /**< CC group id within the CC tree */
+    bool                            plcr_next;          /**< TRUE if after CC, in case of data frame,
+                                                             policing is required. */
+    ioc_fm_pcd_kg_plcr_profile_t    plcr_profile;       /**< only if plcrNext=TRUE */
+} ioc_fm_pcd_kg_cc_t;
+
+/**************************************************************************//**
+ @Description   A structure for initializing a keygen single scheme
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_kg_scheme_params_t {
+    bool                                modify;         /**< enables changing an existing scheme */
+    union
+    {
+        uint8_t                         relative_scheme_id;/**< IN: if modify=FALSE:Partition relative scheme id */
+        void                            *scheme_id;      /**< IN: if modify=TRUE: a handle of the existing scheme */
+    } scm_id;
+    bool                                always_direct;  /**< This scheme is reached only directly, i.e.                                                              no need for match vector. Keygen will ignore
+                                                             it when matching   */
+    struct                                              /**< HL Relevant only if alwaysDirect = FALSE */
+    {
+        void                            *net_env_id;     /**< Network environment id  */
+        uint8_t                         num_of_distinction_units; /**< Number of netenv units listed in unit_ids array */
+        uint8_t                         unit_ids[IOC_FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS];
+                                                        /**< Indexes as passed to SetNetEnvCharacteristics array*/
+    } netEnvParams;
+    bool                                use_hash;       /**< use the KG Hash functionality */
+    ioc_fm_pcd_kg_key_extract_and_hash_params_t     key_extract_and_hash_params;
+                                                        /**< used only if useHash = TRUE */
+    uint32_t                            base_fqid;      /**< Base FQID */
+    uint8_t                             num_of_used_fqid_masks;  /**< Number of Fqid masks listed in fqid_masks array */
+    ioc_fm_pcd_kg_extracted_or_for_fqid_t           fqid_masks[IOC_FM_PCD_KG_NUM_OF_GENERIC_REGS];
+                                                        /**< IOC_FM_PCD_KG_NUM_OF_GENERIC_REGS
+                                                             registers are shared between qidMasks
+                                                             functionality and some of the extraction
+                                                             actions. Normally only some will be used
+                                                             for qidMask. Driver will return error if
+                                                             resource is full at initialization time. */
+    ioc_fm_pcd_engine                   next_engine;    /**< may be BMI, PLCR or CC */
+    union{                                              /**< depends on nextEngine */
+        ioc_fm_pcd_kg_plcr_profile_t    plcr_profile;   /**< Used when next engine is PLCR */
+        ioc_fm_pcd_kg_cc_t              cc;             /**< Used when next engine is CC */
+    } kg_next_engine_params;
+    ioc_fm_pcd_kg_scheme_counter_t      scheme_counter; /**< A strcucture of parameters for updating
+                                                             the scheme counter */
+    ioc_fm_pcd_kg_key_order_t           ordered_array;  /**< OUT: A structure holding the order of the key extraction.
+                                                             Relevant only is 'useHash' is TRUE. each value in this
+                                                             array represents the index of the
+                                                             extraction command as defined by the application in
+                                                             the initialization extraction array.
+                                                             The valid size of this array is the application define number of extractions
+                                                             required (also marked by the second '0' in this array).*/
+    void                                *id;            /**< OUT: Returns the scheme Id to be used */
+} ioc_fm_pcd_kg_scheme_params_t;
+
+/**************************************************************************//**
+ @Description   A structure for defining CC params when CC is the
+                next engine after a CC node
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_cc_next_cc_params_t {
+    void        *cc_node_id;                   /**< Id of the next CC node */
+} ioc_fm_pcd_cc_next_cc_params_t;
+
+/**************************************************************************//**
+ @Description   A structure for defining PLCR params when PLCR is the
+                next engine after a CC node
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_cc_next_plcr_params_t {
+    bool        ctrl_flow;                      /**< TRUE if this is a control flow, FALSE
+                                                     if this is data flow */
+    bool        shared_profile;                 /**< Relevant only if ctrlFlow=TRUE:
+                                                     TRUE if this profile is shared between ports */
+    uint16_t    plcr_profile_num_for_ctrl_flow; /**< Valid if ctrlFlow=TRUE,Proile id for control flow
+                                                     (for data flow porfile id
+                                                     is taken from keygen) */
+    bool        fqid_enq_ctrl_flow;             /**< TRUE if after the policer the frame should
+                                                     be enqueued rather than return to Keygen */
+    uint32_t    fqid_for_ctrl_flow_for_bmi_after_plcr; /**< Valid if fqidEnqForCtrlFlow= TRUE, FQID for enquing
+                                                         the frame */
+} ioc_fm_pcd_cc_next_plcr_params_t;
+
+/**************************************************************************//**
+ @Description   A structure for defining enqueue params when BMI is the
+                next engine after a CC node
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_cc_next_enqueue_params_t {
+    bool        ctrl_flow;              /**< TRUE if this is a control flow, FALSE
+                                             if this is data flow */
+    uint32_t    fqid_for_cntrl_flow;    /**< Valid if ctrlFlow=TRUE, FQID for enquing the frame
+                                             (for data flow FQID is taken from keygen) */
+} ioc_fm_pcd_cc_next_enqueue_params_t;
+
+/**************************************************************************//**
+ @Description   A structure for defining KG params when KG is the
+                next engine after a CC node
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_cc_next_kg_params_t {
+    bool        ctrl_flow;              /**< TRUE if this is a control flow, FALSE
+                                             if this is data flow */
+    void        *direct_scheme_id;      /**< Direct scheme id to go to */
+} ioc_fm_pcd_cc_next_kg_params_t;
+
+/**************************************************************************//**
+ @Description   A structure for defining next engine params after a CC node.
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_cc_next_engine_params_t {
+    ioc_fm_pcd_engine                           next_engine;    /**< user has to init parameters according
+                                                                     to nextEngine definition */
+    union {
+            ioc_fm_pcd_cc_next_cc_params_t      cc_params;      /**< Parameters in case next engine is CC */
+            ioc_fm_pcd_cc_next_plcr_params_t    plcr_params;    /**< Parameters in case next engine is PLCR */
+            ioc_fm_pcd_cc_next_enqueue_params_t enqueue_params; /**< Parameters in case next engine is BMI */
+            ioc_fm_pcd_cc_next_kg_params_t      kg_params;      /**< Parameters in case next engine is KG */
+    } params;
+} ioc_fm_pcd_cc_next_engine_params_t;
+
+/**************************************************************************//**
+ @Description   A structure for defining a single CC Key parameters
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_cc_key_params_t {
+    uint8_t                 *p_key; /**< pointer to the key of the size defined in keySize */
+    uint8_t                 *p_mask;/**< pointer to the Mask per key  of the size defined
+                                         in keySize. p_Key and p_Mask (if defined) has to be
+                                         of the same size defined in the keySize */
+
+    ioc_fm_pcd_cc_next_engine_params_t  cc_next_engine_params;
+                                    /**< parameters for the next for the defined Key in the p_Key */
+} ioc_fm_pcd_cc_key_params_t;
+
+/**************************************************************************//**
+ @Description   A structure for defining CC Keys parameters
+*//***************************************************************************/
+typedef struct ioc_keys_params_t {
+    uint8_t                             num_of_keys;    /**< num Of relevant Keys  */
+    uint8_t                             key_size;       /**< size of the key - in the case of the extraction of
+                                                             the type FULL_FIELD keySize has to be as standard size of the relevant
+                                                             key. In the another type of extraction keySize has to be as size of extraction. */
+
+    uint8_t                             *p_glbl_mask;   /**< optional and can be initialized if :
+                                                             keySize <=4 or  maskForKey is not initialized*/
+    ioc_fm_pcd_cc_key_params_t          key_params[IOC_FM_PCD_MAX_NUM_OF_KEYS];
+                                                        /**< it's array with numOfKeys entries each entry in
+                                                             the array of the type ioc_fm_pcd_cc_key_params_t */
+    ioc_fm_pcd_cc_next_engine_params_t  cc_next_engine_params_for_miss;
+                                                        /**< parameters for the next step of
+                                                             unfound (or undefined) key */
+} ioc_keys_params_t;
+
+/**************************************************************************//**
+ @Description   A structure for defining the CC node params
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_cc_node_params_t {
+    ioc_fm_pcd_extract_entry_t          extract_cc_params;  /**< params which defines extraction parameters */
+    ioc_keys_params_t                   keys_params;        /**< params which defines Keys parameters of the
+                                                                 extraction defined in  extractParams */
+    void                                *id;                /**< output parameter; Returns the CC node Id to be used */
+} ioc_fm_pcd_cc_node_params_t;
+
+/**************************************************************************//**
+ @Description   A structure for defining each CC tree group in term of
+                NetEnv units and the action to be taken in each case.
+                the unit_ids list must be in order from lower to higher indexes.
+
+                ioc_fm_pcd_cc_next_engine_params_t is a list of 2^num_of_distinction_units
+                structures where each defines the next action to be taken for
+                each units combination. for example:
+                num_of_distinction_units = 2
+                unit_ids = {1,3}
+                next_engine_per_entries_in_grp[0] = ioc_fm_pcd_cc_next_engine_params_t for the case that
+                                                    unit 1 - not found; unit 3 - not found;
+                next_engine_per_entries_in_grp[1] = ioc_fm_pcd_cc_next_engine_params_t for the case that
+                                                    unit 1 - not found; unit 3 - found;
+                next_engine_per_entries_in_grp[2] = ioc_fm_pcd_cc_next_engine_params_t for the case that
+                                                    unit 1 - found; unit 3 - not found;
+                next_engine_per_entries_in_grp[3] = ioc_fm_pcd_cc_next_engine_params_t for the case that
+                                                    unit 1 - found; unit 3 - found;
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_cc_grp_params_t {
+    uint8_t                             num_of_distinction_units;   /**< up to 4 */
+    uint8_t                             unit_ids [IOC_FM_PCD_MAX_NUM_OF_CC_UNITS];
+                                                                    /**< Indexes of the units as defined in
+                                                                         FM_PCD_SetNetEnvCharacteristics */
+    ioc_fm_pcd_cc_next_engine_params_t  *p_next_engine_per_entries_in_grp;
+                                                                    /**< Max size is 16 - if only one group used  */
+} ioc_fm_pcd_cc_grp_params_t;
+
+/**************************************************************************//**
+ @Description   A structure for defining the CC tree groups
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_cc_tree_params_t {
+        void                            *net_env_id;    /**< Id of the Network environment as returned
+                                                             by FM_PCD_SetNetEnvCharacteristics */
+        uint8_t                         num_of_groups;  /**< Number of CC groups within the CC tree */
+        ioc_fm_pcd_cc_grp_params_t      fm_pcd_cc_group_params [IOC_FM_PCD_MAX_NUM_OF_PCD_CC_GROUP];
+                                                        /**< Max 8 groups (of 2) for the 16 nodes root */
+        void                            *id;            /**< output parameter; Returns the tree Id to be used */
+} ioc_fm_pcd_cc_tree_params_t;
+
+/**************************************************************************//**
+ @Description   A structure for initializing a keygen classification plan group
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_kg_cls_plan_grp_params_t {
+    void                *net_env_id;    /**< Id of the Network environment as returned
+                                             by FM_PCD_SetNetEnvCharacteristics */
+    uint8_t             num_of_pptions; /**< Number of options, to define the size of the
+                                             following array. */
+    ioc_protocol_opt_t  options[IOC_FM_PCD_MAX_NUM_OF_CLS_PLANS];
+                                        /**< an option may be ipv6Multicast1,
+                                             (ethBroadcast | ethMulticast) or
+                                             (ethBroadcast | ipv4Unicast2 | mplsStacked) */
+    void                *id;            /**< output parameter; Returns the classification-group Id to be used */
+} ioc_fm_pcd_kg_cls_plan_grp_params_t;
+
+/**************************************************************************//**
+ @Description   A structure for defining parameters for byte rate
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_plcr_byte_rate_mode_param_t {
+    ioc_fm_pcd_plcr_frame_length_select     frame_length_selection;     /**< Frame length selection */
+    ioc_fm_pcd_plcr_roll_back_frame_select  roll_back_frame_selection;  /**< relevant option only e_IOC_FM_PCD_PLCR_L2_FRM_LEN,
+                                                                             e_IOC_FM_PCD_PLCR_FULL_FRM_LEN */
+} ioc_fm_pcd_plcr_byte_rate_mode_param_t;
+
+/**************************************************************************//**
+ @Description   A structure for selcting the policer profile RFC 2698 or RFC 4115 parameters
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_plcr_non_passthrough_alg_param_t {
+    ioc_fm_pcd_plcr_rate_mode               rate_mode;                      /**< Byte / Packet */
+    ioc_fm_pcd_plcr_byte_rate_mode_param_t  byte_mode_param;                /**< Valid for Byte NULL for Packet */
+    uint32_t                                comitted_info_rate;             /**< KBits/Sec or Packets/Sec */
+    uint32_t                                comitted_burst_size;            /**< KBits or Packets */
+    uint32_t                                peak_or_accessive_info_rate;    /**< KBits/Sec or Packets/Sec */
+    uint32_t                                peak_or_accessive_burst_size;   /**< KBits or Packets */
+} ioc_fm_pcd_plcr_non_passthrough_alg_param_t;
+
+/**************************************************************************//**
+ @Description   A union for defining Policer next engine parameters
+*//***************************************************************************/
+typedef union ioc_fm_pcd_plcr_next_engine_params_u {
+        ioc_fm_pcd_plcr_done_action     action;             /**< Action - when next engine is BMI (done) */
+        void                            *plcr_profile_id;   /**< Policer profile id -  when next engine is PLCR*/
+        void                            *direct_scheme_id;  /**< Direct scheme id - when next engine is Keygen */
+} ioc_fm_pcd_plcr_next_engine_params_u;
+
+typedef struct fm_pcd_port_params_t {
+    ioc_fm_port_type                    port_type;          /**< Type of port for this profile */
+    uint8_t                             port_id;            /**< FM-Port id of port for this profile */
+} fm_pcd_port_params_t;
+
+/**************************************************************************//**
+ @Description   A structure for selcting the policer profile entry parameters
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_plcr_profile_params_t {
+    bool                                        modify;                     /**< TRUE to change an existing profile */
+    union {
+        struct {
+            ioc_fm_pcd_profile_type_selection   profile_type;               /**< Type of policer profile */
+            fm_pcd_port_params_t                *p_port;                    /**< FM-Port id of port for this profile */
+            uint16_t                            relative_profile_id;        /**< Profile id - relative to shared group or to port */
+        } new_params;
+        void                                    *profile_id;                /**< policer-profile id */
+    } profile_select;
+    ioc_fm_pcd_plcr_algorithm_selection         alg_selection;              /**< Profile Algoritem PASS_THROUGH, RFC_2698, RFC_4115 */
+    ioc_fm_pcd_plcr_color_mode                  color_mode;                 /**< COLOR_BLIND, COLOR_AWARE */
+
+    union {
+        ioc_fm_pcd_plcr_color                   dflt_color;                 /**< For Color-Blind Pass-Through mode. the policer will re-color
+                                                                                 any incoming packet with the deflt value. */
+        ioc_fm_pcd_plcr_color                   override;                   /**< For Color-Aware modes. The profile response to a
+                                                                                 pre-color value of 2b11. */
+    } color;
+
+    ioc_fm_pcd_plcr_non_passthrough_alg_param_t non_passthrough_alg_param;  /**< RFC2698 or RFC4115 params */
+
+    ioc_fm_pcd_engine                           next_engine_on_green;       /**< Green next engine type */
+    ioc_fm_pcd_plcr_next_engine_params_u        params_on_green;            /**< Green next engine params */
+
+    ioc_fm_pcd_engine                           next_engine_on_yellow;      /**< Yellow next engine type */
+    ioc_fm_pcd_plcr_next_engine_params_u        params_on_yellow;           /**< Yellow next engine params */
+
+    ioc_fm_pcd_engine                           next_engine_on_red;         /**< Red next engine type */
+    ioc_fm_pcd_plcr_next_engine_params_u        params_on_red;              /**< Red next engine params */
+
+    bool                                        trap_profile_on_flow_A;     /**< Trap on flow A */
+    bool                                        trap_profile_on_flow_B;     /**< Trap on flow B */
+    bool                                        trap_profile_on_flow_C;     /**< Trap on flow C */
+    void                                        *id;                        /**< output parameter; Returns the profile Id to be used */
+} ioc_fm_pcd_plcr_profile_params_t;
+
+/**************************************************************************//**
+ @Description   TBD
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_cc_tree_modify_next_engine_params_t {
+    void                                *id;                /**< CC tree Id to be used */
+    uint8_t                             grp_indx;           /**< A Group index in the tree */
+    uint8_t                             indx;               /**< Entry index in the group defined by grpId */
+    ioc_fm_pcd_cc_next_engine_params_t  cc_next_engine_params;
+                                                            /**< parameters for the next for the defined Key in the p_Key */
+} ioc_fm_pcd_cc_tree_modify_next_engine_params_t;
+
+/**************************************************************************//**
+ @Description   TBD
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_cc_node_modify_next_engine_params_t {
+    void                                *id;                /**< CC node Id to be used */
+    uint8_t                             key_indx;           /**< Key index for Next Engine Params modifications;
+                                                                 NOTE: This parameter is IGNORED for miss-key!  */
+    uint8_t                             key_size;           /**< Key size of added key */
+    ioc_fm_pcd_cc_next_engine_params_t  cc_next_engine_params;
+                                                            /**< parameters for the next for the defined Key in the p_Key */
+} ioc_fm_pcd_cc_node_modify_next_engine_params_t;
+
+/**************************************************************************//**
+ @Description   TBD
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_cc_node_modify_key_and_next_engine_params_t {
+    void                                *id;                /**< CC node Id to be used */
+    uint8_t                             key_indx;           /**< Key index for Next Engine Params modifications;
+                                                                 NOTE: This parameter is IGNORED for miss-key!  */
+    uint8_t                             key_size;           /**< Key size of added key */
+    ioc_fm_pcd_cc_key_params_t          key_params;         /**< it's array with numOfKeys entries each entry in
+                                                                 the array of the type ioc_fm_pcd_cc_key_params_t */
+} ioc_fm_pcd_cc_node_modify_key_and_next_engine_params_t;
+
+/**************************************************************************//**
+ @Description   TBD
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_cc_node_remove_key_params_t {
+    void                                *id;                /**< CC node Id to be used */
+    uint8_t                             key_indx;           /**< Key index for Next Engine Params modifications;
+                                                                 NOTE: This parameter is IGNORED for miss-key!  */
+} ioc_fm_pcd_cc_node_remove_key_params_t;
+
+/**************************************************************************//**
+ @Description   TBD
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_cc_node_modify_key_params_t {
+    void                                *id;                /**< CC node Id to be used */
+    uint8_t                             key_indx;           /**< Key index for Next Engine Params modifications;
+                                                                 NOTE: This parameter is IGNORED for miss-key!  */
+    uint8_t                             key_size;           /**< Key size of added key */
+    uint8_t                             *p_key;             /**< pointer to the key of the size defined in keySize */
+    uint8_t                             *p_mask;            /**< pointer to the Mask per key  of the size defined
+                                                                 in keySize. p_Key and p_Mask (if defined) has to be
+                                                                 of the same size defined in the keySize */
+} ioc_fm_pcd_cc_node_modify_key_params_t;
+
+
+/**************************************************************************//**
+ @Function      FM_PCD_IOC_SET_NET_ENV_CHARACTERISTICS
+
+ @Description   Define a set of Network Environment Charecteristics.
+                When setting an environment it is important to understand its
+                application. It is not meant to describe the flows that will run
+                on the ports using this environment, but what the user means TO DO
+                with the PCD mechanisms in order to parse-classify-distribute those
+                frames.
+                By specifying a distinction unit, the user means it would use that option
+                for distinction between frames at either a keygen scheme keygen or a coarse
+                classification action descriptor. Using interchangeable headers to define a
+                unit means that the user is indifferent to which of the interchangeable
+                headers is present in the frame, and they want the distinction to be based
+                on the presence of either one of them.
+                Depending on context, there are limitations to the use of environments. A
+                port using the PCD functionality is bound to an environment. Some or even
+                all ports may share an environment but also an environment per port is
+                possible. When initializing a scheme, a classification plan group (see below),
+                or a coarse classification tree, one of the initialized environments must be
+                stated and related to. When a port is bound to a scheme, a classification
+                plan group, or a coarse classification tree, it MUST be bound to the same
+                environment.
+                The different PCD modules, may relate (for flows definition) ONLY on
+                distinction units as defined by their environment. When initializing a
+                scheme for example, it may not choose to select IPV4 as a match for
+                recognizing flows unless it was defined in the relating environment. In
+                fact, to guide the user through the configuration of the PCD, each module's
+                characterization in terms of flows is not done using protocol names, but using
+                environment indexes.
+                In terms of HW implementation, the list of distinction units sets the LCV vectors
+                and later used for match vector, classification plan vectors and coarse classification
+                indexing.
+
+ @Param[in,out] ioc_fm_pcd_net_env_params_t   An structure defining the distiction units for this configuration.
+
+ @Return        0 on success; Error code otherwise.
+
+ @Cautions      Allowed only following PCD_Init().
+*//***************************************************************************/
+#define FM_PCD_IOC_SET_NET_ENV_CHARACTERISTICS  _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(20), ioc_fm_pcd_net_env_params_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_IOC_DELETE_NET_ENV_CHARACTERISTICS
+
+ @Description   Deletes a set of Network Environment Charecteristics.
+
+ @Param[in]     ioc_fm_obj_t        An id of a Network environment object.
+
+ @Return        E_OK on success; Error code otherwise.
+*//***************************************************************************/
+#define FM_PCD_IOC_DELETE_NET_ENV_CHARACTERISTICS  _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(21), ioc_fm_obj_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_IOC_KG_SET_CLS_PLAN_GRP
+
+ @Description   Define a classification plan group..
+                A classification plan group is a set of classification plan
+                entries consisting of a number of protocol options (as listed
+                in HW spec), that is a subset of a previously defined environment,
+                and that is relevant for one or more ports that will use that
+                same environment.
+                By specifying an option, the application means it would use that
+                option for distinction between frames at either a keygen scheme
+                keygen or a coarse classification action descriptor.
+                When RX ports that want to use the classification plan mechanism
+                are initialized, they will be bound to a classification plan
+                group. Usage of the classification plan is optional.
+                If not all ports use classification plan, it is user's responsibility
+                to declare that by calling FM_PCD_KgSetEmptyClsPlanGrp. The driver
+                will then allocate a minimal number of entries for that use, and all
+                ports that do not use the classification plan mechanism will
+                be internally bound to that empty group.
+
+ @Param[in,out] ioc_fm_pcd_kg_cls_plan_grp_params_t  A structure of classification plan parameters.
+
+ @Return        0 on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_Init().
+*//***************************************************************************/
+#define FM_PCD_IOC_KG_SET_CLS_PLAN_GRP  _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(22), ioc_fm_pcd_kg_cls_plan_grp_params_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_IOC_KG_DEL_CLS_PLAN
+
+ @Description   Delete classification plan by writing reset value (0xFFFFFFFF)
+                to it - pass all LCV bits.
+
+ @Param[in]     ioc_fm_obj_t         index of plan entry to be deleted.
+
+ @Return        0 on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_Init().
+*//***************************************************************************/
+#define FM_PCD_IOC_KG_DEL_CLS_PLAN  _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(23), ioc_fm_obj_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_IOC_KG_SET_SCHEME
+
+ @Description   Initializing or modifying and enabling a scheme for the keygen.
+                This routine should be called for adding or modifying a scheme.
+                When a scheme needs modifying, the API requires that it will be
+                rewritten. In such a case 'override' should be TRUE. If  the
+                routine is called for a valid scheme and 'override' is FALSE,
+                it will return error.
+
+ @Param[in]     ioc_fm_pcd_kg_scheme_params_t   A structure of parameters for defining the scheme
+
+ @Return        0 on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_Init().
+*//***************************************************************************/
+#define FM_PCD_IOC_KG_SET_SCHEME    _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(24), ioc_fm_pcd_kg_scheme_params_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_IOC_KG_DEL_SCHEME
+
+ @Description   Deleting an initialized scheme.
+
+ @Param[in]     ioc_fm_obj_t        scheme id as initalized by application at FM_PCD_IOC_KG_SET_SCHEME
+
+ @Return        0 on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_Init().
+*//***************************************************************************/
+#define FM_PCD_IOC_KG_DEL_SCHEME    _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(25), ioc_fm_obj_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_IOC_CC_BUILD_TREE
+
+ @Description   This routine must be called to define a complete coarse
+                classification tree. This is the way to define coarse
+                classification to a certain flow - the keygen schemes
+                may point only to trees defined in this way.
+
+ @Param[in,out] ioc_fm_pcd_cc_tree_params_t     A structure of parameters to define the tree.
+
+ @Return        0 on success; Error code if the exception is not enabled,
+                or is not able to create interrupt.
+
+ @Cautions      Allowed only following PCD_Init().
+*//***************************************************************************/
+#define FM_PCD_IOC_CC_BUILD_TREE    _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(26), ioc_fm_pcd_cc_tree_params_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_IOC_CC_DELETE_TREE
+
+ @Description   Deleting an built tree.
+
+ @Param[in]     ioc_fm_obj_t    An id of a CC-tree.
+
+ @Cautions      Allowed only following FM_PCD_Init().
+*//***************************************************************************/
+#define FM_PCD_IOC_CC_DELETE_TREE    _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(27), ioc_fm_obj_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_IOC_CC_SET_NODE
+
+ @Description   This routine should be called for each CC (coarse classification)
+                node. The whole CC tree should be built bottom up so that each
+                node points to already defined nodes. p_NodeId returns the node
+                Id to be used by other nodes.
+
+ @Param[in,out] ioc_fm_pcd_cc_node_params_t       A structure for defining the CC node params
+
+ @Return        0 on success; Error code if the exception is not enabled,
+                or is not able to create interrupt.
+
+ @Cautions      Allowed only following PCD_Init().
+*//***************************************************************************/
+#define FM_PCD_IOC_CC_SET_NODE    _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(28), ioc_fm_pcd_cc_node_params_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_CcDeleteNode
+
+ @Description   Deleting an built node.
+
+ @Param[in]     ioc_fm_obj_t    An id of a CC-node.
+
+ @Cautions      Allowed only following FM_PCD_Init().
+*//***************************************************************************/
+#define FM_PCD_IOC_CC_DELETE_NODE    _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(29), ioc_fm_obj_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_IOC_CC_TREE_MODIFY_NEXT_ENGINE
+
+ @Description   Modify the Next Engine Parameters in the entry of the tree.
+
+ @Param[in]     ioc_fm_pcd_cc_tree_modify_next_engine_params_t  TBD
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_CcBuildTree().
+*//***************************************************************************/
+#define FM_PCD_IOC_CC_TREE_MODIFY_NEXT_ENGINE   _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(30), ioc_fm_pcd_cc_tree_modify_next_engine_params_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_IOC_CC_NODE_MODIFY_NEXT_ENGINE
+
+ @Description   Modify the Next Engine Parameters in the relevent key entry of the node.
+
+ @Param[in]     ioc_fm_pcd_cc_node_modify_next_engine_params_t  TBD
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_CcSetNode().
+*//***************************************************************************/
+#define FM_PCD_IOC_CC_NODE_MODIFY_NEXT_ENGINE   _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(31), ioc_fm_pcd_cc_node_modify_next_engine_params_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_IOC_CC_NODE_MODIFY_MISS_NEXT_ENGINE
+
+ @Description   Modify the Next Engine Parameters of the Miss key case of the node.
+
+ @Param[in]     ioc_fm_pcd_cc_node_modify_next_engine_params_t  TBD
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_CcSetNode().
+*//***************************************************************************/
+#define FM_PCD_IOC_CC_NODE_MODIFY_MISS_NEXT_ENGINE   _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(32), ioc_fm_pcd_cc_node_modify_next_engine_params_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_IOC_CC_NODE_REMOVE_KEY
+
+ @Description   Remove the key (include Next Engine Parameters of this key) defined by the index of the relevant node .
+
+ @Param[in]     ioc_fm_pcd_cc_node_remove_key_params_t  TBD
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_CcSetNode() not only of the relevnt node but also
+                the node that points to this node
+*//***************************************************************************/
+#define FM_PCD_IOC_CC_NODE_REMOVE_KEY   _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(33), ioc_fm_pcd_cc_node_remove_key_params_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_IOC_CC_NODE_ADD_KEY
+
+ @Description   Add the key(include Next Engine Parameters of this key)in the index defined by the keyIndex .
+
+ @Param[in]     ioc_fm_pcd_cc_node_modify_key_and_next_engine_params_t  TBD
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_CcSetNode() not only of the relevnt node but also
+                the node that points to this node
+*//***************************************************************************/
+#define FM_PCD_IOC_CC_NODE_ADD_KEY   _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(34), ioc_fm_pcd_cc_node_modify_key_and_next_engine_params_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_IOC_CC_NODE_MODIFY_KEY_AND_NEXT_ENGINE
+
+ @Description   Modify the key and Next Engine Parameters of this key in the index defined by the keyIndex .
+
+ @Param[in]     ioc_fm_pcd_cc_node_modify_key_and_next_engine_params_t  TBD
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_CcSetNode() not only of the relevnt node but also
+                the node that points to this node
+*//***************************************************************************/
+#define FM_PCD_IOC_CC_NODE_MODIFY_KEY_AND_NEXT_ENGINE   _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(35), ioc_fm_pcd_cc_node_modify_key_and_next_engine_params_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_IOC_CC_NODE_MODIFY_KEY
+
+ @Description   Modify the key  in the index defined by the keyIndex .
+
+ @Param[in]     ioc_fm_pcd_cc_node_modify_key_params_t  TBD
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_CcSetNode() not only of the relevnt node but also
+                the node that points to this node
+*//***************************************************************************/
+#define FM_PCD_IOC_CC_NODE_MODIFY_KEY   _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(36), ioc_fm_pcd_cc_node_modify_key_params_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_IOC_PLCR_SET_PROFILE
+
+ @Description   Sets a profile entry in the policer profile table.
+                The routine overrides any existing value.
+
+ @Param[in,out] ioc_fm_pcd_plcr_profile_params_t    A structure of parameters for defining a
+                                                    policer profile entry.
+
+ @Return        0 on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_Init().
+*//***************************************************************************/
+#define FM_PCD_IOC_PLCR_SET_PROFILE     _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(37), ioc_fm_pcd_plcr_profile_params_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_IOC_PLCR_DEL_PROFILE
+
+ @Description   Delete a profile entry in the policer profile table.
+                The routine set entry to invalid.
+
+ @Param[in]     ioc_fm_obj_t        an id of a policer-profile.
+
+ @Return        0 on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_Init().
+*//***************************************************************************/
+#define FM_PCD_IOC_PLCR_DEL_PROFILE     _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(38), ioc_fm_obj_t)
+
+/** @} */ /* end of lnx_ioctl_FM_PCD_Runtime_grp group */
+/** @} */ /* end of lnx_ioctl_FM_PCD_grp group */
+/** @} */ /* end of lnx_ioctl_FM_grp group */
+
+
+#endif /* __FM_PCD_IOCTLS_H */
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/Peripherals/fm_port_ioctls.h b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/Peripherals/fm_port_ioctls.h
new file mode 100644
index 0000000..4027dac
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/Peripherals/fm_port_ioctls.h
@@ -0,0 +1,592 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/******************************************************************************
+ @File          fm_port_ioctls.h
+
+ @Description   FM Port routines
+*//***************************************************************************/
+#ifndef __FM_PORT_IOCTLS_H
+#define __FM_PORT_IOCTLS_H
+
+#include "net_ioctls.h"
+#include "fm_ioctls.h"
+#include "fm_pcd_ioctls.h"
+
+
+/**************************************************************************//**
+ @Group         lnx_ioctl_FM_grp Frame Manager Linux IOCTL API
+
+ @Description   FM Linux ioctls definitions and enums
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Group         lnx_ioctl_FM_PORT_grp FM Port
+
+ @Description   FM Port API
+
+                The FM uses a general module called "port" to represent a Tx port
+                (MAC), an Rx port (MAC), offline parsing flow or host command
+                flow. There may be up to 17 (may change) ports in an FM - 5 Tx
+                ports (4 for the 1G MACs, 1 for the 10G MAC), 5 Rx Ports, and 7
+                Host command/Offline parsing ports. The SW driver manages these
+                ports as sub-modules of the FM, i.e. after an FM is initialized,
+                its ports may be initialized and operated upon.
+                The port is initialized aware of its type, but other functions on
+                a port may be indifferent to its type. When necessary, the driver
+                verifies coherency and returns error if applicable.
+                On initialization, user specifies the port type and it's index
+                (relative to the port's type). Host command and Offline parsing
+                ports share the same id range, I.e user may not initialized host
+                command port 0 and offline parsing port 0.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Group         lnx_ioctl_FM_PORT_runtime_control_grp FM Port Runtime Control Unit
+
+ @Description   FM Port Runtime control unit API functions, definitions and enums.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Collection    General FM Port defines
+*//***************************************************************************/
+#define IOC_FM_PORT_NUM_OF_CONGESTION_GRPS      256 /**< Total number of congestion groups in QM */
+/* @} */
+
+
+/**************************************************************************//**
+ @Description   struct for defining port PCD modes
+*//***************************************************************************/
+typedef enum ioc_fm_port_pcd_support {
+    e_IOC_FM_PORT_PCD_SUPPORT_NONE,                 /**< BMI to BMI, PCD is not used */
+    e_IOC_FM_PORT_PCD_SUPPORT_PRS_ONLY,             /**< Use only Parser */
+    e_IOC_FM_PORT_PCD_SUPPORT_PLCR_ONLY,            /**< Use only Policer */
+    e_IOC_FM_PORT_PCD_SUPPORT_PRS_AND_PLCR,         /**< Use Parser and Policer */
+    e_IOC_FM_PORT_PCD_SUPPORT_PRS_AND_KG,           /**< Use Parser and Keygen */
+    e_IOC_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC,    /**< Use Parser, Keygen and Coarse Classification */
+    e_IOC_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC_AND_PLCR, /**< Use all PCD engines */
+    e_IOC_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_PLCR   /**< Use Parser, Keygen and Policer */
+} ioc_fm_port_pcd_support;
+
+/**************************************************************************//**
+ @Description   enum for defining FM Port counters
+*//***************************************************************************/
+typedef enum fm_port_counters {
+    e_IOC_FM_PORT_COUNTERS_CYCLE,                       /**< BMI performance counter */
+    e_IOC_FM_PORT_COUNTERS_TASK_UTIL,                   /**< BMI performance counter */
+    e_IOC_FM_PORT_COUNTERS_QUEUE_UTIL,                  /**< BMI performance counter */
+    e_IOC_FM_PORT_COUNTERS_DMA_UTIL,                    /**< BMI performance counter */
+    e_IOC_FM_PORT_COUNTERS_FIFO_UTIL,                   /**< BMI performance counter */
+    e_IOC_FM_PORT_COUNTERS_RX_PAUSE_ACTIVATION,         /**< BMI Rx only performance counter */
+    e_IOC_FM_PORT_COUNTERS_FRAME,                       /**< BMI statistics counter */
+    e_IOC_FM_PORT_COUNTERS_DISCARD_FRAME,               /**< BMI statistics counter */
+    e_IOC_FM_PORT_COUNTERS_DEALLOC_BUF,                 /**< BMI deallocate buffer statistics counter */
+    e_IOC_FM_PORT_COUNTERS_RX_BAD_FRAME,                /**< BMI Rx only statistics counter */
+    e_IOC_FM_PORT_COUNTERS_RX_LARGE_FRAME,              /**< BMI Rx only statistics counter */
+    e_IOC_FM_PORT_COUNTERS_RX_OUT_OF_BUFFERS_DISCARD,   /**< BMI Rx only statistics counter */
+    e_IOC_FM_PORT_COUNTERS_RX_FILTER_FRAME,             /**< BMI Rx & OP only statistics counter */
+    e_IOC_FM_PORT_COUNTERS_RX_LIST_DMA_ERR,             /**< BMI Rx, OP & HC only statistics counter */
+    e_IOC_FM_PORT_COUNTERS_WRED_DISCARD,                /**< BMI OP & HC only statistics counter */
+    e_IOC_FM_PORT_COUNTERS_LENGTH_ERR,                  /**< BMI non-Rx statistics counter */
+    e_IOC_FM_PORT_COUNTERS_UNSUPPRTED_FORMAT,           /**< BMI non-Rx statistics counter */
+    e_IOC_FM_PORT_COUNTERS_DEQ_TOTAL,                   /**< QMI counter */
+    e_IOC_FM_PORT_COUNTERS_ENQ_TOTAL,                   /**< QMI counter */
+    e_IOC_FM_PORT_COUNTERS_DEQ_FROM_DEFAULT,            /**< QMI counter */
+    e_IOC_FM_PORT_COUNTERS_DEQ_CONFIRM                  /**< QMI counter */
+} fm_port_counters;
+
+
+/**************************************************************************//**
+ @Description   Structure for Port id parameters.
+                Fields commented 'IN' are passed by the port module to be used
+                by the FM module.
+                Fields commented 'OUT' will be filled by FM before returning to port.
+*//***************************************************************************/
+typedef struct ioc_fm_port_congestion_groups_t {
+    uint16_t    num_of_congestion_grps_to_consider; /**< Size of congestion_grps_to_consider array */
+    uint8_t     congestion_grps_to_consider [IOC_FM_PORT_NUM_OF_CONGESTION_GRPS];   /**< list of congestion groups */
+} ioc_fm_port_congestion_groups_t;
+
+
+/**************************************************************************//**
+ @Function      FM_PORT_IOC_DISABLE
+
+ @Description   Gracefully disable an FM port. The port will not start new tasks after all
+                tasks associated with the port are terminated.
+
+ @Return        0 on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+                This is a blocking routine, it returns after port is
+                gracefully stopped, i.e. the port will not except new frames,
+                but it will finish all frames or tasks which were already began
+*//***************************************************************************/
+#define FM_PORT_IOC_DISABLE   _IO(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(1))
+
+/**************************************************************************//**
+ @Function      FM_PORT_IOC_ENABLE
+
+ @Description   A runtime routine provided to allow disable/enable of port.
+
+ @Return        0 on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+#define FM_PORT_IOC_ENABLE   _IO(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(2))
+
+/**************************************************************************//**
+ @Function      FM_PORT_IOC_SET_ERRORS_ROUTE
+
+ @Description   Errors selected for this routine will cause a frame with that error
+                to be enqueued to error queue.
+                Errors not selected for this routine will cause a frame with that error
+                to be enqueued to the one of the other port queues.
+                By default all errors are defined to be enqueued to error queue.
+                Errors that were configured to be discarded (at initialization)
+                may not be selected here.
+
+                May be used for Rx and offline parsing ports only
+
+ @Param[in]     ioc_fm_port_frame_err_select_t  A list of errors to enqueue to error queue
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+#define FM_PORT_IOC_SET_ERRORS_ROUTE   _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(3), ioc_fm_port_frame_err_select_t)
+
+/**************************************************************************//**
+ @Group         lnx_ioctl_FM_PORT_pcd_runtime_control_grp FM Port PCD Runtime Control Unit
+
+ @Description   FM Port PCD Runtime control unit API functions, definitions and enums.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description   A structure of scheme parameters
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_kg_scheme_select_t {
+    bool        direct;                     /**< TRUE is the scheme should be accessed directly */
+    void        *scheme_id;                 /**< Scheme id */
+} ioc_fm_pcd_kg_scheme_select_t;
+
+/**************************************************************************//**
+ @Description    A structure for defining the Parser starting point
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_prs_start_t {
+    uint8_t             parsing_offset; /**< Number of bytes from begining of packet to
+                                             start parsing */
+    ioc_net_header_type first_prs_hdr;  /**< The type of the first header axpected at
+                                             'parsingOffset' */
+} ioc_fm_pcd_prs_start_t;
+
+/**************************************************************************//**
+ @Description   Scheme is'd structure
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_port_schemes_params_t {
+    uint8_t     num_of_schemes;
+    void        *schemes_ids [IOC_FM_PCD_KG_NUM_OF_SCHEMES];
+} ioc_fm_pcd_port_schemes_params_t;
+
+/**************************************************************************//**
+ @Description   classification-plan-group structure
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_port_cls_plan_params_t {
+    bool        use_cls_plan;       /**< TRUE to use a pre-defined group, FALSE to stop using one. */
+    void        *new_cls_plan_grp;  /**< An id of a classification plan group that was already set. */
+} ioc_fm_pcd_port_cls_plan_params_t;
+
+/**************************************************************************//**
+ @Description   Union for defining port protocol parameters for parser
+*//***************************************************************************/
+typedef union ioc_fm_pcd_hdr_prs_opts_u {
+    /* MPLS */
+    struct {
+        bool                label_interpretation_enable;/**< When this bit is set, the last MPLS label will be
+                                                             interpreted as described in HW spec table. When the bit
+                                                             is cleared, the parser will advance to MPLS next parse */
+        ioc_net_header_type next_parse;                 /**< must be equal or higher than IPv4 */
+    } mpls_prs_options;
+    /* VLAN */
+    struct {
+        uint16_t            tag_protocol_id1;           /**< User defined Tag Protocol Identifier, to be recognized
+                                                             on VLAN TAG on top of 0x8100 and 0x88A8 */
+        uint16_t            tag_protocol_id2;           /**< User defined Tag Protocol Identifier, to be recognized
+                                                             on VLAN TAG on top of 0x8100 and 0x88A8 */
+    } vlan_prs_options;
+    /* IPV6 */
+    struct {
+        bool                routing_hdr_disable;        /**< Disable routing header */
+    } ipv6_prs_options;
+
+    /* UDP */
+    struct {
+        bool                pad_ignore_checksum;        /**< TRUE to ignore pad in checksum */
+    } udp_prs_options;
+
+    /* TCP */
+    struct {
+        bool                pad_ignore_checksum;        /**< TRUE to ignore pad in checksum */
+    } tcp_prs_options;
+} ioc_fm_pcd_hdr_prs_opts_u;
+
+
+/**************************************************************************//**
+ @Description   A structure for defining each header for the parser
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_prs_additional_hdr_params_t {
+    ioc_net_header_type         hdr;                /**< Selected header */
+    bool                        err_disable;        /**< TRUE to disable error indication */
+    bool                        soft_prs_enable;    /**< Enable jump to SW parser when this
+                                                         header is recognized by the HW parser. */
+    char                        *soft_prs_label;    /**< Label of SW parser to jump to. */
+    bool                        use_prs_opts;       /**< TRUE to use parser options. */
+    ioc_fm_pcd_hdr_prs_opts_u   prs_opts;           /**< A unuion according to header type,
+                                                         defining the parser options selected.*/
+} ioc_fm_pcd_prs_additional_hdr_params_t;
+
+/**************************************************************************//**
+ @Description   struct for defining port PCD parameters
+*//***************************************************************************/
+typedef struct ioc_fm_port_pcd_prs_params_t {
+    uint8_t                                 prs_res_priv_info;          /**< The private info provides a method of inserting
+                                                                             port information into the parser result. This information
+                                                                             may be extracted by Keygen and be used for frames
+                                                                             distribution when a per-port distinction is required,
+                                                                             it may also be used as a port logical id for analyazing
+                                                                             incoming frames. */
+    uint8_t                                 parsing_offset;             /**< Number of bytes from begining of packet to
+                                                                             start parsing */
+    ioc_net_header_type                     first_prs_hdr;              /**< The type of the first header axpected at
+                                                                             'parsingOffset' */
+    bool                                    include_in_prs_statistics;  /**< TRUE to include this port in the parser statistics.*/
+    uint8_t                                 num_of_hdrs_with_additional_params;
+                                                        /**< Normally 0, some headers may get
+                                                             special parameters */
+    ioc_fm_pcd_prs_additional_hdr_params_t  additional_params[IOC_FM_PCD_PRS_NUM_OF_HDRS];
+                                                        /**< A structure of additional parameters
+                                                             for each header that requires them */
+    bool                                    set_vlan_tpid1;             /**< TRUE to configure user selection of Ethertype to
+                                                                             indicate a VLAN tag (in addition to the TPID values
+                                                                             0x8100 and 0x88A8). */
+    uint16_t                                vlan_tpid1;                 /**< extra tag to use if setVlanTpid1=TRUE. */
+    bool                                    set_vlan_tpid2;             /**< TRUE to configure user selection of Ethertype to
+                                                                             indicate a VLAN tag (in addition to the TPID values
+                                                                             0x8100 and 0x88A8). */
+    uint16_t                                vlan_tpid2;                 /**< extra tag to use if setVlanTpid1=TRUE. */
+} ioc_fm_port_pcd_prs_params_t;
+
+/**************************************************************************//**
+ @Description   struct for defining coarse alassification parameters
+*//***************************************************************************/
+typedef struct ioc_fm_port_pcd_cc_params_t {
+    void                *cc_tree_id; /**< CC tree id */
+} ioc_fm_port_pcd_cc_params_t;
+
+/**************************************************************************//**
+ @Description   struct for defining keygen parameters
+*//***************************************************************************/
+typedef struct ioc_fm_port_pcd_kg_params_t {
+    uint8_t             num_of_schemes;                 /**< Number of schemes for port to be bound to. */
+    void                *schemes_ids[IOC_FM_PCD_KG_NUM_OF_SCHEMES];
+                                                        /**< Array of 'numOfSchemes' schemes for the
+                                                             port to be bound to */
+    bool                use_cls_plan;                   /**< TRUE to use the classification plan mechanism */
+    void                *cls_plan_grp_id;               /**< clsPlan must be of the same netEnvId
+                                                             of this port */
+    bool                direct_scheme;                  /**< TRUE for going from parser to a specific scheme,
+                                                             regardless of parser result */
+    void                *direct_scheme_id;              /**< relevant only if direct == TRUE */
+} ioc_fm_port_pcd_kg_params_t;
+
+/**************************************************************************//**
+ @Description   struct for defining policer parameters
+*//***************************************************************************/
+typedef struct ioc_fm_port_pcd_plcr_params_t {
+    void                *plcr_profile_id;               /**< relevant only if
+                                                             e_IOC_FM_PCD_SUPPORT_PLCR_ONLY or
+                                                             e_IOC_FM_PCD_SUPPORT_PRS_AND_PLCR were selected */
+} ioc_fm_port_pcd_plcr_params_t;
+
+/**************************************************************************//**
+ @Description   struct for defining port PCD parameters
+*//***************************************************************************/
+typedef struct ioc_fm_port_pcd_params_t {
+    ioc_fm_port_pcd_support         pcd_support;    /**< Relevant for Rx and offline ports only.
+                                                         Describes the active PCD engines for this port. */
+    void                            *net_env_id;    /**< HL Unused in PLCR only mode */
+    ioc_fm_port_pcd_prs_params_t    *p_prs_params;  /**< Parser parameters for this port */
+    ioc_fm_port_pcd_cc_params_t     *p_cc_params;   /**< Coarse classification parameters for this port */
+    ioc_fm_port_pcd_kg_params_t     *p_kg_params;   /**< Keygen parameters for this port */
+    ioc_fm_port_pcd_plcr_params_t   *p_plcr_params; /**< Policer parameters for this port */
+} ioc_fm_port_pcd_params_t;
+
+/**************************************************************************//**
+ @Description   FQID parameters structure
+*//***************************************************************************/
+typedef struct ioc_fm_port_pcd_fqids_params_t {
+    uint32_t            num_fqids;  /**< Number of fqids to be allocated for the port */
+    uint8_t             alignment;  /**< Alignment required for this port */
+    uint32_t            base_fqid;  /**< output parameter - the base fqid */
+} ioc_fm_port_pcd_fqids_params_t;
+
+
+/**************************************************************************//**
+ @Function      FM_PORT_IOC_ALLOC_PCD_FQIDS
+
+ @Description   Allocates FQID's
+
+                May be used for Rx and offline parsing ports only
+
+ @Param[in,out] ioc_fm_port_pcd_fqids_params_t  Parameters for allocating FQID's
+
+ @Return        0 on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+#define FM_PORT_IOC_ALLOC_PCD_FQIDS   _IOWR(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(19), ioc_fm_port_pcd_fqids_params_t)
+
+/**************************************************************************//**
+ @Function      FM_PORT_IOC_SET_PCD
+
+ @Description   Calling this routine defines the port's PCD configuration.
+                It changes it from its default configuration which is PCD
+                disabled (BMI to BMI) and configures it according to the passed
+                parameters.
+
+                May be used for Rx and offline parsing ports only
+
+ @Param[in]     ioc_fm_port_pcd_params_t    A Structure of parameters defining the port's PCD
+                                            configuration.
+
+ @Return        0 on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+#define FM_PORT_IOC_SET_PCD _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(20), ioc_fm_port_pcd_params_t)
+
+/**************************************************************************//**
+ @Function      FM_PORT_IOC_DELETE_PCD
+
+ @Description   Calling this routine releases the port's PCD configuration.
+                The port returns to its default configuration which is PCD
+                disabled (BMI to BMI) and all PCD configuration is removed.
+
+                May be used for Rx and offline parsing ports which are
+                in PCD mode  only
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+#define FM_PORT_IOC_DELETE_PCD _IO(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(21))
+
+/**************************************************************************//**
+ @Function      FM_PORT_IOC_DETACH_PCD
+
+ @Description   Calling this routine detaches the port from its PCD functionality.
+                The port returns to its default flow which is BMI to BMI.
+
+                May be used for Rx and offline parsing ports which are
+                in PCD mode only
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+#define FM_PORT_IOC_DETACH_PCD _IO(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(22))
+
+/**************************************************************************//**
+ @Function      FM_PORT_IOC_ATTACH_PCD
+
+ @Description   This routine may be called after FM_PORT_DetachPCD was called,
+                to return to the originally configured PCD support flow.
+                The couple of routines are used to allow PCD configuration changes
+                that demand that PCD will not be used while changes take place.
+
+                May be used for Rx and offline parsing ports which are
+                in PCD mode only
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+#define FM_PORT_IOC_ATTACH_PCD _IO(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(23))
+
+/**************************************************************************//**
+ @Function      FM_PORT_IOC_PCD_PLCR_ALLOC_PROFILES
+
+ @Description   This routine may be called only for ports that use the Policer in
+                order to allocate private policer profiles.
+
+ @Param[in]     uint16_t       The number of required policer profiles
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init() and FM_PCD_Init(), and before FM_PORT_SetPCD().
+*//***************************************************************************/
+#define FM_PORT_IOC_PCD_PLCR_ALLOC_PROFILES     _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(24), uint16_t)
+
+/**************************************************************************//**
+ @Function      FM_PORT_IOC_PCD_PLCR_FREE_PROFILES
+
+ @Description   This routine should be called for freeing private policer profiles.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init() and FM_PCD_Init(), and before FM_PORT_SetPCD().
+*//***************************************************************************/
+#define FM_PORT_IOC_PCD_PLCR_FREE_PROFILES     _IO(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(25))
+
+/**************************************************************************//**
+ @Function      FM_PORT_IOC_PCD_KG_MODIFY_INITIAL_SCHEME
+
+ @Description   This routine may be called only for ports that use the keygen in
+                order to change the initial scheme frame should be routed to.
+                The change may be of a scheme id (in case of direct mode),
+                from direct to indirect, or from indirect to direct - specifying the scheme id.
+
+ @Param[in]     ioc_fm_pcd_kg_scheme_select_t   A structure of parameters for defining whether
+                                                a scheme is direct/indirect, and if direct - scheme id.
+
+ @Return        0 on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+#define FM_PORT_IOC_PCD_KG_MODIFY_INITIAL_SCHEME _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(26), ioc_fm_pcd_kg_scheme_select_t)
+
+/**************************************************************************//**
+ @Function      FM_PORT_IOC_PCD_PLCR_MODIFY_INITIAL_PROFILE
+
+ @Description   This routine may be called for ports with flows e_IOC_FM_PCD_SUPPORT_PLCR_ONLY or
+                e_IOC_FM_PCD_SUPPORT_PRS_AND_PLCR  only, to change the initial Policer profile frame
+                should be routed to. The change may be of a profile and/or absolute/direct mode
+                selection.
+
+ @Param[in]     ioc_fm_obj_t       Policer profile Id as returned from FM_PCD_PlcrSetProfile.
+
+ @Return        0 on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+#define FM_PORT_IOC_PCD_PLCR_MODIFY_INITIAL_PROFILE _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(27), ioc_fm_obj_t)
+
+/**************************************************************************//**
+ @Function      FM_PORT_IOC_PCD_CC_MODIFY_TREE
+
+ @Description   This routine may be called to change this port connection to
+                a pre-initializes coarse classification Tree.
+
+ @Param[in]     ioc_fm_obj_t    Id of new coarse classification tree selected for this port.
+
+ @Return        0 on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+#define FM_PORT_IOC_PCD_CC_MODIFY_TREE _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(28), ioc_fm_obj_t)
+
+/**************************************************************************//**
+ @Function      FM_PORT_IOC_PCD_KG_MODIFY_CLS_PLAN_GRP
+
+ @Description   This routine may be called for ports using the KG functionality of the PCD,
+                if the user wishes to replace the classification plan
+                group that the port uses, to start using the classification plan mechanism or to stop
+                using it. The routine may not be called while port
+                receives packets using the PCD functionalities, therefor port must be first detached
+                from the PCD, only than the routine may be called, and than port be attached to PCD again.
+
+ @Param[in]     ioc_fm_pcd_port_cls_plan_params_t  the parameters of the new classification-plan-group
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init(), FM_PORT_SetPCD() and FM_PORT_DetachPCD()
+*//***************************************************************************/
+#define FM_PORT_IOC_PCD_KG_MODIFY_CLS_PLAN_GRP _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(29), ioc_fm_pcd_port_cls_plan_params_t)
+
+/**************************************************************************//**
+ @Function      FM_PORT_IOC_PCD_KG_BIND_SCHEMES
+
+ @Description   These routines may be called for modifying the binding of ports
+                to schemes. The scheme itself is not added,
+                just this specific port starts using it.
+
+ @Param[in]     ioc_fm_pcd_port_schemes_params_t    Schemes parameters structre
+
+ @Return        0 on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+#define FM_PORT_IOC_PCD_KG_BIND_SCHEMES _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(30), ioc_fm_pcd_port_schemes_params_t)
+
+/**************************************************************************//**
+ @Function      FM_PORT_IOC_PCD_KG_UNBIND_SCHEMES
+
+ @Description   These routines may be called for modifying the binding of ports
+                to schemes. The scheme itself is not removed or invalidated,
+                just this specific port stops using it.
+
+ @Param[in]     ioc_fm_pcd_port_schemes_params_t    Schemes parameters structre
+
+ @Return        0 on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+#define FM_PORT_IOC_PCD_KG_UNBIND_SCHEMES _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(31), ioc_fm_pcd_port_schemes_params_t)
+
+/**************************************************************************//**
+ @Function      FM_PORT_IOC_PCD_PRS_MODIFY_START_OFFSET
+
+ @Description   Runtime change of the parser start offset within the header.
+
+ @Param[in]     ioc_fm_pcd_prs_start_t  A structure of parameters for defining the
+                                        start point for the parser.
+
+ @Return        0 on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+#define      FM_PORT_IOC_PCD_PRS_MODIFY_START_OFFSET _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(32), ioc_fm_pcd_prs_start_t)
+
+/** @} */ /* end of lnx_ioctl_FM_PORT_pcd_runtime_control_grp group */
+/** @} */ /* end of lnx_ioctl_FM_PORT_runtime_control_grp group */
+/** @} */ /* end of lnx_ioctl_FM_PORT_grp group */
+/** @} */ /* end of lnx_ioctl_FM_grp group */
+
+
+#endif /* __FM_PORT_IOCTLS_H */
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/Peripherals/fm_test_ioctls.h b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/Peripherals/fm_test_ioctls.h
new file mode 100644
index 0000000..848ba0f
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/Peripherals/fm_test_ioctls.h
@@ -0,0 +1,159 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**************************************************************************//**
+ @File          fm_test_ioctls.h
+
+ @Description   FM Char device ioctls
+*//***************************************************************************/
+#ifndef __FM_TEST_IOCTLS_H
+#define __FM_TEST_IOCTLS_H
+
+#include "ioctls.h"
+
+
+/**************************************************************************//**
+ @Group         lnx_ioctl_FMT_grp Frame Manager Test Linux IOCTL API
+
+ @Description   FM-Test Linux ioctls definitions and enums
+
+ @{
+*//***************************************************************************/
+
+#define IOC_FMT_MAX_NUM_OF_PORTS        24
+
+/**************************************************************************//**
+ @Collection    TBD
+*//***************************************************************************/
+/**************************************************************************//**
+  @Description: Name of the FM-Test chardev
+*//***************************************************************************/
+#define DEV_FM_TEST_NAME                "fm-test-port"
+
+#define DEV_FM_TEST_PORTS_MINOR_BASE    0
+#define DEV_FM_TEST_MAX_MINORS          (DEV_FM_TEST_PORTS_MINOR_BASE + IOC_FMT_MAX_NUM_OF_PORTS)
+
+#define FMT_PORT_IOC_NUM(n)             n
+/* @} */
+
+/**************************************************************************//**
+ @Group         lnx_ioctl_FMT_lib_grp FM-Test library
+
+ @Description   TBD
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description   TBD
+*//***************************************************************************/
+typedef uint8_t ioc_fmt_xxx_t;
+
+
+/**************************************************************************//**
+ @Description   TBD
+*//***************************************************************************/
+typedef struct ioc_fmt_buff_context_t {
+    void            *p_user_priv;
+    uint8_t         fm_prs_res[32];
+    uint8_t         fm_time_stamp[8];
+} ioc_fmt_buff_context_t;
+
+
+/**************************************************************************//**
+ @Description   TBD
+*//***************************************************************************/
+typedef struct ioc_fmt_buff_desc_t {
+    uint32_t               qid;
+    void                   *p_data;
+    uint32_t               size;
+    uint32_t               status;
+    ioc_fmt_buff_context_t buff_context;
+} ioc_fmt_buff_desc_t;
+
+
+/**************************************************************************//**
+ @Group         lnx_ioctl_FMT_runtime_control_grp FM-Test Runtime Control Unit
+
+ @Description   TBD
+ @{
+*//***************************************************************************/
+
+/** @} */ /* end of lnx_ioctl_FMT_runtime_control_grp group */
+
+
+/**************************************************************************//**
+ @Group         lnx_ioctl_FMTP_lib_grp FM-Port-Test library
+
+ @Description   TBD
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description   FM-Test TBD
+*//***************************************************************************/
+typedef enum ioc_fmt_port_type {
+    e_IOC_FMT_PORT_T_RXTX,  /**< Standard port */
+    e_IOC_FMT_PORT_T_OP,    /**< Offline-parsing port */
+} ioc_fmt_port_type;
+
+/**************************************************************************//**
+ @Description   TBD
+*//***************************************************************************/
+typedef struct ioc_fmt_port_param_t {
+    uint8_t             fm_id;
+    ioc_fmt_port_type   fm_port_type;
+    uint8_t             fm_port_id;
+    uint32_t            num_tx_queues;
+} ioc_fmt_port_param_t;
+
+
+/**************************************************************************//**
+ @Function      FMT_PORT_IOC_INIT
+
+ @Description   TBD
+
+ @Param[in]    ioc_fmt_port_param_t  TBD
+
+ @Return        None.
+
+ @Cautions      Allowed only following FM_Init().
+*//***************************************************************************/
+#define FMT_PORT_IOC_INIT   _IOW(FMT_IOC_TYPE_BASE, FMT_PORT_IOC_NUM(0), ioc_fmt_port_param_t)
+
+/** @} */ /* end of lnx_ioctl_FMTP_lib_grp group */
+/** @} */ /* end of lnx_ioctl_FMT_lib_grp group */
+/** @} */ /* end of lnx_ioctl_FMT_grp */
+
+
+#endif /* __FM_TEST_IOCTLS_H */
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/integrations/P4080/integration_ioctls.h b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/integrations/P4080/integration_ioctls.h
new file mode 100644
index 0000000..5396f3c
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/integrations/P4080/integration_ioctls.h
@@ -0,0 +1,47 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**************************************************************************//**
+ @File          integration_ioctls.h
+
+ @Description   External header file for Integration unit routines.
+*//***************************************************************************/
+
+#ifndef __INTG_IOCTLS_H
+#define __INTG_IOCTLS_H
+
+
+#define FM_IOC_TYPE_BASE            (NCSW_IOC_TYPE_BASE+1)
+#define FMT_IOC_TYPE_BASE           (NCSW_IOC_TYPE_BASE+2)
+
+
+#endif /* __INTG_IOCTLS_H */
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/ioctls.h b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/ioctls.h
new file mode 100644
index 0000000..151a0f4
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/ioctls.h
@@ -0,0 +1,84 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**************************************************************************//**
+ @File          ioctls.h
+
+ @Description   Structures and definitions for Command Relay Ioctls
+*//***************************************************************************/
+
+#ifndef __IOCTLS_H__
+#define __IOCTLS_H__
+
+#include <asm/ioctl.h>
+
+#include "integration_ioctls.h"
+
+
+/**************************************************************************//**
+ @Group         lnx_ioctl_ncsw_grp    NeCommSw Linux User-Space (IOCTL) API
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Collection    TBD
+*//***************************************************************************/
+#define NCSW_IOC_TYPE_BASE          0xe0
+/* @} */
+
+
+/**************************************************************************//**
+ @Description   IOCTL Memory allocation types.
+*//***************************************************************************/
+typedef enum ioc_mem_type {
+    e_IOC_MEM_INVALID      = 0x00000000,  /**< Invalid memory type (error) */
+    e_IOC_MEM_CACHABLE_SYS = 0x00000001,  /**< Primary DDR, cacheable segment */
+    e_IOC_MEM_NOCACHE_SYS  = 0x00000004,  /**< Primary DDR, non-cacheable segment */
+    e_IOC_MEM_SECONDARY    = 0x00000002,  /**< Either secondary DDR or SDRAM */
+    e_IOC_MEM_PRAM         = 0x00000008   /**< Multi-user RAM identifier */
+} ioc_mem_type;
+
+/**************************************************************************//**
+ @Description   Enumeration (bit flags) of communication modes (Transmit,
+                receive or both).
+*//***************************************************************************/
+typedef enum ioc_comm_mode {
+      e_IOC_COMM_MODE_NONE         = 0  /**< No transmit/receive communication */
+    , e_IOC_COMM_MODE_RX           = 1  /**< Only receive communication */
+    , e_IOC_COMM_MODE_TX           = 2  /**< Only transmit communication */
+    , e_IOC_COMM_MODE_RX_AND_TX    = 3  /**< Both transmit and receive communication */
+} ioc_comm_mode;
+
+/** @} */ /* end of lnx_ioctl_ncsw_grp */
+
+
+#endif /* __IOCTLS_H__ */
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/net_ioctls.h b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/net_ioctls.h
new file mode 100644
index 0000000..c26e6d4
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/net_ioctls.h
@@ -0,0 +1,365 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**************************************************************************//**
+ @File          net_ioctls.h
+
+ @Description   This file contains common and general netcomm headers definitions.
+*//***************************************************************************/
+#ifndef __NET_IOCTLS_H
+#define __NET_IOCTLS_H
+
+#include "ioctls.h"
+
+
+typedef uint8_t ioc_header_field_ppp_t;
+
+#define IOC_NET_HEADER_FIELD_PPP_PID                        (1)
+#define IOC_NET_HEADER_FIELD_PPP_COMPRESSED                 (IOC_NET_HEADER_FIELD_PPP_PID << 1)
+#define IOC_NET_HEADER_FIELD_PPP_ALL_FIELDS                 ((IOC_NET_HEADER_FIELD_PPP_PID << 2) - 1)
+
+
+typedef uint8_t ioc_header_field_pppoe_t;
+
+#define IOC_NET_HEADER_FIELD_PPPoE_VER                      (1)
+#define IOC_NET_HEADER_FIELD_PPPoE_TYPE                     (IOC_NET_HEADER_FIELD_PPPoE_VER << 1)
+#define IOC_NET_HEADER_FIELD_PPPoE_CODE                     (IOC_NET_HEADER_FIELD_PPPoE_VER << 2)
+#define IOC_NET_HEADER_FIELD_PPPoE_SID                      (IOC_NET_HEADER_FIELD_PPPoE_VER << 3)
+#define IOC_NET_HEADER_FIELD_PPPoE_LEN                      (IOC_NET_HEADER_FIELD_PPPoE_VER << 4)
+#define IOC_NET_HEADER_FIELD_PPPoE_SESSION                  (IOC_NET_HEADER_FIELD_PPPoE_VER << 5)
+#define IOC_NET_HEADER_FIELD_PPPoE_PID                      (IOC_NET_HEADER_FIELD_PPPoE_VER << 6)
+#define IOC_NET_HEADER_FIELD_PPPoE_ALL_FIELDS               ((IOC_NET_HEADER_FIELD_PPPoE_VER << 7) - 1)
+
+#define IOC_NET_HEADER_FIELD_PPPMUX_PID                     (1)
+#define IOC_NET_HEADER_FIELD_PPPMUX_CKSUM                   (IOC_NET_HEADER_FIELD_PPPMUX_PID << 1)
+#define IOC_NET_HEADER_FIELD_PPPMUX_COMPRESSED              (IOC_NET_HEADER_FIELD_PPPMUX_PID << 2)
+#define IOC_NET_HEADER_FIELD_PPPMUX_ALL_FIELDS              ((IOC_NET_HEADER_FIELD_PPPMUX_PID << 3) - 1)
+
+#define IOC_NET_HEADER_FIELD_PPPMUX_SUBFRAME_PFF            (1)
+#define IOC_NET_HEADER_FIELD_PPPMUX_SUBFRAME_LXT            (IOC_NET_HEADER_FIELD_PPPMUX_SUBFRAME_PFF << 1)
+#define IOC_NET_HEADER_FIELD_PPPMUX_SUBFRAME_LEN            (IOC_NET_HEADER_FIELD_PPPMUX_SUBFRAME_PFF << 2)
+#define IOC_NET_HEADER_FIELD_PPPMUX_SUBFRAME_PID            (IOC_NET_HEADER_FIELD_PPPMUX_SUBFRAME_PFF << 3)
+#define IOC_NET_HEADER_FIELD_PPPMUX_SUBFRAME_USE_PID        (IOC_NET_HEADER_FIELD_PPPMUX_SUBFRAME_PFF << 4)
+#define IOC_NET_HEADER_FIELD_PPPMUX_SUBFRAME_ALL_FIELDS     ((IOC_NET_HEADER_FIELD_PPPMUX_SUBFRAME_PFF << 5) - 1)
+
+
+typedef uint8_t ioc_header_field_eth_t;
+
+#define IOC_NET_HEADER_FIELD_ETH_DA                         (1)
+#define IOC_NET_HEADER_FIELD_ETH_SA                         (IOC_NET_HEADER_FIELD_ETH_DA << 1)
+#define IOC_NET_HEADER_FIELD_ETH_LENGTH                     (IOC_NET_HEADER_FIELD_ETH_DA << 2)
+#define IOC_NET_HEADER_FIELD_ETH_TYPE                       (IOC_NET_HEADER_FIELD_ETH_DA << 3)
+#define IOC_NET_HEADER_FIELD_ETH_FINAL_CKSUM                (IOC_NET_HEADER_FIELD_ETH_DA << 4)
+#define IOC_NET_HEADER_FIELD_ETH_PADDING                    (IOC_NET_HEADER_FIELD_ETH_DA << 5)
+#define IOC_NET_HEADER_FIELD_ETH_ALL_FIELDS                 ((IOC_NET_HEADER_FIELD_ETH_DA << 6) - 1)
+
+
+typedef uint16_t ioc_header_field_ipv4_t;
+
+#define IOC_NET_HEADER_FIELD_IPv4_VER                       (1)
+#define IOC_NET_HEADER_FIELD_IPv4_HDR_LEN                   (IOC_NET_HEADER_FIELD_IPv4_VER << 1)
+#define IOC_NET_HEADER_FIELD_IPv4_TOS                       (IOC_NET_HEADER_FIELD_IPv4_VER << 2)
+#define IOC_NET_HEADER_FIELD_IPv4_TOTAL_LEN                 (IOC_NET_HEADER_FIELD_IPv4_VER << 3)
+#define IOC_NET_HEADER_FIELD_IPv4_ID                        (IOC_NET_HEADER_FIELD_IPv4_VER << 4)
+#define IOC_NET_HEADER_FIELD_IPv4_FLAG_D                    (IOC_NET_HEADER_FIELD_IPv4_VER << 5)
+#define IOC_NET_HEADER_FIELD_IPv4_FLAG_M                    (IOC_NET_HEADER_FIELD_IPv4_VER << 6)
+#define IOC_NET_HEADER_FIELD_IPv4_OFFSET                    (IOC_NET_HEADER_FIELD_IPv4_VER << 7)
+#define IOC_NET_HEADER_FIELD_IPv4_TTL                       (IOC_NET_HEADER_FIELD_IPv4_VER << 8)
+#define IOC_NET_HEADER_FIELD_IPv4_PROTO                     (IOC_NET_HEADER_FIELD_IPv4_VER << 9)
+#define IOC_NET_HEADER_FIELD_IPv4_CKSUM                     (IOC_NET_HEADER_FIELD_IPv4_VER << 10)
+#define IOC_NET_HEADER_FIELD_IPv4_SRC_IP                    (IOC_NET_HEADER_FIELD_IPv4_VER << 11)
+#define IOC_NET_HEADER_FIELD_IPv4_DST_IP                    (IOC_NET_HEADER_FIELD_IPv4_VER << 12)
+#define IOC_NET_HEADER_FIELD_IPv4_OPTS                      (IOC_NET_HEADER_FIELD_IPv4_VER << 13)
+#define IOC_NET_HEADER_FIELD_IPv4_OPTS_COUNT                (IOC_NET_HEADER_FIELD_IPv4_VER << 14)
+#define IOC_NET_HEADER_FIELD_IPv4_ALL_FIELDS                ((IOC_NET_HEADER_FIELD_IPv4_VER << 15) - 1)
+
+
+typedef uint8_t ioc_header_field_ipv6_t;
+
+#define IOC_NET_HEADER_FIELD_IPv6_VER                       (1)
+#define IOC_NET_HEADER_FIELD_IPv6_TC                        (IOC_NET_HEADER_FIELD_IPv6_VER << 1)
+#define IOC_NET_HEADER_FIELD_IPv6_SRC_IP                    (IOC_NET_HEADER_FIELD_IPv6_VER << 2)
+#define IOC_NET_HEADER_FIELD_IPv6_DST_IP                    (IOC_NET_HEADER_FIELD_IPv6_VER << 3)
+#define IOC_NET_HEADER_FIELD_IPv6_NEXT_HDR                  (IOC_NET_HEADER_FIELD_IPv6_VER << 4)
+#define IOC_NET_HEADER_FIELD_IPv6_FL                        (IOC_NET_HEADER_FIELD_IPv6_VER << 5)
+#define IOC_NET_HEADER_FIELD_IPv6_HOP_LIMIT                 (IOC_NET_HEADER_FIELD_IPv6_VER << 6)
+#define IOC_NET_HEADER_FIELD_IPv6_ALL_FIELDS                ((IOC_NET_HEADER_FIELD_IPv6_VER << 7) - 1)
+
+#define IOC_NET_HEADER_FIELD_ICMP_TYPE                      (1)
+#define IOC_NET_HEADER_FIELD_ICMP_CODE                      (IOC_NET_HEADER_FIELD_ICMP_TYPE << 1)
+#define IOC_NET_HEADER_FIELD_ICMP_CKSUM                     (IOC_NET_HEADER_FIELD_ICMP_TYPE << 2)
+#define IOC_NET_HEADER_FIELD_ICMP_ID                        (IOC_NET_HEADER_FIELD_ICMP_TYPE << 3)
+#define IOC_NET_HEADER_FIELD_ICMP_SQ_NUM                    (IOC_NET_HEADER_FIELD_ICMP_TYPE << 4)
+#define IOC_NET_HEADER_FIELD_ICMP_ALL_FIELDS                ((IOC_NET_HEADER_FIELD_ICMP_TYPE << 5) - 1)
+
+#define IOC_NET_HEADER_FIELD_IGMP_VERSION                   (1)
+#define IOC_NET_HEADER_FIELD_IGMP_TYPE                      (IOC_NET_HEADER_FIELD_IGMP_VERSION << 1)
+#define IOC_NET_HEADER_FIELD_IGMP_CKSUM                     (IOC_NET_HEADER_FIELD_IGMP_VERSION << 2)
+#define IOC_NET_HEADER_FIELD_IGMP_DATA                      (IOC_NET_HEADER_FIELD_IGMP_VERSION << 3)
+#define IOC_NET_HEADER_FIELD_IGMP_ALL_FIELDS                ((IOC_NET_HEADER_FIELD_IGMP_VERSION << 4) - 1)
+
+
+typedef uint16_t ioc_header_field_tcp_t;
+
+#define IOC_NET_HEADER_FIELD_TCP_PORT_SRC                   (1)
+#define IOC_NET_HEADER_FIELD_TCP_PORT_DST                   (IOC_NET_HEADER_FIELD_TCP_PORT_SRC << 1)
+#define IOC_NET_HEADER_FIELD_TCP_SEQ                        (IOC_NET_HEADER_FIELD_TCP_PORT_SRC << 2)
+#define IOC_NET_HEADER_FIELD_TCP_ACK                        (IOC_NET_HEADER_FIELD_TCP_PORT_SRC << 3)
+#define IOC_NET_HEADER_FIELD_TCP_OFFSET                     (IOC_NET_HEADER_FIELD_TCP_PORT_SRC << 4)
+#define IOC_NET_HEADER_FIELD_TCP_FLAGS                      (IOC_NET_HEADER_FIELD_TCP_PORT_SRC << 5)
+#define IOC_NET_HEADER_FIELD_TCP_WINDOW                     (IOC_NET_HEADER_FIELD_TCP_PORT_SRC << 6)
+#define IOC_NET_HEADER_FIELD_TCP_CKSUM                      (IOC_NET_HEADER_FIELD_TCP_PORT_SRC << 7)
+#define IOC_NET_HEADER_FIELD_TCP_URGPTR                     (IOC_NET_HEADER_FIELD_TCP_PORT_SRC << 8)
+#define IOC_NET_HEADER_FIELD_TCP_OPTS                       (IOC_NET_HEADER_FIELD_TCP_PORT_SRC << 9)
+#define IOC_NET_HEADER_FIELD_TCP_OPTS_COUNT                 (IOC_NET_HEADER_FIELD_TCP_PORT_SRC << 10)
+#define IOC_NET_HEADER_FIELD_TCP_ALL_FIELDS                 ((IOC_NET_HEADER_FIELD_TCP_PORT_SRC << 11) - 1)
+
+
+typedef uint8_t ioc_header_field_sctp_t;
+
+#define IOC_NET_HEADER_FIELD_SCTP_PORT_SRC                  (1)
+#define IOC_NET_HEADER_FIELD_SCTP_PORT_DST                  (IOC_NET_HEADER_FIELD_SCTP_PORT_SRC << 1)
+#define IOC_NET_HEADER_FIELD_SCTP_VER_TAG                   (IOC_NET_HEADER_FIELD_SCTP_PORT_SRC << 2)
+#define IOC_NET_HEADER_FIELD_SCTP_CKSUM                     (IOC_NET_HEADER_FIELD_SCTP_PORT_SRC << 3)
+#define IOC_NET_HEADER_FIELD_SCTP_ALL_FIELDS                ((IOC_NET_HEADER_FIELD_SCTP_PORT_SRC << 4) - 1)
+
+
+typedef uint8_t ioc_header_field_dccp_t;
+
+#define IOC_NET_HEADER_FIELD_DCCP_PORT_SRC                  (1)
+#define IOC_NET_HEADER_FIELD_DCCP_PORT_DST                  (IOC_NET_HEADER_FIELD_DCCP_PORT_SRC << 1)
+#define IOC_NET_HEADER_FIELD_DCCP_ALL_FIELDS                ((IOC_NET_HEADER_FIELD_DCCP_PORT_SRC << 2) - 1)
+
+
+typedef uint8_t ioc_header_field_udp_t;
+
+#define IOC_NET_HEADER_FIELD_UDP_PORT_SRC                   (1)
+#define IOC_NET_HEADER_FIELD_UDP_PORT_DST                   (IOC_NET_HEADER_FIELD_UDP_PORT_SRC << 1)
+#define IOC_NET_HEADER_FIELD_UDP_LEN                        (IOC_NET_HEADER_FIELD_UDP_PORT_SRC << 2)
+#define IOC_NET_HEADER_FIELD_UDP_CKSUM                      (IOC_NET_HEADER_FIELD_UDP_PORT_SRC << 3)
+#define IOC_NET_HEADER_FIELD_UDP_ALL_FIELDS                 ((IOC_NET_HEADER_FIELD_UDP_PORT_SRC << 4) - 1)
+
+#define IOC_NET_HEADER_FIELD_IPHC_CID                       (1)
+#define IOC_NET_HEADER_FIELD_IPHC_CID_TYPE                  (IOC_NET_HEADER_FIELD_IPHC_CID << 1)
+#define IOC_NET_HEADER_FIELD_IPHC_HCINDEX                   (IOC_NET_HEADER_FIELD_IPHC_CID << 2)
+#define IOC_NET_HEADER_FIELD_IPHC_GEN                       (IOC_NET_HEADER_FIELD_IPHC_CID << 3)
+#define IOC_NET_HEADER_FIELD_IPHC_D_BIT                     (IOC_NET_HEADER_FIELD_IPHC_CID << 4)
+#define IOC_NET_HEADER_FIELD_IPHC_ALL_FIELDS                ((IOC_NET_HEADER_FIELD_IPHC_CID << 5) - 1)
+
+#define IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE           (1)
+#define IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_FLAGS          (IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 1)
+#define IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_LENGTH         (IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 2)
+#define IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_TSN            (IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 3)
+#define IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_STREAM_ID      (IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 4)
+#define IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_STREAM_SQN     (IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 5)
+#define IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_PAYLOAD_PID    (IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 6)
+#define IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_UNORDERED      (IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 7)
+#define IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_BEGGINING      (IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 8)
+#define IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_END            (IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 9)
+#define IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_ALL_FIELDS     ((IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 10) - 1)
+
+#define IOC_NET_HEADER_FIELD_L2TPv2_TYPE_BIT                (1)
+#define IOC_NET_HEADER_FIELD_L2TPv2_LENGTH_BIT              (IOC_NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 1)
+#define IOC_NET_HEADER_FIELD_L2TPv2_SEQUENCE_BIT            (IOC_NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 2)
+#define IOC_NET_HEADER_FIELD_L2TPv2_OFFSET_BIT              (IOC_NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 3)
+#define IOC_NET_HEADER_FIELD_L2TPv2_PRIORITY_BIT            (IOC_NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 4)
+#define IOC_NET_HEADER_FIELD_L2TPv2_VERSION                 (IOC_NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 5)
+#define IOC_NET_HEADER_FIELD_L2TPv2_LEN                     (IOC_NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 6)
+#define IOC_NET_HEADER_FIELD_L2TPv2_TUNNEL_ID               (IOC_NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 7)
+#define IOC_NET_HEADER_FIELD_L2TPv2_SESSION_ID              (IOC_NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 8)
+#define IOC_NET_HEADER_FIELD_L2TPv2_NS                      (IOC_NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 9)
+#define IOC_NET_HEADER_FIELD_L2TPv2_NR                      (IOC_NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 10)
+#define IOC_NET_HEADER_FIELD_L2TPv2_OFFSET_SIZE             (IOC_NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 11)
+#define IOC_NET_HEADER_FIELD_L2TPv2_FIRST_BYTE              (IOC_NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 12)
+#define IOC_NET_HEADER_FIELD_L2TPv2_ALL_FIELDS              ((IOC_NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 13) - 1)
+
+#define IOC_NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT           (1)
+#define IOC_NET_HEADER_FIELD_L2TPv3_CTRL_LENGTH_BIT         (IOC_NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT << 1)
+#define IOC_NET_HEADER_FIELD_L2TPv3_CTRL_SEQUENCE_BIT       (IOC_NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT << 2)
+#define IOC_NET_HEADER_FIELD_L2TPv3_CTRL_VERSION            (IOC_NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT << 3)
+#define IOC_NET_HEADER_FIELD_L2TPv3_CTRL_LENGTH             (IOC_NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT << 4)
+#define IOC_NET_HEADER_FIELD_L2TPv3_CTRL_CONTROL            (IOC_NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT << 5)
+#define IOC_NET_HEADER_FIELD_L2TPv3_CTRL_SENT               (IOC_NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT << 6)
+#define IOC_NET_HEADER_FIELD_L2TPv3_CTRL_RECV               (IOC_NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT << 7)
+#define IOC_NET_HEADER_FIELD_L2TPv3_CTRL_FIRST_BYTE         (IOC_NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT << 8)
+#define IOC_NET_HEADER_FIELD_L2TPv3_CTRL_ALL_FIELDS         ((IOC_NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT << 9) - 1)
+
+#define IOC_NET_HEADER_FIELD_L2TPv3_SESS_TYPE_BIT           (1)
+#define IOC_NET_HEADER_FIELD_L2TPv3_SESS_VERSION            (IOC_NET_HEADER_FIELD_L2TPv3_SESS_TYPE_BIT << 1)
+#define IOC_NET_HEADER_FIELD_L2TPv3_SESS_ID                 (IOC_NET_HEADER_FIELD_L2TPv3_SESS_TYPE_BIT << 2)
+#define IOC_NET_HEADER_FIELD_L2TPv3_SESS_COOKIE             (IOC_NET_HEADER_FIELD_L2TPv3_SESS_TYPE_BIT << 3)
+#define IOC_NET_HEADER_FIELD_L2TPv3_SESS_ALL_FIELDS         ((IOC_NET_HEADER_FIELD_L2TPv3_SESS_TYPE_BIT << 4) - 1)
+
+
+typedef uint8_t ioc_header_field_vlan_t;
+
+#define IOC_NET_HEADER_FIELD_VLAN_VPRI                      (1)
+#define IOC_NET_HEADER_FIELD_VLAN_CFI                       (IOC_NET_HEADER_FIELD_VLAN_VPRI << 1)
+#define IOC_NET_HEADER_FIELD_VLAN_VID                       (IOC_NET_HEADER_FIELD_VLAN_VPRI << 2)
+#define IOC_NET_HEADER_FIELD_VLAN_LENGTH                    (IOC_NET_HEADER_FIELD_VLAN_VPRI << 3)
+#define IOC_NET_HEADER_FIELD_VLAN_TYPE                      (IOC_NET_HEADER_FIELD_VLAN_VPRI << 4)
+#define IOC_NET_HEADER_FIELD_VLAN_TCI                       (IOC_NET_HEADER_FIELD_VLAN_VPRI << 5)
+#define IOC_NET_HEADER_FIELD_VLAN_ALL_FIELDS                ((IOC_NET_HEADER_FIELD_VLAN_VPRI << 6) - 1)
+
+
+typedef uint8_t ioc_header_field_llc_t;
+
+#define IOC_NET_HEADER_FIELD_LLC_DSAP                       (1)
+#define IOC_NET_HEADER_FIELD_LLC_SSAP                       (IOC_NET_HEADER_FIELD_LLC_DSAP << 1)
+#define IOC_NET_HEADER_FIELD_LLC_CTRL                       (IOC_NET_HEADER_FIELD_LLC_DSAP << 2)
+#define IOC_NET_HEADER_FIELD_LLC_ALL_FIELDS                 ((IOC_NET_HEADER_FIELD_LLC_DSAP << 3) - 1)
+
+#define IOC_NET_HEADER_FIELD_NLPID_NLPID                    (1)
+#define IOC_NET_HEADER_FIELD_NLPID_ALL_FIELDS               ((IOC_NET_HEADER_FIELD_NLPID_NLPID << 1) - 1)
+
+
+typedef uint8_t ioc_header_field_snap_t;
+
+#define IOC_NET_HEADER_FIELD_SNAP_OUI                       (1)
+#define IOC_NET_HEADER_FIELD_SNAP_PID                       (IOC_NET_HEADER_FIELD_SNAP_OUI << 1)
+#define IOC_NET_HEADER_FIELD_SNAP_ALL_FIELDS                ((IOC_NET_HEADER_FIELD_SNAP_OUI << 2) - 1)
+
+
+typedef uint8_t ioc_header_field_llc_snap_t;
+
+#define IOC_NET_HEADER_FIELD_LLC_SNAP_TYPE                  (1)
+#define IOC_NET_HEADER_FIELD_LLC_SNAP_ALL_FIELDS            ((IOC_NET_HEADER_FIELD_LLC_SNAP_ALL_FIELDS << 1) - 1)
+
+#define IOC_NET_HEADER_FIELD_ARP_HTYPE                      (1)
+#define IOC_NET_HEADER_FIELD_ARP_PTYPE                      (IOC_NET_HEADER_FIELD_ARP_HTYPE << 1)
+#define IOC_NET_HEADER_FIELD_ARP_HLEN                       (IOC_NET_HEADER_FIELD_ARP_HTYPE << 2)
+#define IOC_NET_HEADER_FIELD_ARP_PLEN                       (IOC_NET_HEADER_FIELD_ARP_HTYPE << 3)
+#define IOC_NET_HEADER_FIELD_ARP_OPER                       (IOC_NET_HEADER_FIELD_ARP_HTYPE << 4)
+#define IOC_NET_HEADER_FIELD_ARP_SHA                        (IOC_NET_HEADER_FIELD_ARP_HTYPE << 5)
+#define IOC_NET_HEADER_FIELD_ARP_SPA                        (IOC_NET_HEADER_FIELD_ARP_HTYPE << 6)
+#define IOC_NET_HEADER_FIELD_ARP_THA                        (IOC_NET_HEADER_FIELD_ARP_HTYPE << 7)
+#define IOC_NET_HEADER_FIELD_ARP_TPA                        (IOC_NET_HEADER_FIELD_ARP_HTYPE << 8)
+#define IOC_NET_HEADER_FIELD_ARP_ALL_FIELDS                 ((IOC_NET_HEADER_FIELD_ARP_HTYPE << 9) - 1)
+
+#define IOC_NET_HEADER_FIELD_RFC2684_LLC                    (1)
+#define IOC_NET_HEADER_FIELD_RFC2684_NLPID                  (IOC_NET_HEADER_FIELD_RFC2684_LLC << 1)
+#define IOC_NET_HEADER_FIELD_RFC2684_OUI                    (IOC_NET_HEADER_FIELD_RFC2684_LLC << 2)
+#define IOC_NET_HEADER_FIELD_RFC2684_PID                    (IOC_NET_HEADER_FIELD_RFC2684_LLC << 3)
+#define IOC_NET_HEADER_FIELD_RFC2684_VPN_OUI                (IOC_NET_HEADER_FIELD_RFC2684_LLC << 4)
+#define IOC_NET_HEADER_FIELD_RFC2684_VPN_IDX                (IOC_NET_HEADER_FIELD_RFC2684_LLC << 5)
+#define IOC_NET_HEADER_FIELD_RFC2684_ALL_FIELDS             ((IOC_NET_HEADER_FIELD_RFC2684_LLC << 6) - 1)
+
+#define IOC_NET_HEADER_FIELD_USER_DEFINED_SRCPORT           (1)
+#define IOC_NET_HEADER_FIELD_USER_DEFINED_PCDID             (IOC_NET_HEADER_FIELD_USER_DEFINED_SRCPORT << 1)
+#define IOC_NET_HEADER_FIELD_USER_DEFINED_ALL_FIELDS        ((IOC_NET_HEADER_FIELD_USER_DEFINED_SRCPORT << 2) - 1)
+
+#define IOC_NET_HEADER_FIELD_PAYLOAD_BUFFER                 (1)
+#define IOC_NET_HEADER_FIELD_PAYLOAD_SIZE                   (IOC_NET_HEADER_FIELD_PAYLOAD_BUFFER << 1)
+#define IOC_NET_HEADER_FIELD_MAX_FRM_SIZE                   (IOC_NET_HEADER_FIELD_PAYLOAD_BUFFER << 2)
+#define IOC_NET_HEADER_FIELD_MIN_FRM_SIZE                   (IOC_NET_HEADER_FIELD_PAYLOAD_BUFFER << 3)
+#define IOC_NET_HEADER_FIELD_PAYLOAD_TYPE                   (IOC_NET_HEADER_FIELD_PAYLOAD_BUFFER << 4)
+#define IOC_NET_HEADER_FIELD_FRAME_SIZE                     (IOC_NET_HEADER_FIELD_PAYLOAD_BUFFER << 5)
+#define IOC_NET_HEADER_FIELD_PAYLOAD_ALL_FIELDS             ((IOC_NET_HEADER_FIELD_PAYLOAD_BUFFER << 6) - 1)
+
+
+typedef uint8_t ioc_header_field_gre_t;
+
+#define IOC_NET_HEADER_FIELD_GRE_TYPE                       (1)
+#define IOC_NET_HEADER_FIELD_GRE_ALL_FIELDS                 ((IOC_NET_HEADER_FIELD_GRE_TYPE << 1) - 1)
+
+
+typedef uint8_t ioc_header_field_minencap_t;
+
+#define IOC_NET_HEADER_FIELD_MINENCAP_SRC_IP                (1)
+#define IOC_NET_HEADER_FIELD_MINENCAP_DST_IP                (IOC_NET_HEADER_FIELD_MINENCAP_SRC_IP << 1)
+#define IOC_NET_HEADER_FIELD_MINENCAP_TYPE                  (IOC_NET_HEADER_FIELD_MINENCAP_SRC_IP << 2)
+#define IOC_NET_HEADER_FIELD_MINENCAP_ALL_FIELDS            ((IOC_NET_HEADER_FIELD_MINENCAP_SRC_IP << 3) - 1)
+
+
+typedef uint8_t ioc_header_field_ipsec_ah_t;
+
+#define IOC_NET_HEADER_FIELD_IPSEC_AH_SPI                   (1)
+#define IOC_NET_HEADER_FIELD_IPSEC_AH_NH                    (IOC_NET_HEADER_FIELD_IPSEC_AH_SPI << 1)
+#define IOC_NET_HEADER_FIELD_IPSEC_AH_ALL_FIELDS               ((IOC_NET_HEADER_FIELD_IPSEC_AH_SPI << 2) - 1)
+
+
+typedef uint8_t ioc_header_field_ipsec_esp_t;
+
+#define IOC_NET_HEADER_FIELD_IPSEC_ESP_SPI                   (1)
+#define IOC_NET_HEADER_FIELD_IPSEC_ESP_ALL_FIELDS            ((IOC_NET_HEADER_FIELD_IPSEC_ESP_SPI << 1) - 1)
+
+
+typedef uint8_t ioc_header_field_mpls_t;
+
+#define IOC_NET_HEADER_FIELD_MPLS_LABEL_STACK               (1)
+#define IOC_NET_HEADER_FIELD_MPLS_LABEL_STACK_ALL_FIELDS    ((IOC_NET_HEADER_FIELD_MPLS_LABEL_STACK << 1) - 1)
+
+
+typedef enum {
+    e_IOC_NET_HEADER_TYPE_NONE = 0,
+    e_IOC_NET_HEADER_TYPE_PAYLOAD,
+    e_IOC_NET_HEADER_TYPE_ETH,
+    e_IOC_NET_HEADER_TYPE_VLAN,
+    e_IOC_NET_HEADER_TYPE_IPv4,
+    e_IOC_NET_HEADER_TYPE_IPv6,
+    e_IOC_NET_HEADER_TYPE_TCP,
+    e_IOC_NET_HEADER_TYPE_UDP,
+    e_IOC_NET_HEADER_TYPE_IPHC,
+    e_IOC_NET_HEADER_TYPE_SCTP,
+    e_IOC_NET_HEADER_TYPE_SCTP_CHUNK_DATA,
+    e_IOC_NET_HEADER_TYPE_PPPoE,
+    e_IOC_NET_HEADER_TYPE_PPP,
+    e_IOC_NET_HEADER_TYPE_PPPMUX,
+    e_IOC_NET_HEADER_TYPE_PPPMUX_SUBFRAME,
+    e_IOC_NET_HEADER_TYPE_L2TPv2,
+    e_IOC_NET_HEADER_TYPE_L2TPv3_CTRL,
+    e_IOC_NET_HEADER_TYPE_L2TPv3_SESS,
+    e_IOC_NET_HEADER_TYPE_LLC,
+    e_IOC_NET_HEADER_TYPE_LLC_SNAP,
+    e_IOC_NET_HEADER_TYPE_NLPID,
+    e_IOC_NET_HEADER_TYPE_SNAP,
+    e_IOC_NET_HEADER_TYPE_MPLS,
+    e_IOC_NET_HEADER_TYPE_IPSEC_AH,
+    e_IOC_NET_HEADER_TYPE_IPSEC_ESP,
+    e_IOC_NET_HEADER_TYPE_GRE,
+    e_IOC_NET_HEADER_TYPE_MINENCAP,
+    e_IOC_NET_HEADER_TYPE_DCCP,
+    e_IOC_NET_HEADER_TYPE_ICMP,
+    e_IOC_NET_HEADER_TYPE_IGMP,
+    e_IOC_NET_HEADER_TYPE_ARP,
+    e_IOC_NET_HEADER_TYPE_RFC2684,
+    e_IOC_NET_HEADER_TYPE_USER_DEFINED_L2,
+    e_IOC_NET_HEADER_TYPE_USER_DEFINED_L3,
+    e_IOC_NET_HEADER_TYPE_USER_DEFINED_L4,
+    e_IOC_NET_HEADER_TYPE_USER_DEFINED_SHIM1,
+    e_IOC_NET_HEADER_TYPE_USER_DEFINED_SHIM2,
+    e_IOC_NET_HEADER_TYPE_USER_DEFINED_SHIM3,
+    MAX_e_IOC_NET_HEADER_TYPE_COUNT
+} ioc_net_header_type;
+
+
+#endif /* __NET_IOCTLS_H */
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/procbuff_ext.h b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/procbuff_ext.h
new file mode 100644
index 0000000..e4f9898
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/procbuff_ext.h
@@ -0,0 +1,58 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**************************************************************************//**
+ @File          procbuff_ext.h
+
+ @Author        Eran Liberty
+
+ @Description   TBD
+*//***************************************************************************/
+#ifndef __PROCBUFF_EXT_H
+#define __PROCBUFF_EXT_H
+
+#include "std_ext.h"
+#include "xx_ext.h"
+
+
+#define MAX_LINE_SIZE       1024
+
+
+t_Handle    ProcBuff_Init (char *buffer,char **start,int offset,int length, int *eof);
+void        ProcBuff_Free (t_Handle h_ProcBuff);
+
+void        ProcBuff_Write (t_Handle h_ProcBuff,const char *fmt, ...);
+int         ProcBuff_GetNumOfWrittenChars (t_Handle h_ProcBuff);
+void        ProcBuff_Done  (t_Handle h_ProcBuff);
+
+
+#endif /* __PROCBUFF_EXT_H */
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/system/platform_ext.h b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/system/platform_ext.h
new file mode 100644
index 0000000..d25f3d7
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/system/platform_ext.h
@@ -0,0 +1,126 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/******************************************************************************
+
+ @File          platform_ext.h
+
+ @Description   Prototypes, externals and typedefs for platform routines
+****************************************************************************/
+#ifndef __PLATFORM_EXT_H
+#define __PLATFORM_EXT_H
+
+#include "std_ext.h"
+#include "sys_ext.h"
+
+
+/**************************************************************************//**
+ @Group         platform_grp PLATFORM Application Programming Interface
+
+ @Description   Generic Platform API, that must be implemented by each
+                specific platform.
+
+ @{
+*//***************************************************************************/
+
+#define MAX_CHIP_NAME_LEN   9   /* (including null character) */
+
+
+/**************************************************************************//**
+ @Description   Cache Operation Mode
+*//***************************************************************************/
+typedef enum e_CacheMode
+{
+    e_CACHE_MODE_DISABLED       = 0x00000000,   /**< Cache is disabled */
+    e_CACHE_MODE_DATA_ONLY      = 0x00000001,   /**< Cache is enabled for data only */
+    e_CACHE_MODE_INST_ONLY      = 0x00000002,   /**< Cache is enabled for instructions only */
+    e_CACHE_MODE_DATA_AND_INST  = 0x00000003    /**< Cache is enabled for data and instructions */
+
+} e_CacheMode;
+
+/**************************************************************************//**
+ @Description   Memory Partition Identifiers
+
+                Note that not all memory partitions are supported by all
+                platforms. Every platform may select which memory partitions
+                to support.
+*//***************************************************************************/
+typedef enum e_MemoryPartitionId
+{
+    e_MEM_1ST_DDR_CACHEABLE     = 1, /**< Primary DDR cacheable memory partition */
+    e_MEM_1ST_DDR_NON_CACHEABLE = 2, /**< Primary DDR non-cacheable memory partition */
+    e_MEM_2ND_DDR_CACHEABLE     = 3, /**< Secondary DDR cacheable memory partition */
+    e_MEM_2ND_DDR_NON_CACHEABLE = 4, /**< Secondary DDR non-cacheable memory partition */
+    e_MEM_SDRAM                 = 5, /**< SDRAM non-cacheable memory partition */
+    e_MEM_L2_SRAM               = 6, /**< L2 SRAM cacheable memory partition */
+    e_MEM_MURAM_LOW             = 7, /**< Low-range MURAM partition */
+    e_MEM_MURAM                 = 8  /**< Full-range MURAM partition */
+
+} e_MemoryPartitionId;
+
+/**************************************************************************//**
+ @Description   Chip Type and Revision Information Structure
+*//***************************************************************************/
+typedef struct t_ChipRevInfo
+{
+    char            chipName[MAX_CHIP_NAME_LEN];
+                    /**< Chip name (e.g. "P4080") */
+    uint16_t        revMajor;
+                    /**< Major chip revision */
+    uint16_t        revMinor;
+                    /**< Minor chip revision */
+} t_ChipRevInfo;
+
+
+/**************************************************************************//**
+ @Description   Platform configuration parameters structure.
+
+                This structure must be specifically defined by each platform.
+*//***************************************************************************/
+struct t_PlatformParam;
+
+
+t_Handle PLATFORM_Init(struct t_PlatformParam *p_PlatformParam);
+
+t_Error  PLATFORM_Free(t_Handle h_Platform);
+
+
+t_Error  PLATFORM_GetChipRevInfo(t_Handle h_Platform, t_ChipRevInfo *p_ChipRevInfo);
+
+uint32_t PLATFORM_GetMemoryMappedModuleBase(t_Handle    h_Platform,
+                                            e_SysModule module,
+                                            uint32_t    id);
+
+/** @} */ /* end of platform_grp */
+
+
+#endif /* __PLATFORM_EXT_H */
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/system/platform_p4080_ds_ext.h b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/system/platform_p4080_ds_ext.h
new file mode 100644
index 0000000..a611e48
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/system/platform_p4080_ds_ext.h
@@ -0,0 +1,64 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/******************************************************************************
+
+ @File          platform_p4080_ds_ext.h
+
+ @Description   Prototypes, externals and typedefs for platform routines
+****************************************************************************/
+#ifndef __PLATFORM_P4080_DS_EXT_H
+#define __PLATFORM_P4080_DS_EXT_H
+
+#include "std_ext.h"
+#include "platform_ext.h"
+
+
+/**************************************************************************//**
+ @Group         platform_grp PLATFORM Application Programming Interface
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description   P4080-DS Platform configuration parameters structure
+*//***************************************************************************/
+typedef struct t_PlatformParam
+{
+    e_CacheMode             l1CacheMode;
+    e_CacheMode             l2CacheMode;
+} t_PlatformParam;
+
+/** @} */ /* end of platform_grp */
+
+
+#endif /* __PLATFORM_P4080_DS_EXT_H */
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/system/sys_ext.h b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/system/sys_ext.h
new file mode 100644
index 0000000..29d6d74
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/system/sys_ext.h
@@ -0,0 +1,290 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __SYS_EXT_H
+#define __SYS_EXT_H
+
+#include "std_ext.h"
+
+
+typedef enum e_SysModule
+{
+    e_SYS_MODULE_NONE = 0,
+
+    /* ----------- Modules ----------- */
+    e_SYS_MODULE_PLATFORM,
+
+    /* Must close the sub-modules list */
+    e_SYS_SUBMODULE_DUMMY_LAST
+
+} e_SysModule;
+
+
+typedef struct t_SysObjectDescriptor
+{
+    e_SysModule module;
+    uint32_t    id;
+    void        *p_Settings;
+
+} t_SysObjectDescriptor;
+
+
+#define SYS_MAX_ADV_CONFIG_ARGS      4
+
+typedef struct t_SysObjectAdvConfigEntry
+{
+    void        *p_Function;
+    uint32_t    args[SYS_MAX_ADV_CONFIG_ARGS]; //@@@@ uint64_t (CW bug) ?
+} t_SysObjectAdvConfigEntry;
+
+
+#define ADV_CONFIG_DONE         NULL, { 0 }
+#define ADV_CONFIG_NONE         (t_SysObjectAdvConfigEntry[]){ ADV_CONFIG_DONE }
+
+
+#define PARAMS(_num, _params)   ADV_CONFIG_PARAMS_##_num _params
+#define NO_PARAMS
+
+#define ADV_CONFIG_PARAMS_1(_type) \
+    , (_type)p_Entry->args[0]
+
+#define ADV_CONFIG_PARAMS_2(_type0, _type1) \
+    , (_type0)p_Entry->args[0], (_type1)p_Entry->args[1]
+
+#define ADV_CONFIG_PARAMS_3(_type0, _type1, _type2) \
+    , (_type0)p_Entry->args[0], (_type1)p_Entry->args[1], (_type2)p_Entry->args[2]
+
+#define ADV_CONFIG_PARAMS_4(_type0, _type1, _type2, _type3) \
+    , (_type0)p_Entry->args[0], (_type1)p_Entry->args[1], (_type2)p_Entry->args[2], (_type3)p_Entry->args[3]
+
+
+#define SET_ADV_CONFIG_ARGS_1(_arg0)        \
+    p_Entry->args[0] = (uint32_t)(_arg0);   \
+
+#define SET_ADV_CONFIG_ARGS_2(_arg0, _arg1) \
+    p_Entry->args[0] = (uint32_t)(_arg0);   \
+    p_Entry->args[1] = (uint32_t)(_arg1);   \
+
+#define SET_ADV_CONFIG_ARGS_3(_arg0, _arg1, _arg2)  \
+    p_Entry->args[0] = (uint32_t)(_arg0);           \
+    p_Entry->args[1] = (uint32_t)(_arg1);           \
+    p_Entry->args[2] = (uint32_t)(_arg2);           \
+
+#define SET_ADV_CONFIG_ARGS_4(_arg0, _arg1, _arg2, _arg3)   \
+    p_Entry->args[0] = (uint32_t)(_arg0);                   \
+    p_Entry->args[1] = (uint32_t)(_arg1);                   \
+    p_Entry->args[2] = (uint32_t)(_arg2);                   \
+    p_Entry->args[3] = (uint32_t)(_arg3);                   \
+
+#define ARGS(_num, _params) SET_ADV_CONFIG_ARGS_##_num _params
+#define NO_ARGS
+
+#define ADD_ADV_CONFIG(_func, _param)       \
+    do {                                    \
+        if (i<max){                         \
+            p_Entry = &p_Entrys[i];         \
+            p_Entry->p_Function = _func;    \
+            _param                          \
+            i++;                            \
+        }                                   \
+        else                                \
+            REPORT_ERROR(MINOR, E_INVALID_VALUE, ("number of advance-configuration exceeded!!!"));\
+    } while (0)
+
+#define ADD_ADV_CONFIG_START(_p_Entries, _maxEntries)                   \
+    {                                                                   \
+        t_SysObjectAdvConfigEntry   *p_Entry;                           \
+        t_SysObjectAdvConfigEntry   *p_Entrys = (_p_Entries);           \
+        int                         i=0, max = (_maxEntries);           \
+        for (; i<FM_MAX_NUM_OF_ADV_SETTINGS;i++)                        \
+            if (!p_LnxWrpFmPortDev->settings.advConfig[i].p_Function)   \
+                break;
+
+#define ADD_ADV_CONFIG_END \
+    }
+
+#define ADV_CONFIG_CHECK_START(_p_Entry)                        \
+    {                                                           \
+        t_SysObjectAdvConfigEntry   *p_Entry = _p_Entry;        \
+        t_Error                     errCode;                    \
+
+#define ADV_CONFIG_CHECK(_handle, _func, _params)               \
+        if (p_Entry->p_Function == _func)                       \
+        {                                                       \
+            errCode = _func(_handle _params);                   \
+        } else
+
+#define ADV_CONFIG_CHECK_END                                    \
+        {                                                       \
+            REPORT_ERROR(MAJOR, E_INVALID_SELECTION,            \
+                         ("Advanced configuration routine"));   \
+            return NULL;                                        \
+        }                                                       \
+        if (errCode != E_OK)                                    \
+        {                                                       \
+            REPORT_ERROR(MAJOR, errCode, NO_MSG);               \
+            return NULL;                                        \
+        }                                                       \
+    }
+
+
+
+#define CAST_ID_TO_HANDLE(_id)      ((t_Handle)(_id))
+#define CAST_HANDLE_TO_ID(_h)       ((uint32_t)(_h))
+
+
+#define SYS_MAX_TEST_GROUP_NAME_LENGTH      14
+#define SYS_MAX_TEST_DESCRIPTION_LENGTH     64
+
+typedef struct t_SysTestDescriptor
+{
+    char        testGroup[SYS_MAX_TEST_GROUP_NAME_LENGTH];
+    uint16_t    testId;
+    char        description[SYS_MAX_TEST_DESCRIPTION_LENGTH];
+    t_Error     (*f_RunTest)(void *p_TestParam);
+    void        (*f_KillTest)(void);
+    void        *p_TestParam;
+
+} t_SysTestDescriptor;
+
+
+typedef struct t_SysRuntimeLayout
+{
+    t_SysObjectDescriptor   **p_LogicalObjects;
+    t_SysTestDescriptor     **p_TestDescriptors;
+
+} t_SysRuntimeLayout;
+
+typedef struct t_SysPeripheralLayout
+{
+    t_SysObjectDescriptor   **p_PeripheralObjects;
+    t_SysRuntimeLayout      *p_RuntimeLayouts;
+
+} t_SysPeripheralLayout;
+
+typedef struct t_SysSystemLayout
+{
+    t_SysObjectDescriptor   **p_SystemObjects;
+    t_SysPeripheralLayout   *p_PeripheralLayouts;
+
+} t_SysSystemLayout;
+
+typedef struct t_SysUseCaseLayout
+{
+    t_SysObjectDescriptor   *p_PlatformObject;
+    t_SysSystemLayout       *p_SystemLayouts;
+
+} t_SysUseCaseLayout;
+
+
+
+t_SysUseCaseLayout * USER_BuildLayout(int argc, char *argv[]);
+
+void USER_FreeLayout(t_SysUseCaseLayout *p_UseCaseLayout);
+
+
+
+#define SYS_SYSTEM_OBJECTS(...)     (t_SysObjectDescriptor*[]){ __VA_ARGS__, NULL }
+#define SYS_PERIPHERAL_OBJECTS(...) (t_SysObjectDescriptor*[]){ __VA_ARGS__, NULL }
+#define SYS_LOGICAL_OBJECTS(...)    (t_SysObjectDescriptor*[]){ __VA_ARGS__, NULL }
+#define SYS_TEST_DESCRIPTORS(...)   (t_SysTestDescriptor*[]){ __VA_ARGS__, NULL }
+
+
+#define SYS_BEGIN_SYSTEM_LAYOUTS \
+        (t_SysSystemLayout[]){
+#define SYS_END_SYSTEM_LAYOUTS \
+        , { NULL, NULL } }
+
+#define SYS_BEGIN_PERIPHERAL_LAYOUTS \
+        (t_SysPeripheralLayout[]){
+#define SYS_END_PERIPHERAL_LAYOUTS \
+        , { NULL, NULL } }
+
+#define SYS_BEGIN_RUNTIME_LAYOUTS \
+        (t_SysRuntimeLayout[]){
+#define SYS_END_RUNTIME_LAYOUTS \
+        , { NULL, NULL } }
+
+
+
+typedef t_Handle (t_SysModuleInitFuncNoParams)(void);
+typedef t_Handle (t_SysModuleInitFuncWithParams)(void *p_ModuleParams);
+
+typedef struct t_SysRegistryEntry
+{
+    e_SysModule     module;
+    bool            noInitParams;
+    union
+    {
+        t_SysModuleInitFuncNoParams     *f_InitNoParams;
+        t_SysModuleInitFuncWithParams   *f_InitWithParams;
+    };
+    t_Error         (*f_Free)(t_Handle h_Module);
+
+} t_SysRegistryEntry;
+
+
+#define SYS_REGISTER_MODULE_VOID_PARAM(mod, initFunc, freeFunc) \
+    {(mod), TRUE,  .f_InitNoParams   = (initFunc), (freeFunc) }
+
+#define SYS_REGISTER_MODULE_WITH_PARAM(mod, initFunc, freeFunc) \
+    {(mod), FALSE, .f_InitWithParams = (t_SysModuleInitFuncWithParams *)(initFunc), (freeFunc) }
+
+#define SYS_REGISTER_MODULE_DONE \
+    {e_SYS_MODULE_NONE, TRUE, NULL, NULL }
+
+typedef struct t_SysSubModuleRegisterParam
+{
+    e_SysModule owner;
+    uint8_t     numOfSubModules;
+    e_SysModule *p_SubModules;
+    t_Error     (*f_InitSubModule)(t_Handle h_Module, t_SysObjectDescriptor *p_SubModuleDesc);
+    t_Error     (*f_FreeSubModule)(t_Handle h_Module, e_SysModule subModule, uint32_t id);
+    t_Handle    (*f_GetSubModule)(t_Handle h_Module, e_SysModule subModule, uint32_t id);
+
+} t_SysSubModuleRegisterParam;
+
+
+typedef struct t_SysSubModuleUnregisterParam
+{
+    e_SysModule owner;
+    uint8_t     numOfSubModules;
+    e_SysModule *p_SubModules;
+
+} t_SysSubModuleUnregisterParam;
+
+
+void SYS_Init(void);
+void SYS_Free(void);
+
+
+#endif /* __SYS_EXT_H */
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/system/sys_io_ext.h b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/system/sys_io_ext.h
new file mode 100644
index 0000000..6ba992e
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/system/sys_io_ext.h
@@ -0,0 +1,46 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __SYS_IO_EXT_H
+#define __SYS_IO_EXT_H
+
+#include "std_ext.h"
+#include "error_ext.h"
+
+
+t_Error  SYS_RegisterIoMap   (uint64_t virtAddr, uint64_t physAddr, uint32_t size);
+t_Error  SYS_UnregisterIoMap (uint64_t virtAddr);
+uint64_t SYS_PhysToVirt      (uint64_t addr);
+uint64_t SYS_VirtToPhys      (uint64_t addr);
+
+
+#endif /* __SYS_IO_EXT_H */
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/types_linux.h b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/types_linux.h
new file mode 100644
index 0000000..afb6906
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/types_linux.h
@@ -0,0 +1,197 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __TYPES_LINUX_H__
+#define __TYPES_LINUX_H__
+
+#include <linux/version.h>
+
+#if defined(CONFIG_MODVERSIONS) && !defined(MODVERSIONS)
+#define MODVERSIONS
+#endif
+#ifdef MODVERSIONS
+#include <config/modversions.h>
+#endif /* MODVERSIONS */
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,11)
+    #error "This kernel is probably not supported!!!"
+#elif   (!((LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,19)) || \
+           (LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,27)) || \
+           (LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,30))))
+    #warning "This kernel is probably not supported!!! You may need to add some fixes."
+#endif    /* LINUX_VERSION_CODE */
+
+
+typedef float               float_t;    /* Single precision floating point  */
+typedef double              double_t;   /* Double precision floating point  */
+
+
+#define _Packed
+#define _PackedType __attribute__ ((packed))
+
+#define UINT8_MAX   0xFF
+#define UINT8_MIN   0
+#define UINT16_MAX  0xFFFF
+#define UINT16_MIN  0
+#define UINT32_MAX  0xFFFFFFFF
+#define UINT32_MIN  0
+#define UINT64_MAX  0xFFFFFFFFFFFFFFFFLL
+#define UINT64_MIN  0
+#define INT8_MAX    0x7F
+#define INT8_MIN    0x80
+#define INT16_MAX   0x7FFF
+#define INT16_MIN   0x8000
+#define INT32_MAX   0x7FFFFFFF
+#define INT32_MIN   0x80000000
+#define INT64_MAX   0x7FFFFFFFFFFFFFFFLL
+#define INT64_MIN   0x8000000000000000LL
+
+#define ON          1
+#define OFF         0
+
+#define FALSE       false
+#define TRUE        true
+
+
+/************************/
+/* memory access macros */
+/************************/
+#define GET_UINT8(arg)              *(volatile uint8_t *)(&(arg))
+#define GET_UINT16(arg)             *(volatile uint16_t*)(&(arg))
+#define GET_UINT32(arg)             *(volatile uint32_t*)(&(arg))
+#define GET_UINT64(arg)             *(volatile uint64_t*)(&(arg))
+
+#ifdef VERBOSE_WRITE
+#define WRITE_UINT8(arg, data)  \
+    do { XX_Print("ADDR: 0x%08x, VAL: 0x%02x\r\n",    (uint32_t)&(arg), (data)); *(volatile uint8_t *)(&(arg)) = (data); } while (0)
+#define WRITE_UINT16(arg, data) \
+    do { XX_Print("ADDR: 0x%08x, VAL: 0x%04x\r\n",    (uint32_t)&(arg), (data)); *(volatile uint16_t*)(&(arg)) = (data); } while (0)
+#define WRITE_UINT32(arg, data) \
+    do { XX_Print("ADDR: 0x%08x, VAL: 0x%08x\r\n",    (uint32_t)&(arg), (data)); *(volatile uint32_t*)(&(arg)) = (data); } while (0)
+#define WRITE_UINT64(arg, data) \
+    do { XX_Print("ADDR: 0x%08x, VAL: 0x%016llx\r\n", (uint32_t)&(arg), (data)); *(volatile uint64_t*)(&(arg)) = (data); } while (0)
+
+#else  /* not VERBOSE_WRITE */
+#define WRITE_UINT8(arg, data)      *(volatile uint8_t *)(&(arg)) = (data)
+#define WRITE_UINT16(arg, data)     *(volatile uint16_t*)(&(arg)) = (data)
+#define WRITE_UINT32(arg, data)     *(volatile uint32_t*)(&(arg)) = (data)
+#define WRITE_UINT64(arg, data)     *(volatile uint64_t*)(&(arg)) = (data)
+#endif /* not VERBOSE_WRITE */
+
+
+/*****************************************************************************/
+/*                      General stuff                                        */
+/*****************************************************************************/
+#ifdef ARRAY_SIZE
+#undef ARRAY_SIZE
+#endif /* ARRAY_SIZE */
+
+#ifdef MAJOR
+#undef MAJOR
+#endif /* MAJOR */
+
+#ifdef MINOR
+#undef MINOR
+#endif /* MINOR */
+
+#ifdef QE_SIZEOF_BD
+#undef QE_SIZEOF_BD
+#endif /* QE_SIZEOF_BD */
+
+#ifdef BD_BUFFER_CLEAR
+#undef BD_BUFFER_CLEAR
+#endif /* BD_BUFFER_CLEAR */
+
+#ifdef BD_BUFFER
+#undef BD_BUFFER
+#endif /* BD_BUFFER */
+
+#ifdef BD_STATUS_AND_LENGTH_SET
+#undef BD_STATUS_AND_LENGTH_SET
+#endif /* BD_STATUS_AND_LENGTH_SET */
+
+#ifdef BD_STATUS_AND_LENGTH
+#undef BD_STATUS_AND_LENGTH
+#endif /* BD_STATUS_AND_LENGTH */
+
+#ifdef BD_BUFFER_ARG
+#undef BD_BUFFER_ARG
+#endif /* BD_BUFFER_ARG */
+
+#ifdef BD_GET_NEXT
+#undef BD_GET_NEXT
+#endif /* BD_GET_NEXT */
+
+#ifdef QE_SDEBCR_BA_MASK
+#undef QE_SDEBCR_BA_MASK
+#endif /* QE_SDEBCR_BA_MASK */
+
+#ifdef BD_BUFFER_SET
+#undef BD_BUFFER_SET
+#endif /* BD_BUFFER_SET */
+
+#ifdef UPGCR_PROTOCOL
+#undef UPGCR_PROTOCOL
+#endif /* UPGCR_PROTOCOL */
+
+#ifdef UPGCR_TMS
+#undef UPGCR_TMS
+#endif /* UPGCR_TMS */
+
+#ifdef UPGCR_RMS
+#undef UPGCR_RMS
+#endif /* UPGCR_RMS */
+
+#ifdef UPGCR_ADDR
+#undef UPGCR_ADDR
+#endif /* UPGCR_ADDR */
+
+#ifdef UPGCR_DIAG
+#undef UPGCR_DIAG
+#endif /* UPGCR_DIAG */
+
+#ifdef PARAMS
+#undef PARAMS
+#endif /* PARAMS */
+
+#ifdef NO_IRQ
+#undef NO_IRQ
+#endif /* NO_IRQ */
+
+#define PRINT_LINE   XX_Print("%s:\n %s [%d]\n",__FILE__,__FUNCTION__,__LINE__);
+
+
+#endif /* __TYPES_LINUX_H__ */
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/wrappers/Peripherals/fsl_fman.h b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/wrappers/Peripherals/fsl_fman.h
new file mode 100644
index 0000000..b955a58
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/wrappers/Peripherals/fsl_fman.h
@@ -0,0 +1,254 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/******************************************************************************
+ @File          fsl_fman.h
+
+ @Description   Linux internal kernel API
+*//***************************************************************************/
+
+#ifndef __FSL_FMAN_H
+#define __FSL_FMAN_H
+
+#include <linux/types.h>
+#include <linux/device.h>   /* struct device */
+#include <linux/fsl_qman.h> /* struct qman_fq */
+
+
+/**************************************************************************//**
+ @Group         FM_LnxKern_grp Frame Manager Linux wrapper API
+
+ @Description   FM API functions, definitions and enums.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Group         FM_LnxKern_ctrl_grp Control Unit
+
+ @Description   Control Unit
+
+                Internal Kernel Control Unit API
+ @{
+*//***************************************************************************/
+
+/*****************************************************************************/
+/*                  Internal Linux kernel routines                           */
+/*****************************************************************************/
+
+#define FM_PORT_MAX_NUM_OF_EXT_POOLS        8           /**< Max number of buffer pools allowed per port */
+
+
+/**************************************************************************//**
+ @Description   A structure ..,
+*//***************************************************************************/
+struct fm;
+
+/**************************************************************************//**
+ @Description   A structure ..,
+*//***************************************************************************/
+struct fm_port;
+
+typedef int (*alloc_pcd_fqids)(struct device    *dev,
+                               uint32_t         num,
+                               uint8_t          alignment,
+                               uint32_t         *base_fqid);
+
+struct fm_port_pcd_param {
+    alloc_pcd_fqids         cb;
+    struct device           *dev;
+};
+
+/**************************************************************************//**
+ @Description   A structure of information about each of the external
+                buffer pools used by the port,
+*//***************************************************************************/
+struct fm_port_pool_param {
+    uint8_t                 id;                 /**< External buffer pool id */
+    uint16_t                size;               /**< External buffer pool buffer size */
+};
+
+/**************************************************************************//**
+ @Description   structure for additional Rx port parameters
+*//***************************************************************************/
+struct fm_port_rx_params {
+    uint32_t                    errq;               /**< Error Queue Id. */
+    uint32_t                    defq;               /**< Default Queue Id.  */
+    uint8_t                     num_pools;          /**< Number of pools use by this port */
+    struct fm_port_pool_param   pool_param[FM_PORT_MAX_NUM_OF_EXT_POOLS];
+                                                    /**< Parameters for each pool */
+    uint8_t                     priv_data_size;     /**< Area that user may save for his own need (E.g. save the SKB) */
+    bool                        parse_results;      /**< Whether to have the parser-results in the Received buffer */
+};
+
+/**************************************************************************//**
+ @Description   structure for additional non-Rx port parameters
+*//***************************************************************************/
+struct fm_port_non_rx_params {
+    uint32_t                errq;               /**< Error Queue Id. */
+    uint32_t                defq;               /**< For Tx and HC - Default Confirmation queue,
+                                                     0 means no Tx confirmation for processed
+                                                     frames. For OP - default Rx queue. */
+    uint8_t                 priv_data_size;     /**< Area that user may save for his own need (E.g. save the SKB) */
+    bool                    parse_results;      /**< Whether to put the parser-results in the Transmitted buffer */
+};
+
+
+/**************************************************************************//**
+ @Function      fm_bind
+
+ @Description   Bind to a specific FM device.
+
+ @Param[in]     fm_dev  - the OF handle of the FM device.
+
+ @Return        A handle of the FM device.
+
+ @Cautions      Allowed only after the port was created.
+*//***************************************************************************/
+struct fm * fm_bind (struct device *fm_dev);
+
+/**************************************************************************//**
+ @Function      fm_unbind
+
+ @Description   Un-bind from a specific FM device.
+
+ @Param[in]     fm      - A handle of the FM device.
+
+ @Cautions      Allowed only after the port was created.
+*//***************************************************************************/
+void fm_unbind(struct fm *fm);
+
+void * fm_get_handle(struct fm *fm);
+struct resource * fm_get_mem_region(struct fm *fm);
+
+/**************************************************************************//**
+ @Function      fm_port_bind
+
+ @Description   Bind to a specific FM-port device (may be Rx or Tx port).
+
+ @Param[in]     fm_port_dev - the OF handle of the FM port device.
+
+ @Return        A handle of the FM port device.
+
+ @Cautions      Allowed only after the port was created.
+*//***************************************************************************/
+struct fm_port * fm_port_bind (struct device *fm_port_dev);
+
+/**************************************************************************//**
+ @Function      fm_port_unbind
+
+ @Description   Un-bind from a specific FM-port device (may be Rx or Tx port).
+
+ @Param[in]     port        - A handle of the FM port device.
+
+ @Cautions      Allowed only after the port was created.
+*//***************************************************************************/
+void fm_port_unbind(struct fm_port *port);
+
+/**************************************************************************//**
+ @Function      fm_set_rx_port_params
+
+ @Description   Configure parameters for a specific Rx FM-port device.
+
+ @Param[in]     port        - A handle of the FM port device.
+ @Param[in]     params      - Rx port parameters
+
+ @Cautions      Allowed only after the port is binded.
+*//***************************************************************************/
+void fm_set_rx_port_params(struct fm_port *port, struct fm_port_rx_params *params);
+
+/**************************************************************************//**
+ @Function      fm_port_pcd_bind
+
+ @Description   Bind as a listener on a port PCD.
+
+ @Param[in]     port        - A handle of the FM port device.
+ @Param[in]     params      - PCD port parameters
+
+ @Cautions      Allowed only after the port is binded.
+*//***************************************************************************/
+void fm_port_pcd_bind (struct fm_port *port, struct fm_port_pcd_param *params);
+
+/**************************************************************************//**
+ @Function      fm_get_tx_port_channel
+
+ @Description   Get qman-channel number for this Tx port.
+
+ @Param[in]     port        - A handle of the FM port device.
+
+ @Return        qman-channel number for this Tx port.
+
+ @Cautions      Allowed only after the port is binded.
+*//***************************************************************************/
+int fm_get_tx_port_channel(struct fm_port *port);
+
+/**************************************************************************//**
+ @Function      fm_set_tx_port_params
+
+ @Description   Configure parameters for a specific Tx FM-port device
+
+ @Param[in]     port        - A handle of the FM port device.
+ @Param[in]     params      - Tx port parameters
+
+ @Cautions      Allowed only after the port is binded.
+*//***************************************************************************/
+void fm_set_tx_port_params(struct fm_port *port, struct fm_port_non_rx_params *params);
+
+/**************************************************************************//**
+ @Function      fm_port_enable
+
+ @Description   Enable specific FM-port device (may be Rx or Tx port).
+
+ @Param[in]     port        - A handle of the FM port device.
+
+ @Cautions      Allowed only the port is initialized.
+*//***************************************************************************/
+int fm_port_enable (struct fm_port *port);
+
+/**************************************************************************//**
+ @Function      fm_port_disable
+
+ @Description   Disable specific FM-port device (may be Rx or Tx port).
+
+ @Param[in]     port        - A handle of the FM port device.
+
+ @Cautions      Allowed only the port is initialized.
+*//***************************************************************************/
+void fm_port_disable(struct fm_port *port);
+
+void * fm_port_get_handle(struct fm_port *port);
+
+/** @} */ /* end of FM_LnxKern_ctrl_grp group */
+/** @} */ /* end of FM_LnxKern_grp group */
+
+
+#endif /* __FSL_FMAN_H */
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/wrappers/Peripherals/fsl_fman_test.h b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/wrappers/Peripherals/fsl_fman_test.h
new file mode 100644
index 0000000..cc8393c
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/wrappers/Peripherals/fsl_fman_test.h
@@ -0,0 +1,68 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/******************************************************************************
+ @File          fsl_fman_test.h
+
+ @Description
+*//***************************************************************************/
+
+#ifndef __FSL_FMAN_TEST_H
+#define __FSL_FMAN_TEST_H
+
+#include <linux/types.h>
+
+
+#define FMT_RX_ERR_Q    0xffffffff
+#define FMT_RX_DFLT_Q   0xfffffffe
+#define FMT_TX_ERR_Q    0xfffffffd
+#define FMT_TX_CONF_Q   0xfffffffc
+
+
+/**************************************************************************//**
+ @Function      is_fman_test
+
+ @Description   Check if arriving frame belong to the test
+
+ @Param[in]     void * fd,  uint32_t fqid, uint8_t *buffer , uint32_t size
+
+ @Param[out]    true/false
+
+ @Cautions      Allowed only the port is initialized.
+*//***************************************************************************/
+bool is_fman_test (void     *mac_dev,
+                   uint32_t queueId,
+                   uint8_t  *buffer,
+                   uint32_t size);
+
+
+#endif /* __FSL_FMAN_TEST_H */
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/wrappers/Peripherals/lnxwrp_fm_ext.h b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/wrappers/Peripherals/lnxwrp_fm_ext.h
new file mode 100644
index 0000000..65d80a8
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/wrappers/Peripherals/lnxwrp_fm_ext.h
@@ -0,0 +1,161 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/******************************************************************************
+ @File          lnxwrp_fm_ext.h
+
+ @Description   TBD
+*//***************************************************************************/
+
+#ifndef __LNXWRP_FM_EXT_H
+#define __LNXWRP_FM_EXT_H
+
+#include "std_ext.h"
+#include "sys_ext.h"
+#include "fm_ext.h"
+#include "fm_muram_ext.h"
+#include "fm_pcd_ext.h"
+#include "fm_port_ext.h"
+#include "fm_mac_ext.h"
+
+
+/**************************************************************************//**
+ @Group         FM_LnxKern_grp Frame Manager Linux wrapper API
+
+ @Description   FM API functions, definitions and enums.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Group         FM_LnxKern_init_grp Initialization Unit
+
+ @Description   Initialization Unit
+
+                Initialization Flow:
+                Initialization of the FM Module will be carried out by the Linux
+                kernel according to the following sequence:
+                a. Calling the initialization routine with no parameters.
+                b. The driver will register to the Device-Tree.
+                c. The Linux Device-Tree will initiate a call to the driver for
+                   initialization.
+                d. The driver will read the appropriate information from the Device-Tree
+                e. [Optional] Calling the advance initialization routines to change
+                   driver's defaults.
+                f. Initialization of the device will be automatically upon using it.
+
+ @{
+*//***************************************************************************/
+
+typedef struct t_WrpFmDevSettings
+{
+    t_FmParams                  param;
+    t_SysObjectAdvConfigEntry   *advConfig;
+} t_WrpFmDevSettings;
+
+typedef struct t_WrpFmPcdDevSettings
+{
+    t_FmPcdParams               param;
+    t_SysObjectAdvConfigEntry   *advConfig;
+} t_WrpFmPcdDevSettings;
+
+typedef struct t_WrpFmPortDevSettings
+{
+    t_FmPortParams              param;
+    t_SysObjectAdvConfigEntry   *advConfig;
+} t_WrpFmPortDevSettings;
+
+typedef struct t_WrpFmMacDevSettings
+{
+    t_FmMacParams               param;
+    t_SysObjectAdvConfigEntry   *advConfig;
+} t_WrpFmMacDevSettings;
+
+
+/**************************************************************************//**
+ @Function      LNXWRP_FM_Init
+
+ @Description   Initialize the FM linux wrapper.
+
+ @Return        A handle (descriptor) of the newly created FM Linux wrapper
+                structure.
+*//***************************************************************************/
+t_Handle LNXWRP_FM_Init(void);
+
+/**************************************************************************//**
+ @Function      LNXWRP_FM_Free
+
+ @Description   Free the FM linux wrapper.
+
+ @Param[in]     h_LnxWrpFm   - A handle to the FM linux wrapper.
+
+ @Return        E_OK on success; Error code otherwise.
+*//***************************************************************************/
+t_Error  LNXWRP_FM_Free(t_Handle h_LnxWrpFm);
+
+/**************************************************************************//**
+ @Function      LNXWRP_FM_GetMacHandle
+
+ @Description   Get the FM-MAC LLD handle from the FM linux wrapper.
+
+ @Param[in]     h_LnxWrpFm   - A handle to the FM linux wrapper.
+ @Param[in]     fmId         - Index of the FM device to get the MAC handle from.
+ @Param[in]     macId        - Index of the mac handle.
+
+ @Return        A handle of the LLD compressor.
+*//***************************************************************************/
+t_Handle LNXWRP_FM_GetMacHandle(t_Handle h_LnxWrpFm, uint8_t fmId, uint8_t macId);
+
+#ifdef CONFIG_FSL_FMAN_TEST
+t_Handle LNXWRP_FM_TEST_Init(void);
+t_Error  LNXWRP_FM_TEST_Free(t_Handle h_FmTestLnxWrp);
+#endif /* CONFIG_FSL_FMAN_TEST */
+
+/** @} */ /* end of FM_LnxKern_init_grp group */
+
+
+/**************************************************************************//**
+ @Group         FM_LnxKern_ctrl_grp Control Unit
+
+ @Description   Control Unit
+
+                TBD
+ @{
+*//***************************************************************************/
+
+#include "fsl_fman.h"
+
+/** @} */ /* end of FM_LnxKern_ctrl_grp group */
+/** @} */ /* end of FM_LnxKern_grp group */
+
+
+#endif /* __LNXWRP_FM_EXT_H */
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/modules/integrations/P4080/FM/Makefile b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/modules/integrations/P4080/FM/Makefile
new file mode 100644
index 0000000..07f8c41
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/modules/integrations/P4080/FM/Makefile
@@ -0,0 +1,11 @@
+#
+# Makefile for the Freescale Ethernet controllers
+#
+EXTRA_CFLAGS           += -DVERSION=\"\"
+#
+#Include netcomm SW specific definitions
+include $(srctree)/drivers/net/dpa/NetCommSw/ncsw_config.mk
+
+obj-y		+= fmm.o
+
+
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/modules/integrations/P4080/FM/fmm.c b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/modules/integrations/P4080/FM/fmm.c
new file mode 100644
index 0000000..d4a2cb7
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/modules/integrations/P4080/FM/fmm.c
@@ -0,0 +1,205 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**************************************************************************//**
+ @File          fmm.c
+
+ @Description   FM module
+*//***************************************************************************/
+#include <linux/version.h>
+
+#if defined(CONFIG_MODVERSIONS) && !defined(MODVERSIONS)
+#define MODVERSIONS
+#endif
+#ifdef MODVERSIONS
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+#include <linux/modversions.h>
+#else
+#include <config/modversions.h>
+#endif /* LINUX_VERSION_CODE */
+#endif /* MODVERSIONS */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/proc_fs.h>
+#include <linux/smp_lock.h>
+#include <linux/uts.h>
+#include <linux/interrupt.h>
+#include <linux/reboot.h>
+#include <asm/pgtable.h>
+
+#include "error_ext.h"
+#include "std_ext.h"
+#include "xx_ext.h"
+#include "sys_ext.h"
+#include "platform_p4080_ds_ext.h"
+#include "lnxwrp_fm_ext.h"
+
+
+#define __ERR_MODULE__      MODULE_P4080
+
+
+#define DRIVER_AUTHOR   "Shlomi Gridish"
+#define DRIVER_DESC     "Frame Manager module"
+#define DRIVER_INFO     DRIVER_DESC
+
+
+MODULE_DESCRIPTION (DRIVER_INFO);
+MODULE_AUTHOR (DRIVER_AUTHOR);
+MODULE_LICENSE ("Dual BSD/GPL");
+
+
+typedef struct {
+    t_Handle                    h_Pltfrm;
+    t_Handle                    h_FmLnxWrp;
+#ifdef CONFIG_FSL_FMAN_TEST
+    t_Handle                    h_FmTestLnxWrp;
+#endif /* CONFIG_FSL_FMAN_TEST */
+} t_NcswModule;
+
+
+#ifdef MODULE
+extern int  __init __cold port_wrapper_load(void);
+extern void __exit __cold port_wrapper_unload(void);
+extern int  __init __cold mac_load(void);
+extern void __exit __cold mac_unload(void);
+extern int  __init __cold dpa_load(void);
+extern void __exit __cold dpa_unload(void);
+#endif /* MODULE */
+
+
+static t_NcswModule mod;
+
+
+#if 0
+static t_Handle ModGetObject (t_Handle h_App, e_SysModule mod, ...)
+{
+    t_NcswModule    *p_Mod = (t_NcswModule *)h_App;
+    t_Handle        obj = NULL;
+    va_list         args;
+    int             index;
+
+    va_start(args, mod);
+    index = va_arg(args, int);
+
+    switch (mod)
+    {
+        case e_SYS_MODULE_PLATFORM:
+            if (index == 0)
+                obj = p_Mod->sys.p_Descriptors[e_DESC_INTEG];
+            break;
+        default:
+            REPORT_ERROR(MINOR, E_INVALID_SELECTION, ("device-type!!!"));
+            break;
+    }
+    va_end(args);
+
+    if (!obj)
+        REPORT_ERROR(MINOR, E_INVALID_HANDLE, ("device [%d,%d]!!!", mod,index));
+    return obj;
+}
+#endif /* 0 */
+
+static void FreeInitResources(t_NcswModule *p_Mod)
+{
+#ifdef CONFIG_FSL_FMAN_TEST
+    if (p_Mod->h_FmTestLnxWrp)
+        LNXWRP_FM_TEST_Free(p_Mod->h_FmTestLnxWrp);
+#endif /* CONFIG_FSL_FMAN_TEST */
+
+    if (p_Mod->h_FmLnxWrp)
+        LNXWRP_FM_Free(p_Mod->h_FmLnxWrp);
+
+    PLATFORM_Free(&p_Mod->h_Pltfrm);
+}
+
+/*-------------------------------------------------------------------------*/
+static int __init __cold fm_load (void)
+{
+    t_PlatformParam     platformParam;
+
+    memset(&platformParam, 0, sizeof(platformParam));
+    if ((mod.h_Pltfrm = PLATFORM_Init(&platformParam)) == NULL)
+    {
+        printk("Failed to init general modules!\n");
+        return -ENODEV;
+    }
+
+    if ((mod.h_FmLnxWrp = LNXWRP_FM_Init()) == NULL)
+    {
+        printk("Failed to init FM wrapper!\n");
+        FreeInitResources(&mod);
+        return -ENODEV;
+    }
+
+#ifdef MODULE
+    if (port_wrapper_load() || mac_load() || dpa_load())
+    {
+        printk("Failed to init port-wrapper or MAC or DPA driver!\n");
+        FreeInitResources(&mod);
+        return -ENODEV;
+    }
+#endif /* MODULE */
+
+#ifdef CONFIG_FSL_FMAN_TEST
+    if ((mod.h_FmTestLnxWrp = LNXWRP_FM_TEST_Init()) == NULL)
+    {
+        printk("Failed to init FM-test wrapper!\n");
+        FreeInitResources(&mod);
+        return -ENODEV;
+    }
+#endif /* CONFIG_FSL_FMAN_TEST */
+
+    printk (KERN_CRIT "Freescale FM module ("__DATE__ ":"__TIME__")\n\n");
+
+    return 0;
+}
+
+static void __exit __cold fm_unload (void)
+{
+#ifdef MODULE
+    dpa_unload();
+    mac_unload();
+    port_wrapper_unload();
+#endif /* MODULE */
+
+    FreeInitResources(&mod);
+}
+
+module_init (fm_load);
+module_exit (fm_unload);
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/modules/integrations/P4080/FM/mod_config.h b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/modules/integrations/P4080/FM/mod_config.h
new file mode 100644
index 0000000..decb8d3
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/modules/integrations/P4080/FM/mod_config.h
@@ -0,0 +1,41 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __SYS_CONFIG_H
+#define __SYS_CONFIG_H
+
+
+/* System & Platform Modules */
+#define SYS_CFG_FM          ON
+
+
+#endif /* __SYS_CONFIG_H */
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/system/Makefile b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/system/Makefile
new file mode 100644
index 0000000..441eda1
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/system/Makefile
@@ -0,0 +1,13 @@
+#
+# Makefile for the Freescale Ethernet controllers
+#
+EXTRA_CFLAGS           += -DVERSION=\"\"
+#
+#Include netcomm SW specific definitions
+include $(srctree)/drivers/net/dpa/NetCommSw/ncsw_config.mk
+#
+
+obj-y		+= sys_io.o
+
+
+obj-y		+= platform/P4080/
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/system/platform/P4080/Makefile b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/system/platform/P4080/Makefile
new file mode 100644
index 0000000..f67748f
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/system/platform/P4080/Makefile
@@ -0,0 +1,9 @@
+#
+# Makefile for the Freescale Ethernet controllers
+#
+EXTRA_CFLAGS           += -DVERSION=\"\"
+#
+#Include netcomm SW specific definitions
+include $(srctree)/drivers/net/dpa/NetCommSw/ncsw_config.mk
+
+obj-y		+= platform_p4080_ds.o
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/system/platform/P4080/platform_p4080_ds.c b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/system/platform/P4080/platform_p4080_ds.c
new file mode 100644
index 0000000..188ee51
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/system/platform/P4080/platform_p4080_ds.c
@@ -0,0 +1,124 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <linux/version.h>
+
+#if defined(CONFIG_MODVERSIONS) && !defined(MODVERSIONS)
+#define MODVERSIONS
+#endif
+#ifdef MODVERSIONS
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+#include <linux/modversions.h>
+#else
+#include <config/modversions.h>
+#endif    /* LINUX_VERSION_CODE */
+#endif /* MODVERSIONS */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+
+#include <sysdev/fsl_soc.h>
+
+#include <asm/io.h>
+
+#include "std_ext.h"
+#include "error_ext.h"
+#include "part_ext.h"
+#include "string_ext.h"
+#include "xx_ext.h"
+#include "sys_io_ext.h"
+#include "platform_p4080_ds_ext.h"
+
+
+#define __ERR_MODULE__      MODULE_UNKNOWN
+
+
+typedef struct t_Platform
+{
+    /* Platform-owned module handles */
+    t_Handle                h_Part;
+    /* Clocks-related variables */
+    uint32_t                clockInFreqHz;
+    uint32_t                localBusFreqHz;
+} t_Platform;
+
+
+uint32_t ram_virt_addr;
+uint32_t ram_phys_addr;
+uint32_t ram_size;
+
+
+
+/*---------------------------------------------------------------------------*/
+/*                       P4080-MDS Platform Init                             */
+/*---------------------------------------------------------------------------*/
+t_Handle PLATFORM_Init(t_PlatformParam *p_PlatformParam)
+{
+    t_Platform                  *p_Platform;
+
+    SANITY_CHECK_RETURN_VALUE(p_PlatformParam, E_NULL_POINTER, NULL);
+
+    /* Allocate the platform's control structure */
+    p_Platform = XX_Malloc(sizeof(t_Platform));
+    if (!p_Platform)
+    {
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("Platform structure"));
+        return NULL;
+    }
+    memset(p_Platform, 0, sizeof(t_Platform));
+
+    ram_virt_addr = (uint32_t)phys_to_virt(0);
+    ram_phys_addr = 0x0;
+    ram_size      = 0x20000000;
+    if (SYS_RegisterIoMap((uint64_t)ram_virt_addr, (uint64_t)ram_phys_addr, ram_size) != E_OK)
+    {
+        REPORT_ERROR(MAJOR, E_INVALID_STATE, ("RAM memory map"));
+        return NULL;
+    }
+
+    return p_Platform;
+}
+
+/*****************************************************************************/
+t_Error PLATFORM_Free(t_Handle h_Platform)
+{
+    t_Platform *p_Platform = (t_Platform *)h_Platform;
+
+    if (!p_Platform)
+        RETURN_ERROR(MINOR, E_INVALID_HANDLE, NO_MSG);
+
+    SYS_UnregisterIoMap((uint64_t)ram_virt_addr);
+
+    XX_Free(p_Platform);
+
+    return E_OK;
+}
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/system/sys_init.c b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/system/sys_init.c
new file mode 100644
index 0000000..a95c461
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/system/sys_init.c
@@ -0,0 +1,48 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+
+#include "std_ext.h"
+#include "error_ext.h"
+#include "sys_ext.h"
+
+
+/*****************************************************************************/
+void SYS_Init(void)
+{
+
+}
+
+void SYS_Free(void)
+{
+
+}
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/system/sys_io.c b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/system/sys_io.c
new file mode 100644
index 0000000..e6e2125
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/system/sys_io.c
@@ -0,0 +1,179 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <linux/version.h>
+
+#if defined(CONFIG_MODVERSIONS) && !defined(MODVERSIONS)
+#define MODVERSIONS
+#endif
+#ifdef MODVERSIONS
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+#include <linux/modversions.h>
+#else
+#include <config/modversions.h>
+#endif    /* LINUX_VERSION_CODE */
+#endif /* MODVERSIONS */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+
+#include <asm/io.h>
+
+#include "std_ext.h"
+#include "error_ext.h"
+#include "string_ext.h"
+#include "list_ext.h"
+#include "sys_io_ext.h"
+
+
+#define __ERR_MODULE__      MODULE_UNKNOWN
+
+
+typedef struct {
+    uint64_t    virtAddr;
+    uint64_t    physAddr;
+    uint32_t    size;
+    t_List      node;
+} t_IoMap;
+#define IOMAP_OBJECT(ptr)  LIST_OBJECT(ptr, t_IoMap, node)
+
+LIST(mapsList);
+
+
+static void EnqueueIoMap(t_IoMap *p_IoMap)
+{
+    uint32_t   intFlags;
+
+    intFlags = XX_DisableAllIntr();
+    LIST_AddToTail(&p_IoMap->node, &mapsList);
+    XX_RestoreAllIntr(intFlags);
+}
+
+#if 0
+static t_IoMap * DequeueIoMap(void)
+{
+    t_IoMap     *p_IoMap = NULL;
+    uint32_t    intFlags;
+
+    intFlags = XX_DisableAllIntr();
+    if (!LIST_IsEmpty(&mapsList))
+    {
+        p_IoMap = IOMAP_OBJECT(mapsList.p_Next);
+        LIST_DelAndInit(&p_IoMap->node);
+    }
+    XX_RestoreAllIntr(intFlags);
+
+    return p_IoMap;
+}
+#endif /* 0 */
+
+static t_IoMap * FindIoMapByVirtAddr(uint64_t addr)
+{
+    t_IoMap     *p_IoMap;
+    t_List      *p_Pos;
+
+    LIST_FOR_EACH(p_Pos, &mapsList)
+    {
+        p_IoMap = IOMAP_OBJECT(p_Pos);
+        if ((addr >= p_IoMap->virtAddr) && (addr < p_IoMap->virtAddr+p_IoMap->size))
+            return p_IoMap;
+    }
+
+    return NULL;
+}
+
+static t_IoMap * FindIoMapByPhysAddr(uint64_t addr)
+{
+    t_IoMap     *p_IoMap;
+    t_List      *p_Pos;
+
+    LIST_FOR_EACH(p_Pos, &mapsList)
+    {
+        p_IoMap = IOMAP_OBJECT(p_Pos);
+        if ((addr >= p_IoMap->physAddr) && (addr < p_IoMap->physAddr+p_IoMap->size))
+            return p_IoMap;
+    }
+
+    return NULL;
+}
+
+t_Error SYS_RegisterIoMap (uint64_t virtAddr, uint64_t physAddr, uint32_t size)
+{
+    t_IoMap *p_IoMap;
+
+    p_IoMap = (t_IoMap*)XX_Malloc(sizeof(t_IoMap));
+    if (!p_IoMap)
+        RETURN_ERROR(MINOR, E_NO_MEMORY, ("message handler object!!!"));
+    memset(p_IoMap, 0, sizeof(t_IoMap));
+
+    p_IoMap->virtAddr = virtAddr;
+    p_IoMap->physAddr = physAddr;
+    p_IoMap->size     = size;
+
+    INIT_LIST(&p_IoMap->node);
+    EnqueueIoMap(p_IoMap);
+
+    return E_OK;
+}
+
+t_Error SYS_UnregisterIoMap  (uint64_t virtAddr)
+{
+    t_IoMap *p_IoMap = FindIoMapByVirtAddr(virtAddr);
+    if (!p_IoMap)
+        RETURN_ERROR(MINOR, E_NO_DEVICE, ("message handler not found in list!!!"));
+
+    LIST_Del(&p_IoMap->node);
+    XX_Free(p_IoMap);
+
+    return E_OK;
+}
+
+uint64_t SYS_PhysToVirt(uint64_t addr)
+{
+    t_IoMap *p_IoMap = FindIoMapByPhysAddr(addr);
+    if (p_IoMap)
+        return (uint64_t)(addr - p_IoMap->physAddr + p_IoMap->virtAddr);
+    return CAST_POINTER_TO_UINT64(phys_to_virt((unsigned long)addr));
+}
+
+uint64_t SYS_VirtToPhys(uint64_t addr)
+{
+    t_IoMap *p_IoMap;
+
+    if (addr == 0)
+        return 0;
+
+    p_IoMap = FindIoMapByVirtAddr(addr);
+    if (p_IoMap)
+        return (uint64_t)(addr - p_IoMap->virtAddr + p_IoMap->physAddr);
+    return (uint64_t)virt_to_phys(CAST_UINT64_TO_POINTER(addr));
+}
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/util/Makefile b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/util/Makefile
new file mode 100644
index 0000000..7edbea6
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/util/Makefile
@@ -0,0 +1,11 @@
+#
+# Makefile for the Freescale Ethernet controllers
+#
+EXTRA_CFLAGS           += -DVERSION=\"\"
+#
+#Include netcomm SW specific definitions
+include $(srctree)/drivers/net/dpa/NetCommSw/ncsw_config.mk
+
+obj-y		+= procbuff.o
+
+
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/util/procbuff.c b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/util/procbuff.c
new file mode 100644
index 0000000..eb59680
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/util/procbuff.c
@@ -0,0 +1,116 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "std_ext.h"
+#include "string_ext.h"
+#include "sprint_ext.h"
+#include "stdarg_ext.h"
+#include "xx_ext.h"
+
+#include "procbuff.h"
+
+
+t_Handle    ProcBuff_Init(char *buffer,char **start,int offset,int length, int *eof)
+{
+    t_ProcBuff  * p_ProcBuff = XX_Malloc(sizeof(t_ProcBuff));
+
+    if (p_ProcBuff)
+    {
+        p_ProcBuff->num_of_written_chars = 0;
+        p_ProcBuff->buffer = buffer;
+        p_ProcBuff->offset = offset;
+        p_ProcBuff->length = length;
+        p_ProcBuff->eof = eof;
+
+        if(start)
+            *start = buffer;
+        *(p_ProcBuff->eof) = 0;
+    }
+
+    return (t_Handle)(p_ProcBuff);
+}
+
+void        ProcBuff_Free (t_Handle h_ProcBuff)
+{
+    t_ProcBuff  * p_ProcBuff = (t_ProcBuff *)(h_ProcBuff);
+    XX_Free(p_ProcBuff);
+}
+
+void         ProcBuff_Write (t_Handle h_ProcBuff,const char *fmt, ...)
+{
+    t_ProcBuff  * p_ProcBuff = (t_ProcBuff *)(h_ProcBuff);
+    int         len;
+    va_list     args;
+    char        str[MAX_LINE_SIZE];
+
+    va_start(args, fmt);
+    len=vsnprintf(str,MAX_LINE_SIZE,fmt,args);
+    va_end(args);
+
+    if (len == -1 || len >= MAX_LINE_SIZE)
+    {
+        /* formated string truncated, it is to big to fit into the MAX_LINE_SIZE */
+        len = MAX_LINE_SIZE - 1;
+        str[len] = 0;
+    }
+
+    if (len <= p_ProcBuff->offset)
+        p_ProcBuff->offset -= len;
+    else
+    {
+        len -= p_ProcBuff->offset;
+        if (len > p_ProcBuff->length)
+            len = p_ProcBuff->length;
+        strncpy(p_ProcBuff->buffer,str + p_ProcBuff->offset,(unsigned int)(len));
+
+        p_ProcBuff->buffer += len;
+        p_ProcBuff->length -= len;
+        if (p_ProcBuff->offset)
+            p_ProcBuff->offset = 0;
+        p_ProcBuff->num_of_written_chars += len;
+    }
+}
+
+int          ProcBuff_GetNumOfWrittenChars(t_Handle h_ProcBuff)
+{
+    t_ProcBuff  * p_ProcBuff = (t_ProcBuff *)(h_ProcBuff);
+
+    return p_ProcBuff->num_of_written_chars;
+}
+
+void         ProcBuff_Done (t_Handle h_ProcBuff)
+{
+    t_ProcBuff  * p_ProcBuff = (t_ProcBuff *)(h_ProcBuff);
+
+    if (p_ProcBuff->length)
+        *(p_ProcBuff->eof) = 1;
+}
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/util/procbuff.h b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/util/procbuff.h
new file mode 100644
index 0000000..d21382b
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/util/procbuff.h
@@ -0,0 +1,48 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __PROCBUFF_H
+#define __PROCBUFF_H
+
+#include "procbuff_ext.h"
+
+
+typedef struct t_ProcBuff {
+    int     num_of_written_chars;
+    char    *buffer;
+    int     length;
+    int     *eof;
+    int     offset;
+} t_ProcBuff;
+
+
+#endif /* __PROCBUFF_H */
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/Makefile b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/Makefile
new file mode 100644
index 0000000..73354b9
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/Makefile
@@ -0,0 +1,15 @@
+#
+# Makefile for the Freescale Ethernet controllers
+#
+EXTRA_CFLAGS           += -DVERSION=\"\"
+#
+#Include netcomm SW specific definitions
+include $(srctree)/drivers/net/dpa/NetCommSw/ncsw_config.mk
+
+#EXTRA_CFLAGS += -I$(NCSW_FM_INC)
+EXTRA_CFLAGS += -I$(NET_DPA)
+
+obj-y		+= fsl-ncsw-PFM.o
+obj-$(CONFIG_FSL_FMAN_TEST)	+= fman_test.o
+
+fsl-ncsw-PFM-objs	:=   lnxwrp_fm.o lnxwrp_fm_ioctls.o
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/fman_test.c b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/fman_test.c
new file mode 100644
index 0000000..0c1665f
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/fman_test.c
@@ -0,0 +1,610 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**************************************************************************//**
+ @File          fman_test.c
+
+ @Author        Moti Bar
+
+ @Description   FM Linux test
+*//***************************************************************************/
+
+/* Linux Headers ------------------- */
+#include <linux/version.h>
+
+#if defined(CONFIG_MODVERSIONS) && !defined(MODVERSIONS)
+#define MODVERSIONS
+#endif
+#ifdef MODVERSIONS
+#include <config/modversions.h>
+#endif /* MODVERSIONS */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/fs.h>
+#include <linux/cdev.h>
+#include <linux/device.h>
+#include <linux/io.h>
+#include <linux/ioport.h>
+#include <linux/fsl_qman.h>     /*struct qman_fq */
+#include <linux/of_platform.h>
+#include <asm/uaccess.h>
+#include <asm/errno.h>
+
+/* NetCommSw Headers --------------- */
+#include "std_ext.h"
+#include "error_ext.h"
+#include "debug_ext.h"
+#include "list_ext.h"
+#include "fm_ext.h"
+
+#include "fm_test_ioctls.h"
+#include "fsl_fman.h"
+#include "fsl_fman_test.h"
+#include "fm_port_ext.h"
+
+
+#define __ERR_MODULE__      MODULE_FM
+
+#define FMT_FRM_WATERMARK   0xdeadbeefdeadbeeaLL
+
+
+typedef struct {
+    ioc_fmt_buff_desc_t     buff;
+    t_List                  node;
+} t_FmTestFrame;
+#define FMT_FRAME_OBJECT(ptr)  LIST_OBJECT(ptr, t_FmTestFrame, node)
+
+typedef struct t_FmTestFq {
+    struct qman_fq      fq_base;
+    struct list_head    list;
+    void                *port;
+    bool                init;
+} t_FmTestFq;
+
+typedef struct {
+    bool                valid;
+    uint8_t             id;
+    ioc_fmt_port_type   portType;
+    struct fm_port      *p_TxPort;
+    t_Handle            h_TxFmPortDev;
+    struct fm_port      *p_RxPort;
+    t_Handle            h_RxFmPortDev;
+    t_Handle            h_Mac;
+    t_List              rxFrmsQ;
+
+    int                 numOfTxQs;
+    struct qman_fq      *p_TxFqs[8];
+} t_FmTestPort;
+
+typedef struct {
+    int major;
+    t_FmTestPort ports[IOC_FMT_MAX_NUM_OF_PORTS];
+} t_FmTest;
+
+
+static t_FmTest fmTest;
+
+
+static void EnqueueFrameToRxQ(t_FmTestPort *p_FmTestPort, t_FmTestFrame *p_FmTestFrame)
+{
+    uint32_t   intFlags;
+
+    intFlags = XX_DisableAllIntr();
+    LIST_AddToTail(&p_FmTestFrame->node, &p_FmTestPort->rxFrmsQ);
+    XX_RestoreAllIntr(intFlags);
+}
+
+static t_FmTestFrame * DequeueFrameFromRxQ(t_FmTestPort *p_FmTestPort)
+{
+    t_FmTestFrame   *p_FmTestFrame = NULL;
+    uint32_t        intFlags;
+
+    intFlags = XX_DisableAllIntr();
+    if (!LIST_IsEmpty(&p_FmTestPort->rxFrmsQ))
+    {
+        p_FmTestFrame = FMT_FRAME_OBJECT(p_FmTestPort->rxFrmsQ.p_Next);
+        LIST_DelAndInit(&p_FmTestFrame->node);
+    }
+    XX_RestoreAllIntr(intFlags);
+
+    return p_FmTestFrame;
+}
+
+static enum qman_cb_dqrr_result egress_dqrr(struct qman_portal          *portal,
+                                            struct qman_fq              *fq,
+                                            const struct qm_dqrr_entry  *dq)
+{
+    BUG();
+    return qman_cb_dqrr_consume;
+}
+
+static void egress_ern(struct qman_portal       *portal,
+                       struct qman_fq           *fq,
+                       const struct qm_mr_entry *msg)
+{
+    BUG();
+}
+
+static struct qman_fq * FqAlloc(t_FmTestPort    *p_FmTestPort,
+                                uint32_t        fqid,
+                                uint32_t        flags,
+                                uint16_t        channel,
+                                uint8_t         wq)
+{
+    int                     _errno;
+    struct qman_fq          *fq = NULL;
+    t_FmTestFq              *p_FmtFq;
+    struct qm_mcc_initfq    initfq;
+
+    p_FmtFq = (t_FmTestFq *)XX_Malloc(sizeof(t_FmTestFq));
+    if (!p_FmtFq) {
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FQ obj!!!"));
+        return NULL;
+    }
+
+    p_FmtFq->fq_base.cb.dqrr = egress_dqrr;
+    p_FmtFq->fq_base.cb.ern = p_FmtFq->fq_base.cb.dc_ern = p_FmtFq->fq_base.cb.fqs = egress_ern;
+    p_FmtFq->port = (void *)p_FmTestPort;
+    if (fqid == 0) {
+        flags |= QMAN_FQ_FLAG_DYNAMIC_FQID;
+        flags &= ~QMAN_FQ_FLAG_NO_MODIFY;
+    } else {
+        flags &= ~QMAN_FQ_FLAG_DYNAMIC_FQID;
+    }
+
+    p_FmtFq->init    = !(flags & QMAN_FQ_FLAG_NO_MODIFY);
+
+    DBG(TRACE, ("fqid %d, flags 0x%08x, channel %d, wq %d",fqid,flags,channel,wq));
+
+    _errno = qman_create_fq(fqid, flags, &p_FmtFq->fq_base);
+    if (unlikely(_errno)) {
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FQ obj - qman_new_fq!!!"));
+        XX_Free(p_FmtFq);
+        return NULL;
+    }
+    fq = &p_FmtFq->fq_base;
+
+    if (p_FmtFq->init) {
+        initfq.we_mask            = QM_INITFQ_WE_DESTWQ;
+        initfq.fqd.dest.channel   = channel;
+        initfq.fqd.dest.wq        = wq;
+
+        _errno = qman_init_fq(fq, QMAN_INITFQ_FLAG_SCHED, &initfq);
+        if (unlikely(_errno < 0)) {
+            REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FQ obj - qman_init_fq!!!"));
+            qman_destroy_fq(fq, 0);
+            XX_Free(p_FmtFq);
+            return NULL;
+        }
+    }
+
+    return fq;
+}
+
+static t_Error PortInit (t_FmTestPort *p_FmTestPort, ioc_fmt_port_param_t *p_Params)
+{
+    struct of_device_id name;
+    struct device_node  *fm_node, *fm_port_node;
+    const uint32_t      *uint32_prop;
+    int                 lenp;
+    uint32_t            i;
+
+    INIT_LIST(&p_FmTestPort->rxFrmsQ);
+    p_FmTestPort->numOfTxQs = p_Params->num_tx_queues;
+    p_FmTestPort->id        = p_Params->fm_port_id;
+    p_FmTestPort->portType  = p_Params->fm_port_type;
+
+    /* Get all the FM nodes */
+    memset(&name, 0, sizeof(struct of_device_id));
+    BUG_ON(strlen("fsl,fman") >= sizeof(name.compatible));
+    strcpy(name.compatible, "fsl,fman");
+    for_each_matching_node(fm_node, &name) {
+        uint32_prop = (uint32_t *)of_get_property(fm_node, "cell-index", &lenp);
+        if (unlikely(uint32_prop == NULL)) {
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("of_get_property(%s, cell-index) failed", fm_node->full_name));
+        }
+        BUG_ON(lenp != sizeof(uint32_t));
+        if (*uint32_prop == p_Params->fm_id) {
+            for_each_child_of_node(fm_node, fm_port_node) {
+                struct of_device    *of_dev;
+                uint32_prop = (uint32_t *)of_get_property(fm_port_node, "cell-index", &lenp);
+                if (uint32_prop == NULL)
+                    continue;
+
+                if (of_device_is_compatible(fm_port_node, "fsl,fman-port-oh") &&
+                    (p_FmTestPort->portType  == e_IOC_FMT_PORT_T_OP)) {
+                    if (*uint32_prop == p_FmTestPort->id)
+                    {
+                        of_dev = of_find_device_by_node(fm_port_node);
+                        if (unlikely(of_dev == NULL))
+                            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fm id!"));
+                        p_FmTestPort->p_TxPort = fm_port_bind(&of_dev->dev);
+                        p_FmTestPort->h_TxFmPortDev = (t_Handle)fm_port_get_handle(p_FmTestPort->p_TxPort);
+                        break;
+                    }
+                }
+
+                else if ((*uint32_prop == p_FmTestPort->id) &&
+                          p_FmTestPort->portType  == e_IOC_FMT_PORT_T_RXTX) {
+                    of_dev = of_find_device_by_node(fm_port_node);
+                    if (unlikely(of_dev == NULL))
+                        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fm id!"));
+                    if(of_device_is_compatible(fm_port_node, "fsl,fman-port-1g-tx"))
+                    {
+                        p_FmTestPort->p_TxPort = fm_port_bind(&of_dev->dev);
+                        p_FmTestPort->h_TxFmPortDev = (t_Handle)fm_port_get_handle(p_FmTestPort->p_TxPort);
+                    }
+                    else if(of_device_is_compatible(fm_port_node, "fsl,fman-port-1g-rx"))
+                    {
+                        p_FmTestPort->p_RxPort = fm_port_bind(&of_dev->dev);
+                        p_FmTestPort->h_RxFmPortDev = (t_Handle)fm_port_get_handle(p_FmTestPort->p_RxPort);
+                    }
+                    else if (of_device_is_compatible(fm_port_node, "fsl,fman-1g-mac"))
+                        p_FmTestPort->h_Mac = (typeof(p_FmTestPort->h_Mac))dev_get_drvdata(&of_dev->dev);
+                    else
+                        continue;
+                    if(p_FmTestPort->h_RxFmPortDev && p_FmTestPort->h_RxFmPortDev && p_FmTestPort->h_Mac)
+                        break;
+                }
+
+                else if (((*uint32_prop + FM_MAX_NUM_OF_1G_RX_PORTS )== p_FmTestPort->id) &&
+                          p_FmTestPort->portType  == e_IOC_FMT_PORT_T_RXTX) {
+                    of_dev = of_find_device_by_node(fm_port_node);
+                    if (unlikely(of_dev == NULL))
+                        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fm id!"));
+                    if(of_device_is_compatible(fm_port_node, "fsl,fman-port-10g-tx"))
+                    {
+                        p_FmTestPort->p_TxPort = fm_port_bind(&of_dev->dev);
+                        p_FmTestPort->h_TxFmPortDev = (t_Handle)fm_port_get_handle(p_FmTestPort->p_TxPort);
+                    }
+                    else if(of_device_is_compatible(fm_port_node, "fsl,fman-port-10g-rx"))
+                    {
+                        p_FmTestPort->p_RxPort = fm_port_bind(&of_dev->dev);
+                        p_FmTestPort->h_RxFmPortDev = (t_Handle)fm_port_get_handle(p_FmTestPort->p_RxPort);
+                    }
+                    else if (of_device_is_compatible(fm_port_node, "fsl,fman-10g-mac"))
+                        p_FmTestPort->h_Mac = (typeof(p_FmTestPort->h_Mac))dev_get_drvdata(&of_dev->dev);
+                    else
+                        continue;
+                    if(p_FmTestPort->h_RxFmPortDev && p_FmTestPort->h_RxFmPortDev && p_FmTestPort->h_Mac)
+                        break;
+                }
+            } //for_each_child
+        }
+    } //for each matching node
+
+    DBG(TRACE, ("h_TxFmPortDev - 0x%08x, h_RxFmPortDev - 0x%08x, h_Mac - 0x%08x\n",
+        p_FmTestPort->h_TxFmPortDev,p_FmTestPort->h_RxFmPortDev,p_FmTestPort->h_Mac));
+
+    //init Queues
+    for (i=0; i<p_FmTestPort->numOfTxQs; i++) {
+        p_FmTestPort->p_TxFqs[i] =
+            FqAlloc(p_FmTestPort,
+                    0,
+                    QMAN_FQ_FLAG_TO_DCPORTAL,
+                    fm_get_tx_port_channel(p_FmTestPort->p_TxPort),
+                    i);
+        if (IS_ERR(p_FmTestPort->p_TxFqs[i]))
+            RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("Tx FQs!"));
+    }
+
+    p_FmTestPort->valid     = TRUE;
+
+    return E_OK;
+}
+
+
+bool is_fman_test (void     *mac_dev,
+                   uint32_t queueId,
+                   uint8_t  *buffer,
+                   uint32_t size)
+{
+    t_FmTest                *p_FmTest = &fmTest;
+    t_FmTestPort            *p_FmTestPort=NULL;
+    t_FmTestFrame           *p_FmTestFrame;
+    uint32_t                count=size-7;
+    uint64_t                temp;
+    uint8_t                 *temp_buf=buffer, i;
+    bool                    fman_test_flag = false;
+    uint32_t                dataOffset;
+
+    if ((queueId == FMT_TX_CONF_Q) || (queueId == FMT_TX_ERR_Q))
+    {
+        /* Get the FM-test-port object */
+        for (i=0; i<IOC_FMT_MAX_NUM_OF_PORTS; i++)
+            if (mac_dev == p_FmTest->ports[i].h_Mac)
+                p_FmTestPort = &p_FmTest->ports[i];
+        if (!p_FmTestPort)
+            return false;
+
+        XX_Free(buffer);
+        return true;
+    }
+
+    /* Get the FM-test-port object */
+    for (i=0; i<IOC_FMT_MAX_NUM_OF_PORTS; i++)
+        if (mac_dev == p_FmTest->ports[i].h_Mac)
+            p_FmTestPort = &p_FmTest->ports[i];
+    if (!p_FmTestPort)
+        return false;
+
+    /* Check according to watermark if this frame is for FM-test */
+    while(count--)
+    {
+        temp = *(uint64_t *)temp_buf;
+        if (temp == FMT_FRM_WATERMARK)
+        {
+            fman_test_flag = true;
+            break;
+        }
+        temp_buf++;
+    }
+
+    if (fman_test_flag)
+    {
+        dataOffset = FM_PORT_GetBufferDataOffset(p_FmTestPort->h_RxFmPortDev);
+        p_FmTestFrame = (t_FmTestFrame *)XX_Malloc(sizeof(t_FmTestFrame));
+        memset(p_FmTestFrame, 0, sizeof(t_FmTestFrame));
+        INIT_LIST(&p_FmTestFrame->node);
+
+        p_FmTestFrame->buff.p_data = (uint8_t *)XX_Malloc(size * sizeof(uint8_t));
+        p_FmTestFrame->buff.size = size-dataOffset;
+        p_FmTestFrame->buff.qid = queueId;
+
+        memcpy(p_FmTestFrame->buff.p_data,
+               CAST_UINT64_TO_POINTER_TYPE(uint8_t,(CAST_POINTER_TO_UINT64(buffer)+dataOffset)),
+               p_FmTestFrame->buff.size);
+
+        memcpy(p_FmTestFrame->buff.buff_context.fm_prs_res,
+               FM_PORT_GetBufferPrsResult(p_FmTestPort->h_RxFmPortDev, (char*)buffer),
+               32);
+
+        EnqueueFrameToRxQ(p_FmTestPort, p_FmTestFrame);
+        return true;
+    }
+
+    return false;
+}
+
+
+/*****************************************************************************/
+/*               API routines for the FM Linux Device                        */
+/*****************************************************************************/
+
+static int fm_test_open(struct inode *inode, struct file *file)
+{
+    t_FmTest            *p_FmTest = &fmTest;
+    //unsigned int        major = imajor(inode);
+    unsigned int        minor = iminor(inode);
+
+    DBG(TRACE, ("Opening minor - %d - ", minor));
+
+    if (file->private_data != NULL)
+        return 0;
+
+    if ((minor >= DEV_FM_TEST_PORTS_MINOR_BASE) &&
+        (minor < DEV_FM_TEST_MAX_MINORS))
+        file->private_data = &p_FmTest->ports[minor];
+    else
+        return -ENXIO;
+
+    return 0;
+}
+
+static int fm_test_close(struct inode *inode, struct file *file)
+{
+    t_FmTestPort        *p_FmTestPort;
+    unsigned int        minor = iminor(inode);
+    int                 err = 0;
+
+    DBG(TRACE, ("Closing minor - %d - ", minor));
+
+    p_FmTestPort = file->private_data;
+    if (!p_FmTestPort)
+        return -ENODEV;
+
+    p_FmTestPort->valid = FALSE;
+
+    /* Complete!!! */
+    return err;
+}
+
+static int fm_test_ioctl(struct inode *inode, struct file *file, unsigned int cmd, unsigned long arg)
+{
+    t_FmTestPort        *p_FmTestPort;
+    unsigned int        minor = iminor(inode);
+
+    DBG(TRACE, ("IOCTL minor - %d, cmd - 0x%08x, arg - 0x%08x", minor, cmd, arg));
+
+    p_FmTestPort = file->private_data;
+    if (!p_FmTestPort)
+        return -ENODEV;
+
+    switch (cmd)
+    {
+        case FMT_PORT_IOC_INIT:
+        {
+            ioc_fmt_port_param_t  param;
+
+            if (p_FmTestPort->valid) {
+                REPORT_ERROR(MINOR, E_INVALID_STATE, ("port is already initialized!!!"));
+                return -EFAULT;
+            }
+
+            if (copy_from_user(&param, (ioc_fmt_port_param_t *)arg, sizeof(ioc_fmt_port_param_t))) {
+                REPORT_ERROR(MINOR, E_INVALID_STATE, NO_MSG);
+                return -EFAULT;
+            }
+
+            return PortInit(p_FmTestPort, &param);
+        }
+        default:
+            REPORT_ERROR(MINOR, E_NOT_SUPPORTED, ("IOCTL"));
+            return -EFAULT;
+    }
+
+    return 0;
+}
+
+ssize_t fm_test_read (struct file *file, char __user *buf, size_t size, loff_t *ppos)
+{
+    t_FmTestPort        *p_FmTestPort;
+    t_FmTestFrame       *p_FmTestFrame;
+    ssize_t             cnt;
+
+    p_FmTestPort = file->private_data;
+    if (!p_FmTestPort || !p_FmTestPort->valid)
+        return -ENODEV;
+
+    p_FmTestFrame = DequeueFrameFromRxQ(p_FmTestPort);
+    if (!p_FmTestFrame)
+        return 0;
+
+    cnt = sizeof(ioc_fmt_buff_desc_t);
+    if (size<cnt) {
+        REPORT_ERROR(MINOR, E_NO_MEMORY, ("Illegal buffer-size!"));
+        return 0;
+    }
+    if (copy_to_user(buf, &p_FmTestFrame->buff, cnt)) {
+        REPORT_ERROR(MINOR, E_INVALID_STATE, NO_MSG);
+        return 0;
+    }
+
+    ((ioc_fmt_buff_desc_t *)buf)->p_data = buf+sizeof(ioc_fmt_buff_desc_t);
+
+    cnt += MIN(p_FmTestFrame->buff.size, size-cnt);
+    if (size<cnt) {
+        REPORT_ERROR(MINOR, E_NO_MEMORY, ("Illegal buffer-size!"));
+        return 0;
+    }
+
+    if (copy_to_user(buf+sizeof(ioc_fmt_buff_desc_t), p_FmTestFrame->buff.p_data, cnt)) {
+        REPORT_ERROR(MINOR, E_INVALID_STATE, NO_MSG);
+        return 0;
+    }
+
+    XX_Free(p_FmTestFrame->buff.p_data);
+    XX_Free(p_FmTestFrame);
+
+    return cnt;
+}
+
+ssize_t fm_test_write (struct file *file, const char __user *buf, size_t size, loff_t *ppos)
+{
+    t_FmTestPort        *p_FmTestPort;
+    ioc_fmt_buff_desc_t buffDesc;
+    t_FmFD              fd;
+    uint8_t             *p_Data;
+    uint32_t            dataOffset;
+    int                 _errno;
+
+    p_FmTestPort = file->private_data;
+    if (!p_FmTestPort || !p_FmTestPort->valid) {
+        REPORT_ERROR(MINOR, E_INVALID_HANDLE, NO_MSG);
+        return 0;
+    }
+
+    if (copy_from_user(&buffDesc, (ioc_fmt_buff_desc_t *)buf, sizeof(ioc_fmt_buff_desc_t))) {
+        REPORT_ERROR(MINOR, E_INVALID_STATE, NO_MSG);
+        return 0;
+    }
+
+    dataOffset = FM_PORT_GetBufferDataOffset(p_FmTestPort->h_TxFmPortDev);
+    p_Data = (uint8_t*)XX_Malloc(buffDesc.size+dataOffset);
+    if (!p_Data) {
+        REPORT_ERROR(MINOR, E_NO_MEMORY, ("data buff!"));
+        return 0;
+    }
+
+    if (copy_from_user (CAST_UINT64_TO_POINTER_TYPE(uint8_t,(CAST_POINTER_TO_UINT64(p_Data)+dataOffset)),
+                        buffDesc.p_data,
+                        buffDesc.size)) {
+        REPORT_ERROR(MINOR, E_NO_MEMORY, ("data buff!"));
+        XX_Free(p_Data);
+        return 0;
+    }
+
+    memset(&fd, 0, sizeof(fd));
+    FM_FD_SET_ADDR(&fd, p_Data);
+    FM_FD_SET_OFFSET(&fd, dataOffset);
+    FM_FD_SET_LENGTH(&fd, buffDesc.size);
+
+    DBG(TRACE, ("buffDesc qId %d, fqid %d, frame len %d, fq 0x%8x\n",
+                buffDesc.qid, qman_fq_fqid(p_FmTestPort->p_TxFqs[buffDesc.qid]), buffDesc.size,p_FmTestPort->p_TxFqs[buffDesc.qid]));
+
+    _errno = qman_enqueue(p_FmTestPort->p_TxFqs[buffDesc.qid], (struct qm_fd*)&fd, 0);
+    if (_errno) {
+        buffDesc.status = (uint32_t)_errno;
+        if (copy_to_user((ioc_fmt_buff_desc_t*)buf, &buffDesc, sizeof(ioc_fmt_buff_desc_t))) {
+            REPORT_ERROR(MINOR, E_WRITE_FAILED, NO_MSG);
+            XX_Free(p_Data);
+            return 0;
+        }
+    }
+    return buffDesc.size;
+}
+
+/* Globals for FM character device */
+static struct file_operations fm_test_fops =
+{
+    owner:      THIS_MODULE,
+    ioctl:      fm_test_ioctl,
+    open:       fm_test_open,
+    release:    fm_test_close,
+    read:       fm_test_read,
+    write:      fm_test_write,
+};
+
+t_Handle LNXWRP_FM_TEST_Init(void)
+{
+    t_FmTest    *p_FmTest = &fmTest;
+
+    /* Register to the /dev for IOCTL API */
+    /* Register dynamically a new major number for the character device: */
+    if ((p_FmTest->major = register_chrdev(0, DEV_FM_TEST_NAME, &fm_test_fops)) <= 0)
+    {
+        REPORT_ERROR(MAJOR, E_INVALID_STATE, ("Failed to allocate a major number for device \"%s\"", DEV_FM_TEST_NAME));
+        return NULL;
+    }
+
+    return p_FmTest;
+}
+
+t_Error  LNXWRP_FM_TEST_Free(t_Handle h_FmTestLnxWrp)
+{
+    t_FmTest    *p_FmTest = (t_FmTest*)h_FmTestLnxWrp;
+
+    UNUSED(p_FmTest);
+    /* Complete!!! */
+    return E_OK;
+}
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/lnxwrp_fm.c b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/lnxwrp_fm.c
new file mode 100644
index 0000000..c4d53d9
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/lnxwrp_fm.c
@@ -0,0 +1,1743 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**************************************************************************//**
+ @File          lnxwrp_fm.c
+
+ @Author        Shlomi Gridish
+
+ @Description   FM Linux wrapper functions.
+*//***************************************************************************/
+
+/* Linux Headers ------------------- */
+#include <linux/version.h>
+
+#if defined(CONFIG_MODVERSIONS) && !defined(MODVERSIONS)
+#define MODVERSIONS
+#endif
+#ifdef MODVERSIONS
+#include <config/modversions.h>
+#endif /* MODVERSIONS */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/fs.h>
+#include <linux/cdev.h>
+#include <linux/device.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/ioport.h>
+#include <linux/of_platform.h>
+#include <asm/uaccess.h>
+#include <asm/errno.h>
+#include <sysdev/fsl_soc.h>
+#include <asm/qe.h>		/* For struct qe_firmware */
+
+/* NetCommSw Headers --------------- */
+#include "std_ext.h"
+#include "error_ext.h"
+#include "sprint_ext.h"
+#include "debug_ext.h"
+#include "sys_io_ext.h"
+#include "procbuff_ext.h"
+
+#include "fm_ioctls.h"
+
+#include "lnxwrp_fm.h"
+
+
+#define PROC_PRINT(args...) offset += sprintf(buf+offset,args)
+
+
+static t_LnxWrpFm   lnxWrpFm;
+
+
+static int fm_proc_dump_stats(char *buffer, char **start, off_t offset,
+                              int length, int *eof, void *data)
+{
+//    t_LnxWrpFmDev               *p_LnxWrpFmDev = (t_LnxWrpFmDev*)data;
+//    t_PppohtLinkStatistics      linkStatistics;
+    t_Handle                    h_ProcBuff = ProcBuff_Init(buffer,start,offset,length,eof);
+    unsigned long               flags;
+    int                         numOfWrittenChars;
+
+    local_irq_save(flags);
+    ProcBuff_Write (h_ProcBuff, "FM driver statistics:\n");
+
+//#warning "complete"
+#if 0
+    for (i=0; i<PPPOHT_MAX_NUM_OF_LINKS; i++)
+        if (p_Pppohtd->links[i].h_Link)
+        {
+            memset(&linkStatistics, 0, sizeof(t_PppohtLinkStatistics));
+            PPPoHT_LINK_GetStatistics(p_Pppohtd->links[i].h_Link, &linkStatistics);
+            ProcBuff_Write (h_ProcBuff,
+                            "\tLink %d statistics:\n \
+                             rxFcsErrCnt: %d\n \
+                             rxInvalidAcCnt: %d\n",
+                            i,
+                            linkStatistics.rxFcsErrCnt,
+                            linkStatistics.rxInvalidAcCnt);
+        }
+#endif /* 0 */
+
+    numOfWrittenChars = ProcBuff_GetNumOfWrittenChars(h_ProcBuff);
+    ProcBuff_Free(h_ProcBuff);
+    local_irq_restore(flags);
+
+    return numOfWrittenChars;
+}
+
+static int fm_proc_dump_regs(char *buffer, char **start, off_t offset,
+                             int length, int *eof, void *data)
+{
+    unsigned long   flags;
+
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+    t_LnxWrpFmDev   *p_LnxWrpFmDev = (t_LnxWrpFmDev*)data;
+    int             i;
+    char            *next = buffer;
+    unsigned        size = length;
+    int             t;
+
+    local_irq_save(flags);
+    t = scnprintf(next, size, "FM driver registers dump.\n");
+    size -= t;
+    next += t;
+
+    if (!p_LnxWrpFmDev->active || !p_LnxWrpFmDev->h_Dev)
+        REPORT_ERROR(MINOR, E_INVALID_STATE, ("FM not initialized!"));
+    else
+    {
+        FM_DumpRegs(p_LnxWrpFmDev->h_Dev);
+
+        for (i=0; i<FM_MAX_NUM_OF_OP_PORTS; i++)
+            if (p_LnxWrpFmDev->opPorts[i].active && p_LnxWrpFmDev->opPorts[i].h_Dev)
+                FM_PORT_DumpRegs(p_LnxWrpFmDev->opPorts[i].h_Dev);
+        for (i=0; i<FM_MAX_NUM_OF_TX_PORTS; i++)
+            if (p_LnxWrpFmDev->txPorts[i].active && p_LnxWrpFmDev->txPorts[i].h_Dev)
+                FM_PORT_DumpRegs(p_LnxWrpFmDev->txPorts[i].h_Dev);
+        for (i=0; i<FM_MAX_NUM_OF_RX_PORTS; i++)
+            if (p_LnxWrpFmDev->rxPorts[i].active && p_LnxWrpFmDev->rxPorts[i].h_Dev)
+                FM_PORT_DumpRegs(p_LnxWrpFmDev->rxPorts[i].h_Dev);
+        if (p_LnxWrpFmDev->hcPort.active && p_LnxWrpFmDev->hcPort.h_Dev)
+            FM_PORT_DumpRegs(p_LnxWrpFmDev->hcPort.h_Dev);
+    }
+
+    local_irq_restore(flags);
+    *eof = 1;
+
+    return length - size;
+
+#else
+    t_Handle    h_ProcBuff = ProcBuff_Init(buffer,start,offset,length,eof);
+    int         numOfWrittenChars;
+
+    local_irq_save(flags);
+    ProcBuff_Write (h_ProcBuff, "Debug level is too low to dump registers!!!\n");
+    numOfWrittenChars = ProcBuff_GetNumOfWrittenChars(h_ProcBuff);
+    ProcBuff_Free(h_ProcBuff);
+    local_irq_restore(flags);
+
+    return numOfWrittenChars;
+#endif /* (defined(DEBUG_ERRORS) && ... */
+}
+
+static irqreturn_t fm_irq(int irq, void *_dev)
+{
+    t_LnxWrpFmDev       *p_LnxWrpFmDev = (t_LnxWrpFmDev *)_dev;
+
+    if (!p_LnxWrpFmDev || !p_LnxWrpFmDev->h_Dev)
+        return IRQ_NONE;
+
+    FM_Isr(p_LnxWrpFmDev->h_Dev);
+
+    return IRQ_HANDLED;
+}
+
+static volatile int   hcFrmRcv = 0;
+
+static enum qman_cb_dqrr_result qm_tx_conf_dqrr_cb(struct qman_portal          *portal,
+                                                   struct qman_fq              *fq,
+                                                   const struct qm_dqrr_entry  *dq)
+{
+    t_LnxWrpFmDev       *p_LnxWrpFmDev = ((t_FmTestFq *)fq)->h_Arg;
+
+    FM_PCD_HcTxConf(p_LnxWrpFmDev->h_PcdDev, (t_FmFD *)&dq->fd);
+    hcFrmRcv--;
+
+    return qman_cb_dqrr_consume;
+}
+
+static enum qman_cb_dqrr_result qm_tx_dqrr_cb(struct qman_portal          *portal,
+                                              struct qman_fq              *fq,
+                                              const struct qm_dqrr_entry  *dq)
+{
+    BUG();
+    return qman_cb_dqrr_consume;
+}
+
+static void qm_err_cb(struct qman_portal       *portal,
+                       struct qman_fq           *fq,
+                       const struct qm_mr_entry *msg)
+{
+    BUG();
+}
+
+static struct qman_fq * FqAlloc(t_LnxWrpFmDev   *p_LnxWrpFmDev,
+                                uint32_t        fqid,
+                                uint32_t        flags,
+                                uint16_t        channel,
+                                uint8_t         wq)
+{
+    int                     _errno;
+    struct qman_fq          *fq = NULL;
+    t_FmTestFq              *p_FmtFq;
+    struct qm_mcc_initfq    initfq;
+
+    p_FmtFq = (t_FmTestFq *)XX_Malloc(sizeof(t_FmTestFq));
+    if (!p_FmtFq) {
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FQ obj!!!"));
+        return NULL;
+    }
+
+    p_FmtFq->fq_base.cb.dqrr = (QMAN_FQ_FLAG_NO_ENQUEUE ? qm_tx_conf_dqrr_cb : qm_tx_dqrr_cb);
+    p_FmtFq->fq_base.cb.ern = p_FmtFq->fq_base.cb.dc_ern = p_FmtFq->fq_base.cb.fqs = qm_err_cb;
+    p_FmtFq->h_Arg = (t_Handle)p_LnxWrpFmDev;
+    if (fqid == 0) {
+        flags |= QMAN_FQ_FLAG_DYNAMIC_FQID;
+        flags &= ~QMAN_FQ_FLAG_NO_MODIFY;
+    } else {
+        flags &= ~QMAN_FQ_FLAG_DYNAMIC_FQID;
+    }
+
+    DBG(TRACE, ("fqid %d, flags 0x%08x, channel %d, wq %d",fqid,flags,channel,wq));
+
+    if (qman_create_fq(fqid, flags, &p_FmtFq->fq_base)) {
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FQ obj - qman_new_fq!!!"));
+        XX_Free(p_FmtFq);
+        return NULL;
+    }
+    fq = &p_FmtFq->fq_base;
+
+    if (!(flags & QMAN_FQ_FLAG_NO_MODIFY)) {
+        initfq.we_mask            = QM_INITFQ_WE_DESTWQ;
+        initfq.fqd.dest.channel   = channel;
+        initfq.fqd.dest.wq        = wq;
+
+        _errno = qman_init_fq(fq, QMAN_INITFQ_FLAG_SCHED, &initfq);
+        if (unlikely(_errno < 0)) {
+            REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FQ obj - qman_init_fq!!!"));
+            qman_destroy_fq(fq, 0);
+            XX_Free(p_FmtFq);
+            return NULL;
+        }
+    }
+
+    return fq;
+}
+
+static t_Error QmEnqueueCB (t_Handle h_Arg, uint32_t fqid, void *p_Fd)
+{
+    t_LnxWrpFmDev   *p_LnxWrpFmDev = (t_LnxWrpFmDev*)h_Arg;
+    int             _errno, timeout=1000000;
+
+    ASSERT_COND(p_LnxWrpFmDev);
+    UNUSED(fqid);
+
+    hcFrmRcv++;
+//MemDisp((uint8_t*)p_Fd,sizeof(t_FmFD));
+    _errno = qman_enqueue(p_LnxWrpFmDev->hc_tx_fq, (struct qm_fd*)p_Fd, 0);
+    if (_errno)
+        RETURN_ERROR(MINOR, E_INVALID_STATE, NO_MSG);
+
+    while (hcFrmRcv && timeout--)
+    {
+        udelay(1);
+        cpu_relax();
+    }
+    BUG_ON(!timeout);
+
+    return E_OK;
+}
+
+static t_LnxWrpFmDev * CreateFmDev(uint8_t  id)
+{
+    t_LnxWrpFmDev   *p_LnxWrpFmDev;
+    int             j;
+
+    p_LnxWrpFmDev = (t_LnxWrpFmDev *)XX_Malloc(sizeof(t_LnxWrpFmDev));
+    if (!p_LnxWrpFmDev)
+    {
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, NO_MSG);
+        return NULL;
+    }
+
+    memset(p_LnxWrpFmDev, 0, sizeof(t_LnxWrpFmDev));
+    p_LnxWrpFmDev->fmDevSettings.advConfig = (t_SysObjectAdvConfigEntry*)XX_Malloc(FM_MAX_NUM_OF_ADV_SETTINGS*sizeof(t_SysObjectAdvConfigEntry));
+    memset(p_LnxWrpFmDev->fmDevSettings.advConfig, 0, (FM_MAX_NUM_OF_ADV_SETTINGS*sizeof(t_SysObjectAdvConfigEntry)));
+    p_LnxWrpFmDev->fmPcdDevSettings.advConfig = (t_SysObjectAdvConfigEntry*)XX_Malloc(FM_MAX_NUM_OF_ADV_SETTINGS*sizeof(t_SysObjectAdvConfigEntry));
+    memset(p_LnxWrpFmDev->fmPcdDevSettings.advConfig, 0, (FM_MAX_NUM_OF_ADV_SETTINGS*sizeof(t_SysObjectAdvConfigEntry)));
+    p_LnxWrpFmDev->hcPort.settings.advConfig = (t_SysObjectAdvConfigEntry*)XX_Malloc(FM_MAX_NUM_OF_ADV_SETTINGS*sizeof(t_SysObjectAdvConfigEntry));
+    memset(p_LnxWrpFmDev->hcPort.settings.advConfig, 0, (FM_MAX_NUM_OF_ADV_SETTINGS*sizeof(t_SysObjectAdvConfigEntry)));
+    for (j=0; j<FM_MAX_NUM_OF_RX_PORTS; j++)
+    {
+        p_LnxWrpFmDev->rxPorts[j].settings.advConfig = (t_SysObjectAdvConfigEntry*)XX_Malloc(FM_MAX_NUM_OF_ADV_SETTINGS*sizeof(t_SysObjectAdvConfigEntry));
+        memset(p_LnxWrpFmDev->rxPorts[j].settings.advConfig, 0, (FM_MAX_NUM_OF_ADV_SETTINGS*sizeof(t_SysObjectAdvConfigEntry)));
+    }
+    for (j=0; j<FM_MAX_NUM_OF_TX_PORTS; j++)
+    {
+        p_LnxWrpFmDev->txPorts[j].settings.advConfig = (t_SysObjectAdvConfigEntry*)XX_Malloc(FM_MAX_NUM_OF_ADV_SETTINGS*sizeof(t_SysObjectAdvConfigEntry));
+        memset(p_LnxWrpFmDev->txPorts[j].settings.advConfig, 0, (FM_MAX_NUM_OF_ADV_SETTINGS*sizeof(t_SysObjectAdvConfigEntry)));
+    }
+    for (j=0; j<FM_MAX_NUM_OF_OP_PORTS; j++)
+    {
+        p_LnxWrpFmDev->opPorts[j].settings.advConfig = (t_SysObjectAdvConfigEntry*)XX_Malloc(FM_MAX_NUM_OF_ADV_SETTINGS*sizeof(t_SysObjectAdvConfigEntry));
+        memset(p_LnxWrpFmDev->opPorts[j].settings.advConfig, 0, (FM_MAX_NUM_OF_ADV_SETTINGS*sizeof(t_SysObjectAdvConfigEntry)));
+    }
+
+    return p_LnxWrpFmDev;
+}
+
+static void DistroyFmDev(t_LnxWrpFmDev *p_LnxWrpFmDev)
+{
+    int             j;
+
+    for (j=0; j<FM_MAX_NUM_OF_OP_PORTS; j++)
+        if (p_LnxWrpFmDev->opPorts[j].settings.advConfig)
+            XX_Free(p_LnxWrpFmDev->opPorts[j].settings.advConfig);
+    for (j=0; j<FM_MAX_NUM_OF_TX_PORTS; j++)
+        if (p_LnxWrpFmDev->txPorts[j].settings.advConfig)
+            XX_Free(p_LnxWrpFmDev->txPorts[j].settings.advConfig);
+    for (j=0; j<FM_MAX_NUM_OF_RX_PORTS; j++)
+        if (p_LnxWrpFmDev->rxPorts[j].settings.advConfig)
+            XX_Free(p_LnxWrpFmDev->rxPorts[j].settings.advConfig);
+    if (p_LnxWrpFmDev->hcPort.settings.advConfig)
+        XX_Free(p_LnxWrpFmDev->hcPort.settings.advConfig);
+    if (p_LnxWrpFmDev->fmPcdDevSettings.advConfig)
+        XX_Free(p_LnxWrpFmDev->fmPcdDevSettings.advConfig);
+    if (p_LnxWrpFmDev->fmDevSettings.advConfig)
+        XX_Free(p_LnxWrpFmDev->fmDevSettings.advConfig);
+
+#ifdef NO_OF_SUPPORT
+    memset(p_LnxWrpFmDev, 0, sizeof(t_LnxWrpFmDev));
+#else
+    XX_Free(p_LnxWrpFmDev);
+#endif /* NO_OF_SUPPORT */
+}
+
+static t_Error FillRestFmInfo(t_LnxWrpFmDev *p_LnxWrpFmDev)
+{
+#define FM_BMI_PPIDS_OFFSET                 0x00080304
+#define FM_DMA_PLR_OFFSET                   0x000c2060
+#define DMA_HIGH_LIODN_MASK                 0x0FFF0000
+#define DMA_LOW_LIODN_MASK                  0x00000FFF
+#define DMA_LIODN_SHIFT                     16
+
+typedef _Packed struct {
+    uint32_t    plr[32];
+} _PackedType t_Plr;
+
+typedef _Packed struct {
+   volatile uint32_t   fmbm_ppid[63];
+} _PackedType t_Ppids;
+
+    t_Plr   *p_Plr;
+    t_Ppids *p_Ppids;
+    int     i;
+    uint8_t physPortId[] = {0x8,0x9,0xa,0xb,0x10};
+
+    p_Plr = (t_Plr *)(p_LnxWrpFmDev->fmBaseAddr+FM_DMA_PLR_OFFSET);
+#ifdef MODULE
+    for (i=0;i<FM_MAX_NUM_OF_PARTITIONS/2;i++)
+        p_Plr->plr[i] = 0;
+#endif /* MODULE */
+
+    for (i=0; i<FM_MAX_NUM_OF_PARTITIONS; i++)
+        p_LnxWrpFmDev->fmDevSettings.param.liodnPerPartition[i] = (i%2) ?
+            (p_Plr->plr[i/2] & DMA_LOW_LIODN_MASK) :
+            ((p_Plr->plr[i/2] & DMA_HIGH_LIODN_MASK) >> DMA_LIODN_SHIFT);
+
+    p_Ppids = (t_Ppids *)(p_LnxWrpFmDev->fmBaseAddr+FM_BMI_PPIDS_OFFSET);
+
+    for (i=0; i<FM_MAX_NUM_OF_RX_PORTS; i++)
+        p_LnxWrpFmDev->rxPorts[i].settings.param.specificParams.rxParams.rxPartitionId =
+            p_Ppids->fmbm_ppid[physPortId[i]-1];
+
+    return E_OK;
+}
+
+#ifndef NO_OF_SUPPORT
+
+/* The default address for the Fman microcode in flash. Having a default
+ * allows older systems to continue functioning.  0xEF000000 is the address
+ * where the firmware is normally on a P4080DS.
+ */
+static phys_addr_t P4080_UCAddr = 0xef000000;
+
+/**
+ * FmanUcodeAddrParam - process the fman_ucode kernel command-line parameter
+ *
+ * This function is called when the kernel encounters a fman_ucode command-
+ * line parameter.  This parameter contains the address of the Fman microcode
+ * in flash.
+ */
+static int FmanUcodeAddrParam(char *str)
+{
+	unsigned long long l;
+	int ret;
+
+	ret = strict_strtoull(str, 0, &l);
+	if (!ret)
+		P4080_UCAddr = (phys_addr_t) l;
+
+	return ret;
+}
+__setup("fman_ucode=", FmanUcodeAddrParam);
+
+/**
+ * FindFmanMicrocode - find the Fman micrcode in memory
+ *
+ * This function returns a pointer to the QE Firmware blob that holds
+ * the Fman microcode.  We use the QE Firmware structure because Fman microcode
+ * is similar to QE microcode, so there's no point in defining a new layout.
+ *
+ * We also never iounmap() the memory because we might reset the Fman at any
+ * time.
+ */
+static struct qe_firmware *FindFmanMicrocode(void)
+{
+    static struct qe_firmware *P4080_UCPatch;
+
+    if (!P4080_UCPatch) {
+        unsigned long P4080_UCSize;
+        struct qe_header *hdr;
+
+        /* Only map enough to the get the core structure */
+        P4080_UCPatch = ioremap(P4080_UCAddr, sizeof(struct qe_firmware));
+        if (!P4080_UCPatch) {
+            REPORT_ERROR(MAJOR, E_NULL_POINTER, ("ioremap(%llx) returned NULL", (u64) P4080_UCAddr));
+            return NULL;
+        }
+
+        /* Make sure it really is a QE Firmware blob */
+        hdr = &P4080_UCPatch->header;
+        if ((hdr->magic[0] != 'Q') || (hdr->magic[1] != 'E') ||
+            (hdr->magic[2] != 'F')) {
+            REPORT_ERROR(MAJOR, E_NOT_FOUND, ("data at %llx is not a Fman microcode", (u64) P4080_UCAddr));
+            return NULL;
+        }
+
+        /* Now we call ioremap again, this time to pick up the whole blob */
+        P4080_UCSize = sizeof(u32) * P4080_UCPatch->microcode[0].count;
+        iounmap(P4080_UCPatch);
+        P4080_UCPatch = ioremap(P4080_UCAddr, P4080_UCSize);
+        if (!P4080_UCPatch) {
+            REPORT_ERROR(MAJOR, E_NULL_POINTER, ("ioremap(%llx) returned NULL", (u64) P4080_UCAddr));
+            return NULL;
+        }
+    }
+
+    return P4080_UCPatch;
+}
+
+static t_LnxWrpFmDev * ReadFmDevTreeNode (struct of_device *of_dev)
+{
+    t_LnxWrpFmDev       *p_LnxWrpFmDev;
+    struct device_node  *fm_node, *dev_node, *dpaa_node;
+    struct of_device_id name;
+    struct resource     res;
+    const uint32_t      *uint32_prop;
+    int                 _errno=0, lenp;
+
+    fm_node = of_dev->node;
+
+    uint32_prop = (uint32_t *)of_get_property(fm_node, "cell-index", &lenp);
+    if (unlikely(uint32_prop == NULL)) {
+        REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("of_get_property(%s, cell-index) failed", fm_node->full_name));
+        return NULL;
+    }
+    BUG_ON(lenp != sizeof(uint32_t));
+    if (*uint32_prop > INTG_MAX_NUM_OF_FM) {
+        REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("fm id!"));
+        return NULL;
+    }
+    p_LnxWrpFmDev = CreateFmDev(*uint32_prop);
+    if (!p_LnxWrpFmDev) {
+        REPORT_ERROR(MAJOR, E_NULL_POINTER, NO_MSG);
+        return NULL;
+    }
+    p_LnxWrpFmDev->dev = &of_dev->dev;
+    p_LnxWrpFmDev->id = *uint32_prop;
+
+    /* Get the FM interrupt */
+    p_LnxWrpFmDev->irq1 = of_irq_to_resource(fm_node, 0, NULL);
+    if (unlikely(p_LnxWrpFmDev->irq1 == NO_IRQ)) {
+        REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("of_irq_to_resource() = %d", NO_IRQ));
+        return NULL;
+    }
+
+    /* Get the FM address */
+    _errno = of_address_to_resource(fm_node, 0, &res);
+    if (unlikely(_errno < 0)) {
+        REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("of_address_to_resource() = %d", _errno));
+        return NULL;
+    }
+
+    p_LnxWrpFmDev->fmBaseAddr = res.start;
+    p_LnxWrpFmDev->fmMemSize = res.end + 1 - res.start;
+
+    uint32_prop = (uint32_t *)of_get_property(fm_node, "clock-frequency", &lenp);
+    if (unlikely(uint32_prop == NULL)) {
+        REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("of_get_property(%s, clock-frequency) failed", fm_node->full_name));
+        return NULL;
+    }
+    BUG_ON(lenp != sizeof(uint32_t));
+    p_LnxWrpFmDev->fmDevSettings.param.fmClkFreq = *uint32_prop;
+
+    /* Get the MURAM base address and size */
+    memset(&name, 0, sizeof(struct of_device_id));
+    BUG_ON(strlen("muram") >= sizeof(name.name));
+    strcpy(name.name, "muram");
+    BUG_ON(strlen("fsl,fman-muram") >= sizeof(name.compatible));
+    strcpy(name.compatible, "fsl,fman-muram");
+    for_each_child_of_node(fm_node, dev_node) {
+        if (likely(of_match_node(&name, dev_node) != NULL)) {
+            _errno = of_address_to_resource(dev_node, 0, &res);
+            if (unlikely(_errno < 0)) {
+                REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("of_address_to_resource() = %d", _errno));
+                return NULL;
+            }
+
+            p_LnxWrpFmDev->fmMuramBaseAddr = res.start;
+            p_LnxWrpFmDev->fmMuramMemSize = res.end + 1 - res.start;
+        }
+    }
+
+    /* Get all PCD nodes */
+    memset(&name, 0, sizeof(struct of_device_id));
+    BUG_ON(strlen("parser") >= sizeof(name.name));
+    strcpy(name.name, "parser");
+    BUG_ON(strlen("fsl,fman-parser") >= sizeof(name.compatible));
+    strcpy(name.compatible, "fsl,fman-parser");
+    for_each_child_of_node(fm_node, dev_node)
+        if (likely(of_match_node(&name, dev_node) != NULL))
+            p_LnxWrpFmDev->prsActive = TRUE;
+
+    memset(&name, 0, sizeof(struct of_device_id));
+    BUG_ON(strlen("keygen") >= sizeof(name.name));
+    strcpy(name.name, "keygen");
+    BUG_ON(strlen("fsl,fman-keygen") >= sizeof(name.compatible));
+    strcpy(name.compatible, "fsl,fman-keygen");
+    for_each_child_of_node(fm_node, dev_node)
+        if (likely(of_match_node(&name, dev_node) != NULL))
+            p_LnxWrpFmDev->kgActive = TRUE;
+
+    memset(&name, 0, sizeof(struct of_device_id));
+    BUG_ON(strlen("cc") >= sizeof(name.name));
+    strcpy(name.name, "cc");
+    BUG_ON(strlen("fsl,fman-cc") >= sizeof(name.compatible));
+    strcpy(name.compatible, "fsl,fman-cc");
+    for_each_child_of_node(fm_node, dev_node)
+        if (likely(of_match_node(&name, dev_node) != NULL))
+            p_LnxWrpFmDev->ccActive = TRUE;
+
+    memset(&name, 0, sizeof(struct of_device_id));
+    BUG_ON(strlen("policer") >= sizeof(name.name));
+    strcpy(name.name, "policer");
+    BUG_ON(strlen("fsl,fman-policer") >= sizeof(name.compatible));
+    strcpy(name.compatible, "fsl,fman-policer");
+    for_each_child_of_node(fm_node, dev_node)
+        if (likely(of_match_node(&name, dev_node) != NULL))
+            p_LnxWrpFmDev->plcrActive = TRUE;
+
+    memset(&name, 0, sizeof(struct of_device_id));
+    BUG_ON(strlen("fsl,dpaa") >= sizeof(name.compatible));
+    strcpy(name.compatible, "fsl,dpaa");
+    for_each_matching_node(dpaa_node, &name) {
+        struct of_device    *of_dev = of_find_device_by_node(dpaa_node);
+        if (unlikely(of_dev == NULL)) {
+            REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("of_address_to_resource() = %d", _errno));
+            return NULL;
+        }
+        p_LnxWrpFmDev->dpaa_dev = &of_dev->dev;
+        break;
+    }
+
+    if (p_LnxWrpFmDev->prsActive || p_LnxWrpFmDev->kgActive ||
+        p_LnxWrpFmDev->ccActive || p_LnxWrpFmDev->plcrActive)
+        p_LnxWrpFmDev->pcdActive = TRUE;
+
+    if (p_LnxWrpFmDev->pcdActive)
+    {
+        const char *str_prop = (char *)of_get_property(fm_node, "fsl,default-pcd", &lenp);
+        if (str_prop) {
+            if (strncmp(str_prop, "3-tuple", strlen("3-tuple")) == 0)
+                p_LnxWrpFmDev->defPcd = e_FM_PCD_3_TUPLE;
+        }
+        else
+            p_LnxWrpFmDev->defPcd = e_NO_PCD;
+    }
+
+    if (p_LnxWrpFmDev->ccActive) {
+        struct qe_firmware *fw = FindFmanMicrocode();
+
+        if (!fw)
+            /* We already reported an error, so just return NULL*/
+            return NULL;
+
+        p_LnxWrpFmDev->fmDevSettings.param.firmware.p_Code =
+            (void *) fw + fw->microcode[0].code_offset;
+        p_LnxWrpFmDev->fmDevSettings.param.firmware.size =
+            sizeof(u32) * fw->microcode[0].count;
+    }
+
+    p_LnxWrpFmDev->active = TRUE;
+
+    of_node_put(fm_node);
+
+    return p_LnxWrpFmDev;
+}
+
+static t_LnxWrpFmPortDev * ReadFmPortDevTreeNode (struct of_device *of_dev)
+{
+    t_LnxWrpFmDev       *p_LnxWrpFmDev;
+    t_LnxWrpFmPortDev   *p_LnxWrpFmPortDev;
+    struct device_node  *fm_node, *port_node;
+    struct resource     res;
+    const uint32_t      *uint32_prop;
+    int                 _errno=0, lenp;
+
+    port_node = of_dev->node;
+
+    /* Get the FM node */
+    fm_node = of_get_parent(port_node);
+    if (unlikely(fm_node == NULL)) {
+        REPORT_ERROR(MAJOR, E_NO_DEVICE, ("of_get_parent() = %d", _errno));
+        return NULL;
+    }
+
+    p_LnxWrpFmDev = dev_get_drvdata(&of_find_device_by_node(fm_node)->dev);
+    of_node_put(fm_node);
+
+    uint32_prop = (uint32_t *)of_get_property(port_node, "cell-index", &lenp);
+    if (unlikely(uint32_prop == NULL)) {
+        REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("of_get_property(%s, cell-index) "
+                                              "failed", port_node->full_name));
+        return NULL;
+    }
+    BUG_ON(lenp != sizeof(uint32_t));
+    if (of_device_is_compatible(port_node, "fsl,fman-port-oh")) {
+        if (unlikely(*uint32_prop >= FM_MAX_NUM_OF_OP_PORTS+1)) {
+            REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("of_get_property(%s, cell-index) "
+                                                  "failed", port_node->full_name));
+            return NULL;
+        }
+
+        if (*uint32_prop == 0) {
+            p_LnxWrpFmPortDev = &p_LnxWrpFmDev->hcPort;
+            p_LnxWrpFmPortDev->id = 0;
+            p_LnxWrpFmPortDev->settings.param.portType = e_FM_PORT_TYPE_HOST_COMMAND;
+        }
+        else {
+            p_LnxWrpFmPortDev = &p_LnxWrpFmDev->opPorts[*uint32_prop-1];
+            p_LnxWrpFmPortDev->id = *uint32_prop-1;
+            p_LnxWrpFmPortDev->settings.param.portType = e_FM_PORT_TYPE_OFFLINE_PARSING;
+        }
+        p_LnxWrpFmPortDev->settings.param.portId = p_LnxWrpFmPortDev->id;
+
+        uint32_prop = (uint32_t *)of_get_property(port_node, "fsl,qman-channel-id", &lenp);
+        if (uint32_prop == NULL) {
+            REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("missing fsl,qman-channel-id"));
+            return NULL;
+        }
+        BUG_ON(lenp != sizeof(uint32_t));
+        p_LnxWrpFmPortDev->txCh = *uint32_prop;
+        p_LnxWrpFmPortDev->settings.param.specificParams.nonRxParams.deqSubPortal = (p_LnxWrpFmPortDev->txCh & 0x1f);
+    }
+    else if (of_device_is_compatible(port_node, "fsl,fman-port-1g-tx") ||
+             of_device_is_compatible(port_node, "fsl,fman-port-10g-tx")) {
+        if (unlikely(*uint32_prop >= FM_MAX_NUM_OF_TX_PORTS)) {
+            REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("of_get_property(%s, cell-index) "
+                                                  "failed", port_node->full_name));
+            return NULL;
+        }
+        if (of_device_is_compatible(port_node, "fsl,fman-port-10g-tx"))
+            p_LnxWrpFmPortDev = &p_LnxWrpFmDev->txPorts[*uint32_prop+FM_MAX_NUM_OF_1G_TX_PORTS];
+        else
+            p_LnxWrpFmPortDev = &p_LnxWrpFmDev->txPorts[*uint32_prop];
+
+        p_LnxWrpFmPortDev->id = *uint32_prop;
+        p_LnxWrpFmPortDev->settings.param.portId = p_LnxWrpFmPortDev->id;
+        if (of_device_is_compatible(port_node, "fsl,fman-port-10g-tx"))
+            p_LnxWrpFmPortDev->settings.param.portType = e_FM_PORT_TYPE_TX_10G;
+        else
+            p_LnxWrpFmPortDev->settings.param.portType = e_FM_PORT_TYPE_TX;
+
+        uint32_prop = (uint32_t *)of_get_property(port_node, "fsl,qman-channel-id", &lenp);
+        if (uint32_prop == NULL) {
+            REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("missing fsl,qman-channel-id"));
+            return NULL;
+        }
+        BUG_ON(lenp != sizeof(uint32_t));
+        p_LnxWrpFmPortDev->txCh = *uint32_prop;
+        p_LnxWrpFmPortDev->settings.param.specificParams.nonRxParams.deqSubPortal = (p_LnxWrpFmPortDev->txCh & 0x1f);
+    }
+    else if (of_device_is_compatible(port_node, "fsl,fman-port-1g-rx") ||
+             of_device_is_compatible(port_node, "fsl,fman-port-10g-rx")) {
+        if (unlikely(*uint32_prop >= FM_MAX_NUM_OF_RX_PORTS)) {
+            REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("of_get_property(%s, cell-index) "
+                                                  "failed", port_node->full_name));
+            return NULL;
+        }
+        if (of_device_is_compatible(port_node, "fsl,fman-port-10g-rx"))
+            p_LnxWrpFmPortDev = &p_LnxWrpFmDev->rxPorts[*uint32_prop+FM_MAX_NUM_OF_1G_RX_PORTS];
+        else
+            p_LnxWrpFmPortDev = &p_LnxWrpFmDev->rxPorts[*uint32_prop];
+
+        p_LnxWrpFmPortDev->id = *uint32_prop;
+        p_LnxWrpFmPortDev->settings.param.portId = p_LnxWrpFmPortDev->id;
+        if (of_device_is_compatible(port_node, "fsl,fman-port-10g-rx"))
+            p_LnxWrpFmPortDev->settings.param.portType = e_FM_PORT_TYPE_RX_10G;
+        else
+            p_LnxWrpFmPortDev->settings.param.portType = e_FM_PORT_TYPE_RX;
+
+        if (p_LnxWrpFmDev->pcdActive)
+            p_LnxWrpFmPortDev->defPcd = p_LnxWrpFmDev->defPcd;
+    }
+    else {
+        REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("Illegal port type"));
+        return NULL;
+    }
+
+    _errno = of_address_to_resource(port_node, 0, &res);
+    if (unlikely(_errno < 0)) {
+        REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("of_address_to_resource() = %d", _errno));
+        return NULL;
+    }
+
+    p_LnxWrpFmPortDev->dev = &of_dev->dev;
+    p_LnxWrpFmPortDev->baseAddr = res.start;
+    p_LnxWrpFmPortDev->memSize = res.end + 1 - res.start;
+    p_LnxWrpFmPortDev->settings.param.h_Fm = p_LnxWrpFmDev->h_Dev;
+    p_LnxWrpFmPortDev->h_LnxWrpFmDev = (t_Handle)p_LnxWrpFmDev;
+
+    of_node_put(port_node);
+
+    p_LnxWrpFmPortDev->active = TRUE;
+
+    return p_LnxWrpFmPortDev;
+}
+#endif /* !NO_OF_SUPPORT */
+
+static void LnxwrpFmDevExceptionsCb(t_Handle h_App, e_FmExceptions exception)
+{
+    t_LnxWrpFmDev       *p_LnxWrpFmDev = (t_LnxWrpFmDev *)h_App;
+
+    ASSERT_COND(p_LnxWrpFmDev);
+
+    DBG(INFO, ("got fm exception %d", exception));
+
+    /* do nothing */
+    UNUSED(exception);
+}
+
+static void LnxwrpFmDevBusErrorCb(t_Handle        h_App,
+                                  e_FmPortType    portType,
+                                  uint8_t         portId,
+                                  uint64_t        addr,
+                                  uint8_t         tnum,
+                                  uint8_t         partition)
+{
+    t_LnxWrpFmDev       *p_LnxWrpFmDev = (t_LnxWrpFmDev *)h_App;
+
+    ASSERT_COND(p_LnxWrpFmDev);
+
+    /* do nothing */
+    UNUSED(portType);UNUSED(portId);UNUSED(addr);UNUSED(tnum);UNUSED(partition);
+}
+
+static void LnxwrpFmPcdDevExceptionsCb( t_Handle h_App, e_FmPcdExceptions exception)
+{
+    t_LnxWrpFmDev       *p_LnxWrpFmDev = (t_LnxWrpFmDev *)h_App;
+
+    ASSERT_COND(p_LnxWrpFmDev);
+
+    DBG(INFO, ("got fm-pcd exception %d", exception));
+
+    /* do nothing */
+    UNUSED(exception);
+}
+
+static void LnxwrpFmPcdDevIndexedExceptionsCb(t_Handle          h_App,
+                                              e_FmPcdExceptions exception,
+                                              uint16_t          index)
+{
+    t_LnxWrpFmDev       *p_LnxWrpFmDev = (t_LnxWrpFmDev *)h_App;
+
+    ASSERT_COND(p_LnxWrpFmDev);
+
+    DBG(INFO, ("got fm-pcd-indexed exception %d, indx %d", exception, index));
+
+    /* do nothing */
+    UNUSED(exception);UNUSED(index);
+}
+
+static t_Error ConfigureFmDev(t_LnxWrpFmDev  *p_LnxWrpFmDev)
+{
+    struct resource     *dev_res;
+    int                 _errno;
+    uint32_t            fmPhysAddr, muramPhysAddr;
+
+    if (!p_LnxWrpFmDev->active)
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("FM not configured!!!"));
+
+    _errno = can_request_irq(p_LnxWrpFmDev->irq1, 0);
+    if (unlikely(_errno < 0))
+        DBG(WARNING, ("can_request_irq() = %d", _errno));
+    _errno = devm_request_irq(p_LnxWrpFmDev->dev, p_LnxWrpFmDev->irq1, fm_irq, 0, "fman", p_LnxWrpFmDev);
+    if (unlikely(_errno < 0))
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("request_irq(%d) = %d", p_LnxWrpFmDev->irq1, _errno));
+
+    fmPhysAddr = p_LnxWrpFmDev->fmBaseAddr;
+    p_LnxWrpFmDev->res = devm_request_mem_region(p_LnxWrpFmDev->dev, p_LnxWrpFmDev->fmBaseAddr, p_LnxWrpFmDev->fmMemSize, "fman");
+    if (unlikely(p_LnxWrpFmDev->res == NULL))
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("request_mem_region() failed"));
+
+    p_LnxWrpFmDev->fmBaseAddr = (uint32_t)devm_ioremap(p_LnxWrpFmDev->dev, p_LnxWrpFmDev->fmBaseAddr, p_LnxWrpFmDev->fmMemSize);
+    if (unlikely(p_LnxWrpFmDev->fmBaseAddr == 0))
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("devm_ioremap() failed"));
+
+    muramPhysAddr = p_LnxWrpFmDev->fmMuramBaseAddr;
+    dev_res = __devm_request_region(p_LnxWrpFmDev->dev, p_LnxWrpFmDev->res, p_LnxWrpFmDev->fmMuramBaseAddr, p_LnxWrpFmDev->fmMuramMemSize, "fman-muram");
+    if (unlikely(dev_res == NULL))
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("__devm_request_region() failed"));
+
+    p_LnxWrpFmDev->fmMuramBaseAddr = (uint32_t)devm_ioremap(p_LnxWrpFmDev->dev, p_LnxWrpFmDev->fmMuramBaseAddr, p_LnxWrpFmDev->fmMuramMemSize);
+    if (unlikely(p_LnxWrpFmDev->fmMuramBaseAddr == 0))
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("devm_ioremap() failed"));
+
+    if (SYS_RegisterIoMap((uint64_t)p_LnxWrpFmDev->fmMuramBaseAddr, (uint64_t)muramPhysAddr, p_LnxWrpFmDev->fmMuramMemSize) != E_OK)
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("FM MURAM memory map"));
+
+    if (SYS_RegisterIoMap((uint64_t)p_LnxWrpFmDev->fmBaseAddr, (uint64_t)fmPhysAddr, p_LnxWrpFmDev->fmMemSize) != E_OK)
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("FM memory map"));
+
+    p_LnxWrpFmDev->fmDevSettings.param.baseAddr     = p_LnxWrpFmDev->fmBaseAddr;
+    p_LnxWrpFmDev->fmDevSettings.param.fmId         = p_LnxWrpFmDev->id;
+    p_LnxWrpFmDev->fmDevSettings.param.irq          = NO_IRQ;
+    p_LnxWrpFmDev->fmDevSettings.param.errIrq       = NO_IRQ;
+    p_LnxWrpFmDev->fmDevSettings.param.f_Exceptions = LnxwrpFmDevExceptionsCb;
+    p_LnxWrpFmDev->fmDevSettings.param.f_BusError   = LnxwrpFmDevBusErrorCb;
+    p_LnxWrpFmDev->fmDevSettings.param.h_App        = p_LnxWrpFmDev;
+
+    return FillRestFmInfo(p_LnxWrpFmDev);
+}
+
+static t_Error ConfigureFmPortDev(t_LnxWrpFmPortDev *p_LnxWrpFmPortDev)
+{
+    t_LnxWrpFmDev       *p_LnxWrpFmDev = (t_LnxWrpFmDev *)p_LnxWrpFmPortDev->h_LnxWrpFmDev;
+    struct resource     *dev_res;
+
+    if (!p_LnxWrpFmPortDev->active)
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("FM port not configured!!!"));
+
+    dev_res = __devm_request_region(p_LnxWrpFmDev->dev, p_LnxWrpFmDev->res, p_LnxWrpFmPortDev->baseAddr, p_LnxWrpFmPortDev->memSize, "fman-port-hc");
+    if (unlikely(dev_res == NULL))
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("__devm_request_region() failed"));
+    p_LnxWrpFmPortDev->baseAddr = (uint32_t)devm_ioremap(p_LnxWrpFmDev->dev, p_LnxWrpFmPortDev->baseAddr, p_LnxWrpFmPortDev->memSize);
+    if (unlikely(p_LnxWrpFmPortDev->baseAddr == 0))
+        REPORT_ERROR(MAJOR, E_INVALID_STATE, ("devm_ioremap() failed"));
+
+    p_LnxWrpFmPortDev->settings.param.baseAddr = p_LnxWrpFmPortDev->baseAddr;
+
+    return E_OK;
+}
+
+static t_Error InitFmPcdDev(t_LnxWrpFmDev  *p_LnxWrpFmDev)
+{
+    if (p_LnxWrpFmDev->pcdActive)
+    {
+        t_LnxWrpFmPortDev   *p_LnxWrpFmPortDev = &p_LnxWrpFmDev->hcPort;
+        t_FmPcdParams       fmPcdParams;
+        t_Error             err;
+
+        memset(&fmPcdParams, 0, sizeof(fmPcdParams));
+        fmPcdParams.h_Fm        = p_LnxWrpFmDev->h_Dev;
+        fmPcdParams.h_FmMuram   = p_LnxWrpFmDev->h_MuramDev;
+        fmPcdParams.prsSupport  = p_LnxWrpFmDev->prsActive;
+        fmPcdParams.kgSupport   = p_LnxWrpFmDev->kgActive;
+        fmPcdParams.plcrSupport = p_LnxWrpFmDev->plcrActive;
+        fmPcdParams.ccSupport   = p_LnxWrpFmDev->ccActive;
+
+#ifndef CONFIG_GUEST_PARTITION
+        fmPcdParams.f_FmPcdException   = LnxwrpFmPcdDevExceptionsCb;
+        if (fmPcdParams.kgSupport)
+            fmPcdParams.f_FmPcdIdException = LnxwrpFmPcdDevIndexedExceptionsCb;
+        fmPcdParams.h_App              = p_LnxWrpFmDev;
+#endif /* !CONFIG_GUEST_PARTITION */
+
+#ifdef CONFIG_MULTI_PARTITION_SUPPORT
+        fmPcdParams.numOfSchemes = 0;
+        fmPcdParams.numOfClsPlanEntries = 0;
+        fmPcdParams.partitionId = 0;
+#endif  /* CONFIG_MULTI_PARTITION_SUPPORT */
+        fmPcdParams.useHostCommand = TRUE;
+        p_LnxWrpFmDev->hc_tx_fq  =
+            FqAlloc(p_LnxWrpFmDev,
+                    0,
+                    QMAN_FQ_FLAG_TO_DCPORTAL,
+                    p_LnxWrpFmPortDev->txCh,
+                    0);
+        p_LnxWrpFmDev->hc_tx_conf_fq  =
+            FqAlloc(p_LnxWrpFmDev,
+                    0,
+                    QMAN_FQ_FLAG_NO_ENQUEUE,
+                    0,
+                    7);
+        p_LnxWrpFmDev->hc_tx_err_fq  =
+            FqAlloc(p_LnxWrpFmDev,
+                    0,
+                    QMAN_FQ_FLAG_NO_ENQUEUE,
+                    0,
+                    7);
+
+        fmPcdParams.hc.portBaseAddr = p_LnxWrpFmPortDev->baseAddr;
+        fmPcdParams.hc.portId = p_LnxWrpFmPortDev->id;
+        fmPcdParams.hc.errFqid = qman_fq_fqid(p_LnxWrpFmDev->hc_tx_err_fq);
+        fmPcdParams.hc.confFqid = qman_fq_fqid(p_LnxWrpFmDev->hc_tx_conf_fq);
+        fmPcdParams.hc.deqSubPortal = (p_LnxWrpFmPortDev->txCh & 0x1f);
+        fmPcdParams.hc.enqFqid = qman_fq_fqid(p_LnxWrpFmDev->hc_tx_fq);
+        fmPcdParams.hc.f_QmEnqueueCB = QmEnqueueCB;
+        fmPcdParams.hc.h_QmArg = (t_Handle)p_LnxWrpFmDev;
+
+        p_LnxWrpFmDev->h_PcdDev = FM_PCD_Config(&fmPcdParams);
+        if(!p_LnxWrpFmDev->h_PcdDev)
+            RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("FM PCD!"));
+
+        if((err = FM_PCD_ConfigPlcrNumOfSharedProfiles(p_LnxWrpFmDev->h_PcdDev,
+                                                       LNXWRP_FM_NUM_OF_SHARED_PROFILES))!= E_OK)
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+
+        if((err = FM_PCD_Init(p_LnxWrpFmDev->h_PcdDev))!= E_OK)
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
+
+    return E_OK;
+}
+
+static t_Error InitFmDev(t_LnxWrpFmDev  *p_LnxWrpFmDev)
+{
+    if (!p_LnxWrpFmDev->active)
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("FM not configured!!!"));
+
+    if ((p_LnxWrpFmDev->h_MuramDev = FM_MURAM_ConfigAndInit(p_LnxWrpFmDev->fmMuramBaseAddr, p_LnxWrpFmDev->fmMuramMemSize)) == NULL)
+        RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("FM-MURAM!"));
+
+    p_LnxWrpFmDev->fmDevSettings.param.h_FmMuram = p_LnxWrpFmDev->h_MuramDev;
+
+    if ((p_LnxWrpFmDev->h_Dev = FM_Config(&p_LnxWrpFmDev->fmDevSettings.param)) == NULL)
+        RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("FM"));
+
+    if (FM_Init(p_LnxWrpFmDev->h_Dev) != E_OK)
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("FM"));
+
+//    return InitFmPcdDev(p_LnxWrpFmDev);
+    return E_OK;
+}
+
+static t_Error InitFmPort3TupleDefPcd(t_LnxWrpFmPortDev *p_LnxWrpFmPortDev)
+{
+    t_LnxWrpFmDev                       *p_LnxWrpFmDev = (t_LnxWrpFmDev *)p_LnxWrpFmPortDev->h_LnxWrpFmDev;
+    t_FmPcdNetEnvParams                 netEnvParam;
+    t_FmPcdKgSchemeParams               schemeParam;
+    t_FmPortPcdParams                   pcdParam;
+    t_FmPortPcdPrsParams                prsParam;
+    t_FmPortPcdKgParams                 kgParam;
+    uint8_t                             i, j;
+
+    if (!p_LnxWrpFmDev->kgActive)
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("keygen must be enabled for 3-tuple PCD!"));
+
+    if (!p_LnxWrpFmDev->prsActive)
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("parser must be enabled for 3-tuple PCD!"));
+
+    if (p_LnxWrpFmPortDev->pcdNumOfQs < 9)
+        RETURN_ERROR(MINOR, E_INVALID_VALUE, ("Need to save at least 18 queues for 3-tuple PCD!!!"));
+
+    p_LnxWrpFmPortDev->totalNumOfSchemes = p_LnxWrpFmPortDev->numOfSchemesUsed = 2;
+
+    if (AllocSchemesForPort(p_LnxWrpFmDev, p_LnxWrpFmPortDev->totalNumOfSchemes, &p_LnxWrpFmPortDev->schemesBase) != E_OK)
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("No schemes for Rx or OP port for 3-tuple PCD!!!"));
+
+    /* set netEnv */
+    memset(&netEnvParam, 0, sizeof(t_FmPcdNetEnvParams));
+    netEnvParam.numOfDistinctionUnits = 2;
+    netEnvParam.units[0].hdrs[0].hdr = HEADER_TYPE_IPv4; /* no special options */
+    netEnvParam.units[1].hdrs[0].hdr = HEADER_TYPE_ETH;
+    p_LnxWrpFmPortDev->h_DefNetEnv = FM_PCD_SetNetEnvCharacteristics(p_LnxWrpFmDev->h_PcdDev, &netEnvParam);
+    if(!p_LnxWrpFmPortDev->h_DefNetEnv)
+        RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("FM PCD!"));
+
+    for(i=0; i<p_LnxWrpFmPortDev->numOfSchemesUsed; i++)
+    {
+        memset(&schemeParam, 0, sizeof(schemeParam));
+        schemeParam.modify = FALSE;
+        schemeParam.id.relativeSchemeId = i+p_LnxWrpFmPortDev->schemesBase;
+        schemeParam.alwaysDirect = FALSE;
+        schemeParam.netEnvParams.h_NetEnv = p_LnxWrpFmPortDev->h_DefNetEnv;
+        schemeParam.schemeCounter.update = TRUE;
+        schemeParam.schemeCounter.value = 0;
+
+        switch (i)
+        {
+            case (0): /* catch IPv4 */
+                schemeParam.netEnvParams.numOfDistinctionUnits = 1;
+                schemeParam.netEnvParams.unitIds[0] = 0;
+                schemeParam.baseFqid = p_LnxWrpFmPortDev->pcdBaseQ;
+                schemeParam.nextEngine = e_FM_PCD_DONE;
+                schemeParam.numOfUsedFqidMasks = 0;
+                schemeParam.useHash = TRUE;
+                schemeParam.keyExtractAndHashParams.numOfUsedExtracts = 3;
+                for(j=0; j<schemeParam.keyExtractAndHashParams.numOfUsedExtracts; j++)
+                {
+                    schemeParam.keyExtractAndHashParams.extractArray[j].type = e_FM_PCD_EXTRACT_BY_HDR;
+                    schemeParam.keyExtractAndHashParams.extractArray[j].extractParams.extractByHdr.hdr = HEADER_TYPE_IPv4;
+                    schemeParam.keyExtractAndHashParams.extractArray[j].extractParams.extractByHdr.ignoreProtocolValidation = FALSE;
+                    schemeParam.keyExtractAndHashParams.extractArray[j].extractParams.extractByHdr.type = e_FM_PCD_EXTRACT_FULL_FIELD;
+                }
+                schemeParam.keyExtractAndHashParams.extractArray[0].extractParams.extractByHdr.extractByHdrType.fullField.ipv4 = NET_HEADER_FIELD_IPv4_PROTO;
+                schemeParam.keyExtractAndHashParams.extractArray[1].extractParams.extractByHdr.extractByHdrType.fullField.ipv4 = NET_HEADER_FIELD_IPv4_SRC_IP;
+                schemeParam.keyExtractAndHashParams.extractArray[2].extractParams.extractByHdr.extractByHdrType.fullField.ipv4 = NET_HEADER_FIELD_IPv4_DST_IP;
+
+                if(schemeParam.useHash)
+                {
+                    schemeParam.keyExtractAndHashParams.privateDflt0 = 0x01020304;
+                    schemeParam.keyExtractAndHashParams.privateDflt1 = 0x11121314;
+                    schemeParam.keyExtractAndHashParams.numOfUsedDflts = FM_PCD_KG_NUM_OF_DEFAULT_GROUPS;
+                    for(j=0; j<FM_PCD_KG_NUM_OF_DEFAULT_GROUPS; j++)
+                    {
+                        schemeParam.keyExtractAndHashParams.dflts[j].type = (e_FmPcdKgKnownFieldsDfltTypes)j; /* all types */
+                        schemeParam.keyExtractAndHashParams.dflts[j].dfltSelect = e_FM_PCD_KG_DFLT_GBL_0;
+                    }
+                    schemeParam.keyExtractAndHashParams.numOfUsedMasks = 0;
+                    schemeParam.keyExtractAndHashParams.hashShift = 0;
+                    schemeParam.keyExtractAndHashParams.hashDistributionNumOfFqids = 8;
+                }
+                break;
+
+            case (1): /* Garbage collector */
+                schemeParam.netEnvParams.numOfDistinctionUnits = 0;
+                schemeParam.baseFqid = p_LnxWrpFmPortDev->pcdBaseQ+8;
+                break;
+
+            default:
+                break;
+        }
+
+        p_LnxWrpFmPortDev->h_Schemes[i] = FM_PCD_KgSetScheme(p_LnxWrpFmDev->h_PcdDev, &schemeParam);
+        if(!p_LnxWrpFmPortDev->h_Schemes[i])
+            RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("FM_PCD_KgSetScheme failed"));
+    }
+
+    /* initialize PCD parameters */
+    memset(&pcdParam, 0, sizeof( t_FmPortPcdParams));
+    pcdParam.h_NetEnv   = p_LnxWrpFmPortDev->h_DefNetEnv;
+    pcdParam.pcdSupport = e_FM_PORT_PCD_SUPPORT_PRS_AND_KG;
+
+    /* initialize Keygen parameters */
+    memset(&prsParam, 0, sizeof( t_FmPortPcdPrsParams));
+
+    prsParam.parsingOffset = 0;
+    prsParam.firstPrsHdr = HEADER_TYPE_ETH;
+    pcdParam.p_PrsParams = &prsParam;
+
+    /* initialize Parser parameters */
+    memset(&kgParam, 0, sizeof( t_FmPortPcdKgParams));
+    kgParam.numOfSchemes = p_LnxWrpFmPortDev->numOfSchemesUsed;
+    for(i=0;i<kgParam.numOfSchemes;i++)
+        kgParam.h_Schemes[i] = p_LnxWrpFmPortDev->h_Schemes[i];
+
+    pcdParam.p_KgParams = &kgParam;
+
+    return FM_PORT_SetPCD(p_LnxWrpFmPortDev->h_Dev, &pcdParam);
+}
+
+static t_Error InitFmPortDev(t_LnxWrpFmPortDev *p_LnxWrpFmPortDev)
+{
+#define MY_ADV_CONFIG_CHECK_END                                 \
+            RETURN_ERROR(MAJOR, E_INVALID_SELECTION,            \
+                         ("Advanced configuration routine"));   \
+        if (errCode != E_OK)                                    \
+            RETURN_ERROR(MAJOR, errCode, NO_MSG);               \
+    }
+
+    int                 i = 0;
+
+    if (!p_LnxWrpFmPortDev->active || p_LnxWrpFmPortDev->initialized)
+        return E_INVALID_STATE;
+
+    if ((p_LnxWrpFmPortDev->h_Dev = FM_PORT_Config(&p_LnxWrpFmPortDev->settings.param)) == NULL)
+        RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("FM-port"));
+
+    /* Call the driver's advanced configuration routines, if requested:
+       Compare the function pointer of each entry to the available routines,
+       and invoke the matching routine with proper casting of arguments. */
+    while (p_LnxWrpFmPortDev->settings.advConfig[i].p_Function)
+    {
+        ADV_CONFIG_CHECK_START(&(p_LnxWrpFmPortDev->settings.advConfig[i]))
+
+        ADV_CONFIG_CHECK(p_LnxWrpFmPortDev->h_Dev, FM_PORT_ConfigBufferPrefixContent,   PARAMS(1, (t_FmPortBufferPrefixContent*)))
+
+        MY_ADV_CONFIG_CHECK_END
+
+        /* Advance to next advanced configuration entry */
+        i++;
+    }
+
+    if (FM_PORT_Init(p_LnxWrpFmPortDev->h_Dev) != E_OK)
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
+
+    FM_PORT_Disable(p_LnxWrpFmPortDev->h_Dev);
+
+    if ((p_LnxWrpFmPortDev->defPcd != e_NO_PCD) &&
+        (InitFmPort3TupleDefPcd(p_LnxWrpFmPortDev) != E_OK))
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
+
+    p_LnxWrpFmPortDev->initialized = TRUE;
+
+    return E_OK;
+}
+
+static void FreeFmDev(t_LnxWrpFmDev  *p_LnxWrpFmDev)
+{
+    if (!p_LnxWrpFmDev->active)
+        return;
+
+    if (p_LnxWrpFmDev->h_PcdDev)
+        FM_PCD_Free(p_LnxWrpFmDev->h_PcdDev);
+
+    if (p_LnxWrpFmDev->h_Dev)
+        FM_Free(p_LnxWrpFmDev->h_Dev);
+
+    if (p_LnxWrpFmDev->h_MuramDev)
+        FM_MURAM_Free(p_LnxWrpFmDev->h_MuramDev);
+
+    SYS_UnregisterIoMap((uint64_t)p_LnxWrpFmDev->fmMuramBaseAddr);
+    devm_iounmap(p_LnxWrpFmDev->dev, (void*)p_LnxWrpFmDev->fmMuramBaseAddr);
+    __devm_release_region(p_LnxWrpFmDev->dev, p_LnxWrpFmDev->res, p_LnxWrpFmDev->fmMuramBaseAddr, p_LnxWrpFmDev->fmMuramMemSize);
+    SYS_UnregisterIoMap((uint64_t)p_LnxWrpFmDev->fmBaseAddr);
+    devm_iounmap(p_LnxWrpFmDev->dev, (void*)p_LnxWrpFmDev->fmBaseAddr);
+    release_mem_region(p_LnxWrpFmDev->fmBaseAddr, p_LnxWrpFmDev->fmMemSize);
+//    devm_release_mem_region(p_LnxWrpFmDev->dev, p_LnxWrpFmDev->fmBaseAddr, p_LnxWrpFmDev->fmMemSize);
+}
+
+static void FreeFmPortDev(t_LnxWrpFmPortDev *p_LnxWrpFmPortDev)
+{
+    t_LnxWrpFmDev       *p_LnxWrpFmDev = (t_LnxWrpFmDev *)p_LnxWrpFmPortDev->h_LnxWrpFmDev;
+
+    if (!p_LnxWrpFmPortDev->active)
+        return;
+
+    if (p_LnxWrpFmPortDev->h_Dev)
+        FM_PORT_Free(p_LnxWrpFmPortDev->h_Dev);
+    devm_iounmap(p_LnxWrpFmDev->dev, (void*)p_LnxWrpFmPortDev->baseAddr);
+    __devm_release_region(p_LnxWrpFmDev->dev, p_LnxWrpFmDev->res, p_LnxWrpFmPortDev->baseAddr, p_LnxWrpFmPortDev->memSize);
+}
+
+
+/*****************************************************************************/
+/*               API routines for the FM Linux Device                        */
+/*****************************************************************************/
+
+static int fm_open(struct inode *inode, struct file *file)
+{
+    t_LnxWrpFmDev       *p_LnxWrpFmDev = NULL;
+    t_LnxWrpFmPortDev   *p_LnxWrpFmPortDev = NULL;
+    unsigned int        major = imajor(inode);
+    unsigned int        minor = iminor(inode);
+
+    DBG(TRACE, ("Opening minor - %d - ", minor));
+
+    if (file->private_data != NULL)
+        return 0;
+
+#ifdef NO_OF_SUPPORT
+{
+    int                 i;
+    for (i=0; i<INTG_MAX_NUM_OF_FM; i++)
+        if (lnxWrpFm.p_FmDevs[i]->major == major)
+            p_LnxWrpFmDev = lnxWrpFm.p_FmDevs[i];
+}
+#else
+{
+    struct of_device_id name;
+    struct device_node  *fm_node;
+
+    /* Get all the FM nodes */
+    memset(&name, 0, sizeof(struct of_device_id));
+    BUG_ON(strlen("fsl,fman") >= sizeof(name.compatible));
+    strcpy(name.compatible, "fsl,fman");
+    for_each_matching_node(fm_node, &name) {
+        struct of_device    *of_dev;
+
+        of_dev = of_find_device_by_node(fm_node);
+        if (unlikely(of_dev == NULL)) {
+            REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("fm id!"));
+            return -ENXIO;
+        }
+
+        p_LnxWrpFmDev = (t_LnxWrpFmDev *)fm_bind(&of_dev->dev);
+        if (p_LnxWrpFmDev->major == major)
+            break;
+        fm_unbind((struct fm *)p_LnxWrpFmDev);
+        p_LnxWrpFmDev = NULL;
+    }
+}
+#endif /* NO_OF_SUPPORT */
+
+    if (!p_LnxWrpFmDev)
+        return -ENODEV;
+
+    if (minor == DEV_FM_MINOR_BASE)
+        file->private_data = p_LnxWrpFmDev;
+    else if (minor == DEV_FM_PCD_MINOR_BASE)
+        file->private_data = p_LnxWrpFmDev;
+    else {
+        if (minor == DEV_FM_HC_PORT_MINOR_BASE)
+            p_LnxWrpFmPortDev = &p_LnxWrpFmDev->hcPort;
+        else if ((minor >= DEV_FM_OP_PORTS_MINOR_BASE) && (minor < DEV_FM_RX_PORTS_MINOR_BASE))
+            p_LnxWrpFmPortDev = &p_LnxWrpFmDev->opPorts[minor-DEV_FM_OP_PORTS_MINOR_BASE];
+        else if ((minor >= DEV_FM_RX_PORTS_MINOR_BASE) && (minor < DEV_FM_TX_PORTS_MINOR_BASE))
+            p_LnxWrpFmPortDev = &p_LnxWrpFmDev->rxPorts[minor-DEV_FM_RX_PORTS_MINOR_BASE];
+        else if ((minor >= DEV_FM_TX_PORTS_MINOR_BASE) && (minor < DEV_FM_MAX_MINORS))
+            p_LnxWrpFmPortDev = &p_LnxWrpFmDev->txPorts[minor-DEV_FM_TX_PORTS_MINOR_BASE];
+        else
+            return -EINVAL;
+
+        /* if trying to open port, check if it initialized */
+        if (!p_LnxWrpFmPortDev->initialized)
+            return -ENODEV;
+
+        p_LnxWrpFmPortDev = (t_LnxWrpFmPortDev *)fm_port_bind(p_LnxWrpFmPortDev->dev);
+        file->private_data = p_LnxWrpFmPortDev;
+        fm_unbind((struct fm *)p_LnxWrpFmDev);
+    }
+
+    if (file->private_data == NULL)
+         return -ENXIO;
+
+    return 0;
+}
+
+static int fm_close(struct inode *inode, struct file *file)
+{
+    t_LnxWrpFmDev       *p_LnxWrpFmDev;
+    t_LnxWrpFmPortDev   *p_LnxWrpFmPortDev;
+    unsigned int        minor = iminor(inode);
+    int                 err = 0;
+
+    DBG(TRACE, ("Closing minor - %d - ", minor));
+
+    if ((minor == DEV_FM_MINOR_BASE) ||
+        (minor == DEV_FM_PCD_MINOR_BASE))
+    {
+        p_LnxWrpFmDev = (t_LnxWrpFmDev*)file->private_data;
+        if (!p_LnxWrpFmDev)
+            return -ENODEV;
+        fm_unbind((struct fm *)p_LnxWrpFmDev);
+    }
+    else if ((minor == DEV_FM_HC_PORT_MINOR_BASE) ||
+             ((minor >= DEV_FM_OP_PORTS_MINOR_BASE) && (minor < DEV_FM_RX_PORTS_MINOR_BASE)) ||
+             ((minor >= DEV_FM_RX_PORTS_MINOR_BASE) && (minor < DEV_FM_TX_PORTS_MINOR_BASE)) ||
+             ((minor >= DEV_FM_TX_PORTS_MINOR_BASE) && (minor < DEV_FM_MAX_MINORS)))
+    {
+        p_LnxWrpFmPortDev = (t_LnxWrpFmPortDev*)file->private_data;
+        if (!p_LnxWrpFmPortDev)
+            return -ENODEV;
+        fm_port_unbind((struct fm_port *)p_LnxWrpFmPortDev);
+    }
+
+    return err;
+}
+
+static int fm_ioctl(struct inode *inode, struct file *file, unsigned int cmd, unsigned long arg)
+{
+    unsigned int        minor = iminor(inode);
+
+    DBG(TRACE, ("IOCTL minor - %d, cmd - 0x%08x, arg - 0x%08x", minor, cmd, arg));
+
+    if ((minor == DEV_FM_MINOR_BASE) ||
+        (minor == DEV_FM_PCD_MINOR_BASE))
+    {
+        t_LnxWrpFmDev *p_LnxWrpFmDev = ((t_LnxWrpFmDev*)file->private_data);
+        if (!p_LnxWrpFmDev)
+            return -ENODEV;
+        if (LnxwrpFmIOCTL(p_LnxWrpFmDev, cmd, arg))
+            return -EFAULT;
+    }
+    else if ((minor == DEV_FM_HC_PORT_MINOR_BASE) ||
+             ((minor >= DEV_FM_OP_PORTS_MINOR_BASE) && (minor < DEV_FM_RX_PORTS_MINOR_BASE)) ||
+             ((minor >= DEV_FM_RX_PORTS_MINOR_BASE) && (minor < DEV_FM_TX_PORTS_MINOR_BASE)) ||
+             ((minor >= DEV_FM_TX_PORTS_MINOR_BASE) && (minor < DEV_FM_MAX_MINORS)))
+    {
+        t_LnxWrpFmPortDev *p_LnxWrpFmPortDev = ((t_LnxWrpFmPortDev*)file->private_data);
+        if (!p_LnxWrpFmPortDev)
+            return -ENODEV;
+        if (LnxwrpFmPortIOCTL(p_LnxWrpFmPortDev, cmd, arg))
+            return -EFAULT;
+    }
+    else
+    {
+        REPORT_ERROR(MINOR, E_INVALID_VALUE, ("minor"));
+        return -ENODEV;
+    }
+
+    return 0;
+}
+
+/* Globals for FM character device */
+static struct file_operations fm_fops =
+{
+    owner:      THIS_MODULE,
+    ioctl:      fm_ioctl,
+    open:       fm_open,
+    release:    fm_close,
+};
+
+
+#ifndef NO_OF_SUPPORT
+static int /*__devinit*/ fm_probe(struct of_device *of_dev, const struct of_device_id *match)
+{
+    t_LnxWrpFmDev   *p_LnxWrpFmDev;
+    char            fmName[10];
+
+    if ((p_LnxWrpFmDev = ReadFmDevTreeNode(of_dev)) == NULL)
+        return -EIO;
+    if (ConfigureFmDev(p_LnxWrpFmDev) != E_OK)
+        return -EIO;
+    if (InitFmDev(p_LnxWrpFmDev) != E_OK)
+        return -EIO;
+
+    memset(fmName,0,sizeof(fmName));
+    Sprint (fmName, "%s%d", DEV_FM_NAME, p_LnxWrpFmDev->id);
+
+    /* Register to the /dev for IOCTL API */
+    /* Register dynamically a new major number for the character device: */
+    if ((p_LnxWrpFmDev->major = register_chrdev(0, fmName, &fm_fops)) <= 0)
+    {
+        FreeFmDev(p_LnxWrpFmDev);
+        REPORT_ERROR(MAJOR, E_INVALID_STATE, ("Failed to allocate a major number for device \"%s\"", DEV_FM_NAME));
+        return -EIO;
+    }
+
+    /* Register to the /proc for debug and statistics API */
+    if (((p_LnxWrpFmDev->proc_fm = proc_mkdir(fmName, NULL)) == NULL) ||
+        ((p_LnxWrpFmDev->proc_fm_regs = create_proc_read_entry("regs", 0, p_LnxWrpFmDev->proc_fm, fm_proc_dump_regs, p_LnxWrpFmDev)) == NULL) ||
+        ((p_LnxWrpFmDev->proc_fm_stats = create_proc_read_entry("stats", 0, p_LnxWrpFmDev->proc_fm, fm_proc_dump_stats, p_LnxWrpFmDev)) == NULL))
+    {
+        FreeFmDev(p_LnxWrpFmDev);
+        REPORT_ERROR(MAJOR, E_INVALID_STATE, ("Unable to create proc entry - fm!!!"));
+        return -EIO;
+    }
+
+    dev_set_drvdata(p_LnxWrpFmDev->dev, p_LnxWrpFmDev);
+
+    DBG(TRACE, ("FM%d probed", p_LnxWrpFmDev->id));
+
+    return 0;
+}
+
+static int __devexit fm_remove(struct of_device *of_dev)
+{
+    t_LnxWrpFmDev   *p_LnxWrpFmDev;
+    struct device   *dev;
+    char            fmName[10];
+
+    dev = &of_dev->dev;
+    p_LnxWrpFmDev = dev_get_drvdata(dev);
+
+    remove_proc_entry("stats", p_LnxWrpFmDev->proc_fm);
+    remove_proc_entry("regs", p_LnxWrpFmDev->proc_fm);
+    memset(fmName,0,sizeof(fmName));
+    Sprint (fmName, "%s%d", DEV_FM_NAME, p_LnxWrpFmDev->id);
+    remove_proc_entry(fmName, NULL);
+
+    /* Destroy chardev */
+    unregister_chrdev(p_LnxWrpFmDev->major, DEV_FM_NAME);
+
+    FreeFmDev(p_LnxWrpFmDev);
+
+    DistroyFmDev(p_LnxWrpFmDev);
+
+    dev_set_drvdata(dev, NULL);
+
+    return 0;
+}
+
+static const struct of_device_id fm_match[] __devinitconst = {
+    {
+        .compatible    = "fsl,fman"
+    },
+    {}
+};
+#ifndef MODULE
+MODULE_DEVICE_TABLE(of, fm_match);
+#endif /* !MODULE */
+
+static struct of_platform_driver fm_driver = {
+    .name           = "fsl-fman",
+    .match_table    = fm_match,
+    .owner          = THIS_MODULE,
+    .probe          = fm_probe,
+    .remove         = __devexit_p(fm_remove)
+};
+
+static int /*__devinit*/ fm_port_probe(struct of_device *of_dev, const struct of_device_id *match)
+{
+    t_LnxWrpFmPortDev   *p_LnxWrpFmPortDev;
+    struct device       *dev;
+
+    dev = &of_dev->dev;
+
+    if ((p_LnxWrpFmPortDev = ReadFmPortDevTreeNode(of_dev)) == NULL)
+        return -EIO;
+
+    if (ConfigureFmPortDev(p_LnxWrpFmPortDev) != E_OK)
+        return -EIO;
+
+#if 0
+    if ((p_LnxWrpFmPortDev->settings.param.portType != e_FM_PORT_TYPE_RX_10G) &&
+        (p_LnxWrpFmPortDev->settings.param.portType != e_FM_PORT_TYPE_RX) &&
+        (p_LnxWrpFmPortDev->settings.param.portType != e_FM_PORT_TYPE_TX_10G) &&
+        (p_LnxWrpFmPortDev->settings.param.portType != e_FM_PORT_TYPE_TX) &&
+        (InitFmPortDev(p_LnxWrpFmPortDev) != E_OK))
+        return -EIO;
+#endif /* 0 */
+
+    dev_set_drvdata(dev, p_LnxWrpFmPortDev);
+
+    DBG(TRACE, ("FM-port-%s%d probed",
+               (((p_LnxWrpFmPortDev->settings.param.portType == e_FM_PORT_TYPE_RX_10G) ||
+                 (p_LnxWrpFmPortDev->settings.param.portType == e_FM_PORT_TYPE_RX)) ? "rx" :
+                (((p_LnxWrpFmPortDev->settings.param.portType == e_FM_PORT_TYPE_TX_10G) ||
+                  (p_LnxWrpFmPortDev->settings.param.portType == e_FM_PORT_TYPE_TX)) ? "tx" :
+                 ((p_LnxWrpFmPortDev->settings.param.portType == e_FM_PORT_TYPE_OFFLINE_PARSING) ? "op" : "hc"))),
+               p_LnxWrpFmPortDev->id));
+
+    if ((p_LnxWrpFmPortDev->settings.param.portType == e_FM_PORT_TYPE_HOST_COMMAND) &&
+        (InitFmPcdDev((t_LnxWrpFmDev *)p_LnxWrpFmPortDev->h_LnxWrpFmDev) != E_OK))
+        return -EIO;
+
+    return 0;
+}
+
+static int __devexit fm_port_remove(struct of_device *of_dev)
+{
+    t_LnxWrpFmPortDev   *p_LnxWrpFmPortDev;
+    struct device       *dev;
+
+    dev = &of_dev->dev;
+    p_LnxWrpFmPortDev = dev_get_drvdata(dev);
+
+    FreeFmPortDev(p_LnxWrpFmPortDev);
+
+    dev_set_drvdata(dev, NULL);
+
+    return 0;
+}
+
+static const struct of_device_id fm_port_match[] __devinitconst = {
+    {
+        .compatible    = "fsl,fman-port-oh"
+    },
+    {
+        .compatible    = "fsl,fman-port-1g-rx"
+    },
+    {
+        .compatible    = "fsl,fman-port-10g-rx"
+    },
+    {
+        .compatible    = "fsl,fman-port-1g-tx"
+    },
+    {
+        .compatible    = "fsl,fman-port-10g-tx"
+    },
+    {}
+};
+#ifndef MODULE
+MODULE_DEVICE_TABLE(of, fm_port_match);
+#endif /* !MODULE */
+
+static struct of_platform_driver fm_port_driver = {
+    .name           = "fsl-fman-port",
+    .match_table    = fm_port_match,
+    .owner          = THIS_MODULE,
+    .probe          = fm_port_probe,
+    .remove         = __devexit_p(fm_port_remove)
+};
+#endif /* !NO_OF_SUPPORT */
+
+
+t_Handle LNXWRP_FM_Init(void)
+{
+#ifdef NO_OF_SUPPORT
+    t_LnxWrpFmDev   *p_LnxWrpFmDev;
+    char            fmName[10];
+    int             i, j;
+#endif /* NO_OF_SUPPORT */
+
+    memset(&lnxWrpFm, 0, sizeof(lnxWrpFm));
+
+#ifdef NO_OF_SUPPORT
+    for (i=0; i<INTG_MAX_NUM_OF_FM; i++)
+    {
+        p_LnxWrpFmDev = CreateFmDev(i);
+        if (!p_LnxWrpFmDev)
+        {
+            REPORT_ERROR(MAJOR, E_INVALID_HANDLE, ("FM dev obj!"));
+            return NULL;
+        }
+        lnxWrpFm.p_FmDevs[i] = p_LnxWrpFmDev;
+
+        if (i==1)
+        {
+            ConfigureFmDev(p_LnxWrpFmDev);
+            if (InitFmDev(p_LnxWrpFmDev) != E_OK)
+                return NULL;
+
+            /* Register to the /dev for IOCTL API */
+            /* Register dynamically a new major number for the character device: */
+            if ((p_LnxWrpFmDev->major = register_chrdev(0, DEV_FM_NAME, &fm_fops)) <= 0)
+            {
+                REPORT_ERROR(MAJOR, E_INVALID_STATE, ("Failed to allocate a major number for device \"%s\"", DEV_FM_NAME));
+                return NULL;
+            }
+
+            /* Register to the /proc for debug and statistics API */
+            memset(fmName,0,sizeof(fmName));
+            Sprint (fmName, "%s%d", DEV_FM_NAME, p_LnxWrpFmDev->id);
+            if (((p_LnxWrpFmDev->proc_fm = proc_mkdir(fmName, NULL)) == NULL) ||
+                ((p_LnxWrpFmDev->proc_fm_regs = create_proc_read_entry("regs", 0, p_LnxWrpFmDev->proc_fm, fm_proc_dump_regs, p_LnxWrpFmDev)) == NULL) ||
+                ((p_LnxWrpFmDev->proc_fm_stats = create_proc_read_entry("stats", 0, p_LnxWrpFmDev->proc_fm, fm_proc_dump_stats, p_LnxWrpFmDev)) == NULL))
+            {
+                REPORT_ERROR(MAJOR, E_INVALID_STATE, ("Unable to create proc entry - fm!!!"));
+                return NULL;
+            }
+        }
+
+//        lnxWrpFm.h_Mod = p_TdmLnxWrpParam->h_Mod;
+//        lnxWrpFm.f_GetObject = p_TdmLnxWrpParam->f_GetObject;
+    }
+
+#else
+    /* Register to the DTB for basic FM API */
+    of_register_platform_driver(&fm_driver);
+    /* Register to the DTB for basic FM port API */
+    of_register_platform_driver(&fm_port_driver);
+#endif /* !NO_OF_SUPPORT */
+
+    return &lnxWrpFm;
+}
+
+t_Error LNXWRP_FM_Free(t_Handle h_LnxWrpFm)
+{
+#ifdef NO_OF_SUPPORT
+    t_LnxWrpFm          *p_LnxWrpFm = (t_LnxWrpFm *)h_LnxWrpFm;
+    t_LnxWrpFmDev       *p_LnxWrpFmDev;
+    int                 i, j;
+    char                fmName[10];
+
+    for (i=0; i<INTG_MAX_NUM_OF_FM; i++)
+    {
+        p_LnxWrpFmDev = p_LnxWrpFm->p_FmDevs[i];
+
+        remove_proc_entry("stats", p_LnxWrpFmDev->proc_fm);
+        remove_proc_entry("regs", p_LnxWrpFmDev->proc_fm);
+        memset(fmName,0,sizeof(fmName));
+        Sprint (fmName, "%s%d", DEV_FM_NAME, p_LnxWrpFmDev->id);
+        remove_proc_entry(fmName, NULL);
+
+        /* Destroy chardev */
+        unregister_chrdev(p_LnxWrpFmDev->major, DEV_FM_NAME);
+
+        FreeFmDev(p_LnxWrpFmDev);
+
+        DistroyFmDev(p_LnxWrpFmDev);
+    }
+
+#else
+        of_unregister_platform_driver(&fm_port_driver);
+        of_unregister_platform_driver(&fm_driver);
+#endif /* NO_OF_SUPPORT */
+
+    return E_OK;
+}
+
+
+struct fm * fm_bind (struct device *fm_dev)
+{
+    return (struct fm *)(dev_get_drvdata(get_device(fm_dev)));
+}
+EXPORT_SYMBOL(fm_bind);
+
+void fm_unbind(struct fm *fm)
+{
+    t_LnxWrpFmDev       *p_LnxWrpFmDev = (t_LnxWrpFmDev*)fm;
+
+    put_device(p_LnxWrpFmDev->dev);
+}
+EXPORT_SYMBOL(fm_unbind);
+
+struct resource * fm_get_mem_region(struct fm *fm)
+{
+    t_LnxWrpFmDev       *p_LnxWrpFmDev = (t_LnxWrpFmDev*)fm;
+
+    return p_LnxWrpFmDev->res;
+}
+EXPORT_SYMBOL(fm_get_mem_region);
+
+void * fm_get_handle(struct fm *fm)
+{
+    t_LnxWrpFmDev       *p_LnxWrpFmDev = (t_LnxWrpFmDev*)fm;
+
+    return (void *)p_LnxWrpFmDev->h_Dev;
+}
+EXPORT_SYMBOL(fm_get_handle);
+
+struct fm_port * fm_port_bind (struct device *fm_port_dev)
+{
+    return (struct fm_port *)(dev_get_drvdata(get_device(fm_port_dev)));
+}
+EXPORT_SYMBOL(fm_port_bind);
+
+void fm_port_unbind(struct fm_port *port)
+{
+    t_LnxWrpFmPortDev   *p_LnxWrpFmPortDev = (t_LnxWrpFmPortDev*)port;
+
+    put_device(p_LnxWrpFmPortDev->dev);
+}
+EXPORT_SYMBOL(fm_port_unbind);
+
+void * fm_port_get_handle(struct fm_port *port)
+{
+    t_LnxWrpFmPortDev   *p_LnxWrpFmPortDev = (t_LnxWrpFmPortDev*)port;
+
+    return (void *)p_LnxWrpFmPortDev->h_Dev;
+}
+EXPORT_SYMBOL(fm_port_get_handle);
+
+void fm_set_rx_port_params(struct fm_port *port, struct fm_port_rx_params *params)
+{
+    t_LnxWrpFmPortDev   *p_LnxWrpFmPortDev = (t_LnxWrpFmPortDev*)port;
+    int                 i;
+
+    p_LnxWrpFmPortDev->settings.param.specificParams.rxParams.errFqid  = params->errq;
+    p_LnxWrpFmPortDev->settings.param.specificParams.rxParams.dfltFqid = params->defq;
+
+    p_LnxWrpFmPortDev->settings.param.specificParams.rxParams.rxExtBufPools.numOfPoolsUsed = params->num_pools;
+    for (i=0; i<params->num_pools; i++)
+    {
+        p_LnxWrpFmPortDev->settings.param.specificParams.rxParams.rxExtBufPools.rxExtBufPool[i].id =
+            params->pool_param[i].id;
+        p_LnxWrpFmPortDev->settings.param.specificParams.rxParams.rxExtBufPools.rxExtBufPool[i].size =
+            params->pool_param[i].size;
+    }
+
+    p_LnxWrpFmPortDev->buffPrefixContent.privDataSize     = params->priv_data_size;
+    p_LnxWrpFmPortDev->buffPrefixContent.passPrsResult    = params->parse_results;
+
+    ADD_ADV_CONFIG_START(p_LnxWrpFmPortDev->settings.advConfig, FM_MAX_NUM_OF_ADV_SETTINGS)
+
+    ADD_ADV_CONFIG(FM_PORT_ConfigBufferPrefixContent,   ARGS(1, (&p_LnxWrpFmPortDev->buffPrefixContent)));
+
+    ADD_ADV_CONFIG_END
+
+    InitFmPortDev(p_LnxWrpFmPortDev);
+}
+EXPORT_SYMBOL(fm_set_rx_port_params);
+
+void fm_port_pcd_bind (struct fm_port *port, struct fm_port_pcd_param *params)
+{
+    t_LnxWrpFmPortDev   *p_LnxWrpFmPortDev = (t_LnxWrpFmPortDev*)port;
+
+    p_LnxWrpFmPortDev->pcd_owner_params.cb      = params->cb;
+    p_LnxWrpFmPortDev->pcd_owner_params.dev     = params->dev;
+}
+EXPORT_SYMBOL(fm_port_pcd_bind);
+
+void fm_set_tx_port_params(struct fm_port *port, struct fm_port_non_rx_params *params)
+{
+    t_LnxWrpFmPortDev   *p_LnxWrpFmPortDev = (t_LnxWrpFmPortDev*)port;
+
+    p_LnxWrpFmPortDev->settings.param.specificParams.nonRxParams.errFqid  = params->errq;
+    p_LnxWrpFmPortDev->settings.param.specificParams.nonRxParams.dfltFqid = params->defq;
+
+    p_LnxWrpFmPortDev->buffPrefixContent.privDataSize     = params->priv_data_size;
+    p_LnxWrpFmPortDev->buffPrefixContent.passPrsResult    = params->parse_results;
+
+    ADD_ADV_CONFIG_START(p_LnxWrpFmPortDev->settings.advConfig, FM_MAX_NUM_OF_ADV_SETTINGS)
+
+    ADD_ADV_CONFIG(FM_PORT_ConfigBufferPrefixContent,   ARGS(1, (&p_LnxWrpFmPortDev->buffPrefixContent)));
+
+    ADD_ADV_CONFIG_END
+
+    InitFmPortDev(p_LnxWrpFmPortDev);
+}
+EXPORT_SYMBOL(fm_set_tx_port_params);
+
+int fm_get_tx_port_channel(struct fm_port *port)
+{
+    t_LnxWrpFmPortDev   *p_LnxWrpFmPortDev = (t_LnxWrpFmPortDev*)port;
+
+    return p_LnxWrpFmPortDev->txCh;
+}
+EXPORT_SYMBOL(fm_get_tx_port_channel);
+
+int fm_port_enable (struct fm_port *port)
+{
+    t_LnxWrpFmPortDev   *p_LnxWrpFmPortDev = (t_LnxWrpFmPortDev*)port;
+
+    FM_PORT_Enable(p_LnxWrpFmPortDev->h_Dev);
+
+    return 0;
+}
+EXPORT_SYMBOL(fm_port_enable);
+
+void fm_port_disable(struct fm_port *port)
+{
+    t_LnxWrpFmPortDev   *p_LnxWrpFmPortDev = (t_LnxWrpFmPortDev*)port;
+
+    FM_PORT_Disable(p_LnxWrpFmPortDev->h_Dev);
+}
+EXPORT_SYMBOL(fm_port_disable);
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/lnxwrp_fm.h b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/lnxwrp_fm.h
new file mode 100644
index 0000000..8191b05
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/lnxwrp_fm.h
@@ -0,0 +1,189 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**************************************************************************//**
+ @File          lnxwrp_fm.h
+
+ @Author        Shlomi Gridish
+
+ @Description   FM Linux wrapper functions.
+*//***************************************************************************/
+#ifndef __LNXWRP_FM_H__
+#define __LNXWRP_FM_H__
+
+#include <linux/fsl_qman.h>    /* struct qman_fq */
+
+#include "std_ext.h"
+#include "error_ext.h"
+#include "list_ext.h"
+#include "procbuff_ext.h"
+
+#include "lnxwrp_fm_ext.h"
+
+
+#define __ERR_MODULE__      MODULE_FM
+
+
+#define FM_MAX_NUM_OF_ADV_SETTINGS          10
+
+#define LNXWRP_FM_NUM_OF_SHARED_PROFILES    16
+
+
+typedef enum {
+    e_NO_PCD = 0,
+    e_FM_PCD_3_TUPLE
+} e_LnxWrpFmPortPcdDefUseCase;
+
+
+typedef struct t_FmTestFq {
+    struct qman_fq      fq_base;
+    t_Handle            h_Arg;
+} t_FmTestFq;
+
+typedef struct {
+    uint8_t                     id;
+    bool                        active;
+    bool                        initialized;
+    uint32_t                    baseAddr;
+    uint32_t                    memSize;
+    t_WrpFmPortDevSettings      settings;
+    uint8_t                     totalNumOfSchemes;
+    uint8_t                     schemesBase;
+    uint8_t                     numOfSchemesUsed;
+    uint32_t                    pcdBaseQ;
+    uint16_t                    pcdNumOfQs;
+    struct fm_port_pcd_param    pcd_owner_params;
+    e_LnxWrpFmPortPcdDefUseCase defPcd;
+    t_Handle                    h_DefNetEnv;
+    t_Handle                    h_Schemes[FM_PCD_KG_NUM_OF_SCHEMES];
+    t_FmPortBufferPrefixContent buffPrefixContent;
+    t_Handle                    h_Dev;
+    t_Handle                    h_LnxWrpFmDev;
+    uint16_t                    txCh;
+    struct device               *dev;
+} t_LnxWrpFmPortDev;
+
+typedef struct {
+    uint8_t                     id;
+    bool                        active;
+    uint32_t                    baseAddr;
+    uint32_t                    memSize;
+    t_WrpFmMacDevSettings       settings;
+    t_Handle                    h_Dev;
+    t_Handle                    h_LnxWrpFmDev;
+} t_LnxWrpFmMacDev;
+
+typedef struct {
+    uint8_t                     id;
+    bool                        active;
+    bool                        pcdActive;
+    bool                        prsActive;
+    bool                        kgActive;
+    bool                        ccActive;
+    bool                        plcrActive;
+    e_LnxWrpFmPortPcdDefUseCase defPcd;
+    uint32_t                    usedSchemes;
+    uint8_t                     totalNumOfSharedSchemes;
+    uint8_t                     sharedSchemesBase;
+    uint8_t                     numOfSchemesUsed;
+    uint8_t                     defNetEnvId;
+    uint32_t                    fmBaseAddr;
+    uint32_t                    fmMemSize;
+    uint32_t                    fmMuramBaseAddr;
+    uint32_t                    fmMuramMemSize;
+    int                         irq1;
+    int                         irq2;
+    t_WrpFmDevSettings          fmDevSettings;
+    t_WrpFmPcdDevSettings       fmPcdDevSettings;
+    t_Handle                    h_Dev;
+
+    t_Handle                    h_MuramDev;
+    t_Handle                    h_PcdDev;
+
+    t_LnxWrpFmPortDev           hcPort;
+    t_LnxWrpFmPortDev           opPorts[FM_MAX_NUM_OF_OP_PORTS];
+    t_LnxWrpFmPortDev           rxPorts[FM_MAX_NUM_OF_RX_PORTS];
+    t_LnxWrpFmPortDev           txPorts[FM_MAX_NUM_OF_TX_PORTS];
+    t_LnxWrpFmMacDev            macs[FM_MAX_NUM_OF_MACS];
+
+    struct device               *dev;
+    struct resource             *res;
+    int                         major;
+    struct proc_dir_entry       *proc_fm;
+    struct proc_dir_entry       *proc_fm_regs;
+    struct proc_dir_entry       *proc_fm_stats;
+    struct device               *dpaa_dev;
+    struct qman_fq              *hc_tx_conf_fq, *hc_tx_err_fq, *hc_tx_fq;
+} t_LnxWrpFmDev;
+
+typedef struct {
+//    t_Handle h_Mod;
+//    t_Handle (*f_GetObject) (t_Handle h_Mod, e_SysModule devType, ...);
+
+    t_LnxWrpFmDev   *p_FmDevs[INTG_MAX_NUM_OF_FM];
+} t_LnxWrpFm;
+#define LNXWRP_FM_OBJECT(ptr)   LIST_OBJECT(ptr, t_LnxWrpFm, fms[((t_LnxWrpFmDev *)ptr)->id])
+
+
+t_Error  LnxwrpFmIOCTL(t_LnxWrpFmDev *p_LnxWrpFmDev, unsigned int cmd, unsigned long arg);
+t_Error  LnxwrpFmPortIOCTL(t_LnxWrpFmPortDev *p_LnxWrpFmPortDev, unsigned int cmd, unsigned long arg);
+
+
+static __inline__ t_Error AllocSchemesForPort(t_LnxWrpFmDev *p_LnxWrpFmDev, uint8_t numSchemes, uint8_t *p_BaseSchemeNum)
+{
+    uint32_t    schemeMask;
+    uint8_t     i;
+
+    if (!numSchemes)
+        RETURN_ERROR(MINOR, E_INVALID_VALUE, NO_MSG);
+
+    schemeMask = 0x80000000;
+    *p_BaseSchemeNum = 0xff;
+
+    for (i=0; schemeMask && numSchemes; schemeMask>>=1, i++)
+        if ((p_LnxWrpFmDev->usedSchemes & schemeMask) == 0)
+        {
+            p_LnxWrpFmDev->usedSchemes |= schemeMask;
+            numSchemes--;
+            if (*p_BaseSchemeNum==0xff)
+                *p_BaseSchemeNum = i;
+        }
+        else if (*p_BaseSchemeNum!=0xff)
+            RETURN_ERROR(MINOR, E_INVALID_STATE, ("Fragmentation on schemes array!!!"));
+
+    if (numSchemes)
+        RETURN_ERROR(MINOR, E_FULL, ("schemes!!!"));
+    return E_OK;
+}
+
+
+#endif /* __LNXWRP_FM_H__ */
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/lnxwrp_fm_ioctls.c b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/lnxwrp_fm_ioctls.c
new file mode 100644
index 0000000..1e2f239
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/lnxwrp_fm_ioctls.c
@@ -0,0 +1,1012 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**************************************************************************//**
+ @File          lnxwrp_fm.c
+
+ @Author        Shlomi Gridish
+
+ @Description   FM Linux wrapper functions.
+*//***************************************************************************/
+
+/* Linux Headers ------------------- */
+#include <linux/version.h>
+
+#if defined(CONFIG_MODVERSIONS) && !defined(MODVERSIONS)
+#define MODVERSIONS
+#endif
+#ifdef MODVERSIONS
+#include <config/modversions.h>
+#endif /* MODVERSIONS */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/fs.h>
+#include <linux/cdev.h>
+#include <linux/device.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/ioport.h>
+#include <asm/uaccess.h>
+#include <asm/errno.h>
+#include <sysdev/fsl_soc.h>
+
+/* NetCommSw Headers --------------- */
+#include "std_ext.h"
+#include "error_ext.h"
+#include "sprint_ext.h"
+#include "sys_io_ext.h"
+
+#include "fm_ioctls.h"
+#include "fm_pcd_ioctls.h"
+#include "fm_port_ioctls.h"
+
+#include "lnxwrp_fm.h"
+
+
+static t_Error LnxwrpFmPcdIOCTL(t_LnxWrpFmDev *p_LnxWrpFmDev, unsigned int cmd, unsigned long arg)
+{
+    t_Error err = E_READ_FAILED;
+
+    switch (cmd)
+    {
+        case FM_PCD_IOC_PRS_LOAD_SW:
+            break;
+
+        case FM_PCD_IOC_ENABLE:
+            return FM_PCD_Enable(p_LnxWrpFmDev->h_PcdDev);
+        case FM_PCD_IOC_DISABLE:
+            return FM_PCD_Disable(p_LnxWrpFmDev->h_PcdDev);
+
+        case FM_PCD_IOC_FORCE_INTR:
+        {
+            int exception;
+            if (get_user(exception, (int *)arg))
+                break;
+            return FM_PCD_ForceIntr(p_LnxWrpFmDev->h_PcdDev, (e_FmPcdExceptions)exception);
+        }
+
+        case FM_PCD_IOC_SET_EXCEPTION:
+        {
+            ioc_fm_pcd_exception_params_t *param;
+
+            param = (ioc_fm_pcd_exception_params_t *)XX_Malloc(sizeof(ioc_fm_pcd_exception_params_t));
+            if (!param)
+                RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
+
+            if (copy_from_user(param, (ioc_fm_pcd_exception_params_t *)arg, sizeof(ioc_fm_pcd_exception_params_t))) {
+                XX_Free(param);
+                RETURN_ERROR(MINOR, err, NO_MSG);
+            }
+
+            err = FM_PCD_SetException(p_LnxWrpFmDev->h_PcdDev, param->exception, param->enable);
+            XX_Free(param);
+            break;
+        }
+
+        case FM_PCD_IOC_KG_SET_ADDITIONAL_DATA_AFTER_PARSING:
+        {
+            int payloadOffset;
+            if (get_user(payloadOffset, (int *)arg))
+                break;
+            return FM_PCD_KgSetAdditionalDataAfterParsing(p_LnxWrpFmDev->h_PcdDev, (uint8_t)payloadOffset);
+        }
+
+        case FM_PCD_IOC_KG_SET_EMPTY_CLS_PLAN_GRP:
+            return FM_PCD_KgSetEmptyClsPlanGrp(p_LnxWrpFmDev->h_PcdDev);
+        case FM_PCD_IOC_KG_DELETE_EMPTY_CLS_PLAN_GRP:
+            return FM_PCD_KgDeleteEmptyClsPlanGrp(p_LnxWrpFmDev->h_PcdDev);
+
+        case FM_PCD_IOC_KG_SET_DFLT_VALUE:
+        {
+            ioc_fm_pcd_kg_dflt_value_params_t *param;
+
+            param = (ioc_fm_pcd_kg_dflt_value_params_t *)XX_Malloc(sizeof(ioc_fm_pcd_kg_dflt_value_params_t));
+            if (!param)
+                RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
+
+            if (copy_from_user(param, (ioc_fm_pcd_kg_dflt_value_params_t *)arg, sizeof(ioc_fm_pcd_kg_dflt_value_params_t))) {
+                XX_Free(param);
+                RETURN_ERROR(MINOR, err, NO_MSG);
+            }
+
+            err = FM_PCD_KgSetDfltValue(p_LnxWrpFmDev->h_PcdDev, param->valueId, param->value);
+            XX_Free(param);
+            break;
+        }
+
+        case FM_PCD_IOC_SET_NET_ENV_CHARACTERISTICS:
+        {
+            ioc_fm_pcd_net_env_params_t  *param;
+
+            param = (ioc_fm_pcd_net_env_params_t *)XX_Malloc(sizeof(ioc_fm_pcd_net_env_params_t));
+            if (!param)
+                RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
+
+            if (copy_from_user(param, (ioc_fm_pcd_net_env_params_t *)arg, sizeof(ioc_fm_pcd_net_env_params_t))) {
+                XX_Free(param);
+                RETURN_ERROR(MINOR, err, NO_MSG);
+            }
+
+            param->id = FM_PCD_SetNetEnvCharacteristics(p_LnxWrpFmDev->h_PcdDev, (t_FmPcdNetEnvParams*)param);
+            if (param->id && !copy_to_user((ioc_fm_pcd_net_env_params_t *)arg, param, sizeof(ioc_fm_pcd_net_env_params_t)))
+                err = E_OK;
+            XX_Free(param);
+            break;
+        }
+
+        case FM_PCD_IOC_DELETE_NET_ENV_CHARACTERISTICS:
+        {
+            ioc_fm_obj_t id;
+            if (copy_from_user(&id, (ioc_fm_obj_t *)arg, sizeof(ioc_fm_obj_t)))
+                break;
+            return FM_PCD_DeleteNetEnvCharacteristics(p_LnxWrpFmDev->h_PcdDev, id.obj);
+        }
+
+        case FM_PCD_IOC_KG_SET_CLS_PLAN_GRP:
+        {
+            ioc_fm_pcd_kg_cls_plan_grp_params_t *param;
+
+            param = (ioc_fm_pcd_kg_cls_plan_grp_params_t *)XX_Malloc(sizeof(ioc_fm_pcd_kg_cls_plan_grp_params_t));
+            if (!param)
+                RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
+
+            if (copy_from_user(param, (ioc_fm_pcd_kg_cls_plan_grp_params_t *)arg, sizeof(ioc_fm_pcd_kg_cls_plan_grp_params_t))) {
+                XX_Free(param);
+                RETURN_ERROR(MINOR, err, NO_MSG);
+            }
+
+            param->id = FM_PCD_KgSetClsPlanGrp(p_LnxWrpFmDev->h_PcdDev, (t_FmPcdKgClsPlanGrpParams*)param);
+            if (param->id && !copy_to_user((ioc_fm_pcd_kg_cls_plan_grp_params_t *)arg, param, sizeof(ioc_fm_pcd_kg_cls_plan_grp_params_t)))
+                err = E_OK;
+
+            XX_Free(param);
+            break;
+        }
+
+        case FM_PCD_IOC_KG_DEL_CLS_PLAN:
+        {
+            ioc_fm_obj_t id;
+            if (copy_from_user(&id, (ioc_fm_obj_t *)arg, sizeof(ioc_fm_obj_t)))
+                break;
+            return FM_PCD_KgDeleteClsPlanGrp(p_LnxWrpFmDev->h_PcdDev, id.obj);
+        }
+
+        case FM_PCD_IOC_KG_SET_SCHEME:
+        {
+            ioc_fm_pcd_kg_scheme_params_t               *param;
+
+            param = (ioc_fm_pcd_kg_scheme_params_t *)XX_Malloc(sizeof(ioc_fm_pcd_kg_scheme_params_t));
+            if (!param)
+                RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
+
+            if (copy_from_user(param, (ioc_fm_pcd_kg_scheme_params_t *)arg, sizeof(ioc_fm_pcd_kg_scheme_params_t))) {
+                XX_Free(param);
+                RETURN_ERROR(MINOR, err, NO_MSG);
+            }
+
+            param->id = FM_PCD_KgSetScheme(p_LnxWrpFmDev->h_PcdDev, (t_FmPcdKgSchemeParams*)param);
+            if (param->id && !copy_to_user((ioc_fm_pcd_kg_scheme_params_t *)arg, param, sizeof(ioc_fm_pcd_kg_scheme_params_t)))
+                err = E_OK;
+
+            XX_Free(param);
+            break;
+        }
+
+        case FM_PCD_IOC_KG_DEL_SCHEME:
+        {
+            ioc_fm_obj_t id;
+            if (copy_from_user(&id, (ioc_fm_obj_t *)arg, sizeof(ioc_fm_obj_t)))
+                break;
+            return FM_PCD_KgDeleteScheme(p_LnxWrpFmDev->h_PcdDev, id.obj);
+        }
+
+        case FM_PCD_IOC_CC_SET_NODE:
+        {
+            ioc_fm_pcd_cc_node_params_t *param;
+            uint8_t                     gbl_mask[4];
+            uint8_t                     *keys;
+            uint8_t                     *masks;
+            int                         i,k;
+
+            param = (ioc_fm_pcd_cc_node_params_t *)XX_Malloc(sizeof(ioc_fm_pcd_cc_node_params_t));
+            if (!param)
+                RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
+
+            keys = (uint8_t *)XX_Malloc(sizeof(uint8_t)*IOC_FM_PCD_MAX_NUM_OF_KEYS*IOC_FM_PCD_MAX_SIZE_OF_KEY);
+            if (!keys)
+                RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD keys"));
+            memset(keys, 0, sizeof(uint8_t)*IOC_FM_PCD_MAX_NUM_OF_KEYS*IOC_FM_PCD_MAX_SIZE_OF_KEY);
+
+            masks = (uint8_t *)XX_Malloc(sizeof(uint8_t)*IOC_FM_PCD_MAX_NUM_OF_KEYS*IOC_FM_PCD_MAX_SIZE_OF_KEY);
+            if (!masks)
+                RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD masks"));
+            memset(masks, 0, sizeof(uint8_t)*IOC_FM_PCD_MAX_NUM_OF_KEYS*IOC_FM_PCD_MAX_SIZE_OF_KEY);
+
+            if (copy_from_user(param, (ioc_fm_pcd_cc_node_params_t *)arg, sizeof(ioc_fm_pcd_cc_node_params_t))) {
+                XX_Free(param);
+                RETURN_ERROR(MINOR, err, NO_MSG);
+            }
+
+            if (param->keys_params.p_glbl_mask &&
+                (param->keys_params.key_size <= 4)) {
+                if (copy_from_user(&gbl_mask,
+                                   param->keys_params.p_glbl_mask,
+                                   param->keys_params.key_size)) {
+                    XX_Free(masks);
+                    XX_Free(keys);
+                    XX_Free(param);
+                    RETURN_ERROR(MINOR, err, NO_MSG);
+                }
+                param->keys_params.p_glbl_mask = gbl_mask;
+            }
+
+            for (i=0,k=0; i<param->keys_params.num_of_keys; i++, k+=IOC_FM_PCD_MAX_SIZE_OF_KEY) {
+                if (copy_from_user(&keys[k],
+                               param->keys_params.key_params[i].p_key,
+                               param->keys_params.key_size)) {
+                    XX_Free(masks);
+                    XX_Free(keys);
+                    XX_Free(param);
+                    RETURN_ERROR(MINOR, err, NO_MSG);
+                }
+                param->keys_params.key_params[i].p_key = &keys[k];
+
+                if (param->keys_params.key_params[i].p_mask) {
+                    if (copy_from_user(&masks[k],
+                                   param->keys_params.key_params[i].p_mask,
+                                   param->keys_params.key_size)) {
+                        XX_Free(masks);
+                        XX_Free(keys);
+                        XX_Free(param);
+                        RETURN_ERROR(MINOR, err, NO_MSG);
+                    }
+                    param->keys_params.key_params[i].p_mask = &masks[k];
+                }
+            }
+            param->id = FM_PCD_CcSetNode(p_LnxWrpFmDev->h_PcdDev, (t_FmPcdCcNodeParams*)param);
+            if (param->id && !copy_to_user((ioc_fm_pcd_cc_node_params_t *)arg, param, sizeof(ioc_fm_pcd_cc_node_params_t)))
+                err = E_OK;
+
+            XX_Free(masks);
+            XX_Free(keys);
+            XX_Free(param);
+            break;
+        }
+
+        case FM_PCD_IOC_CC_DELETE_NODE:
+        {
+            ioc_fm_obj_t id;
+            if (copy_from_user(&id, (ioc_fm_obj_t *)arg, sizeof(ioc_fm_obj_t)))
+                break;
+            return FM_PCD_CcDeleteNode(p_LnxWrpFmDev->h_PcdDev, id.obj);
+        }
+
+        case FM_PCD_IOC_CC_BUILD_TREE:
+        {
+            ioc_fm_pcd_cc_tree_params_t         *param;
+            ioc_fm_pcd_cc_next_engine_params_t  *next_engine_per_entries_in_grp;
+            uint8_t                             numOfEntriesInGroup;
+            int                                 i;
+
+            param = (ioc_fm_pcd_cc_tree_params_t *)XX_Malloc(sizeof(ioc_fm_pcd_cc_tree_params_t));
+            if (!param)
+                RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
+
+            if (copy_from_user(param, (ioc_fm_pcd_cc_tree_params_t *)arg, sizeof(ioc_fm_pcd_cc_tree_params_t))) {
+                XX_Free(param);
+                RETURN_ERROR(MINOR, err, NO_MSG);
+            }
+
+            for (i=0; i<param->num_of_groups; i++) {
+                if (param->fm_pcd_cc_group_params[i].p_next_engine_per_entries_in_grp) {
+                    numOfEntriesInGroup = (uint8_t)( 0x01 << param->fm_pcd_cc_group_params[i].num_of_distinction_units);
+                    if ((numOfEntriesInGroup ==0 ) || (numOfEntriesInGroup >= 16)) {
+                        XX_Free(param);
+                        RETURN_ERROR(MINOR, E_INVALID_VALUE, ("numOfEntriesInGroup"));
+                    }
+
+                    next_engine_per_entries_in_grp =
+                        (ioc_fm_pcd_cc_next_engine_params_t *)XX_Malloc(numOfEntriesInGroup*sizeof(ioc_fm_pcd_cc_next_engine_params_t));
+                    if (!next_engine_per_entries_in_grp)
+                        RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
+
+                    if (copy_from_user(next_engine_per_entries_in_grp,
+                                       param->fm_pcd_cc_group_params[i].p_next_engine_per_entries_in_grp,
+                                       numOfEntriesInGroup*sizeof(ioc_fm_pcd_cc_next_engine_params_t))) {
+                        XX_Free(param);
+                        RETURN_ERROR(MINOR, err, NO_MSG);
+                    }
+                    param->fm_pcd_cc_group_params[i].p_next_engine_per_entries_in_grp = next_engine_per_entries_in_grp;
+                }
+            }
+
+            param->id = FM_PCD_CcBuildTree(p_LnxWrpFmDev->h_PcdDev, (t_FmPcdCcTreeParams*)param);
+            if (param->id && !copy_to_user((ioc_fm_pcd_cc_tree_params_t *)arg, param, sizeof(ioc_fm_pcd_cc_tree_params_t)))
+                err = E_OK;
+
+            for (i=0; i<param->num_of_groups; i++)
+                if (param->fm_pcd_cc_group_params[i].p_next_engine_per_entries_in_grp)
+                    XX_Free(param->fm_pcd_cc_group_params[i].p_next_engine_per_entries_in_grp);
+            XX_Free(param);
+            break;
+        }
+
+        case FM_PCD_IOC_CC_DELETE_TREE:
+        {
+            ioc_fm_obj_t id;
+            if (copy_from_user(&id, (ioc_fm_obj_t *)arg, sizeof(ioc_fm_obj_t)))
+                break;
+            return FM_PCD_CcDeleteTree(p_LnxWrpFmDev->h_PcdDev, id.obj);
+        }
+
+        case FM_PCD_IOC_PLCR_SET_PROFILE:
+        {
+            ioc_fm_pcd_plcr_profile_params_t            *param;
+
+            param = (ioc_fm_pcd_plcr_profile_params_t *)XX_Malloc(sizeof(ioc_fm_pcd_plcr_profile_params_t));
+            if (!param)
+                RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
+
+            if (copy_from_user(param, (ioc_fm_pcd_plcr_profile_params_t *)arg, sizeof(ioc_fm_pcd_plcr_profile_params_t))) {
+                XX_Free(param);
+                RETURN_ERROR(MINOR, err, NO_MSG);
+            }
+
+            if (!param->modify &&
+                (((t_FmPcdPlcrProfileParams*)param)->id.newParams.profileType != e_FM_PCD_PLCR_SHARED))
+            {
+                t_Handle h_Port;
+
+                switch (((fm_pcd_port_params_t*)((t_FmPcdPlcrProfileParams*)param)->id.newParams.h_FmPort)->port_type)
+                {
+                    case (e_IOC_FM_PORT_TYPE_OFFLINE_PARSING):
+                        h_Port = p_LnxWrpFmDev->opPorts[((fm_pcd_port_params_t*)((t_FmPcdPlcrProfileParams*)param)->id.newParams.h_FmPort)->port_id].h_Dev;
+                        break;
+                    case (e_IOC_FM_PORT_TYPE_RX):
+                        h_Port = p_LnxWrpFmDev->rxPorts[((fm_pcd_port_params_t*)((t_FmPcdPlcrProfileParams*)param)->id.newParams.h_FmPort)->port_id].h_Dev;
+                        break;
+                    case (e_IOC_FM_PORT_TYPE_RX_10G):
+                        h_Port = p_LnxWrpFmDev->rxPorts[((fm_pcd_port_params_t*)((t_FmPcdPlcrProfileParams*)param)->id.newParams.h_FmPort)->port_id + FM_MAX_NUM_OF_1G_RX_PORTS].h_Dev;
+                        break;
+                    default:
+                        XX_Free(param);
+                        RETURN_ERROR(MINOR, E_INVALID_SELECTION, NO_MSG);
+                }
+
+                ((t_FmPcdPlcrProfileParams*)param)->id.newParams.h_FmPort = h_Port;
+            }
+
+            param->id = FM_PCD_PlcrSetProfile(p_LnxWrpFmDev->h_PcdDev, (t_FmPcdPlcrProfileParams*)param);
+            if (param->id && !copy_to_user((ioc_fm_pcd_plcr_profile_params_t *)arg, param, sizeof(ioc_fm_pcd_plcr_profile_params_t)))
+                err = E_OK;
+
+            XX_Free(param);
+            break;
+        }
+
+        case FM_PCD_IOC_PLCR_DEL_PROFILE:
+        {
+            ioc_fm_obj_t id;
+            if (copy_from_user(&id, (ioc_fm_obj_t *)arg, sizeof(ioc_fm_obj_t)))
+                break;
+            return FM_PCD_PlcrDeleteProfile(p_LnxWrpFmDev->h_PcdDev, id.obj);
+        }
+
+        case FM_PCD_IOC_CC_TREE_MODIFY_NEXT_ENGINE:
+        {
+            ioc_fm_pcd_cc_tree_modify_next_engine_params_t            *param;
+
+            param = (ioc_fm_pcd_cc_tree_modify_next_engine_params_t *)XX_Malloc(sizeof(ioc_fm_pcd_cc_tree_modify_next_engine_params_t));
+            if (!param)
+                RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
+
+            if (copy_from_user(param, (ioc_fm_pcd_cc_tree_modify_next_engine_params_t *)arg, sizeof(ioc_fm_pcd_cc_tree_modify_next_engine_params_t))) {
+                XX_Free(param);
+                RETURN_ERROR(MINOR, err, NO_MSG);
+            }
+
+            err = FM_PCD_CcTreeModifyNextEngine(p_LnxWrpFmDev->h_PcdDev,
+                                                param->id,
+                                                param->grp_indx,
+                                                param->indx,
+                                                (t_FmPcdCcNextEngineParams*)(&param->cc_next_engine_params));
+            XX_Free(param);
+            break;
+        }
+
+        case FM_PCD_IOC_CC_NODE_MODIFY_NEXT_ENGINE:
+        {
+            ioc_fm_pcd_cc_node_modify_next_engine_params_t            *param;
+
+            param = (ioc_fm_pcd_cc_node_modify_next_engine_params_t *)XX_Malloc(sizeof(ioc_fm_pcd_cc_node_modify_next_engine_params_t));
+            if (!param)
+                RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
+
+            if (copy_from_user(param, (ioc_fm_pcd_cc_node_modify_next_engine_params_t *)arg, sizeof(ioc_fm_pcd_cc_node_modify_next_engine_params_t))) {
+                XX_Free(param);
+                RETURN_ERROR(MINOR, err, NO_MSG);
+            }
+
+            err = FM_PCD_CcNodeModifyNextEngine(p_LnxWrpFmDev->h_PcdDev,
+                                                param->id,
+                                                param->key_indx,
+                                                (t_FmPcdCcNextEngineParams*)(&param->cc_next_engine_params));
+            XX_Free(param);
+            break;
+        }
+
+        case FM_PCD_IOC_CC_NODE_MODIFY_MISS_NEXT_ENGINE:
+        {
+            ioc_fm_pcd_cc_node_modify_next_engine_params_t            *param;
+
+            param = (ioc_fm_pcd_cc_node_modify_next_engine_params_t *)XX_Malloc(sizeof(ioc_fm_pcd_cc_node_modify_next_engine_params_t));
+            if (!param)
+                RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
+
+            if (copy_from_user(param, (ioc_fm_pcd_cc_node_modify_next_engine_params_t *)arg, sizeof(ioc_fm_pcd_cc_node_modify_next_engine_params_t))) {
+                XX_Free(param);
+                RETURN_ERROR(MINOR, err, NO_MSG);
+            }
+
+            err = FM_PCD_CcNodeModifyMissNextEngine(p_LnxWrpFmDev->h_PcdDev,
+                                                    param->id,
+                                                    (t_FmPcdCcNextEngineParams*)(&param->cc_next_engine_params));
+            XX_Free(param);
+            break;
+        }
+
+        case FM_PCD_IOC_CC_NODE_REMOVE_KEY:
+        {
+            ioc_fm_pcd_cc_node_remove_key_params_t            *param;
+
+            param = (ioc_fm_pcd_cc_node_remove_key_params_t *)XX_Malloc(sizeof(ioc_fm_pcd_cc_node_remove_key_params_t));
+            if (!param)
+                RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
+
+            if (copy_from_user(param, (ioc_fm_pcd_cc_node_remove_key_params_t *)arg, sizeof(ioc_fm_pcd_cc_node_remove_key_params_t))) {
+                XX_Free(param);
+                RETURN_ERROR(MINOR, err, NO_MSG);
+            }
+
+            err = FM_PCD_CcNodeRemoveKey(p_LnxWrpFmDev->h_PcdDev, param->id, param->key_indx);
+            XX_Free(param);
+            break;
+        }
+
+        case FM_PCD_IOC_CC_NODE_ADD_KEY:
+        {
+            ioc_fm_pcd_cc_node_modify_key_and_next_engine_params_t            *param;
+
+            param = (ioc_fm_pcd_cc_node_modify_key_and_next_engine_params_t *)XX_Malloc(sizeof(ioc_fm_pcd_cc_node_modify_key_and_next_engine_params_t));
+            if (!param)
+                RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
+
+            if (copy_from_user(param, (ioc_fm_pcd_cc_node_modify_key_and_next_engine_params_t *)arg, sizeof(ioc_fm_pcd_cc_node_modify_key_and_next_engine_params_t))) {
+                XX_Free(param);
+                RETURN_ERROR(MINOR, err, NO_MSG);
+            }
+
+            err = FM_PCD_CcNodeAddKey(p_LnxWrpFmDev->h_PcdDev,
+                                      param->id,
+                                      param->key_indx,
+                                      param->key_size,
+                                      (t_FmPcdCcKeyParams*)(&param->key_params));
+            XX_Free(param);
+            break;
+        }
+
+        case FM_PCD_IOC_CC_NODE_MODIFY_KEY_AND_NEXT_ENGINE:
+        {
+            ioc_fm_pcd_cc_node_modify_key_and_next_engine_params_t            *param;
+
+            param = (ioc_fm_pcd_cc_node_modify_key_and_next_engine_params_t *)XX_Malloc(sizeof(ioc_fm_pcd_cc_node_modify_key_and_next_engine_params_t));
+            if (!param)
+                RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
+
+            if (copy_from_user(param, (ioc_fm_pcd_cc_node_modify_key_and_next_engine_params_t *)arg, sizeof(ioc_fm_pcd_cc_node_modify_key_and_next_engine_params_t))) {
+                XX_Free(param);
+                RETURN_ERROR(MINOR, err, NO_MSG);
+            }
+
+            err = FM_PCD_CcNodeModifyKeyAndNextEngine(p_LnxWrpFmDev->h_PcdDev,
+                                                      param->id,
+                                                      param->key_indx,
+                                                      param->key_size,
+                                                      (t_FmPcdCcKeyParams*)(&param->key_params));
+            XX_Free(param);
+            break;
+        }
+
+        case FM_PCD_IOC_CC_NODE_MODIFY_KEY:
+        {
+            ioc_fm_pcd_cc_node_modify_key_params_t  *param;
+            uint8_t                                 *key;
+            uint8_t                                 *mask;
+
+            param = (ioc_fm_pcd_cc_node_modify_key_params_t *)XX_Malloc(sizeof(ioc_fm_pcd_cc_node_modify_key_params_t));
+            if (!param)
+                RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
+
+            if (copy_from_user(param, (ioc_fm_pcd_cc_node_modify_key_params_t *)arg, sizeof(ioc_fm_pcd_cc_node_modify_key_params_t))) {
+                XX_Free(param);
+                RETURN_ERROR(MINOR, err, NO_MSG);
+            }
+
+            if (param->p_key) {
+                key = (uint8_t *)XX_Malloc(sizeof(uint8_t)*IOC_FM_PCD_MAX_SIZE_OF_KEY);
+                if (!key) {
+                    XX_Free(param);
+                    RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD key"));
+                }
+                memset(key, 0, sizeof(uint8_t)*IOC_FM_PCD_MAX_SIZE_OF_KEY);
+
+                if (copy_from_user(key, param->p_key, param->key_size)) {
+                    XX_Free(key);
+                    XX_Free(param);
+                    RETURN_ERROR(MINOR, err, NO_MSG);
+                }
+                param->p_key = key;
+            }
+
+            if (param->p_mask) {
+                mask = (uint8_t *)XX_Malloc(sizeof(uint8_t)*IOC_FM_PCD_MAX_SIZE_OF_KEY);
+                if (!mask) {
+                    XX_Free(key);
+                    XX_Free(param);
+                    RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD mask"));
+                }
+                memset(mask, 0, sizeof(uint8_t)*IOC_FM_PCD_MAX_SIZE_OF_KEY);
+
+                if (copy_from_user(mask, param->p_mask, param->key_size)) {
+                    XX_Free(mask);
+                    XX_Free(key);
+                    XX_Free(param);
+                    RETURN_ERROR(MINOR, err, NO_MSG);
+                }
+                param->p_mask = mask;
+            }
+
+            err = FM_PCD_CcNodeModifyKey(p_LnxWrpFmDev->h_PcdDev,
+                                         param->id,
+                                         param->key_indx,
+                                         param->key_size,
+                                         param->p_key,
+                                         param->p_mask);
+            XX_Free(mask);
+            XX_Free(key);
+            XX_Free(param);
+            break;
+        }
+
+        default:
+            RETURN_ERROR(MINOR, E_INVALID_SELECTION, ("IOCTL cmd (0x%08x)!", cmd));
+    }
+
+    return err;
+}
+
+t_Error LnxwrpFmIOCTL(t_LnxWrpFmDev *p_LnxWrpFmDev, unsigned int cmd, unsigned long arg)
+{
+    t_Error err = E_READ_FAILED;
+
+    DBG(TRACE, ("p_LnxWrpFmDev - 0x%08x, cmd - 0x%08x, arg - 0x%08x", (uint32_t)p_LnxWrpFmDev, cmd, arg));
+
+    switch (cmd)
+    {
+        case FM_IOC_SET_PORTS_BANDWIDTH:
+        {
+            ioc_ports_param_t *param;
+
+            param = (ioc_ports_param_t *)XX_Malloc(sizeof(ioc_ports_param_t));
+            if (!param)
+                RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
+
+            if (copy_from_user(param, (ioc_ports_param_t *)arg, sizeof(ioc_ports_param_t)))
+            {
+                XX_Free(param);
+                return err;
+            }
+
+            err =  FM_SetPortsBandwidth(p_LnxWrpFmDev->h_Dev,(t_PortsParam*)param);
+            XX_Free(param);
+            return err;
+        }
+
+        case FM_IOC_GET_REVISION:
+        {
+            ioc_fm_revision_info_t *param;
+
+            param = (ioc_fm_revision_info_t *)XX_Malloc(sizeof(ioc_fm_revision_info_t));
+            if (!param)
+                RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
+
+            FM_GetRevision(p_LnxWrpFmDev->h_Dev, (t_FmRevisionInfo*)param);
+            if (copy_to_user((ioc_fm_revision_info_t *)arg, param, sizeof(ioc_fm_revision_info_t)))
+                err = E_WRITE_FAILED;
+            else
+                err = E_OK;
+
+            XX_Free(param);
+            return err;
+        }
+
+        case FM_IOC_SET_COUNTER:
+        {
+            ioc_fm_counters_params_t *param;
+
+            param = (ioc_fm_counters_params_t *)XX_Malloc(sizeof(ioc_fm_counters_params_t));
+            if (!param)
+                RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
+
+            if (copy_from_user(param, (ioc_fm_counters_params_t *)arg, sizeof(ioc_fm_counters_params_t)))
+            {
+                XX_Free(param);
+                return err;
+            }
+
+            err = FM_SetCounter(p_LnxWrpFmDev->h_Dev, param->cnt, param->val);
+
+            XX_Free(param);
+            return err;
+        }
+
+        case FM_IOC_GET_COUNTER:
+        {
+            ioc_fm_counters_params_t *param;
+
+            param = (ioc_fm_counters_params_t *)XX_Malloc(sizeof(ioc_fm_counters_params_t));
+            if (!param)
+                RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
+
+            if (copy_from_user(param, (ioc_fm_counters_params_t *)arg, sizeof(ioc_fm_counters_params_t)))
+            {
+                XX_Free(param);
+                return err;
+            }
+
+            param->val = FM_GetCounter(p_LnxWrpFmDev->h_Dev, param->cnt);
+            if (copy_to_user((ioc_fm_counters_params_t *)arg, param, sizeof(ioc_fm_counters_params_t)))
+                err = E_WRITE_FAILED;
+
+            XX_Free(param);
+            return err;
+        }
+
+        case FM_IOC_FORCE_INTR:
+        {
+            ioc_fm_exceptions param;
+
+            if (get_user(param, (ioc_fm_exceptions*)arg))
+                break;
+            return FM_ForceIntr(p_LnxWrpFmDev->h_Dev, (e_FmExceptions)param);
+        }
+
+        default:
+            return LnxwrpFmPcdIOCTL(p_LnxWrpFmDev, cmd, arg);
+    }
+
+    RETURN_ERROR(MINOR, E_INVALID_OPERATION, ("IOCTL FM"));
+}
+
+t_Error LnxwrpFmPortIOCTL(t_LnxWrpFmPortDev *p_LnxWrpFmPortDev, unsigned int cmd, unsigned long arg)
+{
+    t_Error err = E_READ_FAILED;
+    DBG(TRACE, ("p_LnxWrpFmPortDev - 0x%08x, cmd - 0x%08x, arg - 0x%08x", (uint32_t)p_LnxWrpFmPortDev, cmd, arg));
+
+    switch (cmd)
+    {
+        case FM_PORT_IOC_DISABLE:
+            FM_PORT_Disable(p_LnxWrpFmPortDev->h_Dev);
+            return E_OK;
+        case FM_PORT_IOC_ENABLE:
+            FM_PORT_Enable(p_LnxWrpFmPortDev->h_Dev);
+            return E_OK;
+
+        case FM_PORT_IOC_SET_ERRORS_ROUTE:
+        {
+            int errs;
+            if (get_user(errs, (int *)arg))
+                break;
+            return FM_PORT_SetErrorsRoute(p_LnxWrpFmPortDev->h_Dev, (fmPortFrameErrSelect_t)errs);
+        }
+
+        case FM_PORT_IOC_ALLOC_PCD_FQIDS:
+        {
+            ioc_fm_port_pcd_fqids_params_t        *param;
+
+            param = (ioc_fm_port_pcd_fqids_params_t *)XX_Malloc(sizeof(ioc_fm_port_pcd_fqids_params_t));
+            if (!param)
+                RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PORT"));
+
+            if (copy_from_user(param, (ioc_fm_port_pcd_fqids_params_t *)arg, sizeof(ioc_fm_port_pcd_fqids_params_t)))
+            {
+                XX_Free(param);
+                return err;
+            }
+
+            if (!p_LnxWrpFmPortDev->pcd_owner_params.cb)
+                RETURN_ERROR(MINOR, E_INVALID_STATE, ("No one to listen on this PCD!!!"));
+
+            if (p_LnxWrpFmPortDev->pcd_owner_params.cb (p_LnxWrpFmPortDev->pcd_owner_params.dev,
+                                                        param->num_fqids,
+                                                        param->alignment,
+                                                        &param->base_fqid))
+                RETURN_ERROR(MINOR, E_INVALID_STATE, ("can't allocate fqids for PCD!!!"));
+
+            if (copy_to_user((ioc_fm_port_pcd_fqids_params_t *)arg, param, sizeof(ioc_fm_port_pcd_fqids_params_t)))
+            {
+                XX_Free(param);
+                RETURN_ERROR(MAJOR, E_WRITE_FAILED, NO_MSG);
+            }
+
+            XX_Free(param);
+            return E_OK;
+        }
+
+        case FM_PORT_IOC_SET_PCD:
+        {
+            ioc_fm_port_pcd_params_t        *port_pcd_params;
+            ioc_fm_port_pcd_prs_params_t    *port_pcd_prs_params;
+            ioc_fm_port_pcd_cc_params_t     *port_pcd_cc_params;
+            ioc_fm_port_pcd_kg_params_t     *port_pcd_kg_params;
+            ioc_fm_port_pcd_plcr_params_t   *port_pcd_plcr_params;
+            uint8_t                         copy_fail = 0;
+
+            if ((port_pcd_params = (ioc_fm_port_pcd_params_t *)XX_Malloc(sizeof(ioc_fm_port_pcd_params_t)))) {
+                if ((port_pcd_prs_params = (ioc_fm_port_pcd_prs_params_t *)XX_Malloc(sizeof(ioc_fm_port_pcd_prs_params_t)))) {
+                    if ((port_pcd_cc_params = (ioc_fm_port_pcd_cc_params_t *)XX_Malloc(sizeof(ioc_fm_port_pcd_cc_params_t)))) {
+                        if ((port_pcd_kg_params = (ioc_fm_port_pcd_kg_params_t *)XX_Malloc(sizeof(ioc_fm_port_pcd_kg_params_t)))) {
+                            port_pcd_plcr_params = (ioc_fm_port_pcd_plcr_params_t *)XX_Malloc(sizeof(ioc_fm_port_pcd_plcr_params_t));
+                            if (!port_pcd_plcr_params) {
+                                XX_Free(port_pcd_params);
+                                XX_Free(port_pcd_prs_params);
+                                XX_Free(port_pcd_cc_params);
+                                XX_Free(port_pcd_kg_params);
+                                RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PORT"));
+                            }
+                        }
+                        else {
+                            XX_Free(port_pcd_params);
+                            XX_Free(port_pcd_prs_params);
+                            XX_Free(port_pcd_cc_params);
+                            RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PORT"));
+                        }
+                    }
+                    else {
+                        XX_Free(port_pcd_params);
+                        XX_Free(port_pcd_prs_params);
+                        RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PORT"));
+                    }
+                }
+                else {
+                    XX_Free(port_pcd_params);
+                    RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PORT"));
+                }
+            }
+            else
+                RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PORT"));
+
+            copy_fail = 0;
+            if (copy_from_user(port_pcd_params, (ioc_fm_port_pcd_params_t *)arg, sizeof(ioc_fm_port_pcd_params_t)))
+                copy_fail = 1;
+            if (port_pcd_params->p_prs_params && !copy_fail)
+            {
+                if (copy_from_user(port_pcd_prs_params,
+                                    port_pcd_params->p_prs_params,
+                                    sizeof(ioc_fm_port_pcd_prs_params_t)))
+                  copy_fail = 1;
+                else
+                  port_pcd_params->p_prs_params = port_pcd_prs_params;
+            }
+            if (port_pcd_params->p_cc_params && !copy_fail)
+            {
+                if (copy_from_user(port_pcd_cc_params,
+                                    port_pcd_params->p_cc_params,
+                                    sizeof(ioc_fm_port_pcd_cc_params_t)))
+                  copy_fail = 1;
+                else
+                  port_pcd_params->p_cc_params = port_pcd_cc_params;
+            }
+            if (port_pcd_params->p_kg_params && !copy_fail)
+            {
+                if (copy_from_user(port_pcd_kg_params,
+                                    port_pcd_params->p_kg_params,
+                                    sizeof(ioc_fm_port_pcd_kg_params_t)))
+                  copy_fail = 1;
+                else
+                  port_pcd_params->p_kg_params = port_pcd_kg_params;
+            }
+            if (port_pcd_params->p_plcr_params && !copy_fail)
+            {
+                if (copy_from_user(port_pcd_plcr_params,
+                                    port_pcd_params->p_plcr_params,
+                                    sizeof(ioc_fm_port_pcd_plcr_params_t)))
+                  copy_fail = 1;
+                else
+                  port_pcd_params->p_plcr_params = port_pcd_plcr_params;
+            }
+            if (!copy_fail)
+               err = FM_PORT_SetPCD(p_LnxWrpFmPortDev->h_Dev, (t_FmPortPcdParams *)port_pcd_params);
+            else
+               err = E_READ_FAILED;
+
+            XX_Free(port_pcd_params);
+            XX_Free(port_pcd_prs_params);
+            XX_Free(port_pcd_cc_params);
+            XX_Free(port_pcd_kg_params);
+            XX_Free(port_pcd_plcr_params);
+            return err;
+        }
+
+        case FM_PORT_IOC_DELETE_PCD:
+            return FM_PORT_DeletePCD(p_LnxWrpFmPortDev->h_Dev);
+
+        case FM_PORT_IOC_PCD_KG_MODIFY_INITIAL_SCHEME:
+        {
+            ioc_fm_pcd_kg_scheme_select_t        *param;
+
+            param = (ioc_fm_pcd_kg_scheme_select_t *)XX_Malloc(sizeof(ioc_fm_pcd_kg_scheme_select_t));
+            if (!param)
+                RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PORT"));
+
+            if (copy_from_user(param, (ioc_fm_pcd_kg_scheme_select_t *)arg, sizeof(ioc_fm_pcd_kg_scheme_select_t)))
+            {
+                XX_Free(param);
+                RETURN_ERROR(MAJOR, E_READ_FAILED, NO_MSG);
+            }
+
+            err =  FM_PORT_PcdKgModifyInitialScheme(p_LnxWrpFmPortDev->h_Dev, (t_FmPcdKgSchemeSelect *)param);
+
+            XX_Free(param);
+            return err;
+        }
+
+        case FM_PORT_IOC_PCD_PLCR_MODIFY_INITIAL_PROFILE:
+        {
+            ioc_fm_obj_t id;
+            if (copy_from_user(&id, (ioc_fm_obj_t *)arg, sizeof(ioc_fm_obj_t)))
+                break;
+            return FM_PORT_PcdPlcrModifyInitialProfile(p_LnxWrpFmPortDev->h_Dev, id.obj);
+        }
+
+        case FM_PORT_IOC_PCD_KG_BIND_SCHEMES:
+        {
+            ioc_fm_pcd_port_schemes_params_t        *param;
+
+            param = (ioc_fm_pcd_port_schemes_params_t *)XX_Malloc(sizeof(ioc_fm_pcd_port_schemes_params_t));
+            if (!param)
+                RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PORT"));
+
+            if (copy_from_user(param, (ioc_fm_pcd_port_schemes_params_t *)arg, sizeof(ioc_fm_pcd_port_schemes_params_t)))
+            {
+                XX_Free(param);
+                RETURN_ERROR(MAJOR, E_WRITE_FAILED, NO_MSG);
+            }
+
+            err = FM_PORT_PcdKgBindSchemes(p_LnxWrpFmPortDev->h_Dev, (t_FmPcdPortSchemesParams *)param);
+
+            XX_Free(param);
+            return err;
+        }
+
+        case FM_PORT_IOC_PCD_KG_UNBIND_SCHEMES:
+        {
+            ioc_fm_pcd_port_schemes_params_t        *param;
+
+            param = (ioc_fm_pcd_port_schemes_params_t *)XX_Malloc(sizeof(ioc_fm_pcd_port_schemes_params_t));
+            if (!param)
+                RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PORT"));
+
+            if (copy_from_user(param, (ioc_fm_pcd_port_schemes_params_t *)arg, sizeof(ioc_fm_pcd_port_schemes_params_t)))
+            {
+                XX_Free(param);
+                RETURN_ERROR(MAJOR, E_WRITE_FAILED, NO_MSG);
+            }
+
+            err =  FM_PORT_PcdKgUnbindSchemes(p_LnxWrpFmPortDev->h_Dev, (t_FmPcdPortSchemesParams *)param);
+
+            XX_Free(param);
+            return err;
+        }
+
+        case FM_PORT_IOC_PCD_PRS_MODIFY_START_OFFSET:
+        {
+            ioc_fm_pcd_prs_start_t        *param;
+
+            param = (ioc_fm_pcd_prs_start_t *)XX_Malloc(sizeof(ioc_fm_pcd_prs_start_t));
+            if (!param)
+                RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PORT"));
+
+            if (copy_from_user(param, (ioc_fm_pcd_prs_start_t *)arg, sizeof(ioc_fm_pcd_prs_start_t)))
+            {
+                XX_Free(param);
+                RETURN_ERROR(MAJOR, E_WRITE_FAILED, NO_MSG);
+            }
+            err = FM_PORT_PcdPrsModifyStartOffset(p_LnxWrpFmPortDev->h_Dev, (t_FmPcdPrsStart *)param);
+
+            XX_Free(param);
+            return err;
+        }
+
+        case FM_PORT_IOC_PCD_PLCR_ALLOC_PROFILES:
+        {
+            int num;
+            if (get_user(num, (int *)arg))
+                break;
+            return FM_PORT_PcdPlcrAllocProfiles(p_LnxWrpFmPortDev->h_Dev, (uint16_t)num);
+        }
+        case FM_PORT_IOC_PCD_PLCR_FREE_PROFILES:
+            return FM_PORT_PcdPlcrFreeProfiles(p_LnxWrpFmPortDev->h_Dev);
+
+        case FM_PORT_IOC_DETACH_PCD:
+            return FM_PORT_DetachPCD(p_LnxWrpFmPortDev->h_Dev);
+
+        case FM_PORT_IOC_ATTACH_PCD:
+            return FM_PORT_AttachPCD(p_LnxWrpFmPortDev->h_Dev);
+
+        case FM_PORT_IOC_PCD_KG_MODIFY_CLS_PLAN_GRP:
+        {
+            ioc_fm_pcd_port_cls_plan_params_t        *param;
+
+            param = (ioc_fm_pcd_port_cls_plan_params_t *)XX_Malloc(sizeof(ioc_fm_pcd_port_cls_plan_params_t));
+            if (!param)
+                RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PORT"));
+
+            if (copy_from_user(param, (ioc_fm_pcd_port_cls_plan_params_t *)arg, sizeof(ioc_fm_pcd_port_cls_plan_params_t)))
+            {
+                XX_Free(param);
+                RETURN_ERROR(MAJOR, E_WRITE_FAILED, NO_MSG);
+            }
+            err = FM_PORT_PcdKgModifyClsPlanGrp (p_LnxWrpFmPortDev->h_Dev,
+                                                 param->use_cls_plan,
+                                                 param->new_cls_plan_grp);
+
+            XX_Free(param);
+            return err;
+        }
+
+        case FM_PORT_IOC_PCD_CC_MODIFY_TREE:
+        {
+            ioc_fm_obj_t id;
+            if (copy_from_user(&id, (ioc_fm_obj_t *)arg, sizeof(ioc_fm_obj_t)))
+                break;
+            return FM_PORT_PcdCcModifyTree(p_LnxWrpFmPortDev->h_Dev, id.obj);
+        }
+
+        default:
+            RETURN_ERROR(MINOR, E_INVALID_SELECTION, ("IOCTL port cmd!"));
+    }
+
+    RETURN_ERROR(MINOR, E_INVALID_OPERATION, ("IOCTL port"));
+}
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/xx/Makefile b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/xx/Makefile
new file mode 100644
index 0000000..96cd972
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/xx/Makefile
@@ -0,0 +1,17 @@
+#
+# Makefile for the Freescale Ethernet controllers
+#
+EXTRA_CFLAGS           += -DVERSION=\"\"
+#
+#Include netcomm SW specific definitions
+include $(srctree)/drivers/net/dpa/NetCommSw/ncsw_config.mk
+
+obj-y		+= fsl-ncsw-xx.o
+
+fsl-ncsw-xx-objs	:=   xx_linux.o udivdi3.o stdlib.o
+# ctype.o
+
+obj-y		+= integrations/
+
+
+
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/xx/ctype.c b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/xx/ctype.c
new file mode 100644
index 0000000..96c73e2
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/xx/ctype.c
@@ -0,0 +1,67 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**************************************************************************//**
+ @File          ctype.c
+
+ @Description   ...
+*//***************************************************************************/
+#include "stdlib_ext.h"
+#include "ctype_ext.h"
+
+
+unsigned char _ctype[] = {
+    _C,_C,_C,_C,_C,_C,_C,_C,                    /* 0-7     */
+    _C,_C|_S,_C|_S,_C|_S,_C|_S,_C|_S,_C,_C,     /* 8-15    */
+    _C,_C,_C,_C,_C,_C,_C,_C,                    /* 16-23   */
+    _C,_C,_C,_C,_C,_C,_C,_C,                    /* 24-31   */
+    _S|_SP,_P,_P,_P,_P,_P,_P,_P,                /* 32-39   */
+    _P,_P,_P,_P,_P,_P,_P,_P,                    /* 40-47   */
+    _D,_D,_D,_D,_D,_D,_D,_D,                    /* 48-55   */
+    _D,_D,_P,_P,_P,_P,_P,_P,                    /* 56-63   */
+    _P,_U|_X,_U|_X,_U|_X,_U|_X,_U|_X,_U|_X,_U,  /* 64-71   */
+    _U,_U,_U,_U,_U,_U,_U,_U,                    /* 72-79   */
+    _U,_U,_U,_U,_U,_U,_U,_U,                    /* 80-87   */
+    _U,_U,_U,_P,_P,_P,_P,_P,                    /* 88-95   */
+    _P,_L|_X,_L|_X,_L|_X,_L|_X,_L|_X,_L|_X,_L,  /* 96-103  */
+    _L,_L,_L,_L,_L,_L,_L,_L,                    /* 104-111 */
+    _L,_L,_L,_L,_L,_L,_L,_L,                    /* 112-119 */
+    _L,_L,_L,_P,_P,_P,_P,_C,                    /* 120-127 */
+    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,            /* 128-143 */
+    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,            /* 144-159 */
+    _S|_SP,_P,_P,_P,_P,_P,_P,_P,_P,_P,_P,_P,_P,_P,_P,_P,    /* 160-175 */
+    _P,_P,_P,_P,_P,_P,_P,_P,_P,_P,_P,_P,_P,_P,_P,_P,        /* 176-191 */
+    _U,_U,_U,_U,_U,_U,_U,_U,_U,_U,_U,_U,_U,_U,_U,_U,        /* 192-207 */
+    _U,_U,_U,_U,_U,_U,_U,_P,_U,_U,_U,_U,_U,_U,_U,_L,        /* 208-223 */
+    _L,_L,_L,_L,_L,_L,_L,_L,_L,_L,_L,_L,_L,_L,_L,_L,        /* 224-239 */
+    _L,_L,_L,_L,_L,_L,_L,_P,_L,_L,_L,_L,_L,_L,_L,_L         /* 240-255 */
+};
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/xx/integrations/Makefile b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/xx/integrations/Makefile
new file mode 100644
index 0000000..e961908
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/xx/integrations/Makefile
@@ -0,0 +1,9 @@
+#
+# Makefile for the Freescale Ethernet controllers
+#
+EXTRA_CFLAGS           += -DVERSION=\"\"
+#
+#Include netcomm SW specific definitions
+include $(srctree)/drivers/net/dpa/NetCommSw/ncsw_config.mk
+#
+obj-y		+= P4080/
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/xx/integrations/P4080/Makefile b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/xx/integrations/P4080/Makefile
new file mode 100644
index 0000000..76f148d
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/xx/integrations/P4080/Makefile
@@ -0,0 +1,13 @@
+#
+# Makefile for the Freescale Ethernet controllers
+#
+EXTRA_CFLAGS           += -DVERSION=\"\"
+#
+#Include netcomm SW specific definitions
+include $(srctree)/drivers/net/dpa/NetCommSw/ncsw_config.mk
+
+EXTRA_CFLAGS += -I$(NCSW)/user/env/linux/kernel/2.6/xx
+
+obj-y		+= xx_integration.o
+
+
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/xx/integrations/P4080/xx_integration.c b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/xx/integrations/P4080/xx_integration.c
new file mode 100644
index 0000000..2881292
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/xx/integrations/P4080/xx_integration.c
@@ -0,0 +1,165 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**************************************************************************//**
+ @File          xx_integration.c
+
+ @Description   XX routines implementation for Linux.
+*//***************************************************************************/
+#include <linux/version.h>
+
+#if defined(CONFIG_MODVERSIONS) && !defined(MODVERSIONS)
+#define MODVERSIONS
+#endif
+#ifdef MODVERSIONS
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+#include <linux/modversions.h>
+#else
+#include <config/modversions.h>
+#endif    /* LINUX_VERSION_CODE */
+#endif /* MODVERSIONS */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/ptrace.h>
+#include <linux/errno.h>
+#include <linux/ioport.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/fs.h>
+#include <linux/vmalloc.h>
+#include <linux/init.h>
+#include <linux/timer.h>
+#include <linux/spinlock.h>
+#include <linux/delay.h>
+#include <linux/proc_fs.h>
+#include <linux/smp_lock.h>
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+#include <linux/tqueue.h>
+#else
+#include <linux/workqueue.h>
+#endif    /* LINUX_VERSION_CODE */
+
+#ifdef BIGPHYSAREA_ENABLE
+#include <linux/bigphysarea.h>
+#endif /* BIGPHYSAREA_ENABLE */
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,18)
+#include <asm/of_device.h>
+#include <sysdev/fsl_soc.h>
+#endif    /* LINUX_VERSION_CODE */
+#include <asm/pgtable.h>
+#include <asm/irq.h>
+#include <asm/bitops.h>
+#include <asm/uaccess.h>
+#include <asm/system.h>
+#include <asm/io.h>
+#include <asm/atomic.h>
+#include <asm/string.h>
+#include <asm/byteorder.h>
+#include <asm/page.h>
+
+#include "error_ext.h"
+#include "std_ext.h"
+#include "mem_ext.h"
+#include "list_ext.h"
+#include "mm_ext.h"
+#include "sys_io_ext.h"
+#include "platform_ext.h"
+
+#include "xx.h"
+
+
+#define __ERR_MODULE__      MODULE_UNKNOWN
+
+void * XX_GetMemPartitionBase(int memPartitionId)
+{
+    switch(memPartitionId)
+    {
+        case(0):
+        case(e_MEM_1ST_DDR_CACHEABLE):
+            return phys_to_virt(0);
+            break;
+        default:
+            REPORT_ERROR(MINOR, E_INVALID_VALUE, ("Memory type!"));
+            return CAST_UINT32_TO_POINTER(ILLEGAL_BASE);
+    }
+    return CAST_UINT32_TO_POINTER(ILLEGAL_BASE);
+}
+
+char * GetDeviceName(int irq)
+{
+    switch (irq)
+    {
+//        case e_DUART1_INTR:
+//            return "NCSW_DUART1";
+        default:
+            return NULL;
+    }
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,22)
+int GetDeviceIrqNum(int irq)
+{
+    struct device_node  *iPar;
+    struct irq_host     *irqHost;
+    uint32_t            hwIrq;
+
+    /* Get the interrupt controller */
+    iPar = of_find_node_by_name(NULL, "mpic");
+    hwIrq = 0;
+
+    ASSERT_COND(iPar != NULL);
+    /* Get the irq host */
+    irqHost = irq_find_host(iPar);
+    of_node_put(iPar);
+
+    /* Create irq mapping */
+    return irq_create_mapping(irqHost, hwIrq);
+}
+#else
+#error "kernel not supported!!!"
+#endif    /* LINUX_VERSION_CODE */
+
+
+void * XX_PhysToVirt(void * addr)
+{
+    return CAST_UINT64_TO_POINTER(SYS_PhysToVirt(CAST_POINTER_TO_UINT64(addr)));
+}
+
+void * XX_VirtToPhys(void * addr)
+{
+    return CAST_UINT64_TO_POINTER(SYS_VirtToPhys(CAST_POINTER_TO_UINT64(addr)));
+}
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/xx/stdlib.c b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/xx/stdlib.c
new file mode 100644
index 0000000..3c0730a
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/xx/stdlib.c
@@ -0,0 +1,264 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/*------------------------------------------------------*/
+/*                                                      */
+/* File: stdlib.c                                       */
+/*                                                      */
+/* Description:                                         */
+/*    Standard library routines (externals)             */
+/*                                                      */
+/* Modifications:                                       */
+/* ==============                                       */
+/*                                                      */
+/*------------------------------------------------------*/
+#include "stdlib_ext.h"
+#include "stdarg_ext.h"
+#include "ctype_ext.h"
+#include "string_ext.h"
+#include "std_ext.h"
+#include "xx_ext.h"
+
+
+#ifdef MODULE
+/**
+ * strtoul - convert a string to an uint32_t
+ * @cp: The start of the string
+ * @endp: A pointer to the end of the parsed string will be placed here
+ * @base: The number base to use
+ */
+uint32_t strtoul(const char *cp,char **endp,uint32_t base)
+{
+    uint32_t result = 0,value;
+
+    if (!base) {
+        base = 10;
+        if (*cp == '0') {
+            base = 8;
+            cp++;
+            if ((*cp == 'x') && isxdigit(cp[1])) {
+                cp++;
+                base = 16;
+            }
+        }
+    }
+    while (isxdigit(*cp) &&
+           (value = (uint32_t)(isdigit(*cp) ? *cp-'0' : toupper((uint8_t)(*cp))-'A'+10)) < base) {
+        result = result*base + value;
+        cp++;
+    }
+    if (endp)
+        *endp = (char *)cp;
+    return result;
+}
+
+/**
+ * strtol - convert a string to a int32_t
+ * @cp: The start of the string
+ * @endp: A pointer to the end of the parsed string will be placed here
+ * @base: The number base to use
+ */
+long strtol(const char *cp,char **endp,uint32_t base)
+{
+    if(*cp=='-')
+        return (long)(-strtoul(cp+1,endp,base));
+    return (long)strtoul(cp,endp,base);
+}
+
+/**
+ * strtoull - convert a string to an uint64_t
+ * @cp: The start of the string
+ * @endp: A pointer to the end of the parsed string will be placed here
+ * @base: The number base to use
+ */
+uint64_t strtoull(const char *cp,char **endp,uint32_t base)
+{
+    uint64_t result = 0,value;
+
+    if (!base) {
+        base = 10;
+        if (*cp == '0') {
+            base = 8;
+            cp++;
+            if ((*cp == 'x') && isxdigit(cp[1])) {
+                cp++;
+                base = 16;
+            }
+        }
+    }
+    while (isxdigit(*cp) && (value = isdigit(*cp) ? *cp-'0' : (islower(*cp)
+        ? toupper((uint8_t)(*cp)) : *cp)-'A'+10) < base) {
+        result = result*base + value;
+        cp++;
+    }
+    if (endp)
+        *endp = (char *)cp;
+    return result;
+}
+
+/**
+ * strtoll - convert a string to a int64
+ * @cp: The start of the string
+ * @endp: A pointer to the end of the parsed string will be placed here
+ * @base: The number base to use
+ */
+long long strtoll(const char *cp,char **endp,uint32_t base)
+{
+    if(*cp=='-')
+        return (long long)(-strtoull(cp+1,endp,base));
+    return (long long)(strtoull(cp,endp,base));
+}
+
+/**
+ * atoi - convert a string to a int
+ * @s: The start of the string
+ */
+int atoi(const char *s)
+{
+    int i=0;
+    const char **tmp_s = &s;
+
+    while (isdigit(**tmp_s))
+        i = i*10 + *((*tmp_s)++) - '0';
+    return i;
+}
+
+/**
+ * strlen - Find the length of a string
+ * @s: The string to be sized
+ */
+size_t strlen(const char * s)
+{
+    const char *sc;
+
+    for (sc = s; *sc != '\0'; ++sc)
+        /* nothing */;
+
+    return sc - s;
+}
+
+/**
+ * strnlen - Find the length of a length-limited string
+ * @s: The string to be sized
+ * @count: The maximum number of bytes to search
+ */
+size_t strnlen(const char * s, size_t count)
+{
+    const char *sc;
+
+    for (sc = s; count-- && *sc != '\0'; ++sc)
+        /* nothing */;
+
+    return sc - s;
+}
+
+/**
+ * strcpy - Copy a %NUL terminated string
+ * @dest: Where to copy the string to
+ * @src: Where to copy the string from
+ */
+char * strcpy(char * dest,const char *src)
+{
+    char *tmp = dest;
+
+    while ((*dest++ = *src++) != '\0')
+        /* nothing */;
+
+    return tmp;
+}
+#endif /* MODULE */
+
+/**
+ * strtok - Split a string into tokens
+ * @s: The string to be searched
+ * @ct: The characters to search for
+ *
+ * WARNING: strtok is deprecated, use strsep instead.
+ */
+char *___strtok;
+
+char * strtok(char * s,const char * ct)
+{
+    char *sbegin, *send;
+
+    sbegin  = s ? s : ___strtok;
+    if (!sbegin) {
+        return NULL;
+    }
+    sbegin += strspn(sbegin,ct);
+    if (*sbegin == '\0') {
+        ___strtok = NULL;
+        return( NULL );
+    }
+    send = strpbrk( sbegin, ct);
+    if (send && *send != '\0')
+        *send++ = '\0';
+    ___strtok = send;
+    return (sbegin);
+}
+
+
+#ifdef MODULE
+/**
+ * strncpy - Copy a length-limited, %NUL-terminated string
+ * @dest: Where to copy the string to
+ * @src: Where to copy the string from
+ * @count: The maximum number of bytes to copy
+ *
+ * Note that unlike userspace strncpy, this does not %NUL-pad the buffer.
+ * However, the result is not %NUL-terminated if the source exceeds
+ * @count bytes.
+ */
+char * strncpy(char * dest,const char *src,size_t count)
+{
+    char *tmp = dest;
+
+    while (count-- && (*dest++ = *src++) != '\0')
+        /* nothing */;
+
+    return tmp;
+}
+
+/**
+ * vsprintf - Format a string and place it in a buffer
+ * @buf: The buffer to place the result into
+ * @fmt: The format string to use
+ * @args: Arguments for the format string
+ *
+ * Call this function if you are already dealing with a va_list.
+ * You probably want sprintf instead.
+ */
+int vsprintf(char *buf, const char *fmt, va_list args)
+{
+    return vsnprintf(buf, INT32_MAX, fmt, args);
+}
+#endif /* MODULE */
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/xx/udivdi3.c b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/xx/udivdi3.c
new file mode 100644
index 0000000..ca2fd17
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/xx/udivdi3.c
@@ -0,0 +1,132 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <linux/version.h>
+
+#if defined(CONFIG_MODVERSIONS) && !defined(MODVERSIONS)
+#define MODVERSIONS
+#endif
+#ifdef MODVERSIONS
+#include <config/modversions.h>
+#endif /* MODVERSIONS */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <asm/div64.h>
+
+
+#define BITS_PER_UNIT  8
+#define SI_TYPE_SIZE (sizeof (SItype) * BITS_PER_UNIT)
+
+
+typedef unsigned int UQItype    __attribute__ ((mode (QI)));
+typedef          int SItype     __attribute__ ((mode (SI)));
+typedef unsigned int USItype    __attribute__ ((mode (SI)));
+typedef          int DItype     __attribute__ ((mode (DI)));
+typedef          int word_type  __attribute__ ((mode (__word__)));
+typedef unsigned int UDItype    __attribute__ ((mode (DI)));
+
+struct DIstruct {SItype low, high;};
+
+typedef union
+{
+  struct DIstruct s;
+  DItype ll;
+} DIunion;
+
+
+/* bit divisor, dividend and result. dynamic precision */
+static __inline__ uint64_t _div64_64(uint64_t dividend, uint64_t divisor)
+{
+    uint32_t d = divisor;
+
+    if (divisor > 0xffffffffULL)
+    {
+        unsigned int shift = fls(divisor >> 32);
+
+        d = divisor >> shift;
+        dividend >>= shift;
+    }
+
+    /* avoid 64 bit division if possible */
+    if (dividend >> 32)
+        do_div(dividend, d);
+    else
+        dividend = (uint32_t) dividend / d;
+
+    return dividend;
+}
+
+UDItype __udivdi3 (UDItype n, UDItype d)
+{
+  return _div64_64(n, d);
+}
+
+DItype __divdi3 (DItype n, DItype d)
+{
+  DItype sign = 1;
+  if (n<0)
+  {
+    sign *= -1;
+    n *= -1;
+  }
+  if (d<0)
+  {
+    sign *= -1;
+    d *= -1;
+  }
+  return sign*_div64_64((UDItype)n, (UDItype)d);
+}
+
+UDItype __umoddi3 (UDItype n, UDItype d)
+{
+  return n-(_div64_64(n, d)*d);
+}
+
+#ifdef MODULE
+word_type __ucmpdi2 (DItype a, DItype b)
+{
+  DIunion au, bu;
+
+  au.ll = a, bu.ll = b;
+
+  if ((USItype) au.s.high < (USItype) bu.s.high)
+    return 0;
+  else if ((USItype) au.s.high > (USItype) bu.s.high)
+    return 2;
+  if ((USItype) au.s.low < (USItype) bu.s.low)
+    return 0;
+  else if ((USItype) au.s.low > (USItype) bu.s.low)
+    return 2;
+  return 1;
+}
+#endif /* MODULE */
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/xx/xx.h b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/xx/xx.h
new file mode 100644
index 0000000..fbe65dd
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/xx/xx.h
@@ -0,0 +1,43 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __XX_H
+#define __XX_H
+
+#include "xx_ext.h"
+
+
+char  * GetDeviceName(int irq);
+int     GetDeviceIrqNum(int irq);
+
+
+#endif /* __XX_H */
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/xx/xx_linux.c b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/xx/xx_linux.c
new file mode 100644
index 0000000..cacee0f
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/xx/xx_linux.c
@@ -0,0 +1,924 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**************************************************************************//**
+ @File          xx_linux.c
+
+ @Description   XX routines implementation for Linux.
+*//***************************************************************************/
+#include <linux/version.h>
+
+#if defined(CONFIG_MODVERSIONS) && !defined(MODVERSIONS)
+#define MODVERSIONS
+#endif
+#ifdef MODVERSIONS
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+#include <linux/modversions.h>
+#else
+#include <config/modversions.h>
+#endif    /* LINUX_VERSION_CODE */
+#endif /* MODVERSIONS */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/ptrace.h>
+#include <linux/errno.h>
+#include <linux/ioport.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/fs.h>
+#include <linux/vmalloc.h>
+#include <linux/init.h>
+#include <linux/timer.h>
+#include <linux/spinlock.h>
+#include <linux/delay.h>
+#include <linux/proc_fs.h>
+#include <linux/smp.h>
+#include <linux/smp_lock.h>
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+#include <linux/tqueue.h>
+#else
+#include <linux/workqueue.h>
+#endif    /* LINUX_VERSION_CODE */
+
+#ifdef BIGPHYSAREA_ENABLE
+#include <linux/bigphysarea.h>
+#endif /* BIGPHYSAREA_ENABLE */
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,18)
+#include <asm/of_device.h>
+#include <sysdev/fsl_soc.h>
+#endif    /* LINUX_VERSION_CODE */
+#include <asm/pgtable.h>
+#include <asm/irq.h>
+#include <asm/bitops.h>
+#include <asm/uaccess.h>
+#include <asm/system.h>
+#include <asm/io.h>
+#include <asm/atomic.h>
+#include <asm/string.h>
+#include <asm/byteorder.h>
+#include <asm/page.h>
+
+#include "error_ext.h"
+#include "std_ext.h"
+#include "mem_ext.h"
+#include "list_ext.h"
+#include "mm_ext.h"
+#include "platform_ext.h"
+
+#include "xx.h"
+
+
+#define __ERR_MODULE__      MODULE_UNKNOWN
+
+#ifdef BIGPHYSAREA_ENABLE
+#define MAX_ALLOCATION_SIZE     128 * 1024 /* Maximum size allocated with kmalloc is 128K */
+
+
+/* FIXME: large allocations => use big phys area */
+/******************************************************************************
+ * routine:     get_nr_pages
+ *
+ * description:
+ *     calculates the number of memory pages for a given size (in bytes)
+ *
+ * arguments:
+ *     size       - the number of bytes
+ *
+ * return code:
+ *     The number of pages
+ *
+ *****************************************************************************/
+static __inline__ uint32_t get_nr_pages (uint32_t size)
+{
+    return (uint32_t)((size >> PAGE_SHIFT) + (size & PAGE_SHIFT ? 1 : 0));
+}
+
+static bool in_big_phys_area (uint32_t addr)
+{
+    uint32_t base, size;
+
+    bigphysarea_get_details (&base, &size);
+    return ((addr >= base) && (addr < base + size));
+}
+#endif /* BIGPHYSAREA_ENABLE */
+
+static void * xx_Malloc(uint32_t n)
+{
+    void        *a;
+    uint32_t    flags;
+
+    flags = XX_DisableAllIntr();
+#ifdef BIGPHYSAREA_ENABLE
+    if (n >= MAX_ALLOCATION_SIZE)
+        a = (void*)bigphysarea_alloc_pages(get_nr_pages(n), 0, GFP_ATOMIC);
+    else
+#endif /* BIGPHYSAREA_ENABLE */
+    a = (void *)kmalloc((uint32_t)n, GFP_ATOMIC);
+    if (!a)
+        XX_Print("No memory for XX_Malloc\n");
+    XX_RestoreAllIntr(flags);
+
+    return a;
+}
+
+static void xx_Free(void *p)
+{
+#ifdef BIGPHYSAREA_ENABLE
+    if (in_big_phys_area ((uint32_t)p))
+        bigphysarea_free_pages(p);
+    else
+#endif /* BIGPHYSAREA_ENABLE */
+    kfree(p);
+}
+
+static void * xx_MallocSmart(uint32_t size, int memPartitionId, uint32_t alignment)
+{
+    void        *returnCode;
+    uint32_t    tmp;
+
+    switch(memPartitionId) {
+       case(0):
+       case(e_MEM_1ST_DDR_CACHEABLE):
+            if (alignment < 4)
+                alignment = 4;
+            tmp = (uint32_t)(xx_Malloc((uint32_t)(size + alignment)));
+            if (tmp == 0)
+                return NULL;
+            returnCode = (void*)((tmp + alignment) & ~(alignment - 1));
+            *(uint32_t*)((uint32_t)returnCode - 4) = tmp;
+            break;
+        default:
+            XX_Print("XX_MallocSmart:Mem type not supported\r\n");
+            return NULL;
+    }
+    return returnCode;
+}
+
+static void xx_FreeSmart(void *p)
+{
+    xx_Free((void *)(*(uint32_t *)((uint32_t)(p)-4)));
+}
+
+
+void XX_Exit(int status)
+{
+    XX_Print("NetCommSw driver can't go on!!!\r\n");
+    BUG();
+}
+
+#define BUF_SIZE    512
+void XX_Print(char *str, ...)
+{
+    va_list args;
+#ifdef CONFIG_SMP
+    char buf[BUF_SIZE];
+#endif /* CONFIG_SMP */
+
+    va_start(args, str);
+#ifdef CONFIG_SMP
+    if (vsnprintf (buf, BUF_SIZE, str, args) >= BUF_SIZE)
+        printk(KERN_WARNING "Illegal string to print!\n    more than %d characters.\n\tString was not printed completelly.\n", BUF_SIZE);
+    printk (KERN_CRIT "cpu%d/%d: %s",hard_smp_processor_id(), smp_processor_id(), buf);
+#else
+    vprintk(str, args);
+#endif /* CONFIG_SMP */
+    va_end(args);
+}
+
+void XX_Fprint(void *file, char *str, ...)
+{
+    va_list args;
+#ifdef CONFIG_SMP
+    char buf[BUF_SIZE];
+#endif /* CONFIG_SMP */
+
+    va_start(args, str);
+#ifdef CONFIG_SMP
+    if (vsnprintf (buf, BUF_SIZE, str, args) >= BUF_SIZE)
+        printk(KERN_WARNING "Illegal string to print!\n    more than %d characters.\n\tString was not printed completelly.\n", BUF_SIZE);
+    printk (KERN_CRIT "cpu%d/%d: %s",hard_smp_processor_id(), smp_processor_id(), buf);
+#else
+    vprintk(str, args);
+#endif /* CONFIG_SMP */
+    va_end(args);
+}
+
+#ifdef DEBUG_XX_MALLOC
+typedef void (*t_ffn)(void *);
+typedef struct {
+    t_ffn       f_free;
+    void        *mem;
+    char        *fname;
+    int         fline;
+    uint32_t    size;
+    t_List      node;
+} t_MemDebug;
+#define MEMDBG_OBJECT(p_List) LIST_OBJECT(p_List, t_MemDebug, node)
+
+LIST(memDbgLst);
+
+
+void * XX_MallocDebug(uint32_t size, char *fname, int line)
+{
+    void       *mem;
+    t_MemDebug *p_MemDbg;
+
+    p_MemDbg = (t_MemDebug *)xx_Malloc(sizeof(t_MemDebug));
+    if (p_MemDbg == NULL)
+        return NULL;
+
+    mem = xx_Malloc(size);
+    if (mem == NULL)
+    {
+        XX_Free(p_MemDbg);
+        return NULL;
+    }
+
+    INIT_LIST(&p_MemDbg->node);
+    p_MemDbg->f_free = xx_Free;
+    p_MemDbg->mem    = mem;
+    p_MemDbg->fname  = fname;
+    p_MemDbg->fline  = line;
+    p_MemDbg->size   = size+sizeof(t_MemDebug);
+    LIST_AddToTail(&p_MemDbg->node, &memDbgLst);
+
+    return mem;
+}
+
+void * XX_MallocSmartDebug(uint32_t size,
+                           int      memPartitionId,
+                           uint32_t align,
+                           char     *fname,
+                           int      line)
+{
+    void       *mem;
+    t_MemDebug *p_MemDbg;
+
+    p_MemDbg = (t_MemDebug *)XX_Malloc(sizeof(t_MemDebug));
+    if (p_MemDbg == NULL)
+        return NULL;
+
+    mem = xx_MallocSmart((uint32_t)size, memPartitionId, align);
+    if (mem == NULL)
+    {
+        XX_Free(p_MemDbg);
+        return NULL;
+    }
+
+    INIT_LIST(&p_MemDbg->node);
+    p_MemDbg->f_free = xx_FreeSmart;
+    p_MemDbg->mem    = mem;
+    p_MemDbg->fname  = fname;
+    p_MemDbg->fline  = line;
+    p_MemDbg->size   = size+sizeof(t_MemDebug);
+    LIST_AddToTail(&p_MemDbg->node, &memDbgLst);
+
+    return mem;
+}
+
+static void debug_free(void *mem)
+{
+    t_List      *p_MemDbgLh = NULL;
+    t_MemDebug  *p_MemDbg;
+    bool        found = FALSE;
+
+    if (LIST_IsEmpty(&memDbgLst))
+    {
+        REPORT_ERROR(MAJOR, E_ALREADY_FREE, ("Unbalanced free (0x%08x)", mem));
+        return;
+    }
+
+    LIST_FOR_EACH(p_MemDbgLh, &memDbgLst)
+    {
+        p_MemDbg = MEMDBG_OBJECT(p_MemDbgLh);
+        if (p_MemDbg->mem == mem)
+        {
+            found = TRUE;
+            break;
+        }
+    }
+
+    if (!found)
+    {
+        REPORT_ERROR(MAJOR, E_NOT_FOUND,
+                     ("Attempt to free unallocated address (0x%08x)",mem));
+        return;
+    }
+
+    LIST_Del(p_MemDbgLh);
+    XX_Free(mem);
+    XX_Free(p_MemDbg);
+}
+
+void XX_FreeSmart(void *p)
+{
+    debug_free(p);
+}
+
+
+void XX_Free(void *p)
+{
+    debug_free(p);
+}
+
+#else /* not DEBUG_XX_MALLOC */
+void * XX_Malloc(uint32_t size)
+{
+    return xx_Malloc(size);
+}
+
+void * XX_MallocSmart(uint32_t size, int memPartitionId, uint32_t alignment)
+{
+    return xx_MallocSmart(size,memPartitionId, alignment);
+}
+
+void XX_FreeSmart(void *p)
+{
+    xx_FreeSmart(p);
+}
+
+
+void XX_Free(void *p)
+{
+    xx_Free(p);
+}
+#endif /* not DEBUG_XX_MALLOC */
+
+
+#if (defined(REPORT_EVENTS) && (REPORT_EVENTS > 0))
+void XX_EventById(uint32_t event, t_Handle appId, uint16_t flags, char *msg)
+{
+    e_Event eventCode = (e_Event)event;
+
+    UNUSED(eventCode);
+    UNUSED(appId);
+    UNUSED(flags);
+    UNUSED(msg);
+}
+#endif /* (defined(REPORT_EVENTS) && ... */
+
+
+uint32_t XX_DisableAllIntr(void)
+{
+    unsigned long flags;
+
+    local_irq_save(flags);
+
+    return (uint32_t)flags;
+}
+
+void XX_RestoreAllIntr(uint32_t flags)
+{
+    local_irq_restore(flags);
+}
+
+t_Error XX_Call( uint32_t qid, t_Error (* f)(t_Handle), t_Handle id, t_Handle appId, uint16_t flags )
+{
+    UNUSED(qid);
+    UNUSED(appId);
+    UNUSED(flags);
+
+    return f(id);
+}
+
+int XX_IsICacheEnable(void)
+{
+    return TRUE;
+}
+
+int XX_IsDCacheEnable(void)
+{
+    return TRUE;
+}
+
+
+typedef struct {
+    t_Isr       *f_Isr;
+    t_Handle    handle;
+} t_InterruptHandler;
+
+
+t_Handle interruptHandlers[0x00010000];
+
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+static void LinuxInterruptHandler(int irq, void * dev_id, struct pt_regs * regs)
+{
+    t_InterruptHandler *p_IntrHndl = (t_InterruptHandler *)dev_id;
+    p_IntrHndl->f_Isr(p_IntrHndl->handle);
+}
+#elif LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19)
+static int LinuxInterruptHandler(int irq, void * dev_id, struct pt_regs * regs)
+{
+    t_InterruptHandler *p_IntrHndl = (t_InterruptHandler *)dev_id;
+    p_IntrHndl->f_Isr(p_IntrHndl->handle);
+    return IRQ_HANDLED;
+}
+#else
+static irqreturn_t LinuxInterruptHandler (int irq, void *dev_id)
+{
+    t_InterruptHandler *p_IntrHndl = (t_InterruptHandler *)dev_id;
+    p_IntrHndl->f_Isr(p_IntrHndl->handle);
+    return IRQ_HANDLED;
+}
+#endif    /* LINUX_VERSION_CODE */
+
+t_Error XX_SetIntr(int irq, t_Isr *f_Isr, t_Handle handle)
+{
+    const char *device;
+    t_InterruptHandler *p_IntrHndl;
+
+    device = GetDeviceName(irq);
+    if (device == NULL)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Interrupt source - %d", irq));
+
+    p_IntrHndl = (t_InterruptHandler *)XX_Malloc(sizeof(t_InterruptHandler));
+    if (p_IntrHndl == NULL)
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, NO_MSG);
+    p_IntrHndl->f_Isr = f_Isr;
+    p_IntrHndl->handle = handle;
+    interruptHandlers[irq] = p_IntrHndl;
+
+    if (request_irq(GetDeviceIrqNum(irq), LinuxInterruptHandler, 0, device, p_IntrHndl) < 0)
+        RETURN_ERROR(MAJOR, E_BUSY, ("Can't get IRQ %s\n", device));
+    disable_irq(GetDeviceIrqNum(irq));
+
+    return E_OK;
+}
+
+t_Error XX_FreeIntr(int irq)
+{
+    t_InterruptHandler *p_IntrHndl = interruptHandlers[irq];
+    free_irq(GetDeviceIrqNum(irq), p_IntrHndl);
+    XX_Free(p_IntrHndl);
+    interruptHandlers[irq] = 0;
+    return E_OK;
+}
+
+t_Error XX_EnableIntr(int irq)
+{
+    enable_irq(GetDeviceIrqNum(irq));
+    return E_OK;
+}
+
+t_Error XX_DisableIntr(int irq)
+{
+    disable_irq(GetDeviceIrqNum(irq));
+    return E_OK;
+}
+
+
+/*****************************************************************************/
+/*                       Tasklet Service Routines                            */
+/*****************************************************************************/
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20)
+typedef struct
+{
+    t_Handle            h_Data;
+    void                (*f_Callback) (void *);
+    struct delayed_work dwork;
+} t_Tasklet;
+
+static void GenericTaskletCallback(struct work_struct *p_Work)
+{
+    t_Tasklet *p_Task = container_of(p_Work, t_Tasklet, dwork.work);
+
+    p_Task->f_Callback(p_Task->h_Data);
+}
+#endif    /* LINUX_VERSION_CODE */
+
+
+t_TaskletHandle XX_InitTasklet (void (*routine)(void *), void *data)
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+    struct tq_struct *p_Task;
+    p_Task = (struct tq_struct *)XX_Malloc(sizeof(struct tq_struct));
+    INIT_TQUEUE(p_Task, routine, data);
+#elif LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20)
+    struct work_struct *p_Task;
+    p_Task = (struct work_struct *)XX_Malloc(sizeof(struct work_struct));
+    INIT_WORK(p_Task, routine, data);
+#else
+    t_Tasklet *p_Task = (t_Tasklet *)XX_Malloc(sizeof(t_Tasklet));
+    INIT_DELAYED_WORK(&p_Task->dwork, GenericTaskletCallback);
+    p_Task->h_Data = data;
+    p_Task->f_Callback = routine;
+#endif    /* LINUX_VERSION_CODE */
+
+    return (t_TaskletHandle)p_Task;
+}
+
+
+void XX_FreeTasklet (t_TaskletHandle h_Tasklet)
+{
+    if (h_Tasklet)
+        XX_Free(h_Tasklet);
+}
+
+int XX_ScheduleTask(t_TaskletHandle h_Tasklet, int immediate)
+{
+    int ans;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+    UNUSED(immediate);
+    ans = queue_task(h_Tasklet, &tq_immediate);
+    mark_bh(IMMEDIATE_BH);
+#elif LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20)
+    if (immediate)
+        ans = schedule_work(h_Tasklet);
+    else
+        ans = schedule_delayed_work(h_Tasklet, 1);
+#else
+    if (immediate)
+        ans = schedule_delayed_work(&((t_Tasklet *)h_Tasklet)->dwork, 0);
+    else
+        ans = schedule_delayed_work(&((t_Tasklet *)h_Tasklet)->dwork, HZ);
+#endif /* LINUX_VERSION_CODE */
+
+    return ans;
+}
+
+void XX_FlushScheduledTasks(void)
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+    flush_scheduled_tasks();
+#else
+    flush_scheduled_work();
+#endif    /* LINUX_VERSION_CODE */
+}
+
+int XX_TaskletIsQueued(t_TaskletHandle h_Tasklet)
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+    return (int)(((struct tq_struct *)h_Tasklet)->sync);
+#elif LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20)
+    return (int)(((struct work_struct *)h_Tasklet)->pending);
+#else
+    return (int)delayed_work_pending(&((t_Tasklet *)h_Tasklet)->dwork);
+#endif    /* LINUX_VERSION_CODE */
+}
+
+void XX_SetTaskletData(t_TaskletHandle h_Tasklet, t_Handle data)
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+    ((struct tq_struct *)h_Tasklet)->data = data;
+#elif LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20)
+    ((struct work_struct *)h_Tasklet)->data = data;
+#else
+    ((t_Tasklet *)h_Tasklet)->h_Data = data;
+#endif    /* LINUX_VERSION_CODE */
+}
+
+t_Handle XX_GetTaskletData(t_TaskletHandle h_Tasklet)
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+    return (t_Handle)(((struct tq_struct *)h_Tasklet)->data);
+#elif LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20)
+    return (t_Handle)(((struct work_struct *)h_Tasklet)->data);
+#else
+    return ((t_Tasklet *)h_Tasklet)->h_Data;
+#endif    /* LINUX_VERSION_CODE */
+}
+
+
+/*****************************************************************************/
+/*                       Semaphore Service Routines                          */
+/*****************************************************************************/
+t_SemaphoreHandle XX_InitSemaphore(int val)
+{
+    struct semaphore *p_Semaphore = (struct semaphore *)XX_Malloc(sizeof(struct semaphore));
+    if (p_Semaphore)
+        sema_init (p_Semaphore, val);
+    return (t_SemaphoreHandle)p_Semaphore;
+}
+
+void XX_FreeSemaphore(t_SemaphoreHandle h_Semaphore)
+{
+    if (h_Semaphore)
+        XX_Free(h_Semaphore);
+}
+
+t_MutexHandle XX_InitMutex(void)
+{
+    return (t_MutexHandle)XX_InitSemaphore(1);
+}
+
+
+t_MutexHandle XX_InitMutexLocked(void)
+{
+    return (t_MutexHandle)XX_InitSemaphore(0);
+}
+
+void XX_FreeMutex(t_MutexHandle h_Mutex)
+{
+    XX_FreeSemaphore(h_Mutex);
+}
+
+void XX_Lock(t_MutexHandle h_Mutex)
+{
+    down((struct semaphore *)h_Mutex);
+}
+
+void XX_Unlock(t_MutexHandle h_Mutex)
+{
+    up((struct semaphore *)h_Mutex);
+}
+
+
+/*****************************************************************************/
+/*                         Spinlock Service Routines                         */
+/*****************************************************************************/
+typedef struct {
+    unsigned long   flags;
+    spinlock_t      *p_Lock;
+} t_Spinlock;
+
+t_SpinlockHandle XX_InitSpinlock(void)
+{
+    t_Spinlock *p_Spinlock = (t_Spinlock *)XX_Malloc(sizeof(t_Spinlock));
+    if (!p_Spinlock)
+        return NULL;
+    memset(p_Spinlock, 0 , sizeof(t_Spinlock));
+    p_Spinlock->p_Lock = (spinlock_t *)XX_Malloc(sizeof(spinlock_t));
+    if (!p_Spinlock->p_Lock)
+    {
+        XX_Free(p_Spinlock);
+        return NULL;
+    }
+
+    spin_lock_init (p_Spinlock->p_Lock);
+    return (t_SpinlockHandle)p_Spinlock;
+}
+
+void XX_FreeSpinlock(t_SpinlockHandle h_Spinlock)
+{
+    if (h_Spinlock)
+    {
+        if (((t_Spinlock *)h_Spinlock)->p_Lock)
+            XX_Free(((t_Spinlock *)h_Spinlock)->p_Lock);
+        XX_Free(h_Spinlock);
+    }
+}
+
+void XX_Spinlock(t_SpinlockHandle h_Spinlock)
+{
+    spin_lock(((t_Spinlock *)h_Spinlock)->p_Lock);
+}
+
+void XX_Spinunlock(t_SpinlockHandle h_Spinlock)
+{
+    spin_unlock(((t_Spinlock *)h_Spinlock)->p_Lock);
+}
+
+void XX_IntrSpinlock(t_SpinlockHandle h_Spinlock)
+{
+    spin_lock_irqsave(((t_Spinlock *)h_Spinlock)->p_Lock, ((t_Spinlock *)h_Spinlock)->flags);
+}
+
+void XX_IntrSpinunlock(t_SpinlockHandle h_Spinlock)
+{
+    spin_unlock_irqrestore(((t_Spinlock *)h_Spinlock)->p_Lock, ((t_Spinlock *)h_Spinlock)->flags);
+}
+
+
+/*****************************************************************************/
+/*                        Timers Service Routines                            */
+/*****************************************************************************/
+/* The time now is in mili sec. resolution */
+uint32_t XX_CurrentTime(void)
+{
+    return (jiffies*1000)/HZ;
+}
+
+
+t_TimerHandle XX_CreateTimer(void)
+{
+    struct timer_list *p_Timer = (struct timer_list *)XX_Malloc(sizeof(struct timer_list));
+    if (p_Timer)
+    {
+        memset(p_Timer, 0, sizeof(struct timer_list));
+        init_timer(p_Timer);
+    }
+    return (t_TimerHandle)p_Timer;
+}
+
+void XX_FreeTimer(t_TimerHandle h_Timer)
+{
+    if (h_Timer)
+        XX_Free(h_Timer);
+}
+
+void XX_StartTimer(t_TimerHandle    h_Timer,
+                   uint32_t         msecs,
+                   bool             periodic,
+                   void             (*f_TimerExpired)(t_Handle),
+                   t_Handle         h_Arg)
+{
+    int                 tmp_jiffies = (msecs*HZ)/1000;
+    struct timer_list   *p_Timer = (struct timer_list *)h_Timer;
+
+    SANITY_CHECK_RETURN((periodic == FALSE), E_NOT_SUPPORTED);
+
+    p_Timer->function = (void (*)(unsigned long))f_TimerExpired;
+    p_Timer->data = (unsigned long)h_Arg;
+    if ((msecs*HZ)%1000)
+        tmp_jiffies++;
+    p_Timer->expires = (jiffies + tmp_jiffies);
+
+    add_timer((struct timer_list *)h_Timer);
+}
+
+void XX_SetTimerData(t_TimerHandle h_Timer, t_Handle data)
+{
+    struct timer_list   *p_Timer = (struct timer_list *)h_Timer;
+
+    p_Timer->data = (unsigned long)data;
+}
+
+t_Handle XX_GetTimerData(t_TimerHandle h_Timer)
+{
+    struct timer_list   *p_Timer = (struct timer_list *)h_Timer;
+
+    return (t_Handle)p_Timer->data;
+}
+
+uint32_t   XX_GetExpirationTime(t_TimerHandle h_Timer)
+{
+    struct timer_list   *p_Timer = (struct timer_list *)h_Timer;
+
+    return (uint32_t)p_Timer->expires;
+}
+
+void XX_StopTimer(t_TimerHandle h_Timer)
+{
+    del_timer((struct timer_list *)h_Timer);
+}
+
+void XX_ModTimer(t_TimerHandle h_Timer, uint32_t msecs)
+{
+    int tmp_jiffies = (msecs*HZ)/1000;
+
+    if ((msecs*HZ)%1000)
+        tmp_jiffies++;
+    mod_timer((struct timer_list *)h_Timer, jiffies + tmp_jiffies);
+}
+
+int XX_TimerIsActive(t_TimerHandle h_Timer)
+{
+  return timer_pending((struct timer_list *)h_Timer);
+}
+
+uint32_t XX_Sleep(uint32_t msecs)
+{
+    int tmp_jiffies = (msecs*HZ)/1000;
+
+    if ((msecs*HZ)%1000)
+        tmp_jiffies++;
+    return schedule_timeout(tmp_jiffies);
+}
+
+/*BEWARE!!!!! UDelay routine is BUSY WAITTING!!!!!*/
+void XX_UDelay(uint32_t usecs)
+{
+    udelay(usecs);
+}
+
+#ifdef CONFIG_MULTI_PARTITION_SUPPORT
+typedef struct {
+    char            *p_Addr;
+    t_MsgHandler    *f_MsgHandlerCB;
+    t_Handle        h_Mod;
+    t_List          node;
+} t_MsgHndlr;
+#define MSG_HNDLR_OBJECT(ptr)  LIST_OBJECT(ptr, t_MsgHndlr, node)
+
+LIST(msgHndlrList);
+
+static void EnqueueMsgHndlr(t_MsgHndlr *p_MsgHndlr)
+{
+    uint32_t   intFlags;
+
+    intFlags = XX_DisableAllIntr();
+    LIST_AddToTail(&p_MsgHndlr->node, &msgHndlrList);
+    XX_RestoreAllIntr(intFlags);
+}
+
+static t_MsgHndlr * DequeueMsgHndlr(void)
+{
+    t_MsgHndlr *p_MsgHndlr = NULL;
+    uint32_t   intFlags;
+
+    intFlags = XX_DisableAllIntr();
+    if (!LIST_IsEmpty(&msgHndlrList))
+    {
+        p_MsgHndlr = MSG_HNDLR_OBJECT(msgHndlrList.p_Next);
+        LIST_DelAndInit(&p_MsgHndlr->node);
+    }
+    XX_RestoreAllIntr(intFlags);
+
+    return p_MsgHndlr;
+}
+
+static t_MsgHndlr * FindMsgHndlr(char *p_Addr)
+{
+    t_MsgHndlr  *p_MsgHndlr;
+    t_List      *p_Pos;
+
+    LIST_FOR_EACH(p_Pos, &msgHndlrList)
+    {
+        p_MsgHndlr = MSG_HNDLR_OBJECT(p_Pos);
+        if (strstr(p_MsgHndlr->p_Addr, p_Addr))
+            return p_MsgHndlr;
+    }
+
+    return NULL;
+}
+
+t_Error XX_RegisterMessageHandler   (char *p_Addr, t_MsgHandler *f_MsgHandlerCB, t_Handle h_Mod)
+{
+    t_MsgHndlr  *p_MsgHndlr;
+    uint32_t    len;
+
+    p_MsgHndlr = (t_MsgHndlr*)XX_Malloc(sizeof(t_MsgHndlr));
+    if (!p_MsgHndlr)
+        RETURN_ERROR(MINOR, E_NO_MEMORY, ("message handler object!!!"));
+    memset(p_MsgHndlr, 0, sizeof(t_MsgHndlr));
+
+    len = strlen(p_Addr);
+    p_MsgHndlr->p_Addr = (char*)XX_Malloc(len+1);
+    strncpy(p_MsgHndlr->p_Addr,p_Addr, (uint32_t)(len+1));
+
+    p_MsgHndlr->f_MsgHandlerCB = f_MsgHandlerCB;
+    p_MsgHndlr->h_Mod = h_Mod;
+    INIT_LIST(&p_MsgHndlr->node);
+    EnqueueMsgHndlr(p_MsgHndlr);
+
+    return E_OK;
+}
+
+t_Error XX_UnregisterMessageHandler (char *p_Addr)
+{
+    t_MsgHndlr *p_MsgHndlr = FindMsgHndlr(p_Addr);
+    if (!p_MsgHndlr)
+        RETURN_ERROR(MINOR, E_NO_DEVICE, ("message handler not found in list!!!"));
+
+    LIST_Del(&p_MsgHndlr->node);
+    XX_Free(p_MsgHndlr->p_Addr);
+    XX_Free(p_MsgHndlr);
+
+    return E_OK;
+}
+
+t_Error XX_SendMessage(char                 *p_DestAddr,
+                       uint32_t             msgId,
+                       uint8_t              msgBody[MSG_BODY_SIZE],
+                       t_MsgCompletionCB    *f_CompletionCB,
+                       t_Handle             h_CBArg)
+{
+    t_Error     ans;
+    t_MsgHndlr  *p_MsgHndlr = FindMsgHndlr(p_DestAddr);
+    if (!p_MsgHndlr)
+        RETURN_ERROR(MINOR, E_NO_DEVICE, ("message handler not found in list!!!"));
+
+    ans = p_MsgHndlr->f_MsgHandlerCB(p_MsgHndlr->h_Mod, msgId, msgBody);
+
+    if (f_CompletionCB)
+        f_CompletionCB(h_CBArg, msgBody);
+
+    return ans;
+}
+#endif /* CONFIG_MULTI_PARTITION_SUPPORT */
-- 
1.6.5.2

