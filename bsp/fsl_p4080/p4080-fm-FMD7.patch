From afd9e06d199d14c6db04dac5269eeb3eec3f069a Mon Sep 17 00:00:00 2001
From: Shlomi Gridish <gridish@freescale.com>
Date: Thu, 21 Jan 2010 21:25:09 +0200
Subject: [PATCH 129/148] p4080/fm: FMD7

1. Fixing Bugzila BUGs 4683, 4675, 4895, 5905, 4906
  2. Added workarounds for FM chip erratas.
  3. Fixed several BUGs found during bring-up
  4. Added support for rev2 (simics only!)
  5. added conditional errata execution

Signed-off-by: Shlomi Gridish <gridish@freescale.com>
[Cleanly applied the FSL SDK 2.0.3 patch:
"kernel-2.6.30-p4080-fm-FMD7.patch"]
Integrated-by: Yuri Nedel <Yuri.Nedel@windriver.com>
---
 drivers/net/dpa/NetCommSw/Peripherals/FM/HC/hc.c   |  176 ++--
 .../net/dpa/NetCommSw/Peripherals/FM/MAC/Makefile  |    4 -
 .../net/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.c   |  484 +++++++----
 .../net/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.h   |  297 ++++----
 .../NetCommSw/Peripherals/FM/MAC/dtsec_mii_acc.c   |    8 +-
 .../NetCommSw/Peripherals/FM/MAC/dtsec_mii_acc.h   |   10 +-
 .../net/dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.c  |   53 +-
 .../net/dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.h  |   21 +-
 .../net/dpa/NetCommSw/Peripherals/FM/MAC/tgec.c    |  184 ++++-
 .../net/dpa/NetCommSw/Peripherals/FM/MAC/tgec.h    |   88 +-
 .../NetCommSw/Peripherals/FM/MAC/tgec_mii_acc.c    |   17 +-
 .../NetCommSw/Peripherals/FM/MAC/tgec_mii_acc.h    |   19 +-
 drivers/net/dpa/NetCommSw/Peripherals/FM/Makefile  |    1 +
 .../net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.c   |  170 +++--
 .../net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_kg.c   |  131 ++-
 .../net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.c  |  256 +++---
 .../net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.h  |  103 ++-
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd_ipc.h  |   17 +-
 .../net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_plcr.c |  339 +++++----
 .../net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.c  |  115 ++-
 .../dpa/NetCommSw/Peripherals/FM/Port/fm_port.c    |  897 ++++++++++++--------
 .../dpa/NetCommSw/Peripherals/FM/Port/fm_port.h    |  144 ++--
 .../dpa/NetCommSw/Peripherals/FM/Port/fm_port_im.c |  147 ++--
 .../net/dpa/NetCommSw/Peripherals/FM/Rtc/Makefile  |   15 +
 .../net/dpa/NetCommSw/Peripherals/FM/Rtc/fm_rtc.c  |  835 ++++++++++++++++++
 .../net/dpa/NetCommSw/Peripherals/FM/Rtc/fm_rtc.h  |  219 +++++
 drivers/net/dpa/NetCommSw/Peripherals/FM/fm.c      |  597 ++++++++-----
 drivers/net/dpa/NetCommSw/Peripherals/FM/fm.h      |   69 +-
 .../net/dpa/NetCommSw/Peripherals/FM/fm_guest.c    |   68 +-
 drivers/net/dpa/NetCommSw/Peripherals/FM/fm_ipc.h  |   15 +-
 .../net/dpa/NetCommSw/Peripherals/FM/fm_muram.c    |   17 +-
 .../dpa/NetCommSw/Peripherals/FM/inc/fm_common.h   |  340 ++++++--
 .../net/dpa/NetCommSw/Peripherals/FM/inc/fm_hc.h   |    2 +-
 drivers/net/dpa/NetCommSw/dflags.h                 |    3 +-
 drivers/net/dpa/NetCommSw/etc/error.c              |    2 +-
 drivers/net/dpa/NetCommSw/etc/list.c               |    2 +-
 drivers/net/dpa/NetCommSw/etc/memcpy.c             |    2 +-
 drivers/net/dpa/NetCommSw/etc/mm.c                 |    2 +-
 drivers/net/dpa/NetCommSw/etc/mm.h                 |    2 +-
 drivers/net/dpa/NetCommSw/etc/sprint.c             |    2 +-
 drivers/net/dpa/NetCommSw/events_mapping.h         |    2 +-
 .../NetCommSw/inc/Peripherals/crc_mac_addr_ext.h   |    2 +-
 drivers/net/dpa/NetCommSw/inc/Peripherals/fm_ext.h |  397 ++-------
 .../net/dpa/NetCommSw/inc/Peripherals/fm_mac_ext.h |   65 +-
 .../dpa/NetCommSw/inc/Peripherals/fm_muram_ext.h   |    2 +-
 .../net/dpa/NetCommSw/inc/Peripherals/fm_pcd_ext.h |  167 ++--
 .../dpa/NetCommSw/inc/Peripherals/fm_port_ext.h    |  260 ++++--
 .../net/dpa/NetCommSw/inc/Peripherals/fm_rtc_ext.h |  558 ++++++++++++
 .../dpa/NetCommSw/inc/Peripherals/mii_acc_ext.h    |    2 +-
 drivers/net/dpa/NetCommSw/inc/core_ext.h           |   65 ++
 drivers/net/dpa/NetCommSw/inc/cores/e500v2_ext.h   |  359 ++++++++
 drivers/net/dpa/NetCommSw/inc/cores/ppc_ext.h      |  136 +++
 drivers/net/dpa/NetCommSw/inc/ctype_ext.h          |    2 +-
 drivers/net/dpa/NetCommSw/inc/debug_ext.h          |    2 +-
 drivers/net/dpa/NetCommSw/inc/endian_ext.h         |    2 +-
 drivers/net/dpa/NetCommSw/inc/enet_ext.h           |   11 +-
 drivers/net/dpa/NetCommSw/inc/error_ext.h          |   69 +-
 drivers/net/dpa/NetCommSw/inc/etc/list_ext.h       |    2 +-
 drivers/net/dpa/NetCommSw/inc/etc/mem_ext.h        |    2 +-
 drivers/net/dpa/NetCommSw/inc/etc/memcpy_ext.h     |    2 +-
 drivers/net/dpa/NetCommSw/inc/etc/mm_ext.h         |    2 +-
 drivers/net/dpa/NetCommSw/inc/etc/sprint_ext.h     |    2 +-
 .../inc/integrations/P4080/dpaa_integration_ext.h  |  255 ++++++
 .../inc/integrations/P4080/part_integration_ext.h  |  189 ++---
 .../net/dpa/NetCommSw/inc/integrations/part_ext.h  |    8 +-
 drivers/net/dpa/NetCommSw/inc/math_ext.h           |    2 +-
 drivers/net/dpa/NetCommSw/inc/ncsw_ext.h           |   27 +-
 drivers/net/dpa/NetCommSw/inc/net_ext.h            |    2 +-
 drivers/net/dpa/NetCommSw/inc/std_ext.h            |    2 +-
 drivers/net/dpa/NetCommSw/inc/stdarg_ext.h         |    2 +-
 drivers/net/dpa/NetCommSw/inc/stdlib_ext.h         |    2 +-
 drivers/net/dpa/NetCommSw/inc/string_ext.h         |    2 +-
 drivers/net/dpa/NetCommSw/inc/types_ext.h          |   35 +-
 drivers/net/dpa/NetCommSw/inc/xx_ext.h             |   78 +-
 .../net/dpa/NetCommSw/integrations/P4080/Makefile  |    2 -
 .../NetCommSw/integrations/P4080/module_strings.c  |   13 +-
 drivers/net/dpa/NetCommSw/ncsw_config.mk           |    1 +
 .../kernel/2.6/inc/ioctl/Peripherals/fm_ioctls.h   |    2 +-
 .../2.6/inc/ioctl/Peripherals/fm_pcd_ioctls.h      |   10 +-
 .../2.6/inc/ioctl/Peripherals/fm_port_ioctls.h     |    2 +-
 .../2.6/inc/ioctl/Peripherals/fm_test_ioctls.h     |    2 +-
 .../ioctl/integrations/P4080/integration_ioctls.h  |    2 +-
 .../user/env/linux/kernel/2.6/inc/ioctl/ioctls.h   |    2 +-
 .../env/linux/kernel/2.6/inc/ioctl/net_ioctls.h    |    2 +-
 .../user/env/linux/kernel/2.6/inc/procbuff_ext.h   |    2 +-
 .../env/linux/kernel/2.6/inc/system/platform_ext.h |    3 +-
 .../kernel/2.6/inc/system/platform_p4080_ds_ext.h  |    2 +-
 .../user/env/linux/kernel/2.6/inc/system/sys_ext.h |  660 +++++++++++----
 .../env/linux/kernel/2.6/inc/system/sys_io_ext.h   |    2 +-
 .../user/env/linux/kernel/2.6/inc/types_linux.h    |    4 +-
 .../kernel/2.6/inc/wrappers/Peripherals/fsl_fman.h |    4 +-
 .../2.6/inc/wrappers/Peripherals/fsl_fman_test.h   |   34 +-
 .../2.6/inc/wrappers/Peripherals/lnxwrp_fm_ext.h   |    2 +-
 .../kernel/2.6/modules/integrations/P4080/FM/fmm.c |    2 +-
 .../2.6/modules/integrations/P4080/FM/mod_config.h |    2 +-
 .../kernel/2.6/system/platform/P4080/Makefile      |    2 +
 .../2.6/system/platform/P4080/platform_p4080_ds.c  |    2 +-
 .../user/env/linux/kernel/2.6/system/sys_init.c    |   48 -
 .../user/env/linux/kernel/2.6/system/sys_io.c      |    2 +-
 .../user/env/linux/kernel/2.6/util/procbuff.c      |    2 +-
 .../user/env/linux/kernel/2.6/util/procbuff.h      |    2 +-
 .../kernel/2.6/wrappers/Peripherals/FM/fman_test.c |   98 +--
 .../kernel/2.6/wrappers/Peripherals/FM/lnxwrp_fm.c |  170 ++---
 .../kernel/2.6/wrappers/Peripherals/FM/lnxwrp_fm.h |    2 +-
 .../2.6/wrappers/Peripherals/FM/lnxwrp_fm_ioctls.c |    4 +-
 .../NetCommSw/user/env/linux/kernel/2.6/xx/ctype.c |    2 +-
 .../2.6/xx/integrations/P4080/xx_integration.c     |   10 +-
 .../user/env/linux/kernel/2.6/xx/stdlib.c          |    2 +-
 .../user/env/linux/kernel/2.6/xx/udivdi3.c         |    2 +-
 .../NetCommSw/user/env/linux/kernel/2.6/xx/xx.h    |    2 +-
 .../user/env/linux/kernel/2.6/xx/xx_linux.c        |   74 +-
 drivers/net/dpa/mac-api.c                          |    4 +-
 112 files changed, 6677 insertions(+), 3094 deletions(-)
 create mode 100644 drivers/net/dpa/NetCommSw/Peripherals/FM/Rtc/Makefile
 create mode 100644 drivers/net/dpa/NetCommSw/Peripherals/FM/Rtc/fm_rtc.c
 create mode 100644 drivers/net/dpa/NetCommSw/Peripherals/FM/Rtc/fm_rtc.h
 create mode 100644 drivers/net/dpa/NetCommSw/inc/Peripherals/fm_rtc_ext.h
 create mode 100644 drivers/net/dpa/NetCommSw/inc/core_ext.h
 create mode 100644 drivers/net/dpa/NetCommSw/inc/cores/e500v2_ext.h
 create mode 100644 drivers/net/dpa/NetCommSw/inc/cores/ppc_ext.h
 create mode 100644 drivers/net/dpa/NetCommSw/inc/integrations/P4080/dpaa_integration_ext.h
 delete mode 100644 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/system/sys_init.c

diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/HC/hc.c b/drivers/net/dpa/NetCommSw/Peripherals/FM/HC/hc.c
index f47b808..dceeac0 100644
--- a/drivers/net/dpa/NetCommSw/Peripherals/FM/HC/hc.c
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/HC/hc.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -39,7 +39,14 @@
 #include "fm_hc.h"
 
 
-#define __ERR_MODULE__  MODULE_FM
+#define __ERR_MODULE__  MODULE_FM_PCD
+
+#define HC_HCOR_OPCODE_PLCR_PRFL            0x0
+#define HC_HCOR_OPCODE_KG_SCM               0x1
+#define HC_HCOR_OPCODE_SYNC                 0x2
+#define HC_HCOR_OPCODE_CC                   0x3
+
+#define HC_HCOR_GBL                         0x20000000
 
 #define SIZE_OF_HC_FRAME_PORT_REGS          (sizeof(t_HcFrame)-sizeof(t_FmPcdKgInterModuleSchemeRegs)+sizeof(t_FmPcdKgPortRegs))
 #define SIZE_OF_HC_FRAME_SCHEME_REGS        sizeof(t_HcFrame)
@@ -63,7 +70,7 @@ do {
     p_FmHc->wait[savedSeqNum] = TRUE;                                           \
     DBG(TRACE, ("Send Hc 0x%x , SeqNum %d, fd addr 0x%x, fd offset 0x%x",       \
             p_FmHc,savedSeqNum,FM_FD_GET_ADDR(frm),FM_FD_GET_OFFSET(frm)));     \
-    err = p_FmHc->f_QmEnqueueCB(p_FmHc->h_QmArg, p_FmHc->enqFqid, (void *)frm); \
+    err = p_FmHc->f_QmEnqueue(p_FmHc->h_QmArg, p_FmHc->enqFqid, (void *)frm);   \
     if(err)                                                                     \
         RETURN_ERROR(MINOR, err, ("HC enqueue failed"));                        \
     while (p_FmHc->wait[savedSeqNum]) ;                                         \
@@ -77,7 +84,7 @@ do {
     p_FmHc->wait[savedSeqNum] = TRUE;                                           \
     DBG(TRACE, ("Send Hc Null 0x%x , SeqNum %d, fd addr 0x%x, fd offset 0x%x",  \
             p_FmHc,savedSeqNum,FM_FD_GET_ADDR(frm),FM_FD_GET_OFFSET(frm)));     \
-    err = p_FmHc->f_QmEnqueueCB(p_FmHc->h_QmArg, p_FmHc->enqFqid, (void *)frm); \
+    err = p_FmHc->f_QmEnqueue(p_FmHc->h_QmArg, p_FmHc->enqFqid, (void *)frm);   \
     if(err)  {                                                                  \
         REPORT_ERROR(MINOR, err, ("HC enqueue failed")); return NULL;           \
     }                                                                           \
@@ -113,67 +120,66 @@ do {
 
 
 
-#ifdef __MWERKS__
+#if defined(__MWERKS__) && !defined(__GNUC__)
 #pragma pack(push,1)
-#endif /*__MWERKS__ */
+#endif /* defined(__MWERKS__) && ... */
 #define MEM_MAP_START
 
 /**************************************************************************//**
  @Description   PCD KG scheme registers
 *//***************************************************************************/
 typedef _Packed struct t_FmPcdKgSchemeRegsWithoutCounter {
-    uint32_t kgse_mode;    /**< MODE */
-    uint32_t kgse_ekfc;    /**< Extract Known Fields Command */
-    uint32_t kgse_ekdv;    /**< Extract Known Default Value */
-    uint32_t kgse_bmch;    /**< Bit Mask Command High */
-    uint32_t kgse_bmcl;    /**< Bit Mask Command Low */
-    uint32_t kgse_fqb;     /**< Frame Queue Base */
-    uint32_t kgse_hc;      /**< Hash Command */
-    uint32_t kgse_ppc;     /**< Policer Profile Command */
-    uint32_t kgse_gec[FM_PCD_KG_NUM_OF_GENERIC_REGS];
+    volatile uint32_t kgse_mode;    /**< MODE */
+    volatile uint32_t kgse_ekfc;    /**< Extract Known Fields Command */
+    volatile uint32_t kgse_ekdv;    /**< Extract Known Default Value */
+    volatile uint32_t kgse_bmch;    /**< Bit Mask Command High */
+    volatile uint32_t kgse_bmcl;    /**< Bit Mask Command Low */
+    volatile uint32_t kgse_fqb;     /**< Frame Queue Base */
+    volatile uint32_t kgse_hc;      /**< Hash Command */
+    volatile uint32_t kgse_ppc;     /**< Policer Profile Command */
+    volatile uint32_t kgse_gec[FM_PCD_KG_NUM_OF_GENERIC_REGS];
                            /**< Generic Extract Command */
-    uint32_t kgse_dv0;     /**< KeyGen Scheme Entry Default Value 0 */
-    uint32_t kgse_dv1;     /**< KeyGen Scheme Entry Default Value 1 */
-    uint32_t kgse_ccbs;    /**< KeyGen Scheme Entry Coarse Classification Bit*/
-    uint32_t kgse_mv;      /**< KeyGen Scheme Entry Match vector */
+    volatile uint32_t kgse_dv0;     /**< KeyGen Scheme Entry Default Value 0 */
+    volatile uint32_t kgse_dv1;     /**< KeyGen Scheme Entry Default Value 1 */
+    volatile uint32_t kgse_ccbs;    /**< KeyGen Scheme Entry Coarse Classification Bit*/
+    volatile uint32_t kgse_mv;      /**< KeyGen Scheme Entry Match vector */
 } _PackedType t_FmPcdKgSchemeRegsWithoutCounter;
 
-#define MEM_MAP_END
-#ifdef __MWERKS__
-#pragma pack(pop)
-#endif /* __MWERKS__ */
-
-typedef struct t_FmPcdKgPortRegs {
-        uint32_t                spReg;
-        uint32_t                cppReg;
-} t_FmPcdKgPortRegs;
-
-typedef struct t_HcFrame {
-    uint32_t                    opcode;
-    uint32_t                    actionReg;
-    uint32_t                    extraReg;
-    uint32_t                    commandSequence;
+typedef _Packed struct t_FmPcdKgPortRegs {
+    volatile uint32_t                spReg;
+    volatile uint32_t                cppReg;
+} _PackedType t_FmPcdKgPortRegs;
+
+typedef _Packed struct t_HcFrame {
+    volatile uint32_t                    opcode;
+    volatile uint32_t                    actionReg;
+    volatile uint32_t                    extraReg;
+    volatile uint32_t                    commandSequence;
     union
     {
         t_FmPcdKgInterModuleSchemeRegs      schemeRegs;
         t_FmPcdKgInterModuleSchemeRegs      schemeRegsWithoutCounter;
         t_FmPcdPlcrInterModuleProfileRegs   profileRegs;
-        uint32_t                            singleRegForWrite;    /* for writing SP, CPP, profile counter */
+        volatile uint32_t                   singleRegForWrite;    /* for writing SP, CPP, profile counter */
         t_FmPcdKgPortRegs                   portRegsForRead;
-        uint32_t                            clsPlanEntries[CLS_PLAN_NUM_PER_GRP];
+        volatile uint32_t                   clsPlanEntries[CLS_PLAN_NUM_PER_GRP];
     } hcSpecificData;
-} t_HcFrame;
+} _PackedType t_HcFrame;
+
+#define MEM_MAP_END
+#if defined(__MWERKS__) && !defined(__GNUC__)
+#pragma pack(pop)
+#endif /* defined(__MWERKS__) && ... */
 
 typedef struct t_FmHc {
-    t_Handle                h_FmPcd;
-    t_Handle                h_HcPortDev;
-    uint32_t                enqFqid;            /**< Host-Command enqueue Queue Id. */
-    t_FmPcdQmEnqueueCB      *f_QmEnqueueCB;     /**< A callback for enquing frames to the QM */
-    t_Handle                h_QmArg;            /**< A handle to the QM module */
-
-    //volatile bool           lock;
-    uint32_t                seqNum;
-    volatile bool           wait[32];
+    t_Handle                    h_FmPcd;
+    t_Handle                    h_HcPortDev;
+    uint32_t                    enqFqid;            /**< Host-Command enqueue Queue Id. */
+    t_FmPcdQmEnqueueCallback    *f_QmEnqueue;     /**< A callback for enquing frames to the QM */
+    t_Handle                    h_QmArg;            /**< A handle to the QM module */
+
+    uint32_t                    seqNum;
+    volatile bool               wait[32];
 } t_FmHc;
 
 
@@ -189,11 +195,11 @@ static t_Error KgHcSetClsPlan(t_FmHc *p_FmHc, t_FmPcdKgInterModuleClsPlanSet *p_
     for(i=p_Set->baseEntry;i<p_Set->baseEntry+p_Set->numOfClsPlanEntries;i+=8)
     {
         memset(&hcFrame, 0, sizeof(hcFrame));
-        hcFrame.opcode = 0x00000001;
+        hcFrame.opcode = (uint32_t)(HC_HCOR_GBL | HC_HCOR_OPCODE_KG_SCM);
         hcFrame.actionReg  = FmPcdKgBuildWriteClsPlanBlockActionReg((uint8_t)(i / CLS_PLAN_NUM_PER_GRP));
         hcFrame.extraReg = 0xFFFFF800;
         hcFrame.commandSequence = p_FmHc->seqNum;
-        memcpy(&hcFrame.hcSpecificData.clsPlanEntries, &p_Set->vectors[i-p_Set->baseEntry], CLS_PLAN_NUM_PER_GRP*sizeof(uint32_t));
+        memcpy((void*)&hcFrame.hcSpecificData.clsPlanEntries, (void*)&p_Set->vectors[i-p_Set->baseEntry], CLS_PLAN_NUM_PER_GRP*sizeof(uint32_t));
 
         BUILD_FD(sizeof(hcFrame));
 
@@ -212,7 +218,7 @@ static t_Error CcHcDoDynamicChange(t_FmHc *p_FmHc, bool keyModify, t_Handle p_Ol
     ASSERT_COND(p_FmHc);
 
     memset(&hcFrame, 0, sizeof(hcFrame));
-    hcFrame.opcode = 0x00000003;
+    hcFrame.opcode = (uint32_t)(HC_HCOR_GBL | HC_HCOR_OPCODE_CC);
     hcFrame.actionReg  = FmPcdCcGetNodeAddrOffset(p_FmHc->h_FmPcd, p_NewPointer);
     if(hcFrame.actionReg == ILLEGAL_BASE)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Something wrong with base address"));
@@ -293,13 +299,13 @@ t_Handle    FmHcConfigAndInit(t_FmHcParams *p_FmHcParams)
 
     p_FmHc->h_FmPcd             = p_FmHcParams->h_FmPcd;
     p_FmHc->enqFqid             = p_FmHcParams->params.enqFqid;
-    p_FmHc->f_QmEnqueueCB       = p_FmHcParams->params.f_QmEnqueueCB;
+    p_FmHc->f_QmEnqueue         = p_FmHcParams->params.f_QmEnqueue;
     p_FmHc->h_QmArg             = p_FmHcParams->params.h_QmArg;
 
 #ifndef CONFIG_GUEST_PARTITION
     memset(&fmPortParam, 0, sizeof(fmPortParam));
     fmPortParam.baseAddr    = p_FmHcParams->params.portBaseAddr;
-    fmPortParam.portType    = e_FM_PORT_TYPE_HOST_COMMAND;
+    fmPortParam.portType    = e_FM_PORT_TYPE_OH_HOST_COMMAND;
     fmPortParam.portId      = p_FmHcParams->params.portId;
     fmPortParam.h_Fm        = p_FmHcParams->h_Fm;
 
@@ -353,9 +359,10 @@ void FmHcTxConf(t_Handle h_FmHc, t_FmFD *p_Fd)
     DBG(TRACE, ("Hc Conf 0x%x , SeqNum %d, fd addr 0x%x, fd offset 0x%x",
             p_FmHc,p_HcFrame->commandSequence,FM_FD_GET_ADDR(p_Fd),FM_FD_GET_OFFSET(p_Fd)));
 
-    ASSERT_COND(p_FmHc->wait[p_HcFrame->commandSequence]);
-
-    p_FmHc->wait[p_HcFrame->commandSequence] = FALSE;
+    if (!(p_FmHc->wait[p_HcFrame->commandSequence]))
+        REPORT_ERROR(MINOR, E_INVALID_FRAME, ("Not an Host-Command frame recieved!"));
+    else
+        p_FmHc->wait[p_HcFrame->commandSequence] = FALSE;
 }
 
 t_Handle FmHcPcdKgSetScheme(t_Handle h_FmHc, t_FmPcdKgSchemeParams *p_Scheme)
@@ -375,6 +382,7 @@ t_Handle FmHcPcdKgSetScheme(t_Handle h_FmHc, t_FmPcdKgSchemeParams *p_Scheme)
         /* check that schameId is in range */
         if(p_Scheme->id.relativeSchemeId >= FmPcdKgGetNumOfPartitionSchemes(p_FmHc->h_FmPcd))
         {
+            FmPcdReleaseLock(p_FmHc->h_FmPcd);
             REPORT_ERROR(MAJOR, E_NOT_IN_RANGE, ("Scheme is out of range"));
             return NULL;
         }
@@ -391,7 +399,7 @@ t_Handle FmHcPcdKgSetScheme(t_Handle h_FmHc, t_FmPcdKgSchemeParams *p_Scheme)
         physicalSchemeId = FmPcdKgGetPhysicalSchemeId(p_FmHc->h_FmPcd, relativeSchemeId);
 
         memset(&hcFrame, 0, sizeof(hcFrame));
-        hcFrame.opcode = 0x00000001;
+        hcFrame.opcode = (uint32_t)(HC_HCOR_GBL | HC_HCOR_OPCODE_KG_SCM);
         hcFrame.actionReg  = FmPcdKgBuildReadSchemeActionReg(physicalSchemeId);
         hcFrame.extraReg = 0xFFFFF800;
         hcFrame.commandSequence = p_FmHc->seqNum;
@@ -412,6 +420,12 @@ t_Handle FmHcPcdKgSetScheme(t_Handle h_FmHc, t_FmPcdKgSchemeParams *p_Scheme)
     {
         physicalSchemeId = (uint8_t)(CAST_POINTER_TO_UINT32(p_Scheme->id.h_Scheme)-1);
         relativeSchemeId = FmPcdKgGetRelativeSchemeId(p_FmHc->h_FmPcd, physicalSchemeId);
+        if( relativeSchemeId == FM_PCD_KG_NUM_OF_SCHEMES)
+        {
+            FmPcdKgReleaseSchemeLock(p_FmHc->h_FmPcd, relativeSchemeId);
+            REPORT_ERROR(MAJOR, E_NOT_IN_RANGE, NO_MSG);
+            return NULL;
+        }
         if (FmPcdKgSchemeTryLock(p_FmHc->h_FmPcd, relativeSchemeId))
         {
             FmPcdReleaseLock(p_FmHc->h_FmPcd);
@@ -419,15 +433,9 @@ t_Handle FmHcPcdKgSetScheme(t_Handle h_FmHc, t_FmPcdKgSchemeParams *p_Scheme)
         }
         FmPcdReleaseLock(p_FmHc->h_FmPcd);
 
-        if( relativeSchemeId == FM_PCD_KG_NUM_OF_SCHEMES)
-        {
-            FmPcdKgReleaseSchemeLock(p_FmHc->h_FmPcd, relativeSchemeId);
-            REPORT_ERROR(MAJOR, E_NOT_IN_RANGE, NO_MSG);
-            return NULL;
-        }
     }
 
-    err = FmPcdKgBuildScheme(p_FmHc->h_FmPcd, p_Scheme, &schemeRegs,  &p_Scheme->orderedArray);
+    err = FmPcdKgBuildScheme(p_FmHc->h_FmPcd, p_Scheme, &schemeRegs);
     if(err)
     {
         FmPcdKgReleaseSchemeLock(p_FmHc->h_FmPcd, relativeSchemeId);
@@ -436,14 +444,16 @@ t_Handle FmHcPcdKgSetScheme(t_Handle h_FmHc, t_FmPcdKgSchemeParams *p_Scheme)
     }
 
     memset(&hcFrame, 0, sizeof(hcFrame));
-    hcFrame.opcode = 0x00000001;
+    hcFrame.opcode = (uint32_t)(HC_HCOR_GBL | HC_HCOR_OPCODE_KG_SCM);
     hcFrame.actionReg  = FmPcdKgBuildWriteSchemeActionReg(physicalSchemeId, p_Scheme->schemeCounter.update);
     hcFrame.extraReg = 0xFFFFF800;
     hcFrame.commandSequence = p_FmHc->seqNum;
     memcpy(&hcFrame.hcSpecificData.schemeRegs, &schemeRegs, sizeof(t_FmPcdKgInterModuleSchemeRegs));
     //p_NewStruct= (t_FmPcdKgSchemeRegsWithoutCounter*)&hcFrame.hcSpecificData;
     if(!p_Scheme->schemeCounter.update)
-        memcpy((t_FmPcdKgSchemeRegsWithoutCounter*)&hcFrame.hcSpecificData.schemeRegs.kgse_dv0, &schemeRegs.kgse_dv0, 4*sizeof(uint32_t));
+        memcpy((void*)&hcFrame.hcSpecificData.schemeRegs.kgse_dv0,
+               (void*)&schemeRegs.kgse_dv0,
+               4*sizeof(uint32_t));
 
     BUILD_FD(sizeof(hcFrame));
 
@@ -466,25 +476,27 @@ t_Error FmHcPcdKgDeleteScheme(t_Handle h_FmHc, t_Handle h_Scheme)
     uint8_t                             physicalSchemeId = (uint8_t)(CAST_POINTER_TO_UINT32(h_Scheme)-1);
 
     if ((err = FmPcdTryLock(p_FmHc->h_FmPcd)) != E_OK)
-        return err;
+        RETURN_ERROR(MAJOR, err, NO_MSG);
 
     relativeSchemeId = FmPcdKgGetRelativeSchemeId(p_FmHc->h_FmPcd, physicalSchemeId);
 
     err = FmPcdKgSchemeTryLock(p_FmHc->h_FmPcd, relativeSchemeId);
     FmPcdReleaseLock(p_FmHc->h_FmPcd);
     if (err)
-        return err;
+        RETURN_ERROR(MAJOR, err, NO_MSG);
 
     if(relativeSchemeId == FM_PCD_KG_NUM_OF_SCHEMES)
     {
         FmPcdKgReleaseSchemeLock(p_FmHc->h_FmPcd, relativeSchemeId);
-        REPORT_ERROR(MAJOR, E_NOT_IN_RANGE, NO_MSG);
+        RETURN_ERROR(MAJOR, E_NOT_IN_RANGE, NO_MSG);
     }
 
-    FmPcdKgCheckInvalidateSchemeSw(p_FmHc->h_FmPcd, relativeSchemeId);
+    err = FmPcdKgCheckInvalidateSchemeSw(p_FmHc->h_FmPcd, relativeSchemeId);
+    if (err)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
 
     memset(&hcFrame, 0, sizeof(hcFrame));
-    hcFrame.opcode = 0x00000001;
+    hcFrame.opcode = (uint32_t)(HC_HCOR_GBL | HC_HCOR_OPCODE_KG_SCM);
     hcFrame.actionReg  = FmPcdKgBuildWriteSchemeActionReg(physicalSchemeId, TRUE);
     hcFrame.extraReg = 0xFFFFF800;
     memset(&hcFrame.hcSpecificData.schemeRegs, 0, sizeof(t_FmPcdKgInterModuleSchemeRegs));
@@ -529,7 +541,7 @@ uint32_t  FmHcPcdKgGetSchemeCounter(t_Handle h_FmHc, t_Handle h_Scheme)
 
     /* first read scheme and check that it is valid */
     memset(&hcFrame, 0, sizeof(hcFrame));
-    hcFrame.opcode = 0x00000001;
+    hcFrame.opcode = (uint32_t)(HC_HCOR_GBL | HC_HCOR_OPCODE_KG_SCM);
     hcFrame.actionReg  = FmPcdKgBuildReadSchemeActionReg(physicalSchemeId);
     hcFrame.extraReg = 0xFFFFF800;
     hcFrame.commandSequence = p_FmHc->seqNum;
@@ -577,7 +589,7 @@ t_Error  FmHcPcdKgSetSchemeCounter(t_Handle h_FmHc, t_Handle h_Scheme, uint32_t
 
     /* first read scheme and check that it is valid */
     memset(&hcFrame, 0, sizeof(hcFrame));
-    hcFrame.opcode = 0x00000001;
+    hcFrame.opcode = (uint32_t)(HC_HCOR_GBL | HC_HCOR_OPCODE_KG_SCM);
     hcFrame.actionReg  = FmPcdKgBuildReadSchemeActionReg(physicalSchemeId);
     hcFrame.extraReg = 0xFFFFF800;
     hcFrame.commandSequence = p_FmHc->seqNum;
@@ -594,7 +606,7 @@ t_Error  FmHcPcdKgSetSchemeCounter(t_Handle h_FmHc, t_Handle h_Scheme, uint32_t
     }
 
     /* Write scheme back, with modified counter */
-    hcFrame.opcode = 0x00000001;
+    hcFrame.opcode = (uint32_t)(HC_HCOR_GBL | HC_HCOR_OPCODE_KG_SCM);
     hcFrame.actionReg  = FmPcdKgBuildWriteSchemeActionReg(physicalSchemeId, TRUE);
     hcFrame.extraReg = 0xFFFFF800;
     hcFrame.commandSequence = p_FmHc->seqNum;
@@ -693,7 +705,7 @@ t_Handle FmHcPcdPlcrSetProfile(t_Handle h_FmHc,t_FmPcdPlcrProfileParams *p_Profi
     if(!p_Profile->modify)
     {
         memset(&hcFrame, 0, sizeof(hcFrame));
-        hcFrame.opcode = 0x00000000;
+        hcFrame.opcode = (uint32_t)(HC_HCOR_GBL | HC_HCOR_OPCODE_PLCR_PRFL);
         hcFrame.actionReg  = FmPcdPlcrBuildReadPlcrActionReg(profileIndx);
         hcFrame.extraReg = 0x00008000;
         hcFrame.commandSequence = p_FmHc->seqNum;
@@ -721,7 +733,7 @@ t_Handle FmHcPcdPlcrSetProfile(t_Handle h_FmHc,t_FmPcdPlcrProfileParams *p_Profi
     }
 
     memset(&hcFrame, 0, sizeof(hcFrame));
-    hcFrame.opcode = 0x00000000;
+    hcFrame.opcode = (uint32_t)(HC_HCOR_GBL | HC_HCOR_OPCODE_PLCR_PRFL);
     hcFrame.actionReg  = FmPcdPlcrBuildWritePlcrActionRegs(profileIndx);
     hcFrame.extraReg = 0x00008000;
     hcFrame.commandSequence = p_FmHc->seqNum;
@@ -751,7 +763,7 @@ t_Error FmHcPcdPlcrDeleteProfile(t_Handle h_FmHc, t_Handle h_Profile)
 
     FmPcdPlcrInvalidateProfileSw(p_FmHc->h_FmPcd, absoluteProfileId);
     memset(&hcFrame, 0, sizeof(hcFrame));
-    hcFrame.opcode = 0x00000000;
+    hcFrame.opcode = (uint32_t)(HC_HCOR_GBL | HC_HCOR_OPCODE_PLCR_PRFL);
     hcFrame.actionReg  = FmPcdPlcrBuildWritePlcrActionReg(absoluteProfileId);
     hcFrame.actionReg  |= 0x00008000;
     hcFrame.extraReg = 0x00008000;
@@ -781,7 +793,7 @@ t_Error  FmHcPcdPlcrSetProfileCounter(t_Handle h_FmHc, t_Handle h_Profile, e_FmP
 
     /* first read scheme and check that it is valid */
     memset(&hcFrame, 0, sizeof(hcFrame));
-    hcFrame.opcode = 0x00000000;
+    hcFrame.opcode = (uint32_t)(HC_HCOR_GBL | HC_HCOR_OPCODE_PLCR_PRFL);
     hcFrame.actionReg  = FmPcdPlcrBuildReadPlcrActionReg(absoluteProfileId);
     hcFrame.extraReg = 0x00008000;
     hcFrame.commandSequence = p_FmHc->seqNum;
@@ -797,7 +809,7 @@ t_Error  FmHcPcdPlcrSetProfileCounter(t_Handle h_FmHc, t_Handle h_Profile, e_FmP
         RETURN_ERROR(MAJOR, E_ALREADY_EXISTS, ("Policer is already used"));
     }
 
-    hcFrame.opcode = 0x00000000;
+    hcFrame.opcode = (uint32_t)(HC_HCOR_GBL | HC_HCOR_OPCODE_PLCR_PRFL);
     hcFrame.actionReg  = FmPcdPlcrBuildWritePlcrActionReg(absoluteProfileId);
     hcFrame.actionReg |= FmPcdPlcrBuildCounterProfileReg(counter);
     hcFrame.extraReg = 0x00008000;
@@ -829,7 +841,7 @@ uint32_t FmHcPcdPlcrGetProfileCounter(t_Handle h_FmHc, t_Handle h_Profile, e_FmP
 
     /* first read scheme and check that it is valid */
     memset(&hcFrame, 0, sizeof(hcFrame));
-    hcFrame.opcode = 0x00000000;
+    hcFrame.opcode = (uint32_t)(HC_HCOR_GBL | HC_HCOR_OPCODE_PLCR_PRFL);
     hcFrame.actionReg  = FmPcdPlcrBuildReadPlcrActionReg(absoluteProfileId);
     hcFrame.extraReg = 0x00008000;
     hcFrame.commandSequence = p_FmHc->seqNum;
@@ -842,7 +854,7 @@ uint32_t FmHcPcdPlcrGetProfileCounter(t_Handle h_FmHc, t_Handle h_Profile, e_FmP
     if (!FmPcdPlcrHwProfileIsValid(hcFrame.hcSpecificData.profileRegs.fmpl_pemode))
     {
         FmPcdPlcrReleaseProfileLock(p_FmHc->h_FmPcd, absoluteProfileId);
-        RETURN_ERROR(MAJOR, E_ALREADY_EXISTS, ("Policer is already used"));
+        RETURN_ERROR(MAJOR, E_ALREADY_EXISTS, ("invalid Policer profile"));
     }
 
     switch (counter)
@@ -1123,7 +1135,7 @@ t_Error FmHcKgWriteSp(t_Handle h_FmHc, uint8_t hardwarePortId, uint32_t spReg, b
 
     memset(&hcFrame, 0, sizeof(hcFrame));
     /* first read SP register */
-    hcFrame.opcode = 0x00000001;
+    hcFrame.opcode = (uint32_t)(HC_HCOR_GBL | HC_HCOR_OPCODE_KG_SCM);
     hcFrame.actionReg  = FmPcdKgBuildReadPortSchemeBindActionReg(hardwarePortId);
     hcFrame.extraReg = 0xFFFFF800;
     hcFrame.commandSequence = p_FmHc->seqNum;
@@ -1132,7 +1144,7 @@ t_Error FmHcKgWriteSp(t_Handle h_FmHc, uint8_t hardwarePortId, uint32_t spReg, b
 
     ENQUEUE_FRM(&fmFd);
 
-    /* spReg is the first reg, so we can use it bothe for read and for write */
+    /* spReg is the first reg, so we can use it both for read and for write */
     if(add)
         hcFrame.hcSpecificData.portRegsForRead.spReg |= spReg;
     else
@@ -1159,7 +1171,7 @@ t_Error FmHcKgWriteCpp(t_Handle h_FmHc, uint8_t hardwarePortId, uint32_t cppReg)
 
     memset(&hcFrame, 0, sizeof(hcFrame));
     /* first read SP register */
-    hcFrame.opcode = 0x00000001;
+    hcFrame.opcode = (uint32_t)(HC_HCOR_GBL | HC_HCOR_OPCODE_KG_SCM);
     hcFrame.actionReg  = FmPcdKgBuildWritePortClsPlanBindActionReg(hardwarePortId);
     hcFrame.extraReg = 0xFFFFF800;
     hcFrame.commandSequence = p_FmHc->seqNum;
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/Makefile b/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/Makefile
index 7c63f97..3ff264d 100644
--- a/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/Makefile
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/Makefile
@@ -12,7 +12,3 @@ EXTRA_CFLAGS += -I$(NCSW_FM_INC)
 obj-y		+= fsl-ncsw-MAC.o
 
 fsl-ncsw-MAC-objs	:=   dtsec.o dtsec_mii_acc.o fm_mac.o tgec.o tgec_mii_acc.o
-
-
-
-
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.c b/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.c
index f1e12e7..98e4c70 100644
--- a/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.c
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -61,7 +61,8 @@ static t_Error CheckInitParameters(t_Dtsec *p_Dtsec)
     if(p_Dtsec->addr == 0)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Ethernet 10G MAC Must have a valid MAC Address"));
     if(((p_Dtsec->enetMode == e_ENET_MODE_SGMII_1000) ||
-        (p_Dtsec->enetMode == e_ENET_MODE_RGMII_1000)) &&
+        (p_Dtsec->enetMode == e_ENET_MODE_RGMII_1000) ||
+        (p_Dtsec->enetMode == e_ENET_MODE_QSGMII_1000)) &&
         p_Dtsec->p_DtsecDriverParam->halfDuplex)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Ethernet MAC 1G can't work in halfDuplex"));
     if(p_Dtsec->p_DtsecDriverParam->halfDuplex && (p_Dtsec->p_DtsecDriverParam)->loopback)
@@ -96,12 +97,59 @@ static t_Error CheckInitParameters(t_Dtsec *p_Dtsec)
     return E_OK;
 }
 
+static uint8_t GetMiiDiv(uint32_t refClk)
+{
+#define ABS(a) ((a<0)?(a*-1):a)
+    uint32_t    div,tmpClk;
+    int         minRange;
+
+    div = 1;
+    minRange = (int)(refClk/40 - 1);
+
+    tmpClk = ABS(refClk/60 - 1);
+    if (tmpClk < minRange)
+    {
+        div = 2;
+        minRange = (int)tmpClk;
+    }
+    tmpClk = ABS(refClk/60 - 1);
+    if (tmpClk < minRange)
+    {
+        div = 3;
+        minRange = (int)tmpClk;
+    }
+    tmpClk = ABS(refClk/80 - 1);
+    if (tmpClk < minRange)
+    {
+        div = 4;
+        minRange = (int)tmpClk;
+    }
+    tmpClk = ABS(refClk/100 - 1);
+    if (tmpClk < minRange)
+    {
+        div = 5;
+        minRange = (int)tmpClk;
+    }
+    tmpClk = ABS(refClk/140 - 1);
+    if (tmpClk < minRange)
+    {
+        div = 6;
+        minRange = (int)tmpClk;
+    }
+    tmpClk = ABS(refClk/280 - 1);
+    if (tmpClk < minRange)
+    {
+        div = 7;
+        minRange = (int)tmpClk;
+    }
+
+    return (uint8_t)div;
+}
+
 /* ........................................................................... */
 
-static void SetDefaultParam(t_Dtsec *p_Dtsec, t_DtsecDriverParam *p_DtsecDriverParam)
+static void SetDefaultParam(t_DtsecDriverParam *p_DtsecDriverParam)
 {
-    UNUSED(p_Dtsec);
-
     p_DtsecDriverParam->errorDisabled       = DEFAULT_errorDisabled;
 
     p_DtsecDriverParam->autoZeroCounters    = DEFAULT_autoZeroCounters;
@@ -132,7 +180,6 @@ static void SetDefaultParam(t_Dtsec *p_Dtsec, t_DtsecDriverParam *p_DtsecDriverP
     p_DtsecDriverParam->preambleLength         = DEFAULT_PreAmLength;
     p_DtsecDriverParam->preambleRxEn           = DEFAULT_PreAmRxEn;
     p_DtsecDriverParam->preambleTxEn           = DEFAULT_PreAmTxEn;
-    p_DtsecDriverParam->hugeFramesEnable       = DEFAULT_hugeFrames;
     p_DtsecDriverParam->lengthCheckEnable      = DEFAULT_lengthCheckEnable;
     p_DtsecDriverParam->padAndCrcEnable        = DEFAULT_padAndCrcEnable;
     p_DtsecDriverParam->crcEnable              = DEFAULT_crcEnable;
@@ -177,25 +224,21 @@ static void DtsecException(t_Handle h_Dtsec)
         WRITE_UINT32(p_DtsecMemMap->ievent, event);
 
         if(event & IMASK_MMRDEN)
-            p_Dtsec->f_Events(p_Dtsec->h_App, e_FM_MAC_EX_1G_MII_MNG_RD_COMPLET);
+            p_Dtsec->f_Event(p_Dtsec->h_App, e_FM_MAC_EX_1G_MII_MNG_RD_COMPLET);
         if(event & IMASK_MMWREN)
-            p_Dtsec->f_Events(p_Dtsec->h_App, e_FM_MAC_EX_1G_MII_MNG_WR_COMPLET);
+            p_Dtsec->f_Event(p_Dtsec->h_App, e_FM_MAC_EX_1G_MII_MNG_WR_COMPLET);
     }
-    if (p_Dtsec->structFor1588.enErrExeption)
+    if (p_Dtsec->ptpTsuEnabled)
     {
         event = GET_UINT32(p_DtsecMemMap->tmr_pevent);
         event &= GET_UINT32(p_DtsecMemMap->tmr_pemask);
         if(event)
         {
             WRITE_UINT32(p_DtsecMemMap->tmr_pevent, event);
-
-            if(event & PEMASK_TSRE)
-                p_Dtsec->f_Exceptions(p_Dtsec->h_App, e_FM_MAC_EX_1G_1588_TS_RX_ERR);
+            ASSERT_COND(event & PEMASK_TSRE);
+            p_Dtsec->f_Exception(p_Dtsec->h_App, e_FM_MAC_EX_1G_1588_TS_RX_ERR);
         }
-/* TODO - For Moti */
- /*       if(event & PEMASK_EVENTS)*/
     }
-
 }
 
 static void DtsecErrException(t_Handle h_Dtsec)
@@ -213,58 +256,39 @@ static void DtsecErrException(t_Handle h_Dtsec)
     WRITE_UINT32(p_DtsecMemMap->ievent, event);
 
     if(event & IMASK_BREN)
-        p_Dtsec->f_Exceptions(p_Dtsec->h_App, e_FM_MAC_EX_1G_BAB_RX);
+        p_Dtsec->f_Exception(p_Dtsec->h_App, e_FM_MAC_EX_1G_BAB_RX);
     if(event & IMASK_RXCEN)
-        p_Dtsec->f_Exceptions(p_Dtsec->h_App, e_FM_MAC_EX_1G_RX_CTL);
+        p_Dtsec->f_Exception(p_Dtsec->h_App, e_FM_MAC_EX_1G_RX_CTL);
     if(event & IMASK_MSROEN)
-        p_Dtsec->f_Exceptions(p_Dtsec->h_App, e_FM_MAC_EX_1G_MIB_CNT_OVFL);
+        p_Dtsec->f_Exception(p_Dtsec->h_App, e_FM_MAC_EX_1G_MIB_CNT_OVFL);
     if(event & IMASK_GTSCEN)
-        p_Dtsec->f_Exceptions(p_Dtsec->h_App, e_FM_MAC_EX_1G_GRATEFUL_TX_STP_COMPLET);
+        p_Dtsec->f_Exception(p_Dtsec->h_App, e_FM_MAC_EX_1G_GRATEFUL_TX_STP_COMPLET);
     if(event & IMASK_BTEN)
-        p_Dtsec->f_Exceptions(p_Dtsec->h_App, e_FM_MAC_EX_1G_BAB_TX);
+        p_Dtsec->f_Exception(p_Dtsec->h_App, e_FM_MAC_EX_1G_BAB_TX);
     if(event & IMASK_TXCEN)
-        p_Dtsec->f_Exceptions(p_Dtsec->h_App, e_FM_MAC_EX_1G_TX_CTL);
+        p_Dtsec->f_Exception(p_Dtsec->h_App, e_FM_MAC_EX_1G_TX_CTL);
     if(event & IMASK_TXEEN)
-        p_Dtsec->f_Exceptions(p_Dtsec->h_App, e_FM_MAC_EX_1G_TX_ERR);
+        p_Dtsec->f_Exception(p_Dtsec->h_App, e_FM_MAC_EX_1G_TX_ERR);
     if(event & IMASK_LCEN)
-        p_Dtsec->f_Exceptions(p_Dtsec->h_App, e_FM_MAC_EX_1G_LATE_COL);
+        p_Dtsec->f_Exception(p_Dtsec->h_App, e_FM_MAC_EX_1G_LATE_COL);
     if(event & IMASK_CRLEN)
-        p_Dtsec->f_Exceptions(p_Dtsec->h_App, e_FM_MAC_EX_1G_COL_RET_LMT);
+        p_Dtsec->f_Exception(p_Dtsec->h_App, e_FM_MAC_EX_1G_COL_RET_LMT);
     if(event & IMASK_XFUNEN)
-        p_Dtsec->f_Exceptions(p_Dtsec->h_App, e_FM_MAC_EX_1G_TX_FIFO_UNDRN);
+        p_Dtsec->f_Exception(p_Dtsec->h_App, e_FM_MAC_EX_1G_TX_FIFO_UNDRN);
     if(event & IMASK_MAGEN)
-        p_Dtsec->f_Exceptions(p_Dtsec->h_App, e_FM_MAC_EX_1G_MAG_PCKT);
+        p_Dtsec->f_Exception(p_Dtsec->h_App, e_FM_MAC_EX_1G_MAG_PCKT);
     if(event & IMASK_GRSCEN)
-        p_Dtsec->f_Exceptions(p_Dtsec->h_App, e_FM_MAC_EX_1G_GRATEFUL_RX_STP_COMPLET);
+        p_Dtsec->f_Exception(p_Dtsec->h_App, e_FM_MAC_EX_1G_GRATEFUL_RX_STP_COMPLET);
     if(event & IMASK_TDPEEN)
-        p_Dtsec->f_Exceptions(p_Dtsec->h_App, e_FM_MAC_EX_1G_TX_DATA_ERR);
+        p_Dtsec->f_Exception(p_Dtsec->h_App, e_FM_MAC_EX_1G_TX_DATA_ERR);
     if(event & IMASK_RDPEEN)
-        p_Dtsec->f_Exceptions(p_Dtsec->h_App, e_FM_MAC_EX_1G_RX_DATA_ERR);
+        p_Dtsec->f_Exception(p_Dtsec->h_App, e_FM_MAC_EX_1G_RX_DATA_ERR);
 
     /*  - masked interrupts */
     ASSERT_COND(!(event & IMASK_ABRTEN));
     ASSERT_COND(!(event & IMASK_IFERREN));
 }
 
-/*
-static void Tmr1588Exception(t_Handle h_Dtsec)
-{
-    t_Dtsec             *p_Dtsec = (t_Dtsec *)h_Dtsec;
-    uint32_t            event;
-    t_DtsecMemMap       *p_DtsecMemMap = p_Dtsec->p_MemMap;
-
-    ASSERT_COND(p_Dtsec->support1588);
-
-    event = GET_UINT32(p_DtsecMemMap->tmr_pevent);
-    event &= GET_UINT32(p_DtsecMemMap->tmr_pemask);
-
-    WRITE_UINT32(p_DtsecMemMap->tmr_pevent, event);
-
-    if(event & PEMASK_TSRE)
-        p_Dtsec->f_Exceptions(p_Dtsec->h_App, e_FM_MAC_EX_1G_1588_TS_RX_ERR);
-
-}
-*/
 
 /* ........................................................................... */
 
@@ -306,24 +330,48 @@ static void HardwareAddAddrInPaddr(t_Dtsec *p_Dtsec, uint64_t *p_Addr, uint8_t p
 
 /* ........................................................................... */
 
-static void rxGracefulStop(t_Dtsec *p_Dtsec)
+static t_Error GracefulStop(t_Dtsec *p_Dtsec, e_CommMode mode)
 {
-    t_DtsecMemMap *p_MemMap = (t_DtsecMemMap*)(p_Dtsec->p_MemMap);
-    WRITE_UINT32(p_MemMap->rctrl,
-                  GET_UINT32(p_MemMap->rctrl) | RCTRL_GRS);
+    t_DtsecMemMap   *p_MemMap;
+
+    ASSERT_COND(p_Dtsec);
+
+    p_MemMap= (t_DtsecMemMap*)(p_Dtsec->p_MemMap);
+    ASSERT_COND(p_MemMap);
+
+    /* Assert the graceful transmit stop bit */
+    if (mode & e_COMM_MODE_RX)
+        WRITE_UINT32(p_MemMap->rctrl,
+                     GET_UINT32(p_MemMap->rctrl) | RCTRL_GRS);
+
+    if (mode & e_COMM_MODE_TX)
+        WRITE_UINT32(p_MemMap->tctrl,
+                     GET_UINT32(p_MemMap->tctrl) | TCTRL_GTS);
+
+    return E_OK;
 }
 
-/* ........................................................................... */
+/* .............................................................................. */
 
-static void txGracefulStop(t_Dtsec *p_Dtsec)
+static t_Error GracefulRestart(t_Dtsec *p_Dtsec, e_CommMode mode)
 {
-    t_DtsecMemMap *p_MemMap = (t_DtsecMemMap*)(p_Dtsec->p_MemMap);
+    t_DtsecMemMap   *p_MemMap;
 
-    SANITY_CHECK_RETURN(p_Dtsec, E_INVALID_HANDLE);
+    ASSERT_COND(p_Dtsec);
 
-    /* Assert the graceful transmit stop bit */
-    WRITE_UINT32(p_MemMap->tctrl,
-                  GET_UINT32(p_MemMap->tctrl) | TCTRL_GTS);
+    p_MemMap= (t_DtsecMemMap*)(p_Dtsec->p_MemMap);
+    ASSERT_COND(p_MemMap);
+
+    /* clear the graceful receive stop bit */
+    if(mode & e_COMM_MODE_TX)
+        WRITE_UINT32(p_MemMap->tctrl,
+                      GET_UINT32(p_MemMap->tctrl) & ~TCTRL_GTS);
+
+    if(mode & e_COMM_MODE_RX)
+        WRITE_UINT32(p_MemMap->rctrl,
+                      GET_UINT32(p_MemMap->rctrl) & ~RCTRL_GRS);
+
+    return E_OK;
 }
 
 /*****************************************************************************/
@@ -341,6 +389,7 @@ static t_Error DtsecInit(t_Handle h_Dtsec)
     bool                isSgmii = FALSE, isResetCnfgSgmiiMode = FALSE;
     bool                isReducedPin = FALSE,  isResetCnfgReducedPin = FALSE;
     bool                is100 = FALSE,  isResetCnfg100 = FALSE;
+    bool                isQSgmii = FALSE, isResetCnfgQSgmiiMode = FALSE;
     int                 i;
     uint32_t            tmpReg32;
     uint64_t            addr;
@@ -361,7 +410,9 @@ static t_Error DtsecInit(t_Handle h_Dtsec)
 
     if ((p_Dtsec->enetMode == e_ENET_MODE_RGMII_10) ||
         (p_Dtsec->enetMode == e_ENET_MODE_RGMII_100) ||
-        (p_Dtsec->enetMode == e_ENET_MODE_RGMII_1000))
+        (p_Dtsec->enetMode == e_ENET_MODE_RGMII_1000) ||
+        (p_Dtsec->enetMode == e_ENET_MODE_RMII_10) ||
+        (p_Dtsec->enetMode == e_ENET_MODE_RMII_100))
         if(tmpReg32 & ID2_INT_REDUCED_OFF)
         {
              RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("no support for reduced interface in current DTSEC version"));
@@ -369,7 +420,9 @@ static t_Error DtsecInit(t_Handle h_Dtsec)
 
     if ((p_Dtsec->enetMode == e_ENET_MODE_SGMII_10) ||
         (p_Dtsec->enetMode == e_ENET_MODE_SGMII_100) ||
-        (p_Dtsec->enetMode == e_ENET_MODE_SGMII_1000))
+        (p_Dtsec->enetMode == e_ENET_MODE_SGMII_1000)||
+        (p_Dtsec->enetMode == e_ENET_MODE_MII_10)    ||
+        (p_Dtsec->enetMode == e_ENET_MODE_MII_100))
         if(tmpReg32 & ID2_INT_NORMAL_OFF)
         {
              RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("no support for normal interface in current DTSEC version"));
@@ -384,31 +437,41 @@ static t_Error DtsecInit(t_Handle h_Dtsec)
     tmpReg32 = GET_UINT32(p_DtsecMemMap->ecntrl);
     if(tmpReg32 & ECNTRL_CFG_RO)
     {
-        isRgmii = (( p_Dtsec->enetMode == e_ENET_MODE_RGMII_10)   ||
-                            (p_Dtsec->enetMode == e_ENET_MODE_RGMII_100)  ||
-                            (p_Dtsec->enetMode == e_ENET_MODE_RGMII_1000) ||(p_Dtsec->enetMode == e_ENET_MODE_GMII_1000)) ? TRUE : FALSE;
-        isResetCnfgRgmiiMode= (tmpReg32 & ECNTRL_GMIIM) ? TRUE : FALSE;
+        isRgmii = (bool)(((p_Dtsec->enetMode == e_ENET_MODE_RGMII_10)   ||
+                          (p_Dtsec->enetMode == e_ENET_MODE_RGMII_100)  ||
+                          (p_Dtsec->enetMode == e_ENET_MODE_RGMII_1000) ||
+                          (p_Dtsec->enetMode == e_ENET_MODE_GMII_1000)) ? TRUE : FALSE);
+        isResetCnfgRgmiiMode = (bool)((tmpReg32 & ECNTRL_GMIIM) ? TRUE : FALSE);
         if((isRgmii && !isResetCnfgRgmiiMode) ||
             (!isRgmii && isResetCnfgRgmiiMode))
           RETURN_ERROR(MAJOR, E_CONFLICT,(" Error. Reduced mode not configured properly. Check eTsec cfg switch \n"));
 
-        isSgmii = (( p_Dtsec->enetMode == e_ENET_MODE_SGMII_10)   ||
-                            (p_Dtsec->enetMode == e_ENET_MODE_SGMII_100)  ||
-                            (p_Dtsec->enetMode == e_ENET_MODE_SGMII_1000)) ? TRUE : FALSE;
-        isResetCnfgSgmiiMode = (tmpReg32 & ECNTRL_SGMIIM) ? TRUE : FALSE;
+        isSgmii = (bool)(((p_Dtsec->enetMode == e_ENET_MODE_SGMII_10)   ||
+                          (p_Dtsec->enetMode == e_ENET_MODE_SGMII_100)  ||
+                          (p_Dtsec->enetMode == e_ENET_MODE_SGMII_1000)) ? TRUE : FALSE);
+        isResetCnfgSgmiiMode = (bool)((tmpReg32 & ECNTRL_SGMIIM) ? TRUE : FALSE);
         if((isSgmii && !isResetCnfgSgmiiMode) ||
             (!isSgmii && isResetCnfgSgmiiMode))
           RETURN_ERROR(MAJOR, E_CONFLICT,(" Error. SGMII mode not configured properly. Check dTsec cfg switch \n"));
 
-        isReducedPin = ((p_Dtsec->enetMode == e_ENET_MODE_RGMII_1000) || (p_Dtsec->enetMode == e_ENET_MODE_RGMII_100) ||
-                            (p_Dtsec->enetMode == e_ENET_MODE_RGMII_10)) ? TRUE : FALSE;
-        isResetCnfgReducedPin= (tmpReg32 & ECNTRL_RPM) ? TRUE : FALSE;
+
+        isQSgmii = (bool)(( p_Dtsec->enetMode == e_ENET_MODE_QSGMII_1000)  ? TRUE : FALSE);
+        isResetCnfgQSgmiiMode = (bool)((tmpReg32 & ECNTRL_QSGMIIM) ? TRUE : FALSE);
+        if((isQSgmii && !isResetCnfgQSgmiiMode) ||
+            (!isQSgmii && isResetCnfgQSgmiiMode))
+          RETURN_ERROR(MAJOR, E_CONFLICT,(" Error. QSGMII mode not configured properly. Check dTsec cfg switch \n"));
+
+       isReducedPin = (bool)(((p_Dtsec->enetMode == e_ENET_MODE_RGMII_1000) ||
+                               (p_Dtsec->enetMode == e_ENET_MODE_RGMII_100) ||
+                               (p_Dtsec->enetMode == e_ENET_MODE_RGMII_10)) ? TRUE : FALSE);
+        isResetCnfgReducedPin = (bool)((tmpReg32 & ECNTRL_RPM) ? TRUE : FALSE);
         if((isReducedPin && !isResetCnfgReducedPin) || (!isReducedPin && isResetCnfgReducedPin))
           RETURN_ERROR(MAJOR, E_CONFLICT,(" Error. reduced pin interface is not configured properly. Check dTsec cfg switch \n"));
 
-        is100 = (( p_Dtsec->enetMode == e_ENET_MODE_SGMII_100)   ||
-                            (p_Dtsec->enetMode == e_ENET_MODE_RGMII_100)) ? TRUE : FALSE;
-        isResetCnfg100 = (tmpReg32 & ECNTRL_R100M) ? TRUE : FALSE;
+        is100 = (bool)(((p_Dtsec->enetMode == e_ENET_MODE_SGMII_100)   ||
+                        (p_Dtsec->enetMode == e_ENET_MODE_RGMII_100)   ||
+                        (p_Dtsec->enetMode == e_ENET_MODE_RMII_100)) ? TRUE : FALSE);
+        isResetCnfg100 = (bool)((tmpReg32 & ECNTRL_R100M) ? TRUE : FALSE);
         if((is100 && !isResetCnfg100) ||
             (!is100 && isResetCnfg100))
           RETURN_ERROR(MAJOR, E_CONFLICT,(" Error. 100 speed interface is not configured properly. Check dTsec cfg switch \n"));
@@ -416,19 +479,27 @@ static t_Error DtsecInit(t_Handle h_Dtsec)
     else
     {
       tmpReg32 = 0;
-      if((p_Dtsec->enetMode == e_ENET_MODE_RGMII_10)                     ||
-                           (p_Dtsec->enetMode == e_ENET_MODE_RGMII_100)  ||
-                            (p_Dtsec->enetMode == e_ENET_MODE_RGMII_1000)  || (p_Dtsec->enetMode == e_ENET_MODE_GMII_1000))
+      if ((p_Dtsec->enetMode == e_ENET_MODE_RGMII_10) ||
+          (p_Dtsec->enetMode == e_ENET_MODE_RGMII_100) ||
+          (p_Dtsec->enetMode == e_ENET_MODE_RGMII_1000) ||
+          (p_Dtsec->enetMode == e_ENET_MODE_GMII_1000))
             tmpReg32 |= ECNTRL_GMIIM;
-      if((p_Dtsec->enetMode == e_ENET_MODE_SGMII_10)   ||
+      if ((p_Dtsec->enetMode == e_ENET_MODE_SGMII_10)   ||
           (p_Dtsec->enetMode == e_ENET_MODE_SGMII_100)  ||
           (p_Dtsec->enetMode == e_ENET_MODE_SGMII_1000))
             tmpReg32 |= (ECNTRL_SGMIIM | ECNTRL_TBIM);
-       if((p_Dtsec->enetMode == e_ENET_MODE_RGMII_1000) || (p_Dtsec->enetMode == e_ENET_MODE_RGMII_10)||
-                (p_Dtsec->enetMode == e_ENET_MODE_RGMII_100))
+      if(p_Dtsec->enetMode == e_ENET_MODE_QSGMII_1000)
+            tmpReg32 |= (ECNTRL_SGMIIM | ECNTRL_TBIM | ECNTRL_QSGMIIM);
+      if ((p_Dtsec->enetMode == e_ENET_MODE_RGMII_1000) ||
+           (p_Dtsec->enetMode == e_ENET_MODE_RGMII_10)||
+           (p_Dtsec->enetMode == e_ENET_MODE_RGMII_100))
             tmpReg32 |= ECNTRL_RPM;
-       if((p_Dtsec->enetMode == e_ENET_MODE_RGMII_100) || (p_Dtsec->enetMode == e_ENET_MODE_SGMII_100))
+       if((p_Dtsec->enetMode == e_ENET_MODE_RGMII_100) ||
+            (p_Dtsec->enetMode == e_ENET_MODE_SGMII_100) ||
+            (p_Dtsec->enetMode == e_ENET_MODE_RMII_100))
             tmpReg32 |= ECNTRL_R100M;
+       if((p_Dtsec->enetMode == e_ENET_MODE_RMII_10) || (p_Dtsec->enetMode == e_ENET_MODE_RMII_100))
+            tmpReg32 |= ECNTRL_RMM;
     }
 
     if (p_DtsecDriverParam->autoZeroCounters)
@@ -441,6 +512,14 @@ static t_Error DtsecInit(t_Handle h_Dtsec)
     /***************PTV************************/
     /* initialize PTV */
     tmpReg32 = 0;
+#ifdef FM_1G_SHORT_PAUSE_TIME_ERRATA_DTSEC1
+    {
+        t_FmRevisionInfo revInfo;
+        FmGetRevision(p_Dtsec->fmMacControllerDriver.h_Fm, &revInfo);
+        if ((revInfo.majorRev == 1) && (revInfo.minorRev == 0))
+            p_DtsecDriverParam->pauseTime += 2;
+    }
+#endif /* FM_1G_SHORT_PAUSE_TIME_ERRATA_DTSEC1 */
     if (p_DtsecDriverParam->pauseTime)
         tmpReg32 |= (uint32_t)p_DtsecDriverParam->pauseTime;
 
@@ -484,6 +563,7 @@ static t_Error DtsecInit(t_Handle h_Dtsec)
         tmpReg32 |= RCTRL_EMEN;
 
     WRITE_UINT32(p_DtsecMemMap->rctrl, tmpReg32);
+    /***************RCTRL************************/
 
     /* Assign a Phy Address to the TBI (TBIPA).            */
     /* Done also in case that TBI is not selected to avoid */
@@ -491,11 +571,13 @@ static t_Error DtsecInit(t_Handle h_Dtsec)
     WRITE_UINT32(p_DtsecMemMap->tbipa, p_DtsecDriverParam->tbiPhyAddr);
 
     /* Reset the management interface */
-    WRITE_UINT32(p_DtsecMemMap->miimcfg, MIIMCFG_RESET_MGMT);
-
+    WRITE_UINT32(p_Dtsec->p_MiiMemMap->miimcfg, MIIMCFG_RESET_MGMT);
+    WRITE_UINT32(p_Dtsec->p_MiiMemMap->miimcfg, ~MIIMCFG_RESET_MGMT);
     /* Setup the MII Mgmt clock speed */
-    WRITE_UINT32(p_DtsecMemMap->miimcfg, MIIMCFG_MGMT_CLOCK_SELECT);
+    WRITE_UINT32(p_Dtsec->p_MiiMemMap->miimcfg,
+                 (uint32_t)GetMiiDiv((uint32_t)(((p_Dtsec->fmMacControllerDriver.clkFreq*10)/2)/8)));
 
+#ifndef VERIFICATION_SUPPORT
     if(p_Dtsec->enetMode == e_ENET_MODE_SGMII_1000)
     {
         uint16_t            tmpReg16;
@@ -520,7 +602,10 @@ static t_Error DtsecInit(t_Handle h_Dtsec)
         tmpReg16 = 0x1340;
         DTSEC_MII_WritePhyReg(p_Dtsec, p_DtsecDriverParam->tbiPhyAddr, 0, tmpReg16);
     }
-    /***************RCTRL************************/
+#endif /* VERIFICATION_SUPPORT */
+
+    /***************TMR_CTL************************/
+    WRITE_UINT32(p_DtsecMemMap->tmr_ctrl, 0);
 
     /***************IMASK************************/
     WRITE_UINT32(p_DtsecMemMap->imask, p_Dtsec->exceptions);
@@ -529,10 +614,10 @@ static t_Error DtsecInit(t_Handle h_Dtsec)
     /***************IEVENT************************/
     WRITE_UINT32(p_DtsecMemMap->ievent, EVENTS_MASK);
 
-    if(p_Dtsec->support1588)
+    if(p_Dtsec->ptpTsuEnabled)
     {
-        tmpReg32 = PEMASK_EVENTS;
-        if (p_Dtsec->structFor1588.enErrExeption)
+        tmpReg32 = 0;
+        if (p_Dtsec->enTsuErrExeption)
             tmpReg32 |= PEMASK_TSRE;
         WRITE_UINT32(p_DtsecMemMap->tmr_pemask, tmpReg32);
         WRITE_UINT32(p_DtsecMemMap->tmr_pevent, tmpReg32);
@@ -559,14 +644,19 @@ static t_Error DtsecInit(t_Handle h_Dtsec)
 
     /***************MACCFG2***********************/
     tmpReg32 = 0;
-    if((p_Dtsec->enetMode == e_ENET_MODE_RGMII_10) ||
+    if( (p_Dtsec->enetMode == e_ENET_MODE_RMII_10)  ||
+        (p_Dtsec->enetMode == e_ENET_MODE_RMII_100) ||
+        (p_Dtsec->enetMode == e_ENET_MODE_MII_10)   ||
+        (p_Dtsec->enetMode == e_ENET_MODE_MII_100)  ||
+        (p_Dtsec->enetMode == e_ENET_MODE_RGMII_10) ||
         (p_Dtsec->enetMode == e_ENET_MODE_RGMII_100)||
         (p_Dtsec->enetMode == e_ENET_MODE_SGMII_10) ||
         (p_Dtsec->enetMode == e_ENET_MODE_SGMII_100))
             tmpReg32 |= MACCFG2_NIBBLE_MODE;
     else if((p_Dtsec->enetMode == e_ENET_MODE_RGMII_1000) ||
         (p_Dtsec->enetMode == e_ENET_MODE_SGMII_1000)||
-        (p_Dtsec->enetMode == e_ENET_MODE_GMII_1000))
+        (p_Dtsec->enetMode == e_ENET_MODE_GMII_1000)||
+        (p_Dtsec->enetMode == e_ENET_MODE_QSGMII_1000))
             tmpReg32 |= MACCFG2_BYTE_MODE;
 
     tmpReg32 |= (((uint32_t)p_DtsecDriverParam->preambleLength) & 0x0000000f)<< PREAMBLE_LENGTH_SHIFT;
@@ -575,14 +665,12 @@ static t_Error DtsecInit(t_Handle h_Dtsec)
         tmpReg32 |= MACCFG2_PRE_AM_Rx_EN;
     if(p_DtsecDriverParam->preambleTxEn)
         tmpReg32 |= MACCFG2_PRE_AM_Tx_EN;
-    if(p_DtsecDriverParam->hugeFramesEnable)
-        tmpReg32 |= MACCFG2_HUGE_FRAME;
     if(p_DtsecDriverParam->lengthCheckEnable)
         tmpReg32 |= MACCFG2_LENGTH_CHECK;
     if(p_DtsecDriverParam->padAndCrcEnable)
         tmpReg32 |=  MACCFG2_PAD_CRC_EN;
     if(p_DtsecDriverParam->crcEnable)
-        tmpReg32 |= MACCFG2_CRC_EN ;
+        tmpReg32 |= MACCFG2_CRC_EN;
     if(!p_DtsecDriverParam->halfDuplex)
         tmpReg32 |= MACCFG2_FULL_DUPLEX;
     WRITE_UINT32(p_DtsecMemMap->maccfg2, tmpReg32);
@@ -795,14 +883,23 @@ static t_Error DtsecConfigHalfDuplex(t_Handle h_Dtsec, bool newVal)
 
 /* .............................................................................. */
 
-static t_Error DtsecConfigHugeFrames(t_Handle h_Dtsec, bool newVal)
+static t_Error DtsecConfigLengthCheck(t_Handle h_Dtsec, bool newVal)
 {
     t_Dtsec *p_Dtsec = (t_Dtsec *)h_Dtsec;
 
     SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Dtsec->p_DtsecDriverParam, E_INVALID_STATE);
+#ifdef BUP_FM_LEN_CHECK_ERRATA
+    {
+        t_FmRevisionInfo revInfo;
+        FmGetRevision(p_Dtsec->fmMacControllerDriver.h_Fm, &revInfo);
+        if (((revInfo.majorRev == 1) && (revInfo.minorRev == 0)) ||
+                ((revInfo.majorRev == 2) && (revInfo.minorRev == 0)))
+            RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("LengthCheck!"));
+    }
+#endif /* BUP_FM_LEN_CHECK_ERRATA */
 
-    p_Dtsec->p_DtsecDriverParam->hugeFramesEnable = newVal;
+    p_Dtsec->p_DtsecDriverParam->lengthCheckEnable = newVal;
 
     return E_OK;
 }
@@ -830,12 +927,18 @@ static t_Error DtsecConfigException(t_Handle h_Dtsec, e_FmMacExceptions exceptio
     }
     else
     {
-        if(!p_Dtsec->support1588)
+        if(!p_Dtsec->ptpTsuEnabled)
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Exception valid for 1588 only"));
-        if(enable)
-            p_Dtsec->structFor1588.enErrExeption = TRUE;
-        else
-            p_Dtsec->structFor1588.enErrExeption = FALSE;
+        switch(exception){
+        case(e_FM_MAC_EX_1G_1588_TS_RX_ERR):
+            if(enable)
+                p_Dtsec->enTsuErrExeption = TRUE;
+            else
+                p_Dtsec->enTsuErrExeption = FALSE;
+            break;
+        default:
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Undefined exception"));
+        }
     }
     return E_OK;
 }
@@ -843,29 +946,6 @@ static t_Error DtsecConfigException(t_Handle h_Dtsec, e_FmMacExceptions exceptio
 /*                      dTSEC Run Time API functions                         */
 /*****************************************************************************/
 
-/* .......................................................................... */
-
-static t_Error DtsecRestart(t_Handle h_Dtsec, e_CommMode mode)
-{
-    t_Dtsec *p_Dtsec = (t_Dtsec *)h_Dtsec;
-    t_DtsecMemMap *p_MemMap ;
-    SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(p_Dtsec->p_MemMap, E_INVALID_HANDLE);
-
-    p_MemMap= (t_DtsecMemMap*)(p_Dtsec->p_MemMap);
-    if(mode & e_COMM_MODE_TX)
-        /* clear the graceful receive stop bit */
-        WRITE_UINT32(p_MemMap->tctrl,
-                      GET_UINT32(p_MemMap->tctrl) & ~TCTRL_GTS);
-
-    if(mode & e_COMM_MODE_RX)
-        /* clear the graceful receive stop bit */
-        WRITE_UINT32(p_MemMap->rctrl,
-                      GET_UINT32(p_MemMap->rctrl) & ~RCTRL_GRS);
-
-    return E_OK;
-}
-
 /* .............................................................................. */
 
 static t_Error DtsecEnable(t_Handle h_Dtsec,  e_CommMode mode)
@@ -880,28 +960,13 @@ static t_Error DtsecEnable(t_Handle h_Dtsec,  e_CommMode mode)
     p_MemMap= (t_DtsecMemMap*)(p_Dtsec->p_MemMap);
 
     tmpReg32 = GET_UINT32(p_MemMap->maccfg1);
-
-    switch (mode)
-    {
-        case e_COMM_MODE_NONE:
-            tmpReg32 &= ~(MACCFG1_RX_EN | MACCFG1_TX_EN);
-            break;
-        case e_COMM_MODE_RX :
-            tmpReg32 |= MACCFG1_RX_EN ;
-            break;
-        case e_COMM_MODE_TX :
-            tmpReg32 |= MACCFG1_TX_EN ;
-            break;
-        case e_COMM_MODE_RX_AND_TX:
-            tmpReg32 |= (MACCFG1_RX_EN | MACCFG1_TX_EN);
-            break;
-        default:
-            RETURN_ERROR(MINOR, E_INVALID_SELECTION, NO_MSG);
-    }
-
+    if (mode & e_COMM_MODE_RX)
+        tmpReg32 |= MACCFG1_RX_EN;
+    if (mode & e_COMM_MODE_TX)
+        tmpReg32 |= MACCFG1_TX_EN;
     WRITE_UINT32(p_MemMap->maccfg1, tmpReg32);
 
-	DtsecRestart(h_Dtsec, mode);
+    GracefulRestart(p_Dtsec, mode);
 
     return E_OK;
 }
@@ -919,27 +984,13 @@ static t_Error DtsecDisable (t_Handle h_Dtsec, e_CommMode mode)
 
     p_MemMap = (t_DtsecMemMap*)(p_Dtsec->p_MemMap);
 
-    tmpReg32 = GET_UINT32(p_MemMap->maccfg1);
-
-    switch (mode)
-    {
-        case e_COMM_MODE_RX :
-            rxGracefulStop(h_Dtsec);
-            tmpReg32 &= ~MACCFG1_RX_EN ;
-            break;
-        case e_COMM_MODE_TX :
-            txGracefulStop(h_Dtsec);
-            tmpReg32 &= ~MACCFG1_TX_EN ;
-            break;
-        case e_COMM_MODE_RX_AND_TX:
-            rxGracefulStop(h_Dtsec);
-            txGracefulStop(h_Dtsec);
-            tmpReg32 &= ~(MACCFG1_RX_EN | MACCFG1_TX_EN);
-            break;
-        default:
-            RETURN_ERROR(MINOR, E_INVALID_SELECTION, NO_MSG);
-    }
+    GracefulStop(p_Dtsec, mode);
 
+    tmpReg32 = GET_UINT32(p_MemMap->maccfg1);
+    if (mode & e_COMM_MODE_RX)
+        tmpReg32 &= ~MACCFG1_RX_EN;
+    if (mode & e_COMM_MODE_TX)
+        tmpReg32 &= ~MACCFG1_TX_EN;
     WRITE_UINT32(p_MemMap->maccfg1, tmpReg32);
 
     return E_OK;
@@ -947,11 +998,11 @@ static t_Error DtsecDisable (t_Handle h_Dtsec, e_CommMode mode)
 
 /* .............................................................................. */
 
-static t_Error DtsecTxMacPause(t_Handle h_Dtsec, uint16_t pauseTime, uint16_t exPauseTime )
+static t_Error DtsecTxMacPause(t_Handle h_Dtsec, uint16_t pauseTime)
 {
-    t_Dtsec      *p_Dtsec = (t_Dtsec *)h_Dtsec;
-    uint32_t    ptv = 0 ;
-    t_DtsecMemMap *p_MemMap;
+    t_Dtsec         *p_Dtsec = (t_Dtsec *)h_Dtsec;
+    uint32_t        ptv = 0;
+    t_DtsecMemMap   *p_MemMap;
 
     SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_STATE);
     SANITY_CHECK_RETURN_ERROR(!p_Dtsec->p_DtsecDriverParam, E_INVALID_STATE);
@@ -959,7 +1010,17 @@ static t_Error DtsecTxMacPause(t_Handle h_Dtsec, uint16_t pauseTime, uint16_t ex
 
     p_MemMap = (t_DtsecMemMap*)(p_Dtsec->p_MemMap);
 
-    ptv = ((uint32_t)exPauseTime << PTV_PTE_SHIFT) | pauseTime ;
+#ifdef FM_1G_SHORT_PAUSE_TIME_ERRATA_DTSEC1
+    {
+        t_FmRevisionInfo revInfo;
+        FmGetRevision(p_Dtsec->fmMacControllerDriver.h_Fm, &revInfo);
+        if ((revInfo.majorRev == 1) && (revInfo.minorRev == 0))
+            pauseTime += 2;
+    }
+#endif /* FM_1G_SHORT_PAUSE_TIME_ERRATA_DTSEC1 */
+
+    ptv = GET_UINT32(p_MemMap->ptv);
+    ptv |= pauseTime;
     WRITE_UINT32(p_MemMap->ptv, ptv);
 
     /* trigger the transmission of a flow-control pause frame */
@@ -1032,6 +1093,36 @@ static t_Error DtsecReadStatistics(t_Handle h_Dtsec)
 
 /* .............................................................................. */
 
+static t_Error DtsecEnable1588TimeStamp(t_Handle h_Dtsec)
+{
+    t_Dtsec          *p_Dtsec = (t_Dtsec *)h_Dtsec;
+
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_Dtsec->p_DtsecDriverParam, E_INVALID_STATE);
+
+    p_Dtsec->ptpTsuEnabled = TRUE;
+    WRITE_UINT32(p_Dtsec->p_MemMap->rctrl, GET_UINT32(p_Dtsec->p_MemMap->rctrl) | RCTRL_RTSE);
+    WRITE_UINT32(p_Dtsec->p_MemMap->tctrl, GET_UINT32(p_Dtsec->p_MemMap->tctrl) | TCTRL_TTSE);
+
+    return E_OK;
+}
+
+static t_Error DtsecDisable1588TimeStamp(t_Handle h_Dtsec)
+{
+    t_Dtsec          *p_Dtsec = (t_Dtsec *)h_Dtsec;
+
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_Dtsec->p_DtsecDriverParam, E_INVALID_STATE);
+
+    p_Dtsec->ptpTsuEnabled = TRUE;
+    WRITE_UINT32(p_Dtsec->p_MemMap->rctrl, GET_UINT32(p_Dtsec->p_MemMap->rctrl) & ~RCTRL_RTSE);
+    WRITE_UINT32(p_Dtsec->p_MemMap->tctrl, GET_UINT32(p_Dtsec->p_MemMap->tctrl) & ~TCTRL_TTSE);
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
 static t_Error DtsecGetStatistics(t_Handle h_Dtsec, t_FmMacStatistics *p_Statistics)
 {
     t_Dtsec          *p_Dtsec = (t_Dtsec *)h_Dtsec;
@@ -1404,7 +1495,6 @@ static t_Error DtsecSetExcpetion(t_Handle h_Dtsec, e_FmMacExceptions exception,
 
     SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_Dtsec->p_DtsecDriverParam, E_INVALID_HANDLE);
-    //e_FM_MAC_EX_1G_1588_TS_RX_ERR??
 
     if(exception != e_FM_MAC_EX_1G_1588_TS_RX_ERR)
     {
@@ -1428,23 +1518,41 @@ static t_Error DtsecSetExcpetion(t_Handle h_Dtsec, e_FmMacExceptions exception,
     }
     else
     {
-        if(!p_Dtsec->support1588)
+        if(!p_Dtsec->ptpTsuEnabled)
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Exception valid for 1588 only"));
-        if(enable)
-        {
-            p_Dtsec->structFor1588.enErrExeption = TRUE;
-            WRITE_UINT32(p_DtsecMemMap->tmr_pemask, PEMASK_TSRE);
-        }
-        else
-        {
-            p_Dtsec->structFor1588.enErrExeption = FALSE;
-            WRITE_UINT32(p_DtsecMemMap->tmr_pemask, 0);
+        tmpReg = GET_UINT32(p_DtsecMemMap->tmr_pemask);
+        switch(exception){
+        case(e_FM_MAC_EX_1G_1588_TS_RX_ERR):
+            if(enable)
+            {
+                p_Dtsec->enTsuErrExeption = TRUE;
+                WRITE_UINT32(p_DtsecMemMap->tmr_pemask, tmpReg | PEMASK_TSRE);
+            }
+            else
+            {
+                p_Dtsec->enTsuErrExeption = FALSE;
+                WRITE_UINT32(p_DtsecMemMap->tmr_pemask, tmpReg & ~PEMASK_TSRE);
+            }
+            break;
+        default:
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Undefined exception"));
         }
     }
 
     return E_OK;
 }
 
+/* .............................................................................. */
+
+static uint16_t DtsecGetMaxFrameLength(t_Handle h_Dtsec)
+{
+    t_Dtsec              *p_Dtsec = (t_Dtsec *)h_Dtsec;
+
+    SANITY_CHECK_RETURN_VALUE(p_Dtsec, E_INVALID_HANDLE, 0);
+
+    return (uint16_t)GET_UINT32(p_Dtsec->p_MemMap->maxfrm);
+}
+
 /* ........................................................................... */
 
 #if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
@@ -1466,6 +1574,9 @@ static t_Error DtsecDumpRegs(t_Handle h_Dtsec)
         DUMP_VAR(p_Dtsec->p_MemMap, edis);
         DUMP_VAR(p_Dtsec->p_MemMap, ecntrl);
         DUMP_VAR(p_Dtsec->p_MemMap, ptv);
+        DUMP_VAR(p_Dtsec->p_MemMap, tmr_ctrl);
+        DUMP_VAR(p_Dtsec->p_MemMap, tmr_pevent);
+        DUMP_VAR(p_Dtsec->p_MemMap, tmr_pemask);
         DUMP_VAR(p_Dtsec->p_MemMap, tctrl);
         DUMP_VAR(p_Dtsec->p_MemMap, rctrl);
         DUMP_VAR(p_Dtsec->p_MemMap, maccfg1);
@@ -1508,18 +1619,20 @@ static void InitFmMacControllerDriver(t_FmMacControllerDriver *p_FmMacController
 
     p_FmMacControllerDriver->f_FM_MAC_ConfigPadAndCrc           = DtsecConfigPadAndCrc;
     p_FmMacControllerDriver->f_FM_MAC_ConfigHalfDuplex          = DtsecConfigHalfDuplex;
-    p_FmMacControllerDriver->f_FM_MAC_ConfigHugeFrames          = DtsecConfigHugeFrames;
+    p_FmMacControllerDriver->f_FM_MAC_ConfigLengthCheck         = DtsecConfigLengthCheck;
     p_FmMacControllerDriver->f_FM_MAC_ConfigException           = DtsecConfigException;
 
     p_FmMacControllerDriver->f_FM_MAC_Enable                    = DtsecEnable;
     p_FmMacControllerDriver->f_FM_MAC_Disable                   = DtsecDisable;
-    p_FmMacControllerDriver->f_FM_MAC_Restart                   = DtsecRestart;
 
     p_FmMacControllerDriver->f_FM_MAC_SetException              = DtsecSetExcpetion;
 
     p_FmMacControllerDriver->f_FM_MAC_SetPromiscuous            = DtsecSetPromiscuous;
     p_FmMacControllerDriver->f_FM_MAC_AdjustLink                = DtsecAdjustLink;
 
+    p_FmMacControllerDriver->f_FM_MAC_Enable1588TimeStamp       = DtsecEnable1588TimeStamp;
+    p_FmMacControllerDriver->f_FM_MAC_Disable1588TimeStamp      = DtsecDisable1588TimeStamp;
+
     p_FmMacControllerDriver->f_FM_MAC_TxMacPause                = DtsecTxMacPause;
 
     p_FmMacControllerDriver->f_FM_MAC_ResetCounters             = DtsecResetCounters;
@@ -1532,6 +1645,7 @@ static void InitFmMacControllerDriver(t_FmMacControllerDriver *p_FmMacController
     p_FmMacControllerDriver->f_FM_MAC_RemovelExactMatchMacAddr  = DtsecDelExactMatchMacAddress;
     p_FmMacControllerDriver->f_FM_MAC_GetId                     = DtsecGetId;
     p_FmMacControllerDriver->f_FM_MAC_GetVersion                = DtsecGetVersion;
+    p_FmMacControllerDriver->f_FM_MAC_GetMaxFrameLength         = DtsecGetMaxFrameLength;
 
     p_FmMacControllerDriver->f_FM_MAC_MII_WritePhyReg           = DTSEC_MII_WritePhyReg;
     p_FmMacControllerDriver->f_FM_MAC_MII_ReadPhyReg            = DTSEC_MII_ReadPhyReg;
@@ -1576,7 +1690,7 @@ t_Handle  DTSEC_Config(t_FmMacParams *p_FmMacParam)
     /* Plant parameter structure pointer */
     p_Dtsec->p_DtsecDriverParam = p_DtsecDriverParam;
 
-    SetDefaultParam(p_Dtsec, p_DtsecDriverParam);
+    SetDefaultParam(p_DtsecDriverParam);
 
     p_Dtsec->h_App    = p_FmMacParam->h_App ;
     p_Dtsec->addr  = ((*(uint64_t *)p_FmMacParam->addr) >> 16);
@@ -1585,9 +1699,9 @@ t_Handle  DTSEC_Config(t_FmMacParams *p_FmMacParam)
     p_Dtsec->enetMode = p_FmMacParam->enetMode;
     p_Dtsec->macId    = p_FmMacParam->macId;
     p_Dtsec->exceptions = DEFAULT_exceptions;
-    p_Dtsec->f_Exceptions = p_FmMacParam->f_Exceptions;
+    p_Dtsec->f_Exception = p_FmMacParam->f_Exception;
     p_Dtsec->mdioIrq = p_FmMacParam->mdioIrq;
-    p_Dtsec->f_Events = p_FmMacParam->f_Events;
+    p_Dtsec->f_Event = p_FmMacParam->f_Event;
 
     return p_Dtsec;
 }
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.h b/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.h
index b80e5b3..b80439b 100644
--- a/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.h
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -46,7 +46,6 @@
 
 
 #define PEMASK_TSRE                 0x00010000
-#define PEMASK_EVENTS               0x00000301
 
 #define IMASK_BREN                  0x80000000
 #define IMASK_RXCEN                 0x40000000
@@ -67,6 +66,25 @@
 #define IMASK_TDPEEN                0x00000002
 #define IMASK_RDPEEN                0x00000001
 
+#define EVENTS_MASK                 ((uint32_t)(IMASK_BREN    | \
+                                                IMASK_RXCEN   | \
+                                                IMASK_MSROEN  | \
+                                                IMASK_GTSCEN  | \
+                                                IMASK_BTEN    | \
+                                                IMASK_TXCEN   | \
+                                                IMASK_TXEEN   | \
+                                                IMASK_ABRTEN  | \
+                                                IMASK_LCEN    | \
+                                                IMASK_CRLEN   | \
+                                                IMASK_XFUNEN  | \
+                                                IMASK_IFERREN | \
+                                                IMASK_MAGEN   | \
+                                                IMASK_MMRDEN  | \
+                                                IMASK_MMWREN  | \
+                                                IMASK_GRSCEN  | \
+                                                IMASK_TDPEEN  | \
+                                                IMASK_RDPEEN))
+
 #define GET_EXCEPTION_FLAG(bitMask, exception)       switch(exception){ \
     case e_FM_MAC_EX_1G_BAB_RX:                                   \
         bitMask = IMASK_BREN; break;                              \
@@ -110,7 +128,7 @@
 #define MAX_COLLISION_WINDOW        0x03ff
 
 
-/*********************From mac ext *******************************************/
+/********************* From mac ext ******************************************/
 typedef  uint32_t t_ErrorDisable;
 
 #define ERROR_DISABLE_TRANSMIT              0x00400000
@@ -123,79 +141,80 @@ typedef  uint32_t t_ErrorDisable;
 #define ERROR_DISABLE_RxDATA_PARITY         0x00000001
 
 /*****************************************************************************/
-#define DTSEC_NUM_OF_PADDRS         15  /* number of pattern match registers (entries) */
-
-#define GROUP_ADDRESS               0x0000010000000000LL /* Group address bit indication */
-
-                           /* if TRUE, Multiple individual addresses are used*/
-
-#define HASH_TABLE_SIZE             256 /* Hash table size (= 32 bits * 8 regs) */
-
+#define DTSEC_NUM_OF_PADDRS             15  /* number of pattern match registers (entries) */
 
-#define DTSEC_TO_MII_OFFSET         0x1120  /* number of pattern match registers (entries) */
+#define GROUP_ADDRESS                   0x0000010000000000LL /* Group address bit indication */
 
-#define DEFAULT_cam                 0
+#define HASH_TABLE_SIZE                 256 /* Hash table size (= 32 bits * 8 regs) */
 
-#define DEFAULT_errorDisabled       0
-#define DEFAULT_autoZeroCounters    TRUE        /* Must be TRUE don't change with updating driver */
-#define DEFAULT_statisticsEnable    TRUE
-#define DEFAULT_promiscuousEnable   FALSE
-
-#define DEFAULT_pauseExtended       0
-#define DEFAULT_pauseTime           0xf000
+#define DTSEC_TO_MII_OFFSET             0x1120  /* number of pattern match registers (entries) */
 
+#define DEFAULT_cam                     0
+#define DEFAULT_errorDisabled           0
+#define DEFAULT_autoZeroCounters        TRUE        /* Must be TRUE don't change with updating driver */
+#define DEFAULT_statisticsEnable        TRUE
+#define DEFAULT_promiscuousEnable       FALSE
+#define DEFAULT_pauseExtended           0x0
+#define DEFAULT_pauseTime               0xf000
 #define DEFAULT_halfDuplex              FALSE
 #define DEFAULT_halfDulexFlowControlEn  FALSE
 #define DEFAULT_txTimeStampEn           FALSE
 #define DEFAULT_rxTimeStampEn           FALSE
+#define DEFAULT_packetAlignment         0
+#define DEFAULT_controlFrameAccept      FALSE
+#define DEFAULT_groupHashExtend         FALSE
+#define DEFAULT_broadcReject            FALSE
+#define DEFAULT_rxShortFrame            TRUE
+#define DEFAULT_exactMatch              FALSE
+#define DEFAULT_debugMode               FALSE
+#define DEFAULT_loopback                FALSE
+#define DEFAULT_actOnRxPauseFrame       FALSE
+#define DEFAULT_actOnTxPauseFrame       FALSE
+
+#define DEFAULT_PreAmLength             0x7
+#define DEFAULT_PreAmRxEn               FALSE
+#define DEFAULT_PreAmTxEn               FALSE
+#define DEFAULT_lengthCheckEnable       FALSE
+#define DEFAULT_padAndCrcEnable         TRUE
+#define DEFAULT_crcEnable               FALSE
+
+#define DEFAULT_nonBackToBackIpg1       0x40
+#define DEFAULT_nonBackToBackIpg2       0x60
+#define DEFAULT_minIfgEnforcement       0x50
+#define DEFAULT_backToBackIpg           0x60
+
+#define DEFAULT_altBackoffVal           0x0A
+#define DEFAULT_altBackoffEnable        FALSE
+#define DEFAULT_backPressureNoBackoff   FALSE
+#define DEFAULT_noBackoff               FALSE
+#define DEFAULT_excessDefer             TRUE
+#define DEFAULT_maxRetransmission       0x0F
+#define DEFAULT_collisionWindow         0x37
+
+#define DEFAULT_maxFrameLength          0x600
+
+#define DEFAULT_collisionWindow         0x37
+
+#define DEFAULT_fifoTxThr               0x10
+#define DEFAULT_fifoTxWatermarkH        0x7e
+#define DEFAULT_fifoRxWatermarkL        0x08
+#define DEFAULT_tbiPhyAddr              5
+
+#define DEFAULT_exceptions              ((uint32_t)(IMASK_BREN    | \
+                                                    IMASK_RXCEN   | \
+                                                    IMASK_MSROEN  | \
+                                                    IMASK_BTEN    | \
+                                                    IMASK_TXCEN   | \
+                                                    IMASK_TXEEN   | \
+                                                    IMASK_ABRTEN  | \
+                                                    IMASK_LCEN    | \
+                                                    IMASK_CRLEN   | \
+                                                    IMASK_XFUNEN  | \
+                                                    IMASK_IFERREN | \
+                                                    IMASK_MAGEN   | \
+                                                    IMASK_TDPEEN  | \
+                                                    IMASK_RDPEEN))
 
-#define DEFAULT_packetAlignment     0
-#define DEFAULT_controlFrameAccept  FALSE
-#define DEFAULT_groupHashExtend     FALSE
-#define DEFAULT_broadcReject        FALSE
-#define DEFAULT_rxShortFrame        TRUE
-#define DEFAULT_exactMatch          FALSE
-
-#define DEFAULT_debugMode           FALSE
-
-#define DEFAULT_loopback            FALSE
-#define DEFAULT_actOnRxPauseFrame   FALSE
-#define DEFAULT_actOnTxPauseFrame   FALSE
-
-#define DEFAULT_PreAmLength         0x7
-#define DEFAULT_PreAmRxEn           FALSE
-#define DEFAULT_PreAmTxEn           FALSE
-#define DEFAULT_hugeFrames          TRUE
-#define DEFAULT_lengthCheckEnable   FALSE
-#define DEFAULT_padAndCrcEnable     TRUE
-#define DEFAULT_crcEnable           FALSE
-
-#define DEFAULT_nonBackToBackIpg1   0x40
-#define DEFAULT_nonBackToBackIpg2   0x60
-#define DEFAULT_minIfgEnforcement   0x50
-#define DEFAULT_backToBackIpg       0x60
-
-#define DEFAULT_altBackoffVal          0x0A
-#define DEFAULT_altBackoffEnable       FALSE
-#define DEFAULT_backPressureNoBackoff  FALSE
-#define DEFAULT_noBackoff           FALSE
-#define DEFAULT_excessDefer         TRUE
-#define DEFAULT_maxRetransmission   0x0F
-#define DEFAULT_collisionWindow     0x37
-
-#define DEFAULT_maxFrameLength      0x600
-
-#define DEFAULT_collisionWindow     0x37
-
-#define DEFAULT_fifoTxThr           0x10
-#define DEFAULT_fifoTxWatermarkH    0x7e
-#define DEFAULT_fifoRxWatermarkL    0x08
-#define DEFAULT_tbiPhyAddr          5
-
-#define DEFAULT_exceptions         ((uint32_t)(IMASK_BREN | IMASK_RXCEN | IMASK_MSROEN | \
-                                               IMASK_BTEN | IMASK_TXCEN | IMASK_TXEEN |  IMASK_ABRTEN | \
-                                               IMASK_LCEN | IMASK_CRLEN | IMASK_XFUNEN |IMASK_IFERREN| \
-                                               IMASK_MAGEN | IMASK_TDPEEN |IMASK_RDPEEN))
 
 #define MAX_PHYS                    32 /* maximum number of phys */
 
@@ -215,6 +234,8 @@ typedef  uint32_t t_ErrorDisable;
 #define ECNTRL_SGMIIM               0x00000002
 #define ECNTRL_RPM                  0x00000010
 #define ECNTRL_R100M                0x00000008
+#define ECNTRL_RMM                  0x00000004
+#define ECNTRL_QSGMIIM              0x00000001
 
 #define TCTRL_THDF                  0x00000800
 #define TCTRL_TTSE                  0x00000040
@@ -236,6 +257,9 @@ typedef  uint32_t t_ErrorDisable;
 #define RCTRL_UPROM                 0x00000001
 #define RCTRL_PROM                  (RCTRL_UPROM | RCTRL_MPROM)
 
+#define TMR_CTL_ESFDP               0x00000800
+#define TMR_CTL_ESFDE               0x00000400
+
 #define TSEC_ID1_DEBUG              0x00e00c00
 #define DEBUG_ENABLE                0x80000000
 #define DPERROR_Tx_ERROR_ON_SEC     0x00400000
@@ -260,7 +284,6 @@ typedef  uint32_t t_ErrorDisable;
 #define MACCFG2_BYTE_MODE           0x00000200
 #define MACCFG2_PRE_AM_Rx_EN        0x00000080
 #define MACCFG2_PRE_AM_Tx_EN        0x00000040
-#define MACCFG2_HUGE_FRAME          0x00000020
 #define MACCFG2_LENGTH_CHECK        0x00000010
 #define MACCFG2_MAGIC_PACKET_EN     0x00000008
 #define MACCFG2_PAD_CRC_EN          0x00000004
@@ -295,12 +318,6 @@ typedef  uint32_t t_ErrorDisable;
 /* Pause Time Value Register  */
 #define PTV_PTE_SHIFT    16
 
-#define EVENTS_MASK                 ((uint32_t)(IMASK_BREN | IMASK_RXCEN | IMASK_MSROEN | IMASK_GTSCEN | \
-                                                IMASK_BTEN | IMASK_TXCEN | IMASK_TXEEN  | IMASK_ABRTEN | \
-                                                IMASK_LCEN | IMASK_CRLEN | IMASK_XFUNEN | IMASK_IFERREN| \
-                                                IMASK_MAGEN | IMASK_MMRDEN | IMASK_MMWREN | \
-                                                IMASK_TDPEEN |IMASK_RDPEEN))
-
 #define     MASK22BIT   0x003FFFFF
 #define     MASK16BIT   0x0000FFFF
 #define     MASK12BIT   0x00000FFF
@@ -316,9 +333,9 @@ typedef  uint32_t t_ErrorDisable;
 #define PHY_TBICON_SRESET   0x8000
 
 
-#ifdef __MWERKS__
+#if defined(__MWERKS__) && !defined(__GNUC__)
 #pragma pack(push,1)
-#endif /*__MWERKS__ */
+#endif /* defined(__MWERKS__) && ... */
 #define MEM_MAP_START
 
 typedef _Packed struct
@@ -358,78 +375,73 @@ typedef _Packed struct
     volatile uint32_t ipgifg;               /* 0x108 IPG/IFG */
     volatile uint32_t hafdup;               /* 0x10C Half-duplex */
     volatile uint32_t maxfrm;               /* 0x110 Maximum frame */
-    volatile uint32_t DTSEC_RESERVED7[3];  /* 0x1140x11C register */
-    volatile uint32_t miimcfg;              /* 0x120 MII Mgmt:configuration */
-    volatile uint32_t miimcom;              /* 0x124 MII Mgmt:command */
-    volatile uint32_t miimadd;              /* 0x128 MII Mgmt:address */
-    volatile uint32_t miimcon;              /* 0x12C MII Mgmt:control 3 */
-    volatile uint32_t miimstat;             /* 0x130 MII Mgmt:status */
-    volatile uint32_t miimind;              /* 0x134 MII Mgmt:indicators */
+    volatile uint32_t DTSEC_RESERVED7[3];   /* 0x114-0x11C register */
+    t_MiiAccessMemMap miiMemMap;
     volatile uint32_t ifctrl;               /* 0x138 MII Mgmt:interface control */
     volatile uint32_t ifstat;               /* 0x13C Interface status */
     volatile uint32_t macstnaddr1;          /* 0x140 Station Address,part 1 */
     volatile uint32_t macstnaddr2;          /* 0x144 Station Address,part 2  */
     volatile macRegs  macaddr[DTSEC_NUM_OF_PADDRS]; /* 0x148-0x1BC mac exact match addresses 1-15, parts 1-2 */
-    volatile uint32_t  DTSEC_RESERVED8[16];   /* 0x1C00x1FC register */
+    volatile uint32_t DTSEC_RESERVED8[16];  /* 0x1C0-0x1FC register */
 
     /*  RMON MIB REGISTERS  */
     /*  TRANSMIT and RECEIVE COUNTERS   */
 
-    volatile uint32_t  tr64;            /* 0x200 transmit and receive 64 byte frame counter */
-    volatile uint32_t  tr127;           /* 0x204 transmit and receive 65 to 127 byte frame counter */
-    volatile uint32_t  tr255;           /* 0x208 transmit and receive 128 to 255 byte frame counter */
-    volatile uint32_t  tr511;           /* 0x20C transmit and receive 256 to 511 byte frame counter */
-    volatile uint32_t  tr1k;            /* 0x210 transmit and receive 512 to 1023 byte frame counter */
-    volatile uint32_t  trmax;           /* 0x214 transmit and receive 1024 to 1518 byte frame counter */
-    volatile uint32_t  trmgv;           /* 0x218 transmit and receive 1519 to 1522 byte good VLAN frame count */
+    volatile uint32_t tr64;            /* 0x200 transmit and receive 64 byte frame counter */
+    volatile uint32_t tr127;           /* 0x204 transmit and receive 65 to 127 byte frame counter */
+    volatile uint32_t tr255;           /* 0x208 transmit and receive 128 to 255 byte frame counter */
+    volatile uint32_t tr511;           /* 0x20C transmit and receive 256 to 511 byte frame counter */
+    volatile uint32_t tr1k;            /* 0x210 transmit and receive 512 to 1023 byte frame counter */
+    volatile uint32_t trmax;           /* 0x214 transmit and receive 1024 to 1518 byte frame counter */
+    volatile uint32_t trmgv;           /* 0x218 transmit and receive 1519 to 1522 byte good VLAN frame count */
 
     /* RECEIVE COUNTERS */
-    volatile uint32_t  rbyt;            /* 0x21C receive byte counter */
-    volatile uint32_t  rpkt;            /* 0x220 receive packet counter */
-    volatile uint32_t  rfcs;            /* 0x224 receive FCS error counter */
-    volatile uint32_t  rmca;            /* 0x228 RMCA receive multicast packet counter */
-    volatile uint32_t  rbca;            /* 0x22C receive broadcast packet counter */
-    volatile uint32_t  rxcf;            /* 0x230 receive control frame packet counter */
-    volatile uint32_t  rxpf;            /* 0x234 receive PAUSE frame packet counter */
-    volatile uint32_t  rxuo;            /* 0x238 receive unknown OP code counter */
-    volatile uint32_t  raln;            /* 0x23C receive alignment error counter */
-    volatile uint32_t  rflr;            /* 0x240 receive frame length error counter */
-    volatile uint32_t  rcde;            /* 0x244 receive code error counter */
-    volatile uint32_t  rcse;            /* 0x248 receive carrier sense error counter */
-    volatile uint32_t  rund;            /* 0x24C receive undersize packet counter */
-    volatile uint32_t  rovr;            /* 0x250 receive oversize packet counter */
-    volatile uint32_t  rfrg;            /* 0x254 receive fragments counter */
-    volatile uint32_t  rjbr;            /* 0x258 receive jabber counter */
-    volatile uint32_t  rdrp;            /* 0x25C receive drop */
+    volatile uint32_t rbyt;            /* 0x21C receive byte counter */
+    volatile uint32_t rpkt;            /* 0x220 receive packet counter */
+    volatile uint32_t rfcs;            /* 0x224 receive FCS error counter */
+    volatile uint32_t rmca;            /* 0x228 RMCA receive multicast packet counter */
+    volatile uint32_t rbca;            /* 0x22C receive broadcast packet counter */
+    volatile uint32_t rxcf;            /* 0x230 receive control frame packet counter */
+    volatile uint32_t rxpf;            /* 0x234 receive PAUSE frame packet counter */
+    volatile uint32_t rxuo;            /* 0x238 receive unknown OP code counter */
+    volatile uint32_t raln;            /* 0x23C receive alignment error counter */
+    volatile uint32_t rflr;            /* 0x240 receive frame length error counter */
+    volatile uint32_t rcde;            /* 0x244 receive code error counter */
+    volatile uint32_t rcse;            /* 0x248 receive carrier sense error counter */
+    volatile uint32_t rund;            /* 0x24C receive undersize packet counter */
+    volatile uint32_t rovr;            /* 0x250 receive oversize packet counter */
+    volatile uint32_t rfrg;            /* 0x254 receive fragments counter */
+    volatile uint32_t rjbr;            /* 0x258 receive jabber counter */
+    volatile uint32_t rdrp;            /* 0x25C receive drop */
 
     /* TRANSMIT COUNTERS */
-    volatile uint32_t  tbyt;            /* 0x260 transmit byte counter */
-    volatile uint32_t  tpkt;            /* 0x264 transmit packet counter */
-    volatile uint32_t  tmca;            /* 0x268 transmit multicast packet counter */
-    volatile uint32_t  tbca;            /* 0x26C transmit broadcast packet counter */
-    volatile uint32_t  txpf;            /* 0x270 transmit PAUSE control frame counter */
-    volatile uint32_t  tdfr;            /* 0x274 transmit deferral packet counter */
-    volatile uint32_t  tedf;            /* 0x278 transmit excessive deferral packet counter */
-    volatile uint32_t  tscl;            /* 0x27C transmit single collision packet counter */
-    volatile uint32_t  tmcl;            /* 0x280 transmit multiple collision packet counter */
-    volatile uint32_t  tlcl;            /* 0x284 transmit late collision packet counter */
-    volatile uint32_t  txcl;            /* 0x288 transmit excessive collision packet counter */
-    volatile uint32_t  tncl;            /* 0x28C transmit total collision counter */
-    volatile uint32_t  DTSEC_RESERVED9; /* 0x290 */
-    volatile uint32_t  tdrp;            /* 0x294 transmit drop frame counter */
-    volatile uint32_t  tjbr;            /* 0x298 transmit jabber frame counter */
-    volatile uint32_t  tfcs;            /* 0x29C transmit FCS error counter */
-    volatile uint32_t  txcf;            /* 0x2A0 transmit control frame counter */
-    volatile uint32_t  tovr;            /* 0x2A4 transmit oversize frame counter */
-    volatile uint32_t  tund;            /* 0x2A8 transmit undersize frame counter */
-    volatile uint32_t  tfrg;            /* 0x2AC transmit fragments frame counter */
+    volatile uint32_t tbyt;            /* 0x260 transmit byte counter */
+    volatile uint32_t tpkt;            /* 0x264 transmit packet counter */
+    volatile uint32_t tmca;            /* 0x268 transmit multicast packet counter */
+    volatile uint32_t tbca;            /* 0x26C transmit broadcast packet counter */
+    volatile uint32_t txpf;            /* 0x270 transmit PAUSE control frame counter */
+    volatile uint32_t tdfr;            /* 0x274 transmit deferral packet counter */
+    volatile uint32_t tedf;            /* 0x278 transmit excessive deferral packet counter */
+    volatile uint32_t tscl;            /* 0x27C transmit single collision packet counter */
+    volatile uint32_t tmcl;            /* 0x280 transmit multiple collision packet counter */
+    volatile uint32_t tlcl;            /* 0x284 transmit late collision packet counter */
+    volatile uint32_t txcl;            /* 0x288 transmit excessive collision packet counter */
+    volatile uint32_t tncl;            /* 0x28C transmit total collision counter */
+    volatile uint32_t DTSEC_RESERVED9; /* 0x290 */
+    volatile uint32_t tdrp;            /* 0x294 transmit drop frame counter */
+    volatile uint32_t tjbr;            /* 0x298 transmit jabber frame counter */
+    volatile uint32_t tfcs;            /* 0x29C transmit FCS error counter */
+    volatile uint32_t txcf;            /* 0x2A0 transmit control frame counter */
+    volatile uint32_t tovr;            /* 0x2A4 transmit oversize frame counter */
+    volatile uint32_t tund;            /* 0x2A8 transmit undersize frame counter */
+    volatile uint32_t tfrg;            /* 0x2AC transmit fragments frame counter */
 
     /* GENERAL REGISTERS */
-    volatile uint32_t  car1;            /* 0x2B0 carry register one register* */
-    volatile uint32_t  car2;            /* 0x2B4 carry register two register* */
-    volatile uint32_t  cam1;            /* 0x2B8 carry register one mask register */
-    volatile uint32_t  cam2;            /* 0x2BC carry register two mask register */
-    volatile uint32_t  DTSEC_RESERVED10[16]; /* 0x2C0-0x2FC */
+    volatile uint32_t car1;            /* 0x2B0 carry register one register* */
+    volatile uint32_t car2;            /* 0x2B4 carry register two register* */
+    volatile uint32_t cam1;            /* 0x2B8 carry register one mask register */
+    volatile uint32_t cam2;            /* 0x2BC carry register two mask register */
+    volatile uint32_t DTSEC_RESERVED10[16]; /* 0x2C0-0x2FC */
 
     /* Debug and Factory Test Registers */
     volatile uint32_t debug;            /* 0x300 DEBUGDebug Register */
@@ -452,18 +464,17 @@ typedef _Packed struct
 } _PackedType t_DtsecMemMap;
 
 #define MEM_MAP_END
-#ifdef __MWERKS__
+#if defined(__MWERKS__) && !defined(__GNUC__)
 #pragma pack(pop)
-#endif /* __MWERKS__ */
+#endif /* defined(__MWERKS__) && ... */
 
 
 typedef struct {
-
     uint32_t    errorDisabled;
     bool        halfDuplex;
     uint16_t    pauseTime;
     uint16_t    pauseExtended;
-    uint8_t     tbiPhyAddr;         /**< TBI Physical address  (1-31)     [DEFAULT_tbiPhyAddr]*/
+    uint8_t     tbiPhyAddr;         /**< TBI Physical address  (1-31)     [DEFAULT_tbiPhyAddr] */
 
     bool        autoZeroCounters;
     bool        statisticsEnable;
@@ -494,7 +505,6 @@ typedef struct {
     uint8_t     preambleLength;
     bool        preambleRxEn;
     bool        preambleTxEn;
-    bool        hugeFramesEnable;
     bool        lengthCheckEnable;
     bool        magicPacketEnable;
     bool        padAndCrcEnable;
@@ -525,9 +535,9 @@ typedef struct {
     t_MiiAccessMemMap           *p_MiiMemMap;     /**< pointer to dTSEC MII memory mapped registers.          */
     uint64_t                    addr;             /**< MAC address of device;                             */
     e_EnetMode                  enetMode;         /**< Ethernet physical interface  */
-    t_FmMacExceptionCallback    *f_Exceptions;
+    t_FmMacExceptionCallback    *f_Exception;
     int                         mdioIrq;
-    t_FmMacExceptionCallback    *f_Events;
+    t_FmMacExceptionCallback    *f_Event;
     bool                        indAddrRegUsed[DTSEC_NUM_OF_PADDRS]; /**< Whether a particular individual address recognition register is being used */
     uint64_t                    paddr[DTSEC_NUM_OF_PADDRS]; /**< MAC address for particular individual address recognition register */
     uint8_t                     numOfIndAddrInRegs; /**< Number of individual addresses in registers for this station. */
@@ -539,11 +549,8 @@ typedef struct {
     uint8_t                     macId;
     uint32_t                    exceptions;
     t_DtsecDriverParam          *p_DtsecDriverParam;
-/* TODO - tmp, for Moti to set names and structs */
-    bool                        support1588;
-    struct{
-            bool    enErrExeption;
-    }structFor1588;
+    bool                        ptpTsuEnabled;
+    bool                        enTsuErrExeption;
 } t_Dtsec;
 
 
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/dtsec_mii_acc.c b/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/dtsec_mii_acc.c
index 8a146e5..16575e2 100644
--- a/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/dtsec_mii_acc.c
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/dtsec_mii_acc.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -101,7 +101,7 @@ t_Error DTSEC_MII_ReadPhyReg(t_Handle h_Dtsec,
     /* Dummy read to make sure MIIMCOM is written */
     tmpReg = GET_UINT32(p_MiiAccess->miimcom);
 
-    /* Wait till MII management write is complete */
+    /* Wait till MII management read is complete */
     while ((GET_UINT32(p_MiiAccess->miimind)) & MIIMIND_BUSY) ;
 
     /* Read MII management status  */
@@ -112,7 +112,9 @@ t_Error DTSEC_MII_ReadPhyReg(t_Handle h_Dtsec,
     tmpReg = GET_UINT32(p_MiiAccess->miimcom);
 
     if (*p_Data == 0xffff)
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Read wrong data (0xffff): phyAddr 0x%x, reg 0x%x", phyAddr, reg));
+        RETURN_ERROR(MINOR, E_NO_DEVICE,
+                     ("Read wrong data (0xffff): phyAddr 0x%x, reg 0x%x",
+                      phyAddr, reg));
 
     return E_OK;
 }
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/dtsec_mii_acc.h b/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/dtsec_mii_acc.h
index cd19090..335ad9c 100644
--- a/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/dtsec_mii_acc.h
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/dtsec_mii_acc.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -51,9 +51,9 @@
 #define MIIMIND_BUSY                0x00000001
 
 
-#ifdef __MWERKS__
+#if defined(__MWERKS__) && !defined(__GNUC__)
 #pragma pack(push,1)
-#endif /*__MWERKS__ */
+#endif /* defined(__MWERKS__) && ... */
 #define MEM_MAP_START
 
 /*----------------------------------------------------*/
@@ -70,9 +70,9 @@ typedef _Packed struct t_MiiAccessMemMap
 } _PackedType t_MiiAccessMemMap ;
 
 #define MEM_MAP_END
-#ifdef __MWERKS__
+#if defined(__MWERKS__) && !defined(__GNUC__)
 #pragma pack(pop)
-#endif /* __MWERKS__ */
+#endif /* defined(__MWERKS__) && ... */
 
 
 #endif /* __DTSEC_MII_ACC_H */
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.c b/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.c
index 601cb18..2038ccc 100644
--- a/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.c
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -39,9 +39,10 @@
 #include "string_ext.h"
 #include "sprint_ext.h"
 #include "error_ext.h"
+#include "fm_ext.h"
 
+#include "fm_common.h"
 #include "fm_mac.h"
-#include "fm_ext.h"
 
 
 /* ........................................................................... */
@@ -82,6 +83,9 @@ t_Error FM_MAC_Init (t_Handle h_FmMac)
                      p_FmMacControllerDriver->macId) != E_OK))
         RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Can't reset MAC!"));
 
+    if ((p_FmMacControllerDriver->clkFreq = FmGetClockFreq(p_FmMacControllerDriver->h_Fm)) == 0)
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Can't get clock for MAC!"));
+
     if (p_FmMacControllerDriver->f_FM_MAC_Init)
         return p_FmMacControllerDriver->f_FM_MAC_Init(h_FmMac);
     RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
@@ -199,19 +203,20 @@ t_Error FM_MAC_ConfigHalfDuplex (t_Handle h_FmMac, bool newVal)
 
 /* ........................................................................... */
 
-t_Error FM_MAC_ConfigHugeFrames (t_Handle h_FmMac, bool newVal)
+t_Error FM_MAC_ConfigLengthCheck (t_Handle h_FmMac, bool newVal)
 {
     t_FmMacControllerDriver *p_FmMacControllerDriver = (t_FmMacControllerDriver *)h_FmMac;
 
     SANITY_CHECK_RETURN_ERROR(p_FmMacControllerDriver, E_INVALID_HANDLE);
 
-    if (p_FmMacControllerDriver->f_FM_MAC_ConfigHugeFrames)
-        return p_FmMacControllerDriver->f_FM_MAC_ConfigHugeFrames(h_FmMac, newVal);
+    if (p_FmMacControllerDriver->f_FM_MAC_ConfigLengthCheck)
+        return p_FmMacControllerDriver->f_FM_MAC_ConfigLengthCheck(h_FmMac,newVal);
 
     RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
 }
 
 /* ........................................................................... */
+
 t_Error FM_MAC_ConfigException (t_Handle h_FmMac, e_FmMacExceptions ex, bool enable)
 {
     t_FmMacControllerDriver *p_FmMacControllerDriver = (t_FmMacControllerDriver *)h_FmMac;
@@ -260,28 +265,42 @@ t_Error FM_MAC_Disable (t_Handle h_FmMac, e_CommMode mode)
 
 /* ........................................................................... */
 
-t_Error FM_MAC_Restart (t_Handle h_FmMac, e_CommMode mode)
+t_Error FM_MAC_Enable1588TimeStamp (t_Handle h_FmMac)
 {
     t_FmMacControllerDriver *p_FmMacControllerDriver = (t_FmMacControllerDriver *)h_FmMac;
 
     SANITY_CHECK_RETURN_ERROR(p_FmMacControllerDriver, E_INVALID_HANDLE);
 
-    if (p_FmMacControllerDriver->f_FM_MAC_Restart)
-        return p_FmMacControllerDriver->f_FM_MAC_Restart(h_FmMac, mode);
+    if (p_FmMacControllerDriver->f_FM_MAC_Enable1588TimeStamp)
+        return p_FmMacControllerDriver->f_FM_MAC_Enable1588TimeStamp(h_FmMac);
 
     RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
 }
 
 /* ........................................................................... */
 
-t_Error FM_MAC_TxMacPause (t_Handle h_FmMac, uint16_t pauseTime, uint16_t exPauseTime)
+t_Error FM_MAC_Disable1588TimeStamp (t_Handle h_FmMac)
+{
+    t_FmMacControllerDriver *p_FmMacControllerDriver = (t_FmMacControllerDriver *)h_FmMac;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacControllerDriver, E_INVALID_HANDLE);
+
+    if (p_FmMacControllerDriver->f_FM_MAC_Disable1588TimeStamp)
+        return p_FmMacControllerDriver->f_FM_MAC_Disable1588TimeStamp(h_FmMac);
+
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
+/* ........................................................................... */
+
+t_Error FM_MAC_TxMacPause (t_Handle h_FmMac, uint16_t pauseTime)
 {
     t_FmMacControllerDriver *p_FmMacControllerDriver = (t_FmMacControllerDriver *)h_FmMac;
 
     SANITY_CHECK_RETURN_ERROR(p_FmMacControllerDriver, E_INVALID_HANDLE);
 
     if (p_FmMacControllerDriver->f_FM_MAC_TxMacPause)
-        return p_FmMacControllerDriver->f_FM_MAC_TxMacPause(h_FmMac, pauseTime, exPauseTime);
+        return p_FmMacControllerDriver->f_FM_MAC_TxMacPause(h_FmMac, pauseTime);
 
     RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
 }
@@ -483,6 +502,20 @@ t_Error FM_MAC_MII_ReadPhyReg(t_Handle h_FmMac,  uint8_t phyAddr, uint8_t reg, u
     RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
 }
 
+/* ........................................................................... */
+
+uint16_t FM_MAC_GetMaxFrameLength(t_Handle h_FmMac)
+{
+    t_FmMacControllerDriver *p_FmMacControllerDriver = (t_FmMacControllerDriver *)h_FmMac;
+
+    SANITY_CHECK_RETURN_VALUE(p_FmMacControllerDriver, E_INVALID_HANDLE, 0);
+
+    if (p_FmMacControllerDriver->f_FM_MAC_GetMaxFrameLength)
+        return p_FmMacControllerDriver->f_FM_MAC_GetMaxFrameLength(h_FmMac);
+
+    REPORT_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+    return 0;
+}
 
 #if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
 /*****************************************************************************/
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.h b/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.h
index b981f41..b807456 100644
--- a/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.h
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -41,10 +41,12 @@
 #include "std_ext.h"
 #include "error_ext.h"
 #include "list_ext.h"
-#include "fm_common.h"
 #include "fm_mac_ext.h"
 
 
+#define __ERR_MODULE__  MODULE_FM_MAC
+
+
 #define DEFAULT_resetOnInit                 FALSE
 
 
@@ -59,17 +61,18 @@ typedef struct
     t_Error (*f_FM_MAC_ConfigWan) (t_Handle h_FmMac, bool flag);
     t_Error (*f_FM_MAC_ConfigPadAndCrc) (t_Handle h_FmMac, bool newVal);
     t_Error (*f_FM_MAC_ConfigHalfDuplex) (t_Handle h_FmMac, bool newVal);
-    t_Error (*f_FM_MAC_ConfigHugeFrames) (t_Handle h_FmMac, bool newVal);
+    t_Error (*f_FM_MAC_ConfigLengthCheck) (t_Handle h_FmMac, bool newVal);
     t_Error (*f_FM_MAC_ConfigException) (t_Handle h_FmMac, e_FmMacExceptions, bool enable);
 
     t_Error (*f_FM_MAC_SetException) (t_Handle h_FmMac, e_FmMacExceptions ex, bool enable);
 
     t_Error (*f_FM_MAC_Enable)  (t_Handle h_FmMac,  e_CommMode mode);
     t_Error (*f_FM_MAC_Disable) (t_Handle h_FmMac, e_CommMode mode);
-    t_Error (*f_FM_MAC_Restart) (t_Handle h_FmMac, e_CommMode mode);
+    t_Error (*f_FM_MAC_Enable1588TimeStamp) (t_Handle h_FmMac);
+    t_Error (*f_FM_MAC_Disable1588TimeStamp) (t_Handle h_FmMac);
     t_Error (*f_FM_MAC_Reset)   (t_Handle h_FmMac, bool wait);
 
-    t_Error (*f_FM_MAC_TxMacPause) (t_Handle h_FmMac, uint16_t pauseTime, uint16_t exPauseTime);
+    t_Error (*f_FM_MAC_TxMacPause) (t_Handle h_FmMac, uint16_t pauseTime);
 
     t_Error (*f_FM_MAC_ResetCounters) (t_Handle h_FmMac);
     t_Error (*f_FM_MAC_GetStatistics) (t_Handle h_FmMac, t_FmMacStatistics *p_Statistics);
@@ -87,6 +90,8 @@ typedef struct
 
     t_Error (*f_FM_MAC_GetVersion) (t_Handle h_FmMac, uint32_t *macVersion);
 
+    uint16_t (*f_FM_MAC_GetMaxFrameLength) (t_Handle h_FmMac);
+
     t_Error (*f_FM_MAC_MII_WritePhyReg)(t_Handle h_FmMac, uint8_t phyAddr, uint8_t reg, uint16_t data);
     t_Error (*f_FM_MAC_MII_ReadPhyReg)(t_Handle h_FmMac,  uint8_t phyAddr, uint8_t reg, uint16_t *p_Data);
 
@@ -98,6 +103,7 @@ typedef struct
     e_EnetMode      enetMode;
     uint8_t         macId;
     bool            resetOnInit;
+    uint16_t        clkFreq;
 } t_FmMacControllerDriver;
 
 typedef struct {
@@ -111,8 +117,9 @@ typedef struct {
     t_List      *p_Lsts;
 } t_EthHash;
 
-t_Handle  DTSEC_Config(t_FmMacParams *p_FmMacParam);
-t_Handle  TGEC_Config(t_FmMacParams *p_FmMacParams);
+t_Handle    DTSEC_Config(t_FmMacParams *p_FmMacParam);
+t_Handle    TGEC_Config(t_FmMacParams *p_FmMacParams);
+uint16_t    FM_MAC_GetMaxFrameLength(t_Handle FmMac);
 
 /* ........................................................................... */
 
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/tgec.c b/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/tgec.c
index 81ddd82..dacdf6c 100644
--- a/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/tgec.c
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/tgec.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -115,37 +115,37 @@ static void TgecErrException(t_Handle h_Tgec)
     WRITE_UINT32(p_TgecMemMap->ievent, event);
 
     if(event & IMASK_REM_FAULT)
-        p_Tgec->f_Exceptions(p_Tgec->h_App, e_FM_MAC_EX_10G_REM_FAULT);
+        p_Tgec->f_Exception(p_Tgec->h_App, e_FM_MAC_EX_10G_REM_FAULT);
     if(event & IMASK_LOC_FAULT)
-        p_Tgec->f_Exceptions(p_Tgec->h_App, e_FM_MAC_EX_10G_LOC_FAULT);
+        p_Tgec->f_Exception(p_Tgec->h_App, e_FM_MAC_EX_10G_LOC_FAULT);
     if(event & IMASK_1TX_ECC_ER)
-        p_Tgec->f_Exceptions(p_Tgec->h_App, e_FM_MAC_EX_10G_1TX_ECC_ER);
+        p_Tgec->f_Exception(p_Tgec->h_App, e_FM_MAC_EX_10G_1TX_ECC_ER);
     if(event & IMASK_TX_FIFO_UNFL)
-        p_Tgec->f_Exceptions(p_Tgec->h_App, e_FM_MAC_EX_10G_TX_FIFO_UNFL);
+        p_Tgec->f_Exception(p_Tgec->h_App, e_FM_MAC_EX_10G_TX_FIFO_UNFL);
     if(event & IMASK_TX_FIFO_OVFL)
-        p_Tgec->f_Exceptions(p_Tgec->h_App, e_FM_MAC_EX_10G_TX_FIFO_OVFL);
+        p_Tgec->f_Exception(p_Tgec->h_App, e_FM_MAC_EX_10G_TX_FIFO_OVFL);
     if(event & IMASK_TX_ER )
-        p_Tgec->f_Exceptions(p_Tgec->h_App, e_FM_MAC_EX_10G_TX_ER);
+        p_Tgec->f_Exception(p_Tgec->h_App, e_FM_MAC_EX_10G_TX_ER);
     if(event & IMASK_RX_FIFO_OVFL )
-        p_Tgec->f_Exceptions(p_Tgec->h_App, e_FM_MAC_EX_10G_RX_FIFO_OVFL);
+        p_Tgec->f_Exception(p_Tgec->h_App, e_FM_MAC_EX_10G_RX_FIFO_OVFL);
     if(event & IMASK_RX_ECC_ER )
-        p_Tgec->f_Exceptions(p_Tgec->h_App, e_FM_MAC_EX_10G_RX_ECC_ER);
+        p_Tgec->f_Exception(p_Tgec->h_App, e_FM_MAC_EX_10G_RX_ECC_ER);
     if(event & IMASK_RX_JAB_FRM)
-        p_Tgec->f_Exceptions(p_Tgec->h_App, e_FM_MAC_EX_10G_RX_JAB_FRM);
+        p_Tgec->f_Exception(p_Tgec->h_App, e_FM_MAC_EX_10G_RX_JAB_FRM);
     if(event & IMASK_RX_OVRSZ_FRM)
-        p_Tgec->f_Exceptions(p_Tgec->h_App, e_FM_MAC_EX_10G_RX_OVRSZ_FRM);
+        p_Tgec->f_Exception(p_Tgec->h_App, e_FM_MAC_EX_10G_RX_OVRSZ_FRM);
     if(event & IMASK_RX_RUNT_FRM )
-        p_Tgec->f_Exceptions(p_Tgec->h_App, e_FM_MAC_EX_10G_RX_RUNT_FRM);
+        p_Tgec->f_Exception(p_Tgec->h_App, e_FM_MAC_EX_10G_RX_RUNT_FRM);
     if(event & IMASK_RX_FRAG_FRM)
-        p_Tgec->f_Exceptions(p_Tgec->h_App, e_FM_MAC_EX_10G_RX_FRAG_FRM);
+        p_Tgec->f_Exception(p_Tgec->h_App, e_FM_MAC_EX_10G_RX_FRAG_FRM);
     if(event & IMASK_RX_LEN_ER)
-        p_Tgec->f_Exceptions(p_Tgec->h_App, e_FM_MAC_EX_10G_RX_LEN_ER);
+        p_Tgec->f_Exception(p_Tgec->h_App, e_FM_MAC_EX_10G_RX_LEN_ER);
     if(event & IMASK_RX_CRC_ER)
-        p_Tgec->f_Exceptions(p_Tgec->h_App, e_FM_MAC_EX_10G_RX_CRC_ER);
+        p_Tgec->f_Exception(p_Tgec->h_App, e_FM_MAC_EX_10G_RX_CRC_ER);
     if(event & IMASK_RX_ALIGN_ER)
-        p_Tgec->f_Exceptions(p_Tgec->h_App, e_FM_MAC_EX_10G_RX_ALIGN_ER);
-
+        p_Tgec->f_Exception(p_Tgec->h_App, e_FM_MAC_EX_10G_RX_ALIGN_ER);
 }
+
 static void TgecException(t_Handle h_Tgec)
 {
     t_Tgec             *p_Tgec = (t_Tgec *)h_Tgec;
@@ -160,9 +160,9 @@ static void TgecException(t_Handle h_Tgec)
      WRITE_UINT32(p_TgecMemMap->ievent, event);
 
      if(event & IMASK_MDIO_SCAN_EVENTMDIO)
-         p_Tgec->f_Events(p_Tgec->h_App, e_FM_MAC_EX_10G_MDIO_SCAN_EVENTMDIO);
+         p_Tgec->f_Event(p_Tgec->h_App, e_FM_MAC_EX_10G_MDIO_SCAN_EVENTMDIO);
      if(event & IMASK_MDIO_CMD_CMPL)
-         p_Tgec->f_Events(p_Tgec->h_App, e_FM_MAC_EX_10G_MDIO_CMD_CMPL);
+         p_Tgec->f_Event(p_Tgec->h_App, e_FM_MAC_EX_10G_MDIO_CMD_CMPL);
 }
 
 static void FreeInitResources(t_Tgec *p_Tgec)
@@ -252,22 +252,17 @@ static t_Error TgecInit(t_Handle h_Tgec)
     p_MemMap = p_Tgec->p_MemMap;
 
     /* MAC Address */
-
     addr = p_Tgec->addr;
-
-//    tmpReg32 = (uint32_t)(addr);
     tmpReg32 = (uint32_t)(addr>>16);
     SwapUint32P(&tmpReg32);
     WRITE_UINT32(p_MemMap->mac_addr_0, tmpReg32);
 
-//    tmpReg32 = (uint32_t)(addr>>32);
     tmpReg32 = (uint32_t)(addr);
     SwapUint32P(&tmpReg32);
     tmpReg32 >>= 16;
     WRITE_UINT32(p_MemMap->mac_addr_1, tmpReg32);
 
     /* Config */
-
     tmpReg32 = 0;
     if (p_TgecDriverParam->wanModeEnable)
        tmpReg32 |= CMD_CFG_WAN_MODE;
@@ -313,6 +308,14 @@ static t_Error TgecInit(t_Handle h_Tgec)
     /* Pause Time */
     WRITE_UINT32(p_MemMap->pause_quant, p_TgecDriverParam->pauseTime);
 
+    /* Configure MII */
+    tmpReg32  = GET_UINT32(p_Tgec->p_MiiMemMap->mdio_cfg_status);
+    tmpReg32 |= (MIIMCOM_MDIO_HOLD_4_REG_CLK << 2);
+    tmpReg32 &= ~MIIMCOM_DIV_MASK;
+     /* (one half of fm clock => 2.5Mhz) */
+    tmpReg32 |=((((p_Tgec->fmMacControllerDriver.clkFreq*10)/2)/25) << MIIMCOM_DIV_SHIFT);
+    WRITE_UINT32(p_Tgec->p_MiiMemMap->mdio_cfg_status, tmpReg32);
+
     p_Tgec->p_MulticastAddrHash = AllocHashTable(HASH_TABLE_SIZE);
     if(!p_Tgec->p_MulticastAddrHash)
     {
@@ -327,6 +330,14 @@ static t_Error TgecInit(t_Handle h_Tgec)
     }
 
     /* interrupts */
+#ifdef BUP_FM_10G_REM_N_LCL_FLT_EX_ERRATA
+    {
+        t_FmRevisionInfo revInfo;
+        FmGetRevision(p_Tgec->fmMacControllerDriver.h_Fm, &revInfo);
+        if ((revInfo.majorRev == 1) && (revInfo.minorRev == 0))
+            p_Tgec->exceptions &= ~(IMASK_REM_FAULT | IMASK_LOC_FAULT);
+    }
+#endif   /* BUP_FM_10G_REM_N_LCL_FLT_EX_ERRATA */
     WRITE_UINT32(p_MemMap->ievent, EVENTS_MASK);
     WRITE_UINT32(p_MemMap->imask, p_Tgec->exceptions);
 
@@ -424,15 +435,23 @@ static t_Error TgecConfigPadAndCrc(t_Handle h_Tgec, bool newVal)
 
 /* .............................................................................. */
 
-static t_Error TgecConfigHugeFrames(t_Handle h_Tgec, bool newVal)
+static t_Error TgecConfigLengthCheck(t_Handle h_Tgec, bool newVal)
 {
     t_Tgec *p_Tgec = (t_Tgec *)h_Tgec;
     UNUSED(newVal);
 
     SANITY_CHECK_RETURN_ERROR(p_Tgec, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Tgec->p_TgecDriverParam, E_INVALID_STATE);
-
-    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+#ifdef BUP_FM_LEN_CHECK_ERRATA
+    {
+        t_FmRevisionInfo revInfo;
+        FmGetRevision(p_Tgec->fmMacControllerDriver.h_Fm, &revInfo);
+        if (((revInfo.majorRev == 1) && (revInfo.minorRev == 0))||
+            ((revInfo.majorRev == 2) && (revInfo.minorRev == 0)))
+            RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("LengthCheck!"));
+    }
+#endif /* BUP_FM_LEN_CHECK_ERRATA */
+    p_Tgec->p_TgecDriverParam->noLengthCheckEnable = !newVal;
 
     return E_OK;
 }
@@ -450,6 +469,27 @@ static t_Error TgecConfigException(t_Handle h_Tgec, e_FmMacExceptions exception,
 
     SANITY_CHECK_RETURN_ERROR(p_Tgec, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Tgec->p_TgecDriverParam, E_INVALID_STATE);
+#ifdef BUP_FM_10G_REM_N_LCL_FLT_EX_ERRATA
+    {
+        t_FmRevisionInfo revInfo;
+        if(enable)
+        {
+            if(exception == e_FM_MAC_EX_10G_LOC_FAULT)
+            {
+                FmGetRevision(p_Tgec->fmMacControllerDriver.h_Fm, &revInfo);
+                if ((revInfo.majorRev == 1) && (revInfo.minorRev == 0))
+                    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("e_FM_MAC_EX_10G_LOC_FAULT!"));
+            }
+            else
+                if(exception == e_FM_MAC_EX_10G_REM_FAULT)
+                {
+                    FmGetRevision(p_Tgec->fmMacControllerDriver.h_Fm, &revInfo);
+                    if ((revInfo.majorRev == 1) && (revInfo.minorRev == 0))
+                        RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("e_FM_MAC_EX_10G_REM_FAULT!"));
+                }
+        }
+    }
+#endif   /* BUP_FM_10G_REM_N_LCL_FLT_EX_ERRATA */
 
     GET_EXCEPTION_FLAG(bitMask, exception);
     if(bitMask)
@@ -535,12 +575,11 @@ static t_Error TgecDisable (t_Handle h_Tgec, e_CommMode mode)
 
 /* .............................................................................. */
 
-static t_Error TgecTxMacPause(t_Handle h_Tgec, uint16_t pauseTime, uint16_t exPauseTime )
+static t_Error TgecTxMacPause(t_Handle h_Tgec, uint16_t pauseTime)
 {
-    t_Tgec      *p_Tgec = (t_Tgec *)h_Tgec;
-    uint32_t    ptv = 0 ;
-    t_TgecMemMap *p_MemMap;
-    UNUSED(exPauseTime);
+    t_Tgec          *p_Tgec = (t_Tgec *)h_Tgec;
+    uint32_t        ptv = 0;
+    t_TgecMemMap    *p_MemMap;
 
     SANITY_CHECK_RETURN_ERROR(p_Tgec, E_INVALID_STATE);
     SANITY_CHECK_RETURN_ERROR(!p_Tgec->p_TgecDriverParam, E_INVALID_STATE);
@@ -548,7 +587,7 @@ static t_Error TgecTxMacPause(t_Handle h_Tgec, uint16_t pauseTime, uint16_t exPa
 
     p_MemMap = (t_TgecMemMap*)(p_Tgec->p_MemMap);
 
-    ptv = (uint32_t)pauseTime ;
+    ptv = (uint32_t)pauseTime;
 
     WRITE_UINT32(p_MemMap->pause_quant, ptv);
 
@@ -609,6 +648,40 @@ static t_Error TgecGetStatistics(t_Handle h_Tgec, t_FmMacStatistics *p_Statistic
 
 /* .............................................................................. */
 
+/* .............................................................................. */
+
+static t_Error TgecEnable1588TimeStamp(t_Handle h_Tgec)
+{
+    t_Tgec              *p_Tgec = (t_Tgec *)h_Tgec;
+    t_TgecMemMap        *p_TgecMemMap;
+
+    SANITY_CHECK_RETURN_ERROR(p_Tgec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_Tgec->p_TgecDriverParam, E_INVALID_STATE);
+
+    p_TgecMemMap = p_Tgec->p_MemMap;
+    SANITY_CHECK_RETURN_ERROR(p_TgecMemMap, E_INVALID_HANDLE);
+
+    WRITE_UINT32(p_TgecMemMap->cmd_conf_ctrl, GET_UINT32(p_TgecMemMap->cmd_conf_ctrl) | CMD_CFG_EN_TIMESTAMP);
+
+    return E_OK;
+}
+
+static t_Error TgecDisable1588TimeStamp(t_Handle h_Tgec)
+{
+    t_Tgec              *p_Tgec = (t_Tgec *)h_Tgec;
+    t_TgecMemMap        *p_TgecMemMap;
+
+    SANITY_CHECK_RETURN_ERROR(p_Tgec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_Tgec->p_TgecDriverParam, E_INVALID_STATE);
+
+    p_TgecMemMap = p_Tgec->p_MemMap;
+    SANITY_CHECK_RETURN_ERROR(p_TgecMemMap, E_INVALID_HANDLE);
+
+    WRITE_UINT32(p_TgecMemMap->cmd_conf_ctrl, GET_UINT32(p_TgecMemMap->cmd_conf_ctrl) & ~CMD_CFG_EN_TIMESTAMP);
+
+    return E_OK;
+}
+
 static t_Error TgecModifyMacAddress (t_Handle h_Tgec, t_EnetAddr *p_EnetAddr)
 {
     t_Tgec              *p_Tgec = (t_Tgec *)h_Tgec;
@@ -899,7 +972,8 @@ static t_Error TgecAdjustLink(t_Handle h_Tgec, e_EnetSpeed speed, bool fullDuple
     if (!fullDuplex)
         RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("half-duplex"));
 
-RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+    UNUSED(speed);
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
     return E_OK;
 }
 
@@ -914,6 +988,28 @@ static t_Error TgecSetExcpetion(t_Handle h_Tgec, e_FmMacExceptions exception, bo
     SANITY_CHECK_RETURN_ERROR(p_Tgec, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_Tgec->p_TgecDriverParam, E_INVALID_HANDLE);
 
+#ifdef BUP_FM_10G_REM_N_LCL_FLT_EX_ERRATA
+    {
+        t_FmRevisionInfo revInfo;
+        if(enable)
+        {
+            if(exception == e_FM_MAC_EX_10G_LOC_FAULT)
+            {
+                FmGetRevision(p_Tgec->fmMacControllerDriver.h_Fm, &revInfo);
+                if ((revInfo.majorRev == 1) && (revInfo.minorRev == 0))
+                    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("e_FM_MAC_EX_10G_LOC_FAULT!"));
+            }
+            else
+                if(exception == e_FM_MAC_EX_10G_REM_FAULT)
+                {
+                    FmGetRevision(p_Tgec->fmMacControllerDriver.h_Fm, &revInfo);
+                    if ((revInfo.majorRev == 1) && (revInfo.minorRev == 0))
+                        RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("e_FM_MAC_EX_10G_REM_FAULT!"));
+                }
+        }
+    }
+#endif   /* BUP_FM_10G_REM_N_LCL_FLT_EX_ERRATA */
+
     GET_EXCEPTION_FLAG(bitMask, exception);
     if(bitMask)
     {
@@ -934,6 +1030,15 @@ static t_Error TgecSetExcpetion(t_Handle h_Tgec, e_FmMacExceptions exception, bo
     return E_OK;
 }
 
+static uint16_t TgecGetMaxFrameLength(t_Handle h_Tgec)
+{
+    t_Tgec              *p_Tgec = (t_Tgec *)h_Tgec;
+
+    SANITY_CHECK_RETURN_VALUE(p_Tgec, E_INVALID_HANDLE, 0);
+
+    return (uint16_t)GET_UINT32(p_Tgec->p_MemMap->maxfrm);
+}
+
 /* .............................................................................. */
 
 #if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
@@ -999,17 +1104,19 @@ static void InitFmMacControllerDriver(t_FmMacControllerDriver *p_FmMacController
 
     p_FmMacControllerDriver->f_FM_MAC_ConfigPadAndCrc           = TgecConfigPadAndCrc;
     p_FmMacControllerDriver->f_FM_MAC_ConfigHalfDuplex          = NULL; /* half-duplex is not supported in xgec */
-    p_FmMacControllerDriver->f_FM_MAC_ConfigHugeFrames          = TgecConfigHugeFrames;
+    p_FmMacControllerDriver->f_FM_MAC_ConfigLengthCheck         = TgecConfigLengthCheck;
     p_FmMacControllerDriver->f_FM_MAC_ConfigException           = TgecConfigException;
 
     p_FmMacControllerDriver->f_FM_MAC_SetException              = TgecSetExcpetion;
 
+    p_FmMacControllerDriver->f_FM_MAC_Enable1588TimeStamp       = TgecEnable1588TimeStamp;
+    p_FmMacControllerDriver->f_FM_MAC_Disable1588TimeStamp      = TgecDisable1588TimeStamp;
+
     p_FmMacControllerDriver->f_FM_MAC_SetPromiscuous            = TgecSetPromiscuous;
     p_FmMacControllerDriver->f_FM_MAC_AdjustLink                = TgecAdjustLink;
 
     p_FmMacControllerDriver->f_FM_MAC_Enable                    = TgecEnable;
     p_FmMacControllerDriver->f_FM_MAC_Disable                   = TgecDisable;
-    p_FmMacControllerDriver->f_FM_MAC_Restart                   = NULL; /* TgecRestart; Not Implemented */
 
     p_FmMacControllerDriver->f_FM_MAC_TxMacPause                = TgecTxMacPause;
 
@@ -1023,6 +1130,7 @@ static void InitFmMacControllerDriver(t_FmMacControllerDriver *p_FmMacController
     p_FmMacControllerDriver->f_FM_MAC_RemovelExactMatchMacAddr  = TgecDelExactMatchMacAddress;
     p_FmMacControllerDriver->f_FM_MAC_GetId                     = TgecGetId;
     p_FmMacControllerDriver->f_FM_MAC_GetVersion                = TgecGetVersion;
+    p_FmMacControllerDriver->f_FM_MAC_GetMaxFrameLength         = TgecGetMaxFrameLength;
 
     p_FmMacControllerDriver->f_FM_MAC_MII_WritePhyReg           = TGEC_MII_WritePhyReg;
     p_FmMacControllerDriver->f_FM_MAC_MII_ReadPhyReg            = TGEC_MII_ReadPhyReg;
@@ -1074,9 +1182,9 @@ t_Handle  TGEC_Config(t_FmMacParams *p_FmMacParam)
     p_Tgec->enetMode = p_FmMacParam->enetMode;
     p_Tgec->macId    = p_FmMacParam->macId;
     p_Tgec->exceptions = DEFAULT_exceptions;
-    p_Tgec->f_Exceptions = p_FmMacParam->f_Exceptions;
+    p_Tgec->f_Exception = p_FmMacParam->f_Exception;
     p_Tgec->mdioIrq = p_FmMacParam->mdioIrq;
-    p_Tgec->f_Events = p_FmMacParam->f_Events;
+    p_Tgec->f_Event = p_FmMacParam->f_Event;
 
     return p_Tgec;
 }
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/tgec.h b/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/tgec.h
index 173f67c..fa665d6 100644
--- a/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/tgec.h
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/tgec.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -44,6 +44,7 @@
 #include "tgec_mii_acc.h"
 #include "fm_mac.h"
 
+
 /* Interrupt Mask Register (IMASK) */
 #define IMASK_MDIO_SCAN_EVENTMDIO   0x00010000  /* MDIO_SCAN_EVENTMDIO scan event interrupt mask.
                                                  * 0 masked
@@ -114,6 +115,23 @@
                                                  * 1 enabled
                                                  */
 
+#define EVENTS_MASK                 ((uint32_t)(IMASK_MDIO_SCAN_EVENTMDIO |  \
+                                                IMASK_MDIO_CMD_CMPL       |  \
+                                                IMASK_REM_FAULT           |  \
+                                                IMASK_LOC_FAULT           |  \
+                                                IMASK_1TX_ECC_ER          |  \
+                                                IMASK_TX_FIFO_UNFL        |  \
+                                                IMASK_TX_FIFO_OVFL        |  \
+                                                IMASK_TX_ER               |  \
+                                                IMASK_RX_FIFO_OVFL        |  \
+                                                IMASK_RX_ECC_ER           |  \
+                                                IMASK_RX_JAB_FRM          |  \
+                                                IMASK_RX_OVRSZ_FRM        |  \
+                                                IMASK_RX_RUNT_FRM         |  \
+                                                IMASK_RX_FRAG_FRM         |  \
+                                                IMASK_RX_LEN_ER           |  \
+                                                IMASK_RX_CRC_ER           |  \
+                                                IMASK_RX_ALIGN_ER))
 
 #define GET_EXCEPTION_FLAG(bitMask, exception)       switch(exception){ \
     case e_FM_MAC_EX_10G_MDIO_SCAN_EVENTMDIO:                                    \
@@ -168,7 +186,6 @@
 #define DEFAULT_rxErrorDiscard              FALSE
 #define DEFAULT_phyTxenaOn                  FALSE
 #define DEFAULT_sendIdleEnable              FALSE
-/* TODO - change it back to check length!!! */
 #define DEFAULT_noLengthCheckEnable         TRUE
 #define DEFAULT_lgthCheckNostdr             FALSE
 #define DEFAULT_timeStampEnable             FALSE
@@ -185,40 +202,21 @@
 #define DEFAULT_pauseTime                   0xf000
 #define DEFAULT_imask                       0xf000
 
-#define DEFAULT_exceptions         ((uint32_t)(IMASK_MDIO_SCAN_EVENTMDIO |  \
-                                               IMASK_REM_FAULT           |  \
-                                               IMASK_LOC_FAULT           |  \
-                                               IMASK_1TX_ECC_ER          |  \
-                                               IMASK_TX_FIFO_UNFL        |  \
-                                               IMASK_TX_FIFO_OVFL        |  \
-                                               IMASK_TX_ER               |  \
-                                               IMASK_RX_FIFO_OVFL        |  \
-                                               IMASK_RX_ECC_ER           |  \
-                                               IMASK_RX_JAB_FRM          |  \
-                                               IMASK_RX_OVRSZ_FRM        |  \
-                                               IMASK_RX_RUNT_FRM         |  \
-                                               IMASK_RX_FRAG_FRM         |  \
-                                               IMASK_RX_LEN_ER           |  \
-                                               IMASK_RX_CRC_ER           |  \
-                                               IMASK_RX_ALIGN_ER))
-
-
-#define EVENTS_MASK         ((uint32_t)(IMASK_MDIO_SCAN_EVENTMDIO |  \
-                                        IMASK_REM_FAULT           |  \
-                                        IMASK_LOC_FAULT           |  \
-                                        IMASK_1TX_ECC_ER          |  \
-                                        IMASK_TX_FIFO_UNFL        |  \
-                                        IMASK_TX_FIFO_OVFL        |  \
-                                        IMASK_TX_ER               |  \
-                                        IMASK_RX_FIFO_OVFL        |  \
-                                        IMASK_RX_ECC_ER           |  \
-                                        IMASK_RX_JAB_FRM          |  \
-                                        IMASK_RX_OVRSZ_FRM        |  \
-                                        IMASK_RX_RUNT_FRM         |  \
-                                        IMASK_RX_FRAG_FRM         |  \
-                                        IMASK_RX_LEN_ER           |  \
-                                        IMASK_RX_CRC_ER           |  \
-                                        IMASK_RX_ALIGN_ER))
+#define DEFAULT_exceptions          ((uint32_t)(IMASK_MDIO_SCAN_EVENTMDIO |  \
+                                                IMASK_REM_FAULT           |  \
+                                                IMASK_LOC_FAULT           |  \
+                                                IMASK_1TX_ECC_ER          |  \
+                                                IMASK_TX_FIFO_UNFL        |  \
+                                                IMASK_TX_FIFO_OVFL        |  \
+                                                IMASK_TX_ER               |  \
+                                                IMASK_RX_FIFO_OVFL        |  \
+                                                IMASK_RX_ECC_ER           |  \
+                                                IMASK_RX_JAB_FRM          |  \
+                                                IMASK_RX_OVRSZ_FRM        |  \
+                                                IMASK_RX_RUNT_FRM         |  \
+                                                IMASK_RX_FRAG_FRM         |  \
+                                                IMASK_RX_CRC_ER           |  \
+                                                IMASK_RX_ALIGN_ER))
 
 #define MAX_PACKET_ALIGNMENT        31
 #define MAX_INTER_PACKET_GAP        0x7f
@@ -333,7 +331,7 @@
                                                  * 0 disabled
                                                  * 1 enabled
                                                  */
-#define HASH_ADDR_MASK              0x000001ff  /* 2331 HASH_ADDR Hash table address code.
+#define HASH_ADDR_MASK              0x000001ff  /* 23-31 HASH_ADDR Hash table address code.
                                                  */
 
 /* Transmit Inter-Packet Gap Length Register (TX_IPG_LENGTH) */
@@ -341,9 +339,9 @@
 
 
 
-#ifdef __MWERKS__
+#if defined(__MWERKS__) && !defined(__GNUC__)
 #pragma pack(push,1)
-#endif /*__MWERKS__ */
+#endif /* defined(__MWERKS__) && ... */
 #define MEM_MAP_START
 
 /*
@@ -419,9 +417,9 @@ typedef _Packed struct {
 } _PackedType t_TgecMemMap;
 
 #define MEM_MAP_END
-#ifdef __MWERKS__
+#if defined(__MWERKS__) && !defined(__GNUC__)
 #pragma pack(pop)
-#endif /* __MWERKS__ */
+#endif /* defined(__MWERKS__) && ... */
 
 
 typedef struct {
@@ -454,8 +452,8 @@ typedef struct {
                                         If cleared (default) the MAC */
     uint32_t txIpgLength;           /*Transmit Inter-Packet-Gap (IPG) value.
                                       A 6-bit value: Depending on LAN or WAN mode of operation (see COMMAND_CONFIG, 19.2.1 page 91) the value has the following meaning:
-                                         LAN Mode: Number of octets in steps of 4. Valid values are 8, 12, 16, ... 100. DIC is fully supported (see 10.6.1 page 49) for any setting. A default of 12 (reset value) must be set to conform to IEEE802.3ae. Warning: When set to 8, PCS layers may not be able to perform clock rate compensation.
-                                         WAN Mode: Stretch factor. Valid values are 4..15. The stretch factor is calculated as (value+1)*8. A default of 12 (reset value) must be set to conform to IEEE 802.3ae (i.e. 13*8=104). A larger value shrinks the IPG (increasing bandwidth). */
+                                        - LAN Mode: Number of octets in steps of 4. Valid values are 8, 12, 16, ... 100. DIC is fully supported (see 10.6.1 page 49) for any setting. A default of 12 (reset value) must be set to conform to IEEE802.3ae. Warning: When set to 8, PCS layers may not be able to perform clock rate compensation.
+                                        - WAN Mode: Stretch factor. Valid values are 4..15. The stretch factor is calculated as (value+1)*8. A default of 12 (reset value) must be set to conform to IEEE 802.3ae (i.e. 13*8=104). A larger value shrinks the IPG (increasing bandwidth). */
 /*.. */
     bool        statisticsEnable;
     uint16_t    maxFrameLength;
@@ -474,9 +472,9 @@ typedef struct {
     t_TgecMiiAccessMemMap       *p_MiiMemMap;                       /**< pointer to MII memory mapped registers.          */
     uint64_t                    addr;                               /**< MAC address of device; */
     e_EnetMode                  enetMode;                           /**< Ethernet physical interface  */
-    t_FmMacExceptionCallback    *f_Exceptions;
+    t_FmMacExceptionCallback    *f_Exception;
     int                         mdioIrq;
-    t_FmMacExceptionCallback    *f_Events;
+    t_FmMacExceptionCallback    *f_Event;
     bool                        indAddrRegUsed[TGEC_NUM_OF_PADDRS]; /**< Whether a particular individual address recognition register is being used */
     uint64_t                    paddr[TGEC_NUM_OF_PADDRS];          /**< MAC address for particular individual address recognition register */
     uint8_t                     numOfIndAddrInRegs;                 /**< Number of individual addresses in registers for this station. */
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/tgec_mii_acc.c b/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/tgec_mii_acc.c
index 97a23a8..2a9c788 100644
--- a/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/tgec_mii_acc.c
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/tgec_mii_acc.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -64,6 +64,9 @@ t_Error TGEC_MII_WritePhyReg(t_Handle   h_Tgec,
 
     WRITE_UINT32(p_MiiAccess->mdio_data, data);
 
+    while ((GET_UINT32(p_MiiAccess->mdio_data)) & MIIDATA_BUSY)
+        XX_UDelay (1);
+
     return E_OK;
 }
 
@@ -75,6 +78,7 @@ t_Error TGEC_MII_ReadPhyReg(t_Handle h_Tgec,
 {
     t_Tgec                  *p_Tgec = (t_Tgec *)h_Tgec;
     t_TgecMiiAccessMemMap   *p_MiiAccess;
+    uint32_t                cfg_status;
 
     SANITY_CHECK_RETURN_ERROR(p_Tgec, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Tgec->p_MiiMemMap, E_INVALID_HANDLE);
@@ -96,10 +100,17 @@ t_Error TGEC_MII_ReadPhyReg(t_Handle h_Tgec,
     while ((GET_UINT32(p_MiiAccess->mdio_cfg_status)) & MIIMIND_BUSY)
         XX_UDelay (1);
 
+    cfg_status  = GET_UINT32(p_MiiAccess->mdio_cfg_status);
+
+    while ((GET_UINT32(p_MiiAccess->mdio_data)) & MIIDATA_BUSY)
+        XX_UDelay (1);
+
     *p_Data =  (uint16_t)GET_UINT32(p_MiiAccess->mdio_data);
 
-    if (*p_Data == 0xffff)
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Read wrong data (0xffff): phyAddr 0x%x, reg 0x%x", phyAddr, reg));
+    if (cfg_status & MIIMIND_READ_ERROR)
+        RETURN_ERROR(MINOR, E_INVALID_VALUE,
+                     ("Read Error: phyAddr 0x%x, dev 0x%x, reg 0x%x, cfg_status 0x%x",
+                      ((phyAddr & 0xe0)>>5), (phyAddr & 0x1f), reg, cfg_status));
 
     return E_OK;
 }
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/tgec_mii_acc.h b/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/tgec_mii_acc.h
index 51b996a..ebf774c 100644
--- a/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/tgec_mii_acc.h
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/tgec_mii_acc.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -42,14 +42,23 @@
 #define MIIMCOM_SCAN_CYCLE          0x00000800
 #define MIIMCOM_PREAMBLE_DISABLE    0x00000400
 
+#define MIIMCOM_MDIO_HOLD_1_REG_CLK 0
+#define MIIMCOM_MDIO_HOLD_2_REG_CLK 1
+#define MIIMCOM_MDIO_HOLD_3_REG_CLK 2
+#define MIIMCOM_MDIO_HOLD_4_REG_CLK 3
+
+#define MIIMCOM_DIV_MASK            0x0000ff00
+#define MIIMCOM_DIV_SHIFT           8
+
 /* MII Management Indicator Register */
 #define MIIMIND_BUSY                0x00000001
 #define MIIMIND_READ_ERROR          0x00000002
 
+#define MIIDATA_BUSY                0x80000000
 
-#ifdef __MWERKS__
+#if defined(__MWERKS__) && !defined(__GNUC__)
 #pragma pack(push,1)
-#endif /*__MWERKS__ */
+#endif /* defined(__MWERKS__) && ... */
 #define MEM_MAP_START
 
 /*----------------------------------------------------*/
@@ -64,9 +73,9 @@ typedef _Packed struct t_TgecMiiAccessMemMap
 } _PackedType t_TgecMiiAccessMemMap ;
 
 #define MEM_MAP_END
-#ifdef __MWERKS__
+#if defined(__MWERKS__) && !defined(__GNUC__)
 #pragma pack(pop)
-#endif /* __MWERKS__ */
+#endif /* defined(__MWERKS__) && ... */
 
 
 #endif /* __TGEC_MII_ACC_H */
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/Makefile b/drivers/net/dpa/NetCommSw/Peripherals/FM/Makefile
index 97f3472..a74b5fe 100644
--- a/drivers/net/dpa/NetCommSw/Peripherals/FM/Makefile
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/Makefile
@@ -18,3 +18,4 @@ obj-y		+= MAC/
 obj-y		+= Pcd/
 obj-y		+= Port/
 obj-y		+= HC/
+obj-y		+= Rtc/
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.c b/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.c
index 214d4c9..307a2a6 100644
--- a/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.c
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -184,7 +184,7 @@ static t_CcNodeInfo * FindNodeInfoAccIdAndAddToRetLst(t_List *p_List, uint16_t n
 
 static void  UpdateNodeOwner(t_FmPcd  *p_FmPcd, uint16_t nodeId, bool add)
 {
-    ASSERT_COND(nodeId < MAX_NUM_OF_PCD_CC_NODES);
+    ASSERT_COND(nodeId < FM_PCD_MAX_NUM_OF_CC_NODES);
     if(add)
         p_FmPcd->p_FmPcdCc->ccNodeArrayEntry[nodeId].owners++;
     else
@@ -196,7 +196,7 @@ static void  UpdateNodeOwner(t_FmPcd  *p_FmPcd, uint16_t nodeId, bool add)
 
 static t_Handle GetNodeHandler(t_FmPcd *p_FmPcd, uint16_t nodeId)
 {
-    ASSERT_COND(nodeId < MAX_NUM_OF_PCD_CC_NODES);
+    ASSERT_COND(nodeId < FM_PCD_MAX_NUM_OF_CC_NODES);
     return p_FmPcd->p_FmPcdCc->ccNodeArrayEntry[nodeId].p_FmPcdCcNode;
 
 }
@@ -212,7 +212,7 @@ static void SetNodeHandler(t_Handle h_FmPcdCc, uint16_t nodeId, t_Handle p_FmPcd
 static t_Handle FmPcdCcGetTreeHandler(t_Handle h_FmPcd, uint8_t treeId)
 {
 
-    ASSERT_COND(treeId < MAX_NUM_OF_PCD_CC_TREES);
+    ASSERT_COND(treeId < FM_PCD_MAX_NUM_OF_CC_TREES);
     return ((t_FmPcd*)h_FmPcd)->p_FmPcdCc->ccTreeArrayEntry[treeId].p_FmPcdCcTree;
 }
 
@@ -227,13 +227,13 @@ static void SetTreeHandler(t_Handle h_FmPcdCc, uint8_t treeId, t_Handle p_FmPcdC
 
 static uint8_t GetTreeOwners(t_FmPcd *p_FmPcd, uint8_t treeId)
 {
-    ASSERT_COND(treeId < MAX_NUM_OF_PCD_CC_TREES);
+    ASSERT_COND(treeId < FM_PCD_MAX_NUM_OF_CC_TREES);
     return p_FmPcd->p_FmPcdCc->ccTreeArrayEntry[treeId].owners;
 }
 
 static uint8_t GetNodeOwners(t_FmPcd *p_FmPcd, uint16_t nodeId)
 {
-    ASSERT_COND(nodeId < MAX_NUM_OF_PCD_CC_NODES);
+    ASSERT_COND(nodeId < FM_PCD_MAX_NUM_OF_CC_NODES);
     return p_FmPcd->p_FmPcdCc->ccNodeArrayEntry[nodeId].owners;
 }
 
@@ -243,7 +243,7 @@ static t_Error OccupyNodeId(t_FmPcd *p_FmPcd, uint16_t *nodeId)
     uint16_t i = 0;
 
     TRY_LOCK_RET_ERR(p_FmPcd->lock);
-    for(i = 0; i < MAX_NUM_OF_PCD_CC_NODES; i++)
+    for(i = 0; i < FM_PCD_MAX_NUM_OF_CC_NODES; i++)
     {
         if(!p_FmPcd->p_FmPcdCc->ccNodeArrayEntry[i].occupied && !p_FmPcd->p_FmPcdCc->ccNodeArrayEntry[i].p_FmPcdCcNode)
         {
@@ -263,7 +263,7 @@ static t_Error OccupyTreeId(t_FmPcd *p_FmPcd, uint8_t *treeId)
     uint16_t i = 0;
 
     TRY_LOCK_RET_ERR(p_FmPcd->lock);
-    for(i = 0; i < MAX_NUM_OF_PCD_CC_NODES; i++)
+    for(i = 0; i < FM_PCD_MAX_NUM_OF_CC_NODES; i++)
     {
         if(!p_FmPcd->p_FmPcdCc->ccTreeArrayEntry[i].occupied && !p_FmPcd->p_FmPcdCc->ccTreeArrayEntry[i].p_FmPcdCcTree)
         {
@@ -284,7 +284,7 @@ static bool CcNodeIsValid(t_FmPcd *p_FmPcd, uint16_t nodeId)
 {
     t_FmPcdCc *p_FmPcdCc = p_FmPcd->p_FmPcdCc;
 
-    ASSERT_COND(nodeId < MAX_NUM_OF_PCD_CC_NODES);
+    ASSERT_COND(nodeId < FM_PCD_MAX_NUM_OF_CC_NODES);
 
     if(!p_FmPcdCc->ccNodeArrayEntry[nodeId].occupied ||
         !p_FmPcdCc->ccNodeArrayEntry[nodeId].p_FmPcdCcNode)
@@ -510,10 +510,10 @@ static void ReleaseTreeHandler(t_FmPcdCcTree *p_FmPcdTreeNode, t_FmPcdCc *p_FmPc
 
     if(p_FmPcdTreeNode)
     {
-        if(p_FmPcdTreeNode->p_CcBaseTree)
+        if(p_FmPcdTreeNode->ccTreeBaseAddr)
         {
-            FM_MURAM_FreeMem(p_FmPcdCc->h_FmMuram,p_FmPcdTreeNode->p_CcBaseTree);
-            p_FmPcdTreeNode->p_CcBaseTree = NULL;
+            FM_MURAM_FreeMem(p_FmPcdCc->h_FmMuram, CAST_UINT64_TO_POINTER(p_FmPcdTreeNode->ccTreeBaseAddr));
+            p_FmPcdTreeNode->ccTreeBaseAddr = 0;
         }
 
 
@@ -627,6 +627,17 @@ static uint8_t GetGenParseCode(e_FmPcdExtractFrom src, uint32_t offset, bool glb
             else
                 return CC_PR_WITHOUT_OFFSET;
         break;
+        case(e_FM_PCD_EXTRACT_FROM_IC_KEY) :
+            *parseArrayOffset = 0x50;
+            return CC_PC_GENERIC_IC_GMASK;
+            break;
+        case(e_FM_PCD_EXTRACT_FROM_IC_HASH_EXACT_MATCH) :
+            *parseArrayOffset = 0x48;
+            return CC_PC_GENERIC_IC_GMASK;
+            break;
+        case(e_FM_PCD_EXTRACT_FROM_IC_HASH_INDEXED_MATCH) :
+            return CC_PC_GENERIC_IC_HASH_INDEXED;
+             break;
         default:
             REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("Illegal 'extract from' src"));
             return CC_PC_ILLEGAL;
@@ -1055,14 +1066,14 @@ static void FillAdOfTypeContLookup(t_Handle p_Ad,  t_Handle h_FmPcd, t_Handle p_
     tmpReg32 = 0;
     tmpReg32 |= FM_PCD_AD_CONT_LOOKUP_TYPE;
     tmpReg32 |= p_Node->sizeOfExtraction ? ((p_Node->sizeOfExtraction - 1) << 24) : 0;
-    tmpReg32 |= (uint32_t)(CAST_POINTER_TO_UINT64(XX_VirtToPhys(p_Node->h_AdTable)) - (((t_FmPcd*)h_FmPcd)->p_FmPcdCc)->physicalMuramBase);
+    tmpReg32 |= (uint32_t)((uint64_t)(XX_VirtToPhys(p_Node->h_AdTable)) - (((t_FmPcd*)h_FmPcd)->p_FmPcdCc)->physicalMuramBase);
     WRITE_UINT32(p_AdContLookup->ccAdBase, tmpReg32);
 
     tmpReg32 = 0;
     tmpReg32 |= p_Node->numOfKeys << 24;
     tmpReg32 |= (p_Node->lclMask ? FM_PCD_AD_CONT_LOOKUP_LCL_MASK : 0);
     tmpReg32 |= p_Node->h_KeysMatchTable ?
-                    (uint32_t)(CAST_POINTER_TO_UINT64(XX_VirtToPhys(p_Node->h_KeysMatchTable)) - (((t_FmPcd*)h_FmPcd)->p_FmPcdCc)->physicalMuramBase) : 0;
+                    (uint32_t)((uint64_t)(XX_VirtToPhys(p_Node->h_KeysMatchTable)) - (((t_FmPcd*)h_FmPcd)->p_FmPcdCc)->physicalMuramBase) : 0;
     WRITE_UINT32(p_AdContLookup->matchTblPtr, tmpReg32);
 
     tmpReg32 = 0;
@@ -1274,7 +1285,7 @@ static t_Error BuildNewNodeAddKey(t_Handle h_FmPcd ,t_FmPcdCcNode *p_FmPcdCcNode
 
     p_AdditionalInfo->numOfKeys = (uint8_t)(p_FmPcdCcNode->numOfKeys + 1);
 
-    err = BuildNewNodeCommonPart(h_FmPcd, p_FmPcdCcNode, &size, (p_KeyParams->p_Mask ? TRUE : FALSE), p_AdditionalInfo);
+    err = BuildNewNodeCommonPart(h_FmPcd, p_FmPcdCcNode, &size, (bool)(p_KeyParams->p_Mask ? TRUE : FALSE), p_AdditionalInfo);
     if(err)
         RETURN_ERROR(MAJOR, err, NO_MSG);
 
@@ -1340,7 +1351,7 @@ static t_Error BuildNewNodeRemoveKey(t_Handle h_FmPcd  ,t_FmPcdCcNode *p_FmPcdCc
 
     p_AdditionalInfo->numOfKeys = (uint16_t)(p_FmPcdCcNode->numOfKeys - 1);
 
-    err = BuildNewNodeCommonPart(h_FmPcd, p_FmPcdCcNode, &size, (p_FmPcdCcNode->lclMask ? TRUE : FALSE), p_AdditionalInfo);
+    err = BuildNewNodeCommonPart(h_FmPcd, p_FmPcdCcNode, &size, (bool)(p_FmPcdCcNode->lclMask ? TRUE : FALSE), p_AdditionalInfo);
     if(err)
         RETURN_ERROR(MAJOR, err, NO_MSG);
 
@@ -1385,7 +1396,7 @@ static t_Error BuildNewNodeModifyKey(t_Handle h_FmPcd ,t_FmPcdCcNode *p_FmPcdCcN
 
     p_AdditionalInfo->numOfKeys =  p_FmPcdCcNode->numOfKeys;
 
-    err = BuildNewNodeCommonPart(h_FmPcd, p_FmPcdCcNode, &size, (p_Mask ? TRUE : FALSE), p_AdditionalInfo);
+    err = BuildNewNodeCommonPart(h_FmPcd, p_FmPcdCcNode, &size, (bool)(p_Mask ? TRUE : FALSE), p_AdditionalInfo);
     if(err)
         RETURN_ERROR(MAJOR, err, NO_MSG);
 
@@ -1452,7 +1463,7 @@ static t_Error BuildNewNodeModifyKeyAndNextEngine(t_Handle h_FmPcd ,t_FmPcdCcNod
 
     p_AdditionalInfo->numOfKeys = p_FmPcdCcNode->numOfKeys;
 
-    err = BuildNewNodeCommonPart(h_FmPcd, p_FmPcdCcNode, &size, (p_KeyParams->p_Mask ? TRUE : FALSE), p_AdditionalInfo);
+    err = BuildNewNodeCommonPart(h_FmPcd, p_FmPcdCcNode, &size, (bool)(p_KeyParams->p_Mask ? TRUE : FALSE), p_AdditionalInfo);
     if(err)
         RETURN_ERROR(MAJOR, err, NO_MSG);
 
@@ -1579,7 +1590,7 @@ static t_Error ModifyWithTreeDataStructure(t_FmPcd *p_FmPcd,uint16_t nodeId, t_F
         LIST_FOR_EACH(p_Pos1, &p_List)
         {
             p_CcNodeInfo = CC_NEXT_NODE_F_OBJECT(p_Pos1);
-            CreateNodeInfo(h_OldLst, (uint32_t)((uint32_t)(p_FmPcdCcTreePrev->p_CcBaseTree) + FM_PCD_CC_AD_ENTRY_SIZE * (p_CcNodeInfo->nextCcNodeInfo >> 16)));
+            CreateNodeInfo(h_OldLst, (uint32_t)(p_FmPcdCcTreePrev->ccTreeBaseAddr + FM_PCD_CC_AD_ENTRY_SIZE * (p_CcNodeInfo->nextCcNodeInfo >> 16)));
         }
     }
     ReleaseLst(&p_List);
@@ -1636,7 +1647,8 @@ t_Error FmPcdCcModifyNextEngineParamTree(t_Handle h_FmPcd, t_Handle h_FmPcdCcTre
         RETURN_ERROR(MAJOR, err, NO_MSG);
 
     p_CcOldModifyAdditionalParams = *h_OldPointer;
-    p_CcOldModifyAdditionalParams->p_Ad = (t_Handle)((uint32_t)p_FmPcdCcTree->p_CcBaseTree + FM_PCD_CC_AD_ENTRY_SIZE* (p_FmPcdCcTree->fmPcdGroupParam[grpId].baseGroupEntry + index));
+    p_CcOldModifyAdditionalParams->p_Ad =
+        CAST_UINT64_TO_POINTER(p_FmPcdCcTree->ccTreeBaseAddr + FM_PCD_CC_AD_ENTRY_SIZE* (p_FmPcdCcTree->fmPcdGroupParam[grpId].baseGroupEntry + index));
     p_CcOldModifyAdditionalParams->isTree = TRUE;
     p_CcOldModifyAdditionalParams->h_Node = p_FmPcdCcTree;
     p_CcNewModifyAdditionalParams  = *h_NewPointer;
@@ -1702,7 +1714,7 @@ t_Error FmPcdCcAddKey(t_Handle h_FmPcd, t_Handle h_FmPcdCcNode, uint8_t keyIndex
     if(keyIndex > p_FmPcdCcNode->numOfKeys)
         RETURN_ERROR(MAJOR, E_INVALID_STATE, ("keyIndex > previousely cleared last index + 1"));
 
-    if((p_FmPcdCcNode->numOfKeys + 1) > MAX_NUM_OF_PCD_CC_NODES)
+    if((p_FmPcdCcNode->numOfKeys + 1) > FM_PCD_MAX_NUM_OF_CC_NODES)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("numOfKeys with new key can not be larger than 255"));
 
     err = BuildNewNodeAddKey (h_FmPcd, p_FmPcdCcNode, keyIndex, p_FmPcdCcKeyParams, p_FmPcdModifyCcKeyAdditionalParams);
@@ -1949,7 +1961,7 @@ t_Error FmPcdCcReleaseModifiedOnlyNextEngine(t_Handle h_FmPcd, t_Handle h_FmPcdO
     uint16_t                         numOfReplec;
     t_Error                          err = E_OK;
     t_List                          *p_Pos;
-    uint16_t                        ccArray[MAX_NUM_OF_PCD_CC_NODES];
+    uint16_t                        ccArray[FM_PCD_MAX_NUM_OF_CC_NODES];
 
     SANITY_CHECK_RETURN_ERROR(h_FmPcd,E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdCc,E_INVALID_HANDLE);
@@ -1978,7 +1990,7 @@ t_Error FmPcdCcReleaseModifiedOnlyNextEngine(t_Handle h_FmPcd, t_Handle h_FmPcdO
                         }
                         else
                             CreateNodeInfo(&p_NodeForAdd->ccTreeIdLst, (uint32_t)((uint32_t)p_CurrentTree->treeId | ((uint32_t)1<<16)));
-                        memset(ccArray, 0, sizeof(uint16_t) * MAX_NUM_OF_PCD_CC_NODES);
+                        memset(ccArray, 0, sizeof(uint16_t) * FM_PCD_MAX_NUM_OF_CC_NODES);
                         err = UpdateNodesWithTree(h_FmPcd, &p_NodeForAdd->ccNextNodesLst, ccArray, p_CurrentTree->treeId);
                         if(err)
                             RETURN_ERROR(MAJOR, err, NO_MSG);
@@ -2028,7 +2040,7 @@ t_Error FmPcdCcReleaseModifiedOnlyNextEngine(t_Handle h_FmPcd, t_Handle h_FmPcdO
                         LIST_FOR_EACH(p_Pos, &p_CurrentNode->ccTreesLst)
                         {
                             p_CcNodeInfo = CC_NEXT_NODE_F_OBJECT(p_Pos);
-                            memset(ccArray, 0, sizeof(uint16_t)*MAX_NUM_OF_PCD_CC_NODES);
+                            memset(ccArray, 0, sizeof(uint16_t)*FM_PCD_MAX_NUM_OF_CC_NODES);
                             err = UpdateNodesWithTree(p_FmPcd, &p_NodeForAdd->ccNextNodesLst, ccArray, (uint8_t)p_CcNodeInfo->nextCcNodeInfo);
                             if(err)
                                 RETURN_ERROR(MAJOR, err, NO_MSG);
@@ -2089,7 +2101,7 @@ t_Error FmPcdCcReleaseModifiedKey(t_Handle h_FmPcd, t_List *h_FmPcdOldPointersLs
     uint32_t                        numOfReplec;
     t_List                          *p_Pos;
     t_Error                         err = E_OK;
-    uint16_t                        ccArray[MAX_NUM_OF_PCD_CC_NODES];
+    uint16_t                        ccArray[FM_PCD_MAX_NUM_OF_CC_NODES];
 
     UNUSED(numOfGoodChanges);
 
@@ -2122,7 +2134,7 @@ t_Error FmPcdCcReleaseModifiedKey(t_Handle h_FmPcd, t_List *h_FmPcdOldPointersLs
                 LIST_FOR_EACH(p_Pos, &p_CurrentNode->ccTreesLst)
                 {
                     p_CcNodeInfo = CC_NEXT_NODE_F_OBJECT(p_Pos);
-                    memset(ccArray, 0, sizeof(uint16_t)*MAX_NUM_OF_PCD_CC_NODES);
+                    memset(ccArray, 0, sizeof(uint16_t)*FM_PCD_MAX_NUM_OF_CC_NODES);
                     err = UpdateNodesWithTree(p_FmPcd, &p_NodeForAdd->ccNextNodesLst, ccArray, (uint8_t)p_CcNodeInfo->nextCcNodeInfo);
                     if(err)
                         RETURN_ERROR(MAJOR, err, NO_MSG);
@@ -2186,7 +2198,7 @@ uint32_t FmPcdCcGetNodeAddrOffset(t_Handle h_FmPcd, t_Handle h_Pointer)
     SANITY_CHECK_RETURN_VALUE(h_FmPcd,E_INVALID_HANDLE, (uint32_t)ILLEGAL_BASE);
     SANITY_CHECK_RETURN_VALUE(p_FmPcd->p_FmPcdCc,E_INVALID_HANDLE, (uint32_t)ILLEGAL_BASE);
 
-    return (uint32_t)(CAST_POINTER_TO_UINT64(XX_VirtToPhys(((t_FmPcdModifyCcAdditionalParams *)h_Pointer)->p_Ad)) -
+    return (uint32_t)((uint64_t)(XX_VirtToPhys(((t_FmPcdModifyCcAdditionalParams *)h_Pointer)->p_Ad)) -
                      p_FmPcd->p_FmPcdCc->physicalMuramBase);
 }
 
@@ -2199,7 +2211,7 @@ uint32_t FmPcdCcGetNodeAddrOffsetFromNodeInfo(t_Handle h_FmPcd, t_Handle h_Point
     SANITY_CHECK_RETURN_VALUE(p_FmPcd->p_FmPcdCc,E_INVALID_HANDLE, (uint32_t)ILLEGAL_BASE);
 
     p_CcNodeInfo = CC_NEXT_NODE_F_OBJECT(h_Pointer);
-    return (uint32_t)(CAST_POINTER_TO_UINT64(XX_VirtToPhys(CAST_UINT32_TO_POINTER(p_CcNodeInfo->nextCcNodeInfo))) -
+    return (uint32_t)((uint64_t)(XX_VirtToPhys(CAST_UINT32_TO_POINTER(p_CcNodeInfo->nextCcNodeInfo))) -
                       p_FmPcd->p_FmPcdCc->physicalMuramBase);
 }
 
@@ -2212,7 +2224,7 @@ static t_Error  FmPcdCcUpdateTreeOwner(t_Handle h_FmPcd, uint8_t treeId, bool ad
     SANITY_CHECK_RETURN_ERROR(p_FmPcd,E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdCc,E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdCc->ccTreeArrayEntry[treeId].p_FmPcdCcTree,E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR((treeId < MAX_NUM_OF_PCD_CC_TREES), E_INVALID_VALUE);
+    SANITY_CHECK_RETURN_ERROR((treeId < FM_PCD_MAX_NUM_OF_CC_TREES), E_INVALID_VALUE);
 
     if(add)
         p_FmPcd->p_FmPcdCc->ccTreeArrayEntry[treeId].owners++;
@@ -2278,16 +2290,16 @@ void CcFree(t_FmPcdCc *p_FmPcdCc)
 {
 
     int i = 0;
-    for (i = 0; i < MAX_NUM_OF_PCD_CC_NODES; i++)
+    for (i = 0; i < FM_PCD_MAX_NUM_OF_CC_NODES; i++)
         ReleaseNode(p_FmPcdCc, (uint16_t)i);
 
-    for(i = 0; i < MAX_NUM_OF_PCD_CC_TREES; i++)
+    for(i = 0; i < FM_PCD_MAX_NUM_OF_CC_TREES; i++)
         ReleaseTree(p_FmPcdCc, (uint8_t)i);
 }
 
 t_Error  FmPcdCcBindTree(t_Handle h_FmPcd, t_Handle  h_FmPcdCcTree,  uint32_t  *p_Offset)
 {
-    t_FmPcd *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    t_FmPcd             *p_FmPcd = (t_FmPcd*)h_FmPcd;
     t_FmPcdCcTree       *p_FmPcdCcTree = (t_FmPcdCcTree *)h_FmPcdCcTree;
     t_Error             err = E_OK;
 
@@ -2299,7 +2311,8 @@ t_Error  FmPcdCcBindTree(t_Handle h_FmPcd, t_Handle  h_FmPcdCcTree,  uint32_t  *
     if(err)
         RETURN_ERROR(MINOR, err, NO_MSG);
 
-    *p_Offset = CAST_POINTER_TO_UINT32(XX_VirtToPhys(CAST_UINT32_TO_POINTER((uint32_t)p_FmPcdCcTree->p_CcBaseTree))) - ((t_FmPcd *)p_FmPcd)->p_FmPcdCc->physicalMuramBase;
+    *p_Offset = (uint32_t)(XX_VirtToPhys(CAST_UINT64_TO_POINTER(p_FmPcdCcTree->ccTreeBaseAddr)) -
+                           ((t_FmPcd *)p_FmPcd)->p_FmPcdCc->physicalMuramBase);
 
     return E_OK;
 }
@@ -2329,19 +2342,19 @@ t_Handle FM_PCD_CcBuildTree(t_Handle h_FmPcd, t_FmPcdCcTreeParams *p_PcdGroupsPa
     uint8_t                     lastOne = 0;
     t_CcNodeInfo                *p_CcNodeInfo;
     t_NextEngineParamsInfo      nextEngineParamsInfo;
-    uint16_t                    ccInfo[MAX_NUM_OF_PCD_CC_NODES];
+    uint16_t                    ccInfo[FM_PCD_MAX_NUM_OF_CC_NODES];
     t_FmPcdCcNode               *p_FmPcdCcNextNode;
     t_List                      *p_Pos;
     t_List                      ccNextDifferentNodesLst;
     uint32_t                    myInfo;
-    uint16_t                     ccArray[MAX_NUM_OF_PCD_CC_NODES];
+    uint16_t                    ccArray[FM_PCD_MAX_NUM_OF_CC_NODES];
 
     SANITY_CHECK_RETURN_VALUE(h_FmPcd,E_INVALID_HANDLE, NULL);
     SANITY_CHECK_RETURN_VALUE(p_PcdGroupsParam,E_INVALID_HANDLE, NULL);
     SANITY_CHECK_RETURN_VALUE(p_FmPcd->p_FmPcdCc,E_INVALID_STATE, NULL);
 
-    memset(ccInfo, 0, sizeof(uint8_t) * MAX_NUM_OF_PCD_CC_NODES);
-    memset(ccArray, 0, sizeof(uint16_t) * MAX_NUM_OF_PCD_CC_NODES);
+    memset(ccInfo, 0, sizeof(uint8_t) * FM_PCD_MAX_NUM_OF_CC_NODES);
+    memset(ccArray, 0, sizeof(uint16_t) * FM_PCD_MAX_NUM_OF_CC_NODES);
 
     memset(params, 0, 16 * sizeof(t_FmPcdCcNextEngineParams));
     p_FmPcdCc = p_FmPcd->p_FmPcdCc;
@@ -2441,20 +2454,21 @@ t_Handle FM_PCD_CcBuildTree(t_Handle h_FmPcd, t_FmPcdCcTreeParams *p_PcdGroupsPa
     }
 
     p_FmPcdCcTree->numOfGrps = p_PcdGroupsParam->numOfGrps;
-    p_FmPcdCcTree->p_CcBaseTree = FM_MURAM_AllocMem(p_FmPcdCc->h_FmMuram,
-                                         (uint32_t)( k * FM_PCD_CC_AD_ENTRY_SIZE),
-                                         FM_PCD_CC_AD_TABLE_ALIGN);
+    p_FmPcdCcTree->ccTreeBaseAddr =
+        CAST_POINTER_TO_UINT64(FM_MURAM_AllocMem(p_FmPcdCc->h_FmMuram,
+                                                 (uint32_t)( k * FM_PCD_CC_AD_ENTRY_SIZE),
+                                                 FM_PCD_CC_AD_TABLE_ALIGN));
 
-    if(!p_FmPcdCcTree->p_CcBaseTree)
+    if(!p_FmPcdCcTree->ccTreeBaseAddr)
     {
         ReleaseTree(p_FmPcdCc,treeId);
         ReleaseTreeHandler(p_FmPcdCcTree,p_FmPcdCc);
         REPORT_ERROR(MAJOR, E_NO_MEMORY, ("No memory"));
         return NULL;
     }
-    WRITE_BLOCK((uint8_t *)p_FmPcdCcTree->p_CcBaseTree, 0, (uint32_t)(k * FM_PCD_CC_AD_ENTRY_SIZE));
+    WRITE_BLOCK(CAST_UINT64_TO_POINTER_TYPE(uint8_t, p_FmPcdCcTree->ccTreeBaseAddr), 0, (uint32_t)(k * FM_PCD_CC_AD_ENTRY_SIZE));
 
-    p_CcTreeTmp  = p_FmPcdCcTree->p_CcBaseTree;
+    p_CcTreeTmp  = CAST_UINT64_TO_POINTER(p_FmPcdCcTree->ccTreeBaseAddr);
 
     j = 0;
     for(i = 0; i < numOfEntries; i++)
@@ -2540,8 +2554,8 @@ t_Handle FM_PCD_CcSetNode(t_Handle h_FmPcd, t_FmPcdCcNodeParams *p_CcNodeParam)
     uint16_t            nodeId;
     t_NextEngineParamsInfo nextEngineParamsInfo;
     uint16_t            profileInfo[FM_PCD_PLCR_NUM_ENTRIES];
-    uint16_t            ccInfo[MAX_NUM_OF_PCD_CC_NODES];
-    uint8_t             ccDifferentInfo[MAX_NUM_OF_PCD_CC_NODES];
+    uint16_t            ccInfo[FM_PCD_MAX_NUM_OF_CC_NODES];
+    uint8_t             ccDifferentInfo[FM_PCD_MAX_NUM_OF_CC_NODES];
     t_List              *p_Pos;
     t_CcNodeInfo        *p_CcNodeInfo;
     t_List              ccNextDifferentNodesLst;
@@ -2558,8 +2572,8 @@ t_Handle FM_PCD_CcSetNode(t_Handle h_FmPcd, t_FmPcdCcNodeParams *p_CcNodeParam)
     }
 
     memset(profileInfo, 0x00, FM_PCD_PLCR_NUM_ENTRIES*sizeof(uint16_t));
-    memset(ccInfo, 0x00, MAX_NUM_OF_PCD_CC_NODES*sizeof(uint16_t));
-    memset(ccDifferentInfo, 0x00, MAX_NUM_OF_PCD_CC_NODES*sizeof(uint8_t));
+    memset(ccInfo, 0x00, FM_PCD_MAX_NUM_OF_CC_NODES*sizeof(uint16_t));
+    memset(ccDifferentInfo, 0x00, FM_PCD_MAX_NUM_OF_CC_NODES*sizeof(uint8_t));
 
     p_FmPcdCc = p_FmPcd->p_FmPcdCc;
 
@@ -2620,10 +2634,9 @@ t_Handle FM_PCD_CcSetNode(t_Handle h_FmPcd, t_FmPcdCcNodeParams *p_CcNodeParam)
         p_FmPcdCcNode->glblMaskSize = (uint8_t)p_CcNodeParam->keysParams.keySize;
     }
     else
-     {   memset(p_FmPcdCcNode->p_GlblMask, 0xff, 4);
-         p_FmPcdCcNode->glblMaskSize = 4;
+     {   memset(p_FmPcdCcNode->p_GlblMask, 0xff, CC_GLBL_MASK_SIZE);
+         p_FmPcdCcNode->glblMaskSize = CC_GLBL_MASK_SIZE;
      }
-
     switch(p_CcNodeParam->extractCcParams.type)
     {
         case(e_FM_PCD_EXTRACT_BY_HDR):
@@ -2635,7 +2648,7 @@ t_Handle FM_PCD_CcSetNode(t_Handle h_FmPcd, t_FmPcdCcNodeParams *p_CcNodeParam)
                     GetSizeHeaderField(p_CcNodeParam->extractCcParams.extractParams.extractByHdr.hdr, p_CcNodeParam->extractCcParams.extractParams.extractByHdr.extractByHdrType.fullField, &p_FmPcdCcNode->sizeOfExtraction);
                     fullField = TRUE;
                     break;
-                    case(e_FM_PCD_EXTRACT_FROM_HDR):
+                case(e_FM_PCD_EXTRACT_FROM_HDR):
                         p_FmPcdCcNode->sizeOfExtraction = p_CcNodeParam->extractCcParams.extractParams.extractByHdr.extractByHdrType.fromHdr.size;
                         p_FmPcdCcNode->offset =  p_CcNodeParam->extractCcParams.extractParams.extractByHdr.extractByHdrType.fromHdr.offset;
                         p_FmPcdCcNode->parseCode = GetPrParseCode(p_CcNodeParam->extractCcParams.extractParams.extractByHdr.hdr, p_CcNodeParam->extractCcParams.extractParams.extractByHdr.hdrIndex,
@@ -2660,7 +2673,28 @@ t_Handle FM_PCD_CcSetNode(t_Handle h_FmPcd, t_FmPcdCcNodeParams *p_CcNodeParam)
             p_FmPcdCcNode->sizeOfExtraction = p_CcNodeParam->extractCcParams.extractParams.extractNonHdr.size;
             p_FmPcdCcNode->offset =  p_CcNodeParam->extractCcParams.extractParams.extractNonHdr.offset;
             p_FmPcdCcNode->parseCode = GetGenParseCode(p_CcNodeParam->extractCcParams.extractParams.extractNonHdr.src, p_FmPcdCcNode->offset, glblMask, &p_FmPcdCcNode->prsArrayOffset);
-            break;
+            if(p_FmPcdCcNode->parseCode == CC_PC_GENERIC_IC_GMASK)
+            {
+                p_FmPcdCcNode->offset +=  p_FmPcdCcNode->prsArrayOffset;
+                p_FmPcdCcNode->prsArrayOffset = 0;
+            }
+            if(p_FmPcdCcNode->parseCode == CC_PC_GENERIC_IC_HASH_INDEXED)
+            {
+                 ReleaseNode(p_FmPcdCc,nodeId);
+                 REPORT_ERROR(MAJOR, E_INVALID_SELECTION, ("Not implemented yet"));
+                 return NULL;
+                if(!glblMask)
+               {
+                   REPORT_ERROR(MAJOR, E_INVALID_SELECTION, ("in the type e_FM_PCD_EXTRACT_FROM_IC_HASH_INDEXED_MATCH glblMask has to be defined"));
+                   return NULL;
+               }
+                if(p_FmPcdCcNode->sizeOfExtraction != 2)
+                {
+                    REPORT_ERROR(MAJOR, E_INVALID_SELECTION, ("in the type e_FM_PCD_EXTRACT_FROM_IC_HASH_INDEXED_MATCH sizeOfExtraction has to be 2 bytes"));
+                    return NULL;
+                }
+              }
+                break;
 
        default:
             ReleaseNode(p_FmPcdCc,nodeId);
@@ -2685,7 +2719,7 @@ t_Handle FM_PCD_CcSetNode(t_Handle h_FmPcd, t_FmPcdCcNodeParams *p_CcNodeParam)
         return NULL;
     }
 
-    if((p_FmPcdCcNode->sizeOfExtraction > MAX_SIZE_OF_KEY) || !p_FmPcdCcNode->sizeOfExtraction)
+    if((p_FmPcdCcNode->sizeOfExtraction > FM_PCD_MAX_SIZE_OF_KEY) || !p_FmPcdCcNode->sizeOfExtraction)
     {
         ReleaseNode(p_FmPcdCc,nodeId);
         ReleaseNodeHandler(p_FmPcdCcNode,p_FmPcdCc);
@@ -2708,21 +2742,23 @@ t_Handle FM_PCD_CcSetNode(t_Handle h_FmPcd, t_FmPcdCcNodeParams *p_CcNodeParam)
         p_KeyParams = &p_CcNodeParam->keysParams.keyParams[tmp];
         if((p_FmPcdCcNode->parseCode != CC_PC_FF_IPV4TTL) && (p_FmPcdCcNode->parseCode != CC_PC_FF_IPV6HOP_LIMIT))
         {
-            if(!p_KeyParams->p_Key)
-            {
-                ReleaseNode(p_FmPcdCc,nodeId);
-                ReleaseNodeHandler(p_FmPcdCcNode,p_FmPcdCc);
-                REPORT_ERROR(MAJOR, E_NO_MEMORY, ("p_Key is not initialized"));
-                return NULL;
-            }
 
-            if(p_KeyParams->p_Mask && glblMask)
-            {
-                ReleaseNode(p_FmPcdCc,nodeId);
-                ReleaseNodeHandler(p_FmPcdCcNode,p_FmPcdCc);
-                REPORT_ERROR(MAJOR, E_NO_MEMORY, ("Can not be used globalMask and localMask"));
-                return NULL;
-            }
+                if(!p_KeyParams->p_Key)
+                {
+                    ReleaseNode(p_FmPcdCc,nodeId);
+                    ReleaseNodeHandler(p_FmPcdCcNode,p_FmPcdCc);
+                    REPORT_ERROR(MAJOR, E_NO_MEMORY, ("p_Key is not initialized"));
+                    return NULL;
+                }
+
+                if(p_KeyParams->p_Mask && glblMask)
+                {
+                    ReleaseNode(p_FmPcdCc,nodeId);
+                    ReleaseNodeHandler(p_FmPcdCcNode,p_FmPcdCc);
+                    REPORT_ERROR(MAJOR, E_NO_MEMORY, ("Can not be used globalMask and localMask"));
+                    return NULL;
+                }
+
         }
         err = ValidateNextEngineParams(h_FmPcd, &p_KeyParams->ccNextEngineParams, &nextEngineParamsInfo);
         if(err)
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_kg.c b/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_kg.c
index ea7adc1..48769bd 100644
--- a/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_kg.c
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_kg.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -103,7 +103,6 @@ static e_FmPcdKgExtractDfltSelect GetGenericSwDefault(t_FmPcdKgExtractDflt swDef
             for(i=0 ; i<numOfSwDefaults ; i++)
                 if(swDefaults[i].type == e_FM_PCD_KG_GENERIC_FROM_DATA)
                     return swDefaults[i].dfltSelect;
-            ASSERT_COND(FALSE);
         default:
             return e_FM_PCD_KG_DFLT_ILLEGAL;
     }
@@ -698,7 +697,7 @@ t_Handle FmPcdKgBuildClsPlanGrp(t_Handle h_FmPcd, t_FmPcdKgClsPlanGrpParams *p_G
     struct {
         protocolOpt_t   opt;
         uint32_t        vector;
-    }                               tmpOptStruct[MAX_NUM_OF_OPTIONS];
+    }                               tmpOptStruct[FM_PCD_MAX_NUM_OF_OPTIONS];
 
     SANITY_CHECK_RETURN_VALUE(p_FmPcd, E_INVALID_HANDLE, NULL);
     SANITY_CHECK_RETURN_VALUE(p_FmPcd->p_FmPcdKg, E_INVALID_HANDLE, NULL);
@@ -767,9 +766,9 @@ t_Handle FmPcdKgBuildClsPlanGrp(t_Handle h_FmPcd, t_FmPcdKgClsPlanGrpParams *p_G
     }
 
     /* allocate 2^numOfOptions entries */
-    if(numOfOptions > MAX_NUM_OF_OPTIONS)
+    if(numOfOptions > FM_PCD_MAX_NUM_OF_OPTIONS)
     {
-        REPORT_ERROR(MINOR, E_INVALID_VALUE, ("Too many options - no more than %d components allowed.", MAX_NUM_OF_OPTIONS));
+        REPORT_ERROR(MINOR, E_INVALID_VALUE, ("Too many options - no more than %d components allowed.", FM_PCD_MAX_NUM_OF_OPTIONS));
         RELEASE_LOCK(p_FmPcd->p_FmPcdKg->clsPlanGrps[grpId].lock);
         return NULL;
     }
@@ -837,7 +836,10 @@ void FmPcdKgDestroyClsPlanGrp(t_Handle h_FmPcd, uint8_t grpId)
 
     /* check that no port is bound to this port */
     if(p_FmPcd->p_FmPcdKg->clsPlanGrps[grpId].owners)
+    {
        REPORT_ERROR(MINOR, E_INVALID_STATE, ("Trying to delete a clsPlan grp that has ports bound to"));
+       return;
+    }
 
     FmPcdDecNetEnvOwners(p_FmPcd, p_FmPcd->p_FmPcdKg->clsPlanGrps[grpId].netEnvId);
 
@@ -856,7 +858,6 @@ t_Error FmPcdKgBuildBindPortToSchemes(t_Handle h_FmPcd , t_FmPcdKgInterModuleBin
     uint8_t                 i, relativeSchemeId;
     uint32_t                tmp, walking1Mask;
     uint16_t                pcdPortId;
-    uint8_t                 portsTable[] = PCD_PORTS_TABLE;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdKg, E_INVALID_HANDLE);
@@ -880,7 +881,7 @@ t_Error FmPcdKgBuildBindPortToSchemes(t_Handle h_FmPcd , t_FmPcdKgInterModuleBin
                 RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Port may not be bound to requested scheme - differ in netEnvId"));
 
             /* if next engine is private port policer profile, we need to check that it is valid */
-            GET_FM_PCD_PORTID_FROM_GLOBAL_PORTID(pcdPortId, portsTable, p_BindPort->hardwarePortId)
+            SET_FM_PCD_PORTID_FROM_GLOBAL_PORTID(pcdPortId, p_BindPort->hardwarePortId);
             if(p_Scheme->nextRelativePlcrProfile)
             {
                 for(j = 0;j<p_Scheme->numOfProfiles;j++)
@@ -1038,9 +1039,16 @@ t_Error  FmPcdKgAllocClsPlanEntries(t_Handle h_FmPcd, uint16_t numOfClsPlanEntri
     TRY_LOCK_RET_ERR(p_FmPcd->lock);
 
     if(!numOfClsPlanEntries)
+    {
+        RELEASE_LOCK(p_FmPcd->lock);
         return E_OK;
+    }
+
     if ((numOfClsPlanEntries % CLS_PLAN_NUM_PER_GRP) || (!POWER_OF_2(numOfClsPlanEntries)))
+    {
+        RELEASE_LOCK(p_FmPcd->lock);
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("numOfClsPlanEntries must be a power of 2 and divisible by 8"));
+    }
 
     numOfBlocks =  (uint8_t)(numOfClsPlanEntries/CLS_PLAN_NUM_PER_GRP);
 
@@ -1116,6 +1124,15 @@ t_Error KgEnable(t_FmPcd *p_FmPcd)
     return E_OK;
 }
 
+t_Error KgDisable(t_FmPcd *p_FmPcd)
+{
+    t_FmPcdKgRegs               *p_Regs = p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs;
+
+    WRITE_UINT32(p_Regs->kggcr,GET_UINT32(p_Regs->kggcr) & ~FM_PCD_KG_KGGCR_EN);
+
+    return E_OK;
+}
+
 static t_Error WriteKgarWait(t_FmPcd *p_FmPcd, uint32_t kgar)
 {
     WRITE_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgar, kgar);
@@ -1131,7 +1148,7 @@ void KgSetClsPlan(t_Handle h_FmPcd, t_FmPcdKgInterModuleClsPlanSet *p_Set)
     t_FmPcd                 *p_FmPcd = (t_FmPcd*)h_FmPcd;
     t_FmPcdKgClsPlanRegs    *p_FmPcdKgPortRegs;
     uint32_t                tmpKgarReg=0;
-    uint8_t                 i, j;
+    uint16_t                i, j;
 
     SANITY_CHECK_RETURN(p_FmPcd, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN(p_FmPcd->p_FmPcdKg, E_INVALID_HANDLE);
@@ -1171,7 +1188,7 @@ static void PcdKgErrorException(t_Handle h_FmPcd)
     WRITE_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgseer, schemeIndexes);
 
     if(event & FM_PCD_KG_DOUBLE_ECC)
-        p_FmPcd->f_FmPcdException(p_FmPcd->h_App,e_FM_PCD_KG_ERR_EXCEPTION_DOUBLE_ECC);
+        p_FmPcd->f_Exception(p_FmPcd->h_App,e_FM_PCD_KG_EXCEPTION_DOUBLE_ECC);
     if(event & FM_PCD_KG_KEYSIZE_OVERFLOW)
     {
         if(schemeIndexes)
@@ -1179,13 +1196,13 @@ static void PcdKgErrorException(t_Handle h_FmPcd)
             while(schemeIndexes)
             {
                 if(schemeIndexes & 0x1)
-                    p_FmPcd->f_FmPcdIndexedException(p_FmPcd->h_App,e_FM_PCD_KG_ERR_EXCEPTION_KEYSIZE_OVERFLOW, (uint16_t)(31 - index));
+                    p_FmPcd->f_FmPcdIndexedException(p_FmPcd->h_App,e_FM_PCD_KG_EXCEPTION_KEYSIZE_OVERFLOW, (uint16_t)(31 - index));
                 schemeIndexes >>= 1;
                 index+=1;
             }
         }
         else /* this should happen only when interrupt is forced. */
-            p_FmPcd->f_FmPcdException(p_FmPcd->h_App,e_FM_PCD_KG_ERR_EXCEPTION_KEYSIZE_OVERFLOW);
+            p_FmPcd->f_Exception(p_FmPcd->h_App,e_FM_PCD_KG_EXCEPTION_KEYSIZE_OVERFLOW);
     }
 }
 
@@ -1399,7 +1416,6 @@ t_Error KgInit(t_FmPcd *p_FmPcd)
     int                         i;
     t_FmPcdKgPortConfigRegs     *p_FmPcdKgPortRegs;
     uint8_t                     hardwarePortId;
-    uint8_t                     portsTable[] = PCD_PORTS_TABLE;
     uint32_t                    tmpReg;
 #else
     t_FmPcdIpcKgAllocParams     kgAlloc;
@@ -1413,8 +1429,7 @@ t_Error KgInit(t_FmPcd *p_FmPcd)
     tmpReg = 0;
     if(p_FmPcd->exceptions & FM_PCD_EX_KG_DOUBLE_ECC)
     {
-        if(!FmRamsEccIsExternalCtl(p_FmPcd->h_Fm))
-            FM_EnableRamsEcc(p_FmPcd->h_Fm);
+        FmEnableRamsEcc(p_FmPcd->h_Fm);
         tmpReg |= FM_PCD_KG_DOUBLE_ECC;
     }
     if(p_FmPcd->exceptions & FM_PCD_EX_KG_KEYSIZE_OVERFLOW)
@@ -1449,7 +1464,7 @@ t_Error KgInit(t_FmPcd *p_FmPcd)
     for (i=0;i<PCD_MAX_NUM_OF_PORTS;i++)
     {
 
-        GET_GLOBAL_PORTID_FROM_PCD_PORTS_TABLE(hardwarePortId, portsTable,i);
+        GET_GLOBAL_PORTID_FROM_PCD_PORTS_TABLE(hardwarePortId, i);
 
         err = KgWriteSp(p_FmPcd, hardwarePortId, 0xffffffff, FALSE);
         if(err)
@@ -1545,6 +1560,48 @@ t_Error KgInit(t_FmPcd *p_FmPcd)
 #endif  /* CONFIG_MULTI_PARTITION_SUPPORT */
 #endif /* 0 */
 
+t_Error KgFree(t_FmPcd *p_FmPcd)
+{
+#ifdef CONFIG_GUEST_PARTITION
+    t_FmPcdIpcKgAllocParams             kgAlloc;
+#endif /* CONFIG_GUEST_PARTITION */
+#ifdef CONFIG_MULTI_PARTITION_SUPPORT
+    t_Error                             err = E_OK;
+#endif /* CONFIG_MULTI_PARTITION_SUPPORT */
+
+    FmUnregisterIntr(p_FmPcd->h_Fm, e_FM_MOD_KG, 0, e_FM_INTR_TYPE_ERR);
+
+#ifndef CONFIG_GUEST_PARTITION
+        if(p_FmPcd->p_FmPcdKg->isDriverEmptyClsPlanGrp)
+            FmPcdKgDestroyClsPlanGrp(p_FmPcd, p_FmPcd->p_FmPcdKg->emptyClsPlanGrpId);
+#endif
+#ifdef CONFIG_MULTI_PARTITION_SUPPORT
+#ifdef CONFIG_GUEST_PARTITION
+    kgAlloc.numOfSchemes = p_FmPcd->p_FmPcdKg->numOfSchemes;
+    kgAlloc.partitionId = p_FmPcd->partitionId;
+    kgAlloc.numOfClsPlanEntries = p_FmPcd->p_FmPcdKg->numOfClsPlanEntries;
+    kgAlloc.isDriverClsPlanGrp = p_FmPcd->p_FmPcdKg->isDriverEmptyClsPlanGrp;
+    kgAlloc.clsPlanBase = p_FmPcd->p_FmPcdKg->clsPlanBase;
+    memcpy(kgAlloc.schemesIds, p_FmPcd->p_FmPcdKg->schemesIds , kgAlloc.numOfSchemes);
+    err = XX_SendMessage(p_FmPcd->fmPcdModuleName, FM_PCD_FREE_KG_RSRC, (uint8_t*)&kgAlloc, NULL, NULL);
+    if(err)
+        RETURN_ERROR(MINOR, err, NO_MSG);
+#else /* master */
+    err = FmPcdKgFreeSchemes(p_FmPcd,
+                                p_FmPcd->p_FmPcdKg->numOfSchemes,
+                                p_FmPcd->partitionId,
+                                p_FmPcd->p_FmPcdKg->schemesIds);
+    if(err)
+        RETURN_ERROR(MINOR, err, NO_MSG);
+    err = FmPcdKgFreeClsPlanEntries(p_FmPcd,
+                                p_FmPcd->p_FmPcdKg->numOfClsPlanEntries,
+                                p_FmPcd->partitionId,
+                                p_FmPcd->p_FmPcdKg->clsPlanBase);
+#endif /* CONFIG_GUEST_PARTITION */
+#endif /* CONFIG_MULTI_PARTITION_SUPPORT */
+    return E_OK;
+}
+
 t_Error FmPcdKgSwBindPortToClsPlanGrp(t_Handle h_FmPcd, uint8_t netEnvId, uint8_t clsPlanGrpId, protocolOpt_t *p_OptArray)
 {
     t_FmPcd                 *p_FmPcd = (t_FmPcd *)h_FmPcd;
@@ -1565,7 +1622,7 @@ t_Error FmPcdKgSwBindPortToClsPlanGrp(t_Handle h_FmPcd, uint8_t netEnvId, uint8_
     p_ClsPlanGrp->owners++;
 
     /* copy options array for port */
-    memcpy(p_OptArray, &p_FmPcd->p_FmPcdKg->clsPlanGrps[clsPlanGrpId].optArray, MAX_NUM_OF_OPTIONS*sizeof(protocolOpt_t));
+    memcpy(p_OptArray, &p_FmPcd->p_FmPcdKg->clsPlanGrps[clsPlanGrpId].optArray, FM_PCD_MAX_NUM_OF_OPTIONS*sizeof(protocolOpt_t));
 
     return E_OK;
 }
@@ -1581,7 +1638,7 @@ void FmPcdKgSwUnbindPortToClsPlanGrp(t_Handle h_FmPcd, uint8_t clsPlanGrpId)
     p_ClsPlanGrp->owners--;
 }
 
-t_Error FmPcdKgBuildScheme(t_Handle h_FmPcd,  t_FmPcdKgSchemeParams *p_Scheme, t_FmPcdKgInterModuleSchemeRegs *p_SchemeRegs, t_FmPcdKgKeyOrder *p_OrderedArray)
+t_Error FmPcdKgBuildScheme(t_Handle h_FmPcd,  t_FmPcdKgSchemeParams *p_Scheme, t_FmPcdKgInterModuleSchemeRegs *p_SchemeRegs)
 {
     t_FmPcd                             *p_FmPcd = (t_FmPcd *)h_FmPcd;
     uint32_t                            grpBits;
@@ -1599,22 +1656,21 @@ t_Error FmPcdKgBuildScheme(t_Handle h_FmPcd,  t_FmPcdKgSchemeParams *p_Scheme, t
     t_FmPcdKgExtractedOrForFqid         *p_ExtractOr;
     bool                                generic = FALSE;
     t_KnownFieldsMasks                  bitMask;
-    e_FmPcdKgExtractDfltSelect          swDefault;
-    t_FmPcdKgKeyOrder                   orderedArray;
+    e_FmPcdKgExtractDfltSelect          swDefault = (e_FmPcdKgExtractDfltSelect)0;
     t_FmPcdKgSchemesExtracts            *p_LocalExtractsArray;
     uint8_t                             numOfSwDefaults = 0;
     t_FmPcdKgExtractDflt                swDefaults[NUM_OF_SW_DEFAULTS];
     uint8_t                             currGenId = 0, relativeSchemeId;
 
-    memset(p_OrderedArray, 0, sizeof(t_FmPcdKgKeyOrder));
-    memset(orderedArray, 0, sizeof(t_FmPcdKgKeyOrder));
-    memset(swDefaults, 0, NUM_OF_SW_DEFAULTS*sizeof(t_FmPcdKgExtractDflt));
-
     if(!p_Scheme->modify)
         relativeSchemeId = p_Scheme->id.relativeSchemeId;
     else
         relativeSchemeId = FmPcdKgGetRelativeSchemeId(p_FmPcd, (uint8_t)(CAST_POINTER_TO_UINT32(p_Scheme->id.h_Scheme)-1));
 
+    memset(&p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].orderedArray, 0, sizeof(t_FmPcdKgKeyOrder));
+    memset(swDefaults, 0, NUM_OF_SW_DEFAULTS*sizeof(t_FmPcdKgExtractDflt));
+    memset(p_SchemeRegs, 0, sizeof(t_FmPcdKgInterModuleSchemeRegs));
+
     /* by netEnv parameters, get match vector */
     if(!p_Scheme->alwaysDirect)
     {
@@ -1637,7 +1693,7 @@ t_Error FmPcdKgBuildScheme(t_Handle h_FmPcd,  t_FmPcdKgSchemeParams *p_Scheme, t
     if(p_Scheme->nextEngine == e_FM_PCD_PLCR)
     {
         direct = p_Scheme->kgNextEngineParams.plcrProfile.direct;
-        absolute = p_Scheme->kgNextEngineParams.plcrProfile.sharedProfile ? TRUE: FALSE;
+        absolute = (bool)(p_Scheme->kgNextEngineParams.plcrProfile.sharedProfile ? TRUE : FALSE);
         if(!direct && absolute)
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Indirect policing is not available when profile is shared."));
 
@@ -1956,7 +2012,7 @@ t_Error FmPcdKgBuildScheme(t_Handle h_FmPcd,  t_FmPcdKgSchemeParams *p_Scheme, t
                 genTmp |= (uint32_t)((size - 1) << KG_SCH_GEN_SIZE_SHIFT);
                 swDefault = GetGenericSwDefault(swDefaults, numOfSwDefaults, code);
                 if(swDefault == e_FM_PCD_KG_DFLT_ILLEGAL)
-                    RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal code for sw default"));
+                    DBG(WARNING, ("No sw default configured"));
 
                 genTmp |= swDefault << KG_SCH_GEN_DEF_SHIFT;
                 genTmp |= KG_SCH_GEN_MASK;
@@ -1969,7 +2025,6 @@ t_Error FmPcdKgBuildScheme(t_Handle h_FmPcd,  t_FmPcdKgSchemeParams *p_Scheme, t
         }
         p_SchemeRegs->kgse_ekfc = knownTmp;
 
-
         selectTmp = 0;
         maskTmp = 0xFFFFFFFF;
         /*  configure kgse_bmch, kgse_bmcl and kgse_fqb */
@@ -2018,7 +2073,6 @@ t_Error FmPcdKgBuildScheme(t_Handle h_FmPcd,  t_FmPcdKgSchemeParams *p_Scheme, t
         tmpReg |= p_KeyAndHash->hashShift << KG_SCH_HASH_CONFIG_SHIFT_SHIFT;
         p_SchemeRegs->kgse_hc = tmpReg;
 
-
         /* build the return array describing the order of the extractions */
 
         /* the last currGenId places of the array
@@ -2041,22 +2095,23 @@ t_Error FmPcdKgBuildScheme(t_Handle h_FmPcd,  t_FmPcdKgSchemeParams *p_Scheme, t
                 index in the user's extractions array */
                 /* we compare the id of the current extract with the id of the extract in the orderedArray[j-1]
                 location */
-                while(p_LocalExtractsArray->extractsArray[i].id < p_LocalExtractsArray->extractsArray[orderedArray[j-1]].id && j>0)
+                while(p_LocalExtractsArray->extractsArray[i].id <
+                      p_LocalExtractsArray->extractsArray[p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].orderedArray[j-1]].id && j>0)
                 {
-                    orderedArray[j] = orderedArray[j-1];
+                    p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].orderedArray[j] =
+                        p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].orderedArray[j-1];
                     j--;
                 }
-                orderedArray[j] = (uint8_t)i;
+                p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].orderedArray[j] = (uint8_t)i;
                 curr++;
             }
             else
                 /* index is first_generic_index + generic index (id) */
-                orderedArray[p_KeyAndHash->numOfUsedExtracts - currGenId + p_LocalExtractsArray->extractsArray[i].id]= (uint8_t)i;
+                p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].orderedArray[p_KeyAndHash->numOfUsedExtracts - currGenId + p_LocalExtractsArray->extractsArray[i].id]= (uint8_t)i;
 
         }
         XX_Free(p_LocalExtractsArray);
         p_LocalExtractsArray = NULL;
-        memcpy(p_OrderedArray, &orderedArray, sizeof(orderedArray));
 
     }
     else
@@ -2433,7 +2488,6 @@ t_Error FM_PCD_KgDumpRegs(t_Handle h_FmPcd)
     int                 i = 0, j = 0;
     uint8_t             hardwarePortId;
     uint32_t            tmpKgarReg;
-    uint8_t             portsTable[] = PCD_PORTS_TABLE;
     t_Error             err = E_OK;
 
     DECLARE_DUMP;
@@ -2494,7 +2548,7 @@ t_Error FM_PCD_KgDumpRegs(t_Handle h_FmPcd)
     for (i=0;i<PCD_MAX_NUM_OF_PORTS;i++)
     {
 
-        GET_GLOBAL_PORTID_FROM_PCD_PORTS_TABLE(hardwarePortId, portsTable,i);
+        GET_GLOBAL_PORTID_FROM_PCD_PORTS_TABLE(hardwarePortId, i);
 
         tmpKgarReg = FmPcdKgBuildReadPortSchemeBindActionReg(hardwarePortId);
 
@@ -2553,8 +2607,7 @@ t_Handle FM_PCD_KgSetScheme(t_Handle h_FmPcd,  t_FmPcdKgSchemeParams *p_Scheme)
         REPORT_ERROR(MAJOR, E_INVALID_HANDLE, ("No HC obj. must have HC in guest partition!"));
         return NULL;
     }
-
-#else
+#else /* CONFIG_MULTI_PARTITION_SUPPORT */
 
     TRY_LOCK_RET_NULL(p_FmPcd->lock);
 
@@ -2603,7 +2656,7 @@ t_Handle FM_PCD_KgSetScheme(t_Handle h_FmPcd,  t_FmPcdKgSchemeParams *p_Scheme)
         }
     }
 
-    err = FmPcdKgBuildScheme(h_FmPcd, p_Scheme, &schemeRegs, &p_Scheme->orderedArray);
+    err = FmPcdKgBuildScheme(h_FmPcd, p_Scheme, &schemeRegs);
     if(err)
     {
         REPORT_ERROR(MAJOR, err, NO_MSG);
@@ -2668,11 +2721,11 @@ t_Error  FM_PCD_KgDeleteScheme(t_Handle h_FmPcd, t_Handle h_Scheme)
     physicalSchemeId = (uint8_t)(CAST_POINTER_TO_UINT32(h_Scheme)-1);
     relativeSchemeId = FmPcdKgGetRelativeSchemeId(p_FmPcd, physicalSchemeId);
 
-    TRY_LOCK_RET_ERR(p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].lock);
-
     if(relativeSchemeId == FM_PCD_KG_NUM_OF_SCHEMES)
         REPORT_ERROR(MAJOR, E_NOT_IN_RANGE, NO_MSG);
 
+    TRY_LOCK_RET_ERR(p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].lock);
+
     /* check that no port is bound to this scheme */
     err = FmPcdKgCheckInvalidateSchemeSw(h_FmPcd, relativeSchemeId);
     if(err)
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.c b/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.c
index bc25565..4e8bd0a 100644
--- a/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.c
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -64,7 +64,7 @@ static t_Error CheckFmPcdParameters(t_FmPcd *p_FmPcd)
     if(!p_FmPcd->h_Fm)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("h_Fm has to be initialized"));
 
-    if(!p_FmPcd->f_FmPcdException)
+    if(!p_FmPcd->f_Exception)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("f_FmPcdExceptions has to be initialized"));
 
     if((!p_FmPcd->f_FmPcdIndexedException) && (p_FmPcd->p_FmPcdPlcr || p_FmPcd->p_FmPcdKg))
@@ -90,12 +90,23 @@ t_Error  FmPcdHandleIpcMsg(t_Handle h_FmPcd, uint32_t msgId, uint8_t msgBody[MSG
 
     switch(msgId)
     {
-    case (FM_PCD_MASTER_IS_ALIVE):
-        return E_OK;
-    case (FM_PCD_MASTER_IS_ENABLED):
-        return p_FmPcd->enabled;
-        //case (FM_PCD_CLEAR_PORT_PARAMS):
-            //return FmPcdDeletePortParams(h_FmPcd, (t_FmPcdInterModulePortDeleteParams*)msgBody);
+        case (FM_PCD_MASTER_IS_ALIVE):
+            return E_OK;
+        case (FM_PCD_MASTER_IS_ENABLED):
+            /* count partitions registrations */
+            if(p_FmPcd->enabled)
+                p_FmPcd->numOfEnabledGuestPartitionsPcds++;
+            return p_FmPcd->enabled;
+            //case (FM_PCD_CLEAR_PORT_PARAMS):
+                //return FmPcdDeletePortParams(h_FmPcd, (t_FmPcdInterModulePortDeleteParams*)msgBody);
+        case (FM_PCD_GUEST_DISABLE):
+            if(p_FmPcd->numOfEnabledGuestPartitionsPcds)
+            {
+                p_FmPcd->numOfEnabledGuestPartitionsPcds--;
+                break;
+            }
+            else
+                RETURN_ERROR(MINOR, E_INVALID_STATE,("Trying to disable an unregistered partition"));
         case (FM_PCD_ALLOC_KG_RSRC):
             {
                 err = FmPcdKgAllocSchemes(h_FmPcd,
@@ -259,9 +270,8 @@ void   FmPcdPortRegister(t_Handle h_FmPcd, t_Handle h_FmPort, uint8_t hardwarePo
 {
     t_FmPcd         *p_FmPcd = (t_FmPcd*)h_FmPcd;
     uint16_t        pcdPortId;
-    uint8_t         portsTable[] = PCD_PORTS_TABLE;
 
-    GET_FM_PCD_PORTID_FROM_GLOBAL_PORTID(pcdPortId, portsTable, hardwarePortId)
+    SET_FM_PCD_PORTID_FROM_GLOBAL_PORTID(pcdPortId, hardwarePortId);
 
     p_FmPcd->p_FmPcdPlcr->portsMapping[pcdPortId].h_FmPort = h_FmPort;
 }
@@ -302,28 +312,28 @@ void FmPcdReleaseLock(t_Handle h_FmPcd)
 
 t_Handle FM_PCD_Config(t_FmPcdParams *p_FmPcdParams)
 {
-    t_FmPcd *p_Pcd = NULL;
+    t_FmPcd *p_FmPcd = NULL;
 
     SANITY_CHECK_RETURN_VALUE(p_FmPcdParams, E_INVALID_HANDLE,NULL);
 
-    p_Pcd = (t_FmPcd *) XX_Malloc(sizeof(t_FmPcd));
-    if (!p_Pcd)
+    p_FmPcd = (t_FmPcd *) XX_Malloc(sizeof(t_FmPcd));
+    if (!p_FmPcd)
     {
         REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM Pcd"));
         return NULL;
     }
-    memset(p_Pcd, 0, sizeof(t_FmPcd));
+    memset(p_FmPcd, 0, sizeof(t_FmPcd));
 
-    p_Pcd->p_FmPcdDriverParam = (t_FmPcdDriverParam *) XX_Malloc(sizeof(t_FmPcdDriverParam));
-    if (!p_Pcd)
+    p_FmPcd->p_FmPcdDriverParam = (t_FmPcdDriverParam *) XX_Malloc(sizeof(t_FmPcdDriverParam));
+    if (!p_FmPcd)
     {
-        XX_Free(p_Pcd);
+        XX_Free(p_FmPcd);
         REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM Pcd Driver Param"));
         return NULL;
     }
-    memset(p_Pcd->p_FmPcdDriverParam, 0, sizeof(t_FmPcdDriverParam));
+    memset(p_FmPcd->p_FmPcdDriverParam, 0, sizeof(t_FmPcdDriverParam));
 
-    p_Pcd->h_Fm = p_FmPcdParams->h_Fm;
+    p_FmPcd->h_Fm = p_FmPcdParams->h_Fm;
 
 #ifndef CONFIG_MULTI_PARTITION_SUPPORT
     if (p_FmPcdParams->useHostCommand)
@@ -332,47 +342,47 @@ t_Handle FM_PCD_Config(t_FmPcdParams *p_FmPcdParams)
         t_FmHcParams    hcParams;
 
         memset(&hcParams, 0, sizeof(hcParams));
-        hcParams.h_Fm = p_Pcd->h_Fm;
-        hcParams.h_FmPcd = (t_Handle)p_Pcd;
+        hcParams.h_Fm = p_FmPcd->h_Fm;
+        hcParams.h_FmPcd = (t_Handle)p_FmPcd;
         memcpy((uint8_t*)&hcParams.params, (uint8_t*)&p_FmPcdParams->hc, sizeof(t_FmPcdHcParams));
-        p_Pcd->h_Hc = FmHcConfigAndInit(&hcParams);
-        if (!p_Pcd->h_Hc)
+        p_FmPcd->h_Hc = FmHcConfigAndInit(&hcParams);
+        if (!p_FmPcd->h_Hc)
         {
             REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM Pcd HC"));
-            FM_PCD_Free(p_Pcd);
+            FM_PCD_Free(p_FmPcd);
             return NULL;
         }
     }
 
     if(p_FmPcdParams->kgSupport)
     {
-        p_Pcd->p_FmPcdKg = (t_FmPcdKg *)KgConfig(p_Pcd, p_FmPcdParams);
-        if(!p_Pcd->p_FmPcdKg)
+        p_FmPcd->p_FmPcdKg = (t_FmPcdKg *)KgConfig(p_FmPcd, p_FmPcdParams);
+        if(!p_FmPcd->p_FmPcdKg)
         {
             REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM Pcd Keygen"));
-            FM_PCD_Free(p_Pcd);
+            FM_PCD_Free(p_FmPcd);
             return NULL;
         }
     }
 
     if(p_FmPcdParams->ccSupport)
     {
-        p_Pcd->p_FmPcdCc = (t_FmPcdCc *)CcConfig(p_Pcd, p_FmPcdParams);
-        if(!p_Pcd->p_FmPcdCc)
+        p_FmPcd->p_FmPcdCc = (t_FmPcdCc *)CcConfig(p_FmPcd, p_FmPcdParams);
+        if(!p_FmPcd->p_FmPcdCc)
         {
             REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM Pcd Cc"));
-            FM_PCD_Free(p_Pcd);
+            FM_PCD_Free(p_FmPcd);
             return NULL;
         }
     }
 
     if(p_FmPcdParams->plcrSupport)
     {
-        p_Pcd->p_FmPcdPlcr = (t_FmPcdPlcr *)PlcrConfig(p_Pcd, p_FmPcdParams);
-        if(!p_Pcd->p_FmPcdPlcr)
+        p_FmPcd->p_FmPcdPlcr = (t_FmPcdPlcr *)PlcrConfig(p_FmPcd, p_FmPcdParams);
+        if(!p_FmPcd->p_FmPcdPlcr)
         {
             REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM Pcd Policer"));
-            FM_PCD_Free(p_Pcd);
+            FM_PCD_Free(p_FmPcd);
             return NULL;
         }
 
@@ -380,26 +390,29 @@ t_Handle FM_PCD_Config(t_FmPcdParams *p_FmPcdParams)
 
     if(p_FmPcdParams->prsSupport)
     {
-        p_Pcd->p_FmPcdPrs = (t_FmPcdPrs *)PrsConfig(p_Pcd, p_FmPcdParams);
-        if(!p_Pcd->p_FmPcdPrs)
+        p_FmPcd->p_FmPcdPrs = (t_FmPcdPrs *)PrsConfig(p_FmPcd, p_FmPcdParams);
+        if(!p_FmPcd->p_FmPcdPrs)
         {
             REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM Pcd Parser"));
-            FM_PCD_Free(p_Pcd);
+            FM_PCD_Free(p_FmPcd);
             return NULL;
         }
     }
 
 #ifdef CONFIG_MULTI_PARTITION_SUPPORT
-    p_Pcd->partitionId = FmGetPartitionId(p_Pcd->h_Fm);
+    p_FmPcd->partitionId = FmGetPartitionId(p_FmPcd->h_Fm);
+#ifdef FM_MASTER_PARTITION
+    p_FmPcd->numOfEnabledGuestPartitionsPcds = 0;
+#endif /* FM_MASTER_PARTITION */
 #endif /* CONFIG_MULTI_PARTITION_SUPPORT */
 
 #ifndef CONFIG_GUEST_PARTITION
-    p_Pcd->h_App                                            = p_FmPcdParams->h_App;
-    p_Pcd->f_FmPcdException                                 = p_FmPcdParams->f_FmPcdException;
-    p_Pcd->f_FmPcdIndexedException                          = p_FmPcdParams->f_FmPcdIdException;
+    p_FmPcd->f_Exception                = p_FmPcdParams->f_Exception;
+    p_FmPcd->f_FmPcdIndexedException    = p_FmPcdParams->f_ExceptionId;
+    p_FmPcd->h_App                      = p_FmPcdParams->h_App;
 #endif  /* !CONFIG_GUEST_PARTITION */
 
-    return p_Pcd;
+    return p_FmPcd;
 }
 
 t_Error FM_PCD_Init(t_Handle h_FmPcd)
@@ -410,7 +423,6 @@ t_Error FM_PCD_Init(t_Handle h_FmPcd)
     SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdDriverParam, E_INVALID_HANDLE);
 
-
 #ifdef CONFIG_GUEST_PARTITION
     err = XX_SendMessage(p_FmPcd->fmPcdModuleName, FM_PCD_MASTER_IS_ALIVE, NULL, NULL, NULL);
     if(err)
@@ -464,12 +476,11 @@ t_Error FM_PCD_Free(t_Handle h_FmPcd)
     t_FmPcd                             *p_FmPcd =(t_FmPcd *)h_FmPcd;
 #ifdef CONFIG_GUEST_PARTITION
     t_FmPcdIpcSharedPlcrAllocParams     ipcSharedPlcrParams;
-    t_FmPcdIpcKgAllocParams             kgAlloc;
 #endif /* CONFIG_GUEST_PARTITION */
-#ifdef CONFIG_MULTI_PARTITION_SUPPORT
     t_Error                             err = E_OK;
-#endif /* CONFIG_MULTI_PARTITION_SUPPORT */
 
+    if(p_FmPcd->enabled)
+        FM_PCD_Disable(p_FmPcd);
 
     if(p_FmPcd->p_FmPcdDriverParam)
     {
@@ -478,56 +489,21 @@ t_Error FM_PCD_Free(t_Handle h_FmPcd)
     }
     if(p_FmPcd->p_FmPcdKg)
     {
-
-#ifndef CONFIG_GUEST_PARTITION
-        if(p_FmPcd->p_FmPcdKg->isDriverEmptyClsPlanGrp)
-            FmPcdKgDestroyClsPlanGrp(p_FmPcd, p_FmPcd->p_FmPcdKg->emptyClsPlanGrpId);
-#endif
-#ifdef CONFIG_MULTI_PARTITION_SUPPORT
-#ifdef CONFIG_GUEST_PARTITION
-    kgAlloc.numOfSchemes = p_FmPcd->p_FmPcdKg->numOfSchemes;
-    kgAlloc.partitionId = p_FmPcd->partitionId;
-    kgAlloc.numOfClsPlanEntries = p_FmPcd->p_FmPcdKg->numOfClsPlanEntries;
-    kgAlloc.isDriverClsPlanGrp = p_FmPcd->p_FmPcdKg->isDriverEmptyClsPlanGrp;
-    kgAlloc.clsPlanBase = p_FmPcd->p_FmPcdKg->clsPlanBase;
-    memcpy(kgAlloc.schemesIds, p_FmPcd->p_FmPcdKg->schemesIds , kgAlloc.numOfSchemes);
-    err = XX_SendMessage(p_FmPcd->fmPcdModuleName, FM_PCD_FREE_KG_RSRC, (uint8_t*)&kgAlloc, NULL, NULL);
-    if(err)
-        RETURN_ERROR(MINOR, err, NO_MSG);
-#else /* master */
-    err = FmPcdKgFreeSchemes(p_FmPcd,
-                                p_FmPcd->p_FmPcdKg->numOfSchemes,
-                                p_FmPcd->partitionId,
-                                p_FmPcd->p_FmPcdKg->schemesIds);
-    if(err)
-        RETURN_ERROR(MINOR, err, NO_MSG);
-    err = FmPcdKgFreeClsPlanEntries(p_FmPcd,
-                                p_FmPcd->p_FmPcdKg->numOfClsPlanEntries,
-                                p_FmPcd->partitionId,
-                                p_FmPcd->p_FmPcdKg->clsPlanBase);
-#endif /* CONFIG_GUEST_PARTITION */
-#endif /* CONFIG_MULTI_PARTITION_SUPPORT */
+        if((err = KgFree(p_FmPcd)) != E_OK)
+            RETURN_ERROR(MINOR, err, NO_MSG);
         XX_Free(p_FmPcd->p_FmPcdKg);
         p_FmPcd->p_FmPcdKg = NULL;
     }
     if(p_FmPcd->p_FmPcdPlcr)
     {
-        if(p_FmPcd->p_FmPcdPlcr->numOfSharedProfiles)
-#ifdef CONFIG_GUEST_PARTITION
-    /* Alloc resources using IPC messaging */
-    ipcSharedPlcrParams.num = p_FmPcd->p_FmPcdPlcr->numOfSharedProfiles;
-    memcpy(ipcSharedPlcrParams.profilesIds,p_FmPcd->p_FmPcdPlcr->sharedProfilesIds, p_FmPcd->p_FmPcdPlcr->numOfSharedProfiles*sizeof(uint16_t));
-    err = XX_SendMessage(p_FmPcd->fmPcdModuleName, FM_PCD_FREE_SHARED_PROFILES, (uint8_t*)&ipcSharedPlcrParams, NULL, NULL);
-    if(err)
-        RETURN_ERROR(MAJOR, err,NO_MSG);
-#else /* master */
-        PlcrFreeSharedProfiles(p_FmPcd, p_FmPcd->p_FmPcdPlcr->numOfSharedProfiles, p_FmPcd->p_FmPcdPlcr->sharedProfilesIds);
-#endif /* CONFIG_GUEST_PARTITION */
+        if((err = PlcrFree(p_FmPcd)) != E_OK)
+            RETURN_ERROR(MINOR, err, NO_MSG);
         XX_Free(p_FmPcd->p_FmPcdPlcr);
         p_FmPcd->p_FmPcdPlcr = NULL;
     }
     if(p_FmPcd->p_FmPcdPrs)
     {
+        PrsFree(p_FmPcd);
         XX_Free(p_FmPcd->p_FmPcdPrs);
         p_FmPcd->p_FmPcdPrs = NULL;
     }
@@ -547,6 +523,7 @@ t_Error FM_PCD_Free(t_Handle h_FmPcd)
 #ifdef FM_MASTER_PARTITION
     XX_UnregisterMessageHandler(p_FmPcd->fmPcdModuleName);
 #endif /* FM_MASTER_PARTITION */
+    FmUnregisterPcd(p_FmPcd->h_Fm);
 
     XX_Free(p_FmPcd);
     return E_OK;
@@ -589,18 +566,46 @@ t_Error FM_PCD_Enable(t_Handle h_FmPcd)
 
 t_Error FM_PCD_Disable(t_Handle h_FmPcd)
 {
-/*    t_FmPcd             *p_FmPcd = (t_FmPcd*)h_FmPcd;*/
-/* TODO - implement */
-    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+    t_FmPcd             *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    t_Error             err = E_OK;
+
+#ifndef CONFIG_GUEST_PARTITION
+#ifdef FM_MASTER_PARTITION
+    if(p_FmPcd->numOfEnabledGuestPartitionsPcds != 0)
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Trying to disable a master partition PCD while guest partitions are still enabled."));
+#endif /* FM_MASTER_PARTITION */
+    if(p_FmPcd->p_FmPcdKg)
+    {
+        err = KgDisable(p_FmPcd);
+        if(err)
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
+
+    if(p_FmPcd->p_FmPcdPlcr)
+    {
+        err = PlcrDisable(p_FmPcd);
+        if(err)
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
+
+    if(p_FmPcd->p_FmPcdPrs)
+    {
+        err = PrsDisable(p_FmPcd);
+        if(err)
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
+    p_FmPcd->enabled = FALSE;
 
     return E_OK;
+#else
+    return XX_SendMessage(p_FmPcd->fmPcdModuleName, FM_PCD_GUEST_DISABLE, NULL, NULL, NULL);
+#endif /* !CONFIG_GUEST_PARTITION */
 }
 
 t_Handle FM_PCD_SetNetEnvCharacteristics(t_Handle h_FmPcd, t_FmPcdNetEnvParams  *p_NetEnvParams)
 {
     t_FmPcd                 *p_FmPcd = (t_FmPcd*)h_FmPcd;
     uint8_t                 bitId = 0;
-    uint8_t                 privateBitId = 0;
     uint8_t                 i, j, k;
     uint8_t                 netEnvCurrId;
     uint8_t                 ipsecAhUnit = 0,ipsecEspUnit = 0;
@@ -665,7 +670,7 @@ t_Handle FM_PCD_SetNetEnvCharacteristics(t_Handle h_FmPcd, t_FmPcdNetEnvParams
                 && (k < FM_PCD_MAX_NUM_OF_INTERCHANGABLE_HDRS) ;k++)
         {
             /* Some headers pairs may not be defined on different units as the parser
-            doesn't distingush  */
+            doesn't distinguish */
             if(p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].hdr == HEADER_TYPE_IPSEC_AH)
             {
                 if (ipsecEspExists && (ipsecEspUnit != i))
@@ -696,7 +701,6 @@ t_Handle FM_PCD_SetNetEnvCharacteristics(t_Handle h_FmPcd, t_FmPcdNetEnvParams
             }
        }
 
-
     /* if private header (shim), check that no other headers specified */
     for(i=0;(p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[0].hdr != HEADER_TYPE_NONE)
             && (i < FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS) ;i++)
@@ -704,7 +708,7 @@ t_Handle FM_PCD_SetNetEnvCharacteristics(t_Handle h_FmPcd, t_FmPcdNetEnvParams
         if(IS_PRIVATE_HEADER(p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[0].hdr))
             if(p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[1].hdr != HEADER_TYPE_NONE)
             {
-                REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("SHIM header may not be interchangesd with other headers"));
+                REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("SHIM header may not be interchanged with other headers"));
                 RELEASE_LOCK(p_FmPcd->netEnvs[netEnvCurrId].lock);
                 return NULL;
             }
@@ -713,7 +717,20 @@ t_Handle FM_PCD_SetNetEnvCharacteristics(t_Handle h_FmPcd, t_FmPcdNetEnvParams
     for(i=0; i<p_NetEnvParams->numOfDistinctionUnits;i++)
     {
         if (IS_PRIVATE_HEADER(p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[0].hdr))
-            p_FmPcd->netEnvs[netEnvCurrId].unitsVectors[i] = (uint32_t)(0x00000001 << privateBitId++);
+            switch(p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[0].hdr)
+            {
+            case(HEADER_TYPE_USER_DEFINED_SHIM1):
+                p_FmPcd->netEnvs[netEnvCurrId].unitsVectors[i] = 0x00000001;
+                break;
+            case(HEADER_TYPE_USER_DEFINED_SHIM2):
+                p_FmPcd->netEnvs[netEnvCurrId].unitsVectors[i] = 0x00000002;
+                break;
+            case(HEADER_TYPE_USER_DEFINED_SHIM3):
+                p_FmPcd->netEnvs[netEnvCurrId].unitsVectors[i] = 0x00000004;
+                break;
+            default:
+                REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Only 3 SHIMs supported"));
+            }
         else
             p_FmPcd->netEnvs[netEnvCurrId].unitsVectors[i] = (uint32_t)(0x80000000 >> bitId++);
     }
@@ -755,8 +772,10 @@ t_Error FM_PCD_DeleteNetEnvCharacteristics(t_Handle h_FmPcd, t_Handle h_NetEnv)
     TRY_LOCK_RET_ERR(p_FmPcd->netEnvs[netEnvId].lock);
     /* check that no port is bound to this netEnv */
     if(p_FmPcd->netEnvs[netEnvId].owners)
+    {
+       RELEASE_LOCK(p_FmPcd->netEnvs[netEnvId].lock);
        RETURN_ERROR(MINOR, E_INVALID_STATE, ("Trying to delete a netEnv that has ports/schemes/trees/clsPlanGrps bound to"));
-
+    }
     p_FmPcd->netEnvs[netEnvId].used= FALSE;
 
     memset(p_FmPcd->netEnvs[netEnvId].units, 0, sizeof(t_FmPcdIntDistinctionUnit)*FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS);
@@ -818,13 +837,13 @@ t_Error FM_PCD_SetException(t_Handle h_FmPcd, e_FmPcdExceptions exception, bool
 
         switch(exception)
         {
-            case(e_FM_PCD_KG_ERR_EXCEPTION_DOUBLE_ECC):
-            case(e_FM_PCD_KG_ERR_EXCEPTION_KEYSIZE_OVERFLOW):
+            case(e_FM_PCD_KG_EXCEPTION_DOUBLE_ECC):
+            case(e_FM_PCD_KG_EXCEPTION_KEYSIZE_OVERFLOW):
                 if(!p_FmPcd->p_FmPcdKg)
                     RETURN_ERROR(MINOR, E_INVALID_STATE, ("Can't ask for this interrupt - keygen is not working"));
                 break;
-            case(e_FM_PCD_PLCR_ERR_EXCEPTION_DOUBLE_ECC):
-            case(e_FM_PCD_PLCR_ERR_EXCEPTION_INIT_ENTRY_ERROR):
+            case(e_FM_PCD_PLCR_EXCEPTION_DOUBLE_ECC):
+            case(e_FM_PCD_PLCR_EXCEPTION_INIT_ENTRY_ERROR):
             case(e_FM_PCD_PLCR_EXCEPTION_PRAM_SELF_INIT_COMPLETE):
             case(e_FM_PCD_PLCR_EXCEPTION_ATOMIC_ACTION_COMPLETE):
                 if(!p_FmPcd->p_FmPcdPlcr)
@@ -844,7 +863,7 @@ t_Error FM_PCD_SetException(t_Handle h_FmPcd, e_FmPcdExceptions exception, bool
 
         switch(exception)
         {
-            case(e_FM_PCD_KG_ERR_EXCEPTION_DOUBLE_ECC):
+            case(e_FM_PCD_KG_EXCEPTION_DOUBLE_ECC):
                 tmpReg = GET_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgeeer);
                 if(enable)
                     tmpReg |= FM_PCD_KG_DOUBLE_ECC;
@@ -852,7 +871,7 @@ t_Error FM_PCD_SetException(t_Handle h_FmPcd, e_FmPcdExceptions exception, bool
                     tmpReg &= ~FM_PCD_KG_DOUBLE_ECC;
                 WRITE_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgeeer, tmpReg);
                 break;
-            case(e_FM_PCD_KG_ERR_EXCEPTION_KEYSIZE_OVERFLOW):
+            case(e_FM_PCD_KG_EXCEPTION_KEYSIZE_OVERFLOW):
                 tmpReg = GET_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgeeer);
                 if(enable)
                     tmpReg |= FM_PCD_KG_KEYSIZE_OVERFLOW;
@@ -892,7 +911,7 @@ t_Error FM_PCD_SetException(t_Handle h_FmPcd, e_FmPcdExceptions exception, bool
                     tmpReg &= ~FM_PCD_PRS_SINGLE_ECC;
                 WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->pever, tmpReg);
                 break;
-            case(e_FM_PCD_PLCR_ERR_EXCEPTION_DOUBLE_ECC):
+            case(e_FM_PCD_PLCR_EXCEPTION_DOUBLE_ECC):
                 tmpReg = GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_eier);
                 if(enable)
                     tmpReg |= FM_PCD_PLCR_DOUBLE_ECC;
@@ -900,7 +919,7 @@ t_Error FM_PCD_SetException(t_Handle h_FmPcd, e_FmPcdExceptions exception, bool
                     tmpReg &= ~FM_PCD_PLCR_DOUBLE_ECC;
                 WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_eier, tmpReg);
                 break;
-            case(e_FM_PCD_PLCR_ERR_EXCEPTION_INIT_ENTRY_ERROR):
+            case(e_FM_PCD_PLCR_EXCEPTION_INIT_ENTRY_ERROR):
                 tmpReg = GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_eier);
                 if(enable)
                     tmpReg |= FM_PCD_PLCR_INIT_ENTRY_ERROR;
@@ -928,14 +947,17 @@ t_Error FM_PCD_SetException(t_Handle h_FmPcd, e_FmPcdExceptions exception, bool
                 RETURN_ERROR(MINOR, E_INVALID_STATE, ("Unsupported exception"));
         }
         /* for ECC exceptions driver automatically enables ECC mechanism, if disabled.
-           Driver does NOT disables them automatically, as we do not control which
-           of the rams are enabled and which arn't */
-        if(enable && ( (exception == e_FM_PCD_KG_ERR_EXCEPTION_DOUBLE_ECC) |
-                       (exception == e_FM_PCD_PLCR_ERR_EXCEPTION_DOUBLE_ECC) |
+           Driver may disable them automatically, depending on driver's status */
+        if(enable && ( (exception == e_FM_PCD_KG_EXCEPTION_DOUBLE_ECC) |
+                       (exception == e_FM_PCD_PLCR_EXCEPTION_DOUBLE_ECC) |
+                       (exception == e_FM_PCD_PRS_EXCEPTION_DOUBLE_ECC) |
+                       (exception == e_FM_PCD_PRS_EXCEPTION_SINGLE_ECC)))
+            FmEnableRamsEcc(p_FmPcd->h_Fm);
+        if(!enable && ( (exception == e_FM_PCD_KG_EXCEPTION_DOUBLE_ECC) |
+                       (exception == e_FM_PCD_PLCR_EXCEPTION_DOUBLE_ECC) |
                        (exception == e_FM_PCD_PRS_EXCEPTION_DOUBLE_ECC) |
                        (exception == e_FM_PCD_PRS_EXCEPTION_SINGLE_ECC)))
-            if(!FmRamsEccIsExternalCtl(p_FmPcd->h_Fm))
-                FM_EnableRamsEcc(p_FmPcd->h_Fm);
+            FmDisableRamsEcc(p_FmPcd->h_Fm);
     }
     else
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Undefined exception"));
@@ -1063,7 +1085,7 @@ uint32_t FM_PCD_GetCounter(t_Handle h_FmPcd, e_FmPcdCounters counter)
     }
 }
 
-t_Error FM_PCD_SetCounter(t_Handle h_FmPcd, e_FmPcdCounters counter, uint32_t value)
+t_Error FM_PCD_ModifyCounter(t_Handle h_FmPcd, e_FmPcdCounters counter, uint32_t value)
 {
     t_FmPcd            *p_FmPcd = (t_FmPcd*)h_FmPcd;
 
@@ -1204,13 +1226,13 @@ t_Error FM_PCD_ForceIntr (t_Handle h_FmPcd, e_FmPcdExceptions exception)
 
     switch(exception)
     {
-        case(e_FM_PCD_KG_ERR_EXCEPTION_DOUBLE_ECC):
-        case(e_FM_PCD_KG_ERR_EXCEPTION_KEYSIZE_OVERFLOW):
+        case(e_FM_PCD_KG_EXCEPTION_DOUBLE_ECC):
+        case(e_FM_PCD_KG_EXCEPTION_KEYSIZE_OVERFLOW):
             if(!p_FmPcd->p_FmPcdKg)
                 RETURN_ERROR(MINOR, E_INVALID_STATE, ("Can't ask for this interrupt - keygen is not working"));
             break;
-        case(e_FM_PCD_PLCR_ERR_EXCEPTION_DOUBLE_ECC):
-        case(e_FM_PCD_PLCR_ERR_EXCEPTION_INIT_ENTRY_ERROR):
+        case(e_FM_PCD_PLCR_EXCEPTION_DOUBLE_ECC):
+        case(e_FM_PCD_PLCR_EXCEPTION_INIT_ENTRY_ERROR):
         case(e_FM_PCD_PLCR_EXCEPTION_PRAM_SELF_INIT_COMPLETE):
         case(e_FM_PCD_PLCR_EXCEPTION_ATOMIC_ACTION_COMPLETE):
             if(!p_FmPcd->p_FmPcdPlcr)
@@ -1249,22 +1271,22 @@ t_Error FM_PCD_ForceIntr (t_Handle h_FmPcd, e_FmPcdExceptions exception)
                 RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception is masked"));
             WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->pevfr, FM_PCD_PRS_SINGLE_ECC);
             break;
-        case e_FM_PCD_KG_ERR_EXCEPTION_DOUBLE_ECC:
+        case e_FM_PCD_KG_EXCEPTION_DOUBLE_ECC:
             if (!(p_FmPcd->exceptions & FM_PCD_EX_KG_DOUBLE_ECC))
                 RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception is masked"));
             WRITE_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgfeer, FM_PCD_KG_DOUBLE_ECC);
             break;
-        case e_FM_PCD_KG_ERR_EXCEPTION_KEYSIZE_OVERFLOW:
+        case e_FM_PCD_KG_EXCEPTION_KEYSIZE_OVERFLOW:
             if (!(p_FmPcd->exceptions & FM_PCD_EX_KG_KEYSIZE_OVERFLOW))
                 RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception is masked"));
             WRITE_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgfeer, FM_PCD_KG_KEYSIZE_OVERFLOW);
             break;
-        case e_FM_PCD_PLCR_ERR_EXCEPTION_DOUBLE_ECC:
+        case e_FM_PCD_PLCR_EXCEPTION_DOUBLE_ECC:
             if (!(p_FmPcd->exceptions & FM_PCD_EX_PLCR_DOUBLE_ECC))
                 RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception is masked"));
             WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_eifr, FM_PCD_PLCR_DOUBLE_ECC);
             break;
-        case e_FM_PCD_PLCR_ERR_EXCEPTION_INIT_ENTRY_ERROR:
+        case e_FM_PCD_PLCR_EXCEPTION_INIT_ENTRY_ERROR:
             if (!(p_FmPcd->exceptions & FM_PCD_EX_PLCR_INIT_ENTRY_ERROR))
                 RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception is masked"));
             WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_eifr, FM_PCD_PLCR_INIT_ENTRY_ERROR);
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.h b/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.h
index 96043d5..86efc6c 100644
--- a/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.h
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -46,6 +46,9 @@
 #include "fm_common.h"
 
 
+#define __ERR_MODULE__  MODULE_FM_PCD
+
+
 /**************************************************************************//**
  @Group         FM_PCD_Runtime_grp FM PCD Runtime Unit
  @{
@@ -55,14 +58,22 @@
 /* General defines          */
 /****************************/
 
-#define GET_FM_PCD_PORTID_FROM_GLOBAL_PORTID(pcdPortId, pcdPortsTable, hardwarePortId)\
-    pcdPortId = 0;\
-    while((hardwarePortId != pcdPortsTable[pcdPortId]) && (pcdPortId<PCD_MAX_NUM_OF_PORTS))\
-        pcdPortId++;
-
 #define PCD_PORTS_TABLE                     {1,2,3,4,5,6,7,8,9,10,11,16}
-#define GET_GLOBAL_PORTID_FROM_PCD_PORTS_TABLE(hardwarePortId, pcdPortsTable,i)\
-    hardwarePortId = pcdPortsTable[i]
+
+#define SET_FM_PCD_PORTID_FROM_GLOBAL_PORTID(pcdPortId, hardwarePortId) \
+do {                                                                    \
+    uint8_t pcdPortsTable[] = PCD_PORTS_TABLE;                          \
+    pcdPortId = 0;                                                      \
+    while((hardwarePortId != pcdPortsTable[pcdPortId]) &&               \
+          (pcdPortId<PCD_MAX_NUM_OF_PORTS))                             \
+        pcdPortId++;                                                    \
+} while (0)
+
+#define GET_GLOBAL_PORTID_FROM_PCD_PORTS_TABLE(hardwarePortId, i)       \
+do {                                                                    \
+    uint8_t pcdPortsTable[] = PCD_PORTS_TABLE;                          \
+    hardwarePortId = pcdPortsTable[i];                                  \
+} while (0)
 
 
 #define ILLEGAL_PCD_PORTID                  0xFF
@@ -70,7 +81,7 @@
 
 #define GET_PCD_PORTID_BY_RELATIVE(portId,type,id)      \
 switch(type) {                              \
-    case(e_FM_PORT_TYPE_OFFLINE_PARSING):   \
+    case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):   \
         if (id > (LAST_HO_PORTID-BASE_HO_PORTID))       \
             portId = ILLEGAL_PCD_PORTID;    \
         else                                \
@@ -79,21 +90,21 @@ switch(type) {                              \
         if (id > (LAST_RX_PORTID-BASE_RX_PORTID))       \
             portId = ILLEGAL_PCD_PORTID;    \
         else                                \
-            portId = id+MAX_NUM_OF_OP_PORTS;\
+            portId = id+FM_MAX_NUM_OF_OH_PORTS;\
         break;                              \
       case(e_FM_PORT_TYPE_RX_10G):          \
         if (id > (LAST_RX10_PORTID-BASE_RX10_PORTID))   \
             portId = ILLEGAL_PCD_PORTID;    \
         else                                \
-            portId = id+MAX_NUM_OF_OP_PORTS + MAX_NUM_OF_RX_1G_PORTS;    \
+            portId = id+FM_MAX_NUM_OF_OH_PORTS + FM_MAX_NUM_OF_1G_RX_PORTS;    \
         break;                              \
       default:                              \
         portId = ILLEGAL_PCD_PORTID;        \
 }
 
 #define IS_PRIVATE_HEADER(hdr)              ((hdr == HEADER_TYPE_USER_DEFINED_SHIM1 ) ||   \
-                                            (hdr == HEADER_TYPE_USER_DEFINED_SHIM2) ||    \
-                                            (hdr == HEADER_TYPE_USER_DEFINED_SHIM3))
+                                             (hdr == HEADER_TYPE_USER_DEFINED_SHIM2) ||    \
+                                             (hdr == HEADER_TYPE_USER_DEFINED_SHIM3))
 
 /****************************/
 /* Error defines           */
@@ -113,13 +124,13 @@ switch(type) {                              \
 
 #define GET_FM_PCD_EXCEPTION_FLAG(bitMask, exception)               \
 switch(exception){                                                  \
-    case e_FM_PCD_KG_ERR_EXCEPTION_DOUBLE_ECC:                      \
+    case e_FM_PCD_KG_EXCEPTION_DOUBLE_ECC:                      \
         bitMask = FM_PCD_EX_KG_DOUBLE_ECC; break;                   \
-    case e_FM_PCD_PLCR_ERR_EXCEPTION_DOUBLE_ECC:                    \
+    case e_FM_PCD_PLCR_EXCEPTION_DOUBLE_ECC:                    \
         bitMask = FM_PCD_EX_PLCR_DOUBLE_ECC; break;                 \
-    case e_FM_PCD_KG_ERR_EXCEPTION_KEYSIZE_OVERFLOW:                \
+    case e_FM_PCD_KG_EXCEPTION_KEYSIZE_OVERFLOW:                \
         bitMask = FM_PCD_EX_KG_KEYSIZE_OVERFLOW; break;             \
-    case e_FM_PCD_PLCR_ERR_EXCEPTION_INIT_ENTRY_ERROR:              \
+    case e_FM_PCD_PLCR_EXCEPTION_INIT_ENTRY_ERROR:              \
         bitMask = FM_PCD_EX_PLCR_INIT_ENTRY_ERROR; break;           \
     case e_FM_PCD_PLCR_EXCEPTION_PRAM_SELF_INIT_COMPLETE:           \
         bitMask = FM_PCD_EX_PLCR_PRAM_SELF_INIT_COMPLETE; break;    \
@@ -139,6 +150,7 @@ switch(exception){                                                  \
 /***********************************************************************/
 /*          SW parser L4 shells patch                                  */
 /***********************************************************************/
+#ifdef FM_PRS_L4_SHELL_ERRATA
 #define SW_PRS_L4_PATCH                         \
 {   0x31,0x92,0x02,0x1f,0x00,0x32,0x00,0x78,    \
     0x00,0x34,0x32,0xf0,0x00,0x50,0x00,0x0c,    \
@@ -157,6 +169,7 @@ switch(exception){                                                  \
     0x1b,0xff,0x00,0x00,0x00,0x00,0x00,0x00};
 
 #define SW_PRS_L4_PATCH_SIZE                120
+#endif /* FM_PRS_L4_SHELL_ERRATA */
 
 /****************************/
 /* Parser defines           */
@@ -416,6 +429,8 @@ typedef struct {
 
 #define CC_PC_GENERIC_WITHOUT_MASK          0x27
 #define CC_PC_GENERIC_WITH_MASK             0x28
+#define CC_PC_GENERIC_IC_GMASK              0x2B
+#define CC_PC_GENERIC_IC_HASH_INDEXED       0x2C
 
 #define CC_PR_OFFSET                        0x25
 #define CC_PR_WITHOUT_OFFSET                0x26
@@ -456,6 +471,9 @@ typedef struct {
 #define FM_PCD_AD_TYPE_MASK                 0xc0000000
 #define FM_PCD_AD_PROFILEID_FOR_CNTRL_SHIFT 16
 
+#define GLBL_MASK_FOR_HASH_INDEXED          0xfff00000
+#define CC_GLBL_MASK_SIZE                   4
+
 /****************************/
 /* Defaults                 */
 /****************************/
@@ -473,16 +491,14 @@ typedef struct {
 /***********************************************************************/
 /*          Memory map                                                 */
 /***********************************************************************/
-#ifdef __MWERKS__
+#if defined(__MWERKS__) && !defined(__GNUC__)
 #pragma pack(push,1)
-#endif /*__MWERKS__ */
+#endif /* defined(__MWERKS__) && ... */
 #define MEM_MAP_START
 
-
 typedef _Packed struct {
    volatile uint32_t kgoe_sp;
    volatile uint32_t kgoe_cpp;
-
 } _PackedType t_FmPcdKgPortConfigRegs;
 
 typedef _Packed struct {
@@ -490,9 +506,9 @@ typedef _Packed struct {
 } _PackedType t_FmPcdKgClsPlanRegs;
 
 typedef _Packed union {
-    t_FmPcdKgInterModuleSchemeRegs     schemeRegs;
-    t_FmPcdKgPortConfigRegs portRegs;
-    t_FmPcdKgClsPlanRegs    clsPlanRegs;
+    t_FmPcdKgInterModuleSchemeRegs  schemeRegs;
+    t_FmPcdKgPortConfigRegs         portRegs;
+    t_FmPcdKgClsPlanRegs            clsPlanRegs;
 } _PackedType u_FmPcdKgIndirectAccessRegs;
 
 typedef _Packed struct {
@@ -607,9 +623,9 @@ typedef _Packed union {
 } _PackedType t_Ad;
 
 #define MEM_MAP_END
-#ifdef __MWERKS__
+#if defined(__MWERKS__) && !defined(__GNUC__)
 #pragma pack(pop)
-#endif /* __MWERKS__ */
+#endif /* defined(__MWERKS__) && ... */
 
 /***********************************************************************/
 /*  Driver's internal structures                                        */
@@ -697,7 +713,7 @@ typedef struct {
 #endif /* CONFIG_MULTI_PARTITION_SUPPORT */
     uint8_t             baseEntry;
     uint16_t            sizeOfGrp;
-    protocolOpt_t       optArray[MAX_NUM_OF_OPTIONS];
+    protocolOpt_t       optArray[FM_PCD_MAX_NUM_OF_OPTIONS];
 } t_FmPcdKgClsPlanGrp;
 
 typedef struct {
@@ -710,6 +726,7 @@ typedef struct {
     bool                nextRelativePlcrProfile;
     uint16_t            relativeProfileId;
     uint16_t            numOfProfiles;
+    t_FmPcdKgKeyOrder   orderedArray;
 } t_FmPcdKgScheme;
 
 #ifndef CONFIG_GUEST_PARTITION
@@ -797,7 +814,7 @@ typedef struct {
 
 typedef struct {
     uint8_t             netEnvId;
-    t_Handle            p_CcBaseTree;
+    uint64_t            ccTreeBaseAddr;
     uint8_t             numOfGrps;
     t_FmPcdCcGroupParam fmPcdGroupParam[8];
     t_List              ccNextNodesLst;
@@ -807,17 +824,16 @@ typedef struct {
 } t_FmPcdCcTree;
 
 #if 0
-typedef struct
-{
+typedef struct {
     uint32_t nextCcNodeInfo;
     t_List   h_Node;
-}t_CcNodeInfo;
-#endif
-typedef struct
-{
+} t_CcNodeInfo;
+#endif /* 0 */
+
+typedef struct {
    e_FmPcdEngine  fmPcdEngine;
    uint32_t       additionalInfo;
-}t_NextEngineParamsInfo;
+} t_NextEngineParamsInfo;
 
 typedef struct {
     t_FmPcdCcTree   *p_FmPcdCcTree;
@@ -828,8 +844,8 @@ typedef struct {
 
 typedef struct {
     t_Handle               h_FmMuram;
-    t_FmPcdCcNodeArray     ccNodeArrayEntry[MAX_NUM_OF_PCD_CC_NODES];
-    t_FmPcdCcTreeArray     ccTreeArrayEntry[MAX_NUM_OF_PCD_CC_TREES];
+    t_FmPcdCcNodeArray     ccNodeArrayEntry[FM_PCD_MAX_NUM_OF_CC_NODES];
+    t_FmPcdCcTreeArray     ccTreeArrayEntry[FM_PCD_MAX_NUM_OF_CC_TREES];
     uint64_t               physicalMuramBase;
 } t_FmPcdCc;
 
@@ -861,6 +877,9 @@ typedef struct {
     bool                        enabled;
 #ifdef CONFIG_MULTI_PARTITION_SUPPORT
     uint8_t                     partitionId;            /**< Guest Partition Id */
+#ifdef FM_MASTER_PARTITION
+    uint8_t                     numOfEnabledGuestPartitionsPcds;
+#endif /* FM_MASTER_PARTITION */
 #endif /* CONFIG_MULTI_PARTITION_SUPPORT */
     char                        fmPcdModuleName[MODULE_NAME_SIZE];
 
@@ -874,8 +893,8 @@ typedef struct {
 
 #ifndef CONFIG_GUEST_PARTITION
     uint32_t                    exceptions;
-    t_FmPcdException            *f_FmPcdException;
-    t_FmPcdIdException          *f_FmPcdIndexedException;
+    t_FmPcdExceptionCallback    *f_Exception;
+    t_FmPcdIdExceptionCallback  *f_FmPcdIndexedException;
     t_Handle                    h_App;
 #endif /* !CONFIG_GUEST_PARTITION */
 
@@ -917,9 +936,11 @@ bool        PcdNetEnvIsUnitWithoutOpts(t_FmPcd *p_FmPcd, uint8_t netEnvId, uint3
 
 t_Handle    KgConfig( t_FmPcd *p_FmPcd, t_FmPcdParams *p_FmPcdParams);
 t_Error     KgInit(t_FmPcd *p_FmPcd);
+t_Error     KgFree(t_FmPcd *p_FmPcd);
 void        KgSetClsPlan(t_Handle h_FmPcd, t_FmPcdKgInterModuleClsPlanSet *p_Set);
 bool        KgIsSchemeAlwaysDirect(t_Handle h_FmPcd, uint8_t schemeId);
 t_Error     KgEnable(t_FmPcd *p_FmPcd);
+t_Error     KgDisable(t_FmPcd *p_FmPcd);
 
 #ifdef CONFIG_MULTI_PARTITION_SUPPORT
 t_Error     FmPcdKgAllocSchemes(t_Handle h_FmPcd, uint8_t numOfSchemes, uint8_t partitionId, uint8_t *p_SchemesIds);
@@ -932,7 +953,9 @@ t_Error     KgBindPortToSchemes(t_Handle h_FmPcd , uint8_t hardwarePortId, uint3
 
 t_Handle    PlcrConfig(t_FmPcd *p_FmPcd, t_FmPcdParams *p_FmPcdParams);
 t_Error     PlcrInit(t_FmPcd *p_FmPcd);
+t_Error     PlcrFree(t_FmPcd *p_FmPcd);
 t_Error     PlcrEnable(t_FmPcd *p_FmPcd);
+t_Error     PlcrDisable(t_FmPcd *p_FmPcd);
 t_Error     PlcrFreeProfiles(t_FmPcd *p_FmPcd, uint8_t hardwarePortId, uint16_t num, uint16_t base);
 t_Error     PlcrAllocProfiles(t_FmPcd *p_FmPcd, uint8_t hardwarePortId, uint16_t numOfProfiles, uint16_t *p_Base);
 t_Error     PlcrAllocSharedProfiles(t_FmPcd *p_FmPcd, uint16_t numOfProfiles, uint16_t *profilesIds);
@@ -941,6 +964,8 @@ void        PlcrFreeSharedProfiles(t_FmPcd *p_FmPcd, uint16_t numOfProfiles, uin
 t_Handle    PrsConfig(t_FmPcd *p_FmPcd,t_FmPcdParams *p_FmPcdParams);
 t_Error     PrsInit(t_FmPcd *p_FmPcd);
 t_Error     PrsEnable(t_FmPcd *p_FmPcd);
+t_Error     PrsDisable(t_FmPcd *p_FmPcd);
+void        PrsFree(t_FmPcd *p_FmPcd );
 
 t_Handle    CcConfig(t_FmPcd *p_FmPcd, t_FmPcdParams *p_FmPcdParams);
 void        CcFree(t_FmPcdCc *p_FmPcdCc);
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd_ipc.h b/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd_ipc.h
index 3d0ab65..58d0380 100644
--- a/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd_ipc.h
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd_ipc.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -121,21 +121,20 @@ typedef struct
     uint16_t    profilesIds[FM_PCD_PLCR_NUM_ENTRIES];   /**< OUT */
 } t_FmPcdIpcSharedPlcrAllocParams;
 
-#ifdef __MWERKS__
+#if defined(__MWERKS__) && !defined(__GNUC__)
 #pragma pack(push,1)
-#endif /*__MWERKS__ */
+#endif /* defined(__MWERKS__) && ... */
 #define MEM_MAP_START
 
-typedef _Packed struct t_FmPcdIcPhysAddr
-{
-    volatile uint16_t high;
+typedef _Packed struct t_FmPcdIcPhysAddr {
+    volatile uint8_t  high;
     volatile uint32_t low;
 } _PackedType t_FmPcdIcPhysAddr;
 
 #define MEM_MAP_END
-#ifdef __MWERKS__
+#if defined(__MWERKS__) && !defined(__GNUC__)
 #pragma pack(pop)
-#endif /* __MWERKS__ */
+#endif /* defined(__MWERKS__) && ... */
 
 /**************************************************************************//**
  @Function      FM_PCD_GET_SET_PORT_PARAMS
@@ -207,6 +206,8 @@ typedef _Packed struct t_FmPcdIcPhysAddr
 
 #define FM_PCD_MASTER_IS_ENABLED                35
 
+#define FM_PCD_GUEST_DISABLE                    36
+
 /** @} */ /* end of FM_PCD_IPC_grp group */
 /** @} */ /* end of FM_grp group */
 
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_plcr.c b/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_plcr.c
index ae4fd33..5c5c334 100644
--- a/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_plcr.c
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_plcr.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -45,7 +45,7 @@
 #include "fm_hc.h"
 
 
-static bool    FmPcdPlcrIsProfileShared(t_Handle h_FmPcd, uint16_t absoluteProfileId)
+static bool FmPcdPlcrIsProfileShared(t_Handle h_FmPcd, uint16_t absoluteProfileId)
 {
     t_FmPcd         *p_FmPcd            = (t_FmPcd*)h_FmPcd;
     uint16_t        i;
@@ -115,43 +115,56 @@ static uint32_t FPP_Function(uint32_t fpp)
     else
         return 16 + fpp;
 }
-
-static uint64_t Rate2Sample(e_FmPcdPlcrRateMode rateMode, uint32_t rate, uint64_t timeStampPeriod, uint32_t count)
+static void GetInfoRateReg(e_FmPcdPlcrRateMode rateMode,
+                                uint32_t rate,
+                                uint64_t tsuInTenthNano,
+                                uint32_t fppShift,
+                                uint64_t *p_Integer,
+                                uint64_t *p_Fraction)
 {
-uint64_t temp;
-uint32_t tmp;
+    uint64_t tmp, div;
 
-    tmp = FPP_Function(count);
-    if (rateMode == e_FM_PCD_PLCR_BYTE_MODE)
+    if(rateMode == e_FM_PCD_PLCR_BYTE_MODE)
     {
-        temp = ((uint64_t)rate) << (16+tmp);    /* Move it left 16 Bit to the fix point position
-                                             + 16 Bit to set the time stamp period */
-        temp = temp / 1000000000;         /* Change it from KBit/sec into KBit/(Nano Sec) */
-        temp = (temp * 1000) / 8;         /* Change it from KBit/(Nano Sec) into Byte/(Nano Sec) */
-        temp =  temp / (timeStampPeriod); /* Change it from Byte/(Nano Sec) into Byte/TimeStamp Units*/
+        /* now we calculate the initial integer for the bigger rate */
+        /* from Kbps to Bytes/TSU */
+        tmp = (uint64_t)rate;
+        tmp *= 1000; /* kb --> b */
+        tmp *= tsuInTenthNano; /* bps --> bpTsu(in 10nano) */
+
+        div = 1000000000;   /* nano */
+        div *= 10;          /* 10 nano */
+        div *= 8;           /* bit to byte */
     }
     else
     {
-        temp = ((uint64_t)rate) << (16+tmp);  /* Move it left 16 bit to the fix point position
-                                           + 16 Bit to set the time stamp period */
-        temp = temp / 1000000000;       /* Change it from Packet/sec into Packet/(Nano Sec) */
-        temp =  temp / (timeStampPeriod); /* Change it from Packet/Nano into Packet/TimeStamp */
+        /* now we calculate the initial integer for the bigger rate */
+        /* from Kbps to Bytes/TSU */
+        tmp = (uint64_t)rate;
+        tmp *= tsuInTenthNano; /* bps --> bpTsu(in 10nano) */
+
+        div = 1000000000;   /* nano */
+        div *= 10;          /* 10 nano */
     }
+    *p_Integer = (tmp<<fppShift)/div;
 
-    return temp;
+    /* for calculating the fraction, we will recalculate cir and deduct the integer.
+     * For precision, we will multiply by 2^16. we do not divid back, since we write
+     * this value as fraction - see spec.
+     */
+    *p_Fraction = (((tmp<<fppShift)<<16) - ((*p_Integer<<16)*div))/div;
 
 }
-
-
 static void CheckValidRateRange(t_FmPcd *p_FmPcd)
 {
-    uint64_t    timeStampPeriod;
+    //uint64_t    timeStampPeriod;
 //    uint64_t    maxVal = 0xffffffff0000LL; /* [bytes per timeStamp unit] max value which will be legal  for fpp adjustement calculation - for not being "too big"*/
-    uint32_t    minVal = 0x00010000;     /*  [bytes per timeStamp unit] min value which will be legal  for fpp adjustement calculation - for not being "too small"*/
+    //uint32_t    minVal = 0x00010000;     /*  [bytes per timeStamp unit] min value which will be legal  for fpp adjustement calculation - for not being "too small"*/
 //    uint64_t    tempMaxLimit;
-    uint64_t    tempMinLimit;
-
-    timeStampPeriod = (uint64_t)FmGetTimeStampPeriod(p_FmPcd->h_Fm);               /* TimeStamp per nano seconds units */
+//    uint64_t    tempMinLimit;
+    /*TODO */
+#if 0
+   timeStampPeriod = (uint64_t)FmGetTimeStampPeriod(p_FmPcd->h_Fm);               /* TimeStamp per nano seconds units */
 
     /*With current timestamp configuration there can not be a MaxLimit,
       which means that any rate above MinLimit can be served by Policer*/
@@ -178,6 +191,9 @@ static void CheckValidRateRange(t_FmPcd *p_FmPcd)
     tempMinLimit = tempMinLimit >> 32;         /*16 (Cir/pir register presicion) + 16 (number of shifts done to fpp by default)*/
 
     XX_Print("Valid range for PacketMode RateSelection is min 0x%x ", (uint32_t)tempMinLimit);
+#else
+    UNUSED(p_FmPcd);
+#endif /* 0 */
 }
 
 /* .......... */
@@ -186,100 +202,83 @@ static void calcRates(t_Handle h_FmPcd, t_FmPcdPlcrNonPassthroughAlgParams *p_No
                         uint32_t *cir, uint32_t *cbs, uint32_t *pir_eir, uint32_t *pbs_ebs, uint32_t *fpp)
 {
     t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
-    uint64_t    timeStampPeriod;
-    uint64_t    tempCir, tempPir_Eir;
-    uint32_t    temp, count;
-    bool        big;
+    uint64_t    integer, fraction;
+    uint32_t    temp, tsuInTenthNanos, bitFor1Micro;
+    uint8_t     fppShift=0;
 
-    timeStampPeriod = (uint64_t)FmGetTimeStampPeriod(p_FmPcd->h_Fm);               /* TimeStamp per nano seconds units */
+    bitFor1Micro = FmGetTimeStampScale(p_FmPcd->h_Fm);  /* TimeStamp per nano seconds units */
+    /* we want the tsu to count 10 nano for better precision normally tsu is 3.9 nano, now we will get 39 */
+    tsuInTenthNanos = (uint32_t)(1000*10/(1<<bitFor1Micro));
 
-    /* First round to calculate precision */
+    /* we choose the faster rate to calibrate fpp */
     if (p_NonPassthroughAlgParam->comittedInfoRate > p_NonPassthroughAlgParam->peakOrAccessiveInfoRate)
-        tempCir = Rate2Sample(p_NonPassthroughAlgParam->rateMode, p_NonPassthroughAlgParam->comittedInfoRate, timeStampPeriod, 0);
+        GetInfoRateReg(p_NonPassthroughAlgParam->rateMode, p_NonPassthroughAlgParam->comittedInfoRate, tsuInTenthNanos, 0, &integer, &fraction);
     else
-        tempCir = Rate2Sample(p_NonPassthroughAlgParam->rateMode, p_NonPassthroughAlgParam->peakOrAccessiveInfoRate, timeStampPeriod, 0);
+        GetInfoRateReg(p_NonPassthroughAlgParam->rateMode, p_NonPassthroughAlgParam->peakOrAccessiveInfoRate, tsuInTenthNanos, 0, &integer, &fraction);
 
-    /* Base on result calculate the FPP and re calculate cir, pir_eir */
-    count = 0;
-    if ((tempCir > 0xFFFFFFFF))
-    {
-        /* Overflow need to shrink number */
-        big = TRUE;
-        temp = (uint32_t)(tempCir >> 32);
-        while (temp > 0)
-        {
-            temp = temp >> 1;
-            count++;
-        }
-        if(count > 16)
-        {
-            REPORT_ERROR(MAJOR, E_INVALID_SELECTION, ("timeStampPeriod to Information rate ratio is too big"));
-            CheckValidRateRange(p_FmPcd);
-            return;
-        }
-    }
-    else
+
+    /* we shift integer, as in cir/pir it is represented by the MSB 16 bits, and
+     * the LSB bits are for the fraction */
+    temp = (uint32_t)((integer<<16) & 0x00000000FFFFFFFF);
+    /* temp is effected by the rate. For low rates it may be as low as 0, and then we'll
+     * take max fpp=31.
+     * For high rates it will never exceed the 32 bit reg (after the 16 shift), as it is
+     * limited by the 10G physical port.
+     */
+    if(temp != 0)
     {
-        /* Underflow need to improve accuracy */
-        big = FALSE;
-        temp = (uint32_t)(tempCir & 0x00000000FFFFFFFF);
-        if(temp != 0)
-        {
+        /* count zeroes left of the higher used bit (in order to shift the value such that
+         * unused bits may be used for fraction).
+         */
         while ((temp & 0x80000000) == 0)
         {
             temp = temp << 1;
-            count++;
+            fppShift++;
         }
-        if(count > 15)
+        if(fppShift > 15)
         {
             REPORT_ERROR(MAJOR, E_INVALID_SELECTION, ("timeStampPeriod to Information rate ratio is too small"));
-                CheckValidRateRange(p_FmPcd);
+            CheckValidRateRange(p_FmPcd);
             return;
-            }
         }
     }
-
-    /* Second round based on precision do the roght calculation */
-    if (count > 0)
+    else
     {
-        if (big)
-        {
-           *fpp = (uint32_t)(0x1F - (count - 1));
- //           tempCir     = Rate2Sample(p_NonPassthroughAlgParam->rateMode, p_NonPassthroughAlgParam->comittedInfoRate, timeStampPeriod, *fpp);
- //           tempPir_Eir = Rate2Sample(p_NonPassthroughAlgParam->rateMode, p_NonPassthroughAlgParam->peakOrAccessiveInfoRate , timeStampPeriod, *fpp);
-           // *fpp = (uint32_t)(0x1F - ((1 << (count - 1)) + 1));
-        }
+        temp = (uint32_t)fraction; /* fraction will alyas be smaller than 2^16 */
+        if(!temp)
+            /* integer and fraction are 0, we set fpp to its max val */
+            fppShift = 31;
         else
         {
-            *fpp = (uint32_t)count;
- //           tempCir     = Rate2Sample(p_NonPassthroughAlgParam->rateMode, p_NonPassthroughAlgParam->comittedInfoRate , timeStampPeriod, *fpp);
- //           tempPir_Eir = Rate2Sample(p_NonPassthroughAlgParam->rateMode, p_NonPassthroughAlgParam->peakOrAccessiveInfoRate , timeStampPeriod, *fpp);
-          //  *fpp = (uint32_t)(1 << (count - 1));
+            /* integer was 0 but fraction is not. fpp is 16 for the integer,
+             * + all left zeroes of the fraction. */
+            fppShift=16;
+            /* count zeroes left of the higher used bit (in order to shift the value such that
+             * unused bits may be used for fraction).
+             */
+            while ((temp & 0x8000) == 0)
+            {
+                temp = temp << 1;
+                fppShift++;
+            }
         }
     }
-    else
-    {
-            *fpp = 0;
- //           tempCir     = Rate2Sample(p_NonPassthroughAlgParam->rateMode, p_NonPassthroughAlgParam->comittedInfoRate, timeStampPeriod, *fpp);
- //           tempPir_Eir = Rate2Sample(p_NonPassthroughAlgParam->rateMode, p_NonPassthroughAlgParam->peakOrAccessiveInfoRate, timeStampPeriod, *fpp);
-    }
 
-    tempCir     = Rate2Sample(p_NonPassthroughAlgParam->rateMode, p_NonPassthroughAlgParam->comittedInfoRate, timeStampPeriod, *fpp);
-    tempPir_Eir = Rate2Sample(p_NonPassthroughAlgParam->rateMode, p_NonPassthroughAlgParam->peakOrAccessiveInfoRate , timeStampPeriod, *fpp);
+    /*
+     * This means that the FM TS register will now be used so that 'count' bits are for
+     * fraction and the rest for integer */
+    /* now we re-calculate cir */
+    GetInfoRateReg(p_NonPassthroughAlgParam->rateMode, p_NonPassthroughAlgParam->comittedInfoRate, tsuInTenthNanos, fppShift, &integer, &fraction);
+    *cir = (uint32_t)(integer << 16 | (fraction & 0xFFFF));
+    GetInfoRateReg(p_NonPassthroughAlgParam->rateMode, p_NonPassthroughAlgParam->peakOrAccessiveInfoRate, tsuInTenthNanos, fppShift, &integer, &fraction);
+    *pir_eir = (uint32_t)(integer << 16 | (fraction & 0xFFFF));
 
-    if (p_NonPassthroughAlgParam->rateMode == e_FM_PCD_PLCR_BYTE_MODE)
-    {
-        *cbs     = (1000 * p_NonPassthroughAlgParam->comittedBurstSize / 8);
-        *pbs_ebs = (1000 * p_NonPassthroughAlgParam->peakOrAccessiveBurstSize) / 8; /* 8=Bits->Bytes 1000=KB->B */
-    }
-    else
-    {
-        *cbs     =  p_NonPassthroughAlgParam->comittedBurstSize;
-        *pbs_ebs =  p_NonPassthroughAlgParam->peakOrAccessiveBurstSize;
-    }
+    *cbs     =  p_NonPassthroughAlgParam->comittedBurstSize;
+    *pbs_ebs =  p_NonPassthroughAlgParam->peakOrAccessiveBurstSize;
+
+    /* get fpp as it should be written to reg.*/
+    *fpp = FPP_Function(fppShift);
 
-    *cir     = (uint32_t)tempCir;
-    *pir_eir = (uint32_t)tempPir_Eir;
 }
 
 #ifndef CONFIG_GUEST_PARTITION
@@ -314,9 +313,9 @@ static void PcdPlcrException(t_Handle h_FmPcd)
     WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_evr, event);
 
     if(event & FM_PCD_PLCR_PRAM_SELF_INIT_COMPLETE)
-        p_FmPcd->f_FmPcdException(p_FmPcd->h_App,e_FM_PCD_PLCR_EXCEPTION_PRAM_SELF_INIT_COMPLETE);
+        p_FmPcd->f_Exception(p_FmPcd->h_App,e_FM_PCD_PLCR_EXCEPTION_PRAM_SELF_INIT_COMPLETE);
     if(event & FM_PCD_PLCR_ATOMIC_ACTION_COMPLETE)
-        p_FmPcd->f_FmPcdException(p_FmPcd->h_App,e_FM_PCD_PLCR_EXCEPTION_ATOMIC_ACTION_COMPLETE);
+        p_FmPcd->f_Exception(p_FmPcd->h_App,e_FM_PCD_PLCR_EXCEPTION_ATOMIC_ACTION_COMPLETE);
 
 }
 
@@ -339,7 +338,7 @@ static void PcdPlcrErrorException(t_Handle h_FmPcd)
     WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_eevr, event);
 
     if(event & FM_PCD_PLCR_DOUBLE_ECC)
-        p_FmPcd->f_FmPcdException(p_FmPcd->h_App,e_FM_PCD_PLCR_ERR_EXCEPTION_DOUBLE_ECC);
+        p_FmPcd->f_Exception(p_FmPcd->h_App,e_FM_PCD_PLCR_EXCEPTION_DOUBLE_ECC);
     if(event & FM_PCD_PLCR_INIT_ENTRY_ERROR)
     {
         captureReg = GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_upcr);
@@ -347,7 +346,7 @@ static void PcdPlcrErrorException(t_Handle h_FmPcd)
         p_UnInitCapt->profileNum = (uint8_t)(captureReg & PLCR_ERR_UNINIT_NUM_MASK);
         p_UnInitCapt->portId = (uint8_t)((captureReg & PLCR_ERR_UNINIT_PID_MASK) >>PLCR_ERR_UNINIT_PID_SHIFT) ;
         p_UnInitCapt->absolute = (bool)(captureReg & PLCR_ERR_UNINIT_ABSOLUTE_MASK);*/
-        p_FmPcd->f_FmPcdIndexedException(p_FmPcd->h_App,e_FM_PCD_PLCR_ERR_EXCEPTION_INIT_ENTRY_ERROR,(uint16_t)(captureReg & PLCR_ERR_UNINIT_NUM_MASK));
+        p_FmPcd->f_FmPcdIndexedException(p_FmPcd->h_App,e_FM_PCD_PLCR_EXCEPTION_INIT_ENTRY_ERROR,(uint16_t)(captureReg & PLCR_ERR_UNINIT_NUM_MASK));
         WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_upcr, PLCR_ERR_UNINIT_CAP);
     }
 }
@@ -363,7 +362,6 @@ t_Error  FmPcdPlcrAllocProfiles(t_Handle h_FmPcd, uint8_t hardwarePortId, uint16
     t_Error                     err = E_OK;
     uint16_t                    base;
     uint16_t                    pcdPortId;
-    uint8_t                     portsTable[]        = PCD_PORTS_TABLE;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
 
@@ -381,13 +379,12 @@ t_Error  FmPcdPlcrAllocProfiles(t_Handle h_FmPcd, uint8_t hardwarePortId, uint16
         RETURN_ERROR(MAJOR, err,NO_MSG);
 #endif /* CONFIG_GUEST_PARTITION */
 
-    GET_FM_PCD_PORTID_FROM_GLOBAL_PORTID(pcdPortId, portsTable, hardwarePortId)
+    SET_FM_PCD_PORTID_FROM_GLOBAL_PORTID(pcdPortId, hardwarePortId);
 
     p_FmPcd->p_FmPcdPlcr->portsMapping[pcdPortId].numOfProfiles = numOfProfiles;
     p_FmPcd->p_FmPcdPlcr->portsMapping[pcdPortId].profilesBase = base;
 
     return E_OK;
-
 }
 
 t_Error  FmPcdPlcrFreeProfiles(t_Handle h_FmPcd, uint8_t hardwarePortId)
@@ -398,12 +395,10 @@ t_Error  FmPcdPlcrFreeProfiles(t_Handle h_FmPcd, uint8_t hardwarePortId)
 #endif /* CONFIG_GUEST_PARTITION */
     t_Error                     err = E_OK;
     uint16_t                    pcdPortId;
-    uint8_t                     portsTable[]        = PCD_PORTS_TABLE;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
 
-    GET_FM_PCD_PORTID_FROM_GLOBAL_PORTID(pcdPortId, portsTable, hardwarePortId)
-
+    SET_FM_PCD_PORTID_FROM_GLOBAL_PORTID(pcdPortId, hardwarePortId);
 
 #ifdef CONFIG_GUEST_PARTITION
     /* Alloc resources using IPC messaging */
@@ -662,6 +657,8 @@ t_Error FmPcdPlcrBuildProfile(t_Handle h_FmPcd, t_FmPcdPlcrProfileParams *p_Prof
         case    e_FM_PCD_PLCR_RFC_2698:
             /* Select algorithm MODE[ALG] = 01 */
             pemode |= FM_PCD_PLCR_PEMODE_ALG_RFC2698;
+            if (p_Profile->nonPassthroughAlgParams.comittedInfoRate > p_Profile->nonPassthroughAlgParams.peakOrAccessiveInfoRate)
+                RETURN_ERROR(MAJOR, E_INVALID_SELECTION, ("in RFC2698 Peak rate must be equal or larger than comittedInfoRate."));
             goto cont_rfc;
         case    e_FM_PCD_PLCR_RFC_4115:
             /* Select algorithm MODE[ALG] = 10 */
@@ -875,8 +872,7 @@ t_Error PlcrInit(t_FmPcd *p_FmPcd)
     tmpReg32 = 0;
     if(p_FmPcd->exceptions & FM_PCD_EX_PLCR_DOUBLE_ECC)
     {
-        if(!FmRamsEccIsExternalCtl(p_FmPcd->h_Fm))
-            FM_EnableRamsEcc(p_FmPcd->h_Fm);
+        FmEnableRamsEcc(p_FmPcd->h_Fm);
         tmpReg32 |= FM_PCD_PLCR_DOUBLE_ECC;
     }
     if(p_FmPcd->exceptions & FM_PCD_EX_PLCR_INIT_ENTRY_ERROR)
@@ -911,6 +907,31 @@ t_Error PlcrInit(t_FmPcd *p_FmPcd)
     return E_OK;
 }
 
+t_Error PlcrFree(t_FmPcd *p_FmPcd)
+{
+#ifdef CONFIG_GUEST_PARTITION
+    t_Error err;
+#endif /* CONFIG_GUEST_PARTITION */
+
+    FmUnregisterIntr(p_FmPcd->h_Fm, e_FM_MOD_PLCR, 0, e_FM_INTR_TYPE_ERR);
+    FmUnregisterIntr(p_FmPcd->h_Fm, e_FM_MOD_PLCR, 0, e_FM_INTR_TYPE_NORMAL);
+
+    if(p_FmPcd->p_FmPcdPlcr->numOfSharedProfiles)
+#ifdef CONFIG_GUEST_PARTITION
+    {
+        /* Alloc resources using IPC messaging */
+        ipcSharedPlcrParams.num = p_FmPcd->p_FmPcdPlcr->numOfSharedProfiles;
+        memcpy(ipcSharedPlcrParams.profilesIds,p_FmPcd->p_FmPcdPlcr->sharedProfilesIds, p_FmPcd->p_FmPcdPlcr->numOfSharedProfiles*sizeof(uint16_t));
+        err = XX_SendMessage(p_FmPcd->fmPcdModuleName, FM_PCD_FREE_SHARED_PROFILES, (uint8_t*)&ipcSharedPlcrParams, NULL, NULL);
+        if(err)
+            RETURN_ERROR(MAJOR, err,NO_MSG);
+    }
+#else /* master */
+        PlcrFreeSharedProfiles(p_FmPcd, p_FmPcd->p_FmPcdPlcr->numOfSharedProfiles, p_FmPcd->p_FmPcdPlcr->sharedProfilesIds);
+#endif /* CONFIG_GUEST_PARTITION */
+    return E_OK;
+}
+
 #ifndef CONFIG_GUEST_PARTITION
 t_Error PlcrEnable(t_FmPcd *p_FmPcd)
 {
@@ -920,6 +941,15 @@ t_Error PlcrEnable(t_FmPcd *p_FmPcd)
 
     return E_OK;
 }
+
+t_Error PlcrDisable(t_FmPcd *p_FmPcd)
+{
+    t_FmPcdPlcrRegs             *p_Regs = p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs;
+
+    WRITE_UINT32(p_Regs->fmpl_gcr, GET_UINT32(p_Regs->fmpl_gcr) & ~FM_PCD_PLCR_GCR_EN);
+
+    return E_OK;
+}
 #endif /* CONFIG_GUEST_PARTITION */
 
 t_Error FmPcdPlcrGetAbsoluteProfileId(t_Handle h_FmPcd,
@@ -963,9 +993,8 @@ uint16_t FmPcdPlcrGetPortProfilesBase(t_Handle h_FmPcd, uint8_t hardwarePortId)
 {
     t_FmPcd         *p_FmPcd = (t_FmPcd *)h_FmPcd;
     uint16_t        pcdPortId;
-    uint8_t         portsTable[] = PCD_PORTS_TABLE;
 
-    GET_FM_PCD_PORTID_FROM_GLOBAL_PORTID(pcdPortId, portsTable, hardwarePortId)
+    SET_FM_PCD_PORTID_FROM_GLOBAL_PORTID(pcdPortId, hardwarePortId);
 
     return p_FmPcd->p_FmPcdPlcr->portsMapping[pcdPortId].profilesBase;
 }
@@ -974,9 +1003,8 @@ uint16_t FmPcdPlcrGetPortNumOfProfiles(t_Handle h_FmPcd, uint8_t hardwarePortId)
 {
     t_FmPcd         *p_FmPcd = (t_FmPcd *)h_FmPcd;
     uint16_t        pcdPortId;
-    uint8_t         portsTable[] = PCD_PORTS_TABLE;
 
-    GET_FM_PCD_PORTID_FROM_GLOBAL_PORTID(pcdPortId, portsTable, hardwarePortId)
+    SET_FM_PCD_PORTID_FROM_GLOBAL_PORTID(pcdPortId, hardwarePortId);
 
     return p_FmPcd->p_FmPcdPlcr->portsMapping[pcdPortId].numOfProfiles;
 
@@ -1080,6 +1108,11 @@ t_Handle FM_PCD_PlcrSetProfile(t_Handle     h_FmPcd,
     if (p_Profile->modify)
     {
         absoluteProfileId = (uint16_t)(CAST_POINTER_TO_UINT32(p_Profile->id.h_Profile)-1);
+        if (absoluteProfileId > FM_PCD_PLCR_NUM_ENTRIES)
+        {
+            REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("profileId too Big "));
+            return NULL;
+        }
         TRY_LOCK_RET_NULL(p_FmPcd->p_FmPcdPlcr->profiles[absoluteProfileId].lock);
     }
     else
@@ -1090,6 +1123,11 @@ t_Handle FM_PCD_PlcrSetProfile(t_Handle     h_FmPcd,
                                             p_Profile->id.newParams.h_FmPort,
                                             p_Profile->id.newParams.relativeProfileId,
                                             &absoluteProfileId);
+        if (absoluteProfileId > FM_PCD_PLCR_NUM_ENTRIES)
+        {
+            REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("profileId too Big "));
+            return NULL;
+        }
         if(err)
         {
             RELEASE_LOCK(p_FmPcd->lock);
@@ -1101,12 +1139,6 @@ t_Handle FM_PCD_PlcrSetProfile(t_Handle     h_FmPcd,
         RELEASE_LOCK(p_FmPcd->lock);
     }
 
-    if (absoluteProfileId > FM_PCD_PLCR_NUM_ENTRIES)
-    {
-        REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("profileId too Big "));
-        return NULL;
-    }
-
     /* if no override, check first that this scheme is unused */
     if(!p_Profile->modify)
     {
@@ -1372,9 +1404,7 @@ t_Error FM_PCD_ConfigPlcrAutoRefreshMode(t_Handle h_FmPcd, bool enable)
 t_Error FM_PCD_PlcrDumpRegs(t_Handle h_FmPcd)
 {
     t_FmPcd                             *p_FmPcd = (t_FmPcd*)h_FmPcd;
-    t_FmPcdPlcrInterModuleProfileRegs   *p_ProfilesRegs;
     int                                 i = 0;
-    uint32_t                            tmpReg;
 
     DECLARE_DUMP;
 
@@ -1400,33 +1430,6 @@ t_Error FM_PCD_PlcrDumpRegs(t_Handle h_FmPcd)
     DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_tpcnt);
     DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_flmcnt);
 
-    p_ProfilesRegs = &p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->profileRegs;
-
-    for(i = 0;i<FM_PCD_PLCR_NUM_ENTRIES; i++)
-    {
-        tmpReg = FmPcdPlcrBuildReadPlcrActionReg((uint16_t)i);
-        WritePar(p_FmPcd, tmpReg);
-
-        DUMP_TITLE(p_ProfilesRegs, ("Profile %d regs", i));
-
-        DUMP_VAR(p_ProfilesRegs, fmpl_pemode);
-        DUMP_VAR(p_ProfilesRegs, fmpl_pegnia);
-        DUMP_VAR(p_ProfilesRegs, fmpl_peynia);
-        DUMP_VAR(p_ProfilesRegs, fmpl_pernia);
-        DUMP_VAR(p_ProfilesRegs, fmpl_pecir);
-        DUMP_VAR(p_ProfilesRegs, fmpl_pecbs);
-        DUMP_VAR(p_ProfilesRegs, fmpl_pepepir_eir);
-        DUMP_VAR(p_ProfilesRegs, fmpl_pepbs_ebs);
-        DUMP_VAR(p_ProfilesRegs, fmpl_pelts);
-        DUMP_VAR(p_ProfilesRegs, fmpl_pects);
-        DUMP_VAR(p_ProfilesRegs, fmpl_pepts_ets);
-        DUMP_VAR(p_ProfilesRegs, fmpl_pegpc);
-        DUMP_VAR(p_ProfilesRegs, fmpl_peypc);
-        DUMP_VAR(p_ProfilesRegs, fmpl_perpc);
-        DUMP_VAR(p_ProfilesRegs, fmpl_perypc);
-        DUMP_VAR(p_ProfilesRegs, fmpl_perrpc);
-    }
-
     DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_serc);
     DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_upcr);
     DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_dpmr);
@@ -1440,6 +1443,48 @@ t_Error FM_PCD_PlcrDumpRegs(t_Handle h_FmPcd)
 
     return E_OK;
 }
+t_Error FM_PCD_PlcrProfileDumpRegs(t_Handle h_FmPcd, t_Handle h_Profile)
+{
+    t_FmPcd                             *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    t_FmPcdPlcrInterModuleProfileRegs   *p_ProfilesRegs;
+    uint32_t                            tmpReg;
+    uint16_t                            profileIndx = (uint16_t)(CAST_POINTER_TO_UINT32(h_Profile)-1);
+
+    DECLARE_DUMP;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdPlcr, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE);
+
+    DUMP_SUBTITLE(("\n"));
+    DUMP_TITLE(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs, ("FmPcdPlcrRegs Profile Regs"));
+
+    p_ProfilesRegs = &p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->profileRegs;
+
+    tmpReg = FmPcdPlcrBuildReadPlcrActionReg((uint16_t)profileIndx);
+    WritePar(p_FmPcd, tmpReg);
+
+    DUMP_TITLE(p_ProfilesRegs, ("Profile %d regs", profileIndx));
+
+    DUMP_VAR(p_ProfilesRegs, fmpl_pemode);
+    DUMP_VAR(p_ProfilesRegs, fmpl_pegnia);
+    DUMP_VAR(p_ProfilesRegs, fmpl_peynia);
+    DUMP_VAR(p_ProfilesRegs, fmpl_pernia);
+    DUMP_VAR(p_ProfilesRegs, fmpl_pecir);
+    DUMP_VAR(p_ProfilesRegs, fmpl_pecbs);
+    DUMP_VAR(p_ProfilesRegs, fmpl_pepepir_eir);
+    DUMP_VAR(p_ProfilesRegs, fmpl_pepbs_ebs);
+    DUMP_VAR(p_ProfilesRegs, fmpl_pelts);
+    DUMP_VAR(p_ProfilesRegs, fmpl_pects);
+    DUMP_VAR(p_ProfilesRegs, fmpl_pepts_ets);
+    DUMP_VAR(p_ProfilesRegs, fmpl_pegpc);
+    DUMP_VAR(p_ProfilesRegs, fmpl_peypc);
+    DUMP_VAR(p_ProfilesRegs, fmpl_perpc);
+    DUMP_VAR(p_ProfilesRegs, fmpl_perypc);
+    DUMP_VAR(p_ProfilesRegs, fmpl_perrpc);
+
+    return E_OK;
+}
 #endif /* (defined(DEBUG_ERRORS) && ... */
 #endif /* ! CONFIG_GUEST_PARTITION */
 
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.c b/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.c
index 7e96bd2..ce70bba 100644
--- a/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.c
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -96,12 +96,12 @@ static void PcdPrsErrorException(t_Handle h_FmPcd)
     DBG(TRACE, ("parser error - 0x%08x\n",event));
 
     if(event & FM_PCD_PRS_DOUBLE_ECC)
-        p_FmPcd->f_FmPcdException(p_FmPcd->h_App,e_FM_PCD_PRS_EXCEPTION_DOUBLE_ECC);
+        p_FmPcd->f_Exception(p_FmPcd->h_App,e_FM_PCD_PRS_EXCEPTION_DOUBLE_ECC);
     if(event & FM_PCD_PRS_ILLEGAL_ACCESS)
-        p_FmPcd->f_FmPcdException(p_FmPcd->h_App,e_FM_PCD_PRS_EXCEPTION_ILLEGAL_ACCESS);
+        p_FmPcd->f_Exception(p_FmPcd->h_App,e_FM_PCD_PRS_EXCEPTION_ILLEGAL_ACCESS);
     if(event & FM_PCD_PRS_PORT_ILLEGAL_ACCESS)
 /* TODO - change to indexed? how? */
-        p_FmPcd->f_FmPcdException(p_FmPcd->h_App,e_FM_PCD_PRS_EXCEPTION_PORT_ILLEGAL_ACCESS);
+        p_FmPcd->f_Exception(p_FmPcd->h_App,e_FM_PCD_PRS_EXCEPTION_PORT_ILLEGAL_ACCESS);
 }
 
 static void PcdPrsException(t_Handle h_FmPcd)
@@ -121,7 +121,7 @@ static void PcdPrsException(t_Handle h_FmPcd)
 
     WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->pevr, event);
 
-    p_FmPcd->f_FmPcdException(p_FmPcd->h_App,e_FM_PCD_PRS_EXCEPTION_SINGLE_ECC);
+    p_FmPcd->f_Exception(p_FmPcd->h_App,e_FM_PCD_PRS_EXCEPTION_SINGLE_ECC);
 }
 
 static uint32_t GetSwPrsOffset(t_Handle h_FmPcd,  e_NetHeaderType hdr, uint8_t  indexPerHdr)
@@ -149,31 +149,26 @@ t_Error PrsInit(t_FmPcd *p_FmPcd)
     t_FmPcdDriverParam  *p_Param = p_FmPcd->p_FmPcdDriverParam;
     t_FmPcdPrsRegs      *p_Regs = p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs;
     uint32_t            i, j, tmpReg;
-#ifdef FM_PRS_MEM_ERRATA
-    uint32_t            regsToGlobalOffset = 0x840;
-    uint32_t            firstPortToGlobalOffset = 0x45800;
-    uint32_t            globalAddr = (uint32_t)p_Regs - regsToGlobalOffset;
-    uint32_t            firstPortAddr = globalAddr - firstPortToGlobalOffset;
-    uint32_t            portSize = 0x1000;
-#endif   /* FM_PRS_MEM_ERRATA */
-    uint8_t             swPrsL4Patch[] = SW_PRS_L4_PATCH;
 
 #ifdef FM_PRS_MEM_ERRATA
-    /* clear all parser memory */
-    for(i = 0;i<0x1000;i+=4)
-        WRITE_UINT32(*(uint32_t*)(globalAddr+i), 0x00000000);
-    for(i = 0;i<16;i++)
     {
-        for(j = 0;j<0x3F8;j+=4)
-            WRITE_UINT32(*(uint32_t*)(firstPortAddr+i*portSize+j), 0x00000000);
-        /* disable all ports parser*/
-        WRITE_UINT32(*(uint32_t*)(firstPortAddr+i*portSize+0x3F8), 0x00000001);
-        /* wait for parser to be in idle state */
-        while(GET_UINT32(*(uint32_t*)(firstPortAddr+i*portSize+0x3F8)) & 0x00000100) ;
-/* TODO - ask Liat */
-        WRITE_UINT32(*(uint32_t*)(firstPortAddr+i*portSize+0x3FC), 0x91009100);
+        uint32_t            regsToGlobalOffset = 0x840;
+        uint32_t            firstPortToGlobalOffset = 0x45800;
+        uint32_t            globalAddr = (uint32_t)p_Regs - regsToGlobalOffset;
+        uint32_t            firstPortAddr = globalAddr - firstPortToGlobalOffset;
+        uint32_t            portSize = 0x1000;
+        t_FmRevisionInfo revInfo;
+
+        FmGetRevision(p_FmPcd->h_Fm, &revInfo);
+        if ((revInfo.majorRev == 1) && (revInfo.minorRev == 0))
+        {
+            /* clear all parser memory */
+            IOMemSet32((uint8_t*)globalAddr, 0x00000000, 0x800);
+            for(i = 0;i<16;i++)
+                IOMemSet32((uint8_t*)(firstPortAddr+i*portSize), 0x00000000, 0x80);
+        }
     }
-#endif   /* FM_PRS_MEM_ERRATA */
+#endif /* FM_PRS_MEM_ERRATA */
 
     /**********************RPCLIM******************/
     WRITE_UINT32(p_Regs->rpclim, (uint32_t)p_Param->prsMaxParseCycleLimit);
@@ -192,8 +187,7 @@ t_Error PrsInit(t_FmPcd *p_FmPcd)
     /**********************PEVER******************/
     if(p_FmPcd->exceptions & FM_PCD_EX_PRS_SINGLE_ECC)
     {
-        if(!FmRamsEccIsExternalCtl(p_FmPcd->h_Fm))
-            FM_EnableRamsEcc(p_FmPcd->h_Fm);
+        FmEnableRamsEcc(p_FmPcd->h_Fm);
         WRITE_UINT32(p_Regs->pever, FM_PCD_PRS_SINGLE_ECC);
     }
     else
@@ -210,7 +204,7 @@ t_Error PrsInit(t_FmPcd *p_FmPcd)
     tmpReg = 0;
     if(p_FmPcd->exceptions & FM_PCD_EX_PRS_DOUBLE_ECC)
     {
-        FM_EnableRamsEcc(p_FmPcd->h_Fm);
+        FmEnableRamsEcc(p_FmPcd->h_Fm);
         tmpReg |= FM_PCD_PRS_DOUBLE_ECC;
     }
     if(p_FmPcd->exceptions & FM_PCD_EX_PRS_ILLEGAL_ACCESS)
@@ -224,23 +218,43 @@ t_Error PrsInit(t_FmPcd *p_FmPcd)
     WRITE_UINT32(p_Regs->ppsc, p_FmPcd->p_FmPcdPrs->fmPcdPrsPortIdStatistics);
     /**********************PPCS******************/
 
-    /* load sw parser L4 patch */
-    for(i=0;i<sizeof(swPrsL4Patch)/4;i++)
+#ifdef FM_PRS_L4_SHELL_ERRATA
     {
-       tmpReg = 0;
-       for(j =0;j<4;j++)
-       {
-          tmpReg <<= 8;
-          tmpReg |= swPrsL4Patch[i*4+j];
-
-       }
-        WRITE_UINT32(*(p_FmPcd->p_FmPcdPrs->p_SwPrsCode+ PRS_SW_OFFSET/4 + i), tmpReg);
+        t_FmRevisionInfo    revInfo;
+        uint8_t             swPrsL4Patch[] = SW_PRS_L4_PATCH;
+
+        FmGetRevision(p_FmPcd->h_Fm, &revInfo);
+        if ((revInfo.majorRev == 1) && (revInfo.minorRev == 0))
+        {
+            /* load sw parser L4 patch */
+            for(i=0;i<sizeof(swPrsL4Patch)/4;i++)
+            {
+               tmpReg = 0;
+               for(j =0;j<4;j++)
+               {
+                  tmpReg <<= 8;
+                  tmpReg |= swPrsL4Patch[i*4+j];
+
+               }
+                WRITE_UINT32(*(p_FmPcd->p_FmPcdPrs->p_SwPrsCode+ FM_PCD_PRS_SW_OFFSET/4 + i), tmpReg);
+            }
+            p_FmPcd->p_FmPcdPrs->p_CurrSwPrs = FM_PCD_PRS_SW_OFFSET/4 + p_FmPcd->p_FmPcdPrs->p_SwPrsCode+sizeof(swPrsL4Patch)/4;
+        }
     }
-    p_FmPcd->p_FmPcdPrs->p_CurrSwPrs = PRS_SW_OFFSET/4 + p_FmPcd->p_FmPcdPrs->p_SwPrsCode+sizeof(swPrsL4Patch)/4;
-    p_FmPcd->p_FmPcdPrs->currLabel = 0;
+#endif /* FM_PRS_L4_SHELL_ERRATA */
+
     return E_OK;
 }
 
+#ifndef CONFIG_GUEST_PARTITION
+
+void PrsFree(t_FmPcd *p_FmPcd )
+{
+    FmUnregisterIntr(p_FmPcd->h_Fm, e_FM_MOD_PRS, 0, e_FM_INTR_TYPE_ERR);
+    /* register even if no interrupts enabled, to allow future enablement */
+    FmUnregisterIntr(p_FmPcd->h_Fm, e_FM_MOD_PRS, 0, e_FM_INTR_TYPE_NORMAL);
+}
+
 t_Error PrsEnable(t_FmPcd *p_FmPcd )
 {
     t_FmPcdPrsRegs      *p_Regs = p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs;
@@ -250,7 +264,16 @@ t_Error PrsEnable(t_FmPcd *p_FmPcd )
     return E_OK;
 }
 
+t_Error PrsDisable(t_FmPcd *p_FmPcd )
+{
+    t_FmPcdPrsRegs      *p_Regs = p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs;
+
+    WRITE_UINT32(p_Regs->rpimac, GET_UINT32(p_Regs->rpimac) & ~FM_PCD_PRS_RPIMAC_EN);
 
+    return E_OK;
+}
+
+#endif /* CONFIG_GUEST_PARTITION */
 
 #ifndef CONFIG_MULTI_PARTITION_SUPPORT
 void FmPcdPrsIncludePortInStatistics(t_Handle h_FmPcd, uint8_t hardwarePortId, bool include)
@@ -296,7 +319,7 @@ uint32_t FmPcdGetSwPrsOffset(t_Handle h_FmPcd, e_NetHeaderType hdr, uint8_t inde
 }
 
 #ifndef CONFIG_GUEST_PARTITION
-void FM_PCD_PrsStatistics(t_Handle h_FmPcd, bool enable)
+void FM_PCD_SetPrsStatistics(t_Handle h_FmPcd, bool enable)
 {
     t_FmPcd             *p_FmPcd = (t_FmPcd*)h_FmPcd;
 
@@ -320,14 +343,14 @@ t_Error FM_PCD_PrsLoadSw(t_Handle h_FmPcd, t_FmPcdPrsSwParams *p_SwPrs)
     SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE);
     SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdPrs, E_INVALID_STATE);
     SANITY_CHECK_RETURN_ERROR(p_SwPrs, E_INVALID_HANDLE);
-
+    SANITY_CHECK_RETURN_ERROR(!p_FmPcd->enabled, E_INVALID_HANDLE);
 
     if(!p_SwPrs->override)
     {
         if(p_FmPcd->p_FmPcdPrs->p_CurrSwPrs > p_FmPcd->p_FmPcdPrs->p_SwPrsCode + p_SwPrs->base*2/4)
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("SW parser base must be larger than current loaded code"));
     }
-    if(p_SwPrs->size > FM_SW_PRS_SIZE - PRS_SW_TAIL_SIZE - p_SwPrs->base*2)
+    if(p_SwPrs->size > FM_PCD_SW_PRS_SIZE - FM_PCD_PRS_SW_TAIL_SIZE - p_SwPrs->base*2)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("p_SwPrs->size may not be larger than MAX_SW_PRS_CODE_SIZE"));
     if(p_SwPrs->size % 4)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("p_SwPrs->size must be divisible by 4"));
@@ -340,7 +363,7 @@ t_Error FM_PCD_PrsLoadSw(t_Handle h_FmPcd, t_FmPcdPrsSwParams *p_SwPrs)
     memcpy(&p_FmPcd->p_FmPcdPrs->labelsTable[p_FmPcd->p_FmPcdPrs->currLabel], p_SwPrs->labelsTable, p_SwPrs->numOfLabels*sizeof(t_FmPcdPrsLabelParams));
     p_FmPcd->p_FmPcdPrs->currLabel += p_SwPrs->numOfLabels;
     /* load sw parser code */
-    p_LoadTarget = p_FmPcd->p_FmPcdPrs->p_SwPrsCode + p_SwPrs->base*2/4;//+ PRS_SW_OFFSET/4 + sizeof(swPrsL4Patch)/4;
+    p_LoadTarget = p_FmPcd->p_FmPcdPrs->p_SwPrsCode + p_SwPrs->base*2/4;//+ FM_PCD_PRS_SW_OFFSET/4 + sizeof(swPrsL4Patch)/4;
     for(i=0;i<p_SwPrs->size/4;i++)
     {
         tmpReg = 0;
@@ -359,7 +382,7 @@ t_Error FM_PCD_PrsLoadSw(t_Handle h_FmPcd, t_FmPcdPrsSwParams *p_SwPrs)
 
 
     /* Clear last 4 bytes */
-    WRITE_UINT32(*(p_FmPcd->p_FmPcdPrs->p_SwPrsCode+(PRS_SW_DATA-PRS_SW_TAIL_SIZE)/4), 0);
+    WRITE_UINT32(*(p_FmPcd->p_FmPcdPrs->p_SwPrsCode+(PRS_SW_DATA-FM_PCD_PRS_SW_TAIL_SIZE)/4), 0);
 
     return E_OK;
 }
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/Port/fm_port.c b/drivers/net/dpa/NetCommSw/Peripherals/FM/Port/fm_port.c
index 0142d26..85cc815 100644
--- a/drivers/net/dpa/NetCommSw/Peripherals/FM/Port/fm_port.c
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/Port/fm_port.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -74,12 +74,12 @@ static t_Error CheckInitParameters(t_FmPort *p_FmPort)
                  RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("rxExtBufPools.numOfPoolsUsed=0. At least one buffer pool must be defined"));
 
             if(p_Params->rxExtBufPools.numOfPoolsUsed > FM_PORT_MAX_NUM_OF_EXT_POOLS)
-                    RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("numOfPoolsUsed can't be larger than %d", MAX_NUM_OF_EXT_POOLS));
+                    RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("numOfPoolsUsed can't be larger than %d", BM_MAX_NUM_OF_EXT_POOLS));
 
             for(i=0;i<p_Params->rxExtBufPools.numOfPoolsUsed;i++)
             {
-                if(p_Params->rxExtBufPools.rxExtBufPool[i].id >= MAX_NUM_OF_EXT_POOLS)
-                    RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("rxExtBufPools.rxExtBufPool[i].id can't be larger than %d", MAX_NUM_OF_EXT_POOLS));
+                if(p_Params->rxExtBufPools.rxExtBufPool[i].id >= BM_MAX_NUM_OF_EXT_POOLS)
+                    RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("rxExtBufPools.rxExtBufPool[i].id can't be larger than %d", BM_MAX_NUM_OF_EXT_POOLS));
                 if(!p_Params->rxExtBufPools.rxExtBufPool[i].size)
                     RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("rxExtBufPools.rxExtBufPool[i].size is 0"));
             }
@@ -92,8 +92,22 @@ static t_Error CheckInitParameters(t_FmPort *p_FmPort)
             if(p_Params->intContext.size + p_Params->intContext.extBufOffset > p_Params->bufMargins.startMargins)
                 RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("intContext.size is larger than start margins"));
 
-            if(p_Params->partitionId >= FM_MAX_NUM_OF_PARTITIONS)
-                 RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("partitionId can't be larger than %d", FM_MAX_NUM_OF_PARTITIONS-1));
+            {
+                t_FmRevisionInfo revInfo;
+                FmGetRevision(p_FmPort->h_Fm, &revInfo);
+                if ((revInfo.majorRev == 1) && (revInfo.minorRev == 0))
+                {
+                    if(p_Params->partitionId >= FM_MAX_NUM_OF_PARTITIONS)
+                    {
+                        p_Params->partitionId = (uint16_t)(p_Params->partitionId & (FM_MAX_NUM_OF_PARTITIONS-1));
+                        DBG(WARNING, ("partitionId number is out of rev1 range - MSB bits cleard."));
+                    }
+                }
+                else
+                    if ((revInfo.majorRev == 2) && (revInfo.minorRev == 0))
+                        if(p_Params->partitionId & ~FM_LIODN_OFFSET_MASK)
+                            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("partitionId is larger than %d", FM_LIODN_OFFSET_MASK+1));
+            }
         }
 
         /****************************************/
@@ -112,7 +126,7 @@ static t_Error CheckInitParameters(t_FmPort *p_FmPort)
         /****************************************/
         /*   Rx Or Offline Parsing              */
         /****************************************/
-        if((p_FmPort->portType == e_FM_PORT_TYPE_RX) || (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G) || (p_FmPort->portType == e_FM_PORT_TYPE_OFFLINE_PARSING))
+        if((p_FmPort->portType == e_FM_PORT_TYPE_RX) || (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G) || (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING))
             if(!p_Params->dfltFqid)
                  RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dfltFqid must be between 1 and 2^24-1"));
 
@@ -216,9 +230,9 @@ static t_Error CheckInitParameters(t_FmPort *p_FmPort)
     /*   Rx and Offline parsing             */
     /****************************************/
     if((p_FmPort->portType == e_FM_PORT_TYPE_RX) || (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G)
-        || (p_FmPort->portType == e_FM_PORT_TYPE_OFFLINE_PARSING))
+        || (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING))
     {
-        if(p_FmPort->portType == e_FM_PORT_TYPE_OFFLINE_PARSING)
+        if(p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
             unusedMask = BMI_STATUS_OP_MASK_UNUSED;
         else
             unusedMask = BMI_STATUS_RX_MASK_UNUSED;
@@ -286,11 +300,13 @@ static t_Error BmiRxPortInit(t_FmPort *p_FmPort)
     int                     i=0, j=0, k=0;
     bool                    found;
     uint8_t                 orderedArray[FM_PORT_MAX_NUM_OF_EXT_POOLS];
-    uint16_t                sizesArray[MAX_NUM_OF_EXT_POOLS];
+    uint16_t                sizesArray[BM_MAX_NUM_OF_EXT_POOLS];
     uint8_t                 count = 0;
+    t_FmPortPerformanceCnt  performanceContersParams;
+    t_Error                 err;
 
     memset(&orderedArray, 0, sizeof(uint8_t) * FM_PORT_MAX_NUM_OF_EXT_POOLS);
-    memset(&sizesArray, 0, sizeof(uint16_t) * MAX_NUM_OF_EXT_POOLS);
+    memset(&sizesArray, 0, sizeof(uint16_t) * BM_MAX_NUM_OF_EXT_POOLS);
 
     /* check that port is not busy */
     if (GET_UINT32(p_Regs->fmbm_rcfg) & BMI_PORT_CFG_EN)
@@ -365,7 +381,7 @@ static t_Error BmiRxPortInit(t_FmPort *p_FmPort)
             found = FALSE;
             vector = 0;
             count = 0;
-            for(i=0;i<MAX_NUM_OF_EXT_POOLS;i++)
+            for(i=0;i<BM_MAX_NUM_OF_EXT_POOLS;i++)
             {
                 if(p_Params->bufPoolDepletion.poolsToConsider[i])
                 {
@@ -399,7 +415,7 @@ static t_Error BmiRxPortInit(t_FmPort *p_FmPort)
             found = FALSE;
             vector = 0;
             count = 0;
-            for(i=0;i<MAX_NUM_OF_EXT_POOLS;i++)
+            for(i=0;i<BM_MAX_NUM_OF_EXT_POOLS;i++)
             {
                 if(p_Params->bufPoolDepletion.poolsToConsiderForSingleMode[i])
                 {
@@ -435,8 +451,6 @@ static t_Error BmiRxPortInit(t_FmPort *p_FmPort)
     tmpReg |= p_Params->dmaIntContextCacheAttr << BMI_DMA_ATTR_IC_CACHE_SHIFT;
     tmpReg |= p_Params->dmaHeaderCacheAttr << BMI_DMA_ATTR_HDR_CACHE_SHIFT;
     tmpReg |= p_Params->dmaScatterGatherCacheAttr << BMI_DMA_ATTR_SG_CACHE_SHIFT;
-    if(p_Params->dmaReadOptimize)
-        tmpReg |= BMI_DMA_ATTR_READ_OPTIMIZE;
     if(p_Params->dmaWriteOptimize)
         tmpReg |= BMI_DMA_ATTR_WRITE_OPTIMIZE;
 
@@ -471,7 +485,7 @@ static t_Error BmiRxPortInit(t_FmPort *p_FmPort)
         if(p_Params->bufMargins.startMargins + MIN_EXT_BUF_SIZE + p_Params->bufMargins.endMargins >
                 sizesArray[orderedArray[p_Params->rxExtBufPools.numOfPoolsUsed-1]])
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("bufMargins.startMargins (%d) + minimum buf size (64) + bufMargins.endMargins (%d) is larger than maximum external buffer size (%d)",
-                            p_Params->bufMargins.startMargins, p_Params->bufMargins.endMargins, sizesArray[orderedArray[p_Params->rxExtBufPools.numOfPoolsUsed]]));
+                            p_Params->bufMargins.startMargins, p_Params->bufMargins.endMargins, sizesArray[orderedArray[p_Params->rxExtBufPools.numOfPoolsUsed-1]]));
 
         /* buffer margins */
         tmpReg = 0;
@@ -507,7 +521,7 @@ static t_Error BmiRxPortInit(t_FmPort *p_FmPort)
     {
         tmpReg |= BMI_CMD_ATTR_ORDER;
         if(p_Params->syncReq)
-            tmpReg |= BMI_CMD_ATTR_SYNC ;
+            tmpReg |= BMI_CMD_ATTR_SYNC;
         tmpReg |= (p_Params->color << BMI_CMD_ATTR_COLOR_SHIFT);
     }
 
@@ -519,8 +533,19 @@ static t_Error BmiRxPortInit(t_FmPort *p_FmPort)
         WRITE_UINT32(p_Regs->fmbm_rfqid, p_Params->dfltFqid);
         WRITE_UINT32(p_Regs->fmbm_refqid, p_Params->errFqid);
     }
+
+    /* set counters */
     WRITE_UINT32(p_Regs->fmbm_rstc, BMI_COUNTERS_EN);
-    WRITE_UINT32(p_Regs->fmbm_rpc, 0); /* counters disabled, need parameters for enabling */
+
+    performanceContersParams.taskCompVal    = (uint8_t)p_Params->tasks.num;
+    performanceContersParams.queueCompVal   = 1;
+    performanceContersParams.dmaCompVal     =(uint8_t) p_Params->openDmas.num;
+    performanceContersParams.fifoCompVal    = p_Params->fifoBufs.num;
+    if((err = FM_PORT_SetPerformanceCountersParams(p_FmPort, &performanceContersParams)) != E_OK)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+
+
+    WRITE_UINT32(p_Regs->fmbm_rpc, BMI_COUNTERS_EN);
 
     /* error/status mask  - check that if discard OV is set, no
        discard is required for specific errors.*/
@@ -535,9 +560,10 @@ static t_Error BmiRxPortInit(t_FmPort *p_FmPort)
 static t_Error BmiTxPortInit(t_FmPort *p_FmPort)
 {
     t_FmPortTxBmiRegs   *p_Regs = &p_FmPort->p_FmPortBmiRegs->txPortBmiRegs;
-    uint32_t            tmpReg, prevPowerOf2, count=0, tmpRateLimitScale;
+    uint32_t            tmpReg, tmpRateLimitScale;
     t_FmPortDriverParam *p_Params = p_FmPort->p_FmPortDriverParam;
-    uint32_t            rateCountUnit, roundUp;
+    /*uint32_t            rateCountUnit;*/
+    t_FmPortPerformanceCnt  performanceContersParams;
 
     /* check that port is not busy */
     if (GET_UINT32(p_Regs->fmbm_tcfg) & BMI_PORT_CFG_EN)
@@ -555,10 +581,6 @@ static t_Error BmiTxPortInit(t_FmPort *p_FmPort)
     tmpReg |= p_Params->dmaIntContextCacheAttr << BMI_DMA_ATTR_IC_CACHE_SHIFT;
     tmpReg |= p_Params->dmaHeaderCacheAttr << BMI_DMA_ATTR_HDR_CACHE_SHIFT;
     tmpReg |= p_Params->dmaScatterGatherCacheAttr << BMI_DMA_ATTR_SG_CACHE_SHIFT;
-    if(p_Params->dmaReadOptimize)
-        tmpReg |= BMI_DMA_ATTR_READ_OPTIMIZE;
-    if(p_Params->dmaWriteOptimize)
-        tmpReg |= BMI_DMA_ATTR_WRITE_OPTIMIZE;
 
     WRITE_UINT32(p_Regs->fmbm_tda, tmpReg);
 
@@ -623,67 +645,45 @@ static t_Error BmiTxPortInit(t_FmPort *p_FmPort)
     /* rate limit */
     if(p_Params->enRateLimit)
     {
-        if (!p_Params->timeStampPeriod)
-            RETURN_ERROR(MAJOR, E_NOT_AVAILABLE, ("Rate limit requires timeStamp - not enabled."));
-
-        if(p_Params->rateLimit.rateLimit < 16*p_Params->timeStampPeriod)
-            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("rateLimit is too small, must be larger than 16*timeStampPeriod as initialized in main FM module"));
-
-        /* we want to use the largest possible trlmt[RLM]. So we want
-        the minimal rate count unit (as we write in trlmts[TSBS]).
-        rateCountUnit must be large enough to allow using the maximum
-        trlmt[RLM] (1023 representing 1024 * 16).
-        We want to round up this division */
+        /* normally, we use 1 usec as the reference count */
+        uint8_t     factor = 1, countUnitBit;
 
-        if (p_Params->rateLimit.rateLimit % (1024*16))
-            roundUp = 1;
-        else
-            roundUp = 0;
-        rateCountUnit = p_Params->rateLimit.rateLimit/(1024*16) + roundUp;
-        /* The basic unit may not be smaller than the timeStamp. */
-        if (rateCountUnit<p_Params->timeStampPeriod)
-            rateCountUnit = p_Params->timeStampPeriod;
-
-        /* we need to find the bit of timeStamp that is closest to rateCountUnit */
-        /* we find the previous power of 2, and the next one, than we see which is closer */
-        while(rateCountUnit > p_Params->timeStampPeriod*(1<<count))
-            count++;
-        if(count == 0)
-            tmpRateLimitScale = (31 - count) << BMI_COUNT_RATE_UNIT_SHIFT;
-        else
+        /* if ratelimit is too small for a 1usec factor, multiply the factor */
+        countUnitBit = p_Params->count1MicroBit;
+        while (p_Params->rateLimit.rateLimit < 16000/factor)
         {
-            prevPowerOf2 = (1<<(count-1))*p_Params->timeStampPeriod;
-            /* 'count' or 'count-1' is now the bit that represents the unit */
-            if((rateCountUnit - prevPowerOf2) < (2*prevPowerOf2 - rateCountUnit))
-            {
-                tmpRateLimitScale = (31 - (count-1)) << BMI_COUNT_RATE_UNIT_SHIFT;
-                /* in order to get precision in the following calculation,
-                we now use the closest available rateCountUnit */
-                rateCountUnit = prevPowerOf2;
-            }
-            else
-            {
-                tmpRateLimitScale = (31 - count) << BMI_COUNT_RATE_UNIT_SHIFT;
-                /* in order to get precision in the following calculation,
-                we now use the closest available rateCountUnit */
-                rateCountUnit = 2*prevPowerOf2;
-            }
+            if (countUnitBit==31)
+                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Rate limit is too small"));
+
+            countUnitBit++;
+            factor <<= 1;
         }
+        /* if ratelimit is too large for a 1usec factor, it is also larger than max rate*/
+        if (p_Params->rateLimit.rateLimit > 16384000*factor)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Rate limit is too large"));
+
+        tmpReg = (uint32_t)(p_Params->rateLimit.rateLimit*factor/16000 - 1);
 
-        tmpReg = (uint32_t)(p_Params->rateLimit.rateLimit/(16* rateCountUnit) - 1);
         if(!p_Params->rateLimit.maxBurstSize || (p_Params->rateLimit.maxBurstSize > MAX_BURST_SIZE))
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("maxBurstSize must be between 1K and %dk", MAX_BURST_SIZE));
 
         tmpReg |= (uint32_t)(p_Params->rateLimit.maxBurstSize - 1) << BMI_MAX_BURST_SHIFT;
         WRITE_UINT32(p_Regs->fmbm_trlmt, tmpReg);
 
-        tmpRateLimitScale |= BMI_RATE_LIMIT_EN;
+        tmpRateLimitScale = ((31 - countUnitBit) << BMI_COUNT_RATE_UNIT_SHIFT) | BMI_RATE_LIMIT_EN;
         WRITE_UINT32(p_Regs->fmbm_trlmts, tmpRateLimitScale);
     }
 
     /* statistics & performance counters */
     WRITE_UINT32(p_Regs->fmbm_tstc, BMI_COUNTERS_EN);
-    WRITE_UINT32(p_Regs->fmbm_tpc, 0); /* counters disabled, need parameters for enabling */
+
+    performanceContersParams.taskCompVal    = (uint8_t)p_Params->tasks.num;
+    performanceContersParams.queueCompVal   = 1;
+    performanceContersParams.dmaCompVal     = (uint8_t)p_Params->openDmas.num;
+    performanceContersParams.fifoCompVal    = p_Params->fifoBufs.num;
+    FM_PORT_SetPerformanceCountersParams(p_FmPort, &performanceContersParams);
+
+    WRITE_UINT32(p_Regs->fmbm_tpc, BMI_COUNTERS_EN);
 
     return E_OK;
 }
@@ -691,9 +691,10 @@ static t_Error BmiTxPortInit(t_FmPort *p_FmPort)
 static t_Error BmiOhPortInit(t_FmPort *p_FmPort)
 {
     t_FmPortOhBmiRegs   *p_Regs = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs;
-    uint32_t            tmpReg, prevPowerOf2, count=0, tmpRateLimitScale, errorsToEnq = 0;
+    uint32_t            tmpReg, tmpRateLimitScale, errorsToEnq = 0;
     t_FmPortDriverParam *p_Params = p_FmPort->p_FmPortDriverParam;
-    uint32_t            rateCountUnit, roundUp;
+    uint32_t            rateCountUnit;
+    t_FmPortPerformanceCnt  performanceContersParams;
 
     /* check that port is not busy */
     if (GET_UINT32(p_Regs->fmbm_ocfg) & BMI_PORT_CFG_EN)
@@ -705,8 +706,6 @@ static t_Error BmiOhPortInit(t_FmPort *p_FmPort)
     tmpReg |= p_Params->dmaIntContextCacheAttr << BMI_DMA_ATTR_IC_CACHE_SHIFT;
     tmpReg |= p_Params->dmaHeaderCacheAttr << BMI_DMA_ATTR_HDR_CACHE_SHIFT;
     tmpReg |= p_Params->dmaScatterGatherCacheAttr << BMI_DMA_ATTR_SG_CACHE_SHIFT;
-    if(p_Params->dmaReadOptimize)
-        tmpReg |= BMI_DMA_ATTR_READ_OPTIMIZE;
     if(p_Params->dmaWriteOptimize)
         tmpReg |= BMI_DMA_ATTR_WRITE_OPTIMIZE;
 
@@ -723,13 +722,13 @@ static t_Error BmiOhPortInit(t_FmPort *p_FmPort)
     /* NIA */
     WRITE_UINT32(p_Regs->fmbm_ofdne, NIA_ENG_QMI_DEQ);
 
-    if (p_FmPort->portType==e_FM_PORT_TYPE_HOST_COMMAND)
+    if (p_FmPort->portType==e_FM_PORT_TYPE_OH_HOST_COMMAND)
         WRITE_UINT32(p_Regs->fmbm_ofene, NIA_ENG_QMI_ENQ);
     else
         WRITE_UINT32(p_Regs->fmbm_ofene, NIA_ENG_QMI_ENQ | NIA_ORDER_RESTOR);
 
     /* command attribute */
-    if (p_FmPort->portType==e_FM_PORT_TYPE_HOST_COMMAND)
+    if (p_FmPort->portType==e_FM_PORT_TYPE_OH_HOST_COMMAND)
         tmpReg =  BMI_CMD_MR_DEAS | BMI_CMD_MR_MA;
     else
         tmpReg = BMI_CMD_ATTR_ORDER | BMI_CMD_MR_DEAS | BMI_CMD_MR_MA;
@@ -746,7 +745,7 @@ static t_Error BmiOhPortInit(t_FmPort *p_FmPort)
         tmpReg = 0;
     WRITE_UINT32(p_Regs->fmbm_ocfg, tmpReg);
 
-    if(p_FmPort->portType == e_FM_PORT_TYPE_OFFLINE_PARSING)
+    if(p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
     {
         WRITE_UINT32(p_Regs->fmbm_ofsdm, p_Params->errorsToDiscard);
 
@@ -759,58 +758,20 @@ static t_Error BmiOhPortInit(t_FmPort *p_FmPort)
         /* rate limit */
         if(p_Params->enRateLimit)
         {
-            if (!p_Params->timeStampPeriod)
-                RETURN_ERROR(MAJOR, E_NOT_AVAILABLE, ("Rate limit requires timeStamp - not enabled."));
-
-            if(p_Params->rateLimit.rateLimit < 10*p_Params->timeStampPeriod)
-                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("rateLimit is too small, must be larger than 10*timeStampPeriod as initialized in main FM module"));
+            /* normally, we use 1 usec as the reference count */
+            rateCountUnit = 1000;
+            /* TODO - if ratelimit is out of range, change rateCountUnit */
+            if(p_Params->rateLimit.rateLimit < 16000)
+                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("rateLimit is too small, must be larger than 16*timeStampPeriod as initialized in main FM module"));
 
-            /* we want to use the largest possible trlmt[RLM]. So we want
-            the minimal rate count unit (as we write in orlmts[TSBS]).
-            rateCountUnit must be large enough to allow using the maximum
-            orlmt[RLM] (1023 representing 1024 * 10).
-            We want to round up this division */
+            tmpReg = (uint32_t)(p_Params->rateLimit.rateLimit/16 * rateCountUnit - 1);
+            if(!p_Params->rateLimit.maxBurstSize || (p_Params->rateLimit.maxBurstSize > MAX_BURST_SIZE))
+                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("maxBurstSize must be between 1K and %dk", MAX_BURST_SIZE));
 
-            if (p_Params->rateLimit.rateLimit % (1024*10))
-                roundUp = 1;
-            else
-                roundUp = 0;
-            rateCountUnit = p_Params->rateLimit.rateLimit/(1024*10) + roundUp;
-            /* The basic unit may not be smaller than the timeStamp. */
-            if (rateCountUnit<p_Params->timeStampPeriod)
-                rateCountUnit = p_Params->timeStampPeriod;
-
-            /* we need to find the bit of timeStamp that is closest to rateCountUnit */
-            /* we find the previous power of 2, and the next one, than we see which is closer */
-            while(rateCountUnit > p_Params->timeStampPeriod*(1<<count))
-                count++;
-            if(count == 0)
-                tmpRateLimitScale = (31 - count) << BMI_COUNT_RATE_UNIT_SHIFT;
-            else
-            {
-                prevPowerOf2 = (1<<(count-1))*p_Params->timeStampPeriod;
-                /* 'count' or 'count-1' is now the bit that represents the unit */
-                if((rateCountUnit - prevPowerOf2) < (2*prevPowerOf2 - rateCountUnit))
-                {
-                    tmpRateLimitScale = (31 - (count-1)) << BMI_COUNT_RATE_UNIT_SHIFT;
-                    /* in order to get precision in the following calculation,
-                    we now use the closest available rateCountUnit */
-                    rateCountUnit = prevPowerOf2;
-                }
-                else
-                {
-                    tmpRateLimitScale = (31 - count) << BMI_COUNT_RATE_UNIT_SHIFT;
-                    /* in order to get precision in the following calculation,
-                    we now use the closest available rateCountUnit */
-                    rateCountUnit = 2*prevPowerOf2;
-                }
-            }
-
-            tmpReg = (uint32_t)(p_Params->rateLimit.rateLimit/(10* rateCountUnit) - 1);
             tmpReg |= (uint32_t)(p_Params->rateLimit.maxBurstSize - 1) << BMI_MAX_BURST_SHIFT;
             WRITE_UINT32(p_Regs->fmbm_orlmt, tmpReg);
 
-            tmpRateLimitScale |= BMI_RATE_LIMIT_EN;
+            tmpRateLimitScale = ((31 - p_Params->count1MicroBit - 1) << BMI_COUNT_RATE_UNIT_SHIFT) | BMI_RATE_LIMIT_EN;
             WRITE_UINT32(p_Regs->fmbm_orlmts, tmpRateLimitScale);
         }
     }
@@ -824,7 +785,14 @@ static t_Error BmiOhPortInit(t_FmPort *p_FmPort)
 
     /* statistics & performance counters */
     WRITE_UINT32(p_Regs->fmbm_ostc, BMI_COUNTERS_EN);
-    WRITE_UINT32(p_Regs->fmbm_opc, 0); /* counters disabled, need parameters for enabling */
+
+    performanceContersParams.taskCompVal    = (uint8_t)p_Params->tasks.num;
+    performanceContersParams.queueCompVal   = 0;
+    performanceContersParams.dmaCompVal     = (uint8_t)p_Params->openDmas.num;
+    performanceContersParams.fifoCompVal    = p_Params->fifoBufs.num;
+    FM_PORT_SetPerformanceCountersParams(p_FmPort, &performanceContersParams);
+
+    WRITE_UINT32(p_Regs->fmbm_opc, BMI_COUNTERS_EN);
 
     return E_OK;
 }
@@ -881,6 +849,7 @@ static t_Error QmiInit(t_FmPort *p_FmPort)
                 tmpReg |= QMI_DEQ_CFG_TYPE3;
                 break;
             default:
+                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid dequeue type"));
                 break;
         }
         switch(p_Params->deqPrefetchOption)
@@ -895,6 +864,7 @@ static t_Error QmiInit(t_FmPort *p_FmPort)
                 tmpReg |= QMI_DEQ_CFG_PREFETCH_NO_TNUM | QMI_DEQ_CFG_PREFETCH_3_FRAMES;
                 break;
             default:
+                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid dequeue prefetch option"));
                 break;
         }
         tmpReg |= p_Params->deqByteCnt;
@@ -982,8 +952,10 @@ static t_Error BmiRxPortCheckAndGetCounterPtr(t_FmPort *p_FmPort, e_FmPortCounte
             break;
         case(e_FM_PORT_COUNTERS_RX_OUT_OF_BUFFERS_DISCARD):
             *p_Ptr = &p_BmiRegs->fmbm_rodc;
+            break;
         case(e_FM_PORT_COUNTERS_DEALLOC_BUF):
             *p_Ptr = &p_BmiRegs->fmbm_rbdc;
+            break;
         default:
             RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter is not available for Rx ports"));
             break;
@@ -1052,6 +1024,7 @@ static t_Error BmiTxPortCheckAndGetCounterPtr(t_FmPort *p_FmPort, e_FmPortCounte
             break;
         case(e_FM_PORT_COUNTERS_DEALLOC_BUF):
             *p_Ptr = &p_BmiRegs->fmbm_tbdc;
+            break;
         default:
             RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter is not available for Tx ports"));
             break;
@@ -1060,7 +1033,6 @@ static t_Error BmiTxPortCheckAndGetCounterPtr(t_FmPort *p_FmPort, e_FmPortCounte
     return E_OK;
 }
 
-
 static t_Error BmiOhPortCheckAndGetCounterPtr(t_FmPort *p_FmPort, e_FmPortCounters counter, volatile uint32_t **p_Ptr)
 {
     t_FmPortOhBmiRegs   *p_BmiRegs = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs;
@@ -1086,8 +1058,8 @@ static t_Error BmiOhPortCheckAndGetCounterPtr(t_FmPort *p_FmPort, e_FmPortCounte
                RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter was not enabled"));
             break;
         case(e_FM_PORT_COUNTERS_RX_FILTER_FRAME): /* only valid for offline parsing */
-            if(p_FmPort->portType == e_FM_PORT_TYPE_HOST_COMMAND)
-                RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter is not available for O/H ports"));
+            if(p_FmPort->portType == e_FM_PORT_TYPE_OH_HOST_COMMAND)
+                RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter is not available for Host Command ports"));
             if(!(GET_UINT32(p_BmiRegs->fmbm_ostc) & BMI_COUNTERS_EN))
                RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter was not enabled"));
             break;
@@ -1134,6 +1106,7 @@ static t_Error BmiOhPortCheckAndGetCounterPtr(t_FmPort *p_FmPort, e_FmPortCounte
             break;
         case(e_FM_PORT_COUNTERS_DEALLOC_BUF):
             *p_Ptr = &p_BmiRegs->fmbm_obdc;
+            break;
         default:
             RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter is not available for O/H ports"));
             break;
@@ -1181,6 +1154,7 @@ static t_Error  AdditionalPrsParams(t_FmPort *p_FmPort, t_FmPcdPrsAdditionalHdrP
                 if(p_prsOpts->udpPrsOptions.padIgnoreChecksum)
                    tmpReg |= PRS_HDR_TCP_PAD_REMOVAL;
             default:
+                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid header"));
                 break;
         }
     }
@@ -1227,6 +1201,128 @@ static uint32_t GetPortSchemeBindParams(t_Handle h_FmPort, t_FmPcdKgInterModuleB
     return tmp;
 }
 
+static t_Error BuildBufferStructure(t_FmPort *p_FmPort)
+{
+    uint32_t                        tmp;
+
+    ASSERT_COND(p_FmPort);
+
+    /* Align start of internal context data to 16 byte */
+    p_FmPort->p_FmPortDriverParam->intContext.extBufOffset =
+        (uint16_t)((p_FmPort->p_FmPortDriverParam->bufferPrefixContent.privDataSize & (OFFSET_UNITS-1)) ?
+            ((p_FmPort->p_FmPortDriverParam->bufferPrefixContent.privDataSize + OFFSET_UNITS) & ~(uint16_t)(OFFSET_UNITS-1)) :
+             p_FmPort->p_FmPortDriverParam->bufferPrefixContent.privDataSize);
+
+    /* Translate margin and intContext params to FM parameters */
+    if (!POWER_OF_2(p_FmPort->p_FmPortDriverParam->bufferPrefixContent.dataAlign))
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("bufferPrefixContent.dataAlign must be a power of 2."));
+
+    /* Initialize with illegal value. Later we'll set legal values. */
+    p_FmPort->bufferOffsets.prsResultOffset = (uint32_t)ILLEGAL_BASE;
+    p_FmPort->bufferOffsets.timeStampOffset = (uint32_t)ILLEGAL_BASE;
+    p_FmPort->bufferOffsets.hashResultOffset= (uint32_t)ILLEGAL_BASE;
+    p_FmPort->bufferOffsets.pcdInfoOffset   = (uint32_t)ILLEGAL_BASE;
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+    p_FmPort->bufferOffsets.debugOffset     = (uint32_t)ILLEGAL_BASE;
+#endif /* (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0)) */
+
+    /* Internally the driver supports 4 options
+       1. prsResult/timestamp/hashResult selection (in fact 8 options, but for simplicity we'll
+          relate to it as 1).
+       2. All IC context (from AD) except debug.
+       3. Debug information only.
+       4. All IC context (from AD) including debug.
+       Note, that if user asks for prsResult/timestamp/hashResult and Debug, we give them (4) */
+
+    /* This 'if' covers options  2 & 4. We copy from beginning of context with or without debug. */
+    /* If passAllOtherPCDInfo explicitly requested, or passDebugInfo+prs/ts --> we also take passAllOtherPCDInfo */
+    if ((p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passAllOtherPCDInfo)
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+        || (p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passDebugInfo &&
+         (p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passPrsResult ||
+          p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passTimeStamp ||
+          p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passHashResult))
+#endif /* (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0)) */
+       )
+    {
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+        if(p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passDebugInfo)
+        {
+            p_FmPort->p_FmPortDriverParam->intContext.size = 240;
+            p_FmPort->bufferOffsets.debugOffset =
+                (uint32_t)(p_FmPort->p_FmPortDriverParam->intContext.extBufOffset + 128);
+        }
+        else
+#endif /* (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0)) */
+            p_FmPort->p_FmPortDriverParam->intContext.size = 128; /* must be aligned to 16 */
+        /* Start copying data after 16 bytes (FD) from the beginning of the internal context */
+        p_FmPort->p_FmPortDriverParam->intContext.intContextOffset = 16;
+
+        if (p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passAllOtherPCDInfo)
+            p_FmPort->bufferOffsets.pcdInfoOffset = p_FmPort->p_FmPortDriverParam->intContext.extBufOffset;
+        if (p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passPrsResult)
+            p_FmPort->bufferOffsets.prsResultOffset =
+                (uint32_t)(p_FmPort->p_FmPortDriverParam->intContext.extBufOffset + 16);
+        if (p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passTimeStamp)
+            p_FmPort->bufferOffsets.timeStampOffset =
+                (uint32_t)(p_FmPort->p_FmPortDriverParam->intContext.extBufOffset + 48);
+        if (p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passHashResult)
+            p_FmPort->bufferOffsets.hashResultOffset =
+                (uint32_t)(p_FmPort->p_FmPortDriverParam->intContext.extBufOffset + 56);
+    }
+    else
+    {
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+        if (p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passDebugInfo)
+        {
+            /* This case covers option 3 */
+            p_FmPort->p_FmPortDriverParam->intContext.size = 112;
+            p_FmPort->p_FmPortDriverParam->intContext.intContextOffset = 144;
+            p_FmPort->bufferOffsets.debugOffset = p_FmPort->p_FmPortDriverParam->intContext.extBufOffset;
+        }
+        else
+#endif /* (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0)) */
+        {
+            /* This case covers the options under 1 */
+            /* Copy size must be in 16-byte granularity. */
+            p_FmPort->p_FmPortDriverParam->intContext.size =
+                (uint16_t)((p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passPrsResult ? 32 : 0) +
+                          ((p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passTimeStamp ||
+                          p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passHashResult) ? 16 : 0));
+
+            /* Align start of internal context data to 16 byte */
+            p_FmPort->p_FmPortDriverParam->intContext.intContextOffset =
+                (uint8_t)(p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passPrsResult ? 32 :
+                          ((p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passTimeStamp  ||
+                           p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passHashResult) ? 64 : 0));
+
+            if(p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passPrsResult)
+                p_FmPort->bufferOffsets.prsResultOffset = p_FmPort->p_FmPortDriverParam->intContext.extBufOffset;
+            if(p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passTimeStamp)
+                p_FmPort->bufferOffsets.timeStampOffset =  p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passPrsResult ?
+                                            (p_FmPort->p_FmPortDriverParam->intContext.extBufOffset + sizeof(t_FmPrsResult)) :
+                                            p_FmPort->p_FmPortDriverParam->intContext.extBufOffset;
+            if(p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passHashResult)
+                /* If PR is not requested, whether TS is requested or not, IC will be copied from TS */
+                p_FmPort->bufferOffsets.hashResultOffset = p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passPrsResult ?
+                                              (p_FmPort->p_FmPortDriverParam->intContext.extBufOffset + sizeof(t_FmPrsResult) + 8) :
+                                              p_FmPort->p_FmPortDriverParam->intContext.extBufOffset + 8;
+        }
+    }
+
+    p_FmPort->p_FmPortDriverParam->bufMargins.startMargins =
+        (uint16_t)(p_FmPort->p_FmPortDriverParam->intContext.extBufOffset +
+                   p_FmPort->p_FmPortDriverParam->intContext.size);
+
+    /* align data start */
+    tmp = (uint32_t)(p_FmPort->p_FmPortDriverParam->bufMargins.startMargins &
+                     (p_FmPort->p_FmPortDriverParam->bufferPrefixContent.dataAlign-1));
+    if (tmp)
+        p_FmPort->p_FmPortDriverParam->bufMargins.startMargins += (p_FmPort->p_FmPortDriverParam->bufferPrefixContent.dataAlign-tmp);
+    p_FmPort->bufferOffsets.dataOffset = p_FmPort->p_FmPortDriverParam->bufMargins.startMargins;
+
+    return E_OK;
+}
 
 /********************************************/
 /*  Inter-module API                        */
@@ -1256,7 +1352,7 @@ t_Error FmPortSetPcd(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParams)
 
     if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) &&
         (p_FmPort->portType != e_FM_PORT_TYPE_RX) &&
-        (p_FmPort->portType != e_FM_PORT_TYPE_OFFLINE_PARSING))
+        (p_FmPort->portType != e_FM_PORT_TYPE_OH_OFFLINE_PARSING))
         RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx and offline parsing ports only"));
 
     p_FmPort->netEnvId = (uint8_t)(CAST_POINTER_TO_UINT32(p_PcdParams->h_NetEnv)-1);
@@ -1324,7 +1420,7 @@ t_Error FmPortSetPcd(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParams)
             p_BmiInitPrsResult = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rprai[0];
             p_BmiCcBase = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rccb;
        break;
-        case(e_FM_PORT_TYPE_OFFLINE_PARSING):
+        case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
             p_BmiNia = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofne;
             p_BmiPrsNia = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofpne;
             p_BmiPrsStartOffset = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_opso;
@@ -1332,6 +1428,7 @@ t_Error FmPortSetPcd(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParams)
             p_BmiCcBase = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_occb;
         break;
         default:
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid port type"));
             break;
     }
 
@@ -1394,7 +1491,7 @@ t_Error FmPortSetPcd(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParams)
     }
 
     /* all cases but e_FM_PORT_PCD_SUPPORT_PLCR_ONLY, use parser */
-    if(!(p_PcdParams->pcdSupport == e_FM_PORT_PCD_SUPPORT_PLCR_ONLY))
+    if (!(p_PcdParams->pcdSupport == e_FM_PORT_PCD_SUPPORT_PLCR_ONLY))
     {
         ASSERT_COND(p_FmPort->pcdEngines & FM_PCD_PRS);
         /* Go to Parser */
@@ -1433,7 +1530,10 @@ t_Error FmPortSetPcd(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParams)
                 }
                 WRITE_UINT32(*p_BmiPrsNia, NIA_ENG_KG | tmpReg);
                 break;
+            case(e_FM_PORT_PCD_SUPPORT_PRS_AND_PLCR):
+                break;
             default:
+                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid PCD support"));
                 break;
         }
 
@@ -1522,16 +1622,25 @@ t_Error FmPortSetPcd(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParams)
 
             tmpHxs[hdrNum] |= tmpReg;
         }
-        /* link to sw parser code for L4 shells - only if no other code is applied. */
-        GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_SCTP)
-        if(!(tmpHxs[hdrNum] & PRS_HDR_SW_PRS_EN))
-            tmpHxs[hdrNum] |= (PRS_HDR_SW_PRS_EN | SCTP_SW_PATCH_START);
-        GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_DCCP)
-        if(!(tmpHxs[hdrNum] & PRS_HDR_SW_PRS_EN))
-            tmpHxs[hdrNum] |= (PRS_HDR_SW_PRS_EN | DCCP_SW_PATCH_START);
-        GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_IPSEC_AH)
-        if(!(tmpHxs[hdrNum] & PRS_HDR_SW_PRS_EN))
-            tmpHxs[hdrNum] |= (PRS_HDR_SW_PRS_EN | IPSEC_SW_PATCH_START);
+#ifdef FM_PRS_L4_SHELL_ERRATA
+        {
+            t_FmRevisionInfo revInfo;
+            FmGetRevision(p_FmPort->h_Fm, &revInfo);
+            if ((revInfo.majorRev == 1) && (revInfo.minorRev == 0))
+            {
+               /* link to sw parser code for L4 shells - only if no other code is applied. */
+                GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_SCTP)
+                if(!(tmpHxs[hdrNum] & PRS_HDR_SW_PRS_EN))
+                    tmpHxs[hdrNum] |= (PRS_HDR_SW_PRS_EN | SCTP_SW_PATCH_START);
+                GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_DCCP)
+                if(!(tmpHxs[hdrNum] & PRS_HDR_SW_PRS_EN))
+                    tmpHxs[hdrNum] |= (PRS_HDR_SW_PRS_EN | DCCP_SW_PATCH_START);
+                GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_IPSEC_AH)
+                if(!(tmpHxs[hdrNum] & PRS_HDR_SW_PRS_EN))
+                    tmpHxs[hdrNum] |= (PRS_HDR_SW_PRS_EN | IPSEC_SW_PATCH_START);
+            }
+        }
+#endif /* FM_PRS_L4_SHELL_ERRATA */
 
         for(i=0 ; i<FM_PCD_PRS_NUM_OF_HDRS ; i++)
         {
@@ -1563,13 +1672,13 @@ t_Error FmPortSetPcd(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParams)
         p_FmPort->privateInfo = p_PcdParams->p_PrsParams->prsResultPrivateInfo;
 
     /* set initial parser result - used for all engines */
-    for (i=0;i<PRS_RESULT_NUM_OF_WORDS;i++)
+    for (i=0;i<FM_PORT_PRS_RESULT_NUM_OF_WORDS;i++)
     {
         if (!i)
             WRITE_UINT32(*(p_BmiInitPrsResult), (uint32_t)((p_FmPort->privateInfo << BMI_PR_PORTID_SHIFT)
                                                             | BMI_PRS_RESULT_HIGH));
         else
-            if (i< PRS_RESULT_NUM_OF_WORDS/2)
+            if (i< FM_PORT_PRS_RESULT_NUM_OF_WORDS/2)
                 WRITE_UINT32(*(p_BmiInitPrsResult+i), BMI_PRS_RESULT_HIGH);
             else
                 WRITE_UINT32(*(p_BmiInitPrsResult+i), BMI_PRS_RESULT_LOW);
@@ -1593,7 +1702,7 @@ t_Error FmPortDeletePcd(t_Handle h_FmPort)
 
     if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) &&
         (p_FmPort->portType != e_FM_PORT_TYPE_RX) &&
-        (p_FmPort->portType != e_FM_PORT_TYPE_OFFLINE_PARSING))
+        (p_FmPort->portType != e_FM_PORT_TYPE_OH_OFFLINE_PARSING))
         RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx and offline parsing ports only"));
 
     if(!p_FmPort->pcdEngines)
@@ -1606,10 +1715,11 @@ t_Error FmPortDeletePcd(t_Handle h_FmPort)
         case(e_FM_PORT_TYPE_RX):
             p_BmiNia = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfne;
             break;
-        case(e_FM_PORT_TYPE_OFFLINE_PARSING):
+        case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
             p_BmiNia = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofne;
         break;
         default:
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid port type"));
             break;
     }
 
@@ -1706,7 +1816,7 @@ t_Error FmPortAttachPCD(t_Handle h_FmPort)
         case(e_FM_PORT_TYPE_RX):
             p_BmiNia = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfne;
             break;
-        case(e_FM_PORT_TYPE_OFFLINE_PARSING):
+        case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
             p_BmiNia = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofne;
         break;
         default:
@@ -1756,6 +1866,9 @@ t_Handle FM_PORT_Config(t_FmPortParams *p_FmPortParams)
     p_FmPort->portType      = p_FmPortParams->portType;
     p_FmPort->portId        = p_FmPortParams->portId;
     p_FmPort->pcdEngines    = FM_PCD_NONE;
+    p_FmPort->f_Exception   = p_FmPortParams->f_Exception;
+    p_FmPort->h_App         = p_FmPortParams->h_App;
+    p_FmPort->h_Fm          = p_FmPortParams->h_Fm;
 
     /* calculate global portId number */
     GET_GLOBAL_PORTID(p_FmPort->hardwarePortId, p_FmPort->portType, p_FmPortParams->portId);
@@ -1765,14 +1878,19 @@ t_Handle FM_PORT_Config(t_FmPortParams *p_FmPortParams)
     p_FmPort->p_FmPortDriverParam->bufferPrefixContent.privDataSize = DEFAULT_PORT_bufferPrefixContent_privDataSize;
     p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passPrsResult= DEFAULT_PORT_bufferPrefixContent_passPrsResult;
     p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passTimeStamp= DEFAULT_PORT_bufferPrefixContent_passTimeStamp;
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+    p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passAllOtherPCDInfo
+                                                                    = DEFAULT_PORT_bufferPrefixContent_passTimeStamp;
+    p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passDebugInfo= DEFAULT_PORT_bufferPrefixContent_debugInfo;
+    p_FmPort->p_FmPortDriverParam->bufferPrefixContent.dataAlign    = DEFAULT_PORT_bufferPrefixContent_dataAlign;
+#endif /*(defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))*/
     p_FmPort->p_FmPortDriverParam->dmaSwapData                      = DEFAULT_PORT_dmaSwapData;
     p_FmPort->p_FmPortDriverParam->dmaIntContextCacheAttr           = DEFAULT_PORT_dmaIntContextCacheAttr;
     p_FmPort->p_FmPortDriverParam->dmaHeaderCacheAttr               = DEFAULT_PORT_dmaHeaderCacheAttr;
     p_FmPort->p_FmPortDriverParam->dmaScatterGatherCacheAttr        = DEFAULT_PORT_dmaScatterGatherCacheAttr;
-    p_FmPort->p_FmPortDriverParam->dmaReadOptimize                  = DEFAULT_PORT_dmaReadOptimize;
     p_FmPort->p_FmPortDriverParam->dmaWriteOptimize                 = DEFAULT_PORT_dmaWriteOptimize;
 
-    /* resource distrubution. */
+    /* resource distribution. */
     p_FmPort->p_FmPortDriverParam->fifoBufs.num                     = DEFAULT_PORT_sizeOfFifo(p_FmPort->portType);
     p_FmPort->p_FmPortDriverParam->fifoBufs.extra                   = DEFAULT_PORT_extraSizeOfFifo(p_FmPort->portType);
     p_FmPort->p_FmPortDriverParam->openDmas.num                     = DEFAULT_PORT_numOfOpenDmas(p_FmPort->portType);
@@ -1780,14 +1898,19 @@ t_Handle FM_PORT_Config(t_FmPortParams *p_FmPortParams)
     p_FmPort->p_FmPortDriverParam->tasks.num                        = DEFAULT_PORT_numOfTasks(p_FmPort->portType);
     p_FmPort->p_FmPortDriverParam->tasks.extra                      = DEFAULT_PORT_extraNumOfTasks(p_FmPort->portType);
 
-    p_FmPort->p_FmPortDriverParam->syncReq                          = DEFAULT_PORT_syncReq;
     p_FmPort->p_FmPortDriverParam->color                            = DEFAULT_PORT_color;
+    p_FmPort->p_FmPortDriverParam->syncReq                          = DEFAULT_PORT_syncReq;
+#ifdef FM_PORT_SYNC_ERRATA_FMAN6
+    {
+        t_FmRevisionInfo revInfo;
+        FmGetRevision(p_FmPort->h_Fm, &revInfo);
+        if ((revInfo.majorRev == 1) && (revInfo.minorRev == 0) &&
+            (p_FmPort->portType != e_FM_PORT_TYPE_OH_OFFLINE_PARSING))
+                p_FmPort->p_FmPortDriverParam->syncReq              = FALSE;
+    }
+#endif /* FM_PORT_SYNC_ERRATA_FMAN6 */
 
-#ifdef   VERIFICATION_SUPPORT
-    p_FmPort->p_FmPortDriverParam->intContextConfigured             = FALSE;
-#endif /* VERIFICATION_SUPPORT */
     /* Port type specific initialization: */
-
     if((p_FmPort->portType != e_FM_PORT_TYPE_TX) && (p_FmPort->portType != e_FM_PORT_TYPE_TX_10G))
         p_FmPort->p_FmPortDriverParam->frmDiscardOverride           = DEFAULT_PORT_frmDiscardOverride;
 
@@ -1816,28 +1939,42 @@ t_Handle FM_PORT_Config(t_FmPortParams *p_FmPortParams)
         p_FmPort->p_FmPortDriverParam->cheksumLastBytesIgnore       = DEFAULT_PORT_cheksumLastBytesIgnore;
         p_FmPort->p_FmPortDriverParam->txFifoMinFillLevel           = DEFAULT_PORT_txFifoMinFillLevel;
         p_FmPort->p_FmPortDriverParam->txFifoLowComfLevel           = DEFAULT_PORT_txFifoLowComfLevel;
-    case(e_FM_PORT_TYPE_OFFLINE_PARSING):
+    case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
         p_FmPort->p_FmPortDriverParam->enRateLimit                  = FALSE;
-    case(e_FM_PORT_TYPE_HOST_COMMAND):
+    case(e_FM_PORT_TYPE_OH_HOST_COMMAND):
         p_FmPort->p_FmPortDriverParam->deqHighPriority              = DEFAULT_PORT_deqHighPriority;
         p_FmPort->p_FmPortDriverParam->deqType                      = DEFAULT_PORT_deqType;
         p_FmPort->p_FmPortDriverParam->deqPrefetchOption            = DEFAULT_PORT_deqPrefetchOption;
         p_FmPort->p_FmPortDriverParam->deqByteCnt                   = DEFAULT_PORT_deqByteCnt;
 
-        if(p_FmPort->portType == e_FM_PORT_TYPE_OFFLINE_PARSING)
+        if (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
         {
             p_FmPort->p_FmPortDriverParam->errorsToDiscard          = DEFAULT_PORT_errorsToDiscard;
         }
         break;
 
     default:
-        break;
+        XX_Free(p_FmPort->p_FmPortDriverParam);
+        XX_Free(p_FmPort);
+        REPORT_ERROR(MAJOR, E_INVALID_STATE, ("Invalid port type"));
+        return NULL;
     }
+    if (p_FmPort->portType == e_FM_PORT_TYPE_OH_HOST_COMMAND)
+        p_FmPort->p_FmPortDriverParam->deqPrefetchOption            = DEFAULT_PORT_deqPrefetchOption_HC;
+
+    if ((p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING) ||
+        (p_FmPort->portType == e_FM_PORT_TYPE_OH_HOST_COMMAND))
+        p_FmPort->txFifoDeqPipelineDepth                            = OH_PIPELINE_DEPTH;
 
     p_FmPort->imEn = p_FmPortParams->independentModeEnable;
 
     if (p_FmPort->imEn)
+    {
+        if ((p_FmPort->portType == e_FM_PORT_TYPE_TX) ||
+            (p_FmPort->portType == e_FM_PORT_TYPE_TX_10G))
+            p_FmPort->txFifoDeqPipelineDepth = 2;//DEFAULT_PORT_txFifoDeqPipelineDepth_IM;
         FmPortConfigIM(p_FmPort, p_FmPortParams);
+    }
     else
     {
         switch(p_FmPort->portType)
@@ -1852,23 +1989,46 @@ t_Handle FM_PORT_Config(t_FmPortParams *p_FmPortParams)
             p_FmPort->p_FmPortDriverParam->dfltFqid                     = p_FmPortParams->specificParams.rxParams.dfltFqid;
             p_FmPort->p_FmPortDriverParam->partitionId                  = p_FmPortParams->specificParams.rxParams.rxPartitionId;
             break;
-        case(e_FM_PORT_TYPE_OFFLINE_PARSING):
-#ifdef FM_OP_PARTITION_ERRATA
-            p_FmPort->p_FmPortDriverParam->partitionId                  = p_FmPortParams->specificParams.nonRxParams.opPartitionId;
-#endif /* FM_OP_PARTITION_ERRATA */
+        case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+#ifdef FM_OP_PARTITION_ERRATA_FMAN16
+        {
+            t_FmRevisionInfo revInfo;
+            FmGetRevision(p_FmPort->h_Fm, &revInfo);
+            if ((revInfo.majorRev == 1) && (revInfo.minorRev == 0))
+                p_FmPort->p_FmPortDriverParam->partitionId              = p_FmPortParams->specificParams.nonRxParams.opPartitionId;
+        }
+#endif /* FM_OP_PARTITION_ERRATA_FMAN16 */
         case(e_FM_PORT_TYPE_TX):
         case(e_FM_PORT_TYPE_TX_10G):
-        case(e_FM_PORT_TYPE_HOST_COMMAND):
+        case(e_FM_PORT_TYPE_OH_HOST_COMMAND):
             p_FmPort->p_FmPortDriverParam->errFqid                      = p_FmPortParams->specificParams.nonRxParams.errFqid;
             p_FmPort->p_FmPortDriverParam->deqSubPortal                 = p_FmPortParams->specificParams.nonRxParams.deqSubPortal;
             p_FmPort->p_FmPortDriverParam->dfltFqid                     = p_FmPortParams->specificParams.nonRxParams.dfltFqid;
             break;
         default:
-            break;
+            XX_Free(p_FmPort->p_FmPortDriverParam);
+            XX_Free(p_FmPort);
+            REPORT_ERROR(MAJOR, E_INVALID_STATE, ("Invalid port type"));
+            return NULL;
         }
     }
 
-    p_FmPort->h_Fm = p_FmPortParams->h_Fm;
+    memset(p_FmPort->name, 0, MODULE_NAME_SIZE);
+    if(Sprint (p_FmPort->name, "FM-%d-port-%s-%d",
+               FmGetId(p_FmPort->h_Fm),
+               ((p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING ||
+                 (p_FmPort->portType == e_FM_PORT_TYPE_OH_HOST_COMMAND)) ?
+                "OH" : (p_FmPort->portType == e_FM_PORT_TYPE_RX ?
+                        "1g-RX" : (p_FmPort->portType == e_FM_PORT_TYPE_TX ?
+                                   "1g-TX" : (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G ?
+                                              "10g-RX" : "10g-TX")))),
+               p_FmPort->portId) == 0)
+    {
+        XX_Free(p_FmPort->p_FmPortDriverParam);
+        XX_Free(p_FmPort);
+        REPORT_ERROR(MAJOR, E_INVALID_STATE, ("Sprint failed"));
+        return NULL;
+    }
 
     return p_FmPort;
 }
@@ -1892,24 +2052,9 @@ t_Error FM_PORT_Init(t_Handle h_FmPort)
     SANITY_CHECK_RETURN_ERROR(h_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
 
-#ifdef VERIFICATION_SUPPORT
-    if(!p_FmPort->p_FmPortDriverParam->intContextConfigured)
-    {
-#endif /* VERIFICATION_SUPPORT */
-    /* translate margin and intContext params to FM parameters */
-    p_FmPort->p_FmPortDriverParam->intContext.size = (uint16_t)((p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passPrsResult ? 32:0) +
-                                                        (p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passTimeStamp ? 16:0));
-    /* align start of internal context data to 16 byte */
-    p_FmPort->p_FmPortDriverParam->intContext.extBufOffset =  (uint16_t)((p_FmPort->p_FmPortDriverParam->bufferPrefixContent.privDataSize & (OFFSET_UNITS-1))?
-            ((p_FmPort->p_FmPortDriverParam->bufferPrefixContent.privDataSize + OFFSET_UNITS) &  ~(uint16_t)(OFFSET_UNITS-1)) :
-            p_FmPort->p_FmPortDriverParam->bufferPrefixContent.privDataSize);
-    p_FmPort->p_FmPortDriverParam->intContext.intContextOffset = (uint8_t)(p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passPrsResult ? 32:
-            (p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passTimeStamp ? 64 : 0));
-    p_FmPort->p_FmPortDriverParam->bufMargins.startMargins = (uint16_t)(p_FmPort->p_FmPortDriverParam->intContext.extBufOffset +
-            p_FmPort->p_FmPortDriverParam->intContext.size);
-#ifdef VERIFICATION_SUPPORT
-    }
-#endif /* VERIFICATION_SUPPORT */
+    if ((err = BuildBufferStructure(p_FmPort)) != E_OK)
+        RETURN_ERROR(MINOR, err, NO_MSG);
+
     CHECK_INIT_PARAMETERS(p_FmPort, CheckInitParameters);
 
     p_Params = p_FmPort->p_FmPortDriverParam;
@@ -1919,29 +2064,6 @@ t_Error FM_PORT_Init(t_Handle h_FmPort)
     p_FmPort->p_FmPortBmiRegs     = CAST_UINT64_TO_POINTER_TYPE(u_FmPortBmiRegs , (p_Params->baseAddr + BMI_PORT_REGS_OFFSET));
     p_FmPort->p_FmPortPrsRegs     = CAST_UINT64_TO_POINTER_TYPE(t_FmPortPrsRegs, (p_Params->baseAddr + PRS_PORT_REGS_OFFSET));
 
-#ifdef VERIFICATION_SUPPORT
-    if(p_FmPort->p_FmPortDriverParam->intContextConfigured)
-    {
-        p_FmPort->bufferOffsets.dataOffset = p_FmPort->p_FmPortDriverParam->bufMargins.startMargins;
-        p_FmPort->bufferOffsets.prsResultOffset = (uint32_t)(p_FmPort->p_FmPortDriverParam->intContext.extBufOffset+32 - p_FmPort->p_FmPortDriverParam->intContext.intContextOffset);
-        p_FmPort->bufferOffsets.timeStampOffset = (uint32_t)(p_FmPort->p_FmPortDriverParam->intContext.extBufOffset+64 - p_FmPort->p_FmPortDriverParam->intContext.intContextOffset);
-    }
-    else
-    {
-#endif /* VERIFICATION_SUPPORT */
-    p_FmPort->bufferOffsets.dataOffset = p_FmPort->p_FmPortDriverParam->bufMargins.startMargins;
-    p_FmPort->bufferOffsets.prsResultOffset = p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passPrsResult ?
-                                    p_FmPort->p_FmPortDriverParam->intContext.extBufOffset:
-                                    0xFFFFFFFF;
-    p_FmPort->bufferOffsets.timeStampOffset = p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passTimeStamp ?
-                                    (p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passPrsResult ?
-                                    (p_FmPort->p_FmPortDriverParam->intContext.extBufOffset + sizeof(t_FmPrsResult)) :
-                                    p_FmPort->p_FmPortDriverParam->intContext.extBufOffset):
-                                    0xFFFFFFFF;
-
-#ifdef VERIFICATION_SUPPORT
-    }
-#endif /* VERIFICATION_SUPPORT */
     /************************************************************/
     /* Call FM module routine for communicating parameters      */
     /************************************************************/
@@ -1965,11 +2087,10 @@ t_Error FM_PORT_Init(t_Handle h_FmPort)
             break;
         case(e_FM_PORT_TYPE_TX_10G):
         case(e_FM_PORT_TYPE_TX):
+        case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+        case(e_FM_PORT_TYPE_OH_HOST_COMMAND):
             fmParams.deqPipelineDepth = p_FmPort->txFifoDeqPipelineDepth;
-            break;
-        case(e_FM_PORT_TYPE_OFFLINE_PARSING):
-        case(e_FM_PORT_TYPE_HOST_COMMAND):
-            fmParams.deqPipelineDepth = p_FmPort->txFifoDeqPipelineDepth = 1;
+            fmParams.useRateLimit = p_Params->enRateLimit;
             break;
         default:
             RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
@@ -1980,9 +2101,10 @@ t_Error FM_PORT_Init(t_Handle h_FmPort)
         RETURN_ERROR(MAJOR, err, NO_MSG);
 
     /* get params for use in init */
-    p_Params->timeStampPeriod = fmParams.timeStampPeriod;
+    p_Params->count1MicroBit = fmParams.count1MicroBit;
     p_Params->fmMuramPhysBaseAddr = 0;
-    memcpy(((uint8_t *)&p_Params->fmMuramPhysBaseAddr)+2, (uint8_t *)&fmParams.fmMuramPhysBaseAddr, sizeof(t_FmPhysAddr));
+    memcpy(((uint8_t *)&p_Params->fmMuramPhysBaseAddr)+(sizeof(uint64_t)-sizeof(t_FmPhysAddr)),
+                                (uint8_t *)&fmParams.fmMuramPhysBaseAddr, sizeof(t_FmPhysAddr));
 
     /**********************/
     /* Init BMI Registers */
@@ -2001,8 +2123,8 @@ t_Error FM_PORT_Init(t_Handle h_FmPort)
             if(err)
                 RETURN_ERROR(MAJOR, err, NO_MSG);
             break;
-        case(e_FM_PORT_TYPE_OFFLINE_PARSING):
-        case(e_FM_PORT_TYPE_HOST_COMMAND):
+        case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+        case(e_FM_PORT_TYPE_OH_HOST_COMMAND):
             err = BmiOhPortInit(p_FmPort);
             if(err)
                 RETURN_ERROR(MAJOR, err, NO_MSG);
@@ -2066,6 +2188,7 @@ t_Error FM_PORT_Free(t_Handle h_FmPort)
     return E_OK;
 }
 
+
 /*************************************************/
 /*       API Advanced Init unit functions        */
 /*************************************************/
@@ -2088,7 +2211,7 @@ t_Error FM_PORT_ConfigNumOfTasks(t_Handle h_FmPort, t_FmPortRsrc *p_NumOfTasks)
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
 
-    if(p_FmPort->portType == e_FM_PORT_TYPE_HOST_COMMAND)
+    if(p_FmPort->portType == e_FM_PORT_TYPE_OH_HOST_COMMAND)
         RETURN_ERROR(MAJOR, E_NO_MEMORY, ("not available for host command port where number is always 1"));
 
     memcpy(&p_FmPort->p_FmPortDriverParam->tasks, p_NumOfTasks, sizeof(t_FmPortRsrc));
@@ -2172,41 +2295,20 @@ t_Error FM_PORT_ConfigBufferPrefixContent(t_Handle h_FmPort, t_FmPortBufferPrefi
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
 
     memcpy(&p_FmPort->p_FmPortDriverParam->bufferPrefixContent, p_FmPortBufferPrefixContent, sizeof(t_FmPortBufferPrefixContent));
+    /* if dataAlign was not initialized by user, we return to driver's deafult */
+    if (!p_FmPort->p_FmPortDriverParam->bufferPrefixContent.dataAlign)
+        p_FmPort->p_FmPortDriverParam->bufferPrefixContent.dataAlign = DEFAULT_PORT_bufferPrefixContent_dataAlign;
 
     return E_OK;
 }
 
-#ifdef VERIFICATION_SUPPORT
-t_Error FM_PORT_ConfigIntContent(t_Handle h_FmPort, uint8_t intContextIntOffset,
-                                                    uint16_t intContextExtOffset,
-                                                    uint16_t intContextSize,
-                                                    uint16_t startMargins,
-                                                    uint16_t endMargins)
-{
-    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
-
-    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
-
-    p_FmPort->p_FmPortDriverParam->intContext.size = intContextSize;
-    /* align start of internal context data to 16 byte */
-    p_FmPort->p_FmPortDriverParam->intContext.extBufOffset =  intContextExtOffset;
-    p_FmPort->p_FmPortDriverParam->intContext.intContextOffset = intContextIntOffset;
-    p_FmPort->p_FmPortDriverParam->bufMargins.startMargins = startMargins;
-    p_FmPort->p_FmPortDriverParam->bufMargins.endMargins = endMargins;
-
-    p_FmPort->p_FmPortDriverParam->intContextConfigured = TRUE;
-   return E_OK;
-}
-#endif /* VERIFICATION_SUPPORT */
-
 t_Error FM_PORT_ConfigCheksumLastBytesIgnore(t_Handle h_FmPort, uint8_t cheksumLastBytesIgnore)
 {
     t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
-    if((p_FmPort->portType == e_FM_PORT_TYPE_OFFLINE_PARSING) || (p_FmPort->portType == e_FM_PORT_TYPE_HOST_COMMAND))
+    if((p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING) || (p_FmPort->portType == e_FM_PORT_TYPE_OH_HOST_COMMAND))
         RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx & Tx ports only"));
 
     p_FmPort->p_FmPortDriverParam->cheksumLastBytesIgnore = cheksumLastBytesIgnore;
@@ -2291,8 +2393,11 @@ t_Error FM_PORT_ConfigTxFifoDeqPipelineDepth(t_Handle h_FmPort, uint8_t deqPipel
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
-    if((p_FmPort->portType != e_FM_PORT_TYPE_TX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_TX))
+    if ((p_FmPort->portType != e_FM_PORT_TYPE_TX_10G) &&
+        (p_FmPort->portType != e_FM_PORT_TYPE_TX))
         RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Tx ports only"));
+    if (p_FmPort->imEn)
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("Not available for IM ports!"));
 
     p_FmPort->txFifoDeqPipelineDepth = deqPipelineDepth;
 
@@ -2331,6 +2436,14 @@ t_Error FM_PORT_ConfigSyncReq(t_Handle h_FmPort, bool syncReq)
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+#ifdef FM_PORT_SYNC_ERRATA_FMAN6
+    {
+        t_FmRevisionInfo revInfo;
+        FmGetRevision(p_FmPort->h_Fm, &revInfo);
+        if ((revInfo.majorRev == 1) && (revInfo.minorRev == 0))
+            RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("port-sync!"));
+    }
+#endif /* FM_PORT_SYNC_ERRATA_FMAN6 */
 
     p_FmPort->p_FmPortDriverParam->syncReq = syncReq;
 
@@ -2346,7 +2459,7 @@ t_Error FM_PORT_ConfigRateLimit(t_Handle h_FmPort, t_FmPortRateLimit *p_RateLimi
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
 
     if((p_FmPort->portType == e_FM_PORT_TYPE_RX_10G) || (p_FmPort->portType == e_FM_PORT_TYPE_RX) ||
-                                                (p_FmPort->portType == e_FM_PORT_TYPE_HOST_COMMAND))
+                                                (p_FmPort->portType == e_FM_PORT_TYPE_OH_HOST_COMMAND))
         RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Tx and Offline parsing ports only"));
 
     memcpy(&p_FmPort->p_FmPortDriverParam->rateLimit, p_RateLimit, sizeof(t_FmPortRateLimit));
@@ -2376,7 +2489,7 @@ t_Error FM_PORT_ConfigErrorsToDiscard(t_Handle h_FmPort, fmPortFrameErrSelect_t
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
     if((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_RX) &&
-                                                            (p_FmPort->portType != e_FM_PORT_TYPE_OFFLINE_PARSING))
+                                                            (p_FmPort->portType != e_FM_PORT_TYPE_OH_OFFLINE_PARSING))
         RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx and offline parsing ports only"));
 
     p_FmPort->p_FmPortDriverParam->errorsToDiscard = errs;
@@ -2384,7 +2497,6 @@ t_Error FM_PORT_ConfigErrorsToDiscard(t_Handle h_FmPort, fmPortFrameErrSelect_t
     return E_OK;
 }
 
-
 t_Error FM_PORT_ConfigDmaSwapData(t_Handle h_FmPort, e_FmPortDmaSwap swapData)
 {
     t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
@@ -2433,18 +2545,6 @@ t_Error FM_PORT_ConfigDmaScatterGatherAttr(t_Handle h_FmPort, e_FmPortDmaCache s
     return E_OK;
 }
 
-t_Error FM_PORT_ConfigDmaReadOptimize(t_Handle h_FmPort, bool optimize)
-{
-    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
-
-    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
-
-    p_FmPort->p_FmPortDriverParam->dmaReadOptimize = optimize;
-
-    return E_OK;
-}
-
 t_Error FM_PORT_ConfigDmaWriteOptimize(t_Handle h_FmPort, bool optimize)
 {
     t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
@@ -2452,6 +2552,9 @@ t_Error FM_PORT_ConfigDmaWriteOptimize(t_Handle h_FmPort, bool optimize)
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
 
+    if((p_FmPort->portType == e_FM_PORT_TYPE_TX_10G) || (p_FmPort->portType == e_FM_PORT_TYPE_TX))
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("Not available for Tx ports"));
+
     p_FmPort->p_FmPortDriverParam->dmaWriteOptimize = optimize;
 
     return E_OK;
@@ -2487,6 +2590,7 @@ t_Error FM_PORT_ConfigRxL4ChecksumVerify(t_Handle h_FmPort, bool l4Checksum)
     return E_OK;
 }
 
+
 /****************************************************/
 /*       PCD Advaced config API                     */
 /****************************************************/
@@ -2505,41 +2609,88 @@ uint32_t FM_PORT_GetBufferDataOffset(t_Handle h_FmPort)
     return p_FmPort->bufferOffsets.dataOffset;
 }
 
-t_FmPrsResult *FM_PORT_GetBufferPrsResult(t_Handle h_FmPort, char *p_Data)
+uint8_t * FM_PORT_GetBufferICInfo(t_Handle h_FmPort, char *p_Data)
 {
     t_FmPort                    *p_FmPort = (t_FmPort*)h_FmPort;
 
-    SANITY_CHECK_RETURN_VALUE(p_FmPort, E_INVALID_HANDLE, NULL);
-    SANITY_CHECK_RETURN_VALUE(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE, NULL);
+    SANITY_CHECK_RETURN_VALUE(p_FmPort, E_INVALID_HANDLE, 0);
+    SANITY_CHECK_RETURN_VALUE(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE, 0);
 
-    if(p_FmPort->bufferOffsets.prsResultOffset == 0xFFFFFFFF)
+    if(p_FmPort->bufferOffsets.pcdInfoOffset == ILLEGAL_BASE)
         return NULL;
 
-    return (t_FmPrsResult *)((uint32_t)p_Data + p_FmPort->bufferOffsets.prsResultOffset);
+    return (uint8_t *)((uint32_t)p_Data + p_FmPort->bufferOffsets.pcdInfoOffset);
 }
 
-t_FmTimeStamp *FM_PORT_GetBufferTimeStamp(t_Handle h_FmPort, char *p_Data)
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+uint8_t *FM_PORT_GetBufferDebugInfo(t_Handle h_FmPort, char *p_Data)
+{
+    t_FmPort                    *p_FmPort = (t_FmPort*)h_FmPort;
+
+    SANITY_CHECK_RETURN_VALUE(p_FmPort, E_INVALID_HANDLE, 0);
+    SANITY_CHECK_RETURN_VALUE(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE, 0);
+
+    if(p_FmPort->bufferOffsets.debugOffset == ILLEGAL_BASE)
+        return NULL;
+
+    return (uint8_t *)((uint32_t)p_Data + p_FmPort->bufferOffsets.debugOffset);
+}
+#endif /* (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))*/
+
+t_FmPrsResult * FM_PORT_GetBufferPrsResult(t_Handle h_FmPort, char *p_Data)
 {
     t_FmPort                    *p_FmPort = (t_FmPort*)h_FmPort;
 
     SANITY_CHECK_RETURN_VALUE(p_FmPort, E_INVALID_HANDLE, NULL);
     SANITY_CHECK_RETURN_VALUE(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE, NULL);
 
-    if(p_FmPort->bufferOffsets.timeStampOffset == 0xFFFFFFFF)
+    if(p_FmPort->bufferOffsets.prsResultOffset == ILLEGAL_BASE)
         return NULL;
-    return (t_FmTimeStamp *)((uint32_t)p_Data + p_FmPort->bufferOffsets.timeStampOffset);
+
+    return (t_FmPrsResult *)((uint32_t)p_Data + p_FmPort->bufferOffsets.prsResultOffset);
 }
 
+t_Error FM_PORT_GetBufferTimeStamp(t_Handle h_FmPort, char *p_Data, uint64_t *p_Ts)
+{
+    t_FmPort                    *p_FmPort = (t_FmPort*)h_FmPort;
+    uint64_t                    *p_DataTs;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
+
+    if(p_FmPort->bufferOffsets.timeStampOffset == ILLEGAL_BASE)
+        RETURN_ERROR(MINOR, E_INVALID_VALUE, ("illegal timeStampOffset"));
 
-void FM_PORT_Disable(t_Handle h_FmPort)
+    p_DataTs = CAST_UINT32_TO_POINTER_TYPE(uint64_t,((CAST_POINTER_TO_UINT32(p_Data) + p_FmPort->bufferOffsets.timeStampOffset)));
+
+    *p_Ts = *p_DataTs;
+
+    return E_OK;
+}
+
+uint8_t * FM_PORT_GetBufferHashResult(t_Handle h_FmPort, char *p_Data)
+{
+    t_FmPort                    *p_FmPort = (t_FmPort*)h_FmPort;
+
+    SANITY_CHECK_RETURN_VALUE(p_FmPort, E_INVALID_HANDLE, 0);
+    SANITY_CHECK_RETURN_VALUE(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE, 0);
+
+    if(p_FmPort->bufferOffsets.hashResultOffset == ILLEGAL_BASE)
+        return NULL;
+
+    return (uint8_t *)((uint32_t)p_Data + p_FmPort->bufferOffsets.hashResultOffset);
+}
+
+t_Error FM_PORT_Disable(t_Handle h_FmPort)
 {
     t_FmPort                    *p_FmPort = (t_FmPort*)h_FmPort;
     volatile uint32_t           *p_BmiCfgReg = NULL;
     volatile uint32_t           *p_BmiStatusReg = NULL;
     bool                        rxPort = FALSE;
+    int                         tries;
 
-    SANITY_CHECK_RETURN(p_FmPort, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
 
     switch(p_FmPort->portType)
     {
@@ -2554,13 +2705,13 @@ void FM_PORT_Disable(t_Handle h_FmPort)
              p_BmiCfgReg = &p_FmPort->p_FmPortBmiRegs->txPortBmiRegs.fmbm_tcfg;
              p_BmiStatusReg = &p_FmPort->p_FmPortBmiRegs->txPortBmiRegs.fmbm_tst;
             break;
-        case(e_FM_PORT_TYPE_OFFLINE_PARSING):
-        case(e_FM_PORT_TYPE_HOST_COMMAND):
+        case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+        case(e_FM_PORT_TYPE_OH_HOST_COMMAND):
             p_BmiCfgReg = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ocfg;
             p_BmiStatusReg = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ost;
             break;
         default:
-            break;
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid port type"));
     }
 
     /* Disable QMI */
@@ -2575,19 +2726,31 @@ void FM_PORT_Disable(t_Handle h_FmPort)
 
     /* Disable BMI */
     WRITE_UINT32(*p_BmiCfgReg, GET_UINT32(*p_BmiCfgReg) & ~BMI_PORT_CFG_EN);
-#ifndef BUP_FM_PORT_DISABLE_ERRATA
-    while(GET_UINT32(*p_BmiStatusReg) & BMI_PORT_STATUS_BSY) ;
-#endif /* !BUP_FM_PORT_DISABLE_ERRATA */
+
+    if (p_FmPort->imEn)
+        FmPortImDisable(p_FmPort);
+
+    tries=100;
+    while ((GET_UINT32(*p_BmiStatusReg) & BMI_PORT_STATUS_BSY) &&
+            --tries) ;
+
+    if (!tries)
+        RETURN_ERROR(MINOR, E_BUSY, ("%s: can't disable!", p_FmPort->name));
+
+    return E_OK;
 }
 
-void FM_PORT_Enable(t_Handle h_FmPort)
+t_Error FM_PORT_Enable(t_Handle h_FmPort)
 {
     t_FmPort                    *p_FmPort = (t_FmPort*)h_FmPort;
     volatile uint32_t           *p_BmiCfgReg = NULL;
     bool                        rxPort = FALSE;
 
-    SANITY_CHECK_RETURN(p_FmPort, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
+
+    if (p_FmPort->imEn)
+        FmPortImEnable(p_FmPort);
 
     switch(p_FmPort->portType)
     {
@@ -2600,12 +2763,12 @@ void FM_PORT_Enable(t_Handle h_FmPort)
         case(e_FM_PORT_TYPE_TX):
              p_BmiCfgReg = &p_FmPort->p_FmPortBmiRegs->txPortBmiRegs.fmbm_tcfg;
             break;
-        case(e_FM_PORT_TYPE_OFFLINE_PARSING):
-        case(e_FM_PORT_TYPE_HOST_COMMAND):
+        case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+        case(e_FM_PORT_TYPE_OH_HOST_COMMAND):
             p_BmiCfgReg = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ocfg;
             break;
         default:
-            break;
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid port type"));
     }
 
     /* Enable QMI */
@@ -2615,6 +2778,8 @@ void FM_PORT_Enable(t_Handle h_FmPort)
 
     /* Enable BMI */
     WRITE_UINT32(*p_BmiCfgReg, GET_UINT32(*p_BmiCfgReg) | BMI_PORT_CFG_EN);
+
+    return E_OK;
 }
 
 t_Error FM_PORT_SetFrameQueueCounters(t_Handle h_FmPort, bool enable)
@@ -2636,12 +2801,10 @@ t_Error FM_PORT_SetFrameQueueCounters(t_Handle h_FmPort, bool enable)
     return E_OK;
 }
 
-t_Error FM_PORT_SetPerformanceCounters(t_Handle h_FmPort, t_FmPortPerformanceCnt *p_FmPortPerformanceCnt, bool enable)
+t_Error FM_PORT_SetPerformanceCounters(t_Handle h_FmPort, bool enable)
 {
     t_FmPort                *p_FmPort = (t_FmPort*)h_FmPort;
-    uint32_t                tmpReg;
     volatile uint32_t       *p_BmiPcReg = NULL;
-    volatile uint32_t       *p_BmiPcpReg = NULL;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
@@ -2651,70 +2814,98 @@ t_Error FM_PORT_SetPerformanceCounters(t_Handle h_FmPort, t_FmPortPerformanceCnt
         case(e_FM_PORT_TYPE_RX_10G):
         case(e_FM_PORT_TYPE_RX):
             p_BmiPcReg = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rpc;
-            p_BmiPcpReg = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rpcp;
             break;
         case(e_FM_PORT_TYPE_TX_10G):
         case(e_FM_PORT_TYPE_TX):
             p_BmiPcReg = &p_FmPort->p_FmPortBmiRegs->txPortBmiRegs.fmbm_tpc;
-            p_BmiPcpReg = &p_FmPort->p_FmPortBmiRegs->txPortBmiRegs.fmbm_tpcp;
             break;
-        case(e_FM_PORT_TYPE_OFFLINE_PARSING):
-        case(e_FM_PORT_TYPE_HOST_COMMAND):
+        case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+        case(e_FM_PORT_TYPE_OH_HOST_COMMAND):
             p_BmiPcReg = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_opc;
-            p_BmiPcpReg = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_opcp;
             break;
         default:
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid port type"));
             break;
     }
 
     if(enable)
-    {
-        /* check parameters */
-        if(!p_FmPortPerformanceCnt->taskCompVal || (p_FmPortPerformanceCnt->taskCompVal > MAX_PERFORMANCE_TASK_COMP) )
-            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("performanceCnt.taskCompVal has to be in the range of 1 - %d", MAX_PERFORMANCE_TASK_COMP));
-        if(!p_FmPortPerformanceCnt->dmaCompVal || (p_FmPortPerformanceCnt->dmaCompVal > MAX_PERFORMANCE_DMA_COMP))
-            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("performanceCnt.dmaCompVal has to be in the range of 1 - %d", MAX_PERFORMANCE_DMA_COMP));
-        if(!p_FmPortPerformanceCnt->fifoCompVal || (p_FmPortPerformanceCnt->fifoCompVal > BMI_MAX_FIFO_SIZE))
-            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("performanceCnt.fifoCompVal has to be in the range of 256 - %d", BMI_MAX_FIFO_SIZE));
-        if(p_FmPortPerformanceCnt->fifoCompVal % BMI_FIFO_UNITS)
-            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("performanceCnt.fifoCompVal has to be divisible by %d", BMI_FIFO_UNITS));
-        switch(p_FmPort->portType)
-        {
-            case(e_FM_PORT_TYPE_RX_10G):
-            case(e_FM_PORT_TYPE_RX):
-                if(!p_FmPortPerformanceCnt->queueCompVal || (p_FmPortPerformanceCnt->queueCompVal > MAX_PERFORMANCE_RX_QUEUE_COMP))
-                    RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("performanceCnt.queueCompVal for Rx has to be in the range of 1 - %d", MAX_PERFORMANCE_RX_QUEUE_COMP));
-                break;
-            case(e_FM_PORT_TYPE_TX_10G):
-            case(e_FM_PORT_TYPE_TX):
-                if(!p_FmPortPerformanceCnt->queueCompVal || (p_FmPortPerformanceCnt->queueCompVal > MAX_PERFORMANCE_TX_QUEUE_COMP))
-                    RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("performanceCnt.queueCompVal for Tx has to be in the range of 1 - %d", MAX_PERFORMANCE_TX_QUEUE_COMP));
-                break;
-            case(e_FM_PORT_TYPE_OFFLINE_PARSING):
-            case(e_FM_PORT_TYPE_HOST_COMMAND):
-                if(p_FmPortPerformanceCnt->queueCompVal)
-                    RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("performanceCnt.queueCompVal is not relevant for H/O ports."));
-                break;
-            default:
-                break;
-        }
-
-        tmpReg = 0;
-        tmpReg |= ((p_FmPortPerformanceCnt->queueCompVal - 1) << BMI_PERFORMANCE_PORT_COMP_SHIFT);
-        tmpReg |= ((p_FmPortPerformanceCnt->dmaCompVal- 1) << BMI_PERFORMANCE_DMA_COMP_SHIFT);
-        tmpReg |= ((p_FmPortPerformanceCnt->fifoCompVal/BMI_FIFO_UNITS - 1) << BMI_PERFORMANCE_FIFO_COMP_SHIFT);
-        if ((p_FmPort->portType != e_FM_PORT_TYPE_OFFLINE_PARSING) && (p_FmPort->portType != e_FM_PORT_TYPE_HOST_COMMAND))
-            tmpReg |= ((p_FmPortPerformanceCnt->taskCompVal - 1)  << BMI_PERFORMANCE_TASK_COMP_SHIFT);
-
-        WRITE_UINT32(*p_BmiPcpReg, tmpReg);
         WRITE_UINT32(*p_BmiPcReg, BMI_COUNTERS_EN);
-    }
     else
         WRITE_UINT32(*p_BmiPcReg, 0);
 
     return E_OK;
 }
 
+t_Error FM_PORT_SetPerformanceCountersParams(t_Handle h_FmPort, t_FmPortPerformanceCnt *p_FmPortPerformanceCnt)
+{
+    t_FmPort                *p_FmPort = (t_FmPort*)h_FmPort;
+    uint32_t                tmpReg;
+    volatile uint32_t       *p_BmiPcpReg = NULL;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+
+    switch(p_FmPort->portType)
+    {
+        case(e_FM_PORT_TYPE_RX_10G):
+        case(e_FM_PORT_TYPE_RX):
+            p_BmiPcpReg = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rpcp;
+            break;
+        case(e_FM_PORT_TYPE_TX_10G):
+        case(e_FM_PORT_TYPE_TX):
+            p_BmiPcpReg = &p_FmPort->p_FmPortBmiRegs->txPortBmiRegs.fmbm_tpcp;
+            break;
+        case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+        case(e_FM_PORT_TYPE_OH_HOST_COMMAND):
+            p_BmiPcpReg = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_opcp;
+            break;
+        default:
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid port type"));
+            break;
+    }
+
+    /* check parameters */
+    if(!p_FmPortPerformanceCnt->taskCompVal || (p_FmPortPerformanceCnt->taskCompVal > MAX_PERFORMANCE_TASK_COMP) )
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("performanceCnt.taskCompVal has to be in the range of 1 - %d", MAX_PERFORMANCE_TASK_COMP));
+    if(!p_FmPortPerformanceCnt->dmaCompVal || (p_FmPortPerformanceCnt->dmaCompVal > MAX_PERFORMANCE_DMA_COMP))
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("performanceCnt.dmaCompVal has to be in the range of 1 - %d", MAX_PERFORMANCE_DMA_COMP));
+    if(!p_FmPortPerformanceCnt->fifoCompVal || (p_FmPortPerformanceCnt->fifoCompVal > BMI_MAX_FIFO_SIZE))
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("performanceCnt.fifoCompVal has to be in the range of 256 - %d", BMI_MAX_FIFO_SIZE));
+    if(p_FmPortPerformanceCnt->fifoCompVal % BMI_FIFO_UNITS)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("performanceCnt.fifoCompVal has to be divisible by %d", BMI_FIFO_UNITS));
+    switch(p_FmPort->portType)
+    {
+        case(e_FM_PORT_TYPE_RX_10G):
+        case(e_FM_PORT_TYPE_RX):
+            if(!p_FmPortPerformanceCnt->queueCompVal || (p_FmPortPerformanceCnt->queueCompVal > MAX_PERFORMANCE_RX_QUEUE_COMP))
+                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("performanceCnt.queueCompVal for Rx has to be in the range of 1 - %d", MAX_PERFORMANCE_RX_QUEUE_COMP));
+            break;
+        case(e_FM_PORT_TYPE_TX_10G):
+        case(e_FM_PORT_TYPE_TX):
+            if(!p_FmPortPerformanceCnt->queueCompVal || (p_FmPortPerformanceCnt->queueCompVal > MAX_PERFORMANCE_TX_QUEUE_COMP))
+                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("performanceCnt.queueCompVal for Tx has to be in the range of 1 - %d", MAX_PERFORMANCE_TX_QUEUE_COMP));
+            break;
+        case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+        case(e_FM_PORT_TYPE_OH_HOST_COMMAND):
+            if(p_FmPortPerformanceCnt->queueCompVal)
+                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("performanceCnt.queueCompVal is not relevant for H/O ports."));
+            break;
+        default:
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid port type"));
+            break;
+    }
+
+    tmpReg = 0;
+    tmpReg |= ((p_FmPortPerformanceCnt->queueCompVal - 1) << BMI_PERFORMANCE_PORT_COMP_SHIFT);
+    tmpReg |= ((p_FmPortPerformanceCnt->dmaCompVal- 1) << BMI_PERFORMANCE_DMA_COMP_SHIFT);
+    tmpReg |= ((p_FmPortPerformanceCnt->fifoCompVal/BMI_FIFO_UNITS - 1) << BMI_PERFORMANCE_FIFO_COMP_SHIFT);
+    if ((p_FmPort->portType != e_FM_PORT_TYPE_OH_OFFLINE_PARSING) && (p_FmPort->portType != e_FM_PORT_TYPE_OH_HOST_COMMAND))
+        tmpReg |= ((p_FmPortPerformanceCnt->taskCompVal - 1)  << BMI_PERFORMANCE_TASK_COMP_SHIFT);
+
+    WRITE_UINT32(*p_BmiPcpReg, tmpReg);
+
+    return E_OK;
+}
+
 t_Error FM_PORT_SetStatisticsCounters(t_Handle h_FmPort, bool enable)
 {
     t_FmPort                *p_FmPort = (t_FmPort*)h_FmPort;
@@ -2735,11 +2926,12 @@ t_Error FM_PORT_SetStatisticsCounters(t_Handle h_FmPort, bool enable)
         case(e_FM_PORT_TYPE_TX):
             p_BmiStcReg = &p_FmPort->p_FmPortBmiRegs->txPortBmiRegs.fmbm_tstc;
             break;
-        case(e_FM_PORT_TYPE_OFFLINE_PARSING):
-        case(e_FM_PORT_TYPE_HOST_COMMAND):
+        case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+        case(e_FM_PORT_TYPE_OH_HOST_COMMAND):
             p_BmiStcReg = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ostc;
             break;
         default:
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid port type"));
             break;
     }
 
@@ -2767,7 +2959,7 @@ t_Error FM_PORT_SetErrorsRoute(t_Handle h_FmPort,  fmPortFrameErrSelect_t errs)
             p_ErrQReg = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfsem;
             p_ErrDiscard = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfsdm;
             break;
-        case(e_FM_PORT_TYPE_OFFLINE_PARSING):
+        case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
             p_ErrQReg = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofsem;
             p_ErrDiscard = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofsdm;
             break;
@@ -2783,7 +2975,7 @@ t_Error FM_PORT_SetErrorsRoute(t_Handle h_FmPort,  fmPortFrameErrSelect_t errs)
     return E_OK;
 }
 
-t_Error FM_PORT_SetEnAllocBufCounter(t_Handle h_FmPort, uint8_t poolId, bool enable)
+t_Error FM_PORT_SetAllocBufCounter(t_Handle h_FmPort, uint8_t poolId, bool enable)
 {
     t_FmPort                *p_FmPort = (t_FmPort*)h_FmPort;
     uint32_t                tmpReg;
@@ -2791,7 +2983,7 @@ t_Error FM_PORT_SetEnAllocBufCounter(t_Handle h_FmPort, uint8_t poolId, bool ena
 
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(poolId<MAX_NUM_OF_EXT_POOLS, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(poolId<BM_MAX_NUM_OF_EXT_POOLS, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
 
     if((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_RX))
@@ -2866,13 +3058,14 @@ uint32_t FM_PORT_GetCounter(t_Handle h_FmPort, e_FmPortCounters counter)
                     return 0;
                 }
                 break;
-            case(e_FM_PORT_TYPE_OFFLINE_PARSING):
-            case(e_FM_PORT_TYPE_HOST_COMMAND):
+            case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+            case(e_FM_PORT_TYPE_OH_HOST_COMMAND):
                 if(BmiOhPortCheckAndGetCounterPtr(p_FmPort, counter, &p_Reg))
                 {
                     REPORT_ERROR(MINOR, E_INVALID_STATE, NO_MSG);
                     return 0;
                 }
+            break;
             default:
                 REPORT_ERROR(MINOR, E_INVALID_STATE, ("Unsupported port type"));
                 return 0;
@@ -2913,7 +3106,7 @@ uint32_t FM_PORT_GetCounter(t_Handle h_FmPort, e_FmPortCounters counter)
     }
 }
 
-t_Error FM_PORT_SetCounter(t_Handle h_FmPort, e_FmPortCounters counter, uint32_t value)
+t_Error FM_PORT_ModifyCounter(t_Handle h_FmPort, e_FmPortCounters counter, uint32_t value)
 {
     t_FmPort            *p_FmPort = (t_FmPort*)h_FmPort;
     bool                bmiCounter = FALSE;
@@ -2952,8 +3145,8 @@ t_Error FM_PORT_SetCounter(t_Handle h_FmPort, e_FmPortCounters counter, uint32_t
                if(BmiTxPortCheckAndGetCounterPtr(p_FmPort, counter, &p_Reg))
                     RETURN_ERROR(MINOR, E_INVALID_STATE, NO_MSG);
                 break;
-            case(e_FM_PORT_TYPE_OFFLINE_PARSING):
-            case(e_FM_PORT_TYPE_HOST_COMMAND):
+            case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+            case(e_FM_PORT_TYPE_OH_HOST_COMMAND):
                if(BmiOhPortCheckAndGetCounterPtr(p_FmPort, counter, &p_Reg))
                     RETURN_ERROR(MINOR, E_INVALID_STATE, NO_MSG);
                  break;
@@ -3030,7 +3223,7 @@ uint32_t FM_PORT_GetAllocBufCounter(t_Handle h_FmPort, uint8_t poolId)
     return 0;
 }
 
-t_Error FM_PORT_SetAllocBufCounter(t_Handle h_FmPort, uint8_t poolId, uint32_t value)
+t_Error FM_PORT_ModifyAllocBufCounter(t_Handle h_FmPort, uint8_t poolId, uint32_t value)
 {
     t_FmPort        *p_FmPort = (t_FmPort *)h_FmPort;
     uint32_t        extPoolReg;
@@ -3117,7 +3310,7 @@ t_Error FM_PORT_PcdPlcrFreeProfiles(t_Handle h_FmPort)
     return E_OK;
 }
 
-t_Error            FM_PORT_PcdKgModifyInitialScheme (t_Handle h_FmPort, t_FmPcdKgSchemeSelect *p_FmPcdKgScheme)
+t_Error FM_PORT_PcdKgModifyInitialScheme (t_Handle h_FmPort, t_FmPcdKgSchemeSelect *p_FmPcdKgScheme)
 {
     t_FmPort                *p_FmPort = (t_FmPort*)h_FmPort;
     volatile uint32_t       *p_BmiHpnia = NULL;
@@ -3137,7 +3330,7 @@ t_Error            FM_PORT_PcdKgModifyInitialScheme (t_Handle h_FmPort, t_FmPcdK
         case(e_FM_PORT_TYPE_RX):
             p_BmiHpnia = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfpne;
             break;
-        case(e_FM_PORT_TYPE_OFFLINE_PARSING):
+        case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
             p_BmiHpnia = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofpne;
             break;
         default:
@@ -3203,7 +3396,7 @@ t_Error     FM_PORT_PcdPlcrModifyInitialProfile (t_Handle h_FmPort, t_Handle h_P
             p_BmiHpnia = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfpne;
             tmpReg = GET_UINT32(*p_BmiNia) & BMI_RFNE_FDCS_MASK;
             break;
-        case(e_FM_PORT_TYPE_OFFLINE_PARSING):
+        case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
             p_BmiNia = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofne;
             p_BmiHpnia = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofpne;
             tmpReg = 0;
@@ -3258,7 +3451,7 @@ t_Error          FM_PORT_PcdCcModifyTree (t_Handle h_FmPort, t_Handle h_CcTree)
         case(e_FM_PORT_TYPE_RX):
             p_BmiNia = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfne;
             break;
-        case(e_FM_PORT_TYPE_OFFLINE_PARSING):
+        case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
             p_BmiNia = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofne;
         break;
         default:
@@ -3278,10 +3471,11 @@ t_Error          FM_PORT_PcdCcModifyTree (t_Handle h_FmPort, t_Handle h_CcTree)
             case(e_FM_PORT_TYPE_RX):
                 p_BmiCcBase = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rccb;
                 break;
-            case(e_FM_PORT_TYPE_OFFLINE_PARSING):
+            case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
                 p_BmiCcBase = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_occb;
             break;
             default:
+                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid port type"));
                 break;
         }
 
@@ -3350,7 +3544,7 @@ t_Error FM_PORT_DetachPCD(t_Handle h_FmPort)
         case(e_FM_PORT_TYPE_RX):
             p_BmiNia = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfne;
             break;
-        case(e_FM_PORT_TYPE_OFFLINE_PARSING):
+        case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
             p_BmiNia = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofne;
         break;
         default:
@@ -3481,7 +3675,7 @@ t_Error FM_PORT_PcdKgModifyClsPlanGrp (t_Handle h_FmPort, bool useClsPlan, t_Han
         case(e_FM_PORT_TYPE_RX):
             p_BmiNia = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfne;
             break;
-        case(e_FM_PORT_TYPE_OFFLINE_PARSING):
+        case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
             p_BmiNia = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofne;
         break;
         default:
@@ -3691,7 +3885,7 @@ t_Error FM_PORT_PcdPrsModifyStartOffset (t_Handle h_FmPort, t_FmPcdPrsStart *p_F
             p_BmiNia = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfne;
             tmpReg = GET_UINT32(*p_BmiNia) & BMI_RFNE_FDCS_MASK;
             break;
-        case(e_FM_PORT_TYPE_OFFLINE_PARSING):
+        case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
             p_BmiPrsStartOffset = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_opso;
             p_BmiNia = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofne;
             tmpReg = 0;
@@ -3700,6 +3894,10 @@ t_Error FM_PORT_PcdPrsModifyStartOffset (t_Handle h_FmPort, t_FmPcdPrsStart *p_F
             RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx and offline parsing ports only"));
     }
 
+    /* check that current NIA is BMI to BMI */
+    if((GET_UINT32(*p_BmiNia) & ~BMI_RFNE_FDCS_MASK) != (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME))
+            RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("may be called only for ports in BMI-to-BMI state."));
+
     TRY_LOCK_RET_ERR(p_FmPort->lock);
     /* set the first header */
     GET_PRS_HDR_NUM(hdrNum, p_FmPcdPrsStart->firstPrsHdr);
@@ -3738,11 +3936,11 @@ t_Error FM_PORT_DumpRegs(t_Handle h_FmPort)
 
     switch (p_FmPort->portType)
     {
-        case (e_FM_PORT_TYPE_OFFLINE_PARSING):
+        case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
             strcpy(arr, "PORT_TYPE_OFFLINE_PARSING");
             flag = 0;
             break;
-        case (e_FM_PORT_TYPE_HOST_COMMAND):
+        case (e_FM_PORT_TYPE_OH_HOST_COMMAND):
             strcpy(arr, "PORT_TYPE_HOST_COMMAND");
             flag = 0;
             break;
@@ -3791,7 +3989,7 @@ t_Error FM_PORT_DumpRegs(t_Handle h_FmPort)
         DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_occb);
 
         DUMP_TITLE(&(p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_oprai), ("fmbm_oprai"));
-        DUMP_SUBSTRUCT_ARRAY(i, PRS_RESULT_NUM_OF_WORDS)
+        DUMP_SUBSTRUCT_ARRAY(i, FM_PORT_PRS_RESULT_NUM_OF_WORDS)
         {
             DUMP_MEMORY(&(p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_oprai[i]), sizeof(uint32_t));
         }
@@ -3834,7 +4032,7 @@ t_Error FM_PORT_DumpRegs(t_Handle h_FmPort)
         DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rpp);
 
         DUMP_TITLE(&(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rprai), ("fmbm_rprai"));
-        DUMP_SUBSTRUCT_ARRAY(i, PRS_RESULT_NUM_OF_WORDS)
+        DUMP_SUBSTRUCT_ARRAY(i, FM_PORT_PRS_RESULT_NUM_OF_WORDS)
         {
             DUMP_MEMORY(&(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rprai[i]), sizeof(uint32_t));
         }
@@ -3912,6 +4110,7 @@ t_Error FM_PORT_DumpRegs(t_Handle h_FmPort)
         break;
 
    default:
+       RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid flag"));
         break;
     }
 
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/Port/fm_port.h b/drivers/net/dpa/NetCommSw/Peripherals/FM/Port/fm_port.h
index 1563480..509607d 100644
--- a/drivers/net/dpa/NetCommSw/Peripherals/FM/Port/fm_port.h
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/Port/fm_port.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -45,7 +45,12 @@
 #include "fm_common.h"
 
 
+#define __ERR_MODULE__  MODULE_FM_PORT
+
+
 #define MIN_EXT_BUF_SIZE                                64
+#define DATA_ALIGNMENT                                  64
+
 /**************************************************************************//**
  @Description       Memory Map defines
 *//***************************************************************************/
@@ -56,20 +61,25 @@
 /**************************************************************************//**
  @Description       defaults
 *//***************************************************************************/
-
-#define DEFAULT_PORT_deqHighPriority                    FALSE
+#define DEFAULT_PORT_deqHighPriority                    TRUE
 #define DEFAULT_PORT_deqType                            e_FM_PORT_DEQ_TYPE1
-#define DEFAULT_PORT_deqPrefetchOption                  e_FM_PORT_DEQ_NO_PREFETCH
+#define DEFAULT_PORT_deqPrefetchOption                  e_FM_PORT_DEQ_FULL_PREFETCH
+#define DEFAULT_PORT_deqPrefetchOption_HC               e_FM_PORT_DEQ_NO_PREFETCH
 #define DEFAULT_PORT_deqByteCnt                         2000
 #define DEFAULT_PORT_bufferPrefixContent_privDataSize   0
-#define DEFAULT_PORT_bufferPrefixContent_passPrsResult  TRUE
+#define DEFAULT_PORT_bufferPrefixContent_passPrsResult  FALSE
 #define DEFAULT_PORT_bufferPrefixContent_passTimeStamp  FALSE
-
+#define DEFAULT_PORT_bufferPrefixContent_allOtherPCDInfo    FALSE
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+#define DEFAULT_PORT_bufferPrefixContent_debugInfo      FALSE
+#endif /*(defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))*/
+#define DEFAULT_PORT_bufferPrefixContent_dataAlign      DATA_ALIGNMENT
 #define DEFAULT_PORT_cheksumLastBytesIgnore             0
 #define DEFAULT_PORT_cutBytesFromEnd                    4
 #define DEFAULT_PORT_txFifoMinFillLevel                 0
-#define DEFAULT_PORT_txFifoDeqPipelineDepth_1G          1
-#define DEFAULT_PORT_txFifoDeqPipelineDepth_10G         4
+#define DEFAULT_PORT_txFifoDeqPipelineDepth_IM          1
+#define DEFAULT_PORT_txFifoDeqPipelineDepth_1G          2
+#define DEFAULT_PORT_txFifoDeqPipelineDepth_10G         8
 #define DEFAULT_PORT_txFifoLowComfLevel                 (5*KILOBYTE)
 #define DEFAULT_PORT_rxFifoPriElevationLevel            (160*KILOBYTE)
 #define DEFAULT_PORT_rxFifoThreshold                    (128*KILOBYTE)
@@ -78,19 +88,14 @@
 #define DEFAULT_PORT_dmaIntContextCacheAttr             e_FM_PORT_DMA_NO_STASH
 #define DEFAULT_PORT_dmaHeaderCacheAttr                 e_FM_PORT_DMA_NO_STASH
 #define DEFAULT_PORT_dmaScatterGatherCacheAttr          e_FM_PORT_DMA_NO_STASH
-#define DEFAULT_PORT_dmaReadOptimize                    FALSE
-#define DEFAULT_PORT_dmaWriteOptimize                   FALSE
+#define DEFAULT_PORT_dmaWriteOptimize                   TRUE
 #define DEFAULT_PORT_forwardIntContextReuse             FALSE
 #define DEFAULT_PORT_l4Checksum                         TRUE
 #define DEFAULT_PORT_BufMargins_startMargins            32
 #define DEFAULT_PORT_BufMargins_endMargins              0
-#ifdef FM_PORT_SYNC_ERRATA
-#define DEFAULT_PORT_syncReq                            FALSE
-#else
 #define DEFAULT_PORT_syncReq                            TRUE
-#endif /* FM_PORT_SYNC_ERRATA */
 #define DEFAULT_PORT_color                              e_FM_PORT_COLOR_GREEN
-#define DEFAULT_PORT_errorsToDiscard                    0
+#define DEFAULT_PORT_errorsToDiscard                    FM_PORT_FRM_ERR_CLS_DISCARD
 
 /* Host command port MUST NOT be changed to more than 1 !!! */
 #define DEFAULT_PORT_numOfTasks(type)                   \
@@ -98,14 +103,14 @@
                 (type == e_FM_PORT_TYPE_TX_10G)) ? 16 : \
                (((type == e_FM_PORT_TYPE_RX) ||         \
                  (type == e_FM_PORT_TYPE_TX) ||         \
-                 (type == e_FM_PORT_TYPE_OFFLINE_PARSING)) ? 3 : 1))
+                 (type == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)) ? 3 : 1))
 
 #define DEFAULT_PORT_extraNumOfTasks(type)              \
     (uint32_t)(((type == e_FM_PORT_TYPE_RX_10G) ||      \
                 (type == e_FM_PORT_TYPE_TX_10G)) ? 8 :  \
                (((type == e_FM_PORT_TYPE_RX) ||         \
                  (type == e_FM_PORT_TYPE_TX) ||         \
-                 (type == e_FM_PORT_TYPE_OFFLINE_PARSING)) ? 2 : 0))
+                 (type == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)) ? 2 : 0))
 
 #define DEFAULT_PORT_numOfOpenDmas(type)                \
     (uint32_t)(((type == e_FM_PORT_TYPE_RX_10G) ||      \
@@ -116,33 +121,32 @@
                 (type == e_FM_PORT_TYPE_TX_10G)) ? 8 :  \
                (((type == e_FM_PORT_TYPE_RX) ||         \
                  (type == e_FM_PORT_TYPE_TX) ||         \
-                 (type == e_FM_PORT_TYPE_OFFLINE_PARSING)) ? 1 : 0))
+                 (type == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)) ? 1 : 0))
 
 #define DEFAULT_PORT_sizeOfFifo(type)                               \
     (uint32_t)(((type == e_FM_PORT_TYPE_RX_10G) ||                  \
                 (type == e_FM_PORT_TYPE_TX_10G)) ? (16*KILOBYTE) :  \
                (((type == e_FM_PORT_TYPE_RX) ||                     \
                  (type == e_FM_PORT_TYPE_TX) ||                     \
-                 (type == e_FM_PORT_TYPE_OFFLINE_PARSING)) ? (4*KILOBYTE) : (1*KILOBYTE)))
+                 (type == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)) ? (4*KILOBYTE) : (1*KILOBYTE)))
 
 #define DEFAULT_PORT_extraSizeOfFifo(type)              \
     (uint32_t)(((type == e_FM_PORT_TYPE_RX_10G) ||      \
                 (type == e_FM_PORT_TYPE_RX)) ? (16*KILOBYTE) : 0)
 
-#define DEFAULT_PORT_ImMaxRxBufLength               1024
 #define DEFAULT_PORT_txBdRingLength                 16
 #define DEFAULT_PORT_rxBdRingLength                 128
 #define DEFAULT_PORT_ImfwExtStructsMemId            0
 #define DEFAULT_PORT_Im_fwExtStructsMemAttr         MEMORY_ATTR_CACHEABLE
 
-
+#define OH_PIPELINE_DEPTH                           2
 /**************************************************************************//**
  @Description       Memory Mapped Registers
 *//***************************************************************************/
 
-#ifdef __MWERKS__
+#if defined(__MWERKS__) && !defined(__GNUC__)
 #pragma pack(push,1)
-#endif /*__MWERKS__ */
+#endif /* defined(__MWERKS__) && ... */
 #define MEM_MAP_START
 
 typedef _Packed struct
@@ -162,7 +166,7 @@ typedef _Packed struct
     volatile uint32_t   fmbm_rpp;       /**< Rx Policer Profile  */
     volatile uint32_t   fmbm_rccb;      /**< Rx Coarse Classification Base */
     volatile uint32_t   reserved1[2];   /**< (0x038 0x03F) */
-    volatile uint32_t   fmbm_rprai[PRS_RESULT_NUM_OF_WORDS];
+    volatile uint32_t   fmbm_rprai[FM_PORT_PRS_RESULT_NUM_OF_WORDS];
                                         /**< Rx Parse Results Array Initialization*/
     volatile uint32_t   fmbm_rfqid;     /**< Rx Frame Queue ID*/
     volatile uint32_t   fmbm_refqid;    /**< Rx Error Frame Queue ID*/
@@ -249,7 +253,7 @@ typedef _Packed struct
     volatile uint32_t   fmbm_occb;      /**< O/H Coarse Classification base */
     volatile uint32_t   fmbm_oim;       /**< O/H Internal margins*/
     volatile uint32_t   reserved0[4];   /**< (0x030 - 0x03F) */
-    volatile uint32_t   fmbm_oprai[PRS_RESULT_NUM_OF_WORDS];
+    volatile uint32_t   fmbm_oprai[FM_PORT_PRS_RESULT_NUM_OF_WORDS];
                                         /**< O/H Parse Results Array Initialization  */
     volatile uint32_t   fmbm_ofqid;     /**< O/H Frame Queue ID  */
     volatile uint32_t   fmbm_oefqid;    /**< O/H Error Frame Queue ID  */
@@ -307,11 +311,11 @@ typedef _Packed struct
 
 typedef _Packed struct
 {
-    struct
+    _Packed struct
     {
         volatile uint32_t   softSeqAttach;  /**<   Soft Sequence Attachment */
         volatile uint32_t   lcv;            /**<   Line-up Enable Confirmation Mask */
-    } hdrs[FM_PCD_PRS_NUM_OF_HDRS];
+    } _PackedType hdrs[FM_PCD_PRS_NUM_OF_HDRS];
     volatile uint8_t    reserved0[0x378];
     volatile uint32_t   pcac;               /**<   Parse Internal Memory Configuration Access Control Register */
     volatile uint32_t   pctpid;             /**<   Parse Internal Memory Configured TPID Register */
@@ -325,17 +329,19 @@ typedef _Packed struct
     volatile uint16_t       status;
     volatile uint16_t       length;
     volatile uint8_t        reserved0[0x6];
+    volatile uint8_t        reserved1[0x1];
     volatile t_FmPhysAddr   buff;
 } _PackedType t_FmImBd;
 
 typedef _Packed struct
 {
     volatile uint16_t       gen;                /**< tbd */
+    volatile uint8_t        reserved0[0x1];
     volatile t_FmPhysAddr   bdRingBase;         /**< tbd */
     volatile uint16_t       bdRingSize;         /**< tbd */
     volatile uint16_t       offsetIn;           /**< tbd */
     volatile uint16_t       offsetOut;          /**< tbd */
-    volatile uint8_t        reserved0[0x12];    /**< 0x0e - 0x1f */
+    volatile uint8_t        reserved1[0x12];    /**< 0x0e - 0x1f */
 } _PackedType t_FmPortImQd;
 
 typedef _Packed struct
@@ -352,9 +358,9 @@ typedef _Packed struct
 } _PackedType t_FmPortImPram;
 
 #define MEM_MAP_END
-#ifdef __MWERKS__
+#if defined(__MWERKS__) && !defined(__GNUC__)
 #pragma pack(pop)
-#endif /* __MWERKS__ */
+#endif /* defined(__MWERKS__) && ... */
 
 
 /**************************************************************************//**
@@ -369,7 +375,6 @@ typedef _Packed struct
 #define BMI_PORT_CFG_IM                         0x01000000
 #define BMI_PORT_STATUS_BSY                     0x80000000
 #define BMI_COUNTERS_EN                         0x80000000
-#define BMI_DMA_ATTR_READ_OPTIMIZE              0x00400000
 #define BMI_DMA_ATTR_WRITE_OPTIMIZE             0x00100000
 #define BMI_PORT_RFNE_FRWD_DCL4C                0x10000000
 #define BMI_PORT_RFNE_FRWD_RPD                  0x40000000
@@ -411,24 +416,22 @@ typedef _Packed struct
 #define BMI_PRS_RESULT_HIGH                     0x00000000
 #define BMI_PRS_RESULT_LOW                      0xFFFFFFFF
 
-#define RX_ERRS_TO_ENQ                      (FM_PORT_FRM_ERR_DMA             |\
-                                                         FM_PORT_FRM_ERR_PHYSICAL        |\
-                                                         FM_PORT_FRM_ERR_SIZE            |\
-                                                         FM_PORT_FRM_ERR_CLS_DISCARD     |\
-                                                         FM_PORT_FRM_ERR_EXTRACTION      |\
-                                                         FM_PORT_FRM_ERR_NO_SCHEME       |\
-                                                         FM_PORT_FRM_ERR_COLOR_RED       |\
-                                                         FM_PORT_FRM_ERR_ILL_PLCR        |\
-                                                         FM_PORT_FRM_ERR_PLCR_FRAME_LEN  |\
-                                                         FM_PORT_FRM_ERR_PRS_TIMEOUT     |\
-                                                         FM_PORT_FRM_ERR_PRS_ILL_INSTRUCT|\
-                                                         FM_PORT_FRM_ERR_PRS_HDR_ERR     |\
-                                                         FM_PORT_FRM_ERR_PROCESS_TIMEOUT |\
-                                                         FM_PORT_FRM_ERR_KEYSIZE_OVERFLOW)
-
-#define OP_ERRS_TO_ENQ                      (RX_ERRS_TO_ENQ      |\
-                                                         FM_PORT_FRM_ERR_LENGTH          |\
-                                                         FM_PORT_FRM_ERR_UNSUPPORTED_FORMAT)
+#define RX_ERRS_TO_ENQ                          (FM_PORT_FRM_ERR_DMA             |\
+                                                 FM_PORT_FRM_ERR_PHYSICAL        |\
+                                                 FM_PORT_FRM_ERR_SIZE            |\
+                                                 FM_PORT_FRM_ERR_EXTRACTION      |\
+                                                 FM_PORT_FRM_ERR_NO_SCHEME       |\
+                                                 FM_PORT_FRM_ERR_ILL_PLCR        |\
+                                                 FM_PORT_FRM_ERR_PLCR_FRAME_LEN  |\
+                                                 FM_PORT_FRM_ERR_PRS_TIMEOUT     |\
+                                                 FM_PORT_FRM_ERR_PRS_ILL_INSTRUCT|\
+                                                 FM_PORT_FRM_ERR_PRS_HDR_ERR     |\
+                                                 FM_PORT_FRM_ERR_PROCESS_TIMEOUT |\
+                                                 FM_PORT_FRM_ERR_KEYSIZE_OVERFLOW)
+
+#define OP_ERRS_TO_ENQ                          (RX_ERRS_TO_ENQ      |\
+                                                 FM_PORT_FRM_ERR_LENGTH          |\
+                                                 FM_PORT_FRM_ERR_UNSUPPORTED_FORMAT)
 
 /* shifts */
 #define BMI_DMA_ATTR_SWP_SHIFT                  30
@@ -483,7 +486,7 @@ typedef _Packed struct
 #define MAX_EXT_OFFSET                          496
 #define MAX_EXT_BUFFER_OFFSET                   511
 #define MAX_INT_OFFSET                          240
-#define MIN_TX_INT_OFFSET                       32
+#define MIN_TX_INT_OFFSET                       16
 #define MAX_IC_SIZE                             256
 #define MAX_FRAME_OFFSET                        64
 #define MAX_FIFO_PIPELINE_DEPTH                 8
@@ -606,10 +609,14 @@ typedef _Packed struct
 
 /* masks */
 #define IM_MODE_GBL                             0x20000000
+#define IM_MODE_BO_MASK                         0x18000000
+#define IM_MODE_BO_SHIFT                        3
+#define IM_MODE_GRC_STP                         0x00800000
+
+#define IM_MODE_SET_BO(val)                     (uint32_t)((val << (31-IM_MODE_BO_SHIFT)) & IM_MODE_BO_MASK)
 
 
 typedef struct {
-    t_Handle                    h_App;
     t_Handle                    h_FmMuram;
     t_FmPortImPram              *p_FmPortImPram;
     uint8_t                     fwExtStructsMemId;
@@ -626,11 +633,11 @@ typedef struct {
     t_BufferPoolInfo            rxPool;
     uint16_t                    mrblr;
     uint16_t                    rxFrameAccumLength;
-    t_FmPortImRxStoreFunction   *f_RxStoreCB;
+    t_FmPortImRxStoreCallback   *f_RxStore;
 
     /* Tx port parameters */
     uint32_t                    txFirstBdStatus;
-    t_FmPortImTxConfFunction    *f_TxConfCB;
+    t_FmPortImTxConfCallback    *f_TxConf;
 } t_FmMacIm;
 
 /**************************************************************************//**
@@ -659,7 +666,12 @@ typedef struct{
     uint32_t      dataOffset;
     uint32_t      prsResultOffset;
     uint32_t      timeStampOffset;
-} t_FmPortBufferOffsets;
+    uint32_t      hashResultOffset;
+    uint32_t      pcdInfoOffset;
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+    uint32_t      debugOffset;
+#endif /*(defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))*/
+    } t_FmPortBufferOffsets;
 
 typedef struct
 {
@@ -681,7 +693,7 @@ typedef struct
     bool                        enRateLimit;
     t_FmPortRateLimit           rateLimit;
     bool                        enBufPoolDepletion;
-    uint8_t                     partitionId;
+    uint16_t                    partitionId;
     t_FmPortRxExtPools          rxExtBufPools;
     t_FmPortRsrc                openDmas;
     t_FmPortRsrc                tasks;
@@ -702,7 +714,8 @@ typedef struct
     e_FmPortColor               color;
     fmPortFrameErrSelect_t      errorsToDiscard;
     fmPortFrameErrSelect_t      errorsToEnq;
-    uint32_t                    timeStampPeriod;
+//    uint32_t                    timeStampPeriod;
+    uint8_t                     count1MicroBit;
     uint64_t                    fmMuramPhysBaseAddr;
     bool                        forwardReuseIntContext;
     bool                        l4Checksum;
@@ -718,6 +731,7 @@ typedef struct
     t_Handle                    h_FmPcd;
     uint8_t                     portId;
     e_FmPortType                portType;
+    char                        name[MODULE_NAME_SIZE];
     uint8_t                     hardwarePortId;
     uint16_t                    fmClkFreq;
     t_FmPortQmiRegs             *p_FmPortQmiRegs;
@@ -726,7 +740,7 @@ typedef struct
     fmPcdEngines_t              pcdEngines;
     uint32_t                    savedBmiNia;
     uint8_t                     netEnvId;
-    uint32_t                    optArray[MAX_NUM_OF_OPTIONS];
+    uint32_t                    optArray[FM_PCD_MAX_NUM_OF_OPTIONS];
     uint32_t                    lcvs[FM_PCD_PRS_NUM_OF_HDRS];
     uint8_t                     privateInfo;
     uint32_t                    schemesPerPortVector;
@@ -742,6 +756,8 @@ typedef struct
     uint8_t                     txFifoDeqPipelineDepth;
     t_FmPortDriverParam         *p_FmPortDriverParam;
     volatile bool               lock;
+    t_FmPortExceptionCallback   *f_Exception;
+    t_Handle                    h_App;
 } t_FmPort;
 
 #ifndef CONFIG_MULTI_PARTITION_SUPPORT
@@ -755,24 +771,28 @@ t_Error FmPortImCheckInitParameters(t_FmPort *p_FmPort);
 t_Error FmPortImInit(t_FmPort *p_FmPort);
 void    FmPortImFree(t_FmPort *p_FmPort);
 
-t_Error FmPortImRx  (t_FmPort *p_FmPort);
+t_Error FmPortImEnable  (t_FmPort *p_FmPort);
+t_Error FmPortImDisable (t_FmPort *p_FmPort);
+t_Error FmPortImRx      (t_FmPort *p_FmPort);
 
 
 static __inline__ uint8_t * BD_BUFFER (t_FmImBd *p_Bd)
 {
-/* TODO - complete */
-    return XX_PhysToVirt(CAST_UINT32_TO_POINTER(GET_UINT32(p_Bd->buff.low)));
+    uint64_t    physAddr = (uint64_t)((uint64_t)GET_UINT16(p_Bd->buff.high) << 32);
+    physAddr |= GET_UINT32(p_Bd->buff.low);
+
+    return (uint8_t *)XX_PhysToVirt((physAddress_t)(physAddr));
 }
 
 static __inline__ void SET_ADDR(volatile t_FmPhysAddr *fmPhysAddr, uint64_t value)
 {
-    WRITE_UINT16(fmPhysAddr->high,(uint16_t)((value & 0x0000ffff00000000LL) >> 32));
+    WRITE_UINT8(fmPhysAddr->high,(uint8_t)((value & 0x000000ff00000000LL) >> 32));
     WRITE_UINT32(fmPhysAddr->low,(uint32_t)value);
 }
 
 static __inline__ void BD_BUFFER_SET(t_FmImBd *p_Bd, uint8_t *p_Buffer)
 {
-    uint64_t    physAddr = CAST_POINTER_TO_UINT64(XX_VirtToPhys(p_Buffer));
+    uint64_t    physAddr = (uint64_t)(XX_VirtToPhys(p_Buffer));
     SET_ADDR(&p_Bd->buff, physAddr);
 }
 
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/Port/fm_port_im.c b/drivers/net/dpa/NetCommSw/Peripherals/FM/Port/fm_port_im.c
index 0ca83d7..4c02f74 100644
--- a/drivers/net/dpa/NetCommSw/Peripherals/FM/Port/fm_port_im.c
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/Port/fm_port_im.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -100,57 +100,68 @@ static void DiscardCurrentTxFrame(t_FmPort *p_FmPort)
     p_FmPort->im.firstBdOfFrameId = IM_ILEGAL_BD_ID;
 }
 
-static t_Error FmPortTxConf(t_FmPort *p_FmPort, e_TxConfType confType)
+static t_Error TxConf(t_FmPort *p_FmPort, e_TxConfType confType)
 {
     t_Error             retVal = E_BUSY;
     uint32_t            bdStatus;
-    uint16_t            savedStartBdId;
+    uint16_t            savedStartBdId, confBdId;
 
     ASSERT_COND(p_FmPort);
 
 //    if (confType==e_TX_CONF_TYPE_CHECK)
 //        return (WfqEntryIsQueueEmpty(p_FmPort->im.h_WfqEntry) ? E_OK : E_BUSY);
 
-    savedStartBdId = p_FmPort->im.currBdId;
-    bdStatus = BD_STATUS_AND_LENGTH(BD_GET(p_FmPort->im.currBdId));
+    confBdId = savedStartBdId = p_FmPort->im.currBdId;
+    bdStatus = BD_STATUS_AND_LENGTH(BD_GET(confBdId));
 
-    /* if R bit is set, we don't enter, or we break.
-    we run till we get to R, or complete the loop */
+    /* If R bit is set, we don't enter, or we break.
+       we run till we get to R, or complete the loop */
     while ((!(bdStatus & BD_R_E) || (confType == e_TX_CONF_TYPE_FLUSH)) && (retVal != E_OK))
     {
         if (confType & e_TX_CONF_TYPE_CALLBACK) /* if it is confirmation with user callbacks */
-            BD_STATUS_AND_LENGTH_SET(BD_GET(p_FmPort->im.currBdId), 0);
+            BD_STATUS_AND_LENGTH_SET(BD_GET(confBdId), 0);
 
         /* case 1: R bit is 0 and Length is set -> confirm! */
         if ((confType & e_TX_CONF_TYPE_CALLBACK) && (bdStatus & BD_LENGTH_MASK))
         {
-            if (p_FmPort->im.f_TxConfCB)
+            if (p_FmPort->im.f_TxConf)
             {
                 if ((confType == e_TX_CONF_TYPE_FLUSH) && (bdStatus & BD_R_E))
-                    p_FmPort->im.f_TxConfCB(p_FmPort->im.h_App,
-                                            BD_BUFFER(BD_GET(p_FmPort->im.currBdId)),
-                                            TX_CONF_STATUS_UNSENT,
-                                            p_FmPort->im.p_BdShadow[p_FmPort->im.currBdId]);
+                    p_FmPort->im.f_TxConf(p_FmPort->h_App,
+                                          BD_BUFFER(BD_GET(confBdId)),
+                                          TX_CONF_STATUS_UNSENT,
+                                          p_FmPort->im.p_BdShadow[confBdId]);
                 else
-                    p_FmPort->im.f_TxConfCB(p_FmPort->im.h_App,
-                                            BD_BUFFER(BD_GET(p_FmPort->im.currBdId)),
-                                            0,
-                                            p_FmPort->im.p_BdShadow[p_FmPort->im.currBdId]);
+                    p_FmPort->im.f_TxConf(p_FmPort->h_App,
+                                          BD_BUFFER(BD_GET(confBdId)),
+                                          0,
+                                          p_FmPort->im.p_BdShadow[confBdId]);
             }
         }
         /* case 2: R bit is 0 and Length is 0 -> not used yet, nop! */
 
-        p_FmPort->im.currBdId = GetNextBdId(p_FmPort, p_FmPort->im.currBdId);
-        if (p_FmPort->im.currBdId == savedStartBdId)
+        confBdId = GetNextBdId(p_FmPort, confBdId);
+        if (confBdId == savedStartBdId)
             retVal = E_OK;
-        bdStatus = BD_STATUS_AND_LENGTH(BD_GET(p_FmPort->im.currBdId));
+        bdStatus = BD_STATUS_AND_LENGTH(BD_GET(confBdId));
     }
 
-    MY_WRITE_UINT16(p_FmPort->im.p_FmPortImPram->txQd.offsetIn, (uint16_t)(p_FmPort->im.currBdId<<4));
-
     return retVal;
 }
 
+t_Error FmPortImEnable(t_FmPort *p_FmPort)
+{
+    uint32_t    tmpReg = GET_UINT32(p_FmPort->im.p_FmPortImPram->mode);
+    WRITE_UINT32(p_FmPort->im.p_FmPortImPram->mode, (uint32_t)(tmpReg & ~IM_MODE_GRC_STP));
+    return E_OK;
+}
+
+t_Error FmPortImDisable(t_FmPort *p_FmPort)
+{
+    uint32_t    tmpReg = GET_UINT32(p_FmPort->im.p_FmPortImPram->mode);
+    WRITE_UINT32(p_FmPort->im.p_FmPortImPram->mode, (uint32_t)(tmpReg | IM_MODE_GRC_STP));
+    return E_OK;
+}
 
 t_Error FmPortImRx(t_FmPort *p_FmPort)
 {
@@ -198,19 +209,7 @@ t_Error FmPortImRx(t_FmPort *p_FmPort)
 
         BD_STATUS_AND_LENGTH_SET(BD_GET(p_FmPort->im.currBdId), BD_R_E);
 
-/* TODO - add here support for errors!!! */
         errors = (uint16_t)((bdStatus & BD_RX_ERRORS) >> 16);
-#if 0
-        /* find out which errors the user wants reported. The BD will
-        still be passed to the user, but first f_Exceptions will be called */
-        reportErrors = (uint16_t)(errors & p_FmPort->im.bdErrorsReport);
-        if(reportErrors)
-        {
-            QUEUE_GET_EXCEPTIONS(reportErrors, exceptions);
-            p_FmPort->im.f_Exceptions(p_FmPort->im.h_App, exceptions, 0);
-        }
-#endif /* 0 */
-
         p_FmPort->im.p_BdShadow[p_FmPort->im.currBdId] = h_NewUserPriv;
 
         p_FmPort->im.currBdId = GetNextBdId(p_FmPort, p_FmPort->im.currBdId);
@@ -222,12 +221,12 @@ t_Error FmPortImRx(t_FmPort *p_FmPort)
         - There is an error, but it was defined to be passed anyway. */
         if ((buffPos != SINGLE_BUF) || !errors || (errors & (uint16_t)(BD_ERROR_PASS_FRAME>>16)))
         {
-            if (p_FmPort->im.f_RxStoreCB(p_FmPort->im.h_App,
-                                         p_CurData,
-                                         length,
-                                         errors,
-                                         buffPos,
-                                         h_CurrUserPriv) == e_RX_STORE_RESPONSE_PAUSE)
+            if (p_FmPort->im.f_RxStore(p_FmPort->h_App,
+                                       p_CurData,
+                                       length,
+                                       errors,
+                                       buffPos,
+                                       h_CurrUserPriv) == e_RX_STORE_RESPONSE_PAUSE)
                 break;
         }
         else if (p_FmPort->im.rxPool.f_PutBuf(p_FmPort->im.rxPool.h_BufferPool,
@@ -247,7 +246,6 @@ t_Error FmPortConfigIM (t_FmPort *p_FmPort, t_FmPortParams *p_FmPortParams)
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
 
-    p_FmPort->im.h_App                          = p_FmPortParams->specificParams.imRxTxParams.h_App;
     p_FmPort->im.h_FmMuram                      = p_FmPortParams->specificParams.imRxTxParams.h_FmMuram;
     p_FmPort->p_FmPortDriverParam->partitionId  = p_FmPortParams->specificParams.imRxTxParams.partitionId;
     p_FmPort->im.dataMemId                      = p_FmPortParams->specificParams.imRxTxParams.dataMemId;
@@ -263,14 +261,22 @@ t_Error FmPortConfigIM (t_FmPort *p_FmPort, t_FmPortParams *p_FmPortParams)
         p_FmPort->im.rxPool.f_GetBuf        = p_FmPortParams->specificParams.imRxTxParams.rxPoolParams.f_GetBuf;
         p_FmPort->im.rxPool.f_PutBuf        = p_FmPortParams->specificParams.imRxTxParams.rxPoolParams.f_PutBuf;
         p_FmPort->im.rxPool.bufferSize      = p_FmPortParams->specificParams.imRxTxParams.rxPoolParams.bufferSize;
-        p_FmPort->im.f_RxStoreCB            = p_FmPortParams->specificParams.imRxTxParams.f_RxStoreCB;
+        p_FmPort->im.f_RxStore              = p_FmPortParams->specificParams.imRxTxParams.f_RxStore;
 
-        p_FmPort->im.mrblr                  = DEFAULT_PORT_ImMaxRxBufLength;
+        p_FmPort->im.mrblr                  = 0x8000;
+        while (p_FmPort->im.mrblr)
+        {
+            if (p_FmPort->im.rxPool.bufferSize & p_FmPort->im.mrblr)
+                break;
+            p_FmPort->im.mrblr >>= 1;
+        }
+        if (p_FmPort->im.mrblr != p_FmPort->im.rxPool.bufferSize)
+            DBG(WARNING, ("Max-Rx-Buffer-Length set to %d", p_FmPort->im.mrblr));
         p_FmPort->im.bdRingSize             = DEFAULT_PORT_rxBdRingLength;
     }
     else
     {
-        p_FmPort->im.f_TxConfCB             = p_FmPortParams->specificParams.imRxTxParams.f_TxConfCB;
+        p_FmPort->im.f_TxConf               = p_FmPortParams->specificParams.imRxTxParams.f_TxConf;
 
         p_FmPort->im.bdRingSize             = DEFAULT_PORT_txBdRingLength;
     }
@@ -308,7 +314,7 @@ t_Error FmPortImCheckInitParameters(t_FmPort *p_FmPort)
 t_Error FmPortImInit(t_FmPort *p_FmPort)
 {
     t_FmImBd    *p_Bd=NULL;
-    t_Handle    h_UserPriv;
+    t_Handle    h_BufContext;
     uint64_t    tmpPhysBase;
     uint16_t    log2Num;
     uint8_t     *p_Data/*, *p_Tmp*/;
@@ -341,30 +347,33 @@ t_Error FmPortImInit(t_FmPort *p_FmPort)
             p_Bd = BD_GET(i);
             BD_STATUS_AND_LENGTH_SET (p_Bd, BD_R_E);
 
-            if ((p_Data = p_FmPort->im.rxPool.f_GetBuf(p_FmPort->im.rxPool.h_BufferPool, &h_UserPriv)) == NULL)
+            if ((p_Data = p_FmPort->im.rxPool.f_GetBuf(p_FmPort->im.rxPool.h_BufferPool, &h_BufContext)) == NULL)
                 RETURN_ERROR(MAJOR, E_NOT_AVAILABLE, ("Data buffer"));
             BD_BUFFER_SET(p_Bd, p_Data);
-            p_FmPort->im.p_BdShadow[i] = h_UserPriv;
+            p_FmPort->im.p_BdShadow[i] = h_BufContext;
         }
 
-        if (p_FmPort->im.dataMemAttributes & MEMORY_ATTR_CACHEABLE)
-            WRITE_UINT32(p_FmPort->im.p_FmPortImPram->mode, IM_MODE_GBL);
+        if ((p_FmPort->im.dataMemAttributes & MEMORY_ATTR_CACHEABLE) ||
+            (p_FmPort->im.fwExtStructsMemAttr & MEMORY_ATTR_CACHEABLE))
+            WRITE_UINT32(p_FmPort->im.p_FmPortImPram->mode, IM_MODE_GBL | IM_MODE_SET_BO(2));
+        else
+            WRITE_UINT32(p_FmPort->im.p_FmPortImPram->mode, IM_MODE_SET_BO(2));
 
         WRITE_UINT32(p_FmPort->im.p_FmPortImPram->rxQdPtr,
-                     (uint32_t)(CAST_POINTER_TO_UINT64(XX_VirtToPhys(p_FmPort->im.p_FmPortImPram)) -
+                     (uint32_t)((uint64_t)(XX_VirtToPhys(p_FmPort->im.p_FmPortImPram)) -
                                 p_FmPort->p_FmPortDriverParam->fmMuramPhysBaseAddr + 0x20));
 
         LOG2((uint64_t)p_FmPort->im.mrblr, log2Num);
         MY_WRITE_UINT16(p_FmPort->im.p_FmPortImPram->mrblr, log2Num);
 
         /* Initialize Rx QD */
-        tmpPhysBase = CAST_POINTER_TO_UINT64(XX_VirtToPhys(p_FmPort->im.p_BdRing));
+        tmpPhysBase = (uint64_t)(XX_VirtToPhys(p_FmPort->im.p_BdRing));
         SET_ADDR(&p_FmPort->im.p_FmPortImPram->rxQd.bdRingBase, tmpPhysBase);
         MY_WRITE_UINT16(p_FmPort->im.p_FmPortImPram->rxQd.bdRingSize, (uint16_t)(sizeof(t_FmImBd)*p_FmPort->im.bdRingSize));
 
         /* Update the IM PRAM address in the BMI */
         WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfqid,
-                     (uint32_t)(CAST_POINTER_TO_UINT64(XX_VirtToPhys(p_FmPort->im.p_FmPortImPram)) -
+                     (uint32_t)((uint64_t)(XX_VirtToPhys(p_FmPort->im.p_FmPortImPram)) -
                                 p_FmPort->p_FmPortDriverParam->fmMuramPhysBaseAddr));
     }
     else
@@ -380,21 +389,24 @@ t_Error FmPortImInit(t_FmPort *p_FmPort)
         memset(p_FmPort->im.p_BdShadow, 0, (uint32_t)(sizeof(t_Handle)*p_FmPort->im.bdRingSize));
         p_FmPort->im.firstBdOfFrameId = IM_ILEGAL_BD_ID;
 
-        if (p_FmPort->im.dataMemAttributes & MEMORY_ATTR_CACHEABLE)
-            WRITE_UINT32(p_FmPort->im.p_FmPortImPram->mode, IM_MODE_GBL);
+        if ((p_FmPort->im.dataMemAttributes & MEMORY_ATTR_CACHEABLE) ||
+            (p_FmPort->im.fwExtStructsMemAttr & MEMORY_ATTR_CACHEABLE))
+            WRITE_UINT32(p_FmPort->im.p_FmPortImPram->mode, IM_MODE_GBL | IM_MODE_SET_BO(2));
+        else
+            WRITE_UINT32(p_FmPort->im.p_FmPortImPram->mode, IM_MODE_SET_BO(2));
 
         WRITE_UINT32(p_FmPort->im.p_FmPortImPram->txQdPtr,
-                     (uint32_t)(CAST_POINTER_TO_UINT64(XX_VirtToPhys(p_FmPort->im.p_FmPortImPram)) -
+                     (uint32_t)((uint64_t)(XX_VirtToPhys(p_FmPort->im.p_FmPortImPram)) -
                                 p_FmPort->p_FmPortDriverParam->fmMuramPhysBaseAddr + 0x40));
 
         /* Initialize Tx QD */
-        tmpPhysBase = CAST_POINTER_TO_UINT64(XX_VirtToPhys(p_FmPort->im.p_BdRing));
+        tmpPhysBase = (uint64_t)(XX_VirtToPhys(p_FmPort->im.p_BdRing));
         SET_ADDR(&p_FmPort->im.p_FmPortImPram->txQd.bdRingBase, tmpPhysBase);
         MY_WRITE_UINT16(p_FmPort->im.p_FmPortImPram->txQd.bdRingSize, (uint16_t)(sizeof(t_FmImBd)*p_FmPort->im.bdRingSize));
 
         /* Update the IM PRAM address in the BMI */
         WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->txPortBmiRegs.fmbm_tcfqid,
-                     (uint32_t)(CAST_POINTER_TO_UINT64(XX_VirtToPhys(p_FmPort->im.p_FmPortImPram)) -
+                     (uint32_t)((uint64_t)(XX_VirtToPhys(p_FmPort->im.p_FmPortImPram)) -
                                 p_FmPort->p_FmPortDriverParam->fmMuramPhysBaseAddr));
     }
 
@@ -436,7 +448,7 @@ void FmPortImFree(t_FmPort *p_FmPort)
         }
     }
     else
-        FmPortTxConf(p_FmPort, e_TX_CONF_TYPE_FLUSH);
+        TxConf(p_FmPort, e_TX_CONF_TYPE_FLUSH);
 
     if (p_FmPort->im.p_BdShadow)
         XX_Free(p_FmPort->im.p_BdShadow);
@@ -485,12 +497,11 @@ t_Error FM_PORT_ConfigIMTxBdRingLength(t_Handle h_FmPort, uint16_t newVal)
     return E_OK;
 }
 
-
 t_Error  FM_PORT_ImTx( t_Handle               h_FmPort,
                        uint8_t                *p_Data,
                        uint16_t               length,
                        bool                   lastBuffer,
-                       t_Handle               h_UserPriv)
+                       t_Handle               h_BufContext)
 {
     t_FmPort            *p_FmPort = (t_FmPort*)h_FmPort;
     uint16_t            nextBdId;
@@ -508,11 +519,11 @@ t_Error  FM_PORT_ImTx( t_Handle               h_FmPort,
     if (!(bdStatus & BD_R_E) && !(nextBdStatus & BD_R_E))
     {
         /* Confirm the current BD - BD is available */
-        if ((bdStatus & BD_LENGTH_MASK) && (p_FmPort->im.f_TxConfCB))
-            p_FmPort->im.f_TxConfCB (p_FmPort->im.h_App,
-                                     BD_BUFFER(BD_GET(p_FmPort->im.currBdId)),
-                                     0,
-                                     p_FmPort->im.p_BdShadow[p_FmPort->im.currBdId]);
+        if ((bdStatus & BD_LENGTH_MASK) && (p_FmPort->im.f_TxConf))
+            p_FmPort->im.f_TxConf (p_FmPort->h_App,
+                                   BD_BUFFER(BD_GET(p_FmPort->im.currBdId)),
+                                   0,
+                                   p_FmPort->im.p_BdShadow[p_FmPort->im.currBdId]);
 
         bdStatus |= length;
 
@@ -529,7 +540,7 @@ t_Error  FM_PORT_ImTx( t_Handle               h_FmPort,
             firstBuffer = FALSE;
 
         BD_BUFFER_SET(BD_GET(p_FmPort->im.currBdId), p_Data);
-        p_FmPort->im.p_BdShadow[p_FmPort->im.currBdId] = h_UserPriv;
+        p_FmPort->im.p_BdShadow[p_FmPort->im.currBdId] = h_BufContext;
 
         /* deal with last */
         if (lastBuffer)
@@ -545,12 +556,12 @@ t_Error  FM_PORT_ImTx( t_Handle               h_FmPort,
                 BD_STATUS_AND_LENGTH_SET(BD_GET(p_FmPort->im.firstBdOfFrameId), p_FmPort->im.txFirstBdStatus);
                 p_FmPort->im.firstBdOfFrameId = IM_ILEGAL_BD_ID;
             }
+            MY_WRITE_UINT16(p_FmPort->im.p_FmPortImPram->txQd.offsetIn, (uint16_t)(GetNextBdId(p_FmPort, p_FmPort->im.currBdId)<<4));
         }
         else if (!firstBuffer) /* mid frame buffer */
             BD_STATUS_AND_LENGTH_SET (BD_GET(p_FmPort->im.currBdId), bdStatus | BD_R_E);
 
         p_FmPort->im.currBdId = GetNextBdId(p_FmPort, p_FmPort->im.currBdId);
-        MY_WRITE_UINT16(p_FmPort->im.p_FmPortImPram->txQd.offsetIn, (uint16_t)(p_FmPort->im.currBdId<<4));
     }
     else
     {
@@ -577,7 +588,7 @@ void FM_PORT_ImTxConf(t_Handle h_FmPort)
     SANITY_CHECK_RETURN(p_FmPort->imEn, E_INVALID_STATE);
     SANITY_CHECK_RETURN(!p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
 
-    FmPortTxConf(p_FmPort, e_TX_CONF_TYPE_CALLBACK);
+    TxConf(p_FmPort, e_TX_CONF_TYPE_CALLBACK);
 }
 
 t_Error  FM_PORT_ImRx(t_Handle h_FmPort)
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/Rtc/Makefile b/drivers/net/dpa/NetCommSw/Peripherals/FM/Rtc/Makefile
new file mode 100644
index 0000000..dbe51ff
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/Rtc/Makefile
@@ -0,0 +1,15 @@
+#
+# Makefile for the Freescale Ethernet controllers
+#
+EXTRA_CFLAGS           += -DVERSION=\"\"
+#
+#Include netcomm SW specific definitions
+include $(srctree)/drivers/net/dpa/NetCommSw/ncsw_config.mk
+
+NCSW_FM_INC = $(srctree)/drivers/net/dpa/NetCommSw/Peripherals/FM/inc
+
+EXTRA_CFLAGS += -I$(NCSW_FM_INC)
+
+obj-y		+= fsl-ncsw-RTC.o
+
+fsl-ncsw-RTC-objs	:=   fm_rtc.o
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/Rtc/fm_rtc.c b/drivers/net/dpa/NetCommSw/Peripherals/FM/Rtc/fm_rtc.c
new file mode 100644
index 0000000..3e7737b
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/Rtc/fm_rtc.c
@@ -0,0 +1,835 @@
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/******************************************************************************
+ @File          fm_rtc.c
+
+ @Description   FM RTC driver implementation.
+
+ @Cautions      None
+*//***************************************************************************/
+
+#include "error_ext.h"
+#include "debug_ext.h"
+#include "string_ext.h"
+#include "part_ext.h"
+#include "xx_ext.h"
+#include "ncsw_ext.h"
+
+#include "fm_rtc.h"
+
+
+/*****************************************************************************/
+static void SetDefaultParam(t_FmRtc *p_Rtc)
+{
+    t_FmRtcDriverParam  *p_RtcDriverParam = p_Rtc->p_RtcDriverParam;
+    int                 i;
+
+    p_Rtc->outputClockDivisor = DEFAULT_outputClockDivisor;
+    p_Rtc->p_RtcDriverParam->bypass = DEFAULT_bypass;
+    p_RtcDriverParam->srcClk = DEFAULT_srcClock;
+    p_RtcDriverParam->invertInputClkPhase = DEFAULT_invertInputClkPhase;
+    p_RtcDriverParam->invertOutputClkPhase = DEFAULT_invertOutputClkPhase;
+    p_RtcDriverParam->pulseRealign = DEFAULT_pulseRealign;
+    for (i=0; i < FM_RTC_NUM_OF_ALARMS; i++)
+    {
+        p_RtcDriverParam->alarmPolarity[i] = DEFAULT_alarmPolarity;
+    }
+    for (i=0; i < FM_RTC_NUM_OF_EXT_TRIGGERS; i++)
+    {
+        p_RtcDriverParam->triggerPolarity[i] = DEFAULT_triggerPolarity;
+    }
+    p_Rtc->clockPeriodNanoSec = DEFAULT_clockPeriod; /* 1 usec */
+}
+
+/*****************************************************************************/
+static t_Error CheckInitParameters(t_FmRtc *p_Rtc)
+{
+    t_FmRtcDriverParam  *p_RtcDriverParam = p_Rtc->p_RtcDriverParam;
+    int                 i;
+
+    if ((p_RtcDriverParam->srcClk != e_FM_RTC_SOURCE_CLOCK_EXTERNAL) &&
+        (p_RtcDriverParam->srcClk != e_FM_RTC_SOURCE_CLOCK_SYSTEM) &&
+        (p_RtcDriverParam->srcClk != e_FM_RTC_SOURCE_CLOCK_OSCILATOR))
+        RETURN_ERROR(MAJOR, E_INVALID_CLOCK, ("Source clock undefined"));
+
+    if (p_Rtc->outputClockDivisor == 0)
+    {
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE,
+                     ("Divisor for output clock (should be positive)"));
+    }
+
+    for (i=0; i < FM_RTC_NUM_OF_ALARMS; i++)
+    {
+        if ((p_RtcDriverParam->alarmPolarity[i] != e_FM_RTC_ALARM_POLARITY_ACTIVE_LOW) &&
+            (p_RtcDriverParam->alarmPolarity[i] != e_FM_RTC_ALARM_POLARITY_ACTIVE_HIGH))
+        {
+            RETURN_ERROR(MAJOR, E_INVALID_SELECTION, ("Alarm %d signal polarity", i));
+        }
+    }
+    for (i=0; i < FM_RTC_NUM_OF_EXT_TRIGGERS; i++)
+    {
+        if ((p_RtcDriverParam->triggerPolarity[i] != e_FM_RTC_TRIGGER_ON_FALLING_EDGE) &&
+            (p_RtcDriverParam->triggerPolarity[i] != e_FM_RTC_TRIGGER_ON_RISING_EDGE))
+        {
+            RETURN_ERROR(MAJOR, E_INVALID_SELECTION, ("Trigger %d signal polarity", i));
+        }
+    }
+    return E_OK;
+}
+
+/*****************************************************************************/
+static void RtcExceptions(t_Handle h_FmRtc)
+{
+    t_FmRtc          *p_Rtc = (t_FmRtc *)h_FmRtc;
+    t_FmRtcMemMap    *p_MemMap = (t_FmRtcMemMap *)p_Rtc->p_MemMap;
+    register uint32_t   events;
+
+    ASSERT_COND(p_Rtc);
+
+    /* Get valid events */
+    events =  GET_UINT32(p_MemMap->tmr_tevent);
+    events &= GET_UINT32(p_MemMap->tmr_temask);
+
+    /* Clear event bits */
+    WRITE_UINT32(p_MemMap->tmr_tevent, events);
+
+    if (events & TMR_TEVENT_ALM1)
+    {
+        if(p_Rtc->alarmParams[0].clearOnExpiration)
+        {
+            WRITE_UINT32(p_MemMap->tmr_alarm[0].tmr_alarm_l, 0);
+            WRITE_UINT32(p_MemMap->tmr_temask, GET_UINT32(p_MemMap->tmr_temask) & ~TMR_TEVENT_ALM1);
+        }
+        ASSERT_COND(p_Rtc->alarmParams[0].f_AlarmCallback);
+        p_Rtc->alarmParams[0].f_AlarmCallback(p_Rtc->h_App, 0);
+    }
+    if (events & TMR_TEVENT_ALM2)
+    {
+        if(p_Rtc->alarmParams[1].clearOnExpiration)
+        {
+            WRITE_UINT32(p_MemMap->tmr_alarm[1].tmr_alarm_l, 0);
+            WRITE_UINT32(p_MemMap->tmr_temask, GET_UINT32(p_MemMap->tmr_temask) & ~TMR_TEVENT_ALM2);
+        }
+        ASSERT_COND(p_Rtc->alarmParams[1].f_AlarmCallback);
+        p_Rtc->alarmParams[1].f_AlarmCallback(p_Rtc->h_App, 1);
+    }
+    if (events & TMR_TEVENT_PP1)
+    {
+        ASSERT_COND(p_Rtc->periodicPulseParams[0].f_PeriodicPulseCallback);
+        p_Rtc->periodicPulseParams[0].f_PeriodicPulseCallback(p_Rtc->h_App, 0);
+    }
+    if (events & TMR_TEVENT_PP2)
+    {
+        ASSERT_COND(p_Rtc->periodicPulseParams[1].f_PeriodicPulseCallback);
+        p_Rtc->periodicPulseParams[1].f_PeriodicPulseCallback(p_Rtc->h_App, 1);
+    }
+    if (events & TMR_TEVENT_ETS1)
+    {
+        ASSERT_COND(p_Rtc->externalTriggerParams[0].f_ExternalTriggerCallback);
+        p_Rtc->externalTriggerParams[0].f_ExternalTriggerCallback(p_Rtc->h_App, 0);
+    }
+    if (events & TMR_TEVENT_ETS2)
+    {
+        ASSERT_COND(p_Rtc->externalTriggerParams[1].f_ExternalTriggerCallback);
+        p_Rtc->externalTriggerParams[1].f_ExternalTriggerCallback(p_Rtc->h_App, 1);
+    }
+}
+
+
+/*****************************************************************************/
+t_Handle FM_RTC_Config(t_FmRtcParams *p_FmRtcParam)
+{
+    t_FmRtc *p_Rtc;
+
+    SANITY_CHECK_RETURN_VALUE(p_FmRtcParam, E_NULL_POINTER, NULL);
+
+    /* Allocate memory for the FM RTC driver parameters */
+    p_Rtc = (t_FmRtc *)XX_Malloc(sizeof(t_FmRtc));
+    if (!p_Rtc)
+    {
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM RTC driver structure"));
+        return NULL;
+    }
+
+    memset(p_Rtc, 0, sizeof(t_FmRtc));
+
+    /* Allocate memory for the FM RTC driver parameters */
+    p_Rtc->p_RtcDriverParam = (t_FmRtcDriverParam *)XX_Malloc(sizeof(t_FmRtcDriverParam));
+    if (!p_Rtc->p_RtcDriverParam)
+    {
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM RTC driver parameters"));
+        XX_Free(p_Rtc);
+        return NULL;
+    }
+
+    memset(p_Rtc->p_RtcDriverParam, 0, sizeof(t_FmRtcDriverParam));
+
+    /* Store RTC configuration parameters */
+    p_Rtc->h_Fm = p_FmRtcParam->h_Fm;
+
+    /* Set default RTC configuration parameters */
+    SetDefaultParam(p_Rtc);
+
+    /* Store RTC parameters in the RTC control structure */
+    p_Rtc->p_MemMap = CAST_UINT64_TO_POINTER_TYPE(t_FmRtcMemMap, p_FmRtcParam->baseAddress);
+    p_Rtc->h_App    = p_FmRtcParam->h_App;
+
+    return p_Rtc;
+}
+
+/*****************************************************************************/
+t_Error FM_RTC_Init(t_Handle h_FmRtc)
+{
+    t_FmRtc             *p_Rtc = (t_FmRtc *)h_FmRtc;
+    t_FmRtcDriverParam  *p_RtcDriverParam;
+    t_FmRtcMemMap       *p_MemMap;
+    uint32_t            freqCompensation;
+    uint32_t            tmrCtrl;
+    int                 i;
+    uint64_t            tmpDouble;
+
+    p_RtcDriverParam = p_Rtc->p_RtcDriverParam;
+    p_MemMap = p_Rtc->p_MemMap;
+
+    if(CheckInitParameters(p_Rtc)!=E_OK)
+        RETURN_ERROR(MAJOR, E_CONFLICT,
+                     ("Init Parameters are not Valid"));
+
+    /* TODO A check must be added here, that no timestamping MAC's
+     * are working in this stage. */
+    WRITE_UINT32(p_MemMap->tmr_ctrl, TMR_CTRL_TMSR);
+    XX_UDelay(10);
+    WRITE_UINT32(p_MemMap->tmr_ctrl, 0);
+
+    /* Clear TMR_TEVENT */
+    WRITE_UINT32(p_MemMap->tmr_tevent, TMR_TEVENT_ALL);
+
+    /* Initialize TMR_TEMASK */
+    WRITE_UINT32(p_MemMap->tmr_temask, 0);
+
+    /* Set the source clock */
+    switch (p_RtcDriverParam->srcClk)
+    {
+        case e_FM_RTC_SOURCE_CLOCK_SYSTEM:
+            tmrCtrl = TMR_CTRL_CKSEL_MAC_CLK;
+            break;
+        case e_FM_RTC_SOURCE_CLOCK_OSCILATOR:
+            tmrCtrl = TMR_CTRL_CKSEL_OSC_CLK;
+            break;
+        default:
+            /* Use a clock from the External TMR reference clock.*/
+            tmrCtrl = TMR_CTRL_CKSEL_EXT_CLK;
+            break;
+    }
+
+    /* find source clock frequency in Mhz */
+    if (p_Rtc->p_RtcDriverParam->srcClk != e_FM_RTC_SOURCE_CLOCK_SYSTEM)
+         p_Rtc->srcClkFreqMhz = p_Rtc->p_RtcDriverParam->extSrcClkFreq;
+    else
+        p_Rtc->srcClkFreqMhz = (uint32_t)(FmGetClockFreq(p_Rtc->h_Fm)/2);
+
+    /* if timer in Master mode Initialize TMR_CTRL */
+    /* We want the counter (TMR_CNT) to count in nano-seconds */
+    if (!p_RtcDriverParam->timerSlaveMode && p_Rtc->p_RtcDriverParam->bypass)
+    {
+        p_Rtc->clockPeriodNanoSec = (1000 / p_Rtc->srcClkFreqMhz);
+        tmrCtrl |= TMR_CTRL_BYP;
+    }
+    else
+    {
+        /* Initialize TMR_ADD with the initial frequency compensation value:
+           freqCompensation = (2^32 / frequency ratio) */
+        /* frequency ratio = sorce clock/rtc clock =
+         * (p_Rtc->srcClkFreqMhz*1000000))/ 1/(p_Rtc->clockPeriodNanoSec * 1000000000) */
+        freqCompensation = DIV_CEIL(ACCUMULATOR_OVERFLOW * 1000, p_Rtc->clockPeriodNanoSec * p_Rtc->srcClkFreqMhz);
+        WRITE_UINT32(p_MemMap->tmr_add, freqCompensation);
+    }
+    /* check the legality of the relation between source and destination clocks */
+    /* should be larger than 1.0001 */
+    tmpDouble = 10000 * p_Rtc->clockPeriodNanoSec * p_Rtc->srcClkFreqMhz;
+    if((tmpDouble) <= 10001)
+        RETURN_ERROR(MAJOR, E_CONFLICT,
+              ("Invalid relation between source and destination clocks. Should be larger than 1.0001"));
+
+    /* whatever period the user picked, the timestamp will advance in '1' every time
+     * the period passed. */
+    tmrCtrl |= ((1 << TMR_CTRL_TCLK_PERIOD_SHIFT) & TMR_CTRL_TCLK_PERIOD_MASK);
+
+    if (p_RtcDriverParam->invertInputClkPhase)
+        tmrCtrl |= TMR_CTRL_CIPH;
+    if (p_RtcDriverParam->invertOutputClkPhase)
+        tmrCtrl |= TMR_CTRL_COPH;
+
+    for (i=0; i < FM_RTC_NUM_OF_ALARMS; i++)
+    {
+        if (p_RtcDriverParam->alarmPolarity[i] == e_FM_RTC_ALARM_POLARITY_ACTIVE_LOW)
+            tmrCtrl |= (TMR_CTRL_ALMP1 >> i);
+
+        /* Clear TMR_ALARM registers */
+        WRITE_UINT32(p_MemMap->tmr_alarm[i].tmr_alarm_l, 0xFFFFFFFF);
+        WRITE_UINT32(p_MemMap->tmr_alarm[i].tmr_alarm_h, 0xFFFFFFFF);
+    }
+
+    for (i=0; i < FM_RTC_NUM_OF_EXT_TRIGGERS; i++)
+        if (p_RtcDriverParam->triggerPolarity[i] == e_FM_RTC_TRIGGER_ON_FALLING_EDGE)
+            tmrCtrl |= (TMR_CTRL_ETEP1 << i);
+    WRITE_UINT32(p_MemMap->tmr_ctrl, tmrCtrl);
+
+    for (i=0; i < 2; i++)
+        /* Clear TMR_FIPER registers */
+        WRITE_UINT32(p_MemMap->tmr_fiper[i], 0xFFFFFFFF);
+
+    /* Initialize TMR_PRSC */
+    WRITE_UINT32(p_MemMap->tmr_prsc, p_Rtc->outputClockDivisor);
+
+    /* Clear TMR_OFF */
+    WRITE_UINT32(p_MemMap->tmr_off_l, 0);
+    WRITE_UINT32(p_MemMap->tmr_off_h, 0);
+
+    /* Register the FM RTC interrupt */
+    FmRegisterIntr(p_Rtc->h_Fm, e_FM_MOD_TMR, 0, e_FM_INTR_TYPE_NORMAL, RtcExceptions , p_Rtc);
+
+    /* Free parameters structures */
+    XX_Free(p_Rtc->p_RtcDriverParam);
+    p_Rtc->p_RtcDriverParam = NULL;
+
+    return E_OK;
+}
+
+/*****************************************************************************/
+t_Error FM_RTC_Free(t_Handle h_FmRtc)
+{
+    t_FmRtc *p_Rtc = (t_FmRtc *)h_FmRtc;
+
+    SANITY_CHECK_RETURN_ERROR(p_Rtc, E_INVALID_HANDLE);
+
+    if (p_Rtc->p_RtcDriverParam)
+    {
+        XX_Free(p_Rtc->p_RtcDriverParam);
+    }
+    else
+    {
+        FM_RTC_Disable(h_FmRtc);
+    }
+
+    /* Unregister FM RTC interrupt */
+    FmUnregisterIntr(p_Rtc->h_Fm, e_FM_MOD_TMR, 0, e_FM_INTR_TYPE_NORMAL);
+    XX_Free(p_Rtc);
+
+    return E_OK;
+}
+
+/*****************************************************************************/
+t_Error FM_RTC_ConfigSourceClock(t_Handle         h_FmRtc,
+                                    e_FmSrcClk    srcClk,
+                                    uint32_t      freqInMhz)
+{
+    t_FmRtc *p_Rtc = (t_FmRtc *)h_FmRtc;
+
+    SANITY_CHECK_RETURN_ERROR(p_Rtc, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Rtc->p_RtcDriverParam, E_INVALID_STATE);
+
+    p_Rtc->p_RtcDriverParam->srcClk = srcClk;
+    if(srcClk != e_FM_RTC_SOURCE_CLOCK_SYSTEM)
+        p_Rtc->p_RtcDriverParam->extSrcClkFreq = freqInMhz;
+
+    return E_OK;
+}
+
+/*****************************************************************************/
+t_Error FM_RTC_ConfigPeriod(t_Handle h_FmRtc, uint32_t period)
+{
+    t_FmRtc *p_Rtc = (t_FmRtc *)h_FmRtc;
+
+    SANITY_CHECK_RETURN_ERROR(p_Rtc, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Rtc->p_RtcDriverParam, E_INVALID_STATE);
+
+    p_Rtc->clockPeriodNanoSec = period;
+
+    return E_OK;
+}
+
+/*****************************************************************************/
+t_Error FM_RTC_ConfigFrequencyBypass(t_Handle h_FmRtc, bool enabled)
+{
+    t_FmRtc *p_Rtc = (t_FmRtc *)h_FmRtc;
+
+    SANITY_CHECK_RETURN_ERROR(p_Rtc, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Rtc->p_RtcDriverParam, E_INVALID_STATE);
+
+    p_Rtc->p_RtcDriverParam->bypass = enabled;
+
+    return E_OK;
+}
+
+/*****************************************************************************/
+t_Error FM_RTC_ConfigInvertedInputClockPhase(t_Handle h_FmRtc, bool inverted)
+{
+    t_FmRtc *p_Rtc = (t_FmRtc *)h_FmRtc;
+
+    SANITY_CHECK_RETURN_ERROR(p_Rtc, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Rtc->p_RtcDriverParam, E_INVALID_STATE);
+
+    p_Rtc->p_RtcDriverParam->invertInputClkPhase = inverted;
+
+    return E_OK;
+}
+
+/*****************************************************************************/
+t_Error FM_RTC_ConfigInvertedOutputClockPhase(t_Handle h_FmRtc, bool inverted)
+{
+    t_FmRtc *p_Rtc = (t_FmRtc *)h_FmRtc;
+
+    SANITY_CHECK_RETURN_ERROR(p_Rtc, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Rtc->p_RtcDriverParam, E_INVALID_STATE);
+
+    p_Rtc->p_RtcDriverParam->invertOutputClkPhase = inverted;
+
+    return E_OK;
+}
+
+/*****************************************************************************/
+t_Error FM_RTC_ConfigOutputClockDivisor(t_Handle h_FmRtc, uint16_t divisor)
+{
+    t_FmRtc *p_Rtc = (t_FmRtc *)h_FmRtc;
+
+    SANITY_CHECK_RETURN_ERROR(p_Rtc, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Rtc->p_RtcDriverParam, E_INVALID_STATE);
+
+    p_Rtc->outputClockDivisor = divisor;
+
+    return E_OK;
+}
+
+/*****************************************************************************/
+t_Error FM_RTC_ConfigPulseRealignment(t_Handle h_FmRtc, bool enable)
+{
+    t_FmRtc *p_Rtc = (t_FmRtc *)h_FmRtc;
+
+    SANITY_CHECK_RETURN_ERROR(p_Rtc, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Rtc->p_RtcDriverParam, E_INVALID_STATE);
+
+    p_Rtc->p_RtcDriverParam->pulseRealign = enable;
+
+    return E_OK;
+}
+
+/*****************************************************************************/
+t_Error FM_RTC_ConfigAlarmPolarity(t_Handle             h_FmRtc,
+                                   uint8_t              alarmId,
+                                   e_FmRtcAlarmPolarity alarmPolarity)
+{
+    t_FmRtc *p_Rtc = (t_FmRtc *)h_FmRtc;
+
+    SANITY_CHECK_RETURN_ERROR(p_Rtc, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Rtc->p_RtcDriverParam, E_INVALID_STATE);
+
+    if (alarmId >= FM_RTC_NUM_OF_ALARMS)
+    {
+        RETURN_ERROR(MAJOR, E_INVALID_SELECTION, ("Alarm ID"));
+    }
+
+    p_Rtc->p_RtcDriverParam->alarmPolarity[alarmId] = alarmPolarity;
+
+    return E_OK;
+}
+
+/*****************************************************************************/
+t_Error FM_RTC_ConfigExternalTriggerPolarity(t_Handle               h_FmRtc,
+                                                uint8_t             triggerId,
+                                                e_FmRtcTriggerPolarity triggerPolarity)
+{
+    t_FmRtc *p_Rtc = (t_FmRtc *)h_FmRtc;
+
+    SANITY_CHECK_RETURN_ERROR(p_Rtc, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Rtc->p_RtcDriverParam, E_INVALID_STATE);
+
+    if (triggerId >= FM_RTC_NUM_OF_EXT_TRIGGERS)
+    {
+        RETURN_ERROR(MAJOR, E_INVALID_SELECTION, ("External trigger ID"));
+    }
+
+    p_Rtc->p_RtcDriverParam->triggerPolarity[triggerId] = triggerPolarity;
+
+    return E_OK;
+}
+
+/*****************************************************************************/
+t_Error FM_RTC_Enable(t_Handle h_FmRtc, bool resetClock)
+{
+    t_FmRtc         *p_Rtc = (t_FmRtc *)h_FmRtc;
+    t_FmRtcMemMap   *p_MemMap = p_Rtc->p_MemMap;
+    uint32_t        tmrCtrl;
+
+    SANITY_CHECK_RETURN_ERROR(p_Rtc, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_Rtc->p_RtcDriverParam, E_INVALID_STATE);
+
+    tmrCtrl = GET_UINT32(p_MemMap->tmr_ctrl);
+
+    /* TODO A check must be added here, that no timestamping MAC's
+     * are working in this stage. */
+    if (resetClock)
+    {
+        WRITE_UINT32(p_MemMap->tmr_ctrl, (tmrCtrl | TMR_CTRL_TMSR));
+
+        XX_UDelay(10);
+        /* Clear TMR_OFF */
+        WRITE_UINT32(p_MemMap->tmr_off_l, 0);
+        WRITE_UINT32(p_MemMap->tmr_off_h, 0);
+    }
+
+    WRITE_UINT32(p_MemMap->tmr_ctrl, (tmrCtrl | TMR_CTRL_TE));
+
+    return E_OK;
+}
+
+/*****************************************************************************/
+t_Error FM_RTC_Disable(t_Handle h_FmRtc)
+{
+    t_FmRtc  *p_Rtc = (t_FmRtc *)h_FmRtc;
+    t_FmRtcMemMap *p_MemMap = (t_FmRtcMemMap *)p_Rtc->p_MemMap;
+    uint32_t    tmrCtrl;
+
+    SANITY_CHECK_RETURN_ERROR(p_Rtc, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_Rtc->p_RtcDriverParam, E_INVALID_STATE);
+
+    /* TODO A check must be added here, that no timestamping MAC's
+     * are working in this stage. */
+    tmrCtrl = GET_UINT32(p_MemMap->tmr_ctrl);
+    WRITE_UINT32(p_MemMap->tmr_ctrl, (tmrCtrl & ~(TMR_CTRL_TE)));
+
+    return E_OK;
+}
+
+/*****************************************************************************/
+t_Error FM_RTC_SetClockOffset(t_Handle h_FmRtc, int64_t offset)
+{
+    t_FmRtc *p_Rtc = (t_FmRtc *)h_FmRtc;
+    t_FmRtcMemMap *p_MemMap = (t_FmRtcMemMap *)p_Rtc->p_MemMap;
+
+    SANITY_CHECK_RETURN_ERROR(p_Rtc, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_Rtc->p_RtcDriverParam, E_INVALID_STATE);
+
+    /* TMR_OFF_L must be written first */
+    WRITE_UINT32(p_MemMap->tmr_off_l, (uint32_t)offset);
+    WRITE_UINT32(p_MemMap->tmr_off_h, (uint32_t)(offset >> 32));
+
+    return E_OK;
+}
+
+/*****************************************************************************/
+t_Error FM_RTC_SetAlarm(t_Handle h_FmRtc, t_FmRtcAlarmParams *p_FmRtcAlarmParams)
+{
+    t_FmRtc         *p_Rtc = (t_FmRtc *)h_FmRtc;
+    t_FmRtcMemMap   *p_MemMap = (t_FmRtcMemMap *)p_Rtc->p_MemMap;
+    uint32_t        tmpReg;
+    uint64_t        tmpAlarm;
+
+    SANITY_CHECK_RETURN_ERROR(p_Rtc, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_Rtc->p_RtcDriverParam, E_INVALID_STATE);
+
+    if (p_FmRtcAlarmParams->alarmId >= FM_RTC_NUM_OF_ALARMS)
+    {
+        RETURN_ERROR(MAJOR, E_INVALID_SELECTION, ("Alarm ID"));
+    }
+
+    if(GET_UINT32(p_MemMap->tmr_ctrl) & TMR_CTRL_TE)
+        RETURN_ERROR(MAJOR, E_INVALID_SELECTION, ("Can't set Alarm when RTC is enabled."));
+    if(p_FmRtcAlarmParams->alarmTime < p_Rtc->clockPeriodNanoSec)
+        RETURN_ERROR(MAJOR, E_INVALID_SELECTION, ("Alarm time must be equal or larger than RTC period - %d nanoseconds", p_Rtc->clockPeriodNanoSec));
+    if(p_FmRtcAlarmParams->alarmTime % (uint64_t)p_Rtc->clockPeriodNanoSec)
+        RETURN_ERROR(MAJOR, E_INVALID_SELECTION, ("Alarm time must be a multiple of RTC period - %d nanoseconds", p_Rtc->clockPeriodNanoSec));
+    tmpAlarm = p_FmRtcAlarmParams->alarmTime/(uint64_t)p_Rtc->clockPeriodNanoSec;
+
+    /* TMR_ALARM_L must be written first */
+    WRITE_UINT32(p_MemMap->tmr_alarm[p_FmRtcAlarmParams->alarmId].tmr_alarm_l, (uint32_t)tmpAlarm);
+    WRITE_UINT32(p_MemMap->tmr_alarm[p_FmRtcAlarmParams->alarmId].tmr_alarm_h,
+                 (uint32_t)(tmpAlarm >> 32));
+
+    p_Rtc->alarmParams[p_FmRtcAlarmParams->alarmId].f_AlarmCallback = p_FmRtcAlarmParams->f_AlarmCallback;
+    p_Rtc->alarmParams[p_FmRtcAlarmParams->alarmId].clearOnExpiration = p_FmRtcAlarmParams->clearOnExpiration;
+
+    if(p_FmRtcAlarmParams->alarmId == 0)
+        tmpReg = TMR_TEVENT_ALM1;
+    else
+        tmpReg = TMR_TEVENT_ALM2;
+    WRITE_UINT32(p_MemMap->tmr_temask, GET_UINT32(p_MemMap->tmr_temask) | tmpReg);
+
+    return E_OK;
+}
+
+/*****************************************************************************/
+t_Error FM_RTC_SetPeriodicPulse(t_Handle h_FmRtc, t_FmRtcPeriodicPulseParams *p_FmRtcPeriodicPulseParams)
+{
+    t_FmRtc  *p_Rtc = (t_FmRtc *)h_FmRtc;
+    t_FmRtcMemMap *p_MemMap = (t_FmRtcMemMap *)p_Rtc->p_MemMap;
+    uint32_t    tmpReg;
+    uint64_t    tmpFiper;
+
+    SANITY_CHECK_RETURN_ERROR(p_Rtc, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_Rtc->p_RtcDriverParam, E_INVALID_STATE);
+
+    if (p_FmRtcPeriodicPulseParams->periodicPulseId >= FM_RTC_NUM_OF_PERIODIC_PULSES)
+    {
+        RETURN_ERROR(MAJOR, E_INVALID_SELECTION, ("Periodic pulse ID"));
+    }
+    if(GET_UINT32(p_MemMap->tmr_ctrl) & TMR_CTRL_TE)
+        RETURN_ERROR(MAJOR, E_INVALID_SELECTION, ("Can't set Periodic pulse when RTC is enabled."));
+    if(p_FmRtcPeriodicPulseParams->periodicPulsePeriod < p_Rtc->clockPeriodNanoSec)
+        RETURN_ERROR(MAJOR, E_INVALID_SELECTION, ("Periodic pulse must be equal or larger than RTC period - %d nanoseconds", p_Rtc->clockPeriodNanoSec));
+    if(p_FmRtcPeriodicPulseParams->periodicPulsePeriod % (uint64_t)p_Rtc->clockPeriodNanoSec)
+        RETURN_ERROR(MAJOR, E_INVALID_SELECTION, ("Periodic pulse must be a multiple of RTC period - %d nanoseconds", p_Rtc->clockPeriodNanoSec));
+    tmpFiper = p_FmRtcPeriodicPulseParams->periodicPulsePeriod/(uint64_t)p_Rtc->clockPeriodNanoSec;
+    if(tmpFiper & 0xffffffff00000000LL)
+        RETURN_ERROR(MAJOR, E_INVALID_SELECTION, ("Periodic pulse/RTC Period must be smaller than 4294967296", p_Rtc->clockPeriodNanoSec));
+
+    WRITE_UINT32(p_MemMap->tmr_fiper[p_FmRtcPeriodicPulseParams->periodicPulseId], (uint32_t)tmpFiper);
+
+    p_Rtc->periodicPulseParams[p_FmRtcPeriodicPulseParams->periodicPulseId].f_PeriodicPulseCallback =
+                                                            p_FmRtcPeriodicPulseParams->f_PeriodicPulseCallback;
+
+    if(p_FmRtcPeriodicPulseParams->periodicPulseId == 0)
+        tmpReg = TMR_TEVENT_PP1;
+    else
+        tmpReg = TMR_TEVENT_PP2;
+    WRITE_UINT32(p_MemMap->tmr_temask, GET_UINT32(p_MemMap->tmr_temask) | tmpReg);
+
+    return E_OK;
+}
+
+/*****************************************************************************/
+t_Error FM_RTC_ClearPeriodicPulse(t_Handle h_FmRtc, uint8_t periodicPulseId)
+{
+    t_FmRtc  *p_Rtc = (t_FmRtc *)h_FmRtc;
+    t_FmRtcMemMap *p_MemMap = (t_FmRtcMemMap *)p_Rtc->p_MemMap;
+    uint32_t    tmpReg;
+
+    SANITY_CHECK_RETURN_ERROR(p_Rtc, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_Rtc->p_RtcDriverParam, E_INVALID_STATE);
+
+    if (periodicPulseId >= FM_RTC_NUM_OF_PERIODIC_PULSES)
+    {
+        RETURN_ERROR(MAJOR, E_INVALID_SELECTION, ("Periodic pulse ID"));
+    }
+
+    p_Rtc->periodicPulseParams[periodicPulseId].f_PeriodicPulseCallback = NULL;
+
+    if(periodicPulseId == 0)
+        tmpReg = TMR_TEVENT_PP1;
+    else
+        tmpReg = TMR_TEVENT_PP2;
+    WRITE_UINT32(p_MemMap->tmr_temask, GET_UINT32(p_MemMap->tmr_temask) & ~tmpReg);
+
+    if(GET_UINT32(p_MemMap->tmr_ctrl) & TMR_CTRL_FS)
+        WRITE_UINT32(p_MemMap->tmr_ctrl, GET_UINT32(p_MemMap->tmr_ctrl) & ~TMR_CTRL_FS);
+
+    WRITE_UINT32(p_MemMap->tmr_fiper[periodicPulseId], 0xFFFFFFFF);
+
+    return E_OK;
+}
+
+/*****************************************************************************/
+t_Error FM_RTC_SetExternalTrigger(t_Handle h_FmRtc, t_FmRtcExternalTriggerParams *p_FmRtcExternalTriggerParams)
+{
+    t_FmRtc         *p_Rtc = (t_FmRtc *)h_FmRtc;
+    t_FmRtcMemMap   *p_MemMap = (t_FmRtcMemMap *)p_Rtc->p_MemMap;
+    uint32_t        tmpReg;
+
+    SANITY_CHECK_RETURN_ERROR(p_Rtc, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_Rtc->p_RtcDriverParam, E_INVALID_STATE);
+
+    if (p_FmRtcExternalTriggerParams->externalTriggerId >= FM_RTC_NUM_OF_EXT_TRIGGERS)
+    {
+        RETURN_ERROR(MAJOR, E_INVALID_SELECTION, ("External Trigger ID"));
+    }
+
+    p_Rtc->externalTriggerParams[p_FmRtcExternalTriggerParams->externalTriggerId].f_ExternalTriggerCallback = p_FmRtcExternalTriggerParams->f_ExternalTriggerCallback;
+    if(p_FmRtcExternalTriggerParams->externalTriggerId == 0)
+        tmpReg = TMR_TEVENT_ETS1;
+    else
+        tmpReg = TMR_TEVENT_ETS2;
+    WRITE_UINT32(p_MemMap->tmr_temask, GET_UINT32(p_MemMap->tmr_temask) | tmpReg);
+
+    if(p_FmRtcExternalTriggerParams->usePulseAsInput)
+    {
+        if(p_FmRtcExternalTriggerParams->externalTriggerId == 0)
+            tmpReg = TMR_CTRL_PP1L;
+        else
+            tmpReg = TMR_CTRL_PP2L;
+    }
+    WRITE_UINT32(p_MemMap->tmr_ctrl, GET_UINT32(p_MemMap->tmr_ctrl) | tmpReg);
+
+    return E_OK;
+}
+
+/*****************************************************************************/
+t_Error FM_RTC_ClearExternalTrigger(t_Handle h_FmRtc, uint8_t externalTriggerId)
+{
+    t_FmRtc         *p_Rtc = (t_FmRtc *)h_FmRtc;
+    t_FmRtcMemMap   *p_MemMap = (t_FmRtcMemMap *)p_Rtc->p_MemMap;
+    uint32_t        tmpReg;
+
+    SANITY_CHECK_RETURN_ERROR(p_Rtc, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_Rtc->p_RtcDriverParam, E_INVALID_STATE);
+
+    if (externalTriggerId >= FM_RTC_NUM_OF_EXT_TRIGGERS)
+        RETURN_ERROR(MAJOR, E_INVALID_SELECTION, ("External Trigger ID"));
+
+    p_Rtc->externalTriggerParams[externalTriggerId].f_ExternalTriggerCallback = NULL;
+
+    if(externalTriggerId == 0)
+        tmpReg = TMR_TEVENT_ETS1;
+    else
+        tmpReg = TMR_TEVENT_ETS2;
+    WRITE_UINT32(p_MemMap->tmr_temask, GET_UINT32(p_MemMap->tmr_temask) & ~tmpReg);
+
+    if(externalTriggerId == 0)
+        tmpReg = TMR_CTRL_PP1L;
+    else
+        tmpReg = TMR_CTRL_PP2L;
+
+    if (GET_UINT32(p_MemMap->tmr_ctrl) & tmpReg)
+        WRITE_UINT32(p_MemMap->tmr_ctrl, GET_UINT32(p_MemMap->tmr_ctrl) & ~tmpReg);
+
+    return E_OK;
+}
+
+/*****************************************************************************/
+t_Error FM_RTC_GetExternalTriggerTimeStamp(t_Handle             h_FmRtc,
+                                              uint8_t           triggerId,
+                                              uint64_t          *p_TimeStamp)
+{
+    t_FmRtc  *p_Rtc = (t_FmRtc *)h_FmRtc;
+    t_FmRtcMemMap *p_MemMap = (t_FmRtcMemMap *)p_Rtc->p_MemMap;
+    uint64_t    timeStamp;
+
+    SANITY_CHECK_RETURN_ERROR(p_Rtc, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_Rtc->p_RtcDriverParam, E_INVALID_STATE);
+
+    if (triggerId >= FM_RTC_NUM_OF_EXT_TRIGGERS)
+    {
+        RETURN_ERROR(MAJOR, E_INVALID_SELECTION, ("External trigger ID"));
+    }
+
+    timeStamp = (uint64_t)GET_UINT32(p_MemMap->tmr_etts[triggerId].tmr_etts_l);
+    timeStamp |= ((uint64_t)GET_UINT32(p_MemMap->tmr_etts[triggerId].tmr_etts_h) << 32);
+
+    *p_TimeStamp = timeStamp;
+
+    return E_OK;
+}
+
+/*****************************************************************************/
+t_Error FM_RTC_GetCurrentTime(t_Handle h_FmRtc, uint64_t *p_Ts)
+{
+    t_FmRtc     *p_Rtc = (t_FmRtc *)h_FmRtc;
+    t_FmRtcMemMap *p_MemMap = (t_FmRtcMemMap *)p_Rtc->p_MemMap;
+    uint64_t    time;
+
+    SANITY_CHECK_RETURN_ERROR(p_Rtc, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_Rtc->p_RtcDriverParam, E_INVALID_STATE);
+
+    /* TMR_CNT_L must be read first to get an accurate value */
+    time = (uint64_t)GET_UINT32(p_MemMap->tmr_cnt_l);
+    time |= ((uint64_t)GET_UINT32(p_MemMap->tmr_cnt_h) << 32);
+
+    *p_Ts = time;
+
+    return E_OK;
+}
+
+/*****************************************************************************/
+t_Error FM_RTC_SetCurrentTime(t_Handle h_FmRtc, uint64_t ts)
+{
+    t_FmRtc     *p_Rtc = (t_FmRtc *)h_FmRtc;
+    t_FmRtcMemMap *p_MemMap = (t_FmRtcMemMap *)p_Rtc->p_MemMap;
+
+    SANITY_CHECK_RETURN_ERROR(p_Rtc, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_Rtc->p_RtcDriverParam, E_INVALID_STATE);
+
+    /* TMR_CNT_L must be written first to get an accurate value */
+    WRITE_UINT32(p_MemMap->tmr_cnt_l, (uint32_t)ts);
+    WRITE_UINT32(p_MemMap->tmr_cnt_h, (uint32_t)(ts >> 32));
+
+    return E_OK;
+}
+
+/* ........................................................................... */
+
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+t_Error FM_RTC_DumpRegs(t_Handle h_FmRtc)
+{
+    t_FmRtc     *p_Rtc = (t_FmRtc *)h_FmRtc;
+    t_FmRtcMemMap *p_MemMap = (t_FmRtcMemMap *)p_Rtc->p_MemMap;
+    int i = 0;
+
+    DECLARE_DUMP;
+
+    if (p_MemMap)
+    {
+
+        DUMP_TITLE(p_MemMap, ("RTC:"));
+        DUMP_VAR(p_MemMap, tmr_id);
+        DUMP_VAR(p_MemMap, tmr_id2);
+        DUMP_VAR(p_MemMap, tmr_ctrl);
+        DUMP_VAR(p_MemMap, tmr_tevent);
+        DUMP_VAR(p_MemMap, tmr_temask);
+        DUMP_VAR(p_MemMap, tmr_cnt_h);
+        DUMP_VAR(p_MemMap, tmr_cnt_l);
+        DUMP_VAR(p_MemMap, tmr_ctrl);
+        DUMP_VAR(p_MemMap, tmr_add);
+        DUMP_VAR(p_MemMap, tmr_acc);
+        DUMP_VAR(p_MemMap, tmr_prsc);
+        DUMP_VAR(p_MemMap, tmr_off_h);
+        DUMP_VAR(p_MemMap, tmr_off_l);
+
+        DUMP_SUBSTRUCT_ARRAY(i, 2)
+        {
+            DUMP_VAR(p_MemMap, tmr_alarm[i].tmr_alarm_h);
+            DUMP_VAR(p_MemMap, tmr_alarm[i].tmr_alarm_l);
+        }
+        DUMP_SUBSTRUCT_ARRAY(i, 2)
+        {
+            DUMP_VAR(p_MemMap, tmr_fiper[i]);
+            DUMP_VAR(p_MemMap, tmr_fiper[i]);
+        }
+        DUMP_SUBSTRUCT_ARRAY(i, 2)
+        {
+            DUMP_VAR(p_MemMap, tmr_etts[i].tmr_etts_l);
+            DUMP_VAR(p_MemMap, tmr_etts[i].tmr_etts_l);
+        }
+    }
+
+    return E_OK;
+}
+#endif /* (defined(DEBUG_ERRORS) && ... */
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/Rtc/fm_rtc.h b/drivers/net/dpa/NetCommSw/Peripherals/FM/Rtc/fm_rtc.h
new file mode 100644
index 0000000..3f11786
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/Rtc/fm_rtc.h
@@ -0,0 +1,219 @@
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/******************************************************************************
+ @File          fm_rtc.h
+
+ @Description   Memory map and internal definitions for FM RTC IEEE1588 Timer driver.
+
+ @Cautions      None
+*//***************************************************************************/
+
+#ifndef __FM_RTC_H__
+#define __FM_RTC_H__
+
+#include "std_ext.h"
+#include "fm_rtc_ext.h"
+
+#include "fm_common.h"
+
+
+#define __ERR_MODULE__  MODULE_FM_RTC
+
+/* General definitions */
+
+#define NANOSEC_PER_ONE_HZ_TICK         1000000000
+#define MIN_RTC_CLK_FREQ_HZ             1000
+#define MHz                             1000000
+
+#define ACCUMULATOR_OVERFLOW            ((uint64_t)1 << 32)
+
+/* RTC default values */
+#define DEFAULT_srcClock                e_FM_RTC_SOURCE_CLOCK_SYSTEM
+#define DEFAULT_bypass      FALSE
+#define DEFAULT_invertInputClkPhase     FALSE
+#define DEFAULT_invertOutputClkPhase    FALSE
+#define DEFAULT_outputClockDivisor      0x00000002
+#define DEFAULT_alarmPolarity           e_FM_RTC_ALARM_POLARITY_ACTIVE_HIGH
+#define DEFAULT_triggerPolarity         e_FM_RTC_TRIGGER_ON_FALLING_EDGE
+#define DEFAULT_pulseRealign            FALSE
+#define DEFAULT_clockPeriod             1000
+
+/* FM RTC Registers definitions */
+#define TMR_CTRL_ALMP1                  0x80000000
+#define TMR_CTRL_ALMP2                  0x40000000
+#define TMR_CTRL_FS                     0x10000000
+#define TMR_CTRL_PP1L                   0x08000000
+#define TMR_CTRL_PP2L                   0x04000000
+#define TMR_CTRL_TCLK_PERIOD_MASK       0x03FF0000
+#define TMR_CTRL_FRD                    0x00004000
+#define TMR_CTRL_SLV                    0x00002000
+#define TMR_CTRL_ETEP1                  0x00000100
+#define TMR_CTRL_COPH                   0x00000080
+#define TMR_CTRL_CIPH                   0x00000040
+#define TMR_CTRL_TMSR                   0x00000020
+#define TMR_CTRL_DBG                    0x00000010
+#define TMR_CTRL_BYP                    0x00000008
+#define TMR_CTRL_TE                     0x00000004
+#define TMR_CTRL_CKSEL_OSC_CLK          0x00000003
+#define TMR_CTRL_CKSEL_MAC_CLK          0x00000001
+#define TMR_CTRL_CKSEL_EXT_CLK          0x00000000
+#define TMR_CTRL_TCLK_PERIOD_SHIFT      16
+
+#define TMR_TEVENT_ETS2                 0x02000000
+#define TMR_TEVENT_ETS1                 0x01000000
+#define TMR_TEVENT_ALM2                 0x00020000
+#define TMR_TEVENT_ALM1                 0x00010000
+#define TMR_TEVENT_PP1                  0x00000080
+#define TMR_TEVENT_PP2                  0x00000040
+#define TMR_TEVENT_PP3                  0x00000020
+#define TMR_TEVENT_ALL                  (TMR_TEVENT_ETS2 | TMR_TEVENT_ETS1 | \
+                                         TMR_TEVENT_ALM2 | TMR_TEVENT_ALM1 | \
+                                         TMR_TEVENT_PP1 | TMR_TEVENT_PP2 | TMR_TEVENT_PP3)
+
+#define TMR_PRSC_OCK_MASK               0x0000FFFF
+
+
+/**************************************************************************//**
+ @Description       Memory Mapped Registers
+*//***************************************************************************/
+
+#if defined(__MWERKS__) && !defined(__GNUC__)
+#pragma pack(push,1)
+#endif /* defined(__MWERKS__) && ... */
+#define MEM_MAP_START
+
+/**************************************************************************//**
+ @Description FM RTC timer alarm
+*//***************************************************************************/
+typedef _Packed struct t_TmrAlaram
+{
+    volatile uint32_t   tmr_alarm_h;    /**<  */
+    volatile uint32_t   tmr_alarm_l;    /**<  */
+} _PackedType t_TmrAlaram;
+
+/**************************************************************************//**
+ @Description FM RTC timer Ex trigger
+*//***************************************************************************/
+typedef _Packed struct t_TmrExtTrigger
+{
+    volatile uint32_t   tmr_etts_l;     /**<  */
+    volatile uint32_t   tmr_etts_h;     /**<  */
+} _PackedType t_TmrExtTrigger;
+
+typedef _Packed struct
+{
+    volatile uint32_t tmr_id;      /* Module ID and version register */
+    volatile uint32_t tmr_id2;     /* Module ID and configuration register */
+    volatile uint32_t PTP_RESERVED1[30];
+    volatile uint32_t tmr_ctrl;    /* timer control register */
+    volatile uint32_t tmr_tevent;  /* timer event register */
+    volatile uint32_t tmr_temask;  /* timer event mask register */
+    volatile uint32_t PTP_RESERVED2[3];
+    volatile uint32_t tmr_cnt_h;   /* timer counter high register */
+    volatile uint32_t tmr_cnt_l;   /* timer counter low register */
+    volatile uint32_t tmr_add;     /* timer drift compensation addend register */
+    volatile uint32_t tmr_acc;     /* timer accumulator register */
+    volatile uint32_t tmr_prsc;    /* timer prescale */
+    volatile uint32_t PTP_RESERVED3;
+    volatile uint32_t tmr_off_h;    /* timer offset high */
+    volatile uint32_t tmr_off_l;    /* timer offset low  */
+    volatile t_TmrAlaram tmr_alarm[FM_RTC_NUM_OF_ALARMS]; /* timer alarm */
+    volatile uint32_t PTP_RESERVED4[2];
+    volatile uint32_t tmr_fiper[FM_RTC_NUM_OF_PERIODIC_PULSES]; /* timer fixed period interval */
+    volatile uint32_t PTP_RESERVED5[2];
+    volatile t_TmrExtTrigger tmr_etts[FM_RTC_NUM_OF_EXT_TRIGGERS]; /*time stamp general purpose external */
+    volatile uint32_t PTP_RESERVED6[3];
+} _PackedType t_FmRtcMemMap;
+
+#define MEM_MAP_END
+#if defined(__MWERKS__) && !defined(__GNUC__)
+#pragma pack(pop)
+#endif /* defined(__MWERKS__) && ... */
+
+
+/**************************************************************************//**
+ @Description   RTC FM driver parameters structure.
+*//***************************************************************************/
+typedef struct t_FmRtcDriverParam
+{
+    t_Handle                h_Fm;                   /**<  */
+    e_FmSrcClk              srcClk;               /**<  */
+    uint32_t                extSrcClkFreq;         /**<  */
+    uint32_t                rtcFreqHz;              /**<  */
+    bool                    timerSlaveMode;         /*Slave/Master Mode*/
+    bool                    invertInputClkPhase;
+    bool                    invertOutputClkPhase;
+    uint32_t                eventsMask;
+    bool                    bypass; /**< Indicates if frequency compensation is bypassed */
+    bool                    pulseRealign;
+    e_FmRtcAlarmPolarity    alarmPolarity[FM_RTC_NUM_OF_ALARMS];
+    e_FmRtcTriggerPolarity  triggerPolarity[FM_RTC_NUM_OF_EXT_TRIGGERS];
+} t_FmRtcDriverParam;
+
+typedef struct t_FmRtcAlarm
+{
+    t_FmRtcExceptionsCallback   *f_AlarmCallback;
+    bool                        clearOnExpiration;
+} t_FmRtcAlarm;
+
+typedef struct t_FmRtcPeriodicPulse
+{
+    t_FmRtcExceptionsCallback   *f_PeriodicPulseCallback;
+} t_FmRtcPeriodicPulse;
+
+typedef struct t_FmRtcExternalTrigger
+{
+    t_FmRtcExceptionsCallback   *f_ExternalTriggerCallback;
+} t_FmRtcExternalTrigger;
+
+
+/**************************************************************************//**
+ @Description RTC FM driver control structure.
+*//***************************************************************************/
+typedef struct t_FmRtc
+{
+    t_Part                  *p_Part;            /**< Pointer to the integration device              */
+    t_Handle                h_Fm;
+    t_Handle                h_App;              /**< Application handle */
+    t_FmRtcMemMap           *p_MemMap;          /**< Pointer to RTC memory map */
+    uint32_t                clockPeriodNanoSec; /**< RTC clock period in nano-seconds (for FS mode) */
+    uint32_t                srcClkFreqMhz;
+    uint16_t                outputClockDivisor; /**< Output clock divisor (for FS mode) */
+    t_FmRtcAlarm            alarmParams[FM_RTC_NUM_OF_ALARMS];
+    t_FmRtcPeriodicPulse    periodicPulseParams[FM_RTC_NUM_OF_PERIODIC_PULSES];
+    t_FmRtcExternalTrigger  externalTriggerParams[FM_RTC_NUM_OF_EXT_TRIGGERS];
+    t_FmRtcDriverParam      *p_RtcDriverParam;  /**< RTC Driver parameters (for Init phase) */
+} t_FmRtc;
+
+
+#endif /* __FM_RTC_H__ */
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/fm.c b/drivers/net/dpa/NetCommSw/Peripherals/FM/fm.c
index 8b6be4f..015a599 100644
--- a/drivers/net/dpa/NetCommSw/Peripherals/FM/fm.c
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/fm.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -60,9 +60,6 @@ static t_Error CheckFmParameters(t_Fm *p_Fm)
 {
     uint8_t     i;
 
-    if(p_Fm->p_FmDriverParam->enTimeStamp)
-        if(!p_Fm->timeStampPeriod)
-            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("timeStampPeriod may not be 0"));
     if(!p_Fm->p_FmDriverParam->dmaAxiDbgNumOfBeats || (p_Fm->p_FmDriverParam->dmaAxiDbgNumOfBeats > DMA_MODE_MAX_AXI_DBG_NUM_OF_BEATS))
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("axiDbgNumOfBeats has to be in the range 1 - %d", DMA_MODE_MAX_AXI_DBG_NUM_OF_BEATS));
     if(p_Fm->p_FmDriverParam->dmaCamNumOfEntries % DMA_CAM_UNITS)
@@ -92,8 +89,9 @@ static t_Error CheckFmParameters(t_Fm *p_Fm)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fmClkFreq must be set."));
     if(USEC_TO_CLK(p_Fm->p_FmDriverParam->dmaWatchdog, p_Fm->fmClkFreq) > DMA_MAX_WATCHDOG)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dmaWatchdog depends on FM clock. dmaWatchdog(in microseconds) * clk (in Mhz), may not exceed 0xffffffff"));
-    for (i=0 ; i<FM_MAX_NUM_OF_PARTITIONS ; i++)
-        if(p_Fm->p_FmDriverParam->liodnPerPartition[i] & ~FM_LIODN_MASK)
+
+    for (i=0; i<FM_MAX_NUM_OF_PARTITIONS; i++)
+        if (p_Fm->p_FmDriverParam->liodnPerPartition[i] & ~FM_LIODN_BASE_MASK)
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("liodn number is out of range"));
 
     if(p_Fm->totalFifoSize % BMI_FIFO_UNITS)
@@ -108,7 +106,7 @@ static t_Error CheckFmParameters(t_Fm *p_Fm)
     if(p_Fm->p_FmDriverParam->thresholds.dispLimit > FPM_MAX_DISP_LIMIT)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("thresholds.dispLimit can't be greater than %d", FPM_MAX_DISP_LIMIT));
 
-    if(!p_Fm->f_Exceptions)
+    if(!p_Fm->f_Exception)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Exceptions callback not provided"));
     if(!p_Fm->f_BusError)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Exceptions callback not provided"));
@@ -172,11 +170,11 @@ static void    BmiErrEvent(t_Fm *p_Fm)
     WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_ievr, event);
 
     if(event & BMI_ERR_INTR_EN_PIPELINE_ECC)
-        p_Fm->f_Exceptions(p_Fm->h_App,e_FM_EX_BMI_PIPELINE_ECC);
+        p_Fm->f_Exception(p_Fm->h_App,e_FM_EX_BMI_PIPELINE_ECC);
     if(event & BMI_ERR_INTR_EN_LIST_RAM_ECC)
-        p_Fm->f_Exceptions(p_Fm->h_App,e_FM_EX_BMI_LIST_RAM_ECC);
+        p_Fm->f_Exception(p_Fm->h_App,e_FM_EX_BMI_LIST_RAM_ECC);
     if(event & BMI_ERR_INTR_EN_STATISTICS_RAM_ECC)
-        p_Fm->f_Exceptions(p_Fm->h_App,e_FM_EX_BMI_STATISTICS_RAM_ECC);
+        p_Fm->f_Exception(p_Fm->h_App,e_FM_EX_BMI_STATISTICS_RAM_ECC);
 }
 
 static void    QmiErrEvent(t_Fm *p_Fm)
@@ -195,9 +193,9 @@ static void    QmiErrEvent(t_Fm *p_Fm)
     WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_eie, event);
 
     if(event & QMI_ERR_INTR_EN_DOUBLE_ECC)
-        p_Fm->f_Exceptions(p_Fm->h_App,e_FM_EX_QMI_DOUBLE_ECC);
+        p_Fm->f_Exception(p_Fm->h_App,e_FM_EX_QMI_DOUBLE_ECC);
     if(event & QMI_ERR_INTR_EN_DEQ_FROM_DEF)
-        p_Fm->f_Exceptions(p_Fm->h_App,e_FM_EX_QMI_DEQ_FROM_DEFQ);
+        p_Fm->f_Exception(p_Fm->h_App,e_FM_EX_QMI_DEQ_FROM_UNKNOWN_PORTID);
 }
 
 static void    DmaErrEvent(t_Fm *p_Fm)
@@ -237,11 +235,11 @@ static void    DmaErrEvent(t_Fm *p_Fm)
     if(mask & DMA_MODE_ECC)
     {
         if (status & DMA_STATUS_READ_ECC)
-            p_Fm->f_Exceptions(p_Fm->h_App, e_FM_EX_DMA_READ_ECC) ;
+            p_Fm->f_Exception(p_Fm->h_App, e_FM_EX_DMA_READ_ECC) ;
         if (status & DMA_STATUS_SYSTEM_WRITE_ECC)
-            p_Fm->f_Exceptions(p_Fm->h_App, e_FM_EX_DMA_SYSTEM_WRITE_ECC) ;
+            p_Fm->f_Exception(p_Fm->h_App, e_FM_EX_DMA_SYSTEM_WRITE_ECC) ;
         if (status & DMA_STATUS_FM_WRITE_ECC)
-            p_Fm->f_Exceptions(p_Fm->h_App, e_FM_EX_DMA_FM_WRITE_ECC) ;
+            p_Fm->f_Exception(p_Fm->h_App, e_FM_EX_DMA_FM_WRITE_ECC) ;
     }
 }
 
@@ -255,11 +253,11 @@ static void    FpmErrEvent(t_Fm *p_Fm)
     WRITE_UINT32(p_Fm->p_FmFpmRegs->fpmem, event);
 
     if((event  & FPM_EV_MASK_DOUBLE_ECC) && (event & FPM_EV_MASK_DOUBLE_ECC_EN))
-        p_Fm->f_Exceptions(p_Fm->h_App,e_FM_EX_FPM_DOUBLE_ECC);
+        p_Fm->f_Exception(p_Fm->h_App,e_FM_EX_FPM_DOUBLE_ECC);
     if((event  & FPM_EV_MASK_STALL) && (event & FPM_EV_MASK_STALL_EN))
-        p_Fm->f_Exceptions(p_Fm->h_App,e_FM_EX_FPM_STALL_ON_TASKS);
+        p_Fm->f_Exception(p_Fm->h_App,e_FM_EX_FPM_STALL_ON_TASKS);
     if((event  & FPM_EV_MASK_SINGLE_ECC) && (event & FPM_EV_MASK_SINGLE_ECC_EN))
-        p_Fm->f_Exceptions(p_Fm->h_App,e_FM_EX_FPM_SINGLE_ECC);
+        p_Fm->f_Exception(p_Fm->h_App,e_FM_EX_FPM_SINGLE_ECC);
 }
 
 static void    MuramErrIntr(t_Fm *p_Fm)
@@ -267,47 +265,35 @@ static void    MuramErrIntr(t_Fm *p_Fm)
     uint32_t    event, mask;
 
     event = GET_UINT32(p_Fm->p_FmFpmRegs->fmrcr);
-    mask = GET_UINT32(p_Fm->p_FmFpmRegs->fmeie);
+    mask = GET_UINT32(p_Fm->p_FmFpmRegs->fmrie);
 
     /* clear MURAM event bit */
     WRITE_UINT32(p_Fm->p_FmFpmRegs->fmrcr, event & ~FPM_RAM_CTL_IRAM_ECC);
 
-
-    ASSERT_COND(event  & FPM_RAM_CTL_MURAM_ECC);
-    ASSERT_COND(event  & FPM_RAM_CTL_RAMS_ECC_EN);
+    ASSERT_COND(event & FPM_RAM_CTL_MURAM_ECC);
+    ASSERT_COND(event & FPM_RAM_CTL_RAMS_ECC_EN);
 
     if ((mask & FPM_MURAM_ECC_ERR_EX_EN))
-        p_Fm->f_Exceptions(p_Fm->h_App, e_FM_EX_MURAM_ECC);
-
-#ifdef BUP_ERRATA_RAM_INTR
-    else
-        DBG(WARNING, ("MURAM masked Interrupt ..."));
-#endif /* BUP_ERRATA_RAM_INTR */
-
+        p_Fm->f_Exception(p_Fm->h_App, e_FM_EX_MURAM_ECC);
 }
 
-static void    IramErrIntr(t_Fm *p_Fm)
+static void IramErrIntr(t_Fm *p_Fm)
 {
     uint32_t    event, mask;
 
     event = GET_UINT32(p_Fm->p_FmFpmRegs->fmrcr) ;
-    mask = GET_UINT32(p_Fm->p_FmFpmRegs->fmeie);
+    mask = GET_UINT32(p_Fm->p_FmFpmRegs->fmrie);
     /* clear the acknowledged events (do not clear IRAM event) */
-    WRITE_UINT32(p_Fm->p_FmFpmRegs->fmrcr, event & ~FPM_RAM_CTL_MURAM_ECC );
+    WRITE_UINT32(p_Fm->p_FmFpmRegs->fmrcr, event & ~FPM_RAM_CTL_MURAM_ECC);
 
-    ASSERT_COND(event  & FPM_RAM_CTL_IRAM_ECC);
-    ASSERT_COND(event  & FPM_RAM_CTL_IRAM_ECC_EN);
+    ASSERT_COND(event & FPM_RAM_CTL_IRAM_ECC);
+    ASSERT_COND(event & FPM_RAM_CTL_IRAM_ECC_EN);
 
     if ((mask & FPM_IRAM_ECC_ERR_EX_EN))
-        p_Fm->f_Exceptions(p_Fm->h_App, e_FM_EX_IRAM_ECC);
-
-#ifdef BUP_ERRATA_RAM_INTR
-    else
-        DBG(WARNING, ("IRAM masked Interrupt ..."));
-#endif /* BUP_ERRATA_RAM_INTR */
+        p_Fm->f_Exception(p_Fm->h_App, e_FM_EX_IRAM_ECC);
 }
 
-static void     QmiEvent(t_Fm *p_Fm)
+static void QmiEvent(t_Fm *p_Fm)
 {
     uint32_t    event, mask;
 
@@ -323,10 +309,10 @@ static void     QmiEvent(t_Fm *p_Fm)
     WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_ie, event);
 
     if(event & QMI_INTR_EN_SINGLE_ECC)
-        p_Fm->f_Exceptions(p_Fm->h_App,e_FM_EX_QMI_SINGLE_ECC);
+        p_Fm->f_Exception(p_Fm->h_App,e_FM_EX_QMI_SINGLE_ECC);
 }
 
-static void     FmCtlEvent(t_Fm *p_Fm, uint32_t pending)
+static void CtlEvent(t_Fm *p_Fm, uint32_t pending)
 {
     uint32_t    eventRegBitMask = FPM_EVENT_FM_CTL_0;
     uint8_t     i;
@@ -359,7 +345,40 @@ static void UnimplementedFmCtlIsr(t_Handle h_Arg, uint32_t event)
     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Unimplemented FmCtl Isr!"));
 }
 
-static void FmFreeInitResources(t_Fm *p_Fm)
+static void FmEnableTimeStamp(t_Fm *p_Fm)
+{
+    uint32_t                tmpReg;
+    uint64_t                fraction;
+    uint32_t                integer;
+    uint8_t                 count1MicroBit = 8;
+    uint32_t                tsFrequency = (uint32_t)(1<<count1MicroBit); /* in Mhz */
+
+    /* configure timestamp so that bit 8 will count 1 microsecond */
+    /* Find effective count rate at TIMESTAMP least significant bits:
+       Effective_Count_Rate = 1MHz x 2^8 = 256MHz
+       Find frequency ratio between effective count rate and the clock:
+       Effective_Count_Rate / CLK e.g. for 600 MHz clock:
+       256/600 = 0.4266666... */
+    integer = tsFrequency/p_Fm->fmClkFreq;
+    /* we multiply by 2^16 to keep the fraction of the division */
+    /* we do not divid back, since we write this value as fraction - see spec */
+    fraction = ((tsFrequency << 16) - (integer << 16)*p_Fm->fmClkFreq)/p_Fm->fmClkFreq;
+    /* we check remainder of the division in order to round up if not interger */
+    if(((tsFrequency << 16) - (integer << 16)*p_Fm->fmClkFreq) % p_Fm->fmClkFreq)
+        fraction++;
+
+    tmpReg = (integer << FPM_TS_INT_SHIFT) | (uint16_t)fraction;
+    WRITE_UINT32(p_Fm->p_FmFpmRegs->fpmtsc2, tmpReg);
+
+    /* enable timestamp with original clock */
+    WRITE_UINT32(p_Fm->p_FmFpmRegs->fpmtsc1, FPM_TS_CTL_EN);
+
+    p_Fm->count1MicroBit = count1MicroBit;
+    p_Fm->enabledTimeStamp = TRUE;
+}
+
+
+static void FreeInitResources(t_Fm *p_Fm)
 {
     if (p_Fm->camBaseAddr)
        FM_MURAM_FreeMem(p_Fm->h_FmMuram, CAST_UINT64_TO_POINTER(p_Fm->camBaseAddr));
@@ -367,33 +386,47 @@ static void FmFreeInitResources(t_Fm *p_Fm)
        FM_MURAM_FreeMem(p_Fm->h_FmMuram, CAST_UINT64_TO_POINTER(p_Fm->fifoBaseAddr));
 }
 
-static t_Error LoadUCode(t_Fm *p_Fm)
+static t_Error ClearIRam(t_Fm *p_Fm)
 {
     t_FMIramRegs    *p_Iram = CAST_UINT64_TO_POINTER_TYPE(t_FMIramRegs, (p_Fm->baseAddr + FM_MM_IMEM));
-    uint32_t        *p_Muram = CAST_UINT64_TO_POINTER_TYPE(uint32_t, (p_Fm->baseAddr + FM_MM_MURAM));
     int             i;
-    uint32_t        tmp;
-    uint8_t         compTo16;
 
     SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
 
-    /* clear MURAM */
-    for (i=0; i < FM_MURAM_SIZE/4; i++)
-        WRITE_UINT32(*(p_Muram+i), 0);
+    /* Enable the auto-increment */
+    WRITE_UINT32(p_Iram->iadd, IRAM_IADD_AIE);
+    while (GET_UINT32(p_Iram->iadd) != IRAM_IADD_AIE) ;
+
+    for (i=0; i < (FM_IRAM_SIZE / 4); i++)
+        WRITE_UINT32(p_Iram->idata, 0xffffffff);
+
+    WRITE_UINT32(p_Iram->iadd,0x0);
+    /* verify that writing has completed */
+    while (GET_UINT32(p_Iram->idata) != 0xffffffff) ;
+
+    return E_OK;
+}
 
-    DBG(TRACE, ("Loading firmware to IRAM ..."));
+static t_Error LoadFmanCtrlCode(t_Fm *p_Fm)
+{
+    t_FMIramRegs    *p_Iram = CAST_UINT64_TO_POINTER_TYPE(t_FMIramRegs, (p_Fm->baseAddr + FM_MM_IMEM));
+    int             i;
+    uint32_t        tmp;
+    uint8_t         compTo16;
 
-    /* Applying patch to IRAM */
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+
+    /* Enable the auto-increment */
     WRITE_UINT32(p_Iram->iadd, IRAM_IADD_AIE);
     while (GET_UINT32(p_Iram->iadd) != IRAM_IADD_AIE) ;
 
     for (i=0; i < (p_Fm->p_FmDriverParam->firmware.size / 4); i++)
         WRITE_UINT32(p_Iram->idata, p_Fm->p_FmDriverParam->firmware.p_Code[i]);
 
-    compTo16 = p_Fm->p_FmDriverParam->firmware.size %16;
+    compTo16 = (uint8_t)(p_Fm->p_FmDriverParam->firmware.size % 16);
     if(compTo16)
         for (i=0; i < ((16-compTo16) / 4); i++)
-            WRITE_UINT32(p_Iram->idata, 0);
+            WRITE_UINT32(p_Iram->idata, 0xffffffff);
 
     WRITE_UINT32(p_Iram->iadd,0x0);
     /* verify that writing has completed */
@@ -408,12 +441,16 @@ static t_Error LoadUCode(t_Fm *p_Fm)
                 RETURN_ERROR(MAJOR, E_WRITE_FAILED,
                              ("UCode write error : write 0x%x, read 0x%x",
                               p_Fm->p_FmDriverParam->firmware.p_Code[i],tmp));
-        WRITE_UINT32(p_Iram->iadd,0x0);
+        WRITE_UINT32(p_Iram->iadd, 0x0);
     }
 
     /* Enable patch from IRAM */
     WRITE_UINT32(p_Iram->iready, IRAM_READY);
 
+    DBG(INFO, ("FMan-Controller code (ver %d.%d) loaded to IRAM.",
+               ((uint8_t *)p_Fm->p_FmDriverParam->firmware.p_Code)[5],
+               ((uint8_t *)p_Fm->p_FmDriverParam->firmware.p_Code)[7]));
+
     return E_OK;
 }
 
@@ -443,6 +480,9 @@ t_Error     FmHandleIpcMsg(t_Handle h_Fm, uint32_t msgId, uint8_t msgBody[MSG_BO
             memcpy(msgBody, (uint8_t *)&ipcParams, sizeof(t_FmIpcMacReset));
             return FmResetMac(p_Fm, (e_FmMacType)ipcParams.type, ipcParams.id);
         }
+        case (FM_GET_CLK_FREQ):
+            *(uint16_t*)msgBody = p_Fm->fmClkFreq;
+            break;
         case (FM_FREE_PORT):
             FmFreePortParams(h_Fm, (t_FmInterModulePortFreeParams*)msgBody);
             break;
@@ -453,6 +493,11 @@ t_Error     FmHandleIpcMsg(t_Handle h_Fm, uint32_t msgId, uint8_t msgBody[MSG_BO
         case (FM_DUMP_PORT_REGS):
             return FmDumpPortRegs(h_Fm, msgBody[0]);
 #endif /* (defined(DEBUG_ERRORS) && ... */
+        case (FM_GET_REV):
+        case (FM_GET_COUNTER):
+        case (FM_GET_TIMESTAMP):
+        case (FM_GET_TIMESTAMP_PERIOD):
+            RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
         default:
             RETURN_ERROR(MINOR, E_INVALID_SELECTION, ("command not found!!!"));
     }
@@ -503,13 +548,12 @@ t_Error FmGetPhysicalMuramBase(t_Handle h_Fm, t_FmPhysAddr *fmPhysAddr)
     SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
 
     /* General FM driver initialization */
-    fmPhysAddr->low=(uint32_t)p_Fm->fmMuramPhysBaseAddr;
-    fmPhysAddr->high=(uint16_t)((p_Fm->fmMuramPhysBaseAddr & 0x0000ffff00000000LL) >> 32);
+    fmPhysAddr->low = (uint32_t)p_Fm->fmMuramPhysBaseAddr;
+    fmPhysAddr->high = (uint8_t)((p_Fm->fmMuramPhysBaseAddr & 0x000000ff00000000LL) >> 32);
 
     return E_OK;
 }
 
-
 void FmRegisterIntr(t_Handle h_Fm,
                         e_FmEventModules        module,
                         uint8_t                 modId,
@@ -520,13 +564,28 @@ void FmRegisterIntr(t_Handle h_Fm,
     t_Fm       *p_Fm = (t_Fm*)h_Fm;
     uint8_t     event= 0;
 
-    GET_MODULE_EVENT(module, modId,intrType, event);
+    GET_FM_MODULE_EVENT(module, modId,intrType, event);
 
     ASSERT_COND(event != e_FM_EV_DUMMY_LAST);
     p_Fm->intrMng[event].f_Isr = f_Isr;
     p_Fm->intrMng[event].h_SrcHandle = h_Arg;
 }
 
+void FmUnregisterIntr(t_Handle h_Fm,
+                        e_FmEventModules        module,
+                        uint8_t                 modId,
+                        e_FmIntrType            intrType)
+{
+    t_Fm       *p_Fm = (t_Fm*)h_Fm;
+    uint8_t     event= 0;
+
+    GET_FM_MODULE_EVENT(module, modId,intrType, event);
+
+    ASSERT_COND(event != e_FM_EV_DUMMY_LAST);
+    p_Fm->intrMng[event].f_Isr = NULL;
+    p_Fm->intrMng[event].h_SrcHandle = NULL;
+}
+
 void  FmRegisterFmCtlIntr(t_Handle h_Fm, uint8_t eventRegId, void (*f_Isr) (t_Handle h_Fm, uint32_t event))
 {
     t_Fm       *p_Fm = (t_Fm*)h_Fm;
@@ -545,6 +604,17 @@ void  FmRegisterPcd(t_Handle h_Fm, t_Handle h_FmPcd)
 
 }
 
+void  FmUnregisterPcd(t_Handle h_Fm)
+{
+    t_Fm       *p_Fm = (t_Fm*)h_Fm;
+
+    if(!p_Fm->h_Pcd)
+        REPORT_ERROR(MAJOR, E_ALREADY_EXISTS, ("No PCD"));
+
+    p_Fm->h_Pcd = NULL;
+
+}
+
 t_Handle  FmGetPcdHandle(t_Handle h_Fm)
 {
     t_Fm       *p_Fm = (t_Fm*)h_Fm;
@@ -574,7 +644,12 @@ t_Error FmGetSetPortParams(t_Handle h_Fm,t_FmInterModulePortInitParams *p_PortPa
     SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
 
     /* return parameters */
-    p_PortParams->timeStampPeriod = p_Fm->timeStampPeriod;
+    if (p_PortParams->useRateLimit)
+    {
+        if(!p_Fm->enabledTimeStamp)
+            FmEnableTimeStamp(p_Fm);
+        p_PortParams->count1MicroBit = p_Fm->count1MicroBit;
+    }
 
     if(p_PortParams->independentMode)
     {
@@ -584,7 +659,7 @@ t_Error FmGetSetPortParams(t_Handle h_Fm,t_FmInterModulePortInitParams *p_PortPa
         WRITE_UINT32(p_Fm->p_FmFpmRegs->fpmflc, 0);
     }
 
-    if(p_PortParams->portType == e_FM_PORT_TYPE_HOST_COMMAND)
+    if(p_PortParams->portType == e_FM_PORT_TYPE_OH_HOST_COMMAND)
     {
         if(p_Fm->hcPortInitialized)
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Only one host command port is allowed."));
@@ -707,7 +782,7 @@ void FmFreePortParams(t_Handle h_Fm,t_FmInterModulePortFreeParams *p_PortParams)
 
     SANITY_CHECK_RETURN(p_Fm, E_INVALID_HANDLE);
 
-    if(p_PortParams->portType == e_FM_PORT_TYPE_HOST_COMMAND)
+    if(p_PortParams->portType == e_FM_PORT_TYPE_OH_HOST_COMMAND)
     {
         ASSERT_COND(p_Fm->hcPortInitialized);
         p_Fm->hcPortInitialized = FALSE;
@@ -737,7 +812,7 @@ void FmFreePortParams(t_Handle h_Fm,t_FmInterModulePortFreeParams *p_PortParams)
     if((p_PortParams->portType != e_FM_PORT_TYPE_RX) && (p_PortParams->portType != e_FM_PORT_TYPE_RX_10G))
     /* for transmit & O/H ports */
     {
-        tmpReg = 0;
+        tmpReg = GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_gc);
         /* update qmi ENQ/DEQ threshold */
         p_Fm->accumulatedNumOfDeqTnums -= p_PortParams->deqPipelineDepth;
 
@@ -748,7 +823,7 @@ void FmFreePortParams(t_Handle h_Fm,t_FmInterModulePortFreeParams *p_PortParams)
         tmpReg |= ((uint32_t)enqTh << QMI_CFG_ENQ_SHIFT);
 
          /* p_Fm->accumulatedNumOfDeqTnums is now smaller,
-           so we can reduce enqTh */
+           so we can reduce deqTh */
         deqTh = (uint8_t)(p_Fm->accumulatedNumOfDeqTnums + 1);
         tmpReg &= ~QMI_CFG_DEQ_MASK;
         tmpReg |= (uint32_t)deqTh;
@@ -759,7 +834,6 @@ void FmFreePortParams(t_Handle h_Fm,t_FmInterModulePortFreeParams *p_PortParams)
     return;
 }
 
-
 bool FmIsPortStalled(t_Handle h_Fm, uint8_t hardwarePortId)
 {
     t_Fm        *p_Fm = (t_Fm*)h_Fm;
@@ -835,14 +909,23 @@ t_Error FmResetMac(t_Handle h_Fm, e_FmMacType type, uint8_t macId)
     return E_OK;
 }
 
-uint32_t    FmGetTimeStampPeriod(t_Handle h_Fm)
+uint16_t FmGetClockFreq(t_Handle h_Fm)
+{
+    t_Fm *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_VALUE(p_Fm, E_INVALID_HANDLE, 0);
+
+    return p_Fm->fmClkFreq;
+}
+uint32_t    FmGetTimeStampScale(t_Handle h_Fm)
 {
     t_Fm *p_Fm = (t_Fm*)h_Fm;
 
     SANITY_CHECK_RETURN_VALUE(p_Fm, E_INVALID_HANDLE, 0);
-    SANITY_CHECK_RETURN_VALUE(p_Fm->timeStampPeriod, E_INVALID_HANDLE, 0);
 
-    return p_Fm->timeStampPeriod;
+    if(!p_Fm->enabledTimeStamp)
+        FmEnableTimeStamp(h_Fm);
+    return p_Fm->count1MicroBit;
 }
 
 bool FmRamsEccIsExternalCtl(t_Handle h_Fm)
@@ -857,6 +940,40 @@ bool FmRamsEccIsExternalCtl(t_Handle h_Fm)
         return FALSE;
 }
 
+t_Error FmEnableRamsEcc(t_Handle h_Fm)
+{
+    t_Fm        *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+
+    p_Fm->ramsEccOwners++;
+    p_Fm->internalCall = TRUE;
+
+    return FM_EnableRamsEcc(p_Fm);
+}
+
+t_Error FmDisableRamsEcc(t_Handle h_Fm)
+{
+    t_Fm        *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+
+    ASSERT_COND(p_Fm->ramsEccOwners);
+    p_Fm->ramsEccOwners--;
+
+    if(p_Fm->ramsEccOwners==0)
+    {
+        p_Fm->internalCall = TRUE;
+        return FM_DisableRamsEcc(p_Fm);
+    }
+    return E_OK;
+}
+
+void FmGetRevision(t_Handle h_Fm, t_FmRevisionInfo *p_FmRevisionInfo)
+{
+    FM_GetRevision(h_Fm, p_FmRevisionInfo);
+}
+
 #ifdef CONFIG_MULTI_PARTITION_SUPPORT
 uint8_t FmGetPartitionId(t_Handle h_Fm)
 {
@@ -925,7 +1042,7 @@ t_Handle FM_Config(t_FmParams *p_FmParam)
     p_Fm->h_FmMuram         = p_FmParam->h_FmMuram;
     p_Fm->h_App             = p_FmParam->h_App;
     p_Fm->fmClkFreq         = p_FmParam->fmClkFreq;
-    p_Fm->f_Exceptions      = p_FmParam->f_Exceptions;
+    p_Fm->f_Exception      = p_FmParam->f_Exception;
     p_Fm->f_BusError        = p_FmParam->f_BusError;
     p_Fm->p_FmFpmRegs       = CAST_UINT64_TO_POINTER_TYPE(t_FmFpmRegs, (baseAddr + FM_MM_FPM));
     p_Fm->p_FmBmiRegs       = CAST_UINT64_TO_POINTER_TYPE(t_FmBmiRegs, (baseAddr + FM_MM_BMI));
@@ -942,11 +1059,30 @@ t_Handle FM_Config(t_FmParams *p_FmParam)
     p_Fm->maxNumOfOpenDmas  = DEFAULT_maxNumOfOpenDmas;
     p_Fm->extraFifoPoolSize     = FM_MAX_NUM_OF_RX_PORTS*BMI_FIFO_UNITS;
 
-    p_Fm->exceptions        = DEFAULT_exceptions;
+    p_Fm->exceptions            = DEFAULT_exceptions;
+
+#ifdef FM_RAM_LIST_ERR_IRQ_ERRATA_FMAN11
+    {
+        t_FmRevisionInfo revInfo;
+        FmGetRevision(p_Fm, &revInfo);
+        if ((revInfo.majorRev == 1) && (revInfo.minorRev == 0))
+            p_Fm->exceptions  &= ~FM_EX_BMI_LIST_RAM_ECC;
+    }
+#endif   /* FM_RAM_LIST_ERR_IRQ_ERRATA_FMAN11 */
+
+#ifdef FM_IRAM_ECC_ERR_IRQ_ERRATA
+    {
+        t_FmRevisionInfo revInfo;
+        FmGetRevision(p_Fm, &revInfo);
+        if ((revInfo.majorRev == 1) && (revInfo.minorRev == 0))
+            p_Fm->exceptions  &= ~FM_EX_IRAM_ECC;
+    }
+#endif   /* FM_IRAM_ECC_ERR_IRQ_ERRATA */
+
     for(i = 0;i<FM_MAX_NUM_OF_PORTS;i++)
         p_Fm->portsTypes[i] = e_FM_PORT_TYPE_DUMMY;
     /* Initialize FM driver parameters parameters (for initialization phase only) */
-    memcpy(p_Fm->p_FmDriverParam->liodnPerPartition, p_FmParam->liodnPerPartition, FM_MAX_NUM_OF_PARTITIONS);
+    memcpy(p_Fm->p_FmDriverParam->liodnPerPartition, p_FmParam->liodnPerPartition, FM_MAX_NUM_OF_PARTITIONS*sizeof(uint16_t));
 
     /*p_Fm->p_FmDriverParam->numOfPartitions                      = p_FmParam->numOfPartitions;    */
     p_Fm->p_FmDriverParam->enCounters                           = FALSE;
@@ -963,8 +1099,6 @@ t_Handle FM_Config(t_FmParams *p_FmParam)
     p_Fm->p_FmDriverParam->thresholds.fmCtl1DispTh               = DEFAULT_fmCtl1DispTh;
     p_Fm->p_FmDriverParam->thresholds.fmCtl2DispTh               = DEFAULT_fmCtl2DispTh;
 
-    p_Fm->p_FmDriverParam->enTimeStamp                          = FALSE;
-
     p_Fm->p_FmDriverParam->dmaStopOnBusError                    = DEFAULT_dmaStopOnBusError;
     p_Fm->p_FmDriverParam->dmaBusProtect.privilegeBusProtect    = DEFAULT_privilegeBusProtect;
     p_Fm->p_FmDriverParam->dmaBusProtect.busProtectType         = DEFAULT_busProtectionType;
@@ -999,7 +1133,6 @@ t_Handle FM_Config(t_FmParams *p_FmParam)
     p_Fm->p_FmDriverParam->dmaErr                               = DEFAULT_dmaErr;
     p_Fm->p_FmDriverParam->haltOnExternalActivation             = DEFAULT_haltOnExternalActivation;
     p_Fm->p_FmDriverParam->haltOnUnrecoverableEccError          = DEFAULT_haltOnUnrecoverableEccError;
-
     p_Fm->p_FmDriverParam->enIramTestMode                       = FALSE;
     p_Fm->p_FmDriverParam->enMuramTestMode                      = FALSE;
     p_Fm->p_FmDriverParam->externalEccRamsEnable                = DEFAULT_externalEccRamsEnable;
@@ -1020,7 +1153,7 @@ t_Handle FM_Config(t_FmParams *p_FmParam)
     }
 
 #ifdef CONFIG_MULTI_PARTITION_SUPPORT
-    /* register to inter-core messaging mechanism */
+    /* build the FM master partition IPC address */
     memset(p_Fm->fmModuleName, 0, MODULE_NAME_SIZE);
     if(Sprint (p_Fm->fmModuleName, "FM-%d-Master",p_Fm->fmId) != 11)
     {
@@ -1052,8 +1185,6 @@ t_Error FM_Init(t_Handle h_Fm)
 #endif /* FM_MASTER_PARTITION */
     uint32_t                tmpReg, cfgReg = 0;
     int                     i;
-    uint64_t                fraction;
-    uint32_t                prescalar, integer, period;
 
     SANITY_CHECK_RETURN_ERROR(h_Fm, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
@@ -1065,15 +1196,17 @@ t_Error FM_Init(t_Handle h_Fm)
     if(p_FmDriverParam->resetOnInit)
         WRITE_UINT32(p_Fm->p_FmFpmRegs->fmrstc, FPM_RSTC_FM_RESET);
 
-    /**********************/
-    /* Load patch to Iram */
-    /**********************/
+    /*************************************/
+    /* Load FMan-Controller code to Iram */
+    /*************************************/
+    if (ClearIRam(p_Fm) != E_OK)
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
     if (p_Fm->p_FmDriverParam->firmware.p_Code &&
-        (LoadUCode(p_Fm) != E_OK))
+        (LoadFmanCtrlCode(p_Fm) != E_OK))
         RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
 
     /* General FM driver initialization */
-    p_Fm->fmMuramPhysBaseAddr = CAST_POINTER_TO_UINT64(XX_VirtToPhys(CAST_UINT64_TO_POINTER(p_Fm->baseAddr + FM_MM_MURAM)));
+    p_Fm->fmMuramPhysBaseAddr = (uint64_t)(XX_VirtToPhys(CAST_UINT64_TO_POINTER(p_Fm->baseAddr + FM_MM_MURAM)));
     for(i=0;i<e_FM_EV_DUMMY_LAST;i++)
         p_Fm->intrMng[i].f_Isr = UnimplementedIsr;
     for(i=0;i<NUM_OF_FM_CTL_EVENT_REGS;i++)
@@ -1147,7 +1280,7 @@ t_Error FM_Init(t_Handle h_Fm)
 #endif /* VERIFICATION_SUPPORT */
     /* VirtToPhys */
     WRITE_UINT32(p_Fm->p_FmDmaRegs->fmdmebcr,
-                 (uint32_t)(CAST_POINTER_TO_UINT64(XX_VirtToPhys(CAST_UINT64_TO_POINTER(p_Fm->camBaseAddr))) -
+                 (uint32_t)((uint64_t)(XX_VirtToPhys(CAST_UINT64_TO_POINTER(p_Fm->camBaseAddr))) -
                             p_Fm->fmMuramPhysBaseAddr));
 
     /* liodn-partitions */
@@ -1199,65 +1332,13 @@ t_Error FM_Init(t_Handle h_Fm)
     for(i=0;i<NUM_OF_FM_CTL_EVENT_REGS;i++)
         WRITE_UINT32(p_Fm->p_FmFpmRegs->fpmcev[i], 0xFFFFFFFF);
 
-    /* timeStamp */
-    if(p_FmDriverParam->enTimeStamp)
-    {
-        period = p_Fm->timeStampPeriod;
-
-        /* calculate the prescalar, considering fmClkFreq is in Mhz, and
-        timeStampPeriod is in nanoseconds */
-        prescalar = (period * p_Fm->fmClkFreq)/1000;
-        if(!prescalar)
-            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("timeStampPeriod is too small"));
-        if(prescalar > 256)
-            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("timeStampPeriod is too large"));
-        WRITE_UINT32(p_Fm->p_FmFpmRegs->fpmtsc1, (uint32_t)((prescalar - 1) | FPM_TS_CTL_EN));
-
-        /* the FM HW allows to increase precision by enlarging timeStamp value by value
-        different than 1, possibly by fraction. */
-        integer  = (prescalar * 1000)/ (period * p_Fm->fmClkFreq); /* always 0 */
-        if(integer > 255)
-            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("timeStampPeriod  is too large"));
-
-        /* Since the prescalar may have been be rounded down, we increase the timeStamp by
-        value smaller than the resolution required (and smaller than 1 when resolution is normally 1).
-        Here we calculate the fraction that will give us the nearest result.
-        Since we prefer not to use floating variables, we need to multiply by a large factor in
-        order to get a precise enough number. Since the HW implementation uses 24-bit-fixed-point
-        representation, a 16 bit fraction is used. In order to calculate the fraction value, we should
-        multiply the number by 2^16. We therefor use the 2^16 also as the factor for
-        the multiplication, and do not use another one for enlarging the fraction. */
-        fraction = ((uint64_t)((uint64_t)(prescalar * 1000) << 16)/ (period * p_Fm->fmClkFreq)) - (integer << 16);
-        ASSERT_COND((fraction & ~FPM_TS_FRACTION_MASK) == 0);
-        tmpReg = (integer << FPM_TS_INT_SHIFT) | (uint16_t)fraction;
-        WRITE_UINT32(p_Fm->p_FmFpmRegs->fpmtsc2, tmpReg);
-    }
-
 #ifndef VERIFICATION_SUPPORT
     /* RAM ECC -  enable and clear events*/
     /* first we need to clear all parser memory, as it is uninitialized and
     may cause ECC errors */
-   /* for(i=0;i<FM_SW_PRS_SIZE;i+=4)
-        WRITE_UINT32(*CAST_UINT64_TO_POINTER_TYPE(uint32_t, (p_Fm->baseAddr + FM_MM_PRS + i)), 0);
-*/
     tmpReg = 0;
-    if(p_Fm->exceptions & FM_EX_IRAM_ECC)
-    {
-        p_Fm->ramsEccEnable = TRUE;
-        tmpReg |= FPM_IRAM_ECC_ERR_EX_EN;
-    }
-    if(p_Fm->exceptions & FM_EX_NURAM_ECC)
-    {
-        p_Fm->ramsEccEnable = TRUE;
-        tmpReg |= FPM_MURAM_ECC_ERR_EX_EN;
-    }
-    WRITE_UINT32(p_Fm->p_FmFpmRegs->fmeie, tmpReg);
-
     /* event bits */
     tmpReg = (FPM_RAM_CTL_MURAM_ECC | FPM_RAM_CTL_IRAM_ECC);
-    /* enable ECC */
-    if(p_Fm->ramsEccEnable)
-        tmpReg |= (FPM_RAM_CTL_RAMS_ECC_EN | FPM_RAM_CTL_IRAM_ECC_EN);
     /* Rams enable is not effected by the RCR bit, but by a COP configuration */
     if(p_Fm->p_FmDriverParam->externalEccRamsEnable)
         tmpReg |= FPM_RAM_CTL_RAMS_ECC_EN_SRC_SEL;
@@ -1268,7 +1349,19 @@ t_Error FM_Init(t_Handle h_Fm)
     if(p_FmDriverParam->enIramTestMode)
         tmpReg |= FPM_RAM_CTL_IRAM_TEST_ECC;
     WRITE_UINT32(p_Fm->p_FmFpmRegs->fmrcr, tmpReg);
-#endif  /*  VERIFICATION_SUPPORT */
+
+    if(p_Fm->exceptions & FM_EX_IRAM_ECC)
+    {
+        tmpReg |= FPM_IRAM_ECC_ERR_EX_EN;
+        FmEnableRamsEcc(p_Fm);
+    }
+    if(p_Fm->exceptions & FM_EX_NURAM_ECC)
+    {
+        tmpReg |= FPM_MURAM_ECC_ERR_EX_EN;
+        FmEnableRamsEcc(p_Fm);
+    }
+    WRITE_UINT32(p_Fm->p_FmFpmRegs->fmrie, tmpReg);
+ #endif  /*  VERIFICATION_SUPPORT */
 
     /**********************/
     /* Init BMI Registers */
@@ -1281,11 +1374,11 @@ t_Error FM_Init(t_Handle h_Fm)
                                                                   BMI_FIFO_ALIGN));
     if (!p_Fm->fifoBaseAddr)
     {
-        FmFreeInitResources(p_Fm);
+        FreeInitResources(p_Fm);
         RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc for FIFO failed"));
     }
 
-    tmpReg = (uint32_t)(CAST_POINTER_TO_UINT64(XX_VirtToPhys(CAST_UINT32_TO_POINTER(p_Fm->fifoBaseAddr))) - p_Fm->fmMuramPhysBaseAddr);
+    tmpReg = (uint32_t)((uint64_t)(XX_VirtToPhys(CAST_UINT32_TO_POINTER(p_Fm->fifoBaseAddr))) - p_Fm->fmMuramPhysBaseAddr);
     tmpReg = tmpReg / BMI_FIFO_ALIGN;
 
     tmpReg |= ((p_Fm->totalFifoSize/BMI_FIFO_UNITS - 1) << BMI_CFG1_FIFO_SIZE_SHIFT);
@@ -1299,17 +1392,11 @@ t_Error FM_Init(t_Handle h_Fm)
     tmpReg = 0;
     WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_ievr, (BMI_ERR_INTR_EN_LIST_RAM_ECC|BMI_ERR_INTR_EN_PIPELINE_ECC|BMI_ERR_INTR_EN_STATISTICS_RAM_ECC));
     if(p_Fm->exceptions & FM_EX_BMI_LIST_RAM_ECC)
-    {
         tmpReg |= BMI_ERR_INTR_EN_LIST_RAM_ECC;
-    }
     if(p_Fm->exceptions & FM_EX_BMI_PIPELINE_ECC)
-    {
         tmpReg |= BMI_ERR_INTR_EN_PIPELINE_ECC;
-    }
     if(p_Fm->exceptions & FM_EX_BMI_STATISTICS_RAM_ECC)
-    {
         tmpReg |= BMI_ERR_INTR_EN_STATISTICS_RAM_ECC;
-    }
     WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_ier, tmpReg);
 
     /**********************/
@@ -1318,14 +1405,10 @@ t_Error FM_Init(t_Handle h_Fm)
      /* Clear error interrupt events */
     WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_eie, (QMI_ERR_INTR_EN_DOUBLE_ECC | QMI_ERR_INTR_EN_DEQ_FROM_DEF));
     tmpReg = 0;
-    if(p_Fm->exceptions & FM_EX_QMI_DEQ_FROM_DEFQ)
-    {
+    if(p_Fm->exceptions & FM_EX_QMI_DEQ_FROM_UNKNOWN_PORTID)
         tmpReg |= QMI_ERR_INTR_EN_DEQ_FROM_DEF;
-    }
     if(p_Fm->exceptions & FM_EX_QMI_DOUBLE_ECC)
-    {
         tmpReg |= QMI_ERR_INTR_EN_DOUBLE_ECC;
-    }
     /* enable events */
     WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_eien, tmpReg);
 
@@ -1333,9 +1416,7 @@ t_Error FM_Init(t_Handle h_Fm)
     /* Clear interrupt events */
     WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_ie, QMI_INTR_EN_SINGLE_ECC);
     if(p_Fm->exceptions & FM_EX_QMI_SINGLE_ECC)
-    {
         tmpReg |= QMI_INTR_EN_SINGLE_ECC;
-    }
     /* enable events */
     WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_ien, tmpReg);
 
@@ -1400,16 +1481,39 @@ t_Error FM_Free(t_Handle h_Fm)
     if (!p_Fm)
         return ERROR_CODE(E_INVALID_HANDLE);
 
+    /* disable BMI and QMI */
+    WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_init, 0);
+    WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_gc, 0);
+
+    /* release BMI resources */
+    WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_cfg2, 0);
+    WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_cfg1, 0);
+
+    /* disable ECC */
+    WRITE_UINT32(p_Fm->p_FmFpmRegs->fmrcr, 0);
+
 #ifdef FM_MASTER_PARTITION
     XX_UnregisterMessageHandler(p_Fm->fmModuleName);
 #endif /* FM_MASTER_PARTITION */
 
+    if (p_Fm->irq != NO_IRQ)
+    {
+        XX_FreeIntr(p_Fm->irq);
+        XX_DisableIntr(p_Fm->irq);
+    }
+
+    if (p_Fm->errIrq != NO_IRQ)
+    {
+        XX_FreeIntr(p_Fm->errIrq);
+        XX_DisableIntr(p_Fm->errIrq);
+    }
+
     if(p_Fm->p_FmDriverParam)
     {
         XX_Free(p_Fm->p_FmDriverParam);
         p_Fm->p_FmDriverParam = NULL;
     }
-    FmFreeInitResources(p_Fm);
+    FreeInitResources(p_Fm);
 
     XX_Free(p_Fm);
 
@@ -1494,19 +1598,6 @@ t_Error FM_ConfigThresholds(t_Handle h_Fm, t_FmThresholds *p_FmThresholds)
     return E_OK;
 }
 
-t_Error FM_ConfigTimeStamp(t_Handle h_Fm, uint32_t timeStampPeriod)
-{
-    t_Fm *p_Fm = (t_Fm*)h_Fm;
-
-    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
-
-    p_Fm->p_FmDriverParam->enTimeStamp = TRUE;
-    p_Fm->timeStampPeriod = timeStampPeriod;
-
-    return E_OK;
-}
-
 t_Error FM_ConfigDmaBusProtect(t_Handle h_Fm, t_FmDmaBusProtect *p_FmDmaBusProtect)
 {
     t_Fm *p_Fm = (t_Fm*)h_Fm;
@@ -1760,6 +1851,15 @@ t_Error FM_ConfigHaltOnExternalActivation(t_Handle h_Fm, bool enable)
     SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
 
+#ifdef FM_HALT_SIG_ERRATA_GEN_CCB310
+    {
+        t_FmRevisionInfo revInfo;
+        FmGetRevision(h_Fm, &revInfo);
+        if ((revInfo.majorRev == 1) && (revInfo.minorRev == 0))
+            RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("HaltOnExternalActivation!"));
+    }
+#endif /* FM_HALT_SIG_ERRATA_GEN_CCB310 */
+
     p_Fm->p_FmDriverParam->haltOnExternalActivation = enable;
 
     return E_OK;
@@ -1772,6 +1872,15 @@ t_Error FM_ConfigHaltOnUnrecoverableEccError(t_Handle h_Fm, bool enable)
     SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
 
+#ifdef FM_HALT_SIG_ERRATA_GEN_CCB310
+    {
+        t_FmRevisionInfo revInfo;
+        FmGetRevision(h_Fm, &revInfo);
+        if ((revInfo.majorRev == 1) && (revInfo.minorRev == 0))
+            RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("HaltOnUnrecoverableEccError!"));
+    }
+#endif /* FM_HALT_SIG_ERRATA_GEN_CCB310 */
+
     p_Fm->p_FmDriverParam->haltOnUnrecoverableEccError = enable;
 
     return E_OK;
@@ -1784,6 +1893,29 @@ t_Error FM_ConfigException(t_Handle h_Fm, e_FmExceptions exception, bool enable)
 
     SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
 
+#ifdef FM_IRAM_ECC_ERR_IRQ_ERRATA
+    {
+        t_FmRevisionInfo revInfo;
+        if((exception == e_FM_EX_IRAM_ECC) && (enable))
+        {
+            FmGetRevision(p_Fm, &revInfo);
+            if ((revInfo.majorRev == 1) && (revInfo.minorRev == 0))
+                RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("e_FM_EX_IRAM_ECC!"));
+        }
+    }
+#endif   /* FM_IRAM_ECC_ERR_IRQ_ERRATA */
+#ifdef FM_RAM_LIST_ERR_IRQ_ERRATA_FMAN11
+    {
+        t_FmRevisionInfo revInfo;
+        if((exception == e_FM_EX_IRAM_ECC) && (enable))
+        {
+            FmGetRevision(p_Fm, &revInfo);
+            if ((revInfo.majorRev == 1) && (revInfo.minorRev == 0))
+                RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("e_FM_EX_BMI_LIST_RAM_ECC!"));
+        }
+    }
+#endif   /* FM_RAM_LIST_ERR_IRQ_ERRATA_FMAN11 */
+
     GET_EXCEPTION_FLAG(bitMask, exception);
     if(bitMask)
     {
@@ -1841,7 +1973,7 @@ void FM_EventIsr(t_Handle h_Fm)
     if(pending & INTR_EN_KG)
         p_Fm->intrMng[e_FM_EV_KG].f_Isr(p_Fm->intrMng[e_FM_EV_KG].h_SrcHandle);
     if(pending & FPM_EVENT_FM_CTL)
-        FmCtlEvent(p_Fm, pending  & FPM_EVENT_FM_CTL);
+        CtlEvent(p_Fm, pending  & FPM_EVENT_FM_CTL);
     if(pending & INTR_EN_TMR)
             p_Fm->intrMng[e_FM_EV_TMR].f_Isr(p_Fm->intrMng[e_FM_EV_TMR].h_SrcHandle);
 
@@ -2005,8 +2137,8 @@ t_Error FM_SetPortsBandwidth(t_Handle h_Fm, t_PortsParam *p_PortsBandwidth)
     SANITY_CHECK_RETURN_ERROR(!p_Fm->p_FmDriverParam, E_INVALID_STATE);
 
     memset(portPrecent, 0, FM_MAX_NUM_OF_PORTS);
-    for(i=0;i<NUM_OF_PORT_TYPES;i++)
-        for(j=0;j<MAX_NUM_OF_PORTS_PER_TYPE;j++)
+    for(i=0;i<FM_NUM_OF_PORT_TYPES;i++)
+        for(j=0;j<FM_MAX_NUM_OF_PORTS_PER_TYPE;j++)
         {
             if((*p_PortsBandwidth)[i][j])
             {
@@ -2067,17 +2199,22 @@ t_Error FM_EnableRamsEcc(t_Handle h_Fm)
     uint32_t    tmpReg;
 
     SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(!p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
 
-    tmpReg = GET_UINT32(p_Fm->p_FmFpmRegs->fmrcr);
-    if(tmpReg & FPM_RAM_CTL_RAMS_ECC_EN_SRC_SEL)
-        RETURN_ERROR(MINOR, E_INVALID_STATE,("Rams ECC is configured to be controlled through JTAG"));
+    if(!p_Fm->internalCall)
+        p_Fm->explicitEnable = TRUE;
 
     if(p_Fm->ramsEccEnable)
         return E_OK;
     else
     {
-        WRITE_UINT32(p_Fm->p_FmFpmRegs->fmrcr, tmpReg | (FPM_RAM_CTL_RAMS_ECC_EN | FPM_RAM_CTL_IRAM_ECC_EN));
+        tmpReg = GET_UINT32(p_Fm->p_FmFpmRegs->fmrcr);
+        if(tmpReg & FPM_RAM_CTL_RAMS_ECC_EN_SRC_SEL)
+        {
+            DBG(WARNING, ("Rams ECC is configured to be controlled through JTAG"));
+            WRITE_UINT32(p_Fm->p_FmFpmRegs->fmrcr, tmpReg | FPM_RAM_CTL_IRAM_ECC_EN);
+        }
+        else
+            WRITE_UINT32(p_Fm->p_FmFpmRegs->fmrcr, tmpReg | (FPM_RAM_CTL_RAMS_ECC_EN | FPM_RAM_CTL_IRAM_ECC_EN));
         p_Fm->ramsEccEnable = TRUE;
     }
 
@@ -2088,19 +2225,34 @@ t_Error FM_DisableRamsEcc(t_Handle h_Fm)
 {
     t_Fm        *p_Fm = (t_Fm*)h_Fm;
     uint32_t    tmpReg;
+    bool        explicitDisable = FALSE;
 
     SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
 
-    tmpReg = GET_UINT32(p_Fm->p_FmFpmRegs->fmrcr);
-    if(tmpReg & FPM_RAM_CTL_RAMS_ECC_EN_SRC_SEL)
-        RETURN_ERROR(MINOR, E_INVALID_STATE,("Rams ECC is configured to be controlled through JTAG"));
+    if(!p_Fm->internalCall)
+        explicitDisable = TRUE;
 
-    if(!p_Fm->ramsEccEnable)
+    /* if rams are already disabled, or if rams were explicitly enabled and are
+       currently called indirectly (not explicitly), ignore this call. */
+    if(!p_Fm->ramsEccEnable || (p_Fm->explicitEnable && !explicitDisable))
         return E_OK;
     else
     {
-        WRITE_UINT32(p_Fm->p_FmFpmRegs->fmrcr, tmpReg & ~(FPM_RAM_CTL_RAMS_ECC_EN | FPM_RAM_CTL_IRAM_ECC_EN));
+        if(p_Fm->explicitEnable)
+            /* This is the case were both explicit are TRUE.
+               Turn off this flag for cases were following ramsEnable
+               routines are called */
+            p_Fm->explicitEnable = FALSE;
+
+        tmpReg = GET_UINT32(p_Fm->p_FmFpmRegs->fmrcr);
+        if(tmpReg & FPM_RAM_CTL_RAMS_ECC_EN_SRC_SEL)
+        {
+            DBG(WARNING, ("Rams ECC is configured to be controlled through JTAG"));
+            WRITE_UINT32(p_Fm->p_FmFpmRegs->fmrcr, tmpReg & ~FPM_RAM_CTL_IRAM_ECC_EN);
+        }
+        else
+            WRITE_UINT32(p_Fm->p_FmFpmRegs->fmrcr, tmpReg & ~(FPM_RAM_CTL_RAMS_ECC_EN | FPM_RAM_CTL_IRAM_ECC_EN));
         p_Fm->ramsEccEnable = FALSE;
     }
 
@@ -2185,7 +2337,7 @@ t_Error FM_SetException(t_Handle h_Fm, e_FmExceptions exception, bool enable)
                     tmpReg &= ~QMI_ERR_INTR_EN_DOUBLE_ECC;
                 WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_eien, tmpReg);
                 break;
-             case(e_FM_EX_QMI_DEQ_FROM_DEFQ):
+             case(e_FM_EX_QMI_DEQ_FROM_UNKNOWN_PORTID):
                 tmpReg = GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_eien);
                 if(enable)
                     tmpReg |= QMI_ERR_INTR_EN_DEQ_FROM_DEF;
@@ -2196,7 +2348,15 @@ t_Error FM_SetException(t_Handle h_Fm, e_FmExceptions exception, bool enable)
              case(e_FM_EX_BMI_LIST_RAM_ECC):
                 tmpReg = GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_ier);
                 if(enable)
+                {
+#ifdef FM_RAM_LIST_ERR_IRQ_ERRATA_FMAN11
+                    t_FmRevisionInfo revInfo;
+                    FmGetRevision(p_Fm, &revInfo);
+                    if ((revInfo.majorRev == 1) && (revInfo.minorRev == 0))
+                        RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("e_FM_EX_BMI_LIST_RAM_ECC!"));
+#endif   /* FM_RAM_LIST_ERR_IRQ_ERRATA_FMAN11 */
                     tmpReg |= BMI_ERR_INTR_EN_LIST_RAM_ECC;
+                }
                 else
                     tmpReg &= ~BMI_ERR_INTR_EN_LIST_RAM_ECC;
                 WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_ier, tmpReg);
@@ -2218,40 +2378,46 @@ t_Error FM_SetException(t_Handle h_Fm, e_FmExceptions exception, bool enable)
                 WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_ier, tmpReg);
                 break;
             case(e_FM_EX_IRAM_ECC):
-                tmpReg = GET_UINT32(p_Fm->p_FmFpmRegs->fmeie);
+                tmpReg = GET_UINT32(p_Fm->p_FmFpmRegs->fmrie);
                 if(enable)
                 {
+#ifdef FM_IRAM_ECC_ERR_IRQ_ERRATA
+                    t_FmRevisionInfo revInfo;
+                    FmGetRevision(p_Fm, &revInfo);
+                    if ((revInfo.majorRev == 1) && (revInfo.minorRev == 0))
+                        RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("e_FM_EX_IRAM_ECC!"));
+#endif   /* FM_IRAM_ECC_ERR_IRQ_ERRATA */
                     /* enable ECC if not enabled */
-                    if(!p_Fm->ramsEccEnable)
-                    {
-                        WRITE_UINT32(p_Fm->p_FmFpmRegs->fmrcr, GET_UINT32(p_Fm->p_FmFpmRegs->fmrcr) |
-                                                                (FPM_RAM_CTL_IRAM_ECC_EN | FPM_RAM_CTL_RAMS_ECC_EN));
-                        p_Fm->ramsEccEnable = TRUE;
-                    }
+                    FmEnableRamsEcc(p_Fm);
                     /* enable ECC interrupts */
                     tmpReg |= FPM_IRAM_ECC_ERR_EX_EN;
                 }
                 else
-                    /* ECC mechanism will remain enabled, but interrupts disabled */
+                {
+                    /* ECC mechanism may be disabled, depending on driver status  */
+                    FmDisableRamsEcc(p_Fm);
                     tmpReg &= ~FPM_IRAM_ECC_ERR_EX_EN;
-                WRITE_UINT32(p_Fm->p_FmFpmRegs->fmeie, tmpReg);
+                }
+                WRITE_UINT32(p_Fm->p_FmFpmRegs->fmrie, tmpReg);
                 break;
 
              case(e_FM_EX_MURAM_ECC):
-                tmpReg = GET_UINT32(p_Fm->p_FmFpmRegs->fmeie);
+                tmpReg = GET_UINT32(p_Fm->p_FmFpmRegs->fmrie);
                 if(enable)
                 {
                     /* enable ECC if not enabled */
-                    if(!FmRamsEccIsExternalCtl(p_Fm))
-                        FM_EnableRamsEcc(p_Fm);
+                    FmEnableRamsEcc(p_Fm);
                     /* enable ECC interrupts */
                     tmpReg |= FPM_MURAM_ECC_ERR_EX_EN;
                 }
                 else
-                    /* ECC mechanism will remain enabled, but interrupts disabled */
+                {
+                    /* ECC mechanism may be disabled, depending on driver status  */
+                    FmDisableRamsEcc(p_Fm);
                     tmpReg &= ~FPM_MURAM_ECC_ERR_EX_EN;
+                }
 
-                WRITE_UINT32(p_Fm->p_FmFpmRegs->fmeie, tmpReg);
+                WRITE_UINT32(p_Fm->p_FmFpmRegs->fmrie, tmpReg);
                 break;
             default:
                 RETURN_ERROR(MINOR, E_INVALID_SELECTION, NO_MSG);
@@ -2269,7 +2435,6 @@ void FM_GetRevision(t_Handle h_Fm, t_FmRevisionInfo *p_FmRevisionInfo)
     uint32_t    tmpReg;
 
     SANITY_CHECK_RETURN(p_Fm, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN(!p_Fm->p_FmDriverParam, E_INVALID_STATE);
 
     /* read revision register 1 */
     tmpReg = GET_UINT32(p_Fm->p_FmFpmRegs->fm_ip_rev_1);
@@ -2277,23 +2442,6 @@ void FM_GetRevision(t_Handle h_Fm, t_FmRevisionInfo *p_FmRevisionInfo)
     p_FmRevisionInfo->minorRev = (uint8_t)((tmpReg & FPM_REV1_MINOR_MASK) >> FPM_REV1_MINOR_SHIFT);
 }
 
-uint32_t FM_GetTimeStamp(t_Handle h_Fm)
-{
-    t_Fm *p_Fm = (t_Fm*)h_Fm;
-
-    SANITY_CHECK_RETURN_VALUE(p_Fm, E_INVALID_HANDLE, 0);
-    SANITY_CHECK_RETURN_VALUE(!p_Fm->p_FmDriverParam, E_INVALID_STATE, 0);
-
-    /* check that timeStamp is enabled */
-    if (!(GET_UINT32(p_Fm->p_FmFpmRegs->fpmtsc1) & FPM_TS_CTL_EN))
-    {
-        REPORT_ERROR(MINOR, E_INVALID_STATE, ("Time Stamp was not enabled"));
-        return 0;
-    }
-
-    return GET_UINT32(p_Fm->p_FmFpmRegs->fpmtsp);;
-}
-
 uint32_t  FM_GetCounter(t_Handle h_Fm, e_FmCounters counter)
 {
     t_Fm *p_Fm = (t_Fm*)h_Fm;
@@ -2301,11 +2449,10 @@ uint32_t  FM_GetCounter(t_Handle h_Fm, e_FmCounters counter)
     SANITY_CHECK_RETURN_VALUE(p_Fm, E_INVALID_HANDLE, 0);
     SANITY_CHECK_RETURN_VALUE(!p_Fm->p_FmDriverParam, E_INVALID_STATE, 0);
 
-        switch(counter)
+    switch(counter)
     {
         case(e_FM_COUNTERS_ENQ_TOTAL_FRAME):
             return GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_etfc);
-        break;
         case(e_FM_COUNTERS_DEQ_TOTAL_FRAME):
             return GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_dtfc);
         case(e_FM_COUNTERS_DEQ_0):
@@ -2339,7 +2486,7 @@ uint32_t  FM_GetCounter(t_Handle h_Fm, e_FmCounters counter)
     return 0;
 }
 
-t_Error  FM_SetCounter(t_Handle h_Fm, e_FmCounters counter, uint32_t val)
+t_Error  FM_ModifyCounter(t_Handle h_Fm, e_FmCounters counter, uint32_t val)
 {
     t_Fm *p_Fm = (t_Fm*)h_Fm;
 
@@ -2473,8 +2620,8 @@ t_Error FM_ForceIntr (t_Handle h_Fm, e_FmExceptions exception)
 
     switch(exception)
     {
-        case e_FM_EX_QMI_DEQ_FROM_DEFQ:
-            if (!(p_Fm->exceptions & FM_EX_QMI_DEQ_FROM_DEFQ))
+        case e_FM_EX_QMI_DEQ_FROM_UNKNOWN_PORTID:
+            if (!(p_Fm->exceptions & FM_EX_QMI_DEQ_FROM_UNKNOWN_PORTID))
                 RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception is masked"));
             WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_eif, QMI_ERR_INTR_EN_DEQ_FROM_DEF);
             break;
@@ -2545,18 +2692,18 @@ t_Error FM_DumpRegs(t_Handle h_Fm)
     DUMP_VAR(p_Fm->p_FmFpmRegs,fpmdis1);
     DUMP_VAR(p_Fm->p_FmFpmRegs,fpmdis2);
     DUMP_VAR(p_Fm->p_FmFpmRegs,fmepi);
-    DUMP_VAR(p_Fm->p_FmFpmRegs,fmeie);
+    DUMP_VAR(p_Fm->p_FmFpmRegs,fmrie);
 
-    DUMP_TITLE(&p_Fm->p_FmFpmRegs->fpmrev, ("fpmrev"));
-    DUMP_SUBSTRUCT_ARRAY(i, 8)
+    DUMP_TITLE(&p_Fm->p_FmFpmRegs->fmfpfcev, ("fmfpfcev"));
+    DUMP_SUBSTRUCT_ARRAY(i, 4)
     {
-        DUMP_MEMORY(&p_Fm->p_FmFpmRegs->fpmrev[i], sizeof(uint32_t));
+        DUMP_MEMORY(&p_Fm->p_FmFpmRegs->fmfpfcev[i], sizeof(uint32_t));
     }
 
-    DUMP_TITLE(&p_Fm->p_FmFpmRegs->fpmmsk, ("fpmmsk"));
-    DUMP_SUBSTRUCT_ARRAY(i, 8)
+    DUMP_TITLE(&p_Fm->p_FmFpmRegs->fmfpfcee, ("fmfpfcee"));
+    DUMP_SUBSTRUCT_ARRAY(i, 4)
     {
-        DUMP_MEMORY(&p_Fm->p_FmFpmRegs->fpmmsk[i], sizeof(uint32_t));
+        DUMP_MEMORY(&p_Fm->p_FmFpmRegs->fmfpfcee[i], sizeof(uint32_t));
     }
 
     DUMP_SUBTITLE(("\n"));
@@ -2585,7 +2732,7 @@ t_Error FM_DumpRegs(t_Handle h_Fm)
     DUMP_VAR(p_Fm->p_FmFpmRegs,fpmem);
 
     DUMP_TITLE(&p_Fm->p_FmFpmRegs->fpmcev, ("fpmcev"));
-    DUMP_SUBSTRUCT_ARRAY(i, 8)
+    DUMP_SUBSTRUCT_ARRAY(i, 4)
     {
         DUMP_MEMORY(&p_Fm->p_FmFpmRegs->fpmcev[i], sizeof(uint32_t));
     }
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/fm.h b/drivers/net/dpa/NetCommSw/Peripherals/FM/fm.h
index 8817387..c701d8b 100644
--- a/drivers/net/dpa/NetCommSw/Peripherals/FM/fm.h
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/fm.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -43,7 +43,8 @@
 #include "fm_ext.h"
 
 
-#define FM_MAX_NUM_OF_PORTS         64
+#define __ERR_MODULE__  MODULE_FM
+
 
 /**************************************************************************//**
  @Description       Exceptions
@@ -56,13 +57,13 @@
 #define FM_EX_FPM_SINGLE_ECC                0x04000000      /**< Single ECC on FPM */
 #define FM_EX_FPM_DOUBLE_ECC                0x02000000
 #define FM_EX_QMI_SINGLE_ECC                0x01000000      /**< Single ECC on FPM */
-#define FM_EX_QMI_DEQ_FROM_DEFQ             0x00800000      /**< Dequeu from default queue id */
+#define FM_EX_QMI_DEQ_FROM_UNKNOWN_PORTID   0x00800000      /**< Dequeu from default queue id */
 #define FM_EX_QMI_DOUBLE_ECC                0x00400000
 #define FM_EX_BMI_LIST_RAM_ECC              0x00200000
 #define FM_EX_BMI_PIPELINE_ECC              0x00100000
 #define FM_EX_BMI_STATISTICS_RAM_ECC        0x00080000
 #define FM_EX_IRAM_ECC                      0x00040000
-#define FM_EX_NURAM_ECC                      0x00020000
+#define FM_EX_NURAM_ECC                     0x00020000
 
 #define GET_EXCEPTION_FLAG(bitMask, exception)       switch(exception){ \
     case e_FM_EX_DMA_BUS_ERROR:                                         \
@@ -83,8 +84,8 @@
         bitMask = FM_EX_QMI_SINGLE_ECC; break;                          \
     case e_FM_EX_QMI_DOUBLE_ECC:                                        \
         bitMask = FM_EX_QMI_DOUBLE_ECC; break;                          \
-    case e_FM_EX_QMI_DEQ_FROM_DEFQ:                                     \
-        bitMask = FM_EX_QMI_DEQ_FROM_DEFQ; break;                       \
+    case e_FM_EX_QMI_DEQ_FROM_UNKNOWN_PORTID:                           \
+        bitMask = FM_EX_QMI_DEQ_FROM_UNKNOWN_PORTID; break;             \
     case e_FM_EX_BMI_LIST_RAM_ECC:                                      \
         bitMask = FM_EX_BMI_LIST_RAM_ECC; break;                        \
     case e_FM_EX_BMI_PIPELINE_ECC:                                      \
@@ -108,7 +109,7 @@
                                             FM_EX_FPM_SINGLE_ECC            |\
                                             FM_EX_FPM_DOUBLE_ECC            |\
                                             FM_EX_QMI_SINGLE_ECC            |\
-                                            FM_EX_QMI_DEQ_FROM_DEFQ         |\
+                                            FM_EX_QMI_DEQ_FROM_UNKNOWN_PORTID|\
                                             FM_EX_QMI_DOUBLE_ECC            |\
                                             FM_EX_BMI_LIST_RAM_ECC          |\
                                             FM_EX_BMI_PIPELINE_ECC          |\
@@ -130,7 +131,7 @@
 #define DEFAULT_fmCtl2DispTh                16
 #define DEFAULT_cacheOverride               e_FM_DMA_NO_CACHE_OR
 #define DEFAULT_aidOverride                 FALSE
-#define DEFAULT_aidMode                     e_FM_DMA_AID_OUT_PORT_ID
+#define DEFAULT_aidMode                     e_FM_DMA_AID_OUT_TNUM
 #define DEFAULT_privilegeBusProtect         FALSE
 #define DEFAULT_dmaStopOnBusError           FALSE
 #define DEFAULT_busProtectionType           e_FM_DMA_DATA_BUS_PROT
@@ -148,8 +149,8 @@
 #define DEFAULT_catastrophicErr             e_FM_CATASTROPHIC_ERR_STALL_PORT
 #define DEFAULT_dmaErr                      e_FM_DMA_ERR_CATASTROPHIC
 #define DEFAULT_resetOnInit                 FALSE
-#define DEFAULT_haltOnExternalActivation    FALSE
-#define DEFAULT_haltOnUnrecoverableEccError FALSE
+#define DEFAULT_haltOnExternalActivation    FALSE   /* do not change! if changed, must be disabled for rev1 ! */
+#define DEFAULT_haltOnUnrecoverableEccError FALSE   /* do not change! if changed, must be disabled for rev1 ! */
 #define DEFAULT_externalEccRamsEnable       FALSE
 #define DEFAULT_VerifyUcode                 FALSE
 
@@ -174,9 +175,9 @@
  @Description       Memory Mapped Registers
 *//***************************************************************************/
 
-#ifdef __MWERKS__
+#if defined(__MWERKS__) && !defined(__GNUC__)
 #pragma pack(push,1)
-#endif /*__MWERKS__ */
+#endif /* defined(__MWERKS__) && ... */
 #define MEM_MAP_START
 
 typedef _Packed struct
@@ -188,9 +189,11 @@ typedef _Packed struct
     volatile uint32_t   fpmdis1;        /**< FPM Dispatch Thresholds1 */
     volatile uint32_t   fpmdis2;        /**< FPM Dispatch Thresholds2  */
     volatile uint32_t   fmepi;          /**< FM Error Pending Interrupts */
-    volatile uint32_t   fmeie;          /**< FM Error Interrupt Enable */
-    volatile uint32_t   fpmrev[8];      /**< FPM FmCtl Event 1-8 */
-    volatile uint32_t   fpmmsk[8];      /**< FPM Mask 1-8 */
+    volatile uint32_t   fmrie;          /**< FM Error Interrupt Enable */
+    volatile uint32_t   fmfpfcev[4];    /**< FPM FMan-Controller Event 1-4 */
+    volatile uint8_t    res1[16];       /**< reserved */
+    volatile uint32_t   fmfpfcee[4];    /**< PM FMan-Controller Event 1-4 */
+    volatile uint8_t    res2[16];       /**< reserved */
     volatile uint32_t   fpmtsc1;        /**< FPM TimeStamp Control1 */
     volatile uint32_t   fpmtsc2;        /**< FPM TimeStamp Control2 */
     volatile uint32_t   fpmtsp;         /**< FPM Time Stamp */
@@ -206,9 +209,10 @@ typedef _Packed struct
     volatile uint32_t   fmrstc;         /**< FM Reset Command */
     volatile uint32_t   fmcld;          /**< FM Classifier Debug */
     volatile uint32_t   fmnpi;          /**< FM Normal Pending Interrupts  */
-    volatile uint32_t   reserved;
+    volatile uint8_t    res3[4];        /**< reserved */
     volatile uint32_t   fpmem;          /**< FPM Event & Mask */
-    volatile uint32_t   fpmcev[8];      /**< FPM CPU Event 1-8 */
+    volatile uint32_t   fpmcev[4];      /**< FPM CPU Event 1-4 */
+    volatile uint8_t    res4[16];       /**< reserved */
     volatile uint32_t   fmfp_ps[0x40];  /**< FPM Port Status */
     volatile uint8_t    reserved1[0x260];
     volatile uint32_t   fpmts[128];     /**< 0x400: FPM Task Status */
@@ -261,7 +265,7 @@ typedef _Packed struct
     volatile uint32_t   fmqm_dtc;       /**<  0x0080 Debug Trap Counter */
     volatile uint32_t   fmqm_efddd;     /**<  0x0084 Enqueue Frame Descriptor Dynamic Debug */
     volatile uint32_t   Reserved3[2];
-    struct {
+    _Packed struct {
         volatile uint32_t   fmqm_dtcfg;    /**<  0x0090 Debug Trap Configuration 1 Register */
         volatile uint32_t   fmqm_dtval1;    /**<  Debug Trap Value Register */
         volatile uint32_t   fmqm_dtm1;      /**<  Debug Trap Mask Register */
@@ -269,7 +273,7 @@ typedef _Packed struct
         volatile uint32_t   fmqm_dtc2;
         volatile uint32_t   fmqm_dtval2;    /**<  Debug Trap Value Register */
         volatile uint32_t   fmqm_dtm3;      /**<  Debug Trap Mask Register */
-    }t_FmQmiDbgTraps[NUM_OF_DBG_TRAPS];
+    } _PackedType t_FmQmiDbgTraps[NUM_OF_DBG_TRAPS];
 } _PackedType t_FmQmiRegs;
 
 typedef _Packed struct
@@ -312,9 +316,9 @@ typedef _Packed struct
 } _PackedType t_FMIramRegs;
 
 #define MEM_MAP_END
-#ifdef __MWERKS__
+#if defined(__MWERKS__) && !defined(__GNUC__)
 #pragma pack(pop)
-#endif /* __MWERKS__ */
+#endif /* defined(__MWERKS__) && ... */
 
 
 /**************************************************************************//**
@@ -353,8 +357,7 @@ typedef _Packed struct
 #define DMA_STATUS_FM_DPDAT_ECC             0x00100000
 #define DMA_STATUS_FM_SPDAT_ECC             0x00080000
 
-
-#define FM_LIODN_MASK                       0x00000FFF
+#define FM_LIODN_BASE_MASK                  0x00000FFF
 
 /* shifts */
 #define DMA_MODE_CACHE_OR_SHIFT             30
@@ -549,9 +552,8 @@ typedef struct
 {
  /*   uint8_t                     numOfPartitions; */
     bool                        resetOnInit;
-    uint8_t                     liodnPerPartition[FM_MAX_NUM_OF_PARTITIONS];
+    uint16_t                    liodnPerPartition[FM_MAX_NUM_OF_PARTITIONS];
     bool                        enCounters;
-    bool                        enTimeStamp;
     t_FmThresholds              thresholds;
     t_FmDmaBusProtect           dmaBusProtect;
     e_FmDmaCacheOverride        dmaCacheOverride;
@@ -591,14 +593,20 @@ typedef struct
     e_FmPortType                portsTypes[FM_MAX_NUM_OF_PORTS];
     char                        fmModuleName[MODULE_NAME_SIZE];
     t_FmIntrSrc                 intrMng[e_FM_EV_DUMMY_LAST];    /* FM exceptions user callback */
+    uint16_t                    fmClkFreq;
+
 #ifdef CONFIG_MULTI_PARTITION_SUPPORT
     uint8_t                     partitionId;
 #endif /* CONFIG_MULTI_PARTITION_SUPPORT */
-#ifndef CONFIG_GUEST_PARTITION
+
+#ifdef CONFIG_GUEST_PARTITION
+    char                        fmMasterModuleName[MODULE_NAME_SIZE];
+#else
     uint64_t                    baseAddr;
     t_Handle                    h_FmMuram;
     uint64_t                    fmMuramPhysBaseAddr;
-    uint16_t                    fmClkFreq;
+    bool                        enabledTimeStamp;
+    uint8_t                     count1MicroBit;
     uint32_t                    timeStampPeriod;
     bool                        independentMode;
     bool                        hcPortInitialized;
@@ -618,16 +626,19 @@ typedef struct
     t_FmBmiRegs                 *p_FmBmiRegs;
     t_FmQmiRegs                 *p_FmQmiRegs;
     t_FmDmaRegs                 *p_FmDmaRegs;
-    t_FmExceptionsCallback      *f_Exceptions;
+    t_FmExceptionsCallback      *f_Exception;
     t_FmBusErrorCallback        *f_BusError;
     t_Handle                    h_App;                          /* Application handle */
     t_FmCtlIsr                  *f_FmCtlIsr[NUM_OF_FM_CTL_EVENT_REGS];
     bool                        ramsEccEnable;
+    bool                        explicitEnable;
+    bool                        internalCall;
+    uint8_t                     ramsEccOwners;
     uint32_t                    extraFifoPoolSize;
     uint8_t                     extraTasksPoolSize;
     uint8_t                     extraOpenDmasPoolSize;
     t_FmDriverParam             *p_FmDriverParam;
-#endif /* ! CONFIG_GUEST_PARTITION */
+#endif /* CONFIG_GUEST_PARTITION */
 } t_Fm;
 
 /**************************************************************************//**
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/fm_guest.c b/drivers/net/dpa/NetCommSw/Peripherals/FM/fm_guest.c
index fa608bb..bb80c7d 100644
--- a/drivers/net/dpa/NetCommSw/Peripherals/FM/fm_guest.c
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/fm_guest.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -81,7 +81,7 @@ t_Error FmGetSetPortParams(t_Handle h_Fm,t_FmInterModulePortInitParams *p_PortPa
 {
     SANITY_CHECK_RETURN_ERROR(h_Fm, E_INVALID_HANDLE);
 
-    return XX_SendMessage(((t_Fm*)h_Fm)->fmModuleName, FM_GET_SET_PORT_PARAMS, (uint8_t*)p_PortParams, NULL, NULL);
+    return XX_SendMessage(((t_Fm*)h_Fm)->fmMasterModuleName, FM_GET_SET_PORT_PARAMS, (uint8_t*)p_PortParams, NULL, NULL);
 }
 
 void FmFreePortParams(t_Handle h_Fm,t_FmInterModulePortFreeParams *p_PortParams)
@@ -90,7 +90,7 @@ void FmFreePortParams(t_Handle h_Fm,t_FmInterModulePortFreeParams *p_PortParams)
 
     SANITY_CHECK_RETURN(h_Fm, E_INVALID_HANDLE);
 
-    err = XX_SendMessage(((t_Fm*)h_Fm)->fmModuleName, FM_FREE_PORT, (uint8_t*)p_PortParams, NULL, NULL);
+    err = XX_SendMessage(((t_Fm*)h_Fm)->fmMasterModuleName, FM_FREE_PORT, (uint8_t*)p_PortParams, NULL, NULL);
     if(err)
         REPORT_ERROR(MINOR, err, NO_MSG);
 }
@@ -104,7 +104,7 @@ bool FmIsPortStalled(t_Handle h_Fm, uint8_t hardwarePortId)
     SANITY_CHECK_RETURN_VALUE(h_Fm, E_INVALID_HANDLE, FALSE);
 
     isStalled.hardwarePortId = hardwarePortId;
-    err = XX_SendMessage(((t_Fm*)h_Fm)->fmModuleName, FM_IS_PORT_STALLED, (uint8_t*)&isStalled, NULL, NULL);
+    err = XX_SendMessage(((t_Fm*)h_Fm)->fmMasterModuleName, FM_IS_PORT_STALLED, (uint8_t*)&isStalled, NULL, NULL);
     if(err)
         REPORT_ERROR(MINOR, err, NO_MSG);
 
@@ -115,7 +115,7 @@ t_Error FmResumeStalledPort(t_Handle h_Fm, uint8_t hardwarePortId)
 {
     SANITY_CHECK_RETURN_ERROR(h_Fm, E_INVALID_HANDLE);
 
-    return XX_SendMessage(((t_Fm*)h_Fm)->fmModuleName, FM_RESUME_STALLED_PORT, (uint8_t*)&hardwarePortId, NULL, NULL);
+    return XX_SendMessage(((t_Fm*)h_Fm)->fmMasterModuleName, FM_RESUME_STALLED_PORT, (uint8_t*)&hardwarePortId, NULL, NULL);
 }
 
 t_Error FmResetMac(t_Handle h_Fm, e_FmMacType type, uint8_t macId)
@@ -127,24 +127,31 @@ t_Error FmResetMac(t_Handle h_Fm, e_FmMacType type, uint8_t macId)
     macReset.id = macId;
     macReset.type = (e_FmIpcMacType)type;
 
-    return XX_SendMessage(((t_Fm*)h_Fm)->fmModuleName, FM_RESET_MAC, (uint8_t*)&macReset, NULL, NULL);
+    return XX_SendMessage(((t_Fm*)h_Fm)->fmMasterModuleName, FM_RESET_MAC, (uint8_t*)&macReset, NULL, NULL);
 }
 
-uint32_t    FmGetTimeStampPeriod(t_Handle h_Fm)
+uint16_t FmGetClockFreq(t_Handle h_Fm)
+{
+    SANITY_CHECK_RETURN_ERROR(h_Fm, E_INVALID_HANDLE);
+
+    return ((t_Fm*)h_Fm)->fmClkFreq;
+}
+
+uint32_t FmGetTimeStampPeriod(t_Handle h_Fm)
 {
     uint32_t                timeStampPeriod;
     t_Error                 err;
 
     SANITY_CHECK_RETURN_VALUE(h_Fm, E_INVALID_HANDLE, 0);
 
-    err = XX_SendMessage(((t_Fm*)h_Fm)->fmModuleName, FM_GET_TIMESTAMP_PERIOD, (uint8_t*)&timeStampPeriod, NULL, NULL);
+    err = XX_SendMessage(((t_Fm*)h_Fm)->fmMasterModuleName, FM_GET_TIMESTAMP_PERIOD, (uint8_t*)&timeStampPeriod, NULL, NULL);
     if(err )
         REPORT_ERROR(MINOR, err, NO_MSG);
 
     return timeStampPeriod;
 }
 
-t_Error     FmHandleIpcMsg(t_Handle h_Fm, uint32_t msgId, uint8_t msgBody[MSG_BODY_SIZE])
+t_Error FmHandleIpcMsg(t_Handle h_Fm, uint32_t msgId, uint8_t msgBody[MSG_BODY_SIZE])
 {
     t_Fm    *p_Fm = (t_Fm*)h_Fm;
 
@@ -176,7 +183,7 @@ void FmRegisterIntr(t_Handle h_Fm,
     t_FmIpcRegisterIntr *fmIpcRegisterIntr;
 
     /* register in local FM structure */
-    GET_MODULE_EVENT(module, modId,err, event);
+    GET_FM_MODULE_EVENT(module, modId,err, event);
     ASSERT_COND(event != e_FM_EV_DUMMY_LAST);
     p_Fm->intrMng[event].f_Isr = f_Isr;
     p_Fm->intrMng[event].h_SrcHandle = h_Arg;
@@ -184,7 +191,7 @@ void FmRegisterIntr(t_Handle h_Fm,
     /* register in Master FM structure */
     fmIpcRegisterIntr.event = event;
     fmIpcRegisterIntr.partitionId = p_Fm->partitionId;
-    return XX_SendMessage(((t_Fm*)h_Fm)->fmModuleName, FM_REGISTER_INTR, (uint8_t*)&fmIpcRegisterIntr, NULL, NULL);
+    return XX_SendMessage(((t_Fm*)h_Fm)->fmMasterModuleName, FM_REGISTER_INTR, (uint8_t*)&fmIpcRegisterIntr, NULL, NULL);
 }
 
 #if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
@@ -192,7 +199,7 @@ t_Error FmDumpPortRegs (t_Handle h_Fm,uint8_t hardwarePortId)
 {
     SANITY_CHECK_RETURN_ERROR(h_Fm, E_INVALID_HANDLE);
 
-    return XX_SendMessage(((t_Fm*)h_Fm)->fmModuleName, FM_DUMP_PORT_REGS, (uint8_t*)&hardwarePortId, NULL, NULL);
+    return XX_SendMessage(((t_Fm*)h_Fm)->fmMasterModuleName, FM_DUMP_PORT_REGS, (uint8_t*)&hardwarePortId, NULL, NULL);
 }
 #endif /* (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0)) */
 
@@ -215,9 +222,11 @@ t_Handle FM_Config(t_FmParams *p_FmParam)
 
     /* Initialize FM parameters which will be kept by the driver */
     p_Fm->fmId              = p_FmParam->fmId;
+    p_Fm->partitionId              = p_FmParam->partitionId;
     for(i = 0;i<FM_MAX_NUM_OF_PORTS;i++)
         p_Fm->portsTypes[i] = e_FM_PORT_TYPE_DUMMY;
-    /* register to inter-core messaging mechanism */
+
+    /* build the FM guest partition IPC address */
     memset(p_Fm->fmModuleName, 0, MODULE_NAME_SIZE);
     if(Sprint (p_Fm->fmModuleName, "FM-%d-%d",p_Fm->fmId, p_Fm->partitionId) != (p_Fm->partitionId<10 ? 6:7))
     {
@@ -226,6 +235,15 @@ t_Handle FM_Config(t_FmParams *p_FmParam)
         return NULL;
     }
 
+    /* build the FM master partition IPC address */
+    memset(p_Fm->fmMasterModuleName, 0, MODULE_NAME_SIZE);
+    if(Sprint (p_Fm->fmMasterModuleName, "FM-%d-Master",p_Fm->fmId) != 11)
+    {
+        XX_Free(p_Fm);
+        REPORT_ERROR(MAJOR, E_INVALID_STATE, ("Sprint failed"));
+        return NULL;
+    }
+
     return p_Fm;
 }
 
@@ -241,11 +259,16 @@ t_Handle FM_Config(t_FmParams *p_FmParam)
 t_Error FM_Init(t_Handle h_Fm)
 {
     t_Fm                    *p_Fm = (t_Fm*)h_Fm;
+    t_Error                 err;
     int                     i;
 
     for(i=0;i<e_FM_EV_DUMMY_LAST;i++)
         p_Fm->intrMng[i].f_Isr = UnimplementedIsr;
 
+    err = XX_SendMessage(((t_Fm*)h_Fm)->fmMasterModuleName, FM_GET_CLK_FREQ, (uint8_t*)&(p_Fm->fmClkFreq), NULL, NULL);
+    if(err )
+        REPORT_ERROR(MINOR, err, NO_MSG);
+
     err = XX_RegisterMessageHandler(p_Fm->fmModuleName, FmHandleIpcMsg, p_Fm);
     if(err)
         RETURN_ERROR(MAJOR, err, NO_MSG);
@@ -295,23 +318,10 @@ void FM_GetRevision(t_Handle h_Fm, t_FmRevisionInfo *p_FmRevisionInfo)
     t_Error err;
 
     SANITY_CHECK_RETURN(h_Fm, E_INVALID_HANDLE);
-    err = XX_SendMessage(((t_Fm*)h_Fm)->fmModuleName, FM_GET_REV, (uint8_t*)p_FmRevisionInfo, NULL, NULL);
-    if(err )
-        REPORT_ERROR(MINOR, err, NO_MSG);
-}
-
-uint32_t FM_GetTimeStamp(t_Handle h_Fm)
-{
-    uint32_t    timeStamp;
-    t_Error     err;
 
-    SANITY_CHECK_RETURN_VALUE(h_Fm, E_INVALID_HANDLE, 0);
-
-    err = XX_SendMessage(((t_Fm*)h_Fm)->fmModuleName, FM_GET_TIMESTAMP, (uint8_t*)&timeStamp, NULL, NULL);
+    err = XX_SendMessage(((t_Fm*)h_Fm)->fmMasterModuleName, FM_GET_REV, (uint8_t*)p_FmRevisionInfo, NULL, NULL);
     if(err )
         REPORT_ERROR(MINOR, err, NO_MSG);
-
-    return timeStamp;
 }
 
 uint32_t  FM_GetCounter(t_Handle h_Fm, e_FmCounters counter)
@@ -322,7 +332,7 @@ uint32_t  FM_GetCounter(t_Handle h_Fm, e_FmCounters counter)
     SANITY_CHECK_RETURN_VALUE(h_Fm, E_INVALID_HANDLE, 0);
 
     counterParams.id = (e_FmIpcCounters)counter;
-    err = XX_SendMessage(((t_Fm*)h_Fm)->fmModuleName, FM_GET_COUNTER, (uint8_t*)&counterParams, NULL, NULL);
+    err = XX_SendMessage(((t_Fm*)h_Fm)->fmMasterModuleName, FM_GET_COUNTER, (uint8_t*)&counterParams, NULL, NULL);
     if(err )
         REPORT_ERROR(MINOR, err, NO_MSG);
 
@@ -379,7 +389,7 @@ t_Error FM_DumpRegs(t_Handle h_Fm)
 {
     SANITY_CHECK_RETURN_ERROR(h_Fm, E_INVALID_HANDLE);
 
-    return XX_SendMessage(((t_Fm*)h_Fm)->fmModuleName, FM_DUMP_REGS, NULL, NULL, NULL);
+    return XX_SendMessage(((t_Fm*)h_Fm)->fmMasterModuleName, FM_DUMP_REGS, NULL, NULL, NULL);
 }
 #endif /* (defined(DEBUG_ERRORS) && ... */
 
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/fm_ipc.h b/drivers/net/dpa/NetCommSw/Peripherals/FM/fm_ipc.h
index 059452f..dce6b89 100644
--- a/drivers/net/dpa/NetCommSw/Peripherals/FM/fm_ipc.h
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/fm_ipc.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -212,9 +212,9 @@ typedef enum e_FmIpcPortType {
     e_FM_IPC_PORT_TYPE_DUMMY
 } e_FmIpcPortType;
 
-#ifdef __MWERKS__
+#if defined(__MWERKS__) && !defined(__GNUC__)
 #pragma pack(push,1)
-#endif /*__MWERKS__ */
+#endif /* defined(__MWERKS__) && ... */
 #define MEM_MAP_START
 
 /**************************************************************************//**
@@ -224,12 +224,13 @@ typedef _Packed struct t_FmIpcPhysAddr
 {
     volatile uint16_t high;
     volatile uint32_t low;
-}_PackedType t_FmIpcPhysAddr;
+} _PackedType t_FmIpcPhysAddr;
 
 #define MEM_MAP_END
-#ifdef __MWERKS__
+#if defined(__MWERKS__) && !defined(__GNUC__)
 #pragma pack(pop)
-#endif /* __MWERKS__ */
+#endif /* defined(__MWERKS__) && ... */
+
 
 #define FM_GET_TIMESTAMP            1
 #define FM_GET_TIMESTAMP_PERIOD     2
@@ -244,6 +245,8 @@ typedef _Packed struct t_FmIpcPhysAddr
 #define FM_GET_REV                  11
 #define FM_REGISTER_INTR            12
 #define FM_GUEST_ISR                13
+#define FM_GET_CLK_FREQ             14
+
 /**************************************************************************//**
  @Description   Structure for IPC communication during FM_PORT_Init.
                 Fields commented 'IN' are passed by the port module to be used
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/fm_muram.c b/drivers/net/dpa/NetCommSw/Peripherals/FM/fm_muram.c
index 2b5b3c4..21ec265 100644
--- a/drivers/net/dpa/NetCommSw/Peripherals/FM/fm_muram.c
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/fm_muram.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -38,21 +38,32 @@
 #include "error_ext.h"
 #include "std_ext.h"
 #include "mm_ext.h"
-#include "fm_common.h"
 #include "fm_muram_ext.h"
 
 
+#define __ERR_MODULE__  MODULE_FM_MURAM
+
+
 t_Handle FM_MURAM_ConfigAndInit(uint64_t baseAddress, uint32_t size)
 {
     t_Handle h_Mem;
 
-
     if(!baseAddress)
     {
         REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("baseAddress 0 is not supported"));
         return NULL;
+    }
 
+    if(baseAddress%4)
+    {
+        REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("baseAddress not 4 bytes aligned!"));
+        return NULL;
     }
+
+#ifndef VERIFICATION_SUPPORT
+    IOMemSet32(CAST_UINT64_TO_POINTER(baseAddress), 0, size);
+#endif /* VERIFICATION_SUPPORT */
+
     if (MM_Init(&h_Mem, baseAddress, size) != E_OK)
         return NULL;
     if (!h_Mem)
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/inc/fm_common.h b/drivers/net/dpa/NetCommSw/Peripherals/FM/inc/fm_common.h
index a600ecd..aa93ecd 100644
--- a/drivers/net/dpa/NetCommSw/Peripherals/FM/inc/fm_common.h
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/inc/fm_common.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -43,15 +43,14 @@
 #include "fm_pcd_ext.h"
 #include "fm_port_ext.h"
 
-#define __ERR_MODULE__  MODULE_FM
 
 #define CLS_PLAN_NUM_PER_GRP                        8
 #define DRIVER_PRIVATE_NET_ENV_ID                   PCD_MAX_NUM_OF_PORTS
 
 
-#ifdef __MWERKS__
+#if defined(__MWERKS__) && !defined(__GNUC__)
 #pragma pack(push,1)
-#endif /*__MWERKS__ */
+#endif /* defined(__MWERKS__) && ... */
 #define MEM_MAP_START
 
 /**************************************************************************//**
@@ -81,27 +80,27 @@ typedef _Packed struct t_FmPcdPlcrInterModuleProfileRegs {
  @Description   PCD KG scheme registers
 *//***************************************************************************/
 typedef _Packed struct t_FmPcdKgInterModuleSchemeRegs {
-    uint32_t kgse_mode;    /**< MODE */
-    uint32_t kgse_ekfc;    /**< Extract Known Fields Command */
-    uint32_t kgse_ekdv;    /**< Extract Known Default Value */
-    uint32_t kgse_bmch;    /**< Bit Mask Command High */
-    uint32_t kgse_bmcl;    /**< Bit Mask Command Low */
-    uint32_t kgse_fqb;     /**< Frame Queue Base */
-    uint32_t kgse_hc;      /**< Hash Command */
-    uint32_t kgse_ppc;     /**< Policer Profile Command */
-    uint32_t kgse_gec[FM_PCD_KG_NUM_OF_GENERIC_REGS];
-                           /**< Generic Extract Command */
-    uint32_t kgse_spc;     /**< KeyGen Scheme Entry Statistic Packet Counter */
-    uint32_t kgse_dv0;     /**< KeyGen Scheme Entry Default Value 0 */
-    uint32_t kgse_dv1;     /**< KeyGen Scheme Entry Default Value 1 */
-    uint32_t kgse_ccbs;    /**< KeyGen Scheme Entry Coarse Classification Bit*/
-    uint32_t kgse_mv;      /**< KeyGen Scheme Entry Match vector */
+    volatile uint32_t kgse_mode;    /**< MODE */
+    volatile uint32_t kgse_ekfc;    /**< Extract Known Fields Command */
+    volatile uint32_t kgse_ekdv;    /**< Extract Known Default Value */
+    volatile uint32_t kgse_bmch;    /**< Bit Mask Command High */
+    volatile uint32_t kgse_bmcl;    /**< Bit Mask Command Low */
+    volatile uint32_t kgse_fqb;     /**< Frame Queue Base */
+    volatile uint32_t kgse_hc;      /**< Hash Command */
+    volatile uint32_t kgse_ppc;     /**< Policer Profile Command */
+    volatile uint32_t kgse_gec[FM_PCD_KG_NUM_OF_GENERIC_REGS];
+                                   /**< Generic Extract Command */
+    volatile uint32_t kgse_spc;     /**< KeyGen Scheme Entry Statistic Packet Counter */
+    volatile uint32_t kgse_dv0;     /**< KeyGen Scheme Entry Default Value 0 */
+    volatile uint32_t kgse_dv1;     /**< KeyGen Scheme Entry Default Value 1 */
+    volatile uint32_t kgse_ccbs;    /**< KeyGen Scheme Entry Coarse Classification Bit*/
+    volatile uint32_t kgse_mv;      /**< KeyGen Scheme Entry Match vector */
 } _PackedType t_FmPcdKgInterModuleSchemeRegs;
 
 #define MEM_MAP_END
-#ifdef __MWERKS__
+#if defined(__MWERKS__) && !defined(__GNUC__)
 #pragma pack(pop)
-#endif /* __MWERKS__ */
+#endif /* defined(__MWERKS__) && ... */
 
 typedef struct {
     uint8_t             baseEntry;
@@ -112,8 +111,6 @@ typedef struct {
 /**************************************************************************//**
  @Description   Structure for binding a port to keygen schemes.
 *//***************************************************************************/
-
-
 typedef struct t_FmPcdKgInterModuleBindPortToSchemes {
     uint8_t     hardwarePortId;
     uint8_t     netEnvId;
@@ -212,42 +209,13 @@ typedef uint32_t t_FmBlockIntrEnable;
 /* @} */
 
 
-/**************************************************************************//**
- @Description   Enum for inter-module interrupts registration
-*//***************************************************************************/
-typedef enum e_FmInterModuleEvent {
-    e_FM_EV_PRS,                    /**< Parser event */
-    e_FM_EV_ERR_PRS,                /**< Parser error event */
-    e_FM_EV_KG,                     /**< Keygen event */
-    e_FM_EV_ERR_KG,                 /**< Keygen error event */
-    e_FM_EV_PLCR,                   /**< Policer event */
-    e_FM_EV_ERR_PLCR,               /**< Policer error event */
-    e_FM_EV_ERR_10G_MAC0,           /**< 10G MAC 0 error event */
-    e_FM_EV_ERR_1G_MAC0,            /**< 1G MAC 0 error event */
-    e_FM_EV_ERR_1G_MAC1,            /**< 1G MAC 1 error event */
-    e_FM_EV_ERR_1G_MAC2,            /**< 1G MAC 2 error event */
-    e_FM_EV_ERR_1G_MAC3,            /**< 1G MAC 3 error event */
-    e_FM_EV_TMR,                    /**< Timer event */
-    e_FM_EV_1G_MAC1,                /**< 1G MAC 1 event */
-    e_FM_EV_1G_MAC2,                /**< 1G MAC 2 event */
-    e_FM_EV_1G_MAC3,                /**< 1G MAC 3 event */
-    e_FM_EV_1G_MAC0_TMR,            /**< 1G MAC 0 Timer event */
-    e_FM_EV_1G_MAC1_TMR,            /**< 1G MAC 1 Timer event */
-    e_FM_EV_1G_MAC2_TMR,            /**< 1G MAC 2 Timer event */
-    e_FM_EV_1G_MAC3_TMR,            /**< 1G MAC 3 Timer event */
-    e_FM_EV_DUMMY_LAST
-} e_FmInterModuleEvent;
-
-
-#define MAX_NUM_OF_OP_PORTS                 7
-#define MAX_NUM_OF_RX_1G_PORTS              4
-#define MAX_NUM_OF_RX_10G_PORTS             1
-#define PCD_MAX_NUM_OF_PORTS                (MAX_NUM_OF_OP_PORTS +      \
-                                            MAX_NUM_OF_RX_1G_PORTS +    \
-                                            MAX_NUM_OF_RX_10G_PORTS)
-#define MODULE_NAME_SIZE                    20
-#define DUMMY_PORT_ID                       0
+#define PCD_MAX_NUM_OF_PORTS        (FM_MAX_NUM_OF_OH_PORTS +       \
+                                     FM_MAX_NUM_OF_1G_RX_PORTS +    \
+                                     FM_MAX_NUM_OF_10G_RX_PORTS)
+#define MODULE_NAME_SIZE            30
+#define DUMMY_PORT_ID               0
 
+#define FM_LIODN_OFFSET_MASK        0x3FF
 /**************************************************************************//**
   @Description       NIA Description
 *//***************************************************************************/
@@ -262,10 +230,10 @@ typedef enum e_FmInterModuleEvent {
 #define NIA_ENG_QMI_DEQ             0x00580000
 #define NIA_ENG_MASK                0x007C0000
 
-#define NIA_FM_CTL_AC_CC              0x00000006
-#define NIA_FM_CTL_AC_HC              0x0000000C
-#define NIA_FM_CTL_AC_IND_MODE_TX     0x00000008
-#define NIA_FM_CTL_AC_IND_MODE_RX     0x0000000A
+#define NIA_FM_CTL_AC_CC            0x00000006
+#define NIA_FM_CTL_AC_HC            0x0000000C
+#define NIA_FM_CTL_AC_IND_MODE_TX   0x00000008
+#define NIA_FM_CTL_AC_IND_MODE_RX   0x0000000A
 
 #define NIA_BMI_AC_ENQ_FRAME        0x00000002
 #define NIA_BMI_AC_TX_RELEASE       0x000002C0
@@ -295,8 +263,8 @@ typedef enum e_FmInterModuleEvent {
 
 #define GET_GLOBAL_PORTID(port, type, id)               \
 switch(type){                                           \
-    case(e_FM_PORT_TYPE_OFFLINE_PARSING):               \
-    case(e_FM_PORT_TYPE_HOST_COMMAND):                  \
+    case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):            \
+    case(e_FM_PORT_TYPE_OH_HOST_COMMAND):               \
         port = (uint8_t)(BASE_HO_PORTID + id);          \
         if (id > (LAST_HO_PORTID-BASE_HO_PORTID))       \
             REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("Illegal port id")); \
@@ -600,7 +568,7 @@ t_Error     FmPcdKgSwBindPortToClsPlanGrp(t_Handle h_FmPcd, uint8_t netEnvId, ui
 void        FmPcdKgSwUnbindPortToClsPlanGrp(t_Handle h_FmPcd, uint8_t clsPlanGrpId);
 bool        FmPcdKgIsEmptyClsPlanGrp(t_Handle h_FmPcd);
 uint8_t     FmPcdKgGetEmptyClsPlanGrpId(t_Handle h_FmPcd);
-t_Error     FmPcdKgBuildScheme(t_Handle h_FmPcd,  t_FmPcdKgSchemeParams *p_Scheme, t_FmPcdKgInterModuleSchemeRegs *p_SchemeRegs, t_FmPcdKgKeyOrder *p_OrderedArray);
+t_Error     FmPcdKgBuildScheme(t_Handle h_FmPcd,  t_FmPcdKgSchemeParams *p_Scheme, t_FmPcdKgInterModuleSchemeRegs *p_SchemeRegs);
 t_Handle    FmPcdKgBuildClsPlanGrp(t_Handle h_FmPcd, t_FmPcdKgClsPlanGrpParams *p_Grp, t_FmPcdKgInterModuleClsPlanSet *p_ClsPlanSet);
 uint8_t     FmPcdKgGetNumOfPartitionSchemes(t_Handle h_FmPcd);
 uint8_t     FmPcdKgGetPhysicalSchemeId(t_Handle h_FmPcd, uint8_t schemeId);
@@ -701,6 +669,24 @@ void FmRegisterIntr(t_Handle                h_Fm,
                      t_Handle               h_Arg);
 
 /**************************************************************************//**
+ @Function      FmUnregisterIntr
+
+ @Description   Used to un-register an inter-module event handler that was processed by FM
+
+ @Param[in]     h_Fm            A handle to an FM Module.
+ @Param[in]     mod             The module that causes the event
+ @Param[in]     modId           Module id - if more than 1 instansiation of this
+                                mode exists,0 otherwise.
+ @Param[in]     intrType        Interrupt type (error/normal) selection.
+
+ @Return        None.
+*//***************************************************************************/
+void FmUnregisterIntr(t_Handle                h_Fm,
+                     e_FmEventModules       mod,
+                     uint8_t                modId,
+                     e_FmIntrType           intrType);
+
+/**************************************************************************//**
  @Function      FmRegisterFmCtlIntr
 
  @Description   Used to register to one of the fmCtl events in the FM module
@@ -715,4 +701,228 @@ void FmRegisterIntr(t_Handle                h_Fm,
 *//***************************************************************************/
 void  FmRegisterFmCtlIntr(t_Handle h_Fm, uint8_t eventRegId, void (*f_Isr) (t_Handle h_Fm, uint32_t event));
 
+/**************************************************************************//**
+ @Description   enum for defining MAC types
+*//***************************************************************************/
+typedef enum e_FmMacType {
+    e_FM_MAC_10G,               /**< 10G MAC */
+    e_FM_MAC_1G                 /**< 1G MAC */
+} e_FmMacType;
+
+/**************************************************************************//**
+ @Description   Structure for port-FM communication during FM_PORT_Init.
+                Fields commented 'IN' are passed by the port module to be used
+                by the FM module.
+                Fields commented 'OUT' will be filled by FM before returning to port.
+                Some fields are optional (depending on configuration) and
+                will be analized by the port and FM modules accordingly.
+*//***************************************************************************/
+typedef struct t_FmInterModulePortInitParams {
+    uint8_t             hardwarePortId;     /**< IN. port Id */
+    e_FmPortType        portType;           /**< IN. Port type */
+    bool                useRateLimit;       /**< IN. AN indication whether rate limit
+                                                 is used, to enable timestamp. */
+    uint8_t             count1MicroBit;     /**< OUT. an indication of which TS bit
+                                                 counts closest to 1 Microsecond. */
+    bool                independentMode;    /**< IN. TRUE if FM Port operates in independent mode */
+    uint16_t            portPartition;      /**< IN. Port's requested resource */
+    uint8_t             numOfTasks;         /**< IN. Port's requested resource */
+    uint8_t             numOfExtraTasks;    /**< IN. Port's requested resource */
+    uint8_t             numOfOpenDmas;      /**< IN. Port's requested resource */
+    uint8_t             numOfExtraOpenDmas; /**< IN. Port's requested resource */
+    uint32_t            sizeOfFifo;         /**< IN. Port's requested resource */
+    uint32_t            extraSizeOfFifo;    /**< IN. Port's requested resource */
+    uint8_t             deqPipelineDepth;   /**< IN. Port's requested resource */
+    t_FmPhysAddr        fmMuramPhysBaseAddr;/**< OUT. FM-MURAM physical address*/
+} t_FmInterModulePortInitParams;
+
+/**************************************************************************//**
+ @Description   Structure for port-FM communication during FM_PORT_Free.
+*//***************************************************************************/
+typedef struct t_FmInterModulePortFreeParams {
+    uint8_t             hardwarePortId;     /**< IN. port Id */
+    e_FmPortType        portType;           /**< IN. Port type */
+    uint8_t             deqPipelineDepth;   /**< IN. Port's requested resource */
+} t_FmInterModulePortFreeParams;
+
+/**************************************************************************//**
+ @Function      FmGetPcdPrsBaseAddr
+
+ @Description   Get the base address of the Parser from the FM module
+
+ @Param[in]     h_Fm            A handle to an FM Module.
+
+ @Return        Base address.
+*//***************************************************************************/
+uint64_t FmGetPcdPrsBaseAddr(t_Handle h_Fm);
+
+/**************************************************************************//**
+ @Function      FmGetPcdKgBaseAddr
+
+ @Description   Get the base address of the Keygen from the FM module
+
+ @Param[in]     h_Fm            A handle to an FM Module.
+
+ @Return        Base address.
+*//***************************************************************************/
+uint64_t FmGetPcdKgBaseAddr(t_Handle h_Fm);
+
+/**************************************************************************//**
+ @Function      FmGetPcdPlcrBaseAddr
+
+ @Description   Get the base address of the Policer from the FM module
+
+ @Param[in]     h_Fm            A handle to an FM Module.
+
+ @Return        Base address.
+*//***************************************************************************/
+uint64_t FmGetPcdPlcrBaseAddr(t_Handle h_Fm);
+
+/**************************************************************************//**
+ @Function      FmGetMuramHandle
+
+ @Description   Get the handle of the MURAM from the FM module
+
+ @Param[in]     h_Fm            A handle to an FM Module.
+
+ @Return        MURAM module handle.
+*//***************************************************************************/
+t_Handle FmGetMuramHandle(t_Handle h_Fm);
+
+/**************************************************************************//**
+ @Function      FmGetPhysicalMuramBase
+
+ @Description   Get the physical base address of the MURAM from the FM module
+
+ @Param[in]     h_Fm            A handle to an FM Module.
+ @Param[in]     fmPhysAddr      Physical MURAM base
+
+ @Return        Physical base address.
+*//***************************************************************************/
+t_Error FmGetPhysicalMuramBase(t_Handle h_Fm, t_FmPhysAddr *fmPhysAddr);
+
+/**************************************************************************//**
+ @Function      FmGetTimeStampScale
+
+ @Description   Used internally by other modules in order to get the timeStamp
+                period as requested by the application.
+
+ @Param[in]     h_Fm                    A handle to an FM Module.
+
+ @Return        TimeStamp period in nanoseconds.
+
+ @Cautions      Allowed only following FM_Init().
+*//***************************************************************************/
+uint32_t    FmGetTimeStampScale(t_Handle h_Fm);
+
+/**************************************************************************//**
+ @Function      FmResumeStalledPort
+
+ @Description   Used internally by FM port to release a stalled port.
+
+ @Param[in]     h_Fm                            A handle to an FM Module.
+ @Param[in]     hardwarePortId                    HW port id.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Init().
+*//***************************************************************************/
+t_Error FmResumeStalledPort(t_Handle h_Fm, uint8_t hardwarePortId);
+
+/**************************************************************************//**
+ @Function      FmIsPortStalled
+
+ @Description   Used internally by FM port to read the port's status.
+
+ @Param[in]     h_Fm                            A handle to an FM Module.
+ @Param[in]     hardwarePortId                    HW port id.
+
+ @Return        TRUE if port is stalled, FALSE otherwize
+
+ @Cautions      Allowed only following FM_Init().
+*//***************************************************************************/
+bool FmIsPortStalled(t_Handle h_Fm, uint8_t hardwarePortId);
+
+/**************************************************************************//**
+ @Function      FmResetMac
+
+ @Description   Used by MAC driver to reset the MAC registers
+
+ @Param[in]     h_Fm            A handle to an FM Module.
+ @Param[in]     type            MAC type.
+ @Param[in]     macId           MAC id - according to type.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Init().
+*//***************************************************************************/
+t_Error FmResetMac(t_Handle h_Fm, e_FmMacType type, uint8_t macId);
+
+/**************************************************************************//**
+ @Function      FmGetClockFreq
+
+ @Description   Used by MAC driver to get the FM clock frequency
+
+ @Param[in]     h_Fm            A handle to an FM Module.
+
+ @Return        clock-freq on success; 0 otherwise.
+
+ @Cautions      Allowed only following FM_Init().
+*//***************************************************************************/
+uint16_t FmGetClockFreq(t_Handle h_Fm);
+
+/**************************************************************************//**
+ @Function      FmGetId
+
+ @Description   Used by PCD driver to read rhe FM id
+
+ @Param[in]     h_Fm            A handle to an FM Module.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Init().
+*//***************************************************************************/
+uint8_t FmGetId(t_Handle h_Fm);
+
+/**************************************************************************//**
+ @Function      FmGetSetPortParams
+
+ @Description   Used by FM-PORT driver to pass and receive parameters between
+                PORT and FM modules.
+
+ @Param[in]     h_Fm            A handle to an FM Module.
+ @Param[in,out] p_PortParams    A structure of FM Port parameters.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Init().
+*//***************************************************************************/
+t_Error FmGetSetPortParams(t_Handle h_Fm,t_FmInterModulePortInitParams *p_PortParams);
+
+/**************************************************************************//**
+ @Function      FmFreePortParams
+
+ @Description   Used by FM-PORT driver to free port's resources within the FM.
+
+ @Param[in]     h_Fm            A handle to an FM Module.
+ @Param[in,out] p_PortParams    A structure of FM Port parameters.
+
+ @Return        None.
+
+ @Cautions      Allowed only following FM_Init().
+*//***************************************************************************/
+void FmFreePortParams(t_Handle h_Fm,t_FmInterModulePortFreeParams *p_PortParams);
+
+#if (defined(CONFIG_MULTI_PARTITION_SUPPORT) && !defined(CONFIG_GUEST_PARTITION))
+t_Error     FmHandleIpcMsg(t_Handle h_Fm, uint32_t msgId, uint8_t msgBody[MSG_BODY_SIZE]);
+#endif /* (defined(CONFIG_MULTI_PARTITION_SUPPORT) && ... */
+void        FmRegisterPcd(t_Handle h_Fm, t_Handle h_FmPcd);
+void        FmUnregisterPcd(t_Handle h_Fm);
+t_Handle    FmGetPcdHandle(t_Handle h_Fm);
+bool        FmRamsEccIsExternalCtl(t_Handle h_Fm);
+t_Error     FmEnableRamsEcc(t_Handle h_Fm);
+t_Error     FmDisableRamsEcc(t_Handle h_Fm);
+void        FmGetRevision(t_Handle h_Fm, t_FmRevisionInfo *p_FmRevisionInfo);
+
+
 #endif /* __FM_COMMON_H */
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/inc/fm_hc.h b/drivers/net/dpa/NetCommSw/Peripherals/FM/inc/fm_hc.h
index 6525ef0..4506e24 100644
--- a/drivers/net/dpa/NetCommSw/Peripherals/FM/inc/fm_hc.h
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/inc/fm_hc.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/drivers/net/dpa/NetCommSw/dflags.h b/drivers/net/dpa/NetCommSw/dflags.h
index 581f0dd..8048959 100644
--- a/drivers/net/dpa/NetCommSw/dflags.h
+++ b/drivers/net/dpa/NetCommSw/dflags.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -39,6 +39,7 @@
 #define NCSW_LINUX
 
 #define P4080
+#define NCSW_PPC_CORE
 
 #define DEBUG_ERRORS        1
 
diff --git a/drivers/net/dpa/NetCommSw/etc/error.c b/drivers/net/dpa/NetCommSw/etc/error.c
index 20590fe..e1e3001 100644
--- a/drivers/net/dpa/NetCommSw/etc/error.c
+++ b/drivers/net/dpa/NetCommSw/etc/error.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/drivers/net/dpa/NetCommSw/etc/list.c b/drivers/net/dpa/NetCommSw/etc/list.c
index e71aed9..b4e16ab 100644
--- a/drivers/net/dpa/NetCommSw/etc/list.c
+++ b/drivers/net/dpa/NetCommSw/etc/list.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/drivers/net/dpa/NetCommSw/etc/memcpy.c b/drivers/net/dpa/NetCommSw/etc/memcpy.c
index 57360d4..1813805 100644
--- a/drivers/net/dpa/NetCommSw/etc/memcpy.c
+++ b/drivers/net/dpa/NetCommSw/etc/memcpy.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/drivers/net/dpa/NetCommSw/etc/mm.c b/drivers/net/dpa/NetCommSw/etc/mm.c
index 086711f..ede02ad 100644
--- a/drivers/net/dpa/NetCommSw/etc/mm.c
+++ b/drivers/net/dpa/NetCommSw/etc/mm.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/drivers/net/dpa/NetCommSw/etc/mm.h b/drivers/net/dpa/NetCommSw/etc/mm.h
index 009e16b..ce90b19 100644
--- a/drivers/net/dpa/NetCommSw/etc/mm.h
+++ b/drivers/net/dpa/NetCommSw/etc/mm.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/drivers/net/dpa/NetCommSw/etc/sprint.c b/drivers/net/dpa/NetCommSw/etc/sprint.c
index c28341f..a9337bb 100644
--- a/drivers/net/dpa/NetCommSw/etc/sprint.c
+++ b/drivers/net/dpa/NetCommSw/etc/sprint.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/drivers/net/dpa/NetCommSw/events_mapping.h b/drivers/net/dpa/NetCommSw/events_mapping.h
index 9735ee4..3ec2c69 100644
--- a/drivers/net/dpa/NetCommSw/events_mapping.h
+++ b/drivers/net/dpa/NetCommSw/events_mapping.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/drivers/net/dpa/NetCommSw/inc/Peripherals/crc_mac_addr_ext.h b/drivers/net/dpa/NetCommSw/inc/Peripherals/crc_mac_addr_ext.h
index a957648..86a2d34 100644
--- a/drivers/net/dpa/NetCommSw/inc/Peripherals/crc_mac_addr_ext.h
+++ b/drivers/net/dpa/NetCommSw/inc/Peripherals/crc_mac_addr_ext.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/drivers/net/dpa/NetCommSw/inc/Peripherals/fm_ext.h b/drivers/net/dpa/NetCommSw/inc/Peripherals/fm_ext.h
index bd04b06..64955bc 100644
--- a/drivers/net/dpa/NetCommSw/inc/Peripherals/fm_ext.h
+++ b/drivers/net/dpa/NetCommSw/inc/Peripherals/fm_ext.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -43,11 +43,18 @@
 
 
 /**************************************************************************//**
+ @Group         DPAA_grp Data Path Acceleration Architecture API
+
+ @Description   DPAA API functions, definitions and enums.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
  @Group         FM_grp Frame Manager API
 
  @Description   FM API functions, definitions and enums.
 
-
  @{
 *//***************************************************************************/
 
@@ -71,14 +78,14 @@
  @Description   enum for defining port types
 *//***************************************************************************/
 typedef enum e_FmPortType {
-    e_FM_PORT_TYPE_OFFLINE_PARSING, /**< Offline parsing port (id's: 0-6, share id's with
-                                         host command, so must have exclusive id) */
-    e_FM_PORT_TYPE_HOST_COMMAND,    /**< Host command port (id's: 0-6, share id's with
-                                         offline parsing ports, so must have exclusive id) */
-    e_FM_PORT_TYPE_RX,              /**< 1G Rx port (id's: 0-3) */
-    e_FM_PORT_TYPE_RX_10G,          /**< 10G Rx port (id's: 0) */
-    e_FM_PORT_TYPE_TX,              /**< 1G Tx port (id's: 0-3) */
-    e_FM_PORT_TYPE_TX_10G,          /**< 10G Tx port (id's: 0) */
+    e_FM_PORT_TYPE_OH_OFFLINE_PARSING,  /**< Offline parsing port (id's: 0-6, share id's with
+                                             host command, so must have exclusive id) */
+    e_FM_PORT_TYPE_OH_HOST_COMMAND,     /**< Host command port (id's: 0-6, share id's with
+                                             offline parsing ports, so must have exclusive id) */
+    e_FM_PORT_TYPE_RX,                  /**< 1G Rx port (id's: 0-3) */
+    e_FM_PORT_TYPE_RX_10G,              /**< 10G Rx port (id's: 0) */
+    e_FM_PORT_TYPE_TX,                  /**< 1G Tx port (id's: 0-3) */
+    e_FM_PORT_TYPE_TX_10G,              /**< 10G Tx port (id's: 0) */
     e_FM_PORT_TYPE_DUMMY
 } e_FmPortType;
 
@@ -115,19 +122,18 @@ typedef uint32_t    fmPortFrameErrSelect_t;                         /**< typedef
 #define FM_PORT_FRM_ERR_PROCESS_TIMEOUT                 0x00000001  /**< FPT Frame Processing Timeout Exceeded */
 /* @} */
 
-#ifdef __MWERKS__
+#if defined(__MWERKS__) && !defined(__GNUC__)
 #pragma pack(push,1)
-#endif /*__MWERKS__ */
+#endif /* defined(__MWERKS__) && ... */
 #define MEM_MAP_START
 
 /**************************************************************************//**
  @Description   FM physical Address
 *//***************************************************************************/
-typedef _Packed struct t_FmPhysAddr
-{
-    volatile uint16_t high;         /**< High part of the physical address */
+typedef _Packed struct t_FmPhysAddr {
+    volatile uint8_t  high;         /**< High part of the physical address */
     volatile uint32_t low;          /**< Low part of the physical address */
-}_PackedType t_FmPhysAddr;
+} _PackedType t_FmPhysAddr;
 
 /**************************************************************************//**
  @Description   Parse results memory layout
@@ -166,14 +172,6 @@ typedef _Packed struct t_FmPrsResult {
 #define FM_PR_L2_PPPoE            0x0800    /**< */
 
 /**************************************************************************//**
- @Description   Time stamp in buffer
-*//***************************************************************************/
-typedef _Packed struct t_FmTimeStamp {
-    volatile uint32_t    timeStamp;          /**< Time stamp integer */
-    volatile uint32_t    timeStampFrac;      /**< Time stamp fraction */
-} _PackedType t_FmTimeStamp;
-
-/**************************************************************************//**
  @Description   Frame descriptor
 *//***************************************************************************/
 typedef _Packed struct t_FmFD {
@@ -205,33 +203,36 @@ typedef enum e_FmFDFormatType {
 *//***************************************************************************/
 #define FM_FD_DD_MASK       0xc0000000           /**< FD DD field mask */
 #define FM_FD_PID_MASK      0x3f000000           /**< FD PID field mask */
+#define FM_FD_ELIODN_MASK   0x0000f000           /**< FD ELIODN field mask */
 #define FM_FD_BPID_MASK     0x00ff0000           /**< FD BPID field mask */
-#define FM_FD_ADDRH_MASK    0x0000ffff           /**< FD ADDRH field mask */
+#define FM_FD_ADDRH_MASK    0x000000ff           /**< FD ADDRH field mask */
 #define FM_FD_ADDRL_MASK    0xffffffff           /**< FD ADDRL field mask */
 #define FM_FD_FORMAT_MASK   0xe0000000           /**< FD FORMAT field mask */
 #define FM_FD_OFFSET_MASK   0x1ff00000           /**< FD OFFSET field mask */
 #define FM_FD_LENGTH_MASK   0x000fffff           /**< FD LENGTH field mask */
 
 #define FM_FD_GET_DD(fd)            ((((t_FmFD *)fd)->id & FM_FD_DD_MASK) >> (31-1))            /**< Macro to get FD DD field */
-#define FM_FD_GET_PID(fd)           ((((t_FmFD *)fd)->id & FM_FD_PID_MASK) >> (31-7))           /**< Macro to get FD PID field */
+#define FM_FD_GET_PID(fd)           (((((t_FmFD *)fd)->id & FM_FD_PID_MASK) >> (31-7)) | \
+                                        ((((t_FmFD *)fd)->id & FM_FD_LIODN_MASK) >> (31-19-6)))            /**< Macro to get FD PID field */
 #define FM_FD_GET_BPID(fd)          ((((t_FmFD *)fd)->id & FM_FD_BPID_MASK) >> (31-15))         /**< Macro to get FD BPID field */
 #define FM_FD_GET_ADDRH(fd)         (((t_FmFD *)fd)->id & FM_FD_ADDRH_MASK)                     /**< Macro to get FD ADDRH field */
 #define FM_FD_GET_ADDRL(fd)         ((t_FmFD *)fd)->addrl                                       /**< Macro to get FD ADDRL field */
-#define FM_FD_GET_PHYS_ADDR(fd)     ((uint64_t)(((uint64_t)FM_FD_GET_ADDRH(fd) << 32) | (uint64_t)FM_FD_GET_ADDRL(fd))) /**< Macro to get FD ADDR field */
+#define FM_FD_GET_PHYS_ADDR(fd)     ((physAddress_t)(((uint64_t)FM_FD_GET_ADDRH(fd) << 32) | (uint64_t)FM_FD_GET_ADDRL(fd))) /**< Macro to get FD ADDR field */
 #define FM_FD_GET_FORMAT(fd)        ((((t_FmFD *)fd)->length & FM_FD_FORMAT_MASK) >> (31-2))    /**< Macro to get FD FORMAT field */
 #define FM_FD_GET_OFFSET(fd)        ((((t_FmFD *)fd)->length & FM_FD_OFFSET_MASK) >> (31-11))   /**< Macro to get FD OFFSET field */
 #define FM_FD_GET_LENGTH(fd)        (((t_FmFD *)fd)->length & FM_FD_LENGTH_MASK)                /**< Macro to get FD LENGTH field */
 #define FM_FD_GET_STATUS(fd)        ((t_FmFD *)fd)->status                                      /**< Macro to get FD STATUS field */
-#define FM_FD_GET_ADDR(fd)          XX_PhysToVirt(CAST_UINT64_TO_POINTER(FM_FD_GET_PHYS_ADDR(fd)))
+#define FM_FD_GET_ADDR(fd)          XX_PhysToVirt(FM_FD_GET_PHYS_ADDR(fd))
 
-#define FM_FD_SET_DD(fd,val)        (((t_FmFD *)fd)->id = ((((t_FmFD *)fd)->id & ~FM_FD_DD_MASK) | ((val << (31-1))& FM_FD_DD_MASK )))      /**< Macro to set FD DD field */
-#define FM_FD_SET_PID(fd,val)       (((t_FmFD *)fd)->id = ((((t_FmFD *)fd)->id & ~FM_FD_PID_MASK) | ((val << (31-7))& FM_FD_PID_MASK)))     /**< Macro to set FD PID field */
-#define FM_FD_SET_BPID(fd,val)      (((t_FmFD *)fd)->id = ((((t_FmFD *)fd)->id & ~FM_FD_BPID_MASK) | ((val  << (31-15))& FM_FD_BPID_MASK))) /**< Macro to set FD BPID field */
+#define FM_FD_SET_DD(fd,val)        (((t_FmFD *)fd)->id = ((((t_FmFD *)fd)->id & ~FM_FD_DD_MASK) | ((val << (31-1)) & FM_FD_DD_MASK )))      /**< Macro to set FD DD field */
+/**< Macro to set FD PID field or LIODN offset*/
+#define FM_FD_SET_PID(fd,val)       (((t_FmFD *)fd)->id = ((((t_FmFD *)fd)->id & ~(FM_FD_PID_MASK|FM_FD_ELIODN_MASK)) | (((val << (31-7)) & FM_FD_PID_MASK) | (((val>>6) << (31-19)) & FM_FD_ELIODN_MASK))))
+#define FM_FD_SET_BPID(fd,val)      (((t_FmFD *)fd)->id = ((((t_FmFD *)fd)->id & ~FM_FD_BPID_MASK) | ((val  << (31-15)) & FM_FD_BPID_MASK))) /**< Macro to set FD BPID field */
 #define FM_FD_SET_ADDRH(fd,val)     (((t_FmFD *)fd)->id = ((((t_FmFD *)fd)->id & ~FM_FD_ADDRH_MASK) | (val & FM_FD_ADDRH_MASK)))            /**< Macro to set FD ADDRH field */
 #define FM_FD_SET_ADDRL(fd,val)     ((t_FmFD *)fd)->addrl = val                                 /**< Macro to set FD ADDRL field */
 #define FM_FD_SET_ADDR(fd,val)                                      \
 do {                                                                \
-    uint64_t physAddr = CAST_POINTER_TO_UINT64(XX_VirtToPhys(val)); \
+    uint64_t physAddr = (uint64_t)(XX_VirtToPhys(val)); \
     FM_FD_SET_ADDRH(fd, ((uint32_t)(physAddr >> 32)));              \
     FM_FD_SET_ADDRL(fd, (uint32_t)physAddr);                        \
 } while (0)                                                                                     /**< Macro to set FD ADDR field */
@@ -243,10 +244,11 @@ do {                                                                \
 #define FM_FD_CMD_FCO  0x80000000      /* Frame queue Context Override */
 #define FM_FD_CMD_RPD  0x40000000      /* Read Prepended Data */
 #define FM_FD_CMD_UDP  0x20000000      /* Update Prepended Data */
-#define FM_FD_CMD_BMF  0x10000000      /* Buffer Must not be Freed */
-#define FM_FD_CMD_DTC  0x08000000      /* Do TCP Checksum */
-#define FM_FD_CMD_DME  0x01000000      /* DMA Error */
+#define FM_FD_CMD_DTC  0x10000000      /* Do TCP Checksum */
+
 #define FM_FD_CMD_CFQ  0x00ffffff      /* Confirmation Frame Queue */
+
+#define FM_FD_TX_STATUS_ERR_MASK    0x07000000
 /* @} */
 
 /**************************************************************************//**
@@ -271,7 +273,7 @@ typedef _Packed struct t_FmSGT {
 /**************************************************************************//**
  @Collection   Frame Scatter/Gather Table Entry macros
 *//***************************************************************************/
-#define FM_SGTE_ADDRH_MASK    0x0000ffff           /**< SGTE ADDRH field mask */
+#define FM_SGTE_ADDRH_MASK    0x000000ff           /**< SGTE ADDRH field mask */
 #define FM_SGTE_ADDRL_MASK    0xffffffff           /**< SGTE ADDRL field mask */
 #define FM_SGTE_E_MASK        0x80000000           /**< SGTE Extension field mask */
 #define FM_SGTE_F_MASK        0x40000000           /**< SGTE Final field mask */
@@ -281,19 +283,19 @@ typedef _Packed struct t_FmSGT {
 
 #define FM_SGTE_GET_ADDRH(sgte)         (((t_FmSGTE *)sgte)->addrh & FM_SGTE_ADDRH_MASK)                /**< Macro to get SGTE ADDRH field */
 #define FM_SGTE_GET_ADDRL(sgte)         ((t_FmSGTE *)sgte)->addrl                                       /**< Macro to get SGTE ADDRL field */
-#define FM_SGTE_GET_PHYS_ADDR(sgte)       ((uint64_t)(((uint64_t)FM_SGTE_GET_ADDRH(sgte) << 32) | (uint64_t)FM_SGTE_GET_ADDRL(sgte))) /**< Macro to get FD ADDR field */
+#define FM_SGTE_GET_PHYS_ADDR(sgte)     ((physAddress_t)(((uint64_t)FM_SGTE_GET_ADDRH(sgte) << 32) | (uint64_t)FM_SGTE_GET_ADDRL(sgte))) /**< Macro to get FD ADDR field */
 #define FM_SGTE_GET_EXTENSION(sgte)     ((((t_FmSGTE *)sgte)->length & FM_SGTE_E_MASK) >> (31-0))       /**< Macro to get SGTE EXTENSION field */
 #define FM_SGTE_GET_FINAL(sgte)         ((((t_FmSGTE *)sgte)->length & FM_SGTE_F_MASK) >> (31-1))       /**< Macro to get SGTE FINAL field */
 #define FM_SGTE_GET_LENGTH(sgte)        (((t_FmSGTE *)sgte)->length & FM_SGTE_LENGTH_MASK)              /**< Macro to get SGTE LENGTH field */
 #define FM_SGTE_GET_BPID(sgte)          ((((t_FmSGTE *)sgte)->offset & FM_SGTE_BPID_MASK) >> (31-15))   /**< Macro to get SGTE BPID field */
 #define FM_SGTE_GET_OFFSET(sgte)        (((t_FmSGTE *)sgte)->offset & FM_SGTE_OFFSET_MASK)              /**< Macro to get SGTE OFFSET field */
-#define FM_SGTE_GET_ADDR(sgte)          XX_PhysToVirt(CAST_UINT64_TO_POINTER(FM_SGTE_GET_PHYS_ADDR(sgte)))
+#define FM_SGTE_GET_ADDR(sgte)          XX_PhysToVirt(FM_SGTE_GET_PHYS_ADDR(sgte))
 
 #define FM_SGTE_SET_ADDRH(sgte,val)     (((t_FmSGTE *)sgte)->addrh = ((((t_FmSGTE *)sgte)->addrh & ~FM_SGTE_ADDRH_MASK) | (val & FM_SGTE_ADDRH_MASK))) /**< Macro to set SGTE ADDRH field */
 #define FM_SGTE_SET_ADDRL(sgte,val)     ((t_FmSGTE *)sgte)->addrl = val                                 /**< Macro to set SGTE ADDRL field */
 #define FM_SGTE_SET_ADDR(sgte,val)                                      \
 do {                                                                    \
-    uint64_t physAddr = CAST_POINTER_TO_UINT64(XX_VirtToPhys(val));     \
+    uint64_t physAddr = (uint64_t)(XX_VirtToPhys(val));     \
     FM_SGTE_SET_ADDRH(sgte, ((uint32_t)(physAddr >> 32)));              \
     FM_SGTE_SET_ADDRL(sgte, (uint32_t)physAddr);                        \
 } while (0)                                                                                     /**< Macro to set SGTE ADDR field */
@@ -304,9 +306,9 @@ do {                                                                    \
 #define FM_SGTE_SET_OFFSET(sgte,val)    (((t_FmSGTE *)sgte)->offset = ((((t_FmSGTE *)sgte)->offset & ~FM_SGTE_OFFSET_MASK) | ((val << (31-11))& FM_SGTE_OFFSET_MASK) )) /**< Macro to set SGTE OFFSET field */
 
 #define MEM_MAP_END
-#ifdef __MWERKS__
+#if defined(__MWERKS__) && !defined(__GNUC__)
 #pragma pack(pop)
-#endif /* __MWERKS__ */
+#endif /* defined(__MWERKS__) && ... */
 
 /* @} */
 
@@ -319,13 +321,12 @@ typedef enum e_FmExceptions {
     e_FM_EX_DMA_READ_ECC,               /**< Read Buffer ECC error */
     e_FM_EX_DMA_SYSTEM_WRITE_ECC,       /**< Write Buffer ECC error on system side */
     e_FM_EX_DMA_FM_WRITE_ECC,           /**< Write Buffer ECC error on FM side */
-    e_FM_EX_FPM_STALL_ON_TASKS ,        /**< Stall of tasks on FPM */
+    e_FM_EX_FPM_STALL_ON_TASKS,         /**< Stall of tasks on FPM */
     e_FM_EX_FPM_SINGLE_ECC,             /**< Single ECC on FPM. */
     e_FM_EX_FPM_DOUBLE_ECC,             /**< Double ECC error on FPM ram access */
     e_FM_EX_QMI_SINGLE_ECC,             /**< Single ECC on QMI. */
     e_FM_EX_QMI_DOUBLE_ECC,             /**< Double bit ECC occured on QMI */
-    e_FM_EX_QMI_DEQ_FROM_DEFQ,          /**< Dequeu from default queue id, as a result
-                                             of invalid port id. */
+    e_FM_EX_QMI_DEQ_FROM_UNKNOWN_PORTID,/**< Dequeu from unknown port id */
     e_FM_EX_BMI_LIST_RAM_ECC,           /**< Linked List RAM ECC error */
     e_FM_EX_BMI_PIPELINE_ECC,           /**< Pipeline Table ECC Error */
     e_FM_EX_BMI_STATISTICS_RAM_ECC,     /**< Statistics Count RAM ECC Error Enable */
@@ -394,15 +395,15 @@ typedef struct t_FmPcdFirmwareParams {
 typedef struct t_FmParams {
     uint8_t                 fmId;                   /**< Index of the FM */
 #ifdef CONFIG_MULTI_PARTITION_SUPPORT
-    uint8_t                     partitionId;        /**< FM Partition Id */
+    uint8_t                 partitionId;            /**< FM Partition Id */
 #endif /* CONFIG_MULTI_PARTITION_SUPPORT */
 #ifndef CONFIG_GUEST_PARTITION
     uint64_t                baseAddr;               /**< A pointer to base of memory mapped FM registers (virtual).*/
     t_Handle                h_FmMuram;              /**< A handle of an initialized MURAM object,
                                                          to be used by the FM */
     uint16_t                fmClkFreq;              /**< In Mhz */
-    uint8_t                 liodnPerPartition[FM_MAX_NUM_OF_PARTITIONS]; /**< For each partition, LIODN should be configured here. */
-    t_FmExceptionsCallback  *f_Exceptions;          /**< An application callback routine to
+    uint16_t                liodnPerPartition[FM_MAX_NUM_OF_PARTITIONS]; /**< For each partition, LIODN should be configured here. */
+    t_FmExceptionsCallback  *f_Exception ;          /**< An application callback routine to
                                                          handle exceptions.*/
     t_FmBusErrorCallback    *f_BusError;            /**< An application callback routine to
                                                          handle exceptions.*/
@@ -484,7 +485,7 @@ typedef enum e_FmDmaDbgCntMode {
  @Description   DMA Cache Override
 *//***************************************************************************/
 typedef enum e_FmDmaCacheOverride {
-    e_FM_DMA_NO_CACHE_OR,                   /**< No override of the Cache field */
+    e_FM_DMA_NO_CACHE_OR = 0,               /**< No override of the Cache field */
     e_FM_DMA_NO_STASH_DATA,                 /**< Data should not be stashed in system level cache */
     e_FM_DMA_MAY_STASH_DATA,                /**< Data may be stashed in system level cache */
     e_FM_DMA_STASH_DATA                     /**< Data should be stashed in system level cache */
@@ -494,7 +495,7 @@ typedef enum e_FmDmaCacheOverride {
  @Description   DMA External Bus Priority
 *//***************************************************************************/
 typedef enum e_FmDmaExtBusPri {
-    e_FM_DMA_EXT_BUS_NORMAL,                /**< Normal priority */
+    e_FM_DMA_EXT_BUS_NORMAL = 0,            /**< Normal priority */
     e_FM_DMA_EXT_BUS_EBS,                   /**< AXI extended bus service priority */
     e_FM_DMA_EXT_BUS_SOS,                   /**< AXI sos priority */
     e_FM_DMA_EXT_BUS_EBS_AND_SOS            /**< AXI ebs + sos priority */
@@ -504,7 +505,7 @@ typedef enum e_FmDmaExtBusPri {
  @Description   enum for choosing the field that will be output on AID
 *//***************************************************************************/
 typedef enum e_FmDmaAidMode {
-    e_FM_DMA_AID_OUT_PORT_ID,               /**< 4 LSB of PORT_ID */
+    e_FM_DMA_AID_OUT_PORT_ID = 0,           /**< 4 LSB of PORT_ID */
     e_FM_DMA_AID_OUT_TNUM                   /**< 4 LSB of TNUM */
 } e_FmDmaAidMode;
 
@@ -512,7 +513,7 @@ typedef enum e_FmDmaAidMode {
  @Description   DMA AXI Bus protection
 *//***************************************************************************/
 typedef enum e_FmDmaBusProtectionType {
-    e_FM_DMA_DATA_BUS_PROT,                 /**< AXI data bus protection */
+    e_FM_DMA_DATA_BUS_PROT = 0,             /**< AXI data bus protection */
     e_FM_DMA_INSTRUCTION_BUS_PROT           /**< AXI instruction bus protection */
 } e_FmDmaBusProtectionType;
 
@@ -520,7 +521,7 @@ typedef enum e_FmDmaBusProtectionType {
  @Description   FPM Catasrophic error behaviour
 *//***************************************************************************/
 typedef enum e_FmCatastrophicErr {
-    e_FM_CATASTROPHIC_ERR_STALL_PORT,       /**< Port_ID is stalled (only reset can release it) */
+    e_FM_CATASTROPHIC_ERR_STALL_PORT = 0,   /**< Port_ID is stalled (only reset can release it) */
     e_FM_CATASTROPHIC_ERR_STALL_TASK        /**< Only errornous task is stalled */
 } e_FmCatastrophicErr;
 
@@ -528,7 +529,7 @@ typedef enum e_FmCatastrophicErr {
  @Description   FPM DMA error behaviour
 *//***************************************************************************/
 typedef enum e_FmDmaErr {
-    e_FM_DMA_ERR_CATASTROPHIC,              /**< Dma error is treated as a catastrophic error */
+    e_FM_DMA_ERR_CATASTROPHIC = 0,          /**< Dma error is treated as a catastrophic error */
     e_FM_DMA_ERR_REPORT                     /**< Dma error is just reported */
 } e_FmDmaErr;
 
@@ -536,7 +537,7 @@ typedef enum e_FmDmaErr {
  @Description   DMA Emergency level by BMI emergency signal
 *//***************************************************************************/
 typedef enum e_FmDmaEmergencyLevel {
-    e_FM_DMA_EM_EBS,                        /**< EBS emergency */
+    e_FM_DMA_EM_EBS = 0,                    /**< EBS emergency */
     e_FM_DMA_EM_SOS                         /**< SOS emergency */
 } e_FmDmaEmergencyLevel;
 
@@ -688,34 +689,11 @@ t_Error FM_ConfigMaxNumOfOpenDmas(t_Handle h_Fm, uint8_t maxNumOfOpenDmas);
 t_Error FM_ConfigThresholds(t_Handle h_Fm, t_FmThresholds *p_FmThresholds);
 
 /**************************************************************************//**
- @Function      FM_ConfigTimeStamp
-
- @Description   This routine enables the FPM timeStamp and sets its frequency.
-                Calling this routine changes the internal driver data base
-                from its default configuration - by default time stamp is disabled.
-                The value selected here will be used for the non-Rx ports
-                rate-limit mechanism and for the policer profiles.
-                Note that rate-limiting may be done only for time
-                units larger than the timeStampPeriod specifies
-                here (i.e. select here the smallest time unit
-                required between all ports).
-
-
- @Param[in]     h_Fm                A handle to an FM Module.
- @Param[in]     timeStampPeriod    (in nano-seconds)
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_Config() and before FM_Init().
-*//***************************************************************************/
-t_Error FM_ConfigTimeStamp(t_Handle h_Fm, uint32_t timeStampPeriod);
-
-/**************************************************************************//**
  @Function      FM_ConfigDmaBusProtect
 
  @Description   Calling this routine changes the internal driver data base
                 from its default FM threshold configuration
-                                  privilegeBusProtect:      [DEFAULT_secureBusProtect]
+                                  privilegeBusProtect:      [DEFAULT_privilegeBusProtect]
                                   busProtectType:           [DEFAULT_busProtectionType]
 
  @Param[in]     h_Fm                A handle to an FM Module.
@@ -1113,8 +1091,8 @@ t_Error FM_ConfigExternalEccRamsEnable(t_Handle h_Fm, bool enable);
 /**************************************************************************//**
  @Collection   General FM defines.
 *//***************************************************************************/
-#define NUM_OF_PORT_TYPES               e_FM_PORT_TYPE_DUMMY    /**< Number of port types */
-#define MAX_NUM_OF_PORTS_PER_TYPE       7                       /**< Max number of ports of the same type */
+#define FM_NUM_OF_PORT_TYPES               e_FM_PORT_TYPE_DUMMY    /**< Number of port types */
+#define FM_MAX_NUM_OF_PORTS_PER_TYPE       7                       /**< Max number of ports of the same type */
 /* @} */
 
 /**************************************************************************//**
@@ -1124,7 +1102,7 @@ t_Error FM_ConfigExternalEccRamsEnable(t_Handle h_Fm, bool enable);
                 Note that not all places in the array are valid e.g
                 array[e_FM_PORT_TYPE_TX_10G][1] is not a valid indexes pair.
 *//***************************************************************************/
-typedef uint8_t t_PortsParam[NUM_OF_PORT_TYPES][MAX_NUM_OF_PORTS_PER_TYPE];
+typedef uint8_t t_PortsParam[FM_NUM_OF_PORT_TYPES][FM_MAX_NUM_OF_PORTS_PER_TYPE];
 
 /**************************************************************************//**
  @Description   DMA Emergency control on MURAM
@@ -1221,8 +1199,8 @@ t_Error FM_SetPortsBandwidth(t_Handle h_Fm, t_PortsParam *p_PortsBandwidth);
 /**************************************************************************//**
  @Function      FM_EnableRamsEcc
 
- @Description   Enables ECC mechanism for the different FM RAM's - IRAM, MURAM,
-                Parser, Keygen and Policer.
+ @Description   Enables ECC mechanism for all the different FM RAM's; E.g. IRAM,
+                MURAM, Parser, Keygen, Policer, etc.
                 Note:
                 If FM_ConfigExternalEccRamsEnable was called to enable external
                 setting of ECC, this routine effects IRAM ECC only.
@@ -1240,8 +1218,8 @@ t_Error FM_EnableRamsEcc(t_Handle h_Fm);
 /**************************************************************************//**
  @Function      FM_DisableRamsEcc
 
- @Description   Disables ECC mechanism for the different FM RAM's - IRAM, MURAM,
-                Parser, Keygen and Policer.
+ @Description   Disables ECC mechanism for all the different FM RAM's; E.g. IRAM,
+                MURAM, Parser, Keygen, Policer, etc.
                 Note:
                 If FM_ConfigExternalEccRamsEnable was called to enable external
                 setting of ECC, this routine effects IRAM ECC only.
@@ -1289,7 +1267,7 @@ void  FM_GetRevision(t_Handle h_Fm, t_FmRevisionInfo *p_FmRevisionInfo);
 uint32_t  FM_GetCounter(t_Handle h_Fm, e_FmCounters counter);
 
 /**************************************************************************//**
- @Function      FM_SetCounter
+ @Function      FM_ModifyCounter
 
  @Description   Sets a value to an enabled counter. Use "0" to reset the counter.
 
@@ -1301,7 +1279,7 @@ uint32_t  FM_GetCounter(t_Handle h_Fm, e_FmCounters counter);
 
  @Cautions      Allowed only following FM_Init().
 *//***************************************************************************/
-t_Error  FM_SetCounter(t_Handle h_Fm, e_FmCounters counter, uint32_t val);
+t_Error  FM_ModifyCounter(t_Handle h_Fm, e_FmCounters counter, uint32_t val);
 
 /**************************************************************************//**
  @Function      FM_Resume
@@ -1315,19 +1293,6 @@ t_Error  FM_SetCounter(t_Handle h_Fm, e_FmCounters counter, uint32_t val);
 void FM_Resume(t_Handle h_Fm);
 
 /**************************************************************************//**
- @Function      FM_GetTimeStamp
-
- @Description   Reads the current time stamp
-
- @Param[in]     h_Fm    A handle to an FM Module.
-
- @Return        TimeStamp integer at calling time.
-
- @Cautions      Allowed only following FM_Init().
-*//***************************************************************************/
-uint32_t FM_GetTimeStamp(t_Handle h_Fm);
-
-/**************************************************************************//**
  @Function      FM_SetDmaEmergency
 
  @Description   Manual emergency set
@@ -1442,237 +1407,7 @@ t_Error FmDumpPortRegs(t_Handle h_Fm,uint8_t hardwarePortId);
 
 /** @} */ /* end of FM_lib_grp group */
 /** @} */ /* end of FM_grp group */
+/** @} */ /* end of DPAA_grp group */
 
-/*****************************************************/
-/*****************************************************/
-/****   Inter-module Routines and definitions     ****/
-/*****************************************************/
-/*****************************************************/
-#ifndef DOXYGEN_ONLY
-
-/**************************************************************************//**
-@Group         FM_InterModule_grp FM Inter-Module Unit
-
- @Description   FM Inter Module functions -
-                These are not User API routines but routines that may be called
-                from other modules.
-                Routines used by PCD module are always called directly by the PCD
-                module, since the PCD and FM modules always run on the same core.
-                As for routines used by other modules (FM-Port), They will be called directly
-                in a single core environment. In a multicore environment, some of the
-                other modules may be run by other cores and therefor these routines
-                may not be called directly and will be internally invoked using the
-                XX messeging mechanism.
-
- @{
-*//***************************************************************************/
-
-/**************************************************************************//**
- @Description   enum for defining MAC types
-*//***************************************************************************/
-typedef enum e_FmMacType {
-    e_FM_MAC_10G,               /**< 10G MAC */
-    e_FM_MAC_1G                 /**< 1G MAC */
-} e_FmMacType;
-
-/**************************************************************************//**
- @Description   Structure for port-FM communication during FM_PORT_Init.
-                Fields commented 'IN' are passed by the port module to be used
-                by the FM module.
-                Fields commented 'OUT' will be filled by FM before returning to port.
-                Some fields are optional (depending on configuration) and
-                will be analized by the port and FM modules accordingly.
-*//***************************************************************************/
-typedef struct t_FmInterModulePortInitParams {
-    uint8_t             hardwarePortId;       /**< IN. port Id */
-    e_FmPortType        portType;           /**< IN. Port type */
-    uint32_t            timeStampPeriod;    /**< OUT. Time stamp period in NanoSec */
-    bool                independentMode;    /**< IN. TRUE if FM Port operates in independent mode */
-    uint8_t             portPartition;      /**< IN. Port's requested resource */
-    uint8_t             numOfTasks;         /**< IN. Port's requested resource */
-    uint8_t             numOfExtraTasks;    /**< IN. Port's requested resource */
-    uint8_t             numOfOpenDmas;      /**< IN. Port's requested resource */
-    uint8_t             numOfExtraOpenDmas; /**< IN. Port's requested resource */
-    uint32_t            sizeOfFifo;         /**< IN. Port's requested resource */
-    uint32_t            extraSizeOfFifo;    /**< IN. Port's requested resource */
-    uint8_t             deqPipelineDepth;   /**< IN. Port's requested resource */
-    t_FmPhysAddr        fmMuramPhysBaseAddr;/**< OUT. FM-MURAM physical address*/
-} t_FmInterModulePortInitParams;
-
-/**************************************************************************//**
- @Description   Structure for port-FM communication during FM_PORT_Free.
-*//***************************************************************************/
-typedef struct t_FmInterModulePortFreeParams {
-    uint8_t             hardwarePortId;     /**< IN. port Id */
-    e_FmPortType        portType;           /**< IN. Port type */
-    uint8_t             deqPipelineDepth;   /**< IN. Port's requested resource */
-} t_FmInterModulePortFreeParams;
-
-/**************************************************************************//**
- @Function      FmGetPcdPrsBaseAddr
-
- @Description   Get the base address of the Parser from the FM module
-
- @Param[in]     h_Fm            A handle to an FM Module.
-
- @Return        Base address.
-*//***************************************************************************/
-uint64_t FmGetPcdPrsBaseAddr(t_Handle h_Fm);
-
-/**************************************************************************//**
- @Function      FmGetPcdKgBaseAddr
-
- @Description   Get the base address of the Keygen from the FM module
-
- @Param[in]     h_Fm            A handle to an FM Module.
-
- @Return        Base address.
-*//***************************************************************************/
-uint64_t FmGetPcdKgBaseAddr(t_Handle h_Fm);
-
-/**************************************************************************//**
- @Function      FmGetPcdPlcrBaseAddr
-
- @Description   Get the base address of the Policer from the FM module
-
- @Param[in]     h_Fm            A handle to an FM Module.
-
- @Return        Base address.
-*//***************************************************************************/
-uint64_t FmGetPcdPlcrBaseAddr(t_Handle h_Fm);
-
-/**************************************************************************//**
- @Function      FmGetMuramHandle
-
- @Description   Get the handle of the MURAM from the FM module
-
- @Param[in]     h_Fm            A handle to an FM Module.
-
- @Return        MURAM module handle.
-*//***************************************************************************/
-t_Handle FmGetMuramHandle(t_Handle h_Fm);
-
-/**************************************************************************//**
- @Function      FmGetPhysicalMuramBase
-
- @Description   Get the physical base address of the MURAM from the FM module
-
- @Param[in]     h_Fm            A handle to an FM Module.
- @Param[in]     fmPhysAddr      Physical MURAM base
-
- @Return        Physical base address.
-*//***************************************************************************/
-t_Error FmGetPhysicalMuramBase(t_Handle h_Fm, t_FmPhysAddr *fmPhysAddr);
-
-/**************************************************************************//**
- @Function      FmGetTimeStampPeriod
-
- @Description   Used internally by other modules in order to get the timeStamp
-                period as requested by the application.
-
- @Param[in]     h_Fm                    A handle to an FM Module.
-
- @Return        TimeStamp period in nanoseconds.
-
- @Cautions      Allowed only following FM_Init().
-*//***************************************************************************/
-uint32_t    FmGetTimeStampPeriod(t_Handle h_Fm);
-
-/**************************************************************************//**
- @Function      FmResumeStalledPort
-
- @Description   Used internally by FM port to release a stalled port.
-
- @Param[in]     h_Fm                            A handle to an FM Module.
- @Param[in]     hardwarePortId                    HW port id.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_Init().
-*//***************************************************************************/
-t_Error FmResumeStalledPort(t_Handle h_Fm, uint8_t hardwarePortId);
-
-/**************************************************************************//**
- @Function      FmIsPortStalled
-
- @Description   Used internally by FM port to read the port's status.
-
- @Param[in]     h_Fm                            A handle to an FM Module.
- @Param[in]     hardwarePortId                    HW port id.
-
- @Return        TRUE if port is stalled, FALSE otherwize
-
- @Cautions      Allowed only following FM_Init().
-*//***************************************************************************/
-bool FmIsPortStalled(t_Handle h_Fm, uint8_t hardwarePortId);
-
-/**************************************************************************//**
- @Function      FmResetMac
-
- @Description   Used by MAC driver to reset the MAC registers
-
- @Param[in]     h_Fm            A handle to an FM Module.
- @Param[in]     type            MAC type.
- @Param[in]     macId           MAC id - according to type.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_Init().
-*//***************************************************************************/
-t_Error FmResetMac(t_Handle h_Fm, e_FmMacType type, uint8_t macId);
-
-/**************************************************************************//**
- @Function      FmGetId
-
- @Description   Used by PCD driver to read rhe FM id
-
- @Param[in]     h_Fm            A handle to an FM Module.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_Init().
-*//***************************************************************************/
-uint8_t FmGetId(t_Handle h_Fm);
-
-/**************************************************************************//**
- @Function      FmGetSetPortParams
-
- @Description   Used by FM-PORT driver to pass and receive parameters between
-                PORT and FM modules.
-
- @Param[in]     h_Fm            A handle to an FM Module.
- @Param[in,out] p_PortParams    A structure of FM Port parameters.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_Init().
-*//***************************************************************************/
-t_Error FmGetSetPortParams(t_Handle h_Fm,t_FmInterModulePortInitParams *p_PortParams);
-
-/**************************************************************************//**
- @Function      FmFreePortParams
-
- @Description   Used by FM-PORT driver to free port's resources within the FM.
-
- @Param[in]     h_Fm            A handle to an FM Module.
- @Param[in,out] p_PortParams    A structure of FM Port parameters.
-
- @Return        None.
-
- @Cautions      Allowed only following FM_Init().
-*//***************************************************************************/
-void FmFreePortParams(t_Handle h_Fm,t_FmInterModulePortFreeParams *p_PortParams);
-
-#if (defined(CONFIG_MULTI_PARTITION_SUPPORT) && !defined(CONFIG_GUEST_PARTITION))
-t_Error     FmHandleIpcMsg(t_Handle h_Fm, uint32_t msgId, uint8_t msgBody[MSG_BODY_SIZE]);
-#endif /* (defined(CONFIG_MULTI_PARTITION_SUPPORT) && ... */
-void        FmRegisterPcd(t_Handle h_Fm, t_Handle h_FmPcd);
-t_Handle    FmGetPcdHandle(t_Handle h_Fm);
-bool        FmRamsEccIsExternalCtl(t_Handle h_Fm);
-
-
-/** @} */ /* end of FM_lib_grp group */
-
-#endif /* ! DOXYGEN_ONLY */
 
 #endif /* __FM_EXT */
diff --git a/drivers/net/dpa/NetCommSw/inc/Peripherals/fm_mac_ext.h b/drivers/net/dpa/NetCommSw/inc/Peripherals/fm_mac_ext.h
index b603e0d..a8c41b8 100644
--- a/drivers/net/dpa/NetCommSw/inc/Peripherals/fm_mac_ext.h
+++ b/drivers/net/dpa/NetCommSw/inc/Peripherals/fm_mac_ext.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -58,6 +58,7 @@
  @{
 *//***************************************************************************/
 
+
 /**************************************************************************//**
  @Description   FM MAC Exceptions
 *//***************************************************************************/
@@ -116,8 +117,8 @@ typedef enum e_FmMacExceptions {
     e_FM_MAC_INT_RECOVER,                   /**<   Enable Default Interrupts */
     e_FM_MAC_INT_MINOR                      /**<   Disable all Interrupts */
 } e_FmMacExceptions;
-
 #endif /* 0*/
+
 /**************************************************************************//**
  @Function      t_FmMacExceptionCallback
 
@@ -163,20 +164,20 @@ typedef struct t_FmMacStatistics {
     uint64_t  ifInBcastPkts;           /**< Total number of broadcast frame received */
     uint64_t  ifInDiscards;            /**< Frames received, but discarded due to problems within the MAC RX. */
     uint64_t  ifInErrors;              /**< Number of frames received with error:
-                                                FIFO Overflow Error
-                                                CRC Error
-                                                Frame Too Long Error
-                                                Alignment Error
-                                                The dedicated Error Code (0xfe, not a code error) was received */
+                                               - FIFO Overflow Error
+                                               - CRC Error
+                                               - Frame Too Long Error
+                                               - Alignment Error
+                                               - The dedicated Error Code (0xfe, not a code error) was received */
     uint64_t  ifOutOctets;             /**< Total number of byte sent. */
     uint64_t  ifOutPkts;               /**< Total number of packets sent .*/
     uint64_t  ifOutMcastPkts;          /**< Total number of multicast frame sent */
     uint64_t  ifOutBcastPkts;          /**< Total number of multicast frame sent */
     uint64_t  ifOutDiscards;           /**< Frames received, but discarded due to problems within the MAC TX N/A!.*/
     uint64_t  ifOutErrors;             /**< Number of frames transmitted with error:
-                                                FIFO Overflow Error
-                                                FIFO Underflow Error
-                                                Other*/
+                                               - FIFO Overflow Error
+                                               - FIFO Underflow Error
+                                               - Other */
 } t_FmMacStatistics;
 
 
@@ -200,12 +201,13 @@ typedef struct t_FmMacParams {
     int                         mdioIrq;            /**< MDIO exceptions interrupt source - not valid for all
                                                          MACs; for MACs that don't have mdio-irq, leave this
                                                          parameters 0; For polling, put this parameter - NO_IRQ */
-    t_FmMacExceptionCallback    *f_Events;          /**< MDIO Events Callback Routine         */
-    t_FmMacExceptionCallback    *f_Exceptions;      /**< Exception Callback Routine         */
+    t_FmMacExceptionCallback    *f_Event;           /**< MDIO Events Callback Routine         */
+    t_FmMacExceptionCallback    *f_Exception;       /**< Exception Callback Routine         */
     t_Handle                    h_App;              /**< A handle to an application layer object; This handle will
                                                          be passed by the driver upon calling the above callbacks */
 } t_FmMacParams;
 
+
 /**************************************************************************//**
  @Function      FM_MAC_Config
 
@@ -303,7 +305,7 @@ t_Error FM_MAC_ConfigLoopback (t_Handle h_FmMac, bool enable);
 /**************************************************************************//**
  @Function      FM_MAC_ConfigMaxFrameLength
 
- @Description   Setup maximum Farme Length
+ @Description   Setup maximum Frame Length
 
  @Param[in]     h_FmMac    A handle to a FM MAC Module.
  @Param[in]     newVal     MAX Frame length
@@ -357,9 +359,9 @@ t_Error FM_MAC_ConfigPadAndCrc (t_Handle h_FmMac, bool enable);
 t_Error FM_MAC_ConfigHalfDuplex (t_Handle h_FmMac, bool enable);
 
 /**************************************************************************//**
- @Function      FM_MAC_ConfigHugeFrames
+ @Function      FM_MAC_ConfigLengthCheck
 
- @Description   Enable Huge Frame mode
+ @Description   Configure thef frame length checking.
 
  @Param[in]     h_FmMac    A handle to a FM MAC Module.
  @Param[in]     enable     TRUE to enable or FALSE to disable.
@@ -368,7 +370,7 @@ t_Error FM_MAC_ConfigHalfDuplex (t_Handle h_FmMac, bool enable);
 
  @Cautions      Allowed only following FM_MAC_Config() and before FM_MAC_Init().
 *//***************************************************************************/
-t_Error FM_MAC_ConfigHugeFrames (t_Handle h_FmMac, bool enable);
+t_Error FM_MAC_ConfigLengthCheck (t_Handle h_FmMac, bool enable);
 
 /**************************************************************************//**
  @Function      FM_MAC_ConfigException
@@ -427,18 +429,30 @@ t_Error FM_MAC_Enable  (t_Handle h_FmMac,  e_CommMode mode);
 t_Error FM_MAC_Disable (t_Handle h_FmMac, e_CommMode mode);
 
 /**************************************************************************//**
- @Function      FM_MAC_Restart
+ @Function      FM_MAC_Enable1588TimeStamp
 
- @Description   Restart Rx and Tx on FM-MAC controller
+ @Description   Enables the TSU operation.
 
- @Param[in]     h_FmMac    A handle to a FM MAC Module.
- @Param[in]     mode       Restart the MAC to this mode
+ @Param[in]     h_Fm   - Handle to the PTP as returned from the FM_MAC_PtpConfig.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MAC_Init().
+*//***************************************************************************/
+t_Error FM_MAC_Enable1588TimeStamp(t_Handle h_Fm);
+
+/**************************************************************************//**
+ @Function      FM_MAC_Disable1588TimeStamp
+
+ @Description   Disables the TSU operation.
+
+ @Param[in]     h_Fm   - Handle to the PTP as returned from the FM_MAC_PtpConfig.
 
  @Return        E_OK on success; Error code otherwise.
 
- @Cautions      Allowed only following FM_MAC_Disable().
+ @Cautions      Allowed only following FM_MAC_Init().
 *//***************************************************************************/
-t_Error FM_MAC_Restart (t_Handle h_FmMac, e_CommMode mode);
+t_Error FM_MAC_Disable1588TimeStamp(t_Handle h_Fm);
 
 /**************************************************************************//**
  @Function      FM_MAC_TxMacPause
@@ -446,14 +460,14 @@ t_Error FM_MAC_Restart (t_Handle h_FmMac, e_CommMode mode);
  @Description   Enable transmition of  Pause frame
 
  @Param[in]     h_FmMac     A handle to a FM MAC Module.
- @Param[in]     pauseTime   Define pause time
- @Param[in]     exPauseTime define Extended pause time (not on 10G)
+ @Param[in]     pauseTime   Pause quanta value used with transmitted pause frames.
+                            Each quanta represents a 512 bit-times.
 
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_MAC_Init().
 *//***************************************************************************/
-t_Error FM_MAC_TxMacPause (t_Handle h_FmMac, uint16_t pauseTime, uint16_t exPauseTime);
+t_Error FM_MAC_TxMacPause (t_Handle h_FmMac, uint16_t pauseTime);
 
 /**************************************************************************//**
  @Function      FM_MAC_ResetCounters
@@ -582,6 +596,7 @@ t_Error FM_MAC_RemovelExactMatchMacAddr (t_Handle h_FmMac, t_EnetAddr *p_EnetAdd
  @Cautions      Allowed only after FM_MAC_Init().
 *//***************************************************************************/
 t_Error FM_MAC_SetPromiscuous (t_Handle h_FmMac, bool enable);
+
 /**************************************************************************//**
  @Function      FM_MAC_AdjustLink
 
diff --git a/drivers/net/dpa/NetCommSw/inc/Peripherals/fm_muram_ext.h b/drivers/net/dpa/NetCommSw/inc/Peripherals/fm_muram_ext.h
index 47cc754..1321d9d 100644
--- a/drivers/net/dpa/NetCommSw/inc/Peripherals/fm_muram_ext.h
+++ b/drivers/net/dpa/NetCommSw/inc/Peripherals/fm_muram_ext.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/drivers/net/dpa/NetCommSw/inc/Peripherals/fm_pcd_ext.h b/drivers/net/dpa/NetCommSw/inc/Peripherals/fm_pcd_ext.h
index b48994d..89d219c 100644
--- a/drivers/net/dpa/NetCommSw/inc/Peripherals/fm_pcd_ext.h
+++ b/drivers/net/dpa/NetCommSw/inc/Peripherals/fm_pcd_ext.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -87,7 +87,7 @@ typedef uint32_t fmPcdEngines_t; /**< options as defined below: */
 #define FM_PCD_PRS_NUM_OF_HDRS                      16                  /**< Number of headers supported by HW parser */
 #define FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS         (32 - FM_PCD_MAX_NUM_OF_PRIVATE_HDRS)
                                                                         /**< Maximum number of netenv distinction units */
-#define MAX_NUM_OF_OPTIONS                          8                   /**< Maximum number of netenv distinction units options */
+#define FM_PCD_MAX_NUM_OF_OPTIONS                   8                   /**< Maximum number of netenv distinction units options */
 #define FM_PCD_MAX_NUM_OF_INTERCHANGABLE_HDRS       4                   /**< Maximum number of interchangable headers in a distinction unit */
 #define FM_PCD_KG_NUM_OF_GENERIC_REGS               8                   /**< Total number of generic KG registers */
 #define FM_PCD_KG_MAX_NUM_OF_EXTRACTS_PER_KEY       35                  /**< Max number allowed on any configuration.
@@ -99,12 +99,12 @@ typedef uint32_t fmPcdEngines_t; /**< options as defined below: */
 #define FM_PCD_KG_NUM_OF_DEFAULT_GROUPS             16                  /**< Number of default value logical groups */
 
 #define FM_PCD_PRS_NUM_OF_LABELS                    32                  /**< Max number of SW parser label */
-#define FM_SW_PRS_SIZE                              0x00000800          /**< Total size of sw parser area */
-#define PRS_SW_OFFSET                               0x00000040          /**< Size of illegal addresses at the beginning
+#define FM_PCD_SW_PRS_SIZE                          0x00000800          /**< Total size of sw parser area */
+#define FM_PCD_PRS_SW_OFFSET                        0x00000040          /**< Size of illegal addresses at the beginning
                                                                              of the SW parser area */
-#define PRS_SW_TAIL_SIZE                            4                   /**< Number of bytes that must be cleared at
+#define FM_PCD_PRS_SW_TAIL_SIZE                     4                   /**< Number of bytes that must be cleared at
                                                                              the end of the SW parser area */
-#define FM_SW_PRS_MAX_IMAGE_SIZE                    (FM_SW_PRS_SIZE-PRS_SW_OFFSET-PRS_SW_TAIL_SIZE)
+#define FM_SW_PRS_MAX_IMAGE_SIZE                    (FM_PCD_SW_PRS_SIZE-FM_PCD_PRS_SW_OFFSET-FM_PCD_PRS_SW_TAIL_SIZE)
                                                                         /**< Max possible size of SW parser code */
 /* @} */
 
@@ -150,10 +150,10 @@ typedef enum e_FmPcdCounters {
  @Description   PCD interrupts
 *//***************************************************************************/
 typedef enum e_FmPcdExceptions {
-    e_FM_PCD_KG_ERR_EXCEPTION_DOUBLE_ECC,                   /**< Keygen ECC error */
-    e_FM_PCD_PLCR_ERR_EXCEPTION_DOUBLE_ECC,                 /**< Read Buffer ECC error */
-    e_FM_PCD_KG_ERR_EXCEPTION_KEYSIZE_OVERFLOW,             /**< Write Buffer ECC error on system side */
-    e_FM_PCD_PLCR_ERR_EXCEPTION_INIT_ENTRY_ERROR,           /**< Write Buffer ECC error on FM side */
+    e_FM_PCD_KG_EXCEPTION_DOUBLE_ECC,                   /**< Keygen ECC error */
+    e_FM_PCD_PLCR_EXCEPTION_DOUBLE_ECC,                 /**< Read Buffer ECC error */
+    e_FM_PCD_KG_EXCEPTION_KEYSIZE_OVERFLOW,             /**< Write Buffer ECC error on system side */
+    e_FM_PCD_PLCR_EXCEPTION_INIT_ENTRY_ERROR,           /**< Write Buffer ECC error on FM side */
     e_FM_PCD_PLCR_EXCEPTION_PRAM_SELF_INIT_COMPLETE,        /**< Self init complete */
     e_FM_PCD_PLCR_EXCEPTION_ATOMIC_ACTION_COMPLETE,         /**< Atomic action complete */
     e_FM_PCD_PRS_EXCEPTION_DOUBLE_ECC,                      /**< Parser ECC error */
@@ -164,28 +164,28 @@ typedef enum e_FmPcdExceptions {
 
 
 /**************************************************************************//**
- @Description   t_FmPcdExceptions - Exceptions user callback routine, will be called upon an
+ @Description   Exceptions user callback routine, will be called upon an
                 exception passing the exception identification.
 
  @Param[in]     h_App      - User's application descriptor.
  @Param[in]     exception  - The exception.
   *//***************************************************************************/
-typedef void (t_FmPcdException) ( t_Handle h_App, e_FmPcdExceptions exception);
+typedef void (t_FmPcdExceptionCallback) (t_Handle h_App, e_FmPcdExceptions exception);
 
 /**************************************************************************//**
- @Description   t_FmPcdSchemeErrorExceptionsCallback - Exceptions user callback routine,
-                will be called upon an exception passing the exception identification.
+ @Description   Exceptions user callback routine, will be called upon an exception
+                passing the exception identification.
 
  @Param[in]     h_App           - User's application descriptor.
  @Param[in]     exception       - The exception.
  @Param[in]     index           - id of the relevant source (may be scheme or profile id).
  *//***************************************************************************/
-typedef void (t_FmPcdIdException) ( t_Handle           h_App,
-                                    e_FmPcdExceptions  exception,
-                                    uint16_t           index);
+typedef void (t_FmPcdIdExceptionCallback) ( t_Handle           h_App,
+                                            e_FmPcdExceptions  exception,
+                                            uint16_t           index);
 
 /**************************************************************************//**
- @Description   t_FmPcdQmEnqueueCB - A callback for enquing frame onto a QM queue.
+ @Description   A callback for enquing frame onto a QM queue.
 
  @Param[in]     h_App           - User's application descriptor.
  @Param[in]     fqid            - Frame queue ID on which frame should be enqueued.
@@ -193,7 +193,7 @@ typedef void (t_FmPcdIdException) ( t_Handle           h_App,
 
  @Return        E_OK on success; Error code otherwise.
  *//***************************************************************************/
-typedef t_Error (t_FmPcdQmEnqueueCB) ( t_Handle h_QmArg, uint32_t fqid, void *p_Fd);
+typedef t_Error (t_FmPcdQmEnqueueCallback) ( t_Handle h_QmArg, uint32_t fqid, void *p_Fd);
 
 /**************************************************************************//**
  @Description   A structure for Host-Command
@@ -205,17 +205,17 @@ typedef t_Error (t_FmPcdQmEnqueueCB) ( t_Handle h_QmArg, uint32_t fqid, void *p_
  *//***************************************************************************/
 typedef struct t_FmPcdHcParams {
 #ifndef CONFIG_GUEST_PARTITION
-    uint64_t                portBaseAddr;       /**< Host-Command Port Virtual Address of
-                                                     memory mapped registers.*/
-    uint8_t                 portId;             /**< Host-Command Port Id (0-6 relative
-                                                     to Host-Command/Offline parsing ports) */
-    uint32_t                errFqid;            /**< Host-Command Port Error Queue Id. */
-    uint32_t                confFqid;           /**< Host-Command Port Confirmation queue Id. */
-    uint8_t                 deqSubPortal;       /**< Host-Command Port Subportal for dequeue. */
+    uint64_t                    portBaseAddr;       /**< Host-Command Port Virtual Address of
+                                                         memory mapped registers.*/
+    uint8_t                     portId;             /**< Host-Command Port Id (0-6 relative
+                                                         to Host-Command/Offline parsing ports) */
+    uint32_t                    errFqid;            /**< Host-Command Port Error Queue Id. */
+    uint32_t                    confFqid;           /**< Host-Command Port Confirmation queue Id. */
+    uint8_t                     deqSubPortal;       /**< Host-Command Port Subportal for dequeue. */
 #endif /* !CONFIG_GUEST_PARTITION */
-    uint32_t                enqFqid;            /**< Host-Command enqueue Queue Id. */
-    t_FmPcdQmEnqueueCB      *f_QmEnqueueCB;     /**< Call back routine for enquing a frame to the QM */
-    t_Handle                h_QmArg;            /**< A handle of the QM module */
+    uint32_t                    enqFqid;            /**< Host-Command enqueue Queue Id. */
+    t_FmPcdQmEnqueueCallback    *f_QmEnqueue;       /**< Call back routine for enquing a frame to the QM */
+    t_Handle                    h_QmArg;            /**< A handle of the QM module */
 } t_FmPcdHcParams;
 
 /**************************************************************************//**
@@ -243,8 +243,8 @@ typedef struct t_FmPcdParams {
     t_FmPcdHcParams             hc;                     /**< Host Command parameters */
 
 #ifndef CONFIG_GUEST_PARTITION
-    t_FmPcdException            *f_FmPcdException;      /**< Callback routine to be called of PCD exception */
-    t_FmPcdIdException          *f_FmPcdIdException;    /**< Callback routine to be used for a single scheme and
+    t_FmPcdExceptionCallback    *f_Exception;           /**< Callback routine to be called of PCD exception */
+    t_FmPcdIdExceptionCallback  *f_ExceptionId;         /**< Callback routine to be used for a single scheme and
                                                              profile exceptions */
     t_Handle                    h_App;                  /**< A handle to an application layer object; This handle will
                                                              be passed by the driver upon calling the above callbacks */
@@ -435,6 +435,7 @@ typedef struct t_FmPcdPrsSwParams {
                                                              umOfLabels entries */
 } t_FmPcdPrsSwParams;
 
+
 /**************************************************************************//**
  @Function      FM_PCD_Enable
 
@@ -587,7 +588,7 @@ t_Error FM_PCD_KgSetAdditionalDataAfterParsing(t_Handle h_FmPcd, uint8_t payload
 t_Error FM_PCD_SetException(t_Handle h_FmPcd, e_FmPcdExceptions exception, bool enable);
 
 /**************************************************************************//**
- @Function      FM_PCD_SetCounter
+ @Function      FM_PCD_ModifyCounter
 
  @Description   Sets a value to an enabled counter. Use "0" to reset the counter.
 
@@ -599,7 +600,7 @@ t_Error FM_PCD_SetException(t_Handle h_FmPcd, e_FmPcdExceptions exception, bool
 
  @Cautions      Allowed only following PCD_Init().
 *//***************************************************************************/
-t_Error FM_PCD_SetCounter(t_Handle h_FmPcd, e_FmPcdCounters counter, uint32_t value);
+t_Error FM_PCD_ModifyCounter(t_Handle h_FmPcd, e_FmPcdCounters counter, uint32_t value);
 
 /**************************************************************************//**
  @Function      FM_PCD_SetPlcrStatistics
@@ -615,7 +616,7 @@ t_Error FM_PCD_SetCounter(t_Handle h_FmPcd, e_FmPcdCounters counter, uint32_t va
 t_Error FM_PCD_SetPlcrStatistics(t_Handle h_FmPcd, bool enable);
 
 /**************************************************************************//**
- @Function      FM_PCD_PrsStatistics
+ @Function      FM_PCD_SetPrsStatistics
 
  @Description   Defines whether to gather parser statistics including all ports.
 
@@ -626,7 +627,7 @@ t_Error FM_PCD_SetPlcrStatistics(t_Handle h_FmPcd, bool enable);
 
  @Cautions      Allowed only following PCD_Init().
 *//***************************************************************************/
-void FM_PCD_PrsStatistics(t_Handle h_FmPcd, bool enable);
+void FM_PCD_SetPrsStatistics(t_Handle h_FmPcd, bool enable);
 #endif /* !CONFIG_GUEST_PARTITION */
 
 /**************************************************************************//**
@@ -699,6 +700,20 @@ t_Error FM_PCD_KgDumpRegs(t_Handle h_FmPcd);
 t_Error FM_PCD_PlcrDumpRegs(t_Handle h_FmPcd);
 
 /**************************************************************************//**
+ @Function      FM_PCD_PlcrDumpRegs
+
+ @Description   Dumps all PCD Plcr registers
+
+ @Param[in]     h_FmPcd         A handle to an FM PCD Module.
+ @Param[in]     h_Profile       A handle to a profile.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_Init().
+*//***************************************************************************/
+t_Error FM_PCD_PlcrProfileDumpRegs(t_Handle h_FmPcd, t_Handle h_Profile);
+
+/**************************************************************************//**
  @Function      FM_PCD_PrsDumpRegs
 
  @Description   Dumps all PCD Prs registers
@@ -763,12 +778,12 @@ uint32_t     FM_PCD_BackdoorGet(t_Handle h_FmPcd, e_ModuleId moduleId, uint32_t
                 parameters as required by keygen (when coarse classification
                 is the next engine after this scheme).
 *//***************************************************************************/
-#define         MAX_NUM_OF_PCD_CC_NODES     255
-#define         MAX_NUM_OF_PCD_CC_TREES     8
-#define         MAX_NUM_OF_PCD_CC_GROUPS    16
-#define         MAX_NUM_OF_CC_UNITS         4
-#define         MAX_NUM_OF_KEYS             256
-#define         MAX_SIZE_OF_KEY             56
+#define FM_PCD_MAX_NUM_OF_CC_NODES      255
+#define FM_PCD_MAX_NUM_OF_CC_TREES      8
+#define FM_PCD_MAX_NUM_OF_CC_GROUPS     16
+#define FM_PCD_MAX_NUM_OF_CC_UNITS      4
+#define FM_PCD_MAX_NUM_OF_KEYS          256
+#define FM_PCD_MAX_SIZE_OF_KEY          56
 /* @} */
 
 /**************************************************************************//**
@@ -836,7 +851,10 @@ typedef enum e_FmPcdExtractFrom {
     e_FM_PCD_EXTRACT_FROM_FRAME_START,          /**< Extract from beginning of frame */
     e_FM_PCD_KG_EXTRACT_FROM_DFLT_VALUE,        /**< Extract from a default value */
     e_FM_PCD_KG_EXTRACT_FROM_PARSE_RESULT,      /**< Extract from the parser result */
-    e_FM_PCD_KG_EXTRACT_FROM_CURR_END_OF_PARSE  /**< Extract from the point where parsing had finished */
+    e_FM_PCD_KG_EXTRACT_FROM_CURR_END_OF_PARSE, /**< Extract from the point where parsing had finished */
+    e_FM_PCD_EXTRACT_FROM_IC_KEY,               /**< Extract from Internal Context where extracted Key by Keygen is saved*/
+    e_FM_PCD_EXTRACT_FROM_IC_HASH_EXACT_MATCH,  /**< Extract from Internal Context where Hash Value calculated by Keygen is saved. Mechanism of the exact match by CC is used.*/
+    e_FM_PCD_EXTRACT_FROM_IC_HASH_INDEXED_MATCH /**< Extract from Internal Context where Hash Value calculated by Keygen is saved. Mechanism of the indexed match by CC is used.*/
 } e_FmPcdExtractFrom;
 
 /**************************************************************************//**
@@ -892,20 +910,20 @@ typedef enum e_FmPcdKgKnownFieldsDfltTypes {
  @Description   enum for defining header index when headers may repeat
 *//***************************************************************************/
 typedef enum e_FmPcdHdrIndex {
-    e_FM_PCD_HDR_INDEX_NONE     =   0,      /**< used when multiple headers not used, also
-                                                 to specify regular IP (not tunneled). */
-    e_FM_PCD_HDR_INDEX_1,                   /**< may be used for VLAN, MPLS, tunneled IP */
-    e_FM_PCD_HDR_INDEX_2,                   /**< may be used for MPLS, tunneled IP */
-    e_FM_PCD_HDR_INDEX_3,                   /**< may be used for MPLS */
-    e_FM_PCD_HDR_INDEX_LAST     =   0xFF    /**< may be used for VLAN, MPLS */
+    e_FM_PCD_HDR_INDEX_NONE = 0,        /**< used when multiple headers not used, also
+                                             to specify regular IP (not tunneled). */
+    e_FM_PCD_HDR_INDEX_1,               /**< may be used for VLAN, MPLS, tunneled IP */
+    e_FM_PCD_HDR_INDEX_2,               /**< may be used for MPLS, tunneled IP */
+    e_FM_PCD_HDR_INDEX_3,               /**< may be used for MPLS */
+    e_FM_PCD_HDR_INDEX_LAST = 0xFF      /**< may be used for VLAN, MPLS */
 } e_FmPcdHdrIndex;
 
 /**************************************************************************//**
  @Description   A structure for selcting the policer profile functional type
 *//***************************************************************************/
 typedef enum e_FmPcdProfileTypeSelection {
-    e_FM_PCD_PLCR_PORT_PRIVATE,             /**< Port dedicated profile */
-    e_FM_PCD_PLCR_SHARED                    /**< Shared profile (shared within partition) */
+    e_FM_PCD_PLCR_PORT_PRIVATE,         /**< Port dedicated profile */
+    e_FM_PCD_PLCR_SHARED                /**< Shared profile (shared within partition) */
 } e_FmPcdProfileTypeSelection;
 
 /**************************************************************************//**
@@ -970,7 +988,7 @@ typedef enum e_FmPcdPlcrDoneAction {
 } e_FmPcdPlcrDoneAction;
 
 /**************************************************************************//**
- @Description   A structure for selcting the policer counter
+ @Description   A structure for selecting the policer counter
 *//***************************************************************************/
 typedef enum e_FmPcdPlcrProfileCounters {
     e_FM_PCD_PLCR_PROFILE_GREEN_PACKET_TOTAL_COUNTER,               /**< Green packets counter */
@@ -980,7 +998,6 @@ typedef enum e_FmPcdPlcrProfileCounters {
     e_FM_PCD_PLCR_PROFILE_RECOLOURED_RED_PACKET_TOTAL_COUNTER       /**< Recolored red packets counter */
 } e_FmPcdPlcrProfileCounters;
 
-
 /**************************************************************************//**
  @Description   A Union of protocol dependent special options
 *//***************************************************************************/
@@ -1113,6 +1130,9 @@ typedef struct t_FmPcdKgKeyExtractAndHashParams {
     t_FmPcdExtractEntry         extractArray [FM_PCD_KG_MAX_NUM_OF_EXTRACTS_PER_KEY]; /**< An array of extractions definition. */
     uint8_t                     numOfUsedDflts;              /**< defines the valid size of the following array */
     t_FmPcdKgExtractDflt        dflts[FM_PCD_KG_NUM_OF_DEFAULT_GROUPS];
+                                                             /**< For each extraction used in this scheme, specify the required
+                                                                  default register to be used when header is not found.
+                                                                  types not specified in this array will get undefined value. */
     uint8_t                     numOfUsedMasks;              /**< defines the valid size of the following array */
     t_FmPcdKgExtractMask        masks[FM_PCD_KG_NUM_OF_EXTRACT_MASKS];
     uint8_t                     hashShift;                   /**< Select the 24 bits out of the 64 hash result */
@@ -1234,13 +1254,6 @@ typedef struct t_FmPcdKgSchemeParams {
     } kgNextEngineParams;
     t_FmPcdKgSchemeCounter              schemeCounter;          /**< IN: A strcucture of parameters for updating
                                                                      the scheme counter */
-    t_FmPcdKgKeyOrder                   orderedArray;           /**< OUT: A structure holding the order of the key extraction.
-                                                                     Relevant only is 'useHash' is TRUE. each value in this
-                                                                     array represents the index of the
-                                                                     extraction command as defined by the application in
-                                                                     the initialization extraction array.
-                                                                     The valid size of this array is the application define number of extractions
-                                                                     required (also marked by the second '0' in this array).*/
 } t_FmPcdKgSchemeParams;
 
 /**************************************************************************//**
@@ -1329,12 +1342,14 @@ typedef struct t_KeysParams {
                                                      the type FULL_FIELD keySize has to be as standard size of the relevant
                                                      key. In the another type of extraction keySize has to be as size of extraction. */
 
-    uint8_t                     *p_GlblMask;                /**< optional and can be initialized if:
-                                                                 keySize <=4 or  maskForKey is not initialized */
-    t_FmPcdCcKeyParams          keyParams[MAX_NUM_OF_KEYS];               /**< it's array with numOfKeys entries each entry in
-                                                                 the array of the type t_FmPcdCcKeyParams */
-    t_FmPcdCcNextEngineParams   ccNextEngineParamsForMiss;  /**< parameters for the next step of
-                                                                 unfound (or undefined)  key */
+    uint8_t                     *p_GlblMask;    /**< optional and can be initialized if:
+                                                     keySize <=4 or  maskForKey is not initialized */
+    t_FmPcdCcKeyParams          keyParams[FM_PCD_MAX_NUM_OF_KEYS];
+                                                /**< it's array with numOfKeys entries each entry in
+                                                     the array of the type t_FmPcdCcKeyParams */
+    t_FmPcdCcNextEngineParams   ccNextEngineParamsForMiss;
+                                                /**< parameters for the next step of
+                                                      unfound (or undefined)  key */
 } t_KeysParams;
 
 /**************************************************************************//**
@@ -1367,20 +1382,21 @@ typedef struct t_FmPcdCcNodeParams {
                                                         unit 1 - found; unit 3 - found;
 *//***************************************************************************/
 typedef struct t_FmPcdCcGrpParams {
-        uint8_t                     numOfDistinctionUnits;          /**< up to 4 */
-        uint8_t                     unitIds[MAX_NUM_OF_CC_UNITS];   /**< Indexes of the units as defined in
-                                                                         FM_PCD_SetNetEnvCharacteristics() */
-        t_FmPcdCcNextEngineParams   *p_NextEnginePerEntriesInGrp;   /**< Max size is 16 - if only one group used */
+    uint8_t                     numOfDistinctionUnits;          /**< up to 4 */
+    uint8_t                     unitIds[FM_PCD_MAX_NUM_OF_CC_UNITS];
+                                                                /**< Indexes of the units as defined in
+                                                                     FM_PCD_SetNetEnvCharacteristics() */
+    t_FmPcdCcNextEngineParams   *p_NextEnginePerEntriesInGrp;   /**< Max size is 16 - if only one group used */
 } t_FmPcdCcGrpParams;
 
 /**************************************************************************//**
  @Description   A structure for defining the CC tree groups
 *//***************************************************************************/
 typedef struct t_FmPcdCcTreeParams {
-        t_Handle                h_NetEnv;                               /**< A handle to the Network environment as returned
+    t_Handle                h_NetEnv;                                   /**< A handle to the Network environment as returned
                                                                              by FM_PCD_SetNetEnvCharacteristics() */
-        uint8_t                 numOfGrps;                              /**< Number of CC groups within the CC tree */
-        t_FmPcdCcGrpParams      ccGrpParams[MAX_NUM_OF_PCD_CC_GROUPS];  /**< Parameters for each group. */
+    uint8_t                 numOfGrps;                                  /**< Number of CC groups within the CC tree */
+    t_FmPcdCcGrpParams      ccGrpParams[FM_PCD_MAX_NUM_OF_CC_GROUPS];   /**< Parameters for each group. */
 } t_FmPcdCcTreeParams;
 
 /**************************************************************************//**
@@ -1417,9 +1433,9 @@ typedef struct t_FmPcdPlcrNonPassthroughAlgParams {
     e_FmPcdPlcrRateMode              rateMode;                       /**< Byte / Packet */
     t_FmPcdPlcrByteRateModeParams    byteModeParams;                 /**< Valid for Byte NULL for Packet */
     uint32_t                         comittedInfoRate;               /**< KBits/Sec or Packets/Sec */
-    uint32_t                         comittedBurstSize;              /**< KBits or Packets */
+    uint32_t                         comittedBurstSize;              /**< Bytes/Packets */
     uint32_t                         peakOrAccessiveInfoRate;        /**< KBits/Sec or Packets/Sec */
-    uint32_t                         peakOrAccessiveBurstSize;       /**< KBits or Packets */
+    uint32_t                         peakOrAccessiveBurstSize;       /**< Bytes/Packets */
 } t_FmPcdPlcrNonPassthroughAlgParams;
 
 /**************************************************************************//**
@@ -1433,7 +1449,7 @@ typedef union u_FmPcdPlcrNextEngineParams {
 } u_FmPcdPlcrNextEngineParams;
 
 /**************************************************************************//**
- @Description   A structure for selcting the policer profile entry parameters
+ @Description   A structure for selecting the policer profile entry parameters
 *//***************************************************************************/
 typedef struct t_FmPcdPlcrProfileParams {
     bool                                modify;                     /**< TRUE to change an existing profile */
@@ -1883,4 +1899,5 @@ t_Error FM_PCD_PlcrSetProfileCounter(t_Handle h_FmPcd, t_Handle h_Profile, e_FmP
 /** @} */ /* end of FM_PCD_grp group */
 /** @} */ /* end of FM_grp group */
 
+
 #endif /* __FM_PCD_EXT */
diff --git a/drivers/net/dpa/NetCommSw/inc/Peripherals/fm_port_ext.h b/drivers/net/dpa/NetCommSw/inc/Peripherals/fm_port_ext.h
index df236ca..b3452f3 100644
--- a/drivers/net/dpa/NetCommSw/inc/Peripherals/fm_port_ext.h
+++ b/drivers/net/dpa/NetCommSw/inc/Peripherals/fm_port_ext.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -86,7 +86,7 @@
                 frame headers and payload.
 *//***************************************************************************/
 typedef enum e_FmPortPcdSupport {
-    e_FM_PORT_PCD_SUPPORT_NONE,                 /**< BMI to BMI, PCD is not used */
+    e_FM_PORT_PCD_SUPPORT_NONE = 0,             /**< BMI to BMI, PCD is not used */
     e_FM_PORT_PCD_SUPPORT_PRS_ONLY,             /**< Use only Parser */
     e_FM_PORT_PCD_SUPPORT_PLCR_ONLY,            /**< Use only Policer */
     e_FM_PORT_PCD_SUPPORT_PRS_AND_PLCR,         /**< Use Parser and Policer */
@@ -97,11 +97,20 @@ typedef enum e_FmPortPcdSupport {
 } e_FmPortPcdSupport;
 
 /**************************************************************************//**
+ @Description   Port interrupts
+*//***************************************************************************/
+typedef enum e_FmPortExceptions {
+    e_FM_PORT_EXCEPTION_PRS_ILLEGAL_ACCESS = 0,         /**< Parser port illegal access */
+    e_FM_PORT_EXCEPTION_IM_BUSY                         /**< Independent-Mode Rx-BSUY */
+} e_FmPortExceptions;
+
+
+/**************************************************************************//**
  @Collection    General FM Port defines
 *//***************************************************************************/
-#define PRS_RESULT_NUM_OF_WORDS             8           /**< Number of 4 bytes words in parser result */
+#define BM_MAX_NUM_OF_EXT_POOLS             64          /**< Total number of external BM pools */
+#define FM_PORT_PRS_RESULT_NUM_OF_WORDS     8           /**< Number of 4 bytes words in parser result */
 #define FM_PORT_MAX_NUM_OF_EXT_POOLS        8           /**< Number of external BM pools per Rx port */
-#define MAX_NUM_OF_EXT_POOLS                64          /**< Total number of external BM pools */
 #define FM_PORT_NUM_OF_CONGESTION_GRPS      256         /**< Total number of congestion groups in QM */
 /* @} */
 
@@ -113,6 +122,14 @@ typedef enum e_FmPortPcdSupport {
 
  @{
 *//***************************************************************************/
+/**************************************************************************//**
+ @Description   Exceptions user callback routine, will be called upon an
+                exception passing the exception identification.
+
+ @Param[in]     h_App      - User's application descriptor.
+ @Param[in]     exception  - The exception.
+  *//***************************************************************************/
+typedef void (t_FmPortExceptionCallback) (t_Handle h_App, e_FmPortExceptions exception);
 
 /**************************************************************************//**
  @Description   User callback function called by driver with recieve data.
@@ -131,7 +148,7 @@ typedef enum e_FmPortPcdSupport {
                                                operation for all ready data.
  @Retval        e_RX_STORE_RESPONSE_PAUSE    - order the driver to stop Rx operation.
 *//***************************************************************************/
-typedef e_RxStoreResponse (t_FmPortImRxStoreFunction) (t_Handle h_App,
+typedef e_RxStoreResponse (t_FmPortImRxStoreCallback) (t_Handle h_App,
                                                        uint8_t  *p_Data,
                                                        uint16_t length,
                                                        uint16_t status,
@@ -150,7 +167,7 @@ typedef e_RxStoreResponse (t_FmPortImRxStoreFunction) (t_Handle h_App,
  @Param[in]     lastBuffer      is last buffer in frame
  @Param[in]     h_BufContext    A handle of the user acossiated with this buffer
  *//***************************************************************************/
-typedef void (t_FmPortImTxConfFunction) (t_Handle   h_App,
+typedef void (t_FmPortImTxConfCallback) (t_Handle   h_App,
                                          uint8_t    *p_Data,
                                          uint16_t   status,
                                          t_Handle   h_BufContext);
@@ -180,7 +197,7 @@ typedef struct t_FmPortRxExtPools {
 typedef struct t_FmPortRxParams {
     uint32_t                errFqid;            /**< Error Queue Id. */
     uint32_t                dfltFqid;           /**< Default Queue Id.  */
-    uint8_t                 rxPartitionId;      /**< Port's partition id. */
+    uint16_t                rxPartitionId;      /**< Port's partition id. */
     t_FmPortRxExtPools      rxExtBufPools;      /**< Which external buffer pools are used
                                                      (up to 8), and their sizes. */
 } t_FmPortRxParams;
@@ -194,9 +211,9 @@ typedef struct t_FmPortNonRxParams {
                                                      0 means no Tx confirmation for processed
                                                      frames. For OP - default Rx queue. */
     uint8_t                 deqSubPortal;       /**< Subportal for dequeue. */
-#ifdef FM_OP_PARTITION_ERRATA
-    uint8_t                 opPartitionId;      /**< For Offline Parsing ports only. Port's partition id. */
-#endif  /* FM_OP_PARTITION_ERRATA */
+#ifdef FM_OP_PARTITION_ERRATA_FMAN16
+    uint16_t                opPartitionId;      /**< For Offline Parsing ports only. Port's partition id. */
+#endif  /* FM_OP_PARTITION_ERRATA_FMAN16 */
 } t_FmPortNonRxParams;
 
 /**************************************************************************//**
@@ -204,36 +221,38 @@ typedef struct t_FmPortNonRxParams {
 *//***************************************************************************/
 typedef struct t_FmPortImRxTxParams {
     t_Handle                    h_FmMuram;          /**< A handle of the FM-MURAM partition */
-    uint8_t                     partitionId;        /**< For Rx ports only. Port's partition id. */
+    uint16_t                    partitionId;        /**< For Rx ports only. Port's partition id. */
     uint8_t                     dataMemId;          /**< Memory partition ID for data buffers */
     uint32_t                    dataMemAttributes;  /**< Memory attributes for data buffers */
     t_BufferPoolInfo            rxPoolParams;       /**< For Rx ports only. */
-    t_FmPortImRxStoreFunction   *f_RxStoreCB;       /**< For Rx ports only. */
-    t_FmPortImTxConfFunction    *f_TxConfCB;        /**< For Tx ports only. */
-    t_Handle                    h_App;              /**< A handle to an application layer object; This handle will
-                                                         be passed by the driver upon calling the above callbacks */
+    t_FmPortImRxStoreCallback   *f_RxStore;         /**< For Rx ports only. */
+    t_FmPortImTxConfCallback    *f_TxConf;          /**< For Tx ports only. */
 } t_FmPortImRxTxParams;
 
 /**************************************************************************//**
  @Description   Union for additional parameters depending on port type
 *//***************************************************************************/
 typedef union u_FmPortSpecificParams {
-    t_FmPortImRxTxParams    imRxTxParams;       /**< Rx/Tx Independent-Mode port parameter structure */
-    t_FmPortRxParams        rxParams;           /**< Rx port parameters structure */
-    t_FmPortNonRxParams     nonRxParams;        /**< Non-Rx port parameters structure */
+    t_FmPortImRxTxParams        imRxTxParams;       /**< Rx/Tx Independent-Mode port parameter structure */
+    t_FmPortRxParams            rxParams;           /**< Rx port parameters structure */
+    t_FmPortNonRxParams         nonRxParams;        /**< Non-Rx port parameters structure */
 } u_FmPortSpecificParams;
 
 /**************************************************************************//**
  @Description   structure representing FM initialization parameters
 *//***************************************************************************/
 typedef struct t_FmPortParams {
-    uint64_t                baseAddr;           /**< Virtual Address of memory mapped FM Port registers.*/
-    t_Handle                h_Fm;               /**< A handle to the FM object this port related to */
-    e_FmPortType            portType;           /**< Port type */
-    uint8_t                 portId;             /**< Port Id - relative to type */
-    bool                    independentModeEnable;  /**< This port is Independent-Mode - Used for Rx/Tx ports only! */
-    u_FmPortSpecificParams  specificParams;     /**< Additional parameters depending on port
-                                                     type. */
+    uint64_t                    baseAddr;           /**< Virtual Address of memory mapped FM Port registers.*/
+    t_Handle                    h_Fm;               /**< A handle to the FM object this port related to */
+    e_FmPortType                portType;           /**< Port type */
+    uint8_t                     portId;             /**< Port Id - relative to type */
+    bool                        independentModeEnable;/**< This port is Independent-Mode - Used for Rx/Tx ports only! */
+    u_FmPortSpecificParams      specificParams;     /**< Additional parameters depending on port
+                                                         type. */
+
+    t_FmPortExceptionCallback   *f_Exception;       /**< Callback routine to be called of PCD exception */
+    t_Handle                    h_App;              /**< A handle to an application layer object; This handle will
+                                                         be passed by the driver upon calling the above callbacks */
 } t_FmPortParams;
 
 
@@ -358,12 +377,12 @@ typedef struct t_FmPortBufPoolDepletion {
                                                          a number of pools are depleted */
     uint8_t     numOfPools;                         /**< the minimum number of depleted pools that will
                                                          invoke pause frames transmission. */
-    bool        poolsToConsider[MAX_NUM_OF_EXT_POOLS];
+    bool        poolsToConsider[BM_MAX_NUM_OF_EXT_POOLS];
                                                     /**< For each pool, TRUE if it should be considered for
                                                          deplition (Note - this pool must be used by this port!) */
     bool        singlePoolModeEnable;               /**< select mode in which pause frames will be sent after
                                                          a single of pools are depleted */
-    bool        poolsToConsiderForSingleMode[MAX_NUM_OF_EXT_POOLS];
+    bool        poolsToConsiderForSingleMode[BM_MAX_NUM_OF_EXT_POOLS];
                                                     /**< For each pool, TRUE if it should be considered for
                                                          deplition (Note - this pool must be used by this port!) */
 } t_FmPortBufPoolDepletion;
@@ -374,9 +393,8 @@ typedef struct t_FmPortBufPoolDepletion {
 typedef struct t_FmPortRateLimit {
     uint16_t    maxBurstSize;           /**< in KBytes */
     uint32_t    rateLimit;              /**< in Kb/sec for Tx ports, in frame/sec for
-                                             offline parsing ports. Rate limit will
-                                             be rounded down to the nearest
-                                             16*TimeStampPeriod multiplication. */
+                                             offline parsing ports. Rate limit refers to
+                                             data rate (rather than line rate). */
 } t_FmPortRateLimit;
 
 /**************************************************************************//**
@@ -399,8 +417,18 @@ typedef struct t_FmPortBufferPrefixContent {
                                                  of the external buffer */
     bool        passPrsResult;              /**< TRUE to pass the parse result to/from the FM */
     bool        passTimeStamp;              /**< TRUE to pass the timeStamp to/from the FM */
+    bool        passHashResult;             /**< TRUE to pass the KG hash result to/from the FM */
+    bool        passAllOtherPCDInfo;        /**< Add all other Internal-Context information:
+                                                 AD, hash-result, key, etc.  */
+    uint16_t    dataAlign;                  /**< 0 to use driver's default alignment, other value
+                                                 for selecting a data alignment (must be a
+                                                 power of 2) */
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+    bool        passDebugInfo;                  /**< Debug */
+#endif /* (defined(DEBUG_ERRORS) && ... */
 } t_FmPortBufferPrefixContent;
 
+
 /**************************************************************************//**
  @Function      FM_PORT_ConfigNumOfOpenDmas
 
@@ -461,8 +489,6 @@ t_Error FM_PORT_ConfigSizeOfFifo(t_Handle h_FmPort, t_FmPortRsrc *p_SizeOfFifo);
                 internal driver data base from its default configuration
                 [DEFAULT_PORT_deqHighPriority]
 
-
-
                 May be used for Non-Rx ports only
 
  @Param[in]     h_FmPort    A handle to a FM Port module.
@@ -481,7 +507,6 @@ t_Error FM_PORT_ConfigDeqHighPriority(t_Handle h_FmPort, bool highPri);
                 internal driver data base from its default configuration
                 [DEFAULT_PORT_deqType].
 
-
                 May be used for Non-Rx ports only
 
  @Param[in]     h_FmPort    A handle to a FM Port module.
@@ -863,31 +888,13 @@ t_Error FM_PORT_ConfigDmaHdrAttr(t_Handle h_FmPort, e_FmPortDmaCache headerCache
 t_Error FM_PORT_ConfigDmaScatterGatherAttr(t_Handle h_FmPort, e_FmPortDmaCache scatterGatherCacheAttr);
 
 /**************************************************************************//**
- @Function      FM_PORT_ConfigDmaReadOptimize
-
- @Description   Calling this routine changes the read optimization
-                parameter in the internal driver data base
-                from its default configuration:  optimize = [DEFAULT_PORT_dmaReadOptimize]
-
-                May be used for all port types
-
- @Param[in]     h_FmPort    A handle to a FM Port module.
- @Param[in]     optimize    TRUE to enable optimization, FALSE for normal operation
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
-*//***************************************************************************/
-t_Error FM_PORT_ConfigDmaReadOptimize(t_Handle h_FmPort, bool optimize);
-
-/**************************************************************************//**
  @Function      FM_PORT_ConfigDmaWriteOptimize
 
  @Description   Calling this routine changes the write optimization
                 parameter in the internal driver data base
                 from its default configuration:  optimize = [DEFAULT_PORT_dmaWriteOptimize]
 
-                May be used for all port types
+                May be used for non-Tx port types
 
  @Param[in]     h_FmPort    A handle to a FM Port module.
  @Param[in]     optimize    TRUE to enable optimization, FALSE for normal operation
@@ -978,7 +985,8 @@ t_Error FM_PORT_ConfigRxL4ChecksumVerify(t_Handle h_FmPort, bool l4Checksum);
  @Function      FM_PORT_ConfigIMMaxRxBufLength
 
  @Description   Changes the maximum receive buffer length from its default
-                configuration: [DEFAULT_PORT_ImMaxRxBufLength]
+                configuration: Closest rounded down power of 2 value of the
+                data buffer size.
 
                 The maximum receive buffer length directly affects the structure
                 of received frames (single- or multi-buffered) and the performance
@@ -1117,6 +1125,38 @@ t_Error FM_PORT_DumpRegs(t_Handle h_FmPort);
 uint32_t FM_PORT_GetBufferDataOffset(t_Handle h_FmPort);
 
 /**************************************************************************//**
+ @Function      FM_PORT_GetBufferICInfo
+
+ @Description   Returns the Internal Context offset from the begining of the data buffer
+
+ @Param[in]     h_FmPort - FM PORT module descriptor
+ @Param[in]     p_Data      - A pointer to the data buffer.
+
+ @Return        Internal context info pointer on success, NULL if 'allOtherInfo' was not
+                configured for this port.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+uint8_t * FM_PORT_GetBufferICInfo(t_Handle h_FmPort, char *p_Data);
+
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+/**************************************************************************//**
+ @Function      FM_PORT_GetBufferDebugInfo
+
+ @Description   Returns the debug info offset from the begining of the data buffer
+
+ @Param[in]     h_FmPort - FM PORT module descriptor
+ @Param[in]     p_Data      - A pointer to the data buffer.
+
+ @Return        Debug info pointer on success, NULL if 'passDebugInfo' was not
+                configured for this port.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+uint8_t * FM_PORT_GetBufferDebugInfo(t_Handle h_FmPort, char *p_Data);
+#endif /*(defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))*/
+
+/**************************************************************************//**
  @Function      FM_PORT_GetBufferPrsResult
 
  @Description   Returns the pointer to the parse result in the data buffer.
@@ -1141,24 +1181,37 @@ t_FmPrsResult * FM_PORT_GetBufferPrsResult(t_Handle h_FmPort, char *p_Data);
 /**************************************************************************//**
  @Function      FM_PORT_GetBufferTimeStamp
 
- @Description   Returns the pointer to the time stamp in the data buffer.
-                In Rx ports this is relevant after reception, if parse
-                result is configured to be part of the data passed to the
-                application. For non Rx ports it may be used to get the pointer
-                of the area in the buffer where time stamp should be
-                initialized - if so configured.
+ @Description   Returns the time stamp in the data buffer.
+                Relevant for Rx ports for getting the buffer time stamp.
                 See FM_PORT_ConfigBufferPrefixContent for data buffer prefix
                 configuration.
 
  @Param[in]     h_FmPort    - FM PORT module descriptor
  @Param[in]     p_Data      - A pointer to the data buffer.
+ @Param[out]    p_Ts        - A pointer to 64 bit time stamp.
 
- @Return        Time stamp pointer on success, NULL if time stamp was not
-                configured for this port.
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_GetBufferTimeStamp(t_Handle h_FmPort, char *p_Data, uint64_t *p_Ts);
+
+/**************************************************************************//**
+ @Function      FM_PORT_GetBufferHashResult
+
+ @Description   Given a data buffer, on the condition that hash result was defined
+                as a part of the buffer content (see FM_PORT_ConfigBufferPrefixContent)
+                this routine will return the pointer to the hash result location in the
+                buffer prefix.
+
+ @Param[in]     h_FmPort    - FM PORT module descriptor
+ @Param[in]     p_Data      - A pointer to the data buffer.
+
+ @Return        A pointer to the hash result on success, NULL otherwise.
 
  @Cautions      Allowed only following FM_PORT_Init().
 *//***************************************************************************/
-t_FmTimeStamp * FM_PORT_GetBufferTimeStamp(t_Handle h_FmPort, char *p_Data);
+uint8_t * FM_PORT_GetBufferHashResult(t_Handle h_FmPort, char *p_Data);
 
 /**************************************************************************//**
  @Function      FM_PORT_Disable
@@ -1175,7 +1228,7 @@ t_FmTimeStamp * FM_PORT_GetBufferTimeStamp(t_Handle h_FmPort, char *p_Data);
                 gracefully stopped, i.e. the port will not except new frames,
                 but it will finish all frames or tasks which were already began
 *//***************************************************************************/
-void FM_PORT_Disable(t_Handle h_FmPort);
+t_Error FM_PORT_Disable(t_Handle h_FmPort);
 
 /**************************************************************************//**
  @Function      FM_PORT_Enable
@@ -1188,7 +1241,7 @@ void FM_PORT_Disable(t_Handle h_FmPort);
 
  @Cautions      Allowed only following FM_PORT_Init().
 *//***************************************************************************/
-void FM_PORT_Enable(t_Handle h_FmPort);
+t_Error FM_PORT_Enable(t_Handle h_FmPort);
 
 /**************************************************************************//**
  @Function      FM_PORT_SetStatisticsCounters
@@ -1228,21 +1281,36 @@ t_Error FM_PORT_SetFrameQueueCounters(t_Handle h_FmPort, bool enable);
  @Function      FM_PORT_SetPerformanceCounters
 
  @Description   Calling this routine enables/disables port's performance counters.
-                By default, counters are disabled.
+                By default, counters are enabled.
 
                 May be used for all port types
 
  @Param[in]     h_FmPort                A handle to a FM Port module.
- @Param[in]     p_FmPortPerformanceCnt  A structure of performance counters parameters.
-                                        Note that `queueCompVal` is used only by Rx ports
-                                        and Tx ports with confirmation queue.
  @Param[in]     enable                  TRUE to enable, FALSE to disable.
 
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_PORT_Init().
 *//***************************************************************************/
-t_Error FM_PORT_SetPerformanceCounters(t_Handle h_FmPort, t_FmPortPerformanceCnt *p_FmPortPerformanceCnt, bool enable);
+t_Error FM_PORT_SetPerformanceCounters(t_Handle h_FmPort, bool enable);
+
+/**************************************************************************//**
+ @Function      FM_PORT_SetPerformanceCounters
+
+ @Description   Calling this routine defines port's performance
+                counters parameters.
+
+                May be used for all port types
+
+ @Param[in]     h_FmPort                A handle to a FM Port module.
+ @Param[in]     p_FmPortPerformanceCnt  A pointer to a structure of performance
+                                        counters parameters.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_SetPerformanceCountersParams(t_Handle h_FmPort, t_FmPortPerformanceCnt *p_FmPortPerformanceCnt);
 
 /**************************************************************************//**
  @Function      FM_PORT_SetAllocBufCounter
@@ -1261,7 +1329,7 @@ t_Error FM_PORT_SetPerformanceCounters(t_Handle h_FmPort, t_FmPortPerformanceCnt
 
  @Cautions      Allowed only following FM_PORT_Init().
 *//***************************************************************************/
-t_Error FM_PORT_SetEnAllocBufCounter(t_Handle h_FmPort, uint8_t poolId, bool enable);
+t_Error FM_PORT_SetAllocBufCounter(t_Handle h_FmPort, uint8_t poolId, bool enable);
 
 /**************************************************************************//**
  @Function      FM_PORT_GetCounter
@@ -1281,19 +1349,19 @@ t_Error FM_PORT_SetEnAllocBufCounter(t_Handle h_FmPort, uint8_t poolId, bool ena
 uint32_t FM_PORT_GetCounter(t_Handle h_FmPort, e_FmPortCounters fmPortCounter);
 
 /**************************************************************************//**
- @Function      FM_PORT_SetCounter
+ @Function      FM_PORT_ModifyCounter
 
  @Description   Sets a value to an enabled counter. Use "0" to reset the counter.
 
  @Param[in]     h_FmPort            A handle to a FM Port module.
  @Param[in]     fmPortCounter       The requested counter.
- @Param[in]     value                 The requested value to be written into the counter.
+ @Param[in]     value               The requested value to be written into the counter.
 
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_PORT_Init().
 *//***************************************************************************/
-t_Error FM_PORT_SetCounter(t_Handle h_FmPort, e_FmPortCounters fmPortCounter, uint32_t value);
+t_Error FM_PORT_ModifyCounter(t_Handle h_FmPort, e_FmPortCounters fmPortCounter, uint32_t value);
 
 /**************************************************************************//**
  @Function      FM_PORT_GetAllocBufCounter
@@ -1313,7 +1381,7 @@ t_Error FM_PORT_SetCounter(t_Handle h_FmPort, e_FmPortCounters fmPortCounter, ui
 uint32_t FM_PORT_GetAllocBufCounter(t_Handle h_FmPort, uint8_t poolId);
 
 /**************************************************************************//**
- @Function      FM_PORT_SetAllocBufCounter
+ @Function      FM_PORT_ModifyAllocBufCounter
 
  @Description   Sets a value to an enabled counter. Use "0" to reset the counter.
 
@@ -1325,7 +1393,7 @@ uint32_t FM_PORT_GetAllocBufCounter(t_Handle h_FmPort, uint8_t poolId);
 
  @Cautions      Allowed only following FM_PORT_Init().
 *//***************************************************************************/
-t_Error FM_PORT_SetAllocBufCounter(t_Handle h_FmPort,  uint8_t poolId, uint32_t value);
+t_Error FM_PORT_ModifyAllocBufCounter(t_Handle h_FmPort,  uint8_t poolId, uint32_t value);
 
 /**************************************************************************//**
  @Function      FM_PORT_AddCongestionGrps
@@ -1564,8 +1632,8 @@ typedef struct t_FmPortPcdKgParams {
 *//***************************************************************************/
 typedef struct t_FmPortPcdPlcrParams {
     t_Handle                h_Profile;          /**< Selected profile handle. relevant only if
-                                                     e_FM_PCD_SUPPORT_PLCR_ONLY or
-                                                     e_FM_PCD_SUPPORT_PRS_AND_PLCR were selected */
+                                                     e_FM_PORT_PCD_SUPPORT_PLCR_ONLY or
+                                                     e_FM_PORT_PCD_SUPPORT_PRS_AND_PLCR were selected */
 } t_FmPortPcdPlcrParams;
 
 /**************************************************************************//**
@@ -1581,6 +1649,16 @@ typedef struct t_FmPortPcdParams {
     t_FmPortPcdPlcrParams   *p_PlcrParams;      /**< Policer parameters for this port */
 } t_FmPortPcdParams;
 
+/**************************************************************************//**
+ @Description   A structure for defining the Parser starting point
+*//***************************************************************************/
+typedef struct t_FmPcdPrsStart {
+    uint8_t             parsingOffset;  /**< Number of bytes from begining of packet to
+                                             start parsing */
+    e_NetHeaderType     firstPrsHdr;    /**< The type of the first header axpected at
+                                             'parsingOffset' */
+} t_FmPcdPrsStart;
+
 
 /**************************************************************************//**
  @Function      FM_PORT_SetPCD
@@ -1705,10 +1783,11 @@ t_Error          FM_PORT_PcdKgModifyInitialScheme (t_Handle h_FmPort, t_FmPcdKgS
 /**************************************************************************//**
  @Function      FM_PORT_PcdPlcrModifyInitialProfile
 
- @Description   This routine may be called for ports with flows e_FM_PCD_SUPPORT_PLCR_ONLY or
-                e_FM_PCD_SUPPORT_PRS_AND_PLCR  only, to change the initial Policer profile frame
-                should be routed to. The change may be of a profile and/or absolute/direct mode
-                selection.
+ @Description   This routine may be called for ports with flows
+                e_FM_PORT_PCD_SUPPORT_PLCR_ONLY or e_FM_PORT_PCD_SUPPORT_PRS_AND_PLCR
+                only, to change the initial Policer profile frame should be
+                routed to. The change may be of a profile and/or absolute/direct
+                mode selection.
 
  @Param[in]     h_FmPort                A handle to a FM Port module.
  @Param[in]     h_Profile               Policer profile handle
@@ -1744,7 +1823,7 @@ t_Error          FM_PORT_PcdCcModifyTree (t_Handle h_FmPort, t_Handle h_CcTree);
                 if the user wishes to replace the classification plan
                 group that the port uses, to start using the classification plan mechanism or to stop
                 using it. The routine may not be called while port
-                receives packets using the PCD functionalities, therefor port must be first detached
+                receives packets using the PCD functionalities, therefore port must be first detached
                 from the PCD, only than the routine may be called, and than port be attached to PCD again.
 
  @Param[in]     h_FmPort            A handle to a FM Port module.
@@ -1791,27 +1870,19 @@ t_Error      FM_PORT_PcdKgBindSchemes (t_Handle h_FmPort, t_FmPcdPortSchemesPara
 t_Error      FM_PORT_PcdKgUnbindSchemes (t_Handle h_FmPort, t_FmPcdPortSchemesParams *p_PortScheme);
 
 /**************************************************************************//**
- @Description   A structure for defining the Parser starting point
-*//***************************************************************************/
-typedef struct t_FmPcdPrsStart {
-    uint8_t             parsingOffset;  /**< Number of bytes from begining of packet to
-                                             start parsing */
-    e_NetHeaderType     firstPrsHdr;    /**< The type of the first header axpected at
-                                             'parsingOffset' */
-} t_FmPcdPrsStart;
-
-/**************************************************************************//**
  @Function      FM_PORT_PcdPrsModifyStartOffset
 
  @Description   Runtime change of the parser start offset within the header.
-
+                The routine may not be called while port
+                receives packets using the PCD functionalities, therefore port must be first detached
+                from the PCD, only than the routine may be called, and than port be attached to PCD again.
  @Param[in]     h_FmPort        A handle to a FM Port module.
  @Param[in]     p_FmPcdPrsStart A structure of parameters for defining the
                                 start point for the parser.
 
  @Return        E_OK on success; Error code otherwise.
 
- @Cautions      Allowed only following FM_PORT_Init() and FM_PORT_SetPCD().
+ @Cautions      Allowed only following FM_PORT_Init(), FM_PORT_SetPCD() and FM_PORT_DetatchPCD().
 *//***************************************************************************/
 t_Error      FM_PORT_PcdPrsModifyStartOffset (t_Handle h_FmPort, t_FmPcdPrsStart *p_FmPcdPrsStart);
 
@@ -1890,4 +1961,5 @@ t_Error  FM_PORT_ImRx(t_Handle h_FmPort);
 /** @} */ /* end of FM_PORT_grp group */
 /** @} */ /* end of FM_grp group */
 
+
 #endif /* __FM_PORT_EXT */
diff --git a/drivers/net/dpa/NetCommSw/inc/Peripherals/fm_rtc_ext.h b/drivers/net/dpa/NetCommSw/inc/Peripherals/fm_rtc_ext.h
new file mode 100644
index 0000000..988e3fc
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/inc/Peripherals/fm_rtc_ext.h
@@ -0,0 +1,558 @@
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**************************************************************************//**
+ @File          fm_rtc_ext.h
+
+ @Description   External definitions and API for FM RTC IEEE1588 Timer Module.
+
+ @Cautions      None.
+*//***************************************************************************/
+
+#ifndef __FM_RTC_EXT_H__
+#define __FM_RTC_EXT_H__
+
+
+/**************************************************************************//**
+ @Group         FM_grp Frame Manager API
+
+ @Description   FM API functions, definitions and enums
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Group         fm_rtc_grp FM RTC
+
+ @Description   FM RTC functions, definitions and enums.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Group         fm_rtc_init_grp FM RTC Initialization Unit
+
+ @Description   FM RTC initialization API.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description   FM RTC Alarm Polarity Options.
+*//***************************************************************************/
+typedef enum e_FmRtcAlarmPolarity
+{
+    e_FM_RTC_ALARM_POLARITY_ACTIVE_HIGH,    /**< Active-high output polarity */
+    e_FM_RTC_ALARM_POLARITY_ACTIVE_LOW      /**< Active-low output polarity */
+} e_FmRtcAlarmPolarity;
+
+/**************************************************************************//**
+ @Description   FM RTC Trigger Polarity Options.
+*//***************************************************************************/
+typedef enum e_FmRtcTriggerPolarity
+{
+    e_FM_RTC_TRIGGER_ON_RISING_EDGE,    /**< Trigger on rising edge */
+    e_FM_RTC_TRIGGER_ON_FALLING_EDGE    /**< Trigger on falling edge */
+} e_FmRtcTriggerPolarity;
+
+/**************************************************************************//**
+ @Description   IEEE1588 Timer Module FM RTC Optional Clock Sources.
+*//***************************************************************************/
+typedef enum e_FmSrcClock
+{
+    e_FM_RTC_SOURCE_CLOCK_EXTERNAL,  /**< external high precision timer reference clock */
+    e_FM_RTC_SOURCE_CLOCK_SYSTEM,    /**< MAC system clock */
+    e_FM_RTC_SOURCE_CLOCK_OSCILATOR  /**< RTC clock oscilator */
+}e_FmSrcClk;
+
+/**************************************************************************//**
+ @Description   FM RTC configuration parameters structure.
+
+                This structure should be passed to FM_RTC_Config().
+*//***************************************************************************/
+typedef struct t_FmRtcParams
+{
+    t_Handle                 h_Fm;               /**< FM Handle*/
+    uint64_t                 baseAddress;        /**< Base address of FM RTC registers */
+    t_Handle                 h_App;              /**< A handle to an application layer object; This handle will
+                                                      be passed by the driver upon calling the above callbacks */
+} t_FmRtcParams;
+
+
+/**************************************************************************//**
+ @Function      FM_RTC_Config
+
+ @Description   Configures the FM RTC module according to user's parameters.
+
+                The driver assigns default values to some FM RTC parameters.
+                These parameters can be overwritten using the advanced
+                configuration routines.
+
+ @Param[in]     p_FmRtcParam    - FM RTC configuration parameters.
+
+ @Return        Handle to the new FM RTC object; NULL pointer on failure.
+
+ @Cautions      None
+*//***************************************************************************/
+t_Handle FM_RTC_Config(t_FmRtcParams *p_FmRtcParam);
+
+/**************************************************************************//**
+ @Function      FM_RTC_Init
+
+ @Description   Initializes the FM RTC driver and hardware.
+
+ @Param[in]     h_FmRtc - Handle to FM RTC object.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      h_FmRtc must have been previously created using FM_RTC_Config().
+*//***************************************************************************/
+t_Error FM_RTC_Init(t_Handle h_FmRtc);
+
+/**************************************************************************//**
+ @Function      FM_RTC_Free
+
+ @Description   Frees the FM RTC object and all allocated resources.
+
+ @Param[in]     h_FmRtc - Handle to FM RTC object.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      h_FmRtc must have been previously created using FM_RTC_Config().
+*//***************************************************************************/
+t_Error FM_RTC_Free(t_Handle h_FmRtc);
+
+
+/**************************************************************************//**
+ @Group         fm_rtc_adv_config_grp  FM RTC Advanced Configuration Unit
+
+ @Description   FM RTC advanced configuration functions.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Function      FM_RTC_ConfigPeriod
+
+ @Description   Configures the period of the timestamp if different than
+                default [DEFAULT_clockPeriod].
+
+ @Param[in]     h_FmRtc         - Handle to FM RTC object.
+ @Param[in]     period          - Period in nano-seconds.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      h_FmRtc must have been previously created using FM_RTC_Config().
+*//***************************************************************************/
+t_Error FM_RTC_ConfigPeriod(t_Handle h_FmRtc, uint32_t period);
+
+/**************************************************************************//**
+ @Function      FM_RTC_ConfigSourceClock
+
+ @Description   Configures the source clock of the RTC.
+
+ @Param[in]     h_FmRtc         - Handle to FM RTC object.
+ @Param[in]     srcClk          - Source clock selection.
+ @Param[in]     freqInMhz       - the source-clock frequency (in MHz).
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      h_FmRtc must have been previously created using FM_RTC_Config().
+*//***************************************************************************/
+t_Error FM_RTC_ConfigSourceClock(t_Handle      h_FmRtc,
+                                 e_FmSrcClk    srcClk,
+                                 uint32_t      freqInMhz);
+
+/**************************************************************************//**
+ @Function      FM_RTC_ConfigPulseRealignment
+
+ @Description   Configures the RTC to automatic FIPER pulse realignment in
+                response to timer adjustments [DEFAULT_pulseRealign]
+
+                In this mode, the RTC clock is identical to the source clock.
+                This feature can be useful when the system contains an external
+                RTC with inherent frequency compensation.
+
+ @Param[in]     h_FmRtc     - Handle to FM RTC object.
+ @Param[in]     enable      - TRUE to enable automatic realignment.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      h_FmRtc must have been previously created using FM_RTC_Config().
+*//***************************************************************************/
+t_Error FM_RTC_ConfigPulseRealignment(t_Handle h_FmRtc, bool enable);
+
+/**************************************************************************//**
+ @Function      FM_RTC_ConfigFrequencyBypass
+
+ @Description   Configures the RTC to bypass the frequency compensation
+                mechanism. [DEFAULT_bypass]
+
+                In this mode, the RTC clock is identical to the source clock.
+                This feature can be useful when the system contains an external
+                RTC with inherent frequency compensation.
+
+ @Param[in]     h_FmRtc     - Handle to FM RTC object.
+ @Param[in]     enabled     - TRUE to bypass frequency compensation;
+                              FALSE otherwise.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      h_FmRtc must have been previously created using FM_RTC_Config().
+*//***************************************************************************/
+t_Error FM_RTC_ConfigFrequencyBypass(t_Handle h_FmRtc, bool enabled);
+
+/**************************************************************************//**
+ @Function      FM_RTC_ConfigInvertedInputClockPhase
+
+ @Description   Configures the RTC to invert the source clock phase on input.
+                [DEFAULT_invertInputClkPhase]
+
+ @Param[in]     h_FmRtc  - Handle to FM RTC object.
+ @Param[in]     inverted    - TRUE to invert the source clock phase on input.
+                              FALSE otherwise.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      h_FmRtc must have been previously created using FM_RTC_Config().
+*//***************************************************************************/
+t_Error FM_RTC_ConfigInvertedInputClockPhase(t_Handle h_FmRtc, bool inverted);
+
+/**************************************************************************//**
+ @Function      FM_RTC_ConfigInvertedOutputClockPhase
+
+ @Description   Configures the RTC to invert the output clock phase.
+                [DEFAULT_invertOutputClkPhase]
+
+ @Param[in]     h_FmRtc  - Handle to FM RTC object.
+ @Param[in]     inverted    - TRUE to invert the output clock phase.
+                              FALSE otherwise.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      h_FmRtc must have been previously created using FM_RTC_Config().
+*//***************************************************************************/
+t_Error FM_RTC_ConfigInvertedOutputClockPhase(t_Handle h_FmRtc, bool inverted);
+
+/**************************************************************************//**
+ @Function      FM_RTC_ConfigOutputClockDivisor
+
+ @Description   Configures the divisor for generating the output clock from
+                the RTC clock. [DEFAULT_outputClockDivisor]
+
+ @Param[in]     h_FmRtc  - Handle to FM RTC object.
+ @Param[in]     divisor     - Divisor for generation of the output clock.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      h_FmRtc must have been previously created using FM_RTC_Config().
+*//***************************************************************************/
+t_Error FM_RTC_ConfigOutputClockDivisor(t_Handle h_FmRtc, uint16_t divisor);
+
+/**************************************************************************//**
+ @Function      FM_RTC_ConfigAlarmPolarity
+
+ @Description   Configures the polarity (active-high/active-low) of a specific
+                alarm signal. [DEFAULT_alarmPolarity]
+
+ @Param[in]     h_FmRtc      - Handle to FM RTC object.
+ @Param[in]     alarmId         - Alarm ID.
+ @Param[in]     alarmPolarity   - Alarm polarity.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      h_FmRtc must have been previously created using FM_RTC_Config().
+*//***************************************************************************/
+t_Error FM_RTC_ConfigAlarmPolarity(t_Handle             h_FmRtc,
+                                   uint8_t              alarmId,
+                                   e_FmRtcAlarmPolarity alarmPolarity);
+
+/**************************************************************************//**
+ @Function      FM_RTC_ConfigExternalTriggerPolarity
+
+ @Description   Configures the polarity (rising/falling edge) of a specific
+                external trigger signal. [DEFAULT_triggerPolarity]
+
+ @Param[in]     h_FmRtc      - Handle to FM RTC object.
+ @Param[in]     triggerId       - Trigger ID.
+ @Param[in]     triggerPolarity - Trigger polarity.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      h_FmRtc must have been previously created using FM_RTC_Config().
+*//***************************************************************************/
+t_Error FM_RTC_ConfigExternalTriggerPolarity(t_Handle               h_FmRtc,
+                                             uint8_t                triggerId,
+                                             e_FmRtcTriggerPolarity triggerPolarity);
+
+/** @} */ /* end of fm_rtc_adv_config_grp */
+/** @} */ /* end of fm_rtc_init_grp */
+
+
+/**************************************************************************//**
+ @Group         fm_rtc_control_grp FM RTC Control Unit
+
+ @Description   FM RTC runtime control API.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Function      t_FmRtcExceptionsCallback
+
+ @Description   Exceptions user callback routine, used for RTC different mechanisms.
+
+ @Param[in]     h_App       - User's application descriptor.
+ @Param[in]     id          - source id.
+*//***************************************************************************/
+typedef void (t_FmRtcExceptionsCallback) ( t_Handle  h_App, uint8_t id);
+
+/**************************************************************************//**
+ @Description   FM RTC alarm parameters.
+*//***************************************************************************/
+typedef struct t_FmRtcAlarmParams {
+    uint8_t                     alarmId;            /**< 0 or 1 */
+    uint64_t                    alarmTime;          /**< In nanoseconds, the time when the alarm
+                                                         should go off - must be in RTC units */
+    t_FmRtcExceptionsCallback   *f_AlarmCallback;   /**< This routine will be called when RTC
+                                                         reaches alarmTime */
+    bool                        clearOnExpiration;  /**< TRUE to turn off the alarm once expired. */
+} t_FmRtcAlarmParams;
+
+/**************************************************************************//**
+ @Description   FM RTC Periodic Pulse parameters.
+*//***************************************************************************/
+typedef struct t_FmRtcPeriodicPulseParams {
+    uint8_t                     periodicPulseId;            /**< 0 or 1 */
+    uint64_t                    periodicPulsePeriod;        /**< In Nanoseconds. Must be
+                                                                 a multiple of the RTC period */
+    t_FmRtcExceptionsCallback   *f_PeriodicPulseCallback;   /**< This routine will be called every
+                                                                 periodicPulsePeriod. */
+} t_FmRtcPeriodicPulseParams;
+
+/**************************************************************************//**
+ @Description   FM RTC Periodic Pulse parameters.
+*//***************************************************************************/
+typedef struct t_FmRtcExternalTriggerParams {
+    uint8_t                     externalTriggerId;              /**< 0 or 1 */
+    bool                        usePulseAsInput;                /**< Use the pulse interrupt instead of
+                                                                     an external signal */
+    t_FmRtcExceptionsCallback   *f_ExternalTriggerCallback;     /**< This routine will be called every
+                                                                     periodicPulsePeriod. */
+} t_FmRtcExternalTriggerParams;
+
+
+/**************************************************************************//**
+ @Function      FM_RTC_Enable
+
+ @Description   Enable the RTC (time count is started).
+
+                The user can select to resume the time count from previous
+                point, or to restart the time count.
+
+ @Param[in]     h_FmRtc     - Handle to FM RTC object.
+ @Param[in]     resetClock  - Restart the time count from zero.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      h_FmRtc must have been previously initialized using FM_RTC_Init().
+*//***************************************************************************/
+t_Error FM_RTC_Enable(t_Handle h_FmRtc, bool resetClock);
+
+/**************************************************************************//**
+ @Function      FM_RTC_Disable
+
+ @Description   Disables the RTC (time count is stopped).
+
+ @Param[in]     h_FmRtc - Handle to FM RTC object.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      h_FmRtc must have been previously initialized using FM_RTC_Init().
+*//***************************************************************************/
+t_Error FM_RTC_Disable(t_Handle h_FmRtc);
+
+/**************************************************************************//**
+ @Function      FM_RTC_SetClockOffset
+
+ @Description   Sets the clock offset (usually relative to another clock).
+
+                The user can pass a negative offset value.
+
+ @Param[in]     h_FmRtc  - Handle to FM RTC object.
+ @Param[in]     offset   - New clock offset (in nanoseconds).
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      h_FmRtc must have been previously initialized using FM_RTC_Init().
+*//***************************************************************************/
+t_Error FM_RTC_SetClockOffset(t_Handle h_FmRtc, int64_t offset);
+
+/**************************************************************************//**
+ @Function      FM_RTC_SetAlarm
+
+ @Description   Schedules an alarm event to a given RTC time.
+
+ @Param[in]     h_FmRtc             - Handle to FM RTC object.
+ @Param[in]     p_FmRtcAlarmParams  - Alarm parameters.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      h_FmRtc must have been previously initialized using FM_RTC_Init().
+                Must be called only prior to FM_RTC_Enable().
+*//***************************************************************************/
+t_Error FM_RTC_SetAlarm(t_Handle h_FmRtc, t_FmRtcAlarmParams *p_FmRtcAlarmParams);
+
+/**************************************************************************//**
+ @Function      FM_RTC_SetPeriodicPulse
+
+ @Description   Sets a periodic pulse.
+
+ @Param[in]     h_FmRtc                         - Handle to FM RTC object.
+ @Param[in]     p_FmRtcPeriodicPulseParams      - Periodic pulse parameters.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      h_FmRtc must have been previously initialized using FM_RTC_Init().
+                Must be called only prior to FM_RTC_Enable().
+*//***************************************************************************/
+t_Error FM_RTC_SetPeriodicPulse(t_Handle h_FmRtc, t_FmRtcPeriodicPulseParams *p_FmRtcPeriodicPulseParams);
+
+/**************************************************************************//**
+ @Function      FM_RTC_ClearPeriodicPulse
+
+ @Description   Clears a periodic pulse.
+
+ @Param[in]     h_FmRtc                         - Handle to FM RTC object.
+ @Param[in]     periodicPulseId                 - Periodic pulse id.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      h_FmRtc must have been previously initialized using FM_RTC_Init().
+*//***************************************************************************/
+t_Error FM_RTC_ClearPeriodicPulse(t_Handle h_FmRtc, uint8_t periodicPulseId);
+
+/**************************************************************************//**
+ @Function      FM_RTC_SetExternalTrigger
+
+ @Description   Sets an external trigger indication and define a callback
+                routine to be called on such event.
+
+ @Param[in]     h_FmRtc                         - Handle to FM RTC object.
+ @Param[in]     p_FmRtcExternalTriggerParams    - External Trigger parameters.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      h_FmRtc must have been previously initialized using FM_RTC_Init().
+*//***************************************************************************/
+t_Error FM_RTC_SetExternalTrigger(t_Handle h_FmRtc, t_FmRtcExternalTriggerParams *p_FmRtcExternalTriggerParams);
+
+/**************************************************************************//**
+ @Function      FM_RTC_ClearExternalTrigger
+
+ @Description   Clears external trigger indication.
+
+ @Param[in]     h_FmRtc                         - Handle to FM RTC object.
+ @Param[in]     id                              - External Trigger id.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      h_FmRtc must have been previously initialized using FM_RTC_Init().
+*//***************************************************************************/
+t_Error FM_RTC_ClearExternalTrigger(t_Handle h_FmRtc, uint8_t id);
+
+/**************************************************************************//**
+ @Function      FM_RTC_GetExternalTriggerTimeStamp
+
+ @Description   Reads the External Trigger TimeStamp.
+
+ @Param[in]     h_FmRtc                 - Handle to FM RTC object.
+ @Param[in]     triggerId               - External Trigger id.
+ @Param[out]    p_TimeStamp             - External Trigger timestamp.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      h_FmRtc must have been previously initialized using FM_RTC_Init().
+*//***************************************************************************/
+t_Error FM_RTC_GetExternalTriggerTimeStamp(t_Handle             h_FmRtc,
+                                           uint8_t              triggerId,
+                                           uint64_t             *p_TimeStamp);
+
+/**************************************************************************//**
+ @Function      FM_RTC_GetCurrentTime
+
+ @Description   Returns the current RTC time.
+
+ @Param[in]     h_FmRtc - Handle to FM RTC object.
+ @Param[out]    p_Ts - returned time stamp.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      h_FmRtc must have been previously initialized using FM_RTC_Init().
+*//***************************************************************************/
+t_Error FM_RTC_GetCurrentTime(t_Handle h_FmRtc, uint64_t *p_Ts);
+
+/**************************************************************************//**
+ @Function      FM_RTC_SetCurrentTime
+
+ @Description   Sets the current RTC time.
+
+ @Param[in]     h_FmRtc - Handle to FM RTC object.
+ @Param[in]     ts - The new time stamp.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      h_FmRtc must have been previously initialized using FM_RTC_Init().
+*//***************************************************************************/
+t_Error FM_RTC_SetCurrentTime(t_Handle h_FmRtc, uint64_t ts);
+
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+/**************************************************************************//**
+ @Function      FM_RTC_DumpRegs
+
+ @Description   Dumps all FM registers
+
+ @Param[in]     h_FmRtc      A handle to an FM RTC Module.
+
+ @Return        E_OK on success;
+
+ @Cautions      Allowed only FM_Init().
+*//***************************************************************************/
+t_Error FM_RTC_DumpRegs(t_Handle h_FmRtc);
+#endif /* (defined(DEBUG_ERRORS) && ... */
+
+/** @} */ /* end of fm_rtc_control_grp */
+/** @} */ /* end of fm_rtc_grp */
+/** @} */ /* end of FM_grp group */
+
+
+#endif /* __FM_RTC_EXT_H__ */
diff --git a/drivers/net/dpa/NetCommSw/inc/Peripherals/mii_acc_ext.h b/drivers/net/dpa/NetCommSw/inc/Peripherals/mii_acc_ext.h
index 419445f..26c08fb 100644
--- a/drivers/net/dpa/NetCommSw/inc/Peripherals/mii_acc_ext.h
+++ b/drivers/net/dpa/NetCommSw/inc/Peripherals/mii_acc_ext.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/drivers/net/dpa/NetCommSw/inc/core_ext.h b/drivers/net/dpa/NetCommSw/inc/core_ext.h
new file mode 100644
index 0000000..ea073b1
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/inc/core_ext.h
@@ -0,0 +1,65 @@
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**************************************************************************//**
+ @File          core_std_ext.h
+
+ @Description   TODO
+*//***************************************************************************/
+#ifndef __CORE_EXT_H
+#define __CORE_EXT_H
+
+
+#ifdef NCSW_PPC_CORE
+#include "ppc_ext.h"
+#else
+#error "Core is not defined!"
+#endif /* NCSW_CORE */
+
+#if (!defined(CORE_IS_LITTLE_ENDIAN) && !defined(CORE_IS_BIG_ENDIAN))
+#error "Must define core as little-endian or big-endian!"
+#endif /* (!defined(CORE_IS_LITTLE_ENDIAN) && ... */
+
+
+/**************************************************************************//**
+ @Function      CORE_MemoryBarrier
+
+ @Description   This routine will cause the core to stop executing any commands
+                until all previous memory read/write commands are completely out
+                of the core's pipeline.
+
+ @Return        None.
+*//***************************************************************************/
+void CORE_MemoryBarrier(void);
+
+
+#endif /* __CORE_EXT_H */
diff --git a/drivers/net/dpa/NetCommSw/inc/cores/e500v2_ext.h b/drivers/net/dpa/NetCommSw/inc/cores/e500v2_ext.h
new file mode 100644
index 0000000..2ca002e
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/inc/cores/e500v2_ext.h
@@ -0,0 +1,359 @@
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**************************************************************************//**
+ @File          e500v2_ext.h
+
+ @Description   E500 external definitions prototypes
+                This file is not included by the E500
+                source file as it is an assembly file. It is used
+                only for prototypes exposure, for inclusion
+                by user and other modules.
+*//***************************************************************************/
+
+#ifndef __E500V2_EXT_H
+#define __E500V2_EXT_H
+
+#include "std_ext.h"
+
+
+/* Layer 1 Cache Manipulations
+ *==============================
+ * Should not be called directly by the user.
+ */
+void        L1DCache_Invalidate (void);
+void        L1ICache_Invalidate(void);
+void        L1DCache_Enable(void);
+void        L1ICache_Enable(void);
+void        L1DCache_Disable(void);
+void        L1ICache_Disable(void);
+void        L1DCache_Flush(void);
+void        L1ICache_Flush(void);
+/*
+ *
+ */
+uint32_t    L1DCache_LineLock(uint32_t addr);
+uint32_t    L1ICache_LineLock(uint32_t addr);
+void        L1Cache_BroadCastEnable(void);
+void        L1Cache_BroadCastDisable(void);
+
+
+#define CORE_DCacheEnable       E500_DCacheEnable
+#define CORE_ICacheEnable       E500_ICacheEnable
+#define CORE_DCacheDisable      E500_DCacheDisable
+#define CORE_ICacheDisable      E500_ICacheDisable
+#define CORE_GetId              E500_GetId
+#define CORE_TestAndSet         E500_TestAndSet
+#define CORE_MemoryBarrier      E500_MemoryBarrier
+#define CORE_InstructionSync    E500_InstructionSync
+
+
+/**************************************************************************//**
+ @Group         E500_id E500 Application Programming Interface
+
+ @Description   E500 API functions, definitions and enums
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Group         E500_init_grp E500 Initialization Unit
+
+ @Description   E500 initialization unit API functions, definitions and enums
+
+ @{
+*//***************************************************************************/
+
+
+/**************************************************************************//**
+ @Function      E500_DCacheEnable
+
+ @Description   Enables the data cache for memory pages that are
+                not cache inhibited.
+
+ @Return        None.
+*//***************************************************************************/
+void E500_DCacheEnable(void);
+
+/**************************************************************************//**
+ @Function      E500_ICacheEnable
+
+ @Description   Enables the instruction cache for memory pages that are
+                not cache inhibited.
+
+ @Return        None.
+*//***************************************************************************/
+void E500_ICacheEnable(void);
+
+/**************************************************************************//**
+ @Function      E500_DCacheDisable
+
+ @Description   Disables the data cache.
+
+ @Return        None.
+*//***************************************************************************/
+void E500_DCacheDisable(void);
+
+/**************************************************************************//**
+ @Function      E500_ICacheDisable
+
+ @Description   Disables the instruction cache.
+
+ @Return        None.
+*//***************************************************************************/
+void E500_ICacheDisable(void);
+
+/**************************************************************************//**
+ @Function      E500_DCacheFlush
+
+ @Description   Flushes the data cache
+
+ @Return        None.
+*//***************************************************************************/
+void E500_DCacheFlush(void);
+
+/**************************************************************************//**
+ @Function      E500_ICacheFlush
+
+ @Description   Flushes the instruction cache.
+
+ @Return        None.
+*//***************************************************************************/
+void E500_ICacheFlush(void);
+
+
+/**************************************************************************//**
+ @Description   E500mc L2 Cache Operation Mode
+*//***************************************************************************/
+typedef enum e_E500mcL2CacheMode
+{
+    e_L2_CACHE_MODE_DATA_ONLY      = 0x00000001,   /**< Cache data only */
+    e_L2_CACHE_MODE_INST_ONLY      = 0x00000002,   /**< Cache instructions only */
+    e_L2_CACHE_MODE_DATA_AND_INST  = 0x00000003    /**< Cache data and instructions */
+} e_E500mcL2CacheMode;
+
+/**************************************************************************//**
+ @Function      E500_L2CacheEnable
+
+ @Description   Enables the cache for memory pages that are not cache inhibited.
+
+ @param[in]     mode - L2 cache mode: data only, instruction only or instruction and data.
+
+ @Return        None.
+
+ @Cautions      This routine must be call only ONCE for both caches. I.e. it is
+                not possible to call this routine for i-cache and than to call
+                again for d-cache; The second call will override the first one.
+*//***************************************************************************/
+void E500_L2CacheEnable(e_E500mcL2CacheMode mode);
+
+/**************************************************************************//**
+ @Function      E500_L2CacheDisable
+
+ @Description   Disables the cache (data instruction or both).
+
+ @Return        None.
+
+*//***************************************************************************/
+void E500_L2CacheDisable(void);
+
+/**************************************************************************//**
+ @Function      E500_L2CacheFlush
+
+ @Description   Flushes the cache.
+
+ @Return        None.
+*//***************************************************************************/
+void E500_L2CacheFlush(void);
+
+/**************************************************************************//**
+ @Function      E500_AddressBusStreamingEnable
+
+ @Description   Enables address bus streaming on the CCB.
+
+                This setting, along with the ECM streaming configuration
+                parameters, enables address bus streaming on the CCB.
+
+ @Return        None.
+*//***************************************************************************/
+void E500_AddressBusStreamingEnable(void);
+
+/**************************************************************************//**
+ @Function      E500_AddressBusStreamingDisable
+
+ @Description   Disables address bus streaming on the CCB.
+
+ @Return        None.
+*//***************************************************************************/
+void E500_AddressBusStreamingDisable(void);
+
+/**************************************************************************//**
+ @Function      E500_AddressBroadcastEnable
+
+ @Description   Enables address broadcast.
+
+                The e500 broadcasts cache management instructions (dcbst, dcblc
+                (CT = 1), icblc (CT = 1), dcbf, dcbi, mbar, msync, tlbsync, icbi)
+                based on ABE. ABE must be set to allow management of external
+                L2 caches.
+
+ @Return        None.
+*//***************************************************************************/
+void E500_AddressBroadcastEnable(void);
+
+/**************************************************************************//**
+ @Function      E500_AddressBroadcastDisable
+
+ @Description   Disables address broadcast.
+
+                The e500 broadcasts cache management instructions (dcbst, dcblc
+                (CT = 1), icblc (CT = 1), dcbf, dcbi, mbar, msync, tlbsync, icbi)
+                based on ABE. ABE must be set to allow management of external
+                L2 caches.
+
+ @Return        None.
+*//***************************************************************************/
+void E500_AddressBroadcastDisable(void);
+
+/**************************************************************************//**
+ @Function      E500_IsTaskletSupported
+
+ @Description   Checks if tasklets are supported by the e500 interrupt handler.
+
+ @Retval        TRUE    - Tasklets are supported.
+ @Retval        FALSE   - Tasklets are not supported.
+*//***************************************************************************/
+bool E500_IsTaskletSupported(void);
+
+void E500_EnableTimeBase(void);
+void E500_DisableTimeBase(void);
+
+uint64_t E500_GetTimeBaseTime(void);
+
+void E500_GenericIntrInit(void);
+
+t_Error E500_SetIntr(int        ppcIntrSrc,
+                     void       (* Isr)(t_Handle handle),
+                     t_Handle   handle);
+
+t_Error E500_ClearIntr(int ppcIntrSrc);
+
+/**************************************************************************//**
+ @Function      E500_GenericIntrHandler
+
+ @Description   This is the general e500 interrupt handler.
+
+                It is called by the main assembly interrupt handler
+                when an exception occures and no other function has been
+                assigned to this exception.
+
+ @Param         intrEntry   - (In) The exception interrupt vector entry.
+*//***************************************************************************/
+void E500_GenericIntrHandler(uint32_t intrEntry);
+
+#ifndef QE_CRITICAL_INTR
+/**************************************************************************//**
+ @Function      CriticalIntr
+
+ @Description   This is the specific critical e500 interrupt handler.
+
+                It is called by the main assembly interrupt handler
+                when an critical interrupt.
+
+ @Param         intrEntry   - (In) The exception interrupt vector entry.
+*//***************************************************************************/
+void CriticalIntr(uint32_t intrEntry);
+#endif /* not QE_CRITICAL_INTR */
+
+
+/**************************************************************************//**
+ @Function      E500_GetId
+
+ @Description   Returns the core ID in the system.
+
+ @Return        Core ID.
+*//***************************************************************************/
+uint32_t E500_GetId(void);
+
+/**************************************************************************//**
+ @Function      E500_TestAndSet
+
+ @Description   This routine tries to atomically test-and-set an integer
+                in memory to a non-zero value.
+
+                The memory will be set only if it is tested as zero, in which
+                case the routine retunrs the new non-zero value; otherwise the
+                routine returns zero.
+
+ @Param[in]     p - pointer to a volatile int in memory, on which test-and-set
+                    operation should be made.
+
+ @Retval        Zero        - Operation failed - memory was already set.
+ @Retval        Non-zero    - Operation succeeded - memory has been set.
+*//***************************************************************************/
+int E500_TestAndSet(volatile int *p);
+
+/**************************************************************************//**
+ @Function      E500_MemoryBarrier
+
+ @Description   This routine will cause the core to stop executing any commands
+                until all previous memory read/write commands are completely out
+                of the core's pipeline.
+
+ @Return        None.
+*//***************************************************************************/
+static __inline__ void E500_MemoryBarrier(void)
+{
+    __asm__ ("mbar 1");
+}
+
+/**************************************************************************//**
+ @Function      E500_InstructionSync
+
+ @Description   This routine will cause the core to wait for previous instructions
+                (including any interrupts they generate) to complete before the
+                synchronization command executes, which purges all instructions
+                from the processor's pipeline and refetches the next instruction.
+
+ @Return        None.
+*//***************************************************************************/
+static __inline__ void E500_InstructionSync(void)
+{
+    __asm__ ("isync");
+}
+
+
+/** @} */ /* end of E500_init_grp group */
+/** @} */ /* end of E500_grp group */
+
+
+#endif /* __E500V2_EXT_H */
diff --git a/drivers/net/dpa/NetCommSw/inc/cores/ppc_ext.h b/drivers/net/dpa/NetCommSw/inc/cores/ppc_ext.h
new file mode 100644
index 0000000..7de7164
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/inc/cores/ppc_ext.h
@@ -0,0 +1,136 @@
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**************************************************************************//**
+ @File          ppc_ext.h
+
+ @Description   TODO
+*//***************************************************************************/
+#ifndef __PPC_EXT_H
+#define __PPC_EXT_H
+
+#include "part_ext.h"
+
+
+#define CORE_IS_BIG_ENDIAN
+
+
+/**************************************************************************//**
+ @Function      CORE_GetId
+
+ @Description   Returns the core ID in the system.
+
+ @Return        Core ID.
+*//***************************************************************************/
+uint32_t CORE_GetId(void);
+
+/**************************************************************************//**
+ @Function      CORE_TestAndSet
+
+ @Description   This routine tries to atomically test-and-set an integer
+                in memory to a non-zero value.
+
+                The memory will be set only if it is tested as zero, in which
+                case the routine retunrs the new non-zero value; otherwise the
+                routine returns zero.
+
+ @Param[in]     p - pointer to a volatile int in memory, on which test-and-set
+                    operation should be made.
+
+ @Retval        Zero        - Operation failed - memory was already set.
+ @Retval        Non-zero    - Operation succeeded - memory has been set.
+*//***************************************************************************/
+int CORE_TestAndSet(volatile int *p);
+
+/**************************************************************************//**
+ @Function      CORE_InstructionSync
+
+ @Description   This routine will cause the core to wait for previous instructions
+                (including any interrupts they generate) to complete before the
+                synchronization command executes, which purges all instructions
+                from the processor's pipeline and refetches the next instruction.
+
+ @Return        None.
+*//***************************************************************************/
+void CORE_InstructionSync(void);
+
+/**************************************************************************//**
+ @Function      CORE_DCacheEnable
+
+ @Description   Enables the data cache for memory pages that are
+                not cache inhibited.
+
+ @Return        None.
+*//***************************************************************************/
+void CORE_DCacheEnable(void);
+
+/**************************************************************************//**
+ @Function      CORE_ICacheEnable
+
+ @Description   Enables the instruction cache for memory pages that are
+                not cache inhibited.
+
+ @Return        None.
+*//***************************************************************************/
+void CORE_ICacheEnable(void);
+
+/**************************************************************************//**
+ @Function      CORE_DCacheDisable
+
+ @Description   Disables the data cache.
+
+ @Return        None.
+*//***************************************************************************/
+void CORE_DCacheDisable(void);
+
+/**************************************************************************//**
+ @Function      CORE_ICacheDisable
+
+ @Description   Disables the instruction cache.
+
+ @Return        None.
+*//***************************************************************************/
+void CORE_ICacheDisable(void);
+
+
+
+
+#if defined(CORE_E300)
+#include "e300_ext.h"
+#elif defined(CORE_E500V2) || defined(CORE_E500MC)
+#include "e500v2_ext.h"
+#else
+#error "Core not defined!"
+#endif
+
+
+#endif /* __PPC_EXT_H */
diff --git a/drivers/net/dpa/NetCommSw/inc/ctype_ext.h b/drivers/net/dpa/NetCommSw/inc/ctype_ext.h
index b28ff4c..0c67b34 100644
--- a/drivers/net/dpa/NetCommSw/inc/ctype_ext.h
+++ b/drivers/net/dpa/NetCommSw/inc/ctype_ext.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/drivers/net/dpa/NetCommSw/inc/debug_ext.h b/drivers/net/dpa/NetCommSw/inc/debug_ext.h
index f5f3a7c..60ec35a 100644
--- a/drivers/net/dpa/NetCommSw/inc/debug_ext.h
+++ b/drivers/net/dpa/NetCommSw/inc/debug_ext.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/drivers/net/dpa/NetCommSw/inc/endian_ext.h b/drivers/net/dpa/NetCommSw/inc/endian_ext.h
index 37aa966..42fa3fb 100644
--- a/drivers/net/dpa/NetCommSw/inc/endian_ext.h
+++ b/drivers/net/dpa/NetCommSw/inc/endian_ext.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/drivers/net/dpa/NetCommSw/inc/enet_ext.h b/drivers/net/dpa/NetCommSw/inc/enet_ext.h
index 2ba5bf3..c971bc4 100644
--- a/drivers/net/dpa/NetCommSw/inc/enet_ext.h
+++ b/drivers/net/dpa/NetCommSw/inc/enet_ext.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -73,7 +73,8 @@ typedef enum e_EnetInterface
     e_ENET_IF_TBI   = 0x00060000,   /**< TBI interface */
     e_ENET_IF_RTBI  = 0x00070000,   /**< RTBI interface */
     e_ENET_IF_SGMII = 0x00080000,   /**< SGMII interface */
-    e_ENET_IF_XGMII = 0x00090000    /**< XGMII interface */
+    e_ENET_IF_XGMII = 0x00090000,   /**< XGMII interface */
+    e_ENET_IF_QSGMII= 0x000a0000    /**< QSGMII interface */
 } e_EnetInterface;
 
 /**************************************************************************//**
@@ -117,7 +118,8 @@ typedef enum e_EnetMode
     e_ENET_MODE_SGMII_10    = (e_ENET_IF_SGMII | e_ENET_SPEED_10),      /**<    10 Mbps SGMII */
     e_ENET_MODE_SGMII_100   = (e_ENET_IF_SGMII | e_ENET_SPEED_100),     /**<   100 Mbps SGMII */
     e_ENET_MODE_SGMII_1000  = (e_ENET_IF_SGMII | e_ENET_SPEED_1000),    /**<  1000 Mbps SGMII */
-    e_ENET_MODE_XGMII_10000 = (e_ENET_IF_XGMII | e_ENET_SPEED_10000)    /**< 10000 Mbps XGMII */
+    e_ENET_MODE_XGMII_10000 = (e_ENET_IF_XGMII | e_ENET_SPEED_10000),    /**< 10000 Mbps XGMII */
+    e_ENET_MODE_QSGMII_1000 = (e_ENET_IF_QSGMII| e_ENET_SPEED_1000)    /**<  1000 Mbps QSGMII */
 } e_EnetMode;
 
 
@@ -137,7 +139,8 @@ typedef enum e_EnetMode
          ((mode) == e_ENET_MODE_SGMII_10   ) || \
          ((mode) == e_ENET_MODE_SGMII_100  ) || \
          ((mode) == e_ENET_MODE_SGMII_1000 ) || \
-         ((mode) == e_ENET_MODE_XGMII_10000))
+         ((mode) == e_ENET_MODE_XGMII_10000) || \
+         ((mode) == e_ENET_MODE_QSGMII_1000))
 
 
 #define MAKE_ENET_MODE(_interface, _speed)     (e_EnetMode)((_interface) | (_speed))
diff --git a/drivers/net/dpa/NetCommSw/inc/error_ext.h b/drivers/net/dpa/NetCommSw/inc/error_ext.h
index dc739d5..221e547 100644
--- a/drivers/net/dpa/NetCommSw/inc/error_ext.h
+++ b/drivers/net/dpa/NetCommSw/inc/error_ext.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -41,11 +41,11 @@
 
 #include "std_ext.h"
 #include "xx_ext.h"
+#include "core_ext.h"
 
 #ifdef VC
 #define __FUNCTION__    ""
-#endif
-
+#endif /* VC */
 
 
 /**************************************************************************//**
@@ -303,41 +303,66 @@ typedef enum e_Event        /*   Comments / Associated Flags and Message Strings
 
 #define NO_MSG      ("")
 
+#ifndef DEBUG_GLOBAL_LEVEL
+#define DEBUG_GLOBAL_LEVEL  REPORT_LEVEL_WARNING
+#endif /* DEBUG_GLOBAL_LEVEL */
+
+#ifndef ERROR_GLOBAL_LEVEL
+#define ERROR_GLOBAL_LEVEL  DEBUG_GLOBAL_LEVEL
+#endif /* ERROR_GLOBAL_LEVEL */
+
 #ifndef EVENT_GLOBAL_LEVEL
 #define EVENT_GLOBAL_LEVEL  REPORT_LEVEL_MINOR
-#endif
+#endif /* EVENT_GLOBAL_LEVEL */
 
 #ifdef EVENT_LOCAL_LEVEL
 #define EVENT_DYNAMIC_LEVEL EVENT_LOCAL_LEVEL
 #else
 #define EVENT_DYNAMIC_LEVEL EVENT_GLOBAL_LEVEL
-#endif
+#endif /* EVENT_LOCAL_LEVEL */
 
 
-#ifndef DEBUG_GLOBAL_LEVEL
-#define DEBUG_GLOBAL_LEVEL  REPORT_LEVEL_WARNING
-#endif
-
 #ifndef DEBUG_DYNAMIC_LEVEL
-
 #define DEBUG_USING_STATIC_LEVEL
 
 #ifdef DEBUG_STATIC_LEVEL
 #define DEBUG_DYNAMIC_LEVEL DEBUG_STATIC_LEVEL
 #else
 #define DEBUG_DYNAMIC_LEVEL DEBUG_GLOBAL_LEVEL
-#endif
+#endif /* DEBUG_STATIC_LEVEL */
 
 #else /* DEBUG_DYNAMIC_LEVEL */
-
 #ifdef DEBUG_STATIC_LEVEL
 #error "Please use either DEBUG_STATIC_LEVEL or DEBUG_DYNAMIC_LEVEL (not both)"
 #else
 int DEBUG_DYNAMIC_LEVEL = DEBUG_GLOBAL_LEVEL;
 #endif /* DEBUG_STATIC_LEVEL */
+#endif /* !DEBUG_DYNAMIC_LEVEL */
 
-#endif /* DEBUG_DYNAMIC_LEVEL */
 
+#ifndef ERROR_DYNAMIC_LEVEL
+
+#ifdef ERROR_STATIC_LEVEL
+#define ERROR_DYNAMIC_LEVEL ERROR_STATIC_LEVEL
+#else
+#define ERROR_DYNAMIC_LEVEL ERROR_GLOBAL_LEVEL
+#endif /* ERROR_STATIC_LEVEL */
+
+#else /* ERROR_DYNAMIC_LEVEL */
+#ifdef ERROR_STATIC_LEVEL
+#error "Please use either ERROR_STATIC_LEVEL or ERROR_DYNAMIC_LEVEL (not both)"
+#else
+int ERROR_DYNAMIC_LEVEL = ERROR_GLOBAL_LEVEL;
+#endif /* ERROR_STATIC_LEVEL */
+#endif /* !ERROR_DYNAMIC_LEVEL */
+
+#ifdef NCSW_SMP
+#define PRINT_FORMAT        "[cpu%d, %s:%d %s]"
+#define PRINT_FMT_PARAMS    CORE_GetId(), __FILE__, __LINE__, __FUNCTION__
+#else
+#define PRINT_FORMAT        "[%s:%d %s]"
+#define PRINT_FMT_PARAMS    __FILE__, __LINE__, __FUNCTION__
+#endif /* NCSW_SMP */
 
 #if (!(defined(DEBUG_ERRORS)) || (DEBUG_ERRORS == 0))
 /* No debug/error/event messages at all */
@@ -381,10 +406,10 @@ extern const char *eventStrings[];
 #define DBG(_level, _vmsg) \
     do { \
         if (REPORT_LEVEL_##_level <= DEBUG_DYNAMIC_LEVEL) { \
-            XX_Print("> %s (%s) [%s:%d %s]: ", \
+            XX_Print("> %s (%s) " PRINT_FORMAT ": ", \
                      dbgLevelStrings[REPORT_LEVEL_##_level - 1], \
                      moduleStrings[__ERR_MODULE__ >> 16], \
-                     __FILE__, __LINE__, __FUNCTION__); \
+                     PRINT_FMT_PARAMS); \
             XX_Print _vmsg; \
             XX_Print("\r\n"); \
         } \
@@ -394,11 +419,11 @@ extern const char *eventStrings[];
 
 #define REPORT_ERROR(_level, _err, _vmsg) \
     do { \
-        if (REPORT_LEVEL_##_level <= DEBUG_DYNAMIC_LEVEL) { \
-            XX_Print("! %s %s Error [%s:%d %s]: %s; ", \
+        if (REPORT_LEVEL_##_level <= ERROR_DYNAMIC_LEVEL) { \
+            XX_Print("! %s %s Error " PRINT_FORMAT ": %s; ", \
                      dbgLevelStrings[REPORT_LEVEL_##_level - 1], \
                      moduleStrings[__ERR_MODULE__ >> 16], \
-                     __FILE__, __LINE__, __FUNCTION__, \
+                     PRINT_FMT_PARAMS, \
                      errTypeStrings[(GET_ERROR_TYPE(_err) - E_OK - 1)]); \
             XX_Print _vmsg; \
             XX_Print("\r\n"); \
@@ -418,10 +443,10 @@ extern const char *eventStrings[];
 #define REPORT_EVENT(_ev, _appId, _flg, _vmsg) \
     do { \
         if (_ev##_LEVEL <= EVENT_DYNAMIC_LEVEL) { \
-            XX_Print("~ %s %s Event [%s:%d %s]: %s (flags: 0x%04x); ", \
+            XX_Print("~ %s %s Event " PRINT_FORMAT ": %s (flags: 0x%04x); ", \
                      dbgLevelStrings[_ev##_LEVEL - 1], \
                      moduleStrings[__ERR_MODULE__ >> 16], \
-                     __FILE__, __LINE__, __FUNCTION__, \
+                     PRINT_FMT_PARAMS, \
                      eventStrings[((_ev) - EV_NO_EVENT - 1)], \
                      (uint16_t)(_flg)); \
             XX_Print _vmsg; \
@@ -453,8 +478,8 @@ extern const char *eventStrings[];
 #define ASSERT_COND(_cond) \
     do { \
         if (!(_cond)) { \
-            XX_Print("*** ASSERT_COND failed [%s:%d %s]\r\n", \
-                     __FILE__, __LINE__, __FUNCTION__); \
+            XX_Print("*** ASSERT_COND failed " PRINT_FORMAT "\r\n", \
+                    PRINT_FMT_PARAMS); \
             XX_Exit(1); \
         } \
     } while (0)
diff --git a/drivers/net/dpa/NetCommSw/inc/etc/list_ext.h b/drivers/net/dpa/NetCommSw/inc/etc/list_ext.h
index 5325ee1..d04376c 100644
--- a/drivers/net/dpa/NetCommSw/inc/etc/list_ext.h
+++ b/drivers/net/dpa/NetCommSw/inc/etc/list_ext.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/drivers/net/dpa/NetCommSw/inc/etc/mem_ext.h b/drivers/net/dpa/NetCommSw/inc/etc/mem_ext.h
index 7e41c56..0a0f21d 100644
--- a/drivers/net/dpa/NetCommSw/inc/etc/mem_ext.h
+++ b/drivers/net/dpa/NetCommSw/inc/etc/mem_ext.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/drivers/net/dpa/NetCommSw/inc/etc/memcpy_ext.h b/drivers/net/dpa/NetCommSw/inc/etc/memcpy_ext.h
index 5de41be..526bdce 100644
--- a/drivers/net/dpa/NetCommSw/inc/etc/memcpy_ext.h
+++ b/drivers/net/dpa/NetCommSw/inc/etc/memcpy_ext.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/drivers/net/dpa/NetCommSw/inc/etc/mm_ext.h b/drivers/net/dpa/NetCommSw/inc/etc/mm_ext.h
index 129e332..2eac8de 100644
--- a/drivers/net/dpa/NetCommSw/inc/etc/mm_ext.h
+++ b/drivers/net/dpa/NetCommSw/inc/etc/mm_ext.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/drivers/net/dpa/NetCommSw/inc/etc/sprint_ext.h b/drivers/net/dpa/NetCommSw/inc/etc/sprint_ext.h
index db7f1b2..6a3ce22 100644
--- a/drivers/net/dpa/NetCommSw/inc/etc/sprint_ext.h
+++ b/drivers/net/dpa/NetCommSw/inc/etc/sprint_ext.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/drivers/net/dpa/NetCommSw/inc/integrations/P4080/dpaa_integration_ext.h b/drivers/net/dpa/NetCommSw/inc/integrations/P4080/dpaa_integration_ext.h
new file mode 100644
index 0000000..9ace54d
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/inc/integrations/P4080/dpaa_integration_ext.h
@@ -0,0 +1,255 @@
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**
+
+ @File          dpaa_integration_ext.h
+
+ @Description   P4080 FM external definitions and structures.
+*//***************************************************************************/
+#ifndef __DPAA_INTEGRATION_EXT_H
+#define __DPAA_INTEGRATION_EXT_H
+
+#include "std_ext.h"
+
+
+/*****************************************************************************
+ QMan INTEGRATION-SPECIFIC DEFINITIONS
+******************************************************************************/
+#define QMAN_WQ_CS_CFG_ERRATA
+#define QMAN_SFDR_LEAK_ERRATA_5
+
+#define QM_MAX_NUM_OF_PORTALS   10
+#define QM_MAX_NUM_OF_WQ        8
+
+typedef enum {
+    e_QM_FQ_CHANNEL_SWPORTAL0 = 0,
+    e_QM_FQ_CHANNEL_SWPORTAL1,
+    e_QM_FQ_CHANNEL_SWPORTAL2,
+    e_QM_FQ_CHANNEL_SWPORTAL3,
+    e_QM_FQ_CHANNEL_SWPORTAL4,
+    e_QM_FQ_CHANNEL_SWPORTAL5,
+    e_QM_FQ_CHANNEL_SWPORTAL6,
+    e_QM_FQ_CHANNEL_SWPORTAL7,
+    e_QM_FQ_CHANNEL_SWPORTAL8,
+    e_QM_FQ_CHANNEL_SWPORTAL9,
+
+    e_QM_FQ_CHANNEL_POOL1 = 0x21,
+    e_QM_FQ_CHANNEL_POOL2,
+    e_QM_FQ_CHANNEL_POOL3,
+    e_QM_FQ_CHANNEL_POOL4,
+    e_QM_FQ_CHANNEL_POOL5,
+    e_QM_FQ_CHANNEL_POOL6,
+    e_QM_FQ_CHANNEL_POOL7,
+    e_QM_FQ_CHANNEL_POOL8,
+    e_QM_FQ_CHANNEL_POOL9,
+    e_QM_FQ_CHANNEL_POOL10,
+    e_QM_FQ_CHANNEL_POOL11,
+    e_QM_FQ_CHANNEL_POOL12,
+    e_QM_FQ_CHANNEL_POOL13,
+    e_QM_FQ_CHANNEL_POOL14,
+    e_QM_FQ_CHANNEL_POOL15,
+
+    e_QM_FQ_CHANNEL_FMAN0_SP0 = 0x40,
+    e_QM_FQ_CHANNEL_FMAN0_SP1,
+    e_QM_FQ_CHANNEL_FMAN0_SP2,
+    e_QM_FQ_CHANNEL_FMAN0_SP3,
+    e_QM_FQ_CHANNEL_FMAN0_SP4,
+    e_QM_FQ_CHANNEL_FMAN0_SP5,
+    e_QM_FQ_CHANNEL_FMAN0_SP6,
+    e_QM_FQ_CHANNEL_FMAN0_SP7,
+    e_QM_FQ_CHANNEL_FMAN0_SP8,
+    e_QM_FQ_CHANNEL_FMAN0_SP9,
+    e_QM_FQ_CHANNEL_FMAN0_SP10,
+    e_QM_FQ_CHANNEL_FMAN0_SP11,
+
+    e_QM_FQ_CHANNEL_FMAN1_SP0 = 0x60,
+    e_QM_FQ_CHANNEL_FMAN1_SP1,
+    e_QM_FQ_CHANNEL_FMAN1_SP2,
+    e_QM_FQ_CHANNEL_FMAN1_SP3,
+    e_QM_FQ_CHANNEL_FMAN1_SP4,
+    e_QM_FQ_CHANNEL_FMAN1_SP5,
+    e_QM_FQ_CHANNEL_FMAN1_SP6,
+    e_QM_FQ_CHANNEL_FMAN1_SP7,
+    e_QM_FQ_CHANNEL_FMAN1_SP8,
+    e_QM_FQ_CHANNEL_FMAN1_SP9,
+    e_QM_FQ_CHANNEL_FMAN1_SP10,
+    e_QM_FQ_CHANNEL_FMAN1_SP11,
+
+    e_QM_FQ_CHANNEL_CAAM = 0x80,
+    e_QM_FQ_CHANNEL_PME = 0xa0
+} e_QmFQChannel;
+
+/*****************************************************************************
+ BMan INTEGRATION-SPECIFIC DEFINITIONS
+******************************************************************************/
+#define BM_MAX_NUM_OF_POOLS     64
+#define BM_MAX_NUM_OF_PORTALS   10
+
+/*****************************************************************************
+ FM INTEGRATION-SPECIFIC DEFINITIONS
+******************************************************************************/
+#define INTG_MAX_NUM_OF_FM          2
+
+#define FM_MAX_NUM_OF_1G_RX_PORTS   4
+#define FM_MAX_NUM_OF_10G_RX_PORTS  1
+#define FM_MAX_NUM_OF_RX_PORTS      (FM_MAX_NUM_OF_10G_RX_PORTS+FM_MAX_NUM_OF_1G_RX_PORTS)
+#define FM_MAX_NUM_OF_1G_TX_PORTS   4
+#define FM_MAX_NUM_OF_10G_TX_PORTS  1
+#define FM_MAX_NUM_OF_TX_PORTS      (FM_MAX_NUM_OF_10G_TX_PORTS+FM_MAX_NUM_OF_1G_TX_PORTS)
+#define FM_MAX_NUM_OF_OH_PORTS      7
+#define FM_MAX_NUM_OF_1G_MACS       (FM_MAX_NUM_OF_1G_RX_PORTS)
+#define FM_MAX_NUM_OF_10G_MACS      (FM_MAX_NUM_OF_10G_RX_PORTS)
+#define FM_MAX_NUM_OF_MACS          (FM_MAX_NUM_OF_1G_MACS+FM_MAX_NUM_OF_10G_MACS)
+#define FM_MAX_NUM_OF_PCD_PORTS     (FM_MAX_NUM_OF_RX_PORTS+FM_MAX_NUM_OF_OH_PORTS)
+#define FM_MAX_NUM_OF_PORTS         64
+
+#define FM_MURAM_SIZE               (160*KILOBYTE)
+#define FM_IRAM_SIZE                (4*KILOBYTE)
+#define FM_PCD_PLCR_NUM_ENTRIES     256                 /**< Total number of policer profiles */
+#define FM_PCD_KG_NUM_OF_SCHEMES    32                  /**< Total number of KG schemes */
+#define FM_PCD_MAX_NUM_OF_CLS_PLANS 256                 /**< Number of classification plan entries. */
+
+#define FM_RTC_NUM_OF_ALARMS            2
+#define FM_RTC_NUM_OF_PERIODIC_PULSES   2
+#define FM_RTC_NUM_OF_EXT_TRIGGERS      2
+
+/**************************************************************************//**
+ @Description   Enum for inter-module interrupts registration
+*//***************************************************************************/
+typedef enum e_FmEventModules{
+    e_FM_MOD_PRS,                   /**< Parser event */
+    e_FM_MOD_KG,                    /**< Keygen event */
+    e_FM_MOD_PLCR,                  /**< Policer event */
+    e_FM_MOD_10G_MAC,               /**< 10G MAC  error event */
+    e_FM_MOD_1G_MAC,                /**< 1G MAC  error event */
+    e_FM_MOD_TMR,                   /**< Timer event */
+    e_FM_MOD_1G_MAC_TMR,            /**< 1G MAC  Timer event */
+    e_FM_MOD_DUMMY_LAST
+} e_FmEventModules;
+
+/**************************************************************************//**
+ @Description   Enum for interrupts types
+*//***************************************************************************/
+typedef enum e_FmIntrType {
+    e_FM_INTR_TYPE_ERR,
+    e_FM_INTR_TYPE_NORMAL
+} e_FmIntrType;
+
+/**************************************************************************//**
+ @Description   Enum for inter-module interrupts registration
+*//***************************************************************************/
+typedef enum e_FmInterModuleEvent {
+    e_FM_EV_PRS,                    /**< Parser event */
+    e_FM_EV_ERR_PRS,                /**< Parser error event */
+    e_FM_EV_KG,                     /**< Keygen event */
+    e_FM_EV_ERR_KG,                 /**< Keygen error event */
+    e_FM_EV_PLCR,                   /**< Policer event */
+    e_FM_EV_ERR_PLCR,               /**< Policer error event */
+    e_FM_EV_ERR_10G_MAC0,           /**< 10G MAC 0 error event */
+    e_FM_EV_ERR_1G_MAC0,            /**< 1G MAC 0 error event */
+    e_FM_EV_ERR_1G_MAC1,            /**< 1G MAC 1 error event */
+    e_FM_EV_ERR_1G_MAC2,            /**< 1G MAC 2 error event */
+    e_FM_EV_ERR_1G_MAC3,            /**< 1G MAC 3 error event */
+    e_FM_EV_TMR,                    /**< Timer event */
+    e_FM_EV_1G_MAC1,                /**< 1G MAC 1 event */
+    e_FM_EV_1G_MAC2,                /**< 1G MAC 2 event */
+    e_FM_EV_1G_MAC3,                /**< 1G MAC 3 event */
+    e_FM_EV_1G_MAC0_TMR,            /**< 1G MAC 0 Timer event */
+    e_FM_EV_1G_MAC1_TMR,            /**< 1G MAC 1 Timer event */
+    e_FM_EV_1G_MAC2_TMR,            /**< 1G MAC 2 Timer event */
+    e_FM_EV_1G_MAC3_TMR,            /**< 1G MAC 3 Timer event */
+    e_FM_EV_DUMMY_LAST
+} e_FmInterModuleEvent;
+
+#define GET_FM_MODULE_EVENT(mod, id, intrType, event)                                               \
+    switch(mod){                                                                                    \
+        case e_FM_MOD_PRS:                                                                          \
+            if (id) event = e_FM_EV_DUMMY_LAST;                                                     \
+            else event = (intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_ERR_PRS:e_FM_EV_PRS;            \
+            break;                                                                                  \
+        case e_FM_MOD_KG:                                                                           \
+            if (id) event = e_FM_EV_DUMMY_LAST;                                                     \
+            else event = (intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_ERR_KG:e_FM_EV_DUMMY_LAST;      \
+            break;                                                                                  \
+        case e_FM_MOD_PLCR:                                                                         \
+            if (id) event = e_FM_EV_DUMMY_LAST;                                                     \
+            else event = (intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_ERR_PLCR:e_FM_EV_PLCR;          \
+            break;                                                                                  \
+        case e_FM_MOD_10G_MAC:                                                                      \
+            if (id) event = e_FM_EV_DUMMY_LAST;                                                     \
+            else event = (intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_ERR_10G_MAC0:e_FM_EV_DUMMY_LAST;\
+            break;                                                                                  \
+        case e_FM_MOD_1G_MAC:                                                                       \
+            switch(id){                                                                             \
+                 case(0): event = (intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_ERR_1G_MAC0:e_FM_EV_DUMMY_LAST; break; \
+                 case(1): event = (intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_ERR_1G_MAC1:e_FM_EV_1G_MAC1; break;    \
+                 case(2): event = (intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_ERR_1G_MAC2:e_FM_EV_1G_MAC2; break;    \
+                 case(3): event = (intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_ERR_1G_MAC3:e_FM_EV_1G_MAC3; break;    \
+                 }                                                                                  \
+            break;                                                                                  \
+        case e_FM_MOD_TMR:                                                                          \
+            if (id) event = e_FM_EV_DUMMY_LAST;                                                     \
+            else event = (intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_DUMMY_LAST:e_FM_EV_TMR;         \
+            break;                                                                                  \
+        case e_FM_MOD_1G_MAC_TMR:                                                                   \
+            switch(id){                                                                             \
+                 case(0): event = (intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_DUMMY_LAST:e_FM_EV_1G_MAC0_TMR; break; \
+                 case(1): event = (intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_DUMMY_LAST:e_FM_EV_1G_MAC1_TMR; break; \
+                 case(2): event = (intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_DUMMY_LAST:e_FM_EV_1G_MAC2_TMR; break; \
+                 case(3): event = (intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_DUMMY_LAST:e_FM_EV_1G_MAC3_TMR; break; \
+                 }                                                                                  \
+            break;                                                                                  \
+        default:event = e_FM_EV_DUMMY_LAST;                                                         \
+        break;}
+
+#ifndef SIMULATOR
+#define FM_10G_MAC_NO_CTRL_LOOPBACK
+#define BUP_FM_10G_TX_ECC_FRMS_ERRATA
+#endif /* !SIMULATOR */
+
+/* FM erratas */
+#define FM_OP_PARTITION_ERRATA_FMAN16
+#define FM_RAM_LIST_ERR_IRQ_ERRATA_FMAN11
+#define FM_IRAM_ECC_ERR_IRQ_ERRATA
+#define FM_PORT_SYNC_ERRATA_FMAN6
+#define FM_PRS_MEM_ERRATA
+#define FM_IEEE_BAD_TS_ERRATA_IPG28055
+#define FM_HALT_SIG_ERRATA_GEN_CCB310
+#define FM_PRS_L4_SHELL_ERRATA
+#define FM_1G_SHORT_PAUSE_TIME_ERRATA_DTSEC1
+#define BUP_FM_LEN_CHECK_ERRATA
+#define BUP_FM_10G_REM_N_LCL_FLT_EX_ERRATA
+#define BUP_FM_MDIO_ERRATA
+
+
+#endif /* __DPAA_INTEGRATION_EXT_H */
diff --git a/drivers/net/dpa/NetCommSw/inc/integrations/P4080/part_integration_ext.h b/drivers/net/dpa/NetCommSw/inc/integrations/P4080/part_integration_ext.h
index 24ecc21..fecd7c3 100644
--- a/drivers/net/dpa/NetCommSw/inc/integrations/P4080/part_integration_ext.h
+++ b/drivers/net/dpa/NetCommSw/inc/integrations/P4080/part_integration_ext.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -39,8 +39,8 @@
 #ifndef __PART_INTEGRATION_EXT_H
 #define __PART_INTEGRATION_EXT_H
 
-//#include "ddr_std_ext.h"
-
+#include "std_ext.h"
+#include "dpaa_integration_ext.h"
 /**************************************************************************//**
  @Group         P4080_chip_id P4080 Application Programming Interface
 
@@ -49,6 +49,11 @@
  @{
 *//***************************************************************************/
 
+#define CORE_E500MC
+
+#define INTG_MAX_NUM_OF_CORES   8
+
+
 /**************************************************************************//**
  @Description   Module types.
 *//***************************************************************************/
@@ -97,6 +102,7 @@ typedef enum e_ModuleId
     e_MODULE_ID_BM_CI_PORTAL_7,
     e_MODULE_ID_BM_CI_PORTAL_8,
     e_MODULE_ID_FM1,                /**< Frame manager #1 module */
+    e_MODULE_ID_FM1_RTC,            /**< FM Real-Time-Clock */
     e_MODULE_ID_FM1_MURAM,          /**< FM Multi-User-RAM */
     e_MODULE_ID_FM1_BMI,            /**< FM BMI block */
     e_MODULE_ID_FM1_QMI,            /**< FM QMI block */
@@ -138,6 +144,7 @@ typedef enum e_ModuleId
     e_MODULE_ID_FM1_10GMAC0,        /**< FM 10G MAC #0 */
 
     e_MODULE_ID_FM2,                /**< Frame manager #2 module */
+    e_MODULE_ID_FM2_RTC,            /**< FM Real-Time-Clock */
     e_MODULE_ID_FM2_MURAM,          /**< FM Multi-User-RAM */
     e_MODULE_ID_FM2_BMI,            /**< FM BMI block */
     e_MODULE_ID_FM2_QMI,            /**< FM QMI block */
@@ -216,7 +223,8 @@ typedef enum e_TransSrc
 typedef enum e_P4080DeviceName
 {
     e_P4080_REV_INVALID   = 0x00000000,   /**< Invalid revision      */
-    e_P4080E_REV_1_0      = 0x82080010    /**< P4080E with security, revision 1.0 */
+    e_P4080E_REV_1_0      = 0x82080010,   /**< P4080E with security, revision 1.0 */
+    e_P4080E_REV_2_0      = 0x82080020    /**< P4080E with security, revision 2.0 */
 } e_P4080DeviceName;
 
 /**************************************************************************//**
@@ -225,7 +233,8 @@ typedef enum e_P4080DeviceName
 typedef struct
 {
     uint64_t        ccsrBaseAddress;        /**< CCSR base address (virtual) */
-    uint64_t        portalsBaseAddress;     /**< Portals base address (virtual) */
+    uint64_t        bmPortalsBaseAddress;   /**< Portals base address (virtual) */
+    uint64_t        qmPortalsBaseAddress;   /**< Portals base address (virtual) */
     bool            (*f_BoardIsValidSerDesConfigurationCB) (uint8_t val);
 } t_P4080Params;
 
@@ -292,7 +301,7 @@ t_Handle P4080_ConfigAndInit(t_P4080Params *p_P4080Params);
 t_Error P4080_Free(t_Handle h_P4080);
 
 /**************************************************************************//**
- @Function      P4080_GetModuleBase
+ @Function      P4080_GetModulePhysBase
 
  @Description   returns the base address of a P4080 module's
                 memory mapped registers.
@@ -303,7 +312,7 @@ t_Error P4080_Free(t_Handle h_P4080);
  @Return        Base address of module's memory mapped registers.
                 ILLEGAL_BASE in case of non-existent module
 *//***************************************************************************/
-uint64_t P4080_GetModuleBase(t_Handle h_P4080, e_ModuleId module);
+uint64_t P4080_GetModulePhysBase(t_Handle h_P4080, e_ModuleId module);
 
 /**************************************************************************//**
  @Function      P4080_GetRevInfo
@@ -380,6 +389,15 @@ uint32_t P4080_GetDdrFactor(t_Handle h_P4080);
 *//***************************************************************************/
 t_Error  P4080_GetFmFactor(t_Handle h_P4080, uint8_t fmIndex, uint32_t *p_FmMulFactor, uint32_t *p_FmDivFactor);
 
+/**************************************************************************//**
+ @Function      P4080_Reset
+
+ @Description   Reset the chip.
+
+ @Param[in]     h_P4080 - The handle of the initialized P4080 object.
+*//***************************************************************************/
+void P4080_Reset(t_Handle h_P4080);
+
 t_Error P4080_CoreTimeBaseEnable(t_Handle h_P4080);
 t_Error P4080_CoreTimeBaseDisable(t_Handle h_P4080);
 
@@ -402,12 +420,43 @@ t_Error P4080_DeviceEnable(t_Handle h_P4080,e_ModuleId module, bool enable);
 #define MODULE_P4080_PLTFRM     0x00060000
 #define MODULE_MMU              0x00070000
 #define MODULE_EPIC             0x00080000
-#define MODULE_FM               0x00090000
-#define MODULE_QM               0x000a0000
-#define MODULE_BM               0x000b0000
-#define MODULE_DUART            0x000c0000
-#define MODULE_SERDES           0x000d0000
-#define MODULE_PIO              0x000e0000
+#define MODULE_DUART            0x00090000
+#define MODULE_SERDES           0x000a0000
+#define MODULE_PIO              0x000b0000
+#define MODULE_QM               0x000c0000
+#define MODULE_BM               0x000d0000
+#define MODULE_FM               0x000e0000
+#define MODULE_FM_MURAM         0x000f0000
+#define MODULE_FM_PCD           0x00100000
+#define MODULE_FM_RTC           0x00110000
+#define MODULE_FM_MAC           0x00120000
+#define MODULE_FM_PORT          0x00130000
+
+/*****************************************************************************
+ LA INTEGRATION-SPECIFIC DEFINITIONS
+******************************************************************************/
+#define LA_NUM_OF_WINDOWS       32                      /**< Number of local access windows */
+
+/**************************************************************************//**
+ @Description   Local Access Window Target interface ID
+*//***************************************************************************/
+typedef enum e_LaTgtId
+{
+    e_LA_ID_PCIE1   = 0x00,  /**< PCI Express 1 target interface ID */
+    e_LA_ID_PCIE2   = 0x01,  /**< PCI Express 2 target interface ID */
+    e_LA_ID_PCIE3   = 0x02,  /**< PCI Express 3 target interface ID */
+    e_LA_ID_RIO1    = 0x08,  /**< RapidIO 1 target interface ID */
+    e_LA_ID_RIO2    = 0x09,  /**< RapidIO 2 target interface ID */
+    e_LA_ID_LS      = 0x0F,  /**< Local Space target interface ID */
+    e_LA_ID_MC1     = 0x10,  /**< DDR controller 1 or CPC1 SRAM target interface ID */
+    e_LA_ID_MC2     = 0x11,  /**< DDR controller 2 or CPC2 SRAM target interface ID */
+    e_LA_ID_IM      = 0x14,  /**< Interleaved DDR controllers or CPC SRAM target interface ID */
+    e_LA_ID_BMAN    = 0x18,  /**< BMAN target interface ID */
+    e_LA_ID_DCSR    = 0x1D,  /**< DCSR target interface ID */
+    e_LA_ID_LBC     = 0x1F,  /**< Local Bus target interface ID */
+    e_LA_ID_QMAN    = 0x3C,  /**< QMAN target interface ID */
+    e_LA_ID_NONE    = 0xFF  /**< None */
+} e_LaTgtId;
 
 /*****************************************************************************
  GPIO INTEGRATION-SPECIFIC DEFINITIONS
@@ -429,13 +478,13 @@ t_Error P4080_DeviceEnable(t_Handle h_P4080,e_ModuleId module, bool enable);
 /*****************************************************************************
  MPIC INTEGRATION-SPECIFIC DEFINITIONS
 ******************************************************************************/
-#define EPIC_MULTICORE_SUPPORT
+#define EPIC_MODE_MPIC
 
-/*****************************************************************************
- QMan INTEGRATION-SPECIFIC DEFINITIONS
-******************************************************************************/
-#define QMAN_WQ_CS_CFG_ERRATA
-#define QMAN_SFDR_LEAK_ERRATA
+#define EPIC_NUM_OF_EXT_INTRS           12
+#define EPIC_NUM_OF_INT_INTRS           112
+#define EPIC_NUM_OF_TIMERS              8
+#define EPIC_NUM_OF_MSG_INTRS           8
+#define EPIC_NUM_OF_SMSG_INTRS          24
 
 /*****************************************************************************
  SerDes INTEGRATION-SPECIFIC DEFINITIONS
@@ -444,106 +493,4 @@ t_Error P4080_DeviceEnable(t_Handle h_P4080,e_ModuleId module, bool enable);
 #define SERDES_ERRATA
 #endif /* !SIMULATOR */
 
-/*****************************************************************************
- FM INTEGRATION-SPECIFIC DEFINITIONS
-******************************************************************************/
-#define INTG_MAX_NUM_OF_FM          2
-
-#define FM_MAX_NUM_OF_1G_RX_PORTS   4
-#define FM_MAX_NUM_OF_10G_RX_PORTS  1
-#define FM_MAX_NUM_OF_RX_PORTS      (FM_MAX_NUM_OF_10G_RX_PORTS+FM_MAX_NUM_OF_1G_RX_PORTS)
-#define FM_MAX_NUM_OF_1G_TX_PORTS   4
-#define FM_MAX_NUM_OF_10G_TX_PORTS  1
-#define FM_MAX_NUM_OF_TX_PORTS      (FM_MAX_NUM_OF_10G_TX_PORTS+FM_MAX_NUM_OF_1G_TX_PORTS)
-#define FM_MAX_NUM_OF_OH_PORTS      7
-#define FM_MAX_NUM_OF_1G_MACS       (FM_MAX_NUM_OF_1G_RX_PORTS)
-#define FM_MAX_NUM_OF_10G_MACS      (FM_MAX_NUM_OF_10G_RX_PORTS)
-#define FM_MAX_NUM_OF_MACS          (FM_MAX_NUM_OF_1G_MACS+FM_MAX_NUM_OF_10G_MACS)
-#define FM_MAX_NUM_OF_PCD_PORTS     (FM_MAX_NUM_OF_RX_PORTS+FM_MAX_NUM_OF_OH_PORTS)
-
-#define FM_MURAM_SIZE               (160*KILOBYTE)
-#define FM_PCD_PLCR_NUM_ENTRIES     256                 /**< Total number of policer profiles */
-#define FM_PCD_KG_NUM_OF_SCHEMES    32                  /**< Total number of KG schemes */
-#define FM_PCD_MAX_NUM_OF_CLS_PLANS 256                 /**< Number of classification plan entries. */
-
-/**************************************************************************//**
- @Description   Enum for inter-module interrupts registration
-*//***************************************************************************/
-typedef enum e_FmEventModules{
-    e_FM_MOD_PRS,                   /**< Parser event */
-    e_FM_MOD_KG,                    /**< Keygen event */
-    e_FM_MOD_PLCR,                  /**< Policer event */
-    e_FM_MOD_10G_MAC,               /**< 10G MAC  error event */
-    e_FM_MOD_1G_MAC,                /**< 1G MAC  error event */
-    e_FM_MOD_TMR,                   /**< Timer event */
-    e_FM_MOD_1G_MAC_TMR,            /**< 1G MAC  Timer event */
-    e_FM_MOD_DUMMY_LAST
-} e_FmEventModules;
-
-/**************************************************************************//**
- @Description   Enum for interrupts types
-*//***************************************************************************/
-typedef enum e_FmIntrType {
-    e_FM_INTR_TYPE_ERR,
-    e_FM_INTR_TYPE_NORMAL
-}e_FmIntrType;
-
-#define GET_MODULE_EVENT(mod, id, intrType, event)                                                  \
-    switch(mod){                                                                                    \
-        case e_FM_MOD_PRS:                                                                          \
-            if (id) event = e_FM_EV_DUMMY_LAST;                                                     \
-            else event = (intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_ERR_PRS:e_FM_EV_PRS;            \
-            break;                                                                                  \
-        case e_FM_MOD_KG:                                                                           \
-            if (id) event = e_FM_EV_DUMMY_LAST;                                                     \
-            else event = (intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_ERR_KG:e_FM_EV_DUMMY_LAST;      \
-            break;                                                                                  \
-        case e_FM_MOD_PLCR:                                                                         \
-            if (id) event = e_FM_EV_DUMMY_LAST;                                                     \
-            else event = (intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_ERR_PLCR:e_FM_EV_PLCR;          \
-            break;                                                                                  \
-        case e_FM_MOD_10G_MAC:                                                                      \
-            if (id) event = e_FM_EV_DUMMY_LAST;                                                     \
-            else event = (intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_ERR_10G_MAC0:e_FM_EV_DUMMY_LAST;\
-            break;                                                                                  \
-        case e_FM_MOD_1G_MAC:                                                                       \
-            switch(id){                                                                             \
-                 case(0): event = (intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_ERR_1G_MAC0:e_FM_EV_DUMMY_LAST; break; \
-                 case(1): event = (intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_ERR_1G_MAC1:e_FM_EV_1G_MAC1; break;    \
-                 case(2): event = (intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_ERR_1G_MAC2:e_FM_EV_1G_MAC2; break;    \
-                 case(3): event = (intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_ERR_1G_MAC3:e_FM_EV_1G_MAC3; break;    \
-                 }                                                                                  \
-            break;                                                                                  \
-        case e_FM_MOD_TMR:                                                                          \
-            if (id) event = e_FM_EV_DUMMY_LAST;                                                     \
-            else event = (intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_DUMMY_LAST:e_FM_EV_TMR;         \
-            break;                                                                                  \
-        case e_FM_MOD_1G_MAC_TMR:                                                                   \
-            switch(id){                                                                             \
-                 case(0): event = (intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_DUMMY_LAST:e_FM_EV_1G_MAC0_TMR; break; \
-                 case(1): event = (intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_DUMMY_LAST:e_FM_EV_1G_MAC1_TMR; break; \
-                 case(2): event = (intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_DUMMY_LAST:e_FM_EV_1G_MAC2_TMR; break; \
-                 case(3): event = (intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_DUMMY_LAST:e_FM_EV_1G_MAC3_TMR; break; \
-                 }                                                                                  \
-            break;                                                                                  \
-        default:event = e_FM_EV_DUMMY_LAST;                                                         \
-        break;}
-
-#ifndef SIMULATOR
-#define FM_10G_MAC_NO_CTRL_LOOPBACK
-#endif /* !SIMULATOR */
-
-/* FM erratas */
-#define FM_OP_PARTITION_ERRATA
-#ifndef SIMULATOR
-#define FM_ENET_PAUSE_FRM_ERRATA
-#define FM_MURAM_ERR_IRQ_ERRATA
-#define FM_PORT_SYNC_ERRATA
-#define FM_PRS_MEM_ERRATA
-#define BUP_FM_PORT_DISABLE_ERRATA
-#define BUP_FM_HALT_SIG_ERRATA
-#define BUP_ERRATA_RAM_INTR
-#endif /* !SIMULATOR */
-
-
 #endif /* __PART_INTEGRATION_EXT_H */
diff --git a/drivers/net/dpa/NetCommSw/inc/integrations/part_ext.h b/drivers/net/dpa/NetCommSw/inc/integrations/part_ext.h
index 427f262..3d5efdd 100644
--- a/drivers/net/dpa/NetCommSw/inc/integrations/part_ext.h
+++ b/drivers/net/dpa/NetCommSw/inc/integrations/part_ext.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -50,8 +50,12 @@
       defined(MPC837x) || \
       defined(MPC8568) || \
       defined(MPC8569) || \
-      defined(P4080)   || \
+      defined(P1020)   || \
+      defined(P1021)   || \
+      defined(P1022)   || \
+      defined(SC1023)  || \
       defined(P2020)   || \
+      defined(P4080)   || \
       defined(MSC814x))
 #error "unable to proceed without chip-definition"
 #endif /* !(defined(MPC834x) || ... */
diff --git a/drivers/net/dpa/NetCommSw/inc/math_ext.h b/drivers/net/dpa/NetCommSw/inc/math_ext.h
index 59f0533..80cf247 100644
--- a/drivers/net/dpa/NetCommSw/inc/math_ext.h
+++ b/drivers/net/dpa/NetCommSw/inc/math_ext.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/drivers/net/dpa/NetCommSw/inc/ncsw_ext.h b/drivers/net/dpa/NetCommSw/inc/ncsw_ext.h
index 4d8449f..9652c11 100644
--- a/drivers/net/dpa/NetCommSw/inc/ncsw_ext.h
+++ b/drivers/net/dpa/NetCommSw/inc/ncsw_ext.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -122,8 +122,8 @@
 /* Ceiling division - not the fastest way, but safer in terms of overflow */
 #define DIV_CEIL(x,y)   ((uint32_t)((x)/(y)) + (((((uint32_t)((x)/(y)))*(y)) == (x)) ? 0 : 1))
 
-/* Round division */
-#define DIV_ROUND(x,y)  (((x)+((y)>>1))/(y))
+/* Round up a number to be a multiple of a second number */
+#define ROUND_UP(x,y)   ((((x) + (y) - 1) / (y)) * (y))
 
 /* Timing macro for converting usec units to number of ticks.   */
 /* (number of usec *  clock_Hz) / 1,000,000) - since            */
@@ -159,6 +159,9 @@
 #define WORD_ALIGNED            0x00000003
 #define DOUBLE_WORD_ALIGNED     0x00000007
 #define BURST_ALIGNED           0x0000001f
+#ifndef IS_ALIGNED
+#define IS_ALIGNED(n,align)     (!((uint32_t)(n) & (align - 1)))
+#endif /* IS_ALIGNED */
 
 
 #define LAST_BUF        1
@@ -206,16 +209,14 @@ typedef enum e_CommMode
 *//***************************************************************************/
 typedef enum e_DiagMode
 {
-    e_DIAG_MODE_NONE = 0,
-    e_DIAG_MODE_CTRL_LOOPBACK,      /**< loopback in the controller; E.g. MAC, TDM, etc. */
-#ifdef P4080
-    e_DIAG_MODE_CHIP_LOOPBACK,      /**< loopback in the chip but not in controller;
-                                         E.g. IO-pins, SerDes, etc. */
-#endif /* P4080 */
-    e_DIAG_MODE_PHY_LOOPBACK,       /**< loopback in the external PHY */
-    e_DIAG_MODE_LINE_LOOPBACK,      /**< loopback in the external line */
-    e_DIAG_MODE_CTRL_ECHO,          /**< */
-    e_DIAG_MODE_PHY_ECHO            /**< */
+    e_DIAG_MODE_NONE = 0,       /**< Normal operation; no diagnostic mode */
+    e_DIAG_MODE_CTRL_LOOPBACK,  /**< Loopback in the controller */
+    e_DIAG_MODE_CHIP_LOOPBACK,  /**< Loopback in the chip but not in the
+                                     controller; e.g. IO-pins, SerDes, etc. */
+    e_DIAG_MODE_PHY_LOOPBACK,   /**< Loopback in the external PHY */
+    e_DIAG_MODE_EXT_LOOPBACK,   /**< Loopback in the external line */
+    e_DIAG_MODE_CTRL_ECHO,      /**< Echo incoming data by the controller */
+    e_DIAG_MODE_PHY_ECHO        /**< Echo incoming data by the PHY */
 } e_DiagMode;
 
 /**************************************************************************//**
diff --git a/drivers/net/dpa/NetCommSw/inc/net_ext.h b/drivers/net/dpa/NetCommSw/inc/net_ext.h
index 996bd92..b49d42f 100644
--- a/drivers/net/dpa/NetCommSw/inc/net_ext.h
+++ b/drivers/net/dpa/NetCommSw/inc/net_ext.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/drivers/net/dpa/NetCommSw/inc/std_ext.h b/drivers/net/dpa/NetCommSw/inc/std_ext.h
index ff4698a..69ad0f3 100644
--- a/drivers/net/dpa/NetCommSw/inc/std_ext.h
+++ b/drivers/net/dpa/NetCommSw/inc/std_ext.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/drivers/net/dpa/NetCommSw/inc/stdarg_ext.h b/drivers/net/dpa/NetCommSw/inc/stdarg_ext.h
index 091bd60..f08e527 100644
--- a/drivers/net/dpa/NetCommSw/inc/stdarg_ext.h
+++ b/drivers/net/dpa/NetCommSw/inc/stdarg_ext.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/drivers/net/dpa/NetCommSw/inc/stdlib_ext.h b/drivers/net/dpa/NetCommSw/inc/stdlib_ext.h
index 43b1d77..cdff51d 100644
--- a/drivers/net/dpa/NetCommSw/inc/stdlib_ext.h
+++ b/drivers/net/dpa/NetCommSw/inc/stdlib_ext.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/drivers/net/dpa/NetCommSw/inc/string_ext.h b/drivers/net/dpa/NetCommSw/inc/string_ext.h
index b9aa8f2..45190b8 100644
--- a/drivers/net/dpa/NetCommSw/inc/string_ext.h
+++ b/drivers/net/dpa/NetCommSw/inc/string_ext.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/drivers/net/dpa/NetCommSw/inc/types_ext.h b/drivers/net/dpa/NetCommSw/inc/types_ext.h
index 4a993d4..73aaa68 100644
--- a/drivers/net/dpa/NetCommSw/inc/types_ext.h
+++ b/drivers/net/dpa/NetCommSw/inc/types_ext.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -59,35 +59,38 @@
 
 static __inline__ void TypesChecker(void)
 {
-#ifdef __MWERKS__
+#if defined(__MWERKS__) && !defined(__GNUC__)
 #pragma pack(push,1)
-#endif /*__MWERKS__ */
+#endif /* defined(__MWERKS__) && ... */
 #define MEM_MAP_START
      _Packed struct strct {
         __volatile__ int vi;
     } _PackedType;
 #define MEM_MAP_END
-#ifdef __MWERKS__
+#if defined(__MWERKS__) && !defined(__GNUC__)
 #pragma pack(pop)
-#endif /* __MWERKS__ */
-    size_t          size=0;
-    int             on=ON, off=OFF;
-    bool            tr=TRUE,fls=FALSE;
+#endif /* defined(__MWERKS__) && ... */
+    size_t          size = 0;
+    int             on = ON, off = OFF;
+    bool            tr = TRUE, fls = FALSE;
     struct strct    *p_Strct = NULL;
+    physAddress_t   addr = 0x100;
 
-    on=off;
-    tr=fls;
-    p_Strct=p_Strct;
+    on      = off;
+    tr      = fls;
+    p_Strct = p_Strct;
     size++;
 
-    WRITE_UINT8(*(uint8_t *)UINT8_MAX, GET_UINT8(*(uint8_t *)UINT8_MIN));
+    WRITE_UINT8 (*(uint8_t  *)addr,  GET_UINT8 (*(uint8_t  *)addr ));
+
+    WRITE_UINT8 (*(uint8_t  *)UINT8_MAX,  GET_UINT8 (*(uint8_t  *)UINT8_MIN ));
     WRITE_UINT16(*(uint16_t *)UINT16_MAX, GET_UINT16(*(uint16_t *)UINT16_MIN));
     WRITE_UINT32(*(uint32_t *)UINT32_MAX, GET_UINT32(*(uint32_t *)UINT32_MIN));
     WRITE_UINT64(*(uint64_t *)UINT64_MAX, GET_UINT64(*(uint64_t *)UINT64_MIN));
-    WRITE_UINT8(*(uint8_t *)INT8_MAX, GET_UINT8(*(uint8_t *)UINT8_MIN));
-    WRITE_UINT16(*(uint16_t *)INT16_MAX, GET_UINT16(*(uint16_t *)INT16_MIN));
-    WRITE_UINT32(*(uint32_t *)INT32_MAX, GET_UINT32(*(uint32_t *)INT32_MIN));
-    WRITE_UINT64(*(uint64_t *)INT64_MAX, GET_UINT64(*(uint64_t *)INT64_MIN));
+    WRITE_UINT8 (*(uint8_t  *)INT8_MAX,   GET_UINT8 (*(uint8_t  *)UINT8_MIN ));
+    WRITE_UINT16(*(uint16_t *)INT16_MAX,  GET_UINT16(*(uint16_t *)INT16_MIN ));
+    WRITE_UINT32(*(uint32_t *)INT32_MAX,  GET_UINT32(*(uint32_t *)INT32_MIN ));
+    WRITE_UINT64(*(uint64_t *)INT64_MAX,  GET_UINT64(*(uint64_t *)INT64_MIN ));
 }
 
 
diff --git a/drivers/net/dpa/NetCommSw/inc/xx_ext.h b/drivers/net/dpa/NetCommSw/inc/xx_ext.h
index 5adca3c..4a839f6 100644
--- a/drivers/net/dpa/NetCommSw/inc/xx_ext.h
+++ b/drivers/net/dpa/NetCommSw/inc/xx_ext.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -47,6 +47,7 @@
 #include "xx_integration_ext.h"
 #endif /* defined(__MWERKS__) && defined(OPTIMIZED_FOR_SPEED) */
 
+
 /**************************************************************************//**
  @Group         xx_id  XX Interface (System call hooks)
 
@@ -78,7 +79,6 @@ void XX_EventById(uint32_t event, t_Handle appId, uint16_t flags, char *msg);
 
 
 #ifdef DEBUG_XX_MALLOC
-
 void * XX_MallocDebug(uint32_t size, char *fname, int line);
 
 void * XX_MallocSmartDebug(uint32_t size,
@@ -94,7 +94,6 @@ void * XX_MallocSmartDebug(uint32_t size,
     XX_MallocSmartDebug((sz), (memt), (al), __FILE__, __LINE__)
 
 #else /* not DEBUG_XX_MALLOC */
-
 /**************************************************************************//**
  @Function      XX_Malloc
 
@@ -120,7 +119,6 @@ void * XX_Malloc(uint32_t size);
  @Return        The address of the newly allocated block on success, NULL on failure.
 *//***************************************************************************/
 void * XX_MallocSmart(uint32_t size, int memPartitionId, uint32_t alignment);
-
 #endif /* not DEBUG_XX_MALLOC */
 
 /**************************************************************************//**
@@ -230,18 +228,21 @@ t_Error XX_DisableIntr(int irq);
 /**************************************************************************//**
  @Function      XX_DisableAllIntr
 
- @Description   Disable interrupts by writing to MSR register at the CPU.
+ @Description   Disable all interrupts by masking them at the CPU.
 
- @Return        intMASK a value that represent the interurupt mask before operation
+ @Return        A value that represents the interrupts state before the
+                operation, and should be passed to the matching
+                XX_RestoreAllIntr() call.
 *//***************************************************************************/
 uint32_t XX_DisableAllIntr(void);
 
 /**************************************************************************//**
  @Function      XX_RestoreAllIntr
 
- @Description   Enable interrupts by writing to MSR register at the CPU.
+ @Description   Restore previous state of interrupts level at the CPU.
 
- @Param[in]     flags           - intMASK, mask of previos level function will set the mask based on it.
+ @Param[in]     flags - A value that represents the interrupts state to restore,
+                        as returned by the matching call for XX_DisableAllIntr().
 
  @Return        None.
 *//***************************************************************************/
@@ -511,7 +512,6 @@ void XX_Unlock(t_MutexHandle h_Mutex);
 /*****************************************************************************/
 /*                        Spinlock Service Routines                          */
 /*****************************************************************************/
-typedef t_Handle t_SpinlockHandle;
 
 /**************************************************************************//**
  @Function      XX_InitSpinlock
@@ -520,7 +520,7 @@ typedef t_Handle t_SpinlockHandle;
 
  @Return        Spinlock handle is returned on success; NULL otherwise.
 *//***************************************************************************/
-t_SpinlockHandle  XX_InitSpinlock(void);
+t_Handle XX_InitSpinlock(void);
 
 /**************************************************************************//**
  @Function      XX_FreeSpinlock
@@ -531,10 +531,10 @@ t_SpinlockHandle  XX_InitSpinlock(void);
 
  @Return        None.
 *//***************************************************************************/
-void XX_FreeSpinlock(t_SpinlockHandle h_Spinlock);
+void XX_FreeSpinlock(t_Handle h_Spinlock);
 
 /**************************************************************************//**
- @Function      XX_Spinlock
+ @Function      XX_LockSpinlock
 
  @Description   Locks a spinlock.
 
@@ -542,10 +542,10 @@ void XX_FreeSpinlock(t_SpinlockHandle h_Spinlock);
 
  @Return        None.
 *//***************************************************************************/
-void XX_Spinlock(t_SpinlockHandle h_Spinlock);
+void XX_LockSpinlock(t_Handle h_Spinlock);
 
 /**************************************************************************//**
- @Function      XX_Spinunlock
+ @Function      XX_UnlockSpinlock
 
  @Description   Unlocks a spinlock.
 
@@ -553,35 +553,39 @@ void XX_Spinlock(t_SpinlockHandle h_Spinlock);
 
  @Return        None.
 *//***************************************************************************/
-void XX_Spinunlock(t_SpinlockHandle h_Spinlock);
+void XX_UnlockSpinlock(t_Handle h_Spinlock);
 
 /**************************************************************************//**
- @Function      XX_IntrSpinlock
+ @Function      XX_LockIntrSpinlock
 
  @Description   Locks a spinlock (interrupt safe).
 
  @Param[in]     h_Spinlock - A handle to a spinlock.
 
- @Return        None.
+ @Return        A value that represents the interrupts state before the
+                operation, and should be passed to the matching
+                XX_UnlockIntrSpinlock() call.
 *//***************************************************************************/
-void XX_IntrSpinlock(t_SpinlockHandle h_Spinlock);
+uint32_t XX_LockIntrSpinlock(t_Handle h_Spinlock);
 
 /**************************************************************************//**
- @Function      XX_IntrSpinunlock
+ @Function      XX_UnlockIntrSpinlock
 
  @Description   Unlocks a spinlock (interrupt safe).
 
- @Param[in]     h_Spinlock - A handle to a spinlock.
+ @Param[in]     h_Spinlock  - A handle to a spinlock.
+ @Param[in]     intrFlags   - A value that represents the interrupts state to
+                              restore, as returned by the matching call for
+                              XX_LockIntrSpinlock().
 
  @Return        None.
 *//***************************************************************************/
-void XX_IntrSpinunlock(t_SpinlockHandle h_Spinlock);
+void XX_UnlockIntrSpinlock(t_Handle h_Spinlock, uint32_t intrFlags);
 
 
 /*****************************************************************************/
 /*                        Timers Service Routines                            */
 /*****************************************************************************/
-typedef t_Handle t_TimerHandle;
 
 /**************************************************************************//**
  @Function      XX_CurrentTime
@@ -599,7 +603,7 @@ uint32_t XX_CurrentTime(void);
 
  @Return        Timer handle is returned on success; NULL otherwise.
 *//***************************************************************************/
-t_TimerHandle XX_CreateTimer(void);
+t_Handle XX_CreateTimer(void);
 
 /**************************************************************************//**
  @Function      XX_FreeTimer
@@ -610,7 +614,7 @@ t_TimerHandle XX_CreateTimer(void);
 
  @Return        None.
 *//***************************************************************************/
-void XX_FreeTimer(t_TimerHandle h_Timer);
+void XX_FreeTimer(t_Handle h_Timer);
 
 /**************************************************************************//**
  @Function      XX_StartTimer
@@ -632,11 +636,11 @@ void XX_FreeTimer(t_TimerHandle h_Timer);
 
  @Return        None.
 *//***************************************************************************/
-void XX_StartTimer(t_TimerHandle    h_Timer,
-                   uint32_t         msecs,
-                   bool             periodic,
-                   void             (*f_TimerExpired)(t_Handle h_Arg),
-                   t_Handle         h_Arg);
+void XX_StartTimer(t_Handle h_Timer,
+                   uint32_t msecs,
+                   bool     periodic,
+                   void     (*f_TimerExpired)(t_Handle h_Arg),
+                   t_Handle h_Arg);
 
 /**************************************************************************//**
  @Function      XX_StopTimer
@@ -647,7 +651,7 @@ void XX_StartTimer(t_TimerHandle    h_Timer,
 
  @Return        None.
 *//***************************************************************************/
-void XX_StopTimer(t_TimerHandle h_Timer);
+void XX_StopTimer(t_Handle h_Timer);
 
 /**************************************************************************//**
  @Function      XX_GetExpirationTime
@@ -659,7 +663,7 @@ void XX_StopTimer(t_TimerHandle h_Timer);
 
  @Return        The time left until the timer expires.
 *//***************************************************************************/
-uint32_t XX_GetExpirationTime(t_TimerHandle h_Timer);
+uint32_t XX_GetExpirationTime(t_Handle h_Timer);
 
 /**************************************************************************//**
  @Function      XX_ModTimer
@@ -675,7 +679,7 @@ uint32_t XX_GetExpirationTime(t_TimerHandle h_Timer);
 
  @Return        None.
 *//***************************************************************************/
-void XX_ModTimer(t_TimerHandle h_Timer, uint32_t msecs);
+void XX_ModTimer(t_Handle h_Timer, uint32_t msecs);
 
 /**************************************************************************//**
  @Function      XX_TimerIsActive
@@ -686,7 +690,7 @@ void XX_ModTimer(t_TimerHandle h_Timer, uint32_t msecs);
 
  @Return        0 - the timer is inactive; Non-zero value - the timer is active;
 *//***************************************************************************/
-int XX_TimerIsActive(t_TimerHandle h_Timer);
+int XX_TimerIsActive(t_Handle h_Timer);
 
 /**************************************************************************//**
  @Function      XX_Sleep
@@ -731,7 +735,7 @@ void XX_UDelay(uint32_t usecs);
 
  @Return        Virtual address.
 *//***************************************************************************/
-void * XX_PhysToVirt(void *addr);
+void * XX_PhysToVirt(physAddress_t addr);
 
 /**************************************************************************//**
  @Function      XX_VirtToPhys
@@ -742,11 +746,9 @@ void * XX_PhysToVirt(void *addr);
 
  @Return        Physical address.
 *//***************************************************************************/
-void * XX_VirtToPhys(void *addr);
-
-#define XXX_PhysToVirt(addr)  (CAST_POINTER_TO_UINT32(XX_PhysToVirt(CAST_UINT32_TO_POINTER(addr))))
-#define XXX_VirtToPhys(addr)  (CAST_POINTER_TO_UINT32(XX_VirtToPhys(CAST_UINT32_TO_POINTER(addr))))
+physAddress_t XX_VirtToPhys(void *addr);
 
+#define XXX_VirtToPhys(addr)  XX_VirtToPhys(CAST_UINT32_TO_POINTER(addr))
 
 #define MSG_BODY_SIZE       512
 #ifdef CONFIG_MULTI_PARTITION_SUPPORT
diff --git a/drivers/net/dpa/NetCommSw/integrations/P4080/Makefile b/drivers/net/dpa/NetCommSw/integrations/P4080/Makefile
index 4932179..6241a44 100644
--- a/drivers/net/dpa/NetCommSw/integrations/P4080/Makefile
+++ b/drivers/net/dpa/NetCommSw/integrations/P4080/Makefile
@@ -7,5 +7,3 @@ EXTRA_CFLAGS           += -DVERSION=\"\"
 include $(srctree)/drivers/net/dpa/NetCommSw/ncsw_config.mk
 
 obj-y		+= module_strings.o
-
-
diff --git a/drivers/net/dpa/NetCommSw/integrations/P4080/module_strings.c b/drivers/net/dpa/NetCommSw/integrations/P4080/module_strings.c
index 03d0cd2..8e07b61 100644
--- a/drivers/net/dpa/NetCommSw/integrations/P4080/module_strings.c
+++ b/drivers/net/dpa/NetCommSw/integrations/P4080/module_strings.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -42,8 +42,15 @@ const char *moduleStrings[] =
     ,"P4080-Pltaform"           /* MODULE_P4080_PLTFRM */
     ,"MMU"                      /* MODULE_MMU */
     ,"MPIC"                     /* MODULE_MPIC */
-    ,"FM"                       /* MODULE_FM */
+    ,"DUART"                    /* MODULE_DUART */
+    ,"SerDes"                   /* MODULE_SERDES */
+    ,"PIO"                      /* MODULE_PIO */
     ,"QM"                       /* MODULE_QM */
     ,"BM"                       /* MODULE_BM */
-    ,"DUART"                    /* MODULE_DUART */
+    ,"FM"                       /* MODULE_FM */
+    ,"FM-MURAM"                 /* MODULE_FM_MURAM */
+    ,"FM-PCD"                   /* MODULE_FM_PCD */
+    ,"FM-RTC"                   /* MODULE_FM_RTC */
+    ,"FM-MAC"                   /* MODULE_FM_MAC */
+    ,"FM-Port"                  /* MODULE_FM_PORT */
 };
diff --git a/drivers/net/dpa/NetCommSw/ncsw_config.mk b/drivers/net/dpa/NetCommSw/ncsw_config.mk
index 2702f1f..4931c5e 100644
--- a/drivers/net/dpa/NetCommSw/ncsw_config.mk
+++ b/drivers/net/dpa/NetCommSw/ncsw_config.mk
@@ -9,6 +9,7 @@ EXTRA_CFLAGS +=-include $(NCSW)/dflags.h
 
 EXTRA_CFLAGS += -I$(DRV_DPA)/
 EXTRA_CFLAGS += -I$(NCSW)/inc
+EXTRA_CFLAGS += -I$(NCSW)/inc/cores
 EXTRA_CFLAGS += -I$(NCSW)/inc/etc
 EXTRA_CFLAGS += -I$(NCSW)/inc/Peripherals
 EXTRA_CFLAGS += -I$(NCSW)/inc/integrations
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/Peripherals/fm_ioctls.h b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/Peripherals/fm_ioctls.h
index 90a7837..9108d0d 100644
--- a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/Peripherals/fm_ioctls.h
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/Peripherals/fm_ioctls.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/Peripherals/fm_pcd_ioctls.h b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/Peripherals/fm_pcd_ioctls.h
index f5f3b77..616661f 100644
--- a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/Peripherals/fm_pcd_ioctls.h
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/Peripherals/fm_pcd_ioctls.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -170,10 +170,10 @@ typedef enum ioc_fm_pcd_counters {
  @Description   PCD interrupts
 *//***************************************************************************/
 typedef enum ioc_fm_pcd_exceptions {
-    e_IOC_FM_PCD_KG_ERR_EXCEPTION_DOUBLE_ECC,                   /**< Keygen ECC error */
-    e_IOC_FM_PCD_PLCR_ERR_EXCEPTION_DOUBLE_ECC,                 /**< Read Buffer ECC error */
-    e_IOC_FM_PCD_KG_ERR_EXCEPTION_KEYSIZE_OVERFLOW,             /**< Write Buffer ECC error on system side */
-    e_IOC_FM_PCD_PLCR_ERR_EXCEPTION_INIT_ENTRY_ERROR,           /**< Write Buffer ECC error on FM side */
+    e_IOC_FM_PCD_KG_EXCEPTION_DOUBLE_ECC,                   /**< Keygen ECC error */
+    e_IOC_FM_PCD_PLCR_EXCEPTION_DOUBLE_ECC,                 /**< Read Buffer ECC error */
+    e_IOC_FM_PCD_KG_EXCEPTION_KEYSIZE_OVERFLOW,             /**< Write Buffer ECC error on system side */
+    e_IOC_FM_PCD_PLCR_EXCEPTION_INIT_ENTRY_ERROR,           /**< Write Buffer ECC error on FM side */
     e_IOC_FM_PCD_PLCR_EXCEPTION_PRAM_SELF_INIT_COMPLETE,        /**< Self init complete */
     e_IOC_FM_PCD_PLCR_EXCEPTION_ATOMIC_ACTION_COMPLETE,         /**< Atomic action complete */
     e_IOC_FM_PCD_PRS_EXCEPTION_DOUBLE_ECC,                      /**< Parser ECC error */
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/Peripherals/fm_port_ioctls.h b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/Peripherals/fm_port_ioctls.h
index 087eade..2101b3f 100644
--- a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/Peripherals/fm_port_ioctls.h
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/Peripherals/fm_port_ioctls.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/Peripherals/fm_test_ioctls.h b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/Peripherals/fm_test_ioctls.h
index 7cb27c3..0c39267 100644
--- a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/Peripherals/fm_test_ioctls.h
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/Peripherals/fm_test_ioctls.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/integrations/P4080/integration_ioctls.h b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/integrations/P4080/integration_ioctls.h
index 5396f3c..5385e0a 100644
--- a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/integrations/P4080/integration_ioctls.h
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/integrations/P4080/integration_ioctls.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/ioctls.h b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/ioctls.h
index f138450..fbcd416 100644
--- a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/ioctls.h
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/ioctls.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/net_ioctls.h b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/net_ioctls.h
index c26e6d4..25d6c8d 100644
--- a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/net_ioctls.h
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/net_ioctls.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/procbuff_ext.h b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/procbuff_ext.h
index d50ffb0..6ee6450 100644
--- a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/procbuff_ext.h
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/procbuff_ext.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/system/platform_ext.h b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/system/platform_ext.h
index 5dcef2d..40e513a 100644
--- a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/system/platform_ext.h
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/system/platform_ext.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -183,6 +183,7 @@ t_Handle PLATFORM_Init(struct t_PlatformParam *p_PlatformParam);
 
 t_Error  PLATFORM_Free(t_Handle h_Platform);
 
+t_Error  PLATFORM_ConnectExternalRequest(t_Handle h_Platform, e_SysModule module,uint8_t extReqNum);
 
 t_Error  PLATFORM_GetChipRevInfo(t_Handle h_Platform, t_ChipRevInfo *p_ChipRevInfo);
 
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/system/platform_p4080_ds_ext.h b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/system/platform_p4080_ds_ext.h
index a611e48..9b9a22c 100644
--- a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/system/platform_p4080_ds_ext.h
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/system/platform_p4080_ds_ext.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/system/sys_ext.h b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/system/sys_ext.h
index e695033..6c0ca4e 100644
--- a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/system/sys_ext.h
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/system/sys_ext.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -36,6 +36,31 @@
 #include "std_ext.h"
 
 
+/**************************************************************************//**
+ @Group         sys_grp     System Interfaces
+
+ @Description   Linux system programming interfaces.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Group         sys_gen_grp     System General Interface
+
+ @Description   General definitions, structures and routines of the linux
+                system programming interface.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description   System Modules and Sub-Modules Enumeration
+
+                This enumeration type is expected by most system routines in
+                order to identify the type of the referenced module or sub-module.
+                The lower values of this enumeration type are modules, and the
+                higher values are sub-modules.
+*//***************************************************************************/
 typedef enum e_SysModule
 {
     e_SYS_MODULE_NONE = 0,
@@ -100,9 +125,11 @@ typedef enum e_SysModule
     e_SYS_MODULE_MPC8568_RIO_DEV,
     e_SYS_MODULE_MPC8568_PCI_DEV,
     e_SYS_MODULE_MPC836X_PCI_DEV,
+    e_SYS_MODULE_MPC837x_PCI_DEV,
     e_SYS_MODULE_MPC832X_PCI_DEV,
     e_SYS_MODULE_MPC8568_PCIE_DEV,
     e_SYS_MODULE_MPC8569_PCIE_DEV,
+    e_SYS_MODULE_MPC837x_PCIE_DEV,
     e_SYS_MODULE_MPC8568_SPI_FLASH_DEV,
     e_SYS_MODULE_MPC8568_SPI_LB_DEV,
     e_SYS_MODULE_SD_DEV,
@@ -135,6 +162,7 @@ typedef enum e_SysModule
     e_SYS_SUBMODULE_QE_TIMERS,
     e_SYS_SUBMODULE_GTIMERS,
     e_SYS_SUBMODULE_PAR_IO,
+    e_SYS_SUBMODULE_GPIO,
     e_SYS_SUBMODULE_SI,
     e_SYS_SUBMODULE_TDM,
     e_SYS_SUBMODULE_TDM_RX_FRAME,
@@ -209,6 +237,7 @@ typedef enum e_SysModule
     e_SYS_SUBMODULE_IW_IP_REASS,
     e_SYS_SUBMODULE_IW_PLCR,
     e_SYS_SUBMODULE_IW_QM,
+    e_SYS_SUBMODULE_IW_IPSEC,
     e_SYS_SUBMODULE_QE_FILTER,
     e_SYS_SUBMODULE_QE_TABLE,
     e_SYS_SUBMODULE_QE_RTC,
@@ -216,6 +245,8 @@ typedef enum e_SysModule
     e_SYS_SUBMODULE_VP_PORT,
     e_SYS_SUBMODULE_MII_MNG,
     e_SYS_SUBMODULE_PTP,
+    e_SYS_SUBMODULE_SATA,
+    e_SYS_SUBMODULE_SERDES,
     e_SYS_SUBMODULE_BM,
     e_SYS_SUBMODULE_BM_PORTAL,
     e_SYS_SUBMODULE_BM_CE_PORTAL,
@@ -282,6 +313,457 @@ static __inline__ t_Handle SYS_GetUniqueHandle(e_SysModule module)
 }
 
 /**************************************************************************//**
+ @Description   System Object Descriptor
+
+                This is the generic object descriptor for the system layout.
+                It contains only the module enumeration type, according to
+                which the system can decide whether this is a module descriptor
+                or a sub-module descriptor.
+*//***************************************************************************/
+typedef struct t_SysObjectDescriptor
+{
+    e_SysModule module; /**< Module/sub-module type */
+
+} t_SysObjectDescriptor;
+
+/**************************************************************************//**
+ @Description   Module initialization function (with no parameters)
+*//***************************************************************************/
+typedef t_Handle (t_SysModuleInitFuncNoParams)(void);
+
+/**************************************************************************//**
+ @Description   Module initialization function (with pointer to parameters)
+*//***************************************************************************/
+typedef t_Handle (t_SysModuleInitFuncWithParams)(void *p_ModuleParams);
+
+/**************************************************************************//**
+ @Description   System Module Descriptor
+
+                This structure should be used in the use case layout to request
+                initialization of a module object.
+
+                A module is by definition a singleton object, therefore no ID
+                is required in this structure.
+*//***************************************************************************/
+typedef struct t_SysModuleDescriptor
+{
+    e_SysModule module;                     /**< Module type */
+    void        *p_Settings;                /**< Pointer to the module's settings */
+
+    struct
+    {
+        union
+        {
+            t_SysModuleInitFuncNoParams     *f_InitNoParams;
+                                            /**< Module initialization routine (with no parameters) */
+            t_SysModuleInitFuncWithParams   *f_InitWithParams;
+                                            /**< Module initialization routine (with parameters) */
+        } cbs;
+        t_Error                             (*f_Free)(t_Handle h_Module);
+                                            /**< Module free routine */
+    } moduleInterface;
+
+} t_SysModuleDescriptor;
+
+
+/**************************************************************************//**
+ @Description   System Sub-Module Descriptor
+
+                This structure should be used in the use case layout to request
+                initialization of a sub-module object.
+
+                There may be multiple objects of the same sub-module type,
+                therefore the ID variable must be unique for each instance of
+                the same type.
+
+                The f_UpdateSettings callback routine and the idIncrement value
+                may be used to clone multiple objects of the same type. If the
+                callback is not NULL, the system shall call this routine to
+                generate a new settings structure for the next object, and then
+                initialize the object. The system will continue to invoke the
+                callback routine until a NULL pointer is returned. The callback
+                routine is responsible for allocating and freeing the cloned
+                settings structure. The original settings must not be modified.
+*//***************************************************************************/
+typedef struct t_SysSubModuleDescriptor
+{
+    e_SysModule module;             /**< Sub-module type */
+    uint32_t    id;                 /**< The sub-module ID */
+    void        *p_Settings;        /**< Pointer to the sub-module's settings */
+    void *      (*f_UpdateSettings)(uint32_t newId, void *p_OrigSettings, void *p_PrevSettings);
+                                    /**< Callback routine for cloning objects */
+    uint16_t    idIncrement;        /**< Amount by which to increment the
+                                         Sub-module ID when cloning objects */
+} t_SysSubModuleDescriptor;
+
+
+/**************************************************************************//**
+ @Collection    Object Identifier Macros
+ @{
+*//***************************************************************************/
+#define SYS_NULL_OBJECT_ID          0xFFFFFFFF
+                                    /**< Object ID representing no object */
+
+#define CAST_ID_TO_HANDLE(_id)      ((t_Handle)(_id))
+                                    /**< Macro for casting an object ID to a handle */
+#define CAST_HANDLE_TO_ID(_h)       ((uint32_t)(_h))
+                                    /**< Macro for casting a handle to an object ID */
+/* @} */
+
+/**************************************************************************//**
+ @Collection    Macros for Advanced Configuration Requests
+ @{
+*//***************************************************************************/
+#define SYS_MAX_ADV_CONFIG_ARGS     4
+                                    /**< Maximum number of arguments in
+                                         an advanced confiuration entry */
+
+#define ADV_CONFIG_DONE             NULL, { 0 }
+                                    /**< Marks the end of an advanced
+                                         configuration requests array \hideinitializer */
+#define ADV_CONFIG_NONE             (t_SysObjectAdvConfigEntry[]){ {ADV_CONFIG_DONE} }
+                                    /**< Marks an empty advanced
+                                         configuration requests array \hideinitializer */
+/* @} */
+
+/**************************************************************************//**
+ @Description   System Object Advanced Configuration Entry
+
+                This structure represents a single request for an advanced
+                configuration call on the initialized object. An array of such
+                requests may be contained in the settings structure of the
+                corresponding object.
+
+                The maximum number of arguments is limited to #SYS_MAX_ADV_CONFIG_ARGS.
+*//***************************************************************************/
+typedef struct t_SysObjectAdvConfigEntry
+{
+    void        *p_Function;    /**< Pointer to advanced configuration routine */
+#if 0
+     /*@@@@ cannot use uint64_t (CW bug?) */
+#endif
+    uint32_t    args[SYS_MAX_ADV_CONFIG_ARGS];
+                                /**< Array of arguments for the specified routine;
+                                     All arguments should be casted to uint32_t. */
+} t_SysObjectAdvConfigEntry;
+
+
+/** @} */ /* end of sys_gen_grp */
+
+/**************************************************************************//**
+ @Group         sys_app_grp     System Interface for Applications
+
+ @Description   Linux system programming interface for applications and
+                use cases.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Collection    Test Descriptor Text Length Limits
+ @{
+*//***************************************************************************/
+#define SYS_MAX_TEST_MODULE_NAME_LENGTH     32  /**< Maximum test module name length */
+#define SYS_MAX_TEST_GROUP_NAME_LENGTH      64  /**< Maximum test group name length */
+#define SYS_MAX_TEST_DESCRIPTION_LENGTH     128 /**< Maximum test description length */
+/* @} */
+
+/**************************************************************************//**
+ @Description   Test Descriptor
+
+                This structure should be used in the use case layout to request
+                execution of a specific test.
+*//***************************************************************************/
+typedef struct t_SysTestDescriptor
+{
+    char        testModule[SYS_MAX_TEST_MODULE_NAME_LENGTH];
+                /**< Test module name */
+    char        testGroup[SYS_MAX_TEST_GROUP_NAME_LENGTH];
+                /**< Test group name */
+    uint16_t    testId;
+                /**< Test identifier */
+    char        description[SYS_MAX_TEST_DESCRIPTION_LENGTH];
+                /**< Test description */
+    t_Error     (*f_RunTest)(void *p_TestParam);
+                /**< Test routine */
+    void        (*f_KillTest)(void);
+                /**< Test termination routine */
+    void        *p_TestParam;
+                /**< Pointer to the test parameters structure */
+
+} t_SysTestDescriptor;
+
+
+/**************************************************************************//**
+ @Description   Runtime Layout Structure
+
+                This structure describes a requested runtime layout, and
+                contains both logical object descriptors and test descriptors.
+*//***************************************************************************/
+typedef struct t_SysRuntimeLayout
+{
+    t_SysObjectDescriptor   **p_LogicalObjects;     /**< Logical-layer object descriptors */
+    t_SysTestDescriptor     **p_TestDescriptors;    /**< Test descriptors */
+
+} t_SysRuntimeLayout;
+
+/**************************************************************************//**
+ @Description   Peripheral Layout Structure
+
+                This structure describes a peripheral layout, and contains both
+                peripheral object descriptors and an array of runtime layouts
+*//***************************************************************************/
+typedef struct t_SysPeripheralLayout
+{
+    t_SysObjectDescriptor   **p_PeripheralObjects;  /**< Peripheral-layer object descriptors */
+    t_SysRuntimeLayout      *p_RuntimeLayouts;      /**< An array of runtime layouts */
+
+} t_SysPeripheralLayout;
+
+/**************************************************************************//**
+ @Description   System Layout Structure
+
+                This structure describes a system layout, and contains both
+                system object descriptors and an array of peripheral layouts
+*//***************************************************************************/
+typedef struct t_SysSystemLayout
+{
+    t_SysObjectDescriptor   **p_SystemObjects;      /**< System-layer object descriptors */
+    t_SysPeripheralLayout   *p_PeripheralLayouts;   /**< An array of peripheral layouts */
+
+} t_SysSystemLayout;
+
+/**************************************************************************//**
+ @Description   Use Case Layout Structure
+
+                This structure describes a use case runtime layout, and
+                contains a pointer to the platform settings as well as an
+                array of system layouts.
+*//***************************************************************************/
+typedef struct t_SysUseCaseLayout
+{
+    t_SysObjectDescriptor   *p_PlatformObject;      /**< Platform object descriptor */
+    t_SysSystemLayout       *p_SystemLayouts;       /**< An array of system layouts */
+
+} t_SysUseCaseLayout;
+
+
+/**************************************************************************//**
+ @Collection    Macros for Building the Use Case Layout
+ @{
+*//***************************************************************************/
+#define SYS_SYSTEM_OBJECTS(...)     (t_SysObjectDescriptor*[]){ __VA_ARGS__, NULL }
+                                    /**< Defines an array of system object descriptors \hideinitializer */
+#define SYS_PERIPHERAL_OBJECTS(...) (t_SysObjectDescriptor*[]){ __VA_ARGS__, NULL }
+                                    /**< Defines an array of peripheral object descriptors \hideinitializer */
+#define SYS_LOGICAL_OBJECTS(...)    (t_SysObjectDescriptor*[]){ __VA_ARGS__, NULL }
+                                    /**< Defines an array of logical object descriptors \hideinitializer */
+#define SYS_TEST_DESCRIPTORS(...)   (t_SysTestDescriptor*[]){ __VA_ARGS__, NULL }
+                                    /**< Defines an array of test descriptors \hideinitializer */
+
+#define SYS_BEGIN_SYSTEM_LAYOUTS \
+        (t_SysSystemLayout[]){      /**< Starts an array of system layout structures \hideinitializer */
+#define SYS_END_SYSTEM_LAYOUTS \
+        , { NULL, NULL } }          /**< Ends an array of system layout structures \hideinitializer */
+
+#define SYS_BEGIN_PERIPHERAL_LAYOUTS \
+        (t_SysPeripheralLayout[]){  /**< Starts an array of peripheral layout structures \hideinitializer */
+#define SYS_END_PERIPHERAL_LAYOUTS \
+        , { NULL, NULL } }          /**< Ends an array of peripheral layout structures \hideinitializer */
+
+#define SYS_BEGIN_RUNTIME_LAYOUTS \
+        (t_SysRuntimeLayout[]){     /**< Starts an array of runtime layout structures \hideinitializer */
+#define SYS_END_RUNTIME_LAYOUTS \
+        , { NULL, NULL } }          /**< Ends an array of runtime layout structures \hideinitializer */
+
+/* @} */
+
+/**************************************************************************//**
+ @Collection    Macros for Defining a Module Interface
+ @{
+*//***************************************************************************/
+#define MODULE_INTERFACE_VOID_PARAM(_initFunc, _freeFunc) \
+    { .cbs.f_InitNoParams = (_initFunc), .f_Free = (_freeFunc) }
+                    /**< Defines a module interface (with no initialization parameters) \hideinitializer */
+
+#define MODULE_INTERFACE_WITH_PARAM(_initFunc, _freeFunc) \
+    { .cbs.f_InitWithParams = (t_SysModuleInitFuncWithParams *)(_initFunc), .f_Free = (_freeFunc) }
+                    /**< Defines a module interface (with initialization parameters) \hideinitializer */
+/* @} */
+
+typedef t_Error (t_UpdateSettingsFunc)(uint32_t id, void *p_SubmoduleSettings);
+
+
+/**************************************************************************//**
+ @Function      SYS_Init
+
+ @Description   System initialization routine.
+
+                This routine calls the SYS_InternalInit() routine to initialize
+                the internal system structures and services, such as memory
+                management, objects repository and more.
+
+ @Return        None.
+*//***************************************************************************/
+void SYS_Init(void);
+
+/**************************************************************************//**
+ @Function      SYS_Free
+
+ @Description   System termination routine.
+
+                This routine releases all internal structures that were
+                initialized by the SYS_Init() routine.
+
+ @Return        None.
+*//***************************************************************************/
+void SYS_Free(void);
+
+/**************************************************************************//**
+ @Function      SYS_RunLayout
+
+ @Description   Executes a given use case layout.
+
+                This routine may be called to process and execute a use case
+                layout structure. The user should pass a pointer to a valid
+                use case layout structure, and the system would initialize
+                the requested objects and execute the requested test routines.
+
+ @Param[in]     p_UcLayout - Pointer to use case layout structure.
+
+ @Return        Zero for success; Non-zero value on error.
+*//***************************************************************************/
+int SYS_RunLayout(t_SysUseCaseLayout *p_UcLayout);
+
+
+/**************************************************************************//**
+ @Function      USER_BuildLayout
+
+ @Description   User-implemented routine for building the use case layout.
+
+                Any memory allocations in this routine must be released in the
+                USER_FreeLayout() routine.
+
+ @Return        Pointer to the use case layout; NULL on failure.
+*//***************************************************************************/
+t_SysUseCaseLayout * USER_BuildLayout(void);
+
+/**************************************************************************//**
+ @Function      USER_FreeLayout
+
+ @Description   User-implemented routine for freeing the use case layout.
+
+                This routine is called by the main routine in order to free
+                the use case layout before terminating the program.
+
+ @Param[in]     p_UseCaseLayout - Pointer to the use case layout to free.
+
+ @Return        None.
+*//***************************************************************************/
+void USER_FreeLayout(t_SysUseCaseLayout *p_UseCaseLayout);
+
+
+/**************************************************************************//**
+ @Function      USER_ModuleInit
+
+ @Description   User-implemented routine for system initialization. It calls
+                the necessary routines to build and run the use case layout.
+
+                This must be called from the kernel module's init routine.
+
+ @Return        0 on sucess, negative error code otherwise.
+*//***************************************************************************/
+int USER_ModuleInit(void);
+
+/**************************************************************************//**
+ @Function      USER_ModuleExit
+
+ @Description   User-implemented routine for freeing system resources. out.
+
+                This must be called from the kernel module's exit routine.
+
+ @Return        None.
+*//***************************************************************************/
+void USER_ModuleExit(void);
+
+/** @} */ /* end of sys_app_grp */
+
+/**************************************************************************//**
+ @Group         sys_mod_grp     System Interface for Modules
+
+ @Description   Linux system programming interface for modules (such as
+                wrappers and others).
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description   Sub-Modules Registration Parameters.
+
+                This structure provides registration parameters for a set of
+                sub-modules. Each module should register its own sub-modules
+                in the system using the SYS_RegisterSubModules() routine.
+*//***************************************************************************/
+typedef struct t_SysSubModuleRegisterParam
+{
+    e_SysModule owner;              /**< The type of the owner module */
+    uint8_t     numOfSubModules;    /**< Number of sub-modules in the \c p_SubModules array */
+    e_SysModule *p_SubModules;      /**< An array of sub-module types, of size \c numOfSubModules */
+    t_Error     (*f_InitSubModule)(t_Handle h_Module, t_SysSubModuleDescriptor *p_SubModuleDesc);
+                                    /**< Sub-modules initialization routine */
+    t_Error     (*f_FreeSubModule)(t_Handle h_Module, e_SysModule subModule, uint32_t id);
+                                    /**< Sub-modules free routine */
+    t_Handle    (*f_GetSubModule)(t_Handle h_Module, e_SysModule subModule, uint32_t id);
+                                    /**< Routine for retrieving sub-module handles */
+} t_SysSubModuleRegisterParam;
+
+/**************************************************************************//**
+ @Description   Sub-Modules Deregistration Parameters.
+
+                This structure provides deregistration parameters for a set of
+                sub-modules. Each module should deregister its own sub-modules
+                from the system during its termination and cleanup phase, using
+                the SYS_UnregisterSubModules() routine.
+*//***************************************************************************/
+typedef struct t_SysSubModuleUnregisterParam
+{
+    e_SysModule owner;              /**< The type of the owner module */
+    uint8_t     numOfSubModules;    /**< Number of sub-modules in the \c p_SubModules array */
+    e_SysModule *p_SubModules;      /**< An array of sub-module types, of size \c numOfSubModules */
+
+} t_SysSubModuleUnregisterParam;
+
+/**************************************************************************//**
+ @Function      SYS_RegisterSubModules
+
+ @Description   Registers a set of sub-modules as being owned by a given module.
+
+                This routine should be called by every system module in order
+                to register its sub-modules in the system. Without registration,
+                sub-modules cannot be initialized through the use case layout.
+
+ @Param[in]     p_RegParam - Pointer to registration parameters structure.
+
+ @Return        E_OK on success; Error code otherwise.
+*//***************************************************************************/
+t_Error SYS_RegisterSubModules(t_SysSubModuleRegisterParam *p_RegParam);
+
+/**************************************************************************//**
+ @Function      SYS_UnregisterSubModules
+
+ @Description   Unregisters a set of sub-modules from their owner module.
+
+                This routine should be called by every system module during
+                its termination and cleanup phase, in order to deregister its
+                sub-modules.
+
+ @Param[in]     p_UnregParam - Pointer to de-registration parameters structure.
+
+ @Return        E_OK on success; Error code otherwise.
+*//***************************************************************************/
+t_Error SYS_UnregisterSubModules(t_SysSubModuleUnregisterParam *p_UnregParam);
+
+/**************************************************************************//**
  @Function      SYS_ForceHandle
 
  @Description   Forces a handle for a specific object in the system.
@@ -321,26 +803,18 @@ t_Error SYS_ForceHandle(e_SysModule module, uint32_t id, t_Handle h_Module);
 *//***************************************************************************/
 void SYS_RemoveForcedHandle(e_SysModule module, uint32_t id);
 
-typedef struct t_SysObjectDescriptor
-{
-    e_SysModule module;
-    uint32_t    id;
-    void        *p_Settings;
-
-} t_SysObjectDescriptor;
+#ifdef CONFIG_MULTI_PARTITION_SUPPORT
+t_Error SYS_RegisterMessageHandler   (char *p_Addr, t_MsgHandler *f_MsgHandlerCB, t_Handle h_Mod);
+t_Error SYS_UnregisterMessageHandler (char *p_Addr);
+t_Error SYS_SendMessage(char                 *p_DestAddr,
+                        uint32_t             msgId,
+                        uint8_t              msgBody[MSG_BODY_SIZE],
+                        t_MsgCompletionCB    *f_CompletionCB,
+                        t_Handle             h_CBArg);
+#endif /* CONFIG_MULTI_PARTITION_SUPPORT */
 
-
-#define SYS_MAX_ADV_CONFIG_ARGS      4
-
-typedef struct t_SysObjectAdvConfigEntry
-{
-    void        *p_Function;
-    uint32_t    args[SYS_MAX_ADV_CONFIG_ARGS]; //@@@@ uint64_t (CW bug) ?
-} t_SysObjectAdvConfigEntry;
-
-
-#define ADV_CONFIG_DONE         NULL, { 0 }
-#define ADV_CONFIG_NONE         (t_SysObjectAdvConfigEntry[]){ ADV_CONFIG_DONE }
+/** @} */ /* end of sys_mod_grp */
+/** @} */ /* end of sys_grp */
 
 
 #define PARAMS(_num, _params)   ADV_CONFIG_PARAMS_##_num _params
@@ -389,17 +863,15 @@ typedef struct t_SysObjectAdvConfigEntry
             i++;                            \
         }                                   \
         else                                \
-            REPORT_ERROR(MINOR, E_INVALID_VALUE, ("number of advance-configuration exceeded!!!"));\
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, \
+                         ("Number of advanced-configuration entries exceeded")); \
     } while (0)
 
-#define ADD_ADV_CONFIG_START(_p_Entries, _maxEntries)                   \
-    {                                                                   \
-        t_SysObjectAdvConfigEntry   *p_Entry;                           \
-        t_SysObjectAdvConfigEntry   *p_Entrys = (_p_Entries);           \
-        int                         i=0, max = (_maxEntries);           \
-        for (; i<FM_MAX_NUM_OF_ADV_SETTINGS;i++)                        \
-            if (!p_LnxWrpFmPortDev->settings.advConfig[i].p_Function)   \
-                break;
+#define ADD_ADV_CONFIG_START(_p_Entries, _maxEntries)           \
+    {                                                           \
+        t_SysObjectAdvConfigEntry   *p_Entry;                   \
+        t_SysObjectAdvConfigEntry   *p_Entrys = (_p_Entries);   \
+        int                         i=0, max = (_maxEntries);   \
 
 #define ADD_ADV_CONFIG_END \
     }
@@ -429,134 +901,4 @@ typedef struct t_SysObjectAdvConfigEntry
     }
 
 
-
-#define CAST_ID_TO_HANDLE(_id)      ((t_Handle)(_id))
-#define CAST_HANDLE_TO_ID(_h)       ((uint32_t)(_h))
-
-
-#define SYS_MAX_TEST_GROUP_NAME_LENGTH      14
-#define SYS_MAX_TEST_DESCRIPTION_LENGTH     64
-
-typedef struct t_SysTestDescriptor
-{
-    char        testGroup[SYS_MAX_TEST_GROUP_NAME_LENGTH];
-    uint16_t    testId;
-    char        description[SYS_MAX_TEST_DESCRIPTION_LENGTH];
-    t_Error     (*f_RunTest)(void *p_TestParam);
-    void        (*f_KillTest)(void);
-    void        *p_TestParam;
-
-} t_SysTestDescriptor;
-
-
-typedef struct t_SysRuntimeLayout
-{
-    t_SysObjectDescriptor   **p_LogicalObjects;
-    t_SysTestDescriptor     **p_TestDescriptors;
-
-} t_SysRuntimeLayout;
-
-typedef struct t_SysPeripheralLayout
-{
-    t_SysObjectDescriptor   **p_PeripheralObjects;
-    t_SysRuntimeLayout      *p_RuntimeLayouts;
-
-} t_SysPeripheralLayout;
-
-typedef struct t_SysSystemLayout
-{
-    t_SysObjectDescriptor   **p_SystemObjects;
-    t_SysPeripheralLayout   *p_PeripheralLayouts;
-
-} t_SysSystemLayout;
-
-typedef struct t_SysUseCaseLayout
-{
-    t_SysObjectDescriptor   *p_PlatformObject;
-    t_SysSystemLayout       *p_SystemLayouts;
-
-} t_SysUseCaseLayout;
-
-
-
-t_SysUseCaseLayout * USER_BuildLayout(int argc, char *argv[]);
-
-void USER_FreeLayout(t_SysUseCaseLayout *p_UseCaseLayout);
-
-
-
-#define SYS_SYSTEM_OBJECTS(...)     (t_SysObjectDescriptor*[]){ __VA_ARGS__, NULL }
-#define SYS_PERIPHERAL_OBJECTS(...) (t_SysObjectDescriptor*[]){ __VA_ARGS__, NULL }
-#define SYS_LOGICAL_OBJECTS(...)    (t_SysObjectDescriptor*[]){ __VA_ARGS__, NULL }
-#define SYS_TEST_DESCRIPTORS(...)   (t_SysTestDescriptor*[]){ __VA_ARGS__, NULL }
-
-
-#define SYS_BEGIN_SYSTEM_LAYOUTS \
-        (t_SysSystemLayout[]){
-#define SYS_END_SYSTEM_LAYOUTS \
-        , { NULL, NULL } }
-
-#define SYS_BEGIN_PERIPHERAL_LAYOUTS \
-        (t_SysPeripheralLayout[]){
-#define SYS_END_PERIPHERAL_LAYOUTS \
-        , { NULL, NULL } }
-
-#define SYS_BEGIN_RUNTIME_LAYOUTS \
-        (t_SysRuntimeLayout[]){
-#define SYS_END_RUNTIME_LAYOUTS \
-        , { NULL, NULL } }
-
-
-
-typedef t_Handle (t_SysModuleInitFuncNoParams)(void);
-typedef t_Handle (t_SysModuleInitFuncWithParams)(void *p_ModuleParams);
-
-typedef struct t_SysRegistryEntry
-{
-    e_SysModule     module;
-    bool            noInitParams;
-    union
-    {
-        t_SysModuleInitFuncNoParams     *f_InitNoParams;
-        t_SysModuleInitFuncWithParams   *f_InitWithParams;
-    };
-    t_Error         (*f_Free)(t_Handle h_Module);
-
-} t_SysRegistryEntry;
-
-
-#define SYS_REGISTER_MODULE_VOID_PARAM(mod, initFunc, freeFunc) \
-    {(mod), TRUE,  .f_InitNoParams   = (initFunc), (freeFunc) }
-
-#define SYS_REGISTER_MODULE_WITH_PARAM(mod, initFunc, freeFunc) \
-    {(mod), FALSE, .f_InitWithParams = (t_SysModuleInitFuncWithParams *)(initFunc), (freeFunc) }
-
-#define SYS_REGISTER_MODULE_DONE \
-    {e_SYS_MODULE_NONE, TRUE, NULL, NULL }
-
-typedef struct t_SysSubModuleRegisterParam
-{
-    e_SysModule owner;
-    uint8_t     numOfSubModules;
-    e_SysModule *p_SubModules;
-    t_Error     (*f_InitSubModule)(t_Handle h_Module, t_SysObjectDescriptor *p_SubModuleDesc);
-    t_Error     (*f_FreeSubModule)(t_Handle h_Module, e_SysModule subModule, uint32_t id);
-    t_Handle    (*f_GetSubModule)(t_Handle h_Module, e_SysModule subModule, uint32_t id);
-
-} t_SysSubModuleRegisterParam;
-
-
-typedef struct t_SysSubModuleUnregisterParam
-{
-    e_SysModule owner;
-    uint8_t     numOfSubModules;
-    e_SysModule *p_SubModules;
-
-} t_SysSubModuleUnregisterParam;
-
-
-void SYS_Init(void);
-void SYS_Free(void);
-
-
 #endif /* __SYS_EXT_H */
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/system/sys_io_ext.h b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/system/sys_io_ext.h
index 6ba992e..ee7b628 100644
--- a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/system/sys_io_ext.h
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/system/sys_io_ext.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/types_linux.h b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/types_linux.h
index afb6906..536e9e2 100644
--- a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/types_linux.h
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/types_linux.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -62,6 +62,8 @@ typedef double              double_t;   /* Double precision floating point  */
 #define _Packed
 #define _PackedType __attribute__ ((packed))
 
+typedef  phys_addr_t physAddress_t;
+
 #define UINT8_MAX   0xFF
 #define UINT8_MIN   0
 #define UINT16_MAX  0xFFFF
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/wrappers/Peripherals/fsl_fman.h b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/wrappers/Peripherals/fsl_fman.h
index c4cac55..0e9edfe 100644
--- a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/wrappers/Peripherals/fsl_fman.h
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/wrappers/Peripherals/fsl_fman.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -108,6 +108,7 @@ struct fm_port_rx_params {
                                                     /**< Parameters for each pool */
     uint16_t                    priv_data_size;     /**< Area that user may save for his own need (E.g. save the SKB) */
     bool                        parse_results;      /**< Whether to have the parser-results in the Received buffer */
+    bool                        hash_results;       /**< Whether to have the hash-results in the Received buffer */
 };
 
 /**************************************************************************//**
@@ -120,6 +121,7 @@ struct fm_port_non_rx_params {
                                                      frames. For OP - default Rx queue. */
     uint16_t                priv_data_size;     /**< Area that user may save for his own need (E.g. save the SKB) */
     bool                    parse_results;      /**< Whether to put the parser-results in the Transmitted buffer */
+    bool                    hash_results;       /**< Whether to have the hash-results in the Received buffer */
 };
 
 
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/wrappers/Peripherals/fsl_fman_test.h b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/wrappers/Peripherals/fsl_fman_test.h
index d0406a1..3ed4dbb 100644
--- a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/wrappers/Peripherals/fsl_fman_test.h
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/wrappers/Peripherals/fsl_fman_test.h
@@ -1,36 +1,4 @@
-/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of Freescale Semiconductor nor the
- *       names of its contributors may be used to endorse or promote products
- *       derived from this software without specific prior written permission.
- *
- *
- * ALTERNATIVELY, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") as published by the Free Software
- * Foundation, either version 2 of that License or (at your option) any
- * later version.
- *
- * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
- * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/wrappers/Peripherals/lnxwrp_fm_ext.h b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/wrappers/Peripherals/lnxwrp_fm_ext.h
index f7c7a93..ae065eb 100644
--- a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/wrappers/Peripherals/lnxwrp_fm_ext.h
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/wrappers/Peripherals/lnxwrp_fm_ext.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/modules/integrations/P4080/FM/fmm.c b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/modules/integrations/P4080/FM/fmm.c
index 6fdfcd1..82aee7e 100644
--- a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/modules/integrations/P4080/FM/fmm.c
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/modules/integrations/P4080/FM/fmm.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/modules/integrations/P4080/FM/mod_config.h b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/modules/integrations/P4080/FM/mod_config.h
index decb8d3..87e03ce 100644
--- a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/modules/integrations/P4080/FM/mod_config.h
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/modules/integrations/P4080/FM/mod_config.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/system/platform/P4080/Makefile b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/system/platform/P4080/Makefile
index f67748f..5605157 100644
--- a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/system/platform/P4080/Makefile
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/system/platform/P4080/Makefile
@@ -7,3 +7,5 @@ EXTRA_CFLAGS           += -DVERSION=\"\"
 include $(srctree)/drivers/net/dpa/NetCommSw/ncsw_config.mk
 
 obj-y		+= platform_p4080_ds.o
+
+
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/system/platform/P4080/platform_p4080_ds.c b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/system/platform/P4080/platform_p4080_ds.c
index 188ee51..ddfcc1f 100644
--- a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/system/platform/P4080/platform_p4080_ds.c
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/system/platform/P4080/platform_p4080_ds.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/system/sys_init.c b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/system/sys_init.c
deleted file mode 100644
index a95c461..0000000
--- a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/system/sys_init.c
+++ /dev/null
@@ -1,48 +0,0 @@
-/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of Freescale Semiconductor nor the
- *       names of its contributors may be used to endorse or promote products
- *       derived from this software without specific prior written permission.
- *
- *
- * ALTERNATIVELY, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") as published by the Free Software
- * Foundation, either version 2 of that License or (at your option) any
- * later version.
- *
- * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
- * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-
-#include "std_ext.h"
-#include "error_ext.h"
-#include "sys_ext.h"
-
-
-/*****************************************************************************/
-void SYS_Init(void)
-{
-
-}
-
-void SYS_Free(void)
-{
-
-}
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/system/sys_io.c b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/system/sys_io.c
index e6e2125..82cf0aa 100644
--- a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/system/sys_io.c
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/system/sys_io.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/util/procbuff.c b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/util/procbuff.c
index eb59680..83ba42e 100644
--- a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/util/procbuff.c
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/util/procbuff.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/util/procbuff.h b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/util/procbuff.h
index d21382b..daa7c76 100644
--- a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/util/procbuff.h
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/util/procbuff.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/fman_test.c b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/fman_test.c
index 479bf89..5325b82 100644
--- a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/fman_test.c
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/fman_test.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -122,55 +122,25 @@ static t_FmTest fmTest;
 static t_Error Set1GMacIntLoopback(t_FmTestPort *p_FmTestPort, bool en)
 {
 #define FM_1GMAC0_OFFSET                0x000e0000
-#define FM_1GMAC1_OFFSET                0x000e2000
-#define FM_1GMAC2_OFFSET                0x000e4000
-#define FM_1GMAC3_OFFSET                0x000e6000
 #define FM_1GMAC_CMD_CONF_CTRL_OFFSET   0x100
 #define MACCFG1_LOOPBACK                0x00000100
 
-    uint64_t    tmpAddr = p_FmTestPort->fmPhysBaseAddr;
+    uint64_t    baseAddr, regAddr;
     uint32_t    tmpVal;
 
-    if (p_FmTestPort->portType == e_IOC_FMT_PORT_T_RXTX)
-    switch (p_FmTestPort->id)
-    {
-        case 0:
-            tmpAddr += FM_1GMAC0_OFFSET;
-            break;
-        case 1:
-            tmpAddr += FM_1GMAC1_OFFSET;
-            break;
-        case 2:
-            tmpAddr += FM_1GMAC2_OFFSET;
-            break;
-        case 3:
-            tmpAddr += FM_1GMAC3_OFFSET;
-            break;
-        default:
-            RETURN_ERROR(MINOR, E_INVALID_VALUE, ("fm-port-test id!"));
-    }
+    baseAddr = p_FmTestPort->fmPhysBaseAddr + (FM_1GMAC0_OFFSET + (p_FmTestPort->id*0x2000));
 
-    tmpAddr = CAST_POINTER_TO_UINT64(ioremap(tmpAddr, 0x1000));
+    baseAddr = CAST_POINTER_TO_UINT64(ioremap(baseAddr, 0x1000));
 
-    switch (p_FmTestPort->id)
-    {
-        case 0:
-        case 1:
-        case 2:
-        case 3:
-            tmpAddr += FM_1GMAC_CMD_CONF_CTRL_OFFSET;
-            tmpVal = GET_UINT32(*CAST_UINT64_TO_POINTER_TYPE(uint32_t,tmpAddr));
-            if (en)
-                tmpVal |= MACCFG1_LOOPBACK;
-            else
-                tmpVal &= ~MACCFG1_LOOPBACK;
-            WRITE_UINT32(*CAST_UINT64_TO_POINTER_TYPE(uint32_t,tmpAddr), tmpVal);
-            break;
-        default:
-            break;
-    }
+    regAddr = baseAddr + FM_1GMAC_CMD_CONF_CTRL_OFFSET;
+    tmpVal = GET_UINT32(*CAST_UINT64_TO_POINTER_TYPE(uint32_t,regAddr));
+    if (en)
+        tmpVal |= MACCFG1_LOOPBACK;
+    else
+        tmpVal &= ~MACCFG1_LOOPBACK;
+    WRITE_UINT32(*CAST_UINT64_TO_POINTER_TYPE(uint32_t,regAddr), tmpVal);
 
-    iounmap(CAST_UINT64_TO_POINTER(tmpAddr));
+    iounmap(CAST_UINT64_TO_POINTER(baseAddr));
 
     return E_OK;
 }
@@ -182,37 +152,22 @@ static t_Error Set10GMacIntLoopback(t_FmTestPort *p_FmTestPort, bool en)
 #define FM_10GMAC_CMD_CONF_CTRL_OFFSET  0x8
 #define CMD_CFG_LOOPBACK_EN             0x00000400
 
-    uint64_t    tmpAddr = p_FmTestPort->fmPhysBaseAddr;
+    uint64_t    baseAddr, regAddr;
     uint32_t    tmpVal;
 
-    if (p_FmTestPort->portType == e_IOC_FMT_PORT_T_RXTX)
-        switch (p_FmTestPort->id)
-        {
-            case 4:
-                tmpAddr += FM_10GMAC0_OFFSET;
-                break;
-            default:
-                RETURN_ERROR(MINOR, E_INVALID_VALUE, ("fm-port-test id!"));
-        }
+    baseAddr = p_FmTestPort->fmPhysBaseAddr + (FM_10GMAC0_OFFSET + ((p_FmTestPort->id-4)*0x2000));
 
-    tmpAddr = CAST_POINTER_TO_UINT64(ioremap(tmpAddr, 0x1000));
+    baseAddr = CAST_POINTER_TO_UINT64(ioremap(baseAddr, 0x1000));
 
-    switch (p_FmTestPort->id)
-    {
-        case 4:
-            tmpAddr += FM_10GMAC_CMD_CONF_CTRL_OFFSET;
-            tmpVal = GET_UINT32(*CAST_UINT64_TO_POINTER_TYPE(uint32_t,tmpAddr));
-            if (en)
-                tmpVal |= CMD_CFG_LOOPBACK_EN;
-            else
-                tmpVal &= ~CMD_CFG_LOOPBACK_EN;
-            WRITE_UINT32(*CAST_UINT64_TO_POINTER_TYPE(uint32_t,tmpAddr), tmpVal);
-            break;
-        default:
-            break;
-    }
+    regAddr = baseAddr + FM_10GMAC_CMD_CONF_CTRL_OFFSET;
+    tmpVal = GET_UINT32(*CAST_UINT64_TO_POINTER_TYPE(uint32_t,regAddr));
+    if (en)
+        tmpVal |= CMD_CFG_LOOPBACK_EN;
+    else
+        tmpVal &= ~CMD_CFG_LOOPBACK_EN;
+    WRITE_UINT32(*CAST_UINT64_TO_POINTER_TYPE(uint32_t,regAddr), tmpVal);
 
-    iounmap(CAST_UINT64_TO_POINTER(tmpAddr));
+    iounmap(CAST_UINT64_TO_POINTER(baseAddr));
 
     return E_OK;
 }
@@ -509,6 +464,7 @@ bool is_fman_test (void     *mac_dev,
 
     if (fman_test_flag)
     {
+        DBG(TRACE, ("Port %d got FMUC frame\n", p_FmTestPort->id));
         dataOffset = FM_PORT_GetBufferDataOffset(p_FmTestPort->h_RxFmPortDev);
         p_FmTestFrame = (t_FmTestFrame *)XX_Malloc(sizeof(t_FmTestFrame));
         memset(p_FmTestFrame, 0, sizeof(t_FmTestFrame));
@@ -547,10 +503,8 @@ void fman_test_ip_manip (void *mac_dev, uint8_t *data)
     for (i=0; i<IOC_FMT_MAX_NUM_OF_PORTS; i++)
         if (mac_dev == p_FmTest->ports[i].h_Mac)
             p_FmTestPort = &p_FmTest->ports[i];
-#ifdef SIMULATOR
     if (!p_FmTestPort || !p_FmTestPort->ip_header_manip)
         return;
-#endif /* SIMULATOR */
 
     iph = (struct iphdr *)p_Data;
     saddr = iph->saddr;
@@ -575,14 +529,10 @@ void fman_test_ip_manip (void *mac_dev, uint8_t *data)
          (int)((daddr & 0x0000ff00) >> 8),
          (int)((daddr & 0x000000ff) >> 0)));
 
-#ifdef SIMULATOR
     if ((p_FmTestPort->diag == e_IOC_DIAG_MODE_CTRL_LOOPBACK) ||
         (p_FmTestPort->diag == e_IOC_DIAG_MODE_CHIP_LOOPBACK) ||
         (p_FmTestPort->diag == e_IOC_DIAG_MODE_PHY_LOOPBACK) ||
         (p_FmTestPort->diag == e_IOC_DIAG_MODE_LINE_LOOPBACK))
-#else
-    if (true)
-#endif /* SIMULATOR */
     {
         net   = saddr;
         saddr = daddr;
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/lnxwrp_fm.c b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/lnxwrp_fm.c
index 4ecc5e8..0e71d62 100644
--- a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/lnxwrp_fm.c
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/lnxwrp_fm.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -78,6 +78,19 @@
 
 #define PROC_PRINT(args...) offset += sprintf(buf+offset,args)
 
+#define ADD_ADV_CONFIG_NO_RET(_func, _param)    \
+    do {                                        \
+        if (i<max){                             \
+            p_Entry = &p_Entrys[i];             \
+            p_Entry->p_Function = _func;        \
+            _param                              \
+            i++;                                \
+        }                                       \
+        else                                    \
+            REPORT_ERROR(MAJOR, E_INVALID_VALUE,\
+                         ("Number of advanced-configuration entries exceeded"));\
+    } while (0)
+
 
 static t_LnxWrpFm   lnxWrpFm;
 
@@ -623,6 +636,7 @@ static t_Error FillRestFmInfo(t_LnxWrpFmDev *p_LnxWrpFmDev)
 {
 #define FM_BMI_PPIDS_OFFSET                 0x00080304
 #define FM_DMA_PLR_OFFSET                   0x000c2060
+#define FM_FPM_IP_REV_1_OFFSET              0x000c30c4
 #define DMA_HIGH_LIODN_MASK                 0x0FFF0000
 #define DMA_LOW_LIODN_MASK                  0x00000FFF
 #define DMA_LIODN_SHIFT                     16
@@ -635,12 +649,14 @@ typedef _Packed struct {
    volatile uint32_t   fmbm_ppid[63];
 } _PackedType t_Ppids;
 
-    t_Plr   *p_Plr;
-    t_Ppids *p_Ppids;
-    int     i;
-    uint8_t physRxPortId[] = {0x8,0x9,0xa,0xb,0x10};
-    uint8_t physOhPortId[] = {0x1,0x2,0x3,0x4,0x5, 0x6, 0x7};
+    t_Plr       *p_Plr;
+    t_Ppids     *p_Ppids;
+    int         i;
+    uint32_t    fmRev;
+    uint8_t     physRxPortId[] = {0x8,0x9,0xa,0xb,0x10};
+    uint8_t     physOhPortId[] = {0x1,0x2,0x3,0x4,0x5,0x6,0x7};
 
+    fmRev = (uint32_t)(*CAST_UINT64_TO_POINTER_TYPE(uint32_t, (p_LnxWrpFmDev->fmBaseAddr+FM_FPM_IP_REV_1_OFFSET)) & 0xffff);
     p_Plr = CAST_UINT64_TO_POINTER_TYPE(t_Plr, (p_LnxWrpFmDev->fmBaseAddr+FM_DMA_PLR_OFFSET));
 #ifdef MODULE
     for (i=0;i<FM_MAX_NUM_OF_PARTITIONS/2;i++)
@@ -648,25 +664,28 @@ typedef _Packed struct {
 #endif /* MODULE */
 
     for (i=0; i<FM_MAX_NUM_OF_PARTITIONS; i++)
-        p_LnxWrpFmDev->fmDevSettings.param.liodnPerPartition[i] = (i%2) ?
-            (p_Plr->plr[i/2] & DMA_LOW_LIODN_MASK) :
-            ((p_Plr->plr[i/2] & DMA_HIGH_LIODN_MASK) >> DMA_LIODN_SHIFT);
+        p_LnxWrpFmDev->fmDevSettings.param.liodnPerPartition[i] =
+            (uint16_t)((i%2) ?
+                       (p_Plr->plr[i/2] & DMA_LOW_LIODN_MASK) :
+                       ((p_Plr->plr[i/2] & DMA_HIGH_LIODN_MASK) >> DMA_LIODN_SHIFT));
 
     p_Ppids = CAST_UINT64_TO_POINTER_TYPE(t_Ppids, (p_LnxWrpFmDev->fmBaseAddr+FM_BMI_PPIDS_OFFSET));
 
     for (i=0; i<FM_MAX_NUM_OF_RX_PORTS; i++)
-        p_LnxWrpFmDev->rxPorts[i].settings.param.specificParams.rxParams.rxPartitionId =
-            p_Ppids->fmbm_ppid[physRxPortId[i]-1];
+            p_LnxWrpFmDev->rxPorts[i].settings.param.specificParams.rxParams.rxPartitionId =
+                p_Ppids->fmbm_ppid[physRxPortId[i]-1];
 
-#ifdef FM_OP_PARTITION_ERRATA
+#ifdef FM_OP_PARTITION_ERRATA_FMAN16
     for (i=0; i<FM_MAX_NUM_OF_OH_PORTS; i++)
     {
+        /* OH port #0 is host-command, don't need this workaround */
         if (i == 0)
             continue;
-        p_LnxWrpFmDev->opPorts[i-1].settings.param.specificParams.nonRxParams.opPartitionId =
-            p_Ppids->fmbm_ppid[physOhPortId[i]-1];
+        if (fmRev == 0x0100)
+            p_LnxWrpFmDev->opPorts[i-1].settings.param.specificParams.nonRxParams.opPartitionId =
+                p_Ppids->fmbm_ppid[physOhPortId[i]-1];
     }
-#endif  /* FM_OP_PARTITION_ERRATA */
+#endif  /* FM_OP_PARTITION_ERRATA_FMAN16 */
 
     return E_OK;
 }
@@ -945,24 +964,6 @@ static t_LnxWrpFmDev * ReadFmDevTreeNode (struct of_device *of_dev)
         of_node_put(fm_node);
     }
 
-    /* Loading the fman-controller code */
-    if (p_LnxWrpFmDev->ccActive) {
-        struct qe_firmware *fw = FindFmanMicrocode();
-
-        if (!fw)
-            /* We already reported an error, so just return NULL*/
-            return NULL;
-
-        p_LnxWrpFmDev->fmDevSettings.param.firmware.p_Code =
-            (void *) fw + fw->microcode[0].code_offset;
-        p_LnxWrpFmDev->fmDevSettings.param.firmware.size =
-            sizeof(u32) * fw->microcode[0].count;
-        DBG(INFO, ("Loading fman-controller code version %d.%d.%d",
-                   fw->microcode[0].major,
-                   fw->microcode[0].minor,
-                   fw->microcode[0].revision));
-    }
-
     p_LnxWrpFmDev->active = TRUE;
 
     return p_LnxWrpFmDev;
@@ -1004,14 +1005,14 @@ static t_LnxWrpFmPortDev * ReadFmPortDevTreeNode (struct of_device *of_dev)
         if (*uint32_prop == 0) {
             p_LnxWrpFmPortDev = &p_LnxWrpFmDev->hcPort;
             p_LnxWrpFmPortDev->id = 0;
-            p_LnxWrpFmPortDev->settings.param.portType = e_FM_PORT_TYPE_HOST_COMMAND;
+            p_LnxWrpFmPortDev->settings.param.portType = e_FM_PORT_TYPE_OH_HOST_COMMAND;
         }
         else {
             p_LnxWrpFmPortDev = &p_LnxWrpFmDev->opPorts[*uint32_prop-1];
             p_LnxWrpFmPortDev->id = *uint32_prop-1;
-            p_LnxWrpFmPortDev->settings.param.portType = e_FM_PORT_TYPE_OFFLINE_PARSING;
+            p_LnxWrpFmPortDev->settings.param.portType = e_FM_PORT_TYPE_OH_OFFLINE_PARSING;
         }
-        p_LnxWrpFmPortDev->settings.param.portId = p_LnxWrpFmPortDev->id;
+        p_LnxWrpFmPortDev->settings.param.portId = *uint32_prop;
 
         uint32_prop = (uint32_t *)of_get_property(port_node, "fsl,qman-channel-id", &lenp);
         if (uint32_prop == NULL) {
@@ -1201,7 +1202,7 @@ static t_Error ConfigureFmDev(t_LnxWrpFmDev  *p_LnxWrpFmDev)
     p_LnxWrpFmDev->fmDevSettings.param.fmId         = p_LnxWrpFmDev->id;
     p_LnxWrpFmDev->fmDevSettings.param.irq          = NO_IRQ;
     p_LnxWrpFmDev->fmDevSettings.param.errIrq       = NO_IRQ;
-    p_LnxWrpFmDev->fmDevSettings.param.f_Exceptions = LnxwrpFmDevExceptionsCb;
+    p_LnxWrpFmDev->fmDevSettings.param.f_Exception  = LnxwrpFmDevExceptionsCb;
     p_LnxWrpFmDev->fmDevSettings.param.f_BusError   = LnxwrpFmDevBusErrorCb;
     p_LnxWrpFmDev->fmDevSettings.param.h_App        = p_LnxWrpFmDev;
 
@@ -1245,9 +1246,9 @@ static t_Error InitFmPcdDev(t_LnxWrpFmDev  *p_LnxWrpFmDev)
         fmPcdParams.ccSupport   = p_LnxWrpFmDev->ccActive;
 
 #ifndef CONFIG_GUEST_PARTITION
-        fmPcdParams.f_FmPcdException   = LnxwrpFmPcdDevExceptionsCb;
+        fmPcdParams.f_Exception   = LnxwrpFmPcdDevExceptionsCb;
         if (fmPcdParams.kgSupport)
-            fmPcdParams.f_FmPcdIdException = LnxwrpFmPcdDevIndexedExceptionsCb;
+            fmPcdParams.f_ExceptionId  = LnxwrpFmPcdDevIndexedExceptionsCb;
         fmPcdParams.h_App              = p_LnxWrpFmDev;
 #endif /* !CONFIG_GUEST_PARTITION */
 
@@ -1282,7 +1283,7 @@ static t_Error InitFmPcdDev(t_LnxWrpFmDev  *p_LnxWrpFmDev)
         fmPcdParams.hc.confFqid = qman_fq_fqid(p_LnxWrpFmDev->hc_tx_conf_fq);
         fmPcdParams.hc.deqSubPortal = (p_LnxWrpFmPortDev->txCh & 0x1f);
         fmPcdParams.hc.enqFqid = qman_fq_fqid(p_LnxWrpFmDev->hc_tx_fq);
-        fmPcdParams.hc.f_QmEnqueueCB = QmEnqueueCB;
+        fmPcdParams.hc.f_QmEnqueue = QmEnqueueCB;
         fmPcdParams.hc.h_QmArg = (t_Handle)p_LnxWrpFmDev;
 
         p_LnxWrpFmDev->h_PcdDev = FM_PCD_Config(&fmPcdParams);
@@ -1294,10 +1295,10 @@ static t_Error InitFmPcdDev(t_LnxWrpFmDev  *p_LnxWrpFmDev)
             RETURN_ERROR(MAJOR, err, NO_MSG);
 
         if (p_LnxWrpFmDev->err_irq != 0) {
-            FM_PCD_SetException(p_LnxWrpFmDev->h_PcdDev,e_FM_PCD_KG_ERR_EXCEPTION_DOUBLE_ECC,FALSE);
-            FM_PCD_SetException(p_LnxWrpFmDev->h_PcdDev,e_FM_PCD_KG_ERR_EXCEPTION_KEYSIZE_OVERFLOW,FALSE);
-            FM_PCD_SetException(p_LnxWrpFmDev->h_PcdDev,e_FM_PCD_PLCR_ERR_EXCEPTION_INIT_ENTRY_ERROR,FALSE);
-            FM_PCD_SetException(p_LnxWrpFmDev->h_PcdDev,e_FM_PCD_PLCR_ERR_EXCEPTION_DOUBLE_ECC,FALSE);
+            FM_PCD_SetException(p_LnxWrpFmDev->h_PcdDev,e_FM_PCD_KG_EXCEPTION_DOUBLE_ECC,FALSE);
+            FM_PCD_SetException(p_LnxWrpFmDev->h_PcdDev,e_FM_PCD_KG_EXCEPTION_KEYSIZE_OVERFLOW,FALSE);
+            FM_PCD_SetException(p_LnxWrpFmDev->h_PcdDev,e_FM_PCD_PLCR_EXCEPTION_INIT_ENTRY_ERROR,FALSE);
+            FM_PCD_SetException(p_LnxWrpFmDev->h_PcdDev,e_FM_PCD_PLCR_EXCEPTION_DOUBLE_ECC,FALSE);
             FM_PCD_SetException(p_LnxWrpFmDev->h_PcdDev,e_FM_PCD_PRS_EXCEPTION_DOUBLE_ECC,FALSE);
             FM_PCD_SetException(p_LnxWrpFmDev->h_PcdDev,e_FM_PCD_PRS_EXCEPTION_ILLEGAL_ACCESS,FALSE);
             FM_PCD_SetException(p_LnxWrpFmDev->h_PcdDev,e_FM_PCD_PRS_EXCEPTION_PORT_ILLEGAL_ACCESS,FALSE);
@@ -1312,12 +1313,29 @@ static t_Error InitFmPcdDev(t_LnxWrpFmDev  *p_LnxWrpFmDev)
 
 static t_Error InitFmDev(t_LnxWrpFmDev  *p_LnxWrpFmDev)
 {
+    struct qe_firmware *fw;
+
     if (!p_LnxWrpFmDev->active)
         RETURN_ERROR(MAJOR, E_INVALID_STATE, ("FM not configured!!!"));
 
     if ((p_LnxWrpFmDev->h_MuramDev = FM_MURAM_ConfigAndInit(p_LnxWrpFmDev->fmMuramBaseAddr, p_LnxWrpFmDev->fmMuramMemSize)) == NULL)
         RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("FM-MURAM!"));
 
+    /* Loading the fman-controller code */
+    fw = FindFmanMicrocode();
+    if (!fw)
+        /* We already reported an error, so just return NULL*/
+        return ERROR_CODE(E_NULL_POINTER);
+
+    p_LnxWrpFmDev->fmDevSettings.param.firmware.p_Code =
+        (void *) fw + fw->microcode[0].code_offset;
+    p_LnxWrpFmDev->fmDevSettings.param.firmware.size =
+        sizeof(u32) * fw->microcode[0].count;
+    DBG(INFO, ("Loading fman-controller code version %d.%d.%d",
+               fw->microcode[0].major,
+               fw->microcode[0].minor,
+               fw->microcode[0].revision));
+
     p_LnxWrpFmDev->fmDevSettings.param.h_FmMuram = p_LnxWrpFmDev->h_MuramDev;
 
     if ((p_LnxWrpFmDev->h_Dev = FM_Config(&p_LnxWrpFmDev->fmDevSettings.param)) == NULL)
@@ -1337,39 +1355,15 @@ static t_Error InitFmDev(t_LnxWrpFmDev  *p_LnxWrpFmDev)
         FM_SetException(p_LnxWrpFmDev->h_Dev,e_FM_EX_IRAM_ECC,FALSE);
         FM_SetException(p_LnxWrpFmDev->h_Dev,e_FM_EX_MURAM_ECC,FALSE);
         FM_SetException(p_LnxWrpFmDev->h_Dev,e_FM_EX_QMI_DOUBLE_ECC,FALSE);
-        FM_SetException(p_LnxWrpFmDev->h_Dev,e_FM_EX_QMI_DEQ_FROM_DEFQ,FALSE);
+        FM_SetException(p_LnxWrpFmDev->h_Dev,e_FM_EX_QMI_DEQ_FROM_UNKNOWN_PORTID,FALSE);
         FM_SetException(p_LnxWrpFmDev->h_Dev,e_FM_EX_BMI_LIST_RAM_ECC,FALSE);
         FM_SetException(p_LnxWrpFmDev->h_Dev,e_FM_EX_BMI_PIPELINE_ECC,FALSE);
         FM_SetException(p_LnxWrpFmDev->h_Dev,e_FM_EX_BMI_STATISTICS_RAM_ECC, FALSE);
     }
 
-#ifdef BUP_FM_HALT_SIG_ERRATA
-    /* Workaround for silicon! not relevant for simulator */
-    if (FM_ConfigHaltOnExternalActivation(p_LnxWrpFmDev->h_Dev, FALSE) != E_OK)
-        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("FM"));
-    if (FM_ConfigHaltOnUnrecoverableEccError(p_LnxWrpFmDev->h_Dev, FALSE) != E_OK)
-        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("FM"));
-#endif /* BUP_FM_HALT_SIG_ERRATA */
-
-    {
-        t_FmDmaEmergency    emergency;
-
-        emergency.emergencyBusSelect = FM_DMA_MURAM_READ_EMERGENCY | FM_DMA_MURAM_WRITE_EMERGENCY | FM_DMA_EXT_BUS_EMERGENCY;
-        emergency.emergencyLevel = e_FM_DMA_EM_SOS;
-
-        if (FM_ConfigDmaAidMode(p_LnxWrpFmDev->h_Dev, e_FM_DMA_AID_OUT_TNUM) != E_OK)
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("FM"));
-    }
-
     if (FM_Init(p_LnxWrpFmDev->h_Dev) != E_OK)
         RETURN_ERROR(MAJOR, E_INVALID_STATE, ("FM"));
 
-#ifdef FM_MURAM_ERR_IRQ_ERRATA
-        FM_SetException(p_LnxWrpFmDev->h_Dev, e_FM_EX_BMI_LIST_RAM_ECC, FALSE);
-        FM_SetException(p_LnxWrpFmDev->h_Dev, e_FM_EX_MURAM_ECC, FALSE);
-        FM_SetException(p_LnxWrpFmDev->h_Dev, e_FM_EX_IRAM_ECC, FALSE);
-#endif /* FM_MURAM_ERR_IRQ_ERRATA */
-
 //    return InitFmPcdDev(p_LnxWrpFmDev);
     return E_OK;
 }
@@ -1508,32 +1502,14 @@ static t_Error InitFmPortDev(t_LnxWrpFmPortDev *p_LnxWrpFmPortDev)
     if ((p_LnxWrpFmPortDev->h_Dev = FM_PORT_Config(&p_LnxWrpFmPortDev->settings.param)) == NULL)
         RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("FM-port"));
 
-    if ((p_LnxWrpFmPortDev->settings.param.portType == e_FM_PORT_TYPE_RX_10G) ||
-        (p_LnxWrpFmPortDev->settings.param.portType == e_FM_PORT_TYPE_RX))
-    {
-        t_Error         errCode;
-        if ((errCode = FM_PORT_ConfigDmaWriteOptimize(p_LnxWrpFmPortDev->h_Dev, TRUE)) != E_OK)
-             RETURN_ERROR(MAJOR, errCode, NO_MSG);
-    }
-    else if ((p_LnxWrpFmPortDev->settings.param.portType == e_FM_PORT_TYPE_TX_10G) ||
+    if ((p_LnxWrpFmPortDev->settings.param.portType == e_FM_PORT_TYPE_TX_10G) ||
              (p_LnxWrpFmPortDev->settings.param.portType == e_FM_PORT_TYPE_TX))
     {
-        t_FmPortRsrc    portRsrc;
         t_Error         errCode;
-
-        portRsrc.num = 6;
-        portRsrc.extra = 6;
-
-        if ((p_LnxWrpFmPortDev->settings.param.portType == e_FM_PORT_TYPE_TX_10G) &&
-            (errCode = FM_PORT_ConfigNumOfOpenDmas(p_LnxWrpFmPortDev->h_Dev, &portRsrc)) != E_OK)
-             RETURN_ERROR(MAJOR, errCode, NO_MSG);
         if ((errCode = FM_PORT_ConfigDeqHighPriority(p_LnxWrpFmPortDev->h_Dev, TRUE)) != E_OK)
              RETURN_ERROR(MAJOR, errCode, NO_MSG);
         if ((errCode = FM_PORT_ConfigDeqPrefetchOption(p_LnxWrpFmPortDev->h_Dev, e_FM_PORT_DEQ_FULL_PREFETCH)) != E_OK)
              RETURN_ERROR(MAJOR, errCode, NO_MSG);
-        if ((p_LnxWrpFmPortDev->settings.param.portType == e_FM_PORT_TYPE_TX_10G) &&
-            (errCode = FM_PORT_ConfigTxFifoDeqPipelineDepth(p_LnxWrpFmPortDev->h_Dev, 8)) != E_OK)
-             RETURN_ERROR(MAJOR, errCode, NO_MSG);
     }
 
     if (((t_LnxWrpFmDev *)p_LnxWrpFmPortDev->h_LnxWrpFmDev)->err_irq != 0) {
@@ -1906,7 +1882,7 @@ static int /*__devinit*/ fm_port_probe(struct of_device *of_dev, const struct of
 
     dev_set_drvdata(dev, p_LnxWrpFmPortDev);
 
-    if ((p_LnxWrpFmPortDev->settings.param.portType == e_FM_PORT_TYPE_HOST_COMMAND) &&
+    if ((p_LnxWrpFmPortDev->settings.param.portType == e_FM_PORT_TYPE_OH_HOST_COMMAND) &&
         (InitFmPcdDev((t_LnxWrpFmDev *)p_LnxWrpFmPortDev->h_LnxWrpFmDev) != E_OK))
         return -EIO;
 
@@ -1932,12 +1908,12 @@ static int /*__devinit*/ fm_port_probe(struct of_device *of_dev, const struct of
         Sprint (p_LnxWrpFmPortDev->name, "%s-port-tx%d", p_LnxWrpFmDev->name, p_LnxWrpFmPortDev->id+FM_MAX_NUM_OF_1G_TX_PORTS);
         p_LnxWrpFmPortDev->minor = p_LnxWrpFmPortDev->id + FM_MAX_NUM_OF_1G_TX_PORTS + DEV_FM_TX_PORTS_MINOR_BASE;
     }
-    else if (p_LnxWrpFmPortDev->settings.param.portType == e_FM_PORT_TYPE_HOST_COMMAND)
+    else if (p_LnxWrpFmPortDev->settings.param.portType == e_FM_PORT_TYPE_OH_HOST_COMMAND)
     {
         Sprint (p_LnxWrpFmPortDev->name, "%s-port-oh%d", p_LnxWrpFmDev->name, p_LnxWrpFmPortDev->id);
         p_LnxWrpFmPortDev->minor = p_LnxWrpFmPortDev->id + DEV_FM_OH_PORTS_MINOR_BASE;
     }
-    else if (p_LnxWrpFmPortDev->settings.param.portType == e_FM_PORT_TYPE_OFFLINE_PARSING)
+    else if (p_LnxWrpFmPortDev->settings.param.portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
     {
         Sprint (p_LnxWrpFmPortDev->name, "%s-port-oh%d", p_LnxWrpFmDev->name, p_LnxWrpFmPortDev->id+1);
         p_LnxWrpFmPortDev->minor = p_LnxWrpFmPortDev->id + 1 + DEV_FM_OH_PORTS_MINOR_BASE;
@@ -2074,9 +2050,9 @@ t_Handle LNXWRP_FM_Init(void)
 #endif /* !NO_OF_SUPPORT */
 
 #ifdef CONFIG_FSL_FMAN_TEST
-	/* Seed the QMan allocator so we'll have enough queues to run PCD with
-	   dinamically fqid-range allocation */
-	qman_release_fqid_range(0x100, 0x100);
+    /* Seed the QMan allocator so we'll have enough queues to run PCD with
+       dinamically fqid-range allocation */
+    qman_release_fqid_range(0x100, 0x100);
 #endif /* CONFIG_FSL_FMAN_TEST */
 
     return &lnxWrpFm;
@@ -2185,10 +2161,11 @@ void fm_set_rx_port_params(struct fm_port *port, struct fm_port_rx_params *param
 
     p_LnxWrpFmPortDev->buffPrefixContent.privDataSize     = params->priv_data_size;
     p_LnxWrpFmPortDev->buffPrefixContent.passPrsResult    = params->parse_results;
+    p_LnxWrpFmPortDev->buffPrefixContent.passHashResult   = params->hash_results;
 
     ADD_ADV_CONFIG_START(p_LnxWrpFmPortDev->settings.advConfig, FM_MAX_NUM_OF_ADV_SETTINGS)
 
-    ADD_ADV_CONFIG(FM_PORT_ConfigBufferPrefixContent,   ARGS(1, (&p_LnxWrpFmPortDev->buffPrefixContent)));
+    ADD_ADV_CONFIG_NO_RET(FM_PORT_ConfigBufferPrefixContent,   ARGS(1, (&p_LnxWrpFmPortDev->buffPrefixContent)));
 
     ADD_ADV_CONFIG_END
 
@@ -2214,10 +2191,11 @@ void fm_set_tx_port_params(struct fm_port *port, struct fm_port_non_rx_params *p
 
     p_LnxWrpFmPortDev->buffPrefixContent.privDataSize     = params->priv_data_size;
     p_LnxWrpFmPortDev->buffPrefixContent.passPrsResult    = params->parse_results;
+    p_LnxWrpFmPortDev->buffPrefixContent.passHashResult   = params->hash_results;
 
     ADD_ADV_CONFIG_START(p_LnxWrpFmPortDev->settings.advConfig, FM_MAX_NUM_OF_ADV_SETTINGS)
 
-    ADD_ADV_CONFIG(FM_PORT_ConfigBufferPrefixContent,   ARGS(1, (&p_LnxWrpFmPortDev->buffPrefixContent)));
+    ADD_ADV_CONFIG_NO_RET(FM_PORT_ConfigBufferPrefixContent,   ARGS(1, (&p_LnxWrpFmPortDev->buffPrefixContent)));
 
     ADD_ADV_CONFIG_END
 
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/lnxwrp_fm.h b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/lnxwrp_fm.h
index 7955577..244bb22 100644
--- a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/lnxwrp_fm.h
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/lnxwrp_fm.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/lnxwrp_fm_ioctls.c b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/lnxwrp_fm_ioctls.c
index 3cc7df1..599cc95 100644
--- a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/lnxwrp_fm_ioctls.c
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/lnxwrp_fm_ioctls.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -706,7 +706,7 @@ t_Error LnxwrpFmIOCTL(t_LnxWrpFmDev *p_LnxWrpFmDev, unsigned int cmd, unsigned l
                 return err;
             }
 
-            err = FM_SetCounter(p_LnxWrpFmDev->h_Dev, param->cnt, param->val);
+            err = FM_ModifyCounter(p_LnxWrpFmDev->h_Dev, param->cnt, param->val);
 
             XX_Free(param);
             return err;
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/xx/ctype.c b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/xx/ctype.c
index 96c73e2..5b4057d 100644
--- a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/xx/ctype.c
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/xx/ctype.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/xx/integrations/P4080/xx_integration.c b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/xx/integrations/P4080/xx_integration.c
index 92d7577..b8dcd22 100644
--- a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/xx/integrations/P4080/xx_integration.c
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/xx/integrations/P4080/xx_integration.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -154,14 +154,14 @@ int GetDeviceIrqNum(int irq)
 #endif    /* LINUX_VERSION_CODE */
 
 
-void * XX_PhysToVirt(void * addr)
+void * XX_PhysToVirt(physAddress_t addr)
 {
-    return CAST_UINT64_TO_POINTER(SYS_PhysToVirt(CAST_POINTER_TO_UINT64(addr)));
+    return CAST_UINT64_TO_POINTER(SYS_PhysToVirt((uint64_t)addr));
 }
 
-void * XX_VirtToPhys(void * addr)
+physAddress_t XX_VirtToPhys(void * addr)
 {
-    return CAST_UINT64_TO_POINTER(SYS_VirtToPhys(CAST_POINTER_TO_UINT64(addr)));
+    return (physAddress_t)SYS_VirtToPhys(CAST_POINTER_TO_UINT64(addr));
 }
 
 /*****************************************************************************/
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/xx/stdlib.c b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/xx/stdlib.c
index 3c0730a..08dfd10 100644
--- a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/xx/stdlib.c
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/xx/stdlib.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/xx/udivdi3.c b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/xx/udivdi3.c
index ca2fd17..190f4fa 100644
--- a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/xx/udivdi3.c
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/xx/udivdi3.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/xx/xx.h b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/xx/xx.h
index 45607d4..3db07d2 100644
--- a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/xx/xx.h
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/xx/xx.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/xx/xx_linux.c b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/xx/xx_linux.c
index 32f0e37..927ff4e 100644
--- a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/xx/xx_linux.c
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/xx/xx_linux.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -633,56 +633,44 @@ void XX_Unlock(t_MutexHandle h_Mutex)
 /*****************************************************************************/
 /*                         Spinlock Service Routines                         */
 /*****************************************************************************/
-typedef struct {
-    unsigned long   flags;
-    spinlock_t      *p_Lock;
-} t_Spinlock;
 
-t_SpinlockHandle XX_InitSpinlock(void)
+t_Handle XX_InitSpinlock(void)
 {
-    t_Spinlock *p_Spinlock = (t_Spinlock *)XX_Malloc(sizeof(t_Spinlock));
+    spinlock_t *p_Spinlock = (spinlock_t *)XX_Malloc(sizeof(spinlock_t));
     if (!p_Spinlock)
         return NULL;
-    memset(p_Spinlock, 0 , sizeof(t_Spinlock));
-    p_Spinlock->p_Lock = (spinlock_t *)XX_Malloc(sizeof(spinlock_t));
-    if (!p_Spinlock->p_Lock)
-    {
-        XX_Free(p_Spinlock);
-        return NULL;
-    }
 
-    spin_lock_init (p_Spinlock->p_Lock);
-    return (t_SpinlockHandle)p_Spinlock;
+    spin_lock_init(p_Spinlock);
+
+    return (t_Handle)p_Spinlock;
 }
 
-void XX_FreeSpinlock(t_SpinlockHandle h_Spinlock)
+void XX_FreeSpinlock(t_Handle h_Spinlock)
 {
     if (h_Spinlock)
-    {
-        if (((t_Spinlock *)h_Spinlock)->p_Lock)
-            XX_Free(((t_Spinlock *)h_Spinlock)->p_Lock);
         XX_Free(h_Spinlock);
-    }
 }
 
-void XX_Spinlock(t_SpinlockHandle h_Spinlock)
+void XX_LockSpinlock(t_Handle h_Spinlock)
 {
-    spin_lock(((t_Spinlock *)h_Spinlock)->p_Lock);
+    spin_lock((spinlock_t *)h_Spinlock);
 }
 
-void XX_Spinunlock(t_SpinlockHandle h_Spinlock)
+void XX_UnlockSpinlock(t_Handle h_Spinlock)
 {
-    spin_unlock(((t_Spinlock *)h_Spinlock)->p_Lock);
+    spin_unlock((spinlock_t *)h_Spinlock);
 }
 
-void XX_IntrSpinlock(t_SpinlockHandle h_Spinlock)
+uint32_t XX_LockIntrSpinlock(t_Handle h_Spinlock)
 {
-    spin_lock_irqsave(((t_Spinlock *)h_Spinlock)->p_Lock, ((t_Spinlock *)h_Spinlock)->flags);
+    unsigned long intrFlags;
+    spin_lock_irqsave((spinlock_t *)h_Spinlock, intrFlags);
+    return intrFlags;
 }
 
-void XX_IntrSpinunlock(t_SpinlockHandle h_Spinlock)
+void XX_UnlockIntrSpinlock(t_Handle h_Spinlock, uint32_t intrFlags)
 {
-    spin_unlock_irqrestore(((t_Spinlock *)h_Spinlock)->p_Lock, ((t_Spinlock *)h_Spinlock)->flags);
+     spin_unlock_irqrestore((spinlock_t *)h_Spinlock, (unsigned long)intrFlags);
 }
 
 
@@ -696,7 +684,7 @@ uint32_t XX_CurrentTime(void)
 }
 
 
-t_TimerHandle XX_CreateTimer(void)
+t_Handle XX_CreateTimer(void)
 {
     struct timer_list *p_Timer = (struct timer_list *)XX_Malloc(sizeof(struct timer_list));
     if (p_Timer)
@@ -704,20 +692,20 @@ t_TimerHandle XX_CreateTimer(void)
         memset(p_Timer, 0, sizeof(struct timer_list));
         init_timer(p_Timer);
     }
-    return (t_TimerHandle)p_Timer;
+    return (t_Handle)p_Timer;
 }
 
-void XX_FreeTimer(t_TimerHandle h_Timer)
+void XX_FreeTimer(t_Handle h_Timer)
 {
     if (h_Timer)
         XX_Free(h_Timer);
 }
 
-void XX_StartTimer(t_TimerHandle    h_Timer,
-                   uint32_t         msecs,
-                   bool             periodic,
-                   void             (*f_TimerExpired)(t_Handle),
-                   t_Handle         h_Arg)
+void XX_StartTimer(t_Handle h_Timer,
+                   uint32_t msecs,
+                   bool     periodic,
+                   void     (*f_TimerExpired)(t_Handle),
+                   t_Handle h_Arg)
 {
     int                 tmp_jiffies = (msecs*HZ)/1000;
     struct timer_list   *p_Timer = (struct timer_list *)h_Timer;
@@ -733,33 +721,33 @@ void XX_StartTimer(t_TimerHandle    h_Timer,
     add_timer((struct timer_list *)h_Timer);
 }
 
-void XX_SetTimerData(t_TimerHandle h_Timer, t_Handle data)
+void XX_SetTimerData(t_Handle h_Timer, t_Handle data)
 {
     struct timer_list   *p_Timer = (struct timer_list *)h_Timer;
 
     p_Timer->data = (unsigned long)data;
 }
 
-t_Handle XX_GetTimerData(t_TimerHandle h_Timer)
+t_Handle XX_GetTimerData(t_Handle h_Timer)
 {
     struct timer_list   *p_Timer = (struct timer_list *)h_Timer;
 
     return (t_Handle)p_Timer->data;
 }
 
-uint32_t   XX_GetExpirationTime(t_TimerHandle h_Timer)
+uint32_t   XX_GetExpirationTime(t_Handle h_Timer)
 {
     struct timer_list   *p_Timer = (struct timer_list *)h_Timer;
 
     return (uint32_t)p_Timer->expires;
 }
 
-void XX_StopTimer(t_TimerHandle h_Timer)
+void XX_StopTimer(t_Handle h_Timer)
 {
     del_timer((struct timer_list *)h_Timer);
 }
 
-void XX_ModTimer(t_TimerHandle h_Timer, uint32_t msecs)
+void XX_ModTimer(t_Handle h_Timer, uint32_t msecs)
 {
     int tmp_jiffies = (msecs*HZ)/1000;
 
@@ -768,7 +756,7 @@ void XX_ModTimer(t_TimerHandle h_Timer, uint32_t msecs)
     mod_timer((struct timer_list *)h_Timer, jiffies + tmp_jiffies);
 }
 
-int XX_TimerIsActive(t_TimerHandle h_Timer)
+int XX_TimerIsActive(t_Handle h_Timer)
 {
   return timer_pending((struct timer_list *)h_Timer);
 }
diff --git a/drivers/net/dpa/mac-api.c b/drivers/net/dpa/mac-api.c
index 9b77bb6..e8b0c87 100644
--- a/drivers/net/dpa/mac-api.c
+++ b/drivers/net/dpa/mac-api.c
@@ -121,8 +121,8 @@ static int __devinit __cold init(struct mac_device *mac_dev)
 	param.macId			= mac_dev->cell_index;
 	param.h_Fm 			= (t_Handle)mac_dev->fm;
 	param.mdioIrq		= NO_IRQ;
-	param.f_Exceptions	= mac_exception;
-	param.f_Events		= mac_exception;
+	param.f_Exception	= mac_exception;
+	param.f_Event		= mac_exception;
 	param.h_App			= mac_dev;
 
 	priv->mac = FM_MAC_Config(&param);
-- 
1.6.5.2

