From 8c0ac220c682faf5b5e00d3eadff0cf790543f70 Mon Sep 17 00:00:00 2001
From: Geoff Thorpe <Geoff.Thorpe@freescale.com>
Date: Thu, 3 Dec 2009 13:49:48 +0800
Subject: [PATCH] bman: drain non-empty BPIDs when they're deallocated.

This works around driver bugs one layer up. It may be that releasing a
non-empty pool is ok from the caller perspective (ie. where the remaining
buffer tokens don't represent any memory that needs to be deallocated),
but it could crash the next user of the BPID, particularly if they expect
the pool empty or manage buffers of a different type.

Signed-off-by: Geoff Thorpe <Geoff.Thorpe@freescale.com>
[Kevin: Original patch taken from Freescale p4080 SDK 2.0.1 ISO
image. Apply cleanly to kernel 2.6.27]
Integrated-by: Kevin Hao <kexin.hao@windriver.com>
---
 drivers/hwalloc/bman_high.c |   18 +++++++++++++++++-
 1 files changed, 17 insertions(+), 1 deletions(-)

diff --git a/drivers/hwalloc/bman_high.c b/drivers/hwalloc/bman_high.c
index df8fdeb..4d63d56 100644
--- a/drivers/hwalloc/bman_high.c
+++ b/drivers/hwalloc/bman_high.c
@@ -446,8 +446,24 @@ void bman_free_pool(struct bman_pool *pool)
 	if (pool->params.flags & BMAN_POOL_FLAG_DEPLETION)
 		depletion_unlink(pool);
 #ifdef CONFIG_FSL_BMAN_CONFIG
-	if (pool->params.flags & BMAN_POOL_FLAG_DYNAMIC_BPID)
+	if (pool->params.flags & BMAN_POOL_FLAG_DYNAMIC_BPID) {
+		/* When releasing a BPID to the dynamic allocator, that pool
+		 * must be *empty*. This code makes it so by dropping everything
+		 * into the bit-bucket. This ignores whether or not it was a
+		 * mistake (or a leak) on the caller's part not to drain the
+		 * pool beforehand. */
+		struct bm_buffer bufs[8];
+		int ret = 0;
+		do {
+			/* Acquire is all-or-nothing, so we drain in 8s, then in
+			 * 1s for the remainder. */
+			if (ret != 1)
+				ret = bman_acquire(pool, bufs, 8, 0);
+			if (ret < 8)
+				ret = bman_acquire(pool, bufs, 1, 0);
+		} while (ret > 0);
 		bm_pool_free(pool->params.bpid);
+	}
 #endif
 	kfree(pool);
 }
-- 
1.6.0.4

