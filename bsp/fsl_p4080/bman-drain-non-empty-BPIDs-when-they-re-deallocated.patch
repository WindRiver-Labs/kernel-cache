From 4728cf3d7b01cb688e0f421f341daa3721a918a3 Mon Sep 17 00:00:00 2001
From: Geoff Thorpe <Geoff.Thorpe@freescale.com>
Date: Thu, 3 Dec 2009 13:49:48 +0800
Subject: [PATCH 105/148] bman: drain non-empty BPIDs when they're deallocated.

This works around driver bugs one layer up. It may be that releasing a
non-empty pool is ok from the caller perspective (ie. where the remaining
buffer tokens don't represent any memory that needs to be deallocated),
but it could crash the next user of the BPID, particularly if they expect
the pool empty or manage buffers of a different type.

Signed-off-by: Geoff Thorpe <Geoff.Thorpe@freescale.com>
[Applied FSL SDK 2.0.3 patch
"kernel-2.6.30-bman-drain-non-empty-BPIDs-when-they-re-deallocated.patch"]
Integrated-by: Yuri Nedel <Yuri.Nedel@windriver.com>
---
 drivers/hwalloc/bman_high.c |   18 +++++++++++++++++-
 1 files changed, 17 insertions(+), 1 deletions(-)

diff --git a/drivers/hwalloc/bman_high.c b/drivers/hwalloc/bman_high.c
index c5f992a..a6e2937 100644
--- a/drivers/hwalloc/bman_high.c
+++ b/drivers/hwalloc/bman_high.c
@@ -446,8 +446,24 @@ void bman_free_pool(struct bman_pool *pool)
 	if (pool->params.flags & BMAN_POOL_FLAG_DEPLETION)
 		depletion_unlink(pool);
 #ifdef CONFIG_FSL_BMAN_CONFIG
-	if (pool->params.flags & BMAN_POOL_FLAG_DYNAMIC_BPID)
+	if (pool->params.flags & BMAN_POOL_FLAG_DYNAMIC_BPID) {
+		/* When releasing a BPID to the dynamic allocator, that pool
+		 * must be *empty*. This code makes it so by dropping everything
+		 * into the bit-bucket. This ignores whether or not it was a
+		 * mistake (or a leak) on the caller's part not to drain the
+		 * pool beforehand. */
+		struct bm_buffer bufs[8];
+		int ret = 0;
+		do {
+			/* Acquire is all-or-nothing, so we drain in 8s, then in
+			 * 1s for the remainder. */
+			if (ret != 1)
+				ret = bman_acquire(pool, bufs, 8, 0);
+			if (ret < 8)
+				ret = bman_acquire(pool, bufs, 1, 0);
+		} while (ret > 0);
 		bm_pool_free(pool->params.bpid);
+	}
 #endif
 	kfree(pool);
 }
-- 
1.6.5.2

