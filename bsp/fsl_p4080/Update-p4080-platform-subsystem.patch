From 74a3fd1398650ba99b3f6b0b6fca91e0c5f3fec4 Mon Sep 17 00:00:00 2001
From: Andrew Liu <shengping.liu@windriver.com>
Date: Tue, 22 Feb 2011 16:20:07 +0800
Subject: [PATCH 1/3] Update p4080 platform subsystem

Patch taken from FSL vendor SDK 2.2.

Change the name of p4080ds_mdio.c to corenet_ds_mdio.c in order to
share this file among different boards whose CPU is p4080.

Rarrange MDIO bus probe , PCI bus probe and Fman/Qman/Bman/PME init
from p4080_ds.c to corenet_ds.c, also in order to share them among
different boards whose CPU is p4080

Integrated-by: Andrew Liu <shengping.liu@windriver.com>

[Move changes for p4080_ds.c and p4080ds_mdio.c to an independent
 patch, because this two files is platform level.]

Integrated-by: Hui Wang <Hui.Wang@windriver.com>
---
 arch/powerpc/platforms/85xx/Makefile       |    3 +-
 arch/powerpc/platforms/85xx/p4080_ds.c     |  102 ++--------
 arch/powerpc/platforms/85xx/p4080ds_mdio.c |  286 ----------------------------
 3 files changed, 20 insertions(+), 371 deletions(-)
 delete mode 100644 arch/powerpc/platforms/85xx/p4080ds_mdio.c

diff --git a/arch/powerpc/platforms/85xx/Makefile b/arch/powerpc/platforms/85xx/Makefile
index 5d48558..6b0b7a2 100644
--- a/arch/powerpc/platforms/85xx/Makefile
+++ b/arch/powerpc/platforms/85xx/Makefile
@@ -12,7 +12,8 @@ obj-$(CONFIG_MPC8536_DS)  += mpc8536_ds.o
 obj-$(CONFIG_MPC85xx_DS)  += mpc85xx_ds.o
 obj-$(CONFIG_MPC85xx_MDS) += mpc85xx_mds.o
 obj-$(CONFIG_MPC85xx_RDB) += mpc85xx_rdb.o
-obj-$(CONFIG_P4080_DS)    += p4080_ds.o corenet_ds.o p4080ds_mdio.o
+obj-$(CONFIG_P4080_DS)    += p4080_ds.o corenet_ds.o
+obj-$(CONFIG_FSL_CORENET_DS_MDIO) += corenet_ds_mdio.o
 obj-$(CONFIG_P4080_SIM)   += p4080_sim.o
 obj-$(CONFIG_P4080_HV)    += p4080_hv.o
 obj-$(CONFIG_STX_GP3)	  += stx_gp3.o
diff --git a/arch/powerpc/platforms/85xx/p4080_ds.c b/arch/powerpc/platforms/85xx/p4080_ds.c
index 237a059..d21c3ad 100644
--- a/arch/powerpc/platforms/85xx/p4080_ds.c
+++ b/arch/powerpc/platforms/85xx/p4080_ds.c
@@ -2,6 +2,7 @@
  * P4080 DS Setup
  *
  * Maintained by Kumar Gala (see MAINTAINERS for contact information)
+ *
  * Copyright 2009-2010 Freescale Semiconductor Inc.
  *
  * This program is free software; you can redistribute  it and/or modify it
@@ -32,48 +33,6 @@
 
 #include "corenet_ds.h"
 
-#ifdef CONFIG_PCI
-static int primary_phb_addr;
-#endif
-
-#ifdef CONFIG_NET
-int vsc824x_add_skew(struct phy_device *phydev);
-#define PHY_ID_VSC8244                  0x000fc6c0
-static int __init board_fixups(void)
-{
-	phy_register_fixup_for_uid(PHY_ID_VSC8244, 0xfffff, vsc824x_add_skew);
-
-	return 0;
-}
-machine_device_initcall(p4080_ds, board_fixups);
-#endif
-
-static int __init declare_of_platform_devices(void)
-{
-	struct device_node *np;
-	struct of_device *dev;
-
-	/* Now probe the fake MDIO buses */
-	for_each_compatible_node(np, NULL, "fsl,p4080ds-mdio") {
-		dev = of_platform_device_create(np, NULL, NULL);
-		if (!dev) {
-			of_node_put(np);
-			return -ENOMEM;
-		}
-	}
-
-	for_each_compatible_node(np, NULL, "fsl,p4080ds-xmdio") {
-		dev = of_platform_device_create(np, NULL, NULL);
-		if (!dev) {
-			of_node_put(np);
-			return -ENOMEM;
-		}
-	}
-
-	return 0;
-}
-machine_device_initcall(p4080_ds, declare_of_platform_devices);
-
 /*
  * Called very early, device-tree isn't unflattened
  */
@@ -81,48 +40,20 @@ static int __init p4080_ds_probe(void)
 {
 	unsigned long root = of_get_flat_dt_root();
 
-	if (of_flat_dt_is_compatible(root, "fsl,P4080DS")) {
-#ifdef CONFIG_PCI
-		/* xxx - galak */
-		primary_phb_addr = 0x8000;
-#endif
-		return 1;
-	} else {
-		return 0;
-	}
+	return of_flat_dt_is_compatible(root, "fsl,P4080DS");
 }
 
-/* Early setup is required for large chunks of contiguous (and coarsely-aligned)
- * memory. The following shoe-horns Qman/Bman "init_early" calls into the
- * platform setup to let them parse their CCSR nodes early on. */
-#ifdef CONFIG_FSL_FMAN
-void __init fman_init_early(void);
-#endif
-#ifdef CONFIG_FSL_QMAN_CONFIG
-void __init qman_init_early(void);
-#endif
-#ifdef CONFIG_FSL_BMAN_CONFIG
-void __init bman_init_early(void);
-#endif
-#ifdef CONFIG_FSL_PME2_CTRL
-void __init pme2_init_early(void);
-#endif
-
-static __init void p4080_init_early(void)
+#if defined(CONFIG_PHYLIB) && defined(CONFIG_VITESSE_PHY)
+int vsc824x_add_skew(struct phy_device *phydev);
+#define PHY_ID_VSC8244                  0x000fc6c0
+static int __init board_fixups(void)
 {
-#ifdef CONFIG_FSL_FMAN
-	fman_init_early();
-#endif
-#ifdef CONFIG_FSL_QMAN_CONFIG
-	qman_init_early();
-#endif
-#ifdef CONFIG_FSL_BMAN_CONFIG
-	bman_init_early();
-#endif
-#ifdef CONFIG_FSL_PME2_CTRL
-	pme2_init_early();
-#endif
+	phy_register_fixup_for_uid(PHY_ID_VSC8244, 0xfffff, vsc824x_add_skew);
+
+	return 0;
 }
+machine_device_initcall(p4080_ds, board_fixups);
+#endif
 
 define_machine(p4080_ds) {
 	.name			= "P4080 DS",
@@ -136,10 +67,13 @@ define_machine(p4080_ds) {
 	.restart		= fsl_rstcr_restart,
 	.calibrate_decr		= generic_calibrate_decr,
 	.progress		= udbg_progress,
-	.init_early		= p4080_init_early,
-	.idle_loop              = cpu_idle_simple,
-	.power_save             = ppc_wait,
+	.idle_loop		= cpu_idle_simple,
+	.power_save		= ppc_wait,
+	.init_early		= corenet_ds_init_early,
 };
 
-machine_device_initcall(p4080_ds, corenet_ds_publish_devices);
+machine_device_initcall(p4080_ds, declare_of_platform_devices);
+
+#ifdef CONFIG_SWIOTLB
 machine_arch_initcall(p4080_ds, swiotlb_setup_bus_notifier);
+#endif
diff --git a/arch/powerpc/platforms/85xx/p4080ds_mdio.c b/arch/powerpc/platforms/85xx/p4080ds_mdio.c
deleted file mode 100644
index 2af8a7e..0000000
--- a/arch/powerpc/platforms/85xx/p4080ds_mdio.c
+++ /dev/null
@@ -1,286 +0,0 @@
-/*
- * Freescale P4080DS MDIO bus
- * provides proper gpio muxing for the MDIO buses on the P4080 DS
- *
- * Author: Andy Fleming <afleming@freescale.com>
- *
- * Copyright (c) 2009 Freescale Semiconductor, Inc.
- *
- * This program is free software; you can redistribute  it and/or modify it
- * under  the terms of  the GNU General  Public License as published by the
- * Free Software Foundation;  either version 2 of the  License, or (at your
- * option) any later version.
- *
- */
-
-#ifdef CONFIG_NET
-#include <linux/kernel.h>
-#include <linux/string.h>
-#include <linux/errno.h>
-#include <linux/unistd.h>
-#include <linux/slab.h>
-#include <linux/interrupt.h>
-#include <linux/init.h>
-#include <linux/delay.h>
-#include <linux/netdevice.h>
-#include <linux/etherdevice.h>
-#include <linux/skbuff.h>
-#include <linux/spinlock.h>
-#include <linux/mm.h>
-#include <linux/module.h>
-#include <linux/platform_device.h>
-#include <linux/crc32.h>
-#include <linux/mii.h>
-#include <linux/phy.h>
-#include <linux/of.h>
-#include <linux/of_mdio.h>
-#include <linux/of_platform.h>
-
-#include <asm/io.h>
-#include <asm/irq.h>
-#include <asm/uaccess.h>
-
-struct p4080ds_mdio {
-	struct mii_bus *real_bus;
-	u32 *gpio_reg;
-	u32 gpio_value;
-	u32 gpio_mask;
-};
-
-/* Set the GPIO mux, and then write the MDIO regs */
-int p4080ds_mdio_write(struct mii_bus *bus, int port_addr, int dev_addr,
-			int regnum, u16 value)
-{
-	struct p4080ds_mdio *priv = bus->priv;
-
-	/* Write the GPIO regs to select this bus */
-	clrsetbits_be32(priv->gpio_reg, priv->gpio_mask, priv->gpio_value);
-
-	/* Write through to the attached MDIO bus */
-	return priv->real_bus->write(priv->real_bus, port_addr, dev_addr,
-					regnum, value);
-}
-
-/* Set the GPIO muxing, and then read from the MDIO bus */
-int p4080ds_mdio_read(struct mii_bus *bus, int port_addr, int dev_addr,
-			int regnum)
-{
-	struct p4080ds_mdio *priv = bus->priv;
-
-	/* Write the GPIO regs to select this bus */
-	clrsetbits_be32(priv->gpio_reg, priv->gpio_mask, priv->gpio_value);
-
-	return priv->real_bus->read(priv->real_bus, port_addr, dev_addr,
-					regnum);
-}
-
-
-/* Reset the MIIM registers, and wait for the bus to free */
-static int p4080ds_mdio_reset(struct mii_bus *bus)
-{
-	struct p4080ds_mdio *priv = bus->priv;
-
-	 /* each device already locks this themselves when called, don't lock
-	  * &bus->mdio_lock here! */
-	priv->real_bus->reset(priv->real_bus);
-
-	return 0;
-}
-
-
-#define GPIO_GPDAT_OFFSET	2
-#define GPIO_GPDIR_MDIO		0xf0000000
-
-static int p4080ds_mdio_probe(struct of_device *ofdev,
-		const struct of_device_id *match)
-{
-	struct device_node *np = ofdev->node;
-	struct mii_bus *new_bus;
-	struct p4080ds_mdio *priv;
-	struct device_node *mdio, *gpio;
-	struct of_device *ofmdiodev;
-	u64 reg;
-	int i;
-	const u32 *addr;
-	const u32 *val;
-	int err = 0;
-
-	if (!of_device_is_available(np))
-		return -ENODEV;
-
-	new_bus = mdiobus_alloc();
-	if (NULL == new_bus)
-		return -ENOMEM;
-
-	new_bus->name = "Freescale P4080DS MDIO Bus",
-	new_bus->read = &p4080ds_mdio_read,
-	new_bus->write = &p4080ds_mdio_write,
-	new_bus->reset = &p4080ds_mdio_reset,
-
-	priv = kzalloc(sizeof(*priv), GFP_KERNEL);
-	if (!priv) {
-		err = -ENOMEM;
-		goto err_priv_alloc;
-	}
-
-	new_bus->priv = priv;
-
-	mdio = of_parse_phandle(np, "fsl,mdio-handle", 0);
-
-	if (mdio == NULL) {
-		printk(KERN_ERR "Could not find real MDIO bus for %s\n",
-			new_bus->id);
-		err = -ENODEV;
-		goto err_no_mdio_node;
-	}
-
-	ofmdiodev = of_find_device_by_node(mdio);
-
-	if (!ofmdiodev) {
-		printk(KERN_ERR "No of_device for MDIO node %s\n", mdio->name);
-		err = -ENODEV;
-		goto err_no_mdio_dev;
-	}
-
-	of_node_put(mdio);
-
-	priv->real_bus = dev_get_drvdata(&ofmdiodev->dev);
-
-	if (!priv->real_bus) {
-		printk(KERN_ERR "The MDIO bus has no ofdev!\n");
-		err = -ENODEV;
-		goto err_no_ofdev;
-	}
-
-	new_bus->irq = kcalloc(PHY_MAX_ADDR, sizeof(int), GFP_KERNEL);
-
-	if (NULL == new_bus->irq) {
-		err = -ENOMEM;
-		goto err_irq_alloc;
-	}
-
-	for (i = 0; i < PHY_MAX_ADDR; i++)
-		new_bus->irq[i] = PHY_POLL;
-
-	new_bus->parent = &ofdev->dev;
-	dev_set_drvdata(&ofdev->dev, new_bus);
-
-	/* Find the GPIO register pointer */
-	gpio = of_find_compatible_node(NULL, NULL, "fsl,qoriq-gpio");
-
-	if (!gpio) {
-		err = -ENODEV;
-		goto err_no_gpio;
-	}
-
-	addr = of_get_address(gpio, 0, NULL, NULL);
-	if (!addr) {
-		err = -ENODEV;
-		goto err_no_gpio_addr;
-	}
-
-	reg = of_translate_address(gpio, addr);
-
-	priv->gpio_reg = ioremap(reg, sizeof(*priv->gpio_reg));
-
-	if (!priv->gpio_reg) {
-		err = -ENOMEM;
-		goto err_ioremap;
-	}
-
-	/* Set the direction of the GPIO ports used by MDIO bus */
-	setbits32(priv->gpio_reg, GPIO_GPDIR_MDIO);
-
-	priv->gpio_reg += GPIO_GPDAT_OFFSET;
-
-	/* Grab the value to write to the GPIO */
-	val = of_get_property(np, "fsl,muxval", NULL);
-
-	if (!val) {
-		printk(KERN_ERR "No mux value found for %s\n", np->full_name);
-		err = -ENODEV;
-		goto err_get_muxval;
-	}
-
-	if (of_device_is_compatible(np, "fsl,p4080ds-mdio")) {
-		priv->gpio_mask = 0xc0000000;
-		priv->gpio_value = (*val << 30);
-	} else if (of_device_is_compatible(np, "fsl,p4080ds-xmdio")) {
-		priv->gpio_mask = 0x30000000;
-		priv->gpio_value = (*val << 28);
-	}
-
-	sprintf(new_bus->id, "%s@%d", np->name, *val);
-
-	err = of_mdiobus_register(new_bus, np);
-
-	if (err) {
-		printk(KERN_ERR "%s: Cannot register as MDIO bus\n",
-				new_bus->name);
-		goto err_registration;
-	}
-
-	return 0;
-
-err_registration:
-err_get_muxval:
-	iounmap(priv->gpio_reg);
-err_ioremap:
-err_no_gpio_addr:
-err_no_gpio:
-	kfree(new_bus->irq);
-err_irq_alloc:
-err_no_ofdev:
-err_no_mdio_dev:
-err_no_mdio_node:
-	kfree(priv);
-err_priv_alloc:
-	kfree(new_bus);
-
-	return err;
-}
-
-
-static int p4080ds_mdio_remove(struct of_device *ofdev)
-{
-	struct device *device = &ofdev->dev;
-	struct mii_bus *bus = dev_get_drvdata(device);
-
-	mdiobus_unregister(bus);
-
-	dev_set_drvdata(device, NULL);
-
-	bus->priv = NULL;
-	mdiobus_free(bus);
-
-	return 0;
-}
-
-static struct of_device_id p4080ds_mdio_match[] = {
-	{
-		.compatible = "fsl,p4080ds-mdio",
-	},
-	{
-		.compatible = "fsl,p4080ds-xmdio",
-	},
-};
-
-static struct of_platform_driver p4080ds_mdio_driver = {
-	.name = "p4080ds_mdio",
-	.probe = p4080ds_mdio_probe,
-	.remove = p4080ds_mdio_remove,
-	.match_table = p4080ds_mdio_match,
-};
-
-int __init p4080ds_mdio_init(void)
-{
-	return of_register_platform_driver(&p4080ds_mdio_driver);
-}
-
-void p4080ds_mdio_exit(void)
-{
-	of_unregister_platform_driver(&p4080ds_mdio_driver);
-}
-subsys_initcall_sync(p4080ds_mdio_init);
-module_exit(p4080ds_mdio_exit);
-#endif /* CONFIG_NET */
-- 
1.6.5.2

