From c7da146ca65793f9bd94de5038eb9666aed07e17 Mon Sep 17 00:00:00 2001
From: Steve Cornelius <steve.cornelius@freescale.com>
Date: Tue, 22 Sep 2009 16:30:14 +0800
Subject: [PATCH 22/52] DCL and unit test updates for P4080 beta 1.2

Includes:
- Complete set of instruction generation functions (except Signature)
- High level descriptors for blockciphers, HMACs, SNOW-3G, transport
  mode, WiFi, MacSec, 3GPP-RLC, RSA, and DSA verification
- Expanded disassembler support for all
- Expanded JobQ unit test support for blockciphers, HMACs, and SNOW3G
[KevinHao: Original patch taken from Freescale rev 1.2 board support
ISO image for p4080]
Integrated-by: Kevin Hao <kexin.hao@windriver.com>
---
 drivers/crypto/caam/dcl/cmdgen.c           |  914 +++++++++++++++-
 drivers/crypto/caam/dcl/dcl.h              |  693 +++++-------
 drivers/crypto/caam/dcl/disasm.c           | 1700 +++++++++++++++++++++++++++-
 drivers/crypto/caam/dcl/jobdesc.c          |  346 ++++++-
 drivers/crypto/caam/dcl/protoshared.c      | 1000 ++++++++++++++++
 drivers/crypto/caam/desc.h                 |  370 ++++++-
 drivers/crypto/caam/intern.h               |    5 +
 drivers/crypto/caam/jq.c                   |    5 +
 drivers/crypto/caam/jq.h                   |    5 +
 drivers/crypto/caam/jq_test/Makefile       |    2 +-
 drivers/crypto/caam/jq_test/caam_jqtest.c  |   39 +-
 drivers/crypto/caam/jq_test/caam_jqtest.h  |    9 +
 drivers/crypto/caam/jq_test/jq_blkcipher.c |  322 ++++++
 drivers/crypto/caam/jq_test/jq_ipsec.c     |    5 +
 drivers/crypto/caam/jq_test/jq_snow.c      |  280 +++++
 drivers/crypto/caam/regs.h                 |    5 +
 16 files changed, 5199 insertions(+), 501 deletions(-)
 create mode 100644 drivers/crypto/caam/jq_test/jq_blkcipher.c
 create mode 100644 drivers/crypto/caam/jq_test/jq_snow.c

diff --git a/drivers/crypto/caam/dcl/cmdgen.c b/drivers/crypto/caam/dcl/cmdgen.c
index f3b2d10..27ec65c 100644
--- a/drivers/crypto/caam/dcl/cmdgen.c
+++ b/drivers/crypto/caam/dcl/cmdgen.c
@@ -43,7 +43,38 @@
  * either as a build-time or run-time option.
  */
 
-
+/**
+ * cmd_insert_shared_hdr()
+ * Insert a shared descriptor header into a descriptor
+ *
+ * Returns: Pointer to next incremental descriptor word past the header
+ * just constructed. If an error occurred, returns 0.
+ *
+ * @descwd   = pointer to target descriptor word to hold this command.
+ *             Note that this should always be the first word of a
+ *             descriptor.
+ * @startidx = index to continuation of descriptor data, normally the
+ *             first descriptor word past a PDB. This tells DECO what
+ *             to skip over.
+ * @desclen  = length of descriptor in words, including header.
+ * @ctxsave  = Saved or erases context when a descriptor is self-shared
+ *             - CTX_SAVE  = context saved between iterations
+ *             - CTX_ERASE = context is erased
+ * @share    = Share state of this descriptor:
+ *             - SHR_NEVER  = Never share. Fetching is repeated for each
+ *                            processing pass.
+ *             - SHR_WAIT   = Share once processing starts.
+ *             - SHR_SERIAL = Share once completed.
+ *             - SHR_ALWAYS = Always share (except keys)
+ *
+ * Note: Headers should normally be constructed as the final operation
+ *       in the descriptor construction, because the start index and
+ *       overall descriptor length will likely not be known until
+ *       construction is complete. For this reason, there is little use
+ *       to the "incremental pointer" convention. The exception is probably
+ *       in the construction of simple descriptors where the size is easily
+ *       known early in the construction process.
+ **/
 u_int32_t *cmd_insert_shared_hdr(u_int32_t *descwd, u_int8_t startidx,
 				 u_int8_t desclen, enum ctxsave ctxsave,
 				 enum shrst share)
@@ -57,6 +88,59 @@ u_int32_t *cmd_insert_shared_hdr(u_int32_t *descwd, u_int8_t startidx,
 	return descwd + 1;
 }
 
+/**
+ * cmd_insert_hdr()
+ * Insert a standard descriptor header into a descriptor
+ *
+ * Returns: Pointer to next incremental descriptor word past the header
+ * just constructed. If an error occurred, returns 0.
+ *
+ * @descwd   = pointer to target descriptor word to hold this command.
+ *             Note that this should always be the first word of a
+ *             descriptor.
+ *
+ * @startidx = index to continuation of descriptor data, or if
+ *             sharenext = SHRNXT_SHARED, then specifies the size
+ *             of the associated shared descriptor referenced in
+ *             the following instruction.
+ *
+ * @desclen  = length of descriptor in words, including header
+ *
+ * @share    = Share state for this descriptor:
+ *             - SHR_NEVER  = Never share. Fetching is repeated for each
+ *                            processing pass.
+ *             - SHR_WAIT   = Share once processing starts.
+ *             - SHR_SERIAL = Share once completed.
+ *             - SHR_ALWAYS = Always share (except keys)
+ *             - SHR_DEFER  = Use the referenced sharedesc to determine
+ *                             sharing intent
+ *
+ * @sharenext = Control state of shared descriptor processing
+ *              - SHRNXT_SHARED = This is a job descriptor consisting
+ *                                of a header and a pointer to a shared
+ *                                descriptor only.
+ *              - SHRNXT_LENGTH = This is a detailed job descriptor, thus
+ *                                desclen refers to the full length of this
+ *                                descriptor.
+ *
+ * @reverse   = Reverse execution order between this job descriptor, and
+ *              an associated shared descriptor:
+ *              - ORDER_REVERSE - execute this descriptor before the shared
+ *                                descriptor referenced.
+ *              - ORDER_FORWARD - execute the shared descriptor, then this
+ *                                descriptor.
+ *
+ * @mktrusted = DESC_SIGN - sign this descriptor prior to execuition
+ *              DESC_STD  - leave descriptor non-trusted
+ *
+ * Note: Headers should normally be constructed as the final operation
+ *       of descriptor construction, because the start index and
+ *       overall descriptor length will likely not be known until
+ *       construction is complete. For this reason, there is little use
+ *       to the "incremental pointer" convention. The exception is probably
+ *       in the construction of simple descriptors where the size is easily
+ *       known early in the construction process.
+ **/
 u_int32_t *cmd_insert_hdr(u_int32_t *descwd, u_int8_t startidx,
 			  u_int8_t desclen, enum shrst share,
 			  enum shrnext sharenext, enum execorder reverse,
@@ -73,6 +157,49 @@ u_int32_t *cmd_insert_hdr(u_int32_t *descwd, u_int8_t startidx,
 	return descwd + 1;
 }
 
+/**
+ * cmd_insert_key()
+ * Insert a key command into a descriptor
+ *
+ * Returns: If successful, returns a pointer to the target word
+ * incremented past the newly-inserted command (including item pointer
+ * or inlined data). Effectively, this becomes a pointer to the next
+ * word to receive a new command in this descriptor. If error, returns 0
+ *
+ * @descwd  = pointer to target descriptor word to hold this command
+ *
+ * @key     = pointer to key data as an array of bytes.
+ *
+ * @keylen  = pointer to key size, expressed in bits.
+ *
+ * @sgref   = pointer is actual data, or a scatter-gather list
+ *            representing the key:
+ *            - PTR_DIRECT = points to data
+ *            - PTR_SGLIST = points to CAAM-specific scatter gather
+ *              table. Cannot use if imm = ITEM_INLINE.
+ *
+ * @dest    = target destination in CAAM to receive the key. This may be:
+ *            - KEYDST_KEYREG   = Key register in the CHA selected by an
+ *                                OPERATION command.
+ *            - KEYDST_PK_E     = The 'e' register in the public key block
+ *            - KEYDST_AF_SBOX  = Direct SBOX load if ARC4 is selected
+ *            - KEYDST_MD_SPLIT = Message digest IPAD/OPAD direct load.
+ *
+ * @cover   = Key was encrypted, and must be decrypted during the load.
+ *            If trusted descriptor, use TDEK, else use JDEK to decrypt.
+ *            - KEY_CLEAR   = key is cleartext, no decryption needed
+ *            - KEY_COVERED = key is ciphertext, decrypt.
+ *
+ * @imm     = Key can either be referenced, or loaded into the descriptor
+ *            immediately following the command for improved performance.
+ *            - ITEM_REFERENCE = a pointer follows the command.
+ *            - ITEM_INLINE    = key data follows the command, padded out
+ *                                to a descriptor word boundary.
+ *
+ * @purpose = Sends the key to the class 1 or 2 CHA as selected by an
+ *            OPERATION command. If dest is KEYDST_PK_E or KEYDST_AF_SBOX,
+ *            then this must be ITEM_CLASS1.
+ **/
 u_int32_t *cmd_insert_key(u_int32_t *descwd, u_int8_t *key, u_int32_t keylen,
 			  enum ref_type sgref, enum key_dest dest,
 			  enum key_cover cover, enum item_inline imm,
@@ -155,6 +282,125 @@ u_int32_t *cmd_insert_key(u_int32_t *descwd, u_int8_t *key, u_int32_t keylen,
 	return nextwd;
 }
 
+/**
+ * cmd_insert_seq_key()
+ * Insert a sequence key command into a descriptor
+ *
+ * Returns: If successful, returns a pointer to the target word
+ * incremented past the newly-inserted command (including item pointer
+ * or inlined data). Effectively, this becomes a pointer to the next
+ * word to receive a new command in this descriptor. If error, returns 0
+ *
+ * @descwd  = pointer to target descriptor word to hold this command
+ *
+ * @keylen  = pointer to key size, expressed in bits.
+ *
+ * @sgref   = pointer is actual data, or a scatter-gather list
+ *            representing the key:
+ *            - PTR_DIRECT = points to data
+ *            - PTR_SGLIST = points to CAAM-specific scatter gather
+ *              table. Cannot use if imm = ITEM_INLINE.
+ *
+ * @dest    = target destination in CAAM to receive the key. This may be:
+ *            - KEYDST_KEYREG   = Key register in the CHA selected by an
+ *                                OPERATION command.
+ *            - KEYDST_PK_E     = The 'e' register in the public key block
+ *            - KEYDST_AF_SBOX  = Direct SBOX load if ARC4 is selected
+ *            - KEYDST_MD_SPLIT = Message digest IPAD/OPAD direct load.
+ *
+ * @cover   = Key was encrypted, and must be decrypted during the load.
+ *            If trusted descriptor, use TDEK, else use JDEK to decrypt.
+ *            - KEY_CLEAR   = key is cleartext, no decryption needed
+ *            - KEY_COVERED = key is ciphertext, decrypt.
+ *
+ * @purpose = Sends the key to the class 1 or 2 CHA as selected by an
+ *            OPERATION command. If dest is KEYDST_PK_E or KEYDST_AF_SBOX,
+ *            then this must be ITEM_CLASS1.
+ **/
+u_int32_t *cmd_insert_seq_key(u_int32_t *descwd, u_int32_t keylen,
+			      enum ref_type sgref, enum key_dest dest,
+			      enum key_cover cover, enum item_purpose purpose)
+{
+	u_int32_t *nextwd, keysz;
+
+	if (!descwd)
+		return 0;
+
+	/* If PK 'e' or AF SBOX load, can't be class 2 key */
+	if (((dest == KEYDST_PK_E) || (dest == KEYDST_AF_SBOX)) &&
+	    (purpose == ITEM_CLASS2))
+		return 0;
+
+	nextwd = descwd;
+
+	/* Convert size (in bits) to adequate byte length */
+	keysz = ((keylen & KEY_LENGTH_MASK) >> 3);
+	if (keylen & 0x00000007)
+		keysz++;
+
+	/* Build command word */
+	*nextwd = CMD_SEQ_KEY;
+	switch (dest) {
+	case KEYDST_KEYREG:
+		*nextwd |= KEY_DEST_CLASS_REG;
+		break;
+
+	case KEYDST_PK_E:
+		*nextwd |= KEY_DEST_PKHA_E;
+		break;
+
+	case KEYDST_AF_SBOX:
+		*nextwd |= KEY_DEST_AFHA_SBOX;
+		break;
+
+	case KEYDST_MD_SPLIT:
+		*nextwd |= KEY_DEST_MDHA_SPLIT;
+		break;
+	}
+
+	if (cover == KEY_COVERED)
+		*nextwd |= KEY_ENC;
+
+	switch (purpose) {
+	case ITEM_CLASS1:
+		*nextwd |= CLASS_1;
+		break;
+
+	case ITEM_CLASS2:
+		*nextwd |= CLASS_2;
+		break;
+
+	default:
+		return 0;
+	};
+	if (sgref == PTR_SGLIST)
+		*nextwd |= KEY_SGF;
+
+	*nextwd++ |= keysz;
+
+	return nextwd;
+}
+
+/**
+ * cmd_insert_proto_op_ipsec()
+ * Insert an IPSec protocol operation command into a descriptor
+ *
+ * Returns: Pointer to next incremental descriptor word past the command
+ * just constructed. If an error occurred, returns 0;
+ *
+ * @descwd    = pointer to target descriptor word intended to hold
+ *              this command. For an OPERATION command, this is normally
+ *              the final word of a single descriptor.
+ *
+ * @cipheralg = blockcipher selection for this protocol descriptor.
+ *              This should be one of CIPHER_TYPE_IPSEC_.
+ *
+ * @authalg   = authentication selection for this protocol descriptor.
+ *              This should be one of AUTH_TYPE_IPSEC_.
+ *
+ * @dir       = Select DIR_ENCAP for encapsulation, or DIR_DECAP for
+ *              decapsulation operations.
+ **/
 u_int32_t *cmd_insert_proto_op_ipsec(u_int32_t *descwd, u_int8_t cipheralg,
 				     u_int8_t authalg, enum protdir dir)
 {
@@ -264,13 +510,169 @@ u_int32_t *cmd_insert_proto_op_ipsec(u_int32_t *descwd, u_int8_t cipheralg,
 	return descwd++;
 }
 
+/**
+ * Insert a 802.16 WiMAX protocol OP instruction. These can only be
+ * AES-CCM
+ *
+ * @descwd    = pointer to target descriptor word intended to hold
+ *              this command. For an OPERATION command, this is normally
+ *              the final word of a single descriptor.
+ *
+ * @mode      = nonzero is OFDMa, else assume OFDM
+ *
+ * @dir       = Select DIR_ENCAP for encapsulation, or DIR_DECAP for
+ *              decapsulation operations.
+ **/
+u_int32_t *cmd_insert_proto_op_wimax(u_int32_t *descwd, u_int8_t mode,
+				     enum protdir dir)
+{
+	*descwd = CMD_OPERATION | OP_PCLID_WIMAX |
+		  (mode ? OP_PCL_WIMAX_OFDMA : OP_PCL_WIMAX_OFDM);
+
+	return descwd++;
+}
+
+/**
+ * Insert a 802.11 WiFi protocol OP instruction
+ *
+ * @descwd    = pointer to target descriptor word intended to hold
+ *              this command. For an OPERATION command, this is normally
+ *              the final word of a single descriptor.
+ *
+ * @dir       = Select DIR_ENCAP for encapsulation, or DIR_DECAP for
+ *              decapsulation operations.
+ **/
+u_int32_t *cmd_insert_proto_op_wifi(u_int32_t *descwd, enum protdir dir)
+{
+	*descwd = CMD_OPERATION | OP_PCLID_WIFI | OP_PCL_WIFI;
+
+	return descwd++;
+}
+
+/**
+ * Insert a MacSec protocol OP instruction
+ *
+ * @descwd    = pointer to target descriptor word intended to hold
+ *              this command. For an OPERATION command, this is normally
+ *              the final word of a single descriptor.
+ *
+ * @dir       = Select DIR_ENCAP for encapsulation, or DIR_DECAP for
+ *              decapsulation operations.
+ **/
+u_int32_t *cmd_insert_proto_op_macsec(u_int32_t *descwd, enum protdir dir)
+{
+	*descwd = CMD_OPERATION | OP_PCLID_MACSEC | OP_PCL_MACSEC;
+
+	return descwd++;
+}
+
+/**
+ * Insert a unidirectional protocol OP instruction
+ *
+ * cmd_insert_proto_op_unidir()
+ *
+ * @descwd    = pointer to target descriptor word intended to hold
+ *              this command. For an OPERATION command, this is normally
+ *              the final word of a single descriptor.
+ *
+ * @protid    = Select any PROTID field for a unidirectional protocol
+ *              from OP_PCLID_
+ *
+ * #protinfo  = Select constant or bits to accompany protid
+ **/
+u_int32_t *cmd_insert_proto_op_unidir(u_int32_t *descwd, u_int32_t protid,
+				      u_int32_t protinfo)
+{
+	*descwd = CMD_OPERATION | OP_TYPE_UNI_PROTOCOL | protid | protinfo;
+
+	return descwd++;
+}
+
+/**
+ * cmd_insert_alg_op()
+ * Insert a simple algorithm operation command into a descriptor
+ *
+ * Returns: Pointer to next incremental descriptor word past the command
+ * just constructed. If an error occurred, returns 0;
+ *
+ * @descwd    = pointer to target descriptor word intended to hold
+ *              this command.
+ *
+ * @optype = use as class 1 or 2 with OP_TYPE_CLASSx_ALG
+ *
+ * @algtype = cipher selection, should be one of ALG_TYPE_
+ *
+ * @algmode = mode selection, should be one of ALG_MODE_. Some
+ *            combinations are ORable depending on application.
+ *
+ * @mdstate = if a message digest is being processed, determines
+ *            the processing state. Can be MDSTATE_UPDATE, MDSTATE_INIT,
+ *            MDSTATE_FINAL, or MDSTATE_COMPLETE.
+ *
+ * @icv = if a message digest, or a cipher with an inclusive authentication
+ *        function, then ICV_CHECK_ON selects an inline signature
+ *        comparison on the computed result.
+ *
+ * @dir       = Select DIR_ENCRYPT or DIR_DECRYPT
+ **/
+u_int32_t *cmd_insert_alg_op(u_int32_t *descwd, u_int32_t optype,
+			     u_int32_t algtype, u_int32_t algmode,
+			     enum mdstatesel mdstate, enum icvsel icv,
+			     enum algdir dir)
+{
+	*descwd = CMD_OPERATION | optype | algtype | algmode |
+		mdstate << OP_ALG_AS_SHIFT |
+		icv << OP_ALG_ICV_SHIFT |
+		(dir ? OP_ALG_DECRYPT : OP_ALG_ENCRYPT);
+
+	return ++descwd;
+}
+
+/**
+ * cmd_insert_pkha_op()
+ * Insert a PKHA-algorithm operation command into a descriptor
+ *
+ * Returns: Pointer to next incremental descriptor word past the command
+ * just constructed. If an error occurred, returns 0;
+ *
+ * @descwd    = pointer to target descriptor word intended to hold
+ *              this command.
+ *
+ * @pkmode = mode selection, OR of OP_ALG_PKMODE_ from one of 3 sets
+ * (clear mem, mod arithmetic, copy mem)
+ **/
+u_int32_t *cmd_insert_pkha_op(u_int32_t *descwd, u_int32_t pkmode)
+{
+	*descwd = CMD_OPERATION | OP_TYPE_CLASS1_ALG | OP_ALG_PK | pkmode;
+
+	return ++descwd;
+}
+
 /*
  * FIXME: the following two functions are functionally identical
  * 	  and need refactoring, including macro definitions - e.g,
  * 	  the SGF bit doesn't change among commands.
  */
-int *cmd_insert_seq_in_ptr(u_int32_t *descwd, u_int32_t *ptr, u_int32_t len,
-			   enum ref_type sgref)
+/**
+ * cmd_insert_seq_in_ptr()
+ * Insert an SEQ IN PTR command into a descriptor
+ *
+ * Returns: Pointer to next incremental descriptor word past the command
+ * just constructed. If an error occurred, returns 0;
+ *
+ * @descwd    = pointer to target descriptor word intended to hold
+ *              this command. For an OPERATION command, this is normally
+ *              the final word of a single descriptor.
+ * @ptr       = bus address pointing to the input data buffer
+ * @len       = input length
+ * @sgref     = pointer is actual data, or a scatter-gather list
+ *              representing the key:
+ *              - PTR_DIRECT = points to data
+ *              - PTR_SGLIST = points to CAAM-specific scatter gather
+ *                table.
+ **/
+u_int32_t *cmd_insert_seq_in_ptr(u_int32_t *descwd, void *ptr, u_int32_t len,
+				 enum ref_type sgref)
 {
 	*descwd = CMD_SEQ_IN_PTR | ((sgref == PTR_SGLIST) ? SQIN_SGF : 0) | len;
 
@@ -285,8 +687,26 @@ int *cmd_insert_seq_in_ptr(u_int32_t *descwd, u_int32_t *ptr, u_int32_t len,
 	return descwd + 2;
 }
 
-int *cmd_insert_seq_out_ptr(u_int32_t *descwd, u_int32_t *ptr, u_int32_t len,
-			    enum ref_type sgref)
+/**
+ * cmd_insert_seq_out_ptr()
+ * Insert an SEQ OUT PTR command into a descriptor
+ *
+ * Returns: Pointer to next incremental descriptor word past the command
+ * just constructed. If an error occurred, returns 0;
+ *
+ * @descwd    = pointer to target descriptor word intended to hold
+ *              this command. For an OPERATION command, this is normally
+ *              the final word of a single descriptor.
+ * @ptr       = bus address pointing to the output data buffer
+ * @len       = output length
+ * @sgref     = pointer is actual data, or a scatter-gather list
+ *              representing the key:
+ *              - PTR_DIRECT = points to data
+ *              - PTR_SGLIST = points to CAAM-specific scatter gather
+ *                table.
+ **/
+u_int32_t *cmd_insert_seq_out_ptr(u_int32_t *descwd, void *ptr, u_int32_t len,
+				  enum ref_type sgref)
 {
 	*descwd = CMD_SEQ_OUT_PTR | ((sgref == PTR_SGLIST) ? SQOUT_SGF : 0) |
 		  len;
@@ -302,9 +722,145 @@ int *cmd_insert_seq_out_ptr(u_int32_t *descwd, u_int32_t *ptr, u_int32_t len,
 	return descwd + 2;
 }
 
-int *cmd_insert_seq_load(u_int32_t *descwd, unsigned int class_access,
-			 int variable_len_flag, unsigned char dest,
-			 unsigned char offset, unsigned char len)
+/**
+ * cmd_insert_load()
+ * Insert an LOAD command into a descriptor
+ *
+ * Returns: Pointer to next incremental descriptor word past the command
+ * just constructed. If an error occurred, returns 0;
+ *
+ * @descwd       = pointer to target descriptor word intended to hold
+ *                 this command. For an OPERATION command, this is normally
+ *                 the final word of a single descriptor.
+ *
+ * @data         = pointer to data to be loaded
+ *
+ * @class_access = LDST_CLASS_IND_CCB = access class-independent objects in CCB
+ *               = LDST_CLASS_1_CCB   = access class 1 objects in CCB
+ *               = LDST_CLASS_2_CCB   = access class 2 objects in CCB
+ *               = LDST_CLASS_DECO    = access DECO objects
+ *
+ * @sgflag	 = reference is a scatter/gather list if LDST_SGF
+ *
+ * @dest         = destination
+ *
+ * @offset       = the start point for writing in the destination
+ *
+ * @len          = length of data in bytes
+ *
+ * @imm          = destination data is to be inlined into descriptor itself
+ **/
+u_int32_t *cmd_insert_load(u_int32_t *descwd, void *data,
+			   u_int32_t class_access, u_int32_t sgflag,
+			   u_int32_t dest, u_int8_t offset,
+			   u_int8_t len, enum item_inline imm)
+{
+	int words;
+	u_int32_t *nextin;
+
+	*descwd = CMD_LOAD | (class_access & CLASS_MASK) | sgflag | dest |
+		  (offset << LDST_OFFSET_SHIFT) | len |
+		  ((imm & LDST_IMM_MASK) << LDST_IMM_SHIFT);
+
+	descwd++;
+
+	if (imm == ITEM_INLINE) {
+		words = len >> 2;
+		nextin = (u_int32_t *)data;
+		while (words) {
+			*descwd++ = *nextin++;
+			words--;
+		}
+	} else
+		*descwd++ = (u_int32_t)data;
+
+	return descwd;
+}
+
+/**
+ * cmd_insert_fifo_load()
+ * Insert a FIFO_LOAD command into a descriptor
+ *
+ * Returns: Pointer to next incremental descriptor word past the command
+ * just constructed. If an error occurred, returns 0;
+ *
+ * @descwd = pointer to target descriptor word intended to hold
+ *           this command.
+ *
+ * @data   = pointer to data to be loaded
+ *
+ * @len    = length of data in bits (NOT bytes)
+ *
+ * @class  = LDST_CLASS_IND_CCB = access class-independent objects in CCB
+ *         = LDST_CLASS_1_CCB   = access class 1 objects in CCB
+ *         = LDST_CLASS_2_CCB   = access class 2 objects in CCB
+ *         = LDST_CLASS_DECO    = access DECO objects
+ *
+ * @sgflag = reference is a scatter/gather list if FIFOLDST_SGF
+ *
+ * @imm    = destination data is to be inlined into descriptor itself
+ *           if FIFOLDST_IMM
+ *
+ * @ext    = use extended length field following the pointer if
+ *           FIFOLDST_EXT
+ *
+ * @type   = FIFO input type, an OR combination of FIFOLD_TYPE_
+ *           type and last/flush bits
+ **/
+u_int32_t *cmd_insert_fifo_load(u_int32_t *descwd, void *data, u_int32_t len,
+				u_int32_t class_access, u_int32_t sgflag,
+				u_int32_t imm, u_int32_t ext, u_int32_t type)
+{
+	int words;
+	u_int32_t *nextin;
+
+	*descwd = CMD_FIFO_LOAD | (class_access & CLASS_MASK) | sgflag |
+		  imm | ext | type;
+
+	if (!ext)
+		*descwd |= (len & FIFOLDST_LEN_MASK);
+
+	descwd++;
+
+	if (imm == FIFOLD_IMM) {
+		words = len >> 2;
+		nextin = (u_int32_t *)data;
+		while (words) {
+			*descwd++ = *nextin++;
+			words--;
+		}
+	} else
+		*descwd++ = (u_int32_t)data;
+
+	if (ext)
+		*descwd++ = len;
+
+	return descwd;
+}
+
+/**
+ * cmd_insert_seq_load()
+ * Insert an SEQ LOAD command into a descriptor
+ *
+ * Returns: Pointer to next incremental descriptor word past the command
+ * just constructed. If an error occurred, returns 0;
+ *
+ * @descwd       = pointer to target descriptor word intended to hold
+ *                 this command. For an OPERATION command, this is normally
+ *                 the final word of a single descriptor.
+ * @class_access = LDST_CLASS_IND_CCB = access class-independent objects in CCB
+ *               = LDST_CLASS_1_CCB   = access class 1 objects in CCB
+ *               = LDST_CLASS_2_CCB   = access class 2 objects in CCB
+ *               = LDST_CLASS_DECO    = access DECO objects
+ * @variable_len_flag = use the variable input sequence length
+ * @dest         = destination
+ * @offset       = the start point for writing in the destination
+ * @len          = length of data in bytes
+ *
+ **/
+u_int32_t *cmd_insert_seq_load(u_int32_t *descwd, u_int32_t class_access,
+			       u_int32_t variable_len_flag, u_int32_t dest,
+			       u_int8_t offset, u_int8_t len)
 {
 	*descwd = CMD_SEQ_LOAD | (class_access & CLASS_MASK) |
 		  (variable_len_flag ? LDST_SGF : 0) |
@@ -315,21 +871,349 @@ int *cmd_insert_seq_load(u_int32_t *descwd, unsigned int class_access,
 	return descwd + 1;
 }
 
-int *cmd_insert_seq_fifo_load(u_int32_t *descwd, unsigned int class_access,
-			      int variable_len_flag, unsigned char data_type,
-			      u_int32_t len, u_int32_t *ptr)
+/**
+ * cmd_insert_seq_fifo_load()
+ * Insert an SEQ FIFO LOAD command into a descriptor
+ *
+ * Returns: Pointer to next incremental descriptor word past the command
+ * just constructed. If an error occurred, returns 0;
+ *
+ * @descwd       = pointer to target descriptor word intended to hold
+ *                 this command. For an OPERATION command, this is normally
+ *                 the final word of a single descriptor.
+ * @class_access = LDST_CLASS_IND_CCB = access class-independent objects in CCB
+ *               = LDST_CLASS_1_CCB   = access class 1 objects in CCB
+ *               = LDST_CLASS_2_CCB   = access class 2 objects in CCB
+ *               = LDST_CLASS_DECO    = access DECO objects
+ * @variable_len_flag = use the variable input sequence length
+ * @data_type    = FIFO input data type (FIFOLD_TYPE_* in caam_desc.h)
+ * @len          = input length
+ **/
+u_int32_t *cmd_insert_seq_fifo_load(u_int32_t *descwd, u_int32_t class_access,
+				    u_int32_t variable_len_flag,
+				    u_int32_t data_type, u_int32_t len)
 {
 	*descwd = CMD_SEQ_FIFO_LOAD | (class_access & CLASS_MASK) |
 		  (variable_len_flag ? FIFOLDST_SGF : 0) |
 		  data_type | ((len & LDST_LEN_MASK) << LDST_LEN_SHIFT);
 
-	*(descwd + 1) = (u_int32_t)ptr;
+	if (len > 0xffff) {
+		*descwd |= FIFOLDST_EXT;
+		*(descwd + 1) = len;
+		return descwd + 2;
+	}
+
+	return descwd + 1;
+}
+
+/**
+ * cmd_insert_store()
+ * Insert a STORE command into a descriptor
+ *
+ * Returns: Pointer to next incremental descriptor word past the command
+ * just constructed. If an error occurred, returns 0;
+ *
+ * @descwd       = pointer to target descriptor word intended to hold
+ *                 this command. For an OPERATION command, this is normally
+ *                 the final word of a single descriptor.
+ *
+ * @data         = pointer to data to be stored
+ *
+ * @class_access = LDST_CLASS_IND_CCB = access class-independent objects in CCB
+ *               = LDST_CLASS_1_CCB   = access class 1 objects in CCB
+ *               = LDST_CLASS_2_CCB   = access class 2 objects in CCB
+ *               = LDST_CLASS_DECO    = access DECO objects
+ *
+ * @sgflag       = reference is a scatter-gather list if LDST_SGF
+ *
+ * @src          = source
+ *
+ * @offset       = the start point for writing in the destination
+ *
+ * @len          = length of data in bytes
+ *
+ * @imm          = data is to be inlined into descriptor itself
+ **/
+u_int32_t *cmd_insert_store(u_int32_t *descwd, void *data,
+			    u_int32_t class_access, u_int32_t sg_flag,
+			    u_int32_t src, u_int8_t offset,
+			    u_int8_t len, enum item_inline imm)
+{
+	int words;
+	u_int32_t *nextin;
+
+	*descwd = CMD_STORE | class_access | sg_flag | src |
+		  ((offset & LDST_OFFSET_MASK) << LDST_OFFSET_SHIFT) |
+		  ((len & LDST_LEN_MASK) << LDST_LEN_SHIFT) |
+		  ((imm & LDST_IMM_MASK) << LDST_IMM_SHIFT);
+
+	descwd++;
+
+	if (imm == ITEM_INLINE) {
+		words = len >> 2;
+		nextin = (u_int32_t *)data;
+		while (words) {
+			*descwd++ = *nextin++;
+			words--;
+		}
+	} else
+		*descwd++ = (u_int32_t)data;
+
+	return descwd;
+}
+
+/**
+ * cmd_insert_seq_store()
+ * Insert a SEQ STORE command into a descriptor
+ *
+ * Returns: Pointer to next incremental descriptor word past the command
+ * just constructed. If an error occurred, returns 0;
+ *
+ * @descwd       = pointer to target descriptor word intended to hold
+ *                 this command. For an OPERATION command, this is normally
+ *                 the final word of a single descriptor.
+ *
+ * @class_access = LDST_CLASS_IND_CCB = access class-independent objects in CCB
+ *               = LDST_CLASS_1_CCB   = access class 1 objects in CCB
+ *               = LDST_CLASS_2_CCB   = access class 2 objects in CCB
+ *               = LDST_CLASS_DECO    = access DECO objects
+ *
+ * @variable_len_flag = use the variable input sequence length
+ *
+ * @src          = source
+ *
+ * @offset       = the start point for writing in the destination
+ *
+ * @len          = length of data in bytes
+ **/
+u_int32_t *cmd_insert_seq_store(u_int32_t *descwd, u_int32_t class_access,
+				u_int32_t variable_len_flag, u_int32_t src,
+				u_int8_t offset, u_int8_t len)
+{
+	*descwd = CMD_SEQ_STORE | (class_access & CLASS_MASK) |
+		  (variable_len_flag ? LDST_SGF : 0) |
+		  src | ((offset << LDST_OFFSET_SHIFT) & LDST_OFFSET_MASK) |
+		  ((len << LDST_LEN_SHIFT) & LDST_LEN_MASK);
+
+	return descwd + 1;
+}
+
+/**
+ * cmd_insert_fifo_store()
+ * Insert a FIFO_STORE command into a descriptor
+ *
+ * Returns: Pointer to next incremental descriptor word past the command
+ * just constructed. If an error occurred, returns 0;
+ *
+ * @descwd = pointer to target descriptor word intended to hold
+ *           this command.
+ *
+ * @data   = pointer to data to be loaded
+ *
+ * @len    = length of data in bits (NOT bytes)
+ *
+ * @class  = LDST_CLASS_IND_CCB = access class-independent objects in CCB
+ *         = LDST_CLASS_1_CCB   = access class 1 objects in CCB
+ *         = LDST_CLASS_2_CCB   = access class 2 objects in CCB
+ *         = LDST_CLASS_DECO    = access DECO objects
+ *
+ * @sgflag = reference is a scatter/gather list if FIFOLDST_SGF
+ *
+ * @imm    = destination data is to be inlined into descriptor itself
+ *           if FIFOLDST_IMM
+ *
+ * @ext    = use extended length field following the pointer if
+ *           FIFOLDST_EXT
+ *
+ * @type   = FIFO input type, an OR combination of FIFOLD_TYPE_
+ *           type and last/flush bits
+ **/
+u_int32_t *cmd_insert_fifo_store(u_int32_t *descwd, void *data, u_int32_t len,
+				 u_int32_t class_access, u_int32_t sgflag,
+				 u_int32_t imm, u_int32_t ext, u_int32_t type)
+{
+	int words;
+	u_int32_t *nextin;
+
+	*descwd = CMD_FIFO_LOAD | (class_access & CLASS_MASK) | sgflag |
+		  imm | ext | type;
+
+	if (!ext)
+		*descwd |= (len & FIFOLDST_LEN_MASK);
+
+	descwd++;
+
+	if (imm == FIFOLD_IMM) {
+		words = len >> 2;
+		nextin = (u_int32_t *)data;
+		while (words) {
+			*descwd++ = *nextin++;
+			words--;
+		}
+	} else
+		*descwd++ = (u_int32_t)data;
+
+	if (ext)
+		*descwd++ = len;
+
+	return descwd;
+}
+
+/**
+ * cmd_insert_seq_fifo_store()
+ * Insert a SEQ FIFO STORE command into a descriptor
+ *
+ * Returns: Pointer to next incremental descriptor word past the command
+ * just constructed. If an error occurred, returns 0;
+ *
+ * @descwd       = pointer to target descriptor word intended to hold
+ *                 this command. For an OPERATION command, this is normally
+ *                 the final word of a single descriptor.
+ *
+ * @class_access = LDST_CLASS_IND_CCB = access class-independent objects in CCB
+ *               = LDST_CLASS_1_CCB   = access class 1 objects in CCB
+ *               = LDST_CLASS_2_CCB   = access class 2 objects in CCB
+ *               = LDST_CLASS_DECO    = access DECO objects
+ *
+ * @variable_len_flag = use the variable input sequence length
+ *
+ * @out_type     = FIFO output data type (FIFOST_TYPE_* in caam_desc.h)
+ *
+ * @len          = output length
+ **/
+u_int32_t *cmd_insert_seq_fifo_store(u_int32_t *descwd, u_int32_t class_access,
+				     u_int32_t variable_len_flag,
+				     u_int32_t out_type, u_int32_t len)
+{
+	*descwd = CMD_SEQ_FIFO_STORE | (class_access & CLASS_MASK) |
+		  (variable_len_flag ? FIFOLDST_SGF : 0) |
+		  out_type | ((len & LDST_LEN_MASK) << LDST_LEN_SHIFT);
 
 	if (len > 0xffff) {
 		*descwd |= FIFOLDST_EXT;
-		*(descwd + 2) = len;
-		return descwd + 3;
+		*(descwd + 1) = len;
+		return descwd + 2;
 	}
 
-	return descwd + 2;
+	return descwd + 1;
+}
+
+/**
+ * cmd_insert_jump()
+ * Insert a JUMP command into a descriptor
+ *
+ * Returns: pointer to next incremental descriptor word past the command
+ * just constructed. No error is returned.
+ *
+ * @descwd = pointer to target descriptor word intended to hold this
+ *           command.
+ *
+ * @jtype = type of jump operation to perform, of JUMP_TYPE_
+ *
+ * @test = type of test to perform, one of JUMP_TEST_
+ *
+ * @cond = condition codes to test agaist. OR combination of any of
+ *         JUMP_CC_MATH_ or any of JUMP_CC_MATH_, but not both
+ *
+ * @offset = Relative offset for jump within the descriptor
+ *
+ * @jmpdesc = pointer of descriptor to pass control to, only valid
+ *            if jtype = JUMP_NONLOCAL
+ **/
+u_int32_t *cmd_insert_jump(u_int32_t *descwd, u_int32_t jtype,
+			   u_int32_t test, u_int32_t cond,
+			   u_int8_t offset, u_int32_t *jmpdesc)
+{
+	*descwd++ = CMD_JUMP | jtype | test | cond | offset;
+
+	if (jtype == JUMP_TYPE_NONLOCAL)
+		*descwd++ = (u_int32_t)jmpdesc;
+
+	return descwd;
+}
+
+/**
+ * cmd_insert_math()
+ * Insert a MATH command into a descriptor
+ *
+ * Returns: pointer to next incremental descriptor word past the command
+ * just constructed. No error is returned.
+ *
+ * @descwd = pointer to target descriptor word intended to hold this
+ *           command.
+ *
+ * @func = Function to perform. One of MATH_FUN_
+ *
+ * @src0 = First of two value sources for comparison. One of MATH_SRC0_
+ *
+ * @src1 = Second of two value sources for comparison. One of MATH_SRC1_
+ *
+ * @dest = Destination for the result. One of MATH_DEST_
+ *
+ * @len = Length of the ALU (or immediate value) in bytes.
+ *
+ * @flagupd = if MATH_FLAG_NO_UPDATE, prevents the result from updating
+ *            flags, else use MATH_FLAG_UPDATE
+ *
+ * @stall = if MATH_STALL, cause the instruction to require one extra
+ *          clock cycle, else use MATH_NO_STALL.
+ *
+ * @immediate = if MATH_IMMEDIATE, will insert a 4 byte immediate
+ *              value into the descriptor to use as 1 of the two
+ *              sources, else if not needed, use MATH_NO_IMMEDIATE
+ *
+ * @data = inline data sized per len. If MATH_IMMEDIATE is used,
+ *           must only be a 4-byte value to inline into the descriptor
+ **/
+u_int32_t *cmd_insert_math(u_int32_t *descwd, u_int32_t func,
+			    u_int32_t src0, u_int32_t src1,
+			    u_int32_t dest, u_int32_t len,
+			    u_int32_t flagupd, u_int32_t stall,
+			    u_int32_t immediate, u_int32_t *data)
+ {
+
+	*descwd++ = CMD_MATH | func | src0 | src1 | dest |
+		    (len & MATH_LEN_MASK) | flagupd | stall | immediate;
+
+	if ((immediate) ||
+	   ((src0 & MATH_SRC0_MASK) == MATH_SRC0_IMM) ||
+	   ((src1 & MATH_SRC1_MASK) == MATH_SRC1_IMM))
+		*descwd++ = *data;
+
+
+	return descwd;
+ }
+
+/**
+ * cmd_insert_move()
+ * Insert a MOVE command into a descriptor
+ *
+ * Returns: pointer to next incremental descriptor word past the
+ * command just constructed. No error is returned.
+ *
+ * @descwd = pointer to target descriptor word intended to hold this
+ *           command.
+ *
+ * @waitcomp = if MOVE_WAITCOMPLETE specified, stall execution until
+ *             the MOVE completes. This is only valid if it is using
+ *             the DMA CCB, else use MOVE_NOWAIT.
+ *
+ * @src = defines the source for the move. Must be one of MOVE_SRC_
+ *
+ * @dst = defined the destination for the move. Must be one of
+ *        MOVE_INTSRC_DEST_
+ *
+ * @offset = specifies the offset into the source or destination
+ *           to use.
+ *
+ * @length = specifies the length of the data to move
+ **/
+u_int32_t *cmd_insert_move(u_int32_t *descwd, u_int32_t waitcomp,
+			   u_int32_t src, u_int32_t dst, u_int8_t offset,
+			   u_int8_t length)
+{
+	*descwd++ = CMD_MOVE | waitcomp | src | dst |
+	(offset << MOVE_OFFSET_SHIFT) | length;
+
+	return descwd;
 }
diff --git a/drivers/crypto/caam/dcl/dcl.h b/drivers/crypto/caam/dcl/dcl.h
index 5183d2a..7dbdbdc 100644
--- a/drivers/crypto/caam/dcl/dcl.h
+++ b/drivers/crypto/caam/dcl/dcl.h
@@ -99,13 +99,110 @@ enum protdir {
 	DIR_DECAP
 };
 
+enum algdir {
+	DIR_ENCRYPT,
+	DIR_DECRYPT
+};
+
+enum mdstatesel {
+	MDSTATE_UPDATE,
+	MDSTATE_INIT,
+	MDSTATE_FINAL,
+	MDSTATE_COMPLETE	/* Full init+final in single operation */
+};
+
+enum icvsel {
+	ICV_CHECK_OFF,
+	ICV_CHECK_ON
+};
+
 enum mktrust {
 	DESC_SIGN,
 	DESC_STD
 };
 
+#define MOVE_NOWAIT       0
+#define MOVE_WAITCOMPLETE MOVE_WAITCOMP
+
+/*
+ * LOAD/STORE constants
+ */
+
+
+
+
 /*
- * Type selectors for cipher types in IPSec
+ * JUMP condition codes
+ * First set is standard condition codes, second is for sharing control
+ * Any combination within a set is legal, cross-set combinations are not
+ */
+
+/* Standard conditions */
+#define JUMP_CC_MATH_NV		(JUMP_COND_MATH_NV)
+#define JUMP_CC_MATH_C		(JUMP_COND_MATH_C)
+#define JUMP_CC_MATH_Z		(JUMP_COND_MATH_Z)
+#define JUMP_CC_MATH_N		(JUMP_COND_MATH_N)
+#define JUMP_CC_PKHA_PRIME	(JUMP_COND_PK_PRIME)
+#define JUMP_CC_PKHA_GCD_1	(JUMP_COND_PK_GCD_1)
+#define JUMP_CC_PKHA_ZERO	(JUMP_COND_PK_0)
+
+/* Sharing conditions */
+#define JUMP_CC_SHARE_NCP	(JUMP_COND_NCP | JUMP_JSL)
+#define JUMP_CC_SHARE_NOP	(JUMP_COND_NOP | JUMP_JSL)
+#define JUMP_CC_SHARE_NIFP	(JUMP_COND_NIFP | JUMP_JSL)
+#define JUMP_CC_SHARE_NIP	(JUMP_COND_NIP | JUMP_JSL)
+#define JUMP_CC_SHARE_CALM	(JUMP_COND_CALM | JUMP_JSL)
+#define JUMP_CC_SHARE_SELF	(JUMP_COND_SELF | JUMP_JSL)
+#define JUMP_CC_SHARE_SHRD	(JUMP_COND_SHRD | JUMP_JSL)
+#define JUMP_CC_SHARE_JQP	(JUMP_COND_JQP | JUMP_JSL)
+
+/*
+ * cmd_insert_move() destination combinations
+ */
+#define MOVE_INTSRC_DEST_CLASS1_CTX	(MOVE_DEST_CLASS1CTX)
+#define MOVE_INTSRC_DEST_CLASS2_CTX	(MOVE_DEST_CLASS2CTX)
+#define MOVE_INTSRC_DEST_OUT_FIFO	(MOVE_DEST_OUTFIFO)
+#define MOVE_INTSRC_DEST_DESCBUF	(MOVE_DEST_DESCBUF)
+#define MOVE_INTSRC_DEST_DESCBUF_OFFSET16 \
+	(MOVE_DEST_DESCBUF | (1 << MOVE_AUX_SHIFT))
+#define MOVE_INTSRC_DEST_DESCBUF_OFFSET32 \
+	(MOVE_DEST_DESCBUF | (2 << MOVE_AUX_SHIFT))
+#define MOVE_INTSRC_DEST_DESCBUF_OFFSET48 \
+	(MOVE_DEST_DESCBUF | (3 << MOVE_AUX_SHIFT))
+#define MOVE_INTSRC_DEST_MATH0		(MOVE_DEST_MATH0)
+#define MOVE_INTSRC_DEST_MATH1		(MOVE_DEST_MATH1)
+#define MOVE_INTSRC_DEST_MATH2		(MOVE_DEST_MATH2)
+#define MOVE_INTSRC_DEST_MATH3		(MOVE_DEST_MATH3)
+#define MOVE_INTSRC_DEST_CLASS1_IN_FIFO	(MOVE_DEST_CLASS1INFIFO)
+#define MOVE_INTSRC_DEST_CLASS1_IN_FIFO_FLUSH \
+	(MOVE_DEST_CLASS1INFIFO | (2 << MOVE_AUX_SHIFT))
+#define MOVE_INTSRC_DEST_CLASS1_IN_FIFO_LAST \
+	(MOVE_DEST_CLASS1INFIFO | (1 << MOVE_AUX_SHIFT))
+#define MOVE_INTSRC_DEST_CLASS1_IN_FIFO_FLUSHLAST \
+	(MOVE_DEST_CLASS1INFIFO | (3 << MOVE_AUX_SHIFT))
+#define MOVE_INTSRC_DEST_CLASS2_IN_FIFO	(MOVE_DEST_CLASS2INFIFO)
+#define MOVE_INTSRC_DEST_CLASS2_IN_FIFO_LAST \
+	(MOVE_DEST_CLASS2INFIFO | (1 << MOVE_AUX_SHIFT))
+#define MOVE_INTSRC_DEST_PKHA_A		(MOVE_DEST_PK_A)
+#define MOVE_INTSRC_DEST_CLASS1_KEY	(MOVE_DEST_CLASS1KEY)
+#define MOVE_INTSRC_DEST_CLASS2_KEY	(MOVE_DEST_CLASS2KEY)
+
+
+/*
+ * Extra option bits for MATH instructions
+ */
+
+#define MATH_FLAG_UPDATE      0
+#define MATH_FLAG_NO_UPDATE   MATH_NFU
+
+#define MATH_STALL            MATH_STL
+#define MATH_NO_STALL         0
+
+#define MATH_IMMEDIATE        MATH_IFB
+#define MATH_NO_IMMEDIATE     0
+
+/*
+ * Type selectors for cipher types in IPSec protocol OP instructions
  */
 #define CIPHER_TYPE_IPSEC_DESCBC              2
 #define CIPHER_TYPE_IPSEC_3DESCBC             3
@@ -119,7 +216,7 @@ enum mktrust {
 #define CIPHER_TYPE_IPSEC_AES_GCM_ICV16       20
 
 /*
- * Type selectors for authentication in IPSec
+ * Type selectors for authentication in IPSec protocol OP instructions
  */
 
 #define AUTH_TYPE_IPSEC_MD5HMAC_96            1
@@ -131,293 +228,143 @@ enum mktrust {
 #define AUTH_TYPE_IPSEC_SHA2HMAC_512          14
 
 /*
- * Insert a shared descriptor header into a descriptor
- *
- * Inputs:
- * + descwd   = pointer to target descriptor word to hold this command.
- *              Note that this should always be the first word of a
- *              descriptor.
- *
- * + startidx = index to continuation of descriptor data, normally the
- *              first descriptor word past a PDB. This tells DECO what
- *              to skip over.
- *
- * + desclen  = length of descriptor in words, including header.
- *
- * + ctxsave  = Saved or erases context when a descriptor is self-shared
- *              - CTX_SAVE  = context saved between iterations
- *              - CTX_ERASE = context is erased
- *
- * + share    = Share state of this descriptor:
- *              - SHR_NEVER  = Never share. Fetching is repeated for each
- *                             processing pass.
- *              - SHR_WAIT   = Share once processing starts.
- *              - SHR_SERIAL = Share once completed.
- *              - SHR_ALWAYS = Always share (except keys)
- *
- * Returns:
- * + Pointer to next incremental descriptor word past the header just
- *   constructed. If an error occurred, returns 0.
- *
- * Note: Headers should normally be constructed as the final operation
- *       in the descriptor construction, because the start index and
- *       overall descriptor length will likely not be known until
- *       construction is complete. For this reason, there is little use
- *       to the "incremental pointer" convention. The exception is probably
- *       in the construction of simple descriptors where the size is easily
- *       known early in the construction process.
+ * Type selectors for bulk algorithm OP instructions
  */
-u_int32_t *cmd_insert_shared_hdr(u_int32_t    *descwd,
-				 u_int8_t      startidx,
-				 u_int8_t      desclen,
-				 enum ctxsave  ctxsave,
-				 enum shrst    share);
+#define ALG_OP_CLASS1		1
+#define ALG_OP_CLASS2		2
+
 
 /*
- * Insert a standard descriptor header into a descriptor
- *
- * Inputs:
- * + descwd   = pointer to target descriptor word to hold this command.
- *              Note that this should always be the first word of a
- *              descriptor.
- *
- * + startidx = index to continuation of descriptor data, or if
- *              sharenext = SHRNXT_SHARED, then specifies the size
- *              of the associated shared descriptor referenced in
- *              the following instruction.
- *
- * + desclen  = length of descriptor in words, including header
- *
- * + share    = Share state for this descriptor:
- *              - SHR_NEVER  = Never share. Fetching is repeated for each
- *                             processing pass.
- *              - SHR_WAIT   = Share once processing starts.
- *              - SHR_SERIAL = Share once completed.
- *              - SHR_ALWAYS = Always share (except keys)
- *              - SHR_DEFER  = Use the referenced sharedesc to determine
- *                             sharing intent
- *
- * + sharenext = Control state of shared descriptor processing
- *              - SHRNXT_SHARED = This is a job descriptor consisting
- *                                of a header and a pointer to a shared
- *                                descriptor only.
- *              - SHRNXT_LENGTH = This is a detailed job descriptor, thus
- *                                desclen refers to the full length of this
- *                                descriptor.
- *
- * + reverse   = Reverse execution order between this job descriptor, and
- *               an associated shared descriptor:
- *              - ORDER_REVERSE - execute this descriptor before the shared
- *                                descriptor referenced.
- *              - ORDER_FORWARD - execute the shared descriptor, then this
- *                                descriptor.
- *
- * + mktrusted = DESC_SIGN - sign this descriptor prior to execuition
- *               DESC_STD  - leave descriptor non-trusted
- *
+ * Command Generator Prototypes
  */
+u_int32_t *cmd_insert_shared_hdr(u_int32_t *descwd, u_int8_t startidx,
+				 u_int8_t desclen, enum ctxsave ctxsave,
+				 enum shrst share);
+
 u_int32_t *cmd_insert_hdr(u_int32_t *descwd, u_int8_t startidx,
 			  u_int8_t desclen, enum shrst share,
 			  enum shrnext sharenext, enum execorder reverse,
 			  enum mktrust mktrusted);
 
-/*
- * Insert a key command into a descriptor
- *
- * Inputs:
- * + descwd  = pointer to target descriptor word to hold this command
- *
- * + key     = pointer to key data as an array of bytes.
- *
- * + keylen  = pointer to key size, expressed in bits.
- *
- * + sgref   = pointer is actual data, or a scatter-gather list
- *             representing the key:
- *             - PTR_DIRECT = points to data
- *             - PTR_SGLIST = points to CAAM-specific scatter gather
- *               table. Cannot use if imm = ITEM_INLINE.
- *
- * + dest    = target destination in CAAM to receive the key. This may be:
- *             - KEYDST_KEYREG   = Key register in the CHA selected by an
- *                                 OPERATION command.
- *             - KEYDST_PK_E     = The 'e' register in the public key block
- *             - KEYDST_AF_SBOX  = Direct SBOX load if ARC4 is selected
- *             - KEYDST_MD_SPLIT = Message digest IPAD/OPAD direct load.
- *
- * + cover   = Key was encrypted, and must be decrypted during the load.
- *             If trusted descriptor, use TDEK, else use JDEK to decrypt.
- *             - KEY_CLEAR   = key is cleartext, no decryption needed
- *             - KEY_COVERED = key is ciphertext, decrypt.
- *
- * + imm     = Key can either be referenced, or loaded into the descriptor
- *             immediately following the command for improved performance.
- *             - ITEM_REFERENCE = a pointer follows the command.
- *             - ITEM_INLINE    = key data follows the command, padded out
- *                                to a descriptor word boundary.
- *
- * + purpose = Sends the key to the class 1 or 2 CHA as selected by an
- *             OPERATION command. If dest is KEYDST_PK_E or KEYDST_AF_SBOX,
- *             then this must be ITEM_CLASS1.
- *
- * Returns:
- * + If successful, returns a pointer to the target word incremented
- *   past the newly-inserted command (including item pointer or inlined
- *   data). Effectively, this becomes a pointer to the next word to receive
- *   a new command in this descriptor.
- *
- * + If error, returns 0
- */
-u_int32_t *cmd_insert_key(u_int32_t        *descwd,
-			  u_int8_t         *key,
-			  u_int32_t         keylen,
-			  enum ref_type     sgref,
-			  enum key_dest     dest,
-			  enum key_cover    cover,
-			  enum item_inline  imm,
+u_int32_t *cmd_insert_key(u_int32_t *descwd, u_int8_t *key, u_int32_t keylen,
+			  enum ref_type sgref, enum key_dest dest,
+			  enum key_cover cover, enum item_inline imm,
 			  enum item_purpose purpose);
 
-/*
- * Insert an IPSec protocol operation command into a descriptor
- *
- * Inputs:
- * + descwd    = pointer to target descriptor word intended to hold
- *               this command. For an OPERATION command, this is normally
- *               the final word of a single descriptor.
- *
- * + cipheralg = blockcipher selection for this protocol descriptor.
- *               This should be one of CIPHER_TYPE_IPSEC_.
- *
- * + authalg   = authentication selection for this protocol descriptor.
- *               This should be one of AUTH_TYPE_IPSEC_.
- *
- * + dir       = Select DIR_ENCAP for encapsulation, or DIR_DECAP for
- *               decapsulation operations.
- *
- * Returns:
- * + Pointer to next incremental descriptor word past the command
- *   just constructed. If an error occurred, returns 0;
- */
-u_int32_t *cmd_insert_proto_op_ipsec(u_int32_t   *descwd,
-				     u_int8_t     cipheralg,
-				     u_int8_t     authalg,
+u_int32_t *cmd_insert_seq_key(u_int32_t *descwd, u_int32_t keylen,
+			      enum ref_type sgref, enum key_dest dest,
+			      enum key_cover cover, enum item_purpose purpose);
+
+u_int32_t *cmd_insert_proto_op_ipsec(u_int32_t *descwd, u_int8_t cipheralg,
+				     u_int8_t authalg, enum protdir dir);
+
+u_int32_t *cmd_insert_proto_op_wimax(u_int32_t *descwd, u_int8_t mode,
 				     enum protdir dir);
 
-/*
- * Insert an SEQ IN PTR command into a descriptor
- *
- * Inputs:
- * + descwd    = pointer to target descriptor word intended to hold
- *               this command. For an OPERATION command, this is normally
- *               the final word of a single descriptor.
- * + ptr       = bus address pointing to the input data buffer
- * + len       = input length
- * + sgref     = pointer is actual data, or a scatter-gather list
- *               representing the key:
- *               - PTR_DIRECT = points to data
- *               - PTR_SGLIST = points to CAAM-specific scatter gather
- *                 table.
- *
- * Returns:
- * + Pointer to next incremental descriptor word past the command
- *   just constructed. If an error occurred, returns 0;
- */
-int *cmd_insert_seq_in_ptr(u_int32_t *descwd, u_int32_t *ptr, u_int32_t len,
-			   enum ref_type sgref);
+u_int32_t *cmd_insert_proto_op_wifi(u_int32_t *descwd, enum protdir dir);
 
-/*
- * Insert an SEQ OUT PTR command into a descriptor
- *
- * Inputs:
- * + descwd    = pointer to target descriptor word intended to hold
- *               this command. For an OPERATION command, this is normally
- *               the final word of a single descriptor.
- * + ptr       = bus address pointing to the output data buffer
- * + len       = output length
- * + sgref     = pointer is actual data, or a scatter-gather list
- *               representing the key:
- *               - PTR_DIRECT = points to data
- *               - PTR_SGLIST = points to CAAM-specific scatter gather
- *                 table.
- *
- * Returns:
- * + Pointer to next incremental descriptor word past the command
- *   just constructed. If an error occurred, returns 0;
- */
-int *cmd_insert_seq_out_ptr(u_int32_t *descwd, u_int32_t *ptr, u_int32_t len,
-			    enum ref_type sgref);
+u_int32_t *cmd_insert_proto_op_macsec(u_int32_t *descwd, enum protdir dir);
 
-/*
- * Insert an SEQ LOAD command into a descriptor
- *
- * Inputs:
- * descwd       = pointer to target descriptor word intended to hold
- *                this command. For an OPERATION command, this is normally
- *                the final word of a single descriptor.
- * class_access = LDST_CLASS_IND_CCB = access class-independent objects in CCB
- *              = LDST_CLASS_1_CCB   = access class 1 objects in CCB
- *              = LDST_CLASS_2_CCB   = access class 2 objects in CCB
- *              = LDST_CLASS_DECO    = access DECO objects
- * variable_len_flag = use the variable input sequence length
- * dest         = destination
- * offset       = the start point for writing in the destination
- * len          = length of data in bytes
- *
- * Returns:
- * + Pointer to next incremental descriptor word past the command
- *   just constructed. If an error occurred, returns 0;
- */
-int *cmd_insert_seq_load(u_int32_t *descwd, unsigned int class_access,
-			 int variable_len_flag, unsigned char dest,
-			 unsigned char offset, unsigned char len);
+u_int32_t *cmd_insert_proto_op_unidir(u_int32_t *descwd, u_int32_t protid,
+				      u_int32_t protinfo);
 
-/*
- * Insert an SEQ FIFO LOAD command into a descriptor
- *
- * Inputs:
- * + descwd    = pointer to target descriptor word intended to hold
- *               this command. For an OPERATION command, this is normally
- *               the final word of a single descriptor.
- * class_access = LDST_CLASS_IND_CCB = access class-independent objects in CCB
- *              = LDST_CLASS_1_CCB   = access class 1 objects in CCB
- *              = LDST_CLASS_2_CCB   = access class 2 objects in CCB
- *              = LDST_CLASS_DECO    = access DECO objects
- * variable_len_flag = use the variable input sequence length
- * data_type    = FIFO input data type (FIFOLD_TYPE_* in caam_desc.h)
- * len          = output length
- * ptr          = bus address pointing to the output data buffer
- *
- * Returns:
- * + Pointer to next incremental descriptor word past the command
- *   just constructed. If an error occurred, returns 0;
- */
-int *cmd_insert_seq_fifo_load(u_int32_t *descwd, unsigned int class_access,
-			      int variable_len_flag, unsigned char data_type,
-			      u_int32_t len, u_int32_t *ptr);
+u_int32_t *cmd_insert_alg_op(u_int32_t *descwd, u_int32_t optype,
+			     u_int32_t algtype, u_int32_t algmode,
+			     enum mdstatesel mdstate, enum icvsel icv,
+			     enum algdir dir);
+
+u_int32_t *cmd_insert_pkha_op(u_int32_t *descwd, u_int32_t pkmode);
+
+u_int32_t *cmd_insert_seq_in_ptr(u_int32_t *descwd, void *ptr, u_int32_t len,
+				 enum ref_type sgref);
+
+u_int32_t *cmd_insert_seq_out_ptr(u_int32_t *descwd, void *ptr, u_int32_t len,
+				  enum ref_type sgref);
+
+u_int32_t *cmd_insert_load(u_int32_t *descwd, void *data,
+			   u_int32_t class_access, u_int32_t sgflag,
+			   u_int32_t dest, u_int8_t offset,
+			   u_int8_t len, enum item_inline imm);
+
+u_int32_t *cmd_insert_fifo_load(u_int32_t *descwd, void *data, u_int32_t len,
+				u_int32_t class_access, u_int32_t sgflag,
+				u_int32_t imm, u_int32_t ext, u_int32_t type);
+
+u_int32_t *cmd_insert_seq_load(u_int32_t *descwd, u_int32_t class_access,
+			       u_int32_t variable_len_flag, u_int32_t dest,
+			       u_int8_t offset, u_int8_t len);
+
+u_int32_t *cmd_insert_seq_fifo_load(u_int32_t *descwd, u_int32_t class_access,
+				    u_int32_t variable_len_flag,
+				    u_int32_t data_type, u_int32_t len);
+
+u_int32_t *cmd_insert_store(u_int32_t *descwd, void *data,
+			    u_int32_t class_access, u_int32_t sg_flag,
+			    u_int32_t src, u_int8_t offset,
+			    u_int8_t len, enum item_inline imm);
+
+u_int32_t *cmd_insert_seq_store(u_int32_t *descwd, u_int32_t class_access,
+				u_int32_t variable_len_flag, u_int32_t src,
+				u_int8_t offset, u_int8_t len);
+
+u_int32_t *cmd_insert_fifo_store(u_int32_t *descwd, void *data, u_int32_t len,
+				 u_int32_t class_access, u_int32_t sgflag,
+				 u_int32_t imm, u_int32_t ext, u_int32_t type);
+
+u_int32_t *cmd_insert_seq_fifo_store(u_int32_t *descwd, u_int32_t class_access,
+				     u_int32_t variable_len_flag,
+				     u_int32_t out_type, u_int32_t len);
+
+u_int32_t *cmd_insert_jump(u_int32_t *descwd, u_int32_t jtype,
+			   u_int32_t test, u_int32_t cond,
+			   u_int8_t offset, u_int32_t *jmpdesc);
+
+u_int32_t *cmd_insert_move(u_int32_t *descwd, u_int32_t waitcomp,
+			   u_int32_t src, u_int32_t dst, u_int8_t offset,
+			   u_int8_t length);
+
+u_int32_t *cmd_insert_math(u_int32_t *descwd, u_int32_t func,
+			    u_int32_t src0, u_int32_t src1,
+			    u_int32_t dest, u_int32_t len,
+			    u_int32_t flagupd, u_int32_t stall,
+			    u_int32_t immediate, u_int32_t *data);
 
 /*
  * Section 2 - Simple descriptor construction definitions
  */
 
-/*
- * Construct simple sequence job descriptor
- *
- * Constructs a simple job descriptor that contains 3 references:
- *   (1) A pointer to a shared descriptor to do the work. This is
- *       normally assumed to be some sort of a protocol sharedesc,
- *       but doesn't have to be.
- *   (2) A pointer to a packet/frame for input data
- *   (3) A pointer to a packet/frame for output data
- *
- * This descriptor is always a simple reverse-order descriptor,
- * and has no provisions for other content specifications.
- *
- * Inputs:
- *
- */
-int cnstr_seq_jobdesc(u_int32_t *jobdesc, unsigned short *jobdescsz,
-		      u_int32_t *shrdesc, unsigned short shrdescsize,
-		      unsigned char *inbuf, unsigned long insize,
-		      unsigned char *outbuf, unsigned long outsize);
+struct pk_in_params {
+	u_int8_t *e;
+	u_int32_t e_siz;
+	u_int8_t *n;
+	u_int32_t n_siz;
+	u_int8_t *a;
+	u_int32_t a_siz;
+	u_int8_t *b;
+	u_int32_t b_siz;
+};
+
+int cnstr_seq_jobdesc(u_int32_t *jobdesc, u_int16_t *jobdescsz,
+		      u_int32_t *shrdesc, u_int16_t shrdescsz,
+		      void *inbuf, u_int32_t insize,
+		      void *outbuf, u_int32_t outsize);
+
+int cnstr_jobdesc_blkcipher_cbc(u_int32_t *descbuf, u_int16_t *bufsz,
+				u_int8_t *data_in, u_int8_t *data_out,
+				u_int32_t datasz,
+				u_int8_t *key, u_int32_t keylen,
+				u_int8_t *iv, u_int32_t ivlen,
+				enum algdir dir, u_int32_t cipher,
+				u_int8_t clear);
+
+int32_t cnstr_jobdesc_hmac(u_int32_t *descbuf, u_int16_t *bufsize,
+			   u_int8_t *msg, u_int32_t msgsz, u_int8_t *digest,
+			   u_int8_t *key, u_int32_t cipher, u_int8_t *icv,
+			   u_int8_t clear);
+
+int cnstr_jobdesc_pkha_rsaexp(u_int32_t *descbuf, u_int16_t *bufsz,
+			      struct pk_in_params *pkin, u_int8_t *out,
+			      u_int32_t out_siz, u_int8_t clear);
 
 /*
  * Section 3 - Single-pass descriptor construction definitions
@@ -427,6 +374,24 @@ int cnstr_seq_jobdesc(u_int32_t *jobdesc, unsigned short *jobdescsz,
  * Section 4 - Protocol descriptor construction definitions
  */
 
+struct dsa_pdb {
+	u_int8_t  sgf_ln; /* s/g bitmask for q r g w f c d ab in 31:24 */
+			  /* L in 17:7, n in 6:0 */
+	u_int8_t *q;
+	u_int8_t *r;
+	u_int8_t *g;
+	u_int8_t *w;
+	u_int8_t *f;
+	u_int8_t *c;
+	u_int8_t *d;
+	u_int8_t *tmp; /* temporary data */
+	u_int8_t *ab;  /* only used if ECC processing */
+};
+
+int cnstr_jobdesc_dsaverify(u_int32_t *descbuf, u_int16_t *bufsz,
+			    struct dsa_pdb *dsadata, u_int8_t *msg,
+			    u_int32_t msg_sz, u_int8_t clear);
+
 /* If protocol descriptor, IPV4 or 6? */
 enum protocolvers {
 	PDB_IPV4,
@@ -484,15 +449,8 @@ struct cipherparams {
 	u_int32_t  keylen;
 };
 
-/*
- * A collection of common definitions for the contents
- * of a Protocol Data Block. At this point in time,
- * it only reflects common data used in IPSec-CBC
- * descriptor construction
- *
- * This could possibly use some seed values for SN/ESN,
- * IV, etc.
- */
+/* Common definitions for specifying Protocol Data Blocks */
+
 struct seqnum {
 	enum esn              esn;
 	enum antirply_winsiz  antirplysz;
@@ -508,117 +466,94 @@ struct pdbcont {
 	struct seqnum         seq;
 };
 
-/*
- * Protocol-level shared descriptor constructors
- *
- * These build a full protocol-level shared descriptor for semi-autonomous
- * processing of secured traffic through CAAM. Such descriptors function
- * as single-pass processors (integrating cipher and authentication
- * functions into a single logical step) with the added factor of
- * performing protocol-level packet manipulation in the same step
- * in the packet-handling process, by maintaining protocol-level
- * connection state information within the descriptor itself.
- *
- * For each function, the arguments are uniform:
- *
- * Inputs:
- *
- *    * descbuf    = Points to a buffer to construct the descriptor in.
- *                   All CAAM descriptors are built of an array of up to
- *                   63 32-bit words. If the caller wishes to construct
- *                   a descriptor directly in the executable buffer, then
- *                   that buffer must be hardware DMA-able, and physically
- *                   contiguous.
- *
- *    * bufsize    = Points to an unsigned 16-bit word with the max length
- *                   of the buffer to hold the descriptor. This will be
- *                   written back to with the actual size of the descriptor
- *                   once constructed. (Note: bounds checking not yet
- *                   implemented).
- *
- *    * pdb        = Points to a block of data (struct pdbcont) used to
- *                   describe the content if the Protocol Data Block to be
- *                   maintained inside the descriptor. PDB content is
- *                   protocol and mode specific.
- *
- *    * cipherdata = Points to a block of data used to describe the cipher
- *                   information for encryption/decryption of packet
- *                   content:
- *                   - algtype = one of CIPHER_TYPE_IPSEC_xxx
- *                   - key     = pointer to the cipher key data
- *                   - keydata = size of the key data in bits
- *
- *    * authdata   = Points to a block of data used to describe the
- *                   authentication information for validating the
- *                   authenticity of the packet source.
- *                   - algtype = one of AUTH_TYPE_IPSEC_xxx
- *                   - key     = pointer to the HMAC key data
- *                   - keydata = size of the key data in bits
- *
- *    * clear      = If nonzero, buffer is cleared before writing
- *
- * Returns:
- *
- *    * -1 if the descriptor creation failed for any reason, zero
- *      if creation succeeded.
- *
- */
+struct wimax_pdb {
+	u_int8_t  framecheck;  /* nonzero if FCS to be included */
+	u_int32_t nonce;
+	u_int8_t  b0_flags;
+	u_int8_t  iv_flags;    /* decap only */
+	u_int8_t  ctr_flags;
+	u_int16_t ctr_initial_count;
+	u_int32_t PN;
+	u_int16_t antireplay_len;
+};
 
+struct macsec_pdb {
+	u_int8_t  framecheck;  /* nonzero if FCS to be included */
+	u_int16_t aad_len;
+	u_int64_t sci;
+	u_int32_t PN;
+	u_int16_t ethertype;
+	u_int8_t  tci_an;
+	u_int8_t  antireplay_len;
+};
 
-/*
- * IPSec ESP CBC decapsulation case:
- *
- * pdb.opthdrlen      = Size of inbound header to skip over.
- * pdb.transmode      = PDB_TUNNEL/PDB_TRANSPORT for tunnel or transport
- *                      handling for the next header.
- * pdb.pclvers        = PDB_IPV4/PDB_IPV6 as appropriate for this connection.
- * pdb.seq.esn        = PDB_NO_ESN unless extended sequence numbers are to
- *                      be supported, then PDB_INCLUDE_ESN.
- * pdb.seq/antirplysz = PDB_ANTIRPLY_NONE if no antireplay window is to be
- *                      maintained in the PDB. Otherwise may be
- *                      PDB_ANTIRPLY_32 for a 32-entry window, or
- *                      PDB_ANTIRPLY_64 for a 64-entry window.
- *
- */
-int32_t cnstr_pcl_shdsc_ipsec_cbc_decap(u_int32_t           *descbuf,
-					u_int16_t           *bufsize,
-					struct pdbcont      *pdb,
+int32_t cnstr_pcl_shdsc_ipsec_cbc_decap(u_int32_t *descbuf,
+					u_int16_t *bufsize,
+					struct pdbcont *pdb,
 					struct cipherparams *cipherdata,
-					struct authparams   *authdata,
-					u_int8_t             clear);
+					struct authparams *authdata,
+					u_int8_t clear);
 
-/*
- * IPSec ESP CBC encapsulation case:
- *
- * pdbinfo.opthdrlen = Size of outbound IP header to be prepended to
- *                     output.
- * pdbinfo.opthdr    = Pointer to the IP header to be prepended to the
- *                     output, of size opthdrlen.
- * pdbinfo.transmode = PDB_TUNNEL/PDB_TRANSPORT for tunnel/transport
- *                     handling for the next header.
- * pdbinfo.pclvers   = PDB_IPV4/PDB_IPV6 as appropriate for this connection.
- * pdbinfo.seq.esn   = PDB_NO_ESN unless extended sequence numbers are to
- *                     be supported, then PDB_INCLUDE_ESN.
- * pdbinfo.ivsrc     = PDB_IV_FROM_PDB if the IV is to be maintained in
- *                     the PDB, else PDB_IV_FROM_RNG if the IV is to
- *                     be generated internally by CAAM's random number
- *                     generator.
- *
- */
-int32_t cnstr_pcl_shdsc_ipsec_cbc_encap(u_int32_t           *descbuf,
-					u_int16_t           *bufsize,
-					struct pdbcont      *pdb,
+int32_t cnstr_pcl_shdsc_ipsec_cbc_encap(u_int32_t *descbuf,
+					u_int16_t *bufsize,
+					struct pdbcont *pdb,
 					struct cipherparams *cipherdata,
-					struct authparams   *authdata,
-					u_int8_t             clear);
+					struct authparams *authdata,
+					u_int8_t clear);
+
+int32_t cnstr_shdsc_wimax_encap(u_int32_t *descbuf, u_int16_t *bufsize,
+				struct wimax_pdb *pdb,
+				struct cipherparams *cipherdata,
+				u_int8_t mode, u_int8_t clear);
+
+int32_t cnstr_shdsc_wimax_decap(u_int32_t *descbuf, u_int16_t *bufsize,
+				struct wimax_pdb *pdb,
+				struct cipherparams *cipherdata,
+				u_int8_t mode, u_int8_t clear);
+
+int32_t cnstr_shdsc_macsec_encap(u_int32_t *descbuf, u_int16_t *bufsize,
+				 struct macsec_pdb *pdb,
+				 struct cipherparams *cipherdata,
+				 u_int8_t clear);
+
+int32_t cnstr_shdsc_macsec_decap(u_int32_t *descbuf, u_int16_t *bufsize,
+				 struct macsec_pdb *pdb,
+				 struct cipherparams *cipherdata,
+				 u_int8_t clear);
+
+int32_t cnstr_shdsc_snow_f8(u_int32_t *descbuf, u_int16_t *bufsize,
+			    u_int8_t *key, u_int32_t keylen,
+			    enum algdir dir, u_int32_t count,
+			    u_int8_t bearer, u_int8_t direction,
+			    u_int8_t clear);
+
+int32_t cnstr_shdsc_snow_f9(u_int32_t *descbuf, u_int16_t *bufsize,
+			    u_int8_t *key, u_int32_t keylen,
+			    enum algdir dir, u_int32_t count,
+			    u_int32_t fresh, u_int8_t direction,
+			    u_int8_t clear);
+
+int32_t cnstr_shdsc_cbc_blkcipher(u_int32_t *descbuf, u_int16_t *bufsize,
+				  u_int8_t *key, u_int32_t keylen,
+				  u_int8_t *iv, u_int32_t ivlen,
+				  enum algdir dir, u_int32_t cipher,
+				  u_int8_t clear);
+
+int32_t cnstr_shdsc_hmac(u_int32_t *descbuf, u_int16_t *bufsize,
+			 u_int8_t *key, u_int32_t cipher, u_int8_t *icv,
+			 u_int8_t clear);
+
+int32_t cnstr_pcl_shdsc_3gpp_rlc_decap(u_int32_t *descbuf, u_int16_t *bufsize,
+				       u_int8_t *key, u_int32_t keysz,
+				       u_int32_t count, u_int32_t bearer,
+				       u_int32_t direction,
+				       u_int32_t payload_sz, u_int8_t clear);
 
 /*
  * Section 5 - disassembler definitions
  */
-void desc_hexdump(u_int32_t *descdata,
-		  u_int32_t  size,
-		  u_int32_t  wordsperline,
-		  int8_t    *indentstr);
+void desc_hexdump(u_int32_t *descdata, u_int32_t  size, u_int32_t wordsperline,
+		  int8_t *indentstr);
 
 void caam_desc_disasm(u_int32_t *desc);
 
diff --git a/drivers/crypto/caam/dcl/disasm.c b/drivers/crypto/caam/dcl/disasm.c
index 60732ee..4b60768 100644
--- a/drivers/crypto/caam/dcl/disasm.c
+++ b/drivers/crypto/caam/dcl/disasm.c
@@ -80,10 +80,6 @@ void desc_hexdump(u_int32_t *descdata,
 EXPORT_SYMBOL(desc_hexdump);
 
 
-/*
- * FIXME: in general, this should be reworked to eschew cases
- */
-
 static void show_shrhdr(u_int32_t *hdr)
 {
 	PRINT("   shrdesc: stidx=%d len=%d ",
@@ -233,15 +229,163 @@ static void show_key(u_int32_t *cmd, u_int8_t *idx)
 
 static void show_seq_key(u_int32_t *cmd, u_int8_t *idx)
 {
-	PRINT("    seqkey: ");
+	u_int32_t keylen, *keydata;
+
+	keylen  = *cmd & KEY_LENGTH_MASK;
+	keydata = cmd + 1;
+
+	PRINT("    seqkey: len=%d ", keylen);
+
+	switch (*cmd & CLASS_MASK) {
+	case CLASS_1:
+		PRINT("class1");
+		break;
+
+	case CLASS_2:
+		PRINT("class2");
+		break;
+	}
+
+	switch (*cmd & KEY_DEST_MASK) {
+	case KEY_DEST_CLASS_REG:
+		PRINT("->keyreg ");
+		break;
+
+	case KEY_DEST_PKHA_E:
+		PRINT("->pk-e ");
+		break;
+
+	case KEY_DEST_AFHA_SBOX:
+		PRINT("->af-sbox ");
+		break;
+
+	case KEY_DEST_MDHA_SPLIT:
+		PRINT("->md-split ");
+		break;
+	}
+
+	if (*cmd & KEY_VLF)
+		PRINT("variable ");
+
+	if (*cmd & KEY_ENC)
+		PRINT("encrypted ");
+
+	if (*cmd & KEY_IMM)
+		PRINT("inline ");
+
 	PRINT("\n");
 	(*idx)++;
+
+	if (*cmd & KEY_IMM) {
+		desc_hexdump(keydata, keylen >> 2, 4, NULL_LEADER);
+		(*idx) += keylen >> 2;
+	} else {
+		PRINT("          : @0x%08x\n", *keydata);
+		(*idx)++;
+	}
 }
 
 static void show_load(u_int32_t *cmd, u_int8_t *idx)
 {
+	u_int32_t ldlen, *lddata;
+
+	ldlen  = *cmd & LDST_LEN_MASK;
+	lddata = cmd + 1; /* point to key or pointer */
+
 	PRINT("        ld: ");
+
+	switch (*cmd & CLASS_MASK) {
+	case LDST_CLASS_IND_CCB:
+		PRINT("CCB-class-ind");
+		break;
+
+	case LDST_CLASS_1_CCB:
+		PRINT("CCB-class1");
+		break;
+
+	case LDST_CLASS_2_CCB:
+		PRINT("CCB-class2");
+		break;
+
+	case LDST_CLASS_DECO:
+		PRINT("DECO");
+		break;
+	}
+
+	if (*cmd & LDST_SGF)
+		PRINT(" scatter-gather");
+
+	if (*cmd & LDST_IMM)
+		PRINT(" inline");
+
+	switch (*cmd & LDST_SRCDST_MASK) {
+	case LDST_SRCDST_BYTE_CONTEXT:
+		PRINT(" byte-ctx");
+		break;
+
+	case LDST_SRCDST_BYTE_KEY:
+		PRINT(" byte-key");
+		break;
+
+	case LDST_SRCDST_BYTE_INFIFO:
+		PRINT(" byte-infifo");
+		break;
+
+	case LDST_SRCDST_BYTE_OUTFIFO:
+		PRINT(" byte-outfifo");
+		break;
+
+	case LDST_SRCDST_WORD_MODE_REG:
+		PRINT(" word-mode");
+		break;
+
+	case LDST_SRCDST_WORD_KEYSZ_REG:
+		PRINT(" word-keysz");
+		break;
+
+	case LDST_SRCDST_WORD_DATASZ_REG:
+		PRINT(" word-datasz");
+		break;
+
+	case LDST_SRCDST_WORD_ICVSZ_REG:
+		PRINT(" word-icvsz");
+		break;
+
+	case LDST_SRCDST_WORD_CHACTRL:
+		PRINT(" word-cha-ctrl");
+		break;
+
+	case LDST_SRCDST_WORD_IRQCTRL:
+		PRINT(" word-irq-ctrl");
+		break;
+
+	case LDST_SRCDST_WORD_CLRW:
+		PRINT(" word-clear");
+		break;
+
+	case LDST_SRCDST_WORD_STAT:
+		PRINT(" word-status");
+		break;
+
+	default:
+		PRINT(" <unk-dest>");
+		break;
+	}
+
+	PRINT(" offset=%d len=%d",
+	      (*cmd & LDST_OFFSET_MASK) >> LDST_OFFSET_SHIFT,
+	      (*cmd & LDST_LEN_MASK));
+
 	PRINT("\n");
+
+	if (*cmd & LDST_IMM) {
+		desc_hexdump(lddata, ldlen >> 2, 4, NULL_LEADER);
+		(*idx) += ldlen >> 2;
+	} else {
+		PRINT("          : @0x%08x\n", *lddata);
+		(*idx)++;
+	}
+
 	(*idx)++;
 }
 
@@ -251,29 +395,82 @@ static void show_seq_load(u_int32_t *cmd, u_int8_t *idx)
 
 	switch (*cmd & CLASS_MASK) {
 	case LDST_CLASS_IND_CCB:
-		PRINT("CCB class-indep. access");
+		PRINT("CCB-class-ind");
 		break;
 
 	case LDST_CLASS_1_CCB:
-		PRINT("CCB class 1 access");
+		PRINT("CCB-class1");
 		break;
 
 	case LDST_CLASS_2_CCB:
-		PRINT("CCB class 2 access");
+		PRINT("CCB-class2");
 		break;
 
 	case LDST_CLASS_DECO:
-		PRINT("DECO access");
+		PRINT("DECO");
 		break;
 	}
 
-	if (*cmd & LDST_SGF)
-		PRINT(" scatter-gather");
+	if (*cmd & LDST_VLF)
+		PRINT(" variable");
+
+	switch (*cmd & LDST_SRCDST_MASK) {
+	case LDST_SRCDST_BYTE_CONTEXT:
+		PRINT(" byte-ctx");
+		break;
+
+	case LDST_SRCDST_BYTE_KEY:
+		PRINT(" byte-key");
+		break;
+
+	case LDST_SRCDST_BYTE_INFIFO:
+		PRINT(" byte-infifo");
+		break;
+
+	case LDST_SRCDST_BYTE_OUTFIFO:
+		PRINT(" byte-outfifo");
+		break;
 
-	PRINT(" dest=%d offset=%d len=%d",
-	      (*cmd >> LDST_SRCDST_SHIFT) & LDST_SRCDST_MASK,
-	      (*cmd >> LDST_OFFSET_SHIFT) & LDST_OFFSET_MASK,
-	      *cmd & LDST_LEN_MASK);
+	case LDST_SRCDST_WORD_MODE_REG:
+		PRINT(" word-mode");
+		break;
+
+	case LDST_SRCDST_WORD_KEYSZ_REG:
+		PRINT(" word-keysz");
+		break;
+
+	case LDST_SRCDST_WORD_DATASZ_REG:
+		PRINT(" word-datasz");
+		break;
+
+	case LDST_SRCDST_WORD_ICVSZ_REG:
+		PRINT(" word-icvsz");
+		break;
+
+	case LDST_SRCDST_WORD_CHACTRL:
+		PRINT(" word-cha-ctrl");
+		break;
+
+	case LDST_SRCDST_WORD_IRQCTRL:
+		PRINT(" word-irq-ctrl");
+		break;
+
+	case LDST_SRCDST_WORD_CLRW:
+		PRINT(" word-clear");
+		break;
+
+	case LDST_SRCDST_WORD_STAT:
+		PRINT(" word-status");
+		break;
+
+	default:
+		PRINT(" <unk-dest>");
+		break;
+	}
+
+	PRINT(" offset=%d len=%d",
+	      (*cmd & LDST_OFFSET_MASK) >> LDST_OFFSET_SHIFT,
+	      (*cmd & LDST_LEN_MASK));
 
 	PRINT("\n");
 	(*idx)++;
@@ -281,21 +478,338 @@ static void show_seq_load(u_int32_t *cmd, u_int8_t *idx)
 
 static void show_fifo_load(u_int32_t *cmd, u_int8_t *idx)
 {
-	PRINT("    fifold: ");
-	PRINT("\n");
+	u_int16_t datalen;
+	u_int32_t *data;
+
+	data = cmd + 1;
+
+	PRINT("    fifold: class=");
+	switch (*cmd & CLASS_MASK) {
+	case FIFOLD_CLASS_SKIP:
+		PRINT("skip");
+		break;
+
+	case FIFOLD_CLASS_CLASS1:
+		PRINT("class1");
+		break;
+
+	case FIFOLD_CLASS_CLASS2:
+		PRINT("class2");
+		break;
+
+	case FIFOLD_CLASS_BOTH:
+		PRINT("both");
+		break;
+	}
+
+	if (*cmd & FIFOLDST_SGF_MASK)
+		PRINT(" sgf");
+
+	if (*cmd & FIFOLD_IMM_MASK)
+		PRINT(" imm");
+
+	if (*cmd & FIFOLDST_EXT_MASK)
+		PRINT(" ext");
+
+	PRINT(" type=");
+	if ((*cmd & FIFOLD_TYPE_PK_MASK) == FIFOLD_TYPE_PK) {
+		PRINT("pk-");
+		switch (*cmd * FIFOLD_TYPE_PK_TYPEMASK) {
+		case FIFOLD_TYPE_PK_A0:
+			PRINT("a0");
+			break;
+
+		case FIFOLD_TYPE_PK_A1:
+			PRINT("a1");
+			break;
+
+		case FIFOLD_TYPE_PK_A2:
+			PRINT("a2");
+			break;
+
+		case FIFOLD_TYPE_PK_A3:
+			PRINT("a3");
+			break;
+
+		case FIFOLD_TYPE_PK_B0:
+			PRINT("b0");
+			break;
+
+		case FIFOLD_TYPE_PK_B1:
+			PRINT("b1");
+			break;
+
+		case FIFOLD_TYPE_PK_B2:
+			PRINT("b2");
+			break;
+
+		case FIFOLD_TYPE_PK_B3:
+			PRINT("b3");
+			break;
+
+		case FIFOLD_TYPE_PK_N:
+			PRINT("n");
+			break;
+
+		case FIFOLD_TYPE_PK_A:
+			PRINT("a");
+			break;
+
+		case FIFOLD_TYPE_PK_B:
+			PRINT("b");
+			break;
+		}
+	} else {
+		switch (*cmd & FIFOLD_TYPE_MSG_MASK)  {
+		case FIFOLD_TYPE_MSG:
+			PRINT("msg");
+			break;
+
+		case FIFOLD_TYPE_MSG1OUT2:
+			PRINT("msg1->2");
+			break;
+
+		case FIFOLD_TYPE_IV:
+			PRINT("IV");
+			break;
+
+		case FIFOLD_TYPE_BITDATA:
+			PRINT("bit");
+			break;
+
+		case FIFOLD_TYPE_AAD:
+			PRINT("AAD");
+			break;
+
+		case FIFOLD_TYPE_ICV:
+			PRINT("ICV");
+			break;
+		}
+
+		if (*cmd & FIFOLD_TYPE_LAST2)
+			PRINT("-l2");
+
+		if (*cmd & FIFOLD_TYPE_LAST1)
+			PRINT("-l1");
+
+		if (*cmd & FIFOLD_TYPE_FLUSH1)
+			PRINT("-f1");
+	}
+
+	datalen = (*cmd & FIFOLDST_LEN_MASK);
+	PRINT(" len = %d\n", datalen);
 	(*idx)++;
+
+	if (*cmd & FIFOLDST_EXT)
+		PRINT("          : extlen=0x%08x\n", (*idx)++);
+
 }
 
 static void show_seq_fifo_load(u_int32_t *cmd, u_int8_t *idx)
 {
-	PRINT(" seqfifold: ");
-	PRINT("\n");
+	u_int16_t datalen;
+	u_int32_t *data;
+
+	data = cmd + 1;
+
+	PRINT(" seqfifold: class=");
+	switch (*cmd & CLASS_MASK) {
+	case FIFOLD_CLASS_SKIP:
+		PRINT("skip");
+		break;
+
+	case FIFOLD_CLASS_CLASS1:
+		PRINT("class1");
+		break;
+
+	case FIFOLD_CLASS_CLASS2:
+		PRINT("class2");
+		break;
+
+	case FIFOLD_CLASS_BOTH:
+		PRINT("both");
+		break;
+	}
+
+	if (*cmd & FIFOLDST_VLF_MASK)
+		PRINT(" vlf");
+
+	if (*cmd & FIFOLD_IMM_MASK)
+		PRINT(" imm");
+
+	if (*cmd & FIFOLDST_EXT_MASK)
+		PRINT(" ext");
+
+	PRINT(" type=");
+	if ((*cmd & FIFOLD_TYPE_PK_MASK) == FIFOLD_TYPE_PK) {
+		PRINT("pk-");
+		switch (*cmd * FIFOLD_TYPE_PK_TYPEMASK) {
+		case FIFOLD_TYPE_PK_A0:
+			PRINT("a0");
+			break;
+
+		case FIFOLD_TYPE_PK_A1:
+			PRINT("a1");
+			break;
+
+		case FIFOLD_TYPE_PK_A2:
+			PRINT("a2");
+			break;
+
+		case FIFOLD_TYPE_PK_A3:
+			PRINT("a3");
+			break;
+
+		case FIFOLD_TYPE_PK_B0:
+			PRINT("b0");
+			break;
+
+		case FIFOLD_TYPE_PK_B1:
+			PRINT("b1");
+			break;
+
+		case FIFOLD_TYPE_PK_B2:
+			PRINT("b2");
+			break;
+
+		case FIFOLD_TYPE_PK_B3:
+			PRINT("b3");
+			break;
+
+		case FIFOLD_TYPE_PK_N:
+			PRINT("n");
+			break;
+
+		case FIFOLD_TYPE_PK_A:
+			PRINT("a");
+			break;
+
+		case FIFOLD_TYPE_PK_B:
+			PRINT("b");
+			break;
+		}
+	} else {
+		switch (*cmd & FIFOLD_TYPE_MSG_MASK)  {
+		case FIFOLD_TYPE_MSG:
+			PRINT("msg");
+			break;
+
+		case FIFOLD_TYPE_MSG1OUT2:
+			PRINT("msg1->2");
+			break;
+
+		case FIFOLD_TYPE_IV:
+			PRINT("IV");
+			break;
+
+		case FIFOLD_TYPE_BITDATA:
+			PRINT("bit");
+			break;
+
+		case FIFOLD_TYPE_AAD:
+			PRINT("AAD");
+			break;
+
+		case FIFOLD_TYPE_ICV:
+			PRINT("ICV");
+			break;
+		}
+
+		if (*cmd & FIFOLD_TYPE_LAST2)
+			PRINT("-l2");
+
+		if (*cmd & FIFOLD_TYPE_LAST1)
+			PRINT("-l1");
+
+		if (*cmd & FIFOLD_TYPE_FLUSH1)
+			PRINT("-f1");
+	}
+
+	datalen = (*cmd & FIFOLDST_LEN_MASK);
+	PRINT(" len = %d\n", datalen);
 	(*idx)++;
+
+	if (*cmd & FIFOLDST_EXT)
+		PRINT("          : extlen=0x%08x\n", (*idx)++);
+
 }
 
 static void show_store(u_int32_t *cmd, u_int8_t *idx)
 {
 	PRINT("       str: ");
+	switch (*cmd & LDST_CLASS_MASK) {
+	case LDST_CLASS_IND_CCB:
+		PRINT("ccb-indep ");
+		break;
+
+	case LDST_CLASS_1_CCB:
+		PRINT("ccb-class1 ");
+		break;
+
+	case LDST_CLASS_2_CCB:
+		PRINT("ccb-class2 ");
+		break;
+
+	case LDST_CLASS_DECO:
+		PRINT("deco ");
+		break;
+	}
+
+	if (*cmd & LDST_SGF)
+		PRINT("sgf ");
+
+	if (*cmd & LDST_IMM)
+		PRINT("imm ");
+
+	PRINT("src=");
+	switch (*cmd & LDST_SRCDST_MASK) {
+	case LDST_SRCDST_BYTE_CONTEXT:
+		PRINT("byte-ctx ");
+		break;
+
+	case LDST_SRCDST_BYTE_KEY:
+		PRINT("byte-key ");
+		break;
+
+	case LDST_SRCDST_WORD_MODE_REG:
+		PRINT("word-mode ");
+		break;
+
+	case LDST_SRCDST_WORD_KEYSZ_REG:
+		PRINT("word-keysz ");
+		break;
+
+	case LDST_SRCDST_WORD_DATASZ_REG:
+		PRINT("word-datasz ");
+		break;
+
+	case LDST_SRCDST_WORD_ICVSZ_REG:
+		PRINT("word-icvsz ");
+		break;
+
+	case LDST_SRCDST_WORD_CHACTRL:
+		PRINT("cha-ctrl ");
+		break;
+
+	case LDST_SRCDST_WORD_IRQCTRL:
+		PRINT("irq-ctrl ");
+		break;
+
+	case LDST_SRCDST_WORD_CLRW:
+		PRINT("clr-written ");
+		break;
+
+	case LDST_SRCDST_WORD_STAT:
+		PRINT("status ");
+		break;
+
+	default:
+		PRINT("(unk) ");
+		break;
+	}
+
+	PRINT("offset=%d ", (*cmd & LDST_OFFSET_MASK) >> LDST_OFFSET_SHIFT);
+	PRINT("len=%d ", (*cmd & LDST_LEN_MASK) >> LDST_LEN_SHIFT);
 	PRINT("\n");
 	(*idx)++;
 }
@@ -303,27 +817,500 @@ static void show_store(u_int32_t *cmd, u_int8_t *idx)
 static void show_seq_store(u_int32_t *cmd, u_int8_t *idx)
 {
 	PRINT("    seqstr: ");
+	switch (*cmd & LDST_CLASS_MASK) {
+	case LDST_CLASS_IND_CCB:
+		PRINT("ccb-indep ");
+		break;
+
+	case LDST_CLASS_1_CCB:
+		PRINT("ccb-class1 ");
+		break;
+
+	case LDST_CLASS_2_CCB:
+		PRINT("ccb-class2 ");
+		break;
+
+	case LDST_CLASS_DECO:
+		PRINT("deco ");
+		break;
+	}
+
+	if (*cmd & LDST_VLF)
+		PRINT("vlf ");
+
+	if (*cmd & LDST_IMM)
+		PRINT("imm ");
+
+	PRINT("src=");
+	switch (*cmd & LDST_SRCDST_MASK) {
+	case LDST_SRCDST_BYTE_CONTEXT:
+		PRINT("byte-ctx ");
+		break;
+
+	case LDST_SRCDST_BYTE_KEY:
+		PRINT("byte-key ");
+		break;
+
+	case LDST_SRCDST_WORD_MODE_REG:
+		PRINT("word-mode ");
+		break;
+
+	case LDST_SRCDST_WORD_KEYSZ_REG:
+		PRINT("word-keysz ");
+		break;
+
+	case LDST_SRCDST_WORD_DATASZ_REG:
+		PRINT("word-datasz ");
+		break;
+
+	case LDST_SRCDST_WORD_ICVSZ_REG:
+		PRINT("word-icvsz ");
+		break;
+
+	case LDST_SRCDST_WORD_CHACTRL:
+		PRINT("cha-ctrl ");
+		break;
+
+	case LDST_SRCDST_WORD_IRQCTRL:
+		PRINT("irq-ctrl ");
+		break;
+
+	case LDST_SRCDST_WORD_CLRW:
+		PRINT("clr-written ");
+		break;
+
+	case LDST_SRCDST_WORD_STAT:
+		PRINT("status ");
+		break;
+
+	default:
+		PRINT("<unk> ");
+		break;
+	}
+
+	PRINT("offset=%d ", (*cmd & LDST_OFFSET_MASK) >> LDST_OFFSET_SHIFT);
+	PRINT("len=%d ", (*cmd & LDST_LEN_MASK) >> LDST_LEN_SHIFT);
 	PRINT("\n");
 	(*idx)++;
 }
 
 static void show_fifo_store(u_int32_t *cmd, u_int8_t *idx)
 {
-	PRINT("   fifostr: ");
-	PRINT("\n");
+	u_int16_t datalen;
+	u_int32_t *data;
+
+	data = cmd + 1;
+
+	PRINT("   fifostr: class=");
+	switch (*cmd & CLASS_MASK) {
+	case FIFOST_CLASS_NORMAL:
+		PRINT("norm");
+		break;
+
+	case FIFOST_CLASS_CLASS1KEY:
+		PRINT("class1");
+		break;
+
+	case FIFOST_CLASS_CLASS2KEY:
+		PRINT("class2");
+		break;
+
+	default:
+		PRINT("<unk>");
+		break;
+	}
+
+	if (*cmd & FIFOLDST_SGF_MASK)
+		PRINT(" sgf");
+
+	if (*cmd & FIFOST_CONT_MASK)
+		PRINT(" cont");
+
+	if (*cmd & FIFOLDST_EXT_MASK)
+		PRINT(" ext");
+
+	PRINT(" type=");
+	switch (*cmd & FIFOLD_TYPE_MSG_MASK)  {
+	case FIFOST_TYPE_PKHA_A0:
+		PRINT("pk-a0");
+		break;
+
+	case FIFOST_TYPE_PKHA_A1:
+		PRINT("pk-a1");
+		break;
+
+	case FIFOST_TYPE_PKHA_A2:
+		PRINT("pk-a2");
+		break;
+
+	case FIFOST_TYPE_PKHA_A3:
+		PRINT("pk-a3");
+		break;
+
+	case FIFOST_TYPE_PKHA_B0:
+		PRINT("pk-b0");
+		break;
+
+	case FIFOST_TYPE_PKHA_B1:
+		PRINT("pk-b1");
+		break;
+
+	case FIFOST_TYPE_PKHA_B2:
+		PRINT("pk-b2");
+		break;
+
+	case FIFOST_TYPE_PKHA_B3:
+		PRINT("pk-b3");
+		break;
+
+	case FIFOST_TYPE_PKHA_N:
+		PRINT("pk-n");
+		break;
+
+	case FIFOST_TYPE_PKHA_A:
+		PRINT("pk-a");
+		break;
+
+	case FIFOST_TYPE_PKHA_B:
+		PRINT("pk-b");
+		break;
+
+	case FIFOST_TYPE_AF_SBOX_JKEK:
+		PRINT("af-sbox-jkek");
+		break;
+
+	case FIFOST_TYPE_AF_SBOX_TKEK:
+		PRINT("af-sbox-tkek");
+		break;
+
+	case FIFOST_TYPE_PKHA_E_JKEK:
+		PRINT("pk-e-jkek");
+		break;
+
+	case FIFOST_TYPE_PKHA_E_TKEK:
+		PRINT("pk-e-tkek");
+		break;
+
+	case FIFOST_TYPE_KEY_KEK:
+		PRINT("key-kek");
+		break;
+
+	case FIFOST_TYPE_KEY_TKEK:
+		PRINT("key-tkek");
+		break;
+
+	case FIFOST_TYPE_SPLIT_KEK:
+		PRINT("split-kek");
+		break;
+
+	case FIFOST_TYPE_SPLIT_TKEK:
+		PRINT("split-tkek");
+		break;
+
+	case FIFOST_TYPE_OUTFIFO_KEK:
+		PRINT("outf-kek");
+		break;
+
+	case FIFOST_TYPE_OUTFIFO_TKEK:
+		PRINT("outf-tkek");
+		break;
+
+	case FIFOST_TYPE_MESSAGE_DATA:
+		PRINT("msg");
+		break;
+
+	case FIFOST_TYPE_RNGSTORE:
+		PRINT("rng");
+		break;
+
+	case FIFOST_TYPE_RNGFIFO:
+		PRINT("rngf");
+		break;
+
+	case FIFOST_TYPE_SKIP:
+		PRINT("skip");
+		break;
+
+	default:
+		PRINT("<unk>");
+		break;
+	};
+
+	datalen = (*cmd & FIFOLDST_LEN_MASK);
+	PRINT(" len = %d\n", datalen);
+	(*idx)++;
+
+	if (*cmd & FIFOLDST_EXT)
+		PRINT("          : extlen=0x%08x\n", (*idx)++);
+
 	(*idx)++;
 }
 
 static void show_seq_fifo_store(u_int32_t *cmd, u_int8_t *idx)
 {
-	PRINT("seqfifostr: ");
-	PRINT("\n");
+	u_int16_t datalen;
+	u_int32_t *data;
+
+	data = cmd + 1;
+
+	PRINT("seqfifostr: class=");
+	switch (*cmd & CLASS_MASK) {
+	case FIFOST_CLASS_NORMAL:
+		PRINT("norm");
+		break;
+
+	case FIFOST_CLASS_CLASS1KEY:
+		PRINT("class1");
+		break;
+
+	case FIFOST_CLASS_CLASS2KEY:
+		PRINT("class2");
+		break;
+
+	default:
+		PRINT("<unk>");
+		break;
+	}
+
+	if (*cmd & FIFOLDST_VLF_MASK)
+		PRINT(" vlf");
+
+	if (*cmd & FIFOST_CONT_MASK)
+		PRINT(" cont");
+
+	if (*cmd & FIFOLDST_EXT_MASK)
+		PRINT(" ext");
+
+	PRINT(" type=");
+	switch (*cmd & FIFOLD_TYPE_MSG_MASK)  {
+	case FIFOST_TYPE_PKHA_A0:
+		PRINT("pk-a0");
+		break;
+
+	case FIFOST_TYPE_PKHA_A1:
+		PRINT("pk-a1");
+		break;
+
+	case FIFOST_TYPE_PKHA_A2:
+		PRINT("pk-a2");
+		break;
+
+	case FIFOST_TYPE_PKHA_A3:
+		PRINT("pk-a3");
+		break;
+
+	case FIFOST_TYPE_PKHA_B0:
+		PRINT("pk-b0");
+		break;
+
+	case FIFOST_TYPE_PKHA_B1:
+		PRINT("pk-b1");
+		break;
+
+	case FIFOST_TYPE_PKHA_B2:
+		PRINT("pk-b2");
+		break;
+
+	case FIFOST_TYPE_PKHA_B3:
+		PRINT("pk-b3");
+		break;
+
+	case FIFOST_TYPE_PKHA_N:
+		PRINT("pk-n");
+		break;
+
+	case FIFOST_TYPE_PKHA_A:
+		PRINT("pk-a");
+		break;
+
+	case FIFOST_TYPE_PKHA_B:
+		PRINT("pk-b");
+		break;
+
+	case FIFOST_TYPE_AF_SBOX_JKEK:
+		PRINT("af-sbox-jkek");
+		break;
+
+	case FIFOST_TYPE_AF_SBOX_TKEK:
+		PRINT("af-sbox-tkek");
+		break;
+
+	case FIFOST_TYPE_PKHA_E_JKEK:
+		PRINT("pk-e-jkek");
+		break;
+
+	case FIFOST_TYPE_PKHA_E_TKEK:
+		PRINT("pk-e-tkek");
+		break;
+
+	case FIFOST_TYPE_KEY_KEK:
+		PRINT("key-kek");
+		break;
+
+	case FIFOST_TYPE_KEY_TKEK:
+		PRINT("key-tkek");
+		break;
+
+	case FIFOST_TYPE_SPLIT_KEK:
+		PRINT("split-kek");
+		break;
+
+	case FIFOST_TYPE_SPLIT_TKEK:
+		PRINT("split-tkek");
+		break;
+
+	case FIFOST_TYPE_OUTFIFO_KEK:
+		PRINT("outf-kek");
+		break;
+
+	case FIFOST_TYPE_OUTFIFO_TKEK:
+		PRINT("outf-tkek");
+		break;
+
+	case FIFOST_TYPE_MESSAGE_DATA:
+		PRINT("msg");
+		break;
+
+	case FIFOST_TYPE_RNGSTORE:
+		PRINT("rng");
+		break;
+
+	case FIFOST_TYPE_RNGFIFO:
+		PRINT("rngf");
+		break;
+
+	case FIFOST_TYPE_SKIP:
+		PRINT("skip");
+		break;
+
+	default:
+		PRINT("<unk>");
+		break;
+	};
+
+	datalen = (*cmd & FIFOLDST_LEN_MASK);
+	PRINT(" len = %d\n", datalen);
+	(*idx)++;
+
+	if (*cmd & FIFOLDST_EXT)
+		PRINT("          : extlen=0x%08x\n", (*idx)++);
+
 	(*idx)++;
 }
 
 static void show_move(u_int32_t *cmd, u_int8_t *idx)
 {
 	PRINT("      move: ");
+
+	switch (*cmd & MOVE_SRC_MASK) {
+	case MOVE_SRC_CLASS1CTX:
+		PRINT("class1-ctx");
+		break;
+
+	case MOVE_SRC_CLASS2CTX:
+		PRINT("class2-ctx");
+		break;
+
+	case MOVE_SRC_OUTFIFO:
+		PRINT("outfifo");
+		break;
+
+	case MOVE_SRC_DESCBUF:
+		PRINT("descbuf");
+		break;
+
+	case MOVE_SRC_MATH0:
+		PRINT("math0");
+		break;
+
+	case MOVE_SRC_MATH1:
+		PRINT("math1");
+		break;
+
+	case MOVE_SRC_MATH2:
+		PRINT("math2");
+		break;
+
+	case MOVE_SRC_MATH3:
+		PRINT("math3");
+		break;
+
+	case MOVE_SRC_INFIFO:
+		PRINT("infifo");
+		break;
+
+	default:
+		PRINT("<unk>");
+		break;
+	}
+
+	PRINT("->");
+
+	switch (*cmd & MOVE_DEST_MASK) {
+	case MOVE_DEST_CLASS1CTX:
+		PRINT("class1-ctx ");
+		break;
+
+	case MOVE_DEST_CLASS2CTX:
+		PRINT("class2-ctx ");
+		break;
+
+	case MOVE_DEST_OUTFIFO:
+		PRINT("outfifo ");
+		break;
+
+	case MOVE_DEST_DESCBUF:
+		PRINT("descbuf ");
+		break;
+
+	case MOVE_DEST_MATH0:
+		PRINT("math0 ");
+		break;
+
+	case MOVE_DEST_MATH1:
+		PRINT("math1 ");
+		break;
+
+	case MOVE_DEST_MATH2:
+		PRINT("math2 ");
+		break;
+
+	case MOVE_DEST_MATH3:
+		PRINT("math3 ");
+		break;
+
+	case MOVE_DEST_CLASS1INFIFO:
+		PRINT("class1-infifo ");
+		break;
+
+	case MOVE_DEST_CLASS2INFIFO:
+		PRINT("class2-infifo ");
+		break;
+
+	case MOVE_DEST_PK_A:
+		PRINT("pk-a ");
+		break;
+
+	case MOVE_DEST_CLASS1KEY:
+		PRINT("class1-key ");
+		break;
+
+	case MOVE_DEST_CLASS2KEY:
+		PRINT("class2-key ");
+		break;
+
+	default:
+		PRINT("<unk> ");
+		break;
+	}
+
+	PRINT("offset=%d ", (*cmd & MOVE_OFFSET_MASK) >> MOVE_OFFSET_SHIFT);
+
+	PRINT("length=%d ", (*cmd & MOVE_LEN_MASK) >> MOVE_LEN_SHIFT);
+
+	if (*cmd & MOVE_WAITCOMP)
+		PRINT("wait ");
+
 	PRINT("\n");
 	(*idx)++;
 }
@@ -523,14 +1510,336 @@ static void decode_pk_op(u_int32_t *cmd)
 	}
 }
 
-static void decode_class1_op(u_int32_t *cmd)
+static void decode_class12_op(u_int32_t *cmd)
 {
-}
+	/* Algorithm type */
+	switch (*cmd & OP_ALG_ALGSEL_MASK) {
+	case OP_ALG_ALGSEL_AES:
+		PRINT("aes ");
+		break;
+
+	case OP_ALG_ALGSEL_DES:
+		PRINT("des ");
+		break;
+
+	case OP_ALG_ALGSEL_3DES:
+		PRINT("3des ");
+		break;
+
+	case OP_ALG_ALGSEL_ARC4:
+		PRINT("arc4 ");
+		break;
+
+	case OP_ALG_ALGSEL_MD5:
+		PRINT("md5 ");
+		break;
+
+	case OP_ALG_ALGSEL_SHA1:
+		PRINT("sha1 ");
+		break;
+
+	case OP_ALG_ALGSEL_SHA224:
+		PRINT("sha224 ");
+		break;
+
+	case OP_ALG_ALGSEL_SHA256:
+		PRINT("sha256 ");
+		break;
+
+	case OP_ALG_ALGSEL_SHA384:
+		PRINT("sha384 ");
+		break;
+
+	case OP_ALG_ALGSEL_SHA512:
+		PRINT("sha512 ");
+		break;
+
+	case OP_ALG_ALGSEL_RNG:
+		PRINT("rng ");
+		break;
+
+	case OP_ALG_ALGSEL_SNOW:
+		PRINT("snow ");
+		break;
+
+	case OP_ALG_ALGSEL_KASUMI:
+		PRINT("kasumi ");
+		break;
+
+	case OP_ALG_ALGSEL_CRC:
+		PRINT("crc ");
+		break;
+
+	default:
+		PRINT("unknown-alg ");
+	}
+
+	/* Additional info */
+	switch (*cmd & OP_ALG_ALGSEL_MASK) {
+	case OP_ALG_ALGSEL_AES:
+		switch (*cmd & OP_ALG_AAI_MASK) {
+		case OP_ALG_AAI_CTR_MOD128:
+			PRINT("ctr128 ");
+			break;
+
+		case OP_ALG_AAI_CTR_MOD8:
+			PRINT("ctr8 ");
+			break;
+
+		case OP_ALG_AAI_CTR_MOD16:
+			PRINT("ctr16 ");
+			break;
+
+		case OP_ALG_AAI_CTR_MOD24:
+			PRINT("ctr24 ");
+			break;
+
+		case OP_ALG_AAI_CTR_MOD32:
+			PRINT("ctr32 ");
+			break;
+
+		case OP_ALG_AAI_CTR_MOD40:
+			PRINT("ctr40 ");
+			break;
+
+		case OP_ALG_AAI_CTR_MOD48:
+			PRINT("ctr48 ");
+			break;
+
+		case OP_ALG_AAI_CTR_MOD56:
+			PRINT("ctr56 ");
+			break;
+
+		case OP_ALG_AAI_CTR_MOD64:
+			PRINT("ctr64 ");
+			break;
+
+		case OP_ALG_AAI_CTR_MOD72:
+			PRINT("ctr72 ");
+			break;
+
+		case OP_ALG_AAI_CTR_MOD80:
+			PRINT("ctr80 ");
+			break;
+
+		case OP_ALG_AAI_CTR_MOD88:
+			PRINT("ctr88 ");
+			break;
+
+		case OP_ALG_AAI_CTR_MOD96:
+			PRINT("ctr96 ");
+			break;
+
+		case OP_ALG_AAI_CTR_MOD104:
+			PRINT("ctr104 ");
+			break;
+
+		case OP_ALG_AAI_CTR_MOD112:
+			PRINT("ctr112 ");
+			break;
+
+		case OP_ALG_AAI_CTR_MOD120:
+			PRINT("ctr120 ");
+			break;
+
+		case OP_ALG_AAI_CBC:
+			PRINT("cbc ");
+			break;
+
+		case OP_ALG_AAI_ECB:
+			PRINT("ecb ");
+			break;
+
+		case OP_ALG_AAI_CFB:
+			PRINT("cfb ");
+			break;
+
+		case OP_ALG_AAI_OFB:
+			PRINT("ofb ");
+			break;
+
+		case OP_ALG_AAI_XTS:
+			PRINT("xts ");
+			break;
+
+		case OP_ALG_AAI_CMAC:
+			PRINT("cmac ");
+			break;
+
+		case OP_ALG_AAI_XCBC_MAC:
+			PRINT("xcbc-mac ");
+			break;
+
+		case OP_ALG_AAI_CCM:
+			PRINT("ccm ");
+			break;
+
+		case OP_ALG_AAI_GCM:
+			PRINT("gcm ");
+			break;
+
+		case OP_ALG_AAI_CBC_XCBCMAC:
+			PRINT("cbc-xcbc-mac ");
+			break;
+
+		case OP_ALG_AAI_CTR_XCBCMAC:
+			PRINT("ctr-xcbc-mac ");
+			break;
+
+		case OP_ALG_AAI_DK:
+			PRINT("dk ");
+			break;
+
+		}
+		break;
+
+	case OP_ALG_ALGSEL_DES:
+	case OP_ALG_ALGSEL_3DES:
+	switch (*cmd & OP_ALG_AAI_MASK) {
+	case OP_ALG_AAI_CBC:
+		PRINT("cbc ");
+		break;
+
+	case OP_ALG_AAI_ECB:
+		PRINT("ecb ");
+		break;
+
+	case OP_ALG_AAI_CFB:
+		PRINT("cfb ");
+		break;
+
+	case OP_ALG_AAI_OFB:
+		PRINT("ofb ");
+		break;
+
+	case OP_ALG_AAI_CHECKODD:
+		PRINT("chkodd ");
+		break;
+	}
+	break;
+
+	case OP_ALG_ALGSEL_RNG:
+	switch (*cmd & OP_ALG_AAI_MASK) {
+	case OP_ALG_AAI_RNG:
+		PRINT("rng ");
+		break;
+
+	case OP_ALG_AAI_RNG_NOZERO:
+		PRINT("rng-no0 ");
+		break;
+
+	case OP_ALG_AAI_RNG_ODD:
+		PRINT("rngodd ");
+		break;
+	}
+	break;
+
+
+	case OP_ALG_ALGSEL_SNOW:
+	case OP_ALG_ALGSEL_KASUMI:
+	switch (*cmd & OP_ALG_AAI_MASK) {
+	case OP_ALG_AAI_F8:
+		PRINT("f8 ");
+		break;
+
+	case OP_ALG_AAI_F9:
+		PRINT("f9 ");
+		break;
+
+	case OP_ALG_AAI_GSM:
+		PRINT("gsm ");
+		break;
+
+	case OP_ALG_AAI_EDGE:
+		PRINT("edge ");
+		break;
+	}
+	break;
+
+	case OP_ALG_ALGSEL_CRC:
+	switch (*cmd & OP_ALG_AAI_MASK) {
+	case OP_ALG_AAI_802:
+		PRINT("802 ");
+		break;
+
+	case OP_ALG_AAI_3385:
+		PRINT("3385 ");
+		break;
+
+	case OP_ALG_AAI_CUST_POLY:
+		PRINT("custom-poly ");
+		break;
+
+	case OP_ALG_AAI_DIS:
+		PRINT("dis ");
+		break;
+
+	case OP_ALG_AAI_DOS:
+		PRINT("dos ");
+		break;
+
+	case OP_ALG_AAI_DOC:
+		PRINT("doc ");
+		break;
+	}
+	break;
+
+	case OP_ALG_ALGSEL_MD5:
+	case OP_ALG_ALGSEL_SHA1:
+	case OP_ALG_ALGSEL_SHA224:
+	case OP_ALG_ALGSEL_SHA256:
+	case OP_ALG_ALGSEL_SHA384:
+	case OP_ALG_ALGSEL_SHA512:
+	switch (*cmd & OP_ALG_AAI_MASK) {
+	case OP_ALG_AAI_HMAC:
+		PRINT("hmac ");
+		break;
+
+	case OP_ALG_AAI_SMAC:
+		PRINT("smac ");
+		break;
+
+	case OP_ALG_AAI_HMAC_PRECOMP:
+		PRINT("hmac-pre ");
+		break;
+	}
+	break;
+
+	default:
+		PRINT("unknown-aai ");
+	}
+
+	if (*cmd & OP_ALG_TYPE_MASK) {
+		switch (*cmd & OP_ALG_AS_MASK) {
+		case OP_ALG_AS_UPDATE:
+			PRINT("update ");
+			break;
+
+		case OP_ALG_AS_INIT:
+			PRINT("init ");
+			break;
+
+		case OP_ALG_AS_FINALIZE:
+			PRINT("final ");
+			break;
+
+		case OP_ALG_AS_INITFINAL:
+			PRINT("init-final ");
+			break;
+		}
+	}
+
+	if (*cmd & OP_ALG_ICV_MASK)
+		PRINT("icv ");
+
+	if (*cmd & OP_ALG_DIR_MASK)
+		PRINT("encrypt ");
+	else
+		PRINT("decrypt ");
 
-static void decode_class2_op(u_int32_t *cmd)
-{
 }
 
+
 static void show_op(u_int32_t *cmd, u_int8_t *idx)
 {
 	PRINT(" operation: type=");
@@ -548,12 +1857,12 @@ static void show_op(u_int32_t *cmd, u_int8_t *idx)
 
 	case OP_TYPE_CLASS1_ALG:
 		PRINT("class1-op ");
-		decode_class1_op(cmd);
+		decode_class12_op(cmd);
 		break;
 
 	case OP_TYPE_CLASS2_ALG:
 		PRINT("class2-op ");
-		decode_class2_op(cmd);
+		decode_class12_op(cmd);
 		break;
 
 	case OP_TYPE_DECAP_PROTOCOL:
@@ -580,16 +1889,303 @@ static void show_signature(u_int32_t *cmd, u_int8_t *idx)
 static void show_jump(u_int32_t *cmd, u_int8_t *idx)
 {
 	PRINT("      jump: ");
-	PRINT("\n");
-	(*idx)++;
+	switch (*cmd & CLASS_MASK) {
+	case CLASS_NONE:
+		break;
+
+	case CLASS_1:
+		PRINT("class-1 ");
+		break;
+
+	case CLASS_2:
+		PRINT("class-2 ");
+		break;
+
+	case CLASS_BOTH:
+		PRINT("class-both ");
+		break;
+	}
+
+
+	switch (*cmd & JUMP_TYPE_MASK) {
+	case JUMP_TYPE_LOCAL:
+		PRINT("local");
+		break;
+
+	case JUMP_TYPE_NONLOCAL:
+		PRINT("nonlocal");
+		break;
+
+	case JUMP_TYPE_HALT:
+		PRINT("halt");
+		break;
+
+	case JUMP_TYPE_HALT_USER:
+		PRINT("halt-user");
+		break;
+	}
+
+	switch (*cmd & JUMP_TEST_MASK) {
+	case JUMP_TEST_ALL:
+		PRINT(" all");
+		break;
+
+	case JUMP_TEST_INVALL:
+		PRINT(" !all");
+		break;
+
+	case JUMP_TEST_ANY:
+		PRINT(" any");
+		break;
+
+	case JUMP_TEST_INVANY:
+		PRINT(" !any");
+		break;
+	}
+
+	if (!(*cmd & JUMP_JSL)) {
+		if (*cmd & JUMP_COND_PK_0)
+			PRINT(" pk-0");
+
+		if (*cmd & JUMP_COND_PK_GCD_1)
+			PRINT(" pk-gcd=1");
+
+		if (*cmd & JUMP_COND_PK_PRIME)
+			PRINT(" pk-prime");
+
+		if (*cmd & JUMP_COND_MATH_N)
+			PRINT(" math-n");
+
+		if (*cmd & JUMP_COND_MATH_Z)
+			PRINT(" math-z");
+
+		if (*cmd & JUMP_COND_MATH_C)
+			PRINT(" math-c");
+
+		if (*cmd & JUMP_COND_MATH_NV)
+			PRINT(" math-nv");
+	} else {
+		if (*cmd & JUMP_COND_JQP)
+			PRINT(" jq-pend");
+
+		if (*cmd & JUMP_COND_SHRD)
+			PRINT(" share-skip");
+
+		if (*cmd & JUMP_COND_SELF)
+			PRINT(" share-ctx");
+
+		if (*cmd & JUMP_COND_CALM)
+			PRINT(" complete");
+
+		if (*cmd & JUMP_COND_NIP)
+			PRINT(" no-input");
+
+		if (*cmd & JUMP_COND_NIFP)
+			PRINT(" no-infifo");
+
+		if (*cmd & JUMP_COND_NOP)
+			PRINT(" no-output");
+
+		if (*cmd & JUMP_COND_NCP)
+			PRINT(" no-ctxld");
+	}
+
+	if ((*cmd & JUMP_TYPE_MASK) == JUMP_TYPE_LOCAL) {
+		PRINT(" ->offset=%d\n", (*cmd & JUMP_OFFSET_MASK));
+		(*idx)++;
+	} else {
+		PRINT(" ->@0x%08x\n", (*idx + 1));
+		*idx += 2;
+	}
 }
 
 static void show_math(u_int32_t *cmd, u_int8_t *idx)
 {
+	u_int32_t mathlen, *mathdata;
+
+	mathlen  = *cmd & MATH_LEN_MASK;
+	mathdata = cmd + 1;
+
 	PRINT("      math: ");
-	PRINT("\n");
+	if (*cmd & MATH_IFB)
+		PRINT("imm4 ");
+	if (*cmd & MATH_NFU)
+		PRINT("noflag ");
+	if (*cmd & MATH_STL)
+		PRINT("stall ");
+
+	PRINT("fun=");
+	switch (*cmd & MATH_FUN_MASK) {
+	case MATH_FUN_ADD:
+		PRINT("add");
+		break;
+
+	case MATH_FUN_ADDC:
+		PRINT("addc");
+		break;
+
+	case MATH_FUN_SUB:
+		PRINT("sub");
+		break;
+
+	case MATH_FUN_SUBB:
+		PRINT("subc");
+		break;
+
+	case MATH_FUN_OR:
+		PRINT("or");
+		break;
+
+	case MATH_FUN_AND:
+		PRINT("and");
+		break;
+
+	case MATH_FUN_XOR:
+		PRINT("xor");
+		break;
+
+	case MATH_FUN_LSHIFT:
+		PRINT("lsh");
+		break;
+
+	case MATH_FUN_RSHIFT:
+		PRINT("rsh");
+		break;
+
+	case MATH_FUN_SHLD:
+		PRINT("shld");
+		break;
+	}
+
+
+	PRINT(" src0=");
+	switch (*cmd & MATH_SRC0_MASK) {
+	case MATH_SRC0_REG0:
+		PRINT("r0");
+		break;
+
+	case MATH_SRC0_REG1:
+		PRINT("r1");
+		break;
+
+	case MATH_SRC0_REG2:
+		PRINT("r2");
+		break;
+
+	case MATH_SRC0_REG3:
+		PRINT("r3");
+		break;
+
+	case MATH_SRC0_IMM:
+		PRINT("imm");
+		break;
+
+	case MATH_SRC0_SEQINLEN:
+		PRINT("seqinlen");
+		break;
+
+	case MATH_SRC0_SEQOUTLEN:
+		PRINT("seqoutlen");
+		break;
+
+	case MATH_SRC0_VARSEQINLEN:
+		PRINT("vseqinlen");
+		break;
+
+	case MATH_SRC0_VARSEQOUTLEN:
+		PRINT("vseqoutlen");
+		break;
+
+	case MATH_SRC0_ZERO:
+		PRINT("0");
+		break;
+	};
+
+	PRINT(" src1=");
+	switch (*cmd & MATH_SRC1_MASK) {
+	case MATH_SRC1_REG0:
+		PRINT("r0");
+		break;
+
+	case MATH_SRC1_REG1:
+		PRINT("r1");
+		break;
+
+	case MATH_SRC1_REG2:
+		PRINT("r2");
+		break;
+
+	case MATH_SRC1_REG3:
+		PRINT("r3");
+		break;
+
+	case MATH_SRC1_IMM:
+		PRINT("imm");
+		break;
+
+	case MATH_SRC1_INFIFO:
+		PRINT("infifo");
+		break;
+
+	case MATH_SRC1_OUTFIFO:
+		PRINT("outfifo");
+		break;
+
+	case MATH_SRC1_ONE:
+		PRINT("1");
+		break;
+
+	};
+
+	PRINT(" dest=");
+	switch (*cmd & MATH_DEST_MASK) {
+	case MATH_DEST_REG0:
+		PRINT("r0");
+		break;
+
+	case MATH_DEST_REG1:
+		PRINT("r1");
+		break;
+
+	case MATH_DEST_REG2:
+		PRINT("r2");
+		break;
+
+	case MATH_DEST_REG3:
+		PRINT("r3");
+		break;
+
+	case MATH_DEST_SEQINLEN:
+		PRINT("seqinlen");
+		break;
+
+	case MATH_DEST_SEQOUTLEN:
+		PRINT("seqoutlen");
+		break;
+
+	case MATH_DEST_VARSEQINLEN:
+		PRINT("vseqinlen");
+		break;
+
+	case MATH_DEST_VARSEQOUTLEN:
+		PRINT("vseqoutlen");
+		break;
+
+	case MATH_DEST_NONE:
+		PRINT("none");
+		break;
+	};
+
+	PRINT(" len=%d\n", mathlen);
+
 	(*idx)++;
-}
+
+	if  (((*cmd & MATH_SRC0_MASK) == MATH_SRC0_IMM) ||
+	     ((*cmd & MATH_SRC1_MASK) == MATH_SRC1_IMM)) {
+		desc_hexdump(cmd + 1, 1, 4, (int8_t *)"            ");
+		(*idx)++;
+	};
+};
 
 static void show_seq_in_ptr(u_int32_t *cmd, u_int8_t *idx)
 {
@@ -599,11 +2195,11 @@ static void show_seq_in_ptr(u_int32_t *cmd, u_int8_t *idx)
 	if (*cmd & SQIN_INL)
 		PRINT(" inline");
 	if (*cmd & SQIN_SGF)
-		PRINT(" scatter-gather");
+		PRINT(" s/g");
 	if (*cmd & SQIN_PRE) {
 		PRINT(" PRE");
 	} else {
-		PRINT(" ptr=0x%08x", *(cmd + 1));
+		PRINT(" @0x%08x", *(cmd + 1));
 		(*idx)++;
 	}
 	if (*cmd & SQIN_EXT)
@@ -624,7 +2220,7 @@ static void show_seq_out_ptr(u_int32_t *cmd, u_int8_t *idx)
 	if (*cmd & SQOUT_PRE) {
 		PRINT(" PRE");
 	} else {
-		PRINT(" ptr=0x%08x", *(cmd + 1));
+		PRINT(" @0x%08x", *(cmd + 1));
 		(*idx)++;
 	}
 	if (*cmd & SQOUT_EXT)
@@ -635,15 +2231,14 @@ static void show_seq_out_ptr(u_int32_t *cmd, u_int8_t *idx)
 	(*idx)++;
 }
 
-/*
- * Top-level descriptor disassembler
- *
- * desc - points to the descriptor to disassemble. First command
- *        must be a header, or shared header, and the overall size
- *        is determined by this. Does not handle a QI preheader as
- *        it's first command, and cannot yet follow links in a list
- *        of descriptors
- */
+/**
+ * caam_desc_disasm() - Top-level descriptor disassembler
+ * @desc - points to the descriptor to disassemble. First command
+ *         must be a header, or shared header, and the overall size
+ *         is determined by this. Does not handle a QI preheader as
+ *         it's first command, and cannot yet follow links in a list
+ *         of descriptors
+ **/
 void caam_desc_disasm(u_int32_t *desc)
 {
 	u_int8_t   len, idx, stidx;
@@ -662,6 +2257,12 @@ void caam_desc_disasm(u_int32_t *desc)
 		stidx = (*desc >> HDR_START_IDX_SHIFT) &
 			HDR_START_IDX_MASK;
 		show_shrhdr(desc);
+		/*
+		 * Show PDB area (that between header and startindex)
+		 * Improve PDB content dumps later...
+		 */
+		desc_hexdump(&desc[1], stidx - 1, 4, (int8_t *)"     (pdb): ");
+		idx = stidx;
 		break;
 
 	case CMD_DESC_HDR:
@@ -671,6 +2272,7 @@ void caam_desc_disasm(u_int32_t *desc)
 			HDR_START_IDX_MASK;
 
 		show_hdr(desc);
+		idx = 1; /* next instruction past header */
 
 		if (*desc & HDR_SHARED) {
 			stidx = 2; /* just skip past sharedesc ptr */
@@ -679,22 +2281,16 @@ void caam_desc_disasm(u_int32_t *desc)
 		break;
 
 	default:
-		PRINT("caam_desc_disasm() no initial header: 0x%08x\n",
+		PRINT("caam_desc_disasm(): no header: 0x%08x\n",
 		      *desc);
 		return;
 	}
 
-	/*
-	 * Show PDB area (that between header and startindex)
-	 * Improve PDB content dumps later...
-	 */
-	desc_hexdump(&desc[1], stidx - 1, 4, (int8_t *)"     (pdb): ");
 
 	/*
 	 * Now go process remaining commands in sequence
 	 */
 
-	idx = stidx;
 
 	while (idx < len) {
 		switch (desc[idx] & CMD_MASK) {
diff --git a/drivers/crypto/caam/dcl/jobdesc.c b/drivers/crypto/caam/dcl/jobdesc.c
index 3cf1a32..28939d2 100644
--- a/drivers/crypto/caam/dcl/jobdesc.c
+++ b/drivers/crypto/caam/dcl/jobdesc.c
@@ -37,10 +37,34 @@
 #include "dcl.h"
 
 
-int cnstr_seq_jobdesc(u_int32_t *jobdesc, unsigned short *jobdescsz,
-		      u_int32_t *shrdesc, unsigned short shrdescsz,
-		      unsigned char *inbuf, unsigned long insize,
-		      unsigned char *outbuf, unsigned long outsize)
+/**
+ * cnstr_seq_jobdesc() - Construct simple sequence job descriptor
+ * Returns: 0 (for now)
+ *
+ * @jobdesc - pointer to a buffer to build the target job descriptor
+ *            within
+ * @jobdescsz - size of target job descriptor buffer
+ * @shrdesc - pointer to pre-existing shared descriptor to use with
+ *            this job
+ * @shrdescsz - size of pre-existing shared descriptor
+ * @inbuf - pointer to input frame
+ * @insize - size of input frame
+ * @outbuf - pointer to output frame
+ * @outsize - size of output frame
+ *
+ * Constructs a simple job descriptor that contains 3 references:
+ *   (1) A shared descriptor to do the work. This is normally assumed
+ *       to be some sort of a protocol sharedesc, but can be any sharedesc.
+ *   (2) A packet/frame for input data
+ *   (3) A packet/frame for output data
+ *
+ * The created descriptor is always a simple reverse-order descriptor,
+ * and has no provisions for other content specifications.
+ **/
+int cnstr_seq_jobdesc(u_int32_t *jobdesc, u_int16_t *jobdescsz,
+		      u_int32_t *shrdesc, u_int16_t shrdescsz,
+		      void *inbuf, u_int32_t insize,
+		      void *outbuf, u_int32_t outsize)
 {
 	u_int32_t *next;
 
@@ -60,10 +84,8 @@ int cnstr_seq_jobdesc(u_int32_t *jobdesc, unsigned short *jobdescsz,
 	*next++ = (u_int32_t)shrdesc;
 
 	/* Sequence pointers */
-	next = cmd_insert_seq_out_ptr(next, (void *)outbuf, outsize,
-				      PTR_DIRECT);
-	next = cmd_insert_seq_in_ptr(next, (void *)inbuf, insize,
-				     PTR_DIRECT);
+	next = cmd_insert_seq_out_ptr(next, outbuf, outsize, PTR_DIRECT);
+	next = cmd_insert_seq_in_ptr(next, inbuf, insize, PTR_DIRECT);
 
 	/* Now update header */
 	*jobdescsz = next - jobdesc; /* add 1 to include header */
@@ -72,3 +94,311 @@ int cnstr_seq_jobdesc(u_int32_t *jobdesc, unsigned short *jobdescsz,
 
 	return 0;
 }
+
+
+
+
+
+/**
+ * Construct a blockcipher request as a single job
+ *
+ * @descbuf - pointer to buffer for descriptor construction
+ * @bufsz - size of constructed descriptor (as output)
+ * @data_in - input message
+ * @data_out - output message
+ * @datasz - size of message
+ * @key - cipher key
+ * @keylen - size of cipher key
+ * @iv - cipher IV
+ * @ivlen - size of cipher IV
+ * @dir - DIR_ENCRYPT or DIR_DECRYPT
+ * @cipher - algorithm from OP_ALG_ALGSEL_
+ * @clear - clear descriptor buffer before construction
+ **/
+
+int cnstr_jobdesc_blkcipher_cbc(u_int32_t *descbuf, u_int16_t *bufsz,
+				u_int8_t *data_in, u_int8_t *data_out,
+				u_int32_t datasz,
+				u_int8_t *key, u_int32_t keylen,
+				u_int8_t *iv, u_int32_t ivlen,
+				enum algdir dir, u_int32_t cipher,
+				u_int8_t clear)
+{
+	u_int32_t *start;
+	u_int16_t startidx, endidx;
+	u_int32_t mval;
+
+	start = descbuf++; /* save start for eventual header write */
+
+	if (!descbuf)
+		return -1;
+
+	if (clear)
+		memset(start, 0, (*bufsz * sizeof(u_int32_t)));
+
+	startidx = descbuf - start;
+	descbuf = cmd_insert_seq_in_ptr(descbuf, data_in, datasz,
+					PTR_DIRECT);
+
+	descbuf = cmd_insert_seq_out_ptr(descbuf, data_out, datasz,
+					 PTR_DIRECT);
+
+	descbuf = cmd_insert_load(descbuf, iv, LDST_CLASS_1_CCB,
+				  0, LDST_SRCDST_BYTE_CONTEXT, 0, (ivlen >> 3),
+				  ITEM_REFERENCE);
+
+	descbuf = cmd_insert_key(descbuf, key, keylen, PTR_DIRECT,
+				 KEYDST_KEYREG, KEY_CLEAR, ITEM_REFERENCE,
+				 ITEM_CLASS1);
+
+	mval = 0;
+	descbuf = cmd_insert_math(descbuf, MATH_FUN_SUB, MATH_SRC0_SEQINLEN,
+				  MATH_SRC1_IMM, MATH_DEST_VARSEQINLEN,
+				  4, 0, 0, 0, &mval);
+
+	descbuf = cmd_insert_math(descbuf, MATH_FUN_ADD, MATH_SRC0_SEQINLEN,
+				  MATH_SRC1_IMM, MATH_DEST_VARSEQOUTLEN,
+				  4, 0, 0, 0, &mval);
+
+	descbuf = cmd_insert_alg_op(descbuf, OP_TYPE_CLASS1_ALG, cipher,
+				    OP_ALG_AAI_CBC, MDSTATE_COMPLETE,
+				    ICV_CHECK_OFF, dir);
+
+	descbuf = cmd_insert_seq_fifo_load(descbuf, LDST_CLASS_1_CCB,
+					   FIFOLDST_VLF,
+					   (FIFOLD_TYPE_MSG |
+					   FIFOLD_TYPE_LAST1), 0);
+
+	descbuf = cmd_insert_seq_fifo_store(descbuf, LDST_CLASS_1_CCB,
+					    FIFOLDST_VLF,
+					    FIFOST_TYPE_MESSAGE_DATA, 0);
+
+
+	/* Now update the header with size/offsets */
+	endidx = descbuf - start;
+	cmd_insert_hdr(start, 0, endidx, SHR_NEVER, SHRNXT_LENGTH,
+		       ORDER_FORWARD, DESC_STD);
+
+	*bufsz = endidx;
+
+	return 0;
+}
+
+
+
+/**
+ * HMAC as a single job
+ * @descbuf - descriptor buffer
+ * @bufsize - limit/returned descriptor buffer size
+ * @msg     - pointer to message being processed
+ * @msgsz   - size of message in bytes
+ * @digest  - output buffer for digest (size derived from cipher)
+ * @key     - key data (size derived from cipher)
+ * @cipher  - OP_ALG_ALGSEL_MD5/SHA1-512
+ * @icv     - HMAC comparison for ICV, NULL if no check desired
+ * @clear   - clear buffer before writing
+ **/
+
+int32_t cnstr_jobdesc_hmac(u_int32_t *descbuf, u_int16_t *bufsize,
+			   u_int8_t *msg, u_int32_t msgsz, u_int8_t *digest,
+			   u_int8_t *key, u_int32_t cipher, u_int8_t *icv,
+			   u_int8_t clear)
+{
+	u_int32_t *start;
+	u_int16_t startidx, endidx;
+	u_int8_t storelen;
+	enum icvsel opicv;
+
+	start = descbuf++;
+
+	if (clear)
+		memset(start, 0, (*bufsize * sizeof(u_int32_t)));
+
+	switch (cipher) {
+	case OP_ALG_ALGSEL_MD5:
+		storelen = 16;
+		break;
+
+	case OP_ALG_ALGSEL_SHA1:
+		storelen = 20;
+		break;
+
+	case OP_ALG_ALGSEL_SHA224:
+		storelen = 28;
+		break;
+
+	case OP_ALG_ALGSEL_SHA256:
+		storelen = 32;
+		break;
+
+	case OP_ALG_ALGSEL_SHA384:
+		storelen = 48;
+
+	case OP_ALG_ALGSEL_SHA512:
+		storelen = 64;
+
+	default:
+		return -1;
+	}
+
+	if (icv != NULL)
+		opicv = ICV_CHECK_ON;
+	else
+		opicv = ICV_CHECK_OFF;
+
+
+	startidx = descbuf - start;
+
+	descbuf = cmd_insert_key(descbuf, key, storelen * 8, PTR_DIRECT,
+				 KEYDST_KEYREG, KEY_CLEAR, ITEM_REFERENCE,
+				 ITEM_CLASS2);
+
+	descbuf = cmd_insert_fifo_load(descbuf, msg, msgsz, LDST_CLASS_2_CCB,
+				       0, 0, 0,
+				       (FIFOLD_TYPE_MSG |
+					FIFOLD_TYPE_LASTBOTH));
+
+	descbuf = cmd_insert_alg_op(descbuf, OP_TYPE_CLASS2_ALG, cipher,
+				    OP_ALG_AAI_HMAC, MDSTATE_COMPLETE,
+				    opicv, DIR_ENCRYPT);
+
+	descbuf = cmd_insert_store(descbuf, digest, LDST_CLASS_2_CCB, 0,
+				   LDST_SRCDST_BYTE_CONTEXT, 0, storelen,
+				   ITEM_REFERENCE);
+
+	endidx = descbuf - start;
+	cmd_insert_hdr(start, 0, endidx, SHR_NEVER, SHRNXT_LENGTH,
+		       ORDER_FORWARD, DESC_STD);
+
+	*bufsize = endidx;
+
+	return 0;
+}
+EXPORT_SYMBOL(cnstr_jobdesc_hmac);
+
+/**
+ * RSA exponentiation as a single job - cnstr_jobdesc_pkha_rsaexp()
+ *
+ * @descbuf - pointer to buffer to hold descriptor
+ * @bufsiz - pointer to size of written descriptor
+ * @pkin - Values of A, B, E, and N
+ * @out - Encrypted output
+ * @out_siz - size of buffer for encrypted output
+ * @clear - nonzero if descriptor buffer space is to be cleared
+ *          before construction
+ **/
+
+int cnstr_jobdesc_pkha_rsaexp(u_int32_t *descbuf, u_int16_t *bufsz,
+			      struct pk_in_params *pkin,
+			      u_int8_t *out, u_int32_t out_siz,
+			      u_int8_t clear)
+{
+	u_int32_t *start;
+	u_int16_t startidx, endidx;
+
+	start = descbuf++;
+	startidx = descbuf - start;
+
+	/* class=1 dest=e len=8 s=#ram_e_data */
+	descbuf = cmd_insert_key(descbuf, pkin->e, pkin->e_siz, PTR_DIRECT,
+				 KEYDST_PK_E, KEY_CLEAR, ITEM_REFERENCE,
+				 ITEM_CLASS1);
+
+	/* class=1 type=n len=8 s=#ram_n_data */
+	descbuf = cmd_insert_fifo_load(descbuf, pkin->n, pkin->n_siz,
+				       LDST_CLASS_1_CCB, 0, 0, 0,
+				       FIFOLD_TYPE_PK_N);
+
+	/* class=1 type=a len=8 s=#ram_a_data */
+	descbuf = cmd_insert_fifo_load(descbuf, pkin->a, pkin->a_siz,
+				       LDST_CLASS_1_CCB, 0, 0, 0,
+				       FIFOLD_TYPE_PK_A);
+
+	/* class=1 type=b len=9 s=#ram_b_data */
+	descbuf = cmd_insert_fifo_load(descbuf, pkin->b, pkin->b_siz,
+				       LDST_CLASS_1_CCB, 0, 0, 0,
+				       FIFOLD_TYPE_PK_B);
+
+	/* alg=8 type=pkha func=f2m_exp dest=b */
+	descbuf = cmd_insert_pkha_op(descbuf, OP_ALG_PKMODE_MOD_EXPO);
+
+	/* type=b len=8 d=#ram_exp_data */
+	descbuf = cmd_insert_fifo_store(descbuf, out, out_siz,
+					LDST_CLASS_1_CCB, 0, 0, 0,
+					FIFOST_TYPE_PKHA_B);
+
+	endidx = descbuf - start;
+	cmd_insert_hdr(start, 0, endidx, SHR_NEVER, SHRNXT_LENGTH,
+		       ORDER_FORWARD, DESC_STD);
+
+	*bufsz = endidx;
+	return 0;
+}
+
+/* FIXME: clear-written reg content should perhaps be defined in desc.h */
+static const u_int32_t clrw_imm = 0x00210000;
+
+
+/**
+ * Binary DSA-verify as a single job - cnstr_jobdesc_dsaverify()
+ *
+ * @descbuf - pointer to descriptor buffer for construction
+ * @bufsz - pointer to size of descriptor constructed (output)
+ * @dsadata - pointer to DSA parameters
+ * @msg - pointer to input message for verfication
+ * @msg_sz - size of message to verify
+ * @clear - clear buffer before writing descriptor
+ **/
+
+int cnstr_jobdesc_dsaverify(u_int32_t *descbuf, u_int16_t *bufsz,
+			    struct dsa_pdb *dsadata, u_int8_t *msg,
+			    u_int32_t msg_sz, u_int8_t clear)
+{
+	u_int32_t *start;
+	u_int16_t startidx, endidx;
+
+	start = descbuf++;
+	startidx = descbuf - start;
+
+	/* Build 9-word PDB with pointers to params */
+	memcpy(descbuf, dsadata, 9 * sizeof(u_int32_t));
+	descbuf += 9;
+
+	/* SHA1 hash command */
+	descbuf = cmd_insert_alg_op(descbuf, OP_TYPE_CLASS2_ALG,
+				    OP_ALG_ALGSEL_SHA1, OP_ALG_AAI_HASH,
+				    MDSTATE_COMPLETE, ICV_CHECK_OFF,
+				    DIR_DECRYPT);
+
+	/* FIFO load of message */
+	descbuf = cmd_insert_fifo_load(descbuf, msg, msg_sz,
+				LDST_CLASS_2_CCB, 0, 0, 0,
+				FIFOLD_TYPE_MSG | FIFOLD_TYPE_LAST2);
+
+	/* Store SHA-1 hash from context to f */
+	descbuf = cmd_insert_store(descbuf, dsadata->f, LDST_CLASS_2_CCB, 0,
+			    LDST_SRCDST_BYTE_CONTEXT, 0, 20, ITEM_REFERENCE);
+
+	/* Wait for CALM */
+	descbuf = cmd_insert_jump(descbuf, JUMP_TYPE_LOCAL, JUMP_TEST_ALL,
+				  JUMP_COND_CALM, 1, NULL);
+
+	/* LOAD immediate to clear-written register */
+	descbuf = cmd_insert_load(descbuf, (u_int32_t *)&clrw_imm, CLASS_NONE,
+				  0, LDST_SRCDST_WORD_CLRW, 0,
+				  sizeof(clrw_imm), ITEM_INLINE);
+
+	/* DSAVERIFY OP | decrypt private | ECC | Binary field */
+	descbuf = cmd_insert_proto_op_unidir(descbuf, OP_PCLID_DSAVERIFY,
+					     OP_PCL_PKPROT_DECRYPT |
+					     OP_PCL_PKPROT_ECC |
+					     OP_PCL_PKPROT_F2M);
+
+	/* Header, factor in PDB offset */
+	endidx = descbuf - start;
+	cmd_insert_hdr(start, startidx, endidx, SHR_NEVER, SHRNXT_LENGTH,
+		       ORDER_FORWARD, DESC_STD);
+
+	*bufsz = endidx;
+	return 0;
+}
diff --git a/drivers/crypto/caam/dcl/protoshared.c b/drivers/crypto/caam/dcl/protoshared.c
index dbf896e..70230cc 100644
--- a/drivers/crypto/caam/dcl/protoshared.c
+++ b/drivers/crypto/caam/dcl/protoshared.c
@@ -36,6 +36,77 @@
 #include "../compat.h"
 #include "dcl.h"
 
+/**
+ * Protocol-level shared descriptor constructors
+ *
+ * These build a full protocol-level shared descriptor for semi-autonomous
+ * processing of secured traffic through CAAM. Such descriptors function
+ * as single-pass processors (integrating cipher and authentication
+ * functions into a single logical step) with the added factor of
+ * performing protocol-level packet manipulation in the same step
+ * in the packet-handling process, by maintaining protocol-level
+ * connection state information within the descriptor itself.
+ *
+ * For each function, the arguments are uniform:
+ *
+ * Inputs:
+ *
+ *    * descbuf    = Points to a buffer to construct the descriptor in.
+ *                   All CAAM descriptors are built of an array of up to
+ *                   63 32-bit words. If the caller wishes to construct
+ *                   a descriptor directly in the executable buffer, then
+ *                   that buffer must be hardware DMA-able, and physically
+ *                   contiguous.
+ *
+ *    * bufsize    = Points to an unsigned 16-bit word with the max length
+ *                   of the buffer to hold the descriptor. This will be
+ *                   written back to with the actual size of the descriptor
+ *                   once constructed. (Note: bounds checking not yet
+ *                   implemented).
+ *
+ *    * pdb        = Points to a block of data (struct pdbcont) used to
+ *                   describe the content if the Protocol Data Block to be
+ *                   maintained inside the descriptor. PDB content is
+ *                   protocol and mode specific.
+ *
+ *    * cipherdata = Points to a block of data used to describe the cipher
+ *                   information for encryption/decryption of packet
+ *                   content:
+ *                   - algtype = one of CIPHER_TYPE_IPSEC_xxx
+ *                   - key     = pointer to the cipher key data
+ *                   - keydata = size of the key data in bits
+ *
+ *    * authdata   = Points to a block of data used to describe the
+ *                   authentication information for validating the
+ *                   authenticity of the packet source.
+ *                   - algtype = one of AUTH_TYPE_IPSEC_xxx
+ *                   - key     = pointer to the HMAC key data
+ *                   - keydata = size of the key data in bits
+ *
+ *    * clear      = If nonzero, buffer is cleared before writing
+ *
+ * Returns:
+ *
+ *    * -1 if the descriptor creation failed for any reason, zero
+ *      if creation succeeded.
+ *
+ */
+
+/*
+ * IPSec ESP CBC decapsulation case:
+ *
+ * pdb.opthdrlen      = Size of inbound header to skip over.
+ * pdb.transmode      = PDB_TUNNEL/PDB_TRANSPORT for tunnel or transport
+ *                      handling for the next header.
+ * pdb.pclvers        = PDB_IPV4/PDB_IPV6 as appropriate for this connection.
+ * pdb.seq.esn        = PDB_NO_ESN unless extended sequence numbers are to
+ *                      be supported, then PDB_INCLUDE_ESN.
+ * pdb.seq/antirplysz = PDB_ANTIRPLY_NONE if no antireplay window is to be
+ *                      maintained in the PDB. Otherwise may be
+ *                      PDB_ANTIRPLY_32 for a 32-entry window, or
+ *                      PDB_ANTIRPLY_64 for a 64-entry window.
+ *
+ **/
 int32_t cnstr_pcl_shdsc_ipsec_cbc_decap(u_int32_t           *descbuf,
 					u_int16_t           *bufsize,
 					struct pdbcont      *pdb,
@@ -144,6 +215,24 @@ int32_t cnstr_pcl_shdsc_ipsec_cbc_decap(u_int32_t           *descbuf,
 }
 EXPORT_SYMBOL(cnstr_pcl_shdsc_ipsec_cbc_decap);
 
+/**
+ * IPSec ESP CBC encapsulation case:
+ *
+ * pdbinfo.opthdrlen = Size of outbound IP header to be prepended to
+ *                     output.
+ * pdbinfo.opthdr    = Pointer to the IP header to be prepended to the
+ *                     output, of size opthdrlen.
+ * pdbinfo.transmode = PDB_TUNNEL/PDB_TRANSPORT for tunnel/transport
+ *                     handling for the next header.
+ * pdbinfo.pclvers   = PDB_IPV4/PDB_IPV6 as appropriate for this connection.
+ * pdbinfo.seq.esn   = PDB_NO_ESN unless extended sequence numbers are to
+ *                     be supported, then PDB_INCLUDE_ESN.
+ * pdbinfo.ivsrc     = PDB_IV_FROM_PDB if the IV is to be maintained in
+ *                     the PDB, else PDB_IV_FROM_RNG if the IV is to
+ *                     be generated internally by CAAM's random number
+ *                     generator.
+ *
+ **/
 int32_t cnstr_pcl_shdsc_ipsec_cbc_encap(u_int32_t           *descbuf,
 					u_int16_t           *bufsize,
 					struct pdbcont      *pdb,
@@ -257,3 +346,914 @@ int32_t cnstr_pcl_shdsc_ipsec_cbc_encap(u_int32_t           *descbuf,
 	return 0;
 }
 EXPORT_SYMBOL(cnstr_pcl_shdsc_ipsec_cbc_encap);
+
+/**
+ * 802.16 WiMAX encapsulation
+ *
+ * @descbuf - Pointer to descriptor build buffer
+ *
+ * @bufsize - Pointer to value to write size of built descriptor to
+ *
+ * @pdb.framecheck - nonzero if frame check word to be included
+ * @pdb.nonce - Nonce to use
+ * @pdb.b0_flags - B0 flags
+ * @pdb.ctr_flags - CTR flags
+ * @pdb.PN - PN value
+ *
+ * @cipherdata.keylen - key size in bytes
+ * @cipherdata.key - key data to inline
+ *
+ * @mode - nonzero for OFDMa, else OFDM
+ *
+ * @clear - nonzero clears descriptor buffer
+ *
+ **/
+int32_t cnstr_shdsc_wimax_encap(u_int32_t *descbuf, u_int16_t *bufsize,
+				struct wimax_pdb *pdb,
+				struct cipherparams *cipherdata,
+				u_int8_t mode, u_int8_t clear)
+{
+	u_int32_t pdbopts;
+	u_int32_t *start;
+	u_int16_t startidx, endidx;
+
+	start = descbuf++;
+
+	if (!descbuf)
+		return -1;
+
+	if (clear)
+		memset(start, 0, (*bufsize * sizeof(u_int32_t)));
+
+	/*
+	 * Construct encap PDB
+	 * u24 - (reserved)
+	 * u8  - options
+	 * u32 - nonce
+	 * u8  - b0 flags
+	 * u8  - counter flags
+	 * u16 - counter init
+	 * u32 - PN
+	 */
+
+	/* options word */
+	if (pdb->framecheck)
+		pdbopts = 1;
+	*descbuf++ = pdbopts;
+
+	/* Nonce */
+	pdbopts = pdb->nonce;
+	*descbuf++ = pdbopts;
+
+	/* B0 flags / CTR flags / initial counter */
+	pdbopts = (pdb->b0_flags << 24) | (pdb->ctr_flags << 16) |
+		  pdb->ctr_initial_count;
+	*descbuf++ = pdbopts;
+
+	/* PN word */
+	pdbopts = pdb->PN;
+	*descbuf++ = pdbopts;
+
+	/* Done with PDB, build AES-CTR key block */
+	startidx = descbuf - start;
+
+	descbuf = cmd_insert_key(descbuf, cipherdata->key, cipherdata->keylen,
+				 PTR_DIRECT, KEYDST_KEYREG, KEY_CLEAR,
+				 ITEM_INLINE, ITEM_CLASS1);
+
+	/* end with OPERATION */
+	descbuf = cmd_insert_proto_op_wimax(descbuf, mode, DIR_ENCAP);
+
+	/* Now compute shared header */
+	endidx = descbuf - start + 1;
+	cmd_insert_shared_hdr(start, startidx, endidx, CTX_ERASE, SHR_SERIAL);
+	*bufsize = endidx;
+
+	return 0;
+}
+EXPORT_SYMBOL(cnstr_shdsc_wimax_encap);
+
+/**
+ * 802.16 WiMAX decapsulation
+ *
+ * @descbuf - Pointer to descriptor build buffer
+ *
+ * @bufsize - Pointer to value to write size of built descriptor to
+ *
+ * @pdb.framecheck - nonzero if frame check word to be included
+ * @pdb.nonce - Nonce to use
+ * @pdb.iv_flags - IV flags
+ * @pdb.ctr_flags - counter flags
+ * @pdb.ctr_initial_count - counter value
+ * @pdb.PN - PN value
+ * @pdb.antireplay_len - length of antireplay window
+ *
+ * @cipherdata.keylen - key size in bytes
+ * @cipherdata.key - key data to inline
+ *
+ * @mode - nonzero for OFDMa, else OFDM
+ *
+ * @clear - nonzero clears descriptor buffer
+ **/
+
+int32_t cnstr_shdsc_wimax_decap(u_int32_t *descbuf, u_int16_t *bufsize,
+				struct wimax_pdb *pdb,
+				struct cipherparams *cipherdata,
+				u_int8_t mode, u_int8_t clear)
+{
+	u_int32_t pdbopts;
+	u_int32_t *start;
+	u_int16_t startidx, endidx;
+
+	start = descbuf++;
+
+	if (!descbuf)
+		return -1;
+
+	if (clear)
+		memset(start, 0, (*bufsize * sizeof(u_int32_t)));
+
+	/*
+	 * Construct decap PDB
+	 * u24 - (reserved)
+	 * u8  - options
+	 * u32 - nonce
+	 * u8  - IV flags
+	 * u8  - counter flags
+	 * u16 - counter init
+	 * u32 - PN
+	 * u16 - (reserved)
+	 * u16 - antireplay length
+	 * u64 - antireplay scorecard
+	 */
+
+	/* options word */
+	if (pdb->framecheck)
+		pdbopts = 1;
+	if (pdb->antireplay_len)
+		pdbopts |= 0x40;
+	*descbuf++ = pdbopts;
+
+	/* Nonce */
+	pdbopts = pdb->nonce;
+	*descbuf++ = pdbopts;
+
+	/* IV flags / CTR flags / initial counter */
+	pdbopts = (pdb->iv_flags << 24) | (pdb->ctr_flags << 16) |
+		  pdb->ctr_initial_count;
+	*descbuf++ = pdbopts;
+
+	/* PN word */
+	pdbopts = pdb->PN;
+	*descbuf++ = pdbopts;
+
+	/* Antireplay */
+	pdbopts = pdb->antireplay_len;
+	*descbuf++ = pdbopts; /* write length */
+	memset(descbuf, 0, 8);
+	descbuf += 2;
+
+	/* Done with PDB, build key block */
+	startidx = descbuf - start;
+
+	descbuf = cmd_insert_key(descbuf, cipherdata->key, cipherdata->keylen,
+				 PTR_DIRECT, KEYDST_KEYREG, KEY_CLEAR,
+				 ITEM_INLINE, ITEM_CLASS1);
+
+	/* end with OPERATION */
+	descbuf = cmd_insert_proto_op_wimax(descbuf, mode, DIR_DECAP);
+
+	/* Now compute shared header */
+	endidx = descbuf - start + 1;
+	cmd_insert_shared_hdr(start, startidx, endidx, CTX_ERASE, SHR_SERIAL);
+	*bufsize = endidx;
+
+	return 0;
+}
+EXPORT_SYMBOL(cnstr_shdsc_wimax_decap);
+
+/**
+ * MacSec encapsulation
+ *
+ * @descbuf - Pointer to descriptor build buffer
+ *
+ * @bufsize - Pointer to value to write size of built descriptor to
+ *
+ * pdb.framecheck - nonzero if frame-check-sequence is to be
+ *                  included in the output
+ * pdb.aad_len - length of AAD to include
+ * pdb.sci - SCI, if to be included
+ * pdb.PN - packet number
+ * pdb.ethertype - 16 bit ethertype to include
+ * pdb.tci_an - TCI/AN byte
+ *
+ * @cipherdata.keylen - key size in bytes
+ * @cipherdata.key - key data to inline
+ *
+ * @clear - nonzero clears descriptor buffer
+ **/
+
+int32_t cnstr_shdsc_macsec_encap(u_int32_t *descbuf, u_int16_t *bufsize,
+				 struct macsec_pdb *pdb,
+				 struct cipherparams *cipherdata,
+				 u_int8_t clear)
+{
+	u_int32_t pdbopts;
+	u_int32_t *start;
+	u_int16_t startidx, endidx;
+
+	start = descbuf++;
+
+	if (!descbuf)
+		return -1;
+
+	if (clear)
+		memset(start, 0, (*bufsize * sizeof(u_int32_t)));
+
+	/* options word */
+	pdbopts = pdb->aad_len >> 16;
+	if (pdb->framecheck)
+		pdbopts |= 1;
+	*descbuf++ = pdbopts;
+
+	/* SCI */
+	memcpy(descbuf, &pdb->sci, 8);
+	descbuf += 2;
+
+	pdbopts = (pdb->ethertype << 16) | (pdb->tci_an << 8);
+	*descbuf++ = pdbopts;
+
+	/* PN word */
+	pdbopts = pdb->PN;
+	*descbuf++ = pdbopts;
+
+	/* Done with PDB, build key block */
+	startidx = descbuf - start;
+
+	descbuf = cmd_insert_key(descbuf, cipherdata->key, cipherdata->keylen,
+				 PTR_DIRECT, KEYDST_KEYREG, KEY_CLEAR,
+				 ITEM_INLINE, ITEM_CLASS1);
+
+	/* end with OPERATION */
+	descbuf = cmd_insert_proto_op_macsec(descbuf, DIR_ENCAP);
+
+	/* Now compute shared header */
+	endidx = descbuf - start + 1;
+	cmd_insert_shared_hdr(start, startidx, endidx, CTX_ERASE, SHR_SERIAL);
+	*bufsize = endidx;
+
+	return 0;
+}
+EXPORT_SYMBOL(cnstr_shdsc_macsec_encap);
+
+/**
+ * MacSec decapsulation
+ *
+ * @descbuf - Pointer to descriptor build buffer
+ *
+ * @bufsize - Pointer to value to write size of built descriptor to
+ *
+ * pdb.framecheck - nonzero if frame-check-sequence is on
+ * pdb.aad_len - length of AAD used
+ * pdb.sci - SCI, if to be used
+ * pdb.PN - packet number
+ * pdb.ethertype - 16 bit ethertype
+ * pdb.tci_an - TCI/AN byte
+ * pdb.antireplay_len - antireplay length
+ *
+ * @cipherdata.keylen - key size in bytes
+ * @cipherdata.key - key data to inline
+ *
+ * @clear - nonzero clears descriptor buffer
+ **/
+int32_t cnstr_shdsc_macsec_decap(u_int32_t *descbuf, u_int16_t *bufsize,
+				 struct macsec_pdb *pdb,
+				 struct cipherparams *cipherdata,
+				 u_int8_t clear)
+{
+	u_int32_t pdbopts;
+	u_int32_t *start;
+	u_int16_t startidx, endidx;
+
+	start = descbuf++;
+
+	if (!descbuf)
+		return -1;
+
+	if (clear)
+		memset(start, 0, (*bufsize * sizeof(u_int32_t)));
+
+	/* options word */
+	pdbopts = pdb->aad_len >> 16;
+	if (pdb->framecheck)
+		pdbopts |= 1;
+	if (pdb->antireplay_len)
+		pdbopts |= 0x40;
+	*descbuf++ = pdbopts;
+
+	/* SCI */
+	memcpy(descbuf, &pdb->sci, 8);
+	descbuf += 2;
+
+	/* antireplay length */
+	pdbopts = pdb->antireplay_len;
+	*descbuf++ = pdbopts;
+
+	/* PN word */
+	pdbopts = pdb->PN;
+	*descbuf++ = pdbopts;
+
+	/* antireplay scorecard */
+	memset(descbuf, 0, 8);
+	descbuf += 2;
+
+	/* Done with PDB, build key block */
+	startidx = descbuf - start;
+
+	descbuf = cmd_insert_key(descbuf, cipherdata->key, cipherdata->keylen,
+				 PTR_DIRECT, KEYDST_KEYREG, KEY_CLEAR,
+				 ITEM_INLINE, ITEM_CLASS1);
+
+	/* end with OPERATION */
+	descbuf = cmd_insert_proto_op_macsec(descbuf, DIR_DECAP);
+
+	/* Now compute shared header */
+	endidx = descbuf - start + 1;
+	cmd_insert_shared_hdr(start, startidx, endidx, CTX_ERASE, SHR_SERIAL);
+	*bufsize = endidx;
+
+	return 0;
+}
+EXPORT_SYMBOL(cnstr_shdsc_macsec_decap);
+
+/**
+ * SNOW/f8 (UEA2) as a shared descriptor
+ *
+ * @descbuf - pointer to descriptor-under-construction buffer
+ * @bufsize - points to size to be updated at completion
+ * @key - cipher key
+ * @keylen - size of key in bits
+ * @dir - cipher direction (DIR_ENCRYPT/DIR_DECRYPT)
+ * @count - UEA2 count value (32 bits)
+ * @bearer - UEA2 bearer ID (5 bits)
+ * @direction - UEA2 direction (1 bit)
+ * @clear - nonzero if descriptor buffer clear requested
+ **/
+
+int32_t cnstr_shdsc_snow_f8(u_int32_t *descbuf, u_int16_t *bufsize,
+			    u_int8_t *key, u_int32_t keylen,
+			    enum algdir dir, u_int32_t count,
+			    u_int8_t bearer, u_int8_t direction,
+			    u_int8_t clear)
+{
+	u_int32_t *start;
+	u_int16_t startidx, endidx;
+	u_int32_t mval;
+
+	u_int64_t COUNT       = count;
+	u_int64_t BEARER      = bearer;
+	u_int64_t DIRECTION   = direction;
+
+	u_int64_t context = (COUNT << 32) | (BEARER << 27) | (DIRECTION << 26);
+
+	start = descbuf++; /* save start for eventual header write */
+
+	/* Verify a clean buffer */
+	if (!descbuf)
+		return -1;
+
+	/* If user requested a buffer clear, do it from the start */
+	if (clear)
+		memset(start, 0, (*bufsize * sizeof(u_int32_t)));
+
+	/* Save current location for computing start index */
+	startidx = descbuf - start;
+
+	descbuf = cmd_insert_key(descbuf, key, keylen, PTR_DIRECT,
+				 KEYDST_KEYREG, KEY_CLEAR, ITEM_INLINE,
+				 ITEM_CLASS1);
+
+	mval = 0;
+	descbuf = cmd_insert_math(descbuf, MATH_FUN_SUB, MATH_SRC0_SEQINLEN,
+				  MATH_SRC1_REG2, MATH_DEST_VARSEQINLEN,
+				  4, 0, 0, 0, &mval);
+
+	descbuf = cmd_insert_math(descbuf, MATH_FUN_SUB, MATH_SRC0_SEQINLEN,
+				  MATH_SRC1_REG2, MATH_DEST_VARSEQOUTLEN,
+				  4, 0, 0, 0, &mval);
+
+	descbuf = cmd_insert_alg_op(descbuf, OP_TYPE_CLASS1_ALG,
+				    OP_ALG_ALGSEL_SNOW, OP_ALG_AAI_F8,
+				    MDSTATE_COMPLETE, ICV_CHECK_OFF, dir);
+
+	descbuf = cmd_insert_load(descbuf, &context, LDST_CLASS_1_CCB,
+				  0, LDST_SRCDST_BYTE_CONTEXT, 0, 8,
+				  ITEM_INLINE);
+
+	descbuf = cmd_insert_seq_fifo_load(descbuf, LDST_CLASS_1_CCB,
+					   FIFOLDST_VLF,
+					   (FIFOLD_TYPE_MSG |
+					   FIFOLD_TYPE_LASTBOTH), 32);
+
+	descbuf = cmd_insert_seq_fifo_store(descbuf, LDST_CLASS_1_CCB,
+					    FIFOLDST_VLF,
+					    FIFOST_TYPE_MESSAGE_DATA, 32);
+
+	/* Now update the header with size/offsets */
+	endidx = descbuf - start;
+
+	cmd_insert_shared_hdr(start, startidx, endidx, CTX_ERASE, SHR_ALWAYS);
+
+	*bufsize = endidx;
+
+	return 0;
+}
+EXPORT_SYMBOL(cnstr_shdsc_snow_f8);
+
+/**
+ * SNOW/f9 (UIA2) as a shared descriptor
+ *
+ * @descbuf - pointer to descriptor-under-construction buffer
+ * @bufsize - points to size to be updated at completion
+ * @key - cipher key
+ * @keylen - size of key in bits
+ * @dir - cipher direction (DIR_ENCRYPT/DIR_DECRYPT)
+ * @count - UEA2 count value (32 bits)
+ * @fresh - UEA2 fresh value ID (32 bits)
+ * @direction - UEA2 direction (1 bit)
+ * @clear - nonzero if descriptor buffer clear requested
+ **/
+
+int32_t cnstr_shdsc_snow_f9(u_int32_t *descbuf, u_int16_t *bufsize,
+			    u_int8_t *key, u_int32_t keylen,
+			    enum algdir dir, u_int32_t count,
+			    u_int32_t fresh, u_int8_t direction,
+			    u_int8_t clear)
+{
+	u_int32_t *start;
+	u_int16_t startidx, endidx;
+	u_int32_t mval;
+
+	u_int64_t ct = count;
+	u_int64_t fr = fresh;
+	u_int64_t dr = direction;
+
+	u_int64_t context[2];
+
+	context[0] = (ct << 32) | (dr << 26);
+	context[1] = fr;
+
+	start = descbuf++; /* header skip */
+
+	if (!descbuf)
+		return -1;
+
+	/* buffer clear */
+	if (clear)
+		memset(start, 0, (*bufsize * sizeof(u_int32_t)));
+
+	startidx = descbuf - start;
+
+	descbuf = cmd_insert_key(descbuf, key, keylen, PTR_DIRECT,
+				 KEYDST_KEYREG, KEY_CLEAR, ITEM_INLINE,
+				 ITEM_CLASS1);
+
+	/* compute sequences */
+	mval = 0;
+	descbuf = cmd_insert_math(descbuf, MATH_FUN_SUB, MATH_SRC0_SEQINLEN,
+				  MATH_SRC1_REG2, MATH_DEST_VARSEQINLEN,
+				  4, 0, 0, 0, &mval);
+
+	descbuf = cmd_insert_alg_op(descbuf, OP_TYPE_CLASS1_ALG,
+				    OP_ALG_ALGSEL_SNOW, OP_ALG_AAI_F9,
+				    MDSTATE_COMPLETE, ICV_CHECK_OFF, dir);
+
+	descbuf = cmd_insert_load(descbuf, &context, LDST_CLASS_1_CCB,
+				  0, LDST_SRCDST_BYTE_CONTEXT, 0, 16,
+				  ITEM_INLINE);
+
+	descbuf = cmd_insert_seq_fifo_load(descbuf, LDST_CLASS_1_CCB,
+					   FIFOLDST_VLF,
+					   (FIFOLD_TYPE_MSG |
+					   FIFOLD_TYPE_LASTBOTH), 0);
+
+	/* Save lower half of MAC out into a 32-bit sequence */
+	descbuf = cmd_insert_seq_store(descbuf, LDST_CLASS_1_CCB, 0,
+				       LDST_SRCDST_BYTE_CONTEXT, 4, 4);
+
+	endidx = descbuf - start;
+
+	cmd_insert_shared_hdr(start, startidx, endidx, CTX_ERASE, SHR_ALWAYS);
+
+	*bufsize = endidx;
+
+	return 0;
+}
+EXPORT_SYMBOL(cnstr_shdsc_snow_f9);
+
+
+
+/**
+ * CBC blockcipher
+ * @descbuf - descriptor buffer
+ * @bufsize - limit/returned descriptor buffer size
+ * @key     - key data to inline
+ * @keylen  - key length
+ * @iv      - iv data
+ * @ivsize  - iv length
+ * @dir     - DIR_ENCRYPT/DIR_DECRYPT
+ * @cipher  - OP_ALG_ALGSEL_AES/DES/3DES
+ * @clear   - clear buffer before writing
+ **/
+
+int32_t cnstr_shdsc_cbc_blkcipher(u_int32_t *descbuf, u_int16_t *bufsize,
+				  u_int8_t *key, u_int32_t keylen,
+				  u_int8_t *iv, u_int32_t ivlen,
+				  enum algdir dir, u_int32_t cipher,
+				  u_int8_t clear)
+{
+	u_int32_t *start;
+	u_int16_t startidx, endidx;
+	u_int32_t mval;
+
+	start = descbuf++; /* save start for eventual header write */
+
+	if (!descbuf)
+		return -1;
+
+	if (clear)
+		memset(start, 0, (*bufsize * sizeof(u_int32_t)));
+
+	startidx = descbuf - start;
+
+	/* Insert Key */
+	descbuf = cmd_insert_key(descbuf, key, keylen, PTR_DIRECT,
+				 KEYDST_KEYREG, KEY_CLEAR, ITEM_INLINE,
+				 ITEM_CLASS1);
+
+	/* Compute variable sequence */
+	mval = 0;
+	descbuf = cmd_insert_math(descbuf, MATH_FUN_SUB, MATH_SRC0_SEQINLEN,
+				  MATH_SRC1_REG2, MATH_DEST_VARSEQINLEN,
+				  4, 0, 0, 0, &mval);
+
+	descbuf = cmd_insert_math(descbuf, MATH_FUN_SUB, MATH_SRC0_SEQINLEN,
+				  MATH_SRC1_REG2, MATH_DEST_VARSEQOUTLEN,
+				  4, 0, 0, 0, &mval);
+
+	/* Set cipher, AES/DES/3DES */
+	descbuf = cmd_insert_alg_op(descbuf, OP_TYPE_CLASS1_ALG, cipher,
+				    OP_ALG_AAI_CBC, MDSTATE_INIT,
+				    ICV_CHECK_OFF, dir);
+
+	/* IV load, convert size */
+	descbuf = cmd_insert_load(descbuf, iv, LDST_CLASS_1_CCB,
+				  0, LDST_SRCDST_BYTE_CONTEXT, 0, (ivlen >> 3),
+				  ITEM_INLINE);
+
+	/* Insert sequence load/store with VLF */
+	descbuf = cmd_insert_seq_fifo_load(descbuf, LDST_CLASS_1_CCB,
+					   FIFOLDST_VLF,
+					   (FIFOLD_TYPE_MSG |
+					   FIFOLD_TYPE_LASTBOTH), 32);
+
+	descbuf = cmd_insert_seq_fifo_store(descbuf, LDST_CLASS_1_CCB,
+					    FIFOLDST_VLF,
+					    FIFOST_TYPE_MESSAGE_DATA, 32);
+
+	/* Now update the header with size/offsets */
+	endidx = descbuf - start;
+	cmd_insert_shared_hdr(start, startidx, endidx, CTX_ERASE, SHR_ALWAYS);
+
+	*bufsize = endidx;
+
+	return 0;
+}
+EXPORT_SYMBOL(cnstr_shdsc_cbc_blkcipher);
+
+/**
+ * HMAC shared
+ * @descbuf - descriptor buffer
+ * @bufsize - limit/returned descriptor buffer size
+ * @key     - key data to inline (length based on cipher)
+ * @cipher  - OP_ALG_ALGSEL_MD5/SHA1-512
+ * @icv     - HMAC comparison for ICV, NULL if no check desired
+ * @clear   - clear buffer before writing
+ **/
+
+int32_t cnstr_shdsc_hmac(u_int32_t *descbuf, u_int16_t *bufsize,
+			 u_int8_t *key, u_int32_t cipher, u_int8_t *icv,
+			 u_int8_t clear)
+{
+	u_int32_t *start;
+	u_int16_t startidx, endidx;
+	u_int32_t mval;
+	u_int8_t storelen;
+	enum icvsel opicv;
+
+	start = descbuf++;
+
+	if (!descbuf)
+		return -1;
+
+	if (clear)
+		memset(start, 0, (*bufsize * sizeof(u_int32_t)));
+
+	/* Compute fixed-size store based on alg selection */
+	switch (cipher) {
+	case OP_ALG_ALGSEL_MD5:
+		storelen = 16;
+		break;
+
+	case OP_ALG_ALGSEL_SHA1:
+		storelen = 20;
+		break;
+
+	case OP_ALG_ALGSEL_SHA224:
+		storelen = 28;
+		break;
+
+	case OP_ALG_ALGSEL_SHA256:
+		storelen = 32;
+		break;
+
+	case OP_ALG_ALGSEL_SHA384:
+		storelen = 48;
+
+	case OP_ALG_ALGSEL_SHA512:
+		storelen = 64;
+
+	default:
+		return -1;
+	}
+
+	if (icv != NULL)
+		opicv = ICV_CHECK_ON;
+	else
+		opicv = ICV_CHECK_OFF;
+
+
+	startidx = descbuf - start;
+
+	descbuf = cmd_insert_key(descbuf, key, storelen * 8, PTR_DIRECT,
+				 KEYDST_KEYREG, KEY_CLEAR, ITEM_INLINE,
+				 ITEM_CLASS2);
+
+	/* compute sequences */
+	mval = 0;
+	descbuf = cmd_insert_math(descbuf, MATH_FUN_SUB, MATH_SRC0_SEQINLEN,
+				  MATH_SRC1_REG2, MATH_DEST_VARSEQINLEN,
+				  4, 0, 0, 0, &mval);
+
+	descbuf = cmd_insert_math(descbuf, MATH_FUN_SUB, MATH_SRC0_SEQINLEN,
+				  MATH_SRC1_REG2, MATH_DEST_VARSEQOUTLEN,
+				  4, 0, 0, 0, &mval);
+
+	/* Do operation */
+	descbuf = cmd_insert_alg_op(descbuf, OP_TYPE_CLASS2_ALG, cipher,
+				    OP_ALG_AAI_HMAC, MDSTATE_COMPLETE,
+				    opicv, DIR_ENCRYPT);
+
+	/* Do load (variable length) */
+	descbuf = cmd_insert_seq_fifo_load(descbuf, LDST_CLASS_2_CCB,
+					   FIFOLDST_VLF,
+					   (FIFOLD_TYPE_MSG |
+					   FIFOLD_TYPE_LASTBOTH), 32);
+
+	descbuf = cmd_insert_seq_store(descbuf, LDST_CLASS_2_CCB, 0,
+				       LDST_SRCDST_BYTE_CONTEXT, 0, storelen);
+
+	endidx = descbuf - start;
+
+	cmd_insert_shared_hdr(start, startidx, endidx, CTX_ERASE, SHR_ALWAYS);
+
+	*bufsize = endidx;
+
+	return 0;
+}
+EXPORT_SYMBOL(cnstr_shdsc_hmac);
+
+/**
+ * 3GPP RLC decapsulation - cnstr_pcl_shdsc_3gpp_rlc_decap()
+ *
+ * @descbuf - pointer to buffer for descriptor construction
+ * @bufsize - size of descriptor written
+ * @key - f8 cipher key
+ * @keysz - size of cipher key
+ * @count - f8 count value
+ * @bearer - f8 bearer value
+ * @direction - f8 direction value
+ * @payload_sz - size of payload (this is not using VLF)
+ * @clear - clear descriptor buffer before construction
+ **/
+
+/* FIXME: these should be built from bit defs not yet present in desc.h */
+static const u_int32_t rlc_fifo_cmd[] = {
+	/* IFIFO dest=skip,flush,stype=DFIFO,dtype=msg,len=3 */
+	0x04F00003u,
+	 /* IFIFO dest=skip,flush,stype=DFIFO,dtype=msg,len=80 */
+	0x04F00050u,
+	/* IFIFO dest=class1,last1,flush1,stype=DFIFO,dtype=msg,len=80 */
+	0x54F00050u
+};
+
+static const u_int32_t rlc_segnum_mask[] = {
+	0x00000fff,
+	0x00000000
+};
+
+/* misc values for adding immediates to math/move/load/etc. */
+static const u_int32_t cmd_imm_src[] = {
+	0, 1, 19, 16, 4, 60, 8
+};
+
+static const u_int8_t jump_imm_src[] = {
+	-10
+};
+
+int32_t cnstr_pcl_shdsc_3gpp_rlc_decap(u_int32_t *descbuf, u_int16_t *bufsize,
+				       u_int8_t *key, u_int32_t keysz,
+				       u_int32_t count, u_int32_t bearer,
+				       u_int32_t direction,
+				       u_int32_t payload_sz, u_int8_t clear)
+{
+	u_int32_t *start;
+	u_int16_t startidx, endidx;
+	u_int32_t kctx[2];
+
+	start = descbuf++;
+
+	if (!descbuf)
+		return -1;
+
+
+	/* build count/bearer/direction as register-loadable words */
+	kctx[0] = count;
+	kctx[1] = ((bearer & 0x1f) << 27) | ((direction & 0x01) << 26);
+
+	startidx = descbuf - start;
+
+	/* Key */
+	descbuf = cmd_insert_key(descbuf, key, keysz, PTR_DIRECT, KEYDST_KEYREG,
+				 KEY_CLEAR, ITEM_REFERENCE, ITEM_CLASS1);
+
+	/* load DCTRL - disable auto Info FIFO entries */
+	descbuf = cmd_insert_load(descbuf, NULL, LDST_CLASS_DECO, 0,
+				  LDST_SRCDST_WORD_DECOCTRL, 0x08, 0x00,
+				  ITEM_INLINE);
+
+	/* get encrypted RLC PDU w/header */
+	descbuf = cmd_insert_seq_fifo_load(descbuf, LDST_CLASS_1_CCB, 0,
+					   FIFOLD_TYPE_MSG | FIFOLD_TYPE_LAST1,
+					   83);
+
+	/* load imm Info FIFO */
+	descbuf = cmd_insert_load(descbuf, (u_int32_t *)&rlc_fifo_cmd[1],
+				  LDST_CLASS_DECO, 0,
+				  LDST_SRCDST_WORD_INFO_FIFO, 0, 8,
+				  ITEM_INLINE);
+
+	/* load imm Info FIFO */
+	descbuf = cmd_insert_load(descbuf, (u_int32_t *)&rlc_fifo_cmd[2],
+				  LDST_CLASS_DECO, 0,
+				  LDST_SRCDST_WORD_INFO_FIFO, 0, 8,
+				  ITEM_INLINE);
+
+	/* load imm MATH0 */
+	descbuf = cmd_insert_load(descbuf, kctx, LDST_CLASS_DECO, 0,
+				  LDST_SRCDST_WORD_DECO_MATH0, 0, 8,
+				  ITEM_INLINE);
+
+	/* add imm: IFIFO + 0 -> MATH1 (3B from InfoFIFO) */
+	descbuf = cmd_insert_math(descbuf, MATH_FUN_ADD, MATH_SRC0_IMM,
+				  MATH_SRC1_INFIFO, MATH_DEST_REG0, 8, 0, 0,
+				  MATH_IFB, (u_int32_t *)&cmd_imm_src[0]);
+
+	/* shl imm: MATH1 << 4 -> MATH1 (left-align RLC PDU header) */
+	descbuf = cmd_insert_math(descbuf, MATH_FUN_ADD, MATH_SRC0_REG0,
+				  MATH_SRC1_IMM, MATH_DEST_REG1, 8, 0, 0,
+				  MATH_IFB, (u_int32_t *)&cmd_imm_src[1]);
+
+	/* MATH1 (2B PDU) -> OFIFO (8 bytes get moved) */
+	descbuf = cmd_insert_move(descbuf, 0, MOVE_SRC_MATH1,
+				  MOVE_DEST_OUTFIFO, 0, 2);
+
+	/* Store 2-byte PDU header */
+	descbuf = cmd_insert_seq_fifo_store(descbuf, LDST_CLASS_IND_CCB, 0,
+					    FIFOST_TYPE_MESSAGE_DATA, 2);
+
+	/* wait for DMA CALM */
+	descbuf = cmd_insert_jump(descbuf, JUMP_TYPE_LOCAL, JUMP_TEST_ALL,
+				  JUMP_COND_CALM, 1, NULL);
+
+	/* DCTRL - reset OFIFO to flush extra 6 bytes */
+	descbuf = cmd_insert_load(descbuf, NULL, LDST_CLASS_DECO, 0,
+				  LDST_SRCDST_WORD_DECOCTRL, 0, 32,
+				  ITEM_INLINE);
+
+	/* shr imm MATH1 -> MATH2 (align seqnum with PPDB data) */
+	descbuf = cmd_insert_math(descbuf, MATH_FUN_RSHIFT, MATH_SRC0_REG1,
+				  MATH_SRC1_IMM, MATH_DEST_REG2, 8, 0, 0,
+				  MATH_IFB, (u_int32_t *)&cmd_imm_src[2]);
+
+	/* mask Math2 to isolate seqnum */
+	descbuf = cmd_insert_math(descbuf, MATH_FUN_AND, MATH_SRC0_REG2,
+				  MATH_SRC1_IMM, MATH_DEST_REG2, 8, 0, 0, 0,
+				  (u_int32_t *)rlc_segnum_mask);
+
+	/* add seqnum to PPDB data */
+	descbuf = cmd_insert_math(descbuf, MATH_FUN_ADD, MATH_SRC0_REG0,
+				  MATH_SRC1_REG2, MATH_DEST_REG1, 8, 0, 0,
+				  0, NULL);
+
+	/* MATH0 (PPDB data) -> CTX1 */
+	descbuf = cmd_insert_move(descbuf, 0, MOVE_SRC_MATH0,
+				  MOVE_DEST_CLASS1CTX, 0, 8);
+
+	/* shl imm: MATH1 << 16 -> MATH1 (4 bits left) */
+	descbuf = cmd_insert_math(descbuf, MATH_FUN_LSHIFT, MATH_SRC0_REG1,
+				  MATH_SRC1_IMM, MATH_DEST_REG1, 8, 0, 0,
+				  0, (u_int32_t *)&cmd_imm_src[3]);
+
+	/* load imm MATH3 */
+	descbuf = cmd_insert_load(descbuf, &payload_sz, LDST_CLASS_DECO,
+				  0, LDST_SRCDST_WORD_DECO_MATH3, 0, 4,
+				  ITEM_INLINE);
+
+	/* add imm: IFIFO (next 8B of payload) + 0 -> MATH2 */
+	descbuf = cmd_insert_math(descbuf, MATH_FUN_ADD, MATH_SRC0_IMM,
+				  MATH_SRC1_INFIFO, MATH_DEST_REG2,
+				  8, 0, 0, 0, (u_int32_t *)&cmd_imm_src[0]);
+
+	/* shr imm: Math2 >> 4 -> MATH0 */
+	descbuf = cmd_insert_math(descbuf, MATH_FUN_RSHIFT, MATH_SRC0_REG2,
+				  MATH_SRC1_IMM, MATH_DEST_REG0,
+				  8, 0, 0, 0, (u_int32_t *)&cmd_imm_src[4]);
+
+	/* or: MATH0 (60 lsbs) | MATH1 (4 msbs) -> MATH1 */
+	descbuf = cmd_insert_math(descbuf, MATH_FUN_OR, MATH_SRC0_REG0,
+				  MATH_SRC1_REG1, MATH_DEST_REG1, 8, 0, 0, 0,
+				  NULL);
+
+	/* MATH1 -> IFIFO */
+	descbuf = cmd_insert_move(descbuf, 0, MOVE_SRC_MATH1,
+				  MOVE_DEST_CLASS1INFIFO, 0, 8);
+
+	/* shl imm: MATH2 << 60 -> MATH1 */
+	descbuf = cmd_insert_math(descbuf, MATH_FUN_LSHIFT, MATH_SRC0_REG2,
+				  MATH_SRC1_IMM, MATH_DEST_REG1, 8, 0, 0, 0,
+				  (u_int32_t *)&cmd_imm_src[5]);
+
+	/* dec MATH3 by 8 (number of bytes loaded) */
+	descbuf = cmd_insert_math(descbuf, MATH_FUN_SUB, MATH_SRC0_REG3,
+				  MATH_SRC1_IMM, MATH_DEST_REG3, 8, 0, 0,
+				  MATH_IFB, (u_int32_t *)&cmd_imm_src[6]);
+
+	/* jump back to L1 if MATH3 counter indicates more data */
+	descbuf = cmd_insert_jump(descbuf, JUMP_TYPE_LOCAL, JUMP_TEST_ALL,
+				  JUMP_COND_MATH_NV | JUMP_COND_MATH_Z,
+				  jump_imm_src[0], NULL);
+
+	/* load Class1 Data Size (exec before InfoFIFO entry made w/last1) */
+	descbuf = cmd_insert_load(descbuf, &payload_sz, LDST_CLASS_1_CCB,
+				  0, LDST_SRCDST_WORD_DATASZ_REG, 0, 4,
+				  ITEM_INLINE);
+
+	/* load Info FIFO */
+	descbuf = cmd_insert_load(descbuf, (u_int32_t *)&rlc_fifo_cmd[3],
+				  LDST_CLASS_DECO, 0,
+				  LDST_SRCDST_WORD_INFO_FIFO, 0, 4,
+				  ITEM_INLINE);
+
+	/* operation KFHA f8 initfinal */
+	descbuf = cmd_insert_alg_op(descbuf, OP_TYPE_CLASS1_ALG,
+				    OP_ALG_ALGSEL_KASUMI, OP_ALG_AAI_F8,
+				    OP_ALG_AS_INITFINAL, ICV_CHECK_OFF,
+				    DIR_ENCRYPT);
+
+	/* store msg */
+	descbuf = cmd_insert_seq_fifo_store(descbuf, LDST_CLASS_1_CCB, 0,
+					    FIFOST_TYPE_MESSAGE_DATA,
+					    payload_sz);
+
+	/* wait for CLASS1 CHA done */
+	descbuf = cmd_insert_jump(descbuf, JUMP_TYPE_LOCAL,
+				  JUMP_TEST_ALL, 0, 1, NULL);
+
+	/* load imm to cha ClrWrittenReg to clear mode */
+	descbuf = cmd_insert_load(descbuf, (u_int32_t *)&cmd_imm_src[1],
+				  LDST_CLASS_IND_CCB, 0,
+				  LDST_SRCDST_WORD_CLRW, 0, 4, ITEM_INLINE);
+
+	/* load imm to cha CTL to release KFHA */
+	descbuf = cmd_insert_load(descbuf, (u_int32_t *)&cmd_imm_src[3],
+				  LDST_CLASS_IND_CCB, 0,
+				  LDST_SRCDST_WORD_CHACTRL, 0, 4, ITEM_INLINE);
+
+	endidx = descbuf - start + 1; /* add 1 to include header */
+	cmd_insert_shared_hdr(start, startidx, endidx, CTX_ERASE, SHR_ALWAYS);
+
+	*bufsize = endidx;
+
+	return 0;
+}
diff --git a/drivers/crypto/caam/desc.h b/drivers/crypto/caam/desc.h
index e433bfd..71b6c18 100644
--- a/drivers/crypto/caam/desc.h
+++ b/drivers/crypto/caam/desc.h
@@ -149,6 +149,7 @@
 
 /* Scatter-Gather Table/Variable Length Field */
 #define KEY_SGF                 0x01000000
+#define KEY_VLF                 0x01000000
 
 /* Immediate - Key follows command in the descriptor */
 #define KEY_IMM                 0x00800000
@@ -183,6 +184,7 @@
  * 1 = class 1 CCB, 2 = class 2 CCB, 3 = DECO
  */
 #define LDST_CLASS_SHIFT        25
+#define LDST_CLASS_MASK         (0x03 << LDST_CLASS_SHIFT)
 #define LDST_CLASS_IND_CCB      (0x00 << LDST_CLASS_SHIFT)
 #define LDST_CLASS_1_CCB        (0x01 << LDST_CLASS_SHIFT)
 #define LDST_CLASS_2_CCB        (0x02 << LDST_CLASS_SHIFT)
@@ -190,21 +192,53 @@
 
 /* Scatter-Gather Table/Variable Length Field */
 #define LDST_SGF                0x01000000
+#define LDST_VLF		LDST_SGF
 
 /* Immediate - Key follows this command in descriptor    */
-#define LDST_IMM                0x00800000
+#define LDST_IMM_MASK           1
+#define LDST_IMM_SHIFT          23
+#define LDST_IMM                (LDST_IMM_MASK << LDST_IMM_SHIFT)
 
 /* SRC/DST - Destination for LOAD, Source for STORE   */
-#define LDST_SRCDST_MASK        0x7f
 #define LDST_SRCDST_SHIFT       16
+#define LDST_SRCDST_MASK        (0x7f << LDST_SRCDST_SHIFT)
+
+#define LDST_SRCDST_BYTE_CONTEXT	(0x20 << LDST_SRCDST_SHIFT)
+#define LDST_SRCDST_BYTE_KEY		(0x40 << LDST_SRCDST_SHIFT)
+#define LDST_SRCDST_BYTE_INFIFO		(0x7c << LDST_SRCDST_SHIFT)
+#define LDST_SRCDST_BYTE_OUTFIFO	(0x7e << LDST_SRCDST_SHIFT)
+
+#define LDST_SRCDST_WORD_MODE_REG	(0x00 << LDST_SRCDST_SHIFT)
+#define LDST_SRCDST_WORD_KEYSZ_REG	(0x01 << LDST_SRCDST_SHIFT)
+#define LDST_SRCDST_WORD_DATASZ_REG	(0x02 << LDST_SRCDST_SHIFT)
+#define LDST_SRCDST_WORD_ICVSZ_REG	(0x03 << LDST_SRCDST_SHIFT)
+#define LDST_SRCDST_WORD_CHACTRL	(0x06 << LDST_SRCDST_SHIFT)
+#define LDST_SRCDST_WORD_DECOCTRL       (0x06 << LDST_SRCDST_SHIFT)
+#define LDST_SRCDST_WORD_IRQCTRL	(0x07 << LDST_SRCDST_SHIFT)
+#define LDST_SRCDST_WORD_DECO_PCLOVRD   (0x07 << LDST_SRCDST_SHIFT)
+#define LDST_SRCDST_WORD_CLRW		(0x08 << LDST_SRCDST_SHIFT)
+#define LDST_SRCDST_WORD_DECO_MATH0     (0x08 << LDST_SRCDST_SHIFT)
+#define LDST_SRCDST_WORD_STAT		(0x09 << LDST_SRCDST_SHIFT)
+#define LDST_SRCDST_WORD_DECO_MATH1     (0x09 << LDST_SRCDST_SHIFT)
+#define LDST_SRCDST_WORD_DECO_MATH2     (0x0a << LDST_SRCDST_SHIFT)
+#define LDST_SRCDST_WORD_DECO_AAD_SZ    (0x0b << LDST_SRCDST_SHIFT)
+#define LDST_SRCDST_WORD_DECO_MATH3     (0x0b << LDST_SRCDST_SHIFT)
+#define LDST_SRCDST_WORD_CLASS1_ICV_SZ  (0x0c << LDST_SRCDST_SHIFT)
+#define LDST_SRCDST_WORD_ALTDS_CLASS1   (0x0f << LDST_SRCDST_SHIFT)
+#define LDST_SRCDST_WORD_PKHA_A_SZ      (0x10 << LDST_SRCDST_SHIFT)
+#define LDST_SRCDST_WORD_PKHA_B_SZ      (0x11 << LDST_SRCDST_SHIFT)
+#define LDST_SRCDST_WORD_PKHA_N_SZ      (0x12 << LDST_SRCDST_SHIFT)
+#define LDST_SRCDST_WORD_PKHA_E_SZ      (0x13 << LDST_SRCDST_SHIFT)
+#define LDST_SRCDST_WORD_DESCBUF        (0x40 << LDST_SRCDST_SHIFT)
+#define LDST_SRCDST_WORD_INFO_FIFO      (0x7a << LDST_SRCDST_SHIFT)
 
 /* Offset in source/destination                        */
-#define LDST_OFFSET_MASK        0xff
 #define LDST_OFFSET_SHIFT       8
+#define LDST_OFFSET_MASK        (0xff << LDST_OFFSET_SHIFT)
 
 /* Data length in bytes                                 */
-#define LDST_LEN_MASK           0xff
 #define LDST_LEN_SHIFT          0
+#define LDST_LEN_MASK           (0xff << LDST_LEN_SHIFT)
 
 /*
  * FIFO_LOAD/FIFO_STORE/SEQ_FIFO_LOAD/SEQ_FIFO_STORE
@@ -217,35 +251,55 @@
  * Store Source: 0 = normal, 1 = Class1key, 2 = Class2key
  */
 #define FIFOLD_CLASS_SHIFT      25
+#define FIFOLD_CLASS_MASK       (0x03 << FIFOLD_CLASS_SHIFT)
 #define FIFOLD_CLASS_SKIP       (0x00 << FIFOLD_CLASS_SHIFT)
 #define FIFOLD_CLASS_CLASS1     (0x01 << FIFOLD_CLASS_SHIFT)
 #define FIFOLD_CLASS_CLASS2     (0x02 << FIFOLD_CLASS_SHIFT)
 #define FIFOLD_CLASS_BOTH       (0x03 << FIFOLD_CLASS_SHIFT)
 
-#define FIFOST_CLASS_NORMAL     (0x00 << FIFOLD_CLASS_SHIFT)
-#define FIFOST_CLASS_CLASS1KEY  (0x01 << FIFOLD_CLASS_SHIFT)
-#define FIFOST_CLASS_CLASS2KEY  (0x02 << FIFOLD_CLASS_SHIFT)
+#define FIFOST_CLASS_SHIFT      25
+#define FIFOST_CLASS_MASK       (0x03 << FIFOST_CLASS_SHIFT)
+#define FIFOST_CLASS_NORMAL     (0x00 << FIFOST_CLASS_SHIFT)
+#define FIFOST_CLASS_CLASS1KEY  (0x01 << FIFOST_CLASS_SHIFT)
+#define FIFOST_CLASS_CLASS2KEY  (0x02 << FIFOST_CLASS_SHIFT)
 
 /*
  * Scatter-Gather Table/Variable Length Field
  * If set for FIFO_LOAD, refers to a SG table. Within
  * SEQ_FIFO_LOAD, is variable input sequence
  */
-#define FIFOLDST_SGF            0x01000000
+#define FIFOLDST_SGF_SHIFT      24
+#define FIFOLDST_SGF_MASK       (1 << FIFOLDST_SGF_SHIFT)
+#define FIFOLDST_VLF_MASK       (1 << FIFOLDST_SGF_SHIFT)
+#define FIFOLDST_SGF            (1 << FIFOLDST_SGF_SHIFT)
+#define FIFOLDST_VLF            (1 << FIFOLDST_SGF_SHIFT)
 
 /* Immediate - Key follows command in descriptor */
-#define FIFOLDST_IMM            0x00800000
+#define FIFOLD_IMM_SHIFT      23
+#define FIFOLD_IMM_MASK       (1 << FIFOLD_IMM_SHIFT)
+#define FIFOLD_IMM            (1 << FIFOLD_IMM_SHIFT)
+
+/* Continue - Not the last FIFO store to come */
+#define FIFOST_CONT_SHIFT     23
+#define FIFOST_CONT_MASK      (1 << FIFOST_CONT_SHIFT)
+#define FIFOST_CONT_MASK      (1 << FIFOST_CONT_SHIFT)
 
 /*
  * Extended Length - use 32-bit extended length that
  * follows the pointer field. Illegal with IMM set
  */
-#define FIFOLDST_EXT            0x00400000
+#define FIFOLDST_EXT_SHIFT      22
+#define FIFOLDST_EXT_MASK       (1 << FIFOLDST_EXT_SHIFT)
+#define FIFOLDST_EXT            (1 << FIFOLDST_EXT_SHIFT)
 
 /* Input data type.*/
 #define FIFOLD_TYPE_SHIFT       16
+#define FIFOLD_TYPE_MASK        (0x3f << FIFOLD_TYPE_SHIFT)
 
 /* PK types */
+#define FIFOLD_TYPE_PK          (0x00 << FIFOLD_TYPE_SHIFT)
+#define FIFOLD_TYPE_PK_MASK     (0x30 << FIFOLD_TYPE_SHIFT)
+#define FIFOLD_TYPE_PK_TYPEMASK (0x0f << FIFOLD_TYPE_SHIFT)
 #define FIFOLD_TYPE_PK_A0       (0x00 << FIFOLD_TYPE_SHIFT)
 #define FIFOLD_TYPE_PK_A1       (0x01 << FIFOLD_TYPE_SHIFT)
 #define FIFOLD_TYPE_PK_A2       (0x02 << FIFOLD_TYPE_SHIFT)
@@ -259,6 +313,7 @@
 #define FIFOLD_TYPE_PK_B        (0x0d << FIFOLD_TYPE_SHIFT)
 
 /* Other types. Need to OR in last/flush bits as desired */
+#define FIFOLD_TYPE_MSG_MASK    (0x38 << FIFOLD_TYPE_SHIFT)
 #define FIFOLD_TYPE_MSG         (0x10 << FIFOLD_TYPE_SHIFT)
 #define FIFOLD_TYPE_MSG1OUT2    (0x18 << FIFOLD_TYPE_SHIFT)
 #define FIFOLD_TYPE_IV          (0x20 << FIFOLD_TYPE_SHIFT)
@@ -267,6 +322,7 @@
 #define FIFOLD_TYPE_ICV         (0x38 << FIFOLD_TYPE_SHIFT)
 
 /* Last/Flush bits for use with "other" types above */
+#define FIFOLD_TYPE_ACT_MASK    (0x07 << FIFOLD_TYPE_SHIFT)
 #define FIFOLD_TYPE_NOACTION    (0x00 << FIFOLD_TYPE_SHIFT)
 #define FIFOLD_TYPE_FLUSH1      (0x01 << FIFOLD_TYPE_SHIFT)
 #define FIFOLD_TYPE_LAST1       (0x02 << FIFOLD_TYPE_SHIFT)
@@ -276,6 +332,39 @@
 #define FIFOLD_TYPE_LASTBOTH    (0x06 << FIFOLD_TYPE_SHIFT)
 #define FIFOLD_TYPE_LASTBOTHFL  (0x07 << FIFOLD_TYPE_SHIFT)
 
+#define FIFOLDST_LEN_MASK       0xffff
+#define FIFOLDST_EXT_LEN_MASK   0xffffffff
+
+/* Output data types */
+#define FIFOST_TYPE_SHIFT       16
+#define FIFOST_TYPE_MASK        (0x3f << FIFOST_TYPE_SHIFT)
+
+#define FIFOST_TYPE_PKHA_A0      (0x00 << FIFOST_TYPE_SHIFT)
+#define FIFOST_TYPE_PKHA_A1      (0x01 << FIFOST_TYPE_SHIFT)
+#define FIFOST_TYPE_PKHA_A2      (0x02 << FIFOST_TYPE_SHIFT)
+#define FIFOST_TYPE_PKHA_A3      (0x03 << FIFOST_TYPE_SHIFT)
+#define FIFOST_TYPE_PKHA_B0      (0x04 << FIFOST_TYPE_SHIFT)
+#define FIFOST_TYPE_PKHA_B1      (0x05 << FIFOST_TYPE_SHIFT)
+#define FIFOST_TYPE_PKHA_B2      (0x06 << FIFOST_TYPE_SHIFT)
+#define FIFOST_TYPE_PKHA_B3      (0x07 << FIFOST_TYPE_SHIFT)
+#define FIFOST_TYPE_PKHA_N       (0x08 << FIFOST_TYPE_SHIFT)
+#define FIFOST_TYPE_PKHA_A       (0x0c << FIFOST_TYPE_SHIFT)
+#define FIFOST_TYPE_PKHA_B       (0x0d << FIFOST_TYPE_SHIFT)
+#define FIFOST_TYPE_AF_SBOX_JKEK (0x10 << FIFOST_TYPE_SHIFT)
+#define FIFOST_TYPE_AF_SBOX_TKEK (0x21 << FIFOST_TYPE_SHIFT)
+#define FIFOST_TYPE_PKHA_E_JKEK  (0x22 << FIFOST_TYPE_SHIFT)
+#define FIFOST_TYPE_PKHA_E_TKEK  (0x23 << FIFOST_TYPE_SHIFT)
+#define FIFOST_TYPE_KEY_KEK      (0x24 << FIFOST_TYPE_SHIFT)
+#define FIFOST_TYPE_KEY_TKEK     (0x25 << FIFOST_TYPE_SHIFT)
+#define FIFOST_TYPE_SPLIT_KEK    (0x26 << FIFOST_TYPE_SHIFT)
+#define FIFOST_TYPE_SPLIT_TKEK   (0x27 << FIFOST_TYPE_SHIFT)
+#define FIFOST_TYPE_OUTFIFO_KEK  (0x28 << FIFOST_TYPE_SHIFT)
+#define FIFOST_TYPE_OUTFIFO_TKEK (0x29 << FIFOST_TYPE_SHIFT)
+#define FIFOST_TYPE_MESSAGE_DATA (0x30 << FIFOST_TYPE_SHIFT)
+#define FIFOST_TYPE_RNGSTORE     (0x34 << FIFOST_TYPE_SHIFT)
+#define FIFOST_TYPE_RNGFIFO      (0x35 << FIFOST_TYPE_SHIFT)
+#define FIFOST_TYPE_SKIP         (0x3f << FIFOST_TYPE_SHIFT)
+
 /*
  * OPERATION Command Constructs
  */
@@ -302,6 +391,12 @@
 #define OP_PCLID_TLS10_PRF      (0x09 << OP_PCLID_SHIFT)
 #define OP_PCLID_TLS11_PRF      (0x0a << OP_PCLID_SHIFT)
 #define OP_PCLID_DTLS10_PRF     (0x0c << OP_PCLID_SHIFT)
+#define OP_PCLID_PRF            (0x06 << OP_PCLID_SHIFT)
+#define OP_PCLID_BLOB           (0x0d << OP_PCLID_SHIFT)
+#define OP_PCLID_SECRETKEY      (0x11 << OP_PCLID_SHIFT)
+#define OP_PCLID_PUBLICKEYPAIR  (0x14 << OP_PCLID_SHIFT)
+#define OP_PCLID_DSASIGN        (0x15 << OP_PCLID_SHIFT)
+#define OP_PCLID_DSAVERIFY      (0x16 << OP_PCLID_SHIFT)
 
 /* Assuming OP_TYPE = OP_TYPE_DECAP_PROTOCOL/ENCAP_PROTOCOL */
 #define OP_PCLID_IPSEC          (0x01 << OP_PCLID_SHIFT)
@@ -315,14 +410,6 @@
 #define OP_PCLID_TLS12          (0x0b << OP_PCLID_SHIFT)
 #define OP_PCLID_DTLS           (0x0c << OP_PCLID_SHIFT)
 
-/* Assuming OP_TYPE = other... */
-#define OP_PCLID_PRF            (0x06 << OP_PCLID_SHIFT)
-#define OP_PCLID_BLOB           (0x0d << OP_PCLID_SHIFT)
-#define OP_PCLID_SECRETKEY      (0x11 << OP_PCLID_SHIFT)
-#define OP_PCLID_PUBLICKEYPAIR  (0x14 << OP_PCLID_SHIFT)
-#define OP_PCLID_DSASIGN        (0x15 << OP_PCLID_SHIFT)
-#define OP_PCLID_DSAVERIFY      (0x16 << OP_PCLID_SHIFT)
-
 /*
  * ProtocolInfo selectors
  */
@@ -949,6 +1036,175 @@
 #define OP_PCL_DTLS_AES_256_CBC_SHA384           0xff63
 #define OP_PCL_DTLS_AES_256_CBC_SHA512           0xff65
 
+/* 802.16 WiMAX protinfos */
+#define OP_PCL_WIMAX_OFDM                        0x0201
+#define OP_PCL_WIMAX_OFDMA                       0x0231
+
+/* 802.11 WiFi protinfos */
+#define OP_PCL_WIFI                              0xac04
+
+/* MacSec protinfos */
+#define OP_PCL_MACSEC                            0x0001
+
+/* PKI unidirectional protocol protinfo bits */
+#define OP_PCL_PKPROT_TEST                       0x0008
+#define OP_PCL_PKPROT_DECRYPT                    0x0004
+#define OP_PCL_PKPROT_ECC                        0x0002
+#define OP_PCL_PKPROT_F2M                        0x0001
+
+/* For non-protocol/alg-only op commands */
+#define OP_ALG_TYPE_SHIFT  24
+#define OP_ALG_TYPE_MASK   (0x7 << OP_ALG_TYPE_SHIFT)
+#define OP_ALG_TYPE_CLASS1 2
+#define OP_ALG_TYPE_CLASS2 4
+
+#define OP_ALG_ALGSEL_SHIFT   16
+#define OP_ALG_ALGSEL_MASK    (0xff << OP_ALG_ALGSEL_SHIFT)
+#define OP_ALG_ALGSEL_AES     (0x10 << OP_ALG_ALGSEL_SHIFT)
+#define OP_ALG_ALGSEL_DES     (0x20 << OP_ALG_ALGSEL_SHIFT)
+#define OP_ALG_ALGSEL_3DES    (0x21 << OP_ALG_ALGSEL_SHIFT)
+#define OP_ALG_ALGSEL_ARC4    (0x30 << OP_ALG_ALGSEL_SHIFT)
+#define OP_ALG_ALGSEL_MD5     (0x40 << OP_ALG_ALGSEL_SHIFT)
+#define OP_ALG_ALGSEL_SHA1    (0x41 << OP_ALG_ALGSEL_SHIFT)
+#define OP_ALG_ALGSEL_SHA224  (0x42 << OP_ALG_ALGSEL_SHIFT)
+#define OP_ALG_ALGSEL_SHA256  (0x43 << OP_ALG_ALGSEL_SHIFT)
+#define OP_ALG_ALGSEL_SHA384  (0x44 << OP_ALG_ALGSEL_SHIFT)
+#define OP_ALG_ALGSEL_SHA512  (0x45 << OP_ALG_ALGSEL_SHIFT)
+#define OP_ALG_ALGSEL_RNG     (0x50 << OP_ALG_ALGSEL_SHIFT)
+#define OP_ALG_ALGSEL_SNOW    (0x60 << OP_ALG_ALGSEL_SHIFT)
+#define OP_ALG_ALGSEL_KASUMI  (0x70 << OP_ALG_ALGSEL_SHIFT)
+#define OP_ALG_ALGSEL_CRC     (0x90 << OP_ALG_ALGSEL_SHIFT)
+
+#define OP_ALG_AAI_SHIFT	4
+#define OP_ALG_AAI_MASK		(0x1ff << OP_ALG_AAI_SHIFT)
+
+/* blockcipher AAI set */
+#define OP_ALG_AAI_CTR_MOD128	(0x00 << OP_ALG_AAI_SHIFT)
+#define OP_ALG_AAI_CTR_MOD8	(0x01 << OP_ALG_AAI_SHIFT)
+#define OP_ALG_AAI_CTR_MOD16	(0x02 << OP_ALG_AAI_SHIFT)
+#define OP_ALG_AAI_CTR_MOD24	(0x03 << OP_ALG_AAI_SHIFT)
+#define OP_ALG_AAI_CTR_MOD32	(0x04 << OP_ALG_AAI_SHIFT)
+#define OP_ALG_AAI_CTR_MOD40	(0x05 << OP_ALG_AAI_SHIFT)
+#define OP_ALG_AAI_CTR_MOD48	(0x06 << OP_ALG_AAI_SHIFT)
+#define OP_ALG_AAI_CTR_MOD56	(0x07 << OP_ALG_AAI_SHIFT)
+#define OP_ALG_AAI_CTR_MOD64	(0x08 << OP_ALG_AAI_SHIFT)
+#define OP_ALG_AAI_CTR_MOD72	(0x09 << OP_ALG_AAI_SHIFT)
+#define OP_ALG_AAI_CTR_MOD80	(0x0a << OP_ALG_AAI_SHIFT)
+#define OP_ALG_AAI_CTR_MOD88	(0x0b << OP_ALG_AAI_SHIFT)
+#define OP_ALG_AAI_CTR_MOD96	(0x0c << OP_ALG_AAI_SHIFT)
+#define OP_ALG_AAI_CTR_MOD104	(0x0d << OP_ALG_AAI_SHIFT)
+#define OP_ALG_AAI_CTR_MOD112	(0x0e << OP_ALG_AAI_SHIFT)
+#define OP_ALG_AAI_CTR_MOD120	(0x0f << OP_ALG_AAI_SHIFT)
+#define OP_ALG_AAI_CBC		(0x10 << OP_ALG_AAI_SHIFT)
+#define OP_ALG_AAI_ECB		(0x20 << OP_ALG_AAI_SHIFT)
+#define OP_ALG_AAI_CFB		(0x30 << OP_ALG_AAI_SHIFT)
+#define OP_ALG_AAI_OFB		(0x40 << OP_ALG_AAI_SHIFT)
+#define OP_ALG_AAI_XTS		(0x50 << OP_ALG_AAI_SHIFT)
+#define OP_ALG_AAI_CMAC		(0x60 << OP_ALG_AAI_SHIFT)
+#define OP_ALG_AAI_XCBC_MAC	(0x70 << OP_ALG_AAI_SHIFT)
+#define OP_ALG_AAI_CCM		(0x80 << OP_ALG_AAI_SHIFT)
+#define OP_ALG_AAI_GCM		(0x90 << OP_ALG_AAI_SHIFT)
+#define OP_ALG_AAI_CBC_XCBCMAC	(0xa0 << OP_ALG_AAI_SHIFT)
+#define OP_ALG_AAI_CTR_XCBCMAC	(0xb0 << OP_ALG_AAI_SHIFT)
+#define OP_ALG_AAI_CHECKODD	(0x80 << OP_ALG_AAI_SHIFT)
+#define OP_ALG_AAI_DK		(0x100 << OP_ALG_AAI_SHIFT)
+
+/* randomizer AAI set */
+#define OP_ALG_AAI_RNG		(0x00 << OP_ALG_AAI_SHIFT)
+#define OP_ALG_AAI_RNG_NOZERO	(0x10 << OP_ALG_AAI_SHIFT)
+#define OP_ALG_AAI_RNG_ODD	(0x20 << OP_ALG_AAI_SHIFT)
+
+/* hmac/smac AAI set */
+#define OP_ALG_AAI_HASH		(0x00 << OP_ALG_AAI_SHIFT)
+#define OP_ALG_AAI_HMAC		(0x01 << OP_ALG_AAI_SHIFT)
+#define OP_ALG_AAI_SMAC		(0x02 << OP_ALG_AAI_SHIFT)
+#define OP_ALG_AAI_HMAC_PRECOMP	(0x04 << OP_ALG_AAI_SHIFT)
+
+/* CRC AAI set*/
+#define OP_ALG_AAI_802		(0x01 << OP_ALG_AAI_SHIFT)
+#define OP_ALG_AAI_3385		(0x02 << OP_ALG_AAI_SHIFT)
+#define OP_ALG_AAI_CUST_POLY	(0x04 << OP_ALG_AAI_SHIFT)
+#define OP_ALG_AAI_DIS		(0x10 << OP_ALG_AAI_SHIFT)
+#define OP_ALG_AAI_DOS		(0x20 << OP_ALG_AAI_SHIFT)
+#define OP_ALG_AAI_DOC		(0x40 << OP_ALG_AAI_SHIFT)
+
+/* Kasumi/SNOW AAI set */
+#define OP_ALG_AAI_F8		(0xc0 << OP_ALG_AAI_SHIFT)
+#define OP_ALG_AAI_F9		(0xc8 << OP_ALG_AAI_SHIFT)
+#define OP_ALG_AAI_GSM		(0x10 << OP_ALG_AAI_SHIFT)
+#define OP_ALG_AAI_EDGE		(0x20 << OP_ALG_AAI_SHIFT)
+
+
+#define OP_ALG_AS_SHIFT		2
+#define OP_ALG_AS_MASK		(0x3 << OP_ALG_AS_SHIFT)
+#define OP_ALG_AS_UPDATE	(0 << OP_ALG_AS_SHIFT)
+#define OP_ALG_AS_INIT		(1 << OP_ALG_AS_SHIFT)
+#define OP_ALG_AS_FINALIZE	(2 << OP_ALG_AS_SHIFT)
+#define OP_ALG_AS_INITFINAL	(3 << OP_ALG_AS_SHIFT)
+
+#define OP_ALG_ICV_SHIFT	1
+#define OP_ALG_ICV_MASK		(1 << OP_ALG_ICV_SHIFT)
+#define OP_ALG_ICV_OFF		(0 << OP_ALG_ICV_SHIFT)
+#define OP_ALG_ICV_ON		(1 << OP_ALG_ICV_SHIFT)
+
+#define OP_ALG_DIR_SHIFT	0
+#define OP_ALG_DIR_MASK		1
+#define OP_ALG_DECRYPT		0
+#define OP_ALG_ENCRYPT		1
+
+/* PKHA algorithm type set */
+#define OP_ALG_PK                    0x00800000
+
+/* PKHA mode clear memory functions */
+#define OP_ALG_PKMODE_A_RAM          0x80000
+#define OP_ALG_PKMODE_B_RAM          0x40000
+#define OP_ALG_PKMODE_E_RAM          0x20000
+#define OP_ALG_PKMODE_N_RAM          0x10000
+#define OP_ALG_PKMODE_CLEARMEM       0x00001
+
+/* PKHA mode modular-arithmetic functions */
+#define OP_ALG_PKMODE_MOD_IN_MONTY   0x80000
+#define OP_ALG_PKMODE_MOD_OUT_MONTY  0x40000
+#define OP_ALG_PKMODE_MOD_F2M        0x20000
+#define OP_ALG_PKMODE_MOD_R2_IN      0x10000
+#define OP_ALG_PKMODE_PRJECTV        0x00800
+#define OP_ALG_PKMODE_TIME_EQ        0x400
+#define OP_ALG_PKMODE_OUT_B          0x000
+#define OP_ALG_PKMODE_OUT_A          0x100
+#define OP_ALG_PKMODE_MOD_ADD        0x002
+#define OP_ALG_PKMODE_MOD_SUB_AB     0x003
+#define OP_ALG_PKMODE_MOD_SUB_BA     0x004
+#define OP_ALG_PKMODE_MOD_MULT       0x005
+#define OP_ALG_PKMODE_MOD_EXPO       0x006
+#define OP_ALG_PKMODE_MOD_REDUCT     0x007
+#define OP_ALG_PKMODE_MOD_INV        0x008
+#define OP_ALG_PKMODE_MOD_ECC_ADD    0x009
+#define OP_ALG_PKMODE_MOD_ECC_DBL    0x00a
+#define OP_ALG_PKMODE_MOD_ECC_MULT   0x00b
+#define OP_ALG_PKMODE_MOD_MONT_CNST  0x00c
+#define OP_ALG_PKMODE_MOD_CRT_CNST   0x00d
+#define OP_ALG_PKMODE_MOD_GCD        0x00e
+#define OP_ALG_PKMODE_MOD_PRIMALITY  0x00f
+
+/* PKHA mode copy-memory functions */
+#define OP_ALG_PKMODE_SRC_REG_A      0x00000
+#define OP_ALG_PKMODE_SRC_REG_B      0x20000
+#define OP_ALG_PKMODE_SRC_REG_N      0x60000
+#define OP_ALG_PKMODE_DST_REG_A      0x00000
+#define OP_ALG_PKMODE_DST_REG_B      0x04000
+#define OP_ALG_PKMODE_DST_REG_E      0x08000
+#define OP_ALG_PKMODE_DST_REG_N      0x0c000
+#define OP_ALG_PKMODE_SRC_SEG_0      0x00000
+#define OP_ALG_PKMODE_SRC_SEG_1      0x01000
+#define OP_ALG_PKMODE_SRC_SEG_2      0x02000
+#define OP_ALG_PKMODE_SRC_SEG_3      0x03000
+#define OP_ALG_PKMODE_DST_SEG_0      0x00000
+#define OP_ALG_PKMODE_DST_SEG_1      0x00400
+#define OP_ALG_PKMODE_DST_SEG_2      0x00800
+#define OP_ALG_PKMODE_DST_SEG_3      0x00c00
+#define OP_ALG_PKMODE_CPYMEM_N_SZ    0x00080
+#define OP_ALG_PKMODE_CPYMEM_SRC_SZ  0x00081
+
 /*
  * SEQ_IN_PTR Command Constructs
  */
@@ -1003,10 +1259,14 @@
  */
 
 #define MOVE_AUX_SHIFT          25
+#define MOVE_AUX_MASK           (3 << MOVE_AUX_SHIFT)
 
-#define MOVE_WAITCOMP           0x01000000
+#define MOVE_WAITCOMP_SHIFT     24
+#define MOVE_WAITCOMP_MASK      (1 << MOVE_WAITCOMP_SHIFT)
+#define MOVE_WAITCOMP           (1 << MOVE_WAITCOMP_SHIFT)
 
 #define MOVE_SRC_SHIFT          20
+#define MOVE_SRC_MASK           (0x0f << MOVE_SRC_SHIFT)
 #define MOVE_SRC_CLASS1CTX      (0x00 << MOVE_SRC_SHIFT)
 #define MOVE_SRC_CLASS2CTX      (0x01 << MOVE_SRC_SHIFT)
 #define MOVE_SRC_OUTFIFO        (0x02 << MOVE_SRC_SHIFT)
@@ -1018,6 +1278,7 @@
 #define MOVE_SRC_INFIFO         (0x08 << MOVE_SRC_SHIFT)
 
 #define MOVE_DEST_SHIFT         16
+#define MOVE_DEST_MASK          (0x0f << MOVE_DEST_SHIFT)
 #define MOVE_DEST_CLASS1CTX     (0x00 << MOVE_DEST_SHIFT)
 #define MOVE_DEST_CLASS2CTX     (0x01 << MOVE_DEST_SHIFT)
 #define MOVE_DEST_OUTFIFO       (0x02 << MOVE_DEST_SHIFT)
@@ -1033,20 +1294,30 @@
 #define MOVE_DEST_CLASS2KEY     (0x0e << MOVE_DEST_SHIFT)
 
 #define MOVE_OFFSET_SHIFT       8
-#define MOVE_OFFSET_MASK        0xff
+#define MOVE_OFFSET_MASK        (0xff << MOVE_OFFSET_SHIFT)
 
-#define MOVE_LEN_MASK           0xff
+#define MOVE_LEN_SHIFT           0
+#define MOVE_LEN_MASK           (0xff << MOVE_LEN_SHIFT)
 
 /*
  * MATH Command Constructs
  */
 
-#define MATH_IFB                0x04000000
-#define MATH_NFU                0x02000000
-#define MATH_STL                0x01000000
+#define MATH_IFB_SHIFT          26
+#define MATH_IFB_MASK           (1 << MATH_IFB_SHIFT)
+#define MATH_IFB                (1 << MATH_IFB_SHIFT)
+
+#define MATH_NFU_SHIFT          25
+#define MATH_NFU_MASK           (1 << MATH_NFU_SHIFT)
+#define MATH_NFU                (1 << MATH_NFU_SHIFT)
+
+#define MATH_STL_SHIFT          24
+#define MATH_STL_MASK           (1 << MATH_STL_SHIFT)
+#define MATH_STL                (1 << MATH_STL_SHIFT)
 
 /* Function selectors */
 #define MATH_FUN_SHIFT          20
+#define MATH_FUN_MASK           (0x0f << MATH_FUN_SHIFT)
 #define MATH_FUN_ADD            (0x00 << MATH_FUN_SHIFT)
 #define MATH_FUN_ADDC           (0x01 << MATH_FUN_SHIFT)
 #define MATH_FUN_SUB            (0x02 << MATH_FUN_SHIFT)
@@ -1060,6 +1331,7 @@
 
 /* Source 0 selectors */
 #define MATH_SRC0_SHIFT         16
+#define MATH_SRC0_MASK          (0x0f << MATH_SRC0_SHIFT)
 #define MATH_SRC0_REG0          (0x00 << MATH_SRC0_SHIFT)
 #define MATH_SRC0_REG1          (0x01 << MATH_SRC0_SHIFT)
 #define MATH_SRC0_REG2          (0x02 << MATH_SRC0_SHIFT)
@@ -1073,6 +1345,7 @@
 
 /* Source 1 selectors */
 #define MATH_SRC1_SHIFT         12
+#define MATH_SRC1_MASK          (0x0f << MATH_SRC1_SHIFT)
 #define MATH_SRC1_REG0          (0x00 << MATH_SRC1_SHIFT)
 #define MATH_SRC1_REG1          (0x01 << MATH_SRC1_SHIFT)
 #define MATH_SRC1_REG2          (0x02 << MATH_SRC1_SHIFT)
@@ -1084,6 +1357,7 @@
 
 /* Destination selectors */
 #define MATH_DEST_SHIFT         8
+#define MATH_DEST_MASK          (0x0f << MATH_DEST_SHIFT)
 #define MATH_DEST_REG0          (0x00 << MATH_DEST_SHIFT)
 #define MATH_DEST_REG1          (0x01 << MATH_DEST_SHIFT)
 #define MATH_DEST_REG2          (0x02 << MATH_DEST_SHIFT)
@@ -1095,6 +1369,8 @@
 #define MATH_DEST_NONE          (0x0f << MATH_DEST_SHIFT)
 
 /* Length selectors */
+#define MATH_LEN_SHIFT          0
+#define MATH_LEN_MASK           (0x0f << MATH_LEN_SHIFT)
 #define MATH_LEN_1BYTE          0x01
 #define MATH_LEN_2BYTE          0x02
 #define MATH_LEN_4BYTE          0x04
@@ -1106,38 +1382,46 @@
 
 #define JUMP_CLASS_SHIFT        25 /* General class selectors OK */
 
-#define JUMP_JSL                0x01000000
+#define JUMP_JSL_SHIFT          24
+#define JUMP_JSL_MASK           (1 << JUMP_JSL_SHIFT)
+#define JUMP_JSL                (1 << JUMP_JSL_SHIFT)
 
 #define JUMP_TYPE_SHIFT         22
+#define JUMP_TYPE_MASK          (0x03 << JUMP_TYPE_SHIFT)
 #define JUMP_TYPE_LOCAL         (0x00 << JUMP_TYPE_SHIFT)
 #define JUMP_TYPE_NONLOCAL      (0x01 << JUMP_TYPE_SHIFT)
 #define JUMP_TYPE_HALT          (0x02 << JUMP_TYPE_SHIFT)
 #define JUMP_TYPE_HALT_USER     (0x03 << JUMP_TYPE_SHIFT)
 
 #define JUMP_TEST_SHIFT         16
+#define JUMP_TEST_MASK          (0x03 << JUMP_TEST_SHIFT)
 #define JUMP_TEST_ALL           (0x00 << JUMP_TEST_SHIFT)
 #define JUMP_TEST_INVALL        (0x01 << JUMP_TEST_SHIFT)
 #define JUMP_TEST_ANY           (0x02 << JUMP_TEST_SHIFT)
 #define JUMP_TEST_INVANY        (0x03 << JUMP_TEST_SHIFT)
 
-/* If JUMP_JSL clear, these condition codes apply */
-#define JUMP_COND_PK_0          0x00008000
-#define JUMP_COND_PK_GCD_1      0x00004000
-#define JUMP_COND_PK_PRIME      0x00002000
-#define JUMP_COND_MATH_N        0x00000800
-#define JUMP_COND_MATH_Z        0x00000400
-#define JUMP_COND_MATH_C        0x00000200
-#define JUMP_COND_MATH_NV       0x00000100
-
-/* If JUMP_JSL set, these condition codes apply */
-#define JUMP_COND_JQP           0x00008000
-#define JUMP_COND_SHRD          0x00004000
-#define JUMP_COND_SELF          0x00002000
-#define JUMP_COND_CALM          0x00001000
-#define JUMP_COND_NIP           0x00000800
-#define JUMP_COND_NIFP          0x00000400
-#define JUMP_COND_NOP           0x00000200
-#define JUMP_COND_NCP           0x00000100
+/* Condition codes. JSL bit is factored in */
+#define JUMP_COND_SHIFT         8
+#define JUMP_COND_MASK          (0x100ff << JUMP_COND_SHIFT)
+#define JUMP_COND_PK_0          (0x80 << JUMP_COND_SHIFT)
+#define JUMP_COND_PK_GCD_1      (0x40 << JUMP_COND_SHIFT)
+#define JUMP_COND_PK_PRIME      (0x20 << JUMP_COND_SHIFT)
+#define JUMP_COND_MATH_N        (0x08 << JUMP_COND_SHIFT)
+#define JUMP_COND_MATH_Z        (0x04 << JUMP_COND_SHIFT)
+#define JUMP_COND_MATH_C        (0x02 << JUMP_COND_SHIFT)
+#define JUMP_COND_MATH_NV       (0x01 << JUMP_COND_SHIFT)
+
+#define JUMP_COND_JQP           ((0x80 << JUMP_COND_SHIFT) | JUMP_JSL)
+#define JUMP_COND_SHRD          ((0x40 << JUMP_COND_SHIFT) | JUMP_JSL)
+#define JUMP_COND_SELF          ((0x20 << JUMP_COND_SHIFT) | JUMP_JSL)
+#define JUMP_COND_CALM          ((0x10 << JUMP_COND_SHIFT) | JUMP_JSL)
+#define JUMP_COND_NIP           ((0x08 << JUMP_COND_SHIFT) | JUMP_JSL)
+#define JUMP_COND_NIFP          ((0x04 << JUMP_COND_SHIFT) | JUMP_JSL)
+#define JUMP_COND_NOP           ((0x02 << JUMP_COND_SHIFT) | JUMP_JSL)
+#define JUMP_COND_NCP           ((0x01 << JUMP_COND_SHIFT) | JUMP_JSL)
+
+#define JUMP_OFFSET_SHIFT       0
+#define JUMP_OFFSET_MASK        (0xff << JUMP_OFFSET_SHIFT)
 
 /*
  * PDB internal definitions
diff --git a/drivers/crypto/caam/intern.h b/drivers/crypto/caam/intern.h
index e60753a..102c09c 100644
--- a/drivers/crypto/caam/intern.h
+++ b/drivers/crypto/caam/intern.h
@@ -16,6 +16,11 @@
  *       names of its contributors may be used to endorse or promote products
  *       derived from this software without specific prior written permission.
  *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
  * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
diff --git a/drivers/crypto/caam/jq.c b/drivers/crypto/caam/jq.c
index 8edfcc7..0d71a69 100644
--- a/drivers/crypto/caam/jq.c
+++ b/drivers/crypto/caam/jq.c
@@ -16,6 +16,11 @@
  *       names of its contributors may be used to endorse or promote products
  *       derived from this software without specific prior written permission.
  *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
  * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
diff --git a/drivers/crypto/caam/jq.h b/drivers/crypto/caam/jq.h
index 7a30313..9c83556 100644
--- a/drivers/crypto/caam/jq.h
+++ b/drivers/crypto/caam/jq.h
@@ -15,6 +15,11 @@
  *       names of its contributors may be used to endorse or promote products
  *       derived from this software without specific prior written permission.
  *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
  * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
diff --git a/drivers/crypto/caam/jq_test/Makefile b/drivers/crypto/caam/jq_test/Makefile
index c89c221..aaf0af2 100644
--- a/drivers/crypto/caam/jq_test/Makefile
+++ b/drivers/crypto/caam/jq_test/Makefile
@@ -1,4 +1,4 @@
 
 obj-$(CONFIG_CRYPTO_DEV_FSL_CAAM_JQ_TEST) += caam_jq_test.o
 
-caam_jq_test-objs := caam_jqtest.o jq_ipsec.o
+caam_jq_test-objs := caam_jqtest.o jq_ipsec.o jq_snow.o jq_blkcipher.o
diff --git a/drivers/crypto/caam/jq_test/caam_jqtest.c b/drivers/crypto/caam/jq_test/caam_jqtest.c
index 60b672a..0f49c11 100644
--- a/drivers/crypto/caam/jq_test/caam_jqtest.c
+++ b/drivers/crypto/caam/jq_test/caam_jqtest.c
@@ -15,6 +15,11 @@
  *       names of its contributors may be used to endorse or promote products
  *       derived from this software without specific prior written permission.
  *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
  * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
@@ -30,6 +35,8 @@
 
 #include "caam_jqtest.h"
 
+#define JQTEST_CYCLES 100
+
 wait_queue_head_t jqtest_wq;
 wait_queue_t jqtest_wqentry;
 
@@ -76,12 +83,38 @@ static int __init caam_jqtest(void)
 	printk(KERN_INFO "caam_jqtest: running cases on %d available queues\n",
 	       owned_queues);
 	for (q = 0; q < owned_queues; q++) {
-		for (i = 0; i < 300; i++) {
+		for (i = 0; i < JQTEST_CYCLES; i++) {
+
 			stat = jq_ipsec_esp_no_term(qdev[q], NO_SHOW_DESC);
 			if (stat)
 				printk(KERN_INFO
-				       "jq_ipsec_esp_noterm: fail queue %d\n",
+				"jq_ipsec_esp_noterm: fail on queue %d\n",
+				qid[q]);
+
+			stat = jq_aes_cbc_shared(qdev[q], NO_SHOW_DESC);
+			if (stat)
+				printk(KERN_INFO
+				       "jq_aes_cbc_shared: fail on queue %d\n",
+				       qid[q]);
+
+			stat = jq_aes_cbc_job(qdev[q], NO_SHOW_DESC);
+			if (stat)
+				printk(KERN_INFO
+				       "jq_aes_cbc_job: fail on queue %d\n",
 				       qid[q]);
+
+			stat = jq_snow_f8(qdev[q], NO_SHOW_DESC);
+			if (stat)
+				printk(KERN_INFO
+				       "jq_snow_f8: fail on queue %d\n",
+				       qid[q]);
+
+			stat = jq_snow_f9(qdev[q], NO_SHOW_DESC);
+			if (stat)
+				printk(KERN_INFO
+				       "jq_snow_f9: fail on queue %d\n",
+				       qid[q]);
+
 		}
 		printk(KERN_INFO "caam_jqtest: %d cycles on queue %d\n", i, q);
 	}
@@ -101,6 +134,6 @@ static void __exit caam_jqtest_remove(void)
 module_init(caam_jqtest);
 module_exit(caam_jqtest_remove);
 
-MODULE_LICENSE("BSD");
+MODULE_LICENSE("Dual BSD/GPL");
 MODULE_DESCRIPTION("FSL CAAM JobQ Test Module");
 MODULE_AUTHOR("Freescale Semiconductor - NMG/STC");
diff --git a/drivers/crypto/caam/jq_test/caam_jqtest.h b/drivers/crypto/caam/jq_test/caam_jqtest.h
index ba56f40..01c75d5 100644
--- a/drivers/crypto/caam/jq_test/caam_jqtest.h
+++ b/drivers/crypto/caam/jq_test/caam_jqtest.h
@@ -15,6 +15,11 @@
  *       names of its contributors may be used to endorse or promote products
  *       derived from this software without specific prior written permission.
  *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
  * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
@@ -39,5 +44,9 @@
 #define NO_SHOW_DESC 0
 
 int jq_ipsec_esp_no_term(struct device *dev, int showdesc);
+int jq_snow_f8(struct device *dev, int showdesc);
+int jq_snow_f9(struct device *dev, int show);
+int jq_aes_cbc_shared(struct device *dev, int show);
+int jq_aes_cbc_job(struct device *dev, int show);
 
 #endif /* CAAM_JQTEST_H */
diff --git a/drivers/crypto/caam/jq_test/jq_blkcipher.c b/drivers/crypto/caam/jq_test/jq_blkcipher.c
new file mode 100644
index 0000000..b3cc6b9
--- /dev/null
+++ b/drivers/crypto/caam/jq_test/jq_blkcipher.c
@@ -0,0 +1,322 @@
+/*
+ * jq_blkcipher.c - JobQ unit test for blockcipher examples
+ *
+ * Copyright (c) 2009, Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "caam_jqtest.h"
+
+#if 0
+static const u_int8_t key[] = {
+	0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
+	0xf0, 0xe1, 0xd2, 0xc3, 0xb4, 0xa5, 0x96, 0x87
+};
+
+static const u_int8_t in[] = {
+	"Now is the time for all good men"
+};
+
+static const u_int8_t iv[] = {
+	0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10,
+	0x01, 0x23, 0x45, 0x57, 0x89, 0xab, 0xcd, 0xef
+};
+
+static const u_int8_t out[] = {
+	0x1e, 0x4d, 0xe7, 0x24, 0xeb, 0x93, 0xb0, 0xe0,
+	0xea, 0x74, 0xe0, 0x1b, 0x1b, 0x2f, 0x17, 0x2e,
+	0xcf, 0xa9, 0xad, 0x2a, 0x0e, 0x63, 0xd3, 0x6e,
+	0xef, 0x4a, 0x07, 0x69, 0x02, 0xca, 0xa2, 0x4b
+};
+
+#define AES_TESTSET_SIZE 32
+#define AES_KEY_SIZE 16
+#define AES_IV_SIZE 16
+
+#endif
+
+static const u_int8_t in[] = {
+	0xC4, 0x75, 0xC5, 0xFA, 0x30, 0x86, 0x21, 0x3F,
+	0x1A, 0xEC, 0xDA, 0xA1, 0x0E, 0xBF, 0xF3, 0x71,
+	0xF3, 0x58, 0xB5, 0x81, 0xAA, 0x39, 0x95, 0x2B,
+	0x6D, 0x82, 0xB3, 0x36, 0x0F, 0xD5, 0xCF, 0xDE,
+	0xCD, 0x3F, 0x96, 0x83, 0xEA, 0x2F, 0x69, 0xFA,
+	0x78, 0xCE, 0xF5, 0x63, 0xBC, 0xFF, 0x89, 0xD1,
+	0xE9, 0x6F, 0xDC, 0xF1, 0x74, 0x08, 0xB9, 0x95,
+	0x78, 0x89, 0x80, 0xFD, 0xE6, 0x54, 0xFA, 0x45,
+	0xCF, 0x55, 0x43, 0xEE, 0xCA, 0x25, 0x0C, 0x26,
+	0xF4, 0x91, 0xF2, 0xCC, 0x12, 0xC3, 0x15, 0x8A,
+	0xAB, 0x84, 0xD4, 0xF5, 0x41, 0xF0, 0x28, 0xC2,
+	0x0A, 0x7A, 0x52, 0xC3, 0xB4, 0x81, 0xFC, 0xF0,
+	0x33, 0xFA, 0x6F, 0x34, 0x42, 0xF7, 0x42, 0xEF,
+	0xEE, 0xF2, 0x14, 0x21, 0x11, 0xF0, 0xBB, 0xF5,
+	0x7A, 0x07, 0xE6, 0x43, 0x6A, 0xD3, 0xCD, 0x18,
+	0x8C, 0x8E, 0xD7, 0x38, 0x3B, 0x76, 0xD5, 0x1E,
+	0x18, 0x77, 0x38, 0x60, 0x5F, 0xB4, 0xC6, 0x12,
+	0xF2, 0x2F, 0xB0, 0xD0, 0x49, 0xD2, 0xF4, 0x01,
+	0x02, 0x8E, 0xC6, 0x29, 0x1B, 0x13, 0xC6, 0x7A,
+	0x3E, 0xF0, 0xA9, 0xC9, 0x33, 0x16, 0xCB, 0x3B,
+	0x21, 0xB6, 0x58, 0xB8, 0xD7, 0xE5, 0xC0, 0x5E,
+	0x03, 0x9A, 0x6D, 0x23, 0x70, 0x4E, 0xDC, 0x64,
+	0xAD, 0xA8, 0x2F, 0x5B, 0x2F, 0x0D, 0x38, 0xB3,
+	0x07, 0x5E, 0x17, 0x28, 0x34, 0x77, 0xF4, 0xAE,
+	0xCA, 0xEC, 0x87, 0x35, 0x87, 0xBC, 0x0C, 0x5A,
+	0x7F, 0xEC, 0x9B, 0x3C, 0x3A, 0xCF, 0xA1, 0x04,
+	0x30, 0xFD, 0x3C, 0x50, 0x3F, 0xC9, 0x8B, 0x20,
+	0x16, 0x63, 0x7E, 0x33, 0x57, 0x6E, 0xB7, 0x83,
+	0xBD, 0x11, 0x7B, 0x13, 0x25, 0x15, 0xCD, 0x59,
+	0x06, 0xC8, 0x43, 0xAD, 0x89, 0x9A, 0x46, 0x7C
+};
+
+static const u_int8_t out[] = {
+	0x10, 0x92, 0x99, 0xE1, 0xA2, 0x38, 0x29, 0xCC,
+	0x32, 0x4B, 0xE2, 0x94, 0xA9, 0xE3, 0x9D, 0xBE,
+	0x86, 0x96, 0x1C, 0x60, 0x3A, 0xF8, 0x3C, 0x67,
+	0x3F, 0x6D, 0x7B, 0x34, 0x74, 0x69, 0x4C, 0x8D,
+	0xF1, 0x35, 0x07, 0xB4, 0xB3, 0xD1, 0x0C, 0xB3,
+	0x68, 0x6F, 0x5A, 0x95, 0xD8, 0xA8, 0x0F, 0x99,
+	0xAD, 0x7B, 0xE1, 0x04, 0x05, 0x82, 0x90, 0x06,
+	0xC9, 0xB3, 0x35, 0x34, 0xCE, 0xF0, 0xB2, 0x67,
+	0xA3, 0xF5, 0xDC, 0xFF, 0x4F, 0xDD, 0xEF, 0x5D,
+	0x11, 0x08, 0xB4, 0x9B, 0x7E, 0x7C, 0xAE, 0x78,
+	0x2A, 0x25, 0x9F, 0xF3, 0x24, 0x22, 0x4D, 0xFC,
+	0x23, 0x37, 0x9E, 0xA5, 0xD6, 0xF2, 0xC5, 0x2F,
+	0x7D, 0xB5, 0x32, 0x7B, 0xE8, 0x6A, 0x1B, 0x5A,
+	0xEB, 0xE0, 0x54, 0x2F, 0x25, 0xFD, 0x94, 0xD5,
+	0x8D, 0x71, 0x41, 0x04, 0x75, 0x35, 0xAF, 0x79,
+	0xB7, 0x4B, 0xEE, 0x93, 0xC6, 0x21, 0xE8, 0x99,
+	0xAE, 0x9F, 0xD4, 0xEF, 0x11, 0xEE, 0xD2, 0x17,
+	0x94, 0xC7, 0x42, 0x81, 0xF8, 0x90, 0xA4, 0x56,
+	0xB3, 0x46, 0x10, 0x00, 0x91, 0xDD, 0x2D, 0x31,
+	0x96, 0x72, 0xA1, 0xEF, 0xD2, 0xB2, 0x1C, 0x69,
+	0xA8, 0x76, 0x72, 0xC9, 0x01, 0x1C, 0xD0, 0x8C,
+	0x0D, 0x96, 0x18, 0x63, 0x93, 0x37, 0x42, 0x0E,
+	0x2B, 0x39, 0xB6, 0x23, 0xDA, 0xF7, 0xBB, 0x6B,
+	0xEA, 0x7E, 0x89, 0xE9, 0xEC, 0x58, 0xAE, 0xC1,
+	0x57, 0x1A, 0x21, 0x2A, 0x6D, 0x1D, 0xF1, 0x1B,
+	0x14, 0xCD, 0xC0, 0xB4, 0x28, 0x0C, 0x69, 0x33,
+	0x47, 0x42, 0x6F, 0x4F, 0x67, 0x63, 0x3F, 0x96,
+	0x89, 0xD4, 0x03, 0x31, 0xBB, 0x8C, 0x9F, 0x79,
+	0xEC, 0xAA, 0xE7, 0x07, 0xCE, 0x62, 0x42, 0x8E,
+	0x49, 0xD7, 0x8E, 0x7C, 0x4B, 0x3E, 0xDE, 0x05
+};
+
+static const u_int8_t iv[] = {
+	0x75, 0x16, 0x99, 0x21, 0x49, 0x73, 0x71, 0x63,
+	0x1E, 0x7F, 0xC6, 0x9E, 0x2C, 0xB4, 0xDF, 0x24
+};
+
+static const u_int8_t key[] = {
+	0xEF, 0x4A, 0x6F, 0x4A, 0x52, 0x32, 0xE8, 0x0E,
+	0x2E, 0x3A, 0x3B, 0xF4, 0x00, 0x5E, 0xA7, 0x74,
+	0xFB, 0x93, 0xFE, 0x1C, 0x4D, 0xAD, 0xA3, 0x02,
+	0xE4, 0xF5, 0x71, 0xD7, 0xE6, 0x07, 0xF6, 0x87
+};
+
+#define AES_TESTSET_SIZE 240
+#define AES_KEY_SIZE 32
+#define AES_IV_SIZE 16
+
+extern wait_queue_head_t jqtest_wq;
+
+void jq_blkcipher_done(struct device *dev, u32 *head, u32 status, void *auxarg)
+{
+	(*(int *)auxarg)++;
+	wake_up_interruptible(&jqtest_wq);
+}
+
+
+int jq_aes_cbc_shared(struct device *dev, int show)
+{
+	int stat, exit, rtnval = 0;
+	u32 *sdesc, *jdesc, *sdmap, *jdmap;
+	u8 *inbuf, *outbuf, *inmap, *outmap;
+	u16 sdsz, jdsz, inbufsz, outbufsz;
+	int jqarg;
+
+	sdsz = 64 * sizeof(u32);
+	jdsz = 16 * sizeof(u32);
+	inbufsz = AES_TESTSET_SIZE;
+	outbufsz = AES_TESTSET_SIZE;
+
+	sdesc = kzalloc(sdsz, GFP_KERNEL | GFP_DMA);
+	jdesc = kzalloc(jdsz, GFP_KERNEL | GFP_DMA);
+	inbuf = kmalloc(inbufsz, GFP_KERNEL | GFP_DMA);
+	outbuf = kmalloc(outbufsz, GFP_KERNEL | GFP_DMA);
+
+
+	if ((sdesc == NULL) || (jdesc == NULL) ||
+	    (inbuf == NULL) || (outbuf == NULL)) {
+		printk(KERN_INFO "jq_aes_cbc_shared: can't get buffers\n");
+		kfree(sdesc);
+		kfree(jdesc);
+		kfree(inbuf);
+		kfree(outbuf);
+		return -1;
+	};
+
+	memcpy(inbuf, in, inbufsz);
+
+	stat = cnstr_shdsc_cbc_blkcipher(sdesc, &sdsz, (u_int8_t *)key,
+					 AES_KEY_SIZE * 8,
+					 (u_int8_t *)iv, AES_IV_SIZE * 8,
+					 DIR_DECRYPT, OP_ALG_ALGSEL_AES, 0);
+	if (stat) {
+		printk(KERN_INFO
+		       "jq_aes_cbc_shared: sharedesc construct failed\n");
+		kfree(sdesc);
+		kfree(jdesc);
+		kfree(inbuf);
+		kfree(outbuf);
+		return -1;
+	};
+
+	sdmap = (u32 *)dma_map_single(dev, sdesc, sdsz, DMA_BIDIRECTIONAL);
+	inmap = (u8 *)dma_map_single(dev, inbuf, inbufsz, DMA_TO_DEVICE);
+	outmap = (u8 *)dma_map_single(dev, outbuf, outbufsz, DMA_FROM_DEVICE);
+
+	cnstr_seq_jobdesc(jdesc, &jdsz, sdmap, sdsz, inmap, inbufsz,
+			  outmap, outbufsz);
+
+	jdmap = (u32 *)dma_map_single(dev, jdesc, jdsz, DMA_TO_DEVICE);
+
+	if (show == SHOW_DESC) {
+		caam_desc_disasm(jdesc);
+		caam_desc_disasm(sdesc);
+	}
+
+	stat = caam_jq_enqueue(dev, jdesc, jq_blkcipher_done, (void *)&jqarg);
+	if (stat) {
+		printk(KERN_INFO "jq_aes_cbc_shared: can't enqueue\n");
+		rtnval = -1;
+	}
+	exit = wait_event_interruptible(jqtest_wq, (jqarg));
+	if (exit)
+		printk(KERN_INFO "jq_aes_cbc_shared: interrupted\n");
+
+	dma_unmap_single(dev, (u32)sdmap, sdsz, DMA_BIDIRECTIONAL);
+	dma_unmap_single(dev, (u32)jdmap, jdsz, DMA_TO_DEVICE);
+	dma_unmap_single(dev, (u32)inmap, inbufsz, DMA_TO_DEVICE);
+	dma_unmap_single(dev, (u32)outmap, outbufsz, DMA_FROM_DEVICE);
+
+	if (memcmp(out, outbuf, outbufsz)) {
+		printk(KERN_INFO "jq_aes_cbc_shared: output mismatch\n");
+		printk(KERN_INFO "0x%02x 0x%02x 0x%02x 0x%02x\n",
+			outbuf[0], outbuf[1], outbuf[2], outbuf[3]);
+	}
+
+	kfree(sdesc);
+	kfree(jdesc);
+	kfree(inbuf);
+	kfree(outbuf);
+
+	return rtnval;
+}
+
+int jq_aes_cbc_job(struct device *dev, int show)
+{
+	int stat, exit, rtnval = 0;
+	u32 *jdesc;
+	u8 *inbuf, *outbuf, *inmap, *outmap;
+	u8 *keybuf, *keymap, *ivbuf, *ivmap;
+	u16 jdsz, inbufsz, outbufsz;
+	int jqarg;
+
+	jdsz = 64 * sizeof(u32);
+	jdesc = kzalloc(jdsz, GFP_KERNEL | GFP_DMA);
+
+	inbufsz = AES_TESTSET_SIZE;
+	outbufsz = AES_TESTSET_SIZE;
+	inbuf = kmalloc(inbufsz, GFP_KERNEL | GFP_DMA);
+	outbuf = kmalloc(outbufsz, GFP_KERNEL | GFP_DMA);
+	keybuf = kzalloc(AES_KEY_SIZE, GFP_KERNEL | GFP_DMA);
+	ivbuf = kzalloc(AES_IV_SIZE, GFP_KERNEL | GFP_DMA);
+
+	if ((jdesc == NULL) || (inbuf == NULL) || (outbuf == NULL) ||
+	    (keybuf == NULL) || (ivbuf == NULL)) {
+		printk(KERN_INFO "jq_aes_cbc_job: can't get buffers\n");
+		kfree(jdesc);
+		kfree(inbuf);
+		kfree(outbuf);
+		kfree(keybuf);
+		kfree(ivbuf);
+		return -1;
+	};
+
+	memcpy(inbuf, in, inbufsz);
+	memcpy(keybuf, key, AES_KEY_SIZE);
+	memcpy(ivbuf, iv, AES_IV_SIZE);
+
+	inmap = (u8 *)dma_map_single(dev, inbuf, inbufsz, DMA_TO_DEVICE);
+	outmap = (u8 *)dma_map_single(dev, outbuf, outbufsz, DMA_FROM_DEVICE);
+	keymap = (u8 *)dma_map_single(dev, keybuf, AES_KEY_SIZE, DMA_TO_DEVICE);
+	ivmap = (u8 *)dma_map_single(dev, ivbuf, AES_IV_SIZE, DMA_TO_DEVICE);
+
+	stat = cnstr_jobdesc_blkcipher_cbc(jdesc, &jdsz, inmap, outmap,
+					   AES_TESTSET_SIZE,
+					   (u_int8_t *)keymap,
+					   AES_KEY_SIZE * 8,
+					   (u_int8_t *)ivmap, AES_IV_SIZE * 8,
+					   DIR_DECRYPT, OP_ALG_ALGSEL_AES, 0);
+	if (stat) {
+		printk(KERN_INFO
+		       "jq_aes_cbc_job: jobdesc construct failed\n");
+		kfree(jdesc);
+		return -1;
+	};
+
+	if (show == SHOW_DESC)
+		caam_desc_disasm(jdesc);
+
+	stat = caam_jq_enqueue(dev, jdesc, jq_blkcipher_done, (void *)&jqarg);
+	if (stat) {
+		printk(KERN_INFO "jq_aes_cbc_job: can't enqueue\n");
+		rtnval = -1;
+	}
+	exit = wait_event_interruptible(jqtest_wq, (jqarg));
+	if (exit)
+		printk(KERN_INFO "jq_aes_cbc_job: interrupted\n");
+
+	dma_unmap_single(dev, (u32)inmap, inbufsz, DMA_TO_DEVICE);
+	dma_unmap_single(dev, (u32)outmap, outbufsz, DMA_FROM_DEVICE);
+	dma_unmap_single(dev, (u32)keymap, AES_KEY_SIZE, DMA_TO_DEVICE);
+	dma_unmap_single(dev, (u32)ivmap, AES_IV_SIZE, DMA_TO_DEVICE);
+
+	if (memcmp(out, outbuf, outbufsz))
+		printk(KERN_INFO "jq_aes_cbc_job: output mismatch\n");
+
+	kfree(jdesc);
+	kfree(inbuf);
+	kfree(outbuf);
+	kfree(keybuf);
+	kfree(ivbuf);
+
+	return rtnval;
+}
diff --git a/drivers/crypto/caam/jq_test/jq_ipsec.c b/drivers/crypto/caam/jq_test/jq_ipsec.c
index f478f22..24e91cf 100644
--- a/drivers/crypto/caam/jq_test/jq_ipsec.c
+++ b/drivers/crypto/caam/jq_test/jq_ipsec.c
@@ -15,6 +15,11 @@
  *       names of its contributors may be used to endorse or promote products
  *       derived from this software without specific prior written permission.
  *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
  * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
diff --git a/drivers/crypto/caam/jq_test/jq_snow.c b/drivers/crypto/caam/jq_test/jq_snow.c
new file mode 100644
index 0000000..8f890de
--- /dev/null
+++ b/drivers/crypto/caam/jq_test/jq_snow.c
@@ -0,0 +1,280 @@
+/*
+ * jq_snow.c - JobQ unit test for SNOW examples
+ *
+ * Copyright (c) 2009, Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "caam_jqtest.h"
+
+/*
+ * Case taken from SNOW conformance document, UEA2 case #1
+ * Last byte 0x7c from 0x78 on account of length change from
+ * 253 bits to 16 bytes
+ */
+static u_int8_t snow_key[] = {
+	0xd3, 0xc5, 0xd5, 0x92,
+	0x32, 0x7f, 0xb1, 0x1c,
+	0x40, 0x35, 0xc6, 0x68,
+	0x0a, 0xf8, 0xc6, 0xd1
+};
+
+#define SNOW_F8_TESTSET_SIZE 32
+
+static u_int8_t input_msg_data[] = {
+	0x98, 0x1b, 0xa6, 0x82,
+	0x4c, 0x1b, 0xfb, 0x1a,
+	0xb4, 0x85, 0x47, 0x20,
+	0x29, 0xb7, 0x1d, 0x80,
+	0x8c, 0xe3, 0x3e, 0x2c,
+	0xc3, 0xc0, 0xb5, 0xfc,
+	0x1f, 0x3d, 0xe8, 0xa6,
+	0xdc, 0x66, 0xb1, 0xf0
+};
+
+static u_int8_t output_msg_data[] = {
+	0x5d, 0x5b, 0xfe, 0x75,
+	0xeb, 0x04, 0xf6, 0x8c,
+	0xe0, 0xa1, 0x23, 0x77,
+	0xea, 0x00, 0xb3, 0x7d,
+	0x47, 0xc6, 0xa0, 0xba,
+	0x06, 0x30, 0x91, 0x55,
+	0x08, 0x6a, 0x85, 0x9c,
+	0x43, 0x41, 0xb3, 0x7c
+};
+
+static const u_int32_t count = 0x398a59b4;
+static const u_int8_t bearer = 0x15;
+static const u_int8_t direction = 0x1;
+
+extern wait_queue_head_t jqtest_wq;
+
+void jq_snow_done(struct device *dev, u32 *head, u32 status, void *auxarg)
+{
+	/* Bump volatile completion test value and wake calling thread */
+	(*(int *)auxarg)++;
+	wake_up_interruptible(&jqtest_wq);
+}
+
+int jq_snow_f8(struct device *dev, int show)
+{
+	int stat, exit, rtnval = 0;
+	u32 *sdesc, *jdesc, *sdmap;
+	u8 *inbuf, *outbuf, *inmap, *outmap;
+	u16 sdsz, jdsz, inbufsz, outbufsz;
+	int jqarg;
+
+	jqarg = 0;
+
+	/* Allocate more than necessary for both descs */
+	sdsz = 64 * sizeof(u32);
+	jdsz = 16 * sizeof(u32);
+	sdesc = kzalloc(sdsz, GFP_KERNEL | GFP_DMA);
+	jdesc = kzalloc(jdsz, GFP_KERNEL | GFP_DMA);
+
+	/* Allocate buffers */
+	inbufsz = SNOW_F8_TESTSET_SIZE;
+	outbufsz = SNOW_F8_TESTSET_SIZE;
+	inbuf = kmalloc(inbufsz, GFP_KERNEL | GFP_DMA);
+	outbuf = kmalloc(outbufsz, GFP_KERNEL | GFP_DMA);
+
+	if ((sdesc == NULL) || (jdesc == NULL) ||
+	    (inbuf == NULL) || (outbuf == NULL)) {
+		printk(KERN_INFO "jq_snow_f8: can't get buffers\n");
+		kfree(sdesc);
+		kfree(jdesc);
+		kfree(inbuf);
+		kfree(outbuf);
+		return -1;
+	};
+
+	memcpy(inbuf, input_msg_data, inbufsz);
+
+	stat = cnstr_shdsc_snow_f8(sdesc, &sdsz, snow_key, 128,
+				   DIR_ENCRYPT, count, bearer, direction,
+				   0);
+
+	if (stat) {
+		printk(KERN_INFO
+		       "jq_snow_f8: sharedesc construct failed\n");
+		kfree(sdesc);
+		kfree(jdesc);
+		return -1;
+	};
+
+	/* Map data prior to jobdesc build */
+	sdmap = (u32 *)dma_map_single(dev, sdesc, sdsz, DMA_BIDIRECTIONAL);
+
+	inmap = (u8 *)dma_map_single(dev, inbuf, inbufsz, DMA_TO_DEVICE);
+	outmap = (u8 *)dma_map_single(dev, outbuf, outbufsz, DMA_FROM_DEVICE);
+
+	/* build jobdesc */
+	cnstr_seq_jobdesc(jdesc, &jdsz, sdmap, sdsz, inmap, inbufsz,
+			  outmap, outbufsz);
+
+	/* Show it before we run it */
+	if (show == SHOW_DESC) {
+		caam_desc_disasm(jdesc);
+		caam_desc_disasm(sdesc);
+	}
+
+	/* Enqueue and block*/
+	stat = caam_jq_enqueue(dev, jdesc, jq_snow_done, (void *)&jqarg);
+	if (stat) {
+		printk(KERN_INFO "jq_snow_f8: can't enqueue\n");
+		rtnval = -1;
+	}
+	exit = wait_event_interruptible(jqtest_wq, (jqarg));
+	if (exit)
+		printk(KERN_INFO "jq_snow_f8: interrupted\n");
+
+	dma_unmap_single(dev, (u32)sdmap, sdsz, DMA_BIDIRECTIONAL);
+	dma_unmap_single(dev, (u32)inmap, inbufsz, DMA_TO_DEVICE);
+	dma_unmap_single(dev, (u32)outmap, outbufsz, DMA_FROM_DEVICE);
+
+	if (memcmp(output_msg_data, outbuf, outbufsz))
+		printk(KERN_INFO "jq_snow_f8: output mismatch\n");
+
+	kfree(sdesc);
+	kfree(jdesc);
+	kfree(inbuf);
+	kfree(outbuf);
+
+	return rtnval;
+}
+
+
+static const unsigned char uia2_key[] =
+{
+    0x2b, 0xd6, 0x45, 0x9f, 0x82, 0xc5, 0xb3, 0x00,
+    0x95, 0x2c, 0x49, 0x10, 0x48, 0x81, 0xff, 0x48
+};
+
+static const unsigned char uia2_in[] =
+{
+    0x33, 0x32, 0x34, 0x62, 0x63, 0x39, 0x38, 0x61,
+    0x37, 0x34, 0x79
+};
+
+static const unsigned char uia2_out[] =
+{
+    0xee, 0x41, 0x9e, 0x0d
+};
+
+static const u_int32_t uia2_count = 0x38a6f056;
+static const u_int32_t uia2_fresh = 0xb8aefda9;
+static const u_int8_t uia2_dir;
+
+int jq_snow_f9(struct device *dev, int show)
+{
+	int stat, exit, rtnval = 0;
+	u32 *sdesc, *jdesc, *sdmap;
+	u8 *inbuf, *outbuf, *inmap, *outmap;
+	u16 sdsz, jdsz, inbufsz, outbufsz;
+	int jqarg;
+
+	jqarg = 0;
+
+	/* Allocate more than necessary for both descs */
+	sdsz = 64 * sizeof(u32);
+	jdsz = 16 * sizeof(u32);
+	sdesc = kzalloc(sdsz, GFP_KERNEL | GFP_DMA);
+	jdesc = kzalloc(jdsz, GFP_KERNEL | GFP_DMA);
+
+	/* Allocate buffers */
+	inbufsz = 11;
+	outbufsz = 4;
+	inbuf = kmalloc(inbufsz, GFP_KERNEL | GFP_DMA);
+	outbuf = kmalloc(outbufsz, GFP_KERNEL | GFP_DMA);
+
+	if ((sdesc == NULL) || (jdesc == NULL) ||
+	    (inbuf == NULL) || (outbuf == NULL)) {
+		printk(KERN_INFO "jq_snow_f9: can't get buffers\n");
+		kfree(sdesc);
+		kfree(jdesc);
+		kfree(inbuf);
+		kfree(outbuf);
+		return -1;
+	};
+
+	memcpy(inbuf, uia2_in, inbufsz);
+
+	stat = cnstr_shdsc_snow_f9(sdesc, &sdsz, (u_int8_t *)uia2_key, 128,
+				   DIR_ENCRYPT, uia2_count, uia2_fresh,
+				   uia2_dir, 0);
+
+	if (stat) {
+		printk(KERN_INFO
+		       "jq_snow_f9: sharedesc construct failed\n");
+		kfree(sdesc);
+		kfree(jdesc);
+		return -1;
+	};
+
+	/* Map data prior to jobdesc build */
+	sdmap = (u32 *)dma_map_single(dev, sdesc, sdsz, DMA_BIDIRECTIONAL);
+	inmap = (u8 *)dma_map_single(dev, inbuf, inbufsz, DMA_TO_DEVICE);
+	outmap = (u8 *)dma_map_single(dev, outbuf, outbufsz, DMA_FROM_DEVICE);
+
+	/* build jobdesc */
+	cnstr_seq_jobdesc(jdesc, &jdsz, sdmap, sdsz, inmap, inbufsz,
+			  outmap, outbufsz);
+
+	/* Show it before we run it */
+	if (show == SHOW_DESC) {
+		caam_desc_disasm(jdesc);
+		caam_desc_disasm(sdesc);
+	}
+
+	/* Enqueue and block*/
+	stat = caam_jq_enqueue(dev, jdesc, jq_snow_done, (void *)&jqarg);
+	if (stat) {
+		printk(KERN_INFO "jq_snow_f9: can't enqueue\n");
+		rtnval = -1;
+	}
+	exit = wait_event_interruptible(jqtest_wq, (jqarg));
+	if (exit)
+		printk(KERN_INFO "jq_snow_f9: interrupted\n");
+
+	dma_unmap_single(dev, (u32)sdmap, sdsz, DMA_BIDIRECTIONAL);
+	dma_unmap_single(dev, (u32)inmap, inbufsz, DMA_TO_DEVICE);
+	dma_unmap_single(dev, (u32)outmap, outbufsz, DMA_FROM_DEVICE);
+
+	if (memcmp(uia2_out, outbuf, outbufsz))
+		printk(KERN_INFO "jq_snow_f9: output mismatch\n");
+
+	kfree(sdesc);
+	kfree(jdesc);
+	kfree(inbuf);
+	kfree(outbuf);
+
+	return rtnval;
+}
+
diff --git a/drivers/crypto/caam/regs.h b/drivers/crypto/caam/regs.h
index 01a22da..e8cf409 100644
--- a/drivers/crypto/caam/regs.h
+++ b/drivers/crypto/caam/regs.h
@@ -15,6 +15,11 @@
  *       names of its contributors may be used to endorse or promote products
  *       derived from this software without specific prior written permission.
  *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
  * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-- 
1.6.3.3

