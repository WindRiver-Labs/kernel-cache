From 8f93f9d0961413f82ff4b6e41d4ca7f4d159e4aa Mon Sep 17 00:00:00 2001
From: Geoff Thorpe <Geoff.Thorpe@freescale.com>
Date: Thu, 28 Jan 2010 00:16:49 -0500
Subject: [PATCH] qman: avoid regression on rev1 from rev2 changes.

As the FD address has been unilaterally downgraded from 48-bits to 40-bits, make
sure the upper 8-bits don't contain uninitialised (non-zero) data when running
on rev1 (which carries all 48-bits through the data path).

Signed-off-by: Geoff Thorpe <Geoff.Thorpe@freescale.com>
[Kevin: Original patch taken from Freescale p4080 SDK 2.0.2 tar
package, apply cleanly to kernel 2.6.27]
Integrated-by: Kevin Hao <kexin.hao@windriver.com>
---
 drivers/hwqueue/qman_low.c |   24 ++++++++++++++++++++++++
 1 files changed, 24 insertions(+), 0 deletions(-)

diff --git a/drivers/hwqueue/qman_low.c b/drivers/hwqueue/qman_low.c
index ef7c992..4f6928c 100644
--- a/drivers/hwqueue/qman_low.c
+++ b/drivers/hwqueue/qman_low.c
@@ -257,11 +257,33 @@ do { \
 	QM_ASSERT(eqcr->cursor->fqid == (eqcr->cursor->fqid & 0x00ffffff)); \
 } while(0)
 
+#ifdef CONFIG_FSL_QMAN_BUG_AND_FEATURE_REV1
+static inline void eqcr_fd_fixup(struct qm_eqcr_entry *eq)
+{
+	if (qman_ip_rev == QMAN_REV1) {
+		struct qm_fd *fd = &eq->fd;
+		/* The struct's address went from 48-bit to 40-bit but rev1
+		 * chips will still interpret it as 48-bit, meaning we have to
+		 * scrub the upper 8-bits in that case, just in case the user
+		 * left noise in there. NB, this code is the most explicit but
+		 * if the compiler doesn't optimise it (they are 4-bits each of
+		 * the same byte), it may be more efficient to do;
+		 *    ((u8 *)fd)[2] = 0;
+		 */
+		fd->eliodn_offset = 0;
+		fd->__reserved = 0;
+	}
+}
+#else
+#define eqcr_fd_fixup(fd) do { ; } while (0)
+#endif
+
 void qm_eqcr_pci_commit(struct qm_portal *portal, u8 myverb)
 {
 	EQCR_API_START();
 	EQCR_COMMIT_CHECKS(eqcr);
 	QM_ASSERT(eqcr->pmode == qm_eqcr_pci);
+	eqcr_fd_fixup(eqcr->cursor);
 	eqcr->cursor->__dont_write_directly__verb = myverb | eqcr->vbit;
 	EQCR_INC(eqcr);
 	eqcr->available--;
@@ -288,6 +310,7 @@ void qm_eqcr_pce_commit(struct qm_portal *portal, u8 myverb)
 	EQCR_API_START();
 	EQCR_COMMIT_CHECKS(eqcr);
 	QM_ASSERT(eqcr->pmode == qm_eqcr_pce);
+	eqcr_fd_fixup(eqcr->cursor);
 	eqcr->cursor->__dont_write_directly__verb = myverb | eqcr->vbit;
 	EQCR_INC(eqcr);
 	eqcr->available--;
@@ -306,6 +329,7 @@ void qm_eqcr_pvb_commit(struct qm_portal *portal, u8 myverb)
 	struct qm_eqcr_entry *eqcursor;
 	EQCR_COMMIT_CHECKS(eqcr);
 	QM_ASSERT(eqcr->pmode == qm_eqcr_pvb);
+	eqcr_fd_fixup(eqcr->cursor);
 	lwsync();
 	eqcursor = eqcr->cursor;
 	eqcursor->__dont_write_directly__verb = myverb | eqcr->vbit;
-- 
1.6.0.4

