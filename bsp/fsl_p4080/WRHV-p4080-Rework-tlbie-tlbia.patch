From f6ace6754e2f2a718c5f0319256908511244d4e3 Mon Sep 17 00:00:00 2001
From: Tiejun Chen <tiejun.chen@windriver.com>
Date: Fri, 5 Feb 2010 23:00:08 -0800
Subject: [PATCH 1/4] WRHV/p4080: Rework tlbie/tlbia

Here drop the original workaround tlbie/tlbia way. We use tlbivax to
invalidate one TLB entry, and tlbilx 0 with IPI to boradcasp all cpus
to invalidate all TLB entries dedicated to the given partition.

And note when enable EE we also should handle those pending interrupt
by the HyperCall.

Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 arch/powerpc/include/asm/tlbflush.h |   11 ++++++
 arch/powerpc/kernel/wrhv_misc_32.S  |   58 +++++++++++++++++------------------
 2 files changed, 39 insertions(+), 30 deletions(-)

diff --git a/arch/powerpc/include/asm/tlbflush.h b/arch/powerpc/include/asm/tlbflush.h
index 361cd5c..2432775 100644
--- a/arch/powerpc/include/asm/tlbflush.h
+++ b/arch/powerpc/include/asm/tlbflush.h
@@ -33,8 +33,19 @@ extern void _tlbie(unsigned long address, unsigned int pid);
 #if defined(CONFIG_40x) || defined(CONFIG_8xx)
 #define _tlbia()	asm volatile ("tlbia; sync" : : : "memory")
 #else /* CONFIG_44x || CONFIG_FSL_BOOKE */
+#if defined(CONFIG_WRHV_P4080DS) && defined(CONFIG_SMP)
+extern void local_tlbia(void *param);
+/*
+ * Use tlbilx 0 with IPI to boradcast all CPUs.
+ */
+static inline void _tlbia(void)
+{
+	on_each_cpu(local_tlbia, NULL, 1);
+}
+#else
 extern void _tlbia(void);
 #endif
+#endif
 
 static inline void flush_tlb_mm(struct mm_struct *mm)
 {
diff --git a/arch/powerpc/kernel/wrhv_misc_32.S b/arch/powerpc/kernel/wrhv_misc_32.S
index 3e13033..a1b7d07 100644
--- a/arch/powerpc/kernel/wrhv_misc_32.S
+++ b/arch/powerpc/kernel/wrhv_misc_32.S
@@ -64,25 +64,28 @@ _GLOBAL(paravirt_tlbia)
         bne     11b
 #endif  /* CONFIG_SMP */
 
-	/* FIXME: Currently we cannot get our LPID so let's assume the hypervisor 
-	 * will update this for us.
-	 */
-	/*  The HY will check which privileged instruction trap privileged 
-	 *  exception via r3. 
-	 */
-	lis     r3, TLBIVAX_CODE@h
-	ori     r3, r3, TLBIVAX_CODE@l
-	/* Invalidate all entries in TLB0 */
-	li      r4, 0x04
-	tlbivax 0,4
-	/* Invalidate all entries in TLB1 */
-	li      r4, 0x0c
-	tlbivax 0,4
+#ifdef CONFIG_SMP
+_GLOBAL(local_tlbia)
+#endif
+	/* tlbilx with T = 0 */
+	.long   0x7c001824
+	msync
+	isync
+#ifdef CONFIG_SMP
+	blr
+#endif
 
 #ifdef CONFIG_SMP
         li      r0, 0
         stw     r0, 0(r8)
         wrtee   r11
+	/* When enable EE we should handle the pending interrupt */
+	rlwinm  r11, r11, 0, 16, 16;      /* test EE bit */       
+	beq     1f
+	lis     r0, VBI_SYS_int_enable@h;                
+	ori     r0, r0, VBI_SYS_int_enable@l;             
+	sc	1
+1:
 #endif /* CONFIG_SMP */
 #endif
 	blr
@@ -109,28 +112,23 @@ _GLOBAL(paravirt_tlbie)
 	stwcx.	r5, 0, r8
 	bne	11b
 #endif	/* CONFIG_SMP */
-	
-	/* FIXME: Use tlbia as tlbie temporarily since there are some issue on IPIs.
-	 */
-	/* FIXME: Currently we cannot get our LPID so let's assume the hypervisor 
-	 * will update this for us.
-	 */
-	/*  The HY will check which privileged instruction trap privileged 
-	 *  exception via r3. 
-	 */
+	rlwinm  r4, r3, 0, 0, 19
+	ori     r5, r4, 0x08    /* TLBSEL = 1 */
 	lis     r3, TLBIVAX_CODE@h
 	ori     r3, r3, TLBIVAX_CODE@l
-	/* Invalidate all entries in TLB0 */
-	li      r4, 0x04
-	tlbivax 0,4
-	/* Invalidate all entries in TLB1 */
-	li      r4, 0x0c
-	tlbivax 0,4
-
+	tlbivax 0, r4
+	tlbivax 0, r5
 #if defined(CONFIG_SMP)
 	li	r0, 0
 	stw	r0, 0(r8)
 	wrtee	r11
+	/* When enable EE we should handle the pending interrupt */
+	rlwinm  r11, r11, 0, 16, 16;      /* test EE bit */       
+	beq     1f
+	lis     r0, VBI_SYS_int_enable@h;                
+	ori     r0, r0, VBI_SYS_int_enable@l;             
+	sc	1
+1:
 #endif /* CONFIG_SMP */
 #endif
 	blr
-- 
1.6.5.2

