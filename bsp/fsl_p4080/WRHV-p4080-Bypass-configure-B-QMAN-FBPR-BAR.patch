From ee518428a78521eeba5429e702f94673a9ee5802 Mon Sep 17 00:00:00 2001
From: Kevin Hao <kexin.hao@windriver.com>
Date: Tue, 25 May 2010 10:59:30 +0800
Subject: [PATCH 5/5] WRHV/p4080: Bypass configure B/QMAN FBPR BAR

While booting guest OS, VxWorks will think that BAR address configured
from Linux as invalid address. And often BootROM will configure that as well.
So here we assume FBPR BAR is already configured correctly if that value is
nonzero, then don't configure that again on Linux.

Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 drivers/hwalloc/bman_config.c |   11 ++++++--
 drivers/hwqueue/qman_config.c |   53 ++++++++++++++++++++++------------------
 2 files changed, 37 insertions(+), 27 deletions(-)

diff --git a/drivers/hwalloc/bman_config.c b/drivers/hwalloc/bman_config.c
index f76094a..c53e2e3 100644
--- a/drivers/hwalloc/bman_config.c
+++ b/drivers/hwalloc/bman_config.c
@@ -179,9 +179,14 @@ static void bm_set_memory(struct bman *bm, u16 eba, u32 ba, int prio, u32 size)
 			is_power_of_2(size));
 	/* choke if '[e]ba' has lower-alignment than 'size' */
 	BM_ASSERT(!(ba & (size - 1)));
-	bm_out(FBPR_BARE, eba);
-	bm_out(FBPR_BAR, ba);
-	bm_out(FBPR_AR, (prio ? 0x40000000 : 0) | (exp - 1));
+	/* We assume FBPR BAR is already configured correctly
+	 * if that value is nonzero.
+	 */
+	if ((bm_in(FBPR_BAR)) == 0) {
+		bm_out(FBPR_BARE, eba);
+		bm_out(FBPR_BAR, ba);
+		bm_out(FBPR_AR, (prio ? 0x40000000 : 0) | (exp - 1));
+	}
 }
 
 /*****************/
diff --git a/drivers/hwqueue/qman_config.c b/drivers/hwqueue/qman_config.c
index 61c4580..628252d 100644
--- a/drivers/hwqueue/qman_config.c
+++ b/drivers/hwqueue/qman_config.c
@@ -486,10 +486,6 @@ static int __init fsl_qman_init(struct device_node *node)
 		pr_err("Can't get %s property '%s'\n", node->full_name, "reg");
 		return ret;
 	}
-	ret = parse_mem_property(node, "fsl,qman-fqd", &fqd_a, &fqd_sz, 1);
-	BUG_ON(ret);
-	ret = parse_mem_property(node, "fsl,qman-pfdr", &pfdr_a, &pfdr_sz, 0);
-	BUG_ON(ret);
 	/* Global configuration */
 	regs = ioremap(res.start, res.end - res.start + 1);
 	qm = qm_create(regs);
@@ -497,26 +493,35 @@ static int __init fsl_qman_init(struct device_node *node)
 	pr_info("Qman ver:%04x,%02x,%02x\n", id, major, minor);
 	if (!qman_ip_rev)
 		qman_ip_rev = ((u16)major << 8) | minor;
-	/* FQD memory */
-	qm_set_memory(qm, qm_memory_fqd, (u16)((u64)fqd_a >> 32), (u32)fqd_a,
-			1, 0, 0, fqd_sz);
-	/* PFDR memory */
-	qm_set_memory(qm, qm_memory_pfdr, (u16)((u64)pfdr_a >> 32), (u32)pfdr_a,
-			1, 0, 0, pfdr_sz);
-	qm_init_pfdr(qm, 8, pfdr_sz / 64 - 8);
-	/* thresholds */
-	qm_set_pfdr_threshold(qm, 32, 32);
-	qm_set_sfdr_threshold(qm, 128);
-	/* corenet initiator settings */
-	qm_set_corenet_initiator(qm);
-	/* HID settings */
-	qm_set_hid(qm);
-	/* Set scheduling weights to defaults */
-	for (ret = qm_wq_first; ret <= qm_wq_last; ret++)
-		qm_set_wq_scheduling(qm, ret, 0, 0, 0, 0, 0, 0, 0);
-	/* We are not prepared to accept ERNs for hardware enqueues */
-	qm_set_dc(qm, qm_dc_portal_fman0, 1, 0);
-	qm_set_dc(qm, qm_dc_portal_fman1, 1, 0);
+	/* We assume FQD BAR is already configured correctly
+	 * if that value is nonzero.
+	 */
+	if((__qm_in(qm, REG_FQD_BARE + REG_offset_BAR)) == 0) {
+		ret = parse_mem_property(node, "fsl,qman-fqd", &fqd_a, &fqd_sz, 1);
+		BUG_ON(ret);
+		ret = parse_mem_property(node, "fsl,qman-pfdr", &pfdr_a, &pfdr_sz, 0);
+		BUG_ON(ret);
+		/* FQD memory */
+		qm_set_memory(qm, qm_memory_fqd, (u16)((u64)fqd_a >> 32), (u32)fqd_a,
+				1, 0, 0, fqd_sz);
+		/* PFDR memory */
+		qm_set_memory(qm, qm_memory_pfdr, (u16)((u64)pfdr_a >> 32), (u32)pfdr_a,
+				1, 0, 0, pfdr_sz);
+		qm_init_pfdr(qm, 8, pfdr_sz / 64 - 8);
+		/* thresholds */
+		qm_set_pfdr_threshold(qm, 32, 32);
+		qm_set_sfdr_threshold(qm, 128);
+		/* corenet initiator settings */
+		qm_set_corenet_initiator(qm);
+		/* HID settings */
+		qm_set_hid(qm);
+		/* Set scheduling weights to defaults */
+		for (ret = qm_wq_first; ret <= qm_wq_last; ret++)
+			qm_set_wq_scheduling(qm, ret, 0, 0, 0, 0, 0, 0, 0);
+		/* We are not prepared to accept ERNs for hardware enqueues */
+		qm_set_dc(qm, qm_dc_portal_fman0, 1, 0);
+		qm_set_dc(qm, qm_dc_portal_fman1, 1, 0);
+	}
 	/* Workaround for bug 3594: "PAMU Address translation exception during
 	 * qman dqrr stashing". */
 	if (sizeof(dma_addr_t) <= sizeof(u32))
-- 
1.6.5.2

