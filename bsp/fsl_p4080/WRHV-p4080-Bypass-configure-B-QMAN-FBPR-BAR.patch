From c23cde8899c2d1b794e371440069dcf49a55a3ab Mon Sep 17 00:00:00 2001
From: Tiejun Chen <tiejun.chen@windriver.com>
Date: Thu, 25 Feb 2010 02:45:43 -0800
Subject: [PATCH] WRHV/p4080: Bypass configure B/QMAN FBPR BAR

While booting guest OS, VxWorks will think that BAR address configured
from Linux as invalid address. And often BootROM will configure that as well.
So here we assume FBPR BAR is already configured correctly if that value is
nonzero, then don't configure that again on Linux.

Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/hwalloc/bman_config.c |   11 ++++++++---
 drivers/hwqueue/qman_config.c |   21 +++++++++++++--------
 2 files changed, 21 insertions(+), 11 deletions(-)

diff --git a/drivers/hwalloc/bman_config.c b/drivers/hwalloc/bman_config.c
index a957d88..cfa380c 100644
--- a/drivers/hwalloc/bman_config.c
+++ b/drivers/hwalloc/bman_config.c
@@ -179,9 +179,14 @@ static void bm_set_memory(struct bman *bm, u16 eba, u32 ba, int prio, u32 size)
 			is_power_of_2(size));
 	/* choke if '[e]ba' has lower-alignment than 'size' */
 	BM_ASSERT(!(ba & (size - 1)));
-	bm_out(FBPR_BARE, eba);
-	bm_out(FBPR_BAR, ba);
-	bm_out(FBPR_AR, (prio ? 0x40000000 : 0) | (exp - 1));
+	/* We assume FBPR BAR is already configured correctly 
+	 * if that value is nonzero. 
+	 */
+	if ((bm_in(FBPR_BAR)) == 0) {
+		bm_out(FBPR_BARE, eba);
+		bm_out(FBPR_BAR, ba);
+		bm_out(FBPR_AR, (prio ? 0x40000000 : 0) | (exp - 1));
+	}
 }
 
 /*****************/
diff --git a/drivers/hwqueue/qman_config.c b/drivers/hwqueue/qman_config.c
index e751427..b5c7da8 100644
--- a/drivers/hwqueue/qman_config.c
+++ b/drivers/hwqueue/qman_config.c
@@ -461,14 +461,19 @@ static int __init fsl_qman_init(struct device_node *node)
 	qm = qm_create(regs);
 	qm_get_version(qm, &id, &major, &minor);
 	pr_info("Qman ver:%04x,%02x,%02x\n", id, major, minor);
-	/* FQD memory */
-	qm_set_memory(qm, qm_memory_fqd, 0, (u32)fqd_a, 1, 0, 0, fqd_sz);
-	/* PFDR memory */
-	qm_set_memory(qm, qm_memory_pfdr, 0, (u32)pfdr_a, 1, 0, 0, pfdr_sz);
-	qm_init_pfdr(qm, 8, pfdr_sz / 64 - 8);
-	/* thresholds */
-	qm_set_pfdr_threshold(qm, 32, 32);
-	qm_set_sfdr_threshold(qm, 128);
+	/* We assume FQD BAR is already configured correctly 
+	 * if that value is nonzero. 
+	 */
+	if((__qm_in(qm, REG_FQD_BARE + REG_offset_BAR)) == 0) {
+		/* FQD memory */
+		qm_set_memory(qm, qm_memory_fqd, 0, (u32)fqd_a, 1, 0, 0, fqd_sz);
+		/* PFDR memory */
+		qm_set_memory(qm, qm_memory_pfdr, 0, (u32)pfdr_a, 1, 0, 0, pfdr_sz);
+		qm_init_pfdr(qm, 8, pfdr_sz / 64 - 8);
+		/* thresholds */
+		qm_set_pfdr_threshold(qm, 32, 32);
+		qm_set_sfdr_threshold(qm, 128);
+	}
 	/* Workaround for bug 3594: "PAMU Address translation exception during
 	 * qman dqrr stashing". */
 	if (sizeof(dma_addr_t) <= sizeof(u32))
-- 
1.6.5.2

