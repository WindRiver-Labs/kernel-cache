From b01d652d58e088aa3d15fd567dd6960f9ea6509e Mon Sep 17 00:00:00 2001
From: Li Yang <leoli@freescale.com>
Date: Thu, 24 Sep 2009 10:07:57 +0800
Subject: [PATCH 35/52] Fix BMAN/QMAN/PME to support 36-bit PTE

Although these drivers may not be able to operate correctly on
addresses larger than 32-bit, make they work with 64-bit physical
address and don't panic unless the true address is above 4G.

This is useful to systems which has larger memory, but
Linux only manage the lower part of the memory under 4G.

Signed-off-by: Li Yang <leoli@freescale.com>
[KevinHao: Original patch taken from Freescale
P4080_WRlinux-rc2_20090915 tarball vendor drop.
Remove the part for PME]
Integrated-by: Kevin Hao <kexin.hao@windriver.com>
---
 drivers/hwalloc/bman_config.c |    5 ++---
 drivers/hwqueue/qman_config.c |    6 ++----
 drivers/hwqueue/qman_high.c   |    2 +-
 3 files changed, 5 insertions(+), 8 deletions(-)

diff --git a/drivers/hwalloc/bman_config.c b/drivers/hwalloc/bman_config.c
index f76094a..a957d88 100644
--- a/drivers/hwalloc/bman_config.c
+++ b/drivers/hwalloc/bman_config.c
@@ -212,10 +212,9 @@ static __init int parse_mem_property(struct device_node *node, const char *name,
 		return 0;
 	}
 	pr_info("Using %s property '%s'\n", node->full_name, name);
-	/* Props are 64-bit, but dma_addr_t is (currently) 32-bit */
-	BUG_ON(sizeof(*addr) != 4);
+	/* No high bits above 32bit */
 	BUG_ON(pint[0] || pint[2]);
-	*addr = pint[1];
+	*addr = (dma_addr_t)pint[1];
 	*sz = pint[3];
 	/* Keep things simple, it's either all in the DRAM range or it's all
 	 * outside. */
diff --git a/drivers/hwqueue/qman_config.c b/drivers/hwqueue/qman_config.c
index 62f12b5..e751427 100644
--- a/drivers/hwqueue/qman_config.c
+++ b/drivers/hwqueue/qman_config.c
@@ -405,10 +405,9 @@ static __init int parse_mem_property(struct device_node *node, const char *name,
 		return 0;
 	}
 	pr_info("Using %s property '%s'\n", node->full_name, name);
-	/* Props are 64-bit, but dma_addr_t is (currently) 32-bit */
-	BUG_ON(sizeof(*addr) != 4);
+	/* No high bits above 32bit */
 	BUG_ON(pint[0] || pint[2]);
-	*addr = pint[1];
+	*addr = (dma_addr_t)pint[1];
 	*sz = pint[3];
 	/* Keep things simple, it's either all in the DRAM range or it's all
 	 * outside. */
@@ -448,7 +447,6 @@ static int __init fsl_qman_init(struct device_node *node)
 	u16 id;
 	u8 major, minor;
 
-	BUG_ON(sizeof(dma_addr_t) != sizeof(u32));
 	ret = of_address_to_resource(node, 0, &res);
 	if (ret) {
 		pr_err("Can't get %s property '%s'\n", node->full_name, "reg");
diff --git a/drivers/hwqueue/qman_high.c b/drivers/hwqueue/qman_high.c
index 94eeb6d..77df570 100644
--- a/drivers/hwqueue/qman_high.c
+++ b/drivers/hwqueue/qman_high.c
@@ -918,7 +918,6 @@ int qman_init_fq(struct qman_fq *fq, u32 flags, struct qm_mcc_initfq *opts)
 	if ((flags & QMAN_INITFQ_FLAG_NULL) ||
 			fq_isclear(fq, QMAN_FQ_FLAG_TO_DCPORTAL)) {
 		dma_addr_t phys_fq;
-		BUG_ON(sizeof(phys_fq) > sizeof(u32));
 		mcc->initfq.we_mask |= QM_INITFQ_WE_CONTEXTB;
 		mcc->initfq.fqd.context_b = (flags & QMAN_INITFQ_FLAG_NULL) ?
 						0 : (u32)fq;
@@ -931,6 +930,7 @@ int qman_init_fq(struct qman_fq *fq, u32 flags, struct qm_mcc_initfq *opts)
 		}
 		phys_fq = dma_map_single(&p->pdev->dev, fq, sizeof(*fq),
 					DMA_TO_DEVICE);
+		BUG_ON(phys_fq > 0xffffffff);
 		mcc->initfq.fqd.context_a.context_hi = 0;
 		mcc->initfq.fqd.context_a.context_lo = (u32)phys_fq;
 	}
-- 
1.6.3.3

