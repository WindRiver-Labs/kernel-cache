From 4dc965223ee2022f19b4ff414509b2fe64a14e97 Mon Sep 17 00:00:00 2001
From: Kim Phillips <kim.phillips@freescale.com>
Date: Fri, 7 May 2010 15:54:10 +0800
Subject: [PATCH 09/11] crypto: caam - algapi: utilize all available job queues

providing the cryptoAPI with more devices to do the same algorithm
results in cryptoAPI always using the 1st that registered.

managing our own job queue scheduling, however, (currently based on
cpu_id % total_job_queues) proves to help performance: getting ~250kpps
pretty regularly now (from 200-210kpps) - guaranteed 15% improvement
(up to 25% observed) (test was 60-byte pktgen packets through two
8-way 4080s).

Signed-off-by: Kim Phillips <kim.phillips@freescale.com>
Signed-off-by: Roy Zang <tie-fei.zang@freescale.com>
[Kevin: Original patch taken from Freescale p4080 SDK 2.1 ISO image.
Apply cleanly to kernel 2.6.27]
Integrated-by: Kevin Hao <kexin.hao@windriver.com>
---
 drivers/crypto/caam/algapi.c |   40 ++++++++++++++++++++++++++++++----------
 1 files changed, 30 insertions(+), 10 deletions(-)

diff --git a/drivers/crypto/caam/algapi.c b/drivers/crypto/caam/algapi.c
index 073e3ef..a954c06 100644
--- a/drivers/crypto/caam/algapi.c
+++ b/drivers/crypto/caam/algapi.c
@@ -58,6 +58,8 @@
  */
 
 #include "compat.h"
+#include <linux/percpu.h>
+
 #include "regs.h"
 #include "intern.h"
 #include "desc.h"
@@ -115,6 +117,8 @@ struct ipsec_deco_dpovrd {
 	u8 next_header;	/* reserved if decap */
 } __packed;
 
+static DEFINE_PER_CPU(int, cpu_to_job_queue);
+
 static int aead_authenc_setauthsize(struct crypto_aead *authenc,
 				    unsigned int authsize)
 {
@@ -406,9 +410,11 @@ Split key generation-----------------------------------------------
 static u32 gen_split_key(struct device *dev, struct caam_ctx *ctx,
 			 const u8 *key_in, u32 authkeylen)
 {
+	struct caam_drv_private *priv = dev_get_drvdata(dev);
 	u32 *desc, *desc_pos;
 	struct split_key_result result;
 	dma_addr_t dma_addr_in, dma_addr_out;
+	struct device *tgt_jq_dev;
 	int ret = 0;
 
 	/* FIXME: may need to look at keyspec instead of basing on inkeysize */
@@ -480,7 +486,9 @@ static u32 gen_split_key(struct device *dev, struct caam_ctx *ctx,
 	result.err = 0;
 	init_completion(&result.completion);
 
-	ret = caam_jq_enqueue(dev, desc, split_key_done, &result);
+	tgt_jq_dev = priv->algapi_jq[per_cpu(cpu_to_job_queue,
+				     smp_processor_id())];
+	ret = caam_jq_enqueue(tgt_jq_dev, desc, split_key_done, &result);
 	if (!ret) {
 		/* in progress */
 		wait_for_completion_interruptible(&result.completion);
@@ -738,6 +746,8 @@ static int ipsec_esp(struct ipsec_esp_edesc *edesc, struct aead_request *areq,
 	struct crypto_aead *aead = crypto_aead_reqtfm(areq);
 	struct caam_ctx *ctx = crypto_aead_ctx(aead);
 	struct device *dev = ctx->dev;
+	struct caam_drv_private *priv = dev_get_drvdata(dev);
+	struct device *tgt_jq_dev;
 	struct scatterlist *sg;
 	u32 *desc = edesc->hw_desc;
 	u32 *descptr = desc;
@@ -967,7 +977,9 @@ static int ipsec_esp(struct ipsec_esp_edesc *edesc, struct aead_request *areq,
 	caam_desc_disasm(desc, DISASM_SHOW_OFFSETS | DISASM_SHOW_RAW);
 #endif
 
-	ret = caam_jq_enqueue(dev, desc, callback, areq);
+	tgt_jq_dev = priv->algapi_jq[per_cpu(cpu_to_job_queue,
+					     smp_processor_id())];
+	ret = caam_jq_enqueue(tgt_jq_dev, desc, callback, areq);
 	if (!ret)
 		ret = -EINPROGRESS;
 	else {
@@ -1281,42 +1293,50 @@ static struct caam_crypto_alg *caam_alg_alloc(struct device *dev,
 void caam_jq_algapi_init(struct device *ctrldev)
 {
 	struct caam_drv_private *priv = dev_get_drvdata(ctrldev);
-	struct device *dev;
-	int i, err;
+	struct device **dev;
+	int i = 0, err = 0, cpu;
 
 	INIT_LIST_HEAD(&priv->alg_list);
 
-	err = caam_jq_register(ctrldev, &dev);
-	if (err) {
+	dev = kmalloc(sizeof(*dev) * priv->total_jobqs, GFP_KERNEL);
+	for (i = 0; i < priv->total_jobqs; i++) {
+		err = caam_jq_register(ctrldev, &dev[i]);
+		if (err < 0)
+			break;
+	}
+	if (err < 0 && i == 0) {
 		dev_err(ctrldev, "algapi error in job queue registration: %d\n",
 			err);
 		return;
 	}
+	priv->num_jqs_for_algapi = i;
 
 	/* register crypto algorithms the device supports */
 	for (i = 0; i < ARRAY_SIZE(driver_algs); i++) {
 		/* TODO: check if h/w supports alg */
 		struct caam_crypto_alg *t_alg;
 
-		t_alg = caam_alg_alloc(dev, &driver_algs[i]);
+		t_alg = caam_alg_alloc(ctrldev, &driver_algs[i]);
 		if (IS_ERR(t_alg)) {
 			err = PTR_ERR(t_alg);
-			dev_warn(dev, "%s alg registration failed\n",
+			dev_warn(ctrldev, "%s alg registration failed\n",
 				t_alg->crypto_alg.cra_driver_name);
 			continue;
 		}
 
 		err = crypto_register_alg(&t_alg->crypto_alg);
 		if (err) {
-			dev_warn(dev, "%s alg registration failed\n",
+			dev_warn(ctrldev, "%s alg registration failed\n",
 				t_alg->crypto_alg.cra_driver_name);
 			kfree(t_alg);
 		} else {
 			list_add_tail(&t_alg->entry, &priv->alg_list);
-			dev_info(dev, "%s\n",
+			dev_info(ctrldev, "%s\n",
 				 t_alg->crypto_alg.cra_driver_name);
 		}
 	}
 
 	priv->algapi_jq = dev;
+	for_each_online_cpu(cpu)
+		per_cpu(cpu_to_job_queue, cpu) = cpu % priv->num_jqs_for_algapi;
 }
-- 
1.6.5.2

