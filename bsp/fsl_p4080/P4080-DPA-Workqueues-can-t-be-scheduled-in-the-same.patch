From d718026ecd5b49cebaebb2c3f5f70f4da34bf5d2 Mon Sep 17 00:00:00 2001
From: Emil Medve <Emilian.Medve@freescale.com>
Date: Tue, 13 Oct 2009 14:31:53 -0500
Subject: [PATCH] P4080/DPA: Workqueues can't be scheduled in the same time on multiple CPUs

A work queue can be scheduled sequentially on multiple CPUs, but on in the same time. Thus, add a
workqueue for each CPU so we can process packets with all the CPUs in parallel

Signed-off-by: Emil Medve <Emilian.Medve@Freescale.com>
[Kevin: Original patch taken from Freescale p4080 SDK 2.0 ISO image.
Apply cleanly to kernel 2.6.27]
Integrated-by: Kevin Hao <kexin.hao@windriver.com>
---
 drivers/net/dpa/dpa.c |   19 ++++++++++---------
 drivers/net/dpa/dpa.h |    4 ++--
 2 files changed, 12 insertions(+), 11 deletions(-)

diff --git a/drivers/net/dpa/dpa.c b/drivers/net/dpa/dpa.c
index 811ca5c..ba42f95 100644
--- a/drivers/net/dpa/dpa.c
+++ b/drivers/net/dpa/dpa.c
@@ -896,7 +896,7 @@ ingress_rx_default_dqrr(struct qman_portal		*portal,
 	percpu_priv->count++;
 	percpu_priv->max = max(percpu_priv->max, percpu_priv->count);
 
-	schedule_work(&priv->fd_work);
+	schedule_work(&percpu_priv->fd_work);
 
 _return:
 	if (netif_msg_intr(priv))
@@ -1319,13 +1319,17 @@ static void __hot dpa_rx(struct work_struct *fd_work)
 	unsigned long flags;
 #endif
 
-	priv = (typeof(priv))container_of(fd_work, struct dpa_priv_s, fd_work);
-	net_dev = priv->net_dev;
+	percpu_priv = (typeof(percpu_priv))container_of(
+		fd_work, struct dpa_percpu_priv_s, fd_work);
+	net_dev = percpu_priv->net_dev;
+	priv = (typeof(priv))netdev_priv(net_dev);
 
 	if (netif_msg_rx_status(priv))
 		cpu_netdev_dbg(net_dev, "-> %s:%s()\n", __file__, __func__);
 
-	percpu_priv = per_cpu_ptr(priv->percpu_priv, smp_processor_id());
+	BUG_ON(percpu_priv != per_cpu_ptr(priv->percpu_priv,
+					  smp_processor_id()));
+
 	list_for_each_entry_safe(dpa_fd, tmp, &percpu_priv->fd_list, list) {
 		skb = NULL;
 
@@ -2210,7 +2214,6 @@ dpa_probe(struct of_device *_of_dev)
 	dev_set_drvdata(dev, net_dev);
 
 	priv = (typeof(priv))netdev_priv(net_dev);
-	priv->net_dev = net_dev;
 
 	priv->msg_enable = netif_msg_init(debug, -1);
 
@@ -2299,8 +2302,6 @@ dpa_probe(struct of_device *_of_dev)
 	for (i = 0; i < ARRAY_SIZE(priv->dpa_fq_list); i++)
 		INIT_LIST_HEAD(priv->dpa_fq_list + i);
 
-	INIT_WORK(&priv->fd_work, dpa_rx);
-
 	priv->percpu_priv = (typeof(priv->percpu_priv))__alloc_percpu(
 		sizeof(*priv->percpu_priv));
 	if (unlikely(priv->percpu_priv == NULL)) {
@@ -2315,9 +2316,9 @@ dpa_probe(struct of_device *_of_dev)
 	for_each_online_cpu(i) {
 		percpu_priv = per_cpu_ptr(priv->percpu_priv, i);
 
+		percpu_priv->net_dev = net_dev;
+		INIT_WORK(&percpu_priv->fd_work, dpa_rx);
 		INIT_LIST_HEAD(&percpu_priv->fd_list);
-		percpu_priv->count	= 0;
-		percpu_priv->max	= 0;
 	}
 
 	/* FM */
diff --git a/drivers/net/dpa/dpa.h b/drivers/net/dpa/dpa.h
index b7c5f16..039cd28 100644
--- a/drivers/net/dpa/dpa.h
+++ b/drivers/net/dpa/dpa.h
@@ -52,12 +52,13 @@ struct pcd_range {
 #endif /* CONFIG_FSL_FMAN_TEST */
 
 struct dpa_percpu_priv_s {
+	struct net_device	*net_dev;
+	struct work_struct	 fd_work;
 	struct list_head	fd_list;
 	size_t			count, max;
 };
 
 struct dpa_priv_s {
-	struct net_device	*net_dev;
 	struct list_head	 dpa_bp_list;
 
 	uint16_t		 channel;
@@ -70,7 +71,6 @@ struct dpa_priv_s {
 
 	struct mac_device	*mac_dev;
 
-	struct work_struct	 fd_work;
 	struct dpa_percpu_priv_s	*percpu_priv;
 
 	uint32_t		 msg_enable;	/* net_device message level */
-- 
1.6.0.4

