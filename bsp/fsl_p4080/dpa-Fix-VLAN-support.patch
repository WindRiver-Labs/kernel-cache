From d3e5214ba1138240edd88a98c5acb5124794e0d5 Mon Sep 17 00:00:00 2001
From: Andy Fleming <afleming@freescale.com>
Date: Wed, 28 Oct 2009 02:28:34 -0500
Subject: [PATCH 079/148] dpa: Fix VLAN support

When using DPA with a VLAN, the reserved space was being partially used
for the VLAN tag, which meant that we no longer had DPA_BP_HEAD
available.  However, we only really needed 4 bytes for the skb pointer,
so rather than do some very complicated math, we just back up to the
beginning of the buffer, and put the skb pointer there.  (If there isn't
even room for the skb pointer, we call skb_realloc_headroom()).

Signed-off-by: Andy Fleming <afleming@freescale.com>
[Applied FSL SDK 2.0.3 patch "kernel-2.6.30-dpa-Fix-VLAN-support.patch"]
Integrated-by: Yuri Nedel <Yuri.Nedel@windriver.com>
---
 drivers/net/dpa/dpa.c |   24 +++++++++++++++++++++---
 1 files changed, 21 insertions(+), 3 deletions(-)

diff --git a/drivers/net/dpa/dpa.c b/drivers/net/dpa/dpa.c
index 71748d5..ebe2371 100644
--- a/drivers/net/dpa/dpa.c
+++ b/drivers/net/dpa/dpa.c
@@ -1552,6 +1552,7 @@ static int __hot dpa_tx(struct sk_buff *skb, struct net_device *net_dev)
 	struct qm_fd		 fd;
 	struct dpa_bp		*dpa_bp = NULL;
 	struct bm_buffer	*bmb = NULL;
+	unsigned int	headroom;
 
 	priv = (typeof(priv))netdev_priv(net_dev);
 	dev = net_dev->dev.parent;
@@ -1564,10 +1565,27 @@ static int __hot dpa_tx(struct sk_buff *skb, struct net_device *net_dev)
 
 	memset(&fd, 0, sizeof(fd));
 	fd.format	= qm_fd_contig;
-	fd.offset	= DPA_BP_HEAD;
+
+	headroom = skb_headroom(skb);
+
+	if (headroom < sizeof(skb)) {
+		struct sk_buff *skb_new;
+
+		skb_new = skb_realloc_headroom(skb, DPA_BP_HEAD);
+		if (!skb_new) {
+			net_dev->stats.tx_errors++;
+			kfree_skb(skb);
+			return NETDEV_TX_OK;
+		}
+		kfree_skb(skb);
+		skb = skb_new;
+		headroom = DPA_BP_HEAD;
+	}
+
+	fd.offset	= headroom;
 
 	if (priv->mac_dev) {
-		*((typeof(&skb))skb_push(skb, DPA_BP_HEAD)) = skb;
+		*((typeof(&skb))skb_push(skb, headroom)) = skb;
 
 		fd.addr_lo = dma_map_single(dev, skb->data, skb_headlen(skb),
 				DMA_TO_DEVICE);
@@ -1579,7 +1597,7 @@ static int __hot dpa_tx(struct sk_buff *skb, struct net_device *net_dev)
 			goto _return_dev_kfree_skb;
 		}
 
-		fd.length20	= skb_headlen(skb) - DPA_BP_HEAD;
+		fd.length20	= skb_headlen(skb) - headroom;
 	} else {
 		dpa_bp = dpa_size2pool(&priv->dpa_bp_list, skb_headlen(skb));
 		BUG_ON(IS_ERR(dpa_bp));
-- 
1.6.5.2

