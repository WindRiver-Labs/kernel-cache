From beb18eff9f7a84bb3fc06447b7e513123a217b53 Mon Sep 17 00:00:00 2001
From: Greg Moffatt <greg.moffatt@windriver.com>
Date: Fri, 20 Nov 2009 08:10:59 -0800
Subject: [PATCH] dpa: Fix VLAN support

Extracted from the P4080_SDK_B2.0_20091110.iso vendor drop.

When using DPA with a VLAN, the reserved space was being partially used
for the VLAN tag, which meant that we no longer had DPA_BP_HEAD
available.  However, we only really needed 4 bytes for the skb pointer,
so rather than do some very complicated math, we just back up to the
beginning of the buffer, and put the skb pointer there.  (If there isn't
even room for the skb pointer, we call skb_realloc_headroom()).

Signed-off-by: Andy Fleming <afleming@freescale.com>

[ Integrated into WRS Linux.
  Had to adjust patch slightly to apply to WRS kernel.
  Functionality is unchanged from the original patch. ]

Signed-off-by: Greg Moffatt <greg.moffatt@windriver.com>
---
 drivers/net/dpa/dpa.c |   24 +++++++++++++++++++++---
 1 files changed, 21 insertions(+), 3 deletions(-)

diff --git a/drivers/net/dpa/dpa.c b/drivers/net/dpa/dpa.c
index 36cac7a..e200580 100644
--- a/drivers/net/dpa/dpa.c
+++ b/drivers/net/dpa/dpa.c
@@ -1580,6 +1580,7 @@ static int __hot dpa_tx(struct sk_buff *skb, struct net_device *net_dev)
 	struct qm_fd		 fd;
 	struct dpa_bp		*dpa_bp = NULL;
 	struct bm_buffer	*bmb = NULL;
+	unsigned int		 headroom;
 
 	priv = (typeof(priv))netdev_priv(net_dev);
 	dev = net_dev->dev.parent;
@@ -1592,10 +1593,27 @@ static int __hot dpa_tx(struct sk_buff *skb, struct net_device *net_dev)
 
 	memset(&fd, 0, sizeof(fd));
 	fd.format	= qm_fd_contig;
-	fd.offset	= DPA_BP_HEAD;
+
+	headroom = skb_headroom(skb);
+
+	if (headroom < sizeof(skb)) {
+		struct sk_buff *skb_new;
+
+		skb_new = skb_realloc_headroom(skb, DPA_BP_HEAD);
+		if (!skb_new) {
+			net_dev->stats.tx_errors++;
+			kfree_skb(skb);
+			return NETDEV_TX_OK;
+		}
+		kfree_skb(skb);
+		skb = skb_new;
+		headroom = DPA_BP_HEAD;
+	}
+
+	fd.offset = headroom;
 
 	if (priv->mac_dev) {
-		*((typeof(&skb))skb_push(skb, DPA_BP_HEAD)) = skb;
+		*((typeof(&skb))skb_push(skb, headroom)) = skb;
 
 		fd.addr_lo	= dma_map_single(dev, skb->data, skb_headlen(skb), DMA_TO_DEVICE);
 		if (unlikely(fd.addr_lo == 0)) {
@@ -1605,7 +1623,7 @@ static int __hot dpa_tx(struct sk_buff *skb, struct net_device *net_dev)
 			goto _return_dev_kfree_skb;
 		}
 
-		fd.length20	= skb_headlen(skb) - DPA_BP_HEAD;
+		fd.length20	= skb_headlen(skb) - headroom;
 	} else {
 		dpa_bp = dpa_size2pool(&priv->dpa_bp_list, skb_headlen(skb));
 		BUG_ON(IS_ERR(dpa_bp));
-- 
1.6.5.2

