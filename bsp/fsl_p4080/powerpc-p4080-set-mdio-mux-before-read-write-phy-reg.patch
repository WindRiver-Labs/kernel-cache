From 23ace3fd3b0be2e7f5374f6bbb32abd7ad52d619 Mon Sep 17 00:00:00 2001
From: Kevin Hao <kexin.hao@windriver.com>
Date: Thu, 22 Oct 2009 10:37:32 +0800
Subject: [PATCH 2/3] powerpc/p4080: set mdio mux before read/write phy register

GPIOs are used to control the MDIO multiplexers. So we have to
set the mux before read/write phy register.

Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 drivers/net/fsl_pq_mdio.c |   62 +++++++++++++++++++++++++++++++++++++++++++++
 1 files changed, 62 insertions(+), 0 deletions(-)

diff --git a/drivers/net/fsl_pq_mdio.c b/drivers/net/fsl_pq_mdio.c
index af114fb..5151d81 100644
--- a/drivers/net/fsl_pq_mdio.c
+++ b/drivers/net/fsl_pq_mdio.c
@@ -101,6 +101,63 @@ int fsl_pq_local_mdio_read(struct fsl_pq_mdio __iomem *regs,
 	return value;
 }
 
+#ifdef CONFIG_P4080_DS
+#define EMI1_SLOT5	0xc0000000
+#define EMI_MASK	0xf0000000
+
+static u32 __iomem *fsl_mdio_mux_addr;
+
+static void fsl_mdio_mux_init(void)
+{
+	struct device_node *np;
+	u64 addr, size;
+
+	np = of_find_compatible_node(NULL, NULL, "fsl,p4080-gpio");
+
+	if (!np) {
+		printk(KERN_ERR "Can't get \"fsp,p4080-gpio\" device node\n");
+		return;
+	}
+
+	addr = of_translate_address(np, of_get_address(np, 0, &size, NULL));
+
+	fsl_mdio_mux_addr = ioremap(addr, size);
+	if (!fsl_mdio_mux_addr)
+		return;
+
+	/* reference to the gpio data register */
+	fsl_mdio_mux_addr += 2;
+}
+
+static void fsl_mdio_mux_exit(void)
+{
+	iounmap(fsl_mdio_mux_addr);
+}
+
+static void fsl_mdio_set_mux(int mii_id)
+{
+	u32 tmp;
+
+	if (!fsl_mdio_mux_addr)
+		return;
+
+	tmp = in_be32(fsl_mdio_mux_addr);
+	tmp &= ~EMI_MASK;
+
+	/*
+	 * Currently we only support RGMII and FM1 SGMII, when id is 0
+	 * it's RGMII, otherwise SGMII.
+	 */
+	if (mii_id)
+		tmp |= EMI1_SLOT5;
+
+	out_be32(fsl_mdio_mux_addr, tmp);
+}
+#else
+static void fsl_mdio_mux_init(void) {}
+static void fsl_mdio_set_mux(int mii_id) {}
+static void fsl_mdio_mux_exit(void) {}
+#endif
 /*
  * Write value to the PHY at mii_id at register regnum,
  * on the bus, waiting until the write is done before returning.
@@ -109,6 +166,7 @@ int fsl_pq_mdio_write(struct mii_bus *bus, int mii_id, int regnum, u16 value)
 {
 	struct fsl_pq_mdio __iomem *regs = (void __iomem *)bus->priv;
 
+	fsl_mdio_set_mux(mii_id);
 	/* Write to the local MII regs */
 	return(fsl_pq_local_mdio_write(regs, mii_id, regnum, value));
 }
@@ -122,6 +180,8 @@ int fsl_pq_mdio_read(struct mii_bus *bus, int mii_id, int regnum)
 	struct fsl_pq_mdio __iomem *regs = (void __iomem *)bus->priv;
 
 	/* Read the local MII regs */
+
+	fsl_mdio_set_mux(mii_id);
 	return(fsl_pq_local_mdio_read(regs, mii_id, regnum));
 }
 
@@ -398,6 +458,7 @@ static int fsl_pq_mdio_probe(struct of_device *ofdev,
 	if (of_device_is_compatible(np, "fsl,fman-mdio"))
 		new_bus->phy_mask = 0;
 
+	fsl_mdio_mux_init();
 	err = mdiobus_register(new_bus);
 
 	if (err) {
@@ -428,6 +489,7 @@ static int fsl_pq_mdio_remove(struct of_device *ofdev)
 
 	dev_set_drvdata(device, NULL);
 
+	fsl_mdio_mux_exit();
 	iounmap((void __iomem *)bus->priv);
 	bus->priv = NULL;
 	kfree(bus);
-- 
1.6.5.rc3

