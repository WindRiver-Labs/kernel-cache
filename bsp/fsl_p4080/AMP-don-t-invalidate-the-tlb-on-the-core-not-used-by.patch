From 514a7a7f2e81ca978e21720b35302776bc84c12d Mon Sep 17 00:00:00 2001
From: Kevin Hao <kexin.hao@windriver.com>
Date: Mon, 30 Nov 2009 03:33:18 -0800
Subject: [PATCH 3/4] AMP: don't invalidate the tlb on the core not used by linux

When IA bit is set tlbivax will also invalidate all the tlb entries
on other processors. This is fine when linux works in SMP mode. But
when in AMP mode, this behavior maybe cause other OS corrupt. So we
will use tlbivax + lgid to invalidate a single tlb entry, and
tlbilx + IPI to invlidate all the tlb entries on processors that are
used by linux.

Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 arch/powerpc/include/asm/reg_booke.h   |    6 +++++
 arch/powerpc/include/asm/tlbflush.h    |    7 ++++++
 arch/powerpc/kernel/head_fsl_booke.S   |   35 +++++++++++++++++++++++++++++++-
 arch/powerpc/kernel/misc_32.S          |   12 +++++++++++
 arch/powerpc/kernel/setup_32.c         |    4 +++
 arch/powerpc/mm/fsl_booke_mmu.c        |    5 ++++
 arch/powerpc/platforms/Kconfig.cputype |   11 ++++++++++
 7 files changed, 79 insertions(+), 1 deletions(-)

diff --git a/arch/powerpc/include/asm/reg_booke.h b/arch/powerpc/include/asm/reg_booke.h
index 081fca4..8b9807a 100644
--- a/arch/powerpc/include/asm/reg_booke.h
+++ b/arch/powerpc/include/asm/reg_booke.h
@@ -46,6 +46,8 @@
 #define SPRN_IAC4	0x13B	/* Instruction Address Compare 4 */
 #define SPRN_DVC1	0x13E	/* Data Value Compare Register 1 */
 #define SPRN_DVC2	0x13F	/* Data Value Compare Register 2 */
+#define SPRN_LPIDR	0x152	/* Logical PID Register */
+#define SPRN_MAS8	0x155	/* MMU Assist Register 8 */
 #define SPRN_IVOR0	0x190	/* Interrupt Vector Offset Register 0 */
 #define SPRN_IVOR1	0x191	/* Interrupt Vector Offset Register 1 */
 #define SPRN_IVOR2	0x192	/* Interrupt Vector Offset Register 2 */
@@ -90,7 +92,11 @@
 #define SPRN_MAS2	0x272	/* MMU Assist Register 2 */
 #define SPRN_MAS3	0x273	/* MMU Assist Register 3 */
 #define SPRN_MAS4	0x274	/* MMU Assist Register 4 */
+#ifdef CONFIG_PPC_E500MC
+#define SPRN_MAS5	0x153	/* MMU Assist Register 5 */
+#else
 #define SPRN_MAS5	0x275	/* MMU Assist Register 5 */
+#endif
 #define SPRN_MAS6	0x276	/* MMU Assist Register 6 */
 #define SPRN_PID1	0x279	/* Process ID Register 1 */
 #define SPRN_PID2	0x27A	/* Process ID Register 2 */
diff --git a/arch/powerpc/include/asm/tlbflush.h b/arch/powerpc/include/asm/tlbflush.h
index 361cd5c..af57a7f 100644
--- a/arch/powerpc/include/asm/tlbflush.h
+++ b/arch/powerpc/include/asm/tlbflush.h
@@ -32,6 +32,13 @@ extern void _tlbie(unsigned long address, unsigned int pid);
 
 #if defined(CONFIG_40x) || defined(CONFIG_8xx)
 #define _tlbia()	asm volatile ("tlbia; sync" : : : "memory")
+#elif CONFIG_LOGICAL_PARTITION
+extern void local_tlbia(void *data);
+
+static inline void _tlbia(void)
+{
+	on_each_cpu(local_tlbia, NULL, 1);
+}
 #else /* CONFIG_44x || CONFIG_FSL_BOOKE */
 extern void _tlbia(void);
 #endif
diff --git a/arch/powerpc/kernel/head_fsl_booke.S b/arch/powerpc/kernel/head_fsl_booke.S
index 7f1c8db..8ef5d5e 100644
--- a/arch/powerpc/kernel/head_fsl_booke.S
+++ b/arch/powerpc/kernel/head_fsl_booke.S
@@ -93,6 +93,11 @@ _ENTRY(_start);
  */
 
 _ENTRY(__early_start)
+#ifdef CONFIG_LOGICAL_PARTITION
+	/* Set the logical partition id for this core */
+	li	r6,CONFIG_LOGICAL_PARTITION_ID@l
+	mtspr	SPRN_LPIDR,r6
+#endif
 /* 1. Find the index of the entry we're executing in */
 	bl	invstr				/* Find our address */
 invstr:	mflr	r6				/* Make it accessible */
@@ -154,6 +159,10 @@ skpinv:	addi	r6,r6,1				/* Increment */
 	cmpw	r6,r9				/* Are we done? */
 	bne	1b				/* If not, repeat */
 
+#ifdef CONFIG_PPC_E500MC
+	.long	0x7c001824			/* tlbilx 0,0,0 */
+	msync
+#else
 	/* Invalidate TLB0 */
 	li	r6,0x04
 	tlbivax 0,r6
@@ -162,6 +171,7 @@ skpinv:	addi	r6,r6,1				/* Increment */
 	li	r6,0x0c
 	tlbivax 0,r6
 	TLBSYNC
+#endif
 
 /* 3. Setup a temp mapping and jump to it */
 	andi.	r5, r3, 0x1	/* Find an entry not used and is non-zero */
@@ -241,10 +251,15 @@ skpinv:	addi	r6,r6,1				/* Increment */
 	rlwinm	r6,r6,0,2,0	/* clear IPROT */
 	mtspr	SPRN_MAS1,r6
 	tlbwe
+#ifdef CONFIG_PPC_E500MC
+	.long	0x7c001824			/* tlbilx 0,0,0 */
+	msync
+#else
 	/* Invalidate TLB1 */
 	li	r9,0x0c
 	tlbivax 0,r9
 	TLBSYNC
+#endif
 
 /* 6. Setup KERNELBASE mapping in TLB1[0] */
 	lis	r6,0x1000		/* Set MAS0(TLBSEL) = TLB1(1), ESEL = 0 */
@@ -285,10 +300,15 @@ skpinv:	addi	r6,r6,1				/* Increment */
 	rlwinm	r8,r8,0,2,0	/* clear IPROT */
 	mtspr	SPRN_MAS1,r8
 	tlbwe
+#ifdef CONFIG_PPC_E500MC
+	.long	0x7c001824			/* tlbilx 0,0,0 */
+	msync
+#else
 	/* Invalidate TLB1 */
 	li	r9,0x0c
 	tlbivax 0,r9
 	TLBSYNC
+#endif
 
 	/* Establish the interrupt vector offsets */
 	SET_IVOR(0,  CriticalInput);
@@ -368,6 +388,7 @@ skpinv:	addi	r6,r6,1				/* Increment */
 
 	bl	early_init
 
+
 #ifdef CONFIG_RELOCATABLE
 	lis	r3,kernstart_addr@ha
 	la	r3,kernstart_addr@l(r3)
@@ -769,6 +790,10 @@ END_FTR_SECTION_IFSET(CPU_FTR_BIG_PHYS)
 					 * merge with perms */
 	mtspr	SPRN_MAS3, r10
 #endif
+#ifdef CONFIG_LOGICAL_PARTITION
+	li	r10,CONFIG_LOGICAL_PARTITION_ID@l
+	mtspr	SPRN_MAS8,r10
+#endif
 #ifdef CONFIG_E200
 	/* Round robin TLB1 entries assignment */
 	mfspr	r13, SPRN_MAS0
@@ -959,6 +984,10 @@ END_FTR_SECTION_IFSET(CPU_FTR_BIG_PHYS)
 	mtspr	SPRN_MAS0,r10
 #endif /* CONFIG_E200 */
 
+#ifdef CONFIG_LOGICAL_PARTITION
+	li	r10,CONFIG_LOGICAL_PARTITION_ID@l
+	mtspr	SPRN_MAS8,r10
+#endif
 	tlbwe
 
 #ifdef CONFIG_SMP
@@ -1209,7 +1238,7 @@ _GLOBAL(send_lowpri_doorbell)
 _GLOBAL(loadcam_entry)
 	lis	r4,TLBCAM@ha
 	addi	r4,r4,TLBCAM@l
-	mulli	r5,r3,20
+	mulli	r5,r3,24
 	add	r3,r5,r4
 	lwz	r4,0(r3)
 	mtspr	SPRN_MAS0,r4
@@ -1219,6 +1248,10 @@ _GLOBAL(loadcam_entry)
 	mtspr	SPRN_MAS2,r4
 	lwz	r4,12(r3)
 	mtspr	SPRN_MAS3,r4
+#ifdef CONFIG_LOGICAL_PARTITION
+	lwz	r4,20(r3)
+	mtspr	SPRN_MAS8,r4
+#endif
 	tlbwe
 	isync
 	blr
diff --git a/arch/powerpc/kernel/misc_32.S b/arch/powerpc/kernel/misc_32.S
index 8b177b5..067535c 100644
--- a/arch/powerpc/kernel/misc_32.S
+++ b/arch/powerpc/kernel/misc_32.S
@@ -277,6 +277,12 @@ ivax_lock:
 	.space	4
 #endif	/* CONFIG_SMP */
 
+#ifdef CONFIG_LOGICAL_PARTITION
+_GLOBAL(local_tlbia)
+	.long 0x7c001824
+	msync
+	blr
+#else
 /*
  * Flush MMU TLB
  */
@@ -363,6 +369,7 @@ _GLOBAL(_tlbia)
 #endif /* CONFIG_SMP */
 #endif /* ! defined(CONFIG_40x) */
 	blr
+#endif
 
 /*
  * Flush MMU TLB for a particular address
@@ -431,6 +438,11 @@ _GLOBAL(_tlbie)
 
 	rlwinm	r4, r3, 0, 0, 19
 	ori	r5, r4, 0x08	/* TLBSEL = 1 */
+
+#ifdef CONFIG_LOGICAL_PARTITION
+	li	r3,CONFIG_LOGICAL_PARTITION_ID@l
+	mtspr	SPRN_MAS5,r3
+#endif
 	tlbivax	0, r4
 	tlbivax	0, r5
 	msync
diff --git a/arch/powerpc/kernel/setup_32.c b/arch/powerpc/kernel/setup_32.c
index d3bde01..da16462 100644
--- a/arch/powerpc/kernel/setup_32.c
+++ b/arch/powerpc/kernel/setup_32.c
@@ -135,6 +135,10 @@ notrace void __init machine_init(unsigned long dt_ptr, unsigned long phys)
 	    cpu_has_feature(CPU_FTR_CAN_NAP))
 		ppc_md.power_save = e500_idle;
 #endif
+
+#ifdef CONFIG_LOGICAL_PARTITION
+	printk("Logical partition id is %d\n", CONFIG_LOGICAL_PARTITION_ID);
+#endif
 	if (ppc_md.progress)
 		ppc_md.progress("id mach(): done", 0x200);
 }
diff --git a/arch/powerpc/mm/fsl_booke_mmu.c b/arch/powerpc/mm/fsl_booke_mmu.c
index 131d729..149ee65 100644
--- a/arch/powerpc/mm/fsl_booke_mmu.c
+++ b/arch/powerpc/mm/fsl_booke_mmu.c
@@ -67,6 +67,7 @@ struct tlbcam {
 	u32	MAS2;
 	u32	MAS3;
 	u32	MAS7;
+	u32	MAS8;
 } TLBCAM[NUM_TLBCAMS];
 
 struct tlbcamrange {
@@ -144,6 +145,10 @@ void settlbcam(int index, unsigned long virt, phys_addr_t phys,
 	TLBCAM[index].MAS3 |= ((flags & _PAGE_RW) ? MAS3_UW : 0);
 #endif
 
+#ifdef 	CONFIG_LOGICAL_PARTITION
+	TLBCAM[index].MAS8 = CONFIG_LOGICAL_PARTITION_ID;
+#endif
+
 	tlbcam_addrs[index].start = virt;
 	tlbcam_addrs[index].limit = virt + size - 1;
 	tlbcam_addrs[index].phys = phys;
diff --git a/arch/powerpc/platforms/Kconfig.cputype b/arch/powerpc/platforms/Kconfig.cputype
index 3566565..b3314f1 100644
--- a/arch/powerpc/platforms/Kconfig.cputype
+++ b/arch/powerpc/platforms/Kconfig.cputype
@@ -272,4 +272,15 @@ config NOT_COHERENT_CACHE
 config CHECK_CACHE_COHERENCY
 	bool
 
+config LOGICAL_PARTITION
+	bool "Logical partition support"
+	depends on PPC_E500MC
+	default n
+
+config LOGICAL_PARTITION_ID
+	int "Logical partition ID (0-255)"
+	range 0 255
+	depends on LOGICAL_PARTITION
+	default "1"
+
 endmenu
-- 
1.6.5.2

