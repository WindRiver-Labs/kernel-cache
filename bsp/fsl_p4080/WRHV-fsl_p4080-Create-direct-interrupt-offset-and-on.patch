From 52606dc86ed0fe55f539382ca825baa14d46fa23 Mon Sep 17 00:00:00 2001
From: Tiejun Chen <tiejun.chen@windriver.com>
Date: Wed, 12 May 2010 16:39:51 +0800
Subject: [PATCH 14/15] WRHV/fsl_p4080: Create direct interrupt offset and one direct irq flag

Virtual interrupts use the existing IVOR4 and directed interrupts use
a virtual IVOR20. The GIVOR4 will be directed by IVOR20 of the
excOffsetsGet/Set.

The default behaviour will be to use offset 0x2000 (_EXC_OFF_DIRECT_INTR
) for direct interrupts but it can be changed as 0x1600/0x2c00 for UP/SMP.

And provide one cmd line option, wrhv_dir_irq, to determine if enable
direct interrupt mode on guest OS

Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 arch/powerpc/kernel/head_wrhv.S |    4 ++
 arch/powerpc/kernel/vbi/wrhv.c  |   85 ++++++++++++++++++++++++++++++++++++--
 2 files changed, 84 insertions(+), 5 deletions(-)

diff --git a/arch/powerpc/kernel/head_wrhv.S b/arch/powerpc/kernel/head_wrhv.S
index d0e9c4a..0c94a96 100644
--- a/arch/powerpc/kernel/head_wrhv.S
+++ b/arch/powerpc/kernel/head_wrhv.S
@@ -501,6 +501,10 @@ interrupt_base:
 
 	CRITICAL_EXCEPTION(0x2080, CriticalDoorbell, unknown_exception)
 
+#ifdef	CONFIG_PPC85xx_VT_MODE
+	EXCEPTION(0x2090, DirectExternalInput, wrhv_do_direct_IRQ, EXC_XFER_LITE)
+#endif
+
 	/* Debug Interrupt */
 	DEBUG_DEBUG_EXCEPTION
 	DEBUG_CRIT_EXCEPTION
diff --git a/arch/powerpc/kernel/vbi/wrhv.c b/arch/powerpc/kernel/vbi/wrhv.c
index 61837dc..0cada8e 100644
--- a/arch/powerpc/kernel/vbi/wrhv.c
+++ b/arch/powerpc/kernel/vbi/wrhv.c
@@ -257,6 +257,24 @@ int __init wrhv_enable_pci_law(void)
 	return 0;
 }
 
+int wrhv_dir_irq = 0;
+static int __init wrhv_enable_dir_irq(void)
+{
+	const char *opt;
+	opt = strstr(cmd_line, "wrhv_dir_irq=");
+	if (opt) {
+		opt += 13;
+		while (*opt && *opt == ' ')
+			opt++;
+		if (!strncmp(opt, "on", 2))
+			wrhv_dir_irq = 1;
+		else
+			wrhv_dir_irq = 0;
+	}
+
+	return 0;
+}
+
 void wrhv_mapping(void)
 {
 	/* map in vbConfig address */
@@ -554,6 +572,41 @@ unsigned int wrhv_get_direct_irq(void)
 extern inline void check_stack_overflow(void);
 extern inline void handle_one_irq(unsigned int irq);
 
+/* Refer to wrhv_do_IRQ */
+void wrhv_do_direct_IRQ(struct pt_regs *regs)
+{
+	struct pt_regs *old_regs = set_irq_regs(regs);
+	unsigned int irq;
+
+	trace_irq_entry(regs);
+
+	irq_enter();
+
+	check_stack_overflow();
+
+	irq = ppc_md.get_direct_irq();
+
+	if (irq != NO_IRQ && irq != NO_IRQ_IGNORE) {
+		handle_one_irq(irq);
+	} else if (irq != NO_IRQ_IGNORE)
+		__get_cpu_var(irq_stat).spurious_irqs++;
+
+	irq_exit();
+	set_irq_regs(old_regs);
+
+#ifdef CONFIG_PPC_ISERIES
+	if (firmware_has_feature(FW_FEATURE_ISERIES) &&
+			get_lppaca()->int_dword.fields.decr_int) {
+		get_lppaca()->int_dword.fields.decr_int = 0;
+		/* Signal a fake decrementer interrupt */
+		timer_interrupt(regs);
+	}
+#endif
+
+	trace_irq_exit(regs);
+
+}
+
 void wrhv_do_IRQ(struct pt_regs *regs)
 {
 	struct pt_regs *old_regs = set_irq_regs(regs);
@@ -771,6 +824,9 @@ void wrhv_MMU_setup(void)
 #endif
 }
 
+#define E500MC_DIR_EXC_INDEX	20
+#define E500MC_DIR_EXC_OFFSET	0x1600
+
 void __init wrhv_MMU_init(void)
 {
 	if (ppc_md.progress)
@@ -831,20 +887,40 @@ void __init wrhv_MMU_init(void)
 	vb_context_mmu_on(0, swapper_pg_dir, PAGE_SIZE, 0);
 #endif
 
-#ifdef CONFIG_SMP
 	{
+#ifdef CONFIG_SMP
 		int i;
+#endif
 		vbi_get_exc_offset(&exec_table);
 #ifdef DEBUG
 		printk("****DUMP EXEC OFFSET***\n");
 		for(i=0;i<VBI_ARCH_MAX_EXC_OFFSETS;i++)
 			printk("execoffset:%d	----	0x%08x\n",i,exec_table.excOffset[i]);
 #endif 
+
+#ifdef CONFIG_SMP
 		for(i=0;i<VBI_ARCH_MAX_EXC_OFFSETS;i++)
-		if(exec_table.excOffset[i])
-			/*extend to 0x200, 9bits space*/
-			exec_table.excOffset[i] = exec_table.excOffset[i] << 1;
+			if(exec_table.excOffset[i])
+				/*extend to 0x200, 9bits space*/
+				exec_table.excOffset[i] = exec_table.excOffset[i] << 1;
+#endif
+		/* Check if enable direct interrupt mode. */
+		wrhv_enable_dir_irq();
+	
+		/* IVOR20 is dedicated to for direct interrupt offset
+		 * Here get 0x1600/0x2c00 from head_wrhv.s.
+		 */
+		if (wrhv_dir_irq) {
+			printk ("WRHV: guest OS is under Direct Interrupt mode.\n");
+#ifdef CONFIG_SMP
+			exec_table.excOffset[E500MC_DIR_EXC_INDEX] = E500MC_DIR_EXC_OFFSET << 1 ;
+#else
+			exec_table.excOffset[E500MC_DIR_EXC_INDEX] = E500MC_DIR_EXC_OFFSET;
+#endif
+		}
+
 		vbi_set_exc_offset(&exec_table);
+
 #ifdef DEBUG
 		printk("****DUMP EXEC OFFSET AFTER SET***\n");
 		vbi_get_exc_offset(&exec_table);
@@ -852,7 +928,6 @@ void __init wrhv_MMU_init(void)
 			printk("execoffset:%d	----	0x%08x\n",i,exec_table.excOffset[i]);
 #endif
 	}
-#endif
 }
 
 /* arch/powerpc/mm/mem.c */
-- 
1.6.5.2

