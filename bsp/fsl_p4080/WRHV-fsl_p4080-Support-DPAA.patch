From ba27a637b7e0b1fb0042bf0f3111023f3b5ce948 Mon Sep 17 00:00:00 2001
From: Tiejun Chen <tiejun.chen@windriver.com>
Date: Wed, 9 Dec 2009 18:40:00 -0800
Subject: [PATCH] WRHV/fsl_p4080: Support DPAA

Add necessary firmware binary for WRHV since we cannot access that from flash now.
And replace DMA map page as WRHV expect and fix dts file.

Signe-off-by: Kexin Hao <kexin.hao@windriverr.com>
Signe-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 arch/powerpc/boot/dts/wrhv_p4080ds.dts             |    5 +++
 arch/powerpc/include/asm/dma-mapping.h             |   24 +++++++++---------
 arch/powerpc/include/asm/pv_dma-mapping.h          |   27 ++++++++++++++++++++
 .../kernel/2.6/wrappers/Peripherals/FM/Makefile    |    2 +-
 .../kernel/2.6/wrappers/Peripherals/FM/firmware.S  |    4 +++
 .../Peripherals/FM/fsl_fman_ucode_p4080_91_1.bin   |  Bin 0 -> 6576 bytes
 .../kernel/2.6/wrappers/Peripherals/FM/lnxwrp_fm.c |   10 +++++++
 drivers/net/dpa/dpa.c                              |   23 ++++++++++++++---
 drivers/net/fsl_pq_mdio.c                          |    2 +-
 9 files changed, 79 insertions(+), 18 deletions(-)
 create mode 100644 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/firmware.S
 create mode 100644 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/fsl_fman_ucode_p4080_91_1.bin

diff --git a/arch/powerpc/boot/dts/wrhv_p4080ds.dts b/arch/powerpc/boot/dts/wrhv_p4080ds.dts
index 15fdc39..1c8581e 100644
--- a/arch/powerpc/boot/dts/wrhv_p4080ds.dts
+++ b/arch/powerpc/boot/dts/wrhv_p4080ds.dts
@@ -1197,6 +1197,7 @@
 				compatible = "fsl,p4080-fman-1g-mac", "fsl,fman-1g-mac";
 				reg = <0xe0000 0x1000>;
 				fsl,port-handles = <&fman0_rx0 &fman0_tx0>;
+				local-mac-address = [ 00 01 02 03 04 05 ];
 				phy-handle = <&phy0>;
 				phy-connection-type = "sgmii";
 			};
@@ -1230,6 +1231,7 @@
 				compatible = "fsl,p4080-fman-1g-mac", "fsl,fman-1g-mac";
 				reg = <0xe2000 0x1000>;
 				fsl,port-handles = <&fman0_rx1 &fman0_tx1>;
+				local-mac-address = [ 00 01 02 03 04 06 ];
 				phy-handle = <&phy1>;
 				phy-connection-type = "sgmii";
 			};
@@ -1247,6 +1249,7 @@
 				compatible = "fsl,p4080-fman-1g-mac", "fsl,fman-1g-mac";
 				reg = <0xe4000 0x1000>;
 				fsl,port-handles = <&fman0_rx2 &fman0_tx2>;
+				local-mac-address = [ 00 01 02 03 04 07 ];
 				phy-handle = <&phy2>;
 				phy-connection-type = "sgmii";
 			};
@@ -1264,6 +1267,7 @@
 				compatible = "fsl,p4080-fman-1g-mac", "fsl,fman-1g-mac";
 				reg = <0xe6000 0x1000>;
 				fsl,port-handles = <&fman0_rx3 &fman0_tx3>;
+				local-mac-address = [ 00 01 02 03 04 08 ];
 				phy-handle = <&phy3>;
 				phy-connection-type = "sgmii";
 			};
@@ -1445,6 +1449,7 @@
 				compatible = "fsl,p4080-fman-1g-mac", "fsl,fman-1g-mac";
 				reg = <0xe0000 0x1000>;
 				fsl,port-handles = <&fman1_rx0 &fman1_tx0>;
+				local-mac-address = [ 00 01 02 03 04 09 ];
 				phy-handle = <&phy4>;
 				phy-connection-type = "rgmii";
 			};
diff --git a/arch/powerpc/include/asm/dma-mapping.h b/arch/powerpc/include/asm/dma-mapping.h
index 5e84b2c..9ef8a61 100644
--- a/arch/powerpc/include/asm/dma-mapping.h
+++ b/arch/powerpc/include/asm/dma-mapping.h
@@ -343,6 +343,18 @@ native_dma_map_single(struct device *dev, void *ptr, size_t size,
 	__dma_sync(ptr, size, direction);
 	return virt_to_bus(ptr);
 }
+
+static inline dma_addr_t
+native_dma_map_page(struct device *dev, struct page *page,
+	     unsigned long offset, size_t size,
+	     enum dma_data_direction direction)
+{
+	BUG_ON(direction == DMA_NONE);
+
+	__dma_sync_page(page, offset, size, direction);
+
+	return page_to_bus(page) + offset;
+}
 #include <asm/pv_dma-mapping.h>
 #endif /* CONFIG_PARAVIRT */
 
@@ -365,18 +377,6 @@ static inline void dma_unmap_single(struct device *dev, dma_addr_t dma_addr,
 	/* We do nothing. */
 }
 
-static inline dma_addr_t
-dma_map_page(struct device *dev, struct page *page,
-	     unsigned long offset, size_t size,
-	     enum dma_data_direction direction)
-{
-	BUG_ON(direction == DMA_NONE);
-
-	__dma_sync_page(page, offset, size, direction);
-
-	return page_to_bus(page) + offset;
-}
-
 static inline void dma_unmap_page(struct device *dev, dma_addr_t dma_address,
 				  size_t size,
 				  enum dma_data_direction direction)
diff --git a/arch/powerpc/include/asm/pv_dma-mapping.h b/arch/powerpc/include/asm/pv_dma-mapping.h
index 3195ef3..7be7d40 100644
--- a/arch/powerpc/include/asm/pv_dma-mapping.h
+++ b/arch/powerpc/include/asm/pv_dma-mapping.h
@@ -4,14 +4,17 @@
 /* default native inline */
 #define dma_alloc_coherent	native_dma_alloc_coherent
 #define dma_map_single		native_dma_map_single
+#define dma_map_page		native_dma_map_page
 
 /* redefine hypervisor specific inline */
 #ifdef CONFIG_WRHV
 #undef dma_alloc_coherent
 #undef dma_map_single
+#undef dma_map_page
 
 #define dma_alloc_coherent	paravirt_dma_alloc_coherent
 #define dma_map_single		paravirt_dma_map_single
+#define dma_map_page		paravirt_dma_map_page
 
 #include <vbi/vbi.h>
 
@@ -73,6 +76,30 @@ paravirt_dma_map_single(struct device *dev, void *ptr, size_t size,
 #endif /* CONFIG_WRHV */
 
 }
+
+static inline dma_addr_t
+paravirt_dma_map_page(struct device *dev, struct page *page,
+	     unsigned long offset, size_t size,
+	     enum dma_data_direction direction)
+{
+
+#ifdef	CONFIG_PPC85xx_VT_MODE
+	u32 ptr;
+	u64 paddr;
+#endif
+
+	BUG_ON(direction == DMA_NONE);
+
+	__dma_sync_page(page, offset, size, direction);
+
+#ifndef	CONFIG_PPC85xx_VT_MODE
+	return page_to_bus(page) + offset;
+#else
+	ptr = (u32)page_to_bus(page) + offset;
+	vbi_get_guest_dma_addr((void *)ptr, &paddr);
+	return (dma_addr_t)paddr;
+#endif
+}
 #endif /* CONFIG_WRHV */
 
 #endif	/* _ASM_PV_DMA_MAPPING_H */
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/Makefile b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/Makefile
index 73354b9..9c69110 100644
--- a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/Makefile
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/Makefile
@@ -12,4 +12,4 @@ EXTRA_CFLAGS += -I$(NET_DPA)
 obj-y		+= fsl-ncsw-PFM.o
 obj-$(CONFIG_FSL_FMAN_TEST)	+= fman_test.o
 
-fsl-ncsw-PFM-objs	:=   lnxwrp_fm.o lnxwrp_fm_ioctls.o
+fsl-ncsw-PFM-objs	:=   lnxwrp_fm.o lnxwrp_fm_ioctls.o firmware.o
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/firmware.S b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/firmware.S
new file mode 100644
index 0000000..54c3771
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/firmware.S
@@ -0,0 +1,4 @@
+	.section .firmware,"a"
+	.globl p4080_fman_firmware
+p4080_fman_firmware:
+	.incbin "../linux/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/fsl_fman_ucode_p4080_91_1.bin"
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/fsl_fman_ucode_p4080_91_1.bin b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/fsl_fman_ucode_p4080_91_1.bin
new file mode 100644
index 0000000000000000000000000000000000000000..b3cbcec31ce5ec50bf82c36c2442f3a534214532
GIT binary patch
literal 6576
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
FzX7Q^O)3BY

literal 0
HcmV?d00001

diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/lnxwrp_fm.c b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/lnxwrp_fm.c
index 3d0f4a6..362aac3 100644
--- a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/lnxwrp_fm.c
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/lnxwrp_fm.c
@@ -585,6 +585,9 @@ __setup("fman_ucode=", FmanUcodeAddrParam);
  * We also never iounmap() the memory because we might reset the Fman at any
  * time.
  */
+#ifdef	CONFIG_PPC85xx_VT_MODE
+extern struct qe_firmware p4080_fman_firmware;
+#endif
 static struct qe_firmware *FindFmanMicrocode(void)
 {
     static struct qe_firmware *P4080_UCPatch;
@@ -593,12 +596,17 @@ static struct qe_firmware *FindFmanMicrocode(void)
         unsigned long P4080_UCSize;
         struct qe_header *hdr;
 
+#ifdef	CONFIG_PPC85xx_VT_MODE
+	P4080_UCPatch = &p4080_fman_firmware;
+#else
+
         /* Only map enough to the get the core structure */
         P4080_UCPatch = ioremap(P4080_UCAddr, sizeof(struct qe_firmware));
         if (!P4080_UCPatch) {
             REPORT_ERROR(MAJOR, E_NULL_POINTER, ("ioremap(%llx) returned NULL", (u64) P4080_UCAddr));
             return NULL;
         }
+#endif
 
         /* Make sure it really is a QE Firmware blob */
         hdr = &P4080_UCPatch->header;
@@ -611,8 +619,10 @@ static struct qe_firmware *FindFmanMicrocode(void)
 
         /* Now we call ioremap again, this time to pick up the whole blob */
         P4080_UCSize = sizeof(u32) * P4080_UCPatch->microcode[0].count;
+#ifndef	CONFIG_PPC85xx_VT_MODE
         iounmap(P4080_UCPatch);
         P4080_UCPatch = ioremap(P4080_UCAddr, P4080_UCSize);
+#endif
         if (!P4080_UCPatch) {
             REPORT_ERROR(MAJOR, E_NULL_POINTER, ("ioremap(%llx) returned NULL", (u64) P4080_UCAddr));
             return NULL;
diff --git a/drivers/net/dpa/dpa.c b/drivers/net/dpa/dpa.c
index 2156152..8fc7244 100644
--- a/drivers/net/dpa/dpa.c
+++ b/drivers/net/dpa/dpa.c
@@ -84,6 +84,16 @@ static const char rtx[][3] = {
 	[TX] = "TX"
 };
 
+#ifdef	CONFIG_PPC85xx_VT_MODE
+static u64 guest_phy_offset;
+
+#define dpa_bus_to_virt(addr) 	\
+	__va(addr - guest_phy_offset)
+#else
+#define	dpa_bus_to_virt(addr)	\
+	bus_to_virt(addr)
+#endif
+
 /* BM */
 
 #ifdef DEBUG
@@ -951,7 +961,8 @@ static enum qman_cb_dqrr_result ingress_tx_error_dqrr(struct qman_portal		*porta
 
 #ifdef CONFIG_FSL_FMAN_TEST
 {
-    void   *virt = bus_to_virt(dq->fd.addr_lo);
+    void   *virt = dpa_bus_to_virt(dq->fd.addr_lo);
+
     if (is_fman_test((void *)priv->mac_dev,
                      FMT_TX_ERR_Q,
                      virt,
@@ -1042,7 +1053,8 @@ static enum qman_cb_dqrr_result ingress_tx_default_dqrr(struct qman_portal		*por
 
 #ifdef CONFIG_FSL_FMAN_TEST
 {
-    void   *virt = bus_to_virt(dq->fd.addr_lo);
+    void   *virt = dpa_bus_to_virt(dq->fd.addr_lo);
+
     if (is_fman_test((void *)priv->mac_dev,
                      FMT_TX_CONF_Q,
                      virt,
@@ -1052,7 +1064,7 @@ static enum qman_cb_dqrr_result ingress_tx_default_dqrr(struct qman_portal		*por
 }
 #endif /* CONFIG_FSL_FMAN_TEST */
 
-	skb = *(typeof(&skb))bus_to_virt(dq->fd.addr_lo);
+	skb = *(typeof(&skb))dpa_bus_to_virt(dq->fd.addr_lo);
 
 	BUG_ON(net_dev != skb->dev);
 
@@ -1160,7 +1172,7 @@ static void egress_ern(struct qman_portal	*portal,
 		cpu_netdev_dbg(net_dev, "-> %s:%s()\n", __file__, __func__);
 
 	if (priv->mac_dev) {
-		skb = *(typeof(&skb))bus_to_virt(msg->ern.fd.addr_lo);
+		skb = *(typeof(&skb))dpa_bus_to_virt(msg->ern.fd.addr_lo);
 
 		BUG_ON(net_dev != skb->dev);
 
@@ -2534,6 +2546,9 @@ static int __init __cold dpa_load(void)
 
 	cpu_pr_info(KBUILD_MODNAME ": " DPA_DESCRIPTION " (" VERSION ")\n");
 
+#ifdef	CONFIG_PPC85xx_VT_MODE
+	vbi_guest_phys_to_phys(virt_to_phys(PAGE_OFFSET), &guest_phy_offset);
+#endif
 	_errno = of_register_platform_driver(&dpa_driver);
 	if (unlikely(_errno < 0)) {
 		cpu_pr_err(KBUILD_MODNAME ": %s:%hu:%s(): of_register_platform_driver() = %d\n",
diff --git a/drivers/net/fsl_pq_mdio.c b/drivers/net/fsl_pq_mdio.c
index 5151d81..97372ab 100644
--- a/drivers/net/fsl_pq_mdio.c
+++ b/drivers/net/fsl_pq_mdio.c
@@ -101,7 +101,7 @@ int fsl_pq_local_mdio_read(struct fsl_pq_mdio __iomem *regs,
 	return value;
 }
 
-#ifdef CONFIG_P4080_DS
+#if defined(CONFIG_P4080_DS) || defined(CONFIG_PPC85xx_VT_MODE)
 #define EMI1_SLOT5	0xc0000000
 #define EMI_MASK	0xf0000000
 
-- 
1.6.5.2

