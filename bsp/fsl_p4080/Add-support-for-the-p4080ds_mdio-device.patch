From a687f20d7fe4e846068a1383abf7248138284fc1 Mon Sep 17 00:00:00 2001
From: Andy Fleming <afleming@freescale.com>
Date: Wed, 7 Oct 2009 03:32:03 -0500
Subject: [PATCH] Add support for the p4080ds_mdio "device"

The P4080 uses a peculiar muxing scheme where the two MDIO buses pinned
out from the p4080 are redirected to one of 6 (4 for 1G, 2 for 10G) bus
lines on the DS.  This requires that for each MDIO operation, we write
to some GPIO pins to talk to the desired PHY.  However, the PHY Lib and
MDIO driver are unaware of this, and should remain unaware of this if we
are to cleanly run p4080 code on other boards (and on other chips which
use the same IP).

As such, we design a "fake" MDIO bus type which is specific to the
P4080DS, and use it as a wrapper around the actual bus(es).  This
requires some device tree changes:

1) Addition of p4080ds mdio nodes
2) Moving all PHYs under those nodes
3) Adding aliases and labels so that u-boot can find those nodes in a
less fragile way.
4) Correction of the broken MDIO nodes

While we're at it, we also add full TBI support to the ethernet nodes,
so that the dTSEC can use the same code for MDIO

Also, we need to probe for the p4080ds mdio devices in the board code.

Signed-off-by: Andy Fleming <afleming@freescale.com>
[Kevin: Original patch taken from Freescale p4080 SDK 2.0 ISO image.
fix mdiobus_alloc/free error in order to backport to 2.6.27 kernel]
Integrated-by: Kevin Hao <kexin.hao@windriver.com>
---
 arch/powerpc/boot/dts/p4080ds.dts          |  260 +++++++++++++++++++--------
 arch/powerpc/platforms/85xx/Makefile       |    2 +-
 arch/powerpc/platforms/85xx/p4080_ds.c     |   27 +++-
 arch/powerpc/platforms/85xx/p4080ds_mdio.c |  275 ++++++++++++++++++++++++++++
 4 files changed, 487 insertions(+), 77 deletions(-)
 create mode 100644 arch/powerpc/platforms/85xx/p4080ds_mdio.c

diff --git a/arch/powerpc/boot/dts/p4080ds.dts b/arch/powerpc/boot/dts/p4080ds.dts
index 4e0efaa..ea0ed94 100644
--- a/arch/powerpc/boot/dts/p4080ds.dts
+++ b/arch/powerpc/boot/dts/p4080ds.dts
@@ -24,14 +24,23 @@
 		ethernet1 = &enet1;
 		ethernet2 = &enet2;
 		ethernet3 = &enet3;
-		ethernet5 = &enet5;
-/*
 		ethernet4 = &enet4;
+		ethernet5 = &enet5;
 		ethernet6 = &enet6;
 		ethernet7 = &enet7;
 		ethernet8 = &enet8;
 		ethernet9 = &enet9;
-*/
+		phy_rgmii = &phyrgmii;
+		phy5_slot3 = &phy5slot3;
+		phy6_slot3 = &phy6slot3;
+		phy7_slot3 = &phy7slot3;
+		phy8_slot3 = &phy8slot3;
+		emi1_slot3 = &p4080mdio2;
+		emi1_slot4 = &p4080mdio1;
+		emi1_slot5 = &p4080mdio3;
+		emi1_rgmii = &p4080mdio0;
+		emi2_slot4 = &p4080xmdio2;
+		emi2_slot5 = &p4080xmdio3;
 		serial0 = &serial0;
 		serial1 = &serial1;
 		serial2 = &serial2;
@@ -1013,6 +1022,11 @@
 			interrupt-parent = <&mpic>;
 		};
 
+		gpio: gpio@130000 {
+			compatible = "fsl,qoriq-gpio";
+			reg = <0x130008 0xff8>;
+		};
+
 		crypto: crypto@300000 {
 			compatible = "fsl,p4080-sec4.0", "fsl,sec4.0";
 			#address-cells = <1>;
@@ -1262,31 +1276,97 @@
 				compatible = "fsl,p4080-fman-1g-mac", "fsl,fman-1g-mac";
 				reg = <0xe0000 0x1000>;
 				fsl,port-handles = <&fman0_rx0 &fman0_tx0>;
+				tbi-handle = <&tbi0>;
 				phy-handle = <&phy0>;
 				phy-connection-type = "sgmii";
 			};
 
-			mdio@e1120 {
+			mdio0: mdio@e1120 {
 				#address-cells = <1>;
 				#size-cells = <0>;
 				compatible = "fsl,fman-mdio";
 				reg = <0xe1120 0xee0>;
 				interrupts = <100 1>;
 
-				phy0: ethernet-phy@0 {
-					reg = <0x1c>;
+				tbi0: tbi-phy@8 {
+					reg = <0x8>;
+					device_type = "tbi-phy";
 				};
-				phy1: ethernet-phy@1 {
-					reg = <0x1d>;
+
+				p4080mdio0: p4080ds-mdio0 {
+					#address-cells = <1>;
+					#size-cells = <0>;
+					compatible = "fsl,p4080ds-mdio";
+					fsl,mdio-handle = <&mdio0>;
+					fsl,muxval = <0>;
+
+					phyrgmii: ethernet-phy@0 {
+						reg = <0x0>;
+					};
 				};
-				phy2: ethernet-phy@2 {
-					reg = <0x1e>;
+
+				p4080mdio1: p4080ds-mdio1 {
+					#address-cells = <1>;
+					#size-cells = <0>;
+					compatible = "fsl,p4080ds-mdio";
+					fsl,mdio-handle = <&mdio0>;
+					fsl,muxval = <1>;
+
+					phy5: ethernet-phy@1c {
+						reg = <0x1c>;
+					};
+					phy6: ethernet-phy@1d {
+						reg = <0x1d>;
+					};
+					phy7: ethernet-phy@1e {
+						reg = <0x1e>;
+					};
+					phy8: ethernet-phy@1f {
+						reg = <0x1f>;
+					};
 				};
-				phy3: ethernet-phy@3 {
-					reg = <0x1f>;
+
+				p4080mdio2: p4080ds-mdio2 {
+					#address-cells = <1>;
+					#size-cells = <0>;
+					compatible = "fsl,p4080ds-mdio";
+					fsl,mdio-handle = <&mdio0>;
+					fsl,muxval = <2>;
+					status = "disabled";
+
+					phy5slot3: ethernet-phy@1c {
+						reg = <0x1c>;
+					};
+					phy6slot3: ethernet-phy@1d {
+						reg = <0x1d>;
+					};
+					phy7slot3: ethernet-phy@1e {
+						reg = <0x1e>;
+					};
+					phy8slot3: ethernet-phy@1f {
+						reg = <0x1f>;
+					};
 				};
-				phy4: ethernet-phy@4 {
-					reg = <0>;
+
+				p4080mdio3: p4080ds-mdio3 {
+					#address-cells = <1>;
+					#size-cells = <0>;
+					compatible = "fsl,p4080ds-mdio";
+					fsl,mdio-handle = <&mdio0>;
+					fsl,muxval = <3>;
+
+					phy0: ethernet-phy@1c {
+						reg = <0x1c>;
+					};
+					phy1: ethernet-phy@1d {
+						reg = <0x1d>;
+					};
+					phy2: ethernet-phy@1e {
+						reg = <0x1e>;
+					};
+					phy3: ethernet-phy@1f {
+						reg = <0x1f>;
+					};
 				};
 			};
 
@@ -1295,16 +1375,22 @@
 				compatible = "fsl,p4080-fman-1g-mac", "fsl,fman-1g-mac";
 				reg = <0xe2000 0x1000>;
 				fsl,port-handles = <&fman0_rx1 &fman0_tx1>;
+				tbi-handle = <&tbi1>;
 				phy-handle = <&phy1>;
 				phy-connection-type = "sgmii";
 			};
 
-			mdio@e3000 {
+			mdio@e3120 {
 				#address-cells = <1>;
 				#size-cells = <0>;
-				compatible = "fsl,fman-mdio";
-				reg = <0xe3000 0x1000>;
+				compatible = "fsl,fman-tbi";
+				reg = <0xe3120 0xee0>;
 				interrupts = <100 1>;
+
+				tbi1: tbi-phy@8 {
+					reg = <8>;
+					device_type = "tbi-phy";
+				};
 			};
 
 			enet2: ethernet@e4000 {
@@ -1312,16 +1398,22 @@
 				compatible = "fsl,p4080-fman-1g-mac", "fsl,fman-1g-mac";
 				reg = <0xe4000 0x1000>;
 				fsl,port-handles = <&fman0_rx2 &fman0_tx2>;
+				tbi-handle = <&tbi2>;
 				phy-handle = <&phy2>;
 				phy-connection-type = "sgmii";
 			};
 
-			mdio@e5000 {
+			mdio@e5120 {
 				#address-cells = <1>;
 				#size-cells = <0>;
-				compatible = "fsl,fman-mdio";
-				reg = <0xe5000 0x1000>;
+				compatible = "fsl,fman-tbi";
+				reg = <0xe5120 0xee0>;
 				interrupts = <100 1>;
+
+				tbi2: tbi-phy@8 {
+					reg = <8>;
+					device_type = "tbi-phy";
+				};
 			};
 
 			enet3: ethernet@e6000 {
@@ -1329,35 +1421,63 @@
 				compatible = "fsl,p4080-fman-1g-mac", "fsl,fman-1g-mac";
 				reg = <0xe6000 0x1000>;
 				fsl,port-handles = <&fman0_rx3 &fman0_tx3>;
+				tbi-handle = <&tbi3>;
 				phy-handle = <&phy3>;
 				phy-connection-type = "sgmii";
 			};
 
-			mdio@e7000 {
+			mdio@e7120 {
 				#address-cells = <1>;
 				#size-cells = <0>;
-				compatible = "fsl,fman-mdio";
-				reg = <0xe7000 0x1000>;
+				compatible = "fsl,fman-tbi";
+				reg = <0xe7120 0xee0>;
 				interrupts = <100 1>;
+
+				tbi3: tbi-phy@8 {
+					reg = <8>;
+					device_type = "tbi-phy";
+				};
 			};
-/*
 			enet4: ethernet@f0000 {
 				cell-index = <0>;
 				compatible = "fsl,p4080-fman-10g-mac", "fsl,fman-10g-mac";
 				reg = <0xf0000 0x1000>;
 				fsl,port-handles = <&fman0_rx4 &fman0_tx4>;
-				phy-handle = <&phy4>;
+				phy-handle = <&phy10>;
 				phy-connection-type = "xgmii";
 			};
 
-			mdio@f1000 {
+			xmdio0: mdio@f1000 {
 				#address-cells = <1>;
 				#size-cells = <0>;
-				compatible = "fsl,fman-mdio";
+				compatible = "fsl,fman-xmdio";
 				reg = <0xf1000 0x1000>;
 				interrupts = <100 1>;
+
+				p4080xmdio2: p4080ds-xmdio2 {
+					#address-cells = <1>;
+					#size-cells = <0>;
+					compatible = "fsl,p4080ds-xmdio";
+					fsl,mdio-handle = <&xmdio0>;
+					fsl,muxval = <2>;
+
+					phy11: ethernet-phy@0 {
+						reg = <0x0>;
+					};
+				};
+
+				p4080xmdio3: p4080ds-xmdio3 {
+					#address-cells = <1>;
+					#size-cells = <0>;
+					compatible = "fsl,p4080ds-xmdio";
+					fsl,mdio-handle = <&xmdio0>;
+					fsl,muxval = <3>;
+
+					phy10: ethernet-phy@4 {
+						reg = <0x4>;
+					};
+				};
 			};
-*/
 		};
 
 		fman1: fman@500000 {
@@ -1510,19 +1630,20 @@
 				compatible = "fsl,p4080-fman-1g-mac", "fsl,fman-1g-mac";
 				reg = <0xe0000 0x1000>;
 				fsl,port-handles = <&fman1_rx0 &fman1_tx0>;
-				phy-handle = <&phy4>;
-				phy-connection-type = "rgmii";
+				tbi-handle = <&tbi5>;
+				phy-handle = <&phy5>;
+				phy-connection-type = "sgmii";
 			};
-/*
-			mdio@e1000 {
+			mdio@e1120 {
 				#address-cells = <1>;
 				#size-cells = <0>;
-				compatible = "fsl,fman-mdio";
-				reg = <0xe1000 0x1000>;
+				compatible = "fsl,fman-tbi";
+				reg = <0xe1120 0xee0>;
 				interrupts = <101 1>;
 
-				phy5: ethernet-phy@0 {
-					reg = <0>;
+				tbi5: tbi-phy@8 {
+					reg = <8>;
+					device_type = "tbi-phy";
 				};
 			};
 
@@ -1531,19 +1652,21 @@
 				compatible = "fsl,p4080-fman-1g-mac", "fsl,fman-1g-mac";
 				reg = <0xe2000 0x1000>;
 				fsl,port-handles = <&fman1_rx1 &fman1_tx1>;
+				tbi-handle = <&tbi6>;
 				phy-handle = <&phy6>;
-				phy-connection-type = "rgmii-id";
+				phy-connection-type = "sgmii";
 			};
 
-			mdio@e3000 {
+			mdio@e3120 {
 				#address-cells = <1>;
 				#size-cells = <0>;
-				compatible = "fsl,fman-mdio";
-				reg = <0xe3000 0x1000>;
+				compatible = "fsl,fman-tbi";
+				reg = <0xe3120 0xee0>;
 				interrupts = <101 1>;
 
-				phy6: ethernet-phy@0 {
-					reg = <0>;
+				tbi6: tbi-phy@8 {
+					reg = <8>;
+					device_type = "tbi-phy";
 				};
 			};
 
@@ -1552,19 +1675,21 @@
 				compatible = "fsl,p4080-fman-1g-mac", "fsl,fman-1g-mac";
 				reg = <0xe4000 0x1000>;
 				fsl,port-handles = <&fman1_rx2 &fman1_tx2>;
+				tbi-handle = <&tbi7>;
 				phy-handle = <&phy7>;
-				phy-connection-type = "rgmii-id";
+				phy-connection-type = "sgmii";
 			};
 
-			mdio@e5000 {
+			mdio@e5120 {
 				#address-cells = <1>;
 				#size-cells = <0>;
-				compatible = "fsl,fman-mdio";
-				reg = <0xe5000 0x1000>;
+				compatible = "fsl,fman-tbi";
+				reg = <0xe5120 0xee0>;
 				interrupts = <101 1>;
 
-				phy7: ethernet-phy@0 {
-					reg = <0>;
+				tbi7: tbi-phy@8 {
+					reg = <8>;
+					device_type = "tbi-phy";
 				};
 			};
 
@@ -1573,19 +1698,21 @@
 				compatible = "fsl,p4080-fman-1g-mac", "fsl,fman-1g-mac";
 				reg = <0xe6000 0x1000>;
 				fsl,port-handles = <&fman1_rx3 &fman1_tx3>;
+				tbi-handle = <&tbi8>;
 				phy-handle = <&phy8>;
-				phy-connection-type = "rgmii-id";
+				phy-connection-type = "sgmii";
 			};
 
-			mdio@e7000 {
+			mdio@e7120 {
 				#address-cells = <1>;
 				#size-cells = <0>;
-				compatible = "fsl,fman-mdio";
-				reg = <0xe7000 0x1000>;
+				compatible = "fsl,fman-tbi";
+				reg = <0xe7120 0xee0>;
 				interrupts = <101 1>;
 
-				phy8: ethernet-phy@0 {
-					reg = <0>;
+				tbi8: tbi-phy@8 {
+					reg = <8>;
+					device_type = "tbi-phy";
 				};
 			};
 
@@ -1594,22 +1721,9 @@
 				compatible = "fsl,p4080-fman-10g-mac", "fsl,fman-10g-mac";
 				reg = <0xf0000 0x1000>;
 				fsl,port-handles = <&fman1_rx4 &fman1_tx4>;
-				phy-handle = <&phy9>;
+				phy-handle = <&phy11>;
 				phy-connection-type = "xgmii";
 			};
-
-			mdio@f1000 {
-				#address-cells = <1>;
-				#size-cells = <0>;
-				compatible = "fsl,fman-mdio";
-				reg = <0xf1000 0x1000>;
-				interrupts = <101 1>;
-
-				phy9: ethernet-phy@0 {
-					reg = <0>;
-				};
-			};
-*/
 		};
 	};
 
@@ -1742,7 +1856,7 @@
 
 		ethernet@0 {
 			compatible = "fsl,p4080-dpa-ethernet", "fsl,dpa-ethernet";
-			fsl,qman-channel = <&qportal0>;
+			fsl,qman-channel = <&qpool1>;
 			fsl,fman-mac = <&enet0>;
 		};
 		ethernet@1 {
@@ -1760,19 +1874,16 @@
 			fsl,qman-channel = <&qpool1>;
 			fsl,fman-mac = <&enet3>;
 		};
-/*
 		ethernet@4 {
 			compatible = "fsl,p4080-dpa-ethernet", "fsl,dpa-ethernet";
-			fsl,qman-channel = <&qpool1>;
+			fsl,qman-channel = <&qportal0>;
 			fsl,fman-mac = <&enet4>;
 		};
-*/
 		ethernet@5 {
 			compatible = "fsl,p4080-dpa-ethernet", "fsl,dpa-ethernet";
 			fsl,qman-channel = <&qportal7>;
 			fsl,fman-mac = <&enet5>;
 		};
-/*
 		ethernet@6 {
 			compatible = "fsl,p4080-dpa-ethernet", "fsl,dpa-ethernet";
 			fsl,qman-channel = <&qpool1>;
@@ -1790,10 +1901,9 @@
 		};
 		ethernet@9 {
 			compatible = "fsl,p4080-dpa-ethernet", "fsl,dpa-ethernet";
-			fsl,qman-channel = <&qpool1>;
+			fsl,qman-channel = <&qportal0>;
 			fsl,fman-mac = <&enet9>;
 		};
-*/
 	};
 
 	localbus@fe124000 {
diff --git a/arch/powerpc/platforms/85xx/Makefile b/arch/powerpc/platforms/85xx/Makefile
index a825e79..6cef9f0 100644
--- a/arch/powerpc/platforms/85xx/Makefile
+++ b/arch/powerpc/platforms/85xx/Makefile
@@ -11,7 +11,7 @@ obj-$(CONFIG_MPC8536_DS)  += mpc8536_ds.o
 obj-$(CONFIG_MPC85xx_DS)  += mpc85xx_ds.o
 obj-$(CONFIG_MPC85xx_MDS) += mpc85xx_mds.o
 obj-$(CONFIG_P4080_SIM)   += p4080_sim.o p4080.o
-obj-$(CONFIG_P4080_DS)    += p4080_ds.o p4080.o
+obj-$(CONFIG_P4080_DS)    += p4080_ds.o p4080.o p4080ds_mdio.o
 obj-$(CONFIG_STX_GP3)	  += stx_gp3.o
 obj-$(CONFIG_TQM85xx)	  += tqm85xx.o
 obj-$(CONFIG_SBC8560)     += sbc8560.o
diff --git a/arch/powerpc/platforms/85xx/p4080_ds.c b/arch/powerpc/platforms/85xx/p4080_ds.c
index d61de5f..0ab75a1 100644
--- a/arch/powerpc/platforms/85xx/p4080_ds.c
+++ b/arch/powerpc/platforms/85xx/p4080_ds.c
@@ -118,7 +118,32 @@ static const struct of_device_id of_device_ids[] __devinitconst = {
 
 static int __init declare_of_platform_devices(void)
 {
-	return of_platform_bus_probe(NULL, of_device_ids, NULL);
+	struct device_node *np;
+	struct of_device *dev;
+	int err;
+
+	err = of_platform_bus_probe(NULL, of_device_ids, NULL);
+	if (err)
+		return err;
+
+	/* Now probe the fake MDIO buses */
+	for_each_compatible_node(np, NULL, "fsl,p4080ds-mdio") {
+		dev = of_platform_device_create(np, NULL, NULL);
+		if (!dev) {
+			of_node_put(np);
+			return -ENOMEM;
+		}
+	}
+
+	for_each_compatible_node(np, NULL, "fsl,p4080ds-xmdio") {
+		dev = of_platform_device_create(np, NULL, NULL);
+		if (!dev) {
+			of_node_put(np);
+			return -ENOMEM;
+		}
+	}
+
+	return 0;
 }
 machine_device_initcall(p4080_ds, declare_of_platform_devices);
 
diff --git a/arch/powerpc/platforms/85xx/p4080ds_mdio.c b/arch/powerpc/platforms/85xx/p4080ds_mdio.c
new file mode 100644
index 0000000..83b5ce9
--- /dev/null
+++ b/arch/powerpc/platforms/85xx/p4080ds_mdio.c
@@ -0,0 +1,275 @@
+/*
+ * Freescale P4080DS MDIO bus
+ * provides proper gpio muxing for the MDIO buses on the P4080 DS
+ *
+ * Author: Andy Fleming <afleming@freescale.com>
+ *
+ * Copyright (c) 2009 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/errno.h>
+#include <linux/unistd.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+#include <linux/spinlock.h>
+#include <linux/mm.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/crc32.h>
+#include <linux/mii.h>
+#include <linux/phy.h>
+#include <linux/of.h>
+#include <linux/of_mdio.h>
+#include <linux/of_platform.h>
+
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/uaccess.h>
+
+struct p4080ds_mdio {
+	struct mii_bus *real_bus;
+	u32 *gpio_reg;
+	u32 gpio_value;
+	u32 gpio_mask;
+};
+
+/* Set the GPIO mux, and then write the MDIO regs */
+int p4080ds_mdio_write(struct mii_bus *bus, int port_addr, int dev_addr,
+			int regnum, u16 value)
+{
+	struct p4080ds_mdio *priv = bus->priv;
+
+	/* Write the GPIO regs to select this bus */
+	clrsetbits_be32(priv->gpio_reg, priv->gpio_mask, priv->gpio_value);
+
+	/* Write through to the attached MDIO bus */
+	return priv->real_bus->write(priv->real_bus, port_addr, dev_addr,
+					regnum, value);
+}
+
+/* Set the GPIO muxing, and then read from the MDIO bus */
+int p4080ds_mdio_read(struct mii_bus *bus, int port_addr, int dev_addr,
+			int regnum)
+{
+	struct p4080ds_mdio *priv = bus->priv;
+
+	/* Write the GPIO regs to select this bus */
+	clrsetbits_be32(priv->gpio_reg, priv->gpio_mask, priv->gpio_value);
+
+	return priv->real_bus->read(priv->real_bus, port_addr, dev_addr,
+					regnum);
+}
+
+
+/* Reset the MIIM registers, and wait for the bus to free */
+static int p4080ds_mdio_reset(struct mii_bus *bus)
+{
+	struct p4080ds_mdio *priv = bus->priv;
+
+	mutex_lock(&bus->mdio_lock);
+	priv->real_bus->reset(priv->real_bus);
+	mutex_unlock(&bus->mdio_lock);
+
+	return 0;
+}
+
+
+static int p4080ds_mdio_probe(struct of_device *ofdev,
+		const struct of_device_id *match)
+{
+	struct device_node *np = ofdev->node;
+	struct mii_bus *new_bus;
+	struct p4080ds_mdio *priv;
+	struct device_node *mdio, *gpio;
+	struct of_device *ofmdiodev;
+	u64 reg;
+	int i;
+	const u32 *addr;
+	const u32 *val;
+	int err = 0;
+
+	if (!of_device_is_available(np))
+		return -ENODEV;
+
+	new_bus = kzalloc(sizeof(*new_bus), GFP_KERNEL);
+	if (NULL == new_bus)
+		return -ENOMEM;
+
+	new_bus->name = "Freescale P4080DS MDIO Bus",
+	new_bus->read = &p4080ds_mdio_read,
+	new_bus->write = &p4080ds_mdio_write,
+	new_bus->reset = &p4080ds_mdio_reset,
+
+	priv = kzalloc(sizeof(*priv), GFP_KERNEL);
+	if (!priv) {
+		err = -ENOMEM;
+		goto err_priv_alloc;
+	}
+
+	new_bus->priv = priv;
+
+	mdio = of_parse_phandle(np, "fsl,mdio-handle", 0);
+
+	if (mdio == NULL) {
+		printk(KERN_ERR "Could not find real MDIO bus for %s\n",
+			new_bus->id);
+		err = -ENODEV;
+		goto err_no_mdio_node;
+	}
+
+	ofmdiodev = of_find_device_by_node(mdio);
+
+	if (!ofmdiodev) {
+		printk(KERN_ERR "No of_device for MDIO node %s\n", mdio->name);
+		err = -ENODEV;
+		goto err_no_mdio_dev;
+	}
+
+	of_node_put(mdio);
+
+	priv->real_bus = dev_get_drvdata(&ofmdiodev->dev);
+
+	if (!priv->real_bus) {
+		printk(KERN_ERR "The MDIO bus has no ofdev!\n");
+		err = -ENODEV;
+		goto err_no_ofdev;
+	}
+
+	new_bus->irq = kcalloc(PHY_MAX_ADDR, sizeof(int), GFP_KERNEL);
+
+	if (NULL == new_bus->irq) {
+		err = -ENOMEM;
+		goto err_irq_alloc;
+	}
+
+	for (i = 0; i < PHY_MAX_ADDR; i++)
+		new_bus->irq[i] = PHY_POLL;
+
+	dev_set_drvdata(&ofdev->dev, new_bus);
+
+	/* Find the GPIO register pointer */
+	gpio = of_find_compatible_node(NULL, NULL, "fsl,qoriq-gpio");
+
+	if (!gpio) {
+		err = -ENODEV;
+		goto err_no_gpio;
+	}
+
+	addr = of_get_address(gpio, 0, NULL, NULL);
+	if (!addr) {
+		err = -ENODEV;
+		goto err_no_gpio_addr;
+	}
+
+	reg = of_translate_address(gpio, addr);
+
+	priv->gpio_reg = ioremap(reg, sizeof(*priv->gpio_reg));
+
+	if (!priv->gpio_reg) {
+		err = -ENOMEM;
+		goto err_ioremap;
+	}
+
+	/* Grab the value to write to the GPIO */
+	val = of_get_property(np, "fsl,muxval", NULL);
+
+	if (!val) {
+		printk(KERN_ERR "No mux value found for %s\n", np->full_name);
+		err = -ENODEV;
+		goto err_get_muxval;
+	}
+
+	if (of_device_is_compatible(np, "fsl,p4080ds-mdio")) {
+		priv->gpio_mask = 0xc0000000;
+		priv->gpio_value = (*val << 30);
+	} else if (of_device_is_compatible(np, "fsl,p4080ds-xmdio")) {
+		priv->gpio_mask = 0x30000000;
+		priv->gpio_value = (*val << 28);
+	}
+
+	sprintf(new_bus->id, "%s@%d", np->name, *val);
+
+	err = of_mdiobus_register(new_bus, np);
+
+	if (err) {
+		printk(KERN_ERR "%s: Cannot register as MDIO bus\n",
+				new_bus->name);
+		goto err_registration;
+	}
+
+	return 0;
+
+err_registration:
+err_get_muxval:
+	iounmap(priv->gpio_reg);
+err_ioremap:
+err_no_gpio_addr:
+err_no_gpio:
+	kfree(new_bus->irq);
+err_irq_alloc:
+err_no_ofdev:
+err_no_mdio_dev:
+err_no_mdio_node:
+	kfree(priv);
+err_priv_alloc:
+	kfree(new_bus);
+
+	return err;
+}
+
+
+static int p4080ds_mdio_remove(struct of_device *ofdev)
+{
+	struct device *device = &ofdev->dev;
+	struct mii_bus *bus = dev_get_drvdata(device);
+
+	mdiobus_unregister(bus);
+
+	dev_set_drvdata(device, NULL);
+
+	bus->priv = NULL;
+	kfree(bus);
+
+	return 0;
+}
+
+static struct of_device_id p4080ds_mdio_match[] = {
+	{
+		.compatible = "fsl,p4080ds-mdio",
+	},
+	{
+		.compatible = "fsl,p4080ds-xmdio",
+	},
+};
+
+static struct of_platform_driver p4080ds_mdio_driver = {
+	.name = "p4080ds_mdio",
+	.probe = p4080ds_mdio_probe,
+	.remove = p4080ds_mdio_remove,
+	.match_table = p4080ds_mdio_match,
+};
+
+int __init p4080ds_mdio_init(void)
+{
+	return of_register_platform_driver(&p4080ds_mdio_driver);
+}
+
+void p4080ds_mdio_exit(void)
+{
+	of_unregister_platform_driver(&p4080ds_mdio_driver);
+}
+subsys_initcall_sync(p4080ds_mdio_init);
+module_exit(p4080ds_mdio_exit);
-- 
1.6.0.4

