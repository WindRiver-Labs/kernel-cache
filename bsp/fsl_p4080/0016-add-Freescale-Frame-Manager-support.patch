From 4f205b05142e155f150be718abf0c83b0648898e Mon Sep 17 00:00:00 2001
From: Kevin Hao <kexin.hao@windriver.com>
Date: Mon, 21 Sep 2009 11:07:04 +0800
Subject: [PATCH 16/52] add Freescale Frame Manager support

Merge patches (p4080_1-2-rc1-netcomm_inc.patch,
p4080_1-2-rc1-netcomm_integrations.patch,
p4080_1-2-rc1-netcomm_other.patch,
p4080_1-2-rc1-netcomm_peripherals.patch,
p4080_1-2-rc1-linux-netcomm_user-2.patch,
0001-FMD5.1.patch,
0001-FMD5.2.patch,
0001-FMD5.3.patch,
0001-FMD5.3.1.patch). All these patches are taken from
Freescale v1.2 board support ISO image for p4080

Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 drivers/Kconfig                                    |    2 +
 drivers/net/dpa/NetCommSw/Kconfig                  |   20 +
 drivers/net/dpa/NetCommSw/Makefile                 |   12 +
 .../net/dpa/NetCommSw/Peripherals/FM/HC/Makefile   |   15 +
 drivers/net/dpa/NetCommSw/Peripherals/FM/HC/hc.c   | 1177 ++++++
 .../net/dpa/NetCommSw/Peripherals/FM/MAC/Makefile  |   18 +
 .../net/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.c   | 1358 +++++++
 .../net/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.h   |  496 +++
 .../NetCommSw/Peripherals/FM/MAC/dtsec_mii_acc.c   |  127 +
 .../NetCommSw/Peripherals/FM/MAC/dtsec_mii_acc.h   |   66 +
 .../net/dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.c  |  483 +++
 .../net/dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.h  |  180 +
 .../net/dpa/NetCommSw/Peripherals/FM/MAC/tgec.c    |  930 +++++
 .../net/dpa/NetCommSw/Peripherals/FM/MAC/tgec.h    |  439 +++
 .../NetCommSw/Peripherals/FM/MAC/tgec_mii_acc.c    |  103 +
 .../NetCommSw/Peripherals/FM/MAC/tgec_mii_acc.h    |   60 +
 drivers/net/dpa/NetCommSw/Peripherals/FM/Makefile  |   20 +
 .../net/dpa/NetCommSw/Peripherals/FM/Pcd/Makefile  |   19 +
 .../net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.c   | 2967 +++++++++++++++
 .../net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_kg.c   | 2834 ++++++++++++++
 .../net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.c  | 1379 +++++++
 .../net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.h  |  950 +++++
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd_ipc.h  |  227 ++
 .../net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_plcr.c | 1434 +++++++
 .../net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.c  |  395 ++
 .../net/dpa/NetCommSw/Peripherals/FM/Port/Makefile |   19 +
 .../dpa/NetCommSw/Peripherals/FM/Port/fm_port.c    | 4022 ++++++++++++++++++++
 .../dpa/NetCommSw/Peripherals/FM/Port/fm_port.h    |  784 ++++
 .../dpa/NetCommSw/Peripherals/FM/Port/fm_port_im.c |  590 +++
 drivers/net/dpa/NetCommSw/Peripherals/FM/fm.c      | 2478 ++++++++++++
 drivers/net/dpa/NetCommSw/Peripherals/FM/fm.h      |  629 +++
 .../net/dpa/NetCommSw/Peripherals/FM/fm_guest.c    |  289 ++
 drivers/net/dpa/NetCommSw/Peripherals/FM/fm_ipc.h  |  308 ++
 .../net/dpa/NetCommSw/Peripherals/FM/fm_muram.c    |   94 +
 .../dpa/NetCommSw/Peripherals/FM/inc/fm_common.h   |  606 +++
 .../net/dpa/NetCommSw/Peripherals/FM/inc/fm_hc.h   |   79 +
 drivers/net/dpa/NetCommSw/dflags.h                 |   59 +
 drivers/net/dpa/NetCommSw/etc/Makefile             |   11 +
 drivers/net/dpa/NetCommSw/etc/error.c              |  118 +
 drivers/net/dpa/NetCommSw/etc/list.c               |   70 +
 drivers/net/dpa/NetCommSw/etc/memcpy.c             |  671 ++++
 drivers/net/dpa/NetCommSw/etc/mm.c                 | 1083 ++++++
 drivers/net/dpa/NetCommSw/etc/mm.h                 |  101 +
 drivers/net/dpa/NetCommSw/etc/sprint.c             |   86 +
 drivers/net/dpa/NetCommSw/events_mapping.h         |   51 +
 .../NetCommSw/inc/Peripherals/crc_mac_addr_ext.h   |  363 ++
 drivers/net/dpa/NetCommSw/inc/Peripherals/fm_ext.h | 1694 ++++++++
 .../net/dpa/NetCommSw/inc/Peripherals/fm_mac_ext.h |  617 +++
 .../dpa/NetCommSw/inc/Peripherals/fm_muram_ext.h   |  142 +
 .../net/dpa/NetCommSw/inc/Peripherals/fm_pcd_ext.h | 1889 +++++++++
 .../dpa/NetCommSw/inc/Peripherals/fm_port_ext.h    | 1889 +++++++++
 .../dpa/NetCommSw/inc/Peripherals/mii_acc_ext.h    |   75 +
 drivers/net/dpa/NetCommSw/inc/ctype_ext.h          |   96 +
 drivers/net/dpa/NetCommSw/inc/debug_ext.h          |  258 ++
 drivers/net/dpa/NetCommSw/inc/endian_ext.h         |  458 +++
 drivers/net/dpa/NetCommSw/inc/enet_ext.h           |  151 +
 drivers/net/dpa/NetCommSw/inc/error_ext.h          |  538 +++
 drivers/net/dpa/NetCommSw/inc/etc/list_ext.h       |  357 ++
 drivers/net/dpa/NetCommSw/inc/etc/mem_ext.h        |  324 ++
 drivers/net/dpa/NetCommSw/inc/etc/memcpy_ext.h     |  173 +
 drivers/net/dpa/NetCommSw/inc/etc/mm_ext.h         |  301 ++
 drivers/net/dpa/NetCommSw/inc/etc/sprint_ext.h     |  121 +
 .../inc/integrations/P4080/part_integration_ext.h  |  306 ++
 .../net/dpa/NetCommSw/inc/integrations/part_ext.h  |   85 +
 drivers/net/dpa/NetCommSw/inc/math_ext.h           |  101 +
 drivers/net/dpa/NetCommSw/inc/ncsw_ext.h           |  383 ++
 drivers/net/dpa/NetCommSw/inc/net_ext.h            |  365 ++
 drivers/net/dpa/NetCommSw/inc/std_ext.h            |   48 +
 drivers/net/dpa/NetCommSw/inc/stdarg_ext.h         |   48 +
 drivers/net/dpa/NetCommSw/inc/stdlib_ext.h         |  164 +
 drivers/net/dpa/NetCommSw/inc/string_ext.h         |   58 +
 drivers/net/dpa/NetCommSw/inc/types_ext.h          |   94 +
 drivers/net/dpa/NetCommSw/inc/xx_ext.h             |  818 ++++
 .../net/dpa/NetCommSw/integrations/P4080/Makefile  |   11 +
 .../net/dpa/NetCommSw/integrations/P4080/P4080.c   |  157 +
 .../net/dpa/NetCommSw/integrations/P4080/P4080.h   |  166 +
 .../dpa/NetCommSw/integrations/P4080/P4080_mng.c   |  150 +
 .../NetCommSw/integrations/P4080/module_strings.c  |   48 +
 drivers/net/dpa/NetCommSw/ncsw_config.mk           |   21 +
 .../NetCommSw/user/env/linux/kernel/2.6/Makefile   |   13 +
 .../kernel/2.6/inc/ioctl/Peripherals/fm_ioctls.h   |  293 ++
 .../2.6/inc/ioctl/Peripherals/fm_pcd_ioctls.h      | 1498 ++++++++
 .../2.6/inc/ioctl/Peripherals/fm_port_ioctls.h     |  592 +++
 .../2.6/inc/ioctl/Peripherals/fm_test_ioctls.h     |  159 +
 .../ioctl/integrations/P4080/integration_ioctls.h  |   47 +
 .../user/env/linux/kernel/2.6/inc/ioctl/ioctls.h   |   84 +
 .../env/linux/kernel/2.6/inc/ioctl/net_ioctls.h    |  365 ++
 .../user/env/linux/kernel/2.6/inc/procbuff_ext.h   |   58 +
 .../env/linux/kernel/2.6/inc/system/platform_ext.h |  126 +
 .../kernel/2.6/inc/system/platform_p4080_ds_ext.h  |   64 +
 .../user/env/linux/kernel/2.6/inc/system/sys_ext.h |  290 ++
 .../env/linux/kernel/2.6/inc/system/sys_io_ext.h   |   46 +
 .../user/env/linux/kernel/2.6/inc/types_linux.h    |  197 +
 .../kernel/2.6/inc/wrappers/Peripherals/fsl_fman.h |  254 ++
 .../2.6/inc/wrappers/Peripherals/fsl_fman_test.h   |   68 +
 .../2.6/inc/wrappers/Peripherals/lnxwrp_fm_ext.h   |  161 +
 .../2.6/modules/integrations/P4080/FM/Makefile     |   11 +
 .../kernel/2.6/modules/integrations/P4080/FM/fmm.c |  205 +
 .../2.6/modules/integrations/P4080/FM/mod_config.h |   41 +
 .../user/env/linux/kernel/2.6/system/Makefile      |   13 +
 .../kernel/2.6/system/platform/P4080/Makefile      |    9 +
 .../2.6/system/platform/P4080/platform_p4080_ds.c  |  124 +
 .../user/env/linux/kernel/2.6/system/sys_init.c    |   48 +
 .../user/env/linux/kernel/2.6/system/sys_io.c      |  179 +
 .../user/env/linux/kernel/2.6/util/Makefile        |   11 +
 .../user/env/linux/kernel/2.6/util/procbuff.c      |  116 +
 .../user/env/linux/kernel/2.6/util/procbuff.h      |   48 +
 .../kernel/2.6/wrappers/Peripherals/FM/Makefile    |   15 +
 .../kernel/2.6/wrappers/Peripherals/FM/fman_test.c |  696 ++++
 .../kernel/2.6/wrappers/Peripherals/FM/lnxwrp_fm.c | 1797 +++++++++
 .../kernel/2.6/wrappers/Peripherals/FM/lnxwrp_fm.h |  189 +
 .../2.6/wrappers/Peripherals/FM/lnxwrp_fm_ioctls.c | 1012 +++++
 .../user/env/linux/kernel/2.6/xx/Makefile          |   17 +
 .../NetCommSw/user/env/linux/kernel/2.6/xx/ctype.c |   67 +
 .../env/linux/kernel/2.6/xx/integrations/Makefile  |    9 +
 .../kernel/2.6/xx/integrations/P4080/Makefile      |   13 +
 .../2.6/xx/integrations/P4080/xx_integration.c     |  165 +
 .../user/env/linux/kernel/2.6/xx/stdlib.c          |  264 ++
 .../user/env/linux/kernel/2.6/xx/udivdi3.c         |  132 +
 .../NetCommSw/user/env/linux/kernel/2.6/xx/xx.h    |   43 +
 .../user/env/linux/kernel/2.6/xx/xx_linux.c        |  924 +++++
 drivers/net/dpa/mac-api.c                          |   12 -
 drivers/net/dpa/mac.c                              |   12 -
 123 files changed, 50791 insertions(+), 24 deletions(-)
 create mode 100644 drivers/net/dpa/NetCommSw/Kconfig
 create mode 100644 drivers/net/dpa/NetCommSw/Makefile
 create mode 100644 drivers/net/dpa/NetCommSw/Peripherals/FM/HC/Makefile
 create mode 100644 drivers/net/dpa/NetCommSw/Peripherals/FM/HC/hc.c
 create mode 100644 drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/Makefile
 create mode 100644 drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.c
 create mode 100644 drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.h
 create mode 100644 drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/dtsec_mii_acc.c
 create mode 100644 drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/dtsec_mii_acc.h
 create mode 100644 drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.c
 create mode 100644 drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.h
 create mode 100644 drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/tgec.c
 create mode 100644 drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/tgec.h
 create mode 100644 drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/tgec_mii_acc.c
 create mode 100644 drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/tgec_mii_acc.h
 create mode 100644 drivers/net/dpa/NetCommSw/Peripherals/FM/Makefile
 create mode 100644 drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/Makefile
 create mode 100644 drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.c
 create mode 100644 drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_kg.c
 create mode 100644 drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.c
 create mode 100644 drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.h
 create mode 100644 drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd_ipc.h
 create mode 100644 drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_plcr.c
 create mode 100644 drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.c
 create mode 100644 drivers/net/dpa/NetCommSw/Peripherals/FM/Port/Makefile
 create mode 100644 drivers/net/dpa/NetCommSw/Peripherals/FM/Port/fm_port.c
 create mode 100644 drivers/net/dpa/NetCommSw/Peripherals/FM/Port/fm_port.h
 create mode 100644 drivers/net/dpa/NetCommSw/Peripherals/FM/Port/fm_port_im.c
 create mode 100644 drivers/net/dpa/NetCommSw/Peripherals/FM/fm.c
 create mode 100644 drivers/net/dpa/NetCommSw/Peripherals/FM/fm.h
 create mode 100644 drivers/net/dpa/NetCommSw/Peripherals/FM/fm_guest.c
 create mode 100644 drivers/net/dpa/NetCommSw/Peripherals/FM/fm_ipc.h
 create mode 100644 drivers/net/dpa/NetCommSw/Peripherals/FM/fm_muram.c
 create mode 100644 drivers/net/dpa/NetCommSw/Peripherals/FM/inc/fm_common.h
 create mode 100644 drivers/net/dpa/NetCommSw/Peripherals/FM/inc/fm_hc.h
 create mode 100644 drivers/net/dpa/NetCommSw/dflags.h
 create mode 100644 drivers/net/dpa/NetCommSw/etc/Makefile
 create mode 100644 drivers/net/dpa/NetCommSw/etc/error.c
 create mode 100644 drivers/net/dpa/NetCommSw/etc/list.c
 create mode 100644 drivers/net/dpa/NetCommSw/etc/memcpy.c
 create mode 100644 drivers/net/dpa/NetCommSw/etc/mm.c
 create mode 100644 drivers/net/dpa/NetCommSw/etc/mm.h
 create mode 100644 drivers/net/dpa/NetCommSw/etc/sprint.c
 create mode 100644 drivers/net/dpa/NetCommSw/events_mapping.h
 create mode 100644 drivers/net/dpa/NetCommSw/inc/Peripherals/crc_mac_addr_ext.h
 create mode 100644 drivers/net/dpa/NetCommSw/inc/Peripherals/fm_ext.h
 create mode 100644 drivers/net/dpa/NetCommSw/inc/Peripherals/fm_mac_ext.h
 create mode 100644 drivers/net/dpa/NetCommSw/inc/Peripherals/fm_muram_ext.h
 create mode 100644 drivers/net/dpa/NetCommSw/inc/Peripherals/fm_pcd_ext.h
 create mode 100644 drivers/net/dpa/NetCommSw/inc/Peripherals/fm_port_ext.h
 create mode 100644 drivers/net/dpa/NetCommSw/inc/Peripherals/mii_acc_ext.h
 create mode 100644 drivers/net/dpa/NetCommSw/inc/ctype_ext.h
 create mode 100644 drivers/net/dpa/NetCommSw/inc/debug_ext.h
 create mode 100644 drivers/net/dpa/NetCommSw/inc/endian_ext.h
 create mode 100644 drivers/net/dpa/NetCommSw/inc/enet_ext.h
 create mode 100644 drivers/net/dpa/NetCommSw/inc/error_ext.h
 create mode 100644 drivers/net/dpa/NetCommSw/inc/etc/list_ext.h
 create mode 100644 drivers/net/dpa/NetCommSw/inc/etc/mem_ext.h
 create mode 100644 drivers/net/dpa/NetCommSw/inc/etc/memcpy_ext.h
 create mode 100644 drivers/net/dpa/NetCommSw/inc/etc/mm_ext.h
 create mode 100644 drivers/net/dpa/NetCommSw/inc/etc/sprint_ext.h
 create mode 100644 drivers/net/dpa/NetCommSw/inc/integrations/P4080/part_integration_ext.h
 create mode 100644 drivers/net/dpa/NetCommSw/inc/integrations/part_ext.h
 create mode 100644 drivers/net/dpa/NetCommSw/inc/math_ext.h
 create mode 100644 drivers/net/dpa/NetCommSw/inc/ncsw_ext.h
 create mode 100644 drivers/net/dpa/NetCommSw/inc/net_ext.h
 create mode 100644 drivers/net/dpa/NetCommSw/inc/std_ext.h
 create mode 100644 drivers/net/dpa/NetCommSw/inc/stdarg_ext.h
 create mode 100644 drivers/net/dpa/NetCommSw/inc/stdlib_ext.h
 create mode 100644 drivers/net/dpa/NetCommSw/inc/string_ext.h
 create mode 100644 drivers/net/dpa/NetCommSw/inc/types_ext.h
 create mode 100644 drivers/net/dpa/NetCommSw/inc/xx_ext.h
 create mode 100644 drivers/net/dpa/NetCommSw/integrations/P4080/Makefile
 create mode 100644 drivers/net/dpa/NetCommSw/integrations/P4080/P4080.c
 create mode 100644 drivers/net/dpa/NetCommSw/integrations/P4080/P4080.h
 create mode 100644 drivers/net/dpa/NetCommSw/integrations/P4080/P4080_mng.c
 create mode 100644 drivers/net/dpa/NetCommSw/integrations/P4080/module_strings.c
 create mode 100644 drivers/net/dpa/NetCommSw/ncsw_config.mk
 create mode 100644 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/Makefile
 create mode 100644 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/Peripherals/fm_ioctls.h
 create mode 100644 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/Peripherals/fm_pcd_ioctls.h
 create mode 100644 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/Peripherals/fm_port_ioctls.h
 create mode 100644 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/Peripherals/fm_test_ioctls.h
 create mode 100644 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/integrations/P4080/integration_ioctls.h
 create mode 100644 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/ioctls.h
 create mode 100644 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/net_ioctls.h
 create mode 100644 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/procbuff_ext.h
 create mode 100644 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/system/platform_ext.h
 create mode 100644 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/system/platform_p4080_ds_ext.h
 create mode 100644 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/system/sys_ext.h
 create mode 100644 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/system/sys_io_ext.h
 create mode 100644 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/types_linux.h
 create mode 100644 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/wrappers/Peripherals/fsl_fman.h
 create mode 100644 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/wrappers/Peripherals/fsl_fman_test.h
 create mode 100644 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/wrappers/Peripherals/lnxwrp_fm_ext.h
 create mode 100644 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/modules/integrations/P4080/FM/Makefile
 create mode 100644 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/modules/integrations/P4080/FM/fmm.c
 create mode 100644 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/modules/integrations/P4080/FM/mod_config.h
 create mode 100644 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/system/Makefile
 create mode 100644 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/system/platform/P4080/Makefile
 create mode 100644 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/system/platform/P4080/platform_p4080_ds.c
 create mode 100644 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/system/sys_init.c
 create mode 100644 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/system/sys_io.c
 create mode 100644 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/util/Makefile
 create mode 100644 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/util/procbuff.c
 create mode 100644 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/util/procbuff.h
 create mode 100644 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/Makefile
 create mode 100644 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/fman_test.c
 create mode 100644 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/lnxwrp_fm.c
 create mode 100644 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/lnxwrp_fm.h
 create mode 100644 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/lnxwrp_fm_ioctls.c
 create mode 100644 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/xx/Makefile
 create mode 100644 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/xx/ctype.c
 create mode 100644 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/xx/integrations/Makefile
 create mode 100644 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/xx/integrations/P4080/Makefile
 create mode 100644 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/xx/integrations/P4080/xx_integration.c
 create mode 100644 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/xx/stdlib.c
 create mode 100644 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/xx/udivdi3.c
 create mode 100644 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/xx/xx.h
 create mode 100644 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/xx/xx_linux.c

diff --git a/drivers/Kconfig b/drivers/Kconfig
index dc298a1..e906989 100644
--- a/drivers/Kconfig
+++ b/drivers/Kconfig
@@ -105,4 +105,6 @@ source "drivers/xen/Kconfig"
 source "drivers/hwalloc/Kconfig"
 
 source "drivers/hwqueue/Kconfig"
+
+source "drivers/net/dpa/NetCommSw/Kconfig"
 endmenu
diff --git a/drivers/net/dpa/NetCommSw/Kconfig b/drivers/net/dpa/NetCommSw/Kconfig
new file mode 100644
index 0000000..70dde1a
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/Kconfig
@@ -0,0 +1,20 @@
+menu "Frame Manager support"
+
+menuconfig FSL_FMAN
+	bool "Freescale Frame Manager (datapath) support"
+	depends on PPC_E500MC
+	default y
+	---help---
+	  If unsure, say Y.
+
+if FSL_FMAN
+
+config FSL_FMAN_TEST
+	bool "Fman test module"
+	default n
+	---help---
+	  This option compiles test code for Fman.
+
+endif # FSL_FMAN
+
+endmenu
diff --git a/drivers/net/dpa/NetCommSw/Makefile b/drivers/net/dpa/NetCommSw/Makefile
new file mode 100644
index 0000000..a92ee12
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/Makefile
@@ -0,0 +1,12 @@
+#
+# Makefile for the Freescale Ethernet controllers
+#
+EXTRA_CFLAGS           += -DVERSION=\"\"
+#
+#Include netcomm SW specific definitions
+include $(srctree)/drivers/net/dpa/NetCommSw/ncsw_config.mk
+#
+obj-y		+= etc/
+obj-y		+= integrations/P4080/
+obj-y		+= Peripherals/FM/
+obj-y		+= user/env/linux/kernel/2.6/
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/HC/Makefile b/drivers/net/dpa/NetCommSw/Peripherals/FM/HC/Makefile
new file mode 100644
index 0000000..3ec3824
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/HC/Makefile
@@ -0,0 +1,15 @@
+#
+# Makefile for the Freescale Ethernet controllers
+#
+EXTRA_CFLAGS           += -DVERSION=\"\"
+#
+#Include netcomm SW specific definitions
+include $(srctree)/drivers/net/dpa/NetCommSw/ncsw_config.mk
+
+NCSW_FM_INC = $(srctree)/drivers/net/dpa/NetCommSw/Peripherals/FM/inc
+
+EXTRA_CFLAGS += -I$(NCSW_FM_INC)
+
+obj-y		+= fsl-ncsw-Hc.o
+
+fsl-ncsw-Hc-objs	:=   hc.o
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/HC/hc.c b/drivers/net/dpa/NetCommSw/Peripherals/FM/HC/hc.c
new file mode 100644
index 0000000..c67d2b0
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/HC/hc.c
@@ -0,0 +1,1177 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "std_ext.h"
+#include "error_ext.h"
+#include "sprint_ext.h"
+#include "string_ext.h"
+
+#include "fm_common.h"
+#include "fm_hc.h"
+
+
+#define __ERR_MODULE__  MODULE_FM
+
+#define SIZE_OF_HC_FRAME_PORT_REGS          (sizeof(t_HcFrame)-sizeof(t_FmPcdKgInterModuleSchemeRegs)+sizeof(t_FmPcdKgPortRegs))
+#define SIZE_OF_HC_FRAME_SCHEME_REGS        sizeof(t_HcFrame)
+#define SIZE_OF_HC_FRAME_PROFILES_REGS      (sizeof(t_HcFrame)-sizeof(t_FmPcdKgInterModuleSchemeRegs)+sizeof(t_FmPcdPlcrInterModuleProfileRegs))
+#define SIZE_OF_HC_FRAME_PROFILE_CNT        (sizeof(t_HcFrame)-sizeof(t_FmPcdPlcrInterModuleProfileRegs)+sizeof(uint32_t))
+#define SIZE_OF_HC_FRAME_READ_OR_CC_DYNAMIC 16
+
+/*
+#define BUILD_FD(len)                                                           \
+do {                                                                            \
+        memset(&fmFd, 0, sizeof(t_FmFD));                                       \
+        FM_FD_SET_DD(&fmFd, (uint32_t)0x3);                                     \
+        FM_FD_SET_PID(&fmFd, (uint32_t)0x3f);                                   \
+        FM_FD_SET_BPID(&fmFd, (uint32_t)0xff);                                  \
+        FM_FD_SET_ADDR(&fmFd, &hcFrame);                                        \
+        FM_FD_SET_OFFSET(&fmFd, 0);                                             \
+        FM_FD_SET_LENGTH(&fmFd, len);                                           \
+} while (0)
+*/
+#define BUILD_FD(len)                                                           \
+do {                                                                            \
+        memset(&fmFd, 0, sizeof(t_FmFD));                                       \
+        FM_FD_SET_ADDR(&fmFd, &hcFrame);                                        \
+        FM_FD_SET_OFFSET(&fmFd, 0);                                             \
+        FM_FD_SET_LENGTH(&fmFd, len);                                           \
+} while (0)
+
+#define ENQUEUE_FRM(frm)                                                        \
+do {                                                                            \
+    uint32_t savedSeqNum = p_FmHc->seqNum;                                      \
+    p_FmHc->seqNum = (uint32_t)((p_FmHc->seqNum+1)%32);                         \
+    ASSERT_COND(!p_FmHc->wait[savedSeqNum]);                                    \
+    p_FmHc->wait[savedSeqNum] = TRUE;                                           \
+    err = p_FmHc->f_QmEnqueueCB(p_FmHc->h_QmArg, p_FmHc->enqFqid, (void *)frm); \
+    if(err)                                                                     \
+        RETURN_ERROR(MINOR, err, ("HC enqueue failed"));                        \
+    while (p_FmHc->wait[savedSeqNum]) ;                                         \
+} while (0)
+
+#define ENQUEUE_FRM_RET_NULL(frm)                                               \
+do {                                                                            \
+    uint32_t savedSeqNum = p_FmHc->seqNum;                                      \
+    p_FmHc->seqNum = (uint32_t)((p_FmHc->seqNum+1)%32);                         \
+    ASSERT_COND(!p_FmHc->wait[savedSeqNum]);                                    \
+    p_FmHc->wait[savedSeqNum] = TRUE;                                           \
+    err = p_FmHc->f_QmEnqueueCB(p_FmHc->h_QmArg, p_FmHc->enqFqid, (void *)frm); \
+    if(err)  {                                                                  \
+        REPORT_ERROR(MINOR, err, ("HC enqueue failed")); return NULL;           \
+    }                                                                           \
+    while (p_FmHc->wait[savedSeqNum]) ;                                         \
+} while (0)
+
+#define TRY_LOCK                                                                \
+do {                                                                            \
+    uint32_t intFlags;                                                          \
+    intFlags = XX_DisableAllIntr();                                             \
+    if (p_FmHc->lock)                                                           \
+    {                                                                           \
+        XX_RestoreAllIntr(intFlags);                                            \
+        return ERROR_CODE(E_BUSY);                                              \
+    }                                                                           \
+    p_FmHc->lock = TRUE;                                                        \
+    XX_RestoreAllIntr(intFlags);                                                \
+} while (0)
+
+#define TRY_LOCK_RETURN_NULL                                                    \
+do {                                                                            \
+    uint32_t intFlags;                                                          \
+    intFlags = XX_DisableAllIntr();                                             \
+    if (p_FmHc->lock)                                                           \
+    {                                                                           \
+        XX_RestoreAllIntr(intFlags);                                            \
+        REPORT_ERROR(MINOR, E_BUSY, ("nested host-commands!"));                 \
+        return NULL;                                                            \
+    }                                                                           \
+    p_FmHc->lock = TRUE;                                                        \
+    XX_RestoreAllIntr(intFlags);                                                \
+} while (0)
+
+
+
+#ifdef __MWERKS__
+#pragma pack(push,1)
+#endif /*__MWERKS__ */
+#define MEM_MAP_START
+
+/**************************************************************************//**
+ @Description   PCD KG scheme registers
+*//***************************************************************************/
+typedef _Packed struct t_FmPcdKgSchemeRegsWithoutCounter {
+    uint32_t kgse_mode;    /**< MODE */
+    uint32_t kgse_ekfc;    /**< Extract Known Fields Command */
+    uint32_t kgse_ekdv;    /**< Extract Known Default Value */
+    uint32_t kgse_bmch;    /**< Bit Mask Command High */
+    uint32_t kgse_bmcl;    /**< Bit Mask Command Low */
+    uint32_t kgse_fqb;     /**< Frame Queue Base */
+    uint32_t kgse_hc;      /**< Hash Command */
+    uint32_t kgse_ppc;     /**< Policer Profile Command */
+    uint32_t kgse_gec[FM_PCD_KG_NUM_OF_GENERIC_REGS];
+                           /**< Generic Extract Command */
+    uint32_t kgse_dv0;     /**< KeyGen Scheme Entry Default Value 0 */
+    uint32_t kgse_dv1;     /**< KeyGen Scheme Entry Default Value 1 */
+    uint32_t kgse_ccbs;    /**< KeyGen Scheme Entry Coarse Classification Bit*/
+    uint32_t kgse_mv;      /**< KeyGen Scheme Entry Match vector */
+} _PackedType t_FmPcdKgSchemeRegsWithoutCounter;
+
+#define MEM_MAP_END
+#ifdef __MWERKS__
+#pragma pack(pop)
+#endif /* __MWERKS__ */
+
+typedef struct t_FmPcdKgPortRegs {
+        uint32_t                spReg;
+        uint32_t                cppReg;
+} t_FmPcdKgPortRegs;
+
+typedef struct t_HcFrame {
+    uint32_t                    opcode;
+    uint32_t                    actionReg;
+    uint32_t                    extraReg;
+    uint32_t                    commandSequence;
+    union
+    {
+        t_FmPcdKgInterModuleSchemeRegs      schemeRegs;
+        t_FmPcdKgInterModuleSchemeRegs      schemeRegsWithoutCounter;
+        t_FmPcdPlcrInterModuleProfileRegs   profileRegs;
+        uint32_t                            singleRegForWrite;    /* for writing SP, CPP, profile counter */
+        t_FmPcdKgPortRegs                   portRegsForRead;
+        uint32_t                            clsPlanEntries[CLS_PLAN_NUM_PER_GRP];
+    } hcSpecificData;
+} t_HcFrame;
+
+typedef struct t_FmHc {
+    t_Handle                h_FmPcd;
+    t_Handle                h_HcPortDev;
+    uint32_t                enqFqid;            /**< Host-Command enqueue Queue Id. */
+    t_FmPcdQmEnqueueCB      *f_QmEnqueueCB;     /**< TBD */
+    t_Handle                h_QmArg;            /**< TBD */
+
+    //volatile bool           lock;
+    uint32_t                seqNum;
+    volatile bool           wait[32];
+} t_FmHc;
+
+
+static t_Error KgHcSetClsPlan(t_FmHc *p_FmHc, t_FmPcdKgInterModuleClsPlanSet *p_Set)
+{
+    t_HcFrame               hcFrame;
+    t_FmFD                  fmFd;
+    int                     i;
+    t_Error                 err;
+
+    ASSERT_COND(p_FmHc);
+
+    for(i=p_Set->baseEntry;i<p_Set->baseEntry+p_Set->numOfClsPlanEntries;i+=8)
+    {
+        memset(&hcFrame, 0, sizeof(hcFrame));
+        hcFrame.opcode = 0x00000001;
+        hcFrame.actionReg  = FmPcdKgBuildWriteClsPlanBlockActionReg((uint8_t)(i / CLS_PLAN_NUM_PER_GRP));
+        hcFrame.extraReg = 0xFFFFF800;
+        hcFrame.commandSequence = p_FmHc->seqNum;
+        memcpy(&hcFrame.hcSpecificData.clsPlanEntries, &p_Set->vectors[i-p_Set->baseEntry], CLS_PLAN_NUM_PER_GRP*sizeof(uint32_t));
+
+        BUILD_FD(sizeof(hcFrame));
+
+        ENQUEUE_FRM(&fmFd);
+    }
+
+    return E_OK;
+}
+
+static t_Error CcHcDoDynamicChange(t_FmHc *p_FmHc, bool keyModify, t_Handle p_OldPointer, t_Handle p_NewPointer)
+{
+    t_HcFrame               hcFrame;
+    t_FmFD                  fmFd;
+    t_Error                 err;
+
+    ASSERT_COND(p_FmHc);
+
+    memset(&hcFrame, 0, sizeof(hcFrame));
+    hcFrame.opcode = 0x00000003;
+    hcFrame.actionReg  = FmPcdCcGetNodeAddrOffset(p_FmHc->h_FmPcd, p_NewPointer);
+    if(hcFrame.actionReg == ILLEGAL_BASE)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Something wrong with base address"));
+    hcFrame.actionReg  |=  0xc0000000;
+    if(keyModify)
+        hcFrame.extraReg   = FmPcdCcGetNodeAddrOffsetFromNodeInfo(p_FmHc->h_FmPcd, p_OldPointer);
+    else
+        hcFrame.extraReg   = FmPcdCcGetNodeAddrOffset(p_FmHc->h_FmPcd, p_OldPointer);
+    if(hcFrame.extraReg == ILLEGAL_BASE)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Something wrong with base address"));
+    hcFrame.commandSequence = p_FmHc->seqNum;
+
+    BUILD_FD(SIZE_OF_HC_FRAME_READ_OR_CC_DYNAMIC);
+
+    ENQUEUE_FRM(&fmFd);
+
+    return E_OK;
+}
+
+static t_Error CcHcDynamicChangeForNextEngine(t_FmHc *p_FmHc, t_Handle h_OldPointer, t_Handle h_NewPointer)
+{
+    t_Error err;
+
+    ASSERT_COND(p_FmHc);
+
+    err = CcHcDoDynamicChange(p_FmHc, FALSE, h_OldPointer, h_NewPointer);
+    if(err)
+    {
+        FmPcdCcReleaseModifiedOnlyNextEngine(p_FmHc->h_FmPcd, h_OldPointer, h_NewPointer, FALSE);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
+
+    return FmPcdCcReleaseModifiedOnlyNextEngine(p_FmHc->h_FmPcd, h_OldPointer, h_NewPointer, TRUE);
+}
+static t_Error HcDynamicChangeForKey(t_FmHc *p_FmHc,t_Handle  *h_OldPointersLst, t_Handle h_NewPointer)
+{
+
+    t_List      *p_Pos;
+    uint16_t    i = 0;
+    t_Error     err;
+    t_List      *p_OldPointersLst = (t_List *)h_OldPointersLst;
+
+    LIST_FOR_EACH(p_Pos, p_OldPointersLst)
+    {
+        err = CcHcDoDynamicChange(p_FmHc, TRUE, (t_Handle)p_Pos, h_NewPointer);
+        if(err)
+        {
+            FmPcdCcReleaseModifiedKey(p_FmHc->h_FmPcd, p_OldPointersLst, h_NewPointer, i);
+            RETURN_ERROR(MAJOR, err, ("For part of nodes changes are done - situation is danger"));
+        }
+        i++;
+    }
+
+    err = FmPcdCcReleaseModifiedKey(p_FmHc->h_FmPcd, p_OldPointersLst, h_NewPointer, i);
+    if(err)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+
+    LIST_Del(p_OldPointersLst);
+
+    return E_OK;
+}
+
+t_Handle    FmHcConfigAndInit(t_FmHcParams *p_FmHcParams)
+{
+    t_FmHc          *p_FmHc;
+#ifndef CONFIG_GUEST_PARTITION
+    t_FmPortParams  fmPortParam;
+    t_Error         err;
+#endif /* !CONFIG_GUEST_PARTITION */
+
+    p_FmHc = XX_Malloc(sizeof(t_FmHc));
+    if (!p_FmHc)
+    {
+        REPORT_ERROR(MINOR, E_NO_MEMORY, ("HC obj"));
+        return NULL;
+    }
+    memset(p_FmHc,0,sizeof(t_FmHc));
+
+    p_FmHc->h_FmPcd             = p_FmHcParams->h_FmPcd;
+    p_FmHc->enqFqid             = p_FmHcParams->params.enqFqid;
+    p_FmHc->f_QmEnqueueCB       = p_FmHcParams->params.f_QmEnqueueCB;
+    p_FmHc->h_QmArg             = p_FmHcParams->params.h_QmArg;
+
+#ifndef CONFIG_GUEST_PARTITION
+    memset(&fmPortParam, 0, sizeof(fmPortParam));
+    fmPortParam.baseAddr    = p_FmHcParams->params.portBaseAddr;
+    fmPortParam.portType    = e_FM_PORT_TYPE_HOST_COMMAND;
+    fmPortParam.portId      = p_FmHcParams->params.portId;
+    fmPortParam.h_Fm        = p_FmHcParams->h_Fm;
+
+    fmPortParam.specificParams.nonRxParams.errFqid      = p_FmHcParams->params.errFqid;
+    fmPortParam.specificParams.nonRxParams.dfltFqid     = p_FmHcParams->params.confFqid;
+    fmPortParam.specificParams.nonRxParams.deqSubPortal = p_FmHcParams->params.deqSubPortal;
+
+    p_FmHc->h_HcPortDev = FM_PORT_Config(&fmPortParam);
+    if(!p_FmHc->h_HcPortDev)
+    {
+        REPORT_ERROR(MAJOR, E_INVALID_HANDLE, ("FM HC port!"));
+        XX_Free(p_FmHc);
+        return NULL;
+    }
+
+    /* final init */
+    if ((err = FM_PORT_Init(p_FmHc->h_HcPortDev)) != E_OK)
+    {
+        REPORT_ERROR(MAJOR, E_INVALID_HANDLE, ("FM HC port!"));
+        FmHcFree(p_FmHc);
+        return NULL;
+    }
+#endif /* !CONFIG_GUEST_PARTITION */
+
+    return (t_Handle)p_FmHc;
+}
+
+void FmHcFree(t_Handle h_FmHc)
+{
+    t_FmHc  *p_FmHc = (t_FmHc*)h_FmHc;
+
+    if (!p_FmHc)
+        return;
+
+    if (p_FmHc->h_HcPortDev)
+        FM_PORT_Free(p_FmHc->h_HcPortDev);
+
+    XX_Free(p_FmHc);
+}
+
+void FmHcTxConf(t_Handle h_FmHc, t_FmFD *p_Fd)
+{
+    t_FmHc      *p_FmHc = (t_FmHc*)h_FmHc;
+    t_HcFrame   *p_HcFrame;
+
+    ASSERT_COND(p_FmHc);
+
+    p_HcFrame  = CAST_UINT64_TO_POINTER_TYPE(t_HcFrame,
+                                             (CAST_POINTER_TO_UINT64(FM_FD_GET_ADDR(p_Fd)) + FM_FD_GET_OFFSET(p_Fd)));
+    ASSERT_COND(p_FmHc->wait[p_HcFrame->commandSequence]);
+
+    p_FmHc->wait[p_HcFrame->commandSequence] = FALSE;
+}
+
+t_Handle FmHcPcdKgSetScheme(t_Handle h_FmHc, t_FmPcdKgSchemeParams *p_Scheme)
+{
+    t_FmHc                              *p_FmHc = (t_FmHc*)h_FmHc;
+    t_Error                             err;
+    t_FmPcdKgInterModuleSchemeRegs      schemeRegs;
+    t_HcFrame                           hcFrame;
+    t_FmFD                              fmFd;
+    uint8_t                             physicalSchemeId, relativeSchemeId;
+
+    if (FmPcdTryLock(p_FmHc->h_FmPcd))
+        return NULL;
+
+    if(!p_Scheme->modify)
+    {
+        /* check that schameId is in range */
+        if(p_Scheme->id.relativeSchemeId >= FmPcdKgGetNumOfPartitionSchemes(p_FmHc->h_FmPcd))
+        {
+            REPORT_ERROR(MAJOR, E_NOT_IN_RANGE, ("Scheme is out of range"));
+            return NULL;
+        }
+
+        relativeSchemeId = p_Scheme->id.relativeSchemeId;
+
+        if (FmPcdKgSchemeTryLock(p_FmHc->h_FmPcd, relativeSchemeId))
+        {
+            FmPcdReleaseLock(p_FmHc->h_FmPcd);
+            return NULL;
+        }
+        FmPcdReleaseLock(p_FmHc->h_FmPcd);
+
+        physicalSchemeId = FmPcdKgGetPhysicalSchemeId(p_FmHc->h_FmPcd, relativeSchemeId);
+
+        memset(&hcFrame, 0, sizeof(hcFrame));
+        hcFrame.opcode = 0x00000001;
+        hcFrame.actionReg  = FmPcdKgBuildReadSchemeActionReg(physicalSchemeId);
+        hcFrame.extraReg = 0xFFFFF800;
+        hcFrame.commandSequence = p_FmHc->seqNum;
+
+        BUILD_FD(SIZE_OF_HC_FRAME_READ_OR_CC_DYNAMIC);
+
+        ENQUEUE_FRM_RET_NULL(&fmFd);
+
+        /* check if this scheme is already used */
+        if (FmPcdKgHwSchemeIsValid(hcFrame.hcSpecificData.schemeRegs.kgse_mode))
+        {
+            FmPcdKgReleaseSchemeLock(p_FmHc->h_FmPcd, relativeSchemeId);
+            REPORT_ERROR(MAJOR, E_ALREADY_EXISTS, ("Scheme is already used"));
+            return NULL;
+        }
+    }
+    else
+    {
+        physicalSchemeId = (uint8_t)(CAST_POINTER_TO_UINT32(p_Scheme->id.h_Scheme)-1);
+        relativeSchemeId = FmPcdKgGetRelativeSchemeId(p_FmHc->h_FmPcd, physicalSchemeId);
+        if (FmPcdKgSchemeTryLock(p_FmHc->h_FmPcd, relativeSchemeId))
+        {
+            FmPcdReleaseLock(p_FmHc->h_FmPcd);
+            return NULL;
+        }
+        FmPcdReleaseLock(p_FmHc->h_FmPcd);
+
+        if( relativeSchemeId == FM_PCD_KG_NUM_OF_SCHEMES)
+        {
+            FmPcdKgReleaseSchemeLock(p_FmHc->h_FmPcd, relativeSchemeId);
+            REPORT_ERROR(MAJOR, E_NOT_IN_RANGE, NO_MSG);
+            return NULL;
+        }
+    }
+
+    err = FmPcdKgBuildScheme(p_FmHc->h_FmPcd, p_Scheme, &schemeRegs,  &p_Scheme->orderedArray);
+    if(err)
+    {
+        FmPcdKgReleaseSchemeLock(p_FmHc->h_FmPcd, relativeSchemeId);
+        REPORT_ERROR(MAJOR, err, NO_MSG);
+        return NULL;
+    }
+
+    memset(&hcFrame, 0, sizeof(hcFrame));
+    hcFrame.opcode = 0x00000001;
+    hcFrame.actionReg  = FmPcdKgBuildWriteSchemeActionReg(physicalSchemeId, p_Scheme->schemeCounter.update);
+    hcFrame.extraReg = 0xFFFFF800;
+    hcFrame.commandSequence = p_FmHc->seqNum;
+    memcpy(&hcFrame.hcSpecificData.schemeRegs, &schemeRegs, sizeof(t_FmPcdKgInterModuleSchemeRegs));
+    //p_NewStruct= (t_FmPcdKgSchemeRegsWithoutCounter*)&hcFrame.hcSpecificData;
+    if(!p_Scheme->schemeCounter.update)
+        memcpy((t_FmPcdKgSchemeRegsWithoutCounter*)&hcFrame.hcSpecificData.schemeRegs.kgse_dv0, &schemeRegs.kgse_dv0, 4*sizeof(uint32_t));
+
+    BUILD_FD(sizeof(hcFrame));
+
+    ENQUEUE_FRM_RET_NULL(&fmFd);
+
+    FmPcdKgValidateSchemeSw(p_FmHc->h_FmPcd, relativeSchemeId);
+
+    FmPcdKgReleaseSchemeLock(p_FmHc->h_FmPcd, relativeSchemeId);
+
+    return CAST_UINT32_TO_POINTER((uint32_t)physicalSchemeId+1);
+}
+
+t_Error FmHcPcdKgDeleteScheme(t_Handle h_FmHc, t_Handle h_Scheme)
+{
+    t_FmHc                              *p_FmHc = (t_FmHc*)h_FmHc;
+    t_Error                             err;
+    t_HcFrame                           hcFrame;
+    t_FmFD                              fmFd;
+    uint8_t                             relativeSchemeId;
+    uint8_t                             physicalSchemeId = (uint8_t)(CAST_POINTER_TO_UINT32(h_Scheme)-1);
+
+    if ((err = FmPcdTryLock(p_FmHc->h_FmPcd)) != E_OK)
+        return err;
+
+    relativeSchemeId = FmPcdKgGetRelativeSchemeId(p_FmHc->h_FmPcd, physicalSchemeId);
+
+    err = FmPcdKgSchemeTryLock(p_FmHc->h_FmPcd, relativeSchemeId);
+    FmPcdReleaseLock(p_FmHc->h_FmPcd);
+    if (err)
+        return err;
+
+    if(relativeSchemeId == FM_PCD_KG_NUM_OF_SCHEMES)
+    {
+        FmPcdKgReleaseSchemeLock(p_FmHc->h_FmPcd, relativeSchemeId);
+        REPORT_ERROR(MAJOR, E_NOT_IN_RANGE, NO_MSG);
+    }
+
+    FmPcdKgCheckInvalidateSchemeSw(p_FmHc->h_FmPcd, relativeSchemeId);
+
+    memset(&hcFrame, 0, sizeof(hcFrame));
+    hcFrame.opcode = 0x00000001;
+    hcFrame.actionReg  = FmPcdKgBuildWriteSchemeActionReg(physicalSchemeId, TRUE);
+    hcFrame.extraReg = 0xFFFFF800;
+    memset(&hcFrame.hcSpecificData.schemeRegs, 0, sizeof(t_FmPcdKgInterModuleSchemeRegs));
+    hcFrame.commandSequence = p_FmHc->seqNum;
+
+    BUILD_FD(sizeof(hcFrame));
+
+    ENQUEUE_FRM(&fmFd);
+
+    FmPcdKgInvalidateSchemeSw(p_FmHc->h_FmPcd, relativeSchemeId);
+
+    FmPcdKgReleaseSchemeLock(p_FmHc->h_FmPcd, relativeSchemeId);
+
+    return E_OK;
+}
+
+uint32_t  FmHcPcdKgGetSchemeCounter(t_Handle h_FmHc, t_Handle h_Scheme)
+{
+    t_FmHc                              *p_FmHc = (t_FmHc*)h_FmHc;
+    t_Error                             err;
+    t_HcFrame                           hcFrame;
+    t_FmFD                              fmFd;
+    uint32_t                            retVal;
+    uint8_t                             relativeSchemeId;
+    uint8_t                             physicalSchemeId = (uint8_t)(CAST_POINTER_TO_UINT32(h_Scheme)-1);
+
+    if (FmPcdTryLock(p_FmHc->h_FmPcd))
+        return 0;
+
+    relativeSchemeId = FmPcdKgGetRelativeSchemeId(p_FmHc->h_FmPcd, physicalSchemeId);
+    if( relativeSchemeId == FM_PCD_KG_NUM_OF_SCHEMES)
+    {
+        FmPcdReleaseLock(p_FmHc->h_FmPcd);
+        REPORT_ERROR(MAJOR, E_NOT_IN_RANGE, NO_MSG);
+        return 0;
+    }
+
+    err = FmPcdKgSchemeTryLock(p_FmHc->h_FmPcd, relativeSchemeId);
+    FmPcdReleaseLock(p_FmHc->h_FmPcd);
+    if (err)
+        return 0;
+
+    /* first read scheme and check that it is valid */
+    memset(&hcFrame, 0, sizeof(hcFrame));
+    hcFrame.opcode = 0x00000001;
+    hcFrame.actionReg  = FmPcdKgBuildReadSchemeActionReg(physicalSchemeId);
+    hcFrame.extraReg = 0xFFFFF800;
+    hcFrame.commandSequence = p_FmHc->seqNum;
+
+    BUILD_FD(SIZE_OF_HC_FRAME_READ_OR_CC_DYNAMIC);
+
+    ENQUEUE_FRM(&fmFd);
+
+    if (!FmPcdKgHwSchemeIsValid(hcFrame.hcSpecificData.schemeRegs.kgse_mode))
+    {
+        REPORT_ERROR(MAJOR, E_ALREADY_EXISTS, ("Scheme is invalid"));
+        return 0;
+    }
+
+    retVal = hcFrame.hcSpecificData.schemeRegs.kgse_spc;
+
+    FmPcdKgReleaseSchemeLock(p_FmHc->h_FmPcd, relativeSchemeId);
+
+    return retVal;
+}
+
+t_Error  FmHcPcdKgSetSchemeCounter(t_Handle h_FmHc, t_Handle h_Scheme, uint32_t value)
+{
+
+    t_FmHc                              *p_FmHc = (t_FmHc*)h_FmHc;
+    t_Error                             err;
+    t_HcFrame                           hcFrame;
+    t_FmFD                              fmFd;
+    uint8_t                             relativeSchemeId, physicalSchemeId = (uint8_t)(CAST_POINTER_TO_UINT32(h_Scheme)-1);
+
+    if (FmPcdTryLock(p_FmHc->h_FmPcd))
+        return ERROR_CODE(E_BUSY);
+
+    relativeSchemeId = FmPcdKgGetRelativeSchemeId(p_FmHc->h_FmPcd, physicalSchemeId);
+    if( relativeSchemeId == FM_PCD_KG_NUM_OF_SCHEMES)
+    {
+        FmPcdReleaseLock(p_FmHc->h_FmPcd);
+        RETURN_ERROR(MAJOR, E_NOT_IN_RANGE, NO_MSG);
+    }
+
+    err = FmPcdKgSchemeTryLock(p_FmHc->h_FmPcd, relativeSchemeId);
+    FmPcdReleaseLock(p_FmHc->h_FmPcd);
+    if (err)
+        return err;
+
+    /* first read scheme and check that it is valid */
+    memset(&hcFrame, 0, sizeof(hcFrame));
+    hcFrame.opcode = 0x00000001;
+    hcFrame.actionReg  = FmPcdKgBuildReadSchemeActionReg(physicalSchemeId);
+    hcFrame.extraReg = 0xFFFFF800;
+    hcFrame.commandSequence = p_FmHc->seqNum;
+
+    BUILD_FD(SIZE_OF_HC_FRAME_READ_OR_CC_DYNAMIC);
+
+    ENQUEUE_FRM(&fmFd);
+
+    /* check that scheme is valid */
+    if (!FmPcdKgHwSchemeIsValid(hcFrame.hcSpecificData.schemeRegs.kgse_mode))
+    {
+        FmPcdKgReleaseSchemeLock(p_FmHc->h_FmPcd, relativeSchemeId);
+        RETURN_ERROR(MAJOR, E_ALREADY_EXISTS, ("Scheme is invalid"));
+    }
+
+    /* Write scheme back, with modified counter */
+    hcFrame.opcode = 0x00000001;
+    hcFrame.actionReg  = FmPcdKgBuildWriteSchemeActionReg(physicalSchemeId, TRUE);
+    hcFrame.extraReg = 0xFFFFF800;
+    hcFrame.commandSequence = p_FmHc->seqNum;
+    /* write counter */
+    hcFrame.hcSpecificData.schemeRegs.kgse_spc = value;
+
+    BUILD_FD(sizeof(hcFrame));
+
+    ENQUEUE_FRM(&fmFd);
+
+    FmPcdKgReleaseSchemeLock(p_FmHc->h_FmPcd, relativeSchemeId);
+
+    return E_OK;
+}
+
+t_Handle FmHcPcdKgSetClsPlanGrp(t_Handle h_FmHc, t_FmPcdKgClsPlanGrpParams *p_Grp)
+{
+    t_FmHc                          *p_FmHc = (t_FmHc*)h_FmHc;
+    t_FmPcdKgInterModuleClsPlanSet  clsPlanSet;
+    t_Handle                        h_ClsPlanGrp;
+    t_Error                         err;
+
+    h_ClsPlanGrp = FmPcdKgBuildClsPlanGrp(p_FmHc->h_FmPcd, p_Grp, &clsPlanSet);
+    if(!h_ClsPlanGrp)
+    {
+        REPORT_ERROR(MAJOR, E_INVALID_HANDLE, NO_MSG);
+        return NULL;
+    }
+
+    /* write clsPlan entries to memory */
+    err = KgHcSetClsPlan(p_FmHc, &clsPlanSet);
+    if (err)
+    {
+        REPORT_ERROR(MAJOR, err, NO_MSG);
+        return NULL;
+    }
+
+    return h_ClsPlanGrp;
+}
+
+t_Error FmHcPcdKgDeleteClsPlanGrp(t_Handle h_FmHc, t_Handle h_ClsPlanGrp)
+{
+    t_FmHc                              *p_FmHc = (t_FmHc*)h_FmHc;
+    uint8_t                             grpId = (uint8_t)(CAST_POINTER_TO_UINT32(h_ClsPlanGrp)-1);
+    t_FmPcdKgInterModuleClsPlanSet      clsPlanSet;
+
+    /* clear clsPlan entries in memory */
+    clsPlanSet.baseEntry = FmPcdKgGetClsPlanGrpBase(p_FmHc->h_FmPcd, grpId);
+    clsPlanSet.numOfClsPlanEntries = FmPcdKgGetClsPlanGrpSize(p_FmHc->h_FmPcd, grpId);
+    memset(clsPlanSet.vectors, 0, clsPlanSet.numOfClsPlanEntries*sizeof(uint32_t));
+
+    KgHcSetClsPlan(p_FmHc, &clsPlanSet);
+
+    FmPcdKgDestroyClsPlanGrp(p_FmHc->h_FmPcd, grpId);
+
+    return E_OK;
+}
+
+t_Handle FmHcPcdPlcrSetProfile(t_Handle h_FmHc,t_FmPcdPlcrProfileParams *p_Profile)
+{
+    t_FmHc                              *p_FmHc = (t_FmHc*)h_FmHc;
+    t_FmPcdPlcrInterModuleProfileRegs              profileRegs;
+    t_Error                             err;
+    uint16_t                            profileIndx;
+    t_HcFrame                           hcFrame;
+    t_FmFD                              fmFd;
+
+    if (p_Profile->modify)
+    {
+        profileIndx = (uint16_t)(CAST_POINTER_TO_UINT32(p_Profile->id.h_Profile)-1);
+        if (FmPcdPlcrProfileTryLock(p_FmHc->h_FmPcd, profileIndx))
+            return NULL;
+    }
+    else
+    {
+        if (FmPcdTryLock(p_FmHc->h_FmPcd))
+            return NULL;
+        err = FmPcdPlcrGetAbsoluteProfileId(p_FmHc->h_FmPcd,
+                                            p_Profile->id.newParams.profileType,
+                                            p_Profile->id.newParams.h_FmPort,
+                                            p_Profile->id.newParams.relativeProfileId,
+                                            &profileIndx);
+        if (err)
+        {
+            REPORT_ERROR(MAJOR, err, NO_MSG);
+            return NULL;
+        }
+        if (FmPcdPlcrProfileTryLock(p_FmHc->h_FmPcd, profileIndx))
+        {
+            FmPcdReleaseLock(p_FmHc->h_FmPcd);
+            return NULL;
+        }
+        FmPcdReleaseLock(p_FmHc->h_FmPcd);
+    }
+
+    if(!p_Profile->modify)
+    {
+        memset(&hcFrame, 0, sizeof(hcFrame));
+        hcFrame.opcode = 0x00000000;
+        hcFrame.actionReg  = FmPcdPlcrBuildReadPlcrActionReg(profileIndx);
+        hcFrame.extraReg = 0x00008000;
+        hcFrame.commandSequence = p_FmHc->seqNum;
+
+        BUILD_FD(SIZE_OF_HC_FRAME_READ_OR_CC_DYNAMIC);
+
+        ENQUEUE_FRM_RET_NULL(&fmFd);
+
+        /* check if this scheme is already used */
+        if (FmPcdPlcrHwProfileIsValid(hcFrame.hcSpecificData.profileRegs.fmpl_pemode))
+        {
+            FmPcdPlcrReleaseProfileLock(p_FmHc->h_FmPcd, profileIndx);
+            REPORT_ERROR(MAJOR, E_ALREADY_EXISTS, ("Policer is already used"));
+            return NULL;
+        }
+    }
+
+    memset(&profileRegs, 0, sizeof(t_FmPcdPlcrInterModuleProfileRegs));
+    err = FmPcdPlcrBuildProfile(p_FmHc->h_FmPcd, p_Profile, &profileRegs);
+    if(err)
+    {
+        FmPcdPlcrReleaseProfileLock(p_FmHc->h_FmPcd, profileIndx);
+        REPORT_ERROR(MAJOR, err, NO_MSG);
+        return NULL;
+    }
+
+    memset(&hcFrame, 0, sizeof(hcFrame));
+    hcFrame.opcode = 0x00000000;
+    hcFrame.actionReg  = FmPcdPlcrBuildWritePlcrActionRegs(profileIndx);
+    hcFrame.extraReg = 0x00008000;
+    hcFrame.commandSequence = p_FmHc->seqNum;
+    memcpy(&hcFrame.hcSpecificData.profileRegs, &profileRegs, sizeof(t_FmPcdPlcrInterModuleProfileRegs));
+
+    BUILD_FD(sizeof(hcFrame));
+
+    ENQUEUE_FRM_RET_NULL(&fmFd);
+
+    FmPcdPlcrValidateProfileSw(p_FmHc->h_FmPcd, profileIndx);
+
+    FmPcdPlcrReleaseProfileLock(p_FmHc->h_FmPcd, profileIndx);
+
+    return CAST_UINT32_TO_POINTER((uint32_t)profileIndx+1);
+}
+
+t_Error FmHcPcdPlcrDeleteProfile(t_Handle h_FmHc, t_Handle h_Profile)
+{
+    t_FmHc                              *p_FmHc = (t_FmHc*)h_FmHc;
+    uint16_t                            absoluteProfileId = (uint16_t)(CAST_POINTER_TO_UINT32(h_Profile)-1);
+    t_Error                             err;
+    t_HcFrame                           hcFrame;
+    t_FmFD                              fmFd;
+
+    if (FmPcdPlcrProfileTryLock(p_FmHc->h_FmPcd, absoluteProfileId))
+        return ERROR_CODE(E_BUSY);
+
+    FmPcdPlcrInvalidateProfileSw(p_FmHc->h_FmPcd, absoluteProfileId);
+    memset(&hcFrame, 0, sizeof(hcFrame));
+    hcFrame.opcode = 0x00000000;
+    hcFrame.actionReg  = FmPcdPlcrBuildWritePlcrActionReg(absoluteProfileId);
+    hcFrame.actionReg  |= 0x00008000;
+    hcFrame.extraReg = 0x00008000;
+    hcFrame.commandSequence = p_FmHc->seqNum;
+    memset(&hcFrame.hcSpecificData.profileRegs, 0, sizeof(t_FmPcdPlcrInterModuleProfileRegs));
+
+    BUILD_FD(sizeof(hcFrame));
+
+    ENQUEUE_FRM(&fmFd);
+
+    FmPcdPlcrReleaseProfileLock(p_FmHc->h_FmPcd, absoluteProfileId);
+
+    return E_OK;
+}
+
+t_Error  FmHcPcdPlcrSetProfileCounter(t_Handle h_FmHc, t_Handle h_Profile, e_FmPcdPlcrProfileCounters counter, uint32_t value)
+{
+
+    t_FmHc                              *p_FmHc = (t_FmHc*)h_FmHc;
+    uint16_t                            absoluteProfileId = (uint16_t)(CAST_POINTER_TO_UINT32(h_Profile)-1);
+    t_Error                             err;
+    t_HcFrame                           hcFrame;
+    t_FmFD                              fmFd;
+
+    if (FmPcdPlcrProfileTryLock(p_FmHc->h_FmPcd, absoluteProfileId))
+        return ERROR_CODE(E_BUSY);
+
+    /* first read scheme and check that it is valid */
+    memset(&hcFrame, 0, sizeof(hcFrame));
+    hcFrame.opcode = 0x00000000;
+    hcFrame.actionReg  = FmPcdPlcrBuildReadPlcrActionReg(absoluteProfileId);
+    hcFrame.extraReg = 0x00008000;
+    hcFrame.commandSequence = p_FmHc->seqNum;
+
+    BUILD_FD(SIZE_OF_HC_FRAME_READ_OR_CC_DYNAMIC);
+
+    ENQUEUE_FRM(&fmFd);
+
+    /* check that profile is valid */
+    if (!FmPcdPlcrHwProfileIsValid(hcFrame.hcSpecificData.profileRegs.fmpl_pemode))
+    {
+        FmPcdPlcrReleaseProfileLock(p_FmHc->h_FmPcd, absoluteProfileId);
+        RETURN_ERROR(MAJOR, E_ALREADY_EXISTS, ("Policer is already used"));
+    }
+
+    hcFrame.opcode = 0x00000000;
+    hcFrame.actionReg  = FmPcdPlcrBuildWritePlcrActionReg(absoluteProfileId);
+    hcFrame.actionReg |= FmPcdPlcrBuildCounterProfileReg(counter);
+    hcFrame.extraReg = 0x00008000;
+    hcFrame.commandSequence = p_FmHc->seqNum;
+    hcFrame.hcSpecificData.singleRegForWrite = value;
+
+    BUILD_FD(SIZE_OF_HC_FRAME_PROFILE_CNT);
+
+    ENQUEUE_FRM(&fmFd);
+
+    FmPcdPlcrReleaseProfileLock(p_FmHc->h_FmPcd, absoluteProfileId);
+
+    return E_OK;
+}
+
+uint32_t FmHcPcdPlcrGetProfileCounter(t_Handle h_FmHc, t_Handle h_Profile, e_FmPcdPlcrProfileCounters counter)
+{
+    t_FmHc                              *p_FmHc = (t_FmHc*)h_FmHc;
+    uint16_t                            absoluteProfileId = (uint16_t)(CAST_POINTER_TO_UINT32(h_Profile)-1);
+    t_Error                             err;
+    t_HcFrame                           hcFrame;
+    t_FmFD                              fmFd;
+    uint32_t                            retVal;
+
+    SANITY_CHECK_RETURN_VALUE(h_FmHc, E_INVALID_HANDLE,0);
+
+    if (FmPcdPlcrProfileTryLock(p_FmHc->h_FmPcd, absoluteProfileId))
+        return 0;
+
+    /* first read scheme and check that it is valid */
+    memset(&hcFrame, 0, sizeof(hcFrame));
+    hcFrame.opcode = 0x00000000;
+    hcFrame.actionReg  = FmPcdPlcrBuildReadPlcrActionReg(absoluteProfileId);
+    hcFrame.extraReg = 0x00008000;
+    hcFrame.commandSequence = p_FmHc->seqNum;
+
+    BUILD_FD(SIZE_OF_HC_FRAME_READ_OR_CC_DYNAMIC);
+
+    ENQUEUE_FRM(&fmFd);
+
+    /* check that profile is valid */
+    if (!FmPcdPlcrHwProfileIsValid(hcFrame.hcSpecificData.profileRegs.fmpl_pemode))
+    {
+        FmPcdPlcrReleaseProfileLock(p_FmHc->h_FmPcd, absoluteProfileId);
+        RETURN_ERROR(MAJOR, E_ALREADY_EXISTS, ("Policer is already used"));
+    }
+
+    switch (counter)
+    {
+        case e_FM_PCD_PLCR_PROFILE_GREEN_PACKET_TOTAL_COUNTER:
+            retVal = hcFrame.hcSpecificData.profileRegs.fmpl_pegpc;
+            break;
+        case e_FM_PCD_PLCR_PROFILE_YELLOW_PACKET_TOTAL_COUNTER:
+            retVal = hcFrame.hcSpecificData.profileRegs.fmpl_peypc;
+            break;
+        case e_FM_PCD_PLCR_PROFILE_RED_PACKET_TOTAL_COUNTER:
+            retVal = hcFrame.hcSpecificData.profileRegs.fmpl_perpc;
+            break;
+        case e_FM_PCD_PLCR_PROFILE_RECOLOURED_YELLOW_PACKET_TOTAL_COUNTER:
+            retVal = hcFrame.hcSpecificData.profileRegs.fmpl_perypc;
+            break;
+        case e_FM_PCD_PLCR_PROFILE_RECOLOURED_RED_PACKET_TOTAL_COUNTER:
+            retVal = hcFrame.hcSpecificData.profileRegs.fmpl_perrpc;
+            break;
+        default:
+            REPORT_ERROR(MAJOR, E_INVALID_SELECTION, NO_MSG);
+            retVal = 0;
+    }
+
+    FmPcdPlcrReleaseProfileLock(p_FmHc->h_FmPcd, absoluteProfileId);
+
+    return retVal;
+}
+
+t_Error FmHcPcdCcModifyTreeNextEngine(t_Handle h_FmHc, t_Handle h_CcTree, uint8_t grpId, uint8_t index, t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams)
+{
+    t_FmHc      *p_FmHc = (t_FmHc*)h_FmHc;
+    t_Error     err = E_OK;
+    t_Handle    h_OldPointer, h_NewPointer;
+
+    if ((err = FmPcdCcTreeTryLock(h_CcTree)) != E_OK)
+        return err;
+
+    err = FmPcdCcModifyNextEngineParamTree(p_FmHc->h_FmPcd, h_CcTree, grpId, index, p_FmPcdCcNextEngineParams,
+            &h_OldPointer, &h_NewPointer);
+    if(err)
+    {
+        FmPcdCcTreeReleaseLock(h_CcTree);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
+
+    err = CcHcDynamicChangeForNextEngine(p_FmHc, h_OldPointer, h_NewPointer);
+    FmPcdCcTreeReleaseLock(h_CcTree);
+    return err;
+}
+
+t_Error FmHcPcdCcModifyNodeNextEngine(t_Handle h_FmHc, t_Handle h_CcNode, uint8_t keyIndex, t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams)
+{
+    t_FmHc      *p_FmHc = (t_FmHc*)h_FmHc;
+    t_Error     err = E_OK;
+    t_Handle    h_OldPointer, h_NewPointer;
+    t_List      h_List;
+
+    INIT_LIST(&h_List);
+
+    if (FmPcdTryLock(p_FmHc->h_FmPcd) != E_OK)
+        return err;
+
+    if ((err = FmPcdCcNodeTreeTryLock(p_FmHc->h_FmPcd, h_CcNode, &h_List)) != E_OK)
+    {
+        FmPcdReleaseLock(p_FmHc->h_FmPcd);
+        return err;
+    }
+
+    FmPcdReleaseLock(p_FmHc->h_FmPcd);
+    err = FmPcdCcModiyNextEngineParamNode(p_FmHc->h_FmPcd, h_CcNode, keyIndex, p_FmPcdCcNextEngineParams, &h_OldPointer, &h_NewPointer);
+    if(err)
+    {
+        FmPcdCcNodeTreeReleaseLock(p_FmHc->h_FmPcd, &h_List);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
+
+    err =   CcHcDynamicChangeForNextEngine(p_FmHc, h_OldPointer, h_NewPointer);
+    FmPcdCcNodeTreeReleaseLock(p_FmHc->h_FmPcd, &h_List);
+    return err;
+}
+
+t_Error FmHcPcdCcModifyNodeMissNextEngine(t_Handle h_FmHc, t_Handle h_CcNode, t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams)
+{
+    t_FmHc      *p_FmHc = (t_FmHc*)h_FmHc;
+    t_Error     err = E_OK;
+    t_Handle    h_OldPointer, h_NewPointer;
+    t_List      h_List      ;
+
+    INIT_LIST(&h_List);
+
+    if (FmPcdTryLock(p_FmHc->h_FmPcd) != E_OK)
+        return err;
+
+    if ((err = FmPcdCcNodeTreeTryLock(p_FmHc->h_FmPcd, h_CcNode, &h_List)) != E_OK)
+    {
+        FmPcdReleaseLock(p_FmHc->h_FmPcd);
+        return err;
+    }
+
+    FmPcdReleaseLock(p_FmHc->h_FmPcd);
+
+    err = FmPcdCcModifyMissNextEngineParamNode(p_FmHc->h_FmPcd, h_CcNode, p_FmPcdCcNextEngineParams, &h_OldPointer, &h_NewPointer);
+    if(err)
+    {
+        FmPcdCcNodeTreeReleaseLock(p_FmHc->h_FmPcd, &h_List);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
+
+    err =   CcHcDynamicChangeForNextEngine(p_FmHc, h_OldPointer, h_NewPointer);
+
+    FmPcdCcNodeTreeReleaseLock(p_FmHc->h_FmPcd, &h_List);
+
+    return E_OK;
+}
+
+t_Error FmHcPcdCcRemoveKey(t_Handle h_FmHc, t_Handle h_CcNode, uint8_t keyIndex)
+{
+    t_FmHc      *p_FmHc = (t_FmHc*)h_FmHc;
+    t_Handle    h_NewPointer;
+    t_List      h_OldPointersLst;
+    t_Error     err;
+    t_List      h_List      ;
+
+    INIT_LIST(&h_List);
+
+    if ((err = FmPcdTryLock(p_FmHc->h_FmPcd)) != E_OK)
+        return err;
+
+    if ((err = FmPcdCcNodeTreeTryLock(p_FmHc->h_FmPcd, h_CcNode, &h_List)) != E_OK)
+    {
+        FmPcdReleaseLock(p_FmHc->h_FmPcd);
+        return err;
+    }
+
+    FmPcdReleaseLock(p_FmHc->h_FmPcd);
+
+    INIT_LIST(&h_OldPointersLst);
+
+    err = FmPcdCcRemoveKey(p_FmHc->h_FmPcd,h_CcNode,keyIndex, &h_OldPointersLst,&h_NewPointer);
+    if(err)
+    {
+        FmPcdCcNodeTreeReleaseLock(p_FmHc->h_FmPcd, &h_List);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
+
+    err =  HcDynamicChangeForKey(p_FmHc, (t_Handle)&h_OldPointersLst, h_NewPointer);
+
+    FmPcdCcNodeTreeReleaseLock(p_FmHc->h_FmPcd, &h_List);
+
+    return E_OK;
+}
+
+t_Error FmHcPcdCcAddKey(t_Handle h_FmHc, t_Handle h_CcNode, uint8_t keyIndex, uint8_t keySize, t_FmPcdCcKeyParams  *p_KeyParams)
+{
+    t_FmHc      *p_FmHc = (t_FmHc*)h_FmHc;
+    t_Handle    h_NewPointer;
+    t_List      h_OldPointersLst;
+    t_Error     err;
+    t_List      h_List;
+
+    UNUSED(keySize);
+
+    INIT_LIST(&h_List);
+
+    if ((err = FmPcdTryLock(p_FmHc->h_FmPcd)) != E_OK)
+        return err;
+
+    if ((err = FmPcdCcNodeTreeTryLock(p_FmHc->h_FmPcd, h_CcNode, &h_List)) != E_OK)
+    {
+        FmPcdReleaseLock(p_FmHc->h_FmPcd);
+        return err;
+    }
+
+    FmPcdReleaseLock(p_FmHc->h_FmPcd);
+
+    INIT_LIST(&h_OldPointersLst);
+
+
+    err = FmPcdCcAddKey(p_FmHc->h_FmPcd,h_CcNode,keyIndex,p_KeyParams, &h_OldPointersLst,&h_NewPointer);
+    if(err)
+    {
+        FmPcdCcNodeTreeReleaseLock(p_FmHc->h_FmPcd, &h_List);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
+
+    err =  HcDynamicChangeForKey(p_FmHc, (t_Handle)&h_OldPointersLst, h_NewPointer);
+
+    FmPcdCcNodeTreeReleaseLock(p_FmHc->h_FmPcd, &h_List);
+
+    return err;
+}
+
+t_Error FmHcPcdCcModifyKeyAndNextEngine(t_Handle h_FmHc, t_Handle h_CcNode, uint8_t keyIndex, uint8_t keySize, t_FmPcdCcKeyParams  *p_KeyParams)
+{
+    t_FmHc      *p_FmHc = (t_FmHc*)h_FmHc;
+    t_List      h_OldPointersLst;
+    t_Handle    h_NewPointer;
+    t_Error     err;
+    t_List      h_List;
+
+    UNUSED(keySize);
+
+    INIT_LIST(&h_List);
+
+    if ((err = FmPcdTryLock(p_FmHc->h_FmPcd)) != E_OK)
+        return err;
+
+    if ((err = FmPcdCcNodeTreeTryLock(p_FmHc->h_FmPcd, h_CcNode, &h_List)) != E_OK)
+    {
+        FmPcdReleaseLock(p_FmHc->h_FmPcd);
+        return err;
+    }
+
+    FmPcdReleaseLock(p_FmHc->h_FmPcd);
+
+    INIT_LIST(&h_OldPointersLst);
+
+    err = FmPcdCcModifyKeyAndNextEngine(p_FmHc->h_FmPcd,h_CcNode,keyIndex,p_KeyParams, &h_OldPointersLst,&h_NewPointer);
+    if(err)
+    {
+        FmPcdCcNodeTreeReleaseLock(p_FmHc->h_FmPcd, &h_List);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
+
+    err =  HcDynamicChangeForKey(p_FmHc, (t_Handle)&h_OldPointersLst, h_NewPointer);
+
+    FmPcdCcNodeTreeReleaseLock(p_FmHc->h_FmPcd, &h_List);
+
+    return err;
+}
+
+t_Error FmHcPcdCcModifyKey(t_Handle h_FmHc, t_Handle h_CcNode, uint8_t keyIndex, uint8_t keySize, uint8_t  *p_Key, uint8_t *p_Mask)
+{
+    t_FmHc      *p_FmHc = (t_FmHc*)h_FmHc;
+    t_List      h_OldPointersLst;
+    t_Handle    h_NewPointer;
+    t_Error     err;
+    t_List      h_List;
+    UNUSED(keySize);
+
+    INIT_LIST(&h_List);
+
+    if ((err = FmPcdTryLock(p_FmHc->h_FmPcd)) != E_OK)
+        return err;
+
+    if ((err = FmPcdCcNodeTreeTryLock(p_FmHc->h_FmPcd, h_CcNode, &h_List)) != E_OK)
+    {
+        FmPcdReleaseLock(p_FmHc->h_FmPcd);
+        return err;
+    }
+
+    FmPcdReleaseLock(p_FmHc->h_FmPcd);
+
+    INIT_LIST(&h_OldPointersLst);
+
+    err = FmPcdCcModifyKey(p_FmHc->h_FmPcd, h_CcNode, keyIndex, p_Key, p_Mask, &h_OldPointersLst,&h_NewPointer);
+    if(err)
+    {
+        FmPcdCcNodeTreeReleaseLock(p_FmHc->h_FmPcd, &h_List);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
+
+    err =  HcDynamicChangeForKey(p_FmHc, (t_Handle)&h_OldPointersLst, h_NewPointer);
+    FmPcdCcNodeTreeReleaseLock(p_FmHc->h_FmPcd, &h_List);
+
+    return err;
+}
+
+t_Error FmHcKgWriteSp(t_Handle h_FmHc, uint8_t hardwarePortId, uint32_t spReg, bool add)
+{
+    t_FmHc                  *p_FmHc = (t_FmHc*)h_FmHc;
+    t_HcFrame               hcFrame;
+    t_FmFD                  fmFd;
+    t_Error                 err;
+
+    ASSERT_COND(p_FmHc);
+
+    memset(&hcFrame, 0, sizeof(hcFrame));
+    /* first read SP register */
+    hcFrame.opcode = 0x00000001;
+    hcFrame.actionReg  = FmPcdKgBuildReadPortSchemeBindActionReg(hardwarePortId);
+    hcFrame.extraReg = 0xFFFFF800;
+    hcFrame.commandSequence = p_FmHc->seqNum;
+
+    BUILD_FD(SIZE_OF_HC_FRAME_PORT_REGS);
+
+    ENQUEUE_FRM(&fmFd);
+
+    /* spReg is the first reg, so we can use it bothe for read and for write */
+    if(add)
+        hcFrame.hcSpecificData.portRegsForRead.spReg |= spReg;
+    else
+        hcFrame.hcSpecificData.portRegsForRead.spReg &= ~spReg;
+
+    hcFrame.actionReg  = FmPcdKgBuildWritePortSchemeBindActionReg(hardwarePortId);
+    hcFrame.commandSequence = p_FmHc->seqNum;
+
+    BUILD_FD(sizeof(hcFrame));
+
+    ENQUEUE_FRM(&fmFd);
+
+    return E_OK;
+}
+
+t_Error FmHcKgWriteCpp(t_Handle h_FmHc, uint8_t hardwarePortId, uint32_t cppReg)
+{
+    t_FmHc                  *p_FmHc = (t_FmHc*)h_FmHc;
+    t_HcFrame               hcFrame;
+    t_FmFD                  fmFd;
+    t_Error                 err;
+
+    ASSERT_COND(p_FmHc);
+
+    memset(&hcFrame, 0, sizeof(hcFrame));
+    /* first read SP register */
+    hcFrame.opcode = 0x00000001;
+    hcFrame.actionReg  = FmPcdKgBuildWritePortClsPlanBindActionReg(hardwarePortId);
+    hcFrame.extraReg = 0xFFFFF800;
+    hcFrame.commandSequence = p_FmHc->seqNum;
+    hcFrame.hcSpecificData.singleRegForWrite = cppReg;
+
+    BUILD_FD(sizeof(hcFrame));
+
+    ENQUEUE_FRM(&fmFd);
+
+    return E_OK;
+}
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/Makefile b/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/Makefile
new file mode 100644
index 0000000..7c63f97
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/Makefile
@@ -0,0 +1,18 @@
+#
+# Makefile for the Freescale Ethernet controllers
+#
+EXTRA_CFLAGS           += -DVERSION=\"\"
+#
+#Include netcomm SW specific definitions
+include $(srctree)/drivers/net/dpa/NetCommSw/ncsw_config.mk
+NCSW_FM_INC = $(srctree)/drivers/net/dpa/NetCommSw/Peripherals/FM/inc
+
+EXTRA_CFLAGS += -I$(NCSW_FM_INC)
+
+obj-y		+= fsl-ncsw-MAC.o
+
+fsl-ncsw-MAC-objs	:=   dtsec.o dtsec_mii_acc.o fm_mac.o tgec.o tgec_mii_acc.o
+
+
+
+
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.c b/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.c
new file mode 100644
index 0000000..641814a
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.c
@@ -0,0 +1,1358 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/******************************************************************************
+ @File          dtsec.c
+
+ @Description   FM dTSEC ...
+*//***************************************************************************/
+
+#include "std_ext.h"
+#include "error_ext.h"
+#include "string_ext.h"
+#include "xx_ext.h"
+#include "endian_ext.h"
+#include "crc_mac_addr_ext.h"
+#include "debug_ext.h"
+
+#include "dtsec.h"
+
+
+/*****************************************************************************/
+/*                      Internal routines                                    */
+/*****************************************************************************/
+
+static t_Error CheckInitParameters(t_Dtsec *p_Dtsec)
+{
+    if(ENET_SPEED_FROM_MODE(p_Dtsec->enetMode) >= e_ENET_SPEED_10000)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Ethernet 10G MAC driver only support 10G speed"));
+    if(p_Dtsec->macId >= FM_MAX_NUM_OF_1G_MACS)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("macId of 10 G can not be greater than 0"));
+    if(p_Dtsec->addr == 0)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Ethernet 10G MAC Must have a valid MAC Address"));
+    if(((p_Dtsec->enetMode == e_ENET_MODE_SGMII_1000) ||
+        (p_Dtsec->enetMode == e_ENET_MODE_RGMII_1000)) &&
+        p_Dtsec->p_DtsecDriverParam->halfDuplex)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Ethernet MAC 1G can't work in halfDuplex"));
+    if(p_Dtsec->p_DtsecDriverParam->halfDuplex && (p_Dtsec->p_DtsecDriverParam)->loopback)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("LoopBack is not supported in halfDuplex mode"));
+    if(((p_Dtsec->p_DtsecDriverParam)->preambleTxEn ||(p_Dtsec->p_DtsecDriverParam)->preambleRxEn)  &&( (p_Dtsec->p_DtsecDriverParam)->preambleLength != 0x7))
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("if user defined preamble is transmitted - preamble length should be 0x7"));
+    if((p_Dtsec->p_DtsecDriverParam)->fifoTxWatermarkH<((p_Dtsec->p_DtsecDriverParam)->fifoTxThr+8))
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fifoTxWatermarkH has to be at least 8 larger than fifoTxThr"));
+    if((p_Dtsec->p_DtsecDriverParam)->halfDuplex &&
+       (p_Dtsec->p_DtsecDriverParam->txTimeStampEn || p_Dtsec->p_DtsecDriverParam->rxTimeStampEn))
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dTSEC in half dupplex mode has to be with 1588 timeStamping diable"));
+    if((p_Dtsec->p_DtsecDriverParam)->actOnRxPauseFrame && (p_Dtsec->p_DtsecDriverParam)->controlFrameAccept )
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("receive control frame are not passed to the system memory so it can not be accept "));
+    if((p_Dtsec->p_DtsecDriverParam)->packetAlignmentPadding  > MAX_PACKET_ALIGNMENT)
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("packetAlignmentPadding can't be greater than %d ",MAX_PACKET_ALIGNMENT ));
+    if(((p_Dtsec->p_DtsecDriverParam)->nonBackToBackIpg1  > MAX_INTER_PACKET_GAP) ||
+        ((p_Dtsec->p_DtsecDriverParam)->nonBackToBackIpg2 > MAX_INTER_PACKET_GAP) ||
+        ((p_Dtsec->p_DtsecDriverParam)->backToBackIpg > MAX_INTER_PACKET_GAP))
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("inter packet gap can't be greater than %d ",MAX_INTER_PACKET_GAP ));
+    if((p_Dtsec->p_DtsecDriverParam)->alternateBackoffVal > MAX_INTER_PALTERNATE_BEB)
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("alternateBackoffVal can't be greater than %d ",MAX_INTER_PALTERNATE_BEB ));
+    if((p_Dtsec->p_DtsecDriverParam)->maxRetransmission > MAX_RETRANSMISSION)
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("maxRetransmission can't be greater than %d ",MAX_RETRANSMISSION ));
+    if((p_Dtsec->p_DtsecDriverParam)->collisionWindow > MAX_COLLISION_WINDOW)
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("collisionWindow can't be greater than %d ",MAX_COLLISION_WINDOW ));
+
+    return E_OK;
+}
+
+/* ........................................................................... */
+
+static void SetDefaultParam(t_Dtsec *p_Dtsec, t_DtsecDriverParam *p_DtsecDriverParam)
+{
+    UNUSED(p_Dtsec);
+
+    p_DtsecDriverParam->errorDisabled       = DEFAULT_errorDisabled;
+
+    p_DtsecDriverParam->autoZeroCounters    = DEFAULT_autoZeroCounters;
+    p_DtsecDriverParam->statisticsEnable    = DEFAULT_statisticsEnable;
+    p_DtsecDriverParam->promiscuousEnable   = DEFAULT_promiscuousEnable;
+
+    p_DtsecDriverParam->pauseExtended       = DEFAULT_pauseExtended;
+    p_DtsecDriverParam->pauseTime           = DEFAULT_pauseTime;
+
+    p_DtsecDriverParam->halfDuplex          = DEFAULT_halfDuplex;
+    p_DtsecDriverParam->halfDulexFlowControlEn  = DEFAULT_halfDulexFlowControlEn;
+    p_DtsecDriverParam->txTimeStampEn       = DEFAULT_txTimeStampEn;
+    p_DtsecDriverParam->rxTimeStampEn       = DEFAULT_rxTimeStampEn;
+
+    p_DtsecDriverParam->packetAlignmentPadding = DEFAULT_packetAlignment;
+    p_DtsecDriverParam->controlFrameAccept   = DEFAULT_controlFrameAccept;
+    p_DtsecDriverParam->groupHashExtend      = DEFAULT_groupHashExtend;
+    p_DtsecDriverParam->broadcReject         = DEFAULT_broadcReject;
+    p_DtsecDriverParam->rxShortFrame         = DEFAULT_rxShortFrame;
+    p_DtsecDriverParam->exactMatch           = DEFAULT_exactMatch;
+    p_DtsecDriverParam->debugMode            = DEFAULT_debugMode;
+
+    p_DtsecDriverParam->loopback             = DEFAULT_loopback;
+    p_DtsecDriverParam->actOnRxPauseFrame    = DEFAULT_actOnRxPauseFrame;
+    p_DtsecDriverParam->actOnTxPauseFrame    = DEFAULT_actOnTxPauseFrame;
+
+    p_DtsecDriverParam->preambleLength       = DEFAULT_PreAmLength;
+    p_DtsecDriverParam->preambleRxEn         = DEFAULT_PreAmRxEn;
+    p_DtsecDriverParam->preambleTxEn         = DEFAULT_PreAmTxEn;
+    p_DtsecDriverParam->hugeFramesEnable     = DEFAULT_hugeFrames;
+    p_DtsecDriverParam->lengthCheckEnable    = DEFAULT_lengthCheckEnable;
+    p_DtsecDriverParam->padAndCrcEnable      = DEFAULT_padAndCrcEnable;
+    p_DtsecDriverParam->crcEnable            = DEFAULT_crcEnable;
+
+    p_DtsecDriverParam->nonBackToBackIpg1    = DEFAULT_nonBackToBackIpg1;
+    p_DtsecDriverParam->nonBackToBackIpg2    = DEFAULT_nonBackToBackIpg2;
+    p_DtsecDriverParam->minIfgEnforcement    = DEFAULT_minIfgEnforcement;
+    p_DtsecDriverParam->backToBackIpg        = DEFAULT_backToBackIpg;
+
+    p_DtsecDriverParam->alternateBackoffVal    = DEFAULT_altBackoffVal;
+    p_DtsecDriverParam->alternateBackoffEnable = DEFAULT_altBackoffEnable;
+    p_DtsecDriverParam->backPressureNoBackoff = DEFAULT_backPressureNoBackoff;
+    p_DtsecDriverParam->noBackoff             = DEFAULT_noBackoff;
+    p_DtsecDriverParam->excessDefer           = DEFAULT_excessDefer;
+    p_DtsecDriverParam->maxRetransmission     = DEFAULT_maxRetransmission;
+    p_DtsecDriverParam->collisionWindow       = DEFAULT_collisionWindow;
+
+    p_DtsecDriverParam->maxFrameLength        = DEFAULT_maxFrameLength;
+
+    p_DtsecDriverParam->cam1                  = DEFAULT_cam;
+    p_DtsecDriverParam->cam2                  = DEFAULT_cam;
+
+    p_DtsecDriverParam->fifoTxThr          = DEFAULT_fifoTxThr;
+    p_DtsecDriverParam->fifoTxWatermarkH   = DEFAULT_fifoTxWatermarkH;
+
+    p_DtsecDriverParam->fifoRxWatermarkL   = DEFAULT_fifoRxWatermarkL;
+
+//#warning /*TODO - Handle Interrupt Mask */ /*    p_DtsecDriverParam->imask              = DEFAULT_imask;    */
+}
+
+/* ........................................................................... */
+
+static void FreeInitResources(t_Dtsec *p_Dtsec)
+{
+    /* release the driver's group hash table */
+    FreeHashTable(p_Dtsec->p_MulticastAddrHash);
+    p_Dtsec->p_MulticastAddrHash =   NULL;
+
+    /* release the driver's individual hash table */
+    FreeHashTable(p_Dtsec->p_UnicastAddrHash);
+    p_Dtsec->p_UnicastAddrHash =     NULL;
+}
+
+/* ........................................................................... */
+
+static void HardwareClearAddrInPaddr(t_Dtsec *p_Dtsec, uint8_t paddrNum)
+{
+    WRITE_UINT32(((t_DtsecMemMap*)p_Dtsec->p_MemMap)->macaddr[paddrNum].exact_match1, 0x0);
+    WRITE_UINT32(((t_DtsecMemMap*)p_Dtsec->p_MemMap)->macaddr[paddrNum].exact_match2, 0x0);
+}
+
+/* ........................................................................... */
+
+static void HardwareAddAddrInPaddr(t_Dtsec *p_Dtsec, uint64_t *p_Addr, uint8_t paddrNum)
+{
+    uint32_t tmpReg32 = 0;
+    uint64_t addr = *p_Addr;
+    t_DtsecMemMap  *p_DtsecMemMap = (t_DtsecMemMap*)p_Dtsec->p_MemMap;
+
+    tmpReg32 = (uint32_t)(addr);
+    SwapUint32P(&tmpReg32);
+    WRITE_UINT32(p_DtsecMemMap->macaddr[paddrNum].exact_match1, tmpReg32);
+
+    tmpReg32 = (uint32_t)(addr>>32);
+    SwapUint32P(&tmpReg32);
+    WRITE_UINT32(p_DtsecMemMap->macaddr[paddrNum].exact_match2, tmpReg32);
+}
+
+/* ........................................................................... */
+
+static void rxGracefulStop(t_Dtsec *p_Dtsec)
+{
+    t_DtsecMemMap *p_MemMap = (t_DtsecMemMap*)(p_Dtsec->p_MemMap);
+    WRITE_UINT32(p_MemMap->rctrl,
+                  GET_UINT32(p_MemMap->rctrl) | RCTRL_GRS);
+}
+
+/* ........................................................................... */
+
+static void txGracefulStop(t_Dtsec *p_Dtsec)
+{
+    t_DtsecMemMap *p_MemMap = (t_DtsecMemMap*)(p_Dtsec->p_MemMap);
+
+    SANITY_CHECK_RETURN(p_Dtsec, E_INVALID_HANDLE);
+
+    /* Assert the graceful transmit stop bit */
+    WRITE_UINT32(p_MemMap->tctrl,
+                  GET_UINT32(p_MemMap->tctrl) | TCTRL_GTS);
+}
+
+/*****************************************************************************/
+/*                      FM Init & Free API                                   */
+/*****************************************************************************/
+
+/* ........................................................................... */
+
+static t_Error DtsecInit(t_Handle h_Dtsec)
+{
+    t_Dtsec             *p_Dtsec = (t_Dtsec *)h_Dtsec;
+    t_DtsecDriverParam  *p_DtsecDriverParam;
+    t_DtsecMemMap       *p_DtsecMemMap;
+    bool                isRgmii = FALSE, isResetCnfgRgmiiMode = FALSE;
+    bool                isSgmii = FALSE, isResetCnfgSgmiiMode = FALSE;
+    bool                isReducedPin = FALSE,  isResetCnfgReducedPin = FALSE;
+    bool                is100 = FALSE,  isResetCnfg100 = FALSE;
+    int                 i;
+    uint32_t            tmpReg32;
+    uint64_t            addr;
+
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec->p_DtsecDriverParam, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec->p_MemMap, E_INVALID_STATE);
+
+    CHECK_INIT_PARAMETERS(p_Dtsec, CheckInitParameters);
+
+    p_DtsecDriverParam  = p_Dtsec->p_DtsecDriverParam;
+    p_Dtsec->halfDuplex = p_DtsecDriverParam->halfDuplex;
+    p_Dtsec->debugMode  = p_DtsecDriverParam->debugMode;
+    p_DtsecMemMap       = p_Dtsec->p_MemMap;
+
+/*************dtsec_id2******************/
+   tmpReg32 =  GET_UINT32(p_DtsecMemMap->tsec_id2);
+
+   if ((p_Dtsec->enetMode == e_ENET_MODE_RGMII_10) ||
+       (p_Dtsec->enetMode == e_ENET_MODE_RGMII_100) ||
+       (p_Dtsec->enetMode == e_ENET_MODE_RGMII_1000))
+       if(tmpReg32 & ID2_INT_REDUCED_OFF)
+       {
+            RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("no support for reduced interface in current DTSEC version"));
+       }
+
+   if ((p_Dtsec->enetMode == e_ENET_MODE_SGMII_10) ||
+       (p_Dtsec->enetMode == e_ENET_MODE_SGMII_100) ||
+       (p_Dtsec->enetMode == e_ENET_MODE_SGMII_1000))
+       if(tmpReg32 & ID2_INT_NORMAL_OFF)
+       {
+            RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("no support for normal interface in current DTSEC version"));
+       }
+/*************dtsec_id2******************/
+
+/***************EDIS************************/
+    WRITE_UINT32(p_DtsecMemMap->edis, p_DtsecDriverParam->errorDisabled);
+/***************EDIS************************/
+
+/***************ECNTRL************************/
+    tmpReg32 = GET_UINT32(p_DtsecMemMap->ecntrl);
+
+    if(tmpReg32 & ECNTRL_CFG_RO)
+    {
+        isRgmii = (( p_Dtsec->enetMode == e_ENET_MODE_RGMII_10)   ||
+                            (p_Dtsec->enetMode == e_ENET_MODE_RGMII_100)  ||
+                            (p_Dtsec->enetMode == e_ENET_MODE_RGMII_1000) ||(p_Dtsec->enetMode == e_ENET_MODE_GMII_1000)) ? TRUE : FALSE;
+        isResetCnfgRgmiiMode= (tmpReg32 & ECNTRL_GMIIM) ? TRUE : FALSE;
+        if((isRgmii && !isResetCnfgRgmiiMode) ||
+            (!isRgmii && isResetCnfgRgmiiMode))
+          RETURN_ERROR(MAJOR, E_CONFLICT,(" Error. Reduced mode not configured properly. Check eTsec cfg switch \n"));
+
+        isSgmii = (( p_Dtsec->enetMode == e_ENET_MODE_SGMII_10)   ||
+                            (p_Dtsec->enetMode == e_ENET_MODE_SGMII_100)  ||
+                            (p_Dtsec->enetMode == e_ENET_MODE_SGMII_1000)) ? TRUE : FALSE;
+        isResetCnfgSgmiiMode = (tmpReg32 & ECNTRL_SGMIIM) ? TRUE : FALSE;
+        if((isSgmii && !isResetCnfgSgmiiMode) ||
+            (!isSgmii && isResetCnfgSgmiiMode))
+          RETURN_ERROR(MAJOR, E_CONFLICT,(" Error. SGMII mode not configured properly. Check dTsec cfg switch \n"));
+
+        isReducedPin = ((p_Dtsec->enetMode == e_ENET_MODE_RGMII_1000) || (p_Dtsec->enetMode == e_ENET_MODE_RGMII_100) ||
+                            (p_Dtsec->enetMode == e_ENET_MODE_RGMII_10)) ? TRUE : FALSE;
+        isResetCnfgReducedPin= (tmpReg32 & ECNTRL_RPM) ? TRUE : FALSE;
+        if((isReducedPin && !isResetCnfgReducedPin) || (!isReducedPin && isResetCnfgReducedPin))
+          RETURN_ERROR(MAJOR, E_CONFLICT,(" Error. reduced pin interface is not configured properly. Check dTsec cfg switch \n"));
+
+        is100 = (( p_Dtsec->enetMode == e_ENET_MODE_SGMII_100)   ||
+                            (p_Dtsec->enetMode == e_ENET_MODE_RGMII_100)) ? TRUE : FALSE;
+        isResetCnfg100 = (tmpReg32 & ECNTRL_R100M) ? TRUE : FALSE;
+        if((is100 && !isResetCnfg100) ||
+            (!is100 && isResetCnfg100))
+          RETURN_ERROR(MAJOR, E_CONFLICT,(" Error. 100 speed interface is not configured properly. Check dTsec cfg switch \n"));
+
+    }
+    else
+    {
+      tmpReg32 = 0;
+      if((p_Dtsec->enetMode == e_ENET_MODE_RGMII_10)                     ||
+                           (p_Dtsec->enetMode == e_ENET_MODE_RGMII_100)  ||
+                            (p_Dtsec->enetMode == e_ENET_MODE_RGMII_1000)  || (p_Dtsec->enetMode == e_ENET_MODE_GMII_1000))
+            tmpReg32 |= ECNTRL_GMIIM;
+      if((p_Dtsec->enetMode == e_ENET_MODE_SGMII_10)   ||
+          (p_Dtsec->enetMode == e_ENET_MODE_SGMII_100)  ||
+          (p_Dtsec->enetMode == e_ENET_MODE_SGMII_1000))
+            tmpReg32 |= (ECNTRL_SGMIIM | ECNTRL_TBIM);
+       if((p_Dtsec->enetMode == e_ENET_MODE_RGMII_1000) || (p_Dtsec->enetMode == e_ENET_MODE_RGMII_10)||
+                (p_Dtsec->enetMode == e_ENET_MODE_RGMII_100))
+            tmpReg32 |= ECNTRL_RPM;
+       if((p_Dtsec->enetMode == e_ENET_MODE_RGMII_100) || (p_Dtsec->enetMode == e_ENET_MODE_SGMII_100))
+            tmpReg32 |= ECNTRL_R100M;
+    }
+
+    if (p_DtsecDriverParam->autoZeroCounters)
+        tmpReg32 |= ECNTRL_AUTOZ;
+    if(p_DtsecDriverParam->statisticsEnable)
+        tmpReg32 |= ECNTRL_STEN ;
+
+    WRITE_UINT32(p_DtsecMemMap->ecntrl, tmpReg32);
+
+/***************ECNTRL************************/
+/***************PTV************************/
+    /* initialize PTV */
+    tmpReg32 = 0;
+
+    if (p_DtsecDriverParam->pauseTime)
+        tmpReg32 |= (uint32_t)p_DtsecDriverParam->pauseTime;
+
+    if (p_DtsecDriverParam->pauseExtended)
+        tmpReg32 |= ((uint32_t)p_DtsecDriverParam->pauseExtended) << PTV_PTE_OFST;
+
+    WRITE_UINT32(p_DtsecMemMap->ptv, tmpReg32);
+
+/***************PTV************************/
+
+/***************TCTRL************************/
+    tmpReg32 = 0;
+    if(p_DtsecDriverParam->halfDuplex)
+    {
+        if(p_DtsecDriverParam->halfDulexFlowControlEn)
+            tmpReg32 |= TCTRL_THDF;
+    }
+    else
+    {
+        if(p_DtsecDriverParam->txTimeStampEn)
+            tmpReg32 |= TCTRL_TTSE;
+    }
+    WRITE_UINT32(p_DtsecMemMap->tctrl, tmpReg32);
+/***************TCTRL************************/
+/***************RCTRL************************/
+    tmpReg32 = 0;
+    if (p_DtsecDriverParam->packetAlignmentPadding)
+        tmpReg32 |= ((uint32_t)(0x0000001f & p_DtsecDriverParam->packetAlignmentPadding)) << 16;
+    if (p_DtsecDriverParam->controlFrameAccept)
+        tmpReg32 |= RCTRL_CFA;
+    if (p_DtsecDriverParam->groupHashExtend)
+        tmpReg32 |= RCTRL_GHTX;
+    if(p_DtsecDriverParam->rxTimeStampEn)
+        tmpReg32 |= RCTRL_RTSE;
+    if (p_DtsecDriverParam->broadcReject)
+        tmpReg32 |= RCTRL_BC_REJ;
+    if (p_DtsecDriverParam->rxShortFrame)
+        tmpReg32 |= RCTRL_RSF;
+    if (p_DtsecDriverParam->promiscuousEnable)
+        tmpReg32 |= RCTRL_PROM;
+    if (p_DtsecDriverParam->exactMatch)
+        tmpReg32 |= RCTRL_EMEN;
+
+    WRITE_UINT32(p_DtsecMemMap->rctrl, tmpReg32);
+
+/***************RCTRL************************/
+/***************IMASK************************/
+    WRITE_UINT32(p_DtsecMemMap->imask, p_DtsecDriverParam->imask);
+/***************IMASK************************/
+/***************IEVENT************************/
+    WRITE_UINT32(p_DtsecMemMap->ievent, 0xc7c7cfc3);
+/***************IEVENT************************/
+/***************DEBUG************************/
+    tmpReg32 = 0;
+    if(p_DtsecDriverParam->debugMode)
+        WRITE_UINT32(p_DtsecMemMap->tsec_id1, TSEC_ID1_DEBUG);
+/***************DEBUG************************/
+/***************MACCFG1***********************/
+
+    WRITE_UINT32(p_DtsecMemMap->maccfg1, MACCFG1_SOFT_RESET);
+    WRITE_UINT32(p_DtsecMemMap->maccfg1, 0);
+    tmpReg32 = 0;
+    if(p_DtsecDriverParam->loopback)
+        tmpReg32 |= MACCFG1_LOOPBACK;
+    if(p_DtsecDriverParam->actOnRxPauseFrame)
+        tmpReg32 |= MACCFG1_RX_FLOW;
+    if(p_DtsecDriverParam->actOnTxPauseFrame)
+        tmpReg32 |= MACCFG1_TX_FLOW;
+    WRITE_UINT32(p_DtsecMemMap->maccfg1, tmpReg32);
+
+/***************MACCFG1***********************/
+/***************MACCFG2***********************/
+    tmpReg32 = 0;
+
+    if((p_Dtsec->enetMode == e_ENET_MODE_RGMII_10) ||
+        (p_Dtsec->enetMode == e_ENET_MODE_RGMII_100)||
+        (p_Dtsec->enetMode == e_ENET_MODE_SGMII_10) ||
+        (p_Dtsec->enetMode == e_ENET_MODE_SGMII_100))
+            tmpReg32 |= MACCFG2_NIBBLE_MODE;
+
+    else if((p_Dtsec->enetMode == e_ENET_MODE_RGMII_1000) ||
+        (p_Dtsec->enetMode == e_ENET_MODE_SGMII_1000)||
+        (p_Dtsec->enetMode == e_ENET_MODE_GMII_1000))
+            tmpReg32 |= MACCFG2_BYTE_MODE;
+
+    tmpReg32 |= (((uint32_t)p_DtsecDriverParam->preambleLength) & 0x0000000f)<< PREAMBLE_LENGTH_SHIFT;
+
+    if(p_DtsecDriverParam->preambleRxEn)
+        tmpReg32 |= MACCFG2_PRE_AM_Rx_EN;
+    if(p_DtsecDriverParam->preambleTxEn)
+        tmpReg32 |= MACCFG2_PRE_AM_Tx_EN;
+    if(p_DtsecDriverParam->hugeFramesEnable)
+        tmpReg32 |= MACCFG2_HUGE_FRAME;
+    if(p_DtsecDriverParam->lengthCheckEnable)
+        tmpReg32 |= MACCFG2_LENGTH_CHECK;
+    if(p_DtsecDriverParam->padAndCrcEnable)
+        tmpReg32 |=  MACCFG2_PAD_CRC_EN;
+    if(p_DtsecDriverParam->crcEnable)
+        tmpReg32 |= MACCFG2_CRC_EN ;
+    if(!p_DtsecDriverParam->halfDuplex)
+        tmpReg32 |= MACCFG2_FULL_DUPLEX;
+
+    WRITE_UINT32(p_DtsecMemMap->maccfg2, tmpReg32);
+/***************MACCFG2***********************/
+/***************IPGIFG************************/
+
+    tmpReg32 = 0;
+    ASSERT_COND(p_DtsecDriverParam->nonBackToBackIpg1 <= p_DtsecDriverParam->nonBackToBackIpg2);
+    tmpReg32 = (uint32_t)((((uint32_t)p_DtsecDriverParam->nonBackToBackIpg1 <<
+               IPGIFG_NON_BACK_TO_BACK_IPG_1_SHIFT) & IPGIFG_NON_BACK_TO_BACK_IPG_1) |
+              (((uint32_t)p_DtsecDriverParam->nonBackToBackIpg2  <<
+                IPGIFG_NON_BACK_TO_BACK_IPG_2_SHIFT) & IPGIFG_NON_BACK_TO_BACK_IPG_2) |
+              (((uint32_t)p_DtsecDriverParam->minIfgEnforcement <<
+                IPGIFG_MIN_IFG_ENFORCEMENT_SHIFT) & IPGIFG_MIN_IFG_ENFORCEMENT) |
+              ((uint32_t)p_DtsecDriverParam->backToBackIpg & IPGIFG_BACK_TO_BACK_IPG));
+
+    WRITE_UINT32(p_DtsecMemMap->ipgifg, tmpReg32);
+
+/***************IPGIFG************************/
+/***************HAFDUP************************/
+    tmpReg32 = 0;
+    if(p_DtsecDriverParam->alternateBackoffEnable)
+    {
+        tmpReg32 = (uint32_t) (HAFDUP_ALT_BEB  | (((uint32_t)p_DtsecDriverParam->alternateBackoffVal & 0x0000000f) <<
+                                    HAFDUP_ALTERNATE_BEB_TRUNCATION_SHIFT));
+    }
+
+    if(p_DtsecDriverParam->backPressureNoBackoff)
+        tmpReg32 |= HAFDUP_BP_NO_BACKOFF ;
+    if(p_DtsecDriverParam->noBackoff)
+        tmpReg32 |= HAFDUP_NO_BACKOFF ;
+    if(p_DtsecDriverParam->excessDefer)
+        tmpReg32 |= HAFDUP_EXCESS_DEFER ;
+    tmpReg32 |= (((uint32_t)p_DtsecDriverParam->maxRetransmission <<
+                HAFDUP_RETRANSMISSION_MAX_SHIFT )& HAFDUP_RETRANSMISSION_MAX);
+    tmpReg32|= ((uint32_t)p_DtsecDriverParam->collisionWindow & HAFDUP_COLLISION_WINDOW) ;
+
+    WRITE_UINT32(p_DtsecMemMap->hafdup, tmpReg32);
+/***************HAFDUP************************/
+/***************MAXFRM************************/
+
+    /* Initialize MAXFRM */
+    WRITE_UINT32(p_DtsecMemMap->maxfrm,
+                 p_DtsecDriverParam->maxFrameLength);
+
+/***************MAXFRM************************/
+/***************MII************************/
+//#warning /*TODO - to take care about MII stuff*/
+/***************MII************************/
+/***************CAM1************************/
+
+    WRITE_UINT32(p_DtsecMemMap->cam1,
+                 p_DtsecDriverParam->cam1);
+
+/***************CAM1************************/
+/***************CAM2************************/
+
+    WRITE_UINT32(p_DtsecMemMap->cam2,
+                 p_DtsecDriverParam->cam2);
+
+/***************CAM2************************/
+
+/***************MACSTNADDR1/2*****************/
+
+    /*  Initialize MAC Station Address registers (1 & 2)    */
+    /*  Station address have to be swapped (big endian to little endian */
+    addr = p_Dtsec->addr;
+
+    tmpReg32 = (uint32_t)(addr);
+    SwapUint32P(&tmpReg32);
+    WRITE_UINT32(p_DtsecMemMap->macstnaddr1, tmpReg32);
+
+    tmpReg32 = (uint32_t)(addr>>32);
+    SwapUint32P(&tmpReg32);
+    WRITE_UINT32(p_DtsecMemMap->macstnaddr2, tmpReg32);
+/***************MACSTNADDR1/2*****************/
+
+/***************DEBUG*****************/
+    WRITE_UINT32(p_DtsecMemMap->tx_threshold,       (uint32_t)(p_DtsecDriverParam->fifoTxThr & 0x7f));
+    WRITE_UINT32(p_DtsecMemMap->tx_watermark_high,  (uint32_t)(p_DtsecDriverParam->fifoTxWatermarkH & 0x7f));
+    WRITE_UINT32(p_DtsecMemMap->rx_watermark_low,   (uint32_t)(p_DtsecDriverParam->fifoRxWatermarkL & 0x7f));
+/***************DEBUG*****************/
+
+/*****************HASH************************/
+    for(i=0 ; i<NUM_OF_HASH_REGS ; i++)
+    {
+        /* Initialize IADDRx */
+        WRITE_UINT32(p_DtsecMemMap->igaddr[i], 0);
+        /* Initialize GADDRx */
+        WRITE_UINT32(p_DtsecMemMap->gaddr[i], 0);
+    }
+
+    p_Dtsec->p_MulticastAddrHash = AllocHashTable(HASH_TABLE_SIZE);
+    if(!p_Dtsec->p_MulticastAddrHash)
+    {
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("allocation hash table is FAILED"));
+    }
+
+    p_Dtsec->p_UnicastAddrHash = AllocHashTable(HASH_TABLE_SIZE);
+    if(!p_Dtsec->p_UnicastAddrHash)
+    {
+        FreeInitResources(p_Dtsec);
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("allocation hash table is FAILED"));
+    }
+    /*****************HASH************************/
+
+//#warning /*TODO - Set Interrupt routin*/
+//#warning /*TODO - TBI - need to think*/
+
+    XX_Free(p_DtsecDriverParam);
+    p_Dtsec->p_DtsecDriverParam = NULL;
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static t_Error DtsecFree(t_Handle h_Dtsec)
+{
+    t_Dtsec      *p_Dtsec = (t_Dtsec *)h_Dtsec;
+
+    SANITY_CHECK_RETURN_ERROR(h_Dtsec, E_INVALID_HANDLE);
+
+    if (p_Dtsec->p_DtsecDriverParam)
+    {
+        XX_Free(p_Dtsec->p_DtsecDriverParam);
+        p_Dtsec->p_DtsecDriverParam = NULL;
+    }
+    FreeInitResources(h_Dtsec);
+    XX_Free (h_Dtsec);
+
+    return E_OK;
+}
+
+
+/*****************************************************************************/
+/*                      dTSEC Configs modification functions                 */
+/*****************************************************************************/
+
+/* .............................................................................. */
+
+static t_Error DtsecConfigStatistics(t_Handle h_Dtsec, bool newVal)
+{
+    t_Dtsec *p_Dtsec = (t_Dtsec *)h_Dtsec;
+
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec->p_DtsecDriverParam, E_INVALID_STATE);
+
+    p_Dtsec->p_DtsecDriverParam->statisticsEnable = newVal;
+
+    return E_OK;
+}
+
+
+/* .............................................................................. */
+
+static t_Error DtsecConfigLoopback(t_Handle h_Dtsec, bool newVal)
+{
+
+    t_Dtsec *p_Dtsec = (t_Dtsec *)h_Dtsec;
+
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec->p_DtsecDriverParam, E_INVALID_STATE);
+
+    p_Dtsec->p_DtsecDriverParam->loopback = newVal;
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static t_Error DtsecConfigMaxFrameLength(t_Handle h_Dtsec, uint16_t newVal)
+{
+    t_Dtsec *p_Dtsec = (t_Dtsec *)h_Dtsec;
+
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec->p_DtsecDriverParam, E_INVALID_STATE);
+
+    p_Dtsec->p_DtsecDriverParam->maxFrameLength = newVal;
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static t_Error DtsecConfigPadAndCrc(t_Handle h_Dtsec, bool newVal)
+{
+    t_Dtsec *p_Dtsec = (t_Dtsec *)h_Dtsec;
+
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec->p_DtsecDriverParam, E_INVALID_STATE);
+
+    p_Dtsec->p_DtsecDriverParam->padAndCrcEnable = newVal;
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static t_Error DtsecConfigHalfDuplex(t_Handle h_Dtsec, bool newVal)
+{
+    t_Dtsec *p_Dtsec = (t_Dtsec *)h_Dtsec;
+
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec->p_DtsecDriverParam, E_INVALID_STATE);
+
+    p_Dtsec->p_DtsecDriverParam->halfDuplex = newVal;
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static t_Error DtsecConfigHugeFrames(t_Handle h_Dtsec, bool newVal)
+{
+    t_Dtsec *p_Dtsec = (t_Dtsec *)h_Dtsec;
+
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec->p_DtsecDriverParam, E_INVALID_STATE);
+
+    p_Dtsec->p_DtsecDriverParam->hugeFramesEnable = newVal;
+
+    return E_OK;
+}
+
+/*****************************************************************************/
+/*                      dTSEC Run Time API functions                         */
+/*****************************************************************************/
+
+/* .............................................................................. */
+
+static t_Error DtsecEnable(t_Handle h_Dtsec,  e_CommMode mode)
+{
+    t_Dtsec             *p_Dtsec = (t_Dtsec *)h_Dtsec;
+    t_DtsecMemMap       *p_MemMap ;
+    uint32_t            tmpReg32 = 0;
+
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec->p_MemMap, E_INVALID_HANDLE);
+
+    p_MemMap= (t_DtsecMemMap*)(p_Dtsec->p_MemMap);
+
+    tmpReg32 = GET_UINT32(p_MemMap->maccfg1);
+
+    switch (mode)
+    {
+        case e_COMM_MODE_NONE:
+            tmpReg32 &= ~(MACCFG1_RX_EN | MACCFG1_TX_EN);
+            break;
+        case e_COMM_MODE_RX :
+            tmpReg32 |= MACCFG1_RX_EN ;
+            break;
+        case e_COMM_MODE_TX :
+            tmpReg32 |= MACCFG1_TX_EN ;
+            break;
+        case e_COMM_MODE_RX_AND_TX:
+            tmpReg32 |= (MACCFG1_RX_EN | MACCFG1_TX_EN);
+            break;
+        default:
+            RETURN_ERROR(MINOR, E_INVALID_SELECTION, NO_MSG);
+    }
+
+    WRITE_UINT32(p_MemMap->maccfg1, tmpReg32);
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static t_Error DtsecDisable (t_Handle h_Dtsec, e_CommMode mode)
+{
+    t_Dtsec             *p_Dtsec = (t_Dtsec *)h_Dtsec;
+    t_DtsecMemMap       *p_MemMap ;
+    uint32_t            tmpReg32 = 0;
+
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec->p_MemMap, E_INVALID_HANDLE);
+
+    p_MemMap = (t_DtsecMemMap*)(p_Dtsec->p_MemMap);
+
+    tmpReg32 = GET_UINT32(p_MemMap->maccfg1);
+
+    switch (mode)
+    {
+        case e_COMM_MODE_RX :
+            rxGracefulStop(h_Dtsec);
+            tmpReg32 &= ~MACCFG1_RX_EN ;
+            break;
+        case e_COMM_MODE_TX :
+            txGracefulStop(h_Dtsec);
+            tmpReg32 &= ~MACCFG1_TX_EN ;
+            break;
+        case e_COMM_MODE_RX_AND_TX:
+            rxGracefulStop(h_Dtsec);
+            txGracefulStop(h_Dtsec);
+            tmpReg32 &= ~(MACCFG1_RX_EN | MACCFG1_TX_EN);
+            break;
+        default:
+            RETURN_ERROR(MINOR, E_INVALID_SELECTION, NO_MSG);
+    }
+
+    WRITE_UINT32(p_MemMap->maccfg1, tmpReg32);
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static t_Error DtsecRestart(t_Handle h_Dtsec, e_CommMode mode)
+{
+    t_Dtsec *p_Dtsec = (t_Dtsec *)h_Dtsec;
+    t_DtsecMemMap *p_MemMap ;
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec->p_MemMap, E_INVALID_HANDLE);
+
+    p_MemMap= (t_DtsecMemMap*)(p_Dtsec->p_MemMap);
+    if(mode & e_COMM_MODE_TX)
+        /* clear the graceful receive stop bit */
+        WRITE_UINT32(p_MemMap->tctrl,
+                      GET_UINT32(p_MemMap->tctrl) & ~TCTRL_GTS);
+
+    if(mode & e_COMM_MODE_RX)
+        /* clear the graceful receive stop bit */
+        WRITE_UINT32(p_MemMap->rctrl,
+                      GET_UINT32(p_MemMap->rctrl) & ~RCTRL_GRS);
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static t_Error DtsecTxMacPause(t_Handle h_Dtsec, uint16_t pauseTime, uint16_t exPauseTime )
+{
+    t_Dtsec      *p_Dtsec = (t_Dtsec *)h_Dtsec;
+    uint32_t    ptv = 0 ;
+    t_DtsecMemMap *p_MemMap;
+
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(!p_Dtsec->p_DtsecDriverParam, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec->p_MemMap, E_INVALID_STATE);
+
+    p_MemMap = (t_DtsecMemMap*)(p_Dtsec->p_MemMap);
+
+    ptv = ((uint32_t)exPauseTime << PTV_PTE_SHIFT) | pauseTime ;
+    WRITE_UINT32(p_MemMap->ptv, ptv);
+
+    /* trigger the transmission of a flow-control pause frame */
+    WRITE_UINT32(p_MemMap->tctrl,
+                 GET_UINT32(p_MemMap->tctrl) | TCTRL_TFC_PAUSE);
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static t_Error DtsecReadStatistics(t_Handle h_Dtsec)
+{
+    t_Dtsec          *p_Dtsec = (t_Dtsec *)h_Dtsec;
+    t_DtsecMemMap    *p_DtsecMemMap;
+    t_FmMacStatistics *p_Statistics = &p_Dtsec->macStatistics;
+    uint32_t            tmpRdrp, tmpRaln, tmpTdrp;
+
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec->p_MemMap, E_INVALID_HANDLE);
+
+    p_DtsecMemMap = p_Dtsec->p_MemMap;
+
+    p_Statistics->eStatPkts64           += (MASK22BIT & GET_UINT32(p_DtsecMemMap->tr64));      /**< r-10G tr-DT 64 byte frame counter */
+    p_Statistics->eStatPkts65to127      += (MASK22BIT & GET_UINT32(p_DtsecMemMap->tr127));     /**< r-10G 65 to 127 byte frame counter */
+    p_Statistics->eStatPkts128to255     += (MASK22BIT & GET_UINT32(p_DtsecMemMap->tr255));     /**< r-10G 128 to 255 byte frame counter */
+    p_Statistics->eStatPkts256to511     += (MASK22BIT & GET_UINT32(p_DtsecMemMap->tr511));     /**< r-10G 256 to 511 byte frame counter */
+    p_Statistics->eStatPkts512to1023    += (MASK22BIT & GET_UINT32(p_DtsecMemMap->tr1k));      /**< r-10G 512 to 1023 byte frame counter */
+    p_Statistics->eStatPkts1024to1518   += (MASK22BIT & GET_UINT32(p_DtsecMemMap->trmax));     /**< r-10G 1024 to 1518 byte frame counter */
+    p_Statistics->eStatPkts1519to1522   += (MASK22BIT & GET_UINT32(p_DtsecMemMap->trmgv));     /**< r-10G 1519 to 1522 byte good frame count */
+/* */
+    p_Statistics->eStatFragments        += (MASK16BIT & GET_UINT32(p_DtsecMemMap->rfrg));      /**< Total number of packets that were less than 64 octets long with a wrong CRC.*/
+    p_Statistics->eStatJabbers          += (MASK16BIT & GET_UINT32(p_DtsecMemMap->rjbr));      /**< Total number of packets longer than valid maximum length octets */
+
+    tmpRdrp                             = (MASK16BIT & GET_UINT32(p_DtsecMemMap->rdrp));      /**< number of dropped packets due to internal errors of the MAC Client. */
+    tmpRaln                             = (MASK16BIT & GET_UINT32(p_DtsecMemMap->raln));      /**< Incremented when frames of correct length but with CRC error are received.*/
+    p_Statistics->eStatsDropEvents      += tmpRdrp;                                            /**< number of dropped packets due to internal errors of the MAC Client. */
+    p_Statistics->eStatCRCAlignErrors   += tmpRaln;                                            /**< Incremented when frames of correct length but with CRC error are received.*/
+
+    p_Statistics->eStatUndersizePkts    += (MASK16BIT & GET_UINT32(p_DtsecMemMap->rund));      /**< Total number of packets that were less than 64 octets long with a good CRC.*/
+    p_Statistics->eStatOversizePkts     += (MASK16BIT & GET_UINT32(p_DtsecMemMap->rovr));      /**< T,B.D*/
+/* Pause */
+    p_Statistics->reStatPause           += (MASK16BIT & GET_UINT32(p_DtsecMemMap->rxpf));      /**< Pause MAC Control received */
+    p_Statistics->teStatPause           += (MASK16BIT & GET_UINT32(p_DtsecMemMap->txpf));      /**< Pause MAC Control sent */
+
+/* MIB II */
+    p_Statistics->ifInOctets            += GET_UINT32(p_DtsecMemMap->rbyt);                  /**< Total number of byte received. */
+    p_Statistics->ifInPkts              += (MASK22BIT & GET_UINT32(p_DtsecMemMap->rpkt));    /**< Total number of packets received.*/
+    p_Statistics->ifInMcastPkts         += (MASK22BIT & GET_UINT32(p_DtsecMemMap->rmca));    /**< Total number of multicast frame received*/
+    p_Statistics->ifInBcastPkts         += (MASK22BIT & GET_UINT32(p_DtsecMemMap->rbca));    /**< Total number of broadcast frame received */
+    p_Statistics->ifInDiscards          = p_Statistics->eStatsDropEvents;                    /**< Frames received, but discarded due to problems within the MAC RX. */
+
+    p_Statistics->ifInErrors            += tmpRdrp
+                                        + tmpRaln
+                                        + (MASK16BIT & GET_UINT32(p_DtsecMemMap->rflr))
+                                        + (MASK16BIT & GET_UINT32(p_DtsecMemMap->rcde))
+                                        + (MASK16BIT & GET_UINT32(p_DtsecMemMap->rcse));
+
+    p_Statistics->ifOutOctets           += GET_UINT32(p_DtsecMemMap->tbyt);                  /**< Total number of byte sent. */
+    p_Statistics->ifOutPkts             += (MASK22BIT & GET_UINT32(p_DtsecMemMap->tpkt));    /**< Total number of packets sent .*/
+    p_Statistics->ifOutMcastPkts        += (MASK22BIT & GET_UINT32(p_DtsecMemMap->tmca));    /**< Total number of multicast frame sent */
+    p_Statistics->ifOutBcastPkts        += (MASK22BIT & GET_UINT32(p_DtsecMemMap->tbca));    /**< Total number of multicast frame sent */
+    tmpTdrp                             =  (MASK16BIT & GET_UINT32(p_DtsecMemMap->tdrp));     /**< Frames received, but discarded due to problems within the MAC TX N/A!.*/
+    p_Statistics->ifOutDiscards         += tmpTdrp;                                          /**< Frames received, but discarded due to problems within the MAC TX N/A!.*/
+    p_Statistics->ifOutErrors           += tmpTdrp                                           /**< Number of frames transmitted with error: */
+                                        + (MASK12BIT & GET_UINT32(p_DtsecMemMap->tfcs));
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static t_Error DtsecGetStatistics(t_Handle h_Dtsec, t_FmMacStatistics *p_Statistics)
+{
+    t_Dtsec          *p_Dtsec = (t_Dtsec *)h_Dtsec;
+
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Statistics, E_NULL_POINTER);
+
+    DtsecReadStatistics(h_Dtsec);              /* Update all counters based on HW counters */
+
+    memcpy((char *)p_Statistics, (char *)&p_Dtsec->macStatistics, sizeof(t_FmMacStatistics));
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static t_Error DtsecModifyMacAddress (t_Handle h_Dtsec, t_EnetAddr *p_EnetAddr)
+{
+    t_Dtsec              *p_Dtsec = (t_Dtsec *)h_Dtsec;
+    t_DtsecMemMap        *p_DtsecMemMap = p_Dtsec->p_MemMap;
+    uint32_t              tmpReg32 = 0;
+    uint64_t              addr;
+
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_DtsecMemMap, E_INVALID_HANDLE);
+
+    /*  Initialize MAC Station Address registers (1 & 2)    */
+    /*  Station address have to be swapped (big endian to little endian */
+    addr = ((*(uint64_t *)p_EnetAddr) >> 16);
+    p_Dtsec->addr = addr;
+
+    tmpReg32 = (uint32_t)(addr);
+    SwapUint32P(&tmpReg32);
+    WRITE_UINT32(p_DtsecMemMap->macstnaddr1, tmpReg32);
+
+    tmpReg32 = (uint32_t)(addr>>32);
+    SwapUint32P(&tmpReg32);
+    WRITE_UINT32(p_DtsecMemMap->macstnaddr2, tmpReg32);
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static t_Error DtsecResetCounters (t_Handle h_Dtsec)
+{
+    t_Dtsec          *p_Dtsec = (t_Dtsec *)h_Dtsec;
+
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
+
+    DtsecReadStatistics(h_Dtsec);              /* Update all counters based on HW counters */
+
+    memset((char *)&p_Dtsec->macStatistics, (char)0x0, sizeof(t_FmMacStatistics));
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static t_Error DtsecDelExactMatchMacAddress(t_Handle h_Dtsec, t_EnetAddr *p_EthAddr)
+{
+    t_Dtsec   *p_Dtsec = (t_Dtsec *) h_Dtsec;
+    uint64_t  ethAddr;
+    uint8_t   paddrNum;
+
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
+
+    ethAddr = ((*(uint64_t *)p_EthAddr) >> 16);
+
+    /* Find used PADDR containing this address */
+    for (paddrNum = 0; paddrNum < DTSEC_NUM_OF_PADDRS; paddrNum++)
+    {
+        if ((p_Dtsec->indAddrRegUsed[paddrNum]) &&
+            (p_Dtsec->paddr[paddrNum] == ethAddr))
+        {
+            /* mark this PADDR as not used */
+            p_Dtsec->indAddrRegUsed[paddrNum] = FALSE;
+            /* clear in hardware */
+            HardwareClearAddrInPaddr(p_Dtsec, paddrNum);
+            p_Dtsec->numOfIndAddrInRegs--;
+
+            return E_OK;
+        }
+    }
+
+    RETURN_ERROR(MAJOR, E_NOT_FOUND, NO_MSG);
+}
+
+/* .............................................................................. */
+
+static t_Error DtsecAddExactMatchMacAddress(t_Handle h_Dtsec, t_EnetAddr *p_EthAddr)
+{
+    t_Dtsec   *p_Dtsec = (t_Dtsec *) h_Dtsec;
+    uint64_t  ethAddr;
+    uint8_t   paddrNum;
+
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
+
+    ethAddr = ((*(uint64_t *)p_EthAddr) >> 16);
+
+    if (ethAddr & GROUP_ADDRESS)
+        /* Multicast address has no effect in PADDR */
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Multicast address"));
+
+    /* Make sure no PADDR contains this address */
+    for (paddrNum = 0; paddrNum < DTSEC_NUM_OF_PADDRS; paddrNum++)
+        if (p_Dtsec->indAddrRegUsed[paddrNum])
+            if (p_Dtsec->paddr[paddrNum] == ethAddr)
+                RETURN_ERROR(MAJOR, E_ALREADY_EXISTS, NO_MSG);
+
+    /* Find first unused PADDR */
+    for (paddrNum = 0; paddrNum < DTSEC_NUM_OF_PADDRS; paddrNum++)
+        if (!(p_Dtsec->indAddrRegUsed[paddrNum]))
+        {
+            /* mark this PADDR as used */
+            p_Dtsec->indAddrRegUsed[paddrNum] = TRUE;
+            /* store address */
+            p_Dtsec->paddr[paddrNum] = ethAddr;
+
+            /* put in hardware */
+            HardwareAddAddrInPaddr(p_Dtsec, &ethAddr, paddrNum);
+            p_Dtsec->numOfIndAddrInRegs++;
+
+            return E_OK;
+        }
+
+    /* No free PADDR */
+    RETURN_ERROR(MAJOR, E_FULL, NO_MSG);
+}
+
+/* .............................................................................. */
+
+static t_Error DtsecAddHashMacAddress(t_Handle h_Dtsec, t_EnetAddr *p_EthAddr)
+{
+    t_Dtsec         *p_Dtsec = (t_Dtsec *)h_Dtsec;
+    t_DtsecMemMap   *p_DtsecMemMap = p_Dtsec->p_MemMap;
+    uint32_t        crc;
+    uint8_t         crcMirror, reg;
+    uint32_t        bitMask;
+    t_EthHashEntry  *p_HashEntry;
+    uint64_t        ethAddr;
+
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_DtsecMemMap, E_INVALID_HANDLE);
+
+    ethAddr = ((*(uint64_t *)p_EthAddr) >> 16);
+
+    /* CRC calculation */
+    GET_MAC_ADDR_CRC(ethAddr, crc);
+
+    /* calculate the "crc mirror" */
+    crcMirror = MIRROR((uint8_t)crc);
+
+    /* 3 MSB bits define the register */
+    reg = (uint8_t)(crcMirror >> 5);
+    /* 5 LSB bits define the bit within the register */
+    bitMask =  0x80000000 >> (crcMirror & 0x1f);
+
+    /* Create element to be added to the driver hash table */
+    p_HashEntry = (t_EthHashEntry *)XX_Malloc(sizeof(t_EthHashEntry));
+    p_HashEntry->addr = ethAddr;
+    INIT_LIST(&p_HashEntry->node);
+
+    if (ethAddr & GROUP_ADDRESS)
+    {
+        /* Group Address */
+        LIST_AddToTail(&(p_HashEntry->node), &(p_Dtsec->p_MulticastAddrHash->p_Lsts[crcMirror]));
+        /* Set the appropriate bit in GADDR0-7 */
+        WRITE_UINT32(p_DtsecMemMap->gaddr[reg],
+                     GET_UINT32(p_DtsecMemMap->gaddr[reg]) | bitMask);
+    }
+    else
+    {
+        LIST_AddToTail(&(p_HashEntry->node), &(p_Dtsec->p_UnicastAddrHash->p_Lsts[crcMirror]));
+        /* Set the appropriate bit in IADDR0-7 */
+        WRITE_UINT32(p_DtsecMemMap->igaddr[reg],
+                     GET_UINT32(p_DtsecMemMap->igaddr[reg]) | bitMask);
+    }
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static t_Error DtsecDelHashMacAddress(t_Handle h_Dtsec, t_EnetAddr *p_EthAddr)
+{
+    t_Dtsec         *p_Dtsec = (t_Dtsec *)h_Dtsec;
+    t_DtsecMemMap   *p_DtsecMemMap = p_Dtsec->p_MemMap;
+    t_List          *p_Pos;
+    uint32_t        crc;
+    uint8_t         crcMirror, reg;
+    uint32_t        bitMask;
+    t_EthHashEntry  *p_HashEntry = NULL;
+    uint64_t        ethAddr;
+
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_DtsecMemMap, E_INVALID_HANDLE);
+
+    ethAddr = ((*(uint64_t *)p_EthAddr) >> 16);
+
+    /* CRC calculation */
+    GET_MAC_ADDR_CRC(ethAddr, crc);
+
+    /* calculate the "crc mirror" */
+    crcMirror = MIRROR((uint8_t)crc);
+
+    /* 3 MSB bits define the register */
+    reg =(uint8_t)( crcMirror >> 5);
+    /* 5 LSB bits define the bit within the register */
+    bitMask =  0x80000000 >> (crcMirror & 0x1f);
+
+    if (ethAddr & GROUP_ADDRESS)
+    {
+        /* Group Address */
+        LIST_FOR_EACH(p_Pos, &(p_Dtsec->p_MulticastAddrHash->p_Lsts[crcMirror]))
+        {
+
+            p_HashEntry = ETH_HASH_ENTRY_OBJ(p_Pos);
+            if(p_HashEntry->addr == ethAddr)
+            {
+                LIST_DelAndInit(&p_HashEntry->node);
+                XX_Free(p_HashEntry);
+                break;
+            }
+        }
+        if(LIST_IsEmpty(&p_Dtsec->p_MulticastAddrHash->p_Lsts[crcMirror]))
+            WRITE_UINT32(p_DtsecMemMap->gaddr[reg],
+                         GET_UINT32(p_DtsecMemMap->gaddr[reg]) & ~bitMask);
+    }
+    else
+    {
+        /* Individual Address */
+        LIST_FOR_EACH(p_Pos, &(p_Dtsec->p_UnicastAddrHash->p_Lsts[crcMirror]))
+        {
+            p_HashEntry = ETH_HASH_ENTRY_OBJ(p_Pos);
+            if(p_HashEntry->addr == ethAddr)
+            {
+                LIST_DelAndInit(&p_HashEntry->node);
+                XX_Free(p_HashEntry);
+                break;
+            }
+        }
+        if(LIST_IsEmpty(&p_Dtsec->p_UnicastAddrHash->p_Lsts[crcMirror]))
+            WRITE_UINT32(p_DtsecMemMap->igaddr[reg],
+                         GET_UINT32(p_DtsecMemMap->igaddr[reg]) & ~bitMask);
+    }
+
+    /* address does not exist */
+    ASSERT_COND(p_HashEntry != NULL);
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static t_Error DtsecSetPromiscuous(t_Handle h_Dtsec, bool newVal)
+{
+    t_Dtsec         *p_Dtsec = (t_Dtsec *)h_Dtsec;
+    t_DtsecMemMap   *p_DtsecMemMap = p_Dtsec->p_MemMap;
+    uint32_t        tmpReg32;
+
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_Dtsec->p_DtsecDriverParam, E_INVALID_HANDLE);
+
+    tmpReg32 = GET_UINT32(p_DtsecMemMap->rctrl);
+
+    if (newVal)
+        tmpReg32 |= RCTRL_PROM;
+    else
+        tmpReg32 &= ~RCTRL_PROM;
+
+    WRITE_UINT32(p_DtsecMemMap->rctrl, tmpReg32);
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static t_Error DtsecAdjustLink(t_Handle h_Dtsec, e_EnetSpeed speed, bool fullDuplex)
+{
+    t_Dtsec         *p_Dtsec = (t_Dtsec *)h_Dtsec;
+    t_DtsecMemMap   *p_DtsecMemMap = p_Dtsec->p_MemMap;
+    uint32_t        tmpReg32;
+
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_Dtsec->p_DtsecDriverParam, E_INVALID_HANDLE);
+
+    if (!fullDuplex &&
+        ((speed >= e_ENET_SPEED_1000) ||
+         (ENET_INTERFACE_FROM_MODE(p_Dtsec->enetMode) == e_ENET_IF_SGMII)))
+        RETURN_ERROR(MAJOR, E_CONFLICT, ("Ethernet interface does not support Half Duplex mode"));
+
+    p_Dtsec->enetMode = MAKE_ENET_MODE(ENET_INTERFACE_FROM_MODE(p_Dtsec->enetMode), speed);
+    p_Dtsec->p_DtsecDriverParam->halfDuplex = !fullDuplex;
+
+    tmpReg32 = GET_UINT32(p_DtsecMemMap->maccfg2);
+    if(p_Dtsec->p_DtsecDriverParam->halfDuplex)
+        tmpReg32 &= ~MACCFG2_FULL_DUPLEX;
+    else
+        tmpReg32 |= MACCFG2_FULL_DUPLEX;
+    WRITE_UINT32(p_DtsecMemMap->maccfg2, tmpReg32);
+
+    tmpReg32 = GET_UINT32(p_DtsecMemMap->ecntrl);
+    if((p_Dtsec->enetMode == e_ENET_MODE_RGMII_10) ||
+        (p_Dtsec->enetMode == e_ENET_MODE_RGMII_100)||
+        (p_Dtsec->enetMode == e_ENET_MODE_SGMII_10) ||
+        (p_Dtsec->enetMode == e_ENET_MODE_SGMII_100))
+            tmpReg32 |= MACCFG2_NIBBLE_MODE;
+
+    else if((p_Dtsec->enetMode == e_ENET_MODE_RGMII_1000) ||
+        (p_Dtsec->enetMode == e_ENET_MODE_SGMII_1000)||
+        (p_Dtsec->enetMode == e_ENET_MODE_GMII_1000))
+            tmpReg32 |= MACCFG2_BYTE_MODE;
+    WRITE_UINT32(p_DtsecMemMap->ecntrl, tmpReg32);
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static t_Error DtsecGetId(t_Handle h_Dtsec, uint32_t *macId)
+{
+    t_Dtsec              *p_Dtsec = (t_Dtsec *)h_Dtsec;
+    t_DtsecMemMap        *p_DtsecMemMap = p_Dtsec->p_MemMap;
+UNUSED(macId);
+
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_Dtsec->p_DtsecDriverParam, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_DtsecMemMap, E_INVALID_HANDLE);
+
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("DtsecGetId Not Supported"));
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static t_Error DtsecGetVersion(t_Handle h_Dtsec, uint32_t *macVersion)
+{
+    t_Dtsec              *p_Dtsec = (t_Dtsec *)h_Dtsec;
+    t_DtsecMemMap        *p_DtsecMemMap = p_Dtsec->p_MemMap;
+
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_Dtsec->p_DtsecDriverParam, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_DtsecMemMap, E_INVALID_HANDLE);
+
+    *macVersion = GET_UINT32(p_DtsecMemMap->tsec_id1);
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static t_Error DtsecSetExcpetions(t_Handle h_Dtsec, e_FmMacExceptions ex)
+{
+    t_Dtsec              *p_Dtsec = (t_Dtsec *)h_Dtsec;
+
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
+UNUSED(ex);
+
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
+/* ........................................................................... */
+
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+static t_Error DtsecDumpRegs(t_Handle h_Dtsec)
+{
+    t_Dtsec *p_Dtsec = (t_Dtsec *)h_Dtsec;
+    int i = 0;
+
+    DECLARE_DUMP;
+
+    if (p_Dtsec->p_MemMap)
+    {
+
+        DUMP_TITLE(p_Dtsec->p_MemMap, ("MAC %d: ", p_Dtsec->macId));
+        DUMP_VAR(p_Dtsec->p_MemMap, tsec_id1);
+        DUMP_VAR(p_Dtsec->p_MemMap, tsec_id2);
+        DUMP_VAR(p_Dtsec->p_MemMap, ievent);
+        DUMP_VAR(p_Dtsec->p_MemMap, imask);
+        DUMP_VAR(p_Dtsec->p_MemMap, edis);
+        DUMP_VAR(p_Dtsec->p_MemMap, ecntrl);
+        DUMP_VAR(p_Dtsec->p_MemMap, ptv);
+        DUMP_VAR(p_Dtsec->p_MemMap, tctrl);
+        DUMP_VAR(p_Dtsec->p_MemMap, rctrl);
+        DUMP_VAR(p_Dtsec->p_MemMap, maccfg1);
+        DUMP_VAR(p_Dtsec->p_MemMap, maccfg2);
+        DUMP_VAR(p_Dtsec->p_MemMap, ipgifg);
+        DUMP_VAR(p_Dtsec->p_MemMap, hafdup);
+        DUMP_VAR(p_Dtsec->p_MemMap, maxfrm);
+
+        DUMP_VAR(p_Dtsec->p_MemMap, macstnaddr1);
+        DUMP_VAR(p_Dtsec->p_MemMap, macstnaddr2);
+
+        DUMP_SUBSTRUCT_ARRAY(i, 8)
+        {
+            DUMP_VAR(p_Dtsec->p_MemMap, macaddr[i].exact_match1);
+            DUMP_VAR(p_Dtsec->p_MemMap, macaddr[i].exact_match2);
+        }
+
+    }
+
+    return E_OK;
+}
+#endif /* (defined(DEBUG_ERRORS) && ... */
+
+
+/*****************************************************************************/
+/*                      dTSEC Config  Main Entry                             */
+/*****************************************************************************/
+
+/* .............................................................................. */
+
+static void InitFmMacControllerDriver(t_FmMacControllerDriver *p_FmMacControllerDriver)
+{
+    p_FmMacControllerDriver->f_FM_MAC_Init                      = DtsecInit;
+    p_FmMacControllerDriver->f_FM_MAC_Free                      = DtsecFree;
+
+    p_FmMacControllerDriver->f_FM_MAC_ConfigStatistics          = DtsecConfigStatistics;
+    p_FmMacControllerDriver->f_FM_MAC_ConfigLoopback            = DtsecConfigLoopback;
+    p_FmMacControllerDriver->f_FM_MAC_ConfigMaxFrameLength      = DtsecConfigMaxFrameLength;
+
+    p_FmMacControllerDriver->f_FM_MAC_ConfigWan                 = NULL; /* Not supported on dTSEC */
+
+    p_FmMacControllerDriver->f_FM_MAC_ConfigPadAndCrc           = DtsecConfigPadAndCrc;
+    p_FmMacControllerDriver->f_FM_MAC_ConfigHalfDuplex          = DtsecConfigHalfDuplex;
+    p_FmMacControllerDriver->f_FM_MAC_ConfigHugeFrames          = DtsecConfigHugeFrames;
+
+    p_FmMacControllerDriver->f_FM_MAC_Enable                    = DtsecEnable;
+    p_FmMacControllerDriver->f_FM_MAC_Disable                   = DtsecDisable;
+    p_FmMacControllerDriver->f_FM_MAC_Restart                   = DtsecRestart;
+
+    p_FmMacControllerDriver->f_FM_MAC_SetExceptions             = DtsecSetExcpetions;
+
+    p_FmMacControllerDriver->f_FM_MAC_SetPromiscuous            = DtsecSetPromiscuous;
+    p_FmMacControllerDriver->f_FM_MAC_AdjustLink                = DtsecAdjustLink;
+
+    p_FmMacControllerDriver->f_FM_MAC_TxMacPause                = DtsecTxMacPause;
+
+    p_FmMacControllerDriver->f_FM_MAC_ResetCounters             = DtsecResetCounters;
+    p_FmMacControllerDriver->f_FM_MAC_GetStatistics             = DtsecGetStatistics;
+
+    p_FmMacControllerDriver->f_FM_MAC_ModifyMacAddr             = DtsecModifyMacAddress;
+    p_FmMacControllerDriver->f_FM_MAC_AddHashMacAddr            = DtsecAddHashMacAddress;
+    p_FmMacControllerDriver->f_FM_MAC_RemoveHashMacAddr         = DtsecDelHashMacAddress;
+    p_FmMacControllerDriver->f_FM_MAC_AddExactMatchMacAddr      = DtsecAddExactMatchMacAddress;
+    p_FmMacControllerDriver->f_FM_MAC_RemovelExactMatchMacAddr  = DtsecDelExactMatchMacAddress;
+    p_FmMacControllerDriver->f_FM_MAC_GetId                     = DtsecGetId;
+    p_FmMacControllerDriver->f_FM_MAC_GetVersion                = DtsecGetVersion;
+
+    p_FmMacControllerDriver->f_FM_MAC_MII_WritePhyReg           = MII_WritePhyReg;
+    p_FmMacControllerDriver->f_FM_MAC_MII_ReadPhyReg            = MII_ReadPhyReg;
+
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+    p_FmMacControllerDriver->f_FM_MAC_DumpRegs                  = DtsecDumpRegs;
+#endif /* (defined(DEBUG_ERRORS) && ... */
+}
+
+/* .............................................................................. */
+
+t_Handle  DTSEC_Config(t_FmMacParams *p_FmMacParam)
+{
+    t_Dtsec             *p_Dtsec;
+    t_DtsecDriverParam  *p_DtsecDriverParam;
+    uint64_t            baseAddr = p_FmMacParam->baseAddr;
+
+    SANITY_CHECK_RETURN_VALUE(p_FmMacParam, E_NULL_POINTER, NULL);
+
+    /* allocate memory for the UCC GETH data structure. */
+    p_Dtsec = (t_Dtsec *) XX_Malloc(sizeof(t_Dtsec));
+    if (!p_Dtsec)
+    {
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("dTSEC driver structure"));
+        return NULL;
+    }
+    /* Zero out * p_Dtsec */
+    memset( p_Dtsec, 0, sizeof(t_Dtsec));
+    InitFmMacControllerDriver(&p_Dtsec->fmMacControllerDriver);
+
+    /* allocate memory for the dTSEC driver parameters data structure. */
+    p_DtsecDriverParam = (t_DtsecDriverParam *) XX_Malloc(sizeof(t_DtsecDriverParam));
+    if (!p_DtsecDriverParam)
+    {
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("dTSEC driver parameters"));
+        DtsecFree(p_Dtsec);
+        return NULL;
+    }
+    /* Zero out */
+    memset(p_DtsecDriverParam, 0, sizeof(t_DtsecDriverParam));
+
+    /* Plant parameter structure pointer */
+    p_Dtsec->p_DtsecDriverParam = p_DtsecDriverParam;
+
+    SetDefaultParam(p_Dtsec, p_DtsecDriverParam);
+
+    p_Dtsec->h_App    = p_FmMacParam->h_App ;
+    p_Dtsec->addr  = ((*(uint64_t *)p_FmMacParam->addr) >> 16);
+    p_Dtsec->p_MemMap = CAST_UINT64_TO_POINTER_TYPE(t_DtsecMemMap, baseAddr);
+    p_Dtsec->p_MiiMemMap  = CAST_UINT64_TO_POINTER_TYPE(t_MiiAccessMemMap, (baseAddr + DTSEC_TO_MII_OFFSET));
+    p_Dtsec->enetMode = p_FmMacParam->enetMode;
+    p_Dtsec->macId    = p_FmMacParam->macId;
+
+    return p_Dtsec;
+}
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.h b/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.h
new file mode 100644
index 0000000..cb2e2a1
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.h
@@ -0,0 +1,496 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/******************************************************************************
+ @File          dtsec.h
+
+ @Description   FM dTSEC ...
+*//***************************************************************************/
+#ifndef __DTSEC_H
+#define __DTSEC_H
+
+#include "std_ext.h"
+#include "error_ext.h"
+#include "list_ext.h"
+#include "dtsec_mii_acc.h"
+#include "fm_mac.h"
+
+
+#define MAX_PACKET_ALIGNMENT        31
+#define MAX_INTER_PACKET_GAP        0x7f
+#define MAX_INTER_PALTERNATE_BEB    0x0f
+#define MAX_RETRANSMISSION          0x0f
+#define MAX_COLLISION_WINDOW        0x03ff
+
+
+/*********************From mac ext *******************************************/
+typedef  uint32_t t_ErrorDisable;
+
+#define ERROR_DISABLE_TRANSMIT              0x00400000
+#define ERROR_DISABLE_LATE_COLLISION        0x00040000
+#define ERROR_DISABLE_COLLISION_RETRY_LIMIT 0x00020000
+#define ERROR_DISABLE_TxFIFO_UNDERRUN       0x00010000
+#define ERROR_DISABLE_TxABORT               0x00008000
+#define ERROR_DISABLE_INTERFACE             0x00004000
+#define ERROR_DISABLE_TxDATA_PARITY         0x00000002
+#define ERROR_DISABLE_RxDATA_PARITY         0x00000001
+
+/*****************************************************************************/
+#define DTSEC_NUM_OF_PADDRS         15  /* number of pattern match registers (entries) */
+
+#define GROUP_ADDRESS               0x0000010000000000LL /* Group address bit indication */
+
+                           /* if TRUE, Multiple individual addresses are used*/
+
+#define HASH_TABLE_SIZE             256 /* Hash table size (= 32 bits * 8 regs) */
+
+
+#define DTSEC_TO_MII_OFFSET         0x1000  /* number of pattern match registers (entries) */
+
+#define DEFAULT_cam                 0
+
+#define DEFAULT_errorDisabled       0
+#define DEFAULT_autoZeroCounters    TRUE        /* Must be TRUE don't change with updating driver */
+#define DEFAULT_statisticsEnable    TRUE
+#define DEFAULT_promiscuousEnable   FALSE
+
+#define DEFAULT_pauseExtended       0
+#define DEFAULT_pauseTime           0xf000
+
+#define DEFAULT_halfDuplex              FALSE
+#define DEFAULT_halfDulexFlowControlEn  FALSE
+#define DEFAULT_txTimeStampEn           FALSE
+#define DEFAULT_rxTimeStampEn           FALSE
+
+#define DEFAULT_packetAlignment     0
+#define DEFAULT_controlFrameAccept  FALSE
+#define DEFAULT_groupHashExtend     FALSE
+#define DEFAULT_broadcReject        FALSE
+#define DEFAULT_rxShortFrame        TRUE
+#define DEFAULT_exactMatch          FALSE
+
+#define DEFAULT_debugMode           FALSE
+
+#define DEFAULT_loopback            FALSE
+#define DEFAULT_actOnRxPauseFrame   FALSE
+#define DEFAULT_actOnTxPauseFrame   FALSE
+
+#define DEFAULT_PreAmLength         0x7
+#define DEFAULT_PreAmRxEn           FALSE
+#define DEFAULT_PreAmTxEn           FALSE
+#define DEFAULT_hugeFrames          TRUE
+#define DEFAULT_lengthCheckEnable   FALSE
+#define DEFAULT_padAndCrcEnable     TRUE
+#define DEFAULT_crcEnable           FALSE
+
+#define DEFAULT_nonBackToBackIpg1   0x40
+#define DEFAULT_nonBackToBackIpg2   0x60
+#define DEFAULT_minIfgEnforcement   0x50
+#define DEFAULT_backToBackIpg       0x60
+
+#define DEFAULT_altBackoffVal          0x0A
+#define DEFAULT_altBackoffEnable       FALSE
+#define DEFAULT_backPressureNoBackoff  FALSE
+#define DEFAULT_noBackoff           FALSE
+#define DEFAULT_excessDefer         TRUE
+#define DEFAULT_maxRetransmission   0x0F
+#define DEFAULT_collisionWindow     0x37
+
+#define DEFAULT_maxFrameLength      0x600
+
+#define DEFAULT_collisionWindow     0x37
+
+#define DEFAULT_fifoTxThr           0x10
+#define DEFAULT_fifoTxWatermarkH    0x7e
+#define DEFAULT_fifoRxWatermarkL    0x08
+
+#define DEFAULT_imask               ((uint32_t)(IMASK_BREN | IMASK_RXCEN | IMASK_MSROEN | IMASK_GTSCEN | \
+                                                IMASK_BTEN | IMASK_TXCEN | IMASK_TXEEN |  IMASK_ABRTEN | \
+                                                IMASK_LCEN | IMASK_CRLEN | IMASK_XFUNEN) |IMASK_IFERREN| \
+                                                IMASK_MAGEN | IMASK_MMRDEN | IMASK_MMWREN |IMASK_GRSCEN| \
+                                                IMASK_TDPEEN |IMASK_RDPEEN)
+
+
+#define DTSEC_ID1_ID                0xffff0000
+#define DTSEC_ID1_REV_MJ            0x0000FF00
+#define DTSEC_ID1_REV_MN            0x000000ff
+
+#define ID2_INT_REDUCED_OFF         0x00010000
+#define ID2_INT_NORMAL_OFF          0x00020000
+
+#define ECNTRL_CLRCNT               0x00004000
+#define ECNTRL_AUTOZ                0x00002000
+#define ECNTRL_STEN                 0x00001000
+#define ECNTRL_CFG_RO               0x80000000
+#define ECNTRL_GMIIM                0x00000040
+#define ECNTRL_TBIM                 0x00000020
+#define ECNTRL_SGMIIM               0x00000002
+#define ECNTRL_RPM                  0x00000010
+#define ECNTRL_R100M                0x00000008
+
+#define TCTRL_THDF                  0x00000800
+#define TCTRL_TTSE                  0x00000040
+#define TCTRL_GTS                   0x00000020
+#define TCTRL_GET_RFC_PAUSE         0x00000010
+#define TCTRL_TFC_PAUSE             0x00000008
+
+/* PTV offsets */
+#define PTV_PTE_OFST                16
+
+#define RCTRL_CFA                   0x00008000
+#define RCTRL_GHTX                  0x00000400
+#define RCTRL_RTSE                  0x00000040
+#define RCTRL_GRS                   0x00000020
+#define RCTRL_BC_REJ                0x00000010
+#define RCTRL_MPROM                 0x00000008
+#define RCTRL_RSF                   0x00000004
+#define RCTRL_EMEN                  0x00000002
+#define RCTRL_UPROM                 0x00000001
+#define RCTRL_PROM                  (RCTRL_UPROM | RCTRL_MPROM)
+
+#define TSEC_ID1_DEBUG              0x00e00c00
+#define DEBUG_ENABLE                0x80000000
+#define DPERROR_Tx_ERROR_ON_SEC     0x00400000
+#define DPERROR_Tx_ERROR_ON_WRITE   0x10000000
+#define DPERROR_Rx_ERROR_ON_SEC     0x00000040
+#define DPERROR_Rx_ERROR_ON_WRITE   0x00001000
+#define DPERROR_STT                 0x80000000
+#define DPERROR_STR                 0x00008000
+
+#define MACCFG1_SOFT_RESET          0x80000000
+#define MACCFG1_LOOPBACK            0x00000100
+#define MACCFG1_RX_FLOW             0x00000020
+#define MACCFG1_TX_FLOW             0x00000010
+#define MACCFG1_TX_EN               0x00000001
+#define MACCFG1_RX_EN               0x00000004
+#define MACCFG1_RESET_RxMC          0x00080000
+#define MACCFG1_RESET_TxMC          0x00040000
+#define MACCFG1_RESET_RxFUN         0x00020000
+#define MACCFG1_RESET_TxFUN         0x00010000
+
+#define MACCFG2_NIBBLE_MODE         0x00000100
+#define MACCFG2_BYTE_MODE           0x00000200
+#define MACCFG2_PRE_AM_Rx_EN        0x00000080
+#define MACCFG2_PRE_AM_Tx_EN        0x00000040
+#define MACCFG2_HUGE_FRAME          0x00000020
+#define MACCFG2_LENGTH_CHECK        0x00000010
+#define MACCFG2_MAGIC_PACKET_EN     0x00000008
+#define MACCFG2_PAD_CRC_EN          0x00000004
+#define MACCFG2_CRC_EN              0x00000002
+#define MACCFG2_FULL_DUPLEX         0x00000001
+
+#define PREAMBLE_LENGTH_SHIFT       12
+
+#define IPGIFG_NON_BACK_TO_BACK_IPG_1_SHIFT    24
+#define IPGIFG_NON_BACK_TO_BACK_IPG_2_SHIFT    16
+#define IPGIFG_MIN_IFG_ENFORCEMENT_SHIFT        8
+
+#define IPGIFG_NON_BACK_TO_BACK_IPG_1    0x7F000000
+#define IPGIFG_NON_BACK_TO_BACK_IPG_2    0x007F0000
+#define IPGIFG_MIN_IFG_ENFORCEMENT       0x0000FF00
+#define IPGIFG_BACK_TO_BACK_IPG          0x0000007F
+
+#define HAFDUP_ALT_BEB                   0x00080000
+#define HAFDUP_BP_NO_BACKOFF             0x00040000
+#define HAFDUP_NO_BACKOFF                0x00020000
+#define HAFDUP_EXCESS_DEFER              0x00010000
+#define HAFDUP_COLLISION_WINDOW          0x000003ff
+
+#define HAFDUP_ALTERNATE_BEB_TRUNCATION_SHIFT    20
+#define HAFDUP_RETRANSMISSION_MAX_SHIFT          12
+#define HAFDUP_RETRANSMISSION_MAX       0x0000f000
+
+#define NUM_OF_HASH_REGS     8 /* Number of hash table registers */
+
+#define DEBUG_GET_FIFO_READ_INDEX       0x007f0000
+#define DEBUG_GET_FIFO_WRITE_INDEX      0x0000007f
+/* Pause Time Value Register  */
+#define PTV_PTE_SHIFT    16
+
+#define IEVENT_BABR    IMASK_BREN                  /* 0x80000000 */
+#define IEVENT_RXC     IMASK_RXCEN                 /* 0x40000000 */
+#define IEVENT_MSRO    IMASK_MSROEN                /* 0x04000000 */
+#define IEVENT_GTSC    IMASK_GTSCEN                /* 0x02000000 */
+#define IEVENT_BABT    IMASK_BTEN                  /* 0x01000000 */
+#define IEVENT_TXC     IMASK_TXCEN                 /* 0x00800000 */
+#define IEVENT_TXE     IMASK_TXEEN                 /* 0x00400000 */
+#define IEVENT_LC      IMASK_LCEN                  /* 0x00040000 */
+#define IEVENT_CRL     IMASK_CRLEN                 /* 0x00020000 */
+#define IEVENT_XFUN    IMASK_XFUNEN                /* 0x00010000 */
+#define IEVENT_ABRT    IMASK_ABRTEN                /* 0x00008000 */
+#define IEVENT_IFERR   IMASK_IFERREN               /* 0x00004000 */
+#define IEVENT_MAG     IMASK_MAGEN                 /* 0x00000800 */
+#define IEVENT_MMRD    IMASK_MMRDEN                /* 0x00000400 */
+#define IEVENT_MMWR    IMASK_MMWREN                /* 0x00000200 */
+#define IEVENT_GRSC    IMASK_GRSCEN                /* 0x00000100 */
+#define IEVENT_DPE     IMASK_TDPEEN                /* 0x00000002 */
+#define IEVENT_RDPE    IMASK_RDPEEN                /* 0x00000001 */
+
+#define IEVENT_ERRORS   (IEVENT_BABR | IMASK_RXCEN | IMASK_MSROEN | IMASK_BTEN | \
+                         IMASK_TXCEN | IMASK_TXEEN | IMASK_LCEN | IMASK_CRLEN | \
+                         IMASK_XFUNEN | IMASK_ABRTEN | IMASK_IFERREN | IMASK_MAGEN | \
+                         IMASK_MMRDEN | IMASK_MMWREN | IMASK_TDPEEN | IMASK_RDPEEN)
+
+#define     MASK22BIT   0x003FFFFF
+#define     MASK16BIT   0x0000FFFF
+#define     MASK12BIT   0x00000FFF
+#define     MASK8BIT    0x000000FF
+
+
+#ifdef __MWERKS__
+#pragma pack(push,1)
+#endif /*__MWERKS__ */
+#define MEM_MAP_START
+
+typedef _Packed struct
+{
+    uint32_t exact_match1; /* octets 1-4 */
+    uint32_t exact_match2; /* octets 5-6 */
+} _PackedType macRegs;
+
+typedef _Packed struct
+{
+    volatile uint32_t tsec_id1;             /* 0x000 ETSEC_ID register */
+    volatile uint32_t tsec_id2;             /* 0x004 ETSEC_ID2 register */
+    volatile uint32_t ievent;               /* 0x008 Interrupt event register */
+    volatile uint32_t imask;                /* 0x00C Interrupt mask register */
+    volatile uint32_t edis;                 /* 0x010 Error disabled register */
+    volatile uint32_t ecntrl;               /* 0x014 E control register */
+    volatile uint32_t ptv;                  /* 0x018 Pause time value register */
+    volatile uint32_t DTSEC_RESERVED1;      /* 0x01C TBIPATBI PHY address register */
+    volatile uint32_t tmr_ctrl;             /* 0x020 Time-stamp Control register */
+    volatile uint32_t tmr_pevent;           /* 0x024 Time-stamp event register */
+    volatile uint32_t tmr_pemask;           /* 0x028 Timer event mask register */
+    volatile uint32_t DTSEC_RESERVED2;      /* 0x02C */
+    volatile uint32_t iobistctl;            /* 0x030 IO BIST Control register */
+    volatile uint32_t DTSEC_RESERVED3[3];   /* 0x034 */
+
+    volatile uint32_t tctrl;                /* 0x040 Transmit control register */
+    volatile uint32_t DTSEC_RESERVED4[3];   /* 0x044-0x04C */
+    volatile uint32_t rctrl;                /* 0x050 Receive control register */
+    volatile uint32_t DTSEC_RESERVED5[11];  /* 0x054- 0x07C */
+
+    volatile uint32_t igaddr[8];            /* 0x080-0x09C Individual/group address registers 0-7 */
+    volatile uint32_t gaddr[8];             /* 0x0A0-0x0BC Group address registers 0-7 */
+    volatile uint32_t ETSEC_RESERVED6[16];  /* 0x0C0-0x0FC */
+
+    volatile uint32_t maccfg1;              /* 0x100 MAC configuration #1 */
+    volatile uint32_t maccfg2;              /* 0x104 MAC configuration #2 */
+    volatile uint32_t ipgifg;               /* 0x108 IPG/IFG */
+    volatile uint32_t hafdup;               /* 0x10C Half-duplex */
+    volatile uint32_t maxfrm;               /* 0x110 Maximum frame */
+    volatile uint32_t  DTSEC_RESERVED7[3];  /* 0x1140x11C register */
+    volatile uint32_t miimcfg;              /* 0x120 MII Mgmt:configuration */
+    volatile uint32_t miimcom;              /* 0x124 MII Mgmt:command */
+    volatile uint32_t miimadd;              /* 0x128 MII Mgmt:address */
+    volatile uint32_t miimcon;              /* 0x12C MII Mgmt:control 3 */
+    volatile uint32_t miimstat;             /* 0x130 MII Mgmt:status */
+    volatile uint32_t miimind;              /* 0x134 MII Mgmt:indicators */
+    volatile uint32_t ifctrl;               /* 0x138 MII Mgmt:interface control */
+    volatile uint32_t ifstat;               /* 0x13C Interface status */
+    volatile uint32_t macstnaddr1;          /* 0x140 Station Address,part 1 */
+    volatile uint32_t macstnaddr2;          /* 0x144 Station Address,part 2  */
+    volatile macRegs  macaddr[DTSEC_NUM_OF_PADDRS]; /* 0x148-0x1BC mac exact match addresses 1-15, parts 1-2 */
+    volatile uint32_t  DTSEC_RESERVED8[16];   /* 0x1C00x1FC register */
+
+    /*  RMON MIB REGISTERS  */
+    /*  TRANSMIT and RECEIVE COUNTERS   */
+
+    volatile uint32_t  tr64;            /* 0x200 transmit and receive 64 byte frame counter */
+    volatile uint32_t  tr127;           /* 0x204 transmit and receive 65 to 127 byte frame counter */
+    volatile uint32_t  tr255;           /* 0x208 transmit and receive 128 to 255 byte frame counter */
+    volatile uint32_t  tr511;           /* 0x20C transmit and receive 256 to 511 byte frame counter */
+    volatile uint32_t  tr1k;            /* 0x210 transmit and receive 512 to 1023 byte frame counter */
+    volatile uint32_t  trmax;           /* 0x214 transmit and receive 1024 to 1518 byte frame counter */
+    volatile uint32_t  trmgv;           /* 0x218 transmit and receive 1519 to 1522 byte good VLAN frame count */
+
+    /* RECEIVE COUNTERS */
+    volatile uint32_t  rbyt;            /* 0x21C receive byte counter */
+    volatile uint32_t  rpkt;            /* 0x220 receive packet counter */
+    volatile uint32_t  rfcs;            /* 0x224 receive FCS error counter */
+    volatile uint32_t  rmca;            /* 0x228 RMCA receive multicast packet counter */
+    volatile uint32_t  rbca;            /* 0x22C receive broadcast packet counter */
+    volatile uint32_t  rxcf;            /* 0x230 receive control frame packet counter */
+    volatile uint32_t  rxpf;            /* 0x234 receive PAUSE frame packet counter */
+    volatile uint32_t  rxuo;            /* 0x238 receive unknown OP code counter */
+    volatile uint32_t  raln;            /* 0x23C receive alignment error counter */
+    volatile uint32_t  rflr;            /* 0x240 receive frame length error counter */
+    volatile uint32_t  rcde;            /* 0x244 receive code error counter */
+    volatile uint32_t  rcse;            /* 0x248 receive carrier sense error counter */
+    volatile uint32_t  rund;            /* 0x24C receive undersize packet counter */
+    volatile uint32_t  rovr;            /* 0x250 receive oversize packet counter */
+    volatile uint32_t  rfrg;            /* 0x254 receive fragments counter */
+    volatile uint32_t  rjbr;            /* 0x258 receive jabber counter */
+    volatile uint32_t  rdrp;            /* 0x25C receive drop */
+
+    /* TRANSMIT COUNTERS */
+    volatile uint32_t  tbyt;            /* 0x260 transmit byte counter */
+    volatile uint32_t  tpkt;            /* 0x264 transmit packet counter */
+    volatile uint32_t  tmca;            /* 0x268 transmit multicast packet counter */
+    volatile uint32_t  tbca;            /* 0x26C transmit broadcast packet counter */
+    volatile uint32_t  txpf;            /* 0x270 transmit PAUSE control frame counter */
+    volatile uint32_t  tdfr;            /* 0x274 transmit deferral packet counter */
+    volatile uint32_t  tedf;            /* 0x278 transmit excessive deferral packet counter */
+    volatile uint32_t  tscl;            /* 0x27C transmit single collision packet counter */
+    volatile uint32_t  tmcl;            /* 0x280 transmit multiple collision packet counter */
+    volatile uint32_t  tlcl;            /* 0x284 transmit late collision packet counter */
+    volatile uint32_t  txcl;            /* 0x288 transmit excessive collision packet counter */
+    volatile uint32_t  tncl;            /* 0x28C transmit total collision counter */
+    volatile uint32_t  DTSEC_RESERVED9; /* 0x290 */
+    volatile uint32_t  tdrp;            /* 0x294 transmit drop frame counter */
+    volatile uint32_t  tjbr;            /* 0x298 transmit jabber frame counter */
+    volatile uint32_t  tfcs;            /* 0x29C transmit FCS error counter */
+    volatile uint32_t  txcf;            /* 0x2A0 transmit control frame counter */
+    volatile uint32_t  tovr;            /* 0x2A4 transmit oversize frame counter */
+    volatile uint32_t  tund;            /* 0x2A8 transmit undersize frame counter */
+    volatile uint32_t  tfrg;            /* 0x2AC transmit fragments frame counter */
+
+    /* GENERAL REGISTERS */
+    volatile uint32_t  car1;            /* 0x2B0 carry register one register* */
+    volatile uint32_t  car2;            /* 0x2B4 carry register two register* */
+    volatile uint32_t  cam1;            /* 0x2B8 carry register one mask register */
+    volatile uint32_t  cam2;            /* 0x2BC carry register two mask register */
+    volatile uint32_t  DTSEC_RESERVED10[16]; /* 0x2C0-0x2FC */
+
+    /* Debug and Factory Test Registers */
+    volatile uint32_t debug;            /* 0x300 DEBUGDebug Register */
+    volatile uint32_t dperror;          /* 0x304 DPERRORParity Error Register */
+    volatile uint32_t hwassert;         /* 0x308 HWASSERT */
+    volatile uint32_t RESERVED11;       /* 0x30C Reserved */
+    volatile uint32_t rx_fifo_ptr;      /* 0x310 RXFIFOPTRRx FIFO R/W Pointer Register */
+    volatile uint32_t rx_fifo_dath;     /* 0x314 RXFIFODATHRx FIFO Data Register */
+    volatile uint32_t rx_fifo_datl;     /* 0x318 RXFIFODATLRx FIFO Data Register */
+    volatile uint32_t rx_fifo_stat;     /* 0x31C RXFIFOSTATRx FIFO Status Register */
+    volatile uint32_t tx_fifo_ptr;      /* 0x320 TXFIFOPTRTx FIFO R/W Pointer Register */
+    volatile uint32_t tx_fifo_dath;     /* 0x324 TXFIFODATHRx FIFO Data Register */
+    volatile uint32_t tx_fifo_datl;     /* 0x328 TXFIFODATLRx FIFO Data Register */
+    volatile uint32_t tx_fifo_stat;     /* 0x32C TXFIFOSTATTx FIFO Status Register */
+    volatile uint32_t pkt_rcv_cnt;      /* 0x330 PKTRCVCNTNumber of packets accepted and written to Rx FIFO */
+    volatile uint32_t RESERVED12[3];    /* 0x334-0x33C Reserved */
+    volatile uint32_t tx_threshold;     /* 0x340 Transmit threshold; Number of entries (4 bytes units) before starting to transmit to the MAC */
+    volatile uint32_t tx_watermark_high;/* 0x344 Transmit watermark high; Number of entries (4 byte units) before de-asserting Ready to packet Interface */
+    volatile uint32_t rx_watermark_low; /* 0x348 Receive watermark low; Number of entries (4 byte units) before unloading to packet Interface */
+} _PackedType t_DtsecMemMap;
+
+#define MEM_MAP_END
+#ifdef __MWERKS__
+#pragma pack(pop)
+#endif /* __MWERKS__ */
+
+
+typedef struct {
+
+    uint32_t    errorDisabled;
+    bool        halfDuplex;
+    uint16_t    pauseTime;
+    uint16_t    pauseExtended;
+
+    bool        autoZeroCounters;
+    bool        statisticsEnable;
+    bool        promiscuousEnable;
+
+    bool        halfDulexFlowControlEn;
+    bool        txTimeStampEn;
+    bool        rxTimeStampEn;
+
+    uint8_t     packetAlignmentPadding;
+    bool        controlFrameAccept;
+    bool        groupHashExtend;
+    bool        broadcReject;
+    bool        rxShortFrame;
+    bool        exactMatch;
+
+    bool        debugMode;
+
+    bool        loopback;
+    bool        actOnRxPauseFrame;
+    bool        actOnTxPauseFrame;
+
+    uint8_t     nonBackToBackIpg1;
+    uint8_t     nonBackToBackIpg2;
+    uint8_t     minIfgEnforcement;
+    uint8_t     backToBackIpg;
+
+    uint8_t     preambleLength;
+    bool        preambleRxEn;
+    bool        preambleTxEn;
+    bool        hugeFramesEnable;
+    bool        lengthCheckEnable;
+    bool        magicPacketEnable;
+    bool        padAndCrcEnable;
+    bool        crcEnable;
+
+    bool        alternateBackoffEnable;
+    uint8_t     alternateBackoffVal;
+    bool        backPressureNoBackoff;
+    bool        noBackoff;
+    bool        excessDefer;
+    uint8_t     maxRetransmission;
+    uint16_t    collisionWindow;
+
+    uint16_t    maxFrameLength;
+
+    uint32_t    cam1;
+    uint32_t    cam2;
+
+    uint8_t     fifoTxThr;
+    uint8_t     fifoTxWatermarkH;
+    uint8_t     fifoRxWatermarkL;
+
+    uint32_t    imask;
+} t_DtsecDriverParam;
+
+typedef struct {
+    t_FmMacControllerDriver     fmMacControllerDriver;
+    t_Handle                    h_App;            /**< Handle to the upper layer application              */
+    t_DtsecMemMap               *p_MemMap;        /**< pointer to dTSEC memory mapped registers.          */
+    t_MiiAccessMemMap           *p_MiiMemMap;     /**< pointer to dTSEC MII memory mapped registers.          */
+    uint64_t                    addr;             /**< MAC address of device;                             */
+    e_EnetMode                  enetMode;         /**< Ethernet physical interface  */
+    t_FmMacExceptionCallback    *f_Exceptions;
+    bool                        indAddrRegUsed[DTSEC_NUM_OF_PADDRS]; /**< Whether a particular individual address recognition register is being used */
+    uint64_t                    paddr[DTSEC_NUM_OF_PADDRS]; /**< MAC address for particular individual address recognition register */
+    uint8_t                     numOfIndAddrInRegs; /**< Number of individual addresses in registers for this station. */
+    bool                        debugMode;
+    bool                        halfDuplex;
+    t_FmMacStatistics           macStatistics;
+    t_EthHash                   *p_MulticastAddrHash;      /* pointer to driver's global address hash table  */
+    t_EthHash                   *p_UnicastAddrHash;    /* pointer to driver's individual address hash table  */
+    uint8_t                     macId;
+    t_DtsecDriverParam          *p_DtsecDriverParam;
+} t_Dtsec;
+
+t_Error MII_WritePhyReg(t_Handle h_Dtsec, uint8_t phyAddr, uint8_t reg, uint16_t data);
+t_Error MII_ReadPhyReg(t_Handle  h_Dtsec, uint8_t phyAddr, uint8_t reg, uint16_t *p_Data);
+
+
+#endif /* __DTSEC_H */
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/dtsec_mii_acc.c b/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/dtsec_mii_acc.c
new file mode 100644
index 0000000..98a0ba6
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/dtsec_mii_acc.c
@@ -0,0 +1,127 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/******************************************************************************
+ @File          dtsec_mii_acc.c
+
+ @Description   FM dtsec MII register access MAC ...
+*//***************************************************************************/
+
+#include "error_ext.h"
+#include "std_ext.h"
+#include "fm_mac.h"
+#include "dtsec.h"
+
+
+
+/*****************************************************************************/
+t_Error MII_WritePhyReg(t_Handle h_Dtsec,
+                        uint8_t     phyAddr,
+                        uint8_t     reg,
+                        uint16_t    data)
+{
+    t_Dtsec             *p_Dtsec = (t_Dtsec *)h_Dtsec;
+    t_MiiAccessMemMap   *p_MiiAccess;
+    uint32_t            tmpReg;
+
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec->p_MiiMemMap, E_INVALID_HANDLE);
+
+    p_MiiAccess = p_Dtsec->p_MiiMemMap;
+
+    /* Stop the MII management read cycle */
+    WRITE_UINT32(p_MiiAccess->miimcom, 0);
+    /* Dummy read to make sure MIIMCOM is written */
+    tmpReg = GET_UINT32(p_MiiAccess->miimcom);
+
+    /* Setting up MII Management Address Register */
+    tmpReg = (uint32_t)((phyAddr << MIIMADD_PHY_ADDR_SHIFT) | reg);
+    WRITE_UINT32(p_MiiAccess->miimadd, tmpReg);
+
+    /* Setting up MII Management Control Register with data */
+    WRITE_UINT32(p_MiiAccess->miimcon, (uint32_t)data);
+    /* Dummy read to make sure MIIMCON is written */
+    tmpReg = GET_UINT32(p_MiiAccess->miimcon);
+
+    /* Wait till MII management write is complete */
+    while ((GET_UINT32(p_MiiAccess->miimind)) & MIIMIND_BUSY) ;
+
+    return E_OK;
+}
+
+
+/*****************************************************************************/
+t_Error MII_ReadPhyReg(t_Handle h_Dtsec,
+                   uint8_t  phyAddr,
+                   uint8_t  reg,
+                   uint16_t *p_Data)
+{
+    t_Dtsec             *p_Dtsec = (t_Dtsec *)h_Dtsec;
+    t_MiiAccessMemMap   *p_MiiAccess;
+    uint32_t            tmpReg;
+
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec->p_MiiMemMap, E_INVALID_HANDLE);
+
+    p_MiiAccess = p_Dtsec->p_MiiMemMap;
+
+    /* Setting up the MII Management Address Register */
+    tmpReg = (uint32_t)((phyAddr << MIIMADD_PHY_ADDR_SHIFT) | reg);
+    WRITE_UINT32(p_MiiAccess->miimadd, tmpReg);
+
+    /* Perform an MII management read cycle */
+    WRITE_UINT32(p_MiiAccess->miimcom, MIIMCOM_READ_CYCLE);
+    /* Dummy read to make sure MIIMCOM is written */
+    tmpReg = GET_UINT32(p_MiiAccess->miimcom);
+
+    /* Wait till MII management write is complete */
+    while ((GET_UINT32(p_MiiAccess->miimind)) & MIIMIND_BUSY) ;
+
+    /* Read MII management status  */
+    *p_Data = (uint16_t)GET_UINT32(p_MiiAccess->miimstat);
+
+    WRITE_UINT32(p_MiiAccess->miimcom, 0);
+    /* Dummy read to make sure MIIMCOM is written */
+    tmpReg = GET_UINT32(p_MiiAccess->miimcom);
+
+    if (*p_Data == 0xffff)
+    {
+        REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("Read wrong data: phyAddr"));
+/*
+        DBG(INFO, ("Read wrong data: phyAddr %d, reg %d, base %08x",
+            phyAddr, reg, (long)p_MiiAccess));
+*/
+    return E_INVALID_VALUE;
+    }
+
+    return E_OK;
+}
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/dtsec_mii_acc.h b/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/dtsec_mii_acc.h
new file mode 100644
index 0000000..c952a59
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/dtsec_mii_acc.h
@@ -0,0 +1,66 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __MII_ACC_H
+#define __MII_ACC_H
+
+/* #define __ERR_MODULE__ MODULE_MII */
+
+/* MII Management Configuration Register */
+#define MIIMCFG_RESET_MGMT          0x80000000
+#define MIIMCFG_MGMT_CLOCK_SELECT   0x00000007
+
+/* MII  Management Command Register */
+#define MIIMCOM_READ_CYCLE          0x00000001
+#define MIIMCOM_SCAN_CYCLE          0x00000002
+
+/* MII  Management Address Register */
+#define MIIMADD_PHY_ADDR_SHIFT      8
+
+/* MII Management Indicator Register */
+#define MIIMIND_BUSY                0x00000001
+
+/*----------------------------------------------------*/
+/* MII Configuration Control Memory Map Registers     */
+/*----------------------------------------------------*/
+typedef _Packed struct t_MiiAccessMemMap
+{
+    volatile uint32_t miimcfg;    /* MII Mgmt:configuration */
+    volatile uint32_t miimcom;    /* MII Mgmt:command       */
+    volatile uint32_t miimadd;    /* MII Mgmt:address       */
+    volatile uint32_t miimcon;    /* MII Mgmt:control 3     */
+    volatile uint32_t miimstat;   /* MII Mgmt:status        */
+    volatile uint32_t miimind;    /* MII Mgmt:indicators    */
+} _PackedType t_MiiAccessMemMap ;
+
+
+#endif /* __MII_ACC_H */
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.c b/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.c
new file mode 100644
index 0000000..34d39ca
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.c
@@ -0,0 +1,483 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/******************************************************************************
+ @File          fm_mac.c
+
+ @Description   FM MAC ...
+*//***************************************************************************/
+#include "std_ext.h"
+#include "string_ext.h"
+#include "sprint_ext.h"
+#include "error_ext.h"
+
+#include "fm_mac.h"
+#include "fm_ext.h"
+
+
+/* ........................................................................... */
+
+t_Handle FM_MAC_Config (t_FmMacParams *p_FmMacParam)
+{
+    t_FmMacControllerDriver *p_FmMacControllerDriver;
+
+    SANITY_CHECK_RETURN_VALUE(p_FmMacParam, E_INVALID_HANDLE, NULL);
+
+    if(ENET_SPEED_FROM_MODE(p_FmMacParam->enetMode) < e_ENET_SPEED_10000)
+        p_FmMacControllerDriver = (t_FmMacControllerDriver *)DTSEC_Config(p_FmMacParam);
+    else
+       p_FmMacControllerDriver = (t_FmMacControllerDriver *)TGEC_Config(p_FmMacParam);
+
+    if (!p_FmMacControllerDriver)
+        return NULL;
+
+    p_FmMacControllerDriver->h_Fm = p_FmMacParam->h_Fm;
+
+    p_FmMacControllerDriver->enetMode = p_FmMacParam->enetMode;
+    p_FmMacControllerDriver->macId    = p_FmMacParam->macId;
+
+    return (t_Handle)p_FmMacControllerDriver;
+}
+
+/* ........................................................................... */
+
+t_Error FM_MAC_Init (t_Handle h_FmMac)
+{
+    t_FmMacControllerDriver *p_FmMacControllerDriver = (t_FmMacControllerDriver *)h_FmMac;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacControllerDriver, E_INVALID_HANDLE);
+
+    if (p_FmMacControllerDriver->f_FM_MAC_Init)
+        return p_FmMacControllerDriver->f_FM_MAC_Init(h_FmMac);
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
+/* ........................................................................... */
+
+t_Error FM_MAC_Free (t_Handle h_FmMac)
+{
+    t_FmMacControllerDriver *p_FmMacControllerDriver = (t_FmMacControllerDriver *)h_FmMac;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacControllerDriver, E_INVALID_HANDLE);
+
+    if (p_FmMacControllerDriver->f_FM_MAC_Free)
+        return p_FmMacControllerDriver->f_FM_MAC_Free(h_FmMac);
+
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
+/* ........................................................................... */
+
+t_Error FM_MAC_ConfigStatistics (t_Handle h_FmMac, bool newVal)
+{
+    t_FmMacControllerDriver *p_FmMacControllerDriver = (t_FmMacControllerDriver *)h_FmMac;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacControllerDriver, E_INVALID_HANDLE);
+
+    if (p_FmMacControllerDriver->f_FM_MAC_ConfigStatistics)
+        return p_FmMacControllerDriver->f_FM_MAC_ConfigStatistics(h_FmMac, newVal);
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
+
+/* ........................................................................... */
+
+t_Error FM_MAC_ConfigLoopback (t_Handle h_FmMac, bool newVal)
+{
+    t_FmMacControllerDriver *p_FmMacControllerDriver = (t_FmMacControllerDriver *)h_FmMac;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacControllerDriver, E_INVALID_HANDLE);
+
+    if (p_FmMacControllerDriver->f_FM_MAC_ConfigLoopback)
+        return p_FmMacControllerDriver->f_FM_MAC_ConfigLoopback(h_FmMac, newVal);
+
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
+/* ........................................................................... */
+
+t_Error FM_MAC_ConfigMaxFrameLength (t_Handle h_FmMac, uint16_t newVal)
+{
+    t_FmMacControllerDriver *p_FmMacControllerDriver = (t_FmMacControllerDriver *)h_FmMac;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacControllerDriver, E_INVALID_HANDLE);
+
+    if (p_FmMacControllerDriver->f_FM_MAC_ConfigMaxFrameLength)
+        return p_FmMacControllerDriver->f_FM_MAC_ConfigMaxFrameLength(h_FmMac, newVal);
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
+/* ........................................................................... */
+
+t_Error FM_MAC_ConfigWan (t_Handle h_FmMac, bool flag)
+{
+   t_FmMacControllerDriver *p_FmMacControllerDriver = (t_FmMacControllerDriver *)h_FmMac;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacControllerDriver, E_INVALID_HANDLE);
+
+    if (p_FmMacControllerDriver->f_FM_MAC_ConfigWan)
+        return p_FmMacControllerDriver->f_FM_MAC_ConfigWan(h_FmMac, flag);
+
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
+/* ........................................................................... */
+
+t_Error FM_MAC_ConfigPadAndCrc (t_Handle h_FmMac, bool newVal)
+{
+    t_FmMacControllerDriver *p_FmMacControllerDriver = (t_FmMacControllerDriver *)h_FmMac;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacControllerDriver, E_INVALID_HANDLE);
+
+    if (p_FmMacControllerDriver->f_FM_MAC_ConfigPadAndCrc)
+        return p_FmMacControllerDriver->f_FM_MAC_ConfigPadAndCrc(h_FmMac, newVal);
+
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
+/* ........................................................................... */
+
+t_Error FM_MAC_ConfigHalfDuplex (t_Handle h_FmMac, bool newVal)
+{
+    t_FmMacControllerDriver *p_FmMacControllerDriver = (t_FmMacControllerDriver *)h_FmMac;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacControllerDriver, E_INVALID_HANDLE);
+
+    if (p_FmMacControllerDriver->f_FM_MAC_ConfigHalfDuplex)
+        return p_FmMacControllerDriver->f_FM_MAC_ConfigHalfDuplex(h_FmMac,newVal);
+
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
+/* ........................................................................... */
+
+t_Error FM_MAC_ConfigHugeFrames (t_Handle h_FmMac, bool newVal)
+{
+    t_FmMacControllerDriver *p_FmMacControllerDriver = (t_FmMacControllerDriver *)h_FmMac;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacControllerDriver, E_INVALID_HANDLE);
+
+    if (p_FmMacControllerDriver->f_FM_MAC_ConfigHugeFrames)
+        return p_FmMacControllerDriver->f_FM_MAC_ConfigHugeFrames(h_FmMac, newVal);
+
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
+/* ........................................................................... */
+
+/*****************************************************************************/
+/* Run Time Control                                                          */
+/*****************************************************************************/
+
+/* ........................................................................... */
+
+t_Error FM_MAC_Enable  (t_Handle h_FmMac,  e_CommMode mode)
+{
+    t_FmMacControllerDriver *p_FmMacControllerDriver = (t_FmMacControllerDriver *)h_FmMac;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacControllerDriver, E_INVALID_HANDLE);
+
+    if (p_FmMacControllerDriver->f_FM_MAC_Enable)
+        return p_FmMacControllerDriver->f_FM_MAC_Enable(h_FmMac, mode);
+
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
+/* ........................................................................... */
+
+t_Error FM_MAC_Disable (t_Handle h_FmMac, e_CommMode mode)
+{
+    t_FmMacControllerDriver *p_FmMacControllerDriver = (t_FmMacControllerDriver *)h_FmMac;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacControllerDriver, E_INVALID_HANDLE);
+
+    if (p_FmMacControllerDriver->f_FM_MAC_Disable)
+        return p_FmMacControllerDriver->f_FM_MAC_Disable(h_FmMac, mode);
+
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
+/* ........................................................................... */
+
+t_Error FM_MAC_Restart (t_Handle h_FmMac, e_CommMode mode)
+{
+    t_FmMacControllerDriver *p_FmMacControllerDriver = (t_FmMacControllerDriver *)h_FmMac;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacControllerDriver, E_INVALID_HANDLE);
+
+    if (p_FmMacControllerDriver->f_FM_MAC_Restart)
+        return p_FmMacControllerDriver->f_FM_MAC_Restart(h_FmMac, mode);
+
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
+/* ........................................................................... */
+
+t_Error FM_MAC_Reset (t_Handle h_FmMac, bool wait)
+{
+    t_FmMacControllerDriver *p_FmMacControllerDriver = (t_FmMacControllerDriver *)h_FmMac;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacControllerDriver, E_INVALID_HANDLE);
+
+    if  (!wait)
+        RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("reset must blocking!!!"));
+
+    return FmResetMac(p_FmMacControllerDriver->h_Fm,
+                      ((ENET_SPEED_FROM_MODE(p_FmMacControllerDriver->enetMode) < e_ENET_SPEED_10000) ? e_FM_MAC_1G : e_FM_MAC_10G),
+                      p_FmMacControllerDriver->macId);
+}
+
+/* ........................................................................... */
+
+t_Error FM_MAC_TxMacPause (t_Handle h_FmMac, uint16_t pauseTime, uint16_t exPauseTime)
+{
+    t_FmMacControllerDriver *p_FmMacControllerDriver = (t_FmMacControllerDriver *)h_FmMac;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacControllerDriver, E_INVALID_HANDLE);
+
+    if (p_FmMacControllerDriver->f_FM_MAC_TxMacPause)
+        return p_FmMacControllerDriver->f_FM_MAC_TxMacPause(h_FmMac, pauseTime, exPauseTime);
+
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
+/* ........................................................................... */
+
+t_Error FM_MAC_ResetCounters (t_Handle h_FmMac)
+{
+    t_FmMacControllerDriver *p_FmMacControllerDriver = (t_FmMacControllerDriver *)h_FmMac;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacControllerDriver, E_INVALID_HANDLE);
+
+    if (p_FmMacControllerDriver->f_FM_MAC_ResetCounters)
+        return p_FmMacControllerDriver->f_FM_MAC_ResetCounters(h_FmMac);
+
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
+/* ........................................................................... */
+
+t_Error FM_MAC_SetExceptions(t_Handle h_FmMac, e_FmMacExceptions ex)
+{
+   t_FmMacControllerDriver *p_FmMacControllerDriver = (t_FmMacControllerDriver *)h_FmMac;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacControllerDriver, E_INVALID_HANDLE);
+
+    if (p_FmMacControllerDriver->f_FM_MAC_SetExceptions)
+        return p_FmMacControllerDriver->f_FM_MAC_SetExceptions(h_FmMac, ex);
+
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
+/* ........................................................................... */
+
+t_Error FM_MAC_GetStatistics (t_Handle h_FmMac, t_FmMacStatistics *p_Statistics)
+{
+    t_FmMacControllerDriver *p_FmMacControllerDriver = (t_FmMacControllerDriver *)h_FmMac;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacControllerDriver, E_INVALID_HANDLE);
+
+    if (p_FmMacControllerDriver->f_FM_MAC_GetStatistics)
+        return p_FmMacControllerDriver->f_FM_MAC_GetStatistics(h_FmMac, p_Statistics);
+
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
+/* ........................................................................... */
+
+t_Error FM_MAC_ModifyMacAddr (t_Handle h_FmMac, t_EnetAddr *p_EnetAddr)
+{
+    t_FmMacControllerDriver *p_FmMacControllerDriver = (t_FmMacControllerDriver *)h_FmMac;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacControllerDriver, E_INVALID_HANDLE);
+
+    if (p_FmMacControllerDriver->f_FM_MAC_ModifyMacAddr)
+        return p_FmMacControllerDriver->f_FM_MAC_ModifyMacAddr(h_FmMac, p_EnetAddr);
+
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
+/* ........................................................................... */
+
+t_Error FM_MAC_AddHashMacAddr (t_Handle h_FmMac, t_EnetAddr *p_EnetAddr)
+{
+    t_FmMacControllerDriver *p_FmMacControllerDriver = (t_FmMacControllerDriver *)h_FmMac;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacControllerDriver, E_INVALID_HANDLE);
+
+    if (p_FmMacControllerDriver->f_FM_MAC_AddHashMacAddr)
+        return p_FmMacControllerDriver->f_FM_MAC_AddHashMacAddr(h_FmMac, p_EnetAddr);
+
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
+/* ........................................................................... */
+
+t_Error FM_MAC_RemoveHashMacAddr (t_Handle h_FmMac, t_EnetAddr *p_EnetAddr)
+{
+    t_FmMacControllerDriver *p_FmMacControllerDriver = (t_FmMacControllerDriver *)h_FmMac;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacControllerDriver, E_INVALID_HANDLE);
+
+    if (p_FmMacControllerDriver->f_FM_MAC_RemoveHashMacAddr)
+        return p_FmMacControllerDriver->f_FM_MAC_RemoveHashMacAddr(h_FmMac, p_EnetAddr);
+
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
+/* ........................................................................... */
+
+t_Error FM_MAC_AddExactMatchMacAddr (t_Handle h_FmMac, t_EnetAddr *p_EnetAddr)
+{
+    t_FmMacControllerDriver *p_FmMacControllerDriver = (t_FmMacControllerDriver *)h_FmMac;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacControllerDriver, E_INVALID_HANDLE);
+
+    if (p_FmMacControllerDriver->f_FM_MAC_AddExactMatchMacAddr)
+        return p_FmMacControllerDriver->f_FM_MAC_AddExactMatchMacAddr(h_FmMac, p_EnetAddr);
+
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
+/* ........................................................................... */
+
+t_Error FM_MAC_RemovelExactMatchMacAddr (t_Handle h_FmMac, t_EnetAddr *p_EnetAddr)
+{
+    t_FmMacControllerDriver *p_FmMacControllerDriver = (t_FmMacControllerDriver *)h_FmMac;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacControllerDriver, E_INVALID_HANDLE);
+
+    if (p_FmMacControllerDriver->f_FM_MAC_RemovelExactMatchMacAddr)
+        return p_FmMacControllerDriver->f_FM_MAC_RemovelExactMatchMacAddr(h_FmMac, p_EnetAddr);
+
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
+/* ........................................................................... */
+
+t_Error FM_MAC_GetVesrion (t_Handle h_FmMac, uint32_t *macVresion)
+{
+    t_FmMacControllerDriver *p_FmMacControllerDriver = (t_FmMacControllerDriver *)h_FmMac;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacControllerDriver, E_INVALID_HANDLE);
+
+    if (p_FmMacControllerDriver->f_FM_MAC_GetVersion)
+        return p_FmMacControllerDriver->f_FM_MAC_GetVersion(h_FmMac, macVresion);
+
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+
+}
+
+/* ........................................................................... */
+
+t_Error FM_MAC_GetId (t_Handle h_FmMac, uint32_t *macId)
+{
+    t_FmMacControllerDriver *p_FmMacControllerDriver = (t_FmMacControllerDriver *)h_FmMac;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacControllerDriver, E_INVALID_HANDLE);
+
+    if (p_FmMacControllerDriver->f_FM_MAC_GetId)
+        return p_FmMacControllerDriver->f_FM_MAC_GetId(h_FmMac, macId);
+
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
+/* ........................................................................... */
+
+t_Error FM_MAC_SetPromiscuous (t_Handle h_FmMac, bool newVal)
+{
+    t_FmMacControllerDriver *p_FmMacControllerDriver = (t_FmMacControllerDriver *)h_FmMac;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacControllerDriver, E_INVALID_HANDLE);
+
+    if (p_FmMacControllerDriver->f_FM_MAC_SetPromiscuous)
+        return p_FmMacControllerDriver->f_FM_MAC_SetPromiscuous(h_FmMac, newVal);
+
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
+/* ........................................................................... */
+
+t_Error FM_MAC_AdjustLink(t_Handle h_FmMac, e_EnetSpeed speed, bool fullDuplex)
+{
+    t_FmMacControllerDriver *p_FmMacControllerDriver = (t_FmMacControllerDriver *)h_FmMac;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacControllerDriver, E_INVALID_HANDLE);
+
+    if (p_FmMacControllerDriver->f_FM_MAC_AdjustLink)
+        return p_FmMacControllerDriver->f_FM_MAC_AdjustLink(h_FmMac, speed, fullDuplex);
+
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
+/* ........................................................................... */
+
+t_Error FM_MAC_MII_WritePhyReg (t_Handle h_FmMac, uint8_t phyAddr, uint8_t reg, uint16_t data)
+{
+    t_FmMacControllerDriver *p_FmMacControllerDriver = (t_FmMacControllerDriver *)h_FmMac;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacControllerDriver, E_INVALID_HANDLE);
+
+    if (p_FmMacControllerDriver->f_FM_MAC_MII_WritePhyReg)
+        return p_FmMacControllerDriver->f_FM_MAC_MII_WritePhyReg(h_FmMac, phyAddr, reg, data);
+
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
+/* ........................................................................... */
+
+t_Error FM_MAC_MII_ReadPhyReg(t_Handle h_FmMac,  uint8_t phyAddr, uint8_t reg, uint16_t *p_Data)
+{
+    t_FmMacControllerDriver *p_FmMacControllerDriver = (t_FmMacControllerDriver *)h_FmMac;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacControllerDriver, E_INVALID_HANDLE);
+
+    if (p_FmMacControllerDriver->f_FM_MAC_MII_ReadPhyReg)
+        return p_FmMacControllerDriver->f_FM_MAC_MII_ReadPhyReg(h_FmMac, phyAddr, reg, p_Data);
+
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
+
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+/*****************************************************************************/
+t_Error FM_MAC_DumpRegs(t_Handle h_FmMac)
+{
+    t_FmMacControllerDriver *p_FmMacControllerDriver = (t_FmMacControllerDriver *)h_FmMac;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacControllerDriver, E_INVALID_HANDLE);
+
+    if (p_FmMacControllerDriver->f_FM_MAC_DumpRegs)
+         return p_FmMacControllerDriver->f_FM_MAC_DumpRegs(h_FmMac);
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+#endif /* (defined(DEBUG_ERRORS) && ... */
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.h b/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.h
new file mode 100644
index 0000000..16c26fe
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.h
@@ -0,0 +1,180 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/******************************************************************************
+ @File          fm_mac.h
+
+ @Description   FM MAC ...
+*//***************************************************************************/
+#ifndef __FM_MAC_H
+#define __FM_MAC_H
+
+#include "std_ext.h"
+#include "error_ext.h"
+#include "list_ext.h"
+#include "fm_common.h"
+#include "fm_mac_ext.h"
+
+
+typedef struct
+{
+    t_Error (*f_FM_MAC_Init) (t_Handle h_FmMac);
+    t_Error (*f_FM_MAC_Free) (t_Handle h_FmMac);
+
+    t_Error (*f_FM_MAC_ConfigStatistics) (t_Handle h_FmMac, bool newVal);
+    t_Error (*f_FM_MAC_ConfigLoopback) (t_Handle h_FmMac, bool newVal);
+    t_Error (*f_FM_MAC_ConfigMaxFrameLength) (t_Handle h_FmMac, uint16_t newVal);
+    t_Error (*f_FM_MAC_ConfigWan) (t_Handle h_FmMac, bool flag);
+    t_Error (*f_FM_MAC_ConfigPadAndCrc) (t_Handle h_FmMac, bool newVal);
+    t_Error (*f_FM_MAC_ConfigHalfDuplex) (t_Handle h_FmMac, bool newVal);
+    t_Error (*f_FM_MAC_ConfigHugeFrames) (t_Handle h_FmMac, bool newVal);
+
+    t_Error (*f_FM_MAC_SetExceptions) (t_Handle h_FmMac, e_FmMacExceptions ex);
+
+    t_Error (*f_FM_MAC_Enable)  (t_Handle h_FmMac,  e_CommMode mode);
+    t_Error (*f_FM_MAC_Disable) (t_Handle h_FmMac, e_CommMode mode);
+    t_Error (*f_FM_MAC_Restart) (t_Handle h_FmMac, e_CommMode mode);
+    t_Error (*f_FM_MAC_Reset)   (t_Handle h_FmMac, bool wait);
+
+    t_Error (*f_FM_MAC_TxMacPause) (t_Handle h_FmMac, uint16_t pauseTime, uint16_t exPauseTime);
+
+    t_Error (*f_FM_MAC_ResetCounters) (t_Handle h_FmMac);
+    t_Error (*f_FM_MAC_GetStatistics) (t_Handle h_FmMac, t_FmMacStatistics *p_Statistics);
+
+    t_Error (*f_FM_MAC_ModifyMacAddr) (t_Handle h_FmMac, t_EnetAddr *p_EnetAddr);
+    t_Error (*f_FM_MAC_AddHashMacAddr) (t_Handle h_FmMac, t_EnetAddr *p_EnetAddr);
+    t_Error (*f_FM_MAC_RemoveHashMacAddr) (t_Handle h_FmMac, t_EnetAddr *p_EnetAddr);
+    t_Error (*f_FM_MAC_AddExactMatchMacAddr) (t_Handle h_FmMac, t_EnetAddr *p_EnetAddr);
+    t_Error (*f_FM_MAC_RemovelExactMatchMacAddr) (t_Handle h_FmMac, t_EnetAddr *p_EnetAddr);
+
+    t_Error (*f_FM_MAC_SetPromiscuous) (t_Handle h_FmMac, bool newVal);
+    t_Error (*f_FM_MAC_AdjustLink)     (t_Handle h_FmMac, e_EnetSpeed speed, bool fullDuplex);
+
+    t_Error (*f_FM_MAC_GetId) (t_Handle h_FmMac, uint32_t *macId);
+
+    t_Error (*f_FM_MAC_GetVersion) (t_Handle h_FmMac, uint32_t *macVersion);
+
+    t_Error (*f_FM_MAC_MII_WritePhyReg)(t_Handle h_FmMac, uint8_t phyAddr, uint8_t reg, uint16_t data);
+    t_Error (*f_FM_MAC_MII_ReadPhyReg)(t_Handle h_FmMac,  uint8_t phyAddr, uint8_t reg, uint16_t *p_Data);
+
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+    t_Error (*f_FM_MAC_DumpRegs) (t_Handle h_FmMac);
+#endif /* (defined(DEBUG_ERRORS) && ... */
+
+    t_Handle        h_Fm;
+    e_EnetMode      enetMode;
+    uint8_t         macId;
+} t_FmMacControllerDriver;
+
+typedef struct {
+    uint64_t addr;      /* Ethernet Address  */
+    t_List   node;
+} t_EthHashEntry;
+#define ETH_HASH_ENTRY_OBJ(ptr) LIST_OBJECT(ptr, t_EthHashEntry, node)
+
+typedef struct {
+    uint16_t    size;
+    t_List      *p_Lsts;
+} t_EthHash;
+
+t_Handle  DTSEC_Config(t_FmMacParams *p_FmMacParam);
+t_Handle  TGEC_Config(t_FmMacParams *p_FmMacParams);
+
+/* ........................................................................... */
+
+static __inline__ t_EthHashEntry *DequeueAddrFromHashEntry(t_List *p_AddrLst)
+{
+   t_EthHashEntry *p_HashEntry = NULL;
+    if (!LIST_IsEmpty(p_AddrLst))
+    {
+        p_HashEntry = ETH_HASH_ENTRY_OBJ(p_AddrLst->p_Next);
+        LIST_DelAndInit(&p_HashEntry->node);
+    }
+    return p_HashEntry;
+}
+
+/* ........................................................................... */
+
+static __inline__ void FreeHashTable(t_EthHash *p_Hash)
+{
+    t_EthHashEntry  *p_HashEntry;
+    int             i = 0;
+
+    if (!p_Hash || !p_Hash->p_Lsts)
+        return;
+
+    for(i=0; i<p_Hash->size; i++)
+    {
+        p_HashEntry = DequeueAddrFromHashEntry(&p_Hash->p_Lsts[i]);
+        while (p_HashEntry)
+        {
+            XX_Free(p_HashEntry);
+            p_HashEntry = DequeueAddrFromHashEntry(&p_Hash->p_Lsts[i]);
+        }
+    }
+
+    XX_Free(p_Hash->p_Lsts);
+    XX_Free(p_Hash);
+}
+
+/* ........................................................................... */
+
+static __inline__ t_EthHash * AllocHashTable(uint16_t size)
+{
+    uint32_t    i;
+    t_EthHash *p_Hash;
+
+    /* Allocate address hash table */
+    p_Hash = (t_EthHash *)XX_Malloc(size*sizeof(t_EthHash *));
+    if (!p_Hash)
+    {
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("Address hash table"));
+        return NULL;
+    }
+    p_Hash->size = size;
+
+    p_Hash->p_Lsts = (t_List *)XX_Malloc(p_Hash->size*sizeof(t_List));
+    if (!p_Hash->p_Lsts)
+    {
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("Address hash table"));
+        XX_Free(p_Hash);
+        return NULL;
+    }
+
+    for(i=0 ; i<p_Hash->size; i++)
+        INIT_LIST(&p_Hash->p_Lsts[i]);
+
+    return p_Hash;
+}
+
+
+#endif /* __FM_MAC_H */
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/tgec.c b/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/tgec.c
new file mode 100644
index 0000000..34bcb06
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/tgec.c
@@ -0,0 +1,930 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/******************************************************************************
+ @File          tgec.c
+
+ @Description   FM 10G MAC ...
+*//***************************************************************************/
+
+#include "std_ext.h"
+#include "string_ext.h"
+#include "error_ext.h"
+#include "xx_ext.h"
+#include "endian_ext.h"
+#include "crc_mac_addr_ext.h"
+#include "debug_ext.h"
+
+#include "tgec.h"
+
+
+/*****************************************************************************/
+/*                      Internal routines                                    */
+/*****************************************************************************/
+
+static t_Error CheckInitParameters(t_Tgec    *p_Tgec)
+{
+    if(ENET_SPEED_FROM_MODE(p_Tgec->enetMode) < e_ENET_SPEED_10000)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Ethernet 10G MAC driver only support 10G speed"));
+    if(p_Tgec->macId >= FM_MAX_NUM_OF_10G_MACS)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("macId of 10 G can not be greater than 0"));
+    if(p_Tgec->addr == 0)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Ethernet 10G MAC Must have a valid MAC Address"));
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static void SetDefaultParam(t_TgecDriverParam *p_TgecDriverParam)
+{
+    p_TgecDriverParam->wanModeEnable            = DEFAULT_wanModeEnable;
+    p_TgecDriverParam->promiscuousModeEnable    = DEFAULT_promiscuousModeEnable;
+    p_TgecDriverParam->padRemovalEnable         = DEFAULT_padRemovalEnable;
+    p_TgecDriverParam->crcForwardEnable         = DEFAULT_crcForwardEnable;
+    p_TgecDriverParam->pauseForwardEnable       = DEFAULT_pauseForwardEnable;
+    p_TgecDriverParam->pauseIgnore              = DEFAULT_pauseIgnore;
+    p_TgecDriverParam->txAddrInsEnable          = DEFAULT_txAddrInsEnable;
+
+    p_TgecDriverParam->loopbackEnable           = DEFAULT_loopbackEnable;
+    p_TgecDriverParam->cmdFrameEnable           = DEFAULT_cmdFrameEnable;
+    p_TgecDriverParam->rxErrorDiscard           = DEFAULT_rxErrorDiscard;
+    p_TgecDriverParam->phyTxenaOn               = DEFAULT_phyTxenaOn;
+    p_TgecDriverParam->sendIdleEnable           = DEFAULT_sendIdleEnable;
+    p_TgecDriverParam->noLengthCheckEnable      = DEFAULT_noLengthCheckEnable;
+    p_TgecDriverParam->lgthCheckNostdr          = DEFAULT_lgthCheckNostdr;
+    p_TgecDriverParam->timeStampEnable          = DEFAULT_timeStampEnable;
+    p_TgecDriverParam->rxSfdAny                 = DEFAULT_rxSfdAny;
+    p_TgecDriverParam->rxPblFwd                 = DEFAULT_rxPblFwd;
+    p_TgecDriverParam->txPblFwd                 = DEFAULT_txPblFwd;
+
+    p_TgecDriverParam->txIpgLength              = DEFAULT_txIpgLength;
+    p_TgecDriverParam->statisticsEnable         = DEFAULT_statisticsEnable;
+    p_TgecDriverParam->maxFrameLength           = DEFAULT_maxFrameLength;
+    p_TgecDriverParam->padAndCrcEnable          = DEFAULT_padAndCrcEnable;
+
+    p_TgecDriverParam->debugMode                = DEFAULT_debugMode;
+
+    p_TgecDriverParam->pauseTime                = DEFAULT_pauseTime;
+
+//Temp    p_TgecDriverParam->imask              = DEFAULT_imask;
+}
+
+/* ........................................................................... */
+
+static void FreeInitResources(t_Tgec *p_Tgec)
+{
+    /* release the driver's group hash table */
+    FreeHashTable(p_Tgec->p_MulticastAddrHash);
+    p_Tgec->p_MulticastAddrHash =   NULL;
+
+    /* release the driver's individual hash table */
+    FreeHashTable(p_Tgec->p_UnicastAddrHash);
+    p_Tgec->p_UnicastAddrHash =     NULL;
+}
+
+/* .............................................................................. */
+
+static void HardwareClearAddrInPaddr(t_Tgec   *p_Tgec, uint8_t paddrNum)
+{
+    if (paddrNum != 0)
+        return;             /* At this time MAC has only one address */
+
+    WRITE_UINT32(p_Tgec->p_MemMap->mac_addr_2, 0x0);
+    WRITE_UINT32(p_Tgec->p_MemMap->mac_addr_3, 0x0);
+}
+
+/* ........................................................................... */
+
+static void HardwareAddAddrInPaddr(t_Tgec   *p_Tgec, uint64_t *p_Addr, uint8_t paddrNum)
+{
+    uint32_t tmpReg32 = 0;
+    uint64_t addr = *p_Addr;
+    t_TgecMemMap    *p_TgecMemMap = p_Tgec->p_MemMap;
+
+    if (paddrNum != 0)
+        return;             /* At this time MAC has only one address */
+
+//    tmpReg32 = (uint32_t)(addr);
+    tmpReg32 = (uint32_t)(addr>>16);
+    SwapUint32P(&tmpReg32);
+    WRITE_UINT32(p_TgecMemMap->mac_addr_2, tmpReg32);
+
+//    tmpReg32 = (uint32_t)(addr>>32);
+    tmpReg32 = (uint32_t)(addr);
+    SwapUint32P(&tmpReg32);
+    tmpReg32 >>= 16;
+    WRITE_UINT32(p_TgecMemMap->mac_addr_3, tmpReg32);
+}
+
+/*****************************************************************************/
+/*                     10G MAC API routines                                  */
+/*****************************************************************************/
+
+static t_Error TgecFree(t_Handle h_Tgec)
+{
+    t_Tgec       *p_Tgec = (t_Tgec *)h_Tgec;
+
+    SANITY_CHECK_RETURN_ERROR(p_Tgec, E_INVALID_HANDLE);
+
+    if (p_Tgec->p_TgecDriverParam)
+    {
+        XX_Free(p_Tgec->p_TgecDriverParam);
+        p_Tgec->p_TgecDriverParam = NULL;
+    }
+    FreeInitResources(p_Tgec);
+    XX_Free (p_Tgec);
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static t_Error TgecInit(t_Handle h_Tgec)
+{
+
+    t_Tgec                  *p_Tgec = (t_Tgec *)h_Tgec;
+    t_TgecDriverParam       *p_TgecDriverParam;
+    t_TgecMemMap            *p_MemMap;
+    uint32_t                tmpReg32;
+    uint64_t                addr;
+
+    SANITY_CHECK_RETURN_ERROR(p_Tgec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Tgec->p_TgecDriverParam, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(p_Tgec->p_MemMap, E_INVALID_HANDLE);
+
+    CHECK_INIT_PARAMETERS(p_Tgec, CheckInitParameters);
+
+    p_TgecDriverParam = p_Tgec->p_TgecDriverParam;
+    p_MemMap = p_Tgec->p_MemMap;
+
+    /* MAC Address */
+
+    addr = p_Tgec->addr;
+
+//    tmpReg32 = (uint32_t)(addr);
+    tmpReg32 = (uint32_t)(addr>>16);
+    SwapUint32P(&tmpReg32);
+    WRITE_UINT32(p_MemMap->mac_addr_0, tmpReg32);
+
+//    tmpReg32 = (uint32_t)(addr>>32);
+    tmpReg32 = (uint32_t)(addr);
+    SwapUint32P(&tmpReg32);
+    tmpReg32 >>= 16;
+    WRITE_UINT32(p_MemMap->mac_addr_1, tmpReg32);
+
+    /* Config */
+
+    tmpReg32 = 0;
+    if (p_TgecDriverParam->wanModeEnable)
+       tmpReg32 |= CMD_CFG_WAN_MODE;
+    if (p_TgecDriverParam->promiscuousModeEnable)
+       tmpReg32 |= CMD_CFG_PROMIS_EN;
+    if (p_TgecDriverParam->padRemovalEnable)
+       tmpReg32 |= CMD_CFG_PAD_EN;
+    if (p_TgecDriverParam->crcForwardEnable)
+       tmpReg32 |= CMD_CFG_CRC_FWD;
+    if (p_TgecDriverParam->pauseForwardEnable)
+       tmpReg32 |= CMD_CFG_PAUSE_FWD;
+    if (p_TgecDriverParam->pauseIgnore)
+       tmpReg32 |= CMD_CFG_PAUSE_IGNORE;
+    if (p_TgecDriverParam->txAddrInsEnable)
+       tmpReg32 |= CMD_CFG_TX_ADDR_INS;
+    if (p_TgecDriverParam->loopbackEnable)
+        tmpReg32 |= CMD_CFG_LOOPBACK_EN;
+    if (p_TgecDriverParam->cmdFrameEnable)
+        tmpReg32 |= CMD_CFG_CMD_FRM_EN;
+    if (p_TgecDriverParam->rxErrorDiscard)
+        tmpReg32 |= CMD_CFG_RX_ER_DISC;
+    if (p_TgecDriverParam->phyTxenaOn)
+       tmpReg32 |= CMD_CFG_PHY_TX_EN;
+    if (p_TgecDriverParam->sendIdleEnable)
+       tmpReg32 |= CMD_CFG_SEND_IDLE;
+    if (p_TgecDriverParam->noLengthCheckEnable)
+       tmpReg32 |= CMD_CFG_NO_LEN_CHK;
+    if (p_TgecDriverParam->lgthCheckNostdr)
+       tmpReg32 |= CMD_CFG_LEN_CHK_NOSTDR;
+    if (p_TgecDriverParam->timeStampEnable)
+       tmpReg32 |= CMD_CFG_EN_TIMESTAMP;
+    if (p_TgecDriverParam->rxSfdAny)
+       tmpReg32 |= RX_SFD_ANY;
+    if (p_TgecDriverParam->rxPblFwd)
+       tmpReg32 |= CMD_CFG_RX_PBL_FWD;
+    if (p_TgecDriverParam->txPblFwd)
+       tmpReg32 |= CMD_CFG_TX_PBL_FWD;
+    WRITE_UINT32(p_MemMap->cmd_conf_ctrl, tmpReg32);
+
+    /* Max Frame Length */
+    WRITE_UINT32(p_MemMap->maxfrm, (uint32_t)p_TgecDriverParam->maxFrameLength);
+
+    /* Pause Time */
+    WRITE_UINT32(p_MemMap->pause_quant, p_TgecDriverParam->pauseTime);
+
+    p_Tgec->p_MulticastAddrHash = AllocHashTable(HASH_TABLE_SIZE);
+    if(!p_Tgec->p_MulticastAddrHash)
+    {
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("allocation hash table is FAILED"));
+    }
+
+    p_Tgec->p_UnicastAddrHash = AllocHashTable(HASH_TABLE_SIZE);
+    if(!p_Tgec->p_UnicastAddrHash)
+    {
+        FreeInitResources(p_Tgec);
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("allocation hash table is FAILED"));
+    }
+
+    XX_Free(p_TgecDriverParam);
+    p_Tgec->p_TgecDriverParam = NULL;
+
+    return E_OK;
+}
+
+
+/*****************************************************************************/
+/*                      Tgec Configs modification functions                 */
+/*****************************************************************************/
+
+/* .............................................................................. */
+
+static t_Error TgecConfigStatistics(t_Handle h_Tgec, bool newVal)
+{
+    t_Tgec *p_Tgec = (t_Tgec *)h_Tgec;
+
+    SANITY_CHECK_RETURN_ERROR(p_Tgec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Tgec->p_TgecDriverParam, E_INVALID_STATE);
+
+    p_Tgec->p_TgecDriverParam->statisticsEnable = newVal;
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static t_Error TgecConfigLoopback(t_Handle h_Tgec, bool newVal)
+{
+    t_Tgec *p_Tgec = (t_Tgec *)h_Tgec;
+
+    SANITY_CHECK_RETURN_ERROR(p_Tgec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Tgec->p_TgecDriverParam, E_INVALID_STATE);
+
+    p_Tgec->p_TgecDriverParam->loopbackEnable = newVal;
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static t_Error TgecConfigWan(t_Handle h_Tgec, bool newVal)
+{
+    t_Tgec *p_Tgec = (t_Tgec *)h_Tgec;
+
+    SANITY_CHECK_RETURN_ERROR(p_Tgec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Tgec->p_TgecDriverParam, E_INVALID_STATE);
+
+    p_Tgec->p_TgecDriverParam->wanModeEnable = newVal;
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static t_Error TgecConfigMaxFrameLength(t_Handle h_Tgec, uint16_t newVal)
+{
+    t_Tgec *p_Tgec = (t_Tgec *)h_Tgec;
+
+    SANITY_CHECK_RETURN_ERROR(p_Tgec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Tgec->p_TgecDriverParam, E_INVALID_STATE);
+
+    p_Tgec->p_TgecDriverParam->maxFrameLength = newVal;
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static t_Error TgecConfigPadAndCrc(t_Handle h_Tgec, bool newVal)
+{
+    t_Tgec *p_Tgec = (t_Tgec *)h_Tgec;
+
+    SANITY_CHECK_RETURN_ERROR(p_Tgec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Tgec->p_TgecDriverParam, E_INVALID_STATE);
+
+    p_Tgec->p_TgecDriverParam->padAndCrcEnable = newVal;
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static t_Error TgecConfigHugeFrames(t_Handle h_Tgec, bool newVal)
+{
+    t_Tgec *p_Tgec = (t_Tgec *)h_Tgec;
+    UNUSED(newVal);
+
+    SANITY_CHECK_RETURN_ERROR(p_Tgec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Tgec->p_TgecDriverParam, E_INVALID_STATE);
+
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+
+    return E_OK;
+}
+
+/*****************************************************************************/
+/*                      Tgec Run Time API functions                         */
+/*****************************************************************************/
+
+/* .............................................................................. */
+
+static t_Error TgecEnable(t_Handle h_Tgec,  e_CommMode mode)
+{
+    t_Tgec *p_Tgec = (t_Tgec *)h_Tgec;
+    t_TgecMemMap       *p_MemMap ;
+    uint32_t            tmpReg32 = 0;
+
+    SANITY_CHECK_RETURN_ERROR(p_Tgec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Tgec->p_MemMap, E_INVALID_HANDLE);
+
+    p_MemMap= (t_TgecMemMap*)(p_Tgec->p_MemMap);
+
+    tmpReg32 = GET_UINT32(p_MemMap->cmd_conf_ctrl);
+
+    switch (mode)
+    {
+        case e_COMM_MODE_NONE:
+            tmpReg32 &= ~(CMD_CFG_TX_EN | CMD_CFG_RX_EN);
+            break;
+        case e_COMM_MODE_RX :
+            tmpReg32 |= CMD_CFG_RX_EN ;
+            break;
+        case e_COMM_MODE_TX :
+            tmpReg32 |= CMD_CFG_TX_EN ;
+            break;
+        case e_COMM_MODE_RX_AND_TX:
+            tmpReg32 |= (CMD_CFG_TX_EN | CMD_CFG_RX_EN);
+            break;
+    }
+
+    WRITE_UINT32(p_MemMap->cmd_conf_ctrl, tmpReg32);
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+static t_Error TgecDisable (t_Handle h_Tgec, e_CommMode mode)
+{
+    t_Tgec *p_Tgec = (t_Tgec *)h_Tgec;
+    t_TgecMemMap       *p_MemMap ;
+    uint32_t            tmpReg32 = 0;
+
+    SANITY_CHECK_RETURN_ERROR(p_Tgec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Tgec->p_MemMap, E_INVALID_HANDLE);
+
+    p_MemMap= (t_TgecMemMap*)(p_Tgec->p_MemMap);
+
+    tmpReg32 = GET_UINT32(p_MemMap->cmd_conf_ctrl);
+
+    switch (mode)
+    {
+        case e_COMM_MODE_RX :
+            tmpReg32 &= ~CMD_CFG_RX_EN ;
+            break;
+        case e_COMM_MODE_TX :
+            tmpReg32 &= ~CMD_CFG_TX_EN ;
+            break;
+        case e_COMM_MODE_RX_AND_TX:
+            tmpReg32 &= ~(CMD_CFG_TX_EN | CMD_CFG_RX_EN);
+        break;
+        default:
+            RETURN_ERROR(MINOR, E_INVALID_SELECTION, NO_MSG);
+    }
+
+    WRITE_UINT32(p_MemMap->cmd_conf_ctrl, tmpReg32);
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static t_Error TgecTxMacPause(t_Handle h_Tgec, uint16_t pauseTime, uint16_t exPauseTime )
+{
+    t_Tgec      *p_Tgec = (t_Tgec *)h_Tgec;
+    uint32_t    ptv = 0 ;
+    t_TgecMemMap *p_MemMap;
+    UNUSED(exPauseTime);
+
+    SANITY_CHECK_RETURN_ERROR(p_Tgec, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(!p_Tgec->p_TgecDriverParam, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(p_Tgec->p_MemMap, E_INVALID_STATE);
+
+    p_MemMap = (t_TgecMemMap*)(p_Tgec->p_MemMap);
+
+    ptv = (uint32_t)pauseTime ;
+
+    WRITE_UINT32(p_MemMap->pause_quant, ptv);
+
+    return E_OK;
+}
+
+/* Counters handling */
+/* .............................................................................. */
+
+static t_Error TgecGetStatistics(t_Handle h_Tgec, t_FmMacStatistics *p_Statistics)
+{
+    t_Tgec          *p_Tgec = (t_Tgec *)h_Tgec;
+    t_TgecMemMap        *p_TgecMemMap = p_Tgec->p_MemMap;
+
+    SANITY_CHECK_RETURN_ERROR(p_Tgec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Statistics, E_NULL_POINTER);
+
+
+
+    p_Statistics->eStatPkts64           = GET_UINT64(p_TgecMemMap->R64);
+    p_Statistics->eStatPkts65to127      = GET_UINT64(p_TgecMemMap->R127);
+    p_Statistics->eStatPkts128to255     = GET_UINT64(p_TgecMemMap->R255);
+    p_Statistics->eStatPkts256to511     = GET_UINT64(p_TgecMemMap->R511);
+    p_Statistics->eStatPkts512to1023    = GET_UINT64(p_TgecMemMap->R1023);
+    p_Statistics->eStatPkts1024to1518   = GET_UINT64(p_TgecMemMap->R1518);
+    p_Statistics->eStatPkts1519to1522   = GET_UINT64(p_TgecMemMap->R1519X);
+/* */
+    p_Statistics->eStatFragments        = GET_UINT64(p_TgecMemMap->TRFRG);
+    p_Statistics->eStatJabbers          = GET_UINT64(p_TgecMemMap->TRJBR);
+
+    p_Statistics->eStatsDropEvents      = GET_UINT64(p_TgecMemMap->RDRP);
+    p_Statistics->eStatCRCAlignErrors   = GET_UINT64(p_TgecMemMap->RALN);
+
+    p_Statistics->eStatUndersizePkts    = GET_UINT64(p_TgecMemMap->TRUND);
+    p_Statistics->eStatOversizePkts     = GET_UINT64(p_TgecMemMap->TROVR);
+/* Pause */
+    p_Statistics->reStatPause           = GET_UINT64(p_TgecMemMap->RXPF);
+    p_Statistics->teStatPause           = GET_UINT64(p_TgecMemMap->TXPF);
+
+
+/* MIB II */
+    p_Statistics->ifInOctets            = GET_UINT64(p_TgecMemMap->ROCT);
+    p_Statistics->ifInMcastPkts         = GET_UINT64(p_TgecMemMap->RMCA);
+    p_Statistics->ifInBcastPkts         = GET_UINT64(p_TgecMemMap->RBCA);
+    p_Statistics->ifInPkts              = GET_UINT64(p_TgecMemMap->RUCA)
+                                        + p_Statistics->ifInMcastPkts
+                                        + p_Statistics->ifInBcastPkts;
+    p_Statistics->ifInDiscards          = 0;
+    p_Statistics->ifInErrors            = GET_UINT64(p_TgecMemMap->RERR);
+
+    p_Statistics->ifOutOctets           = GET_UINT64(p_TgecMemMap->TOCT);
+    p_Statistics->ifOutMcastPkts        = GET_UINT64(p_TgecMemMap->TMCA);
+    p_Statistics->ifOutBcastPkts        = GET_UINT64(p_TgecMemMap->TBCA);
+    p_Statistics->ifOutPkts             = GET_UINT64(p_TgecMemMap->TUCA);
+    p_Statistics->ifOutDiscards         = 0;
+    p_Statistics->ifOutErrors           = GET_UINT64(p_TgecMemMap->TERR);
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static t_Error TgecModifyMacAddress (t_Handle h_Tgec, t_EnetAddr *p_EnetAddr)
+{
+    t_Tgec              *p_Tgec = (t_Tgec *)h_Tgec;
+    t_TgecMemMap        *p_TgecMemMap = p_Tgec->p_MemMap;
+    uint32_t              tmpReg32 = 0;
+    uint64_t              addr;
+
+    SANITY_CHECK_RETURN_ERROR(p_Tgec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_TgecMemMap, E_INVALID_HANDLE);
+
+    /*  Initialize MAC Station Address registers (1 & 2)    */
+    /*  Station address have to be swapped (big endian to little endian */
+
+    addr = ((*(uint64_t *)p_EnetAddr) >> 16);
+    p_Tgec->addr = addr;
+
+    tmpReg32 = 0;
+    tmpReg32 |= (uint32_t)(addr & 0xFFFFFFFF);
+    WRITE_UINT32(p_TgecMemMap->mac_addr_0, tmpReg32);
+
+    tmpReg32 = 0;
+    tmpReg32 |= (uint32_t) (addr >> 32);
+
+    WRITE_UINT32(p_TgecMemMap->mac_addr_1, tmpReg32);
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static t_Error TgecResetCounters (t_Handle h_Tgec)
+{
+    t_Tgec *p_Tgec = (t_Tgec *)h_Tgec;
+    t_TgecMemMap       *p_MemMap ;
+    uint32_t            tmpReg32, cmdConfCtrl;
+    int i;
+
+    SANITY_CHECK_RETURN_ERROR(p_Tgec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Tgec->p_MemMap, E_INVALID_HANDLE);
+
+    p_MemMap= (t_TgecMemMap*)(p_Tgec->p_MemMap);
+
+    cmdConfCtrl = GET_UINT32(p_MemMap->cmd_conf_ctrl);
+
+    cmdConfCtrl |= CMD_CFG_STAT_CLR;
+
+    WRITE_UINT32(p_MemMap->cmd_conf_ctrl, cmdConfCtrl);
+
+    for (i=0; i<1000; i++)
+    {
+        tmpReg32 = GET_UINT32(p_MemMap->cmd_conf_ctrl);
+        if (!(tmpReg32 & CMD_CFG_STAT_CLR))
+            break;
+    }
+
+    cmdConfCtrl &= ~CMD_CFG_STAT_CLR;
+    WRITE_UINT32(p_MemMap->cmd_conf_ctrl, cmdConfCtrl);
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static t_Error TgecDelExactMatchMacAddress(t_Handle h_Tgec, t_EnetAddr *p_EthAddr)
+{
+    t_Tgec   *p_Tgec = (t_Tgec *) h_Tgec;
+    uint64_t  ethAddr;
+    uint8_t   paddrNum;
+
+    SANITY_CHECK_RETURN_ERROR(p_Tgec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Tgec->p_MemMap, E_INVALID_HANDLE);
+
+    ethAddr = ((*(uint64_t *)p_EthAddr) >> 16);
+
+    /* Find used PADDR containing this address */
+    for (paddrNum = 0; paddrNum < TGEC_NUM_OF_PADDRS; paddrNum++)
+    {
+        if ((p_Tgec->indAddrRegUsed[paddrNum]) &&
+            (p_Tgec->paddr[paddrNum] == ethAddr))
+        {
+            /* mark this PADDR as not used */
+            p_Tgec->indAddrRegUsed[paddrNum] = FALSE;
+            /* clear in hardware */
+            HardwareClearAddrInPaddr(p_Tgec, paddrNum);
+            p_Tgec->numOfIndAddrInRegs--;
+
+            return E_OK;
+        }
+    }
+
+    RETURN_ERROR(MAJOR, E_NOT_FOUND, NO_MSG);
+}
+
+/* .............................................................................. */
+
+static t_Error TgecAddExactMatchMacAddress(t_Handle h_Tgec, t_EnetAddr *p_EthAddr)
+{
+    t_Tgec   *p_Tgec = (t_Tgec *) h_Tgec;
+    uint64_t  ethAddr;
+    uint8_t   paddrNum;
+
+    SANITY_CHECK_RETURN_ERROR(p_Tgec, E_INVALID_HANDLE);
+
+    ethAddr = ((*(uint64_t *)p_EthAddr) >> 16);
+
+    if (ethAddr & GROUP_ADDRESS)
+        /* Multicast address has no effect in PADDR */
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Multicast address"));
+
+    /* Make sure no PADDR contains this address */
+    for (paddrNum = 0; paddrNum < TGEC_NUM_OF_PADDRS; paddrNum++)
+    {
+        if (p_Tgec->indAddrRegUsed[paddrNum])
+        {
+            if (p_Tgec->paddr[paddrNum] == ethAddr)
+            {
+                RETURN_ERROR(MAJOR, E_ALREADY_EXISTS, NO_MSG);
+            }
+        }
+    }
+
+    /* Find first unused PADDR */
+    for (paddrNum = 0; paddrNum < TGEC_NUM_OF_PADDRS; paddrNum++)
+    {
+        if (!(p_Tgec->indAddrRegUsed[paddrNum]))
+        {
+            /* mark this PADDR as used */
+            p_Tgec->indAddrRegUsed[paddrNum] = TRUE;
+            /* store address */
+            p_Tgec->paddr[paddrNum] = ethAddr;
+
+            /* put in hardware */
+            HardwareAddAddrInPaddr(p_Tgec, &ethAddr, paddrNum);
+            p_Tgec->numOfIndAddrInRegs++;
+
+            return E_OK;
+        }
+    }
+
+    /* No free PADDR */
+    RETURN_ERROR(MAJOR, E_FULL, NO_MSG);
+}
+
+/* .............................................................................. */
+
+static t_Error TgecAddHashMacAddress(t_Handle h_Tgec, t_EnetAddr *p_EthAddr)
+{
+    t_Tgec          *p_Tgec = (t_Tgec *)h_Tgec;
+    t_TgecMemMap    *p_TgecMemMap = p_Tgec->p_MemMap;
+    t_EthHashEntry  *p_HashEntry;
+    uint32_t        crc;
+    uint32_t        hash;
+    uint64_t        ethAddr;
+
+    SANITY_CHECK_RETURN_ERROR(p_Tgec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_TgecMemMap, E_INVALID_HANDLE);
+
+    ethAddr = ((*(uint64_t *)p_EthAddr) >> 16);
+
+    if (!(ethAddr & GROUP_ADDRESS))
+        /* Unicast addresses not supported in hash */
+        RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Unicast Address"));
+
+    /* CRC calculation */
+    GET_MAC_ADDR_CRC(ethAddr, crc);
+    crc = MIRROR_32(crc);
+
+    hash = (crc >> HASH_CTRL_MCAST_SHIFT) & HASH_ADDR_MASK;        /* Take 9 MSB bits */
+
+    /* Create element to be added to the driver hash table */
+    p_HashEntry = (t_EthHashEntry *)XX_Malloc(sizeof(t_EthHashEntry));
+    p_HashEntry->addr = ethAddr;
+    INIT_LIST(&p_HashEntry->node);
+
+    LIST_AddToTail(&(p_HashEntry->node), &(p_Tgec->p_MulticastAddrHash->p_Lsts[hash]));
+    WRITE_UINT32(p_TgecMemMap->hashtable_ctrl, (hash | HASH_CTRL_MCAST_EN));
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static t_Error TgecDelHashMacAddress(t_Handle h_Tgec, t_EnetAddr *p_EthAddr)
+{
+    t_Tgec          *p_Tgec = (t_Tgec *)h_Tgec;
+    t_TgecMemMap    *p_TgecMemMap = p_Tgec->p_MemMap;
+    t_EthHashEntry  *p_HashEntry = NULL;
+    t_List          *p_Pos;
+    uint32_t        crc;
+    uint32_t        hash;
+    uint64_t        ethAddr;
+
+    SANITY_CHECK_RETURN_ERROR(p_Tgec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_TgecMemMap, E_INVALID_HANDLE);
+
+    ethAddr = ((*(uint64_t *)p_EthAddr) >> 16);
+
+    /* CRC calculation */
+    GET_MAC_ADDR_CRC(ethAddr, crc);
+    crc = MIRROR_32(crc);
+
+    hash = (crc >> HASH_CTRL_MCAST_SHIFT) & HASH_ADDR_MASK;        /* Take 9 MSB bits */
+
+    LIST_FOR_EACH(p_Pos, &(p_Tgec->p_MulticastAddrHash->p_Lsts[hash]))
+    {
+
+        p_HashEntry = ETH_HASH_ENTRY_OBJ(p_Pos);
+        if(p_HashEntry->addr == ethAddr)
+        {
+            LIST_DelAndInit(&p_HashEntry->node);
+            XX_Free(p_HashEntry);
+            break;
+        }
+    }
+    if(LIST_IsEmpty(&p_Tgec->p_MulticastAddrHash->p_Lsts[hash]))
+        WRITE_UINT32(p_TgecMemMap->hashtable_ctrl, (hash & ~HASH_CTRL_MCAST_EN));
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static t_Error TgecGetId(t_Handle h_Tgec, uint32_t *macId)
+{
+    t_Tgec              *p_Tgec = (t_Tgec *)h_Tgec;
+    t_TgecMemMap        *p_TgecMemMap = p_Tgec->p_MemMap;
+UNUSED(macId);
+
+    SANITY_CHECK_RETURN_ERROR(p_Tgec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_Tgec->p_TgecDriverParam, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_TgecMemMap, E_INVALID_HANDLE);
+
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("TgecGetId Not Supported"));
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static t_Error TgecGetVersion(t_Handle h_Tgec, uint32_t *macVersion)
+{
+    t_Tgec              *p_Tgec = (t_Tgec *)h_Tgec;
+    t_TgecMemMap        *p_TgecMemMap = p_Tgec->p_MemMap;
+
+    SANITY_CHECK_RETURN_ERROR(p_Tgec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_Tgec->p_TgecDriverParam, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_TgecMemMap, E_INVALID_HANDLE);
+
+    *macVersion = GET_UINT32(p_TgecMemMap->tgec_id);
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static t_Error TgecSetPromiscuous(t_Handle h_Tgec, bool newVal)
+{
+    t_Tgec       *p_Tgec = (t_Tgec *)h_Tgec;
+    t_TgecMemMap *p_TgecMemMap = p_Tgec->p_MemMap;
+    uint32_t     tmpReg32;
+
+    SANITY_CHECK_RETURN_ERROR(p_Tgec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_Tgec->p_TgecDriverParam, E_INVALID_HANDLE);
+
+    tmpReg32 = GET_UINT32(p_TgecMemMap->cmd_conf_ctrl);
+
+    if (newVal)
+        tmpReg32 |= CMD_CFG_PROMIS_EN;
+    else
+        tmpReg32 &= ~CMD_CFG_PROMIS_EN;
+
+    WRITE_UINT32(p_TgecMemMap->cmd_conf_ctrl, tmpReg32);
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static t_Error TgecAdjustLink(t_Handle h_Tgec, e_EnetSpeed speed, bool fullDuplex)
+{
+    t_Tgec       *p_Tgec = (t_Tgec *)h_Tgec;
+    /*t_TgecMemMap *p_TgecMemMap = p_Tgec->p_MemMap;
+    uint32_t     tmpReg32;*/
+
+    SANITY_CHECK_RETURN_ERROR(p_Tgec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_Tgec->p_TgecDriverParam, E_INVALID_HANDLE);
+
+    if (!fullDuplex)
+        RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("half-duplex"));
+
+RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static t_Error TgecSetExcpetions(t_Handle h_Tgec, e_FmMacExceptions ex)
+{
+    t_Tgec              *p_Tgec = (t_Tgec *)h_Tgec;
+
+    SANITY_CHECK_RETURN_ERROR(p_Tgec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_Tgec->p_TgecDriverParam, E_INVALID_HANDLE);
+UNUSED(ex);
+
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
+/* .............................................................................. */
+
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+static t_Error TgecDumpRegs(t_Handle h_Tgec)
+{
+    t_Tgec    *p_Tgec = (t_Tgec *)h_Tgec;
+
+    DECLARE_DUMP;
+
+    if (p_Tgec->p_MemMap)
+    {
+        DUMP_TITLE(p_Tgec->p_MemMap, ("10G MAC %d: ", p_Tgec->macId));
+    }
+
+    return E_OK;
+}
+#endif /* (defined(DEBUG_ERRORS) && ... */
+
+/*****************************************************************************/
+/*                      Tgec Config  Main Entry                             */
+/*****************************************************************************/
+
+static void InitFmMacControllerDriver(t_FmMacControllerDriver *p_FmMacControllerDriver)
+{
+    p_FmMacControllerDriver->f_FM_MAC_Init                      = TgecInit;
+    p_FmMacControllerDriver->f_FM_MAC_Free                      = TgecFree;
+
+    p_FmMacControllerDriver->f_FM_MAC_ConfigStatistics          = TgecConfigStatistics;
+    p_FmMacControllerDriver->f_FM_MAC_ConfigLoopback            = TgecConfigLoopback;
+    p_FmMacControllerDriver->f_FM_MAC_ConfigMaxFrameLength      = TgecConfigMaxFrameLength;
+
+    p_FmMacControllerDriver->f_FM_MAC_ConfigWan                 = TgecConfigWan;
+
+    p_FmMacControllerDriver->f_FM_MAC_ConfigPadAndCrc           = TgecConfigPadAndCrc;
+    p_FmMacControllerDriver->f_FM_MAC_ConfigHalfDuplex          = NULL; /* half-duplex is not supported in xgec */
+    p_FmMacControllerDriver->f_FM_MAC_ConfigHugeFrames          = TgecConfigHugeFrames;
+
+    p_FmMacControllerDriver->f_FM_MAC_SetExceptions             = TgecSetExcpetions;
+
+    p_FmMacControllerDriver->f_FM_MAC_SetPromiscuous            = TgecSetPromiscuous;
+    p_FmMacControllerDriver->f_FM_MAC_AdjustLink                = TgecAdjustLink;
+
+    p_FmMacControllerDriver->f_FM_MAC_Enable                    = TgecEnable;
+    p_FmMacControllerDriver->f_FM_MAC_Disable                   = TgecDisable;
+    p_FmMacControllerDriver->f_FM_MAC_Restart                   = NULL; /* TgecRestart; Not Implemented */
+
+    p_FmMacControllerDriver->f_FM_MAC_TxMacPause                = TgecTxMacPause;
+
+    p_FmMacControllerDriver->f_FM_MAC_ResetCounters             = TgecResetCounters;
+    p_FmMacControllerDriver->f_FM_MAC_GetStatistics             = TgecGetStatistics;
+
+    p_FmMacControllerDriver->f_FM_MAC_ModifyMacAddr             = TgecModifyMacAddress;
+    p_FmMacControllerDriver->f_FM_MAC_AddHashMacAddr            = TgecAddHashMacAddress;
+    p_FmMacControllerDriver->f_FM_MAC_RemoveHashMacAddr         = TgecDelHashMacAddress;
+    p_FmMacControllerDriver->f_FM_MAC_AddExactMatchMacAddr      = TgecAddExactMatchMacAddress;
+    p_FmMacControllerDriver->f_FM_MAC_RemovelExactMatchMacAddr  = TgecDelExactMatchMacAddress;
+    p_FmMacControllerDriver->f_FM_MAC_GetId                     = TgecGetId;
+    p_FmMacControllerDriver->f_FM_MAC_GetVersion                = TgecGetVersion;
+
+    p_FmMacControllerDriver->f_FM_MAC_MII_WritePhyReg           = TGEC_MII_WritePhyReg;
+    p_FmMacControllerDriver->f_FM_MAC_MII_ReadPhyReg            = TGEC_MII_ReadPhyReg;
+
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+    p_FmMacControllerDriver->f_FM_MAC_DumpRegs                  = TgecDumpRegs;
+#endif /* (defined(DEBUG_ERRORS) && ... */
+}
+
+t_Handle  TGEC_Config(t_FmMacParams *p_FmMacParam)
+{
+    t_Tgec                  *p_Tgec;
+    t_TgecDriverParam       *p_TgecDriverParam;
+    uint64_t                baseAddr = p_FmMacParam->baseAddr;
+
+    SANITY_CHECK_RETURN_VALUE(p_FmMacParam, E_NULL_POINTER, NULL);
+
+    /* allocate memory for the UCC GETH data structure. */
+    p_Tgec = (t_Tgec *) XX_Malloc(sizeof(t_Tgec));
+    if (!p_Tgec)
+    {
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("10G MAC driver structure"));
+        return NULL;
+    }
+    /* Zero out * p_Tgec */
+    memset( p_Tgec, 0, sizeof(t_Tgec));
+    InitFmMacControllerDriver(&p_Tgec->fmMacControllerDriver);
+
+    /* allocate memory for the 10G MAC driver parameters data structure. */
+    p_TgecDriverParam = (t_TgecDriverParam *) XX_Malloc(sizeof(t_TgecDriverParam));
+    if (!p_TgecDriverParam)
+    {
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("10G MAC driver parameters"));
+        TgecFree(p_Tgec);
+        return NULL;
+    }
+    /* Zero out */
+    memset(p_TgecDriverParam, 0, sizeof(t_TgecDriverParam));
+
+    /* Plant parameter structure pointer */
+    p_Tgec->p_TgecDriverParam = p_TgecDriverParam;
+
+    SetDefaultParam(p_TgecDriverParam);
+
+    p_Tgec->h_App    = p_FmMacParam->h_App ;
+    p_Tgec->addr  = ((*(uint64_t *)p_FmMacParam->addr) >> 16);
+    p_Tgec->p_MemMap = CAST_UINT64_TO_POINTER_TYPE(t_TgecMemMap, baseAddr);
+    p_Tgec->p_MiiMemMap  = CAST_UINT64_TO_POINTER_TYPE(t_TgecMiiAccessMemMap, (baseAddr + TGEC_TO_MII_OFFSET));
+    p_Tgec->enetMode = p_FmMacParam->enetMode;
+    p_Tgec->macId    = p_FmMacParam->macId;
+
+    return p_Tgec;
+}
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/tgec.h b/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/tgec.h
new file mode 100644
index 0000000..9c8ac97
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/tgec.h
@@ -0,0 +1,439 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/******************************************************************************
+ @File          tgec.h
+
+ @Description   FM 10G MAC ...
+*//***************************************************************************/
+#ifndef __TGEC_H
+#define __TGEC_H
+
+#include "std_ext.h"
+#include "error_ext.h"
+#include "list_ext.h"
+#include "tgec_mii_acc.h"
+#include "fm_mac.h"
+
+
+/* Default Config Params */
+#define DEFAULT_wanModeEnable               FALSE
+#define DEFAULT_promiscuousModeEnable       FALSE
+
+#define DEFAULT_padRemovalEnable            FALSE
+#define DEFAULT_crcForwardEnable            TRUE
+#define DEFAULT_pauseForwardEnable          FALSE
+#define DEFAULT_pauseIgnore                 FALSE
+#define DEFAULT_txAddrInsEnable             FALSE
+
+#define DEFAULT_loopbackEnable              FALSE
+#define DEFAULT_cmdFrameEnable              FALSE
+#define DEFAULT_rxErrorDiscard              FALSE
+#define DEFAULT_phyTxenaOn                  FALSE
+#define DEFAULT_sendIdleEnable              FALSE
+#define DEFAULT_noLengthCheckEnable         FALSE
+#define DEFAULT_lgthCheckNostdr             FALSE
+#define DEFAULT_timeStampEnable             FALSE
+#define DEFAULT_rxSfdAny                    FALSE
+#define DEFAULT_rxPblFwd                    FALSE
+#define DEFAULT_txPblFwd                    FALSE
+#define DEFAULT_txIpgLength                 12
+
+#define DEFAULT_statisticsEnable            TRUE
+#define DEFAULT_maxFrameLength              0x600
+#define DEFAULT_padAndCrcEnable             TRUE
+
+#define DEFAULT_debugMode                   FALSE
+#define DEFAULT_pauseTime                   0xf000
+
+
+#define MAX_PACKET_ALIGNMENT        31
+#define MAX_INTER_PACKET_GAP        0x7f
+#define MAX_INTER_PALTERNATE_BEB    0x0f
+#define MAX_RETRANSMISSION          0x0f
+#define MAX_COLLISION_WINDOW        0x03ff
+
+
+#define TGEC_NUM_OF_PADDRS          1                   /* number of pattern match registers (entries) */
+
+#define GROUP_ADDRESS               0x0000010000000000LL /* Group address bit indication */
+
+#define HASH_TABLE_SIZE             512                 /* Hash table size (= 32 bits * 8 regs) */
+
+#define TGEC_TO_MII_OFFSET          0x1000              /* Offset from the MEM map to the MDIO mem map */
+
+/* 10-gigabit Ethernet MAC Controller ID (10GEC_ID) */
+#define TGEC_ID_ID                  0xffff0000
+#define TGEC_ID_MAC_VERSION         0x0000FF00
+#define TGEC_ID_MAC_REV             0x000000ff
+
+/* Command and Configuration Register (COMMAND_CONFIG) */
+#define CMD_CFG_TX_PBL_FWD          0x00800000  /* 08 Transmit Preamble Forwarding (custom preamble).
+                                                 */
+#define CMD_CFG_RX_PBL_FWD          0x00400000  /* 09 Receive Preamble Forwarding (custom preamble).
+                                                 */
+#define RX_SFD_ANY                  0x00200000  /* 10 Enables, when set, that any character is allowed at the SFD position of the preamble and the frame will be accepted.
+                                                 */
+#define CMD_CFG_EN_TIMESTAMP        0x00100000  /* 11 EN_TIMESTAMP IEEE 1588 timeStamp functionality control.
+                                                 * 0 disabled
+                                                 * 1 enabled
+                                                 */
+#define CMD_CFG_TX_ADDR_INS_SEL     0x00080000  /* 12 TX_ADDR_INS_SEL Transmit MAC address select
+                                                 * 0 insert using first MAC address
+                                                 * 1 insert using second MAC address
+                                                 */
+#define CMD_CFG_LEN_CHK_NOSTDR      0x00040000  /* 13 LEN_CHK_NOSTDR
+                                                 */
+#define CMD_CFG_NO_LEN_CHK          0x00020000  /* 14 NO_LEN_CHK Payload length check disable
+                                                 * 0 MAC compares the frame payload length with the frame length/type field.
+                                                 * 1 Payload length check is disabled.
+                                                 */
+#define CMD_CFG_SEND_IDLE           0x00010000  /* 15 SEND_IDLE Force idle generation
+                                                 * 0 Normal operation.
+                                                * 1 MAC permanently sends XGMII idle sequences even when faults are received.
+                                                 */
+#define CMD_CFG_PHY_TX_EN           0x00008000  /* 16 PHY_TX_EN PHY transmit enable
+                                                 * 0 PHY transmit is disabled.
+                                                 * 1 PHY transmit is enabled.
+                                                 */
+#define CMD_CFG_RX_ER_DISC          0x00004000  /* 17 RX_ER_DISC Receive error frame discard enable
+                                                 * 0 Received error frames are processed.
+                                                 * 1 Any frame received with an error is discarded.
+                                                 */
+#define CMD_CFG_CMD_FRM_EN          0x00002000  /* 18 CMD_FRM_EN Command frame reception enable
+                                                 * 0 Only Pause frames are accepted (all other command frames are rejected).
+                                                 * 1 All command frames are accepted.
+                                                 */
+#define CMD_CFG_STAT_CLR            0x00001000  /* 19 STAT_CLR Clear statistics
+                                                 * 0 Normal operations.
+                                                 * 1 All statistics counters are cleared.
+                                                 */
+#define CMD_CFG_LOOPBACK_EN         0x00000400  /* 21 LOOPBAC_EN PHY interface loopback enable
+                                                 * 0 Configure PHY for normal operation.
+                                                 * 1 Configure PHY for loopback mode.
+                                                 */
+#define CMD_CFG_TX_ADDR_INS         0x00000200  /* 22 TX_ADDR_INS Transmit source MAC address insertion
+                                                 * 0 MAC transmits the source MAC address unmodified.
+                                                 * 1 MAC overwrites the source MAC address with address specified by COMMAND_CONFIG[TX_ADDR_INS_SEL].
+                                                 */
+#define CMD_CFG_PAUSE_IGNORE        0x00000100  /* 23 PAUSE_IGNORE Ignore Pause frame quanta
+                                                 * 0 MAC stops transmit process for the duration specified in the Pause frame quanta of a received Pause frame.
+                                                 * 1 MAC ignores received Pause frames.
+                                                 */
+#define CMD_CFG_PAUSE_FWD           0x00000080  /* 24 PAUSE_FWD Terminate/forward received Pause frames
+                                                 * 0 MAC terminates and discards received Pause frames.
+                                                 * 1 MAC forwards Pause frames to the user application.
+                                                 */
+#define CMD_CFG_CRC_FWD             0x00000040  /* 25 CRC_FWD Terminate/forward CRC of received frames
+                                                 * 0 MAC strips CRC from received frames.
+                                                 * 1 MAC forwards CRC of received frames to the user application.
+                                                 */
+#define CMD_CFG_PAD_EN              0x00000020  /* 26 PAD_EN Frame padding removal in receive path enable
+                                                 * 0 MAC does not remove padding prior to forwarding frames to the user application.
+                                                 * 1 MAC removed padding prior to forwarding frames to the user application.
+                                                 */
+#define CMD_CFG_PROMIS_EN           0x00000010  /* 27 PROMIS_EN Promiscuous operation enable
+                                                 * 0 Unicast frames with a destination address not matching the core MAC address (defined by registers, MAC_ADDR_0 and MAC_ADDR_1) are rejected.
+                                                 * 1 All frames are received without any MAC address filtering.
+                                                 */
+#define CMD_CFG_WAN_MODE            0x00000008  /* 28 WAN_MODE WAN mode enable
+                                                 * 0 Configure MAC for LAN mode.
+                                                 * 1 Configure MAC for WAN mode.
+                                                 */
+#define CMD_CFG_RX_EN               0x00000002  /* 30 RX_EN MAC receive path enable
+                                                 * 0 MAC receive path is disabled
+                                                 * 1 MAC receive path is enabled.
+                                                 */
+#define CMD_CFG_TX_EN               0x00000001  /* 31 TX_EN MAC transmit path enable
+                                                 * 0 MAC transmit path is disabled
+                                                 * 1 MAC transmit path is enabled.
+                                                 */
+
+/* Hashtable Control Register (HASHTABLE_CTRL) */
+#define HASH_CTRL_MCAST_SHIFT       23
+
+#define HASH_CTRL_MCAST_RD          0x00000400  /* 22 MCAST_READ Entry Multicast frame reception for the hash entry.
+                                                 * 0 disabled
+                                                 * 1 enabled
+                                                 */
+#define HASH_CTRL_MCAST_EN          0x00000200  /* 22 MCAST_EN Multicast frame reception for the hash entry.
+                                                 * 0 disabled
+                                                 * 1 enabled
+                                                 */
+#define HASH_ADDR_MASK              0x000001ff  /* 2331 HASH_ADDR Hash table address code.
+                                                 */
+
+/* Transmit Inter-Packet Gap Length Register (TX_IPG_LENGTH) */
+#define TX_IPG_LENGTH_MASK          0x000003ff
+
+/* Interrupt Mask Register (IMASK) */
+#define IMASK_MDIO_SCAN_EVENTMDIO   0x00010000  /* MDIO_SCAN_EVENTMDIO scan event interrupt mask.
+                                                 * 0 masked
+                                                 * 1 enabled
+                                                 */
+#define IMASK_MDIO_CMD_CMPL         0x00008000  /* 16 MDIO_CMD_CMPL MDIO command completion interrupt mask.
+                                                 * 0 masked
+                                                 * 1 enabled
+                                                 */
+#define IMASK_REM_FAULT             0x00004000  /* 17 REM_FAULT Remote fault interrupt mask.
+                                                 * 0 masked
+                                                 * 1 enabled
+                                                 */
+#define IMASK_LOC_FAULT             0x00002000  /* 18 LOC_FAULT Local fault interrupt mask.
+                                                 * 0 masked
+                                                 * 1 enabled
+                                                 */
+#define IMASK_1TX_ECC_ER            0x00001000  /* 19 TX_ECC_ER Transmit frame ECC error interrupt mask.
+                                                 * 0 masked
+                                                 * 1 enabled
+                                                 */
+#define IMASK_TX_FIFO_UNFL          0x00000800  /* 20 TX_FIFO_UNFL Transmit FIFO underflow interrupt mask.
+                                                 * 0 masked
+                                                 * 1 enabled
+                                                 */
+#define IMASK_TX_FIFO_OVFL          0x00000400  /* 21 TX_FIFO_OVFL Transmit FIFO overflow interrupt mask.
+                                                 * 0 masked
+                                                 * 1 enabled
+                                                 */
+#define IMASK_TX_ER                 0x00000200  /* 22 TX_ER Transmit frame error interrupt mask.
+                                                 * 0 masked
+                                                 * 1 enabled
+                                                 */
+#define IMASK_RX_FIFO_OVFL          0x00000100  /* 23 RX_FIFO_OVFL Receive FIFO overflow interrupt mask.
+                                                 * 0 masked
+                                                 * 1 enabled
+                                                 */
+#define IMASK_RX_ECC_ER             0x00000080  /* 24 RX_ECC_ER Receive frame ECC error interrupt mask.
+                                                 * 0 masked
+                                                 * 1 enabled
+                                                 */
+#define IMASK_RX_JAB_FRM            0x00000040  /* 25 RX_JAB_FRM Receive jabber frame interrupt mask.
+                                                 * 0 masked
+                                                 * 1 enabled
+                                                 */
+#define IMASK_RX_OVRSZ_FRM          0x00000020  /* 26 RX_OVRSZ_FRM Receive oversized frame interrupt mask.
+                                                 * 0 masked
+                                                 * 1 enabled
+                                                 */
+#define IMASK_RX_RUNT_FRM           0x00000010  /* 27 RX_RUNT_FRM Receive runt frame interrupt mask.
+                                                 * 0 masked
+                                                 * 1 enabled
+                                                 */
+#define IMASK_RX_FRAG_FRM           0x00000008  /* 28 RX_FRAG_FRM Receive fragment frame interrupt mask.
+                                                 * 0 masked
+                                                 * 1 enabled
+                                                 */
+#define IMASK_RX_LEN_ER             0x00000004  /* 29 RX_LEN_ER Receive payload length error interrupt mask.
+                                                 * 0 masked
+                                                 * 1 enabled
+                                                 */
+#define IMASK_RX_CRC_ER             0x00000002  /* 30 RX_CRC_ER Receive CRC error interrupt mask.
+                                                 * 0 masked
+                                                 * 1 enabled
+                                                 */
+#define IMASK_RX_ALIGN_ER           0x00000001  /* 31 RX_ALIGN_ER Receive alignment error interrupt mask.
+                                                 * 0 masked
+                                                 * 1 enabled
+                                                 */
+
+#ifdef TBD
+#define IEVENT_MDIO_SCAN_EVENTMDIO  IMASK_MDIO_SCAN_EVENTMDIO
+#define IEVENT_MDIO_CMD_CMPL        IMASK_MDIO_CMD_CMPL
+#define IEVENT_REM_FAULT            IMASK_REM_FAULT
+#define IEVENT_LOC_FAULT            IMASK_LOC_FAULT
+#define IEVENT_TX_ECC_ER            IMASK_1TX_ECC_ER
+#define IEVENT_TX_FIFO_UNFL         IMASK_TX_FIFO_UNFL
+#define IEVENT_TX_FIFO_OVFL         IMASK_TX_FIFO_OVFL
+#define IEVENT_TX_ER                IMASK_TX_ER
+#define IEVENT_RX_FIFO_OVFL         IMASK_RX_FIFO_OVFL
+#define IEVENT_RX_ECC_ER            IMASK_RX_ECC_ER
+#define IEVENT_RX_JAB_FRM           IMASK_RX_JAB_FRM
+#define IEVENT_RX_OVRSZ_FRM         IMASK_RX_OVRSZ_FRM
+#define IEVENT_RX_RUNT_FRM          IMASK_RX_RUNT_FRM
+#define IEVENT_RX_FRAG_FRM          IMASK_RX_FRAG_FRM
+#define IEVENT_RX_LEN_ER            IMASK_RX_LEN_ER
+#define IEVENT_RX_CRC_ER            IMASK_RX_CRC_ER
+#define IEVENT_RX_ALIGN_ER          IMASK_RX_ALIGN_ER
+#endif
+
+
+#ifdef __MWERKS__
+#pragma pack(push,1)
+#endif /*__MWERKS__ */
+#define MEM_MAP_START
+
+/*
+ * 10G memory map
+ */
+typedef _Packed struct {
+/* 10Ge General Control and Status */
+    volatile uint32_t   tgec_id;            /* 0x000 10GEC_IDController ID register */
+    volatile uint32_t   scratch;            /* 0x004  */
+    volatile uint32_t   cmd_conf_ctrl;      /* 0x008 COMMAND_CONFIGControl and configuration register */
+    volatile uint32_t   mac_addr_0;         /* 0x00C MAC_ADDR_0Lower 32 bits of the first 48-bit MAC address */
+    volatile uint32_t   mac_addr_1;         /* 0x010 MAC_ADDR_1Upper 16 bits of the first 48-bit MAC address */
+    volatile uint32_t   maxfrm;             /* 0x014 MAXFRMMaximum frame length register */
+    volatile uint32_t   pause_quant;        /* 0x018 PAUSE_QUANTPause quanta register */
+    volatile uint32_t   rx_fifo_sections;   /* 0x01c  */
+    volatile uint32_t   tx_fifo_sections;   /* 0x020  */
+    volatile uint32_t   rx_fifo_almost_f_e; /* 0x024  */
+    volatile uint32_t   tx_fifo_almost_f_e; /* 0x028  */
+    volatile uint32_t   hashtable_ctrl;     /* 0x02C HASHTABLE_CTRLHash table control register */
+    volatile uint32_t   mdio_cfg_status;    /* 0x030  */
+    volatile uint32_t   mdio_command;       /* 0x034  */
+    volatile uint32_t   mdio_data;          /* 0x038  */
+    volatile uint32_t   mdio_regaddr;       /* 0x03c  */
+    volatile uint32_t   status;             /* 0x040  */
+    volatile uint32_t   tx_ipg_len;         /* 0x044 TX_IPG_LENGTHTransmitter inter-packet-gap register */
+    volatile uint32_t   mac_addr_2;         /* 0x048 MAC_ADDR_2Lower 32 bits of the second 48-bit MAC address */
+    volatile uint32_t   mac_addr_3;         /* 0x04C MAC_ADDR_3Upper 16 bits of the second 48-bit MAC address */
+    volatile uint32_t   rx_fifo_ptr_rd;     /* 0x050  */
+    volatile uint32_t   rx_fifo_ptr_wr;     /* 0x054  */
+    volatile uint32_t   tx_fifo_ptr_rd;     /* 0x058  */
+    volatile uint32_t   tx_fifo_ptr_wr;     /* 0x05c  */
+    volatile uint32_t   imask;              /* 0x060 IMASKInterrupt mask register */
+    volatile uint32_t   ievent;             /* 0x064 IEVENTInterrupt event register */
+    volatile uint32_t   udp_port;           /* 0x068 Defines a UDP Port number. When an UDP/IP frame is received with a matching UDP destination port, the receive status indication pin ff_rx_ts_frm will be asserted.*/
+    volatile uint32_t   type_1588v2;        /* 0x06c Type field for 1588v2 layer 2 frames. IEEE1588 defines the type 0x88f7 for 1588 frames. */
+    volatile uint32_t   TENGEC_RESERVED4[4];
+/*10Ge Statistics Counter */
+    volatile uint64_t   TFRM;        /* 80 aFramesTransmittedOK */
+    volatile uint64_t   RFRM;        /* 88 aFramesReceivedOK */
+    volatile uint64_t   RFCS;        /* 90 aFrameCheckSequenceErrors */
+    volatile uint64_t   RALN;        /* 98 aAlignmentErrors */
+    volatile uint64_t   TXPF;        /* A0 aPAUSEMACCtrlFramesTransmitted */
+    volatile uint64_t   RXPF;        /* A8 aPAUSEMACCtrlFramesReceived */
+    volatile uint64_t   RLONG;       /* B0 aFrameTooLongErrors */
+    volatile uint64_t   RFLR;        /* B8 aInRangeLengthErrors */
+    volatile uint64_t   TVLAN;       /* C0 VLANTransmittedOK */
+    volatile uint64_t   RVLAN;       /* C8 VLANReceivedOK */
+    volatile uint64_t   TOCT;        /* D0 ifOutOctets */
+    volatile uint64_t   ROCT;        /* D8 ifInOctets */
+    volatile uint64_t   RUCA;        /* E0 ifInUcastPkts */
+    volatile uint64_t   RMCA;        /* E8 ifInMulticastPkts */
+    volatile uint64_t   RBCA;        /* F0 ifInBroadcastPkts */
+    volatile uint64_t   TERR;        /* F8 ifOutErrors */
+    volatile uint32_t   TENGEC_RESERVED6[2];
+    volatile uint64_t   TUCA;        /* 108 ifOutUcastPkts */
+    volatile uint64_t   TMCA;        /* 110 ifOutMulticastPkts */
+    volatile uint64_t   TBCA;        /* 118 ifOutBroadcastPkts */
+    volatile uint64_t   RDRP;        /* 120 etherStatsDropEvents */
+    volatile uint64_t   REOCT;       /* 128 etherStatsOctets */
+    volatile uint64_t   RPKT;        /* 130 etherStatsPkts */
+    volatile uint64_t   TRUND;       /* 138 etherStatsUndersizePkts */
+    volatile uint64_t   R64;         /* 140 etherStatsPkts64Octets */
+    volatile uint64_t   R127;        /* 148 etherStatsPkts65to127Octets */
+    volatile uint64_t   R255;        /* 150 etherStatsPkts128to255Octets */
+    volatile uint64_t   R511;        /* 158 etherStatsPkts256to511Octets */
+    volatile uint64_t   R1023;       /* 160 etherStatsPkts512to1023Octets */
+    volatile uint64_t   R1518;       /* 168 etherStatsPkts1024to1518Octets */
+    volatile uint64_t   R1519X;      /* 170 etherStatsPkts1519toX */
+    volatile uint64_t   TROVR;       /* 178 etherStatsOversizePkts */
+    volatile uint64_t   TRJBR;       /* 180 etherStatsJabbers */
+    volatile uint64_t   TRFRG;       /* 188 etherStatsFragments */
+    volatile uint64_t   RERR;        /* 190 ifInErrors */
+} _PackedType t_TgecMemMap;
+
+#define MEM_MAP_END
+#ifdef __MWERKS__
+#pragma pack(pop)
+#endif /* __MWERKS__ */
+
+
+typedef struct {
+    bool wanModeEnable;             /* WAN Mode Enable. Sets WAN mode (1) or LAN mode (0, default) of operation. */
+    bool promiscuousModeEnable;     /* Enables MAC promiscuous operation. When set to '1', all frames are received without any MAC address filtering, when set to '0' (Reset value) Unicast Frames with a destination address not matching the Core MAC Address (MAC Address programmed in Registers MAC_ADDR_0 and MAC_ADDR_1 or the MAC address programmed in Registers MAC_ADDR_2 and MAC_ADDR_3 ) are rejected. */
+    bool padRemovalEnable;          /* Enable Frame Padding Removal in receive path. If set to '1', padding is removed before the frame is conveyed to the MAC Client application. If set to '0' (Reset value) no padding is removed on receive by the MAC. */
+    bool crcForwardEnable;          /* Terminate / Forward Received CRC. If set to '1' the CRC field of received frames is forwarded with the frame to the user application. If set to '1' (Reset value) the CRC field is stripped from the frame. */
+    bool pauseForwardEnable;        /* Terminate / Forward Pause Frames. If set to '1' pause frames are forwarded to the user application. When set to '0' (Reset value) pause frames are terminated and discarded within the MAC. */
+    bool pauseIgnore;               /* Ignore Pause Frame Quanta. If set to '1' received pause frames are ignored by the MAC. When set to '0' (Reset value) the transmit process is stopped for the amount of time specified in the pause quanta received within a pause frame. */
+    bool txAddrInsEnable;           /* Set Source MAC Address on Transmit.
+                                        If set to '1' the MAC overwrites the source MAC address received from the Client Interface with one of the MAC addresses (Refer to section 10.4)
+                                        If set to '0' (Reset value), the source MAC address from the Client Interface is transmitted unmodified to the line. */
+    bool loopbackEnable;            /* PHY Interface Loopback. When set to '1', the signal loop_ena is set to '1', when set to '0' (Reset value) the signal loop_ena is set to '0'. */
+    bool cmdFrameEnable;            /* Enables reception of all command frames. When set to '1' all Command Frames are accepted, when set to '0' (Reset Value) only Pause Frames are accepted and all other Command Frames are rejected. */
+    bool rxErrorDiscard;            /* Receive Errored Frame Discard Enable. When set to 1, any frame received with an error is discarded in the Core and not forwarded to the Client interface. When set to 0 (Reset value), errored Frames are forwarded to the Client interface with ff_rx_err asserted. */
+    bool phyTxenaOn;                /* PHY Transmit Enable. When set to '1', the signal phy_txena is set to '1', when set to '0' (Reset value) the signal phy_txena is set to '0' */
+    bool sendIdleEnable;            /* Force Idle Generation. When set to '1', the MAC permanently sends XGMII Idle sequences even when faults are received. */
+    bool noLengthCheckEnable;       /* Payload Length Check Disable. When set to 0 (Reset value), the Core checks the frame's payload length with the Frame Length/Type field, when set to 1, the payload length check is disabled. */
+    bool lgthCheckNostdr;           /* The Core interprets the Length/Type field differently depending on the value of this Bit */
+    bool timeStampEnable;           /* This bit selects between enabling and disabling the IEEE 1588 functionality.
+                                        1: IEEE 1588 is enabled.
+                                        0: IEEE 1588 is disabled. */
+    bool rxSfdAny;                  /* Enables, when set, that any character is allowed at the SFD position of the preamble and the frame will be accepted.
+                                        If cleared (default) the frame is accepted only if the 8th byte of the preamble contains the SFD value 0xd5. If another value is received, the frame is discarded and the alignment error counter increments. */
+    bool rxPblFwd;                  /* Receive Preamble Forwarding (custom preamble).
+                                        If set, the first word (ff_rx_sop) of every received frame contains the preamble of the frame. The frame data starts with the 2nd word from the FIFO.
+                                        If the bit is cleared (default) the preamble is removed from the frame before it is written into the receive FIFO. */
+    bool txPblFwd;                  /* Transmit Preamble Forwarding (custom preamble).
+                                        If set, the first word written into the TX FIFO is considered as frame preamble. The MAC will not add a preamble in front of the frame. Note that bits 7:0 of the preamble word will still be overwritten with the XGMII start character upon transmission.
+                                        If cleared (default) the MAC */
+    uint32_t txIpgLength;           /*Transmit Inter-Packet-Gap (IPG) value.
+                                      A 6-bit value: Depending on LAN or WAN mode of operation (see COMMAND_CONFIG, 19.2.1 page 91) the value has the following meaning:
+                                         LAN Mode: Number of octets in steps of 4. Valid values are 8, 12, 16, ... 100. DIC is fully supported (see 10.6.1 page 49) for any setting. A default of 12 (reset value) must be set to conform to IEEE802.3ae. Warning: When set to 8, PCS layers may not be able to perform clock rate compensation.
+                                         WAN Mode: Stretch factor. Valid values are 4..15. The stretch factor is calculated as (value+1)*8. A default of 12 (reset value) must be set to conform to IEEE 802.3ae (i.e. 13*8=104). A larger value shrinks the IPG (increasing bandwidth). */
+/*.. */
+    bool        statisticsEnable;
+    uint16_t    maxFrameLength;
+    bool        padAndCrcEnable;
+    bool        debugMode;
+    uint16_t    pauseTime;
+
+#if 0
+    uint32_t    imask;
+#endif
+
+} t_TgecDriverParam;
+
+typedef struct {
+    t_FmMacControllerDriver     fmMacControllerDriver;              /**< Upper Mac control block */
+    t_Handle                    h_App;                              /**< Handle to the upper layer application  */
+    t_TgecMemMap                *p_MemMap;                          /**< pointer to 10G memory mapped registers. */
+    t_TgecMiiAccessMemMap       *p_MiiMemMap;                       /**< pointer to MII memory mapped registers.          */
+    uint64_t                    addr;                               /**< MAC address of device; */
+    e_EnetMode                  enetMode;                           /**< Ethernet physical interface  */
+    t_FmMacExceptionCallback    *f_Exceptions;
+    bool                        indAddrRegUsed[TGEC_NUM_OF_PADDRS]; /**< Whether a particular individual address recognition register is being used */
+    uint64_t                    paddr[TGEC_NUM_OF_PADDRS];          /**< MAC address for particular individual address recognition register */
+    uint8_t                     numOfIndAddrInRegs;                 /**< Number of individual addresses in registers for this station. */
+    t_EthHash                   *p_MulticastAddrHash;               /**< pointer to driver's global address hash table  */
+    t_EthHash                   *p_UnicastAddrHash;                 /**< pointer to driver's individual address hash table  */
+    bool                        debugMode;
+    uint8_t                     macId;
+    t_TgecDriverParam           *p_TgecDriverParam;
+} t_Tgec;
+
+t_Error TGEC_MII_WritePhyReg(t_Handle h_Tgec, uint8_t phyAddr, uint8_t reg, uint16_t data);
+t_Error TGEC_MII_ReadPhyReg(t_Handle h_Tgec,  uint8_t phyAddr, uint8_t reg, uint16_t *p_Data);
+
+
+#endif /* __TGEC_H */
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/tgec_mii_acc.c b/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/tgec_mii_acc.c
new file mode 100644
index 0000000..5ea63ff
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/tgec_mii_acc.c
@@ -0,0 +1,103 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+
+#include "error_ext.h"
+#include "std_ext.h"
+#include "fm_mac.h"
+#include "tgec.h"
+#include "xx_ext.h"
+
+
+/*****************************************************************************/
+t_Error TGEC_MII_WritePhyReg(t_Handle h_Tgec,
+                        uint8_t     phyAddr,
+                        uint8_t     reg,
+                        uint16_t    data)
+{
+    t_Tgec                  *p_Tgec = (t_Tgec *)h_Tgec;
+    t_TgecMiiAccessMemMap   *p_MiiAccess;
+
+    SANITY_CHECK_RETURN_ERROR(p_Tgec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Tgec->p_MiiMemMap, E_INVALID_HANDLE);
+
+    p_MiiAccess = p_Tgec->p_MiiMemMap;
+
+    while ((GET_UINT32(p_MiiAccess->mdio_cfg_status)) & MIIMIND_BUSY)
+        XX_UDelay (1);
+
+    WRITE_UINT32(p_MiiAccess->mdio_command, phyAddr);
+
+    WRITE_UINT32(p_MiiAccess->mdio_regaddr, reg);
+
+    while ((GET_UINT32(p_MiiAccess->mdio_cfg_status)) & MIIMIND_BUSY)
+        XX_UDelay (1);
+
+    WRITE_UINT32(p_MiiAccess->mdio_data, data);
+
+    return E_OK;
+}
+
+
+/*****************************************************************************/
+t_Error TGEC_MII_ReadPhyReg(t_Handle h_Tgec,
+                   uint8_t  phyAddr,
+                   uint8_t  reg,
+                   uint16_t *p_Data)
+{
+    t_Tgec             *p_Tgec = (t_Tgec *)h_Tgec;
+    t_TgecMiiAccessMemMap   *p_MiiAccess;
+
+    SANITY_CHECK_RETURN_ERROR(p_Tgec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Tgec->p_MiiMemMap, E_INVALID_HANDLE);
+
+    p_MiiAccess = p_Tgec->p_MiiMemMap;
+
+    while ((GET_UINT32(p_MiiAccess->mdio_cfg_status)) & MIIMIND_BUSY)
+        XX_UDelay (1);
+
+    WRITE_UINT32(p_MiiAccess->mdio_command, phyAddr);
+
+    WRITE_UINT32(p_MiiAccess->mdio_regaddr, reg);
+
+    while ((GET_UINT32(p_MiiAccess->mdio_cfg_status)) & MIIMIND_BUSY)
+        XX_UDelay (1);
+
+    WRITE_UINT32(p_MiiAccess->mdio_command, (uint32_t)(phyAddr | MIIMCOM_READ_CYCLE));
+
+    while ((GET_UINT32(p_MiiAccess->mdio_cfg_status)) & MIIMIND_BUSY)
+        XX_UDelay (1);
+
+    *p_Data =  (uint16_t)GET_UINT32(p_MiiAccess->mdio_data);
+
+    return E_OK;
+}
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/tgec_mii_acc.h b/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/tgec_mii_acc.h
new file mode 100644
index 0000000..a7808c6
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/tgec_mii_acc.h
@@ -0,0 +1,60 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __MII_ACC_H
+#define __MII_ACC_H
+
+/* #define __ERR_MODULE__ MODULE_MII */
+
+/* MII  Management Command Register */
+#define MIIMCOM_READ_POST_INCREMENT 0x00004000
+#define MIIMCOM_READ_CYCLE          0x00008000
+#define MIIMCOM_SCAN_CYCLE          0x00000800
+#define MIIMCOM_PREAMBLE_DISABLE    0x00000400
+
+/* MII Management Indicator Register */
+#define MIIMIND_BUSY                0x00000001
+#define MIIMIND_READ_ERROR          0x00000002
+
+/*----------------------------------------------------*/
+/* MII Configuration Control Memory Map Registers     */
+/*----------------------------------------------------*/
+typedef _Packed struct t_TgecMiiAccessMemMap
+{
+    volatile uint32_t   mdio_cfg_status;    /* 0x030  */
+    volatile uint32_t   mdio_command;       /* 0x034  */
+    volatile uint32_t   mdio_data;          /* 0x038  */
+    volatile uint32_t   mdio_regaddr;       /* 0x03c  */
+} _PackedType t_TgecMiiAccessMemMap ;
+
+
+#endif /* __MII_ACC_H */
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/Makefile b/drivers/net/dpa/NetCommSw/Peripherals/FM/Makefile
new file mode 100644
index 0000000..97f3472
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/Makefile
@@ -0,0 +1,20 @@
+#
+# Makefile for the Freescale Ethernet controllers
+#
+EXTRA_CFLAGS           += -DVERSION=\"\"
+#
+#Include netcomm SW specific definitions
+include $(srctree)/drivers/net/dpa/NetCommSw/ncsw_config.mk
+NCSW_FM_INC = $(srctree)/drivers/net/dpa/NetCommSw/Peripherals/FM/inc
+
+EXTRA_CFLAGS += -I$(NCSW_FM_INC)
+
+
+obj-y		+= fsl-ncsw-PFM1.o
+
+fsl-ncsw-PFM1-objs	:=   fm.o fm_muram.o
+
+obj-y		+= MAC/
+obj-y		+= Pcd/
+obj-y		+= Port/
+obj-y		+= HC/
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/Makefile b/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/Makefile
new file mode 100644
index 0000000..9d05f1a
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/Makefile
@@ -0,0 +1,19 @@
+#
+# Makefile for the Freescale Ethernet controllers
+#
+EXTRA_CFLAGS           += -DVERSION=\"\"
+#
+#Include netcomm SW specific definitions
+include $(srctree)/drivers/net/dpa/NetCommSw/ncsw_config.mk
+
+NCSW_FM_INC = $(srctree)/drivers/net/dpa/NetCommSw/Peripherals/FM/inc
+
+EXTRA_CFLAGS += -I$(NCSW_FM_INC)
+
+obj-y		+= fsl-ncsw-Pcd.o
+
+fsl-ncsw-Pcd-objs	:=   fm_cc.o fm_kg.o fm_pcd.o fm_plcr.o fm_prs.o
+
+
+
+
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.c b/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.c
new file mode 100644
index 0000000..0bd6330
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.c
@@ -0,0 +1,2967 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/******************************************************************************
+ @File          fm_cc.c
+
+ @Description   FM CC ...
+*//***************************************************************************/
+#include "std_ext.h"
+#include "error_ext.h"
+#include "string_ext.h"
+#include "debug_ext.h"
+
+#include "fm_pcd_ext.h"
+#include "fm_muram_ext.h"
+#include "fm_hc.h"
+
+#include "fm_pcd.h"
+
+
+t_Error FmPcdCcTreeTryLock(t_Handle h_FmPcdCcTree)
+{
+    TRY_LOCK_RET_ERR(((t_FmPcdCcTree *)h_FmPcdCcTree)->lock);
+    return E_OK;
+}
+void FmPcdCcTreeReleaseLock(t_Handle h_FmPcdCcTree)
+{
+    RELEASE_LOCK(((t_FmPcdCcTree *)h_FmPcdCcTree)->lock);
+}
+
+static void EnqueueAdditionalInfoToRelevantLst(t_List *p_CcNode, t_CcNodeInfo *p_CcInfo)
+{
+    uint32_t   intFlags;
+
+    intFlags = XX_DisableAllIntr();
+    LIST_AddToTail(&p_CcInfo->h_Node, p_CcNode);
+    XX_RestoreAllIntr(intFlags);
+}
+
+static void CreateNodeInfo(t_List *p_List, uint32_t info)
+{
+        t_CcNodeInfo *p_CcInfo;
+
+        p_CcInfo = (t_CcNodeInfo *)XX_Malloc(sizeof(t_CcNodeInfo));
+        if(!p_CcInfo)
+            REPORT_ERROR(MAJOR, E_NO_MEMORY, ("No memory"));
+        memset(p_CcInfo, 0, sizeof(t_CcNodeInfo));
+        INIT_LIST(&p_CcInfo->h_Node);
+        p_CcInfo->nextCcNodeInfo = (uint32_t)info;
+        EnqueueAdditionalInfoToRelevantLst(p_List, p_CcInfo);
+}
+
+static t_CcNodeInfo * FindNodeInfoAccIndex(t_List *p_List, uint16_t indx)
+{
+    t_CcNodeInfo   *p_CcNodeInfo = NULL;
+    t_List      *p_Pos;
+
+    LIST_FOR_EACH(p_Pos, p_List)
+    {
+        p_CcNodeInfo = CC_NEXT_NODE_F_OBJECT(p_Pos);
+        if((p_CcNodeInfo->nextCcNodeInfo >> 16) == indx)
+            return   p_CcNodeInfo;
+    }
+    return NULL;
+}
+
+static t_CcNodeInfo * FindNodeInfoAccId(t_List *p_List, uint16_t indx)
+{
+    t_CcNodeInfo   *p_CcNodeInfo = NULL;
+    t_List      *p_Pos;
+
+    LIST_FOR_EACH(p_Pos, p_List)
+    {
+        p_CcNodeInfo = CC_NEXT_NODE_F_OBJECT(p_Pos);
+        if(((uint16_t)p_CcNodeInfo->nextCcNodeInfo) == indx)
+            return   p_CcNodeInfo;
+    }
+    return NULL;
+}
+
+static t_CcNodeInfo * DequeueAdditionalInfoFromRelevantLst(t_List *p_List)
+{
+    t_CcNodeInfo   *p_CcNodeInfo = NULL;
+    uint32_t        intFlags;
+
+    intFlags = XX_DisableAllIntr();
+    if (!LIST_IsEmpty(p_List))
+    {
+        p_CcNodeInfo = CC_NEXT_NODE_F_OBJECT(p_List->p_Next);
+        LIST_DelAndInit(&p_CcNodeInfo->h_Node);
+    }
+    XX_RestoreAllIntr(intFlags);
+    return p_CcNodeInfo;
+}
+
+static void ReleaseLst(t_List *p_List)
+{
+    t_CcNodeInfo   *p_CcNodeInfo = NULL;
+
+    if(!LIST_IsEmpty(p_List))
+    {
+        p_CcNodeInfo = DequeueAdditionalInfoFromRelevantLst(p_List);
+        while (p_CcNodeInfo)
+        {
+            XX_Free(p_CcNodeInfo);
+            p_CcNodeInfo = DequeueAdditionalInfoFromRelevantLst(p_List);
+        }
+    }
+    LIST_DelAndInit(p_List);
+}
+
+static void ReleaseNodeHandler(t_FmPcdCcNode *p_FmPcdCcNode, t_FmPcdCc *p_FmPcdCc)
+{
+
+    if(p_FmPcdCcNode)
+    {
+            if(p_FmPcdCcNode->p_GlblMask)
+            {
+                XX_Free(p_FmPcdCcNode->p_GlblMask);
+                p_FmPcdCcNode->p_GlblMask = NULL;
+            }
+            if(p_FmPcdCcNode->h_KeysMatchTable)
+            {
+                FM_MURAM_FreeMem(p_FmPcdCc->h_FmMuram,p_FmPcdCcNode->h_KeysMatchTable);
+                p_FmPcdCcNode->h_KeysMatchTable = NULL;
+            }
+            if(p_FmPcdCcNode->h_AdTable)
+            {
+                FM_MURAM_FreeMem(p_FmPcdCc->h_FmMuram,p_FmPcdCcNode->h_AdTable);
+                p_FmPcdCcNode->h_AdTable = NULL;
+            }
+
+            ReleaseLst(&p_FmPcdCcNode->ccNextNodesLst);
+            ReleaseLst(&p_FmPcdCcNode->ccPrevNodesLst);
+            ReleaseLst(&p_FmPcdCcNode->ccTreeIdLst);
+            ReleaseLst(&p_FmPcdCcNode->ccTreesLst);
+
+
+            XX_Free(p_FmPcdCcNode);
+    }
+}
+
+static t_CcNodeInfo * FindNodeInfoAccIdAndAddToRetLst(t_List *p_List, uint16_t nodeId,  t_List *p_ReturnList)
+{
+    t_CcNodeInfo   *p_CcNodeInfo = NULL;
+    t_List      *p_Pos;
+
+    LIST_FOR_EACH(p_Pos, p_List)
+    {
+        p_CcNodeInfo = CC_NEXT_NODE_F_OBJECT(p_Pos);
+        if(((uint16_t)p_CcNodeInfo->nextCcNodeInfo) == nodeId)
+            CreateNodeInfo(p_ReturnList, p_CcNodeInfo->nextCcNodeInfo);
+    }
+    return NULL;
+}
+
+static void  UpdateNodeOwner(t_FmPcd  *p_FmPcd, uint16_t nodeId, bool add)
+{
+    ASSERT_COND(nodeId < MAX_NUM_OF_PCD_CC_NODES);
+    if(add)
+        p_FmPcd->p_FmPcdCc->ccNodeArrayEntry[nodeId].owners++;
+    else
+    {
+        ASSERT_COND(p_FmPcd->p_FmPcdCc->ccNodeArrayEntry[nodeId].owners);
+        p_FmPcd->p_FmPcdCc->ccNodeArrayEntry[nodeId].owners--;
+    }
+}
+
+static t_Handle GetNodeHandler(t_FmPcd *p_FmPcd, uint16_t nodeId)
+{
+    ASSERT_COND(nodeId < MAX_NUM_OF_PCD_CC_NODES);
+    return p_FmPcd->p_FmPcdCc->ccNodeArrayEntry[nodeId].p_FmPcdCcNode;
+
+}
+
+static void SetNodeHandler(t_Handle h_FmPcdCc, uint16_t nodeId, t_Handle p_FmPcdCcNode)
+{
+    t_FmPcdCc *p_FmPcdCc = (t_FmPcdCc*)h_FmPcdCc;
+
+    ASSERT_COND(!p_FmPcdCc->ccNodeArrayEntry[nodeId].p_FmPcdCcNode);
+    p_FmPcdCc->ccNodeArrayEntry[nodeId].p_FmPcdCcNode = p_FmPcdCcNode;
+}
+
+static t_Handle FmPcdCcGetTreeHandler(t_Handle h_FmPcd, uint8_t treeId)
+{
+
+    ASSERT_COND(treeId < MAX_NUM_OF_PCD_CC_TREES);
+    return ((t_FmPcd*)h_FmPcd)->p_FmPcdCc->ccTreeArrayEntry[treeId].p_FmPcdCcTree;
+}
+
+static void SetTreeHandler(t_Handle h_FmPcdCc, uint8_t treeId, t_Handle p_FmPcdCcTree)
+{
+    t_FmPcdCc *p_FmPcdCc = (t_FmPcdCc*)h_FmPcdCc;
+
+    ASSERT_COND(!p_FmPcdCc->ccTreeArrayEntry[treeId].p_FmPcdCcTree);
+    p_FmPcdCc->ccTreeArrayEntry[treeId].p_FmPcdCcTree = p_FmPcdCcTree;
+}
+
+
+static uint8_t GetTreeOwners(t_FmPcd *p_FmPcd, uint8_t treeId)
+{
+    ASSERT_COND(treeId < MAX_NUM_OF_PCD_CC_TREES);
+    return p_FmPcd->p_FmPcdCc->ccTreeArrayEntry[treeId].owners;
+}
+
+static uint8_t GetNodeOwners(t_FmPcd *p_FmPcd, uint16_t nodeId)
+{
+    ASSERT_COND(nodeId < MAX_NUM_OF_PCD_CC_NODES);
+    return p_FmPcd->p_FmPcdCc->ccNodeArrayEntry[nodeId].owners;
+}
+
+
+static t_Error OccupyNodeId(t_FmPcd *p_FmPcd, uint16_t *nodeId)
+{
+    uint16_t i = 0;
+
+    TRY_LOCK_RET_ERR(p_FmPcd->lock);
+    for(i = 0; i < MAX_NUM_OF_PCD_CC_NODES; i++)
+    {
+        if(!p_FmPcd->p_FmPcdCc->ccNodeArrayEntry[i].occupied && !p_FmPcd->p_FmPcdCc->ccNodeArrayEntry[i].p_FmPcdCcNode)
+        {
+            *nodeId = i;
+            p_FmPcd->p_FmPcdCc->ccNodeArrayEntry[i].occupied = TRUE;
+            RELEASE_LOCK(p_FmPcd->lock)
+           return E_OK;
+        }
+
+    }
+    RELEASE_LOCK(p_FmPcd->lock)
+    RETURN_ERROR(MAJOR, E_NOT_AVAILABLE, ("asked for more nodes in CC than MAX"))  ;
+}
+
+static t_Error OccupyTreeId(t_FmPcd *p_FmPcd, uint8_t *treeId)
+{
+    uint16_t i = 0;
+
+    TRY_LOCK_RET_ERR(p_FmPcd->lock);
+    for(i = 0; i < MAX_NUM_OF_PCD_CC_NODES; i++)
+    {
+        if(!p_FmPcd->p_FmPcdCc->ccTreeArrayEntry[i].occupied && !p_FmPcd->p_FmPcdCc->ccTreeArrayEntry[i].p_FmPcdCcTree)
+        {
+            *treeId = (uint8_t)i;
+            p_FmPcd->p_FmPcdCc->ccTreeArrayEntry[i].occupied = TRUE;
+            RELEASE_LOCK(p_FmPcd->lock)
+           return E_OK;
+        }
+
+    }
+    RELEASE_LOCK(p_FmPcd->lock)
+    RETURN_ERROR(MAJOR, E_NOT_AVAILABLE, ("asked for more nodes in CC than MAX"))  ;
+}
+
+
+
+static bool CcNodeIsValid(t_FmPcd *p_FmPcd, uint16_t nodeId)
+{
+    t_FmPcdCc *p_FmPcdCc = p_FmPcd->p_FmPcdCc;
+
+    ASSERT_COND(nodeId < MAX_NUM_OF_PCD_CC_NODES);
+
+    if(!p_FmPcdCc->ccNodeArrayEntry[nodeId].occupied ||
+        !p_FmPcdCc->ccNodeArrayEntry[nodeId].p_FmPcdCcNode)
+        return FALSE;
+    else
+        return TRUE;
+}
+
+static void  GetCcExtractKeySize(uint8_t parseCodeRealSize, uint8_t *parseCodeCcSize)
+{
+    if((parseCodeRealSize > 0) && (parseCodeRealSize < 2))
+        *parseCodeCcSize = 1;
+    else if(parseCodeRealSize == 2)
+        *parseCodeCcSize = 2;
+    else if((parseCodeRealSize > 2)    && (parseCodeRealSize <= 4))
+        *parseCodeCcSize = 4;
+    else if((parseCodeRealSize > 4)    && (parseCodeRealSize <= 8))
+        *parseCodeCcSize = 8;
+    else if((parseCodeRealSize > 8)    && (parseCodeRealSize <= 16))
+        *parseCodeCcSize = 16;
+    else if((parseCodeRealSize  > 16)  && (parseCodeRealSize <= 24))
+        *parseCodeCcSize = 24;
+    else if((parseCodeRealSize  > 24)  && (parseCodeRealSize <= 32))
+        *parseCodeCcSize = 32;
+    else if((parseCodeRealSize  > 32)  && (parseCodeRealSize <= 40))
+        *parseCodeCcSize = 40;
+    else if((parseCodeRealSize  > 40)  && (parseCodeRealSize <= 48))
+        *parseCodeCcSize = 48;
+    else if((parseCodeRealSize  > 48)  && (parseCodeRealSize <= 56))
+        *parseCodeCcSize = 56;
+    else
+        *parseCodeCcSize = 0;
+}
+
+static void  GetSizeHeaderField(e_NetHeaderType hdr,t_FmPcdFields field,uint8_t *parseCodeRealSize)
+{
+    switch(hdr)
+    {
+        case (HEADER_TYPE_ETH):
+            switch(field.eth)
+            {
+                case(NET_HEADER_FIELD_ETH_DA):
+                    *parseCodeRealSize = 6;
+                    break;
+                case(NET_HEADER_FIELD_ETH_SA):
+                    *parseCodeRealSize = 6;
+                    break;
+                case(NET_HEADER_FIELD_ETH_TYPE):
+                    *parseCodeRealSize = 2;
+                    break;
+                default:
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported1"));
+                    *parseCodeRealSize = CC_SIZE_ILLEGAL;
+                    break;
+            }
+        break;
+        case(HEADER_TYPE_PPPoE):
+            switch(field.pppoe)
+            {
+                case(NET_HEADER_FIELD_PPPoE_PID):
+                    *parseCodeRealSize = 2;
+                    break;
+                default:
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported1"));
+                    *parseCodeRealSize = CC_SIZE_ILLEGAL;
+                    break;
+            }
+        break;
+        case (HEADER_TYPE_VLAN):
+            switch(field.vlan)
+            {
+               case(NET_HEADER_FIELD_VLAN_TCI):
+                    *parseCodeRealSize = 2;
+                    break;
+                default:
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported2"));
+                    *parseCodeRealSize = CC_SIZE_ILLEGAL;
+                    break;
+            }
+        break;
+        case (HEADER_TYPE_MPLS):
+            switch(field.mpls)
+            {
+                case(NET_HEADER_FIELD_MPLS_LABEL_STACK):
+                    *parseCodeRealSize = 4;
+                    break;
+                default:
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported3"));
+                    *parseCodeRealSize = CC_SIZE_ILLEGAL;
+                    break;
+            }
+        break;
+        case (HEADER_TYPE_IPv4):
+            switch(field.ipv4)
+            {
+                case(NET_HEADER_FIELD_IPv4_DST_IP):
+                case(NET_HEADER_FIELD_IPv4_SRC_IP):
+                    *parseCodeRealSize = 4;
+                    break;
+                case(NET_HEADER_FIELD_IPv4_TOS):
+                case(NET_HEADER_FIELD_IPv4_PROTO):
+                    *parseCodeRealSize = 1;
+                    break;
+                case(NET_HEADER_FIELD_IPv4_DST_IP | NET_HEADER_FIELD_IPv4_SRC_IP):
+                    *parseCodeRealSize = 8;
+                    break;
+                case(NET_HEADER_FIELD_IPv4_TTL):
+                    *parseCodeRealSize = 1;
+                    break;
+                default:
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported4"));
+                    *parseCodeRealSize = CC_SIZE_ILLEGAL;
+                    break;
+            }
+        break;
+        case (HEADER_TYPE_IPv6):
+            switch(field.ipv6)
+            {
+                case(NET_HEADER_FIELD_IPv6_VER | NET_HEADER_FIELD_IPv6_FL | NET_HEADER_FIELD_IPv6_TC):
+                   *parseCodeRealSize = 4;
+                    break;
+                case(NET_HEADER_FIELD_IPv6_NEXT_HDR):
+                case(NET_HEADER_FIELD_IPv6_HOP_LIMIT):
+                   *parseCodeRealSize = 1;
+                    break;
+                case(NET_HEADER_FIELD_IPv6_DST_IP):
+                case(NET_HEADER_FIELD_IPv6_SRC_IP):
+                   *parseCodeRealSize = 16;
+                    break;
+                default:
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported5"));
+                    *parseCodeRealSize = CC_SIZE_ILLEGAL;
+                    break;
+            }
+        break;
+        case (HEADER_TYPE_GRE):
+            switch(field.gre)
+            {
+                case(NET_HEADER_FIELD_GRE_TYPE):
+                   *parseCodeRealSize = 2;
+                    break;
+                default:
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported6"));
+                    *parseCodeRealSize = CC_SIZE_ILLEGAL;
+                    break;
+            }
+        break;
+        case (HEADER_TYPE_MINENCAP):
+            switch(field.minencap)
+            {
+                case(NET_HEADER_FIELD_MINENCAP_TYPE):
+                   *parseCodeRealSize = 1;
+                    break;
+                case(NET_HEADER_FIELD_MINENCAP_DST_IP):
+                 case(NET_HEADER_FIELD_MINENCAP_SRC_IP):
+                  *parseCodeRealSize = 4;
+                    break;
+                 case(NET_HEADER_FIELD_MINENCAP_SRC_IP | NET_HEADER_FIELD_MINENCAP_DST_IP):
+                  *parseCodeRealSize = 8;
+                    break;
+                default:
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported7"));
+                    *parseCodeRealSize = CC_SIZE_ILLEGAL;
+                    break;
+            }
+        break;
+        case (HEADER_TYPE_TCP):
+            switch(field.tcp)
+            {
+                case(NET_HEADER_FIELD_TCP_PORT_SRC):
+                case(NET_HEADER_FIELD_TCP_PORT_DST):
+                   *parseCodeRealSize = 2;
+                    break;
+                 case(NET_HEADER_FIELD_TCP_PORT_SRC | NET_HEADER_FIELD_TCP_PORT_DST):
+                  *parseCodeRealSize = 4;
+                    break;
+                default:
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported8"));
+                    *parseCodeRealSize = CC_SIZE_ILLEGAL;
+                    break;
+            }
+        break;
+        case (HEADER_TYPE_UDP):
+            switch(field.udp)
+            {
+                case(NET_HEADER_FIELD_UDP_PORT_SRC):
+                case(NET_HEADER_FIELD_UDP_PORT_DST):
+                   *parseCodeRealSize = 2;
+                    break;
+                 case(NET_HEADER_FIELD_UDP_PORT_SRC | NET_HEADER_FIELD_UDP_PORT_DST):
+                  *parseCodeRealSize = 4;
+                    break;
+                default:
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported9"));
+                    *parseCodeRealSize = CC_SIZE_ILLEGAL;
+                    break;
+            }
+            break;
+       default:
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported10"));
+                    *parseCodeRealSize = CC_SIZE_ILLEGAL;
+                    break;
+    }
+}
+
+
+
+static void ReleaseNode(t_FmPcdCc *p_FmPcdCc, uint16_t nodeId)
+{
+    t_FmPcdCcNode *p_FmPcdCcNode;
+
+    if(p_FmPcdCc->ccNodeArrayEntry[nodeId].p_FmPcdCcNode)
+    {
+            p_FmPcdCcNode = (t_FmPcdCcNode *)p_FmPcdCc->ccNodeArrayEntry[nodeId].p_FmPcdCcNode;
+            ReleaseNodeHandler(p_FmPcdCcNode,p_FmPcdCc);
+            p_FmPcdCc->ccNodeArrayEntry[nodeId].p_FmPcdCcNode = NULL;
+    }
+    p_FmPcdCc->ccNodeArrayEntry[nodeId].occupied = FALSE;
+}
+
+static void ReleaseTreeHandler(t_FmPcdCcTree *p_FmPcdTreeNode, t_FmPcdCc *p_FmPcdCc)
+{
+
+    if(p_FmPcdTreeNode)
+    {
+        if(p_FmPcdTreeNode->p_CcBaseTree)
+        {
+            FM_MURAM_FreeMem(p_FmPcdCc->h_FmMuram,p_FmPcdTreeNode->p_CcBaseTree);
+            p_FmPcdTreeNode->p_CcBaseTree = NULL;
+        }
+
+
+        ReleaseLst(&p_FmPcdTreeNode->ccNextNodesLst);
+        ReleaseLst(&p_FmPcdTreeNode->fmPortsLst);
+
+        XX_Free(p_FmPcdTreeNode);
+        }
+}
+
+static void ReleaseTree(t_FmPcdCc *p_FmPcdCc, uint8_t treeId)
+{
+    t_FmPcdCcTree *p_FmPcdCcTree;
+
+    if(p_FmPcdCc->ccTreeArrayEntry[treeId].p_FmPcdCcTree)
+    {
+            p_FmPcdCcTree = p_FmPcdCc->ccTreeArrayEntry[treeId].p_FmPcdCcTree;
+            ReleaseTreeHandler(p_FmPcdCcTree,p_FmPcdCc);
+            p_FmPcdCc->ccTreeArrayEntry[treeId].p_FmPcdCcTree = NULL;
+    }
+    p_FmPcdCc->ccTreeArrayEntry[treeId].occupied = FALSE;
+}
+
+
+static t_Error ValidateNextEngineParams(t_Handle h_FmPcd, t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams, t_NextEngineParamsInfo *p_NextEngineParamsInfo)
+{
+    uint16_t                    absoluteProfileId;
+    t_Error                     err;
+    uint8_t                     relativeSchemeId;
+
+    p_NextEngineParamsInfo->fmPcdEngine = e_FM_PCD_DONE;
+
+     switch(p_FmPcdCcNextEngineParams->nextEngine)
+    {
+        case(e_FM_PCD_DONE):
+            if(p_FmPcdCcNextEngineParams->params.enqueueParams.ctrlFlow &&
+               !p_FmPcdCcNextEngineParams->params.enqueueParams.fqidForCtrlFlow)
+                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("not defined fqid for control flow for BMI next engine "));
+            if(p_FmPcdCcNextEngineParams->params.enqueueParams.fqidForCtrlFlow & ~0x00FFFFFF)
+                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fqidForCtrlFlow must be between 1 and 2^24-1"));
+            p_NextEngineParamsInfo->fmPcdEngine = e_FM_PCD_DONE;
+            break;
+        case(e_FM_PCD_KG):
+            relativeSchemeId = FmPcdKgGetRelativeSchemeId(h_FmPcd, (uint8_t)(CAST_POINTER_TO_UINT32(p_FmPcdCcNextEngineParams->params.kgParams.h_DirectScheme)-1));
+            if(relativeSchemeId == FM_PCD_KG_NUM_OF_SCHEMES)
+                RETURN_ERROR(MAJOR, E_NOT_IN_RANGE, NO_MSG);
+
+            if(!FmPcdKgIsSchemeValidSw(h_FmPcd, relativeSchemeId))
+                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("not valid schemeIndex in KG next engine param"));
+            if(!KgIsSchemeAlwaysDirect(h_FmPcd, relativeSchemeId))
+                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("CC Node may point only to a scheme that is always direct."));
+            p_NextEngineParamsInfo->fmPcdEngine = e_FM_PCD_KG;
+            break;
+        case(e_FM_PCD_PLCR):
+            if(p_FmPcdCcNextEngineParams->params.plcrParams.ctrlFlow)
+            {
+                /* if private policer profile, it may be uninitialized yet, therefor no checks are done at this stage */
+                if(p_FmPcdCcNextEngineParams->params.plcrParams.sharedProfile)
+                {
+                    err = FmPcdPlcrGetAbsoluteProfileId(h_FmPcd,e_FM_PCD_PLCR_SHARED,NULL,p_FmPcdCcNextEngineParams->params.plcrParams.relativeProfileIdForCtrlFlow, &absoluteProfileId);
+                    if(err)
+                        RETURN_ERROR(MAJOR, err, ("Shared profile offset is out of range"));
+                    if(!FmPcdPlcrIsProfileValid(h_FmPcd, absoluteProfileId))
+                        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid profile"));
+                    if(p_FmPcdCcNextEngineParams->params.plcrParams.fqidEnqForCtrlFlow &&  (!p_FmPcdCcNextEngineParams->params.plcrParams.fqidForCtrlFlowForEnqueueAfterPlcr ||
+                            p_FmPcdCcNextEngineParams->params.plcrParams.fqidForCtrlFlowForEnqueueAfterPlcr & ~0x00FFFFFF))
+                        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("fqidForCtrlFlowForEnqueueAfterPlcr  must be between 1 and 2^24-1"));
+                }
+                else
+                {
+                    p_NextEngineParamsInfo->fmPcdEngine = e_FM_PCD_PLCR;
+                    p_NextEngineParamsInfo->additionalInfo = p_FmPcdCcNextEngineParams->params.plcrParams.relativeProfileIdForCtrlFlow;
+                }
+            }
+            break;
+        case(e_FM_PCD_CC):
+            if(!p_FmPcdCcNextEngineParams->params.ccParams.h_CcNode)
+                RETURN_ERROR(MAJOR, E_NULL_POINTER, ("handler to next Node is NULL"));
+            if (!CcNodeIsValid((t_FmPcd*)h_FmPcd,
+                               (uint16_t)((t_FmPcdCcNode*)(p_FmPcdCcNextEngineParams->params.ccParams.h_CcNode))->nodeId))
+                RETURN_ERROR(MAJOR, E_INVALID_SELECTION, ("not valid nodeId in CC next engine param" ));
+            p_NextEngineParamsInfo->fmPcdEngine = e_FM_PCD_CC;
+            p_NextEngineParamsInfo->additionalInfo  =
+                (uint16_t)((t_FmPcdCcNode*)(p_FmPcdCcNextEngineParams->params.ccParams.h_CcNode))->nodeId;
+            break;
+        default:
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Next engine is not correct"));
+    }
+
+    return E_OK;
+}
+
+
+
+
+
+static uint8_t GetGenParseCode(e_FmPcdExtractFrom src, uint32_t offset, bool glblMask, uint8_t *parseArrayOffset)
+{
+    switch(src)
+    {
+        case(e_FM_PCD_EXTRACT_FROM_FRAME_START):
+            if(glblMask)
+                return CC_PC_GENERIC_WITH_MASK ;
+            else
+              return CC_PC_GENERIC_WITHOUT_MASK;
+            break;
+        case(e_FM_PCD_KG_EXTRACT_FROM_CURR_END_OF_PARSE):
+            *parseArrayOffset = CC_PC_PR_NEXT_HEADER_OFFSET;
+            if(offset)
+                return CC_PR_OFFSET;
+            else
+                return CC_PR_WITHOUT_OFFSET;
+        break;
+        default:
+            REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("Illegal 'extract from' src"));
+            return CC_PC_ILLEGAL;
+    }
+}
+
+
+static uint8_t GetFullFieldParseCode(e_NetHeaderType hdr, e_FmPcdHdrIndex index, t_FmPcdFields field)
+{
+
+      switch(hdr)
+        {
+            case(HEADER_TYPE_NONE):
+                ASSERT_COND(FALSE);
+                return CC_PC_ILLEGAL;
+            break;
+
+       case(HEADER_TYPE_ETH):
+                switch(field.eth)
+                {
+                    case(NET_HEADER_FIELD_ETH_DA):
+                        return CC_PC_FF_MACDST;
+                    case(NET_HEADER_FIELD_ETH_SA):
+                         return CC_PC_FF_MACSRC;
+                    case(NET_HEADER_FIELD_ETH_TYPE):
+                         return CC_PC_FF_ETYPE;
+                    default:
+                        REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+                        return CC_PC_ILLEGAL;
+                }
+                break;
+
+         case(HEADER_TYPE_VLAN):
+            switch(field.vlan)
+            {
+                case(NET_HEADER_FIELD_VLAN_TCI):
+                    if((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
+                        return CC_PC_FF_TCI1;
+                    if(index == e_FM_PCD_HDR_INDEX_LAST)
+                        return CC_PC_FF_TCI2;
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+                    return CC_PC_ILLEGAL;
+                default:
+                        REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+                        return CC_PC_ILLEGAL;
+            }
+            break;
+
+        case(HEADER_TYPE_MPLS):
+            switch(field.mpls)
+            {
+                case(NET_HEADER_FIELD_MPLS_LABEL_STACK):
+                    if((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
+                        return CC_PC_FF_MPLS1;
+                    if(index == e_FM_PCD_HDR_INDEX_LAST)
+                        return CC_PC_FF_MPLS_LAST;
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal MPLS index"));
+                    return CC_PC_ILLEGAL;
+               default:
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+                    return CC_PC_ILLEGAL;
+             }
+            break;
+
+        case(HEADER_TYPE_IPv4):
+            switch(field.ipv4)
+            {
+                case(NET_HEADER_FIELD_IPv4_DST_IP):
+                    if((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
+                        return CC_PC_FF_IPV4DST1;
+                    if(index == e_FM_PCD_HDR_INDEX_2)
+                        return CC_PC_FF_IPV4DST2;
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IPv4 index"));
+                    return CC_PC_ILLEGAL;
+                case(NET_HEADER_FIELD_IPv4_TOS):
+                    if((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
+                        return CC_PC_FF_IPV4IPTOS_TC1;
+                    if(index == e_FM_PCD_HDR_INDEX_2)
+                        return CC_PC_FF_IPV4IPTOS_TC2;
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IPv4 index"));
+                    return CC_PC_ILLEGAL;
+                case(NET_HEADER_FIELD_IPv4_PROTO):
+                    if((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
+                        return CC_PC_FF_IPV4PTYPE1;
+                    if(index == e_FM_PCD_HDR_INDEX_2)
+                        return CC_PC_FF_IPV4PTYPE2;
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IPv4 index"));
+                    return CC_PC_ILLEGAL;
+                case(NET_HEADER_FIELD_IPv4_SRC_IP):
+                    if((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
+                        return CC_PC_FF_IPV4SRC1;
+                    if(index == e_FM_PCD_HDR_INDEX_2)
+                        return CC_PC_FF_IPV4SRC2;
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IPv4 index"));
+                    return CC_PC_ILLEGAL;
+                case(NET_HEADER_FIELD_IPv4_SRC_IP | NET_HEADER_FIELD_IPv4_DST_IP):
+                    if((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
+                        return CC_PC_FF_IPV4SRC1_IPV4DST1;
+                    if(index == e_FM_PCD_HDR_INDEX_2)
+                        return CC_PC_FF_IPV4SRC2_IPV4DST2;
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IPv4 index"));
+                    return CC_PC_ILLEGAL;
+                case(NET_HEADER_FIELD_IPv4_TTL):
+                    return CC_PC_FF_IPV4TTL;
+                default:
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+                    return CC_PC_ILLEGAL;
+            }
+            break;
+        case(HEADER_TYPE_IPv6):
+             switch(field.ipv6)
+            {
+                case(NET_HEADER_FIELD_IPv6_VER | NET_HEADER_FIELD_IPv6_FL | NET_HEADER_FIELD_IPv6_TC):
+                    if((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
+                        return CC_PC_FF_IPTOS_IPV6TC1_IPV6FLOW1;
+                    if(index == e_FM_PCD_HDR_INDEX_2)
+                        return CC_PC_FF_IPTOS_IPV6TC2_IPV6FLOW2;
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IPv6 index"));
+                    return CC_PC_ILLEGAL;
+                case(NET_HEADER_FIELD_IPv6_NEXT_HDR):
+                    if((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
+                        return CC_PC_FF_IPV6PTYPE1;
+                    if(index == e_FM_PCD_HDR_INDEX_2)
+                        return CC_PC_FF_IPV6PTYPE2;
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IPv6 index"));
+                    return CC_PC_ILLEGAL;
+                case(NET_HEADER_FIELD_IPv6_DST_IP):
+                    if((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
+                        return CC_PC_FF_IPV6DST1;
+                    if(index == e_FM_PCD_HDR_INDEX_2)
+                        return CC_PC_FF_IPV6DST2;
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IPv6 index"));
+                    return CC_PC_ILLEGAL;
+                case(NET_HEADER_FIELD_IPv6_SRC_IP):
+                    if((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
+                        return CC_PC_FF_IPV6SRC1;
+                    if(index == e_FM_PCD_HDR_INDEX_2)
+                        return CC_PC_FF_IPV6SRC2;
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IPv6 index"));
+                    return CC_PC_ILLEGAL;
+                case(NET_HEADER_FIELD_IPv6_HOP_LIMIT):
+                    return CC_PC_FF_IPV6HOP_LIMIT;
+                 default:
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+                    return CC_PC_ILLEGAL;
+            }
+            break;
+
+        case(HEADER_TYPE_GRE):
+            switch(field.gre)
+            {
+                case(NET_HEADER_FIELD_GRE_TYPE):
+                    return CC_PC_FF_GREPTYPE;
+                default:
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+                    return CC_PC_ILLEGAL;
+           }
+        case(HEADER_TYPE_MINENCAP):
+            switch(field.minencap)
+            {
+                case(NET_HEADER_FIELD_MINENCAP_TYPE):
+                    return CC_PC_FF_MINENCAP_PTYPE;
+                case(NET_HEADER_FIELD_MINENCAP_DST_IP):
+                    return CC_PC_FF_MINENCAP_IPDST;
+                case(NET_HEADER_FIELD_MINENCAP_SRC_IP):
+                    return CC_PC_FF_MINENCAP_IPSRC;
+                case(NET_HEADER_FIELD_MINENCAP_SRC_IP | NET_HEADER_FIELD_MINENCAP_DST_IP):
+                    return CC_PC_FF_MINENCAP_IPSRC_IPDST;
+                default:
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+                    return CC_PC_ILLEGAL;
+           }
+           break;
+        case(HEADER_TYPE_TCP):
+            switch(field.tcp)
+            {
+                case(NET_HEADER_FIELD_TCP_PORT_SRC):
+                    return CC_PC_FF_L4PSRC;
+                case(NET_HEADER_FIELD_TCP_PORT_DST):
+                    return CC_PC_FF_L4PDST;
+                case(NET_HEADER_FIELD_TCP_PORT_DST | NET_HEADER_FIELD_TCP_PORT_SRC):
+                    return CC_PC_FF_L4PSRC_L4PDST;
+                default:
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+                    return CC_PC_ILLEGAL;
+            }
+            break;
+        case(HEADER_TYPE_PPPoE):
+            switch(field.pppoe)
+            {
+                case(NET_HEADER_FIELD_PPPoE_PID):
+                    return CC_PC_FF_PPPPID;
+                default:
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+                    return CC_PC_ILLEGAL;
+            }
+            break;
+        case(HEADER_TYPE_UDP):
+            switch(field.udp)
+            {
+                case(NET_HEADER_FIELD_UDP_PORT_SRC):
+                    return CC_PC_FF_L4PSRC;
+                case(NET_HEADER_FIELD_UDP_PORT_DST):
+                    return CC_PC_FF_L4PDST;
+                case(NET_HEADER_FIELD_UDP_PORT_DST | NET_HEADER_FIELD_UDP_PORT_SRC):
+                    return CC_PC_FF_L4PSRC_L4PDST;
+                default:
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+                    return CC_PC_ILLEGAL;
+            }
+            break;
+         default:
+            REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+            return CC_PC_ILLEGAL;
+
+    }
+}
+
+static uint8_t GetPrParseCode(e_NetHeaderType hdr, e_FmPcdHdrIndex hdrIndex, uint32_t offset, bool glblMask, uint8_t *parseArrayOffset)
+{
+
+ bool offsetRelevant = FALSE;
+
+    if(offset)
+        offsetRelevant = TRUE;
+
+    switch(hdr){
+        case(HEADER_TYPE_NONE):
+            ASSERT_COND(FALSE);
+            return CC_PC_ILLEGAL;
+        case(HEADER_TYPE_ETH):
+            *parseArrayOffset = (uint8_t)CC_PC_PR_ETH_OFFSET;
+            break;
+        case(HEADER_TYPE_USER_DEFINED_SHIM1):
+            if(offset || glblMask)
+                *parseArrayOffset = (uint8_t)CC_PC_PR_USER_DEFINED_SHIM1_OFFSET;
+            else
+                return CC_PC_PR_SHIM1;
+            break;
+        case(HEADER_TYPE_USER_DEFINED_SHIM2):
+            if(offset || glblMask)
+                *parseArrayOffset = (uint8_t)CC_PC_PR_USER_DEFINED_SHIM2_OFFSET;
+            else
+                return CC_PC_PR_SHIM2;
+            break;
+        case(HEADER_TYPE_USER_DEFINED_SHIM3):
+            if(offset || glblMask)
+                *parseArrayOffset = (uint8_t)CC_PC_PR_USER_DEFINED_SHIM3_OFFSET;
+            else
+                return CC_PC_PR_SHIM3;
+            break;
+              break;
+      case(HEADER_TYPE_LLC_SNAP):
+            *parseArrayOffset = CC_PC_PR_USER_LLC_SNAP_OFFSET;
+            break;
+        case(HEADER_TYPE_PPPoE):
+            *parseArrayOffset = CC_PC_PR_PPPOE_OFFSET;
+            break;
+            case(HEADER_TYPE_MPLS):
+                 if((hdrIndex == e_FM_PCD_HDR_INDEX_NONE) || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
+                        *parseArrayOffset = CC_PC_PR_MPLS1_OFFSET;
+                else if(hdrIndex == e_FM_PCD_HDR_INDEX_LAST)
+                        *parseArrayOffset = CC_PC_PR_MPLS_LAST_OFFSET;
+                else
+                {
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal MPLS header index"));
+                    return CC_PC_ILLEGAL;
+                }
+                break;
+            case(HEADER_TYPE_IPv4):
+            case(HEADER_TYPE_IPv6):
+              if((hdrIndex == e_FM_PCD_HDR_INDEX_NONE) || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
+                    *parseArrayOffset = CC_PC_PR_IP1_OFFSET;
+              else if(hdrIndex == e_FM_PCD_HDR_INDEX_2)
+                    *parseArrayOffset = CC_PC_PR_IP_LAST_OFFSET;
+              else
+              {
+                REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IP header index"));
+                return CC_PC_ILLEGAL;
+
+              }
+                break;
+            case(HEADER_TYPE_MINENCAP):
+                *parseArrayOffset = CC_PC_PR_MINENC_OFFSET;
+                break;
+            case(HEADER_TYPE_GRE):
+                *parseArrayOffset = CC_PC_PR_GRE_OFFSET;
+                break;
+            case(HEADER_TYPE_TCP):
+            case(HEADER_TYPE_UDP):
+            case(HEADER_TYPE_IPSEC_AH):
+            case(HEADER_TYPE_IPSEC_ESP):
+            case(HEADER_TYPE_DCCP):
+            case(HEADER_TYPE_SCTP):
+                *parseArrayOffset = CC_PC_PR_L4_OFFSET;
+                break;
+
+            default:
+                REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IP header for this type of operation"));
+                return CC_PC_ILLEGAL;
+     }
+
+        if(offsetRelevant)
+            return CC_PR_OFFSET;
+        else
+            return CC_PR_WITHOUT_OFFSET;
+
+}
+
+static uint8_t GetFieldParseCode(e_NetHeaderType hdr, t_FmPcdFields field, uint32_t offset, uint8_t *parseArrayOffset, e_FmPcdHdrIndex hdrIndex)
+{
+
+ bool offsetRelevant = FALSE;
+
+    if(offset)
+        offsetRelevant = TRUE;
+
+    switch(hdr)
+    {
+        case(HEADER_TYPE_NONE):
+                ASSERT_COND(FALSE);
+        case(HEADER_TYPE_ETH):
+            switch(field.eth)
+            {
+                case(NET_HEADER_FIELD_ETH_TYPE):
+                    *parseArrayOffset = CC_PC_PR_ETYPE_LAST_OFFSET;
+                    break;
+                REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+                return CC_PC_ILLEGAL;
+            }
+            break;
+        case(HEADER_TYPE_VLAN):
+            switch(field.vlan)
+            {
+                case(NET_HEADER_FIELD_VLAN_TCI) :
+                    if((hdrIndex == e_FM_PCD_HDR_INDEX_NONE) || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
+                        *parseArrayOffset = CC_PC_PR_VLAN1_OFFSET;
+                    else if(hdrIndex == e_FM_PCD_HDR_INDEX_LAST)
+                        *parseArrayOffset = CC_PC_PR_VLAN2_OFFSET;
+                    break;
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+                    return CC_PC_ILLEGAL;
+            }
+        break;
+        default:
+            REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal header "));
+            return CC_PC_ILLEGAL;
+    }
+    if(offsetRelevant)
+        return CC_PR_OFFSET;
+    else
+        return CC_PR_WITHOUT_OFFSET;
+
+}
+
+static void FillAdOfTypeResult(t_Handle p_Ad, t_FmPcd *p_FmPcd, t_FmPcdCcNextEngineParams *p_CcNextEngineParams)
+{
+    t_AdOfTypeResult                *p_AdResult = (t_AdOfTypeResult*)p_Ad;
+    uint32_t                        tmp = 0, tmpNia = 0;
+    uint16_t                        profileId;
+
+    switch(p_CcNextEngineParams->nextEngine)
+    {
+        case(e_FM_PCD_DONE):
+            if(p_CcNextEngineParams->params.enqueueParams.ctrlFlow)
+            {
+               tmp = FM_PCD_AD_RESULT_CONTRL_FLOW_TYPE;
+               tmp |= p_CcNextEngineParams->params.enqueueParams.fqidForCtrlFlow;
+            }
+            else
+            {
+               tmp = FM_PCD_AD_RESULT_DATA_FLOW_TYPE;
+               tmp |= FM_PCD_AD_RESULT_PLCR_DIS;
+            }
+            tmpNia |= NIA_ENG_BMI |NIA_BMI_AC_ENQ_FRAME;
+            break;
+        case(e_FM_PCD_KG):
+            if(p_CcNextEngineParams->params.kgParams.ctrlFlow)
+                tmp = FM_PCD_AD_RESULT_CONTRL_FLOW_TYPE;
+            else
+            {
+                tmp = FM_PCD_AD_RESULT_DATA_FLOW_TYPE;
+                tmp |= FM_PCD_AD_RESULT_PLCR_DIS;
+            }
+            tmpNia = NIA_KG_DIRECT;
+            tmpNia |= NIA_ENG_KG;
+            tmpNia |= (uint8_t)(CAST_POINTER_TO_UINT32(p_CcNextEngineParams->params.kgParams.h_DirectScheme)-1);
+        break;
+        case(e_FM_PCD_PLCR):
+            tmp = 0;
+            if(p_CcNextEngineParams->params.plcrParams.ctrlFlow)
+            {
+                tmp = FM_PCD_AD_RESULT_CONTRL_FLOW_TYPE;
+
+                /* if private policer profile, it may be uninitialized yet, therefor no checks are done at this stage */
+                if(p_CcNextEngineParams->params.plcrParams.sharedProfile)
+                {
+                    tmpNia |= NIA_PLCR_ABSOLUTE;
+                    FmPcdPlcrGetAbsoluteProfileId((t_Handle)p_FmPcd,e_FM_PCD_PLCR_SHARED,NULL,p_CcNextEngineParams->params.plcrParams.relativeProfileIdForCtrlFlow, &profileId);
+                }
+                else
+                    profileId = p_CcNextEngineParams->params.plcrParams.relativeProfileIdForCtrlFlow;
+
+                if(p_CcNextEngineParams->params.plcrParams.fqidEnqForCtrlFlow)
+                    tmp |= p_CcNextEngineParams->params.plcrParams.fqidForCtrlFlowForEnqueueAfterPlcr;
+                WRITE_UINT32(p_AdResult->plcrProfile,(uint32_t)((uint32_t)profileId << FM_PCD_AD_PROFILEID_FOR_CNTRL_SHIFT));
+            }
+            else
+               tmp = FM_PCD_AD_RESULT_DATA_FLOW_TYPE;
+            tmpNia |= NIA_ENG_PLCR | p_CcNextEngineParams->params.plcrParams.relativeProfileIdForCtrlFlow;
+           break;
+        default:
+            return;
+    }
+
+    WRITE_UINT32(p_AdResult->fqid, tmp);
+    WRITE_UINT32(p_AdResult->nia, tmpNia);
+}
+
+static void FillAdOfTypeContLookup(t_Handle p_Ad,  t_Handle h_FmPcd, t_Handle p_FmPcdCcNode)
+{
+    t_FmPcdCcNode           *p_Node = (t_FmPcdCcNode *)p_FmPcdCcNode;
+    t_AdOfTypeContLookup    *p_AdContLookup = (t_AdOfTypeContLookup *)p_Ad;
+    uint32_t                tmpReg32;
+
+    tmpReg32 = 0;
+    tmpReg32 |= FM_PCD_AD_CONT_LOOKUP_TYPE;
+    tmpReg32 |= p_Node->sizeOfExtraction ? ((p_Node->sizeOfExtraction - 1) << 24) : 0;
+    tmpReg32 |= (uint32_t)(CAST_POINTER_TO_UINT64(XX_VirtToPhys(p_Node->h_AdTable)) - (((t_FmPcd*)h_FmPcd)->p_FmPcdCc)->physicalMuramBase);
+    WRITE_UINT32(p_AdContLookup->ccAdBase, tmpReg32);
+
+    tmpReg32 = 0;
+    tmpReg32 |= p_Node->numOfKeys << 24;
+    tmpReg32 |= (p_Node->lclMask ? FM_PCD_AD_CONT_LOOKUP_LCL_MASK : 0);
+    tmpReg32 |= p_Node->h_KeysMatchTable ?
+                    (uint32_t)(CAST_POINTER_TO_UINT64(XX_VirtToPhys(p_Node->h_KeysMatchTable)) - (((t_FmPcd*)h_FmPcd)->p_FmPcdCc)->physicalMuramBase) : 0;
+    WRITE_UINT32(p_AdContLookup->matchTblPtr, tmpReg32);
+
+    tmpReg32 = 0;
+    tmpReg32 |= p_Node->prsArrayOffset << 24;
+    tmpReg32 |= p_Node->offset << 16;
+    tmpReg32 |= p_Node->parseCode;
+    WRITE_UINT32(p_AdContLookup->pcAndOffsets, tmpReg32);
+
+    COPY_BLOCK((void*)&p_AdContLookup->gmask, p_Node->p_GlblMask, p_Node->glblMaskSize);
+}
+
+static void NextStepAd(t_Handle p_Ad, t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams, t_FmPcd *p_FmPcd)
+{
+    switch(p_FmPcdCcNextEngineParams->nextEngine)
+    {
+        case(e_FM_PCD_KG):
+        case(e_FM_PCD_PLCR):
+        case(e_FM_PCD_DONE):
+            FillAdOfTypeResult(p_Ad, p_FmPcd, p_FmPcdCcNextEngineParams);
+            break;
+        case(e_FM_PCD_CC):
+            FillAdOfTypeContLookup( p_Ad,
+                                   p_FmPcd,
+                                    p_FmPcdCcNextEngineParams->params.ccParams.h_CcNode);
+            UpdateNodeOwner(p_FmPcd,
+                            (uint16_t)(((t_FmPcdCcNode *)(p_FmPcdCcNextEngineParams->params.ccParams.h_CcNode))->nodeId),
+                            TRUE);
+        break;
+        default:
+            return;
+    }
+}
+
+static t_Error ModifyCcCommon1(t_Handle h_FmPcd, t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams,t_Handle *h_OldPointer, t_Handle *h_NewPointer)
+{
+    t_FmPcdModifyCcAdditionalParams *p_CcOldModifyAdditionalParams;
+    t_FmPcdModifyCcAdditionalParams *p_CcNewModifyAdditionalParams;
+    t_Error                         err;
+    t_FmPcd                         *p_FmPcd = (t_FmPcd *)h_FmPcd;
+    t_NextEngineParamsInfo          nextEngineParamsInfo;
+
+    SANITY_CHECK_RETURN_ERROR(h_FmPcd,E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdCc,E_INVALID_STATE);
+
+    err = ValidateNextEngineParams(h_FmPcd, p_FmPcdCcNextEngineParams, &nextEngineParamsInfo);
+    if(err)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+
+    p_CcOldModifyAdditionalParams =(t_FmPcdModifyCcAdditionalParams *)XX_Malloc(sizeof(t_FmPcdModifyCcAdditionalParams));
+    if(!p_CcOldModifyAdditionalParams)
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Memory allocation FAILED"));
+    memset(p_CcOldModifyAdditionalParams, 0, sizeof(t_FmPcdModifyCcAdditionalParams));
+
+    p_CcNewModifyAdditionalParams =(t_FmPcdModifyCcAdditionalParams *)XX_Malloc(sizeof(t_FmPcdModifyCcAdditionalParams));
+    if(!p_CcNewModifyAdditionalParams)
+    {
+        XX_Free(p_CcOldModifyAdditionalParams);
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Memory allocation FAILED"));
+    }
+    memset(p_CcNewModifyAdditionalParams, 0, sizeof(t_FmPcdModifyCcAdditionalParams));
+
+    p_CcNewModifyAdditionalParams->p_Ad = (t_Handle)FM_MURAM_AllocMem(p_FmPcd->p_FmPcdCc->h_FmMuram,
+                                         FM_PCD_CC_AD_ENTRY_SIZE,
+                                         FM_PCD_CC_AD_TABLE_ALIGN);
+
+    if(!p_CcNewModifyAdditionalParams->p_Ad)
+    {
+        XX_Free(p_CcOldModifyAdditionalParams);
+        XX_Free(p_CcNewModifyAdditionalParams);
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Memory allocation in MURAM FAILED"));
+
+    }
+    WRITE_BLOCK((uint8_t *)p_CcNewModifyAdditionalParams->p_Ad, 0,  FM_PCD_CC_AD_ENTRY_SIZE);
+
+    if(p_FmPcdCcNextEngineParams)
+        NextStepAd((t_Handle)p_CcNewModifyAdditionalParams->p_Ad,p_FmPcdCcNextEngineParams, p_FmPcd);
+
+    p_CcNewModifyAdditionalParams->fmPcdEngine      = nextEngineParamsInfo.fmPcdEngine;
+    if(p_CcNewModifyAdditionalParams->fmPcdEngine == e_FM_PCD_CC)
+        p_CcNewModifyAdditionalParams->myInfo = nextEngineParamsInfo.additionalInfo;
+    else
+        p_CcNewModifyAdditionalParams->myInfo = 0xffffffff;
+
+    *h_OldPointer = p_CcOldModifyAdditionalParams;
+    *h_NewPointer = p_CcNewModifyAdditionalParams;
+
+    return E_OK;
+}
+
+static void ReleaseCommonModifyKey(t_Handle h_FmMuram, t_FmPcdModifyCcAdditionalParams *p_CcModifyAdditionalParams)
+{
+   if(p_CcModifyAdditionalParams->adAllocated)
+        FM_MURAM_FreeMem(h_FmMuram, p_CcModifyAdditionalParams->p_Ad);
+   XX_Free(p_CcModifyAdditionalParams);
+}
+
+static t_Error ModifyCcKeyCommon(t_FmPcd *p_FmPcd, t_Handle *h_Pointer,bool allocateAd)
+{
+    t_FmPcdModifyCcAdditionalParams *p_ModifyAdditionalParams;
+
+    p_ModifyAdditionalParams =(t_FmPcdModifyCcAdditionalParams *)XX_Malloc(sizeof(t_FmPcdModifyCcAdditionalParams));
+    if(!p_ModifyAdditionalParams)
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Memory allocation FAILED"));
+    memset(p_ModifyAdditionalParams, 0, sizeof(t_FmPcdModifyCcAdditionalParams));
+    if(allocateAd)
+    {
+        p_ModifyAdditionalParams->p_Ad = (t_Handle)FM_MURAM_AllocMem(p_FmPcd->p_FmPcdCc->h_FmMuram,
+                                             FM_PCD_CC_AD_ENTRY_SIZE,
+                                             FM_PCD_CC_AD_TABLE_ALIGN);
+
+        if(!p_ModifyAdditionalParams->p_Ad)
+        {
+            XX_Free(p_ModifyAdditionalParams);
+            XX_Free(p_ModifyAdditionalParams);
+            RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Memory allocation in MURAM FAILED"));
+
+        }
+        WRITE_BLOCK((uint8_t *)p_ModifyAdditionalParams->p_Ad, 0,  FM_PCD_CC_AD_ENTRY_SIZE);
+        p_ModifyAdditionalParams->adAllocated = TRUE;
+    }
+    *h_Pointer = p_ModifyAdditionalParams;
+
+    return E_OK;
+}
+
+
+static void ModifyCcCommon2(t_FmPcdModifyCcAdditionalParams *p_CcOldModifyAdditionalParams,
+                            t_FmPcdModifyCcAdditionalParams *p_CcNewModifyAdditionalParams,
+                            uint16_t indx)
+{
+
+    uint32_t    tmpReg;
+
+    if(p_CcNewModifyAdditionalParams->fmPcdEngine == e_FM_PCD_CC)
+        p_CcNewModifyAdditionalParams->myInfo |= (uint32_t)indx <<16;
+
+    tmpReg = GET_UINT32(*((uint32_t*)p_CcOldModifyAdditionalParams->p_Ad));
+    if((tmpReg & FM_PCD_AD_TYPE_MASK) == FM_PCD_AD_CONT_LOOKUP_TYPE)
+    {
+        p_CcOldModifyAdditionalParams->fmPcdEngine = e_FM_PCD_CC;
+        p_CcOldModifyAdditionalParams->myInfo =(uint32_t)indx ;
+    }
+    else
+        p_CcOldModifyAdditionalParams->myInfo = 0xffffffff;
+}
+
+static void ReleaseNewNodeCommonPart(t_FmPcdCc *p_FmPcdCc, t_FmPcdModifyCcKeyAdditionalParams *p_AdditionalInfo)
+{
+    if(p_AdditionalInfo->p_AdTableNew)
+        FM_MURAM_FreeMem(p_FmPcdCc->h_FmMuram, p_AdditionalInfo->p_AdTableNew);
+    if(p_AdditionalInfo->p_KeysMatchTableNew)
+        FM_MURAM_FreeMem(p_FmPcdCc->h_FmMuram, p_AdditionalInfo->p_KeysMatchTableNew);
+}
+
+static t_Error BuildNewNodeCommonPart(t_Handle *h_FmPcd, t_FmPcdCcNode *p_FmPcdCcNode, int *size, bool mask, t_FmPcdModifyCcKeyAdditionalParams *p_AdditionalInfo)
+{
+    t_FmPcd                *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    t_FmPcdCc               *p_FmPcdCc = p_FmPcd->p_FmPcdCc;
+
+    p_AdditionalInfo->p_AdTableNew = (t_Handle)FM_MURAM_AllocMem(p_FmPcdCc->h_FmMuram,
+                                     (uint32_t)( (p_AdditionalInfo->numOfKeys+1) * FM_PCD_CC_AD_ENTRY_SIZE),
+                                     FM_PCD_CC_AD_TABLE_ALIGN);
+    if(!p_AdditionalInfo->p_AdTableNew)
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("No memory in MURAM ffor AD table "));
+
+    WRITE_BLOCK((uint8_t *)p_AdditionalInfo->p_AdTableNew, 0, (uint32_t)((p_AdditionalInfo->numOfKeys+1) * FM_PCD_CC_AD_ENTRY_SIZE));
+
+    if(p_FmPcdCcNode->lclMask || mask)
+    {
+        p_AdditionalInfo->lclMask = TRUE;
+        *size = 2 * p_FmPcdCcNode->ccKeySizeAccExtraction;
+    }
+    else
+    {
+        p_AdditionalInfo->lclMask = p_FmPcdCcNode->lclMask;
+        *size = p_FmPcdCcNode->ccKeySizeAccExtraction;
+    }
+
+    p_AdditionalInfo->p_KeysMatchTableNew =(t_Handle)FM_MURAM_AllocMem(p_FmPcdCc->h_FmMuram,
+                                         (uint32_t)(*size * sizeof(uint8_t) * (p_AdditionalInfo->numOfKeys + 1)),
+                                         FM_PCD_CC_KEYS_MATCH_TABLE_ALIGN);
+    if(!p_AdditionalInfo->p_KeysMatchTableNew)
+    {
+        FM_MURAM_FreeMem(p_FmPcdCc->h_FmMuram, p_AdditionalInfo->p_KeysMatchTableNew);
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("No memory in MURAM for KEY MATCH table"));
+    }
+    WRITE_BLOCK((uint8_t *)p_AdditionalInfo->p_KeysMatchTableNew, 0, *size * sizeof(uint8_t) * (p_AdditionalInfo->numOfKeys + 1));
+
+
+    p_AdditionalInfo->p_AdTableOld          = p_FmPcdCcNode->h_AdTable;
+    p_AdditionalInfo->p_KeysMatchTableOld   =p_FmPcdCcNode->h_KeysMatchTable;
+
+    return E_OK;
+}
+
+static t_Error BuildNewNodeAddKey(t_Handle h_FmPcd ,t_FmPcdCcNode *p_FmPcdCcNode, uint8_t keyIndex, t_FmPcdCcKeyParams  *p_KeyParams,t_FmPcdModifyCcKeyAdditionalParams *p_AdditionalInfo)
+{
+    t_Error                 err;
+    t_NextEngineParamsInfo  nextEngineParamsInfo;
+    t_Handle                p_AdTableNewTmp, p_KeysMatchTableNewTmp;
+    t_Handle                p_KeysMatchTableOldTmp, p_AdTableOldTmp;
+    int                     size;
+    int                     i = 0, j = 0;
+    t_FmPcd                 *p_FmPcd = (t_FmPcd*)h_FmPcd;
+
+    err = ValidateNextEngineParams(h_FmPcd, &p_KeyParams->ccNextEngineParams, &nextEngineParamsInfo);
+    if(err)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+
+    p_AdditionalInfo->numOfKeys = (uint8_t)(p_FmPcdCcNode->numOfKeys + 1);
+
+    err = BuildNewNodeCommonPart(h_FmPcd, p_FmPcdCcNode, &size, (p_KeyParams->p_Mask ? TRUE : FALSE), p_AdditionalInfo);
+    if(err)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+
+    i = 0;
+    for(j = 0; j < p_AdditionalInfo->numOfKeys; j++)
+    {
+        p_AdTableNewTmp = (t_Handle)((uint32_t)p_AdditionalInfo->p_AdTableNew + j*FM_PCD_CC_AD_ENTRY_SIZE);
+        if(j == keyIndex)
+         {
+            NextStepAd(p_AdTableNewTmp,&p_KeyParams->ccNextEngineParams, p_FmPcd);
+            p_KeysMatchTableNewTmp = (t_Handle)(((uint32_t)p_AdditionalInfo->p_KeysMatchTableNew) + j*size * sizeof(uint8_t));
+            COPY_BLOCK((void*)p_KeysMatchTableNewTmp, p_KeyParams->p_Key, p_FmPcdCcNode->ccKeySizeAccExtraction);
+            if(p_AdditionalInfo->lclMask)
+            {
+                if(p_KeyParams->p_Mask)
+                    IO2IOCpy32((t_Handle)(((uint32_t)p_KeysMatchTableNewTmp) + p_FmPcdCcNode->ccKeySizeAccExtraction), p_KeyParams->p_Mask, p_FmPcdCcNode->ccKeySizeAccExtraction);
+                else
+                    WRITE_BLOCK((void*)(((uint32_t)p_KeysMatchTableNewTmp) + p_FmPcdCcNode->ccKeySizeAccExtraction),0xff, p_FmPcdCcNode->ccKeySizeAccExtraction);
+            }
+         }
+         else
+         {
+            p_AdTableOldTmp = (t_Handle)((uint32_t)p_AdditionalInfo->p_AdTableOld + i*FM_PCD_CC_AD_ENTRY_SIZE);
+            IO2IOCpy32(p_AdTableNewTmp, p_AdTableOldTmp,  FM_PCD_CC_AD_ENTRY_SIZE);
+            p_KeysMatchTableNewTmp = (t_Handle)(((uint32_t)p_AdditionalInfo->p_KeysMatchTableNew) + j*size * sizeof(uint8_t));
+            p_KeysMatchTableOldTmp  = (t_Handle)((uint32_t)p_AdditionalInfo->p_KeysMatchTableOld + i*size*sizeof(uint8_t));
+            if(p_AdditionalInfo->lclMask)
+            {
+                if(p_FmPcdCcNode->lclMask)
+                {
+                    IO2IOCpy32((t_Handle)((uint32_t)p_KeysMatchTableNewTmp + p_FmPcdCcNode->ccKeySizeAccExtraction), (t_Handle)((uint32_t)p_KeysMatchTableOldTmp+p_FmPcdCcNode->ccKeySizeAccExtraction),p_FmPcdCcNode->ccKeySizeAccExtraction);
+                }
+                else
+                {
+                    p_KeysMatchTableOldTmp  = (t_Handle)((uint32_t)p_FmPcdCcNode->h_KeysMatchTable + i*p_FmPcdCcNode->ccKeySizeAccExtraction*sizeof(uint8_t));
+                    WRITE_BLOCK((void*)(((uint32_t)p_KeysMatchTableNewTmp) + p_FmPcdCcNode->ccKeySizeAccExtraction),0xff, p_FmPcdCcNode->ccKeySizeAccExtraction);
+                }
+            }
+            IO2IOCpy32((void*)p_KeysMatchTableNewTmp, p_KeysMatchTableOldTmp, p_FmPcdCcNode->ccKeySizeAccExtraction);
+           i++;
+         }
+    }
+
+    p_AdTableNewTmp = (t_Handle)((uint32_t)p_AdditionalInfo->p_AdTableNew + j*FM_PCD_CC_AD_ENTRY_SIZE);
+    p_AdTableOldTmp = (t_Handle)((uint32_t)p_AdditionalInfo->p_AdTableOld + i*FM_PCD_CC_AD_ENTRY_SIZE);
+    IO2IOCpy32((void*)p_AdTableNewTmp, p_AdTableOldTmp, FM_PCD_CC_AD_ENTRY_SIZE);
+
+    p_AdditionalInfo->keyIndexForRemove = 0xffff;
+    if(nextEngineParamsInfo.fmPcdEngine == e_FM_PCD_CC)
+        p_AdditionalInfo->nodeIdForAdd = (uint16_t)nextEngineParamsInfo.additionalInfo;
+    else
+        p_AdditionalInfo->nodeIdForAdd = 0xffff;
+    return E_OK;
+}
+
+static t_Error BuildNewNodeRemoveKey(t_Handle h_FmPcd  ,t_FmPcdCcNode *p_FmPcdCcNode, uint8_t keyIndex, t_FmPcdModifyCcKeyAdditionalParams *p_AdditionalInfo)
+{
+    int         i = 0, j = 0;
+    t_Handle    p_AdTableNewTmp,p_KeysMatchTableNewTmp;
+    t_Handle    p_KeysMatchTableOldTmp, p_AdTableOldTmp;
+    int         size;
+    t_Error     err;
+
+    p_AdditionalInfo->numOfKeys = (uint16_t)(p_FmPcdCcNode->numOfKeys - 1);
+
+    err = BuildNewNodeCommonPart(h_FmPcd, p_FmPcdCcNode, &size, (p_FmPcdCcNode->lclMask ? TRUE : FALSE), p_AdditionalInfo);
+    if(err)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+
+    for(i = 0, j = 0; j < p_FmPcdCcNode->numOfKeys; i++, j++)
+    {
+        if(j == keyIndex)
+        {
+            p_AdTableOldTmp = (t_Handle)((uint32_t)p_AdditionalInfo->p_AdTableOld + j*FM_PCD_CC_AD_ENTRY_SIZE);
+            if((GET_UINT32(*(uint32_t*)p_AdTableOldTmp) & FM_PCD_AD_TYPE_MASK) == FM_PCD_AD_CONT_LOOKUP_TYPE)
+                p_AdditionalInfo->keyIndexForRemove = keyIndex;
+            else
+                p_AdditionalInfo->keyIndexForRemove = 0xffff;
+            j++;
+        }
+        if(j == p_FmPcdCcNode->numOfKeys)
+            break;
+         p_AdTableNewTmp = (t_Handle)((uint32_t)p_AdditionalInfo->p_AdTableNew + i*FM_PCD_CC_AD_ENTRY_SIZE);
+         p_AdTableOldTmp = (t_Handle)((uint32_t)p_AdditionalInfo->p_AdTableOld + j*FM_PCD_CC_AD_ENTRY_SIZE);
+         IO2IOCpy32(p_AdTableNewTmp,p_AdTableOldTmp,  FM_PCD_CC_AD_ENTRY_SIZE);
+         p_KeysMatchTableOldTmp  = (t_Handle)((uint32_t)p_AdditionalInfo->p_KeysMatchTableOld + j*size*sizeof(uint8_t));
+         p_KeysMatchTableNewTmp  = (t_Handle)((uint32_t)p_AdditionalInfo->p_KeysMatchTableNew+ i*size*sizeof(uint8_t));
+         IO2IOCpy32(p_KeysMatchTableNewTmp,p_KeysMatchTableOldTmp,  size * sizeof(uint8_t));
+    }
+
+    p_AdTableNewTmp = (t_Handle)((uint32_t)p_AdditionalInfo->p_AdTableNew + i*FM_PCD_CC_AD_ENTRY_SIZE);
+    p_AdTableOldTmp = (t_Handle)((uint32_t)p_AdditionalInfo->p_AdTableOld + j*FM_PCD_CC_AD_ENTRY_SIZE);
+    IO2IOCpy32(p_AdTableNewTmp,p_AdTableOldTmp,  FM_PCD_CC_AD_ENTRY_SIZE);
+
+    p_AdditionalInfo->nodeIdForAdd = 0xffff;
+
+   return E_OK;
+}
+
+
+static t_Error BuildNewNodeModifyKey(t_Handle h_FmPcd ,t_FmPcdCcNode *p_FmPcdCcNode, uint8_t keyIndex, uint8_t  *p_Key, uint8_t *p_Mask,t_FmPcdModifyCcKeyAdditionalParams *p_AdditionalInfo)
+{
+    t_Error                 err;
+    t_Handle                p_AdTableNewTmp, p_KeysMatchTableNewTmp;
+    t_Handle                p_KeysMatchTableOldTmp, p_AdTableOldTmp;
+    int                     size;
+    int                     i = 0, j = 0;
+
+    p_AdditionalInfo->numOfKeys =  p_FmPcdCcNode->numOfKeys;
+
+    err = BuildNewNodeCommonPart(h_FmPcd, p_FmPcdCcNode, &size, (p_Mask ? TRUE : FALSE), p_AdditionalInfo);
+    if(err)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+
+    for(j = 0, i = 0; j < p_AdditionalInfo->numOfKeys; j++, i++)
+    {
+        p_AdTableNewTmp = (t_Handle)((uint32_t)p_AdditionalInfo->p_AdTableNew + j*FM_PCD_CC_AD_ENTRY_SIZE);
+        p_AdTableOldTmp = (t_Handle)((uint32_t)p_AdditionalInfo->p_AdTableOld + i*FM_PCD_CC_AD_ENTRY_SIZE);
+        IO2IOCpy32(p_AdTableNewTmp, p_AdTableOldTmp,  FM_PCD_CC_AD_ENTRY_SIZE);
+        if(j == keyIndex)
+        {
+            p_KeysMatchTableNewTmp = (t_Handle)(((uint32_t)p_AdditionalInfo->p_KeysMatchTableNew) + j*size * sizeof(uint8_t));
+            COPY_BLOCK((void*)p_KeysMatchTableNewTmp, p_Key, p_FmPcdCcNode->ccKeySizeAccExtraction);
+            if(p_AdditionalInfo->lclMask)
+            {
+                if(p_Mask)
+                    IO2IOCpy32((t_Handle)(((uint32_t)p_KeysMatchTableNewTmp) + p_FmPcdCcNode->ccKeySizeAccExtraction), p_Mask, p_FmPcdCcNode->ccKeySizeAccExtraction);
+                else
+                    WRITE_BLOCK((void*)(((uint32_t)p_KeysMatchTableNewTmp) + p_FmPcdCcNode->ccKeySizeAccExtraction),0xff, p_FmPcdCcNode->ccKeySizeAccExtraction);
+            }
+        }
+        else
+        {
+            p_KeysMatchTableNewTmp = (t_Handle)(((uint32_t)p_AdditionalInfo->p_KeysMatchTableNew) + j*size * sizeof(uint8_t));
+            p_KeysMatchTableOldTmp  = (t_Handle)((uint32_t)p_FmPcdCcNode->h_KeysMatchTable + i*size*sizeof(uint8_t));
+            if(p_AdditionalInfo->lclMask)
+            {
+                if(p_FmPcdCcNode->lclMask)
+                {
+                    IO2IOCpy32((t_Handle)((uint32_t)p_KeysMatchTableNewTmp + p_FmPcdCcNode->ccKeySizeAccExtraction), (t_Handle)((uint32_t)p_KeysMatchTableOldTmp+p_FmPcdCcNode->ccKeySizeAccExtraction),p_FmPcdCcNode->ccKeySizeAccExtraction);
+                }
+                else
+                {
+                    p_KeysMatchTableOldTmp  = (t_Handle)((uint32_t)p_FmPcdCcNode->h_KeysMatchTable + i*p_FmPcdCcNode->ccKeySizeAccExtraction*sizeof(uint8_t));
+                    WRITE_BLOCK((void*)(((uint32_t)p_KeysMatchTableNewTmp) + p_FmPcdCcNode->ccKeySizeAccExtraction),0xff, p_FmPcdCcNode->ccKeySizeAccExtraction);
+                }
+            }
+            IO2IOCpy32((void*)p_KeysMatchTableNewTmp, p_KeysMatchTableOldTmp, p_FmPcdCcNode->ccKeySizeAccExtraction);
+        }
+    }
+
+    p_AdTableNewTmp = (t_Handle)((uint32_t)p_AdditionalInfo->p_AdTableNew + j*FM_PCD_CC_AD_ENTRY_SIZE);
+    p_AdTableOldTmp = (t_Handle)((uint32_t)p_FmPcdCcNode->h_AdTable + i*FM_PCD_CC_AD_ENTRY_SIZE);
+    IO2IOCpy32((void*)p_AdTableNewTmp, p_AdTableOldTmp, FM_PCD_CC_AD_ENTRY_SIZE);
+
+    p_AdditionalInfo->nodeIdForAdd = 0xffff;
+    p_AdditionalInfo->keyIndexForRemove = 0xffff;
+
+    return E_OK;
+}
+
+static t_Error BuildNewNodeModifyKeyAndNextEngine(t_Handle h_FmPcd ,t_FmPcdCcNode *p_FmPcdCcNode, uint8_t keyIndex, t_FmPcdCcKeyParams  *p_KeyParams,t_FmPcdModifyCcKeyAdditionalParams *p_AdditionalInfo)
+{
+    t_Error                 err;
+    t_NextEngineParamsInfo nextEngineParamsInfo;
+    t_FmPcd                 *p_FmPcd = (t_FmPcd *)h_FmPcd;
+    t_Handle                p_AdTableNewTmp,p_KeysMatchTableNewTmp;
+    t_Handle                p_KeysMatchTableOldTmp, p_AdTableOldTmp;
+    int                     size;
+    int                     i = 0, j = 0;
+
+    err = ValidateNextEngineParams(h_FmPcd, &p_KeyParams->ccNextEngineParams, &nextEngineParamsInfo);
+    if(err)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+
+    p_AdditionalInfo->numOfKeys = p_FmPcdCcNode->numOfKeys;
+
+    err = BuildNewNodeCommonPart(h_FmPcd, p_FmPcdCcNode, &size, (p_KeyParams->p_Mask ? TRUE : FALSE), p_AdditionalInfo);
+    if(err)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+
+    for(j = 0, i = 0; j < p_AdditionalInfo->numOfKeys; j++, i++)
+    {
+        p_AdTableNewTmp = (t_Handle)((uint32_t)p_AdditionalInfo->p_AdTableNew + j*FM_PCD_CC_AD_ENTRY_SIZE);
+        if(j == keyIndex)
+         {
+            p_AdTableOldTmp = (t_Handle)((uint32_t)p_AdditionalInfo->p_AdTableOld + i*FM_PCD_CC_AD_ENTRY_SIZE);
+            if((GET_UINT32(*(uint32_t*)p_AdTableOldTmp) & FM_PCD_AD_TYPE_MASK) == FM_PCD_AD_CONT_LOOKUP_TYPE)
+                p_AdditionalInfo->keyIndexForRemove = keyIndex;
+            else
+                p_AdditionalInfo->keyIndexForRemove = 0xffff;
+            NextStepAd(p_AdTableNewTmp,&p_KeyParams->ccNextEngineParams, p_FmPcd);
+            p_KeysMatchTableNewTmp = (t_Handle)(((uint32_t)p_AdditionalInfo->p_KeysMatchTableNew) + j*size * sizeof(uint8_t));
+            COPY_BLOCK((void*)p_KeysMatchTableNewTmp, p_KeyParams->p_Key, p_FmPcdCcNode->ccKeySizeAccExtraction);
+            if(p_FmPcdCcNode->lclMask)
+            {
+                if(p_KeyParams->p_Mask)
+                    IO2IOCpy32((void*)(((uint32_t)p_KeysMatchTableNewTmp) + p_FmPcdCcNode->ccKeySizeAccExtraction), p_KeyParams->p_Mask, p_FmPcdCcNode->ccKeySizeAccExtraction);
+                else
+                    WRITE_BLOCK((void*)(((uint32_t)p_KeysMatchTableNewTmp) + p_FmPcdCcNode->ccKeySizeAccExtraction),0xff, p_FmPcdCcNode->ccKeySizeAccExtraction);
+            }
+         }
+         else
+         {
+            p_AdTableOldTmp = (t_Handle)((uint32_t)p_AdditionalInfo->p_AdTableOld + i*FM_PCD_CC_AD_ENTRY_SIZE);
+            IO2IOCpy32(p_AdTableNewTmp, p_AdTableOldTmp,  FM_PCD_CC_AD_ENTRY_SIZE);
+            p_KeysMatchTableNewTmp = (t_Handle)(((uint32_t)p_AdditionalInfo->p_KeysMatchTableNew) + j*size * sizeof(uint8_t));
+            p_KeysMatchTableOldTmp  = (t_Handle)((uint32_t)p_AdditionalInfo->p_KeysMatchTableOld + i*size*sizeof(uint8_t));
+            if(p_AdditionalInfo->lclMask)
+            {
+                if(p_FmPcdCcNode->lclMask)
+                    IO2IOCpy32((t_Handle)((uint32_t)p_KeysMatchTableNewTmp + p_FmPcdCcNode->ccKeySizeAccExtraction), (t_Handle)((uint32_t)p_KeysMatchTableOldTmp+p_FmPcdCcNode->ccKeySizeAccExtraction),p_FmPcdCcNode->ccKeySizeAccExtraction);
+                else
+                {
+                    p_KeysMatchTableOldTmp  = (t_Handle)((uint32_t)p_AdditionalInfo->p_KeysMatchTableOld + i*p_FmPcdCcNode->ccKeySizeAccExtraction*sizeof(uint8_t));
+                    WRITE_BLOCK((void*)(((uint32_t)p_KeysMatchTableNewTmp) + p_FmPcdCcNode->ccKeySizeAccExtraction),0xff, p_FmPcdCcNode->ccKeySizeAccExtraction);
+                }
+            }
+             IO2IOCpy32((void*)p_KeysMatchTableNewTmp, p_KeysMatchTableOldTmp, p_FmPcdCcNode->ccKeySizeAccExtraction);
+         }
+    }
+
+    p_AdTableNewTmp = (t_Handle)((uint32_t)p_AdditionalInfo->p_AdTableNew + j*FM_PCD_CC_AD_ENTRY_SIZE);
+    p_AdTableOldTmp = (t_Handle)((uint32_t)p_AdditionalInfo->p_AdTableOld + i*FM_PCD_CC_AD_ENTRY_SIZE);
+    IO2IOCpy32((void*)p_AdTableNewTmp, p_AdTableOldTmp, FM_PCD_CC_AD_ENTRY_SIZE);
+
+    if(nextEngineParamsInfo.fmPcdEngine == e_FM_PCD_CC)
+        p_AdditionalInfo->nodeIdForAdd = (uint16_t)nextEngineParamsInfo.additionalInfo;
+    else
+        p_AdditionalInfo->nodeIdForAdd = 0xffff;
+    return E_OK;
+}
+
+
+static void FillNodeWithParams(t_FmPcdCcNode *p_FmPcdCcNodeTo, t_FmPcdCcNode *p_FmPcdCcNodeFrom, t_FmPcdModifyCcKeyAdditionalParams *p_FmPcdModifyCcKeyAdditionalParams)
+{
+    p_FmPcdCcNodeTo->h_AdTable       = p_FmPcdModifyCcKeyAdditionalParams->p_AdTableNew;
+    p_FmPcdCcNodeTo->numOfKeys       = p_FmPcdModifyCcKeyAdditionalParams->numOfKeys;
+    p_FmPcdCcNodeTo->lclMask         = p_FmPcdModifyCcKeyAdditionalParams->lclMask;
+    p_FmPcdCcNodeTo->h_KeysMatchTable= p_FmPcdModifyCcKeyAdditionalParams->p_KeysMatchTableNew;
+
+    p_FmPcdCcNodeTo->sizeOfExtraction = p_FmPcdCcNodeFrom->sizeOfExtraction;
+    p_FmPcdCcNodeTo->prsArrayOffset  = p_FmPcdCcNodeFrom->prsArrayOffset;
+    p_FmPcdCcNodeTo->offset          = p_FmPcdCcNodeFrom->offset;
+    p_FmPcdCcNodeTo->parseCode       = p_FmPcdCcNodeFrom->parseCode;
+    p_FmPcdCcNodeTo->p_GlblMask      = p_FmPcdCcNodeFrom->p_GlblMask;
+    p_FmPcdCcNodeTo->glblMaskSize    = p_FmPcdCcNodeFrom->glblMaskSize;
+}
+
+static t_Error ModifyWithNodeDataStructure(t_FmPcd *p_FmPcd,uint16_t nodeId, t_FmPcdCcNode *p_FmPcdCcNode ,t_List  *h_OldLst)
+{
+    t_List                          *p_Pos,*p_Pos1;
+    t_CcNodeInfo                    *p_CcNodeInfo;
+    uint16_t                        nodeIdPrev;
+    t_FmPcdCcNode                   *p_FmPcdCcNodePrev;
+    t_List                          p_List;
+
+
+    INIT_LIST(&p_List);
+
+    LIST_FOR_EACH(p_Pos, &p_FmPcdCcNode->ccPrevNodesLst)
+    {
+        p_CcNodeInfo = CC_NEXT_NODE_F_OBJECT(p_Pos);
+        nodeIdPrev = (uint16_t)p_CcNodeInfo->nextCcNodeInfo;
+        p_FmPcdCcNodePrev = (t_FmPcdCcNode *)GetNodeHandler(p_FmPcd, nodeIdPrev);
+        if(!p_FmPcdCcNodePrev)
+            RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("the node with this nodeId wasn't initialized"));
+        FindNodeInfoAccIdAndAddToRetLst(&p_FmPcdCcNodePrev->ccNextNodesLst,nodeId, &p_List);
+        if(LIST_IsEmpty(&p_List))
+            RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("numOfPrevNodes has to be 1"));
+        LIST_FOR_EACH(p_Pos1, &p_List)
+        {
+            p_CcNodeInfo = CC_NEXT_NODE_F_OBJECT(p_Pos1);
+            CreateNodeInfo(h_OldLst, (uint32_t)((uint32_t)(p_FmPcdCcNodePrev->h_AdTable) + FM_PCD_CC_AD_ENTRY_SIZE * (p_CcNodeInfo->nextCcNodeInfo >> 16)));
+        }
+    }
+
+    ReleaseLst(&p_List);
+    return E_OK;
+}
+static t_Error ModifyWithTreeDataStructure(t_FmPcd *p_FmPcd,uint16_t nodeId, t_FmPcdCcNode *p_FmPcdCcNode, t_List  *h_OldLst)
+{
+    t_List                          *p_Pos,*p_Pos1;
+    t_CcNodeInfo                    *p_CcNodeInfo;
+    uint16_t                        treeIdPrev;
+    t_List                          p_List;
+    t_FmPcdCcTree                   *p_FmPcdCcTreePrev;
+
+
+    INIT_LIST(&p_List);
+
+    LIST_FOR_EACH(p_Pos, &p_FmPcdCcNode->ccTreeIdLst)
+    {
+        p_CcNodeInfo = CC_NEXT_NODE_F_OBJECT(p_Pos);
+        treeIdPrev = (uint16_t)p_CcNodeInfo->nextCcNodeInfo;
+        p_FmPcdCcTreePrev = (t_FmPcdCcTree *)FmPcdCcGetTreeHandler(p_FmPcd, (uint8_t)treeIdPrev);
+        if(!p_FmPcdCcTreePrev)
+            RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("the node with this nodeId wasn't initialized"));
+        FindNodeInfoAccIdAndAddToRetLst(&p_FmPcdCcTreePrev->ccNextNodesLst,nodeId , &p_List);
+        if(LIST_IsEmpty(&p_List))
+            RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("numOfPrevNodes has to be 1"));
+        LIST_FOR_EACH(p_Pos1, &p_List)
+        {
+            p_CcNodeInfo = CC_NEXT_NODE_F_OBJECT(p_Pos1);
+            CreateNodeInfo(h_OldLst, (uint32_t)((uint32_t)(p_FmPcdCcTreePrev->p_CcBaseTree) + FM_PCD_CC_AD_ENTRY_SIZE * (p_CcNodeInfo->nextCcNodeInfo >> 16)));
+        }
+    }
+    ReleaseLst(&p_List);
+    return E_OK;
+}
+
+static t_Error ModifyKeyCommonPart1(t_FmPcdCcNode *p_FmPcdCcNode,  uint8_t keyIndex, t_FmPcdModifyCcKeyAdditionalParams **p_FmPcdModifyCcKeyAdditionalParams)
+{
+    t_FmPcdModifyCcKeyAdditionalParams *p_FmPcdModifyCcKeyAdditionalParamsTmp;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcdCcNode,E_INVALID_HANDLE);
+
+    if(p_FmPcdCcNode->parseCode == CC_PC_FF_IPV4TTL ||
+       p_FmPcdCcNode->parseCode == CC_PC_FF_IPV6HOP_LIMIT)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("nodeId of CC_PC_FF_IPV4TTL or CC_PC_FF_IPV6HOP_LIMIT can not be used for addKey, removeKey, modifyKey"));
+
+    if (!LIST_NumOfObjs(&p_FmPcdCcNode->ccPrevNodesLst) &&
+        !LIST_NumOfObjs(&p_FmPcdCcNode->ccTreeIdLst))
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("this node without connection"));
+
+    p_FmPcdModifyCcKeyAdditionalParamsTmp =  (t_FmPcdModifyCcKeyAdditionalParams *)XX_Malloc(sizeof(t_FmPcdModifyCcKeyAdditionalParams));
+    if(!p_FmPcdModifyCcKeyAdditionalParamsTmp)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Allocation of internal data structure FAILED"));
+    memset(p_FmPcdModifyCcKeyAdditionalParamsTmp, 0, sizeof(t_FmPcdModifyCcKeyAdditionalParams));
+
+    p_FmPcdModifyCcKeyAdditionalParamsTmp->h_CurrentNode = (t_Handle)p_FmPcdCcNode;
+    p_FmPcdModifyCcKeyAdditionalParamsTmp->keyIndexForRemove = keyIndex;
+    p_FmPcdModifyCcKeyAdditionalParamsTmp->keyIndexForAdd = keyIndex;
+
+    *p_FmPcdModifyCcKeyAdditionalParams = p_FmPcdModifyCcKeyAdditionalParamsTmp;
+
+    return E_OK;
+}
+
+t_Error FmPcdCcModifyNextEngineParamTree(t_Handle h_FmPcd, t_Handle h_FmPcdCcTree, uint8_t grpId, uint8_t index, t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams, t_Handle *h_OldPointer, t_Handle *h_NewPointer)
+{
+    t_FmPcdCcTree                   *p_FmPcdCcTree = (t_FmPcdCcTree *)h_FmPcdCcTree;
+    t_Error                         err;
+    t_FmPcdModifyCcAdditionalParams *p_CcOldModifyAdditionalParams;
+    t_FmPcdModifyCcAdditionalParams *p_CcNewModifyAdditionalParams;
+
+    SANITY_CHECK_RETURN_ERROR((grpId <= 7),E_INVALID_VALUE);
+    SANITY_CHECK_RETURN_ERROR(h_FmPcdCcTree,E_INVALID_VALUE);
+
+
+    if(grpId >= p_FmPcdCcTree->numOfGrps)
+        RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("grpId you asked > numOfGroup of relevant tree"));
+
+    if(index >= p_FmPcdCcTree->fmPcdGroupParam[grpId].numOfEntriesInGroup)
+        RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("index > numOfEntriesInGroup"));
+
+    err = ModifyCcCommon1(h_FmPcd, p_FmPcdCcNextEngineParams, h_OldPointer, h_NewPointer);
+    if(err)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+
+    p_CcOldModifyAdditionalParams = *h_OldPointer;
+    p_CcOldModifyAdditionalParams->p_Ad = (t_Handle)((uint32_t)p_FmPcdCcTree->p_CcBaseTree + FM_PCD_CC_AD_ENTRY_SIZE* (p_FmPcdCcTree->fmPcdGroupParam[grpId].baseGroupEntry + index));
+    p_CcOldModifyAdditionalParams->isTree = TRUE;
+    p_CcOldModifyAdditionalParams->h_Node = p_FmPcdCcTree;
+    p_CcNewModifyAdditionalParams  = *h_NewPointer;
+    p_CcNewModifyAdditionalParams->isTree = TRUE;
+    p_CcNewModifyAdditionalParams->h_Node = p_FmPcdCcTree;
+
+    ModifyCcCommon2(p_CcOldModifyAdditionalParams, p_CcNewModifyAdditionalParams, (uint8_t)(p_FmPcdCcTree->fmPcdGroupParam[grpId].baseGroupEntry + index));
+
+    return E_OK;
+}
+
+
+static t_Error ModifyKeyCommonPart2(t_FmPcd *p_FmPcd, t_FmPcdCcNode *p_FmPcdCcNode, t_FmPcdModifyCcKeyAdditionalParams *p_FmPcdModifyCcKeyAdditionalParams ,t_List *h_OldLst, t_Handle *h_NewPointer)
+{
+
+    t_Error         err;
+    t_FmPcdCcNode   fmPcdCcNode;
+
+    if(!LIST_IsEmpty(&p_FmPcdCcNode->ccPrevNodesLst))
+    {
+        err =  ModifyWithNodeDataStructure(p_FmPcd,p_FmPcdCcNode->nodeId, p_FmPcdCcNode,h_OldLst);
+        if(err)
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
+    if(!LIST_IsEmpty(&p_FmPcdCcNode->ccTreeIdLst))
+    {
+        err =  ModifyWithTreeDataStructure(p_FmPcd,p_FmPcdCcNode->nodeId, p_FmPcdCcNode,h_OldLst);
+        if(err)
+        {
+            ReleaseLst(h_OldLst);
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+        }
+
+    }
+
+    memset(&fmPcdCcNode, 0, sizeof(t_FmPcdCcNode));
+    FillNodeWithParams(&fmPcdCcNode, p_FmPcdCcNode, p_FmPcdModifyCcKeyAdditionalParams);
+    err = ModifyCcKeyCommon(p_FmPcd,h_NewPointer, TRUE);
+    if(err)
+    {
+        ReleaseLst(h_OldLst);
+        ReleaseCommonModifyKey((p_FmPcd->p_FmPcdCc)->h_FmMuram,(t_FmPcdModifyCcAdditionalParams *)*h_NewPointer);
+    }
+    FillAdOfTypeContLookup(((t_FmPcdModifyCcAdditionalParams *)*h_NewPointer)->p_Ad, p_FmPcd,&fmPcdCcNode);
+
+    ((t_FmPcdModifyCcAdditionalParams *)*h_NewPointer)->h_AdditionalInfo = p_FmPcdModifyCcKeyAdditionalParams;
+
+    return E_OK;
+}
+
+
+t_Error FmPcdCcAddKey(t_Handle h_FmPcd, t_Handle h_FmPcdCcNode, uint8_t keyIndex, t_FmPcdCcKeyParams *p_FmPcdCcKeyParams, t_List *h_OldLst, t_Handle *h_NewPointer)
+{
+    t_FmPcdCcNode                   *p_FmPcdCcNode = (t_FmPcdCcNode *)h_FmPcdCcNode;
+    t_FmPcd                         *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    t_Error                         err;
+    t_FmPcdModifyCcKeyAdditionalParams *p_FmPcdModifyCcKeyAdditionalParams;
+
+    err =  ModifyKeyCommonPart1(p_FmPcdCcNode, keyIndex, &p_FmPcdModifyCcKeyAdditionalParams);
+    if(err)
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
+
+    if(keyIndex > p_FmPcdCcNode->numOfKeys)
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("keyIndex > previousely cleared last index + 1"));
+
+    if((p_FmPcdCcNode->numOfKeys + 1) > MAX_NUM_OF_PCD_CC_NODES)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("numOfKeys with new key can not be larger than 255"));
+
+    err = BuildNewNodeAddKey (h_FmPcd, p_FmPcdCcNode, keyIndex, p_FmPcdCcKeyParams, p_FmPcdModifyCcKeyAdditionalParams);
+    if(err)
+    {
+        XX_Free(p_FmPcdModifyCcKeyAdditionalParams);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
+
+    err = ModifyKeyCommonPart2(p_FmPcd, p_FmPcdCcNode, p_FmPcdModifyCcKeyAdditionalParams, h_OldLst, h_NewPointer);
+    if(err)
+    {
+            ReleaseNewNodeCommonPart(p_FmPcd->p_FmPcdCc, p_FmPcdModifyCcKeyAdditionalParams);
+            XX_Free(p_FmPcdModifyCcKeyAdditionalParams);
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
+
+    return E_OK;
+}
+
+t_Error FmPcdCcRemoveKey(t_Handle h_FmPcd, t_Handle h_FmPcdCcNode, uint8_t keyIndex,t_List *h_OldLst, t_Handle *h_NewPointer)
+{
+
+    t_FmPcdCcNode                   *p_FmPcdCcNode = (t_FmPcdCcNode *) h_FmPcdCcNode;
+    t_FmPcd                         *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    t_Error                         err;
+    t_FmPcdModifyCcKeyAdditionalParams *p_FmPcdModifyCcKeyAdditionalParams;
+
+
+    err = ModifyKeyCommonPart1(p_FmPcdCcNode, keyIndex, &p_FmPcdModifyCcKeyAdditionalParams);
+    if(err)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+
+    if(keyIndex >= p_FmPcdCcNode->numOfKeys)
+        RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("impossible to remove key from numOfKeys = 0"));
+
+    if(!p_FmPcdCcNode->numOfKeys)
+        RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("keyIndex you asked > numOfKeys of relevant node that was initialized"));
+
+    err = BuildNewNodeRemoveKey (h_FmPcd, p_FmPcdCcNode, keyIndex, p_FmPcdModifyCcKeyAdditionalParams);
+    if(err)
+    {
+        XX_Free(p_FmPcdModifyCcKeyAdditionalParams);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
+
+    err = ModifyKeyCommonPart2(p_FmPcd, p_FmPcdCcNode, p_FmPcdModifyCcKeyAdditionalParams, h_OldLst, h_NewPointer);
+    if(err)
+    {
+        ReleaseNewNodeCommonPart(p_FmPcd->p_FmPcdCc, p_FmPcdModifyCcKeyAdditionalParams);
+        XX_Free(p_FmPcdModifyCcKeyAdditionalParams);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
+
+ return E_OK;
+}
+
+t_Error FmPcdCcModifyKey(t_Handle h_FmPcd, t_Handle h_FmPcdCcNode, uint8_t keyIndex, uint8_t *p_Key, uint8_t *p_Mask, t_List *h_OldLst, t_Handle *h_NewPointer)
+{
+    t_FmPcdCcNode                   *p_FmPcdCcNode = (t_FmPcdCcNode *)h_FmPcdCcNode;
+    t_FmPcd                         *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    t_Error                         err;
+    t_FmPcdModifyCcKeyAdditionalParams *p_FmPcdModifyCcKeyAdditionalParams;
+
+    err = ModifyKeyCommonPart1(p_FmPcdCcNode, keyIndex, &p_FmPcdModifyCcKeyAdditionalParams);
+    if(err)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+
+    if(keyIndex >= p_FmPcdCcNode->numOfKeys)
+        RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("keyIndex you asked > numOfKeys of relevant node that was initialized"));
+
+    err = BuildNewNodeModifyKey (h_FmPcd, p_FmPcdCcNode, keyIndex, p_Key, p_Mask, p_FmPcdModifyCcKeyAdditionalParams);
+    if(err)
+    {
+        XX_Free(p_FmPcdModifyCcKeyAdditionalParams);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
+
+    err = ModifyKeyCommonPart2(p_FmPcd, p_FmPcdCcNode, p_FmPcdModifyCcKeyAdditionalParams, h_OldLst, h_NewPointer);
+    if(err)
+    {
+        ReleaseNewNodeCommonPart(p_FmPcd->p_FmPcdCc, p_FmPcdModifyCcKeyAdditionalParams);
+        XX_Free(p_FmPcdModifyCcKeyAdditionalParams);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
+
+ return E_OK;
+}
+
+t_Error FmPcdCcModifyKeyAndNextEngine(t_Handle h_FmPcd, t_Handle h_FmPcdNode, uint8_t keyIndex, t_FmPcdCcKeyParams *p_FmPcdCcKeyParams, t_List *h_OldLst, t_Handle *h_NewPointer)
+{
+    t_FmPcdCcNode                   *p_FmPcdCcNode = (t_FmPcdCcNode *)h_FmPcdNode;
+    t_FmPcd                         *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    t_Error                         err;
+    t_FmPcdModifyCcKeyAdditionalParams *p_FmPcdModifyCcKeyAdditionalParams;
+
+    err = ModifyKeyCommonPart1(p_FmPcdCcNode, keyIndex, &p_FmPcdModifyCcKeyAdditionalParams);
+    if(err)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+
+    if(keyIndex >= p_FmPcdCcNode->numOfKeys)
+        RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("keyIndex you asked > numOfKeys of relevant node that was initialized"));
+
+
+    err = BuildNewNodeModifyKeyAndNextEngine (h_FmPcd, p_FmPcdCcNode, keyIndex, p_FmPcdCcKeyParams, p_FmPcdModifyCcKeyAdditionalParams);
+    if(err)
+    {
+        XX_Free(p_FmPcdModifyCcKeyAdditionalParams);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
+
+    err = ModifyKeyCommonPart2(p_FmPcd, p_FmPcdCcNode, p_FmPcdModifyCcKeyAdditionalParams, h_OldLst, h_NewPointer);
+    if(err)
+    {
+        ReleaseNewNodeCommonPart(p_FmPcd->p_FmPcdCc, p_FmPcdModifyCcKeyAdditionalParams);
+        XX_Free(p_FmPcdModifyCcKeyAdditionalParams);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
+
+ return E_OK;
+}
+
+
+
+t_Error FmPcdCcModiyNextEngineParamNode(t_Handle h_FmPcd,t_Handle h_FmPcdCcNode, uint8_t keyIndex,t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams,t_Handle *h_OldPointer, t_Handle *h_NewPointer)
+{
+    t_FmPcdModifyCcAdditionalParams *p_CcOldModifyAdditionalParams;
+    t_FmPcdModifyCcAdditionalParams *p_CcNewModifyAdditionalParams;
+    t_FmPcdCcNode                   *p_FmPcdCcNode = (t_FmPcdCcNode *)h_FmPcdCcNode;
+    t_Error                         err;
+
+    SANITY_CHECK_RETURN_ERROR(h_FmPcd,E_INVALID_VALUE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcdCcNode,E_INVALID_HANDLE);
+
+
+    if(keyIndex >= p_FmPcdCcNode->numOfKeys)
+        RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("keyIndex you asked > numOfKeys of relevant node that was initialized"));
+
+    err = ModifyCcCommon1(h_FmPcd, p_FmPcdCcNextEngineParams, h_OldPointer, h_NewPointer);
+    if(err)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+
+
+    p_CcOldModifyAdditionalParams = *h_OldPointer;
+    p_CcOldModifyAdditionalParams->p_Ad = (t_Handle)((uint32_t)p_FmPcdCcNode->h_AdTable + FM_PCD_CC_AD_ENTRY_SIZE * keyIndex);
+    p_CcOldModifyAdditionalParams->h_Node = (t_Handle)p_FmPcdCcNode;
+
+    p_CcNewModifyAdditionalParams  = *h_NewPointer;
+    p_CcNewModifyAdditionalParams->h_Node = (t_Handle)p_FmPcdCcNode;
+    ModifyCcCommon2(p_CcOldModifyAdditionalParams,p_CcNewModifyAdditionalParams, keyIndex);
+
+    return E_OK;
+}
+
+t_Error FmPcdCcModifyMissNextEngineParamNode(t_Handle h_FmPcd, t_Handle h_FmPcdCcNode, t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams,t_Handle *h_OldPointer, t_Handle *h_NewPointer)
+{
+    t_FmPcdModifyCcAdditionalParams *p_CcOldModifyAdditionalParams;
+    t_FmPcdModifyCcAdditionalParams *p_CcNewModifyAdditionalParams;
+    t_FmPcdCcNode                   *p_FmPcdCcNode = (t_FmPcdCcNode *)h_FmPcdCcNode;
+    t_Error                         err;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcdCcNode,E_INVALID_VALUE);
+
+    err = ModifyCcCommon1(h_FmPcd, p_FmPcdCcNextEngineParams, h_OldPointer, h_NewPointer);
+    if(err)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+
+
+    p_CcOldModifyAdditionalParams = *h_OldPointer;
+    p_CcOldModifyAdditionalParams->p_Ad = (t_Handle)((uint32_t)p_FmPcdCcNode->h_AdTable + FM_PCD_CC_AD_ENTRY_SIZE * p_FmPcdCcNode->numOfKeys);
+    p_CcOldModifyAdditionalParams->h_Node = (t_Handle)p_FmPcdCcNode;
+
+    p_CcNewModifyAdditionalParams  = *h_NewPointer;
+    p_CcOldModifyAdditionalParams->h_Node = (t_Handle)p_FmPcdCcNode;
+    ModifyCcCommon2(p_CcOldModifyAdditionalParams,p_CcNewModifyAdditionalParams,p_FmPcdCcNode->numOfKeys);
+
+    return E_OK;
+}
+static t_Error UpdateNodesWithTree(t_Handle h_FmPcd,t_List *ccNextNodesLst, uint16_t *p_CcArray, uint8_t treeId)
+{
+    t_List          *p_Pos;
+    t_Error         err;
+    t_FmPcdCcNode   *p_FmPcdCcNode;
+    uint32_t        nodeIdTmp;
+    if(!LIST_IsEmpty(ccNextNodesLst))
+     {
+         LIST_FOR_EACH(p_Pos, ccNextNodesLst)
+         {
+             nodeIdTmp = ((t_CcNodeInfo *)CC_NEXT_NODE_F_OBJECT(p_Pos))->nextCcNodeInfo;
+             p_FmPcdCcNode = (t_FmPcdCcNode *)GetNodeHandler((t_FmPcd *)h_FmPcd, (uint16_t)nodeIdTmp);
+             if(!p_FmPcdCcNode)
+                 RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
+             if(p_CcArray[(uint16_t)nodeIdTmp] ==0)
+             {
+                 err = UpdateNodesWithTree(h_FmPcd, &p_FmPcdCcNode->ccNextNodesLst,p_CcArray, treeId);
+                 if(err)
+                     RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
+                 CreateNodeInfo(&p_FmPcdCcNode->ccTreesLst, (uint32_t)treeId);
+                 p_CcArray[(uint16_t)nodeIdTmp] = 1;
+             }
+         }
+     }
+    return E_OK;
+}
+
+static t_Error RemoveNodesFromTree(t_Handle h_FmPcd,t_List *ccNextNodesLst, uint8_t treeId)
+{
+    t_List          *p_Pos;
+    t_Error         err;
+    t_FmPcdCcNode   *p_FmPcdCcNode;
+    uint32_t        nodeIdTmp;
+    t_CcNodeInfo    *p_CcNodeInfo;
+    if(!LIST_IsEmpty(ccNextNodesLst))
+    {
+        LIST_FOR_EACH(p_Pos, ccNextNodesLst)
+        {
+            nodeIdTmp = ((t_CcNodeInfo *)CC_NEXT_NODE_F_OBJECT(p_Pos))->nextCcNodeInfo;
+            p_FmPcdCcNode = GetNodeHandler((t_FmPcd *)h_FmPcd, (uint16_t)nodeIdTmp);
+            if(!p_FmPcdCcNode)
+                RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
+
+            err = RemoveNodesFromTree(h_FmPcd, &p_FmPcdCcNode->ccNextNodesLst, treeId);
+            if(err)
+                RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
+            p_CcNodeInfo = FindNodeInfoAccId(&p_FmPcdCcNode->ccTreesLst, treeId);
+            ASSERT_COND(p_CcNodeInfo);
+            LIST_DelAndInit(&p_CcNodeInfo->h_Node);
+            XX_Free(p_CcNodeInfo);
+        }
+    }
+
+    return E_OK;
+}
+
+
+t_Error FmPcdCcReleaseModifiedOnlyNextEngine(t_Handle h_FmPcd, t_Handle h_FmPcdOldPointer, t_Handle h_FmPcdNewPointer, bool isAllGood)
+{
+    t_FmPcdModifyCcAdditionalParams *p_CcOldModifyAdditionalParams = (t_FmPcdModifyCcAdditionalParams *)h_FmPcdOldPointer;
+    t_FmPcdModifyCcAdditionalParams *p_CcNewModifyAdditionalParams = (t_FmPcdModifyCcAdditionalParams *)h_FmPcdNewPointer;
+    t_FmPcd                         *p_FmPcd = (t_FmPcd *)h_FmPcd;
+    t_FmPcdCcTree                   *p_CurrentTree=NULL;
+    t_FmPcdCcNode                   *p_CurrentNode=NULL, *p_NodeForAdd, *p_NodeForRemove;
+    t_CcNodeInfo                    *p_CcNodeInfo, *p_CcNodeInfo1;
+    uint16_t                         numOfReplec;
+    t_Error                          err;
+    t_List                          *p_Pos;
+    uint16_t                        ccArray[MAX_NUM_OF_PCD_CC_NODES];
+
+    SANITY_CHECK_RETURN_ERROR(h_FmPcd,E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdCc,E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(h_FmPcdOldPointer,E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_CcNewModifyAdditionalParams->h_Node,E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_CcOldModifyAdditionalParams->h_Node,E_INVALID_HANDLE);
+
+    if(isAllGood)
+    {
+            if(p_CcNewModifyAdditionalParams->isTree)
+                p_CurrentTree = (t_FmPcdCcTree*)p_CcNewModifyAdditionalParams->h_Node;
+            else
+                p_CurrentNode = (t_FmPcdCcNode*)p_CcNewModifyAdditionalParams->h_Node;
+           if(p_CurrentTree)
+            {
+                    if(p_CcNewModifyAdditionalParams->myInfo != 0xffffffff)
+                    {
+                        p_NodeForAdd = GetNodeHandler(p_FmPcd, (uint16_t)p_CcNewModifyAdditionalParams->myInfo);
+                        ASSERT_COND(p_NodeForAdd);
+                        CreateNodeInfo(&p_CurrentTree->ccNextNodesLst, p_CcNewModifyAdditionalParams->myInfo);
+                        p_CcNodeInfo = FindNodeInfoAccId(&p_NodeForAdd->ccTreeIdLst, p_CurrentTree->treeId);
+                        if(p_CcNodeInfo)
+                        {
+                            numOfReplec = (uint16_t)(p_CcNodeInfo->nextCcNodeInfo >> 16);
+                            p_CcNodeInfo->nextCcNodeInfo = ((p_CcNodeInfo->nextCcNodeInfo & 0x0000ffff) | ((uint32_t)(numOfReplec+1) <<16));
+                        }
+                        else
+                            CreateNodeInfo(&p_NodeForAdd->ccTreeIdLst, (uint32_t)((uint32_t)p_CurrentTree->treeId | ((uint32_t)1<<16)));
+                        memset(ccArray, 0, sizeof(uint16_t) * MAX_NUM_OF_PCD_CC_NODES);
+                        err = UpdateNodesWithTree(h_FmPcd, &p_NodeForAdd->ccNextNodesLst, ccArray, p_CurrentTree->treeId);
+                        if(err)
+                            RETURN_ERROR(MAJOR, err, NO_MSG);
+                    }
+                    if(p_CcOldModifyAdditionalParams->myInfo != 0xffffffff)
+                    {
+                        p_CcNodeInfo = FindNodeInfoAccIndex(&p_CurrentTree->ccNextNodesLst, (uint16_t)p_CcOldModifyAdditionalParams->myInfo);
+                        ASSERT_COND(p_CcNodeInfo);
+                        p_NodeForRemove = GetNodeHandler(p_FmPcd, (uint16_t)p_CcNodeInfo->nextCcNodeInfo);
+                        ASSERT_COND(p_NodeForRemove);
+                        UpdateNodeOwner(p_FmPcd, p_NodeForRemove->nodeId, FALSE);
+                        p_CcNodeInfo1 = FindNodeInfoAccId(&p_NodeForRemove->ccTreeIdLst, p_CurrentTree->treeId);
+                        ASSERT_COND(p_CcNodeInfo1);
+                        numOfReplec = (uint16_t)(p_CcNodeInfo1->nextCcNodeInfo >> 16);
+                        ASSERT_COND(numOfReplec);
+                        numOfReplec -=1;
+                        if(numOfReplec)
+                            p_CcNodeInfo1->nextCcNodeInfo = (uint32_t)((p_CcNodeInfo1->nextCcNodeInfo & 0x0000ffff) | (numOfReplec << 16));
+                        else
+                        {
+                            LIST_DelAndInit(&p_CcNodeInfo1->h_Node);
+                            XX_Free(p_CcNodeInfo1);
+                        }
+                        LIST_DelAndInit(&p_CcNodeInfo->h_Node);
+                        XX_Free(p_CcNodeInfo);
+                        err = RemoveNodesFromTree(h_FmPcd, &p_NodeForRemove->ccNextNodesLst, p_CurrentTree->treeId);
+                        if(err)
+                            RETURN_ERROR(MAJOR, err, NO_MSG);
+                     }
+            }
+            else if(p_CurrentNode)
+            {
+                   if(p_CcNewModifyAdditionalParams->myInfo != 0xffffffff)
+                    {
+                        p_NodeForAdd = GetNodeHandler(p_FmPcd, (uint16_t)p_CcNewModifyAdditionalParams->myInfo);
+                        ASSERT_COND(p_NodeForAdd);
+                        CreateNodeInfo(&p_CurrentNode->ccNextNodesLst, p_CcNewModifyAdditionalParams->myInfo);
+                        p_CcNodeInfo = FindNodeInfoAccId(&p_NodeForAdd->ccPrevNodesLst, p_CurrentNode->nodeId);
+                        if(p_CcNodeInfo)
+                        {
+                            numOfReplec = (uint16_t)(p_CcNodeInfo->nextCcNodeInfo >> 16);
+                            p_CcNodeInfo->nextCcNodeInfo = ((p_CcNodeInfo->nextCcNodeInfo & 0x0000ffff) | ((uint32_t)(numOfReplec+1) <<16));
+                        }
+                        else
+                            CreateNodeInfo(&p_NodeForAdd->ccPrevNodesLst, (uint32_t)((uint32_t)p_CurrentNode->nodeId | ((uint32_t)1<<16)));
+
+                        LIST_FOR_EACH(p_Pos, &p_CurrentNode->ccTreesLst)
+                        {
+                            p_CcNodeInfo = CC_NEXT_NODE_F_OBJECT(p_Pos);
+                            memset(ccArray, 0, sizeof(uint16_t)*MAX_NUM_OF_PCD_CC_NODES);
+                            err = UpdateNodesWithTree(p_FmPcd, &p_NodeForAdd->ccNextNodesLst, ccArray, (uint8_t)p_CcNodeInfo->nextCcNodeInfo);
+                            if(err)
+                                RETURN_ERROR(MAJOR, err, NO_MSG);
+                        }
+                    }
+                    if(p_CcOldModifyAdditionalParams->myInfo != 0xffffffff)
+                    {
+                        p_CcNodeInfo = FindNodeInfoAccIndex(&p_CurrentNode->ccNextNodesLst, (uint16_t)p_CcOldModifyAdditionalParams->myInfo);
+                        ASSERT_COND(p_CcNodeInfo);
+                        p_NodeForRemove = GetNodeHandler(p_FmPcd, (uint16_t)p_CcNodeInfo->nextCcNodeInfo);
+                        ASSERT_COND(p_NodeForRemove);
+                        p_CcNodeInfo1 = FindNodeInfoAccId(&p_NodeForRemove->ccPrevNodesLst, p_CurrentNode->nodeId);
+                        UpdateNodeOwner(p_FmPcd, p_NodeForRemove->nodeId, FALSE);
+                        ASSERT_COND(p_CcNodeInfo1);
+                        numOfReplec = (uint16_t)(p_CcNodeInfo1->nextCcNodeInfo >> 16);
+                        ASSERT_COND(numOfReplec);
+                        numOfReplec -=1;
+                        if(numOfReplec)
+                            p_CcNodeInfo1->nextCcNodeInfo = (uint32_t)((p_CcNodeInfo1->nextCcNodeInfo & 0x0000ffff) | (numOfReplec << 16));
+                        else
+                        {
+                            LIST_DelAndInit(&p_CcNodeInfo1->h_Node);
+                            XX_Free(p_CcNodeInfo1);
+                        }
+                        LIST_DelAndInit(&p_CcNodeInfo->h_Node);
+                        XX_Free(p_CcNodeInfo);
+                        LIST_FOR_EACH(p_Pos, &p_CurrentNode->ccTreesLst)
+                        {
+                            p_CcNodeInfo = CC_NEXT_NODE_F_OBJECT(p_Pos);
+                            err = RemoveNodesFromTree(h_FmPcd, &p_NodeForRemove->ccNextNodesLst, (uint8_t)p_CcNodeInfo->nextCcNodeInfo);
+                            if(err)
+                                RETURN_ERROR(MAJOR, err, NO_MSG);
+                        }
+                  }
+            }
+       }
+         else
+         {
+        if(p_CcNewModifyAdditionalParams->myInfo != 0xffffffff)
+            UpdateNodeOwner(p_FmPcd, (uint16_t)p_CcNewModifyAdditionalParams->myInfo, FALSE);
+       }
+
+    if(p_CcNewModifyAdditionalParams->p_Ad)
+        FM_MURAM_FreeMem(p_FmPcd->p_FmPcdCc->h_FmMuram,p_CcNewModifyAdditionalParams->p_Ad);
+
+    XX_Free(h_FmPcdNewPointer);
+    XX_Free(h_FmPcdOldPointer);
+
+    return E_OK;
+}
+t_Error FmPcdCcReleaseModifiedKey(t_Handle h_FmPcd, t_List *h_FmPcdOldPointersLst, t_Handle h_FmPcdNewPointer, uint16_t numOfGoodChanges)
+{
+    t_FmPcdModifyCcAdditionalParams *p_CcNewModifyAdditionalParams = (t_FmPcdModifyCcAdditionalParams *)h_FmPcdNewPointer;
+    t_FmPcd                         *p_FmPcd = (t_FmPcd *)h_FmPcd;
+    t_CcNodeInfo                    *p_CcNodeInfo, *p_CcNodeInfo1;
+    t_FmPcdModifyCcKeyAdditionalParams *p_FmPcdCcKeyAdditionalParams;
+    t_FmPcdCcNode                  *p_CurrentNode = NULL, *p_NodeForAdd, *p_NodeForRemove;
+    uint32_t                        numOfReplec;
+    t_List                          *p_Pos;
+    t_Error                         err;
+    uint16_t                        ccArray[MAX_NUM_OF_PCD_CC_NODES];
+
+    UNUSED(numOfGoodChanges);
+
+    SANITY_CHECK_RETURN_ERROR(h_FmPcd,E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdCc,E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(h_FmPcdOldPointersLst,E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(h_FmPcdNewPointer,E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR((numOfGoodChanges == LIST_NumOfObjs(h_FmPcdOldPointersLst)),E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(p_CcNewModifyAdditionalParams->h_AdditionalInfo,E_INVALID_HANDLE);
+
+            p_FmPcdCcKeyAdditionalParams  = (t_FmPcdModifyCcKeyAdditionalParams *)p_CcNewModifyAdditionalParams->h_AdditionalInfo;
+            p_CurrentNode = (t_FmPcdCcNode *)p_FmPcdCcKeyAdditionalParams->h_CurrentNode;
+            if(p_FmPcdCcKeyAdditionalParams->nodeIdForAdd != 0xffff)
+            {
+                p_NodeForAdd = GetNodeHandler(p_FmPcd, p_FmPcdCcKeyAdditionalParams->nodeIdForAdd);
+                ASSERT_COND(p_NodeForAdd);
+                p_CcNodeInfo = FindNodeInfoAccId(&p_NodeForAdd->ccPrevNodesLst, p_CurrentNode->nodeId);
+                if(p_CcNodeInfo)
+                {
+                    numOfReplec = p_CcNodeInfo->nextCcNodeInfo >> 16;
+                    numOfReplec +=1;
+                    p_CcNodeInfo->nextCcNodeInfo = (uint32_t)((p_CcNodeInfo->nextCcNodeInfo & 0x0000ffff) | (numOfReplec << 16));
+                }
+                else
+                {
+                    numOfReplec = (uint32_t)p_CurrentNode->nodeId | ((uint32_t)1<<16);
+                    CreateNodeInfo(&p_NodeForAdd->ccPrevNodesLst, numOfReplec);
+                }
+                CreateNodeInfo(&p_CurrentNode->ccNextNodesLst, (((uint32_t)p_FmPcdCcKeyAdditionalParams->keyIndexForAdd << 16) |(uint32_t)p_FmPcdCcKeyAdditionalParams->nodeIdForAdd));
+                LIST_FOR_EACH(p_Pos, &p_CurrentNode->ccTreesLst)
+                {
+                    p_CcNodeInfo = CC_NEXT_NODE_F_OBJECT(p_Pos);
+                    memset(ccArray, 0, sizeof(uint16_t)*MAX_NUM_OF_PCD_CC_NODES);
+                    err = UpdateNodesWithTree(p_FmPcd, &p_NodeForAdd->ccNextNodesLst, ccArray, (uint8_t)p_CcNodeInfo->nextCcNodeInfo);
+                    if(err)
+                        RETURN_ERROR(MAJOR, err, NO_MSG);
+                }
+            }
+            if(p_FmPcdCcKeyAdditionalParams->keyIndexForRemove != 0xffff)
+            {
+                p_CcNodeInfo =  FindNodeInfoAccIndex(&p_CurrentNode->ccNextNodesLst, p_FmPcdCcKeyAdditionalParams->keyIndexForRemove);
+                ASSERT_COND(p_CcNodeInfo);
+                p_NodeForRemove = GetNodeHandler(p_FmPcd, (uint16_t)p_CcNodeInfo->nextCcNodeInfo);
+                UpdateNodeOwner(p_FmPcd, (uint16_t)p_CcNodeInfo->nextCcNodeInfo, FALSE);
+                p_CcNodeInfo1 = FindNodeInfoAccId(&p_NodeForRemove->ccPrevNodesLst, p_CurrentNode->nodeId);
+                numOfReplec = p_CcNodeInfo1->nextCcNodeInfo >> 16;
+                ASSERT_COND(numOfReplec);
+                numOfReplec -=1;
+                if(numOfReplec)
+                    p_CcNodeInfo->nextCcNodeInfo = (uint32_t)((p_CcNodeInfo1->nextCcNodeInfo & 0x0000ffff) | (numOfReplec << 16));
+                else
+                {
+                    LIST_DelAndInit(&p_CcNodeInfo1->h_Node);
+                    XX_Free(p_CcNodeInfo1);
+                }
+                LIST_DelAndInit(&p_CcNodeInfo->h_Node);
+                XX_Free(p_CcNodeInfo);
+                LIST_FOR_EACH(p_Pos, &p_CurrentNode->ccTreesLst)
+                {
+                    p_CcNodeInfo = CC_NEXT_NODE_F_OBJECT(p_Pos);
+                    err = RemoveNodesFromTree(h_FmPcd, &p_NodeForRemove->ccNextNodesLst, (uint8_t)p_CcNodeInfo->nextCcNodeInfo);
+                    if(err)
+                        RETURN_ERROR(MAJOR, err, NO_MSG);
+                 }
+              }
+
+            ASSERT_COND(p_FmPcdCcKeyAdditionalParams->p_AdTableOld);
+            FM_MURAM_FreeMem(p_FmPcd->p_FmPcdCc->h_FmMuram,p_FmPcdCcKeyAdditionalParams->p_AdTableOld);
+            ASSERT_COND(p_FmPcdCcKeyAdditionalParams->p_KeysMatchTableOld);
+            FM_MURAM_FreeMem(p_FmPcd->p_FmPcdCc->h_FmMuram,p_FmPcdCcKeyAdditionalParams->p_KeysMatchTableOld);
+
+            p_CurrentNode->h_AdTable    = p_FmPcdCcKeyAdditionalParams->p_AdTableNew;
+            p_CurrentNode->numOfKeys    = p_FmPcdCcKeyAdditionalParams->numOfKeys;
+            p_CurrentNode->lclMask      = p_FmPcdCcKeyAdditionalParams->lclMask;
+            p_CurrentNode->h_KeysMatchTable = p_FmPcdCcKeyAdditionalParams->p_KeysMatchTableNew;
+
+            XX_Free(p_CcNewModifyAdditionalParams->h_AdditionalInfo);
+            p_CcNewModifyAdditionalParams->h_AdditionalInfo = NULL;
+
+    ReleaseLst(h_FmPcdOldPointersLst);
+
+    if(p_CcNewModifyAdditionalParams->p_Ad)
+        FM_MURAM_FreeMem(p_FmPcd->p_FmPcdCc->h_FmMuram,p_CcNewModifyAdditionalParams->p_Ad);
+
+    XX_Free(h_FmPcdNewPointer);
+
+    return E_OK;
+}
+
+uint32_t FmPcdCcGetNodeAddrOffset(t_Handle h_FmPcd, t_Handle h_Pointer)
+{
+    t_FmPcd                         *p_FmPcd = (t_FmPcd *)h_FmPcd;
+
+    SANITY_CHECK_RETURN_VALUE(h_FmPcd,E_INVALID_HANDLE, (uint32_t)ILLEGAL_BASE);
+    SANITY_CHECK_RETURN_VALUE(p_FmPcd->p_FmPcdCc,E_INVALID_HANDLE, (uint32_t)ILLEGAL_BASE);
+
+    return (uint32_t)(CAST_POINTER_TO_UINT64(XX_VirtToPhys(((t_FmPcdModifyCcAdditionalParams *)h_Pointer)->p_Ad)) -
+                     p_FmPcd->p_FmPcdCc->physicalMuramBase);
+}
+
+uint32_t FmPcdCcGetNodeAddrOffsetFromNodeInfo(t_Handle h_FmPcd, t_Handle h_Pointer)
+{
+    t_FmPcd                         *p_FmPcd = (t_FmPcd *)h_FmPcd;
+    t_CcNodeInfo                    *p_CcNodeInfo;
+
+    SANITY_CHECK_RETURN_VALUE(h_FmPcd,E_INVALID_HANDLE, (uint32_t)ILLEGAL_BASE);
+    SANITY_CHECK_RETURN_VALUE(p_FmPcd->p_FmPcdCc,E_INVALID_HANDLE, (uint32_t)ILLEGAL_BASE);
+
+    p_CcNodeInfo = CC_NEXT_NODE_F_OBJECT(h_Pointer);
+    return (uint32_t)(CAST_POINTER_TO_UINT64(XX_VirtToPhys(CAST_UINT32_TO_POINTER(p_CcNodeInfo->nextCcNodeInfo))) -
+                      p_FmPcd->p_FmPcdCc->physicalMuramBase);
+}
+
+static t_Error  FmPcdCcUpdateTreeOwner(t_Handle h_FmPcd, uint8_t treeId, bool add)
+{
+
+
+    t_FmPcd *p_FmPcd = (t_FmPcd*)h_FmPcd;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd,E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdCc,E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdCc->ccTreeArrayEntry[treeId].p_FmPcdCcTree,E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR((treeId < MAX_NUM_OF_PCD_CC_TREES), E_INVALID_VALUE);
+
+    if(add)
+        p_FmPcd->p_FmPcdCc->ccTreeArrayEntry[treeId].owners++;
+    else
+    {
+        if(!p_FmPcd->p_FmPcdCc->ccTreeArrayEntry[treeId].owners)
+            RETURN_ERROR(MAJOR, E_INVALID_SELECTION, ("this tree wasn't assighned before"))  ;
+        p_FmPcd->p_FmPcdCc->ccTreeArrayEntry[treeId].owners--;
+    }
+
+    return E_OK;
+}
+
+t_Error     CcGetGrpParams(t_Handle h_FmPcdCcTree, uint8_t grpId, uint32_t *p_GrpBits, uint8_t *p_GrpBase)
+{
+    t_FmPcdCcTree *p_FmPcdCcTree = (t_FmPcdCcTree *) h_FmPcdCcTree;
+
+    SANITY_CHECK_RETURN_ERROR((grpId <= 7),E_INVALID_STATE);
+
+    if(grpId >= p_FmPcdCcTree->numOfGrps)
+        RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("grpId you asked > numOfGroup of relevant tree"));
+    *p_GrpBits = p_FmPcdCcTree->fmPcdGroupParam[grpId].totalBitsMask;
+    *p_GrpBase = p_FmPcdCcTree->fmPcdGroupParam[grpId].baseGroupEntry;
+    return E_OK;
+}
+
+t_Handle CcConfig(t_FmPcd *p_FmPcd, t_FmPcdParams *p_FmPcdParams)
+{
+    t_FmPcdCc           *p_FmPcdCc;
+#ifdef CONFIG_GUEST_PARTITION
+    t_FmPcdIcPhysAddr   physicalMuramBase;
+    t_Error             err;
+#else
+    t_FmPhysAddr        physicalMuramBase;
+#endif /* CONFIG_GUEST_PARTITION */
+
+    UNUSED(p_FmPcd);
+    p_FmPcdCc = (t_FmPcdCc *) XX_Malloc(sizeof(t_FmPcdCc));
+    if (!p_FmPcdCc)
+    {
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM Cc allocation FAILED"));
+        return NULL;
+    }
+    memset(p_FmPcdCc, 0, sizeof(t_FmPcdCc));
+
+    p_FmPcdCc->h_FmMuram = p_FmPcdParams->h_FmMuram;
+#ifndef CONFIG_GUEST_PARTITION
+    FmGetPhysicalMuramBase(p_FmPcdParams->h_Fm, &physicalMuramBase);
+#else
+    err = XX_SendMessage(p_FmPcd->fmPcdModuleName, FM_PCD_GET_PHYS_MURAM_BASE, (uint8_t*)&physicalMuramBase, NULL, NULL);
+    if(err)
+    {
+        REPORT_ERROR(MINOR, err, NO_MSG);
+    }
+#endif /* CONFIG_GUEST_PARTITION */
+    p_FmPcdCc->physicalMuramBase = (uint64_t)((uint64_t)(&physicalMuramBase)->low | ((uint64_t)(&physicalMuramBase)->high << 32));
+
+    return p_FmPcdCc;
+}
+
+void CcFree(t_FmPcdCc *p_FmPcdCc)
+{
+
+    int i = 0;
+    for (i = 0; i < MAX_NUM_OF_PCD_CC_NODES; i++)
+        ReleaseNode(p_FmPcdCc, (uint16_t)i);
+
+    for(i = 0; i < MAX_NUM_OF_PCD_CC_TREES; i++)
+        ReleaseTree(p_FmPcdCc, (uint8_t)i);
+}
+
+t_Error  FmPcdCcBindTree(t_Handle h_FmPcd, t_Handle  h_FmPcdCcTree,  uint32_t  *p_Offset)
+{
+    t_FmPcd *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    t_FmPcdCcTree       *p_FmPcdCcTree = (t_FmPcdCcTree *)h_FmPcdCcTree;
+    t_Error             err;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd,E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdCc,E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcdCcTree,E_INVALID_STATE);
+
+    err = FmPcdCcUpdateTreeOwner(h_FmPcd, p_FmPcdCcTree->treeId, TRUE);
+    if(err)
+        RETURN_ERROR(MINOR, err, NO_MSG);
+
+    *p_Offset = CAST_POINTER_TO_UINT32(XX_VirtToPhys(CAST_UINT32_TO_POINTER((uint32_t)p_FmPcdCcTree->p_CcBaseTree))) - ((t_FmPcd *)p_FmPcd)->p_FmPcdCc->physicalMuramBase;
+
+    return E_OK;
+}
+
+t_Error FmPcdCcUnbindTree(t_Handle h_FmPcd, t_Handle  h_FmPcdCcTree)
+{
+    t_FmPcdCcTree       *p_FmPcdCcTree = (t_FmPcdCcTree *)h_FmPcdCcTree;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcdCcTree,E_INVALID_HANDLE);
+
+    return  FmPcdCcUpdateTreeOwner(h_FmPcd, p_FmPcdCcTree->treeId, FALSE);
+}
+
+t_Handle FM_PCD_CcBuildTree(t_Handle h_FmPcd, t_FmPcdCcTreeParams *p_PcdGroupsParam)
+{
+    t_FmPcd                     *p_FmPcd = (t_FmPcd *)h_FmPcd;
+    t_FmPcdCc                   *p_FmPcdCc;
+    t_Error                     err;
+    uint8_t                     treeId;
+    int                         i = 0, j = 0, k = 0;
+    t_FmPcdCcTree               *p_FmPcdCcTree;
+    uint8_t                     numOfEntries;
+    t_Handle                    p_CcTreeTmp;
+    t_FmPcdCcGrpParams          *p_FmPcdCcGroupParams;
+    t_FmPcdCcNextEngineParams   params[16];
+    t_NetEnvParams              netEnvParams;
+    uint8_t                     lastOne = 0;
+    t_CcNodeInfo                *p_CcNodeInfo;
+    t_NextEngineParamsInfo      nextEngineParamsInfo;
+    uint16_t                    ccInfo[MAX_NUM_OF_PCD_CC_NODES];
+    t_FmPcdCcNode               *p_FmPcdCcNextNode;
+    t_List                      *p_Pos;
+    t_List                      ccNextDifferentNodesLst;
+    uint32_t                    myInfo;
+    uint16_t                     ccArray[MAX_NUM_OF_PCD_CC_NODES];
+
+    SANITY_CHECK_RETURN_VALUE(h_FmPcd,E_INVALID_HANDLE, NULL);
+    SANITY_CHECK_RETURN_VALUE(p_PcdGroupsParam,E_INVALID_HANDLE, NULL);
+    SANITY_CHECK_RETURN_VALUE(p_FmPcd->p_FmPcdCc,E_INVALID_STATE, NULL);
+
+    memset(ccInfo, 0, sizeof(uint8_t) * MAX_NUM_OF_PCD_CC_NODES);
+    memset(ccArray, 0, sizeof(uint16_t) * MAX_NUM_OF_PCD_CC_NODES);
+
+    memset(params, 0, 16 * sizeof(t_FmPcdCcNextEngineParams));
+    p_FmPcdCc = p_FmPcd->p_FmPcdCc;
+
+    err = OccupyTreeId(p_FmPcd, &treeId);
+    if(err)
+    {
+        REPORT_ERROR(MAJOR, err, NO_MSG);
+        return NULL;
+    }
+
+    p_FmPcdCcTree = (t_FmPcdCcTree*)XX_Malloc (sizeof(t_FmPcdCcTree));
+    if(!p_FmPcdCcTree)
+    {
+        ReleaseTree(p_FmPcdCc,treeId);
+        ReleaseTreeHandler(p_FmPcdCcTree,p_FmPcdCc);
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("No memory"));
+        return NULL;
+    }
+    memset(p_FmPcdCcTree, 0, sizeof(t_FmPcdCcTree)) ;
+
+    INIT_LIST(&p_FmPcdCcTree->ccNextNodesLst);
+    INIT_LIST(&p_FmPcdCcTree->fmPortsLst);
+    INIT_LIST(&ccNextDifferentNodesLst);
+
+    if(p_PcdGroupsParam->numOfGrps > 8)
+    {
+        ReleaseTree(p_FmPcdCc,treeId);
+        ReleaseTreeHandler(p_FmPcdCcTree,p_FmPcdCc);
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("numOfGrps can not be greater than 8"));
+        return NULL;
+    }
+    numOfEntries = 0;
+    p_FmPcdCcTree->netEnvId = (uint8_t)(CAST_POINTER_TO_UINT32(p_PcdGroupsParam->h_NetEnv)-1);
+    for(i = 0; i < p_PcdGroupsParam->numOfGrps; i++)
+    {
+        p_FmPcdCcGroupParams = &p_PcdGroupsParam->ccGrpParams[i];
+        p_FmPcdCcTree->fmPcdGroupParam[i].baseGroupEntry = numOfEntries;
+        p_FmPcdCcTree->fmPcdGroupParam[i].numOfEntriesInGroup =(uint8_t)( 0x01 << p_FmPcdCcGroupParams->numOfDistinctionUnits);
+        numOfEntries += p_FmPcdCcTree->fmPcdGroupParam[i].numOfEntriesInGroup;
+        if(numOfEntries > 16)
+        {
+            ReleaseTree(p_FmPcdCc,treeId);
+            ReleaseTreeHandler(p_FmPcdCcTree,p_FmPcdCc);
+            REPORT_ERROR(MAJOR, E_NO_MEMORY, ("numOfEntries can not be larger than 16"));
+            return NULL;
+        }
+        if(lastOne)
+        {
+            if(p_FmPcdCcTree->fmPcdGroupParam[i].numOfEntriesInGroup > lastOne)
+            {
+                ReleaseTree(p_FmPcdCc,treeId);
+                ReleaseTreeHandler(p_FmPcdCcTree,p_FmPcdCc);
+                REPORT_ERROR(MAJOR, E_NO_MEMORY, ("numOfEntries per group in Tree has to  be from biggest to lower"));
+                return NULL;
+            }
+        }
+
+        lastOne = p_FmPcdCcTree->fmPcdGroupParam[i].numOfEntriesInGroup;
+
+        netEnvParams.netEnvId = p_FmPcdCcTree->netEnvId;
+        netEnvParams.numOfDistinctionUnits = p_FmPcdCcGroupParams->numOfDistinctionUnits;
+        memcpy(netEnvParams.unitIds, &p_FmPcdCcGroupParams->unitIds, p_FmPcdCcGroupParams->numOfDistinctionUnits);
+        err = PcdGetUnitsVector(p_FmPcd, &netEnvParams);
+        if(err)
+        {
+            ReleaseTree(p_FmPcdCc,treeId);
+            ReleaseTreeHandler(p_FmPcdCcTree,p_FmPcdCc);
+            REPORT_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
+            return NULL;
+        }
+
+        p_FmPcdCcTree->fmPcdGroupParam[i].totalBitsMask = netEnvParams.vector;
+        for(j = 0; j < p_FmPcdCcTree->fmPcdGroupParam[i].numOfEntriesInGroup; j++)
+        {
+
+            err = ValidateNextEngineParams(h_FmPcd,&p_FmPcdCcGroupParams->p_NextEnginePerEntriesInGrp[j], &nextEngineParamsInfo);
+            if(err)
+            {
+                ReleaseTree(p_FmPcdCc,treeId);
+                ReleaseTreeHandler(p_FmPcdCcTree,p_FmPcdCc);
+                REPORT_ERROR(MAJOR, err, (NO_MSG));
+                return NULL;
+            }
+            if(nextEngineParamsInfo.fmPcdEngine == e_FM_PCD_CC)
+            {
+                myInfo = (uint32_t)nextEngineParamsInfo.additionalInfo | (uint32_t)k << 16;
+                CreateNodeInfo(&p_FmPcdCcTree->ccNextNodesLst, myInfo);
+                if(ccInfo[nextEngineParamsInfo.additionalInfo] == 0)
+                    CreateNodeInfo(&ccNextDifferentNodesLst, (uint32_t)nextEngineParamsInfo.additionalInfo);
+
+                ccInfo[nextEngineParamsInfo.additionalInfo] +=1;
+            }
+           memcpy(&params[k], &p_FmPcdCcGroupParams->p_NextEnginePerEntriesInGrp[j], sizeof(t_FmPcdCcNextEngineParams));
+           k++;
+        }
+    }
+
+    p_FmPcdCcTree->numOfGrps = p_PcdGroupsParam->numOfGrps;
+    p_FmPcdCcTree->p_CcBaseTree = FM_MURAM_AllocMem(p_FmPcdCc->h_FmMuram,
+                                         (uint32_t)( k * FM_PCD_CC_AD_ENTRY_SIZE),
+                                         FM_PCD_CC_AD_TABLE_ALIGN);
+
+    if(!p_FmPcdCcTree->p_CcBaseTree)
+    {
+        ReleaseTree(p_FmPcdCc,treeId);
+        ReleaseTreeHandler(p_FmPcdCcTree,p_FmPcdCc);
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("No memory"));
+        return NULL;
+    }
+    WRITE_BLOCK((uint8_t *)p_FmPcdCcTree->p_CcBaseTree, 0, (uint32_t)(k * FM_PCD_CC_AD_ENTRY_SIZE));
+
+    p_CcTreeTmp  = p_FmPcdCcTree->p_CcBaseTree;
+
+    j = 0;
+    for(i = 0; i < numOfEntries; i++)
+    {
+        NextStepAd(p_CcTreeTmp,&params[i],p_FmPcd);
+        p_CcTreeTmp =   (t_Handle)(((uint32_t)p_CcTreeTmp) + FM_PCD_CC_AD_ENTRY_SIZE);
+    }
+
+    if(!LIST_IsEmpty(&ccNextDifferentNodesLst))
+    {
+        LIST_FOR_EACH(p_Pos, &ccNextDifferentNodesLst)
+        {
+            p_CcNodeInfo = CC_NEXT_NODE_F_OBJECT(p_Pos);
+            p_FmPcdCcNextNode = (t_FmPcdCcNode *)GetNodeHandler(p_FmPcd, (uint16_t)p_CcNodeInfo->nextCcNodeInfo);
+            if(!p_FmPcdCcNextNode)
+            {
+                ReleaseTree(p_FmPcdCc,treeId);
+                ReleaseTreeHandler(p_FmPcdCcTree,p_FmPcdCc);
+                REPORT_ERROR(MAJOR, E_NO_MEMORY, ("No memory"));
+                return NULL;
+            }
+            myInfo = (uint32_t)treeId | ((uint32_t)ccInfo[p_CcNodeInfo->nextCcNodeInfo] << 16);
+            CreateNodeInfo(&p_FmPcdCcNextNode->ccTreeIdLst, myInfo);
+        }
+    }
+
+    ReleaseLst(&ccNextDifferentNodesLst);
+    p_FmPcdCcTree->treeId = treeId;
+    SetTreeHandler(p_FmPcdCc, treeId, p_FmPcdCcTree);
+
+    FmPcdIncNetEnvOwners(h_FmPcd, p_FmPcdCcTree->netEnvId);
+
+    err = UpdateNodesWithTree(h_FmPcd, &p_FmPcdCcTree->ccNextNodesLst, ccArray, treeId);
+    if(err)
+    {
+        ReleaseTree(p_FmPcdCc,treeId);
+        ReleaseTreeHandler(p_FmPcdCcTree,p_FmPcdCc);
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("No memory"));
+        return NULL;
+    }
+    return p_FmPcdCcTree;
+}
+
+t_Error FM_PCD_CcDeleteTree(t_Handle h_FmPcd, t_Handle h_CcTree)
+{
+    t_FmPcd                     *p_FmPcd = (t_FmPcd *)h_FmPcd;
+    t_FmPcdCcTree               *p_CcTree = (t_FmPcdCcTree *)h_CcTree;
+    uint32_t                    nodeIdTmp;
+    t_List                      *p_Pos;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdCc,E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(p_CcTree,E_INVALID_STATE);
+
+    FmPcdDecNetEnvOwners(h_FmPcd, p_CcTree->netEnvId);
+
+    if(GetTreeOwners(p_FmPcd, p_CcTree->treeId))
+        RETURN_ERROR(MAJOR, E_INVALID_SELECTION, ("the tree with this ID can not be removed because this tree is occupied, first - unbind this tree"));
+
+    LIST_FOR_EACH(p_Pos, &p_CcTree->ccNextNodesLst)
+    {
+        nodeIdTmp = ((t_CcNodeInfo *)CC_NEXT_NODE_F_OBJECT(p_Pos))->nextCcNodeInfo;
+        UpdateNodeOwner(p_FmPcd, (uint16_t)nodeIdTmp, FALSE);
+    }
+
+    ReleaseTree(p_FmPcd->p_FmPcdCc, p_CcTree->treeId);
+
+    return E_OK;
+}
+
+t_Handle FM_PCD_CcSetNode(t_Handle h_FmPcd, t_FmPcdCcNodeParams *p_CcNodeParam)
+{
+    t_FmPcd             *p_FmPcd = (t_FmPcd *) h_FmPcd;
+    t_FmPcdCcNode       *p_FmPcdCcNode, *p_FmPcdCcNextNode;
+    t_FmPcdCc           *p_FmPcdCc;
+    t_Error             err;
+    int                 tmp, size;
+    bool                glblMask = FALSE;
+    t_FmPcdCcKeyParams  *p_KeyParams;
+    t_Handle            p_KeysMatchTblTmp;
+    t_Handle            p_AdTableTmp;
+    bool                fullField = FALSE;
+    uint16_t            nodeId;
+    t_NextEngineParamsInfo nextEngineParamsInfo;
+    uint16_t            profileInfo[FM_PCD_PLCR_NUM_ENTRIES];
+    uint16_t            ccInfo[MAX_NUM_OF_PCD_CC_NODES];
+    uint8_t             ccDifferentInfo[MAX_NUM_OF_PCD_CC_NODES];
+    t_List              *p_Pos;
+    t_CcNodeInfo        *p_CcNodeInfo;
+    t_List              ccNextDifferentNodesLst;
+    uint32_t            myInfo;
+
+    SANITY_CHECK_RETURN_VALUE(h_FmPcd,E_INVALID_HANDLE,NULL);
+    SANITY_CHECK_RETURN_VALUE(p_FmPcd->p_FmPcdCc,E_INVALID_STATE,NULL);
+
+    memset(profileInfo, 0x00, FM_PCD_PLCR_NUM_ENTRIES*sizeof(uint16_t));
+    memset(ccInfo, 0x00, MAX_NUM_OF_PCD_CC_NODES*sizeof(uint16_t));
+    memset(ccDifferentInfo, 0x00, MAX_NUM_OF_PCD_CC_NODES*sizeof(uint8_t));
+
+    p_FmPcdCc = p_FmPcd->p_FmPcdCc;
+
+    if((p_CcNodeParam->keysParams.keySize > 4 )&& (p_CcNodeParam->keysParams.p_GlblMask))
+    {
+        REPORT_ERROR(MAJOR, E_INVALID_STATE, ("Global Mask is relevant only for keySize less or equal than 4"));
+        return NULL;
+    }
+
+    err = ValidateNextEngineParams(h_FmPcd, &p_CcNodeParam->keysParams.ccNextEngineParamsForMiss, &nextEngineParamsInfo);
+    if(err)
+    {
+        REPORT_ERROR(MAJOR, err, NO_MSG);
+        return NULL;
+    }
+
+    err = OccupyNodeId(p_FmPcd, &nodeId);
+    if(err)
+    {
+        REPORT_ERROR(MAJOR, err, NO_MSG);
+        return NULL;
+    }
+
+    p_FmPcdCcNode = (t_FmPcdCcNode*)XX_Malloc(sizeof(t_FmPcdCcNode));
+    if(!p_FmPcdCcNode)
+    {
+        ReleaseNode(p_FmPcdCc,nodeId);
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("No memory"));
+        return NULL;
+    }
+    memset(p_FmPcdCcNode, 0, sizeof(t_FmPcdCcNode));
+
+    INIT_LIST(&p_FmPcdCcNode->ccNextNodesLst);
+    INIT_LIST(&p_FmPcdCcNode->ccPrevNodesLst);
+    INIT_LIST(&p_FmPcdCcNode->ccTreeIdLst);
+    INIT_LIST(&p_FmPcdCcNode->ccTreesLst);
+
+    INIT_LIST(&ccNextDifferentNodesLst);
+
+    if(nextEngineParamsInfo.fmPcdEngine == e_FM_PCD_CC)
+    {
+        myInfo = (uint32_t)nextEngineParamsInfo.additionalInfo | (uint32_t)(p_CcNodeParam->keysParams.numOfKeys << 16);
+        CreateNodeInfo(&p_FmPcdCcNode->ccNextNodesLst, myInfo);
+        if(ccInfo[nextEngineParamsInfo.additionalInfo] == 0)
+            CreateNodeInfo(&ccNextDifferentNodesLst, (uint32_t)nextEngineParamsInfo.additionalInfo);
+        ccInfo[nextEngineParamsInfo.additionalInfo] +=1;
+    }
+
+    p_FmPcdCcNode->numOfKeys = p_CcNodeParam->keysParams.numOfKeys;
+
+    p_FmPcdCcNode->p_GlblMask = (t_Handle)XX_Malloc(p_CcNodeParam->keysParams.keySize * sizeof(uint8_t));
+    memset(p_FmPcdCcNode->p_GlblMask, 0, p_CcNodeParam->keysParams.keySize * sizeof(uint8_t));
+
+    if(p_CcNodeParam->keysParams.p_GlblMask)
+    {
+        memcpy((void*)p_FmPcdCcNode->p_GlblMask,p_CcNodeParam->keysParams.p_GlblMask,p_CcNodeParam->keysParams.keySize);
+        glblMask = TRUE;
+        p_FmPcdCcNode->glblMaskSize = (uint8_t)p_CcNodeParam->keysParams.keySize;
+    }
+    else
+     {   memset(p_FmPcdCcNode->p_GlblMask, 0xff, 4);
+         p_FmPcdCcNode->glblMaskSize = 4;
+     }
+
+    switch(p_CcNodeParam->extractCcParams.type)
+    {
+        case(e_FM_PCD_EXTRACT_BY_HDR):
+            switch(p_CcNodeParam->extractCcParams.extractParams.extractByHdr.type)
+            {
+                case(e_FM_PCD_EXTRACT_FULL_FIELD):
+                    p_FmPcdCcNode->parseCode = GetFullFieldParseCode(p_CcNodeParam->extractCcParams.extractParams.extractByHdr.hdr, p_CcNodeParam->extractCcParams.extractParams.extractByHdr.hdrIndex,
+                                                                    p_CcNodeParam->extractCcParams.extractParams.extractByHdr.extractByHdrType.fullField);
+                    GetSizeHeaderField(p_CcNodeParam->extractCcParams.extractParams.extractByHdr.hdr, p_CcNodeParam->extractCcParams.extractParams.extractByHdr.extractByHdrType.fullField, &p_FmPcdCcNode->sizeOfExtraction);
+                    fullField = TRUE;
+                    break;
+                    case(e_FM_PCD_EXTRACT_FROM_HDR):
+                        p_FmPcdCcNode->sizeOfExtraction = p_CcNodeParam->extractCcParams.extractParams.extractByHdr.extractByHdrType.fromHdr.size;
+                        p_FmPcdCcNode->offset =  p_CcNodeParam->extractCcParams.extractParams.extractByHdr.extractByHdrType.fromHdr.offset;
+                        p_FmPcdCcNode->parseCode = GetPrParseCode(p_CcNodeParam->extractCcParams.extractParams.extractByHdr.hdr, p_CcNodeParam->extractCcParams.extractParams.extractByHdr.hdrIndex,
+                                                                p_FmPcdCcNode->offset,glblMask, &p_FmPcdCcNode->prsArrayOffset);
+                        break;
+                case(e_FM_PCD_EXTRACT_FROM_FIELD):
+                        p_FmPcdCcNode->offset = p_CcNodeParam->extractCcParams.extractParams.extractByHdr.extractByHdrType.fromField.offset;
+                        p_FmPcdCcNode->sizeOfExtraction = p_CcNodeParam->extractCcParams.extractParams.extractByHdr.extractByHdrType.fromField.size;
+                        p_FmPcdCcNode->parseCode = GetFieldParseCode(p_CcNodeParam->extractCcParams.extractParams.extractByHdr.hdr, p_CcNodeParam->extractCcParams.extractParams.extractByHdr.extractByHdrType.fromField.field,
+                                                    p_FmPcdCcNode->offset,&p_FmPcdCcNode->prsArrayOffset,
+                                                    p_CcNodeParam->extractCcParams.extractParams.extractByHdr.hdrIndex);
+                        break;
+                default:
+                    ReleaseNode(p_FmPcdCc,nodeId);
+                    ReleaseNodeHandler(p_FmPcdCcNode,p_FmPcdCc);
+                    REPORT_ERROR(MAJOR, E_INVALID_SELECTION, NO_MSG);
+                    return NULL;
+            }
+            break;
+        case(e_FM_PCD_EXTRACT_NON_HDR):
+            /* get the field code for the generic extract */
+            p_FmPcdCcNode->sizeOfExtraction = p_CcNodeParam->extractCcParams.extractParams.extractNonHdr.size;
+            p_FmPcdCcNode->offset =  p_CcNodeParam->extractCcParams.extractParams.extractNonHdr.offset;
+            p_FmPcdCcNode->parseCode = GetGenParseCode(p_CcNodeParam->extractCcParams.extractParams.extractNonHdr.src, p_FmPcdCcNode->offset, glblMask, &p_FmPcdCcNode->prsArrayOffset);
+            break;
+
+       default:
+            ReleaseNode(p_FmPcdCc,nodeId);
+            ReleaseNodeHandler(p_FmPcdCcNode,p_FmPcdCc);
+            REPORT_ERROR(MAJOR, E_INVALID_SELECTION, NO_MSG);
+            return NULL;
+    }
+
+    if(p_FmPcdCcNode->parseCode == CC_PC_ILLEGAL)
+    {
+        ReleaseNode(p_FmPcdCc,nodeId);
+        ReleaseNodeHandler(p_FmPcdCcNode,p_FmPcdCc);
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("illeagl extraction type"));
+        return NULL;
+    }
+
+    if(((p_FmPcdCcNode->parseCode == CC_PC_FF_IPV4TTL) || (p_FmPcdCcNode->parseCode == CC_PC_FF_IPV6HOP_LIMIT)) && (p_FmPcdCcNode->numOfKeys != 1 ))
+    {
+        ReleaseNode(p_FmPcdCc,nodeId);
+        ReleaseNodeHandler(p_FmPcdCcNode,p_FmPcdCc);
+        REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("for IPV4TTL and IPV6_HOP_LIMIT has to be only 1 key - TTL = 1, otherwise it's Miss"));
+        return NULL;
+    }
+
+    if((p_FmPcdCcNode->sizeOfExtraction > MAX_SIZE_OF_KEY) || !p_FmPcdCcNode->sizeOfExtraction)
+    {
+        ReleaseNode(p_FmPcdCc,nodeId);
+        ReleaseNodeHandler(p_FmPcdCcNode,p_FmPcdCc);
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("sizeOfExatrction can not be greater than 56 and not 0"));
+        return NULL;
+    }
+
+    if(p_CcNodeParam->keysParams.keySize !=p_FmPcdCcNode->sizeOfExtraction)
+    {
+        ReleaseNode(p_FmPcdCc,nodeId);
+        ReleaseNodeHandler(p_FmPcdCcNode,p_FmPcdCc);
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("keySize has to be equal to sizeOfExtraction"));
+        return NULL;
+    }
+
+    GetCcExtractKeySize(p_FmPcdCcNode->sizeOfExtraction, &p_FmPcdCcNode->ccKeySizeAccExtraction);
+
+    for(tmp = 0 ; tmp < p_FmPcdCcNode->numOfKeys; tmp++)
+    {
+        p_KeyParams = &p_CcNodeParam->keysParams.keyParams[tmp];
+        if((p_FmPcdCcNode->parseCode != CC_PC_FF_IPV4TTL) && (p_FmPcdCcNode->parseCode != CC_PC_FF_IPV6HOP_LIMIT))
+        {
+            if(!p_KeyParams->p_Key)
+            {
+                ReleaseNode(p_FmPcdCc,nodeId);
+                ReleaseNodeHandler(p_FmPcdCcNode,p_FmPcdCc);
+                REPORT_ERROR(MAJOR, E_NO_MEMORY, ("numOfKeys is not match defined parameters - p_Key is not initialized"));
+                return NULL;
+            }
+
+            if(p_KeyParams->p_Mask && glblMask)
+            {
+                ReleaseNode(p_FmPcdCc,nodeId);
+                ReleaseNodeHandler(p_FmPcdCcNode,p_FmPcdCc);
+                REPORT_ERROR(MAJOR, E_NO_MEMORY, ("Can not be used globalMask and localMask"));
+                return NULL;
+            }
+        }
+        err = ValidateNextEngineParams(h_FmPcd, &p_KeyParams->ccNextEngineParams, &nextEngineParamsInfo);
+        if(err)
+        {
+            ReleaseNode(p_FmPcdCc,nodeId);
+            ReleaseNodeHandler(p_FmPcdCcNode,p_FmPcdCc);
+            REPORT_ERROR(MAJOR, err, (NO_MSG));
+            return NULL;
+        }
+        if(nextEngineParamsInfo.fmPcdEngine == e_FM_PCD_CC)
+        {
+            myInfo = (uint32_t)nextEngineParamsInfo.additionalInfo | (uint32_t)tmp << 16;
+            CreateNodeInfo(&p_FmPcdCcNode->ccNextNodesLst,myInfo);
+            if(ccInfo[nextEngineParamsInfo.additionalInfo] == 0)
+                CreateNodeInfo(&ccNextDifferentNodesLst, (uint32_t)nextEngineParamsInfo.additionalInfo);
+            ccInfo[nextEngineParamsInfo.additionalInfo] +=1;
+        }
+        if(p_KeyParams->p_Mask)
+            p_FmPcdCcNode->lclMask = TRUE;
+    }
+
+    if(p_FmPcdCcNode->lclMask)
+        size = 2 * p_FmPcdCcNode->ccKeySizeAccExtraction;
+    else
+        size = p_FmPcdCcNode->ccKeySizeAccExtraction;
+
+    if((p_FmPcdCcNode->parseCode != CC_PC_FF_IPV4TTL) && (p_FmPcdCcNode->parseCode != CC_PC_FF_IPV6HOP_LIMIT))
+    {
+        p_FmPcdCcNode->h_KeysMatchTable =(t_Handle)FM_MURAM_AllocMem(p_FmPcdCc->h_FmMuram,
+                                         (uint32_t)(size * sizeof(uint8_t) * (p_FmPcdCcNode->numOfKeys + 1)),
+                                         FM_PCD_CC_KEYS_MATCH_TABLE_ALIGN);
+        if(!p_FmPcdCcNode->h_KeysMatchTable)
+        {
+            ReleaseNode(p_FmPcdCc,nodeId);
+            ReleaseNodeHandler(p_FmPcdCcNode,p_FmPcdCc);
+            REPORT_ERROR(MAJOR, E_NO_MEMORY, ("No memory in MURAM for KEY MATCH table"));
+            return NULL;
+        }
+        WRITE_BLOCK((uint8_t *)p_FmPcdCcNode->h_KeysMatchTable, 0, size * sizeof(uint8_t) * (p_FmPcdCcNode->numOfKeys + 1));
+    }
+
+    p_FmPcdCcNode->h_AdTable = (t_Handle)FM_MURAM_AllocMem(p_FmPcdCc->h_FmMuram,
+                                     (uint32_t)( (p_FmPcdCcNode->numOfKeys+1) * FM_PCD_CC_AD_ENTRY_SIZE),
+                                     FM_PCD_CC_AD_TABLE_ALIGN);
+    if(!p_FmPcdCcNode->h_AdTable)
+    {
+        ReleaseNode(p_FmPcdCc,nodeId);
+        ReleaseNodeHandler(p_FmPcdCcNode,p_FmPcdCc);
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("No memory in MURAM ffor AD table "));
+        return NULL;
+    }
+    WRITE_BLOCK((uint8_t *)p_FmPcdCcNode->h_AdTable, 0, (uint32_t)((p_FmPcdCcNode->numOfKeys+1) * FM_PCD_CC_AD_ENTRY_SIZE));
+
+    p_KeysMatchTblTmp    = p_FmPcdCcNode->h_KeysMatchTable;
+    p_AdTableTmp         = p_FmPcdCcNode->h_AdTable;
+    for(tmp = 0 ; tmp < p_FmPcdCcNode->numOfKeys; tmp++)
+    {
+        p_KeyParams = &p_CcNodeParam->keysParams.keyParams[tmp];
+
+        if(p_KeysMatchTblTmp)
+        {
+
+            COPY_BLOCK((void*)p_KeysMatchTblTmp, p_KeyParams->p_Key, p_FmPcdCcNode->sizeOfExtraction);
+
+            if(p_FmPcdCcNode->lclMask && p_KeyParams->p_Mask)
+                COPY_BLOCK((void*)(((uint32_t)p_KeysMatchTblTmp) + p_FmPcdCcNode->ccKeySizeAccExtraction), p_KeyParams->p_Mask, p_FmPcdCcNode->sizeOfExtraction);
+            else if(p_FmPcdCcNode->lclMask)
+                WRITE_BLOCK((void*)(((uint32_t)p_KeysMatchTblTmp) + p_FmPcdCcNode->ccKeySizeAccExtraction),0xff, p_FmPcdCcNode->sizeOfExtraction);
+            p_KeysMatchTblTmp = (t_Handle)(((uint32_t)p_KeysMatchTblTmp) + size * sizeof(uint8_t));
+        }
+        NextStepAd(p_AdTableTmp,&p_KeyParams->ccNextEngineParams, p_FmPcd);
+
+        p_AdTableTmp =   (t_Handle)(((uint32_t)p_AdTableTmp) + FM_PCD_CC_AD_ENTRY_SIZE);
+
+    }
+    NextStepAd(p_AdTableTmp,&p_CcNodeParam->keysParams.ccNextEngineParamsForMiss, p_FmPcd);
+
+    if(fullField == TRUE)
+        p_FmPcdCcNode->sizeOfExtraction = 0;
+
+
+    if(!LIST_IsEmpty(&ccNextDifferentNodesLst))
+    {
+        LIST_FOR_EACH(p_Pos, &ccNextDifferentNodesLst)
+        {
+            p_CcNodeInfo = CC_NEXT_NODE_F_OBJECT(p_Pos);
+            p_FmPcdCcNextNode = (t_FmPcdCcNode *)GetNodeHandler(p_FmPcd, (uint16_t)p_CcNodeInfo->nextCcNodeInfo);
+            if(!p_FmPcdCcNextNode)
+            {
+                ReleaseNode(p_FmPcdCc,nodeId);
+                REPORT_ERROR(MAJOR, E_NO_MEMORY, ("No memory"));
+                return NULL;
+            }
+            myInfo = (uint32_t)nodeId | ((uint32_t)ccInfo[(uint16_t)p_CcNodeInfo->nextCcNodeInfo] << 16);
+            CreateNodeInfo(&p_FmPcdCcNextNode->ccPrevNodesLst, myInfo);
+        }
+    }
+    ReleaseLst(&ccNextDifferentNodesLst);
+    p_FmPcdCcNode->nodeId = nodeId;
+    SetNodeHandler(p_FmPcdCc, nodeId, p_FmPcdCcNode);
+    return p_FmPcdCcNode;
+}
+
+t_Error FM_PCD_CcDeleteNode(t_Handle h_FmPcd, t_Handle h_CcNode)
+{
+    t_FmPcd                     *p_FmPcd = (t_FmPcd *)h_FmPcd;
+    t_FmPcdCcNode               *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
+    uint32_t                    nodeIdTmp;
+    t_List                      *p_Pos;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdCc,E_INVALID_STATE);
+
+    if(!p_CcNode)
+        RETURN_ERROR(MAJOR, E_INVALID_SELECTION, ("the node with this ID is not initialized"));
+
+    if(GetNodeOwners(p_FmPcd, p_CcNode->nodeId))
+        RETURN_ERROR(MAJOR, E_INVALID_SELECTION, ("the node with this ID can not be removed because this node is occupied, first - unbind this node"));
+
+    LIST_FOR_EACH(p_Pos, &p_CcNode->ccNextNodesLst)
+    {
+        nodeIdTmp = ((t_CcNodeInfo *)CC_NEXT_NODE_F_OBJECT(p_Pos))->nextCcNodeInfo;
+        UpdateNodeOwner(p_FmPcd, (uint16_t)nodeIdTmp, FALSE);
+
+    }
+
+    ReleaseNode(p_FmPcd->p_FmPcdCc, p_CcNode->nodeId);
+    return E_OK;
+}
+
+t_Error FM_PCD_CcTreeModifyNextEngine(t_Handle h_FmPcd, t_Handle h_CcTree, uint8_t grpId, uint8_t index, t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams)
+{
+    t_FmPcd                         *p_FmPcd = (t_FmPcd *)h_FmPcd;
+
+    SANITY_CHECK_RETURN_ERROR(h_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdCc, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->h_Hc, E_INVALID_HANDLE);
+
+    return FmHcPcdCcModifyTreeNextEngine(p_FmPcd->h_Hc, h_CcTree, grpId, index, p_FmPcdCcNextEngineParams);
+}
+
+t_Error FM_PCD_CcNodeModifyNextEngine(t_Handle h_FmPcd, t_Handle h_CcNode, uint8_t keyIndex, t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams)
+{
+    t_FmPcd                         *p_FmPcd = (t_FmPcd *)h_FmPcd;
+
+    SANITY_CHECK_RETURN_ERROR(h_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdCc, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->h_Hc, E_INVALID_HANDLE);
+
+    return FmHcPcdCcModifyNodeNextEngine(p_FmPcd->h_Hc, h_CcNode, keyIndex, p_FmPcdCcNextEngineParams);
+}
+
+t_Error FM_PCD_CcNodeModifyMissNextEngine(t_Handle h_FmPcd, t_Handle h_CcNode, t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams)
+{
+    t_FmPcd                         *p_FmPcd = (t_FmPcd *)h_FmPcd;
+
+    SANITY_CHECK_RETURN_ERROR(h_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdCc, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->h_Hc, E_INVALID_HANDLE);
+
+    return FmHcPcdCcModifyNodeMissNextEngine(p_FmPcd->h_Hc, h_CcNode, p_FmPcdCcNextEngineParams);
+}
+
+t_Error FM_PCD_CcNodeRemoveKey(t_Handle h_FmPcd, t_Handle h_CcNode, uint8_t keyIndex)
+{
+    t_FmPcd                         *p_FmPcd = (t_FmPcd *)h_FmPcd;
+
+    SANITY_CHECK_RETURN_ERROR(h_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdCc, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->h_Hc, E_INVALID_HANDLE);
+
+    return FmHcPcdCcRemoveKey(p_FmPcd->h_Hc, h_CcNode, keyIndex);
+}
+
+t_Error FM_PCD_CcNodeAddKey(t_Handle h_FmPcd, t_Handle h_CcNode, uint8_t keyIndex, uint8_t keySize, t_FmPcdCcKeyParams  *p_KeyParams)
+{
+    t_FmPcd                         *p_FmPcd = (t_FmPcd *)h_FmPcd;
+
+    SANITY_CHECK_RETURN_ERROR(h_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdCc, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->h_Hc, E_INVALID_HANDLE);
+
+    return FmHcPcdCcAddKey(p_FmPcd->h_Hc, h_CcNode, keyIndex, keySize, p_KeyParams);
+}
+
+t_Error FM_PCD_CcNodeModifyKeyAndNextEngine(t_Handle h_FmPcd, t_Handle h_CcNode, uint8_t keyIndex, uint8_t keySize, t_FmPcdCcKeyParams  *p_KeyParams)
+{
+    t_FmPcd                         *p_FmPcd = (t_FmPcd *)h_FmPcd;
+
+    SANITY_CHECK_RETURN_ERROR(h_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdCc, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->h_Hc, E_INVALID_HANDLE);
+
+    return FmHcPcdCcModifyKeyAndNextEngine(p_FmPcd->h_Hc, h_CcNode, keyIndex, keySize, p_KeyParams);
+}
+
+t_Error FM_PCD_CcNodeModifyKey(t_Handle h_FmPcd, t_Handle h_CcNode, uint8_t keyIndex, uint8_t keySize, uint8_t  *p_Key, uint8_t *p_Mask)
+{
+    t_FmPcd                         *p_FmPcd = (t_FmPcd *)h_FmPcd;
+
+    SANITY_CHECK_RETURN_ERROR(h_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdCc, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->h_Hc, E_INVALID_HANDLE);
+
+    return FmHcPcdCcModifyKey(p_FmPcd->h_Hc, h_CcNode, keyIndex, keySize, p_Key, p_Mask);
+}
+
+void FmPcdCcNodeTreeReleaseLock(t_Handle h_FmPcd, t_List *p_List)
+{
+    t_List          *p_Pos;
+    t_CcNodeInfo    *p_CcNodeInfo;
+    t_Handle        h_FmPcdCcTree;
+
+    LIST_FOR_EACH(p_Pos, p_List)
+    {
+        p_CcNodeInfo = CC_NEXT_NODE_F_OBJECT(p_Pos);
+        h_FmPcdCcTree = FmPcdCcGetTreeHandler(h_FmPcd, (uint8_t)p_CcNodeInfo->nextCcNodeInfo);
+        FmPcdCcTreeReleaseLock(h_FmPcdCcTree);
+    }
+}
+
+t_Error FmPcdCcNodeTreeTryLock(t_Handle h_FmPcd,t_Handle h_FmPcdCcNode, t_List *p_List)
+{
+    t_FmPcdCcNode   *p_FmPcdCcNode = (t_FmPcdCcNode *)h_FmPcdCcNode;
+    t_List          *p_Pos;
+    t_CcNodeInfo    *p_CcNodeInfo;
+    t_Handle        h_FmPcdCcTree;
+    t_Error         err;
+
+    if(LIST_IsEmpty(&p_FmPcdCcNode->ccTreesLst))
+        RETURN_ERROR(MAJOR, E_NOT_AVAILABLE, ("asked for more nodes in CC than MAX"))  ;
+    LIST_FOR_EACH(p_Pos, &p_FmPcdCcNode->ccTreesLst)
+    {
+        p_CcNodeInfo = CC_NEXT_NODE_F_OBJECT(p_Pos);
+        h_FmPcdCcTree = FmPcdCcGetTreeHandler(h_FmPcd, (uint8_t)p_CcNodeInfo->nextCcNodeInfo);
+        err = FmPcdCcTreeTryLock(h_FmPcdCcTree);
+        if(err == E_OK)
+            CreateNodeInfo(p_List, (uint8_t)p_CcNodeInfo->nextCcNodeInfo);
+        else
+        {
+            FmPcdCcNodeTreeReleaseLock(h_FmPcd, p_List);
+            ReleaseLst(p_List);
+
+        }
+    }
+
+    return err;
+}
+
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_kg.c b/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_kg.c
new file mode 100644
index 0000000..6e96b9f
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_kg.c
@@ -0,0 +1,2834 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/******************************************************************************
+ @File          fm_kg.c
+
+ @Description   FM PCD ...
+*//***************************************************************************/
+#include "std_ext.h"
+#include "error_ext.h"
+#include "string_ext.h"
+#include "debug_ext.h"
+#include "net_ext.h"
+#include "fm_pcd.h"
+#include "fm_port_ext.h"
+#include "fm_hc.h"
+
+
+static e_FmPcdKgExtractDfltSelect GetGenericSwDefault(t_FmPcdKgExtractDflt swDefaults[], uint8_t numOfSwDefaults, uint8_t code)
+{
+    int i;
+
+    switch(code)
+    {
+        case( KG_SCH_GEN_PARSE_RESULT):
+        case( KG_SCH_GEN_DEFAULT):
+        case( KG_SCH_GEN_NEXTHDR):
+            for(i=0 ; i<numOfSwDefaults ; i++)
+                if(swDefaults[i].type == e_FM_PCD_KG_GENERIC_NOT_FROM_DATA)
+                    return swDefaults[i].dfltSelect;
+            ASSERT_COND(FALSE);
+        case( KG_SCH_GEN_SHIM1):
+        case( KG_SCH_GEN_SHIM2):
+        case( KG_SCH_GEN_SHIM3):
+        case( KG_SCH_GEN_ETH_NO_V):
+        case( KG_SCH_GEN_SNAP_NO_V):
+        case( KG_SCH_GEN_VLAN1_NO_V):
+        case( KG_SCH_GEN_VLAN2_NO_V):
+        case( KG_SCH_GEN_ETH_TYPE_NO_V):
+        case( KG_SCH_GEN_PPP_NO_V):
+        case( KG_SCH_GEN_MPLS1_NO_V):
+        case( KG_SCH_GEN_MPLS_LAST_NO_V):
+        case( KG_SCH_GEN_L3_NO_V):
+        case( KG_SCH_GEN_IP2_NO_V):
+        case( KG_SCH_GEN_GRE_NO_V):
+        case( KG_SCH_GEN_L4_NO_V):
+            for(i=0 ; i<numOfSwDefaults ; i++)
+                if(swDefaults[i].type == e_FM_PCD_KG_GENERIC_FROM_DATA_NO_V)
+                    return swDefaults[i].dfltSelect;
+
+        case( KG_SCH_GEN_START_OF_FRM):
+        case( KG_SCH_GEN_ETH):
+        case( KG_SCH_GEN_SNAP):
+        case( KG_SCH_GEN_VLAN1):
+        case( KG_SCH_GEN_VLAN2):
+        case( KG_SCH_GEN_ETH_TYPE):
+        case( KG_SCH_GEN_PPP):
+        case( KG_SCH_GEN_MPLS1):
+        case( KG_SCH_GEN_MPLS2):
+        case( KG_SCH_GEN_MPLS3):
+        case( KG_SCH_GEN_MPLS_LAST):
+        case( KG_SCH_GEN_IPV4):
+        case( KG_SCH_GEN_IPV6):
+        case( KG_SCH_GEN_IPV4_TUNNELED):
+        case( KG_SCH_GEN_IPV6_TUNNELED):
+        case( KG_SCH_GEN_MIN_ENCAP):
+        case( KG_SCH_GEN_GRE):
+        case( KG_SCH_GEN_TCP):
+        case( KG_SCH_GEN_UDP):
+        case( KG_SCH_GEN_IPSEC_AH):
+        case( KG_SCH_GEN_SCTP):
+        case( KG_SCH_GEN_DCCP):
+        case( KG_SCH_GEN_IPSEC_ESP):
+            for(i=0 ; i<numOfSwDefaults ; i++)
+                if(swDefaults[i].type == e_FM_PCD_KG_GENERIC_FROM_DATA)
+                    return swDefaults[i].dfltSelect;
+            ASSERT_COND(FALSE);
+        default:
+            return e_FM_PCD_KG_DFLT_ILLEGAL;
+    }
+}
+
+static uint8_t GetGenCode(e_FmPcdExtractFrom src)
+{
+    switch(src)
+    {
+        case(e_FM_PCD_EXTRACT_FROM_FRAME_START):
+            return KG_SCH_GEN_START_OF_FRM;
+        case(e_FM_PCD_KG_EXTRACT_FROM_DFLT_VALUE):
+            return KG_SCH_GEN_DEFAULT;
+        case(e_FM_PCD_KG_EXTRACT_FROM_PARSE_RESULT):
+            return KG_SCH_GEN_PARSE_RESULT;
+        case(e_FM_PCD_KG_EXTRACT_FROM_CURR_END_OF_PARSE):
+            return KG_SCH_GEN_NEXTHDR;
+        default:
+            REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("Illegal 'extract from' src"));
+            return 0;
+    }
+}
+
+static uint8_t GetGenHdrCode(e_NetHeaderType hdr, e_FmPcdHdrIndex hdrIndex, bool ignoreProtocolValidation)
+{
+    if(!ignoreProtocolValidation)
+        switch(hdr)
+        {
+            case(HEADER_TYPE_NONE):
+                ASSERT_COND(FALSE);
+            case(HEADER_TYPE_ETH):
+                return KG_SCH_GEN_ETH;
+            case(HEADER_TYPE_LLC_SNAP):
+                return KG_SCH_GEN_SNAP;
+            case(HEADER_TYPE_PPPoE):
+                return KG_SCH_GEN_PPP;
+            case(HEADER_TYPE_MPLS):
+                if((hdrIndex == e_FM_PCD_HDR_INDEX_NONE) || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
+                    return KG_SCH_GEN_MPLS1;
+                if(hdrIndex == e_FM_PCD_HDR_INDEX_2)
+                    return KG_SCH_GEN_MPLS2;
+                if(hdrIndex == e_FM_PCD_HDR_INDEX_3)
+                    return KG_SCH_GEN_MPLS3;
+                if(hdrIndex == e_FM_PCD_HDR_INDEX_LAST)
+                    return KG_SCH_GEN_MPLS_LAST;
+                REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal MPLS header index"));
+                return 0;
+            case(HEADER_TYPE_IPv4):
+                if((hdrIndex == e_FM_PCD_HDR_INDEX_NONE) || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
+                    return KG_SCH_GEN_IPV4;
+                if(hdrIndex == e_FM_PCD_HDR_INDEX_2)
+                    return KG_SCH_GEN_IPV4_TUNNELED;
+                REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IPv4 header index"));
+                return 0;
+            case(HEADER_TYPE_IPv6):
+                if((hdrIndex == e_FM_PCD_HDR_INDEX_NONE) || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
+                    return KG_SCH_GEN_IPV6;
+                if(hdrIndex == e_FM_PCD_HDR_INDEX_2)
+                    return KG_SCH_GEN_IPV6_TUNNELED;
+                REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IPv6 header index"));
+                return 0;
+            case(HEADER_TYPE_GRE):
+                return KG_SCH_GEN_GRE;
+            case(HEADER_TYPE_TCP):
+                return KG_SCH_GEN_TCP;
+            case(HEADER_TYPE_UDP):
+                return KG_SCH_GEN_UDP;
+            case(HEADER_TYPE_IPSEC_AH):
+                return KG_SCH_GEN_IPSEC_AH;
+            case(HEADER_TYPE_IPSEC_ESP):
+                return KG_SCH_GEN_IPSEC_ESP;
+            case(HEADER_TYPE_SCTP):
+                return KG_SCH_GEN_SCTP;
+            case(HEADER_TYPE_DCCP):
+                return KG_SCH_GEN_DCCP;
+            default:
+                REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+                return 0;
+        }
+    else
+        switch(hdr)
+        {
+            case(HEADER_TYPE_NONE):
+                ASSERT_COND(FALSE);
+            case(HEADER_TYPE_ETH):
+                return KG_SCH_GEN_ETH_NO_V;
+            case(HEADER_TYPE_LLC_SNAP):
+                return KG_SCH_GEN_SNAP_NO_V;
+            case(HEADER_TYPE_PPPoE):
+                return KG_SCH_GEN_PPP_NO_V;
+            case(HEADER_TYPE_MPLS):
+                 if((hdrIndex == e_FM_PCD_HDR_INDEX_NONE) || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
+                    return KG_SCH_GEN_MPLS1_NO_V;
+                if(hdrIndex == e_FM_PCD_HDR_INDEX_LAST)
+                    return KG_SCH_GEN_MPLS_LAST_NO_V;
+                if((hdrIndex == e_FM_PCD_HDR_INDEX_2) || (hdrIndex == e_FM_PCD_HDR_INDEX_3) )
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Indexed MPLS Extraction not supported"));
+                else
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal MPLS header index"));
+                return 0;
+            case(HEADER_TYPE_IPv4):
+            case(HEADER_TYPE_IPv6):
+              if((hdrIndex == e_FM_PCD_HDR_INDEX_NONE) || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
+                    return KG_SCH_GEN_L3_NO_V;
+                if(hdrIndex == e_FM_PCD_HDR_INDEX_2)
+                    return KG_SCH_GEN_IP2_NO_V;
+                REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IP header index"));
+            case(HEADER_TYPE_MINENCAP):
+                return KG_SCH_GEN_IP2_NO_V;
+            case(HEADER_TYPE_USER_DEFINED_L3):
+                return KG_SCH_GEN_L3_NO_V;
+            case(HEADER_TYPE_GRE):
+                return KG_SCH_GEN_GRE_NO_V;
+            case(HEADER_TYPE_TCP):
+            case(HEADER_TYPE_UDP):
+            case(HEADER_TYPE_IPSEC_AH):
+            case(HEADER_TYPE_IPSEC_ESP):
+            case(HEADER_TYPE_SCTP):
+            case(HEADER_TYPE_DCCP):
+                return KG_SCH_GEN_L4_NO_V;
+            case(HEADER_TYPE_USER_DEFINED_SHIM1):
+                return KG_SCH_GEN_SHIM1;
+            case(HEADER_TYPE_USER_DEFINED_SHIM2):
+                return KG_SCH_GEN_SHIM2;
+            case(HEADER_TYPE_USER_DEFINED_SHIM3):
+                return KG_SCH_GEN_SHIM3;
+            default:
+                REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+                return 0;
+        }
+}
+
+static t_GenericCodes GetGenFieldCode(e_NetHeaderType hdr, t_FmPcdFields field, bool ignoreProtocolValidation, e_FmPcdHdrIndex hdrIndex)
+{
+    if(!ignoreProtocolValidation)
+        switch(hdr)
+        {
+            case(HEADER_TYPE_NONE):
+                ASSERT_COND(FALSE);
+            case(HEADER_TYPE_ETH):
+                switch(field.eth)
+                {
+                    case(NET_HEADER_FIELD_ETH_TYPE):
+                        return KG_SCH_GEN_ETH_TYPE;
+                    default:
+                        REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+                        return 0;
+                }
+                break;
+            case(HEADER_TYPE_VLAN):
+                switch(field.vlan)
+                {
+                case(NET_HEADER_FIELD_VLAN_TCI) :
+                    if((hdrIndex == e_FM_PCD_HDR_INDEX_NONE) || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
+                        return KG_SCH_GEN_VLAN1;
+                    if(hdrIndex == e_FM_PCD_HDR_INDEX_LAST)
+                        return KG_SCH_GEN_VLAN2;
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal VLAN header index"));
+                        return 0;
+                }
+                break;
+            case(HEADER_TYPE_MPLS):
+            case(HEADER_TYPE_IPSEC_AH):
+            case(HEADER_TYPE_IPSEC_ESP):
+            case(HEADER_TYPE_LLC_SNAP):
+            case(HEADER_TYPE_PPPoE):
+            case(HEADER_TYPE_IPv4):
+            case(HEADER_TYPE_IPv6):
+            case(HEADER_TYPE_GRE):
+            case(HEADER_TYPE_MINENCAP):
+            case(HEADER_TYPE_USER_DEFINED_L3):
+            case(HEADER_TYPE_TCP):
+            case(HEADER_TYPE_UDP):
+            case(HEADER_TYPE_SCTP):
+            case(HEADER_TYPE_DCCP):
+            case(HEADER_TYPE_USER_DEFINED_L4):
+                REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+            default:
+                REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Header not supported"));
+                return 0;
+        }
+        else
+            switch(hdr)
+            {
+                case(HEADER_TYPE_NONE):
+                    ASSERT_COND(FALSE);
+                case(HEADER_TYPE_ETH):
+                switch(field.eth)
+                {
+                    case(NET_HEADER_FIELD_ETH_TYPE):
+                        return KG_SCH_GEN_ETH_TYPE_NO_V;
+                    default:
+                        REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+                        return 0;
+                }
+                break;
+                case(HEADER_TYPE_VLAN):
+                    switch(field.vlan)
+                    {
+                    case(NET_HEADER_FIELD_VLAN_TCI) :
+                        if((hdrIndex == e_FM_PCD_HDR_INDEX_NONE) || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
+                            return KG_SCH_GEN_VLAN1_NO_V;
+                        if(hdrIndex == e_FM_PCD_HDR_INDEX_LAST)
+                            return KG_SCH_GEN_VLAN2_NO_V;
+                        REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal VLAN header index"));
+                        return 0;
+                    }
+                    break;
+                case(HEADER_TYPE_MPLS):
+                case(HEADER_TYPE_LLC_SNAP):
+                case(HEADER_TYPE_PPPoE):
+                case(HEADER_TYPE_IPv4):
+                case(HEADER_TYPE_IPv6):
+                case(HEADER_TYPE_GRE):
+                case(HEADER_TYPE_MINENCAP):
+                case(HEADER_TYPE_USER_DEFINED_L3):
+                case(HEADER_TYPE_TCP):
+                case(HEADER_TYPE_UDP):
+                case(HEADER_TYPE_IPSEC_AH):
+                case(HEADER_TYPE_IPSEC_ESP):
+                case(HEADER_TYPE_SCTP):
+                case(HEADER_TYPE_DCCP):
+                case(HEADER_TYPE_USER_DEFINED_L4):
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+                    return 0;
+                default:
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Header not supported"));
+                    return 0;
+            }
+    return 0;
+}
+
+static t_KnownFieldsMasks GetKnownProtMask(e_NetHeaderType hdr, e_FmPcdHdrIndex index, t_FmPcdFields field)
+{
+    switch(hdr)
+    {
+        case(HEADER_TYPE_NONE):
+            ASSERT_COND(FALSE);
+        case(HEADER_TYPE_ETH):
+            switch(field.eth)
+            {
+                case(NET_HEADER_FIELD_ETH_DA):
+                    return KG_SCH_KN_MACDST;
+                case(NET_HEADER_FIELD_ETH_SA):
+                    return KG_SCH_KN_MACSRC;
+                case(NET_HEADER_FIELD_ETH_TYPE):
+                    return KG_SCH_KN_ETYPE;
+                default:
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+                    return 0;
+           }
+        case(HEADER_TYPE_LLC_SNAP):
+            switch(field.llcSnap)
+            {
+                case(NET_HEADER_FIELD_LLC_SNAP_TYPE):
+                    return KG_SCH_KN_ETYPE;
+                default:
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+                    return 0;
+           }
+        case(HEADER_TYPE_VLAN):
+            switch(field.vlan)
+            {
+                case(NET_HEADER_FIELD_VLAN_TCI):
+                    if((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
+                        return KG_SCH_KN_TCI1;
+                    if(index == e_FM_PCD_HDR_INDEX_LAST)
+                        return KG_SCH_KN_TCI2;
+                    else
+                    {
+                        REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+                        return 0;
+                    }
+                default:
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+                    return 0;
+            }
+            break;
+        case(HEADER_TYPE_MPLS):
+            switch(field.mpls)
+            {
+                case(NET_HEADER_FIELD_MPLS_LABEL_STACK):
+                    if((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
+                        return KG_SCH_KN_MPLS1;
+                    if(index == e_FM_PCD_HDR_INDEX_2)
+                        return KG_SCH_KN_MPLS2;
+                    if(index == e_FM_PCD_HDR_INDEX_LAST)
+                        return KG_SCH_KN_MPLS_LAST;
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal MPLS index"));
+                    return 0;
+                default:
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+                    return 0;
+            }
+            break;
+        case(HEADER_TYPE_IPv4):
+            switch(field.ipv4)
+            {
+                case(NET_HEADER_FIELD_IPv4_SRC_IP):
+                    if((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
+                        return KG_SCH_KN_IPSRC1;
+                    if(index == e_FM_PCD_HDR_INDEX_2)
+                        return KG_SCH_KN_IPSRC2;
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IPv4 index"));
+                    return 0;
+                case(NET_HEADER_FIELD_IPv4_DST_IP):
+                    if((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
+                        return KG_SCH_KN_IPDST1;
+                    if(index == e_FM_PCD_HDR_INDEX_2)
+                        return KG_SCH_KN_IPDST2;
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IPv4 index"));
+                    return 0;
+                case(NET_HEADER_FIELD_IPv4_PROTO):
+                    if((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
+                        return KG_SCH_KN_PTYPE1;
+                    if(index == e_FM_PCD_HDR_INDEX_2)
+                        return KG_SCH_KN_PTYPE2;
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IPv4 index"));
+                    return 0;
+                case(NET_HEADER_FIELD_IPv4_TOS):
+                    if((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
+                        return KG_SCH_KN_IPTOS_TC1;
+                    if(index == e_FM_PCD_HDR_INDEX_2)
+                        return KG_SCH_KN_IPTOS_TC2;
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IPv4 index"));
+                    return 0;
+                default:
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+                    return 0;
+            }
+            break;
+        case(HEADER_TYPE_IPv6):
+             switch(field.ipv6)
+            {
+                case(NET_HEADER_FIELD_IPv6_SRC_IP):
+                    if((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
+                        return KG_SCH_KN_IPSRC1;
+                    if(index == e_FM_PCD_HDR_INDEX_2)
+                        return KG_SCH_KN_IPSRC2;
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IPv6 index"));
+                    return 0;
+                case(NET_HEADER_FIELD_IPv6_DST_IP):
+                    if((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
+                        return KG_SCH_KN_IPDST1;
+                    if(index == e_FM_PCD_HDR_INDEX_2)
+                        return KG_SCH_KN_IPDST2;
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IPv6 index"));
+                    return 0;
+                case(NET_HEADER_FIELD_IPv6_NEXT_HDR):
+                    if((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
+                        return KG_SCH_KN_PTYPE1;
+                    if(index == e_FM_PCD_HDR_INDEX_2)
+                        return KG_SCH_KN_PTYPE2;
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IPv6 index"));
+                    return 0;
+                case(NET_HEADER_FIELD_IPv6_VER | NET_HEADER_FIELD_IPv6_FL | NET_HEADER_FIELD_IPv6_TC):
+                    if((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
+                        return (KG_SCH_KN_IPV6FL1 | KG_SCH_KN_IPTOS_TC1);
+                    if(index == e_FM_PCD_HDR_INDEX_2)
+                        return (KG_SCH_KN_IPV6FL2 | KG_SCH_KN_IPTOS_TC2);
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IPv6 index"));
+                    return 0;
+                default:
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+                    return 0;
+            }
+            break;
+        case(HEADER_TYPE_GRE):
+            switch(field.gre)
+            {
+                case(NET_HEADER_FIELD_GRE_TYPE):
+                    return KG_SCH_KN_GREPTYPE;
+                default:
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+                    return 0;
+           }
+        case(HEADER_TYPE_MINENCAP):
+            switch(field.minencap)
+            {
+                case(NET_HEADER_FIELD_MINENCAP_SRC_IP):
+                    return KG_SCH_KN_IPSRC2;
+                case(NET_HEADER_FIELD_MINENCAP_DST_IP):
+                    return KG_SCH_KN_IPDST2;
+                case(NET_HEADER_FIELD_MINENCAP_TYPE):
+                    return KG_SCH_KN_PTYPE2;
+                default:
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+                    return 0;
+           }
+           break;
+        case(HEADER_TYPE_TCP):
+            switch(field.tcp)
+            {
+                case(NET_HEADER_FIELD_TCP_PORT_SRC):
+                    return KG_SCH_KN_L4PSRC;
+                case(NET_HEADER_FIELD_TCP_PORT_DST):
+                    return KG_SCH_KN_L4PDST;
+                case(NET_HEADER_FIELD_TCP_FLAGS):
+                    return KG_SCH_KN_TFLG;
+                default:
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+                    return 0;
+            }
+            break;
+        case(HEADER_TYPE_UDP):
+            switch(field.udp)
+            {
+                case(NET_HEADER_FIELD_UDP_PORT_SRC):
+                    return KG_SCH_KN_L4PSRC;
+                case(NET_HEADER_FIELD_UDP_PORT_DST):
+                    return KG_SCH_KN_L4PDST;
+                default:
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+                    return 0;
+            }
+            break;
+        case(HEADER_TYPE_IPSEC_AH):
+            switch(field.ipsecAh)
+            {
+                case(NET_HEADER_FIELD_IPSEC_AH_SPI):
+                    return KG_SCH_KN_IPSEC_SPI;
+                case(NET_HEADER_FIELD_IPSEC_AH_NH):
+                    return KG_SCH_KN_IPSEC_NH;
+                default:
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+                    return 0;
+            }
+            break;
+        case(HEADER_TYPE_IPSEC_ESP):
+            switch(field.ipsecEsp)
+            {
+                case(NET_HEADER_FIELD_IPSEC_ESP_SPI):
+                    return KG_SCH_KN_IPSEC_SPI;
+                default:
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+                    return 0;
+            }
+            break;
+        case(HEADER_TYPE_SCTP):
+            switch(field.sctp)
+            {
+                case(NET_HEADER_FIELD_SCTP_PORT_SRC):
+                    return KG_SCH_KN_L4PSRC;
+                case(NET_HEADER_FIELD_SCTP_PORT_DST):
+                    return KG_SCH_KN_L4PDST;
+                default:
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+                    return 0;
+            }
+            break;
+        case(HEADER_TYPE_DCCP):
+            switch(field.dccp)
+            {
+                case(NET_HEADER_FIELD_DCCP_PORT_SRC):
+                    return KG_SCH_KN_L4PSRC;
+                case(NET_HEADER_FIELD_DCCP_PORT_DST):
+                    return KG_SCH_KN_L4PDST;
+                default:
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+                    return 0;
+            }
+            break;
+        case(HEADER_TYPE_PPPoE):
+            switch(field.pppoe)
+            {
+                case(NET_HEADER_FIELD_PPPoE_PID):
+                    return KG_SCH_KN_PPPID;
+                case(NET_HEADER_FIELD_PPPoE_SID):
+                    return KG_SCH_KN_PPPSID;
+                default:
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+                    return 0;
+            }
+            break;
+        default:
+            REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+            return 0;
+    }
+}
+
+static uint8_t GetFieldSize(e_NetHeaderType hdr, t_FmPcdFields field)
+{
+    UNUSED(field);
+
+    switch(hdr)
+    {
+        case(HEADER_TYPE_NONE):
+            ASSERT_COND(FALSE);
+        case(HEADER_TYPE_ETH):
+        case(HEADER_TYPE_LLC_SNAP):
+        case(HEADER_TYPE_VLAN):
+        case(HEADER_TYPE_PPPoE):
+        case(HEADER_TYPE_MPLS):
+        case(HEADER_TYPE_IPv4):
+        case(HEADER_TYPE_IPv6):
+        case(HEADER_TYPE_GRE):
+        case(HEADER_TYPE_MINENCAP):
+        case(HEADER_TYPE_USER_DEFINED_L3):
+        case(HEADER_TYPE_TCP):
+        case(HEADER_TYPE_UDP):
+        case(HEADER_TYPE_IPSEC_AH):
+        case(HEADER_TYPE_IPSEC_ESP):
+        case(HEADER_TYPE_SCTP):
+        case(HEADER_TYPE_DCCP):
+        case(HEADER_TYPE_USER_DEFINED_L4):
+        default:
+            REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+            return 0;
+    }
+}
+
+static uint8_t GetKnownFieldId(uint32_t bitMask)
+{
+    uint8_t cnt = 0;
+
+    while (bitMask)
+        if(bitMask & 0x80000000)
+            break;
+        else
+        {
+            cnt++;
+            bitMask <<= 1;
+        }
+    return cnt;
+
+}
+
+static t_Error AllocClsPlanGrpBlocks(t_FmPcd *p_FmPcd, uint16_t sizeOfGrp, uint8_t *p_BaseEntry)
+{
+    uint8_t     numOfBlocks, blocksFound=0, first=0;
+    uint8_t     i, j;
+
+    numOfBlocks =  (uint8_t)(sizeOfGrp/CLS_PLAN_NUM_PER_GRP);
+
+    TRY_LOCK_RET_ERR(p_FmPcd->lock);
+
+    /* try to find consequent blocks */
+    first = 0;
+    for(i=p_FmPcd->p_FmPcdKg->clsPlanBase;i<p_FmPcd->p_FmPcdKg->numOfClsPlanEntries/CLS_PLAN_NUM_PER_GRP;)
+    {
+        if(!p_FmPcd->p_FmPcdKg->clsPlanUsedBlocks[i])
+        {
+            blocksFound++;
+            i++;
+            if(blocksFound == numOfBlocks)
+                break;
+        }
+        else
+        {
+            blocksFound = 0;
+            /* advance i to the next aligned address */
+            first = i = (uint8_t)(first + numOfBlocks);
+        }
+    }
+
+    if(blocksFound == numOfBlocks)
+    {
+        *p_BaseEntry = (uint8_t)(first*CLS_PLAN_NUM_PER_GRP);
+        for(j = first; j<first + numOfBlocks; j++)
+            p_FmPcd->p_FmPcdKg->clsPlanUsedBlocks[j] = TRUE;
+        RELEASE_LOCK(p_FmPcd->lock);
+        return E_OK;
+    }
+    else
+    {
+        RELEASE_LOCK(p_FmPcd->lock);
+        RETURN_ERROR(MINOR, E_FULL, ("No recources for clsPlan"));
+    }
+}
+
+static void FreeClsPlanGrpBlock(t_FmPcd *p_FmPcd, uint16_t sizeOfGrp, uint8_t baseEntry)
+{
+    int     i;
+
+    for(i=baseEntry/CLS_PLAN_NUM_PER_GRP;i<(baseEntry/CLS_PLAN_NUM_PER_GRP+sizeOfGrp/CLS_PLAN_NUM_PER_GRP);i++)
+    {
+        ASSERT_COND( p_FmPcd->p_FmPcdKg->clsPlanUsedBlocks[i]);
+        p_FmPcd->p_FmPcdKg->clsPlanUsedBlocks[i] = FALSE;
+    }
+}
+
+t_Handle FmPcdKgBuildClsPlanGrp(t_Handle h_FmPcd, t_FmPcdKgClsPlanGrpParams *p_Grp, t_FmPcdKgInterModuleClsPlanSet *p_ClsPlanSet)
+{
+    t_FmPcd                         *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    protocolOpt_t                   allOptions = 0, tmpOpt;
+    int                             i, j;
+    uint8_t                         numOfOptions = 0, grpId;
+    uint32_t                        walking1Mask, oredVectors = 0, lcvVector;
+    uint8_t                         tmpEntryId;
+    t_FmPcdKgClsPlanGrp             *p_ClsPlanGrp;
+    t_Error                         err;
+    struct {
+        protocolOpt_t   opt;
+        uint32_t        vector;
+    }                               tmpOptStruct[MAX_NUM_OF_OPTIONS];
+
+    SANITY_CHECK_RETURN_VALUE(p_FmPcd, E_INVALID_HANDLE, NULL);
+    SANITY_CHECK_RETURN_VALUE(p_FmPcd->p_FmPcdKg, E_INVALID_HANDLE, NULL);
+
+    TRY_LOCK_RET_NULL(p_FmPcd->lock);
+
+    /* find a new clsPlan group */
+    for(i = 0;i<PCD_MAX_NUM_OF_PORTS;i++)
+        if(!p_FmPcd->p_FmPcdKg->clsPlanGrps[i].used)
+            break;
+    if(i== PCD_MAX_NUM_OF_PORTS)
+    {
+        REPORT_ERROR(MAJOR, E_FULL,("No classification plan groups available."));
+        RELEASE_LOCK(p_FmPcd->lock);
+        return NULL;
+    }
+    p_FmPcd->p_FmPcdKg->clsPlanGrps[i].used = TRUE;
+
+    TRY_LOCK_RET_NULL(p_FmPcd->p_FmPcdKg->clsPlanGrps[i].lock);
+    RELEASE_LOCK(p_FmPcd->lock);
+
+    grpId = (uint8_t)i;
+
+    p_ClsPlanGrp = &p_FmPcd->p_FmPcdKg->clsPlanGrps[i];
+    p_ClsPlanGrp->netEnvId = (uint8_t)(CAST_POINTER_TO_UINT32(p_Grp->h_NetEnv)-1);
+
+    p_ClsPlanGrp->owners = 0;
+
+    FmPcdIncNetEnvOwners(p_FmPcd, (uint8_t)(CAST_POINTER_TO_UINT32(p_Grp->h_NetEnv)-1));
+
+    /* first count all options */
+    for(i=0;i<p_Grp->numOfOptions;i++)
+        allOptions |= p_Grp->options[i];
+
+    walking1Mask = 0x80000000;
+    while(allOptions)
+    {
+        if (numOfOptions==8)
+        {
+            REPORT_ERROR(MAJOR, E_INVALID_VALUE,("Too many (more than 8) classification plan basic options selected."));
+            RELEASE_LOCK(p_FmPcd->lock);
+            return NULL;
+        }
+
+        if(allOptions & walking1Mask)
+        {
+            allOptions &= ~walking1Mask;
+            /* the internal array now represents the single options considered.
+            it's order defines the location of each option in the
+            classification plan array */
+            tmpOptStruct[numOfOptions].opt = walking1Mask;
+            err = PcdGetVectorForOpt(p_FmPcd,
+                                     (uint8_t)(CAST_POINTER_TO_UINT32(p_Grp->h_NetEnv)-1),
+                                     walking1Mask,
+                                     &tmpOptStruct[numOfOptions].vector);
+            if(err)
+            {
+                REPORT_ERROR(MINOR, E_INVALID_STATE, NO_MSG);
+                RELEASE_LOCK(p_FmPcd->p_FmPcdKg->clsPlanGrps[grpId].lock);
+                return NULL;
+            }
+            oredVectors  |= tmpOptStruct[numOfOptions].vector;
+            numOfOptions++;
+        }
+        walking1Mask >>= 1;
+    }
+
+    /* allocate 2^numOfOptions entries */
+    if(numOfOptions > MAX_NUM_OF_OPTIONS)
+    {
+        REPORT_ERROR(MINOR, E_INVALID_VALUE, ("Too many options - no more than %d components allowed.", MAX_NUM_OF_OPTIONS));
+        RELEASE_LOCK(p_FmPcd->p_FmPcdKg->clsPlanGrps[grpId].lock);
+        return NULL;
+    }
+    p_ClsPlanGrp->sizeOfGrp = (uint16_t)(1<<numOfOptions);
+    /* a minimal group of 8 is required */
+    if(p_ClsPlanGrp->sizeOfGrp < CLS_PLAN_NUM_PER_GRP)
+        p_ClsPlanGrp->sizeOfGrp = CLS_PLAN_NUM_PER_GRP;
+
+    err = AllocClsPlanGrpBlocks(p_FmPcd, p_ClsPlanGrp->sizeOfGrp, &p_ClsPlanGrp->baseEntry);
+    if(err)
+    {
+        RELEASE_LOCK(p_FmPcd->p_FmPcdKg->clsPlanGrps[grpId].lock);
+        REPORT_ERROR(MINOR, E_INVALID_STATE, NO_MSG);
+        return NULL;
+    }
+
+    p_ClsPlanSet->baseEntry = p_ClsPlanGrp->baseEntry;
+
+    /* set all entries in group to be the non-option vector */
+    p_ClsPlanSet->numOfClsPlanEntries = p_ClsPlanGrp->sizeOfGrp;
+    for(i=0;i<p_ClsPlanGrp->sizeOfGrp;i++)
+        p_ClsPlanSet->vectors[i] = ~oredVectors;
+
+    /* now set the relevant values only for user defined option */
+    for(i=0;i<p_Grp->numOfOptions;i++)
+    {
+        tmpEntryId = 0;
+        lcvVector = ~oredVectors;
+        j = 0;
+        tmpOpt = p_Grp->options[i];
+        while(tmpOpt)
+        {
+            /* find each option in the internal array */
+            if((tmpOpt & tmpOptStruct[j].opt) == tmpOptStruct[j].opt)
+            {
+                /* clear that bit */
+                tmpOpt &= ~tmpOptStruct[j].opt;
+                /* j is now the internal array interesting entry */
+                tmpEntryId += (1 << j);
+                lcvVector |= tmpOptStruct[j].vector;
+            }
+            j++;
+        }
+
+        ASSERT_COND(tmpEntryId < p_ClsPlanGrp->sizeOfGrp);
+        p_ClsPlanSet->vectors[tmpEntryId] = lcvVector;
+    }
+
+    /* save an array of used options - the indexes represent the power of 2 index */
+    j=0;
+    while(j<numOfOptions)
+    {
+        p_ClsPlanGrp->optArray[j] = tmpOptStruct[j].opt;
+        j++;
+    }
+
+    RELEASE_LOCK(p_FmPcd->p_FmPcdKg->clsPlanGrps[grpId].lock);
+
+    return CAST_UINT32_TO_POINTER((uint32_t)grpId+1);;
+}
+
+void FmPcdKgDestroyClsPlanGrp(t_Handle h_FmPcd, uint8_t grpId)
+{
+    t_FmPcd                         *p_FmPcd = (t_FmPcd*)h_FmPcd;
+
+    /* check that no port is bound to this port */
+    if(p_FmPcd->p_FmPcdKg->clsPlanGrps[grpId].owners)
+       REPORT_ERROR(MINOR, E_INVALID_STATE, ("Trying to delete a clsPlan grp that has ports bound to"));
+
+    FmPcdDecNetEnvOwners(p_FmPcd, p_FmPcd->p_FmPcdKg->clsPlanGrps[grpId].netEnvId);
+
+    /* free blocks */
+    FreeClsPlanGrpBlock(p_FmPcd, p_FmPcd->p_FmPcdKg->clsPlanGrps[grpId].sizeOfGrp, p_FmPcd->p_FmPcdKg->clsPlanGrps[grpId].baseEntry);
+
+    /* clear clsPlan driver structure */
+    memset(&p_FmPcd->p_FmPcdKg->clsPlanGrps[grpId], 0, sizeof(t_FmPcdKgClsPlanGrp));
+}
+
+t_Error FmPcdKgBuildBindPortToSchemes(t_Handle h_FmPcd , t_FmPcdKgInterModuleBindPortToSchemes *p_BindPort, uint32_t *p_SpReg, bool add)
+{
+    t_FmPcd                 *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    uint32_t                j, schemesPerPortVector = 0;
+    t_FmPcdKgScheme         *p_Scheme;
+    uint8_t                 i, relativeSchemeId;
+    uint32_t                tmp, walking1Mask;
+    uint16_t                pcdPortId;
+    uint8_t                 portsTable[] = PCD_PORTS_TABLE;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdKg, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE);
+
+    /* for each scheme */
+    for(i = 0; i<p_BindPort->numOfSchemes; i++)
+    {
+        relativeSchemeId = FmPcdKgGetRelativeSchemeId(p_FmPcd, p_BindPort->schemesIds[i]);
+        if(relativeSchemeId == FM_PCD_KG_NUM_OF_SCHEMES)
+            REPORT_ERROR(MAJOR, E_NOT_IN_RANGE, NO_MSG);
+
+        if(add)
+        {
+            if (!FmPcdKgIsSchemeValidSw(h_FmPcd, relativeSchemeId))
+                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Requested scheme is invalid."));
+
+            p_Scheme = &p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId];
+            /* check netEnvId  of the port against the scheme netEnvId */
+            if((p_Scheme->netEnvId != p_BindPort->netEnvId) && (p_Scheme->netEnvId != DRIVER_PRIVATE_NET_ENV_ID))
+                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Port may not be bound to requested scheme - differ in netEnvId"));
+
+            /* if next engine is private port policer profile, we need to check that it is valid */
+            GET_FM_PCD_PORTID_FROM_GLOBAL_PORTID(pcdPortId, portsTable, p_BindPort->hardwarePortId)
+            if(p_Scheme->nextRelativePlcrProfile)
+            {
+                for(j = 0;j<p_Scheme->numOfProfiles;j++)
+                {
+                    ASSERT_COND(p_FmPcd->p_FmPcdPlcr->portsMapping[pcdPortId].h_FmPort);
+                    if(p_Scheme->relativeProfileId+j >= p_FmPcd->p_FmPcdPlcr->portsMapping[pcdPortId].numOfProfiles)
+                        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Relative profile not in range"));
+                     if(!FmPcdPlcrIsProfileValid(p_FmPcd, (uint16_t)(p_FmPcd->p_FmPcdPlcr->portsMapping[pcdPortId].profilesBase + p_Scheme->relativeProfileId + j)))
+                        RETURN_ERROR(MINOR, E_INVALID_STATE, ("Relative profile not valid."));
+                }
+            }
+            if(!p_BindPort->useClsPlan)
+            {
+                /* if this port does not use clsPlan, it may not be bound to schemes with units that contain
+                cls plan options. Schemes that are used only directly, should not be checked.
+                it also may not be bound to schemes that go to CC with units that are options  - so we OR
+                the match vector and the grpBits (= ccUnits) */
+                if ((p_Scheme->matchVector != SCHEME_ALWAYS_DIRECT) || p_Scheme->ccUnits)
+                {
+                    walking1Mask = 0x80000000;
+                    tmp = (p_Scheme->matchVector == SCHEME_ALWAYS_DIRECT)? 0:p_Scheme->matchVector;
+                    tmp |= p_Scheme->ccUnits;
+                    while (tmp)
+                    {
+                        if(tmp & walking1Mask)
+                        {
+                            tmp &= ~walking1Mask;
+                            if(!PcdNetEnvIsUnitWithoutOpts(p_FmPcd, p_Scheme->netEnvId, walking1Mask))
+                                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Port (without clsPlan) may not be bound to requested scheme - uses clsPlan options"));
+                        }
+                        walking1Mask >>= 1;
+                    }
+                }
+            }
+        }
+        /* build vector */
+        schemesPerPortVector |= 1 << (31 - p_BindPort->schemesIds[i]);
+    }
+
+    *p_SpReg = schemesPerPortVector;
+
+    return E_OK;
+}
+
+void FmPcdKgIncSchemeOwners(t_Handle h_FmPcd , t_FmPcdKgInterModuleBindPortToSchemes *p_BindPort)
+{
+    t_FmPcd             *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    int             i;
+    t_FmPcdKgScheme *p_Scheme;
+
+    /* for each scheme - update owners counters */
+    for(i = 0; i<p_BindPort->numOfSchemes; i++)
+    {
+        p_Scheme = &p_FmPcd->p_FmPcdKg->schemes[p_BindPort->schemesIds[i]];
+
+        /* increment owners number */
+        p_Scheme->owners++;
+    }
+}
+
+void FmPcdKgDecSchemeOwners(t_Handle h_FmPcd , t_FmPcdKgInterModuleBindPortToSchemes *p_BindPort)
+{
+    t_FmPcd             *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    int             i;
+    t_FmPcdKgScheme *p_Scheme;
+
+    /* for each scheme - update owners counters */
+    for(i = 0; i<p_BindPort->numOfSchemes; i++)
+    {
+        p_Scheme = &p_FmPcd->p_FmPcdKg->schemes[p_BindPort->schemesIds[i]];
+
+        /* increment owners number */
+        ASSERT_COND(p_Scheme->owners);
+        p_Scheme->owners--;
+    }
+}
+
+#ifdef FM_MASTER_PARTITION
+t_Error  FmPcdKgAllocSchemes(t_Handle h_FmPcd, uint8_t numOfSchemes, uint8_t partitionId, uint8_t *p_SchemesIds)
+{
+    t_FmPcd             *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    uint8_t             i,j;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdKg, E_INVALID_HANDLE);
+
+    TRY_LOCK_RET_ERR(p_FmPcd->lock);
+
+    for(j=0,i=0;i<FM_PCD_KG_NUM_OF_SCHEMES && j<numOfSchemes;i++)
+    {
+        if(!p_FmPcd->p_FmPcdKg->schemesMng[i].allocated)
+        {
+            p_FmPcd->p_FmPcdKg->schemesMng[i].allocated = TRUE;
+            p_FmPcd->p_FmPcdKg->schemesMng[i].ownerId = partitionId;
+            p_SchemesIds[j] = i;
+            j++;
+        }
+    }
+
+    if (j != numOfSchemes)
+    {
+        /* roll back */
+        for(i = 0;i<j;i++)
+        {
+            p_SchemesIds[j] = 0;
+            p_FmPcd->p_FmPcdKg->schemesMng[p_SchemesIds[i]].allocated = FALSE;
+            p_FmPcd->p_FmPcdKg->schemesMng[p_SchemesIds[i]].ownerId = 0;
+            p_SchemesIds[i] = 0;
+        }
+        RELEASE_LOCK(p_FmPcd->lock);
+        RETURN_ERROR(MAJOR, E_NOT_AVAILABLE, ("No schemes found"));
+    }
+
+    RELEASE_LOCK(p_FmPcd->lock);
+
+    return E_OK;
+}
+
+t_Error  FmPcdKgFreeSchemes(t_Handle h_FmPcd, uint8_t numOfSchemes, uint8_t partitionId, uint8_t *p_SchemesIds)
+{
+    t_FmPcd             *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    uint8_t             i;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdKg, E_INVALID_HANDLE);
+
+    TRY_LOCK_RET_ERR(p_FmPcd->lock);
+
+    for(i=0;i<numOfSchemes;i++)
+    {
+        if(!p_FmPcd->p_FmPcdKg->schemesMng[p_SchemesIds[i]].allocated)
+        {
+            RELEASE_LOCK(p_FmPcd->lock);
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Scheme was not previously allocated"));
+        }
+        if(p_FmPcd->p_FmPcdKg->schemesMng[p_SchemesIds[i]].ownerId != partitionId)
+        {
+            RELEASE_LOCK(p_FmPcd->lock);
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Scheme is not owned by caller. "));
+        }
+        p_FmPcd->p_FmPcdKg->schemesMng[p_SchemesIds[i]].allocated = FALSE;
+        p_FmPcd->p_FmPcdKg->schemesMng[p_SchemesIds[i]].ownerId = 0;
+    }
+
+    RELEASE_LOCK(p_FmPcd->lock);
+    return E_OK;
+}
+
+t_Error  FmPcdKgAllocClsPlanEntries(t_Handle h_FmPcd, uint16_t numOfClsPlanEntries, uint8_t partitionId, uint8_t *p_First)
+{
+    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    uint8_t     numOfBlocks, blocksFound=0, first=0;
+    uint8_t     i, j;
+
+    TRY_LOCK_RET_ERR(p_FmPcd->lock);
+
+    if(!numOfClsPlanEntries)
+        return E_OK;
+    if ((numOfClsPlanEntries % CLS_PLAN_NUM_PER_GRP) || (!POWER_OF_2(numOfClsPlanEntries)))
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("numOfClsPlanEntries must be a power of 2 and divisible by 8"));
+
+    numOfBlocks =  (uint8_t)(numOfClsPlanEntries/CLS_PLAN_NUM_PER_GRP);
+
+    /* try to find consequent blocks */
+    first = 0;
+    for(i=0;i<FM_PCD_MAX_NUM_OF_CLS_PLANS/CLS_PLAN_NUM_PER_GRP;)
+    {
+        if(!p_FmPcd->p_FmPcdKg->clsPlanBlocksMng[i].allocated)
+        {
+            blocksFound++;
+            i++;
+            if(blocksFound == numOfBlocks)
+                break;
+        }
+        else
+        {
+            blocksFound = 0;
+            /* advance i to the next aligned address */
+            first = i = (uint8_t)(first + numOfBlocks);
+        }
+    }
+
+    if(blocksFound == numOfBlocks)
+    {
+        *p_First = (uint8_t)(first*CLS_PLAN_NUM_PER_GRP);
+        for(j = first; j<first + numOfBlocks; j++)
+        {
+            p_FmPcd->p_FmPcdKg->clsPlanBlocksMng[j].allocated = TRUE;
+            p_FmPcd->p_FmPcdKg->clsPlanBlocksMng[j].ownerId = partitionId;
+        }
+        RELEASE_LOCK(p_FmPcd->lock);
+
+        return E_OK;
+    }
+    else
+    {
+        RELEASE_LOCK(p_FmPcd->lock);
+        RETURN_ERROR(MINOR, E_FULL, ("No recources for clsPlan"));
+    }
+}
+
+t_Error  FmPcdKgFreeClsPlanEntries(t_Handle h_FmPcd, uint16_t numOfClsPlanEntries, uint8_t partitionId, uint8_t base)
+{
+    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    uint8_t     numOfBlocks;
+    uint8_t     i;
+
+    UNUSED( partitionId);
+
+    TRY_LOCK_RET_ERR(p_FmPcd->lock);
+
+    numOfBlocks =  (uint8_t)(numOfClsPlanEntries/CLS_PLAN_NUM_PER_GRP);
+
+    for(i=base;i<base+numOfBlocks;i++)
+    {
+        ASSERT_COND(p_FmPcd->p_FmPcdKg->clsPlanBlocksMng[i].allocated);
+        ASSERT_COND(partitionId == p_FmPcd->p_FmPcdKg->clsPlanBlocksMng[i].ownerId);
+        p_FmPcd->p_FmPcdKg->clsPlanBlocksMng[i].allocated = FALSE;
+        p_FmPcd->p_FmPcdKg->clsPlanBlocksMng[i].ownerId = 0;
+    }
+    RELEASE_LOCK(p_FmPcd->lock);
+    return E_OK;
+}
+#endif /* FM_MASTER_PARTITION */
+
+#ifndef CONFIG_GUEST_PARTITION /* master or single */
+t_Error KgEnable(t_FmPcd *p_FmPcd)
+{
+    t_FmPcdKgRegs               *p_Regs = p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs;
+
+    WRITE_UINT32(p_Regs->kggcr,GET_UINT32(p_Regs->kggcr) | FM_PCD_KG_KGGCR_EN);
+
+    return E_OK;
+}
+
+static t_Error WriteKgarWait(t_FmPcd *p_FmPcd, uint32_t kgar)
+{
+    WRITE_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgar, kgar);
+    /* Wait for GO to be idle and read error */
+    while ((kgar = GET_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgar)) & FM_PCD_KG_KGAR_GO) ;
+    if (kgar & FM_PCD_KG_KGAR_ERR)
+        RETURN_ERROR(MINOR, E_INVALID_STATE, ("Keygen scheme access violation"));
+    return E_OK;
+}
+
+void KgSetClsPlan(t_Handle h_FmPcd, t_FmPcdKgInterModuleClsPlanSet *p_Set)
+{
+    t_FmPcd                 *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    t_FmPcdKgClsPlanRegs    *p_FmPcdKgPortRegs;
+    uint32_t                tmpKgarReg=0;
+    uint8_t                 i, j;
+
+    SANITY_CHECK_RETURN(p_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN(p_FmPcd->p_FmPcdKg, E_INVALID_HANDLE);
+
+    p_FmPcdKgPortRegs = &p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.clsPlanRegs;
+
+    for(i=p_Set->baseEntry;i<p_Set->baseEntry+p_Set->numOfClsPlanEntries;i+=8)
+    {
+        tmpKgarReg = FmPcdKgBuildWriteClsPlanBlockActionReg((uint8_t)(i / CLS_PLAN_NUM_PER_GRP));
+
+        for(j=i;j<i+8;j++)
+            WRITE_UINT32(p_FmPcdKgPortRegs->kgcpe[j % CLS_PLAN_NUM_PER_GRP],p_Set->vectors[j - p_Set->baseEntry]);
+
+        WriteKgarWait(p_FmPcd, tmpKgarReg);
+
+    }
+}
+
+static void PcdKgErrorException(t_Handle h_FmPcd)
+{
+    t_FmPcd                 *p_FmPcd = (t_FmPcd *)h_FmPcd;
+    uint32_t                event, schemeIndexes = 0,index = 0;
+
+    event = GET_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgeer);
+    event &= GET_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgeeer);
+
+    schemeIndexes = GET_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgseer);
+    schemeIndexes &= GET_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgseeer);
+
+    WRITE_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgeer, event);
+    WRITE_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgseer, schemeIndexes);
+
+    if(event & FM_PCD_KG_DOUBLE_ECC)
+        p_FmPcd->f_FmPcdException(p_FmPcd->h_App,e_FM_PCD_KG_ERR_EXCEPTION_DOUBLE_ECC);
+    if(event & FM_PCD_KG_KEYSIZE_OVERFLOW)
+    {
+        if(schemeIndexes)
+        {
+            while(schemeIndexes)
+            {
+                if(schemeIndexes & 0x1)
+                    p_FmPcd->f_FmPcdIndexedException(p_FmPcd->h_App,e_FM_PCD_KG_ERR_EXCEPTION_KEYSIZE_OVERFLOW, (uint16_t)(31 - index));
+                schemeIndexes >>= 1;
+                index+=1;
+            }
+        }
+        else /* this should happen only when interrupt is forced. */
+            p_FmPcd->f_FmPcdException(p_FmPcd->h_App,e_FM_PCD_KG_ERR_EXCEPTION_KEYSIZE_OVERFLOW);
+    }
+}
+
+static t_Error KgWriteSp(t_FmPcd *p_FmPcd, uint8_t hardwarePortId, uint32_t spReg, bool add)
+{
+    if (p_FmPcd->h_Hc)
+        return FmHcKgWriteSp(p_FmPcd->h_Hc, hardwarePortId, spReg, add);
+    else
+#ifdef CONFIG_MULTI_PARTITION_SUPPORT
+        RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("No HC obj. must have HC in guest partition!"));
+#else
+    {
+        t_FmPcdKgPortConfigRegs *p_FmPcdKgPortRegs;
+        uint32_t                tmpKgarReg = 0, tmpKgpeSp;
+        t_Error                 err;
+
+        p_FmPcdKgPortRegs = &p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.portRegs;
+
+        tmpKgarReg = FmPcdKgBuildReadPortSchemeBindActionReg(hardwarePortId);
+
+        err = WriteKgarWait(p_FmPcd, tmpKgarReg);
+        if(err)
+            RETURN_ERROR(MINOR, err, NO_MSG);
+
+        tmpKgpeSp = GET_UINT32(p_FmPcdKgPortRegs->kgoe_sp);
+
+        if(add)
+            tmpKgpeSp |= spReg;
+        else
+            tmpKgpeSp &= ~spReg;
+
+        WRITE_UINT32(p_FmPcdKgPortRegs->kgoe_sp, tmpKgpeSp);
+
+        tmpKgarReg = FmPcdKgBuildWritePortSchemeBindActionReg(hardwarePortId);
+
+        err = WriteKgarWait(p_FmPcd, tmpKgarReg);
+        if(err)
+            RETURN_ERROR(MINOR, err, NO_MSG);
+    }
+
+    return E_OK;
+#endif /* CONFIG_MULTI_PARTITION_SUPPORT */
+}
+
+static t_Error KgWriteCpp(t_FmPcd *p_FmPcd, uint8_t hardwarePortId, uint32_t cppReg)
+{
+    if (p_FmPcd->h_Hc)
+        return FmHcKgWriteCpp(p_FmPcd->h_Hc, hardwarePortId, cppReg);
+    else
+#ifdef CONFIG_MULTI_PARTITION_SUPPORT
+        RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("No HC obj. must have HC in guest partition!"));
+#else
+    {
+        t_FmPcdKgPortConfigRegs *p_FmPcdKgPortRegs;
+        uint32_t                tmpKgarReg;
+
+        p_FmPcdKgPortRegs = &p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.portRegs;
+        WRITE_UINT32(p_FmPcdKgPortRegs->kgoe_cpp, cppReg);
+
+        tmpKgarReg = FmPcdKgBuildWritePortClsPlanBindActionReg(hardwarePortId);
+        return WriteKgarWait(p_FmPcd, tmpKgarReg);
+    }
+#endif /* CONFIG_MULTI_PARTITION_SUPPORT */
+}
+
+/****************************************/
+/*  Internal and Inter-Module routines  */
+/****************************************/
+t_Error FmPcdKgBindPortToSchemes(t_Handle h_FmPcd , t_FmPcdKgInterModuleBindPortToSchemes  *p_SchemeBind)
+{
+    t_FmPcd                 *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    uint32_t                spReg;
+    t_Error                 err;
+
+    err = FmPcdKgBuildBindPortToSchemes(h_FmPcd, p_SchemeBind, &spReg, TRUE);
+    if(err)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+
+    err = KgWriteSp(p_FmPcd, p_SchemeBind->hardwarePortId, spReg, TRUE);
+    if(err)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+
+    FmPcdKgIncSchemeOwners(h_FmPcd, p_SchemeBind);
+
+    return E_OK;
+}
+
+t_Error FmPcdKgUnbindPortToSchemes(t_Handle h_FmPcd ,  t_FmPcdKgInterModuleBindPortToSchemes *p_SchemeBind)
+{
+    t_FmPcd                 *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    uint32_t                spReg;
+    t_Error                 err;
+
+    err = FmPcdKgBuildBindPortToSchemes(h_FmPcd, p_SchemeBind, &spReg, FALSE);
+    if(err)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+
+    err = KgWriteSp(p_FmPcd, p_SchemeBind->hardwarePortId, spReg, FALSE);
+    if(err)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+
+    FmPcdKgDecSchemeOwners(h_FmPcd, p_SchemeBind);
+
+    return E_OK;
+}
+
+t_Error FmPcdKgBindPortToClsPlanGrp(t_Handle h_FmPcd, uint8_t hardwarePortId, uint8_t clsPlanGrpId)
+{
+    t_FmPcd                 *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    uint32_t                tmpKgpeCpp = 0;
+
+    tmpKgpeCpp = FmPcdKgBuildCppReg(p_FmPcd, clsPlanGrpId);
+    return KgWriteCpp(p_FmPcd, hardwarePortId, tmpKgpeCpp);
+}
+
+void FmPcdKgUnbindPortToClsPlanGrp(t_Handle h_FmPcd, uint8_t hardwarePortId)
+{
+    t_FmPcd                 *p_FmPcd = (t_FmPcd*)h_FmPcd;
+
+    SANITY_CHECK_RETURN(p_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN(p_FmPcd->p_FmPcdKg, E_INVALID_HANDLE);
+
+    KgWriteCpp(p_FmPcd, hardwarePortId, 0);
+}
+
+#if 0
+bool KgSchemeIsValid(t_Handle h_FmPcd, uint8_t schemeId)
+{
+    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    uint32_t    tmpReg;
+    uint32_t    tmpKgarReg;
+    t_Error     err;
+
+    SANITY_CHECK_RETURN_VALUE(p_FmPcd, E_INVALID_HANDLE, FALSE);
+    SANITY_CHECK_RETURN_VALUE(p_FmPcd->p_FmPcdKg, E_INVALID_HANDLE, FALSE);
+    SANITY_CHECK_RETURN_VALUE(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE, FALSE);
+    SANITY_CHECK_RETURN_VALUE(schemeId<p_FmPcd->p_FmPcdKg->numOfSchemes, E_INVALID_STATE, 0);
+
+    /* read specified scheme into scheme registers */
+    tmpKgarReg = FmPcdKgBuildReadSchemeActionReg(p_FmPcd->p_FmPcdKg->schemesIds[schemeId]);
+    WriteKgarWait(p_FmPcd, tmpKgarReg);
+
+    tmpReg = GET_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs.kgse_mode);
+    if (tmpReg & KG_SCH_MODE_EN)
+        return TRUE;
+    else
+        return FALSE;
+}
+#endif /* 0 */
+
+bool     FmPcdKgIsSchemeValidSw(t_Handle h_FmPcd, uint8_t schemeId)
+{
+    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
+
+    return p_FmPcd->p_FmPcdKg->schemes[schemeId].valid;
+}
+
+bool     KgIsSchemeAlwaysDirect(t_Handle h_FmPcd, uint8_t schemeId)
+{
+    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
+
+    if(p_FmPcd->p_FmPcdKg->schemes[schemeId].matchVector == SCHEME_ALWAYS_DIRECT)
+        return TRUE;
+    else
+        return FALSE;
+}
+
+t_Handle KgConfig( t_FmPcd *p_FmPcd, t_FmPcdParams *p_FmPcdParams)
+{
+    t_FmPcdKg   *p_FmPcdKg;
+#ifndef CONFIG_MULTI_PARTITION_SUPPORT
+    uint8_t     i=0;
+#endif /* !CONFIG_MULTI_PARTITION_SUPPORT */
+
+    UNUSED(p_FmPcd);
+    p_FmPcdKg = (t_FmPcdKg *) XX_Malloc(sizeof(t_FmPcdKg));
+    if (!p_FmPcdKg)
+    {
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM Keygen allocation FAILED"));
+        return NULL;
+    }
+    memset(p_FmPcdKg, 0, sizeof(t_FmPcdKg));
+
+#ifndef CONFIG_GUEST_PARTITION
+    p_FmPcdKg->p_FmPcdKgRegs  = CAST_UINT64_TO_POINTER_TYPE(t_FmPcdKgRegs, (FmGetPcdKgBaseAddr(p_FmPcdParams->h_Fm)));
+
+    p_FmPcd->exceptions |= DEFAULT_fmPcdKgErrorExceptions;
+#endif /* !CONFIG_GUEST_PARTITION */
+
+#ifdef CONFIG_MULTI_PARTITION_SUPPORT
+    p_FmPcdKg->numOfSchemes = p_FmPcdParams->numOfSchemes;
+    p_FmPcdKg->numOfClsPlanEntries = p_FmPcdParams->numOfClsPlanEntries;
+#else
+    p_FmPcdKg->numOfSchemes = FM_PCD_KG_NUM_OF_SCHEMES;
+    for(i = 0;i<FM_PCD_KG_NUM_OF_SCHEMES;i++)
+        p_FmPcdKg->schemesIds[i] = i;
+    p_FmPcdKg->numOfClsPlanEntries = (uint16_t)FM_PCD_MAX_NUM_OF_CLS_PLANS;
+    p_FmPcdKg->clsPlanBase = 0;
+#endif /* CONFIG_MULTI_PARTITION_SUPPORT */
+
+    p_FmPcdKg->isDriverEmptyClsPlanGrp = FALSE;
+
+    return p_FmPcdKg;
+}
+
+t_Error KgInit(t_FmPcd *p_FmPcd)
+{
+    t_Error                     err;
+    t_FmPcdKgRegs               *p_Regs = p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs;
+#ifndef CONFIG_GUEST_PARTITION
+    int                         i;
+    t_FmPcdKgPortConfigRegs     *p_FmPcdKgPortRegs;
+    uint32_t                    tmpKgarReg;
+    uint8_t                     hardwarePortId;
+    uint8_t                     portsTable[] = PCD_PORTS_TABLE;
+    uint32_t                    tmpReg;
+#else
+    t_FmPcdIpcKgAllocParams     kgAlloc;
+#endif /* CONFIG_GUEST_PARTITION */
+
+#ifndef CONFIG_GUEST_PARTITION
+    /**********************KGEER******************/
+    WRITE_UINT32(p_Regs->kgeer, (FM_PCD_KG_DOUBLE_ECC | FM_PCD_KG_KEYSIZE_OVERFLOW));
+    /**********************KGEER******************/
+    /**********************KGEEER******************/
+    tmpReg = 0;
+    if(p_FmPcd->exceptions & FM_PCD_EX_KG_DOUBLE_ECC)
+    {
+        if(!FmRamsEccIsExternalCtl(p_FmPcd->h_Fm))
+            FM_EnableRamsEcc(p_FmPcd->h_Fm);
+        tmpReg |= FM_PCD_KG_DOUBLE_ECC;
+    }
+    if(p_FmPcd->exceptions & FM_PCD_EX_KG_KEYSIZE_OVERFLOW)
+        tmpReg |= FM_PCD_KG_KEYSIZE_OVERFLOW;
+    WRITE_UINT32(p_Regs->kgeeer,tmpReg);
+    /**********************KGEEER******************/
+
+    /**********************KGFDOR******************/
+    WRITE_UINT32(p_Regs->kgfdor,0);
+    /**********************KGFDOR******************/
+
+    /**********************KGGDV0R******************/
+    WRITE_UINT32(p_Regs->kggdv0r,0);
+    /**********************KGGDV0R******************/
+
+    /**********************KGGDV1R******************/
+    WRITE_UINT32(p_Regs->kggdv1r,0);
+    /**********************KGGDV1R******************/
+
+    /**********************KGGCR******************/
+    WRITE_UINT32(p_Regs->kggcr, NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME);
+    /**********************KGGCR******************/
+
+    /* register even if no interrupts enabled, to allow future enablement */
+    FmRegisterIntr(p_FmPcd->h_Fm, e_FM_EV_ERR_KG, PcdKgErrorException, p_FmPcd);
+
+    for(i=0;i<FM_PCD_MAX_NUM_OF_CLS_PLANS/CLS_PLAN_NUM_PER_GRP;i++)
+        p_FmPcd->p_FmPcdKg->clsPlanUsedBlocks[i] = FALSE;
+
+    /* clear binding between ports to schemes so that all ports are not bound to any schemes */
+    p_FmPcdKgPortRegs = &p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.portRegs;
+    for (i=0;i<PCD_MAX_NUM_OF_PORTS;i++)
+    {
+
+        GET_GLOBAL_PORTID_FROM_PCD_PORTS_TABLE(hardwarePortId, portsTable,i);
+
+        WRITE_UINT32(p_FmPcdKgPortRegs->kgoe_sp, 0x00000000);
+
+        tmpKgarReg = FmPcdKgBuildWritePortSchemeBindActionReg(hardwarePortId);
+
+        err = WriteKgarWait(p_FmPcd, tmpKgarReg);
+//        err = KgWriteSp(p_FmPcd, hardwarePortId, 0xffffffff, FALSE);
+        if(err)
+            RETURN_ERROR(MINOR, err, NO_MSG);
+
+        WRITE_UINT32(p_FmPcdKgPortRegs->kgoe_cpp, 0x00000000);
+
+        tmpKgarReg = FmPcdKgBuildWritePortClsPlanBindActionReg(hardwarePortId);
+
+        err = WriteKgarWait(p_FmPcd, tmpKgarReg);
+//        err = KgWriteCpp(p_FmPcd, hardwarePortId, 0);
+        if(err)
+            RETURN_ERROR(MINOR, err, NO_MSG);
+    }
+
+    /* enable and enable all scheme interrupts                */
+    WRITE_UINT32(p_Regs->kgseer, 0xFFFFFFFF);
+    WRITE_UINT32(p_Regs->kgseeer, 0xFFFFFFFF);
+#endif /* !CONFIG_GUEST_PARTITION */
+
+    if(!p_FmPcd->p_FmPcdKg->numOfClsPlanEntries)
+        /* allocate at least the minimum grp for not using clsPlan */
+        p_FmPcd->p_FmPcdKg->numOfClsPlanEntries = CLS_PLAN_NUM_PER_GRP;
+
+    /* In Multi partition, both guest and master should allocate schemes and
+       clsPlan entries for future use */
+#ifdef CONFIG_MULTI_PARTITION_SUPPORT
+#ifdef CONFIG_GUEST_PARTITION
+    /* in GUEST_PARTITION, we use the IPC, to also set a private driver group if required */
+    kgAlloc.numOfSchemes = p_FmPcd->p_FmPcdKg->numOfSchemes;
+    kgAlloc.partitionId = p_FmPcd->partitionId;
+    kgAlloc.numOfClsPlanEntries = p_FmPcd->p_FmPcdKg->numOfClsPlanEntries;
+    err = XX_SendMessage(p_FmPcd->fmPcdModuleName, FM_PCD_ALLOC_KG_RSRC, (uint8_t*)&kgAlloc, NULL, NULL);
+    if(err)
+        RETURN_ERROR(MINOR, err, NO_MSG);
+    memcpy(p_FmPcd->p_FmPcdKg->schemesIds , kgAlloc.schemesIds, kgAlloc.numOfSchemes);
+    p_FmPcd->p_FmPcdKg->clsPlanBase = kgAlloc.clsPlanBase;
+#else /* master */
+    if(p_FmPcd->p_FmPcdKg->numOfSchemes)
+    {
+        err = FmPcdKgAllocSchemes(p_FmPcd,
+                                    p_FmPcd->p_FmPcdKg->numOfSchemes,
+                                    p_FmPcd->partitionId,
+                                    p_FmPcd->p_FmPcdKg->schemesIds);
+        if(err)
+            RETURN_ERROR(MINOR, err, NO_MSG);
+    }
+    err = FmPcdKgAllocClsPlanEntries(p_FmPcd,
+                                p_FmPcd->p_FmPcdKg->numOfClsPlanEntries,
+                                p_FmPcd->partitionId,
+                                &p_FmPcd->p_FmPcdKg->clsPlanBase);
+    if(err)
+        RETURN_ERROR(MINOR, err, NO_MSG);
+
+#endif /* CONFIG_GUEST_PARTITION */
+#endif /* CONFIG_MULTI_PARTITION_SUPPORT */
+
+    return E_OK;
+}
+
+#if 0
+#ifdef CONFIG_MULTI_PARTITION_SUPPORT
+    if(p_FmPcd->p_FmPcdKg->isDriverEmptyClsPlanGrp)
+    {
+        /* For guest XX_SendMessage will initialize the first 8 entries
+           for the driver's empty classification plan. For master it will be set below.
+           We now need to internally (sw) allocate this
+           block (8 entries) in the partition p_FmPcd clsPlan structure.
+           We assume that since this is the first internal allocation, the first 8 entries will be allocated */
+        clsPlanGrp.netEnvId = DRIVER_PRIVATE_NET_ENV_ID;
+        clsPlanGrp.numOfOptions = 0;
+        err = FmPcdKgBuildClsPlanGrp(p_FmPcd, &clsPlanGrp, &clsPlanSet);
+        if(err)
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+        ASSERT_COND(clsPlanGrp.clsPlanGrpId==0);
+        ASSERT_COND(clsPlanSet.baseEntry == p_FmPcd->p_FmPcdKg->clsPlanBase);
+
+#ifdef CONFIG_GUEST_PARTITION
+    err = XX_SendMessage(p_FmPcd->fmPcdModuleName, FM_PCD_ALLOC_CLS_PLAN_EMPTY_GRP, (uint8_t*)&p_FmPcd->p_FmPcdKg->clsPlanBase, NULL, NULL);
+    if(err)
+        RETURN_ERROR(MINOR, err, NO_MSG);
+
+#else /* CONFIG_GUEST_PARTITION --> Master */
+        memset(clsPlanSet.vectors, 0xFF, CLS_PLAN_NUM_PER_GRP*sizeof(uint32_t));
+        clsPlanSet.baseEntry = p_FmPcd->p_FmPcdKg->clsPlanBase;
+        clsPlanSet.numOfClsPlanEntries = CLS_PLAN_NUM_PER_GRP;
+        KgSetClsPlan(p_FmPcd, &clsPlanSet);
+    }
+#endif /* CONFIG_GUEST_PARTITION */
+
+    /* in master or single partition, we now allocate a private driver group if required */
+#else /* ! CONFIG_MULTI_PARTITION_SUPPORT  --> Single */
+        /* prepare a clsPlan group for all ports that are not using the clsPlan mechanism */
+        clsPlanGrp.netEnvId = DRIVER_PRIVATE_NET_ENV_ID;
+        clsPlanGrp.numOfOptions = 0;
+        if(FM_PCD_KgSetClsPlanGrp(p_FmPcd, &clsPlanGrp) !=E_OK)
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Driver internal clsPlan group id should be '0'"));
+#endif  /* CONFIG_MULTI_PARTITION_SUPPORT */
+#endif /* 0 */
+
+t_Error FmPcdKgSwBindPortToClsPlanGrp(t_Handle h_FmPcd, uint8_t netEnvId, uint8_t clsPlanGrpId, protocolOpt_t *p_OptArray)
+{
+    t_FmPcd                 *p_FmPcd = (t_FmPcd *)h_FmPcd;
+    t_FmPcdKgClsPlanGrp     *p_ClsPlanGrp = &p_FmPcd->p_FmPcdKg->clsPlanGrps[clsPlanGrpId];
+
+    /* check that this clsPlan group is valid */
+    if(!p_FmPcd->p_FmPcdKg->clsPlanGrps[clsPlanGrpId].used)
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid clsPlan group."));
+
+    if(p_ClsPlanGrp->netEnvId != DRIVER_PRIVATE_NET_ENV_ID)
+    /* When netEnvId == DRIVER_PRIVATE_NET_ENV_ID this is a special internal driver group.
+    it is used by ports that do not use the classification plan mechanism, and it is of
+    the minimum size - 8 entries = 1 block. In this case no check is done,
+    any port from any netEnv may be bound to this group. */
+        if(p_ClsPlanGrp->netEnvId != netEnvId)
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Port may not be bound to requested clsPlan - difer in netEnvId"));
+    /* increment owners number */
+    p_ClsPlanGrp->owners++;
+
+    /* copy options array for port */
+    memcpy(p_OptArray, &p_FmPcd->p_FmPcdKg->clsPlanGrps[clsPlanGrpId].optArray, MAX_NUM_OF_OPTIONS*sizeof(protocolOpt_t));
+
+    return E_OK;
+}
+
+void FmPcdKgSwUnbindPortToClsPlanGrp(t_Handle h_FmPcd, uint8_t clsPlanGrpId)
+{
+    t_FmPcd                 *p_FmPcd = (t_FmPcd *)h_FmPcd;
+
+    t_FmPcdKgClsPlanGrp     *p_ClsPlanGrp = &p_FmPcd->p_FmPcdKg->clsPlanGrps[clsPlanGrpId];
+
+     /* decrement owners number */
+    ASSERT_COND(p_ClsPlanGrp->owners);
+    p_ClsPlanGrp->owners--;
+}
+
+t_Error FmPcdKgBuildScheme(t_Handle h_FmPcd,  t_FmPcdKgSchemeParams *p_Scheme, t_FmPcdKgInterModuleSchemeRegs *p_SchemeRegs, t_FmPcdKgKeyOrder *p_OrderedArray)
+{
+    t_FmPcd                             *p_FmPcd = (t_FmPcd *)h_FmPcd;
+    uint32_t                            grpBits;
+    uint8_t                             grpBase;
+    bool                                direct=TRUE, absolute=FALSE;
+    uint16_t                            profileId, numOfProfiles=0, relativeProfileId;
+    t_Error                             err;
+    int                                 i = 0;
+    t_NetEnvParams                      netEnvParams;
+    uint32_t                            tmpReg, fqbTmp = 0, ppcTmp = 0, selectTmp, maskTmp, knownTmp, genTmp;
+    t_FmPcdKgKeyExtractAndHashParams    *p_KeyAndHash;
+    uint8_t                             j, curr;
+    uint8_t                             id, shift=0, code=0, offset=0, size=0;
+    t_FmPcdExtractEntry                 *p_Extract = NULL;
+    t_FmPcdKgExtractedOrForFqid         *p_ExtractOr;
+    bool                                generic = FALSE;
+    t_KnownFieldsMasks                  bitMask;
+    e_FmPcdKgExtractDfltSelect          swDefault;
+    t_FmPcdKgKeyOrder                   orderedArray;
+    t_FmPcdKgSchemesExtracts            *p_LocalExtractsArray;
+    uint8_t                             numOfSwDefaults = 0;
+    t_FmPcdKgExtractDflt                swDefaults[NUM_OF_SW_DEFAULTS];
+    uint8_t                             currGenId = 0, relativeSchemeId;
+
+    memset(p_OrderedArray, 0, sizeof(t_FmPcdKgKeyOrder));
+    memset(orderedArray, 0, sizeof(t_FmPcdKgKeyOrder));
+    memset(swDefaults, 0, NUM_OF_SW_DEFAULTS*sizeof(t_FmPcdKgExtractDflt));
+
+    if(!p_Scheme->modify)
+        relativeSchemeId = p_Scheme->id.relativeSchemeId;
+    else
+        relativeSchemeId = FmPcdKgGetRelativeSchemeId(p_FmPcd, (uint8_t)(CAST_POINTER_TO_UINT32(p_Scheme->id.h_Scheme)-1));
+
+    /* by netEnv parameters, get match vector */
+    if(!p_Scheme->alwaysDirect)
+    {
+        p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].netEnvId =
+            (uint8_t)(CAST_POINTER_TO_UINT32(p_Scheme->netEnvParams.h_NetEnv)-1);
+        netEnvParams.netEnvId = p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].netEnvId;
+        netEnvParams.numOfDistinctionUnits = p_Scheme->netEnvParams.numOfDistinctionUnits;
+        memcpy(netEnvParams.unitIds, p_Scheme->netEnvParams.unitIds, p_Scheme->netEnvParams.numOfDistinctionUnits);
+        err = PcdGetUnitsVector(p_FmPcd, &netEnvParams);
+        if(err)
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
+        p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].matchVector = netEnvParams.vector;
+    }
+    else
+    {
+        p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].matchVector = SCHEME_ALWAYS_DIRECT;
+        p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].netEnvId = DRIVER_PRIVATE_NET_ENV_ID;
+    }
+
+    if(p_Scheme->nextEngine == e_FM_PCD_PLCR)
+    {
+        direct = p_Scheme->kgNextEngineParams.plcrProfile.direct;
+        absolute = p_Scheme->kgNextEngineParams.plcrProfile.sharedProfile ? TRUE: FALSE;
+        if(!direct && absolute)
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Indirect policing is not available when profile is shared."));
+
+        if(direct)
+        {
+            profileId = p_Scheme->kgNextEngineParams.plcrProfile.profileSelect.directRelativeProfileId;
+            numOfProfiles = 1;
+        }
+        else
+        {
+            profileId = p_Scheme->kgNextEngineParams.plcrProfile.profileSelect.indirectProfile.fqidOffsetRelativeProfileIdBase;
+            shift = p_Scheme->kgNextEngineParams.plcrProfile.profileSelect.indirectProfile.fqidOffsetShift;
+            numOfProfiles = p_Scheme->kgNextEngineParams.plcrProfile.profileSelect.indirectProfile.numOfProfiles;
+        }
+    }
+
+    if(p_Scheme->nextEngine == e_FM_PCD_CC)
+    {
+        err = CcGetGrpParams(p_Scheme->kgNextEngineParams.cc.h_CcTree,
+                             p_Scheme->kgNextEngineParams.cc.grpId,
+                             &grpBits,
+                             &grpBase);
+        if(err)
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+        p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].ccUnits = grpBits;
+
+        if(p_Scheme->kgNextEngineParams.cc.plcrNext)
+        {
+            if(p_Scheme->kgNextEngineParams.cc.plcrProfile.sharedProfile)
+                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Shared profile may not be used after Coarse classification."));
+            absolute = FALSE;
+            direct = p_Scheme->kgNextEngineParams.cc.plcrProfile.direct;
+            if(direct)
+            {
+                profileId = p_Scheme->kgNextEngineParams.cc.plcrProfile.profileSelect.directRelativeProfileId;
+                numOfProfiles = 1;
+            }
+            else
+            {
+                profileId = p_Scheme->kgNextEngineParams.cc.plcrProfile.profileSelect.indirectProfile.fqidOffsetRelativeProfileIdBase;
+                shift = p_Scheme->kgNextEngineParams.cc.plcrProfile.profileSelect.indirectProfile.fqidOffsetShift;
+                numOfProfiles = p_Scheme->kgNextEngineParams.cc.plcrProfile.profileSelect.indirectProfile.numOfProfiles;
+            }
+        }
+    }
+
+    /* if policer is used directly after KG, or after CC */
+    if((p_Scheme->nextEngine == e_FM_PCD_PLCR)  ||
+       ((p_Scheme->nextEngine == e_FM_PCD_CC) && (p_Scheme->kgNextEngineParams.cc.plcrNext)))
+    {
+        /* if private policer profile, it may be uninitialized yet, therefor no checks are done at this stage */
+        if(absolute)
+        {
+            /* for absolute direct policy only, */
+            relativeProfileId = profileId;
+            err = FmPcdPlcrGetAbsoluteProfileId(h_FmPcd,e_FM_PCD_PLCR_SHARED,NULL, relativeProfileId, &profileId);
+            if(err)
+                RETURN_ERROR(MAJOR, err, ("Shared profile not valid offset"));
+            if(!FmPcdPlcrIsProfileValid(p_FmPcd, profileId))
+                RETURN_ERROR(MINOR, E_INVALID_STATE, ("Shared profile not valid."));
+        }
+        else
+        {
+            /* save relative profile id's for later check */
+            p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].nextRelativePlcrProfile = TRUE;
+            p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].relativeProfileId = profileId;
+            p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].numOfProfiles = numOfProfiles;
+        }
+    }
+
+    /* configure all 21 scheme registers */
+    tmpReg =  KG_SCH_MODE_EN;
+    switch(p_Scheme->nextEngine)
+    {
+        case(e_FM_PCD_PLCR):
+            /* add to mode register - NIA */
+            tmpReg |= KG_SCH_MODE_NIA_PLCR;
+            tmpReg |= NIA_ENG_PLCR;
+            tmpReg |= (uint32_t)(p_Scheme->kgNextEngineParams.plcrProfile.sharedProfile ? NIA_PLCR_ABSOLUTE:0);
+            /* initialize policer profile command - */
+            /*  configure kgse_ppc  */
+            if(direct)
+            /* use profileId as base, other fields are 0 */
+                p_SchemeRegs->kgse_ppc = (uint32_t)profileId;
+            else
+            {
+                if(shift > MAX_PP_SHIFT)
+                    RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fqidOffsetShift may not be larger than %d", MAX_PP_SHIFT));
+
+                if(!numOfProfiles || !POWER_OF_2(numOfProfiles))
+                    RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("numOfProfiles must not be 0 and must be a power of 2"));
+
+                ppcTmp = ((uint32_t)shift << KG_SCH_PP_SHIFT_HIGH_SHIFT) & KG_SCH_PP_SHIFT_HIGH;
+                ppcTmp |= ((uint32_t)shift << KG_SCH_PP_SHIFT_LOW_SHIFT) & KG_SCH_PP_SHIFT_LOW;
+                ppcTmp |= ((uint32_t)(numOfProfiles-1) << KG_SCH_PP_MASK_SHIFT);
+                ppcTmp |= (uint32_t)profileId;
+
+                p_SchemeRegs->kgse_ppc = ppcTmp;
+            }
+            break;
+        case(e_FM_PCD_CC):
+            /* mode reg - define NIA */
+            tmpReg |= (NIA_ENG_FM_CTL | NIA_FM_CTL_AC_CC);
+
+            p_SchemeRegs->kgse_ccbs = grpBits;
+            tmpReg |= (uint32_t)(grpBase << KG_SCH_MODE_CCOBASE_SHIFT);
+
+            if(p_Scheme->kgNextEngineParams.cc.plcrNext)
+            {
+                /* find out if absolute or relative */
+                if(absolute)
+                     RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("It is illegal to request a shared profile in a scheme that is in a KG->CC->PLCR flow"));
+                if(direct)
+                {
+                    /* mask = 0, base = directProfileId */
+                    p_SchemeRegs->kgse_ppc = (uint32_t)profileId;
+                }
+                else
+                {
+                    if(shift > MAX_PP_SHIFT)
+                        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fqidOffsetShift may not be larger than %d", MAX_PP_SHIFT));
+                    if(!numOfProfiles || !POWER_OF_2(numOfProfiles))
+                        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("numOfProfiles must not be 0 and must be a power of 2"));
+
+                    ppcTmp = ((uint32_t)shift << KG_SCH_PP_SHIFT_HIGH_SHIFT) & KG_SCH_PP_SHIFT_HIGH;
+                    ppcTmp |= ((uint32_t)shift << KG_SCH_PP_SHIFT_LOW_SHIFT) & KG_SCH_PP_SHIFT_LOW;
+                    ppcTmp |= ((uint32_t)(numOfProfiles-1) << KG_SCH_PP_MASK_SHIFT);
+                    ppcTmp |= (uint32_t)profileId;
+
+                    p_SchemeRegs->kgse_ppc = ppcTmp;
+                }
+            }
+
+            break;
+        case(e_FM_PCD_DONE):
+            tmpReg |= (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME);
+            break;
+        default:
+             RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Next engine not supported"));
+    }
+    p_SchemeRegs->kgse_mode = tmpReg;
+
+    p_SchemeRegs->kgse_mv = p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].matchVector;
+
+    if(p_Scheme->useHash)
+    {
+        p_KeyAndHash = &p_Scheme->keyExtractAndHashParams;
+
+        /*  configure kgse_dv0  */
+        p_SchemeRegs->kgse_dv0 = p_KeyAndHash->privateDflt0;
+
+        /*  configure kgse_dv1  */
+        p_SchemeRegs->kgse_dv1 = p_KeyAndHash->privateDflt1;
+
+
+        /*  configure kgse_ekdv  */
+        tmpReg = 0;
+        for( i=0 ;i<p_KeyAndHash->numOfUsedDflts ; i++)
+        {
+            switch(p_KeyAndHash->dflts[i].type)
+            {
+                case(e_FM_PCD_KG_MAC_ADDR):
+                    tmpReg |= (p_KeyAndHash->dflts[i].dfltSelect << KG_SCH_DEF_MAC_ADDR_SHIFT);
+                    break;
+                case(e_FM_PCD_KG_TCI):
+                    tmpReg |= (p_KeyAndHash->dflts[i].dfltSelect << KG_SCH_DEF_TCI_SHIFT);
+                    break;
+                case(e_FM_PCD_KG_ENET_TYPE):
+                    tmpReg |= (p_KeyAndHash->dflts[i].dfltSelect << KG_SCH_DEF_ENET_TYPE_SHIFT);
+                    break;
+                case(e_FM_PCD_KG_PPP_SESSION_ID):
+                    tmpReg |= (p_KeyAndHash->dflts[i].dfltSelect << KG_SCH_DEF_PPP_SESSION_ID_SHIFT);
+                    break;
+                case(e_FM_PCD_KG_PPP_PROTOCOL_ID):
+                    tmpReg |= (p_KeyAndHash->dflts[i].dfltSelect << KG_SCH_DEF_PPP_PROTOCOL_ID_SHIFT);
+                    break;
+                case(e_FM_PCD_KG_MPLS_LABEL):
+                    tmpReg |= (p_KeyAndHash->dflts[i].dfltSelect << KG_SCH_DEF_MPLS_LABEL_SHIFT);
+                    break;
+                case(e_FM_PCD_KG_IP_ADDR):
+                    tmpReg |= (p_KeyAndHash->dflts[i].dfltSelect << KG_SCH_DEF_IP_ADDR_SHIFT);
+                    break;
+                case(e_FM_PCD_KG_PROTOCOL_TYPE):
+                    tmpReg |= (p_KeyAndHash->dflts[i].dfltSelect << KG_SCH_DEF_PROTOCOL_TYPE_SHIFT);
+                    break;
+                case(e_FM_PCD_KG_IP_TOS_TC):
+                    tmpReg |= (p_KeyAndHash->dflts[i].dfltSelect << KG_SCH_DEF_IP_TOS_TC_SHIFT);
+                    break;
+                case(e_FM_PCD_KG_IPV6_FLOW_LABEL):
+                    tmpReg |= (p_KeyAndHash->dflts[i].dfltSelect << KG_SCH_DEF_L4_PORT_SHIFT);
+                    break;
+                case(e_FM_PCD_KG_IPSEC_SPI):
+                    tmpReg |= (p_KeyAndHash->dflts[i].dfltSelect << KG_SCH_DEF_IPSEC_SPI_SHIFT);
+                    break;
+                case(e_FM_PCD_KG_L4_PORT):
+                    tmpReg |= (p_KeyAndHash->dflts[i].dfltSelect << KG_SCH_DEF_L4_PORT_SHIFT);
+                    break;
+                case(e_FM_PCD_KG_TCP_FLAG):
+                    tmpReg |= (p_KeyAndHash->dflts[i].dfltSelect << KG_SCH_DEF_TCP_FLAG_SHIFT);
+                    break;
+                case(e_FM_PCD_KG_GENERIC_FROM_DATA):
+                    swDefaults[numOfSwDefaults].type = e_FM_PCD_KG_GENERIC_FROM_DATA;
+                    swDefaults[numOfSwDefaults].dfltSelect = p_KeyAndHash->dflts[i].dfltSelect;
+                    numOfSwDefaults ++;
+                    break;
+                case(e_FM_PCD_KG_GENERIC_FROM_DATA_NO_V):
+                    swDefaults[numOfSwDefaults].type = e_FM_PCD_KG_GENERIC_FROM_DATA_NO_V;
+                    swDefaults[numOfSwDefaults].dfltSelect = p_KeyAndHash->dflts[i].dfltSelect;
+                    numOfSwDefaults ++;
+                    break;
+                case(e_FM_PCD_KG_GENERIC_NOT_FROM_DATA):
+                    swDefaults[numOfSwDefaults].type = e_FM_PCD_KG_GENERIC_NOT_FROM_DATA;
+                    swDefaults[numOfSwDefaults].dfltSelect = p_KeyAndHash->dflts[i].dfltSelect;
+                    numOfSwDefaults ++;
+                   break;
+                default:
+                    RETURN_ERROR(MAJOR, E_INVALID_SELECTION, NO_MSG);
+            }
+        }
+        p_SchemeRegs->kgse_ekdv = tmpReg;
+
+        p_LocalExtractsArray = (t_FmPcdKgSchemesExtracts *)XX_Malloc(sizeof(t_FmPcdKgSchemesExtracts));
+        if(!p_LocalExtractsArray)
+            RETURN_ERROR(MAJOR, E_NO_MEMORY, ("No memory"));
+        /*  configure kgse_ekfc and  kgse_gec */
+        knownTmp = 0;
+        for( i=0 ;i<p_KeyAndHash->numOfUsedExtracts ; i++)
+        {
+            p_Extract = &p_KeyAndHash->extractArray[i];
+            switch(p_Extract->type)
+            {
+                case(e_FM_PCD_KG_EXTRACT_PORT_PRIVATE_INFO):
+                    knownTmp |= KG_SCH_KN_PORT_ID;
+                    /* save in driver structure */
+                    p_LocalExtractsArray->extractsArray[i].id = GetKnownFieldId(KG_SCH_KN_PORT_ID);
+                    p_LocalExtractsArray->extractsArray[i].known = TRUE;
+                    break;
+                case(e_FM_PCD_EXTRACT_BY_HDR):
+                    switch(p_Extract->extractParams.extractByHdr.type)
+                    {
+                        case(e_FM_PCD_EXTRACT_FROM_HDR):
+                            generic = TRUE;
+                            /* get the header code for the generic extract */
+                            code = GetGenHdrCode(p_Extract->extractParams.extractByHdr.hdr, p_Extract->extractParams.extractByHdr.hdrIndex, p_Extract->extractParams.extractByHdr.ignoreProtocolValidation);
+                            /* set generic register fields */
+                            offset = p_Extract->extractParams.extractByHdr.extractByHdrType.fromHdr.offset;
+                            size = p_Extract->extractParams.extractByHdr.extractByHdrType.fromHdr.size;
+                            break;
+                        case(e_FM_PCD_EXTRACT_FROM_FIELD):
+                            generic = TRUE;
+                            /* get the field code for the generic extract */
+                            code = GetGenFieldCode(p_Extract->extractParams.extractByHdr.hdr,
+                                        p_Extract->extractParams.extractByHdr.extractByHdrType.fromField.field, p_Extract->extractParams.extractByHdr.ignoreProtocolValidation,p_Extract->extractParams.extractByHdr.hdrIndex);
+                            offset = p_Extract->extractParams.extractByHdr.extractByHdrType.fromField.offset;
+                            size = p_Extract->extractParams.extractByHdr.extractByHdrType.fromField.size;
+                            break;
+                        case(e_FM_PCD_EXTRACT_FULL_FIELD):
+                            if(!p_Extract->extractParams.extractByHdr.ignoreProtocolValidation)
+                            {
+                                /* if we have a known field for it - use it, otherwise use generic */
+                                bitMask = GetKnownProtMask(p_Extract->extractParams.extractByHdr.hdr, p_Extract->extractParams.extractByHdr.hdrIndex,
+                                            p_Extract->extractParams.extractByHdr.extractByHdrType.fullField);
+                                if(bitMask)
+                                {
+                                    knownTmp |= bitMask;
+                                    /* save in driver structure */
+                                    p_LocalExtractsArray->extractsArray[i].id = GetKnownFieldId(bitMask);
+                                    p_LocalExtractsArray->extractsArray[i].known = TRUE;
+                                }
+                                else
+                                    generic = TRUE;
+
+                            }
+                            else
+                                generic = TRUE;
+                            if(generic)
+                            {
+                                /* tmp - till we cover more headers under generic */
+                                RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Full header selection not supported"));
+                                /* get the field code for the generic extract */
+                                code = GetGenFieldCode(p_Extract->extractParams.extractByHdr.hdr,
+                                            p_Extract->extractParams.extractByHdr.extractByHdrType.fullField, p_Extract->extractParams.extractByHdr.ignoreProtocolValidation, p_Extract->extractParams.extractByHdr.hdrIndex);
+                                offset = 0; //GetFieldOffset
+                                size = GetFieldSize(p_Extract->extractParams.extractByHdr.hdr, p_Extract->extractParams.extractByHdr.extractByHdrType.fullField);
+                            }
+                            break;
+                        default:
+                            RETURN_ERROR(MAJOR, E_INVALID_SELECTION, NO_MSG);
+                    }
+                    break;
+                case(e_FM_PCD_EXTRACT_NON_HDR):
+                    /* use generic */
+                    generic = TRUE;
+                    /* get the field code for the generic extract */
+                    code = GetGenCode(p_Extract->extractParams.extractNonHdr.src);
+                    offset = p_Extract->extractParams.extractNonHdr.offset;
+                    size = p_Extract->extractParams.extractNonHdr.size;
+                    break;
+                default:
+                    RETURN_ERROR(MAJOR, E_INVALID_SELECTION, NO_MSG);
+            }
+
+            if(generic)
+            {
+                /* set generic register fields */
+                if(currGenId >= FM_PCD_KG_NUM_OF_GENERIC_REGS)
+                    RETURN_ERROR(MAJOR, E_FULL, ("Generic registers are fully used"));
+                if(!code)
+                    RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, NO_MSG);
+
+                genTmp = KG_SCH_GEN_VALID;
+                genTmp |= (uint32_t)(code << KG_SCH_GEN_HT_SHIFT);
+                genTmp |= offset;
+                if((size > MAX_KG_SCH_SIZE) || (size < 1))
+                      RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal extraction (size out of range)"));
+                genTmp |= (uint32_t)((size - 1) << KG_SCH_GEN_SIZE_SHIFT);
+                swDefault = GetGenericSwDefault(swDefaults, numOfSwDefaults, code);
+                if(swDefault == e_FM_PCD_KG_DFLT_ILLEGAL)
+                    RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal code for sw default"));
+
+                genTmp |= swDefault << KG_SCH_GEN_DEF_SHIFT;
+                genTmp |= KG_SCH_GEN_MASK;
+                p_SchemeRegs->kgse_gec[currGenId] = genTmp;
+                /* save in driver structure */
+                p_LocalExtractsArray->extractsArray[i].id = currGenId++;
+                p_LocalExtractsArray->extractsArray[i].known = FALSE;
+                generic = FALSE;
+            }
+        }
+        p_SchemeRegs->kgse_ekfc = knownTmp;
+
+
+        selectTmp = 0;
+        maskTmp = 0xFFFFFFFF;
+        /*  configure kgse_bmch, kgse_bmcl and kgse_fqb */
+        for( i=0 ;i<p_KeyAndHash->numOfUsedMasks ; i++)
+        {
+            /* Get the relative id of the extract (for known 0-0x1f, for generic 0-7) */
+            id = p_LocalExtractsArray->extractsArray[p_KeyAndHash->masks[i].extractArrayIndex].id;
+            /* Get the shift of the select field (depending on i) */
+            GET_MASK_SEL_SHIFT(shift,i);
+            if (p_LocalExtractsArray->extractsArray[p_KeyAndHash->masks[i].extractArrayIndex].known)
+                selectTmp |= id << shift;
+            else
+                selectTmp |= (id + MASK_FOR_GENERIC_BASE_ID) << shift;
+
+            /* Get the shift of the offset field (depending on i) - may
+               be in  kgse_bmch or in kgse_fqb (depending on i) */
+            GET_MASK_OFFSET_SHIFT(shift,i);
+            if (i<=1)
+                selectTmp |= p_KeyAndHash->masks[i].offset << shift;
+            else
+                fqbTmp |= p_KeyAndHash->masks[i].offset << shift;
+
+            /* Get the shift of the mask field (depending on i) */
+            GET_MASK_SHIFT(shift,i);
+            /* pass all bits */
+            maskTmp |= KG_SCH_BITMASK_MASK << shift;
+            /* clear bits that need masking */
+            maskTmp &= ~(0xFF << shift) ;
+            /* set mask bits */
+            maskTmp |= (p_KeyAndHash->masks[i].mask << shift) ;
+        }
+        p_SchemeRegs->kgse_bmch = selectTmp;
+        p_SchemeRegs->kgse_bmcl = maskTmp;
+        /* kgse_fqb will be written t the end of the routine */
+
+        /*  configure kgse_hc  */
+        if(!p_KeyAndHash->hashDistributionNumOfFqids || !POWER_OF_2(p_KeyAndHash->hashDistributionNumOfFqids))
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("hashDistributionNumOfFqids must not be 0 and must be a power of 2"));
+        if(p_KeyAndHash->hashShift > MAX_HASH_SHIFT)
+             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("hashShift must not be larger than %d", MAX_HASH_SHIFT));
+        if(p_KeyAndHash->hashDistributionFqidsShift > MAX_DIST_FQID_SHIFT)
+             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("hashDistributionFqidsShift must not be larger than %d", MAX_DIST_FQID_SHIFT));
+
+        tmpReg = 0;
+        tmpReg |= ((p_KeyAndHash->hashDistributionNumOfFqids - 1) << p_KeyAndHash->hashDistributionFqidsShift);
+        tmpReg |= p_KeyAndHash->hashShift << KG_SCH_HASH_CONFIG_SHIFT_SHIFT;
+        p_SchemeRegs->kgse_hc = tmpReg;
+
+
+        /* build the return array describing the order of the extractions */
+
+        /* the last currGenId places of the array
+           are for generic extracts that are always last.
+           We now sort for the calculation of the order of the known
+           extractions we sort the known extracts between orderedArray[0] and
+           orderedArray[p_KeyAndHash->numOfUsedExtracts - currGenId - 1].
+           for the calculation of the order of the generic extractions we use:
+           num_of_generic - currGenId
+           num_of_known - p_KeyAndHash->numOfUsedExtracts - currGenId
+           first_generic_index = num_of_known */
+        curr = 0;
+        for (i=0;i<p_KeyAndHash->numOfUsedExtracts ; i++)
+        {
+            if(p_LocalExtractsArray->extractsArray[i].known)
+            {
+                ASSERT_COND(curr<(p_KeyAndHash->numOfUsedExtracts - currGenId));
+                j = curr;
+                /* id is the extract id (port id = 0, mac src = 1 etc.). the value in the array is the original
+                index in the user's extractions array */
+                /* we compare the id of the current extract with the id of the extract in the orderedArray[j-1]
+                location */
+                while(p_LocalExtractsArray->extractsArray[i].id < p_LocalExtractsArray->extractsArray[orderedArray[j-1]].id && j>0)
+                {
+                    orderedArray[j] = orderedArray[j-1];
+                    j--;
+                }
+                orderedArray[j] = (uint8_t)i;
+                curr++;
+            }
+            else
+                /* index is first_generic_index + generic index (id) */
+                orderedArray[p_KeyAndHash->numOfUsedExtracts - currGenId + p_LocalExtractsArray->extractsArray[i].id]= (uint8_t)i;
+
+        }
+        XX_Free(p_LocalExtractsArray);
+        p_LocalExtractsArray = NULL;
+        memcpy(p_OrderedArray, &orderedArray, sizeof(orderedArray));
+
+    }
+    else
+    {
+        /* clear all unused registers: */
+        p_SchemeRegs->kgse_ekfc = 0;
+        p_SchemeRegs->kgse_ekdv = 0;
+        p_SchemeRegs->kgse_bmch = 0;
+        p_SchemeRegs->kgse_bmcl = 0;
+        p_SchemeRegs->kgse_hc = 0;
+        p_SchemeRegs->kgse_dv0 = 0;
+        p_SchemeRegs->kgse_dv1 = 0;
+    }
+
+    /*  configure kgse_spc  */
+    if( p_Scheme->schemeCounter.update)
+        p_SchemeRegs->kgse_spc = p_Scheme->schemeCounter.value;
+
+
+    /* check that are enough generic registers */
+    if(p_Scheme->numOfUsedFqidMasks + currGenId > FM_PCD_KG_NUM_OF_GENERIC_REGS)
+        RETURN_ERROR(MAJOR, E_FULL, ("Generic registers are fully used"));
+
+    /* extracted OR mask on Qid */
+    for( i=0 ;i<p_Scheme->numOfUsedFqidMasks ; i++)
+    {
+
+        /*  configure kgse_gec[i]  */
+        p_ExtractOr = &p_Scheme->fqidMasks[i];
+        switch(p_ExtractOr->type)
+        {
+            case(e_FM_PCD_KG_EXTRACT_PORT_PRIVATE_INFO):
+                code = KG_SCH_GEN_PARSE_RESULT;
+                offset = 0;
+                break;
+            case(e_FM_PCD_EXTRACT_BY_HDR):
+                /* get the header code for the generic extract */
+                code = GetGenHdrCode(p_ExtractOr->extractParams.extractByHdr.hdr, p_ExtractOr->extractParams.extractByHdr.hdrIndex, p_ExtractOr->extractParams.extractByHdr.ignoreProtocolValidation);
+                /* set generic register fields */
+                offset = p_ExtractOr->extractionOffset;
+                break;
+            case(e_FM_PCD_EXTRACT_NON_HDR):
+                /* get the field code for the generic extract */
+                code = GetGenCode(p_ExtractOr->extractParams.src);
+                offset = p_ExtractOr->extractionOffset;
+                break;
+            default:
+                RETURN_ERROR(MAJOR, E_INVALID_SELECTION, NO_MSG);
+        }
+
+        /* set generic register fields */
+        if(!code)
+            RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, NO_MSG);
+        genTmp = KG_SCH_GEN_EXTRACT_TYPE | KG_SCH_GEN_VALID;
+        genTmp |= (uint32_t)(code << KG_SCH_GEN_HT_SHIFT);
+        genTmp |= offset;
+        if(p_ExtractOr->bitOffsetInFqid > MAX_KG_SCH_BIT_OFFSET )
+              RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal extraction (bitOffsetInFqid out of range)"));
+        genTmp |= (uint32_t)(p_ExtractOr->bitOffsetInFqid << KG_SCH_GEN_SIZE_SHIFT);
+        genTmp |= (uint32_t)(p_ExtractOr->extractionOffset << KG_SCH_GEN_DEF_SHIFT);
+        /* pass all bits */
+        genTmp |= KG_SCH_GEN_MASK;
+        /* clear bits that need masking */
+        genTmp &= ~(0xFF << KG_SCH_GEN_MASK_SHIFT) ;
+        /* set mask bits */
+        genTmp |= (uint32_t)(p_ExtractOr->mask << KG_SCH_GEN_MASK_SHIFT);
+        p_SchemeRegs->kgse_gec[currGenId++] = genTmp;
+
+    }
+    /* clear all unused GEC registers */
+    for( i=currGenId ;i<FM_PCD_KG_NUM_OF_GENERIC_REGS ; i++)
+        p_SchemeRegs->kgse_gec[i] = 0;
+
+    /* add base Qid for this scheme */
+    /* add configuration for kgse_fqb */
+    if(p_Scheme->baseFqid & ~0x00FFFFFF)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("baseFqid must be between 1 and 2^24-1"));
+
+    fqbTmp |= p_Scheme->baseFqid;
+    p_SchemeRegs->kgse_fqb = fqbTmp;
+
+    return E_OK;
+}
+
+void  FmPcdKgValidateSchemeSw(t_Handle h_FmPcd, uint8_t schemeId)
+{
+    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
+
+    ASSERT_COND(!p_FmPcd->p_FmPcdKg->schemes[schemeId].valid);
+
+    FmPcdIncNetEnvOwners(p_FmPcd, p_FmPcd->p_FmPcdKg->schemes[schemeId].netEnvId);
+    p_FmPcd->p_FmPcdKg->schemes[schemeId].valid = TRUE;
+}
+
+void  FmPcdKgInvalidateSchemeSw(t_Handle h_FmPcd, uint8_t schemeId)
+{
+
+    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
+
+    FmPcdDecNetEnvOwners(h_FmPcd, p_FmPcd->p_FmPcdKg->schemes[schemeId].netEnvId);
+    p_FmPcd->p_FmPcdKg->schemes[schemeId].valid = FALSE;
+}
+
+t_Error FmPcdKgCheckInvalidateSchemeSw(t_Handle h_FmPcd, uint8_t schemeId)
+{
+    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
+
+   /* check that no port is bound to this scheme */
+    if(p_FmPcd->p_FmPcdKg->schemes[schemeId].owners)
+       RETURN_ERROR(MINOR, E_INVALID_STATE, ("Trying to delete a scheme that has ports bound to"));
+    if(!p_FmPcd->p_FmPcdKg->schemes[schemeId].valid)
+       RETURN_ERROR(MINOR, E_INVALID_STATE, ("Trying to delete an invalid scheme"));
+    return E_OK;
+}
+
+uint32_t FmPcdKgBuildCppReg(t_Handle h_FmPcd, uint8_t clsPlanGrpId)
+{
+    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    uint32_t    tmpKgpeCpp;
+
+    tmpKgpeCpp = (uint32_t)(p_FmPcd->p_FmPcdKg->clsPlanGrps[clsPlanGrpId].baseEntry / 8);
+    tmpKgpeCpp |= (uint32_t)(((p_FmPcd->p_FmPcdKg->clsPlanGrps[clsPlanGrpId].sizeOfGrp / 8) - 1) << FM_PCD_KG_PE_CPP_MASK_SHIFT);
+    return tmpKgpeCpp;
+}
+
+bool    FmPcdKgHwSchemeIsValid(uint32_t schemeModeReg)
+{
+
+    if(schemeModeReg & KG_SCH_MODE_EN)
+        return TRUE;
+    else
+        return FALSE;
+}
+
+uint32_t    FmPcdKgBuildWriteSchemeActionReg(uint8_t schemeId, bool updateCounter)
+{
+    return     (uint32_t)((schemeId << FM_PCD_KG_KGAR_NUM_SHIFT)|
+                            FM_PCD_KG_KGAR_GO |
+                            FM_PCD_KG_KGAR_WRITE |
+                            FM_PCD_KG_KGAR_SEL_SCHEME_ENTRY |
+                            DUMMY_PORT_ID |
+                            (updateCounter ? FM_PCD_KG_KGAR_SCHEME_WSEL_UPDATE_CNT:0));
+
+}
+
+uint32_t    FmPcdKgBuildReadSchemeActionReg(uint8_t schemeId)
+{
+    return     (uint32_t)((schemeId << FM_PCD_KG_KGAR_NUM_SHIFT)|
+                            FM_PCD_KG_KGAR_GO |
+                            FM_PCD_KG_KGAR_READ |
+                            FM_PCD_KG_KGAR_SEL_SCHEME_ENTRY |
+                            DUMMY_PORT_ID |
+                            FM_PCD_KG_KGAR_SCHEME_WSEL_UPDATE_CNT);
+
+}
+
+
+uint32_t    FmPcdKgBuildWriteClsPlanBlockActionReg(uint8_t grpId)
+{
+    return (uint32_t)(FM_PCD_KG_KGAR_GO |
+                        FM_PCD_KG_KGAR_WRITE |
+                        FM_PCD_KG_KGAR_SEL_CLS_PLAN_ENTRY |
+                        DUMMY_PORT_ID |
+                        (grpId << FM_PCD_KG_KGAR_NUM_SHIFT) |
+                        FM_PCD_KG_KGAR_WSEL_MASK);
+
+
+        /* if we ever want to write 1 by 1, use:
+        sel = (uint8_t)(0x01 << (7- (entryId % CLS_PLAN_NUM_PER_GRP)));*/
+}
+
+uint32_t    FmPcdKgBuildReadClsPlanBlockActionReg(uint8_t grpId)
+{
+    return (uint32_t)(FM_PCD_KG_KGAR_GO |
+                        FM_PCD_KG_KGAR_READ |
+                        FM_PCD_KG_KGAR_SEL_CLS_PLAN_ENTRY |
+                        DUMMY_PORT_ID |
+                        (grpId << FM_PCD_KG_KGAR_NUM_SHIFT) |
+                        FM_PCD_KG_KGAR_WSEL_MASK);
+
+
+        /* if we ever want to write 1 by 1, use:
+        sel = (uint8_t)(0x01 << (7- (entryId % CLS_PLAN_NUM_PER_GRP)));*/
+}
+
+uint32_t        FmPcdKgBuildWritePortSchemeBindActionReg(uint8_t hardwarePortId)
+{
+
+    return (uint32_t)(FM_PCD_KG_KGAR_GO |
+                        FM_PCD_KG_KGAR_WRITE |
+                        FM_PCD_KG_KGAR_SEL_PORT_ENTRY |
+                        hardwarePortId |
+                        FM_PCD_KG_KGAR_SEL_PORT_WSEL_SP);
+}
+
+uint32_t        FmPcdKgBuildReadPortSchemeBindActionReg(uint8_t hardwarePortId)
+{
+
+    return (uint32_t)(FM_PCD_KG_KGAR_GO |
+                        FM_PCD_KG_KGAR_READ |
+                        FM_PCD_KG_KGAR_SEL_PORT_ENTRY |
+                        hardwarePortId |
+                        FM_PCD_KG_KGAR_SEL_PORT_WSEL_SP);
+}
+uint32_t        FmPcdKgBuildWritePortClsPlanBindActionReg(uint8_t hardwarePortId)
+{
+
+    return (uint32_t)(FM_PCD_KG_KGAR_GO |
+                        FM_PCD_KG_KGAR_WRITE |
+                        FM_PCD_KG_KGAR_SEL_PORT_ENTRY |
+                        hardwarePortId |
+                        FM_PCD_KG_KGAR_SEL_PORT_WSEL_CPP);
+}
+
+uint8_t FmPcdKgGetClsPlanGrpBase(t_Handle h_FmPcd, uint8_t clsPlanGrp)
+{
+    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
+
+    return p_FmPcd->p_FmPcdKg->clsPlanGrps[clsPlanGrp].baseEntry;
+}
+
+uint16_t FmPcdKgGetClsPlanGrpSize(t_Handle h_FmPcd, uint8_t clsPlanGrp)
+{
+    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
+
+    return p_FmPcd->p_FmPcdKg->clsPlanGrps[clsPlanGrp].sizeOfGrp;
+}
+
+uint8_t FmPcdKgGetSchemeSwId(t_Handle h_FmPcd, uint8_t schemeHwId)
+{
+    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    uint8_t     i;
+
+    for(i=0;i<p_FmPcd->p_FmPcdKg->numOfSchemes;i++)
+        if(p_FmPcd->p_FmPcdKg->schemesIds[i] == schemeHwId)
+            return i;
+    ASSERT_COND(i!=p_FmPcd->p_FmPcdKg->numOfSchemes);
+    return FM_PCD_KG_NUM_OF_SCHEMES;
+}
+
+bool FmPcdKgIsEmptyClsPlanGrp(t_Handle h_FmPcd)
+{
+    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
+
+    return p_FmPcd->p_FmPcdKg->isDriverEmptyClsPlanGrp;
+}
+
+uint8_t FmPcdKgGetEmptyClsPlanGrpId(t_Handle h_FmPcd)
+{
+    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
+
+    return p_FmPcd->p_FmPcdKg->emptyClsPlanGrpId;
+}
+
+uint8_t FmPcdKgGetNumOfPartitionSchemes(t_Handle h_FmPcd)
+{
+    return ((t_FmPcd*)h_FmPcd)->p_FmPcdKg->numOfSchemes;
+}
+
+uint8_t FmPcdKgGetPhysicalSchemeId(t_Handle h_FmPcd, uint8_t relativeSchemeId)
+{
+    return ((t_FmPcd*)h_FmPcd)->p_FmPcdKg->schemesIds[relativeSchemeId];
+}
+
+uint8_t FmPcdKgGetRelativeSchemeId(t_Handle h_FmPcd, uint8_t schemeId)
+{
+    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    uint8_t     i;
+
+    for(i = 0;i<p_FmPcd->p_FmPcdKg->numOfSchemes;i++)
+        if(p_FmPcd->p_FmPcdKg->schemesIds[i] == schemeId)
+            return i;
+
+    if(i == p_FmPcd->p_FmPcdKg->numOfSchemes)
+        REPORT_ERROR(MAJOR, E_NOT_IN_RANGE, ("Scheme is out of partition range"));
+
+    return FM_PCD_KG_NUM_OF_SCHEMES;
+}
+
+t_Error FmPcdKgSchemeTryLock(t_Handle h_FmPcd, uint8_t schemeId)
+{
+    TRY_LOCK_RET_ERR(((t_FmPcd*)h_FmPcd)->p_FmPcdKg->schemes[schemeId].lock);
+
+    return E_OK;
+}
+
+void FmPcdKgReleaseSchemeLock(t_Handle h_FmPcd, uint8_t schemeId)
+{
+    RELEASE_LOCK(((t_FmPcd*)h_FmPcd)->p_FmPcdKg->schemes[schemeId].lock);
+}
+
+/****************************************/
+/*  API routines                        */
+/****************************************/
+t_Error FM_PCD_KgSetAdditionalDataAfterParsing(t_Handle h_FmPcd, uint8_t payloadOffset)
+{
+   t_FmPcd              *p_FmPcd = (t_FmPcd*)h_FmPcd;
+   t_FmPcdKgRegs        *p_Regs = p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdKg, E_INVALID_HANDLE);
+
+    if(payloadOffset >  256)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("data exatraction offset from parseing end can not be more than 256"));
+
+    WRITE_UINT32(p_Regs->kgfdor,payloadOffset);
+
+    return E_OK;
+}
+
+t_Error FM_PCD_KgSetDfltValue(t_Handle h_FmPcd, uint8_t valueId, uint32_t value)
+{
+   t_FmPcd              *p_FmPcd = (t_FmPcd*)h_FmPcd;
+   t_FmPcdKgRegs        *p_Regs = p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(((valueId == 0) || (valueId == 1)), E_INVALID_VALUE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdKg, E_INVALID_HANDLE);
+
+    if(valueId == 0)
+        WRITE_UINT32(p_Regs->kggdv0r,value);
+    else
+        WRITE_UINT32(p_Regs->kggdv1r,value);
+    return E_OK;
+}
+
+t_Error FM_PCD_KgSetEmptyClsPlanGrp(t_Handle h_FmPcd)
+{
+    t_FmPcd                     *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    t_FmPcdKgClsPlanGrpParams   clsPlanGrp;
+    t_Handle                    h_ClsPlanFrp;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdKg, E_INVALID_HANDLE);
+
+    p_FmPcd->p_FmPcdKg->isDriverEmptyClsPlanGrp = TRUE;
+
+    /* prepare a clsPlan group for all ports that are not using the clsPlan mechanism */
+    clsPlanGrp.h_NetEnv = CAST_UINT32_TO_POINTER((uint32_t)DRIVER_PRIVATE_NET_ENV_ID+1);
+    clsPlanGrp.numOfOptions = 0;
+    h_ClsPlanFrp = FM_PCD_KgSetClsPlanGrp(p_FmPcd, &clsPlanGrp);
+    if(!h_ClsPlanFrp)
+        RETURN_ERROR(MAJOR, E_INVALID_HANDLE, NO_MSG);
+    p_FmPcd->p_FmPcdKg->emptyClsPlanGrpId = (uint8_t)(CAST_POINTER_TO_UINT32(h_ClsPlanFrp)-1);
+
+    return E_OK;
+}
+
+t_Error FM_PCD_KgDeleteEmptyClsPlanGrp(t_Handle h_FmPcd)
+{
+   t_FmPcd  *p_FmPcd = (t_FmPcd*)h_FmPcd;
+   t_Error  err;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdKg, E_INVALID_HANDLE);
+
+    p_FmPcd->p_FmPcdKg->isDriverEmptyClsPlanGrp = FALSE;
+
+    err = FM_PCD_KgDeleteClsPlanGrp(p_FmPcd, CAST_UINT32_TO_POINTER((uint32_t)(p_FmPcd->p_FmPcdKg->emptyClsPlanGrpId+1)));
+    if(err)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+
+    return E_OK;
+}
+
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+t_Error FM_PCD_KgDumpRegs(t_Handle h_FmPcd)
+{
+    t_FmPcd             *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    int                 i = 0, j = 0;
+    uint8_t             hardwarePortId;
+    uint32_t            tmpKgarReg;
+    uint8_t             portsTable[] = PCD_PORTS_TABLE;
+    t_Error             err;
+
+    DECLARE_DUMP;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdKg, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE);
+
+    DUMP_SUBTITLE(("\n"));
+    DUMP_TITLE(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs, ("FmPcdKgRegs Regs"));
+
+    DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,kggcr);
+    DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,kgeer);
+    DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,kgeeer);
+    DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,kgseer);
+    DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,kgseeer);
+    DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,kggsr);
+    DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,kgtpc);
+    DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,kgserc);
+    DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,kgfdor);
+    DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,kggdv0r);
+    DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,kggdv1r);
+    DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,kgfer);
+    DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,kgfeer);
+    DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,kgar);
+
+    DUMP_SUBTITLE(("\n"));
+    for(j = 0;j<FM_PCD_KG_NUM_OF_SCHEMES;j++)
+    {
+        tmpKgarReg = FmPcdKgBuildReadSchemeActionReg((uint8_t)j);
+        WriteKgarWait(p_FmPcd, tmpKgarReg);
+
+        DUMP_TITLE(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs, ("FmPcdKgIndirectAccessSchemeRegs Scheme %d Regs", j));
+
+        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs,kgse_mode);
+        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs,kgse_ekfc);
+        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs,kgse_ekdv);
+        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs,kgse_bmch);
+        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs,kgse_bmcl);
+        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs,kgse_fqb);
+        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs,kgse_hc);
+        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs,kgse_ppc);
+
+        DUMP_TITLE(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs.kgse_gec, ("kgse_gec"));
+        DUMP_SUBSTRUCT_ARRAY(i, FM_PCD_KG_NUM_OF_GENERIC_REGS)
+        {
+            DUMP_MEMORY(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs.kgse_gec[i], sizeof(uint32_t));
+        }
+
+        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs,kgse_spc);
+        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs,kgse_dv0);
+        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs,kgse_dv1);
+        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs,kgse_ccbs);
+        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs,kgse_mv);
+    }
+    DUMP_SUBTITLE(("\n"));
+
+    for (i=0;i<PCD_MAX_NUM_OF_PORTS;i++)
+    {
+
+        GET_GLOBAL_PORTID_FROM_PCD_PORTS_TABLE(hardwarePortId, portsTable,i);
+
+        tmpKgarReg = FmPcdKgBuildReadPortSchemeBindActionReg(hardwarePortId);
+
+        err = WriteKgarWait(p_FmPcd, tmpKgarReg);
+        if(err)
+            RETURN_ERROR(MINOR, err, NO_MSG);
+
+        DUMP_TITLE(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.portRegs, ("FmPcdKgIndirectAccessPortRegs PCD Port %d regs", hardwarePortId));
+
+        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.portRegs, kgoe_sp);
+        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.portRegs, kgoe_cpp);
+
+    }
+
+    DUMP_SUBTITLE(("\n"));
+    for(j=0;j<FM_PCD_MAX_NUM_OF_CLS_PLANS/CLS_PLAN_NUM_PER_GRP;j++)
+    {
+        DUMP_TITLE(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.clsPlanRegs, ("FmPcdKgIndirectAccessClsPlanRegs Regs group %d", j));
+        DUMP_TITLE(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.clsPlanRegs.kgcpe, ("kgcpe"));
+
+        tmpKgarReg = FmPcdKgBuildReadClsPlanBlockActionReg((uint8_t)j);
+        err = WriteKgarWait(p_FmPcd, tmpKgarReg);
+        if(err)
+            RETURN_ERROR(MINOR, err, NO_MSG);
+        DUMP_SUBSTRUCT_ARRAY(i, 8)
+            DUMP_MEMORY(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.clsPlanRegs.kgcpe[i], sizeof(uint32_t));
+    }
+    return E_OK;
+}
+#endif /* (defined(DEBUG_ERRORS) && ... */
+#endif /* !CONFIG_GUEST_PARTITION */
+
+
+t_Handle FM_PCD_KgSetScheme(t_Handle h_FmPcd,  t_FmPcdKgSchemeParams *p_Scheme)
+{
+    t_FmPcd                             *p_FmPcd = (t_FmPcd*)h_FmPcd;
+#ifndef CONFIG_MULTI_PARTITION_SUPPORT
+    uint32_t                            tmpReg;
+    t_FmPcdKgInterModuleSchemeRegs      schemeRegs;
+    t_FmPcdKgInterModuleSchemeRegs      *p_MemRegs;
+    uint8_t                             i;
+    t_Error                             err;
+    uint32_t                            tmpKgarReg;
+    uint8_t                             physicalSchemeId, relativeSchemeId;
+#endif /* !CONFIG_MULTI_PARTITION_SUPPORT */
+
+    SANITY_CHECK_RETURN_VALUE(p_FmPcd, E_INVALID_HANDLE, NULL);
+    SANITY_CHECK_RETURN_VALUE(p_FmPcd->p_FmPcdKg, E_INVALID_HANDLE, NULL);
+    SANITY_CHECK_RETURN_VALUE(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE, NULL);
+
+    if (p_FmPcd->h_Hc)
+        return FmHcPcdKgSetScheme(p_FmPcd->h_Hc, p_Scheme);
+#ifdef CONFIG_MULTI_PARTITION_SUPPORT
+    else
+    {
+        REPORT_ERROR(MAJOR, E_INVALID_HANDLE, ("No HC obj. must have HC in guest partition!"));
+        return NULL;
+    }
+
+#else
+
+    TRY_LOCK_RET_NULL(p_FmPcd->lock);
+
+    /* if not called for modification, check first that this scheme is unused */
+    if(!p_Scheme->modify)
+    {
+        /* check that schameId is in range */
+        if(p_Scheme->id.relativeSchemeId >= p_FmPcd->p_FmPcdKg->numOfSchemes)
+        {
+            REPORT_ERROR(MAJOR, E_NOT_IN_RANGE, ("Scheme is out of range"));
+            RELEASE_LOCK(p_FmPcd->lock);
+            return NULL;
+        }
+        relativeSchemeId = p_Scheme->id.relativeSchemeId;
+
+        TRY_LOCK_RET_NULL(p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].lock);
+        RELEASE_LOCK(p_FmPcd->lock);
+
+        physicalSchemeId = p_FmPcd->p_FmPcdKg->schemesIds[relativeSchemeId];
+
+        /* read specified scheme into scheme registers */
+        tmpKgarReg = FmPcdKgBuildReadSchemeActionReg(physicalSchemeId);
+        WriteKgarWait(p_FmPcd, tmpKgarReg);
+        tmpReg = GET_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs.kgse_mode);
+        if (tmpReg & KG_SCH_MODE_EN)
+        {
+            REPORT_ERROR(MAJOR, E_ALREADY_EXISTS, ("Scheme is already used"));
+            RELEASE_LOCK(p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].lock);
+            return NULL;
+        }
+
+    }
+    else
+    {
+        physicalSchemeId = (uint8_t)(CAST_POINTER_TO_UINT32(p_Scheme->id.h_Scheme)-1);
+        relativeSchemeId = FmPcdKgGetRelativeSchemeId(p_FmPcd, physicalSchemeId);
+
+        TRY_LOCK_RET_NULL(p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].lock);
+        RELEASE_LOCK(p_FmPcd->lock);
+
+        if(relativeSchemeId == FM_PCD_KG_NUM_OF_SCHEMES)
+        {
+            REPORT_ERROR(MAJOR, E_NOT_IN_RANGE, NO_MSG);
+            RELEASE_LOCK(p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].lock);
+            return NULL;
+        }
+    }
+
+    err = FmPcdKgBuildScheme(h_FmPcd, p_Scheme, &schemeRegs, &p_Scheme->orderedArray);
+    if(err)
+    {
+        REPORT_ERROR(MAJOR, err, NO_MSG);
+        FmPcdKgInvalidateSchemeSw(h_FmPcd, relativeSchemeId);
+        RELEASE_LOCK(p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].lock);
+        return NULL;
+    }
+
+    /* configure all 21 scheme registers */
+    p_MemRegs = &p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs;
+    WRITE_UINT32(p_MemRegs->kgse_ppc, schemeRegs.kgse_ppc);
+    WRITE_UINT32(p_MemRegs->kgse_ccbs, schemeRegs.kgse_ccbs);
+    WRITE_UINT32(p_MemRegs->kgse_mode, schemeRegs.kgse_mode);
+    WRITE_UINT32(p_MemRegs->kgse_mv, schemeRegs.kgse_mv);
+    WRITE_UINT32(p_MemRegs->kgse_dv0, schemeRegs.kgse_dv0);
+    WRITE_UINT32(p_MemRegs->kgse_dv1, schemeRegs.kgse_dv1);
+    WRITE_UINT32(p_MemRegs->kgse_ekdv, schemeRegs.kgse_ekdv);
+    WRITE_UINT32(p_MemRegs->kgse_ekfc, schemeRegs.kgse_ekfc);
+    WRITE_UINT32(p_MemRegs->kgse_bmch, schemeRegs.kgse_bmch);
+    WRITE_UINT32(p_MemRegs->kgse_bmcl, schemeRegs.kgse_bmcl);
+    WRITE_UINT32(p_MemRegs->kgse_hc, schemeRegs.kgse_hc);
+    WRITE_UINT32(p_MemRegs->kgse_spc, schemeRegs.kgse_spc);
+    WRITE_UINT32(p_MemRegs->kgse_fqb, schemeRegs.kgse_fqb);
+    for(i=0 ; i<FM_PCD_KG_NUM_OF_GENERIC_REGS ; i++)
+        WRITE_UINT32(p_MemRegs->kgse_gec[i], schemeRegs.kgse_gec[i]);
+
+    /* call indirect command for scheme write */
+    tmpKgarReg = FmPcdKgBuildWriteSchemeActionReg(physicalSchemeId, p_Scheme->schemeCounter.update);
+
+    WriteKgarWait(p_FmPcd, tmpKgarReg);
+
+    FmPcdKgValidateSchemeSw(h_FmPcd, relativeSchemeId);
+
+    RELEASE_LOCK(p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].lock);
+
+    return CAST_UINT32_TO_POINTER((uint32_t)physicalSchemeId+1);
+#endif /* CONFIG_MULTI_PARTITION_SUPPORT */
+}
+
+t_Error  FM_PCD_KgDeleteScheme(t_Handle h_FmPcd, t_Handle h_Scheme)
+{
+    t_FmPcd             *p_FmPcd = (t_FmPcd*)h_FmPcd;
+#ifndef CONFIG_MULTI_PARTITION_SUPPORT
+    uint8_t             physicalSchemeId;
+    uint32_t            tmpKgarReg;
+    t_Error             err;
+    uint8_t             relativeSchemeId;
+#endif /* !CONFIG_MULTI_PARTITION_SUPPORT */
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdKg, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE);
+
+    if (p_FmPcd->h_Hc)
+        return FmHcPcdKgDeleteScheme(p_FmPcd->h_Hc, h_Scheme);
+#ifdef CONFIG_MULTI_PARTITION_SUPPORT
+    else
+        RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("No HC obj. must have HC in guest partition!"));
+
+#else
+
+    physicalSchemeId = (uint8_t)(CAST_POINTER_TO_UINT32(h_Scheme)-1);
+    relativeSchemeId = FmPcdKgGetRelativeSchemeId(p_FmPcd, physicalSchemeId);
+
+    TRY_LOCK_RET_ERR(p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].lock);
+
+    if(relativeSchemeId == FM_PCD_KG_NUM_OF_SCHEMES)
+        REPORT_ERROR(MAJOR, E_NOT_IN_RANGE, NO_MSG);
+
+    /* check that no port is bound to this scheme */
+    err = FmPcdKgCheckInvalidateSchemeSw(h_FmPcd, relativeSchemeId);
+    if(err)
+       RETURN_ERROR(MINOR, err, NO_MSG);
+
+    /* clear mode register, including enable bit */
+    WRITE_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs.kgse_mode, 0);
+
+    /* call indirect command for scheme write */
+    tmpKgarReg = FmPcdKgBuildWriteSchemeActionReg(physicalSchemeId, FALSE);
+
+    WriteKgarWait(p_FmPcd, tmpKgarReg);
+
+    FmPcdKgInvalidateSchemeSw(h_FmPcd, relativeSchemeId);
+
+    RELEASE_LOCK(p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].lock);
+
+    return E_OK;
+#endif /* CONFIG_MULTI_PARTITION_SUPPORT */
+}
+
+t_Handle FM_PCD_KgSetClsPlanGrp(t_Handle h_FmPcd, t_FmPcdKgClsPlanGrpParams *p_Grp)
+{
+    t_FmPcd                         *p_FmPcd = (t_FmPcd*)h_FmPcd;
+#ifndef CONFIG_MULTI_PARTITION_SUPPORT
+    t_FmPcdKgInterModuleClsPlanSet  clsPlanSet;
+    t_Handle                        h_ClsPlanGrp;
+#endif /* !CONFIG_MULTI_PARTITION_SUPPORT */
+
+    if (p_FmPcd->h_Hc)
+        return FmHcPcdKgSetClsPlanGrp(p_FmPcd->h_Hc, p_Grp);
+#ifdef CONFIG_MULTI_PARTITION_SUPPORT
+    else
+    {
+        REPORT_ERROR(MAJOR, E_INVALID_HANDLE, ("No HC obj. must have HC in guest partition!"));
+        return NULL;
+    }
+#else
+    h_ClsPlanGrp = FmPcdKgBuildClsPlanGrp(p_FmPcd, p_Grp, &clsPlanSet);
+    if(!h_ClsPlanGrp)
+    {
+        REPORT_ERROR(MAJOR, E_INVALID_HANDLE, NO_MSG);
+        return NULL;
+    }
+
+    /* write clsPlan entries to memory */
+    KgSetClsPlan(p_FmPcd, &clsPlanSet);
+
+
+    return h_ClsPlanGrp;
+#endif /* CONFIG_MULTI_PARTITION_SUPPORT */
+}
+
+t_Error FM_PCD_KgDeleteClsPlanGrp(t_Handle h_FmPcd, t_Handle h_ClsPlanGrp)
+{
+    t_FmPcd                         *p_FmPcd = (t_FmPcd*)h_FmPcd;
+#ifndef CONFIG_MULTI_PARTITION_SUPPORT
+    uint8_t                         grpId = (uint8_t)(CAST_POINTER_TO_UINT32(h_ClsPlanGrp)-1);
+    t_FmPcdKgInterModuleClsPlanSet  clsPlanSet;
+#endif /* !CONFIG_MULTI_PARTITION_SUPPORT */
+
+    if (p_FmPcd->h_Hc)
+        return FmHcPcdKgDeleteClsPlanGrp(p_FmPcd->h_Hc, h_ClsPlanGrp);
+#ifdef CONFIG_MULTI_PARTITION_SUPPORT
+    else
+        RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("No HC obj. must have HC in guest partition!"));
+
+#else
+    /* clear clsPlan entries in memory */
+    clsPlanSet.baseEntry = p_FmPcd->p_FmPcdKg->clsPlanGrps[grpId].baseEntry;
+    clsPlanSet.numOfClsPlanEntries = p_FmPcd->p_FmPcdKg->clsPlanGrps[grpId].sizeOfGrp;
+    memset(clsPlanSet.vectors, 0, p_FmPcd->p_FmPcdKg->clsPlanGrps[grpId].sizeOfGrp*sizeof(uint32_t));
+    KgSetClsPlan(p_FmPcd, &clsPlanSet );
+
+    FmPcdKgDestroyClsPlanGrp(h_FmPcd, grpId);
+
+    return E_OK;
+#endif /* CONFIG_MULTI_PARTITION_SUPPORT */
+}
+
+uint32_t  FM_PCD_KgGetSchemeCounter(t_Handle h_FmPcd, t_Handle h_Scheme)
+{
+    t_FmPcd             *p_FmPcd = (t_FmPcd*)h_FmPcd;
+#ifndef CONFIG_MULTI_PARTITION_SUPPORT
+    uint32_t            tmpKgarReg;
+    uint8_t             physicalSchemeId;
+#endif /* !CONFIG_MULTI_PARTITION_SUPPORT */
+
+    SANITY_CHECK_RETURN_VALUE(h_FmPcd, E_INVALID_HANDLE, 0);
+    SANITY_CHECK_RETURN_VALUE(p_FmPcd->p_FmPcdKg, E_INVALID_HANDLE, 0);
+    SANITY_CHECK_RETURN_VALUE(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE, 0);
+
+    if (p_FmPcd->h_Hc)
+        return FmHcPcdKgGetSchemeCounter(p_FmPcd->h_Hc, h_Scheme);
+#ifdef CONFIG_MULTI_PARTITION_SUPPORT
+    else
+        RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("No HC obj. must have HC in guest partition!"));
+
+#else
+    physicalSchemeId = (uint8_t)(CAST_POINTER_TO_UINT32(h_Scheme)-1);
+
+    if(FmPcdKgGetRelativeSchemeId(p_FmPcd, physicalSchemeId) == FM_PCD_KG_NUM_OF_SCHEMES)
+        REPORT_ERROR(MAJOR, E_NOT_IN_RANGE, NO_MSG);
+
+    tmpKgarReg = FmPcdKgBuildReadSchemeActionReg(physicalSchemeId);
+    WriteKgarWait(p_FmPcd, tmpKgarReg);
+    if (!(GET_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs.kgse_mode) & KG_SCH_MODE_EN))
+       REPORT_ERROR(MAJOR, E_ALREADY_EXISTS, ("Scheme is Invalid"));
+
+    return GET_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs.kgse_spc);
+#endif /* CONFIG_MULTI_PARTITION_SUPPORT */
+}
+
+t_Error  FM_PCD_KgSetSchemeCounter(t_Handle h_FmPcd, t_Handle h_Scheme, uint32_t value)
+{
+    t_FmPcd             *p_FmPcd = (t_FmPcd*)h_FmPcd;
+#ifndef CONFIG_MULTI_PARTITION_SUPPORT
+    uint32_t            tmpKgarReg;
+    uint8_t             physicalSchemeId;
+#endif /* !CONFIG_MULTI_PARTITION_SUPPORT */
+
+    SANITY_CHECK_RETURN_VALUE(h_FmPcd, E_INVALID_HANDLE, 0);
+    SANITY_CHECK_RETURN_VALUE(p_FmPcd->p_FmPcdKg, E_INVALID_HANDLE, 0);
+    SANITY_CHECK_RETURN_VALUE(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE, 0);
+
+    if (p_FmPcd->h_Hc)
+        return FmHcPcdKgSetSchemeCounter(p_FmPcd->h_Hc, h_Scheme, value);
+#ifdef CONFIG_MULTI_PARTITION_SUPPORT
+    else
+        RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("No HC obj. must have HC in guest partition!"));
+
+#else
+    physicalSchemeId = (uint8_t)(CAST_POINTER_TO_UINT32(h_Scheme)-1);
+    /* check that schameId is in range */
+    if(FmPcdKgGetRelativeSchemeId(p_FmPcd, physicalSchemeId) == FM_PCD_KG_NUM_OF_SCHEMES)
+        REPORT_ERROR(MAJOR, E_NOT_IN_RANGE, NO_MSG);
+
+    /* read specified scheme into scheme registers */
+    tmpKgarReg = FmPcdKgBuildReadSchemeActionReg(physicalSchemeId);
+    WriteKgarWait(p_FmPcd, tmpKgarReg);
+    if (!(GET_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs.kgse_mode) & KG_SCH_MODE_EN))
+       RETURN_ERROR(MAJOR, E_ALREADY_EXISTS, ("Scheme is Invalid"));
+
+    /* change counter value */
+    WRITE_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs.kgse_spc, value);
+
+    /* call indirect command for scheme write */
+    tmpKgarReg = FmPcdKgBuildWriteSchemeActionReg(physicalSchemeId, TRUE);
+
+    WriteKgarWait(p_FmPcd, tmpKgarReg);
+
+    return E_OK;
+#endif /* CONFIG_MULTI_PARTITION_SUPPORT */
+}
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.c b/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.c
new file mode 100644
index 0000000..8af8a09
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.c
@@ -0,0 +1,1379 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/******************************************************************************
+ @File          fm_pcd.c
+
+ @Description   FM PCD ...
+*//***************************************************************************/
+#include "std_ext.h"
+#include "error_ext.h"
+#include "string_ext.h"
+#include "xx_ext.h"
+#include "sprint_ext.h"
+#include "debug_ext.h"
+#include "net_ext.h"
+#include "fm_ext.h"
+#include "fm_pcd_ext.h"
+
+#include "fm_pcd.h"
+#ifdef FM_MASTER_PARTITION
+#include "fm_pcd_ipc.h"
+#endif /* FM_MASTER_PARTITION */
+#include "fm_hc.h"
+
+
+#ifndef CONFIG_GUEST_PARTITION
+static t_Error CheckFmPcdParameters(t_FmPcd *p_FmPcd)
+{
+    if(p_FmPcd->p_FmPcdKg && !p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Something WRONG"));
+
+    if(p_FmPcd->p_FmPcdPlcr && !p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Something WRONG"));
+
+    if(!p_FmPcd->h_Fm)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("h_Fm has to be initialized"));
+
+    if(!p_FmPcd->f_FmPcdException)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("f_FmPcdExceptions has to be initialized"));
+
+    if((!p_FmPcd->f_FmPcdIndexedException) && (p_FmPcd->p_FmPcdPlcr || p_FmPcd->p_FmPcdKg))
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("f_FmPcdIndexedException has to be initialized"));
+
+   if(p_FmPcd->p_FmPcdDriverParam->prsMaxParseCycleLimit > PRS_MAX_CYCLE_LIMIT)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("prsMaxParseCycleLimit has to be less than 8191"));
+
+
+    return E_OK;
+}
+#endif  /* !CONFIG_GUEST_PARTITION */
+
+#ifdef FM_MASTER_PARTITION
+t_Error  FmPcdHandleIpcMsg(t_Handle h_FmPcd, uint32_t msgId, uint8_t msgBody[MSG_BODY_SIZE])
+{
+    t_FmPcd                     *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    uint8_t                     schemeId;
+    t_Error                     err;
+    t_FmPcdKgInterModuleClsPlanSet           clsPlanSet;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+
+    switch(msgId)
+    {
+    case (FM_PCD_MASTER_IS_ALIVE):
+        return E_OK;
+    case (FM_PCD_MASTER_IS_ENABLED):
+        return p_FmPcd->enabled;
+        //case (FM_PCD_CLEAR_PORT_PARAMS):
+            //return FmPcdDeletePortParams(h_FmPcd, (t_FmPcdInterModulePortDeleteParams*)msgBody);
+        case (FM_PCD_ALLOC_KG_RSRC):
+            {
+                err = FmPcdKgAllocSchemes(h_FmPcd,
+                                            ((t_FmPcdIpcKgAllocParams*)msgBody)->numOfSchemes,
+                                            ((t_FmPcdIpcKgAllocParams*)msgBody)->partitionId,
+                                            ((t_FmPcdIpcKgAllocParams*)msgBody)->schemesIds);
+                if(err)
+                    RETURN_ERROR(MINOR, err, NO_MSG);
+
+                err = FmPcdKgAllocClsPlanEntries(h_FmPcd,
+                                            ((t_FmPcdIpcKgAllocParams*)msgBody)->numOfClsPlanEntries,
+                                            ((t_FmPcdIpcKgAllocParams*)msgBody)->partitionId,
+                                            &((t_FmPcdIpcKgAllocParams*)msgBody)->clsPlanBase);
+                if(err)
+                    RETURN_ERROR(MINOR, err, NO_MSG);
+                /* build vectors of 0xFFFFFFFF for creating a private clsPlan group */
+
+            }
+            break;
+
+        case (FM_PCD_ALLOC_CLS_PLAN_EMPTY_GRP):
+            {
+                memset(clsPlanSet.vectors, 0xFF, CLS_PLAN_NUM_PER_GRP*sizeof(uint32_t));
+                clsPlanSet.baseEntry = *(uint8_t*)msgBody;
+                clsPlanSet.numOfClsPlanEntries = CLS_PLAN_NUM_PER_GRP;
+                KgSetClsPlan(h_FmPcd, &clsPlanSet);
+            }
+            break;
+        case (FM_PCD_FREE_KG_RSRC):
+            {
+                err = FmPcdKgFreeSchemes(h_FmPcd,
+                                            ((t_FmPcdIpcKgAllocParams*)msgBody)->numOfSchemes,
+                                            ((t_FmPcdIpcKgAllocParams*)msgBody)->partitionId,
+                                            ((t_FmPcdIpcKgAllocParams*)msgBody)->schemesIds);
+                if(err)
+                    RETURN_ERROR(MINOR, err, NO_MSG);
+
+                err = FmPcdKgFreeClsPlanEntries(h_FmPcd,
+                                            ((t_FmPcdIpcKgAllocParams*)msgBody)->numOfClsPlanEntries,
+                                            ((t_FmPcdIpcKgAllocParams*)msgBody)->partitionId,
+                                            ((t_FmPcdIpcKgAllocParams*)msgBody)->clsPlanBase);
+                if(err)
+                    RETURN_ERROR(MINOR, err, NO_MSG);
+                /* build vectors of 0xFFFFFFFF for creating a private clsPlan group */
+
+                if(((t_FmPcdIpcKgAllocParams*)msgBody)->isDriverClsPlanGrp)
+                {
+                    memset(clsPlanSet.vectors, 0x00, CLS_PLAN_NUM_PER_GRP*sizeof(uint32_t));
+                    clsPlanSet.baseEntry = ((t_FmPcdIpcKgAllocParams*)msgBody)->clsPlanBase;
+                    clsPlanSet.numOfClsPlanEntries = CLS_PLAN_NUM_PER_GRP;
+                    KgSetClsPlan(h_FmPcd, &clsPlanSet);
+                }
+            }
+            break;
+        case (FM_PCD_ALLOC_PROFILES):
+            return PlcrAllocProfiles(h_FmPcd,
+                                        ((t_FmPcdIpcPlcrAllocParams*)msgBody)->hardwarePortId,
+                                        ((t_FmPcdIpcPlcrAllocParams*)msgBody)->num,
+                                        &((t_FmPcdIpcPlcrAllocParams*)msgBody)->plcrProfilesBase);
+        case (FM_PCD_FREE_PROFILES):
+            return PlcrFreeProfiles(h_FmPcd,
+                                        ((t_FmPcdIpcPlcrAllocParams*)msgBody)->hardwarePortId,
+                                        ((t_FmPcdIpcPlcrAllocParams*)msgBody)->num,
+                                        ((t_FmPcdIpcPlcrAllocParams*)msgBody)->plcrProfilesBase);
+
+        case (FM_PCD_ALLOC_SHARED_PROFILES):
+            return PlcrAllocSharedProfiles(h_FmPcd,
+                                        ((t_FmPcdIpcSharedPlcrAllocParams*)msgBody)->num,
+                                        ((t_FmPcdIpcSharedPlcrAllocParams*)msgBody)->profilesIds);
+        case (FM_PCD_FREE_SHARED_PROFILES):
+            PlcrFreeSharedProfiles(h_FmPcd,
+                                        ((t_FmPcdIpcSharedPlcrAllocParams*)msgBody)->num,
+                                        ((t_FmPcdIpcSharedPlcrAllocParams*)msgBody)->profilesIds);
+            break;
+        case (FM_PCD_GET_PHYS_MURAM_BASE):
+            return FmGetPhysicalMuramBase(p_FmPcd->h_Fm, (t_FmPhysAddr*)msgBody);
+        case(FM_PCD_GET_SW_PRS_OFFSET):
+            ((t_FmPcdIpcSwPrsLable*)msgBody)->offset = FmPcdGetSwPrsOffset(h_FmPcd, ((t_FmPcdIpcSwPrsLable*)msgBody)->hdr, ((t_FmPcdIpcSwPrsLable*)msgBody)->indexPerHdr);
+            if(((t_FmPcdIpcSwPrsLable*)msgBody)->offset == ILLEGAL_BASE)
+                RETURN_ERROR(MINOR, E_INVALID_VALUE, NO_MSG);
+
+
+            break;
+       /* case(FM_PCD_GET_SET_KG_SCHEME_HC_PARAMS):
+            return FmPcdKgGetSetSchemeParams(h_FmPcd, (t_FmPcdInterModuleKgSchemeParams*)msgBody);*/
+        case(FM_PCD_FREE_KG_SCHEME_HC):
+            schemeId = *(uint8_t*)msgBody;
+            FmPcdKgInvalidateSchemeSw(h_FmPcd, schemeId);
+            break;
+        default:
+            RETURN_ERROR(MINOR, E_INVALID_SELECTION, ("command not found!!!"));
+    }
+    return E_OK;
+}
+#endif /* FM_MASTER_PARTITION */
+
+t_Error PcdGetVectorForOpt(t_FmPcd *p_FmPcd, uint8_t netEnvId, protocolOpt_t opt, uint32_t *p_Vector)
+{
+    uint8_t     j,k;
+
+    *p_Vector = 0;
+
+    for(j=0;(p_FmPcd->netEnvs[netEnvId].units[j].hdrs[0].hdr != HEADER_TYPE_NONE)
+            && (j < FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS) ;j++)
+        for(k=0;(p_FmPcd->netEnvs[netEnvId].units[j].hdrs[k].hdr != HEADER_TYPE_NONE)
+                && (k < FM_PCD_MAX_NUM_OF_INTERCHANGABLE_HDRS) ;k++)
+        {
+            if(p_FmPcd->netEnvs[netEnvId].units[j].hdrs[k].opt == opt)
+                *p_Vector |= p_FmPcd->netEnvs[netEnvId].unitsVectors[j];
+        }
+
+    if (!*p_Vector)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Requested option was not defined for this Network Environment Characteristics module"));
+    else
+        return E_OK;
+}
+
+t_Error PcdGetUnitsVector(t_FmPcd *p_FmPcd, t_NetEnvParams *p_Params)
+{
+    int                     i;
+
+    p_Params->vector = 0;
+    for(i=0; i<p_Params->numOfDistinctionUnits ;i++)
+    {
+        if(p_FmPcd->netEnvs[p_Params->netEnvId].units[p_Params->unitIds[i]].hdrs[0].hdr == HEADER_TYPE_NONE)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Requested unit was not defined for this Network Environment Characteristics module"));
+        ASSERT_COND(p_FmPcd->netEnvs[p_Params->netEnvId].unitsVectors[p_Params->unitIds[i]]);
+        p_Params->vector |= p_FmPcd->netEnvs[p_Params->netEnvId].unitsVectors[p_Params->unitIds[i]];
+    }
+
+    return E_OK;
+}
+
+bool PcdNetEnvIsUnitWithoutOpts(t_FmPcd *p_FmPcd, uint8_t netEnvId, uint32_t unitVector)
+{
+    int     i=0, k;
+    /* check whether a given unit may be used by non-clsPlan users. */
+    /* first, recognize the unit by its vector */
+    while (p_FmPcd->netEnvs[netEnvId].units[i].hdrs[0].hdr != HEADER_TYPE_NONE)
+    {
+        if (p_FmPcd->netEnvs[netEnvId].unitsVectors[i] == unitVector)
+        {
+            for (k=0;
+                 ((k < FM_PCD_MAX_NUM_OF_INTERCHANGABLE_HDRS) &&
+                  (p_FmPcd->netEnvs[netEnvId].units[i].hdrs[k].hdr != HEADER_TYPE_NONE));
+                 k++)
+                /* check that no option exists */
+                if((protocolOpt_t)p_FmPcd->netEnvs[netEnvId].units[i].hdrs[k].opt)
+                    return FALSE;
+            break;
+        }
+        i++;
+    }
+    /* assert that a unit was found to mach the vector */
+    ASSERT_COND(p_FmPcd->netEnvs[netEnvId].units[i].hdrs[0].hdr != HEADER_TYPE_NONE);
+
+    return TRUE;
+}
+
+void   FmPcdPortRegister(t_Handle h_FmPcd, t_Handle h_FmPort, uint8_t hardwarePortId)
+{
+    t_FmPcd         *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    uint16_t        pcdPortId;
+    uint8_t         portsTable[] = PCD_PORTS_TABLE;
+
+    GET_FM_PCD_PORTID_FROM_GLOBAL_PORTID(pcdPortId, portsTable, hardwarePortId)
+
+    p_FmPcd->p_FmPcdPlcr->portsMapping[pcdPortId].h_FmPort = h_FmPort;
+}
+
+uint32_t FmPcdGetLcv(t_Handle h_FmPcd, uint32_t netEnvId, uint8_t hdrNum)
+{
+    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
+
+    return p_FmPcd->netEnvs[netEnvId].lcvs[hdrNum];
+}
+
+#ifdef CONFIG_MULTI_PARTITION_SUPPORT
+uint8_t FmPcdGetPartitionId(t_Handle h_FmPcd)
+{
+    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
+
+    return p_FmPcd->partitionId;
+}
+#endif /* CONFIG_MULTI_PARTITION_SUPPORT */
+
+void FmPcdIncNetEnvOwners(t_Handle h_FmPcd, uint8_t netEnvId)
+{
+    ((t_FmPcd*)h_FmPcd)->netEnvs[netEnvId].owners++;
+}
+
+void FmPcdDecNetEnvOwners(t_Handle h_FmPcd, uint8_t netEnvId)
+{
+    ASSERT_COND(((t_FmPcd*)h_FmPcd)->netEnvs[netEnvId].owners);
+    ((t_FmPcd*)h_FmPcd)->netEnvs[netEnvId].owners--;
+}
+
+t_Error FmPcdTryLock(t_Handle h_FmPcd)
+{
+    TRY_LOCK_RET_ERR(((t_FmPcd*)h_FmPcd)->lock);
+    return E_OK;
+}
+
+void FmPcdReleaseLock(t_Handle h_FmPcd)
+{
+    RELEASE_LOCK(((t_FmPcd*)h_FmPcd)->lock);
+}
+
+/**********************************************************************************************************/
+/*              API                                                                                       */
+/**********************************************************************************************************/
+
+t_Handle FM_PCD_Config(t_FmPcdParams *p_FmPcdParams)
+{
+    t_FmPcd *p_Pcd = NULL;
+
+    SANITY_CHECK_RETURN_VALUE(p_FmPcdParams, E_INVALID_HANDLE,NULL);
+
+    p_Pcd = (t_FmPcd *) XX_Malloc(sizeof(t_FmPcd));
+    if (!p_Pcd)
+    {
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM Pcd"));
+        return NULL;
+    }
+    memset(p_Pcd, 0, sizeof(t_FmPcd));
+
+    p_Pcd->p_FmPcdDriverParam = (t_FmPcdDriverParam *) XX_Malloc(sizeof(t_FmPcdDriverParam));
+    if (!p_Pcd)
+    {
+        XX_Free(p_Pcd);
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM Pcd Driver Param"));
+        return NULL;
+    }
+    memset(p_Pcd->p_FmPcdDriverParam, 0, sizeof(t_FmPcdDriverParam));
+
+    p_Pcd->h_Fm = p_FmPcdParams->h_Fm;
+
+#ifndef CONFIG_MULTI_PARTITION_SUPPORT
+    if (p_FmPcdParams->useHostCommand)
+#endif  /* !CONFIG_MULTI_PARTITION_SUPPORT */
+    {
+        t_FmHcParams    hcParams;
+
+        memset(&hcParams, 0, sizeof(hcParams));
+        hcParams.h_Fm = p_Pcd->h_Fm;
+        hcParams.h_FmPcd = (t_Handle)p_Pcd;
+        memcpy((uint8_t*)&hcParams.params, (uint8_t*)&p_FmPcdParams->hc, sizeof(t_FmPcdHcParams));
+        p_Pcd->h_Hc = FmHcConfigAndInit(&hcParams);
+        if (!p_Pcd->h_Hc)
+        {
+            REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM Pcd HC"));
+            FM_PCD_Free(p_Pcd);
+            return NULL;
+        }
+    }
+
+    if(p_FmPcdParams->kgSupport)
+    {
+        p_Pcd->p_FmPcdKg = (t_FmPcdKg *)KgConfig(p_Pcd, p_FmPcdParams);
+        if(!p_Pcd->p_FmPcdKg)
+        {
+            REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM Pcd Keygen"));
+            FM_PCD_Free(p_Pcd);
+            return NULL;
+        }
+    }
+
+    if(p_FmPcdParams->ccSupport)
+    {
+        p_Pcd->p_FmPcdCc = (t_FmPcdCc *)CcConfig(p_Pcd, p_FmPcdParams);
+        if(!p_Pcd->p_FmPcdCc)
+        {
+            REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM Pcd Cc"));
+            FM_PCD_Free(p_Pcd);
+            return NULL;
+        }
+    }
+
+    if(p_FmPcdParams->plcrSupport)
+    {
+        p_Pcd->p_FmPcdPlcr = (t_FmPcdPlcr *)PlcrConfig(p_Pcd, p_FmPcdParams);
+        if(!p_Pcd->p_FmPcdPlcr)
+        {
+            REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM Pcd Policer"));
+            FM_PCD_Free(p_Pcd);
+            return NULL;
+        }
+
+    }
+
+    if(p_FmPcdParams->prsSupport)
+    {
+        p_Pcd->p_FmPcdPrs = (t_FmPcdPrs *)PrsConfig(p_Pcd, p_FmPcdParams);
+        if(!p_Pcd->p_FmPcdPrs)
+        {
+            REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM Pcd Parser"));
+            FM_PCD_Free(p_Pcd);
+            return NULL;
+        }
+    }
+
+#ifdef CONFIG_MULTI_PARTITION_SUPPORT
+    p_Pcd->partitionId                                      = p_FmPcdParams->partitionId;
+#endif /* CONFIG_MULTI_PARTITION_SUPPORT */
+
+#ifndef CONFIG_GUEST_PARTITION
+    p_Pcd->h_App                                            = p_FmPcdParams->h_App;
+    p_Pcd->f_FmPcdException                                 = p_FmPcdParams->f_FmPcdException;
+    p_Pcd->f_FmPcdIndexedException                          = p_FmPcdParams->f_FmPcdIdException;
+#endif  /* !CONFIG_GUEST_PARTITION */
+
+    return p_Pcd;
+}
+
+t_Error FM_PCD_Init(t_Handle h_FmPcd)
+{
+    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    t_Error     err;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdDriverParam, E_INVALID_HANDLE);
+
+
+#ifdef CONFIG_GUEST_PARTITION
+    err = XX_SendMessage(p_FmPcd->fmPcdModuleName, FM_PCD_MASTER_IS_ALIVE, NULL, NULL, NULL);
+    if(err)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+#else
+    CHECK_INIT_PARAMETERS(p_FmPcd, CheckFmPcdParameters);
+#endif /* CONFIG_GUEST_PARTITION */
+
+    if(p_FmPcd->p_FmPcdKg)
+    {
+        err = KgInit(p_FmPcd);
+        if(err)
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
+
+    if(p_FmPcd->p_FmPcdPlcr)
+    {
+        err = PlcrInit(p_FmPcd);
+        if(err)
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
+
+#ifndef CONFIG_GUEST_PARTITION
+    if(p_FmPcd->p_FmPcdPrs)
+    {
+        err = PrsInit(p_FmPcd);
+        if(err)
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
+#endif  /* CONFIG_GUEST_PARTITION */
+#ifdef FM_MASTER_PARTITION
+     /* register to inter-core messaging mechanism */
+    memset(p_FmPcd->fmPcdModuleName, 0, MODULE_NAME_SIZE);
+    if(Sprint (p_FmPcd->fmPcdModuleName, "FM-%d.PCD",FmGetId(p_FmPcd->h_Fm)) != 8)
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Sprint failed"));
+    err = XX_RegisterMessageHandler(p_FmPcd->fmPcdModuleName, FmPcdHandleIpcMsg, p_FmPcd);
+    if(err)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+#endif /* FM_MASTER_PARTITION */
+
+    XX_Free(p_FmPcd->p_FmPcdDriverParam);
+    p_FmPcd->p_FmPcdDriverParam = NULL;
+
+    FmRegisterPcd(p_FmPcd->h_Fm, p_FmPcd);
+
+    return E_OK;
+}
+
+t_Error FM_PCD_Free(t_Handle h_FmPcd)
+{
+    t_FmPcd                             *p_FmPcd =(t_FmPcd *)h_FmPcd;
+#ifdef CONFIG_GUEST_PARTITION
+    t_FmPcdIpcSharedPlcrAllocParams     ipcSharedPlcrParams;
+    t_FmPcdIpcKgAllocParams             kgAlloc;
+#endif /* CONFIG_GUEST_PARTITION */
+#ifdef CONFIG_MULTI_PARTITION_SUPPORT
+    t_Error                             err;
+#endif /* CONFIG_MULTI_PARTITION_SUPPORT */
+
+
+    if(p_FmPcd->p_FmPcdDriverParam)
+    {
+        XX_Free(p_FmPcd->p_FmPcdDriverParam);
+        p_FmPcd->p_FmPcdDriverParam = NULL;
+    }
+    if(p_FmPcd->p_FmPcdKg)
+    {
+
+#ifndef CONFIG_GUEST_PARTITION
+        if(p_FmPcd->p_FmPcdKg->isDriverEmptyClsPlanGrp)
+            FmPcdKgDestroyClsPlanGrp(p_FmPcd, p_FmPcd->p_FmPcdKg->emptyClsPlanGrpId);
+#endif
+#ifdef CONFIG_MULTI_PARTITION_SUPPORT
+#ifdef CONFIG_GUEST_PARTITION
+    kgAlloc.numOfSchemes = p_FmPcd->p_FmPcdKg->numOfSchemes;
+    kgAlloc.partitionId = p_FmPcd->partitionId;
+    kgAlloc.numOfClsPlanEntries = p_FmPcd->p_FmPcdKg->numOfClsPlanEntries;
+    kgAlloc.isDriverClsPlanGrp = p_FmPcd->p_FmPcdKg->isDriverEmptyClsPlanGrp;
+    kgAlloc.clsPlanBase = p_FmPcd->p_FmPcdKg->clsPlanBase;
+    memcpy(kgAlloc.schemesIds, p_FmPcd->p_FmPcdKg->schemesIds , kgAlloc.numOfSchemes);
+    err = XX_SendMessage(p_FmPcd->fmPcdModuleName, FM_PCD_FREE_KG_RSRC, (uint8_t*)&kgAlloc, NULL, NULL);
+    if(err)
+        RETURN_ERROR(MINOR, err, NO_MSG);
+#else /* master */
+    err = FmPcdKgFreeSchemes(p_FmPcd,
+                                p_FmPcd->p_FmPcdKg->numOfSchemes,
+                                p_FmPcd->partitionId,
+                                p_FmPcd->p_FmPcdKg->schemesIds);
+    if(err)
+        RETURN_ERROR(MINOR, err, NO_MSG);
+    err = FmPcdKgFreeClsPlanEntries(p_FmPcd,
+                                p_FmPcd->p_FmPcdKg->numOfClsPlanEntries,
+                                p_FmPcd->partitionId,
+                                p_FmPcd->p_FmPcdKg->clsPlanBase);
+#endif /* CONFIG_GUEST_PARTITION */
+#endif /* CONFIG_MULTI_PARTITION_SUPPORT */
+        XX_Free(p_FmPcd->p_FmPcdKg);
+        p_FmPcd->p_FmPcdKg = NULL;
+    }
+    if(p_FmPcd->p_FmPcdPlcr)
+    {
+        if(p_FmPcd->p_FmPcdPlcr->numOfSharedProfiles)
+#ifdef CONFIG_GUEST_PARTITION
+    /* Alloc resources using IPC messaging */
+    ipcSharedPlcrParams.num = p_FmPcd->p_FmPcdPlcr->numOfSharedProfiles;
+    memcpy(ipcSharedPlcrParams.profilesIds,p_FmPcd->p_FmPcdPlcr->sharedProfilesIds, p_FmPcd->p_FmPcdPlcr->numOfSharedProfiles*sizeof(uint16_t));
+    err = XX_SendMessage(p_FmPcd->fmPcdModuleName, FM_PCD_FREE_SHARED_PROFILES, (uint8_t*)&ipcSharedPlcrParams, NULL, NULL);
+    if(err)
+        RETURN_ERROR(MAJOR, err,NO_MSG);
+#else /* master */
+        PlcrFreeSharedProfiles(p_FmPcd, p_FmPcd->p_FmPcdPlcr->numOfSharedProfiles, p_FmPcd->p_FmPcdPlcr->sharedProfilesIds);
+#endif /* CONFIG_GUEST_PARTITION */
+        XX_Free(p_FmPcd->p_FmPcdPlcr);
+        p_FmPcd->p_FmPcdPlcr = NULL;
+    }
+    if(p_FmPcd->p_FmPcdPrs)
+    {
+        XX_Free(p_FmPcd->p_FmPcdPrs);
+        p_FmPcd->p_FmPcdPrs = NULL;
+    }
+    if(p_FmPcd->p_FmPcdCc)
+    {
+        CcFree(p_FmPcd->p_FmPcdCc);
+        XX_Free(p_FmPcd->p_FmPcdCc);
+        p_FmPcd->p_FmPcdCc = NULL;
+    }
+
+    if (p_FmPcd->h_Hc)
+    {
+        FmHcFree(p_FmPcd->h_Hc);
+        p_FmPcd->h_Hc = NULL;
+    }
+
+#ifdef FM_MASTER_PARTITION
+    XX_UnregisterMessageHandler(p_FmPcd->fmPcdModuleName);
+#endif /* FM_MASTER_PARTITION */
+
+    XX_Free(p_FmPcd);
+    return E_OK;
+}
+
+t_Error FM_PCD_Enable(t_Handle h_FmPcd)
+{
+    t_FmPcd             *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    t_Error             err;
+
+#ifndef CONFIG_GUEST_PARTITION
+    if(p_FmPcd->p_FmPcdKg)
+    {
+        err = KgEnable(p_FmPcd);
+        if(err)
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
+
+    if(p_FmPcd->p_FmPcdPlcr)
+    {
+        err = PlcrEnable(p_FmPcd);
+        if(err)
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
+
+    if(p_FmPcd->p_FmPcdPrs)
+    {
+        err = PrsEnable(p_FmPcd);
+        if(err)
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
+    p_FmPcd->enabled = TRUE;
+
+    return E_OK;
+
+#else
+    return XX_SendMessage(p_FmPcd->fmPcdModuleName, FM_PCD_MASTER_IS_ENABLED, NULL, NULL, NULL);
+#endif /* !CONFIG_GUEST_PARTITION */
+}
+
+t_Error FM_PCD_Disable(t_Handle h_FmPcd)
+{
+/*    t_FmPcd             *p_FmPcd = (t_FmPcd*)h_FmPcd;*/
+
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+
+    return E_OK;
+}
+
+t_Handle FM_PCD_SetNetEnvCharacteristics(t_Handle h_FmPcd, t_FmPcdNetEnvParams  *p_NetEnvParams)
+{
+    t_FmPcd                 *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    uint8_t                 bitId = 0;
+    uint8_t                 privateBitId = 0;
+    uint8_t                 i, j, k;
+    uint8_t                 netEnvCurrId;
+    uint8_t                 ipsecAhUnit = 0,ipsecEspUnit = 0;
+    bool                    ipsecAhExists = FALSE,ipsecEspExists = FALSE;
+    uint8_t                 hdrNum;
+
+    SANITY_CHECK_RETURN_VALUE(h_FmPcd, E_INVALID_STATE, NULL);
+    SANITY_CHECK_RETURN_VALUE(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE, NULL);
+
+    TRY_LOCK_RET_NULL(p_FmPcd->lock);
+
+    /* find a new netEnv */
+    for(i = 0;i<PCD_MAX_NUM_OF_PORTS;i++)
+        if(!p_FmPcd->netEnvs[i].used)
+            break;
+
+    if(i== PCD_MAX_NUM_OF_PORTS)
+    {
+        REPORT_ERROR(MAJOR, E_FULL,("No more than %d netEnv's allowed.", PCD_MAX_NUM_OF_PORTS));
+        RELEASE_LOCK(p_FmPcd->lock);
+        return NULL;
+    }
+
+    p_FmPcd->netEnvs[i].used = TRUE;
+
+    TRY_LOCK_RET_NULL(p_FmPcd->netEnvs[i].lock);
+    RELEASE_LOCK(p_FmPcd->lock);
+
+    netEnvCurrId = (uint8_t)i;
+
+    /* clear from previous use */
+    memset(&p_FmPcd->netEnvs[netEnvCurrId].units, 0, FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS);
+    memcpy(&p_FmPcd->netEnvs[netEnvCurrId].units, p_NetEnvParams->units, p_NetEnvParams->numOfDistinctionUnits*sizeof(t_FmPcdDistinctionUnit));
+
+    /* check that header with opt is not interchanged with the same header */
+    for(i=0;(p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[0].hdr != HEADER_TYPE_NONE)
+            && (i < FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS) ;i++)
+        for(k=0;(p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].hdr != HEADER_TYPE_NONE)
+                && (k < FM_PCD_MAX_NUM_OF_INTERCHANGABLE_HDRS) ;k++)
+        {
+            /* if an option exists, check that other headers are not the same header
+            without option */
+            if(p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].opt)
+            {
+                for(j=0;(p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[j].hdr != HEADER_TYPE_NONE)
+                        && (j < FM_PCD_MAX_NUM_OF_INTERCHANGABLE_HDRS) ;j++)
+                    if((p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[j].hdr == p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].hdr) &&
+                        !p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[j].opt)
+                    {
+                        REPORT_ERROR(MINOR, E_FULL, ("Illegal unit - header with opt may not be interchangable with the same header without opt"));
+                        RELEASE_LOCK(p_FmPcd->netEnvs[netEnvCurrId].lock);
+                        return NULL;
+                    }
+            }
+        }
+
+    /* IPSEC_AH and IPSEC_SPI can't be 2 units,  */
+    /* check that header with opt is not interchanged with the same header */
+    for(i=0;(p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[0].hdr != HEADER_TYPE_NONE)
+            && (i < FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS) ;i++)
+        for(k=0;(p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].hdr != HEADER_TYPE_NONE)
+                && (k < FM_PCD_MAX_NUM_OF_INTERCHANGABLE_HDRS) ;k++)
+        {
+            /* Some headers pairs may not be defined on different units as the parser
+            doesn't distingush  */
+            if(p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].hdr == HEADER_TYPE_IPSEC_AH)
+            {
+                if (ipsecEspExists && (ipsecEspUnit != i))
+                {
+                    REPORT_ERROR(MINOR, E_INVALID_STATE, ("HEADER_TYPE_IPSEC_AH and HEADER_TYPE_IPSEC_ESP may not be defined in separate units"));
+                    RELEASE_LOCK(p_FmPcd->netEnvs[netEnvCurrId].lock);
+                   return NULL;
+                }
+                else
+                {
+                    ipsecAhUnit = i;
+                    ipsecAhExists = TRUE;
+                }
+            }
+            if(p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].hdr == HEADER_TYPE_IPSEC_ESP)
+            {
+                if (ipsecAhExists && (ipsecAhUnit != i))
+                {
+                    REPORT_ERROR(MINOR, E_INVALID_STATE, ("HEADER_TYPE_IPSEC_AH and HEADER_TYPE_IPSEC_ESP may not be defined in separate units"));
+                    RELEASE_LOCK(p_FmPcd->netEnvs[netEnvCurrId].lock);
+                    return NULL;
+                }
+                else
+                {
+                    ipsecEspUnit = i;
+                    ipsecEspExists = TRUE;
+                }
+            }
+       }
+
+
+    /* if private header (shim), check that no other headers specified */
+    for(i=0;(p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[0].hdr != HEADER_TYPE_NONE)
+            && (i < FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS) ;i++)
+    {
+        if(IS_PRIVATE_HEADER(p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[0].hdr))
+            if(p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[1].hdr != HEADER_TYPE_NONE)
+            {
+                REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("SHIM header may not be interchangesd with other headers"));
+                RELEASE_LOCK(p_FmPcd->netEnvs[netEnvCurrId].lock);
+                return NULL;
+            }
+    }
+
+    for(i=0; i<p_NetEnvParams->numOfDistinctionUnits;i++)
+    {
+        if (IS_PRIVATE_HEADER(p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[0].hdr))
+            p_FmPcd->netEnvs[netEnvCurrId].unitsVectors[i] = (uint32_t)(0x00000001 << privateBitId++);
+        else
+            p_FmPcd->netEnvs[netEnvCurrId].unitsVectors[i] = (uint32_t)(0x80000000 >> bitId++);
+    }
+
+    /* define a set of hardware parser LCV's according to the defined netenv */
+
+    /* set an array of LCV's for each header in the netEnv */
+    for(i=0;(p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[0].hdr != HEADER_TYPE_NONE)
+            && (i < FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS) ;i++)
+        /* private headers have no LCV in the hard parser */
+        if (!IS_PRIVATE_HEADER(p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[0].hdr))
+        {
+            for(k=0;(p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].hdr != HEADER_TYPE_NONE)
+                    && (k < FM_PCD_MAX_NUM_OF_INTERCHANGABLE_HDRS) ;k++)
+            {
+                GET_PRS_HDR_NUM(hdrNum, p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].hdr);
+                if (hdrNum == ILLEGAL_HDR_NUM)
+                {
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, NO_MSG);
+                    RELEASE_LOCK(p_FmPcd->netEnvs[netEnvCurrId].lock);
+                    return NULL;
+                }
+                p_FmPcd->netEnvs[netEnvCurrId].lcvs[hdrNum] |= p_FmPcd->netEnvs[netEnvCurrId].unitsVectors[i];
+            }
+        }
+
+    RELEASE_LOCK(p_FmPcd->netEnvs[netEnvCurrId].lock);
+
+    return CAST_UINT32_TO_POINTER((uint32_t)netEnvCurrId+1);
+}
+
+t_Error FM_PCD_DeleteNetEnvCharacteristics(t_Handle h_FmPcd, t_Handle h_NetEnv)
+{
+    t_FmPcd                 *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    uint8_t                 netEnvId = (uint8_t)(CAST_POINTER_TO_UINT32(h_NetEnv)-1);
+    SANITY_CHECK_RETURN_ERROR(h_FmPcd, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE);
+
+    TRY_LOCK_RET_ERR(p_FmPcd->netEnvs[netEnvId].lock);
+    /* check that no port is bound to this netEnv */
+    if(p_FmPcd->netEnvs[netEnvId].owners)
+       RETURN_ERROR(MINOR, E_INVALID_STATE, ("Trying to delete a netEnv that has ports/schemes/trees/clsPlanGrps bound to"));
+
+    p_FmPcd->netEnvs[netEnvId].used= FALSE;
+
+    memset(p_FmPcd->netEnvs[netEnvId].units, 0, sizeof(t_FmPcdIntDistinctionUnit)*FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS);
+    memset(p_FmPcd->netEnvs[netEnvId].unitsVectors, 0, sizeof(uint32_t)*FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS);
+    memset(p_FmPcd->netEnvs[netEnvId].lcvs, 0, sizeof(uint32_t)*FM_PCD_PRS_NUM_OF_HDRS);
+
+    RELEASE_LOCK(p_FmPcd->netEnvs[netEnvId].lock);
+
+    return E_OK;
+}
+
+void FM_PCD_HcTxConf(t_Handle h_FmPcd, t_FmFD *p_Fd)
+{
+    t_FmPcd                 *p_FmPcd = (t_FmPcd*)h_FmPcd;
+
+    SANITY_CHECK_RETURN(h_FmPcd, E_INVALID_STATE);
+
+    FmHcTxConf(p_FmPcd->h_Hc, p_Fd);
+}
+
+#ifndef CONFIG_GUEST_PARTITION
+t_Error FM_PCD_ConfigException(t_Handle h_FmPcd, e_FmPcdExceptions exception, bool enable)
+{
+    t_FmPcd         *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    uint32_t        bitMask = 0;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+
+    GET_FM_PCD_EXCEPTION_FLAG(bitMask, exception);
+    if(bitMask)
+    {
+        if (enable)
+            p_FmPcd->exceptions |= bitMask;
+        else
+            p_FmPcd->exceptions &= ~bitMask;
+   }
+    else
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Undefined exception"));
+
+    return E_OK;
+}
+
+t_Error FM_PCD_SetException(t_Handle h_FmPcd, e_FmPcdExceptions exception, bool enable)
+{
+    t_FmPcd         *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    uint32_t        bitMask = 0, tmpReg;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE);
+
+    GET_FM_PCD_EXCEPTION_FLAG(bitMask, exception);
+
+    if(bitMask)
+    {
+        if (enable)
+            p_FmPcd->exceptions |= bitMask;
+        else
+            p_FmPcd->exceptions &= ~bitMask;
+
+        switch(exception)
+        {
+            case(e_FM_PCD_KG_ERR_EXCEPTION_DOUBLE_ECC):
+            case(e_FM_PCD_KG_ERR_EXCEPTION_KEYSIZE_OVERFLOW):
+                if(!p_FmPcd->p_FmPcdKg)
+                    RETURN_ERROR(MINOR, E_INVALID_STATE, ("Can't ask for this interrupt - keygen is not working"));
+                break;
+            case(e_FM_PCD_PLCR_ERR_EXCEPTION_DOUBLE_ECC):
+            case(e_FM_PCD_PLCR_ERR_EXCEPTION_INIT_ENTRY_ERROR):
+            case(e_FM_PCD_PLCR_EXCEPTION_PRAM_SELF_INIT_COMPLETE):
+            case(e_FM_PCD_PLCR_EXCEPTION_ATOMIC_ACTION_COMPLETE):
+                if(!p_FmPcd->p_FmPcdPlcr)
+                    RETURN_ERROR(MINOR, E_INVALID_STATE, ("Can't ask for this interrupt - policer is not working"));
+            break;
+            case(e_FM_PCD_PRS_EXCEPTION_DOUBLE_ECC):
+            case(e_FM_PCD_PRS_EXCEPTION_SINGLE_ECC):
+            case(e_FM_PCD_PRS_EXCEPTION_ILLEGAL_ACCESS):
+            case(e_FM_PCD_PRS_EXCEPTION_PORT_ILLEGAL_ACCESS):
+                if(!p_FmPcd->p_FmPcdPrs)
+                    RETURN_ERROR(MINOR, E_INVALID_STATE, ("Can't ask for this interrupt - parser is not working"));
+            break;
+            default:
+                RETURN_ERROR(MINOR, E_INVALID_STATE, ("Unsupported exception"));
+
+        }
+
+        switch(exception)
+        {
+            case(e_FM_PCD_KG_ERR_EXCEPTION_DOUBLE_ECC):
+                tmpReg = GET_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgeeer);
+                if(enable)
+                    tmpReg |= FM_PCD_KG_DOUBLE_ECC;
+                else
+                    tmpReg &= ~FM_PCD_KG_DOUBLE_ECC;
+                WRITE_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgeeer, tmpReg);
+                break;
+            case(e_FM_PCD_KG_ERR_EXCEPTION_KEYSIZE_OVERFLOW):
+                tmpReg = GET_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgeeer);
+                if(enable)
+                    tmpReg |= FM_PCD_KG_KEYSIZE_OVERFLOW;
+                else
+                    tmpReg &= ~FM_PCD_KG_KEYSIZE_OVERFLOW;
+                WRITE_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgeeer, tmpReg);
+                break;
+            case(e_FM_PCD_PRS_EXCEPTION_DOUBLE_ECC):
+                tmpReg = GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->perer);
+                if(enable)
+                    tmpReg |= FM_PCD_PRS_DOUBLE_ECC;
+                else
+                    tmpReg &= ~FM_PCD_PRS_DOUBLE_ECC;
+                WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->perer, tmpReg);
+                break;
+            case(e_FM_PCD_PRS_EXCEPTION_ILLEGAL_ACCESS):
+                tmpReg = GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->perer);
+                if(enable)
+                    tmpReg |= FM_PCD_PRS_ILLEGAL_ACCESS;
+                else
+                    tmpReg &= ~FM_PCD_PRS_ILLEGAL_ACCESS;
+                WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->perer, tmpReg);
+                break;
+            case(e_FM_PCD_PRS_EXCEPTION_PORT_ILLEGAL_ACCESS):
+                tmpReg = GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->perer);
+                if(enable)
+                    tmpReg |= FM_PCD_PRS_PORT_ILLEGAL_ACCESS;
+                else
+                    tmpReg &= ~FM_PCD_PRS_PORT_ILLEGAL_ACCESS;
+                WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->perer, tmpReg);
+                break;
+            case(e_FM_PCD_PRS_EXCEPTION_SINGLE_ECC):
+                tmpReg = GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->pever);
+                if(enable)
+                    tmpReg |= FM_PCD_PRS_SINGLE_ECC;
+                else
+                    tmpReg &= ~FM_PCD_PRS_SINGLE_ECC;
+                WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->pever, tmpReg);
+                break;
+            case(e_FM_PCD_PLCR_ERR_EXCEPTION_DOUBLE_ECC):
+                tmpReg = GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_eier);
+                if(enable)
+                    tmpReg |= FM_PCD_PLCR_DOUBLE_ECC;
+                else
+                    tmpReg &= ~FM_PCD_PLCR_DOUBLE_ECC;
+                WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_eier, tmpReg);
+                break;
+            case(e_FM_PCD_PLCR_ERR_EXCEPTION_INIT_ENTRY_ERROR):
+                tmpReg = GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_eier);
+                if(enable)
+                    tmpReg |= FM_PCD_PLCR_INIT_ENTRY_ERROR;
+                else
+                    tmpReg &= ~FM_PCD_PLCR_INIT_ENTRY_ERROR;
+                WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_eier, tmpReg);
+                break;
+            case(e_FM_PCD_PLCR_EXCEPTION_PRAM_SELF_INIT_COMPLETE):
+                tmpReg = GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_ier);
+                if(enable)
+                    tmpReg |= FM_PCD_PLCR_PRAM_SELF_INIT_COMPLETE;
+                else
+                    tmpReg &= ~FM_PCD_PLCR_PRAM_SELF_INIT_COMPLETE;
+                WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_ier, tmpReg);
+                break;
+            case(e_FM_PCD_PLCR_EXCEPTION_ATOMIC_ACTION_COMPLETE):
+                tmpReg = GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_ier);
+                if(enable)
+                    tmpReg |= FM_PCD_PLCR_ATOMIC_ACTION_COMPLETE;
+                else
+                    tmpReg &= ~FM_PCD_PLCR_ATOMIC_ACTION_COMPLETE;
+                WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_ier, tmpReg);
+                break;
+             default:
+                RETURN_ERROR(MINOR, E_INVALID_STATE, ("Unsupported exception"));
+        }
+        /* for ECC exceptions driver automatically enables ECC mechanism, if disabled.
+           Driver does NOT disables them automatically, as we do not control which
+           of the rams are enabled and which arn't */
+        if(enable && ( (exception == e_FM_PCD_KG_ERR_EXCEPTION_DOUBLE_ECC) |
+                       (exception == e_FM_PCD_PLCR_ERR_EXCEPTION_DOUBLE_ECC) |
+                       (exception == e_FM_PCD_PRS_EXCEPTION_DOUBLE_ECC) |
+                       (exception == e_FM_PCD_PRS_EXCEPTION_SINGLE_ECC)))
+            if(!FmRamsEccIsExternalCtl(p_FmPcd->h_Fm))
+                FM_EnableRamsEcc(p_FmPcd->h_Fm);
+    }
+    else
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Undefined exception"));
+
+    return E_OK;
+}
+
+uint32_t FM_PCD_GetCounter(t_Handle h_FmPcd, e_FmPcdCounters counter)
+{
+    t_FmPcd            *p_FmPcd = (t_FmPcd*)h_FmPcd;
+
+    SANITY_CHECK_RETURN_VALUE(h_FmPcd, E_INVALID_HANDLE, 0);
+    SANITY_CHECK_RETURN_VALUE(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE, 0);
+
+    switch(counter)
+    {
+        case(e_FM_PCD_KG_COUNTERS_TOTAL):
+            if(!p_FmPcd->p_FmPcdKg)
+            {
+                REPORT_ERROR(MINOR, E_INVALID_STATE, ("Can't ask for this counters"));
+                return 0;
+            }
+            break;
+        case(e_FM_PCD_PLCR_COUNTERS_YELLOW):
+        case(e_FM_PCD_PLCR_COUNTERS_RED):
+        case(e_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_RED):
+        case(e_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_YELLOW):
+        case(e_FM_PCD_PLCR_COUNTERS_TOTAL):
+        case(e_FM_PCD_PLCR_COUNTERS_LENGTH_MISMATCH):
+            if(!p_FmPcd->p_FmPcdPlcr)
+            {
+                REPORT_ERROR(MINOR, E_INVALID_STATE, ("Can't ask for this counters"));
+                return 0;
+            }
+            /* check that counters are enabled */
+            if(!(GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_gcr) & FM_PCD_PLCR_GCR_STEN))
+            {
+                REPORT_ERROR(MINOR, E_INVALID_STATE, ("Requested counter was not enabled"));
+                return 0;
+            }
+            break;
+        case(e_FM_PCD_PRS_COUNTERS_PARSE_DISPATCH):
+        case(e_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED):
+        case(e_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED):
+        case(e_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED):
+        case(e_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED):
+        case(e_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED_WITH_ERR):
+        case(e_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED_WITH_ERR):
+        case(e_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED_WITH_ERR):
+        case(e_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED_WITH_ERR):
+        case(e_FM_PCD_PRS_COUNTERS_SOFT_PRS_CYCLES):
+        case(e_FM_PCD_PRS_COUNTERS_SOFT_PRS_STALL_CYCLES):
+        case(e_FM_PCD_PRS_COUNTERS_HARD_PRS_CYCLE_INCL_STALL_CYCLES):
+        case(e_FM_PCD_PRS_COUNTERS_MURAM_READ_CYCLES):
+        case(e_FM_PCD_PRS_COUNTERS_MURAM_READ_STALL_CYCLES):
+        case(e_FM_PCD_PRS_COUNTERS_MURAM_WRITE_CYCLES):
+        case(e_FM_PCD_PRS_COUNTERS_MURAM_WRITE_STALL_CYCLES):
+        case(e_FM_PCD_PRS_COUNTERS_FPM_COMMAND_STALL_CYCLES):
+            if(!p_FmPcd->p_FmPcdPrs)
+            {
+                REPORT_ERROR(MINOR, E_INVALID_STATE, ("Can't ask for this counters"));
+                return 0;
+            }
+            break;
+        default:
+            REPORT_ERROR(MINOR, E_INVALID_STATE, ("Unsupported type of counter"));
+            return 0;
+    }
+    switch(counter)
+    {
+        case(e_FM_PCD_PRS_COUNTERS_PARSE_DISPATCH):
+               return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->pds);
+        case(e_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED):
+               return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->l2rrs);
+        case(e_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED):
+               return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->l3rrs);
+        case(e_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED):
+               return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->l4rrs);
+        case(e_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED):
+               return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->srrs);
+        case(e_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED_WITH_ERR):
+               return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->l2rres);
+        case(e_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED_WITH_ERR):
+               return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->l3rres);
+        case(e_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED_WITH_ERR):
+               return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->l4rres);
+        case(e_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED_WITH_ERR):
+               return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->srres);
+        case(e_FM_PCD_PRS_COUNTERS_SOFT_PRS_CYCLES):
+               return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->spcs);
+        case(e_FM_PCD_PRS_COUNTERS_SOFT_PRS_STALL_CYCLES):
+               return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->spscs);
+        case(e_FM_PCD_PRS_COUNTERS_HARD_PRS_CYCLE_INCL_STALL_CYCLES):
+               return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->hxscs);
+        case(e_FM_PCD_PRS_COUNTERS_MURAM_READ_CYCLES):
+               return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->mrcs);
+        case(e_FM_PCD_PRS_COUNTERS_MURAM_READ_STALL_CYCLES):
+               return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->mrscs);
+        case(e_FM_PCD_PRS_COUNTERS_MURAM_WRITE_CYCLES):
+               return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->mwcs);
+        case(e_FM_PCD_PRS_COUNTERS_MURAM_WRITE_STALL_CYCLES):
+               return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->mwscs);
+        case(e_FM_PCD_PRS_COUNTERS_FPM_COMMAND_STALL_CYCLES):
+               return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->fcscs);
+        case(e_FM_PCD_KG_COUNTERS_TOTAL):
+               return GET_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgtpc);
+
+        /*Policer statictics*/
+        case(e_FM_PCD_PLCR_COUNTERS_YELLOW):
+                return GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_ypcnt);
+        case(e_FM_PCD_PLCR_COUNTERS_RED):
+                return GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_rpcnt);
+        case(e_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_RED):
+                return GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_rrpcnt);
+        case(e_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_YELLOW):
+                return GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_rypcnt);
+        case(e_FM_PCD_PLCR_COUNTERS_TOTAL):
+                return GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_tpcnt);
+        case(e_FM_PCD_PLCR_COUNTERS_LENGTH_MISMATCH):
+                return GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_flmcnt);
+
+        default:
+            REPORT_ERROR(MINOR, E_INVALID_STATE, ("Unsupported type of counter"));
+            return 0;
+    }
+}
+
+t_Error FM_PCD_SetCounter(t_Handle h_FmPcd, e_FmPcdCounters counter, uint32_t value)
+{
+    t_FmPcd            *p_FmPcd = (t_FmPcd*)h_FmPcd;
+
+    SANITY_CHECK_RETURN_ERROR(h_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE);
+
+    switch(counter)
+    {
+        case(e_FM_PCD_KG_COUNTERS_TOTAL):
+            if(!p_FmPcd->p_FmPcdKg)
+                RETURN_ERROR(MINOR, E_INVALID_STATE, ("Can't ask for this counters - keygen is not working"));
+            break;
+        case(e_FM_PCD_PLCR_COUNTERS_YELLOW):
+        case(e_FM_PCD_PLCR_COUNTERS_RED):
+        case(e_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_RED):
+        case(e_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_YELLOW):
+        case(e_FM_PCD_PLCR_COUNTERS_TOTAL):
+        case(e_FM_PCD_PLCR_COUNTERS_LENGTH_MISMATCH):
+            if(!p_FmPcd->p_FmPcdPlcr)
+                RETURN_ERROR(MINOR, E_INVALID_STATE, ("Can't ask for this counters - Policer is not working"));
+            if(!(GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_gcr) & FM_PCD_PLCR_GCR_STEN))
+                RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter was not enabled"));
+            break;
+        case(e_FM_PCD_PRS_COUNTERS_PARSE_DISPATCH):
+        case(e_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED):
+        case(e_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED):
+        case(e_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED):
+        case(e_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED):
+        case(e_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED_WITH_ERR):
+        case(e_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED_WITH_ERR):
+        case(e_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED_WITH_ERR):
+        case(e_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED_WITH_ERR):
+        case(e_FM_PCD_PRS_COUNTERS_SOFT_PRS_CYCLES):
+        case(e_FM_PCD_PRS_COUNTERS_SOFT_PRS_STALL_CYCLES):
+        case(e_FM_PCD_PRS_COUNTERS_HARD_PRS_CYCLE_INCL_STALL_CYCLES):
+        case(e_FM_PCD_PRS_COUNTERS_MURAM_READ_CYCLES):
+        case(e_FM_PCD_PRS_COUNTERS_MURAM_READ_STALL_CYCLES):
+        case(e_FM_PCD_PRS_COUNTERS_MURAM_WRITE_CYCLES):
+        case(e_FM_PCD_PRS_COUNTERS_MURAM_WRITE_STALL_CYCLES):
+        case(e_FM_PCD_PRS_COUNTERS_FPM_COMMAND_STALL_CYCLES):
+            if(!p_FmPcd->p_FmPcdPrs)
+                RETURN_ERROR(MINOR, E_INVALID_STATE, ("Unsupported type of counter"));
+            break;
+        default:
+            RETURN_ERROR(MINOR, E_INVALID_STATE, ("Unsupported type of counter"));
+    }
+    switch(counter)
+    {
+        case(e_FM_PCD_PRS_COUNTERS_PARSE_DISPATCH):
+               WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->pds, value);
+            break;
+        case(e_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED):
+               WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->l2rrs, value);
+            break;
+        case(e_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED):
+               WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->l3rrs, value);
+             break;
+       case(e_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED):
+               WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->l4rrs, value);
+            break;
+        case(e_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED):
+               WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->srrs, value);
+            break;
+        case(e_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED_WITH_ERR):
+               WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->l2rres, value);
+            break;
+        case(e_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED_WITH_ERR):
+               WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->l3rres, value);
+            break;
+        case(e_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED_WITH_ERR):
+               WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->l4rres, value);
+            break;
+        case(e_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED_WITH_ERR):
+               WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->srres, value);
+            break;
+        case(e_FM_PCD_PRS_COUNTERS_SOFT_PRS_CYCLES):
+               WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->spcs, value);
+            break;
+        case(e_FM_PCD_PRS_COUNTERS_SOFT_PRS_STALL_CYCLES):
+               WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->spscs, value);
+            break;
+        case(e_FM_PCD_PRS_COUNTERS_HARD_PRS_CYCLE_INCL_STALL_CYCLES):
+               WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->hxscs, value);
+            break;
+        case(e_FM_PCD_PRS_COUNTERS_MURAM_READ_CYCLES):
+               WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->mrcs, value);
+            break;
+        case(e_FM_PCD_PRS_COUNTERS_MURAM_READ_STALL_CYCLES):
+               WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->mrscs, value);
+            break;
+        case(e_FM_PCD_PRS_COUNTERS_MURAM_WRITE_CYCLES):
+               WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->mwcs, value);
+            break;
+        case(e_FM_PCD_PRS_COUNTERS_MURAM_WRITE_STALL_CYCLES):
+               WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->mwscs, value);
+            break;
+        case(e_FM_PCD_PRS_COUNTERS_FPM_COMMAND_STALL_CYCLES):
+               WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->fcscs, value);
+             break;
+        case(e_FM_PCD_KG_COUNTERS_TOTAL):
+            WRITE_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgtpc,value);
+            break;
+
+        /*Policer counters*/
+        case(e_FM_PCD_PLCR_COUNTERS_YELLOW):
+            WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_ypcnt, value);
+            break;
+        case(e_FM_PCD_PLCR_COUNTERS_RED):
+            WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_rpcnt, value);
+            break;
+        case(e_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_RED):
+             WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_rrpcnt, value);
+            break;
+        case(e_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_YELLOW):
+              WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_rypcnt, value);
+            break;
+        case(e_FM_PCD_PLCR_COUNTERS_TOTAL):
+              WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_tpcnt, value);
+            break;
+        case(e_FM_PCD_PLCR_COUNTERS_LENGTH_MISMATCH):
+              WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_flmcnt, value);
+            break;
+        default:
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Unsupported type of counter"));
+    }
+
+return E_OK;
+}
+
+
+
+t_Error FM_PCD_ForceIntr (t_Handle h_FmPcd, e_FmPcdExceptions exception)
+{
+    t_FmPcd            *p_FmPcd = (t_FmPcd*)h_FmPcd;
+
+    SANITY_CHECK_RETURN_ERROR(h_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE);
+
+    switch(exception)
+    {
+        case(e_FM_PCD_KG_ERR_EXCEPTION_DOUBLE_ECC):
+        case(e_FM_PCD_KG_ERR_EXCEPTION_KEYSIZE_OVERFLOW):
+            if(!p_FmPcd->p_FmPcdKg)
+                RETURN_ERROR(MINOR, E_INVALID_STATE, ("Can't ask for this interrupt - keygen is not working"));
+            break;
+        case(e_FM_PCD_PLCR_ERR_EXCEPTION_DOUBLE_ECC):
+        case(e_FM_PCD_PLCR_ERR_EXCEPTION_INIT_ENTRY_ERROR):
+        case(e_FM_PCD_PLCR_EXCEPTION_PRAM_SELF_INIT_COMPLETE):
+        case(e_FM_PCD_PLCR_EXCEPTION_ATOMIC_ACTION_COMPLETE):
+            if(!p_FmPcd->p_FmPcdPlcr)
+                RETURN_ERROR(MINOR, E_INVALID_STATE, ("Can't ask for this interrupt - policer is not working"));
+            break;
+        case(e_FM_PCD_PRS_EXCEPTION_DOUBLE_ECC):
+        case(e_FM_PCD_PRS_EXCEPTION_SINGLE_ECC):
+        case(e_FM_PCD_PRS_EXCEPTION_ILLEGAL_ACCESS):
+        case(e_FM_PCD_PRS_EXCEPTION_PORT_ILLEGAL_ACCESS):
+            if(!p_FmPcd->p_FmPcdPrs)
+                RETURN_ERROR(MINOR, E_INVALID_STATE, ("Can't ask for this interrupt -parsrer is not working"));
+            break;
+        default:
+            RETURN_ERROR(MINOR, E_INVALID_STATE, ("Invalid interrupt requested"));
+
+    }
+    switch(exception)
+    {
+        case e_FM_PCD_PRS_EXCEPTION_DOUBLE_ECC:
+            if (!(p_FmPcd->exceptions & FM_PCD_EX_PRS_DOUBLE_ECC))
+                RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception is masked"));
+            WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->perfr, FM_PCD_PRS_DOUBLE_ECC);
+            break;
+        case e_FM_PCD_PRS_EXCEPTION_ILLEGAL_ACCESS:
+            if (!(p_FmPcd->exceptions & FM_PCD_EX_PRS_ILLEGAL_ACCESS))
+                RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception is masked"));
+            WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->perfr, FM_PCD_PRS_ILLEGAL_ACCESS);
+            break;
+        case e_FM_PCD_PRS_EXCEPTION_PORT_ILLEGAL_ACCESS:
+            if (!(p_FmPcd->exceptions & FM_PCD_EX_PRS_PORT_ILLEGAL_ACCESS))
+                RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception is masked"));
+            WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->perfr, /*FM_PCD_PRS_PORT_ILLEGAL_ACCESS*/0x80000000);
+            WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->perfr, /*FM_PCD_PRS_PORT_ILLEGAL_ACCESS*/0x00800000);
+            WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->perfr, FM_PCD_PRS_PORT_ILLEGAL_ACCESS);
+            break;
+        case e_FM_PCD_PRS_EXCEPTION_SINGLE_ECC:
+            if (!(p_FmPcd->exceptions & FM_PCD_EX_PRS_SINGLE_ECC))
+                RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception is masked"));
+            WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->pevfr, FM_PCD_PRS_SINGLE_ECC);
+            break;
+        case e_FM_PCD_KG_ERR_EXCEPTION_DOUBLE_ECC:
+            if (!(p_FmPcd->exceptions & FM_PCD_EX_KG_DOUBLE_ECC))
+                RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception is masked"));
+            WRITE_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgfeer, FM_PCD_KG_DOUBLE_ECC);
+            break;
+        case e_FM_PCD_KG_ERR_EXCEPTION_KEYSIZE_OVERFLOW:
+            if (!(p_FmPcd->exceptions & FM_PCD_EX_KG_KEYSIZE_OVERFLOW))
+                RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception is masked"));
+            WRITE_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgfeer, FM_PCD_KG_KEYSIZE_OVERFLOW);
+            break;
+        case e_FM_PCD_PLCR_ERR_EXCEPTION_DOUBLE_ECC:
+            if (!(p_FmPcd->exceptions & FM_PCD_EX_PLCR_DOUBLE_ECC))
+                RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception is masked"));
+            WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_eifr, FM_PCD_PLCR_DOUBLE_ECC);
+            break;
+        case e_FM_PCD_PLCR_ERR_EXCEPTION_INIT_ENTRY_ERROR:
+            if (!(p_FmPcd->exceptions & FM_PCD_EX_PLCR_INIT_ENTRY_ERROR))
+                RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception is masked"));
+            WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_eifr, FM_PCD_PLCR_INIT_ENTRY_ERROR);
+            break;
+        case e_FM_PCD_PLCR_EXCEPTION_PRAM_SELF_INIT_COMPLETE:
+            if (!(p_FmPcd->exceptions & FM_PCD_EX_PLCR_PRAM_SELF_INIT_COMPLETE))
+                RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception is masked"));
+            WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_ifr, FM_PCD_PLCR_PRAM_SELF_INIT_COMPLETE);
+            break;
+        case e_FM_PCD_PLCR_EXCEPTION_ATOMIC_ACTION_COMPLETE:
+            if (!(p_FmPcd->exceptions & FM_PCD_EX_PLCR_ATOMIC_ACTION_COMPLETE))
+                RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception is masked"));
+            WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_ifr, FM_PCD_PLCR_ATOMIC_ACTION_COMPLETE);
+            break;
+        default:
+            RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception may not be forced"));
+    }
+
+    return E_OK;
+}
+
+#ifdef VERIFICATION_SUPPORT
+void FM_PCD_BackdoorSet (t_Handle h_FmPcd, e_ModuleId moduleId, uint32_t offset, uint32_t value)
+{
+    t_FmPcd             *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    uint32_t            base;
+
+    SANITY_CHECK_RETURN(h_FmPcd, E_INVALID_HANDLE);
+
+    switch(moduleId)
+    {
+        case e_MODULE_ID_FM1_PRS:
+        case e_MODULE_ID_FM2_PRS:
+            base = FmGetPcdPrsBaseAddr(p_FmPcd);
+            break;
+        case e_MODULE_ID_FM1_PLCR:
+        case e_MODULE_ID_FM2_PLCR:
+            base = FmGetPcdPlcrBaseAddr(p_FmPcd);
+            break;
+        case e_MODULE_ID_FM1_KG:
+        case e_MODULE_ID_FM2_KG:
+            base = FmGetPcdKgBaseAddr(p_FmPcd);
+            break;
+        default:
+            REPORT_ERROR(MAJOR, E_INVALID_SELECTION, NO_MSG);
+            return;
+
+    }
+    WRITE_UINT32(*(uint32_t*)(base+offset), value);
+}
+
+uint32_t      FM_PCD_BackdoorGet(t_Handle h_FmPcd, e_ModuleId moduleId, uint32_t offset)
+{
+    t_FmPcd             *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    uint32_t            base;
+
+    SANITY_CHECK_RETURN_ERROR(h_FmPcd, E_INVALID_HANDLE);
+
+    switch(moduleId)
+    {
+        case e_MODULE_ID_FM1_PRS:
+        case e_MODULE_ID_FM2_PRS:
+            base = FmGetPcdPrsBaseAddr(p_FmPcd);
+            break;
+        case e_MODULE_ID_FM1_PLCR:
+        case e_MODULE_ID_FM2_PLCR:
+            base = FmGetPcdPlcrBaseAddr(p_FmPcd);
+            break;
+        case e_MODULE_ID_FM1_KG:
+        case e_MODULE_ID_FM2_KG:
+            base = FmGetPcdKgBaseAddr(p_FmPcd);
+            break;
+        default:
+            REPORT_ERROR(MAJOR, E_INVALID_SELECTION, NO_MSG);
+            return 0;
+    }
+
+    return GET_UINT32(*(uint32_t*)(base+offset));
+}
+#endif /*VERIFICATION_SUPPORT*/
+
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+t_Error FM_PCD_DumpRegs(t_Handle h_FmPcd)
+{
+    t_FmPcd             *p_FmPcd = (t_FmPcd*)h_FmPcd;
+
+    DECLARE_DUMP;
+
+    SANITY_CHECK_RETURN_ERROR(h_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE);
+
+    if (p_FmPcd->p_FmPcdKg)
+        FM_PCD_KgDumpRegs(h_FmPcd);
+    if (p_FmPcd->p_FmPcdPlcr)
+        FM_PCD_PlcrDumpRegs(h_FmPcd);
+    if (p_FmPcd->p_FmPcdPrs)
+        FM_PCD_PrsDumpRegs(h_FmPcd);
+    return E_OK;
+ }
+#endif /* (defined(DEBUG_ERRORS) && ... */
+#endif /* ! CONFIG_GUEST_PARTITION */
+
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.h b/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.h
new file mode 100644
index 0000000..96043d5
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.h
@@ -0,0 +1,950 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/******************************************************************************
+ @File          fm_pcd.h
+
+ @Description   FM PCD ...
+*//***************************************************************************/
+#ifndef __FM_PCD_H
+#define __FM_PCD_H
+
+#include "std_ext.h"
+#include "error_ext.h"
+#include "list_ext.h"
+#include "fm_pcd_ext.h"
+
+#include "fm_common.h"
+
+
+/**************************************************************************//**
+ @Group         FM_PCD_Runtime_grp FM PCD Runtime Unit
+ @{
+*//***************************************************************************/
+
+/****************************/
+/* General defines          */
+/****************************/
+
+#define GET_FM_PCD_PORTID_FROM_GLOBAL_PORTID(pcdPortId, pcdPortsTable, hardwarePortId)\
+    pcdPortId = 0;\
+    while((hardwarePortId != pcdPortsTable[pcdPortId]) && (pcdPortId<PCD_MAX_NUM_OF_PORTS))\
+        pcdPortId++;
+
+#define PCD_PORTS_TABLE                     {1,2,3,4,5,6,7,8,9,10,11,16}
+#define GET_GLOBAL_PORTID_FROM_PCD_PORTS_TABLE(hardwarePortId, pcdPortsTable,i)\
+    hardwarePortId = pcdPortsTable[i]
+
+
+#define ILLEGAL_PCD_PORTID                  0xFF
+#define ILLEGAL_CLS_PLAN                    0xFF
+
+#define GET_PCD_PORTID_BY_RELATIVE(portId,type,id)      \
+switch(type) {                              \
+    case(e_FM_PORT_TYPE_OFFLINE_PARSING):   \
+        if (id > (LAST_HO_PORTID-BASE_HO_PORTID))       \
+            portId = ILLEGAL_PCD_PORTID;    \
+        else                                \
+            portId = id; break;             \
+     case(e_FM_PORT_TYPE_RX):               \
+        if (id > (LAST_RX_PORTID-BASE_RX_PORTID))       \
+            portId = ILLEGAL_PCD_PORTID;    \
+        else                                \
+            portId = id+MAX_NUM_OF_OP_PORTS;\
+        break;                              \
+      case(e_FM_PORT_TYPE_RX_10G):          \
+        if (id > (LAST_RX10_PORTID-BASE_RX10_PORTID))   \
+            portId = ILLEGAL_PCD_PORTID;    \
+        else                                \
+            portId = id+MAX_NUM_OF_OP_PORTS + MAX_NUM_OF_RX_1G_PORTS;    \
+        break;                              \
+      default:                              \
+        portId = ILLEGAL_PCD_PORTID;        \
+}
+
+#define IS_PRIVATE_HEADER(hdr)              ((hdr == HEADER_TYPE_USER_DEFINED_SHIM1 ) ||   \
+                                            (hdr == HEADER_TYPE_USER_DEFINED_SHIM2) ||    \
+                                            (hdr == HEADER_TYPE_USER_DEFINED_SHIM3))
+
+/****************************/
+/* Error defines           */
+/****************************/
+#define FM_PCD_EX_KG_DOUBLE_ECC                     0x80000000
+#define FM_PCD_EX_KG_KEYSIZE_OVERFLOW               0x40000000
+
+#define FM_PCD_EX_PLCR_DOUBLE_ECC                   0x20000000
+#define FM_PCD_EX_PLCR_INIT_ENTRY_ERROR             0x10000000
+#define FM_PCD_EX_PLCR_PRAM_SELF_INIT_COMPLETE      0x08000000
+#define FM_PCD_EX_PLCR_ATOMIC_ACTION_COMPLETE       0x04000000
+
+#define FM_PCD_EX_PRS_DOUBLE_ECC                    0x02000000
+#define FM_PCD_EX_PRS_SINGLE_ECC                    0x01000000
+#define FM_PCD_EX_PRS_ILLEGAL_ACCESS                0x00800000
+#define FM_PCD_EX_PRS_PORT_ILLEGAL_ACCESS           0x00400000
+
+#define GET_FM_PCD_EXCEPTION_FLAG(bitMask, exception)               \
+switch(exception){                                                  \
+    case e_FM_PCD_KG_ERR_EXCEPTION_DOUBLE_ECC:                      \
+        bitMask = FM_PCD_EX_KG_DOUBLE_ECC; break;                   \
+    case e_FM_PCD_PLCR_ERR_EXCEPTION_DOUBLE_ECC:                    \
+        bitMask = FM_PCD_EX_PLCR_DOUBLE_ECC; break;                 \
+    case e_FM_PCD_KG_ERR_EXCEPTION_KEYSIZE_OVERFLOW:                \
+        bitMask = FM_PCD_EX_KG_KEYSIZE_OVERFLOW; break;             \
+    case e_FM_PCD_PLCR_ERR_EXCEPTION_INIT_ENTRY_ERROR:              \
+        bitMask = FM_PCD_EX_PLCR_INIT_ENTRY_ERROR; break;           \
+    case e_FM_PCD_PLCR_EXCEPTION_PRAM_SELF_INIT_COMPLETE:           \
+        bitMask = FM_PCD_EX_PLCR_PRAM_SELF_INIT_COMPLETE; break;    \
+    case e_FM_PCD_PLCR_EXCEPTION_ATOMIC_ACTION_COMPLETE:            \
+        bitMask = FM_PCD_EX_PLCR_ATOMIC_ACTION_COMPLETE; break;     \
+    case e_FM_PCD_PRS_EXCEPTION_DOUBLE_ECC:                         \
+        bitMask = FM_PCD_EX_PRS_DOUBLE_ECC; break;                  \
+    case e_FM_PCD_PRS_EXCEPTION_ILLEGAL_ACCESS:                     \
+        bitMask = FM_PCD_EX_PRS_ILLEGAL_ACCESS; break;              \
+    case e_FM_PCD_PRS_EXCEPTION_SINGLE_ECC:                         \
+        bitMask = FM_PCD_EX_PRS_SINGLE_ECC; break;                  \
+    case e_FM_PCD_PRS_EXCEPTION_PORT_ILLEGAL_ACCESS:                \
+        bitMask = FM_PCD_EX_PRS_PORT_ILLEGAL_ACCESS; break;         \
+    default: bitMask = 0;break;}
+
+
+/***********************************************************************/
+/*          SW parser L4 shells patch                                  */
+/***********************************************************************/
+#define SW_PRS_L4_PATCH                         \
+{   0x31,0x92,0x02,0x1f,0x00,0x32,0x00,0x78,    \
+    0x00,0x34,0x32,0xf0,0x00,0x50,0x00,0x0c,    \
+    0x28,0x5e,0x83,0x8e,0x29,0x32,0xaf,0x8e,    \
+    0x31,0xb2,0x9f,0xff,0x00,0x06,0xaf,0xbf,    \
+    0x00,0x06,0x29,0x36,0x00,0x01,0x1b,0xff,    \
+    0x32,0xf0,0x00,0x50,0x00,0x08,0x28,0x5e,    \
+    0x08,0x99,0x00,0x00,0x9f,0x8e,0x31,0xb2,    \
+    0x9f,0xff,0x00,0x06,0x29,0x36,0x00,0x01,    \
+    0x1b,0xff,0x32,0xf0,0x00,0x50,0x00,0x04,    \
+    0x28,0x5e,0x8f,0x9e,0x29,0x32,0x31,0xb2,    \
+    0x8f,0xbf,0x00,0x06,0x29,0x36,0x00,0x01,    \
+    0x1b,0xff,0x32,0xf0,0x00,0x50,0x00,0x04,    \
+    0x28,0x5e,0x8f,0x9e,0x29,0x32,0x31,0xb2,    \
+    0x8f,0xbf,0x00,0x06,0x29,0x36,0x00,0x01,    \
+    0x1b,0xff,0x00,0x00,0x00,0x00,0x00,0x00};
+
+#define SW_PRS_L4_PATCH_SIZE                120
+
+/****************************/
+/* Parser defines           */
+/****************************/
+/* masks */
+#define PRS_ERR_CAP                         0x80000000
+#define PRS_ERR_TYPE_DOUBLE                 0x40000000
+#define PRS_ERR_SINGLE_ECC_CNT_MASK         0x00FF0000
+#define PRS_ERR_ADDR_MASK                   0x000001FF
+#define FM_PCD_PRS_RPIMAC_EN                0x00000001
+#define FM_PCD_PRS_SINGLE_ECC               0x00004000
+#define FM_PCD_PRS_PORT_IDLE_STS            0xffff0000
+#define FM_PCD_PRS_DOUBLE_ECC               0x00004000
+#define FM_PCD_PRS_PORT_ILLEGAL_ACCESS      0xffff0000
+#define FM_PCD_PRS_ILLEGAL_ACCESS           0x00008000
+#define FM_PCD_PRS_PPSC_ALL_PORTS           0xffff0000
+
+/* others */
+#define PRS_MAX_CYCLE_LIMIT                 8191
+#define PRS_SW_DATA                         0x00000800
+#define PRS_REGS_OFFSET                     0x00000840
+
+#define GET_FM_PCD_PRS_PORT_ID(prsPortId,hardwarePortId) \
+    prsPortId = (uint8_t)(hardwarePortId & 0x0f)
+
+#define GET_FM_PCD_PORT_ID_FROM_PRS(pcdPortId, prsPortId) \
+    pcdPortId = (prsPortId == 0) ? 0x10:prsPortId;
+
+#define GET_FM_PCD_INDEX_FLAG(bitMask, prsPortId)    \
+    bitMask = 0x80000000>>prsPortId
+
+
+/***********************************************************************/
+/*          Keygen defines                                             */
+/***********************************************************************/
+/* Masks */
+#define FM_PCD_KG_KGGCR_EN                      0x80000000
+#define KG_SCH_GEN_VALID                        0x80000000
+#define KG_SCH_GEN_EXTRACT_TYPE                 0x00008000
+#define KG_ERR_CAP                              0x80000000
+#define KG_ERR_TYPE_DOUBLE                      0x40000000
+#define KG_ERR_ADDR_MASK                        0x00000FFF
+#define FM_PCD_KG_DOUBLE_ECC                    0x80000000
+#define FM_PCD_KG_KEYSIZE_OVERFLOW              0x40000000
+#define KG_SCH_MODE_EN                          0x80000000
+
+/* shifts */
+#define FM_PCD_KG_PE_CPP_MASK_SHIFT             16
+#define FM_PCD_KG_KGAR_WSEL_SHIFT               8
+
+/* others */
+#define KG_DOUBLE_MEANING_REGS_OFFSET           0x100
+#define NO_VALIDATION                           0x70
+#define KG_ACTION_REG_TO                        1024
+#define KG_MAX_PROFILE                          255
+#define SCHEME_ALWAYS_DIRECT                    0xFFFFFFFF
+
+typedef struct {
+    bool        known;
+    uint8_t     id;
+} t_FmPcdKgSchemesExtractsEntry;
+
+typedef struct {
+    t_FmPcdKgSchemesExtractsEntry extractsArray[FM_PCD_KG_MAX_NUM_OF_EXTRACTS_PER_KEY];
+} t_FmPcdKgSchemesExtracts;
+
+/***********************************************************************/
+/*          Policer defines                                            */
+/***********************************************************************/
+
+/* masks */
+#define FM_PCD_PLCR_PEMODE_PI                 0x80000000
+#define FM_PCD_PLCR_PEMODE_CBLND              0x40000000
+#define FM_PCD_PLCR_PEMODE_ALG_MASK           0x30000000
+#define FM_PCD_PLCR_PEMODE_ALG_RFC2698        0x10000000
+#define FM_PCD_PLCR_PEMODE_ALG_RFC4115        0x20000000
+#define FM_PCD_PLCR_PEMODE_DEFC_MASK          0x0C000000
+#define FM_PCD_PLCR_PEMODE_DEFC_Y             0x04000000
+#define FM_PCD_PLCR_PEMODE_DEFC_R             0x08000000
+#define FM_PCD_PLCR_PEMODE_DEFC_OVERRIDE      0x0C000000
+#define FM_PCD_PLCR_PEMODE_OVCLR_MASK         0x03000000
+#define FM_PCD_PLCR_PEMODE_OVCLR_Y            0x01000000
+#define FM_PCD_PLCR_PEMODE_OVCLR_R            0x02000000
+#define FM_PCD_PLCR_PEMODE_OVCLR_G_NC         0x03000000
+#define FM_PCD_PLCR_PEMODE_PKT                0x00800000
+#define FM_PCD_PLCR_PEMODE_FPP_MASK           0x001F0000
+#define FM_PCD_PLCR_PEMODE_FPP_SHIFT          16
+#define FM_PCD_PLCR_PEMODE_FLS_MASK           0x0000F000
+#define FM_PCD_PLCR_PEMODE_FLS_L2             0x00003000
+#define FM_PCD_PLCR_PEMODE_FLS_L3             0x0000B000
+#define FM_PCD_PLCR_PEMODE_FLS_L4             0x0000E000
+#define FM_PCD_PLCR_PEMODE_FLS_FULL           0x0000F000
+#define FM_PCD_PLCR_PEMODE_RBFLS              0x00000800
+#define FM_PCD_PLCR_PEMODE_TRA                0x00000004
+#define FM_PCD_PLCR_PEMODE_TRB                0x00000002
+#define FM_PCD_PLCR_PEMODE_TRC                0x00000001
+#define FM_PCD_PLCR_DOUBLE_ECC                0x80000000
+#define FM_PCD_PLCR_INIT_ENTRY_ERROR          0x40000000
+#define FM_PCD_PLCR_PRAM_SELF_INIT_COMPLETE   0x80000000
+#define FM_PCD_PLCR_ATOMIC_ACTION_COMPLETE    0x40000000
+
+#define FM_PCD_PLCR_NIA_VALID                 0x80000000
+
+#define FM_PCD_PLCR_GCR_EN                    0x80000000
+#define FM_PCD_PLCR_GCR_STEN                  0x40000000
+#define FM_PCD_PLCR_GCR_DAR                   0x20000000
+#define FM_PCD_PLCR_GCR_DEFNIA                0x00FFFFFF
+#define FM_PCD_PLCR_NIA_ABS                   0x00000100
+
+#define FM_PCD_PLCR_GSR_BSY                   0x80000000
+#define FM_PCD_PLCR_GSR_DQS                   0x60000000
+#define FM_PCD_PLCR_GSR_RPB                   0x20000000
+#define FM_PCD_PLCR_GSR_FQS                   0x0C000000
+#define FM_PCD_PLCR_GSR_LPALG                 0x0000C000
+#define FM_PCD_PLCR_GSR_LPCA                  0x00003000
+#define FM_PCD_PLCR_GSR_LPNUM                 0x000000FF
+
+#define FM_PCD_PLCR_EVR_PSIC                  0x80000000
+#define FM_PCD_PLCR_EVR_AAC                   0x40000000
+
+#define FM_PCD_PLCR_PAR_PSI                   0x20000000
+#define FM_PCD_PLCR_PAR_PNUM                  0x00FF0000
+/* PWSEL Selctive select options */
+#define FM_PCD_PLCR_PAR_PWSEL_PEMODE          0x00008000    /* 0 */
+#define FM_PCD_PLCR_PAR_PWSEL_PEGNIA          0x00004000    /* 1 */
+#define FM_PCD_PLCR_PAR_PWSEL_PEYNIA          0x00002000    /* 2 */
+#define FM_PCD_PLCR_PAR_PWSEL_PERNIA          0x00001000    /* 3 */
+#define FM_PCD_PLCR_PAR_PWSEL_PECIR           0x00000800    /* 4 */
+#define FM_PCD_PLCR_PAR_PWSEL_PECBS           0x00000400    /* 5 */
+#define FM_PCD_PLCR_PAR_PWSEL_PEPIR_EIR       0x00000200    /* 6 */
+#define FM_PCD_PLCR_PAR_PWSEL_PEPBS_EBS       0x00000100    /* 7 */
+#define FM_PCD_PLCR_PAR_PWSEL_PELTS           0x00000080    /* 8 */
+#define FM_PCD_PLCR_PAR_PWSEL_PECTS           0x00000040    /* 9 */
+#define FM_PCD_PLCR_PAR_PWSEL_PEPTS_ETS       0x00000020    /* 10 */
+#define FM_PCD_PLCR_PAR_PWSEL_PEGPC           0x00000010    /* 11 */
+#define FM_PCD_PLCR_PAR_PWSEL_PEYPC           0x00000008    /* 12 */
+#define FM_PCD_PLCR_PAR_PWSEL_PERPC           0x00000004    /* 13 */
+#define FM_PCD_PLCR_PAR_PWSEL_PERYPC          0x00000002    /* 14 */
+#define FM_PCD_PLCR_PAR_PWSEL_PERRPC          0x00000001    /* 15 */
+
+#define FM_PCD_PLCR_PAR_PMR_BRN_1TO1          0x0000      /* - Full bit replacement. {PBNUM[0:N-1]
+                                                           1-> 2^N specific locations. */
+#define FM_PCD_PLCR_PAR_PMR_BRN_2TO2          0x1      /* - {PBNUM[0:N-2],PNUM[N-1]}.
+                                                           2-> 2^(N-1) base locations. */
+#define FM_PCD_PLCR_PAR_PMR_BRN_4TO4          0x2      /* - {PBNUM[0:N-3],PNUM[N-2:N-1]}.
+                                                           4-> 2^(N-2) base locations. */
+#define FM_PCD_PLCR_PAR_PMR_BRN_8TO8          0x3      /* - {PBNUM[0:N-4],PNUM[N-3:N-1]}.
+                                                           8->2^(N-3) base locations. */
+#define FM_PCD_PLCR_PAR_PMR_BRN_16TO16        0x4      /* - {PBNUM[0:N-5],PNUM[N-4:N-1]}.
+                                                           16-> 2^(N-4) base locations. */
+#define FM_PCD_PLCR_PAR_PMR_BRN_32TO32        0x5      /* {PBNUM[0:N-6],PNUM[N-5:N-1]}.
+                                                           32-> 2^(N-5) base locations. */
+#define FM_PCD_PLCR_PAR_PMR_BRN_64TO64        0x6      /* {PBNUM[0:N-7],PNUM[N-6:N-1]}.
+                                                           64-> 2^(N-6) base locations. */
+#define FM_PCD_PLCR_PAR_PMR_BRN_128TO128      0x7      /* {PBNUM[0:N-8],PNUM[N-7:N-1]}.
+                                                            128-> 2^(N-7) base locations. */
+#define FM_PCD_PLCR_PAR_PMR_BRN_256TO256      0x8      /* - No bit replacement for N=8. {PNUM[N-8:N-1]}.
+                                                            When N=8 this option maps all 256 profiles by the DISPATCH bus into one group. */
+
+#define FM_PCD_PLCR_PMR_V                     0x80000000
+#define PLCR_ERR_ECC_CAP                      0x80000000
+#define PLCR_ERR_ECC_TYPE_DOUBLE              0x40000000
+#define PLCR_ERR_ECC_PNUM_MASK                0x00000FF0
+#define PLCR_ERR_ECC_OFFSET_MASK              0x0000000F
+
+#define PLCR_ERR_UNINIT_CAP                   0x80000000
+#define PLCR_ERR_UNINIT_NUM_MASK              0x000000FF
+#define PLCR_ERR_UNINIT_PID_MASK              0x003f0000
+#define PLCR_ERR_UNINIT_ABSOLUTE_MASK         0x00008000
+
+/* shifts */
+#define PLCR_ERR_ECC_PNUM_SHIFT               4
+#define PLCR_ERR_UNINIT_PID_SHIFT             16
+
+#define FM_PCD_PLCR_PMR_BRN_SHIFT             16
+
+/* others */
+#define WAIT_FOR_PLCR_EVR_AAC \
+{\
+    uint32_t count = 0; \
+    uint32_t tmpReg32; \
+    while (count < FM_PCD_PLCR_POLL) \
+    { \
+        tmpReg32 = GET_UINT32(p_FmPcdPlcrRegs->fmpl_evr);\
+        if (!( tmpReg32 & FM_PCD_PLCR_EVR_AAC)) break;\
+        count++;\
+    }\
+}
+
+#define WAIT_FOR_PLCR_PAR_GO \
+{\
+    uint32_t count = 0; \
+    uint32_t tmpReg32; \
+    while (count < FM_PCD_PLCR_POLL) \
+    { \
+        tmpReg32 = GET_UINT32(p_FmPcdPlcrRegs->fmpl_par);\
+        if (!( tmpReg32 & FM_PCD_PLCR_PAR_GO)) break;\
+        count++; \
+    }\
+}
+
+#define PLCR_PORT_WINDOW_SIZE(hardwarePortId)
+
+/***********************************************************************/
+/*          Coarse classification defines                              */
+/***********************************************************************/
+
+#define CC_PC_FF_MACDST            0x00
+#define CC_PC_FF_MACSRC            0x01
+#define CC_PC_FF_ETYPE             0x02
+
+#define CC_PC_FF_TCI1              0x03
+#define CC_PC_FF_TCI2              0x04
+
+#define CC_PC_FF_MPLS1             0x06
+#define CC_PC_FF_MPLS_LAST         0x07
+
+#define CC_PC_FF_IPV4DST1          0x08
+#define CC_PC_FF_IPV4DST2          0x16
+#define CC_PC_FF_IPV4IPTOS_TC1     0x09
+#define CC_PC_FF_IPV4IPTOS_TC2     0x17
+#define CC_PC_FF_IPV4PTYPE1        0x0A
+#define CC_PC_FF_IPV4PTYPE2        0x18
+#define CC_PC_FF_IPV4SRC1          0x0b
+#define CC_PC_FF_IPV4SRC2          0x19
+#define CC_PC_FF_IPV4SRC1_IPV4DST1 0x0c
+#define CC_PC_FF_IPV4SRC2_IPV4DST2 0x1a
+#define CC_PC_FF_IPV4TTL           0x29
+
+
+#define CC_PC_FF_IPTOS_IPV6TC1_IPV6FLOW1    0x0d /*TODO - CLASS - what is it? TOS*/
+#define CC_PC_FF_IPTOS_IPV6TC2_IPV6FLOW2    0x1b
+#define CC_PC_FF_IPV6PTYPE1                 0x0e
+#define CC_PC_FF_IPV6PTYPE2                 0x1c
+#define CC_PC_FF_IPV6DST1                   0x0f
+#define CC_PC_FF_IPV6DST2                   0x1d
+#define CC_PC_FF_IPV6SRC1                   0x10
+#define CC_PC_FF_IPV6SRC2                   0x1e
+#define CC_PC_FF_IPV6HOP_LIMIT              0x2a
+#define CC_PC_FF_GREPTYPE                   0x11
+
+#define CC_PC_FF_MINENCAP_PTYPE             0x12
+#define CC_PC_FF_MINENCAP_IPDST             0x13
+#define CC_PC_FF_MINENCAP_IPSRC             0x14
+#define CC_PC_FF_MINENCAP_IPSRC_IPDST       0x15
+
+#define CC_PC_FF_L4PSRC                     0x1f
+#define CC_PC_FF_L4PDST                     0x20
+#define CC_PC_FF_L4PSRC_L4PDST              0x21
+
+#define CC_PC_FF_PPPPID                     0x05
+
+
+#define CC_PC_PR_SHIM1                      0x22
+#define CC_PC_PR_SHIM2                      0x23
+#define CC_PC_PR_SHIM3                      0x24
+
+#define CC_PC_GENERIC_WITHOUT_MASK          0x27
+#define CC_PC_GENERIC_WITH_MASK             0x28
+
+#define CC_PR_OFFSET                        0x25
+#define CC_PR_WITHOUT_OFFSET                0x26
+
+#define CC_PC_PR_ETH_OFFSET                 19
+#define CC_PC_PR_USER_DEFINED_SHIM1_OFFSET  16
+#define CC_PC_PR_USER_DEFINED_SHIM2_OFFSET  17
+#define CC_PC_PR_USER_DEFINED_SHIM3_OFFSET  18
+#define CC_PC_PR_USER_LLC_SNAP_OFFSET       20
+#define CC_PC_PR_VLAN1_OFFSET               21
+#define CC_PC_PR_VLAN2_OFFSET               22
+#define CC_PC_PR_PPPOE_OFFSET               24
+#define CC_PC_PR_MPLS1_OFFSET               25
+#define CC_PC_PR_MPLS_LAST_OFFSET           26
+#define CC_PC_PR_IP1_OFFSET                 27
+#define CC_PC_PR_IP_LAST_OFFSET             28
+#define CC_PC_PR_MINENC_OFFSET              28
+#define CC_PC_PR_L4_OFFSET                  30
+#define CC_PC_PR_GRE_OFFSET                 29
+#define CC_PC_PR_ETYPE_LAST_OFFSET          23
+#define CC_PC_PR_NEXT_HEADER_OFFSET         31
+
+#define CC_PC_ILLEGAL                       0xff
+#define CC_SIZE_ILLEGAL                     0
+
+#define FM_PCD_CC_KEYS_MATCH_TABLE_ALIGN    16
+#define FM_PCD_CC_AD_TABLE_ALIGN            256
+#define FM_PCD_CC_AD_ENTRY_SIZE             16
+#define FM_PCD_CC_NUM_OF_KEYS               255
+
+#define FM_PCD_AD_RESULT_CONTRL_FLOW_TYPE   0x00000000
+#define FM_PCD_AD_RESULT_DATA_FLOW_TYPE     0x80000000
+#define FM_PCD_AD_RESULT_PLCR_DIS           0x20000000
+
+#define FM_PCD_AD_CONT_LOOKUP_TYPE          0x40000000
+#define FM_PCD_AD_CONT_LOOKUP_LCL_MASK      0x00800000
+
+#define FM_PCD_AD_TYPE_MASK                 0xc0000000
+#define FM_PCD_AD_PROFILEID_FOR_CNTRL_SHIFT 16
+
+/****************************/
+/* Defaults                 */
+/****************************/
+#define DEFAULT_plcrAutoRefresh                 FALSE
+#define DEFAULT_prsMaxParseCycleLimit           0
+#define DEFAULT_fmPcdKgErrorExceptions          (FM_PCD_EX_KG_DOUBLE_ECC | FM_PCD_EX_KG_KEYSIZE_OVERFLOW)
+#define DEFAULT_fmPcdPlcrErrorExceptions        (FM_PCD_EX_PLCR_DOUBLE_ECC | FM_PCD_EX_PLCR_INIT_ENTRY_ERROR)
+#define DEFAULT_fmPcdPlcrExceptions             0
+#define DEFAULT_fmPcdPrsErrorExceptions         (FM_PCD_EX_PRS_DOUBLE_ECC  |  FM_PCD_EX_PRS_ILLEGAL_ACCESS | FM_PCD_EX_PRS_PORT_ILLEGAL_ACCESS)
+#define DEFAULT_fmPcdPrsExceptions              FM_PCD_EX_PRS_SINGLE_ECC
+#define DEFAULT_numOfUsedProfilesPerWindow      16
+#define DEFAULT_fmPcdPrsPortIdStatictics        FM_PCD_PRS_PPSC_ALL_PORTS
+#define DEFAULT_numOfSharedPlcrProfiles         4
+
+/***********************************************************************/
+/*          Memory map                                                 */
+/***********************************************************************/
+#ifdef __MWERKS__
+#pragma pack(push,1)
+#endif /*__MWERKS__ */
+#define MEM_MAP_START
+
+
+typedef _Packed struct {
+   volatile uint32_t kgoe_sp;
+   volatile uint32_t kgoe_cpp;
+
+} _PackedType t_FmPcdKgPortConfigRegs;
+
+typedef _Packed struct {
+    volatile uint32_t kgcpe[8];
+} _PackedType t_FmPcdKgClsPlanRegs;
+
+typedef _Packed union {
+    t_FmPcdKgInterModuleSchemeRegs     schemeRegs;
+    t_FmPcdKgPortConfigRegs portRegs;
+    t_FmPcdKgClsPlanRegs    clsPlanRegs;
+} _PackedType u_FmPcdKgIndirectAccessRegs;
+
+typedef _Packed struct {
+    volatile uint32_t kggcr;
+    volatile uint32_t res0;
+    volatile uint32_t res1;
+    volatile uint32_t kgeer;
+    volatile uint32_t kgeeer;
+    volatile uint32_t res2;
+    volatile uint32_t res3;
+    volatile uint32_t kgseer;
+    volatile uint32_t kgseeer;
+    volatile uint32_t kggsr;
+    volatile uint32_t kgtpc;
+    volatile uint32_t kgserc;
+    volatile uint32_t res4[4];
+    volatile uint32_t kgfdor;
+    volatile uint32_t kggdv0r;
+    volatile uint32_t kggdv1r;
+    volatile uint32_t res5[5];
+    volatile uint32_t kgfer;
+    volatile uint32_t kgfeer;
+    volatile uint32_t res6[38];
+    u_FmPcdKgIndirectAccessRegs   indirectAccessRegs;
+    volatile uint32_t res[42];                  /*(0xfc-sizeof(u_FmPcdKgIndirectAccessRegs))/4 */
+    volatile uint32_t kgar;
+} _PackedType t_FmPcdKgRegs;
+
+typedef _Packed struct {
+/* General Configuration and Status Registers */
+    volatile uint32_t fmpl_gcr;         /* 0x000 FMPL_GCR  - FM Policer General Configuration */
+    volatile uint32_t fmpl_gsr;         /* 0x004 FMPL_GSR  - FM Policer Global Status Register */
+    volatile uint32_t fmpl_evr;         /* 0x008 FMPL_EVR  - FM Policer Event Register */
+    volatile uint32_t fmpl_ier;         /* 0x00C FMPL_IER  - FM Policer Interrupt Enable Register */
+    volatile uint32_t fmpl_ifr;         /* 0x010 FMPL_IFR  - FM Policer Interrupt Force Register */
+    volatile uint32_t fmpl_eevr;        /* 0x014 FMPL_EEVR - FM Policer Error Event Register */
+    volatile uint32_t fmpl_eier;        /* 0x018 FMPL_EIER - FM Policer Error Interrupt Enable Register */
+    volatile uint32_t fmpl_eifr;        /* 0x01C FMPL_EIFR - FM Policer Error Interrupt Force Register */
+/* Global Statistic Counters */
+    volatile uint32_t fmpl_rpcnt;       /* 0x020 FMPL_RPC  - FM Policer RED Packets Counter */
+    volatile uint32_t fmpl_ypcnt;       /* 0x024 FMPL_YPC  - FM Policer YELLOW Packets Counter */
+    volatile uint32_t fmpl_rrpcnt;      /* 0x028 FMPL_RRPC - FM Policer Recolored RED Packet Counter */
+    volatile uint32_t fmpl_rypcnt;      /* 0x02C FMPL_RYPC - FM Policer Recolored YELLOW Packet Counter */
+    volatile uint32_t fmpl_tpcnt;       /* 0x030 FMPL_TPC  - FM Policer Total Packet Counter */
+    volatile uint32_t fmpl_flmcnt;      /* 0x034 FMPL_FLMC - FM Policer Frame Length Mismatch Counter */
+    volatile uint32_t fmpl_res0[21];    /* 0x038 - 0x08B Reserved */
+/* Profile RAM Access Registers */
+    volatile uint32_t fmpl_par;         /* 0x08C FMPL_PAR    - FM Policer Profile Action Register*/
+    t_FmPcdPlcrInterModuleProfileRegs profileRegs;
+/* Error Capture Registers */
+    volatile uint32_t fmpl_serc;        /* 0x100 FMPL_SERC - FM Policer Soft Error Capture */
+    volatile uint32_t fmpl_upcr;        /* 0x104 FMPL_UPCR - FM Policer Uninitialized Profile Capture Register */
+    volatile uint32_t fmpl_res2;        /* 0x108 Reserved */
+/* Debug Registers */
+    volatile uint32_t fmpl_res3[61];    /* 0x10C-0x200 Reserved Debug*/
+/* Profile Selection Mapping Registers Per Port-ID (n=1-11, 16) */
+    volatile uint32_t fmpl_dpmr;        /* 0x200 FMPL_DPMR - FM Policer Default Mapping Register */
+    volatile uint32_t fmpl_pmr[63];     /*+default 0x204-0x2FF FMPL_PMR1 - FMPL_PMR63, - FM Policer Profile Mapping Registers.
+                                           (for port-ID 1-11, only for supported Port-ID registers) */
+} _PackedType t_FmPcdPlcrRegs;
+
+typedef _Packed struct {
+    volatile uint32_t rpclim;
+    volatile uint32_t rpimac;
+    volatile uint32_t pmeec;
+    volatile uint32_t res1[5];
+    volatile uint32_t pevr;
+    volatile uint32_t pever;
+    volatile uint32_t pevfr;
+    volatile uint32_t perr;
+    volatile uint32_t perer;
+    volatile uint32_t perfr;
+    volatile uint32_t res2[0xA];
+    volatile uint32_t ppsc;
+    volatile uint32_t res3;
+    volatile uint32_t pds;
+    volatile uint32_t l2rrs;
+    volatile uint32_t l3rrs;
+    volatile uint32_t l4rrs;
+    volatile uint32_t srrs;
+    volatile uint32_t l2rres;
+    volatile uint32_t l3rres;
+    volatile uint32_t l4rres;
+    volatile uint32_t srres;
+    volatile uint32_t spcs;
+    volatile uint32_t spscs;
+    volatile uint32_t hxscs;
+    volatile uint32_t mrcs;
+    volatile uint32_t mwcs;
+    volatile uint32_t mrscs;
+    volatile uint32_t mwscs;
+    volatile uint32_t fcscs;
+} _PackedType t_FmPcdPrsRegs;
+
+typedef _Packed struct {
+    volatile uint32_t fqid;
+    volatile uint32_t plcrProfile;
+    volatile uint32_t nia;
+    volatile uint8_t  res[4];
+} _PackedType t_AdOfTypeResult;
+
+typedef _Packed struct {
+    volatile uint32_t ccAdBase;
+    volatile uint32_t matchTblPtr;
+    volatile uint32_t pcAndOffsets;
+    volatile uint32_t gmask;
+} _PackedType t_AdOfTypeContLookup;
+
+typedef _Packed union {
+    volatile t_AdOfTypeResult        adResult;
+    volatile t_AdOfTypeContLookup    adContLookup;
+} _PackedType t_Ad;
+
+#define MEM_MAP_END
+#ifdef __MWERKS__
+#pragma pack(pop)
+#endif /* __MWERKS__ */
+
+/***********************************************************************/
+/*  Driver's internal structures                                        */
+/***********************************************************************/
+
+/**************************************************************************//**
+ @Description   Structure for PLCR profile parameters.
+                Fields commented 'IN' are passed by the port module to be used
+                by the FM module.
+                Fields commented 'OUT' will be filled by FM before returning to port.
+*//***************************************************************************/
+
+#if 0
+typedef struct t_FmPcdPlcrProfileGetParams {
+    uint16_t        relativeProfileId;                  /* IN/OUT: get the user policer profile id.
+                                                   Depending on 'isAbsolute' below, return
+                                                   either the relative or absolute profile */
+
+    bool            isAbsolute;                 /* OUT: Return true if the profile is abosulte else port based */
+    uint8_t         hardwarePortId;             /* OUT: Global port id, must be cleared if called by a
+                                                   non-port (KG, CC). */
+} t_FmPcdPlcrProfileGetParams;
+#endif /* 0 */
+
+typedef struct
+{
+    t_Handle         p_Ad;
+    e_FmPcdEngine    fmPcdEngine;
+    bool             adAllocated;
+    bool             isTree;
+
+//    bool        isCcNextEngine;
+    //uint32_t    nextEngineInfo;
+    uint32_t    myInfo;
+    t_List      *h_CcNextNodesLst;
+    t_Handle    h_AdditionalInfo;
+    t_Handle    h_Node;
+}t_FmPcdModifyCcAdditionalParams;
+
+typedef struct
+{
+    t_Handle p_AdTableNew;
+    t_Handle p_KeysMatchTableNew;
+    t_Handle p_AdTableOld;
+    t_Handle p_KeysMatchTableOld;
+    bool     lclMask;
+    uint16_t  numOfKeys;
+    t_Handle h_CurrentNode;
+    uint16_t nodeIdForAdd;
+    uint16_t keyIndexForRemove;
+    uint16_t keyIndexForAdd;
+}t_FmPcdModifyCcKeyAdditionalParams;
+
+typedef struct {
+    uint16_t    numOfKeys;
+    t_Handle    p_GlblMask;
+    bool        lclMask;
+    uint8_t     parseCode;
+    uint8_t     offset;
+    uint8_t     prsArrayOffset;
+    bool        ctrlFlow;
+    uint16_t    nodeId;
+
+    uint8_t     ccKeySizeAccExtraction;
+    uint8_t     sizeOfExtraction;
+    uint8_t     glblMaskSize;
+
+    t_Handle    h_KeysMatchTable;
+    t_Handle    h_AdTable;
+
+    t_List      ccNextNodesLst;
+    t_List      ccPrevNodesLst;
+
+    t_List      ccTreeIdLst;
+    t_List      ccTreesLst;
+} t_FmPcdCcNode;
+
+typedef struct {
+    volatile bool       lock;
+    bool                used;
+    uint8_t             owners;
+    uint8_t             netEnvId;
+#ifdef CONFIG_MULTI_PARTITION_SUPPORT
+    uint8_t             partitionId;
+#endif /* CONFIG_MULTI_PARTITION_SUPPORT */
+    uint8_t             baseEntry;
+    uint16_t            sizeOfGrp;
+    protocolOpt_t       optArray[MAX_NUM_OF_OPTIONS];
+} t_FmPcdKgClsPlanGrp;
+
+typedef struct {
+    volatile bool       lock;
+    bool                valid;
+    uint8_t             netEnvId;
+    uint8_t             owners;
+    uint32_t            matchVector;
+    uint32_t            ccUnits;
+    bool                nextRelativePlcrProfile;
+    uint16_t            relativeProfileId;
+    uint16_t            numOfProfiles;
+} t_FmPcdKgScheme;
+
+#ifndef CONFIG_GUEST_PARTITION
+typedef struct
+{
+    bool    allocated;
+    uint8_t ownerId;    /* partitionId for KG in CONFIG_MULTI_PARTITION_SUPPORT only,
+                           portId for PLCR in any environment */
+} t_FmPcdAllocMng;
+#endif /* CONFIG_GUEST_PARTITION */
+
+typedef struct {
+#ifndef CONFIG_GUEST_PARTITION
+    t_FmPcdKgRegs                   *p_FmPcdKgRegs;
+    uint32_t                        schemeExceptionsBitMask;
+#endif
+    uint8_t                         numOfSchemes;
+    uint8_t                         schemesIds[FM_PCD_KG_NUM_OF_SCHEMES];
+    t_FmPcdKgScheme                 schemes[FM_PCD_KG_NUM_OF_SCHEMES];
+    t_FmPcdKgClsPlanGrp             clsPlanGrps[PCD_MAX_NUM_OF_PORTS];
+    bool                            clsPlanUsedBlocks[FM_PCD_MAX_NUM_OF_CLS_PLANS/CLS_PLAN_NUM_PER_GRP];
+    bool                            isDriverEmptyClsPlanGrp;
+    uint8_t                         emptyClsPlanGrpId;
+    uint16_t                        numOfClsPlanEntries;
+    uint8_t                         clsPlanBase;
+
+#ifdef FM_MASTER_PARTITION
+    t_FmPcdAllocMng                 schemesMng[FM_PCD_KG_NUM_OF_SCHEMES];
+    t_FmPcdAllocMng                 clsPlanBlocksMng[FM_PCD_MAX_NUM_OF_CLS_PLANS/CLS_PLAN_NUM_PER_GRP];
+#endif  /* FM_MASTER_PARTITION */
+} t_FmPcdKg;
+
+
+typedef struct {
+    uint16_t profilesBase;
+    uint16_t numOfProfiles;
+    t_Handle h_FmPort;
+} t_FmPcdPlcrMapParam;
+
+typedef struct {
+    bool                valid;
+    volatile bool       lock;
+#ifndef CONFIG_GUEST_PARTITION
+    t_FmPcdAllocMng     profilesMng;
+#endif /* ! CONFIG_GUEST_PARTITION */
+} t_FmPcdPlcrProfile;
+
+typedef struct {
+#ifndef CONFIG_GUEST_PARTITION
+    t_FmPcdPlcrRegs                 *p_FmPcdPlcrRegs;
+#endif /* ! CONFIG_GUEST_PARTITION */
+    t_FmPcdPlcrProfile              profiles[FM_PCD_PLCR_NUM_ENTRIES];
+    uint16_t                        numOfSharedProfiles;
+    uint16_t                        sharedProfilesIds[FM_PCD_PLCR_NUM_ENTRIES];
+    t_FmPcdPlcrMapParam             portsMapping[PCD_MAX_NUM_OF_PORTS];
+} t_FmPcdPlcr;
+
+typedef struct {
+#ifndef CONFIG_GUEST_PARTITION
+    uint32_t                        *p_SwPrsCode;
+    uint32_t                        *p_CurrSwPrs;
+    uint8_t                         currLabel;
+    t_FmPcdPrsRegs                  *p_FmPcdPrsRegs;
+#endif /* ! CONFIG_GUEST_PARTITION */
+    t_FmPcdPrsLabelParams           labelsTable[FM_PCD_PRS_NUM_OF_LABELS];
+    uint32_t                        fmPcdPrsPortIdStatistics;
+} t_FmPcdPrs;
+
+typedef struct {
+    t_FmPcdCcNode   *p_FmPcdCcNode;
+    bool            occupied;
+    uint8_t         owners;
+    volatile bool   lock;
+} t_FmPcdCcNodeArray;
+
+typedef struct {
+    uint32_t indexInGroupParam;
+} t_FmPcdCcGroupAdditionalParam;
+
+typedef struct {
+    uint8_t     numOfEntriesInGroup;
+    uint32_t    totalBitsMask;
+    uint8_t     baseGroupEntry;
+} t_FmPcdCcGroupParam;
+
+typedef struct {
+    uint8_t             netEnvId;
+    t_Handle            p_CcBaseTree;
+    uint8_t             numOfGrps;
+    t_FmPcdCcGroupParam fmPcdGroupParam[8];
+    t_List              ccNextNodesLst;
+    t_List              fmPortsLst;
+    uint8_t             treeId;
+    volatile bool       lock;
+} t_FmPcdCcTree;
+
+#if 0
+typedef struct
+{
+    uint32_t nextCcNodeInfo;
+    t_List   h_Node;
+}t_CcNodeInfo;
+#endif
+typedef struct
+{
+   e_FmPcdEngine  fmPcdEngine;
+   uint32_t       additionalInfo;
+}t_NextEngineParamsInfo;
+
+typedef struct {
+    t_FmPcdCcTree   *p_FmPcdCcTree;
+    bool            occupied;
+    uint8_t         owners;
+    volatile bool   lock;
+} t_FmPcdCcTreeArray;
+
+typedef struct {
+    t_Handle               h_FmMuram;
+    t_FmPcdCcNodeArray     ccNodeArrayEntry[MAX_NUM_OF_PCD_CC_NODES];
+    t_FmPcdCcTreeArray     ccTreeArrayEntry[MAX_NUM_OF_PCD_CC_TREES];
+    uint64_t               physicalMuramBase;
+} t_FmPcdCc;
+
+typedef struct {
+    struct {
+        e_NetHeaderType    hdr;
+        protocolOpt_t      opt;        /* only one option !! */
+    } hdrs[FM_PCD_MAX_NUM_OF_INTERCHANGABLE_HDRS];
+} t_FmPcdIntDistinctionUnit;
+
+typedef struct {
+    volatile bool               lock;
+    bool                        used;
+    uint8_t                     owners;
+    t_FmPcdIntDistinctionUnit   units[FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS];
+    uint32_t                    unitsVectors[FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS];
+    uint32_t                    lcvs[FM_PCD_PRS_NUM_OF_HDRS];
+} t_FmPcdNetEnv;
+
+typedef struct {
+    bool                        plcrAutoRefresh;
+
+    uint16_t                    prsMaxParseCycleLimit;
+} t_FmPcdDriverParam;
+
+typedef struct {
+    t_Handle                    h_Fm;
+    volatile bool               lock;
+    bool                        enabled;
+#ifdef CONFIG_MULTI_PARTITION_SUPPORT
+    uint8_t                     partitionId;            /**< Guest Partition Id */
+#endif /* CONFIG_MULTI_PARTITION_SUPPORT */
+    char                        fmPcdModuleName[MODULE_NAME_SIZE];
+
+    t_FmPcdNetEnv               netEnvs[PCD_MAX_NUM_OF_PORTS+1]; /* +1 for the private netenv used for clsPlan */
+    t_FmPcdKg                   *p_FmPcdKg;
+    t_FmPcdPlcr                 *p_FmPcdPlcr;
+    t_FmPcdPrs                  *p_FmPcdPrs;
+    t_FmPcdCc                   *p_FmPcdCc;
+
+    t_Handle                    h_Hc;
+
+#ifndef CONFIG_GUEST_PARTITION
+    uint32_t                    exceptions;
+    t_FmPcdException            *f_FmPcdException;
+    t_FmPcdIdException          *f_FmPcdIndexedException;
+    t_Handle                    h_App;
+#endif /* !CONFIG_GUEST_PARTITION */
+
+    t_FmPcdDriverParam          *p_FmPcdDriverParam;
+} t_FmPcd;
+
+
+/***********************************************************************/
+/*  PCD internal routines                                              */
+/***********************************************************************/
+/**************************************************************************//**
+ @Description   A structure of parameters to communicate
+                between the port and PCD regarding the KG scheme.
+*//***************************************************************************/
+typedef struct {
+    uint8_t                     netEnvId;    /* in */
+    uint8_t                     numOfDistinctionUnits; /* in */
+    uint8_t                     unitIds[FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS]; /* in */
+    uint32_t                    vector; /* out */
+} t_NetEnvParams;
+
+/**************************************************************************//**
+
+ @Group         FM_PCD_InterModule_grp FM PCD Inter-Module Unit
+
+ @Description   FM PCD Inter Module functions -
+                These are not User API routines but routines that may be called
+                from other modules. This will be the case in a single core environment,
+                where instead of useing the XX messeging mechanism, the routines may be
+                called from other modules. In a multicore environment, the other modules may
+                be run by other cores and therefor these routines may not be called directly.
+
+ @{
+*//***************************************************************************/
+
+t_Error     PcdGetUnitsVector(t_FmPcd *p_FmPcd, t_NetEnvParams *p_Params);
+t_Error     PcdGetVectorForOpt(t_FmPcd *p_FmPcd, uint8_t netEnvId, protocolOpt_t opt, uint32_t *p_Vector);
+bool        PcdNetEnvIsUnitWithoutOpts(t_FmPcd *p_FmPcd, uint8_t netEnvId, uint32_t unitVector);
+
+t_Handle    KgConfig( t_FmPcd *p_FmPcd, t_FmPcdParams *p_FmPcdParams);
+t_Error     KgInit(t_FmPcd *p_FmPcd);
+void        KgSetClsPlan(t_Handle h_FmPcd, t_FmPcdKgInterModuleClsPlanSet *p_Set);
+bool        KgIsSchemeAlwaysDirect(t_Handle h_FmPcd, uint8_t schemeId);
+t_Error     KgEnable(t_FmPcd *p_FmPcd);
+
+#ifdef CONFIG_MULTI_PARTITION_SUPPORT
+t_Error     FmPcdKgAllocSchemes(t_Handle h_FmPcd, uint8_t numOfSchemes, uint8_t partitionId, uint8_t *p_SchemesIds);
+t_Error     FmPcdKgFreeSchemes(t_Handle h_FmPcd, uint8_t numOfSchemes, uint8_t partitionId, uint8_t *p_SchemesIds);
+t_Error     FmPcdKgAllocClsPlanEntries(t_Handle h_FmPcd, uint16_t numOfClsPlanEntries, uint8_t partitionId, uint8_t *p_First);
+t_Error     FmPcdKgFreeClsPlanEntries(t_Handle h_FmPcd, uint16_t numOfClsPlanEntries, uint8_t partitionId, uint8_t base);
+#else /* single */
+t_Error     KgBindPortToSchemes(t_Handle h_FmPcd , uint8_t hardwarePortId, uint32_t spReg);
+#endif /* CONFIG_MULTI_PARTITION_SUPPORT */
+
+t_Handle    PlcrConfig(t_FmPcd *p_FmPcd, t_FmPcdParams *p_FmPcdParams);
+t_Error     PlcrInit(t_FmPcd *p_FmPcd);
+t_Error     PlcrEnable(t_FmPcd *p_FmPcd);
+t_Error     PlcrFreeProfiles(t_FmPcd *p_FmPcd, uint8_t hardwarePortId, uint16_t num, uint16_t base);
+t_Error     PlcrAllocProfiles(t_FmPcd *p_FmPcd, uint8_t hardwarePortId, uint16_t numOfProfiles, uint16_t *p_Base);
+t_Error     PlcrAllocSharedProfiles(t_FmPcd *p_FmPcd, uint16_t numOfProfiles, uint16_t *profilesIds);
+void        PlcrFreeSharedProfiles(t_FmPcd *p_FmPcd, uint16_t numOfProfiles, uint16_t *profilesIds);
+
+t_Handle    PrsConfig(t_FmPcd *p_FmPcd,t_FmPcdParams *p_FmPcdParams);
+t_Error     PrsInit(t_FmPcd *p_FmPcd);
+t_Error     PrsEnable(t_FmPcd *p_FmPcd);
+
+t_Handle    CcConfig(t_FmPcd *p_FmPcd, t_FmPcdParams *p_FmPcdParams);
+void        CcFree(t_FmPcdCc *p_FmPcdCc);
+t_Error     CcGetGrpParams(t_Handle treeId, uint8_t grpId, uint32_t *p_GrpBits, uint8_t *p_GrpBase);
+
+
+#endif /* __FM_PCD_H */
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd_ipc.h b/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd_ipc.h
new file mode 100644
index 0000000..e8b1da0
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd_ipc.h
@@ -0,0 +1,227 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**************************************************************************//**
+ @File          fm_pcd_ipc.h
+
+ @Description   FM PCD Inter-Partition prototypes, structures and definitions.
+*//***************************************************************************/
+#ifndef __FM_PCD_IPC_H
+#define __FM_PCD_IPC_H
+
+#include "error_ext.h"
+#include "std_ext.h"
+#include "net_ext.h"
+
+
+/**************************************************************************//**
+ @Group         FM_grp Frame Manager API
+
+ @Description   FM API functions, definitions and enums
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Group         FM_PCD_IPC_grp FM PCD Inter-Partition messaging Unit
+
+ @Description   FM PCD Inter-Partition messaging unit API definitions and enums.
+
+ @{
+*//***************************************************************************/
+#define FM_PCD_PLCR_NUM_ENTRIES                     256
+#define FM_PCD_IPC_MAX_NUM_OF_DISTINCTION_UNITS     32
+#define FM_PCD_IPC_KG_NUM_OF_SCHEMES                32
+
+/**************************************************************************//**
+ @Collection    General PCD defines
+*//***************************************************************************/
+typedef uint32_t fmPcdIpcEngines_t; /**< options as defined below: */
+
+#define FM_PCD_IPC_NONE                 0                   /**< No PCD Engine indicated */
+#define FM_PCD_IPC_PRS                  0x80000000          /**< Parser indicated */
+#define FM_PCD_IPC_KG                   0x40000000          /**< Keygen indicated */
+#define FM_PCD_IPC_CC                   0x20000000          /**< Coarse classification indicated */
+#define FM_PCD_IPC_PLCR                 0x10000000          /**< Policer indicated */
+/* @} */
+/**************************************************************************//**
+ @Description   struct for defining port PCD modes
+*//***************************************************************************/
+
+
+/**************************************************************************//**
+ @Description   Structure for getting a sw parser address according to a label
+                Fields commented 'IN' are passed by the port module to be used
+                by the FM module.
+                Fields commented 'OUT' will be filled by FM before returning to port.
+*//***************************************************************************/
+typedef struct
+{
+    e_NetHeaderType         hdr;                            /**< IN. The existance of this header will envoke
+                                                                 the sw parser code. */
+    uint8_t                 indexPerHdr;                    /**< IN. Normally 0, if more than one sw parser
+                                                                 attachments for the same header, use this
+                                                                 index to distinguish between them. */
+    uint32_t                offset;                         /**< OUT. MURAM offset for the labeled code. */
+}t_FmPcdIpcSwPrsLable;
+
+/**************************************************************************//**
+ @Description   Structure for port-PCD communication.
+                Fields commented 'IN' are passed by the port module to be used
+                by the FM module.
+                Fields commented 'OUT' will be filled by FM before returning to port.
+                Some fields are optional (depending on configuration) and
+                will be analized by the port and FM modules accordingly.
+*//***************************************************************************/
+
+
+/**************************************************************************//**
+ @Description   Structure for port-PCD communication.
+                Fields commented 'IN' are passed by the port module to be used
+                by the FM module.
+                Fields commented 'OUT' will be filled by FM before returning to port.
+                Some fields are optional (depending on configuration) and
+                will be analized by the port and FM modules accordingly.
+*//***************************************************************************/
+
+
+typedef struct
+{
+    uint8_t     partitionId;                                /**< IN */
+    uint8_t     numOfSchemes;                               /**< IN */
+    uint8_t     schemesIds[FM_PCD_IPC_KG_NUM_OF_SCHEMES];   /**< OUT */
+    uint16_t    numOfClsPlanEntries;                        /**< IN */
+    uint8_t     clsPlanBase;                                /**< OUT */
+    bool        isDriverClsPlanGrp;                         /**< IN */
+} t_FmPcdIpcKgAllocParams;
+
+typedef struct
+{
+    uint16_t num;
+    uint8_t  hardwarePortId;
+    uint16_t plcrProfilesBase;
+} t_FmPcdIpcPlcrAllocParams;
+
+typedef struct
+{
+    uint16_t    num;                                    /**< IN */
+    uint16_t    profilesIds[FM_PCD_PLCR_NUM_ENTRIES];   /**< OUT */
+} t_FmPcdIpcSharedPlcrAllocParams;
+
+#ifdef __MWERKS__
+#pragma pack(push,1)
+#endif /*__MWERKS__ */
+#define MEM_MAP_START
+
+typedef _Packed struct t_FmPcdIcPhysAddr
+{
+    volatile uint16_t high;
+    volatile uint32_t low;
+}_PackedType t_FmPcdIcPhysAddr;
+
+#define MEM_MAP_END
+#ifdef __MWERKS__
+#pragma pack(pop)
+#endif /* __MWERKS__ */
+
+/**************************************************************************//**
+ @Function      FM_PCD_GET_SET_PORT_PARAMS
+
+ @Description   Used by FM PORT module in order to check whether
+                an FM port is stalled.
+
+ @Param[in/out] t_FmPcdIcPortInitParams
+
+*//***************************************************************************/
+#define FM_PCD_GET_SET_PORT_PARAMS              20
+/**************************************************************************//**
+ @Function      FM_PCD_CLEAR_PORT_PARAMS
+
+ @Description   Used by FM PORT module in order to free port's PCD resources
+
+ @Param[in/out] t_FmPcdIcPortInitParams
+
+*//***************************************************************************/
+#define FM_PCD_CLEAR_PORT_PARAMS                21
+
+#define FM_PCD_ALLOC_KG_RSRC                    22
+#define FM_PCD_FREE_KG_RSRC                     23
+#define FM_PCD_ALLOC_PROFILES                   24
+#define FM_PCD_FREE_PROFILES                    25
+#define FM_PCD_GET_PHYS_MURAM_BASE              26
+/**************************************************************************//**
+ @Function      FM_PCD_GET_SW_PRS_OFFSET
+
+ @Description   Used by FM PORT module to get the SW parser offset of the start of
+                code relevant to a given label..
+
+ @Param[in/out] t_FmPcdIcSwPrsLable
+
+*//***************************************************************************/
+#define FM_PCD_GET_SW_PRS_OFFSET                27
+
+#define FM_PCD_ALLOC_SHARED_PROFILES            28
+#define FM_PCD_FREE_SHARED_PROFILES             29
+/**************************************************************************//**
+ @Function      FM_PCD_GET_SET_KG_SCHEME_HC_PARAMS
+
+ @Description   Used by FM HC module to get and set keygen scheme parameters
+
+ @Param[in/out] t_FmPcdIcKgSchemeParams
+
+*//***************************************************************************/
+#define FM_PCD_GET_SET_KG_SCHEME_HC_PARAMS      30
+
+/**************************************************************************//**
+ @Function      FM_PCD_FREE_KG_SCHEME_HC
+
+ @Description   Used by FM HC  module in order to update owners counter
+                if PCD Network environment.
+
+ @Param[in]     scheme id
+
+*//***************************************************************************/
+#define FM_PCD_FREE_KG_SCHEME_HC                31
+
+#define FM_PCD_MASTER_IS_ALIVE                  32
+
+#define FM_PCD_FREE_PLCR_PROFILE_HC             33
+
+#define FM_PCD_ALLOC_CLS_PLAN_EMPTY_GRP         34
+
+#define FM_PCD_MASTER_IS_ENABLED                35
+
+/** @} */ /* end of FM_PCD_IPC_grp group */
+/** @} */ /* end of FM_grp group */
+
+
+#endif /* __FM_PCD_IPC_H */
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_plcr.c b/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_plcr.c
new file mode 100644
index 0000000..51fcbad
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_plcr.c
@@ -0,0 +1,1434 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/******************************************************************************
+ @File          fm_plcr.c
+
+ @Description   FM PCD POLICER...
+*//***************************************************************************/
+#include "std_ext.h"
+#include "error_ext.h"
+#include "string_ext.h"
+#include "debug_ext.h"
+#include "net_ext.h"
+#include "fm_ext.h"
+#include "fm_pcd.h"
+#include "fm_hc.h"
+
+
+static bool    FmPcdPlcrIsProfileShared(t_Handle h_FmPcd, uint16_t absoluteProfileId)
+{
+    t_FmPcd         *p_FmPcd            = (t_FmPcd*)h_FmPcd;
+    uint16_t        i;
+
+    SANITY_CHECK_RETURN_VALUE(p_FmPcd, E_INVALID_HANDLE, FALSE);
+
+    for(i=0;i<p_FmPcd->p_FmPcdPlcr->numOfSharedProfiles;i++)
+        if(p_FmPcd->p_FmPcdPlcr->sharedProfilesIds[i] == absoluteProfileId)
+            return TRUE;
+    return FALSE;
+}
+
+static t_Error SetProfileNia(t_FmPcd *p_FmPcd, e_FmPcdEngine nextEngine, u_FmPcdPlcrNextEngineParams *p_NextEngineParams, uint32_t *nextAction)
+{
+    uint32_t    nia;
+    uint16_t    absoluteProfileId = (uint16_t)(CAST_POINTER_TO_UINT32(p_NextEngineParams->h_Profile)-1);
+    uint8_t     relativeSchemeId, physicatSchemeId;
+
+    nia = FM_PCD_PLCR_NIA_VALID;
+
+    switch (nextEngine)
+    {
+        case e_FM_PCD_DONE :
+            switch (p_NextEngineParams->action)
+            {
+                case e_FM_PCD_PLCR_DROP_FRAME :
+                    nia |= (NIA_ENG_BMI | NIA_BMI_AC_DISCARD);
+                    break;
+                case e_FM_PCD_PLCR_ENQ_FRAME:
+                    nia |= (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME);
+                    break;
+                default:
+                    RETURN_ERROR(MAJOR, E_INVALID_SELECTION, NO_MSG);
+            }
+            break;
+        case e_FM_PCD_KG:
+            physicatSchemeId = (uint8_t)(CAST_POINTER_TO_UINT32(p_NextEngineParams->h_DirectScheme)-1);
+            relativeSchemeId = FmPcdKgGetRelativeSchemeId(p_FmPcd, physicatSchemeId);
+            if(relativeSchemeId == FM_PCD_KG_NUM_OF_SCHEMES)
+                RETURN_ERROR(MAJOR, E_NOT_IN_RANGE, NO_MSG);
+            if (!FmPcdKgIsSchemeValidSw(p_FmPcd, relativeSchemeId))
+                 RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid direct scheme."));
+            if(!KgIsSchemeAlwaysDirect(p_FmPcd, relativeSchemeId))
+                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Policer Profile may point only to a scheme that is always direct."));
+            nia |= NIA_ENG_KG | NIA_KG_DIRECT | physicatSchemeId;
+            break;
+        case e_FM_PCD_PLCR:
+             if(!FmPcdPlcrIsProfileShared(p_FmPcd, absoluteProfileId))
+               RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Next profile must be a shared profile"));
+             if(!FmPcdPlcrIsProfileValid(p_FmPcd, absoluteProfileId))
+               RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid profile "));
+            nia |= NIA_ENG_PLCR | NIA_PLCR_ABSOLUTE | absoluteProfileId;
+            break;
+        default:
+            RETURN_ERROR(MAJOR, E_INVALID_SELECTION, NO_MSG);
+    }
+
+    *nextAction =  nia;
+
+    return E_OK;
+}
+
+static uint32_t FPP_Function(uint32_t fpp)
+{
+    if(fpp > 15)
+        return 15 - (0x1f - fpp);
+    else
+        return 16 + fpp;
+}
+
+static uint64_t Rate2Sample(e_FmPcdPlcrRateMode rateMode, uint32_t rate, uint64_t timeStampPeriod, uint32_t count)
+{
+uint64_t temp;
+uint32_t tmp;
+
+    tmp = FPP_Function(count);
+    if (rateMode == e_FM_PCD_PLCR_BYTE_MODE)
+    {
+        temp = ((uint64_t)rate) << (16+tmp);    /* Move it left 16 Bit to the fix point position
+                                             + 16 Bit to set the time stamp period */
+        temp = temp / 1000000000;         /* Change it from KBit/sec into KBit/(Nano Sec) */
+        temp = (temp * 1000) / 8;         /* Change it from KBit/(Nano Sec) into Byte/(Nano Sec) */
+        temp =  temp / (timeStampPeriod); /* Change it from Byte/(Nano Sec) into Byte/TimeStamp Units*/
+    }
+    else
+    {
+        temp = ((uint64_t)rate) << (16+tmp);  /* Move it left 16 bit to the fix point position
+                                           + 16 Bit to set the time stamp period */
+        temp = temp / 1000000000;       /* Change it from Packet/sec into Packet/(Nano Sec) */
+        temp =  temp / (timeStampPeriod); /* Change it from Packet/Nano into Packet/TimeStamp */
+    }
+
+    return temp;
+
+}
+
+
+static void CheckValidRateRange(t_FmPcd *p_FmPcd)
+{
+    uint64_t    timeStampPeriod;
+//    uint64_t    maxVal = 0xffffffff0000LL; /* [bytes per timeStamp unit] max value which will be legal  for fpp adjustement calculation - for not being "too big"*/
+    uint32_t    minVal = 0x00010000;     /*  [bytes per timeStamp unit] min value which will be legal  for fpp adjustement calculation - for not being "too small"*/
+//    uint64_t    tempMaxLimit;
+    uint64_t    tempMinLimit;
+
+    timeStampPeriod = (uint64_t)FmGetTimeStampPeriod(p_FmPcd->h_Fm);               /* TimeStamp per nano seconds units */
+
+    /*With current timestamp configuration there can not be a MaxLimit,
+      which means that any rate above MinLimit can be served by Policer*/
+    /*transform  [bytes per timeStamp unit] into  [Kbit/s]*/
+    //tempMaxLimit = maxVal * timeStampPeriod;   /*[Byte/TimeStamp] -> [Byte/Nano]*/
+    //tempMaxLimit = tempMaxLimit * 8 / 1000;    /*[Byte/NanoSec] -> [KBits/NanoSec]*/
+    //tempMaxLimit = tempMaxLimit * 1000000000;  /*[KBits/NanoSec] ->[KBits/Sec]*/
+    //tempMaxLimit = tempMaxLimit >> 32;         /*16 (Cir/pir register presicion) + 16 (number of shifts done to fpp by default)*/
+
+    /*transform  [bytes per timeStamp unit] into  [Kbit/s]*/
+    tempMinLimit = minVal * timeStampPeriod;   /*[Byte/TimeStamp] -> [Byte/Nano]*/
+    tempMinLimit = tempMinLimit * 8 / 1000;    /*[Byte/NanoSec] -> [KBits/NanoSec]*/
+    tempMinLimit = tempMinLimit * 1000000000;  /*[KBits/NanoSec] ->[KBits/Sec]*/
+    tempMinLimit = tempMinLimit >> 32;         /*16 (Cir/pir register presicion) + 16 (number of shifts done to fpp by default)*/
+
+    XX_Print("Valid range for ByteMode RateSelection is min 0x%x ", (uint32_t)tempMinLimit);
+
+    //tempMaxLimit = maxVal * timeStampPeriod;   /*[Packets/TimeStamp] -> [Packets/Nano]*/
+    //tempMaxLimit = maxVal * 1000000000;        /*[Packets/Nano] -> [Packets/Sec]*/
+    //tempMaxLimit = tempMaxLimit >> 32;         /*16 (Cir/pir register presicion) + 0 (number of shifts done to fpp)*/
+
+    tempMinLimit = minVal * timeStampPeriod;   /*[Packets/TimeStamp] -> [Packets/Nano]*/
+    tempMinLimit = minVal * 1000000000;        /*[Packets/Nano] -> [Packets/Sec]*/
+    tempMinLimit = tempMinLimit >> 32;         /*16 (Cir/pir register presicion) + 16 (number of shifts done to fpp by default)*/
+
+    XX_Print("Valid range for PacketMode RateSelection is min 0x%x ", (uint32_t)tempMinLimit);
+}
+
+/* .......... */
+
+static void calcRates(t_Handle h_FmPcd, t_FmPcdPlcrNonPassthroughAlgParams *p_NonPassthroughAlgParam,
+                        uint32_t *cir, uint32_t *cbs, uint32_t *pir_eir, uint32_t *pbs_ebs, uint32_t *fpp)
+{
+    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    uint64_t    timeStampPeriod;
+    uint64_t    tempCir, tempPir_Eir;
+    uint32_t    temp, count;
+    bool        big;
+
+    timeStampPeriod = (uint64_t)FmGetTimeStampPeriod(p_FmPcd->h_Fm);               /* TimeStamp per nano seconds units */
+
+    /* First round to calculate precision */
+    if (p_NonPassthroughAlgParam->comittedInfoRate > p_NonPassthroughAlgParam->peakOrAccessiveInfoRate)
+        tempCir = Rate2Sample(p_NonPassthroughAlgParam->rateMode, p_NonPassthroughAlgParam->comittedInfoRate, timeStampPeriod, 0);
+    else
+        tempCir = Rate2Sample(p_NonPassthroughAlgParam->rateMode, p_NonPassthroughAlgParam->peakOrAccessiveInfoRate, timeStampPeriod, 0);
+
+    /* Base on result calculate the FPP and re calculate cir, pir_eir */
+    count = 0;
+    if ((tempCir > 0xFFFFFFFF))
+    {
+        /* Overflow need to shrink number */
+        big = TRUE;
+        temp = (uint32_t)(tempCir >> 32);
+        while (temp > 0)
+        {
+            temp = temp >> 1;
+            count++;
+        }
+        if(count > 16)
+        {
+            REPORT_ERROR(MAJOR, E_INVALID_SELECTION, ("timeStampPeriod to Information rate ratio is too big"));
+            CheckValidRateRange(p_FmPcd);
+            return;
+        }
+    }
+    else
+    {
+        /* Underflow need to improve accuracy */
+        big = FALSE;
+        temp = (uint32_t)(tempCir & 0x00000000FFFFFFFF);
+        if(temp != 0)
+        {
+        while ((temp & 0x80000000) == 0)
+        {
+            temp = temp << 1;
+            count++;
+        }
+        if(count > 15)
+        {
+            REPORT_ERROR(MAJOR, E_INVALID_SELECTION, ("timeStampPeriod to Information rate ratio is too small"));
+                CheckValidRateRange(p_FmPcd);
+            return;
+            }
+        }
+    }
+
+    /* Second round based on precision do the roght calculation */
+    if (count > 0)
+    {
+        if (big)
+        {
+           *fpp = (uint32_t)(0x1F - (count - 1));
+ //           tempCir     = Rate2Sample(p_NonPassthroughAlgParam->rateMode, p_NonPassthroughAlgParam->comittedInfoRate, timeStampPeriod, *fpp);
+ //           tempPir_Eir = Rate2Sample(p_NonPassthroughAlgParam->rateMode, p_NonPassthroughAlgParam->peakOrAccessiveInfoRate , timeStampPeriod, *fpp);
+           // *fpp = (uint32_t)(0x1F - ((1 << (count - 1)) + 1));
+        }
+        else
+        {
+            *fpp = (uint32_t)count;
+ //           tempCir     = Rate2Sample(p_NonPassthroughAlgParam->rateMode, p_NonPassthroughAlgParam->comittedInfoRate , timeStampPeriod, *fpp);
+ //           tempPir_Eir = Rate2Sample(p_NonPassthroughAlgParam->rateMode, p_NonPassthroughAlgParam->peakOrAccessiveInfoRate , timeStampPeriod, *fpp);
+          //  *fpp = (uint32_t)(1 << (count - 1));
+        }
+    }
+    else
+    {
+            *fpp = 0;
+ //           tempCir     = Rate2Sample(p_NonPassthroughAlgParam->rateMode, p_NonPassthroughAlgParam->comittedInfoRate, timeStampPeriod, *fpp);
+ //           tempPir_Eir = Rate2Sample(p_NonPassthroughAlgParam->rateMode, p_NonPassthroughAlgParam->peakOrAccessiveInfoRate, timeStampPeriod, *fpp);
+    }
+
+    tempCir     = Rate2Sample(p_NonPassthroughAlgParam->rateMode, p_NonPassthroughAlgParam->comittedInfoRate, timeStampPeriod, *fpp);
+    tempPir_Eir = Rate2Sample(p_NonPassthroughAlgParam->rateMode, p_NonPassthroughAlgParam->peakOrAccessiveInfoRate , timeStampPeriod, *fpp);
+
+    if (p_NonPassthroughAlgParam->rateMode == e_FM_PCD_PLCR_BYTE_MODE)
+    {
+        *cbs     = (1000 * p_NonPassthroughAlgParam->comittedBurstSize / 8);
+        *pbs_ebs = (1000 * p_NonPassthroughAlgParam->peakOrAccessiveBurstSize) / 8; /* 8=Bits->Bytes 1000=KB->B */
+    }
+    else
+    {
+        *cbs     =  p_NonPassthroughAlgParam->comittedBurstSize;
+        *pbs_ebs =  p_NonPassthroughAlgParam->peakOrAccessiveBurstSize;
+    }
+
+    *cir     = (uint32_t)tempCir;
+    *pir_eir = (uint32_t)tempPir_Eir;
+}
+
+#ifndef CONFIG_GUEST_PARTITION
+static void WritePar(t_FmPcd *p_FmPcd, uint32_t par)
+{
+    t_FmPcdPlcrRegs *p_FmPcdPlcrRegs    = p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs;
+
+    WRITE_UINT32(p_FmPcdPlcrRegs->fmpl_par, par);
+
+    while(GET_UINT32(p_FmPcdPlcrRegs->fmpl_par) & FM_PCD_PLCR_PAR_GO) ;
+
+}
+#endif /* CONFIG_GUEST_PARTITION */
+
+/*********************************************/
+/*............Policer Exception..............*/
+/*********************************************/
+#ifndef CONFIG_GUEST_PARTITION
+static void PcdPlcrException(t_Handle h_FmPcd)
+{
+    t_FmPcd *p_FmPcd = (t_FmPcd *)h_FmPcd;
+    uint32_t event;
+
+    event = GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_evr);
+    event &= GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_ier);
+
+    WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_evr, event);
+
+    if(event & FM_PCD_PLCR_PRAM_SELF_INIT_COMPLETE)
+        p_FmPcd->f_FmPcdException(p_FmPcd->h_App,e_FM_PCD_PLCR_EXCEPTION_PRAM_SELF_INIT_COMPLETE);
+    if(event & FM_PCD_PLCR_ATOMIC_ACTION_COMPLETE)
+        p_FmPcd->f_FmPcdException(p_FmPcd->h_App,e_FM_PCD_PLCR_EXCEPTION_ATOMIC_ACTION_COMPLETE);
+
+}
+
+/* ..... */
+
+static void PcdPlcrErrorException(t_Handle h_FmPcd)
+{
+    t_FmPcd             *p_FmPcd = (t_FmPcd *)h_FmPcd;
+    uint32_t            event, captureReg;
+
+    event = GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_eevr);
+    event &= GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_eier);
+
+    WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_eevr, event);
+
+    if(event & FM_PCD_PLCR_DOUBLE_ECC)
+        p_FmPcd->f_FmPcdException(p_FmPcd->h_App,e_FM_PCD_PLCR_ERR_EXCEPTION_DOUBLE_ECC);
+    if(event & FM_PCD_PLCR_INIT_ENTRY_ERROR)
+    {
+        captureReg = GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_upcr);
+        /*ASSERT_COND(captureReg & PLCR_ERR_UNINIT_CAP);
+        p_UnInitCapt->profileNum = (uint8_t)(captureReg & PLCR_ERR_UNINIT_NUM_MASK);
+        p_UnInitCapt->portId = (uint8_t)((captureReg & PLCR_ERR_UNINIT_PID_MASK) >>PLCR_ERR_UNINIT_PID_SHIFT) ;
+        p_UnInitCapt->absolute = (bool)(captureReg & PLCR_ERR_UNINIT_ABSOLUTE_MASK);*/
+        p_FmPcd->f_FmPcdIndexedException(p_FmPcd->h_App,e_FM_PCD_PLCR_ERR_EXCEPTION_INIT_ENTRY_ERROR,(uint16_t)(captureReg & PLCR_ERR_UNINIT_NUM_MASK));
+        //WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_upcr, PLCR_ERR_UNINIT_CAP);
+    }
+}
+
+#endif /* !CONFIG_GUEST_PARTITION */
+
+t_Error  FmPcdPlcrAllocProfiles(t_Handle h_FmPcd, uint8_t hardwarePortId, uint16_t numOfProfiles)
+{
+    t_FmPcd                     *p_FmPcd = (t_FmPcd*)h_FmPcd;
+#ifdef CONFIG_GUEST_PARTITION
+    t_FmPcdIpcPlcrAllocParams   ipcPlcrParams;
+#endif /* CONFIG_GUEST_PARTITION */
+    t_Error                     err;
+    uint16_t                    base;
+    uint16_t                    pcdPortId;
+    uint8_t                     portsTable[]        = PCD_PORTS_TABLE;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+
+#ifdef CONFIG_GUEST_PARTITION
+    /* Alloc resources using IPC messaging */
+    ipcPlcrParams.num = numOfProfiles;
+    ipcPlcrParams.hardwarePortId = hardwarePortId;
+    err = XX_SendMessage(p_FmPcd->fmPcdModuleName, FM_PCD_ALLOC_PROFILES, (uint8_t*)&ipcPlcrParams, NULL, NULL);
+    if(err)
+        RETURN_ERROR(MAJOR, err,NO_MSG);
+    base = ipcPlcrParams.plcrProfilesBase;
+#else /* master */
+    err = PlcrAllocProfiles(p_FmPcd, hardwarePortId, numOfProfiles, &base);
+    if(err)
+        RETURN_ERROR(MAJOR, err,NO_MSG);
+#endif /* CONFIG_GUEST_PARTITION */
+
+    GET_FM_PCD_PORTID_FROM_GLOBAL_PORTID(pcdPortId, portsTable, hardwarePortId)
+
+    p_FmPcd->p_FmPcdPlcr->portsMapping[pcdPortId].numOfProfiles = numOfProfiles;
+    p_FmPcd->p_FmPcdPlcr->portsMapping[pcdPortId].profilesBase = base;
+
+    return E_OK;
+
+}
+
+t_Error  FmPcdPlcrFreeProfiles(t_Handle h_FmPcd, uint8_t hardwarePortId)
+{
+    t_FmPcd                     *p_FmPcd = (t_FmPcd*)h_FmPcd;
+#ifdef CONFIG_GUEST_PARTITION
+    t_FmPcdIpcPlcrAllocParams   ipcPlcrParams;
+#endif /* CONFIG_GUEST_PARTITION */
+    t_Error                     err;
+    uint16_t                    pcdPortId;
+    uint8_t                     portsTable[]        = PCD_PORTS_TABLE;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+
+    GET_FM_PCD_PORTID_FROM_GLOBAL_PORTID(pcdPortId, portsTable, hardwarePortId)
+
+
+#ifdef CONFIG_GUEST_PARTITION
+    /* Alloc resources using IPC messaging */
+    ipcPlcrParams.num = p_FmPcd->p_FmPcdPlcr->portsMapping[pcdPortId].numOfProfiles;
+    ipcPlcrParams.hardwarePortId = hardwarePortId;
+    ipcPlcrParams.plcrProfilesBase = p_FmPcd->p_FmPcdPlcr->portsMapping[pcdPortId].profilesBase;
+    err = XX_SendMessage(p_FmPcd->fmPcdModuleName, FM_PCD_FREE_PROFILES, (uint8_t*)&ipcPlcrParams, NULL, NULL);
+    if(err)
+        RETURN_ERROR(MAJOR, err,NO_MSG);
+#else /* master */
+    err = PlcrFreeProfiles(p_FmPcd, hardwarePortId, p_FmPcd->p_FmPcdPlcr->portsMapping[pcdPortId].numOfProfiles, p_FmPcd->p_FmPcdPlcr->portsMapping[pcdPortId].profilesBase);
+    if(err)
+        RETURN_ERROR(MAJOR, err,NO_MSG);
+#endif /* CONFIG_GUEST_PARTITION */
+
+    p_FmPcd->p_FmPcdPlcr->portsMapping[pcdPortId].numOfProfiles = 0;
+    p_FmPcd->p_FmPcdPlcr->portsMapping[pcdPortId].profilesBase = 0;
+
+    return E_OK;
+
+}
+
+bool    FmPcdPlcrIsProfileValid(t_Handle h_FmPcd, uint16_t absoluteProfileId)
+{
+    t_FmPcd         *p_FmPcd            = (t_FmPcd*)h_FmPcd;
+    t_FmPcdPlcr     *p_FmPcdPlcr        = p_FmPcd->p_FmPcdPlcr;
+
+    return p_FmPcdPlcr->profiles[absoluteProfileId].valid;
+}
+
+
+#ifndef CONFIG_GUEST_PARTITION
+t_Error  PlcrAllocProfiles(t_FmPcd *p_FmPcd, uint8_t hardwarePortId, uint16_t numOfProfiles, uint16_t *p_Base)
+{
+    t_FmPcdPlcrRegs *p_Regs = p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs;
+    uint32_t        profilesFound, log2Num, tmpReg32;
+    uint16_t        first, i;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+
+    ASSERT_COND(hardwarePortId);
+
+    if (numOfProfiles>FM_PCD_PLCR_NUM_ENTRIES)
+        RETURN_ERROR(MINOR, E_INVALID_VALUE, ("numProfiles is too big."));
+
+    if (!POWER_OF_2(numOfProfiles))
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("numProfiles must be a power of 2."));
+
+    TRY_LOCK_RET_ERR(p_FmPcd->lock);
+
+    if(GET_UINT32(p_Regs->fmpl_pmr[hardwarePortId-1]) & FM_PCD_PLCR_PMR_V)
+    {
+        RELEASE_LOCK(p_FmPcd->lock);
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("The requesting port has already an allocated profiles window."));
+    }
+
+    first = 0;
+    profilesFound = 0;
+    for(i=0;i<FM_PCD_PLCR_NUM_ENTRIES;)
+    {
+        if(!p_FmPcd->p_FmPcdPlcr->profiles[i].profilesMng.allocated)
+        {
+            profilesFound++;
+            i++;
+            if(profilesFound == numOfProfiles)
+                break;
+        }
+        else
+        {
+            profilesFound = 0;
+            /* advance i to the next aligned address */
+            first = i = (uint8_t)(first + numOfProfiles);
+        }
+    }
+    if(profilesFound == numOfProfiles)
+    {
+        for(i = first; i<first + numOfProfiles; i++)
+        {
+            p_FmPcd->p_FmPcdPlcr->profiles[i].profilesMng.allocated = TRUE;
+            p_FmPcd->p_FmPcdPlcr->profiles[i].profilesMng.ownerId = hardwarePortId;
+        }
+    }
+    else
+    {
+        RELEASE_LOCK(p_FmPcd->lock);
+        RETURN_ERROR(MINOR, E_FULL, ("No profiles."));
+    }
+
+
+    /**********************FMPL_PMRx******************/
+    LOG2((uint64_t)numOfProfiles, log2Num);
+    tmpReg32 = first;
+    tmpReg32 |= log2Num << 16;
+    tmpReg32 |= FM_PCD_PLCR_PMR_V;
+    WRITE_UINT32(p_Regs->fmpl_pmr[hardwarePortId-1], tmpReg32);
+
+    *p_Base = first;
+
+    RELEASE_LOCK(p_FmPcd->lock);
+
+    return E_OK;
+
+}
+
+t_Error  PlcrAllocSharedProfiles(t_FmPcd *p_FmPcd, uint16_t numOfProfiles, uint16_t *profilesIds)
+{
+    uint32_t        profilesFound;
+    uint16_t        i, k=0;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+
+    if (numOfProfiles>FM_PCD_PLCR_NUM_ENTRIES)
+        RETURN_ERROR(MINOR, E_INVALID_VALUE, ("numProfiles is too big."));
+
+    profilesFound = 0;
+    for(i=0;i<FM_PCD_PLCR_NUM_ENTRIES; i++)
+    {
+        if(!p_FmPcd->p_FmPcdPlcr->profiles[i].profilesMng.allocated)
+        {
+            profilesFound++;
+            profilesIds[k] = i;
+            k++;
+            if(profilesFound == numOfProfiles)
+                break;
+        }
+    }
+    if(profilesFound != numOfProfiles)
+        RETURN_ERROR(MAJOR, E_INVALID_STATE,NO_MSG);
+    for(i = 0;i<k;i++)
+    {
+        p_FmPcd->p_FmPcdPlcr->profiles[profilesIds[i]].profilesMng.allocated = TRUE;
+        p_FmPcd->p_FmPcdPlcr->profiles[profilesIds[i]].profilesMng.ownerId = 0;
+    }
+
+    return E_OK;
+
+}
+
+t_Error  PlcrFreeProfiles(t_FmPcd *p_FmPcd, uint8_t hardwarePortId, uint16_t numOfProfiles, uint16_t base)
+{
+    t_FmPcdPlcrRegs *p_Regs = p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs;
+    uint16_t        i;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_HANDLE);
+
+#if 0 //- default
+        else
+        {
+            tmpReg32 = GET_UINT32(p_Regs->fmpl_dpmr);
+            log2Num = (uint8_t)(tmpReg32 >> 16);
+            first = (uint16_t)tmpReg32;
+            numProfiles = (uint16_t)(1<<log2Num);
+            ASSERT_COND(p_FmPcd->p_FmPcdPlcr->profiles[first].ownerId == hardwarePortId);
+            /* 1 profile is still allocated for default window - HW limitaion. */
+            tmpReg32 = first;
+            WRITE_UINT32(p_Regs->fmpl_dpmr, tmpReg32);
+            first++;
+            numProfiles--;
+        }
+#endif
+
+    WRITE_UINT32(p_Regs->fmpl_pmr[hardwarePortId-1], 0);
+
+    for(i = base; i<base+numOfProfiles;i++)
+    {
+        ASSERT_COND(p_FmPcd->p_FmPcdPlcr->profiles[i].profilesMng.ownerId == hardwarePortId);
+        ASSERT_COND(p_FmPcd->p_FmPcdPlcr->profiles[i].profilesMng.allocated);
+
+        p_FmPcd->p_FmPcdPlcr->profiles[i].profilesMng.allocated = FALSE;
+        p_FmPcd->p_FmPcdPlcr->profiles[i].profilesMng.ownerId = 0;
+    }
+    return E_OK;
+
+}
+
+void  PlcrFreeSharedProfiles(t_FmPcd *p_FmPcd, uint16_t numOfProfiles, uint16_t *profilesIds)
+{
+    uint16_t        i;
+
+    SANITY_CHECK_RETURN(p_FmPcd, E_INVALID_HANDLE);
+
+    for(i=0;i<numOfProfiles; i++)
+    {
+        ASSERT_COND(p_FmPcd->p_FmPcdPlcr->profiles[profilesIds[i]].profilesMng.allocated);
+        p_FmPcd->p_FmPcdPlcr->profiles[profilesIds[i]].profilesMng.allocated = FALSE;
+    }
+}
+
+#endif /* ! CONFIG_GUEST_PARTITION */
+
+t_Error FmPcdPlcrBuildProfile(t_Handle h_FmPcd, t_FmPcdPlcrProfileParams *p_Profile, t_FmPcdPlcrInterModuleProfileRegs *p_PlcrRegs)
+{
+
+    t_FmPcd         *p_FmPcd            = (t_FmPcd*)h_FmPcd;
+    t_Error err;
+    uint32_t        pemode, gnia, ynia, rnia;
+
+/* Set G, Y, R Nia */
+    err = SetProfileNia(p_FmPcd, p_Profile->nextEngineOnGreen,  &(p_Profile->paramsOnGreen), &gnia);
+    if(err)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+    err = SetProfileNia(p_FmPcd, p_Profile->nextEngineOnYellow, &(p_Profile->paramsOnYellow), &ynia);
+    if(err)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+    err = SetProfileNia(p_FmPcd, p_Profile->nextEngineOnRed,    &(p_Profile->paramsOnRed), &rnia);
+   if(err)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+
+
+/* Mode fmpl_pemode */
+    pemode = FM_PCD_PLCR_PEMODE_PI;
+
+    switch (p_Profile->algSelection)
+    {
+        case    e_FM_PCD_PLCR_PASS_THROUGH:
+            p_PlcrRegs->fmpl_pecir         = 0;
+            p_PlcrRegs->fmpl_pecbs         = 0;
+            p_PlcrRegs->fmpl_pepepir_eir   = 0;
+            p_PlcrRegs->fmpl_pepbs_ebs     = 0;
+            p_PlcrRegs->fmpl_pelts         = 0;
+            p_PlcrRegs->fmpl_pects         = 0;
+            p_PlcrRegs->fmpl_pepts_ets     = 0;
+            pemode &= ~FM_PCD_PLCR_PEMODE_ALG_MASK;
+            switch (p_Profile->colorMode)
+            {
+                case    e_FM_PCD_PLCR_COLOR_BLIND:
+                    pemode |= FM_PCD_PLCR_PEMODE_CBLND;
+                    switch (p_Profile->color.dfltColor)
+                    {
+                        case e_FM_PCD_PLCR_GREEN:
+                            pemode &= ~FM_PCD_PLCR_PEMODE_DEFC_MASK;
+                            break;
+                        case e_FM_PCD_PLCR_YELLOW:
+                            pemode |= FM_PCD_PLCR_PEMODE_DEFC_Y;
+                            break;
+                        case e_FM_PCD_PLCR_RED:
+                            pemode |= FM_PCD_PLCR_PEMODE_DEFC_R;
+                            break;
+                        case e_FM_PCD_PLCR_OVERRIDE:
+                            pemode |= FM_PCD_PLCR_PEMODE_DEFC_OVERRIDE;
+                            break;
+                        default:
+                            RETURN_ERROR(MAJOR, E_INVALID_SELECTION, NO_MSG);
+                    }
+
+                    break;
+                case    e_FM_PCD_PLCR_COLOR_AWARE:
+                    pemode &= ~FM_PCD_PLCR_PEMODE_CBLND;
+                    break;
+                default:
+                    RETURN_ERROR(MAJOR, E_INVALID_SELECTION, NO_MSG);
+            }
+            break;
+
+        case    e_FM_PCD_PLCR_RFC_2698:
+            /* Select algorithm MODE[ALG] = 01 */
+            pemode |= FM_PCD_PLCR_PEMODE_ALG_RFC2698;
+            goto cont_rfc;
+        case    e_FM_PCD_PLCR_RFC_4115:
+            /* Select algorithm MODE[ALG] = 10 */
+            pemode |= FM_PCD_PLCR_PEMODE_ALG_RFC4115;
+cont_rfc:
+            /* Select Color-Blind / Color-Aware operation (MODE[CBLND]) */
+            switch (p_Profile->colorMode)
+            {
+                case    e_FM_PCD_PLCR_COLOR_BLIND:
+                    pemode |= FM_PCD_PLCR_PEMODE_CBLND;
+                    break;
+                case    e_FM_PCD_PLCR_COLOR_AWARE:
+                    pemode &= ~FM_PCD_PLCR_PEMODE_CBLND;
+                    /*In color aware more select override color interpretation (MODE[OVCLR]) */
+                    switch (p_Profile->color.override)
+                    {
+                        case e_FM_PCD_PLCR_GREEN:
+                            pemode &= ~FM_PCD_PLCR_PEMODE_OVCLR_MASK;
+                            break;
+                        case e_FM_PCD_PLCR_YELLOW:
+                            pemode |= FM_PCD_PLCR_PEMODE_OVCLR_Y;
+                            break;
+                        case e_FM_PCD_PLCR_RED:
+                            pemode |= FM_PCD_PLCR_PEMODE_OVCLR_R;
+                            break;
+                        case e_FM_PCD_PLCR_OVERRIDE:
+                            pemode |= FM_PCD_PLCR_PEMODE_OVCLR_G_NC;
+                            break;
+                        default:
+                            RETURN_ERROR(MAJOR, E_INVALID_SELECTION, NO_MSG);
+                    }
+                    break;
+                default:
+                    RETURN_ERROR(MAJOR, E_INVALID_SELECTION, NO_MSG);
+            }
+            /* Select Measurement Unit Mode to BYTE or PACKET (MODE[PKT]) */
+            switch (p_Profile->nonPassthroughAlgParams.rateMode)
+            {
+                case e_FM_PCD_PLCR_BYTE_MODE :
+                    pemode &= ~FM_PCD_PLCR_PEMODE_PKT;
+                        switch (p_Profile->nonPassthroughAlgParams.byteModeParams.frameLengthSelection)
+                        {
+                            case e_FM_PCD_PLCR_L2_FRM_LEN:
+                                pemode |= FM_PCD_PLCR_PEMODE_FLS_L2;
+                                break;
+                            case e_FM_PCD_PLCR_L3_FRM_LEN:
+                                pemode |= FM_PCD_PLCR_PEMODE_FLS_L3;
+                                break;
+                            case e_FM_PCD_PLCR_L4_FRM_LEN:
+                                pemode |= FM_PCD_PLCR_PEMODE_FLS_L4;
+                                break;
+                            case e_FM_PCD_PLCR_FULL_FRM_LEN:
+                                pemode |= FM_PCD_PLCR_PEMODE_FLS_FULL;
+                                break;
+                            default:
+                                RETURN_ERROR(MAJOR, E_INVALID_SELECTION, NO_MSG);
+                        }
+                        switch (p_Profile->nonPassthroughAlgParams.byteModeParams.rollBackFrameSelection)
+                        {
+                            case e_FM_PCD_PLCR_ROLLBACK_L2_FRM_LEN:
+                                pemode &= ~FM_PCD_PLCR_PEMODE_RBFLS;
+                                break;
+                            case e_FM_PCD_PLCR_ROLLBACK_FULL_FRM_LEN:
+                                pemode |= FM_PCD_PLCR_PEMODE_RBFLS;
+                                break;
+                            default:
+                                RETURN_ERROR(MAJOR, E_INVALID_SELECTION, NO_MSG);
+                        }
+                    break;
+                case e_FM_PCD_PLCR_PACKET_MODE :
+                    pemode |= FM_PCD_PLCR_PEMODE_PKT;
+                    break;
+                default:
+                    RETURN_ERROR(MAJOR, E_INVALID_SELECTION, NO_MSG);
+            }
+            /* Select timeStamp floating point position (MODE[FPP]) to fit the actual traffic rates. For PACKET
+               mode with low traffic rates move the fixed point to the left to increase fraction accuracy. For BYTE
+               mode with high traffic rates move the fixed point to the right to increase integer accuracy. */
+
+            /* Configure Traffic Parameters*/
+            {
+                uint32_t cir=0, cbs=0, pir_eir=0, pbs_ebs=0, fpp=0;
+
+                calcRates(h_FmPcd, &p_Profile->nonPassthroughAlgParams, &cir, &cbs, &pir_eir, &pbs_ebs, &fpp);
+
+                /*  Set Committed Information Rate (CIR) */
+                p_PlcrRegs->fmpl_pecir = cir;
+                /*  Set Committed Burst Size (CBS). */
+                p_PlcrRegs->fmpl_pecbs =  cbs;
+                /*  Set Peak Information Rate (PIR_EIR used as PIR) */
+                p_PlcrRegs->fmpl_pepepir_eir = pir_eir;
+                /*   Set Peak Burst Size (PBS_EBS used as PBS) */
+                p_PlcrRegs->fmpl_pepbs_ebs = pbs_ebs;
+
+                /* Initialize the Metering Buckets to be full (write them with 0xFFFFFFFF. */
+                /* Peak Rate Token Bucket Size (PTS_ETS used as PTS) */
+                p_PlcrRegs->fmpl_pepts_ets = 0xFFFFFFFF;
+                /* Committed Rate Token Bucket Size (CTS) */
+                p_PlcrRegs->fmpl_pects = 0xFFFFFFFF;
+
+                /* Set the FPP based on calculation */
+                pemode |= (fpp << FM_PCD_PLCR_PEMODE_FPP_SHIFT);
+            }
+            break;  /* FM_PCD_PLCR_PEMODE_ALG_RFC2698 , FM_PCD_PLCR_PEMODE_ALG_RFC4115 */
+        default:
+            RETURN_ERROR(MAJOR, E_INVALID_SELECTION, NO_MSG);
+    }
+
+    p_PlcrRegs->fmpl_pemode = pemode;
+
+
+    p_PlcrRegs->fmpl_pegnia = gnia;
+    p_PlcrRegs->fmpl_peynia = ynia;
+    p_PlcrRegs->fmpl_pernia = rnia;
+
+
+/* Zero Counters */
+    p_PlcrRegs->fmpl_pegpc     = 0;
+    p_PlcrRegs->fmpl_peypc     = 0;
+    p_PlcrRegs->fmpl_perpc     = 0;
+    p_PlcrRegs->fmpl_perypc    = 0;
+    p_PlcrRegs->fmpl_perrpc    = 0;
+
+    return E_OK;
+}
+
+void  FmPcdPlcrValidateProfileSw(t_Handle h_FmPcd, uint16_t absoluteProfileId)
+{
+    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
+
+    ASSERT_COND(!p_FmPcd->p_FmPcdPlcr->profiles[absoluteProfileId].valid);
+    p_FmPcd->p_FmPcdPlcr->profiles[absoluteProfileId].valid = TRUE;
+}
+
+void  FmPcdPlcrInvalidateProfileSw(t_Handle h_FmPcd, uint16_t absoluteProfileId)
+{
+    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
+
+    ASSERT_COND(p_FmPcd->p_FmPcdPlcr->profiles[absoluteProfileId].valid);
+    p_FmPcd->p_FmPcdPlcr->profiles[absoluteProfileId].valid = FALSE;
+}
+
+t_Handle PlcrConfig(t_FmPcd *p_FmPcd, t_FmPcdParams *p_FmPcdParams)
+{
+    t_FmPcdPlcr *p_FmPcdPlcr;
+    /*uint8_t i=0;*/
+
+    UNUSED(p_FmPcd);
+    UNUSED(p_FmPcdParams);
+
+    p_FmPcdPlcr = (t_FmPcdPlcr *) XX_Malloc(sizeof(t_FmPcdPlcr));
+    if (!p_FmPcdPlcr)
+    {
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM Policer structure allocation FAILED"));
+        return NULL;
+    }
+    memset(p_FmPcdPlcr, 0, sizeof(t_FmPcdPlcr));
+
+#ifndef CONFIG_GUEST_PARTITION
+    p_FmPcdPlcr->p_FmPcdPlcrRegs  = CAST_UINT64_TO_POINTER_TYPE(t_FmPcdPlcrRegs , (FmGetPcdPlcrBaseAddr(p_FmPcdParams->h_Fm)));
+    p_FmPcd->p_FmPcdDriverParam->plcrAutoRefresh    = DEFAULT_plcrAutoRefresh;
+    p_FmPcd->exceptions |= (DEFAULT_fmPcdPlcrExceptions | DEFAULT_fmPcdPlcrErrorExceptions);
+#endif /* !CONFIG_GUEST_PARTITION */
+
+    p_FmPcdPlcr->numOfSharedProfiles = DEFAULT_numOfSharedPlcrProfiles;
+
+    return p_FmPcdPlcr;
+}
+
+t_Error PlcrInit(t_FmPcd *p_FmPcd)
+{
+    t_FmPcdDriverParam          *p_Param = p_FmPcd->p_FmPcdDriverParam;
+    t_FmPcdPlcr                 *p_FmPcdPlcr = p_FmPcd->p_FmPcdPlcr;
+    uint32_t                    tmpReg32 = 0;
+    t_Error                     err;
+#ifndef CONFIG_GUEST_PARTITION
+    t_FmPcdPlcrRegs             *p_Regs = p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs;
+#else
+    t_FmPcdIpcSharedPlcrAllocParams    ipcSharedPlcrParams;
+#endif /* !CONFIG_GUEST_PARTITION */
+
+#ifdef CONFIG_GUEST_PARTITION
+    /* Alloc resources using IPC messaging */
+    ipcSharedPlcrParams.num = p_FmPcdPlcr->numOfSharedProfiles;
+    err = XX_SendMessage(p_FmPcd->fmPcdModuleName, FM_PCD_ALLOC_SHARED_PROFILES, (uint8_t*)&ipcSharedPlcrParams, NULL, NULL);
+    if(err)
+        RETURN_ERROR(MAJOR, err,NO_MSG);
+    memcpy(p_FmPcd->p_FmPcdPlcr->sharedProfilesIds,ipcSharedPlcrParams.profilesIds, sizeof(uint16_t)*ipcSharedPlcrParams.num);
+#else /* master */
+    err = PlcrAllocSharedProfiles(p_FmPcd, p_FmPcdPlcr->numOfSharedProfiles, p_FmPcd->p_FmPcdPlcr->sharedProfilesIds);
+    if(err)
+        RETURN_ERROR(MAJOR, err,NO_MSG);
+#endif /* CONFIG_GUEST_PARTITION */
+
+#ifndef CONFIG_GUEST_PARTITION
+
+    /**********************FMPL_GCR******************/
+    tmpReg32 = 0;
+    tmpReg32 |= FM_PCD_PLCR_GCR_STEN;
+    if(p_Param->plcrAutoRefresh)
+        tmpReg32 |= FM_PCD_PLCR_GCR_DAR;
+    tmpReg32 |= NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME;
+
+    WRITE_UINT32(p_Regs->fmpl_gcr, tmpReg32);
+    /**********************FMPL_GCR******************/
+
+    /**********************FMPL_EEVR******************/
+    WRITE_UINT32(p_Regs->fmpl_eevr, (FM_PCD_PLCR_DOUBLE_ECC | FM_PCD_PLCR_INIT_ENTRY_ERROR));
+    /**********************FMPL_EEVR******************/
+    /**********************FMPL_EIER******************/
+    tmpReg32 = 0;
+    if(p_FmPcd->exceptions & FM_PCD_EX_PLCR_DOUBLE_ECC)
+    {
+        if(!FmRamsEccIsExternalCtl(p_FmPcd->h_Fm))
+            FM_EnableRamsEcc(p_FmPcd->h_Fm);
+        tmpReg32 |= FM_PCD_PLCR_DOUBLE_ECC;
+    }
+    if(p_FmPcd->exceptions & FM_PCD_EX_PLCR_INIT_ENTRY_ERROR)
+        tmpReg32 |= FM_PCD_PLCR_INIT_ENTRY_ERROR;
+    WRITE_UINT32(p_Regs->fmpl_eier, tmpReg32);
+    /**********************FMPL_EIER******************/
+
+    /**********************FMPL_EVR******************/
+    WRITE_UINT32(p_Regs->fmpl_evr, (FM_PCD_PLCR_PRAM_SELF_INIT_COMPLETE | FM_PCD_PLCR_ATOMIC_ACTION_COMPLETE));
+    /**********************FMPL_EVR******************/
+    /**********************FMPL_IER******************/
+    tmpReg32 = 0;
+    if(p_FmPcd->exceptions & FM_PCD_EX_PLCR_PRAM_SELF_INIT_COMPLETE)
+        tmpReg32 |= FM_PCD_PLCR_PRAM_SELF_INIT_COMPLETE;
+    if(p_FmPcd->exceptions & FM_PCD_EX_PLCR_ATOMIC_ACTION_COMPLETE )
+        tmpReg32 |= FM_PCD_PLCR_ATOMIC_ACTION_COMPLETE;
+    WRITE_UINT32(p_Regs->fmpl_ier, tmpReg32);
+    /**********************FMPL_IER******************/
+
+    /* register even if no interrupts enabled, to allow future enablement */
+    FmRegisterIntr(p_FmPcd->h_Fm, e_FM_EV_ERR_PLCR, PcdPlcrErrorException, p_FmPcd);
+    FmRegisterIntr(p_FmPcd->h_Fm, e_FM_EV_PLCR, PcdPlcrException, p_FmPcd);
+
+    /* driver initializes one DFLT profile at the last entry*/
+    p_FmPcd->p_FmPcdPlcr->profiles[FM_PCD_PLCR_NUM_ENTRIES-1].profilesMng.allocated = TRUE;
+
+    /**********************FMPL_DPMR******************/
+    tmpReg32 = FM_PCD_PLCR_NUM_ENTRIES-1;
+    WRITE_UINT32(p_Regs->fmpl_dpmr, tmpReg32);
+
+#endif /* CONFIG_GUEST_PARTITION */
+    return E_OK;
+}
+
+#ifndef CONFIG_GUEST_PARTITION
+t_Error PlcrEnable(t_FmPcd *p_FmPcd)
+{
+    t_FmPcdPlcrRegs             *p_Regs = p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs;
+
+    WRITE_UINT32(p_Regs->fmpl_gcr, GET_UINT32(p_Regs->fmpl_gcr) | FM_PCD_PLCR_GCR_EN);
+
+    return E_OK;
+}
+#endif /* CONFIG_GUEST_PARTITION */
+
+t_Error FmPcdPlcrGetAbsoluteProfileId(t_Handle h_FmPcd,
+                                e_FmPcdProfileTypeSelection profileType,
+                                t_Handle  h_FmPort,
+                                uint16_t relativeProfile,
+                                uint16_t *p_AbsoluteId)
+{
+    t_FmPcd         *p_FmPcd            = (t_FmPcd*)h_FmPcd;
+    t_FmPcdPlcr     *p_FmPcdPlcr        = p_FmPcd->p_FmPcdPlcr;
+    uint8_t         i;
+
+    switch (profileType)
+    {
+        case e_FM_PCD_PLCR_PORT_PRIVATE:
+            /* get port PCD id from port handle */
+            for(i=0;i<PCD_MAX_NUM_OF_PORTS;i++)
+                if(p_FmPcd->p_FmPcdPlcr->portsMapping[i].h_FmPort == h_FmPort)
+                    break;
+            if (i ==  PCD_MAX_NUM_OF_PORTS)
+                RETURN_ERROR(MAJOR, E_INVALID_STATE , ("Invalid port handle."));
+
+            if(!p_FmPcd->p_FmPcdPlcr->portsMapping[i].numOfProfiles)
+                RETURN_ERROR(MAJOR, E_INVALID_SELECTION , ("Port has no allocated profiles"));
+            if(relativeProfile >= p_FmPcd->p_FmPcdPlcr->portsMapping[i].numOfProfiles)
+                RETURN_ERROR(MAJOR, E_INVALID_SELECTION , ("Profile id is out of range"));
+            *p_AbsoluteId = (uint16_t)(p_FmPcd->p_FmPcdPlcr->portsMapping[i].profilesBase + relativeProfile);
+            break;
+        case e_FM_PCD_PLCR_SHARED:
+            if(relativeProfile >= p_FmPcdPlcr->numOfSharedProfiles)
+                RETURN_ERROR(MAJOR, E_INVALID_SELECTION , ("Profile id is out of range"));
+            *p_AbsoluteId = (uint16_t)(p_FmPcdPlcr->sharedProfilesIds[relativeProfile]);
+            break;
+        default:
+            RETURN_ERROR(MAJOR, E_INVALID_SELECTION, ("Invalid policer profile type"));
+    }
+    return E_OK;
+}
+
+uint16_t FmPcdPlcrGetPortProfilesBase(t_Handle h_FmPcd, uint8_t hardwarePortId)
+{
+    t_FmPcd         *p_FmPcd = (t_FmPcd *)h_FmPcd;
+    uint16_t        pcdPortId;
+    uint8_t         portsTable[] = PCD_PORTS_TABLE;
+
+    GET_FM_PCD_PORTID_FROM_GLOBAL_PORTID(pcdPortId, portsTable, hardwarePortId)
+
+    return p_FmPcd->p_FmPcdPlcr->portsMapping[pcdPortId].profilesBase;
+}
+
+uint16_t FmPcdPlcrGetPortNumOfProfiles(t_Handle h_FmPcd, uint8_t hardwarePortId)
+{
+    t_FmPcd         *p_FmPcd = (t_FmPcd *)h_FmPcd;
+    uint16_t        pcdPortId;
+    uint8_t         portsTable[] = PCD_PORTS_TABLE;
+
+    GET_FM_PCD_PORTID_FROM_GLOBAL_PORTID(pcdPortId, portsTable, hardwarePortId)
+
+    return p_FmPcd->p_FmPcdPlcr->portsMapping[pcdPortId].numOfProfiles;
+
+}
+uint32_t FmPcdPlcrBuildWritePlcrActionReg(uint16_t absoluteProfileId)
+{
+    return (uint32_t)(FM_PCD_PLCR_PAR_GO |
+                        (absoluteProfileId << FM_PCD_PLCR_PAR_PNUM_SHIFT));
+}
+
+uint32_t FmPcdPlcrBuildWritePlcrActionRegs(uint16_t absoluteProfileId)
+{
+    return (uint32_t)(FM_PCD_PLCR_PAR_GO |
+                        (absoluteProfileId << FM_PCD_PLCR_PAR_PNUM_SHIFT) |
+                        FM_PCD_PLCR_PAR_PWSEL_MASK);
+}
+
+bool    FmPcdPlcrHwProfileIsValid(uint32_t profileModeReg)
+{
+
+    if(profileModeReg & FM_PCD_PLCR_PEMODE_PI)
+        return TRUE;
+    else
+        return FALSE;
+}
+
+uint32_t FmPcdPlcrBuildReadPlcrActionReg(uint16_t absoluteProfileId)
+{
+    return (uint32_t)(FM_PCD_PLCR_PAR_GO |
+                        FM_PCD_PLCR_PAR_R |
+                        (absoluteProfileId << FM_PCD_PLCR_PAR_PNUM_SHIFT) |
+                        FM_PCD_PLCR_PAR_PWSEL_MASK);
+}
+
+uint32_t FmPcdPlcrBuildCounterProfileReg(e_FmPcdPlcrProfileCounters counter)
+{
+    switch(counter)
+    {
+        case(e_FM_PCD_PLCR_PROFILE_GREEN_PACKET_TOTAL_COUNTER):
+            return FM_PCD_PLCR_PAR_PWSEL_PEGPC;
+        case(e_FM_PCD_PLCR_PROFILE_YELLOW_PACKET_TOTAL_COUNTER):
+            return FM_PCD_PLCR_PAR_PWSEL_PEYPC;
+        case(e_FM_PCD_PLCR_PROFILE_RED_PACKET_TOTAL_COUNTER) :
+            return FM_PCD_PLCR_PAR_PWSEL_PERPC;
+        case(e_FM_PCD_PLCR_PROFILE_RECOLOURED_YELLOW_PACKET_TOTAL_COUNTER) :
+            return FM_PCD_PLCR_PAR_PWSEL_PERYPC;
+        case(e_FM_PCD_PLCR_PROFILE_RECOLOURED_RED_PACKET_TOTAL_COUNTER) :
+            return FM_PCD_PLCR_PAR_PWSEL_PERRPC;
+       default:
+            REPORT_ERROR(MAJOR, E_INVALID_SELECTION, NO_MSG);
+            return 0;
+
+    }
+}
+
+t_Error FmPcdPlcrProfileTryLock(t_Handle h_FmPcd, uint16_t profileId)
+{
+    TRY_LOCK_RET_ERR(((t_FmPcd*)h_FmPcd)->p_FmPcdPlcr->profiles[profileId].lock);
+    return E_OK;
+}
+
+void FmPcdPlcrReleaseProfileLock(t_Handle h_FmPcd, uint16_t profileId)
+{
+    RELEASE_LOCK(((t_FmPcd*)h_FmPcd)->p_FmPcdPlcr->profiles[profileId].lock);
+}
+
+/**************************************************/
+/*............Policer API.........................*/
+/**************************************************/
+
+t_Handle FM_PCD_PlcrSetProfile(t_Handle     h_FmPcd,
+                              t_FmPcdPlcrProfileParams *p_Profile)
+{
+    t_FmPcd                             *p_FmPcd            = (t_FmPcd*)h_FmPcd;
+#ifndef CONFIG_MULTI_PARTITION_SUPPORT
+    t_FmPcdPlcr                         *p_FmPcdPlcr        = p_FmPcd->p_FmPcdPlcr;
+    t_FmPcdPlcrRegs                     *p_FmPcdPlcrRegs    = p_FmPcdPlcr->p_FmPcdPlcrRegs;
+    t_FmPcdPlcrInterModuleProfileRegs   plcrProfileReg;
+    uint16_t                            absoluteProfileId;
+    t_Error                             err;
+    uint32_t                            tmpReg32;
+#endif /* !CONFIG_MULTI_PARTITION_SUPPORT */
+
+    SANITY_CHECK_RETURN_VALUE(p_FmPcd, E_INVALID_HANDLE, NULL);
+    SANITY_CHECK_RETURN_VALUE(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE, NULL);
+
+    if (p_FmPcd->h_Hc)
+        return FmHcPcdPlcrSetProfile(p_FmPcd->h_Hc, p_Profile);
+#ifdef CONFIG_MULTI_PARTITION_SUPPORT
+    else
+    {
+        REPORT_ERROR(MAJOR, E_INVALID_HANDLE, ("No HC obj. must have HC in guest partition!"));
+        return NULL;
+    }
+
+#else
+    SANITY_CHECK_RETURN_VALUE(p_FmPcdPlcr, E_INVALID_HANDLE, NULL);
+    SANITY_CHECK_RETURN_VALUE(p_FmPcdPlcrRegs, E_INVALID_HANDLE, NULL);
+
+
+    if (p_Profile->modify)
+    {
+        absoluteProfileId = (uint16_t)(CAST_POINTER_TO_UINT32(p_Profile->id.h_Profile)-1);
+        TRY_LOCK_RET_NULL(p_FmPcd->p_FmPcdPlcr->profiles[absoluteProfileId].lock);
+    }
+    else
+    {
+        TRY_LOCK_RET_NULL(p_FmPcd->lock);
+        err = FmPcdPlcrGetAbsoluteProfileId(h_FmPcd,
+                                            p_Profile->id.newParams.profileType,
+                                            p_Profile->id.newParams.h_FmPort,
+                                            p_Profile->id.newParams.relativeProfileId,
+                                            &absoluteProfileId);
+        if(err)
+        {
+            RELEASE_LOCK(p_FmPcd->lock);
+            REPORT_ERROR(MAJOR, err, NO_MSG);
+            return NULL;
+        }
+        TRY_LOCK_RET_NULL(p_FmPcd->p_FmPcdPlcr->profiles[absoluteProfileId].lock);
+
+        RELEASE_LOCK(p_FmPcd->lock);
+    }
+
+    if (absoluteProfileId > FM_PCD_PLCR_NUM_ENTRIES)
+    {
+        REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("profileId too Big "));
+        return NULL;
+    }
+
+    /* if no override, check first that this scheme is unused */
+    if(!p_Profile->modify)
+    {
+        /* read specified profile into profile registers */
+        tmpReg32 = FmPcdPlcrBuildReadPlcrActionReg(absoluteProfileId);
+        WritePar(p_FmPcd, tmpReg32);
+        tmpReg32 = GET_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_pemode);
+        if (tmpReg32 & FM_PCD_PLCR_PEMODE_PI)
+        {
+            RELEASE_LOCK(p_FmPcd->p_FmPcdPlcr->profiles[absoluteProfileId].lock);
+            REPORT_ERROR(MAJOR, E_ALREADY_EXISTS, ("Polcer Profile is already used"));
+            return NULL;
+        }
+    }
+
+    memset(&plcrProfileReg, 0, sizeof(t_FmPcdPlcrInterModuleProfileRegs));
+
+    err =  FmPcdPlcrBuildProfile(h_FmPcd, p_Profile, &plcrProfileReg);
+    if(err)
+    {
+        RELEASE_LOCK(p_FmPcd->p_FmPcdPlcr->profiles[absoluteProfileId].lock);
+        REPORT_ERROR(MAJOR, err, NO_MSG);
+        return NULL;
+    }
+
+    WRITE_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_pemode , plcrProfileReg.fmpl_pemode);
+    WRITE_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_pegnia , plcrProfileReg.fmpl_pegnia);
+    WRITE_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_peynia , plcrProfileReg.fmpl_peynia);
+    WRITE_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_pernia , plcrProfileReg.fmpl_pernia);
+    WRITE_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_pecir  , plcrProfileReg.fmpl_pecir);
+    WRITE_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_pecbs  , plcrProfileReg.fmpl_pecbs);
+    WRITE_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_pepepir_eir,plcrProfileReg.fmpl_pepepir_eir);
+    WRITE_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_pepbs_ebs,plcrProfileReg.fmpl_pepbs_ebs);
+    WRITE_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_pelts  , plcrProfileReg.fmpl_pelts);
+    WRITE_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_pects  , plcrProfileReg.fmpl_pects);
+    WRITE_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_pepts_ets,plcrProfileReg.fmpl_pepts_ets);
+    WRITE_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_pegpc  , plcrProfileReg.fmpl_pegpc);
+    WRITE_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_peypc  , plcrProfileReg.fmpl_peypc);
+    WRITE_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_perpc  , plcrProfileReg.fmpl_perpc);
+    WRITE_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_perypc , plcrProfileReg.fmpl_perypc);
+    WRITE_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_perrpc , plcrProfileReg.fmpl_perrpc);
+
+    tmpReg32 = FmPcdPlcrBuildWritePlcrActionRegs(absoluteProfileId);
+    WritePar(p_FmPcd, tmpReg32);
+
+    FmPcdPlcrValidateProfileSw(p_FmPcd,absoluteProfileId);
+
+    RELEASE_LOCK(p_FmPcd->p_FmPcdPlcr->profiles[absoluteProfileId].lock);
+
+    return CAST_UINT32_TO_POINTER((uint32_t)absoluteProfileId+1);
+#endif /* CONFIG_MULTI_PARTITION_SUPPORT */
+}
+
+t_Error FM_PCD_PlcrDeleteProfile(t_Handle h_FmPcd, t_Handle h_Profile)
+{
+    t_FmPcd         *p_FmPcd            = (t_FmPcd*)h_FmPcd;
+#ifndef CONFIG_MULTI_PARTITION_SUPPORT
+    uint16_t        profileIndx = (uint16_t)(CAST_POINTER_TO_UINT32(h_Profile)-1);
+    t_FmPcdPlcr     *p_FmPcdPlcr        = p_FmPcd->p_FmPcdPlcr;
+    uint32_t        tmpReg32;
+#endif /* !CONFIG_MULTI_PARTITION_SUPPORT */
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdPlcr, E_INVALID_HANDLE);
+
+    if (p_FmPcd->h_Hc)
+        return FmHcPcdPlcrDeleteProfile(p_FmPcd->h_Hc, h_Profile);
+#ifdef CONFIG_MULTI_PARTITION_SUPPORT
+    else
+        RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("No HC obj. must have HC in guest partition!"));
+
+#else
+    SANITY_CHECK_RETURN_ERROR((profileIndx <= FM_PCD_PLCR_NUM_ENTRIES), E_INVALID_SELECTION);
+
+    FmPcdPlcrInvalidateProfileSw(p_FmPcd,profileIndx);
+
+    WRITE_UINT32(p_FmPcdPlcr->p_FmPcdPlcrRegs->profileRegs.fmpl_pemode, ~FM_PCD_PLCR_PEMODE_PI);
+
+    tmpReg32 = FmPcdPlcrBuildWritePlcrActionRegs(profileIndx);
+    WritePar(p_FmPcd, tmpReg32);
+
+    return E_OK;
+#endif /* CONFIG_MULTI_PARTITION_SUPPORT */
+}
+
+/* ......... */
+/***************************************************/
+/*............Policer Profile Counter..............*/
+/***************************************************/
+uint32_t FM_PCD_PlcrGetProfileCounter(t_Handle h_FmPcd, t_Handle h_Profile, e_FmPcdPlcrProfileCounters counter)
+{
+    t_FmPcd         *p_FmPcd            = (t_FmPcd*)h_FmPcd;
+#ifndef CONFIG_MULTI_PARTITION_SUPPORT
+    uint16_t        profileIndx = (uint16_t)(CAST_POINTER_TO_UINT32(h_Profile)-1);
+    t_FmPcdPlcr     *p_FmPcdPlcr        = p_FmPcd->p_FmPcdPlcr;
+    t_FmPcdPlcrRegs *p_FmPcdPlcrRegs    = p_FmPcdPlcr->p_FmPcdPlcrRegs;
+#endif /* !CONFIG_MULTI_PARTITION_SUPPORT */
+
+    SANITY_CHECK_RETURN_VALUE(p_FmPcd, E_INVALID_HANDLE,0);
+    SANITY_CHECK_RETURN_VALUE(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE, 0);
+
+    if (p_FmPcd->h_Hc)
+        return FmHcPcdPlcrGetProfileCounter(p_FmPcd->h_Hc, h_Profile, counter);
+#ifdef CONFIG_MULTI_PARTITION_SUPPORT
+    else
+        RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("No HC obj. must have HC in guest partition!"));
+
+#else
+    SANITY_CHECK_RETURN_VALUE(p_FmPcdPlcr, E_INVALID_HANDLE,0);
+    SANITY_CHECK_RETURN_VALUE(p_FmPcdPlcrRegs, E_INVALID_HANDLE,0);
+
+    if (profileIndx >= FM_PCD_PLCR_NUM_ENTRIES)
+    {
+        REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("profileId too Big "));
+        return 0;
+    }
+
+    WritePar(p_FmPcd, FmPcdPlcrBuildReadPlcrActionReg(profileIndx));
+
+    if (!(GET_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_pemode) & FM_PCD_PLCR_PEMODE_PI))
+    {
+        REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("Uninitialized profile"));
+        return 0;
+    }
+
+    switch (counter)
+    {
+        case e_FM_PCD_PLCR_PROFILE_GREEN_PACKET_TOTAL_COUNTER:
+            return (GET_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_pegpc));
+            break;
+        case e_FM_PCD_PLCR_PROFILE_YELLOW_PACKET_TOTAL_COUNTER:
+            return  GET_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_peypc);
+            break;
+        case e_FM_PCD_PLCR_PROFILE_RED_PACKET_TOTAL_COUNTER:
+            return  GET_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_perpc);
+            break;
+        case e_FM_PCD_PLCR_PROFILE_RECOLOURED_YELLOW_PACKET_TOTAL_COUNTER:
+            return  GET_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_perypc);
+            break;
+        case e_FM_PCD_PLCR_PROFILE_RECOLOURED_RED_PACKET_TOTAL_COUNTER:
+            return  GET_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_perrpc);
+            break;
+        default:
+            REPORT_ERROR(MAJOR, E_INVALID_SELECTION, NO_MSG);
+            return 0;
+    }
+
+    return 0;
+#endif /* CONFIG_MULTI_PARTITION_SUPPORT */
+}
+
+t_Error FM_PCD_PlcrSetProfileCounter(t_Handle h_FmPcd, t_Handle h_Profile, e_FmPcdPlcrProfileCounters counter, uint32_t value)
+{
+    t_FmPcd         *p_FmPcd            = (t_FmPcd*)h_FmPcd;
+#ifndef CONFIG_MULTI_PARTITION_SUPPORT
+    uint16_t        profileIndx = (uint16_t)(CAST_POINTER_TO_UINT32(h_Profile)-1);
+    t_FmPcdPlcr     *p_FmPcdPlcr        = p_FmPcd->p_FmPcdPlcr;
+    t_FmPcdPlcrRegs *p_FmPcdPlcrRegs    = p_FmPcdPlcr->p_FmPcdPlcrRegs;
+    uint32_t        tmpReg32;
+#endif /* !CONFIG_MULTI_PARTITION_SUPPORT */
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE);
+
+    if (p_FmPcd->h_Hc)
+        return FmHcPcdPlcrSetProfileCounter(p_FmPcd->h_Hc, h_Profile, counter, value);
+#ifdef CONFIG_MULTI_PARTITION_SUPPORT
+    else
+        RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("No HC obj. must have HC in guest partition!"));
+
+#else
+    SANITY_CHECK_RETURN_ERROR(p_FmPcdPlcr, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcdPlcrRegs, E_INVALID_HANDLE);
+
+    switch (counter)
+    {
+        case e_FM_PCD_PLCR_PROFILE_GREEN_PACKET_TOTAL_COUNTER:
+             WRITE_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_pegpc, value);
+             break;
+        case e_FM_PCD_PLCR_PROFILE_YELLOW_PACKET_TOTAL_COUNTER:
+             WRITE_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_peypc, value);
+             break;
+        case e_FM_PCD_PLCR_PROFILE_RED_PACKET_TOTAL_COUNTER:
+             WRITE_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_perpc, value);
+             break;
+        case e_FM_PCD_PLCR_PROFILE_RECOLOURED_YELLOW_PACKET_TOTAL_COUNTER:
+             WRITE_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_perypc ,value);
+             break;
+        case e_FM_PCD_PLCR_PROFILE_RECOLOURED_RED_PACKET_TOTAL_COUNTER:
+             WRITE_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_perrpc ,value);
+             break;
+        default:
+            RETURN_ERROR(MAJOR, E_INVALID_SELECTION, NO_MSG);
+    }
+
+    /*  Activate the atomic write action by writing FMPL_PAR with: GO=1, RW=1, PSI=0, PNUM =
+     *  Profile Number, PWSEL=0xFFFF (select all words).
+     */
+    tmpReg32 = FmPcdPlcrBuildWritePlcrActionReg(profileIndx);
+    tmpReg32 |= FmPcdPlcrBuildCounterProfileReg(counter);
+    WritePar(p_FmPcd, tmpReg32);
+
+     return E_OK;
+#endif /* CONFIG_MULTI_PARTITION_SUPPORT */
+}
+
+t_Error FM_PCD_ConfigPlcrNumOfSharedProfiles(t_Handle h_FmPcd, uint16_t numOfSharedPlcrProfiles)
+{
+   t_FmPcd *p_FmPcd = (t_FmPcd*)h_FmPcd;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdDriverParam, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdPlcr, E_INVALID_HANDLE);
+
+    p_FmPcd->p_FmPcdPlcr->numOfSharedProfiles = numOfSharedPlcrProfiles;
+
+    return E_OK;
+}
+
+t_Error FM_PCD_SetPlcrStatistics(t_Handle h_FmPcd, bool enable)
+{
+   t_FmPcd  *p_FmPcd = (t_FmPcd*)h_FmPcd;
+#ifndef CONFIG_GUEST_PARTITION
+   uint32_t tmpReg32;
+#else
+    UNUSED(enable);
+#endif /* !CONFIG_GUEST_PARTITION */
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdPlcr, E_INVALID_HANDLE);
+#ifndef CONFIG_GUEST_PARTITION
+    tmpReg32 =  GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_gcr);
+    if(enable)
+        tmpReg32 |= FM_PCD_PLCR_GCR_STEN;
+    else
+        tmpReg32 &= ~FM_PCD_PLCR_GCR_STEN;
+
+    WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_gcr, tmpReg32);
+#else
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+#endif
+    return E_OK;
+}
+
+#ifndef CONFIG_GUEST_PARTITION
+t_Error FM_PCD_ConfigPlcrAutoRefreshMode(t_Handle h_FmPcd, bool enable)
+{
+   t_FmPcd *p_FmPcd = (t_FmPcd*)h_FmPcd;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdDriverParam, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdPlcr, E_INVALID_HANDLE);
+
+    p_FmPcd->p_FmPcdDriverParam->plcrAutoRefresh = enable;
+
+    return E_OK;
+}
+
+/* ... */
+
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+t_Error FM_PCD_PlcrDumpRegs(t_Handle h_FmPcd)
+{
+    t_FmPcd                             *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    t_FmPcdPlcrInterModuleProfileRegs   *p_ProfilesRegs;
+    int                                 i = 0;
+    uint32_t                            tmpReg;
+
+    DECLARE_DUMP;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdPlcr, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE);
+
+    DUMP_SUBTITLE(("\n"));
+    DUMP_TITLE(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs, ("FmPcdPlcrRegs Regs"));
+
+    DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_gcr);
+    DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_gsr);
+    DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_evr);
+    DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_ier);
+    DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_ifr);
+    DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_eevr);
+    DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_eier);
+    DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_eifr);
+    DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_rpcnt);
+    DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_ypcnt);
+    DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_rrpcnt);
+    DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_rypcnt);
+    DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_tpcnt);
+    DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_flmcnt);
+
+    p_ProfilesRegs = &p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->profileRegs;
+
+    for(i = 0;i<FM_PCD_PLCR_NUM_ENTRIES; i++)
+    {
+        tmpReg = FmPcdPlcrBuildReadPlcrActionReg((uint16_t)i);
+        WritePar(p_FmPcd, tmpReg);
+
+        DUMP_TITLE(p_ProfilesRegs, ("Profile %d regs", i));
+
+        DUMP_VAR(p_ProfilesRegs, fmpl_pemode);
+        DUMP_VAR(p_ProfilesRegs, fmpl_pegnia);
+        DUMP_VAR(p_ProfilesRegs, fmpl_peynia);
+        DUMP_VAR(p_ProfilesRegs, fmpl_pernia);
+        DUMP_VAR(p_ProfilesRegs, fmpl_pecir);
+        DUMP_VAR(p_ProfilesRegs, fmpl_pecbs);
+        DUMP_VAR(p_ProfilesRegs, fmpl_pepepir_eir);
+        DUMP_VAR(p_ProfilesRegs, fmpl_pepbs_ebs);
+        DUMP_VAR(p_ProfilesRegs, fmpl_pelts);
+        DUMP_VAR(p_ProfilesRegs, fmpl_pects);
+        DUMP_VAR(p_ProfilesRegs, fmpl_pepts_ets);
+        DUMP_VAR(p_ProfilesRegs, fmpl_pegpc);
+        DUMP_VAR(p_ProfilesRegs, fmpl_peypc);
+        DUMP_VAR(p_ProfilesRegs, fmpl_perpc);
+        DUMP_VAR(p_ProfilesRegs, fmpl_perypc);
+        DUMP_VAR(p_ProfilesRegs, fmpl_perrpc);
+    }
+
+    DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_serc);
+    DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_upcr);
+    DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_dpmr);
+
+
+    DUMP_TITLE(&p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_pmr, ("fmpl_pmr"));
+    DUMP_SUBSTRUCT_ARRAY(i, 63)
+    {
+        DUMP_MEMORY(&p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_pmr[i], sizeof(uint32_t));
+    }
+
+    return E_OK;
+}
+#endif /* (defined(DEBUG_ERRORS) && ... */
+#endif /* ! CONFIG_GUEST_PARTITION */
+
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.c b/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.c
new file mode 100644
index 0000000..893f877
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.c
@@ -0,0 +1,395 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/******************************************************************************
+ @File          fm_pcd.c
+
+ @Description   FM PCD ...
+*//***************************************************************************/
+#include "std_ext.h"
+#include "error_ext.h"
+#include "string_ext.h"
+#include "debug_ext.h"
+
+#include "fm_pcd.h"
+#include "net_ext.h"
+
+
+t_Handle PrsConfig(t_FmPcd *p_FmPcd,t_FmPcdParams *p_FmPcdParams)
+{
+    t_FmPcdPrs  *p_FmPcdPrs;
+#ifndef CONFIG_GUEST_PARTITION
+    uint64_t    baseAddr = FmGetPcdPrsBaseAddr(p_FmPcdParams->h_Fm);
+#endif /* !CONFIG_GUEST_PARTITION */
+
+    UNUSED(p_FmPcd);
+    UNUSED(p_FmPcdParams);
+
+    p_FmPcdPrs = (t_FmPcdPrs *) XX_Malloc(sizeof(t_FmPcdPrs));
+    if (!p_FmPcdPrs)
+    {
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM Parser structure allocation FAILED"));
+        return NULL;
+    }
+    memset(p_FmPcdPrs, 0, sizeof(t_FmPcdPrs));
+
+#ifndef CONFIG_GUEST_PARTITION
+    p_FmPcdPrs->p_SwPrsCode  = CAST_UINT64_TO_POINTER_TYPE(uint32_t, baseAddr);
+    p_FmPcdPrs->p_FmPcdPrsRegs  = CAST_UINT64_TO_POINTER_TYPE(t_FmPcdPrsRegs, (baseAddr + PRS_REGS_OFFSET));
+#ifdef CONFIG_MULTI_PARTITION_SUPPORT
+    p_FmPcdPrs->fmPcdPrsPortIdStatistics             = DEFAULT_fmPcdPrsPortIdStatictics;
+#else
+    p_FmPcdPrs->fmPcdPrsPortIdStatistics             = 0;
+#endif /* CONFIG_MULTI_PARTITION_SUPPORT */
+    p_FmPcd->p_FmPcdDriverParam->prsMaxParseCycleLimit   = DEFAULT_prsMaxParseCycleLimit;
+    p_FmPcd->exceptions |= (DEFAULT_fmPcdPrsErrorExceptions | DEFAULT_fmPcdPrsExceptions);
+#endif /* !CONFIG_GUEST_PARTITION */
+
+    return p_FmPcdPrs;
+}
+
+#ifndef CONFIG_GUEST_PARTITION
+static void PcdPrsErrorException(t_Handle h_FmPcd)
+{
+    t_FmPcd                 *p_FmPcd = (t_FmPcd *)h_FmPcd;
+    uint32_t                event;
+
+    event = GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->perr);
+    event &= GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->perer);
+
+    WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->perr, event);
+
+    DBG(TRACE, ("parser error - 0x%08x\n",event));
+
+    if(event & FM_PCD_PRS_DOUBLE_ECC)
+        p_FmPcd->f_FmPcdException(p_FmPcd->h_App,e_FM_PCD_PRS_EXCEPTION_DOUBLE_ECC);
+    if(event & FM_PCD_PRS_ILLEGAL_ACCESS)
+        p_FmPcd->f_FmPcdException(p_FmPcd->h_App,e_FM_PCD_PRS_EXCEPTION_ILLEGAL_ACCESS);
+    if(event & FM_PCD_PRS_PORT_ILLEGAL_ACCESS)
+//#warning - change to indexed? how?
+        p_FmPcd->f_FmPcdException(p_FmPcd->h_App,e_FM_PCD_PRS_EXCEPTION_PORT_ILLEGAL_ACCESS);
+}
+
+static void PcdPrsException(t_Handle h_FmPcd)
+{
+    t_FmPcd             *p_FmPcd = (t_FmPcd *)h_FmPcd;
+    uint32_t            event;
+
+    event = GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->pevr);
+    event &= GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->pever);
+
+    ASSERT_COND(event & FM_PCD_PRS_SINGLE_ECC);
+
+    DBG(TRACE, ("parser event - 0x%08x\n",event));
+
+    WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->pevr, event);
+
+    p_FmPcd->f_FmPcdException(p_FmPcd->h_App,e_FM_PCD_PRS_EXCEPTION_SINGLE_ECC);
+}
+
+static uint32_t GetSwPrsOffset(t_Handle h_FmPcd,  e_NetHeaderType hdr, uint8_t  indexPerHdr)
+{
+    t_FmPcd                 *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    int                     i;
+    t_FmPcdPrsLabelParams   *p_Label;
+
+    SANITY_CHECK_RETURN_VALUE(p_FmPcd, E_INVALID_HANDLE, 0);
+    SANITY_CHECK_RETURN_VALUE(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_HANDLE, 0);
+
+    p_Label = p_FmPcd->p_FmPcdPrs->labelsTable;
+    for(i=0;i<p_FmPcd->p_FmPcdPrs->currLabel;i++, p_Label = &p_FmPcd->p_FmPcdPrs->labelsTable[i])
+    {
+        if((hdr == p_Label->hdr) && (indexPerHdr == p_Label->indexPerHdr))
+            return p_Label->instructionOffset;
+    }
+
+    REPORT_ERROR(MINOR, E_NOT_FOUND, ("Sw Parser attachment Not found"));
+    return (uint32_t)ILLEGAL_BASE;
+}
+
+t_Error PrsInit(t_FmPcd *p_FmPcd)
+{
+    t_FmPcdDriverParam  *p_Param = p_FmPcd->p_FmPcdDriverParam;
+    t_FmPcdPrsRegs      *p_Regs = p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs;
+    uint32_t            i, j;
+    uint32_t            tmpReg;
+    uint8_t             swPrsL4Patch[] = SW_PRS_L4_PATCH;
+
+    /**********************RPCLIM******************/
+    /*TODO - what default value to put*/
+    WRITE_UINT32(p_Regs->rpclim, (uint32_t)p_Param->prsMaxParseCycleLimit);
+    /**********************FMPL_RPCLIM******************/
+
+    /* register even if no interrupts enabled, to allow future enablement */
+    FmRegisterIntr(p_FmPcd->h_Fm, e_FM_EV_ERR_PRS, PcdPrsErrorException, p_FmPcd);
+
+    /* register even if no interrupts enabled, to allow future enablement */
+    FmRegisterIntr(p_FmPcd->h_Fm, e_FM_EV_PRS, PcdPrsException, p_FmPcd);
+
+    /**********************PEVR******************/
+    WRITE_UINT32(p_Regs->pevr, (FM_PCD_PRS_SINGLE_ECC | FM_PCD_PRS_PORT_IDLE_STS) );
+    /**********************PEVR******************/
+
+    /**********************PEVER******************/
+    if(p_FmPcd->exceptions & FM_PCD_EX_PRS_SINGLE_ECC)
+    {
+        if(!FmRamsEccIsExternalCtl(p_FmPcd->h_Fm))
+            FM_EnableRamsEcc(p_FmPcd->h_Fm);
+        WRITE_UINT32(p_Regs->pever, FM_PCD_PRS_SINGLE_ECC);
+    }
+    else
+        WRITE_UINT32(p_Regs->pever, 0);
+    /**********************PEVER******************/
+
+    /**********************PERR******************/
+    WRITE_UINT32(p_Regs->perr, (FM_PCD_PRS_DOUBLE_ECC  |
+                               FM_PCD_PRS_PORT_ILLEGAL_ACCESS |
+                               FM_PCD_PRS_ILLEGAL_ACCESS));
+    /**********************PERR******************/
+
+    /**********************PERER******************/
+    tmpReg = 0;
+    if(p_FmPcd->exceptions & FM_PCD_EX_PRS_DOUBLE_ECC)
+    {
+        FM_EnableRamsEcc(p_FmPcd->h_Fm);
+        tmpReg |= FM_PCD_PRS_DOUBLE_ECC;
+    }
+    if(p_FmPcd->exceptions & FM_PCD_EX_PRS_ILLEGAL_ACCESS)
+        tmpReg |= FM_PCD_PRS_ILLEGAL_ACCESS;
+    if(p_FmPcd->exceptions & FM_PCD_EX_PRS_PORT_ILLEGAL_ACCESS)
+        tmpReg |= FM_PCD_PRS_PORT_ILLEGAL_ACCESS;
+    WRITE_UINT32(p_Regs->perer, tmpReg);
+    /**********************PERER******************/
+
+    /**********************PPCS******************/
+    WRITE_UINT32(p_Regs->ppsc, p_FmPcd->p_FmPcdPrs->fmPcdPrsPortIdStatistics);
+    /**********************PPCS******************/
+
+    /* load sw parser L4 patch */
+    for(i=0;i<sizeof(swPrsL4Patch)/4;i++)
+    {
+       tmpReg = 0;
+       for(j =0;j<4;j++)
+       {
+          tmpReg <<= 8;
+          tmpReg |= swPrsL4Patch[i*4+j];
+
+       }
+        WRITE_UINT32(*(p_FmPcd->p_FmPcdPrs->p_SwPrsCode+ PRS_SW_OFFSET/4 + i), tmpReg);
+    }
+    p_FmPcd->p_FmPcdPrs->p_CurrSwPrs = PRS_SW_OFFSET/4 + p_FmPcd->p_FmPcdPrs->p_SwPrsCode+sizeof(swPrsL4Patch)/4;
+    p_FmPcd->p_FmPcdPrs->currLabel = 0;
+    return E_OK;
+}
+
+t_Error PrsEnable(t_FmPcd *p_FmPcd )
+{
+    t_FmPcdPrsRegs      *p_Regs = p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs;
+
+    WRITE_UINT32(p_Regs->rpimac, GET_UINT32(p_Regs->rpimac) | FM_PCD_PRS_RPIMAC_EN);
+
+    return E_OK;
+}
+
+
+
+#ifndef CONFIG_MULTI_PARTITION_SUPPORT
+void FmPcdPrsIncludePortInStatistics(t_Handle h_FmPcd, uint8_t hardwarePortId, bool include)
+{
+    t_FmPcd     *p_FmPcd = (t_FmPcd *)h_FmPcd;
+    uint32_t    bitMask = 0;
+    uint8_t     prsPortId;
+
+    SANITY_CHECK_RETURN((hardwarePortId >=1 && hardwarePortId <= 16), E_INVALID_VALUE);
+    SANITY_CHECK_RETURN(p_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN(p_FmPcd->p_FmPcdPrs, E_INVALID_HANDLE);
+
+    GET_FM_PCD_PRS_PORT_ID(prsPortId, hardwarePortId);
+    GET_FM_PCD_INDEX_FLAG(bitMask, prsPortId) ;
+
+    if(include)
+        p_FmPcd->p_FmPcdPrs->fmPcdPrsPortIdStatistics |= bitMask;
+    else
+        p_FmPcd->p_FmPcdPrs->fmPcdPrsPortIdStatistics &= ~bitMask;
+
+    WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->ppsc, p_FmPcd->p_FmPcdPrs->fmPcdPrsPortIdStatistics);
+}
+#endif /* CONFIG_MULTI_PARTITION_SUPPORT */
+#endif /* ! CONFIG_GUEST_PARTITION */
+
+uint32_t FmPcdGetSwPrsOffset(t_Handle h_FmPcd, e_NetHeaderType hdr, uint8_t indexPerHdr)
+{
+#ifdef CONFIG_GUEST_PARTITION
+    t_Error                 err;
+    t_FmPcdIpcSwPrsLable    labelParams;
+
+    labelParams.hdr = hdr;
+    labelParams.indexPerHdr = indexPerHdr;
+    err = XX_SendMessage(((t_FmPcd *)h_FmPcd)->fmPcdModuleName, FM_PCD_GET_SW_PRS_OFFSET, (uint8_t*)&labelParams, NULL, NULL);
+    if(err)
+        REPORT_ERROR(MAJOR, err, NO_MSG);
+    XX_Free(labelParams.p_SwPrsLabel);
+
+    return  labelParams.offset;
+#else
+    return GetSwPrsOffset(h_FmPcd, hdr, indexPerHdr);
+#endif /* CONFIG_GUEST_PARTITION */
+}
+
+#ifndef CONFIG_GUEST_PARTITION
+void FM_PCD_PrsStatistics(t_Handle h_FmPcd, bool enable)
+{
+    t_FmPcd             *p_FmPcd = (t_FmPcd*)h_FmPcd;
+
+    SANITY_CHECK_RETURN(p_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN(p_FmPcd->p_FmPcdPrs, E_INVALID_HANDLE);
+
+    if(enable)
+        WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->ppsc, FM_PCD_PRS_PPSC_ALL_PORTS);
+    else
+        WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->ppsc, 0);
+
+}
+
+t_Error FM_PCD_PrsLoadSw(t_Handle h_FmPcd, t_FmPcdPrsSwParams *p_SwPrs)
+{
+    t_FmPcd                 *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    uint32_t                *p_LoadTarget, tmpReg;
+    int                     i, j;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdPrs, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(p_SwPrs, E_INVALID_HANDLE);
+
+
+    if(!p_SwPrs->override)
+    {
+        if(p_FmPcd->p_FmPcdPrs->p_CurrSwPrs > p_FmPcd->p_FmPcdPrs->p_SwPrsCode + p_SwPrs->base*2/4)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("SW parser base must be larger than current loaded code"));
+    }
+    if(p_SwPrs->size > FM_SW_PRS_SIZE - PRS_SW_TAIL_SIZE - p_SwPrs->base*2)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("p_SwPrs->size may not be larger than MAX_SW_PRS_CODE_SIZE"));
+    if(p_SwPrs->size % 4)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("p_SwPrs->size must be divisible by 4"));
+
+    /* save sw parser lables */
+    if(p_SwPrs->override)
+        p_FmPcd->p_FmPcdPrs->currLabel = 0;
+    if(p_FmPcd->p_FmPcdPrs->currLabel+ p_SwPrs->numOfLabels > FM_PCD_PRS_NUM_OF_LABELS)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Exceeded number of labels allowed "));
+    memcpy(&p_FmPcd->p_FmPcdPrs->labelsTable[p_FmPcd->p_FmPcdPrs->currLabel], p_SwPrs->labelsTable, p_SwPrs->numOfLabels*sizeof(t_FmPcdPrsLabelParams));
+    p_FmPcd->p_FmPcdPrs->currLabel += p_SwPrs->numOfLabels;
+    /* load sw parser code */
+    p_LoadTarget = p_FmPcd->p_FmPcdPrs->p_SwPrsCode + p_SwPrs->base*2/4;//+ PRS_SW_OFFSET/4 + sizeof(swPrsL4Patch)/4;
+    for(i=0;i<p_SwPrs->size/4;i++)
+    {
+        tmpReg = 0;
+        for(j =0;j<4;j++)
+        {
+            tmpReg <<= 8;
+            tmpReg |= *(p_SwPrs->p_Code+i*4+j);
+        }
+        WRITE_UINT32(*(p_LoadTarget + i), tmpReg);
+    }
+    p_FmPcd->p_FmPcdPrs->p_CurrSwPrs = p_FmPcd->p_FmPcdPrs->p_SwPrsCode + p_SwPrs->base*2/4 + p_SwPrs->size/4;
+
+    /* copy data parameters */
+    for(i=0;i<FM_PCD_PRS_NUM_OF_HDRS;i++)
+        WRITE_UINT32(*(p_FmPcd->p_FmPcdPrs->p_SwPrsCode+PRS_SW_DATA/4+i), p_SwPrs->swPrsDataParams[i]);
+
+
+    /* Clear last 4 bytes */
+    WRITE_UINT32(*(p_FmPcd->p_FmPcdPrs->p_SwPrsCode+(PRS_SW_DATA-PRS_SW_TAIL_SIZE)/4), 0);
+
+    return E_OK;
+}
+
+t_Error FM_PCD_ConfigPrsMaxCycleLimit(t_Handle h_FmPcd,uint16_t value)
+{
+    t_FmPcd *p_FmPcd = (t_FmPcd*)h_FmPcd;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdDriverParam, E_INVALID_HANDLE);
+
+    p_FmPcd->p_FmPcdDriverParam->prsMaxParseCycleLimit = value;
+
+    return E_OK;
+}
+
+
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+t_Error FM_PCD_PrsDumpRegs(t_Handle h_FmPcd)
+{
+    t_FmPcd             *p_FmPcd = (t_FmPcd*)h_FmPcd;
+
+    DECLARE_DUMP;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdPrs, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE);
+
+    DUMP_SUBTITLE(("\n"));
+    DUMP_TITLE(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs, ("FmPcdPrsRegs Regs"));
+
+    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,rpclim);
+    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,rpimac);
+    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,pmeec);
+    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,pevr);
+    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,pever);
+    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,pevfr);
+    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,perr);
+    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,perer);
+    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,perfr);
+    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,ppsc);
+    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,pds);
+    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,l2rrs);
+    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,l3rrs);
+    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,l4rrs);
+    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,srrs);
+    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,l2rres);
+    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,l3rres);
+    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,l4rres);
+    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,srres);
+    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,spcs);
+    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,spscs);
+    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,hxscs);
+    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,mrcs);
+    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,mwcs);
+    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,mrscs);
+    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,mwscs);
+    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,fcscs);
+
+    return E_OK;
+}
+#endif /* (defined(DEBUG_ERRORS) && ... */
+#endif  /* !CONFIG_GUEST_PARTITION */
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/Port/Makefile b/drivers/net/dpa/NetCommSw/Peripherals/FM/Port/Makefile
new file mode 100644
index 0000000..8799431
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/Port/Makefile
@@ -0,0 +1,19 @@
+#
+# Makefile for the Freescale Ethernet controllers
+#
+EXTRA_CFLAGS           += -DVERSION=\"\"
+#
+#Include netcomm SW specific definitions
+include $(srctree)/drivers/net/dpa/NetCommSw/ncsw_config.mk
+
+NCSW_FM_INC = $(srctree)/drivers/net/dpa/NetCommSw/Peripherals/FM/inc
+
+EXTRA_CFLAGS += -I$(NCSW_FM_INC)
+
+obj-y		+= fsl-ncsw-Pcd.o
+
+fsl-ncsw-Pcd-objs	:=   fm_port.o fm_port_im.o
+
+
+
+
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/Port/fm_port.c b/drivers/net/dpa/NetCommSw/Peripherals/FM/Port/fm_port.c
new file mode 100644
index 0000000..3670a6f
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/Port/fm_port.c
@@ -0,0 +1,4022 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/******************************************************************************
+ @File          fm_port.c
+
+ @Description   FM driver routines implementation.
+*//***************************************************************************/
+#include "error_ext.h"
+#include "std_ext.h"
+#include "string_ext.h"
+#include "sprint_ext.h"
+#include "debug_ext.h"
+#include "fm_pcd_ext.h"
+
+#include "fm_port.h"
+
+
+/****************************************/
+/*       static functions               */
+/****************************************/
+
+static t_Error CheckInitParameters(t_FmPort *p_FmPort)
+{
+    t_FmPortDriverParam *p_Params = p_FmPort->p_FmPortDriverParam;
+    t_Error             ans;
+    uint8_t             i;
+    uint32_t            unusedMask;
+
+    if (p_FmPort->imEn)
+    {
+        if ((ans = FmPortImCheckInitParameters(p_FmPort)) != E_OK)
+            return ERROR_CODE(ans);
+    }
+    else
+    {
+        /****************************************/
+        /*   Rx only                            */
+        /****************************************/
+        if((p_FmPort->portType == e_FM_PORT_TYPE_RX) || (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
+        {
+            /* pools id may be 0-31 */
+            /* external buffer pools */
+            if(!p_Params->rxExtBufPools.numOfPoolsUsed)
+                 RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("rxExtBufPools.numOfPoolsUsed=0. At least one buffer pool must be defined"));
+
+            if(p_Params->rxExtBufPools.numOfPoolsUsed > FM_PORT_MAX_NUM_OF_EXT_POOLS)
+                    RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("numOfPoolsUsed can't be larger than %d", MAX_NUM_OF_EXT_POOLS));
+
+            for(i=0;i<p_Params->rxExtBufPools.numOfPoolsUsed;i++)
+            {
+                if(p_Params->rxExtBufPools.rxExtBufPool[i].id >= MAX_NUM_OF_EXT_POOLS)
+                    RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("rxExtBufPools.rxExtBufPool[i].id can't be larger than %d", MAX_NUM_OF_EXT_POOLS));
+                if(!p_Params->rxExtBufPools.rxExtBufPool[i].size)
+                    RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("rxExtBufPools.rxExtBufPool[i].size is 0"));
+            }
+
+            /* up to rxExtBufPools.numOfPoolsUsed pools may be defined */
+            if((p_Params->bufPoolDepletion.numOfPools > p_Params->rxExtBufPools.numOfPoolsUsed))
+                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("bufPoolDepletion.numOfPools can't be larger than %d and can't be larger than numOfPoolsUsed", FM_PORT_MAX_NUM_OF_EXT_POOLS));
+
+            /* Check that part of IC that needs copying is small enough to enter start margin */
+            if(p_Params->intContext.size + p_Params->intContext.extBufOffset > p_Params->bufMargins.startMargins)
+                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("intContext.size is larger than start margins"));
+
+            if(p_Params->partitionId >= FM_MAX_NUM_OF_PARTITIONS)
+                 RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("partitionId can't be larger than %d", FM_MAX_NUM_OF_PARTITIONS-1));
+        }
+
+        /****************************************/
+        /*   Non Rx ports                       */
+        /****************************************/
+        else
+        {
+            if(p_Params->deqSubPortal > MAX_QMI_DEQ_SUBPORTAL)
+                 RETURN_ERROR(MAJOR, E_INVALID_VALUE, (" deqSubPortal has to be in the range of 0 - %d", MAX_QMI_DEQ_SUBPORTAL));
+
+            /* to protect HW internal-context from overwrite */
+            if((p_Params->intContext.size) && (p_Params->intContext.intContextOffset < MIN_TX_INT_OFFSET))
+                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("non-Rx intContext.intContextOffset can't be smaller than %d", MIN_TX_INT_OFFSET));
+        }
+
+        /****************************************/
+        /*   Rx Or Offline Parsing              */
+        /****************************************/
+        if((p_FmPort->portType == e_FM_PORT_TYPE_RX) || (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G) || (p_FmPort->portType == e_FM_PORT_TYPE_OFFLINE_PARSING))
+            if(!p_Params->dfltFqid)
+                 RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dfltFqid must be between 1 and 2^24-1"));
+
+        /****************************************/
+        /*   All ports                          */
+        /****************************************/
+        /* common BMI registers values */
+        /* Check that Queue Id is not larger than 2^24, and is not 0 */
+        if((p_Params->errFqid & ~0x00FFFFFF) || !p_Params->errFqid)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("errFqid must be between 1 and 2^24-1"));
+        if(p_Params->dfltFqid & ~0x00FFFFFF)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dfltFqid must be between 1 and 2^24-1"));
+    }
+
+    /****************************************/
+    /*   Rx only                            */
+    /****************************************/
+    if((p_FmPort->portType == e_FM_PORT_TYPE_RX) || (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
+    {
+        /* Check that divisible by 256 and not larger than 256 */
+        if(p_Params->rxFifoPriElevationLevel % BMI_FIFO_UNITS)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("rxFifoPriElevationLevel has to be divisible by %d", BMI_FIFO_UNITS));
+        if(!p_Params->rxFifoPriElevationLevel || (p_Params->rxFifoPriElevationLevel > BMI_MAX_FIFO_SIZE))
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("rxFifoPriElevationLevel has to be in the range of 256 - %d", BMI_MAX_FIFO_SIZE));
+        if(p_Params->rxFifoThreshold % BMI_FIFO_UNITS)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("rxFifoThreshold has to be divisible by %d", BMI_FIFO_UNITS));
+        if(!p_Params->rxFifoThreshold ||(p_Params->rxFifoThreshold > BMI_MAX_FIFO_SIZE))
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("rxFifoThreshold has to be in the range of 256 - %d", BMI_MAX_FIFO_SIZE));
+
+        /* Check that not larger than 16 */
+        if(p_Params->cutBytesFromEnd > FRAME_END_DATA_SIZE)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("cutBytesFromEnd can't be larger than %d", FRAME_END_DATA_SIZE));
+
+        /* Check the margin definition */
+        if(p_Params->bufMargins.startMargins > MAX_EXT_BUFFER_OFFSET)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("bufMargins.startMargins can't be larger than %d", MAX_EXT_BUFFER_OFFSET));
+        if(p_Params->bufMargins.endMargins > MAX_EXT_BUFFER_OFFSET)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("bufMargins.endMargins can't be larger than %d", MAX_EXT_BUFFER_OFFSET));
+
+        /* extra FIFO size (allowed only to Rx ports) */
+        if(p_Params->fifoBufs.extra % BMI_FIFO_UNITS)
+             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fifoBufs.extra has to be divisible by %d", BMI_FIFO_UNITS));
+
+        if(p_Params->bufPoolDepletion.numberOfPoolsModeEnable &&
+           !p_Params->bufPoolDepletion.numOfPools)
+              RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("bufPoolDepletion.numOfPoolsToConsider can not be 0 when numberOfPoolsModeEnable=TRUE"));
+    }
+
+    /****************************************/
+    /*   Non Rx ports                       */
+    /****************************************/
+    else
+        /* extra FIFO size (allowed only to Rx ports) */
+        if(p_Params->fifoBufs.extra)
+             RETURN_ERROR(MAJOR, E_INVALID_VALUE, (" No fifoBufs.extra for non Rx ports"));
+
+    /****************************************/
+    /*   Rx & Tx                            */
+    /****************************************/
+    if((p_FmPort->portType == e_FM_PORT_TYPE_TX) || (p_FmPort->portType == e_FM_PORT_TYPE_TX_10G) ||
+        (p_FmPort->portType == e_FM_PORT_TYPE_RX) || (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
+    {
+        /* Check that not larger than 16 */
+        if(p_Params->cheksumLastBytesIgnore > FRAME_END_DATA_SIZE)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("cheksumLastBytesIgnore can't be larger than %d", FRAME_END_DATA_SIZE));
+    }
+
+    /****************************************/
+    /*   Tx only                            */
+    /****************************************/
+    if((p_FmPort->portType == e_FM_PORT_TYPE_TX) || (p_FmPort->portType == e_FM_PORT_TYPE_TX_10G))
+    {
+        /* Check that divisible by 256 and not larger than 256 */
+        if(p_Params->txFifoMinFillLevel % BMI_FIFO_UNITS)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("txFifoMinFillLevel has to be divisible by %d", BMI_FIFO_UNITS));
+        if(p_Params->txFifoMinFillLevel > (BMI_MAX_FIFO_SIZE - 256))
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("txFifoMinFillLevel has to be in the range of 0 - %d", BMI_MAX_FIFO_SIZE));
+        if(p_Params->txFifoLowComfLevel % BMI_FIFO_UNITS)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("txFifoLowComfLevel has to be divisible by %d", BMI_FIFO_UNITS));
+        if(!p_Params->txFifoLowComfLevel || (p_Params->txFifoLowComfLevel > BMI_MAX_FIFO_SIZE))
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("txFifoLowComfLevel has to be in the range of 256 - %d", BMI_MAX_FIFO_SIZE));
+
+        /* Check that not larger than 8 */
+        if((!p_FmPort->txFifoDeqPipelineDepth) ||( p_FmPort->txFifoDeqPipelineDepth > MAX_FIFO_PIPELINE_DEPTH))
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("txFifoDeqPipelineDepth can't be larger than %d", MAX_FIFO_PIPELINE_DEPTH));
+        if(p_FmPort->portType == e_FM_PORT_TYPE_TX)
+            if(p_FmPort->txFifoDeqPipelineDepth > 2)
+                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("txFifoDeqPipelineDepth for !G can't be larger than 2"));
+    }
+    else
+    /****************************************/
+    /*   Non Tx Ports                       */
+    /****************************************/
+    {
+        /* If discard override was selected , no frames may be discarded. */
+        if(p_Params->frmDiscardOverride && p_Params->errorsToDiscard)
+            RETURN_ERROR(MAJOR, E_CONFLICT, ("errorsToDiscard is not empty, but frmDiscardOverride selected (all discarded frames to be enqueued to error queue)."));
+    }
+
+    /****************************************/
+    /*   Rx and Offline parsing             */
+    /****************************************/
+    if((p_FmPort->portType == e_FM_PORT_TYPE_RX) || (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G)
+        || (p_FmPort->portType == e_FM_PORT_TYPE_OFFLINE_PARSING))
+    {
+        if(p_FmPort->portType == e_FM_PORT_TYPE_OFFLINE_PARSING)
+            unusedMask = BMI_STATUS_OP_MASK_UNUSED;
+        else
+            unusedMask = BMI_STATUS_RX_MASK_UNUSED;
+
+        /* Check that no common bits with BMI_STATUS_MASK_UNUSED */
+        if(p_Params->errorsToDiscard & unusedMask)
+            RETURN_ERROR(MAJOR, E_INVALID_SELECTION, ("errorsToDiscard contains undefined bits"));
+    }
+
+    /****************************************/
+    /*   All ports                          */
+    /****************************************/
+    /* Check that divisible by 16 and not larger than 240 */
+    if(p_Params->intContext.intContextOffset >MAX_INT_OFFSET)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("intContext.intContextOffset can't be larger than %d", MAX_INT_OFFSET));
+    if(p_Params->intContext.intContextOffset % OFFSET_UNITS)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("intContext.intContextOffset has to be divisible by %d", OFFSET_UNITS));
+
+    /* check that ic size+ic internal offset, does not exceed ic block size */
+    if(p_Params->intContext.size + p_Params->intContext.intContextOffset > MAX_IC_SIZE)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("intContext.size + intContext.intContextOffset has to be smaller than %d", MAX_IC_SIZE));
+    /* Check that divisible by 16 and not larger than 256 */
+    if(p_Params->intContext.size % OFFSET_UNITS)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("intContext.size  has to be divisible by %d", OFFSET_UNITS));
+
+    /* Check that divisible by 16 and not larger than 4K */
+    if(p_Params->intContext.extBufOffset > MAX_EXT_OFFSET)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("intContext.extBufOffset can't be larger than %d", MAX_EXT_OFFSET));
+    if(p_Params->intContext.extBufOffset % OFFSET_UNITS)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("intContext.extBufOffset  has to be divisible by %d", OFFSET_UNITS));
+
+    /* common BMI registers values */
+    if((!p_Params->tasks.num) || (p_Params->tasks.num > MAX_NUM_OF_TASKS))
+         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("tasks.num can't be larger than %d", MAX_NUM_OF_TASKS));
+    if(p_Params->tasks.extra > MAX_NUM_OF_EXTRA_TASKS)
+         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("tasks.extra can't be larger than %d", MAX_NUM_OF_EXTRA_TASKS));
+    if((!p_Params->openDmas.num) || (p_Params->openDmas.num > MAX_NUM_OF_DMAS))
+         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("openDmas.num can't be larger than %d", MAX_NUM_OF_DMAS));
+    if(p_Params->openDmas.extra > MAX_NUM_OF_EXTRA_DMAS)
+         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("openDmas.extra can't be larger than %d", MAX_NUM_OF_EXTRA_DMAS));
+    if(!p_Params->fifoBufs.num || (p_Params->fifoBufs.num > BMI_MAX_FIFO_SIZE))
+         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fifoBufs.num has to be in the range of 256 - %d", BMI_MAX_FIFO_SIZE));
+    if(p_Params->fifoBufs.num % BMI_FIFO_UNITS)
+         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fifoBufs.num has to be divisible by %d", BMI_FIFO_UNITS));
+
+    return E_OK;
+}
+
+static void FmPortDriverParamFree(t_FmPort *p_FmPort)
+{
+    if(p_FmPort->p_FmPortDriverParam)
+    {
+        XX_Free(p_FmPort->p_FmPortDriverParam);
+        p_FmPort->p_FmPortDriverParam = NULL;
+    }
+}
+
+static t_Error BmiRxPortInit(t_FmPort *p_FmPort)
+{
+    t_FmPortRxBmiRegs       *p_Regs = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs;
+    uint32_t                tmpReg;
+    t_FmPortDriverParam     *p_Params = p_FmPort->p_FmPortDriverParam;
+    uint32_t                vector = 0, errorsToEnq = 0;
+    uint16_t                bufSize = 0;
+    int                     i=0, j=0, k=0;
+    bool                    found;
+    uint8_t                 orderedArray[FM_PORT_MAX_NUM_OF_EXT_POOLS];
+    uint16_t                sizesArray[MAX_NUM_OF_EXT_POOLS];
+    uint8_t                 count = 0;
+
+    memset(&orderedArray, 0, sizeof(uint8_t) * FM_PORT_MAX_NUM_OF_EXT_POOLS);
+    memset(&sizesArray, 0, sizeof(uint16_t) * MAX_NUM_OF_EXT_POOLS);
+
+    /* check that port is not busy */
+    if (GET_UINT32(p_Regs->fmbm_rcfg) & BMI_PORT_CFG_EN)
+         RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Port is already enabled"));
+
+    /* Set Config register */
+    tmpReg = 0;
+    if (p_FmPort->imEn)
+        tmpReg |= BMI_PORT_CFG_IM;
+    /* No discard - all error frames go to error queue */
+    else if (p_Params->frmDiscardOverride)
+        tmpReg |= BMI_PORT_CFG_FDOVR;
+
+    WRITE_UINT32(p_Regs->fmbm_rcfg, tmpReg);
+
+    if (!p_FmPort->imEn)
+    {
+        /* define external buffer pools */
+        /* First we copy the external buffers pools information to an ordered local array */
+        for(i=0;i<p_Params->rxExtBufPools.numOfPoolsUsed;i++)
+        {
+            /* get pool size */
+            bufSize = p_Params->rxExtBufPools.rxExtBufPool[i].size;
+            /* check if pool size is not too big */
+            if(bufSize > p_Params->fifoBufs.num )
+                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Pool %d size is bigger than ports commited fifo size",
+                                                        p_Params->rxExtBufPools.rxExtBufPool[i].id));
+            /* keep sizes in an array according to poolId for direct access */
+            sizesArray[p_Params->rxExtBufPools.rxExtBufPool[i].id] =  bufSize;
+
+            /* save poolId in an ordered array according to size */
+            for (j=0;j<=i;j++)
+            {
+                /* this is the next free place in the array */
+                if (j==i)
+                    orderedArray[i] = p_Params->rxExtBufPools.rxExtBufPool[i].id;
+                else
+                {
+                    /* find the right place for this poolId */
+                    if(bufSize < sizesArray[orderedArray[j]])
+                    {
+                        /* move the poolIds one place ahead to make room for this poolId */
+                        for(k=i;k>j;k--)
+                           orderedArray[k] = orderedArray[k-1];
+
+                        /* now k==j, this is the place for the new size */
+                        orderedArray[k] = p_Params->rxExtBufPools.rxExtBufPool[i].id;
+                        break;
+                    }
+                }
+            }
+        }
+
+        /* build the register value */
+        for(i=0;i<p_Params->rxExtBufPools.numOfPoolsUsed;i++)
+        {
+            tmpReg = BMI_EXT_BUF_POOL_VALID | BMI_EXT_BUF_POOL_EN_COUNTER;
+            tmpReg |= (orderedArray[i] << BMI_EXT_BUF_POOL_ID_SHIFT);
+            tmpReg |= sizesArray[orderedArray[i]];
+            WRITE_UINT32(p_Regs->fmbm_ebmpi[i], tmpReg);
+        }
+
+        /* clear unused pools */
+        for(i=p_Params->rxExtBufPools.numOfPoolsUsed;i<FM_PORT_MAX_NUM_OF_EXT_POOLS;i++)
+            WRITE_UINT32(p_Regs->fmbm_ebmpi[i], 0);
+
+        /* pool depletion */
+        tmpReg = 0;
+        if(p_Params->bufPoolDepletion.numberOfPoolsModeEnable)
+        {
+            /* calculate vector for number of pools depletion */
+            found = FALSE;
+            vector = 0;
+            count = 0;
+            for(i=0;i<MAX_NUM_OF_EXT_POOLS;i++)
+            {
+                if(p_Params->bufPoolDepletion.poolsToConsider[i])
+                {
+                    for(j=0;j<p_Params->rxExtBufPools.numOfPoolsUsed;j++)
+                    {
+                        if (i == orderedArray[j])
+                        {
+                            vector |= 0x80000000 >> j;
+                            found = TRUE;
+                            count++;
+                            break;
+                        }
+                    }
+                    if (!found)
+                        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Pools selected for depletion are not used."));
+                    else
+                        found = FALSE;
+                }
+            }
+            if (count < p_Params->bufPoolDepletion.numOfPools)
+                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("bufPoolDepletion.numOfPools is larger than the number of pools defined."));
+
+            /* configure num of pools and vector for number of pools mode */
+            tmpReg |= ((p_Params->bufPoolDepletion.numOfPools - 1) << BMI_POOL_DEP_NUM_OF_POOLS_SHIFT);
+            tmpReg |= vector;
+        }
+
+        if(p_Params->bufPoolDepletion.singlePoolModeEnable)
+        {
+            /* calculate vector for number of pools depletion */
+            found = FALSE;
+            vector = 0;
+            count = 0;
+            for(i=0;i<MAX_NUM_OF_EXT_POOLS;i++)
+            {
+                if(p_Params->bufPoolDepletion.poolsToConsiderForSingleMode[i])
+                {
+                    for(j=0;j<p_Params->rxExtBufPools.numOfPoolsUsed;j++)
+                    {
+                        if (i == orderedArray[j])
+                         {
+                            vector |= 0x00000080 >> j;
+                            found = TRUE;
+                            count++;
+                            break;
+                        }
+                    }
+                    if (!found)
+                        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Pools selected for depletion are not used."));
+                    else
+                        found = FALSE;
+                }
+            }
+            if (!count)
+                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("No pools defined for single buffer mode pool depletion."));
+
+            /* configure num of pools and vector for number of pools mode */
+            tmpReg |= vector;
+        }
+
+        WRITE_UINT32(p_Regs->fmbm_mpd, tmpReg);
+    }
+
+    /* Configure dma attributes */
+    tmpReg = 0;
+    tmpReg |= p_Params->dmaSwapData << BMI_DMA_ATTR_SWP_SHIFT;
+    tmpReg |= p_Params->dmaIntContextCacheAttr << BMI_DMA_ATTR_IC_CACHE_SHIFT;
+    tmpReg |= p_Params->dmaHeaderCacheAttr << BMI_DMA_ATTR_HDR_CACHE_SHIFT;
+    tmpReg |= p_Params->dmaScatterGatherCacheAttr << BMI_DMA_ATTR_SG_CACHE_SHIFT;
+    if(p_Params->dmaReadOptimize)
+        tmpReg |= BMI_DMA_ATTR_READ_OPTIMIZE;
+    if(p_Params->dmaWriteOptimize)
+        tmpReg |= BMI_DMA_ATTR_WRITE_OPTIMIZE;
+
+    WRITE_UINT32(p_Regs->fmbm_rda, tmpReg);
+
+    /* Configure Rx Fifo params */
+    tmpReg = 0;
+    tmpReg |= ((p_Params->rxFifoPriElevationLevel/BMI_FIFO_UNITS - 1) << BMI_RX_FIFO_PRI_ELEVATION_SHIFT);
+    tmpReg |= ((p_Params->rxFifoThreshold/BMI_FIFO_UNITS - 1) << BMI_RX_FIFO_THRESHOLD_SHIFT);
+
+    WRITE_UINT32(p_Regs->fmbm_rfp, tmpReg);
+
+    /* frame end parameters */
+    tmpReg = 0;
+    tmpReg |= (p_Params->cheksumLastBytesIgnore << BMI_RX_FRAME_END_CS_IGNORE_SHIFT);
+    tmpReg |= (p_Params->cutBytesFromEnd << BMI_RX_FRAME_END_CUT_SHIFT);
+
+    WRITE_UINT32(p_Regs->fmbm_rfed, tmpReg);
+
+    /* IC parameters */
+
+    tmpReg = 0;
+    tmpReg |= ((p_Params->intContext.extBufOffset/OFFSET_UNITS) << BMI_IC_TO_EXT_SHIFT);
+    tmpReg |= ((p_Params->intContext.intContextOffset/OFFSET_UNITS) << BMI_IC_FROM_INT_SHIFT);
+    tmpReg |= ((p_Params->intContext.size/OFFSET_UNITS)  << BMI_IC_SIZE_SHIFT);
+
+    WRITE_UINT32(p_Regs->fmbm_ricp, tmpReg);
+
+    if (!p_FmPort->imEn)
+    {
+        /* check if the largest external buffer pool is large enough */
+        if(p_Params->bufMargins.startMargins + MIN_EXT_BUF_SIZE + p_Params->bufMargins.endMargins >
+                sizesArray[orderedArray[p_Params->rxExtBufPools.numOfPoolsUsed-1]])
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("bufMargins.startMargins (%d) + minimum buf size (64) + bufMargins.endMargins (%d) is larger than maximum external buffer size (%d)",
+                            p_Params->bufMargins.startMargins, p_Params->bufMargins.endMargins, sizesArray[orderedArray[p_Params->rxExtBufPools.numOfPoolsUsed]]));
+
+        /* buffer margins */
+        tmpReg = 0;
+        tmpReg |= ((p_Params->bufMargins.startMargins) << BMI_EXT_BUF_MARG_START_SHIFT);
+        tmpReg |= ((p_Params->bufMargins.endMargins) << BMI_EXT_BUF_MARG_END_SHIFT);
+
+        WRITE_UINT32(p_Regs->fmbm_rebm, tmpReg);
+    }
+#if 0 /* in our driver p_Params->bufMargins.startMargins is always aligned to 16 */
+    /* if p_Params->bufMargins.startMargins is not devisible by 16 (usually for alignment),
+    than we give a buffer (16 bytes) in order to avoid HW using the end of the previous buffer */
+    if(p_Params->bufMargins.startMargins % FRAME_OFFSET_UNITS)
+        WRITE_UINT32(p_Regs->fmbm_rim, 1 << BMI_RIM_FOF_SHIFT);
+#endif
+
+    /* NIA */
+    if (p_FmPort->imEn)
+        WRITE_UINT32(p_Regs->fmbm_rfne, NIA_ENG_FM_CTL | NIA_FM_CTL_AC_IND_MODE_RX);
+    else
+    {
+        tmpReg = 0;
+        if (p_Params->forwardReuseIntContext)
+            tmpReg |= BMI_PORT_RFNE_FRWD_RPD;
+        if (!p_Params->l4Checksum)
+            tmpReg |= BMI_PORT_RFNE_FRWD_DCL4C;
+        WRITE_UINT32(p_Regs->fmbm_rfne, tmpReg | NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME);
+    }
+    WRITE_UINT32(p_Regs->fmbm_rfene, NIA_ENG_QMI_ENQ | NIA_ORDER_RESTOR);
+
+    /* command attribute */
+    tmpReg = BMI_CMD_RX_MR_DEF;
+    if (!p_FmPort->imEn)
+    {
+        tmpReg |= BMI_CMD_ATTR_ORDER;
+        if(p_Params->syncReq)
+            tmpReg |= BMI_CMD_ATTR_SYNC ;
+        tmpReg |= (p_Params->color << BMI_CMD_ATTR_COLOR_SHIFT);
+    }
+
+    WRITE_UINT32(p_Regs->fmbm_rfca, tmpReg);
+
+    /* default queues */
+    if (!p_FmPort->imEn)
+    {
+        WRITE_UINT32(p_Regs->fmbm_rfqid, p_Params->dfltFqid);
+        WRITE_UINT32(p_Regs->fmbm_refqid, p_Params->errFqid);
+    }
+    WRITE_UINT32(p_Regs->fmbm_rstc, BMI_COUNTERS_EN);
+    WRITE_UINT32(p_Regs->fmbm_rpc, 0); /* counters disabled, need parameters for enabling */
+
+    /* error/status mask  - check that if discard OV is set, no
+       discard is required for specific errors.*/
+    WRITE_UINT32(p_Regs->fmbm_rfsdm, p_Params->errorsToDiscard);
+
+    errorsToEnq = (RX_ERRS_TO_ENQ & ~p_Params->errorsToDiscard);
+    WRITE_UINT32(p_Regs->fmbm_rfsem, errorsToEnq);
+
+    return E_OK;
+}
+
+static t_Error BmiTxPortInit(t_FmPort *p_FmPort)
+{
+    t_FmPortTxBmiRegs   *p_Regs = &p_FmPort->p_FmPortBmiRegs->txPortBmiRegs;
+    uint32_t            tmpReg, prevPowerOf2, count=0, tmpRateLimitScale;
+    t_FmPortDriverParam *p_Params = p_FmPort->p_FmPortDriverParam;
+    uint32_t            rateCountUnit, roundUp;
+
+    /* check that port is not busy */
+    if (GET_UINT32(p_Regs->fmbm_tcfg) & BMI_PORT_CFG_EN)
+         RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Port is already enabled"));
+
+    tmpReg = 0;
+    if (p_FmPort->imEn)
+        tmpReg |= BMI_PORT_CFG_IM;
+
+    WRITE_UINT32(p_Regs->fmbm_tcfg, tmpReg);
+
+    /* Configure dma attributes */
+    tmpReg = 0;
+    tmpReg |= p_Params->dmaSwapData << BMI_DMA_ATTR_SWP_SHIFT;
+    tmpReg |= p_Params->dmaIntContextCacheAttr << BMI_DMA_ATTR_IC_CACHE_SHIFT;
+    tmpReg |= p_Params->dmaHeaderCacheAttr << BMI_DMA_ATTR_HDR_CACHE_SHIFT;
+    tmpReg |= p_Params->dmaScatterGatherCacheAttr << BMI_DMA_ATTR_SG_CACHE_SHIFT;
+    if(p_Params->dmaReadOptimize)
+        tmpReg |= BMI_DMA_ATTR_READ_OPTIMIZE;
+    if(p_Params->dmaWriteOptimize)
+        tmpReg |= BMI_DMA_ATTR_WRITE_OPTIMIZE;
+
+    WRITE_UINT32(p_Regs->fmbm_tda, tmpReg);
+
+    /* Configure Tx Fifo params */
+    tmpReg = 0;
+    tmpReg |= ((p_Params->txFifoMinFillLevel/BMI_FIFO_UNITS) << BMI_TX_FIFO_MIN_FILL_SHIFT);
+    tmpReg |= ((p_FmPort->txFifoDeqPipelineDepth - 1) << BMI_TX_FIFO_PIPELINE_DEPTH_SHIFT);
+    tmpReg |= ((p_Params->txFifoLowComfLevel/BMI_FIFO_UNITS - 1) << BMI_TX_LOW_COMF_SHIFT);
+
+    WRITE_UINT32(p_Regs->fmbm_tfp, tmpReg);
+
+    /* frame end parameters */
+    tmpReg = 0;
+    tmpReg |= (p_Params->cheksumLastBytesIgnore << BMI_TX_FRAME_END_CS_IGNORE_SHIFT);
+
+    WRITE_UINT32(p_Regs->fmbm_tfed, tmpReg);
+
+    if (!p_FmPort->imEn)
+    {
+        /* IC parameters */
+        tmpReg = 0;
+        tmpReg |= ((p_Params->intContext.extBufOffset/OFFSET_UNITS) << BMI_IC_TO_EXT_SHIFT);
+        tmpReg |= ((p_Params->intContext.intContextOffset/OFFSET_UNITS) << BMI_IC_FROM_INT_SHIFT);
+        tmpReg |= ((p_Params->intContext.size/OFFSET_UNITS)  << BMI_IC_SIZE_SHIFT);
+
+        WRITE_UINT32(p_Regs->fmbm_ticp, tmpReg);
+    }
+
+    /* NIA */
+    if (p_FmPort->imEn)
+    {
+        WRITE_UINT32(p_Regs->fmbm_tfne, NIA_ENG_FM_CTL | NIA_FM_CTL_AC_IND_MODE_TX);
+        WRITE_UINT32(p_Regs->fmbm_tfene, NIA_ENG_FM_CTL | NIA_FM_CTL_AC_IND_MODE_TX);
+    }
+    else
+    {
+        WRITE_UINT32(p_Regs->fmbm_tfne, NIA_ENG_QMI_DEQ);
+        WRITE_UINT32(p_Regs->fmbm_tfene, NIA_ENG_QMI_ENQ | NIA_ORDER_RESTOR);
+    }
+
+    /* command attribute */
+    tmpReg = BMI_CMD_TX_MR_DEF;
+    if (p_FmPort->imEn)
+        tmpReg |= BMI_CMD_MR_DEAS;
+    else
+    {
+        tmpReg |= BMI_CMD_ATTR_ORDER;
+        if(p_Params->syncReq)
+            tmpReg |= BMI_CMD_ATTR_SYNC;
+        tmpReg |= (p_Params->color << BMI_CMD_ATTR_COLOR_SHIFT);
+    }
+
+    WRITE_UINT32(p_Regs->fmbm_tfca, tmpReg);
+
+    /* default queues */
+    if (!p_FmPort->imEn)
+    {
+        WRITE_UINT32(p_Regs->fmbm_tcfqid, p_Params->dfltFqid);
+        WRITE_UINT32(p_Regs->fmbm_tfeqid, p_Params->errFqid);
+    }
+
+    /* rate limit */
+    if(p_Params->enRateLimit)
+    {
+        if (!p_Params->timeStampPeriod)
+            RETURN_ERROR(MAJOR, E_NOT_AVAILABLE, ("Rate limit requires timeStamp - not enabled."));
+
+        if(p_Params->rateLimit.rateLimit < 16*p_Params->timeStampPeriod)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("rateLimit is too small, must be larger than 16*timeStampPeriod as initialized in main FM module"));
+
+        /* we want to use the largest possible trlmt[RLM]. So we want
+        the minimal rate count unit (as we write in trlmts[TSBS]).
+        rateCountUnit must be large enough to allow using the maximum
+        trlmt[RLM] (1023 representing 1024 * 16).
+        We want to round up this division */
+
+        if (p_Params->rateLimit.rateLimit % (1024*16))
+            roundUp = 1;
+        else
+            roundUp = 0;
+        rateCountUnit = p_Params->rateLimit.rateLimit/(1024*16) + roundUp;
+        /* The basic unit may not be smaller than the timeStamp. */
+        if (rateCountUnit<p_Params->timeStampPeriod)
+            rateCountUnit = p_Params->timeStampPeriod;
+
+        /* we need to find the bit of timeStamp that is closest to rateCountUnit */
+        /* we find the previous power of 2, and the next one, than we see which is closer */
+        while(rateCountUnit > p_Params->timeStampPeriod*(1<<count))
+            count++;
+        if(count == 0)
+            tmpRateLimitScale = (31 - count) << BMI_COUNT_RATE_UNIT_SHIFT;
+        else
+        {
+            prevPowerOf2 = (1<<(count-1))*p_Params->timeStampPeriod;
+            /* 'count' or 'count-1' is now the bit that represents the unit */
+            if((rateCountUnit - prevPowerOf2) < (2*prevPowerOf2 - rateCountUnit))
+            {
+                tmpRateLimitScale = (31 - (count-1)) << BMI_COUNT_RATE_UNIT_SHIFT;
+                /* in order to get precision in the following calculation,
+                we now use the closest available rateCountUnit */
+                rateCountUnit = prevPowerOf2;
+            }
+            else
+            {
+                tmpRateLimitScale = (31 - count) << BMI_COUNT_RATE_UNIT_SHIFT;
+                /* in order to get precision in the following calculation,
+                we now use the closest available rateCountUnit */
+                rateCountUnit = 2*prevPowerOf2;
+            }
+        }
+
+        tmpReg = (uint32_t)(p_Params->rateLimit.rateLimit/(16* rateCountUnit) - 1);
+        if(!p_Params->rateLimit.maxBurstSize || (p_Params->rateLimit.maxBurstSize > MAX_BURST_SIZE))
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("maxBurstSize must be between 1K and %dk", MAX_BURST_SIZE));
+
+        tmpReg |= (uint32_t)(p_Params->rateLimit.maxBurstSize - 1) << BMI_MAX_BURST_SHIFT;
+        WRITE_UINT32(p_Regs->fmbm_trlmt, tmpReg);
+
+        tmpRateLimitScale |= BMI_RATE_LIMIT_EN;
+        WRITE_UINT32(p_Regs->fmbm_trlmts, tmpRateLimitScale);
+    }
+
+    /* statistics & performance counters */
+    WRITE_UINT32(p_Regs->fmbm_tstc, BMI_COUNTERS_EN);
+    WRITE_UINT32(p_Regs->fmbm_tpc, 0); /* counters disabled, need parameters for enabling */
+
+    return E_OK;
+}
+
+static t_Error BmiOhPortInit(t_FmPort *p_FmPort)
+{
+    t_FmPortOhBmiRegs   *p_Regs = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs;
+    uint32_t            tmpReg, prevPowerOf2, count=0, tmpRateLimitScale, errorsToEnq = 0;
+    t_FmPortDriverParam *p_Params = p_FmPort->p_FmPortDriverParam;
+    uint32_t            rateCountUnit, roundUp;
+
+    /* check that port is not busy */
+    if (GET_UINT32(p_Regs->fmbm_ocfg) & BMI_PORT_CFG_EN)
+         RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Port is already enabled"));
+
+    /* Configure dma attributes */
+    tmpReg = 0;
+    tmpReg |= p_Params->dmaSwapData << BMI_DMA_ATTR_SWP_SHIFT;
+    tmpReg |= p_Params->dmaIntContextCacheAttr << BMI_DMA_ATTR_IC_CACHE_SHIFT;
+    tmpReg |= p_Params->dmaHeaderCacheAttr << BMI_DMA_ATTR_HDR_CACHE_SHIFT;
+    tmpReg |= p_Params->dmaScatterGatherCacheAttr << BMI_DMA_ATTR_SG_CACHE_SHIFT;
+    if(p_Params->dmaReadOptimize)
+        tmpReg |= BMI_DMA_ATTR_READ_OPTIMIZE;
+    if(p_Params->dmaWriteOptimize)
+        tmpReg |= BMI_DMA_ATTR_WRITE_OPTIMIZE;
+
+    WRITE_UINT32(p_Regs->fmbm_oda, tmpReg);
+
+    /* IC parameters */
+    tmpReg = 0;
+    tmpReg |= ((p_Params->intContext.extBufOffset/OFFSET_UNITS) << BMI_IC_TO_EXT_SHIFT);
+    tmpReg |= ((p_Params->intContext.intContextOffset/OFFSET_UNITS) << BMI_IC_FROM_INT_SHIFT);
+    tmpReg |= ((p_Params->intContext.size/OFFSET_UNITS)  << BMI_IC_SIZE_SHIFT);
+
+    WRITE_UINT32(p_Regs->fmbm_oicp, tmpReg);
+
+    /* NIA */
+    WRITE_UINT32(p_Regs->fmbm_ofdne, NIA_ENG_QMI_DEQ);
+
+    if (p_FmPort->portType==e_FM_PORT_TYPE_HOST_COMMAND)
+        WRITE_UINT32(p_Regs->fmbm_ofene, NIA_ENG_QMI_ENQ);
+    else
+        WRITE_UINT32(p_Regs->fmbm_ofene, NIA_ENG_QMI_ENQ | NIA_ORDER_RESTOR);
+
+    /* command attribute */
+    if (p_FmPort->portType==e_FM_PORT_TYPE_HOST_COMMAND)
+        tmpReg =  BMI_CMD_MR_DEAS | BMI_CMD_MR_MA;
+    else
+        tmpReg = BMI_CMD_ATTR_ORDER | BMI_CMD_MR_DEAS | BMI_CMD_MR_MA;
+
+    if(p_Params->syncReq)
+        tmpReg |= BMI_CMD_ATTR_SYNC;
+    tmpReg |= (p_Params->color << BMI_CMD_ATTR_COLOR_SHIFT);
+    WRITE_UINT32(p_Regs->fmbm_ofca, tmpReg);
+
+    /* No discard - all error frames go to error queue */
+    if (p_Params->frmDiscardOverride)
+        tmpReg = BMI_PORT_CFG_FDOVR;
+    else
+        tmpReg = 0;
+    WRITE_UINT32(p_Regs->fmbm_ocfg, tmpReg);
+
+    if(p_FmPort->portType == e_FM_PORT_TYPE_OFFLINE_PARSING)
+    {
+        WRITE_UINT32(p_Regs->fmbm_ofsdm, p_Params->errorsToDiscard);
+
+        errorsToEnq = (OP_ERRS_TO_ENQ & ~p_Params->errorsToDiscard);
+        WRITE_UINT32(p_Regs->fmbm_ofsem, errorsToEnq);
+
+        /* NIA */
+        WRITE_UINT32(p_Regs->fmbm_ofne, NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME);
+
+        /* rate limit */
+        if(p_Params->enRateLimit)
+        {
+            if (!p_Params->timeStampPeriod)
+                RETURN_ERROR(MAJOR, E_NOT_AVAILABLE, ("Rate limit requires timeStamp - not enabled."));
+
+            if(p_Params->rateLimit.rateLimit < 10*p_Params->timeStampPeriod)
+                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("rateLimit is too small, must be larger than 10*timeStampPeriod as initialized in main FM module"));
+
+            /* we want to use the largest possible trlmt[RLM]. So we want
+            the minimal rate count unit (as we write in orlmts[TSBS]).
+            rateCountUnit must be large enough to allow using the maximum
+            orlmt[RLM] (1023 representing 1024 * 10).
+            We want to round up this division */
+
+            if (p_Params->rateLimit.rateLimit % (1024*10))
+                roundUp = 1;
+            else
+                roundUp = 0;
+            rateCountUnit = p_Params->rateLimit.rateLimit/(1024*10) + roundUp;
+            /* The basic unit may not be smaller than the timeStamp. */
+            if (rateCountUnit<p_Params->timeStampPeriod)
+                rateCountUnit = p_Params->timeStampPeriod;
+
+            /* we need to find the bit of timeStamp that is closest to rateCountUnit */
+            /* we find the previous power of 2, and the next one, than we see which is closer */
+            while(rateCountUnit > p_Params->timeStampPeriod*(1<<count))
+                count++;
+            if(count == 0)
+                tmpRateLimitScale = (31 - count) << BMI_COUNT_RATE_UNIT_SHIFT;
+            else
+            {
+                prevPowerOf2 = (1<<(count-1))*p_Params->timeStampPeriod;
+                /* 'count' or 'count-1' is now the bit that represents the unit */
+                if((rateCountUnit - prevPowerOf2) < (2*prevPowerOf2 - rateCountUnit))
+                {
+                    tmpRateLimitScale = (31 - (count-1)) << BMI_COUNT_RATE_UNIT_SHIFT;
+                    /* in order to get precision in the following calculation,
+                    we now use the closest available rateCountUnit */
+                    rateCountUnit = prevPowerOf2;
+                }
+                else
+                {
+                    tmpRateLimitScale = (31 - count) << BMI_COUNT_RATE_UNIT_SHIFT;
+                    /* in order to get precision in the following calculation,
+                    we now use the closest available rateCountUnit */
+                    rateCountUnit = 2*prevPowerOf2;
+                }
+            }
+
+            tmpReg = (uint32_t)(p_Params->rateLimit.rateLimit/(10* rateCountUnit) - 1);
+            tmpReg |= (uint32_t)(p_Params->rateLimit.maxBurstSize - 1) << BMI_MAX_BURST_SHIFT;
+            WRITE_UINT32(p_Regs->fmbm_orlmt, tmpReg);
+
+            tmpRateLimitScale |= BMI_RATE_LIMIT_EN;
+            WRITE_UINT32(p_Regs->fmbm_orlmts, tmpRateLimitScale);
+        }
+    }
+    else
+        /* NIA */
+        WRITE_UINT32(p_Regs->fmbm_ofne, NIA_ENG_FM_CTL | NIA_FM_CTL_AC_HC);
+
+    /* default queues */
+    WRITE_UINT32(p_Regs->fmbm_ofqid, p_Params->dfltFqid);
+    WRITE_UINT32(p_Regs->fmbm_oefqid, p_Params->errFqid);
+
+    /* statistics & performance counters */
+    WRITE_UINT32(p_Regs->fmbm_ostc, BMI_COUNTERS_EN);
+    WRITE_UINT32(p_Regs->fmbm_opc, 0); /* counters disabled, need parameters for enabling */
+
+    return E_OK;
+}
+
+static t_Error QmiInit(t_FmPort *p_FmPort)
+{
+    t_FmPortDriverParam             *p_Params = NULL;
+    uint32_t                        tmpReg;
+
+    p_Params = p_FmPort->p_FmPortDriverParam;
+
+    /* check that port is not busy */
+    if(((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) &&
+        (p_FmPort->portType != e_FM_PORT_TYPE_RX)) &&
+       (GET_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnc) & QMI_PORT_CFG_EN))
+         RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Port is already enabled"));
+
+    /* enable & clear counters */
+    WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnc, QMI_PORT_CFG_EN_COUNTERS);
+
+    /* The following is  done for non-Rx ports only */
+    if((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) &&
+        (p_FmPort->portType != e_FM_PORT_TYPE_RX))
+    {
+        if((p_FmPort->portType == e_FM_PORT_TYPE_TX_10G) ||
+                        (p_FmPort->portType == e_FM_PORT_TYPE_TX))
+        {
+            /* define dequeue NIA */
+            WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs.fmqm_pndn, NIA_ENG_BMI | NIA_BMI_AC_TX);
+            /* define enqueue NIA */
+            WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnen, NIA_ENG_BMI | NIA_BMI_AC_TX_RELEASE);
+        }
+        else  /* for HC & OP */
+        {
+            WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs.fmqm_pndn, NIA_ENG_BMI | NIA_BMI_AC_FETCH);
+            /* define enqueue NIA */
+            WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnen, NIA_ENG_BMI | NIA_BMI_AC_RELEASE);
+        }
+
+        /* configure dequeue */
+        tmpReg = 0;
+        if(p_Params->deqHighPriority)
+            tmpReg |= QMI_DEQ_CFG_PRI;
+
+        switch(p_Params->deqType)
+        {
+            case(e_FM_PORT_DEQ_TYPE1):
+                tmpReg |= QMI_DEQ_CFG_TYPE1;
+                break;
+            case(e_FM_PORT_DEQ_TYPE2):
+                tmpReg |= QMI_DEQ_CFG_TYPE2;
+                break;
+            case(e_FM_PORT_DEQ_TYPE3):
+                tmpReg |= QMI_DEQ_CFG_TYPE3;
+                break;
+            default:
+                break;
+        }
+        switch(p_Params->deqPrefetchOption)
+        {
+            case(e_FM_PORT_DEQ_NO_PREFETCH):
+                /* Do nothing - QMI_DEQ_CFG_PREFETCH_WAITING_TNUM | QMI_DEQ_CFG_PREFETCH_1_FRAME = 0 */
+                break;
+            case(e_FM_PORT_DEQ_PARTIAL_PREFETCH):
+                tmpReg |= QMI_DEQ_CFG_PREFETCH_WAITING_TNUM | QMI_DEQ_CFG_PREFETCH_3_FRAMES;
+                break;
+            case(e_FM_PORT_DEQ_FULL_PREFETCH):
+                tmpReg |= QMI_DEQ_CFG_PREFETCH_NO_TNUM | QMI_DEQ_CFG_PREFETCH_3_FRAMES;
+                break;
+            default:
+                break;
+        }
+        tmpReg |= p_Params->deqByteCnt;
+        tmpReg |= p_Params->deqSubPortal << QMI_DEQ_CFG_SUBPORTAL_SHIFT;
+
+        WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs.fmqm_pndc, tmpReg);
+    }
+    else /* rx port */
+        /* define enqueue NIA */
+        WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnen, NIA_ENG_BMI | NIA_BMI_AC_RELEASE);
+
+    return E_OK;
+}
+
+static t_Error BmiRxPortCheckAndGetCounterPtr(t_FmPort *p_FmPort, e_FmPortCounters counter, volatile uint32_t **p_Ptr)
+{
+    t_FmPortRxBmiRegs   *p_BmiRegs = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs;
+
+     /* check that counters are enabled */
+    switch(counter)
+    {
+        case(e_FM_PORT_COUNTERS_CYCLE):
+        case(e_FM_PORT_COUNTERS_TASK_UTIL):
+        case(e_FM_PORT_COUNTERS_QUEUE_UTIL):
+        case(e_FM_PORT_COUNTERS_DMA_UTIL):
+        case(e_FM_PORT_COUNTERS_FIFO_UTIL):
+        case(e_FM_PORT_COUNTERS_RX_PAUSE_ACTIVATION):
+            if(!(GET_UINT32(p_BmiRegs->fmbm_rpc) & BMI_COUNTERS_EN))
+               RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter was not enabled"));
+            break;
+        case(e_FM_PORT_COUNTERS_FRAME):
+        case(e_FM_PORT_COUNTERS_DISCARD_FRAME):
+        case(e_FM_PORT_COUNTERS_RX_BAD_FRAME):
+        case(e_FM_PORT_COUNTERS_RX_LARGE_FRAME):
+        case(e_FM_PORT_COUNTERS_RX_FILTER_FRAME):
+        case(e_FM_PORT_COUNTERS_RX_LIST_DMA_ERR):
+        case(e_FM_PORT_COUNTERS_RX_OUT_OF_BUFFERS_DISCARD):
+        case(e_FM_PORT_COUNTERS_DEALLOC_BUF):
+            if(!(GET_UINT32(p_BmiRegs->fmbm_rstc) & BMI_COUNTERS_EN))
+               RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter was not enabled"));
+            break;
+         default:
+            RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter is not available for Rx ports"));
+            break;
+    }
+
+    /* Set counter */
+    switch(counter)
+    {
+        case(e_FM_PORT_COUNTERS_CYCLE):
+            *p_Ptr = &p_BmiRegs->fmbm_rccn;
+            break;
+        case(e_FM_PORT_COUNTERS_TASK_UTIL):
+            *p_Ptr = &p_BmiRegs->fmbm_rtuc;
+            break;
+        case(e_FM_PORT_COUNTERS_QUEUE_UTIL):
+            *p_Ptr = &p_BmiRegs->fmbm_rrquc;
+            break;
+        case(e_FM_PORT_COUNTERS_DMA_UTIL):
+            *p_Ptr = &p_BmiRegs->fmbm_rduc;
+            break;
+        case(e_FM_PORT_COUNTERS_FIFO_UTIL):
+            *p_Ptr = &p_BmiRegs->fmbm_rfuc;
+            break;
+        case(e_FM_PORT_COUNTERS_RX_PAUSE_ACTIVATION):
+            *p_Ptr = &p_BmiRegs->fmbm_rpac;
+            break;
+        case(e_FM_PORT_COUNTERS_FRAME):
+            *p_Ptr = &p_BmiRegs->fmbm_rfrc;
+            break;
+        case(e_FM_PORT_COUNTERS_DISCARD_FRAME):
+            *p_Ptr = &p_BmiRegs->fmbm_rfcd;
+            break;
+        case(e_FM_PORT_COUNTERS_RX_BAD_FRAME):
+            *p_Ptr = &p_BmiRegs->fmbm_rfbc;
+            break;
+        case(e_FM_PORT_COUNTERS_RX_LARGE_FRAME):
+            *p_Ptr = &p_BmiRegs->fmbm_rlfc;
+            break;
+        case(e_FM_PORT_COUNTERS_RX_FILTER_FRAME):
+            *p_Ptr = &p_BmiRegs->fmbm_rffc;
+            break;
+        case(e_FM_PORT_COUNTERS_RX_LIST_DMA_ERR):
+            *p_Ptr = &p_BmiRegs->fmbm_rfldec;
+            break;
+        case(e_FM_PORT_COUNTERS_RX_OUT_OF_BUFFERS_DISCARD):
+            *p_Ptr = &p_BmiRegs->fmbm_rodc;
+        case(e_FM_PORT_COUNTERS_DEALLOC_BUF):
+            *p_Ptr = &p_BmiRegs->fmbm_rbdc;
+        default:
+            RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter is not available for Rx ports"));
+            break;
+    }
+
+    return E_OK;
+}
+
+static t_Error BmiTxPortCheckAndGetCounterPtr(t_FmPort *p_FmPort, e_FmPortCounters counter, volatile uint32_t **p_Ptr)
+{
+    t_FmPortTxBmiRegs   *p_BmiRegs = &p_FmPort->p_FmPortBmiRegs->txPortBmiRegs;
+
+     /* check that counters are enabled */
+    switch(counter)
+    {
+        case(e_FM_PORT_COUNTERS_CYCLE):
+        case(e_FM_PORT_COUNTERS_TASK_UTIL):
+        case(e_FM_PORT_COUNTERS_QUEUE_UTIL):
+        case(e_FM_PORT_COUNTERS_DMA_UTIL):
+        case(e_FM_PORT_COUNTERS_FIFO_UTIL):
+            if(!(GET_UINT32(p_BmiRegs->fmbm_tpc) & BMI_COUNTERS_EN))
+               RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter was not enabled"));
+            break;
+        case(e_FM_PORT_COUNTERS_FRAME):
+        case(e_FM_PORT_COUNTERS_DISCARD_FRAME):
+        case(e_FM_PORT_COUNTERS_LENGTH_ERR):
+        case(e_FM_PORT_COUNTERS_UNSUPPRTED_FORMAT):
+        case(e_FM_PORT_COUNTERS_DEALLOC_BUF):
+            if(!(GET_UINT32(p_BmiRegs->fmbm_tstc) & BMI_COUNTERS_EN))
+               RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter was not enabled"));
+            break;
+        default:
+            RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter is not available for Tx ports"));
+            break;
+    }
+
+    /* Set counter */
+    switch(counter)
+    {
+        case(e_FM_PORT_COUNTERS_CYCLE):
+           *p_Ptr = &p_BmiRegs->fmbm_tccn;
+            break;
+        case(e_FM_PORT_COUNTERS_TASK_UTIL):
+           *p_Ptr = &p_BmiRegs->fmbm_ttuc;
+            break;
+        case(e_FM_PORT_COUNTERS_QUEUE_UTIL):
+            *p_Ptr = &p_BmiRegs->fmbm_ttcquc;
+            break;
+        case(e_FM_PORT_COUNTERS_DMA_UTIL):
+           *p_Ptr = &p_BmiRegs->fmbm_tduc;
+            break;
+        case(e_FM_PORT_COUNTERS_FIFO_UTIL):
+           *p_Ptr = &p_BmiRegs->fmbm_tfuc;
+            break;
+        case(e_FM_PORT_COUNTERS_FRAME):
+           *p_Ptr = &p_BmiRegs->fmbm_tfrc;
+            break;
+        case(e_FM_PORT_COUNTERS_DISCARD_FRAME):
+           *p_Ptr = &p_BmiRegs->fmbm_tfdc;
+            break;
+        case(e_FM_PORT_COUNTERS_LENGTH_ERR):
+           *p_Ptr = &p_BmiRegs->fmbm_tfledc;
+            break;
+        case(e_FM_PORT_COUNTERS_UNSUPPRTED_FORMAT):
+            *p_Ptr = &p_BmiRegs->fmbm_tfufdc;
+            break;
+        case(e_FM_PORT_COUNTERS_DEALLOC_BUF):
+            *p_Ptr = &p_BmiRegs->fmbm_tbdc;
+        default:
+            RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter is not available for Tx ports"));
+            break;
+    }
+
+    return E_OK;
+}
+
+
+static t_Error BmiOhPortCheckAndGetCounterPtr(t_FmPort *p_FmPort, e_FmPortCounters counter, volatile uint32_t **p_Ptr)
+{
+    t_FmPortOhBmiRegs   *p_BmiRegs = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs;
+
+    /* check that counters are enabled */
+    switch(counter)
+    {
+        case(e_FM_PORT_COUNTERS_CYCLE):
+        case(e_FM_PORT_COUNTERS_TASK_UTIL):
+        case(e_FM_PORT_COUNTERS_DMA_UTIL):
+        case(e_FM_PORT_COUNTERS_FIFO_UTIL):
+            if(!(GET_UINT32(p_BmiRegs->fmbm_opc) & BMI_COUNTERS_EN))
+               RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter was not enabled"));
+            break;
+        case(e_FM_PORT_COUNTERS_FRAME):
+        case(e_FM_PORT_COUNTERS_DISCARD_FRAME):
+        case(e_FM_PORT_COUNTERS_RX_LIST_DMA_ERR):
+        case(e_FM_PORT_COUNTERS_WRED_DISCARD):
+        case(e_FM_PORT_COUNTERS_LENGTH_ERR):
+        case(e_FM_PORT_COUNTERS_UNSUPPRTED_FORMAT):
+        case(e_FM_PORT_COUNTERS_DEALLOC_BUF):
+            if(!(GET_UINT32(p_BmiRegs->fmbm_ostc) & BMI_COUNTERS_EN))
+               RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter was not enabled"));
+            break;
+        case(e_FM_PORT_COUNTERS_RX_FILTER_FRAME): /* only valid for offline parsing */
+            if(p_FmPort->portType == e_FM_PORT_TYPE_HOST_COMMAND)
+                RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter is not available for O/H ports"));
+            if(!(GET_UINT32(p_BmiRegs->fmbm_ostc) & BMI_COUNTERS_EN))
+               RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter was not enabled"));
+            break;
+        default:
+            RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter is not available for O/H ports"));
+            break;
+    }
+
+    /* Set counter */
+    switch(counter)
+    {
+        case(e_FM_PORT_COUNTERS_CYCLE):
+           *p_Ptr = &p_BmiRegs->fmbm_occn;
+            break;
+        case(e_FM_PORT_COUNTERS_TASK_UTIL):
+           *p_Ptr = &p_BmiRegs->fmbm_otuc;
+            break;
+        case(e_FM_PORT_COUNTERS_DMA_UTIL):
+           *p_Ptr = &p_BmiRegs->fmbm_oduc;
+            break;
+        case(e_FM_PORT_COUNTERS_FIFO_UTIL):
+           *p_Ptr = &p_BmiRegs->fmbm_ofuc;
+            break;
+        case(e_FM_PORT_COUNTERS_FRAME):
+           *p_Ptr = &p_BmiRegs->fmbm_ofrc;
+            break;
+        case(e_FM_PORT_COUNTERS_DISCARD_FRAME):
+           *p_Ptr = &p_BmiRegs->fmbm_ofdc;
+            break;
+        case(e_FM_PORT_COUNTERS_RX_FILTER_FRAME):
+           *p_Ptr = &p_BmiRegs->fmbm_offc;
+            break;
+        case(e_FM_PORT_COUNTERS_RX_LIST_DMA_ERR):
+           *p_Ptr = &p_BmiRegs->fmbm_ofldec;
+            break;
+        case(e_FM_PORT_COUNTERS_WRED_DISCARD):
+           *p_Ptr = &p_BmiRegs->fmbm_ofwdc;
+            break;
+        case(e_FM_PORT_COUNTERS_LENGTH_ERR):
+           *p_Ptr = &p_BmiRegs->fmbm_ofledc;
+            break;
+        case(e_FM_PORT_COUNTERS_UNSUPPRTED_FORMAT):
+            *p_Ptr = &p_BmiRegs->fmbm_ofufdc;
+            break;
+        case(e_FM_PORT_COUNTERS_DEALLOC_BUF):
+            *p_Ptr = &p_BmiRegs->fmbm_obdc;
+        default:
+            RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter is not available for O/H ports"));
+            break;
+    }
+
+    return E_OK;
+}
+
+static t_Error  AdditionalPrsParams(t_FmPort *p_FmPort, t_FmPcdPrsAdditionalHdrParams *p_HdrParams, uint32_t *p_SoftSeqAttachReg)
+{
+    uint8_t                     hdrNum, Ipv4HdrNum;
+    u_FmPcdHdrPrsOpts            *p_prsOpts;
+    uint32_t                    tmpReg = 0, tmpPrsOffset;
+
+    if(p_HdrParams->errDisable)
+        tmpReg |= PRS_HDR_ERROR_DIS;
+
+    /* Set parser options */
+    if(p_HdrParams->usePrsOpts)
+    {
+        p_prsOpts = &p_HdrParams->prsOpts;
+        switch(p_HdrParams->hdr)
+        {
+            case(HEADER_TYPE_MPLS):
+                if(p_prsOpts->mplsPrsOptions.labelInterpretationEnable)
+                    tmpReg |= PRS_HDR_MPLS_LBL_INTER_EN;
+                GET_PRS_HDR_NUM(hdrNum, p_prsOpts->mplsPrsOptions.nextParse);
+                if(hdrNum == ILLEGAL_HDR_NUM)
+                    RETURN_ERROR(MAJOR, E_INVALID_VALUE, NO_MSG);
+                GET_PRS_HDR_NUM(Ipv4HdrNum, HEADER_TYPE_IPv4);
+                if(hdrNum < Ipv4HdrNum)
+                    RETURN_ERROR(MAJOR, E_INVALID_VALUE,
+                        ("Header must be equal or higher than IPv4"));
+                tmpReg |= (hdrNum * PRS_HDR_ENTRY_SIZE) << PRS_HDR_MPLS_NEXT_HDR_SHIFT;
+                break;
+            case(HEADER_TYPE_IPv6):
+                if(p_prsOpts->ipv6PrsOptions.routingHdrDisable)
+                    tmpReg |= PRS_HDR_IPV6_ROUTE_HDR_DIS;
+                break;
+            case(HEADER_TYPE_TCP):
+                if(p_prsOpts->tcpPrsOptions.padIgnoreChecksum)
+                   tmpReg |= PRS_HDR_TCP_PAD_REMOVAL;
+                break;
+            case(HEADER_TYPE_UDP):
+                if(p_prsOpts->udpPrsOptions.padIgnoreChecksum)
+                   tmpReg |= PRS_HDR_TCP_PAD_REMOVAL;
+            default:
+                break;
+        }
+    }
+
+    /* set software parsing (address is devided in 2 since parser uses 2 byte access. */
+    if(p_HdrParams->swPrsEnable)
+    {
+        tmpPrsOffset = FmPcdGetSwPrsOffset(p_FmPort->h_FmPcd, p_HdrParams->hdr, p_HdrParams->indexPerHdr);
+        if(tmpPrsOffset == ILLEGAL_BASE)
+            RETURN_ERROR(MINOR, E_INVALID_VALUE, NO_MSG);
+        tmpReg |= (PRS_HDR_SW_PRS_EN | tmpPrsOffset);
+    }
+    *p_SoftSeqAttachReg = tmpReg;
+
+    return E_OK;
+}
+
+static uint32_t GetPortSchemeBindParams(t_Handle h_FmPort, t_FmPcdKgInterModuleBindPortToSchemes *p_SchemeBind)
+{
+    t_FmPort                    *p_FmPort = (t_FmPort*)h_FmPort;
+    uint32_t                    walking1Mask = 0x80000000, tmp;
+    uint8_t                     idx = 0;
+
+    p_SchemeBind->netEnvId = p_FmPort->netEnvId;
+    p_SchemeBind->hardwarePortId = p_FmPort->hardwarePortId;
+    p_SchemeBind->useClsPlan = p_FmPort->useClsPlan;
+    p_SchemeBind->numOfSchemes = 0;
+    tmp = p_FmPort->schemesPerPortVector;
+    if(tmp)
+    {
+        while (tmp)
+        {
+            if(tmp & walking1Mask)
+            {
+                p_SchemeBind->schemesIds[p_SchemeBind->numOfSchemes] = FmPcdKgGetSchemeSwId(p_FmPort->h_FmPcd, idx);
+                p_SchemeBind->numOfSchemes++;
+                tmp &= ~walking1Mask;
+            }
+            walking1Mask >>= 1;
+            idx++;
+        }
+    }
+
+    return tmp;
+}
+
+
+/********************************************/
+/*  Inter-module API                        */
+/********************************************/
+t_Error FmPortSetPcd(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParams)
+{
+    t_FmPort                            *p_FmPort = (t_FmPort*)h_FmPort;
+    t_Error                             err = E_OK;
+    uint32_t                            tmpReg;
+    volatile uint32_t                   *p_BmiNia=NULL;
+    volatile uint32_t                   *p_BmiPrsNia=NULL;
+    volatile uint32_t                   *p_BmiPrsStartOffset=NULL;
+    volatile uint32_t                   *p_BmiInitPrsResult=NULL;
+    volatile uint32_t                   *p_BmiCcBase=NULL;
+    uint8_t                             hdrNum, L3HdrNum;
+    int                                 i;
+    uint32_t                            tmpHxs[FM_PCD_PRS_NUM_OF_HDRS];
+    uint16_t                            absoluteProfileId;
+    uint8_t                             physicalSchemeId;
+    uint32_t                            ccTreePhysOffset;
+
+    SANITY_CHECK_RETURN_ERROR(h_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
+
+    if (p_FmPort->imEn)
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for non-independant mode ports only"));
+
+    if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) &&
+        (p_FmPort->portType != e_FM_PORT_TYPE_RX) &&
+        (p_FmPort->portType != e_FM_PORT_TYPE_OFFLINE_PARSING))
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx and offline parsing ports only"));
+
+    p_FmPort->netEnvId = (uint8_t)(CAST_POINTER_TO_UINT32(p_PcdParams->h_NetEnv)-1);
+
+    p_FmPort->pcdEngines = 0;
+
+    /* initialize p_FmPort->pcdEngines field in port's structure */
+    switch(p_PcdParams->pcdSupport)
+    {
+        case(e_FM_PORT_PCD_SUPPORT_NONE):
+            REPORT_ERROR(MAJOR, E_INVALID_STATE, ("No PCD configuration required if e_FM_PORT_PCD_SUPPORT_NONE selected"));
+            break;
+        case(e_FM_PORT_PCD_SUPPORT_PRS_ONLY):
+            p_FmPort->pcdEngines |= FM_PCD_PRS;
+            break;
+        case(e_FM_PORT_PCD_SUPPORT_PLCR_ONLY):
+            p_FmPort->pcdEngines |= FM_PCD_PLCR;
+            break;
+        case(e_FM_PORT_PCD_SUPPORT_PRS_AND_PLCR):
+            p_FmPort->pcdEngines |= FM_PCD_PRS;
+            p_FmPort->pcdEngines |= FM_PCD_PLCR;
+            break;
+        case(e_FM_PORT_PCD_SUPPORT_PRS_AND_KG):
+            p_FmPort->pcdEngines |= FM_PCD_PRS;
+            p_FmPort->pcdEngines |= FM_PCD_KG;
+            break;
+        case(e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC):
+            p_FmPort->pcdEngines |= FM_PCD_PRS;
+            p_FmPort->pcdEngines |= FM_PCD_CC;
+            p_FmPort->pcdEngines |= FM_PCD_KG;
+            break;
+        case(e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC_AND_PLCR):
+            p_FmPort->pcdEngines |= FM_PCD_PRS;
+            p_FmPort->pcdEngines |= FM_PCD_KG;
+            p_FmPort->pcdEngines |= FM_PCD_CC;
+            p_FmPort->pcdEngines |= FM_PCD_PLCR;
+            break;
+        case(e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_PLCR):
+            p_FmPort->pcdEngines |= FM_PCD_PRS;
+            p_FmPort->pcdEngines |= FM_PCD_KG;
+            p_FmPort->pcdEngines |= FM_PCD_PLCR;
+            break;
+        default:
+            REPORT_ERROR(MAJOR, E_INVALID_STATE, ("invalid pcdSupport"));
+            break;
+    }
+
+    if((p_FmPort->pcdEngines & FM_PCD_PRS) && (p_PcdParams->p_PrsParams->numOfHdrsWithAdditionalParams > FM_PCD_PRS_NUM_OF_HDRS))
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Port parser numOfHdrsWithAdditionalParams may not exceed %d", FM_PCD_PRS_NUM_OF_HDRS));
+
+    /* check that parameters exist for each and only each defined engine */
+    if((!!(p_FmPort->pcdEngines & FM_PCD_PRS) != !!p_PcdParams->p_PrsParams) ||
+        (!!(p_FmPort->pcdEngines & FM_PCD_KG) != !!p_PcdParams->p_KgParams) ||
+        (!!(p_FmPort->pcdEngines & FM_PCD_CC) != !!p_PcdParams->p_CcParams))
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("PCD initialization structure is not consistant with pcdSupport"));
+
+    /* get PCD registers pointers */
+    switch(p_FmPort->portType)
+    {
+        case(e_FM_PORT_TYPE_RX_10G):
+        case(e_FM_PORT_TYPE_RX):
+            p_BmiNia = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfne;
+            p_BmiPrsNia = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfpne;
+            p_BmiPrsStartOffset = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rpso;
+            p_BmiInitPrsResult = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rprai[0];
+            p_BmiCcBase = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rccb;
+       break;
+        case(e_FM_PORT_TYPE_OFFLINE_PARSING):
+            p_BmiNia = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofne;
+            p_BmiPrsNia = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofpne;
+            p_BmiPrsStartOffset = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_opso;
+            p_BmiInitPrsResult = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_oprai[0];
+            p_BmiCcBase = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_occb;
+        break;
+        default:
+            break;
+    }
+
+    if(p_FmPort->pcdEngines & FM_PCD_KG)
+    {
+
+        if(p_PcdParams->p_KgParams->numOfSchemes == 0)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("For ports using Keygen, at lease one scheme must be bound. "));
+        /* for each scheme */
+        for(i = 0; i<p_PcdParams->p_KgParams->numOfSchemes; i++)
+        {
+            physicalSchemeId = (uint8_t)(CAST_POINTER_TO_UINT32(p_PcdParams->p_KgParams->h_Schemes[i])-1);
+            /* build vector */
+            p_FmPort->schemesPerPortVector |= 1 << (31 - physicalSchemeId);
+        }
+
+        err = FmPortPcdKgSwBindClsPlanGrp(p_FmPort,
+                                          p_PcdParams->p_KgParams->useClsPlan,
+                                          (uint8_t)(CAST_POINTER_TO_UINT32(p_PcdParams->p_KgParams->h_ClsPlanGrp)-1));
+        if(err)
+            RETURN_ERROR(MINOR, err, NO_MSG);
+    }
+
+    /* set PCD port parameter */
+    if(p_FmPort->pcdEngines & FM_PCD_CC)
+    {
+        err = FmPcdCcBindTree(p_FmPort->h_FmPcd, p_PcdParams->p_CcParams->h_CcTree, &ccTreePhysOffset);
+        if(err)
+            RETURN_ERROR(MINOR, err, NO_MSG);
+
+        WRITE_UINT32(*p_BmiCcBase, ccTreePhysOffset);
+        p_FmPort->ccTreeId = p_PcdParams->p_CcParams->h_CcTree;
+    }
+
+    /* NIA after BMI*/
+    if((p_FmPort->pcdEngines & FM_PCD_PLCR) &&
+        ((p_PcdParams->pcdSupport == e_FM_PORT_PCD_SUPPORT_PLCR_ONLY) ||
+                (p_PcdParams->pcdSupport == e_FM_PORT_PCD_SUPPORT_PRS_AND_PLCR)))
+    {
+        absoluteProfileId = (uint16_t)(CAST_POINTER_TO_UINT32(p_PcdParams->p_PlcrParams->h_Profile)-1);
+
+        if(!FmPcdPlcrIsProfileValid(p_FmPort->h_FmPcd, absoluteProfileId))
+            RETURN_ERROR(MINOR, E_INVALID_STATE, ("Private port profile not valid."));
+
+        tmpReg = (uint32_t)(absoluteProfileId | NIA_PLCR_ABSOLUTE);
+
+        if(p_FmPort->pcdEngines & FM_PCD_PRS) /* e_FM_PCD_SUPPORT_PRS_AND_PLCR */
+        {
+            /* update BMI HPNIA */
+            WRITE_UINT32(*p_BmiPrsNia, (uint32_t)(NIA_ENG_PLCR | tmpReg));
+        }
+        else /* e_FM_PCD_SUPPORT_PLCR_ONLY */
+        {
+            /* rfne may contain FDCS bits, so first we read them. */
+            tmpReg |= GET_UINT32(*p_BmiNia) & BMI_RFNE_FDCS_MASK;
+            /* update BMI NIA */
+            p_FmPort->savedBmiNia = (uint32_t)(NIA_ENG_PLCR | tmpReg);
+            //WRITE_UINT32(*p_BmiNia, (uint32_t)(NIA_ENG_PLCR | tmpReg));
+        }
+    }
+
+    /* all cases but e_FM_PORT_PCD_SUPPORT_PLCR_ONLY, use parser */
+    if(!(p_PcdParams->pcdSupport == e_FM_PORT_PCD_SUPPORT_PLCR_ONLY))
+    {
+        ASSERT_COND(p_FmPort->pcdEngines & FM_PCD_PRS);
+        /* Go to Parser */
+
+        GET_PRS_HDR_NUM(hdrNum, p_PcdParams->p_PrsParams->firstPrsHdr);
+        if (hdrNum == ILLEGAL_HDR_NUM)
+            RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Unsupported header."));
+        /* rfne may contain FDCS bits, so first we read them. */
+        tmpReg = GET_UINT32(*p_BmiNia) & BMI_RFNE_FDCS_MASK;
+        p_FmPort->savedBmiNia = tmpReg | (uint32_t)(NIA_ENG_PRS | (uint32_t)(hdrNum * PRS_HDR_ENTRY_SIZE));
+        //WRITE_UINT32(*p_BmiNia, tmpReg | (uint32_t)(NIA_ENG_PRS | (uint32_t)(hdrNum * PRS_HDR_ENTRY_SIZE)));
+        ASSERT_COND(p_PcdParams->p_PrsParams);
+        /* set after parser NIA */
+        tmpReg = 0;
+        switch(p_PcdParams->pcdSupport)
+        {
+            case(e_FM_PORT_PCD_SUPPORT_PRS_ONLY):
+                WRITE_UINT32(*p_BmiPrsNia, NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME);
+                break;
+            case(e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC):
+            case(e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC_AND_PLCR):
+                tmpReg = NIA_KG_CC_EN;
+            case(e_FM_PORT_PCD_SUPPORT_PRS_AND_KG):
+            case(e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_PLCR):
+                if(p_PcdParams->p_KgParams->directScheme)
+                {
+                    physicalSchemeId = (uint8_t)(CAST_POINTER_TO_UINT32(p_PcdParams->p_KgParams->h_DirectScheme)-1);
+                    /* check that this scheme was bound to this port */
+                    for(i=0 ; i<p_PcdParams->p_KgParams->numOfSchemes; i++)
+                        if(p_PcdParams->p_KgParams->h_DirectScheme == p_PcdParams->p_KgParams->h_Schemes[i])
+                            break;
+                    if(i == p_PcdParams->p_KgParams->numOfSchemes)
+                        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Direct scheme is not one of the port selected schemes."));
+
+                    tmpReg |= (uint32_t)(NIA_KG_DIRECT | physicalSchemeId);
+                }
+                WRITE_UINT32(*p_BmiPrsNia, NIA_ENG_KG | tmpReg);
+                break;
+            default:
+                break;
+        }
+
+        /* set start parsing offset */
+        WRITE_UINT32(*p_BmiPrsStartOffset, p_PcdParams->p_PrsParams->parsingOffset);
+
+        /************************************/
+        /* Parser port parameters           */
+        /************************************/
+        /* stop before configuring */
+        WRITE_UINT32(p_FmPort->p_FmPortPrsRegs->pcac, PRS_CAC_STOP);
+        /* wait for parser to be in idle state */
+        while(GET_UINT32(p_FmPort->p_FmPortPrsRegs->pcac) & PRS_CAC_ACTIVE) ;
+
+        /* set soft seq attachment register */
+        memset(tmpHxs, 0, FM_PCD_PRS_NUM_OF_HDRS*sizeof(uint32_t));
+
+        /* set protocol options */
+        for(i=0;p_FmPort->optArray[i];i++)
+            switch(p_FmPort->optArray[i])
+            {
+                case(ETH_BROADCAST):
+                    GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_ETH)
+                    tmpHxs[hdrNum] |= (i+1) << PRS_HDR_ETH_BC_SHIFT;
+                    break;
+                case(ETH_MULTICAST):
+                    GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_ETH)
+                    tmpHxs[hdrNum] |= (i+1) << PRS_HDR_ETH_MC_SHIFT;
+                    break;
+                case(VLAN_STACKED):
+                    GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_VLAN)
+                    tmpHxs[hdrNum] |= (i+1)<< PRS_HDR_VLAN_STACKED_SHIFT;
+                    break;
+                case(MPLS_STACKED):
+                    GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_MPLS)
+                    tmpHxs[hdrNum] |= (i+1) << PRS_HDR_MPLS_STACKED_SHIFT;
+                    break;
+                case(IPV4_BROADCAST_1):
+                    GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_IPv4)
+                    tmpHxs[hdrNum] |= (i+1) << PRS_HDR_IPV4_1_BC_SHIFT;
+                    break;
+                case(IPV4_MULTICAST_1):
+                    GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_IPv4)
+                    tmpHxs[hdrNum] |= (i+1) << PRS_HDR_IPV4_1_MC_SHIFT;
+                    break;
+                case(IPV4_UNICAST_2):
+                    GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_IPv4)
+                    tmpHxs[hdrNum] |= (i+1) << PRS_HDR_IPV4_2_UC_SHIFT;
+                    break;
+                case(IPV4_MULTICAST_BROADCAST_2):
+                    GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_IPv4)
+                    tmpHxs[hdrNum] |= (i+1) << PRS_HDR_IPV4_2_MC_BC_SHIFT;
+                    break;
+                case(IPV6_MULTICAST_1):
+                    GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_IPv6)
+                    tmpHxs[hdrNum] |= (i+1) << PRS_HDR_IPV6_1_MC_SHIFT;
+                    break;
+                case(IPV6_UNICAST_2):
+                    GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_IPv6)
+                    tmpHxs[hdrNum] |= (i+1) << PRS_HDR_IPV6_2_UC_SHIFT;
+                    break;
+                case(IPV6_MULTICAST_2):
+                    GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_IPv6)
+                    tmpHxs[hdrNum] |= (i+1) << PRS_HDR_IPV6_2_MC_SHIFT;
+                    break;
+            }
+
+        /* set MPLS default next header - HW reset workaround  */
+        GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_MPLS)
+        tmpHxs[hdrNum] |= PRS_HDR_MPLS_LBL_INTER_EN;
+        GET_PRS_HDR_NUM(L3HdrNum, HEADER_TYPE_USER_DEFINED_L3);
+        tmpHxs[hdrNum] |= L3HdrNum  << PRS_HDR_MPLS_NEXT_HDR_SHIFT;
+
+        /* config additional params for specific headers */
+        for(i=0 ; i<p_PcdParams->p_PrsParams->numOfHdrsWithAdditionalParams ; i++)
+        {
+            GET_PRS_HDR_NUM(hdrNum, p_PcdParams->p_PrsParams->additionalParams[i].hdr);
+            if(hdrNum== ILLEGAL_HDR_NUM)
+                RETURN_ERROR(MAJOR, E_INVALID_VALUE, NO_MSG);
+            if(hdrNum==NO_HDR_NUM)
+                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Private headers may not use additional parameters"));
+
+            err = AdditionalPrsParams(p_FmPort, &p_PcdParams->p_PrsParams->additionalParams[i], &tmpReg);
+            if(err)
+                RETURN_ERROR(MAJOR, E_INVALID_VALUE, NO_MSG);
+
+            tmpHxs[hdrNum] |= tmpReg;
+        }
+        /* link to sw parser code for L4 shells - only if no other code is applied. */
+        GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_SCTP)
+        if(!(tmpHxs[hdrNum] & PRS_HDR_SW_PRS_EN))
+            tmpHxs[hdrNum] |= (PRS_HDR_SW_PRS_EN | SCTP_SW_PATCH_START);
+        GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_DCCP)
+        if(!(tmpHxs[hdrNum] & PRS_HDR_SW_PRS_EN))
+            tmpHxs[hdrNum] |= (PRS_HDR_SW_PRS_EN | DCCP_SW_PATCH_START);
+        GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_IPSEC_AH)
+        if(!(tmpHxs[hdrNum] & PRS_HDR_SW_PRS_EN))
+            tmpHxs[hdrNum] |= (PRS_HDR_SW_PRS_EN | IPSEC_SW_PATCH_START);
+
+        for(i=0 ; i<FM_PCD_PRS_NUM_OF_HDRS ; i++)
+        {
+            /* For all header set LCV as taken from netEnv*/
+            WRITE_UINT32(p_FmPort->p_FmPortPrsRegs->hdrs[i].lcv,  FmPcdGetLcv(p_FmPort->h_FmPcd, p_FmPort->netEnvId, (uint8_t)i));
+            /* set HXS register according to default+Additional params+protocol options */
+            WRITE_UINT32(p_FmPort->p_FmPortPrsRegs->hdrs[i].softSeqAttach,  tmpHxs[i]);
+        }
+
+        /* set tpid. */
+        tmpReg = PRS_TPID_DFLT;
+        if(p_PcdParams->p_PrsParams->setVlanTpid1)
+        {
+            tmpReg &= PRS_TPID2_MASK;
+            tmpReg |= (uint32_t)p_PcdParams->p_PrsParams->vlanTpid1 << PRS_PCTPID_SHIFT;
+        }
+        if(p_PcdParams->p_PrsParams->setVlanTpid2)
+        {
+            tmpReg &= PRS_TPID1_MASK;
+            tmpReg |= (uint32_t)p_PcdParams->p_PrsParams->vlanTpid2;
+        }
+        WRITE_UINT32(p_FmPort->p_FmPortPrsRegs->pctpid, tmpReg);
+
+        /* enable parser */
+        WRITE_UINT32(p_FmPort->p_FmPortPrsRegs->pcac, 0);
+    }
+
+    if(p_PcdParams->p_PrsParams->prsResultPrivateInfo)
+        p_FmPort->privateInfo = p_PcdParams->p_PrsParams->prsResultPrivateInfo;
+
+    /* set initial parser result - used for all engines */
+    for (i=0;i<PRS_RESULT_NUM_OF_WORDS;i++)
+    {
+        if (!i)
+            WRITE_UINT32(*(p_BmiInitPrsResult), (uint32_t)((p_FmPort->privateInfo << BMI_PR_PORTID_SHIFT)
+                                                            | BMI_PRS_RESULT_HIGH));
+        else
+            if (i< PRS_RESULT_NUM_OF_WORDS/2)
+                WRITE_UINT32(*(p_BmiInitPrsResult+i), BMI_PRS_RESULT_HIGH);
+            else
+                WRITE_UINT32(*(p_BmiInitPrsResult+i), BMI_PRS_RESULT_LOW);
+    }
+
+    return E_OK;
+}
+
+t_Error FmPortDeletePcd(t_Handle h_FmPort)
+{
+    t_FmPort                            *p_FmPort = (t_FmPort*)h_FmPort;
+    t_Error                             err = E_OK;
+    volatile uint32_t                   *p_BmiNia=NULL;
+    //uint32_t                            tmpReg;
+
+    SANITY_CHECK_RETURN_ERROR(h_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
+
+    if (p_FmPort->imEn)
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for non-independant mode ports only"));
+
+    if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) &&
+        (p_FmPort->portType != e_FM_PORT_TYPE_RX) &&
+        (p_FmPort->portType != e_FM_PORT_TYPE_OFFLINE_PARSING))
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx and offline parsing ports only"));
+
+    if(!p_FmPort->pcdEngines)
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("called for non PCD port"));
+
+    /* get PCD registers pointers */
+    switch(p_FmPort->portType)
+    {
+        case(e_FM_PORT_TYPE_RX_10G):
+        case(e_FM_PORT_TYPE_RX):
+            p_BmiNia = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfne;
+            break;
+        case(e_FM_PORT_TYPE_OFFLINE_PARSING):
+            p_BmiNia = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofne;
+        break;
+        default:
+            break;
+    }
+
+    /* "cut" PCD out of the port's flow - go to BMI */
+    //tmpReg = GET_UINT32(*p_BmiNia) & BMI_RFNE_FDCS_MASK;
+    //WRITE_UINT32(*p_BmiNia, NIA_ENG_BMI | tmpReg);
+    WRITE_UINT32(*p_BmiNia, (p_FmPort->savedBmiNia & BMI_RFNE_FDCS_MASK) | (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME));
+
+    if(p_FmPort->pcdEngines | FM_PCD_PRS)
+    {
+        /* stop parser */
+        WRITE_UINT32(p_FmPort->p_FmPortPrsRegs->pcac, PRS_CAC_STOP);
+        /* wait for parser to be in idle state */
+        while(GET_UINT32(p_FmPort->p_FmPortPrsRegs->pcac) & PRS_CAC_ACTIVE) ;
+    }
+
+    if(p_FmPort->pcdEngines & FM_PCD_KG)
+        FmPcdKgSwUnbindPortToClsPlanGrp(p_FmPort->h_FmPcd, p_FmPort->clsPlanGrpId);
+
+    if(p_FmPort->pcdEngines & FM_PCD_CC)
+    {
+        //unbind - we need to get the treeId too.
+
+        err = FmPcdCcUnbindTree(p_FmPort->h_FmPcd,  p_FmPort->ccTreeId);
+        if(err)
+            RETURN_ERROR(MINOR, err, NO_MSG);
+    }
+
+    p_FmPort->pcdEngines = 0;
+
+    return E_OK;
+}
+
+void          FmPortPcdKgSwUnbindClsPlanGrp (t_Handle h_FmPort)
+{
+    t_FmPort        *p_FmPort = (t_FmPort*)h_FmPort;
+
+    FmPcdKgSwUnbindPortToClsPlanGrp(p_FmPort->h_FmPcd, p_FmPort->clsPlanGrpId);
+}
+
+t_Error          FmPortPcdKgSwBindClsPlanGrp (t_Handle h_FmPort, bool useClsPlan, uint8_t newClsPlanGrpId)
+{
+    t_FmPort        *p_FmPort = (t_FmPort*)h_FmPort;
+    t_Error         err;
+
+    if(useClsPlan)
+    {
+        p_FmPort->useClsPlan = TRUE;
+        p_FmPort->clsPlanGrpId = newClsPlanGrpId;
+        err = FmPcdKgSwBindPortToClsPlanGrp(p_FmPort->h_FmPcd, p_FmPort->netEnvId, newClsPlanGrpId, p_FmPort->optArray);
+    }
+    else
+    {
+        if(!FmPcdKgIsEmptyClsPlanGrp(p_FmPort->h_FmPcd))
+            RETURN_ERROR(MINOR, E_CONFLICT, ("A port is defined to be without clsPlan, but PCD was configured so that all ports use the clsPlan mechanism"));
+        p_FmPort->clsPlanGrpId = FmPcdKgGetEmptyClsPlanGrpId(p_FmPort->h_FmPcd);
+        err = FmPcdKgSwBindPortToClsPlanGrp(p_FmPort->h_FmPcd, DRIVER_PRIVATE_NET_ENV_ID, p_FmPort->clsPlanGrpId, p_FmPort->optArray);
+    }
+    if(err)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("FmPortPcdKgSwBindClsPlanGrp failed. "));
+
+    return E_OK;
+}
+
+uint8_t FmPortGetNetEnvId(t_Handle h_FmPort)
+{
+    return ((t_FmPort*)h_FmPort)->netEnvId;
+}
+
+uint8_t FmPortGetHardwarePortId(t_Handle h_FmPort)
+{
+    return ((t_FmPort*)h_FmPort)->hardwarePortId;
+}
+
+uint32_t FmPortGetPcdEngines(t_Handle h_FmPort)
+{
+    return ((t_FmPort*)h_FmPort)->pcdEngines;
+}
+
+uint8_t  FmPortGetClsPlanId(t_Handle h_FmPort)
+{
+    return ((t_FmPort*)h_FmPort)->clsPlanGrpId;
+}
+
+t_Error FmPortAttachPCD(t_Handle h_FmPort)
+{
+    t_FmPort                            *p_FmPort = (t_FmPort*)h_FmPort;
+    volatile uint32_t                   *p_BmiNia=NULL;
+
+    /* get PCD registers pointers */
+    switch(p_FmPort->portType)
+    {
+        case(e_FM_PORT_TYPE_RX_10G):
+        case(e_FM_PORT_TYPE_RX):
+            p_BmiNia = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfne;
+            break;
+        case(e_FM_PORT_TYPE_OFFLINE_PARSING):
+            p_BmiNia = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofne;
+        break;
+        default:
+            RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx and offline parsing ports only"));
+            break;
+    }
+
+    /* check that current NIA is BMI to BMI */
+    if((GET_UINT32(*p_BmiNia) & ~BMI_RFNE_FDCS_MASK) != (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME))
+            RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("may be called only for ports in BMI-to-BMI state."));
+
+    WRITE_UINT32(*p_BmiNia, p_FmPort->savedBmiNia);
+
+    return E_OK;
+}
+
+/**********************************         End of inter-module routines ********************************/
+
+/****************************************/
+/*       API Init unit functions        */
+/****************************************/
+t_Handle FM_PORT_Config(t_FmPortParams *p_FmPortParams)
+{
+    t_FmPort    *p_FmPort;
+    uint64_t    baseAddr = p_FmPortParams->baseAddr;
+
+    /* Allocate FM structure */
+    p_FmPort = (t_FmPort *) XX_Malloc(sizeof(t_FmPort));
+    if (!p_FmPort)
+    {
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM Port driver structure"));
+        return NULL;
+    }
+    memset(p_FmPort, 0, sizeof(t_FmPort));
+
+    /* Allocate the FM driver's parameters structure */
+    p_FmPort->p_FmPortDriverParam = (t_FmPortDriverParam *)XX_Malloc(sizeof(t_FmPortDriverParam));
+    if (!p_FmPort->p_FmPortDriverParam)
+    {
+        XX_Free(p_FmPort);
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM Port driver parameters"));
+        return NULL;
+    }
+    memset(p_FmPort->p_FmPortDriverParam, 0, sizeof(t_FmPortDriverParam));
+
+    /* Initialize FM port parameters which will be kept by the driver */
+    p_FmPort->portType      = p_FmPortParams->portType;
+    p_FmPort->portId        = p_FmPortParams->portId;
+    p_FmPort->pcdEngines    = FM_PCD_NONE;
+
+    /* calculate global portId number */
+    GET_GLOBAL_PORTID(p_FmPort->hardwarePortId, p_FmPort->portType, p_FmPortParams->portId);
+
+    /* Initialize FM port parameters for initialization phase only */
+    p_FmPort->p_FmPortDriverParam->baseAddr                         = baseAddr;
+    p_FmPort->p_FmPortDriverParam->bufferPrefixContent.privDataSize = DEFAULT_PORT_bufferPrefixContent_privDataSize;
+    p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passPrsResult= DEFAULT_PORT_bufferPrefixContent_passPrsResult;
+    p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passTimeStamp= DEFAULT_PORT_bufferPrefixContent_passTimeStamp;
+    p_FmPort->p_FmPortDriverParam->dmaSwapData                      = DEFAULT_PORT_dmaSwapData;
+    p_FmPort->p_FmPortDriverParam->dmaIntContextCacheAttr           = DEFAULT_PORT_dmaIntContextCacheAttr;
+    p_FmPort->p_FmPortDriverParam->dmaHeaderCacheAttr               = DEFAULT_PORT_dmaHeaderCacheAttr;
+    p_FmPort->p_FmPortDriverParam->dmaScatterGatherCacheAttr        = DEFAULT_PORT_dmaScatterGatherCacheAttr;
+    p_FmPort->p_FmPortDriverParam->dmaReadOptimize                  = DEFAULT_PORT_dmaReadOptimize;
+    p_FmPort->p_FmPortDriverParam->dmaWriteOptimize                 = DEFAULT_PORT_dmaWriteOptimize;
+
+    /* resource distrubution. */
+    p_FmPort->p_FmPortDriverParam->fifoBufs.num                     = DEFAULT_PORT_sizeOfFifo(p_FmPort->portType);
+    p_FmPort->p_FmPortDriverParam->fifoBufs.extra                   = DEFAULT_PORT_extraSizeOfFifo(p_FmPort->portType);
+    p_FmPort->p_FmPortDriverParam->openDmas.num                     = DEFAULT_PORT_numOfOpenDmas(p_FmPort->portType);
+    p_FmPort->p_FmPortDriverParam->openDmas.extra                   = DEFAULT_PORT_extraNumOfOpenDmas(p_FmPort->portType);
+    p_FmPort->p_FmPortDriverParam->tasks.num                        = DEFAULT_PORT_numOfTasks(p_FmPort->portType);
+    p_FmPort->p_FmPortDriverParam->tasks.extra                      = DEFAULT_PORT_extraNumOfTasks(p_FmPort->portType);
+
+    p_FmPort->p_FmPortDriverParam->syncReq                          = DEFAULT_PORT_syncReq;
+    p_FmPort->p_FmPortDriverParam->color                            = DEFAULT_PORT_color;
+
+#ifdef   VERIFICATION_SUPPORT
+    p_FmPort->p_FmPortDriverParam->intContextConfigured             = FALSE;
+#endif /* VERIFICATION_SUPPORT */
+    /* Port type specific initialization: */
+
+    if((p_FmPort->portType != e_FM_PORT_TYPE_TX) && (p_FmPort->portType != e_FM_PORT_TYPE_TX_10G))
+        p_FmPort->p_FmPortDriverParam->frmDiscardOverride           = DEFAULT_PORT_frmDiscardOverride;
+
+    switch(p_FmPort->portType)
+    {
+    case(e_FM_PORT_TYPE_RX):
+    case(e_FM_PORT_TYPE_RX_10G):
+        /* Initialize FM port parameters for initialization phase only */
+        p_FmPort->p_FmPortDriverParam->cutBytesFromEnd              = DEFAULT_PORT_cutBytesFromEnd;
+        p_FmPort->p_FmPortDriverParam->enBufPoolDepletion           = FALSE;
+        p_FmPort->p_FmPortDriverParam->frmDiscardOverride           = DEFAULT_PORT_frmDiscardOverride;
+        p_FmPort->p_FmPortDriverParam->rxFifoPriElevationLevel      = DEFAULT_PORT_rxFifoPriElevationLevel;
+        p_FmPort->p_FmPortDriverParam->rxFifoThreshold              = DEFAULT_PORT_rxFifoThreshold;
+        p_FmPort->p_FmPortDriverParam->bufMargins.endMargins        = DEFAULT_PORT_BufMargins_endMargins;
+        p_FmPort->p_FmPortDriverParam->errorsToDiscard              = DEFAULT_PORT_errorsToDiscard;
+        p_FmPort->p_FmPortDriverParam->cheksumLastBytesIgnore       = DEFAULT_PORT_cheksumLastBytesIgnore;
+        p_FmPort->p_FmPortDriverParam->forwardReuseIntContext       = DEFAULT_PORT_forwardIntContextReuse;
+        p_FmPort->p_FmPortDriverParam->l4Checksum                   = DEFAULT_PORT_l4Checksum;
+        break;
+
+    case(e_FM_PORT_TYPE_TX):
+        p_FmPort->txFifoDeqPipelineDepth                            = DEFAULT_PORT_txFifoDeqPipelineDepth_1G;
+    case(e_FM_PORT_TYPE_TX_10G):
+        if(p_FmPort->portType == e_FM_PORT_TYPE_TX_10G)
+            p_FmPort->txFifoDeqPipelineDepth                        = DEFAULT_PORT_txFifoDeqPipelineDepth_10G;
+        p_FmPort->p_FmPortDriverParam->cheksumLastBytesIgnore       = DEFAULT_PORT_cheksumLastBytesIgnore;
+        p_FmPort->p_FmPortDriverParam->txFifoMinFillLevel           = DEFAULT_PORT_txFifoMinFillLevel;
+        p_FmPort->p_FmPortDriverParam->txFifoLowComfLevel           = DEFAULT_PORT_txFifoLowComfLevel;
+    case(e_FM_PORT_TYPE_OFFLINE_PARSING):
+        p_FmPort->p_FmPortDriverParam->enRateLimit                  = FALSE;
+    case(e_FM_PORT_TYPE_HOST_COMMAND):
+        p_FmPort->p_FmPortDriverParam->deqHighPriority              = DEFAULT_PORT_deqHighPriority;
+        p_FmPort->p_FmPortDriverParam->deqType                      = DEFAULT_PORT_deqType;
+        p_FmPort->p_FmPortDriverParam->deqPrefetchOption            = DEFAULT_PORT_deqPrefetchOption;
+        p_FmPort->p_FmPortDriverParam->deqByteCnt                   = DEFAULT_PORT_deqByteCnt;
+
+        if(p_FmPort->portType == e_FM_PORT_TYPE_OFFLINE_PARSING)
+        {
+            p_FmPort->p_FmPortDriverParam->errorsToDiscard          = DEFAULT_PORT_errorsToDiscard;
+        }
+        break;
+
+    default:
+        break;
+    }
+
+    p_FmPort->imEn = p_FmPortParams->independentModeEnable;
+
+    if (p_FmPort->imEn)
+        FmPortConfigIM(p_FmPort, p_FmPortParams);
+    else
+    {
+        switch(p_FmPort->portType)
+        {
+        case(e_FM_PORT_TYPE_RX):
+        case(e_FM_PORT_TYPE_RX_10G):
+            /* Initialize FM port parameters for initialization phase only */
+            memcpy(&p_FmPort->p_FmPortDriverParam->rxExtBufPools,
+                   &p_FmPortParams->specificParams.rxParams.rxExtBufPools,
+                   sizeof(t_FmPortRxExtPools));
+            p_FmPort->p_FmPortDriverParam->errFqid                      = p_FmPortParams->specificParams.rxParams.errFqid;
+            p_FmPort->p_FmPortDriverParam->dfltFqid                     = p_FmPortParams->specificParams.rxParams.dfltFqid;
+            p_FmPort->p_FmPortDriverParam->partitionId                  = p_FmPortParams->specificParams.rxParams.rxPartitionId;
+            break;
+        case(e_FM_PORT_TYPE_OFFLINE_PARSING):
+#ifdef FM_OP_PARTITION_ERRATA
+            p_FmPort->p_FmPortDriverParam->partitionId                  = p_FmPortParams->specificParams.nonRxParams.opPartitionId;
+#endif /* FM_OP_PARTITION_ERRATA */
+        case(e_FM_PORT_TYPE_TX):
+        case(e_FM_PORT_TYPE_TX_10G):
+        case(e_FM_PORT_TYPE_HOST_COMMAND):
+            p_FmPort->p_FmPortDriverParam->errFqid                      = p_FmPortParams->specificParams.nonRxParams.errFqid;
+            p_FmPort->p_FmPortDriverParam->deqSubPortal                 = p_FmPortParams->specificParams.nonRxParams.deqSubPortal;
+            p_FmPort->p_FmPortDriverParam->dfltFqid                     = p_FmPortParams->specificParams.nonRxParams.dfltFqid;
+            break;
+        default:
+            break;
+        }
+    }
+
+    p_FmPort->h_Fm = p_FmPortParams->h_Fm;
+
+    return p_FmPort;
+}
+
+/**************************************************************************//**
+ @Function      FM_PORT_Init
+
+ @Description   Initializes the FM module
+
+ @Param[in]     h_FmPort - FM module descriptor
+
+ @Return        E_OK on success; Error code otherwise.
+*//***************************************************************************/
+t_Error FM_PORT_Init(t_Handle h_FmPort)
+{
+    t_FmPort                        *p_FmPort = (t_FmPort*)h_FmPort;
+    t_FmPortDriverParam             *p_Params;
+    t_Error                         err = E_OK;
+    t_FmInterModulePortInitParams   fmParams;
+
+    SANITY_CHECK_RETURN_ERROR(h_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+
+#ifdef VERIFICATION_SUPPORT
+    if(!p_FmPort->p_FmPortDriverParam->intContextConfigured)
+    {
+#endif /* VERIFICATION_SUPPORT */
+    /* translate margin and intContext params to FM parameters */
+    p_FmPort->p_FmPortDriverParam->intContext.size = (uint16_t)((p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passPrsResult ? 32:0) +
+                                                        (p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passTimeStamp ? 16:0));
+    /* align start of internal context data to 16 byte */
+    p_FmPort->p_FmPortDriverParam->intContext.extBufOffset =  (uint16_t)((p_FmPort->p_FmPortDriverParam->bufferPrefixContent.privDataSize & (OFFSET_UNITS-1))?
+            ((p_FmPort->p_FmPortDriverParam->bufferPrefixContent.privDataSize + OFFSET_UNITS) &  ~(uint16_t)(OFFSET_UNITS-1)) :
+            p_FmPort->p_FmPortDriverParam->bufferPrefixContent.privDataSize);
+    p_FmPort->p_FmPortDriverParam->intContext.intContextOffset = (uint8_t)(p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passPrsResult ? 32:
+            (p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passTimeStamp ? 64 : 0));
+    p_FmPort->p_FmPortDriverParam->bufMargins.startMargins = (uint16_t)(p_FmPort->p_FmPortDriverParam->intContext.extBufOffset +
+            p_FmPort->p_FmPortDriverParam->intContext.size);
+#ifdef VERIFICATION_SUPPORT
+    }
+#endif /* VERIFICATION_SUPPORT */
+    CHECK_INIT_PARAMETERS(p_FmPort, CheckInitParameters);
+
+    p_Params = p_FmPort->p_FmPortDriverParam;
+
+    /* set memory map pointers */
+    p_FmPort->p_FmPortQmiRegs     = CAST_UINT64_TO_POINTER_TYPE(t_FmPortQmiRegs , (p_Params->baseAddr + QMI_PORT_REGS_OFFSET));
+    p_FmPort->p_FmPortBmiRegs     = CAST_UINT64_TO_POINTER_TYPE(u_FmPortBmiRegs , (p_Params->baseAddr + BMI_PORT_REGS_OFFSET));
+    p_FmPort->p_FmPortPrsRegs     = CAST_UINT64_TO_POINTER_TYPE(t_FmPortPrsRegs, (p_Params->baseAddr + PRS_PORT_REGS_OFFSET));
+
+#ifdef VERIFICATION_SUPPORT
+    if(p_FmPort->p_FmPortDriverParam->intContextConfigured)
+    {
+        p_FmPort->bufferOffsets.dataOffset = p_FmPort->p_FmPortDriverParam->bufMargins.startMargins;
+        p_FmPort->bufferOffsets.prsResultOffset = (uint32_t)(p_FmPort->p_FmPortDriverParam->intContext.extBufOffset+32 - p_FmPort->p_FmPortDriverParam->intContext.intContextOffset);
+        p_FmPort->bufferOffsets.timeStampOffset = (uint32_t)(p_FmPort->p_FmPortDriverParam->intContext.extBufOffset+64 - p_FmPort->p_FmPortDriverParam->intContext.intContextOffset);
+    }
+    else
+    {
+#endif /* VERIFICATION_SUPPORT */
+    p_FmPort->bufferOffsets.dataOffset = p_FmPort->p_FmPortDriverParam->bufMargins.startMargins;
+    p_FmPort->bufferOffsets.prsResultOffset = p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passPrsResult ?
+                                    p_FmPort->p_FmPortDriverParam->intContext.extBufOffset:
+                                    0xFFFFFFFF;
+    p_FmPort->bufferOffsets.timeStampOffset = p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passTimeStamp ?
+                                    (p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passPrsResult ?
+                                    (p_FmPort->p_FmPortDriverParam->intContext.extBufOffset + sizeof(t_FmPrsResult)) :
+                                    p_FmPort->p_FmPortDriverParam->intContext.extBufOffset):
+                                    0xFFFFFFFF;
+
+#ifdef VERIFICATION_SUPPORT
+    }
+#endif /* VERIFICATION_SUPPORT */
+    /************************************************************/
+    /* Call FM module routine for communicating parameters      */
+    /************************************************************/
+    memset(&fmParams, 0, sizeof(fmParams));
+    fmParams.hardwarePortId = p_FmPort->hardwarePortId;
+    fmParams.portType = (e_FmPortType)p_FmPort->portType;
+    fmParams.numOfTasks = (uint8_t)p_Params->tasks.num;
+    fmParams.numOfExtraTasks = (uint8_t)p_Params->tasks.extra;
+    fmParams.numOfOpenDmas = (uint8_t)p_Params->openDmas.num;
+    fmParams.numOfExtraOpenDmas = (uint8_t)p_Params->openDmas.extra;
+    fmParams.sizeOfFifo = p_Params->fifoBufs.num;
+    fmParams.extraSizeOfFifo = p_Params->fifoBufs.extra;
+
+    fmParams.independentMode = p_FmPort->imEn;
+    fmParams.portPartition = p_Params->partitionId;
+
+    switch(p_FmPort->portType)
+    {
+        case(e_FM_PORT_TYPE_RX_10G):
+        case(e_FM_PORT_TYPE_RX):
+            break;
+        case(e_FM_PORT_TYPE_TX_10G):
+        case(e_FM_PORT_TYPE_TX):
+            fmParams.deqPipelineDepth = p_FmPort->txFifoDeqPipelineDepth;
+            break;
+        case(e_FM_PORT_TYPE_OFFLINE_PARSING):
+        case(e_FM_PORT_TYPE_HOST_COMMAND):
+            fmParams.deqPipelineDepth = p_FmPort->txFifoDeqPipelineDepth = 1;
+            break;
+        default:
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
+    }
+
+    err = FmGetSetPortParams(p_FmPort->h_Fm, &fmParams);
+    if(err)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+
+    /* get params for use in init */
+    p_Params->timeStampPeriod = fmParams.timeStampPeriod;
+    p_Params->fmMuramPhysBaseAddr = 0;
+    memcpy(((uint8_t *)&p_Params->fmMuramPhysBaseAddr)+2, (uint8_t *)&fmParams.fmMuramPhysBaseAddr, sizeof(t_FmPhysAddr));
+
+    /**********************/
+    /* Init BMI Registers */
+    /**********************/
+    switch(p_FmPort->portType)
+    {
+        case(e_FM_PORT_TYPE_RX_10G):
+        case(e_FM_PORT_TYPE_RX):
+            err = BmiRxPortInit(p_FmPort);
+            if(err)
+                RETURN_ERROR(MAJOR, err, NO_MSG);
+            break;
+        case(e_FM_PORT_TYPE_TX_10G):
+        case(e_FM_PORT_TYPE_TX):
+            err = BmiTxPortInit(p_FmPort);
+            if(err)
+                RETURN_ERROR(MAJOR, err, NO_MSG);
+            break;
+        case(e_FM_PORT_TYPE_OFFLINE_PARSING):
+        case(e_FM_PORT_TYPE_HOST_COMMAND):
+            err = BmiOhPortInit(p_FmPort);
+            if(err)
+                RETURN_ERROR(MAJOR, err, NO_MSG);
+            break;
+        default:
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
+    }
+
+    /**********************/
+    /* Init QMI Registers */
+    /**********************/
+    if (!p_FmPort->imEn && ((err = QmiInit(p_FmPort)) != E_OK))
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+
+    if (p_FmPort->imEn && ((err = FmPortImInit(p_FmPort)) != E_OK))
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+
+    FmPortDriverParamFree(p_FmPort);
+
+    /* enable port. */
+    FM_PORT_Enable(p_FmPort);
+
+    return E_OK;
+}
+
+/**************************************************************************//**
+ @Function      FM_PORT_Free
+
+ @Description   Frees all resources that were assigned to FM module.
+
+                Calling this routine invalidates the descriptor.
+
+ @Param[in]     h_FmPort - FM module descriptor
+
+ @Return        E_OK on success; Error code otherwise.
+*//***************************************************************************/
+t_Error FM_PORT_Free(t_Handle h_FmPort)
+{
+    t_FmPort                            *p_FmPort = (t_FmPort*)h_FmPort;
+    t_FmInterModulePortFreeParams       fmParams;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+
+    if(p_FmPort->pcdEngines)
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Trying to free a port with PCD. FM_PORT_DeletePCD must be called first."));
+
+    FM_PORT_Disable(p_FmPort);
+    FmPortDriverParamFree(p_FmPort);
+
+    if (p_FmPort->imEn)
+        FmPortImFree(p_FmPort);
+
+    fmParams.hardwarePortId = p_FmPort->hardwarePortId;
+    fmParams.portType = (e_FmPortType)p_FmPort->portType;
+    fmParams.deqPipelineDepth = p_FmPort->txFifoDeqPipelineDepth;
+
+    FmFreePortParams(p_FmPort->h_Fm, &fmParams);
+
+    XX_Free(p_FmPort);
+
+    return E_OK;
+}
+
+/*************************************************/
+/*       API Advanced Init unit functions        */
+/*************************************************/
+t_Error FM_PORT_ConfigNumOfOpenDmas(t_Handle h_FmPort, t_FmPortRsrc *p_NumOfOpenDmas)
+{
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+
+    memcpy(&p_FmPort->p_FmPortDriverParam->openDmas, p_NumOfOpenDmas, sizeof(t_FmPortRsrc));
+
+    return E_OK;
+}
+
+t_Error FM_PORT_ConfigNumOfTasks(t_Handle h_FmPort, t_FmPortRsrc *p_NumOfTasks)
+{
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+
+    if(p_FmPort->portType == e_FM_PORT_TYPE_HOST_COMMAND)
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("not available for host command port where number is always 1"));
+
+    memcpy(&p_FmPort->p_FmPortDriverParam->tasks, p_NumOfTasks, sizeof(t_FmPortRsrc));
+
+    return E_OK;
+}
+
+t_Error FM_PORT_ConfigSizeOfFifo(t_Handle h_FmPort, t_FmPortRsrc *p_SizeOfFifo)
+{
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+
+    memcpy(&p_FmPort->p_FmPortDriverParam->fifoBufs, p_SizeOfFifo, sizeof(t_FmPortRsrc));
+
+    return E_OK;
+}
+
+t_Error FM_PORT_ConfigDeqHighPriority(t_Handle h_FmPort, bool highPri)
+{
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+    if((p_FmPort->portType == e_FM_PORT_TYPE_RX_10G) || (p_FmPort->portType == e_FM_PORT_TYPE_RX))
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("not available for Rx ports"));
+
+    p_FmPort->p_FmPortDriverParam->deqHighPriority = highPri;
+
+    return E_OK;
+}
+
+t_Error FM_PORT_ConfigDeqType(t_Handle h_FmPort, e_FmPortDeqType deqType)
+{
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+    if((p_FmPort->portType == e_FM_PORT_TYPE_RX_10G) || (p_FmPort->portType == e_FM_PORT_TYPE_RX))
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("not available for Rx ports"));
+
+    p_FmPort->p_FmPortDriverParam->deqType = deqType;
+
+    return E_OK;
+}
+
+t_Error FM_PORT_ConfigDeqPrefetchOption(t_Handle h_FmPort, e_FmPortDeqPrefetchOption deqPrefetchOption)
+{
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+    if((p_FmPort->portType == e_FM_PORT_TYPE_RX_10G) || (p_FmPort->portType == e_FM_PORT_TYPE_RX))
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("not available for Rx ports"));
+
+    p_FmPort->p_FmPortDriverParam->deqPrefetchOption = deqPrefetchOption;
+
+    return E_OK;
+}
+
+t_Error FM_PORT_ConfigDeqByteCnt(t_Handle h_FmPort, uint16_t deqByteCnt)
+{
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+    if((p_FmPort->portType == e_FM_PORT_TYPE_RX_10G) || (p_FmPort->portType == e_FM_PORT_TYPE_RX))
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("not available for Rx ports"));
+
+    p_FmPort->p_FmPortDriverParam->deqByteCnt = deqByteCnt;
+
+    return E_OK;
+}
+
+t_Error FM_PORT_ConfigBufferPrefixContent(t_Handle h_FmPort, t_FmPortBufferPrefixContent *p_FmPortBufferPrefixContent)
+{
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+
+    memcpy(&p_FmPort->p_FmPortDriverParam->bufferPrefixContent, p_FmPortBufferPrefixContent, sizeof(t_FmPortBufferPrefixContent));
+
+    return E_OK;
+}
+
+#ifdef VERIFICATION_SUPPORT
+t_Error FM_PORT_ConfigIntContent(t_Handle h_FmPort, uint8_t intContextIntOffset,
+                                                    uint16_t intContextExtOffset,
+                                                    uint16_t intContextSize,
+                                                    uint16_t startMargins,
+                                                    uint16_t endMargins)
+{
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+
+    p_FmPort->p_FmPortDriverParam->intContext.size = intContextSize;
+    /* align start of internal context data to 16 byte */
+    p_FmPort->p_FmPortDriverParam->intContext.extBufOffset =  intContextExtOffset;
+    p_FmPort->p_FmPortDriverParam->intContext.intContextOffset = intContextIntOffset;
+    p_FmPort->p_FmPortDriverParam->bufMargins.startMargins = startMargins;
+    p_FmPort->p_FmPortDriverParam->bufMargins.endMargins = endMargins;
+
+    p_FmPort->p_FmPortDriverParam->intContextConfigured = TRUE;
+   return E_OK;
+}
+#endif /* VERIFICATION_SUPPORT */
+
+t_Error FM_PORT_ConfigCheksumLastBytesIgnore(t_Handle h_FmPort, uint8_t cheksumLastBytesIgnore)
+{
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+    if((p_FmPort->portType == e_FM_PORT_TYPE_OFFLINE_PARSING) || (p_FmPort->portType == e_FM_PORT_TYPE_HOST_COMMAND))
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx & Tx ports only"));
+
+    p_FmPort->p_FmPortDriverParam->cheksumLastBytesIgnore = cheksumLastBytesIgnore;
+
+    return E_OK;
+}
+
+t_Error FM_PORT_ConfigCutBytesFromEnd(t_Handle h_FmPort, uint8_t cutBytesFromEnd)
+{
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+    if((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_RX))
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx ports only"));
+
+    p_FmPort->p_FmPortDriverParam->cutBytesFromEnd = cutBytesFromEnd;
+
+    return E_OK;
+}
+
+t_Error FM_PORT_ConfigPoolDepletion(t_Handle h_FmPort, t_FmPortBufPoolDepletion *p_BufPoolDepletion)
+{
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+    if((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_RX))
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx ports only"));
+
+    p_FmPort->p_FmPortDriverParam->enBufPoolDepletion = TRUE;
+    memcpy(&p_FmPort->p_FmPortDriverParam->bufPoolDepletion, p_BufPoolDepletion, sizeof(t_FmPortBufPoolDepletion));
+
+    return E_OK;
+}
+
+t_Error FM_PORT_ConfigRxFifoThreshold(t_Handle h_FmPort, uint32_t fifoThreshold)
+{
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+    if((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_RX))
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx ports only"));
+
+    p_FmPort->p_FmPortDriverParam->rxFifoThreshold = fifoThreshold;
+
+    return E_OK;
+}
+
+t_Error FM_PORT_ConfigRxPriElevationLevel(t_Handle h_FmPort, uint32_t priElevationLevel)
+{
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+    if((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_RX))
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx ports only"));
+
+    p_FmPort->p_FmPortDriverParam->rxFifoPriElevationLevel = priElevationLevel;
+
+    return E_OK;
+}
+
+t_Error FM_PORT_ConfigTxFifoMinFillLevel(t_Handle h_FmPort, uint32_t minFillLevel)
+{
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+    if((p_FmPort->portType != e_FM_PORT_TYPE_TX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_TX))
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Tx ports only"));
+
+    p_FmPort->p_FmPortDriverParam->txFifoMinFillLevel = minFillLevel;
+
+    return E_OK;
+}
+
+t_Error FM_PORT_ConfigTxFifoDeqPipelineDepth(t_Handle h_FmPort, uint8_t deqPipelineDepth)
+{
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+    if((p_FmPort->portType != e_FM_PORT_TYPE_TX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_TX))
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Tx ports only"));
+
+    p_FmPort->txFifoDeqPipelineDepth = deqPipelineDepth;
+
+    return E_OK;
+}
+
+t_Error FM_PORT_ConfigTxFifoLowComfLevel(t_Handle h_FmPort, uint32_t fifoLowComfLevel)
+{
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+    if((p_FmPort->portType != e_FM_PORT_TYPE_TX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_TX))
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Tx ports only"));
+
+    p_FmPort->p_FmPortDriverParam->txFifoLowComfLevel = fifoLowComfLevel;
+
+    return E_OK;
+}
+
+t_Error FM_PORT_ConfigDfltColor(t_Handle h_FmPort, e_FmPortColor color)
+{
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+
+    p_FmPort->p_FmPortDriverParam->color = color;
+
+    return E_OK;
+}
+
+t_Error FM_PORT_ConfigSyncReq(t_Handle h_FmPort, bool syncReq)
+{
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+
+    p_FmPort->p_FmPortDriverParam->syncReq = syncReq;
+
+    return E_OK;
+}
+
+t_Error FM_PORT_ConfigRateLimit(t_Handle h_FmPort, t_FmPortRateLimit *p_RateLimit)
+{
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+
+    if((p_FmPort->portType == e_FM_PORT_TYPE_RX_10G) || (p_FmPort->portType == e_FM_PORT_TYPE_RX) ||
+                                                (p_FmPort->portType == e_FM_PORT_TYPE_HOST_COMMAND))
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Tx and Offline parsing ports only"));
+
+    memcpy(&p_FmPort->p_FmPortDriverParam->rateLimit, p_RateLimit, sizeof(t_FmPortRateLimit));
+    p_FmPort->p_FmPortDriverParam->enRateLimit = TRUE;
+
+    return E_OK;
+}
+
+t_Error FM_PORT_ConfigFrmDiscardOverride(t_Handle h_FmPort, bool override)
+{
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+    if((p_FmPort->portType == e_FM_PORT_TYPE_TX_10G) && (p_FmPort->portType == e_FM_PORT_TYPE_TX))
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("not available for Tx ports"));
+
+    p_FmPort->p_FmPortDriverParam->frmDiscardOverride = override;
+
+    return E_OK;
+}
+
+t_Error FM_PORT_ConfigErrorsToDiscard(t_Handle h_FmPort, fmPortFrameErrSelect_t errs)
+{
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+    if((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_RX) &&
+                                                            (p_FmPort->portType != e_FM_PORT_TYPE_OFFLINE_PARSING))
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx and offline parsing ports only"));
+
+    p_FmPort->p_FmPortDriverParam->errorsToDiscard = errs;
+
+    return E_OK;
+}
+
+
+t_Error FM_PORT_ConfigDmaSwapData(t_Handle h_FmPort, e_FmPortDmaSwap swapData)
+{
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+
+    p_FmPort->p_FmPortDriverParam->dmaSwapData = swapData;
+
+    return E_OK;
+}
+
+t_Error FM_PORT_ConfigDmaIcCacheAttr(t_Handle h_FmPort, e_FmPortDmaCache intContextCacheAttr)
+{
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+
+    p_FmPort->p_FmPortDriverParam->dmaIntContextCacheAttr = intContextCacheAttr;
+
+    return E_OK;
+}
+
+t_Error FM_PORT_ConfigDmaHdrAttr(t_Handle h_FmPort, e_FmPortDmaCache headerCacheAttr)
+{
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+
+    p_FmPort->p_FmPortDriverParam->dmaHeaderCacheAttr = headerCacheAttr;
+
+    return E_OK;
+}
+
+t_Error FM_PORT_ConfigDmaScatterGatherAttr(t_Handle h_FmPort, e_FmPortDmaCache scatterGatherCacheAttr)
+{
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+
+    p_FmPort->p_FmPortDriverParam->dmaScatterGatherCacheAttr = scatterGatherCacheAttr;
+
+    return E_OK;
+}
+
+t_Error FM_PORT_ConfigDmaReadOptimize(t_Handle h_FmPort, bool optimize)
+{
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+
+    p_FmPort->p_FmPortDriverParam->dmaReadOptimize = optimize;
+
+    return E_OK;
+}
+
+t_Error FM_PORT_ConfigDmaWriteOptimize(t_Handle h_FmPort, bool optimize)
+{
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+
+    p_FmPort->p_FmPortDriverParam->dmaWriteOptimize = optimize;
+
+    return E_OK;
+}
+
+t_Error FM_PORT_ConfigForwardReuseIntContext(t_Handle h_FmPort, bool forwardReuse)
+{
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+
+    if((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_RX))
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx ports only"));
+
+    p_FmPort->p_FmPortDriverParam->forwardReuseIntContext = forwardReuse;
+
+    return E_OK;
+}
+
+t_Error FM_PORT_ConfigRxL4ChecksumVerify(t_Handle h_FmPort, bool l4Checksum)
+{
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+
+    if((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_RX))
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx ports only"));
+
+    p_FmPort->p_FmPortDriverParam->l4Checksum = l4Checksum;
+
+    return E_OK;
+}
+
+/****************************************************/
+/*       PCD Advaced config API                     */
+/****************************************************/
+
+/****************************************************/
+/*       API Run-time Control unit functions        */
+/****************************************************/
+
+uint32_t FM_PORT_GetBufferDataOffset(t_Handle h_FmPort)
+{
+    t_FmPort                    *p_FmPort = (t_FmPort*)h_FmPort;
+
+    SANITY_CHECK_RETURN_VALUE(p_FmPort, E_INVALID_HANDLE, 0);
+    SANITY_CHECK_RETURN_VALUE(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE, 0);
+
+    return p_FmPort->bufferOffsets.dataOffset;
+}
+
+t_FmPrsResult *FM_PORT_GetBufferPrsResult(t_Handle h_FmPort, char *p_Data)
+{
+    t_FmPort                    *p_FmPort = (t_FmPort*)h_FmPort;
+
+    SANITY_CHECK_RETURN_VALUE(p_FmPort, E_INVALID_HANDLE, NULL);
+    SANITY_CHECK_RETURN_VALUE(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE, NULL);
+
+    if(p_FmPort->bufferOffsets.prsResultOffset == 0xFFFFFFFF)
+        return NULL;
+
+    return (t_FmPrsResult *)((uint32_t)p_Data + p_FmPort->bufferOffsets.prsResultOffset);
+}
+
+t_FmTimeStamp *FM_PORT_GetBufferTimeStamp(t_Handle h_FmPort, char *p_Data)
+{
+    t_FmPort                    *p_FmPort = (t_FmPort*)h_FmPort;
+
+    SANITY_CHECK_RETURN_VALUE(p_FmPort, E_INVALID_HANDLE, NULL);
+    SANITY_CHECK_RETURN_VALUE(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE, NULL);
+
+    if(p_FmPort->bufferOffsets.timeStampOffset == 0xFFFFFFFF)
+        return NULL;
+    return (t_FmTimeStamp *)((uint32_t)p_Data + p_FmPort->bufferOffsets.timeStampOffset);
+}
+
+
+void FM_PORT_Disable(t_Handle h_FmPort)
+{
+    t_FmPort                    *p_FmPort = (t_FmPort*)h_FmPort;
+    volatile uint32_t           *p_BmiCfgReg = NULL;
+    volatile uint32_t           *p_BmiStatusReg = NULL;
+    bool                        rxPort = FALSE;
+
+    SANITY_CHECK_RETURN(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
+
+    switch(p_FmPort->portType)
+    {
+        case(e_FM_PORT_TYPE_RX_10G):
+        case(e_FM_PORT_TYPE_RX):
+            p_BmiCfgReg = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rcfg;
+            p_BmiStatusReg = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rst;
+            rxPort = TRUE;
+            break;
+        case(e_FM_PORT_TYPE_TX_10G):
+        case(e_FM_PORT_TYPE_TX):
+             p_BmiCfgReg = &p_FmPort->p_FmPortBmiRegs->txPortBmiRegs.fmbm_tcfg;
+             p_BmiStatusReg = &p_FmPort->p_FmPortBmiRegs->txPortBmiRegs.fmbm_tst;
+            break;
+        case(e_FM_PORT_TYPE_OFFLINE_PARSING):
+        case(e_FM_PORT_TYPE_HOST_COMMAND):
+            p_BmiCfgReg = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ocfg;
+            p_BmiStatusReg = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ost;
+            break;
+        default:
+            break;
+    }
+
+    /* Disable QMI */
+    if (!rxPort && !p_FmPort->imEn)
+    {
+        WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnc,
+                     GET_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnc) & ~QMI_PORT_CFG_EN);
+        /* wait for QMI to finish Handling dequeue tnums */
+        while(GET_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pns) & QMI_PORT_STATUS_DEQ_TNUM_BSY) ;
+        while(GET_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pns) & QMI_PORT_STATUS_DEQ_FD_BSY) ;
+    }
+
+    /* Disable BMI */
+    WRITE_UINT32(*p_BmiCfgReg, GET_UINT32(*p_BmiCfgReg) & ~BMI_PORT_CFG_EN);
+    while(GET_UINT32(*p_BmiStatusReg) & BMI_PORT_STATUS_BSY) ;
+}
+
+void FM_PORT_Enable(t_Handle h_FmPort)
+{
+    t_FmPort                    *p_FmPort = (t_FmPort*)h_FmPort;
+    volatile uint32_t           *p_BmiCfgReg = NULL;
+    bool                        rxPort = FALSE;
+
+    SANITY_CHECK_RETURN(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
+
+    switch(p_FmPort->portType)
+    {
+        case(e_FM_PORT_TYPE_RX_10G):
+        case(e_FM_PORT_TYPE_RX):
+            p_BmiCfgReg = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rcfg;
+            rxPort = TRUE;
+            break;
+        case(e_FM_PORT_TYPE_TX_10G):
+        case(e_FM_PORT_TYPE_TX):
+             p_BmiCfgReg = &p_FmPort->p_FmPortBmiRegs->txPortBmiRegs.fmbm_tcfg;
+            break;
+        case(e_FM_PORT_TYPE_OFFLINE_PARSING):
+        case(e_FM_PORT_TYPE_HOST_COMMAND):
+            p_BmiCfgReg = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ocfg;
+            break;
+        default:
+            break;
+    }
+
+
+    /* Enable QMI */
+    if (!rxPort && !p_FmPort->imEn)
+        WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnc,
+                     GET_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnc) | QMI_PORT_CFG_EN);
+
+    /* Enable BMI */
+    WRITE_UINT32(*p_BmiCfgReg, GET_UINT32(*p_BmiCfgReg) | BMI_PORT_CFG_EN);
+}
+
+t_Error FM_PORT_SetFrameQueueCounters(t_Handle h_FmPort, bool enable)
+{
+    t_FmPort                *p_FmPort = (t_FmPort*)h_FmPort;
+    uint32_t                tmpReg;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
+
+    tmpReg = GET_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnc);
+
+    if(enable)
+        tmpReg |= QMI_PORT_CFG_EN_COUNTERS ;
+    else
+        tmpReg &= ~QMI_PORT_CFG_EN_COUNTERS;
+
+    WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnc, tmpReg);
+
+    return E_OK;
+}
+
+t_Error FM_PORT_SetPerformanceCounters(t_Handle h_FmPort, t_FmPortPerformanceCnt *p_FmPortPerformanceCnt, bool enable)
+{
+    t_FmPort                *p_FmPort = (t_FmPort*)h_FmPort;
+    uint32_t                tmpReg;
+    volatile uint32_t       *p_BmiPcReg = NULL;
+    volatile uint32_t       *p_BmiPcpReg = NULL;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
+
+    switch(p_FmPort->portType)
+    {
+        case(e_FM_PORT_TYPE_RX_10G):
+        case(e_FM_PORT_TYPE_RX):
+            p_BmiPcReg = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rpc;
+            p_BmiPcpReg = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rpcp;
+            break;
+        case(e_FM_PORT_TYPE_TX_10G):
+        case(e_FM_PORT_TYPE_TX):
+            p_BmiPcReg = &p_FmPort->p_FmPortBmiRegs->txPortBmiRegs.fmbm_tpc;
+            p_BmiPcpReg = &p_FmPort->p_FmPortBmiRegs->txPortBmiRegs.fmbm_tpcp;
+            break;
+        case(e_FM_PORT_TYPE_OFFLINE_PARSING):
+        case(e_FM_PORT_TYPE_HOST_COMMAND):
+            p_BmiPcReg = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_opc;
+            p_BmiPcpReg = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_opcp;
+            break;
+        default:
+            break;
+    }
+
+    if(enable)
+    {
+        /* check parameters */
+        if(!p_FmPortPerformanceCnt->taskCompVal || (p_FmPortPerformanceCnt->taskCompVal > MAX_PERFORMANCE_TASK_COMP) )
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("performanceCnt.taskCompVal has to be in the range of 1 - %d", MAX_PERFORMANCE_TASK_COMP));
+        if(!p_FmPortPerformanceCnt->dmaCompVal || (p_FmPortPerformanceCnt->dmaCompVal > MAX_PERFORMANCE_DMA_COMP))
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("performanceCnt.dmaCompVal has to be in the range of 1 - %d", MAX_PERFORMANCE_DMA_COMP));
+        if(!p_FmPortPerformanceCnt->fifoCompVal || (p_FmPortPerformanceCnt->fifoCompVal > BMI_MAX_FIFO_SIZE))
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("performanceCnt.fifoCompVal has to be in the range of 256 - %d", BMI_MAX_FIFO_SIZE));
+        if(p_FmPortPerformanceCnt->fifoCompVal % BMI_FIFO_UNITS)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("performanceCnt.fifoCompVal has to be divisible by %d", BMI_FIFO_UNITS));
+        switch(p_FmPort->portType)
+        {
+            case(e_FM_PORT_TYPE_RX_10G):
+            case(e_FM_PORT_TYPE_RX):
+                if(!p_FmPortPerformanceCnt->queueCompVal || (p_FmPortPerformanceCnt->queueCompVal > MAX_PERFORMANCE_RX_QUEUE_COMP))
+                    RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("performanceCnt.queueCompVal for Rx has to be in the range of 1 - %d", MAX_PERFORMANCE_RX_QUEUE_COMP));
+                break;
+            case(e_FM_PORT_TYPE_TX_10G):
+            case(e_FM_PORT_TYPE_TX):
+                if(!p_FmPortPerformanceCnt->queueCompVal || (p_FmPortPerformanceCnt->queueCompVal > MAX_PERFORMANCE_TX_QUEUE_COMP))
+                    RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("performanceCnt.queueCompVal for Tx has to be in the range of 1 - %d", MAX_PERFORMANCE_TX_QUEUE_COMP));
+                break;
+            case(e_FM_PORT_TYPE_OFFLINE_PARSING):
+            case(e_FM_PORT_TYPE_HOST_COMMAND):
+                if(p_FmPortPerformanceCnt->queueCompVal)
+                    RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("performanceCnt.queueCompVal is not relevant for H/O ports."));
+                break;
+            default:
+                break;
+        }
+
+        tmpReg = 0;
+        tmpReg |= ((p_FmPortPerformanceCnt->queueCompVal - 1) << BMI_PERFORMANCE_PORT_COMP_SHIFT);
+        tmpReg |= ((p_FmPortPerformanceCnt->dmaCompVal- 1) << BMI_PERFORMANCE_DMA_COMP_SHIFT);
+        tmpReg |= ((p_FmPortPerformanceCnt->fifoCompVal/BMI_FIFO_UNITS - 1) << BMI_PERFORMANCE_FIFO_COMP_SHIFT);
+        if ((p_FmPort->portType != e_FM_PORT_TYPE_OFFLINE_PARSING) && (p_FmPort->portType != e_FM_PORT_TYPE_HOST_COMMAND))
+            tmpReg |= ((p_FmPortPerformanceCnt->taskCompVal - 1)  << BMI_PERFORMANCE_TASK_COMP_SHIFT);
+
+        WRITE_UINT32(*p_BmiPcpReg, tmpReg);
+        WRITE_UINT32(*p_BmiPcReg, BMI_COUNTERS_EN);
+    }
+    else
+        WRITE_UINT32(*p_BmiPcReg, 0);
+
+    return E_OK;
+}
+
+t_Error FM_PORT_SetStatisticsCounters(t_Handle h_FmPort, bool enable)
+{
+    t_FmPort                *p_FmPort = (t_FmPort*)h_FmPort;
+    uint32_t                tmpReg;
+    volatile uint32_t       *p_BmiStcReg = NULL;
+
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
+
+    switch(p_FmPort->portType)
+    {
+        case(e_FM_PORT_TYPE_RX_10G):
+        case(e_FM_PORT_TYPE_RX):
+            p_BmiStcReg = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rstc;
+            break;
+        case(e_FM_PORT_TYPE_TX_10G):
+        case(e_FM_PORT_TYPE_TX):
+            p_BmiStcReg = &p_FmPort->p_FmPortBmiRegs->txPortBmiRegs.fmbm_tstc;
+            break;
+        case(e_FM_PORT_TYPE_OFFLINE_PARSING):
+        case(e_FM_PORT_TYPE_HOST_COMMAND):
+            p_BmiStcReg = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ostc;
+            break;
+        default:
+            break;
+    }
+
+    tmpReg = GET_UINT32(*p_BmiStcReg);
+
+    if(enable)
+        tmpReg |= BMI_COUNTERS_EN;
+    else
+        tmpReg &= ~BMI_COUNTERS_EN;
+
+    WRITE_UINT32(*p_BmiStcReg, tmpReg);
+
+    return E_OK;
+}
+
+t_Error FM_PORT_SetErrorsRoute(t_Handle h_FmPort,  fmPortFrameErrSelect_t errs)
+{
+    t_FmPort                *p_FmPort = (t_FmPort*)h_FmPort;
+    volatile uint32_t       *p_ErrQReg, *p_ErrDiscard;
+
+    switch(p_FmPort->portType)
+    {
+        case(e_FM_PORT_TYPE_RX_10G):
+        case(e_FM_PORT_TYPE_RX):
+            p_ErrQReg = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfsem;
+            p_ErrDiscard = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfsdm;
+            break;
+        case(e_FM_PORT_TYPE_OFFLINE_PARSING):
+            p_ErrQReg = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofsem;
+            p_ErrDiscard = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofsdm;
+            break;
+        default:
+           RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx and offline parsing ports only"));
+    }
+
+    if(GET_UINT32(*p_ErrDiscard) & errs)
+        RETURN_ERROR(MAJOR, E_INVALID_SELECTION, ("Selectd Errors that were configured to cause frame discard."));
+
+    WRITE_UINT32(*p_ErrQReg, errs);
+
+    return E_OK;
+}
+
+t_Error FM_PORT_SetEnAllocBufCounter(t_Handle h_FmPort, uint8_t poolId, bool enable)
+{
+    t_FmPort                *p_FmPort = (t_FmPort*)h_FmPort;
+    uint32_t                tmpReg;
+    int                     i;
+
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(poolId<MAX_NUM_OF_EXT_POOLS, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
+
+    if((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_RX))
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx ports only"));
+
+    for(i=0 ; i< FM_PORT_MAX_NUM_OF_EXT_POOLS ; i++)
+    {
+        tmpReg = GET_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_ebmpi[i]);
+        if ((uint8_t)((tmpReg & BMI_EXT_BUF_POOL_ID_MASK) >> BMI_EXT_BUF_POOL_ID_SHIFT) == poolId)
+        {
+            if(enable)
+                tmpReg |= BMI_EXT_BUF_POOL_EN_COUNTER;
+            else
+                tmpReg &= ~BMI_EXT_BUF_POOL_EN_COUNTER;
+            WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_ebmpi[i], tmpReg);
+            break;
+        }
+    }
+    if (i == FM_PORT_MAX_NUM_OF_EXT_POOLS)
+        RETURN_ERROR(MINOR, E_INVALID_VALUE,("poolId %d is not included in this ports pools", poolId));
+
+
+    return E_OK;
+}
+
+uint32_t FM_PORT_GetCounter(t_Handle h_FmPort, e_FmPortCounters counter)
+{
+    t_FmPort            *p_FmPort = (t_FmPort*)h_FmPort;
+    bool                bmiCounter = FALSE;
+    volatile uint32_t   *p_Reg;
+
+    SANITY_CHECK_RETURN_VALUE(p_FmPort, E_INVALID_HANDLE, 0);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
+
+    switch(counter)
+    {
+        case(e_FM_PORT_COUNTERS_DEQ_TOTAL):
+        case(e_FM_PORT_COUNTERS_DEQ_FROM_DEFAULT):
+        case(e_FM_PORT_COUNTERS_DEQ_CONFIRM ):
+            /* check that counter is available for the port type */
+            if((p_FmPort->portType == e_FM_PORT_TYPE_RX) || (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
+            {
+                REPORT_ERROR(MINOR, E_INVALID_STATE, ("Requested counter is not available for Rx ports"));
+                return 0;
+            }
+            bmiCounter = FALSE;
+        case(e_FM_PORT_COUNTERS_ENQ_TOTAL):
+            bmiCounter = FALSE;
+        break;
+        default: /* BMI counters (or error - will be checked in BMI routine )*/
+            bmiCounter = TRUE;
+            break;
+    }
+
+    if(bmiCounter)
+    {
+        switch(p_FmPort->portType)
+        {
+            case(e_FM_PORT_TYPE_RX_10G):
+            case(e_FM_PORT_TYPE_RX):
+                if(BmiRxPortCheckAndGetCounterPtr(p_FmPort, counter, &p_Reg))
+                {
+                    REPORT_ERROR(MINOR, E_INVALID_STATE, NO_MSG);
+                    return 0;
+                }
+                break;
+            case(e_FM_PORT_TYPE_TX_10G):
+            case(e_FM_PORT_TYPE_TX):
+                if(BmiTxPortCheckAndGetCounterPtr(p_FmPort, counter, &p_Reg))
+                {
+                    REPORT_ERROR(MINOR, E_INVALID_STATE, NO_MSG);
+                    return 0;
+                }
+                break;
+            case(e_FM_PORT_TYPE_OFFLINE_PARSING):
+            case(e_FM_PORT_TYPE_HOST_COMMAND):
+                if(BmiOhPortCheckAndGetCounterPtr(p_FmPort, counter, &p_Reg))
+                {
+                    REPORT_ERROR(MINOR, E_INVALID_STATE, NO_MSG);
+                    return 0;
+                }
+            default:
+                REPORT_ERROR(MINOR, E_INVALID_STATE, ("Unsupported port type"));
+                return 0;
+                break;
+        }
+        return GET_UINT32(*p_Reg);
+    }
+    else /* QMI counter */
+    {
+
+        /* check that counters are enabled */
+        if(!(GET_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnc) & QMI_PORT_CFG_EN_COUNTERS))
+        {
+            REPORT_ERROR(MINOR, E_INVALID_STATE, ("Requested counter was not enabled"));
+            return 0;
+        }
+
+        /* Set counter */
+        switch(counter)
+        {
+           case(e_FM_PORT_COUNTERS_ENQ_TOTAL):
+                return GET_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnetfc);
+            break;
+            case(e_FM_PORT_COUNTERS_DEQ_TOTAL):
+                return GET_UINT32(p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs.fmqm_pndtfc);
+            break;
+            case(e_FM_PORT_COUNTERS_DEQ_FROM_DEFAULT):
+                return GET_UINT32(p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs.fmqm_pndfdc);
+            break;
+            case(e_FM_PORT_COUNTERS_DEQ_CONFIRM):
+                return GET_UINT32(p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs.fmqm_pndcc);
+            break;
+            default:
+                REPORT_ERROR(MINOR, E_INVALID_STATE, ("Requested counter is not available"));
+                return 0;
+                break;
+        }
+    }
+}
+
+t_Error FM_PORT_SetCounter(t_Handle h_FmPort, e_FmPortCounters counter, uint32_t value)
+{
+    t_FmPort            *p_FmPort = (t_FmPort*)h_FmPort;
+    bool                bmiCounter = FALSE;
+    volatile uint32_t   *p_Reg;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
+
+    switch(counter)
+    {
+        case(e_FM_PORT_COUNTERS_DEQ_TOTAL):
+        case(e_FM_PORT_COUNTERS_DEQ_FROM_DEFAULT):
+        case(e_FM_PORT_COUNTERS_DEQ_CONFIRM ):
+            /* check that counter is available for the port type */
+            if((p_FmPort->portType == e_FM_PORT_TYPE_RX) || (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
+                        RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter is not available for Rx ports"));
+        case(e_FM_PORT_COUNTERS_ENQ_TOTAL):
+            bmiCounter = FALSE;
+        break;
+        default: /* BMI counters (or error - will be checked in BMI routine )*/
+            bmiCounter = TRUE;
+            break;
+    }
+
+    if(bmiCounter)
+    {
+        switch(p_FmPort->portType)
+        {
+            case(e_FM_PORT_TYPE_RX_10G):
+            case(e_FM_PORT_TYPE_RX):
+               if(BmiRxPortCheckAndGetCounterPtr(p_FmPort, counter, &p_Reg))
+                    RETURN_ERROR(MINOR, E_INVALID_STATE, NO_MSG);
+                break;
+            case(e_FM_PORT_TYPE_TX_10G):
+            case(e_FM_PORT_TYPE_TX):
+               if(BmiTxPortCheckAndGetCounterPtr(p_FmPort, counter, &p_Reg))
+                    RETURN_ERROR(MINOR, E_INVALID_STATE, NO_MSG);
+                break;
+            case(e_FM_PORT_TYPE_OFFLINE_PARSING):
+            case(e_FM_PORT_TYPE_HOST_COMMAND):
+               if(BmiOhPortCheckAndGetCounterPtr(p_FmPort, counter, &p_Reg))
+                    RETURN_ERROR(MINOR, E_INVALID_STATE, NO_MSG);
+                 break;
+            default:
+               RETURN_ERROR(MINOR, E_INVALID_STATE, ("Unsupported port type"));
+        }
+        WRITE_UINT32(*p_Reg, value);
+    }
+    else /* QMI counter */
+    {
+
+        /* check that counters are enabled */
+        if(!(GET_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnc) & QMI_PORT_CFG_EN_COUNTERS))
+                RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter was not enabled"));
+
+        /* Set counter */
+        switch(counter)
+        {
+           case(e_FM_PORT_COUNTERS_ENQ_TOTAL):
+                WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnetfc, value);
+            break;
+            case(e_FM_PORT_COUNTERS_DEQ_TOTAL):
+                WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs.fmqm_pndtfc, value);
+            break;
+            case(e_FM_PORT_COUNTERS_DEQ_FROM_DEFAULT):
+                WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs.fmqm_pndfdc, value);
+            break;
+            case(e_FM_PORT_COUNTERS_DEQ_CONFIRM):
+                WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs.fmqm_pndcc, value);
+            break;
+            default:
+                RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter is not available"));
+                break;
+        }
+    }
+    return E_OK;
+}
+
+uint32_t FM_PORT_GetAllocBufCounter(t_Handle h_FmPort, uint8_t poolId)
+{
+    t_FmPort        *p_FmPort = (t_FmPort*)h_FmPort;
+    uint32_t        extPoolReg;
+    uint8_t         tmpPool;
+    uint8_t         i;
+
+    SANITY_CHECK_RETURN_VALUE(p_FmPort, E_INVALID_HANDLE, 0);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
+
+    if((p_FmPort->portType != e_FM_PORT_TYPE_RX) && (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
+    {
+        REPORT_ERROR(MINOR, E_INVALID_STATE, ("Requested counter is not available for non-Rx ports"));
+        return 0;
+    }
+
+    for(i=0;i<FM_PORT_MAX_NUM_OF_EXT_POOLS;i++)
+    {
+        extPoolReg = GET_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_ebmpi[i]);
+        if (extPoolReg & BMI_EXT_BUF_POOL_VALID)
+        {
+            tmpPool = (uint8_t)((extPoolReg & BMI_EXT_BUF_POOL_ID_MASK) >> BMI_EXT_BUF_POOL_ID_SHIFT);
+            if(tmpPool == poolId)
+            {
+                if(extPoolReg & BMI_EXT_BUF_POOL_EN_COUNTER)
+                    return  GET_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_acnt[i]);
+                else
+                {
+                    REPORT_ERROR(MINOR, E_INVALID_STATE, ("Requested counter is not enabled"));
+                    return 0;
+                }
+            }
+        }
+    }
+    REPORT_ERROR(MINOR, E_INVALID_STATE, ("Pool %d is not used", poolId));
+    return 0;
+}
+
+t_Error FM_PORT_SetAllocBufCounter(t_Handle h_FmPort, uint8_t poolId, uint32_t value)
+{
+    t_FmPort        *p_FmPort = (t_FmPort *)h_FmPort;
+    uint32_t        extPoolReg;
+    uint8_t         tmpPool;
+    uint8_t         i;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
+
+    if((p_FmPort->portType != e_FM_PORT_TYPE_RX) && (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
+        RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter is not available for non-Rx ports"));
+
+
+    for(i=0;i<FM_PORT_MAX_NUM_OF_EXT_POOLS;i++)
+    {
+        extPoolReg = GET_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_ebmpi[i]);
+        if (extPoolReg & BMI_EXT_BUF_POOL_VALID)
+        {
+            tmpPool = (uint8_t)((extPoolReg & BMI_EXT_BUF_POOL_ID_MASK) >> BMI_EXT_BUF_POOL_ID_SHIFT);
+            if(tmpPool == poolId)
+            {
+                if(extPoolReg & BMI_EXT_BUF_POOL_EN_COUNTER)
+                {
+                    WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_acnt[i], value);
+                    return E_OK;
+                }
+                else
+                    RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter is not enabled"));
+            }
+        }
+    }
+    RETURN_ERROR(MINOR, E_INVALID_STATE, ("Pool %d is not used", poolId));
+}
+
+bool FM_PORT_IsStalled(t_Handle h_FmPort)
+{
+    t_FmPort                    *p_FmPort = (t_FmPort*)h_FmPort;
+
+    SANITY_CHECK_RETURN_VALUE(p_FmPort, E_INVALID_HANDLE, FALSE);
+    SANITY_CHECK_RETURN_VALUE(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE, FALSE);
+
+    return FmIsPortStalled(p_FmPort->h_Fm, p_FmPort->hardwarePortId);
+}
+
+t_Error FM_PORT_ReleaseStalled(t_Handle h_FmPort)
+{
+    t_FmPort        *p_FmPort = (t_FmPort*)h_FmPort;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
+
+    return FmResumeStalledPort(p_FmPort->h_Fm, p_FmPort->hardwarePortId);
+}
+
+
+/*       API Run-time PCD Control unit functions        */
+
+
+t_Error FM_PORT_PcdPlcrAllocProfiles(t_Handle h_FmPort, uint16_t numOfProfiles)
+{
+    t_FmPort                    *p_FmPort = (t_FmPort*)h_FmPort;
+    t_Error                     err;
+
+    p_FmPort->h_FmPcd = FmGetPcdHandle(p_FmPort->h_Fm);
+    ASSERT_COND(p_FmPort->h_FmPcd);
+
+    err = FmPcdPlcrAllocProfiles(p_FmPort->h_FmPcd, p_FmPort->hardwarePortId, numOfProfiles);
+    if(err)
+        RETURN_ERROR(MAJOR, err,NO_MSG);
+
+    FmPcdPortRegister(p_FmPort->h_FmPcd, h_FmPort, p_FmPort->hardwarePortId);
+
+    return E_OK;
+}
+
+t_Error FM_PORT_PcdPlcrFreeProfiles(t_Handle h_FmPort)
+{
+    t_FmPort                    *p_FmPort = (t_FmPort*)h_FmPort;
+    t_Error                     err;
+
+    err = FmPcdPlcrFreeProfiles(p_FmPort->h_FmPcd, p_FmPort->hardwarePortId);
+    if(err)
+        RETURN_ERROR(MAJOR, err,NO_MSG);
+    return E_OK;
+}
+
+t_Error            FM_PORT_PcdKgModifyInitialScheme (t_Handle h_FmPort, t_FmPcdKgSchemeSelect *p_FmPcdKgScheme)
+{
+    t_FmPort                *p_FmPort = (t_FmPort*)h_FmPort;
+    volatile uint32_t       *p_BmiHpnia = NULL;
+    uint32_t                tmpReg;
+    uint8_t                 relativeSchemeId;
+    uint8_t                 physicalSchemeId;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->pcdEngines & FM_PCD_KG , E_INVALID_STATE);
+
+
+    tmpReg = (uint32_t)((p_FmPort->pcdEngines & FM_PCD_CC)? NIA_KG_CC_EN:0);
+    switch(p_FmPort->portType)
+    {
+        case(e_FM_PORT_TYPE_RX_10G):
+        case(e_FM_PORT_TYPE_RX):
+            p_BmiHpnia = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfpne;
+            break;
+        case(e_FM_PORT_TYPE_OFFLINE_PARSING):
+            p_BmiHpnia = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofpne;
+            break;
+        default:
+            RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx and offline parsing ports only"));
+    }
+
+    TRY_LOCK_RET_ERR(p_FmPort->lock);
+    /* if we want to change to direct scheme, we need to check that this scheme is valid */
+    if(p_FmPcdKgScheme->direct)
+    {
+        physicalSchemeId = (uint8_t)(CAST_POINTER_TO_UINT32(p_FmPcdKgScheme->h_DirectScheme)-1);
+        /* check that this scheme is bound to this port */
+        if(!(p_FmPort->schemesPerPortVector &  (uint32_t)(1 << (31 - physicalSchemeId))))
+        {
+            RELEASE_LOCK(p_FmPort->lock);
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("called with a scheme that is not bound to this port"));
+        }
+
+        relativeSchemeId = FmPcdKgGetRelativeSchemeId(p_FmPort->h_FmPcd, physicalSchemeId);
+        if(relativeSchemeId == FM_PCD_KG_NUM_OF_SCHEMES)
+        {
+            RELEASE_LOCK(p_FmPort->lock);
+            RETURN_ERROR(MAJOR, E_NOT_IN_RANGE, ("called with invalid Scheme "));
+        }
+
+        if(!FmPcdKgIsSchemeValidSw(p_FmPort->h_FmPcd, relativeSchemeId))
+        {
+            RELEASE_LOCK(p_FmPort->lock);
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("called with uninitialized Scheme "));
+        }
+
+        WRITE_UINT32(*p_BmiHpnia, NIA_ENG_KG | tmpReg | NIA_KG_DIRECT | (uint32_t)physicalSchemeId);
+    }
+    else /* change to indirect scheme */
+        WRITE_UINT32(*p_BmiHpnia, NIA_ENG_KG | tmpReg);
+
+    RELEASE_LOCK(p_FmPort->lock);
+    return E_OK;
+}
+
+t_Error     FM_PORT_PcdPlcrModifyInitialProfile (t_Handle h_FmPort, t_Handle h_Profile)
+{
+    t_FmPort                        *p_FmPort = (t_FmPort*)h_FmPort;
+    volatile uint32_t               *p_BmiNia;
+    volatile uint32_t               *p_BmiHpnia;
+    uint32_t                        tmpReg;
+    uint16_t                        absoluteProfileId = (uint16_t)(CAST_POINTER_TO_UINT32(h_Profile)-1);
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->pcdEngines & FM_PCD_PLCR , E_INVALID_STATE);
+
+    /* check relevancy of this routine  - only when policer is used
+    directly after BMI or Parser */
+    if((p_FmPort->pcdEngines & FM_PCD_KG) || (p_FmPort->pcdEngines & FM_PCD_CC))
+        RETURN_ERROR(MINOR, E_INVALID_STATE, ("relevant only when PCD support mode is e_FM_PCD_SUPPORT_PLCR_ONLY or e_FM_PCD_SUPPORT_PRS_AND_PLCR"));
+
+    switch(p_FmPort->portType)
+    {
+        case(e_FM_PORT_TYPE_RX_10G):
+        case(e_FM_PORT_TYPE_RX):
+            p_BmiNia = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfne;
+            p_BmiHpnia = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfpne;
+            tmpReg = GET_UINT32(*p_BmiNia) & BMI_RFNE_FDCS_MASK;
+            break;
+        case(e_FM_PORT_TYPE_OFFLINE_PARSING):
+            p_BmiNia = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofne;
+            p_BmiHpnia = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofpne;
+            tmpReg = 0;
+            break;
+        default:
+           RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx and offline parsing ports only"));
+    }
+
+    TRY_LOCK_RET_ERR(p_FmPort->lock);
+    if(!FmPcdPlcrIsProfileValid(p_FmPort->h_FmPcd, absoluteProfileId))
+    {
+        RELEASE_LOCK(p_FmPort->lock);
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("Invalid profile"));
+    }
+
+    tmpReg = (uint32_t)(NIA_ENG_PLCR | NIA_PLCR_ABSOLUTE | absoluteProfileId);
+
+    if(p_FmPort->pcdEngines & FM_PCD_PRS) /* e_FM_PCD_SUPPORT_PRS_AND_PLCR */
+    {
+        /* update BMI HPNIA */
+        WRITE_UINT32(*p_BmiHpnia, tmpReg);
+    }
+    else /* e_FM_PCD_SUPPORT_PLCR_ONLY */
+    {
+        /* rfne may contain FDCS bits, so first we read them. */
+        tmpReg |= (GET_UINT32(*p_BmiNia) & BMI_RFNE_FDCS_MASK);
+        /* update BMI NIA */
+        WRITE_UINT32(*p_BmiNia, tmpReg);
+    }
+    RELEASE_LOCK(p_FmPort->lock);
+    return E_OK;
+}
+
+
+t_Error          FM_PORT_PcdCcModifyTree (t_Handle h_FmPort, t_Handle h_CcTree)
+{
+    t_FmPort                            *p_FmPort = (t_FmPort*)h_FmPort;
+    uint32_t                            ccTreePhysOffset;
+    volatile uint32_t                   *p_BmiCcBase=NULL;
+    t_Error                             err;
+    volatile uint32_t                   *p_BmiNia=NULL;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_VALUE);
+
+    if (p_FmPort->imEn)
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for non-independant mode ports only"));
+
+    /* get PCD registers pointers */
+    switch(p_FmPort->portType)
+    {
+        case(e_FM_PORT_TYPE_RX_10G):
+        case(e_FM_PORT_TYPE_RX):
+            p_BmiNia = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfne;
+            break;
+        case(e_FM_PORT_TYPE_OFFLINE_PARSING):
+            p_BmiNia = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofne;
+        break;
+        default:
+            RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx and offline parsing ports only"));
+            break;
+    }
+
+    /* check that current NIA is BMI to BMI */
+    if((GET_UINT32(*p_BmiNia) & ~BMI_RFNE_FDCS_MASK) != (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME))
+            RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("may be called only for ports in BMI-to-BMI state."));
+
+    if(p_FmPort->pcdEngines & FM_PCD_CC)
+    {
+        switch(p_FmPort->portType)
+        {
+            case(e_FM_PORT_TYPE_RX_10G):
+            case(e_FM_PORT_TYPE_RX):
+                p_BmiCcBase = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rccb;
+                break;
+            case(e_FM_PORT_TYPE_OFFLINE_PARSING):
+                p_BmiCcBase = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_occb;
+            break;
+            default:
+                break;
+        }
+
+        TRY_LOCK_RET_ERR(p_FmPort->lock);
+        err = FmPcdCcBindTree(p_FmPort->h_FmPcd, h_CcTree, &ccTreePhysOffset);
+        if(err)
+        {
+            RELEASE_LOCK(p_FmPort->lock);
+            RETURN_ERROR(MINOR, err, NO_MSG);
+        }
+        WRITE_UINT32(*p_BmiCcBase, ccTreePhysOffset);
+
+        p_FmPort->ccTreeId = h_CcTree;
+        RELEASE_LOCK(p_FmPort->lock);
+    }
+    else
+        RETURN_ERROR(MINOR, E_INVALID_STATE, ("Coarse CLassification not defined for this port."));
+
+    return E_OK;
+}
+
+t_Error FM_PORT_AttachPCD(t_Handle h_FmPort)
+{
+
+    t_FmPort        *p_FmPort = (t_FmPort*)h_FmPort;
+    t_Error         err;
+
+    SANITY_CHECK_RETURN_ERROR(h_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
+
+    if (p_FmPort->imEn)
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for non-independant mode ports only"));
+
+   /* may add here checks for:
+        SP (or in sw: schemes)
+        CPP (or in sw clsPlan)
+        Parser enabled and configured(?)
+        Tree(?)
+        Profile - only if direct.
+        Scheme - only if direct */
+
+    TRY_LOCK_RET_ERR(p_FmPort->lock);
+
+    err = FmPortAttachPCD(h_FmPort);
+
+    RELEASE_LOCK(p_FmPort->lock);
+
+    return err;
+}
+
+t_Error FM_PORT_DetachPCD(t_Handle h_FmPort)
+{
+    t_FmPort                            *p_FmPort = (t_FmPort*)h_FmPort;
+    volatile uint32_t                   *p_BmiNia=NULL;
+
+    SANITY_CHECK_RETURN_ERROR(h_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
+
+    if (p_FmPort->imEn)
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for non-independant mode ports only"));
+
+    /* get PCD registers pointers */
+    switch(p_FmPort->portType)
+    {
+        case(e_FM_PORT_TYPE_RX_10G):
+        case(e_FM_PORT_TYPE_RX):
+            p_BmiNia = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfne;
+            break;
+        case(e_FM_PORT_TYPE_OFFLINE_PARSING):
+            p_BmiNia = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofne;
+        break;
+        default:
+            RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx and offline parsing ports only"));
+            break;
+    }
+
+    WRITE_UINT32(*p_BmiNia, (p_FmPort->savedBmiNia & BMI_RFNE_FDCS_MASK) | (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME));
+
+    return E_OK;
+}
+
+t_Error FM_PORT_SetPCD(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParams)
+{
+    t_FmPort                                *p_FmPort = (t_FmPort*)h_FmPort;
+    t_FmPcdKgInterModuleBindPortToSchemes   schemeBind;
+    t_Error                                 err = E_OK;
+    uint8_t                                 i;
+
+    if (p_FmPort->imEn)
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for non-independant mode ports only"));
+
+    TRY_LOCK_RET_ERR(p_FmPort->lock);
+
+    p_FmPort->h_FmPcd = FmGetPcdHandle(p_FmPort->h_Fm);
+    ASSERT_COND(p_FmPort->h_FmPcd);
+
+    err = FmPortSetPcd( h_FmPort, p_PcdParams);
+    if(err)
+    {
+        RELEASE_LOCK(p_FmPort->lock);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
+
+    if(p_FmPort->pcdEngines & FM_PCD_KG)
+    {
+        schemeBind.netEnvId = p_FmPort->netEnvId;
+        schemeBind.hardwarePortId = p_FmPort->hardwarePortId;
+        schemeBind.numOfSchemes = p_PcdParams->p_KgParams->numOfSchemes;
+        schemeBind.useClsPlan = p_PcdParams->p_KgParams->useClsPlan;
+        for(i = 0;i<schemeBind.numOfSchemes;i++)
+            schemeBind.schemesIds[i] = (uint8_t)(CAST_POINTER_TO_UINT32(p_PcdParams->p_KgParams->h_Schemes[i])-1);
+
+        err = FmPcdKgBindPortToSchemes(p_FmPort->h_FmPcd, &schemeBind);
+        if(err)
+        {
+            FmPortDeletePcd(p_FmPort);
+            RELEASE_LOCK(p_FmPort->lock);
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+        }
+
+        err = FmPcdKgBindPortToClsPlanGrp(p_FmPort->h_FmPcd, p_FmPort->hardwarePortId, p_FmPort->clsPlanGrpId);
+        if(err)
+        {
+            FmPortDeletePcd(p_FmPort);
+            FmPcdKgUnbindPortToSchemes(p_FmPort->h_FmPcd, &schemeBind);
+            RELEASE_LOCK(p_FmPort->lock);
+            RETURN_ERROR(MINOR, err, NO_MSG);
+        }
+    }
+
+#ifndef CONFIG_MULTI_PARTITION_SUPPORT
+    if(( p_FmPort->pcdEngines & FM_PCD_PRS) && (p_PcdParams->p_PrsParams->includeInPrsStatistics))
+        FmPcdPrsIncludePortInStatistics(p_FmPort->h_FmPcd, p_FmPort->hardwarePortId, TRUE);
+#endif  /* ! CONFIG_MULTI_PARTITION_SUPPORT */
+
+    FmPcdIncNetEnvOwners(p_FmPort->h_FmPcd, p_FmPort->netEnvId);
+
+    err = FmPortAttachPCD(h_FmPort);
+
+    RELEASE_LOCK(p_FmPort->lock);
+
+    return err;
+}
+
+t_Error FM_PORT_DeletePCD(t_Handle h_FmPort)
+{
+    t_FmPort                                *p_FmPort = (t_FmPort*)h_FmPort;
+    t_FmPcdKgInterModuleBindPortToSchemes   schemeBind;
+    t_Error                                 err = E_OK;
+
+    if(p_FmPort->pcdEngines & FM_PCD_KG)
+    {
+        /* unbind all schemes */
+        p_FmPort->schemesPerPortVector = GetPortSchemeBindParams(p_FmPort, &schemeBind);
+
+        err = FmPcdKgUnbindPortToSchemes(p_FmPort->h_FmPcd, &schemeBind);
+        if(err)
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+
+        FmPcdKgUnbindPortToClsPlanGrp(p_FmPort->h_FmPcd, p_FmPort->hardwarePortId);
+    }
+
+#ifndef CONFIG_MULTI_PARTITION_SUPPORT
+    /* we do it anyway, instead of checking if included */
+    FmPcdPrsIncludePortInStatistics(p_FmPort->h_FmPcd, p_FmPort->hardwarePortId, FALSE);
+#endif  /* ! CONFIG_MULTI_PARTITION_SUPPORT */
+
+    err = FmPortDeletePcd( h_FmPort);
+    if(err)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+
+    FmPcdDecNetEnvOwners(p_FmPort->h_FmPcd, p_FmPort->netEnvId);
+
+    return E_OK;
+}
+
+t_Error FM_PORT_PcdKgModifyClsPlanGrp (t_Handle h_FmPort, bool useClsPlan, t_Handle h_NewClsPlanGrp)
+{
+    t_FmPort            *p_FmPort = (t_FmPort*)h_FmPort;
+    t_Error             err;
+    uint32_t            tmpHxs[FM_PCD_PRS_NUM_OF_HDRS];
+    int                 i = 0;
+    uint8_t             hdrNum;
+    volatile uint32_t   *p_BmiNia=NULL;
+
+    TRY_LOCK_RET_ERR(p_FmPort->lock);
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_VALUE);
+
+    if (p_FmPort->imEn)
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for non-independant mode ports only"));
+
+    /* get PCD registers pointers */
+    switch(p_FmPort->portType)
+    {
+        case(e_FM_PORT_TYPE_RX_10G):
+        case(e_FM_PORT_TYPE_RX):
+            p_BmiNia = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfne;
+            break;
+        case(e_FM_PORT_TYPE_OFFLINE_PARSING):
+            p_BmiNia = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofne;
+        break;
+        default:
+            RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx and offline parsing ports only"));
+            break;
+    }
+
+    /* check that current NIA is BMI to BMI */
+    if((GET_UINT32(*p_BmiNia) & ~BMI_RFNE_FDCS_MASK) != (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME))
+            RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("may be called only for ports in BMI-to-BMI state."));
+
+    /* deal with SW */
+    FmPortPcdKgSwUnbindClsPlanGrp(h_FmPort);
+
+    err = FmPortPcdKgSwBindClsPlanGrp(h_FmPort, useClsPlan, (uint8_t)(CAST_POINTER_TO_UINT32(h_NewClsPlanGrp)-1));
+    if(err)
+    {
+        RELEASE_LOCK(p_FmPort->lock);
+        RETURN_ERROR(MINOR, err, NO_MSG);
+    }
+
+    /* deal with HW */
+    err = FmPcdKgBindPortToClsPlanGrp(p_FmPort->h_FmPcd, p_FmPort->hardwarePortId, p_FmPort->clsPlanGrpId);
+    if(err)
+    {
+        RELEASE_LOCK(p_FmPort->lock);
+        RETURN_ERROR(MINOR, err, NO_MSG);
+    }
+
+    /************************************/
+    /* Parser classification group plan parameters           */
+    /************************************/
+    /* stop before configuring */
+    WRITE_UINT32(p_FmPort->p_FmPortPrsRegs->pcac, PRS_CAC_STOP);
+    /* wait for parser to be in idle state */
+    while(GET_UINT32(p_FmPort->p_FmPortPrsRegs->pcac) & PRS_CAC_ACTIVE) ;
+
+    /* set soft seq attachment register */
+    memset(tmpHxs, 0, FM_PCD_PRS_NUM_OF_HDRS*sizeof(uint32_t));
+
+    /* set protocol options */
+    for(i=0;p_FmPort->optArray[i];i++)
+        switch(p_FmPort->optArray[i])
+        {
+            case(ETH_BROADCAST):
+                GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_ETH)
+                tmpHxs[hdrNum] = GET_UINT32(p_FmPort->p_FmPortPrsRegs->hdrs[hdrNum].softSeqAttach);
+                tmpHxs[hdrNum] &= PRS_HDR_ETH_BC_MASK;
+                tmpHxs[hdrNum] |= (i+1) << PRS_HDR_ETH_BC_SHIFT;
+                break;
+            case(ETH_MULTICAST):
+                GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_ETH)
+                tmpHxs[hdrNum] = GET_UINT32(p_FmPort->p_FmPortPrsRegs->hdrs[hdrNum].softSeqAttach);
+                tmpHxs[hdrNum] &= PRS_HDR_ETH_MC_MASK;
+                tmpHxs[hdrNum] |= (i+1) << PRS_HDR_ETH_MC_SHIFT;
+                break;
+            case(VLAN_STACKED):
+                GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_VLAN)
+                tmpHxs[hdrNum] = GET_UINT32(p_FmPort->p_FmPortPrsRegs->hdrs[hdrNum].softSeqAttach);
+                tmpHxs[hdrNum] &= PRS_HDR_VLAN_STACKED_MASK;
+                tmpHxs[hdrNum] |= (i+1)<< PRS_HDR_VLAN_STACKED_SHIFT;
+                break;
+            case(MPLS_STACKED):
+                GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_MPLS)
+                tmpHxs[hdrNum] = GET_UINT32(p_FmPort->p_FmPortPrsRegs->hdrs[hdrNum].softSeqAttach);
+                tmpHxs[hdrNum] &= PRS_HDR_MPLS_STACKED_MASK;
+                tmpHxs[hdrNum] |= (i+1) << PRS_HDR_MPLS_STACKED_SHIFT;
+                break;
+            case(IPV4_BROADCAST_1):
+                GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_IPv4)
+                tmpHxs[hdrNum] = GET_UINT32(p_FmPort->p_FmPortPrsRegs->hdrs[hdrNum].softSeqAttach);
+                tmpHxs[hdrNum] &= PRS_HDR_IPV4_1_BC_MASK;
+                tmpHxs[hdrNum] |= (i+1) << PRS_HDR_IPV4_1_BC_SHIFT;
+                break;
+            case(IPV4_MULTICAST_1):
+                GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_IPv4)
+                tmpHxs[hdrNum] = GET_UINT32(p_FmPort->p_FmPortPrsRegs->hdrs[hdrNum].softSeqAttach);
+                tmpHxs[hdrNum] &= PRS_HDR_IPV4_1_MC_MASK;
+                tmpHxs[hdrNum] |= (i+1) << PRS_HDR_IPV4_1_MC_SHIFT;
+                break;
+            case(IPV4_UNICAST_2):
+                GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_IPv4)
+                tmpHxs[hdrNum] = GET_UINT32(p_FmPort->p_FmPortPrsRegs->hdrs[hdrNum].softSeqAttach);
+                tmpHxs[hdrNum] &= PRS_HDR_IPV4_2_UC_MASK;
+                tmpHxs[hdrNum] |= (i+1) << PRS_HDR_IPV4_2_UC_SHIFT;
+                break;
+            case(IPV4_MULTICAST_BROADCAST_2):
+                GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_IPv4)
+                tmpHxs[hdrNum] = GET_UINT32(p_FmPort->p_FmPortPrsRegs->hdrs[hdrNum].softSeqAttach);
+                tmpHxs[hdrNum] &= PRS_HDR_IPV4_2_MC_BC_MASK;
+                tmpHxs[hdrNum] |= (i+1) << PRS_HDR_IPV4_2_MC_BC_SHIFT;
+                break;
+            case(IPV6_MULTICAST_1):
+                GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_IPv6)
+                tmpHxs[hdrNum] = GET_UINT32(p_FmPort->p_FmPortPrsRegs->hdrs[hdrNum].softSeqAttach);
+                tmpHxs[hdrNum] &= PRS_HDR_IPV6_1_MC_MASK;
+                tmpHxs[hdrNum] |= (i+1) << PRS_HDR_IPV6_1_MC_SHIFT;
+                break;
+            case(IPV6_UNICAST_2):
+                GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_IPv6)
+                tmpHxs[hdrNum] = GET_UINT32(p_FmPort->p_FmPortPrsRegs->hdrs[hdrNum].softSeqAttach);
+                tmpHxs[hdrNum] &= PRS_HDR_IPV6_2_UC_MASK;
+                tmpHxs[hdrNum] |= (i+1) << PRS_HDR_IPV6_2_UC_SHIFT;
+                break;
+            case(IPV6_MULTICAST_2):
+                GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_IPv6)
+                tmpHxs[hdrNum] = GET_UINT32(p_FmPort->p_FmPortPrsRegs->hdrs[hdrNum].softSeqAttach);
+                tmpHxs[hdrNum] &= PRS_HDR_IPV6_2_MC_MASK;
+                tmpHxs[hdrNum] |= (i+1) << PRS_HDR_IPV6_2_MC_SHIFT;
+                break;
+    }
+
+    for(i=0 ; i<FM_PCD_PRS_NUM_OF_HDRS ; i++)
+    {
+        /* For all header set LCV as taken from netEnv*/
+    //  WRITE_UINT32(p_FmPort->p_FmPortPrsRegs->hdrs[i].lcv,  FmPcdGetLcv(p_FmPort->h_FmPcd, p_FmPort->netEnvId, (uint8_t)i));
+        /* set HXS register according to default+Additional params+protocol options */
+        WRITE_UINT32(p_FmPort->p_FmPortPrsRegs->hdrs[i].softSeqAttach,  tmpHxs[i]);
+    }
+
+    /* enable parser */
+    WRITE_UINT32(p_FmPort->p_FmPortPrsRegs->pcac, 0);
+
+    RELEASE_LOCK(p_FmPort->lock);
+
+    return E_OK;
+}
+
+t_Error  FM_PORT_PcdKgBindSchemes (t_Handle h_FmPort, t_FmPcdPortSchemesParams *p_PortScheme)
+{
+    t_FmPort                                *p_FmPort = (t_FmPort*)h_FmPort;
+    t_FmPcdKgInterModuleBindPortToSchemes   schemeBind;
+    t_Error                                 err;
+    uint32_t                                tmpScmVec=0;
+    int                                     i;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->pcdEngines & FM_PCD_KG , E_INVALID_STATE);
+
+    schemeBind.netEnvId = p_FmPort->netEnvId;
+    schemeBind.hardwarePortId = p_FmPort->hardwarePortId;
+    schemeBind.numOfSchemes = p_PortScheme->numOfSchemes;
+    schemeBind.useClsPlan = p_FmPort->useClsPlan;
+    for (i=0; i<schemeBind.numOfSchemes; i++)
+    {
+        schemeBind.schemesIds[i] = (uint8_t)(CAST_POINTER_TO_UINT32(p_PortScheme->h_Schemes[i])-1);
+        /* build vector */
+        tmpScmVec |= 1 << (31 - schemeBind.schemesIds[i]);
+    }
+
+    TRY_LOCK_RET_ERR(p_FmPort->lock);
+    err = FmPcdKgBindPortToSchemes(p_FmPort->h_FmPcd, &schemeBind);
+    p_FmPort->schemesPerPortVector |= tmpScmVec;
+    RELEASE_LOCK(p_FmPort->lock);
+
+    return err;
+}
+
+t_Error FM_PORT_PcdKgUnbindSchemes (t_Handle h_FmPort, t_FmPcdPortSchemesParams *p_PortScheme)
+{
+    t_FmPort                                *p_FmPort = (t_FmPort*)h_FmPort;
+    t_FmPcdKgInterModuleBindPortToSchemes   schemeBind;
+    t_Error                                 err;
+    uint32_t                                tmpScmVec=0;
+    int                                     i;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->pcdEngines & FM_PCD_KG , E_INVALID_STATE);
+
+    schemeBind.netEnvId = p_FmPort->netEnvId;
+    schemeBind.hardwarePortId = p_FmPort->hardwarePortId;
+    schemeBind.numOfSchemes = p_PortScheme->numOfSchemes;
+    for (i=0; i<schemeBind.numOfSchemes; i++)
+    {
+        schemeBind.schemesIds[i] = (uint8_t)(CAST_POINTER_TO_UINT32(p_PortScheme->h_Schemes[i])-1);
+        /* build vector */
+        tmpScmVec |= 1 << (31 - schemeBind.schemesIds[i]);
+    }
+
+    TRY_LOCK_RET_ERR(p_FmPort->lock);
+    err = FmPcdKgUnbindPortToSchemes(p_FmPort->h_FmPcd, &schemeBind);
+    p_FmPort->schemesPerPortVector &= ~tmpScmVec;
+    RELEASE_LOCK(p_FmPort->lock);
+
+    return err;
+}
+
+t_Error FM_PORT_PcdPrsModifyStartOffset (t_Handle h_FmPort, t_FmPcdPrsStart *p_FmPcdPrsStart)
+{
+    t_FmPort            *p_FmPort = (t_FmPort*)h_FmPort;
+    volatile uint32_t   *p_BmiPrsStartOffset = NULL;
+    volatile uint32_t   *p_BmiNia = NULL;
+    uint8_t             hdrNum;
+    uint32_t            tmpReg;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->pcdEngines & FM_PCD_PRS , E_INVALID_STATE);
+
+    switch(p_FmPort->portType)
+    {
+        case(e_FM_PORT_TYPE_RX_10G):
+        case(e_FM_PORT_TYPE_RX):
+            p_BmiPrsStartOffset = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rpso;
+            p_BmiNia = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfne;
+            tmpReg = GET_UINT32(*p_BmiNia) & BMI_RFNE_FDCS_MASK;
+            break;
+        case(e_FM_PORT_TYPE_OFFLINE_PARSING):
+            p_BmiPrsStartOffset = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_opso;
+            p_BmiNia = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofne;
+            tmpReg = 0;
+            break;
+        default:
+            RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx and offline parsing ports only"));
+    }
+
+    TRY_LOCK_RET_ERR(p_FmPort->lock);
+    /* set the first header */
+    GET_PRS_HDR_NUM(hdrNum, p_FmPcdPrsStart->firstPrsHdr);
+    if (hdrNum == ILLEGAL_HDR_NUM)
+    {
+        RELEASE_LOCK(p_FmPort->lock);
+        RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Unsupported header."));
+    }
+    WRITE_UINT32(*p_BmiNia, (uint32_t)(NIA_ENG_PRS | (uint32_t)(hdrNum * PRS_HDR_ENTRY_SIZE) | tmpReg));
+
+    /* set start parsing offset */
+    WRITE_UINT32(*p_BmiPrsStartOffset, p_FmPcdPrsStart->parsingOffset);
+    RELEASE_LOCK(p_FmPort->lock);
+
+    return E_OK;
+}
+
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+t_Error FM_PORT_DumpRegs(t_Handle h_FmPort)
+{
+    t_FmPort        *p_FmPort = (t_FmPort*)h_FmPort;
+    t_FmPortQmiRegs *p_FmPortQmiRegs;
+    t_Error         err;
+    char            arr[30];
+    uint8_t         flag;
+    int             i=0;
+
+    DECLARE_DUMP;
+
+    SANITY_CHECK_RETURN_ERROR(h_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortQmiRegs, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortBmiRegs, E_INVALID_HANDLE);
+
+    p_FmPortQmiRegs = p_FmPort->p_FmPortQmiRegs;
+
+    switch (p_FmPort->portType)
+    {
+        case (e_FM_PORT_TYPE_OFFLINE_PARSING):
+            strcpy(arr, "PORT_TYPE_OFFLINE_PARSING");
+            flag = 0;
+            break;
+        case (e_FM_PORT_TYPE_HOST_COMMAND):
+            strcpy(arr, "PORT_TYPE_HOST_COMMAND");
+            flag = 0;
+            break;
+        case (e_FM_PORT_TYPE_RX):
+            strcpy(arr, "PORT_TYPE_RX");
+            flag = 1;
+            break;
+        case (e_FM_PORT_TYPE_RX_10G):
+            strcpy(arr, "PORT_TYPE_RX_10G");
+            flag = 1;
+          break;
+        case (e_FM_PORT_TYPE_TX):
+            strcpy(arr, "PORT_TYPE_TX");
+            flag = 2;
+            break;
+        case (e_FM_PORT_TYPE_TX_10G):
+            strcpy(arr, "PORT_TYPE_TX_10G");
+            flag = 2;
+            break;
+        default:
+            return E_INVALID_VALUE;
+            break ;
+    }
+
+    DUMP_TITLE(p_FmPort->hardwarePortId, ("PortId for %s %d", arr, p_FmPort->portId ));
+    DUMP_TITLE(p_FmPort->p_FmPortBmiRegs, ("Bmi Port Regs"));
+
+    err = FmDumpPortRegs(p_FmPort->h_Fm, p_FmPort->hardwarePortId);
+    if(err)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+
+    switch(flag)
+    {
+        case(0):
+
+        DUMP_SUBTITLE(("\n"));
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ocfg);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ost);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_oda);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ofdne);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ofne);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ofca);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ofpne);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_opso);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_opp);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_occb);
+
+        DUMP_TITLE(&(p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_oprai), ("fmbm_oprai"));
+        DUMP_SUBSTRUCT_ARRAY(i, PRS_RESULT_NUM_OF_WORDS)
+        {
+            DUMP_MEMORY(&(p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_oprai[i]), sizeof(uint32_t));
+        }
+        DUMP_SUBTITLE(("\n"));
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ofqid );
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_oefqid);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ofsdm );
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ofsem );
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ofene );
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_orlmts);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_orlmt);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ostc);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ofrc );
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ofdc );
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ofledc);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ofufdc);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_offc);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ofwdc);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ofldec);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_opc);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_opcp);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_occn);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_otuc);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_oduc);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ofuc);
+        break;
+    case(1):
+        DUMP_SUBTITLE(("\n"));
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rcfg);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rst);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rda);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rfp);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rfed);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_ricp);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rebm);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rfne);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rfca);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rfpne);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rpso);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rpp);
+
+        DUMP_TITLE(&(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rprai), ("fmbm_rprai"));
+        DUMP_SUBSTRUCT_ARRAY(i, PRS_RESULT_NUM_OF_WORDS)
+        {
+            DUMP_MEMORY(&(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rprai[i]), sizeof(uint32_t));
+        }
+        DUMP_SUBTITLE(("\n"));
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rfqid);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_refqid);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rfsdm);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rfsem);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rfene);
+        DUMP_TITLE(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_ebmpi, ("fmbm_ebmpi"));
+        DUMP_SUBSTRUCT_ARRAY(i, FM_PORT_MAX_NUM_OF_EXT_POOLS)
+        {
+            DUMP_MEMORY(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_ebmpi[i], sizeof(uint32_t));
+        }
+        DUMP_TITLE(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_acnt, ("fmbm_acnt"));
+        DUMP_SUBSTRUCT_ARRAY(i, FM_PORT_MAX_NUM_OF_EXT_POOLS)
+        {
+            DUMP_MEMORY(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_acnt[i], sizeof(uint32_t));
+        }
+        DUMP_TITLE(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_cgm, ("fmbm_cgm"));
+        DUMP_SUBSTRUCT_ARRAY(i, FM_PORT_NUM_OF_CONGESTION_GRPS/32)
+        {
+            DUMP_MEMORY(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_cgm[i], sizeof(uint32_t));
+        }
+        DUMP_SUBTITLE(("\n"));
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_mpd);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rstc);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rfrc);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rfbc);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rlfc);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rffc);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rfcd);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rfldec);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rodc);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rpc);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rpcp);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rccn);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rtuc);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rrquc);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rduc);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rfuc);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rpac);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rdbg);
+
+        break;
+    case(2):
+
+        DUMP_SUBTITLE(("\n"));
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tcfg);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tst);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tda);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tfp);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tfed);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_ticp);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tfne);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tfca);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tcfqid);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tfeqid);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tfene);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_trlmts);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_trlmt);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tstc);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tfrc);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tfdc);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tfledc);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tfufdc);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tpc);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tpcp);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tccn);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_ttuc);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_ttcquc);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tduc);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tfuc);
+
+        break;
+
+   default:
+        break;
+    }
+
+
+    DUMP_TITLE(p_FmPort->p_FmPortQmiRegs, ("Qmi Port Regs"));
+
+    DUMP_VAR(p_FmPort->p_FmPortQmiRegs,fmqm_pnc);
+    DUMP_VAR(p_FmPort->p_FmPortQmiRegs,fmqm_pns);
+    DUMP_VAR(p_FmPort->p_FmPortQmiRegs,fmqm_pnts);
+    DUMP_VAR(p_FmPort->p_FmPortQmiRegs,fmqm_pnen);
+    DUMP_VAR(p_FmPort->p_FmPortQmiRegs,fmqm_pnetfc);
+
+    if(flag !=1)
+    {
+        DUMP_VAR(&p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs,fmqm_pndn);
+        DUMP_VAR(&p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs,fmqm_pndc);
+        DUMP_VAR(&p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs,fmqm_pndtfc);
+        DUMP_VAR(&p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs,fmqm_pndfdc);
+        DUMP_VAR(&p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs,fmqm_pndcc);
+    }
+
+    return E_OK;
+}
+#endif /* (defined(DEBUG_ERRORS) && ... */
+
+/**********************************        Inter-module routines ********************************/
+
+t_Error FM_PORT_AddCongestionGrps(t_Handle h_FmPort, t_FmPortCongestionGrps *p_CongestionGrps)
+{
+    t_FmPort            *p_FmPort = (t_FmPort*)h_FmPort;
+    t_FmPortRxBmiRegs   *p_Regs = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs;
+    bool                tmpArray[FM_PORT_NUM_OF_CONGESTION_GRPS];
+    int                 i;
+    uint8_t             mod;
+    uint32_t            tmpReg = 0;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+
+    if((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_RX))
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("available for Tx ports only"));
+
+    /* to minimize memory access (groups may belong to the same regsiter, and may
+    be out of order), we first collect all information into a 256 booleans array,
+    representing each possible group. */
+
+    memset(&tmpArray, 0, FM_PORT_NUM_OF_CONGESTION_GRPS*sizeof(bool));
+    for(i=0;i<p_CongestionGrps->numOfCongestionGrpsToConsider;i++)
+        tmpArray[p_CongestionGrps->congestionGrpsToConsider[i]] = TRUE;
+
+    for(i=0;i<FM_PORT_NUM_OF_CONGESTION_GRPS;i++)
+    {
+        mod = (uint8_t)(i%32);
+        /* each 32 congestion groups are represented by a register */
+        if (mod == 0) /* first in a 32 bunch of congestion groups, get the currest register state  */
+            tmpReg = GET_UINT32(p_Regs->fmbm_cgm[7-i/32]);
+
+        /* set in the register, the bit representing the relevant congestion group. */
+        if(tmpArray[i])
+            tmpReg |=  (0x00000001 << mod);
+
+        if (mod == 31) /* last in a 32 bunch of congestion groups - write the corresponding register */
+            WRITE_UINT32(p_Regs->fmbm_cgm[7-i/32], tmpReg);
+    }
+
+    return  E_OK;
+
+}
+
+t_Error FM_PORT_RemoveCongestionGrps(t_Handle h_FmPort, t_FmPortCongestionGrps *p_CongestionGrps)
+{
+    t_FmPort            *p_FmPort = (t_FmPort*)h_FmPort;
+    t_FmPortRxBmiRegs   *p_Regs = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs;
+    bool                tmpArray[FM_PORT_NUM_OF_CONGESTION_GRPS];
+    int                 i;
+    uint8_t             mod;
+    uint32_t            tmpReg = 0;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+
+    if((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_RX))
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("available for Rx ports only"));
+
+    /* to minimize memory access (groups may belong to the same regsiter, and may
+    be out of order), we first collect all information into a 256 booleans array,
+    representing each possible group. */
+    memset(&tmpArray, 0, FM_PORT_NUM_OF_CONGESTION_GRPS*sizeof(bool));
+    for(i=0;i<p_CongestionGrps->numOfCongestionGrpsToConsider;i++)
+        tmpArray[p_CongestionGrps->congestionGrpsToConsider[i]] = TRUE;
+
+    for(i=0;i<FM_PORT_NUM_OF_CONGESTION_GRPS;i++)
+    {
+        mod = (uint8_t)(i%32);
+        /* each 32 congestion groups are represented by a register */
+        if (mod == 0) /* first in a 32 bunch of congestion groups, get the currest register state  */
+            tmpReg = GET_UINT32(p_Regs->fmbm_cgm[7-i/32]);
+
+        /* set in the register, the bit representing the relevant congestion group. */
+        if(tmpArray[i])
+            tmpReg &=  ~(0x00000001 << mod);
+
+       if (mod == 31) /* last in a 32 bunch of congestion groups - write the corresponding register */
+        WRITE_UINT32(p_Regs->fmbm_cgm[7-i/32], tmpReg);
+    }
+
+    return  E_OK;
+
+}
+
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/Port/fm_port.h b/drivers/net/dpa/NetCommSw/Peripherals/FM/Port/fm_port.h
new file mode 100644
index 0000000..3192d41
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/Port/fm_port.h
@@ -0,0 +1,784 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/******************************************************************************
+ @File          fm_port.h
+
+ @Description   FM Port internal structures and definitions.
+*//***************************************************************************/
+#ifndef __FM_PORT_H
+#define __FM_PORT_H
+
+#include "error_ext.h"
+#include "std_ext.h"
+#include "fm_port_ext.h"
+
+#include "fm_common.h"
+
+
+#define MIN_EXT_BUF_SIZE                                64
+/**************************************************************************//**
+ @Description       Memory Map defines
+*//***************************************************************************/
+#define BMI_PORT_REGS_OFFSET                            0
+#define QMI_PORT_REGS_OFFSET                            0x400
+#define PRS_PORT_REGS_OFFSET                            0x800
+
+/**************************************************************************//**
+ @Description       defaults
+*//***************************************************************************/
+
+#define DEFAULT_PORT_deqHighPriority                    FALSE
+#define DEFAULT_PORT_deqType                            e_FM_PORT_DEQ_TYPE1
+#define DEFAULT_PORT_deqPrefetchOption                  e_FM_PORT_DEQ_NO_PREFETCH
+#define DEFAULT_PORT_deqByteCnt                         2000
+#define DEFAULT_PORT_bufferPrefixContent_privDataSize   0
+#define DEFAULT_PORT_bufferPrefixContent_passPrsResult  TRUE
+#define DEFAULT_PORT_bufferPrefixContent_passTimeStamp  FALSE
+
+#define DEFAULT_PORT_cheksumLastBytesIgnore             0
+#define DEFAULT_PORT_cutBytesFromEnd                    4
+#define DEFAULT_PORT_txFifoMinFillLevel                 0
+#define DEFAULT_PORT_txFifoDeqPipelineDepth_1G          1
+#define DEFAULT_PORT_txFifoDeqPipelineDepth_10G         4
+#define DEFAULT_PORT_txFifoLowComfLevel                 (5*KILOBYTE)
+#define DEFAULT_PORT_rxFifoPriElevationLevel            (160*KILOBYTE)
+#define DEFAULT_PORT_rxFifoThreshold                    (128*KILOBYTE)
+#define DEFAULT_PORT_frmDiscardOverride                 FALSE
+#define DEFAULT_PORT_dmaSwapData                        e_FM_PORT_DMA_NO_SWP
+#define DEFAULT_PORT_dmaIntContextCacheAttr             e_FM_PORT_DMA_NO_STASH
+#define DEFAULT_PORT_dmaHeaderCacheAttr                 e_FM_PORT_DMA_NO_STASH
+#define DEFAULT_PORT_dmaScatterGatherCacheAttr          e_FM_PORT_DMA_NO_STASH
+#define DEFAULT_PORT_dmaReadOptimize                    FALSE
+#define DEFAULT_PORT_dmaWriteOptimize                   FALSE
+#define DEFAULT_PORT_forwardIntContextReuse             FALSE
+#define DEFAULT_PORT_l4Checksum                         TRUE
+#define DEFAULT_PORT_BufMargins_startMargins            32
+#define DEFAULT_PORT_BufMargins_endMargins              0
+#define DEFAULT_PORT_syncReq                            TRUE
+#define DEFAULT_PORT_color                              e_FM_PORT_COLOR_GREEN
+#define DEFAULT_PORT_errorsToDiscard                    0
+
+/* Host command port MUST NOT be changed to more than 1 !!! */
+#define DEFAULT_PORT_numOfTasks(type)                   \
+    (uint32_t)(((type == e_FM_PORT_TYPE_RX_10G) ||      \
+                (type == e_FM_PORT_TYPE_TX_10G)) ? 16 : \
+               (((type == e_FM_PORT_TYPE_RX) ||         \
+                 (type == e_FM_PORT_TYPE_TX) ||         \
+                 (type == e_FM_PORT_TYPE_OFFLINE_PARSING)) ? 3 : 1))
+
+#define DEFAULT_PORT_extraNumOfTasks(type)              \
+    (uint32_t)(((type == e_FM_PORT_TYPE_RX_10G) ||      \
+                (type == e_FM_PORT_TYPE_TX_10G)) ? 8 :  \
+               (((type == e_FM_PORT_TYPE_RX) ||         \
+                 (type == e_FM_PORT_TYPE_TX) ||         \
+                 (type == e_FM_PORT_TYPE_OFFLINE_PARSING)) ? 2 : 0))
+
+#define DEFAULT_PORT_numOfOpenDmas(type)                \
+    (uint32_t)(((type == e_FM_PORT_TYPE_RX_10G) ||      \
+                (type == e_FM_PORT_TYPE_TX_10G)) ? 4 : 1)
+
+#define DEFAULT_PORT_extraNumOfOpenDmas(type)           \
+    (uint32_t)(((type == e_FM_PORT_TYPE_RX_10G) ||      \
+                (type == e_FM_PORT_TYPE_TX_10G)) ? 8 :  \
+               (((type == e_FM_PORT_TYPE_RX) ||         \
+                 (type == e_FM_PORT_TYPE_TX) ||         \
+                 (type == e_FM_PORT_TYPE_OFFLINE_PARSING)) ? 1 : 0))
+
+#define DEFAULT_PORT_sizeOfFifo(type)                               \
+    (uint32_t)(((type == e_FM_PORT_TYPE_RX_10G) ||                  \
+                (type == e_FM_PORT_TYPE_TX_10G)) ? (16*KILOBYTE) :  \
+               (((type == e_FM_PORT_TYPE_RX) ||                     \
+                 (type == e_FM_PORT_TYPE_TX) ||                     \
+                 (type == e_FM_PORT_TYPE_OFFLINE_PARSING)) ? (4*KILOBYTE) : (1*KILOBYTE)))
+
+#define DEFAULT_PORT_extraSizeOfFifo(type)              \
+    (uint32_t)(((type == e_FM_PORT_TYPE_RX_10G) ||      \
+                (type == e_FM_PORT_TYPE_RX)) ? (16*KILOBYTE) : 0)
+
+#define DEFAULT_PORT_ImMaxRxBufLength               1024
+#define DEFAULT_PORT_txBdRingLength                 16
+#define DEFAULT_PORT_rxBdRingLength                 128
+#define DEFAULT_PORT_ImfwExtStructsMemId            0
+#define DEFAULT_PORT_Im_fwExtStructsMemAttr         MEMORY_ATTR_CACHEABLE
+
+
+/**************************************************************************//**
+ @Description       Memory Mapped Registers
+*//***************************************************************************/
+
+#ifdef __MWERKS__
+#pragma pack(push,1)
+#endif /*__MWERKS__ */
+#define MEM_MAP_START
+
+typedef _Packed struct
+{
+    volatile uint32_t   fmbm_rcfg;      /**< Rx Configuration */
+    volatile uint32_t   fmbm_rst;       /**< Rx Status */
+    volatile uint32_t   fmbm_rda;       /**< Rx DMA attributes*/
+    volatile uint32_t   fmbm_rfp;       /**< Rx FIFO Parameters*/
+    volatile uint32_t   fmbm_rfed;      /**< Rx Frame End Data*/
+    volatile uint32_t   fmbm_ricp;      /**< Rx Internal Context Parameters*/
+    volatile uint32_t   fmbm_rim;       /**< Rx Internal Buffer Margins*/
+    volatile uint32_t   fmbm_rebm;      /**< Rx External Buffer Margins*/
+    volatile uint32_t   fmbm_rfne;      /**< Rx Frame Next Engine*/
+    volatile uint32_t   fmbm_rfca;      /**< Rx Frame Command Attributes.*/
+    volatile uint32_t   fmbm_rfpne;     /**< Rx Frame Parser Next Engine*/
+    volatile uint32_t   fmbm_rpso;      /**< Rx Parse Start Offset*/
+    volatile uint32_t   fmbm_rpp;       /**< Rx Policer Profile  */
+    volatile uint32_t   fmbm_rccb;      /**< Rx Coarse Classification Base */
+    volatile uint32_t   reserved1[2];   /**< (0x038 0x03F) */
+    volatile uint32_t   fmbm_rprai[PRS_RESULT_NUM_OF_WORDS];
+                                        /**< Rx Parse Results Array Initialization*/
+    volatile uint32_t   fmbm_rfqid;     /**< Rx Frame Queue ID*/
+    volatile uint32_t   fmbm_refqid;    /**< Rx Error Frame Queue ID*/
+    volatile uint32_t   fmbm_rfsdm;     /**< Rx Frame Status Discard Mask*/
+    volatile uint32_t   fmbm_rfsem;     /**< Rx Frame Status Error Mask*/
+    volatile uint32_t   fmbm_rfene;     /**< Rx Frame Enqueue Next Engine */
+    volatile uint32_t   reserved2[0x23];/**< (0x074 0x0FF)  */
+    volatile uint32_t   fmbm_ebmpi[FM_PORT_MAX_NUM_OF_EXT_POOLS];
+                                        /**< Buffer Manager pool Information-*/
+    volatile uint32_t   fmbm_acnt[FM_PORT_MAX_NUM_OF_EXT_POOLS];
+                                        /**< Allocate Counter-*/
+    volatile uint32_t   reserved3[8];
+                                        /**< 0x140 - 0x15F reserved -*/
+    volatile uint32_t   fmbm_cgm[FM_PORT_NUM_OF_CONGESTION_GRPS/32];
+                                        /**< Congestion Group Map*/
+    volatile uint32_t   fmbm_mpd;       /**< BM Pool Depletion  */
+    volatile uint32_t   reserved4[0x1F];/**< (0x184 0x1FF) */
+    volatile uint32_t   fmbm_rstc;      /**< Rx Statistics Counters*/
+    volatile uint32_t   fmbm_rfrc;      /**< Rx Frame Counter*/
+    volatile uint32_t   fmbm_rfbc;      /**< Rx Bad Frames Counter*/
+    volatile uint32_t   fmbm_rlfc;      /**< Rx Large Frames Counter*/
+    volatile uint32_t   fmbm_rffc;      /**< Rx Filter Frames Counter*/
+    volatile uint32_t   fmbm_rfcd;      /**< Rx Frame Discard Counter*/
+    volatile uint32_t   fmbm_rfldec;    /**< Rx Frames List DMA Error Counter*/
+    volatile uint32_t   fmbm_rodc;      /**< Rx Out of Buffers Discard Counter-*/
+    volatile uint32_t   fmbm_rbdc;      /**< Rx Buffers Deallocate Counter-*/
+    volatile uint32_t   reserved5[0x17];/**< (0x224 0x27F) */
+    volatile uint32_t   fmbm_rpc;       /**< Rx Performance Counters*/
+    volatile uint32_t   fmbm_rpcp;      /**< Rx Performance Count Parameters*/
+    volatile uint32_t   fmbm_rccn;      /**< Rx Cycle Counter*/
+    volatile uint32_t   fmbm_rtuc;      /**< Rx Tasks Utilization Counter*/
+    volatile uint32_t   fmbm_rrquc;     /**< Rx Receive Queue Utilization Counter*/
+    volatile uint32_t   fmbm_rduc;      /**< Rx DMA Utilization Counter*/
+    volatile uint32_t   fmbm_rfuc;      /**< Rx FIFO Utilization Counter*/
+    volatile uint32_t   fmbm_rpac;      /**< Rx Pause Activation Counter-*/
+    volatile uint32_t   reserved6[0x18];/**< (0x2A0 0x2FF) */
+    volatile uint32_t   fmbm_rdbg;      /**< Rx Debug-*/
+} _PackedType t_FmPortRxBmiRegs;
+
+typedef _Packed struct
+{
+    volatile uint32_t   fmbm_tcfg;      /**< Tx Configuration */
+    volatile uint32_t   fmbm_tst;       /**< Tx Status */
+    volatile uint32_t   fmbm_tda;       /**< Tx DMA attributes */
+    volatile uint32_t   fmbm_tfp;       /**< Tx FIFO Parameters */
+    volatile uint32_t   fmbm_tfed;      /**< Tx Frame End Data */
+    volatile uint32_t   fmbm_ticp;      /**< Tx Internal Context Parameters */
+    volatile uint32_t   fmbm_tfne;      /**< Tx Frame Next Engine. */
+    volatile uint32_t   fmbm_tfca;      /**< Tx Frame Command attribute. */
+    volatile uint32_t   fmbm_tcfqid;    /**< Tx Confirmation Frame Queue ID. */
+    volatile uint32_t   fmbm_tfeqid;    /**< Tx Frame Error Queue ID */
+    volatile uint32_t   fmbm_tfene;     /**< Tx Frame Enqueue Next Engine */
+    volatile uint32_t   fmbm_trlmts;    /**< Tx Rate Limiter Scale */
+    volatile uint32_t   fmbm_trlmt;     /**< Tx Rate Limiter */
+    volatile uint32_t   reserved0[0x73];/**< (0x038-0x200) */
+    volatile uint32_t   fmbm_tstc;      /**< Tx Statistics Counters */
+    volatile uint32_t   fmbm_tfrc;      /**< Tx Frame Counter */
+    volatile uint32_t   fmbm_tfdc;      /**< Tx Frames Discard Counter */
+    volatile uint32_t   fmbm_tfledc;    /**< Tx Frame Length error discard counter */
+    volatile uint32_t   fmbm_tfufdc;    /**< Tx Frame unsupported format discard Counter */
+    volatile uint32_t   fmbm_tbdc;      /**< Tx Buffers Deallocate Counter */
+    volatile uint32_t   reserved1[0x1A];/**< (0x218-0x280) */
+    volatile uint32_t   fmbm_tpc;       /**< Tx Performance Counters*/
+    volatile uint32_t   fmbm_tpcp;      /**< Tx Performance Count Parameters*/
+    volatile uint32_t   fmbm_tccn;      /**< Tx Cycle Counter*/
+    volatile uint32_t   fmbm_ttuc;      /**< Tx Tasks Utilization Counter*/
+    volatile uint32_t   fmbm_ttcquc;    /**< Tx Transmit Confirm Queue Utilization Counter*/
+    volatile uint32_t   fmbm_tduc;      /**< Tx DMA Utilization Counter*/
+    volatile uint32_t   fmbm_tfuc;      /**< Tx FIFO Utilization Counter*/
+} _PackedType t_FmPortTxBmiRegs;
+
+typedef _Packed struct
+{
+    volatile uint32_t   fmbm_ocfg;      /**< O/H Configuration  */
+    volatile uint32_t   fmbm_ost;       /**< O/H Status */
+    volatile uint32_t   fmbm_oda;       /**< O/H DMA attributes  */
+    volatile uint32_t   fmbm_oicp;      /**< O/H Internal Context Parameters  */
+    volatile uint32_t   fmbm_ofdne;     /**< O/H Frame Dequeue Next Engine  */
+    volatile uint32_t   fmbm_ofne;      /**< O/H Frame Next Engine  */
+    volatile uint32_t   fmbm_ofca;      /**< O/H Frame Command Attributes.  */
+    volatile uint32_t   fmbm_ofpne;     /**< O/H Frame Parser Next Engine  */
+    volatile uint32_t   fmbm_opso;      /**< O/H Parse Start Offset  */
+    volatile uint32_t   fmbm_opp;       /**< O/H Policer Profile */
+    volatile uint32_t   fmbm_occb;      /**< O/H Coarse Classification base */
+    volatile uint32_t   fmbm_oim;       /**< O/H Internal margins*/
+    volatile uint32_t   reserved0[4];   /**< (0x030 - 0x03F) */
+    volatile uint32_t   fmbm_oprai[PRS_RESULT_NUM_OF_WORDS];
+                                        /**< O/H Parse Results Array Initialization  */
+    volatile uint32_t   fmbm_ofqid;     /**< O/H Frame Queue ID  */
+    volatile uint32_t   fmbm_oefqid;    /**< O/H Error Frame Queue ID  */
+    volatile uint32_t   fmbm_ofsdm;     /**< O/H Frame Status Discard Mask  */
+    volatile uint32_t   fmbm_ofsem;     /**< O/H Frame Status Error Mask  */
+    volatile uint32_t   fmbm_ofene;     /**< O/H Frame Enqueue Next Engine  */
+    volatile uint32_t   fmbm_orlmts;    /**< O/H Rate Limiter Scale  */
+    volatile uint32_t   fmbm_orlmt;     /**< O/H Rate Limiter  */
+    volatile uint32_t   reserved1[0x61];/**< (0x07C - 0x1FF) */
+    volatile uint32_t   fmbm_ostc;      /**< O/H Statistics Counters  */
+    volatile uint32_t   fmbm_ofrc;      /**< O/H Frame Counter  */
+    volatile uint32_t   fmbm_ofdc;      /**< O/H Frames Discard Counter  */
+    volatile uint32_t   fmbm_ofledc;    /**< O/H Frames Length Error Discard Counter  */
+    volatile uint32_t   fmbm_ofufdc;    /**< O/H Frames Unsupported Format Discard Counter  */
+    volatile uint32_t   fmbm_offc;      /**< O/H Filter Frames Counter  */
+    volatile uint32_t   fmbm_ofwdc;     /**< - Rx Frames WRED Discard Counter  */
+    volatile uint32_t   fmbm_ofldec;    /**< O/H Frames List DMA Error Counter */
+    volatile uint32_t   fmbm_obdc;      /**< O/H Buffers Deallocate Counter */
+    volatile uint32_t   reserved2[0x17];/**< (0x218 - 0x27F) */
+    volatile uint32_t   fmbm_opc;       /**< O/H Performance Counters  */
+    volatile uint32_t   fmbm_opcp;      /**< O/H Performance Count Parameters  */
+    volatile uint32_t   fmbm_occn;      /**< O/H Cycle Counter  */
+    volatile uint32_t   fmbm_otuc;      /**< O/H Tasks Utilization Counter  */
+    volatile uint32_t   fmbm_oduc;      /**< O/H DMA Utilization Counter */
+    volatile uint32_t   fmbm_ofuc;      /**< O/H FIFO Utilization Counter */
+} _PackedType t_FmPortOhBmiRegs;
+
+typedef _Packed union
+{
+    t_FmPortRxBmiRegs rxPortBmiRegs;
+    t_FmPortTxBmiRegs txPortBmiRegs;
+    t_FmPortOhBmiRegs ohPortBmiRegs;
+} _PackedType u_FmPortBmiRegs;
+
+typedef _Packed struct
+{
+    volatile uint32_t   reserved1[2];   /**<   0xn024 - 0x02B */
+    volatile uint32_t   fmqm_pndn;      /**<   PortID n Dequeue NIA Register */
+    volatile uint32_t   fmqm_pndc;      /**<   PortID n Dequeue Config Register */
+    volatile uint32_t   fmqm_pndtfc;    /**<   PortID n Dequeue Total Frame Counter */
+    volatile uint32_t   fmqm_pndfdc;    /**<   PortID n Dequeue FQID from Default Counter */
+    volatile uint32_t   fmqm_pndcc;     /**<   PortID n Dequeue Confirm Counter */
+} _PackedType t_FmPortNonRxQmiRegs;
+
+typedef _Packed struct
+{
+    volatile uint32_t   fmqm_pnc;       /**<   PortID n Configuration Register */
+    volatile uint32_t   fmqm_pns;       /**<   PortID n Status Register */
+    volatile uint32_t   fmqm_pnts;      /**<   PortID n Task Status Register */
+    volatile uint32_t   reserved0[4];   /**<   0xn00C - 0xn01B */
+    volatile uint32_t   fmqm_pnen;      /**<   PortID n Enqueue NIA Register */
+    volatile uint32_t   fmqm_pnetfc;    /**<   PortID n Enqueue Total Frame Counter */
+    t_FmPortNonRxQmiRegs    nonRxQmiRegs;  /**<   Registers for Tx Hc & Op ports */
+} _PackedType t_FmPortQmiRegs;
+
+typedef _Packed struct
+{
+    struct
+    {
+        volatile uint32_t   softSeqAttach;  /**<   Soft Sequence Attachment */
+        volatile uint32_t   lcv;            /**<   Line-up Enable Confirmation Mask */
+    } hdrs[FM_PCD_PRS_NUM_OF_HDRS];
+    volatile uint8_t    reserved0[0x378];
+    volatile uint32_t   pcac;               /**<   Parse Internal Memory Configuration Access Control Register */
+    volatile uint32_t   pctpid;             /**<   Parse Internal Memory Configured TPID Register */
+} _PackedType t_FmPortPrsRegs;
+
+/**************************************************************************//*
+ @Description   Basic buffer descriptor (BD) structure
+*//***************************************************************************/
+typedef _Packed struct
+{
+    volatile uint16_t       status;
+    volatile uint16_t       length;
+    volatile uint8_t        reserved0[0x6];
+    volatile t_FmPhysAddr   buff;
+} _PackedType t_FmImBd;
+
+typedef _Packed struct
+{
+    volatile uint16_t       gen;                /**< tbd */
+    volatile t_FmPhysAddr   bdRingBase;         /**< tbd */
+    volatile uint16_t       bdRingSize;         /**< tbd */
+    volatile uint16_t       offsetIn;           /**< tbd */
+    volatile uint16_t       offsetOut;          /**< tbd */
+    volatile uint8_t        reserved0[0x12];    /**< 0x0e - 0x1f */
+} _PackedType t_FmPortImQd;
+
+typedef _Packed struct
+{
+    volatile uint32_t   mode;               /**< Mode register */
+    volatile uint32_t   rxQdPtr;            /**< tbd */
+    volatile uint32_t   txQdPtr;            /**< tbd */
+    volatile uint16_t   mrblr;              /**< tbd */
+    volatile uint16_t   rxQdBsyCnt;         /**< tbd */
+    volatile uint8_t    reserved0[0x10];    /**< 0x10 - 0x1f */
+    t_FmPortImQd        rxQd;
+    t_FmPortImQd        txQd;
+    volatile uint8_t    reserved1[0xa0];    /**< 0x10 - 0x1f */
+} _PackedType t_FmPortImPram;
+
+#define MEM_MAP_END
+#ifdef __MWERKS__
+#pragma pack(pop)
+#endif /* __MWERKS__ */
+
+
+/**************************************************************************//**
+ @Description       Registers bit fields
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description       BMI defines
+*//***************************************************************************/
+#define BMI_PORT_CFG_EN                         0x80000000
+#define BMI_PORT_CFG_FDOVR                      0x02000000
+#define BMI_PORT_CFG_IM                         0x01000000
+#define BMI_PORT_STATUS_BSY                     0x80000000
+#define BMI_COUNTERS_EN                         0x80000000
+#define BMI_DMA_ATTR_READ_OPTIMIZE              0x00400000
+#define BMI_DMA_ATTR_WRITE_OPTIMIZE             0x00100000
+#define BMI_PORT_RFNE_FRWD_DCL4C                0x10000000
+#define BMI_PORT_RFNE_FRWD_RPD                  0x40000000
+#define BMI_RFNE_FDCS_MASK                      0xFF000000
+
+#define BMI_CMD_MR_LEAC                         0x00200000
+#define BMI_CMD_MR_SLEAC                        0x00100000
+#define BMI_CMD_MR_MA                           0x00080000
+#define BMI_CMD_MR_DEAS                         0x00040000
+#define BMI_CMD_TX_MR_DEF                       (0)
+#define BMI_CMD_RX_MR_DEF                       (BMI_CMD_MR_LEAC | BMI_CMD_MR_SLEAC | BMI_CMD_MR_MA | BMI_CMD_MR_DEAS)
+#define BMI_CMD_ATTR_ORDER                      0x80000000
+#define BMI_CMD_ATTR_SYNC                       0x02000000
+
+#define BMI_EXT_BUF_POOL_VALID                  0x80000000
+#define BMI_EXT_BUF_POOL_EN_COUNTER             0x40000000
+#define BMI_EXT_BUF_POOL_ID_MASK                0x003F0000
+#define BMI_STATUS_RX_MASK_UNUSED               (uint32_t)(~(FM_PORT_FRM_ERR_DMA|\
+                                                FM_PORT_FRM_ERR_PHYSICAL        |\
+                                                FM_PORT_FRM_ERR_SIZE            |\
+                                                FM_PORT_FRM_ERR_CLS_DISCARD     |\
+                                                FM_PORT_FRM_ERR_EXTRACTION      |\
+                                                FM_PORT_FRM_ERR_NO_SCHEME       |\
+                                                FM_PORT_FRM_ERR_COLOR_RED       |\
+                                                FM_PORT_FRM_ERR_COLOR_YELLOW    |\
+                                                FM_PORT_FRM_ERR_ILL_PLCR        |\
+                                                FM_PORT_FRM_ERR_PLCR_FRAME_LEN  |\
+                                                FM_PORT_FRM_ERR_PRS_TIMEOUT     |\
+                                                FM_PORT_FRM_ERR_PRS_ILL_INSTRUCT|\
+                                                FM_PORT_FRM_ERR_PRS_HDR_ERR     |\
+                                                FM_PORT_FRM_ERR_PROCESS_TIMEOUT |\
+                                                FM_PORT_FRM_ERR_KEYSIZE_OVERFLOW))
+
+#define BMI_STATUS_OP_MASK_UNUSED               (uint32_t)(BMI_STATUS_RX_MASK_UNUSED    &\
+                                                ~(FM_PORT_FRM_ERR_LENGTH                |\
+                                                  FM_PORT_FRM_ERR_UNSUPPORTED_FORMAT))
+
+#define BMI_RATE_LIMIT_EN                       0x80000000
+#define BMI_PRS_RESULT_HIGH                     0x00000000
+#define BMI_PRS_RESULT_LOW                      0xFFFFFFFF
+
+#define RX_ERRS_TO_ENQ                      (FM_PORT_FRM_ERR_DMA             |\
+                                                         FM_PORT_FRM_ERR_PHYSICAL        |\
+                                                         FM_PORT_FRM_ERR_SIZE            |\
+                                                         FM_PORT_FRM_ERR_CLS_DISCARD     |\
+                                                         FM_PORT_FRM_ERR_EXTRACTION      |\
+                                                         FM_PORT_FRM_ERR_NO_SCHEME       |\
+                                                         FM_PORT_FRM_ERR_COLOR_RED       |\
+                                                         FM_PORT_FRM_ERR_ILL_PLCR        |\
+                                                         FM_PORT_FRM_ERR_PLCR_FRAME_LEN  |\
+                                                         FM_PORT_FRM_ERR_PRS_TIMEOUT     |\
+                                                         FM_PORT_FRM_ERR_PRS_ILL_INSTRUCT|\
+                                                         FM_PORT_FRM_ERR_PRS_HDR_ERR     |\
+                                                         FM_PORT_FRM_ERR_PROCESS_TIMEOUT |\
+                                                         FM_PORT_FRM_ERR_KEYSIZE_OVERFLOW)
+
+#define OP_ERRS_TO_ENQ                      (RX_ERRS_TO_ENQ      |\
+                                                         FM_PORT_FRM_ERR_LENGTH          |\
+                                                         FM_PORT_FRM_ERR_UNSUPPORTED_FORMAT)
+
+/* shifts */
+#define BMI_DMA_ATTR_SWP_SHIFT                  30
+#define BMI_DMA_ATTR_IC_CACHE_SHIFT             28
+#define BMI_DMA_ATTR_HDR_CACHE_SHIFT            26
+#define BMI_DMA_ATTR_SG_CACHE_SHIFT             24
+
+#define BMI_RIM_FOF_SHIFT                       28
+#define BMI_PR_PORTID_SHIFT                     24
+
+#define BMI_RX_FIFO_PRI_ELEVATION_SHIFT         16
+#define BMI_RX_FIFO_THRESHOLD_SHIFT             0
+
+#define BMI_RX_FRAME_END_CS_IGNORE_SHIFT        24
+#define BMI_RX_FRAME_END_CUT_SHIFT              16
+
+#define BMI_IC_TO_EXT_SHIFT                     16
+#define BMI_IC_FROM_INT_SHIFT                   8
+#define BMI_IC_SIZE_SHIFT                       0
+
+#define BMI_INT_BUF_MARG_SHIFT                  28
+
+#define BMI_EXT_BUF_MARG_START_SHIFT            16
+#define BMI_EXT_BUF_MARG_END_SHIFT              0
+
+#define BMI_CMD_ATTR_COLOR_SHIFT                26
+#define BMI_CMD_ATTR_COM_MODE_SHIFT             16
+
+#define BMI_POOL_DEP_NUM_OF_POOLS_SHIFT         16
+#define BMI_POOL_DEP_NUM_OF_POOLS_VECTOR_SHIFT  24
+
+#define BMI_EXT_BUF_POOL_ID_SHIFT               16
+
+#define BMI_TX_FIFO_MIN_FILL_SHIFT              16
+#define BMI_TX_FIFO_PIPELINE_DEPTH_SHIFT        12
+#define BMI_TX_LOW_COMF_SHIFT                   0
+
+#define BMI_TX_FRAME_END_CS_IGNORE_SHIFT        24
+
+#define BMI_PERFORMANCE_TASK_COMP_SHIFT         24
+#define BMI_PERFORMANCE_PORT_COMP_SHIFT         16
+#define BMI_PERFORMANCE_DMA_COMP_SHIFT          12
+#define BMI_PERFORMANCE_FIFO_COMP_SHIFT         0
+
+#define BMI_MAX_BURST_SHIFT                     16
+#define BMI_COUNT_RATE_UNIT_SHIFT               16
+
+/* sizes */
+#define FRAME_END_DATA_SIZE                     16
+#define OFFSET_UNITS                            16
+#define FRAME_OFFSET_UNITS                      16
+#define MAX_EXT_OFFSET                          496
+#define MAX_EXT_BUFFER_OFFSET                   511
+#define MAX_INT_OFFSET                          240
+#define MIN_TX_INT_OFFSET                       32
+#define MAX_IC_SIZE                             256
+#define MAX_FRAME_OFFSET                        64
+#define MAX_FIFO_PIPELINE_DEPTH                 8
+#define MAX_PERFORMANCE_TASK_COMP               64
+#define MAX_PERFORMANCE_TX_QUEUE_COMP           8
+#define MAX_PERFORMANCE_RX_QUEUE_COMP           64
+#define MAX_PERFORMANCE_DMA_COMP                16
+#define MAX_NUM_OF_TASKS                        64
+#define MAX_NUM_OF_EXTRA_TASKS                  8
+#define MAX_NUM_OF_DMAS                         16
+#define MAX_NUM_OF_EXTRA_DMAS                   8
+#define MAX_BURST_SIZE                          1024
+
+/**************************************************************************//**
+ @Description       QMI defines
+*//***************************************************************************/
+/* masks */
+#define QMI_PORT_CFG_EN                         0x80000000
+#define QMI_PORT_CFG_EN_COUNTERS                0x10000000
+#define QMI_PORT_STATUS_DEQ_TNUM_BSY            0x80000000
+#define QMI_PORT_STATUS_DEQ_FD_BSY              0x20000000
+
+#define QMI_DEQ_CFG_PREFETCH_NO_TNUM            0x02000000
+#define QMI_DEQ_CFG_PREFETCH_WAITING_TNUM       0
+#define QMI_DEQ_CFG_PREFETCH_1_FRAME            0
+#define QMI_DEQ_CFG_PREFETCH_3_FRAMES           0x01000000
+
+#define QMI_DEQ_CFG_PRI                         0x80000000
+#define QMI_DEQ_CFG_TYPE1                       0x10000000
+#define QMI_DEQ_CFG_TYPE2                       0x20000000
+#define QMI_DEQ_CFG_TYPE3                       0x30000000
+
+#define QMI_DEQ_CFG_SUBPORTAL_SHIFT             20
+
+/* sizes */
+#define MAX_QMI_DEQ_SUBPORTAL                   15
+
+/**************************************************************************//**
+ @Description       PARSER defines
+*//***************************************************************************/
+/* masks */
+#define PRS_HDR_ERROR_DIS                       0x00000800
+#define PRS_HDR_SW_PRS_EN                       0x00000400
+#define PRS_CP_OFFSET_MASK                      0x0000000F
+#define PRS_TPID1_MASK                          0xFFFF0000
+#define PRS_TPID2_MASK                          0x0000FFFF
+#define PRS_TPID_DFLT                           0x91009100
+
+#define PRS_HDR_MPLS_LBL_INTER_EN               0x00200000
+#define PRS_HDR_IPV6_ROUTE_HDR_DIS              0x00008000
+#define PRS_HDR_UDP_PAD_REMOVAL                 0x80000000
+#define PRS_HDR_TCP_PAD_REMOVAL                 0x80000000
+#define PRS_CAC_STOP                            0x00000001
+#define PRS_CAC_ACTIVE                          0x00000100
+
+/* shifts */
+#define PRS_PCTPID_SHIFT                        16
+#define PRS_HDR_MPLS_NEXT_HDR_SHIFT             22
+#define PRS_HDR_ETH_BC_SHIFT                    28
+#define PRS_HDR_ETH_MC_SHIFT                    24
+#define PRS_HDR_VLAN_STACKED_SHIFT              16
+#define PRS_HDR_MPLS_STACKED_SHIFT              16
+#define PRS_HDR_IPV4_1_BC_SHIFT                 28
+#define PRS_HDR_IPV4_1_MC_SHIFT                 24
+#define PRS_HDR_IPV4_2_UC_SHIFT                 20
+#define PRS_HDR_IPV4_2_MC_BC_SHIFT              16
+#define PRS_HDR_IPV6_1_MC_SHIFT                 24
+#define PRS_HDR_IPV6_2_UC_SHIFT                 20
+#define PRS_HDR_IPV6_2_MC_SHIFT                 16
+
+#define PRS_HDR_ETH_BC_MASK                     0x0fffffff
+#define PRS_HDR_ETH_MC_MASK                     0xf0ffffff
+#define PRS_HDR_VLAN_STACKED_MASK               0xfff0ffff
+#define PRS_HDR_MPLS_STACKED_MASK               0xfff0ffff
+#define PRS_HDR_IPV4_1_BC_MASK                  0x0fffffff
+#define PRS_HDR_IPV4_1_MC_MASK                  0xf0ffffff
+#define PRS_HDR_IPV4_2_UC_MASK                  0xff0fffff
+#define PRS_HDR_IPV4_2_MC_BC_MASK               0xfff0ffff
+#define PRS_HDR_IPV6_1_MC_MASK                  0xf0ffffff
+#define PRS_HDR_IPV6_2_UC_MASK                  0xff0fffff
+#define PRS_HDR_IPV6_2_MC_MASK                  0xfff0ffff
+
+/* others */
+#define PRS_HDR_ENTRY_SIZE                      8
+#define DEFAULT_CLS_PLAN_VECTOR                 0xFFFFFFFF
+
+#define IPSEC_SW_PATCH_START                    0x20
+#define SCTP_SW_PATCH_START                     0x4D
+#define DCCP_SW_PATCH_START                     0x41
+
+/**************************************************************************//**
+ @Description       IM defines
+*//***************************************************************************/
+#define BD_R_E                                  0x80000000
+#define BD_L                                    0x08000000
+
+#define BD_RX_CRE                               0x00080000
+#define BD_RX_FTL                               0x00040000
+#define BD_RX_FTS                               0x00020000
+#define BD_RX_OV                                0x00010000
+
+#define BD_RX_ERRORS                            (BD_RX_CRE | BD_RX_FTL | BD_RX_FTS | BD_RX_OV)
+#define BD_ERROR_PASS_FRAME                     BD_RX_ERRORS
+
+#define FM_IM_SIZEOF_BD                         sizeof(t_FmImBd)
+
+#define BD_STATUS_MASK                          0xffff0000
+#define BD_LENGTH_MASK                          0x0000ffff
+
+#define BD_STATUS_AND_LENGTH_SET(bd, val)       WRITE_UINT32(*(volatile uint32_t*)(bd), (val))
+
+#define BD_STATUS_AND_LENGTH(bd)                GET_UINT32(*(volatile uint32_t*)(bd))
+
+#define BD_GET(id)                              &p_FmPort->im.p_BdRing[id]
+
+#define IM_ILEGAL_BD_ID                         0xffff
+
+/* others */
+#define IM_PRAM_ALIGN                           0x100
+
+/* masks */
+#define IM_MODE_GBL                             0x20000000
+
+
+typedef struct {
+    t_Handle                    h_App;
+    t_Handle                    h_FmMuram;
+    t_FmPortImPram              *p_FmPortImPram;
+    uint8_t                     fwExtStructsMemId;
+    uint32_t                    fwExtStructsMemAttr;
+    uint16_t                    bdRingSize;
+    t_FmImBd                    *p_BdRing;
+    t_Handle                    *p_BdShadow;
+    uint16_t                    currBdId;
+    uint16_t                    firstBdOfFrameId;
+
+    /* Rx port parameters */
+    uint8_t                     dataMemId;          /**< Memory partition ID for data buffers */
+    uint32_t                    dataMemAttributes;  /**< Memory attributes for data buffers */
+    t_BufferPoolInfo            rxPool;
+    uint16_t                    mrblr;
+    uint16_t                    rxFrameAccumLength;
+    t_FmPortImRxStoreFunction   *f_RxStoreCB;
+
+    /* Tx port parameters */
+    uint32_t                    txFirstBdStatus;
+    t_FmPortImTxConfFunction    *f_TxConfCB;
+} t_FmMacIm;
+
+/**************************************************************************//**
+ @Description   structure for defining internal context copying
+*//***************************************************************************/
+typedef struct
+{
+    uint16_t    extBufOffset;       /**< Offset in External buffer to which internal
+                                         context is copied to (Rx) or taken from (Tx, Op). */
+    uint8_t     intContextOffset;   /**< Offset within internal context to copy from
+                                         (Rx) or to copy to (Tx, Op). */
+    uint16_t    size;               /**< Internal offset size to be copied */
+} t_FmPortIntContextDataCopy;
+
+/**************************************************************************//**
+ @Description   struct for defining external buffer margins
+*//***************************************************************************/
+typedef struct{
+    uint16_t    startMargins;           /**< Number of bytes to be left at the beginning
+                                             of the external buffer (must be divisible by 16) */
+    uint16_t    endMargins;             /**< number of bytes to be left at the end
+                                             of the external buffer(must be divisible by 16) */
+} t_FmPortBufMargins;
+
+typedef struct{
+    uint32_t      dataOffset;
+    uint32_t      prsResultOffset;
+    uint32_t      timeStampOffset;
+} t_FmPortBufferOffsets;
+
+typedef struct
+{
+    uint32_t                    dfltFqid;
+    uint32_t                    confFqid;
+    uint32_t                    errFqid;
+    uint64_t                    baseAddr;
+    uint8_t                     deqSubPortal;
+    bool                        deqHighPriority;
+    e_FmPortDeqType             deqType;
+    e_FmPortDeqPrefetchOption   deqPrefetchOption;
+    uint16_t                    deqByteCnt;
+    uint8_t                     cheksumLastBytesIgnore;
+    uint8_t                     cutBytesFromEnd;
+    t_FmPortBufPoolDepletion    bufPoolDepletion;
+    uint8_t                     pipelineDepth;
+    uint16_t                    fifoLowComfLevel;
+    bool                        frmDiscardOverride;
+    bool                        enRateLimit;
+    t_FmPortRateLimit           rateLimit;
+    bool                        enBufPoolDepletion;
+    uint8_t                     partitionId;
+    t_FmPortRxExtPools          rxExtBufPools;
+    t_FmPortRsrc                openDmas;
+    t_FmPortRsrc                tasks;
+    t_FmPortRsrc                fifoBufs;
+    e_FmPortDmaSwap             dmaSwapData;
+    e_FmPortDmaCache            dmaIntContextCacheAttr;
+    e_FmPortDmaCache            dmaHeaderCacheAttr;
+    e_FmPortDmaCache            dmaScatterGatherCacheAttr;
+    bool                        dmaReadOptimize;
+    bool                        dmaWriteOptimize;
+    uint32_t                    txFifoMinFillLevel;
+    uint32_t                    txFifoLowComfLevel;
+    uint32_t                    rxFifoPriElevationLevel;
+    uint32_t                    rxFifoThreshold;
+    t_FmPortBufMargins          bufMargins;
+    t_FmPortIntContextDataCopy  intContext;
+    bool                        syncReq;
+    e_FmPortColor               color;
+    fmPortFrameErrSelect_t      errorsToDiscard;
+    fmPortFrameErrSelect_t      errorsToEnq;
+    uint32_t                    timeStampPeriod;
+    uint64_t                    fmMuramPhysBaseAddr;
+    bool                        forwardReuseIntContext;
+    bool                        l4Checksum;
+    t_FmPortBufferPrefixContent bufferPrefixContent;
+#ifdef VERIFICATION_SUPPORT
+    bool                        intContextConfigured;
+#endif
+}t_FmPortDriverParam;
+
+typedef struct
+{
+    t_Handle                    h_Fm;
+    t_Handle                    h_FmPcd;
+    uint8_t                     portId;
+    e_FmPortType                portType;
+    uint8_t                     hardwarePortId;
+    uint16_t                    fmClkFreq;
+    t_FmPortQmiRegs             *p_FmPortQmiRegs;
+    u_FmPortBmiRegs             *p_FmPortBmiRegs;
+    t_FmPortPrsRegs             *p_FmPortPrsRegs;
+    fmPcdEngines_t              pcdEngines;
+    uint32_t                    savedBmiNia;
+    uint8_t                     netEnvId;
+    uint32_t                    optArray[MAX_NUM_OF_OPTIONS];
+    uint32_t                    lcvs[FM_PCD_PRS_NUM_OF_HDRS];
+    uint8_t                     privateInfo;
+    uint32_t                    schemesPerPortVector;
+    bool                        useClsPlan;
+    uint8_t                     clsPlanGrpId;
+    t_Handle                    ccTreeId;
+    t_Handle                    completeArg;
+    void                        (*f_Complete)(t_Handle arg);
+    t_FmPortBufferOffsets       bufferOffsets;
+    /* Independent-Mode parameters support */
+    bool                        imEn;
+    t_FmMacIm                   im;
+    uint8_t                     txFifoDeqPipelineDepth;
+    t_FmPortDriverParam         *p_FmPortDriverParam;
+    volatile bool               lock;
+} t_FmPort;
+
+#ifndef CONFIG_MULTI_PARTITION_SUPPORT
+t_Error FmPortSetPcd(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParams);
+t_Error FmPortDeletePcd(t_Handle h_FmPort);
+#endif
+
+t_Error FmPortConfigIM (t_FmPort *p_FmPort, t_FmPortParams *p_FmPortParams);
+t_Error FmPortImCheckInitParameters(t_FmPort *p_FmPort);
+
+t_Error FmPortImInit(t_FmPort *p_FmPort);
+void    FmPortImFree(t_FmPort *p_FmPort);
+
+t_Error FmPortImRx  (t_FmPort *p_FmPort);
+
+
+static __inline__ uint8_t * BD_BUFFER (t_FmImBd *p_Bd)
+{
+//#warning complete
+    return XX_PhysToVirt(CAST_UINT32_TO_POINTER(GET_UINT32(p_Bd->buff.low)));
+}
+
+static __inline__ void SET_ADDR(volatile t_FmPhysAddr *fmPhysAddr, uint64_t value)
+{
+    WRITE_UINT16(fmPhysAddr->high,(uint16_t)((value & 0x0000ffff00000000LL) >> 32));
+    WRITE_UINT32(fmPhysAddr->low,(uint32_t)value);
+}
+
+static __inline__ void BD_BUFFER_SET(t_FmImBd *p_Bd, uint8_t *p_Buffer)
+{
+    uint64_t    physAddr = CAST_POINTER_TO_UINT64(XX_VirtToPhys(p_Buffer));
+    SET_ADDR(&p_Bd->buff, physAddr);
+}
+
+static __inline__ uint16_t GetNextBdId(t_FmPort *p_FmPort, uint16_t id)
+{
+    if (id < p_FmPort->im.bdRingSize-1)
+        return (uint16_t)(id+1);
+    else
+        return 0;
+}
+
+
+#endif /* __FM_PORT_H */
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/Port/fm_port_im.c b/drivers/net/dpa/NetCommSw/Peripherals/FM/Port/fm_port_im.c
new file mode 100644
index 0000000..3108611
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/Port/fm_port_im.c
@@ -0,0 +1,590 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/******************************************************************************
+ @File          fm_port_im.c
+
+ @Description   FM Port Independent-Mode ...
+*//***************************************************************************/
+#include "std_ext.h"
+#include "string_ext.h"
+#include "error_ext.h"
+#include "fm_muram_ext.h"
+
+#include "fm_port.h"
+
+
+#define TX_CONF_STATUS_UNSENT 0x1
+
+#ifdef CORE_8BIT_ACCESS_ERRATA
+#define MY_WRITE_UINT16(addr, val)                          \
+do {                                                        \
+    if (addr%4)                                             \
+    {                                                       \
+        uint32_t    newAddr = (uint32_t)((addr>>2)<<2);     \
+        uint32_t    tmp = GET_UINT32(newAddr);              \
+        tmp = (uint32_t)((tmp & 0xffff0000) | val);         \
+        WRITE_UINT32(newAddr, tmp);                         \
+    }                                                       \
+    else                                                    \
+    {                                                       \
+        uint32_t    tmp = GET_UINT32(addr);                 \
+        tmp = (uint32_t)((tmp & 0x0000ffff) | (((uint32_t)val)<<16));\
+        WRITE_UINT32(addr, tmp);                            \
+    }                                                       \
+} while (0)
+
+#define MY_WRITE_UINT8(addr,val) MY_MY_WRITE_UINT8(&addr,val)
+#define MY_GET_UINT8(addr) MY_MY_GET_UINT8(&addr)
+#else
+#define MY_WRITE_UINT16 WRITE_UINT16
+#define MY_GET_UINT16   GET_UINT16
+#endif /* CORE_8BIT_ACCESS_ERRATA */
+
+typedef enum e_TxConfType
+{
+     e_TX_CONF_TYPE_CHECK      = 0  /**< check if all the buffers were touched by the muxator, no confirmation callback */
+    ,e_TX_CONF_TYPE_CALLBACK   = 1  /**< confirm to user all the available sent buffers */
+    ,e_TX_CONF_TYPE_FLUSH      = 3  /**< confirm all buffers plus the unsent one with an appropriate status */
+} e_TxConfType;
+
+
+static void DiscardCurrentTxFrame(t_FmPort *p_FmPort)
+{
+    uint16_t   cleanBdId = p_FmPort->im.firstBdOfFrameId;
+
+    if ((cleanBdId == IM_ILEGAL_BD_ID) ||
+        (cleanBdId == p_FmPort->im.currBdId))
+        return;
+
+    /* Since firstInFrame is not NULL, one buffer at least has already been
+       inserted into the BD ring. Using do-while covers the situation of a
+       frame spanned throughout the whole Tx BD ring (p_CleanBd is incremented
+       prior to testing whether or not it's equal to TxBd). */
+    do
+    {
+        BD_STATUS_AND_LENGTH_SET(BD_GET(cleanBdId), 0);
+        /* Advance BD pointer */
+        cleanBdId = GetNextBdId(p_FmPort, cleanBdId);
+    } while (cleanBdId != p_FmPort->im.currBdId);
+
+    p_FmPort->im.firstBdOfFrameId = IM_ILEGAL_BD_ID;
+}
+
+static t_Error FmPortTxConf(t_FmPort *p_FmPort, e_TxConfType confType)
+{
+    t_Error             retVal = E_BUSY;
+    uint32_t            bdStatus;
+    uint16_t            savedStartBdId;
+
+    ASSERT_COND(p_FmPort);
+
+//    if (confType==e_TX_CONF_TYPE_CHECK)
+//        return (WfqEntryIsQueueEmpty(p_FmPort->im.h_WfqEntry) ? E_OK : E_BUSY);
+
+    savedStartBdId = p_FmPort->im.currBdId;
+    bdStatus = BD_STATUS_AND_LENGTH(BD_GET(p_FmPort->im.currBdId));
+
+    /* if R bit is set, we don't enter, or we break.
+    we run till we get to R, or complete the loop */
+    while ((!(bdStatus & BD_R_E) || (confType == e_TX_CONF_TYPE_FLUSH)) && (retVal != E_OK))
+    {
+        if (confType & e_TX_CONF_TYPE_CALLBACK) /* if it is confirmation with user callbacks */
+            BD_STATUS_AND_LENGTH_SET(BD_GET(p_FmPort->im.currBdId), 0);
+
+        /* case 1: R bit is 0 and Length is set -> confirm! */
+        if ((confType & e_TX_CONF_TYPE_CALLBACK) && (bdStatus & BD_LENGTH_MASK))
+        {
+            if (p_FmPort->im.f_TxConfCB)
+            {
+                if ((confType == e_TX_CONF_TYPE_FLUSH) && (bdStatus & BD_R_E))
+                    p_FmPort->im.f_TxConfCB(p_FmPort->im.h_App,
+                                            BD_BUFFER(BD_GET(p_FmPort->im.currBdId)),
+                                            TX_CONF_STATUS_UNSENT,
+                                            p_FmPort->im.p_BdShadow[p_FmPort->im.currBdId]);
+                else
+                    p_FmPort->im.f_TxConfCB(p_FmPort->im.h_App,
+                                            BD_BUFFER(BD_GET(p_FmPort->im.currBdId)),
+                                            0,
+                                            p_FmPort->im.p_BdShadow[p_FmPort->im.currBdId]);
+            }
+        }
+        /* case 2: R bit is 0 and Length is 0 -> not used yet, nop! */
+
+        p_FmPort->im.currBdId = GetNextBdId(p_FmPort, p_FmPort->im.currBdId);
+        if (p_FmPort->im.currBdId == savedStartBdId)
+            retVal = E_OK;
+        bdStatus = BD_STATUS_AND_LENGTH(BD_GET(p_FmPort->im.currBdId));
+    }
+
+    MY_WRITE_UINT16(p_FmPort->im.p_FmPortImPram->txQd.offsetIn, (uint16_t)(p_FmPort->im.currBdId<<4));
+
+    return retVal;
+}
+
+
+t_Error FmPortImRx(t_FmPort *p_FmPort)
+{
+//    e_ExceptionsSelect      exceptions = e_EX_NONE;
+    t_Handle                h_CurrUserPriv, h_NewUserPriv;
+    uint32_t                bdStatus;
+    volatile uint8_t        buffPos;
+    uint16_t                length;
+    uint16_t                errors/*, reportErrors*/;
+    uint8_t                 *p_CurData, *p_Data;
+
+    ASSERT_COND(p_FmPort);
+
+    bdStatus = BD_STATUS_AND_LENGTH(BD_GET(p_FmPort->im.currBdId));
+
+    while (!(bdStatus & BD_R_E)) /* while there is data in the Rx BD */
+    {
+        if (p_FmPort->im.firstBdOfFrameId == IM_ILEGAL_BD_ID)
+            p_FmPort->im.firstBdOfFrameId = p_FmPort->im.currBdId;
+
+        errors = 0;
+        p_CurData = BD_BUFFER(BD_GET(p_FmPort->im.currBdId));
+        h_CurrUserPriv = p_FmPort->im.p_BdShadow[p_FmPort->im.currBdId];
+        length = (uint16_t)((bdStatus & BD_L) ?
+                            ((bdStatus & BD_LENGTH_MASK) - p_FmPort->im.rxFrameAccumLength):
+                            (bdStatus & BD_LENGTH_MASK));
+        p_FmPort->im.rxFrameAccumLength += length;
+
+        /* determine whether buffer is first, last, first and last (single  */
+        /* buffer frame) or middle (not first and not last)                 */
+        buffPos = (uint8_t)((p_FmPort->im.currBdId == p_FmPort->im.firstBdOfFrameId) ?
+                            ((bdStatus & BD_L) ? SINGLE_BUF : FIRST_BUF) :
+                            ((bdStatus & BD_L) ? LAST_BUF : MIDDLE_BUF));
+
+        if (bdStatus & BD_L)
+        {
+            p_FmPort->im.rxFrameAccumLength = 0;
+            p_FmPort->im.firstBdOfFrameId = IM_ILEGAL_BD_ID;
+        }
+
+        if ((p_Data = p_FmPort->im.rxPool.f_GetBuf(p_FmPort->im.rxPool.h_BufferPool, &h_NewUserPriv)) == NULL)
+            RETURN_ERROR(MAJOR, E_NOT_AVAILABLE, ("Data buffer"));
+
+        BD_BUFFER_SET(BD_GET(p_FmPort->im.currBdId), p_Data);
+
+        BD_STATUS_AND_LENGTH_SET(BD_GET(p_FmPort->im.currBdId), BD_R_E);
+
+//#warning "add here support for errors!!!"
+        errors = (uint16_t)((bdStatus & BD_RX_ERRORS) >> 16);
+#if 0
+        /* find out which errors the user wants reported. The BD will
+        still be passed to the user, but first f_Exceptions will be called */
+        reportErrors = (uint16_t)(errors & p_FmPort->im.bdErrorsReport);
+        if(reportErrors)
+        {
+            QUEUE_GET_EXCEPTIONS(reportErrors, exceptions);
+            p_FmPort->im.f_Exceptions(p_FmPort->im.h_App, exceptions, 0);
+        }
+#endif /* 0 */
+
+        /* Pass the buffer if one of the conditions is true:
+        - There are no errors
+        - This is a part of a larger frame ( the application has already received some buffers )
+        - There is an error, but it was defined to be passed anyway. */
+        if ((buffPos != SINGLE_BUF) || !errors || (errors & (uint16_t)(BD_ERROR_PASS_FRAME>>16)))
+        {
+            p_FmPort->im.f_RxStoreCB(p_FmPort->im.h_App,
+                                     p_CurData,
+                                     length,
+                                     errors,
+                                     buffPos,
+                                     h_CurrUserPriv);
+        }
+        else if (p_FmPort->im.rxPool.f_PutBuf(p_FmPort->im.rxPool.h_BufferPool,
+                                              p_CurData,
+                                              h_CurrUserPriv))
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Failed freeing data buffer"));
+
+        p_FmPort->im.p_BdShadow[p_FmPort->im.currBdId] = h_NewUserPriv;
+
+        p_FmPort->im.currBdId = GetNextBdId(p_FmPort, p_FmPort->im.currBdId);
+        bdStatus = BD_STATUS_AND_LENGTH(BD_GET(p_FmPort->im.currBdId));
+        MY_WRITE_UINT16(p_FmPort->im.p_FmPortImPram->rxQd.offsetOut, (uint16_t)(p_FmPort->im.currBdId<<4));
+    }
+
+    return E_OK;
+}
+
+t_Error FmPortConfigIM (t_FmPort *p_FmPort, t_FmPortParams *p_FmPortParams)
+{
+    ASSERT_COND(p_FmPort);
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+
+    p_FmPort->im.h_App                          = p_FmPortParams->specificParams.imRxTxParams.h_App;
+    p_FmPort->im.h_FmMuram                      = p_FmPortParams->specificParams.imRxTxParams.h_FmMuram;
+    p_FmPort->p_FmPortDriverParam->partitionId  = p_FmPortParams->specificParams.imRxTxParams.partitionId;
+    p_FmPort->im.dataMemId                      = p_FmPortParams->specificParams.imRxTxParams.dataMemId;
+    p_FmPort->im.dataMemAttributes              = p_FmPortParams->specificParams.imRxTxParams.dataMemAttributes;
+
+    p_FmPort->im.fwExtStructsMemId      = DEFAULT_PORT_ImfwExtStructsMemId;
+    p_FmPort->im.fwExtStructsMemAttr    = DEFAULT_PORT_Im_fwExtStructsMemAttr;
+
+    if ((p_FmPort->portType == e_FM_PORT_TYPE_RX) ||
+        (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
+    {
+        p_FmPort->im.rxPool.h_BufferPool    = p_FmPortParams->specificParams.imRxTxParams.rxPoolParams.h_BufferPool;
+        p_FmPort->im.rxPool.f_GetBuf        = p_FmPortParams->specificParams.imRxTxParams.rxPoolParams.f_GetBuf;
+        p_FmPort->im.rxPool.f_PutBuf        = p_FmPortParams->specificParams.imRxTxParams.rxPoolParams.f_PutBuf;
+        p_FmPort->im.rxPool.bufferSize      = p_FmPortParams->specificParams.imRxTxParams.rxPoolParams.bufferSize;
+        p_FmPort->im.f_RxStoreCB            = p_FmPortParams->specificParams.imRxTxParams.f_RxStoreCB;
+
+        p_FmPort->im.mrblr                  = DEFAULT_PORT_ImMaxRxBufLength;
+        p_FmPort->im.bdRingSize             = DEFAULT_PORT_rxBdRingLength;
+    }
+    else
+    {
+        p_FmPort->im.f_TxConfCB             = p_FmPortParams->specificParams.imRxTxParams.f_TxConfCB;
+
+        p_FmPort->im.bdRingSize             = DEFAULT_PORT_txBdRingLength;
+    }
+
+    return E_OK;
+}
+
+t_Error FmPortImCheckInitParameters(t_FmPort *p_FmPort)
+{
+    if ((p_FmPort->portType != e_FM_PORT_TYPE_RX) &&
+        (p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) &&
+        (p_FmPort->portType != e_FM_PORT_TYPE_TX) &&
+        (p_FmPort->portType != e_FM_PORT_TYPE_TX_10G))
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, NO_MSG);
+
+    if ((p_FmPort->portType == e_FM_PORT_TYPE_RX) ||
+        (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
+    {
+        if (!POWER_OF_2(p_FmPort->im.mrblr))
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("max Rx buffer length must be power of 2!!!"));
+        if (p_FmPort->im.mrblr < 256)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("max Rx buffer length must at least 256!!!"));
+        if(p_FmPort->p_FmPortDriverParam->partitionId >= FM_MAX_NUM_OF_PARTITIONS)
+             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("partitionId can't be larger than %d", FM_MAX_NUM_OF_PARTITIONS-1));
+//#warning "add checks"
+    }
+    else
+    {
+//#warning "add checks"
+    }
+
+    return E_OK;
+}
+
+t_Error FmPortImInit(t_FmPort *p_FmPort)
+{
+    t_FmImBd    *p_Bd=NULL;
+    t_Handle    h_UserPriv;
+    uint64_t    tmpPhysBase;
+    uint16_t    log2Num;
+    uint8_t     *p_Data/*, *p_Tmp*/;
+    int         i;
+
+    ASSERT_COND(p_FmPort);
+
+    p_FmPort->im.p_FmPortImPram =
+        (t_FmPortImPram *)FM_MURAM_AllocMem(p_FmPort->im.h_FmMuram, sizeof(t_FmPortImPram), IM_PRAM_ALIGN);
+    if (!p_FmPort->im.p_FmPortImPram)
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Independent-Mode Parameter-RAM!!!"));
+    WRITE_BLOCK(p_FmPort->im.p_FmPortImPram, 0, sizeof(t_FmPortImPram));
+
+    if ((p_FmPort->portType == e_FM_PORT_TYPE_RX) ||
+        (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
+    {
+        p_FmPort->im.p_BdRing = (t_FmImBd *)XX_MallocSmart((uint32_t)(sizeof(t_FmImBd)*p_FmPort->im.bdRingSize), p_FmPort->im.fwExtStructsMemId, 4);
+        if (!p_FmPort->im.p_BdRing)
+            RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Independent-Mode Rx BD ring!!!"));
+        memset(p_FmPort->im.p_BdRing, 0, (uint32_t)(sizeof(t_FmImBd)*p_FmPort->im.bdRingSize));
+
+        p_FmPort->im.p_BdShadow = (t_Handle *)XX_Malloc((uint32_t)(sizeof(t_Handle)*p_FmPort->im.bdRingSize));
+        if (!p_FmPort->im.p_BdShadow)
+            RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Independent-Mode Rx BD shadow!!!"));
+        memset(p_FmPort->im.p_BdShadow, 0, (uint32_t)(sizeof(t_Handle)*p_FmPort->im.bdRingSize));
+
+        /* Initialize the Rx-BD ring */
+        for (i=0; i<p_FmPort->im.bdRingSize; i++)
+        {
+            p_Bd = BD_GET(i);
+            BD_STATUS_AND_LENGTH_SET (p_Bd, BD_R_E);
+
+            if ((p_Data = p_FmPort->im.rxPool.f_GetBuf(p_FmPort->im.rxPool.h_BufferPool, &h_UserPriv)) == NULL)
+                RETURN_ERROR(MAJOR, E_NOT_AVAILABLE, ("Data buffer"));
+            BD_BUFFER_SET(p_Bd, p_Data);
+            p_FmPort->im.p_BdShadow[i] = h_UserPriv;
+        }
+
+        if (p_FmPort->im.dataMemAttributes & MEMORY_ATTR_CACHEABLE)
+            WRITE_UINT32(p_FmPort->im.p_FmPortImPram->mode, IM_MODE_GBL);
+
+        WRITE_UINT32(p_FmPort->im.p_FmPortImPram->rxQdPtr,
+                     (uint32_t)(CAST_POINTER_TO_UINT64(XX_VirtToPhys(p_FmPort->im.p_FmPortImPram)) -
+                                p_FmPort->p_FmPortDriverParam->fmMuramPhysBaseAddr + 0x20));
+
+        LOG2((uint64_t)p_FmPort->im.mrblr, log2Num);
+        MY_WRITE_UINT16(p_FmPort->im.p_FmPortImPram->mrblr, log2Num);
+
+        /* Initialize Rx QD */
+        tmpPhysBase = CAST_POINTER_TO_UINT64(XX_VirtToPhys(p_FmPort->im.p_BdRing));
+        SET_ADDR(&p_FmPort->im.p_FmPortImPram->rxQd.bdRingBase, tmpPhysBase);
+        MY_WRITE_UINT16(p_FmPort->im.p_FmPortImPram->rxQd.bdRingSize, (uint16_t)(sizeof(t_FmImBd)*p_FmPort->im.bdRingSize));
+
+        /* Update the IM PRAM address in the BMI */
+        WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfqid,
+                     (uint32_t)(CAST_POINTER_TO_UINT64(XX_VirtToPhys(p_FmPort->im.p_FmPortImPram)) -
+                                p_FmPort->p_FmPortDriverParam->fmMuramPhysBaseAddr));
+    }
+    else
+    {
+        p_FmPort->im.p_BdRing = (t_FmImBd *)XX_MallocSmart((uint32_t)(sizeof(t_FmImBd)*p_FmPort->im.bdRingSize), p_FmPort->im.fwExtStructsMemId, 4);
+        if (!p_FmPort->im.p_BdRing)
+            RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Independent-Mode Tx BD ring!!!"));
+        memset(p_FmPort->im.p_BdRing, 0, (uint32_t)(sizeof(t_FmImBd)*p_FmPort->im.bdRingSize));
+
+        p_FmPort->im.p_BdShadow = (t_Handle *)XX_Malloc((uint32_t)(sizeof(t_Handle)*p_FmPort->im.bdRingSize));
+        if (!p_FmPort->im.p_BdShadow)
+            RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Independent-Mode Rx BD shadow!!!"));
+        memset(p_FmPort->im.p_BdShadow, 0, (uint32_t)(sizeof(t_Handle)*p_FmPort->im.bdRingSize));
+        p_FmPort->im.firstBdOfFrameId = IM_ILEGAL_BD_ID;
+
+        if (p_FmPort->im.dataMemAttributes & MEMORY_ATTR_CACHEABLE)
+            WRITE_UINT32(p_FmPort->im.p_FmPortImPram->mode, IM_MODE_GBL);
+
+        WRITE_UINT32(p_FmPort->im.p_FmPortImPram->txQdPtr,
+                     (uint32_t)(CAST_POINTER_TO_UINT64(XX_VirtToPhys(p_FmPort->im.p_FmPortImPram)) -
+                                p_FmPort->p_FmPortDriverParam->fmMuramPhysBaseAddr + 0x40));
+
+        /* Initialize Tx QD */
+        tmpPhysBase = CAST_POINTER_TO_UINT64(XX_VirtToPhys(p_FmPort->im.p_BdRing));
+        SET_ADDR(&p_FmPort->im.p_FmPortImPram->txQd.bdRingBase, tmpPhysBase);
+        MY_WRITE_UINT16(p_FmPort->im.p_FmPortImPram->txQd.bdRingSize, (uint16_t)(sizeof(t_FmImBd)*p_FmPort->im.bdRingSize));
+
+        /* Update the IM PRAM address in the BMI */
+        WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->txPortBmiRegs.fmbm_tcfqid,
+                     (uint32_t)(CAST_POINTER_TO_UINT64(XX_VirtToPhys(p_FmPort->im.p_FmPortImPram)) -
+                                p_FmPort->p_FmPortDriverParam->fmMuramPhysBaseAddr));
+    }
+
+    return E_OK;
+}
+
+void FmPortImFree(t_FmPort *p_FmPort)
+{
+    uint32_t    bdStatus;
+    uint8_t     *p_CurData;
+
+    ASSERT_COND(p_FmPort);
+
+    if (p_FmPort->im.p_FmPortImPram)
+        FM_MURAM_FreeMem(p_FmPort->im.h_FmMuram, p_FmPort->im.p_FmPortImPram);
+
+    if ((p_FmPort->portType == e_FM_PORT_TYPE_RX) ||
+        (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
+    {
+        /* Try first clean what has recieved */
+        FmPortImRx(p_FmPort);
+
+        /* Now, get rid of the the empty buffer! */
+        bdStatus = BD_STATUS_AND_LENGTH(BD_GET(p_FmPort->im.currBdId));
+
+        while (bdStatus & BD_R_E) /* while there is data in the Rx BD */
+        {
+            p_CurData = BD_BUFFER(BD_GET(p_FmPort->im.currBdId));
+
+            BD_BUFFER_SET(BD_GET(p_FmPort->im.currBdId), NULL);
+            BD_STATUS_AND_LENGTH_SET(BD_GET(p_FmPort->im.currBdId), 0);
+
+            p_FmPort->im.rxPool.f_PutBuf(p_FmPort->im.rxPool.h_BufferPool,
+                                         p_CurData,
+                                         p_FmPort->im.p_BdShadow[p_FmPort->im.currBdId]);
+
+            p_FmPort->im.currBdId = GetNextBdId(p_FmPort, p_FmPort->im.currBdId);
+            bdStatus = BD_STATUS_AND_LENGTH(BD_GET(p_FmPort->im.currBdId));
+        }
+    }
+    else
+        FmPortTxConf(p_FmPort, e_TX_CONF_TYPE_FLUSH);
+
+    if (p_FmPort->im.p_BdShadow)
+        XX_Free(p_FmPort->im.p_BdShadow);
+
+    if (p_FmPort->im.p_BdRing)
+        XX_FreeSmart(p_FmPort->im.p_BdRing);
+}
+
+
+t_Error FM_PORT_ConfigIMMaxRxBufLength(t_Handle h_FmPort, uint16_t newVal)
+{
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->imEn, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+
+    p_FmPort->im.mrblr = newVal;
+
+    return E_OK;
+}
+
+t_Error FM_PORT_ConfigIMRxBdRingLength(t_Handle h_FmPort, uint16_t newVal)
+{
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->imEn, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+
+    p_FmPort->im.bdRingSize = newVal;
+
+    return E_OK;
+}
+
+t_Error FM_PORT_ConfigIMTxBdRingLength(t_Handle h_FmPort, uint16_t newVal)
+{
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->imEn, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+
+    p_FmPort->im.bdRingSize = newVal;
+
+    return E_OK;
+}
+
+
+t_Error  FM_PORT_ImTx( t_Handle               h_FmPort,
+                       uint8_t                *p_Data,
+                       uint16_t               length,
+                       bool                   lastBuffer,
+                       t_Handle               h_UserPriv)
+{
+    t_FmPort            *p_FmPort = (t_FmPort*)h_FmPort;
+    uint16_t            nextBdId;
+    uint32_t            bdStatus, nextBdStatus;
+    bool                firstBuffer;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->imEn, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+
+    bdStatus = BD_STATUS_AND_LENGTH(BD_GET(p_FmPort->im.currBdId));
+    nextBdId = GetNextBdId(p_FmPort, p_FmPort->im.currBdId);
+    nextBdStatus = BD_STATUS_AND_LENGTH(BD_GET(nextBdId));
+
+    if (!(bdStatus & BD_R_E) && !(nextBdStatus & BD_R_E))
+    {
+        /* Confirm the current BD - BD is available */
+        if ((bdStatus & BD_LENGTH_MASK) && (p_FmPort->im.f_TxConfCB))
+            p_FmPort->im.f_TxConfCB (p_FmPort->im.h_App,
+                                     BD_BUFFER(BD_GET(p_FmPort->im.currBdId)),
+                                     0,
+                                     p_FmPort->im.p_BdShadow[p_FmPort->im.currBdId]);
+
+        bdStatus |= length;
+
+        /* if this is the first BD of a frame */
+        if (p_FmPort->im.firstBdOfFrameId == IM_ILEGAL_BD_ID)
+        {
+            firstBuffer = TRUE;
+            p_FmPort->im.txFirstBdStatus = (bdStatus | BD_R_E);
+
+            if (!lastBuffer)
+                p_FmPort->im.firstBdOfFrameId = p_FmPort->im.currBdId;
+        }
+        else
+            firstBuffer = FALSE;
+
+        BD_BUFFER_SET(BD_GET(p_FmPort->im.currBdId), p_Data);
+        p_FmPort->im.p_BdShadow[p_FmPort->im.currBdId] = h_UserPriv;
+
+        /* deal with last */
+        if (lastBuffer)
+        {
+            /* if single buffer frame */
+            if (firstBuffer)
+                BD_STATUS_AND_LENGTH_SET(BD_GET(p_FmPort->im.currBdId), p_FmPort->im.txFirstBdStatus | BD_L);
+            else
+            {
+                /* Set the last BD of the frame */
+                BD_STATUS_AND_LENGTH_SET (BD_GET(p_FmPort->im.currBdId), (bdStatus | BD_R_E | BD_L));
+                /* Set the first BD of the frame */
+                BD_STATUS_AND_LENGTH_SET(BD_GET(p_FmPort->im.firstBdOfFrameId), p_FmPort->im.txFirstBdStatus);
+                p_FmPort->im.firstBdOfFrameId = IM_ILEGAL_BD_ID;
+            }
+        }
+        else if (!firstBuffer) /* mid frame buffer */
+            BD_STATUS_AND_LENGTH_SET (BD_GET(p_FmPort->im.currBdId), bdStatus | BD_R_E);
+
+        p_FmPort->im.currBdId = GetNextBdId(p_FmPort, p_FmPort->im.currBdId);
+        MY_WRITE_UINT16(p_FmPort->im.p_FmPortImPram->txQd.offsetIn, (uint16_t)(p_FmPort->im.currBdId<<4));
+    }
+    else
+    {
+        /* Discard current frame. Return error.   */
+        if (p_FmPort->im.firstBdOfFrameId != IM_ILEGAL_BD_ID)
+        {
+            ASSERT_COND(p_FmPort->im.firstBdOfFrameId != p_FmPort->im.currBdId);
+            /* Error:    No free BD */
+            /* Response: Discard current frame. Return error.   */
+            DiscardCurrentTxFrame(p_FmPort);
+        }
+
+        return E_FULL;
+    }
+
+    return E_OK;
+}
+
+void FM_PORT_ImTxConf(t_Handle h_FmPort)
+{
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+
+    SANITY_CHECK_RETURN(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN(p_FmPort->imEn, E_INVALID_STATE);
+    SANITY_CHECK_RETURN(!p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+
+    FmPortTxConf(p_FmPort, e_TX_CONF_TYPE_CALLBACK);
+}
+
+t_Error  FM_PORT_ImRx(t_Handle h_FmPort)
+{
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->imEn, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+
+    return FmPortImRx(p_FmPort);
+}
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/fm.c b/drivers/net/dpa/NetCommSw/Peripherals/FM/fm.c
new file mode 100644
index 0000000..abdeaca
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/fm.c
@@ -0,0 +1,2478 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/******************************************************************************
+ @File          fm.c
+
+ @Description   FM driver routines implementation.
+*//***************************************************************************/
+#include "std_ext.h"
+#include "error_ext.h"
+#include "xx_ext.h"
+#include "string_ext.h"
+#include "sprint_ext.h"
+#include "debug_ext.h"
+#include "fm_muram_ext.h"
+#include "fm_common.h"
+#ifdef FM_MASTER_PARTITION
+#include "fm_ipc.h"
+#endif /* FM_MASTER_PARTITION */
+#include "fm.h"
+
+
+#define TS_FRAC_PRECISION_FACTOR    1000
+
+
+/****************************************/
+/*       static functions               */
+/****************************************/
+static t_Error CheckFmParameters(t_Fm *p_Fm)
+{
+    uint8_t     i;
+
+    if(p_Fm->p_FmDriverParam->enTimeStamp)
+    {
+        if(!p_Fm->timeStampPeriod)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("timeStampPeriod may not be 0"));
+    }
+    if(!p_Fm->p_FmDriverParam->dmaAxiDbgNumOfBeats || (p_Fm->p_FmDriverParam->dmaAxiDbgNumOfBeats > DMA_MODE_MAX_AXI_DBG_NUM_OF_BEATS))
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("axiDbgNumOfBeats has to be in the range 1 - %d", DMA_MODE_MAX_AXI_DBG_NUM_OF_BEATS));
+    if(p_Fm->p_FmDriverParam->dmaCamNumOfEntries % DMA_CAM_UNITS)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dmaCamNumOfEntries has to be divisble by %d", DMA_CAM_UNITS));
+    if(!p_Fm->p_FmDriverParam->dmaCamNumOfEntries || (p_Fm->p_FmDriverParam->dmaCamNumOfEntries > DMA_MODE_MAX_CAM_NUM_OF_ENTRIES))
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dmaCamNumOfEntries has to be in the range 1 - %d", DMA_MODE_MAX_CAM_NUM_OF_ENTRIES));
+    if(p_Fm->p_FmDriverParam->dmaCommQThresholds.assertEmergency > DMA_THRESH_MAX_COMMQ)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dmaCommQThresholds.assertEmergency can not be larger than %d", DMA_THRESH_MAX_COMMQ));
+    if(p_Fm->p_FmDriverParam->dmaCommQThresholds.clearEmergency > DMA_THRESH_MAX_COMMQ)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dmaCommQThresholds.clearEmergency can not be larger than %d", DMA_THRESH_MAX_COMMQ));
+    if(p_Fm->p_FmDriverParam->dmaCommQThresholds.clearEmergency >= p_Fm->p_FmDriverParam->dmaCommQThresholds.assertEmergency)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dmaCommQThresholds.clearEmergency must be smaller than dmaCommQThresholds.assertEmergency"));
+    if(p_Fm->p_FmDriverParam->dmaReadBufThresholds.assertEmergency > DMA_THRESH_MAX_BUF)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dmaReadBufThresholds.assertEmergency can not be larger than %d", DMA_THRESH_MAX_BUF));
+    if(p_Fm->p_FmDriverParam->dmaReadBufThresholds.clearEmergency > DMA_THRESH_MAX_BUF)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dmaReadBufThresholds.clearEmergency can not be larger than %d", DMA_THRESH_MAX_BUF));
+    if(p_Fm->p_FmDriverParam->dmaReadBufThresholds.clearEmergency >= p_Fm->p_FmDriverParam->dmaReadBufThresholds.assertEmergency)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dmaReadBufThresholds.clearEmergency must be smaller than dmaReadBufThresholds.assertEmergency"));
+    if(p_Fm->p_FmDriverParam->dmaWriteBufThresholds.assertEmergency > DMA_THRESH_MAX_BUF)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dmaWriteBufThresholds.assertEmergency can not be larger than %d", DMA_THRESH_MAX_BUF));
+    if(p_Fm->p_FmDriverParam->dmaWriteBufThresholds.clearEmergency > DMA_THRESH_MAX_BUF)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dmaWriteBufThresholds.clearEmergency can not be larger than %d", DMA_THRESH_MAX_BUF));
+    if(p_Fm->p_FmDriverParam->dmaWriteBufThresholds.clearEmergency >= p_Fm->p_FmDriverParam->dmaWriteBufThresholds.assertEmergency)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dmaWriteBufThresholds.clearEmergency must be smaller than dmaWriteBufThresholds.assertEmergency"));
+
+    if(!p_Fm->fmClkFreq)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fmClkFreq must be set."));
+    if(USEC_TO_CLK(p_Fm->p_FmDriverParam->dmaWatchdog, p_Fm->fmClkFreq) > DMA_MAX_WATCHDOG)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dmaWatchdog depends on FM clock. dmaWatchdog(in microseconds) * clk (in Mhz), may not exceed 0xffffffff"));
+    for (i=0 ; i<FM_MAX_NUM_OF_PARTITIONS ; i++)
+        if(p_Fm->p_FmDriverParam->liodnPerPartition[i] & ~FM_LIODN_MASK)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("liodn number is out of range"));
+
+    if(p_Fm->totalFifoSize % BMI_FIFO_UNITS)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("totalFifoSize number has to be divisible by %d", BMI_FIFO_UNITS));
+    if(!p_Fm->totalFifoSize || (p_Fm->totalFifoSize > BMI_MAX_FIFO_SIZE))
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("totalFifoSize number has to be in the range 256 - %d", BMI_MAX_FIFO_SIZE));
+    if(!p_Fm->totalNumOfTasks || (p_Fm->totalNumOfTasks > BMI_MAX_NUM_OF_TASKS))
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("totalNumOfTasks number has to be in the range 1 - %d", BMI_MAX_NUM_OF_TASKS));
+    if(!p_Fm->maxNumOfOpenDmas || (p_Fm->maxNumOfOpenDmas > BMI_MAX_NUM_OF_DMAS))
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("maxNumOfOpenDmas number has to be in the range 1 - %d", BMI_MAX_NUM_OF_DMAS));
+
+    if(p_Fm->p_FmDriverParam->thresholds.dispLimit > FPM_MAX_DISP_LIMIT)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("thresholds.dispLimit can't be greater than %d", FPM_MAX_DISP_LIMIT));
+
+    if(!p_Fm->f_Exceptions)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Exceptions callback not provided"));
+    if(!p_Fm->f_BusError)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Exceptions callback not provided"));
+
+    return E_OK;
+}
+
+static uint8_t  GetPartition(t_Fm *p_Fm, uint16_t liodn)
+{
+    int         i;
+    uint32_t    tmpReg;
+
+    for (i=0 ; i<FM_MAX_NUM_OF_PARTITIONS ; i+=2)
+    {
+        tmpReg = GET_UINT32(p_Fm->p_FmDmaRegs->fmdmplr[i/2]);
+        if (liodn == (uint16_t)((tmpReg & DMA_HIGH_LIODN_MASK )>> DMA_LIODN_SHIFT))
+            return (uint8_t)i;
+        if (liodn == (uint16_t)(tmpReg & DMA_LOW_LIODN_MASK))
+            return (uint8_t)(i+1);
+    }
+    REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("Partition not found in LIODN table"));
+    return 0;
+}
+
+static void    BmiErrEvent(t_Fm *p_Fm)
+{
+    uint32_t    event, mask;
+
+    event = GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_ievr);
+    mask = GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_ier);
+    event &= mask;
+    /* clear the acknowledged events */
+    WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_ievr, event);
+
+    if(event & BMI_ERR_INTR_EN_PIPELINE_ECC)
+        p_Fm->f_Exceptions(p_Fm->h_App,e_FM_EX_BMI_PIPELINE_ECC);
+    if(event & BMI_ERR_INTR_EN_LIST_RAM_ECC)
+        p_Fm->f_Exceptions(p_Fm->h_App,e_FM_EX_BMI_LIST_RAM_ECC);
+    if(event & BMI_ERR_INTR_EN_STATISTICS_RAM_ECC)
+        p_Fm->f_Exceptions(p_Fm->h_App,e_FM_EX_BMI_STATISTICS_RAM_ECC);
+}
+
+static void    QmiErrEvent(t_Fm *p_Fm)
+{
+    uint32_t    event, mask;
+
+    event = GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_eie);
+    mask = GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_eien);
+    event &= mask;
+    /* clear the acknowledged events */
+    WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_eie, event);
+
+    if(event & QMI_ERR_INTR_EN_DOUBLE_ECC)
+        p_Fm->f_Exceptions(p_Fm->h_App,e_FM_EX_QMI_DOUBLE_ECC);
+    if(event & QMI_ERR_INTR_EN_DEQ_FROM_DEF)
+        p_Fm->f_Exceptions(p_Fm->h_App,e_FM_EX_QMI_DEQ_FROM_DEFQ);
+}
+
+static void    DmaErrEvent(t_Fm *p_Fm)
+{
+    uint64_t            addr=0;
+    uint32_t            status, mask, tmpReg=0;
+    uint8_t             tnum, partition;
+    uint8_t             hardwarePortId;
+    uint8_t             relativePortId;
+
+    status = GET_UINT32(p_Fm->p_FmDmaRegs->fmdmsr);
+    mask = GET_UINT32(p_Fm->p_FmDmaRegs->fmdmmr);
+
+    /* get bus error regs befor clearing BER */
+    if ((status & DMA_STATUS_BUS_ERR) && (mask & DMA_MODE_BER))
+    {
+        addr = (uint64_t)GET_UINT32(p_Fm->p_FmDmaRegs->fmdmtal);
+        addr |= (uint64_t)GET_UINT32(p_Fm->p_FmDmaRegs->fmdmtah) << 32;
+
+        /* get information about the owner of that bus error */
+        tmpReg = GET_UINT32(p_Fm->p_FmDmaRegs->fmdmtcid);
+    }
+
+    /* clear set events */
+    WRITE_UINT32(p_Fm->p_FmDmaRegs->fmdmsr, status);
+
+    if ((status & DMA_STATUS_BUS_ERR) && (mask & DMA_MODE_BER))
+    {
+        ASSERT_COND(p_Fm->h_FmPorts[((tmpReg & DMA_TRANSFER_PORTID_MASK) >> DMA_TRANSFER_PORTID_SHIFT)]);
+        hardwarePortId = (uint8_t)(((tmpReg & DMA_TRANSFER_PORTID_MASK) >> DMA_TRANSFER_PORTID_SHIFT));
+        GET_RELATIVE_PORTID(relativePortId, hardwarePortId);
+        tnum = (uint8_t)((tmpReg & DMA_TRANSFER_TNUM_MASK) >> DMA_TRANSFER_TNUM_SHIFT);
+        partition = GetPartition(p_Fm, (uint16_t)(tmpReg & DMA_TRANSFER_LIODN_MASK));
+        ASSERT_COND(p_Fm->portsTypes[hardwarePortId] != e_FM_PORT_TYPE_DUMMY);
+        p_Fm->f_BusError(p_Fm->h_App, p_Fm->portsTypes[hardwarePortId] , relativePortId, addr, tnum, partition) ;
+    }
+    if(mask & DMA_MODE_ECC)
+    {
+        if (status & DMA_STATUS_READ_ECC)
+            p_Fm->f_Exceptions(p_Fm->h_App, e_FM_EX_DMA_READ_ECC) ;
+        if (status & DMA_STATUS_SYSTEM_WRITE_ECC)
+            p_Fm->f_Exceptions(p_Fm->h_App, e_FM_EX_DMA_SYSTEM_WRITE_ECC) ;
+        if (status & DMA_STATUS_FM_WRITE_ECC)
+            p_Fm->f_Exceptions(p_Fm->h_App, e_FM_EX_DMA_FM_WRITE_ECC) ;
+    }
+}
+
+static void    FpmErrEvent(t_Fm *p_Fm)
+{
+    uint32_t    event;
+
+    event = GET_UINT32(p_Fm->p_FmFpmRegs->fpmem);
+    /* clear the all occured events */
+    WRITE_UINT32(p_Fm->p_FmFpmRegs->fpmem, event);
+
+    if((event  & FPM_EV_MASK_DOUBLE_ECC) && (event & FPM_EV_MASK_DOUBLE_ECC_EN))
+        p_Fm->f_Exceptions(p_Fm->h_App,e_FM_EX_FPM_DOUBLE_ECC);
+    if((event  & FPM_EV_MASK_STALL) && (event & FPM_EV_MASK_STALL_EN))
+        p_Fm->f_Exceptions(p_Fm->h_App,e_FM_EX_FPM_STALL_ON_TASKS);
+    if((event  & FPM_EV_MASK_SINGLE_ECC) && (event & FPM_EV_MASK_SINGLE_ECC_EN))
+        p_Fm->f_Exceptions(p_Fm->h_App,e_FM_EX_FPM_SINGLE_ECC);
+}
+
+static void    MuramErrIntr(t_Fm *p_Fm)
+{
+    uint32_t    event;
+
+    event = GET_UINT32(p_Fm->p_FmFpmRegs->fmrcr);
+
+    /* clear MURAM event bit */
+    WRITE_UINT32(p_Fm->p_FmFpmRegs->fmrcr, event & ~FPM_RAM_CTL_IRAM_ECC);
+
+    ASSERT_COND(event  & FPM_RAM_CTL_MURAM_ECC);
+    ASSERT_COND(event  & FPM_RAM_CTL_RAMS_ECC_EN);
+
+    p_Fm->f_Exceptions(p_Fm->h_App, e_FM_EX_MURAM_ECC);
+}
+
+static void    IramErrIntr(t_Fm *p_Fm)
+{
+    uint32_t    event;
+
+    event = GET_UINT32(p_Fm->p_FmFpmRegs->fmrcr) ;
+    /* clear the acknowledged events (do not clear IRAM event) */
+    WRITE_UINT32(p_Fm->p_FmFpmRegs->fmrcr, event & ~FPM_RAM_CTL_MURAM_ECC );
+
+    ASSERT_COND(event  & FPM_RAM_CTL_IRAM_ECC);
+    ASSERT_COND(event  & FPM_RAM_CTL_IRAM_ECC_EN);
+
+    p_Fm->f_Exceptions(p_Fm->h_App, e_FM_EX_IRAM_ECC);
+}
+
+static void     QmiEvent(t_Fm *p_Fm)
+{
+    uint32_t    event, mask;
+
+    event = GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_ie);
+    mask = GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_ien);
+    event &= mask;
+    /* clear the acknowledged events */
+    WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_ie, event);
+
+    if(event & QMI_INTR_EN_SINGLE_ECC)
+        p_Fm->f_Exceptions(p_Fm->h_App,e_FM_EX_QMI_SINGLE_ECC);
+}
+
+static void     FmCtlEvent(t_Fm *p_Fm, uint32_t pending)
+{
+    uint32_t    eventRegBitMask = FPM_EVENT_FM_CTL_0;
+    uint8_t     i;
+    uint32_t    event;
+
+    for(i=0;i<NUM_OF_FM_CTL_EVENT_REGS;i++)
+    {
+       if (pending & eventRegBitMask)
+       {
+            event = GET_UINT32(p_Fm->p_FmFpmRegs->fpmcev[i]);
+            /* clear event bits */
+            WRITE_UINT32(p_Fm->p_FmFpmRegs->fpmcev[i], event);
+            p_Fm->f_FmCtlIsr[i](p_Fm, event);
+       }
+       eventRegBitMask >>= 1;
+    }
+}
+
+static void UnimplementedIsr(t_Handle h_Arg)
+{
+    UNUSED(h_Arg);
+
+    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Unimplemented Isr!"));
+}
+
+static void UnimplementedFmCtlIsr(t_Handle h_Arg, uint32_t event)
+{
+    UNUSED(h_Arg); UNUSED(event);
+
+    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Unimplemented FmCtl Isr!"));
+}
+
+static void FmFreeInitResources(t_Fm *p_Fm)
+{
+    if (p_Fm->camBaseAddr)
+       FM_MURAM_FreeMem(p_Fm->h_FmMuram, CAST_UINT64_TO_POINTER(p_Fm->camBaseAddr));
+    if (p_Fm->fifoBaseAddr)
+       FM_MURAM_FreeMem(p_Fm->h_FmMuram, CAST_UINT64_TO_POINTER(p_Fm->fifoBaseAddr));
+}
+
+static void LoadPatch(t_Fm *p_Fm)
+{
+    t_FMIramRegs    *p_Iram = CAST_UINT64_TO_POINTER_TYPE(t_FMIramRegs, (p_Fm->baseAddr + FM_MM_IMEM));
+    int             i;
+
+    SANITY_CHECK_RETURN(p_Fm, E_INVALID_HANDLE);
+
+    DBG(TRACE, ("Loading firmware to IRAM ..."));
+
+    /* Applying patch to IRAM */
+    WRITE_UINT32(p_Iram->iadd, IRAM_IADD_AIE);
+    while (GET_UINT32(p_Iram->iadd) != IRAM_IADD_AIE) ;
+
+    for (i=0; i < (p_Fm->p_FmDriverParam->firmware.size / 4); i++)
+        WRITE_UINT32(p_Iram->idata, p_Fm->p_FmDriverParam->firmware.p_Code[i]);
+
+    WRITE_UINT32(p_Iram->iadd,0x0);
+    /* verify that writing has completed */
+    while (GET_UINT32(p_Iram->idata) != p_Fm->p_FmDriverParam->firmware.p_Code[0]) ;
+
+    /* Enable patch from IRAM */
+    WRITE_UINT32(p_Iram->iready, IRAM_READY);
+}
+
+/****************************************/
+/*       Inter-Module functions        */
+/****************************************/
+
+#ifdef FM_MASTER_PARTITION
+t_Error     FmHandleIpcMsg(t_Handle h_Fm, uint32_t msgId, uint8_t msgBody[MSG_BODY_SIZE])
+{
+    t_Fm    *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+
+    switch(msgId)
+    {
+        case (FM_GET_SET_PORT_PARAMS):
+            return FmGetSetPortParams(h_Fm, (t_FmInterModulePortInitParams*)msgBody);
+         case (FM_RESUME_STALLED_PORT):
+            return FmResumeStalledPort(h_Fm, msgBody[0]);
+        case (FM_IS_PORT_STALLED):
+            ((t_FmIpcPortIsStalled*)msgBody)->isStalled = FmIsPortStalled(h_Fm, (uint8_t)(((t_FmIpcPortIsStalled*)msgBody)->hardwarePortId));
+            break;
+        case (FM_RESET_MAC):
+        {
+            t_FmIpcMacReset ipcParams;
+            memcpy(msgBody, (uint8_t *)&ipcParams, sizeof(t_FmIpcMacReset));
+            return FmResetMac(p_Fm, (e_FmMacType)ipcParams.type, ipcParams.id);
+        }
+        case (FM_FREE_PORT):
+            FmFreePortParams(h_Fm, (t_FmInterModulePortFreeParams*)msgBody);
+            break;
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+        case (FM_DUMP_PORT_REGS):
+            return FmDumpPortRegs(h_Fm, msgBody[0]);
+#endif /* (defined(DEBUG_ERRORS) && ... */
+        default:
+            RETURN_ERROR(MINOR, E_INVALID_SELECTION, ("command not found!!!"));
+    }
+    return E_OK;
+}
+#endif /* FM_MASTER_PARTITION */
+
+uint64_t FmGetPcdPrsBaseAddr(t_Handle h_Fm)
+{
+    t_Fm        *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_VALUE(p_Fm, E_INVALID_HANDLE, 0);
+
+    return (p_Fm->baseAddr + FM_MM_PRS);
+}
+
+uint64_t FmGetPcdKgBaseAddr(t_Handle h_Fm)
+{
+    t_Fm        *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_VALUE(p_Fm, E_INVALID_HANDLE, 0);
+
+    return (p_Fm->baseAddr + FM_MM_KG);
+}
+
+uint64_t FmGetPcdPlcrBaseAddr(t_Handle h_Fm)
+{
+    t_Fm        *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_VALUE(p_Fm, E_INVALID_HANDLE, 0);
+
+    return (p_Fm->baseAddr + FM_MM_PLCR);
+}
+
+t_Handle FmGetMuramHandle(t_Handle h_Fm)
+{
+    t_Fm        *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_VALUE(p_Fm, E_INVALID_HANDLE, NULL);
+
+    return (p_Fm->h_FmMuram);
+}
+
+t_Error FmGetPhysicalMuramBase(t_Handle h_Fm, t_FmPhysAddr *fmPhysAddr)
+{
+    t_Fm            *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+
+    /* General FM driver initialization */
+    fmPhysAddr->low=(uint32_t)p_Fm->fmMuramPhysBaseAddr;
+    fmPhysAddr->high=(uint16_t)((p_Fm->fmMuramPhysBaseAddr & 0x0000ffff00000000LL) >> 32);
+
+    return E_OK;
+}
+
+
+void FmRegisterIntr(t_Handle h_Fm,
+                        e_FmInterModuleEvent   event,
+                        void (*f_Isr) (t_Handle h_Arg),
+                        t_Handle    h_Arg)
+{
+    t_Fm       *p_Fm = (t_Fm*)h_Fm;
+
+    p_Fm->intrMng[event].f_Isr = f_Isr;
+    p_Fm->intrMng[event].h_SrcHandle = h_Arg;
+}
+
+void  FmRegisterFmCtlIntr(t_Handle h_Fm, uint8_t eventRegId, void (*f_Isr) (t_Handle h_Fm, uint32_t event))
+{
+    t_Fm       *p_Fm = (t_Fm*)h_Fm;
+
+    p_Fm->f_FmCtlIsr[eventRegId] = f_Isr;
+}
+
+void  FmRegisterPcd(t_Handle h_Fm, t_Handle h_FmPcd)
+{
+    t_Fm       *p_Fm = (t_Fm*)h_Fm;
+
+    if(p_Fm->h_Pcd)
+        REPORT_ERROR(MAJOR, E_ALREADY_EXISTS, ("PCD already set"));
+
+    p_Fm->h_Pcd = h_FmPcd;
+
+}
+
+t_Handle  FmGetPcdHandle(t_Handle h_Fm)
+{
+    t_Fm       *p_Fm = (t_Fm*)h_Fm;
+
+    return p_Fm->h_Pcd;
+
+}
+
+uint8_t FmGetId(t_Handle h_Fm)
+{
+    t_Fm *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_VALUE(p_Fm, E_INVALID_HANDLE, 0xff);
+
+    return p_Fm->fmId;
+}
+
+t_Error FmGetSetPortParams(t_Handle h_Fm,t_FmInterModulePortInitParams *p_PortParams)
+{
+    t_Fm        *p_Fm = (t_Fm*)h_Fm;
+    uint32_t    tmpReg;
+    uint8_t     hardwarePortId = p_PortParams->hardwarePortId;
+    uint8_t     enqTh;
+    uint8_t     deqTh;
+    bool        update = FALSE;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+
+    /* return parameters */
+    p_PortParams->timeStampPeriod = p_Fm->timeStampPeriod;
+
+    if(p_PortParams->independentMode)
+    {
+        /* set port parameters */
+        p_Fm->independentMode = p_PortParams->independentMode;
+        /* disable dispatch limit */
+        WRITE_UINT32(p_Fm->p_FmFpmRegs->fpmflc, 0);
+    }
+
+    if(p_PortParams->portType == e_FM_PORT_TYPE_HOST_COMMAND)
+    {
+        if(p_Fm->hcPortInitialized)
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Only one host command port is allowed."));
+        else
+            p_Fm->hcPortInitialized = TRUE;
+    }
+    p_Fm->portsTypes[hardwarePortId] = p_PortParams->portType;
+
+    /* check that there are enough uncommited tasks */
+    if(p_PortParams->numOfExtraTasks > p_Fm->extraTasksPoolSize)
+        p_Fm->extraTasksPoolSize = p_PortParams->numOfExtraTasks;
+
+    if((p_Fm->accumulatedNumOfTasks + p_PortParams->numOfTasks) > p_Fm->totalNumOfTasks-p_Fm->extraTasksPoolSize)
+        RETURN_ERROR(MAJOR, E_NOT_AVAILABLE, ("Requested numOfTasks and extra tasks pool exceed total numOfTasks."));
+    else
+    {
+        p_Fm->accumulatedNumOfTasks += p_PortParams->numOfTasks;
+        tmpReg = (uint32_t)(((p_PortParams->numOfTasks-1) << BMI_NUM_OF_TASKS_SHIFT) |
+                    (p_PortParams->numOfExtraTasks << BMI_EXTRA_NUM_OF_TASKS_SHIFT));
+        WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_pp[hardwarePortId-1],tmpReg);
+    }
+
+    if((p_PortParams->portType != e_FM_PORT_TYPE_RX) && (p_PortParams->portType != e_FM_PORT_TYPE_RX_10G))
+    /* for transmit & O/H ports */
+    {
+        /* update qmi ENQ/DEQ threshold */
+        p_Fm->accumulatedNumOfDeqTnums += p_PortParams->deqPipelineDepth;
+        tmpReg = GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_gc);
+        enqTh = (uint8_t)(tmpReg>>8);
+        /* if enqTh is too big, we reduce it to the max value that is still OK */
+        if(enqTh >= (QMI_MAX_NUM_OF_TNUMS - p_Fm->accumulatedNumOfDeqTnums))
+        {
+            enqTh = (uint8_t)(QMI_MAX_NUM_OF_TNUMS - p_Fm->accumulatedNumOfDeqTnums - 1);
+            tmpReg &= ~QMI_CFG_ENQ_MASK;
+            tmpReg |= ((uint32_t)enqTh << 8);
+            update = TRUE;
+        }
+
+        deqTh = (uint8_t)tmpReg;
+        /* if deqTh is too small, we enlarge it to the min value that is still OK.
+         deqTh may not be larger than 63 (QMI_MAX_NUM_OF_TNUMS-1). */
+        if((deqTh <= p_Fm->accumulatedNumOfDeqTnums)  && (deqTh < QMI_MAX_NUM_OF_TNUMS-1))
+        {
+            deqTh = (uint8_t)(p_Fm->accumulatedNumOfDeqTnums + 1);
+            tmpReg &= ~QMI_CFG_DEQ_MASK;
+            tmpReg |= (uint32_t)deqTh;
+            update = TRUE;
+        }
+        if(update)
+            WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_gc, tmpReg);
+    }
+
+    /* check that there are enough uncommited open DMA's */
+    if(p_PortParams->numOfExtraOpenDmas > p_Fm->extraOpenDmasPoolSize)
+        p_Fm->extraOpenDmasPoolSize = p_PortParams->numOfExtraOpenDmas;
+
+    if((p_Fm->accumulatedNumOfOpenDmas + p_PortParams->numOfOpenDmas) > p_Fm->maxNumOfOpenDmas)
+        RETURN_ERROR(MAJOR, E_NOT_AVAILABLE, ("Requested numOfOpenDmas exceeds total numOfTasks."));
+    else
+    {
+        p_Fm->accumulatedNumOfOpenDmas += p_PortParams->numOfOpenDmas;
+        tmpReg = (uint32_t)(((p_PortParams->numOfOpenDmas-1) << BMI_NUM_OF_DMAS_SHIFT) |
+                    (p_PortParams->numOfExtraOpenDmas << BMI_EXTRA_NUM_OF_DMAS_SHIFT));
+        WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_pp[hardwarePortId-1],
+                GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_pp[hardwarePortId-1]) | tmpReg);
+        /* update total num of DMA's with committed number of open DMAS, and max uncommitted pool. */
+        tmpReg = GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_cfg2) & ~BMI_CFG2_DMAS_MASK;
+        tmpReg |= (uint32_t)(p_Fm->accumulatedNumOfOpenDmas + p_Fm->extraOpenDmasPoolSize - 1) << BMI_CFG2_DMAS_SHIFT;
+        WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_cfg2,  tmpReg);
+    }
+
+    /* we leave FM_MAX_NUM_OF_RX_PORTS spare bufferes for excessive buffers */
+        /* check that there are enough uncommited tasks */
+    if(p_PortParams->extraSizeOfFifo > p_Fm->extraFifoPoolSize)
+        p_Fm->extraTasksPoolSize = p_PortParams->numOfExtraTasks;
+
+    if((p_Fm->accumulatedFifoSize + p_PortParams->sizeOfFifo) > (p_Fm->totalFifoSize - p_Fm->extraTasksPoolSize))
+        RETURN_ERROR(MAJOR, E_NOT_AVAILABLE, ("Requested fifo size and extra size exceed total fifo size."));
+    else
+    {
+        p_Fm->accumulatedFifoSize += p_PortParams->sizeOfFifo;
+        tmpReg = (uint32_t)((p_PortParams->sizeOfFifo/BMI_FIFO_UNITS - 1) | ((p_PortParams->extraSizeOfFifo/BMI_FIFO_UNITS) << BMI_FIFO_SIZE_SHIFT));
+        WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_pfs[hardwarePortId-1], tmpReg);
+    }
+    WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_ppid[hardwarePortId-1], (uint32_t)p_PortParams->portPartition);
+
+    tmpReg = (uint32_t)(hardwarePortId << FPM_PORT_FM_CTL_PORTID_SHIFT);
+    if(p_PortParams->independentMode)
+    {
+        if((p_PortParams->portType==e_FM_PORT_TYPE_RX) || (e_FM_PORT_TYPE_RX_10G))
+            tmpReg |= (FPM_PORT_FM_CTL1 << FPM_PRC_ORA_FM_CTL_SEL_SHIFT) |FPM_PORT_FM_CTL1;
+        else
+            tmpReg |= (FPM_PORT_FM_CTL2 << FPM_PRC_ORA_FM_CTL_SEL_SHIFT) |FPM_PORT_FM_CTL2;
+    }
+    else
+    {
+        tmpReg |= (FPM_PORT_FM_CTL2|FPM_PORT_FM_CTL1);
+
+        /* order restoration */
+        if(hardwarePortId%2)
+            tmpReg |= (FPM_PORT_FM_CTL1 << FPM_PRC_ORA_FM_CTL_SEL_SHIFT);
+        else
+            tmpReg |= (FPM_PORT_FM_CTL2 << FPM_PRC_ORA_FM_CTL_SEL_SHIFT);
+    }
+    WRITE_UINT32(p_Fm->p_FmFpmRegs->fpmpr, tmpReg);
+
+    FmGetPhysicalMuramBase(p_Fm, &p_PortParams->fmMuramPhysBaseAddr);
+
+    return E_OK;
+}
+
+void FmFreePortParams(t_Handle h_Fm,t_FmInterModulePortFreeParams *p_PortParams)
+{
+    t_Fm        *p_Fm = (t_Fm*)h_Fm;
+    uint32_t    tmpReg;
+    uint8_t     hardwarePortId = p_PortParams->hardwarePortId;
+    uint8_t     enqTh;
+    uint8_t     deqTh;
+    uint8_t     numOfTasks;
+
+    SANITY_CHECK_RETURN(p_Fm, E_INVALID_HANDLE);
+
+    if(p_PortParams->portType == e_FM_PORT_TYPE_HOST_COMMAND)
+    {
+        ASSERT_COND(p_Fm->hcPortInitialized);
+        p_Fm->hcPortInitialized = FALSE;
+    }
+
+    p_Fm->portsTypes[hardwarePortId] = e_FM_PORT_TYPE_DUMMY;
+
+    tmpReg = GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_pp[hardwarePortId-1]);
+    /* free numOfTasks */
+    numOfTasks = (uint8_t)(((tmpReg & BMI_NUM_OF_TASKS_MASK) >> BMI_NUM_OF_TASKS_SHIFT) + 1);
+    ASSERT_COND(p_Fm->accumulatedNumOfTasks >= numOfTasks);
+    p_Fm->accumulatedNumOfTasks -= numOfTasks;
+
+    /* free numOfOpenDmas */
+    ASSERT_COND(p_Fm->accumulatedNumOfOpenDmas >= ((tmpReg & BMI_NUM_OF_DMAS_MASK) >> BMI_NUM_OF_DMAS_SHIFT));
+    p_Fm->accumulatedNumOfOpenDmas -= ((tmpReg & BMI_NUM_OF_DMAS_MASK) >> BMI_NUM_OF_DMAS_SHIFT);
+    tmpReg = GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_pfs[hardwarePortId-1]);
+    /* free sizeOfFifo */
+    ASSERT_COND(p_Fm->accumulatedFifoSize >= ((tmpReg & BMI_FIFO_SIZE_MASK) + 1)*BMI_FIFO_UNITS);
+    p_Fm->accumulatedFifoSize -= ((tmpReg & BMI_FIFO_SIZE_MASK) + 1)*BMI_FIFO_UNITS;
+
+    /* clear registers */
+    WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_pp[hardwarePortId-1], 0);
+    WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_pfs[hardwarePortId-1], 0);
+    //WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_ppid[hardwarePortId-1], 0);
+
+    if((p_PortParams->portType != e_FM_PORT_TYPE_RX) && (p_PortParams->portType != e_FM_PORT_TYPE_RX_10G))
+    /* for transmit & O/H ports */
+    {
+        tmpReg = 0;
+        /* update qmi ENQ/DEQ threshold */
+        p_Fm->accumulatedNumOfDeqTnums -= p_PortParams->deqPipelineDepth;
+
+        /* p_Fm->accumulatedNumOfDeqTnums is now smaller,
+           so we can enlarge enqTh */
+        enqTh = (uint8_t)(QMI_MAX_NUM_OF_TNUMS - p_Fm->accumulatedNumOfDeqTnums - 1);
+        tmpReg &= ~QMI_CFG_ENQ_MASK;
+        tmpReg |= ((uint32_t)enqTh << QMI_CFG_ENQ_SHIFT);
+
+         /* p_Fm->accumulatedNumOfDeqTnums is now smaller,
+           so we can reduce enqTh */
+        deqTh = (uint8_t)(p_Fm->accumulatedNumOfDeqTnums + 1);
+        tmpReg &= ~QMI_CFG_DEQ_MASK;
+        tmpReg |= (uint32_t)deqTh;
+
+        WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_gc, tmpReg);
+    }
+
+    return;
+}
+
+
+bool FmIsPortStalled(t_Handle h_Fm, uint8_t hardwarePortId)
+{
+    t_Fm        *p_Fm = (t_Fm*)h_Fm;
+    uint32_t    tmpReg;
+
+    SANITY_CHECK_RETURN_VALUE(p_Fm, E_INVALID_HANDLE, FALSE);
+
+    tmpReg = GET_UINT32(p_Fm->p_FmFpmRegs->fmfp_ps[hardwarePortId]);
+
+    return (bool)!!(tmpReg & FPM_PS_STALLED);
+}
+
+t_Error FmResumeStalledPort(t_Handle h_Fm, uint8_t hardwarePortId)
+{
+    t_Fm                    *p_Fm = (t_Fm*)h_Fm;
+    uint32_t                tmpReg;
+
+    /* Get port status */
+    if (!FmIsPortStalled(h_Fm, hardwarePortId))
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Port is not stalled"));
+
+    tmpReg = (uint32_t)((hardwarePortId << FPM_PORT_FM_CTL_PORTID_SHIFT) | FPM_PRC_REALSE_STALLED);
+    WRITE_UINT32(p_Fm->p_FmFpmRegs->fpmpr, tmpReg);
+
+    return E_OK;
+}
+
+t_Error FmResetMac(t_Handle h_Fm, e_FmMacType type, uint8_t macId)
+{
+    t_Fm        *p_Fm = (t_Fm*)h_Fm;
+    uint32_t    bitMask;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+
+    /* Get the relevant bit mask */
+    if (type == e_FM_MAC_10G)
+    {
+        switch(macId)
+        {
+            case(0):
+                bitMask = FPM_RSTC_10G0_RESET;
+                break;
+            default:
+                RETURN_ERROR(MINOR, E_INVALID_VALUE, ("Illegal MAC Id"));
+               break;
+        }
+    }
+    else
+    {
+        switch(macId)
+        {
+            case(0):
+                bitMask = FPM_RSTC_1G0_RESET;
+                break;
+            case(1):
+                bitMask = FPM_RSTC_1G1_RESET;
+                break;
+            case(2):
+                bitMask = FPM_RSTC_1G2_RESET;
+                break;
+            case(3):
+                bitMask = FPM_RSTC_1G3_RESET;
+                break;
+            default:
+                RETURN_ERROR(MINOR, E_INVALID_VALUE, ("Illegal MAC Id"));
+                break;
+        }
+    }
+
+    /* reset */
+    WRITE_UINT32(p_Fm->p_FmFpmRegs->fmrstc, bitMask);
+
+    return E_OK;
+}
+
+uint32_t    FmGetTimeStampPeriod(t_Handle h_Fm)
+{
+    t_Fm *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_VALUE(p_Fm, E_INVALID_HANDLE, 0);
+    SANITY_CHECK_RETURN_VALUE(p_Fm->timeStampPeriod, E_INVALID_HANDLE, 0);
+
+    return p_Fm->timeStampPeriod;
+}
+
+bool FmRamsEccIsExternalCtl(t_Handle h_Fm)
+{
+    t_Fm        *p_Fm = (t_Fm*)h_Fm;
+    uint32_t    tmpReg;
+
+    tmpReg = GET_UINT32(p_Fm->p_FmFpmRegs->fmrcr);
+    if(tmpReg & FPM_RAM_CTL_RAMS_ECC_EN_SRC_SEL)
+        return TRUE;
+    else
+        return FALSE;
+}
+
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+t_Error FmDumpPortRegs (t_Handle h_Fm,uint8_t hardwarePortId)
+{
+    t_Fm *p_Fm = (t_Fm *)h_Fm;
+
+    DECLARE_DUMP;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+
+    DUMP_TITLE(&p_Fm->p_FmBmiRegs->fmbm_pp[hardwarePortId-1], ("fmbm_pp for port %d", (hardwarePortId)));
+    DUMP_MEMORY(&p_Fm->p_FmBmiRegs->fmbm_pp[hardwarePortId-1], sizeof(uint32_t));
+
+    DUMP_TITLE(&p_Fm->p_FmBmiRegs->fmbm_pfs[hardwarePortId-1], ("fmbm_pfs for port %d", (hardwarePortId )));
+    DUMP_MEMORY(&p_Fm->p_FmBmiRegs->fmbm_pfs[hardwarePortId-1], sizeof(uint32_t));
+
+    DUMP_TITLE(&p_Fm->p_FmBmiRegs->fmbm_ppid[hardwarePortId-1], ("bm_ppid for port %d", (hardwarePortId)));
+    DUMP_MEMORY(&p_Fm->p_FmBmiRegs->fmbm_ppid[hardwarePortId-1], sizeof(uint32_t));
+
+    return E_OK;
+}
+#endif /* (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0)) */
+
+/****************************************/
+/*       API Init unit functions        */
+/****************************************/
+t_Handle FM_Config(t_FmParams *p_FmParam)
+{
+    t_Fm        *p_Fm;
+    uint8_t     i;
+    uint64_t    baseAddr = p_FmParam->baseAddr;
+
+    SANITY_CHECK_RETURN_VALUE(((p_FmParam->firmware.p_Code && p_FmParam->firmware.size) ||
+                               (!p_FmParam->firmware.p_Code && !p_FmParam->firmware.size)),
+                              E_INVALID_VALUE, NULL);
+
+    /* Allocate FM structure */
+    p_Fm = (t_Fm *) XX_Malloc(sizeof(t_Fm));
+    if (!p_Fm)
+    {
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM driver structure"));
+        return NULL;
+    }
+    memset(p_Fm, 0, sizeof(t_Fm));
+
+    /* Allocate the FM driver's parameters structure */
+    p_Fm->p_FmDriverParam = (t_FmDriverParam *)XX_Malloc(sizeof(t_FmDriverParam));
+    if (!p_Fm->p_FmDriverParam)
+    {
+        XX_Free(p_Fm);
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM driver parameters"));
+        return NULL;
+    }
+    memset(p_Fm->p_FmDriverParam, 0, sizeof(t_FmDriverParam));
+
+    /* Initialize FM parameters which will be kept by the driver */
+    p_Fm->fmId              = p_FmParam->fmId;
+    p_Fm->h_FmMuram         = p_FmParam->h_FmMuram;
+    p_Fm->h_App             = p_FmParam->h_App;
+    p_Fm->fmClkFreq         = p_FmParam->fmClkFreq;
+    p_Fm->f_Exceptions      = p_FmParam->f_Exceptions;
+    p_Fm->f_BusError        = p_FmParam->f_BusError;
+    p_Fm->p_FmFpmRegs       = CAST_UINT64_TO_POINTER_TYPE(t_FmFpmRegs, (baseAddr + FM_MM_FPM));
+    p_Fm->p_FmBmiRegs       = CAST_UINT64_TO_POINTER_TYPE(t_FmBmiRegs, (baseAddr + FM_MM_BMI));
+    p_Fm->p_FmQmiRegs       = CAST_UINT64_TO_POINTER_TYPE(t_FmQmiRegs, (baseAddr + FM_MM_QMI));
+    p_Fm->p_FmDmaRegs       = CAST_UINT64_TO_POINTER_TYPE(t_FmDmaRegs, (baseAddr + FM_MM_DMA));
+    p_Fm->baseAddr          = baseAddr;
+    p_Fm->irq               = p_FmParam->irq;
+    p_Fm->errIrq            = p_FmParam->errIrq;
+    p_Fm->hcPortInitialized = FALSE;
+    p_Fm->independentMode   = FALSE;
+    p_Fm->ramsEccEnable     = FALSE;
+    p_Fm->totalNumOfTasks   = DEFAULT_totalNumOfTasks;
+    p_Fm->totalFifoSize     = DEFAULT_totalFifoSize;
+    p_Fm->maxNumOfOpenDmas  = DEFAULT_maxNumOfOpenDmas;
+    p_Fm->extraFifoPoolSize     = FM_MAX_NUM_OF_RX_PORTS*BMI_FIFO_UNITS;
+
+    p_Fm->exceptions        = DEFAULT_exceptions;
+    for(i = 0;i<FM_MAX_NUM_OF_PORTS;i++)
+        p_Fm->portsTypes[i] = e_FM_PORT_TYPE_DUMMY;
+    /* Initialize FM driver parameters parameters (for initialization phase only) */
+    memcpy(p_Fm->p_FmDriverParam->liodnPerPartition, p_FmParam->liodnPerPartition, FM_MAX_NUM_OF_PARTITIONS);
+
+    /*p_Fm->p_FmDriverParam->numOfPartitions                      = p_FmParam->numOfPartitions;    */
+    p_Fm->p_FmDriverParam->enCounters                           = FALSE;
+
+    p_Fm->p_FmDriverParam->resetOnInit                          = DEFAULT_resetOnInit;
+
+    p_Fm->p_FmDriverParam->thresholds.dispLimit                 = DEFAULT_dispLimit;
+    p_Fm->p_FmDriverParam->thresholds.prsDispTh                 = DEFAULT_prsDispTh;
+    p_Fm->p_FmDriverParam->thresholds.plcrDispTh                = DEFAULT_plcrDispTh;
+    p_Fm->p_FmDriverParam->thresholds.kgDispTh                  = DEFAULT_kgDispTh;
+    p_Fm->p_FmDriverParam->thresholds.bmiDispTh                 = DEFAULT_bmiDispTh;
+    p_Fm->p_FmDriverParam->thresholds.qmiEnqDispTh              = DEFAULT_qmiEnqDispTh;
+    p_Fm->p_FmDriverParam->thresholds.qmiDeqDispTh              = DEFAULT_qmiDeqDispTh;
+    p_Fm->p_FmDriverParam->thresholds.fmCtl1DispTh               = DEFAULT_fmCtl1DispTh;
+    p_Fm->p_FmDriverParam->thresholds.fmCtl2DispTh               = DEFAULT_fmCtl2DispTh;
+
+    p_Fm->p_FmDriverParam->enTimeStamp                          = FALSE;
+
+    p_Fm->p_FmDriverParam->dmaStopOnBusError                    = DEFAULT_dmaStopOnBusError;
+    p_Fm->p_FmDriverParam->dmaBusProtect.privilegeBusProtect    = DEFAULT_privilegeBusProtect;
+    p_Fm->p_FmDriverParam->dmaBusProtect.busProtectType         = DEFAULT_busProtectionType;
+
+    p_Fm->p_FmDriverParam->dmaCacheOverride                     = DEFAULT_cacheOverride;
+    p_Fm->p_FmDriverParam->dmaAidMode                           = DEFAULT_aidMode;
+    p_Fm->p_FmDriverParam->dmaAidOverride                       = DEFAULT_aidOverride;
+    p_Fm->p_FmDriverParam->dmaAxiDbgNumOfBeats                  = DEFAULT_axiDbgNumOfBeats;
+    p_Fm->p_FmDriverParam->dmaCamNumOfEntries                   = DEFAULT_dmaCamNumOfEntries;
+    if(p_Fm->fmClkFreq)
+        p_Fm->p_FmDriverParam->dmaWatchdog                      = 0xffffffff/p_Fm->fmClkFreq; /* max possible */
+    else
+    {
+        XX_Free(p_Fm->p_FmDriverParam);
+        XX_Free(p_Fm);
+        REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("fmClkFreq can't be '0'"));
+        return NULL;
+    }
+    p_Fm->p_FmDriverParam->dmaCommQThresholds.clearEmergency               = DEFAULT_dmaCommQLow;
+    p_Fm->p_FmDriverParam->dmaCommQThresholds.assertEmergency              = DEFAULT_dmaCommQHigh;
+    p_Fm->p_FmDriverParam->dmaReadBufThresholds.clearEmergency             = DEFAULT_dmaReadIntBufLow;
+    p_Fm->p_FmDriverParam->dmaReadBufThresholds.assertEmergency            = DEFAULT_dmaReadIntBufHigh;
+    p_Fm->p_FmDriverParam->dmaWriteBufThresholds.clearEmergency            = DEFAULT_dmaWriteIntBufLow;
+    p_Fm->p_FmDriverParam->dmaWriteBufThresholds.assertEmergency           = DEFAULT_dmaWriteIntBufHigh;
+    p_Fm->p_FmDriverParam->dmaSosEmergency                      = DEFAULT_dmaSosEmergency;
+
+    p_Fm->p_FmDriverParam->dmaDbgCntMode                        = DEFAULT_dmaDbgCntMode;
+
+    p_Fm->p_FmDriverParam->dmaEnEmergency                       = FALSE;
+    p_Fm->p_FmDriverParam->dmaEnEmergencySmoother               = FALSE;
+    p_Fm->p_FmDriverParam->catastrophicErr                      = DEFAULT_catastrophicErr;
+    p_Fm->p_FmDriverParam->dmaErr                               = DEFAULT_dmaErr;
+    p_Fm->p_FmDriverParam->haltOnExternalActivation             = DEFAULT_haltOnExternalActivation;
+    p_Fm->p_FmDriverParam->haltOnUnrecoverableEccError          = DEFAULT_haltOnUnrecoverableEccError;
+
+    p_Fm->p_FmDriverParam->enIramTestMode                       = FALSE;
+    p_Fm->p_FmDriverParam->enMuramTestMode                      = FALSE;
+    p_Fm->p_FmDriverParam->externalEccRamsEnable                = DEFAULT_externalEccRamsEnable;
+
+     p_Fm->p_FmDriverParam->firmware.size = p_FmParam->firmware.size;
+     if (p_Fm->p_FmDriverParam->firmware.size)
+     {
+         p_Fm->p_FmDriverParam->firmware.p_Code = (uint32_t *)XX_Malloc(p_Fm->p_FmDriverParam->firmware.size);
+        if (!p_Fm->p_FmDriverParam->firmware.p_Code)
+        {
+            XX_Free(p_Fm->p_FmDriverParam);
+            XX_Free(p_Fm);
+            REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM firmware code"));
+            return NULL;
+        }
+         memcpy(p_Fm->p_FmDriverParam->firmware.p_Code ,p_FmParam->firmware.p_Code ,p_Fm->p_FmDriverParam->firmware.size);
+     }
+
+#ifdef CONFIG_GUEST_PARTITION
+    /* register to inter-core messaging mechanism */
+    memset(p_Fm->fmModuleName, 0, MODULE_NAME_SIZE);
+    if(Sprint (p_Fm->fmModuleName, "FM-%d",p_Fm->fmId) != 4)
+    {
+        XX_Free(p_Fm->p_FmDriverParam);
+        XX_Free(p_Fm);
+        REPORT_ERROR(MAJOR, E_INVALID_STATE, ("Sprint failed"));
+        return NULL;
+    }
+#endif /* CONFIG_GUEST_PARTITION */
+
+    return p_Fm;
+}
+
+/**************************************************************************//**
+ @Function      FM_Init
+
+ @Description   Initializes the FM module
+
+ @Param[in]     h_Fm - FM module descriptor
+
+ @Return        E_OK on success; Error code otherwise.
+*//***************************************************************************/
+t_Error FM_Init(t_Handle h_Fm)
+{
+    t_Fm                    *p_Fm = (t_Fm*)h_Fm;
+    t_FmDriverParam         *p_FmDriverParam = NULL;
+#ifdef FM_MASTER_PARTITION
+    t_Error                 err;
+#endif /* FM_MASTER_PARTITION */
+    uint32_t                tmpReg, cfgReg = 0;
+    int                     i;
+    uint64_t                fraction;
+    uint32_t                prescalar, integer, period;
+
+    SANITY_CHECK_RETURN_ERROR(h_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
+
+    CHECK_INIT_PARAMETERS(p_Fm, CheckFmParameters);
+
+    p_FmDriverParam = p_Fm->p_FmDriverParam;
+
+    if(p_FmDriverParam->resetOnInit)
+        WRITE_UINT32(p_Fm->p_FmFpmRegs->fmrstc, FPM_RSTC_FM_RESET);
+
+    /**********************/
+    /* Load patch to Iram */
+    /**********************/
+    if (p_Fm->p_FmDriverParam->firmware.p_Code)
+        LoadPatch(p_Fm);
+
+    /* General FM driver initialization */
+    p_Fm->fmMuramPhysBaseAddr = CAST_POINTER_TO_UINT64(XX_VirtToPhys(CAST_UINT64_TO_POINTER(p_Fm->baseAddr + FM_MM_MURAM)));
+    for(i=0;i<e_FM_EV_DUMMY_LAST;i++)
+        p_Fm->intrMng[i].f_Isr = UnimplementedIsr;
+    for(i=0;i<NUM_OF_FM_CTL_EVENT_REGS;i++)
+        p_Fm->f_FmCtlIsr[i] = UnimplementedFmCtlIsr;
+
+    /**********************/
+    /* Init DMA Registers */
+    /**********************/
+    /* clear status reg events */
+    tmpReg = (DMA_STATUS_BUS_ERR | DMA_STATUS_READ_ECC | DMA_STATUS_SYSTEM_WRITE_ECC | DMA_STATUS_FM_WRITE_ECC);
+  //  tmpReg |= (DMA_STATUS_SYSTEM_DPEXT_ECC | DMA_STATUS_FM_DPEXT_ECC | DMA_STATUS_SYSTEM_DPDAT_ECC | DMA_STATUS_FM_DPDAT_ECC | DMA_STATUS_FM_SPDAT_ECC);
+    WRITE_UINT32(p_Fm->p_FmDmaRegs->fmdmsr, GET_UINT32(p_Fm->p_FmDmaRegs->fmdmsr) | tmpReg);
+
+    /* configure mode register */
+    tmpReg = 0;
+    tmpReg |= p_FmDriverParam->dmaCacheOverride << DMA_MODE_CACHE_OR_SHIFT;
+    if(p_FmDriverParam->dmaAidOverride)
+    {
+        tmpReg |= DMA_MODE_AID_OR;
+    }
+    if (p_Fm->exceptions & FM_EX_DMA_BUS_ERROR)
+    {
+        tmpReg |= DMA_MODE_BER;
+    }
+    if ((p_Fm->exceptions & FM_EX_DMA_SYSTEM_WRITE_ECC) | (p_Fm->exceptions & FM_EX_DMA_READ_ECC) | (p_Fm->exceptions & FM_EX_DMA_FM_WRITE_ECC))
+    {
+        tmpReg |= DMA_MODE_ECC;
+    }
+    if(p_FmDriverParam->dmaStopOnBusError)
+        tmpReg |= DMA_MODE_SBER;
+    tmpReg |= (uint32_t)(p_FmDriverParam->dmaAxiDbgNumOfBeats - 1) << DMA_MODE_AXI_DBG_SHIFT;
+    if (p_FmDriverParam->dmaEnEmergency)
+    {
+        tmpReg |= p_FmDriverParam->dmaEmergency.emergencyBusSelect;
+        tmpReg |= p_FmDriverParam->dmaEmergency.emergencyLevel << DMA_MODE_EMERGENCY_LEVEL_SHIFT;
+        if(p_FmDriverParam->dmaEnEmergencySmoother)
+            WRITE_UINT32(p_Fm->p_FmDmaRegs->fmdmemsr, p_FmDriverParam->dmaEmergencySwitchCounter);
+     }
+    tmpReg |= ((p_FmDriverParam->dmaCamNumOfEntries/DMA_CAM_UNITS) - 1) << DMA_MODE_CEN_SHIFT;
+
+    if(p_FmDriverParam->dmaBusProtect.privilegeBusProtect)
+        tmpReg |= DMA_MODE_PRIVILEGE_PROT;
+    tmpReg |= DMA_MODE_SECURE_PROT;
+    tmpReg |= p_FmDriverParam->dmaBusProtect.busProtectType << DMA_MODE_BUS_PROT_SHIFT;
+    tmpReg |= p_FmDriverParam->dmaDbgCntMode << DMA_MODE_DBG_SHIFT;
+    tmpReg |= p_FmDriverParam->dmaAidMode << DMA_MODE_AID_MODE_SHIFT;
+
+    WRITE_UINT32(p_Fm->p_FmDmaRegs->fmdmmr, tmpReg);
+
+    /* configure thresholds register */
+    tmpReg = ((uint32_t)p_FmDriverParam->dmaCommQThresholds.assertEmergency << DMA_THRESH_COMMQ_SHIFT) |
+                ((uint32_t)p_FmDriverParam->dmaReadBufThresholds.assertEmergency << DMA_THRESH_READ_INT_BUF_SHIFT) |
+                ((uint32_t)p_FmDriverParam->dmaWriteBufThresholds.assertEmergency);
+    WRITE_UINT32(p_Fm->p_FmDmaRegs->fmdmtr, tmpReg);
+
+    /* configure hysteresis register */
+    tmpReg = ((uint32_t)p_FmDriverParam->dmaCommQThresholds.clearEmergency << DMA_THRESH_COMMQ_SHIFT) |
+                ((uint32_t)p_FmDriverParam->dmaReadBufThresholds.clearEmergency << DMA_THRESH_READ_INT_BUF_SHIFT) |
+                ((uint32_t)p_FmDriverParam->dmaWriteBufThresholds.clearEmergency);
+    WRITE_UINT32(p_Fm->p_FmDmaRegs->fmdmhy, tmpReg);
+
+    /* configure emergency threshold */
+    WRITE_UINT32(p_Fm->p_FmDmaRegs->fmdmsetr, p_FmDriverParam->dmaSosEmergency);
+
+    /* configure Watchdog */
+    WRITE_UINT32(p_Fm->p_FmDmaRegs->fmdmwcr, USEC_TO_CLK(p_FmDriverParam->dmaWatchdog, p_Fm->fmClkFreq));
+
+    /* Allocate MURAM for CAM */
+    p_Fm->camBaseAddr = CAST_POINTER_TO_UINT64(FM_MURAM_AllocMem(p_Fm->h_FmMuram,
+                                                                 (uint32_t)(p_FmDriverParam->dmaCamNumOfEntries*DMA_CAM_SIZEOF_ENTRY),
+                                                                 DMA_CAM_ALIGN));
+    if (!p_Fm->camBaseAddr )
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc for DMA CAM failed"));
+
+#ifndef VERIFICATION_SUPPORT
+    WRITE_BLOCK(CAST_UINT64_TO_POINTER_TYPE(uint8_t, p_Fm->camBaseAddr), 0, (uint32_t)(p_FmDriverParam->dmaCamNumOfEntries*DMA_CAM_SIZEOF_ENTRY));
+#endif /* VERIFICATION_SUPPORT */
+    /* VirtToPhys */
+    WRITE_UINT32(p_Fm->p_FmDmaRegs->fmdmebcr,
+                 (uint32_t)(CAST_POINTER_TO_UINT64(XX_VirtToPhys(CAST_UINT64_TO_POINTER(p_Fm->camBaseAddr))) -
+                            p_Fm->fmMuramPhysBaseAddr));
+
+    /* liodn-partitions */
+    for (i=0 ; i<FM_MAX_NUM_OF_PARTITIONS ; i+=2)
+    {
+        tmpReg = (((uint32_t)p_FmDriverParam->liodnPerPartition[i] << DMA_LIODN_SHIFT) |
+                    (uint32_t)p_FmDriverParam->liodnPerPartition[i+1]);
+        WRITE_UINT32(p_Fm->p_FmDmaRegs->fmdmplr[i/2], tmpReg);
+    }
+
+    /**********************/
+    /* Init FPM Registers */
+    /**********************/
+    tmpReg = (uint32_t)(p_FmDriverParam->thresholds.dispLimit << FPM_DISP_LIMIT_SHIFT);
+    WRITE_UINT32(p_Fm->p_FmFpmRegs->fpmflc, tmpReg);
+
+    tmpReg =   (((uint32_t)p_FmDriverParam->thresholds.prsDispTh  << FPM_THR1_PRS_SHIFT) |
+                ((uint32_t)p_FmDriverParam->thresholds.kgDispTh  << FPM_THR1_KG_SHIFT) |
+                ((uint32_t)p_FmDriverParam->thresholds.plcrDispTh  << FPM_THR1_PLCR_SHIFT) |
+                ((uint32_t)p_FmDriverParam->thresholds.bmiDispTh  << FPM_THR1_BMI_SHIFT));
+    WRITE_UINT32(p_Fm->p_FmFpmRegs->fpmdis1, tmpReg);
+
+    tmpReg =   (((uint32_t)p_FmDriverParam->thresholds.qmiEnqDispTh  << FPM_THR2_QMI_ENQ_SHIFT) |
+                ((uint32_t)p_FmDriverParam->thresholds.qmiDeqDispTh  << FPM_THR2_QMI_DEQ_SHIFT) |
+                ((uint32_t)p_FmDriverParam->thresholds.fmCtl1DispTh  << FPM_THR2_FM_CTL1_SHIFT) |
+                ((uint32_t)p_FmDriverParam->thresholds.fmCtl2DispTh  << FPM_THR2_FM_CTL2_SHIFT));
+    WRITE_UINT32(p_Fm->p_FmFpmRegs->fpmdis2, tmpReg);
+
+    /* define exceptions and error behavior */
+    tmpReg = 0;
+    /* Clear events */
+    tmpReg |= (FPM_EV_MASK_STALL | FPM_EV_MASK_DOUBLE_ECC | FPM_EV_MASK_SINGLE_ECC);
+    /* enable interrupts */
+    if(p_Fm->exceptions & FM_EX_FPM_STALL_ON_TASKS)
+    {
+        tmpReg |= FPM_EV_MASK_STALL_EN;
+    }
+    if(p_Fm->exceptions & FM_EX_FPM_SINGLE_ECC)
+    {
+        tmpReg |= FPM_EV_MASK_SINGLE_ECC_EN;
+    }
+    if(p_Fm->exceptions & FM_EX_FPM_DOUBLE_ECC)
+    {
+        tmpReg |= FPM_EV_MASK_DOUBLE_ECC_EN ;
+    }
+    tmpReg |= (p_Fm->p_FmDriverParam->catastrophicErr  << FPM_EV_MASK_CAT_ERR_SHIFT);
+    tmpReg |= (p_Fm->p_FmDriverParam->dmaErr << FPM_EV_MASK_DMA_ERR_SHIFT);
+    if(p_Fm->p_FmDriverParam->haltOnExternalActivation)
+        tmpReg |= FPM_EV_MASK_EXTERNAL_HALT;
+    if(p_Fm->p_FmDriverParam->haltOnUnrecoverableEccError)
+        tmpReg |= FPM_EV_MASK_ECC_ERR_HALT;
+    WRITE_UINT32(p_Fm->p_FmFpmRegs->fpmem, tmpReg);
+
+    /* clear all fmCtls event registers */
+    for(i=0;i<NUM_OF_FM_CTL_EVENT_REGS;i++)
+        WRITE_UINT32(p_Fm->p_FmFpmRegs->fpmcev[i], 0xFFFFFFFF);
+
+    /* timeStamp */
+    if(p_FmDriverParam->enTimeStamp)
+    {
+        period = p_Fm->timeStampPeriod;
+
+        /* calculate the prescalar, considering fmClkFreq is in Mhz, and
+        timeStampPeriod is in nanoseconds */
+        prescalar = (period * p_Fm->fmClkFreq)/1000;
+        if(!prescalar)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("timeStampPeriod is too small"));
+        if(prescalar > 256)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("timeStampPeriod is too large"));
+        WRITE_UINT32(p_Fm->p_FmFpmRegs->fpmtsc1, (uint32_t)((prescalar - 1) | FPM_TS_CTL_EN));
+
+        /* the FM HW allows to increase precision by enlarging timeStamp value by value
+        different than 1, possibly by fraction. */
+        integer  = (prescalar * 1000)/ (period * p_Fm->fmClkFreq); /* always 0 */
+        if(integer > 255)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("timeStampPeriod  is too large"));
+
+        /* Since the prescalar may have been be rounded down, we increase the timeStamp by
+        value smaller than the resolution required (and smaller than 1 when resolution is normally 1).
+        Here we calculate the fraction that will give us the nearest result.
+        Since we prefer not to use floating variables, we need to multiply by a large factor in
+        order to get a precise enough number. Since the HW implementation uses 24-bit-fixed-point
+        representation, a 16 bit fraction is used. In order to calculate the fraction value, we should
+        multiply the number by 2^16. We therefor use the 2^16 also as the factor for
+        the multiplication, and do not use another one for enlarging the fraction. */
+        fraction = ((uint64_t)((uint64_t)(prescalar * 1000) << 16)/ (period * p_Fm->fmClkFreq)) - (integer << 16);
+        ASSERT_COND((fraction & ~FPM_TS_FRACTION_MASK) == 0);
+        tmpReg = (integer << FPM_TS_INT_SHIFT) | (uint16_t)fraction;
+        WRITE_UINT32(p_Fm->p_FmFpmRegs->fpmtsc2, tmpReg);
+    }
+
+#ifndef VERIFICATION_SUPPORT
+    /* RAM ECC -  enable and clear events*/
+    /* first we need to clear all parser memory, as it is uninitialized and
+    may cause ECC errors */
+    for(i=0;i<FM_SW_PRS_SIZE;i+=4)
+        WRITE_UINT32(*CAST_UINT64_TO_POINTER_TYPE(uint32_t, (p_Fm->baseAddr + FM_MM_PRS + i)), 0);
+
+    tmpReg = 0;
+    if(p_Fm->exceptions & FM_EX_IRAM_ECC)
+    {
+        p_Fm->ramsEccEnable = TRUE;
+        tmpReg |= FPM_IRAM_ECC_ERR_EX_EN;
+    }
+    if(p_Fm->exceptions & FM_EX_NURAM_ECC)
+    {
+        p_Fm->ramsEccEnable = TRUE;
+        tmpReg |= FPM_MURAM_ECC_ERR_EX_EN;
+    }
+    WRITE_UINT32(p_Fm->p_FmFpmRegs->fmeie, tmpReg);
+
+    /* event bits */
+    tmpReg = (FPM_RAM_CTL_MURAM_ECC | FPM_RAM_CTL_IRAM_ECC);
+    /* enable ECC */
+    if(p_Fm->ramsEccEnable)
+        tmpReg |= (FPM_RAM_CTL_RAMS_ECC_EN | FPM_RAM_CTL_IRAM_ECC_EN);
+    /* Rams enable is not effected by the RCR bit, but by a COP configuration */
+    if(p_Fm->p_FmDriverParam->externalEccRamsEnable)
+        tmpReg |= FPM_RAM_CTL_RAMS_ECC_EN_SRC_SEL;
+
+    /* enable test mode */
+    if(p_FmDriverParam->enMuramTestMode)
+        tmpReg |= FPM_RAM_CTL_MURAM_TEST_ECC;
+    if(p_FmDriverParam->enIramTestMode)
+        tmpReg |= FPM_RAM_CTL_IRAM_TEST_ECC;
+    WRITE_UINT32(p_Fm->p_FmFpmRegs->fmrcr, tmpReg);
+#endif  /*  VERIFICATION_SUPPORT */
+
+    /**********************/
+    /* Init BMI Registers */
+    /**********************/
+
+    /* define common resources */
+    /* allocate MURAM for FIFO according to total size */
+    p_Fm->fifoBaseAddr = CAST_POINTER_TO_UINT64(FM_MURAM_AllocMem(p_Fm->h_FmMuram,
+                                                                  p_Fm->totalFifoSize,
+                                                                  BMI_FIFO_ALIGN));
+    if (!p_Fm->fifoBaseAddr)
+    {
+        FmFreeInitResources(p_Fm);
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc for FIFO failed"));
+    }
+
+    tmpReg = (uint32_t)(CAST_POINTER_TO_UINT64(XX_VirtToPhys(CAST_UINT32_TO_POINTER(p_Fm->fifoBaseAddr))) - p_Fm->fmMuramPhysBaseAddr);
+    tmpReg = tmpReg / BMI_FIFO_ALIGN;
+
+    tmpReg |= ((p_Fm->totalFifoSize/BMI_FIFO_UNITS - 1) << BMI_CFG1_FIFO_SIZE_SHIFT);
+    WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_cfg1, tmpReg);
+
+    tmpReg =  ((uint32_t)(p_Fm->totalNumOfTasks - 1) << BMI_CFG2_TASKS_SHIFT );
+    /* num of DMA's will be dynamically updated when each port is set */
+    WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_cfg2, tmpReg);
+
+    /* define unmaskable exceptions, enable and clear events */
+    tmpReg = 0;
+    WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_ievr, (BMI_ERR_INTR_EN_LIST_RAM_ECC|BMI_ERR_INTR_EN_PIPELINE_ECC|BMI_ERR_INTR_EN_STATISTICS_RAM_ECC));
+    if(p_Fm->exceptions & FM_EX_BMI_LIST_RAM_ECC)
+    {
+        tmpReg |= BMI_ERR_INTR_EN_LIST_RAM_ECC;
+    }
+    if(p_Fm->exceptions & FM_EX_BMI_PIPELINE_ECC)
+    {
+        tmpReg |= BMI_ERR_INTR_EN_PIPELINE_ECC;
+    }
+    if(p_Fm->exceptions & FM_EX_BMI_STATISTICS_RAM_ECC)
+    {
+        tmpReg |= BMI_ERR_INTR_EN_STATISTICS_RAM_ECC;
+    }
+    WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_ier, tmpReg);
+
+    /**********************/
+    /* Init QMI Registers */
+    /**********************/
+     /* Clear error interrupt events */
+    WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_eie, (QMI_ERR_INTR_EN_DOUBLE_ECC | QMI_ERR_INTR_EN_DEQ_FROM_DEF));
+    tmpReg = 0;
+    if(p_Fm->exceptions & FM_EX_QMI_DEQ_FROM_DEFQ)
+    {
+        tmpReg |= QMI_ERR_INTR_EN_DEQ_FROM_DEF;
+    }
+    if(p_Fm->exceptions & FM_EX_QMI_DOUBLE_ECC)
+    {
+        tmpReg |= QMI_ERR_INTR_EN_DOUBLE_ECC;
+    }
+    /* enable events */
+    WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_eien, tmpReg);
+
+    tmpReg = 0;
+    /* Clear interrupt events */
+    WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_ie, QMI_INTR_EN_SINGLE_ECC);
+    if(p_Fm->exceptions & FM_EX_QMI_SINGLE_ECC)
+    {
+        tmpReg |= QMI_INTR_EN_SINGLE_ECC;
+    }
+    /* enable events */
+    WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_ien, tmpReg);
+
+    /* clear & enable global counters  - calculate reg and save for later,
+       because it's the same reg for QMI enable */
+    if(p_Fm->p_FmDriverParam->enCounters)
+        cfgReg = QMI_CFG_EN_COUNTERS;
+
+    cfgReg |= (uint32_t)(((QMI_DEF_TNUMS_THRESH) << 8) |  (uint32_t)QMI_DEF_TNUMS_THRESH);
+
+    if (p_Fm->irq != NO_IRQ)
+    {
+        XX_SetIntr(p_Fm->irq, FM_Isr, p_Fm);
+        XX_EnableIntr(p_Fm->irq);
+    }
+
+    if (p_Fm->errIrq != NO_IRQ)
+    {
+        XX_SetIntr(p_Fm->errIrq, FM_Isr, p_Fm);
+        XX_EnableIntr(p_Fm->errIrq);
+    }
+
+#ifdef FM_MASTER_PARTITION
+    err = XX_RegisterMessageHandler(p_Fm->fmModuleName, FmHandleIpcMsg, p_Fm);
+    if(err)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+#endif /* FM_MASTER_PARTITION */
+
+    /**********************/
+    /* Enable all modules */
+    /**********************/
+    WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_init, BMI_INIT_START);
+    WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_gc, cfgReg | QMI_CFG_ENQ_EN | QMI_CFG_DEQ_EN);
+
+    if (p_Fm->p_FmDriverParam->firmware.p_Code)
+    {
+        XX_Free(p_Fm->p_FmDriverParam->firmware.p_Code);
+        p_Fm->p_FmDriverParam->firmware.p_Code = NULL;
+    }
+
+    XX_Free(p_Fm->p_FmDriverParam);
+    p_Fm->p_FmDriverParam = NULL;
+
+    return E_OK;
+}
+
+/**************************************************************************//**
+ @Function      FM_Free
+
+ @Description   Frees all resources that were assigned to FM module.
+
+                Calling this routine invalidates the descriptor.
+
+ @Param[in]     h_Fm - FM module descriptor
+
+ @Return        E_OK on success; Error code otherwise.
+*//***************************************************************************/
+t_Error FM_Free(t_Handle h_Fm)
+{
+   t_Fm        *p_Fm = (t_Fm*)h_Fm;
+
+    if (!p_Fm)
+        return ERROR_CODE(E_INVALID_HANDLE);
+
+#ifdef FM_MASTER_PARTITION
+    XX_UnregisterMessageHandler(p_Fm->fmModuleName);
+#endif /* FM_MASTER_PARTITION */
+
+    if(p_Fm->p_FmDriverParam)
+    {
+        XX_Free(p_Fm->p_FmDriverParam);
+        p_Fm->p_FmDriverParam = NULL;
+    }
+    FmFreeInitResources(p_Fm);
+
+    XX_Free(p_Fm);
+
+    return E_OK;
+}
+
+/*************************************************/
+/*       API Advanced Init unit functions        */
+/*************************************************/
+
+t_Error FM_ConfigResetOnInit(t_Handle h_Fm, bool enable)
+{
+
+    t_Fm *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
+
+    p_Fm->p_FmDriverParam->resetOnInit = enable;
+
+    return E_OK;
+}
+
+#if 0
+t_Error FM_ConfigIndependentMode(t_Handle h_Fm)
+{
+    t_Fm *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
+
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+    return E_OK;
+}
+#endif /* 0 */
+
+t_Error FM_ConfigTotalNumOfTasks(t_Handle h_Fm, uint8_t totalNumOfTasks)
+{
+    t_Fm *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
+
+    p_Fm->totalNumOfTasks = totalNumOfTasks;
+
+    return E_OK;
+}
+
+t_Error FM_ConfigTotalFifoSize(t_Handle h_Fm, uint32_t totalFifoSize)
+{
+    t_Fm *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
+
+    p_Fm->totalFifoSize = totalFifoSize;
+
+    return E_OK;
+}
+
+t_Error FM_ConfigMaxNumOfOpenDmas(t_Handle h_Fm, uint8_t maxNumOfOpenDmas)
+{
+    t_Fm *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
+
+    p_Fm->maxNumOfOpenDmas = maxNumOfOpenDmas;
+
+    return E_OK;
+}
+
+t_Error FM_ConfigThresholds(t_Handle h_Fm, t_FmThresholds *p_FmThresholds)
+{
+    t_Fm *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
+
+    memcpy(&p_Fm->p_FmDriverParam->thresholds, p_FmThresholds, sizeof(t_FmThresholds));
+
+    return E_OK;
+}
+
+t_Error FM_ConfigTimeStamp(t_Handle h_Fm, uint32_t timeStampPeriod)
+{
+    t_Fm *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
+
+    p_Fm->p_FmDriverParam->enTimeStamp = TRUE;
+    p_Fm->timeStampPeriod = timeStampPeriod;
+
+    return E_OK;
+}
+
+t_Error FM_ConfigDmaBusProtect(t_Handle h_Fm, t_FmDmaBusProtect *p_FmDmaBusProtect)
+{
+    t_Fm *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
+
+    memcpy(&p_Fm->p_FmDriverParam->dmaBusProtect, p_FmDmaBusProtect, sizeof(t_FmDmaBusProtect));
+
+    return E_OK;
+}
+
+t_Error FM_ConfigDmaCacheOverride(t_Handle h_Fm, e_FmDmaCacheOverride cacheOverride)
+{
+    t_Fm *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
+
+    p_Fm->p_FmDriverParam->dmaCacheOverride = cacheOverride;
+
+    return E_OK;
+}
+
+t_Error FM_ConfigDmaAidOverride(t_Handle h_Fm, bool aidOverride)
+{
+    t_Fm *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
+
+    p_Fm->p_FmDriverParam->dmaAidOverride = aidOverride;
+
+    return E_OK;
+}
+
+t_Error FM_ConfigDmaAidMode(t_Handle h_Fm, e_FmDmaAidMode aidMode)
+{
+    t_Fm *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
+
+    p_Fm->p_FmDriverParam->dmaAidMode = aidMode;
+
+    return E_OK;
+}
+
+t_Error FM_ConfigDmaAxiDbgNumOfBeats(t_Handle h_Fm, uint8_t axiDbgNumOfBeats)
+{
+    t_Fm *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
+
+    p_Fm->p_FmDriverParam->dmaAxiDbgNumOfBeats = axiDbgNumOfBeats;
+
+    return E_OK;
+}
+
+t_Error FM_ConfigDmaCamNumOfEntries(t_Handle h_Fm, uint8_t numOfEntries)
+{
+    t_Fm *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
+
+    p_Fm->p_FmDriverParam->dmaCamNumOfEntries = numOfEntries;
+
+    return E_OK;
+}
+
+t_Error FM_ConfigDmaWatchdog(t_Handle h_Fm, uint32_t watchdogValue)
+{
+    t_Fm *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
+
+    p_Fm->p_FmDriverParam->dmaWatchdog = watchdogValue;
+
+    return E_OK;
+}
+
+t_Error FM_ConfigDmaWriteBufThresholds(t_Handle h_Fm, t_FmDmaThresholds *p_FmDmaThresholds)
+
+{
+    t_Fm *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
+
+    memcpy(&p_Fm->p_FmDriverParam->dmaWriteBufThresholds, p_FmDmaThresholds, sizeof(t_FmDmaThresholds));
+
+    return E_OK;
+}
+
+t_Error FM_ConfigDmaCommQThresholds(t_Handle h_Fm, t_FmDmaThresholds *p_FmDmaThresholds)
+{
+    t_Fm *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
+
+    memcpy(&p_Fm->p_FmDriverParam->dmaCommQThresholds, p_FmDmaThresholds, sizeof(t_FmDmaThresholds));
+
+    return E_OK;
+}
+
+t_Error FM_ConfigDmaReadBufThresholds(t_Handle h_Fm, t_FmDmaThresholds *p_FmDmaThresholds)
+{
+    t_Fm *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
+
+    memcpy(&p_Fm->p_FmDriverParam->dmaReadBufThresholds, p_FmDmaThresholds, sizeof(t_FmDmaThresholds));
+
+    return E_OK;
+}
+
+t_Error FM_ConfigDmaEmergency(t_Handle h_Fm, t_FmDmaEmergency *p_Emergency)
+{
+    t_Fm *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
+
+    p_Fm->p_FmDriverParam->dmaEnEmergency = TRUE;
+    memcpy(&p_Fm->p_FmDriverParam->dmaEmergency, p_Emergency, sizeof(t_FmDmaEmergency));
+
+    return E_OK;
+}
+
+t_Error FM_ConfigDmaEmergencySmoother(t_Handle h_Fm, uint32_t emergencyCnt)
+{
+    t_Fm *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
+
+    if(!p_Fm->p_FmDriverParam->dmaEnEmergency)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("FM_ConfigEnDmaEmergencySmoother may be called only after FM_ConfigEnDmaEmergency"));
+
+    p_Fm->p_FmDriverParam->dmaEnEmergencySmoother = TRUE;
+    p_Fm->p_FmDriverParam->dmaEmergencySwitchCounter = emergencyCnt;
+
+    return E_OK;
+}
+
+t_Error FM_ConfigDmaDbgCounter(t_Handle h_Fm, e_FmDmaDbgCntMode fmDmaDbgCntMode)
+{
+    t_Fm *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
+
+    p_Fm->p_FmDriverParam->dmaDbgCntMode = fmDmaDbgCntMode;
+
+    return E_OK;
+}
+
+t_Error FM_ConfigDmaStopOnBusErr(t_Handle h_Fm, bool stop)
+{
+    t_Fm *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
+
+    p_Fm->p_FmDriverParam->dmaStopOnBusError = stop;
+
+    return E_OK;
+}
+
+t_Error FM_ConfigDmaSosEmergencyThreshold(t_Handle h_Fm, uint32_t dmaSosEmergency)
+{
+    t_Fm *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
+
+    p_Fm->p_FmDriverParam->dmaSosEmergency = dmaSosEmergency;
+
+    return E_OK;
+}
+
+t_Error FM_ConfigEnableCounters(t_Handle h_Fm)
+{
+    t_Fm *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
+
+    p_Fm->p_FmDriverParam->enCounters = TRUE;
+
+    return E_OK;
+}
+
+t_Error FM_ConfigDmaErr(t_Handle h_Fm, e_FmDmaErr dmaErr)
+{
+    t_Fm *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
+
+    p_Fm->p_FmDriverParam->dmaErr = dmaErr;
+
+    return E_OK;
+}
+
+t_Error FM_ConfigCatastrophicErr(t_Handle h_Fm, e_FmCatastrophicErr catastrophicErr)
+{
+    t_Fm *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
+
+    p_Fm->p_FmDriverParam->catastrophicErr = catastrophicErr;
+
+    return E_OK;
+}
+
+t_Error FM_ConfigEnableMuramTestMode(t_Handle h_Fm)
+{
+    t_Fm *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
+
+    p_Fm->p_FmDriverParam->enMuramTestMode = TRUE;
+
+    return E_OK;
+}
+
+t_Error FM_ConfigEnableIramTestMode(t_Handle h_Fm)
+{
+    t_Fm *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
+
+    p_Fm->p_FmDriverParam->enIramTestMode = TRUE;
+
+    return E_OK;
+}
+
+t_Error FM_ConfigHaltOnExternalActivation(t_Handle h_Fm, bool enable)
+{
+    t_Fm *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
+
+    p_Fm->p_FmDriverParam->haltOnExternalActivation = enable;
+
+    return E_OK;
+}
+
+t_Error FM_ConfigHaltOnUnrecoverableEccError(t_Handle h_Fm, bool enable)
+{
+    t_Fm *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
+
+    p_Fm->p_FmDriverParam->haltOnUnrecoverableEccError = enable;
+
+    return E_OK;
+}
+
+t_Error FM_ConfigException(t_Handle h_Fm, e_FmExceptions exception, bool enable)
+{
+    t_Fm        *p_Fm = (t_Fm*)h_Fm;
+    uint32_t    bitMask = 0;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+
+    GET_EXCEPTION_FLAG(bitMask, exception);
+    if(bitMask)
+    {
+        if (enable)
+            p_Fm->exceptions |= bitMask;
+        else
+            p_Fm->exceptions &= ~bitMask;
+   }
+    else
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Undefined exception"));
+
+    return E_OK;
+}
+
+t_Error FM_ConfigExternalEccRamsEnable(t_Handle h_Fm, bool enable)
+{
+    t_Fm        *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+
+    p_Fm->p_FmDriverParam->externalEccRamsEnable = enable;
+
+    return E_OK;
+}
+
+/****************************************************/
+/*       API Run-time Control uint functions        */
+/****************************************************/
+t_Handle FM_GetPcdHandle(t_Handle h_Fm)
+{
+    SANITY_CHECK_RETURN_VALUE(h_Fm, E_INVALID_HANDLE, NULL);
+    SANITY_CHECK_RETURN_VALUE(!((t_Fm*)h_Fm)->p_FmDriverParam, E_INVALID_STATE, NULL);
+
+    return ((t_Fm*)h_Fm)->h_Pcd;
+}
+
+void FM_Isr(t_Handle h_Fm)
+{
+    t_Fm                    *p_Fm = (t_Fm*)h_Fm;
+    uint32_t                pending;
+
+    SANITY_CHECK_RETURN(h_Fm, E_INVALID_HANDLE);
+
+    /* error interrupts */
+    pending = GET_UINT32(p_Fm->p_FmFpmRegs->fmepi);
+    if(pending) /* remove if separate sources */
+    {
+        if(pending & ERR_INTR_EN_BMI)
+            BmiErrEvent(p_Fm);
+        if(pending & ERR_INTR_EN_QMI)
+            QmiErrEvent(p_Fm);
+        if(pending & ERR_INTR_EN_FPM)
+            FpmErrEvent(p_Fm);
+        if(pending & ERR_INTR_EN_DMA)
+            DmaErrEvent(p_Fm);
+        if(pending & ERR_INTR_EN_IRAM)
+            IramErrIntr(p_Fm);
+        if(pending & ERR_INTR_EN_MURAM)
+            MuramErrIntr(p_Fm);
+        if(pending & ERR_INTR_EN_PRS)
+            p_Fm->intrMng[e_FM_EV_ERR_PRS].f_Isr(p_Fm->intrMng[e_FM_EV_ERR_PRS].h_SrcHandle);
+        if(pending & ERR_INTR_EN_PLCR)
+            p_Fm->intrMng[e_FM_EV_ERR_PLCR].f_Isr(p_Fm->intrMng[e_FM_EV_ERR_PLCR].h_SrcHandle);
+        if(pending & ERR_INTR_EN_KG)
+            p_Fm->intrMng[e_FM_EV_ERR_KG].f_Isr(p_Fm->intrMng[e_FM_EV_ERR_KG].h_SrcHandle);
+        if(pending & ERR_INTR_EN_1G_MAC0)
+            p_Fm->intrMng[e_FM_EV_ERR_1G_MAC0].f_Isr(p_Fm->intrMng[e_FM_EV_ERR_1G_MAC0].h_SrcHandle);
+        if(pending & ERR_INTR_EN_1G_MAC1)
+            p_Fm->intrMng[e_FM_EV_ERR_1G_MAC1].f_Isr(p_Fm->intrMng[e_FM_EV_ERR_1G_MAC1].h_SrcHandle);
+        if(pending & ERR_INTR_EN_1G_MAC2)
+            p_Fm->intrMng[e_FM_EV_ERR_1G_MAC2].f_Isr(p_Fm->intrMng[e_FM_EV_ERR_1G_MAC2].h_SrcHandle);
+        if(pending & ERR_INTR_EN_1G_MAC3)
+            p_Fm->intrMng[e_FM_EV_ERR_1G_MAC3].f_Isr(p_Fm->intrMng[e_FM_EV_ERR_1G_MAC3].h_SrcHandle);
+        if(pending & ERR_INTR_EN_10G_MAC0)
+            p_Fm->intrMng[e_FM_EV_ERR_10G_MAC0].f_Isr(p_Fm->intrMng[e_FM_EV_ERR_10G_MAC0].h_SrcHandle);
+    }
+
+    /* normal interrupts */
+    pending = GET_UINT32(p_Fm->p_FmFpmRegs->fmnpi);
+    if(pending) /* remove if separate sources */
+    {
+        if(pending & INTR_EN_BMI)
+            REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("BMI Event - undefined!"));
+        if(pending & INTR_EN_QMI)
+            QmiEvent(p_Fm);
+        if(pending & INTR_EN_PRS)
+            p_Fm->intrMng[e_FM_EV_PRS].f_Isr(p_Fm->intrMng[e_FM_EV_PRS].h_SrcHandle);
+        if(pending & INTR_EN_PLCR)
+            p_Fm->intrMng[e_FM_EV_PLCR].f_Isr(p_Fm->intrMng[e_FM_EV_PLCR].h_SrcHandle);
+        if(pending & INTR_EN_KG)
+            p_Fm->intrMng[e_FM_EV_KG].f_Isr(p_Fm->intrMng[e_FM_EV_KG].h_SrcHandle);
+        if(pending & FPM_EVENT_FM_CTL)
+            FmCtlEvent(p_Fm, pending  & FPM_EVENT_FM_CTL);
+        if(pending & INTR_EN_1G_MAC1)
+            p_Fm->intrMng[e_FM_EV_1G_MAC1].f_Isr(p_Fm->intrMng[e_FM_EV_1G_MAC1].h_SrcHandle);
+        if(pending & INTR_EN_1G_MAC2)
+            p_Fm->intrMng[e_FM_EV_1G_MAC2].f_Isr(p_Fm->intrMng[e_FM_EV_1G_MAC2].h_SrcHandle);
+        if(pending & INTR_EN_1G_MAC3)
+            p_Fm->intrMng[e_FM_EV_1G_MAC3].f_Isr(p_Fm->intrMng[e_FM_EV_1G_MAC3].h_SrcHandle);
+        if(pending & INTR_EN_1G_MAC0_TMR)
+            p_Fm->intrMng[e_FM_EV_1G_MAC0_TMR].f_Isr(p_Fm->intrMng[e_FM_EV_1G_MAC0_TMR].h_SrcHandle);
+        if(pending & INTR_EN_1G_MAC1_TMR)
+            p_Fm->intrMng[e_FM_EV_1G_MAC1_TMR].f_Isr(p_Fm->intrMng[e_FM_EV_1G_MAC1_TMR].h_SrcHandle);
+        if(pending & INTR_EN_1G_MAC2_TMR)
+            p_Fm->intrMng[e_FM_EV_1G_MAC2_TMR].f_Isr(p_Fm->intrMng[e_FM_EV_1G_MAC2_TMR].h_SrcHandle);
+        if(pending & INTR_EN_1G_MAC3_TMR)
+            p_Fm->intrMng[e_FM_EV_1G_MAC3_TMR].f_Isr(p_Fm->intrMng[e_FM_EV_1G_MAC3_TMR].h_SrcHandle);
+        if(pending & INTR_EN_TMR)
+            p_Fm->intrMng[e_FM_EV_TMR].f_Isr(p_Fm->intrMng[e_FM_EV_TMR].h_SrcHandle);
+    }
+}
+
+t_Error FM_SetPortsBandwidth(t_Handle h_Fm, t_PortsParam *p_PortsBandwidth)
+{
+    t_Fm        *p_Fm = (t_Fm*)h_Fm;
+    int         j, i;
+    uint8_t     sum;
+    uint8_t     hardwarePortId=0;
+    uint8_t     portPrecent[FM_MAX_NUM_OF_PORTS];
+    uint32_t    tmpReg;
+    uint8_t     relativePortId, remain, shift, weight, maxPercent = 0;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_Fm->p_FmDriverParam, E_INVALID_STATE);
+
+    memset(portPrecent, 0, FM_MAX_NUM_OF_PORTS);
+    for(i=0;i<NUM_OF_PORT_TYPES;i++)
+        for(j=0;j<MAX_NUM_OF_PORTS_PER_TYPE;j++)
+        {
+            if((*p_PortsBandwidth)[i][j])
+            {
+                GET_GLOBAL_PORTID(hardwarePortId, i,j);
+                portPrecent[hardwarePortId] = (*p_PortsBandwidth)[i][j];
+            }
+        }
+
+    /* check that all ports add up to 100% */
+    sum = 0;
+    for (i=0;i<FM_MAX_NUM_OF_PORTS;i++)
+        sum +=portPrecent[i];
+    if (sum != 100)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Sum of ports bandwidth differ from 100%"));
+
+    tmpReg = 0;
+    /* find highest precent */
+    for (i=0;i<FM_MAX_NUM_OF_PORTS;i++)
+    {
+        if (portPrecent[i] > maxPercent)
+            maxPercent = portPrecent[i];
+    }
+
+    /* calculate weight for each port */
+    for (i=0;i<FM_MAX_NUM_OF_PORTS;i++)
+    {
+        weight = (uint8_t)((portPrecent[i] * PORT_MAX_WEIGHT )/maxPercent);
+        remain = (uint8_t)((portPrecent[i] * PORT_MAX_WEIGHT ) - maxPercent*weight);
+
+        /* round the remain to add 1 if it is bigger than 0.5 */
+        if (remain*2 > maxPercent)
+            weight++;
+
+        /* find the location of this port within the register */
+        relativePortId = (uint8_t)(i % 8);
+        shift = (uint8_t)(32-4*(relativePortId+1));
+
+
+        if(weight)
+            /* Add this port to tmpReg */
+            tmpReg |= ((weight-1) << shift);
+
+        /* each 8 ports result in one register, write this register */
+        if (relativePortId == 7 && tmpReg)
+        {
+            WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_arb[i/8], tmpReg);
+            tmpReg = 0;
+        }
+    }
+
+
+    return E_OK;
+}
+
+t_Error FM_EnableRamsEcc(t_Handle h_Fm)
+{
+    t_Fm        *p_Fm = (t_Fm*)h_Fm;
+    uint32_t    tmpReg;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
+
+    tmpReg = GET_UINT32(p_Fm->p_FmFpmRegs->fmrcr);
+    if(tmpReg & FPM_RAM_CTL_RAMS_ECC_EN_SRC_SEL)
+        RETURN_ERROR(MINOR, E_INVALID_STATE,("Rams ECC is configured to be controlled through JTAG"));
+
+    if(p_Fm->ramsEccEnable)
+        return E_OK;
+    else
+    {
+        WRITE_UINT32(p_Fm->p_FmFpmRegs->fmrcr, tmpReg | (FPM_RAM_CTL_RAMS_ECC_EN | FPM_RAM_CTL_IRAM_ECC_EN));
+        p_Fm->ramsEccEnable = TRUE;
+    }
+
+    return E_OK;
+}
+
+t_Error FM_DisableRamsEcc(t_Handle h_Fm)
+{
+    t_Fm        *p_Fm = (t_Fm*)h_Fm;
+    uint32_t    tmpReg;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
+
+    tmpReg = GET_UINT32(p_Fm->p_FmFpmRegs->fmrcr);
+    if(tmpReg & FPM_RAM_CTL_RAMS_ECC_EN_SRC_SEL)
+        RETURN_ERROR(MINOR, E_INVALID_STATE,("Rams ECC is configured to be controlled through JTAG"));
+
+    if(!p_Fm->ramsEccEnable)
+        return E_OK;
+    else
+    {
+        WRITE_UINT32(p_Fm->p_FmFpmRegs->fmrcr, tmpReg & ~(FPM_RAM_CTL_RAMS_ECC_EN | FPM_RAM_CTL_IRAM_ECC_EN));
+        p_Fm->ramsEccEnable = FALSE;
+    }
+
+    return E_OK;
+}
+
+t_Error FM_SetException(t_Handle h_Fm, e_FmExceptions exception, bool enable)
+{
+    t_Fm        *p_Fm = (t_Fm*)h_Fm;
+    uint32_t    bitMask = 0;
+    uint32_t    tmpReg;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_Fm->p_FmDriverParam, E_INVALID_STATE);
+
+    GET_EXCEPTION_FLAG(bitMask, exception);
+    if(bitMask)
+    {
+        if (enable)
+            p_Fm->exceptions |= bitMask;
+        else
+            p_Fm->exceptions &= ~bitMask;
+
+        switch(exception)
+        {
+             case(e_FM_EX_DMA_BUS_ERROR):
+                tmpReg = GET_UINT32(p_Fm->p_FmDmaRegs->fmdmmr);
+                if(enable)
+                    tmpReg |= DMA_MODE_BER;
+                else
+                    tmpReg &= ~DMA_MODE_BER;
+                /* disable bus error */
+                WRITE_UINT32(p_Fm->p_FmDmaRegs->fmdmmr, tmpReg);
+                break;
+             case(e_FM_EX_DMA_READ_ECC):
+             case(e_FM_EX_DMA_SYSTEM_WRITE_ECC):
+             case(e_FM_EX_DMA_FM_WRITE_ECC):
+                tmpReg = GET_UINT32(p_Fm->p_FmDmaRegs->fmdmmr);
+                if(enable)
+                    tmpReg |= DMA_MODE_ECC;
+                else
+                    tmpReg &= ~DMA_MODE_ECC;
+                WRITE_UINT32(p_Fm->p_FmDmaRegs->fmdmmr, tmpReg);
+                break;
+             case(e_FM_EX_FPM_STALL_ON_TASKS):
+                tmpReg = GET_UINT32(p_Fm->p_FmFpmRegs->fpmem);
+                if(enable)
+                    tmpReg |= FPM_EV_MASK_STALL_EN;
+                else
+                    tmpReg &= ~FPM_EV_MASK_STALL_EN;
+                WRITE_UINT32(p_Fm->p_FmFpmRegs->fpmem, tmpReg);
+                break;
+             case(e_FM_EX_FPM_SINGLE_ECC):
+                tmpReg = GET_UINT32(p_Fm->p_FmFpmRegs->fpmem);
+                if(enable)
+                    tmpReg |= FPM_EV_MASK_SINGLE_ECC_EN;
+                else
+                    tmpReg &= ~FPM_EV_MASK_SINGLE_ECC_EN;
+                WRITE_UINT32(p_Fm->p_FmFpmRegs->fpmem, tmpReg);
+                break;
+            case( e_FM_EX_FPM_DOUBLE_ECC):
+                tmpReg = GET_UINT32(p_Fm->p_FmFpmRegs->fpmem);
+                if(enable)
+                    tmpReg |= FPM_EV_MASK_DOUBLE_ECC_EN;
+                else
+                    tmpReg &= ~FPM_EV_MASK_DOUBLE_ECC_EN;
+                WRITE_UINT32(p_Fm->p_FmFpmRegs->fpmem, tmpReg);
+                break;
+            case( e_FM_EX_QMI_SINGLE_ECC):
+                tmpReg = GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_ien);
+                if(enable)
+                    tmpReg |= QMI_INTR_EN_SINGLE_ECC;
+                else
+                    tmpReg &= ~QMI_INTR_EN_SINGLE_ECC;
+                WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_ien, tmpReg);
+                break;
+             case(e_FM_EX_QMI_DOUBLE_ECC):
+                tmpReg = GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_eien);
+                if(enable)
+                    tmpReg |= QMI_ERR_INTR_EN_DOUBLE_ECC;
+                else
+                    tmpReg &= ~QMI_ERR_INTR_EN_DOUBLE_ECC;
+                WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_eien, tmpReg);
+                break;
+             case(e_FM_EX_QMI_DEQ_FROM_DEFQ):
+                tmpReg = GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_eien);
+                if(enable)
+                    tmpReg |= QMI_ERR_INTR_EN_DEQ_FROM_DEF;
+                else
+                    tmpReg &= ~QMI_ERR_INTR_EN_DEQ_FROM_DEF;
+                WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_eien, tmpReg);
+                break;
+             case(e_FM_EX_BMI_LIST_RAM_ECC):
+                tmpReg = GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_ier);
+                if(enable)
+                    tmpReg |= BMI_ERR_INTR_EN_LIST_RAM_ECC;
+                else
+                    tmpReg &= ~BMI_ERR_INTR_EN_LIST_RAM_ECC;
+                WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_ier, tmpReg);
+                break;
+             case(e_FM_EX_BMI_PIPELINE_ECC):
+                tmpReg = GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_ier);
+                if(enable)
+                    tmpReg |= BMI_ERR_INTR_EN_PIPELINE_ECC;
+                else
+                    tmpReg &= ~BMI_ERR_INTR_EN_PIPELINE_ECC;
+                WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_ier, tmpReg);
+                break;
+              case(e_FM_EX_BMI_STATISTICS_RAM_ECC):
+                tmpReg = GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_ier);
+                if(enable)
+                    tmpReg |= BMI_ERR_INTR_EN_STATISTICS_RAM_ECC;
+                else
+                    tmpReg &= ~BMI_ERR_INTR_EN_STATISTICS_RAM_ECC;
+                WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_ier, tmpReg);
+                break;
+            case(e_FM_EX_IRAM_ECC):
+                tmpReg = GET_UINT32(p_Fm->p_FmFpmRegs->fmeie);
+                if(enable)
+                {
+                    /* enable ECC if not enabled */
+                    if(!p_Fm->ramsEccEnable)
+                    {
+
+                        WRITE_UINT32(p_Fm->p_FmFpmRegs->fmrcr, GET_UINT32(p_Fm->p_FmFpmRegs->fmrcr) |
+                                                                (FPM_RAM_CTL_IRAM_ECC_EN | FPM_RAM_CTL_RAMS_ECC_EN));
+                        p_Fm->ramsEccEnable = TRUE;
+                    }
+                    /* enable ECC interrupts */
+                    tmpReg |= FPM_IRAM_ECC_ERR_EX_EN;
+                }
+                else
+                    tmpReg &= FPM_IRAM_ECC_ERR_EX_EN;
+                WRITE_UINT32(p_Fm->p_FmFpmRegs->fmeie, tmpReg);
+                break;
+
+             case(e_FM_EX_MURAM_ECC):
+                tmpReg = GET_UINT32(p_Fm->p_FmFpmRegs->fmeie);
+                if(enable)
+                {
+                    /* enable ECC if not enabled */
+                    if(!FmRamsEccIsExternalCtl(p_Fm))
+                        FM_EnableRamsEcc(p_Fm);
+                    /* enable ECC interrupts */
+                    tmpReg |= FPM_MURAM_ECC_ERR_EX_EN;
+                }
+                else
+                    tmpReg &= FPM_MURAM_ECC_ERR_EX_EN;
+                WRITE_UINT32(p_Fm->p_FmFpmRegs->fmeie, tmpReg);
+
+                break;
+            default:
+                RETURN_ERROR(MINOR, E_INVALID_SELECTION, NO_MSG);
+
+        }
+    }
+    else
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Undefined exception"));
+
+    return E_OK;
+}
+
+void FM_GetRevision(t_Handle h_Fm, t_FmRevisionInfo *p_FmRevisionInfo)
+{
+    t_Fm        *p_Fm = (t_Fm*)h_Fm;
+    uint32_t    tmpReg;
+
+    SANITY_CHECK_RETURN(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN(!p_Fm->p_FmDriverParam, E_INVALID_STATE);
+
+    /* read revision register 1 */
+    tmpReg = GET_UINT32(p_Fm->p_FmFpmRegs->fm_ip_rev_1);
+    p_FmRevisionInfo->majorRev = (uint8_t)((tmpReg & FPM_REV1_MAJOR_MASK) >> FPM_REV1_MAJOR_SHIFT);
+    p_FmRevisionInfo->minorRev = (uint8_t)((tmpReg & FPM_REV1_MINOR_MASK) >> FPM_REV1_MINOR_SHIFT);
+}
+
+uint32_t FM_GetTimeStamp(t_Handle h_Fm)
+{
+    t_Fm *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_VALUE(p_Fm, E_INVALID_HANDLE, 0);
+    SANITY_CHECK_RETURN_VALUE(!p_Fm->p_FmDriverParam, E_INVALID_STATE, 0);
+
+    /* check that timeStamp is enabled */
+    if (!(GET_UINT32(p_Fm->p_FmFpmRegs->fpmtsc1) & FPM_TS_CTL_EN))
+    {
+        REPORT_ERROR(MINOR, E_INVALID_STATE, ("Time Stamp was not enabled"));
+        return 0;
+    }
+
+    return GET_UINT32(p_Fm->p_FmFpmRegs->fpmtsp);;
+}
+
+uint32_t  FM_GetCounter(t_Handle h_Fm, e_FmCounters counter)
+{
+    t_Fm *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_VALUE(p_Fm, E_INVALID_HANDLE, 0);
+    SANITY_CHECK_RETURN_VALUE(!p_Fm->p_FmDriverParam, E_INVALID_STATE, 0);
+
+        switch(counter)
+    {
+        case(e_FM_COUNTERS_ENQ_TOTAL_FRAME):
+            return GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_etfc);
+        break;
+        case(e_FM_COUNTERS_DEQ_TOTAL_FRAME):
+            return GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_dtfc);
+        case(e_FM_COUNTERS_DEQ_0):
+            return GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_dc0);
+        case(e_FM_COUNTERS_DEQ_1):
+            return GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_dc1);
+        case(e_FM_COUNTERS_DEQ_2):
+            return GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_dc2);
+        case(e_FM_COUNTERS_DEQ_3):
+            return GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_dc3);
+        case(e_FM_COUNTERS_DEQ_FROM_DEFAULT):
+            return GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_dfdc);
+        case(e_FM_COUNTERS_DEQ_FROM_CONTEXT):
+            return GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_dfcc);
+        case(e_FM_COUNTERS_DEQ_FROM_FD):
+            return GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_dffc);
+        case(e_FM_COUNTERS_DEQ_CONFIRM):
+            return GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_dcc);
+        case(e_FM_COUNTERS_SEMAPHOR_ENTRY_FULL_REJECT):
+            return GET_UINT32(p_Fm->p_FmDmaRegs->fmdmsefrc);
+        case(e_FM_COUNTERS_SEMAPHOR_QUEUE_FULL_REJECT):
+            return GET_UINT32(p_Fm->p_FmDmaRegs->fmdmsqfrc);
+        case(e_FM_COUNTERS_SEMAPHOR_SYNC_REJECT):
+            return GET_UINT32(p_Fm->p_FmDmaRegs->fmdmssrc);
+        default:
+            break;
+    }
+    /* should never get here */
+    ASSERT_COND(FALSE);
+
+    return 0;
+}
+
+t_Error  FM_SetCounter(t_Handle h_Fm, e_FmCounters counter, uint32_t val)
+{
+    t_Fm *p_Fm = (t_Fm*)h_Fm;
+
+   SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+   SANITY_CHECK_RETURN_ERROR(!p_Fm->p_FmDriverParam, E_INVALID_STATE);
+
+    /* When applicable (when there is an 'enable counters' bit,
+    check that counters are enabled */
+    switch(counter)
+    {
+        case(e_FM_COUNTERS_ENQ_TOTAL_FRAME):
+        case(e_FM_COUNTERS_DEQ_TOTAL_FRAME):
+        case(e_FM_COUNTERS_DEQ_0):
+        case(e_FM_COUNTERS_DEQ_1):
+        case(e_FM_COUNTERS_DEQ_2):
+        case(e_FM_COUNTERS_DEQ_3):
+        case(e_FM_COUNTERS_DEQ_FROM_DEFAULT):
+        case(e_FM_COUNTERS_DEQ_FROM_CONTEXT):
+        case(e_FM_COUNTERS_DEQ_FROM_FD):
+        case(e_FM_COUNTERS_DEQ_CONFIRM):
+            if(!(GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_gc) & QMI_CFG_EN_COUNTERS))
+                RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter was not enabled"));
+            break;
+        default:
+            break;
+    }
+
+    /* Set counter */
+    switch(counter)
+    {
+        case(e_FM_COUNTERS_ENQ_TOTAL_FRAME):
+            WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_etfc, val);
+            break;
+        case(e_FM_COUNTERS_DEQ_TOTAL_FRAME):
+            WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_dtfc, val);
+            break;
+        case(e_FM_COUNTERS_DEQ_0):
+            WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_dc0, val);
+            break;
+        case(e_FM_COUNTERS_DEQ_1):
+            WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_dc1, val);
+            break;
+        case(e_FM_COUNTERS_DEQ_2):
+            WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_dc2, val);
+            break;
+        case(e_FM_COUNTERS_DEQ_3):
+            WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_dc3, val);
+            break;
+        case(e_FM_COUNTERS_DEQ_FROM_DEFAULT):
+            WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_dfdc, val);
+            break;
+        case(e_FM_COUNTERS_DEQ_FROM_CONTEXT):
+            WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_dfcc, val);
+            break;
+        case(e_FM_COUNTERS_DEQ_FROM_FD):
+            WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_dffc, val);
+            break;
+        case(e_FM_COUNTERS_DEQ_CONFIRM):
+            WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_dcc, val);
+            break;
+        case(e_FM_COUNTERS_SEMAPHOR_ENTRY_FULL_REJECT):
+            WRITE_UINT32(p_Fm->p_FmDmaRegs->fmdmsefrc, val);
+            break;
+        case(e_FM_COUNTERS_SEMAPHOR_QUEUE_FULL_REJECT):
+            WRITE_UINT32(p_Fm->p_FmDmaRegs->fmdmsqfrc, val);
+            break;
+        case(e_FM_COUNTERS_SEMAPHOR_SYNC_REJECT):
+            WRITE_UINT32(p_Fm->p_FmDmaRegs->fmdmssrc, val);
+            break;
+        default:
+            break;
+    }
+
+    return E_OK;
+}
+
+void FM_DmaEmergencyCtrl(t_Handle h_Fm, e_FmDmaMuramPort muramPort, bool enable)
+{
+    t_Fm *p_Fm = (t_Fm*)h_Fm;
+    uint32_t    bitMask;
+
+    SANITY_CHECK_RETURN(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN(!p_Fm->p_FmDriverParam, E_INVALID_STATE);
+
+    bitMask = (uint32_t)((muramPort==e_FM_DMA_MURAM_PORT_WRITE) ? DMA_MODE_EMERGENCY_WRITE : DMA_MODE_EMERGENCY_READ);
+
+    if(enable)
+        WRITE_UINT32(p_Fm->p_FmDmaRegs->fmdmmr, GET_UINT32(p_Fm->p_FmDmaRegs->fmdmmr) | bitMask);
+    else /* disable */
+        WRITE_UINT32(p_Fm->p_FmDmaRegs->fmdmmr, GET_UINT32(p_Fm->p_FmDmaRegs->fmdmmr) & ~bitMask);
+
+    return;
+}
+
+void FM_SetDmaExtBusPri(t_Handle h_Fm, e_FmDmaExtBusPri pri)
+{
+    t_Fm *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN(!p_Fm->p_FmDriverParam, E_INVALID_STATE);
+
+    WRITE_UINT32(p_Fm->p_FmDmaRegs->fmdmmr, GET_UINT32(p_Fm->p_FmDmaRegs->fmdmmr) | ((uint32_t)pri << DMA_MODE_BUS_PRI_SHIFT) );
+
+    return;
+}
+
+void FM_GetDmaStatus(t_Handle h_Fm, t_FmDmaStatus *p_FmDmaStatus)
+{
+    t_Fm        *p_Fm = (t_Fm*)h_Fm;
+    uint32_t    tmpReg;
+
+    SANITY_CHECK_RETURN(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN(!p_Fm->p_FmDriverParam, E_INVALID_STATE);
+
+    tmpReg = GET_UINT32(p_Fm->p_FmDmaRegs->fmdmsr);
+
+    p_FmDmaStatus->cmqNotEmpty = (bool)(tmpReg & DMA_STATUS_CMD_QUEUE_NOT_EMPTY);
+    p_FmDmaStatus->busError = (bool)(tmpReg & DMA_STATUS_BUS_ERR);
+    p_FmDmaStatus->readBufEccError = (bool)(tmpReg & DMA_STATUS_READ_ECC);
+    p_FmDmaStatus->writeBufEccSysError = (bool)(tmpReg & DMA_STATUS_SYSTEM_WRITE_ECC);
+    p_FmDmaStatus->writeBufEccFmError = (bool)(tmpReg & DMA_STATUS_FM_WRITE_ECC);
+    return;
+}
+
+t_Error FM_ForceIntr (t_Handle h_Fm, e_FmExceptions exception)
+{
+    t_Fm *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_Fm->p_FmDriverParam, E_INVALID_STATE);
+
+    switch(exception)
+    {
+        case e_FM_EX_QMI_DEQ_FROM_DEFQ:
+            if (!(p_Fm->exceptions & FM_EX_QMI_DEQ_FROM_DEFQ))
+                RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception is masked"));
+            WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_eif, QMI_ERR_INTR_EN_DEQ_FROM_DEF);
+            break;
+        case e_FM_EX_QMI_SINGLE_ECC:
+            if (!(p_Fm->exceptions & FM_EX_QMI_SINGLE_ECC))
+                RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception is masked"));
+            WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_if, QMI_INTR_EN_SINGLE_ECC);
+            break;
+        case e_FM_EX_QMI_DOUBLE_ECC:
+            if (!(p_Fm->exceptions & FM_EX_QMI_DOUBLE_ECC))
+                RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception is masked"));
+            WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_eif, QMI_ERR_INTR_EN_DOUBLE_ECC);
+            break;
+        case e_FM_EX_BMI_LIST_RAM_ECC:
+            if (!(p_Fm->exceptions & FM_EX_BMI_LIST_RAM_ECC))
+                RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception is masked"));
+            WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_ifr, BMI_ERR_INTR_EN_LIST_RAM_ECC);
+            break;
+        case e_FM_EX_BMI_PIPELINE_ECC:
+            if (!(p_Fm->exceptions & FM_EX_BMI_PIPELINE_ECC))
+                RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception is masked"));
+            WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_ifr, BMI_ERR_INTR_EN_PIPELINE_ECC);
+            break;
+        case e_FM_EX_BMI_STATISTICS_RAM_ECC:
+            if (!(p_Fm->exceptions & FM_EX_BMI_STATISTICS_RAM_ECC))
+                RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception is masked"));
+            WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_ifr, BMI_ERR_INTR_EN_STATISTICS_RAM_ECC);
+            break;
+        default:
+            RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception may not be forced"));
+    }
+
+    return E_OK;
+}
+
+void FM_Resume(t_Handle h_Fm)
+{
+    t_Fm            *p_Fm = (t_Fm*)h_Fm;
+    uint32_t        tmpReg;
+
+    SANITY_CHECK_RETURN(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN(!p_Fm->p_FmDriverParam, E_INVALID_STATE);
+
+    tmpReg  = GET_UINT32(p_Fm->p_FmFpmRegs->fpmem);
+    /* clear tmpReg event bits in order not to clear standing events */
+    tmpReg &= ~(FPM_EV_MASK_DOUBLE_ECC | FPM_EV_MASK_STALL | FPM_EV_MASK_SINGLE_ECC);
+    WRITE_UINT32(p_Fm->p_FmFpmRegs->fpmem, tmpReg | FPM_EV_MASK_RELEASE_FM);
+}
+
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+t_Error FM_DumpRegs(t_Handle h_Fm)
+{
+    t_Fm    *p_Fm = (t_Fm *)h_Fm;
+    uint8_t i = 0;
+
+    DECLARE_DUMP;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_Fm->p_FmDriverParam, E_INVALID_STATE);
+
+    DUMP_SUBTITLE(("\n"));
+    DUMP_TITLE(p_Fm->p_FmFpmRegs, ("FmFpmRegs Regs"));
+
+    DUMP_VAR(p_Fm->p_FmFpmRegs,fpmtnc);
+    DUMP_VAR(p_Fm->p_FmFpmRegs,fpmpr);
+    DUMP_VAR(p_Fm->p_FmFpmRegs,brkc);
+    DUMP_VAR(p_Fm->p_FmFpmRegs,fpmflc);
+    DUMP_VAR(p_Fm->p_FmFpmRegs,fpmdis1);
+    DUMP_VAR(p_Fm->p_FmFpmRegs,fpmdis2);
+    DUMP_VAR(p_Fm->p_FmFpmRegs,fmepi);
+    DUMP_VAR(p_Fm->p_FmFpmRegs,fmeie);
+
+    DUMP_TITLE(&p_Fm->p_FmFpmRegs->fpmrev, ("fpmrev"));
+    DUMP_SUBSTRUCT_ARRAY(i, 8)
+    {
+        DUMP_MEMORY(&p_Fm->p_FmFpmRegs->fpmrev[i], sizeof(uint32_t));
+    }
+
+    DUMP_TITLE(&p_Fm->p_FmFpmRegs->fpmmsk, ("fpmmsk"));
+    DUMP_SUBSTRUCT_ARRAY(i, 8)
+    {
+        DUMP_MEMORY(&p_Fm->p_FmFpmRegs->fpmmsk[i], sizeof(uint32_t));
+    }
+
+    DUMP_SUBTITLE(("\n"));
+    DUMP_VAR(p_Fm->p_FmFpmRegs,fpmtsc1);
+    DUMP_VAR(p_Fm->p_FmFpmRegs,fpmtsc2);
+    DUMP_VAR(p_Fm->p_FmFpmRegs,fpmtsp);
+    DUMP_VAR(p_Fm->p_FmFpmRegs,fpmtsf);
+    DUMP_VAR(p_Fm->p_FmFpmRegs,fmrcr);
+    DUMP_VAR(p_Fm->p_FmFpmRegs,fpmextc);
+    DUMP_VAR(p_Fm->p_FmFpmRegs,fpmext1);
+    DUMP_VAR(p_Fm->p_FmFpmRegs,fpmext2);
+
+    DUMP_TITLE(&p_Fm->p_FmFpmRegs->fpmdrd, ("fpmdrd"));
+    DUMP_SUBSTRUCT_ARRAY(i, 16)
+    {
+        DUMP_MEMORY(&p_Fm->p_FmFpmRegs->fpmdrd[i], sizeof(uint32_t));
+    }
+
+    DUMP_SUBTITLE(("\n"));
+    DUMP_VAR(p_Fm->p_FmFpmRegs,fpmdra);
+    DUMP_VAR(p_Fm->p_FmFpmRegs,fm_ip_rev_1);
+    DUMP_VAR(p_Fm->p_FmFpmRegs,fm_ip_rev_2);
+    DUMP_VAR(p_Fm->p_FmFpmRegs,fmrstc);
+    DUMP_VAR(p_Fm->p_FmFpmRegs,fmcld);
+    DUMP_VAR(p_Fm->p_FmFpmRegs,fmnpi);
+    DUMP_VAR(p_Fm->p_FmFpmRegs,fpmem);
+
+    DUMP_TITLE(&p_Fm->p_FmFpmRegs->fpmcev, ("fpmcev"));
+    DUMP_SUBSTRUCT_ARRAY(i, 8)
+    {
+        DUMP_MEMORY(&p_Fm->p_FmFpmRegs->fpmcev[i], sizeof(uint32_t));
+    }
+
+    DUMP_TITLE(&p_Fm->p_FmFpmRegs->fmfp_ps, ("fmfp_ps"));
+    DUMP_SUBSTRUCT_ARRAY(i, 64)
+    {
+        DUMP_MEMORY(&p_Fm->p_FmFpmRegs->fmfp_ps[i], sizeof(uint32_t));
+    }
+
+
+    DUMP_TITLE(p_Fm->p_FmDmaRegs, ("p_FmDmaRegs Regs"));
+    DUMP_VAR(p_Fm->p_FmDmaRegs,fmdmsr);
+    DUMP_VAR(p_Fm->p_FmDmaRegs,fmdmmr);
+    DUMP_VAR(p_Fm->p_FmDmaRegs,fmdmtr);
+    DUMP_VAR(p_Fm->p_FmDmaRegs,fmdmhy);
+    DUMP_VAR(p_Fm->p_FmDmaRegs,fmdmsetr);
+    DUMP_VAR(p_Fm->p_FmDmaRegs,fmdmtah);
+    DUMP_VAR(p_Fm->p_FmDmaRegs,fmdmtal);
+    DUMP_VAR(p_Fm->p_FmDmaRegs,fmdmtcid);
+    DUMP_VAR(p_Fm->p_FmDmaRegs,fmdmra);
+    DUMP_VAR(p_Fm->p_FmDmaRegs,fmdmrd);
+    DUMP_VAR(p_Fm->p_FmDmaRegs,fmdmwcr);
+    DUMP_VAR(p_Fm->p_FmDmaRegs,fmdmebcr);
+    DUMP_VAR(p_Fm->p_FmDmaRegs,fmdmccqdr);
+    DUMP_VAR(p_Fm->p_FmDmaRegs,fmdmccqvr1);
+    DUMP_VAR(p_Fm->p_FmDmaRegs,fmdmccqvr2);
+    DUMP_VAR(p_Fm->p_FmDmaRegs,fmdmcqvr3);
+    DUMP_VAR(p_Fm->p_FmDmaRegs,fmdmcqvr4);
+    DUMP_VAR(p_Fm->p_FmDmaRegs,fmdmcqvr5);
+    DUMP_VAR(p_Fm->p_FmDmaRegs,fmdmsefrc);
+    DUMP_VAR(p_Fm->p_FmDmaRegs,fmdmsqfrc);
+    DUMP_VAR(p_Fm->p_FmDmaRegs,fmdmssrc);
+    DUMP_VAR(p_Fm->p_FmDmaRegs,fmdmdcr);
+
+    DUMP_TITLE(&p_Fm->p_FmDmaRegs->fmdmplr, ("fmdmplr"));
+
+    DUMP_SUBSTRUCT_ARRAY(i, FM_MAX_NUM_OF_PARTITIONS/2)
+    {
+        DUMP_MEMORY(&p_Fm->p_FmDmaRegs->fmdmplr[i], sizeof(uint32_t));
+    }
+
+    DUMP_TITLE(p_Fm->p_FmBmiRegs, ("p_FmBmiRegs COMMON Regs"));
+    DUMP_VAR(p_Fm->p_FmBmiRegs,fmbm_init);
+    DUMP_VAR(p_Fm->p_FmBmiRegs,fmbm_cfg1);
+    DUMP_VAR(p_Fm->p_FmBmiRegs,fmbm_cfg2);
+    DUMP_VAR(p_Fm->p_FmBmiRegs,fmbm_ievr);
+    DUMP_VAR(p_Fm->p_FmBmiRegs,fmbm_ier);
+
+    DUMP_TITLE(&p_Fm->p_FmBmiRegs->fmbm_arb, ("fmbm_arb"));
+    DUMP_SUBSTRUCT_ARRAY(i, 8)
+    {
+        DUMP_MEMORY(&p_Fm->p_FmBmiRegs->fmbm_arb[i], sizeof(uint32_t));
+    }
+
+
+    DUMP_TITLE(p_Fm->p_FmQmiRegs, ("p_FmQmiRegs COMMON Regs"));
+    DUMP_VAR(p_Fm->p_FmQmiRegs,fmqm_gc);
+    DUMP_VAR(p_Fm->p_FmQmiRegs,fmqm_eie);
+    DUMP_VAR(p_Fm->p_FmQmiRegs,fmqm_eien);
+    DUMP_VAR(p_Fm->p_FmQmiRegs,fmqm_eif);
+    DUMP_VAR(p_Fm->p_FmQmiRegs,fmqm_ie);
+    DUMP_VAR(p_Fm->p_FmQmiRegs,fmqm_ien);
+    DUMP_VAR(p_Fm->p_FmQmiRegs,fmqm_if);
+    DUMP_VAR(p_Fm->p_FmQmiRegs,fmqm_gs);
+    DUMP_VAR(p_Fm->p_FmQmiRegs,fmqm_ts);
+    DUMP_VAR(p_Fm->p_FmQmiRegs,fmqm_etfc);
+
+    return E_OK;
+}
+#endif /* (defined(DEBUG_ERRORS) && ... */
+
+
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/fm.h b/drivers/net/dpa/NetCommSw/Peripherals/FM/fm.h
new file mode 100644
index 0000000..6174fed
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/fm.h
@@ -0,0 +1,629 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/******************************************************************************
+ @File          fm.h
+
+ @Description   FM internal structures and definitions.
+*//***************************************************************************/
+#ifndef __FM_H
+#define __FM_H
+
+#include "error_ext.h"
+#include "std_ext.h"
+#include "fm_ext.h"
+
+
+#define FM_MAX_NUM_OF_PORTS         64
+
+/**************************************************************************//**
+ @Description       Exceptions
+*//***************************************************************************/
+#define FM_EX_DMA_BUS_ERROR                 0x80000000      /**< DMA bus error. */
+#define FM_EX_DMA_READ_ECC                  0x40000000
+#define FM_EX_DMA_SYSTEM_WRITE_ECC          0x20000000
+#define FM_EX_DMA_FM_WRITE_ECC              0x10000000
+#define FM_EX_FPM_STALL_ON_TASKS            0x08000000      /**< Stall of tasks on FPM */
+#define FM_EX_FPM_SINGLE_ECC                0x04000000      /**< Single ECC on FPM */
+#define FM_EX_FPM_DOUBLE_ECC                0x02000000
+#define FM_EX_QMI_SINGLE_ECC                0x01000000      /**< Single ECC on FPM */
+#define FM_EX_QMI_DEQ_FROM_DEFQ             0x00800000      /**< Dequeu from default queue id */
+#define FM_EX_QMI_DOUBLE_ECC                0x00400000
+#define FM_EX_BMI_LIST_RAM_ECC              0x00200000
+#define FM_EX_BMI_PIPELINE_ECC              0x00100000
+#define FM_EX_BMI_STATISTICS_RAM_ECC        0x00080000
+#define FM_EX_IRAM_ECC                      0x00040000
+#define FM_EX_NURAM_ECC                      0x00020000
+
+#define GET_EXCEPTION_FLAG(bitMask, exception)       switch(exception){ \
+    case e_FM_EX_DMA_BUS_ERROR:                                         \
+        bitMask = FM_EX_DMA_BUS_ERROR; break;                           \
+    case e_FM_EX_DMA_READ_ECC:                                          \
+        bitMask = FM_EX_DMA_READ_ECC; break;                            \
+    case e_FM_EX_DMA_SYSTEM_WRITE_ECC:                                  \
+        bitMask = FM_EX_DMA_SYSTEM_WRITE_ECC; break;                    \
+    case e_FM_EX_DMA_FM_WRITE_ECC:                                      \
+        bitMask = FM_EX_DMA_FM_WRITE_ECC; break;                        \
+    case e_FM_EX_FPM_STALL_ON_TASKS:                                    \
+        bitMask = FM_EX_FPM_STALL_ON_TASKS; break;                      \
+    case e_FM_EX_FPM_SINGLE_ECC:                                        \
+        bitMask = FM_EX_FPM_SINGLE_ECC; break;                          \
+    case e_FM_EX_FPM_DOUBLE_ECC:                                        \
+        bitMask = FM_EX_FPM_DOUBLE_ECC; break;                          \
+    case e_FM_EX_QMI_SINGLE_ECC:                                        \
+        bitMask = FM_EX_QMI_SINGLE_ECC; break;                          \
+    case e_FM_EX_QMI_DOUBLE_ECC:                                        \
+        bitMask = FM_EX_QMI_DOUBLE_ECC; break;                          \
+    case e_FM_EX_QMI_DEQ_FROM_DEFQ:                                     \
+        bitMask = FM_EX_QMI_DEQ_FROM_DEFQ; break;                       \
+    case e_FM_EX_BMI_LIST_RAM_ECC:                                      \
+        bitMask = FM_EX_BMI_LIST_RAM_ECC; break;                        \
+    case e_FM_EX_BMI_PIPELINE_ECC:                                      \
+        bitMask = FM_EX_BMI_PIPELINE_ECC; break;                        \
+    case e_FM_EX_BMI_STATISTICS_RAM_ECC:                                \
+        bitMask = FM_EX_BMI_STATISTICS_RAM_ECC; break;                  \
+    case e_FM_EX_IRAM_ECC:                                              \
+        bitMask = FM_EX_IRAM_ECC; break;                                \
+    case e_FM_EX_MURAM_ECC:                                             \
+        bitMask = FM_EX_NURAM_ECC; break;                               \
+    default: bitMask = 0;break;}
+
+/**************************************************************************//**
+ @Description       defaults
+*//***************************************************************************/
+#define DEFAULT_exceptions              (FM_EX_DMA_BUS_ERROR            |\
+                                        FM_EX_DMA_READ_ECC              |\
+                                        FM_EX_DMA_SYSTEM_WRITE_ECC      |\
+                                        FM_EX_DMA_FM_WRITE_ECC          |\
+                                        FM_EX_FPM_STALL_ON_TASKS        |\
+                                        FM_EX_FPM_SINGLE_ECC            |\
+                                        FM_EX_FPM_DOUBLE_ECC            |\
+                                        FM_EX_QMI_SINGLE_ECC            |\
+                                        FM_EX_QMI_DEQ_FROM_DEFQ         |\
+                                        FM_EX_QMI_DOUBLE_ECC            |\
+                                        FM_EX_BMI_LIST_RAM_ECC          |\
+                                        FM_EX_BMI_PIPELINE_ECC          |\
+                                        FM_EX_BMI_STATISTICS_RAM_ECC    |\
+                                        FM_EX_IRAM_ECC                  |\
+                                        FM_EX_NURAM_ECC                 )
+#define DEFAULT_totalNumOfTasks         96
+#define DEFAULT_totalFifoSize           (128*KILOBYTE)
+#define DEFAULT_maxNumOfOpenDmas      24
+#define DEFAULT_eccEnable               FALSE
+#define DEFAULT_dispLimit               16
+#define DEFAULT_prsDispTh               16
+#define DEFAULT_plcrDispTh              16
+#define DEFAULT_kgDispTh                16
+#define DEFAULT_bmiDispTh               16
+#define DEFAULT_qmiEnqDispTh            16
+#define DEFAULT_qmiDeqDispTh            16
+#define DEFAULT_fmCtl1DispTh             16
+#define DEFAULT_fmCtl2DispTh             16
+#define DEFAULT_cacheOverride           e_FM_DMA_NO_CACHE_OR
+#define DEFAULT_aidOverride             FALSE
+#define DEFAULT_aidMode                 e_FM_DMA_AID_OUT_PORT_ID
+#define DEFAULT_secureBusProtect        FALSE
+#define DEFAULT_privilegeBusProtect     FALSE
+#define DEFAULT_dmaStopOnBusError       FALSE
+#define DEFAULT_busProtectionType       e_FM_DMA_DATA_BUS_PROT
+#define DEFAULT_stopAtBusError          FALSE
+#define DEFAULT_axiDbgNumOfBeats        1
+#define DEFAULT_dmaCamNumOfEntries      32
+#define DEFAULT_dmaCommQLow             16
+#define DEFAULT_dmaCommQHigh            24
+#define DEFAULT_dmaReadIntBufLow        64
+#define DEFAULT_dmaReadIntBufHigh       96
+#define DEFAULT_dmaWriteIntBufLow       64
+#define DEFAULT_dmaWriteIntBufHigh      96
+#define DEFAULT_dmaSosEmergency         0
+#define DEFAULT_dmaDbgCntMode           e_FM_DMA_DBG_NO_CNT
+#define DEFAULT_catastrophicErr         e_FM_CATASTROPHIC_ERR_STALL_PORT
+#define DEFAULT_dmaErr                  e_FM_DMA_ERR_CATASTROPHIC
+#define DEFAULT_resetOnInit             FALSE
+#define DEFAULT_haltOnExternalActivation        FALSE
+#define DEFAULT_haltOnUnrecoverableEccError     FALSE
+#define DEFAULT_externalEccRamsEnable           FALSE
+/**************************************************************************//**
+ @Description       Modules registers offsets
+*//***************************************************************************/
+#define FM_MM_MURAM             0x00000000
+#define FM_MM_BMI               0x00080000
+#define FM_MM_QMI               0x00080400
+#define FM_MM_PRS               0x000c7000
+#define FM_MM_KG                0x000C1000
+#define FM_MM_DMA               0x000C2000
+#define FM_MM_FPM               0x000C3000
+#define FM_MM_PLCR              0x000C0000
+#define FM_MM_IMEM              0x000C4000
+
+/**************************************************************************//**
+ @Description       Interrupt Enable/Mask
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description       Memory Mapped Registers
+*//***************************************************************************/
+
+#ifdef __MWERKS__
+#pragma pack(push,1)
+#endif /*__MWERKS__ */
+#define MEM_MAP_START
+
+typedef _Packed struct
+{
+    volatile uint32_t   fpmtnc;         /**< FPM TNUM Control */
+    volatile uint32_t   fpmpr;          /**< FPM Port_ID FmCtl Association */
+    volatile uint32_t   brkc;           /**< FPM Breakpoint Control */
+    volatile uint32_t   fpmflc;         /**< FPM Flush Control */
+    volatile uint32_t   fpmdis1;        /**< FPM Dispatch Thresholds1 */
+    volatile uint32_t   fpmdis2;        /**< FPM Dispatch Thresholds2  */
+    volatile uint32_t   fmepi;          /**< FM Error Pending Interrupts */
+    volatile uint32_t   fmeie;          /**< FM Error Interrupt Enable */
+    volatile uint32_t   fpmrev[8];      /**< FPM FmCtl Event 1-8 */
+    volatile uint32_t   fpmmsk[8];      /**< FPM Mask 1-8 */
+    volatile uint32_t   fpmtsc1;        /**< FPM TimeStamp Control1 */
+    volatile uint32_t   fpmtsc2;        /**< FPM TimeStamp Control2 */
+    volatile uint32_t   fpmtsp;         /**< FPM Time Stamp */
+    volatile uint32_t   fpmtsf;         /**< FPM Time Stamp Fraction */
+    volatile uint32_t   fmrcr;          /**< FM Rams Control */
+    volatile uint32_t   fpmextc;        /**< FPM External Requests Control */
+    volatile uint32_t   fpmext1;        /**< FPM External Requests Config1 */
+    volatile uint32_t   fpmext2;        /**< FPM External Requests Config2 */
+    volatile uint32_t   fpmdrd[16];     /**< FPM Data_Ram Data 0-15 */
+    volatile uint32_t   fpmdra;         /**< FPM Data Ram Access */
+    volatile uint32_t   fm_ip_rev_1;    /**< FM IP Block Revision 1 */
+    volatile uint32_t   fm_ip_rev_2;    /**< FM IP Block Revision 2 */
+    volatile uint32_t   fmrstc;         /**< FM Reset Command */
+    volatile uint32_t   fmcld;          /**< FM Classifier Debug */
+    volatile uint32_t   fmnpi;          /**< FM Normal Pending Interrupts  */
+    volatile uint32_t   reserved;
+    volatile uint32_t   fpmem;          /**< FPM Event & Mask */
+    volatile uint32_t   fpmcev[8];      /**< FPM CPU Event 1-8 */
+    volatile uint32_t   fmfp_ps[0x40];  /**< FPM Port Status */
+    volatile uint8_t    reserved1[0x260];
+    volatile uint32_t   fpmts[128];     /**< 0x400: FPM Task Status */
+} _PackedType t_FmFpmRegs;
+
+typedef _Packed struct
+{
+   volatile uint32_t   fmbm_init;       /**< BMI Initialization */
+   volatile uint32_t   fmbm_cfg1;       /**< BMI Configuration 1 */
+   volatile uint32_t   fmbm_cfg2;       /**< BMI Configuration 2 */
+   volatile uint32_t   reserved[5];
+   volatile uint32_t   fmbm_ievr;       /**< Interrupt Event Register */
+   volatile uint32_t   fmbm_ier;        /**< Interrupt Enable Register */
+   volatile uint32_t   fmbm_ifr;        /**< Interrupt Force Register */
+   volatile uint32_t   reserved1[5];
+   volatile uint32_t   fmbm_arb[8];     /**< BMI Arbitration */
+   volatile uint32_t   reserved2[0x29];
+   volatile uint32_t   fmbm_pp[63];     /**< BMI Port Parameters */
+   volatile uint32_t   reserved3;
+   volatile uint32_t   fmbm_pfs[63];    /**< BMI Port FIFO Size */
+   volatile uint32_t   reserved4;
+   volatile uint32_t   fmbm_ppid[63];   /**< Port Partition ID */
+} _PackedType t_FmBmiRegs;
+
+#define NUM_OF_DBG_TRAPS    3
+
+typedef _Packed struct
+{
+    volatile uint32_t   fmqm_gc;        /**<  General Configuration Register */
+    volatile uint32_t   Reserved0;
+    volatile uint32_t   fmqm_eie;       /**<  Error Interrupt Event Register */
+    volatile uint32_t   fmqm_eien;      /**<  Error Interrupt Enable Register */
+    volatile uint32_t   fmqm_eif;       /**<  Error Interrupt Force Register */
+    volatile uint32_t   fmqm_ie;        /**<  Interrupt Event Register */
+    volatile uint32_t   fmqm_ien;       /**<  Interrupt Enable Register */
+    volatile uint32_t   fmqm_if;        /**<  Interrupt Force Register */
+    volatile uint32_t   fmqm_gs;        /**<  Global Status Register */
+    volatile uint32_t   fmqm_ts;        /**<  Task Status Register */
+    volatile uint32_t   fmqm_etfc;      /**<  Enqueue Total Frame Counter */
+    volatile uint32_t   fmqm_dtfc;      /**<  Dequeue Total Frame Counter */
+    volatile uint32_t   fmqm_dc0;       /**<  Dequeue Counter 0 */
+    volatile uint32_t   fmqm_dc1;       /**<  Dequeue Counter 1 */
+    volatile uint32_t   fmqm_dc2;       /**<  Dequeue Counter 2 */
+    volatile uint32_t   fmqm_dc3;       /**<  Dequeue Counter 3 */
+    volatile uint32_t   fmqm_dfdc;      /**<  Dequeue FQID from Default Counter */
+    volatile uint32_t   fmqm_dfcc;      /**<  Dequeue FQID from Context Counter */
+    volatile uint32_t   fmqm_dffc;      /**<  Dequeue FQID from FD Counter */
+    volatile uint32_t   fmqm_dcc;       /**<  Dequeue Confirm Counter */
+    volatile uint32_t   Reserved1[11];
+    volatile uint32_t   fmqm_dtc;       /**<  0x0080 Debug Trap Counter */
+    volatile uint32_t   fmqm_efddd;     /**<  0x0084 Enqueue Frame Descriptor Dynamic Debug */
+    volatile uint32_t   Reserved3[2];
+    struct {
+        volatile uint32_t   fmqm_dtcfg;    /**<  0x0090 Debug Trap Configuration 1 Register */
+        volatile uint32_t   fmqm_dtval1;    /**<  Debug Trap Value Register */
+        volatile uint32_t   fmqm_dtm1;      /**<  Debug Trap Mask Register */
+        volatile uint32_t   fmqm_dtc1;
+        volatile uint32_t   fmqm_dtc2;
+        volatile uint32_t   fmqm_dtval2;    /**<  Debug Trap Value Register */
+        volatile uint32_t   fmqm_dtm3;      /**<  Debug Trap Mask Register */
+    }t_FmQmiDbgTraps[NUM_OF_DBG_TRAPS];
+} _PackedType t_FmQmiRegs;
+
+
+typedef _Packed struct
+{
+    volatile uint32_t   fmdmsr;         /**<    FM DMA status register 0x04 */
+    volatile uint32_t   fmdmmr;         /**<    FM DMA mode register 0x08 */
+    volatile uint32_t   fmdmtr;         /**<    FM DMA bus threshold register 0x0c */
+    volatile uint32_t   fmdmhy;         /**<    FM DMA bus hysteresis register 0x10 */
+    volatile uint32_t   fmdmsetr;       /**<    FM DMA SOS emergency Threshold Register 0x14 */
+    volatile uint32_t   fmdmtah;        /**<    FM DMA transfer bus address high register 0x18  */
+    volatile uint32_t   fmdmtal;        /**<    FM DMA transfer bus address low register 0x1C  */
+    volatile uint32_t   fmdmtcid;       /**<    FM DMA transfer bus communication ID register 0x20  */
+    volatile uint32_t   fmdmra;         /**<    FM DMA bus internal ram address register 0x24  */
+    volatile uint32_t   fmdmrd;         /**<    FM DMA bus internal ram data register 0x28  */
+    volatile uint32_t   fmdmwcr;        /**<    FM DMA CAM watchdog counter value 0x2C  */
+    volatile uint32_t   fmdmebcr;       /**<    FM DMA CAM base in MURAM register 0x30  */
+    volatile uint32_t   fmdmccqdr;      /**<    FM DMA CAM and CMD Queue Debug register 0x34  */
+    volatile uint32_t   fmdmccqvr1;     /**<    FM DMA CAM and CMD Queue Value register #1 0x38  */
+    volatile uint32_t   fmdmccqvr2;     /**<    FM DMA CAM and CMD Queue Value register #2 0x3C  */
+    volatile uint32_t   fmdmcqvr3;      /**<    FM DMA CMD Queue Value register #3 0x40  */
+    volatile uint32_t   fmdmcqvr4;      /**<    FM DMA CMD Queue Value register #4 0x44  */
+    volatile uint32_t   fmdmcqvr5;      /**<    FM DMA CMD Queue Value register #5 0x48  */
+    volatile uint32_t   fmdmsefrc;      /**<    FM DMA Semaphore Entry Full Reject Counter 0x50  */
+    volatile uint32_t   fmdmsqfrc;      /**<    FM DMA Semaphore Queue Full Reject Counter 0x54  */
+    volatile uint32_t   fmdmssrc;       /**<    FM DMA Semaphore SYNC Reject Counter 0x54  */
+    volatile uint32_t   fmdmdcr;        /**<    FM DMA Debug Counter */
+    volatile uint32_t   fmdmemsr;       /**<    FM DMA Emrgency Smoother Register */
+    volatile uint32_t   reserved;
+    volatile uint32_t   fmdmplr[FM_MAX_NUM_OF_PARTITIONS/2];
+                                        /**<    FM DMA PID-LIODN # register  */
+} _PackedType t_FmDmaRegs;
+
+typedef _Packed struct
+{
+     volatile uint32_t      iadd;               /**<    FM IRAM instruction address register */
+    volatile uint32_t      idata;               /**<    FM IRAM instruction data register */
+    volatile uint32_t      itcfg;               /**<    FM IRAM timing config register */
+    volatile uint32_t      iready;               /**<    FM IRAM ready register */
+    volatile uint8_t    res[0x80000-0x10];
+} _PackedType t_FMIramRegs;
+
+#define MEM_MAP_END
+#ifdef __MWERKS__
+#pragma pack(pop)
+#endif /* __MWERKS__ */
+
+/**************************************************************************//**
+ @Description       General defines
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description       DMA definitions
+*//***************************************************************************/
+
+/* masks */
+#define DMA_MODE_AID_OR                     0x20000000
+#define DMA_MODE_SBER                       0x10000000
+#define DMA_MODE_BER                        0x00200000
+#define DMA_MODE_ECC                        0x00000020
+#define DMA_MODE_PRIVILEGE_PROT             0x00001000
+#define DMA_MODE_SECURE_PROT                0x00000800
+#define DMA_MODE_EMERGENCY_READ             0x00080000
+#define DMA_MODE_EMERGENCY_WRITE            0x00040000
+
+#define DMA_TRANSFER_PORTID_MASK            0xFF000000
+#define DMA_TRANSFER_TNUM_MASK              0x00FF0000
+#define DMA_TRANSFER_LIODN_MASK             0x00000FFF
+
+#define DMA_HIGH_LIODN_MASK                 0x0FFF0000
+#define DMA_LOW_LIODN_MASK                  0x00000FFF
+
+#define DMA_STATUS_CMD_QUEUE_NOT_EMPTY      0x10000000
+#define DMA_STATUS_BUS_ERR                  0x08000000
+#define DMA_STATUS_READ_ECC                 0x04000000
+#define DMA_STATUS_SYSTEM_WRITE_ECC         0x02000000
+#define DMA_STATUS_FM_WRITE_ECC             0x01000000
+#define DMA_STATUS_SYSTEM_DPEXT_ECC         0x00800000
+#define DMA_STATUS_FM_DPEXT_ECC             0x00400000
+#define DMA_STATUS_SYSTEM_DPDAT_ECC         0x00200000
+#define DMA_STATUS_FM_DPDAT_ECC             0x00100000
+#define DMA_STATUS_FM_SPDAT_ECC             0x00080000
+
+
+#define FM_LIODN_MASK                       0x00000FFF
+
+/* shifts */
+#define DMA_MODE_CACHE_OR_SHIFT             30
+#define DMA_MODE_BUS_PRI_SHIFT              16
+#define DMA_MODE_AXI_DBG_SHIFT              24
+#define DMA_MODE_CEN_SHIFT                  13
+#define DMA_MODE_BUS_PROT_SHIFT             10
+#define DMA_MODE_DBG_SHIFT                  7
+#define DMA_MODE_AID_MODE_SHIFT             4
+#define DMA_MODE_EMERGENCY_LEVEL_SHIFT      6
+#define DMA_MODE_MAX_AXI_DBG_NUM_OF_BEATS   16
+#define DMA_MODE_MAX_CAM_NUM_OF_ENTRIES     32
+
+#define DMA_THRESH_COMMQ_SHIFT              24
+#define DMA_THRESH_READ_INT_BUF_SHIFT       16
+
+#define DMA_LIODN_SHIFT                     16
+
+#define DMA_TRANSFER_PORTID_SHIFT           24
+#define DMA_TRANSFER_TNUM_SHIFT             16
+
+/* sizes */
+#define DMA_THRESH_MAX_COMMQ                31
+#define DMA_THRESH_MAX_BUF                  127
+#define DMA_MAX_WATCHDOG                    0xffffffff
+
+/* others */
+#define DMA_CAM_SIZEOF_ENTRY                0x40
+#define DMA_CAM_ALIGN                       0x1000
+#define DMA_CAM_UNITS                       8
+
+
+/**************************************************************************//**
+ @Description       FPM defines
+*//***************************************************************************/
+
+/* masks */
+#define FPM_EV_MASK_DOUBLE_ECC_EN       0x00008000
+#define FPM_EV_MASK_STALL_EN            0x00004000
+#define FPM_EV_MASK_SINGLE_ECC_EN       0x00002000
+#define FPM_EV_MASK_DOUBLE_ECC          0x80000000
+#define FPM_EV_MASK_STALL               0x40000000
+#define FPM_EV_MASK_SINGLE_ECC          0x20000000
+#define FPM_EV_MASK_RELEASE_FM          0x00010000
+#define FPM_EV_MASK_EXTERNAL_HALT       0x00000008
+#define FPM_EV_MASK_ECC_ERR_HALT        0x00000004
+
+#define FPM_RAM_CTL_RAMS_ECC_EN         0x80000000
+#define FPM_RAM_CTL_IRAM_ECC_EN         0x40000000
+#define FPM_RAM_CTL_MURAM_ECC           0x00008000
+#define FPM_RAM_CTL_IRAM_ECC            0x00004000
+#define FPM_RAM_CTL_MURAM_TEST_ECC      0x20000000
+#define FPM_RAM_CTL_IRAM_TEST_ECC       0x10000000
+#define FPM_RAM_CTL_RAMS_ECC_EN_SRC_SEL 0x08000000
+
+#define FPM_IRAM_ECC_ERR_EX_EN          0x00020000
+#define FPM_MURAM_ECC_ERR_EX_EN         0x00040000
+
+#define FPM_REV1_MAJOR_MASK             0x0000FF00
+#define FPM_REV1_MINOR_MASK             0x000000FF
+
+#define FPM_REV2_INTEG_MASK             0x00FF0000
+#define FPM_REV2_ERR_MASK               0x0000FF00
+#define FPM_REV2_CFG_MASK               0x000000FF
+
+#define FPM_TS_FRACTION_MASK            0x0000FFFF
+#define FPM_TS_CTL_EN                   0x80000000
+
+#define FPM_PORT_FM_CTL1                0x00000001
+#define FPM_PORT_FM_CTL2                0x00000002
+#define FPM_PRC_REALSE_STALLED          0x00800000
+
+#define FPM_PS_STALLED                  0x00800000
+#define FPM_PS_FM_CTL1_SEL              0x80000000
+#define FPM_PS_FM_CTL2_SEL              0x40000000
+#define FPM_PS_FM_CTL_SEL_MASK          (FPM_PS_FM_CTL1_SEL | FPM_PS_FM_CTL2_SEL)
+
+#define FPM_RSTC_FM_RESET               0x80000000
+#define FPM_RSTC_10G0_RESET             0x04000000
+#define FPM_RSTC_1G0_RESET              0x40000000
+#define FPM_RSTC_1G1_RESET              0x20000000
+#define FPM_RSTC_1G2_RESET              0x10000000
+#define FPM_RSTC_1G3_RESET              0x08000000
+
+/* shifts */
+#define FPM_DISP_LIMIT_SHIFT            24
+
+#define FPM_THR1_PRS_SHIFT              24
+#define FPM_THR1_KG_SHIFT               16
+#define FPM_THR1_PLCR_SHIFT             8
+#define FPM_THR1_BMI_SHIFT              0
+
+#define FPM_THR2_QMI_ENQ_SHIFT          24
+#define FPM_THR2_QMI_DEQ_SHIFT          0
+#define FPM_THR2_FM_CTL1_SHIFT            16
+#define FPM_THR2_FM_CTL2_SHIFT            8
+
+#define FPM_EV_MASK_CAT_ERR_SHIFT       1
+#define FPM_EV_MASK_DMA_ERR_SHIFT       0
+
+
+#define FPM_REV1_MAJOR_SHIFT            8
+#define FPM_REV1_MINOR_SHIFT            0
+
+#define FPM_REV2_INTEG_SHIFT            16
+#define FPM_REV2_ERR_SHIFT              8
+#define FPM_REV2_CFG_SHIFT              0
+
+#define FPM_TS_INT_SHIFT                16
+
+#define FPM_PORT_FM_CTL_PORTID_SHIFT      24
+
+#define FPM_PS_FM_CTL_SEL_SHIFT           30
+#define FPM_PRC_ORA_FM_CTL_SEL_SHIFT      16
+
+/* Interrupts defines */
+#define FPM_EVENT_FM_CTL_0                0x00008000
+#define FPM_EVENT_FM_CTL                  0x0000FF00
+#define FPM_EVENT_FM_CTL_BRK              0x00000080
+
+/* others */
+#define NUM_OF_FM_CTL_EVENT_REGS          4
+#define FPM_MAX_DISP_LIMIT              31
+
+
+/**************************************************************************//**
+ @Description       BMI defines
+*//***************************************************************************/
+/* masks */
+#define BMI_INIT_START                      0x80000000
+#define BMI_ERR_INTR_EN_PIPELINE_ECC        0x80000000
+#define BMI_ERR_INTR_EN_LIST_RAM_ECC        0x40000000
+#define BMI_ERR_INTR_EN_STATISTICS_RAM_ECC  0x20000000
+#define BMI_NUM_OF_TASKS_MASK               0x3F000000
+#define BMI_NUM_OF_DMAS_MASK                0x00000F00
+#define BMI_FIFO_SIZE_MASK                  0x000003FF
+#define BMI_CFG2_DMAS_MASK                  0x0000003F
+
+/* shifts */
+#define BMI_CFG2_TASKS_SHIFT            16
+#define BMI_CFG2_DMAS_SHIFT             0
+#define BMI_CFG1_FIFO_SIZE_SHIFT        16
+#define BMI_FIFO_SIZE_SHIFT             16
+#define BMI_NUM_OF_TASKS_SHIFT          24
+#define BMI_EXTRA_NUM_OF_TASKS_SHIFT    16
+#define BMI_NUM_OF_DMAS_SHIFT           8
+#define BMI_EXTRA_NUM_OF_DMAS_SHIFT     0
+
+/* sizes */
+#define BMI_MAX_NUM_OF_TASKS            128
+#define BMI_MAX_NUM_OF_DMAS             32
+
+/* others */
+#define PORT_MAX_WEIGHT                 16
+#define BMI_FIFO_ALIGN                  0x100
+
+
+/**************************************************************************//**
+ @Description       QMI defines
+*//***************************************************************************/
+/* masks */
+#define QMI_CFG_ENQ_EN                  0x80000000
+#define QMI_CFG_DEQ_EN                  0x40000000
+#define QMI_CFG_EN_COUNTERS             0x10000000
+#define QMI_CFG_SOFT_RESET              0x01000000
+#define QMI_CFG_DEQ_MASK                0x0000003F
+#define QMI_CFG_ENQ_MASK                0x00003F00
+
+#define QMI_ERR_INTR_EN_DOUBLE_ECC      0x80000000
+#define QMI_ERR_INTR_EN_DEQ_FROM_DEF    0x40000000
+#define QMI_INTR_EN_SINGLE_ECC          0x80000000
+
+/* shifts */
+#define QMI_CFG_ENQ_SHIFT               8
+
+
+/* others */
+#define QMI_DEF_TNUMS_THRESH            48
+#define QMI_MAX_NUM_OF_TNUMS            64
+
+
+/**************************************************************************//**
+ @Description       IRAM defines
+*//***************************************************************************/
+/* masks */
+#define IRAM_IADD_AIE                   0x80000000
+#define IRAM_READY                      0x80000000
+
+
+
+typedef struct
+{
+ /*   uint8_t                     numOfPartitions; */
+    bool                        resetOnInit;
+    uint8_t                     liodnPerPartition[FM_MAX_NUM_OF_PARTITIONS];
+    bool                        enCounters;
+    bool                        enTimeStamp;
+    t_FmThresholds              thresholds;
+    t_FmDmaBusProtect           dmaBusProtect;
+    e_FmDmaCacheOverride        dmaCacheOverride;
+    e_FmDmaAidMode              dmaAidMode;
+    bool                        dmaAidOverride;
+    uint8_t                     dmaAxiDbgNumOfBeats;
+    uint8_t                     dmaCamNumOfEntries;
+    uint32_t                    dmaWatchdog;
+    t_FmDmaThresholds           dmaCommQThresholds;
+    t_FmDmaThresholds           dmaWriteBufThresholds;
+    t_FmDmaThresholds           dmaReadBufThresholds;
+    uint32_t                    dmaSosEmergency;
+    e_FmDmaDbgCntMode           dmaDbgCntMode;
+    bool                        dmaStopOnBusError;
+    bool                        dmaEnEmergency;
+    t_FmDmaEmergency            dmaEmergency;
+    bool                        dmaEnEmergencySmoother;
+    uint32_t                    dmaEmergencySwitchCounter;
+    bool                        haltOnExternalActivation;
+    bool                        haltOnUnrecoverableEccError;
+    e_FmCatastrophicErr         catastrophicErr;
+    e_FmDmaErr                  dmaErr;
+    bool                        enMuramTestMode;
+    bool                        enIramTestMode;
+    bool                        externalEccRamsEnable;
+    t_FmPcdFirmwareParams       firmware;
+} t_FmDriverParam;
+
+typedef void (t_FmCtlIsr)( t_Handle h_Fm, uint32_t event);
+
+typedef struct
+{
+    uint8_t                     fmId;
+    t_Handle                    h_Pcd;
+    t_Handle                    h_FmPorts[FM_MAX_NUM_OF_PORTS]; /* Handles to all partitions ports */
+    e_FmPortType                portsTypes[FM_MAX_NUM_OF_PORTS];
+    char                        fmModuleName[MODULE_NAME_SIZE];
+#ifndef CONFIG_GUEST_PARTITION
+    uint64_t                    baseAddr;
+    t_Handle                    h_FmMuram;
+    uint64_t                    fmMuramPhysBaseAddr;
+    uint16_t                    fmClkFreq;
+    uint32_t                    timeStampPeriod;
+    bool                        independentMode;
+    bool                        hcPortInitialized;
+    uint8_t                     totalNumOfTasks;
+    uint32_t                    totalFifoSize;
+    uint8_t                     maxNumOfOpenDmas;
+    uint8_t                     accumulatedNumOfTasks;
+    uint32_t                    accumulatedFifoSize;
+    uint8_t                     accumulatedNumOfOpenDmas;
+    uint8_t                     accumulatedNumOfDeqTnums;
+    uint32_t                    exceptions;
+    uint64_t                    camBaseAddr;                    /* save for freeing */
+    uint64_t                    fifoBaseAddr;                   /* save for freeing */
+    int                         irq;
+    int                         errIrq;
+    t_FmFpmRegs                 *p_FmFpmRegs;
+    t_FmBmiRegs                 *p_FmBmiRegs;
+    t_FmQmiRegs                 *p_FmQmiRegs;
+    t_FmDmaRegs                 *p_FmDmaRegs;
+    t_FmExceptionsCallback      *f_Exceptions;
+    t_FmBusErrorCallback        *f_BusError;
+    t_Handle                    h_App;                          /* Application handle */
+    t_FmIntrSrc                 intrMng[e_FM_EV_DUMMY_LAST];    /* FM exceptions user callback */
+    t_FmCtlIsr                  *f_FmCtlIsr[NUM_OF_FM_CTL_EVENT_REGS];
+    bool                        ramsEccEnable;
+    uint32_t                    extraFifoPoolSize;
+    uint8_t                     extraTasksPoolSize;
+    uint8_t                     extraOpenDmasPoolSize;
+    t_FmDriverParam             *p_FmDriverParam;
+#endif /* ! CONFIG_GUEST_PARTITION */
+} t_Fm;
+
+#endif /* __FM_H */
+
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/fm_guest.c b/drivers/net/dpa/NetCommSw/Peripherals/FM/fm_guest.c
new file mode 100644
index 0000000..98b7357
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/fm_guest.c
@@ -0,0 +1,289 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/******************************************************************************
+ @File          fm.c
+
+ @Description   FM driver routines implementation.
+*//***************************************************************************/
+#include "std_ext.h"
+#include "error_ext.h"
+#include "xx_ext.h"
+#include "string_ext.h"
+#include "sprint_ext.h"
+#include "debug_ext.h"
+#include "fm_muram_ext.h"
+#include "fm_common.h"
+#include "fm_ipc.h"
+#include "fm.h"
+
+/****************************************/
+/*       Inter-Module functions        */
+/****************************************/
+void  FmRegisterPcd(t_Handle h_Fm, t_Handle h_FmPcd)
+{
+    t_Fm       *p_Fm = (t_Fm*)h_Fm;
+
+    if(p_Fm->h_Pcd)
+        REPORT_ERROR(MAJOR, E_ALREADY_EXISTS, ("PCD already set"));
+
+    p_Fm->h_Pcd = h_FmPcd;
+
+}
+
+t_Handle  FmGetPcdHandle(t_Handle h_Fm)
+{
+    t_Fm       *p_Fm = (t_Fm*)h_Fm;
+
+    return p_Fm->h_Pcd;
+
+}
+
+uint8_t FmGetId(t_Handle h_Fm)
+{
+    t_Fm *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_VALUE(p_Fm, E_INVALID_HANDLE, 0xff);
+
+    return p_Fm->fmId;
+}
+
+t_Error FmGetSetPortParams(t_Handle h_Fm,t_FmInterModulePortInitParams *p_PortParams)
+{
+    SANITY_CHECK_RETURN_ERROR(h_Fm, E_INVALID_HANDLE);
+
+    return XX_SendMessage(((t_Fm*)h_Fm)->fmModuleName, FM_GET_SET_PORT_PARAMS, (uint8_t*)p_PortParams, NULL, NULL);
+}
+
+void FmFreePortParams(t_Handle h_Fm,t_FmInterModulePortFreeParams *p_PortParams)
+{
+    t_Error err;
+
+    SANITY_CHECK_RETURN(h_Fm, E_INVALID_HANDLE);
+
+    err = XX_SendMessage(((t_Fm*)h_Fm)->fmModuleName, FM_FREE_PORT, (uint8_t*)p_PortParams, NULL, NULL);
+    if(err)
+        REPORT_ERROR(MINOR, err, NO_MSG);
+}
+
+
+bool FmIsPortStalled(t_Handle h_Fm, uint8_t hardwarePortId)
+{
+    t_FmIpcPortIsStalled    isStalled;
+    t_Error                 err;
+
+    SANITY_CHECK_RETURN_VALUE(h_Fm, E_INVALID_HANDLE, FALSE);
+
+    isStalled.hardwarePortId = hardwarePortId;
+    err = XX_SendMessage(((t_Fm*)h_Fm)->fmModuleName, FM_IS_PORT_STALLED, (uint8_t*)&isStalled, NULL, NULL);
+    if(err)
+        REPORT_ERROR(MINOR, err, NO_MSG);
+
+    return isStalled.isStalled;
+}
+
+t_Error FmResumeStalledPort(t_Handle h_Fm, uint8_t hardwarePortId)
+{
+    SANITY_CHECK_RETURN_ERROR(h_Fm, E_INVALID_HANDLE);
+
+    return XX_SendMessage(((t_Fm*)h_Fm)->fmModuleName, FM_RESUME_STALLED_PORT, (uint8_t*)&hardwarePortId, NULL, NULL);
+}
+
+t_Error FmResetMac(t_Handle h_Fm, e_FmMacType type, uint8_t macId)
+{
+    t_FmIpcMacReset macReset;
+
+    SANITY_CHECK_RETURN_ERROR(h_Fm, E_INVALID_HANDLE);
+
+    macReset.id = macId;
+    macReset.type = (e_FmIpcMacType)type;
+
+    return XX_SendMessage(((t_Fm*)h_Fm)->fmModuleName, FM_RESET_MAC, (uint8_t*)&macReset, NULL, NULL);
+}
+
+uint32_t    FmGetTimeStampPeriod(t_Handle h_Fm)
+{
+    uint32_t                timeStampPeriod;
+    t_Error                 err;
+
+    SANITY_CHECK_RETURN_VALUE(h_Fm, E_INVALID_HANDLE, 0);
+
+    err = XX_SendMessage(((t_Fm*)h_Fm)->fmModuleName, FM_GET_TIMESTAMP_PERIOD, (uint8_t*)&timeStampPeriod, NULL, NULL);
+    if(err )
+        REPORT_ERROR(MINOR, err, NO_MSG);
+
+    return timeStampPeriod;
+}
+
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+t_Error FmDumpPortRegs (t_Handle h_Fm,uint8_t hardwarePortId)
+{
+    SANITY_CHECK_RETURN_ERROR(h_Fm, E_INVALID_HANDLE);
+
+    return XX_SendMessage(((t_Fm*)h_Fm)->fmModuleName, FM_DUMP_PORT_REGS, (uint8_t*)&hardwarePortId, NULL, NULL);
+}
+#endif /* (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0)) */
+
+/****************************************/
+/*       API Init unit functions        */
+/****************************************/
+t_Handle FM_Config(t_FmParams *p_FmParam)
+{
+    t_Fm        *p_Fm;
+    uint8_t     i;
+
+    /* Allocate FM structure */
+    p_Fm = (t_Fm *) XX_Malloc(sizeof(t_Fm));
+    if (!p_Fm)
+    {
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM driver structure"));
+        return NULL;
+    }
+    memset(p_Fm, 0, sizeof(t_Fm));
+
+    /* Initialize FM parameters which will be kept by the driver */
+    p_Fm->fmId              = p_FmParam->fmId;
+    for(i = 0;i<FM_MAX_NUM_OF_PORTS;i++)
+        p_Fm->portsTypes[i] = e_FM_PORT_TYPE_DUMMY;
+    /* register to inter-core messaging mechanism */
+    memset(p_Fm->fmModuleName, 0, MODULE_NAME_SIZE);
+    if(Sprint (p_Fm->fmModuleName, "FM-%d",p_Fm->fmId) != 4)
+    {
+        XX_Free(p_Fm);
+        REPORT_ERROR(MAJOR, E_INVALID_STATE, ("Sprint failed"));
+        return NULL;
+    }
+
+    return p_Fm;
+}
+
+/**************************************************************************//**
+ @Function      FM_Init
+
+ @Description   Initializes the FM module
+
+ @Param[in]     h_Fm - FM module descriptor
+
+ @Return        E_OK on success; Error code otherwise.
+*//***************************************************************************/
+t_Error FM_Init(t_Handle h_Fm)
+{
+    UNUSED(h_Fm);
+    return E_OK;
+}
+
+/**************************************************************************//**
+ @Function      FM_Free
+
+ @Description   Frees all resources that were assigned to FM module.
+
+                Calling this routine invalidates the descriptor.
+
+ @Param[in]     h_Fm - FM module descriptor
+
+ @Return        E_OK on success; Error code otherwise.
+*//***************************************************************************/
+t_Error FM_Free(t_Handle h_Fm)
+{
+   t_Fm        *p_Fm = (t_Fm*)h_Fm;
+
+    if (!p_Fm)
+        return ERROR_CODE(E_INVALID_HANDLE);
+
+    XX_Free(p_Fm);
+
+    return E_OK;
+}
+
+/*************************************************/
+/*       API Advanced Init unit functions        */
+/*************************************************/
+
+/****************************************************/
+/*       API Run-time Control uint functions        */
+/****************************************************/
+t_Handle FM_GetPcdHandle(t_Handle h_Fm)
+{
+    SANITY_CHECK_RETURN_VALUE(h_Fm, E_INVALID_HANDLE, NULL);
+
+    return ((t_Fm*)h_Fm)->h_Pcd;
+}
+
+void FM_GetRevision(t_Handle h_Fm, t_FmRevisionInfo *p_FmRevisionInfo)
+{
+    t_Error err;
+
+    SANITY_CHECK_RETURN(h_Fm, E_INVALID_HANDLE);
+    err = XX_SendMessage(((t_Fm*)h_Fm)->fmModuleName, FM_GET_REV, (uint8_t*)p_FmRevisionInfo, NULL, NULL);
+    if(err )
+        REPORT_ERROR(MINOR, err, NO_MSG);
+}
+
+uint32_t FM_GetTimeStamp(t_Handle h_Fm)
+{
+    uint32_t    timeStamp;
+    t_Error     err;
+
+    SANITY_CHECK_RETURN_VALUE(h_Fm, E_INVALID_HANDLE, 0);
+
+    err = XX_SendMessage(((t_Fm*)h_Fm)->fmModuleName, FM_GET_TIMESTAMP, (uint8_t*)&timeStamp, NULL, NULL);
+    if(err )
+        REPORT_ERROR(MINOR, err, NO_MSG);
+
+    return timeStamp;
+}
+
+uint32_t  FM_GetCounter(t_Handle h_Fm, e_FmCounters counter)
+{
+    t_FmIpcGetCounter   counterParams;
+    t_Error             err;
+
+    SANITY_CHECK_RETURN_VALUE(h_Fm, E_INVALID_HANDLE, 0);
+
+    counterParams.id = (e_FmIpcCounters)counter;
+    err = XX_SendMessage(((t_Fm*)h_Fm)->fmModuleName, FM_GET_COUNTER, (uint8_t*)&counterParams, NULL, NULL);
+    if(err )
+        REPORT_ERROR(MINOR, err, NO_MSG);
+
+    return counterParams.val;
+}
+
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+t_Error FM_DumpRegs(t_Handle h_Fm)
+{
+    SANITY_CHECK_RETURN_ERROR(h_Fm, E_INVALID_HANDLE);
+
+    return XX_SendMessage(((t_Fm*)h_Fm)->fmModuleName, FM_DUMP_REGS, NULL, NULL, NULL);
+}
+#endif /* (defined(DEBUG_ERRORS) && ... */
+
+
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/fm_ipc.h b/drivers/net/dpa/NetCommSw/Peripherals/FM/fm_ipc.h
new file mode 100644
index 0000000..1cb41a9
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/fm_ipc.h
@@ -0,0 +1,308 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**************************************************************************//**
+ @File          fm_ipc.h
+
+ @Description   FM Inter-Partition prototypes, structures and definitions.
+*//***************************************************************************/
+#ifndef __FM_IPC_H
+#define __FM_IPC_H
+
+#include "error_ext.h"
+#include "std_ext.h"
+
+
+/**************************************************************************//**
+ @Group         FM_grp Frame Manager API
+
+ @Description   FM API functions, definitions and enums
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Group         FM_IPC_grp FM Inter-Partition messaging Unit
+
+ @Description   FM Inter-Partition messaging unit API definitions and enums.
+
+ @{
+*//***************************************************************************/
+
+#define FM_IC_PHYS_ADDRESS_SIZE    6
+
+/**************************************************************************//**
+ @Description   FM physical Address
+*//***************************************************************************/
+//typedef uint8_t fmIpcPhysAddr_t[FM_IC_PHYS_ADDRESS_SIZE];
+
+/**************************************************************************//**
+ @Description   Structure for port-FM communication during FM_PORT_Init.
+                Fields commented 'IN' are passed by the port module to be used
+                by the FM module.
+                Fields commented 'OUT' will be filled by FM before returning to port.
+                Some fields are optional (depending on configuration) and
+                will be analized by the port and FM modules accordingly.
+*//***************************************************************************/
+//typedef struct
+//{
+//    uint8_t             hardwarePortId;       /**< IN. port Id */
+//    e_FmPortIcType      portType;           /**< IN. Port type */
+//    uint32_t            timeStampPeriod;    /**< OUT. Time stamp period in NanoSec */
+//    bool                independentMode;    /**< IN. TRUE if FM Port operates in independent mode */
+//    uint8_t             portPartition;      /**< IN. Port's requested resource */
+//    uint8_t             numOfTasks;         /**< IN. Port's requested resource */
+//    uint8_t             numOfExtraTasks;    /**< IN. Port's requested resource */
+//    uint8_t             numOfOpenDmas;      /**< IN. Port's requested resource */
+//    uint8_t             numOfExtraOpenDmas; /**< IN. Port's requested resource */
+//    uint32_t            sizeOfFifo;         /**< IN. Port's requested resource */
+//    uint32_t            extraSizeOfFifo;    /**< IN. Port's requested resource */
+//    fmIcPhysAddr_t      fmMuramPhysBaseAddr;/**< OUT. FM-MURAM physical address*/
+//} t_FmIcPortInitParams;
+
+/**************************************************************************//**
+ @Description   Structure for finding out whether a port is stalled.
+                Fields commented 'IN' are passed by the port module to be used
+                by the FM module.
+                Fields commented 'OUT' will be filled by FM before returning to port.
+*//***************************************************************************/
+typedef struct
+{
+    uint8_t             hardwarePortId;       /**< IN. port Id */
+    bool                isStalled;          /**< OUT. TRUE if FM PORT is stalled */
+} t_FmIpcPortIsStalled;
+
+
+
+/**************************************************************************//**
+ @Description   enum for defining MAC types
+*//***************************************************************************/
+typedef enum
+{
+    e_FM_IPC_MAC_10G,
+    e_FM_IPC_MAC_1G
+} e_FmIpcMacType;
+
+/**************************************************************************//**
+ @Description   A structure of parameters for specifying a MAC.
+*//***************************************************************************/
+typedef struct
+{
+    uint8_t         id;
+    e_FmIpcMacType   type;
+} t_FmIpcMacReset;
+
+
+/**************************************************************************//**
+ @Function      FM_RESET_MAC
+
+ @Description   Used by MAC module to reset the MAC registers
+
+ @Param[in]     t_FmIpcMacReset  .
+
+ @Return        E_OK on success; Error code otherwise.
+*//***************************************************************************/
+//#define FM_RESET_MAC                10
+
+/**************************************************************************//**
+ @Function      FM_GET_SET_PORT_PARAMS
+
+ @Description   Used by FM PORT module in order to set and get parameters in/from
+                FM module on FM PORT initialization time.
+
+ @Param[in/out] t_FmIcPortInitParams
+
+*//***************************************************************************/
+//#define FM_GET_SET_PORT_PARAMS      11
+
+/**************************************************************************//**
+ @Function      FM_IS_PORT_STALLED
+
+ @Description   Used by FM PORT module in order to check whether
+                an FM port is stalled.
+
+ @Param[in/out] t_FmIcPortIsStalled
+
+*//***************************************************************************/
+//#define FM_IS_PORT_STALLED          12
+
+/**************************************************************************//**
+ @Function      FM_RESUME_STALLED_PORT
+
+ @Description   Used by FM PORT module in order to release a stalled
+                FM Port.
+
+ @Param[in]     hardwarePortId
+
+*//***************************************************************************/
+//#define FM_RESUME_STALLED_PORT     13
+
+/**************************************************************************//**
+ @Function      FM_DUMP_PORT_REGS
+
+ @Description   Used by FM PORT module in order to dump all port registers
+                that are a part of the FM module.
+
+ @Param[in]     hardwarePortId
+
+ @Return        E_OK on success; Error code otherwise.
+*//***************************************************************************/
+//#define FM_DUMP_PORT_REGS           14
+
+
+/**************************************************************************//**
+ @Function      FM_FREE_PORT
+
+ @Description   Used by FM PORT module when a port is freed to free all FM resources.
+
+ @Param[in]     hardwarePortId
+
+ @Return        None.
+*//***************************************************************************/
+//#define FM_FREE_PORT                15
+
+
+
+/*=============================*/
+/**************************************************************************//**
+ @Description   enum for defining port types
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description   enum for defining port types
+*//***************************************************************************/
+typedef enum e_FmIpcPortType {
+    e_FM_IPC_PORT_TYPE_OFFLINE_PARSING, /**< Offline parsing port (id's: 0-6, share id's with
+                                             host command, so must have exclusive id) */
+    e_FM_IPC_PORT_TYPE_HOST_COMMAND,    /**< Host command port (id's: 0-6, share id's with
+                                             offline parsing ports, so must have exclusive id) */
+    e_FM_IPC_PORT_TYPE_RX,              /**< 1G Rx port (id's: 0-3) */
+    e_FM_IPC_PORT_TYPE_RX_10G,          /**< 10G Rx port (id's: 0) */
+    e_FM_IPC_PORT_TYPE_TX,              /**< 1G Tx port (id's: 0-3) */
+    e_FM_IPC_PORT_TYPE_TX_10G,          /**< 10G Tx port (id's: 0) */
+    e_FM_IPC_PORT_TYPE_DUMMY
+} e_FmIpcPortType;
+
+#ifdef __MWERKS__
+#pragma pack(push,1)
+#endif /*__MWERKS__ */
+#define MEM_MAP_START
+
+/**************************************************************************//**
+ @Description   FM physical Address
+*//***************************************************************************/
+typedef _Packed struct t_FmIpcPhysAddr
+{
+    volatile uint16_t high;
+    volatile uint32_t low;
+}_PackedType t_FmIpcPhysAddr;
+
+#define MEM_MAP_END
+#ifdef __MWERKS__
+#pragma pack(pop)
+#endif /* __MWERKS__ */
+
+#define FM_GET_TIMESTAMP            1
+#define FM_GET_TIMESTAMP_PERIOD     2
+#define FM_GET_COUNTER              3
+#define FM_DUMP_REGS                4
+#define FM_GET_SET_PORT_PARAMS      5
+#define FM_FREE_PORT                6
+#define FM_RESET_MAC                7
+#define FM_RESUME_STALLED_PORT      8
+#define FM_IS_PORT_STALLED          9
+#define FM_DUMP_PORT_REGS           10
+#define FM_GET_REV                  11
+/**************************************************************************//**
+ @Description   Structure for IPC communication during FM_PORT_Init.
+                Fields commented 'IN' are passed by the port module to be used
+                by the FM module.
+                Fields commented 'OUT' will be filled by FM before returning to port.
+                Some fields are optional (depending on configuration) and
+                will be analized by the port and FM modules accordingly.
+*//***************************************************************************/
+typedef struct t_FmIpcPortInitParams {
+    uint8_t             hardwarePortId;       /**< IN. port Id */
+    e_FmIpcPortType     portType;           /**< IN. Port type */
+    uint32_t            timeStampPeriod;    /**< OUT. Time stamp period in NanoSec */
+    bool                independentMode;    /**< IN. TRUE if FM Port operates in independent mode */
+    uint8_t             portPartition;      /**< IN. Port's requested resource */
+    uint8_t             numOfTasks;         /**< IN. Port's requested resource */
+    uint8_t             numOfExtraTasks;    /**< IN. Port's requested resource */
+    uint8_t             numOfOpenDmas;      /**< IN. Port's requested resource */
+    uint8_t             numOfExtraOpenDmas; /**< IN. Port's requested resource */
+    uint32_t            sizeOfFifo;         /**< IN. Port's requested resource */
+    uint32_t            extraSizeOfFifo;    /**< IN. Port's requested resource */
+    uint8_t             deqPipelineDepth;   /**< IN. Port's requested resource */
+    t_FmIpcPhysAddr     fmMuramPhysBaseAddr;/**< OUT. FM-MURAM physical address*/
+} t_FmIpcPortInitParams;
+
+/**************************************************************************//**
+ @Description   Structure for port-FM communication during FM_PORT_Free.
+*//***************************************************************************/
+typedef struct t_FmIpcPortFreeParams {
+    uint8_t             hardwarePortId;         /**< IN. port Id */
+    e_FmIpcPortType     portType;               /**< IN. Port type */
+    uint8_t             deqPipelineDepth;       /**< IN. Port's requested resource */
+} t_FmIpcPortFreeParams;
+
+
+/**************************************************************************//**
+ @Description   enum for defining FM counters
+*//***************************************************************************/
+typedef enum e_FmIpcCounters {
+    e_FM_IPC_COUNTERS_ENQ_TOTAL_FRAME,              /**< QMI total enqueued frames counter */
+    e_FM_IPC_COUNTERS_DEQ_TOTAL_FRAME,              /**< QMI total dequeued frames counter */
+    e_FM_IPC_COUNTERS_DEQ_0,                        /**< QMI 0 frames from QMan counter */
+    e_FM_IPC_COUNTERS_DEQ_1,                        /**< QMI 1 frames from QMan counter */
+    e_FM_IPC_COUNTERS_DEQ_2,                        /**< QMI 2 frames from QMan counter */
+    e_FM_IPC_COUNTERS_DEQ_3,                        /**< QMI 3 frames from QMan counter */
+    e_FM_IPC_COUNTERS_DEQ_FROM_DEFAULT,             /**< QMI dequeue from default queue counter */
+    e_FM_IPC_COUNTERS_DEQ_FROM_CONTEXT,             /**< QMI dequeue from FQ context counter */
+    e_FM_IPC_COUNTERS_DEQ_FROM_FD,                  /**< QMI dequeue from FD command field counter */
+    e_FM_IPC_COUNTERS_DEQ_CONFIRM,                  /**< QMI dequeue confirm counter */
+    e_FM_IPC_COUNTERS_SEMAPHOR_ENTRY_FULL_REJECT,   /**< DMA semaphor reject due to full entry counter */
+    e_FM_IPC_COUNTERS_SEMAPHOR_QUEUE_FULL_REJECT,   /**< DMA semaphor reject due to full CAM queue counter */
+    e_FM_IPC_COUNTERS_SEMAPHOR_SYNC_REJECT          /**< DMA semaphor reject due to sync counter */
+} e_FmIpcCounters;
+
+typedef struct t_FmIpcGetCounter
+{
+    e_FmIpcCounters id;         /* IN */
+    uint32_t        val;        /* OUT */
+} t_FmIpcGetCounter;
+
+/** @} */ /* end of FM_IPC_grp group */
+/** @} */ /* end of FM_grp group */
+
+
+#endif /* __FM_IPC_H */
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/fm_muram.c b/drivers/net/dpa/NetCommSw/Peripherals/FM/fm_muram.c
new file mode 100644
index 0000000..2b5b3c4
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/fm_muram.c
@@ -0,0 +1,94 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/******************************************************************************
+ @File          FM_muram.c
+
+ @Description   FM MURAM ...
+*//***************************************************************************/
+#include "error_ext.h"
+#include "std_ext.h"
+#include "mm_ext.h"
+#include "fm_common.h"
+#include "fm_muram_ext.h"
+
+
+t_Handle FM_MURAM_ConfigAndInit(uint64_t baseAddress, uint32_t size)
+{
+    t_Handle h_Mem;
+
+
+    if(!baseAddress)
+    {
+        REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("baseAddress 0 is not supported"));
+        return NULL;
+
+    }
+    if (MM_Init(&h_Mem, baseAddress, size) != E_OK)
+        return NULL;
+    if (!h_Mem)
+        REPORT_ERROR(MAJOR, E_INVALID_HANDLE, ("FM-MURAM partition!!!"));
+
+    return h_Mem;
+}
+
+t_Error  FM_MURAM_Free(t_Handle h_FmMuram)
+{
+    if (h_FmMuram)
+        MM_Free(h_FmMuram);
+
+    return E_OK;
+}
+
+void  * FM_MURAM_AllocMem(t_Handle h_FmMuram, uint32_t size, uint32_t align)
+{
+    uint64_t addr;
+
+    SANITY_CHECK_RETURN_VALUE(h_FmMuram, E_INVALID_HANDLE, NULL);
+
+    addr = MM_Get(h_FmMuram, size, (int32_t)align ,"FM MURAM");
+
+    if(addr == ILLEGAL_BASE)
+        return NULL;
+
+    return CAST_UINT64_TO_POINTER(addr);
+}
+
+t_Error FM_MURAM_FreeMem(t_Handle h_FmMuram, void *ptr)
+{
+    SANITY_CHECK_RETURN_ERROR(h_FmMuram, E_INVALID_HANDLE);
+
+    if (MM_Put(h_FmMuram, CAST_POINTER_TO_UINT64(ptr)) == 0)
+        RETURN_ERROR(MINOR, E_INVALID_HANDLE, ("memory pointer!!!"));
+
+    return E_OK;
+}
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/inc/fm_common.h b/drivers/net/dpa/NetCommSw/Peripherals/FM/inc/fm_common.h
new file mode 100644
index 0000000..6250db1
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/inc/fm_common.h
@@ -0,0 +1,606 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/******************************************************************************
+ @File          fm_common.h
+
+ @Description   FM internal structures and definitions.
+*//***************************************************************************/
+#ifndef __FM_COMMON_H
+#define __FM_COMMON_H
+
+#include "error_ext.h"
+#include "std_ext.h"
+#include "fm_pcd_ext.h"
+#include "fm_port_ext.h"
+
+#define __ERR_MODULE__  MODULE_FM
+
+#define CLS_PLAN_NUM_PER_GRP                        8
+#define DRIVER_PRIVATE_NET_ENV_ID                   PCD_MAX_NUM_OF_PORTS
+
+
+#ifdef __MWERKS__
+#pragma pack(push,1)
+#endif /*__MWERKS__ */
+#define MEM_MAP_START
+
+/**************************************************************************//**
+ @Description   PCD KG scheme registers
+*//***************************************************************************/
+typedef _Packed struct t_FmPcdPlcrInterModuleProfileRegs {
+    volatile uint32_t fmpl_pemode;      /* 0x090 FMPL_PEMODE - FM Policer Profile Entry Mode*/
+    volatile uint32_t fmpl_pegnia;      /* 0x094 FMPL_PEGNIA - FM Policer Profile Entry GREEN Next Invoked Action*/
+    volatile uint32_t fmpl_peynia;      /* 0x098 FMPL_PEYNIA - FM Policer Profile Entry YELLOW Next Invoked Action*/
+    volatile uint32_t fmpl_pernia;      /* 0x09C FMPL_PERNIA - FM Policer Profile Entry RED Next Invoked Action*/
+    volatile uint32_t fmpl_pecir;       /* 0x0A0 FMPL_PECIR  - FM Policer Profile Entry Committed Information Rate*/
+    volatile uint32_t fmpl_pecbs;       /* 0x0A4 FMPL_PECBS  - FM Policer Profile Entry Committed Burst Size*/
+    volatile uint32_t fmpl_pepepir_eir; /* 0x0A8 FMPL_PEPIR_EIR - FM Policer Profile Entry Peak/Excess Information Rate*/
+    volatile uint32_t fmpl_pepbs_ebs;   /* 0x0AC FMPL_PEPBS_EBS - FM Policer Profile Entry Peak/Excess Information Rate*/
+    volatile uint32_t fmpl_pelts;       /* 0x0B0 FMPL_PELTS  - FM Policer Profile Entry Last TimeStamp*/
+    volatile uint32_t fmpl_pects;       /* 0x0B4 FMPL_PECTS  - FM Policer Profile Entry Committed Token Status*/
+    volatile uint32_t fmpl_pepts_ets;   /* 0x0B8 FMPL_PEPTS_ETS - FM Policer Profile Entry Peak/Excess Token Status*/
+    volatile uint32_t fmpl_pegpc;       /* 0x0BC FMPL_PEGPC  - FM Policer Profile Entry GREEN Packet Counter*/
+    volatile uint32_t fmpl_peypc;       /* 0x0C0 FMPL_PEYPC  - FM Policer Profile Entry YELLOW Packet Counter*/
+    volatile uint32_t fmpl_perpc;       /* 0x0C4 FMPL_PERPC  - FM Policer Profile Entry RED Packet Counter */
+    volatile uint32_t fmpl_perypc;      /* 0x0C8 FMPL_PERYPC - FM Policer Profile Entry Recolored YELLOW Packet Counter*/
+    volatile uint32_t fmpl_perrpc;      /* 0x0CC FMPL_PERRPC - FM Policer Profile Entry Recolored RED Packet Counter*/
+    volatile uint32_t fmpl_res1[12];    /* 0x0D0-0x0FF Reserved */
+} _PackedType t_FmPcdPlcrInterModuleProfileRegs;
+
+/**************************************************************************//**
+ @Description   PCD KG scheme registers
+*//***************************************************************************/
+typedef _Packed struct t_FmPcdKgInterModuleSchemeRegs {
+    uint32_t kgse_mode;    /**< MODE */
+    uint32_t kgse_ekfc;    /**< Extract Known Fields Command */
+    uint32_t kgse_ekdv;    /**< Extract Known Default Value */
+    uint32_t kgse_bmch;    /**< Bit Mask Command High */
+    uint32_t kgse_bmcl;    /**< Bit Mask Command Low */
+    uint32_t kgse_fqb;     /**< Frame Queue Base */
+    uint32_t kgse_hc;      /**< Hash Command */
+    uint32_t kgse_ppc;     /**< Policer Profile Command */
+    uint32_t kgse_gec[FM_PCD_KG_NUM_OF_GENERIC_REGS];
+                           /**< Generic Extract Command */
+    uint32_t kgse_spc;     /**< KeyGen Scheme Entry Statistic Packet Counter */
+    uint32_t kgse_dv0;     /**< KeyGen Scheme Entry Default Value 0 */
+    uint32_t kgse_dv1;     /**< KeyGen Scheme Entry Default Value 1 */
+    uint32_t kgse_ccbs;    /**< KeyGen Scheme Entry Coarse Classification Bit*/
+    uint32_t kgse_mv;      /**< KeyGen Scheme Entry Match vector */
+} _PackedType t_FmPcdKgInterModuleSchemeRegs;
+
+#define MEM_MAP_END
+#ifdef __MWERKS__
+#pragma pack(pop)
+#endif /* __MWERKS__ */
+
+typedef struct {
+    uint8_t             baseEntry;
+    uint16_t            numOfClsPlanEntries;
+    uint32_t            vectors[FM_PCD_MAX_NUM_OF_CLS_PLANS];
+} t_FmPcdKgInterModuleClsPlanSet;
+
+/**************************************************************************//**
+ @Description   Structure for binding a port to keygen schemes.
+*//***************************************************************************/
+
+
+typedef struct t_FmPcdKgInterModuleBindPortToSchemes {
+    uint8_t     hardwarePortId;
+    uint8_t     netEnvId;
+    bool        useClsPlan;                 /**< TRUE if this port uses the clsPlan mechanism */
+    uint8_t     numOfSchemes;
+    uint8_t     schemesIds[FM_PCD_KG_NUM_OF_SCHEMES];
+} t_FmPcdKgInterModuleBindPortToSchemes;
+
+
+#define CC_NEXT_NODE_F_OBJECT(ptr)  LIST_OBJECT(ptr, t_CcNodeInfo, h_Node)
+
+typedef struct {
+    uint32_t nextCcNodeInfo;
+    t_List   h_Node;
+} t_CcNodeInfo;
+
+
+#define TRY_LOCK_RET_ERR(lock)                                  \
+do {                                                            \
+    uint32_t intFlags;                                          \
+    intFlags = XX_DisableAllIntr();                             \
+    if (lock)                                                   \
+    {                                                           \
+        XX_RestoreAllIntr(intFlags);                            \
+        return ERROR_CODE(E_BUSY);                              \
+    }                                                           \
+    lock = TRUE;                                                \
+    XX_RestoreAllIntr(intFlags);                                \
+} while (0)
+
+#define TRY_LOCK_RET_NULL(lock)                                 \
+do {                                                            \
+    uint32_t intFlags;                                          \
+    intFlags = XX_DisableAllIntr();                             \
+    if (lock)                                                   \
+    {                                                           \
+        XX_RestoreAllIntr(intFlags);                            \
+        return NULL;                                            \
+    }                                                           \
+    lock = TRUE;                                                \
+    XX_RestoreAllIntr(intFlags);                                \
+} while (0)
+
+#define RELEASE_LOCK(lock) lock = FALSE;
+
+#if defined (CONFIG_GUEST_PARTITION) && !defined (CONFIG_MULTI_PARTITION_SUPPORT)
+#error "CONFIG_MULTI_PARTITION_SUPPORT must be defined!"
+#elif (defined(CONFIG_MULTI_PARTITION_SUPPORT) && !defined(CONFIG_GUEST_PARTITION))
+#define FM_MASTER_PARTITION
+#endif /* defined (CONFIG_GUEST_PARTITION) && ... */
+
+
+#define MAX_NUM_OF_OP_PORTS                 7
+#define MAX_NUM_OF_RX_1G_PORTS              4
+#define MAX_NUM_OF_RX_10G_PORTS             1
+#define PCD_MAX_NUM_OF_PORTS                (MAX_NUM_OF_OP_PORTS +      \
+                                            MAX_NUM_OF_RX_1G_PORTS +    \
+                                            MAX_NUM_OF_RX_10G_PORTS)
+#define MODULE_NAME_SIZE                    20
+#define DUMMY_PORT_ID                       0
+
+/**************************************************************************//**
+  @Description       NIA Description
+*//***************************************************************************/
+
+#define NIA_ORDER_RESTOR            0x00800000
+#define NIA_ENG_FM_CTL              0x00000000
+#define NIA_ENG_PRS                 0x00440000
+#define NIA_ENG_KG                  0x00480000
+#define NIA_ENG_PLCR                0x004C0000
+#define NIA_ENG_BMI                 0x00500000
+#define NIA_ENG_QMI_ENQ             0x00540000
+#define NIA_ENG_QMI_DEQ             0x00580000
+#define NIA_ENG_MASK                0x007C0000
+
+#define NIA_FM_CTL_AC_CC              0x00000006
+#define NIA_FM_CTL_AC_HC              0x0000000C
+#define NIA_FM_CTL_AC_IND_MODE_TX     0x00000008
+#define NIA_FM_CTL_AC_IND_MODE_RX     0x0000000A
+
+#define NIA_BMI_AC_ENQ_FRAME        0x00000002
+#define NIA_BMI_AC_TX_RELEASE       0x000002C0
+#define NIA_BMI_AC_RELEASE          0x000000C0
+#define NIA_BMI_AC_DISCARD          0x000000C1
+#define NIA_BMI_AC_TX               0x00000274
+#define NIA_BMI_AC_FETCH            0x00000208
+#define NIA_BMI_AC_MASK             0x000003FF
+
+#define NIA_KG_DIRECT               0x00000100
+#define NIA_KG_CC_EN                0x00000200
+#define NIA_PLCR_ABSOLUTE           0x00008000
+
+/**************************************************************************//**
+ @Description       Port Id defines
+*//***************************************************************************/
+#define BASE_HO_PORTID              1
+#define BASE_RX_PORTID              8
+#define BASE_RX10_PORTID            0x10
+#define BASE_TX_PORTID              0x28
+#define BASE_TX10_PORTID            0x30
+#define LAST_HO_PORTID              7
+#define LAST_RX_PORTID              0xB
+#define LAST_TX_PORTID              0x2B
+#define LAST_RX10_PORTID            0x10
+#define LAST_TX10_PORTID            0x30
+
+#define GET_GLOBAL_PORTID(port, type, id)               \
+switch(type){                                           \
+    case(e_FM_PORT_TYPE_OFFLINE_PARSING):               \
+    case(e_FM_PORT_TYPE_HOST_COMMAND):                  \
+        port = (uint8_t)(BASE_HO_PORTID + id);          \
+        if (id > (LAST_HO_PORTID-BASE_HO_PORTID))       \
+            REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("Illegal port id")); \
+        break;                                          \
+    case(e_FM_PORT_TYPE_RX):                            \
+        port = (uint8_t)(BASE_RX_PORTID + id);          \
+        if (id > (LAST_RX_PORTID-BASE_RX_PORTID))       \
+            REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("Illegal port id")); \
+        break;                                          \
+    case(e_FM_PORT_TYPE_RX_10G):                        \
+        port = (uint8_t)(BASE_RX10_PORTID + id);        \
+        if (id > (LAST_RX10_PORTID-BASE_RX10_PORTID))   \
+            REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("Illegal port id")); \
+        break;                                          \
+    case(e_FM_PORT_TYPE_TX):                            \
+        port = (uint8_t)(BASE_TX_PORTID + id);          \
+        if (id > (LAST_TX_PORTID-BASE_TX_PORTID))       \
+            REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("Illegal port id")); \
+        break;                                          \
+    case(e_FM_PORT_TYPE_TX_10G):                        \
+        port = (uint8_t)(BASE_TX10_PORTID + id);        \
+        if (id > (LAST_TX10_PORTID-BASE_TX10_PORTID))   \
+            REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("Illegal port id")); \
+        break;                                          \
+    default:                                            \
+        REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("Illegal port type")); \
+        break;                                          \
+}
+
+#define GET_RELATIVE_PORTID(relativePortId, hardwarePortId)                           \
+{   if ((hardwarePortId>=BASE_HO_PORTID) && (hardwarePortId<=LAST_HO_PORTID))           \
+        relativePortId = (uint8_t)(hardwarePortId-BASE_HO_PORTID);                    \
+    else if ((hardwarePortId>=BASE_TX10_PORTID) && (hardwarePortId<=LAST_TX10_PORTID))  \
+        relativePortId = (uint8_t)(hardwarePortId-BASE_TX10_PORTID);                  \
+    else if ((hardwarePortId>=BASE_TX_PORTID) && (hardwarePortId<=LAST_TX_PORTID))      \
+        relativePortId = (uint8_t)(hardwarePortId-BASE_TX_PORTID);                    \
+    else if ((hardwarePortId>=BASE_RX10_PORTID) && (hardwarePortId<=LAST_RX10_PORTID))  \
+        relativePortId = (uint8_t)(hardwarePortId-BASE_RX10_PORTID);                  \
+    else if ((hardwarePortId>=BASE_RX_PORTID) && (hardwarePortId<=LAST_RX_PORTID))      \
+        relativePortId = (uint8_t)(hardwarePortId-BASE_RX_PORTID);                    \
+    else {                                                                          \
+        relativePortId = (uint8_t)DUMMY_PORT_ID;                                    \
+        REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("Illegal port type"));                \
+    }                                                                               \
+}
+
+#define BMI_FIFO_UNITS                      0x100
+#define BMI_MAX_FIFO_SIZE                   (160*KILOBYTE)
+
+typedef struct
+{
+    void        (*f_Isr) (t_Handle h_Arg);
+    t_Handle    h_SrcHandle;
+} t_FmIntrSrc;
+
+#define ILLEGAL_HDR_NUM                         0xFF
+#define NO_HDR_NUM                              FM_PCD_PRS_NUM_OF_HDRS
+
+#define GET_PRS_HDR_NUM(num, hdr)                           \
+switch(hdr)                                                 \
+{   case(HEADER_TYPE_ETH):              num = 0;  break;    \
+    case(HEADER_TYPE_LLC_SNAP):         num = 1;  break;    \
+    case(HEADER_TYPE_VLAN):             num = 2;  break;    \
+    case(HEADER_TYPE_PPPoE):            num = 3;  break;    \
+    case(HEADER_TYPE_MPLS):             num = 4;  break;    \
+    case(HEADER_TYPE_IPv4):             num = 5;  break;    \
+    case(HEADER_TYPE_IPv6):             num = 6;  break;    \
+    case(HEADER_TYPE_GRE):              num = 7;  break;    \
+    case(HEADER_TYPE_MINENCAP):         num = 8;  break;    \
+    case(HEADER_TYPE_USER_DEFINED_L3):  num = 9;  break;    \
+    case(HEADER_TYPE_TCP):              num = 10; break;    \
+    case(HEADER_TYPE_UDP):              num = 11; break;    \
+    case(HEADER_TYPE_IPSEC_AH):                             \
+    case(HEADER_TYPE_IPSEC_ESP):        num = 12; break;    \
+    case(HEADER_TYPE_SCTP):             num = 13; break;    \
+    case(HEADER_TYPE_DCCP):             num = 14; break;    \
+    case(HEADER_TYPE_USER_DEFINED_L4):  num = 15; break;    \
+    case(HEADER_TYPE_USER_DEFINED_SHIM1):                   \
+    case(HEADER_TYPE_USER_DEFINED_SHIM2):                   \
+    case(HEADER_TYPE_USER_DEFINED_SHIM3):                   \
+        num = NO_HDR_NUM; break;                            \
+    default:                                                \
+        REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Unsupported header for parser"));\
+        num = ILLEGAL_HDR_NUM; break;                       \
+}
+
+/***********************************************************************/
+/*          Policer defines                                            */
+/***********************************************************************/
+#define FM_PCD_PLCR_PAR_GO                    0x80000000
+#define FM_PCD_PLCR_PAR_PWSEL_MASK            0x0000FFFF
+#define FM_PCD_PLCR_PAR_R                     0x40000000
+
+/* shifts */
+#define FM_PCD_PLCR_PAR_PNUM_SHIFT            16
+
+
+/***********************************************************************/
+/*          Keygen defines                                             */
+/***********************************************************************/
+/* maskes */
+#define KG_SCH_PP_SHIFT_HIGH                    0x80000000
+#define KG_SCH_PP_SHIFT_LOW                     0x0000F000
+#define KG_SCH_MODE_NIA_PLCR                    0x40000000
+#define KG_SCH_GEN_EXTRACT_TYPE                 0x00008000
+#define KG_SCH_BITMASK_MASK                     0x000000FF
+#define KG_SCH_GEN_VALID                        0x80000000
+#define KG_SCH_GEN_MASK                         0x00FF0000
+#define FM_PCD_KG_KGAR_ERR                      0x20000000
+#define FM_PCD_KG_KGAR_SEL_CLS_PLAN_ENTRY       0x01000000
+#define FM_PCD_KG_KGAR_SEL_PORT_ENTRY           0x02000000
+#define FM_PCD_KG_KGAR_SEL_PORT_WSEL_SP         0x00008000
+#define FM_PCD_KG_KGAR_SEL_PORT_WSEL_CPP        0x00004000
+#define FM_PCD_KG_KGAR_WSEL_MASK                0x0000FF00
+
+#define FM_PCD_KG_KGAR_GO                       0x80000000
+#define FM_PCD_KG_KGAR_READ                     0x40000000
+#define FM_PCD_KG_KGAR_WRITE                    0x00000000
+#define FM_PCD_KG_KGAR_SEL_SCHEME_ENTRY         0x00000000
+#define FM_PCD_KG_KGAR_SCHEME_WSEL_UPDATE_CNT   0x00008000
+
+
+typedef uint32_t t_KnownFieldsMasks;
+
+#define KG_SCH_KN_PORT_ID                   0x80000000
+#define KG_SCH_KN_MACDST                    0x40000000
+#define KG_SCH_KN_MACSRC                    0x20000000
+#define KG_SCH_KN_TCI1                      0x10000000
+#define KG_SCH_KN_TCI2                      0x08000000
+#define KG_SCH_KN_ETYPE                     0x04000000
+#define KG_SCH_KN_PPPSID                    0x02000000
+#define KG_SCH_KN_PPPID                     0x01000000
+#define KG_SCH_KN_MPLS1                     0x00800000
+#define KG_SCH_KN_MPLS2                     0x00400000
+#define KG_SCH_KN_MPLS_LAST                 0x00200000
+#define KG_SCH_KN_IPSRC1                    0x00100000
+#define KG_SCH_KN_IPDST1                    0x00080000
+#define KG_SCH_KN_PTYPE1                    0x00040000
+#define KG_SCH_KN_IPTOS_TC1                 0x00020000
+#define KG_SCH_KN_IPV6FL1                   0x00010000
+#define KG_SCH_KN_IPSRC2                    0x00008000
+#define KG_SCH_KN_IPDST2                    0x00004000
+#define KG_SCH_KN_PTYPE2                    0x00002000
+#define KG_SCH_KN_IPTOS_TC2                 0x00001000
+#define KG_SCH_KN_IPV6FL2                   0x00000800
+#define KG_SCH_KN_GREPTYPE                  0x00000400
+#define KG_SCH_KN_IPSEC_SPI                 0x00000200
+#define KG_SCH_KN_IPSEC_NH                  0x00000100
+#define KG_SCH_KN_L4PSRC                    0x00000004
+#define KG_SCH_KN_L4PDST                    0x00000002
+#define KG_SCH_KN_TFLG                      0x00000001
+
+typedef uint8_t t_GenericCodes;
+
+#define KG_SCH_GEN_SHIM1                       0x70
+#define KG_SCH_GEN_DEFAULT                     0x10
+#define KG_SCH_GEN_PARSE_RESULT                0x20
+#define KG_SCH_GEN_START_OF_FRM                0x40
+#define KG_SCH_GEN_SHIM2                       0x71
+#define KG_SCH_GEN_SHIM3                       0x72
+#define KG_SCH_GEN_ETH                         0x03
+#define KG_SCH_GEN_ETH_NO_V                    0x73
+#define KG_SCH_GEN_SNAP                        0x04
+#define KG_SCH_GEN_SNAP_NO_V                   0x74
+#define KG_SCH_GEN_VLAN1                       0x05
+#define KG_SCH_GEN_VLAN1_NO_V                  0x75
+#define KG_SCH_GEN_VLAN2                       0x06
+#define KG_SCH_GEN_VLAN2_NO_V                  0x76
+#define KG_SCH_GEN_ETH_TYPE                    0x07
+#define KG_SCH_GEN_ETH_TYPE_NO_V               0x77
+#define KG_SCH_GEN_PPP                         0x08
+#define KG_SCH_GEN_PPP_NO_V                    0x78
+#define KG_SCH_GEN_MPLS1                       0x09
+#define KG_SCH_GEN_MPLS2                       0x19
+#define KG_SCH_GEN_MPLS3                       0x29
+#define KG_SCH_GEN_MPLS1_NO_V                  0x79
+#define KG_SCH_GEN_MPLS_LAST                   0x0a
+#define KG_SCH_GEN_MPLS_LAST_NO_V              0x7a
+#define KG_SCH_GEN_IPV4                        0x0b
+#define KG_SCH_GEN_IPV6                        0x1b
+#define KG_SCH_GEN_L3_NO_V                     0x7b
+#define KG_SCH_GEN_IPV4_TUNNELED               0x0c
+#define KG_SCH_GEN_IPV6_TUNNELED               0x1c
+#define KG_SCH_GEN_MIN_ENCAP                   0x2c
+#define KG_SCH_GEN_IP2_NO_V                    0x7c
+#define KG_SCH_GEN_GRE                         0x0d
+#define KG_SCH_GEN_GRE_NO_V                    0x7d
+#define KG_SCH_GEN_TCP                         0x0e
+#define KG_SCH_GEN_UDP                         0x1e
+#define KG_SCH_GEN_IPSEC_AH                    0x2e
+#define KG_SCH_GEN_SCTP                        0x3e
+#define KG_SCH_GEN_DCCP                        0x4e
+#define KG_SCH_GEN_IPSEC_ESP                   0x6e
+#define KG_SCH_GEN_L4_NO_V                     0x7e
+#define KG_SCH_GEN_NEXTHDR                     0x7f
+
+/* shifts */
+#define KG_SCH_PP_SHIFT_HIGH_SHIFT          27
+#define KG_SCH_PP_SHIFT_LOW_SHIFT           12
+#define KG_SCH_PP_MASK_SHIFT                16
+#define KG_SCH_MODE_CCOBASE_SHIFT           24
+#define KG_SCH_DEF_MAC_ADDR_SHIFT           30
+#define KG_SCH_DEF_TCI_SHIFT                28
+#define KG_SCH_DEF_ENET_TYPE_SHIFT          26
+#define KG_SCH_DEF_PPP_SESSION_ID_SHIFT     24
+#define KG_SCH_DEF_PPP_PROTOCOL_ID_SHIFT    22
+#define KG_SCH_DEF_MPLS_LABEL_SHIFT         20
+#define KG_SCH_DEF_IP_ADDR_SHIFT            18
+#define KG_SCH_DEF_PROTOCOL_TYPE_SHIFT      16
+#define KG_SCH_DEF_IP_TOS_TC_SHIFT          14
+#define KG_SCH_DEF_IPV6_FLOW_LABEL_SHIFT    12
+#define KG_SCH_DEF_IPSEC_SPI_SHIFT          10
+#define KG_SCH_DEF_L4_PORT_SHIFT            8
+#define KG_SCH_DEF_TCP_FLAG_SHIFT           6
+#define KG_SCH_HASH_CONFIG_SHIFT_SHIFT      24
+#define KG_SCH_GEN_MASK_SHIFT               16
+#define KG_SCH_GEN_HT_SHIFT                 8
+#define KG_SCH_GEN_SIZE_SHIFT               24
+#define KG_SCH_GEN_DEF_SHIFT                29
+#define FM_PCD_KG_KGAR_NUM_SHIFT            16
+
+
+/* others */
+#define NUM_OF_SW_DEFAULTS                  3
+#define MAX_PP_SHIFT                        15
+#define MAX_KG_SCH_SIZE                     16
+#define MASK_FOR_GENERIC_BASE_ID            0x20
+#define MAX_HASH_SHIFT                      40
+#define MAX_KG_SCH_BIT_OFFSET               23
+#define MAX_DIST_FQID_SHIFT                 23
+
+#define GET_MASK_SEL_SHIFT(shift,i)             \
+switch(i) {                                     \
+    case(0):shift = 26;break;                   \
+    case(1):shift = 20;break;                   \
+    case(2):shift = 10;break;                   \
+    case(3):shift = 4;break;                    \
+    default:                                    \
+    RETURN_ERROR(MAJOR, E_INVALID_VALUE, NO_MSG);\
+}
+
+#define GET_MASK_OFFSET_SHIFT(shift,i)          \
+switch(i) {                                     \
+    case(0):shift = 16;break;                   \
+    case(1):shift = 0;break;                    \
+    case(2):shift = 28;break;                   \
+    case(3):shift = 24;break;                   \
+    default:                                    \
+    RETURN_ERROR(MAJOR, E_INVALID_VALUE, NO_MSG);\
+}
+
+#define GET_MASK_SHIFT(shift,i)                 \
+switch(i) {                                     \
+    case(0):shift = 24;break;                   \
+    case(1):shift = 16;break;                   \
+    case(2):shift = 8;break;                    \
+    case(3):shift = 0;break;                    \
+    default:                                    \
+    RETURN_ERROR(MAJOR, E_INVALID_VALUE, NO_MSG);\
+}
+
+
+typedef struct {
+    uint16_t num;
+    uint8_t  hardwarePortId;
+    uint16_t plcrProfilesBase;
+} t_FmPortPcdInterModulePlcrParams;
+
+
+uint32_t    FmPcdGetSwPrsOffset(t_Handle h_FmPcd, e_NetHeaderType hdr, uint8_t  indexPerHdr);
+uint32_t    FmPcdGetLcv(t_Handle h_FmPcd, uint32_t netEnvId, uint8_t hdrNum);
+void        FmPcdIncNetEnvOwners(t_Handle h_FmPcd, uint8_t netEnvId);
+void        FmPcdDecNetEnvOwners(t_Handle h_FmPcd, uint8_t netEnvId);
+void        FmPcdPortRegister(t_Handle h_FmPcd, t_Handle h_FmPort, uint8_t hardwarePortId);
+t_Error     FmPcdTryLock(t_Handle h_FmPcd);
+void        FmPcdReleaseLock(t_Handle h_FmPcd);
+
+t_Error     FmPcdCcReleaseModifiedOnlyNextEngine(t_Handle h_FmPcd, t_Handle h_FmPcdOldPointer, t_Handle h_FmPcdNewPointer, bool isAllGood);
+t_Error     FmPcdCcReleaseModifiedKey(t_Handle h_FmPcd, t_List *h_FmPcdOldPointersLst, t_Handle h_FmPcdNewPointer, uint16_t numOfGoodChanges);
+uint32_t    FmPcdCcGetNodeAddrOffset(t_Handle h_FmPcd, t_Handle h_Pointer);
+t_Error     FmPcdCcRemoveKey(t_Handle h_FmPcd, t_Handle h_CcNode, uint8_t keyIndex,t_List *h_OldLst, t_Handle *h_NewPointer);
+t_Error     FmPcdCcAddKey(t_Handle h_FmPcd, t_Handle h_CcNode, uint8_t keyIndex, t_FmPcdCcKeyParams *p_FmPCdCcKeyParams,  t_List *h_OldLst, t_Handle *h_NewPointer);
+t_Error     FmPcdCcModifyKey(t_Handle h_FmPcd, t_Handle h_CcNode, uint8_t keyIndex, uint8_t *p_Key, uint8_t *p_Mask, t_List *h_OldLst,  t_Handle *h_NewPointer);
+t_Error     FmPcdCcModifyKeyAndNextEngine(t_Handle h_FmPcd, t_Handle h_CcNode, uint8_t keyIndex, t_FmPcdCcKeyParams *p_FmPcdCcKeyParams, t_List *h_OldLst, t_Handle *h_NewPointer);
+t_Error     FmPcdCcModifyMissNextEngineParamNode(t_Handle h_FmPcd, t_Handle h_CcNode, t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams,t_Handle *h_OldPointer, t_Handle *h_NewPointer);
+t_Error     FmPcdCcModifyNextEngineParamTree(t_Handle h_FmPcd, t_Handle h_CcTree, uint8_t grpId, uint8_t index, t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams, t_Handle *h_OldPointer, t_Handle *h_NewPointer);
+t_Error     FmPcdCcModiyNextEngineParamNode(t_Handle h_FmPcd, t_Handle h_CcNode, uint8_t keyIndex,t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams,t_Handle *h_OldPointer, t_Handle *h_NewPointer);
+uint32_t    FmPcdCcGetNodeAddrOffsetFromNodeInfo(t_Handle h_FmPcd, t_Handle h_Pointer);
+t_Error     FmPcdCcTreeTryLock(t_Handle h_FmPcdCcTree);
+t_Error     FmPcdCcNodeTreeTryLock(t_Handle h_FmPcd,t_Handle h_FmPcdCcNode, t_List *p_List);
+void        FmPcdCcTreeReleaseLock(t_Handle h_FmPcdCcTree);
+void        FmPcdCcNodeTreeReleaseLock(t_Handle h_FmPcd, t_List *p_List);
+
+bool        FmPcdKgIsSchemeValidSw(t_Handle h_FmPcd, uint8_t schemeId);
+uint8_t     FmPcdKgGetClsPlanGrpBase(t_Handle h_FmPcd, uint8_t clsPlanGrp);
+uint16_t    FmPcdKgGetClsPlanGrpSize(t_Handle h_FmPcd, uint8_t clsPlanGrp);
+t_Error     FmPcdKgSwBindPortToClsPlanGrp(t_Handle h_FmPcd, uint8_t netEnvId, uint8_t clsPlanGrpId, protocolOpt_t *p_OptArray);
+void        FmPcdKgSwUnbindPortToClsPlanGrp(t_Handle h_FmPcd, uint8_t clsPlanGrpId);
+bool        FmPcdKgIsEmptyClsPlanGrp(t_Handle h_FmPcd);
+uint8_t     FmPcdKgGetEmptyClsPlanGrpId(t_Handle h_FmPcd);
+t_Error     FmPcdKgBuildScheme(t_Handle h_FmPcd,  t_FmPcdKgSchemeParams *p_Scheme, t_FmPcdKgInterModuleSchemeRegs *p_SchemeRegs, t_FmPcdKgKeyOrder *p_OrderedArray);
+t_Handle    FmPcdKgBuildClsPlanGrp(t_Handle h_FmPcd, t_FmPcdKgClsPlanGrpParams *p_Grp, t_FmPcdKgInterModuleClsPlanSet *p_ClsPlanSet);
+uint8_t     FmPcdKgGetNumOfPartitionSchemes(t_Handle h_FmPcd);
+uint8_t     FmPcdKgGetPhysicalSchemeId(t_Handle h_FmPcd, uint8_t schemeId);
+uint8_t     FmPcdKgGetRelativeSchemeId(t_Handle h_FmPcd, uint8_t schemeId);
+void        FmPcdKgDestroyClsPlanGrp(t_Handle h_FmPcd, uint8_t grpId);
+void        FmPcdKgValidateSchemeSw(t_Handle h_FmPcd, uint8_t schemeId);
+void        FmPcdKgInvalidateSchemeSw(t_Handle h_FmPcd, uint8_t schemeId);
+t_Error     FmPcdKgCheckInvalidateSchemeSw(t_Handle h_FmPcd, uint8_t schemeId);
+t_Error     FmPcdKgBuildBindPortToSchemes(t_Handle h_FmPcd , t_FmPcdKgInterModuleBindPortToSchemes *p_BindPortToSchemes, uint32_t *p_SpReg, bool add);
+void        FmPcdKgIncSchemeOwners(t_Handle h_FmPcd , t_FmPcdKgInterModuleBindPortToSchemes *p_BindPort);
+void        FmPcdKgDecSchemeOwners(t_Handle h_FmPcd , t_FmPcdKgInterModuleBindPortToSchemes *p_BindPort);
+bool        FmPcdKgIsDriverClsPlan(t_Handle h_FmPcd);
+bool        FmPcdKgHwSchemeIsValid(uint32_t schemeModeReg);
+uint32_t    FmPcdKgBuildCppReg(t_Handle h_FmPcd, uint8_t clsPlanGrpId);
+uint32_t    FmPcdKgBuildWriteSchemeActionReg(uint8_t schemeId, bool updateCounter);
+uint32_t    FmPcdKgBuildReadSchemeActionReg(uint8_t schemeId);
+uint32_t    FmPcdKgBuildWriteClsPlanBlockActionReg(uint8_t grpId);
+uint32_t    FmPcdKgBuildReadClsPlanBlockActionReg(uint8_t grpId);
+uint32_t    FmPcdKgBuildWritePortSchemeBindActionReg(uint8_t hardwarePortId);
+uint32_t    FmPcdKgBuildReadPortSchemeBindActionReg(uint8_t hardwarePortId);
+uint32_t    FmPcdKgBuildWritePortClsPlanBindActionReg(uint8_t hardwarePortId);
+uint8_t     FmPcdKgGetSchemeSwId(t_Handle h_FmPcd, uint8_t schemeHwId);
+t_Error     FmPcdKgSchemeTryLock(t_Handle h_FmPcd, uint8_t schemeId);
+void        FmPcdKgReleaseSchemeLock(t_Handle h_FmPcd, uint8_t schemeId);
+
+t_Error     FmPcdKgBindPortToSchemes(t_Handle h_FmPcd , t_FmPcdKgInterModuleBindPortToSchemes  *p_SchemeBind);
+t_Error     FmPcdKgUnbindPortToSchemes(t_Handle h_FmPcd , t_FmPcdKgInterModuleBindPortToSchemes *p_SchemeBind);
+t_Error     FmPcdKgBindPortToClsPlanGrp(t_Handle p_FmPcd, uint8_t hardwarePortId, uint8_t clsPlanGrpId);
+void        FmPcdKgUnbindPortToClsPlanGrp(t_Handle h_FmPcd, uint8_t hardwarePortId);
+
+#ifndef CONFIG_MULTI_PARTITION_SUPPORT
+void        FmPcdPrsIncludePortInStatistics(t_Handle p_FmPcd, uint8_t hardwarePortId,  bool include);
+#endif /* !CONFIG_MULTI_PARTITION_SUPPORT */
+
+t_Error     FmPcdPlcrAllocProfiles(t_Handle h_FmPcd, uint8_t hardwarePortId, uint16_t numOfProfiles);
+t_Error     FmPcdPlcrFreeProfiles(t_Handle h_FmPcd, uint8_t hardwarePortId);
+bool        FmPcdPlcrIsProfileValid(t_Handle h_FmPcd, uint16_t absoluteProfileId);
+uint16_t    FmPcdPlcrGetPortProfilesBase(t_Handle h_FmPcd, uint8_t hardwarePortId);
+uint16_t    FmPcdPlcrGetPortNumOfProfiles(t_Handle h_FmPcd, uint8_t hardwarePortId);
+uint32_t    FmPcdPlcrBuildWritePlcrActionRegs(uint16_t absoluteProfileId);
+uint32_t    FmPcdPlcrBuildCounterProfileReg(e_FmPcdPlcrProfileCounters counter);
+uint32_t    FmPcdPlcrBuildWritePlcrActionReg(uint16_t absoluteProfileId);
+uint32_t    FmPcdPlcrBuildReadPlcrActionReg(uint16_t absoluteProfileId);
+t_Error     FmPcdPlcrBuildProfile(t_Handle h_FmPcd, t_FmPcdPlcrProfileParams *p_Profile, t_FmPcdPlcrInterModuleProfileRegs *p_PlcrRegs);
+t_Error     FmPcdPlcrGetAbsoluteProfileId(t_Handle h_FmPcd,
+                                e_FmPcdProfileTypeSelection profileType,
+                                t_Handle  h_FmPort,
+                                uint16_t relativeProfile,
+                                uint16_t *p_AbsoluteId);
+void        FmPcdPlcrInvalidateProfileSw(t_Handle h_FmPcd, uint16_t absoluteProfileId);
+void        FmPcdPlcrValidateProfileSw(t_Handle h_FmPcd, uint16_t absoluteProfileId);
+bool        FmPcdPlcrHwProfileIsValid(uint32_t profileModeReg);
+t_Error     FmPcdPlcrProfileTryLock(t_Handle h_FmPcd, uint16_t profileId);
+void        FmPcdPlcrReleaseProfileLock(t_Handle h_FmPcd, uint16_t profileId);
+
+t_Error     FmPcdCcBindTree(t_Handle h_FmPcd, t_Handle h_CcTree,  uint32_t  *p_Offset);
+t_Error     FmPcdCcUnbindTree(t_Handle h_FmPcd, t_Handle h_CcTree);
+
+#if (defined(CONFIG_MULTI_PARTITION_SUPPORT) && !defined(CONFIG_GUEST_PARTITION))
+t_Error     FmPcdHandleIpcMsg(t_Handle h_FmPcd, uint32_t msgId, uint8_t msgBody[MSG_BODY_SIZE]);
+#endif /* (defined(CONFIG_MULTI_PARTITION_SUPPORT) && ... */
+
+#ifdef CONFIG_MULTI_PARTITION_SUPPORT
+uint8_t     FmPcdGetPartitionId(t_Handle h_FmPcd);
+#endif /* CONFIG_MULTI_PARTITION_SUPPORT */
+
+t_Error     FmPortSetPcd(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParams);
+t_Error     FmPortDeletePcd(t_Handle h_FmPort);
+uint8_t     FmPortGetNetEnvId(t_Handle h_FmPort);
+uint8_t     FmPortGetHardwarePortId(t_Handle h_FmPort);
+uint32_t    FmPortGetPcdEngines(t_Handle h_FmPort);
+uint8_t     FmPortGetClsPlanId(t_Handle h_FmPort);
+t_Error     FmPortPcdKgSwBindClsPlanGrp (t_Handle h_FmPort, bool useClsPlan, uint8_t newClsPlanGrpId);
+void        FmPortPcdKgSwUnbindClsPlanGrp (t_Handle h_FmPort);
+t_Error     FmPortAttachPCD(t_Handle h_FmPort);
+
+
+
+#endif /* __FM_COMMON_H */
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/inc/fm_hc.h b/drivers/net/dpa/NetCommSw/Peripherals/FM/inc/fm_hc.h
new file mode 100644
index 0000000..6525ef0
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/inc/fm_hc.h
@@ -0,0 +1,79 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __FM_HC_H
+#define __FM_HC_H
+
+#include "std_ext.h"
+#include "error_ext.h"
+
+
+typedef struct t_FmHcParams {
+    t_Handle        h_Fm;
+    t_Handle        h_FmPcd;
+    t_FmPcdHcParams params;
+} t_FmHcParams;
+
+
+t_Handle    FmHcConfigAndInit(t_FmHcParams *p_FmHcParams);
+void        FmHcFree(t_Handle h_FmHc);
+
+void        FmHcTxConf(t_Handle h_FmHc, t_FmFD *p_Fd);
+
+t_Handle    FmHcPcdKgSetScheme(t_Handle h_FmHc, t_FmPcdKgSchemeParams *p_Scheme);
+t_Error     FmHcPcdKgDeleteScheme(t_Handle h_FmHc, t_Handle h_Scheme);
+
+t_Handle    FmHcPcdKgSetClsPlanGrp(t_Handle h_FmHc, t_FmPcdKgClsPlanGrpParams *p_Grp);
+t_Error     FmHcPcdKgDeleteClsPlanGrp(t_Handle h_FmHc, t_Handle h_ClsPlanGrp);
+
+t_Error     FmHcPcdKgSetSchemeCounter(t_Handle h_FmHc, t_Handle h_Scheme, uint32_t value);
+uint32_t    FmHcPcdKgGetSchemeCounter(t_Handle h_FmHc, t_Handle h_Scheme);
+
+t_Error     FmHcPcdCcModifyTreeNextEngine(t_Handle h_FmHc, t_Handle h_CcTree, uint8_t grpId, uint8_t index, t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams);
+t_Error     FmHcPcdCcModifyNodeNextEngine(t_Handle h_FmHc, t_Handle h_CcNode, uint8_t keyIndex, t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams);
+t_Error     FmHcPcdCcModifyNodeMissNextEngine(t_Handle h_FmHc, t_Handle h_CcNode, t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams);
+t_Error     FmHcPcdCcRemoveKey(t_Handle h_FmHc, t_Handle h_CcNode, uint8_t keyIndex);
+t_Error     FmHcPcdCcAddKey(t_Handle h_FmHc, t_Handle h_CcNode, uint8_t keyIndex, uint8_t keySize, t_FmPcdCcKeyParams  *p_KeyParams);
+t_Error     FmHcPcdCcModifyKeyAndNextEngine(t_Handle h_FmHc, t_Handle h_CcNode, uint8_t keyIndex, uint8_t keySize, t_FmPcdCcKeyParams  *p_KeyParams);
+t_Error     FmHcPcdCcModifyKey(t_Handle h_FmHc, t_Handle h_CcNode, uint8_t keyIndex, uint8_t keySize, uint8_t  *p_Key, uint8_t *p_Mask);
+
+t_Handle    FmHcPcdPlcrSetProfile(t_Handle h_FmHc,t_FmPcdPlcrProfileParams *p_Profile);
+t_Error     FmHcPcdPlcrDeleteProfile(t_Handle h_FmHc, t_Handle h_Profile);
+
+t_Error     FmHcPcdPlcrSetProfileCounter(t_Handle h_FmHc, t_Handle h_Profile, e_FmPcdPlcrProfileCounters counter, uint32_t value);
+uint32_t    FmHcPcdPlcrGetProfileCounter(t_Handle h_FmHc, t_Handle h_Profile, e_FmPcdPlcrProfileCounters counter);
+
+t_Error     FmHcKgWriteSp(t_Handle h_FmHc, uint8_t hardwarePortId, uint32_t spReg, bool add);
+t_Error     FmHcKgWriteCpp(t_Handle h_FmHc, uint8_t hardwarePortId, uint32_t cppReg);
+
+
+#endif /* __FM_HC_H */
diff --git a/drivers/net/dpa/NetCommSw/dflags.h b/drivers/net/dpa/NetCommSw/dflags.h
new file mode 100644
index 0000000..bc40bcc
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/dflags.h
@@ -0,0 +1,59 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __dflags_h
+#define __dflags_h
+
+#include "events_mapping.h"
+
+
+#define NCSW_LINUX
+
+#define P4080
+
+#define DEBUG_ERRORS        1
+
+#if defined(DEBUG)
+#define DEBUG_GLOBAL_LEVEL  REPORT_LEVEL_INFO
+
+#define DEBUG_XX_MALLOC
+#define DEBUG_MEM_LEAKS
+
+#else
+#define DEBUG_GLOBAL_LEVEL  REPORT_LEVEL_WARNING
+#endif /* (DEBUG) */
+
+#define REPORT_EVENTS       1
+#define EVENT_GLOBAL_LEVEL  REPORT_LEVEL_MINOR
+
+
+#endif /* __dflags_h */
diff --git a/drivers/net/dpa/NetCommSw/etc/Makefile b/drivers/net/dpa/NetCommSw/etc/Makefile
new file mode 100644
index 0000000..ed10553
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/etc/Makefile
@@ -0,0 +1,11 @@
+#
+# Makefile for the Freescale Ethernet controllers
+#
+EXTRA_CFLAGS           += -DVERSION=\"\"
+#
+#Include netcomm SW specific definitions
+include $(srctree)/drivers/net/dpa/NetCommSw/ncsw_config.mk
+
+obj-y		+= fsl-ncsw-etc.o
+
+fsl-ncsw-etc-objs	:= mm.o memcpy.o sprint.o list.o error.o
diff --git a/drivers/net/dpa/NetCommSw/etc/error.c b/drivers/net/dpa/NetCommSw/etc/error.c
new file mode 100644
index 0000000..20590fe
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/etc/error.c
@@ -0,0 +1,118 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/*
+
+ @File          error.c
+
+ @Description   General errors and events reporting utilities.
+*//***************************************************************************/
+
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+
+const char *dbgLevelStrings[] =
+{
+     "CRITICAL"
+    ,"MAJOR"
+    ,"MINOR"
+    ,"WARNING"
+    ,"INFO"
+    ,"TRACE"
+};
+
+const char *errTypeStrings[] =
+{
+     "Invalid State"                        /* E_INVALID_STATE */
+    ,"Invalid Operation"                    /* E_INVALID_OPERATION */
+    ,"Unsupported Operation"                /* E_NOT_SUPPORTED */
+    ,"No Device"                            /* E_NO_DEVICE */
+    ,"Invalid Handle"                       /* E_INVALID_HANDLE */
+    ,"Invalid ID"                           /* E_INVALID_ID */
+    ,"Unexpected NULL Pointer"              /* E_NULL_POINTER */
+    ,"Invalid Value"                        /* E_INVALID_VALUE */
+    ,"Invalid Selection"                    /* E_INVALID_SELECTION */
+    ,"Invalid Communication Mode"           /* E_INVALID_COMM_MODE */
+    ,"Invalid Byte Order"                   /* E_INVALID_BYTE_ORDER */
+    ,"Invalid Memory Type"                  /* E_INVALID_MEMORY_TYPE */
+    ,"Invalid Interrupt Queue"              /* E_INVALID_INTR_QUEUE */
+    ,"Invalid Priority"                     /* E_INVALID_PRIORITY */
+    ,"Invalid Clock"                        /* E_INVALID_CLOCK */
+    ,"Invalid Rate"                         /* E_INVALID_RATE */
+    ,"Invalid Address"                      /* E_INVALID_ADDRESS */
+    ,"Invalid Bus"                          /* E_INVALID_BUS */
+    ,"Conflict In Bus Selection"            /* E_BUS_CONFLICT */
+    ,"Conflict In Settings"                 /* E_CONFLICT */
+    ,"Incorrect Alignment"                  /* E_NOT_ALIGNED */
+    ,"Value Out Of Range"                   /* E_NOT_IN_RANGE */
+    ,"Invalid Frame"                        /* E_INVALID_FRAME */
+    ,"Frame Is Empty"                       /* E_EMPTY_FRAME */
+    ,"Buffer Is Empty"                      /* E_EMPTY_BUFFER */
+    ,"Memory Allocation Failed"             /* E_NO_MEMORY */
+    ,"Resource Not Found"                   /* E_NOT_FOUND */
+    ,"Resource Is Unavailable"              /* E_NOT_AVAILABLE */
+    ,"Resource Already Exists"              /* E_ALREADY_EXISTS */
+    ,"Resource Is Full"                     /* E_FULL */
+    ,"Resource Is Empty"                    /* E_EMPTY */
+    ,"Resource Is Busy"                     /* E_BUSY */
+    ,"Resource Already Free"                /* E_ALREADY_FREE */
+    ,"Read Access Failed"                   /* E_READ_FAILED */
+    ,"Write Access Failed"                  /* E_WRITE_FAILED */
+    ,"Send Operation Failed"                /* E_SEND_FAILED */
+    ,"Receive Operation Failed"             /* E_RECEIVE_FAILED */
+    ,"Operation Timed Out"                  /* E_TIMEOUT */
+};
+
+
+#if (defined(REPORT_EVENTS) && (REPORT_EVENTS > 0))
+
+const char *eventStrings[] =
+{
+     "Rx Discard"                           /* EV_RX_DISCARD */
+    ,"Rx Error"                             /* EV_RX_ERROR */
+    ,"Tx Error"                             /* EV_TX_ERROR */
+    ,"No Buffer Objects"                    /* EV_NO_BUFFERS */
+    ,"No MB-Frame Objects"                  /* EV_NO_MB_FRAMES */
+    ,"No SB-Frame Objects"                  /* EV_NO_SB_FRAMES */
+    ,"Tx Queue Is Full"                     /* EV_TX_QUEUE_FULL */
+    ,"Rx Queue Is Full"                     /* EV_RX_QUEUE_FULL */
+    ,"Interrupts Queue Is Full"             /* EV_INTR_QUEUE_FULL */
+    ,"Data Buffer Is Unavailable"           /* EV_NO_DATA_BUFFER */
+    ,"Objects Pool Is Empty"                /* EV_OBJ_POOL_EMPTY */
+    ,"Illegal bus access"                   /* EV_BUS_ERROR */
+    ,"PTP Tx Timestamps Queue Is Full"      /* EV_PTP_TXTS_QUEUE_FULL */
+    ,"PTP Rx Timestamps Queue Is Full"      /* EV_PTP_RXTS_QUEUE_FULL */
+};
+
+#endif /* (defined(REPORT_EVENTS) && (REPORT_EVENTS > 0)) */
+
+#endif /* (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0)) */
+
diff --git a/drivers/net/dpa/NetCommSw/etc/list.c b/drivers/net/dpa/NetCommSw/etc/list.c
new file mode 100644
index 0000000..e71aed9
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/etc/list.c
@@ -0,0 +1,70 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**************************************************************************//**
+
+ @File          list.c
+
+ @Description   Implementation of list.
+*//***************************************************************************/
+#include "std_ext.h"
+#include "list_ext.h"
+
+
+void LIST_Append(t_List *p_NewList, t_List *p_Head)
+{
+    t_List *p_First = LIST_FIRST(p_NewList);
+
+    if (p_First != p_NewList)
+    {
+        t_List *p_Last  = LIST_LAST(p_NewList);
+        t_List *p_Cur   = LIST_NEXT(p_Head);
+
+        LIST_PREV(p_First) = p_Head;
+        LIST_FIRST(p_Head) = p_First;
+        LIST_NEXT(p_Last)  = p_Cur;
+        LIST_LAST(p_Cur)   = p_Last;
+    }
+}
+
+
+int LIST_NumOfObjs(t_List *p_List)
+{
+    t_List *p_Tmp;
+    int    numOfObjs = 0;
+
+    if (!LIST_IsEmpty(p_List))
+        LIST_FOR_EACH(p_Tmp, p_List)
+            numOfObjs++;
+
+    return numOfObjs;
+}
diff --git a/drivers/net/dpa/NetCommSw/etc/memcpy.c b/drivers/net/dpa/NetCommSw/etc/memcpy.c
new file mode 100644
index 0000000..e43d3b9
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/etc/memcpy.c
@@ -0,0 +1,671 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+
+#include "std_ext.h"
+#include "xx_ext.h"
+#include "memcpy_ext.h"
+
+
+#ifdef CORE_8BIT_ACCESS_ERRATA
+static void MY_MY_WRITE_UINT8(uint8_t *addr, uint8_t val)
+{
+    uint32_t newAddr, newVal;
+    switch ((uint32_t)addr%4)
+    {
+    case (0):
+        newAddr = (uint32_t)addr;
+        newVal = GET_UINT32(*(uint32_t*)newAddr);
+        newVal = (newVal & 0x00ffffff) | (((uint32_t)val)<<24);
+        WRITE_UINT32(*(uint32_t*)newAddr, newVal);
+        break;
+    case (1):
+        newAddr = (((uint32_t)addr>>1)<<1);
+        newVal = GET_UINT32(*(uint32_t*)newAddr);
+        newVal = (newVal & 0xff00ffff) | (((uint32_t)val)<<16);
+        WRITE_UINT32(*(uint32_t*)newAddr, newVal);
+        break;
+    case (2):
+        newAddr = (((uint32_t)addr>>2)<<2);
+        newVal = GET_UINT32(*(uint32_t*)newAddr);
+        newVal = (newVal & 0xffff00ff) | (((uint32_t)val)<<8);
+        WRITE_UINT32(*(uint32_t*)newAddr, newVal);
+        break;
+    case (3):
+        newAddr = (((uint32_t)addr>>3)<<3);
+        newVal = GET_UINT32(*(uint32_t*)newAddr);
+        newVal = (newVal & 0xffffff00) | val;
+        WRITE_UINT32(*(uint32_t*)newAddr, newVal);
+        break;
+    }
+}
+
+static uint8_t MY_MY_GET_UINT8(uint8_t *addr)
+{
+    uint32_t newAddr, newVal=0;
+    switch ((uint32_t)addr%4)
+    {
+    case (0):
+        newAddr = (uint32_t)addr;
+        newVal = GET_UINT32(*(uint32_t*)newAddr);
+        newVal = (newVal & 0xff000000)>>24;
+        break;
+    case (1):
+        newAddr = (((uint32_t)addr>>1)<<1);
+        newVal = GET_UINT32(*(uint32_t*)newAddr);
+        newVal = (newVal & 0x00ff0000)>>16;
+        break;
+    case (2):
+        newAddr = (((uint32_t)addr>>2)<<2);
+        newVal = GET_UINT32(*(uint32_t*)newAddr);
+        newVal = (newVal & 0x0000ff00)>>8;
+        break;
+    case (3):
+        newAddr = (((uint32_t)addr>>3)<<3);
+        newVal = GET_UINT32(*(uint32_t*)newAddr);
+        newVal = (newVal & 0x000000ff);
+        break;
+    }
+
+    return (uint8_t)newVal;
+}
+
+#define MY_WRITE_UINT8(addr,val) MY_MY_WRITE_UINT8(&addr,val)
+#define MY_GET_UINT8(addr) MY_MY_GET_UINT8(&addr)
+#else
+#define MY_WRITE_UINT8 WRITE_UINT8
+#define MY_GET_UINT8   GET_UINT8
+#endif /* CORE_8BIT_ACCESS_ERRATA */
+
+
+void * MemCpy32(void* pDst,void* pSrc, uint32_t size)
+{
+    uint32_t leftAlign;
+    uint32_t rightAlign;
+    uint32_t lastWord;
+    uint32_t currWord;
+    uint32_t *p_Src32;
+    uint32_t *p_Dst32;
+    uint8_t  *p_Src8;
+    uint8_t  *p_Dst8;
+
+    p_Src8 = (uint8_t*)(pSrc);
+    p_Dst8 = (uint8_t*)(pDst);
+    /* first copy byte by byte till the source first alignment
+     * this step is necessary to ensure we do not even try to access
+     * data which is before the source buffer, hence it is not ours.
+     */
+    while(((uint32_t)(p_Src8) & 3) && size) /* (pSrc mod 4) > 0 and size > 0 */
+    {
+        *p_Dst8++ = *p_Src8++;
+        size--;
+    }
+
+    /* align destination (possibly disaligning source)*/
+    while(((uint32_t)(p_Dst8) & 3) && size) /* (pDst mod 4) > 0 and size > 0 */
+    {
+        *p_Dst8++ = *p_Src8++;
+        size--;
+    }
+
+    /* dest is aligned and source is not necessarily aligned */
+    leftAlign = (((uint32_t)(p_Src8) & 3) << 3); /* leftAlign = (pSrc mod 4)*8 */
+    rightAlign = 32 - leftAlign;
+
+
+    if (leftAlign == 0)
+    {
+        /* source is also aligned */
+        p_Src32 = (uint32_t*)(p_Src8);
+        p_Dst32 = (uint32_t*)(p_Dst8);
+        while (size >> 2) /* size >= 4 */
+        {
+            *p_Dst32++ = *p_Src32++;
+            size -= 4;
+        }
+        p_Src8 = (uint8_t*)(p_Src32);
+        p_Dst8 = (uint8_t*)(p_Dst32);
+    }
+    else
+    {
+        /* source is not aligned (destination is aligned)*/
+        p_Src32 = (uint32_t*)(p_Src8 - (leftAlign >> 3));
+        p_Dst32 = (uint32_t*)(p_Dst8);
+        lastWord = *p_Src32++;
+        while(size >> 3) /* size >= 8 */
+        {
+            currWord = *p_Src32;
+            *p_Dst32 = (lastWord << leftAlign) | (currWord >> rightAlign);
+            lastWord = currWord;
+            p_Src32++;
+            p_Dst32++;
+            size -= 4;
+        }
+        p_Dst8 = (uint8_t*)(p_Dst32);
+        p_Src8 = (uint8_t*)(p_Src32) - 4 + (leftAlign >> 3);
+    }
+
+    /* complete the left overs */
+    while (size--)
+        *p_Dst8++ = *p_Src8++;
+
+    return pDst;
+}
+
+void * IO2IOCpy32(void* pDst,void* pSrc, uint32_t size)
+{
+    uint32_t leftAlign;
+    uint32_t rightAlign;
+    uint32_t lastWord;
+    uint32_t currWord;
+    uint32_t *p_Src32;
+    uint32_t *p_Dst32;
+    uint8_t  *p_Src8;
+    uint8_t  *p_Dst8;
+
+    p_Src8 = (uint8_t*)(pSrc);
+    p_Dst8 = (uint8_t*)(pDst);
+    /* first copy byte by byte till the source first alignment
+     * this step is necessary to ensure we do not even try to access
+     * data which is before the source buffer, hence it is not ours.
+     */
+    while(((uint32_t)(p_Src8) & 3) && size) /* (pSrc mod 4) > 0 and size > 0 */
+    {
+        MY_WRITE_UINT8(*p_Dst8, MY_GET_UINT8(*p_Src8));
+        p_Dst8++;p_Src8++;
+        size--;
+    }
+
+    /* align destination (possibly disaligning source)*/
+    while(((uint32_t)(p_Dst8) & 3) && size) /* (pDst mod 4) > 0 and size > 0 */
+    {
+        MY_WRITE_UINT8(*p_Dst8, MY_GET_UINT8(*p_Src8));
+        p_Dst8++;p_Src8++;
+        size--;
+    }
+
+    /* dest is aligned and source is not necessarily aligned */
+    leftAlign = (((uint32_t)(p_Src8) & 3) << 3); /* leftAlign = (pSrc mod 4)*8 */
+    rightAlign = 32 - leftAlign;
+
+    if (leftAlign == 0)
+    {
+        /* source is also aligned */
+        p_Src32 = (uint32_t*)(p_Src8);
+        p_Dst32 = (uint32_t*)(p_Dst8);
+        while (size >> 2) /* size >= 4 */
+        {
+            WRITE_UINT32(*p_Dst32, GET_UINT32(*p_Src32));
+            p_Dst32++;p_Src32++;
+            size -= 4;
+        }
+        p_Src8 = (uint8_t*)(p_Src32);
+        p_Dst8 = (uint8_t*)(p_Dst32);
+    }
+    else
+    {
+        /* source is not aligned (destination is aligned)*/
+        p_Src32 = (uint32_t*)(p_Src8 - (leftAlign >> 3));
+        p_Dst32 = (uint32_t*)(p_Dst8);
+        lastWord = GET_UINT32(*p_Src32);
+        p_Src32++;
+        while(size >> 3) /* size >= 8 */
+        {
+            currWord = GET_UINT32(*p_Src32);
+            WRITE_UINT32(*p_Dst32, (lastWord << leftAlign) | (currWord >> rightAlign));
+            lastWord = currWord;
+            p_Src32++;p_Dst32++;
+            size -= 4;
+        }
+        p_Dst8 = (uint8_t*)(p_Dst32);
+        p_Src8 = (uint8_t*)(p_Src32) - 4 + (leftAlign >> 3);
+    }
+
+    /* complete the left overs */
+    while (size--)
+    {
+        MY_WRITE_UINT8(*p_Dst8, MY_GET_UINT8(*p_Src8));
+        p_Dst8++;p_Src8++;
+    }
+
+    return pDst;
+}
+
+void * Mem2IOCpy32(void* pDst,void* pSrc, uint32_t size)
+{
+    uint32_t leftAlign;
+    uint32_t rightAlign;
+    uint32_t lastWord;
+    uint32_t currWord;
+    uint32_t *p_Src32;
+    uint32_t *p_Dst32;
+    uint8_t  *p_Src8;
+    uint8_t  *p_Dst8;
+
+    p_Src8 = (uint8_t*)(pSrc);
+    p_Dst8 = (uint8_t*)(pDst);
+    /* first copy byte by byte till the source first alignment
+     * this step is necessary to ensure we do not even try to access
+     * data which is before the source buffer, hence it is not ours.
+     */
+    while(((uint32_t)(p_Src8) & 3) && size) /* (pSrc mod 4) > 0 and size > 0 */
+    {
+        MY_WRITE_UINT8(*p_Dst8, *p_Src8);
+        p_Dst8++;p_Src8++;
+        size--;
+    }
+
+    /* align destination (possibly disaligning source)*/
+    while(((uint32_t)(p_Dst8) & 3) && size) /* (pDst mod 4) > 0 and size > 0 */
+    {
+        MY_WRITE_UINT8(*p_Dst8, *p_Src8);
+        p_Dst8++;p_Src8++;
+        size--;
+    }
+
+    /* dest is aligned and source is not necessarily aligned */
+    leftAlign = (((uint32_t)(p_Src8) & 3) << 3); /* leftAlign = (pSrc mod 4)*8 */
+    rightAlign = 32 - leftAlign;
+
+    if (leftAlign == 0)
+    {
+        /* source is also aligned */
+        p_Src32 = (uint32_t*)(p_Src8);
+        p_Dst32 = (uint32_t*)(p_Dst8);
+        while (size >> 2) /* size >= 4 */
+        {
+            WRITE_UINT32(*p_Dst32, *p_Src32);
+            p_Dst32++;p_Src32++;
+            size -= 4;
+        }
+        p_Src8 = (uint8_t*)(p_Src32);
+        p_Dst8 = (uint8_t*)(p_Dst32);
+    }
+    else
+    {
+        /* source is not aligned (destination is aligned)*/
+        p_Src32 = (uint32_t*)(p_Src8 - (leftAlign >> 3));
+        p_Dst32 = (uint32_t*)(p_Dst8);
+        lastWord = *p_Src32++;
+        while(size >> 3) /* size >= 8 */
+        {
+            currWord = *p_Src32;
+            WRITE_UINT32(*p_Dst32, (lastWord << leftAlign) | (currWord >> rightAlign));
+            lastWord = currWord;
+            p_Src32++;p_Dst32++;
+            size -= 4;
+        }
+        p_Dst8 = (uint8_t*)(p_Dst32);
+        p_Src8 = (uint8_t*)(p_Src32) - 4 + (leftAlign >> 3);
+    }
+
+    /* complete the left overs */
+    while (size--)
+    {
+        MY_WRITE_UINT8(*p_Dst8, *p_Src8);
+        p_Dst8++;p_Src8++;
+    }
+
+    return pDst;
+}
+
+void * IO2MemCpy32(void* pDst,void* pSrc, uint32_t size)
+{
+    uint32_t leftAlign;
+    uint32_t rightAlign;
+    uint32_t lastWord;
+    uint32_t currWord;
+    uint32_t *p_Src32;
+    uint32_t *p_Dst32;
+    uint8_t  *p_Src8;
+    uint8_t  *p_Dst8;
+
+    p_Src8 = (uint8_t*)(pSrc);
+    p_Dst8 = (uint8_t*)(pDst);
+    /* first copy byte by byte till the source first alignment
+     * this step is necessary to ensure we do not even try to access
+     * data which is before the source buffer, hence it is not ours.
+     */
+    while(((uint32_t)(p_Src8) & 3) && size) /* (pSrc mod 4) > 0 and size > 0 */
+    {
+        *p_Dst8 = MY_GET_UINT8(*p_Src8);
+        p_Dst8++;p_Src8++;
+        size--;
+    }
+
+    /* align destination (possibly disaligning source)*/
+    while(((uint32_t)(p_Dst8) & 3) && size) /* (pDst mod 4) > 0 and size > 0 */
+    {
+        *p_Dst8 = MY_GET_UINT8(*p_Src8);
+        p_Dst8++;p_Src8++;
+        size--;
+    }
+
+    /* dest is aligned and source is not necessarily aligned */
+    leftAlign = (((uint32_t)(p_Src8) & 3) << 3); /* leftAlign = (pSrc mod 4)*8 */
+    rightAlign = 32 - leftAlign;
+
+    if (leftAlign == 0)
+    {
+        /* source is also aligned */
+        p_Src32 = (uint32_t*)(p_Src8);
+        p_Dst32 = (uint32_t*)(p_Dst8);
+        while (size >> 2) /* size >= 4 */
+        {
+            *p_Dst32 = GET_UINT32(*p_Src32);
+            p_Dst32++;p_Src32++;
+            size -= 4;
+        }
+        p_Src8 = (uint8_t*)(p_Src32);
+        p_Dst8 = (uint8_t*)(p_Dst32);
+    }
+    else
+    {
+        /* source is not aligned (destination is aligned)*/
+        p_Src32 = (uint32_t*)(p_Src8 - (leftAlign >> 3));
+        p_Dst32 = (uint32_t*)(p_Dst8);
+        lastWord = GET_UINT32(*p_Src32);
+        p_Src32++;
+        while(size >> 3) /* size >= 8 */
+        {
+            currWord = GET_UINT32(*p_Src32);
+            *p_Dst32 = (lastWord << leftAlign) | (currWord >> rightAlign);
+            lastWord = currWord;
+            p_Src32++;p_Dst32++;
+            size -= 4;
+        }
+        p_Dst8 = (uint8_t*)(p_Dst32);
+        p_Src8 = (uint8_t*)(p_Src32) - 4 + (leftAlign >> 3);
+    }
+
+    /* complete the left overs */
+    while (size--)
+    {
+        *p_Dst8 = MY_GET_UINT8(*p_Src8);
+        p_Dst8++;p_Src8++;
+    }
+
+    return pDst;
+}
+
+void * MemCpy64(void* pDst,void* pSrc, uint32_t size)
+{
+    uint32_t leftAlign;
+    uint32_t rightAlign;
+    uint64_t lastWord;
+    uint64_t currWord;
+    uint64_t *pSrc64;
+    uint64_t *pDst64;
+    uint8_t  *p_Src8;
+    uint8_t  *p_Dst8;
+
+    p_Src8 = (uint8_t*)(pSrc);
+    p_Dst8 = (uint8_t*)(pDst);
+    /* first copy byte by byte till the source first alignment
+     * this step is necessarily to ensure we do not even try to access
+     * data which is before the source buffer, hence it is not ours.
+     */
+    while(((uint32_t)(p_Src8) & 7) && size) /* (pSrc mod 8) > 0 and size > 0 */
+    {
+        *p_Dst8++ = *p_Src8++;
+        size--;
+    }
+
+    /* align destination (possibly disaligning source)*/
+    while(((uint32_t)(p_Dst8) & 7) && size) /* (pDst mod 8) > 0 and size > 0 */
+    {
+        *p_Dst8++ = *p_Src8++;
+        size--;
+    }
+
+    /* dest is aligned and source is not necessarily aligned */
+    leftAlign = (((uint32_t)(p_Src8) & 7) << 3); /* leftAlign = (pSrc mod 8)*8 */
+    rightAlign = 64 - leftAlign;
+
+
+    if (leftAlign == 0)
+    {
+        /* source is also aligned */
+        pSrc64 = (uint64_t*)(p_Src8);
+        pDst64 = (uint64_t*)(p_Dst8);
+        while (size >> 3) /* size >= 8 */
+        {
+            *pDst64++ = *pSrc64++;
+            size -= 8;
+        }
+        p_Src8 = (uint8_t*)(pSrc64);
+        p_Dst8 = (uint8_t*)(pDst64);
+    }
+    else
+    {
+        /* source is not aligned (destination is aligned)*/
+        pSrc64 = (uint64_t*)(p_Src8 - (leftAlign >> 3));
+        pDst64 = (uint64_t*)(p_Dst8);
+        lastWord = *pSrc64++;
+        while(size >> 4) /* size >= 16 */
+        {
+            currWord = *pSrc64;
+            *pDst64 = (lastWord << leftAlign) | (currWord >> rightAlign);
+            lastWord = currWord;
+            pSrc64++;
+            pDst64++;
+            size -= 8;
+        }
+        p_Dst8 = (uint8_t*)(pDst64);
+        p_Src8 = (uint8_t*)(pSrc64) - 8 + (leftAlign >> 3);
+    }
+
+    /* complete the left overs */
+    while (size--)
+        *p_Dst8++ = *p_Src8++;
+
+    return pDst;
+}
+
+void * MemSet32(void* pDst, uint8_t val, uint32_t size)
+{
+    uint32_t val32;
+    uint32_t *p_Dst32;
+    uint8_t  *p_Dst8;
+
+    p_Dst8 = (uint8_t*)(pDst);
+
+    /* generate four 8-bit val's in 32-bit container */
+    val32  = (uint32_t) val;
+    val32 |= (val32 <<  8);
+    val32 |= (val32 << 16);
+
+    /* align destination to 32 */
+    while(((uint32_t)(p_Dst8) & 3) && size) /* (pDst mod 4) > 0 and size > 0 */
+    {
+        *p_Dst8++ = val;
+        size--;
+    }
+
+    /* 32-bit chunks */
+    p_Dst32 = (uint32_t*)(p_Dst8);
+    while (size >> 2) /* size >= 4 */
+    {
+        *p_Dst32++ = val32;
+        size -= 4;
+    }
+
+    /* complete the leftovers */
+    p_Dst8 = (uint8_t*)(p_Dst32);
+    while (size--)
+        *p_Dst8++ = val;
+
+    return pDst;
+}
+
+void * IOMemSet32(void* pDst, uint8_t val, uint32_t size)
+{
+    uint32_t val32;
+    uint32_t *p_Dst32;
+    uint8_t  *p_Dst8;
+
+    p_Dst8 = (uint8_t*)(pDst);
+
+    /* generate four 8-bit val's in 32-bit container */
+    val32  = (uint32_t) val;
+    val32 |= (val32 <<  8);
+    val32 |= (val32 << 16);
+
+    /* align destination to 32 */
+    while(((uint32_t)(p_Dst8) & 3) && size) /* (pDst mod 4) > 0 and size > 0 */
+    {
+        MY_WRITE_UINT8(*p_Dst8, val);
+        p_Dst8++;
+        size--;
+    }
+
+    /* 32-bit chunks */
+    p_Dst32 = (uint32_t*)(p_Dst8);
+    while (size >> 2) /* size >= 4 */
+    {
+        WRITE_UINT32(*p_Dst32, val32);
+        p_Dst32++;
+        size -= 4;
+    }
+
+    /* complete the leftovers */
+    p_Dst8 = (uint8_t*)(p_Dst32);
+    while (size--)
+    {
+        MY_WRITE_UINT8(*p_Dst8, val);
+        p_Dst8++;
+    }
+
+    return pDst;
+}
+
+void * MemSet64(void* pDst, uint8_t val, uint32_t size)
+{
+    uint64_t val64;
+    uint64_t *pDst64;
+    uint8_t  *p_Dst8;
+
+    p_Dst8 = (uint8_t*)(pDst);
+
+    /* generate four 8-bit val's in 32-bit container */
+    val64  = (uint64_t) val;
+    val64 |= (val64 <<  8);
+    val64 |= (val64 << 16);
+    val64 |= (val64 << 24);
+    val64 |= (val64 << 32);
+
+    /* align destination to 64 */
+    while(((uint32_t)(p_Dst8) & 7) && size) /* (pDst mod 8) > 0 and size > 0 */
+    {
+        *p_Dst8++ = val;
+        size--;
+    }
+
+    /* 64-bit chunks */
+    pDst64 = (uint64_t*)(p_Dst8);
+    while (size >> 4) /* size >= 8 */
+    {
+        *pDst64++ = val64;
+        size -= 8;
+    }
+
+    /* complete the leftovers */
+    p_Dst8 = (uint8_t*)(pDst64);
+    while (size--)
+        *p_Dst8++ = val;
+
+    return pDst;
+}
+
+void MemDisp(uint8_t *p, int size)
+{
+    uint32_t    space = ((uint32_t)p & 0x3);
+    uint8_t     *p_Limit;
+
+    if (space)
+    {
+        p_Limit = (p - space + 4);
+
+        XX_Print("0x%08X: ", (p - space));
+
+        while (space--)
+        {
+            XX_Print("--");
+        }
+        while (size  && (p < p_Limit))
+        {
+            XX_Print("%02x", *(uint8_t*)p);
+            size--;
+            p++;
+        }
+
+        XX_Print(" ");
+        p_Limit += 12;
+
+        while ((size > 3) && (p < p_Limit))
+        {
+            XX_Print("%08x ", *(uint32_t*)p);
+            size -= 4;
+            p += 4;
+        }
+        XX_Print("\r\n");
+    }
+
+    while (size > 15)
+    {
+        XX_Print("0x%08X: %08x %08x %08x %08x\r\n",
+                 p, *(uint32_t *)p, *(uint32_t *)(p + 4),
+                 *(uint32_t *)(p + 8), *(uint32_t *)(p + 12));
+        size -= 16;
+        p += 16;
+    }
+
+    if (size)
+    {
+        XX_Print("0x%08X: ", p);
+
+        while (size > 3)
+        {
+            XX_Print("%08x ", *(uint32_t *)p);
+            size -= 4;
+            p += 4;
+        }
+        while (size)
+        {
+            XX_Print("%02x", *(uint8_t *)p);
+            size--;
+            p++;
+        }
+
+        XX_Print("\r\n");
+    }
+}
diff --git a/drivers/net/dpa/NetCommSw/etc/mm.c b/drivers/net/dpa/NetCommSw/etc/mm.c
new file mode 100644
index 0000000..086711f
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/etc/mm.c
@@ -0,0 +1,1083 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "string_ext.h"
+#include "error_ext.h"
+#include "std_ext.h"
+#include "sprint_ext.h"
+#include "part_ext.h"
+#include "xx_ext.h"
+
+#include "mm.h"
+
+
+/* Prototypes of the internal MM routines */
+static uint64_t MM_GetGreaterAlignment(t_MM *p_MM, uint64_t size, int alignment, char* name);
+
+static t_Error  MM_AddFree(t_MM *p_MM, uint64_t base, uint64_t end);
+static t_Error  MM_CutFree(t_MM *p_MM, uint64_t holdBase, uint64_t holdEnd);
+static void     MM_AddBusy(t_MM *p_MM, t_BusyBlock *p_NewBusyB);
+static t_Error  MM_CutBusy(t_MM *p_MM, uint64_t base, uint64_t end);
+
+static t_Error  MemBlock_Init(t_Handle *memBlock, uint64_t base, uint64_t size);
+static t_Error  FreeBlock_Init(t_Handle *freeBlock, uint64_t base, uint64_t size);
+static t_Error  BusyBlock_Init(t_Handle *busyBlock, uint64_t base, uint64_t size, char *name);
+
+
+/**********************************************************************
+ *                     MM API routines set                            *
+ **********************************************************************/
+
+/*****************************************************************************/
+t_Error MM_Init(t_Handle *h_MM, uint64_t base, uint64_t size)
+{
+    t_MM        *p_MM;
+    uint64_t    newBase, newSize;
+    int         i;
+
+    if (!size)
+    {
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Size (should be positive)"));
+    }
+
+    /* Initializes a new MM object */
+    p_MM = (t_MM *)XX_Malloc(sizeof(t_MM));
+    if (!p_MM)
+    {
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, NO_MSG);
+    }
+
+    /* initializes a new memory block */
+    if ( MemBlock_Init((t_Handle *)&p_MM->memBlocks, base, size) != E_OK )
+    {
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, NO_MSG);
+    }
+
+    /* A busy list is empty */
+    p_MM->busyBlocks = 0;
+
+    /*Initializes a new free block for each free list*/
+    for (i=0; i <= MM_MAX_ALIGNMENT; i++)
+    {
+        newBase = MAKE_ALIGNED( base, (0x1 << i) );
+        newSize = size - (newBase - base);
+
+        if ( FreeBlock_Init((t_Handle *)&p_MM->freeBlocks[i], newBase, newSize ) != E_OK)
+        {
+            RETURN_ERROR(MAJOR, E_NO_MEMORY, NO_MSG);
+        }
+    }
+
+    *h_MM = p_MM;
+
+    return (E_OK);
+}
+
+
+/*****************************************************************************/
+uint64_t MM_Get(t_Handle h_MM, uint64_t size, int alignment, char* name)
+{
+    t_MM        *p_MM = (t_MM *)h_MM;
+    t_FreeBlock *p_FreeB;
+    t_BusyBlock *p_NewBusyB;
+    uint64_t    holdBase, holdEnd;
+    int         i = 0, j;
+
+    SANITY_CHECK_RETURN_VALUE(p_MM, E_INVALID_HANDLE, (uint64_t)ILLEGAL_BASE);
+
+    /* checks that alignment value is greater then zero */
+    if (alignment == 0)
+    {
+        alignment = 1;
+    }
+
+    j = alignment;
+
+    /* checks if alignment is a power of two, if it correct and if the
+       required size is multiple of the given alignment. */
+    while ((j & 0x1) == 0)
+    {
+        i++;
+        j = j >> 1;
+    }
+
+    /* if the given alignment isn't power of two, returns an error */
+    if (j != 1)
+    {
+        REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("alignment (should be power of 2)"));
+        return (uint64_t)ILLEGAL_BASE;
+    }
+
+    if (i > MM_MAX_ALIGNMENT)
+    {
+        return (MM_GetGreaterAlignment(p_MM, size, alignment, name));
+    }
+
+    /* look for a block of the size greater or equal to the required size. */
+    p_FreeB = p_MM->freeBlocks[i];
+    while ( p_FreeB && (p_FreeB->end - p_FreeB->base) < size )
+        p_FreeB = p_FreeB->p_Next;
+
+    /* If such block is found */
+    if ( !p_FreeB )
+        return (uint64_t)(ILLEGAL_BASE);
+
+    holdBase = p_FreeB->base;
+    holdEnd = holdBase + size;
+
+    /* init a new busy block */
+    if ( BusyBlock_Init ( (t_Handle *)&p_NewBusyB, holdBase, size, name ) != E_OK )
+        return (uint64_t)(ILLEGAL_BASE);
+
+    /* calls Update routine to update a lists of free blocks */
+    if ( MM_CutFree ( p_MM, holdBase, holdEnd ) != E_OK )
+        return (uint64_t)(ILLEGAL_BASE);
+
+    /* insert the new busy block into the list of busy blocks */
+    MM_AddBusy ( p_MM, p_NewBusyB );
+
+    return (holdBase);
+}
+
+
+/*****************************************************************************/
+uint64_t MM_GetForce(t_Handle h_MM, uint64_t base, uint64_t size, char* name)
+{
+    t_MM        *p_MM = (t_MM *)h_MM;
+    t_FreeBlock *p_FreeB;
+    t_BusyBlock *p_NewBusyB;
+    bool        blockIsFree = FALSE;
+
+    ASSERT_COND(p_MM);
+
+    p_FreeB = p_MM->freeBlocks[0]; /* The biggest free blocks are in the
+                                      free list with alignment 1 */
+    while ( p_FreeB )
+    {
+        if ( base >= p_FreeB->base && (base+size) <= p_FreeB->end )
+        {
+            blockIsFree = TRUE;
+            break;
+        }
+        else
+            p_FreeB = p_FreeB->p_Next;
+    }
+
+    if ( !blockIsFree )
+        return (uint64_t)(ILLEGAL_BASE);
+
+    /* init a new busy block */
+    if ( BusyBlock_Init ( (t_Handle *)&p_NewBusyB, base, size, name ) != E_OK )
+        return (uint64_t)(ILLEGAL_BASE);
+
+    /* calls Update routine to update a lists of free blocks */
+    if ( MM_CutFree ( p_MM, base, base+size ) != E_OK )
+        return (uint64_t)(ILLEGAL_BASE);
+
+    /* insert the new busy block into the list of busy blocks */
+    MM_AddBusy ( p_MM, p_NewBusyB );
+    return (base);
+}
+
+
+/*****************************************************************************/
+uint64_t MM_GetForceMin(t_Handle h_MM, uint64_t size, int alignment, uint64_t min, char* name)
+{
+    t_MM        *p_MM = (t_MM *)h_MM;
+    t_FreeBlock *p_FreeB;
+    t_BusyBlock *p_NewBusyB;
+    uint64_t    holdBase, holdEnd;
+    int         i=0, j = alignment;
+
+    ASSERT_COND(p_MM);
+
+    /* checks if alignment is a power of two, if it correct and if the
+       required size is multiple of the given alignment. */
+    while ((j & 0x1) == 0)
+    {
+        i++;
+        j = j >> 1;
+    }
+
+    if ( (j != 1) || (i > MM_MAX_ALIGNMENT) )
+    {
+        return (uint64_t)(ILLEGAL_BASE);
+    }
+
+    p_FreeB = p_MM->freeBlocks[i];
+
+    /* look for the first block that contains the minimum
+       base address. If the whole required size may be fit
+       into it, use that block, otherwise look for the next
+       block of size greater or equal to the required size. */
+    while ( p_FreeB && (min >= p_FreeB->end))
+            p_FreeB = p_FreeB->p_Next;
+
+    /* If such block is found */
+    if ( !p_FreeB )
+        return (uint64_t)(ILLEGAL_BASE);
+
+    /* if this block is large enough, use this block */
+    holdBase = ( min <= p_FreeB->base ) ? p_FreeB->base : min;
+    if ((holdBase + size) <= p_FreeB->end )
+    {
+        holdEnd = holdBase + size;
+    }
+    else
+    {
+        p_FreeB = p_FreeB->p_Next;
+        while ( p_FreeB && ((p_FreeB->end - p_FreeB->base) < size) )
+            p_FreeB = p_FreeB->p_Next;
+
+        /* If such block is found */
+        if ( !p_FreeB )
+            return (uint64_t)(ILLEGAL_BASE);
+
+        holdBase = p_FreeB->base;
+        holdEnd = holdBase + size;
+    }
+
+    /* init a new busy block */
+    if ( BusyBlock_Init((t_Handle *)&p_NewBusyB, holdBase, size, name) != E_OK )
+        return (uint64_t)(ILLEGAL_BASE);
+
+    /* calls Update routine to update a lists of free blocks */
+    if ( MM_CutFree( p_MM, holdBase, holdEnd ) != E_OK )
+        return (uint64_t)(ILLEGAL_BASE);
+
+    /* insert the new busy block into the list of busy blocks */
+    MM_AddBusy( p_MM, p_NewBusyB );
+
+    return (holdBase);
+}
+
+
+/*****************************************************************************/
+uint64_t MM_Put(t_Handle h_MM, uint64_t base)
+{
+    t_MM        *p_MM = (t_MM *)h_MM;
+    t_BusyBlock *p_BusyB, *p_PrevBusyB;
+    uint64_t    size;
+
+    ASSERT_COND(p_MM);
+
+    /* Look for a busy block that have the given base value.
+     * That block will be returned back to the memory.
+     */
+    p_PrevBusyB = 0;
+    p_BusyB = p_MM->busyBlocks;
+    while ( p_BusyB && base != p_BusyB->base )
+    {
+        p_PrevBusyB = p_BusyB;
+        p_BusyB = p_BusyB->p_Next;
+    }
+
+    if ( !p_BusyB )
+        return (0);
+
+    if ( MM_AddFree( p_MM, p_BusyB->base, p_BusyB->end ) != E_OK )
+        return (0);
+
+    /* removes a busy block form the list of busy blocks */
+    if ( p_PrevBusyB )
+        p_PrevBusyB->p_Next = p_BusyB->p_Next;
+    else
+        p_MM->busyBlocks = p_BusyB->p_Next;
+
+    size = p_BusyB->end - p_BusyB->base;
+
+    XX_Free(p_BusyB);
+
+    return (size);
+}
+
+
+/*****************************************************************************/
+uint64_t MM_PutForce(t_Handle h_MM, uint64_t base, uint64_t size)
+{
+    t_MM        *p_MM = (t_MM *)h_MM;
+    uint64_t    end = base + size;
+
+    ASSERT_COND(p_MM);
+
+    if ( MM_CutBusy( p_MM, base, end ) != E_OK )
+        return (0);
+
+    if ( MM_AddFree ( p_MM, base, end ) != E_OK )
+        return (0);
+
+    return (size);
+}
+
+
+/*****************************************************************************/
+t_Error MM_Add(t_Handle h_MM, uint64_t base, uint64_t size)
+{
+    t_MM        *p_MM = (t_MM *)h_MM;
+    t_MemBlock  *p_MemB, *p_NewMemB;
+    t_Error     errCode;
+
+    ASSERT_COND(p_MM);
+
+    /* find a last block in the list of memory blocks to insert a new
+     * memory block
+     */
+    p_MemB = p_MM->memBlocks;
+    while ( p_MemB->p_Next )
+    {
+        if ( base >= p_MemB->base && base < p_MemB->end )
+        {
+            RETURN_ERROR(MAJOR, E_ALREADY_EXISTS, NO_MSG);
+        }
+        p_MemB = p_MemB->p_Next;
+    }
+    /* check for a last memory block */
+    if ( base >= p_MemB->base && base < p_MemB->end )
+    {
+        RETURN_ERROR(MAJOR, E_ALREADY_EXISTS, NO_MSG);
+    }
+
+    /* create a new memory block */
+    if ( MemBlock_Init( (t_Handle *)&p_NewMemB, base, size ) != E_OK )
+    {
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, NO_MSG);
+    }
+
+    /* append a new memory block to the end of the list of memory blocks */
+    p_MemB->p_Next = p_NewMemB;
+
+    /* add a new free block to the free lists */
+    errCode = MM_AddFree(p_MM, base, base+size);
+    if (errCode)
+    {
+        p_MemB->p_Next = 0;
+        XX_Free(p_NewMemB);
+        return ((t_Error)errCode);
+    }
+
+    return (E_OK);
+}
+
+
+/*****************************************************************************/
+void        MM_Dump(t_Handle h_MM, void *buff)
+{
+    t_MM        *p_MM = (t_MM *)h_MM;
+    t_FreeBlock *p_FreeB;
+    t_BusyBlock *p_BusyB;
+    int          i;
+
+    p_BusyB = p_MM->busyBlocks;
+    Sprint(buff, "List of busy blocks:\n");
+    while (p_BusyB)
+    {
+        Sprint(buff, "\t0x%lx: (%s: b=0x%lx, e=0x%lx)\n",
+                (uint32_t)p_BusyB, p_BusyB->name, p_BusyB->base, p_BusyB->end );
+        p_BusyB = p_BusyB->p_Next;
+    }
+
+    Sprint(buff, "\nLists of free blocks according to alignment:\n");
+    for (i=0; i <= MM_MAX_ALIGNMENT; i++)
+    {
+        Sprint(buff, "%d alignment:\n", (0x1 << i));
+        p_FreeB = p_MM->freeBlocks[i];
+        while (p_FreeB)
+        {
+            Sprint(buff, "\t0x%lx: (b=0x%lx, e=0x%lx)\n",
+                     (uint32_t)p_FreeB, p_FreeB->base, p_FreeB->end );
+            p_FreeB = p_FreeB->p_Next;
+        }
+        Sprint(buff, "\n");
+    }
+}
+
+
+/**********************************************************************
+ *                     MM internal routines set                       *
+ **********************************************************************/
+
+/****************************************************************
+ *  Routine:    MM_AddFree
+ *
+ *  Description:
+ *      Adds a new free block to the free lists. It updates each
+ *      free list to include a new free block.
+ *      Note, that all free block in each free list are ordered
+ *      by their base address.
+ *
+ *  Arguments:
+ *      p_MM  - pointer to the MM object
+ *      base  - base address of a given free block
+ *      end   - end address of a given free block
+ *
+ *  Return value:
+ *
+ *
+ ****************************************************************/
+static t_Error MM_AddFree(t_MM *p_MM, uint64_t base, uint64_t end)
+{
+    t_FreeBlock *p_PrevB, *p_CurrB, *p_NewB;
+    uint32_t    alignment;
+    uint64_t    alignBase;
+    int         i;
+
+    /* Updates free lists to include  a just released block */
+    for (i=0; i <= MM_MAX_ALIGNMENT; i++)
+    {
+        p_PrevB = p_NewB = 0;
+        p_CurrB = p_MM->freeBlocks[i];
+
+        alignment = (uint32_t)(0x1 << i);
+        alignBase = MAKE_ALIGNED(base, alignment);
+
+        /* Goes to the next free list if there is no block to free */
+        if (alignBase >= end)
+            continue;
+
+        /* Looks for a free block that should be updated */
+        while ( p_CurrB )
+        {
+            if ( alignBase <= p_CurrB->end )
+            {
+                if ( end > p_CurrB->end )
+                {
+                    t_FreeBlock *p_NextB;
+                    while ( p_CurrB->p_Next && end > p_CurrB->p_Next->end )
+                    {
+                        p_NextB = p_CurrB->p_Next;
+                        p_CurrB->p_Next = p_CurrB->p_Next->p_Next;
+                        XX_Free(p_NextB);
+                    }
+
+                    p_NextB = p_CurrB->p_Next;
+                    if ( !p_NextB || (p_NextB && end < p_NextB->base) )
+                    {
+                        p_CurrB->end = end;
+                    }
+                    else
+                    {
+                        p_CurrB->end = p_NextB->end;
+                        p_CurrB->p_Next = p_NextB->p_Next;
+                        XX_Free(p_NextB);
+                    }
+                }
+                else if ( (end < p_CurrB->base) && ((end-alignBase) >= alignment) )
+                {
+                    if ( FreeBlock_Init((t_Handle *)&p_NewB,
+                                        alignBase,
+                                        end-alignBase) != E_OK )
+                    {
+                        RETURN_ERROR(MAJOR, E_NO_MEMORY, NO_MSG);
+                    }
+                    p_NewB->p_Next = p_CurrB;
+                    if (p_PrevB)
+                        p_PrevB->p_Next = p_NewB;
+                    else
+                        p_MM->freeBlocks[i] = p_NewB;
+                    break;
+                }
+
+                if ((alignBase < p_CurrB->base) && (end >= p_CurrB->base))
+                {
+                    p_CurrB->base = alignBase;
+                }
+
+                /* if size of the free block is less then alignment
+                 * deletes that free block from the free list. */
+                if ( (p_CurrB->end - p_CurrB->base) < alignment)
+                {
+                    if ( p_PrevB )
+                        p_PrevB->p_Next = p_CurrB->p_Next;
+                    else
+                        p_MM->freeBlocks[i] = p_CurrB->p_Next;
+                    XX_Free(p_CurrB);
+                }
+                break;
+            }
+            else
+            {
+                p_PrevB = p_CurrB;
+                p_CurrB = p_CurrB->p_Next;
+            }
+        }
+
+        /* If no free block found to be updated, insert a new free block
+         * to the end of the free list.
+         */
+        if ( !p_CurrB && ((((uint64_t)(end-base)) & ((uint64_t)(alignment-1))) == 0) )
+        {
+            if ( FreeBlock_Init((t_Handle *)&p_NewB, alignBase, end-base) != E_OK )
+            {
+                RETURN_ERROR(MAJOR, E_NO_MEMORY, NO_MSG);
+            }
+            if (p_PrevB)
+                p_PrevB->p_Next = p_NewB;
+            else
+                p_MM->freeBlocks[i] = p_NewB;
+        }
+
+        /* Update boundaries of the new free block */
+        if ((alignment == 1) && !p_NewB)
+        {
+            if ( p_CurrB && base > p_CurrB->base )
+                base = p_CurrB->base;
+            if ( p_CurrB && end < p_CurrB->end )
+                end = p_CurrB->end;
+        }
+    }
+
+    return (E_OK);
+}
+
+
+/****************************************************************
+ *  Routine:      MM_CutFree
+ *
+ *  Description:
+ *      Cuts a free block from holdBase to holdEnd from the free lists.
+ *      That is, it updates all free lists of the MM object do
+ *      not include a block of memory from holdBase to holdEnd.
+ *      For each free lists it seek for a free block that holds
+ *      either holdBase or holdEnd. If such block is found it updates it.
+ *
+ *  Arguments:
+ *      p_MM            - pointer to the MM object
+ *      holdBase        - base address of the allocated block
+ *      holdEnd         - end address of the allocated block
+ *
+ *  Return value:
+ *      E_OK is returned on success,
+ *      otherwise returns an error code.
+ *
+ ****************************************************************/
+static t_Error MM_CutFree(t_MM *p_MM, uint64_t holdBase, uint64_t holdEnd)
+{
+    t_FreeBlock *p_PrevB, *p_CurrB, *p_NewB;
+    uint64_t    alignBase, base, end;
+    uint32_t    alignment;
+    int         i;
+
+    for (i=0; i <= MM_MAX_ALIGNMENT; i++)
+    {
+        p_PrevB = p_NewB = 0;
+        p_CurrB = p_MM->freeBlocks[i];
+
+        alignment = (uint32_t)(0x1 << i);
+        alignBase = MAKE_ALIGNED(holdEnd, alignment);
+
+        while ( p_CurrB )
+        {
+            base = p_CurrB->base;
+            end = p_CurrB->end;
+
+            if ( (holdBase <= base) && (holdEnd <= end) && (holdEnd > base) )
+            {
+                if ( alignBase >= end ||
+                     (alignBase < end && ((end-alignBase) < alignment)) )
+                {
+                    if (p_PrevB)
+                        p_PrevB->p_Next = p_CurrB->p_Next;
+                    else
+                        p_MM->freeBlocks[i] = p_CurrB->p_Next;
+                    XX_Free( p_CurrB );
+                }
+                else
+                {
+                    p_CurrB->base = alignBase;
+                }
+                break;
+            }
+            else if ( (holdBase > base) && (holdEnd <= end) )
+            {
+                if ( (holdBase-base) >= alignment )
+                {
+                    if ( (alignBase < end) && ((end-alignBase) >= alignment) )
+                    {
+                        if ( FreeBlock_Init( (t_Handle *)&p_NewB,
+                                             alignBase,
+                                             (end-alignBase)) != E_OK )
+                        {
+                            RETURN_ERROR(MAJOR, E_NO_MEMORY, NO_MSG);
+                        }
+                        p_NewB->p_Next = p_CurrB->p_Next;
+                        p_CurrB->p_Next = p_NewB;
+                    }
+                    p_CurrB->end = holdBase;
+                }
+                else if ( (alignBase < end) && ((end-alignBase) >= alignment) )
+                {
+                    p_CurrB->base = alignBase;
+                }
+                else
+                {
+                    if (p_PrevB)
+                        p_PrevB->p_Next = p_CurrB->p_Next;
+                    else
+                        p_MM->freeBlocks[i] = p_CurrB->p_Next;
+                    XX_Free(p_CurrB);
+                }
+                break;
+            }
+            else
+            {
+                p_PrevB = p_CurrB;
+                p_CurrB = p_CurrB->p_Next;
+            }
+        }
+    }
+
+    return (E_OK);
+}
+
+
+/****************************************************************
+ *  Routine:     MM_AddBusy
+ *
+ *  Description:
+ *      Adds a new busy block to the list of busy blocks. Note,
+ *      that all busy blocks are ordered by their base address in
+ *      the busy list.
+ *
+ *  Arguments:
+ *      MM              - handler to the MM object
+ *      p_NewBusyB      - pointer to the a busy block
+ *
+ *  Return value:
+ *      None.
+ *
+ ****************************************************************/
+static void MM_AddBusy(t_MM *p_MM, t_BusyBlock *p_NewBusyB)
+{
+    t_BusyBlock *p_CurrBusyB, *p_PrevBusyB;
+
+    /* finds a place of a new busy block in the list of busy blocks */
+    p_PrevBusyB = 0;
+    p_CurrBusyB = p_MM->busyBlocks;
+
+    while ( p_CurrBusyB && p_NewBusyB->base > p_CurrBusyB->base )
+    {
+        p_PrevBusyB = p_CurrBusyB;
+        p_CurrBusyB = p_CurrBusyB->p_Next;
+    }
+
+    /* insert the new busy block into the list of busy blocks */
+    if ( p_CurrBusyB )
+        p_NewBusyB->p_Next = p_CurrBusyB;
+    if ( p_PrevBusyB )
+        p_PrevBusyB->p_Next = p_NewBusyB;
+    else
+        p_MM->busyBlocks = p_NewBusyB;
+}
+
+
+/****************************************************************
+ *  Routine:    MM_CutBusy
+ *
+ *  Description:
+ *      Cuts a block from base to end from the list of busy blocks.
+ *      This is done by updating the list of busy blocks do not
+ *      include a given block, that block is going to be free. If a
+ *      given block is a part of some other busy block, so that
+ *      busy block is updated. If there are number of busy blocks
+ *      included in the given block, so all that blocks are removed
+ *      from the busy list and the end blocks are updated.
+ *      If the given block devides some block into two parts, a new
+ *      busy block is added to the busy list.
+ *
+ *  Arguments:
+ *      p_MM  - pointer to the MM object
+ *      base  - base address of a given busy block
+ *      end   - end address of a given busy block
+ *
+ *  Return value:
+ *      E_OK on success, E_NOMEMORY otherwise.
+ *
+ ****************************************************************/
+static t_Error MM_CutBusy(t_MM *p_MM, uint64_t base, uint64_t end)
+{
+    t_BusyBlock  *p_CurrB, *p_PrevB, *p_NewB;
+
+    p_CurrB = p_MM->busyBlocks;
+    p_PrevB = p_NewB = 0;
+
+    while ( p_CurrB )
+    {
+        if ( base < p_CurrB->end )
+        {
+            if ( end > p_CurrB->end )
+            {
+                t_BusyBlock *p_NextB;
+                while ( p_CurrB->p_Next && end >= p_CurrB->p_Next->end )
+                {
+                    p_NextB = p_CurrB->p_Next;
+                    p_CurrB->p_Next = p_CurrB->p_Next->p_Next;
+                    XX_Free(p_NextB);
+                }
+
+                p_NextB = p_CurrB->p_Next;
+                if ( p_NextB && end > p_NextB->base )
+                {
+                    p_NextB->base = end;
+                }
+            }
+
+            if ( base <= p_CurrB->base )
+            {
+                if ( end < p_CurrB->end && end > p_CurrB->base )
+                {
+                    p_CurrB->base = end;
+                }
+                else if ( end >= p_CurrB->end )
+                {
+                    if ( p_PrevB )
+                        p_PrevB->p_Next = p_CurrB->p_Next;
+                    else
+                        p_MM->busyBlocks = p_CurrB->p_Next;
+                    XX_Free(p_CurrB);
+                }
+            }
+            else
+            {
+                if ( end < p_CurrB->end && end > p_CurrB->base )
+                {
+                    if ( BusyBlock_Init((t_Handle *)&p_NewB,
+                                        end,
+                                        p_CurrB->end-end,
+                                        p_CurrB->name ) != E_OK )
+                    {
+                        RETURN_ERROR(MAJOR, E_NO_MEMORY, NO_MSG);
+                    }
+                    p_NewB->p_Next = p_CurrB->p_Next;
+                    p_CurrB->p_Next = p_NewB;
+                }
+                p_CurrB->end = base;
+            }
+            break;
+        }
+        else
+        {
+            p_PrevB = p_CurrB;
+            p_CurrB = p_CurrB->p_Next;
+        }
+    }
+
+    return (E_OK);
+}
+
+
+/****************************************************************
+ *  Routine:   MemBlock_Init
+ *
+ *  Description:
+ *      Initializes a new memory block of "size" bytes and started
+ *      from "base" address.
+ *
+ *  Arguments:
+ *      memBlock- handle to the memBlock object
+ *      base    - base address of the memory block
+ *      size    - size of the memory block
+ *
+ *  Return value:
+ *      E_OK is returned on success. E_NOMEMORY is returned
+ *      if can't allocate memory for memBlock object.
+ ****************************************************************/
+static t_Error MemBlock_Init(t_Handle *memBlock, uint64_t base, uint64_t size)
+{
+    t_MemBlock *p_MemBlock;
+
+    p_MemBlock = (t_MemBlock *)XX_Malloc(sizeof(t_MemBlock));
+    if ( !p_MemBlock )
+    {
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, NO_MSG);
+    }
+
+    p_MemBlock->base = base;
+    p_MemBlock->end = base+size;
+    p_MemBlock->p_Next = 0;
+
+    *memBlock = p_MemBlock;
+
+    return (E_OK);
+}
+
+
+/****************************************************************
+ *  Routine:   FreeBlock_Init
+ *
+ *  Description:
+ *      Initializes a new free block of of "size" bytes and
+ *      started from "base" address.
+ *
+ *  Arguments:
+ *      freeBlock - handle to the freeBlock object
+ *      base      - base address of the free block
+ *      size      - size of the free block
+ *
+ *  Return value:
+ *      E_OK is returned on success. E_NOMEMORY is returned
+ *      if can't allocate memory for a free block.
+ ****************************************************************/
+static t_Error FreeBlock_Init(t_Handle *freeBlock, uint64_t base, uint64_t size)
+{
+    t_FreeBlock *p_FreeBlock;
+
+    p_FreeBlock = (t_FreeBlock *)XX_Malloc(sizeof(t_FreeBlock));
+    if ( !p_FreeBlock )
+    {
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, NO_MSG);
+    }
+
+    p_FreeBlock->base = base;
+    p_FreeBlock->end = base + size;
+    p_FreeBlock->p_Next = 0;
+
+    *freeBlock = p_FreeBlock;
+
+    return (E_OK);
+}
+
+
+/****************************************************************
+ *  Routine:   BusyBlock_Init
+ *
+ *  Description:
+ *      Initializes a new busy block of "size" bytes and started
+ *      rom "base" address. Each busy block has a name that
+ *      specified the purpose of the memory allocation.
+ *
+ *  Arguments:
+ *      busyBlock - handle to the busyBlock object
+ *      base      - base address of the busy block
+ *      size      - size of the busy block
+ *      name      - name that specified the busy block
+ *
+ *  Return value:
+ *      E_OK is returned on success. E_NOMEMORY is returned
+ *      if can't allocate memory for busy block.
+ ****************************************************************/
+static t_Error BusyBlock_Init(t_Handle *busyBlock, uint64_t base, uint64_t size, char *name)
+{
+    t_BusyBlock *p_BusyBlock;
+    int         n, nameLen;
+
+    p_BusyBlock = (t_BusyBlock *)XX_Malloc(sizeof(t_BusyBlock));
+    if ( !p_BusyBlock )
+    {
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, NO_MSG);
+    }
+
+    p_BusyBlock->base = base;
+    p_BusyBlock->end = base + size;
+    nameLen = (int)strlen(name);
+    n = (nameLen > MM_MAX_NAME_LEN - 1) ? MM_MAX_NAME_LEN-1 : nameLen;
+    strncpy(p_BusyBlock->name, name, (uint32_t)n);
+    p_BusyBlock->name[n] = '\0';
+    p_BusyBlock->p_Next = 0;
+
+    *busyBlock = p_BusyBlock;
+
+    return (E_OK);
+}
+
+
+/****************************************************************
+ *  Routine:     MM_GetGreaterAlignment
+ *
+ *  Description:
+ *      Allocates a block of memory according to the given size
+ *      and the alignment. That routine is called from the MM_Get
+ *      routine if the required alignment is greater then MM_MAX_ALIGNMENT.
+ *      In that case, it goes over free blocks of 64 byte align list
+ *      and checks if it has the required size of bytes of the required
+ *      alignment. If no blocks found returns ILLEGAL_BASE.
+ *      After the block is found and data is allocated, it calls
+ *      the internal MM_CutFree routine to update all free lists
+ *      do not include a just allocated block. Of course, each
+ *      free list contains a free blocks with the same alignment.
+ *      It is also creates a busy block that holds
+ *      information about an allocated block.
+ *
+ *  Arguments:
+ *      MM              - handle to the MM object
+ *      size            - size of the MM
+ *      alignment       - index as a power of two defines
+ *                        a required alignment that is greater then 64.
+ *      name            - the name that specifies an allocated block.
+ *
+ *  Return value:
+ *      base address of an allocated block.
+ *      ILLEGAL_BASE if can't allocate a block
+ *
+ ****************************************************************/
+static uint64_t MM_GetGreaterAlignment(t_MM *p_MM, uint64_t size, int alignment, char* name)
+{
+    t_FreeBlock *p_FreeB;
+    t_BusyBlock *p_NewBusyB;
+    uint64_t    holdBase, holdEnd, alignBase = 0;
+
+    /* goes over free blocks of the 64 byte alignment list
+       and look for a block of the suitable size and
+       base address according to the alignment. */
+    p_FreeB = p_MM->freeBlocks[MM_MAX_ALIGNMENT];
+
+    while ( p_FreeB )
+    {
+        alignBase = MAKE_ALIGNED(p_FreeB->base, alignment);
+
+        /* the block is found if the aligned base inside the block
+         * and has the anough size. */
+        if ( alignBase >= p_FreeB->base &&
+             alignBase < p_FreeB->end &&
+             size <= (p_FreeB->end - alignBase) )
+            break;
+        else
+            p_FreeB = p_FreeB->p_Next;
+    }
+
+    /* If such block isn't found */
+    if ( !p_FreeB )
+        return (uint64_t)(ILLEGAL_BASE);
+
+    holdBase = alignBase;
+    holdEnd = alignBase + size;
+
+    /* init a new busy block */
+    if ( BusyBlock_Init ( (t_Handle *)&p_NewBusyB, holdBase, size, name ) != E_OK )
+        return (uint64_t)(ILLEGAL_BASE);
+
+    /* calls Update routine to update a lists of free blocks */
+    if ( MM_CutFree ( p_MM, holdBase, holdEnd ) != E_OK )
+        return (uint64_t)(ILLEGAL_BASE);
+
+    /* insert the new busy block into the list of busy blocks */
+    MM_AddBusy ( p_MM, p_NewBusyB );
+
+    return (holdBase);
+}
+
+
+/*****************************************************************************/
+void MM_Free(t_Handle h_MM)
+{
+    t_MM        *p_MM = (t_MM *)h_MM;
+    t_MemBlock  *p_MemBlock;
+    t_BusyBlock *p_BusyBlock;
+    t_FreeBlock *p_FreeBlock;
+    void        *p_Block;
+    int         i;
+
+    ASSERT_COND(p_MM);
+
+    /* release memory allocated for busy blocks */
+    p_BusyBlock = p_MM->busyBlocks;
+    while ( p_BusyBlock )
+    {
+        p_Block = p_BusyBlock;
+        p_BusyBlock = p_BusyBlock->p_Next;
+        XX_Free(p_Block);
+    }
+
+    /* release memory allocated for free blocks */
+    for (i=0; i <= MM_MAX_ALIGNMENT; i++)
+    {
+        p_FreeBlock = p_MM->freeBlocks[i];
+        while ( p_FreeBlock )
+        {
+            p_Block = p_FreeBlock;
+            p_FreeBlock = p_FreeBlock->p_Next;
+            XX_Free(p_Block);
+        }
+    }
+
+    /* release memory allocated for memory blocks */
+    p_MemBlock = p_MM->memBlocks;
+    while ( p_MemBlock )
+    {
+        p_Block = p_MemBlock;
+        p_MemBlock = p_MemBlock->p_Next;
+        XX_Free(p_Block);
+    }
+
+    /* release memory allocated for MM object itself */
+    XX_Free(p_MM);
+}
+
+
+/*****************************************************************************/
+uint64_t MM_GetMemBlock(t_Handle h_MM, int index)
+{
+    t_MM       *p_MM = (t_MM*)h_MM;
+    t_MemBlock *p_MemBlock;
+    int         i;
+
+    ASSERT_COND(p_MM);
+
+    p_MemBlock = p_MM->memBlocks;
+    for (i=0; i < index; i++)
+        p_MemBlock = p_MemBlock->p_Next;
+
+    if ( p_MemBlock )
+        return (p_MemBlock->base);
+    else
+        return (uint64_t)ILLEGAL_BASE;
+}
+
+
+/*****************************************************************************/
+uint64_t MM_GetBase(t_Handle h_MM)
+{
+    t_MM       *p_MM = (t_MM*)h_MM;
+    t_MemBlock *p_MemBlock;
+
+    ASSERT_COND(p_MM);
+
+    p_MemBlock = p_MM->memBlocks;
+    return  p_MemBlock->base;
+}
+
+
+/*****************************************************************************/
+bool MM_InRange(t_Handle h_MM, uint64_t addr)
+{
+    t_MM       *p_MM = (t_MM*)h_MM;
+    t_MemBlock *p_MemBlock;
+
+    ASSERT_COND(p_MM);
+
+    p_MemBlock = p_MM->memBlocks;
+
+    if ((addr >= p_MemBlock->base) && (addr < p_MemBlock->end))
+        return TRUE;
+    else
+        return FALSE;
+}
+
diff --git a/drivers/net/dpa/NetCommSw/etc/mm.h b/drivers/net/dpa/NetCommSw/etc/mm.h
new file mode 100644
index 0000000..009e16b
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/etc/mm.h
@@ -0,0 +1,101 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/****************************************************************
+ *
+ * File:  mm.h
+ *
+ *
+ * Description:
+ *  MM (Memory Management) object definitions.
+ *  It also includes definitions of the Free Block, Busy Block
+ *  and Memory Block structures used by the MM object.
+ *
+ ****************************************************************/
+
+#ifndef __MM_H
+#define __MM_H
+
+
+#include "mm_ext.h"
+
+#define __ERR_MODULE__  MODULE_MM
+
+
+#define MAKE_ALIGNED(addr, align)    \
+    (((uint64_t)(addr) + ((align) - 1)) & (~((align) - 1)))
+
+
+/* t_MemBlock data stucutre defines parameters of the Memory Block */
+typedef struct t_MemBlock
+{
+    struct t_MemBlock *p_Next;    /* Pointer to the next memory block */
+
+    uint64_t  base;             /* Base address of the memory block */
+    uint64_t  end;              /* End address of the memory block */
+} t_MemBlock;
+
+
+/* t_FreeBlock data stucutre defines parameters of the Free Block */
+typedef struct t_FreeBlock
+{
+    struct t_FreeBlock *p_Next;   /* Pointer to the next free block */
+
+    uint64_t  base;             /* Base address of the block */
+    uint64_t  end;              /* End address of the block */
+} t_FreeBlock;
+
+
+/* t_BusyBlock data stucutre defines parameters of the Busy Block  */
+typedef struct t_BusyBlock
+{
+    struct t_BusyBlock *p_Next;       /* Pointer to the next free block */
+
+    uint64_t  base;                 /* Base address of the block */
+    uint64_t  end;                  /* End address of the block */
+    char  name[MM_MAX_NAME_LEN];    /* That block of memory was allocated for
+                                       something specified by the Name */
+} t_BusyBlock;
+
+
+/* t_MM data structure defines parameters of the MM object */
+typedef struct t_MM
+{
+    t_MemBlock*  memBlocks;     /* List of memory blocks (Memory list) */
+    t_BusyBlock* busyBlocks;    /* List of busy blocks (Busy list) */
+    t_FreeBlock* freeBlocks[MM_MAX_ALIGNMENT + 1];
+                                /* Alignment lists of free blocks (Free lists) */
+} t_MM;
+
+
+#endif
+
diff --git a/drivers/net/dpa/NetCommSw/etc/sprint.c b/drivers/net/dpa/NetCommSw/etc/sprint.c
new file mode 100644
index 0000000..c28341f
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/etc/sprint.c
@@ -0,0 +1,86 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/*------------------------------------------------------*/
+/*                                                      */
+/* File: sprint.c                                       */
+/*                                                      */
+/* Description:                                         */
+/*    Debug routines (externals)                        */
+/*                                                      */
+/* Modifications:                                       */
+/* ==============                                       */
+/*                                                      */
+/*------------------------------------------------------*/
+#include "string_ext.h"
+#include "stdlib_ext.h"
+#include "ctype_ext.h"
+#include "stdarg_ext.h"
+#include "sprint_ext.h"
+#include "std_ext.h"
+#include "xx_ext.h"
+
+
+int Sprint(char * buf, const char *fmt, ...)
+{
+    va_list args;
+    int i;
+
+    va_start(args, fmt);
+    i=vsprintf(buf,fmt,args);
+    va_end(args);
+    return i;
+}
+
+
+int Snprint(char * buf, uint32_t size, const char *fmt, ...)
+{
+    va_list args;
+    int i;
+
+    va_start(args, fmt);
+    i=vsnprintf(buf,size,fmt,args);
+    va_end(args);
+    return i;
+}
+
+
+int Sscan(const char * buf, const char * fmt, ...)
+{
+    va_list args;
+    int i;
+
+    va_start(args,fmt);
+    i = vsscanf(buf,fmt,args);
+    va_end(args);
+    return i;
+}
diff --git a/drivers/net/dpa/NetCommSw/events_mapping.h b/drivers/net/dpa/NetCommSw/events_mapping.h
new file mode 100644
index 0000000..9735ee4
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/events_mapping.h
@@ -0,0 +1,51 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __EVENTS_MAPPING_H
+#define __EVENTS_MAPPING_H
+
+
+#define EV_RX_DISCARD_LEVEL         REPORT_LEVEL_MINOR
+#define EV_RX_ERROR_LEVEL           REPORT_LEVEL_MINOR
+#define EV_TX_ERROR_LEVEL           REPORT_LEVEL_MINOR
+#define EV_NO_BUFFERS_LEVEL         REPORT_LEVEL_MAJOR
+#define EV_NO_MB_FRAMES_LEVEL       REPORT_LEVEL_MAJOR
+#define EV_NO_SB_FRAMES_LEVEL       REPORT_LEVEL_MAJOR
+#define EV_TX_QUEUE_FULL_LEVEL      REPORT_LEVEL_MINOR
+#define EV_RX_QUEUE_FULL_LEVEL      REPORT_LEVEL_MAJOR
+#define EV_INTR_QUEUE_FULL_LEVEL    REPORT_LEVEL_MINOR
+#define EV_NO_DATA_BUFFER_LEVEL     REPORT_LEVEL_MAJOR
+#define EV_OBJ_POOL_EMPTY_LEVEL     REPORT_LEVEL_MAJOR
+#define EV_BUS_ERROR_LEVEL          REPORT_LEVEL_CRITICAL
+
+
+#endif /* __EVENTS_MAPPING_H */
diff --git a/drivers/net/dpa/NetCommSw/inc/Peripherals/crc_mac_addr_ext.h b/drivers/net/dpa/NetCommSw/inc/Peripherals/crc_mac_addr_ext.h
new file mode 100644
index 0000000..a957648
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/inc/Peripherals/crc_mac_addr_ext.h
@@ -0,0 +1,363 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/*------------------------------------------------------*/
+/*                                                      */
+/* File: crc_mac_addr_ext.h                             */
+/*                                                      */
+/* Description:                                         */
+/*    Define a macro that calculate the crc value of    */
+/*    an Ethernet MAC address (48 bitd address          */
+/*------------------------------------------------------*/
+
+#ifndef __crc_mac_addr_ext_h
+#define __crc_mac_addr_ext_h
+
+#include "std_ext.h"
+
+
+static uint32_t crc_table[256] =
+{
+    0x00000000,
+    0x77073096,
+    0xee0e612c,
+    0x990951ba,
+    0x076dc419,
+    0x706af48f,
+    0xe963a535,
+    0x9e6495a3,
+    0x0edb8832,
+    0x79dcb8a4,
+    0xe0d5e91e,
+    0x97d2d988,
+    0x09b64c2b,
+    0x7eb17cbd,
+    0xe7b82d07,
+    0x90bf1d91,
+    0x1db71064,
+    0x6ab020f2,
+    0xf3b97148,
+    0x84be41de,
+    0x1adad47d,
+    0x6ddde4eb,
+    0xf4d4b551,
+    0x83d385c7,
+    0x136c9856,
+    0x646ba8c0,
+    0xfd62f97a,
+    0x8a65c9ec,
+    0x14015c4f,
+    0x63066cd9,
+    0xfa0f3d63,
+    0x8d080df5,
+    0x3b6e20c8,
+    0x4c69105e,
+    0xd56041e4,
+    0xa2677172,
+    0x3c03e4d1,
+    0x4b04d447,
+    0xd20d85fd,
+    0xa50ab56b,
+    0x35b5a8fa,
+    0x42b2986c,
+    0xdbbbc9d6,
+    0xacbcf940,
+    0x32d86ce3,
+    0x45df5c75,
+    0xdcd60dcf,
+    0xabd13d59,
+    0x26d930ac,
+    0x51de003a,
+    0xc8d75180,
+    0xbfd06116,
+    0x21b4f4b5,
+    0x56b3c423,
+    0xcfba9599,
+    0xb8bda50f,
+    0x2802b89e,
+    0x5f058808,
+    0xc60cd9b2,
+    0xb10be924,
+    0x2f6f7c87,
+    0x58684c11,
+    0xc1611dab,
+    0xb6662d3d,
+    0x76dc4190,
+    0x01db7106,
+    0x98d220bc,
+    0xefd5102a,
+    0x71b18589,
+    0x06b6b51f,
+    0x9fbfe4a5,
+    0xe8b8d433,
+    0x7807c9a2,
+    0x0f00f934,
+    0x9609a88e,
+    0xe10e9818,
+    0x7f6a0dbb,
+    0x086d3d2d,
+    0x91646c97,
+    0xe6635c01,
+    0x6b6b51f4,
+    0x1c6c6162,
+    0x856530d8,
+    0xf262004e,
+    0x6c0695ed,
+    0x1b01a57b,
+    0x8208f4c1,
+    0xf50fc457,
+    0x65b0d9c6,
+    0x12b7e950,
+    0x8bbeb8ea,
+    0xfcb9887c,
+    0x62dd1ddf,
+    0x15da2d49,
+    0x8cd37cf3,
+    0xfbd44c65,
+    0x4db26158,
+    0x3ab551ce,
+    0xa3bc0074,
+    0xd4bb30e2,
+    0x4adfa541,
+    0x3dd895d7,
+    0xa4d1c46d,
+    0xd3d6f4fb,
+    0x4369e96a,
+    0x346ed9fc,
+    0xad678846,
+    0xda60b8d0,
+    0x44042d73,
+    0x33031de5,
+    0xaa0a4c5f,
+    0xdd0d7cc9,
+    0x5005713c,
+    0x270241aa,
+    0xbe0b1010,
+    0xc90c2086,
+    0x5768b525,
+    0x206f85b3,
+    0xb966d409,
+    0xce61e49f,
+    0x5edef90e,
+    0x29d9c998,
+    0xb0d09822,
+    0xc7d7a8b4,
+    0x59b33d17,
+    0x2eb40d81,
+    0xb7bd5c3b,
+    0xc0ba6cad,
+    0xedb88320,
+    0x9abfb3b6,
+    0x03b6e20c,
+    0x74b1d29a,
+    0xead54739,
+    0x9dd277af,
+    0x04db2615,
+    0x73dc1683,
+    0xe3630b12,
+    0x94643b84,
+    0x0d6d6a3e,
+    0x7a6a5aa8,
+    0xe40ecf0b,
+    0x9309ff9d,
+    0x0a00ae27,
+    0x7d079eb1,
+    0xf00f9344,
+    0x8708a3d2,
+    0x1e01f268,
+    0x6906c2fe,
+    0xf762575d,
+    0x806567cb,
+    0x196c3671,
+    0x6e6b06e7,
+    0xfed41b76,
+    0x89d32be0,
+    0x10da7a5a,
+    0x67dd4acc,
+    0xf9b9df6f,
+    0x8ebeeff9,
+    0x17b7be43,
+    0x60b08ed5,
+    0xd6d6a3e8,
+    0xa1d1937e,
+    0x38d8c2c4,
+    0x4fdff252,
+    0xd1bb67f1,
+    0xa6bc5767,
+    0x3fb506dd,
+    0x48b2364b,
+    0xd80d2bda,
+    0xaf0a1b4c,
+    0x36034af6,
+    0x41047a60,
+    0xdf60efc3,
+    0xa867df55,
+    0x316e8eef,
+    0x4669be79,
+    0xcb61b38c,
+    0xbc66831a,
+    0x256fd2a0,
+    0x5268e236,
+    0xcc0c7795,
+    0xbb0b4703,
+    0x220216b9,
+    0x5505262f,
+    0xc5ba3bbe,
+    0xb2bd0b28,
+    0x2bb45a92,
+    0x5cb36a04,
+    0xc2d7ffa7,
+    0xb5d0cf31,
+    0x2cd99e8b,
+    0x5bdeae1d,
+    0x9b64c2b0,
+    0xec63f226,
+    0x756aa39c,
+    0x026d930a,
+    0x9c0906a9,
+    0xeb0e363f,
+    0x72076785,
+    0x05005713,
+    0x95bf4a82,
+    0xe2b87a14,
+    0x7bb12bae,
+    0x0cb61b38,
+    0x92d28e9b,
+    0xe5d5be0d,
+    0x7cdcefb7,
+    0x0bdbdf21,
+    0x86d3d2d4,
+    0xf1d4e242,
+    0x68ddb3f8,
+    0x1fda836e,
+    0x81be16cd,
+    0xf6b9265b,
+    0x6fb077e1,
+    0x18b74777,
+    0x88085ae6,
+    0xff0f6a70,
+    0x66063bca,
+    0x11010b5c,
+    0x8f659eff,
+    0xf862ae69,
+    0x616bffd3,
+    0x166ccf45,
+    0xa00ae278,
+    0xd70dd2ee,
+    0x4e048354,
+    0x3903b3c2,
+    0xa7672661,
+    0xd06016f7,
+    0x4969474d,
+    0x3e6e77db,
+    0xaed16a4a,
+    0xd9d65adc,
+    0x40df0b66,
+    0x37d83bf0,
+    0xa9bcae53,
+    0xdebb9ec5,
+    0x47b2cf7f,
+    0x30b5ffe9,
+    0xbdbdf21c,
+    0xcabac28a,
+    0x53b39330,
+    0x24b4a3a6,
+    0xbad03605,
+    0xcdd70693,
+    0x54de5729,
+    0x23d967bf,
+    0xb3667a2e,
+    0xc4614ab8,
+    0x5d681b02,
+    0x2a6f2b94,
+    0xb40bbe37,
+    0xc30c8ea1,
+    0x5a05df1b,
+    0x2d02ef8d
+};
+
+
+#define GET_MAC_ADDR_CRC(addr, crc)             \
+{                                               \
+    uint32_t    i;                              \
+    uint8_t     data;                           \
+                                                \
+    /* CRC calculation */                       \
+    crc = 0xffffffff;                           \
+    for (i=0; i < 6; i++)                       \
+    {                                           \
+        data = (uint8_t)(addr >> ((5-i)*8));    \
+        crc = crc^data;                         \
+        crc = crc_table[crc&0xff] ^ (crc>>8);   \
+    }                                           \
+}                                               \
+
+/*    Define a macro for getting the mirrored value of      */
+/*    a byte size number. (0x11010011 --> 0x11001011)       */
+/*    Sometimes the mirrored value of the CRC is required   */
+static __inline__ uint8_t GetMirror(uint8_t n)
+{
+    uint8_t mirror[16] =
+        {
+            0x00,
+            0x08,
+            0x04,
+            0x0c,
+            0x02,
+            0x0a,
+            0x06,
+            0x0e,
+            0x01,
+            0x09,
+            0x05,
+            0x0d,
+            0x03,
+            0x0b,
+            0x07,
+            0x0f
+        };
+    return ((uint8_t)(((mirror[n & 0x0f] << 4) | (mirror[n >> 4]))));
+}
+
+static __inline__ uint32_t GetMirror32(uint32_t n)
+{
+    return (((uint32_t)GetMirror((uint8_t)(n))<<24) |
+            ((uint32_t)GetMirror((uint8_t)(n>>8))<<16) |
+            ((uint32_t)GetMirror((uint8_t)(n>>16))<<8) |
+            ((uint32_t)GetMirror((uint8_t)(n>>24))));
+}
+
+#define MIRROR      GetMirror
+#define MIRROR_32   GetMirror32
+
+
+#endif /* __crc_mac_addr_ext_h */
diff --git a/drivers/net/dpa/NetCommSw/inc/Peripherals/fm_ext.h b/drivers/net/dpa/NetCommSw/inc/Peripherals/fm_ext.h
new file mode 100644
index 0000000..4fee320
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/inc/Peripherals/fm_ext.h
@@ -0,0 +1,1694 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**************************************************************************//**
+ @File          FM_ext.h
+
+ @Description   FM Application Programming Interface.
+*//***************************************************************************/
+#ifndef __FM_EXT
+#define __FM_EXT
+
+#include "error_ext.h"
+#include "std_ext.h"
+
+
+/**************************************************************************//**
+ @Group         FM_grp Frame Manager API
+
+ @Description   FM API functions, definitions and enums.
+
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Group         FM_lib_grp FM library
+
+ @Description   FM API functions, definitions and enums
+                The FM module is the main driver module and is a mandatory module
+                for FM driver users. Before any further module initialization,
+                this module must be initialized.
+                The FM is a "singletone" module. It is responsible of the common
+                HW modules: FPM, DMA, common QMI, common BMI initializations and
+                run-time control routines. This module must be initialized always
+                when working with any of the FM modules.
+                NOTE - We assumes that the FML will be initialize only by core No. 0!
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description   enum for defining port types
+*//***************************************************************************/
+typedef enum e_FmPortType {
+    e_FM_PORT_TYPE_OFFLINE_PARSING, /**< Offline parsing port (id's: 0-6, share id's with
+                                         host command, so must have exclusive id) */
+    e_FM_PORT_TYPE_HOST_COMMAND,    /**< Host command port (id's: 0-6, share id's with
+                                         offline parsing ports, so must have exclusive id) */
+    e_FM_PORT_TYPE_RX,              /**< 1G Rx port (id's: 0-3) */
+    e_FM_PORT_TYPE_RX_10G,          /**< 10G Rx port (id's: 0) */
+    e_FM_PORT_TYPE_TX,              /**< 1G Tx port (id's: 0-3) */
+    e_FM_PORT_TYPE_TX_10G,          /**< 10G Tx port (id's: 0) */
+    e_FM_PORT_TYPE_DUMMY
+} e_FmPortType;
+
+/**************************************************************************//**
+ @Collection    General FM defines
+*//***************************************************************************/
+#define FM_MAX_NUM_OF_PARTITIONS    64      /**< Maximim number of partitions */
+#define FM_PHYS_ADDRESS_SIZE        6       /**< FM Physical address size */
+/* @} */
+
+/**************************************************************************//**
+ @Collection   FM Frame error
+*//***************************************************************************/
+typedef uint32_t    fmPortFrameErrSelect_t;                         /**< typedef for defining Frame Descriptor errors */
+
+#define FM_PORT_FRM_ERR_UNSUPPORTED_FORMAT              0x04000000  /**< Offline parsing only! Unsupported Format */
+#define FM_PORT_FRM_ERR_LENGTH                          0x02000000  /**< Offline parsing only! Length Error */
+#define FM_PORT_FRM_ERR_DMA                             0x01000000  /**< DMA Data error */
+#define FM_PORT_FRM_ERR_PHYSICAL                        0x00080000  /**< Rx FIFO overflow, FCS error, code error, running disparity
+                                                                         error (SGMII and TBI modes), FIFO parity error. PHY
+                                                                         Sequence error, PHY error control character detected. */
+#define FM_PORT_FRM_ERR_SIZE                            0x00040000  /**< Frame too long OR Frame size exceeds max_length_frame  */
+#define FM_PORT_FRM_ERR_CLS_DISCARD                     0x00020000  /**< classification discard */
+#define FM_PORT_FRM_ERR_EXTRACTION                      0x00008000  /**< Extract Out of Frame */
+#define FM_PORT_FRM_ERR_NO_SCHEME                       0x00004000  /**< No Scheme Selected */
+#define FM_PORT_FRM_ERR_KEYSIZE_OVERFLOW                0x00002000  /**< No Scheme Selected */
+#define FM_PORT_FRM_ERR_COLOR_YELLOW                    0x00000400
+#define FM_PORT_FRM_ERR_COLOR_RED                       0x00000800
+#define FM_PORT_FRM_ERR_ILL_PLCR                        0x00000200  /**< Illegal Policer Profile selected */
+#define FM_PORT_FRM_ERR_PLCR_FRAME_LEN                  0x00000100  /**< Illegal Policer Profile selected */
+#define FM_PORT_FRM_ERR_PRS_TIMEOUT                     0x00000080  /**< Parser Time out Exceed */
+#define FM_PORT_FRM_ERR_PRS_ILL_INSTRUCT                0x00000040  /**< Invalid Soft Parser instruction */
+#define FM_PORT_FRM_ERR_PRS_HDR_ERR                     0x00000020  /**< Header error was identified during parsing */
+#define FM_PORT_FRM_ERR_PROCESS_TIMEOUT                 0x00000001  /**< FPT Frame Processing Timeout Exceeded */
+/* @} */
+
+#ifdef __MWERKS__
+#pragma pack(push,1)
+#endif /*__MWERKS__ */
+#define MEM_MAP_START
+
+/**************************************************************************//**
+ @Description   FM physical Address
+*//***************************************************************************/
+typedef _Packed struct t_FmPhysAddr
+{
+    volatile uint16_t high;
+    volatile uint32_t low;
+}_PackedType t_FmPhysAddr;
+
+/**************************************************************************//**
+ @Description   Parse results memory layout
+*//***************************************************************************/
+typedef _Packed struct t_FmPrsResult {
+    uint8_t     lpid;               /**< Logical port id */
+    uint8_t     shimr;              /**< Shim header result  */
+    uint16_t    l2r;                /**< Layer 2 result */
+    uint16_t    l3r;                /**< Layer 3 result */
+    uint8_t     l4r;                /**< Layer 4 result */
+    uint8_t     cplan;              /**< Classification plan id */
+    uint16_t    nxthdr;             /**< Next Header  */
+    uint16_t    cksum;              /**< Checksum */
+    uint32_t    lcv;                /**< LCV */
+    uint8_t     shim_off[3];        /**< Shim offset */
+    uint8_t     eth_off;            /**< ETH offset */
+    uint8_t     llc_snap_off;       /**< LLC_SNAP offset */
+    uint8_t     vlan_off[2];        /**< VLAN offset */
+    uint8_t     etype_off;          /**< ETYPE offset */
+    uint8_t     pppoe_off;          /**< PPP offset */
+    uint8_t     mpls_off[2];        /**< MPLS offset */
+    uint8_t     ip_off[2];          /**< IP offset */
+    uint8_t     gre_off;            /**< GRE offset */
+    uint8_t     l4_off;             /**< Layer 4 offset */
+    uint8_t     nxthdr_off;         /**< Parser end point */
+} _PackedType t_FmPrsResult;
+
+/**************************************************************************//**
+ @Description   Parse results
+*//***************************************************************************/
+#define FM_PR_L2_VLAN_STACK       0x0100
+#define FM_PR_L2_ETHERNET         0x8000
+#define FM_PR_L2_VLAN             0x4000
+#define FM_PR_L2_LLC_SNAP         0x2000
+#define FM_PR_L2_MPLS             0x1000
+#define FM_PR_L2_PPPoE            0x0800
+
+/**************************************************************************//**
+ @Description   Time stamp in buffer
+*//***************************************************************************/
+typedef _Packed struct t_FmTimeStamp {
+    uint32_t    timeStamp;          /**< Time stamp integer */
+    uint32_t    timeStampFrac;      /**< Time stamp fraction */
+} _PackedType t_FmTimeStamp;
+
+/**************************************************************************//**
+ @Description   Frame descriptor
+*//***************************************************************************/
+typedef _Packed struct t_FmFD {
+    uint32_t    id;                 /**< FD id */
+    uint32_t    addrl;              /**< Data Address */
+    uint32_t    length;             /**< Frame length */
+    uint32_t    status;             /**< FD status */
+} _PackedType t_FmFD;
+
+#define MEM_MAP_END
+#ifdef __MWERKS__
+#pragma pack(pop)
+#endif /* __MWERKS__ */
+
+/**************************************************************************//**
+ @Collection   Frame descriptor macros
+*//***************************************************************************/
+#define FM_FD_DD_MASK       0xc0000000           /**< FD DD field mask */
+#define FM_FD_PID_MASK      0x3f000000           /**< FD PID field mask */
+#define FM_FD_BPID_MASK     0x00ff0000           /**< FD BPID field mask */
+#define FM_FD_ADDRH_MASK    0x0000ffff           /**< FD ADDRH field mask */
+#define FM_FD_ADDRL_MASK    0xffffffff           /**< FD ADDRL field mask */
+#define FM_FD_FORMAT_MASK   0xe0000000           /**< FD FORMAT field mask */
+#define FM_FD_OFFSET_MASK   0x1ff00000           /**< FD OFFSET field mask */
+#define FM_FD_LENGTH_MASK   0x000fffff           /**< FD LENGTH field mask */
+
+#define FM_FD_GET_DD(fd)            ((((t_FmFD *)fd)->id & FM_FD_DD_MASK) >> (31-1))            /**< Macro to get FD DD field */
+#define FM_FD_GET_PID(fd)           ((((t_FmFD *)fd)->id & FM_FD_PID_MASK) >> (31-7))           /**< Macro to get FD PID field */
+#define FM_FD_GET_BPID(fd)          ((((t_FmFD *)fd)->id & FM_FD_BPID_MASK) >> (31-15))         /**< Macro to get FD BPID field */
+#define FM_FD_GET_ADDRH(fd)         (((t_FmFD *)fd)->id & FM_FD_ADDRH_MASK)                     /**< Macro to get FD ADDRH field */
+#define FM_FD_GET_ADDRL(fd)         ((t_FmFD *)fd)->addrl                                       /**< Macro to get FD ADDRL field */
+#define FM_FD_GET_PHYS_ADDR(fd)     ((uint64_t)(((uint64_t)FM_FD_GET_ADDRH(fd) << 32) | (uint64_t)FM_FD_GET_ADDRL(fd))) /**< Macro to get FD ADDR field */
+#define FM_FD_GET_FORMAT(fd)        ((((t_FmFD *)fd)->length & FM_FD_FORMAT_MASK) >> (31-2))    /**< Macro to get FD FORMAT field */
+#define FM_FD_GET_OFFSET(fd)        ((((t_FmFD *)fd)->length & FM_FD_OFFSET_MASK) >> (31-11))   /**< Macro to get FD OFFSET field */
+#define FM_FD_GET_LENGTH(fd)        (((t_FmFD *)fd)->length & FM_FD_LENGTH_MASK)                /**< Macro to get FD LENGTH field */
+#define FM_FD_GET_STATUS(fd)        ((t_FmFD *)fd)->status                                      /**< Macro to get FD STATUS field */
+#define FM_FD_GET_ADDR(fd)          XX_PhysToVirt(CAST_UINT64_TO_POINTER(FM_FD_GET_PHYS_ADDR(fd)))
+
+#define FM_FD_SET_DD(fd,val)        (((t_FmFD *)fd)->id = ((((t_FmFD *)fd)->id & ~FM_FD_DD_MASK) | ((val << (31-1))& FM_FD_DD_MASK )))      /**< Macro to get FD DD field */
+#define FM_FD_SET_PID(fd,val)       (((t_FmFD *)fd)->id = ((((t_FmFD *)fd)->id & ~FM_FD_PID_MASK) | ((val << (31-7))& FM_FD_PID_MASK)))     /**< Macro to get FD PID field */
+#define FM_FD_SET_BPID(fd,val)      (((t_FmFD *)fd)->id = ((((t_FmFD *)fd)->id & ~FM_FD_BPID_MASK) | ((val  << (31-15))& FM_FD_BPID_MASK))) /**< Macro to get FD BPID field */
+#define FM_FD_SET_ADDRH(fd,val)     (((t_FmFD *)fd)->id = ((((t_FmFD *)fd)->id & ~FM_FD_ADDRH_MASK) | (val & FM_FD_ADDRH_MASK)))            /**< Macro to get FD ADDRH field */
+#define FM_FD_SET_ADDRL(fd,val)     ((t_FmFD *)fd)->addrl = val                                 /**< Macro to get FD ADDRL field */
+#define FM_FD_SET_ADDR(fd,val)                                      \
+do {                                                                \
+    uint64_t physAddr = CAST_POINTER_TO_UINT64(XX_VirtToPhys(val)); \
+    FM_FD_SET_ADDRH(fd, ((uint32_t)(physAddr >> 32)));              \
+    FM_FD_SET_ADDRL(fd, (uint32_t)physAddr);                        \
+} while (0)                                                                                     /**< Macro to get FD ADDR field */
+#define FM_FD_SET_FORMAT(fd,val)    (((t_FmFD *)fd)->length = ((((t_FmFD *)fd)->length & ~FM_FD_FORMAT_MASK) | ((val  << (31-2))& FM_FD_FORMAT_MASK)))  /**< Macro to get FD FORMAT field */
+#define FM_FD_SET_OFFSET(fd,val)    (((t_FmFD *)fd)->length = ((((t_FmFD *)fd)->length & ~FM_FD_OFFSET_MASK) | ((val << (31-11))& FM_FD_OFFSET_MASK) )) /**< Macro to get FD OFFSET field */
+#define FM_FD_SET_LENGTH(fd,val)    (((t_FmFD *)fd)->length = (((t_FmFD *)fd)->length & ~FM_FD_LENGTH_MASK) | (val & FM_FD_LENGTH_MASK))                /**< Macro to get FD LENGTH field */
+#define FM_FD_SET_STATUS(fd,val)    ((t_FmFD *)fd)->status = val                                /**< Macro to get FD STATUS field */
+
+
+#define FM_FD_CMD_FCO  0x80000000      /* Frame queue Context Override */
+#define FM_FD_CMD_RPD  0x40000000      /* Read Prepended Data */
+#define FM_FD_CMD_UDP  0x20000000      /* Update Prepended Data */
+#define FM_FD_CMD_BMF  0x10000000      /* Buffer Must not be Freed */
+#define FM_FD_CMD_DTC  0x08000000      /* Do TCP Checksum */
+#define FM_FD_CMD_DME  0x01000000      /* DMA Error */
+#define FM_FD_CMD_CFQ  0x00ffffff      /* Confirmation Frame Queue */
+/* @} */
+
+/**************************************************************************//**
+ @Description   FM Exceptions
+*//***************************************************************************/
+typedef enum e_FmExceptions {
+    e_FM_EX_DMA_BUS_ERROR,              /**< DMA bus error. */
+    e_FM_EX_DMA_READ_ECC,               /**< Read Buffer ECC error */
+    e_FM_EX_DMA_SYSTEM_WRITE_ECC,       /**< Write Buffer ECC error on system side */
+    e_FM_EX_DMA_FM_WRITE_ECC,           /**< Write Buffer ECC error on FM side */
+    e_FM_EX_FPM_STALL_ON_TASKS ,        /**< Stall of tasks on FPM */
+    e_FM_EX_FPM_SINGLE_ECC,             /**< Single ECC on FPM. */
+    e_FM_EX_FPM_DOUBLE_ECC,             /**< Double ECC error on FPM ram access */
+    e_FM_EX_QMI_SINGLE_ECC,             /**< Single ECC on QMI. */
+    e_FM_EX_QMI_DOUBLE_ECC,             /**< Double bit ECC occured on QMI */
+    e_FM_EX_QMI_DEQ_FROM_DEFQ,          /**< Dequeu from default queue id, as a result
+                                             of invalid port id. */
+    e_FM_EX_BMI_LIST_RAM_ECC,           /**< Linked List RAM ECC error */
+    e_FM_EX_BMI_PIPELINE_ECC,           /**< Pipeline Table ECC Error */
+    e_FM_EX_BMI_STATISTICS_RAM_ECC,     /**< Statistics Count RAM ECC Error Enable */
+    e_FM_EX_IRAM_ECC,                   /**< Double bit ECC occured on IRAM*/
+    e_FM_EX_MURAM_ECC                   /**< Double bit ECC occured on MURAM*/
+} e_FmExceptions;
+
+/**************************************************************************//**
+ @Group         FM_init_grp FM Initialization Unit
+
+ @Description   FM Initialization Unit
+
+                Initialization Flow
+                Initialization of the FM Module will be carried out by the application
+                according to the following sequence:
+                a.  Calling the configuration routine with basic parameters.
+                b.  Calling the advance initialization routines to change driver's defaults.
+                c.  Calling the initialization routine.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Function      t_FmExceptionsCallback
+
+ @Description   Exceptions user callback routine, will be called upon an
+                exception passing the exception identification.
+
+ @Param[in]     h_App      - User's application descriptor.
+ @Param[in]     exception  - The exception.
+*//***************************************************************************/
+typedef void (t_FmExceptionsCallback) ( t_Handle              h_App,
+                                        e_FmExceptions        exception);
+
+/**************************************************************************//**
+ @Function      t_FmBusErrorCallback
+
+ @Description   Bus error user callback routine, will be called upon a
+                bus error, passing parameters describing the errors and the owner.
+
+ @Param[in]     h_App       - User's application descriptor.
+ @Param[in]     portType    - Port type (e_FmPortType)
+ @Param[in]     portId      - Port id - relative to type.
+ @Param[in]     addr        - Address that caused the error
+ @Param[in]     tnum        - Owner of error
+ @Param[in]     partition   - memory partition
+*//***************************************************************************/
+typedef void (t_FmBusErrorCallback) ( t_Handle        h_App,
+                                      e_FmPortType    portType,
+                                      uint8_t         portId,
+                                      uint64_t        addr,
+                                      uint8_t         tnum,
+                                      uint8_t         partition);
+
+/**************************************************************************//**
+ @Description   structure for defining Ucode patch for loading.
+*//***************************************************************************/
+typedef struct t_FmPcdFirmwareParams {
+    uint32_t                size;                   /**< Size of uCode */
+    uint32_t                *p_Code;                /**< A pointer to the uCode */
+} t_FmPcdFirmwareParams;
+
+/**************************************************************************//**
+ @Description   structure representing FM initialization parameters
+*//***************************************************************************/
+typedef struct t_FmParams {
+    uint8_t                 fmId;                   /**< Index of the FM */
+#ifndef CONFIG_GUEST_PARTITION
+    uint64_t                baseAddr;               /**< A pointer to base of memory mapped FM registers (virtual).*/
+    t_Handle                h_FmMuram;              /**< A handle of an initialized MURAM object,
+                                                         to be used by the FM */
+    uint16_t                fmClkFreq;              /**< In Mhz */
+    uint8_t                 liodnPerPartition[FM_MAX_NUM_OF_PARTITIONS]; /**< For each partition, LIODN should be configured here. */
+    t_FmExceptionsCallback  *f_Exceptions;          /**< An application callback routine to
+                                                         handle exceptions.*/
+    t_FmBusErrorCallback    *f_BusError;            /**< An application callback routine to
+                                                         handle exceptions.*/
+    t_Handle                h_App;                  /**< A handle to an application layer object; This handle will
+                                                         be passed by the driver upon calling the above callbacks */
+    int                     irq;                    /**< FM interrupt source for normal events */
+    int                     errIrq;                 /**< FM interrupt source for errors */
+    t_FmPcdFirmwareParams   firmware;               /**< Ucode */
+#endif /* CONFIG_GUEST_PARTITION */
+} t_FmParams;
+
+
+/**************************************************************************//**
+ @Function      FM_Config
+
+ @Description   Creates descriptor for the FM module.
+
+                The routine returns a handle (descriptor) to the FM object.
+                This descriptor must be passed as first parameter to all other
+                FM function calls.
+
+                No actual initialization or configuration of FM hardware is
+                done by this routine.
+
+ @Param[in]     p_FmParams  - A pointer to data structure of parameters
+
+ @Return        Handle to FM object, or NULL for Failure.
+*//***************************************************************************/
+t_Handle FM_Config(t_FmParams *p_FmParams);
+
+/**************************************************************************//**
+ @Function      FM_Init
+
+ @Description   Initializes the FM module
+
+ @Param[in]     h_Fm - FM module descriptor
+
+ @Return        E_OK on success; Error code otherwise.
+*//***************************************************************************/
+t_Error FM_Init(t_Handle h_Fm);
+
+/**************************************************************************//**
+ @Function      FM_Free
+
+ @Description   Frees all resources that were assigned to FM module.
+
+                Calling this routine invalidates the descriptor.
+
+ @Param[in]     h_Fm - FM module descriptor
+
+ @Return        E_OK on success; Error code otherwise.
+*//***************************************************************************/
+t_Error FM_Free(t_Handle h_Fm);
+
+
+/**************************************************************************//**
+ @Group         FM_advanced_init_grp    FM Advanced Configuration Unit
+
+ @Description   Configuration functions used to change default values.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description   DMA debug mode
+*//***************************************************************************/
+typedef enum e_FmDmaDbgCntMode {
+    e_FM_DMA_DBG_NO_CNT             = 0,    /**< No counting */
+    e_FM_DMA_DBG_CNT_DONE           = 1,    /**< Count DONE commands */
+    e_FM_DMA_DBG_CNT_COMM_Q_EM      = 2,    /**< count command queue emergency signals */
+    e_FM_DMA_DBG_CNT_INT_READ_EM    = 3,    /**< Count Internal Read buffer emergency signal */
+    e_FM_DMA_DBG_CNT_INT_WRITE_EM   = 4,    /**< Count Internal Write buffer emergency signal */
+    e_FM_DMA_DBG_CNT_FPM_WAIT       = 5,    /**< Count FPM WAIT signal */
+    e_FM_DMA_DBG_CNT_SIGLE_BIT_ECC  = 6,    /**< Single bit ECC errors. */
+    e_FM_DMA_DBG_CNT_RAW_WAR_PROT   = 7     /**< Number of times there was a need for RAW & WAR protection. */
+} e_FmDmaDbgCntMode;
+
+/**************************************************************************//**
+ @Description   DMA Cache Override
+*//***************************************************************************/
+typedef enum e_FmDmaCacheOverride {
+    e_FM_DMA_NO_CACHE_OR,                   /**< No override of the Cache field */
+    e_FM_DMA_NO_STASH_DATA,                 /**< Data should not be stashed in system level cache */
+    e_FM_DMA_MAY_STASH_DATA,                /**< Data may be stashed in system level cache */
+    e_FM_DMA_STASH_DATA                     /**< Data should be stashed in system level cache */
+} e_FmDmaCacheOverride;
+
+/**************************************************************************//**
+ @Description   DMA External Bus Priority
+*//***************************************************************************/
+typedef enum e_FmDmaExtBusPri {
+    e_FM_DMA_EXT_BUS_NORMAL,                /**< Normal priority */
+    e_FM_DMA_EXT_BUS_EBS,                   /**< AXI extended bus service priority */
+    e_FM_DMA_EXT_BUS_SOS,                   /**< AXI sos priority */
+    e_FM_DMA_EXT_BUS_EBS_AND_SOS            /**< AXI ebs + sos priority */
+} e_FmDmaExtBusPri;
+
+/**************************************************************************//**
+ @Description   enum for choosing the field that will be output on AID
+*//***************************************************************************/
+typedef enum e_FmDmaAidMode {
+    e_FM_DMA_AID_OUT_PORT_ID,               /**< 4 LSB of PORT_ID */
+    e_FM_DMA_AID_OUT_TNUM                   /**< 4 LSB of TNUM */
+} e_FmDmaAidMode;
+
+/**************************************************************************//**
+ @Description   DMA AXI Bus protection
+*//***************************************************************************/
+typedef enum e_FmDmaBusProtectionType {
+    e_FM_DMA_DATA_BUS_PROT,                 /**< AXI data bus protection */
+    e_FM_DMA_INSTRUCTION_BUS_PROT           /**< AXI instruction bus protection */
+} e_FmDmaBusProtectionType;
+
+/**************************************************************************//**
+ @Description   FPM Catasrophic error behaviour
+*//***************************************************************************/
+typedef enum e_FmCatastrophicErr {
+    e_FM_CATASTROPHIC_ERR_STALL_PORT,       /**< Port_ID is stalled (only reset can release it) */
+    e_FM_CATASTROPHIC_ERR_STALL_TASK        /**< Only errornous task is stalled */
+} e_FmCatastrophicErr;
+
+/**************************************************************************//**
+ @Description   FPM DMA error behaviour
+*//***************************************************************************/
+typedef enum e_FmDmaErr {
+    e_FM_DMA_ERR_CATASTROPHIC,              /**< Dma error is treated as a catastrophic error */
+    e_FM_DMA_ERR_REPORT                     /**< Dma error is just reported */
+} e_FmDmaErr;
+
+/**************************************************************************//**
+ @Description   DMA Emergency level by BMI emergency signal
+*//***************************************************************************/
+typedef enum e_FmDmaEmergencyLevel {
+    e_FM_DMA_EM_EBS,                        /**< EBS emergency */
+    e_FM_DMA_EM_SOS                         /**< SOS emergency */
+} e_FmDmaEmergencyLevel;
+
+/**************************************************************************//**
+ @Collection   DMA emergency options
+*//***************************************************************************/
+typedef uint32_t fmEmergencyBus_t;          /**< DMA emergency options */
+
+#define  FM_DMA_MURAM_READ_EMERGENCY        0x00800000    /**< Enable emergency for MURAM1 */
+#define  FM_DMA_MURAM_WRITE_EMERGENCY       0x00400000    /**< Enable emergency for MURAM2 */
+#define  FM_DMA_EXT_BUS_EMERGENCY           0x00100000    /**< Enable emergency for external bus */
+/* @} */
+
+/**************************************************************************//**
+ @Description   A structure for defining DMA emergency level
+*//***************************************************************************/
+typedef struct t_FmDmaEmergency {
+    fmEmergencyBus_t        emergencyBusSelect;             /**< An OR of the busses where emergency
+                                                                 should be enabled */
+    e_FmDmaEmergencyLevel   emergencyLevel;                 /**< EBS/SOS */
+} t_FmDmaEmergency;
+
+/**************************************************************************//**
+ @Description   structure for defining FM threshold
+*//***************************************************************************/
+typedef struct t_FmThresholds {
+    uint8_t                 dispLimit;                      /**< The number of times a frames may
+                                                                 be passed in the FM before assumed to
+                                                                 be looping. */
+    uint8_t                 prsDispTh;                      /**< This is the number pf packets that may be
+                                                                 queued in the parser dispatch queue*/
+    uint8_t                 plcrDispTh;                     /**< This is the number pf packets that may be
+                                                                 queued in the policer dispatch queue*/
+    uint8_t                 kgDispTh;                       /**< This is the number pf packets that may be
+                                                                 queued in the keygen dispatch queue*/
+    uint8_t                 bmiDispTh;                      /**< This is the number pf packets that may be
+                                                                 queued in the BMI dispatch queue*/
+    uint8_t                 qmiEnqDispTh;                   /**< This is the number pf packets that may be
+                                                                 queued in the QMI enqueue dispatch queue*/
+    uint8_t                 qmiDeqDispTh;                   /**< This is the number pf packets that may be
+                                                                 queued in the QMI dequeue dispatch queue*/
+    uint8_t                 fmCtl1DispTh;                    /**< This is the number pf packets that may be
+                                                                 queued in fmCtl1 dispatch queue*/
+    uint8_t                 fmCtl2DispTh;                    /**< This is the number pf packets that may be
+                                                                 queued in fmCtl2 dispatch queue*/
+} t_FmThresholds;
+
+/**************************************************************************//**
+ @Description   structure for defining DMA mode parameters
+*//***************************************************************************/
+typedef struct t_FmDmaBusProtect {
+    bool                        privilegeBusProtect;        /**< TRUE to select privilage bus protection */
+    e_FmDmaBusProtectionType    busProtectType;             /**< Data/Instruction protect select. */
+} t_FmDmaBusProtect;
+
+/**************************************************************************//**
+ @Description   structure for defining DMA thresholds
+*//***************************************************************************/
+typedef struct t_FmDmaThresholds {
+    uint8_t                     assertEmergency;            /**< When this value is reached,
+                                                                 assert emergency (Threshold)*/
+    uint8_t                     clearEmergency;             /**< After emergency is asserted, it is held
+                                                                 until this value is reached (Hystheresis) */
+} t_FmDmaThresholds;
+
+
+/**************************************************************************//**
+ @Function      FM_ConfigResetOnInit
+
+ @Description   Tell the driver whether to reset the FM before initialization or
+                not. It changes the default configuration [DEFAULT_resetOnInit].
+
+ @Param[in]     h_Fm                A handle to an FM Module.
+ @Param[in]     enable              When TRUE, FM will be reset before any initialization.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Config() and before FM_Init().
+*//***************************************************************************/
+t_Error FM_ConfigResetOnInit(t_Handle h_Fm, bool enable);
+
+/**************************************************************************//**
+ @Function      FM_ConfigTotalNumOfTasks
+
+ @Description   Change the total number of tasks from its default
+                configuration [DEFAULT_totalNumOfTasks]
+
+ @Param[in]     h_Fm                A handle to an FM Module.
+ @Param[in]     totalNumOfTasks     The selected new value.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Config() and before FM_Init().
+*//***************************************************************************/
+t_Error FM_ConfigTotalNumOfTasks(t_Handle h_Fm, uint8_t totalNumOfTasks);
+
+/**************************************************************************//**
+ @Function      FM_ConfigTotalFifoSize
+
+ @Description   Change the total Fifo size from its default
+                configuration [DEFAULT_totalFifoSize]
+
+ @Param[in]     h_Fm                A handle to an FM Module.
+ @Param[in]     totalFifoSize       The selected new value.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Config() and before FM_Init().
+*//***************************************************************************/
+t_Error FM_ConfigTotalFifoSize(t_Handle h_Fm, uint32_t totalFifoSize);
+
+/**************************************************************************//**
+ @Function      FM_ConfigMaxNumOfOpenDmas
+
+ @Description   Change the maximum allowed open DMA's for this FM from its default
+                configuration [DEFAULT_maxNumOfOpenDmas]
+
+ @Param[in]     h_Fm                A handle to an FM Module.
+ @Param[in]     maxNumOfOpenDmas    The selected new value.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Config() and before FM_Init().
+*//***************************************************************************/
+t_Error FM_ConfigMaxNumOfOpenDmas(t_Handle h_Fm, uint8_t maxNumOfOpenDmas);
+
+/**************************************************************************//**
+ @Function      FM_ConfigThresholds
+
+ @Description   Calling this routine changes the internal driver data base
+                from its default FM threshold configuration:
+                                          dispLimit:    [DEFAULT_dispLimit]
+                                          prsDispTh:    [DEFAULT_prsDispTh]
+                                          plcrDispTh:   [DEFAULT_plcrDispTh]
+                                          kgDispTh:     [DEFAULT_kgDispTh]
+                                          bmiDispTh:    [DEFAULT_bmiDispTh]
+                                          qmiEnqDispTh: [DEFAULT_qmiEnqDispTh]
+                                          qmiDeqDispTh: [DEFAULT_qmiDeqDispTh]
+                                          fmCtl1DispTh:  [DEFAULT_fmCtl1DispTh]
+                                          fmCtl2DispTh:  [DEFAULT_fmCtl2DispTh]
+
+ @Param[in]     h_Fm            A handle to an FM Module.
+ @Param[in]     p_FmThresholds  A structure of threshold parameters.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Config() and before FM_Init().
+*//***************************************************************************/
+t_Error FM_ConfigThresholds(t_Handle h_Fm, t_FmThresholds *p_FmThresholds);
+
+/**************************************************************************//**
+ @Function      FM_ConfigTimeStamp
+
+ @Description   This routine enables the FPM timeStamp and sets its frequency.
+                Calling this routine changes the internal driver data base
+                from its default configuration - by default time stamp is disabled.
+                The value selected here will be used for the non-Rx ports
+                rate-limit mechanism and for the policer profiles.
+                Note that rate-limiting may be done only for time
+                units larger than the timeStampPeriod specifies
+                here (i.e. select here the smallest time unit
+                required between all ports).
+
+
+ @Param[in]     h_Fm                A handle to an FM Module.
+ @Param[in]     timeStampPeriod    (in nano-seconds)
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Config() and before FM_Init().
+*//***************************************************************************/
+t_Error FM_ConfigTimeStamp(t_Handle h_Fm, uint32_t timeStampPeriod);
+
+/**************************************************************************//**
+ @Function      FM_ConfigDmaBusProtect
+
+ @Description   Calling this routine changes the internal driver data base
+                from its default FM threshold configuration
+                                  privilegeBusProtect:      [DEFAULT_secureBusProtect]
+                                  secureBusProtect:         [DEFAULT_privilegeBusProtect]
+                                  busProtectType:           [DEFAULT_busProtectionType]
+
+ @Param[in]     h_Fm                A handle to an FM Module.
+ @Param[in]     p_FmDmaBusProtect   A structure of bus protection parameters.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Config() and before FM_Init().
+*//***************************************************************************/
+t_Error FM_ConfigDmaBusProtect(t_Handle h_Fm, t_FmDmaBusProtect *p_FmDmaBusProtect);
+
+ /**************************************************************************//**
+ @Function      FM_ConfigDmaCacheOverride
+
+ @Description   Calling this routine changes the internal driver data base
+                from its default configuration of cache override mode [DEFAULT_cacheOverride]
+
+ @Param[in]     h_Fm            A handle to an FM Module.
+ @Param[in]     cacheOverride   The selected new value.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Config() and before FM_Init().
+*//***************************************************************************/
+t_Error FM_ConfigDmaCacheOverride(t_Handle h_Fm, e_FmDmaCacheOverride cacheOverride);
+
+/**************************************************************************//**
+ @Function      FM_ConfigDmaAidOverride
+
+ @Description   Calling this routine changes the internal driver data base
+                from its default configuration of aid override mode [DEFAULT_aidOverride]
+
+ @Param[in]     h_Fm            A handle to an FM Module.
+ @Param[in]     aidOverride     The selected new value.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Config() and before FM_Init().
+*//***************************************************************************/
+t_Error FM_ConfigDmaAidOverride(t_Handle h_Fm, bool aidOverride);
+
+/**************************************************************************//**
+ @Function      FM_ConfigDmaAidMode
+
+ @Description   Calling this routine changes the internal driver data base
+                from its default configuration of aid mode [DEFAULT_aidMode]
+
+ @Param[in]     h_Fm            A handle to an FM Module.
+ @Param[in]     aidMode         The selected new value.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Config() and before FM_Init().
+*//***************************************************************************/
+t_Error FM_ConfigDmaAidMode(t_Handle h_Fm, e_FmDmaAidMode aidMode);
+
+/**************************************************************************//**
+ @Function      FM_ConfigDmaAxiDbgNumOfBeats
+
+ @Description   Calling this routine changes the internal driver data base
+                from its default configuration of axi debug [DEFAULT_axiDbgNumOfBeats]
+
+ @Param[in]     h_Fm                A handle to an FM Module.
+ @Param[in]     axiDbgNumOfBeats    The selected new value.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Config() and before FM_Init().
+*//***************************************************************************/
+t_Error FM_ConfigDmaAxiDbgNumOfBeats(t_Handle h_Fm, uint8_t axiDbgNumOfBeats);
+
+/**************************************************************************//**
+ @Function      FM_ConfigDmaCamNumOfEntries
+
+ @Description   Calling this routine changes the internal driver data base
+                from its default configuration of number of CAM entries [DEFAULT_dmaCamNumOfEntries]
+
+ @Param[in]     h_Fm            A handle to an FM Module.
+ @Param[in]     numOfEntries    The selected new value.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Config() and before FM_Init().
+*//***************************************************************************/
+t_Error FM_ConfigDmaCamNumOfEntries(t_Handle h_Fm, uint8_t numOfEntries);
+
+/**************************************************************************//**
+ @Function      FM_ConfigDmaWatchdog
+
+ @Description   Calling this routine changes the internal driver data base
+                from its default watchdog configuration, which is the maximum
+                possible value.
+
+ @Param[in]     h_Fm            A handle to an FM Module.
+ @Param[in]     watchDogValue   The selected new value - in microseconds.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Config() and before FM_Init().
+*//***************************************************************************/
+t_Error FM_ConfigDmaWatchdog(t_Handle h_Fm, uint32_t watchDogValue);
+
+/**************************************************************************//**
+ @Function      FM_ConfigDmaWriteBufThresholds
+
+ @Description   Calling this routine changes the internal driver data base
+                from its default configuration of DMA write buffer threshold
+                assertEmergency: [DEFAULT_dmaWriteIntBufLow]
+                clearEmergency:  [DEFAULT_dmaWriteIntBufHigh]
+
+ @Param[in]     h_Fm                A handle to an FM Module.
+ @Param[in]     p_FmDmaThresholds   A structure of thresholds to define emegrency behavior -
+                                    When 'assertEmergency' value is reached, emergency is asserted,
+                                    then it is held until 'clearEmergency' value is reached.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Config() and before FM_Init().
+*//***************************************************************************/
+t_Error FM_ConfigDmaWriteBufThresholds(t_Handle h_Fm, t_FmDmaThresholds *p_FmDmaThresholds);
+
+ /**************************************************************************//**
+ @Function      FM_ConfigDmaCommQThresholds
+
+ @Description   Calling this routine changes the internal driver data base
+                from its default configuration of DMA command queue threshold
+                assertEmergency: [DEFAULT_dmaCommQLow]
+                clearEmergency:  [DEFAULT_dmaCommQHigh]
+
+ @Param[in]     h_Fm                A handle to an FM Module.
+ @Param[in]     p_FmDmaThresholds   A structure of thresholds to define emegrency behavior -
+                                    When 'assertEmergency' value is reached, emergency is asserted,
+                                    then it is held until 'clearEmergency' value is reached..
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Config() and before FM_Init().
+*//***************************************************************************/
+t_Error FM_ConfigDmaCommQThresholds(t_Handle h_Fm, t_FmDmaThresholds *p_FmDmaThresholds);
+
+/**************************************************************************//**
+ @Function      FM_ConfigDmaReadBufThresholds
+
+ @Description   Calling this routine changes the internal driver data base
+                from its default configuration of DMA read buffer threshold
+                assertEmergency: [DEFAULT_dmaReadIntBufLow]
+                clearEmergency:  [DEFAULT_dmaReadIntBufHigh]
+
+ @Param[in]     h_Fm                A handle to an FM Module.
+ @Param[in]     p_FmDmaThresholds   A structure of thresholds to define emegrency behavior -
+                                    When 'assertEmergency' value is reached, emergency is asserted,
+                                    then it is held until 'clearEmergency' value is reached..
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Config() and before FM_Init().
+*//***************************************************************************/
+t_Error FM_ConfigDmaReadBufThresholds(t_Handle h_Fm, t_FmDmaThresholds *p_FmDmaThresholds);
+
+/**************************************************************************//**
+ @Function      FM_ConfigDmaSosEmergencyThreshold
+
+ @Description   Calling this routine changes the internal driver data base
+                from its default dma SOS emergency configuration [DEFAULT_dmaSosEmergency]
+
+ @Param[in]     h_Fm                A handle to an FM Module.
+ @Param[in]     dmaSosEmergency     The selected new value.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Config() and before FM_Init().
+*//***************************************************************************/
+t_Error FM_ConfigDmaSosEmergencyThreshold(t_Handle h_Fm, uint32_t dmaSosEmergency);
+
+/**************************************************************************//**
+ @Function      FM_ConfigEnableCounters
+
+ @Description   Calling this routine changes the internal driver data base
+                from its default counters configuration where counters are disabled.
+
+ @Param[in]     h_Fm    A handle to an FM Module.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Config() and before FM_Init().
+*//***************************************************************************/
+t_Error FM_ConfigEnableCounters(t_Handle h_Fm);
+
+/**************************************************************************//**
+ @Function      FM_ConfigDmaDbgCounter
+
+ @Description   Calling this routine changes the internal driver data base
+                from its default DMA debug counters configuration [DEFAULT_dmaDbgCntMode]
+
+ @Param[in]     h_Fm                A handle to an FM Module.
+ @Param[in]     fmDmaDbgCntMode     An enum selecting the debug counter mode.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Config() and before FM_Init().
+*//***************************************************************************/
+t_Error FM_ConfigDmaDbgCounter(t_Handle h_Fm, e_FmDmaDbgCntMode fmDmaDbgCntMode);
+
+/**************************************************************************//**
+ @Function      FM_ConfigDmaStopOnBusErr
+
+ @Description   Calling this routine changes the internal driver data base
+                from its default selection of bus error behavior [DEFAULT_dmaStopOnBusError]
+
+
+ @Param[in]     h_Fm    A handle to an FM Module.
+ @Param[in]     stop    TRUE to stop on bus error, FALSE to continue.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Config() and before FM_Init().
+                Only if bus error is enabled.
+*//***************************************************************************/
+t_Error FM_ConfigDmaStopOnBusErr(t_Handle h_Fm, bool stop);
+
+/**************************************************************************//**
+ @Function      FM_ConfigDmaEmergency
+
+ @Description   Calling this routine changes the internal driver data base
+                from its default selection of DMA emergency where's it's disabled.
+
+ @Param[in]     h_Fm        A handle to an FM Module.
+ @Param[in]     p_Emergency An OR mask of all required options.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Config() and before FM_Init().
+*//***************************************************************************/
+t_Error FM_ConfigDmaEmergency(t_Handle h_Fm, t_FmDmaEmergency *p_Emergency);
+
+/**************************************************************************//**
+ @Function      FM_ConfigDmaEmergencySmoother
+
+ @Description   sets the minimum amount of DATA beats transferred on the AXI
+                READ and WRITE ports before lowering the emergency level.
+                By default smother is disabled.
+
+ @Param[in]     h_Fm            A handle to an FM Module.
+ @Param[in]     emergencyCnt    emergency switching counter.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Config() and before FM_Init().
+*//***************************************************************************/
+t_Error FM_ConfigDmaEmergencySmoother(t_Handle h_Fm, uint32_t emergencyCnt);
+
+/**************************************************************************//**
+ @Function      FM_ConfigDmaErr
+
+ @Description   Calling this routine changes the internal driver data base
+                from its default DMA error treatment [DEFAULT_dmaErr]
+
+ @Param[in]     h_Fm    A handle to an FM Module.
+ @Param[in]     dmaErr  The selected new choice.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Config() and before FM_Init().
+*//***************************************************************************/
+t_Error FM_ConfigDmaErr(t_Handle h_Fm, e_FmDmaErr dmaErr);
+
+/**************************************************************************//**
+ @Function      FM_ConfigCatastrophicErr
+
+ @Description   Calling this routine changes the internal driver data base
+                from its default behavior on catastrophic error [DEFAULT_catastrophicErr]
+
+ @Param[in]     h_Fm                A handle to an FM Module.
+ @Param[in]     catastrophicErr     The selected new choice.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Config() and before FM_Init().
+*//***************************************************************************/
+t_Error FM_ConfigCatastrophicErr(t_Handle h_Fm, e_FmCatastrophicErr catastrophicErr);
+
+/**************************************************************************//**
+ @Function      FM_ConfigEnableMuramTestMode
+
+ @Description   Calling this routine changes the internal driver data base
+                from its default selection of test mode where it's disabled.
+
+ @Param[in]     h_Fm    A handle to an FM Module.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Config() and before FM_Init().
+*//***************************************************************************/
+t_Error FM_ConfigEnableMuramTestMode(t_Handle h_Fm);
+
+/**************************************************************************//**
+ @Function      FM_ConfigEnableIramTestMode
+
+ @Description   Calling this routine changes the internal driver data base
+                from its default selection of test mode where it's disabled.
+
+ @Param[in]     h_Fm    A handle to an FM Module.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Config() and before FM_Init().
+*//***************************************************************************/
+t_Error FM_ConfigEnableIramTestMode(t_Handle h_Fm);
+
+/**************************************************************************//**
+ @Function      FM_ConfigHaltOnExternalActivation
+
+ @Description   Calling this routine changes the internal driver data base
+                from its default selection of FM behaviour on external halt
+                activation [DEFAULT_haltOnExternalActivation].
+
+ @Param[in]     h_Fm            A handle to an FM Module.
+ @Param[in]     enable          TRUE to enable halt on external halt
+                                activation.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Config() and before FM_Init().
+*//***************************************************************************/
+t_Error FM_ConfigHaltOnExternalActivation(t_Handle h_Fm, bool enable);
+
+/**************************************************************************//**
+ @Function      FM_ConfigHaltOnUnrecoverableEccError
+
+ @Description   Calling this routine changes the internal driver data base
+                from its default selection of FM behaviour on unrecoverable
+                Ecc error [DEFAULT_haltOnUnrecoverableEccError].
+
+ @Param[in]     h_Fm            A handle to an FM Module.
+ @Param[in]     enable          TRUE to enable halt on unrecoverable Ecc error
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Config() and before FM_Init().
+*//***************************************************************************/
+t_Error FM_ConfigHaltOnUnrecoverableEccError(t_Handle h_Fm, bool enable);
+
+/**************************************************************************//**
+ @Function      FM_ConfigException
+
+ @Description   Calling this routine changes the internal driver data base
+                from its default selection of exceptions enablement.
+                By default all exceptions are enabled.
+
+ @Param[in]     h_Fm            A handle to an FM Module.
+ @Param[in]     exception       The exception to be selected.
+ @Param[in]     enable          TRUE to enable interrupt, FALSE to mask it.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Config() and before FM_Init().
+*//***************************************************************************/
+t_Error FM_ConfigException(t_Handle h_Fm, e_FmExceptions exception, bool enable);
+
+/**************************************************************************//**
+ @Function      FM_ConfigExternalEccRamsEnable
+
+ @Description   Calling this routine changes the internal driver data base
+                from its default [DEFAULT_externalEccRamsEnable].
+                When this option is enabled Rams ECC enable is not effected
+                by the FPM RCR bit, but by a JTAG.
+
+ @Param[in]     h_Fm            A handle to an FM Module.
+ @Param[in]     enable          TRUE to enable this option.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Config() and before FM_Init().
+*//***************************************************************************/
+t_Error FM_ConfigExternalEccRamsEnable(t_Handle h_Fm, bool enable);
+
+/** @} */ /* end of FM_advanced_init_grp group */
+/** @} */ /* end of FM_init_grp group */
+
+
+/**************************************************************************//**
+ @Group         FM_runtime_control_grp FM Runtime Control Unit
+
+ @Description   FM Runtime control unit API functions, definitions and enums.
+                The FM driver provides a set of control routines for each module.
+                These routines may only be called after the module was fully
+                initialized (both configuration and initialization routines were
+                called). They are typically used to get information from hardware
+                (status, counters/statistics, revision etc.), to modify a current
+                state or to force/enable a required action. Run-time control may
+                be called whenever necessary and as many times as needed.
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Collection   General FM defines.
+*//***************************************************************************/
+#define NUM_OF_PORT_TYPES               e_FM_PORT_TYPE_DUMMY    /**< Number of port types */
+#define MAX_NUM_OF_PORTS_PER_TYPE       7                       /**< Max number of ports of the same type */
+/* @} */
+
+/**************************************************************************//**
+ @Description   Port id by type and relative id.
+                This type is a 2 dimentional array of port id's according
+                to port types.used to pass per-port parameters.
+                Note that not all places in the array are valid e.g
+                array[e_FM_PORT_TYPE_TX_10G][1] is not a valid indexes pair.
+*//***************************************************************************/
+typedef uint8_t t_PortsParam[NUM_OF_PORT_TYPES][MAX_NUM_OF_PORTS_PER_TYPE];
+
+/**************************************************************************//**
+ @Description   DMA Emergency control on MURAM
+*//***************************************************************************/
+typedef enum e_FmDmaMuramPort {
+    e_FM_DMA_MURAM_PORT_WRITE,              /**< MURAM write port */
+    e_FM_DMA_MURAM_PORT_READ                /**< MURAM read port */
+} e_FmDmaMuramPort;
+
+/**************************************************************************//**
+ @Description   enum for defining FM counters
+*//***************************************************************************/
+typedef enum e_FmCounters {
+    e_FM_COUNTERS_ENQ_TOTAL_FRAME,              /**< QMI total enqueued frames counter */
+    e_FM_COUNTERS_DEQ_TOTAL_FRAME,              /**< QMI total dequeued frames counter */
+    e_FM_COUNTERS_DEQ_0,                        /**< QMI 0 frames from QMan counter */
+    e_FM_COUNTERS_DEQ_1,                        /**< QMI 1 frames from QMan counter */
+    e_FM_COUNTERS_DEQ_2,                        /**< QMI 2 frames from QMan counter */
+    e_FM_COUNTERS_DEQ_3,                        /**< QMI 3 frames from QMan counter */
+    e_FM_COUNTERS_DEQ_FROM_DEFAULT,             /**< QMI dequeue from default queue counter */
+    e_FM_COUNTERS_DEQ_FROM_CONTEXT,             /**< QMI dequeue from FQ context counter */
+    e_FM_COUNTERS_DEQ_FROM_FD,                  /**< QMI dequeue from FD command field counter */
+    e_FM_COUNTERS_DEQ_CONFIRM,                  /**< QMI dequeue confirm counter */
+    e_FM_COUNTERS_SEMAPHOR_ENTRY_FULL_REJECT,   /**< DMA semaphor reject due to full entry counter */
+    e_FM_COUNTERS_SEMAPHOR_QUEUE_FULL_REJECT,   /**< DMA semaphor reject due to full CAM queue counter */
+    e_FM_COUNTERS_SEMAPHOR_SYNC_REJECT          /**< DMA semaphor reject due to sync counter */
+} e_FmCounters;
+
+/**************************************************************************//**
+ @Description   structure for returning revision information
+*//***************************************************************************/
+typedef struct t_FmRevisionInfo {
+    uint8_t         majorRev;               /**< Major revision */
+    uint8_t         minorRev;               /**< Minor revision */
+} t_FmRevisionInfo;
+
+/**************************************************************************//**
+ @Description   struct for defining DMA status
+*//***************************************************************************/
+typedef struct t_FmDmaStatus {
+    bool    cmqNotEmpty;            /**< Command queue is not empty */
+    bool    busError;               /**< Bus error occured */
+    bool    readBufEccError;        /**< Double ECC error on buffer Read */
+    bool    writeBufEccSysError;    /**< Double ECC error on buffer write from system side */
+    bool    writeBufEccFmError;     /**< Double ECC error on buffer write from FM side */
+} t_FmDmaStatus;
+
+
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+/**************************************************************************//**
+ @Function      FM_DumpRegs
+
+ @Description   Dumps all FM registers
+
+ @Param[in]     h_Fm      A handle to an FM Module.
+
+ @Return        E_OK on success;
+
+ @Cautions      Allowed only FM_Init().
+*//***************************************************************************/
+t_Error FM_DumpRegs(t_Handle h_Fm);
+#endif /* (defined(DEBUG_ERRORS) && ... */
+
+/**************************************************************************//**
+ @Function      FM_Isr
+
+ @Description   FM interrupt-service-routine.
+
+ @Param[in]     h_Fm            A handle to an FM Module.
+
+ @Cautions      Allowed only following FM_Init().
+*//***************************************************************************/
+void FM_Isr(t_Handle h_Fm);
+
+/**************************************************************************//**
+ @Function      FM_SetException
+
+ @Description   Calling this routine enables/disables the specified exception.
+
+ @Param[in]     h_Fm            A handle to an FM Module.
+ @Param[in]     exception       The exception to be selected.
+ @Param[in]     enable          TRUE to enable interrupt, FALSE to mask it.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Init().
+*//***************************************************************************/
+t_Error FM_SetException(t_Handle h_Fm, e_FmExceptions exception, bool enable);
+
+/**************************************************************************//**
+ @Function      FM_SetPortsBandwidth
+
+ @Description   Sets relative weights between ports when accessing common resources.
+
+ @Param[in]     h_Fm                A handle to an FM Module.
+ @Param[in]     p_PortsBandwidth    A table of ports bandwidth in percentage, i.e.
+                                    total must equal 100.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Init().
+*//***************************************************************************/
+t_Error FM_SetPortsBandwidth(t_Handle h_Fm, t_PortsParam *p_PortsBandwidth);
+
+/**************************************************************************//**
+ @Function      FM_EnableRamsEcc
+
+ @Description   Enables ECC mechanism for the different FM RAM's - IRAM, MURAM,
+                Parser, Keygen and Policer.
+                Note:
+                If FM_ConfigExternalEccRamsEnable was called to enable external
+                setting of ECC, this routine effects IRAM ECC only.
+                This routine is also called by the driver if an ECC exception is
+                enabled.
+
+ @Param[in]     h_Fm            A handle to an FM Module.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Config() and before FM_Init().
+*//***************************************************************************/
+t_Error FM_EnableRamsEcc(t_Handle h_Fm);
+
+/**************************************************************************//**
+ @Function      FM_DisableRamsEcc
+
+ @Description   Disables ECC mechanism for the different FM RAM's - IRAM, MURAM,
+                Parser, Keygen and Policer.
+                Note:
+                If FM_ConfigExternalEccRamsEnable was called to enable external
+                setting of ECC, this routine effects IRAM ECC only.
+                In opposed to FM_EnableRamsEcc, this routine must be called
+                explicitly to disable all Rams ECC.
+
+
+ @Param[in]     h_Fm            A handle to an FM Module.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Config() and before FM_Init().
+*//***************************************************************************/
+t_Error FM_DisableRamsEcc(t_Handle h_Fm);
+
+/**************************************************************************//**
+ @Function      FM_GetRevision
+
+ @Description   Returns the FM revision
+
+ @Param[in]     h_Fm                A handle to an FM Module.
+ @Param[out]    p_FmRevisionInfo    A structure of revision information parameters.
+
+ @Return        None.
+
+ @Cautions      Allowed only following FM_Init().
+*//***************************************************************************/
+void  FM_GetRevision(t_Handle h_Fm, t_FmRevisionInfo *p_FmRevisionInfo);
+
+/**************************************************************************//**
+ @Function      FM_GetCounter
+
+ @Description   Reads one of the FM counters.
+
+ @Param[in]     h_Fm        A handle to an FM Module.
+ @Param[in]     counter     The requested counter.
+
+ @Return        Counter's current value.
+
+ @Cautions      Allowed only following FM_Init().
+                Note that it is user's responsibilty to call this routine only
+                for enabled counters, and there will be no indication if a
+                disabled counter is accessed.
+*//***************************************************************************/
+uint32_t  FM_GetCounter(t_Handle h_Fm, e_FmCounters counter);
+
+/**************************************************************************//**
+ @Function      FM_SetCounter
+
+ @Description   Sets a value to an enabled counter. Use "0" to reset the counter.
+
+ @Param[in]     h_Fm        A handle to an FM Module.
+ @Param[in]     counter     The requested counter.
+ @Param[in]     val         The requested value to be written into the counter.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Init().
+*//***************************************************************************/
+t_Error  FM_SetCounter(t_Handle h_Fm, e_FmCounters counter, uint32_t val);
+
+/**************************************************************************//**
+ @Function      FM_Resume
+
+ @Description   Release FM after halt FM command or after unrecoverable ECC error.
+
+ @Param[in]     h_Fm        A handle to an FM Module.
+
+ @Return        E_OK on success; Error code otherwise.
+*//***************************************************************************/
+void FM_Resume(t_Handle h_Fm);
+
+/**************************************************************************//**
+ @Function      FM_GetTimeStamp
+
+ @Description   Reads the current time stamp
+
+ @Param[in]     h_Fm    A handle to an FM Module.
+
+ @Return        TimeStamp integer at calling time.
+
+ @Cautions      Allowed only following FM_Init().
+*//***************************************************************************/
+uint32_t FM_GetTimeStamp(t_Handle h_Fm);
+
+/**************************************************************************//**
+ @Function      FM_DmaEmergencyCtrl
+
+ @Description   Manual emergency set
+
+ @Param[in]     h_Fm        A handle to an FM Module.
+ @Param[in]     muramPort   MURAM direction select.
+ @Param[in]     enable      TRUE to manualy enable emergency, FALSE to disable.
+
+ @Return        None.
+
+ @Cautions      Allowed only following FM_Init().
+*//***************************************************************************/
+void FM_DmaEmergencyCtrl(t_Handle h_Fm, e_FmDmaMuramPort muramPort, bool enable);
+
+/**************************************************************************//**
+ @Function      FM_SetDmaExtBusPri
+
+ @Description   Manual emergency set
+
+ @Param[in]     h_Fm    A handle to an FM Module.
+ @Param[in]     pri     External bus priority select
+
+ @Return        None.
+
+ @Cautions      Allowed only following FM_Init().
+*//***************************************************************************/
+void FM_SetDmaExtBusPri(t_Handle h_Fm, e_FmDmaExtBusPri pri);
+
+/**************************************************************************//**
+ @Function      FM_ForceIntr
+
+ @Description   Causes an interrupt event on the requested source.
+
+ @Param[in]     h_Fm            A handle to an FM Module.
+ @Param[in]     exception       An exception to be forced.
+
+ @Return        E_OK on success; Error code if the exception is not enabled,
+                or is not able to create interrupt.
+
+ @Cautions      Allowed only following FM_Init().
+*//***************************************************************************/
+t_Error FM_ForceIntr (t_Handle h_Fm, e_FmExceptions exception);
+
+/**************************************************************************//**
+ @Function      FM_GetDmaStatus
+
+ @Description   Reads the DMA current status
+
+ @Param[in]     h_Fm                A handle to an FM Module.
+ @Param[out]     p_FmDmaStatus      A structure of DMA status parameters.
+
+ @Return        None
+
+ @Cautions      Allowed only following FM_Init().
+*//***************************************************************************/
+void FM_GetDmaStatus(t_Handle h_Fm, t_FmDmaStatus *p_FmDmaStatus);
+
+/**************************************************************************//**
+ @Function      FM_GetPcdHandle
+
+ @Description   Used by FMC in order to get PCD handle
+
+ @Param[in]     h_Fm     A handle to an FM Module.
+
+ @Return        A handle to the PCD module, NULL if uninitialized.
+
+ @Cautions      Allowed only following FM_Init().
+*//***************************************************************************/
+t_Handle FM_GetPcdHandle(t_Handle h_Fm);
+/** @} */ /* end of FM_runtime_control_grp group */
+
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+/**************************************************************************//**
+ @Function      FmDumpPortRegs
+
+ @Description   Dumps FM port registers which are part of FM common registers
+
+ @Param[in]     h_Fm            A handle to an FM Module.
+ @Param[in]     hardwarePortId    HW port id.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only FM_Init().
+*//***************************************************************************/
+t_Error FmDumpPortRegs(t_Handle h_Fm,uint8_t hardwarePortId);
+#endif /* (defined(DEBUG_ERRORS) && ... */
+
+/** @} */ /* end of FM_lib_grp group */
+/** @} */ /* end of FM_grp group */
+
+/*****************************************************/
+/*****************************************************/
+/****   Inter-module Routines and definitions     ****/
+/*****************************************************/
+/*****************************************************/
+#ifndef DOXYGEN_ONLY
+
+/**************************************************************************//**
+@Group         FM_InterModule_grp FM Inter-Module Unit
+
+ @Description   FM Inter Module functions -
+                These are not User API routines but routines that may be called
+                from other modules.
+                Routines used by PCD module are always called directly by the PCD
+                module, since the PCD and FM modules always run on the same core.
+                As for routines used by other modules (FM-Port), They will be called directly
+                in a single core environment. In a multicore environment, some of the
+                other modules may be run by other cores and therefor these routines
+                may not be called directly and will be internally invoked using the
+                XX messeging mechanism.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Collection   Defines used for enabling/disabling FM interrupts
+
+ @{
+*//***************************************************************************/
+
+typedef uint32_t t_FmBlockErrIntrEnable;
+
+#define ERR_INTR_EN_DMA         0x00010000      /**< TBD */
+#define ERR_INTR_EN_FPM         0x80000000      /**< TBD */
+#define ERR_INTR_EN_BMI         0x00800000      /**< TBD */
+#define ERR_INTR_EN_QMI         0x00400000      /**< TBD */
+#define ERR_INTR_EN_PRS         0x00200000      /**< TBD */
+#define ERR_INTR_EN_KG          0x00100000      /**< TBD */
+#define ERR_INTR_EN_PLCR        0x00080000      /**< TBD */
+#define ERR_INTR_EN_MURAM       0x00040000      /**< TBD */
+#define ERR_INTR_EN_IRAM        0x00020000      /**< TBD */
+#define ERR_INTR_EN_10G_MAC0    0x00008000      /**< TBD */
+#define ERR_INTR_EN_1G_MAC0     0x00004000      /**< TBD */
+#define ERR_INTR_EN_1G_MAC1     0x00002000      /**< TBD */
+#define ERR_INTR_EN_1G_MAC2     0x00001000      /**< TBD */
+#define ERR_INTR_EN_1G_MAC3     0x00000800      /**< TBD */
+
+typedef uint32_t t_FmBlockIntrEnable;           /**< TBD */
+
+#define INTR_EN_BMI             0x80000000      /**< TBD */
+#define INTR_EN_QMI             0x40000000      /**< TBD */
+#define INTR_EN_PRS             0x20000000      /**< TBD */
+#define INTR_EN_KG              0x10000000      /**< TBD */
+#define INTR_EN_PLCR            0x08000000      /**< TBD */
+#define INTR_EN_REV0            0x00008000      /**< TBD */
+#define INTR_EN_REV1            0x00004000      /**< TBD */
+#define INTR_EN_REV2            0x00002000      /**< TBD */
+#define INTR_EN_REV3            0x00001000      /**< TBD */
+#define INTR_EN_BRK             0x00000080      /**< TBD */
+#define INTR_EN_TMR             0x01000000      /**< TBD */
+#define INTR_EN_1G_MAC0_TMR     0x00080000      /**< TBD */
+#define INTR_EN_1G_MAC1_TMR     0x00040000      /**< TBD */
+#define INTR_EN_1G_MAC2_TMR     0x00020000      /**< TBD */
+#define INTR_EN_1G_MAC3_TMR     0x00010000      /**< TBD */
+#define INTR_EN_1G_MAC1         0x00400000      /**< TBD */
+#define INTR_EN_1G_MAC2         0x00200000      /**< TBD */
+#define INTR_EN_1G_MAC3         0x00100000      /**< TBD */
+
+/* @} */
+
+
+/**************************************************************************//**
+ @Description   Enum for inter-module interrupts registration
+*//***************************************************************************/
+typedef enum e_FmInterModuleEvent {
+    e_FM_EV_PRS,                    /**< Parser event */
+    e_FM_EV_ERR_PRS,                /**< Parser error event */
+    e_FM_EV_KG,                     /**< Keygen event */
+    e_FM_EV_ERR_KG,                 /**< Keygen error event */
+    e_FM_EV_PLCR,                   /**< Policer event */
+    e_FM_EV_ERR_PLCR,               /**< Policer error event */
+    e_FM_EV_ERR_10G_MAC0,           /**< 10G MAC 0 error event */
+    e_FM_EV_ERR_1G_MAC0,            /**< 1G MAC 0 error event */
+    e_FM_EV_ERR_1G_MAC1,            /**< 1G MAC 1 error event */
+    e_FM_EV_ERR_1G_MAC2,            /**< 1G MAC 2 error event */
+    e_FM_EV_ERR_1G_MAC3,            /**< 1G MAC 3 error event */
+    e_FM_EV_TMR,                    /**< Timer event */
+    e_FM_EV_1G_MAC1,                /**< 1G MAC 1 event */
+    e_FM_EV_1G_MAC2,                /**< 1G MAC 2 event */
+    e_FM_EV_1G_MAC3,                /**< 1G MAC 3 event */
+    e_FM_EV_1G_MAC0_TMR,            /**< 1G MAC 0 Timer event */
+    e_FM_EV_1G_MAC1_TMR,            /**< 1G MAC 1 Timer event */
+    e_FM_EV_1G_MAC2_TMR,            /**< 1G MAC 2 Timer event */
+    e_FM_EV_1G_MAC3_TMR,            /**< 1G MAC 3 Timer event */
+    e_FM_EV_DUMMY_LAST
+} e_FmInterModuleEvent;
+
+/**************************************************************************//**
+ @Description   enum for defining MAC types
+*//***************************************************************************/
+typedef enum e_FmMacType {
+    e_FM_MAC_10G,               /**< 10G MAC */
+    e_FM_MAC_1G                 /**< 1G MAC */
+} e_FmMacType;
+
+/**************************************************************************//**
+ @Description   Structure for port-FM communication during FM_PORT_Init.
+                Fields commented 'IN' are passed by the port module to be used
+                by the FM module.
+                Fields commented 'OUT' will be filled by FM before returning to port.
+                Some fields are optional (depending on configuration) and
+                will be analized by the port and FM modules accordingly.
+*//***************************************************************************/
+typedef struct t_FmInterModulePortInitParams {
+    uint8_t             hardwarePortId;       /**< IN. port Id */
+    e_FmPortType        portType;           /**< IN. Port type */
+    uint32_t            timeStampPeriod;    /**< OUT. Time stamp period in NanoSec */
+    bool                independentMode;    /**< IN. TRUE if FM Port operates in independent mode */
+    uint8_t             portPartition;      /**< IN. Port's requested resource */
+    uint8_t             numOfTasks;         /**< IN. Port's requested resource */
+    uint8_t             numOfExtraTasks;    /**< IN. Port's requested resource */
+    uint8_t             numOfOpenDmas;      /**< IN. Port's requested resource */
+    uint8_t             numOfExtraOpenDmas; /**< IN. Port's requested resource */
+    uint32_t            sizeOfFifo;         /**< IN. Port's requested resource */
+    uint32_t            extraSizeOfFifo;    /**< IN. Port's requested resource */
+    uint8_t             deqPipelineDepth;   /**< IN. Port's requested resource */
+    t_FmPhysAddr        fmMuramPhysBaseAddr;/**< OUT. FM-MURAM physical address*/
+} t_FmInterModulePortInitParams;
+
+/**************************************************************************//**
+ @Description   Structure for port-FM communication during FM_PORT_Free.
+*//***************************************************************************/
+typedef struct t_FmInterModulePortFreeParams {
+    uint8_t             hardwarePortId;     /**< IN. port Id */
+    e_FmPortType        portType;           /**< IN. Port type */
+    uint8_t             deqPipelineDepth;   /**< IN. Port's requested resource */
+} t_FmInterModulePortFreeParams;
+
+/**************************************************************************//**
+ @Function      FmRegisterIntr
+
+ @Description   Used to register an inter-module event handler to be processed by FM
+
+ @Param[in]     h_Fm            A handle to an FM Module.
+ @Param[in]     event           Event selector
+ @Param[in]     f_Isr           The interrupt service routine.
+ @Param[in]     h_Arg           Argument to be passed to f_Isr.
+
+ @Return        None.
+*//***************************************************************************/
+void FmRegisterIntr(t_Handle               h_Fm,
+                     e_FmInterModuleEvent   event,
+                     void                   (*f_Isr) (t_Handle h_Arg),
+                     t_Handle               h_Arg);
+
+/**************************************************************************//**
+ @Function      FmRegisterFmCtlIntr
+
+ @Description   Used to register to one of the fmCtl events in the FM module
+
+ @Param[in]     h_Fm            A handle to an FM Module.
+ @Param[in]     eventRegId      FmCtl event id (0-7).
+ @Param[in]     f_Isr           The interrupt service routine.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Init().
+*//***************************************************************************/
+void  FmRegisterFmCtlIntr(t_Handle h_Fm, uint8_t eventRegId, void (*f_Isr) (t_Handle h_Fm, uint32_t event));
+
+/**************************************************************************//**
+ @Function      FmGetPcdPrsBaseAddr
+
+ @Description   Get the base address of the Parser from the FM module
+
+ @Param[in]     h_Fm            A handle to an FM Module.
+
+ @Return        Base address.
+*//***************************************************************************/
+uint64_t FmGetPcdPrsBaseAddr(t_Handle h_Fm);
+
+/**************************************************************************//**
+ @Function      FmGetPcdKgBaseAddr
+
+ @Description   Get the base address of the Keygen from the FM module
+
+ @Param[in]     h_Fm            A handle to an FM Module.
+
+ @Return        Base address.
+*//***************************************************************************/
+uint64_t FmGetPcdKgBaseAddr(t_Handle h_Fm);
+
+/**************************************************************************//**
+ @Function      FmGetPcdPlcrBaseAddr
+
+ @Description   Get the base address of the Policer from the FM module
+
+ @Param[in]     h_Fm            A handle to an FM Module.
+
+ @Return        Base address.
+*//***************************************************************************/
+uint64_t FmGetPcdPlcrBaseAddr(t_Handle h_Fm);
+
+/**************************************************************************//**
+ @Function      FmGetMuramHandle
+
+ @Description   Get the handle of the MURAM from the FM module
+
+ @Param[in]     h_Fm            A handle to an FM Module.
+
+ @Return        MURAM module handle.
+*//***************************************************************************/
+t_Handle FmGetMuramHandle(t_Handle h_Fm);
+
+/**************************************************************************//**
+ @Function      FmGetPhysicalMuramBase
+
+ @Description   Get the physical base address of the MURAM from the FM module
+
+ @Param[in]     h_Fm            A handle to an FM Module.
+ @Param[in]     fmPhysAddr      Physical MURAM base
+
+ @Return        Physical base address.
+*//***************************************************************************/
+t_Error FmGetPhysicalMuramBase(t_Handle h_Fm, t_FmPhysAddr *fmPhysAddr);
+
+/**************************************************************************//**
+ @Function      FmGetTimeStampPeriod
+
+ @Description   Used internally by other modules in order to get the timeStamp
+                period as requested by the application.
+
+ @Param[in]     h_Fm                    A handle to an FM Module.
+
+ @Return        TimeStamp period in nanoseconds.
+
+ @Cautions      Allowed only following FM_Init().
+*//***************************************************************************/
+uint32_t    FmGetTimeStampPeriod(t_Handle h_Fm);
+
+/**************************************************************************//**
+ @Function      FmResumeStalledPort
+
+ @Description   Used internally by FM port to release a stalled port.
+
+ @Param[in]     h_Fm                            A handle to an FM Module.
+ @Param[in]     hardwarePortId                    HW port id.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Init().
+*//***************************************************************************/
+t_Error FmResumeStalledPort(t_Handle h_Fm, uint8_t hardwarePortId);
+
+/**************************************************************************//**
+ @Function      FmIsPortStalled
+
+ @Description   Used internally by FM port to read the port's status.
+
+ @Param[in]     h_Fm                            A handle to an FM Module.
+ @Param[in]     hardwarePortId                    HW port id.
+
+ @Return        TRUE if port is stalled, FALSE otherwize
+
+ @Cautions      Allowed only following FM_Init().
+*//***************************************************************************/
+bool FmIsPortStalled(t_Handle h_Fm, uint8_t hardwarePortId);
+
+/**************************************************************************//**
+ @Function      FmResetMac
+
+ @Description   Used by MAC driver to reset the MAC registers
+
+ @Param[in]     h_Fm            A handle to an FM Module.
+ @Param[in]     type            MAC type.
+ @Param[in]     macId           MAC id - according to type.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Init().
+*//***************************************************************************/
+t_Error FmResetMac(t_Handle h_Fm, e_FmMacType type, uint8_t macId);
+
+/**************************************************************************//**
+ @Function      FmGetId
+
+ @Description   Used by PCD driver to read rhe FM id
+
+ @Param[in]     h_Fm            A handle to an FM Module.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Init().
+*//***************************************************************************/
+uint8_t FmGetId(t_Handle h_Fm);
+
+/**************************************************************************//**
+ @Function      FmGetSetPortParams
+
+ @Description   Used by FM-PORT driver to pass and receive parameters between
+                PORT and FM modules.
+
+ @Param[in]     h_Fm            A handle to an FM Module.
+ @Param[in,out] p_PortParams    A structure of FM Port parameters.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Init().
+*//***************************************************************************/
+t_Error FmGetSetPortParams(t_Handle h_Fm,t_FmInterModulePortInitParams *p_PortParams);
+
+/**************************************************************************//**
+ @Function      FmFreePortParams
+
+ @Description   Used by FM-PORT driver to free port's resources within the FM.
+
+ @Param[in]     h_Fm            A handle to an FM Module.
+ @Param[in,out] p_PortParams    A structure of FM Port parameters.
+
+ @Return        None.
+
+ @Cautions      Allowed only following FM_Init().
+*//***************************************************************************/
+void FmFreePortParams(t_Handle h_Fm,t_FmInterModulePortFreeParams *p_PortParams);
+
+#if (defined(CONFIG_MULTI_PARTITION_SUPPORT) && !defined(CONFIG_GUEST_PARTITION))
+t_Error     FmHandleIpcMsg(t_Handle h_Fm, uint32_t msgId, uint8_t msgBody[MSG_BODY_SIZE]);
+#endif /* (defined(CONFIG_MULTI_PARTITION_SUPPORT) && ... */
+void        FmRegisterPcd(t_Handle h_Fm, t_Handle h_FmPcd);
+t_Handle    FmGetPcdHandle(t_Handle h_Fm);
+bool        FmRamsEccIsExternalCtl(t_Handle h_Fm);
+
+
+/** @} */ /* end of FM_lib_grp group */
+
+#endif /* ! DOXYGEN_ONLY */
+
+#endif /* __FM_EXT */
diff --git a/drivers/net/dpa/NetCommSw/inc/Peripherals/fm_mac_ext.h b/drivers/net/dpa/NetCommSw/inc/Peripherals/fm_mac_ext.h
new file mode 100644
index 0000000..a034268
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/inc/Peripherals/fm_mac_ext.h
@@ -0,0 +1,617 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**************************************************************************//**
+ @File          fm_mac_ext.h
+
+ @Description   FM MAC ...
+*//***************************************************************************/
+#ifndef __FM_MAC_EXT_H
+#define __FM_MAC_EXT_H
+
+#include "std_ext.h"
+#include "enet_ext.h"
+
+
+/**************************************************************************//**
+ @Group         FM_grp Frame Manager API
+
+ @Description   FM API functions, definitions and enums
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Group         FM_mac_grp FM MAC
+
+ @Description   FM MAC API functions, definitions and enums
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description   interrupt setup option
+*//***************************************************************************/
+typedef enum e_FmMacIntOption {
+    e_FM_MAC_INT_NONE,                      /**<   Disable all Interrupts */
+    e_FM_MAC_INT_DFLT,                      /**<   Enable Default Interrupts */
+    e_FM_MAC_INT_ALL                        /**<   Enable all Interrupts */
+} e_FmMacIntOption;
+
+/**************************************************************************//**
+ @Description   interrupt Exceptions
+*//***************************************************************************/
+typedef enum e_FmMacExceptions {
+    e_FM_MAC_INT_FATAL,                     /**<   Enable all Interrupts */
+    e_FM_MAC_INT_RECOVER,                   /**<   Enable Default Interrupts */
+    e_FM_MAC_INT_MINOR                      /**<   Disable all Interrupts */
+} e_FmMacExceptions;
+
+
+/**************************************************************************//**
+ @Function      t_FmMacExceptionCallback
+
+ @Description   Fm Mac Exception Callback from FM MAC to the user
+
+ @Param[in]     h_App             - Handle to the upper layer handler
+
+ @Param[in]     exceptions        - Exceptions clasification
+
+ @Param[in]     events            - bitwise denition of the exact mac event register
+
+ @Return        void.
+*//***************************************************************************/
+typedef void (t_FmMacExceptionCallback)(t_Handle h_App, e_FmMacExceptions exceptions, uint32_t events);
+
+
+/**************************************************************************//**
+ @Description   TM MAC statistics rfc3635
+*//***************************************************************************/
+typedef struct t_FmMacStatistics {
+/* RMON */
+    uint64_t  eStatPkts64;             /**< r-10G tr-DT 64 byte frame counter */
+    uint64_t  eStatPkts65to127;        /**< r-10G 65 to 127 byte frame counter */
+    uint64_t  eStatPkts128to255;       /**< r-10G 128 to 255 byte frame counter */
+    uint64_t  eStatPkts256to511;       /**< r-10G 256 to 511 byte frame counter */
+    uint64_t  eStatPkts512to1023;      /**< r-10G 512 to 1023 byte frame counter */
+    uint64_t  eStatPkts1024to1518;     /**< r-10G 1024 to 1518 byte frame counter */
+    uint64_t  eStatPkts1519to1522;     /**< r-10G 1519 to 1522 byte good frame count */
+/* */
+    uint64_t  eStatFragments;          /**< Total number of packets that were less than 64 octets long with a wrong CRC.*/
+    uint64_t  eStatJabbers;            /**< Total number of packets longer than valid maximum length octets */
+    uint64_t  eStatsDropEvents;        /**< number of dropped packets due to internal errors of the MAC Client. */
+    uint64_t  eStatCRCAlignErrors;     /**< Incremented when frames of correct length but with CRC error are received.*/
+    uint64_t  eStatUndersizePkts;      /**< Total number of packets that were less than 64 octets long with a good CRC.*/
+    uint64_t  eStatOversizePkts;       /**< T,B.D*/
+/* Pause */
+    uint64_t  teStatPause;             /**< Pause MAC Control received */
+    uint64_t  reStatPause;             /**< Pause MAC Control sent */
+
+/* MIB II */
+    uint64_t  ifInOctets;               /**< Total number of byte received. */
+    uint64_t  ifInPkts;                 /**< Total number of packets received.*/
+    uint64_t  ifInMcastPkts;            /**< Total number of multicast frame received*/
+    uint64_t  ifInBcastPkts;            /**< Total number of broadcast frame received */
+    uint64_t  ifInDiscards;             /**< Frames received, but discarded due to problems within the MAC RX. */
+    uint64_t  ifInErrors;               /**< Number of frames received with error:
+                                                 FIFO Overflow Error
+                                                 CRC Error
+                                                 Frame Too Long Error
+                                                 Alignment Error
+                                                 The dedicated Error Code (0xfe, not a code error) was received */
+    uint64_t  ifOutOctets;              /**< Total number of byte sent. */
+    uint64_t  ifOutPkts;                /**< Total number of packets sent .*/
+    uint64_t  ifOutMcastPkts;           /**< Total number of multicast frame sent */
+    uint64_t  ifOutBcastPkts;           /**< Total number of multicast frame sent */
+    uint64_t  ifOutDiscards;            /**< Frames received, but discarded due to problems within the MAC TX N/A!.*/
+    uint64_t  ifOutErrors;              /**< Number of frames transmitted with error:
+                                                 FIFO Overflow Error
+                                                 FIFO Underflow Error
+                                                 Other*/
+} t_FmMacStatistics;
+
+
+/**************************************************************************//**
+ @Group         FM_mac_init_grp Initialization Unit
+
+ @Description   FM MAC Initialization Unit
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description   FM MAC config input
+*//***************************************************************************/
+typedef struct t_FmMacParams {
+    uint64_t                    baseAddr;           /**< Base of memory mapped FM MAC registers */
+    uint8_t                     macId;              /**< MAC ID <dTSEC 0-3> <10G 0>         */
+    t_EnetAddr                  addr;               /**< MAC address of device; First octet is sent first */
+    e_EnetMode                  enetMode;           /**< Ethernet operation mode (MAC-PHY interface and speed) */
+    t_FmMacExceptionCallback    *f_Exceptions;      /**< Exception Callback Routine         */
+    t_Handle                    h_App;              /**< A handle to an application layer object; This handle will
+                                                         be passed by the driver upon calling the above callbacks */
+    t_Handle                    h_Fm;               /**< A handle to the FM object this port related to */
+} t_FmMacParams;
+
+
+/**************************************************************************//**
+ @Function      FM_MAC_Config
+
+ @Description   Creates descriptor for the FM MAC module.
+
+                The routine returns a handle (descriptor) to the FM MAC object.
+                This descriptor must be passed as first parameter to all other
+                FM MAC function calls.
+
+                No actual initialization or configuration of FM MAC hardware is
+                done by this routine.
+
+ @Param[in]     p_FmMacParam   - Pointer to data structure of parameters
+
+ @Retval        Handle to FM MAC object, or NULL for Failure.
+*//***************************************************************************/
+t_Handle FM_MAC_Config (t_FmMacParams *p_FmMacParam);
+
+/**************************************************************************//**
+ @Function      FM_MAC_Init
+
+ @Description   Initializes the FM MAC module
+
+ @Param[in]     h_FmMac - FM module descriptor
+
+ @Return        E_OK on success; Error code otherwise.
+*//***************************************************************************/
+t_Error  FM_MAC_Init (t_Handle h_FmMac);
+
+/**************************************************************************//**
+ @Function      FM_Free
+
+ @Description   Frees all resources that were assigned to FM MAC module.
+
+                Calling this routine invalidates the descriptor.
+
+ @Param[in]     h_FmMac - FM module descriptor
+
+ @Return        E_OK on success; Error code otherwise.
+*//***************************************************************************/
+t_Error  FM_MAC_Free (t_Handle h_FmMac);
+
+
+/**************************************************************************//**
+ @Group         FM_mac_advanced_init_grp    Advanced Configuration Unit
+
+ @Description   Configuration functions used to change default values.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Function      FM_MAC_ConfigStatistics
+
+ @Description   Enable/Disable RMON statistics
+
+ @Param[in]     h_FmMac    A handle to a FM MAC Module.
+ @Param[in]     enable     TRUE to enable or FALSE to disable.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MAC_Config() and before FM_MAC_Init().
+*//***************************************************************************/
+t_Error FM_MAC_ConfigStatistics (t_Handle h_FmMac, bool enable);
+
+/**************************************************************************//**
+ @Function      FM_MAC_ConfigLoopback
+
+ @Description   Enable/Disable internal loopback mode
+
+ @Param[in]     h_FmMac    A handle to a FM MAC Module.
+ @Param[in]     enable     TRUE to enable or FALSE to disable.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MAC_Config() and before FM_MAC_Init().
+*//***************************************************************************/
+t_Error FM_MAC_ConfigLoopback (t_Handle h_FmMac, bool enable);
+
+/**************************************************************************//**
+ @Function      FM_MAC_ConfigMaxFrameLength
+
+ @Description   Setup maximum Farme Length
+
+ @Param[in]     h_FmMac    A handle to a FM MAC Module.
+ @Param[in]     newVal     MAX Frame length
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MAC_Config() and before FM_MAC_Init().
+*//***************************************************************************/
+t_Error FM_MAC_ConfigMaxFrameLength (t_Handle h_FmMac, uint16_t newVal);
+
+/**************************************************************************//**
+ @Function      FM_MAC_ConfigWan
+
+ @Description   ENABLE WAN mode in 10G MAC
+
+ @Param[in]     h_FmMac    A handle to a FM MAC Module.
+ @Param[in]     enable     TRUE to enable or FALSE to disable.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MAC_Config() and before FM_MAC_Init().
+*//***************************************************************************/
+t_Error FM_MAC_ConfigWan (t_Handle h_FmMac, bool enable);
+
+/**************************************************************************//**
+ @Function      FM_MAC_ConfigPadAndCrc
+
+ @Description   Config PAD and CRC mode
+
+ @Param[in]     h_FmMac    A handle to a FM MAC Module.
+ @Param[in]     enable     TRUE to enable or FALSE to disable.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MAC_Config() and before FM_MAC_Init().
+*//***************************************************************************/
+t_Error FM_MAC_ConfigPadAndCrc (t_Handle h_FmMac, bool enable);
+
+/**************************************************************************//**
+ @Function      FM_MAC_ConfigHalfDuplex
+
+ @Description   Config Half Duplex Mode
+
+ @Param[in]     h_FmMac    A handle to a FM MAC Module.
+ @Param[in]     enable     TRUE to enable or FALSE to disable.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MAC_Config() and before FM_MAC_Init().
+*//***************************************************************************/
+t_Error FM_MAC_ConfigHalfDuplex (t_Handle h_FmMac, bool enable);
+
+/**************************************************************************//**
+ @Function      FM_MAC_ConfigHugeFrames
+
+ @Description   Enable Huge Frame mode
+
+ @Param[in]     h_FmMac    A handle to a FM MAC Module.
+ @Param[in]     enable     TRUE to enable or FALSE to disable.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MAC_Config() and before FM_MAC_Init().
+*//***************************************************************************/
+t_Error FM_MAC_ConfigHugeFrames (t_Handle h_FmMac, bool enable);
+/** @} */ /* end of FM_mac_advanced_init_grp group */
+/** @} */ /* end of FM_mac_init_grp group */
+
+
+/**************************************************************************//**
+ @Group         FM_mac_runtime_control_grp Runtime Control Unit
+
+ @Description   FM MAC Runtime control unit API functions, definitions and enums.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Function      FM_MAC_Enable
+
+ @Description   Enable the MAC
+
+ @Param[in]     h_FmMac    A handle to a FM MAC Module.
+ @Param[in]     mode       Mode of operation (RX, TX, Both)
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MAC_Init().
+*//***************************************************************************/
+t_Error FM_MAC_Enable  (t_Handle h_FmMac,  e_CommMode mode);
+
+/**************************************************************************//**
+ @Function      FM_MAC_Disable
+
+ @Description   DISABLE the MAC
+
+ @Param[in]     h_FmMac    A handle to a FM MAC Module.
+ @Param[in]     mode       Define what part to Disable (RX,  TX or BOTH)
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MAC_Init().
+*//***************************************************************************/
+t_Error FM_MAC_Disable (t_Handle h_FmMac, e_CommMode mode);
+
+/**************************************************************************//**
+ @Function      FM_MAC_Restart
+
+ @Description   Restart Rx and Tx on FM-MAC controller
+
+ @Param[in]     h_FmMac    A handle to a FM MAC Module.
+ @Param[in]     mode       Restart the MAC to this mode
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MAC_Disable().
+*//***************************************************************************/
+t_Error FM_MAC_Restart (t_Handle h_FmMac, e_CommMode mode);
+
+/**************************************************************************//**
+ @Function      FM_MAC_Reset
+
+ @Description   Reset FM-MAC controller. The controller will be back to default setup.
+
+ @Param[in]     h_FmMac    A handle to a FM MAC Module.
+ @Param[in]     wait       Reset the MAC to this mode
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MAC_Disable(). After this routine is
+                being called, the only operation allowed is FM_MAC_Free().
+*//***************************************************************************/
+t_Error FM_MAC_Reset (t_Handle h_FmMac, bool wait);
+
+/**************************************************************************//**
+ @Function      FM_MAC_TxMacPause
+
+ @Description   Enable transmition of  Pause frame
+
+ @Param[in]     h_FmMac     A handle to a FM MAC Module.
+ @Param[in]     pauseTime   Define pause time
+ @Param[in]     exPauseTime define Extended pause time (not on 10G)
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MAC_Init().
+*//***************************************************************************/
+t_Error FM_MAC_TxMacPause (t_Handle h_FmMac, uint16_t pauseTime, uint16_t exPauseTime);
+
+/**************************************************************************//**
+ @Function      FM_MAC_ResetCounters
+
+ @Description   reset all statistics counters
+
+ @Param[in]     h_FmMac     A handle to a FM MAC Module.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MAC_Init().
+*//***************************************************************************/
+t_Error FM_MAC_ResetCounters (t_Handle h_FmMac);
+
+/**************************************************************************//**
+ @Function      FM_MAC_SetExceptions
+
+ @Description   Setup Excption Handler
+
+ @Param[in]     h_FmMac         A handle to a FM MAC Module.
+ @Param[in]     ex              Type of the desired excpetions
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MAC_Init().
+*//***************************************************************************/
+t_Error FM_MAC_SetExceptions(t_Handle h_FmMac, e_FmMacExceptions ex);
+
+/**************************************************************************//**
+ @Function      FM_MAC_GetStatistics
+
+ @Description   get all statistics counters
+
+ @Param[in]     h_FmMac         A handle to a FM MAC Module.
+ @Param[in]     p_Statistics    Staructure with statistics
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Init().
+*//***************************************************************************/
+t_Error FM_MAC_GetStatistics (t_Handle h_FmMac, t_FmMacStatistics *p_Statistics);
+
+/**************************************************************************//**
+ @Function      FM_MAC_ModifyMacAddr
+
+ @Description   Replace the main MAC Address
+
+ @Param[in]     h_FmMac     -   A handle to a FM Module.
+ @Param[in]     p_EnetAddr  -   Ethernet Mac address
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only after FM_MAC_Init().
+*//***************************************************************************/
+t_Error FM_MAC_ModifyMacAddr (t_Handle h_FmMac, t_EnetAddr *p_EnetAddr);
+
+/**************************************************************************//**
+ @Function      FM_MAC_AddHashMacAddr
+
+ @Description   Add an Address to the hash table. This is for filter purpose only.
+
+ @Param[in]     h_FmMac     -   A handle to a FM Module.
+ @Param[in]     p_EnetAddr  -   Ethernet Mac address
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MAC_Init(). It is a filter only address.
+ @Cautions      Some address need to be filterd out in upper FM blocks.
+*//***************************************************************************/
+t_Error FM_MAC_AddHashMacAddr (t_Handle h_FmMac, t_EnetAddr *p_EnetAddr);
+
+/**************************************************************************//**
+ @Function      FM_MAC_RemoveHashMacAddr
+
+ @Description   Delete an Address to the hash table. This is for filter purpose only.
+
+ @Param[in]     h_FmMac     -   A handle to a FM Module.
+ @Param[in]     p_EnetAddr  -   Ethernet Mac address
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MAC_Init().
+*//***************************************************************************/
+t_Error FM_MAC_RemoveHashMacAddr (t_Handle h_FmMac, t_EnetAddr *p_EnetAddr);
+
+/**************************************************************************//**
+ @Function      FM_MAC_AddExactMatchMacAddr
+
+ @Description   Add a unicast or multicast mac address (8 on dTSEC 1 on 10G).
+
+ @Param[in]     h_FmMac     -   A handle to a FM Module.
+ @Param[in]     p_EnetAddr  -   MAC Address to ADD
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only after FM_MAC_Init().
+*//***************************************************************************/
+t_Error FM_MAC_AddExactMatchMacAddr (t_Handle h_FmMac, t_EnetAddr *p_EnetAddr);
+
+/**************************************************************************//**
+ @Function      FM_MAC_RemovelExactMatchMacAddr
+
+ @Description   Remove a uni cast or multi cast mac address
+
+ @Param[in]     h_FmMac     -   A handle to a FM Module.
+ @Param[in]     p_EnetAddr  -   MAC Address to remove
+
+ @Return        E_OK on success; Error code otherwise..
+
+ @Cautions      Allowed only after FM_MAC_Init().
+*//***************************************************************************/
+t_Error FM_MAC_RemovelExactMatchMacAddr (t_Handle h_FmMac, t_EnetAddr *p_EnetAddr);
+
+/**************************************************************************//**
+ @Function      FM_MAC_SetPromiscuous
+
+ @Description   Enable/Disable MAC Promiscuous mode for ALL mac addresses.
+
+ @Param[in]     h_FmMac    - A handle to a FM MAC Module.
+ @Param[in]     enable     - TRUE to enable or FALSE to disable.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only after FM_MAC_Init().
+*//***************************************************************************/
+t_Error FM_MAC_SetPromiscuous (t_Handle h_FmMac, bool enable);
+/**************************************************************************//**
+ @Function      FM_MAC_AdjustLink
+
+ @Description   Adjusts the Ethernet link with new speed/duplex setup.
+
+ @Param[in]     h_FmMac     - A handle to a FM Module.
+ @Param[in]     speed       - Ethernet speed.
+ @Param[in]     fullDuplex  - TRUE for Full-Duplex mode;
+                              FALSE for Half-Duplex mode.
+
+ @Return        E_OK on success; Error code otherwise.
+*//***************************************************************************/
+t_Error FM_MAC_AdjustLink(t_Handle h_FmMac, e_EnetSpeed speed, bool fullDuplex);
+
+/**************************************************************************//**
+ @Function      FM_MAC_GetId
+
+ @Description   Return the MAC ID
+
+ @Param[in]     h_FmMac     -   A handle to a FM Module.
+ @Param[out]    p_MacId     -   MAC ID of device
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only after FM_MAC_Init().
+*//***************************************************************************/
+t_Error FM_MAC_GetId (t_Handle h_FmMac, uint32_t *p_MacId);
+
+/**************************************************************************//**
+ @Function      FM_MAC_GetVesrion
+
+ @Description   Return Mac HW chip version
+
+ @Param[in]     h_FmMac      -   A handle to a FM Module.
+ @Param[out]    p_MacVresion -   Mac version as defined by the chip
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only after FM_MAC_Init().
+*//***************************************************************************/
+t_Error FM_MAC_GetVesrion (t_Handle h_FmMac, uint32_t *p_MacVresion);
+
+/**************************************************************************//**
+ @Function      FM_MAC_MII_WritePhyReg
+
+ @Description   Write data into Phy Register
+
+ @Param[in]     h_FmMac     -   A handle to a FM Module.
+ @Param[in]     phyAddr     -   Phy Address on the MII bus
+ @Param[in]     reg         -   Register Number.
+ @Param[in]     data        -   Data to write.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only after FM_MAC_Init().
+*//***************************************************************************/
+t_Error FM_MAC_MII_WritePhyReg (t_Handle h_FmMac, uint8_t phyAddr, uint8_t reg, uint16_t data);
+
+/**************************************************************************//**
+ @Function      FM_MAC_MII_ReadPhyReg
+
+ @Description   Read data from Phy Register
+
+ @Param[in]     h_FmMac     -   A handle to a FM Module.
+ @Param[in]     phyAddr     -   Phy Address on the MII bus
+ @Param[in]     reg         -   Register Number.
+ @Param[out]    p_Data      -   Data from PHY.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only after FM_MAC_Init().
+*//***************************************************************************/
+t_Error FM_MAC_MII_ReadPhyReg(t_Handle h_FmMac,  uint8_t phyAddr, uint8_t reg, uint16_t *p_Data);
+
+#if (DEBUG_ERRORS > 0)
+/**************************************************************************//**
+ @Function      FM_MAC_DumpRegs
+
+ @Description   Dump internal registers
+
+ @Param[in]     h_FmMac     -   A handle to a FM Module.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only after FM_MAC_Init().
+*//***************************************************************************/
+t_Error FM_MAC_DumpRegs(t_Handle h_FmMac);
+#endif /* (DEBUG_ERRORS > 0) */
+
+/** @} */ /* end of FM_mac_runtime_control_grp group */
+/** @} */ /* end of FM_mac_grp group */
+/** @} */ /* end of FM_grp group */
+
+
+#endif /* __FM_MAC_EXT_H */
diff --git a/drivers/net/dpa/NetCommSw/inc/Peripherals/fm_muram_ext.h b/drivers/net/dpa/NetCommSw/inc/Peripherals/fm_muram_ext.h
new file mode 100644
index 0000000..47cc754
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/inc/Peripherals/fm_muram_ext.h
@@ -0,0 +1,142 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**************************************************************************//**
+ @File          FM_muram_ext.h
+
+ @Description   FM MURAM Application Programming Interface.
+*//***************************************************************************/
+#ifndef __FM_MURAM_EXT
+#define __FM_MURAM_EXT
+
+#include "error_ext.h"
+#include "std_ext.h"
+
+
+/**************************************************************************//**
+ @Group         FM_grp Frame Manager API
+
+ @Description   FM API functions, definitions and enums
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Group         FM_muram_grp FM MURAM
+
+ @Description   FM MURAM API functions, definitions and enums
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Group         FM_muram_init_grp FM MURAM Initialization
+
+ @Description   FM MURAM initialization API functions, definitions and enums
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Function      FM_MURAM_ConfigAndInit
+
+ @Description   Creates partition in the MURAM.
+
+                The routine returns a handle (descriptor) to the MURAM partition.
+                This descriptor must be passed as first parameter to all other
+                FM-MURAM function calls.
+
+                No actual initialization or configuration of FM_MURAM hardware is
+                done by this routine.
+
+ @Param[in]     baseAddress - Pointer to base of memory mapped FM-MURAM.
+ @Param[in]     size        - Size of the FM-MURAM partition.
+
+ @Return        Handle to FM-MURAM object, or NULL for Failure.
+*//***************************************************************************/
+t_Handle FM_MURAM_ConfigAndInit(uint64_t baseAddress, uint32_t size);
+
+/**************************************************************************//**
+ @Function      FM_MURAM_Free
+
+ @Description   Frees all resources that were assigned to FM-MURAM module.
+
+                Calling this routine invalidates the descriptor.
+
+ @Param[in]     h_FmMuram - FM-MURAM module descriptor.
+
+ @Return        E_OK on success; Error code otherwise.
+*//***************************************************************************/
+t_Error  FM_MURAM_Free(t_Handle h_FmMuram);
+
+/** @} */ /* end of FM_muram_init_grp group */
+
+
+/**************************************************************************//**
+ @Group         FM_muram_ctrl_grp FM MURAM Control
+
+ @Description   FM MURAM control API functions, definitions and enums
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Function      FM_MURAM_AllocMem
+
+ @Description   Allocate some memory from FM-MURAM partition.
+
+ @Param[in]     h_FmMuram - FM-MURAM module descriptor.
+ @Param[in]     size      - size of the memory to be allocated.
+ @Param[in]     align     - Alignment of the memory.
+
+ @Return        address of the allocated memory; NULL otherwise.
+*//***************************************************************************/
+void  * FM_MURAM_AllocMem(t_Handle h_FmMuram, uint32_t size, uint32_t align);
+
+/**************************************************************************//**
+ @Function      FM_MURAM_FreeMem
+
+ @Description   Free an allocated memory from FM-MURAM partition.
+
+ @Param[in]     h_FmMuram - FM-MURAM module descriptor.
+ @Param[in]     ptr       - A pointer to an allocated memory.
+
+ @Return        E_OK on success; Error code otherwise.
+*//***************************************************************************/
+t_Error FM_MURAM_FreeMem(t_Handle h_FmMuram, void *ptr);
+
+/** @} */ /* end of FM_muram_ctrl_grp group */
+/** @} */ /* end of FM_muram_grp group */
+/** @} */ /* end of FM_grp group */
+
+
+#endif /* __FM_MURAM_EXT */
diff --git a/drivers/net/dpa/NetCommSw/inc/Peripherals/fm_pcd_ext.h b/drivers/net/dpa/NetCommSw/inc/Peripherals/fm_pcd_ext.h
new file mode 100644
index 0000000..dcd4607
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/inc/Peripherals/fm_pcd_ext.h
@@ -0,0 +1,1889 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**************************************************************************//**
+ @File          fm_pcd_ext.h
+
+ @Description   FM PCD ...
+*//***************************************************************************/
+#ifndef __FM_PCD_EXT
+#define __FM_PCD_EXT
+
+#include "std_ext.h"
+#include "net_ext.h"
+#include "fm_ext.h"
+#include "list_ext.h"
+
+
+/**************************************************************************//**
+ @Group         FM_grp Frame Manager API
+
+ @Description   FM API functions, definitions and enums
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Group         FM_PCD_grp FM PCD
+
+ @Description   FM PCD API functions, definitions and enums
+
+                The FM PCD module is responsible for the initialization of all
+                global classifying FM modules. This includes the parser general and
+                common registers, the key generator global and common registers,
+                and the Policer global and common registers.
+                In addition, the FM PCD SW module will initialize all required
+                key generator schemes, coarse classification flows, and Policer
+                profiles. When An FM module is configured to work with one of these
+                entities, it will register to it using the FM PORT API. The PCD
+                module will manage the PCD resources - i.e. resource management of
+                Keygen schemes, etc.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Collection    General PCD defines
+*//***************************************************************************/
+typedef uint32_t fmPcdEngines_t; /**< options as defined below: */
+
+#define FM_PCD_NONE                                 0                   /**< No PCD Engine indicated */
+#define FM_PCD_PRS                                  0x80000000          /**< Parser indicated */
+#define FM_PCD_KG                                   0x40000000          /**< Keygen indicated */
+#define FM_PCD_CC                                   0x20000000          /**< Coarse classification indicated */
+#define FM_PCD_PLCR                                 0x10000000          /**< Policer indicated */
+
+#define FM_PCD_MAX_NUM_OF_PRIVATE_HDRS              3                   /**< Number of units/headers saved for user */
+
+#define FM_PCD_PRS_NUM_OF_HDRS                      16                  /**< Number of headers supported by HW parser */
+#define FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS         (32 - FM_PCD_MAX_NUM_OF_PRIVATE_HDRS)
+                                                                        /**< Maximum number of netenv distinction units */
+#define MAX_NUM_OF_OPTIONS                          8                   /**< Maximum number of netenv distinction units options */
+#define FM_PCD_MAX_NUM_OF_INTERCHANGABLE_HDRS       4                   /**< Maximum number of interchangable headers in a distinction unit */
+#define FM_PCD_KG_NUM_OF_GENERIC_REGS               8                   /**< Total number of generic KG registers */
+#define FM_PCD_KG_MAX_NUM_OF_EXTRACTS_PER_KEY       35                  /**< Max number allowed on any configuration.
+                                                                             For reason of HW implemetation, in most
+                                                                             cases less than this will be allowed. The
+                                                                             driver will return error in initialization
+                                                                             time if resource is overused. */
+#define FM_PCD_KG_NUM_OF_EXTRACT_MASKS              4                   /**< Total number of masks allowed on KG extractions. */
+#define FM_PCD_KG_NUM_OF_DEFAULT_GROUPS             16                  /**< Number of default value logical groups */
+
+#define FM_PCD_PRS_NUM_OF_LABELS                    32                  /**< Max number of SW parser label */
+#define FM_SW_PRS_SIZE                              0x00000800          /**< Total size of sw parser area */
+#define PRS_SW_OFFSET                               0x00000040          /**< Size of illegal addresses at the beginning
+                                                                             of the SW parser area */
+#define PRS_SW_TAIL_SIZE                            4                   /**< Number of bytes that must be cleared at
+                                                                             the end of the SW parser area */
+#define FM_SW_PRS_MAX_IMAGE_SIZE                    (FM_SW_PRS_SIZE-PRS_SW_OFFSET-PRS_SW_TAIL_SIZE)
+                                                                        /**< Max possible size of SW parser code */
+/* @} */
+
+/**************************************************************************//**
+ @Group         FM_PCD_init_grp FM PCD Initialization Unit
+
+ @Description   FM PCD Initialization Unit
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description   PCD counters
+*//***************************************************************************/
+typedef enum e_FmPcdCounters {
+    e_FM_PCD_KG_COUNTERS_TOTAL,                                 /**< Policer counter */
+    e_FM_PCD_PLCR_COUNTERS_YELLOW,                              /**< Policer counter */
+    e_FM_PCD_PLCR_COUNTERS_RED,                                 /**< Policer counter */
+    e_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_RED,                    /**< Policer counter */
+    e_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_YELLOW,                 /**< Policer counter */
+    e_FM_PCD_PLCR_COUNTERS_TOTAL,                               /**< Policer counter */
+    e_FM_PCD_PLCR_COUNTERS_LENGTH_MISMATCH,                     /**< Policer counter */
+    e_FM_PCD_PRS_COUNTERS_PARSE_DISPATCH,                       /**< Parser counter */
+    e_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED,             /**< Parser counter */
+    e_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED,             /**< Parser counter */
+    e_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED,             /**< Parser counter */
+    e_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED,           /**< Parser counter */
+    e_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED_WITH_ERR,    /**< Parser counter */
+    e_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED_WITH_ERR,    /**< Parser counter */
+    e_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED_WITH_ERR,    /**< Parser counter */
+    e_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED_WITH_ERR,  /**< Parser counter */
+    e_FM_PCD_PRS_COUNTERS_SOFT_PRS_CYCLES,                      /**< Parser counter */
+    e_FM_PCD_PRS_COUNTERS_SOFT_PRS_STALL_CYCLES,                /**< Parser counter */
+    e_FM_PCD_PRS_COUNTERS_HARD_PRS_CYCLE_INCL_STALL_CYCLES,     /**< Parser counter */
+    e_FM_PCD_PRS_COUNTERS_MURAM_READ_CYCLES,                    /**< MURAM counter */
+    e_FM_PCD_PRS_COUNTERS_MURAM_READ_STALL_CYCLES,              /**< MURAM counter */
+    e_FM_PCD_PRS_COUNTERS_MURAM_WRITE_CYCLES,                   /**< MURAM counter */
+    e_FM_PCD_PRS_COUNTERS_MURAM_WRITE_STALL_CYCLES,             /**< MURAM counter */
+    e_FM_PCD_PRS_COUNTERS_FPM_COMMAND_STALL_CYCLES              /**< FPM counter */
+} e_FmPcdCounters;
+
+/**************************************************************************//**
+ @Description   PCD interrupts
+*//***************************************************************************/
+typedef enum e_FmPcdExceptions {
+
+    /*TODO - to understand how it has to be done*/
+    /*maybe module of PCD + specific interrupts*/
+    e_FM_PCD_KG_ERR_EXCEPTION_DOUBLE_ECC,                   /**< Keygen ECC error */
+    e_FM_PCD_PLCR_ERR_EXCEPTION_DOUBLE_ECC,                 /**< Read Buffer ECC error */
+    e_FM_PCD_KG_ERR_EXCEPTION_KEYSIZE_OVERFLOW,             /**< Write Buffer ECC error on system side */
+    e_FM_PCD_PLCR_ERR_EXCEPTION_INIT_ENTRY_ERROR,           /**< Write Buffer ECC error on FM side */
+    e_FM_PCD_PLCR_EXCEPTION_PRAM_SELF_INIT_COMPLETE,        /**< Self init complete */
+    e_FM_PCD_PLCR_EXCEPTION_ATOMIC_ACTION_COMPLETE,         /**< Atomic action complete */
+    e_FM_PCD_PRS_EXCEPTION_DOUBLE_ECC,                      /**< Parser ECC error */
+    e_FM_PCD_PRS_EXCEPTION_SINGLE_ECC,                      /**< Parser single ECC */
+    e_FM_PCD_PRS_EXCEPTION_ILLEGAL_ACCESS,                  /**< Parser illegal access */
+    e_FM_PCD_PRS_EXCEPTION_PORT_ILLEGAL_ACCESS              /**< Parser port illegal access */
+} e_FmPcdExceptions;
+
+
+/**************************************************************************//**
+ @Description   t_FmPcdExceptions - Exceptions user callback routine, will be called upon an
+                exception passing the exception identification.
+
+ @Param[in]     h_App      - User's application descriptor.
+ @Param[in]     exception  - The exception.
+  *//***************************************************************************/
+typedef void (t_FmPcdException) ( t_Handle h_App, e_FmPcdExceptions exception);
+
+/**************************************************************************//**
+ @Description   t_FmPcdSchemeErrorExceptionsCallback - Exceptions user callback routine,
+                will be called upon an exception passing the exception identification.
+
+ @Param[in]     h_App           - User's application descriptor.
+ @Param[in]     exception       - The exception.
+ @Param[in]     index           - id of the relevant source (may be scheme or profile id).
+ *//***************************************************************************/
+typedef void (t_FmPcdIdException) ( t_Handle           h_App,
+                                    e_FmPcdExceptions  exception,
+                                    uint16_t           index);
+
+/**************************************************************************//**
+ @Description   t_FmPcdQmEnqueueCB - TBD.
+
+ @Param[in]     h_App           - User's application descriptor.
+ @Param[in]     fqid            - TBD.
+ @Param[in]     p_Fd            - TBD.
+
+ @Return        E_OK on success; Error code otherwise.
+ *//***************************************************************************/
+typedef t_Error (t_FmPcdQmEnqueueCB) ( t_Handle h_QmArg, uint32_t fqid, void *p_Fd);
+
+/**************************************************************************//**
+ @Description   A structure for Host-Command
+                When using Host command for PCD functionalities, a dedicated port
+                must be used. If this routine is called for a PCD in a single partition
+                environment, or it is the Master partition in a Multi partition
+                environment, The port will be initialized by the PCD driver
+                initialization routine.
+ *//***************************************************************************/
+typedef struct t_FmPcdHcParams {
+#ifndef CONFIG_GUEST_PARTITION
+    uint64_t                portBaseAddr;       /**< Host-Command Port Virtual Address of
+                                                     memory mapped registers.*/
+    uint8_t                 portId;             /**< Host-Command Port Id (0-6 relative
+                                                     to Host-Command/Offline parsing ports) */
+    uint32_t                errFqid;            /**< Host-Command Port Error Queue Id. */
+    uint32_t                confFqid;           /**< Host-Command Port Confirmation queue Id. */
+    uint8_t                 deqSubPortal;       /**< Host-Command Port Subportal for dequeue. */
+#endif /* !CONFIG_GUEST_PARTITION */
+    uint32_t                enqFqid;            /**< Host-Command enqueue Queue Id. */
+    t_FmPcdQmEnqueueCB      *f_QmEnqueueCB;     /**< TBD */
+    t_Handle                h_QmArg;            /**< TBD */
+} t_FmPcdHcParams;
+
+/**************************************************************************//**
+ @Description   The main structure for PCD initialization
+ *//***************************************************************************/
+typedef struct t_FmPcdParams {
+    bool                        prsSupport;             /**< TRUE if Parser will be used for any
+                                                             of the FM ports */
+    bool                        ccSupport;              /**< TRUE if Coarse Classification will be used for any
+                                                             of the FM ports */
+    bool                        kgSupport;              /**< TRUE if Keygen will be used for any
+                                                             of the FM ports */
+    bool                        plcrSupport;            /**< TRUE if Policer will be used for any
+                                                             of the FM ports */
+    t_Handle                    h_Fm;                   /**< A handle to the FM module */
+    t_Handle                    h_FmMuram;              /**< Relevant only if ccEnable is enabled. */
+
+#ifdef CONFIG_MULTI_PARTITION_SUPPORT
+    uint8_t                     numOfSchemes;           /**< Number of schemes dedicated to this partition. */
+    uint16_t                    numOfClsPlanEntries;    /**< Number of clsPlan entries dedicated to this partition,
+                                                             Must be a power of 2. */
+    uint8_t                     partitionId;            /**< Guest Partition Id */
+#else
+    bool                        useHostCommand;
+#endif  /* CONFIG_MULTI_PARTITION_SUPPORT */
+    t_FmPcdHcParams             hc;                     /**< Host Command parameters */
+
+#ifndef CONFIG_GUEST_PARTITION
+    t_FmPcdException            *f_FmPcdException;      /**< Callback routine to be called of PCD exception */
+    t_FmPcdIdException          *f_FmPcdIdException;    /**< Callback routine to be used for a single scheme and
+                                                             profile exceptions */
+    t_Handle                    h_App;                  /**< A handle to an application layer object; This handle will
+                                                             be passed by the driver upon calling the above callbacks */
+#endif /* !CONFIG_GUEST_PARTITION */
+} t_FmPcdParams;
+
+
+/**************************************************************************//**
+ @Function      FM_PCD_Config
+
+ @Description   Basic configuration of the PCD module.
+                Creates descriptor for the FM PCD module.
+
+ @Param[in]     p_FmPcdParams    A structure of parameters for the initialization of PCD.
+
+ @Return        A handle to the initialized module.
+*//***************************************************************************/
+t_Handle FM_PCD_Config(t_FmPcdParams *p_FmPcdParams);
+
+/**************************************************************************//**
+ @Function      FM_PCD_Init
+
+ @Description   Initialization of the PCD module.
+
+ @Param[in]     h_FmPcd - FM PCD module descriptor.
+
+ @Return        E_OK on success; Error code otherwise.
+*//***************************************************************************/
+t_Error FM_PCD_Init(t_Handle h_FmPcd);
+
+/**************************************************************************//**
+ @Function      FM_PCD_Free
+
+ @Description   Frees all resources that were assigned to FM module.
+
+                Calling this routine invalidates the descriptor.
+
+ @Param[in]     h_FmPcd - FM PCD module descriptor.
+
+ @Return        E_OK on success; Error code otherwise.
+*//***************************************************************************/
+t_Error FM_PCD_Free(t_Handle h_FmPcd);
+
+/**************************************************************************//**
+ @Group         FM_PCD_advanced_init_grp    FM PCD Advanced Configuration Unit
+
+ @Description   Configuration functions used to change default values.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Function      FM_PCD_ConfigPlcrNumOfSharedProfiles
+
+ @Description   Calling this routine changes the internal driver data base
+                from its default selection of exceptions enablement.
+                [DEFAULT_numOfSharedPlcrProfiles].
+
+ @Param[in]     h_FmPcd                     FM PCD module descriptor.
+ @Param[in]     numOfSharedPlcrProfiles     Number of profiles to
+                                            be shared between ports on this partition
+
+ @Return        E_OK on success; Error code otherwise.
+*//***************************************************************************/
+t_Error FM_PCD_ConfigPlcrNumOfSharedProfiles(t_Handle h_FmPcd, uint16_t numOfSharedPlcrProfiles);
+
+/**************************************************************************//**
+ @Function      FM_PCD_ConfigException
+
+ @Description   Calling this routine changes the internal driver data base
+                from its default selection of exceptions enablement.
+                By default all exceptions are enabled.
+
+ @Param[in]     h_FmPcd         FM PCD module descriptor.
+ @Param[in]     exception       The exception to be selected.
+ @Param[in]     enable          TRUE to enable interrupt, FALSE to mask it.
+
+ @Return        E_OK on success; Error code otherwise.
+*//***************************************************************************/
+t_Error FM_PCD_ConfigException(t_Handle h_FmPcd, e_FmPcdExceptions exception, bool enable);
+
+/**************************************************************************//**
+ @Function      FM_PCD_ConfigPlcrAutoRefreshMode
+
+ @Description   Calling this routine changes the internal driver data base
+                from its default selection of exceptions enablement.
+                By default autorefresh is enabled.
+
+ @Param[in]     h_FmPcd         FM PCD module descriptor.
+ @Param[in]     enable          TRUE to enable, FALSE to disable
+
+ @Return        E_OK on success; Error code otherwise.
+*//***************************************************************************/
+t_Error FM_PCD_ConfigPlcrAutoRefreshMode(t_Handle h_FmPcd, bool enable);
+
+/**************************************************************************//**
+ @Function      FM_PCD_ConfigPrsMaxCycleLimit
+
+ @Description   Calling this routine changes the internal data structure for
+                the maximum parsing time from its default value
+                [DEFAULT_prsMaxParseCycleLimit].
+
+ @Param[in]     h_FmPcd         FM PCD module descriptor.
+ @Param[in]     value           0 to disable the mechanism, or new
+                                maximum parsing time.
+
+ @Return        E_OK on success; Error code otherwise.
+*//***************************************************************************/
+t_Error FM_PCD_ConfigPrsMaxCycleLimit(t_Handle h_FmPcd,uint16_t value);
+
+/** @} */ /* end of FM_PCD_advanced_init_grp group */
+/** @} */ /* end of FM_PCD_init_grp group */
+
+
+/**************************************************************************//**
+ @Group         FM_PCD_Runtime_grp FM PCD Runtime Unit
+
+ @Description   FM PCD Runtime Unit
+
+                The runtime control allows creation of PCD infrastructure modules
+                such as Network Environment Characteristics, Classification Plan
+                Groups and Coarse Classification Trees.
+                It also allows on-the-fly initialization, modification and removal
+                of PCD modules such as Keygen schemes, coarse classification nodes
+                and Policer profiles.
+
+
+                In order to explain the programming model of the PCD driver interface
+                a few terms should be explained, and will be used below.
+                  * Distinction Header - One of the 16 protocols supported by the FM parser,
+                    or one of the shim headers (1-3). May be a header with a special
+                    option (see below).
+                  * Interchangeable Headers Group- This is a group of Headers recognized
+                    by either one of them. For example, if in a specific context the user
+                    chooses to treat IPv4 and IPV6 in the same way, they may create an
+                    Interchangable Headers Unit consisting of these 2 headers.
+                  * A Distinction Unit - a Distinction Header or an Interchangeable Headers
+                    Group.
+                  * Header with special option - applies to ethernet, mpls, vlan, ipv4 and
+                    ipv6, includes multicast, broadcast and other protocol specific options.
+                    In terms of hardware it relates to the options available in the classification
+                    plan.
+                  * Network Environment Characteristics - a set of Distinction Units that define
+                    the total recognizable header selection for a certain environment. This is
+                    NOT the list of all headers that will ever appear in a flow, but rather
+                    everything that needs distinction in a flow, where distinction is made by keygen
+                    schemes and coarse classification action descriptors.
+
+                The PCD runtime modules initialization is done in stages. The first stage after
+                initializing the PCD module itself is to establish a Network Flows Environment
+                Definition. The application may choose to establish one or more such environments.
+                Later, when needed, the application will have to state, for some of its modules,
+                to which single environment it belongs.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description   A structure for sw parser labels
+ *//***************************************************************************/
+typedef struct t_FmPcdPrsLabelParams {
+    uint32_t                instructionOffset;              /**< SW parser label instruction offset (2 bytes
+                                                                 resolution), relative to Parser RAM. */
+    e_NetHeaderType         hdr;                            /**< The existance of this header will envoke
+                                                                 the sw parser code. */
+    uint8_t                 indexPerHdr;                    /**< Normally 0, if more than one sw parser
+                                                                 attachments for the same header, use this
+                                                                 index to distinguish between them. */
+} t_FmPcdPrsLabelParams;
+
+/**************************************************************************//**
+ @Description   A structure for sw parser
+ *//***************************************************************************/
+typedef struct t_FmPcdPrsSwParams {
+    bool                    override;                   /**< FALSE to invoke a check that nothing else
+                                                             was loaded to this address, including
+                                                             internal patched.
+                                                             TRUE to override any existing code.*/
+    uint32_t                size;                       /**< SW parser code size */
+    uint16_t                base;                       /**< SW parser base (in instruction counts!
+                                                             muat be larger than 0x20)*/
+    uint8_t                 *p_Code;                    /**< SW parser code */
+    uint32_t                swPrsDataParams[FM_PCD_PRS_NUM_OF_HDRS];
+                                                        /**< SW parser data (parameters) */
+    uint8_t                 numOfLabels;                /**< Number of labels for SW parser. */
+    t_FmPcdPrsLabelParams   labelsTable[FM_PCD_PRS_NUM_OF_LABELS];
+                                                        /**< SW parser labels table, containing n
+                                                             umOfLabels entries */
+} t_FmPcdPrsSwParams;
+
+/**************************************************************************//**
+ @Function      FM_PCD_Enable
+
+ @Description   This routine should be called after PCD is initialized for enabling all
+                PCD engines according to their existing configuration.
+
+ @Param[in]     h_FmPcd         FM PCD module descriptor.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following PCD_Init() and when PCD is disabled.
+*//***************************************************************************/
+t_Error FM_PCD_Enable(t_Handle h_FmPcd);
+
+/**************************************************************************//**
+ @Function      FM_PCD_Disable
+
+ @Description   This routine may be called when PCD is enabled in order to
+                disable all PCD engines. It may be called
+                only when none of the ports in the system are using the PCD.
+
+ @Param[in]     h_FmPcd         FM PCD module descriptor.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following PCD_Init() and when PCD is enabled.
+*//***************************************************************************/
+t_Error FM_PCD_Disable(t_Handle h_FmPcd);
+
+/**************************************************************************//**
+ @Function      FM_PCD_KgSetEmptyClsPlanGrp
+
+ @Description   This routine may always be called, and MUST be called when
+                not all ports in the partition are actively using the classification
+                plan mechanism.
+                When called, the driver automatically saves 8 classification
+                plans for ports that do NOT use the classification plan mechanism, to
+                avoid this (in order to save those entries) this routine may
+                be ommited when all ports are using the classification
+                plan machanism.
+
+ @Param[in]     h_FmPcd         FM PCD module descriptor.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following PCD_Init().
+ *//***************************************************************************/
+t_Error FM_PCD_KgSetEmptyClsPlanGrp(t_Handle h_FmPcd);
+
+/**************************************************************************//**
+ @Function      FM_PCD_KgDeleteEmptyClsPlanGrp
+
+ @Description   This routine may be called only when all ports in the
+                system are actively using the classification plan scheme.
+                In such cases, if empty clsPlan was already set,
+                it is recommended in order to save resources.
+
+ @Param[in]     h_FmPcd         FM PCD module descriptor.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following PCD_Init().
+                Note that this routine may not be called if any of the FM ports
+                is not using the classification plan mechanism.
+*//***************************************************************************/
+t_Error FM_PCD_KgDeleteEmptyClsPlanGrp(t_Handle h_FmPcd);
+
+/**************************************************************************//**
+ @Function      FM_PCD_GetCounter
+
+ @Description   Reads one of the FM PCD counters.
+
+ @Param[in]     h_FmPcd     FM PCD module descriptor.
+ @Param[in]     counter     The requested counter.
+
+ @Return        Counter's current value.
+
+ @Cautions      Allowed only following FM_PCD_Init().
+                Note that it is user's responsibilty to call this routine only
+                for enabled counters, and there will be no indication if a
+                disabled counter is accessed.
+*//***************************************************************************/
+uint32_t FM_PCD_GetCounter(t_Handle h_FmPcd, e_FmPcdCounters counter);
+
+#ifndef CONFIG_GUEST_PARTITION
+/**************************************************************************//**
+@Function      FM_PCD_PrsLoadSw
+
+@Description   This routine may be called in order to load software parsing code.
+
+
+@Param[in]     h_FmPcd         FM PCD module descriptor.
+@Param[in]     p_SwPrs         A pointer to a structure of software
+                               parser parameters, including the software
+                               parser image.
+
+@Return        E_OK on success; Error code otherwise.
+
+@Cautions      Allowed only following PCD_Init() and when PCD is disabled.
+*//***************************************************************************/
+t_Error FM_PCD_PrsLoadSw(t_Handle h_FmPcd, t_FmPcdPrsSwParams *p_SwPrs);
+
+/**************************************************************************//**
+ @Function      FM_PCD_KgSetDfltValue
+
+ @Description   Calling this routine sets a global default value to be used
+                by the keygen when parser does not recognize a required
+                field/header.
+                By default default values are 0.
+
+ @Param[in]     h_FmPcd         FM PCD module descriptor.
+ @Param[in]     valueId         0,1 - one of 2 global default values.
+ @Param[in]     value           The requested default value.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following PCD_Init() and when PCD is disabled.
+*//***************************************************************************/
+t_Error FM_PCD_KgSetDfltValue(t_Handle h_FmPcd, uint8_t valueId, uint32_t value);
+
+/**************************************************************************//**
+ @Function      FM_PCD_ConfigKgAdditionalDataAfterParsing
+
+ @Description   Calling this routine allows the keygen to access data past
+                the parser finidhing point.
+
+ @Param[in]     h_FmPcd         FM PCD module descriptor.
+ @Param[in]     payloadOffset   the number of bytes beyond the parser location.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following PCD_Init() and when PCD is disabled.
+
+*//***************************************************************************/
+t_Error FM_PCD_KgSetAdditionalDataAfterParsing(t_Handle h_FmPcd, uint8_t payloadOffset);
+
+/**************************************************************************//**
+ @Function      FM_PCD_SetException
+
+ @Description   Calling this routine enables/disables PCD interrupts.
+
+ @Param[in]     h_FmPcd         FM PCD module descriptor.
+ @Param[in]     exception       The exception to be selected.
+ @Param[in]     enable          TRUE to enable interrupt, FALSE to mask it.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following PCD_Init().
+*//***************************************************************************/
+t_Error FM_PCD_SetException(t_Handle h_FmPcd, e_FmPcdExceptions exception, bool enable);
+
+/**************************************************************************//**
+ @Function      FM_PCD_SetCounter
+
+ @Description   Sets a value to an enabled counter. Use "0" to reset the counter.
+
+ @Param[in]     h_FmPcd     FM PCD module descriptor.
+ @Param[in]     counter     The requested counter.
+ @Param[in]     value       The requested value to be written into the counter.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following PCD_Init().
+*//***************************************************************************/
+t_Error FM_PCD_SetCounter(t_Handle h_FmPcd, e_FmPcdCounters counter, uint32_t value);
+
+/**************************************************************************//**
+ @Function      FM_PCD_SetPlcrStatistics
+
+ @Description   This routine may be used to enable/disable policer statistics
+                counter. By default the statistics is enabled.
+
+ @Param[in]     h_FmPcd         FM PCD module descriptor
+ @Param[in]     enable          TRUE to enable, FALSE to disable.
+
+ @Return        E_OK on success; Error code otherwise.
+*//***************************************************************************/
+t_Error FM_PCD_SetPlcrStatistics(t_Handle h_FmPcd, bool enable);
+
+/**************************************************************************//**
+ @Function      FM_PCD_PrsStatistics
+
+ @Description   Defines whether to gather parser statistics including all ports.
+
+ @Param[in]     h_FmPcd     FM PCD module descriptor.
+ @Param[in]     enable      TRUE to enable, FALSE to disable.
+
+ @Return        None
+
+ @Cautions      Allowed only following PCD_Init().
+*//***************************************************************************/
+void FM_PCD_PrsStatistics(t_Handle h_FmPcd, bool enable);
+#endif /* !CONFIG_GUEST_PARTITION */
+
+/**************************************************************************//**
+ @Function      FM_PCD_ForceIntr
+
+ @Description   Causes an interrupt event on the requested source.
+
+ @Param[in]     h_FmPcd     FM PCD module descriptor.
+ @Param[in]     exception       An exception to be forced.
+
+ @Return        E_OK on success; Error code if the exception is not enabled,
+                or is not able to create interrupt.
+
+ @Cautions      Allowed only following PCD_Init().
+*//***************************************************************************/
+t_Error FM_PCD_ForceIntr (t_Handle h_FmPcd, e_FmPcdExceptions exception);
+
+/**************************************************************************//**
+ @Function      FM_PCD_HcTxConf
+
+ @Description   TBD
+
+ @Param[in]     h_FmPcd         A handle to an FM PCD Module.
+ @Param[in]     p_Fd            TBD
+
+ @Cautions      Allowed only following FM_PCD_Init(). Allowed only if 'useHostCommand'
+                option was selected in the initialization.
+*//***************************************************************************/
+void FM_PCD_HcTxConf(t_Handle h_FmPcd, t_FmFD *p_Fd);
+
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+/**************************************************************************//**
+ @Function      FM_PCD_DumpRegs
+
+ @Description   Dumps all PCD registers
+
+ @Param[in]     h_FmPcd         A handle to an FM PCD Module.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_Init().
+*//***************************************************************************/
+t_Error FM_PCD_DumpRegs(t_Handle h_FmPcd);
+
+/**************************************************************************//**
+ @Function      FM_PCD_KgDumpRegs
+
+ @Description   Dumps all PCD KG registers
+
+ @Param[in]     h_FmPcd         A handle to an FM PCD Module.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_Init().
+*//***************************************************************************/
+t_Error FM_PCD_KgDumpRegs(t_Handle h_FmPcd);
+
+/**************************************************************************//**
+ @Function      FM_PCD_PlcrDumpRegs
+
+ @Description   Dumps all PCD Plcr registers
+
+ @Param[in]     h_FmPcd         A handle to an FM PCD Module.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_Init().
+*//***************************************************************************/
+t_Error FM_PCD_PlcrDumpRegs(t_Handle h_FmPcd);
+
+/**************************************************************************//**
+ @Function      FM_PCD_PrsDumpRegs
+
+ @Description   Dumps all PCD Prs registers
+
+ @Param[in]     h_FmPcd         A handle to an FM PCD Module.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_Init().
+*//***************************************************************************/
+t_Error FM_PCD_PrsDumpRegs(t_Handle h_FmPcd);
+#endif /* (defined(DEBUG_ERRORS) && ... */
+
+#ifdef VERIFICATION_SUPPORT
+/********************* VERIFICATION ONLY ********************************/
+/**************************************************************************//**
+ @Function      FM_PCD_BackdoorSet
+
+ @Description   Reads the DMA current status
+
+ @Param[in]     h_FmPcd             A handle to an FM Module.
+ @Param[out]    moduleId            Selected block.
+ @Param[out]    offset              Register offset withing the block.
+ @Param[out]    value               Value to write.
+
+
+ @Return        None
+
+ @Cautions      Allowed only following FM_Init().
+*//***************************************************************************/
+void FM_PCD_BackdoorSet (t_Handle h_FmPcd, e_ModuleId moduleId, uint32_t offset, uint32_t value);
+
+/**************************************************************************//**
+ @Function      FM_PCD_BackdoorGet
+
+ @Description   Reads the DMA current status
+
+ @Param[in]     h_FmPcd             A handle to an FM Module.
+ @Param[out]    moduleId            Selected block.
+ @Param[out]    offset              Register offset withing the block.
+
+ @Return        Value read
+
+ @Cautions      Allowed only following FM_Init().
+*//***************************************************************************/
+uint32_t     FM_PCD_BackdoorGet(t_Handle h_FmPcd, e_ModuleId moduleId, uint32_t offset);
+#endif /*VERIFICATION_SUPPORT*/
+
+
+/**************************************************************************//**
+ @Group         FM_PCD_Runtime_tree_buildgrp FM PCD Tree building Unit
+
+ @Description   FM PCD Runtime Unit
+
+                This group contains routines for setting, deleting and modifying
+                PCD resources, for defining the total PCD tree.
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Collection    Definitions of coarse classification
+                parameters as required by keygen (when coarse classification
+                is the next engine after this scheme).
+*//***************************************************************************/
+#define         MAX_NUM_OF_PCD_CC_NODES     255
+#define         MAX_NUM_OF_PCD_CC_TREES     8
+#define         MAX_NUM_OF_PCD_CC_GROUPS    16
+#define         MAX_NUM_OF_CC_UNITS         4
+#define         MAX_NUM_OF_KEYS             256
+#define         MAX_SIZE_OF_KEY             56
+/* @} */
+
+/**************************************************************************//**
+ @Collection    A set of definitions to allow protocol
+                special option description.
+*//***************************************************************************/
+typedef uint32_t        protocolOpt_t;          /**< A general type to define a protocol option. */
+
+typedef protocolOpt_t   ethProtocolOpt_t;       /**< Ethernet protocol options. */
+#define ETH_BROADCAST               0x80000000  /**< Ethernet Broadcast. */
+#define ETH_MULTICAST               0x40000000  /**< Ethernet Multicast. */
+
+typedef protocolOpt_t   vlanProtocolOpt_t;      /**< Vlan protocol options. */
+#define VLAN_STACKED                0x20000000  /**< Vlan Stacked. */
+
+typedef protocolOpt_t   mplsProtocolOpt_t;      /**< MPLS protocol options. */
+#define MPLS_STACKED                0x10000000  /**< MPLS Stacked. */
+
+typedef protocolOpt_t   ipv4ProtocolOpt_t;      /**< IPv4 protocol options. */
+#define IPV4_BROADCAST_1            0x08000000  /**< IPv4 Broadcast. */
+#define IPV4_MULTICAST_1            0x04000000  /**< IPv4 Multicast. */
+#define IPV4_UNICAST_2              0x02000000  /**< Tunneled IPv4 - Unicast. */
+#define IPV4_MULTICAST_BROADCAST_2  0x01000000  /**< Tunneled IPv4 - Broadcast/Multicast. */
+
+typedef protocolOpt_t   ipv6ProtocolOpt_t;      /**< IPv6 protocol options. */
+#define IPV6_MULTICAST_1            0x00800000  /**< IPv6 Multicast. */
+#define IPV6_UNICAST_2              0x00400000  /**< Tunneled IPv6 - Unicast. */
+#define IPV6_MULTICAST_2            0x00200000  /**< Tunneled IPv6 - Multicast. */
+/* @} */
+
+/**************************************************************************//**
+ @Description   A type used for returning the order of the key extraction.
+                each value in this array represents the index of the extraction
+                command as defined by the user in the initialization extraction array.
+                The valid size of this array is the user define number of extractions
+                required (also marked by the second '0' in this array).
+*//***************************************************************************/
+typedef    uint8_t    t_FmPcdKgKeyOrder [FM_PCD_KG_MAX_NUM_OF_EXTRACTS_PER_KEY];
+
+/**************************************************************************//**
+ @Description   All PCD engines
+*//***************************************************************************/
+typedef enum e_FmPcdEngine {
+    e_FM_PCD_DONE,      /**< No PCD Engine indicated */
+    e_FM_PCD_KG,        /**< Keygen indicated */
+    e_FM_PCD_CC,        /**< Coarse classification indicated */
+    e_FM_PCD_PLCR,      /**< Policer indicated */
+    e_FM_PCD_PRS        /**< Parser indicated */
+} e_FmPcdEngine;
+
+/**************************************************************************//**
+ @Description   An enum for selecting extraction by header types
+*//***************************************************************************/
+typedef enum e_FmPcdExtractByHdrType {
+    e_FM_PCD_EXTRACT_FROM_HDR,      /**< Extract bytes from header */
+    e_FM_PCD_EXTRACT_FROM_FIELD,    /**< Extract bytes from header field */
+    e_FM_PCD_EXTRACT_FULL_FIELD     /**< Extract a full field */
+} e_FmPcdExtractByHdrType;
+
+/**************************************************************************//**
+ @Description   An enum for selecting extraction source
+                (when it is not the header)
+*//***************************************************************************/
+typedef enum e_FmPcdExtractFrom {
+    e_FM_PCD_EXTRACT_FROM_FRAME_START,          /**< Extract from beginning of frame */
+    e_FM_PCD_KG_EXTRACT_FROM_DFLT_VALUE,        /**< Extract from a default value */
+    e_FM_PCD_KG_EXTRACT_FROM_PARSE_RESULT,      /**< Extract from the parser result */
+    e_FM_PCD_KG_EXTRACT_FROM_CURR_END_OF_PARSE  /**< Extract from the point where parsing had finished */
+} e_FmPcdExtractFrom;
+
+/**************************************************************************//**
+ @Description   An enum for selecting extraction type
+*//***************************************************************************/
+typedef enum e_FmPcdExtractType {
+    e_FM_PCD_EXTRACT_BY_HDR,                /**< Extract according to header */
+    e_FM_PCD_EXTRACT_NON_HDR,               /**< Extract from data that is not the header */
+    e_FM_PCD_KG_EXTRACT_PORT_PRIVATE_INFO   /**< Extract private info as specified by user */
+} e_FmPcdExtractType;
+
+/**************************************************************************//**
+ @Description   An enum for selecting a default
+*//***************************************************************************/
+typedef enum e_FmPcdKgExtractDfltSelect {
+    e_FM_PCD_KG_DFLT_GBL_0,          /**< Default selection is KG register 0 */
+    e_FM_PCD_KG_DFLT_GBL_1,          /**< Default selection is KG register 1 */
+    e_FM_PCD_KG_DFLT_PRIVATE_0,      /**< Default selection is a per scheme register 0 */
+    e_FM_PCD_KG_DFLT_PRIVATE_1,      /**< Default selection is a per scheme register 1 */
+    e_FM_PCD_KG_DFLT_ILLEGAL         /**< Illegal selection */
+} e_FmPcdKgExtractDfltSelect;
+
+/**************************************************************************//**
+ @Description   An enum defining all default groups -
+                each group shares a default value, one of 4 user
+                initialized values.
+*//***************************************************************************/
+typedef enum e_FmPcdKgKnownFieldsDfltTypes {
+    e_FM_PCD_KG_MAC_ADDR,               /**< MAC Address */
+    e_FM_PCD_KG_TCI,                    /**< TCI field */
+    e_FM_PCD_KG_ENET_TYPE,              /**< ENET Type */
+    e_FM_PCD_KG_PPP_SESSION_ID,         /**< PPP Session id */
+    e_FM_PCD_KG_PPP_PROTOCOL_ID,        /**< PPP Protocol id */
+    e_FM_PCD_KG_MPLS_LABEL,             /**< MPLS label */
+    e_FM_PCD_KG_IP_ADDR,                /**< IP addr */
+    e_FM_PCD_KG_PROTOCOL_TYPE,          /**< Protocol type */
+    e_FM_PCD_KG_IP_TOS_TC,              /**< TOS or TC */
+    e_FM_PCD_KG_IPV6_FLOW_LABEL,        /**< IPV6 flow label */
+    e_FM_PCD_KG_IPSEC_SPI,              /**< IPSEC SPI */
+    e_FM_PCD_KG_L4_PORT,                /**< L4 Port */
+    e_FM_PCD_KG_TCP_FLAG,               /**< TCP Flag */
+    e_FM_PCD_KG_GENERIC_FROM_DATA,      /**< grouping implemented by sw,
+                                             any data extraction that is not the full
+                                             field described above  */
+    e_FM_PCD_KG_GENERIC_FROM_DATA_NO_V, /**< grouping implemented by sw,
+                                             any data extraction without validation */
+    e_FM_PCD_KG_GENERIC_NOT_FROM_DATA   /**< grouping implemented by sw,
+                                             extraction from parser result or
+                                             direct use of default value  */
+} e_FmPcdKgKnownFieldsDfltTypes;
+
+/**************************************************************************//**
+ @Description   enum for defining header index when headers may repeat
+*//***************************************************************************/
+typedef enum e_FmPcdHdrIndex {
+    e_FM_PCD_HDR_INDEX_NONE     =   0,      /**< used when multiple headers not used, also
+                                                 to specify regular IP (not tunneled). */
+    e_FM_PCD_HDR_INDEX_1,                   /**< may be used for VLAN, MPLS, tunneled IP */
+    e_FM_PCD_HDR_INDEX_2,                   /**< may be used for MPLS, tunneled IP */
+    e_FM_PCD_HDR_INDEX_3,                   /**< may be used for MPLS */
+    e_FM_PCD_HDR_INDEX_LAST     =   0xFF    /**< may be used for VLAN, MPLS */
+} e_FmPcdHdrIndex;
+
+/**************************************************************************//**
+ @Description   A structure for selcting the policer profile functional type
+*//***************************************************************************/
+typedef enum e_FmPcdProfileTypeSelection {
+    e_FM_PCD_PLCR_PORT_PRIVATE,             /**< Port dedicated profile */
+    e_FM_PCD_PLCR_SHARED                    /**< Shared profile (shared within partition) */
+} e_FmPcdProfileTypeSelection;
+
+/**************************************************************************//**
+ @Description   A structure for selcting the policer profile algorithem
+*//***************************************************************************/
+typedef enum e_FmPcdPlcrAlgorithmSelection {
+    e_FM_PCD_PLCR_PASS_THROUGH,         /**< Policer pass through */
+    e_FM_PCD_PLCR_RFC_2698,             /**< Policer algorythm RFC 2698 */
+    e_FM_PCD_PLCR_RFC_4115              /**< Policer algorythm RFC 4115 */
+} e_FmPcdPlcrAlgorithmSelection;
+
+/**************************************************************************//**
+ @Description   A structure for selcting the policer profile color mode
+*//***************************************************************************/
+typedef enum e_FmPcdPlcrColorMode {
+    e_FM_PCD_PLCR_COLOR_BLIND,          /**< Color blind */
+    e_FM_PCD_PLCR_COLOR_AWARE           /**< Color aware */
+} e_FmPcdPlcrColorMode;
+
+/**************************************************************************//**
+ @Description   A structure for selcting the policer profile color functional mode
+*//***************************************************************************/
+typedef enum e_FmPcdPlcrColor {
+    e_FM_PCD_PLCR_GREEN,                /**< Green */
+    e_FM_PCD_PLCR_YELLOW,               /**< Yellow */
+    e_FM_PCD_PLCR_RED,                  /**< Red */
+    e_FM_PCD_PLCR_OVERRIDE              /**< Color override */
+} e_FmPcdPlcrColor;
+
+/**************************************************************************//**
+ @Description   A structure for selcting the policer profile packet frame length selector
+*//***************************************************************************/
+typedef enum e_FmPcdPlcrFrameLengthSelect {
+  e_FM_PCD_PLCR_L2_FRM_LEN,             /**< L2 frame length */
+  e_FM_PCD_PLCR_L3_FRM_LEN,             /**< L3 frame length */
+  e_FM_PCD_PLCR_L4_FRM_LEN,             /**< L4 frame length */
+  e_FM_PCD_PLCR_FULL_FRM_LEN            /**< Full frame length */
+} e_FmPcdPlcrFrameLengthSelect;
+
+/**************************************************************************//**
+ @Description   An enum for selecting rollback frame
+*//***************************************************************************/
+typedef enum e_FmPcdPlcrRollBackFrameSelect {
+  e_FM_PCD_PLCR_ROLLBACK_L2_FRM_LEN,    /**< Rollback L2 frame length */
+  e_FM_PCD_PLCR_ROLLBACK_FULL_FRM_LEN   /**< Rollback Full frame length */
+} e_FmPcdPlcrRollBackFrameSelect;
+
+/**************************************************************************//**
+ @Description   A structure for selcting the policer profile packet or byte mode
+*//***************************************************************************/
+typedef enum e_FmPcdPlcrRateMode {
+    e_FM_PCD_PLCR_BYTE_MODE,            /**< Byte mode */
+    e_FM_PCD_PLCR_PACKET_MODE           /**< Packet mode */
+} e_FmPcdPlcrRateMode;
+
+/**************************************************************************//**
+ @Description   An enum for defining action of frame
+*//***************************************************************************/
+typedef enum e_FmPcdPlcrDoneAction {
+    e_FM_PCD_PLCR_ENQ_FRAME,            /**< Enqueue frame */
+    e_FM_PCD_PLCR_DROP_FRAME            /**< Drop frame */
+} e_FmPcdPlcrDoneAction;
+
+/**************************************************************************//**
+ @Description   A structure for selcting the policer counter
+*//***************************************************************************/
+typedef enum e_FmPcdPlcrProfileCounters {
+    e_FM_PCD_PLCR_PROFILE_GREEN_PACKET_TOTAL_COUNTER,               /**< Green packets counter */
+    e_FM_PCD_PLCR_PROFILE_YELLOW_PACKET_TOTAL_COUNTER,              /**< Yellow packets counter */
+    e_FM_PCD_PLCR_PROFILE_RED_PACKET_TOTAL_COUNTER,                 /**< Red packets counter */
+    e_FM_PCD_PLCR_PROFILE_RECOLOURED_YELLOW_PACKET_TOTAL_COUNTER,   /**< Recolored yellow packets counter */
+    e_FM_PCD_PLCR_PROFILE_RECOLOURED_RED_PACKET_TOTAL_COUNTER       /**< Recolored red packets counter */
+} e_FmPcdPlcrProfileCounters;
+
+
+/**************************************************************************//**
+ @Description   A Union of protocol dependent special options
+*//***************************************************************************/
+typedef union u_FmPcdHdrProtocolOpt {
+    ethProtocolOpt_t    ethOpt;     /**< Ethernet options */
+    vlanProtocolOpt_t   vlanOpt;    /**< Vlan options */
+    mplsProtocolOpt_t   mplsOpt;    /**< MPLS options */
+    ipv4ProtocolOpt_t   ipv4Opt;    /**< IPv4 options */
+    ipv6ProtocolOpt_t   ipv6Opt;    /**< IPv6 options */
+} u_FmPcdHdrProtocolOpt;
+
+/**************************************************************************//**
+ @Description   A union holding all known protocol fields
+*//***************************************************************************/
+typedef union t_FmPcdFields {
+    headerFieldEth_t        eth;        /**< eth      */
+    headerFieldVlan_t       vlan;       /**< vlan     */
+    headerFieldLlcSnap_t    llcSnap;    /**< llcSnap  */
+    headerFieldPppoe_t      pppoe;      /**< pppoe    */
+    headerFieldMpls_t       mpls;       /**< mpls     */
+    headerFieldIpv4_t       ipv4;       /**< ipv4     */
+    headerFieldIpv6_t       ipv6;       /**< ipv6     */
+    headerFieldUdp_t        udp;        /**< udp      */
+    headerFieldTcp_t        tcp;        /**< tcp      */
+    headerFieldSctp_t       sctp;       /**< sctp     */
+    headerFieldDccp_t       dccp;       /**< dccp     */
+    headerFieldGre_t        gre;        /**< gre      */
+    headerFieldMinencap_t   minencap;   /**< minencap */
+    headerFieldIpsecAh_t    ipsecAh;    /**< ipsecAh  */
+    headerFieldIpsecEsp_t   ipsecEsp;   /**< ipsecEsp */
+} t_FmPcdFields;
+
+/**************************************************************************//**
+ @Description   structure for defining header extraction for key generation
+*//***************************************************************************/
+typedef struct t_FmPcdFromHdr {
+    uint8_t             size;           /**< Size in byte */
+    uint8_t             offset;         /**< Byte offset */
+} t_FmPcdFromHdr;
+
+/**************************************************************************//**
+ @Description   structure for defining field extraction for key generation
+*//***************************************************************************/
+typedef struct t_FmPcdFromField {
+    t_FmPcdFields       field;          /**< Field selection */
+    uint8_t             size;           /**< Size in byte */
+    uint8_t             offset;         /**< Byte offset */
+} t_FmPcdFromField;
+
+/**************************************************************************//**
+ @Description   A structure of parameters used to define a single network
+                environment unit.
+                A unit should be defined if it will later be used by one or
+                more PCD engines to distinguich between flows.
+*//***************************************************************************/
+typedef struct t_FmPcdDistinctionUnit {
+    struct {
+        e_NetHeaderType         hdr;        /**< One of the headers supported by the FM */
+        u_FmPcdHdrProtocolOpt   opt;        /**< only one option !! */
+    } hdrs[FM_PCD_MAX_NUM_OF_INTERCHANGABLE_HDRS];
+} t_FmPcdDistinctionUnit;
+
+/**************************************************************************//**
+ @Description   A structure of parameters used to define the different
+                units supported by a specific PCD Network Environment
+                Characteristics module. Each unit represent
+                a protocol or a group of protocols that may be used later
+                by the different PCD engined to distinguich between flows.
+*//***************************************************************************/
+typedef struct t_FmPcdNetEnvParams {
+    uint8_t                 numOfDistinctionUnits;                      /**< Number of different units to be identified */
+    t_FmPcdDistinctionUnit  units[FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS]; /**< An array of numOfDistinctionUnits of the
+                                                                             different units to be identified */
+} t_FmPcdNetEnvParams;
+
+/**************************************************************************//**
+ @Description   structure for defining a single extraction action
+                when creating a key
+*//***************************************************************************/
+typedef struct t_FmPcdExtractEntry {
+    e_FmPcdExtractType                  type;           /**< Extraction type select */
+    union {
+        struct {                        /**< used when type = e_FM_PCD_KG_EXTRACT_BY_HDR */
+            e_NetHeaderType             hdr;            /**< Header selection */
+            bool                        ignoreProtocolValidation;   /**< Ignore protocol validation */
+            e_FmPcdHdrIndex             hdrIndex;       /**< Relevant only for MPLS, VLAN and tunneled
+                                                             IP. Otherwise should be cleared.*/
+            e_FmPcdExtractByHdrType     type;           /**< Header extraction type select */
+            union {
+                t_FmPcdFromHdr          fromHdr;        /**< Extract bytes from header parameters */
+                t_FmPcdFromField        fromField;      /**< Extract bytes from field parameters*/
+                t_FmPcdFields           fullField;      /**< Extract full filed parameters*/
+            } extractByHdrType;
+        } extractByHdr;
+        struct {                        /**< used when type = e_FM_PCD_KG_EXTRACT_NON_HDR */
+            e_FmPcdExtractFrom          src;            /**< Non-header extraction source */
+            uint8_t                     offset;         /**< Byte offset */
+            uint8_t                     size;           /**< Size in byte */
+        } extractNonHdr;
+    } extractParams;
+} t_FmPcdExtractEntry;
+
+/**************************************************************************//**
+ @Description   A structure for defining masks for each extracted
+                field in the key.
+*//***************************************************************************/
+typedef struct t_FmPcdKgExtractMask {
+    uint8_t                             extractArrayIndex;       /**< Index in the extraction array, as initialized by user */
+    uint8_t                             offset;                  /**< Byte offset */
+    uint8_t                             mask;                    /**< A byte mask (selected bits will be used) */
+} t_FmPcdKgExtractMask;
+
+/**************************************************************************//**
+ @Description   A structure for defining default selection per groups
+                of fields
+*//***************************************************************************/
+typedef struct t_FmPcdKgExtractDflt {
+    e_FmPcdKgKnownFieldsDfltTypes       type;                /**< Default type select*/
+    e_FmPcdKgExtractDfltSelect          dfltSelect;          /**< Default register select */
+} t_FmPcdKgExtractDflt;
+
+/**************************************************************************//**
+ @Description   A structure for defining all parameters needed for
+                generation a key and using a hash function
+*//***************************************************************************/
+typedef struct t_FmPcdKgKeyExtractAndHashParams {
+    uint32_t                    privateDflt0;                /**< Scheme default register 0 */
+    uint32_t                    privateDflt1;                /**< Scheme default register 1 */
+    uint8_t                     numOfUsedExtracts;           /**< defines the valid size of the following array */
+    t_FmPcdExtractEntry         extractArray [FM_PCD_KG_MAX_NUM_OF_EXTRACTS_PER_KEY]; /**< An array of extractions definition. */
+    uint8_t                     numOfUsedDflts;              /**< defines the valid size of the following array */
+    t_FmPcdKgExtractDflt        dflts[FM_PCD_KG_NUM_OF_DEFAULT_GROUPS];
+    uint8_t                     numOfUsedMasks;              /**< defines the valid size of the following array */
+    t_FmPcdKgExtractMask        masks[FM_PCD_KG_NUM_OF_EXTRACT_MASKS];
+    uint8_t                     hashShift;                   /**< Select the 24 bits out of the 64 hash result */
+    uint32_t                    hashDistributionNumOfFqids;  /**< must be > 1 and a power of 2. Represents the range
+                                                                  of queues for the key and hash functionality */
+    uint8_t                     hashDistributionFqidsShift;  /**< selects the FQID bits that will be effected by the hash */
+} t_FmPcdKgKeyExtractAndHashParams;
+
+/**************************************************************************//**
+ @Description   A structure of parameters for defining a single
+                Fqid mask (extracted OR).
+*//***************************************************************************/
+typedef struct t_FmPcdKgExtractedOrForFqid {
+    e_FmPcdExtractType              type;               /**< Extraction type select */
+    union {
+        struct {                                        /**< used when type = e_FM_PCD_KG_EXTRACT_BY_HDR */
+            e_NetHeaderType         hdr;
+            e_FmPcdHdrIndex         hdrIndex;           /**< Relevant only for MPLS, VLAN and tunneled
+                                                             IP. Otherwise should be cleared.*/
+            bool                    ignoreProtocolValidation;
+                                                        /**< continue extraction even if protocol is not recognized */
+        } extractByHdr;
+        e_FmPcdExtractFrom          src;                /**< used when type = e_FM_PCD_KG_EXTRACT_NON_HDR */
+    } extractParams;
+    uint8_t                         extractionOffset;   /**< Offset for extraction (in bytes).  */
+    e_FmPcdKgExtractDfltSelect      dfltValue;          /**< Select register from which extraction is taken if
+                                                             field not found */
+    uint8_t                         mask;               /**< Extraction mask (specified bits are used) */
+    uint8_t                         bitOffsetInFqid;    /**< out of 24 bits Qid  (max offset = 16) */
+} t_FmPcdKgExtractedOrForFqid;
+
+/**************************************************************************//**
+ @Description   A structure for configuring scheme counter
+*//***************************************************************************/
+typedef struct t_FmPcdKgSchemeCounter {
+    bool        update;     /**< FALSE to keep the current counter state
+                                 and continue from that point, TRUE to update/reset
+                                 the counter when the scheme is written. */
+    uint32_t    value;      /**< If update=TRUE, this value will be written into the
+                                 counter. clear this field to reset the counter. */
+} t_FmPcdKgSchemeCounter;
+
+/**************************************************************************//**
+ @Description   A structure for defining policer profile
+                parameters as required by keygen (when policer
+                is the next engine after this scheme).
+*//***************************************************************************/
+typedef struct t_FmPcdKgPlcrProfile {
+    bool                sharedProfile;              /**< TRUE if this profile is shared between ports
+                                                         (i.e. managed by master partition) May not be TRUE
+                                                         if profile is after Coarse Classification*/
+    bool                direct;                     /**< if TRUE, directRelativeProfileId only selects the profile
+                                                         id, if FALSE fqidOffsetRelativeProfileIdBase is used
+                                                         together with fqidOffsetShift and numOfProfiles
+                                                         parameters, to define a range of profiles from
+                                                         which the keygen result will determine the
+                                                         destination policer profile.  */
+    union {
+        uint16_t        directRelativeProfileId;         /**< Used if 'direct' is TRUE, to select policer profile.
+                                                         This parameter should
+                                                         indicate the policer profile offset within the port's
+                                                         policer profiles or SHARED window. */
+        struct {
+            uint8_t     fqidOffsetShift;            /**< shift of KG results without the qid base */
+            uint8_t     fqidOffsetRelativeProfileIdBase;/**< OR of KG results without the qid base
+                                                         This parameter should
+                                                         indicate the policer profile offset within the port's
+                                                         policer profiles windowor SHARED window depends on sharedProfile */
+            uint8_t     numOfProfiles;              /**< Range of profiles starting at base */
+        } indirectProfile;
+    } profileSelect;
+} t_FmPcdKgPlcrProfile;
+
+/**************************************************************************//**
+ @Description   A structure for CC parameters if CC is the next engine after KG
+*//***************************************************************************/
+typedef struct t_FmPcdKgCc {
+    t_Handle                h_CcTree;           /**< A handle to a CC Tree */
+    uint8_t                 grpId;              /**< CC group id within the CC tree */
+    bool                    plcrNext;           /**< TRUE if after CC, in case of data frame,
+                                                     policing is required. */
+    t_FmPcdKgPlcrProfile    plcrProfile;        /**< only if plcrNext=TRUE */
+} t_FmPcdKgCc;
+
+/**************************************************************************//**
+ @Description   A structure for initializing a keygen single scheme
+*//***************************************************************************/
+typedef struct t_FmPcdKgSchemeParams {
+    bool                                modify;                 /**< IN: TRUE to change an existing scheme */
+    union
+    {
+        uint8_t                         relativeSchemeId;       /**< IN: if modify=FALSE:Partition relative scheme id */
+        t_Handle                        h_Scheme;               /**< IN: if modify=TRUE: a handle of the existing scheme */
+    }id;
+    bool                                alwaysDirect;           /**< IN: This scheme is reached only directly, i.e.                                                              no need for match vector. Keygen will ignore
+                                                                     it when matching   */
+    struct {                                                    /**< IN: HL Relevant only if alwaysDirect = FALSE */
+        t_Handle                        h_NetEnv;               /**< IN: A handle to the Network environment as returned
+                                                                     by FM_PCD_SetNetEnvCharacteristics() */
+        uint8_t                         numOfDistinctionUnits;  /**< IN: Number of netenv units listed in unitIds array */
+        uint8_t                         unitIds[FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS];      /**< Indexes as passed to SetNetEnvCharacteristics array*/
+    } netEnvParams;
+    bool                                useHash;                /**< IN: use the KG Hash functionality  */
+    t_FmPcdKgKeyExtractAndHashParams    keyExtractAndHashParams;
+                                                                /**< IN: used only if useHash = TRUE */
+    uint32_t                            baseFqid;               /**< IN: Base FQID */
+    uint8_t                             numOfUsedFqidMasks;     /**< IN: Number of Fqid masks listed in fqidMasks array*/
+    t_FmPcdKgExtractedOrForFqid         fqidMasks[FM_PCD_KG_NUM_OF_GENERIC_REGS];
+                                                                /**< IN: FM_PCD_KG_NUM_OF_GENERIC_REGS
+                                                                     registers are shared between qidMasks
+                                                                     functionality and some of the extraction
+                                                                     actions. Normally only some will be used
+                                                                     for qidMask. Driver will return error if
+                                                                     resource is full at initialization time. */
+    e_FmPcdEngine                       nextEngine;             /**< IN: may be BMI, PLCR or CC */
+    union {                                                     /**< IN: depends on nextEngine */
+        t_FmPcdKgPlcrProfile            plcrProfile;            /**< IN: Used when next engine is PLCR */
+        t_FmPcdKgCc                     cc;                     /**< IN: Used when next engine is CC */
+    } kgNextEngineParams;
+    t_FmPcdKgSchemeCounter              schemeCounter;          /**< IN: A strcucture of parameters for updating
+                                                                     the scheme counter */
+    t_FmPcdKgKeyOrder                   orderedArray;           /**< OUT: A structure holding the order of the key extraction.
+                                                                     Relevant only is 'useHash' is TRUE. each value in this
+                                                                     array represents the index of the
+                                                                     extraction command as defined by the application in
+                                                                     the initialization extraction array.
+                                                                     The valid size of this array is the application define number of extractions
+                                                                     required (also marked by the second '0' in this array).*/
+} t_FmPcdKgSchemeParams;
+
+/**************************************************************************//**
+ @Description   A structure for defining CC params when CC is the
+                next engine after a CC node.
+*//***************************************************************************/
+typedef struct t_FmPcdCcNextCcParams {
+    t_Handle    h_CcNode;                           /**< A handle of the next CC node */
+} t_FmPcdCcNextCcParams;
+
+/**************************************************************************//**
+ @Description   A structure for defining PLCR params when PLCR is the
+                next engine after a CC node.
+*//***************************************************************************/
+typedef struct t_FmPcdCcNextPlcrParams {
+    bool        ctrlFlow;                           /**< TRUE if this is a control flow, FALSE
+                                                         if this is data flow. */
+    bool        sharedProfile;                      /**< Relevant only if ctrlFlow=TRUE:
+                                                         TRUE if this profile is shared between ports */
+    uint16_t    relativeProfileIdForCtrlFlow;        /**< Relevant only if ctrlFlow=TRUE:
+                                                         (for data flow porfile id
+                                                         is taken from keygen).
+                                                         This parameter should
+                                                         indicate the policer profile offset within the port's
+                                                         policer profiles or from SHARED window.*/
+    bool        fqidEnqForCtrlFlow;                 /**< Relevant only if ctrlFlow=TRUE:
+                                                         TRUE if after the policer the frame should
+                                                         be enqueued rather than return to Keygen */
+    uint32_t    fqidForCtrlFlowForEnqueueAfterPlcr; /**< Relevant only if ctrlFlow=TRUE:
+                                                         if fqidEnqForCtrlFlow= TRUE, FQID for enquing
+                                                         the frame. Unused otherwize. */
+} t_FmPcdCcNextPlcrParams;
+
+/**************************************************************************//**
+ @Description   A structure for defining enqueue params when BMI is the
+                next engine after a CC node.
+*//***************************************************************************/
+typedef struct t_FmPcdCcNextEnqueueParams {
+    bool        ctrlFlow;           /**< TRUE if this is a control flow, FALSE
+                                         if this is data flow */
+    uint32_t    fqidForCtrlFlow;    /**< Valid if ctrlFlow=TRUE, FQID for enquing the frame
+                                         (for data flow FQID is taken from keygen). */
+} t_FmPcdCcNextEnqueueParams;
+
+/**************************************************************************//**
+ @Description   A structure for defining KG params when KG is the
+                next engine after a CC node.
+*//***************************************************************************/
+typedef struct t_FmPcdCcNextKgParams {
+    bool        ctrlFlow;           /**< TRUE if this is a control flow, FALSE
+                                         if this is data flow */
+    t_Handle    h_DirectScheme;     /**< Direct scheme handle to go to. */
+} t_FmPcdCcNextKgParams;
+
+/**************************************************************************//**
+ @Description   A structure for defining next engine params after a CC node.
+*//***************************************************************************/
+typedef struct t_FmPcdCcNextEngineParams {
+    e_FmPcdEngine                       nextEngine;    /**< User has to init parameters
+                                                            according to nextEngine definition */
+    union {
+            t_FmPcdCcNextCcParams       ccParams;      /**< Parameters in case next engine is CC */
+            t_FmPcdCcNextPlcrParams     plcrParams;    /**< Parameters in case next engine is PLCR */
+            t_FmPcdCcNextEnqueueParams  enqueueParams; /**< Parameters in case next engine is BMI */
+            t_FmPcdCcNextKgParams       kgParams;      /**< Parameters in case next engine is KG */
+    } params;
+} t_FmPcdCcNextEngineParams;
+
+/**************************************************************************//**
+ @Description   A structure for defining a single CC Key parameters
+*//***************************************************************************/
+typedef struct t_FmPcdCcKeyParams {
+    uint8_t                     *p_Key;     /**< pointer to the key of the size defined in keySize*/
+    uint8_t                     *p_Mask;    /**< pointer to the Mask per key  of the size defined
+                                                 in keySize. p_Key and p_Mask (if defined) has to be
+                                                 of the same size defined in the keySize*/
+    t_FmPcdCcNextEngineParams   ccNextEngineParams; /**< parameters for the next for the defined Key in the p_Key*/
+} t_FmPcdCcKeyParams;
+
+/**************************************************************************//**
+ @Description   A structure for defining CC Keys parameters
+*//***************************************************************************/
+typedef struct t_KeysParams {
+    uint8_t                     numOfKeys;      /**< num Of relevant Keys  */
+    uint8_t                     keySize;        /**< size of the key - in the case of the extraction of
+                                                     the type FULL_FIELD keySize has to be as standard size of the relevant
+                                                     key. In the another type of extraction keySize has to be as size of extraction. */
+
+    uint8_t                     *p_GlblMask;                /**< optional and can be initialized if:
+                                                                 keySize <=4 or  maskForKey is not initialized */
+    t_FmPcdCcKeyParams          keyParams[MAX_NUM_OF_KEYS];               /**< it's array with numOfKeys entries each entry in
+                                                                 the array of the type t_FmPcdCcKeyParams */
+    t_FmPcdCcNextEngineParams   ccNextEngineParamsForMiss;  /**< parameters for the next step of
+                                                                 unfound (or undefined)  key */
+} t_KeysParams;
+
+/**************************************************************************//**
+ @Description   A structure for defining the CC node params
+*//***************************************************************************/
+typedef struct t_FmPcdCcNodeParams {
+    t_FmPcdExtractEntry         extractCcParams;    /**< params which defines extraction parameters */
+    t_KeysParams                keysParams;         /**< params which defines Keys parameters of the
+                                                         extraction defined in  extractParams */
+
+} t_FmPcdCcNodeParams;
+
+/**************************************************************************//**
+ @Description   A structure for defining each CC tree group in term of
+                NetEnv units and the action to be taken in each case.
+                the unitIds list must be in order from lower to higher indexes.
+
+                t_FmPcdCcNextEngineParams is a list of 2^numOfDistinctionUnits
+                structures where each defines the next action to be taken for
+                each units combination. for example:
+                numOfDistinctionUnits = 2
+                unitIds = {1,3}
+                p_NextEnginePerEntriesInGrp[0] = t_FmPcdCcNextEngineParams for the case that
+                                                        unit 1 - not found; unit 3 - not found;
+                p_NextEnginePerEntriesInGrp[1] = t_FmPcdCcNextEngineParams for the case that
+                                                        unit 1 - not found; unit 3 - found;
+                p_NextEnginePerEntriesInGrp[2] = t_FmPcdCcNextEngineParams for the case that
+                                                        unit 1 - found; unit 3 - not found;
+                p_NextEnginePerEntriesInGrp[3] = t_FmPcdCcNextEngineParams for the case that
+                                                        unit 1 - found; unit 3 - found;
+*//***************************************************************************/
+typedef struct t_FmPcdCcGrpParams {
+        uint8_t                     numOfDistinctionUnits;          /**< up to 4 */
+        uint8_t                     unitIds[MAX_NUM_OF_CC_UNITS];   /**< Indexes of the units as defined in
+                                                                         FM_PCD_SetNetEnvCharacteristics() */
+        t_FmPcdCcNextEngineParams   *p_NextEnginePerEntriesInGrp;   /**< Max size is 16 - if only one group used */
+} t_FmPcdCcGrpParams;
+
+/**************************************************************************//**
+ @Description   A structure for defining the CC tree groups
+*//***************************************************************************/
+typedef struct t_FmPcdCcTreeParams {
+        t_Handle                h_NetEnv;                               /**< A handle to the Network environment as returned
+                                                                             by FM_PCD_SetNetEnvCharacteristics() */
+        uint8_t                 numOfGrps;                              /**< Number of CC groups within the CC tree */
+        t_FmPcdCcGrpParams      ccGrpParams[MAX_NUM_OF_PCD_CC_GROUPS];  /**< Parameters for each group. */
+} t_FmPcdCcTreeParams;
+
+/**************************************************************************//**
+ @Description   A structure for initializing a keygen classification plan group
+*//***************************************************************************/
+typedef struct t_FmPcdKgClsPlanGrpParams {
+    t_Handle        h_NetEnv;                       /**< A handle to the Network environment as returned
+                                                         by FM_PCD_SetNetEnvCharacteristics() */
+
+    uint8_t         numOfOptions;                   /**< Number of options, to define the size of the
+                                                         following array. */
+    protocolOpt_t   options[FM_PCD_MAX_NUM_OF_CLS_PLANS];
+                                                    /**< an option may be a basic one, such as ipv6Multicast1,
+                                                         or a combination of the basic ones such as
+                                                         (ethBroadcast | ethMulticast) or
+                                                         (ethBroadcast | ipv4Unicast2 | mplsStacked).
+                                                         No more than a total of 8 basic options may
+                                                         participate in this array. */
+} t_FmPcdKgClsPlanGrpParams;
+
+/**************************************************************************//**
+ @Description   A structure for defining parameters for byte rate
+*//***************************************************************************/
+typedef struct t_FmPcdPlcrByteRateModeParams {
+    e_FmPcdPlcrFrameLengthSelect    frameLengthSelection;   /**< Frame length selection */
+    e_FmPcdPlcrRollBackFrameSelect  rollBackFrameSelection; /**< relevant option only e_FM_PCD_PLCR_L2_FRM_LEN,
+                                                                 e_FM_PCD_PLCR_FULL_FRM_LEN */
+} t_FmPcdPlcrByteRateModeParams;
+
+/**************************************************************************//**
+ @Description   A structure for selcting the policer profile RFC 2698 or RFC 4115 parameters
+*//***************************************************************************/
+typedef struct t_FmPcdPlcrNonPassthroughAlgParams {
+    e_FmPcdPlcrRateMode              rateMode;                       /**< Byte / Packet */
+    t_FmPcdPlcrByteRateModeParams    byteModeParams;                 /**< Valid for Byte NULL for Packet */
+    uint32_t                         comittedInfoRate;               /**< KBits/Sec or Packets/Sec */
+    uint32_t                         comittedBurstSize;              /**< KBits or Packets */
+    uint32_t                         peakOrAccessiveInfoRate;        /**< KBits/Sec or Packets/Sec */
+    uint32_t                         peakOrAccessiveBurstSize;       /**< KBits or Packets */
+} t_FmPcdPlcrNonPassthroughAlgParams;
+
+/**************************************************************************//**
+ @Description   A union for defining Policer next engine parameters
+*//***************************************************************************/
+typedef union u_FmPcdPlcrNextEngineParams {
+        e_FmPcdPlcrDoneAction           action;             /**< Action - when next engine is BMI (done) */
+        t_Handle                        h_Profile;          /**< Policer profile handle -  used when next engine
+                                                                 is PLCR, must be a SHARED profile */
+        t_Handle                        h_DirectScheme;     /**< Direct scheme select - when next engine is Keygen */
+} u_FmPcdPlcrNextEngineParams;
+
+/**************************************************************************//**
+ @Description   A structure for selcting the policer profile entry parameters
+*//***************************************************************************/
+typedef struct t_FmPcdPlcrProfileParams {
+    bool                                modify;                     /**< TRUE to change an existing profile */
+    union {
+        struct {
+            e_FmPcdProfileTypeSelection profileType;                /**< Type of policer profile */
+            t_Handle                    h_FmPort;                   /**< Relevant for per-port profiles only */
+            uint16_t                    relativeProfileId;          /**< Profile id - relative to shared group or to port */
+        } newParams;                                                /**< use it when modify=FALSE */
+        t_Handle                        h_Profile;                  /***< A handle to a profile - use it when modify=TRUE */
+    } id;
+    e_FmPcdPlcrAlgorithmSelection       algSelection;               /**< Profile Algoritem PASS_THROUGH, RFC_2698, RFC_4115 */
+    e_FmPcdPlcrColorMode                colorMode;                  /**< COLOR_BLIND, COLOR_AWARE */
+
+    union {
+        e_FmPcdPlcrColor                dfltColor;                  /**< For Color-Blind Pass-Through mode. the policer will re-color
+                                                                         any incoming packet with the default value. */
+        e_FmPcdPlcrColor                override;                   /**< For Color-Aware modes. The profile response to a
+                                                                         pre-color value of 2b11. */
+    } color;
+
+    t_FmPcdPlcrNonPassthroughAlgParams  nonPassthroughAlgParams;    /**< RFC2698 or RFC4115 params */
+
+    e_FmPcdEngine                       nextEngineOnGreen;          /**< Green next engine type */
+    u_FmPcdPlcrNextEngineParams         paramsOnGreen;              /**< Green next engine params */
+
+    e_FmPcdEngine                       nextEngineOnYellow;         /**< Yellow next engine type */
+    u_FmPcdPlcrNextEngineParams         paramsOnYellow;             /**< Yellow next engine params */
+
+    e_FmPcdEngine                       nextEngineOnRed;            /**< Red next engine type */
+    u_FmPcdPlcrNextEngineParams         paramsOnRed;                /**< Red next engine params */
+
+    bool                                trapProfileOnFlowA;         /**< Trap on flow A */
+    bool                                trapProfileOnFlowB;         /**< Trap on flow B */
+    bool                                trapProfileOnFlowC;         /**< Trap on flow C */
+} t_FmPcdPlcrProfileParams;
+
+
+/**************************************************************************//**
+ @Function      FM_PCD_SetNetEnvCharacteristics
+
+ @Description   Define a set of Network Environment Charecteristics.
+                When setting an environment it is important to understand its
+                application. It is not meant to describe the flows that will run
+                on the ports using this environment, but what the user means TO DO
+                with the PCD mechanisms in order to parse-classify-distribute those
+                frames.
+                By specifying a distinction unit, the user means it would use that option
+                for distinction between frames at either a keygen scheme keygen or a coarse
+                classification action descriptor. Using interchangeable headers to define a
+                unit means that the user is indifferent to which of the interchangeable
+                headers is present in the frame, and they want the distinction to be based
+                on the presence of either one of them.
+                Depending on context, there are limitations to the use of environments. A
+                port using the PCD functionality is bound to an environment. Some or even
+                all ports may share an environment but also an environment per port is
+                possible. When initializing a scheme, a classification plan group (see below),
+                or a coarse classification tree, one of the initialized environments must be
+                stated and related to. When a port is bound to a scheme, a classification
+                plan group, or a coarse classification tree, it MUST be bound to the same
+                environment.
+                The different PCD modules, may relate (for flows definition) ONLY on
+                distinction units as defined by their environment. When initializing a
+                scheme for example, it may not choose to select IPV4 as a match for
+                recognizing flows unless it was defined in the relating environment. In
+                fact, to guide the user through the configuration of the PCD, each module's
+                characterization in terms of flows is not done using protocol names, but using
+                environment indexes.
+                In terms of HW implementation, the list of distinction units sets the LCV vectors
+                and later used for match vector, classification plan vectors and coarse classification
+                indexing.
+
+ @Param[in]     h_FmPcd         FM PCD module descriptor.
+ @Param[in]     p_NetEnvParams  A structure of parameters for the initialization of
+                                the network environment.
+
+ @Return        A handle to the initialized object on success; NULL code otherwise.
+
+ @Cautions      Allowed only following PCD_Init().
+*//***************************************************************************/
+t_Handle FM_PCD_SetNetEnvCharacteristics(t_Handle h_FmPcd, t_FmPcdNetEnvParams *p_NetEnvParams);
+
+/**************************************************************************//**
+ @Function      FM_PCD_DeleteNetEnvCharacteristics
+
+ @Description   Deletes a set of Network Environment Charecteristics.
+
+ @Param[in]     h_FmPcd         FM PCD module descriptor.
+ @Param[in]     h_NetEnv        A handle to the Network environment.
+
+ @Return        E_OK on success; Error code otherwise.
+*//***************************************************************************/
+t_Error FM_PCD_DeleteNetEnvCharacteristics(t_Handle h_FmPcd, t_Handle h_NetEnv);
+
+/**************************************************************************//**
+ @Function      FM_PCD_KgSetClsPlanGrp
+
+ @Description   Define a classification plan group..
+                A classification plan group is a set of classification plan
+                entries consisting of a number of protocol options (as listed
+                in HW spec), that is a subset of a previously defined environment,
+                and that is relevant for one or more ports that will use that
+                same environment.
+                By specifying an option, the application means it would use that
+                option for distinction between frames at either a keygen scheme
+                keygen or a coarse classification action descriptor.
+                When RX ports that want to use the classification plan mechanism
+                are initialized, they will be bound to a classification plan
+                group. Usage of the classification plan is optional.
+                If not all ports use classification plan, it is user's responsibility
+                to declare that by calling FM_PCD_KgSetEmptyClsPlanGrp. The driver
+                will then allocate a minimal number of entries for that use, and all
+                ports that do not use the classification plan mechanism will
+                be internally bound to that empty group.
+
+ @Param[in]     h_FmPcd         A handle to an FM PCD Module.
+ @Param[in]     p_GrpParams     A structure of classification plan parameters.
+
+ @Return        A handle to the initialized object on success; NULL code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_Init().
+*//***************************************************************************/
+t_Handle FM_PCD_KgSetClsPlanGrp(t_Handle h_FmPcd, t_FmPcdKgClsPlanGrpParams *p_GrpParams);
+
+/**************************************************************************//**
+ @Function      FM_PCD_KgDeleteClsPlanGrp
+
+ @Description   Delete classification plan by writing reset value (0xFFFFFFFF)
+                to it - pass all LCV bits.
+
+ @Param[in]     h_FmPcd         A handle to an FM PCD Module.
+ @Param[in]     h_ClsPlanGrp    a handle to an classification-plan-group.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_Init().
+*//***************************************************************************/
+t_Error FM_PCD_KgDeleteClsPlanGrp(t_Handle h_FmPcd, t_Handle h_ClsPlanGrp);
+
+/**************************************************************************//**
+ @Function      FM_PCD_KgSetScheme
+
+ @Description   Initializing or modifying and enabling a scheme for the keygen.
+                This routine should be called for adding or modifying a scheme.
+                When a scheme needs modifying, the API requires that it will be
+                rewritten. In such a case 'modify' should be TRUE. If the
+                routine is called for a valid scheme and 'modify' is FALSE,
+                it will return error.
+
+ @Param[in]     h_FmPcd         A handle to an FM PCD Module.
+ @Param[in,out] p_Scheme        A structure of parameters for defining the scheme
+
+ @Return        A handle to the initialized scheme on success; NULL code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_Init().
+*//***************************************************************************/
+t_Handle FM_PCD_KgSetScheme (t_Handle                h_FmPcd,
+                             t_FmPcdKgSchemeParams   *p_Scheme);
+
+/**************************************************************************//**
+ @Function      FM_PCD_KgDeleteScheme
+
+ @Description   Deleting an initialized scheme.
+
+ @Param[in]     h_FmPcd         A handle to an FM PCD Module.
+ @Param[in]     h_Scheme        scheme handle as returned by FM_PCD_KgSetScheme
+
+ @Return        E_OK on success; Error code otherwise.
+ @Cautions      Allowed only following FM_PCD_Init().
+*//***************************************************************************/
+t_Error     FM_PCD_KgDeleteScheme(t_Handle h_FmPcd, t_Handle h_Scheme);
+
+/**************************************************************************//**
+ @Function      FM_PCD_KgGetSchemeCounter
+
+ @Description   Reads scheme packet counter.
+
+ @Param[in]     h_FmPcd         FM PCD module descriptor.
+ @Param[in]     h_Scheme        scheme handle as returned by FM_PCD_KgSetScheme.
+
+ @Return        Counter's current value.
+
+ @Cautions      Allowed only following FM_PCD_Init().
+*//***************************************************************************/
+uint32_t  FM_PCD_KgGetSchemeCounter(t_Handle h_FmPcd, t_Handle h_Scheme);
+
+/**************************************************************************//**
+ @Function      FM_PCD_KgSetSchemeCounter
+
+ @Description   Writes scheme packet counter.
+
+ @Param[in]     h_FmPcd         FM PCD module descriptor.
+ @Param[in]     h_Scheme        scheme handle as returned by FM_PCD_KgSetScheme.
+ @Param[in]     value           New scheme counter value - typically '0' for
+                                resetting the counter.
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_Init().
+*//***************************************************************************/
+t_Error  FM_PCD_KgSetSchemeCounter(t_Handle h_FmPcd, t_Handle h_Scheme, uint32_t value);
+
+/**************************************************************************//**
+ @Function      FM_PCD_CcBuildTree
+
+ @Description   This routine must be called to define a complete coarse
+                classification tree. This is the way to define coarse
+                classification to a certain flow - the keygen schemes
+                may point only to trees defined in this way.
+
+ @Param[in]     h_FmPcd                 FM PCD module descriptor.
+ @Param[in]     p_FmPcdCcTreeParams     A structure of parameters to define the tree.
+
+ @Return        A handle to the initialized object on success; NULL code otherwise.
+
+ @Cautions      Allowed only following PCD_Init().
+*//***************************************************************************/
+t_Handle FM_PCD_CcBuildTree (t_Handle             h_FmPcd,
+                             t_FmPcdCcTreeParams  *p_FmPcdCcTreeParams);
+
+/**************************************************************************//**
+ @Function      FM_PCD_CcDeleteTree
+
+ @Description   Deleting an built tree.
+
+ @Param[in]     h_FmPcd         A handle to an FM PCD Module.
+ @Param[in]     h_CcTree        A handle to a CC tree.
+
+ @Cautions      Allowed only following FM_PCD_Init().
+*//***************************************************************************/
+t_Error FM_PCD_CcDeleteTree(t_Handle h_FmPcd, t_Handle h_CcTree);
+
+/**************************************************************************//**
+ @Function      FM_PCD_CcSetNode
+
+ @Description   This routine should be called for each CC (coarse classification)
+                node. The whole CC tree should be built bottom up so that each
+                node points to already defined nodes.
+
+ @Param[in]     h_FmPcd             FM PCD module descriptor.
+ @Param[in]     p_CcNodeParam       A structure of parameters defining the CC node
+
+ @Return        A handle to the initialized object on success; NULL code otherwise.
+
+ @Cautions      Allowed only following PCD_Init().
+*//***************************************************************************/
+t_Handle   FM_PCD_CcSetNode(t_Handle             h_FmPcd,
+                            t_FmPcdCcNodeParams  *p_CcNodeParam);
+
+/**************************************************************************//**
+ @Function      FM_PCD_CcDeleteNode
+
+ @Description   Deleting an built node.
+
+ @Param[in]     h_FmPcd         A handle to an FM PCD Module.
+ @Param[in]     h_CcNode        A handle to a CC node.
+
+ @Cautions      Allowed only following FM_PCD_Init().
+*//***************************************************************************/
+t_Error FM_PCD_CcDeleteNode(t_Handle h_FmPcd, t_Handle h_CcNode);
+
+/**************************************************************************//**
+ @Function      FM_PCD_CcTreeModifyNextEngine
+
+ @Description   Modify the Next Engine Parameters in the entry of the tree.
+
+ @Param[in]     h_FmPcd                     A handle to an FM PCD Module.
+ @Param[in]     h_CcTree                    A handle to the tree
+ @Param[in]     grpId                       A Group index in the tree
+ @Param[in]     index                       Entry index in the group defined by grpId
+ @Param[in]     p_FmPcdCcNextEngineParams   A structure for defining new next engine params
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_CcBuildTree().
+*//***************************************************************************/
+t_Error FM_PCD_CcTreeModifyNextEngine(t_Handle h_FmPcd, t_Handle h_CcTree, uint8_t grpId, uint8_t index, t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams);
+
+/**************************************************************************//**
+ @Function      FM_PCD_CcNodeModifyNextEngine
+
+ @Description   Modify the Next Engine Parameters in the relevent key entry of the node.
+
+ @Param[in]     h_FmPcd                     A handle to an FM PCD Module.
+ @Param[in]     h_CcNode                    A handle to the node
+ @Param[in]     keyIndex                    Key index for Next Engine Params modifications
+ @Param[in]     p_FmPcdCcNextEngineParams   A structure for defining new next engine params
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_CcSetNode().
+*//***************************************************************************/
+t_Error FM_PCD_CcNodeModifyNextEngine(t_Handle h_FmPcd, t_Handle h_CcNode, uint8_t keyIndex, t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams);
+
+/**************************************************************************//**
+ @Function      FM_PCD_CcNodeModifyMissNextEngine
+
+ @Description   Modify the Next Engine Parameters of the Miss key case of the node.
+
+ @Param[in]     h_FmPcd                     A handle to an FM PCD Module.
+ @Param[in]     h_CcNode                    A handle to the node
+ @Param[in]     p_FmPcdCcNextEngineParams   A structure for defining new next engine params
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_CcSetNode().
+*//***************************************************************************/
+t_Error FM_PCD_CcNodeModifyMissNextEngine(t_Handle h_FmPcd, t_Handle h_CcNode, t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams);
+
+/**************************************************************************//**
+ @Function      FM_PCD_CcNodeRemoveKey
+
+ @Description   Remove the key (include Next Engine Parameters of this key) defined by the index of the relevant node .
+
+ @Param[in]     h_FmPcd                     A handle to an FM PCD Module.
+ @Param[in]     h_CcNode                    A handle to the node
+ @Param[in]     keyIndex                    Key index for removing
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_CcSetNode() not only of the relevnt node but also
+                the node that points to this node
+*//***************************************************************************/
+t_Error FM_PCD_CcNodeRemoveKey(t_Handle h_FmPcd, t_Handle h_CcNode, uint8_t keyIndex);
+
+/**************************************************************************//**
+ @Function      FM_PCD_CcNodeAddKey
+
+ @Description   Add the key(include Next Engine Parameters of this key)in the index defined by the keyIndex .
+
+ @Param[in]     h_FmPcd                     A handle to an FM PCD Module.
+ @Param[in]     h_CcNode                    A handle to the node
+ @Param[in]     keyIndex                    Key index for adding
+ @Param[in]     keySize                     Key size of added key
+ @Param[in]     p_KeyParams                 A pointer to the parametrs includes new key with Next Engine Parameters
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_CcSetNode() not only of the relevnt node but also
+                the node that points to this node
+*//***************************************************************************/
+t_Error FM_PCD_CcNodeAddKey(t_Handle h_FmPcd, t_Handle h_CcNode, uint8_t keyIndex, uint8_t keySize, t_FmPcdCcKeyParams  *p_KeyParams);
+
+/**************************************************************************//**
+ @Function      FM_PCD_CcNodeModifyKeyAndNextEngine
+
+ @Description   Modify the key and Next Engine Parameters of this key in the index defined by the keyIndex .
+
+ @Param[in]     h_FmPcd                     A handle to an FM PCD Module.
+ @Param[in]     h_CcNode                    A handle to the node
+ @Param[in]     keyIndex                    Key index for adding
+ @Param[in]     keySize                     Key size of added key
+ @Param[in]     p_KeyParams                 A pointer to the parametrs includes modified key and modified Next Engine Parameters
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_CcSetNode() not only of the relevnt node but also
+                the node that points to this node
+*//***************************************************************************/
+t_Error FM_PCD_CcNodeModifyKeyAndNextEngine(t_Handle h_FmPcd, t_Handle h_CcNode, uint8_t keyIndex, uint8_t keySize, t_FmPcdCcKeyParams  *p_KeyParams);
+
+/**************************************************************************//**
+ @Function      FM_PCD_CcNodeModifyKey
+
+ @Description   Modify the key  in the index defined by the keyIndex .
+
+ @Param[in]     h_FmPcd                     A handle to an FM PCD Module.
+ @Param[in]     h_CcNode                    A handle to the node
+ @Param[in]     keyIndex                    Key index for adding
+ @Param[in]     keySize                     Key size of added key
+ @Param[in]     p_Key                       A pointer to the new key
+ @Param[in]     p_Mask                      A pointer to the new mask if relevnt, otherwise pointer to NULL
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_CcSetNode() not only of the relevnt node but also
+                the node that points to this node
+*//***************************************************************************/
+t_Error FM_PCD_CcNodeModifyKey(t_Handle h_FmPcd, t_Handle h_CcNode, uint8_t keyIndex, uint8_t keySize, uint8_t  *p_Key, uint8_t *p_Mask);
+
+/**************************************************************************//**
+ @Function      FM_PCD_PlcrSetProfile
+
+ @Description   Sets a profile entry in the policer profile table.
+                The routine overrides any existing value.
+
+ @Param[in]     h_FmPcd           A handle to an FM PCD Module.
+ @Param[in]     p_Profile         A structure of parameters for defining a
+                                  policer profile entry.
+
+ @Return        A handle to the initialized object on success; NULL code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_Init().
+*//***************************************************************************/
+t_Handle FM_PCD_PlcrSetProfile(t_Handle                  h_FmPcd,
+                               t_FmPcdPlcrProfileParams  *p_Profile);
+
+/**************************************************************************//**
+ @Function      FM_PCD_PlcrDeleteProfile
+
+ @Description   Delete a profile entry in the policer profile table.
+                The routine set entry to invalid.
+
+ @Param[in]     h_FmPcd         A handle to an FM PCD Module.
+ @Param[in]     h_Profile       A handle to the profile.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_Init().
+*//***************************************************************************/
+t_Error FM_PCD_PlcrDeleteProfile(t_Handle h_FmPcd, t_Handle h_Profile);
+
+/**************************************************************************//**
+ @Function      FM_PCD_PlcrGetProfileCounter
+
+ @Description   Sets an entry in the classification plan.
+                The routine overrides any existing value.
+
+ @Param[in]     h_FmPcd             A handle to an FM PCD Module.
+ @Param[in]     h_Profile       A handle to the profile.
+ @Param[in]     counter             Counter selector.
+
+ @Return        specific counter value.
+
+ @Cautions      Allowed only following FM_PCD_Init().
+*//***************************************************************************/
+uint32_t FM_PCD_PlcrGetProfileCounter(t_Handle h_FmPcd, t_Handle h_Profile, e_FmPcdPlcrProfileCounters counter);
+
+/**************************************************************************//**
+ @Function      FM_PCD_PlcrSetProfileCounter
+
+ @Description   Sets an entry in the classification plan.
+                The routine overrides any existing value.
+
+ @Param[in]     h_FmPcd         A handle to an FM PCD Module.
+ @Param[in]     h_Profile       A handle to the profile.
+ @Param[in]     counter         Counter selector.
+ @Param[in]     value           value to set counter with.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_Init().
+*//***************************************************************************/
+t_Error FM_PCD_PlcrSetProfileCounter(t_Handle h_FmPcd, t_Handle h_Profile, e_FmPcdPlcrProfileCounters counter,    uint32_t value);
+
+/** @} */ /* end of FM_PCD_Runtime_tree_buildgrp group */
+/** @} */ /* end of FM_PCD_Runtime_grp group */
+/** @} */ /* end of FM_PCD_grp group */
+/** @} */ /* end of FM_grp group */
+
+#endif /* __FM_PCD_EXT */
diff --git a/drivers/net/dpa/NetCommSw/inc/Peripherals/fm_port_ext.h b/drivers/net/dpa/NetCommSw/inc/Peripherals/fm_port_ext.h
new file mode 100644
index 0000000..44c334e
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/inc/Peripherals/fm_port_ext.h
@@ -0,0 +1,1889 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**************************************************************************//**
+ @File          fm_port_ext.h
+
+ @Description   FM-Port Application Programming Interface.
+*//***************************************************************************/
+#ifndef __FM_PORT_EXT
+#define __FM_PORT_EXT
+
+#include "error_ext.h"
+#include "std_ext.h"
+#include "fm_pcd_ext.h"
+#include "fm_ext.h"
+#include "net_ext.h"
+
+
+/**************************************************************************//**
+ @Group         FM_grp Frame Manager API
+
+ @Description   FM API functions, definitions and enums
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Group         FM_PORT_grp FM Port
+
+ @Description   FM Port API
+
+                The FM uses a general module called "port" to represent a Tx port
+                (MAC), an Rx port (MAC), offline parsing flow or host command
+                flow. There may be up to 17 (may change) ports in an FM - 5 Tx
+                ports (4 for the 1G MACs, 1 for the 10G MAC), 5 Rx Ports, and 7
+                Host command/Offline parsing ports. The SW driver manages these
+                ports as sub-modules of the FM, i.e. after an FM is initialized,
+                its ports may be initialized and operated upon.
+
+                The port is initialized aware of its type, but other functions on
+                a port may be indifferent to its type. When necessary, the driver
+                verifies coherency and returns error if applicable.
+
+                On initialization, user specifies the port type and it's index
+                (relative to the port's type). Host command and Offline parsing
+                ports share the same id range, I.e user may not initialized host
+                command port 0 and offline parsing port 0.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description   An enum for defining port PCD modes.
+                This enum defines the superset of PCD engines support - i.e. not
+                all engines have to be used, but all have to be enabled. The real
+                flow of a specific frame depends on the PCD configuration and the
+                frame headers and payload.
+*//***************************************************************************/
+typedef enum e_FmPortPcdSupport {
+    e_FM_PORT_PCD_SUPPORT_NONE,                 /**< BMI to BMI, PCD is not used */
+    e_FM_PORT_PCD_SUPPORT_PRS_ONLY,             /**< Use only Parser */
+    e_FM_PORT_PCD_SUPPORT_PLCR_ONLY,            /**< Use only Policer */
+    e_FM_PORT_PCD_SUPPORT_PRS_AND_PLCR,         /**< Use Parser and Policer */
+    e_FM_PORT_PCD_SUPPORT_PRS_AND_KG,           /**< Use Parser and Keygen */
+    e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC,    /**< Use Parser, Keygen and Coarse Classification */
+    e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC_AND_PLCR, /**< Use all PCD engines */
+    e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_PLCR   /**< Use Parser, Keygen and Policer */
+} e_FmPortPcdSupport;
+
+/**************************************************************************//**
+ @Collection    General FM Port defines
+*//***************************************************************************/
+#define PRS_RESULT_NUM_OF_WORDS             8           /**< Number of 4 bytes words in parser result */
+#define FM_PORT_MAX_NUM_OF_EXT_POOLS        8           /**< Number of external BM pools per Rx port */
+#define MAX_NUM_OF_EXT_POOLS                64          /**< Total number of external BM pools */
+#define FM_PORT_NUM_OF_CONGESTION_GRPS      256         /**< Total number of congestion groups in QM */
+/* @} */
+
+
+/**************************************************************************//**
+ @Group         FM_PORT_init_grp FM Port Initialization Unit
+
+ @Description   FM Port Initialization Unit
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description   User callback function called by driver with recieve data.
+
+                User provides this function. Driver invokes it.
+
+ @Param[in]     h_App       Application's handle originally specified to
+                            the API Config function
+ @Param[in]     p_Data      A pointer to data received
+ @Param[in]     length      length of received data
+ @Param[in]     status      receive status and errors
+ @Param[in]     position    position of buffer in frame
+ @Param[in]     h_UserPriv  A handle of the user acossiated with this buffer
+ *//***************************************************************************/
+typedef void (t_FmPortImRxStoreFunction) (t_Handle h_App,
+                                          uint8_t  *p_Data,
+                                          uint16_t length,
+                                          uint16_t status,
+                                          uint8_t  position,
+                                          t_Handle h_UserPriv);
+
+/**************************************************************************//**
+ @Description   User callback function called by driver when transmit completed.
+
+                User provides this function. Driver invokes it.
+
+ @Param[in]     h_App       Application's handle originally specified to
+                            the API Config function
+ @Param[in]     p_Data      A pointer to data received
+ @Param[in]     status      transmit status and errors
+ @Param[in]     lastBuffer  is last buffer in frame
+ @Param[in]     h_UserPriv  A handle of the user acossiated with this buffer
+ *//***************************************************************************/
+typedef void (t_FmPortImTxConfFunction) (t_Handle   h_App,
+                                         uint8_t    *p_Data,
+                                         uint16_t   status,
+                                         t_Handle   h_UserPriv);
+
+/**************************************************************************//**
+ @Description   A structure of information about each of the external
+                buffer pools used by the port,
+*//***************************************************************************/
+typedef struct t_FmPortExtPoolParams {
+    uint8_t                 id;                 /**< External buffer pool id */
+    uint16_t                size;               /**< External buffer pool buffer size */
+} t_FmPortExtPoolParams;
+
+/**************************************************************************//**
+ @Description   A structure for informing the driver about the external
+                buffer pools allocated in the BM and used by this port.
+*//***************************************************************************/
+typedef struct t_FmPortRxExtPools {
+    uint8_t                 numOfPoolsUsed;     /**< Number of pools use by this port */
+    t_FmPortExtPoolParams   rxExtBufPool[FM_PORT_MAX_NUM_OF_EXT_POOLS];
+                                                /**< Parameters for each port */
+} t_FmPortRxExtPools;
+
+/**************************************************************************//**
+ @Description   structure for additional Rx port parameters
+*//***************************************************************************/
+typedef struct t_FmPortRxParams {
+    uint32_t                errFqid;            /**< Error Queue Id. */
+    uint32_t                dfltFqid;           /**< Default Queue Id.  */
+    uint8_t                 rxPartitionId;      /**< Port's partition id. */
+    t_FmPortRxExtPools      rxExtBufPools;      /**< Which external buffer pools are used
+                                                     (up to 8), and their sizes. */
+} t_FmPortRxParams;
+
+/**************************************************************************//**
+ @Description   structure for additional non-Rx port parameters
+*//***************************************************************************/
+typedef struct t_FmPortNonRxParams {
+    uint32_t                errFqid;            /**< Error Queue Id. */
+    uint32_t                dfltFqid;           /**< For Tx and HC - Default Confirmation queue,
+                                                     0 means no Tx confirmation for processed
+                                                     frames. For OP - default Rx queue. */
+    uint8_t                 deqSubPortal;       /**< Subportal for dequeue. */
+#ifdef FM_OP_PARTITION_ERRATA
+    uint8_t                 opPartitionId;      /**< For Offline Parsing ports only. Port's partition id. */
+#endif  /* FM_OP_PARTITION_ERRATA */
+} t_FmPortNonRxParams;
+
+/**************************************************************************//**
+ @Description   structure for additional Rx port parameters
+*//***************************************************************************/
+typedef struct t_FmPortImRxTxParams {
+    t_Handle                    h_FmMuram;          /**< A handle of the FM-MURAM partition */
+    uint8_t                     partitionId;        /**< For Rx ports only. Port's partition id. */
+    uint8_t                     dataMemId;          /**< Memory partition ID for data buffers */
+    uint32_t                    dataMemAttributes;  /**< Memory attributes for data buffers */
+    t_BufferPoolInfo            rxPoolParams;       /**< For Rx ports only. */
+    t_FmPortImRxStoreFunction   *f_RxStoreCB;       /**< For Rx ports only. */
+    t_FmPortImTxConfFunction    *f_TxConfCB;        /**< For Tx ports only. */
+    t_Handle                    h_App;              /**< A handle to an application layer object; This handle will
+                                                         be passed by the driver upon calling the above callbacks */
+} t_FmPortImRxTxParams;
+
+/**************************************************************************//**
+ @Description   Union for additional parameters depending on port type
+*//***************************************************************************/
+typedef union u_FmPortSpecificParams {
+    t_FmPortImRxTxParams    imRxTxParams;       /**< Rx/Tx Independent-Mode port parameter structure */
+    t_FmPortRxParams        rxParams;           /**< Rx port parameters structure */
+    t_FmPortNonRxParams     nonRxParams;        /**< Non-Rx port parameters structure */
+} u_FmPortSpecificParams;
+
+/**************************************************************************//**
+ @Description   structure representing FM initialization parameters
+*//***************************************************************************/
+typedef struct t_FmPortParams {
+    uint64_t                baseAddr;           /**< Virtual Address of memory mapped FM Port registers.*/
+    t_Handle                h_Fm;               /**< A handle to the FM object this port related to */
+    e_FmPortType            portType;           /**< Port type */
+    uint8_t                 portId;             /**< Port Id - relative to type */
+    bool                    independentModeEnable;  /**< This port is Independent-Mode - Used for Rx/Tx ports only! */
+    u_FmPortSpecificParams  specificParams;     /**< Additional parameters depending on port
+                                                     type. */
+} t_FmPortParams;
+
+
+/**************************************************************************//**
+ @Function      FM_PORT_Config
+
+ @Description   Creates descriptor for the FM PORT module.
+
+                The routine returns a handle (descriptor) to the FM PORT object.
+                This descriptor must be passed as first parameter to all other
+                FM PORT function calls.
+
+                No actual initialization or configuration of FM hardware is
+                done by this routine.
+
+ @Param[in]     p_FmPortParams   - Pointer to data structure of parameters
+
+ @Retval        Handle to FM object, or NULL for Failure.
+*//***************************************************************************/
+t_Handle FM_PORT_Config(t_FmPortParams *p_FmPortParams);
+
+/**************************************************************************//**
+ @Function      FM_PORT_Init
+
+ @Description   Initializes the FM PORT module
+
+ @Param[in]     h_FmPort - FM PORT module descriptor
+
+ @Return        E_OK on success; Error code otherwise.
+*//***************************************************************************/
+t_Error FM_PORT_Init(t_Handle h_FmPort);
+
+/**************************************************************************//**
+ @Function      FM_PORT_Free
+
+ @Description   Frees all resources that were assigned to FM PORT module.
+
+                Calling this routine invalidates the descriptor.
+
+ @Param[in]     h_FmPort - FM PORT module descriptor
+
+ @Return        E_OK on success; Error code otherwise.
+*//***************************************************************************/
+t_Error FM_PORT_Free(t_Handle h_FmPort);
+
+
+/**************************************************************************//**
+ @Group         FM_PORT_advanced_init_grp    FM Port Advanced Configuration Unit
+
+ @Description   Configuration functions used to change default values.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description   enum for defining QM frame dequeue
+*//***************************************************************************/
+typedef enum e_FmPortDeqType {
+   e_FM_PORT_DEQ_TYPE1,             /**< Dequeue from the SP channel - with priority precedence,
+                                         and Intra-Class Scheduling respected. */
+   e_FM_PORT_DEQ_TYPE2,             /**< Dequeue from the SP channel - with active FQ precedence,
+                                         and Intra-Class Scheduling respected. */
+   e_FM_PORT_DEQ_TYPE3              /**< Dequeue from the SP channel - with active FQ precedence,
+                                         and override Intra-Class Scheduling */
+} e_FmPortDeqType;
+
+/**************************************************************************//**
+ @Description   enum for defining QM frame dequeue
+*//***************************************************************************/
+typedef enum e_FmPortDeqPrefetchOption {
+   e_FM_PORT_DEQ_NO_PREFETCH,       /**< QMI preforms a dequeue action for a single frame
+                                         only when a dedicated portID Tnum is waiting. */
+   e_FM_PORT_DEQ_PARTIAL_PREFETCH,  /**< QMI preforms a dequeue action for 3 frames when
+                                         one dedicated portId tnum is waiting. */
+   e_FM_PORT_DEQ_FULL_PREFETCH      /**< QMI preforms a dequeue action for 3 frames when
+                                         no dedicated portId tnums are waiting. */
+
+} e_FmPortDeqPrefetchOption;
+
+/**************************************************************************//**
+ @Description   enum for defining port DMA swap mode
+*//***************************************************************************/
+typedef enum e_FmPortDmaSwap {
+    e_FM_PORT_DMA_NO_SWP,           /**< No swap, transfer data as is.*/
+    e_FM_PORT_DMA_SWP_PPC_LE,       /**< The transferred data should be swapped
+                                         in PowerPc Little Endian mode. */
+    e_FM_PORT_DMA_SWP_BE            /**< The transferred data should be swapped
+                                         in Big Endian mode */
+} e_FmPortDmaSwap;
+
+/**************************************************************************//**
+ @Description   enum for defining port DMA cache attributes
+*//***************************************************************************/
+typedef enum e_FmPortDmaCache {
+    e_FM_PORT_DMA_NO_STASH,         /**< Cacheable, no Allocate (No Stashing) */
+    e_FM_PORT_DMA_STASH             /**< Cacheable and Allocate (Stashing on) */
+} e_FmPortDmaCache;
+
+/**************************************************************************//**
+ @Description   enum for defining port default color
+*//***************************************************************************/
+typedef enum e_FmPortColor {
+    e_FM_PORT_COLOR_GREEN,          /**< Default port color is green */
+    e_FM_PORT_COLOR_YELLOW,         /**< Default port color is yellow */
+    e_FM_PORT_COLOR_RED,            /**< Default port color is red */
+    e_FM_PORT_COLOR_OVERRIDE        /**< Ignore color */
+} e_FmPortColor;
+
+/**************************************************************************//**
+ @Description   struct for defining FM port resources
+*//***************************************************************************/
+typedef struct t_FmPortRsrc {
+    uint32_t    num;                /**< Commited required resource */
+    uint32_t    extra;              /**< Extra (not commited) required resource */
+} t_FmPortRsrc;
+
+/**************************************************************************//**
+ @Description   struct for defining pool depeltion criteria
+*//***************************************************************************/
+typedef struct t_FmPortBufPoolDepletion {
+    bool        numberOfPoolsModeEnable;            /**< select mode in which pause frames will be sent after
+                                                         a number of pools are depleted */
+    uint8_t     numOfPools;                         /**< the minimum number of depleted pools that will
+                                                         invoke pause frames transmission. */
+    bool        poolsToConsider[MAX_NUM_OF_EXT_POOLS];
+                                                    /**< For each pool, TRUE if it should be considered for
+                                                         deplition (Note - this pool must be used by this port!) */
+    bool        singlePoolModeEnable;               /**< select mode in which pause frames will be sent after
+                                                         a single of pools are depleted */
+    bool        poolsToConsiderForSingleMode[MAX_NUM_OF_EXT_POOLS];
+                                                    /**< For each pool, TRUE if it should be considered for
+                                                         deplition (Note - this pool must be used by this port!) */
+} t_FmPortBufPoolDepletion;
+
+/**************************************************************************//**
+ @Description   struct for defining Tx rate limiting
+*//***************************************************************************/
+typedef struct t_FmPortRateLimit {
+    uint16_t    maxBurstSize;           /**< in KBytes */
+    uint32_t    rateLimit;              /**< in Kb/sec for Tx ports, in frame/sec for
+                                             offline parsing ports. Rate limit will
+                                             be rounded down to the nearest
+                                             16*TimeStampPeriod multiplication. */
+} t_FmPortRateLimit;
+
+/**************************************************************************//**
+ @Description   struct for defining define the parameters of
+                the Rx port performance counters
+*//***************************************************************************/
+typedef struct t_FmPortPerformanceCnt {
+    uint8_t     taskCompVal;            /**< Task compare value */
+    uint8_t     queueCompVal;           /**< Rx queue/Tx confirm queue compare
+                                             value (unused for H/O) */
+    uint8_t     dmaCompVal;             /**< Dma compare value */
+    uint32_t    fifoCompVal;            /**< Fifo compare value */
+} t_FmPortPerformanceCnt;
+
+/**************************************************************************//**
+ @Description   struct for defining buffer content.
+*//***************************************************************************/
+typedef struct t_FmPortBufferPrefixContent {
+    uint16_t    privDataSize;               /**< Number of bytes to be left at the beginning
+                                                 of the external buffer */
+    bool        passPrsResult;              /**< TRUE to pass the parse result to/from the FM */
+    bool        passTimeStamp;              /**< TRUE to pass the timeStamp to/from the FM */
+} t_FmPortBufferPrefixContent;
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigNumOfOpenDmas
+
+ @Description   Calling this routine changes the number of open DMA requested for
+                this port in the internal driver data base from its default configuration.
+
+
+                May be used for all port types.
+
+ @Param[in]     h_FmPort            A handle to a FM Port module.
+ @Param[in]     p_NumOfOpenDmas     A structure of resource requested parameters
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigNumOfOpenDmas(t_Handle h_FmPort, t_FmPortRsrc *p_NumOfOpenDmas);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigNumOfTasks
+
+ @Description   Calling this routine changes the number of tasks requested for
+                this port in the internal driver data base from its default configuration.
+
+                May be used for all port types.
+
+ @Param[in]     h_FmPort            A handle to a FM Port module.
+ @Param[in]     p_NumOfTasks        A structure of resource requested parameters
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigNumOfTasks(t_Handle h_FmPort, t_FmPortRsrc *p_NumOfTasks);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigSizeOfFifo
+
+ @Description   Calling this routine changes the Fifo size requested for
+                this port in the internal driver data base from its default configuration.
+
+                May be used for all port types - note that only Rx has 'extra'
+                fifo size. For other ports 'extra' field must be disabled.
+
+ @Param[in]     h_FmPort            A handle to a FM Port module.
+ @Param[in]     p_SizeOfFifo        A structure of resource requested parameters
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigSizeOfFifo(t_Handle h_FmPort, t_FmPortRsrc *p_SizeOfFifo);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigDeqHighPriority
+
+ @Description   Calling this routine changes the dequeue priority in the
+                internal driver data base from its default configuration
+                [DEFAULT_PORT_deqHighPriority]
+
+
+
+                May be used for Non-Rx ports only
+
+ @Param[in]     h_FmPort    A handle to a FM Port module.
+ @Param[in]     highPri     TRUE to select high priority, FALSE for normal operation.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigDeqHighPriority(t_Handle h_FmPort, bool highPri);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigDeqType
+
+ @Description   Calling this routine changes the dequeue type parameter in the
+                internal driver data base from its default configuration
+                [DEFAULT_PORT_deqType].
+
+
+                May be used for Non-Rx ports only
+
+ @Param[in]     h_FmPort    A handle to a FM Port module.
+ @Param[in]     deqType     According to QM definition.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigDeqType(t_Handle h_FmPort, e_FmPortDeqType deqType);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigDeqPrefetchOption
+
+ @Description   Calling this routine changes the dequeue prefetch option parameter in the
+                internal driver data base from its default configuration
+                [DEFAULT_PORT_deqPrefetchOption]
+
+
+                May be used for Non-Rx ports only
+
+ @Param[in]     h_FmPort            A handle to a FM Port module.
+ @Param[in]     deqPrefetchOption   New option
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigDeqPrefetchOption(t_Handle h_FmPort, e_FmPortDeqPrefetchOption deqPrefetchOption);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigDeqByteCnt
+
+ @Description   Calling this routine changes the dequeue byte count parameter in
+                the internal driver data base from its default configuration [DEFAULT_PORT_deqByteCnt].
+
+                May be used for Non-Rx ports only
+
+ @Param[in]     h_FmPort        A handle to a FM Port module.
+ @Param[in]     deqByteCnt      New byte count
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigDeqByteCnt(t_Handle h_FmPort, uint16_t deqByteCnt);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigTxFifoMinFillLevel
+
+ @Description   Calling this routine changes the fifo minimum
+                fill level parameter in the internal driver data base
+                from its default configuration  [DEFAULT_PORT_txFifoMinFillLevel]
+
+                May be used for Tx ports only
+
+ @Param[in]     h_FmPort        A handle to a FM Port module.
+ @Param[in]     minFillLevel    New value
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigTxFifoMinFillLevel(t_Handle h_FmPort, uint32_t minFillLevel);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigTxFifoDeqPipelineDepth
+
+ @Description   Calling this routine changes the fifo dequeue
+                pipeline depth parameter in the internal driver data base
+
+                from its default configuration: 1G ports: [DEFAULT_PORT_txFifoDeqPipelineDepth_1G],
+                10G port: [DEFAULT_PORT_txFifoDeqPipelineDepth_10G]
+
+                May be used for Tx ports only
+
+ @Param[in]     h_FmPort            A handle to a FM Port module.
+ @Param[in]     deqPipelineDepth    New value
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigTxFifoDeqPipelineDepth(t_Handle h_FmPort, uint8_t deqPipelineDepth);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigTxFifoLowComfLevel
+
+ @Description   Calling this routine changes the fifo low comfort level
+                parameter in internal driver data base
+                from its default configuration  [DEFAULT_PORT_txFifoLowComfLevel]
+
+                May be used for Tx ports only
+
+ @Param[in]     h_FmPort            A handle to a FM Port module.
+ @Param[in]     fifoLowComfLevel    New value
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigTxFifoLowComfLevel(t_Handle h_FmPort, uint32_t fifoLowComfLevel);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigRxFifoThreshold
+
+ @Description   Calling this routine changes the threshold of the FIFO
+                fill level parameter in the internal driver data base
+                from its default configuration [DEFAULT_PORT_rxFifoThreshold]
+
+                If the total number of buffers which are
+                currently in use and associated with the
+                specific RX port exceed this threshold, the
+                BMI will signal the MAC to send a pause frame
+                over the link.
+
+                May be used for Rx ports only
+
+ @Param[in]     h_FmPort            A handle to a FM Port module.
+ @Param[in]     fifoThreshold       New value
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigRxFifoThreshold(t_Handle h_FmPort, uint32_t fifoThreshold);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigRxPriElevationLevel
+
+ @Description   Calling this routine changes the priority elevation level
+                parameter in the internal driver data base from its default
+                configuration  [DEFAULT_PORT_rxFifoPriElevationLevel]
+
+                If the total number of buffers which are currently
+                in use and associated with the specific RX
+                port exceed the amount specified in priElevationLevel,
+                BMI will signal the main FMs DMA to elivate
+                the FM priority on the system bus.
+
+                May be used for Rx ports only
+
+ @Param[in]     h_FmPort            A handle to a FM Port module.
+ @Param[in]     priElevationLevel   New value
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigRxPriElevationLevel(t_Handle h_FmPort, uint32_t priElevationLevel);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigBufferPrefixContent
+
+ @Description   Defines the structure, size and content of the application buffer.
+                The prefix will
+                In Tx ports, if 'passPrsResult', the application
+                should set a value to their offsets in the prefix of
+                the FM will save the first 'privDataSize', than,
+                depending on 'passPrsResult' and 'passTimeStamp', copy parse result
+                and timeStamp, and the packet itself (in this order), to the
+                application buffer, and to offset.
+                Calling this routine changes the buffer margins definitions
+                in the internal driver data base from its default
+                configuration: Data size:  [DEFAULT_PORT_bufferPrefixContent_privDataSize]
+                               Pass Parser result: [DEFAULT_PORT_bufferPrefixContent_passPrsResult].
+                               Pass timestamp: [DEFAULT_PORT_bufferPrefixContent_passTimeStamp].
+
+                May be used for all ports
+
+ @Param[in]     h_FmPort                        A handle to a FM Port module.
+ @Param[in,out] p_FmPortBufferPrefixContent     A structure of parameters describing the
+                                                structure of the buffer.
+                                                Out parameter: Start margin - offset
+                                                of data from start of external buffer.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigBufferPrefixContent(t_Handle h_FmPort, t_FmPortBufferPrefixContent *p_FmPortBufferPrefixContent);
+
+#ifdef VERIFICATION_SUPPORT
+t_Error FM_PORT_ConfigIntContent (t_Handle  h_FmPort,
+                                  uint8_t   intContextIntOffset,
+                                  uint16_t  intContextExtOffset,
+                                  uint16_t  intContextSize,
+                                  uint16_t  startMargins,
+                                  uint16_t  endMargins);
+#endif /* VERIFICATION_SUPPORT */
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigCheksumLastBytesIgnore
+
+ @Description   Calling this routine changes the number of checksum bytes to ignore
+                parameter in the internal driver data base from its default configuration
+                [DEFAULT_PORT_cheksumLastBytesIgnore]
+
+                May be used by Tx & Rx ports only
+
+ @Param[in]     h_FmPort                A handle to a FM Port module.
+ @Param[in]     cheksumLastBytesIgnore    New value
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigCheksumLastBytesIgnore(t_Handle h_FmPort, uint8_t cheksumLastBytesIgnore);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigCutBytesFromEnd
+
+ @Description   Calling this routine changes the number of bytes to cut from a
+                frame's end parameter in the internal driver data base
+                from its default configuration  [DEFAULT_PORT_cutBytesFromEnd]
+
+                May be used for Rx ports only
+
+ @Param[in]     h_FmPort            A handle to a FM Port module.
+ @Param[in]     cutBytesFromEnd     New value
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigCutBytesFromEnd(t_Handle h_FmPort, uint8_t cutBytesFromEnd);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigPoolDepletion
+
+ @Description   Calling this routine enables pause frame generation depending on the
+                depletion status of BM pools. It also defines the conditions to activate
+                this functionality. By default, this functionality is disabled.
+
+                May be used for Rx ports only
+
+ @Param[in]     h_FmPort                A handle to a FM Port module.
+ @Param[in]     p_BufPoolDepletion      A structure of pool depletion parameters
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigPoolDepletion(t_Handle h_FmPort, t_FmPortBufPoolDepletion *p_BufPoolDepletion);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigRateLimit
+
+ @Description   Calling this routine enables rate limit algorithm.
+                By default, this functionality is disabled.
+                Note that rate-limit mechanism uses the FM time stamp.
+                The selected rate limit specified here would be
+                rounded to the nearest power of 2 multiplication
+                (i.e. up to twice the required rate).
+
+                May be used for Tx and offline parsing ports only
+
+ @Param[in]     h_FmPort        A handle to a FM Port module.
+ @Param[in]     p_RateLimit     A structure of rate limit parameters
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigRateLimit(t_Handle h_FmPort, t_FmPortRateLimit *p_RateLimit);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigFrmDiscardOverride
+
+ @Description   Calling this routine changes the error frames destination parameter
+                in the internal driver data base from its default configuration:
+                override = [DEFAULT_PORT_frmDiscardOverride]
+
+                May be used for Rx and offline parsing ports only
+
+ @Param[in]     h_FmPort    A handle to a FM Port module.
+ @Param[in]     override    TRUE to override dicarding of error frames and
+                            enqueueing them to error queue.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigFrmDiscardOverride(t_Handle h_FmPort, bool override);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigErrorsToDiscard
+
+ @Description   Calling this routine changes the behaviour on error parameter
+                in the internal driver data base from its default configuration:
+                [DEFAULT_PORT_errorsToDiscard].
+                If a requested error was previously defined as "ErrorsToEnqueue" it's
+                definition will change and the frame will be discarded.
+                Errors that were not defined either as "ErrorsToEnqueue" nor as
+                "ErrorsToDiscard", will be forwarded to CPU.
+
+
+                May be used for Rx and offline parsing ports only
+
+ @Param[in]     h_FmPort    A handle to a FM Port module.
+ @Param[in]     errs        A list of errors to discard
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigErrorsToDiscard(t_Handle h_FmPort, fmPortFrameErrSelect_t errs);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigDmaSwapData
+
+ @Description   Calling this routine changes the DMA swap data aparameter
+                in the internal driver data base from its default
+                configuration  [DEFAULT_PORT_dmaSwapData]
+
+                May be used for all port types
+
+ @Param[in]     h_FmPort    A handle to a FM Port module.
+ @Param[in]     swapData    New selection
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigDmaSwapData(t_Handle h_FmPort, e_FmPortDmaSwap swapData);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigDmaIcCacheAttr
+
+ @Description   Calling this routine changes the internal context cache
+                attribute parameter in the internal driver data base
+                from its default configuration  [DEFAULT_PORT_dmaIntContextCacheAttr]
+
+                May be used for all port types
+
+ @Param[in]     h_FmPort                    A handle to a FM Port module.
+ @Param[in]     intContextCacheAttr    New selection
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigDmaIcCacheAttr(t_Handle h_FmPort, e_FmPortDmaCache intContextCacheAttr);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigDmaHdrAttr
+
+ @Description   Calling this routine changes the header cache
+                attribute parameter in the internal driver data base
+                from its default configuration  [DEFAULT_PORT_dmaHeaderCacheAttr]
+
+                May be used for all port types
+
+ @Param[in]     h_FmPort                    A handle to a FM Port module.
+ @Param[in]     headerCacheAttr             New selection
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigDmaHdrAttr(t_Handle h_FmPort, e_FmPortDmaCache headerCacheAttr);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigDmaScatterGatherAttr
+
+ @Description   Calling this routine changes the scatter gather cache
+                attribute parameter in the internal driver data base
+                from its default configuration  [DEFAULT_PORT_dmaScatterGatherCacheAttr]
+
+                May be used for all port types
+
+ @Param[in]     h_FmPort                    A handle to a FM Port module.
+ @Param[in]     scatterGatherCacheAttr      New selection
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigDmaScatterGatherAttr(t_Handle h_FmPort, e_FmPortDmaCache scatterGatherCacheAttr);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigDmaReadOptimize
+
+ @Description   Calling this routine changes the read optimization
+                parameter in the internal driver data base
+                from its default configuration:  optimize = [DEFAULT_PORT_dmaReadOptimize]
+
+                May be used for all port types
+
+ @Param[in]     h_FmPort    A handle to a FM Port module.
+ @Param[in]     optimize    TRUE to enable optimization, FALSE for normal operation
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigDmaReadOptimize(t_Handle h_FmPort, bool optimize);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigDmaWriteOptimize
+
+ @Description   Calling this routine changes the write optimization
+                parameter in the internal driver data base
+                from its default configuration:  optimize = [DEFAULT_PORT_dmaWriteOptimize]
+
+                May be used for all port types
+
+ @Param[in]     h_FmPort    A handle to a FM Port module.
+ @Param[in]     optimize    TRUE to enable optimization, FALSE for normal operation
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigDmaWriteOptimize(t_Handle h_FmPort, bool optimize);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigDfltColor
+
+ @Description   Calling this routine changes the internal default color parameter
+                in the internal driver data base
+                from its default configuration  [DEFAULT_PORT_color]
+
+                May be used for all port types
+
+ @Param[in]     h_FmPort        A handle to a FM Port module.
+ @Param[in]     color           New selection
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigDfltColor(t_Handle h_FmPort, e_FmPortColor color);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigSyncReq
+
+ @Description   Calling this routine changes the synchronization attribute parameter
+                in the internal driver data base from its default configuration:
+                syncReq = [DEFAULT_PORT_syncReq]
+
+                May be used for all port types
+
+ @Param[in]     h_FmPort        A handle to a FM Port module.
+ @Param[in]     syncReq         TRUE to request synchronization, FALSE otherwize.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigSyncReq(t_Handle h_FmPort, bool syncReq);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigForwardReuseIntContext
+
+ @Description   This routine is relevant for Rx ports that are routed to offline
+                parsing. It changes the internal context reuse option
+                in the internal driver data base from its default configuration:
+                reuse = [DEFAULT_PORT_forwardIntContextReuse]
+
+                May be used for Rx ports only
+
+ @Param[in]     h_FmPort        A handle to a FM Port module.
+ @Param[in]     reuse           TRUE to reuse internal context on frames
+                                forwarded to offline parsing.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigForwardReuseIntContext(t_Handle h_FmPort, bool reuse);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigRxL4ChecksumVerify
+
+ @Description   This routine is relevant for Rx ports that are routed to transmission.
+                It changes the internal context reuse option
+                in the internal driver data base from its default configuration:
+                l4Checksum = [DEFAULT_PORT_l4Checksum]
+
+                May be used for Rx ports only.
+
+ @Param[in]     h_FmPort        A handle to a FM Port module.
+ @Param[in]     l4Checksum      TRUE to do TCP checksum on frames
+                                forwarded to transmission.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigRxL4ChecksumVerify(t_Handle h_FmPort, bool l4Checksum);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigIMMaxRxBufLength
+
+ @Description   Changes the maximum receive buffer length from its default
+                configuration: [DEFAULT_PORT_ImMaxRxBufLength]
+
+                The maximum receive buffer length directly affects the structure
+                of received frames (single- or multi-buffered) and the performance
+                of both the FM and the driver.
+
+                The selection between single- or multi-buffered frames should be
+                done according to the characteristics of the specific application.
+                The recommended mode is to use a single data buffer per packet,
+                as this mode provides the best performance. However, the user can
+                select to use multiple data buffers per packet.
+
+ @Param[in]     h_FmPort        A handle to a FM Port module.
+ @Param[in]     newVal          Maximum receive buffer length (in bytes).
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+                This routine is to be used only if Independent-Mode is enabled.
+*//***************************************************************************/
+t_Error FM_PORT_ConfigIMMaxRxBufLength(t_Handle h_FmPort, uint16_t newVal);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigIMRxBdRingLength
+
+ @Description   Changes the receive BD ring length from its default
+                configuration:[DEFAULT_PORT_rxBdRingLength]
+
+ @Param[in]     h_FmPort        A handle to a FM Port module.
+ @Param[in]     newVal          The desired BD ring length.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+                This routine is to be used only if Independent-Mode is enabled.
+*//***************************************************************************/
+t_Error FM_PORT_ConfigIMRxBdRingLength(t_Handle h_FmPort, uint16_t newVal);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigIMTxBdRingLength
+
+ @Description   Changes the transmit BD ring length from its default
+                configuration:[DEFAULT_PORT_txBdRingLength]
+
+ @Param[in]     h_FmPort        A handle to a FM Port module.
+ @Param[in]     newVal          The desired BD ring length.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+                This routine is to be used only if Independent-Mode is enabled.
+*//***************************************************************************/
+t_Error FM_PORT_ConfigIMTxBdRingLength(t_Handle h_FmPort, uint16_t newVal);
+
+/** @} */ /* end of FM_PORT_advanced_init_grp group */
+/** @} */ /* end of FM_PORT_init_grp group */
+
+
+/**************************************************************************//**
+ @Group         FM_PORT_runtime_control_grp FM Port Runtime Control Unit
+
+ @Description   FM Port Runtime control unit API functions, definitions and enums.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description   enum for defining FM Port counters
+*//***************************************************************************/
+typedef enum e_FmPortCounters {
+    e_FM_PORT_COUNTERS_CYCLE,                       /**< BMI performance counter */
+    e_FM_PORT_COUNTERS_TASK_UTIL,                   /**< BMI performance counter */
+    e_FM_PORT_COUNTERS_QUEUE_UTIL,                  /**< BMI performance counter */
+    e_FM_PORT_COUNTERS_DMA_UTIL,                    /**< BMI performance counter */
+    e_FM_PORT_COUNTERS_FIFO_UTIL,                   /**< BMI performance counter */
+    e_FM_PORT_COUNTERS_RX_PAUSE_ACTIVATION,         /**< BMI Rx only performance counter */
+    e_FM_PORT_COUNTERS_FRAME,                       /**< BMI statistics counter */
+    e_FM_PORT_COUNTERS_DISCARD_FRAME,               /**< BMI statistics counter */
+    e_FM_PORT_COUNTERS_DEALLOC_BUF,                 /**< BMI deallocate buffer statistics counter */
+    e_FM_PORT_COUNTERS_RX_BAD_FRAME,                /**< BMI Rx only statistics counter */
+    e_FM_PORT_COUNTERS_RX_LARGE_FRAME,              /**< BMI Rx only statistics counter */
+    e_FM_PORT_COUNTERS_RX_OUT_OF_BUFFERS_DISCARD,   /**< BMI Rx only statistics counter */
+    e_FM_PORT_COUNTERS_RX_FILTER_FRAME,             /**< BMI Rx & OP only statistics counter */
+    e_FM_PORT_COUNTERS_RX_LIST_DMA_ERR,             /**< BMI Rx, OP & HC only statistics counter */
+    e_FM_PORT_COUNTERS_WRED_DISCARD,                /**< BMI OP & HC only statistics counter */
+    e_FM_PORT_COUNTERS_LENGTH_ERR,                  /**< BMI non-Rx statistics counter */
+    e_FM_PORT_COUNTERS_UNSUPPRTED_FORMAT,           /**< BMI non-Rx statistics counter */
+    e_FM_PORT_COUNTERS_DEQ_TOTAL,                   /**< QMI counter */
+    e_FM_PORT_COUNTERS_ENQ_TOTAL,                   /**< QMI counter */
+    e_FM_PORT_COUNTERS_DEQ_FROM_DEFAULT,            /**< QMI counter */
+    e_FM_PORT_COUNTERS_DEQ_CONFIRM                  /**< QMI counter */
+} e_FmPortCounters;
+
+/**************************************************************************//**
+ @Description   Structure for Port id parameters.
+                Fields commented 'IN' are passed by the port module to be used
+                by the FM module.
+                Fields commented 'OUT' will be filled by FM before returning to port.
+*//***************************************************************************/
+typedef struct t_FmPortCongestionGrps {
+    uint16_t    numOfCongestionGrpsToConsider;          /**< The number of required congestion groups
+                                                             to define the size of the following array */
+    uint8_t     congestionGrpsToConsider[FM_PORT_NUM_OF_CONGESTION_GRPS];
+                                                        /**< An array of 'numOfCongestionGrpsToConsider'
+                                                             describing the groups */
+} t_FmPortCongestionGrps;
+
+
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+/**************************************************************************//**
+ @Function      FM_PORT_DumpRegs
+
+ @Description   Dump all regs.
+
+                Calling this routine invalidates the descriptor.
+
+ @Param[in]     h_FmPort - FM PORT module descriptor
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_DumpRegs(t_Handle h_FmPort);
+#endif /* (defined(DEBUG_ERRORS) && ... */
+
+/**************************************************************************//**
+ @Function      FM_PORT_GetBufferDataOffset
+
+ @Description   Returns the data offset from the begining of the data buffer
+
+ @Param[in]     h_FmPort - FM PORT module descriptor
+
+ @Return        data offset.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+uint32_t FM_PORT_GetBufferDataOffset(t_Handle h_FmPort);
+
+/**************************************************************************//**
+ @Function      FM_PORT_GetBufferPrsResult
+
+ @Description   Returns the pointer to the parse result in the data buffer.
+                In Rx ports this is relevant after reception, if parse
+                result is configured to be part of the data passed to the
+                application. For non Rx ports it may be used to get the pointer
+                of the area in the buffer where parse result should be
+                initialized - if so configured.
+                See FM_PORT_ConfigBufferPrefixContent for data buffer prefix
+                configuration.
+
+ @Param[in]     h_FmPort    - FM PORT module descriptor
+ @Param[in]     p_Data      - A pointer to the data buffer.
+
+ @Return        Parse result pointer on success, NULL if parse result was not
+                configured for this port.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+t_FmPrsResult * FM_PORT_GetBufferPrsResult(t_Handle h_FmPort, char *p_Data);
+
+/**************************************************************************//**
+ @Function      FM_PORT_GetBufferTimeStamp
+
+ @Description   Returns the pointer to the time stamp in the data buffer.
+                In Rx ports this is relevant after reception, if parse
+                result is configured to be part of the data passed to the
+                application. For non Rx ports it may be used to get the pointer
+                of the area in the buffer where time stamp should be
+                initialized - if so configured.
+                See FM_PORT_ConfigBufferPrefixContent for data buffer prefix
+                configuration.
+
+ @Param[in]     h_FmPort    - FM PORT module descriptor
+ @Param[in]     p_Data      - A pointer to the data buffer.
+
+ @Return        Time stamp pointer on success, NULL if time stamp was not
+                configured for this port.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+t_FmTimeStamp * FM_PORT_GetBufferTimeStamp(t_Handle h_FmPort, char *p_Data);
+
+/**************************************************************************//**
+ @Function      FM_PORT_Disable
+
+ @Description   Gracefully disable an FM port. The port will not start new tasks after all
+                tasks associated with the port are terminated.
+
+ @Param[in]     h_FmPort    A handle to a FM Port module.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+                This is a blocking routine, it returns after port is
+                gracefully stopped, i.e. the port will not except new frames,
+                but it will finish all frames or tasks which were already began
+*//***************************************************************************/
+void FM_PORT_Disable(t_Handle h_FmPort);
+
+/**************************************************************************//**
+ @Function      FM_PORT_Enable
+
+ @Description   A runtime routine provided to allow disable/enable of port.
+
+ @Param[in]     h_FmPort    A handle to a FM Port module.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+void FM_PORT_Enable(t_Handle h_FmPort);
+
+/**************************************************************************//**
+ @Function      FM_PORT_SetStatisticsCounters
+
+ @Description   Calling this routine enables/disables port's statistics counters.
+                By default, counters are enabled.
+
+                May be used for all port types
+
+ @Param[in]     h_FmPort    A handle to a FM Port module.
+ @Param[in]     enable      TRUE to enable, FALSE to disable.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_SetStatisticsCounters(t_Handle h_FmPort, bool enable);
+
+/**************************************************************************//**
+ @Function      FM_PORT_SetFrameQueueCounters
+
+ @Description   Calling this routine enables/disables port's enqueue/dequeue counters.
+                By default, counters are enabled.
+
+                May be used for all ports
+
+ @Param[in]     h_FmPort    A handle to a FM Port module.
+ @Param[in]     enable      TRUE to enable, FALSE to disable.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_SetFrameQueueCounters(t_Handle h_FmPort, bool enable);
+
+/**************************************************************************//**
+ @Function      FM_PORT_SetPerformanceCounters
+
+ @Description   Calling this routine enables/disables port's performance counters.
+                By default, counters are disabled.
+
+                May be used for all port types
+
+ @Param[in]     h_FmPort                A handle to a FM Port module.
+ @Param[in]     p_FmPortPerformanceCnt  A structure of performance counters parameters.
+                                        Note that `queueCompVal` is used only by Rx ports
+                                        and Tx ports with confirmation queue.
+ @Param[in]     enable                  TRUE to enable, FALSE to disable.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_SetPerformanceCounters(t_Handle h_FmPort, t_FmPortPerformanceCnt *p_FmPortPerformanceCnt, bool enable);
+
+/**************************************************************************//**
+ @Function      FM_PORT_SetAllocBufCounter
+
+ @Description   Calling this routine enables/disables BM pool allocate
+                buffer counters.
+                By default, counters are enabled.
+
+                May be used for Rx ports only
+
+ @Param[in]     h_FmPort    A handle to a FM Port module.
+ @Param[in]     poolId      BM pool id.
+ @Param[in]     enable      TRUE to enable, FALSE to disable.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_SetEnAllocBufCounter(t_Handle h_FmPort, uint8_t poolId, bool enable);
+
+/**************************************************************************//**
+ @Function      FM_PORT_GetCounter
+
+ @Description   Reads one of the FM PORT counters.
+
+ @Param[in]     h_FmPort            A handle to a FM Port module.
+ @Param[in]     fmPortCounter       The requested counter.
+
+ @Return        Counter's current value.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+                Note that it is user's responsibilty to call this routine only
+                for enabled counters, and there will be no indication if a
+                disabled counter is accessed.
+*//***************************************************************************/
+uint32_t FM_PORT_GetCounter(t_Handle h_FmPort, e_FmPortCounters fmPortCounter);
+
+/**************************************************************************//**
+ @Function      FM_PORT_SetCounter
+
+ @Description   Sets a value to an enabled counter. Use "0" to reset the counter.
+
+ @Param[in]     h_FmPort            A handle to a FM Port module.
+ @Param[in]     fmPortCounter       The requested counter.
+ @Param[in]     value                 The requested value to be written into the counter.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_SetCounter(t_Handle h_FmPort, e_FmPortCounters fmPortCounter, uint32_t value);
+
+/**************************************************************************//**
+ @Function      FM_PORT_GetAllocBufCounter
+
+ @Description   Reads one of the FM PORT buffer counters.
+
+ @Param[in]     h_FmPort            A handle to a FM Port module.
+ @Param[in]     poolId              The requested pool.
+
+ @Return        Counter's current value.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+                Note that it is user's responsibilty to call this routine only
+                for enabled counters, and there will be no indication if a
+                disabled counter is accessed.
+*//***************************************************************************/
+uint32_t FM_PORT_GetAllocBufCounter(t_Handle h_FmPort, uint8_t poolId);
+
+/**************************************************************************//**
+ @Function      FM_PORT_SetAllocBufCounter
+
+ @Description   Sets a value to an enabled counter. Use "0" to reset the counter.
+
+ @Param[in]     h_FmPort            A handle to a FM Port module.
+ @Param[in]     poolId              The requested pool.
+ @Param[in]     value               The requested value to be written into the counter.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_SetAllocBufCounter(t_Handle h_FmPort,  uint8_t poolId, uint32_t value);
+
+/**************************************************************************//**
+ @Function      FM_PORT_AddCongestionGrps
+
+ @Description   This routine effects the corresponding Tx port.
+                It should be called in order to enable pause
+                frame transmission in case of congestion in one or more
+                of the congestion groups relevant to this port.
+                Each call to this routine may add one or more congestion
+                groups to be considered relevant to this port.
+
+                May be used for Rx ports only
+
+ @Param[in]     h_FmPort            A handle to a FM Port module.
+ @Param[in]     p_CongestionGrps    A pointer to an array of congestion groups
+                                    id's to consider.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_AddCongestionGrps(t_Handle h_FmPort, t_FmPortCongestionGrps *p_CongestionGrps);
+
+/**************************************************************************//**
+ @Function      FM_PORT_RemoveCongestionGrps
+
+ @Description   This routine effects the corresponding Tx port. It should be
+                called when congestion groups were
+                defined for this port and are no longer relevant, or pause
+                frames transmitting is not required on their behalf.
+                Each call to this routine may remove one or more congestion
+                groups to be considered relevant to this port.
+
+                May be used for Rx ports only
+
+ @Param[in]     h_FmPort            A handle to a FM Port module.
+ @Param[in]     p_CongestionGrps    A pointer to an array of congestion groups
+                                    id's to consider.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_RemoveCongestionGrps(t_Handle h_FmPort, t_FmPortCongestionGrps *p_CongestionGrps);
+
+/**************************************************************************//**
+ @Function      FM_PORT_IsStalled
+
+ @Description   A routine for checking whether the specified port is stalled.
+
+ @Param[in]     h_FmPort            A handle to a FM Port module.
+
+ @Return        TRUE if port is stalled, FALSE otherwize
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+bool FM_PORT_IsStalled(t_Handle h_FmPort);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ReleaseStalled
+
+ @Description   This routine may be called in case the port was stalled and may
+                now be released.
+
+ @Param[in]     h_FmPort    A handle to a FM Port module.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ReleaseStalled(t_Handle h_FmPort);
+
+/**************************************************************************//**
+ @Function      FM_PORT_SetErrorsRoute
+
+ @Description   Errors selected for this routine will cause a frame with that error
+                to be enqueued to error queue.
+                Errors not selected for this routine will cause a frame with that error
+                to be enqueued to the one of the other port queues.
+                By default all errors are defined to be enqueued to error queue.
+                Errors that were configured to be discarded (at initialization)
+                may not be selected here.
+
+                May be used for Rx and offline parsing ports only
+
+ @Param[in]     h_FmPort    A handle to a FM Port module.
+ @Param[in]     errs        A list of errors to enqueue to error queue
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_SetErrorsRoute(t_Handle h_FmPort, fmPortFrameErrSelect_t errs);
+
+/**************************************************************************//**
+ @Group         FM_PORT_pcd_runtime_control_grp FM Port PCD Runtime Control Unit
+
+ @Description   FM Port PCD Runtime control unit API functions, definitions and enums.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description   A stracture defining the KG scheme after the parser.
+                This is relevant only to change scheme selection mode - from
+                direct to indirect and vice versa, or when the scheme is selected directly,
+                to select the scheme id.
+
+*//***************************************************************************/
+typedef struct t_FmPcdKgSchemeSelect {
+    bool        direct;                 /**< TRUE to use 'h_Scheme' directly, FALSE to use LCV.*/
+    t_Handle    h_DirectScheme;         /**< Relevant for 'direct'=TRUE only. scheme handle,
+                                             Selects the scheme after parser. */
+} t_FmPcdKgSchemeSelect;
+
+/**************************************************************************//**
+ @Description   A structure of scheme parameters
+*//***************************************************************************/
+typedef struct t_FmPcdPortSchemesParams {
+    uint8_t     numOfSchemes;                           /**< Number of schemes for port to be bound to. */
+    t_Handle    h_Schemes[FM_PCD_KG_NUM_OF_SCHEMES];    /**< Array of 'numOfSchemes' schemes for the
+                                                             port to be bound to */
+} t_FmPcdPortSchemesParams;
+
+/**************************************************************************//**
+ @Description   Union for defining port protocol parameters for parser
+*//***************************************************************************/
+typedef union u_FmPcdHdrPrsOpts {
+    /* MPLS */
+    struct {
+        bool            labelInterpretationEnable;  /**< When this bit is set, the last MPLS label will be
+                                                         interpreted as described in HW spec table. When the bit
+                                                         is cleared, the parser will advance to MPLS next parse */
+        e_NetHeaderType nextParse;                  /**< must be equal or higher than IPv4 */
+    } mplsPrsOptions;
+    /* VLAN */
+    struct {
+        uint16_t        tagProtocolId1;             /**< User defined Tag Protocol Identifier, to be recognized
+                                                         on VLAN TAG on top of 0x8100 and 0x88A8 */
+        uint16_t        tagProtocolId2;             /**< User defined Tag Protocol Identifier, to be recognized
+                                                         on VLAN TAG on top of 0x8100 and 0x88A8 */
+    } vlanPrsOptions;
+    /* IPV6 */
+    struct{
+        bool            routingHdrDisable;          /**< Disable routing header */
+    } ipv6PrsOptions;
+
+    /* UDP */
+    struct{
+        bool            padIgnoreChecksum;          /**< TRUE to ignore pad in checksum */
+    } udpPrsOptions;
+
+    /* TCP */
+    struct {
+        bool            padIgnoreChecksum;          /**< TRUE to ignore pad in checksum */
+    } tcpPrsOptions;
+} u_FmPcdHdrPrsOpts;
+
+
+/**************************************************************************//**
+ @Description   A structure for defining each header for the parser
+*//***************************************************************************/
+typedef struct t_FmPcdPrsAdditionalHdrParams {
+    e_NetHeaderType         hdr;            /**< Selected header */
+    bool                    errDisable;     /**< TRUE to disable error indication */
+    bool                    swPrsEnable;    /**< Enable jump to SW parser when this
+                                                 header is recognized by the HW parser. */
+    uint8_t                 indexPerHdr;    /**< Normally 0, if more than one sw parser
+                                                 attachments exists for the same header,
+                                                 (in the main sw parser code) use this
+                                                 index to distinguish between them. */
+    bool                    usePrsOpts;     /**< TRUE to use parser options. */
+    u_FmPcdHdrPrsOpts       prsOpts;        /**< A unuion according to header type,
+                                                 defining the parser options selected.*/
+} t_FmPcdPrsAdditionalHdrParams;
+
+/**************************************************************************//**
+ @Description   struct for defining port PCD parameters
+*//***************************************************************************/
+typedef struct t_FmPortPcdPrsParams {
+    uint8_t                         prsResultPrivateInfo;           /**< The private info provides a method of inserting
+                                                                         port information into the parser result. This information
+                                                                         may be extracted by Keygen and be used for frames
+                                                                         distribution when a per-port distinction is required,
+                                                                         it may also be used as a port logical id for analyazing
+                                                                         incoming frames. */
+    uint8_t                         parsingOffset;                  /**< Number of bytes from begining of packet to
+                                                                         start parsing */
+    e_NetHeaderType                 firstPrsHdr;                    /**< The type of the first header axpected at
+                                                                         'parsingOffset' */
+#ifndef CONFIG_MULTI_PARTITION_SUPPORT
+    bool                            includeInPrsStatistics;         /**< TRUE to include this port in the parser statistics.*/
+#endif  /* ! CONFIG_MULTI_PARTITION_SUPPORT */
+    uint8_t                         numOfHdrsWithAdditionalParams;  /**< Normally 0, some headers may get
+                                                                         special parameters */
+    t_FmPcdPrsAdditionalHdrParams   additionalParams[FM_PCD_PRS_NUM_OF_HDRS];
+                                                                    /**< 'numOfHdrsWithAdditionalParams'  structures
+                                                                         of additional parameters
+                                                                         for each header that requires them */
+    bool                            setVlanTpid1;                   /**< TRUE to configure user selection of Ethertype to
+                                                                         indicate a VLAN tag (in addition to the TPID values
+                                                                         0x8100 and 0x88A8). */
+    uint16_t                        vlanTpid1;                      /**< extra tag to use if setVlanTpid1=TRUE. */
+    bool                            setVlanTpid2;                   /**< TRUE to configure user selection of Ethertype to
+                                                                         indicate a VLAN tag (in addition to the TPID values
+                                                                         0x8100 and 0x88A8). */
+    uint16_t                        vlanTpid2;                      /**< extra tag to use if setVlanTpid1=TRUE. */
+} t_FmPortPcdPrsParams;
+
+/**************************************************************************//**
+ @Description   struct for defining coarse alassification parameters
+*//***************************************************************************/
+typedef struct t_FmPortPcdCcParams {
+    t_Handle            h_CcTree;                       /**< A handle to a CC tree */
+} t_FmPortPcdCcParams;
+
+/**************************************************************************//**
+ @Description   struct for defining keygen parameters
+*//***************************************************************************/
+typedef struct t_FmPortPcdKgParams {
+    uint8_t             numOfSchemes;                   /**< Number of schemes for port to be bound to. */
+    t_Handle            h_Schemes[FM_PCD_KG_NUM_OF_SCHEMES];
+                                                        /**< Array of 'numOfSchemes' schemes handles for the
+                                                             port to be bound to */
+    bool                useClsPlan;                     /**< TRUE to use the classification plan mechanism */
+    t_Handle            h_ClsPlanGrp;                   /**< clssification-Plan must be of the same h_NetEnv
+                                                             of this port */
+    bool                directScheme;                   /**< TRUE for going from parser to a specific scheme,
+                                                             regardless of parser result */
+    t_Handle            h_DirectScheme;                 /**< relevant only if direct == TRUE, Scheme handle,
+                                                             as returned by FM_PCD_KgSetScheme */
+} t_FmPortPcdKgParams;
+
+/**************************************************************************//**
+ @Description   struct for defining policer parameters
+*//***************************************************************************/
+typedef struct t_FmPortPcdPlcrParams {
+    t_Handle                h_Profile;          /**< Selected profile handle. relevant only if
+                                                     e_FM_PCD_SUPPORT_PLCR_ONLY or
+                                                     e_FM_PCD_SUPPORT_PRS_AND_PLCR were selected */
+} t_FmPortPcdPlcrParams;
+
+/**************************************************************************//**
+ @Description   struct for defining port PCD parameters
+*//***************************************************************************/
+typedef struct t_FmPortPcdParams {
+    e_FmPortPcdSupport      pcdSupport;         /**< Relevant for Rx and offline ports only.
+                                                     Describes the active PCD engines for this port. */
+    t_Handle                h_NetEnv;           /**< HL Unused in PLCR only mode */
+    t_FmPortPcdPrsParams    *p_PrsParams;       /**< Parser parameters for this port */
+    t_FmPortPcdCcParams     *p_CcParams;        /**< Coarse classification parameters for this port */
+    t_FmPortPcdKgParams     *p_KgParams;        /**< Keygen parameters for this port */
+    t_FmPortPcdPlcrParams   *p_PlcrParams;      /**< Policer parameters for this port */
+} t_FmPortPcdParams;
+
+
+/**************************************************************************//**
+ @Function      FM_PORT_SetPCD
+
+ @Description   Calling this routine defines the port's PCD configuration.
+                It changes it from its default configuration which is PCD
+                disabled (BMI to BMI) and configures it according to the passed
+                parameters.
+
+                May be used for Rx and offline parsing ports only
+
+ @Param[in]     h_FmPort        A handle to a FM Port module.
+ @Param[in]     p_FmPortPcd     A Structure of parameters defining the port's PCD
+                                configuration.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_SetPCD(t_Handle h_FmPort, t_FmPortPcdParams *p_FmPortPcd);
+
+/**************************************************************************//**
+ @Function      FM_PORT_DeletePCD
+
+ @Description   Calling this routine releases the port's PCD configuration.
+                The port returns to its default configuration which is PCD
+                disabled (BMI to BMI) and all PCD configuration is removed.
+
+                May be used for Rx and offline parsing ports which are
+                in PCD mode  only
+
+ @Param[in]     h_FmPort        A handle to a FM Port module.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_DeletePCD(t_Handle h_FmPort);
+
+/**************************************************************************//**
+ @Function      FM_PORT_AttachPCD
+
+ @Description   This routine may be called after FM_PORT_DetachPCD was called,
+                to return to the originally configured PCD support flow.
+                The couple of routines are used to allow PCD configuration changes
+                that demand that PCD will not be used while changes take place.
+
+                May be used for Rx and offline parsing ports which are
+                in PCD mode only
+
+ @Param[in]     h_FmPort        A handle to a FM Port module.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_AttachPCD(t_Handle h_FmPort);
+
+/**************************************************************************//**
+ @Function      FM_PORT_DetachPCD
+
+ @Description   Calling this routine detaches the port from its PCD functionality.
+                The port returns to its default flow which is BMI to BMI.
+
+                May be used for Rx and offline parsing ports which are
+                in PCD mode only
+
+ @Param[in]     h_FmPort        A handle to a FM Port module.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_DetachPCD(t_Handle h_FmPort);
+
+/**************************************************************************//**
+ @Function      FM_PORT_PcdPlcrAllocProfiles
+
+ @Description   This routine may be called only for ports that use the Policer in
+                order to allocate private policer profiles.
+
+ @Param[in]     h_FmPort            A handle to a FM Port module.
+ @Param[in]     numOfProfiles       The number of required policer profiles
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init() and FM_PCD_Init(), and before FM_PORT_SetPCD().
+*//***************************************************************************/
+t_Error FM_PORT_PcdPlcrAllocProfiles(t_Handle h_FmPort, uint16_t numOfProfiles);
+
+/**************************************************************************//**
+ @Function      FM_PORT_PcdPlcrFreeProfiles
+
+ @Description   This routine should be called for freeing private policer profiles.
+
+ @Param[in]     h_FmPort            A handle to a FM Port module.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init() and FM_PCD_Init(), and before FM_PORT_SetPCD().
+*//***************************************************************************/
+t_Error FM_PORT_PcdPlcrFreeProfiles(t_Handle h_FmPort);
+
+/**************************************************************************//**
+ @Function      FM_PORT_PcdKgModifyInitialScheme
+
+ @Description   This routine may be called only for ports that use the keygen in
+                order to change the initial scheme frame should be routed to.
+                The change may be of a scheme id (in case of direct mode),
+                from direct to indirect, or from indirect to direct - specifying the scheme id.
+
+ @Param[in]     h_FmPort            A handle to a FM Port module.
+ @Param[in]     p_FmPcdKgScheme     A structure of parameters for defining whether
+                                    a scheme is direct/indirect, and if direct - scheme id.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init() and FM_PORT_SetPCD().
+*//***************************************************************************/
+t_Error          FM_PORT_PcdKgModifyInitialScheme (t_Handle h_FmPort, t_FmPcdKgSchemeSelect *p_FmPcdKgScheme);
+
+/**************************************************************************//**
+ @Function      FM_PORT_PcdPlcrModifyInitialProfile
+
+ @Description   This routine may be called for ports with flows e_FM_PCD_SUPPORT_PLCR_ONLY or
+                e_FM_PCD_SUPPORT_PRS_AND_PLCR  only, to change the initial Policer profile frame
+                should be routed to. The change may be of a profile and/or absolute/direct mode
+                selection.
+
+ @Param[in]     h_FmPort                A handle to a FM Port module.
+ @Param[in]     h_Profile               Policer profile handle
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init() and FM_PORT_SetPCD().
+*//***************************************************************************/
+t_Error     FM_PORT_PcdPlcrModifyInitialProfile (t_Handle h_FmPort, t_Handle h_Profile);
+
+/**************************************************************************//**
+ @Function      FM_PORT_PcdCcModifyTree
+
+ @Description   This routine may be called for ports that use coarse classification tree
+                if the user wishes to replace the tree. The routine may not be called while port
+                receives packets using the PCD functionalities, therefor port must be first detached
+                from the PCD, only than the routine may be called, and than port be attached to PCD again.
+
+ @Param[in]     h_FmPort            A handle to a FM Port module.
+ @Param[in]     h_CcTree            A CC tree that was already built. The tree id as returned from
+                                    the BuildTree routine.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init(), FM_PORT_SetPCD() and FM_PORT_DetachPCD()
+*//***************************************************************************/
+t_Error          FM_PORT_PcdCcModifyTree (t_Handle h_FmPort, t_Handle h_CcTree);
+
+/**************************************************************************//**
+ @Function      FM_PORT_PcdKgModifyClsPlanGrp
+
+ @Description   This routine may be called for ports using the KG functionality of the PCD,
+                if the user wishes to replace the classification plan
+                group that the port uses, to start using the classification plan mechanism or to stop
+                using it. The routine may not be called while port
+                receives packets using the PCD functionalities, therefor port must be first detached
+                from the PCD, only than the routine may be called, and than port be attached to PCD again.
+
+ @Param[in]     h_FmPort            A handle to a FM Port module.
+ @Param[in]     useClsPlan          TRUE to use a pre-defined group, FALSE to stop using one.
+ @Param[in]     h_NewClsPlanGrp     A handle of a classification plan group that was already set.
+                                    The handle as returned from the SetClsPlanGrp routine.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init(), FM_PORT_SetPCD() and FM_PORT_DetachPCD()
+*//***************************************************************************/
+t_Error          FM_PORT_PcdKgModifyClsPlanGrp (t_Handle h_FmPort, bool useClsPlan, t_Handle h_NewClsPlanGrp);
+
+/**************************************************************************//**
+ @Function      FM_PORT_PcdKgBindSchemes
+
+ @Description   These routines may be called for adding more schemes for the
+                port to be bound to. The selected schemes are not added,
+                just this specific port starts using them.
+
+ @Param[in]     h_FmPort        A handle to a FM Port module.
+ @Param[in]     p_PortScheme    A structure defining the list of schemes to be added.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init() and FM_PORT_SetPCD().
+*//***************************************************************************/
+t_Error      FM_PORT_PcdKgBindSchemes (t_Handle h_FmPort, t_FmPcdPortSchemesParams *p_PortScheme);
+
+/**************************************************************************//**
+ @Function      FM_PORT_PcdKgUnbindSchemes
+
+ @Description   These routines may be called for adding more schemes for the
+                port to be bound to. The selected schemes are not removed or invalidated,
+                just this specific port stops using them.
+
+ @Param[in]     h_FmPort        A handle to a FM Port module.
+ @Param[in]     p_PortScheme    A structure defining the list of schemes to be added.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init() and FM_PORT_SetPCD().
+*//***************************************************************************/
+t_Error      FM_PORT_PcdKgUnbindSchemes (t_Handle h_FmPort, t_FmPcdPortSchemesParams *p_PortScheme);
+
+/**************************************************************************//**
+ @Description   A structure for defining the Parser starting point
+*//***************************************************************************/
+typedef struct t_FmPcdPrsStart {
+    uint8_t             parsingOffset;  /**< Number of bytes from begining of packet to
+                                             start parsing */
+    e_NetHeaderType     firstPrsHdr;    /**< The type of the first header axpected at
+                                             'parsingOffset' */
+} t_FmPcdPrsStart;
+
+/**************************************************************************//**
+ @Function      FM_PORT_PcdPrsModifyStartOffset
+
+ @Description   Runtime change of the parser start offset within the header.
+
+ @Param[in]     h_FmPort        A handle to a FM Port module.
+ @Param[in]     p_FmPcdPrsStart A structure of parameters for defining the
+                                start point for the parser.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init() and FM_PORT_SetPCD().
+*//***************************************************************************/
+t_Error      FM_PORT_PcdPrsModifyStartOffset (t_Handle h_FmPort, t_FmPcdPrsStart *p_FmPcdPrsStart);
+
+/** @} */ /* end of FM_PORT_pcd_runtime_control_grp group */
+/** @} */ /* end of FM_PORT_runtime_control_grp group */
+
+
+/**************************************************************************//**
+ @Group         FM_PORT_runtime_data_grp FM Port Runtime Data-path Unit
+
+ @Description   FM Port Runtime data unit API functions, definitions and enums.
+                This API is valid only if working in Independent-Mode.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Function      FM_PORT_ImTx
+
+ @Description   Tx function, called to transmit a data buffer on the port.
+
+ @Param[in]     h_FmPort    A handle to a FM Port module.
+ @Param[in]     p_Data      A pointer to an LCP data buffer.
+ @Param[in]     length      Size of data for transmission.
+ @Param[in]     lastBuffer  Buffer poistion - TRUE for the last buffer
+                            of a frame, including a single buffer frame
+ @Param[in]     h_UserPriv  A handle of the user acossiated with this buffer
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+                NOTE - This routine can be used only when working in
+                Independent-Mode mode.
+*//***************************************************************************/
+t_Error  FM_PORT_ImTx( t_Handle               h_FmPort,
+                       uint8_t                *p_Data,
+                       uint16_t               length,
+                       bool                   lastBuffer,
+                       t_Handle               h_UserPriv);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ImTxConf
+
+ @Description   Tx port confirmation routine, optional, may be called to verify
+                transmission of all frames. The procedure performed by this
+                routine will be performed automatically on next buffer transmission,
+                but if desired, calling this routine will invoke this action on
+                demand.
+
+ @Param[in]     h_FmPort            A handle to a FM Port module.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+                NOTE - This routine can be used only when working in
+                Independent-Mode mode.
+*//***************************************************************************/
+void FM_PORT_ImTxConf(t_Handle h_FmPort);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ImRx
+
+ @Description   Rx function, may be called to poll for received buffers.
+                Normally, Rx process is invoked by the driver on Rx interrupt.
+                Alternatively, this routine may be called on demand.
+
+ @Param[in]     h_FmPort            A handle to a FM Port module.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+                NOTE - This routine can be used only when working in
+                Independent-Mode mode.
+*//***************************************************************************/
+t_Error  FM_PORT_ImRx(t_Handle h_FmPort);
+
+/** @} */ /* end of FM_PORT_runtime_data_grp group */
+/** @} */ /* end of FM_PORT_grp group */
+/** @} */ /* end of FM_grp group */
+
+#endif /* __FM_PORT_EXT */
diff --git a/drivers/net/dpa/NetCommSw/inc/Peripherals/mii_acc_ext.h b/drivers/net/dpa/NetCommSw/inc/Peripherals/mii_acc_ext.h
new file mode 100644
index 0000000..419445f
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/inc/Peripherals/mii_acc_ext.h
@@ -0,0 +1,75 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+
+#ifndef __MII_ACC_EXT_H
+#define __MII_ACC_EXT_H
+
+
+/**************************************************************************//**
+ @Function      MII_ReadPhyReg
+
+ @Description   This routine is called to read a specified PHY
+                register value.
+
+ @Param[in]     h_MiiAccess - Handle to MII configuration access registers
+ @Param[in]     phyAddr     - PHY address (0-31).
+ @Param[in]     reg         - PHY register to read
+ @Param[out]    p_Data      - Gets the register value.
+
+ @Return        Always zero (success).
+*//***************************************************************************/
+int MII_ReadPhyReg(t_Handle h_MiiAccess,
+                   uint8_t  phyAddr,
+                   uint8_t  reg,
+                   uint16_t *p_Data);
+
+/**************************************************************************//**
+ @Function      MII_WritePhyReg
+
+ @Description   This routine is called to write data to a specified PHY
+                   register.
+
+ @Param[in]     h_MiiAccess - Handle to MII configuration access registers
+ @Param[in]     phyAddr     - PHY address (0-31).
+ @Param[in]     reg         - PHY register to write
+ @Param[in]     data        - Data to write in register.
+
+ @Return        Always zero (success).
+*//***************************************************************************/
+int MII_WritePhyReg(t_Handle    h_MiiAccess,
+                    uint8_t     phyAddr,
+                    uint8_t     reg,
+                    uint16_t    data);
+
+
+#endif /* __MII_ACC_EXT_H */
diff --git a/drivers/net/dpa/NetCommSw/inc/ctype_ext.h b/drivers/net/dpa/NetCommSw/inc/ctype_ext.h
new file mode 100644
index 0000000..b28ff4c
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/inc/ctype_ext.h
@@ -0,0 +1,96 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __CTYPE_EXT_H
+#define __CTYPE_EXT_H
+
+
+#if defined(NCSW_LINUX) && defined(__KERNEL__)
+/*
+ * NOTE! This ctype does not handle EOF like the standard C
+ * library is required to.
+ */
+
+#define _U    0x01    /* upper */
+#define _L    0x02    /* lower */
+#define _D    0x04    /* digit */
+#define _C    0x08    /* cntrl */
+#define _P    0x10    /* punct */
+#define _S    0x20    /* white space (space/lf/tab) */
+#define _X    0x40    /* hex digit */
+#define _SP   0x80    /* hard space (0x20) */
+
+extern unsigned char _ctype[];
+
+#define __ismask(x) (_ctype[(int)(unsigned char)(x)])
+
+#define isalnum(c)    ((__ismask(c)&(_U|_L|_D)) != 0)
+#define isalpha(c)    ((__ismask(c)&(_U|_L)) != 0)
+#define iscntrl(c)    ((__ismask(c)&(_C)) != 0)
+#define isdigit(c)    ((__ismask(c)&(_D)) != 0)
+#define isgraph(c)    ((__ismask(c)&(_P|_U|_L|_D)) != 0)
+#define islower(c)    ((__ismask(c)&(_L)) != 0)
+#define isprint(c)    ((__ismask(c)&(_P|_U|_L|_D|_SP)) != 0)
+#define ispunct(c)    ((__ismask(c)&(_P)) != 0)
+#define isspace(c)    ((__ismask(c)&(_S)) != 0)
+#define isupper(c)    ((__ismask(c)&(_U)) != 0)
+#define isxdigit(c)   ((__ismask(c)&(_D|_X)) != 0)
+
+#define isascii(c) (((unsigned char)(c))<=0x7f)
+#define toascii(c) (((unsigned char)(c))&0x7f)
+
+static __inline__ unsigned char __tolower(unsigned char c)
+{
+    if (isupper(c))
+        c -= 'A'-'a';
+    return c;
+}
+
+static __inline__ unsigned char __toupper(unsigned char c)
+{
+    if (islower(c))
+        c -= 'a'-'A';
+    return c;
+}
+
+#define tolower(c) __tolower(c)
+#define toupper(c) __toupper(c)
+
+#elif defined(MWI_VXWORKS)
+#include "ctype.h"
+
+#else
+#include <ctype.h>
+#endif /* defined(NCSW_LINUX) && defined(__KERNEL__) */
+
+
+#endif /* __CTYPE_EXT_H */
diff --git a/drivers/net/dpa/NetCommSw/inc/debug_ext.h b/drivers/net/dpa/NetCommSw/inc/debug_ext.h
new file mode 100644
index 0000000..f5f3a7c
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/inc/debug_ext.h
@@ -0,0 +1,258 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**************************************************************************//**
+ @File          debug_ext.h
+
+ @Description   Debug mode definitions.
+*//***************************************************************************/
+
+#ifndef __DEBUG_EXT_H
+#define __DEBUG_EXT_H
+
+#include "std_ext.h"
+#include "xx_ext.h"
+#include "memcpy_ext.h"
+#if (DEBUG_ERRORS > 0)
+#include "sprint_ext.h"
+#include "string_ext.h"
+#endif /* DEBUG_ERRORS > 0 */
+
+
+#if (DEBUG_ERRORS > 0)
+
+/* Internally used macros */
+
+#define DUMP_Print          XX_Print
+#define DUMP_MAX_LEVELS     6
+#define DUMP_MAX_STR        64
+
+
+#define _CREATE_DUMP_SUBSTR(phrase) \
+    dumpTmpLevel = 0; dumpSubStr[0] = '\0'; \
+    sprintf(dumpTmpStr, "%s", #phrase); \
+    p_DumpToken = strtok(dumpTmpStr, (dumpIsArr[0] ? "[" : ".")); \
+    while (p_DumpToken != NULL) \
+    { \
+        strcat(dumpSubStr, p_DumpToken); \
+        if (dumpIsArr[dumpTmpLevel]) \
+        { \
+            strcat(dumpSubStr, dumpIdxStr[dumpTmpLevel]); \
+            p_DumpToken = strtok(NULL, "."); \
+        } \
+        if ((p_DumpToken = strtok(NULL, (dumpIsArr[++dumpTmpLevel] ? "[" : "."))) != 0) \
+            strcat(dumpSubStr, "."); \
+    }\
+
+
+/**************************************************************************//**
+ @Group         gen_id  General Drivers Utilities
+
+ @Description   External routines.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Group         dump_id  Memory and Registers Dump Mechanism
+
+ @Description   Macros for dumping memory mapped structures.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description   Declaration of dump mechanism variables.
+
+                This macro must be declared at the beginning of each routine
+                which uses the dump mechanism macros, before the routine's code
+                starts.
+*//***************************************************************************/
+#define DECLARE_DUMP \
+    char    dumpIdxStr[DUMP_MAX_LEVELS + 1][6] = { "", }; \
+    char    dumpSubStr[DUMP_MAX_STR] = ""; \
+    char    dumpTmpStr[DUMP_MAX_STR] = ""; \
+    char    *p_DumpToken = NULL; \
+    int     dumpArrIdx = 0, dumpArrSize = 0, dumpVarSize = 0, dumpLevel = 0, dumpTmpLevel = 0; \
+    uint8_t dumpIsArr[DUMP_MAX_LEVELS + 1] = { 0 }; \
+    /* Prevent warnings if not all used */ \
+    UNUSED(dumpIdxStr[0][0]); \
+    UNUSED(dumpSubStr[0]); \
+    UNUSED(dumpTmpStr[0]); \
+    UNUSED(p_DumpToken); \
+    UNUSED(dumpArrIdx); \
+    UNUSED(dumpArrSize); \
+    UNUSED(dumpVarSize); \
+    UNUSED(dumpLevel); \
+    UNUSED(dumpTmpLevel); \
+    UNUSED(dumpIsArr[0]);
+
+
+/**************************************************************************//**
+ @Description   Prints a title for a subsequent dumped structure or memory.
+
+                The inputs for this macro are the structure/memory title and
+                its base addresss.
+*//***************************************************************************/
+#define DUMP_TITLE(addr, msg)  \
+    DUMP_Print("\r\n"); DUMP_Print msg; \
+    DUMP_Print(" (0x%08X)\r\n" \
+               "---------------------------------------------------------\r\n", \
+               (uint32_t)addr)
+
+/**************************************************************************//**
+ @Description   Prints a subtitle for a subsequent dumped sub-structure (optional).
+
+                The inputs for this macro are the sub-structure subtitle.
+                A separating line with this subtitle will be printed.
+*//***************************************************************************/
+#define DUMP_SUBTITLE(subtitle)  \
+    DUMP_Print("----------- "); DUMP_Print subtitle; DUMP_Print("\r\n")
+
+
+/**************************************************************************//**
+ @Description   Dumps a memory region in 4-bytes aligned format.
+
+                The inputs for this macro are the base addresss and size
+                (in bytes) of the memory region.
+*//***************************************************************************/
+#define DUMP_MEMORY(addr, size)  \
+    MemDisp((uint8_t *)(addr), (int)(size))
+
+
+/**************************************************************************//**
+ @Description   Declares a dump loop, for dumping a sub-structure array.
+
+                The inputs for this macro are:
+                - idx: an index variable, for indexing the sub-structure items
+                       inside the loop. This variable must be declared separately
+                       in the beginning of the routine.
+                - cnt: the number of times to repeat the loop. This number should
+                       equal the number of items in the sub-structures array.
+
+                Note, that the body of the loop must be written inside brackets.
+*//***************************************************************************/
+#define DUMP_SUBSTRUCT_ARRAY(idx, cnt) \
+    for (idx=0, dumpIsArr[dumpLevel++] = 1; \
+         (idx < cnt) && sprintf(dumpIdxStr[dumpLevel-1], "[%d]", idx); \
+         idx++, ((idx < cnt) || ((dumpIsArr[--dumpLevel] = 0) == 0)))
+
+
+/**************************************************************************//**
+ @Description   Dumps a structure's member variable.
+
+                The input for this macro is the full reference for the member
+                variable, where the structure is referenced using a pointer.
+
+                Note, that a members array must be dumped using DUMP_ARR macro,
+                rather than using this macro.
+
+                If the member variable is part of a sub-structure hierarchy,
+                the full hierarchy (including array indexing) must be specified.
+
+                Examples:   p_Struct->member
+                            p_Struct->sub.member
+                            p_Struct->sub[i].member
+*//***************************************************************************/
+#define DUMP_VAR(st, phrase) \
+    do { \
+        _CREATE_DUMP_SUBSTR(phrase); \
+        dumpVarSize = sizeof((st)->phrase); \
+        switch (dumpVarSize) \
+        { \
+            case 1:  DUMP_Print("0x%08X: 0x%02x%14s\t%s\r\n", \
+                                &((st)->phrase), GET_UINT8((st)->phrase), "", dumpSubStr); break; \
+            case 2:  DUMP_Print("0x%08X: 0x%04x%12s\t%s\r\n", \
+                                &((st)->phrase), GET_UINT16((st)->phrase), "", dumpSubStr); break; \
+            case 4:  DUMP_Print("0x%08X: 0x%08x%8s\t%s\r\n", \
+                                &((st)->phrase), GET_UINT32((st)->phrase), "", dumpSubStr); break; \
+            case 8:  DUMP_Print("0x%08X: 0x%016llx\t%s\r\n", \
+                                &((st)->phrase), GET_UINT64((st)->phrase), dumpSubStr); break; \
+            default: DUMP_Print("Bad size %d (" #st "->" #phrase ")\r\n", dumpVarSize); \
+        } \
+    } while (0)
+
+
+/**************************************************************************//**
+ @Description   Dumps a structure's members array.
+
+                The input for this macro is the full reference for the members
+                array, where the structure is referenced using a pointer.
+
+                If the members array is part of a sub-structure hierarchy,
+                the full hierarchy (including array indexing) must be specified.
+
+                Examples:   p_Struct->array
+                            p_Struct->sub.array
+                            p_Struct->sub[i].array
+*//***************************************************************************/
+#define DUMP_ARR(st, phrase) \
+    do { \
+        _CREATE_DUMP_SUBSTR(phrase); \
+        dumpArrSize = ARRAY_SIZE((st)->phrase); \
+        dumpVarSize = sizeof((st)->phrase[0]); \
+        switch (dumpVarSize) \
+        { \
+            case 1: \
+                for (dumpArrIdx=0; dumpArrIdx < dumpArrSize; dumpArrIdx++) { \
+                    DUMP_Print("0x%08X: 0x%02x%14s\t%s[%d]\r\n", \
+                               &((st)->phrase[dumpArrIdx]), GET_UINT8((st)->phrase[dumpArrIdx]), "", dumpSubStr, dumpArrIdx); \
+                } break; \
+            case 2: \
+                for (dumpArrIdx=0; dumpArrIdx < dumpArrSize; dumpArrIdx++) { \
+                    DUMP_Print("0x%08X: 0x%04x%12s\t%s[%d]\r\n", \
+                               &((st)->phrase[dumpArrIdx]), GET_UINT16((st)->phrase[dumpArrIdx]), "", dumpSubStr, dumpArrIdx); \
+                } break; \
+            case 4: \
+                for (dumpArrIdx=0; dumpArrIdx < dumpArrSize; dumpArrIdx++) { \
+                    DUMP_Print("0x%08X: 0x%08x%8s\t%s[%d]\r\n", \
+                               &((st)->phrase[dumpArrIdx]), GET_UINT32((st)->phrase[dumpArrIdx]), "", dumpSubStr, dumpArrIdx); \
+                } break; \
+            case 8: \
+                for (dumpArrIdx=0; dumpArrIdx < dumpArrSize; dumpArrIdx++) { \
+                    DUMP_Print("0x%08X: 0x%016llx\t%s[%d]\r\n", \
+                               &((st)->phrase[dumpArrIdx]), GET_UINT64((st)->phrase[dumpArrIdx]), dumpSubStr, dumpArrIdx); \
+                } break; \
+            default: DUMP_Print("Bad size %d (" #st "->" #phrase "[0])\r\n", dumpVarSize); \
+        } \
+    } while (0)
+
+
+#endif /* DEBUG_ERRORS > 0 */
+
+
+/** @} */ /* end of dump_id group */
+/** @} */ /* end of gen_id group */
+
+
+#endif /* __DEBUG_EXT_H */
+
diff --git a/drivers/net/dpa/NetCommSw/inc/endian_ext.h b/drivers/net/dpa/NetCommSw/inc/endian_ext.h
new file mode 100644
index 0000000..37aa966
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/inc/endian_ext.h
@@ -0,0 +1,458 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**************************************************************************//**
+
+ @File          endian_ext.h
+
+ @Description   Big/little endian swapping routines.
+*//***************************************************************************/
+
+#ifndef __ENDIAN_EXT_H
+#define __ENDIAN_EXT_H
+
+#include "std_ext.h"
+
+
+/**************************************************************************//**
+ @Group         gen_id  General Drivers Utilities
+
+ @Description   General usage API. This API is intended for usage by both the
+                internal modules and the user's application.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Group         endian_id Big/Little-Endian Conversion
+
+ @Description   Routines and macros for Big/Little-Endian conversion and
+                general byte swapping.
+
+                All routines and macros are expecting unsigned values as
+                parameters, but will generate the correct result also for
+                signed values. Therefore, signed/unsigned casting is allowed.
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Collection    Byte-Swap Macros
+
+                Macros for swapping byte order.
+
+ @Cautions      The parameters of these macros are evaluated multiple times.
+                For calculated expressions or expressions that contain function
+                calls it is recommended to use the byte-swap routines.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description   Swaps the byte order of a given 16-bit value.
+
+ @Param[in]     val - The 16-bit value to swap.
+
+ @Return        The byte-swapped value..
+
+ @Cautions      The given value is evaluated multiple times by this macro.
+                For calculated expressions or expressions that contain function
+                calls it is recommended to use the SwapUint16() routine.
+
+ @hideinitializer
+*//***************************************************************************/
+#define SWAP_UINT16(val) \
+    ((uint16_t)((((val) & 0x00FF) << 8) | (((val) & 0xFF00) >> 8)))
+
+/**************************************************************************//**
+ @Description   Swaps the byte order of a given 32-bit value.
+
+ @Param[in]     val - The 32-bit value to swap.
+
+ @Return        The byte-swapped value..
+
+ @Cautions      The given value is evaluated multiple times by this macro.
+                For calculated expressions or expressions that contain function
+                calls it is recommended to use the SwapUint32() routine.
+
+ @hideinitializer
+*//***************************************************************************/
+#define SWAP_UINT32(val) \
+    ((uint32_t)((((val) & 0x000000FF) << 24) | \
+                (((val) & 0x0000FF00) <<  8) | \
+                (((val) & 0x00FF0000) >>  8) | \
+                (((val) & 0xFF000000) >> 24)))
+
+/**************************************************************************//**
+ @Description   Swaps the byte order of a given 64-bit value.
+
+ @Param[in]     val - The 64-bit value to swap.
+
+ @Return        The byte-swapped value..
+
+ @Cautions      The given value is evaluated multiple times by this macro.
+                For calculated expressions or expressions that contain function
+                calls it is recommended to use the SwapUint64() routine.
+
+ @hideinitializer
+*//***************************************************************************/
+#define SWAP_UINT64(val) \
+    ((uint64_t)((((val) & 0x00000000000000FFULL) << 56) | \
+                (((val) & 0x000000000000FF00ULL) << 40) | \
+                (((val) & 0x0000000000FF0000ULL) << 24) | \
+                (((val) & 0x00000000FF000000ULL) <<  8) | \
+                (((val) & 0x000000FF00000000ULL) >>  8) | \
+                (((val) & 0x0000FF0000000000ULL) >> 24) | \
+                (((val) & 0x00FF000000000000ULL) >> 40) | \
+                (((val) & 0xFF00000000000000ULL) >> 56)))
+
+/* @} */
+
+/**************************************************************************//**
+ @Collection    Byte-Swap Routines
+
+                Routines for swapping the byte order of a given parameter and
+                returning the swapped value.
+
+                These inline routines are safer than the byte-swap macros,
+                because they evaluate the parameter expression only once.
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Function      SwapUint16
+
+ @Description   Returns the byte-swapped value of a given 16-bit value.
+
+ @Param[in]     val - The 16-bit value.
+
+ @Return        The byte-swapped value of the parameter.
+*//***************************************************************************/
+static __inline__ uint16_t SwapUint16(uint16_t val)
+{
+    return (uint16_t)(((val & 0x00FF) << 8) |
+                      ((val & 0xFF00) >> 8));
+}
+
+/**************************************************************************//**
+ @Function      SwapUint32
+
+ @Description   Returns the byte-swapped value of a given 32-bit value.
+
+ @Param[in]     val - The 32-bit value.
+
+ @Return        The byte-swapped value of the parameter.
+*//***************************************************************************/
+static __inline__ uint32_t SwapUint32(uint32_t val)
+{
+    return (uint32_t)(((val & 0x000000FF) << 24) |
+                      ((val & 0x0000FF00) <<  8) |
+                      ((val & 0x00FF0000) >>  8) |
+                      ((val & 0xFF000000) >> 24));
+}
+
+/**************************************************************************//**
+ @Function      SwapUint64
+
+ @Description   Returns the byte-swapped value of a given 64-bit value.
+
+ @Param[in]     val - The 64-bit value.
+
+ @Return        The byte-swapped value of the parameter.
+*//***************************************************************************/
+static __inline__ uint64_t SwapUint64(uint64_t val)
+{
+    return (uint64_t)(((val & 0x00000000000000FFULL) << 56) |
+                      ((val & 0x000000000000FF00ULL) << 40) |
+                      ((val & 0x0000000000FF0000ULL) << 24) |
+                      ((val & 0x00000000FF000000ULL) <<  8) |
+                      ((val & 0x000000FF00000000ULL) >>  8) |
+                      ((val & 0x0000FF0000000000ULL) >> 24) |
+                      ((val & 0x00FF000000000000ULL) >> 40) |
+                      ((val & 0xFF00000000000000ULL) >> 56));
+}
+
+/* @} */
+
+/**************************************************************************//**
+ @Collection    In-place Byte-Swap-And-Set Routines
+
+                Routines for swapping the byte order of a given variable and
+                setting the swapped value back to the same variable.
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Function      SwapUint16P
+
+ @Description   Swaps the byte order of a given 16-bit variable.
+
+ @Param[in]     p_Val - Pointer to the 16-bit variable.
+
+ @Return        None.
+*//***************************************************************************/
+static __inline__ void SwapUint16P(uint16_t *p_Val)
+{
+    *p_Val = SwapUint16(*p_Val);
+}
+
+/**************************************************************************//**
+ @Function      SwapUint32P
+
+ @Description   Swaps the byte order of a given 32-bit variable.
+
+ @Param[in]     p_Val - Pointer to the 32-bit variable.
+
+ @Return        None.
+*//***************************************************************************/
+static __inline__ void SwapUint32P(uint32_t *p_Val)
+{
+    *p_Val = SwapUint32(*p_Val);
+}
+
+/**************************************************************************//**
+ @Function      SwapUint64P
+
+ @Description   Swaps the byte order of a given 64-bit variable.
+
+ @Param[in]     p_Val - Pointer to the 64-bit variable.
+
+ @Return        None.
+*//***************************************************************************/
+static __inline__ void SwapUint64P(uint64_t *p_Val)
+{
+    *p_Val = SwapUint64(*p_Val);
+}
+
+/* @} */
+
+
+/**************************************************************************//**
+ @Collection    Little-Endian Conversion Macros
+
+                These macros convert given parameters to or from Little-Endian
+                format. Use these macros when you want to read or write a specific
+                Little-Endian value in memory, without a-priori knowing the CPU
+                byte order.
+
+                These macros use the byte-swap routines. For conversion of
+                constants in initialization structures, you may use the CONST
+                versions of these macros (see below), which are using the
+                byte-swap macros instead.
+ @{
+*//***************************************************************************/
+
+#ifndef VERILOG
+/**************************************************************************//**
+ @Description   Converts a given 16-bit value from CPU byte order to
+                Little-Endian byte order.
+
+ @Param[in]     val - The 16-bit value to convert.
+
+ @Return        The converted value.
+
+ @hideinitializer
+*//***************************************************************************/
+#define CPU_TO_LE16(val)        SwapUint16(val)
+
+/**************************************************************************//**
+ @Description   Converts a given 32-bit value from CPU byte order to
+                Little-Endian byte order.
+
+ @Param[in]     val - The 32-bit value to convert.
+
+ @Return        The converted value.
+
+ @hideinitializer
+*//***************************************************************************/
+#define CPU_TO_LE32(val)        SwapUint32(val)
+
+/**************************************************************************//**
+ @Description   Converts a given 64-bit value from CPU byte order to
+                Little-Endian byte order.
+
+ @Param[in]     val - The 64-bit value to convert.
+
+ @Return        The converted value.
+
+ @hideinitializer
+*//***************************************************************************/
+#define CPU_TO_LE64(val)        SwapUint64(val)
+
+#else  /* VERILOG */
+#define CPU_TO_LE16(val)        (val)
+#define CPU_TO_LE32(val)        (val)
+#define CPU_TO_LE64(val)        (val)
+#endif /* VERILOG */
+
+/**************************************************************************//**
+ @Description   Converts a given 16-bit value from Little-Endian byte order to
+                CPU byte order.
+
+ @Param[in]     val - The 16-bit value to convert.
+
+ @Return        The converted value.
+
+ @hideinitializer
+*//***************************************************************************/
+#define LE16_TO_CPU(val)        CPU_TO_LE16(val)
+
+/**************************************************************************//**
+ @Description   Converts a given 32-bit value from Little-Endian byte order to
+                CPU byte order.
+
+ @Param[in]     val - The 32-bit value to convert.
+
+ @Return        The converted value.
+
+ @hideinitializer
+*//***************************************************************************/
+#define LE32_TO_CPU(val)        CPU_TO_LE32(val)
+
+/**************************************************************************//**
+ @Description   Converts a given 64-bit value from Little-Endian byte order to
+                CPU byte order.
+
+ @Param[in]     val - The 64-bit value to convert.
+
+ @Return        The converted value.
+
+ @hideinitializer
+*//***************************************************************************/
+#define LE64_TO_CPU(val)        CPU_TO_LE64(val)
+
+/* @} */
+
+/**************************************************************************//**
+ @Collection    Little-Endian Constant Conversion Macros
+
+                These macros convert given constants to or from Little-Endian
+                format. Use these macros when you want to read or write a specific
+                Little-Endian constant in memory, without a-priori knowing the
+                CPU byte order.
+
+                These macros use the byte-swap macros, therefore can be used for
+                conversion of constants in initialization structures.
+
+ @Cautions      The parameters of these macros are evaluated multiple times.
+                For non-constant expressions, use the non-CONST macro versions.
+
+ @{
+*//***************************************************************************/
+
+#ifndef VERILOG
+/**************************************************************************//**
+ @Description   Converts a given 16-bit constant from CPU byte order to
+                Little-Endian byte order.
+
+ @Param[in]     val - The 16-bit value to convert.
+
+ @Return        The converted value.
+
+ @hideinitializer
+*//***************************************************************************/
+#define CONST_CPU_TO_LE16(val)  SWAP_UINT16(val)
+
+/**************************************************************************//**
+ @Description   Converts a given 32-bit constant from CPU byte order to
+                Little-Endian byte order.
+
+ @Param[in]     val - The 32-bit value to convert.
+
+ @Return        The converted value.
+
+ @hideinitializer
+*//***************************************************************************/
+#define CONST_CPU_TO_LE32(val)  SWAP_UINT32(val)
+
+/**************************************************************************//**
+ @Description   Converts a given 64-bit constant from CPU byte order to
+                Little-Endian byte order.
+
+ @Param[in]     val - The 64-bit value to convert.
+
+ @Return        The converted value.
+
+ @hideinitializer
+*//***************************************************************************/
+#define CONST_CPU_TO_LE64(val)  SWAP_UINT64(val)
+
+#else  /* VERILOG */
+#define CONST_CPU_TO_LE16(val)  (val)
+#define CONST_CPU_TO_LE32(val)  (val)
+#define CONST_CPU_TO_LE64(val)  (val)
+#endif /* VERILOG */
+
+/**************************************************************************//**
+ @Description   Converts a given 16-bit constant from Little-Endian byte order
+                to CPU byte order.
+
+ @Param[in]     val - The 16-bit value to convert.
+
+ @Return        The converted value.
+
+ @hideinitializer
+*//***************************************************************************/
+#define CONST_LE16_TO_CPU(val)  CONST_CPU_TO_LE16(val)
+
+/**************************************************************************//**
+ @Description   Converts a given 32-bit constant from Little-Endian byte order
+                to CPU byte order.
+
+ @Param[in]     val - The 32-bit value to convert.
+
+ @Return        The converted value.
+
+ @hideinitializer
+*//***************************************************************************/
+#define CONST_LE32_TO_CPU(val)  CONST_CPU_TO_LE32(val)
+
+/**************************************************************************//**
+ @Description   Converts a given 64-bit constant from Little-Endian byte order
+                to CPU byte order.
+
+ @Param[in]     val - The 64-bit value to convert.
+
+ @Return        The converted value.
+
+ @hideinitializer
+*//***************************************************************************/
+#define CONST_LE64_TO_CPU(val)  CONST_CPU_TO_LE64(val)
+
+/* @} */
+
+
+/** @} */ /* end of endian_id group */
+/** @} */ /* end of gen_id group */
+
+
+#endif /* __ENDIAN_EXT_H */
+
diff --git a/drivers/net/dpa/NetCommSw/inc/enet_ext.h b/drivers/net/dpa/NetCommSw/inc/enet_ext.h
new file mode 100644
index 0000000..2ba5bf3
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/inc/enet_ext.h
@@ -0,0 +1,151 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**************************************************************************//**
+ @File          enet_ext.h
+
+ @Description   Ethernet generic definitions and enums.
+*//***************************************************************************/
+
+#ifndef __ENET_EXT_H
+#define __ENET_EXT_H
+
+
+#define ENET_NUM_OCTETS_PER_ADDRESS 6     /**< Number of octets (8-bit bytes) in an ethernet address */
+#define ENET_GROUP_ADDR             0x01  /**< Group address mask for ethernet addresses */
+
+
+/**************************************************************************//**
+ @Description   Ethernet Address
+*//***************************************************************************/
+typedef uint8_t t_EnetAddr[ENET_NUM_OCTETS_PER_ADDRESS];
+
+/**************************************************************************//**
+ @Description   Ethernet Address Type.
+*//***************************************************************************/
+typedef enum e_EnetAddrType
+{
+    e_ENET_ADDR_TYPE_INDIVIDUAL,    /**< Individual (unicast) address */
+    e_ENET_ADDR_TYPE_GROUP,         /**< Group (multicast) address */
+    e_ENET_ADDR_TYPE_BROADCAST      /**< Broadcast address */
+} e_EnetAddrType;
+
+
+/**************************************************************************//**
+ @Description   Ethernet MAC-PHY Interface
+*//***************************************************************************/
+typedef enum e_EnetInterface
+{
+    e_ENET_IF_MII   = 0x00010000,   /**< MII interface */
+    e_ENET_IF_RMII  = 0x00020000,   /**< RMII interface */
+    e_ENET_IF_SMII  = 0x00030000,   /**< SMII interface */
+    e_ENET_IF_GMII  = 0x00040000,   /**< GMII interface */
+    e_ENET_IF_RGMII = 0x00050000,   /**< RGMII interface */
+    e_ENET_IF_TBI   = 0x00060000,   /**< TBI interface */
+    e_ENET_IF_RTBI  = 0x00070000,   /**< RTBI interface */
+    e_ENET_IF_SGMII = 0x00080000,   /**< SGMII interface */
+    e_ENET_IF_XGMII = 0x00090000    /**< XGMII interface */
+} e_EnetInterface;
+
+/**************************************************************************//**
+ @Description   Ethernet Duplex Mode
+*//***************************************************************************/
+typedef enum e_EnetDuplexMode
+{
+    e_ENET_HALF_DUPLEX,             /**< Half-Duplex mode */
+    e_ENET_FULL_DUPLEX              /**< Full-Duplex mode */
+} e_EnetDuplexMode;
+
+/**************************************************************************//**
+ @Description   Ethernet Speed (nominal data rate)
+*//***************************************************************************/
+typedef enum e_EnetSpeed
+{
+    e_ENET_SPEED_10     = 10,       /**< 10 Mbps */
+    e_ENET_SPEED_100    = 100,      /**< 100 Mbps */
+    e_ENET_SPEED_1000   = 1000,     /**< 1000 Mbps = 1 Gbps */
+    e_ENET_SPEED_10000  = 10000     /**< 10000 Mbps = 10 Gbps */
+} e_EnetSpeed;
+
+/**************************************************************************//**
+ @Description   Ethernet mode (combination of MAC-PHY interface and speed)
+*//***************************************************************************/
+typedef enum e_EnetMode
+{
+    e_ENET_MODE_INVALID     = 0,                                        /**< Invalid Ethernet mode */
+    e_ENET_MODE_MII_10      = (e_ENET_IF_MII   | e_ENET_SPEED_10),      /**<    10 Mbps MII   */
+    e_ENET_MODE_MII_100     = (e_ENET_IF_MII   | e_ENET_SPEED_100),     /**<   100 Mbps MII   */
+    e_ENET_MODE_RMII_10     = (e_ENET_IF_RMII  | e_ENET_SPEED_10),      /**<    10 Mbps RMII  */
+    e_ENET_MODE_RMII_100    = (e_ENET_IF_RMII  | e_ENET_SPEED_100),     /**<   100 Mbps RMII  */
+    e_ENET_MODE_SMII_10     = (e_ENET_IF_SMII  | e_ENET_SPEED_10),      /**<    10 Mbps SMII  */
+    e_ENET_MODE_SMII_100    = (e_ENET_IF_SMII  | e_ENET_SPEED_100),     /**<   100 Mbps SMII  */
+    e_ENET_MODE_GMII_1000   = (e_ENET_IF_GMII  | e_ENET_SPEED_1000),    /**<  1000 Mbps GMII  */
+    e_ENET_MODE_RGMII_10    = (e_ENET_IF_RGMII | e_ENET_SPEED_10),      /**<    10 Mbps RGMII */
+    e_ENET_MODE_RGMII_100   = (e_ENET_IF_RGMII | e_ENET_SPEED_100),     /**<   100 Mbps RGMII */
+    e_ENET_MODE_RGMII_1000  = (e_ENET_IF_RGMII | e_ENET_SPEED_1000),    /**<  1000 Mbps RGMII */
+    e_ENET_MODE_TBI_1000    = (e_ENET_IF_TBI   | e_ENET_SPEED_1000),    /**<  1000 Mbps TBI   */
+    e_ENET_MODE_RTBI_1000   = (e_ENET_IF_RTBI  | e_ENET_SPEED_1000),    /**<  1000 Mbps RTBI  */
+    e_ENET_MODE_SGMII_10    = (e_ENET_IF_SGMII | e_ENET_SPEED_10),      /**<    10 Mbps SGMII */
+    e_ENET_MODE_SGMII_100   = (e_ENET_IF_SGMII | e_ENET_SPEED_100),     /**<   100 Mbps SGMII */
+    e_ENET_MODE_SGMII_1000  = (e_ENET_IF_SGMII | e_ENET_SPEED_1000),    /**<  1000 Mbps SGMII */
+    e_ENET_MODE_XGMII_10000 = (e_ENET_IF_XGMII | e_ENET_SPEED_10000)    /**< 10000 Mbps XGMII */
+} e_EnetMode;
+
+
+#define IS_ENET_MODE_VALID(mode) \
+        (((mode) == e_ENET_MODE_MII_10     ) || \
+         ((mode) == e_ENET_MODE_MII_100    ) || \
+         ((mode) == e_ENET_MODE_RMII_10    ) || \
+         ((mode) == e_ENET_MODE_RMII_100   ) || \
+         ((mode) == e_ENET_MODE_SMII_10    ) || \
+         ((mode) == e_ENET_MODE_SMII_100   ) || \
+         ((mode) == e_ENET_MODE_GMII_1000  ) || \
+         ((mode) == e_ENET_MODE_RGMII_10   ) || \
+         ((mode) == e_ENET_MODE_RGMII_100  ) || \
+         ((mode) == e_ENET_MODE_RGMII_1000 ) || \
+         ((mode) == e_ENET_MODE_TBI_1000   ) || \
+         ((mode) == e_ENET_MODE_RTBI_1000  ) || \
+         ((mode) == e_ENET_MODE_SGMII_10   ) || \
+         ((mode) == e_ENET_MODE_SGMII_100  ) || \
+         ((mode) == e_ENET_MODE_SGMII_1000 ) || \
+         ((mode) == e_ENET_MODE_XGMII_10000))
+
+
+#define MAKE_ENET_MODE(_interface, _speed)     (e_EnetMode)((_interface) | (_speed))
+
+#define ENET_INTERFACE_FROM_MODE(mode)          (e_EnetInterface)((mode) & 0xFFFF0000)
+#define ENET_SPEED_FROM_MODE(mode)              (e_EnetSpeed)((mode) & 0x0000FFFF)
+
+
+
+#endif /* __ENET_EXT_H */
+
diff --git a/drivers/net/dpa/NetCommSw/inc/error_ext.h b/drivers/net/dpa/NetCommSw/inc/error_ext.h
new file mode 100644
index 0000000..dc739d5
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/inc/error_ext.h
@@ -0,0 +1,538 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**
+ @File          error_ext.h
+
+ @Description   Error definitions.
+*//***************************************************************************/
+
+#ifndef __ERROR_EXT_H
+#define __ERROR_EXT_H
+
+#include "std_ext.h"
+#include "xx_ext.h"
+
+#ifdef VC
+#define __FUNCTION__    ""
+#endif
+
+
+
+/**************************************************************************//**
+ @Group         gen_id  General Drivers Utilities
+
+ @Description   External routines.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Group         gen_error_id  Errors, Events and Debug
+
+ @Description   External routines.
+
+ @{
+*//***************************************************************************/
+
+/******************************************************************************
+The scheme below provides the bits description for error codes:
+
+ 0    1    2    3    4    5    6    7    8    9    10   11   12   13   14   15
+|       Reserved (should be zero)      |              Module ID               |
+
+ 16   17   18   19   20   21   22   23   24   25   26   27   28   29   30   31
+|                               Error Type                                    |
+******************************************************************************/
+
+#define ERROR_CODE(_err)            ((((uint32_t)_err) & 0x0000FFFF) | __ERR_MODULE__)
+
+#define GET_ERROR_TYPE(_errcode)    ((_errcode) & 0x0000FFFF)
+                                /**< Extract module code from error code (#t_Error) */
+
+#define GET_ERROR_MODULE(_errcode)  ((_errcode) & 0x00FF0000)
+                                /**< Extract error type (#e_ErrorType) from
+                                     error code (#t_Error) */
+
+
+/**************************************************************************//**
+ @Description    Error Type Enumeration
+*//***************************************************************************/
+typedef enum e_ErrorType    /*   Comments / Associated Message Strings                      */
+{                           /* ------------------------------------------------------------ */
+    E_OK = 0                /*   Never use "RETURN_ERROR" with E_OK; Use "return E_OK;"     */
+
+    /* Invalid Function Calls */
+    ,E_INVALID_STATE        /**< The operation is not allowed in current module state.      */
+                            /*   String: none.                                              */
+    ,E_INVALID_OPERATION    /**< The operation/command is invalid (unrecognized).           */
+                            /*   String: none.                                              */
+    ,E_NOT_SUPPORTED        /**< The function is not supported or not implemented.          */
+                            /*   String: none.                                              */
+    ,E_NO_DEVICE            /**< The associated device is not initialized.                  */
+                            /*   String: none.                                              */
+
+    /* Invalid Parameters */
+    ,E_INVALID_HANDLE       /**< Invalid handle of module or object.                        */
+                            /*   String: none, unless the function takes in more than one
+                                 handle (in this case add the handle description)           */
+    ,E_INVALID_ID           /**< Invalid module ID (usually enumeration or index).          */
+                            /*   String: none, unless the function takes in more than one
+                                 ID (in this case add the ID description)                   */
+    ,E_NULL_POINTER         /**< Unexpected NULL pointer.                                   */
+                            /*   String: pointer description.                               */
+    ,E_INVALID_VALUE        /**< Invalid value.                                             */
+                            /*   Use for non-enumeration parameters, and
+                                 only when other error types are not suitable.
+                                 String: parameter description + "(should be <attribute>)",
+                                 e.g: "Maximum Rx buffer length (should be divisible by 8)",
+                                      "Channel number (should be even)".                    */
+    ,E_INVALID_SELECTION    /**< Invalid selection or mode.                                 */
+                            /*   Use for enumeration values, only when other error types
+                                 are not suitable.
+                                 String: parameter description.                             */
+    ,E_INVALID_COMM_MODE    /**< Invalid communication mode.                                */
+                            /*   String: none, unless the function takes in more than one
+                                 communication mode indications (in this case add
+                                 parameter description).                                    */
+    ,E_INVALID_BYTE_ORDER   /**< Invalid byte order.                                        */
+                            /*   String: none, unless the function takes in more than one
+                                 byte order indications (in this case add parameter
+                                 description).                                              */
+    ,E_INVALID_MEMORY_TYPE  /**< Invalid memory type.                                       */
+                            /*   String: none, unless the function takes in more than one
+                                 memory types (in this case add memory description,
+                                 e.g: "Data memory", "Buffer descriptors memory").          */
+    ,E_INVALID_INTR_QUEUE   /**< Invalid interrupt queue.                                   */
+                            /*   String: none, unless the function takes in more than one
+                                 interrupt queues (in this case add queue description,
+                                 e.g: "Rx interrupt queue", "Tx interrupt queue").          */
+    ,E_INVALID_PRIORITY     /**< Invalid priority.                                          */
+                            /*   String: none, unless the function takes in more than one
+                                 priority (in this case add priority description).          */
+    ,E_INVALID_CLOCK        /**< Invalid clock.                                             */
+                            /*   String: none, unless the function takes in more than one
+                                 clocks (in this case add clock description,
+                                 e.g: "Rx clock", "Tx clock").                              */
+    ,E_INVALID_RATE         /**< Invalid rate value.                                        */
+                            /*   String: none, unless the function takes in more than one
+                                 rate values (in this case add rate description).           */
+    ,E_INVALID_ADDRESS      /**< Invalid address.                                           */
+                            /*   String: description of the specific violation.             */
+    ,E_INVALID_BUS          /**< Invalid bus type.                                          */
+                            /*   String: none, unless the function takes in more than one
+                                 bus parameters (in this case add bus description).         */
+    ,E_BUS_CONFLICT         /**< Bus (or memory) type conflicts with another setting.       */
+                            /*   String: description of the conflicting buses/memories.     */
+    ,E_CONFLICT             /**< Some setting conflicts with another setting.               */
+                            /*   String: description of the conflicting settings.           */
+    ,E_NOT_ALIGNED          /**< Non-aligned address.                                       */
+                            /*   String: parameter description + "(should be %d-bytes aligned)",
+                                 e.g: "Rx data buffer (should be 32-bytes aligned)".        */
+    ,E_NOT_IN_RANGE         /**< Parameter value is out of range.                           */
+                            /*   Don't use this error for enumeration parameters.
+                                 String: parameter description + "(should be %d-%d)",
+                                 e.g: "Number of pad characters (should be 0-15)".          */
+
+    /* Frame/Buffer Errors */
+    ,E_INVALID_FRAME        /**< Invalid frame object (NULL handle or missing buffers).     */
+                            /*   String: none.                                              */
+    ,E_EMPTY_FRAME          /**< Frame object is empty (has no buffers).                    */
+                            /*   String: none.                                              */
+    ,E_EMPTY_BUFFER         /**< Buffer object is empty (no data, or zero data length).     */
+                            /*   String: none.                                              */
+
+    /* Resource Errors */
+    ,E_NO_MEMORY            /**< External memory allocation failed.                         */
+                            /*   String: description of item for which allocation failed.   */
+    ,E_NOT_FOUND            /**< Requested resource or item was not found.                  */
+                            /*   Use only when the resource/item is uniquely identified.
+                                 String: none, unless the operation is not the main goal
+                                 of the function (in this case add item description).       */
+    ,E_NOT_AVAILABLE        /**< Resource is unavailable.                                   */
+                            /*   String: none, unless the operation is not the main goal
+                                 of the function (in this case add resource description).   */
+    ,E_ALREADY_EXISTS       /**< Requested resource or item already exists.                 */
+                            /*   Use when resource duplication or sharing are not allowed.
+                                 String: none, unless the operation is not the main goal
+                                 of the function (in this case add item description).       */
+    ,E_FULL                 /**< Resource is full.                                          */
+                            /*   String: none, unless the operation is not the main goal
+                                 of the function (in this case add resource description).   */
+    ,E_EMPTY                /**< Resource is empty.                                         */
+                            /*   String: none, unless the operation is not the main goal
+                                 of the function (in this case add resource description).   */
+    ,E_BUSY                 /**< Resource or module is busy.                                */
+                            /*   String: none, unless the operation is not the main goal
+                                 of the function (in this case add resource description).   */
+    ,E_ALREADY_FREE         /**< Specified resource or item is already free or deleted.     */
+                            /*   String: none, unless the operation is not the main goal
+                                 of the function (in this case add item description).       */
+
+    /* Read/Write Access Errors */
+    ,E_READ_FAILED          /**< Read access failed on memory/device.                       */
+                            /*   String: none, or device name.                              */
+    ,E_WRITE_FAILED         /**< Write access failed on memory/device.                      */
+                            /*   String: none, or device name.                              */
+
+    /* Send/Receive Failures */
+    ,E_SEND_FAILED          /**< Send operation failed on device.                           */
+                            /*   String: none, or device name.                              */
+    ,E_RECEIVE_FAILED       /**< Receive operation failed on device.                        */
+                            /*   String: none, or device name.                              */
+
+    /* Operation time-out */
+    ,E_TIMEOUT              /**< The operation timed out.                                   */
+                            /*   String: none.                                              */
+
+    ,E_DUMMY_LAST           /* NEVER USED */
+
+} e_ErrorType;
+
+
+/**************************************************************************//**
+ @Description    Event Type Enumeration
+*//***************************************************************************/
+typedef enum e_Event        /*   Comments / Associated Flags and Message Strings            */
+{                           /* ------------------------------------------------------------ */
+    EV_NO_EVENT = 0         /**< No event; Never used.                                      */
+
+    ,EV_RX_DISCARD          /**< Received packet discarded (by the driver, and only for
+                                 complete packets);
+                                 Flags: error flags in case of error, zero otherwise.       */
+                            /*   String: reason for discard, e.g: "Error in frame",
+                                 "Disordered frame", "Incomplete frame", "No frame object". */
+    ,EV_RX_ERROR            /**< Receive error (by hardware/firmware);
+                                 Flags: usually status flags from the buffer descriptor.    */
+                            /*   String: none.                                              */
+    ,EV_TX_ERROR            /**< Transmit error (by hardware/firmware);
+                                 Flags: usually status flags from the buffer descriptor.    */
+                            /*   String: none.                                              */
+    ,EV_NO_BUFFERS          /**< System ran out of buffer objects;
+                                 Flags: zero.                                               */
+                            /*   String: none.                                              */
+    ,EV_NO_MB_FRAMES        /**< System ran out of multi-buffer frame objects;
+                                 Flags: zero.                                               */
+                            /*   String: none.                                              */
+    ,EV_NO_SB_FRAMES        /**< System ran out of single-buffer frame objects;
+                                 Flags: zero.                                               */
+                            /*   String: none.                                              */
+    ,EV_TX_QUEUE_FULL       /**< Transmit queue is full;
+                                 Flags: zero.                                               */
+                            /*   String: none.                                              */
+    ,EV_RX_QUEUE_FULL       /**< Receive queue is full;
+                                 Flags: zero.                                               */
+                            /*   String: none.                                              */
+    ,EV_INTR_QUEUE_FULL     /**< Interrupt queue overflow;
+                                 Flags: zero.                                               */
+                            /*   String: none.                                              */
+    ,EV_NO_DATA_BUFFER      /**< Data buffer allocation (from higher layer) failed;
+                                 Flags: zero.                                               */
+                            /*   String: none.                                              */
+    ,EV_OBJ_POOL_EMPTY      /**< Objects pool is empty;
+                                 Flags: zero.                                               */
+                            /*   String: object description (name).                         */
+    ,EV_BUS_ERROR           /**< Illegal access on bus;
+                                 Flags: the address (if available) or bus identifier        */
+                            /*   String: bus/address/module description.                    */
+    ,EV_PTP_TXTS_QUEUE_FULL /**< PTP Tx timestamps queue is full;
+                                 Flags: zero.                                               */
+                            /*   String: none.                                              */
+    ,EV_PTP_RXTS_QUEUE_FULL /**< PTP Rx timestamps queue is full;
+                                 Flags: zero.                                               */
+                            /*   String: none.                                              */
+    ,EV_DUMMY_LAST
+
+} e_Event;
+
+
+/**************************************************************************//**
+ @Collection    Debug Levels for Errors and Events
+
+                The level description refers to errors only.
+                For events, classification is done by the user.
+
+                The TRACE, INFO and WARNING levels are allowed only when using
+                the DBG macro, and are not allowed when using the error macros
+                (RETURN_ERROR or REPORT_ERROR).
+ @{
+*//***************************************************************************/
+#define REPORT_LEVEL_CRITICAL   1       /**< Crasher: Incorrect flow, NULL pointers/handles. */
+#define REPORT_LEVEL_MAJOR      2       /**< Cannot proceed: Invalid operation, parameters or
+                                             configuration. */
+#define REPORT_LEVEL_MINOR      3       /**< Recoverable problem: a repeating call with the same
+                                             parameters may be successful. */
+#define REPORT_LEVEL_WARNING    4       /**< Something is not exactly right, yet it is not an error. */
+#define REPORT_LEVEL_INFO       5       /**< Messages which may be of interest to user/programmer. */
+#define REPORT_LEVEL_TRACE      6       /**< Program flow messages. */
+
+#define EVENT_DISABLED          0xFF    /**< Disabled event (not reported at all) */
+
+/* @} */
+
+
+
+#define NO_MSG      ("")
+
+#ifndef EVENT_GLOBAL_LEVEL
+#define EVENT_GLOBAL_LEVEL  REPORT_LEVEL_MINOR
+#endif
+
+#ifdef EVENT_LOCAL_LEVEL
+#define EVENT_DYNAMIC_LEVEL EVENT_LOCAL_LEVEL
+#else
+#define EVENT_DYNAMIC_LEVEL EVENT_GLOBAL_LEVEL
+#endif
+
+
+#ifndef DEBUG_GLOBAL_LEVEL
+#define DEBUG_GLOBAL_LEVEL  REPORT_LEVEL_WARNING
+#endif
+
+#ifndef DEBUG_DYNAMIC_LEVEL
+
+#define DEBUG_USING_STATIC_LEVEL
+
+#ifdef DEBUG_STATIC_LEVEL
+#define DEBUG_DYNAMIC_LEVEL DEBUG_STATIC_LEVEL
+#else
+#define DEBUG_DYNAMIC_LEVEL DEBUG_GLOBAL_LEVEL
+#endif
+
+#else /* DEBUG_DYNAMIC_LEVEL */
+
+#ifdef DEBUG_STATIC_LEVEL
+#error "Please use either DEBUG_STATIC_LEVEL or DEBUG_DYNAMIC_LEVEL (not both)"
+#else
+int DEBUG_DYNAMIC_LEVEL = DEBUG_GLOBAL_LEVEL;
+#endif /* DEBUG_STATIC_LEVEL */
+
+#endif /* DEBUG_DYNAMIC_LEVEL */
+
+
+#if (!(defined(DEBUG_ERRORS)) || (DEBUG_ERRORS == 0))
+/* No debug/error/event messages at all */
+#define DBG(_level, _vmsg)
+
+#define REPORT_ERROR(_level, _err, _vmsg)
+
+#define RETURN_ERROR(_level, _err, _vmsg) \
+        return ERROR_CODE(_err)
+
+#if (REPORT_EVENTS > 0)
+
+#define REPORT_EVENT(_ev, _appId, _flg, _vmsg) \
+    do { \
+        if (_ev##_LEVEL <= EVENT_DYNAMIC_LEVEL) { \
+            XX_EventById((uint32_t)(_ev), (t_Handle)(_appId), (uint16_t)(_flg), NO_MSG); \
+        } \
+    } while (0)
+
+#else
+
+#define REPORT_EVENT(_ev, _appId, _flg, _vmsg)
+
+#endif /* (REPORT_EVENTS > 0) */
+
+
+#else /* DEBUG_ERRORS > 0 */
+
+extern const char *dbgLevelStrings[];
+extern const char *errTypeStrings[];
+extern const char *moduleStrings[];
+#if (REPORT_EVENTS > 0)
+extern const char *eventStrings[];
+#endif /* (REPORT_EVENTS > 0) */
+
+
+#if ((defined(DEBUG_USING_STATIC_LEVEL)) && (DEBUG_DYNAMIC_LEVEL < REPORT_LEVEL_WARNING))
+/* No need for DBG macro - debug level is higher anyway */
+#define DBG(_level, _vmsg)
+#else
+#define DBG(_level, _vmsg) \
+    do { \
+        if (REPORT_LEVEL_##_level <= DEBUG_DYNAMIC_LEVEL) { \
+            XX_Print("> %s (%s) [%s:%d %s]: ", \
+                     dbgLevelStrings[REPORT_LEVEL_##_level - 1], \
+                     moduleStrings[__ERR_MODULE__ >> 16], \
+                     __FILE__, __LINE__, __FUNCTION__); \
+            XX_Print _vmsg; \
+            XX_Print("\r\n"); \
+        } \
+    } while (0)
+#endif /* (defined(DEBUG_USING_STATIC_LEVEL) && (DEBUG_DYNAMIC_LEVEL < WARNING)) */
+
+
+#define REPORT_ERROR(_level, _err, _vmsg) \
+    do { \
+        if (REPORT_LEVEL_##_level <= DEBUG_DYNAMIC_LEVEL) { \
+            XX_Print("! %s %s Error [%s:%d %s]: %s; ", \
+                     dbgLevelStrings[REPORT_LEVEL_##_level - 1], \
+                     moduleStrings[__ERR_MODULE__ >> 16], \
+                     __FILE__, __LINE__, __FUNCTION__, \
+                     errTypeStrings[(GET_ERROR_TYPE(_err) - E_OK - 1)]); \
+            XX_Print _vmsg; \
+            XX_Print("\r\n"); \
+        } \
+    } while (0)
+
+
+#define RETURN_ERROR(_level, _err, _vmsg) \
+    do { \
+        REPORT_ERROR(_level, (_err), _vmsg); \
+        return ERROR_CODE(_err); \
+    } while (0)
+
+
+#if (REPORT_EVENTS > 0)
+
+#define REPORT_EVENT(_ev, _appId, _flg, _vmsg) \
+    do { \
+        if (_ev##_LEVEL <= EVENT_DYNAMIC_LEVEL) { \
+            XX_Print("~ %s %s Event [%s:%d %s]: %s (flags: 0x%04x); ", \
+                     dbgLevelStrings[_ev##_LEVEL - 1], \
+                     moduleStrings[__ERR_MODULE__ >> 16], \
+                     __FILE__, __LINE__, __FUNCTION__, \
+                     eventStrings[((_ev) - EV_NO_EVENT - 1)], \
+                     (uint16_t)(_flg)); \
+            XX_Print _vmsg; \
+            XX_Print("\r\n"); \
+            XX_EventById((uint32_t)(_ev), (t_Handle)(_appId), (uint16_t)(_flg), NO_MSG); \
+        } \
+    } while (0)
+
+#else /* not REPORT_EVENTS */
+
+#define REPORT_EVENT(_ev, _appId, _flg, _vmsg)
+
+#endif /* (REPORT_EVENTS > 0) */
+
+#endif /* (DEBUG_ERRORS > 0) */
+
+
+/**************************************************************************//**
+ @Function      ASSERT_COND
+
+ @Description   Assertion macro.
+
+ @Param[in]     _cond - The condition being checked, in positive form;
+                        Failure of the condition triggers the assert.
+*//***************************************************************************/
+#ifdef DISABLE_ASSERTIONS
+#define ASSERT_COND(_cond)
+#else
+#define ASSERT_COND(_cond) \
+    do { \
+        if (!(_cond)) { \
+            XX_Print("*** ASSERT_COND failed [%s:%d %s]\r\n", \
+                     __FILE__, __LINE__, __FUNCTION__); \
+            XX_Exit(1); \
+        } \
+    } while (0)
+#endif /* DISABLE_ASSERTIONS */
+
+
+#ifdef DISABLE_INIT_PARAMETERS_CHECK
+
+#define CHECK_INIT_PARAMETERS(handle, f_check)
+#define CHECK_INIT_PARAMETERS_RETURN_VALUE(handle, f_check, retval)
+
+#else
+
+#define CHECK_INIT_PARAMETERS(handle, f_check) \
+    do { \
+        t_Error err = f_check(handle); \
+        if (err != E_OK) { \
+            RETURN_ERROR(MAJOR, err, NO_MSG); \
+        } \
+    } while (0)
+
+#define CHECK_INIT_PARAMETERS_RETURN_VALUE(handle, f_check, retval) \
+    do { \
+        t_Error err = f_check(handle); \
+        if (err != E_OK) { \
+            REPORT_ERROR(MAJOR, err, NO_MSG); \
+            return (retval); \
+        } \
+    } while (0)
+
+#endif /* DISABLE_INIT_PARAMETERS_CHECK */
+
+#ifdef DISABLE_SANITY_CHECKS
+
+#define SANITY_CHECK_RETURN_ERROR(_cond, _err)
+#define SANITY_CHECK_RETURN_VALUE(_cond, _err, retval)
+#define SANITY_CHECK_RETURN(_cond, _err)
+#define SANITY_CHECK_EXIT(_cond, _err)
+
+#else /* DISABLE_SANITY_CHECKS */
+
+#define SANITY_CHECK_RETURN_ERROR(_cond, _err) \
+    do { \
+        if (!(_cond)) { \
+            RETURN_ERROR(CRITICAL, (_err), NO_MSG); \
+        } \
+    } while (0)
+
+#define SANITY_CHECK_RETURN_VALUE(_cond, _err, retval) \
+    do { \
+        if (!(_cond)) { \
+            REPORT_ERROR(CRITICAL, (_err), NO_MSG); \
+            return (retval); \
+        } \
+    } while (0)
+
+#define SANITY_CHECK_RETURN(_cond, _err) \
+    do { \
+        if (!(_cond)) { \
+            REPORT_ERROR(CRITICAL, (_err), NO_MSG); \
+            return; \
+        } \
+    } while (0)
+
+#define SANITY_CHECK_EXIT(_cond, _err) \
+    do { \
+        if (!(_cond)) { \
+            REPORT_ERROR(CRITICAL, (_err), NO_MSG); \
+            XX_Exit(1); \
+        } \
+    } while (0)
+
+#endif /* DISABLE_SANITY_CHECKS */
+
+/** @} */ /* end of Debug/error Utils group */
+
+/** @} */ /* end of General Utils group */
+
+#endif /* __ERROR_EXT_H */
+
+
diff --git a/drivers/net/dpa/NetCommSw/inc/etc/list_ext.h b/drivers/net/dpa/NetCommSw/inc/etc/list_ext.h
new file mode 100644
index 0000000..5325ee1
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/inc/etc/list_ext.h
@@ -0,0 +1,357 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**************************************************************************//**
+
+ @File          list_ext.h
+
+ @Description   External prototypes for list.c
+*//***************************************************************************/
+
+#ifndef __LIST_EXT_H
+#define __LIST_EXT_H
+
+
+#include "std_ext.h"
+
+
+/**************************************************************************//**
+ @Group         etc_id   Utility Library Application Programming Interface
+
+ @Description   External routines.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Group         list_id List
+
+ @Description   List module functions,definitions and enums.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description   List structure.
+*//***************************************************************************/
+typedef struct List
+{
+    struct List *p_Next;  /**< A pointer to the next list object     */
+    struct List *p_Prev;  /**< A pointer to the previous list object */
+} t_List;
+
+
+/**************************************************************************//**
+ @Function      LIST_FIRST/LIST_LAST/LIST_NEXT/LIST_PREV
+
+ @Description   Macro to get first/last/next/previous entry in a list.
+
+ @Param[in]     p_List - A pointer to a list.
+*//***************************************************************************/
+#define LIST_FIRST(p_List) (p_List)->p_Next
+#define LIST_LAST(p_List)  (p_List)->p_Prev
+#define LIST_NEXT          LIST_FIRST
+#define LIST_PREV          LIST_LAST
+
+
+/**************************************************************************//**
+ @Function      LIST_INIT
+
+ @Description   Macro for initialization of a list struct.
+
+ @Param[in]     lst - The t_List object to initialize.
+*//***************************************************************************/
+#define LIST_INIT(lst) {&(lst), &(lst)}
+
+
+/**************************************************************************//**
+ @Function      LIST
+
+ @Description   Macro to declare of a list.
+
+ @Param[in]     listName - The list object name.
+*//***************************************************************************/
+#define LIST(listName) t_List listName = LIST_INIT(listName)
+
+
+/**************************************************************************//**
+ @Function      INIT_LIST
+
+ @Description   Macro to initialize a list pointer.
+
+ @Param[in]     p_List - The list pointer.
+*//***************************************************************************/
+#define INIT_LIST(p_List)   LIST_FIRST(p_List) = LIST_LAST(p_List) = (p_List)
+
+
+/**************************************************************************//**
+ @Function      LIST_OBJECT
+
+ @Description   Macro to get the struct (object) for this entry.
+
+ @Param[in]     type   - The type of the struct (object) this list is embedded in.
+ @Param[in]     member - The name of the t_List object within the struct.
+
+ @Return        The structure pointer for this entry.
+*//***************************************************************************/
+#define MEMBER_OFFSET(type, member) ((uint32_t)(&((type *)0)->member))
+#define LIST_OBJECT(p_List, type, member) \
+    ((type *)((char *)(p_List)-MEMBER_OFFSET(type, member)))
+
+
+/**************************************************************************//**
+ @Function      LIST_FOR_EACH
+
+ @Description   Macro to iterate over a list.
+
+ @Param[in]     p_Pos  - A pointer to a list to use as a loop counter.
+ @Param[in]     p_Head - A pointer to the head for your list pointer.
+
+ @Cautions      You can't delete items with this routine.
+                For deletion use LIST_FOR_EACH_SAFE().
+*//***************************************************************************/
+#define LIST_FOR_EACH(p_Pos, p_Head) \
+    for (p_Pos = LIST_FIRST(p_Head); p_Pos != (p_Head); p_Pos = LIST_NEXT(p_Pos))
+
+
+/**************************************************************************//**
+ @Function      LIST_FOR_EACH_SAFE
+
+ @Description   Macro to iterate over a list safe against removal of list entry.
+
+ @Param[in]     p_Pos  - A pointer to a list to use as a loop counter.
+ @Param[in]     p_Tmp  - Another pointer to a list to use as temporary storage.
+ @Param[in]     p_Head - A pointer to the head for your list pointer.
+*//***************************************************************************/
+#define LIST_FOR_EACH_SAFE(p_Pos, p_Tmp, p_Head)                \
+    for (p_Pos = LIST_FIRST(p_Head), p_Tmp = LIST_FIRST(p_Pos); \
+         p_Pos != (p_Head);                                     \
+         p_Pos = p_Tmp, p_Tmp = LIST_NEXT(p_Pos))
+
+
+/**************************************************************************//**
+ @Function      LIST_FOR_EACH_OBJECT_SAFE
+
+ @Description   Macro to iterate over list of given type safely.
+
+ @Param[in]     p_Pos  - A pointer to a list to use as a loop counter.
+ @Param[in]     p_Tmp  - Another pointer to a list to use as temporary storage.
+ @Param[in]     type   - The type of the struct this is embedded in.
+ @Param[in]     p_Head - A pointer to the head for your list pointer.
+ @Param[in]     member - The name of the list_struct within the struct.
+
+ @Cautions      You can't delete items with this routine.
+                For deletion use LIST_FOR_EACH_SAFE().
+*//***************************************************************************/
+#define LIST_FOR_EACH_OBJECT_SAFE(p_Pos, p_Tmp, p_Head, type, member)      \
+    for (p_Pos = LIST_OBJECT(LIST_FIRST(p_Head), type, member),            \
+         p_Tmp = LIST_OBJECT(LIST_FIRST(&p_Pos->member), type, member);    \
+         &p_Pos->member != (p_Head);                                       \
+         p_Pos = p_Tmp,                                                    \
+         p_Tmp = LIST_OBJECT(LIST_FIRST(&p_Pos->member), type, member))
+
+/**************************************************************************//**
+ @Function      LIST_FOR_EACH_OBJECT
+
+ @Description   Macro to iterate over list of given type.
+
+ @Param[in]     p_Pos  - A pointer to a list to use as a loop counter.
+ @Param[in]     type   - The type of the struct this is embedded in.
+ @Param[in]     p_Head - A pointer to the head for your list pointer.
+ @Param[in]     member - The name of the list_struct within the struct.
+
+ @Cautions      You can't delete items with this routine.
+                For deletion use LIST_FOR_EACH_SAFE().
+*//***************************************************************************/
+#define LIST_FOR_EACH_OBJECT(p_Pos, type, p_Head, member)                  \
+    for (p_Pos = LIST_OBJECT(LIST_FIRST(p_Head), type, member);            \
+         &p_Pos->member != (p_Head);                                       \
+         p_Pos = LIST_OBJECT(LIST_FIRST(&(p_Pos->member)), type, member))
+
+
+/**************************************************************************//**
+ @Function      LIST_Add
+
+ @Description   Add a new entry to a list.
+
+                Insert a new entry after the specified head.
+                This is good for implementing stacks.
+
+ @Param[in]     p_New  - A pointer to a new list entry to be added.
+ @Param[in]     p_Head - A pointer to a list head to add it after.
+
+ @Return        none.
+*//***************************************************************************/
+static __inline__ void LIST_Add(t_List *p_New, t_List *p_Head)
+{
+    LIST_PREV(LIST_NEXT(p_Head)) = p_New;
+    LIST_NEXT(p_New)             = LIST_NEXT(p_Head);
+    LIST_PREV(p_New)             = p_Head;
+    LIST_NEXT(p_Head)            = p_New;
+}
+
+
+/**************************************************************************//**
+ @Function      LIST_AddToTail
+
+ @Description   Add a new entry to a list.
+
+                Insert a new entry before the specified head.
+                This is useful for implementing queues.
+
+ @Param[in]     p_New  - A pointer to a new list entry to be added.
+ @Param[in]     p_Head - A pointer to a list head to add it after.
+
+ @Return        none.
+*//***************************************************************************/
+static __inline__ void LIST_AddToTail(t_List *p_New, t_List *p_Head)
+{
+    LIST_NEXT(LIST_PREV(p_Head)) = p_New;
+    LIST_PREV(p_New)             = LIST_PREV(p_Head);
+    LIST_NEXT(p_New)             = p_Head;
+    LIST_PREV(p_Head)            = p_New;
+}
+
+
+/**************************************************************************//**
+ @Function      LIST_Del
+
+ @Description   Deletes entry from a list.
+
+ @Param[in]     p_Entry - A pointer to the element to delete from the list.
+
+ @Return        none.
+
+ @Cautions      LIST_IsEmpty() on entry does not return true after this,
+                the entry is in an undefined state.
+*//***************************************************************************/
+static __inline__ void LIST_Del(t_List *p_Entry)
+{
+    LIST_PREV(LIST_NEXT(p_Entry)) = LIST_PREV(p_Entry);
+    LIST_NEXT(LIST_PREV(p_Entry)) = LIST_NEXT(p_Entry);
+}
+
+
+/**************************************************************************//**
+ @Function      LIST_DelAndInit
+
+ @Description   Deletes entry from list and reinitialize it.
+
+ @Param[in]     p_Entry - A pointer to the element to delete from the list.
+
+ @Return        none.
+*//***************************************************************************/
+static __inline__ void LIST_DelAndInit(t_List *p_Entry)
+{
+    LIST_Del(p_Entry);
+    INIT_LIST(p_Entry);
+}
+
+
+/**************************************************************************//**
+ @Function      LIST_Move
+
+ @Description   Delete from one list and add as another's head.
+
+ @Param[in]     p_Entry - A pointer to the list entry to move.
+ @Param[in]     p_Head  - A pointer to the list head that will precede our entry.
+
+ @Return        none.
+*//***************************************************************************/
+static __inline__ void LIST_Move(t_List *p_Entry, t_List *p_Head)
+{
+    LIST_Del(p_Entry);
+    LIST_Add(p_Entry, p_Head);
+}
+
+
+/**************************************************************************//**
+ @Function      LIST_MoveToTail
+
+ @Description   Delete from one list and add as another's tail.
+
+ @Param[in]     p_Entry - A pointer to the entry to move.
+ @Param[in]     p_Head  - A pointer to the list head that will follow our entry.
+
+ @Return        none.
+*//***************************************************************************/
+static __inline__ void LIST_MoveToTail(t_List *p_Entry, t_List *p_Head)
+{
+    LIST_Del(p_Entry);
+    LIST_AddToTail(p_Entry, p_Head);
+}
+
+
+/**************************************************************************//**
+ @Function      LIST_IsEmpty
+
+ @Description   Tests whether a list is empty.
+
+ @Param[in]     p_List - A pointer to the list to test.
+
+ @Return        1 if the list is empty, 0 otherwise.
+*//***************************************************************************/
+static __inline__ int LIST_IsEmpty(t_List *p_List)
+{
+    return (LIST_FIRST(p_List) == p_List);
+}
+
+
+/**************************************************************************//**
+ @Function      LIST_Append
+
+ @Description   Join two lists.
+
+ @Param[in]     p_NewList - A pointer to the new list to add.
+ @Param[in]     p_Head    - A pointer to the place to add it in the first list.
+
+ @Return        none.
+*//***************************************************************************/
+void LIST_Append(t_List *p_NewList, t_List *p_Head);
+
+
+/**************************************************************************//**
+ @Function      LIST_NumOfObjs
+
+ @Description   Counts number of objects in the list
+
+ @Param[in]     p_List - A pointer to the list which objects are to be counted.
+
+ @Return        Number of objects in the list.
+*//***************************************************************************/
+int LIST_NumOfObjs(t_List *p_List);
+
+/** @} */ /* end of list_id group */
+/** @} */ /* end of etc_id group */
+
+
+#endif /* __LIST_EXT_H */
diff --git a/drivers/net/dpa/NetCommSw/inc/etc/mem_ext.h b/drivers/net/dpa/NetCommSw/inc/etc/mem_ext.h
new file mode 100644
index 0000000..7e41c56
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/inc/etc/mem_ext.h
@@ -0,0 +1,324 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**************************************************************************//**
+
+ @File          mem_ext.h
+
+ @Description   External prototypes for the memory manager object
+*//***************************************************************************/
+
+#ifndef __MEM_EXT_H
+#define __MEM_EXT_H
+
+#include "std_ext.h"
+#include "part_ext.h"
+
+
+/**************************************************************************//**
+ @Group         etc_id   Utility Library Application Programming Interface
+
+ @Description   External routines.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Group         mem_id   Slab Memory Manager
+
+ @Description   Slab Memory Manager module functions, definitions and enums.
+
+ @{
+*//***************************************************************************/
+
+/* Each block is of the following structure:
+ *
+ *
+ *  +-----------+----------+---------------------------+-----------+-----------+
+ *  | Alignment |  Prefix  | Data                      | Postfix   | Alignment |
+ *  |  field    |   field  |  field                    |   field   | Padding   |
+ *  |           |          |                           |           |           |
+ *  +-----------+----------+---------------------------+-----------+-----------+
+ *  and at the beginning of all bytes, an additional optional padding might reside
+ *  to ensure that the first blocks data field is aligned as requested.
+ */
+
+
+#define MEM_MAX_NAME_LENGTH     4
+
+/**************************************************************************//*
+ @Description   Memory Segment structure
+*//***************************************************************************/
+
+typedef struct
+{
+    char        name[MEM_MAX_NAME_LENGTH];
+                                    /* The segment's name */
+    uint16_t    dataSize;           /* Size of each data block */
+    uint32_t    getFailures;        /* Number of times get failed */
+    int         allocOwner;         /* Memory allocation owner */
+    uint8_t     **p_Bases;          /* Base addresses of the segments */
+    uint8_t     **p_BlocksStack;    /* Array of pointers to blocks */
+    uint32_t    num;                /* Number of blocks in segment */
+    uint32_t    current;            /* Current block */
+    uint16_t    prefixSize;         /* How many bytes to reserve before the data */
+    uint16_t    postfixSize;        /* How many bytes to reserve after the data */
+    uint16_t    alignment;          /* Requested alignment for the data field */
+    bool        consecutiveMem;     /* Allocate consecutive data blocks memory */
+#ifdef DEBUG_MEM_LEAKS
+    void        *p_MemDbg;          /* MEM debug database (MEM leaks detection) */
+    uint32_t    blockOffset;
+    uint32_t    blockSize;
+#endif /* DEBUG_MEM_LEAKS */
+
+} t_MemorySegment;
+
+
+
+/**************************************************************************//**
+ @Function      MEM_Init
+
+ @Description   Create a new memory segment.
+
+ @Param[in]     name        - Name of memory partition.
+ @Param[in]     p_Handle    - Handle to new segment is returned through here.
+ @Param[in]     num         - Number of blocks in new segment.
+ @Param[in]     dataSize    - Size of blocks in segment.
+ @Param[in]     prefixSize  - How many bytes to allocate before the data.
+ @Param[in]     postfixSize - How many bytes to allocate after the data.
+ @Param[in]     alignment   - Requested alignment for data field.
+
+ @Return        E_OK - success, E_NO_MEMORY - out of memory.
+*//***************************************************************************/
+t_Error MEM_Init(char     name[],
+                 t_Handle *p_Handle,
+                 uint32_t num,
+                 uint16_t dataSize,
+                 uint16_t prefixSize,
+                 uint16_t postfixSize,
+                 uint16_t alignment);
+
+/**************************************************************************//**
+ @Function      MEM_InitSmart
+
+ @Description   Create a new memory segment.
+
+ @Param[in]     name            - Name of memory partition.
+ @Param[in]     p_Handle        - Handle to new segment is returned through here.
+ @Param[in]     num             - Number of blocks in new segment.
+ @Param[in]     dataSize        - Size of blocks in segment.
+ @Param[in]     prefixSize      - How many bytes to allocate before the data.
+ @Param[in]     postfixSize     - How many bytes to allocate after the data.
+ @Param[in]     alignment       - Requested alignment for data field.
+ @Param[in]     memPartitionId  - Memory partition ID for allocation.
+ @Param[in]     consecutiveMem  - Whether to allocate the memory blocks
+                                  continuously or not.
+
+ @Return        E_OK - success, E_NO_MEMORY - out of memory.
+*//***************************************************************************/
+t_Error MEM_InitSmart(char      name[],
+                      t_Handle  *p_Handle,
+                      uint32_t  num,
+                      uint16_t  dataSize,
+                      uint16_t  prefixSize,
+                      uint16_t  postfixSize,
+                      uint16_t  alignment,
+                      uint8_t   memPartitionId,
+                      bool      consecutiveMem);
+
+/**************************************************************************//**
+ @Function      MEM_InitByAddress
+
+ @Description   Create a new memory segment with a specified base address.
+
+ @Param[in]     name        - Name of memory partition.
+ @Param[in]     p_Handle    - Handle to new segment is returned through here.
+ @Param[in]     num         - Number of blocks in new segment.
+ @Param[in]     dataSize    - Size of blocks in segment.
+ @Param[in]     prefixSize  - How many bytes to allocate before the data.
+ @Param[in]     postfixSize - How many bytes to allocate after the data.
+ @Param[in]     alignment   - Requested alignment for data field.
+ @Param[in]     address     - The required base address.
+
+ @Return        E_OK - success, E_NO_MEMORY - out of memory.
+ *//***************************************************************************/
+t_Error MEM_InitByAddress(char        name[],
+                          t_Handle    *p_Handle,
+                          uint32_t    num,
+                          uint16_t    dataSize,
+                          uint16_t    prefixSize,
+                          uint16_t    postfixSize,
+                          uint16_t    alignment,
+                          uint8_t     *address);
+
+/**************************************************************************//**
+ @Function      MEM_Free
+
+ @Description   Free a specific memory segment.
+
+ @Param[in]     h_Mem - Handle to memory segment.
+
+ @Return        None.
+*//***************************************************************************/
+void MEM_Free(t_Handle h_Mem);
+
+/**************************************************************************//**
+ @Function      MEM_Get
+
+ @Description   Get a block of memory from a segment.
+
+ @Param[in]     h_Mem - Handle to memory segment.
+
+ @Return        Pointer to new memory block on success,0 otherwise.
+*//***************************************************************************/
+void * MEM_Get(t_Handle h_Mem);
+
+/**************************************************************************//**
+ @Function      MEM_GetN
+
+ @Description   Get up to N blocks of memory from a segment.
+
+                The blocks are assumed to be of a fixed size (one size per segment).
+
+ @Param[in]     h_Mem   - Handle to memory segment.
+ @Param[in]     num     - Number of blocks to allocate.
+ @Param[out]    array   - Array of at least num pointers to which the addresses
+                          of the allocated blocks are written.
+
+ @Return        The number of blocks actually allocated.
+
+ @Cautions      Interrupts are disabled for all of the allocation loop.
+                Although this loop is very short for each block (several machine
+                instructions), you should not allocate a very large number
+                of blocks via this routine.
+*//***************************************************************************/
+uint16_t MEM_GetN(t_Handle h_Mem, uint32_t num, void *array[]);
+
+/**************************************************************************//**
+ @Function      MEM_Put
+
+ @Description   Put a block of memory back to a segment.
+
+ @Param[in]     h_Mem   - Handle to memory segment.
+ @Param[in]     p_Block - The block to return.
+
+ @Return        Pointer to new memory block on success,0 otherwise.
+*//***************************************************************************/
+t_Error MEM_Put(t_Handle h_Mem, void *p_Block);
+
+
+
+/**************************************************************************//**
+ @Function      MEM_ComputePartitionSize
+
+ @Description   calculate a tight upper boundary of the size of a partition with
+                given attributes.
+
+                The returned value is suitable if one wants to use MEM_InitByAddress().
+
+ @Param[in]     num         - The number of blocks in the segment.
+ @Param[in]     dataSize    - Size of block to get.
+ @Param[in]     prefixSize  - The prefix size
+ @Param         postfixSize - The postfix size
+ @Param[in]     alignment   - The requested alignment value
+
+ @Return        The memory block size a segment with the given attributes needs.
+*//***************************************************************************/
+uint32_t MEM_ComputePartitionSize(uint32_t num,
+                                  uint16_t dataSize,
+                                  uint16_t prefixSize,
+                                  uint16_t postfixSize,
+                                  uint16_t alignment);
+
+
+#ifdef DEBUG_MEM_LEAKS
+
+#if !(defined(__MWERKS__) && (__dest_os == __ppc_eabi))
+#error  "Memory-Leaks-Debug option is supported only for freescale CodeWarrior"
+#endif /* __MWERKS__ */
+/**************************************************************************//**
+ @Function      MEM_CheckLeaks
+
+ @Description   Report MEM object leaks.
+
+                This routine is automatically called by the MEM_Free() routine,
+                but it can also be invoked while the MEM object is alive.
+
+ @Param[in]     h_Mem - Handle to memory segment.
+
+ @Return        None.
+*//***************************************************************************/
+void MEM_CheckLeaks(t_Handle h_Mem);
+
+#else  /* not DEBUG_MEM_LEAKS */
+
+#define MEM_CheckLeaks(h_Mem)
+
+#endif /* not DEBUG_MEM_LEAKS */
+
+
+/**************************************************************************//**
+ @Description   Get base of MEM
+*//***************************************************************************/
+#define MEM_GetBase(h_Mem)             ((t_MemorySegment *)(h_Mem))->p_Bases[0]
+
+/**************************************************************************//**
+ @Description   Get size of MEM block
+*//***************************************************************************/
+#define MEM_GetSize(h_Mem)             ((t_MemorySegment *)(h_Mem))->dataSize
+
+/**************************************************************************//**
+ @Description   Get prefix size of MEM block
+*//***************************************************************************/
+#define MEM_GetPrefixSize(h_Mem)       ((t_MemorySegment *)(h_Mem))->prefixSize
+
+/**************************************************************************//**
+ @Description   Get postfix size of MEM block
+*//***************************************************************************/
+#define MEM_GetPostfixSize(h_Mem)      ((t_MemorySegment *)(h_Mem))->postfixSize
+
+/**************************************************************************//**
+ @Description   Get alignment of MEM block
+*//***************************************************************************/
+#define MEM_GetAlignment(h_Mem)        ((t_MemorySegment *)(h_Mem))->alignment
+
+/**************************************************************************//**
+ @Description   Get the number of blocks in the segment
+*//***************************************************************************/
+#define MEM_GetNumOfBlocks(h_Mem)             ((t_MemorySegment *)(h_Mem))->num
+
+
+/** @} */ /* end of MEM group */
+/** @} */ /* end of etc_id group */
+
+
+#endif /* __MEM_EXT_H */
diff --git a/drivers/net/dpa/NetCommSw/inc/etc/memcpy_ext.h b/drivers/net/dpa/NetCommSw/inc/etc/memcpy_ext.h
new file mode 100644
index 0000000..5de41be
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/inc/etc/memcpy_ext.h
@@ -0,0 +1,173 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**************************************************************************//**
+
+ @File          memcpy_ext.h
+
+ @Description   Efficient functions for copying and setting blocks of memory.
+*//***************************************************************************/
+
+#ifndef __MEMCPY_EXT_H
+#define __MEMCPY_EXT_H
+
+#include "std_ext.h"
+
+
+/**************************************************************************//**
+ @Group         etc_id   Utility Library Application Programming Interface
+
+ @Description   External routines.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Group         mem_cpy Memory Copy
+
+ @Description   Memory Copy module functions,definitions and enums.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Function      MemCpy32
+
+ @Description   Copies one memory buffer into another one in 4-byte chunks!
+                Which should be more efficient than byte by byte.
+
+                For large buffers (over 60 bytes) this function is about 4 times
+                more efficient than the trivial memory copy. For short buffers
+                it is reduced to the trivial copy and may be a bit worse.
+
+ @Param[in]     pDst    - The address of the destination buffer.
+ @Param[in]     pSrc    - The address of the source buffer.
+ @Param[in]     size    - The number of bytes that will be copied from pSrc to pDst.
+
+ @Return        pDst (the address of the destination buffer).
+
+ @Cautions      There is no parameter or boundary checking! It is up to the user
+                to supply non-null parameters as source & destination and size
+                that actually fits into the destination buffer.
+*//***************************************************************************/
+void * MemCpy32(void* pDst,void* pSrc, uint32_t size);
+void * IO2IOCpy32(void* pDst,void* pSrc, uint32_t size);
+void * IO2MemCpy32(void* pDst,void* pSrc, uint32_t size);
+void * Mem2IOCpy32(void* pDst,void* pSrc, uint32_t size);
+
+/**************************************************************************//**
+ @Function      MemCpy64
+
+ @Description   Copies one memory buffer into another one in 8-byte chunks!
+                Which should be more efficient than byte by byte.
+
+                For large buffers (over 60 bytes) this function is about 8 times
+                more efficient than the trivial memory copy. For short buffers
+                it is reduced to the trivial copy and may be a bit worse.
+
+                Some testing suggests that MemCpy32() preforms better than
+                MemCpy64() over small buffers. On average they break even at
+                100 byte buffers. For buffers larger than that MemCpy64 is
+                superior.
+
+ @Param[in]     pDst    - The address of the destination buffer.
+ @Param[in]     pSrc    - The address of the source buffer.
+ @Param[in]     size    - The number of bytes that will be copied from pSrc to pDst.
+
+ @Return        pDst (the address of the destination buffer).
+
+ @Cautions      There is no parameter or boundary checking! It is up to the user
+                to supply non null parameters as source & destination and size
+                that actually fits into their buffer.
+
+                Do not use under Linux.
+*//***************************************************************************/
+void * MemCpy64(void* pDst,void* pSrc, uint32_t size);
+
+/**************************************************************************//**
+ @Function      MemSet32
+
+ @Description   Sets all bytes of a memory buffer to a specific value, in
+                4-byte chunks.
+
+ @Param[in]     pDst    - The address of the destination buffer.
+ @Param[in]     val     - Value to set destination bytes to.
+ @Param[in]     size    - The number of bytes that will be set to val.
+
+ @Return        pDst (the address of the destination buffer).
+
+ @Cautions      There is no parameter or boundary checking! It is up to the user
+                to supply non null parameter as destination and size
+                that actually fits into the destination buffer.
+*//***************************************************************************/
+void * MemSet32(void* pDst, uint8_t val, uint32_t size);
+void * IOMemSet32(void* pDst, uint8_t val, uint32_t size);
+
+/**************************************************************************//**
+ @Function      MemSet64
+
+ @Description   Sets all bytes of a memory buffer to a specific value, in
+                8-byte chunks.
+
+ @Param[in]     pDst    - The address of the destination buffer.
+ @Param[in]     val     - Value to set destination bytes to.
+ @Param[in]     size    - The number of bytes that will be set to val.
+
+ @Return        pDst (the address of the destination buffer).
+
+ @Cautions      There is no parameter or boundary checking! It is up to the user
+                to supply non null parameter as destination and size
+                that actually fits into the destination buffer.
+*//***************************************************************************/
+void * MemSet64(void* pDst, uint8_t val, uint32_t size);
+
+/**************************************************************************//**
+ @Function      MemDisp
+
+ @Description   Displays a block of memory in chunks of 32 bits.
+
+ @Param[in]     addr    - The address of the memory to dysplay.
+ @Param[in]     size    - The number of bytes that will be displayed.
+
+ @Return        None.
+
+ @Cautions      There is no parameter or boundary checking! It is up to the user
+                to supply non null parameter as destination and size
+                that actually fits into the destination buffer.
+*//***************************************************************************/
+void MemDisp(uint8_t *addr, int size);
+
+/** @} */ /* end of mem_cpy group */
+/** @} */ /* end of etc_id group */
+
+
+#endif /* __MEMCPY_EXT_H */
diff --git a/drivers/net/dpa/NetCommSw/inc/etc/mm_ext.h b/drivers/net/dpa/NetCommSw/inc/etc/mm_ext.h
new file mode 100644
index 0000000..129e332
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/inc/etc/mm_ext.h
@@ -0,0 +1,301 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+ /**************************************************************************//**
+
+ @File          mm_ext.h
+
+ @Description   Memory Manager Application Programming Interface
+*//***************************************************************************/
+#ifndef __MM_EXT
+#define __MM_EXT
+
+#include "std_ext.h"
+
+#define MM_MAX_ALIGNMENT    20  /*ys* patch for data overrun */
+                                /* The alignments from 2 to 128 are available
+                                   where maximum alignment defined as
+                                   MM_MAX_ALIGNMENT power of 2 */
+
+#define MM_MAX_NAME_LEN     50
+
+/**************************************************************************//**
+ @Group         etc_id   Utility Library Application Programming Interface
+
+ @Description   External routines.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Group         mm_grp Flexible Memory Manager
+
+ @Description   Flexible Memory Manager module functions,definitions and enums.
+                (All of the following functions,definitions and enums can be found in mm_ext.h)
+
+ @{
+*//***************************************************************************/
+
+
+/**************************************************************************//**
+ @Function      MM_Init
+
+ @Description   Initializes a new MM object.
+
+                It initializes a new memory block consisting of base address
+                and size of the available memory by calling to MemBlock_Init
+                routine. It is also initializes a new free block for each
+                by calling FreeBlock_Init routine, which is pointed to
+                the almost all memory started from the required alignment
+                from the base address and to the end of the memory.
+                The handle to the new MM object is returned via "MM"
+                argument (passed by reference).
+
+ @Param[in]     h_MM    - Handle to the MM object.
+ @Param[in]     base    - Base address of the MM.
+ @Param[in]     size    - Size of the MM.
+
+ @Return        E_OK is returned on success. E_NOMEMORY is returned if the new MM object or a new free block can not be initialized.
+*//***************************************************************************/
+t_Error     MM_Init(t_Handle *h_MM, uint64_t base, uint64_t size);
+
+/**************************************************************************//**
+ @Function      MM_Get
+
+ @Description   Allocates a block of memory according to the given size and the alignment.
+
+                The Alignement argument tells from which
+                free list allocate a block of memory. 2^alignment indicates
+                the alignment that the base address of the allocated block
+                should have. So, the only values 1, 2, 4, 8, 16, 32 and 64
+                are available for the alignment argument.
+                The routine passes through the specific free list of free
+                blocks and seeks for a first block that have anough memory
+                that  is required (best fit).
+                After the block is found and data is allocated, it calls
+                the internal MM_CutFree routine to update all free lists
+                do not include a just allocated block. Of course, each
+                free list contains a free blocks with the same alignment.
+                It is also creates a busy block that holds
+                information about an allocated block.
+
+ @Param[in]     h_MM        - Handle to the MM object.
+ @Param[in]     size        - Size of the MM.
+ @Param[in]     alignment   - Index as a power of two defines a required
+                              alignment; Should be 1, 2, 4, 8, 16, 32 or 64
+ @Param[in]     name        - The name that specifies an allocated block.
+
+ @Return        base address of an allocated block ILLEGAL_BASE if can't allocate a block
+*//***************************************************************************/
+uint64_t    MM_Get(t_Handle h_MM, uint64_t size, int alignment, char *name);
+
+/**************************************************************************//**
+ @Function      MM_GetBase
+
+ @Description   Gets the base address of the required MM objects.
+
+ @Param[in]     h_MM - Handle to the MM object.
+
+ @Return        base address of the block.
+*//***************************************************************************/
+uint64_t    MM_GetBase(t_Handle h_MM);
+
+/**************************************************************************//**
+ @Function      MM_GetForce
+
+ @Description   Force memory allocation.
+
+                It means to allocate a block of memory of the given
+                size from the given base address.
+                The routine checks if the required block can be allocated
+                (that is it is free) and then, calls the internal MM_CutFree
+                routine to update all free lists do not include that block.
+
+ @Param[in]     h_MM    - Handle to the MM object.
+ @Param[in]     base    - Base address of the MM.
+ @Param[in]     size    - Size of the MM.
+ @Param[in]     name    - Name that specifies an allocated block.
+
+ @Return        base address of an allocated block, ILLEGAL_BASE if can't allocate a block.
+*//***************************************************************************/
+uint64_t    MM_GetForce(t_Handle h_MM, uint64_t base, uint64_t size, char *name);
+
+/**************************************************************************//**
+ @Function      MM_GetForceMin
+
+ @Description   Allocates a block of memory according to the given size, the alignment and minimum base address.
+
+                The Alignement argument tells from which
+                free list allocate a block of memory. 2^alignment indicates
+                the alignment that the base address of the allocated block
+                should have. So, the only values 1, 2, 4, 8, 16, 32 and 64
+                are available for the alignment argument.
+                The minimum baser address forces the location of the block
+                to be from a given address onward.
+                The routine passes through the specific free list of free
+                blocks and seeks for the first base address equal or smaller
+                than the required minimum address and end address larger than
+                than the required base + its size - i.e. that may contain
+                the required block.
+                After the block is found and data is allocated, it calls
+                the internal MM_CutFree routine to update all free lists
+                do not include a just allocated block. Of course, each
+                free list contains a free blocks with the same alignment.
+                It is also creates a busy block that holds
+                information about an allocated block.
+
+ @Param[in]     h_MM        - Handle to the MM object.
+ @Param[in]     size        - Size of the MM.
+ @Param[in]     alignment   - Index as a power of two defines a required
+                              alignment; Should be 1, 2, 4, 8, 16, 32 or 64
+ @Param[in]     min         - The minimum base address of the block.
+ @Param[in]     name        - Name that specifies an allocated block.
+
+ @Return        base address of an allocated block,ILLEGAL_BASE if can't allocate a block.
+*//***************************************************************************/
+uint64_t    MM_GetForceMin(t_Handle h_MM,
+                           uint64_t size,
+                           int      alignment,
+                           uint64_t min,
+                           char     *name);
+
+/**************************************************************************//**
+ @Function      MM_Put
+
+ @Description   Puts a block of memory of the given base address back to the memory.
+
+                It checks if there is a busy block with the
+                given base address. If not, it returns 0, that
+                means can't free a block. Otherwise, it gets parameters of
+                the busy block and after it updates lists of free blocks,
+                removes that busy block from the list by calling to MM_CutBusy
+                routine.
+                After that it calls to MM_AddFree routine to add a new free
+                block to the free lists.
+
+ @Param[in]     h_MM    - Handle to the MM object.
+ @Param[in]     base    - Base address of the MM.
+
+ @Return         The size of bytes released, 0 if failed.
+*//***************************************************************************/
+uint64_t    MM_Put(t_Handle h_MM, uint64_t base);
+
+/**************************************************************************//**
+ @Function      MM_PutForce
+
+ @Description   Releases a block of memory of the required size from the required base address.
+
+                First, it calls to MM_CutBusy routine
+                to cut a free block from the busy list. And then, calls to
+                MM_AddFree routine to add the free block to the free lists.
+
+ @Param[in]     h_MM    - Handle to the MM object.
+ @Param[in]     base    - Base address of of a block to free.
+ @Param[in]     size    - Size of a block to free.
+
+ @Return        The number of bytes released, 0 on failure.
+*//***************************************************************************/
+uint64_t    MM_PutForce(t_Handle h_MM, uint64_t base, uint64_t size);
+
+/**************************************************************************//**
+ @Function      MM_Add
+
+ @Description   Adds a new memory block for memory allocation.
+
+                When a new memory block is initialized and added to the
+                memory list, it calls to MM_AddFree routine to add the
+                new free block to the free lists.
+
+ @Param[in]     h_MM    - Handle to the MM object.
+ @Param[in]     base    - Base address of the memory block.
+ @Param[in]     size    - Size of the memory block.
+
+ @Return        E_OK on success, otherwise returns an error code.
+*//***************************************************************************/
+t_Error     MM_Add(t_Handle h_MM, uint64_t base, uint64_t size);
+
+/**************************************************************************//**
+ @Function      MM_Dump
+
+ @Description   Prints results of free and busy lists into the file.
+
+ @Param[in]     h_MM        - Handle to the MM object.
+ @Param[in]     buff        - A pointer to a buffer
+*//***************************************************************************/
+void        MM_Dump(t_Handle h_MM, void *buff);
+
+/**************************************************************************//**
+ @Function      MM_Free
+
+ @Description   Releases memory allocated for MM object.
+
+ @Param[in]     h_MM - Handle of the MM object.
+*//***************************************************************************/
+void        MM_Free(t_Handle h_MM);
+
+/**************************************************************************//**
+ @Function      MM_GetMemBlock
+
+ @Description   Returns base address of the memory block specified by the index.
+
+                If index is 0, returns base address
+                of the first memory block, 1 - returns base address
+                of the second memory block, etc.
+                Note, those memory blocks are allocated by the
+                application before MM_Init or MM_Add and have to
+                be released by the application before or after invoking
+                the MM_Free routine.
+
+ @Param[in]     h_MM    - Handle to the MM object.
+ @Param[in]     index   - Index of the memory block.
+
+ @Return        valid base address or ILLEGAL_BASE if no memory block specified by the index.
+*//***************************************************************************/
+uint64_t    MM_GetMemBlock(t_Handle h_MM, int index);
+
+/**************************************************************************//**
+ @Function      MM_InRange
+
+ @Description   Checks if a specific address is in the memory range of the passed MM object.
+
+ @Param[in]     h_MM    - Handle to the MM object.
+ @Param[in]     addr    - The address to be checked.
+
+ @Return        TRUE if the addres is in the address range of the block,FALSE otherwise.
+*//***************************************************************************/
+bool        MM_InRange(t_Handle h_MM, uint64_t addr);
+
+
+/** @} */ /* end of mm_grp group */
+/** @} */ /* end of etc_id group */
+
+#endif /* __MM_EXT_H */
diff --git a/drivers/net/dpa/NetCommSw/inc/etc/sprint_ext.h b/drivers/net/dpa/NetCommSw/inc/etc/sprint_ext.h
new file mode 100644
index 0000000..db7f1b2
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/inc/etc/sprint_ext.h
@@ -0,0 +1,121 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/******************************************************************************
+
+ @File          sprint_ext.h
+
+ @Description   Debug routines (externals).
+
+*//***************************************************************************/
+
+#ifndef __SPRINT_EXT_H
+#define __SPRINT_EXT_H
+
+
+#if defined(NCSW_LINUX) && defined(__KERNEL__)
+#include <linux/kernel.h>
+
+#elif defined(MWI_VXWORKS)
+#include "stdio.h"
+
+#else
+#include <stdio.h>
+
+#endif /* defined(NCSW_LINUX) && defined(__KERNEL__) */
+
+#include "std_ext.h"
+#ifdef NCSW_VXWORKS
+#include "private/stdioP.h"
+#endif /* NCSW_VXWORKS */
+
+/**************************************************************************//**
+ @Group         etc_id   Utility Library Application Programming Interface
+
+ @Description   External routines.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Group         sprint_id Sprint
+
+ @Description   Sprint & Sscan module functions,definitions and enums.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Function      Sprint
+
+ @Description   Format a string and place it in a buffer.
+
+ @Param[in]     buff - The buffer to place the result into.
+ @Param[in]     str  - The format string to use.
+ @Param[in]     ...  - Arguments for the format string.
+
+ @Return        Number of bytes formatted.
+*//***************************************************************************/
+int Sprint(char *buff, const char *str, ...);
+
+/**************************************************************************//**
+ @Function      Snprint
+
+ @Description   Format a string and place it in a buffer.
+
+ @Param[in]     buf  - The buffer to place the result into.
+ @Param[in]     size - The size of the buffer, including the trailing null space.
+ @Param[in]     fmt  - The format string to use.
+ @Param[in]     ...  - Arguments for the format string.
+
+ @Return        Number of bytes formatted.
+*//***************************************************************************/
+int Snprint(char * buf, uint32_t size, const char *fmt, ...);
+
+/**************************************************************************//**
+ @Function      Sscan
+
+ @Description   Unformat a buffer into a list of arguments.
+
+ @Param[in]     buf  - input buffer.
+ @Param[in]     fmt  - formatting of buffer.
+ @Param[out]    ...  - resulting arguments.
+
+ @Return        Number of bytes unformatted.
+*//***************************************************************************/
+int Sscan(const char * buf, const char * fmt, ...);
+
+/** @} */ /* end of sprint_id group */
+/** @} */ /* end of etc_id group */
+
+
+#endif /* __SPRINT_EXT_H */
diff --git a/drivers/net/dpa/NetCommSw/inc/integrations/P4080/part_integration_ext.h b/drivers/net/dpa/NetCommSw/inc/integrations/P4080/part_integration_ext.h
new file mode 100644
index 0000000..273b46e
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/inc/integrations/P4080/part_integration_ext.h
@@ -0,0 +1,306 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**
+
+ @File          part_integration_ext.h
+
+ @Description   P4080 external definitions and structures.
+*//***************************************************************************/
+#ifndef __PART_INTEGRATION_EXT_H
+#define __PART_INTEGRATION_EXT_H
+
+
+/**************************************************************************//**
+ @Group         P4080_chip_id P4080 Application Programming Interface
+
+ @Description   P4080 Chip functions,definitions and enums.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description   Module types.
+*//***************************************************************************/
+typedef enum e_ModuleId
+{
+    e_MODULE_ID_DUART_1 = 0,
+    e_MODULE_ID_DUART_2,
+    e_MODULE_ID_DUART_3,
+    e_MODULE_ID_DUART_4,
+    e_MODULE_ID_QM,                 /**< Queue manager module */
+    e_MODULE_ID_BM,                 /**< Buffer manager module */
+
+    e_MODULE_ID_FM1,                /**< Frame manager #1 module */
+    e_MODULE_ID_FM1_MURAM,          /**< FM Multi-User-RAM */
+    e_MODULE_ID_FM1_BMI,            /**< FM BMI block */
+    e_MODULE_ID_FM1_QMI,            /**< FM QMI block */
+    e_MODULE_ID_FM1_PRS,            /**< FM parser block */
+    e_MODULE_ID_FM1_PORT_HO0,       /**< FM Host-command/offline-parsing port block */
+    e_MODULE_ID_FM1_PORT_HO1,       /**< FM Host-command/offline-parsing port block */
+    e_MODULE_ID_FM1_PORT_HO2,       /**< FM Host-command/offline-parsing port block */
+    e_MODULE_ID_FM1_PORT_HO3,       /**< FM Host-command/offline-parsing port block */
+    e_MODULE_ID_FM1_PORT_HO4,       /**< FM Host-command/offline-parsing port block */
+    e_MODULE_ID_FM1_PORT_HO5,       /**< FM Host-command/offline-parsing port block */
+    e_MODULE_ID_FM1_PORT_HO6,       /**< FM Host-command/offline-parsing port block */
+    e_MODULE_ID_FM1_PORT_1GRx0,     /**< FM Rx 1G MAC port block */
+    e_MODULE_ID_FM1_PORT_1GRx1,     /**< FM Rx 1G MAC port block */
+    e_MODULE_ID_FM1_PORT_1GRx2,     /**< FM Rx 1G MAC port block */
+    e_MODULE_ID_FM1_PORT_1GRx3,     /**< FM Rx 1G MAC port block */
+    e_MODULE_ID_FM1_PORT_10GRx0,    /**< FM Rx 10G MAC port block */
+    e_MODULE_ID_FM1_PORT_1GTx0,     /**< FM Tx 1G MAC port block */
+    e_MODULE_ID_FM1_PORT_1GTx1,     /**< FM Tx 1G MAC port block */
+    e_MODULE_ID_FM1_PORT_1GTx2,     /**< FM Tx 1G MAC port block */
+    e_MODULE_ID_FM1_PORT_1GTx3,     /**< FM Tx 1G MAC port block */
+    e_MODULE_ID_FM1_PORT_10GTx0,    /**< FM Tx 10G MAC port block */
+    e_MODULE_ID_FM1_PLCR,           /**< FM Policer */
+    e_MODULE_ID_FM1_KG,             /**< FM Keygen */
+    e_MODULE_ID_FM1_DMA,            /**< FM DMA */
+    e_MODULE_ID_FM1_FPM,            /**< FM FPM */
+    e_MODULE_ID_FM1_IRAM,           /**< FM Instruction-RAM */
+    e_MODULE_ID_FM1_1GMDIO0,        /**< FM 1G MDIO MAC 0*/
+    e_MODULE_ID_FM1_1GMDIO1,        /**< FM 1G MDIO MAC 1*/
+    e_MODULE_ID_FM1_1GMDIO2,        /**< FM 1G MDIO MAC 2*/
+    e_MODULE_ID_FM1_1GMDIO3,        /**< FM 1G MDIO MAC 3*/
+    e_MODULE_ID_FM1_10GMDIO,        /**< FM 10G MDIO */
+    e_MODULE_ID_FM1_PRS_IRAM,       /**< FM SW-parser Instruction-RAM */
+    e_MODULE_ID_FM1_RISC0,          /**< FM risc #0 */
+    e_MODULE_ID_FM1_RISC1,          /**< FM risc #1 */
+    e_MODULE_ID_FM1_1GMAC0,         /**< FM 1G MAC #0 */
+    e_MODULE_ID_FM1_1GMAC1,         /**< FM 1G MAC #1 */
+    e_MODULE_ID_FM1_1GMAC2,         /**< FM 1G MAC #2 */
+    e_MODULE_ID_FM1_1GMAC3,         /**< FM 1G MAC #3 */
+    e_MODULE_ID_FM1_10GMAC0,        /**< FM 10G MAC #0 */
+
+    e_MODULE_ID_FM2,                /**< Frame manager #2 module */
+    e_MODULE_ID_FM2_MURAM,          /**< FM Multi-User-RAM */
+    e_MODULE_ID_FM2_BMI,            /**< FM BMI block */
+    e_MODULE_ID_FM2_QMI,            /**< FM QMI block */
+    e_MODULE_ID_FM2_PRS,            /**< FM parser block */
+    e_MODULE_ID_FM2_PORT_HO0,       /**< FM Host-command/offline-parsing port block */
+    e_MODULE_ID_FM2_PORT_HO1,       /**< FM Host-command/offline-parsing port block */
+    e_MODULE_ID_FM2_PORT_HO2,       /**< FM Host-command/offline-parsing port block */
+    e_MODULE_ID_FM2_PORT_HO3,       /**< FM Host-command/offline-parsing port block */
+    e_MODULE_ID_FM2_PORT_HO4,       /**< FM Host-command/offline-parsing port block */
+    e_MODULE_ID_FM2_PORT_HO5,       /**< FM Host-command/offline-parsing port block */
+    e_MODULE_ID_FM2_PORT_HO6,       /**< FM Host-command/offline-parsing port block */
+    e_MODULE_ID_FM2_PORT_1GRx0,     /**< FM Rx 1G MAC port block */
+    e_MODULE_ID_FM2_PORT_1GRx1,     /**< FM Rx 1G MAC port block */
+    e_MODULE_ID_FM2_PORT_1GRx2,     /**< FM Rx 1G MAC port block */
+    e_MODULE_ID_FM2_PORT_1GRx3,     /**< FM Rx 1G MAC port block */
+    e_MODULE_ID_FM2_PORT_10GRx0,    /**< FM Rx 10G MAC port block */
+    e_MODULE_ID_FM2_PORT_1GTx0,     /**< FM Tx 1G MAC port block */
+    e_MODULE_ID_FM2_PORT_1GTx1,     /**< FM Tx 1G MAC port block */
+    e_MODULE_ID_FM2_PORT_1GTx2,     /**< FM Tx 1G MAC port block */
+    e_MODULE_ID_FM2_PORT_1GTx3,     /**< FM Tx 1G MAC port block */
+    e_MODULE_ID_FM2_PORT_10GTx0,    /**< FM Tx 10G MAC port block */
+    e_MODULE_ID_FM2_PLCR,           /**< FM Policer */
+    e_MODULE_ID_FM2_KG,             /**< FM Keygen */
+    e_MODULE_ID_FM2_DMA,            /**< FM DMA */
+    e_MODULE_ID_FM2_FPM,            /**< FM FPM */
+    e_MODULE_ID_FM2_IRAM,           /**< FM Instruction-RAM */
+    e_MODULE_ID_FM2_1GMDIO0,        /**< FM 1G MDIO MAC 0*/
+    e_MODULE_ID_FM2_1GMDIO1,        /**< FM 1G MDIO MAC 1*/
+    e_MODULE_ID_FM2_1GMDIO2,        /**< FM 1G MDIO MAC 2*/
+    e_MODULE_ID_FM2_1GMDIO3,        /**< FM 1G MDIO MAC 3*/
+    e_MODULE_ID_FM2_10GMDIO,        /**< FM 10G MDIO */
+    e_MODULE_ID_FM2_PRS_IRAM,       /**< FM SW-parser Instruction-RAM */
+    e_MODULE_ID_FM2_RISC0,          /**< FM risc #0 */
+    e_MODULE_ID_FM2_RISC1,          /**< FM risc #1 */
+    e_MODULE_ID_FM2_1GMAC0,         /**< FM 1G MAC #0 */
+    e_MODULE_ID_FM2_1GMAC1,         /**< FM 1G MAC #1 */
+    e_MODULE_ID_FM2_1GMAC2,         /**< FM 1G MAC #2 */
+    e_MODULE_ID_FM2_1GMAC3,         /**< FM 1G MAC #3 */
+    e_MODULE_ID_FM2_10GMAC0,        /**< FM 10G MAC #0 */
+
+    e_MODULE_ID_MPIC,               /**< MPIC */
+    e_MODULE_ID_DUMMY_LAST
+} e_ModuleId;
+
+#define NUM_OF_MODULES  e_MODULE_ID_DUMMY_LAST
+
+/**************************************************************************//**
+ @Description   Transaction source id (for memory conrollers error reporting DDR,LBC,ECM).
+*//***************************************************************************/
+typedef enum e_TransSrc
+{
+    e_TRANS_SRC_LBC             = 0x4,  /**< Enhanced local bus      */
+    e_TRANS_SRC_BOOTS           = 0xA,  /**< Boot sequencer          */
+    e_TRANS_SRC_DDR1            = 0xF,  /**< DDR controller 1        */
+    e_TRANS_SRC_CORE_INS_FETCH  = 0x10, /**< Processor (instruction) */
+    e_TRANS_SRC_CORE_DATA       = 0x11, /**< Processor (data)        */
+    e_TRANS_SRC_DMA             = 0x15, /**< DMA                     */
+} e_TransSrc;
+
+
+/***************************************************************
+    P4080 general routines
+****************************************************************/
+/**************************************************************************//**
+ @Group         P4080_init_grp P4080 Initialization Unit
+
+ @Description   P4080 initialization unit API functions, definitions and enums
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description   Part ID and revision number
+*//***************************************************************************/
+typedef enum e_P4080DeviceName
+{
+    e_P4080_REV_INVALID   = 0x00000000,   /**< Invalid revision      */
+    e_P4080E_REV_1_0      = 0x807D0010    /**< P4080E with security, revision 1.0 */
+} e_P4080DeviceName;
+
+
+/**************************************************************************//**
+ @Function      P4080_ConfigAndInit
+
+ @Description   General initiation of the chip registers.
+
+ @Param         baseAddress  - (In) memory map start
+
+ @Return        A handle to the P4080 data structure.
+*//***************************************************************************/
+t_Handle P4080_ConfigAndInit(uint32_t baseAddress);
+
+/**************************************************************************//**
+ @Function      P4080_Free
+
+ @Description   Free all resources.
+
+ @Param         h_P4080 - (In) The handle of the initialized P4080 object.
+
+ @Return        E_OK on success; Other value otherwise.
+*//***************************************************************************/
+t_Error P4080_Free(t_Handle h_P4080);
+
+/**************************************************************************//**
+ @Function      P4080_GetModuleBase
+
+ @Description   returns the base address of a P4080 module's
+                memory mapped registers.
+
+ @Param         h_P4080   - (In) The handle of the initialized P4080 object.
+ @Param         module      - (In) The module ID.
+
+ @Return        Base address of module's memory mapped registers.
+                ILLEGAL_BASE in case of non-existent module
+*//***************************************************************************/
+uint32_t P4080_GetModuleBase(t_Handle h_P4080, e_ModuleId module);
+
+/**************************************************************************//**
+ @Function      P4080_GetRevInfo
+
+ @Description   This routine enables access to chip and revision information.
+
+ @Param         h_P4080 - (In) The handle of the initialized P4080 object.
+
+ @Return        Part ID and revision.
+*//***************************************************************************/
+e_P4080DeviceName P4080_GetRevInfo(t_Handle h_P4080);
+
+/**************************************************************************//**
+ @Function      P4080_GetE500Factor
+
+ @Description   returns system multiplication factor.
+
+ @Param         h_P4080 - (In) a handle to the P4080 object.
+ @Param         p_E500MulFactor   - (Out) returns E500 to CCB multification factor.
+ @Param         p_E500DivFactor   - (Out) returns E500 to CCB division factor.
+
+ @Return        E_OK on success; Other value otherwise.
+*
+*//***************************************************************************/
+t_Error P4080_GetE500Factor(t_Handle h_P4080, uint32_t *p_E500MulFactor, uint32_t *p_E500DivFactor);
+
+/**************************************************************************//**
+ @Function      P4080_GetCcbFactor
+
+ @Description   returns system multiplication factor.
+
+ @Param         h_P4080 - (In) The handle of the initialized P4080 object.
+
+ @Return        System multiplication factor.
+*//***************************************************************************/
+uint32_t P4080_GetCcbFactor(t_Handle h_P4080);
+
+/** @} */ /* end of P4080_init_grp group */
+/** @} */ /* end of P4080_grp group */
+
+
+/*****************************************************************************
+ INTEGRATION-SPECIFIC MODULE CODES
+******************************************************************************/
+#define MODULE_UNKNOWN          0x00000000
+#define MODULE_MEM              0x00010000
+#define MODULE_MM               0x00020000
+#define MODULE_CORE             0x00030000
+#define MODULE_PM               0x00040000
+#define MODULE_P4080            0x00050000
+#define MODULE_P4080_PLTFRM     0x00060000
+#define MODULE_MMU              0x00070000
+#define MODULE_EPIC             0x00080000
+#define MODULE_FM               0x00090000
+#define MODULE_QM               0x000a0000
+#define MODULE_BM               0x000b0000
+#define MODULE_DUART            0x000c0000
+
+/*****************************************************************************
+ FM INTEGRATION-SPECIFIC DEFINITIONS
+******************************************************************************/
+#define INTG_MAX_NUM_OF_FM          2
+
+#define FM_MAX_NUM_OF_1G_RX_PORTS   4
+#define FM_MAX_NUM_OF_10G_RX_PORTS  1
+#define FM_MAX_NUM_OF_RX_PORTS      (FM_MAX_NUM_OF_10G_RX_PORTS+FM_MAX_NUM_OF_1G_RX_PORTS)
+#define FM_MAX_NUM_OF_1G_TX_PORTS   4
+#define FM_MAX_NUM_OF_10G_TX_PORTS  1
+#define FM_MAX_NUM_OF_TX_PORTS      (FM_MAX_NUM_OF_10G_TX_PORTS+FM_MAX_NUM_OF_1G_TX_PORTS)
+#define FM_MAX_NUM_OF_OP_PORTS      6
+#define FM_MAX_NUM_OF_HC_PORTS      1
+#define FM_MAX_NUM_OF_1G_MACS       (FM_MAX_NUM_OF_1G_RX_PORTS)
+#define FM_MAX_NUM_OF_10G_MACS      (FM_MAX_NUM_OF_10G_RX_PORTS)
+#define FM_MAX_NUM_OF_MACS          (FM_MAX_NUM_OF_1G_MACS+FM_MAX_NUM_OF_10G_MACS)
+#define FM_MAX_NUM_OF_PCD_PORTS     FM_MAX_NUM_OF_RX_PORTS+FM_MAX_NUM_OF_OP_PORTS
+
+#define FM_MURAM_SIZE               (160*KILOBYTE)
+#define FM_PCD_PLCR_NUM_ENTRIES     256                 /**< Total number of policer profiles */
+#define FM_PCD_KG_NUM_OF_SCHEMES    32                  /**< Total number of KG schemes */
+#define FM_PCD_MAX_NUM_OF_CLS_PLANS 256                 /**< Number of classification plan entries. */
+
+#define FM_OP_PARTITION_ERRATA
+#define CORE_8BIT_ACCESS_ERRATA
+
+
+#endif /* __PART_INTEGRATION_EXT_H */
diff --git a/drivers/net/dpa/NetCommSw/inc/integrations/part_ext.h b/drivers/net/dpa/NetCommSw/inc/integrations/part_ext.h
new file mode 100644
index 0000000..b9f3f87
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/inc/integrations/part_ext.h
@@ -0,0 +1,85 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**************************************************************************//**
+
+ @File          part_ext.h
+
+ @Description   Definitions for the part (integration) module.
+*//***************************************************************************/
+
+#ifndef __PART_EXT_H
+#define __PART_EXT_H
+
+#include "std_ext.h"
+#include "part_integration_ext.h"
+
+
+#if !(defined(MPC834x) || \
+      defined(MPC836x) || \
+      defined(MPC832x) || \
+      defined(MPC837x) || \
+      defined(MPC8568) || \
+      defined(MPC8569) || \
+      defined(P4080)   || \
+      defined(MSC814x))
+#error "unable to proceed without chip-definition"
+#endif /* !(defined(MPC834x) || ... */
+
+
+/**************************************************************************//**
+ @Description   Part callback typedef for revision information.
+
+ @Param         appId   - (In) user's id as passed at init routine
+ @Param         event   - (In) GPIO event register - may be used if a single routine
+                        is passed to all events. Otherwize - redundent.
+
+*//***************************************************************************/
+typedef uint32_t (t_RevInfoCallback)(t_Handle h_Part);
+
+/**************************************************************************//*
+ @Description   Part data structure - must be contained in any integration
+                data structure.
+*//***************************************************************************/
+typedef struct t_Part
+{
+    uint32_t    (* f_GetRevInfo)(t_Handle h_Part);
+                /**< Returns the revision number of the chip. */
+    uint32_t    (* f_GetModuleBase)(t_Handle h_Part, e_ModuleId moduleId);
+                /**< Returns the address of the module's memory map base. */
+    e_ModuleId  (* f_GetModuleIdByBase)(t_Handle h_Part, uint32_t baseAddress);
+                /**< Returns the module's ID according to its memory map base. */
+} t_Part;
+
+
+
+#endif /* __PART_EXT_H */
diff --git a/drivers/net/dpa/NetCommSw/inc/math_ext.h b/drivers/net/dpa/NetCommSw/inc/math_ext.h
new file mode 100644
index 0000000..59f0533
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/inc/math_ext.h
@@ -0,0 +1,101 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __MATH_EXT_H
+#define __MATH_EXT_H
+
+
+#if defined(NCSW_LINUX) && defined(__KERNEL__)
+#include <linux/math.h>
+
+#elif defined(MWI_VXWORKS)
+#include "math.h"
+
+#elif defined(__MWERKS__)
+#define LOW(x) ( sizeof(x)==8 ? *(1+(int32_t*)&x) : (*(int32_t*)&x))
+#define HIGH(x) (*(int32_t*)&x)
+#define ULOW(x) ( sizeof(x)==8 ? *(1+(uint32_t*)&x) : (*(uint32_t*)&x))
+#define UHIGH(x) (*(uint32_t*)&x)
+
+static const double big = 1.0e300;
+
+/* Macro for checking if a number is a power of 2 */
+static __inline__ double ceil(double x)
+{
+    int32_t i0,i1,j0; /*- cc 020130 -*/
+    uint32_t i,j; /*- cc 020130 -*/
+    i0 =  HIGH(x);
+    i1 =  LOW(x);
+    j0 = ((i0>>20)&0x7ff)-0x3ff;
+    if(j0<20) {
+        if(j0<0) {     /* raise inexact if x != 0 */
+        if(big+x>0.0) {/* return 0*sign(x) if |x|<1 */
+            if(i0<0) {i0=0x80000000;i1=0;}
+            else if((i0|i1)!=0) { i0=0x3ff00000;i1=0;}
+        }
+        } else {
+        i = (uint32_t)(0x000fffff)>>j0;
+        if(((i0&i)|i1)==0) return x; /* x is integral */
+        if(big+x>0.0) {    /* raise inexact flag */
+            if(i0>0) i0 += (0x00100000)>>j0;
+            i0 &= (~i); i1=0;
+        }
+        }
+    } else if (j0>51) {
+        if(j0==0x400) return x+x;    /* inf or NaN */
+        else return x;        /* x is integral */
+    } else {
+        i = ((uint32_t)(0xffffffff))>>(j0-20); /*- cc 020130 -*/
+        if((i1&i)==0) return x;    /* x is integral */
+        if(big+x>0.0) {         /* raise inexact flag */
+        if(i0>0) {
+            if(j0==20) i0+=1;
+            else {
+            j = (uint32_t)(i1 + (1<<(52-j0)));
+            if(j<i1) i0+=1;    /* got a carry */
+            i1 = (int32_t)j;
+            }
+        }
+        i1 &= (~i);
+        }
+    }
+    HIGH(x) = i0;
+    LOW(x) = i1;
+    return x;
+}
+
+#else
+#include <math.h>
+#endif /* defined(NCSW_LINUX) && defined(__KERNEL__) */
+
+
+#endif /* __MATH_EXT_H */
diff --git a/drivers/net/dpa/NetCommSw/inc/ncsw_ext.h b/drivers/net/dpa/NetCommSw/inc/ncsw_ext.h
new file mode 100644
index 0000000..139ff76
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/inc/ncsw_ext.h
@@ -0,0 +1,383 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+ /**************************************************************************//**
+ @File          ncsw_ext.h
+
+ @Description   General NetCommSw Standard Definitions
+*//***************************************************************************/
+
+#ifndef __NCSW_EXT_H
+#define __NCSW_EXT_H
+
+#include "memcpy_ext.h"
+
+
+#define WRITE_BLOCK                 IOMemSet32
+#define COPY_BLOCK                  Mem2IOCpy32
+
+#define CAST_POINTER_TO_UINT32(val) ((uint32_t)((size_t)((void*)(val))))
+#define CAST_POINTER_TO_UINT64(val) ((uint64_t)((size_t)((void*)(val))))
+#define CAST_UINT32_TO_POINTER(val) ((void*)((size_t)((uint32_t)(val))))
+#define CAST_UINT64_TO_POINTER(val) ((void*)((size_t)((uint64_t)(val))))
+#define CAST_UINT32_TO_POINTER_TYPE(type,val) ((type*)((size_t)((uint32_t)(val))))
+#define CAST_UINT64_TO_POINTER_TYPE(type,val) ((type*)((size_t)((uint64_t)(val))))
+
+#define WRITE_UINT8_UINT24(arg, data08, data24) WRITE_UINT32(arg,((uint32_t)(data08)<<24)|((uint32_t)(data24)&0x00FFFFFF))
+#define WRITE_UINT24_UINT8(arg, data24, data08) WRITE_UINT32(arg,((uint32_t)(data24)<< 8)|((uint32_t)(data08)&0x000000FF))
+
+/* Little-Endian access macros */
+
+#define WRITE_UINT16_LE(arg, data) \
+        WRITE_UINT16((arg), SwapUint16(data))
+
+#define WRITE_UINT32_LE(arg, data) \
+        WRITE_UINT32((arg), SwapUint32(data))
+
+#define WRITE_UINT64_LE(arg, data) \
+        WRITE_UINT64((arg), SwapUint64(data))
+
+#define GET_UINT16_LE(arg) \
+        SwapUint16(GET_UINT16(arg))
+
+#define GET_UINT32_LE(arg) \
+        SwapUint32(GET_UINT32(arg))
+
+#define GET_UINT64_LE(arg) \
+        SwapUint64(GET_UINT64(arg))
+
+/* Write and Read again macros */
+#define WRITE_UINT_SYNC(size, arg, data)    \
+    do {                                    \
+        uint##size##_t temp;                \
+        WRITE_UINT##size((arg), (data));    \
+        temp = GET_UINT##size(arg);         \
+    } while (0)
+
+#define WRITE_UINT8_SYNC(arg, data)     WRITE_UINT_SYNC(8, (arg), (data))
+
+#define WRITE_UINT16_SYNC(arg, data)    WRITE_UINT_SYNC(16, (arg), (data))
+
+#define WRITE_UINT32_SYNC(arg, data)    WRITE_UINT_SYNC(32, (arg), (data))
+
+#define MAKE_UINT64(high32, low32)      (((uint64_t)high32 << 32) | (low32))
+
+
+/*----------------------*/
+/* Miscellaneous macros */
+/*----------------------*/
+
+#define UNUSED(X) (X=X)
+
+#define KILOBYTE            0x400       /* 1024 */
+#define MEGABYTE            0x100000    /* 1024*1024 */
+
+#define NO_IRQ              (-1)
+
+/* Macro for checking if a number is a power of 2 */
+#define POWER_OF_2(n)   (!((n) & ((n)-1)))
+
+/* Macro for calculating log of base 2 */
+#define LOG2(num, log2Num)                          \
+    do                                              \
+    {                                               \
+        uint64_t tmp = (num);                       \
+        log2Num = 0;                                \
+        while(tmp > 1)                              \
+        {                                           \
+            log2Num++;                              \
+            tmp = tmp >> 1;                         \
+        }                                           \
+    } while (0)
+
+/* Ceiling division - not the fastest way, but safer in terms of overflow */
+#define DIV_CEIL(x,y)   ((uint32_t)((x)/(y)) + (((((uint32_t)((x)/(y)))*(y)) == (x)) ? 0 : 1))
+
+/* Round division */
+#define DIV_ROUND(x,y)  (((x)+((y)>>1))/(y))
+
+/* Timing macro for converting usec units to number of ticks.   */
+/* (number of usec *  clock_Hz) / 1,000,000) - since            */
+/* clk is in MHz units, no division needed.                     */
+#define USEC_TO_CLK(usec,clk)       ((usec) * (clk))
+#define CYCLES_TO_USEC(cycles,clk)  ((cycles) / (clk))
+
+/* Timing macros for converting between nsec units and number of clocks. */
+#define NSEC_TO_CLK(nsec,clk)       DIV_CEIL(((nsec) * (clk)), 1000)
+#define CYCLES_TO_NSEC(cycles,clk)  (((cycles) * 1000) / (clk))
+
+/* Timing macros for converting between psec units and number of clocks. */
+#define PSEC_TO_CLK(psec,clk)       DIV_CEIL(((psec) * (clk)), 1000000)
+#define CYCLES_TO_PSEC(cycles,clk)  (((cycles) * 1000000) / (clk))
+
+/* Min, Max macros */
+#define MIN(a,b)    ((a) < (b) ? (a) : (b))
+#define MAX(a,b)    ((a) > (b) ? (a) : (b))
+#define IN_RANGE(min,val,max) ((min)<=(val) && (val)<=(max))
+
+#if !(defined(ARRAY_SIZE))
+#define ARRAY_SIZE(arr)   (sizeof(arr) / sizeof((arr)[0]))
+#endif /* !defined(ARRAY_SIZE) */
+
+
+/* possible alignments */
+#define HALF_WORD_ALIGNMENT     2
+#define WORD_ALIGNMENT          4
+#define DOUBLE_WORD_ALIGNMENT   8
+#define BURST_ALIGNMENT         32
+
+#define HALF_WORD_ALIGNED       0x00000001
+#define WORD_ALIGNED            0x00000003
+#define DOUBLE_WORD_ALIGNED     0x00000007
+#define BURST_ALIGNED           0x0000001f
+
+
+#define LAST_BUF        1
+#define FIRST_BUF       2
+#define SINGLE_BUF      (LAST_BUF | FIRST_BUF)
+#define MIDDLE_BUF      4
+
+#define ARRAY_END       -1
+
+#define ILLEGAL_BASE    (~0)
+
+#define BUF_POSITION(first, last)   state[(!!(last))<<1 | !!(first)]
+#define DECLARE_POSITION static uint8_t state[4] = { (uint8_t)MIDDLE_BUF, (uint8_t)FIRST_BUF, (uint8_t)LAST_BUF, (uint8_t)SINGLE_BUF };
+
+
+/**************************************************************************//**
+ @Description   Timers operation mode
+*//***************************************************************************/
+typedef enum e_TimerMode
+{
+    e_TIMER_MODE_INVALID = 0,
+    e_TIMER_MODE_FREE_RUN,    /**< Free run - counter continues to increase
+                                   after reaching the reference value. */
+    e_TIMER_MODE_PERIODIC,    /**< Periodic - counter restarts counting from 0
+                                   after reaching the reference value. */
+    e_TIMER_MODE_SINGLE       /**< Single (one-shot) - counter stops counting
+                                   after reaching the reference value. */
+} e_TimerMode;
+
+
+/**************************************************************************//**
+ @Description   Enumeration (bit flags) of communication modes (Transmit,
+                receive or both).
+*//***************************************************************************/
+typedef enum e_CommMode
+{
+      e_COMM_MODE_NONE         = 0  /**< No transmit/receive communication */
+    , e_COMM_MODE_RX           = 1  /**< Only receive communication */
+    , e_COMM_MODE_TX           = 2  /**< Only transmit communication */
+    , e_COMM_MODE_RX_AND_TX    = 3  /**< Both transmit and receive communication */
+} e_CommMode;
+
+/**************************************************************************//**
+ @Description   General Diagnostic Mode
+*//***************************************************************************/
+typedef enum e_DiagMode
+{
+    e_DIAG_MODE_NONE = 0,
+    e_DIAG_MODE_CTRL_LOOPBACK,
+    e_DIAG_MODE_PHY_LOOPBACK,
+    e_DIAG_MODE_LINE_LOOPBACK,
+    e_DIAG_MODE_CTRL_ECHO,
+    e_DIAG_MODE_PHY_ECHO
+
+} e_DiagMode;
+
+/**************************************************************************//**
+ @Description   Possible RxStore callback responses.
+*//***************************************************************************/
+typedef enum e_RxStoreResponse
+{
+      e_RX_STORE_RESPONSE_PAUSE     /**< Pause invoking callback with received data;
+                                         in polling mode, start again invoking callback
+                                         only next time user invokes the receive routine;
+                                         in interrupt mode, start again invoking callback
+                                         only next time a receive event triggers an interrupt;
+                                         in all cases, received data that are pending are not
+                                         lost, rather, their processing is temporarily deferred;
+                                         in all cases, received data are processed in the order
+                                         in which they were received. */
+    , e_RX_STORE_RESPONSE_CONTINUE  /**< Continue invoking callback with received data. */
+} e_RxStoreResponse;
+
+
+/**************************************************************************//**
+ @Description   General Handle
+*//***************************************************************************/
+typedef void *      t_Handle;   /**< handle, used as object's descriptor */
+
+/**************************************************************************//**
+ @Description   MUTEX type
+*//***************************************************************************/
+typedef uint32_t    t_Mutex;
+
+/**************************************************************************//**
+ @Description   Error Code.
+
+                The high word of the error code is the code of the software
+                module (driver). The low word is the error type (e_ErrorType).
+                To get the values from the error code, use GET_ERROR_TYPE()
+                and GET_ERROR_MODULE().
+*//***************************************************************************/
+typedef uint32_t    t_Error;
+
+
+/**************************************************************************//**
+ @Description   General prototype of interrupt service routine (ISR).
+
+ @Param[in]     handle - Optional handle of the module handling the interrupt.
+
+ @Return        None
+ *//***************************************************************************/
+typedef void (t_Isr)(t_Handle handle);
+
+
+/**************************************************************************//**
+ @Anchor        mem_attr
+
+ @Collection    Memory Attributes
+
+                Various attributes of memory partitions. These values may be
+                or'ed together to create a mask of all memory attributes.
+ @{
+*//***************************************************************************/
+#define MEMORY_ATTR_CACHEABLE           0x00000001
+                                        /**< Memory is cacheable */
+#define MEMORY_ATTR_QE_2ND_BUS_ACCESS   0x00000002
+                                        /**< Memory can be accessed by QUICC Engine
+                                             through its secondary bus interface */
+
+/* @} */
+
+
+/**************************************************************************//**
+ @Function      t_GetBufFunction
+
+ @Description   User callback function called by driver to get data buffer.
+
+                User provides this function. Driver invokes it.
+
+ @Param[in]     h_BufferPool        - A handle to buffer pool manager
+ @Param[out]    p_BufContextHandle  - Returns the user's private context that
+                                      should be associated with the buffer
+
+ @Return        Pointer to data buffer, NULL if error
+ *//***************************************************************************/
+typedef uint8_t * (t_GetBufFunction)(t_Handle   h_BufferPool,
+                                     t_Handle   *p_BufContextHandle);
+
+/**************************************************************************//**
+ @Function      t_PutBufFunction
+
+ @Description   User callback function called by driver to return data buffer.
+
+                User provides this function. Driver invokes it.
+
+ @Param[in]     h_BufferPool    - A handle to buffer pool manager
+ @Param[in]     p_Buffer        - A pointer to buffer to return
+ @Param[in]     h_BufContext    - The user's private context associated with
+                                  the returned buffer
+
+ @Return        E_OK on success; Error code otherwise
+ *//***************************************************************************/
+typedef t_Error (t_PutBufFunction)(t_Handle h_BufferPool,
+                                   uint8_t  *p_Buffer,
+                                   t_Handle h_BufContext);
+
+/**************************************************************************//**
+ @Description   Buffer Pool Information Structure.
+*//***************************************************************************/
+typedef struct t_BufferPoolInfo
+{
+    t_Handle            h_BufferPool;   /**< A handle to the buffer pool manager */
+    t_GetBufFunction    *f_GetBuf;      /**< User callback to get a free buffer */
+    t_PutBufFunction    *f_PutBuf;      /**< User callback to return a buffer */
+    uint16_t            bufferSize;     /**< Buffer size (in bytes) */
+
+} t_BufferPoolInfo;
+
+
+/**************************************************************************//**
+ @Description   User callback function called by driver when transmit completed.
+
+                User provides this function. Driver invokes it.
+
+ @Param[in]     h_App           - Application's handle, as was provided to the
+                                  driver by the user
+ @Param[in]     queueId         - Transmit queue ID
+ @Param[in]     p_Data          - Pointer to the data buffer
+ @Param[in]     h_BufContext    - The user's private context associated with
+                                  the given data buffer
+ @Param[in]     status          - Transmit status and errors
+ @Param[in]     flags           - Driver-dependent information
+ *//***************************************************************************/
+typedef void (t_TxConfFunction)(t_Handle    h_App,
+                                uint32_t    queueId,
+                                uint8_t     *p_Data,
+                                t_Handle    h_BufContext,
+                                uint16_t    status,
+                                uint32_t    flags);
+
+/**************************************************************************//**
+ @Description   User callback function called by driver with receive data.
+
+                User provides this function. Driver invokes it.
+
+ @Param[in]     h_App           - Application's handle, as was provided to the
+                                  driver by the user
+ @Param[in]     queueId         - Receive queue ID
+ @Param[in]     p_Data          - Pointer to the buffer with received data
+ @Param[in]     h_BufContext    - The user's private context associated with
+                                  the given data buffer
+ @Param[in]     length          - Length of received data
+ @Param[in]     status          - Receive status and errors
+ @Param[in]     position        - Position of buffer in frame
+ @Param[in]     flags           - Driver-dependent information
+
+ @Retval        e_RX_STORE_RESPONSE_CONTINUE - order the driver to continue Rx
+                                               operation for all ready data.
+ @Retval        e_RX_STORE_RESPONSE_PAUSE    - order the driver to stop Rx operation.
+ *//***************************************************************************/
+typedef e_RxStoreResponse (t_RxStoreFunction)(t_Handle  h_App,
+                                              uint32_t  queueId,
+                                              uint8_t   *p_Data,
+                                              t_Handle  h_BufContext,
+                                              uint32_t  length,
+                                              uint16_t  status,
+                                              uint8_t   position,
+                                              uint32_t  flags);
+
+
+#endif /* __NCSW_EXT_H */
diff --git a/drivers/net/dpa/NetCommSw/inc/net_ext.h b/drivers/net/dpa/NetCommSw/inc/net_ext.h
new file mode 100644
index 0000000..5a6bcd8
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/inc/net_ext.h
@@ -0,0 +1,365 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**************************************************************************//**
+ @File          net_ext.h
+
+ @Description   This file contains common and general netcomm headers definitions.
+*//***************************************************************************/
+#ifndef __NET_EXT_H
+#define __NET_EXT_H
+
+#include "std_ext.h"
+
+
+typedef uint8_t headerFieldPpp_t;
+
+#define NET_HEADER_FIELD_PPP_PID                        (1)
+#define NET_HEADER_FIELD_PPP_COMPRESSED                 (NET_HEADER_FIELD_PPP_PID << 1)
+#define NET_HEADER_FIELD_PPP_ALL_FIELDS                 ((NET_HEADER_FIELD_PPP_PID << 2) - 1)
+
+
+typedef uint8_t headerFieldPppoe_t;
+
+#define NET_HEADER_FIELD_PPPoE_VER                      (1)
+#define NET_HEADER_FIELD_PPPoE_TYPE                     (NET_HEADER_FIELD_PPPoE_VER << 1)
+#define NET_HEADER_FIELD_PPPoE_CODE                     (NET_HEADER_FIELD_PPPoE_VER << 2)
+#define NET_HEADER_FIELD_PPPoE_SID                      (NET_HEADER_FIELD_PPPoE_VER << 3)
+#define NET_HEADER_FIELD_PPPoE_LEN                      (NET_HEADER_FIELD_PPPoE_VER << 4)
+#define NET_HEADER_FIELD_PPPoE_SESSION                  (NET_HEADER_FIELD_PPPoE_VER << 5)
+#define NET_HEADER_FIELD_PPPoE_PID                      (NET_HEADER_FIELD_PPPoE_VER << 6)
+#define NET_HEADER_FIELD_PPPoE_ALL_FIELDS               ((NET_HEADER_FIELD_PPPoE_VER << 7) - 1)
+
+#define NET_HEADER_FIELD_PPPMUX_PID                     (1)
+#define NET_HEADER_FIELD_PPPMUX_CKSUM                   (NET_HEADER_FIELD_PPPMUX_PID << 1)
+#define NET_HEADER_FIELD_PPPMUX_COMPRESSED              (NET_HEADER_FIELD_PPPMUX_PID << 2)
+#define NET_HEADER_FIELD_PPPMUX_ALL_FIELDS              ((NET_HEADER_FIELD_PPPMUX_PID << 3) - 1)
+
+#define NET_HEADER_FIELD_PPPMUX_SUBFRAME_PFF            (1)
+#define NET_HEADER_FIELD_PPPMUX_SUBFRAME_LXT            (NET_HEADER_FIELD_PPPMUX_SUBFRAME_PFF << 1)
+#define NET_HEADER_FIELD_PPPMUX_SUBFRAME_LEN            (NET_HEADER_FIELD_PPPMUX_SUBFRAME_PFF << 2)
+#define NET_HEADER_FIELD_PPPMUX_SUBFRAME_PID            (NET_HEADER_FIELD_PPPMUX_SUBFRAME_PFF << 3)
+#define NET_HEADER_FIELD_PPPMUX_SUBFRAME_USE_PID        (NET_HEADER_FIELD_PPPMUX_SUBFRAME_PFF << 4)
+#define NET_HEADER_FIELD_PPPMUX_SUBFRAME_ALL_FIELDS     ((NET_HEADER_FIELD_PPPMUX_SUBFRAME_PFF << 5) - 1)
+
+
+typedef uint8_t headerFieldEth_t;
+
+#define NET_HEADER_FIELD_ETH_DA                         (1)
+#define NET_HEADER_FIELD_ETH_SA                         (NET_HEADER_FIELD_ETH_DA << 1)
+#define NET_HEADER_FIELD_ETH_LENGTH                     (NET_HEADER_FIELD_ETH_DA << 2)
+#define NET_HEADER_FIELD_ETH_TYPE                       (NET_HEADER_FIELD_ETH_DA << 3)
+#define NET_HEADER_FIELD_ETH_FINAL_CKSUM                (NET_HEADER_FIELD_ETH_DA << 4)
+#define NET_HEADER_FIELD_ETH_PADDING                    (NET_HEADER_FIELD_ETH_DA << 5)
+#define NET_HEADER_FIELD_ETH_ALL_FIELDS                 ((NET_HEADER_FIELD_ETH_DA << 6) - 1)
+
+
+typedef uint16_t headerFieldIpv4_t;
+
+#define NET_HEADER_FIELD_IPv4_VER                       (1)
+#define NET_HEADER_FIELD_IPv4_HDR_LEN                   (NET_HEADER_FIELD_IPv4_VER << 1)
+#define NET_HEADER_FIELD_IPv4_TOS                       (NET_HEADER_FIELD_IPv4_VER << 2)
+#define NET_HEADER_FIELD_IPv4_TOTAL_LEN                 (NET_HEADER_FIELD_IPv4_VER << 3)
+#define NET_HEADER_FIELD_IPv4_ID                        (NET_HEADER_FIELD_IPv4_VER << 4)
+#define NET_HEADER_FIELD_IPv4_FLAG_D                    (NET_HEADER_FIELD_IPv4_VER << 5)
+#define NET_HEADER_FIELD_IPv4_FLAG_M                    (NET_HEADER_FIELD_IPv4_VER << 6)
+#define NET_HEADER_FIELD_IPv4_OFFSET                    (NET_HEADER_FIELD_IPv4_VER << 7)
+#define NET_HEADER_FIELD_IPv4_TTL                       (NET_HEADER_FIELD_IPv4_VER << 8)
+#define NET_HEADER_FIELD_IPv4_PROTO                     (NET_HEADER_FIELD_IPv4_VER << 9)
+#define NET_HEADER_FIELD_IPv4_CKSUM                     (NET_HEADER_FIELD_IPv4_VER << 10)
+#define NET_HEADER_FIELD_IPv4_SRC_IP                    (NET_HEADER_FIELD_IPv4_VER << 11)
+#define NET_HEADER_FIELD_IPv4_DST_IP                    (NET_HEADER_FIELD_IPv4_VER << 12)
+#define NET_HEADER_FIELD_IPv4_OPTS                      (NET_HEADER_FIELD_IPv4_VER << 13)
+#define NET_HEADER_FIELD_IPv4_OPTS_COUNT                (NET_HEADER_FIELD_IPv4_VER << 14)
+#define NET_HEADER_FIELD_IPv4_ALL_FIELDS                ((NET_HEADER_FIELD_IPv4_VER << 15) - 1)
+
+
+typedef uint8_t headerFieldIpv6_t;
+
+#define NET_HEADER_FIELD_IPv6_VER                       (1)
+#define NET_HEADER_FIELD_IPv6_TC                        (NET_HEADER_FIELD_IPv6_VER << 1)
+#define NET_HEADER_FIELD_IPv6_SRC_IP                    (NET_HEADER_FIELD_IPv6_VER << 2)
+#define NET_HEADER_FIELD_IPv6_DST_IP                    (NET_HEADER_FIELD_IPv6_VER << 3)
+#define NET_HEADER_FIELD_IPv6_NEXT_HDR                  (NET_HEADER_FIELD_IPv6_VER << 4)
+#define NET_HEADER_FIELD_IPv6_FL                        (NET_HEADER_FIELD_IPv6_VER << 5)
+#define NET_HEADER_FIELD_IPv6_HOP_LIMIT                 (NET_HEADER_FIELD_IPv6_VER << 6)
+#define NET_HEADER_FIELD_IPv6_ALL_FIELDS                ((NET_HEADER_FIELD_IPv6_VER << 7) - 1)
+
+#define NET_HEADER_FIELD_ICMP_TYPE                      (1)
+#define NET_HEADER_FIELD_ICMP_CODE                      (NET_HEADER_FIELD_ICMP_TYPE << 1)
+#define NET_HEADER_FIELD_ICMP_CKSUM                     (NET_HEADER_FIELD_ICMP_TYPE << 2)
+#define NET_HEADER_FIELD_ICMP_ID                        (NET_HEADER_FIELD_ICMP_TYPE << 3)
+#define NET_HEADER_FIELD_ICMP_SQ_NUM                    (NET_HEADER_FIELD_ICMP_TYPE << 4)
+#define NET_HEADER_FIELD_ICMP_ALL_FIELDS                ((NET_HEADER_FIELD_ICMP_TYPE << 5) - 1)
+
+#define NET_HEADER_FIELD_IGMP_VERSION                   (1)
+#define NET_HEADER_FIELD_IGMP_TYPE                      (NET_HEADER_FIELD_IGMP_VERSION << 1)
+#define NET_HEADER_FIELD_IGMP_CKSUM                     (NET_HEADER_FIELD_IGMP_VERSION << 2)
+#define NET_HEADER_FIELD_IGMP_DATA                      (NET_HEADER_FIELD_IGMP_VERSION << 3)
+#define NET_HEADER_FIELD_IGMP_ALL_FIELDS                ((NET_HEADER_FIELD_IGMP_VERSION << 4) - 1)
+
+
+typedef uint16_t headerFieldTcp_t;
+
+#define NET_HEADER_FIELD_TCP_PORT_SRC                   (1)
+#define NET_HEADER_FIELD_TCP_PORT_DST                   (NET_HEADER_FIELD_TCP_PORT_SRC << 1)
+#define NET_HEADER_FIELD_TCP_SEQ                        (NET_HEADER_FIELD_TCP_PORT_SRC << 2)
+#define NET_HEADER_FIELD_TCP_ACK                        (NET_HEADER_FIELD_TCP_PORT_SRC << 3)
+#define NET_HEADER_FIELD_TCP_OFFSET                     (NET_HEADER_FIELD_TCP_PORT_SRC << 4)
+#define NET_HEADER_FIELD_TCP_FLAGS                      (NET_HEADER_FIELD_TCP_PORT_SRC << 5)
+#define NET_HEADER_FIELD_TCP_WINDOW                     (NET_HEADER_FIELD_TCP_PORT_SRC << 6)
+#define NET_HEADER_FIELD_TCP_CKSUM                      (NET_HEADER_FIELD_TCP_PORT_SRC << 7)
+#define NET_HEADER_FIELD_TCP_URGPTR                     (NET_HEADER_FIELD_TCP_PORT_SRC << 8)
+#define NET_HEADER_FIELD_TCP_OPTS                       (NET_HEADER_FIELD_TCP_PORT_SRC << 9)
+#define NET_HEADER_FIELD_TCP_OPTS_COUNT                 (NET_HEADER_FIELD_TCP_PORT_SRC << 10)
+#define NET_HEADER_FIELD_TCP_ALL_FIELDS                 ((NET_HEADER_FIELD_TCP_PORT_SRC << 11) - 1)
+
+
+typedef uint8_t headerFieldSctp_t;
+
+#define NET_HEADER_FIELD_SCTP_PORT_SRC                  (1)
+#define NET_HEADER_FIELD_SCTP_PORT_DST                  (NET_HEADER_FIELD_SCTP_PORT_SRC << 1)
+#define NET_HEADER_FIELD_SCTP_VER_TAG                   (NET_HEADER_FIELD_SCTP_PORT_SRC << 2)
+#define NET_HEADER_FIELD_SCTP_CKSUM                     (NET_HEADER_FIELD_SCTP_PORT_SRC << 3)
+#define NET_HEADER_FIELD_SCTP_ALL_FIELDS                ((NET_HEADER_FIELD_SCTP_PORT_SRC << 4) - 1)
+
+
+typedef uint8_t headerFieldDccp_t;
+
+#define NET_HEADER_FIELD_DCCP_PORT_SRC                  (1)
+#define NET_HEADER_FIELD_DCCP_PORT_DST                  (NET_HEADER_FIELD_DCCP_PORT_SRC << 1)
+#define NET_HEADER_FIELD_DCCP_ALL_FIELDS                ((NET_HEADER_FIELD_DCCP_PORT_SRC << 2) - 1)
+
+
+typedef uint8_t headerFieldUdp_t;
+
+#define NET_HEADER_FIELD_UDP_PORT_SRC                   (1)
+#define NET_HEADER_FIELD_UDP_PORT_DST                   (NET_HEADER_FIELD_UDP_PORT_SRC << 1)
+#define NET_HEADER_FIELD_UDP_LEN                        (NET_HEADER_FIELD_UDP_PORT_SRC << 2)
+#define NET_HEADER_FIELD_UDP_CKSUM                      (NET_HEADER_FIELD_UDP_PORT_SRC << 3)
+#define NET_HEADER_FIELD_UDP_ALL_FIELDS                 ((NET_HEADER_FIELD_UDP_PORT_SRC << 4) - 1)
+
+#define NET_HEADER_FIELD_IPHC_CID                       (1)
+#define NET_HEADER_FIELD_IPHC_CID_TYPE                  (NET_HEADER_FIELD_IPHC_CID << 1)
+#define NET_HEADER_FIELD_IPHC_HCINDEX                   (NET_HEADER_FIELD_IPHC_CID << 2)
+#define NET_HEADER_FIELD_IPHC_GEN                       (NET_HEADER_FIELD_IPHC_CID << 3)
+#define NET_HEADER_FIELD_IPHC_D_BIT                     (NET_HEADER_FIELD_IPHC_CID << 4)
+#define NET_HEADER_FIELD_IPHC_ALL_FIELDS                ((NET_HEADER_FIELD_IPHC_CID << 5) - 1)
+
+#define NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE           (1)
+#define NET_HEADER_FIELD_SCTP_CHUNK_DATA_FLAGS          (NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 1)
+#define NET_HEADER_FIELD_SCTP_CHUNK_DATA_LENGTH         (NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 2)
+#define NET_HEADER_FIELD_SCTP_CHUNK_DATA_TSN            (NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 3)
+#define NET_HEADER_FIELD_SCTP_CHUNK_DATA_STREAM_ID      (NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 4)
+#define NET_HEADER_FIELD_SCTP_CHUNK_DATA_STREAM_SQN     (NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 5)
+#define NET_HEADER_FIELD_SCTP_CHUNK_DATA_PAYLOAD_PID    (NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 6)
+#define NET_HEADER_FIELD_SCTP_CHUNK_DATA_UNORDERED      (NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 7)
+#define NET_HEADER_FIELD_SCTP_CHUNK_DATA_BEGGINING      (NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 8)
+#define NET_HEADER_FIELD_SCTP_CHUNK_DATA_END            (NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 9)
+#define NET_HEADER_FIELD_SCTP_CHUNK_DATA_ALL_FIELDS     ((NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 10) - 1)
+
+#define NET_HEADER_FIELD_L2TPv2_TYPE_BIT                (1)
+#define NET_HEADER_FIELD_L2TPv2_LENGTH_BIT              (NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 1)
+#define NET_HEADER_FIELD_L2TPv2_SEQUENCE_BIT            (NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 2)
+#define NET_HEADER_FIELD_L2TPv2_OFFSET_BIT              (NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 3)
+#define NET_HEADER_FIELD_L2TPv2_PRIORITY_BIT            (NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 4)
+#define NET_HEADER_FIELD_L2TPv2_VERSION                 (NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 5)
+#define NET_HEADER_FIELD_L2TPv2_LEN                     (NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 6)
+#define NET_HEADER_FIELD_L2TPv2_TUNNEL_ID               (NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 7)
+#define NET_HEADER_FIELD_L2TPv2_SESSION_ID              (NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 8)
+#define NET_HEADER_FIELD_L2TPv2_NS                      (NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 9)
+#define NET_HEADER_FIELD_L2TPv2_NR                      (NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 10)
+#define NET_HEADER_FIELD_L2TPv2_OFFSET_SIZE             (NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 11)
+#define NET_HEADER_FIELD_L2TPv2_FIRST_BYTE              (NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 12)
+#define NET_HEADER_FIELD_L2TPv2_ALL_FIELDS              ((NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 13) - 1)
+
+#define NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT           (1)
+#define NET_HEADER_FIELD_L2TPv3_CTRL_LENGTH_BIT         (NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT << 1)
+#define NET_HEADER_FIELD_L2TPv3_CTRL_SEQUENCE_BIT       (NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT << 2)
+#define NET_HEADER_FIELD_L2TPv3_CTRL_VERSION            (NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT << 3)
+#define NET_HEADER_FIELD_L2TPv3_CTRL_LENGTH             (NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT << 4)
+#define NET_HEADER_FIELD_L2TPv3_CTRL_CONTROL            (NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT << 5)
+#define NET_HEADER_FIELD_L2TPv3_CTRL_SENT               (NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT << 6)
+#define NET_HEADER_FIELD_L2TPv3_CTRL_RECV               (NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT << 7)
+#define NET_HEADER_FIELD_L2TPv3_CTRL_FIRST_BYTE         (NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT << 8)
+#define NET_HEADER_FIELD_L2TPv3_CTRL_ALL_FIELDS         ((NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT << 9) - 1)
+
+#define NET_HEADER_FIELD_L2TPv3_SESS_TYPE_BIT           (1)
+#define NET_HEADER_FIELD_L2TPv3_SESS_VERSION            (NET_HEADER_FIELD_L2TPv3_SESS_TYPE_BIT << 1)
+#define NET_HEADER_FIELD_L2TPv3_SESS_ID                 (NET_HEADER_FIELD_L2TPv3_SESS_TYPE_BIT << 2)
+#define NET_HEADER_FIELD_L2TPv3_SESS_COOKIE             (NET_HEADER_FIELD_L2TPv3_SESS_TYPE_BIT << 3)
+#define NET_HEADER_FIELD_L2TPv3_SESS_ALL_FIELDS         ((NET_HEADER_FIELD_L2TPv3_SESS_TYPE_BIT << 4) - 1)
+
+
+typedef uint8_t headerFieldVlan_t;
+
+#define NET_HEADER_FIELD_VLAN_VPRI                      (1)
+#define NET_HEADER_FIELD_VLAN_CFI                       (NET_HEADER_FIELD_VLAN_VPRI << 1)
+#define NET_HEADER_FIELD_VLAN_VID                       (NET_HEADER_FIELD_VLAN_VPRI << 2)
+#define NET_HEADER_FIELD_VLAN_LENGTH                    (NET_HEADER_FIELD_VLAN_VPRI << 3)
+#define NET_HEADER_FIELD_VLAN_TYPE                      (NET_HEADER_FIELD_VLAN_VPRI << 4)
+#define NET_HEADER_FIELD_VLAN_TCI                       (NET_HEADER_FIELD_VLAN_VPRI << 5)
+#define NET_HEADER_FIELD_VLAN_ALL_FIELDS                ((NET_HEADER_FIELD_VLAN_VPRI << 6) - 1)
+
+
+typedef uint8_t headerFieldLlc_t;
+
+#define NET_HEADER_FIELD_LLC_DSAP                       (1)
+#define NET_HEADER_FIELD_LLC_SSAP                       (NET_HEADER_FIELD_LLC_DSAP << 1)
+#define NET_HEADER_FIELD_LLC_CTRL                       (NET_HEADER_FIELD_LLC_DSAP << 2)
+#define NET_HEADER_FIELD_LLC_ALL_FIELDS                 ((NET_HEADER_FIELD_LLC_DSAP << 3) - 1)
+
+#define NET_HEADER_FIELD_NLPID_NLPID                    (1)
+#define NET_HEADER_FIELD_NLPID_ALL_FIELDS               ((NET_HEADER_FIELD_NLPID_NLPID << 1) - 1)
+
+
+typedef uint8_t headerFieldSnap_t;
+
+#define NET_HEADER_FIELD_SNAP_OUI                       (1)
+#define NET_HEADER_FIELD_SNAP_PID                       (NET_HEADER_FIELD_SNAP_OUI << 1)
+#define NET_HEADER_FIELD_SNAP_ALL_FIELDS                ((NET_HEADER_FIELD_SNAP_OUI << 2) - 1)
+
+
+typedef uint8_t headerFieldLlcSnap_t;
+
+#define NET_HEADER_FIELD_LLC_SNAP_TYPE                  (1)
+#define NET_HEADER_FIELD_LLC_SNAP_ALL_FIELDS            ((NET_HEADER_FIELD_LLC_SNAP_ALL_FIELDS << 1) - 1)
+
+#define NET_HEADER_FIELD_ARP_HTYPE                      (1)
+#define NET_HEADER_FIELD_ARP_PTYPE                      (NET_HEADER_FIELD_ARP_HTYPE << 1)
+#define NET_HEADER_FIELD_ARP_HLEN                       (NET_HEADER_FIELD_ARP_HTYPE << 2)
+#define NET_HEADER_FIELD_ARP_PLEN                       (NET_HEADER_FIELD_ARP_HTYPE << 3)
+#define NET_HEADER_FIELD_ARP_OPER                       (NET_HEADER_FIELD_ARP_HTYPE << 4)
+#define NET_HEADER_FIELD_ARP_SHA                        (NET_HEADER_FIELD_ARP_HTYPE << 5)
+#define NET_HEADER_FIELD_ARP_SPA                        (NET_HEADER_FIELD_ARP_HTYPE << 6)
+#define NET_HEADER_FIELD_ARP_THA                        (NET_HEADER_FIELD_ARP_HTYPE << 7)
+#define NET_HEADER_FIELD_ARP_TPA                        (NET_HEADER_FIELD_ARP_HTYPE << 8)
+#define NET_HEADER_FIELD_ARP_ALL_FIELDS                 ((NET_HEADER_FIELD_ARP_HTYPE << 9) - 1)
+
+#define NET_HEADER_FIELD_RFC2684_LLC                    (1)
+#define NET_HEADER_FIELD_RFC2684_NLPID                  (NET_HEADER_FIELD_RFC2684_LLC << 1)
+#define NET_HEADER_FIELD_RFC2684_OUI                    (NET_HEADER_FIELD_RFC2684_LLC << 2)
+#define NET_HEADER_FIELD_RFC2684_PID                    (NET_HEADER_FIELD_RFC2684_LLC << 3)
+#define NET_HEADER_FIELD_RFC2684_VPN_OUI                (NET_HEADER_FIELD_RFC2684_LLC << 4)
+#define NET_HEADER_FIELD_RFC2684_VPN_IDX                (NET_HEADER_FIELD_RFC2684_LLC << 5)
+#define NET_HEADER_FIELD_RFC2684_ALL_FIELDS             ((NET_HEADER_FIELD_RFC2684_LLC << 6) - 1)
+
+#define NET_HEADER_FIELD_USER_DEFINED_SRCPORT           (1)
+#define NET_HEADER_FIELD_USER_DEFINED_PCDID             (NET_HEADER_FIELD_USER_DEFINED_SRCPORT << 1)
+#define NET_HEADER_FIELD_USER_DEFINED_ALL_FIELDS        ((NET_HEADER_FIELD_USER_DEFINED_SRCPORT << 2) - 1)
+
+#define NET_HEADER_FIELD_PAYLOAD_BUFFER                 (1)
+#define NET_HEADER_FIELD_PAYLOAD_SIZE                   (NET_HEADER_FIELD_PAYLOAD_BUFFER << 1)
+#define NET_HEADER_FIELD_MAX_FRM_SIZE                   (NET_HEADER_FIELD_PAYLOAD_BUFFER << 2)
+#define NET_HEADER_FIELD_MIN_FRM_SIZE                   (NET_HEADER_FIELD_PAYLOAD_BUFFER << 3)
+#define NET_HEADER_FIELD_PAYLOAD_TYPE                   (NET_HEADER_FIELD_PAYLOAD_BUFFER << 4)
+#define NET_HEADER_FIELD_FRAME_SIZE                     (NET_HEADER_FIELD_PAYLOAD_BUFFER << 5)
+#define NET_HEADER_FIELD_PAYLOAD_ALL_FIELDS             ((NET_HEADER_FIELD_PAYLOAD_BUFFER << 6) - 1)
+
+
+typedef uint8_t headerFieldGre_t;
+
+#define NET_HEADER_FIELD_GRE_TYPE                       (1)
+#define NET_HEADER_FIELD_GRE_ALL_FIELDS                 ((NET_HEADER_FIELD_GRE_TYPE << 1) - 1)
+
+
+typedef uint8_t headerFieldMinencap_t;
+
+#define NET_HEADER_FIELD_MINENCAP_SRC_IP                (1)
+#define NET_HEADER_FIELD_MINENCAP_DST_IP                (NET_HEADER_FIELD_MINENCAP_SRC_IP << 1)
+#define NET_HEADER_FIELD_MINENCAP_TYPE                  (NET_HEADER_FIELD_MINENCAP_SRC_IP << 2)
+#define NET_HEADER_FIELD_MINENCAP_ALL_FIELDS            ((NET_HEADER_FIELD_MINENCAP_SRC_IP << 3) - 1)
+
+
+typedef uint8_t headerFieldIpsecAh_t;
+
+#define NET_HEADER_FIELD_IPSEC_AH_SPI                   (1)
+#define NET_HEADER_FIELD_IPSEC_AH_NH                    (NET_HEADER_FIELD_IPSEC_AH_SPI << 1)
+#define NET_HEADER_FIELD_IPSEC_AH_ALL_FIELDS            ((NET_HEADER_FIELD_IPSEC_AH_SPI << 2) - 1)
+
+
+typedef uint8_t headerFieldIpsecEsp_t;
+
+#define NET_HEADER_FIELD_IPSEC_ESP_SPI                  (1)
+#define NET_HEADER_FIELD_IPSEC_ESP_ALL_FIELDS           ((NET_HEADER_FIELD_IPSEC_ESP_SPI << 1) - 1)
+
+
+typedef uint8_t headerFieldMpls_t;
+
+#define NET_HEADER_FIELD_MPLS_LABEL_STACK               (1)
+#define NET_HEADER_FIELD_MPLS_LABEL_STACK_ALL_FIELDS    ((NET_HEADER_FIELD_MPLS_LABEL_STACK << 1) - 1)
+
+
+typedef enum {
+    HEADER_TYPE_NONE = 0,
+    HEADER_TYPE_PAYLOAD,
+    HEADER_TYPE_ETH,
+    HEADER_TYPE_VLAN,
+    HEADER_TYPE_IPv4,
+    HEADER_TYPE_IPv6,
+    HEADER_TYPE_TCP,
+    HEADER_TYPE_UDP,
+    HEADER_TYPE_IPHC,
+    HEADER_TYPE_SCTP,
+    HEADER_TYPE_SCTP_CHUNK_DATA,
+    HEADER_TYPE_PPPoE,
+    HEADER_TYPE_PPP,
+    HEADER_TYPE_PPPMUX,
+    HEADER_TYPE_PPPMUX_SUBFRAME,
+    HEADER_TYPE_L2TPv2,
+    HEADER_TYPE_L2TPv3_CTRL,
+    HEADER_TYPE_L2TPv3_SESS,
+    HEADER_TYPE_LLC,
+    HEADER_TYPE_LLC_SNAP,
+    HEADER_TYPE_NLPID,
+    HEADER_TYPE_SNAP,
+    HEADER_TYPE_MPLS,
+    HEADER_TYPE_IPSEC_AH,
+    HEADER_TYPE_IPSEC_ESP,
+    HEADER_TYPE_GRE,
+    HEADER_TYPE_MINENCAP,
+    HEADER_TYPE_DCCP,
+    HEADER_TYPE_ICMP,
+    HEADER_TYPE_IGMP,
+    HEADER_TYPE_ARP,
+    HEADER_TYPE_RFC2684,
+    HEADER_TYPE_USER_DEFINED_L2,
+    HEADER_TYPE_USER_DEFINED_L3,
+    HEADER_TYPE_USER_DEFINED_L4,
+    HEADER_TYPE_USER_DEFINED_SHIM1,
+    HEADER_TYPE_USER_DEFINED_SHIM2,
+    HEADER_TYPE_USER_DEFINED_SHIM3,
+    MAX_HEADER_TYPE_COUNT
+} e_NetHeaderType;
+
+
+#endif /* __NET_EXT_H */
diff --git a/drivers/net/dpa/NetCommSw/inc/std_ext.h b/drivers/net/dpa/NetCommSw/inc/std_ext.h
new file mode 100644
index 0000000..ff4698a
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/inc/std_ext.h
@@ -0,0 +1,48 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+ /**************************************************************************//**
+
+ @File          std_ext.h
+
+ @Description   General Standard Definitions
+*//***************************************************************************/
+
+#ifndef __STD_EXT_H
+#define __STD_EXT_H
+
+
+#include "types_ext.h"
+#include "ncsw_ext.h"
+
+
+#endif /* __STD_EXT_H */
diff --git a/drivers/net/dpa/NetCommSw/inc/stdarg_ext.h b/drivers/net/dpa/NetCommSw/inc/stdarg_ext.h
new file mode 100644
index 0000000..091bd60
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/inc/stdarg_ext.h
@@ -0,0 +1,48 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __STDARG_EXT_H
+#define __STDARG_EXT_H
+
+
+#if defined(NCSW_LINUX) && defined(__KERNEL__)
+#include <stdarg.h>
+
+#else
+#include <stdarg.h>
+
+#endif /* defined(NCSW_LINUX) && defined(__KERNEL__) */
+
+#include "std_ext.h"
+
+
+#endif /* __STDARG_EXT_H */
diff --git a/drivers/net/dpa/NetCommSw/inc/stdlib_ext.h b/drivers/net/dpa/NetCommSw/inc/stdlib_ext.h
new file mode 100644
index 0000000..43b1d77
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/inc/stdlib_ext.h
@@ -0,0 +1,164 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+
+#ifndef __STDLIB_EXT_H
+#define __STDLIB_EXT_H
+
+
+#if (defined(MWI_UBOOT) || defined(NCSW_LINUX)) && defined(__KERNEL__)
+#include "stdarg_ext.h"
+#include "std_ext.h"
+
+
+/**
+ * strtoul - convert a string to an uint32_t
+ * @cp: The start of the string
+ * @endp: A pointer to the end of the parsed string will be placed here
+ * @base: The number base to use
+ */
+uint32_t strtoul(const char *cp,char **endp,uint32_t base);
+
+/**
+ * strtol - convert a string to a int32_t
+ * @cp: The start of the string
+ * @endp: A pointer to the end of the parsed string will be placed here
+ * @base: The number base to use
+ */
+long strtol(const char *cp,char **endp,uint32_t base);
+
+/**
+ * strtoull - convert a string to an uint64_t
+ * @cp: The start of the string
+ * @endp: A pointer to the end of the parsed string will be placed here
+ * @base: The number base to use
+ */
+uint64_t strtoull(const char *cp,char **endp,uint32_t base);
+
+/**
+ * strtoll - convert a string to a int64 long
+ * @cp: The start of the string
+ * @endp: A pointer to the end of the parsed string will be placed here
+ * @base: The number base to use
+ */
+long long strtoll(const char *cp,char **endp,uint32_t base);
+
+/**
+ * atoi - convert a character to a int
+ * @s: The start of the string
+ */
+int atoi(const char *s);
+
+/**
+ * strnlen - Find the length of a length-limited string
+ * @s: The string to be sized
+ * @count: The maximum number of bytes to search
+ */
+size_t strnlen(const char * s, size_t count);
+
+/**
+ * strlen - Find the length of a string
+ * @s: The string to be sized
+ */
+size_t strlen(const char * s);
+
+/**
+ * strtok - Split a string into tokens
+ * @s: The string to be searched
+ * @ct: The characters to search for
+ *
+ * WARNING: strtok is deprecated, use strsep instead.
+ */
+char * strtok(char * s,const char * ct);
+
+/**
+ * strncpy - Copy a length-limited, %NUL-terminated string
+ * @dest: Where to copy the string to
+ * @src: Where to copy the string from
+ * @count: The maximum number of bytes to copy
+ *
+ * Note that unlike userspace strncpy, this does not %NUL-pad the buffer.
+ * However, the result is not %NUL-terminated if the source exceeds
+ * @count bytes.
+ */
+char * strncpy(char * dest,const char *src,size_t count);
+
+/**
+ * strcpy - Copy a %NUL terminated string
+ * @dest: Where to copy the string to
+ * @src: Where to copy the string from
+ */
+char * strcpy(char * dest,const char *src);
+
+/**
+ * vsscanf - Unformat a buffer into a list of arguments
+ * @buf:    input buffer
+ * @fmt:    format of buffer
+ * @args:    arguments
+ */
+int vsscanf(const char * buf, const char * fmt, va_list args);
+
+/**
+ * vsnprintf - Format a string and place it in a buffer
+ * @buf: The buffer to place the result into
+ * @size: The size of the buffer, including the trailing null space
+ * @fmt: The format string to use
+ * @args: Arguments for the format string
+ *
+ * Call this function if you are already dealing with a va_list.
+ * You probably want snprintf instead.
+ */
+int vsnprintf(char *buf, size_t size, const char *fmt, va_list args);
+
+/**
+ * vsprintf - Format a string and place it in a buffer
+ * @buf: The buffer to place the result into
+ * @fmt: The format string to use
+ * @args: Arguments for the format string
+ *
+ * Call this function if you are already dealing with a va_list.
+ * You probably want sprintf instead.
+ */
+int vsprintf(char *buf, const char *fmt, va_list args);
+
+#elif defined(MWI_VXWORKS)
+#include "stdlib.h"
+
+#else
+#include <stdlib.h>
+#include <stdio.h>
+#endif /* defined(NCSW_LINUX) && defined(__KERNEL__) */
+
+#include "std_ext.h"
+
+
+#endif /* __STDLIB_EXT_H */
diff --git a/drivers/net/dpa/NetCommSw/inc/string_ext.h b/drivers/net/dpa/NetCommSw/inc/string_ext.h
new file mode 100644
index 0000000..b9aa8f2
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/inc/string_ext.h
@@ -0,0 +1,58 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __STRING_EXT_H
+#define __STRING_EXT_H
+
+
+#if defined(NCSW_LINUX) && defined(__KERNEL__)
+#include <linux/kernel.h>
+#include <linux/string.h>
+extern char * strtok ( char * str, const char * delimiters );
+
+#elif defined(MWI_VXWORKS)
+#include "string.h"
+
+#elif defined(MWI_UBOOT) || defined(__KERNEL__)
+#include "linux/types.h"
+#include "linux/posix_types.h"
+#include "linux/string.h"
+
+#else
+#include <string.h>
+
+#endif /* defined(NCSW_LINUX) && defined(__KERNEL__) */
+
+#include "std_ext.h"
+
+
+#endif /* __STRING_EXT_H */
diff --git a/drivers/net/dpa/NetCommSw/inc/types_ext.h b/drivers/net/dpa/NetCommSw/inc/types_ext.h
new file mode 100644
index 0000000..4a993d4
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/inc/types_ext.h
@@ -0,0 +1,94 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+ /**************************************************************************//**
+ @File          types_ext.h
+
+ @Description   General types Standard Definitions
+*//***************************************************************************/
+
+#ifndef __TYPES_EXT_H
+#define __TYPES_EXT_H
+
+
+#if defined (__ROCOO__)
+#include "types_rocoo.h"
+
+#elif defined (NCSW_LINUX)
+#include "types_linux.h"
+
+#elif defined (NCSW_VXWORKS)
+#include "types_vxworks.h"
+
+#elif defined (__MWERKS__) && defined (__GNUC__)
+#include "types_bb_gcc.h"
+
+#else
+#include "types_dflt.h"
+#endif /* defined (__ROCOO__) */
+
+
+static __inline__ void TypesChecker(void)
+{
+#ifdef __MWERKS__
+#pragma pack(push,1)
+#endif /*__MWERKS__ */
+#define MEM_MAP_START
+     _Packed struct strct {
+        __volatile__ int vi;
+    } _PackedType;
+#define MEM_MAP_END
+#ifdef __MWERKS__
+#pragma pack(pop)
+#endif /* __MWERKS__ */
+    size_t          size=0;
+    int             on=ON, off=OFF;
+    bool            tr=TRUE,fls=FALSE;
+    struct strct    *p_Strct = NULL;
+
+    on=off;
+    tr=fls;
+    p_Strct=p_Strct;
+    size++;
+
+    WRITE_UINT8(*(uint8_t *)UINT8_MAX, GET_UINT8(*(uint8_t *)UINT8_MIN));
+    WRITE_UINT16(*(uint16_t *)UINT16_MAX, GET_UINT16(*(uint16_t *)UINT16_MIN));
+    WRITE_UINT32(*(uint32_t *)UINT32_MAX, GET_UINT32(*(uint32_t *)UINT32_MIN));
+    WRITE_UINT64(*(uint64_t *)UINT64_MAX, GET_UINT64(*(uint64_t *)UINT64_MIN));
+    WRITE_UINT8(*(uint8_t *)INT8_MAX, GET_UINT8(*(uint8_t *)UINT8_MIN));
+    WRITE_UINT16(*(uint16_t *)INT16_MAX, GET_UINT16(*(uint16_t *)INT16_MIN));
+    WRITE_UINT32(*(uint32_t *)INT32_MAX, GET_UINT32(*(uint32_t *)INT32_MIN));
+    WRITE_UINT64(*(uint64_t *)INT64_MAX, GET_UINT64(*(uint64_t *)INT64_MIN));
+}
+
+
+#endif /* __TYPES_EXT_H */
diff --git a/drivers/net/dpa/NetCommSw/inc/xx_ext.h b/drivers/net/dpa/NetCommSw/inc/xx_ext.h
new file mode 100644
index 0000000..5adca3c
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/inc/xx_ext.h
@@ -0,0 +1,818 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**************************************************************************//**
+ @File          xx_ext.h
+
+ @Description   Prototypes, externals and typedefs for system-supplied
+                (external) routines
+*//***************************************************************************/
+
+#ifndef __XX_EXT_H
+#define __XX_EXT_H
+
+#include "std_ext.h"
+#include "part_ext.h"
+
+#if defined(__MWERKS__) && defined(OPTIMIZED_FOR_SPEED)
+#include "xx_integration_ext.h"
+#endif /* defined(__MWERKS__) && defined(OPTIMIZED_FOR_SPEED) */
+
+/**************************************************************************//**
+ @Group         xx_id  XX Interface (System call hooks)
+
+ @Description   Prototypes, externals and typedefs for system-supplied
+                (external) routines
+
+ @{
+*//***************************************************************************/
+
+#if (defined(REPORT_EVENTS) && (REPORT_EVENTS > 0))
+/**************************************************************************//**
+ @Function      XX_EventById
+
+ @Description   Event reporting routine - executed only when REPORT_EVENTS=1.
+
+ @Param[in]     event - Event code (e_Event).
+ @Param[in]     appId - Application identifier.
+ @Param[in]     flags - Event flags.
+ @Param[in]     msg   - Event message.
+
+ @Return        None
+*//***************************************************************************/
+void XX_EventById(uint32_t event, t_Handle appId, uint16_t flags, char *msg);
+
+#else  /* not REPORT_EVENTS */
+#define XX_EventById(event, appId, flags, msg)
+#endif /* REPORT_EVENTS */
+
+
+
+#ifdef DEBUG_XX_MALLOC
+
+void * XX_MallocDebug(uint32_t size, char *fname, int line);
+
+void * XX_MallocSmartDebug(uint32_t size,
+                           int      memPartitionId,
+                           uint32_t align,
+                           char     *fname,
+                           int      line);
+
+#define XX_Malloc(sz) \
+    XX_MallocDebug((sz), __FILE__, __LINE__)
+
+#define XX_MallocSmart(sz, memt, al) \
+    XX_MallocSmartDebug((sz), (memt), (al), __FILE__, __LINE__)
+
+#else /* not DEBUG_XX_MALLOC */
+
+/**************************************************************************//**
+ @Function      XX_Malloc
+
+ @Description   allocates contiguous block of memory.
+
+ @Param[in]     size - Number of bytes to allocate.
+
+ @Return        The address of the newly allocated block on success, NULL on failure.
+*//***************************************************************************/
+void * XX_Malloc(uint32_t size);
+
+/**************************************************************************//**
+ @Function      XX_MallocSmart
+
+ @Description   Allocates contiguous block of memory in a specified
+                alignment and from the specified segment.
+
+ @Param[in]     size            - Number of bytes to allocate.
+ @Param[in]     memPartitionId  - Memory partition ID; The value zero must
+                                  be mapped to the default heap partition.
+ @Param[in]     alignment       - Required memory alignment.
+
+ @Return        The address of the newly allocated block on success, NULL on failure.
+*//***************************************************************************/
+void * XX_MallocSmart(uint32_t size, int memPartitionId, uint32_t alignment);
+
+#endif /* not DEBUG_XX_MALLOC */
+
+/**************************************************************************//**
+ @Function      XX_FreeSmart
+
+ @Description   Frees the memory block pointed to by "p".
+                Only for memory allocated by XX_MallocSmart
+
+ @Param[in]     p_Memory - pointer to the memory block.
+
+ @Return        None.
+*//***************************************************************************/
+void XX_FreeSmart(void *p_Memory);
+
+/**************************************************************************//**
+ @Function      XX_Free
+
+ @Description   frees the memory block pointed to by "p".
+
+ @Param[in]     p_Memory - pointer to the memory block.
+
+ @Return        None.
+*//***************************************************************************/
+void XX_Free(void *p_Memory);
+
+
+/**************************************************************************//**
+ @Function      XX_GetPartitionBase
+
+ @Description   This routine gets the address of a memory segment according to
+                the memory type.
+
+ @Param[in]     memPartitionId  - Memory partition ID; The value zero must
+                                  be mapped to the default heap partition.
+
+ @Return        The address of the required memory type.
+*//***************************************************************************/
+void * XX_GetMemPartitionBase(int memPartitionId);
+
+/**************************************************************************//**
+ @Function      XX_Print
+
+ @Description   print a string.
+
+ @Param[in]     str - string to print.
+
+ @Return        None.
+*//***************************************************************************/
+void    XX_Print(char *str, ...);
+
+/**************************************************************************//**
+ @Function      XX_GetChar
+
+ @Description   Get character from console.
+
+ @Return        Character is returned on success. Zero is returned otherwise.
+*//***************************************************************************/
+char    XX_GetChar(void);
+
+/**************************************************************************//**
+ @Function      XX_SetIntr
+
+ @Description   Set an interupt service routine for a specific interrupt source.
+
+ @Param[in]     irq     - Interrupt ID (system-specific number).
+ @Param[in]     f_Isr   - Callback routine that will be called when the interupt occurs.
+ @Param[in]     handle  - The argument for the user callback routine.
+
+ @Return        E_OK on success; error code otherwise..
+*//***************************************************************************/
+t_Error XX_SetIntr(int irq, t_Isr *f_Isr, t_Handle handle);
+
+/**************************************************************************//**
+ @Function      XX_FreeIntr
+
+ @Description   Free a specific interrupt and a specific callback routine.
+
+ @Param[in]     irq - Interrupt ID (system-specific number).
+
+ @Return        E_OK on success; error code otherwise..
+*//***************************************************************************/
+t_Error XX_FreeIntr(int irq);
+
+/**************************************************************************//**
+ @Function      XX_EnableIntr
+
+ @Description   Enable a specific interrupt.
+
+ @Param[in]     irq - Interrupt ID (system-specific number).
+
+ @Return        E_OK on success; error code otherwise..
+*//***************************************************************************/
+t_Error XX_EnableIntr(int irq);
+
+/**************************************************************************//**
+ @Function      XX_DisableIntr
+
+ @Description   Disable a specific interrupt.
+
+ @Param[in]     irq - Interrupt ID (system-specific number).
+
+ @Return        E_OK on success; error code otherwise..
+*//***************************************************************************/
+t_Error XX_DisableIntr(int irq);
+
+#if !(defined(__MWERKS__) && defined(OPTIMIZED_FOR_SPEED))
+/**************************************************************************//**
+ @Function      XX_DisableAllIntr
+
+ @Description   Disable interrupts by writing to MSR register at the CPU.
+
+ @Return        intMASK a value that represent the interurupt mask before operation
+*//***************************************************************************/
+uint32_t XX_DisableAllIntr(void);
+
+/**************************************************************************//**
+ @Function      XX_RestoreAllIntr
+
+ @Description   Enable interrupts by writing to MSR register at the CPU.
+
+ @Param[in]     flags           - intMASK, mask of previos level function will set the mask based on it.
+
+ @Return        None.
+*//***************************************************************************/
+void XX_RestoreAllIntr(uint32_t flags);
+#endif /* !(defined(__MWERKS__) && defined(OPTIMIZED_FOR_SPEED)) */
+
+/**************************************************************************//**
+ @Function      XX_Call
+
+ @Description   Call a service in another task.
+
+                Activate the routine f via the queue identified by IntrManagerId. The
+                parameter to f is Id - the handle of the destination object
+
+ @Param[in]     intrManagerId   - Queue ID.
+ @Param[in]     f               - routine pointer.
+ @Param[in]     Id              - the parameter to be passed to f().
+ @Param[in]     h_App           - Application handle.
+ @Param[in]     flags           - Unused,
+
+ @Return        E_OK is returned on success. E_FAIL is returned otherwise (usually an operating system level failure).
+*//***************************************************************************/
+t_Error XX_Call( uint32_t intrManagerId,
+                 t_Error (* f)(t_Handle),
+                 t_Handle Id,
+                 t_Handle h_App,
+                 uint16_t flags );
+
+#ifndef BOOT_SEQ
+/**************************************************************************//**
+ @Function      XX_Exit
+
+ @Description   Stop execution and report status (where it is applicable)
+
+ @Param[in]     status - exit status
+*//***************************************************************************/
+void    XX_Exit(int status);
+#endif /* BOOT_SEQ */
+
+/*****************************************************************************/
+/*                        Tasklet Service Routines                           */
+/*****************************************************************************/
+typedef t_Handle t_TaskletHandle;
+
+/**************************************************************************//**
+ @Function      XX_InitTasklet
+
+ @Description   Create and initialize a tasklet object.
+
+ @Param[in]     routine - A routine to be ran as a tasklet.
+ @Param[in]     data    - An argument to pass to the tasklet.
+
+ @Return        Tasklet handle is returned on success. NULL is returned otherwise.
+*//***************************************************************************/
+t_TaskletHandle XX_InitTasklet (void (*routine)(void *), void *data);
+
+/**************************************************************************//**
+ @Function      XX_FreeTasklet
+
+ @Description   Free a tasklet object.
+
+ @Param[in]     h_Tasklet - A handle to a tasklet to be free.
+
+ @Return        None.
+*//***************************************************************************/
+void XX_FreeTasklet (t_TaskletHandle h_Tasklet);
+
+/**************************************************************************//**
+ @Function      XX_ScheduleTask
+
+ @Description   Schedule a tasklet object.
+
+ @Param[in]     h_Tasklet - A handle to a tasklet to be schedulded.
+ @Param[in]     immediate - Indicate whether to schedule this tasklet on
+                            the immediate queue or on the delayed one.
+
+ @Return        0 - on success. Error code - otherwise.
+*//***************************************************************************/
+int XX_ScheduleTask(t_TaskletHandle h_Tasklet, int immediate);
+
+/**************************************************************************//**
+ @Function      XX_FlushScheduledTasks
+
+ @Description   Flush all tasks there are in the scheduled tasks queue.
+
+ @Return        None.
+*//***************************************************************************/
+void XX_FlushScheduledTasks(void);
+
+/**************************************************************************//**
+ @Function      XX_TaskletIsQueued
+
+ @Description   Check if task is queued.
+
+ @Param[in]     h_Tasklet - A handle to a tasklet to be schedulded.
+
+ @Return        1 - task is queued. 0 - otherwise.
+*//***************************************************************************/
+int XX_TaskletIsQueued(t_TaskletHandle h_Tasklet);
+
+/**************************************************************************//**
+ @Function      XX_SetTaskletData
+
+ @Description   Set data to a scheduleded task. Used to change data of allready
+                scheduled task.
+
+ @Param[in]     h_Tasklet - A handle to a tasklet to be schedulded.
+ @Param[in]     data      - Data to be set.
+*//***************************************************************************/
+void XX_SetTaskletData(t_TaskletHandle h_Tasklet, t_Handle data);
+
+/**************************************************************************//**
+ @Function      XX_GetTaskletData
+
+ @Description   Get the data of scheduled task.
+
+ @Param[in]     h_Tasklet - A handle to a tasklet to be schedulded.
+
+ @Return        handle to the data of the task.
+*//***************************************************************************/
+t_Handle XX_GetTaskletData(t_TaskletHandle h_Tasklet);
+
+/**************************************************************************//**
+ @Function      XX_BottomHalf
+
+ @Description   Bottom half implementation, invoked by the interrupt handler.
+
+                This routine handles all bottom-half tasklets with interrupts
+                enabled.
+
+ @Return        None.
+*//***************************************************************************/
+void XX_BottomHalf(void);
+
+
+/*****************************************************************************/
+/*                        Semaphore Service Routines                         */
+/*****************************************************************************/
+typedef t_Handle t_SemaphoreHandle;
+typedef t_Handle t_MutexHandle;
+
+/**************************************************************************//**
+ @Function      XX_InitSemaphore
+
+ @Description   Creates a counting semaphore.
+
+ @Param[in]     initialCount - initial counter value.
+
+ @Return        Semaphore handle is returned on success. NULL is returned
+                otherwise.
+*//***************************************************************************/
+t_SemaphoreHandle XX_InitSemaphore(int initialCount);
+
+/**************************************************************************//**
+ @Function      XX_InitBinSemaphore
+
+ @Description   creates a binary semaphore, which is a semaphore with maximum
+                count of 1.
+
+ @Param[in]     initialCount - initial counter value, should be of course
+                               either 0 or 1.
+
+ @Return        Semaphore handle is returned on success. NULL is returned
+                otherwise.
+*//***************************************************************************/
+t_SemaphoreHandle XX_InitBinSemaphore(int initialCount);
+
+/**************************************************************************//**
+ @Function      XX_FreeSemaphore
+
+ @Description   Frees the memory allocated for the semaphore creation.
+
+ @Param[in]     h_Semaphore - A handle to a semaphore.
+
+ @Return        None.
+*//***************************************************************************/
+void XX_FreeSemaphore(t_SemaphoreHandle h_Semaphore);
+
+/**************************************************************************//**
+ @Function      XX_InitMutex
+
+ @Description   Creates a mutex.
+
+ @Return        Mutex handle is returned on success. NULL is returned
+                otherwise.
+*//***************************************************************************/
+t_MutexHandle XX_InitMutex(void);
+
+/**************************************************************************//**
+ @Function      XX_InitMutexLocked
+
+ @Description   Creates a mutex and locks it.
+
+ @Return        Mutex handle is returned on success; NULL otherwise.
+*//***************************************************************************/
+t_MutexHandle XX_InitMutexLocked(void);
+
+/**************************************************************************//**
+ @Function      XX_FreeMutex
+
+ @Description   Frees the memory allocated for the mutex creation.
+
+ @Param[in]     h_Mutex - A handle to a mutex.
+
+ @Return        None.
+*//***************************************************************************/
+void XX_FreeMutex(t_MutexHandle h_Mutex);
+
+/**************************************************************************//**
+ @Function      XX_DownSemaphore
+
+ @Description   Decrements the counter of the semaphore by 1; When counter
+                reaches 0, the semaphore is locked.
+
+ @Param[in]     h_Semaphore - A handle to a semaphore.
+
+ @Return        None.
+*//***************************************************************************/
+void XX_DownSemaphore(t_SemaphoreHandle h_Semaphore);
+
+/**************************************************************************//**
+ @Function      XX_UpSemaphore
+
+ @Description   Increments the counter of the semaphore by 1; When counter
+                passes 0, the semaphore is unlocked.
+
+ @Param[in]     h_Semaphore - A handle to a semaphore.
+
+ @Return        None.
+*//***************************************************************************/
+void XX_UpSemaphore(t_SemaphoreHandle h_Semaphore);
+
+/**************************************************************************//**
+ @Function      XX_TryLock
+
+ @Description   Tries to lock a mutex.
+
+ @Param[in]     h_Mutex - A handle to a mutex.
+
+ @Return        1 - on success. 0 - otherwise.
+*//***************************************************************************/
+int XX_TryLock(t_MutexHandle h_Mutex);
+
+/**************************************************************************//**
+ @Function      XX_Lock
+
+ @Description   Locks a mutex.
+
+ @Param[in]     h_Mutex - A handle to a mutex.
+
+ @Return        None.
+*//***************************************************************************/
+void XX_Lock(t_MutexHandle h_Mutex);
+
+/**************************************************************************//**
+ @Function      XX_Unlock
+
+ @Description   Unlocks a mutex.
+
+ @Param[in]     h_Mutex - A handle to a mutex.
+
+ @Return        None.
+*//***************************************************************************/
+void XX_Unlock(t_MutexHandle h_Mutex);
+
+
+/*****************************************************************************/
+/*                        Spinlock Service Routines                          */
+/*****************************************************************************/
+typedef t_Handle t_SpinlockHandle;
+
+/**************************************************************************//**
+ @Function      XX_InitSpinlock
+
+ @Description   Creates a spinlock.
+
+ @Return        Spinlock handle is returned on success; NULL otherwise.
+*//***************************************************************************/
+t_SpinlockHandle  XX_InitSpinlock(void);
+
+/**************************************************************************//**
+ @Function      XX_FreeSpinlock
+
+ @Description   Frees the memory allocated for the spinlock creation.
+
+ @Param[in]     h_Spinlock - A handle to a spinlock.
+
+ @Return        None.
+*//***************************************************************************/
+void XX_FreeSpinlock(t_SpinlockHandle h_Spinlock);
+
+/**************************************************************************//**
+ @Function      XX_Spinlock
+
+ @Description   Locks a spinlock.
+
+ @Param[in]     h_Spinlock - A handle to a spinlock.
+
+ @Return        None.
+*//***************************************************************************/
+void XX_Spinlock(t_SpinlockHandle h_Spinlock);
+
+/**************************************************************************//**
+ @Function      XX_Spinunlock
+
+ @Description   Unlocks a spinlock.
+
+ @Param[in]     h_Spinlock - A handle to a spinlock.
+
+ @Return        None.
+*//***************************************************************************/
+void XX_Spinunlock(t_SpinlockHandle h_Spinlock);
+
+/**************************************************************************//**
+ @Function      XX_IntrSpinlock
+
+ @Description   Locks a spinlock (interrupt safe).
+
+ @Param[in]     h_Spinlock - A handle to a spinlock.
+
+ @Return        None.
+*//***************************************************************************/
+void XX_IntrSpinlock(t_SpinlockHandle h_Spinlock);
+
+/**************************************************************************//**
+ @Function      XX_IntrSpinunlock
+
+ @Description   Unlocks a spinlock (interrupt safe).
+
+ @Param[in]     h_Spinlock - A handle to a spinlock.
+
+ @Return        None.
+*//***************************************************************************/
+void XX_IntrSpinunlock(t_SpinlockHandle h_Spinlock);
+
+
+/*****************************************************************************/
+/*                        Timers Service Routines                            */
+/*****************************************************************************/
+typedef t_Handle t_TimerHandle;
+
+/**************************************************************************//**
+ @Function      XX_CurrentTime
+
+ @Description   Returns current system time.
+
+ @Return        Current system time (in milliseconds).
+*//***************************************************************************/
+uint32_t XX_CurrentTime(void);
+
+/**************************************************************************//**
+ @Function      XX_CreateTimer
+
+ @Description   Creates a timer.
+
+ @Return        Timer handle is returned on success; NULL otherwise.
+*//***************************************************************************/
+t_TimerHandle XX_CreateTimer(void);
+
+/**************************************************************************//**
+ @Function      XX_FreeTimer
+
+ @Description   Frees the memory allocated for the timer creation.
+
+ @Param[in]     h_Timer - A handle to a timer.
+
+ @Return        None.
+*//***************************************************************************/
+void XX_FreeTimer(t_TimerHandle h_Timer);
+
+/**************************************************************************//**
+ @Function      XX_StartTimer
+
+ @Description   Starts a timer.
+
+                The user can select to start the timer as periodic timer or as
+                one-shot timer. The user should provide a callback routine that
+                will be called when the timer expires.
+
+ @Param[in]     h_Timer         - A handle to a timer.
+ @Param[in]     msecs           - Timer expiration period (in milliseconds).
+ @Param[in]     periodic        - TRUE for a periodic timer;
+                                  FALSE for a one-shot timer..
+ @Param[in]     f_TimerExpired  - A callback routine to be called when the
+                                  timer expires.
+ @Param[in]     h_Arg           - The argument to pass in the timer-expired
+                                  callback routine.
+
+ @Return        None.
+*//***************************************************************************/
+void XX_StartTimer(t_TimerHandle    h_Timer,
+                   uint32_t         msecs,
+                   bool             periodic,
+                   void             (*f_TimerExpired)(t_Handle h_Arg),
+                   t_Handle         h_Arg);
+
+/**************************************************************************//**
+ @Function      XX_StopTimer
+
+ @Description   Frees the memory allocated for the timer creation.
+
+ @Param[in]     h_Timer - A handle to a timer.
+
+ @Return        None.
+*//***************************************************************************/
+void XX_StopTimer(t_TimerHandle h_Timer);
+
+/**************************************************************************//**
+ @Function      XX_GetExpirationTime
+
+ @Description   Returns the time (in milliseconds) remaining until the
+                expiration of a timer.
+
+ @Param[in]     h_Timer - A handle to a timer.
+
+ @Return        The time left until the timer expires.
+*//***************************************************************************/
+uint32_t XX_GetExpirationTime(t_TimerHandle h_Timer);
+
+/**************************************************************************//**
+ @Function      XX_ModTimer
+
+ @Description   Updates the expiration time of a timer.
+
+                This routine adds the given time to the current system time,
+                and sets this value as the new expiration time of the timer.
+
+ @Param[in]     h_Timer - A handle to a timer.
+ @Param[in]     msecs   - The new interval until timer expiration
+                          (in milliseconds).
+
+ @Return        None.
+*//***************************************************************************/
+void XX_ModTimer(t_TimerHandle h_Timer, uint32_t msecs);
+
+/**************************************************************************//**
+ @Function      XX_TimerIsActive
+
+ @Description   Checks whether a timer is active (pending) or not.
+
+ @Param[in]     h_Timer - A handle to a timer.
+
+ @Return        0 - the timer is inactive; Non-zero value - the timer is active;
+*//***************************************************************************/
+int XX_TimerIsActive(t_TimerHandle h_Timer);
+
+/**************************************************************************//**
+ @Function      XX_Sleep
+
+ @Description   Non-busy wait until the desired time (in milliseconds) has passed.
+
+ @Param[in]     msecs - The requested sleep time (in milliseconds).
+
+ @Return        None.
+
+ @Cautions      This routine enables interrupts during its wait time.
+*//***************************************************************************/
+uint32_t XX_Sleep(uint32_t msecs);
+
+/**************************************************************************//**
+ @Function      XX_UDelay
+
+ @Description   Busy-wait until the desired time (in microseconds) has passed.
+
+ @Param[in]     usecs - The requested delay time (in microseconds).
+
+ @Return        None.
+
+ @Cautions      It is highly unrecommended to call this routine during interrupt
+                time, because the system time may not be updated properly during
+                the delay loop. The behavior of this routine during interrupt
+                time is unexpected.
+*//***************************************************************************/
+void XX_UDelay(uint32_t usecs);
+
+
+/*****************************************************************************/
+/*                         Other Service Routines                            */
+/*****************************************************************************/
+
+/**************************************************************************//**
+ @Function      XX_PhysToVirt
+
+ @Description   Translates a physical address to the matching virtual address.
+
+ @Param[in]     addr - The physical address to translate.
+
+ @Return        Virtual address.
+*//***************************************************************************/
+void * XX_PhysToVirt(void *addr);
+
+/**************************************************************************//**
+ @Function      XX_VirtToPhys
+
+ @Description   Translates a virtual address to the matching physical address.
+
+ @Param[in]     addr - The virtual address to translate.
+
+ @Return        Physical address.
+*//***************************************************************************/
+void * XX_VirtToPhys(void *addr);
+
+#define XXX_PhysToVirt(addr)  (CAST_POINTER_TO_UINT32(XX_PhysToVirt(CAST_UINT32_TO_POINTER(addr))))
+#define XXX_VirtToPhys(addr)  (CAST_POINTER_TO_UINT32(XX_VirtToPhys(CAST_UINT32_TO_POINTER(addr))))
+
+
+#define MSG_BODY_SIZE       512
+#ifdef CONFIG_MULTI_PARTITION_SUPPORT
+/**************************************************************************//**
+ @Group         xx_ipc  XX Inter-Partition-Communication API
+
+ @Description   The following API is to be used when working with multi-core.
+
+ @{
+*//***************************************************************************/
+typedef void (t_MsgCompletionCB) (t_Handle h_Arg, uint8_t msgBody[MSG_BODY_SIZE]);
+typedef t_Error (t_MsgHandler) (t_Handle h_Mod, uint32_t msgId, uint8_t msgBody[MSG_BODY_SIZE]);
+
+/**************************************************************************//**
+ @Function      XX_RegisterMessageHandler
+
+ @Description   This routine is used to register to the XX messaging mechanism.
+
+ @Param[in]     p_Addr          - The module address.
+ @Param[in]     f_MsgHandlerCB  - The module callback; It will be called when the
+                                  module gets message.
+ @Param[in]     h_Mod           - The module arg; It will be passed to the module
+                                  whithin the callback when it gets message.
+
+ @Return        E_OK is returned on success. error code is returned otherwise.
+*//***************************************************************************/
+t_Error XX_RegisterMessageHandler   (char *p_Addr, t_MsgHandler *f_MsgHandlerCB, t_Handle h_Mod);
+
+/**************************************************************************//**
+ @Function      XX_UnregisterMessageHandler
+
+ @Description   This routine is used to unregister to the XX messaging mechanism.
+
+ @Param[in]     p_Addr          - The module address.
+
+ @Return        E_OK is returned on success. error code is returned otherwise.
+*//***************************************************************************/
+t_Error XX_UnregisterMessageHandler (char *p_Addr);
+
+/**************************************************************************//**
+ @Function      XX_SendMessage
+
+ @Description   This routine is used to send messages to modules registered to the
+                XX messaging mechanism.
+
+ @Param[in]     p_DestAddr      - The destination module address.
+ @Param[in]     msgId           - The message ID.
+ @Param[in]     msgBody         - The message body (up to 64 bytes).
+ @Param[in]     f_CompletionCB  - The caller callback; It will be called after the
+                                  message will be handled by the destination module.
+                                  NOTE - if passing here NULL, the routine will be
+                                  blocking untill the destination module will
+                                  handle the message.
+ @Param[in]     h_CBArg         - The caller handler; This argument will be
+                                  passed to whithin the completion routine.
+
+ @Return        E_OK is returned on success. error code is returned otherwise.
+*//***************************************************************************/
+t_Error XX_SendMessage(char                 *p_DestAddr,
+                       uint32_t             msgId,
+                       uint8_t              msgBody[MSG_BODY_SIZE],
+                       t_MsgCompletionCB    *f_CompletionCB,
+                       t_Handle             h_CBArg);
+/** @} */ /* end of xx_ic group */
+#endif /* CONFIG_MULTI_PARTITION_SUPPORT */
+/** @} */ /* end of xx_id group */
+
+
+#endif /* __XX_EXT_H */
diff --git a/drivers/net/dpa/NetCommSw/integrations/P4080/Makefile b/drivers/net/dpa/NetCommSw/integrations/P4080/Makefile
new file mode 100644
index 0000000..4932179
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/integrations/P4080/Makefile
@@ -0,0 +1,11 @@
+#
+# Makefile for the Freescale Ethernet controllers
+#
+EXTRA_CFLAGS           += -DVERSION=\"\"
+#
+#Include netcomm SW specific definitions
+include $(srctree)/drivers/net/dpa/NetCommSw/ncsw_config.mk
+
+obj-y		+= module_strings.o
+
+
diff --git a/drivers/net/dpa/NetCommSw/integrations/P4080/P4080.c b/drivers/net/dpa/NetCommSw/integrations/P4080/P4080.c
new file mode 100644
index 0000000..d2474ff
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/integrations/P4080/P4080.c
@@ -0,0 +1,157 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "error_ext.h"
+#include "std_ext.h"
+#include "string_ext.h"
+#include "part_ext.h"
+#include "xx_ext.h"
+
+#include "P4080.h"
+
+
+/*****************************************************************************/
+static e_ModuleId GetModuleIdByBase(t_Handle h_P4080, uint32_t baseAddress)
+{
+    t_P4080   *p_P4080 = (t_P4080 *)h_P4080;
+    e_ModuleId  moduleId;
+
+    SANITY_CHECK_RETURN_VALUE(p_P4080, E_INVALID_HANDLE, e_MODULE_ID_DUMMY_LAST);
+
+    for (moduleId = (e_ModuleId)0; moduleId < e_MODULE_ID_DUMMY_LAST; moduleId++)
+    {
+        if (baseAddress == p_P4080->baseAddresses[moduleId])
+        {
+            return moduleId;
+        }
+    }
+
+    return e_MODULE_ID_DUMMY_LAST;
+}
+
+
+/*****************************************************************************/
+t_Handle P4080_ConfigAndInit(uint32_t baseAddress)
+{
+    t_P4080   *p_P4080;
+    t_Error     errCode;
+
+    p_P4080 = (t_P4080 *)XX_Malloc(sizeof(t_P4080));
+    if (!p_P4080)
+    {
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("P4080 driver structure"));
+        return NULL;
+    }
+
+    memset(p_P4080, 0, sizeof(t_P4080));
+
+    /* Initialize 'part' parameters with P4080 parameters and service routines. */
+    ((t_Part *)p_P4080)->f_GetModuleBase = P4080_GetModuleBase;
+    ((t_Part *)p_P4080)->f_GetModuleIdByBase = GetModuleIdByBase;
+    ((t_Part *)p_P4080)->f_GetRevInfo = (t_RevInfoCallback *)P4080_GetRevInfo;
+
+    errCode = P4080_MngInit(p_P4080, baseAddress);
+    if (errCode != E_OK)
+    {
+        P4080_Free(p_P4080);
+        REPORT_ERROR(MAJOR, errCode, NO_MSG);
+        return NULL;
+    }
+
+    return p_P4080;
+}
+
+/*****************************************************************************/
+t_Error P4080_Free(t_Handle h_P4080)
+{
+    t_P4080 *p_P4080 = (t_P4080 *)h_P4080;
+
+    SANITY_CHECK_RETURN_ERROR(p_P4080, E_INVALID_HANDLE);
+
+    P4080_MngFree(p_P4080);
+
+    XX_Free(p_P4080);
+
+    return E_OK;
+}
+
+/*****************************************************************************/
+uint32_t P4080_GetModuleBase(t_Handle h_P4080, e_ModuleId module)
+{
+    t_P4080 *p_P4080 = (t_P4080 *)h_P4080;
+
+    SANITY_CHECK_RETURN_VALUE(p_P4080, E_INVALID_HANDLE, 0);
+
+    return p_P4080->baseAddresses[module];
+}
+
+/*****************************************************************************/
+uint32_t P4080_GetPramSize(t_Handle h_P4080)
+{
+    SANITY_CHECK_RETURN_VALUE(h_P4080, E_INVALID_HANDLE, 0);
+
+    UNUSED(h_P4080);
+    return FM_MURAM_SIZE;
+}
+
+/*****************************************************************************/
+e_P4080DeviceName P4080_GetRevInfo(t_Handle h_P4080)
+{
+    t_P4080  *p_P4080 = (t_P4080 *)h_P4080;
+
+    SANITY_CHECK_RETURN_VALUE(p_P4080, E_INVALID_HANDLE, e_P4080_REV_INVALID);
+
+    REPORT_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+    return e_P4080_REV_INVALID;
+}
+
+/*****************************************************************************/
+t_Error P4080_GetE500Factor(t_Handle h_P4080, uint32_t *p_E500MulFactor, uint32_t *p_E500DivFactor)
+{
+    t_P4080   *p_P4080 = (t_P4080 *)h_P4080;
+
+    SANITY_CHECK_RETURN_ERROR(p_P4080, E_INVALID_HANDLE);
+
+    *p_E500MulFactor = 8;
+    *p_E500DivFactor = 3;
+    return E_OK;
+}
+
+/*****************************************************************************/
+uint32_t P4080_GetCcbFactor(t_Handle h_P4080)
+{
+    t_P4080   *p_P4080 = (t_P4080 *)h_P4080;
+
+    SANITY_CHECK_RETURN_VALUE(p_P4080, E_INVALID_HANDLE, 0);
+
+    return 8;
+}
diff --git a/drivers/net/dpa/NetCommSw/integrations/P4080/P4080.h b/drivers/net/dpa/NetCommSw/integrations/P4080/P4080.h
new file mode 100644
index 0000000..0e00dc1
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/integrations/P4080/P4080.h
@@ -0,0 +1,166 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+ /**************************************************************************//**
+
+ @File          P4080.h
+
+ @Description   P4080 object data structure declaration, definitions and internal prototypes.
+*//***************************************************************************/
+
+#ifndef __P4080_H
+#define __P4080_H
+
+#include "std_ext.h"
+#include "part_ext.h"
+
+
+#define __ERR_MODULE__  MODULE_P4080
+
+#ifdef __MWERKS__
+#pragma pack(push,1)
+#endif /* __MWERKS__ */
+#define MEM_MAP_START
+
+typedef _Packed struct
+{
+    /* system configuration module */
+    volatile uint32_t tbd;    /**< tbd */
+} _PackedType t_P4080SysCfgMemMap;
+
+#define MEM_MAP_END
+#ifdef __MWERKS__
+#pragma pack(pop)
+#endif /* __MWERKS__ */
+
+
+/* Offsets relative to larger memory map, with base IMMRBAR */
+#define DUART0_OFFSET           0x0011c500
+#define DUART1_OFFSET           0x0011c600
+#define DUART2_OFFSET           0x0011d500
+#define DUART3_OFFSET           0x0011d600
+#define QM_OFFSET               0x00318000
+#define BM_OFFSET               0x0031a000
+#define FM1_OFFSET              0x00400000
+#define FM2_OFFSET              0x00500000
+#define MPIC_OFFSET             0x00040000
+
+/* Offsets relative to FM_BASE_OFFSET off of base IMMRBAR */
+#define FM_MURAM_OFFSET         0x00000000
+#define FM_BMI_OFFSET           0x00080000
+#define FM_QMI_OFFSET           0x00080400
+#define FM_PRS_OFFSET           0x00080800
+#define FM_PORT_HO0_OFFSET      0x00081000
+#define FM_PORT_HO1_OFFSET      0x00082000
+#define FM_PORT_HO2_OFFSET      0x00083000
+#define FM_PORT_HO3_OFFSET      0x00084000
+#define FM_PORT_HO4_OFFSET      0x00085000
+#define FM_PORT_HO5_OFFSET      0x00086000
+#define FM_PORT_HO6_OFFSET      0x00087000
+#define FM_PORT_1GRX0_OFFSET    0x00088000
+#define FM_PORT_1GRX1_OFFSET    0x00089000
+#define FM_PORT_1GRX2_OFFSET    0x0008a000
+#define FM_PORT_1GRX3_OFFSET    0x0008b000
+#define FM_PORT_10GRX0_OFFSET   0x00090000
+#define FM_PORT_1GTX0_OFFSET    0x000a8000
+#define FM_PORT_1GTX1_OFFSET    0x000a9000
+#define FM_PORT_1GTX2_OFFSET    0x000aa000
+#define FM_PORT_1GTX3_OFFSET    0x000ab000
+#define FM_PORT_10GTX0_OFFSET   0x000b0000
+#define FM_PLCR_OFFSET          0x000c0000
+#define FM_KG_OFFSET            0x000c1000
+#define FM_DMA_OFFSET           0x000c2000
+#define FM_FPM_OFFSET           0x000c3000
+#define FM_IRAM_OFFSET          0x000c4000
+#define FM_PRS_IRAM_OFFSET      0x000c7000
+#define FM_RISC0_OFFSET         0x000d0000
+#define FM_RISC1_OFFSET         0x000d1000
+#define FM_1GMAC0_OFFSET        0x000e0000
+#define FM_1GMDIO0_OFFSET       0x000e1000
+#define FM_1GMAC1_OFFSET        0x000e2000
+#define FM_1GMDIO1_OFFSET       0x000e3000
+#define FM_1GMAC2_OFFSET        0x000e4000
+#define FM_1GMDIO2_OFFSET       0x000e5000
+#define FM_1GMAC3_OFFSET        0x000e6000
+#define FM_1GMDIO3_OFFSET       0x000e7000
+#define FM_10GMAC0_OFFSET       0x000f0000
+#define FM_10GMDIO_OFFSET       0x000f1000
+
+//#define FM_MURAM_SIZE 0x40000
+
+#define BM_PORTALS_CE_OFFSET    0x000000
+#define BM_PORTALS_CI_OFFSET    0x100000
+#define QM_PORTALS_CE_OFFSET    0x200000
+#define QM_PORTALS_CI_OFFSET    0x300000
+
+#define QM_PORTALS_OFFSET_CE(portal)    (0x4000 * portal)
+#define QM_PORTALS_OFFSET_CI(portal)    (0x1000 * portal)
+#define BM_PORTALS_OFFSET_CE(portal)    (0x4000 * portal)
+#define BM_PORTALS_OFFSET_CI(portal)    (0x1000 * portal)
+
+
+/*--------------------------------------*/
+/* Structure for the P4080 object.    */
+/*--------------------------------------*/
+typedef struct
+{
+    t_Part                  part;               /**< Common parameters for all parts */
+    uint32_t                baseAddresses[NUM_OF_MODULES];
+                                                /**< Modules offsets in memory map */
+} t_P4080;
+
+
+/**************************************************************************//**
+ @Function      P4080_MngInit
+
+ @Description   Initializes the P4080 module's managment unit.
+
+ @Param         p_P4080   - (in) Pointer to the P4080 control structure.
+ @Param         baseAddress - (in) Base address of the memory-map.
+
+ @Return        E_OK on success, other value otherwise.
+*//***************************************************************************/
+t_Error P4080_MngInit(t_P4080 *p_P4080, uint32_t baseAddress);
+
+/**************************************************************************//**
+ @Function      P4080_MngFree
+
+ @Description   Free the P4080 module's managment unit.
+
+ @Param         p_P4080 - (in) Pointer to the P4080 control structure.
+
+ @Return        E_OK on success, other value otherwise.
+*//***************************************************************************/
+t_Error P4080_MngFree(t_P4080 *p_P4080);
+
+
+#endif /* __P4080_H */
diff --git a/drivers/net/dpa/NetCommSw/integrations/P4080/P4080_mng.c b/drivers/net/dpa/NetCommSw/integrations/P4080/P4080_mng.c
new file mode 100644
index 0000000..b686e4c
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/integrations/P4080/P4080_mng.c
@@ -0,0 +1,150 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "string_ext.h"
+#include "error_ext.h"
+#include "std_ext.h"
+#include "xx_ext.h"
+
+#include "P4080.h"
+
+
+/*****************************************************************************/
+t_Error P4080_MngInit(t_P4080 *p_P4080, uint32_t baseAddress)
+{
+    uint32_t tmpBaseAddr = baseAddress;
+
+    /* Initialize base addresses to ILLEGAL_BASE */
+    memset(p_P4080->baseAddresses, (~0), NUM_OF_MODULES * sizeof(uint32_t));
+
+    /* init base addresses for all part's modules */
+    p_P4080->baseAddresses[e_MODULE_ID_DUART_1]   = tmpBaseAddr + DUART0_OFFSET;
+    p_P4080->baseAddresses[e_MODULE_ID_DUART_2]   = tmpBaseAddr + DUART1_OFFSET;
+    p_P4080->baseAddresses[e_MODULE_ID_DUART_3]   = tmpBaseAddr + DUART2_OFFSET;
+    p_P4080->baseAddresses[e_MODULE_ID_DUART_4]   = tmpBaseAddr + DUART3_OFFSET;
+    p_P4080->baseAddresses[e_MODULE_ID_QM]        = tmpBaseAddr + QM_OFFSET;
+    p_P4080->baseAddresses[e_MODULE_ID_BM]        = tmpBaseAddr + BM_OFFSET;
+    p_P4080->baseAddresses[e_MODULE_ID_MPIC]      = tmpBaseAddr + MPIC_OFFSET;
+
+    tmpBaseAddr = baseAddress + FM1_OFFSET;
+    p_P4080->baseAddresses[e_MODULE_ID_FM1]               = tmpBaseAddr;
+    p_P4080->baseAddresses[e_MODULE_ID_FM1_MURAM]         = tmpBaseAddr + FM_MURAM_OFFSET;
+    p_P4080->baseAddresses[e_MODULE_ID_FM1_BMI]           = tmpBaseAddr + FM_BMI_OFFSET;
+    p_P4080->baseAddresses[e_MODULE_ID_FM1_QMI]           = tmpBaseAddr + FM_QMI_OFFSET;
+    p_P4080->baseAddresses[e_MODULE_ID_FM1_PRS]           = tmpBaseAddr + FM_PRS_OFFSET;
+    p_P4080->baseAddresses[e_MODULE_ID_FM1_PORT_HO0]      = tmpBaseAddr + FM_PORT_HO0_OFFSET;
+    p_P4080->baseAddresses[e_MODULE_ID_FM1_PORT_HO1]      = tmpBaseAddr + FM_PORT_HO1_OFFSET;
+    p_P4080->baseAddresses[e_MODULE_ID_FM1_PORT_HO2]      = tmpBaseAddr + FM_PORT_HO2_OFFSET;
+    p_P4080->baseAddresses[e_MODULE_ID_FM1_PORT_HO3]      = tmpBaseAddr + FM_PORT_HO3_OFFSET;
+    p_P4080->baseAddresses[e_MODULE_ID_FM1_PORT_HO4]      = tmpBaseAddr + FM_PORT_HO4_OFFSET;
+    p_P4080->baseAddresses[e_MODULE_ID_FM1_PORT_HO5]      = tmpBaseAddr + FM_PORT_HO5_OFFSET;
+    p_P4080->baseAddresses[e_MODULE_ID_FM1_PORT_HO6]      = tmpBaseAddr + FM_PORT_HO6_OFFSET;
+    p_P4080->baseAddresses[e_MODULE_ID_FM1_PORT_1GRx0]    = tmpBaseAddr + FM_PORT_1GRX0_OFFSET;
+    p_P4080->baseAddresses[e_MODULE_ID_FM1_PORT_1GRx1]    = tmpBaseAddr + FM_PORT_1GRX1_OFFSET;
+    p_P4080->baseAddresses[e_MODULE_ID_FM1_PORT_1GRx2]    = tmpBaseAddr + FM_PORT_1GRX2_OFFSET;
+    p_P4080->baseAddresses[e_MODULE_ID_FM1_PORT_1GRx3]    = tmpBaseAddr + FM_PORT_1GRX3_OFFSET;
+    p_P4080->baseAddresses[e_MODULE_ID_FM1_PORT_10GRx0]   = tmpBaseAddr + FM_PORT_10GRX0_OFFSET;
+    p_P4080->baseAddresses[e_MODULE_ID_FM1_PORT_1GTx0]    = tmpBaseAddr + FM_PORT_1GTX0_OFFSET;
+    p_P4080->baseAddresses[e_MODULE_ID_FM1_PORT_1GTx1]    = tmpBaseAddr + FM_PORT_1GTX1_OFFSET;
+    p_P4080->baseAddresses[e_MODULE_ID_FM1_PORT_1GTx2]    = tmpBaseAddr + FM_PORT_1GTX2_OFFSET;
+    p_P4080->baseAddresses[e_MODULE_ID_FM1_PORT_1GTx3]    = tmpBaseAddr + FM_PORT_1GTX3_OFFSET;
+    p_P4080->baseAddresses[e_MODULE_ID_FM1_PORT_10GTx0]   = tmpBaseAddr + FM_PORT_10GTX0_OFFSET;
+    p_P4080->baseAddresses[e_MODULE_ID_FM1_PLCR]          = tmpBaseAddr + FM_PLCR_OFFSET;
+    p_P4080->baseAddresses[e_MODULE_ID_FM1_KG]            = tmpBaseAddr + FM_KG_OFFSET;
+    p_P4080->baseAddresses[e_MODULE_ID_FM1_DMA]           = tmpBaseAddr + FM_DMA_OFFSET;
+    p_P4080->baseAddresses[e_MODULE_ID_FM1_FPM]           = tmpBaseAddr + FM_FPM_OFFSET;
+    p_P4080->baseAddresses[e_MODULE_ID_FM1_IRAM]          = tmpBaseAddr + FM_IRAM_OFFSET;
+    p_P4080->baseAddresses[e_MODULE_ID_FM1_1GMDIO0]       = tmpBaseAddr + FM_1GMDIO0_OFFSET;
+    p_P4080->baseAddresses[e_MODULE_ID_FM1_1GMDIO1]       = tmpBaseAddr + FM_1GMDIO1_OFFSET;
+    p_P4080->baseAddresses[e_MODULE_ID_FM1_1GMDIO2]       = tmpBaseAddr + FM_1GMDIO2_OFFSET;
+    p_P4080->baseAddresses[e_MODULE_ID_FM1_1GMDIO3]       = tmpBaseAddr + FM_1GMDIO3_OFFSET;
+    p_P4080->baseAddresses[e_MODULE_ID_FM1_10GMDIO]       = tmpBaseAddr + FM_10GMDIO_OFFSET;
+    p_P4080->baseAddresses[e_MODULE_ID_FM1_PRS_IRAM]      = tmpBaseAddr + FM_PRS_IRAM_OFFSET;
+    p_P4080->baseAddresses[e_MODULE_ID_FM1_RISC0]         = tmpBaseAddr + FM_RISC0_OFFSET;
+    p_P4080->baseAddresses[e_MODULE_ID_FM1_RISC1]         = tmpBaseAddr + FM_RISC1_OFFSET;
+    p_P4080->baseAddresses[e_MODULE_ID_FM1_1GMAC0]        = tmpBaseAddr + FM_1GMAC0_OFFSET;
+    p_P4080->baseAddresses[e_MODULE_ID_FM1_1GMAC1]        = tmpBaseAddr + FM_1GMAC1_OFFSET;
+    p_P4080->baseAddresses[e_MODULE_ID_FM1_1GMAC2]        = tmpBaseAddr + FM_1GMAC2_OFFSET;
+    p_P4080->baseAddresses[e_MODULE_ID_FM1_1GMAC3]        = tmpBaseAddr + FM_1GMAC3_OFFSET;
+    p_P4080->baseAddresses[e_MODULE_ID_FM1_10GMAC0]       = tmpBaseAddr + FM_10GMAC0_OFFSET;
+
+    tmpBaseAddr = baseAddress + FM2_OFFSET;
+    p_P4080->baseAddresses[e_MODULE_ID_FM2]               = tmpBaseAddr;
+    p_P4080->baseAddresses[e_MODULE_ID_FM2_MURAM]         = tmpBaseAddr + FM_MURAM_OFFSET;
+    p_P4080->baseAddresses[e_MODULE_ID_FM2_BMI]           = tmpBaseAddr + FM_BMI_OFFSET;
+    p_P4080->baseAddresses[e_MODULE_ID_FM2_QMI]           = tmpBaseAddr + FM_QMI_OFFSET;
+    p_P4080->baseAddresses[e_MODULE_ID_FM2_PRS]           = tmpBaseAddr + FM_PRS_OFFSET;
+    p_P4080->baseAddresses[e_MODULE_ID_FM2_PORT_HO0]      = tmpBaseAddr + FM_PORT_HO0_OFFSET;
+    p_P4080->baseAddresses[e_MODULE_ID_FM2_PORT_HO1]      = tmpBaseAddr + FM_PORT_HO1_OFFSET;
+    p_P4080->baseAddresses[e_MODULE_ID_FM2_PORT_HO2]      = tmpBaseAddr + FM_PORT_HO2_OFFSET;
+    p_P4080->baseAddresses[e_MODULE_ID_FM2_PORT_HO3]      = tmpBaseAddr + FM_PORT_HO3_OFFSET;
+    p_P4080->baseAddresses[e_MODULE_ID_FM2_PORT_HO4]      = tmpBaseAddr + FM_PORT_HO4_OFFSET;
+    p_P4080->baseAddresses[e_MODULE_ID_FM2_PORT_HO5]      = tmpBaseAddr + FM_PORT_HO5_OFFSET;
+    p_P4080->baseAddresses[e_MODULE_ID_FM2_PORT_HO6]      = tmpBaseAddr + FM_PORT_HO6_OFFSET;
+    p_P4080->baseAddresses[e_MODULE_ID_FM2_PORT_1GRx0]    = tmpBaseAddr + FM_PORT_1GRX0_OFFSET;
+    p_P4080->baseAddresses[e_MODULE_ID_FM2_PORT_1GRx1]    = tmpBaseAddr + FM_PORT_1GRX1_OFFSET;
+    p_P4080->baseAddresses[e_MODULE_ID_FM2_PORT_1GRx2]    = tmpBaseAddr + FM_PORT_1GRX2_OFFSET;
+    p_P4080->baseAddresses[e_MODULE_ID_FM2_PORT_1GRx3]    = tmpBaseAddr + FM_PORT_1GRX3_OFFSET;
+    p_P4080->baseAddresses[e_MODULE_ID_FM2_PORT_10GRx0]   = tmpBaseAddr + FM_PORT_10GRX0_OFFSET;
+    p_P4080->baseAddresses[e_MODULE_ID_FM2_PORT_1GTx0]    = tmpBaseAddr + FM_PORT_1GTX0_OFFSET;
+    p_P4080->baseAddresses[e_MODULE_ID_FM2_PORT_1GTx1]    = tmpBaseAddr + FM_PORT_1GTX1_OFFSET;
+    p_P4080->baseAddresses[e_MODULE_ID_FM2_PORT_1GTx2]    = tmpBaseAddr + FM_PORT_1GTX2_OFFSET;
+    p_P4080->baseAddresses[e_MODULE_ID_FM2_PORT_1GTx3]    = tmpBaseAddr + FM_PORT_1GTX3_OFFSET;
+    p_P4080->baseAddresses[e_MODULE_ID_FM2_PORT_10GTx0]   = tmpBaseAddr + FM_PORT_10GTX0_OFFSET;
+    p_P4080->baseAddresses[e_MODULE_ID_FM2_PLCR]          = tmpBaseAddr + FM_PLCR_OFFSET;
+    p_P4080->baseAddresses[e_MODULE_ID_FM2_KG]            = tmpBaseAddr + FM_KG_OFFSET;
+    p_P4080->baseAddresses[e_MODULE_ID_FM2_DMA]           = tmpBaseAddr + FM_DMA_OFFSET;
+    p_P4080->baseAddresses[e_MODULE_ID_FM2_FPM]           = tmpBaseAddr + FM_FPM_OFFSET;
+    p_P4080->baseAddresses[e_MODULE_ID_FM2_IRAM]          = tmpBaseAddr + FM_IRAM_OFFSET;
+    p_P4080->baseAddresses[e_MODULE_ID_FM2_1GMDIO0]       = tmpBaseAddr + FM_1GMDIO0_OFFSET;
+    p_P4080->baseAddresses[e_MODULE_ID_FM2_1GMDIO1]       = tmpBaseAddr + FM_1GMDIO1_OFFSET;
+    p_P4080->baseAddresses[e_MODULE_ID_FM2_1GMDIO2]       = tmpBaseAddr + FM_1GMDIO2_OFFSET;
+    p_P4080->baseAddresses[e_MODULE_ID_FM2_1GMDIO3]       = tmpBaseAddr + FM_1GMDIO3_OFFSET;
+    p_P4080->baseAddresses[e_MODULE_ID_FM2_10GMDIO]       = tmpBaseAddr + FM_10GMDIO_OFFSET;
+    p_P4080->baseAddresses[e_MODULE_ID_FM2_PRS_IRAM]      = tmpBaseAddr + FM_PRS_IRAM_OFFSET;
+    p_P4080->baseAddresses[e_MODULE_ID_FM2_RISC0]         = tmpBaseAddr + FM_RISC0_OFFSET;
+    p_P4080->baseAddresses[e_MODULE_ID_FM2_RISC1]         = tmpBaseAddr + FM_RISC1_OFFSET;
+    p_P4080->baseAddresses[e_MODULE_ID_FM2_1GMAC0]        = tmpBaseAddr + FM_1GMAC0_OFFSET;
+    p_P4080->baseAddresses[e_MODULE_ID_FM2_1GMAC1]        = tmpBaseAddr + FM_1GMAC1_OFFSET;
+    p_P4080->baseAddresses[e_MODULE_ID_FM2_1GMAC2]        = tmpBaseAddr + FM_1GMAC2_OFFSET;
+    p_P4080->baseAddresses[e_MODULE_ID_FM2_1GMAC3]        = tmpBaseAddr + FM_1GMAC3_OFFSET;
+    p_P4080->baseAddresses[e_MODULE_ID_FM2_10GMAC0]       = tmpBaseAddr + FM_10GMAC0_OFFSET;
+
+    return E_OK;
+}
+
+/*****************************************************************************/
+t_Error P4080_MngFree(t_P4080 *p_P4080)
+{
+    UNUSED(p_P4080);
+    return E_OK;
+}
diff --git a/drivers/net/dpa/NetCommSw/integrations/P4080/module_strings.c b/drivers/net/dpa/NetCommSw/integrations/P4080/module_strings.c
new file mode 100644
index 0000000..16d0429
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/integrations/P4080/module_strings.c
@@ -0,0 +1,48 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/* Module names for debug messages */
+const char *moduleStrings[] =
+{
+     "???"                      /* MODULE_UNKNOWN */
+    ,"MEM"                      /* MODULE_ */
+    ,"MM"                       /* MODULE_MM */
+    ,"CORE"                     /* MODULE_CORE */
+    ,"PM"                       /* MODULE_PM */
+    ,"P4080"                    /* MODULE_P4080 */
+    ,"P4080-Pltaform"           /* MODULE_P4080_PLTFRM */
+    ,"MMU"                      /* MODULE_MMU */
+    ,"MPIC"                     /* MODULE_MPIC */
+    ,"FM"                       /* MODULE_FM */
+    ,"QM"                       /* MODULE_QM */
+    ,"BM"                       /* MODULE_BM */
+};
diff --git a/drivers/net/dpa/NetCommSw/ncsw_config.mk b/drivers/net/dpa/NetCommSw/ncsw_config.mk
new file mode 100644
index 0000000..2702f1f
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/ncsw_config.mk
@@ -0,0 +1,21 @@
+#
+# Makefile config for the Freescale NetcommSW
+#
+NET_DPA     = $(srctree)/drivers/net
+DRV_DPA     = $(srctree)/drivers/net/dpa
+NCSW        = $(srctree)/drivers/net/dpa/NetCommSw
+
+EXTRA_CFLAGS +=-include $(NCSW)/dflags.h
+
+EXTRA_CFLAGS += -I$(DRV_DPA)/
+EXTRA_CFLAGS += -I$(NCSW)/inc
+EXTRA_CFLAGS += -I$(NCSW)/inc/etc
+EXTRA_CFLAGS += -I$(NCSW)/inc/Peripherals
+EXTRA_CFLAGS += -I$(NCSW)/inc/integrations
+EXTRA_CFLAGS += -I$(NCSW)/inc/integrations/P4080
+EXTRA_CFLAGS += -I$(NCSW)/user/env/linux/kernel/2.6/inc
+EXTRA_CFLAGS += -I$(NCSW)/user/env/linux/kernel/2.6/inc/system
+EXTRA_CFLAGS += -I$(NCSW)/user/env/linux/kernel/2.6/inc/wrappers/Peripherals
+EXTRA_CFLAGS += -I$(NCSW)/user/env/linux/kernel/2.6/inc/ioctl
+EXTRA_CFLAGS += -I$(NCSW)/user/env/linux/kernel/2.6/inc/ioctl/Peripherals
+EXTRA_CFLAGS += -I$(NCSW)/user/env/linux/kernel/2.6/inc/ioctl/integrations/P4080
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/Makefile b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/Makefile
new file mode 100644
index 0000000..902fe6e
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/Makefile
@@ -0,0 +1,13 @@
+#
+# Makefile for the Freescale Ethernet controllers
+#
+EXTRA_CFLAGS           += -DVERSION=\"\"
+#
+#Include netcomm SW specific definitions
+include $(srctree)/drivers/net/dpa/NetCommSw/ncsw_config.mk
+#
+obj-y		+= modules/integrations/P4080/FM/
+obj-y		+= system/
+obj-y		+= util/
+obj-y		+= wrappers/Peripherals/FM/
+obj-y		+= xx/
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/Peripherals/fm_ioctls.h b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/Peripherals/fm_ioctls.h
new file mode 100644
index 0000000..95abf75
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/Peripherals/fm_ioctls.h
@@ -0,0 +1,293 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**************************************************************************//**
+ @File          fm_ioctls.h
+
+ @Description   FM Char device ioctls
+*//***************************************************************************/
+#ifndef __FM_IOCTLS_H
+#define __FM_IOCTLS_H
+
+
+/**************************************************************************//**
+ @Group         lnx_ioctl_FM_grp Frame Manager Linux IOCTL API
+
+ @Description   FM Linux ioctls definitions and enums
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Collection    FM IOCTL device ('/dev') definitions
+*//***************************************************************************/
+#define DEV_FM_NAME                 "fm" /**< Name of the FM chardev */
+
+#define DEV_FM_MINOR_BASE           0
+#define DEV_FM_PCD_MINOR_BASE       (DEV_FM_MINOR_BASE + 1)
+#define DEV_FM_HC_PORT_MINOR_BASE   (DEV_FM_PCD_MINOR_BASE + 1)
+#define DEV_FM_OP_PORTS_MINOR_BASE  (DEV_FM_HC_PORT_MINOR_BASE + 1)
+#define DEV_FM_RX_PORTS_MINOR_BASE  (DEV_FM_OP_PORTS_MINOR_BASE + 6)
+#define DEV_FM_TX_PORTS_MINOR_BASE  (DEV_FM_RX_PORTS_MINOR_BASE + 5)
+#define DEV_FM_MAX_MINORS           (DEV_FM_TX_PORTS_MINOR_BASE + 5)
+
+#define FM_IOC_NUM(n)       n
+#define FM_PCD_IOC_NUM(n)   (n+20)
+#define FM_PORT_IOC_NUM(n)  (n+50)
+/* @} */
+
+#define IOC_FM_MAX_NUM_OF_PORTS         64
+
+/**************************************************************************//**
+ @Collection   FM Frame error
+*//***************************************************************************/
+typedef uint32_t    ioc_fm_port_frame_err_select_t;                     /**< typedef for defining Frame Descriptor errors */
+
+#define IOC_FM_PORT_FRM_ERR_DMA                             0x01000000  /**< DMA Data error */
+#define IOC_FM_PORT_FRM_ERR_PHYSICAL                        0x00080000  /**< Rx FIFO overflow, FCS error, code error, running disparity
+                                                                             error (SGMII and TBI modes), FIFO parity error. PHY
+                                                                             Sequence error, PHY error control character detected. */
+#define IOC_FM_PORT_FRM_ERR_SIZE                            0x00040000  /**< Frame too long OR Frame size exceeds max_length_frame  */
+#define IOC_FM_PORT_FRM_ERR_CLS_DISCARD                     0x00020000  /**< classification discard */
+#define IOC_FM_PORT_FRM_ERR_EXTRACTION                      0x00008000  /**< Extract Out of Frame */
+#define IOC_FM_PORT_FRM_ERR_NO_SCHEME                       0x00004000  /**< No Scheme Selected */
+#define IOC_FM_PORT_FRM_ERR_KEYSIZE_OVERFLOW                0x00002000  /**< No Scheme Selected */
+#define IOC_FM_PORT_FRM_ERR_COLOR_YELLOW                    0x00000400
+#define IOC_FM_PORT_FRM_ERR_COLOR_RED                       0x00000800
+#define IOC_FM_PORT_FRM_ERR_ILL_PLCR                        0x00000200  /**< Illegal Policer Profile selected */
+#define IOC_FM_PORT_FRM_ERR_PLCR_FRAME_LEN                  0x00000100  /**< Illegal Policer Profile selected */
+#define IOC_FM_PORT_FRM_ERR_PRS_TIMEOUT                     0x00000080  /**< Parser Time out Exceed */
+#define IOC_FM_PORT_FRM_ERR_PRS_ILL_INSTRUCT                0x00000040  /**< Invalid Soft Parser instruction */
+#define IOC_FM_PORT_FRM_ERR_PRS_HDR_ERR                     0x00000020  /**< Header error was identified during parsing */
+#define IOC_FM_PORT_FRM_ERR_PROCESS_TIMEOUT                 0x00000001  /**< FPT Frame Processing Timeout Exceeded */
+#define IOC_FM_PORT_FRM_ERR_LENGTH                          0x02000000  /**< Offline parsing only! Length Error */
+#define IOC_FM_PORT_FRM_ERR_UNSUPPORTED_FORMAT              0x04000000  /**< Offline parsing only! Unsupported Format */
+/* @} */
+
+
+/**************************************************************************//**
+ @Description   enum for defining port types
+*//***************************************************************************/
+typedef enum ioc_fm_port_type {
+    e_IOC_FM_PORT_TYPE_OFFLINE_PARSING, /**< Offline parsing port (id's: 0-6, share id's with
+                                             host command, so must have exclusive id) */
+    e_IOC_FM_PORT_TYPE_HOST_COMMAND,    /**< Host command port (id's: 0-6, share id's with
+                                             offline parsing ports, so must have exclusive id) */
+    e_IOC_FM_PORT_TYPE_RX,              /**< 1G Rx port (id's: 0-3) */
+    e_IOC_FM_PORT_TYPE_RX_10G,          /**< 10G Rx port (id's: 0) */
+    e_IOC_FM_PORT_TYPE_TX,              /**< 1G Tx port (id's: 0-3) */
+    e_IOC_FM_PORT_TYPE_TX_10G,          /**< 10G Tx port (id's: 0) */
+    e_IOC_FM_PORT_TYPE_DUMMY
+} ioc_fm_port_type;
+
+
+/**************************************************************************//**
+ @Group         lnx_ioctl_FM_lib_grp FM library
+
+ @Description   FM API functions, definitions and enums
+                The FM module is the main driver module and is a mandatory module
+                for FM driver users. Before any further module initialization,
+                this module must be initialized.
+                The FM is a "single-tone" module. It is responsible of the common
+                HW modules: FPM, DMA, common QMI, common BMI initializations and
+                run-time control routines. This module must be initialized always
+                when working with any of the FM modules.
+                NOTE - We assumes that the FML will be initialize only by core No. 0!
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description   FM Exceptions
+*//***************************************************************************/
+typedef enum ioc_fm_exceptions {
+    e_IOC_FM_EX_DMA_BUS_ERROR,              /**< DMA bus error. */
+    e_IOC_FM_EX_DMA_READ_ECC,               /**< Read Buffer ECC error */
+    e_IOC_FM_EX_DMA_SYSTEM_WRITE_ECC,       /**< Write Buffer ECC error on system side */
+    e_IOC_FM_EX_DMA_FM_WRITE_ECC,           /**< Write Buffer ECC error on FM side */
+    e_IOC_FM_EX_FPM_STALL_ON_TASKS ,        /**< Stall of tasks on FPM */
+    e_IOC_FM_EX_FPM_SINGLE_ECC,             /**< Single ECC on FPM. */
+    e_IOC_FM_EX_FPM_DOUBLE_ECC,             /**< Double ECC error on FPM ram access */
+    e_IOC_FM_EX_QMI_SINGLE_ECC,             /**< Single ECC on QMI. */
+    e_IOC_FM_EX_QMI_DOUBLE_ECC,             /**< Double bit ECC occured on QMI */
+    e_IOC_FM_EX_QMI_DEQ_FROM_DEFQ,          /**< Dequeu from default queue id, as a result
+                                                 of invalid port id. */
+    e_IOC_FM_EX_BMI_LIST_RAM_ECC,           /**< Linked List RAM ECC error */
+    e_IOC_FM_EX_BMI_PIPELINE_ECC,           /**< Pipeline Table ECC Error */
+    e_IOC_FM_EX_BMI_STATISTICS_RAM_ECC,     /**< Statistics Count RAM ECC Error Enable */
+    e_IOC_FM_EX_IRAM_ECC,                   /**< Double bit ECC occured on IRAM*/
+    e_IOC_FM_EX_MURAM_ECC                   /**< Double bit ECC occured on MURAM*/
+} ioc_fm_exceptions;
+
+
+/**************************************************************************//**
+ @Group         lnx_ioctl_FM_runtime_control_grp FM Runtime Control Unit
+
+ @Description   FM Runtime control unit API functions, definitions and enums.
+                The FM driver provides a set of control routines for each module.
+                These routines may only be called after the module was fully
+                initialized (both configuration and initialization routines were
+                called). They are typically used to get information from hardware
+                (status, counters/statistics, revision etc.), to modify a current
+                state or to force/enable a required action. Run-time control may
+                be called whenever necessary and as many times as needed.
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Collection   General FM defines.
+*//***************************************************************************/
+#define IOC_FM_NUM_OF_PORT_TYPES            e_IOC_FM_PORT_TYPE_DUMMY
+#define IOC_FM_MAX_NUM_OF_PORTS_PER_TYPE    7
+/* @} */
+
+/**************************************************************************//**
+ @Description   Port id by type and relative id
+*//***************************************************************************/
+typedef uint8_t ioc_ports_param_t[IOC_FM_NUM_OF_PORT_TYPES][IOC_FM_MAX_NUM_OF_PORTS_PER_TYPE];
+
+/**************************************************************************//**
+ @Description   enum for defining FM counters
+*//***************************************************************************/
+typedef enum ioc_fm_counters {
+    e_IOC_FM_COUNTERS_ENQ_TOTAL_FRAME,              /**< QMI total enqueued frames counter */
+    e_IOC_FM_COUNTERS_DEQ_TOTAL_FRAME,              /**< QMI total dequeued frames counter */
+    e_IOC_FM_COUNTERS_DEQ_0,                        /**< QMI 0 frames from QMan counter */
+    e_IOC_FM_COUNTERS_DEQ_1,                        /**< QMI 1 frames from QMan counter */
+    e_IOC_FM_COUNTERS_DEQ_2,                        /**< QMI 2 frames from QMan counter */
+    e_IOC_FM_COUNTERS_DEQ_3,                        /**< QMI 3 frames from QMan counter */
+    e_IOC_FM_COUNTERS_DEQ_FROM_DEFAULT,             /**< QMI dequeue from default queue counter */
+    e_IOC_FM_COUNTERS_DEQ_FROM_CONTEXT,             /**< QMI dequeue from FQ context counter */
+    e_IOC_FM_COUNTERS_DEQ_FROM_FD,                  /**< QMI dequeue from FD command field counter */
+    e_IOC_FM_COUNTERS_DEQ_CONFIRM,                  /**< QMI dequeue confirm counter */
+    e_IOC_FM_COUNTERS_SEMAPHOR_ENTRY_FULL_REJECT,   /**< DMA semaphor reject due to full entry counter */
+    e_IOC_FM_COUNTERS_SEMAPHOR_QUEUE_FULL_REJECT,   /**< DMA semaphor reject due to full CAM queue counter */
+    e_IOC_FM_COUNTERS_SEMAPHOR_SYNC_REJECT          /**< DMA semaphor reject due to sync counter */
+} ioc_fm_counters;
+
+typedef struct ioc_fm_obj_t {
+    void            *obj;
+} ioc_fm_obj_t;
+
+/**************************************************************************//**
+ @Description   structure for returning revision information
+*//***************************************************************************/
+typedef struct ioc_fm_revision_info_t {
+    uint8_t         major;               /**< Major revision */
+    uint8_t         minor;               /**< Minor revision */
+} ioc_fm_revision_info_t;
+
+/**************************************************************************//**
+ @Description   structure for FM counters
+*//***************************************************************************/
+typedef struct ioc_fm_counters_params_t {
+    ioc_fm_counters cnt;                /**< The requested counter */
+    uint32_t        val;                /**< The requested value to get/set from/into the counter */
+} ioc_fm_counters_params_t;
+
+
+/**************************************************************************//**
+ @Function      FM_IOC_SET_PORTS_BANDWIDTH
+
+ @Description   Sets relative weights between ports when accessing common resources.
+
+ @Param[in]     ioc_ports_param_t   A table of ports bandwidth in percentage, i.e.
+                                    total must equal 100.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Init().
+*//***************************************************************************/
+#define FM_IOC_SET_PORTS_BANDWIDTH                             _IOW(FM_IOC_TYPE_BASE, FM_IOC_NUM(2), ioc_ports_param_t)
+
+/**************************************************************************//**
+ @Function      FM_IOC_GET_REVISION
+
+ @Description   Returns the FM revision
+
+ @Param[out]    ioc_fm_revision_info_t  A structure of revision information parameters.
+
+ @Return        None.
+
+ @Cautions      Allowed only following FM_Init().
+*//***************************************************************************/
+#define FM_IOC_GET_REVISION                                    _IOR(FM_IOC_TYPE_BASE, FM_IOC_NUM(3), ioc_fm_revision_info_t)
+
+/**************************************************************************//**
+ @Function      FM_IOC_GET_COUNTER
+
+ @Description   Reads one of the FM counters.
+
+ @Param[in,out] ioc_fm_counters_params_t The requested counter parameters.
+
+ @Return        Counter's current value.
+
+ @Cautions      Allowed only following FM_Init().
+                Note that it is user's responsibilty to call this routine only
+                for enabled counters, and there will be no indication if a
+                disabled counter is accessed.
+*//***************************************************************************/
+#define FM_IOC_GET_COUNTER                                    _IOWR(FM_IOC_TYPE_BASE, FM_IOC_NUM(4), ioc_fm_counters_params_t)
+
+/**************************************************************************//**
+ @Function      FM_IOC_SET_COUNTER
+
+ @Description   Sets a value to an enabled counter. Use "0" to reset the counter.
+
+ @Param[in]     ioc_fm_counters_params_t The requested counter parameters.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Init().
+*//***************************************************************************/
+#define FM_IOC_SET_COUNTER                                    _IOW(FM_IOC_TYPE_BASE, FM_IOC_NUM(5), ioc_fm_counters_params_t)
+
+/**************************************************************************//**
+ @Function      FM_IOC_FORCE_INTR
+
+ @Description   Causes an interrupt event on the requested source.
+
+ @Param[in]     ioc_fm_exceptions   An exception to be forced.
+
+ @Return        E_OK on success; Error code if the exception is not enabled,
+                or is not able to create interrupt.
+
+ @Cautions      Allowed only following FM_Init().
+*//***************************************************************************/
+#define FM_IOC_FORCE_INTR                                    _IOW(FM_IOC_TYPE_BASE, FM_IOC_NUM(6), ioc_fm_exceptions)
+
+/** @} */ /* end of lnx_ioctl_FM_runtime_control_grp group */
+/** @} */ /* end of lnx_ioctl_FM_lib_grp group */
+/** @} */ /* end of lnx_ioctl_FM_grp */
+
+
+#endif /* __FM_IOCTLS_H */
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/Peripherals/fm_pcd_ioctls.h b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/Peripherals/fm_pcd_ioctls.h
new file mode 100644
index 0000000..170a2fa
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/Peripherals/fm_pcd_ioctls.h
@@ -0,0 +1,1498 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/******************************************************************************
+ @File          fm_pcd_ioctls.h
+
+ @Description   FM PCD ...
+*//***************************************************************************/
+#ifndef __FM_PCD_IOCTLS_H
+#define __FM_PCD_IOCTLS_H
+
+#include "net_ioctls.h"
+#include "fm_ioctls.h"
+
+
+/**************************************************************************//**
+ @Group         lnx_ioctl_FM_grp Frame Manager Linux IOCTL API
+
+ @Description   FM Linux ioctls definitions and enums
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Group         lnx_ioctl_FM_PCD_grp FM PCD
+
+ @Description   FM PCD API functions, definitions and enums
+
+                The FM PCD module is responsible for the initialization of all
+                global classifying FM modules. This includes the parser general and
+                common registers, the key generator global and common registers,
+                and the Policer global and common registers.
+                In addition, the FM PCD SW module will initialize all required
+                key generator schemes, coarse classification flows, and Policer
+                profiles. When An FM module is configured to work with one of these
+                entities, it will register to it using the FM PORT API. The PCD
+                module will manage the PCD resources - i.e. resource management of
+                Keygen schemes, etc.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Collection    General PCD defines
+*//***************************************************************************/
+#define IOC_FM_PCD_MAX_NUM_OF_PRIVATE_HDRS              3                   /**< Number of units/headers saved for user */
+
+#define IOC_FM_PCD_PRS_NUM_OF_HDRS                      16                  /**< Number of headers supported by HW parser */
+#define IOC_FM_PCD_KG_NUM_OF_SCHEMES                    32                  /**< Total number of KG schemes */
+#define IOC_FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS         (32 - IOC_FM_PCD_MAX_NUM_OF_PRIVATE_HDRS)
+                                                                            /**< Maximum number of netenv distinction units */
+#define IOC_FM_PCD_MAX_NUM_OF_OPTIONS                   8                   /**< Maximum number of netenv distinction units options */
+#define IOC_FM_PCD_MAX_NUM_OF_INTERCHANGABLE_HDRS       4                   /**< Maximum number of interchangable headers in a distinction unit */
+#define IOC_FM_PCD_KG_NUM_OF_GENERIC_REGS               8                   /**< Total number of generic KG registers */
+#define IOC_FM_PCD_KG_MAX_NUM_OF_EXTRACTS_PER_KEY       35                  /**< Max number allowed on any configuration.
+                                                                                 For reason of HW implemetation, in most
+                                                                                 cases less than this will be allowed. The
+                                                                                 driver will return error in initialization
+                                                                                 time if resource is overused. */
+#define IOC_FM_PCD_MAX_NUM_OF_CLS_PLANS                 256                 /**< Number of classification plan entries. */
+#define IOC_FM_PCD_KG_NUM_OF_EXTRACT_MASKS              4                   /**< Total number of masks allowed on KG extractions. */
+#define IOC_FM_PCD_KG_NUM_OF_DEFAULT_GROUPS             16                  /**< Number of default value logical groups */
+
+#define IOC_FM_PCD_PRS_NUM_OF_LABELS                    32                  /**< Max number of SW parser label */
+/* @} */
+
+/**************************************************************************//**
+ @Group         lnx_ioctl_FM_PCD_Runtime_grp FM PCD Runtime Unit
+
+ @Description   FM PCD Runtime Unit
+
+                The runtime control allows creation of PCD infrastructure modules
+                such as Network Environment Characteristics, Classification Plan
+                Groups and Coarse Classification Trees.
+                It also allows on-the-fly initialization, modification and removal
+                of PCD modules such as Keygen schemes, coarse classification nodes
+                and Policer profiles.
+
+
+                In order to explain the programming model of the PCD driver interface
+                a few terms should be explained, and will be used below.
+                  * Distinction Header - One of the 16 protocols supported by the FM parser,
+                    or one of the shim headers (1-3). May be a header with a special
+                    option (see below).
+                  * Interchangeable Headers Group- This is a group of Headers recognized
+                    by either one of them. For example, if in a specific context the user
+                    chooses to treat IPv4 and IPV6 in the same way, they may create an
+                    Interchangable Headers Unit consisting of these 2 headers.
+                  * A Distinction Unit - a Distinction Header or an Interchangeable Headers
+                    Group.
+                  * Header with special option - applies to ethernet, mpls, vlan, ipv4 and
+                    ipv6, includes multicast, broadcast and other protocol specific options.
+                    In terms of hardware it relates to the options available in the classification
+                    plan.
+                  * Network Environment Characteristics - a set of Distinction Units that define
+                    the total recognizable header selection for a certain environment. This is
+                    NOT the list of all headers that will ever appear in a flow, but rather
+                    everything that needs distinction in a flow, where distinction is made by keygen
+                    schemes and coarse classification action descriptors.
+
+                The PCD runtime modules initialization is done in stages. The first stage after
+                initializing the PCD module itself is to establish a Network Flows Environment
+                Definition. The application may choose to establish one or more such environments.
+                Later, when needed, the application will have to state, for some of its modules,
+                to which single environment it belongs.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description   PCD counters
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_counters {
+    e_IOC_FM_PCD_KG_COUNTERS_TOTAL,                                 /**< Policer counter */
+    e_IOC_FM_PCD_PLCR_COUNTERS_YELLOW,                              /**< Policer counter */
+    e_IOC_FM_PCD_PLCR_COUNTERS_RED,                                 /**< Policer counter */
+    e_IOC_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_RED,                    /**< Policer counter */
+    e_IOC_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_YELLOW,                 /**< Policer counter */
+    e_IOC_FM_PCD_PLCR_COUNTERS_TOTAL,                               /**< Policer counter */
+    e_IOC_FM_PCD_PLCR_COUNTERS_LENGTH_MISMATCH,                     /**< Policer counter */
+    e_IOC_FM_PCD_PRS_COUNTERS_PARSE_DISPATCH,                       /**< Parser counter */
+    e_IOC_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED,             /**< Parser counter */
+    e_IOC_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED,             /**< Parser counter */
+    e_IOC_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED,             /**< Parser counter */
+    e_IOC_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED,           /**< Parser counter */
+    e_IOC_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED_WITH_ERR,    /**< Parser counter */
+    e_IOC_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED_WITH_ERR,    /**< Parser counter */
+    e_IOC_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED_WITH_ERR,    /**< Parser counter */
+    e_IOC_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED_WITH_ERR,  /**< Parser counter */
+    e_IOC_FM_PCD_PRS_COUNTERS_SOFT_PRS_CYCLES,                      /**< Parser counter */
+    e_IOC_FM_PCD_PRS_COUNTERS_SOFT_PRS_STALL_CYCLES,                /**< Parser counter */
+    e_IOC_FM_PCD_PRS_COUNTERS_HARD_PRS_CYCLE_INCL_STALL_CYCLES,     /**< Parser counter */
+    e_IOC_FM_PCD_PRS_COUNTERS_MURAM_READ_CYCLES,                    /**< MURAM counter */
+    e_IOC_FM_PCD_PRS_COUNTERS_MURAM_READ_STALL_CYCLES,              /**< MURAM counter */
+    e_IOC_FM_PCD_PRS_COUNTERS_MURAM_WRITE_CYCLES,                   /**< MURAM counter */
+    e_IOC_FM_PCD_PRS_COUNTERS_MURAM_WRITE_STALL_CYCLES,             /**< MURAM counter */
+    e_IOC_FM_PCD_PRS_COUNTERS_FPM_COMMAND_STALL_CYCLES              /**< FPM counter */
+} ioc_fm_pcd_counters;
+
+/**************************************************************************//**
+ @Description   PCD interrupts
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_exceptions {
+    e_IOC_FM_PCD_KG_ERR_EXCEPTION_DOUBLE_ECC,                   /**< Keygen ECC error */
+    e_IOC_FM_PCD_PLCR_ERR_EXCEPTION_DOUBLE_ECC,                 /**< Read Buffer ECC error */
+    e_IOC_FM_PCD_KG_ERR_EXCEPTION_KEYSIZE_OVERFLOW,             /**< Write Buffer ECC error on system side */
+    e_IOC_FM_PCD_PLCR_ERR_EXCEPTION_INIT_ENTRY_ERROR,           /**< Write Buffer ECC error on FM side */
+    e_IOC_FM_PCD_PLCR_EXCEPTION_PRAM_SELF_INIT_COMPLETE,        /**< Self init complete */
+    e_IOC_FM_PCD_PLCR_EXCEPTION_ATOMIC_ACTION_COMPLETE,         /**< Atomic action complete */
+    e_IOC_FM_PCD_PRS_EXCEPTION_DOUBLE_ECC,                      /**< Parser ECC error */
+    e_IOC_FM_PCD_PRS_EXCEPTION_SINGLE_ECC,                      /**< Parser single ECC */
+    e_IOC_FM_PCD_PRS_EXCEPTION_ILLEGAL_ACCESS,                  /**< Parser illegal access */
+    e_IOC_FM_PCD_PRS_EXCEPTION_PORT_ILLEGAL_ACCESS              /**< Parser port illegal access */
+} ioc_fm_pcd_exceptions;
+
+/**************************************************************************//**
+ @Description   structure for FM counters
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_counters_params_t {
+    ioc_fm_pcd_counters cnt;                /**< The requested counter */
+    uint32_t            val;                /**< The requested value to get/set from/into the counter */
+} ioc_fm_pcd_counters_params_t;
+
+/**************************************************************************//**
+ @Description   structure for FM exception definitios
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_exception_params_t {
+    ioc_fm_pcd_exceptions exception;        /**< The requested exception */
+    bool                  enable;           /**< TRUE to enable interrupt, FALSE to mask it. */
+} ioc_fm_pcd_exception_params_t;
+
+/**************************************************************************//**
+ @Description   A structure for sw parser labels
+ *//***************************************************************************/
+typedef struct ioc_fm_pcd_prs_label_params_t {
+    uint32_t                instruction_offset;             /**< SW parser label instruction offset (2 bytes
+                                                                 resolution), relative to Parser RAM. */
+    ioc_net_header_type     hdr;                            /**< The existance of this header will envoke
+                                                                 the sw parser code. */
+    uint8_t                 index_per_hdr;                  /**< Normally 0, if more than one sw parser
+                                                                 attachments for the same header, use this
+                                                                 index to distinguish between them. */
+} ioc_fm_pcd_prs_label_params_t;
+
+/**************************************************************************//**
+ @Description   A structure for sw parser
+ *//***************************************************************************/
+typedef struct ioc_fm_pcd_prs_sw_params_t {
+    bool                            override;           /**< FALSE to invoke a check that nothing else
+                                                             was loaded to this address, including
+                                                             internal patched.
+                                                             TRUE to override any existing code.*/
+    uint32_t                        size;               /**< SW parser code size */
+    uint16_t                        base;               /**< SW parser base (in instruction counts!
+                                                             muat be larger than 0x20)*/
+    uint8_t                         *p_code;            /**< SW parser code */
+    uint32_t                        sw_prs_data_params[IOC_FM_PCD_PRS_NUM_OF_HDRS];
+                                                        /**< SW parser data (parameters) */
+    uint8_t                         num_of_labels;      /**< Number of labels for SW parser. */
+    ioc_fm_pcd_prs_label_params_t   labels_table[IOC_FM_PCD_PRS_NUM_OF_LABELS];
+                                                        /**< SW parser labels table, containing n
+                                                             umOfLabels entries */
+} ioc_fm_pcd_prs_sw_params_t;
+
+typedef struct ioc_fm_pcd_kg_dflt_value_params_t {
+    uint8_t                         valueId;                /**< 0,1 - one of 2 global default values */
+    uint32_t                        value;                  /**< The requested default value */
+} ioc_fm_pcd_kg_dflt_value_params_t;
+
+
+/**************************************************************************//**
+ @Function      FM_PCD_IOC_ENABLE
+
+ @Description   This routine should be called after PCD is initialized for enabling all
+                PCD engines according to their existing configuration.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following PCD_Init() and when PCD is disabled.
+*//***************************************************************************/
+#define FM_PCD_IOC_ENABLE  _IO(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(1))
+
+/**************************************************************************//**
+ @Function      FM_PCD_IOC_DISABLE
+
+ @Description   This routine may be called when PCD is enabled in order to
+                disable all PCD engines. It may be called
+                only when none of the ports in the system are using the PCD.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following PCD_Init() and when PCD is enabled.
+*//***************************************************************************/
+#define FM_PCD_IOC_DISABLE  _IO(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(2))
+
+ /**************************************************************************//**
+ @Function      FM_PCD_IOC_PRS_LOAD_SW
+
+ @Description   This routine may be called only when all ports in the
+                system are actively using the classification plan scheme.
+                In such cases it is recommended in order to save resources.
+                The driver automatically saves 8 classification plans for
+                ports that do NOT use the classification plan mechanism, to
+                avoid this (in order to save those entries) this routine may
+                be called.
+
+ @Param[in]     ioc_fm_pcd_prs_sw_params_t  A pointer to the image of the software parser code.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following PCD_Init() and when PCD is disabled.
+*//***************************************************************************/
+#define FM_PCD_IOC_PRS_LOAD_SW  _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(3), ioc_fm_pcd_prs_sw_params_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_IOC_KG_SET_EMPTY_CLS_PLAN_GRP
+
+ @Description   This routine may always be called, and MUST be called when
+                not all ports in the partition are actively using the classification
+                plan mechanism.
+                When called, the driver automatically saves 8 classification
+                plans for ports that do NOT use the classification plan mechanism, to
+                avoid this (in order to save those entries) this routine may
+                be ommited when all ports are using the classification
+                plan machanism.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following PCD_Init().
+ *//***************************************************************************/
+#define FM_PCD_IOC_KG_SET_EMPTY_CLS_PLAN_GRP  _IO(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(4))
+
+/**************************************************************************//**
+ @Function      FM_PCD_IOC_KG_DELETE_EMPTY_CLS_PLAN_GRP
+
+ @Description   This routine may be called only when all ports in the
+                system are actively using the classification plan scheme.
+                In such cases, if empty clsPlan was already set,
+                it is recommended in order to save resources.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following PCD_Init().
+                Note that this routine may not be called if any of the FM ports
+                is not using the classification plan mechanism.
+*//***************************************************************************/
+#define FM_PCD_IOC_KG_DELETE_EMPTY_CLS_PLAN_GRP  _IO(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(5))
+
+/**************************************************************************//**
+ @Function      FM_PCD_IOC_KG_SET_DFLT_VALUE
+
+ @Description   Calling this routine sets a global default value to be used
+                by the keygen when parser does not recognize a required
+                field/header.
+                By default default values are 0.
+
+ @Param[in]     ioc_fm_pcd_kg_dflt_value_params_t   TBD
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following PCD_Init() and when PCD is disabled.
+*//***************************************************************************/
+#define FM_PCD_IOC_KG_SET_DFLT_VALUE  _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(6), ioc_fm_pcd_kg_dflt_value_params_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_IOC_KG_SET_ADDITIONAL_DATA_AFTER_PARSING
+
+ @Description   Calling this routine allows the keygen to access data past
+                the parser finidhing point.
+
+ @Param[in]     uint8_t   payload-offset; the number of bytes beyond the parser location.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following PCD_Init() and when PCD is disabled.
+
+*//***************************************************************************/
+#define FM_PCD_IOC_KG_SET_ADDITIONAL_DATA_AFTER_PARSING  _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(7), uint8_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_IOC_SET_EXCEPTION
+
+ @Description   Calling this routine enables/disables PCD interrupts.
+
+ @Param[in]     h_FmPcd         FM PCD module descriptor.
+ @Param[in]     ioc_fm_pcd_exception_params_t     The exception to be selected.
+ @Param[in]     enable          TRUE to enable interrupt, FALSE to mask it.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following PCD_Init().
+*//***************************************************************************/
+#define FM_PCD_IOC_SET_EXCEPTION _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(8), ioc_fm_pcd_exception_params_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_IOC_GET_COUNTER
+
+ @Description   Reads one of the FM PCD counters.
+
+ @Param[in,out] ioc_fm_pcd_counters_params_t The requested counter parameters.
+
+ @Return        Counter's current value.
+
+ @Cautions      Allowed only following FM_PCD_Init().
+                Note that it is user's responsibilty to call this routine only
+                for enabled counters, and there will be no indication if a
+                disabled counter is accessed.
+*//***************************************************************************/
+#define FM_PCD_IOC_GET_COUNTER  _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(9), ioc_fm_pcd_counters_params_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_IOC_SET_COUNTER
+
+ @Description   Sets a value to an enabled counter. Use "0" to reset the counter.
+
+ @Param[in]     ioc_fm_pcd_counters_params_t The requested counter parameters.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following PCD_Init().
+*//***************************************************************************/
+#define FM_PCD_IOC_SET_COUNTER  _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(10), ioc_fm_pcd_counters_params_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_IOC_FORCE_INTR
+
+ @Description   Causes an interrupt event on the requested source.
+
+ @Param[in]     ioc_fm_pcd_exceptions    An exception to be forced.
+
+ @Return        E_OK on success; Error code if the exception is not enabled,
+                or is not able to create interrupt.
+
+ @Cautions      Allowed only following PCD_Init().
+*//***************************************************************************/
+#define FM_PCD_IOC_FORCE_INTR _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(11), ioc_fm_pcd_exceptions)
+
+/**************************************************************************//**
+ @Collection    Definitions of coarse classification
+                parameters as required by keygen (when coarse classification
+                is the next engine after this scheme).
+*//***************************************************************************/
+#define IOC_FM_PCD_MAX_NUM_OF_PCD_CC_NODES     255
+#define IOC_FM_PCD_MAX_NUM_OF_PCD_CC_TREES     8
+#define IOC_FM_PCD_MAX_NUM_OF_PCD_CC_GROUP     16
+#define IOC_FM_PCD_MAX_NUM_OF_CC_UNITS         4
+#define IOC_FM_PCD_MAX_NUM_OF_KEYS             256
+#define IOC_FM_PCD_MAX_SIZE_OF_KEY             56
+/* @} */
+
+/**************************************************************************//**
+ @Collection    A set of definitions to allow protocol
+                special option description.
+*//***************************************************************************/
+typedef uint32_t            ioc_protocol_opt_t;      /**< A general type to define a protocol option. */
+
+typedef ioc_protocol_opt_t  ioc_eth_protocol_opt_t;  /**< Ethernet protocol options. */
+#define IOC_ETH_BROADCAST               0x80000000   /**< Ethernet Broadcast. */
+#define IOC_ETH_MULTICAST               0x40000000   /**< Ethernet Multicast. */
+
+typedef ioc_protocol_opt_t  ioc_vlan_protocol_opt_t; /**< Vlan protocol options. */
+#define IOC_VLAN_STACKED                0x20000000   /**< Vlan Stacked. */
+
+typedef ioc_protocol_opt_t  ioc_mpls_protocol_opt_t; /**< MPLS protocol options. */
+#define IOC_MPLS_STACKED                0x10000000   /**< MPLS Stacked. */
+
+typedef ioc_protocol_opt_t  ioc_ipv4_protocol_opt_t; /**< IPv4 protocol options. */
+#define IOC_IPV4_BROADCAST_1            0x08000000   /**< IPv4 Broadcast. */
+#define IOC_IPV4_MULTICAST_1            0x04000000   /**< IPv4 Multicast. */
+#define IOC_IPV4_UNICAST_2              0x02000000   /**< Tunneled IPv4 - Unicast. */
+#define IOC_IPV4_MULTICAST_BROADCAST_2  0x01000000   /**< Tunneled IPv4 - Broadcast/Multicast. */
+
+typedef ioc_protocol_opt_t  ioc_ipv6_protocol_opt_t; /**< IPv6 protocol options. */
+#define IOC_IPV6_MULTICAST_1            0x00800000   /**< IPv6 Multicast. */
+#define IOC_IPV6_UNICAST_2              0x00400000   /**< Tunneled IPv6 - Unicast. */
+#define IOC_IPV6_MULTICAST_2            0x00200000   /**< Tunneled IPv6 - Multicast. */
+/* @} */
+
+/**************************************************************************//**
+ @Description   All PCD engines
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_engine {
+    e_IOC_FM_PCD_DONE,      /**< No PCD Engine indicated */
+    e_IOC_FM_PCD_KG,        /**< Parser indicated */
+    e_IOC_FM_PCD_CC,        /**< Keygen indicated */
+    e_IOC_FM_PCD_PLCR,      /**< Coarse classification indicated */
+    e_IOC_FM_PCD_PRS        /**< Policer indicated */
+} ioc_fm_pcd_engine;
+
+/**************************************************************************//**
+ @Description   An enum for selecting extraction by header types
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_extract_by_hdr_type {
+    e_IOC_FM_PCD_EXTRACT_FROM_HDR,      /**< Extract bytes from header */
+    e_IOC_FM_PCD_EXTRACT_FROM_FIELD,    /**< Extract bytes from header field */
+    e_IOC_FM_PCD_EXTRACT_FULL_FIELD     /**< Extract a full field */
+} ioc_fm_pcd_extract_by_hdr_type;
+
+/**************************************************************************//**
+ @Description   An enum for selecting extraction source
+                (when it is not the header)
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_extract_from {
+    e_IOC_FM_PCD_EXTRACT_FROM_FRAME_START,          /**< Extract from beginning of frame */
+    e_IOC_FM_PCD_KG_EXTRACT_FROM_DFLT_VALUE,        /**< Extract from a default value */
+    e_IOC_FM_PCD_KG_EXTRACT_FROM_PARSE_RESULT,      /**< Extract from the parser result */
+    e_IOC_FM_PCD_KG_EXTRACT_FROM_CURR_END_OF_PARSE  /**< Extract from the point where parsing had finished */
+} ioc_fm_pcd_extract_from;
+
+/**************************************************************************//**
+ @Description   An enum for selecting extraction type
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_extract_type {
+    e_IOC_FM_PCD_EXTRACT_BY_HDR,                /**< Extract according to header */
+    e_IOC_FM_PCD_EXTRACT_NON_HDR,               /**< Extract from data that is not the header */
+    e_IOC_FM_PCD_KG_EXTRACT_PORT_PRIVATE_INFO   /**< Extract private info as specified by user */
+} ioc_fm_pcd_extract_type;
+
+/**************************************************************************//**
+ @Description   An enum for selecting a default
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_kg_extract_dflt_select {
+    e_IOC_FM_PCD_KG_DFLT_GBL_0,          /**< Default selection is KG register 0 */
+    e_IOC_FM_PCD_KG_DFLT_GBL_1,          /**< Default selection is KG register 1 */
+    e_IOC_FM_PCD_KG_DFLT_PRIVATE_0,      /**< Default selection is a per scheme register 0 */
+    e_IOC_FM_PCD_KG_DFLT_PRIVATE_1,      /**< Default selection is a per scheme register 1 */
+    e_IOC_FM_PCD_KG_DFLT_ILLEGAL         /**< Illegal selection */
+} ioc_fm_pcd_kg_extract_dflt_select;
+
+/**************************************************************************//**
+ @Description   An enum defining all default groups -
+                each group shares a default value, one of 4 user
+                initialized values.
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_kg_known_fields_dflt_types {
+    e_IOC_FM_PCD_KG_MAC_ADDR,               /**< MAC Address */
+    e_IOC_FM_PCD_KG_TCI,                    /**< TCI field */
+    e_IOC_FM_PCD_KG_ENET_TYPE,              /**< ENET Type */
+    e_IOC_FM_PCD_KG_PPP_SESSION_ID,         /**< PPP Session id */
+    e_IOC_FM_PCD_KG_PPP_PROTOCOL_ID,        /**< PPP Protocol id */
+    e_IOC_FM_PCD_KG_MPLS_LABEL,             /**< MPLS label */
+    e_IOC_FM_PCD_KG_IP_ADDR,                /**< IP addr */
+    e_IOC_FM_PCD_KG_PROTOCOL_TYPE,          /**< Protocol type */
+    e_IOC_FM_PCD_KG_IP_TOS_TC,              /**< TOS or TC */
+    e_IOC_FM_PCD_KG_IPV6_FLOW_LABEL,        /**< IPV6 flow label */
+    e_IOC_FM_PCD_KG_IPSEC_SPI,              /**< IPSEC SPI */
+    e_IOC_FM_PCD_KG_L4_PORT,                /**< L4 Port */
+    e_IOC_FM_PCD_KG_TCP_FLAG,               /**< TCP Flag */
+    e_IOC_FM_PCD_KG_GENERIC_FROM_DATA,      /**< grouping implemented by sw,
+                                                 any data extraction that is not the full
+                                                 field described above  */
+    e_IOC_FM_PCD_KG_GENERIC_FROM_DATA_NO_V, /**< grouping implemented by sw,
+                                                 any data extraction without validation */
+    e_IOC_FM_PCD_KG_GENERIC_NOT_FROM_DATA   /**< grouping implemented by sw,
+                                                 extraction from parser result or
+                                                 direct use of default value  */
+} ioc_fm_pcd_kg_known_fields_dflt_types;
+
+/**************************************************************************//**
+ @Description   enum for defining header index when headers may repeat
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_hdr_index {
+    e_IOC_FM_PCD_HDR_INDEX_NONE     =   0,      /**< used when multiple headers not used, also
+                                                     to specify regular IP (not tunneled). */
+    e_IOC_FM_PCD_HDR_INDEX_1,                   /**< may be used for VLAN, MPLS, tunneled IP */
+    e_IOC_FM_PCD_HDR_INDEX_2,                   /**< may be used for MPLS, tunneled IP */
+    e_IOC_FM_PCD_HDR_INDEX_3,                   /**< may be used for MPLS */
+    e_IOC_FM_PCD_HDR_INDEX_LAST     =   0xFF    /**< may be used for VLAN, MPLS */
+} ioc_fm_pcd_hdr_index;
+
+/**************************************************************************//**
+ @Description   A structure for selcting the policer profile functional type
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_profile_type_selection {
+    e_IOC_FM_PCD_PLCR_PORT_PRIVATE,             /**< Port dedicated profile */
+    e_IOC_FM_PCD_PLCR_SHARED                    /**< Shared profile (shared within partition) */
+} ioc_fm_pcd_profile_type_selection;
+
+/**************************************************************************//**
+ @Description   A structure for selcting the policer profile algorithem
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_plcr_algorithm_selection {
+    e_IOC_FM_PCD_PLCR_PASS_THROUGH, /**< Policer pass through */
+    e_IOC_FM_PCD_PLCR_RFC_2698,     /**< Policer algorythm RFC 2698 */
+    e_IOC_FM_PCD_PLCR_RFC_4115      /**< Policer algorythm RFC 4115 */
+} ioc_fm_pcd_plcr_algorithm_selection;
+
+/**************************************************************************//**
+ @Description   A structure for selcting the policer profile color mode
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_plcr_color_mode {
+    e_IOC_FM_PCD_PLCR_COLOR_BLIND,  /**< Color blind */
+    e_IOC_FM_PCD_PLCR_COLOR_AWARE   /**< Color aware */
+} ioc_fm_pcd_plcr_color_mode;
+
+/**************************************************************************//**
+ @Description   A structure for selcting the policer profile color functional mode
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_plcr_color {
+    e_IOC_FM_PCD_PLCR_GREEN,    /**< Green */
+    e_IOC_FM_PCD_PLCR_YELLOW,   /**< Yellow */
+    e_IOC_FM_PCD_PLCR_RED,      /**< Red */
+    e_IOC_FM_PCD_PLCR_OVERRIDE  /**< Color override */
+} ioc_fm_pcd_plcr_color;
+
+/**************************************************************************//**
+ @Description   A structure for selcting the policer profile packet frame length selector
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_plcr_frame_length_select {
+  e_IOC_FM_PCD_PLCR_L2_FRM_LEN,     /**< L2 frame length */
+  e_IOC_FM_PCD_PLCR_L3_FRM_LEN,     /**< L3 frame length */
+  e_IOC_FM_PCD_PLCR_L4_FRM_LEN,     /**< L4 frame length */
+  e_IOC_FM_PCD_PLCR_FULL_FRM_LEN    /**< Full frame length */
+} ioc_fm_pcd_plcr_frame_length_select;
+
+/**************************************************************************//**
+ @Description   An enum for selecting rollback frame
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_plcr_roll_back_frame_select {
+  e_IOC_FM_PCD_PLCR_ROLLBACK_L2_FRM_LEN,    /**< Rollback L2 frame length */
+  e_IOC_FM_PCD_PLCR_ROLLBACK_FULL_FRM_LEN   /**< Rollback Full frame length */
+} ioc_fm_pcd_plcr_roll_back_frame_select;
+
+/**************************************************************************//**
+ @Description   A structure for selcting the policer profile packet or byte mode
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_plcr_rate_mode {
+    e_IOC_FM_PCD_PLCR_BYTE_MODE,    /**< Byte mode */
+    e_IOC_FM_PCD_PLCR_PACKET_MODE   /**< Packet mode */
+} ioc_fm_pcd_plcr_rate_mode;
+
+/**************************************************************************//**
+ @Description   An enum for defining action of frame
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_plcr_done_action {
+    e_IOC_FM_PCD_PLCR_ENQ_FRAME,    /**< Enqueue frame */
+    e_IOC_FM_PCD_PLCR_DROP_FRAME    /**< Drop frame */
+} ioc_fm_pcd_plcr_done_action;
+
+/**************************************************************************//**
+ @Description   A structure for selcting the policer counter
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_plcr_profile_counters {
+    e_IOC_FM_PCD_PLCR_PROFILE_GREEN_PACKET_TOTAL_COUNTER,               /**< Green packets counter */
+    e_IOC_FM_PCD_PLCR_PROFILE_YELLOW_PACKET_TOTAL_COUNTER,              /**< Yellow packets counter */
+    e_IOC_FM_PCD_PLCR_PROFILE_RED_PACKET_TOTAL_COUNTER,                 /**< Red packets counter */
+    e_IOC_FM_PCD_PLCR_PROFILE_RECOLOURED_YELLOW_PACKET_TOTAL_COUNTER,   /**< Recolored yellow packets counter */
+    e_IOC_FM_PCD_PLCR_PROFILE_RECOLOURED_RED_PACKET_TOTAL_COUNTER       /**< Recolored red packets counter */
+} ioc_fm_pcd_plcr_profile_counters;
+
+/**************************************************************************//**
+ @Description   A type used for returning the order of the key extraction.
+                each value in this array represents the index of the extraction
+                command as defined by the user in the initialization extraction array.
+                The valid size of this array is the user define number of extractions
+                required (also marked by the second '0' in this array).
+*//***************************************************************************/
+typedef    uint8_t    ioc_fm_pcd_kg_key_order_t [IOC_FM_PCD_KG_MAX_NUM_OF_EXTRACTS_PER_KEY];
+
+/**************************************************************************//**
+ @Description   A Union of protocol dependent special options
+*//***************************************************************************/
+typedef union ioc_fm_pcd_hdr_protocol_opt_u {
+    ioc_eth_protocol_opt_t    eth_opt;     /**< Ethernet options */
+    ioc_vlan_protocol_opt_t   vlan_opt;    /**< Vlan options */
+    ioc_mpls_protocol_opt_t   mpls_opt;    /**< MPLS options */
+    ioc_ipv4_protocol_opt_t   ipv4_opt;    /**< IPv4 options */
+    ioc_ipv6_protocol_opt_t   ipv6_opt;    /**< IPv6 options */
+} ioc_fm_pcd_hdr_protocol_opt_u;
+
+/**************************************************************************//**
+ @Description   A union holding all known protocol fields
+*//***************************************************************************/
+typedef union ioc_fm_pcd_fields_u {
+    ioc_header_field_eth_t        eth;        /**< eth      */
+    ioc_header_field_vlan_t       vlan;       /**< vlan     */
+    ioc_header_field_llc_snap_t   llc_snap;   /**< llcSnap  */
+    ioc_header_field_pppoe_t      pppoe;      /**< pppoe    */
+    ioc_header_field_mpls_t       mpls;       /**< mpls     */
+    ioc_header_field_ipv4_t       ipv4;       /**< ipv4     */
+    ioc_header_field_ipv6_t       ipv6;       /**< ipv6     */
+    ioc_header_field_udp_t        udp;        /**< udp      */
+    ioc_header_field_tcp_t        tcp;        /**< tcp      */
+    ioc_header_field_sctp_t       sctp;       /**< sctp     */
+    ioc_header_field_dccp_t       dccp;       /**< dccp     */
+    ioc_header_field_gre_t        gre;        /**< gre      */
+    ioc_header_field_minencap_t   minencap;   /**< minencap */
+    ioc_header_field_ipsec_ah_t   ipsec_ah;   /**< ipsecAh  */
+    ioc_header_field_ipsec_esp_t  ipsec_esp;  /**< ipsecEsp */
+} ioc_fm_pcd_fields_u;
+
+/**************************************************************************//**
+ @Description   structure for defining header extraction for key generation
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_from_hdr_t {
+    uint8_t             size;           /**< Size in byte */
+    uint8_t             offset;         /**< Byte offset */
+} ioc_fm_pcd_from_hdr_t;
+
+/**************************************************************************//**
+ @Description   structure for defining field extraction for key generation
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_from_field_t {
+    ioc_fm_pcd_fields_u field;          /**< Field selection */
+    uint8_t             size;           /**< Size in byte */
+    uint8_t             offset;         /**< Byte offset */
+} ioc_fm_pcd_from_field_t;
+
+/**************************************************************************//**
+ @Description   A structure of parameters used to define a single network
+                environment unit.
+                A unit should be defined if it will later be used by one or
+                more PCD engines to distinguich between flows.
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_distinction_unit_t {
+    struct {
+        ioc_net_header_type             hdr;            /**< One of the headers supported by the FM */
+        ioc_fm_pcd_hdr_protocol_opt_u   opt;            /**< only one option !! */
+    } hdrs[IOC_FM_PCD_MAX_NUM_OF_INTERCHANGABLE_HDRS];
+} ioc_fm_pcd_distinction_unit_t;
+
+/**************************************************************************//**
+ @Description   A structure of parameters used to define the different
+                units supported by a specific PCD Network Environment
+                Characteristics module. Each unit represent
+                a protocol or a group of protocols that may be used later
+                by the different PCD engined to distinguich between flows.
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_net_env_params_t {
+    uint8_t                         num_of_distinction_units;   /**< Number of different units to be identified */
+    ioc_fm_pcd_distinction_unit_t   units[IOC_FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS];
+                                                                /**< An array of numOfDistinctionUnits of the
+                                                                     different units to be identified */
+    void                            *id;                        /**< output parameter; Returns the net-env Id to be used */
+} ioc_fm_pcd_net_env_params_t;
+
+/**************************************************************************//**
+ @Description   structure for defining a single extraction action
+                when creating a key
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_extract_entry_t {
+    ioc_fm_pcd_extract_type                 type;           /**< Extraction type select */
+    union {
+        struct {                            /**< used when type = e_IOC_FM_PCD_KG_EXTRACT_BY_HDR */
+            ioc_net_header_type             hdr;            /**< Header selection */
+            bool                            ignore_protocol_validation; /**< Ignore protocol validation */
+            ioc_fm_pcd_hdr_index            hdr_index;       /**< Relevant only for MPLS, VLAN and tunneled
+                                                                  IP. Otherwise should be cleared.*/
+            ioc_fm_pcd_extract_by_hdr_type  type;            /**< Header extraction type select */
+            union {
+                ioc_fm_pcd_from_hdr_t       from_hdr;        /**< Extract bytes from header parameters */
+                ioc_fm_pcd_from_field_t     from_field;      /**< Extract bytes from field parameters*/
+                ioc_fm_pcd_fields_u         full_field;      /**< Extract full filed parameters*/
+            } extract_by_hdr_type;
+        } extract_by_hdr;
+        struct{                       /**< used when type = e_IOC_FM_PCD_KG_EXTRACT_NON_HDR */
+            ioc_fm_pcd_extract_from         src;            /**< Non-header extraction source */
+            uint8_t                         offset;         /**< Byte offset */
+            uint8_t                         size;           /**< Size in byte */
+        } extract_non_hdr;
+    } extract_params;
+} ioc_fm_pcd_extract_entry_t;
+
+/**************************************************************************//**
+ @Description   A structure for defining masks for each extracted
+                field in the key.
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_kg_extract_mask_t {
+    uint8_t                extract_array_index;         /**< Index in the extraction array, as initialized by user */
+    uint8_t                offset;                      /**< Byte offset */
+    uint8_t                mask;                        /**< A byte mask (selected bits will be ignored) */
+} ioc_fm_pcd_kg_extract_mask_t;
+
+/**************************************************************************//**
+ @Description   A structure for defining default selection per groups
+                of fields
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_kg_extract_dflt_t {
+    ioc_fm_pcd_kg_known_fields_dflt_types    type;          /**< Default type select*/
+    ioc_fm_pcd_kg_extract_dflt_select        dflt_select;   /**< Default register select */
+} ioc_fm_pcd_kg_extract_dflt_t;
+
+/**************************************************************************//**
+ @Description   A structure for defining all parameters needed for
+                generation a key and using a hash function
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_kg_key_extract_and_hash_params_t {
+    uint32_t                            private_dflt0;               /**< Scheme default register 0 */
+    uint32_t                            private_dflt1;               /**< Scheme default register 1 */
+    uint8_t                             num_of_used_extracts;           /**< defines the valid size of the following array */
+    ioc_fm_pcd_extract_entry_t          extract_array [IOC_FM_PCD_KG_MAX_NUM_OF_EXTRACTS_PER_KEY];
+    uint8_t                             num_of_used_dflt;           /**< defines the valid size of the following array */
+    ioc_fm_pcd_kg_extract_dflt_t        dflts[IOC_FM_PCD_KG_NUM_OF_DEFAULT_GROUPS];
+    uint8_t                             num_of_used_masks;              /**< defines the valid size of the following array */
+    ioc_fm_pcd_kg_extract_mask_t        masks[IOC_FM_PCD_KG_NUM_OF_EXTRACT_MASKS];
+    uint8_t                             hash_shift;                     /**< Select the 24 bits out of the 64 hash result */
+    uint32_t                            hash_distribution_num_of_fqids; /**< must be > 1 and a power of 2. Represents the range
+                                                                             of queues for the key and hash functionality */
+    uint8_t                             hash_distribution_fqids_shift;  /**< selects the FQID bits that will be effected by the hash */
+} ioc_fm_pcd_kg_key_extract_and_hash_params_t;
+
+/**************************************************************************//**
+ @Description   A structure of parameters for defining a single
+                Qid mask (extracted OR).
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_kg_extracted_or_for_fqid_t {
+    ioc_fm_pcd_extract_type                 type;               /**< Extraction type select */
+    union{
+        struct{                                                 /**< used when type = e_IOC_FM_PCD_KG_EXTRACT_BY_HDR */
+            ioc_net_header_type             hdr;
+            ioc_fm_pcd_hdr_index            hdr_index;          /**< Relevant only for MPLS, VLAN and tunneled
+                                                                     IP. Otherwise should be cleared.*/
+            bool                            ignore_protocol_validation;
+        } extract_by_hdr;
+        ioc_fm_pcd_extract_from             src;                /**< used when type = e_IOC_FM_PCD_KG_EXTRACT_NON_HDR */
+    } extract_params;
+    uint8_t                                 extraction_offset;  /**< Offset for extraction */
+    ioc_fm_pcd_kg_extract_dflt_select       dflt_value;         /**< Select register from which extraction is taken if
+                                                                     field not found */
+    uint8_t                                 mask;               /**< Mask LSB byte of extraction (specified bits are ignored) */
+    uint8_t                                 bit_offset_in_fqid; /**< out of 24 bits Qid  (max offset = 16) */
+} ioc_fm_pcd_kg_extracted_or_for_fqid_t;
+
+/**************************************************************************//**
+ @Description   A structure for configuring scheme counter
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_kg_scheme_counter_t {
+    bool        update;     /**< FALSE to keep the current counter state
+                                 and continue from that point, TRUE to update/reset
+                                 the counter when the scheme is written. */
+    uint32_t    value;      /**< If update=TRUE, this value will be written into the
+                                 counter. clear this field to reset the counter. */
+} ioc_fm_pcd_kg_scheme_counter_t;
+
+/**************************************************************************//**
+ @Description   A structure for defining policer profile
+                parameters as required by keygen (when policer
+                is the next engine after this scheme).
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_kg_plcr_profile_t {
+    bool                shared_profile;                 /**< TRUE if this profile is shared between ports
+                                                             (i.e. managed by master partition) May not be TRUE
+                                                             if profile is after Coarse Classification*/
+    bool                direct;                         /**< if TRUE, directRelativeProfileId only selects the profile
+                                                             id, if FALSE fqidOffsetRelativeProfileIdBase is used
+                                                             together with fqidOffsetShift and numOfProfiles
+                                                             parameters, to define a range of profiles from
+                                                             which the keygen result will determine the
+                                                             destination policer profile.  */
+    union{
+        uint16_t        direct_relative_profile_id;     /**< Used if 'direct' is TRUE, to select policer profile.
+                                                             This parameter should
+                                                             indicate the policer profile offset within the port's
+                                                             policer profiles or SHARED window. */
+        struct {
+            uint8_t     fqid_offset_shift;              /**< shift of KG results without the qid base */
+            uint8_t     fqid_offset_relative_profile_id_base;/**< OR of KG results without the qid base
+                                                             This parameter should
+                                                             indicate the policer profile offset within the port's
+                                                             policer profiles windowor SHARED window depends on sharedProfile */
+            uint8_t     num_of_profiles;                /**< Range of profiles starting at base */
+        } indirect_profile_id;
+    } profile_select;
+} ioc_fm_pcd_kg_plcr_profile_t;
+
+/**************************************************************************//**
+ @Description   A structure for CC parameters if CC is the next engine after KG
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_kg_cc_t {
+    void                            *tree_id;           /**< CC Tree id */
+    uint8_t                         grp_id;             /**< CC group id within the CC tree */
+    bool                            plcr_next;          /**< TRUE if after CC, in case of data frame,
+                                                             policing is required. */
+    ioc_fm_pcd_kg_plcr_profile_t    plcr_profile;       /**< only if plcrNext=TRUE */
+} ioc_fm_pcd_kg_cc_t;
+
+/**************************************************************************//**
+ @Description   A structure for initializing a keygen single scheme
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_kg_scheme_params_t {
+    bool                                modify;         /**< enables changing an existing scheme */
+    union
+    {
+        uint8_t                         relative_scheme_id;/**< IN: if modify=FALSE:Partition relative scheme id */
+        void                            *scheme_id;      /**< IN: if modify=TRUE: a handle of the existing scheme */
+    } scm_id;
+    bool                                always_direct;  /**< This scheme is reached only directly, i.e.                                                              no need for match vector. Keygen will ignore
+                                                             it when matching   */
+    struct                                              /**< HL Relevant only if alwaysDirect = FALSE */
+    {
+        void                            *net_env_id;     /**< Network environment id  */
+        uint8_t                         num_of_distinction_units; /**< Number of netenv units listed in unit_ids array */
+        uint8_t                         unit_ids[IOC_FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS];
+                                                        /**< Indexes as passed to SetNetEnvCharacteristics array*/
+    } netEnvParams;
+    bool                                use_hash;       /**< use the KG Hash functionality */
+    ioc_fm_pcd_kg_key_extract_and_hash_params_t     key_extract_and_hash_params;
+                                                        /**< used only if useHash = TRUE */
+    uint32_t                            base_fqid;      /**< Base FQID */
+    uint8_t                             num_of_used_fqid_masks;  /**< Number of Fqid masks listed in fqid_masks array */
+    ioc_fm_pcd_kg_extracted_or_for_fqid_t           fqid_masks[IOC_FM_PCD_KG_NUM_OF_GENERIC_REGS];
+                                                        /**< IOC_FM_PCD_KG_NUM_OF_GENERIC_REGS
+                                                             registers are shared between qidMasks
+                                                             functionality and some of the extraction
+                                                             actions. Normally only some will be used
+                                                             for qidMask. Driver will return error if
+                                                             resource is full at initialization time. */
+    ioc_fm_pcd_engine                   next_engine;    /**< may be BMI, PLCR or CC */
+    union{                                              /**< depends on nextEngine */
+        ioc_fm_pcd_kg_plcr_profile_t    plcr_profile;   /**< Used when next engine is PLCR */
+        ioc_fm_pcd_kg_cc_t              cc;             /**< Used when next engine is CC */
+    } kg_next_engine_params;
+    ioc_fm_pcd_kg_scheme_counter_t      scheme_counter; /**< A strcucture of parameters for updating
+                                                             the scheme counter */
+    ioc_fm_pcd_kg_key_order_t           ordered_array;  /**< OUT: A structure holding the order of the key extraction.
+                                                             Relevant only is 'useHash' is TRUE. each value in this
+                                                             array represents the index of the
+                                                             extraction command as defined by the application in
+                                                             the initialization extraction array.
+                                                             The valid size of this array is the application define number of extractions
+                                                             required (also marked by the second '0' in this array).*/
+    void                                *id;            /**< OUT: Returns the scheme Id to be used */
+} ioc_fm_pcd_kg_scheme_params_t;
+
+/**************************************************************************//**
+ @Description   A structure for defining CC params when CC is the
+                next engine after a CC node
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_cc_next_cc_params_t {
+    void        *cc_node_id;                   /**< Id of the next CC node */
+} ioc_fm_pcd_cc_next_cc_params_t;
+
+/**************************************************************************//**
+ @Description   A structure for defining PLCR params when PLCR is the
+                next engine after a CC node
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_cc_next_plcr_params_t {
+    bool        ctrl_flow;                      /**< TRUE if this is a control flow, FALSE
+                                                     if this is data flow */
+    bool        shared_profile;                 /**< Relevant only if ctrlFlow=TRUE:
+                                                     TRUE if this profile is shared between ports */
+    uint16_t    plcr_profile_num_for_ctrl_flow; /**< Valid if ctrlFlow=TRUE,Proile id for control flow
+                                                     (for data flow porfile id
+                                                     is taken from keygen) */
+    bool        fqid_enq_ctrl_flow;             /**< TRUE if after the policer the frame should
+                                                     be enqueued rather than return to Keygen */
+    uint32_t    fqid_for_ctrl_flow_for_bmi_after_plcr; /**< Valid if fqidEnqForCtrlFlow= TRUE, FQID for enquing
+                                                         the frame */
+} ioc_fm_pcd_cc_next_plcr_params_t;
+
+/**************************************************************************//**
+ @Description   A structure for defining enqueue params when BMI is the
+                next engine after a CC node
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_cc_next_enqueue_params_t {
+    bool        ctrl_flow;              /**< TRUE if this is a control flow, FALSE
+                                             if this is data flow */
+    uint32_t    fqid_for_cntrl_flow;    /**< Valid if ctrlFlow=TRUE, FQID for enquing the frame
+                                             (for data flow FQID is taken from keygen) */
+} ioc_fm_pcd_cc_next_enqueue_params_t;
+
+/**************************************************************************//**
+ @Description   A structure for defining KG params when KG is the
+                next engine after a CC node
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_cc_next_kg_params_t {
+    bool        ctrl_flow;              /**< TRUE if this is a control flow, FALSE
+                                             if this is data flow */
+    void        *direct_scheme_id;      /**< Direct scheme id to go to */
+} ioc_fm_pcd_cc_next_kg_params_t;
+
+/**************************************************************************//**
+ @Description   A structure for defining next engine params after a CC node.
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_cc_next_engine_params_t {
+    ioc_fm_pcd_engine                           next_engine;    /**< user has to init parameters according
+                                                                     to nextEngine definition */
+    union {
+            ioc_fm_pcd_cc_next_cc_params_t      cc_params;      /**< Parameters in case next engine is CC */
+            ioc_fm_pcd_cc_next_plcr_params_t    plcr_params;    /**< Parameters in case next engine is PLCR */
+            ioc_fm_pcd_cc_next_enqueue_params_t enqueue_params; /**< Parameters in case next engine is BMI */
+            ioc_fm_pcd_cc_next_kg_params_t      kg_params;      /**< Parameters in case next engine is KG */
+    } params;
+} ioc_fm_pcd_cc_next_engine_params_t;
+
+/**************************************************************************//**
+ @Description   A structure for defining a single CC Key parameters
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_cc_key_params_t {
+    uint8_t                 *p_key; /**< pointer to the key of the size defined in keySize */
+    uint8_t                 *p_mask;/**< pointer to the Mask per key  of the size defined
+                                         in keySize. p_Key and p_Mask (if defined) has to be
+                                         of the same size defined in the keySize */
+
+    ioc_fm_pcd_cc_next_engine_params_t  cc_next_engine_params;
+                                    /**< parameters for the next for the defined Key in the p_Key */
+} ioc_fm_pcd_cc_key_params_t;
+
+/**************************************************************************//**
+ @Description   A structure for defining CC Keys parameters
+*//***************************************************************************/
+typedef struct ioc_keys_params_t {
+    uint8_t                             num_of_keys;    /**< num Of relevant Keys  */
+    uint8_t                             key_size;       /**< size of the key - in the case of the extraction of
+                                                             the type FULL_FIELD keySize has to be as standard size of the relevant
+                                                             key. In the another type of extraction keySize has to be as size of extraction. */
+
+    uint8_t                             *p_glbl_mask;   /**< optional and can be initialized if :
+                                                             keySize <=4 or  maskForKey is not initialized*/
+    ioc_fm_pcd_cc_key_params_t          key_params[IOC_FM_PCD_MAX_NUM_OF_KEYS];
+                                                        /**< it's array with numOfKeys entries each entry in
+                                                             the array of the type ioc_fm_pcd_cc_key_params_t */
+    ioc_fm_pcd_cc_next_engine_params_t  cc_next_engine_params_for_miss;
+                                                        /**< parameters for the next step of
+                                                             unfound (or undefined) key */
+} ioc_keys_params_t;
+
+/**************************************************************************//**
+ @Description   A structure for defining the CC node params
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_cc_node_params_t {
+    ioc_fm_pcd_extract_entry_t          extract_cc_params;  /**< params which defines extraction parameters */
+    ioc_keys_params_t                   keys_params;        /**< params which defines Keys parameters of the
+                                                                 extraction defined in  extractParams */
+    void                                *id;                /**< output parameter; Returns the CC node Id to be used */
+} ioc_fm_pcd_cc_node_params_t;
+
+/**************************************************************************//**
+ @Description   A structure for defining each CC tree group in term of
+                NetEnv units and the action to be taken in each case.
+                the unit_ids list must be in order from lower to higher indexes.
+
+                ioc_fm_pcd_cc_next_engine_params_t is a list of 2^num_of_distinction_units
+                structures where each defines the next action to be taken for
+                each units combination. for example:
+                num_of_distinction_units = 2
+                unit_ids = {1,3}
+                next_engine_per_entries_in_grp[0] = ioc_fm_pcd_cc_next_engine_params_t for the case that
+                                                    unit 1 - not found; unit 3 - not found;
+                next_engine_per_entries_in_grp[1] = ioc_fm_pcd_cc_next_engine_params_t for the case that
+                                                    unit 1 - not found; unit 3 - found;
+                next_engine_per_entries_in_grp[2] = ioc_fm_pcd_cc_next_engine_params_t for the case that
+                                                    unit 1 - found; unit 3 - not found;
+                next_engine_per_entries_in_grp[3] = ioc_fm_pcd_cc_next_engine_params_t for the case that
+                                                    unit 1 - found; unit 3 - found;
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_cc_grp_params_t {
+    uint8_t                             num_of_distinction_units;   /**< up to 4 */
+    uint8_t                             unit_ids [IOC_FM_PCD_MAX_NUM_OF_CC_UNITS];
+                                                                    /**< Indexes of the units as defined in
+                                                                         FM_PCD_SetNetEnvCharacteristics */
+    ioc_fm_pcd_cc_next_engine_params_t  *p_next_engine_per_entries_in_grp;
+                                                                    /**< Max size is 16 - if only one group used  */
+} ioc_fm_pcd_cc_grp_params_t;
+
+/**************************************************************************//**
+ @Description   A structure for defining the CC tree groups
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_cc_tree_params_t {
+        void                            *net_env_id;    /**< Id of the Network environment as returned
+                                                             by FM_PCD_SetNetEnvCharacteristics */
+        uint8_t                         num_of_groups;  /**< Number of CC groups within the CC tree */
+        ioc_fm_pcd_cc_grp_params_t      fm_pcd_cc_group_params [IOC_FM_PCD_MAX_NUM_OF_PCD_CC_GROUP];
+                                                        /**< Max 8 groups (of 2) for the 16 nodes root */
+        void                            *id;            /**< output parameter; Returns the tree Id to be used */
+} ioc_fm_pcd_cc_tree_params_t;
+
+/**************************************************************************//**
+ @Description   A structure for initializing a keygen classification plan group
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_kg_cls_plan_grp_params_t {
+    void                *net_env_id;    /**< Id of the Network environment as returned
+                                             by FM_PCD_SetNetEnvCharacteristics */
+    uint8_t             num_of_pptions; /**< Number of options, to define the size of the
+                                             following array. */
+    ioc_protocol_opt_t  options[IOC_FM_PCD_MAX_NUM_OF_CLS_PLANS];
+                                        /**< an option may be ipv6Multicast1,
+                                             (ethBroadcast | ethMulticast) or
+                                             (ethBroadcast | ipv4Unicast2 | mplsStacked) */
+    void                *id;            /**< output parameter; Returns the classification-group Id to be used */
+} ioc_fm_pcd_kg_cls_plan_grp_params_t;
+
+/**************************************************************************//**
+ @Description   A structure for defining parameters for byte rate
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_plcr_byte_rate_mode_param_t {
+    ioc_fm_pcd_plcr_frame_length_select     frame_length_selection;     /**< Frame length selection */
+    ioc_fm_pcd_plcr_roll_back_frame_select  roll_back_frame_selection;  /**< relevant option only e_IOC_FM_PCD_PLCR_L2_FRM_LEN,
+                                                                             e_IOC_FM_PCD_PLCR_FULL_FRM_LEN */
+} ioc_fm_pcd_plcr_byte_rate_mode_param_t;
+
+/**************************************************************************//**
+ @Description   A structure for selcting the policer profile RFC 2698 or RFC 4115 parameters
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_plcr_non_passthrough_alg_param_t {
+    ioc_fm_pcd_plcr_rate_mode               rate_mode;                      /**< Byte / Packet */
+    ioc_fm_pcd_plcr_byte_rate_mode_param_t  byte_mode_param;                /**< Valid for Byte NULL for Packet */
+    uint32_t                                comitted_info_rate;             /**< KBits/Sec or Packets/Sec */
+    uint32_t                                comitted_burst_size;            /**< KBits or Packets */
+    uint32_t                                peak_or_accessive_info_rate;    /**< KBits/Sec or Packets/Sec */
+    uint32_t                                peak_or_accessive_burst_size;   /**< KBits or Packets */
+} ioc_fm_pcd_plcr_non_passthrough_alg_param_t;
+
+/**************************************************************************//**
+ @Description   A union for defining Policer next engine parameters
+*//***************************************************************************/
+typedef union ioc_fm_pcd_plcr_next_engine_params_u {
+        ioc_fm_pcd_plcr_done_action     action;             /**< Action - when next engine is BMI (done) */
+        void                            *plcr_profile_id;   /**< Policer profile id -  when next engine is PLCR*/
+        void                            *direct_scheme_id;  /**< Direct scheme id - when next engine is Keygen */
+} ioc_fm_pcd_plcr_next_engine_params_u;
+
+typedef struct fm_pcd_port_params_t {
+    ioc_fm_port_type                    port_type;          /**< Type of port for this profile */
+    uint8_t                             port_id;            /**< FM-Port id of port for this profile */
+} fm_pcd_port_params_t;
+
+/**************************************************************************//**
+ @Description   A structure for selcting the policer profile entry parameters
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_plcr_profile_params_t {
+    bool                                        modify;                     /**< TRUE to change an existing profile */
+    union {
+        struct {
+            ioc_fm_pcd_profile_type_selection   profile_type;               /**< Type of policer profile */
+            fm_pcd_port_params_t                *p_port;                    /**< FM-Port id of port for this profile */
+            uint16_t                            relative_profile_id;        /**< Profile id - relative to shared group or to port */
+        } new_params;
+        void                                    *profile_id;                /**< policer-profile id */
+    } profile_select;
+    ioc_fm_pcd_plcr_algorithm_selection         alg_selection;              /**< Profile Algoritem PASS_THROUGH, RFC_2698, RFC_4115 */
+    ioc_fm_pcd_plcr_color_mode                  color_mode;                 /**< COLOR_BLIND, COLOR_AWARE */
+
+    union {
+        ioc_fm_pcd_plcr_color                   dflt_color;                 /**< For Color-Blind Pass-Through mode. the policer will re-color
+                                                                                 any incoming packet with the deflt value. */
+        ioc_fm_pcd_plcr_color                   override;                   /**< For Color-Aware modes. The profile response to a
+                                                                                 pre-color value of 2b11. */
+    } color;
+
+    ioc_fm_pcd_plcr_non_passthrough_alg_param_t non_passthrough_alg_param;  /**< RFC2698 or RFC4115 params */
+
+    ioc_fm_pcd_engine                           next_engine_on_green;       /**< Green next engine type */
+    ioc_fm_pcd_plcr_next_engine_params_u        params_on_green;            /**< Green next engine params */
+
+    ioc_fm_pcd_engine                           next_engine_on_yellow;      /**< Yellow next engine type */
+    ioc_fm_pcd_plcr_next_engine_params_u        params_on_yellow;           /**< Yellow next engine params */
+
+    ioc_fm_pcd_engine                           next_engine_on_red;         /**< Red next engine type */
+    ioc_fm_pcd_plcr_next_engine_params_u        params_on_red;              /**< Red next engine params */
+
+    bool                                        trap_profile_on_flow_A;     /**< Trap on flow A */
+    bool                                        trap_profile_on_flow_B;     /**< Trap on flow B */
+    bool                                        trap_profile_on_flow_C;     /**< Trap on flow C */
+    void                                        *id;                        /**< output parameter; Returns the profile Id to be used */
+} ioc_fm_pcd_plcr_profile_params_t;
+
+/**************************************************************************//**
+ @Description   TBD
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_cc_tree_modify_next_engine_params_t {
+    void                                *id;                /**< CC tree Id to be used */
+    uint8_t                             grp_indx;           /**< A Group index in the tree */
+    uint8_t                             indx;               /**< Entry index in the group defined by grpId */
+    ioc_fm_pcd_cc_next_engine_params_t  cc_next_engine_params;
+                                                            /**< parameters for the next for the defined Key in the p_Key */
+} ioc_fm_pcd_cc_tree_modify_next_engine_params_t;
+
+/**************************************************************************//**
+ @Description   TBD
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_cc_node_modify_next_engine_params_t {
+    void                                *id;                /**< CC node Id to be used */
+    uint8_t                             key_indx;           /**< Key index for Next Engine Params modifications;
+                                                                 NOTE: This parameter is IGNORED for miss-key!  */
+    uint8_t                             key_size;           /**< Key size of added key */
+    ioc_fm_pcd_cc_next_engine_params_t  cc_next_engine_params;
+                                                            /**< parameters for the next for the defined Key in the p_Key */
+} ioc_fm_pcd_cc_node_modify_next_engine_params_t;
+
+/**************************************************************************//**
+ @Description   TBD
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_cc_node_modify_key_and_next_engine_params_t {
+    void                                *id;                /**< CC node Id to be used */
+    uint8_t                             key_indx;           /**< Key index for Next Engine Params modifications;
+                                                                 NOTE: This parameter is IGNORED for miss-key!  */
+    uint8_t                             key_size;           /**< Key size of added key */
+    ioc_fm_pcd_cc_key_params_t          key_params;         /**< it's array with numOfKeys entries each entry in
+                                                                 the array of the type ioc_fm_pcd_cc_key_params_t */
+} ioc_fm_pcd_cc_node_modify_key_and_next_engine_params_t;
+
+/**************************************************************************//**
+ @Description   TBD
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_cc_node_remove_key_params_t {
+    void                                *id;                /**< CC node Id to be used */
+    uint8_t                             key_indx;           /**< Key index for Next Engine Params modifications;
+                                                                 NOTE: This parameter is IGNORED for miss-key!  */
+} ioc_fm_pcd_cc_node_remove_key_params_t;
+
+/**************************************************************************//**
+ @Description   TBD
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_cc_node_modify_key_params_t {
+    void                                *id;                /**< CC node Id to be used */
+    uint8_t                             key_indx;           /**< Key index for Next Engine Params modifications;
+                                                                 NOTE: This parameter is IGNORED for miss-key!  */
+    uint8_t                             key_size;           /**< Key size of added key */
+    uint8_t                             *p_key;             /**< pointer to the key of the size defined in keySize */
+    uint8_t                             *p_mask;            /**< pointer to the Mask per key  of the size defined
+                                                                 in keySize. p_Key and p_Mask (if defined) has to be
+                                                                 of the same size defined in the keySize */
+} ioc_fm_pcd_cc_node_modify_key_params_t;
+
+
+/**************************************************************************//**
+ @Function      FM_PCD_IOC_SET_NET_ENV_CHARACTERISTICS
+
+ @Description   Define a set of Network Environment Charecteristics.
+                When setting an environment it is important to understand its
+                application. It is not meant to describe the flows that will run
+                on the ports using this environment, but what the user means TO DO
+                with the PCD mechanisms in order to parse-classify-distribute those
+                frames.
+                By specifying a distinction unit, the user means it would use that option
+                for distinction between frames at either a keygen scheme keygen or a coarse
+                classification action descriptor. Using interchangeable headers to define a
+                unit means that the user is indifferent to which of the interchangeable
+                headers is present in the frame, and they want the distinction to be based
+                on the presence of either one of them.
+                Depending on context, there are limitations to the use of environments. A
+                port using the PCD functionality is bound to an environment. Some or even
+                all ports may share an environment but also an environment per port is
+                possible. When initializing a scheme, a classification plan group (see below),
+                or a coarse classification tree, one of the initialized environments must be
+                stated and related to. When a port is bound to a scheme, a classification
+                plan group, or a coarse classification tree, it MUST be bound to the same
+                environment.
+                The different PCD modules, may relate (for flows definition) ONLY on
+                distinction units as defined by their environment. When initializing a
+                scheme for example, it may not choose to select IPV4 as a match for
+                recognizing flows unless it was defined in the relating environment. In
+                fact, to guide the user through the configuration of the PCD, each module's
+                characterization in terms of flows is not done using protocol names, but using
+                environment indexes.
+                In terms of HW implementation, the list of distinction units sets the LCV vectors
+                and later used for match vector, classification plan vectors and coarse classification
+                indexing.
+
+ @Param[in,out] ioc_fm_pcd_net_env_params_t   An structure defining the distiction units for this configuration.
+
+ @Return        0 on success; Error code otherwise.
+
+ @Cautions      Allowed only following PCD_Init().
+*//***************************************************************************/
+#define FM_PCD_IOC_SET_NET_ENV_CHARACTERISTICS  _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(20), ioc_fm_pcd_net_env_params_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_IOC_DELETE_NET_ENV_CHARACTERISTICS
+
+ @Description   Deletes a set of Network Environment Charecteristics.
+
+ @Param[in]     ioc_fm_obj_t        An id of a Network environment object.
+
+ @Return        E_OK on success; Error code otherwise.
+*//***************************************************************************/
+#define FM_PCD_IOC_DELETE_NET_ENV_CHARACTERISTICS  _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(21), ioc_fm_obj_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_IOC_KG_SET_CLS_PLAN_GRP
+
+ @Description   Define a classification plan group..
+                A classification plan group is a set of classification plan
+                entries consisting of a number of protocol options (as listed
+                in HW spec), that is a subset of a previously defined environment,
+                and that is relevant for one or more ports that will use that
+                same environment.
+                By specifying an option, the application means it would use that
+                option for distinction between frames at either a keygen scheme
+                keygen or a coarse classification action descriptor.
+                When RX ports that want to use the classification plan mechanism
+                are initialized, they will be bound to a classification plan
+                group. Usage of the classification plan is optional.
+                If not all ports use classification plan, it is user's responsibility
+                to declare that by calling FM_PCD_KgSetEmptyClsPlanGrp. The driver
+                will then allocate a minimal number of entries for that use, and all
+                ports that do not use the classification plan mechanism will
+                be internally bound to that empty group.
+
+ @Param[in,out] ioc_fm_pcd_kg_cls_plan_grp_params_t  A structure of classification plan parameters.
+
+ @Return        0 on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_Init().
+*//***************************************************************************/
+#define FM_PCD_IOC_KG_SET_CLS_PLAN_GRP  _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(22), ioc_fm_pcd_kg_cls_plan_grp_params_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_IOC_KG_DEL_CLS_PLAN
+
+ @Description   Delete classification plan by writing reset value (0xFFFFFFFF)
+                to it - pass all LCV bits.
+
+ @Param[in]     ioc_fm_obj_t         index of plan entry to be deleted.
+
+ @Return        0 on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_Init().
+*//***************************************************************************/
+#define FM_PCD_IOC_KG_DEL_CLS_PLAN  _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(23), ioc_fm_obj_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_IOC_KG_SET_SCHEME
+
+ @Description   Initializing or modifying and enabling a scheme for the keygen.
+                This routine should be called for adding or modifying a scheme.
+                When a scheme needs modifying, the API requires that it will be
+                rewritten. In such a case 'override' should be TRUE. If  the
+                routine is called for a valid scheme and 'override' is FALSE,
+                it will return error.
+
+ @Param[in]     ioc_fm_pcd_kg_scheme_params_t   A structure of parameters for defining the scheme
+
+ @Return        0 on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_Init().
+*//***************************************************************************/
+#define FM_PCD_IOC_KG_SET_SCHEME    _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(24), ioc_fm_pcd_kg_scheme_params_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_IOC_KG_DEL_SCHEME
+
+ @Description   Deleting an initialized scheme.
+
+ @Param[in]     ioc_fm_obj_t        scheme id as initalized by application at FM_PCD_IOC_KG_SET_SCHEME
+
+ @Return        0 on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_Init().
+*//***************************************************************************/
+#define FM_PCD_IOC_KG_DEL_SCHEME    _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(25), ioc_fm_obj_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_IOC_CC_BUILD_TREE
+
+ @Description   This routine must be called to define a complete coarse
+                classification tree. This is the way to define coarse
+                classification to a certain flow - the keygen schemes
+                may point only to trees defined in this way.
+
+ @Param[in,out] ioc_fm_pcd_cc_tree_params_t     A structure of parameters to define the tree.
+
+ @Return        0 on success; Error code if the exception is not enabled,
+                or is not able to create interrupt.
+
+ @Cautions      Allowed only following PCD_Init().
+*//***************************************************************************/
+#define FM_PCD_IOC_CC_BUILD_TREE    _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(26), ioc_fm_pcd_cc_tree_params_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_IOC_CC_DELETE_TREE
+
+ @Description   Deleting an built tree.
+
+ @Param[in]     ioc_fm_obj_t    An id of a CC-tree.
+
+ @Cautions      Allowed only following FM_PCD_Init().
+*//***************************************************************************/
+#define FM_PCD_IOC_CC_DELETE_TREE    _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(27), ioc_fm_obj_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_IOC_CC_SET_NODE
+
+ @Description   This routine should be called for each CC (coarse classification)
+                node. The whole CC tree should be built bottom up so that each
+                node points to already defined nodes. p_NodeId returns the node
+                Id to be used by other nodes.
+
+ @Param[in,out] ioc_fm_pcd_cc_node_params_t       A structure for defining the CC node params
+
+ @Return        0 on success; Error code if the exception is not enabled,
+                or is not able to create interrupt.
+
+ @Cautions      Allowed only following PCD_Init().
+*//***************************************************************************/
+#define FM_PCD_IOC_CC_SET_NODE    _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(28), ioc_fm_pcd_cc_node_params_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_CcDeleteNode
+
+ @Description   Deleting an built node.
+
+ @Param[in]     ioc_fm_obj_t    An id of a CC-node.
+
+ @Cautions      Allowed only following FM_PCD_Init().
+*//***************************************************************************/
+#define FM_PCD_IOC_CC_DELETE_NODE    _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(29), ioc_fm_obj_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_IOC_CC_TREE_MODIFY_NEXT_ENGINE
+
+ @Description   Modify the Next Engine Parameters in the entry of the tree.
+
+ @Param[in]     ioc_fm_pcd_cc_tree_modify_next_engine_params_t  TBD
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_CcBuildTree().
+*//***************************************************************************/
+#define FM_PCD_IOC_CC_TREE_MODIFY_NEXT_ENGINE   _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(30), ioc_fm_pcd_cc_tree_modify_next_engine_params_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_IOC_CC_NODE_MODIFY_NEXT_ENGINE
+
+ @Description   Modify the Next Engine Parameters in the relevent key entry of the node.
+
+ @Param[in]     ioc_fm_pcd_cc_node_modify_next_engine_params_t  TBD
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_CcSetNode().
+*//***************************************************************************/
+#define FM_PCD_IOC_CC_NODE_MODIFY_NEXT_ENGINE   _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(31), ioc_fm_pcd_cc_node_modify_next_engine_params_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_IOC_CC_NODE_MODIFY_MISS_NEXT_ENGINE
+
+ @Description   Modify the Next Engine Parameters of the Miss key case of the node.
+
+ @Param[in]     ioc_fm_pcd_cc_node_modify_next_engine_params_t  TBD
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_CcSetNode().
+*//***************************************************************************/
+#define FM_PCD_IOC_CC_NODE_MODIFY_MISS_NEXT_ENGINE   _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(32), ioc_fm_pcd_cc_node_modify_next_engine_params_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_IOC_CC_NODE_REMOVE_KEY
+
+ @Description   Remove the key (include Next Engine Parameters of this key) defined by the index of the relevant node .
+
+ @Param[in]     ioc_fm_pcd_cc_node_remove_key_params_t  TBD
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_CcSetNode() not only of the relevnt node but also
+                the node that points to this node
+*//***************************************************************************/
+#define FM_PCD_IOC_CC_NODE_REMOVE_KEY   _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(33), ioc_fm_pcd_cc_node_remove_key_params_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_IOC_CC_NODE_ADD_KEY
+
+ @Description   Add the key(include Next Engine Parameters of this key)in the index defined by the keyIndex .
+
+ @Param[in]     ioc_fm_pcd_cc_node_modify_key_and_next_engine_params_t  TBD
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_CcSetNode() not only of the relevnt node but also
+                the node that points to this node
+*//***************************************************************************/
+#define FM_PCD_IOC_CC_NODE_ADD_KEY   _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(34), ioc_fm_pcd_cc_node_modify_key_and_next_engine_params_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_IOC_CC_NODE_MODIFY_KEY_AND_NEXT_ENGINE
+
+ @Description   Modify the key and Next Engine Parameters of this key in the index defined by the keyIndex .
+
+ @Param[in]     ioc_fm_pcd_cc_node_modify_key_and_next_engine_params_t  TBD
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_CcSetNode() not only of the relevnt node but also
+                the node that points to this node
+*//***************************************************************************/
+#define FM_PCD_IOC_CC_NODE_MODIFY_KEY_AND_NEXT_ENGINE   _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(35), ioc_fm_pcd_cc_node_modify_key_and_next_engine_params_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_IOC_CC_NODE_MODIFY_KEY
+
+ @Description   Modify the key  in the index defined by the keyIndex .
+
+ @Param[in]     ioc_fm_pcd_cc_node_modify_key_params_t  TBD
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_CcSetNode() not only of the relevnt node but also
+                the node that points to this node
+*//***************************************************************************/
+#define FM_PCD_IOC_CC_NODE_MODIFY_KEY   _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(36), ioc_fm_pcd_cc_node_modify_key_params_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_IOC_PLCR_SET_PROFILE
+
+ @Description   Sets a profile entry in the policer profile table.
+                The routine overrides any existing value.
+
+ @Param[in,out] ioc_fm_pcd_plcr_profile_params_t    A structure of parameters for defining a
+                                                    policer profile entry.
+
+ @Return        0 on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_Init().
+*//***************************************************************************/
+#define FM_PCD_IOC_PLCR_SET_PROFILE     _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(37), ioc_fm_pcd_plcr_profile_params_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_IOC_PLCR_DEL_PROFILE
+
+ @Description   Delete a profile entry in the policer profile table.
+                The routine set entry to invalid.
+
+ @Param[in]     ioc_fm_obj_t        an id of a policer-profile.
+
+ @Return        0 on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_Init().
+*//***************************************************************************/
+#define FM_PCD_IOC_PLCR_DEL_PROFILE     _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(38), ioc_fm_obj_t)
+
+/** @} */ /* end of lnx_ioctl_FM_PCD_Runtime_grp group */
+/** @} */ /* end of lnx_ioctl_FM_PCD_grp group */
+/** @} */ /* end of lnx_ioctl_FM_grp group */
+
+
+#endif /* __FM_PCD_IOCTLS_H */
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/Peripherals/fm_port_ioctls.h b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/Peripherals/fm_port_ioctls.h
new file mode 100644
index 0000000..4027dac
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/Peripherals/fm_port_ioctls.h
@@ -0,0 +1,592 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/******************************************************************************
+ @File          fm_port_ioctls.h
+
+ @Description   FM Port routines
+*//***************************************************************************/
+#ifndef __FM_PORT_IOCTLS_H
+#define __FM_PORT_IOCTLS_H
+
+#include "net_ioctls.h"
+#include "fm_ioctls.h"
+#include "fm_pcd_ioctls.h"
+
+
+/**************************************************************************//**
+ @Group         lnx_ioctl_FM_grp Frame Manager Linux IOCTL API
+
+ @Description   FM Linux ioctls definitions and enums
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Group         lnx_ioctl_FM_PORT_grp FM Port
+
+ @Description   FM Port API
+
+                The FM uses a general module called "port" to represent a Tx port
+                (MAC), an Rx port (MAC), offline parsing flow or host command
+                flow. There may be up to 17 (may change) ports in an FM - 5 Tx
+                ports (4 for the 1G MACs, 1 for the 10G MAC), 5 Rx Ports, and 7
+                Host command/Offline parsing ports. The SW driver manages these
+                ports as sub-modules of the FM, i.e. after an FM is initialized,
+                its ports may be initialized and operated upon.
+                The port is initialized aware of its type, but other functions on
+                a port may be indifferent to its type. When necessary, the driver
+                verifies coherency and returns error if applicable.
+                On initialization, user specifies the port type and it's index
+                (relative to the port's type). Host command and Offline parsing
+                ports share the same id range, I.e user may not initialized host
+                command port 0 and offline parsing port 0.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Group         lnx_ioctl_FM_PORT_runtime_control_grp FM Port Runtime Control Unit
+
+ @Description   FM Port Runtime control unit API functions, definitions and enums.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Collection    General FM Port defines
+*//***************************************************************************/
+#define IOC_FM_PORT_NUM_OF_CONGESTION_GRPS      256 /**< Total number of congestion groups in QM */
+/* @} */
+
+
+/**************************************************************************//**
+ @Description   struct for defining port PCD modes
+*//***************************************************************************/
+typedef enum ioc_fm_port_pcd_support {
+    e_IOC_FM_PORT_PCD_SUPPORT_NONE,                 /**< BMI to BMI, PCD is not used */
+    e_IOC_FM_PORT_PCD_SUPPORT_PRS_ONLY,             /**< Use only Parser */
+    e_IOC_FM_PORT_PCD_SUPPORT_PLCR_ONLY,            /**< Use only Policer */
+    e_IOC_FM_PORT_PCD_SUPPORT_PRS_AND_PLCR,         /**< Use Parser and Policer */
+    e_IOC_FM_PORT_PCD_SUPPORT_PRS_AND_KG,           /**< Use Parser and Keygen */
+    e_IOC_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC,    /**< Use Parser, Keygen and Coarse Classification */
+    e_IOC_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC_AND_PLCR, /**< Use all PCD engines */
+    e_IOC_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_PLCR   /**< Use Parser, Keygen and Policer */
+} ioc_fm_port_pcd_support;
+
+/**************************************************************************//**
+ @Description   enum for defining FM Port counters
+*//***************************************************************************/
+typedef enum fm_port_counters {
+    e_IOC_FM_PORT_COUNTERS_CYCLE,                       /**< BMI performance counter */
+    e_IOC_FM_PORT_COUNTERS_TASK_UTIL,                   /**< BMI performance counter */
+    e_IOC_FM_PORT_COUNTERS_QUEUE_UTIL,                  /**< BMI performance counter */
+    e_IOC_FM_PORT_COUNTERS_DMA_UTIL,                    /**< BMI performance counter */
+    e_IOC_FM_PORT_COUNTERS_FIFO_UTIL,                   /**< BMI performance counter */
+    e_IOC_FM_PORT_COUNTERS_RX_PAUSE_ACTIVATION,         /**< BMI Rx only performance counter */
+    e_IOC_FM_PORT_COUNTERS_FRAME,                       /**< BMI statistics counter */
+    e_IOC_FM_PORT_COUNTERS_DISCARD_FRAME,               /**< BMI statistics counter */
+    e_IOC_FM_PORT_COUNTERS_DEALLOC_BUF,                 /**< BMI deallocate buffer statistics counter */
+    e_IOC_FM_PORT_COUNTERS_RX_BAD_FRAME,                /**< BMI Rx only statistics counter */
+    e_IOC_FM_PORT_COUNTERS_RX_LARGE_FRAME,              /**< BMI Rx only statistics counter */
+    e_IOC_FM_PORT_COUNTERS_RX_OUT_OF_BUFFERS_DISCARD,   /**< BMI Rx only statistics counter */
+    e_IOC_FM_PORT_COUNTERS_RX_FILTER_FRAME,             /**< BMI Rx & OP only statistics counter */
+    e_IOC_FM_PORT_COUNTERS_RX_LIST_DMA_ERR,             /**< BMI Rx, OP & HC only statistics counter */
+    e_IOC_FM_PORT_COUNTERS_WRED_DISCARD,                /**< BMI OP & HC only statistics counter */
+    e_IOC_FM_PORT_COUNTERS_LENGTH_ERR,                  /**< BMI non-Rx statistics counter */
+    e_IOC_FM_PORT_COUNTERS_UNSUPPRTED_FORMAT,           /**< BMI non-Rx statistics counter */
+    e_IOC_FM_PORT_COUNTERS_DEQ_TOTAL,                   /**< QMI counter */
+    e_IOC_FM_PORT_COUNTERS_ENQ_TOTAL,                   /**< QMI counter */
+    e_IOC_FM_PORT_COUNTERS_DEQ_FROM_DEFAULT,            /**< QMI counter */
+    e_IOC_FM_PORT_COUNTERS_DEQ_CONFIRM                  /**< QMI counter */
+} fm_port_counters;
+
+
+/**************************************************************************//**
+ @Description   Structure for Port id parameters.
+                Fields commented 'IN' are passed by the port module to be used
+                by the FM module.
+                Fields commented 'OUT' will be filled by FM before returning to port.
+*//***************************************************************************/
+typedef struct ioc_fm_port_congestion_groups_t {
+    uint16_t    num_of_congestion_grps_to_consider; /**< Size of congestion_grps_to_consider array */
+    uint8_t     congestion_grps_to_consider [IOC_FM_PORT_NUM_OF_CONGESTION_GRPS];   /**< list of congestion groups */
+} ioc_fm_port_congestion_groups_t;
+
+
+/**************************************************************************//**
+ @Function      FM_PORT_IOC_DISABLE
+
+ @Description   Gracefully disable an FM port. The port will not start new tasks after all
+                tasks associated with the port are terminated.
+
+ @Return        0 on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+                This is a blocking routine, it returns after port is
+                gracefully stopped, i.e. the port will not except new frames,
+                but it will finish all frames or tasks which were already began
+*//***************************************************************************/
+#define FM_PORT_IOC_DISABLE   _IO(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(1))
+
+/**************************************************************************//**
+ @Function      FM_PORT_IOC_ENABLE
+
+ @Description   A runtime routine provided to allow disable/enable of port.
+
+ @Return        0 on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+#define FM_PORT_IOC_ENABLE   _IO(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(2))
+
+/**************************************************************************//**
+ @Function      FM_PORT_IOC_SET_ERRORS_ROUTE
+
+ @Description   Errors selected for this routine will cause a frame with that error
+                to be enqueued to error queue.
+                Errors not selected for this routine will cause a frame with that error
+                to be enqueued to the one of the other port queues.
+                By default all errors are defined to be enqueued to error queue.
+                Errors that were configured to be discarded (at initialization)
+                may not be selected here.
+
+                May be used for Rx and offline parsing ports only
+
+ @Param[in]     ioc_fm_port_frame_err_select_t  A list of errors to enqueue to error queue
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+#define FM_PORT_IOC_SET_ERRORS_ROUTE   _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(3), ioc_fm_port_frame_err_select_t)
+
+/**************************************************************************//**
+ @Group         lnx_ioctl_FM_PORT_pcd_runtime_control_grp FM Port PCD Runtime Control Unit
+
+ @Description   FM Port PCD Runtime control unit API functions, definitions and enums.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description   A structure of scheme parameters
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_kg_scheme_select_t {
+    bool        direct;                     /**< TRUE is the scheme should be accessed directly */
+    void        *scheme_id;                 /**< Scheme id */
+} ioc_fm_pcd_kg_scheme_select_t;
+
+/**************************************************************************//**
+ @Description    A structure for defining the Parser starting point
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_prs_start_t {
+    uint8_t             parsing_offset; /**< Number of bytes from begining of packet to
+                                             start parsing */
+    ioc_net_header_type first_prs_hdr;  /**< The type of the first header axpected at
+                                             'parsingOffset' */
+} ioc_fm_pcd_prs_start_t;
+
+/**************************************************************************//**
+ @Description   Scheme is'd structure
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_port_schemes_params_t {
+    uint8_t     num_of_schemes;
+    void        *schemes_ids [IOC_FM_PCD_KG_NUM_OF_SCHEMES];
+} ioc_fm_pcd_port_schemes_params_t;
+
+/**************************************************************************//**
+ @Description   classification-plan-group structure
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_port_cls_plan_params_t {
+    bool        use_cls_plan;       /**< TRUE to use a pre-defined group, FALSE to stop using one. */
+    void        *new_cls_plan_grp;  /**< An id of a classification plan group that was already set. */
+} ioc_fm_pcd_port_cls_plan_params_t;
+
+/**************************************************************************//**
+ @Description   Union for defining port protocol parameters for parser
+*//***************************************************************************/
+typedef union ioc_fm_pcd_hdr_prs_opts_u {
+    /* MPLS */
+    struct {
+        bool                label_interpretation_enable;/**< When this bit is set, the last MPLS label will be
+                                                             interpreted as described in HW spec table. When the bit
+                                                             is cleared, the parser will advance to MPLS next parse */
+        ioc_net_header_type next_parse;                 /**< must be equal or higher than IPv4 */
+    } mpls_prs_options;
+    /* VLAN */
+    struct {
+        uint16_t            tag_protocol_id1;           /**< User defined Tag Protocol Identifier, to be recognized
+                                                             on VLAN TAG on top of 0x8100 and 0x88A8 */
+        uint16_t            tag_protocol_id2;           /**< User defined Tag Protocol Identifier, to be recognized
+                                                             on VLAN TAG on top of 0x8100 and 0x88A8 */
+    } vlan_prs_options;
+    /* IPV6 */
+    struct {
+        bool                routing_hdr_disable;        /**< Disable routing header */
+    } ipv6_prs_options;
+
+    /* UDP */
+    struct {
+        bool                pad_ignore_checksum;        /**< TRUE to ignore pad in checksum */
+    } udp_prs_options;
+
+    /* TCP */
+    struct {
+        bool                pad_ignore_checksum;        /**< TRUE to ignore pad in checksum */
+    } tcp_prs_options;
+} ioc_fm_pcd_hdr_prs_opts_u;
+
+
+/**************************************************************************//**
+ @Description   A structure for defining each header for the parser
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_prs_additional_hdr_params_t {
+    ioc_net_header_type         hdr;                /**< Selected header */
+    bool                        err_disable;        /**< TRUE to disable error indication */
+    bool                        soft_prs_enable;    /**< Enable jump to SW parser when this
+                                                         header is recognized by the HW parser. */
+    char                        *soft_prs_label;    /**< Label of SW parser to jump to. */
+    bool                        use_prs_opts;       /**< TRUE to use parser options. */
+    ioc_fm_pcd_hdr_prs_opts_u   prs_opts;           /**< A unuion according to header type,
+                                                         defining the parser options selected.*/
+} ioc_fm_pcd_prs_additional_hdr_params_t;
+
+/**************************************************************************//**
+ @Description   struct for defining port PCD parameters
+*//***************************************************************************/
+typedef struct ioc_fm_port_pcd_prs_params_t {
+    uint8_t                                 prs_res_priv_info;          /**< The private info provides a method of inserting
+                                                                             port information into the parser result. This information
+                                                                             may be extracted by Keygen and be used for frames
+                                                                             distribution when a per-port distinction is required,
+                                                                             it may also be used as a port logical id for analyazing
+                                                                             incoming frames. */
+    uint8_t                                 parsing_offset;             /**< Number of bytes from begining of packet to
+                                                                             start parsing */
+    ioc_net_header_type                     first_prs_hdr;              /**< The type of the first header axpected at
+                                                                             'parsingOffset' */
+    bool                                    include_in_prs_statistics;  /**< TRUE to include this port in the parser statistics.*/
+    uint8_t                                 num_of_hdrs_with_additional_params;
+                                                        /**< Normally 0, some headers may get
+                                                             special parameters */
+    ioc_fm_pcd_prs_additional_hdr_params_t  additional_params[IOC_FM_PCD_PRS_NUM_OF_HDRS];
+                                                        /**< A structure of additional parameters
+                                                             for each header that requires them */
+    bool                                    set_vlan_tpid1;             /**< TRUE to configure user selection of Ethertype to
+                                                                             indicate a VLAN tag (in addition to the TPID values
+                                                                             0x8100 and 0x88A8). */
+    uint16_t                                vlan_tpid1;                 /**< extra tag to use if setVlanTpid1=TRUE. */
+    bool                                    set_vlan_tpid2;             /**< TRUE to configure user selection of Ethertype to
+                                                                             indicate a VLAN tag (in addition to the TPID values
+                                                                             0x8100 and 0x88A8). */
+    uint16_t                                vlan_tpid2;                 /**< extra tag to use if setVlanTpid1=TRUE. */
+} ioc_fm_port_pcd_prs_params_t;
+
+/**************************************************************************//**
+ @Description   struct for defining coarse alassification parameters
+*//***************************************************************************/
+typedef struct ioc_fm_port_pcd_cc_params_t {
+    void                *cc_tree_id; /**< CC tree id */
+} ioc_fm_port_pcd_cc_params_t;
+
+/**************************************************************************//**
+ @Description   struct for defining keygen parameters
+*//***************************************************************************/
+typedef struct ioc_fm_port_pcd_kg_params_t {
+    uint8_t             num_of_schemes;                 /**< Number of schemes for port to be bound to. */
+    void                *schemes_ids[IOC_FM_PCD_KG_NUM_OF_SCHEMES];
+                                                        /**< Array of 'numOfSchemes' schemes for the
+                                                             port to be bound to */
+    bool                use_cls_plan;                   /**< TRUE to use the classification plan mechanism */
+    void                *cls_plan_grp_id;               /**< clsPlan must be of the same netEnvId
+                                                             of this port */
+    bool                direct_scheme;                  /**< TRUE for going from parser to a specific scheme,
+                                                             regardless of parser result */
+    void                *direct_scheme_id;              /**< relevant only if direct == TRUE */
+} ioc_fm_port_pcd_kg_params_t;
+
+/**************************************************************************//**
+ @Description   struct for defining policer parameters
+*//***************************************************************************/
+typedef struct ioc_fm_port_pcd_plcr_params_t {
+    void                *plcr_profile_id;               /**< relevant only if
+                                                             e_IOC_FM_PCD_SUPPORT_PLCR_ONLY or
+                                                             e_IOC_FM_PCD_SUPPORT_PRS_AND_PLCR were selected */
+} ioc_fm_port_pcd_plcr_params_t;
+
+/**************************************************************************//**
+ @Description   struct for defining port PCD parameters
+*//***************************************************************************/
+typedef struct ioc_fm_port_pcd_params_t {
+    ioc_fm_port_pcd_support         pcd_support;    /**< Relevant for Rx and offline ports only.
+                                                         Describes the active PCD engines for this port. */
+    void                            *net_env_id;    /**< HL Unused in PLCR only mode */
+    ioc_fm_port_pcd_prs_params_t    *p_prs_params;  /**< Parser parameters for this port */
+    ioc_fm_port_pcd_cc_params_t     *p_cc_params;   /**< Coarse classification parameters for this port */
+    ioc_fm_port_pcd_kg_params_t     *p_kg_params;   /**< Keygen parameters for this port */
+    ioc_fm_port_pcd_plcr_params_t   *p_plcr_params; /**< Policer parameters for this port */
+} ioc_fm_port_pcd_params_t;
+
+/**************************************************************************//**
+ @Description   FQID parameters structure
+*//***************************************************************************/
+typedef struct ioc_fm_port_pcd_fqids_params_t {
+    uint32_t            num_fqids;  /**< Number of fqids to be allocated for the port */
+    uint8_t             alignment;  /**< Alignment required for this port */
+    uint32_t            base_fqid;  /**< output parameter - the base fqid */
+} ioc_fm_port_pcd_fqids_params_t;
+
+
+/**************************************************************************//**
+ @Function      FM_PORT_IOC_ALLOC_PCD_FQIDS
+
+ @Description   Allocates FQID's
+
+                May be used for Rx and offline parsing ports only
+
+ @Param[in,out] ioc_fm_port_pcd_fqids_params_t  Parameters for allocating FQID's
+
+ @Return        0 on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+#define FM_PORT_IOC_ALLOC_PCD_FQIDS   _IOWR(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(19), ioc_fm_port_pcd_fqids_params_t)
+
+/**************************************************************************//**
+ @Function      FM_PORT_IOC_SET_PCD
+
+ @Description   Calling this routine defines the port's PCD configuration.
+                It changes it from its default configuration which is PCD
+                disabled (BMI to BMI) and configures it according to the passed
+                parameters.
+
+                May be used for Rx and offline parsing ports only
+
+ @Param[in]     ioc_fm_port_pcd_params_t    A Structure of parameters defining the port's PCD
+                                            configuration.
+
+ @Return        0 on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+#define FM_PORT_IOC_SET_PCD _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(20), ioc_fm_port_pcd_params_t)
+
+/**************************************************************************//**
+ @Function      FM_PORT_IOC_DELETE_PCD
+
+ @Description   Calling this routine releases the port's PCD configuration.
+                The port returns to its default configuration which is PCD
+                disabled (BMI to BMI) and all PCD configuration is removed.
+
+                May be used for Rx and offline parsing ports which are
+                in PCD mode  only
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+#define FM_PORT_IOC_DELETE_PCD _IO(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(21))
+
+/**************************************************************************//**
+ @Function      FM_PORT_IOC_DETACH_PCD
+
+ @Description   Calling this routine detaches the port from its PCD functionality.
+                The port returns to its default flow which is BMI to BMI.
+
+                May be used for Rx and offline parsing ports which are
+                in PCD mode only
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+#define FM_PORT_IOC_DETACH_PCD _IO(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(22))
+
+/**************************************************************************//**
+ @Function      FM_PORT_IOC_ATTACH_PCD
+
+ @Description   This routine may be called after FM_PORT_DetachPCD was called,
+                to return to the originally configured PCD support flow.
+                The couple of routines are used to allow PCD configuration changes
+                that demand that PCD will not be used while changes take place.
+
+                May be used for Rx and offline parsing ports which are
+                in PCD mode only
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+#define FM_PORT_IOC_ATTACH_PCD _IO(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(23))
+
+/**************************************************************************//**
+ @Function      FM_PORT_IOC_PCD_PLCR_ALLOC_PROFILES
+
+ @Description   This routine may be called only for ports that use the Policer in
+                order to allocate private policer profiles.
+
+ @Param[in]     uint16_t       The number of required policer profiles
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init() and FM_PCD_Init(), and before FM_PORT_SetPCD().
+*//***************************************************************************/
+#define FM_PORT_IOC_PCD_PLCR_ALLOC_PROFILES     _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(24), uint16_t)
+
+/**************************************************************************//**
+ @Function      FM_PORT_IOC_PCD_PLCR_FREE_PROFILES
+
+ @Description   This routine should be called for freeing private policer profiles.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init() and FM_PCD_Init(), and before FM_PORT_SetPCD().
+*//***************************************************************************/
+#define FM_PORT_IOC_PCD_PLCR_FREE_PROFILES     _IO(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(25))
+
+/**************************************************************************//**
+ @Function      FM_PORT_IOC_PCD_KG_MODIFY_INITIAL_SCHEME
+
+ @Description   This routine may be called only for ports that use the keygen in
+                order to change the initial scheme frame should be routed to.
+                The change may be of a scheme id (in case of direct mode),
+                from direct to indirect, or from indirect to direct - specifying the scheme id.
+
+ @Param[in]     ioc_fm_pcd_kg_scheme_select_t   A structure of parameters for defining whether
+                                                a scheme is direct/indirect, and if direct - scheme id.
+
+ @Return        0 on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+#define FM_PORT_IOC_PCD_KG_MODIFY_INITIAL_SCHEME _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(26), ioc_fm_pcd_kg_scheme_select_t)
+
+/**************************************************************************//**
+ @Function      FM_PORT_IOC_PCD_PLCR_MODIFY_INITIAL_PROFILE
+
+ @Description   This routine may be called for ports with flows e_IOC_FM_PCD_SUPPORT_PLCR_ONLY or
+                e_IOC_FM_PCD_SUPPORT_PRS_AND_PLCR  only, to change the initial Policer profile frame
+                should be routed to. The change may be of a profile and/or absolute/direct mode
+                selection.
+
+ @Param[in]     ioc_fm_obj_t       Policer profile Id as returned from FM_PCD_PlcrSetProfile.
+
+ @Return        0 on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+#define FM_PORT_IOC_PCD_PLCR_MODIFY_INITIAL_PROFILE _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(27), ioc_fm_obj_t)
+
+/**************************************************************************//**
+ @Function      FM_PORT_IOC_PCD_CC_MODIFY_TREE
+
+ @Description   This routine may be called to change this port connection to
+                a pre-initializes coarse classification Tree.
+
+ @Param[in]     ioc_fm_obj_t    Id of new coarse classification tree selected for this port.
+
+ @Return        0 on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+#define FM_PORT_IOC_PCD_CC_MODIFY_TREE _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(28), ioc_fm_obj_t)
+
+/**************************************************************************//**
+ @Function      FM_PORT_IOC_PCD_KG_MODIFY_CLS_PLAN_GRP
+
+ @Description   This routine may be called for ports using the KG functionality of the PCD,
+                if the user wishes to replace the classification plan
+                group that the port uses, to start using the classification plan mechanism or to stop
+                using it. The routine may not be called while port
+                receives packets using the PCD functionalities, therefor port must be first detached
+                from the PCD, only than the routine may be called, and than port be attached to PCD again.
+
+ @Param[in]     ioc_fm_pcd_port_cls_plan_params_t  the parameters of the new classification-plan-group
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init(), FM_PORT_SetPCD() and FM_PORT_DetachPCD()
+*//***************************************************************************/
+#define FM_PORT_IOC_PCD_KG_MODIFY_CLS_PLAN_GRP _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(29), ioc_fm_pcd_port_cls_plan_params_t)
+
+/**************************************************************************//**
+ @Function      FM_PORT_IOC_PCD_KG_BIND_SCHEMES
+
+ @Description   These routines may be called for modifying the binding of ports
+                to schemes. The scheme itself is not added,
+                just this specific port starts using it.
+
+ @Param[in]     ioc_fm_pcd_port_schemes_params_t    Schemes parameters structre
+
+ @Return        0 on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+#define FM_PORT_IOC_PCD_KG_BIND_SCHEMES _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(30), ioc_fm_pcd_port_schemes_params_t)
+
+/**************************************************************************//**
+ @Function      FM_PORT_IOC_PCD_KG_UNBIND_SCHEMES
+
+ @Description   These routines may be called for modifying the binding of ports
+                to schemes. The scheme itself is not removed or invalidated,
+                just this specific port stops using it.
+
+ @Param[in]     ioc_fm_pcd_port_schemes_params_t    Schemes parameters structre
+
+ @Return        0 on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+#define FM_PORT_IOC_PCD_KG_UNBIND_SCHEMES _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(31), ioc_fm_pcd_port_schemes_params_t)
+
+/**************************************************************************//**
+ @Function      FM_PORT_IOC_PCD_PRS_MODIFY_START_OFFSET
+
+ @Description   Runtime change of the parser start offset within the header.
+
+ @Param[in]     ioc_fm_pcd_prs_start_t  A structure of parameters for defining the
+                                        start point for the parser.
+
+ @Return        0 on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+#define      FM_PORT_IOC_PCD_PRS_MODIFY_START_OFFSET _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(32), ioc_fm_pcd_prs_start_t)
+
+/** @} */ /* end of lnx_ioctl_FM_PORT_pcd_runtime_control_grp group */
+/** @} */ /* end of lnx_ioctl_FM_PORT_runtime_control_grp group */
+/** @} */ /* end of lnx_ioctl_FM_PORT_grp group */
+/** @} */ /* end of lnx_ioctl_FM_grp group */
+
+
+#endif /* __FM_PORT_IOCTLS_H */
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/Peripherals/fm_test_ioctls.h b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/Peripherals/fm_test_ioctls.h
new file mode 100644
index 0000000..848ba0f
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/Peripherals/fm_test_ioctls.h
@@ -0,0 +1,159 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**************************************************************************//**
+ @File          fm_test_ioctls.h
+
+ @Description   FM Char device ioctls
+*//***************************************************************************/
+#ifndef __FM_TEST_IOCTLS_H
+#define __FM_TEST_IOCTLS_H
+
+#include "ioctls.h"
+
+
+/**************************************************************************//**
+ @Group         lnx_ioctl_FMT_grp Frame Manager Test Linux IOCTL API
+
+ @Description   FM-Test Linux ioctls definitions and enums
+
+ @{
+*//***************************************************************************/
+
+#define IOC_FMT_MAX_NUM_OF_PORTS        24
+
+/**************************************************************************//**
+ @Collection    TBD
+*//***************************************************************************/
+/**************************************************************************//**
+  @Description: Name of the FM-Test chardev
+*//***************************************************************************/
+#define DEV_FM_TEST_NAME                "fm-test-port"
+
+#define DEV_FM_TEST_PORTS_MINOR_BASE    0
+#define DEV_FM_TEST_MAX_MINORS          (DEV_FM_TEST_PORTS_MINOR_BASE + IOC_FMT_MAX_NUM_OF_PORTS)
+
+#define FMT_PORT_IOC_NUM(n)             n
+/* @} */
+
+/**************************************************************************//**
+ @Group         lnx_ioctl_FMT_lib_grp FM-Test library
+
+ @Description   TBD
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description   TBD
+*//***************************************************************************/
+typedef uint8_t ioc_fmt_xxx_t;
+
+
+/**************************************************************************//**
+ @Description   TBD
+*//***************************************************************************/
+typedef struct ioc_fmt_buff_context_t {
+    void            *p_user_priv;
+    uint8_t         fm_prs_res[32];
+    uint8_t         fm_time_stamp[8];
+} ioc_fmt_buff_context_t;
+
+
+/**************************************************************************//**
+ @Description   TBD
+*//***************************************************************************/
+typedef struct ioc_fmt_buff_desc_t {
+    uint32_t               qid;
+    void                   *p_data;
+    uint32_t               size;
+    uint32_t               status;
+    ioc_fmt_buff_context_t buff_context;
+} ioc_fmt_buff_desc_t;
+
+
+/**************************************************************************//**
+ @Group         lnx_ioctl_FMT_runtime_control_grp FM-Test Runtime Control Unit
+
+ @Description   TBD
+ @{
+*//***************************************************************************/
+
+/** @} */ /* end of lnx_ioctl_FMT_runtime_control_grp group */
+
+
+/**************************************************************************//**
+ @Group         lnx_ioctl_FMTP_lib_grp FM-Port-Test library
+
+ @Description   TBD
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description   FM-Test TBD
+*//***************************************************************************/
+typedef enum ioc_fmt_port_type {
+    e_IOC_FMT_PORT_T_RXTX,  /**< Standard port */
+    e_IOC_FMT_PORT_T_OP,    /**< Offline-parsing port */
+} ioc_fmt_port_type;
+
+/**************************************************************************//**
+ @Description   TBD
+*//***************************************************************************/
+typedef struct ioc_fmt_port_param_t {
+    uint8_t             fm_id;
+    ioc_fmt_port_type   fm_port_type;
+    uint8_t             fm_port_id;
+    uint32_t            num_tx_queues;
+} ioc_fmt_port_param_t;
+
+
+/**************************************************************************//**
+ @Function      FMT_PORT_IOC_INIT
+
+ @Description   TBD
+
+ @Param[in]    ioc_fmt_port_param_t  TBD
+
+ @Return        None.
+
+ @Cautions      Allowed only following FM_Init().
+*//***************************************************************************/
+#define FMT_PORT_IOC_INIT   _IOW(FMT_IOC_TYPE_BASE, FMT_PORT_IOC_NUM(0), ioc_fmt_port_param_t)
+
+/** @} */ /* end of lnx_ioctl_FMTP_lib_grp group */
+/** @} */ /* end of lnx_ioctl_FMT_lib_grp group */
+/** @} */ /* end of lnx_ioctl_FMT_grp */
+
+
+#endif /* __FM_TEST_IOCTLS_H */
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/integrations/P4080/integration_ioctls.h b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/integrations/P4080/integration_ioctls.h
new file mode 100644
index 0000000..5396f3c
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/integrations/P4080/integration_ioctls.h
@@ -0,0 +1,47 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**************************************************************************//**
+ @File          integration_ioctls.h
+
+ @Description   External header file for Integration unit routines.
+*//***************************************************************************/
+
+#ifndef __INTG_IOCTLS_H
+#define __INTG_IOCTLS_H
+
+
+#define FM_IOC_TYPE_BASE            (NCSW_IOC_TYPE_BASE+1)
+#define FMT_IOC_TYPE_BASE           (NCSW_IOC_TYPE_BASE+2)
+
+
+#endif /* __INTG_IOCTLS_H */
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/ioctls.h b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/ioctls.h
new file mode 100644
index 0000000..151a0f4
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/ioctls.h
@@ -0,0 +1,84 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**************************************************************************//**
+ @File          ioctls.h
+
+ @Description   Structures and definitions for Command Relay Ioctls
+*//***************************************************************************/
+
+#ifndef __IOCTLS_H__
+#define __IOCTLS_H__
+
+#include <asm/ioctl.h>
+
+#include "integration_ioctls.h"
+
+
+/**************************************************************************//**
+ @Group         lnx_ioctl_ncsw_grp    NeCommSw Linux User-Space (IOCTL) API
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Collection    TBD
+*//***************************************************************************/
+#define NCSW_IOC_TYPE_BASE          0xe0
+/* @} */
+
+
+/**************************************************************************//**
+ @Description   IOCTL Memory allocation types.
+*//***************************************************************************/
+typedef enum ioc_mem_type {
+    e_IOC_MEM_INVALID      = 0x00000000,  /**< Invalid memory type (error) */
+    e_IOC_MEM_CACHABLE_SYS = 0x00000001,  /**< Primary DDR, cacheable segment */
+    e_IOC_MEM_NOCACHE_SYS  = 0x00000004,  /**< Primary DDR, non-cacheable segment */
+    e_IOC_MEM_SECONDARY    = 0x00000002,  /**< Either secondary DDR or SDRAM */
+    e_IOC_MEM_PRAM         = 0x00000008   /**< Multi-user RAM identifier */
+} ioc_mem_type;
+
+/**************************************************************************//**
+ @Description   Enumeration (bit flags) of communication modes (Transmit,
+                receive or both).
+*//***************************************************************************/
+typedef enum ioc_comm_mode {
+      e_IOC_COMM_MODE_NONE         = 0  /**< No transmit/receive communication */
+    , e_IOC_COMM_MODE_RX           = 1  /**< Only receive communication */
+    , e_IOC_COMM_MODE_TX           = 2  /**< Only transmit communication */
+    , e_IOC_COMM_MODE_RX_AND_TX    = 3  /**< Both transmit and receive communication */
+} ioc_comm_mode;
+
+/** @} */ /* end of lnx_ioctl_ncsw_grp */
+
+
+#endif /* __IOCTLS_H__ */
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/net_ioctls.h b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/net_ioctls.h
new file mode 100644
index 0000000..c26e6d4
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/net_ioctls.h
@@ -0,0 +1,365 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**************************************************************************//**
+ @File          net_ioctls.h
+
+ @Description   This file contains common and general netcomm headers definitions.
+*//***************************************************************************/
+#ifndef __NET_IOCTLS_H
+#define __NET_IOCTLS_H
+
+#include "ioctls.h"
+
+
+typedef uint8_t ioc_header_field_ppp_t;
+
+#define IOC_NET_HEADER_FIELD_PPP_PID                        (1)
+#define IOC_NET_HEADER_FIELD_PPP_COMPRESSED                 (IOC_NET_HEADER_FIELD_PPP_PID << 1)
+#define IOC_NET_HEADER_FIELD_PPP_ALL_FIELDS                 ((IOC_NET_HEADER_FIELD_PPP_PID << 2) - 1)
+
+
+typedef uint8_t ioc_header_field_pppoe_t;
+
+#define IOC_NET_HEADER_FIELD_PPPoE_VER                      (1)
+#define IOC_NET_HEADER_FIELD_PPPoE_TYPE                     (IOC_NET_HEADER_FIELD_PPPoE_VER << 1)
+#define IOC_NET_HEADER_FIELD_PPPoE_CODE                     (IOC_NET_HEADER_FIELD_PPPoE_VER << 2)
+#define IOC_NET_HEADER_FIELD_PPPoE_SID                      (IOC_NET_HEADER_FIELD_PPPoE_VER << 3)
+#define IOC_NET_HEADER_FIELD_PPPoE_LEN                      (IOC_NET_HEADER_FIELD_PPPoE_VER << 4)
+#define IOC_NET_HEADER_FIELD_PPPoE_SESSION                  (IOC_NET_HEADER_FIELD_PPPoE_VER << 5)
+#define IOC_NET_HEADER_FIELD_PPPoE_PID                      (IOC_NET_HEADER_FIELD_PPPoE_VER << 6)
+#define IOC_NET_HEADER_FIELD_PPPoE_ALL_FIELDS               ((IOC_NET_HEADER_FIELD_PPPoE_VER << 7) - 1)
+
+#define IOC_NET_HEADER_FIELD_PPPMUX_PID                     (1)
+#define IOC_NET_HEADER_FIELD_PPPMUX_CKSUM                   (IOC_NET_HEADER_FIELD_PPPMUX_PID << 1)
+#define IOC_NET_HEADER_FIELD_PPPMUX_COMPRESSED              (IOC_NET_HEADER_FIELD_PPPMUX_PID << 2)
+#define IOC_NET_HEADER_FIELD_PPPMUX_ALL_FIELDS              ((IOC_NET_HEADER_FIELD_PPPMUX_PID << 3) - 1)
+
+#define IOC_NET_HEADER_FIELD_PPPMUX_SUBFRAME_PFF            (1)
+#define IOC_NET_HEADER_FIELD_PPPMUX_SUBFRAME_LXT            (IOC_NET_HEADER_FIELD_PPPMUX_SUBFRAME_PFF << 1)
+#define IOC_NET_HEADER_FIELD_PPPMUX_SUBFRAME_LEN            (IOC_NET_HEADER_FIELD_PPPMUX_SUBFRAME_PFF << 2)
+#define IOC_NET_HEADER_FIELD_PPPMUX_SUBFRAME_PID            (IOC_NET_HEADER_FIELD_PPPMUX_SUBFRAME_PFF << 3)
+#define IOC_NET_HEADER_FIELD_PPPMUX_SUBFRAME_USE_PID        (IOC_NET_HEADER_FIELD_PPPMUX_SUBFRAME_PFF << 4)
+#define IOC_NET_HEADER_FIELD_PPPMUX_SUBFRAME_ALL_FIELDS     ((IOC_NET_HEADER_FIELD_PPPMUX_SUBFRAME_PFF << 5) - 1)
+
+
+typedef uint8_t ioc_header_field_eth_t;
+
+#define IOC_NET_HEADER_FIELD_ETH_DA                         (1)
+#define IOC_NET_HEADER_FIELD_ETH_SA                         (IOC_NET_HEADER_FIELD_ETH_DA << 1)
+#define IOC_NET_HEADER_FIELD_ETH_LENGTH                     (IOC_NET_HEADER_FIELD_ETH_DA << 2)
+#define IOC_NET_HEADER_FIELD_ETH_TYPE                       (IOC_NET_HEADER_FIELD_ETH_DA << 3)
+#define IOC_NET_HEADER_FIELD_ETH_FINAL_CKSUM                (IOC_NET_HEADER_FIELD_ETH_DA << 4)
+#define IOC_NET_HEADER_FIELD_ETH_PADDING                    (IOC_NET_HEADER_FIELD_ETH_DA << 5)
+#define IOC_NET_HEADER_FIELD_ETH_ALL_FIELDS                 ((IOC_NET_HEADER_FIELD_ETH_DA << 6) - 1)
+
+
+typedef uint16_t ioc_header_field_ipv4_t;
+
+#define IOC_NET_HEADER_FIELD_IPv4_VER                       (1)
+#define IOC_NET_HEADER_FIELD_IPv4_HDR_LEN                   (IOC_NET_HEADER_FIELD_IPv4_VER << 1)
+#define IOC_NET_HEADER_FIELD_IPv4_TOS                       (IOC_NET_HEADER_FIELD_IPv4_VER << 2)
+#define IOC_NET_HEADER_FIELD_IPv4_TOTAL_LEN                 (IOC_NET_HEADER_FIELD_IPv4_VER << 3)
+#define IOC_NET_HEADER_FIELD_IPv4_ID                        (IOC_NET_HEADER_FIELD_IPv4_VER << 4)
+#define IOC_NET_HEADER_FIELD_IPv4_FLAG_D                    (IOC_NET_HEADER_FIELD_IPv4_VER << 5)
+#define IOC_NET_HEADER_FIELD_IPv4_FLAG_M                    (IOC_NET_HEADER_FIELD_IPv4_VER << 6)
+#define IOC_NET_HEADER_FIELD_IPv4_OFFSET                    (IOC_NET_HEADER_FIELD_IPv4_VER << 7)
+#define IOC_NET_HEADER_FIELD_IPv4_TTL                       (IOC_NET_HEADER_FIELD_IPv4_VER << 8)
+#define IOC_NET_HEADER_FIELD_IPv4_PROTO                     (IOC_NET_HEADER_FIELD_IPv4_VER << 9)
+#define IOC_NET_HEADER_FIELD_IPv4_CKSUM                     (IOC_NET_HEADER_FIELD_IPv4_VER << 10)
+#define IOC_NET_HEADER_FIELD_IPv4_SRC_IP                    (IOC_NET_HEADER_FIELD_IPv4_VER << 11)
+#define IOC_NET_HEADER_FIELD_IPv4_DST_IP                    (IOC_NET_HEADER_FIELD_IPv4_VER << 12)
+#define IOC_NET_HEADER_FIELD_IPv4_OPTS                      (IOC_NET_HEADER_FIELD_IPv4_VER << 13)
+#define IOC_NET_HEADER_FIELD_IPv4_OPTS_COUNT                (IOC_NET_HEADER_FIELD_IPv4_VER << 14)
+#define IOC_NET_HEADER_FIELD_IPv4_ALL_FIELDS                ((IOC_NET_HEADER_FIELD_IPv4_VER << 15) - 1)
+
+
+typedef uint8_t ioc_header_field_ipv6_t;
+
+#define IOC_NET_HEADER_FIELD_IPv6_VER                       (1)
+#define IOC_NET_HEADER_FIELD_IPv6_TC                        (IOC_NET_HEADER_FIELD_IPv6_VER << 1)
+#define IOC_NET_HEADER_FIELD_IPv6_SRC_IP                    (IOC_NET_HEADER_FIELD_IPv6_VER << 2)
+#define IOC_NET_HEADER_FIELD_IPv6_DST_IP                    (IOC_NET_HEADER_FIELD_IPv6_VER << 3)
+#define IOC_NET_HEADER_FIELD_IPv6_NEXT_HDR                  (IOC_NET_HEADER_FIELD_IPv6_VER << 4)
+#define IOC_NET_HEADER_FIELD_IPv6_FL                        (IOC_NET_HEADER_FIELD_IPv6_VER << 5)
+#define IOC_NET_HEADER_FIELD_IPv6_HOP_LIMIT                 (IOC_NET_HEADER_FIELD_IPv6_VER << 6)
+#define IOC_NET_HEADER_FIELD_IPv6_ALL_FIELDS                ((IOC_NET_HEADER_FIELD_IPv6_VER << 7) - 1)
+
+#define IOC_NET_HEADER_FIELD_ICMP_TYPE                      (1)
+#define IOC_NET_HEADER_FIELD_ICMP_CODE                      (IOC_NET_HEADER_FIELD_ICMP_TYPE << 1)
+#define IOC_NET_HEADER_FIELD_ICMP_CKSUM                     (IOC_NET_HEADER_FIELD_ICMP_TYPE << 2)
+#define IOC_NET_HEADER_FIELD_ICMP_ID                        (IOC_NET_HEADER_FIELD_ICMP_TYPE << 3)
+#define IOC_NET_HEADER_FIELD_ICMP_SQ_NUM                    (IOC_NET_HEADER_FIELD_ICMP_TYPE << 4)
+#define IOC_NET_HEADER_FIELD_ICMP_ALL_FIELDS                ((IOC_NET_HEADER_FIELD_ICMP_TYPE << 5) - 1)
+
+#define IOC_NET_HEADER_FIELD_IGMP_VERSION                   (1)
+#define IOC_NET_HEADER_FIELD_IGMP_TYPE                      (IOC_NET_HEADER_FIELD_IGMP_VERSION << 1)
+#define IOC_NET_HEADER_FIELD_IGMP_CKSUM                     (IOC_NET_HEADER_FIELD_IGMP_VERSION << 2)
+#define IOC_NET_HEADER_FIELD_IGMP_DATA                      (IOC_NET_HEADER_FIELD_IGMP_VERSION << 3)
+#define IOC_NET_HEADER_FIELD_IGMP_ALL_FIELDS                ((IOC_NET_HEADER_FIELD_IGMP_VERSION << 4) - 1)
+
+
+typedef uint16_t ioc_header_field_tcp_t;
+
+#define IOC_NET_HEADER_FIELD_TCP_PORT_SRC                   (1)
+#define IOC_NET_HEADER_FIELD_TCP_PORT_DST                   (IOC_NET_HEADER_FIELD_TCP_PORT_SRC << 1)
+#define IOC_NET_HEADER_FIELD_TCP_SEQ                        (IOC_NET_HEADER_FIELD_TCP_PORT_SRC << 2)
+#define IOC_NET_HEADER_FIELD_TCP_ACK                        (IOC_NET_HEADER_FIELD_TCP_PORT_SRC << 3)
+#define IOC_NET_HEADER_FIELD_TCP_OFFSET                     (IOC_NET_HEADER_FIELD_TCP_PORT_SRC << 4)
+#define IOC_NET_HEADER_FIELD_TCP_FLAGS                      (IOC_NET_HEADER_FIELD_TCP_PORT_SRC << 5)
+#define IOC_NET_HEADER_FIELD_TCP_WINDOW                     (IOC_NET_HEADER_FIELD_TCP_PORT_SRC << 6)
+#define IOC_NET_HEADER_FIELD_TCP_CKSUM                      (IOC_NET_HEADER_FIELD_TCP_PORT_SRC << 7)
+#define IOC_NET_HEADER_FIELD_TCP_URGPTR                     (IOC_NET_HEADER_FIELD_TCP_PORT_SRC << 8)
+#define IOC_NET_HEADER_FIELD_TCP_OPTS                       (IOC_NET_HEADER_FIELD_TCP_PORT_SRC << 9)
+#define IOC_NET_HEADER_FIELD_TCP_OPTS_COUNT                 (IOC_NET_HEADER_FIELD_TCP_PORT_SRC << 10)
+#define IOC_NET_HEADER_FIELD_TCP_ALL_FIELDS                 ((IOC_NET_HEADER_FIELD_TCP_PORT_SRC << 11) - 1)
+
+
+typedef uint8_t ioc_header_field_sctp_t;
+
+#define IOC_NET_HEADER_FIELD_SCTP_PORT_SRC                  (1)
+#define IOC_NET_HEADER_FIELD_SCTP_PORT_DST                  (IOC_NET_HEADER_FIELD_SCTP_PORT_SRC << 1)
+#define IOC_NET_HEADER_FIELD_SCTP_VER_TAG                   (IOC_NET_HEADER_FIELD_SCTP_PORT_SRC << 2)
+#define IOC_NET_HEADER_FIELD_SCTP_CKSUM                     (IOC_NET_HEADER_FIELD_SCTP_PORT_SRC << 3)
+#define IOC_NET_HEADER_FIELD_SCTP_ALL_FIELDS                ((IOC_NET_HEADER_FIELD_SCTP_PORT_SRC << 4) - 1)
+
+
+typedef uint8_t ioc_header_field_dccp_t;
+
+#define IOC_NET_HEADER_FIELD_DCCP_PORT_SRC                  (1)
+#define IOC_NET_HEADER_FIELD_DCCP_PORT_DST                  (IOC_NET_HEADER_FIELD_DCCP_PORT_SRC << 1)
+#define IOC_NET_HEADER_FIELD_DCCP_ALL_FIELDS                ((IOC_NET_HEADER_FIELD_DCCP_PORT_SRC << 2) - 1)
+
+
+typedef uint8_t ioc_header_field_udp_t;
+
+#define IOC_NET_HEADER_FIELD_UDP_PORT_SRC                   (1)
+#define IOC_NET_HEADER_FIELD_UDP_PORT_DST                   (IOC_NET_HEADER_FIELD_UDP_PORT_SRC << 1)
+#define IOC_NET_HEADER_FIELD_UDP_LEN                        (IOC_NET_HEADER_FIELD_UDP_PORT_SRC << 2)
+#define IOC_NET_HEADER_FIELD_UDP_CKSUM                      (IOC_NET_HEADER_FIELD_UDP_PORT_SRC << 3)
+#define IOC_NET_HEADER_FIELD_UDP_ALL_FIELDS                 ((IOC_NET_HEADER_FIELD_UDP_PORT_SRC << 4) - 1)
+
+#define IOC_NET_HEADER_FIELD_IPHC_CID                       (1)
+#define IOC_NET_HEADER_FIELD_IPHC_CID_TYPE                  (IOC_NET_HEADER_FIELD_IPHC_CID << 1)
+#define IOC_NET_HEADER_FIELD_IPHC_HCINDEX                   (IOC_NET_HEADER_FIELD_IPHC_CID << 2)
+#define IOC_NET_HEADER_FIELD_IPHC_GEN                       (IOC_NET_HEADER_FIELD_IPHC_CID << 3)
+#define IOC_NET_HEADER_FIELD_IPHC_D_BIT                     (IOC_NET_HEADER_FIELD_IPHC_CID << 4)
+#define IOC_NET_HEADER_FIELD_IPHC_ALL_FIELDS                ((IOC_NET_HEADER_FIELD_IPHC_CID << 5) - 1)
+
+#define IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE           (1)
+#define IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_FLAGS          (IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 1)
+#define IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_LENGTH         (IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 2)
+#define IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_TSN            (IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 3)
+#define IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_STREAM_ID      (IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 4)
+#define IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_STREAM_SQN     (IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 5)
+#define IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_PAYLOAD_PID    (IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 6)
+#define IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_UNORDERED      (IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 7)
+#define IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_BEGGINING      (IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 8)
+#define IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_END            (IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 9)
+#define IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_ALL_FIELDS     ((IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 10) - 1)
+
+#define IOC_NET_HEADER_FIELD_L2TPv2_TYPE_BIT                (1)
+#define IOC_NET_HEADER_FIELD_L2TPv2_LENGTH_BIT              (IOC_NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 1)
+#define IOC_NET_HEADER_FIELD_L2TPv2_SEQUENCE_BIT            (IOC_NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 2)
+#define IOC_NET_HEADER_FIELD_L2TPv2_OFFSET_BIT              (IOC_NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 3)
+#define IOC_NET_HEADER_FIELD_L2TPv2_PRIORITY_BIT            (IOC_NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 4)
+#define IOC_NET_HEADER_FIELD_L2TPv2_VERSION                 (IOC_NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 5)
+#define IOC_NET_HEADER_FIELD_L2TPv2_LEN                     (IOC_NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 6)
+#define IOC_NET_HEADER_FIELD_L2TPv2_TUNNEL_ID               (IOC_NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 7)
+#define IOC_NET_HEADER_FIELD_L2TPv2_SESSION_ID              (IOC_NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 8)
+#define IOC_NET_HEADER_FIELD_L2TPv2_NS                      (IOC_NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 9)
+#define IOC_NET_HEADER_FIELD_L2TPv2_NR                      (IOC_NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 10)
+#define IOC_NET_HEADER_FIELD_L2TPv2_OFFSET_SIZE             (IOC_NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 11)
+#define IOC_NET_HEADER_FIELD_L2TPv2_FIRST_BYTE              (IOC_NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 12)
+#define IOC_NET_HEADER_FIELD_L2TPv2_ALL_FIELDS              ((IOC_NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 13) - 1)
+
+#define IOC_NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT           (1)
+#define IOC_NET_HEADER_FIELD_L2TPv3_CTRL_LENGTH_BIT         (IOC_NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT << 1)
+#define IOC_NET_HEADER_FIELD_L2TPv3_CTRL_SEQUENCE_BIT       (IOC_NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT << 2)
+#define IOC_NET_HEADER_FIELD_L2TPv3_CTRL_VERSION            (IOC_NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT << 3)
+#define IOC_NET_HEADER_FIELD_L2TPv3_CTRL_LENGTH             (IOC_NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT << 4)
+#define IOC_NET_HEADER_FIELD_L2TPv3_CTRL_CONTROL            (IOC_NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT << 5)
+#define IOC_NET_HEADER_FIELD_L2TPv3_CTRL_SENT               (IOC_NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT << 6)
+#define IOC_NET_HEADER_FIELD_L2TPv3_CTRL_RECV               (IOC_NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT << 7)
+#define IOC_NET_HEADER_FIELD_L2TPv3_CTRL_FIRST_BYTE         (IOC_NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT << 8)
+#define IOC_NET_HEADER_FIELD_L2TPv3_CTRL_ALL_FIELDS         ((IOC_NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT << 9) - 1)
+
+#define IOC_NET_HEADER_FIELD_L2TPv3_SESS_TYPE_BIT           (1)
+#define IOC_NET_HEADER_FIELD_L2TPv3_SESS_VERSION            (IOC_NET_HEADER_FIELD_L2TPv3_SESS_TYPE_BIT << 1)
+#define IOC_NET_HEADER_FIELD_L2TPv3_SESS_ID                 (IOC_NET_HEADER_FIELD_L2TPv3_SESS_TYPE_BIT << 2)
+#define IOC_NET_HEADER_FIELD_L2TPv3_SESS_COOKIE             (IOC_NET_HEADER_FIELD_L2TPv3_SESS_TYPE_BIT << 3)
+#define IOC_NET_HEADER_FIELD_L2TPv3_SESS_ALL_FIELDS         ((IOC_NET_HEADER_FIELD_L2TPv3_SESS_TYPE_BIT << 4) - 1)
+
+
+typedef uint8_t ioc_header_field_vlan_t;
+
+#define IOC_NET_HEADER_FIELD_VLAN_VPRI                      (1)
+#define IOC_NET_HEADER_FIELD_VLAN_CFI                       (IOC_NET_HEADER_FIELD_VLAN_VPRI << 1)
+#define IOC_NET_HEADER_FIELD_VLAN_VID                       (IOC_NET_HEADER_FIELD_VLAN_VPRI << 2)
+#define IOC_NET_HEADER_FIELD_VLAN_LENGTH                    (IOC_NET_HEADER_FIELD_VLAN_VPRI << 3)
+#define IOC_NET_HEADER_FIELD_VLAN_TYPE                      (IOC_NET_HEADER_FIELD_VLAN_VPRI << 4)
+#define IOC_NET_HEADER_FIELD_VLAN_TCI                       (IOC_NET_HEADER_FIELD_VLAN_VPRI << 5)
+#define IOC_NET_HEADER_FIELD_VLAN_ALL_FIELDS                ((IOC_NET_HEADER_FIELD_VLAN_VPRI << 6) - 1)
+
+
+typedef uint8_t ioc_header_field_llc_t;
+
+#define IOC_NET_HEADER_FIELD_LLC_DSAP                       (1)
+#define IOC_NET_HEADER_FIELD_LLC_SSAP                       (IOC_NET_HEADER_FIELD_LLC_DSAP << 1)
+#define IOC_NET_HEADER_FIELD_LLC_CTRL                       (IOC_NET_HEADER_FIELD_LLC_DSAP << 2)
+#define IOC_NET_HEADER_FIELD_LLC_ALL_FIELDS                 ((IOC_NET_HEADER_FIELD_LLC_DSAP << 3) - 1)
+
+#define IOC_NET_HEADER_FIELD_NLPID_NLPID                    (1)
+#define IOC_NET_HEADER_FIELD_NLPID_ALL_FIELDS               ((IOC_NET_HEADER_FIELD_NLPID_NLPID << 1) - 1)
+
+
+typedef uint8_t ioc_header_field_snap_t;
+
+#define IOC_NET_HEADER_FIELD_SNAP_OUI                       (1)
+#define IOC_NET_HEADER_FIELD_SNAP_PID                       (IOC_NET_HEADER_FIELD_SNAP_OUI << 1)
+#define IOC_NET_HEADER_FIELD_SNAP_ALL_FIELDS                ((IOC_NET_HEADER_FIELD_SNAP_OUI << 2) - 1)
+
+
+typedef uint8_t ioc_header_field_llc_snap_t;
+
+#define IOC_NET_HEADER_FIELD_LLC_SNAP_TYPE                  (1)
+#define IOC_NET_HEADER_FIELD_LLC_SNAP_ALL_FIELDS            ((IOC_NET_HEADER_FIELD_LLC_SNAP_ALL_FIELDS << 1) - 1)
+
+#define IOC_NET_HEADER_FIELD_ARP_HTYPE                      (1)
+#define IOC_NET_HEADER_FIELD_ARP_PTYPE                      (IOC_NET_HEADER_FIELD_ARP_HTYPE << 1)
+#define IOC_NET_HEADER_FIELD_ARP_HLEN                       (IOC_NET_HEADER_FIELD_ARP_HTYPE << 2)
+#define IOC_NET_HEADER_FIELD_ARP_PLEN                       (IOC_NET_HEADER_FIELD_ARP_HTYPE << 3)
+#define IOC_NET_HEADER_FIELD_ARP_OPER                       (IOC_NET_HEADER_FIELD_ARP_HTYPE << 4)
+#define IOC_NET_HEADER_FIELD_ARP_SHA                        (IOC_NET_HEADER_FIELD_ARP_HTYPE << 5)
+#define IOC_NET_HEADER_FIELD_ARP_SPA                        (IOC_NET_HEADER_FIELD_ARP_HTYPE << 6)
+#define IOC_NET_HEADER_FIELD_ARP_THA                        (IOC_NET_HEADER_FIELD_ARP_HTYPE << 7)
+#define IOC_NET_HEADER_FIELD_ARP_TPA                        (IOC_NET_HEADER_FIELD_ARP_HTYPE << 8)
+#define IOC_NET_HEADER_FIELD_ARP_ALL_FIELDS                 ((IOC_NET_HEADER_FIELD_ARP_HTYPE << 9) - 1)
+
+#define IOC_NET_HEADER_FIELD_RFC2684_LLC                    (1)
+#define IOC_NET_HEADER_FIELD_RFC2684_NLPID                  (IOC_NET_HEADER_FIELD_RFC2684_LLC << 1)
+#define IOC_NET_HEADER_FIELD_RFC2684_OUI                    (IOC_NET_HEADER_FIELD_RFC2684_LLC << 2)
+#define IOC_NET_HEADER_FIELD_RFC2684_PID                    (IOC_NET_HEADER_FIELD_RFC2684_LLC << 3)
+#define IOC_NET_HEADER_FIELD_RFC2684_VPN_OUI                (IOC_NET_HEADER_FIELD_RFC2684_LLC << 4)
+#define IOC_NET_HEADER_FIELD_RFC2684_VPN_IDX                (IOC_NET_HEADER_FIELD_RFC2684_LLC << 5)
+#define IOC_NET_HEADER_FIELD_RFC2684_ALL_FIELDS             ((IOC_NET_HEADER_FIELD_RFC2684_LLC << 6) - 1)
+
+#define IOC_NET_HEADER_FIELD_USER_DEFINED_SRCPORT           (1)
+#define IOC_NET_HEADER_FIELD_USER_DEFINED_PCDID             (IOC_NET_HEADER_FIELD_USER_DEFINED_SRCPORT << 1)
+#define IOC_NET_HEADER_FIELD_USER_DEFINED_ALL_FIELDS        ((IOC_NET_HEADER_FIELD_USER_DEFINED_SRCPORT << 2) - 1)
+
+#define IOC_NET_HEADER_FIELD_PAYLOAD_BUFFER                 (1)
+#define IOC_NET_HEADER_FIELD_PAYLOAD_SIZE                   (IOC_NET_HEADER_FIELD_PAYLOAD_BUFFER << 1)
+#define IOC_NET_HEADER_FIELD_MAX_FRM_SIZE                   (IOC_NET_HEADER_FIELD_PAYLOAD_BUFFER << 2)
+#define IOC_NET_HEADER_FIELD_MIN_FRM_SIZE                   (IOC_NET_HEADER_FIELD_PAYLOAD_BUFFER << 3)
+#define IOC_NET_HEADER_FIELD_PAYLOAD_TYPE                   (IOC_NET_HEADER_FIELD_PAYLOAD_BUFFER << 4)
+#define IOC_NET_HEADER_FIELD_FRAME_SIZE                     (IOC_NET_HEADER_FIELD_PAYLOAD_BUFFER << 5)
+#define IOC_NET_HEADER_FIELD_PAYLOAD_ALL_FIELDS             ((IOC_NET_HEADER_FIELD_PAYLOAD_BUFFER << 6) - 1)
+
+
+typedef uint8_t ioc_header_field_gre_t;
+
+#define IOC_NET_HEADER_FIELD_GRE_TYPE                       (1)
+#define IOC_NET_HEADER_FIELD_GRE_ALL_FIELDS                 ((IOC_NET_HEADER_FIELD_GRE_TYPE << 1) - 1)
+
+
+typedef uint8_t ioc_header_field_minencap_t;
+
+#define IOC_NET_HEADER_FIELD_MINENCAP_SRC_IP                (1)
+#define IOC_NET_HEADER_FIELD_MINENCAP_DST_IP                (IOC_NET_HEADER_FIELD_MINENCAP_SRC_IP << 1)
+#define IOC_NET_HEADER_FIELD_MINENCAP_TYPE                  (IOC_NET_HEADER_FIELD_MINENCAP_SRC_IP << 2)
+#define IOC_NET_HEADER_FIELD_MINENCAP_ALL_FIELDS            ((IOC_NET_HEADER_FIELD_MINENCAP_SRC_IP << 3) - 1)
+
+
+typedef uint8_t ioc_header_field_ipsec_ah_t;
+
+#define IOC_NET_HEADER_FIELD_IPSEC_AH_SPI                   (1)
+#define IOC_NET_HEADER_FIELD_IPSEC_AH_NH                    (IOC_NET_HEADER_FIELD_IPSEC_AH_SPI << 1)
+#define IOC_NET_HEADER_FIELD_IPSEC_AH_ALL_FIELDS               ((IOC_NET_HEADER_FIELD_IPSEC_AH_SPI << 2) - 1)
+
+
+typedef uint8_t ioc_header_field_ipsec_esp_t;
+
+#define IOC_NET_HEADER_FIELD_IPSEC_ESP_SPI                   (1)
+#define IOC_NET_HEADER_FIELD_IPSEC_ESP_ALL_FIELDS            ((IOC_NET_HEADER_FIELD_IPSEC_ESP_SPI << 1) - 1)
+
+
+typedef uint8_t ioc_header_field_mpls_t;
+
+#define IOC_NET_HEADER_FIELD_MPLS_LABEL_STACK               (1)
+#define IOC_NET_HEADER_FIELD_MPLS_LABEL_STACK_ALL_FIELDS    ((IOC_NET_HEADER_FIELD_MPLS_LABEL_STACK << 1) - 1)
+
+
+typedef enum {
+    e_IOC_NET_HEADER_TYPE_NONE = 0,
+    e_IOC_NET_HEADER_TYPE_PAYLOAD,
+    e_IOC_NET_HEADER_TYPE_ETH,
+    e_IOC_NET_HEADER_TYPE_VLAN,
+    e_IOC_NET_HEADER_TYPE_IPv4,
+    e_IOC_NET_HEADER_TYPE_IPv6,
+    e_IOC_NET_HEADER_TYPE_TCP,
+    e_IOC_NET_HEADER_TYPE_UDP,
+    e_IOC_NET_HEADER_TYPE_IPHC,
+    e_IOC_NET_HEADER_TYPE_SCTP,
+    e_IOC_NET_HEADER_TYPE_SCTP_CHUNK_DATA,
+    e_IOC_NET_HEADER_TYPE_PPPoE,
+    e_IOC_NET_HEADER_TYPE_PPP,
+    e_IOC_NET_HEADER_TYPE_PPPMUX,
+    e_IOC_NET_HEADER_TYPE_PPPMUX_SUBFRAME,
+    e_IOC_NET_HEADER_TYPE_L2TPv2,
+    e_IOC_NET_HEADER_TYPE_L2TPv3_CTRL,
+    e_IOC_NET_HEADER_TYPE_L2TPv3_SESS,
+    e_IOC_NET_HEADER_TYPE_LLC,
+    e_IOC_NET_HEADER_TYPE_LLC_SNAP,
+    e_IOC_NET_HEADER_TYPE_NLPID,
+    e_IOC_NET_HEADER_TYPE_SNAP,
+    e_IOC_NET_HEADER_TYPE_MPLS,
+    e_IOC_NET_HEADER_TYPE_IPSEC_AH,
+    e_IOC_NET_HEADER_TYPE_IPSEC_ESP,
+    e_IOC_NET_HEADER_TYPE_GRE,
+    e_IOC_NET_HEADER_TYPE_MINENCAP,
+    e_IOC_NET_HEADER_TYPE_DCCP,
+    e_IOC_NET_HEADER_TYPE_ICMP,
+    e_IOC_NET_HEADER_TYPE_IGMP,
+    e_IOC_NET_HEADER_TYPE_ARP,
+    e_IOC_NET_HEADER_TYPE_RFC2684,
+    e_IOC_NET_HEADER_TYPE_USER_DEFINED_L2,
+    e_IOC_NET_HEADER_TYPE_USER_DEFINED_L3,
+    e_IOC_NET_HEADER_TYPE_USER_DEFINED_L4,
+    e_IOC_NET_HEADER_TYPE_USER_DEFINED_SHIM1,
+    e_IOC_NET_HEADER_TYPE_USER_DEFINED_SHIM2,
+    e_IOC_NET_HEADER_TYPE_USER_DEFINED_SHIM3,
+    MAX_e_IOC_NET_HEADER_TYPE_COUNT
+} ioc_net_header_type;
+
+
+#endif /* __NET_IOCTLS_H */
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/procbuff_ext.h b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/procbuff_ext.h
new file mode 100644
index 0000000..e4f9898
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/procbuff_ext.h
@@ -0,0 +1,58 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**************************************************************************//**
+ @File          procbuff_ext.h
+
+ @Author        Eran Liberty
+
+ @Description   TBD
+*//***************************************************************************/
+#ifndef __PROCBUFF_EXT_H
+#define __PROCBUFF_EXT_H
+
+#include "std_ext.h"
+#include "xx_ext.h"
+
+
+#define MAX_LINE_SIZE       1024
+
+
+t_Handle    ProcBuff_Init (char *buffer,char **start,int offset,int length, int *eof);
+void        ProcBuff_Free (t_Handle h_ProcBuff);
+
+void        ProcBuff_Write (t_Handle h_ProcBuff,const char *fmt, ...);
+int         ProcBuff_GetNumOfWrittenChars (t_Handle h_ProcBuff);
+void        ProcBuff_Done  (t_Handle h_ProcBuff);
+
+
+#endif /* __PROCBUFF_EXT_H */
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/system/platform_ext.h b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/system/platform_ext.h
new file mode 100644
index 0000000..d25f3d7
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/system/platform_ext.h
@@ -0,0 +1,126 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/******************************************************************************
+
+ @File          platform_ext.h
+
+ @Description   Prototypes, externals and typedefs for platform routines
+****************************************************************************/
+#ifndef __PLATFORM_EXT_H
+#define __PLATFORM_EXT_H
+
+#include "std_ext.h"
+#include "sys_ext.h"
+
+
+/**************************************************************************//**
+ @Group         platform_grp PLATFORM Application Programming Interface
+
+ @Description   Generic Platform API, that must be implemented by each
+                specific platform.
+
+ @{
+*//***************************************************************************/
+
+#define MAX_CHIP_NAME_LEN   9   /* (including null character) */
+
+
+/**************************************************************************//**
+ @Description   Cache Operation Mode
+*//***************************************************************************/
+typedef enum e_CacheMode
+{
+    e_CACHE_MODE_DISABLED       = 0x00000000,   /**< Cache is disabled */
+    e_CACHE_MODE_DATA_ONLY      = 0x00000001,   /**< Cache is enabled for data only */
+    e_CACHE_MODE_INST_ONLY      = 0x00000002,   /**< Cache is enabled for instructions only */
+    e_CACHE_MODE_DATA_AND_INST  = 0x00000003    /**< Cache is enabled for data and instructions */
+
+} e_CacheMode;
+
+/**************************************************************************//**
+ @Description   Memory Partition Identifiers
+
+                Note that not all memory partitions are supported by all
+                platforms. Every platform may select which memory partitions
+                to support.
+*//***************************************************************************/
+typedef enum e_MemoryPartitionId
+{
+    e_MEM_1ST_DDR_CACHEABLE     = 1, /**< Primary DDR cacheable memory partition */
+    e_MEM_1ST_DDR_NON_CACHEABLE = 2, /**< Primary DDR non-cacheable memory partition */
+    e_MEM_2ND_DDR_CACHEABLE     = 3, /**< Secondary DDR cacheable memory partition */
+    e_MEM_2ND_DDR_NON_CACHEABLE = 4, /**< Secondary DDR non-cacheable memory partition */
+    e_MEM_SDRAM                 = 5, /**< SDRAM non-cacheable memory partition */
+    e_MEM_L2_SRAM               = 6, /**< L2 SRAM cacheable memory partition */
+    e_MEM_MURAM_LOW             = 7, /**< Low-range MURAM partition */
+    e_MEM_MURAM                 = 8  /**< Full-range MURAM partition */
+
+} e_MemoryPartitionId;
+
+/**************************************************************************//**
+ @Description   Chip Type and Revision Information Structure
+*//***************************************************************************/
+typedef struct t_ChipRevInfo
+{
+    char            chipName[MAX_CHIP_NAME_LEN];
+                    /**< Chip name (e.g. "P4080") */
+    uint16_t        revMajor;
+                    /**< Major chip revision */
+    uint16_t        revMinor;
+                    /**< Minor chip revision */
+} t_ChipRevInfo;
+
+
+/**************************************************************************//**
+ @Description   Platform configuration parameters structure.
+
+                This structure must be specifically defined by each platform.
+*//***************************************************************************/
+struct t_PlatformParam;
+
+
+t_Handle PLATFORM_Init(struct t_PlatformParam *p_PlatformParam);
+
+t_Error  PLATFORM_Free(t_Handle h_Platform);
+
+
+t_Error  PLATFORM_GetChipRevInfo(t_Handle h_Platform, t_ChipRevInfo *p_ChipRevInfo);
+
+uint32_t PLATFORM_GetMemoryMappedModuleBase(t_Handle    h_Platform,
+                                            e_SysModule module,
+                                            uint32_t    id);
+
+/** @} */ /* end of platform_grp */
+
+
+#endif /* __PLATFORM_EXT_H */
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/system/platform_p4080_ds_ext.h b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/system/platform_p4080_ds_ext.h
new file mode 100644
index 0000000..a611e48
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/system/platform_p4080_ds_ext.h
@@ -0,0 +1,64 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/******************************************************************************
+
+ @File          platform_p4080_ds_ext.h
+
+ @Description   Prototypes, externals and typedefs for platform routines
+****************************************************************************/
+#ifndef __PLATFORM_P4080_DS_EXT_H
+#define __PLATFORM_P4080_DS_EXT_H
+
+#include "std_ext.h"
+#include "platform_ext.h"
+
+
+/**************************************************************************//**
+ @Group         platform_grp PLATFORM Application Programming Interface
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description   P4080-DS Platform configuration parameters structure
+*//***************************************************************************/
+typedef struct t_PlatformParam
+{
+    e_CacheMode             l1CacheMode;
+    e_CacheMode             l2CacheMode;
+} t_PlatformParam;
+
+/** @} */ /* end of platform_grp */
+
+
+#endif /* __PLATFORM_P4080_DS_EXT_H */
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/system/sys_ext.h b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/system/sys_ext.h
new file mode 100644
index 0000000..29d6d74
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/system/sys_ext.h
@@ -0,0 +1,290 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __SYS_EXT_H
+#define __SYS_EXT_H
+
+#include "std_ext.h"
+
+
+typedef enum e_SysModule
+{
+    e_SYS_MODULE_NONE = 0,
+
+    /* ----------- Modules ----------- */
+    e_SYS_MODULE_PLATFORM,
+
+    /* Must close the sub-modules list */
+    e_SYS_SUBMODULE_DUMMY_LAST
+
+} e_SysModule;
+
+
+typedef struct t_SysObjectDescriptor
+{
+    e_SysModule module;
+    uint32_t    id;
+    void        *p_Settings;
+
+} t_SysObjectDescriptor;
+
+
+#define SYS_MAX_ADV_CONFIG_ARGS      4
+
+typedef struct t_SysObjectAdvConfigEntry
+{
+    void        *p_Function;
+    uint32_t    args[SYS_MAX_ADV_CONFIG_ARGS]; //@@@@ uint64_t (CW bug) ?
+} t_SysObjectAdvConfigEntry;
+
+
+#define ADV_CONFIG_DONE         NULL, { 0 }
+#define ADV_CONFIG_NONE         (t_SysObjectAdvConfigEntry[]){ ADV_CONFIG_DONE }
+
+
+#define PARAMS(_num, _params)   ADV_CONFIG_PARAMS_##_num _params
+#define NO_PARAMS
+
+#define ADV_CONFIG_PARAMS_1(_type) \
+    , (_type)p_Entry->args[0]
+
+#define ADV_CONFIG_PARAMS_2(_type0, _type1) \
+    , (_type0)p_Entry->args[0], (_type1)p_Entry->args[1]
+
+#define ADV_CONFIG_PARAMS_3(_type0, _type1, _type2) \
+    , (_type0)p_Entry->args[0], (_type1)p_Entry->args[1], (_type2)p_Entry->args[2]
+
+#define ADV_CONFIG_PARAMS_4(_type0, _type1, _type2, _type3) \
+    , (_type0)p_Entry->args[0], (_type1)p_Entry->args[1], (_type2)p_Entry->args[2], (_type3)p_Entry->args[3]
+
+
+#define SET_ADV_CONFIG_ARGS_1(_arg0)        \
+    p_Entry->args[0] = (uint32_t)(_arg0);   \
+
+#define SET_ADV_CONFIG_ARGS_2(_arg0, _arg1) \
+    p_Entry->args[0] = (uint32_t)(_arg0);   \
+    p_Entry->args[1] = (uint32_t)(_arg1);   \
+
+#define SET_ADV_CONFIG_ARGS_3(_arg0, _arg1, _arg2)  \
+    p_Entry->args[0] = (uint32_t)(_arg0);           \
+    p_Entry->args[1] = (uint32_t)(_arg1);           \
+    p_Entry->args[2] = (uint32_t)(_arg2);           \
+
+#define SET_ADV_CONFIG_ARGS_4(_arg0, _arg1, _arg2, _arg3)   \
+    p_Entry->args[0] = (uint32_t)(_arg0);                   \
+    p_Entry->args[1] = (uint32_t)(_arg1);                   \
+    p_Entry->args[2] = (uint32_t)(_arg2);                   \
+    p_Entry->args[3] = (uint32_t)(_arg3);                   \
+
+#define ARGS(_num, _params) SET_ADV_CONFIG_ARGS_##_num _params
+#define NO_ARGS
+
+#define ADD_ADV_CONFIG(_func, _param)       \
+    do {                                    \
+        if (i<max){                         \
+            p_Entry = &p_Entrys[i];         \
+            p_Entry->p_Function = _func;    \
+            _param                          \
+            i++;                            \
+        }                                   \
+        else                                \
+            REPORT_ERROR(MINOR, E_INVALID_VALUE, ("number of advance-configuration exceeded!!!"));\
+    } while (0)
+
+#define ADD_ADV_CONFIG_START(_p_Entries, _maxEntries)                   \
+    {                                                                   \
+        t_SysObjectAdvConfigEntry   *p_Entry;                           \
+        t_SysObjectAdvConfigEntry   *p_Entrys = (_p_Entries);           \
+        int                         i=0, max = (_maxEntries);           \
+        for (; i<FM_MAX_NUM_OF_ADV_SETTINGS;i++)                        \
+            if (!p_LnxWrpFmPortDev->settings.advConfig[i].p_Function)   \
+                break;
+
+#define ADD_ADV_CONFIG_END \
+    }
+
+#define ADV_CONFIG_CHECK_START(_p_Entry)                        \
+    {                                                           \
+        t_SysObjectAdvConfigEntry   *p_Entry = _p_Entry;        \
+        t_Error                     errCode;                    \
+
+#define ADV_CONFIG_CHECK(_handle, _func, _params)               \
+        if (p_Entry->p_Function == _func)                       \
+        {                                                       \
+            errCode = _func(_handle _params);                   \
+        } else
+
+#define ADV_CONFIG_CHECK_END                                    \
+        {                                                       \
+            REPORT_ERROR(MAJOR, E_INVALID_SELECTION,            \
+                         ("Advanced configuration routine"));   \
+            return NULL;                                        \
+        }                                                       \
+        if (errCode != E_OK)                                    \
+        {                                                       \
+            REPORT_ERROR(MAJOR, errCode, NO_MSG);               \
+            return NULL;                                        \
+        }                                                       \
+    }
+
+
+
+#define CAST_ID_TO_HANDLE(_id)      ((t_Handle)(_id))
+#define CAST_HANDLE_TO_ID(_h)       ((uint32_t)(_h))
+
+
+#define SYS_MAX_TEST_GROUP_NAME_LENGTH      14
+#define SYS_MAX_TEST_DESCRIPTION_LENGTH     64
+
+typedef struct t_SysTestDescriptor
+{
+    char        testGroup[SYS_MAX_TEST_GROUP_NAME_LENGTH];
+    uint16_t    testId;
+    char        description[SYS_MAX_TEST_DESCRIPTION_LENGTH];
+    t_Error     (*f_RunTest)(void *p_TestParam);
+    void        (*f_KillTest)(void);
+    void        *p_TestParam;
+
+} t_SysTestDescriptor;
+
+
+typedef struct t_SysRuntimeLayout
+{
+    t_SysObjectDescriptor   **p_LogicalObjects;
+    t_SysTestDescriptor     **p_TestDescriptors;
+
+} t_SysRuntimeLayout;
+
+typedef struct t_SysPeripheralLayout
+{
+    t_SysObjectDescriptor   **p_PeripheralObjects;
+    t_SysRuntimeLayout      *p_RuntimeLayouts;
+
+} t_SysPeripheralLayout;
+
+typedef struct t_SysSystemLayout
+{
+    t_SysObjectDescriptor   **p_SystemObjects;
+    t_SysPeripheralLayout   *p_PeripheralLayouts;
+
+} t_SysSystemLayout;
+
+typedef struct t_SysUseCaseLayout
+{
+    t_SysObjectDescriptor   *p_PlatformObject;
+    t_SysSystemLayout       *p_SystemLayouts;
+
+} t_SysUseCaseLayout;
+
+
+
+t_SysUseCaseLayout * USER_BuildLayout(int argc, char *argv[]);
+
+void USER_FreeLayout(t_SysUseCaseLayout *p_UseCaseLayout);
+
+
+
+#define SYS_SYSTEM_OBJECTS(...)     (t_SysObjectDescriptor*[]){ __VA_ARGS__, NULL }
+#define SYS_PERIPHERAL_OBJECTS(...) (t_SysObjectDescriptor*[]){ __VA_ARGS__, NULL }
+#define SYS_LOGICAL_OBJECTS(...)    (t_SysObjectDescriptor*[]){ __VA_ARGS__, NULL }
+#define SYS_TEST_DESCRIPTORS(...)   (t_SysTestDescriptor*[]){ __VA_ARGS__, NULL }
+
+
+#define SYS_BEGIN_SYSTEM_LAYOUTS \
+        (t_SysSystemLayout[]){
+#define SYS_END_SYSTEM_LAYOUTS \
+        , { NULL, NULL } }
+
+#define SYS_BEGIN_PERIPHERAL_LAYOUTS \
+        (t_SysPeripheralLayout[]){
+#define SYS_END_PERIPHERAL_LAYOUTS \
+        , { NULL, NULL } }
+
+#define SYS_BEGIN_RUNTIME_LAYOUTS \
+        (t_SysRuntimeLayout[]){
+#define SYS_END_RUNTIME_LAYOUTS \
+        , { NULL, NULL } }
+
+
+
+typedef t_Handle (t_SysModuleInitFuncNoParams)(void);
+typedef t_Handle (t_SysModuleInitFuncWithParams)(void *p_ModuleParams);
+
+typedef struct t_SysRegistryEntry
+{
+    e_SysModule     module;
+    bool            noInitParams;
+    union
+    {
+        t_SysModuleInitFuncNoParams     *f_InitNoParams;
+        t_SysModuleInitFuncWithParams   *f_InitWithParams;
+    };
+    t_Error         (*f_Free)(t_Handle h_Module);
+
+} t_SysRegistryEntry;
+
+
+#define SYS_REGISTER_MODULE_VOID_PARAM(mod, initFunc, freeFunc) \
+    {(mod), TRUE,  .f_InitNoParams   = (initFunc), (freeFunc) }
+
+#define SYS_REGISTER_MODULE_WITH_PARAM(mod, initFunc, freeFunc) \
+    {(mod), FALSE, .f_InitWithParams = (t_SysModuleInitFuncWithParams *)(initFunc), (freeFunc) }
+
+#define SYS_REGISTER_MODULE_DONE \
+    {e_SYS_MODULE_NONE, TRUE, NULL, NULL }
+
+typedef struct t_SysSubModuleRegisterParam
+{
+    e_SysModule owner;
+    uint8_t     numOfSubModules;
+    e_SysModule *p_SubModules;
+    t_Error     (*f_InitSubModule)(t_Handle h_Module, t_SysObjectDescriptor *p_SubModuleDesc);
+    t_Error     (*f_FreeSubModule)(t_Handle h_Module, e_SysModule subModule, uint32_t id);
+    t_Handle    (*f_GetSubModule)(t_Handle h_Module, e_SysModule subModule, uint32_t id);
+
+} t_SysSubModuleRegisterParam;
+
+
+typedef struct t_SysSubModuleUnregisterParam
+{
+    e_SysModule owner;
+    uint8_t     numOfSubModules;
+    e_SysModule *p_SubModules;
+
+} t_SysSubModuleUnregisterParam;
+
+
+void SYS_Init(void);
+void SYS_Free(void);
+
+
+#endif /* __SYS_EXT_H */
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/system/sys_io_ext.h b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/system/sys_io_ext.h
new file mode 100644
index 0000000..6ba992e
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/system/sys_io_ext.h
@@ -0,0 +1,46 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __SYS_IO_EXT_H
+#define __SYS_IO_EXT_H
+
+#include "std_ext.h"
+#include "error_ext.h"
+
+
+t_Error  SYS_RegisterIoMap   (uint64_t virtAddr, uint64_t physAddr, uint32_t size);
+t_Error  SYS_UnregisterIoMap (uint64_t virtAddr);
+uint64_t SYS_PhysToVirt      (uint64_t addr);
+uint64_t SYS_VirtToPhys      (uint64_t addr);
+
+
+#endif /* __SYS_IO_EXT_H */
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/types_linux.h b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/types_linux.h
new file mode 100644
index 0000000..afb6906
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/types_linux.h
@@ -0,0 +1,197 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __TYPES_LINUX_H__
+#define __TYPES_LINUX_H__
+
+#include <linux/version.h>
+
+#if defined(CONFIG_MODVERSIONS) && !defined(MODVERSIONS)
+#define MODVERSIONS
+#endif
+#ifdef MODVERSIONS
+#include <config/modversions.h>
+#endif /* MODVERSIONS */
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,11)
+    #error "This kernel is probably not supported!!!"
+#elif   (!((LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,19)) || \
+           (LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,27)) || \
+           (LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,30))))
+    #warning "This kernel is probably not supported!!! You may need to add some fixes."
+#endif    /* LINUX_VERSION_CODE */
+
+
+typedef float               float_t;    /* Single precision floating point  */
+typedef double              double_t;   /* Double precision floating point  */
+
+
+#define _Packed
+#define _PackedType __attribute__ ((packed))
+
+#define UINT8_MAX   0xFF
+#define UINT8_MIN   0
+#define UINT16_MAX  0xFFFF
+#define UINT16_MIN  0
+#define UINT32_MAX  0xFFFFFFFF
+#define UINT32_MIN  0
+#define UINT64_MAX  0xFFFFFFFFFFFFFFFFLL
+#define UINT64_MIN  0
+#define INT8_MAX    0x7F
+#define INT8_MIN    0x80
+#define INT16_MAX   0x7FFF
+#define INT16_MIN   0x8000
+#define INT32_MAX   0x7FFFFFFF
+#define INT32_MIN   0x80000000
+#define INT64_MAX   0x7FFFFFFFFFFFFFFFLL
+#define INT64_MIN   0x8000000000000000LL
+
+#define ON          1
+#define OFF         0
+
+#define FALSE       false
+#define TRUE        true
+
+
+/************************/
+/* memory access macros */
+/************************/
+#define GET_UINT8(arg)              *(volatile uint8_t *)(&(arg))
+#define GET_UINT16(arg)             *(volatile uint16_t*)(&(arg))
+#define GET_UINT32(arg)             *(volatile uint32_t*)(&(arg))
+#define GET_UINT64(arg)             *(volatile uint64_t*)(&(arg))
+
+#ifdef VERBOSE_WRITE
+#define WRITE_UINT8(arg, data)  \
+    do { XX_Print("ADDR: 0x%08x, VAL: 0x%02x\r\n",    (uint32_t)&(arg), (data)); *(volatile uint8_t *)(&(arg)) = (data); } while (0)
+#define WRITE_UINT16(arg, data) \
+    do { XX_Print("ADDR: 0x%08x, VAL: 0x%04x\r\n",    (uint32_t)&(arg), (data)); *(volatile uint16_t*)(&(arg)) = (data); } while (0)
+#define WRITE_UINT32(arg, data) \
+    do { XX_Print("ADDR: 0x%08x, VAL: 0x%08x\r\n",    (uint32_t)&(arg), (data)); *(volatile uint32_t*)(&(arg)) = (data); } while (0)
+#define WRITE_UINT64(arg, data) \
+    do { XX_Print("ADDR: 0x%08x, VAL: 0x%016llx\r\n", (uint32_t)&(arg), (data)); *(volatile uint64_t*)(&(arg)) = (data); } while (0)
+
+#else  /* not VERBOSE_WRITE */
+#define WRITE_UINT8(arg, data)      *(volatile uint8_t *)(&(arg)) = (data)
+#define WRITE_UINT16(arg, data)     *(volatile uint16_t*)(&(arg)) = (data)
+#define WRITE_UINT32(arg, data)     *(volatile uint32_t*)(&(arg)) = (data)
+#define WRITE_UINT64(arg, data)     *(volatile uint64_t*)(&(arg)) = (data)
+#endif /* not VERBOSE_WRITE */
+
+
+/*****************************************************************************/
+/*                      General stuff                                        */
+/*****************************************************************************/
+#ifdef ARRAY_SIZE
+#undef ARRAY_SIZE
+#endif /* ARRAY_SIZE */
+
+#ifdef MAJOR
+#undef MAJOR
+#endif /* MAJOR */
+
+#ifdef MINOR
+#undef MINOR
+#endif /* MINOR */
+
+#ifdef QE_SIZEOF_BD
+#undef QE_SIZEOF_BD
+#endif /* QE_SIZEOF_BD */
+
+#ifdef BD_BUFFER_CLEAR
+#undef BD_BUFFER_CLEAR
+#endif /* BD_BUFFER_CLEAR */
+
+#ifdef BD_BUFFER
+#undef BD_BUFFER
+#endif /* BD_BUFFER */
+
+#ifdef BD_STATUS_AND_LENGTH_SET
+#undef BD_STATUS_AND_LENGTH_SET
+#endif /* BD_STATUS_AND_LENGTH_SET */
+
+#ifdef BD_STATUS_AND_LENGTH
+#undef BD_STATUS_AND_LENGTH
+#endif /* BD_STATUS_AND_LENGTH */
+
+#ifdef BD_BUFFER_ARG
+#undef BD_BUFFER_ARG
+#endif /* BD_BUFFER_ARG */
+
+#ifdef BD_GET_NEXT
+#undef BD_GET_NEXT
+#endif /* BD_GET_NEXT */
+
+#ifdef QE_SDEBCR_BA_MASK
+#undef QE_SDEBCR_BA_MASK
+#endif /* QE_SDEBCR_BA_MASK */
+
+#ifdef BD_BUFFER_SET
+#undef BD_BUFFER_SET
+#endif /* BD_BUFFER_SET */
+
+#ifdef UPGCR_PROTOCOL
+#undef UPGCR_PROTOCOL
+#endif /* UPGCR_PROTOCOL */
+
+#ifdef UPGCR_TMS
+#undef UPGCR_TMS
+#endif /* UPGCR_TMS */
+
+#ifdef UPGCR_RMS
+#undef UPGCR_RMS
+#endif /* UPGCR_RMS */
+
+#ifdef UPGCR_ADDR
+#undef UPGCR_ADDR
+#endif /* UPGCR_ADDR */
+
+#ifdef UPGCR_DIAG
+#undef UPGCR_DIAG
+#endif /* UPGCR_DIAG */
+
+#ifdef PARAMS
+#undef PARAMS
+#endif /* PARAMS */
+
+#ifdef NO_IRQ
+#undef NO_IRQ
+#endif /* NO_IRQ */
+
+#define PRINT_LINE   XX_Print("%s:\n %s [%d]\n",__FILE__,__FUNCTION__,__LINE__);
+
+
+#endif /* __TYPES_LINUX_H__ */
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/wrappers/Peripherals/fsl_fman.h b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/wrappers/Peripherals/fsl_fman.h
new file mode 100644
index 0000000..b955a58
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/wrappers/Peripherals/fsl_fman.h
@@ -0,0 +1,254 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/******************************************************************************
+ @File          fsl_fman.h
+
+ @Description   Linux internal kernel API
+*//***************************************************************************/
+
+#ifndef __FSL_FMAN_H
+#define __FSL_FMAN_H
+
+#include <linux/types.h>
+#include <linux/device.h>   /* struct device */
+#include <linux/fsl_qman.h> /* struct qman_fq */
+
+
+/**************************************************************************//**
+ @Group         FM_LnxKern_grp Frame Manager Linux wrapper API
+
+ @Description   FM API functions, definitions and enums.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Group         FM_LnxKern_ctrl_grp Control Unit
+
+ @Description   Control Unit
+
+                Internal Kernel Control Unit API
+ @{
+*//***************************************************************************/
+
+/*****************************************************************************/
+/*                  Internal Linux kernel routines                           */
+/*****************************************************************************/
+
+#define FM_PORT_MAX_NUM_OF_EXT_POOLS        8           /**< Max number of buffer pools allowed per port */
+
+
+/**************************************************************************//**
+ @Description   A structure ..,
+*//***************************************************************************/
+struct fm;
+
+/**************************************************************************//**
+ @Description   A structure ..,
+*//***************************************************************************/
+struct fm_port;
+
+typedef int (*alloc_pcd_fqids)(struct device    *dev,
+                               uint32_t         num,
+                               uint8_t          alignment,
+                               uint32_t         *base_fqid);
+
+struct fm_port_pcd_param {
+    alloc_pcd_fqids         cb;
+    struct device           *dev;
+};
+
+/**************************************************************************//**
+ @Description   A structure of information about each of the external
+                buffer pools used by the port,
+*//***************************************************************************/
+struct fm_port_pool_param {
+    uint8_t                 id;                 /**< External buffer pool id */
+    uint16_t                size;               /**< External buffer pool buffer size */
+};
+
+/**************************************************************************//**
+ @Description   structure for additional Rx port parameters
+*//***************************************************************************/
+struct fm_port_rx_params {
+    uint32_t                    errq;               /**< Error Queue Id. */
+    uint32_t                    defq;               /**< Default Queue Id.  */
+    uint8_t                     num_pools;          /**< Number of pools use by this port */
+    struct fm_port_pool_param   pool_param[FM_PORT_MAX_NUM_OF_EXT_POOLS];
+                                                    /**< Parameters for each pool */
+    uint8_t                     priv_data_size;     /**< Area that user may save for his own need (E.g. save the SKB) */
+    bool                        parse_results;      /**< Whether to have the parser-results in the Received buffer */
+};
+
+/**************************************************************************//**
+ @Description   structure for additional non-Rx port parameters
+*//***************************************************************************/
+struct fm_port_non_rx_params {
+    uint32_t                errq;               /**< Error Queue Id. */
+    uint32_t                defq;               /**< For Tx and HC - Default Confirmation queue,
+                                                     0 means no Tx confirmation for processed
+                                                     frames. For OP - default Rx queue. */
+    uint8_t                 priv_data_size;     /**< Area that user may save for his own need (E.g. save the SKB) */
+    bool                    parse_results;      /**< Whether to put the parser-results in the Transmitted buffer */
+};
+
+
+/**************************************************************************//**
+ @Function      fm_bind
+
+ @Description   Bind to a specific FM device.
+
+ @Param[in]     fm_dev  - the OF handle of the FM device.
+
+ @Return        A handle of the FM device.
+
+ @Cautions      Allowed only after the port was created.
+*//***************************************************************************/
+struct fm * fm_bind (struct device *fm_dev);
+
+/**************************************************************************//**
+ @Function      fm_unbind
+
+ @Description   Un-bind from a specific FM device.
+
+ @Param[in]     fm      - A handle of the FM device.
+
+ @Cautions      Allowed only after the port was created.
+*//***************************************************************************/
+void fm_unbind(struct fm *fm);
+
+void * fm_get_handle(struct fm *fm);
+struct resource * fm_get_mem_region(struct fm *fm);
+
+/**************************************************************************//**
+ @Function      fm_port_bind
+
+ @Description   Bind to a specific FM-port device (may be Rx or Tx port).
+
+ @Param[in]     fm_port_dev - the OF handle of the FM port device.
+
+ @Return        A handle of the FM port device.
+
+ @Cautions      Allowed only after the port was created.
+*//***************************************************************************/
+struct fm_port * fm_port_bind (struct device *fm_port_dev);
+
+/**************************************************************************//**
+ @Function      fm_port_unbind
+
+ @Description   Un-bind from a specific FM-port device (may be Rx or Tx port).
+
+ @Param[in]     port        - A handle of the FM port device.
+
+ @Cautions      Allowed only after the port was created.
+*//***************************************************************************/
+void fm_port_unbind(struct fm_port *port);
+
+/**************************************************************************//**
+ @Function      fm_set_rx_port_params
+
+ @Description   Configure parameters for a specific Rx FM-port device.
+
+ @Param[in]     port        - A handle of the FM port device.
+ @Param[in]     params      - Rx port parameters
+
+ @Cautions      Allowed only after the port is binded.
+*//***************************************************************************/
+void fm_set_rx_port_params(struct fm_port *port, struct fm_port_rx_params *params);
+
+/**************************************************************************//**
+ @Function      fm_port_pcd_bind
+
+ @Description   Bind as a listener on a port PCD.
+
+ @Param[in]     port        - A handle of the FM port device.
+ @Param[in]     params      - PCD port parameters
+
+ @Cautions      Allowed only after the port is binded.
+*//***************************************************************************/
+void fm_port_pcd_bind (struct fm_port *port, struct fm_port_pcd_param *params);
+
+/**************************************************************************//**
+ @Function      fm_get_tx_port_channel
+
+ @Description   Get qman-channel number for this Tx port.
+
+ @Param[in]     port        - A handle of the FM port device.
+
+ @Return        qman-channel number for this Tx port.
+
+ @Cautions      Allowed only after the port is binded.
+*//***************************************************************************/
+int fm_get_tx_port_channel(struct fm_port *port);
+
+/**************************************************************************//**
+ @Function      fm_set_tx_port_params
+
+ @Description   Configure parameters for a specific Tx FM-port device
+
+ @Param[in]     port        - A handle of the FM port device.
+ @Param[in]     params      - Tx port parameters
+
+ @Cautions      Allowed only after the port is binded.
+*//***************************************************************************/
+void fm_set_tx_port_params(struct fm_port *port, struct fm_port_non_rx_params *params);
+
+/**************************************************************************//**
+ @Function      fm_port_enable
+
+ @Description   Enable specific FM-port device (may be Rx or Tx port).
+
+ @Param[in]     port        - A handle of the FM port device.
+
+ @Cautions      Allowed only the port is initialized.
+*//***************************************************************************/
+int fm_port_enable (struct fm_port *port);
+
+/**************************************************************************//**
+ @Function      fm_port_disable
+
+ @Description   Disable specific FM-port device (may be Rx or Tx port).
+
+ @Param[in]     port        - A handle of the FM port device.
+
+ @Cautions      Allowed only the port is initialized.
+*//***************************************************************************/
+void fm_port_disable(struct fm_port *port);
+
+void * fm_port_get_handle(struct fm_port *port);
+
+/** @} */ /* end of FM_LnxKern_ctrl_grp group */
+/** @} */ /* end of FM_LnxKern_grp group */
+
+
+#endif /* __FSL_FMAN_H */
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/wrappers/Peripherals/fsl_fman_test.h b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/wrappers/Peripherals/fsl_fman_test.h
new file mode 100644
index 0000000..cc8393c
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/wrappers/Peripherals/fsl_fman_test.h
@@ -0,0 +1,68 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/******************************************************************************
+ @File          fsl_fman_test.h
+
+ @Description
+*//***************************************************************************/
+
+#ifndef __FSL_FMAN_TEST_H
+#define __FSL_FMAN_TEST_H
+
+#include <linux/types.h>
+
+
+#define FMT_RX_ERR_Q    0xffffffff
+#define FMT_RX_DFLT_Q   0xfffffffe
+#define FMT_TX_ERR_Q    0xfffffffd
+#define FMT_TX_CONF_Q   0xfffffffc
+
+
+/**************************************************************************//**
+ @Function      is_fman_test
+
+ @Description   Check if arriving frame belong to the test
+
+ @Param[in]     void * fd,  uint32_t fqid, uint8_t *buffer , uint32_t size
+
+ @Param[out]    true/false
+
+ @Cautions      Allowed only the port is initialized.
+*//***************************************************************************/
+bool is_fman_test (void     *mac_dev,
+                   uint32_t queueId,
+                   uint8_t  *buffer,
+                   uint32_t size);
+
+
+#endif /* __FSL_FMAN_TEST_H */
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/wrappers/Peripherals/lnxwrp_fm_ext.h b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/wrappers/Peripherals/lnxwrp_fm_ext.h
new file mode 100644
index 0000000..65d80a8
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/wrappers/Peripherals/lnxwrp_fm_ext.h
@@ -0,0 +1,161 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/******************************************************************************
+ @File          lnxwrp_fm_ext.h
+
+ @Description   TBD
+*//***************************************************************************/
+
+#ifndef __LNXWRP_FM_EXT_H
+#define __LNXWRP_FM_EXT_H
+
+#include "std_ext.h"
+#include "sys_ext.h"
+#include "fm_ext.h"
+#include "fm_muram_ext.h"
+#include "fm_pcd_ext.h"
+#include "fm_port_ext.h"
+#include "fm_mac_ext.h"
+
+
+/**************************************************************************//**
+ @Group         FM_LnxKern_grp Frame Manager Linux wrapper API
+
+ @Description   FM API functions, definitions and enums.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Group         FM_LnxKern_init_grp Initialization Unit
+
+ @Description   Initialization Unit
+
+                Initialization Flow:
+                Initialization of the FM Module will be carried out by the Linux
+                kernel according to the following sequence:
+                a. Calling the initialization routine with no parameters.
+                b. The driver will register to the Device-Tree.
+                c. The Linux Device-Tree will initiate a call to the driver for
+                   initialization.
+                d. The driver will read the appropriate information from the Device-Tree
+                e. [Optional] Calling the advance initialization routines to change
+                   driver's defaults.
+                f. Initialization of the device will be automatically upon using it.
+
+ @{
+*//***************************************************************************/
+
+typedef struct t_WrpFmDevSettings
+{
+    t_FmParams                  param;
+    t_SysObjectAdvConfigEntry   *advConfig;
+} t_WrpFmDevSettings;
+
+typedef struct t_WrpFmPcdDevSettings
+{
+    t_FmPcdParams               param;
+    t_SysObjectAdvConfigEntry   *advConfig;
+} t_WrpFmPcdDevSettings;
+
+typedef struct t_WrpFmPortDevSettings
+{
+    t_FmPortParams              param;
+    t_SysObjectAdvConfigEntry   *advConfig;
+} t_WrpFmPortDevSettings;
+
+typedef struct t_WrpFmMacDevSettings
+{
+    t_FmMacParams               param;
+    t_SysObjectAdvConfigEntry   *advConfig;
+} t_WrpFmMacDevSettings;
+
+
+/**************************************************************************//**
+ @Function      LNXWRP_FM_Init
+
+ @Description   Initialize the FM linux wrapper.
+
+ @Return        A handle (descriptor) of the newly created FM Linux wrapper
+                structure.
+*//***************************************************************************/
+t_Handle LNXWRP_FM_Init(void);
+
+/**************************************************************************//**
+ @Function      LNXWRP_FM_Free
+
+ @Description   Free the FM linux wrapper.
+
+ @Param[in]     h_LnxWrpFm   - A handle to the FM linux wrapper.
+
+ @Return        E_OK on success; Error code otherwise.
+*//***************************************************************************/
+t_Error  LNXWRP_FM_Free(t_Handle h_LnxWrpFm);
+
+/**************************************************************************//**
+ @Function      LNXWRP_FM_GetMacHandle
+
+ @Description   Get the FM-MAC LLD handle from the FM linux wrapper.
+
+ @Param[in]     h_LnxWrpFm   - A handle to the FM linux wrapper.
+ @Param[in]     fmId         - Index of the FM device to get the MAC handle from.
+ @Param[in]     macId        - Index of the mac handle.
+
+ @Return        A handle of the LLD compressor.
+*//***************************************************************************/
+t_Handle LNXWRP_FM_GetMacHandle(t_Handle h_LnxWrpFm, uint8_t fmId, uint8_t macId);
+
+#ifdef CONFIG_FSL_FMAN_TEST
+t_Handle LNXWRP_FM_TEST_Init(void);
+t_Error  LNXWRP_FM_TEST_Free(t_Handle h_FmTestLnxWrp);
+#endif /* CONFIG_FSL_FMAN_TEST */
+
+/** @} */ /* end of FM_LnxKern_init_grp group */
+
+
+/**************************************************************************//**
+ @Group         FM_LnxKern_ctrl_grp Control Unit
+
+ @Description   Control Unit
+
+                TBD
+ @{
+*//***************************************************************************/
+
+#include "fsl_fman.h"
+
+/** @} */ /* end of FM_LnxKern_ctrl_grp group */
+/** @} */ /* end of FM_LnxKern_grp group */
+
+
+#endif /* __LNXWRP_FM_EXT_H */
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/modules/integrations/P4080/FM/Makefile b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/modules/integrations/P4080/FM/Makefile
new file mode 100644
index 0000000..07f8c41
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/modules/integrations/P4080/FM/Makefile
@@ -0,0 +1,11 @@
+#
+# Makefile for the Freescale Ethernet controllers
+#
+EXTRA_CFLAGS           += -DVERSION=\"\"
+#
+#Include netcomm SW specific definitions
+include $(srctree)/drivers/net/dpa/NetCommSw/ncsw_config.mk
+
+obj-y		+= fmm.o
+
+
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/modules/integrations/P4080/FM/fmm.c b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/modules/integrations/P4080/FM/fmm.c
new file mode 100644
index 0000000..d4a2cb7
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/modules/integrations/P4080/FM/fmm.c
@@ -0,0 +1,205 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**************************************************************************//**
+ @File          fmm.c
+
+ @Description   FM module
+*//***************************************************************************/
+#include <linux/version.h>
+
+#if defined(CONFIG_MODVERSIONS) && !defined(MODVERSIONS)
+#define MODVERSIONS
+#endif
+#ifdef MODVERSIONS
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+#include <linux/modversions.h>
+#else
+#include <config/modversions.h>
+#endif /* LINUX_VERSION_CODE */
+#endif /* MODVERSIONS */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/proc_fs.h>
+#include <linux/smp_lock.h>
+#include <linux/uts.h>
+#include <linux/interrupt.h>
+#include <linux/reboot.h>
+#include <asm/pgtable.h>
+
+#include "error_ext.h"
+#include "std_ext.h"
+#include "xx_ext.h"
+#include "sys_ext.h"
+#include "platform_p4080_ds_ext.h"
+#include "lnxwrp_fm_ext.h"
+
+
+#define __ERR_MODULE__      MODULE_P4080
+
+
+#define DRIVER_AUTHOR   "Shlomi Gridish"
+#define DRIVER_DESC     "Frame Manager module"
+#define DRIVER_INFO     DRIVER_DESC
+
+
+MODULE_DESCRIPTION (DRIVER_INFO);
+MODULE_AUTHOR (DRIVER_AUTHOR);
+MODULE_LICENSE ("Dual BSD/GPL");
+
+
+typedef struct {
+    t_Handle                    h_Pltfrm;
+    t_Handle                    h_FmLnxWrp;
+#ifdef CONFIG_FSL_FMAN_TEST
+    t_Handle                    h_FmTestLnxWrp;
+#endif /* CONFIG_FSL_FMAN_TEST */
+} t_NcswModule;
+
+
+#ifdef MODULE
+extern int  __init __cold port_wrapper_load(void);
+extern void __exit __cold port_wrapper_unload(void);
+extern int  __init __cold mac_load(void);
+extern void __exit __cold mac_unload(void);
+extern int  __init __cold dpa_load(void);
+extern void __exit __cold dpa_unload(void);
+#endif /* MODULE */
+
+
+static t_NcswModule mod;
+
+
+#if 0
+static t_Handle ModGetObject (t_Handle h_App, e_SysModule mod, ...)
+{
+    t_NcswModule    *p_Mod = (t_NcswModule *)h_App;
+    t_Handle        obj = NULL;
+    va_list         args;
+    int             index;
+
+    va_start(args, mod);
+    index = va_arg(args, int);
+
+    switch (mod)
+    {
+        case e_SYS_MODULE_PLATFORM:
+            if (index == 0)
+                obj = p_Mod->sys.p_Descriptors[e_DESC_INTEG];
+            break;
+        default:
+            REPORT_ERROR(MINOR, E_INVALID_SELECTION, ("device-type!!!"));
+            break;
+    }
+    va_end(args);
+
+    if (!obj)
+        REPORT_ERROR(MINOR, E_INVALID_HANDLE, ("device [%d,%d]!!!", mod,index));
+    return obj;
+}
+#endif /* 0 */
+
+static void FreeInitResources(t_NcswModule *p_Mod)
+{
+#ifdef CONFIG_FSL_FMAN_TEST
+    if (p_Mod->h_FmTestLnxWrp)
+        LNXWRP_FM_TEST_Free(p_Mod->h_FmTestLnxWrp);
+#endif /* CONFIG_FSL_FMAN_TEST */
+
+    if (p_Mod->h_FmLnxWrp)
+        LNXWRP_FM_Free(p_Mod->h_FmLnxWrp);
+
+    PLATFORM_Free(&p_Mod->h_Pltfrm);
+}
+
+/*-------------------------------------------------------------------------*/
+static int __init __cold fm_load (void)
+{
+    t_PlatformParam     platformParam;
+
+    memset(&platformParam, 0, sizeof(platformParam));
+    if ((mod.h_Pltfrm = PLATFORM_Init(&platformParam)) == NULL)
+    {
+        printk("Failed to init general modules!\n");
+        return -ENODEV;
+    }
+
+    if ((mod.h_FmLnxWrp = LNXWRP_FM_Init()) == NULL)
+    {
+        printk("Failed to init FM wrapper!\n");
+        FreeInitResources(&mod);
+        return -ENODEV;
+    }
+
+#ifdef MODULE
+    if (port_wrapper_load() || mac_load() || dpa_load())
+    {
+        printk("Failed to init port-wrapper or MAC or DPA driver!\n");
+        FreeInitResources(&mod);
+        return -ENODEV;
+    }
+#endif /* MODULE */
+
+#ifdef CONFIG_FSL_FMAN_TEST
+    if ((mod.h_FmTestLnxWrp = LNXWRP_FM_TEST_Init()) == NULL)
+    {
+        printk("Failed to init FM-test wrapper!\n");
+        FreeInitResources(&mod);
+        return -ENODEV;
+    }
+#endif /* CONFIG_FSL_FMAN_TEST */
+
+    printk (KERN_CRIT "Freescale FM module ("__DATE__ ":"__TIME__")\n\n");
+
+    return 0;
+}
+
+static void __exit __cold fm_unload (void)
+{
+#ifdef MODULE
+    dpa_unload();
+    mac_unload();
+    port_wrapper_unload();
+#endif /* MODULE */
+
+    FreeInitResources(&mod);
+}
+
+module_init (fm_load);
+module_exit (fm_unload);
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/modules/integrations/P4080/FM/mod_config.h b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/modules/integrations/P4080/FM/mod_config.h
new file mode 100644
index 0000000..decb8d3
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/modules/integrations/P4080/FM/mod_config.h
@@ -0,0 +1,41 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __SYS_CONFIG_H
+#define __SYS_CONFIG_H
+
+
+/* System & Platform Modules */
+#define SYS_CFG_FM          ON
+
+
+#endif /* __SYS_CONFIG_H */
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/system/Makefile b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/system/Makefile
new file mode 100644
index 0000000..441eda1
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/system/Makefile
@@ -0,0 +1,13 @@
+#
+# Makefile for the Freescale Ethernet controllers
+#
+EXTRA_CFLAGS           += -DVERSION=\"\"
+#
+#Include netcomm SW specific definitions
+include $(srctree)/drivers/net/dpa/NetCommSw/ncsw_config.mk
+#
+
+obj-y		+= sys_io.o
+
+
+obj-y		+= platform/P4080/
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/system/platform/P4080/Makefile b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/system/platform/P4080/Makefile
new file mode 100644
index 0000000..f67748f
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/system/platform/P4080/Makefile
@@ -0,0 +1,9 @@
+#
+# Makefile for the Freescale Ethernet controllers
+#
+EXTRA_CFLAGS           += -DVERSION=\"\"
+#
+#Include netcomm SW specific definitions
+include $(srctree)/drivers/net/dpa/NetCommSw/ncsw_config.mk
+
+obj-y		+= platform_p4080_ds.o
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/system/platform/P4080/platform_p4080_ds.c b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/system/platform/P4080/platform_p4080_ds.c
new file mode 100644
index 0000000..188ee51
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/system/platform/P4080/platform_p4080_ds.c
@@ -0,0 +1,124 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <linux/version.h>
+
+#if defined(CONFIG_MODVERSIONS) && !defined(MODVERSIONS)
+#define MODVERSIONS
+#endif
+#ifdef MODVERSIONS
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+#include <linux/modversions.h>
+#else
+#include <config/modversions.h>
+#endif    /* LINUX_VERSION_CODE */
+#endif /* MODVERSIONS */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+
+#include <sysdev/fsl_soc.h>
+
+#include <asm/io.h>
+
+#include "std_ext.h"
+#include "error_ext.h"
+#include "part_ext.h"
+#include "string_ext.h"
+#include "xx_ext.h"
+#include "sys_io_ext.h"
+#include "platform_p4080_ds_ext.h"
+
+
+#define __ERR_MODULE__      MODULE_UNKNOWN
+
+
+typedef struct t_Platform
+{
+    /* Platform-owned module handles */
+    t_Handle                h_Part;
+    /* Clocks-related variables */
+    uint32_t                clockInFreqHz;
+    uint32_t                localBusFreqHz;
+} t_Platform;
+
+
+uint32_t ram_virt_addr;
+uint32_t ram_phys_addr;
+uint32_t ram_size;
+
+
+
+/*---------------------------------------------------------------------------*/
+/*                       P4080-MDS Platform Init                             */
+/*---------------------------------------------------------------------------*/
+t_Handle PLATFORM_Init(t_PlatformParam *p_PlatformParam)
+{
+    t_Platform                  *p_Platform;
+
+    SANITY_CHECK_RETURN_VALUE(p_PlatformParam, E_NULL_POINTER, NULL);
+
+    /* Allocate the platform's control structure */
+    p_Platform = XX_Malloc(sizeof(t_Platform));
+    if (!p_Platform)
+    {
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("Platform structure"));
+        return NULL;
+    }
+    memset(p_Platform, 0, sizeof(t_Platform));
+
+    ram_virt_addr = (uint32_t)phys_to_virt(0);
+    ram_phys_addr = 0x0;
+    ram_size      = 0x20000000;
+    if (SYS_RegisterIoMap((uint64_t)ram_virt_addr, (uint64_t)ram_phys_addr, ram_size) != E_OK)
+    {
+        REPORT_ERROR(MAJOR, E_INVALID_STATE, ("RAM memory map"));
+        return NULL;
+    }
+
+    return p_Platform;
+}
+
+/*****************************************************************************/
+t_Error PLATFORM_Free(t_Handle h_Platform)
+{
+    t_Platform *p_Platform = (t_Platform *)h_Platform;
+
+    if (!p_Platform)
+        RETURN_ERROR(MINOR, E_INVALID_HANDLE, NO_MSG);
+
+    SYS_UnregisterIoMap((uint64_t)ram_virt_addr);
+
+    XX_Free(p_Platform);
+
+    return E_OK;
+}
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/system/sys_init.c b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/system/sys_init.c
new file mode 100644
index 0000000..a95c461
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/system/sys_init.c
@@ -0,0 +1,48 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+
+#include "std_ext.h"
+#include "error_ext.h"
+#include "sys_ext.h"
+
+
+/*****************************************************************************/
+void SYS_Init(void)
+{
+
+}
+
+void SYS_Free(void)
+{
+
+}
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/system/sys_io.c b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/system/sys_io.c
new file mode 100644
index 0000000..e6e2125
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/system/sys_io.c
@@ -0,0 +1,179 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <linux/version.h>
+
+#if defined(CONFIG_MODVERSIONS) && !defined(MODVERSIONS)
+#define MODVERSIONS
+#endif
+#ifdef MODVERSIONS
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+#include <linux/modversions.h>
+#else
+#include <config/modversions.h>
+#endif    /* LINUX_VERSION_CODE */
+#endif /* MODVERSIONS */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+
+#include <asm/io.h>
+
+#include "std_ext.h"
+#include "error_ext.h"
+#include "string_ext.h"
+#include "list_ext.h"
+#include "sys_io_ext.h"
+
+
+#define __ERR_MODULE__      MODULE_UNKNOWN
+
+
+typedef struct {
+    uint64_t    virtAddr;
+    uint64_t    physAddr;
+    uint32_t    size;
+    t_List      node;
+} t_IoMap;
+#define IOMAP_OBJECT(ptr)  LIST_OBJECT(ptr, t_IoMap, node)
+
+LIST(mapsList);
+
+
+static void EnqueueIoMap(t_IoMap *p_IoMap)
+{
+    uint32_t   intFlags;
+
+    intFlags = XX_DisableAllIntr();
+    LIST_AddToTail(&p_IoMap->node, &mapsList);
+    XX_RestoreAllIntr(intFlags);
+}
+
+#if 0
+static t_IoMap * DequeueIoMap(void)
+{
+    t_IoMap     *p_IoMap = NULL;
+    uint32_t    intFlags;
+
+    intFlags = XX_DisableAllIntr();
+    if (!LIST_IsEmpty(&mapsList))
+    {
+        p_IoMap = IOMAP_OBJECT(mapsList.p_Next);
+        LIST_DelAndInit(&p_IoMap->node);
+    }
+    XX_RestoreAllIntr(intFlags);
+
+    return p_IoMap;
+}
+#endif /* 0 */
+
+static t_IoMap * FindIoMapByVirtAddr(uint64_t addr)
+{
+    t_IoMap     *p_IoMap;
+    t_List      *p_Pos;
+
+    LIST_FOR_EACH(p_Pos, &mapsList)
+    {
+        p_IoMap = IOMAP_OBJECT(p_Pos);
+        if ((addr >= p_IoMap->virtAddr) && (addr < p_IoMap->virtAddr+p_IoMap->size))
+            return p_IoMap;
+    }
+
+    return NULL;
+}
+
+static t_IoMap * FindIoMapByPhysAddr(uint64_t addr)
+{
+    t_IoMap     *p_IoMap;
+    t_List      *p_Pos;
+
+    LIST_FOR_EACH(p_Pos, &mapsList)
+    {
+        p_IoMap = IOMAP_OBJECT(p_Pos);
+        if ((addr >= p_IoMap->physAddr) && (addr < p_IoMap->physAddr+p_IoMap->size))
+            return p_IoMap;
+    }
+
+    return NULL;
+}
+
+t_Error SYS_RegisterIoMap (uint64_t virtAddr, uint64_t physAddr, uint32_t size)
+{
+    t_IoMap *p_IoMap;
+
+    p_IoMap = (t_IoMap*)XX_Malloc(sizeof(t_IoMap));
+    if (!p_IoMap)
+        RETURN_ERROR(MINOR, E_NO_MEMORY, ("message handler object!!!"));
+    memset(p_IoMap, 0, sizeof(t_IoMap));
+
+    p_IoMap->virtAddr = virtAddr;
+    p_IoMap->physAddr = physAddr;
+    p_IoMap->size     = size;
+
+    INIT_LIST(&p_IoMap->node);
+    EnqueueIoMap(p_IoMap);
+
+    return E_OK;
+}
+
+t_Error SYS_UnregisterIoMap  (uint64_t virtAddr)
+{
+    t_IoMap *p_IoMap = FindIoMapByVirtAddr(virtAddr);
+    if (!p_IoMap)
+        RETURN_ERROR(MINOR, E_NO_DEVICE, ("message handler not found in list!!!"));
+
+    LIST_Del(&p_IoMap->node);
+    XX_Free(p_IoMap);
+
+    return E_OK;
+}
+
+uint64_t SYS_PhysToVirt(uint64_t addr)
+{
+    t_IoMap *p_IoMap = FindIoMapByPhysAddr(addr);
+    if (p_IoMap)
+        return (uint64_t)(addr - p_IoMap->physAddr + p_IoMap->virtAddr);
+    return CAST_POINTER_TO_UINT64(phys_to_virt((unsigned long)addr));
+}
+
+uint64_t SYS_VirtToPhys(uint64_t addr)
+{
+    t_IoMap *p_IoMap;
+
+    if (addr == 0)
+        return 0;
+
+    p_IoMap = FindIoMapByVirtAddr(addr);
+    if (p_IoMap)
+        return (uint64_t)(addr - p_IoMap->virtAddr + p_IoMap->physAddr);
+    return (uint64_t)virt_to_phys(CAST_UINT64_TO_POINTER(addr));
+}
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/util/Makefile b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/util/Makefile
new file mode 100644
index 0000000..7edbea6
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/util/Makefile
@@ -0,0 +1,11 @@
+#
+# Makefile for the Freescale Ethernet controllers
+#
+EXTRA_CFLAGS           += -DVERSION=\"\"
+#
+#Include netcomm SW specific definitions
+include $(srctree)/drivers/net/dpa/NetCommSw/ncsw_config.mk
+
+obj-y		+= procbuff.o
+
+
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/util/procbuff.c b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/util/procbuff.c
new file mode 100644
index 0000000..eb59680
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/util/procbuff.c
@@ -0,0 +1,116 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "std_ext.h"
+#include "string_ext.h"
+#include "sprint_ext.h"
+#include "stdarg_ext.h"
+#include "xx_ext.h"
+
+#include "procbuff.h"
+
+
+t_Handle    ProcBuff_Init(char *buffer,char **start,int offset,int length, int *eof)
+{
+    t_ProcBuff  * p_ProcBuff = XX_Malloc(sizeof(t_ProcBuff));
+
+    if (p_ProcBuff)
+    {
+        p_ProcBuff->num_of_written_chars = 0;
+        p_ProcBuff->buffer = buffer;
+        p_ProcBuff->offset = offset;
+        p_ProcBuff->length = length;
+        p_ProcBuff->eof = eof;
+
+        if(start)
+            *start = buffer;
+        *(p_ProcBuff->eof) = 0;
+    }
+
+    return (t_Handle)(p_ProcBuff);
+}
+
+void        ProcBuff_Free (t_Handle h_ProcBuff)
+{
+    t_ProcBuff  * p_ProcBuff = (t_ProcBuff *)(h_ProcBuff);
+    XX_Free(p_ProcBuff);
+}
+
+void         ProcBuff_Write (t_Handle h_ProcBuff,const char *fmt, ...)
+{
+    t_ProcBuff  * p_ProcBuff = (t_ProcBuff *)(h_ProcBuff);
+    int         len;
+    va_list     args;
+    char        str[MAX_LINE_SIZE];
+
+    va_start(args, fmt);
+    len=vsnprintf(str,MAX_LINE_SIZE,fmt,args);
+    va_end(args);
+
+    if (len == -1 || len >= MAX_LINE_SIZE)
+    {
+        /* formated string truncated, it is to big to fit into the MAX_LINE_SIZE */
+        len = MAX_LINE_SIZE - 1;
+        str[len] = 0;
+    }
+
+    if (len <= p_ProcBuff->offset)
+        p_ProcBuff->offset -= len;
+    else
+    {
+        len -= p_ProcBuff->offset;
+        if (len > p_ProcBuff->length)
+            len = p_ProcBuff->length;
+        strncpy(p_ProcBuff->buffer,str + p_ProcBuff->offset,(unsigned int)(len));
+
+        p_ProcBuff->buffer += len;
+        p_ProcBuff->length -= len;
+        if (p_ProcBuff->offset)
+            p_ProcBuff->offset = 0;
+        p_ProcBuff->num_of_written_chars += len;
+    }
+}
+
+int          ProcBuff_GetNumOfWrittenChars(t_Handle h_ProcBuff)
+{
+    t_ProcBuff  * p_ProcBuff = (t_ProcBuff *)(h_ProcBuff);
+
+    return p_ProcBuff->num_of_written_chars;
+}
+
+void         ProcBuff_Done (t_Handle h_ProcBuff)
+{
+    t_ProcBuff  * p_ProcBuff = (t_ProcBuff *)(h_ProcBuff);
+
+    if (p_ProcBuff->length)
+        *(p_ProcBuff->eof) = 1;
+}
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/util/procbuff.h b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/util/procbuff.h
new file mode 100644
index 0000000..d21382b
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/util/procbuff.h
@@ -0,0 +1,48 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __PROCBUFF_H
+#define __PROCBUFF_H
+
+#include "procbuff_ext.h"
+
+
+typedef struct t_ProcBuff {
+    int     num_of_written_chars;
+    char    *buffer;
+    int     length;
+    int     *eof;
+    int     offset;
+} t_ProcBuff;
+
+
+#endif /* __PROCBUFF_H */
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/Makefile b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/Makefile
new file mode 100644
index 0000000..73354b9
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/Makefile
@@ -0,0 +1,15 @@
+#
+# Makefile for the Freescale Ethernet controllers
+#
+EXTRA_CFLAGS           += -DVERSION=\"\"
+#
+#Include netcomm SW specific definitions
+include $(srctree)/drivers/net/dpa/NetCommSw/ncsw_config.mk
+
+#EXTRA_CFLAGS += -I$(NCSW_FM_INC)
+EXTRA_CFLAGS += -I$(NET_DPA)
+
+obj-y		+= fsl-ncsw-PFM.o
+obj-$(CONFIG_FSL_FMAN_TEST)	+= fman_test.o
+
+fsl-ncsw-PFM-objs	:=   lnxwrp_fm.o lnxwrp_fm_ioctls.o
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/fman_test.c b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/fman_test.c
new file mode 100644
index 0000000..fb35312
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/fman_test.c
@@ -0,0 +1,696 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**************************************************************************//**
+ @File          fman_test.c
+
+ @Author        Moti Bar
+
+ @Description   FM Linux test
+*//***************************************************************************/
+
+/* Linux Headers ------------------- */
+#include <linux/version.h>
+
+#if defined(CONFIG_MODVERSIONS) && !defined(MODVERSIONS)
+#define MODVERSIONS
+#endif
+#ifdef MODVERSIONS
+#include <config/modversions.h>
+#endif /* MODVERSIONS */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/fs.h>
+#include <linux/cdev.h>
+#include <linux/device.h>
+#include <linux/io.h>
+#include <linux/ioport.h>
+#include <linux/fsl_qman.h>     /*struct qman_fq */
+#include <linux/of_platform.h>
+#include <asm/uaccess.h>
+#include <asm/errno.h>
+
+/* NetCommSw Headers --------------- */
+#include "std_ext.h"
+#include "error_ext.h"
+#include "debug_ext.h"
+#include "list_ext.h"
+#include "fm_ext.h"
+
+#include "fm_test_ioctls.h"
+#include "fsl_fman.h"
+#include "fsl_fman_test.h"
+#include "fm_port_ext.h"
+
+
+#define __ERR_MODULE__      MODULE_FM
+
+#define FMT_FRM_WATERMARK   0xdeadbeefdeadbeeaLL
+
+
+typedef struct {
+    ioc_fmt_buff_desc_t     buff;
+    t_List                  node;
+} t_FmTestFrame;
+#define FMT_FRAME_OBJECT(ptr)  LIST_OBJECT(ptr, t_FmTestFrame, node)
+
+typedef struct t_FmTestFq {
+    struct qman_fq      fq_base;
+    struct list_head    list;
+    void                *port;
+    bool                init;
+} t_FmTestFq;
+
+typedef struct {
+    bool                valid;
+    uint8_t             id;
+    ioc_fmt_port_type   portType;
+    struct fm_port      *p_TxPort;
+    t_Handle            h_TxFmPortDev;
+    struct fm_port      *p_RxPort;
+    t_Handle            h_RxFmPortDev;
+    t_Handle            h_Mac;
+    uint64_t            fmPhysBaseAddr;
+    t_List              rxFrmsQ;
+
+    int                 numOfTxQs;
+    struct qman_fq      *p_TxFqs[8];
+} t_FmTestPort;
+
+typedef struct {
+    int major;
+    t_FmTestPort ports[IOC_FMT_MAX_NUM_OF_PORTS];
+} t_FmTest;
+
+
+static t_FmTest fmTest;
+
+
+static t_Error SetMacLoopback(t_FmTestPort *p_FmTestPort, bool en)
+{
+#define FM_1GMAC0_OFFSET                0x000e0000
+#define FM_1GMAC1_OFFSET                0x000e2000
+#define FM_1GMAC2_OFFSET                0x000e4000
+#define FM_1GMAC3_OFFSET                0x000e6000
+#define FM_10GMAC0_OFFSET               0x000f0000
+
+#define FM_1GMAC_CMD_CONF_CTRL_OFFSET   0x100
+#define FM_10GMAC_CMD_CONF_CTRL_OFFSET  0x8
+
+#define MACCFG1_LOOPBACK                0x00000100
+#define CMD_CFG_LOOPBACK_EN             0x00000400
+
+    uint64_t    tmpAddr = p_FmTestPort->fmPhysBaseAddr;
+    uint32_t    tmpVal;
+
+    if (p_FmTestPort->portType == e_IOC_FMT_PORT_T_RXTX)
+    switch (p_FmTestPort->id)
+    {
+        case 0:
+            tmpAddr += FM_1GMAC0_OFFSET;
+            break;
+        case 1:
+            tmpAddr += FM_1GMAC1_OFFSET;
+            break;
+        case 2:
+            tmpAddr += FM_1GMAC2_OFFSET;
+            break;
+        case 3:
+            tmpAddr += FM_1GMAC3_OFFSET;
+            break;
+        case 4:
+            tmpAddr += FM_10GMAC0_OFFSET;
+            break;
+        default:
+            RETURN_ERROR(MINOR, E_INVALID_VALUE, ("fm-port-test id!"));
+    }
+
+    tmpAddr = CAST_POINTER_TO_UINT64(ioremap(tmpAddr, 0x1000));
+
+    switch (p_FmTestPort->id)
+    {
+        case 0:
+        case 1:
+        case 2:
+        case 3:
+            tmpAddr += FM_1GMAC_CMD_CONF_CTRL_OFFSET;
+            tmpVal = GET_UINT32(*CAST_UINT64_TO_POINTER_TYPE(uint32_t,tmpAddr));
+            if (en)
+                tmpVal |= MACCFG1_LOOPBACK;
+            else
+                tmpVal &= ~MACCFG1_LOOPBACK;
+            WRITE_UINT32(*CAST_UINT64_TO_POINTER_TYPE(uint32_t,tmpAddr), tmpVal);
+            break;
+        case 4:
+            tmpAddr += FM_10GMAC_CMD_CONF_CTRL_OFFSET;
+            tmpVal = GET_UINT32(*CAST_UINT64_TO_POINTER_TYPE(uint32_t,tmpAddr));
+            if (en)
+                tmpVal |= CMD_CFG_LOOPBACK_EN;
+            else
+                tmpVal &= ~CMD_CFG_LOOPBACK_EN;
+            WRITE_UINT32(*CAST_UINT64_TO_POINTER_TYPE(uint32_t,tmpAddr), tmpVal);
+            break;
+        default:
+            break;
+    }
+
+    iounmap(CAST_UINT64_TO_POINTER(tmpAddr));
+
+    return E_OK;
+}
+
+static void EnqueueFrameToRxQ(t_FmTestPort *p_FmTestPort, t_FmTestFrame *p_FmTestFrame)
+{
+    uint32_t   intFlags;
+
+    intFlags = XX_DisableAllIntr();
+    LIST_AddToTail(&p_FmTestFrame->node, &p_FmTestPort->rxFrmsQ);
+    XX_RestoreAllIntr(intFlags);
+}
+
+static t_FmTestFrame * DequeueFrameFromRxQ(t_FmTestPort *p_FmTestPort)
+{
+    t_FmTestFrame   *p_FmTestFrame = NULL;
+    uint32_t        intFlags;
+
+    intFlags = XX_DisableAllIntr();
+    if (!LIST_IsEmpty(&p_FmTestPort->rxFrmsQ))
+    {
+        p_FmTestFrame = FMT_FRAME_OBJECT(p_FmTestPort->rxFrmsQ.p_Next);
+        LIST_DelAndInit(&p_FmTestFrame->node);
+    }
+    XX_RestoreAllIntr(intFlags);
+
+    return p_FmTestFrame;
+}
+
+static enum qman_cb_dqrr_result egress_dqrr(struct qman_portal          *portal,
+                                            struct qman_fq              *fq,
+                                            const struct qm_dqrr_entry  *dq)
+{
+    BUG();
+    return qman_cb_dqrr_consume;
+}
+
+static void egress_ern(struct qman_portal       *portal,
+                       struct qman_fq           *fq,
+                       const struct qm_mr_entry *msg)
+{
+    BUG();
+}
+
+static struct qman_fq * FqAlloc(t_FmTestPort    *p_FmTestPort,
+                                uint32_t        fqid,
+                                uint32_t        flags,
+                                uint16_t        channel,
+                                uint8_t         wq)
+{
+    int                     _errno;
+    struct qman_fq          *fq = NULL;
+    t_FmTestFq              *p_FmtFq;
+    struct qm_mcc_initfq    initfq;
+
+    p_FmtFq = (t_FmTestFq *)XX_Malloc(sizeof(t_FmTestFq));
+    if (!p_FmtFq) {
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FQ obj!!!"));
+        return NULL;
+    }
+
+    p_FmtFq->fq_base.cb.dqrr = egress_dqrr;
+    p_FmtFq->fq_base.cb.ern = p_FmtFq->fq_base.cb.dc_ern = p_FmtFq->fq_base.cb.fqs = egress_ern;
+    p_FmtFq->port = (void *)p_FmTestPort;
+    if (fqid == 0) {
+        flags |= QMAN_FQ_FLAG_DYNAMIC_FQID;
+        flags &= ~QMAN_FQ_FLAG_NO_MODIFY;
+    } else {
+        flags &= ~QMAN_FQ_FLAG_DYNAMIC_FQID;
+    }
+
+    p_FmtFq->init    = !(flags & QMAN_FQ_FLAG_NO_MODIFY);
+
+    DBG(TRACE, ("fqid %d, flags 0x%08x, channel %d, wq %d",fqid,flags,channel,wq));
+
+    _errno = qman_create_fq(fqid, flags, &p_FmtFq->fq_base);
+    if (unlikely(_errno)) {
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FQ obj - qman_new_fq!!!"));
+        XX_Free(p_FmtFq);
+        return NULL;
+    }
+    fq = &p_FmtFq->fq_base;
+
+    if (p_FmtFq->init) {
+        initfq.we_mask            = QM_INITFQ_WE_DESTWQ;
+        initfq.fqd.dest.channel   = channel;
+        initfq.fqd.dest.wq        = wq;
+
+        _errno = qman_init_fq(fq, QMAN_INITFQ_FLAG_SCHED, &initfq);
+        if (unlikely(_errno < 0)) {
+            REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FQ obj - qman_init_fq!!!"));
+            qman_destroy_fq(fq, 0);
+            XX_Free(p_FmtFq);
+            return NULL;
+        }
+    }
+
+    return fq;
+}
+
+static t_Error PortInit (t_FmTestPort *p_FmTestPort, ioc_fmt_port_param_t *p_Params)
+{
+    struct of_device_id name;
+    struct device_node  *fm_node, *fm_port_node;
+    const uint32_t      *uint32_prop;
+    int                 _errno=0, lenp;
+    uint32_t            i;
+
+    INIT_LIST(&p_FmTestPort->rxFrmsQ);
+    p_FmTestPort->numOfTxQs = p_Params->num_tx_queues;
+    p_FmTestPort->id        = p_Params->fm_port_id;
+    p_FmTestPort->portType  = p_Params->fm_port_type;
+
+    /* Get all the FM nodes */
+    memset(&name, 0, sizeof(struct of_device_id));
+    BUG_ON(strlen("fsl,fman") >= sizeof(name.compatible));
+    strcpy(name.compatible, "fsl,fman");
+    for_each_matching_node(fm_node, &name) {
+        uint32_prop = (uint32_t *)of_get_property(fm_node, "cell-index", &lenp);
+        if (unlikely(uint32_prop == NULL)) {
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("of_get_property(%s, cell-index) failed", fm_node->full_name));
+        }
+        BUG_ON(lenp != sizeof(uint32_t));
+        if (*uint32_prop == p_Params->fm_id) {
+            struct resource     res;
+            /* Get the FM address */
+            _errno = of_address_to_resource(fm_node, 0, &res);
+            if (unlikely(_errno < 0))
+                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("of_address_to_resource() = %d", _errno));
+
+            p_FmTestPort->fmPhysBaseAddr = res.start;
+
+            for_each_child_of_node(fm_node, fm_port_node) {
+                struct of_device    *of_dev;
+                uint32_prop = (uint32_t *)of_get_property(fm_port_node, "cell-index", &lenp);
+                if (uint32_prop == NULL)
+                    continue;
+
+                if (of_device_is_compatible(fm_port_node, "fsl,fman-port-oh") &&
+                    (p_FmTestPort->portType  == e_IOC_FMT_PORT_T_OP)) {
+                    if (*uint32_prop == p_FmTestPort->id)
+                    {
+                        of_dev = of_find_device_by_node(fm_port_node);
+                        if (unlikely(of_dev == NULL))
+                            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fm id!"));
+                        p_FmTestPort->p_TxPort = fm_port_bind(&of_dev->dev);
+                        p_FmTestPort->h_TxFmPortDev = (t_Handle)fm_port_get_handle(p_FmTestPort->p_TxPort);
+                        break;
+                    }
+                }
+
+                else if ((*uint32_prop == p_FmTestPort->id) &&
+                          p_FmTestPort->portType  == e_IOC_FMT_PORT_T_RXTX) {
+                    of_dev = of_find_device_by_node(fm_port_node);
+                    if (unlikely(of_dev == NULL))
+                        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fm id!"));
+                    if(of_device_is_compatible(fm_port_node, "fsl,fman-port-1g-tx"))
+                    {
+                        p_FmTestPort->p_TxPort = fm_port_bind(&of_dev->dev);
+                        p_FmTestPort->h_TxFmPortDev = (t_Handle)fm_port_get_handle(p_FmTestPort->p_TxPort);
+                    }
+                    else if(of_device_is_compatible(fm_port_node, "fsl,fman-port-1g-rx"))
+                    {
+                        p_FmTestPort->p_RxPort = fm_port_bind(&of_dev->dev);
+                        p_FmTestPort->h_RxFmPortDev = (t_Handle)fm_port_get_handle(p_FmTestPort->p_RxPort);
+                    }
+                    else if (of_device_is_compatible(fm_port_node, "fsl,fman-1g-mac"))
+                        p_FmTestPort->h_Mac = (typeof(p_FmTestPort->h_Mac))dev_get_drvdata(&of_dev->dev);
+                    else
+                        continue;
+                    if(p_FmTestPort->h_RxFmPortDev && p_FmTestPort->h_RxFmPortDev && p_FmTestPort->h_Mac)
+                        break;
+                }
+
+                else if (((*uint32_prop + FM_MAX_NUM_OF_1G_RX_PORTS )== p_FmTestPort->id) &&
+                          p_FmTestPort->portType  == e_IOC_FMT_PORT_T_RXTX) {
+                    of_dev = of_find_device_by_node(fm_port_node);
+                    if (unlikely(of_dev == NULL))
+                        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fm id!"));
+                    if(of_device_is_compatible(fm_port_node, "fsl,fman-port-10g-tx"))
+                    {
+                        p_FmTestPort->p_TxPort = fm_port_bind(&of_dev->dev);
+                        p_FmTestPort->h_TxFmPortDev = (t_Handle)fm_port_get_handle(p_FmTestPort->p_TxPort);
+                    }
+                    else if(of_device_is_compatible(fm_port_node, "fsl,fman-port-10g-rx"))
+                    {
+                        p_FmTestPort->p_RxPort = fm_port_bind(&of_dev->dev);
+                        p_FmTestPort->h_RxFmPortDev = (t_Handle)fm_port_get_handle(p_FmTestPort->p_RxPort);
+                    }
+                    else if (of_device_is_compatible(fm_port_node, "fsl,fman-10g-mac"))
+                        p_FmTestPort->h_Mac = (typeof(p_FmTestPort->h_Mac))dev_get_drvdata(&of_dev->dev);
+                    else
+                        continue;
+                    if(p_FmTestPort->h_RxFmPortDev && p_FmTestPort->h_RxFmPortDev && p_FmTestPort->h_Mac)
+                        break;
+                }
+            } //for_each_child
+        }
+    } //for each matching node
+
+    DBG(TRACE, ("h_TxFmPortDev - 0x%08x, h_RxFmPortDev - 0x%08x, h_Mac - 0x%08x\n",
+        p_FmTestPort->h_TxFmPortDev,p_FmTestPort->h_RxFmPortDev,p_FmTestPort->h_Mac));
+
+    //init Queues
+    for (i=0; i<p_FmTestPort->numOfTxQs; i++) {
+        p_FmTestPort->p_TxFqs[i] =
+            FqAlloc(p_FmTestPort,
+                    0,
+                    QMAN_FQ_FLAG_TO_DCPORTAL,
+                    fm_get_tx_port_channel(p_FmTestPort->p_TxPort),
+                    i);
+        if (IS_ERR(p_FmTestPort->p_TxFqs[i]))
+            RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("Tx FQs!"));
+    }
+
+    SetMacLoopback(p_FmTestPort, TRUE);
+
+    p_FmTestPort->valid     = TRUE;
+
+    return E_OK;
+}
+
+
+bool is_fman_test (void     *mac_dev,
+                   uint32_t queueId,
+                   uint8_t  *buffer,
+                   uint32_t size)
+{
+    t_FmTest                *p_FmTest = &fmTest;
+    t_FmTestPort            *p_FmTestPort=NULL;
+    t_FmTestFrame           *p_FmTestFrame;
+    uint32_t                count=size-7;
+    uint64_t                temp;
+    uint8_t                 *temp_buf=buffer, i;
+    bool                    fman_test_flag = false;
+    uint32_t                dataOffset;
+
+    if ((queueId == FMT_TX_CONF_Q) || (queueId == FMT_TX_ERR_Q))
+    {
+        /* Get the FM-test-port object */
+        for (i=0; i<IOC_FMT_MAX_NUM_OF_PORTS; i++)
+            if (mac_dev == p_FmTest->ports[i].h_Mac)
+                p_FmTestPort = &p_FmTest->ports[i];
+        if (!p_FmTestPort)
+            return false;
+
+        XX_Free(buffer);
+        return true;
+    }
+
+    /* Get the FM-test-port object */
+    for (i=0; i<IOC_FMT_MAX_NUM_OF_PORTS; i++)
+        if (mac_dev == p_FmTest->ports[i].h_Mac)
+            p_FmTestPort = &p_FmTest->ports[i];
+    if (!p_FmTestPort)
+        return false;
+
+    /* Check according to watermark if this frame is for FM-test */
+    while(count--)
+    {
+        temp = *(uint64_t *)temp_buf;
+        if (temp == FMT_FRM_WATERMARK)
+        {
+            fman_test_flag = true;
+            break;
+        }
+        temp_buf++;
+    }
+
+    if (fman_test_flag)
+    {
+        dataOffset = FM_PORT_GetBufferDataOffset(p_FmTestPort->h_RxFmPortDev);
+        p_FmTestFrame = (t_FmTestFrame *)XX_Malloc(sizeof(t_FmTestFrame));
+        memset(p_FmTestFrame, 0, sizeof(t_FmTestFrame));
+        INIT_LIST(&p_FmTestFrame->node);
+
+        p_FmTestFrame->buff.p_data = (uint8_t *)XX_Malloc(size * sizeof(uint8_t));
+        p_FmTestFrame->buff.size = size-dataOffset;
+        p_FmTestFrame->buff.qid = queueId;
+
+        memcpy(p_FmTestFrame->buff.p_data,
+               CAST_UINT64_TO_POINTER_TYPE(uint8_t,(CAST_POINTER_TO_UINT64(buffer)+dataOffset)),
+               p_FmTestFrame->buff.size);
+
+        memcpy(p_FmTestFrame->buff.buff_context.fm_prs_res,
+               FM_PORT_GetBufferPrsResult(p_FmTestPort->h_RxFmPortDev, (char*)buffer),
+               32);
+
+        EnqueueFrameToRxQ(p_FmTestPort, p_FmTestFrame);
+        return true;
+    }
+
+    return false;
+}
+
+
+/*****************************************************************************/
+/*               API routines for the FM Linux Device                        */
+/*****************************************************************************/
+
+static int fm_test_open(struct inode *inode, struct file *file)
+{
+    t_FmTest            *p_FmTest = &fmTest;
+    //unsigned int        major = imajor(inode);
+    unsigned int        minor = iminor(inode);
+
+    DBG(TRACE, ("Opening minor - %d - ", minor));
+
+    if (file->private_data != NULL)
+        return 0;
+
+    if ((minor >= DEV_FM_TEST_PORTS_MINOR_BASE) &&
+        (minor < DEV_FM_TEST_MAX_MINORS))
+        file->private_data = &p_FmTest->ports[minor];
+    else
+        return -ENXIO;
+
+    return 0;
+}
+
+static int fm_test_close(struct inode *inode, struct file *file)
+{
+    t_FmTestPort        *p_FmTestPort;
+    unsigned int        minor = iminor(inode);
+    int                 err = 0;
+
+    DBG(TRACE, ("Closing minor - %d - ", minor));
+
+    p_FmTestPort = file->private_data;
+    if (!p_FmTestPort)
+        return -ENODEV;
+
+    p_FmTestPort->valid = FALSE;
+
+    SetMacLoopback(p_FmTestPort, FALSE);
+
+    /* Complete!!! */
+    return err;
+}
+
+static int fm_test_ioctl(struct inode *inode, struct file *file, unsigned int cmd, unsigned long arg)
+{
+    t_FmTestPort        *p_FmTestPort;
+    unsigned int        minor = iminor(inode);
+
+    DBG(TRACE, ("IOCTL minor - %d, cmd - 0x%08x, arg - 0x%08x", minor, cmd, arg));
+
+    p_FmTestPort = file->private_data;
+    if (!p_FmTestPort)
+        return -ENODEV;
+
+    switch (cmd)
+    {
+        case FMT_PORT_IOC_INIT:
+        {
+            ioc_fmt_port_param_t  param;
+
+            if (p_FmTestPort->valid) {
+                REPORT_ERROR(MINOR, E_INVALID_STATE, ("port is already initialized!!!"));
+                return -EFAULT;
+            }
+
+            if (copy_from_user(&param, (ioc_fmt_port_param_t *)arg, sizeof(ioc_fmt_port_param_t))) {
+                REPORT_ERROR(MINOR, E_INVALID_STATE, NO_MSG);
+                return -EFAULT;
+            }
+
+            return PortInit(p_FmTestPort, &param);
+        }
+        default:
+            REPORT_ERROR(MINOR, E_NOT_SUPPORTED, ("IOCTL"));
+            return -EFAULT;
+    }
+
+    return 0;
+}
+
+ssize_t fm_test_read (struct file *file, char __user *buf, size_t size, loff_t *ppos)
+{
+    t_FmTestPort        *p_FmTestPort;
+    t_FmTestFrame       *p_FmTestFrame;
+    ssize_t             cnt;
+
+    p_FmTestPort = file->private_data;
+    if (!p_FmTestPort || !p_FmTestPort->valid)
+        return -ENODEV;
+
+    p_FmTestFrame = DequeueFrameFromRxQ(p_FmTestPort);
+    if (!p_FmTestFrame)
+        return 0;
+
+    cnt = sizeof(ioc_fmt_buff_desc_t);
+    if (size<cnt) {
+        REPORT_ERROR(MINOR, E_NO_MEMORY, ("Illegal buffer-size!"));
+        return 0;
+    }
+    if (copy_to_user(buf, &p_FmTestFrame->buff, cnt)) {
+        REPORT_ERROR(MINOR, E_INVALID_STATE, NO_MSG);
+        return 0;
+    }
+
+    ((ioc_fmt_buff_desc_t *)buf)->p_data = buf+sizeof(ioc_fmt_buff_desc_t);
+
+    cnt += MIN(p_FmTestFrame->buff.size, size-cnt);
+    if (size<cnt) {
+        REPORT_ERROR(MINOR, E_NO_MEMORY, ("Illegal buffer-size!"));
+        return 0;
+    }
+
+    if (copy_to_user(buf+sizeof(ioc_fmt_buff_desc_t), p_FmTestFrame->buff.p_data, cnt)) {
+        REPORT_ERROR(MINOR, E_INVALID_STATE, NO_MSG);
+        return 0;
+    }
+
+    XX_Free(p_FmTestFrame->buff.p_data);
+    XX_Free(p_FmTestFrame);
+
+    return cnt;
+}
+
+ssize_t fm_test_write (struct file *file, const char __user *buf, size_t size, loff_t *ppos)
+{
+    t_FmTestPort        *p_FmTestPort;
+    ioc_fmt_buff_desc_t buffDesc;
+    t_FmFD              fd;
+    uint8_t             *p_Data;
+    uint32_t            dataOffset;
+    int                 _errno;
+
+    p_FmTestPort = file->private_data;
+    if (!p_FmTestPort || !p_FmTestPort->valid) {
+        REPORT_ERROR(MINOR, E_INVALID_HANDLE, NO_MSG);
+        return 0;
+    }
+
+    if (copy_from_user(&buffDesc, (ioc_fmt_buff_desc_t *)buf, sizeof(ioc_fmt_buff_desc_t))) {
+        REPORT_ERROR(MINOR, E_INVALID_STATE, NO_MSG);
+        return 0;
+    }
+
+    dataOffset = FM_PORT_GetBufferDataOffset(p_FmTestPort->h_TxFmPortDev);
+    p_Data = (uint8_t*)XX_Malloc(buffDesc.size+dataOffset);
+    if (!p_Data) {
+        REPORT_ERROR(MINOR, E_NO_MEMORY, ("data buff!"));
+        return 0;
+    }
+
+    if (copy_from_user (CAST_UINT64_TO_POINTER_TYPE(uint8_t,(CAST_POINTER_TO_UINT64(p_Data)+dataOffset)),
+                        buffDesc.p_data,
+                        buffDesc.size)) {
+        REPORT_ERROR(MINOR, E_NO_MEMORY, ("data buff!"));
+        XX_Free(p_Data);
+        return 0;
+    }
+
+    memset(&fd, 0, sizeof(fd));
+    FM_FD_SET_ADDR(&fd, p_Data);
+    FM_FD_SET_OFFSET(&fd, dataOffset);
+    FM_FD_SET_LENGTH(&fd, buffDesc.size);
+
+    DBG(TRACE, ("buffDesc qId %d, fqid %d, frame len %d, fq 0x%8x\n",
+                buffDesc.qid, qman_fq_fqid(p_FmTestPort->p_TxFqs[buffDesc.qid]), buffDesc.size,p_FmTestPort->p_TxFqs[buffDesc.qid]));
+
+    _errno = qman_enqueue(p_FmTestPort->p_TxFqs[buffDesc.qid], (struct qm_fd*)&fd, 0);
+    if (_errno) {
+        buffDesc.status = (uint32_t)_errno;
+        if (copy_to_user((ioc_fmt_buff_desc_t*)buf, &buffDesc, sizeof(ioc_fmt_buff_desc_t))) {
+            REPORT_ERROR(MINOR, E_WRITE_FAILED, NO_MSG);
+            XX_Free(p_Data);
+            return 0;
+        }
+    }
+    return buffDesc.size;
+}
+
+/* Globals for FM character device */
+static struct file_operations fm_test_fops =
+{
+    owner:      THIS_MODULE,
+    ioctl:      fm_test_ioctl,
+    open:       fm_test_open,
+    release:    fm_test_close,
+    read:       fm_test_read,
+    write:      fm_test_write,
+};
+
+t_Handle LNXWRP_FM_TEST_Init(void)
+{
+    t_FmTest    *p_FmTest = &fmTest;
+
+    /* Register to the /dev for IOCTL API */
+    /* Register dynamically a new major number for the character device: */
+    if ((p_FmTest->major = register_chrdev(0, DEV_FM_TEST_NAME, &fm_test_fops)) <= 0)
+    {
+        REPORT_ERROR(MAJOR, E_INVALID_STATE, ("Failed to allocate a major number for device \"%s\"", DEV_FM_TEST_NAME));
+        return NULL;
+    }
+
+    return p_FmTest;
+}
+
+t_Error  LNXWRP_FM_TEST_Free(t_Handle h_FmTestLnxWrp)
+{
+    t_FmTest    *p_FmTest = (t_FmTest*)h_FmTestLnxWrp;
+
+    UNUSED(p_FmTest);
+    /* Complete!!! */
+    return E_OK;
+}
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/lnxwrp_fm.c b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/lnxwrp_fm.c
new file mode 100644
index 0000000..dbd24c9
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/lnxwrp_fm.c
@@ -0,0 +1,1797 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**************************************************************************//**
+ @File          lnxwrp_fm.c
+
+ @Author        Shlomi Gridish
+
+ @Description   FM Linux wrapper functions.
+*//***************************************************************************/
+
+/* Linux Headers ------------------- */
+#include <linux/version.h>
+
+#if defined(CONFIG_MODVERSIONS) && !defined(MODVERSIONS)
+#define MODVERSIONS
+#endif
+#ifdef MODVERSIONS
+#include <config/modversions.h>
+#endif /* MODVERSIONS */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/fs.h>
+#include <linux/cdev.h>
+#include <linux/device.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/ioport.h>
+#include <linux/of_platform.h>
+#include <asm/uaccess.h>
+#include <asm/errno.h>
+#include <asm/qe.h>        /* For struct qe_firmware */
+#include <sysdev/fsl_soc.h>
+
+/* NetCommSw Headers --------------- */
+#include "std_ext.h"
+#include "error_ext.h"
+#include "sprint_ext.h"
+#include "debug_ext.h"
+#include "sys_io_ext.h"
+#include "procbuff_ext.h"
+
+#include "fm_ioctls.h"
+
+#include "lnxwrp_fm.h"
+
+
+#define PROC_PRINT(args...) offset += sprintf(buf+offset,args)
+
+
+static t_LnxWrpFm   lnxWrpFm;
+
+
+static int fm_proc_dump_stats(char *buffer, char **start, off_t offset,
+                              int length, int *eof, void *data)
+{
+//    t_LnxWrpFmDev               *p_LnxWrpFmDev = (t_LnxWrpFmDev*)data;
+//    t_PppohtLinkStatistics      linkStatistics;
+    t_Handle                    h_ProcBuff = ProcBuff_Init(buffer,start,offset,length,eof);
+    unsigned long               flags;
+    int                         numOfWrittenChars;
+
+    local_irq_save(flags);
+    ProcBuff_Write (h_ProcBuff, "FM driver statistics:\n");
+
+//#warning "complete"
+#if 0
+    for (i=0; i<PPPOHT_MAX_NUM_OF_LINKS; i++)
+        if (p_Pppohtd->links[i].h_Link)
+        {
+            memset(&linkStatistics, 0, sizeof(t_PppohtLinkStatistics));
+            PPPoHT_LINK_GetStatistics(p_Pppohtd->links[i].h_Link, &linkStatistics);
+            ProcBuff_Write (h_ProcBuff,
+                            "\tLink %d statistics:\n \
+                             rxFcsErrCnt: %d\n \
+                             rxInvalidAcCnt: %d\n",
+                            i,
+                            linkStatistics.rxFcsErrCnt,
+                            linkStatistics.rxInvalidAcCnt);
+        }
+#endif /* 0 */
+
+    numOfWrittenChars = ProcBuff_GetNumOfWrittenChars(h_ProcBuff);
+    ProcBuff_Free(h_ProcBuff);
+    local_irq_restore(flags);
+
+    return numOfWrittenChars;
+}
+
+static int fm_proc_dump_regs(char *buffer, char **start, off_t offset,
+                             int length, int *eof, void *data)
+{
+    unsigned long   flags;
+
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+    t_LnxWrpFmDev   *p_LnxWrpFmDev = (t_LnxWrpFmDev*)data;
+    int             i;
+    char            *next = buffer;
+    unsigned        size = length;
+    int             t;
+
+    local_irq_save(flags);
+    t = scnprintf(next, size, "FM driver registers dump.\n");
+    size -= t;
+    next += t;
+
+    if (!p_LnxWrpFmDev->active || !p_LnxWrpFmDev->h_Dev)
+        REPORT_ERROR(MINOR, E_INVALID_STATE, ("FM not initialized!"));
+    else
+    {
+        FM_DumpRegs(p_LnxWrpFmDev->h_Dev);
+
+        for (i=0; i<FM_MAX_NUM_OF_OP_PORTS; i++)
+            if (p_LnxWrpFmDev->opPorts[i].active && p_LnxWrpFmDev->opPorts[i].h_Dev)
+                FM_PORT_DumpRegs(p_LnxWrpFmDev->opPorts[i].h_Dev);
+        for (i=0; i<FM_MAX_NUM_OF_TX_PORTS; i++)
+            if (p_LnxWrpFmDev->txPorts[i].active && p_LnxWrpFmDev->txPorts[i].h_Dev)
+                FM_PORT_DumpRegs(p_LnxWrpFmDev->txPorts[i].h_Dev);
+        for (i=0; i<FM_MAX_NUM_OF_RX_PORTS; i++)
+            if (p_LnxWrpFmDev->rxPorts[i].active && p_LnxWrpFmDev->rxPorts[i].h_Dev)
+                FM_PORT_DumpRegs(p_LnxWrpFmDev->rxPorts[i].h_Dev);
+        if (p_LnxWrpFmDev->hcPort.active && p_LnxWrpFmDev->hcPort.h_Dev)
+            FM_PORT_DumpRegs(p_LnxWrpFmDev->hcPort.h_Dev);
+    }
+
+    local_irq_restore(flags);
+    *eof = 1;
+
+    return length - size;
+
+#else
+    t_Handle    h_ProcBuff = ProcBuff_Init(buffer,start,offset,length,eof);
+    int         numOfWrittenChars;
+
+    local_irq_save(flags);
+    ProcBuff_Write (h_ProcBuff, "Debug level is too low to dump registers!!!\n");
+    numOfWrittenChars = ProcBuff_GetNumOfWrittenChars(h_ProcBuff);
+    ProcBuff_Free(h_ProcBuff);
+    local_irq_restore(flags);
+
+    return numOfWrittenChars;
+#endif /* (defined(DEBUG_ERRORS) && ... */
+}
+
+static irqreturn_t fm_irq(int irq, void *_dev)
+{
+    t_LnxWrpFmDev       *p_LnxWrpFmDev = (t_LnxWrpFmDev *)_dev;
+
+    if (!p_LnxWrpFmDev || !p_LnxWrpFmDev->h_Dev)
+        return IRQ_NONE;
+
+    FM_Isr(p_LnxWrpFmDev->h_Dev);
+
+    return IRQ_HANDLED;
+}
+
+static volatile int   hcFrmRcv = 0;
+
+static enum qman_cb_dqrr_result qm_tx_conf_dqrr_cb(struct qman_portal          *portal,
+                                                   struct qman_fq              *fq,
+                                                   const struct qm_dqrr_entry  *dq)
+{
+    t_LnxWrpFmDev       *p_LnxWrpFmDev = ((t_FmTestFq *)fq)->h_Arg;
+
+    FM_PCD_HcTxConf(p_LnxWrpFmDev->h_PcdDev, (t_FmFD *)&dq->fd);
+    hcFrmRcv--;
+
+    return qman_cb_dqrr_consume;
+}
+
+static enum qman_cb_dqrr_result qm_tx_dqrr_cb(struct qman_portal          *portal,
+                                              struct qman_fq              *fq,
+                                              const struct qm_dqrr_entry  *dq)
+{
+    BUG();
+    return qman_cb_dqrr_consume;
+}
+
+static void qm_err_cb(struct qman_portal       *portal,
+                       struct qman_fq           *fq,
+                       const struct qm_mr_entry *msg)
+{
+    BUG();
+}
+
+static struct qman_fq * FqAlloc(t_LnxWrpFmDev   *p_LnxWrpFmDev,
+                                uint32_t        fqid,
+                                uint32_t        flags,
+                                uint16_t        channel,
+                                uint8_t         wq)
+{
+    int                     _errno;
+    struct qman_fq          *fq = NULL;
+    t_FmTestFq              *p_FmtFq;
+    struct qm_mcc_initfq    initfq;
+
+    p_FmtFq = (t_FmTestFq *)XX_Malloc(sizeof(t_FmTestFq));
+    if (!p_FmtFq) {
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FQ obj!!!"));
+        return NULL;
+    }
+
+    p_FmtFq->fq_base.cb.dqrr = (QMAN_FQ_FLAG_NO_ENQUEUE ? qm_tx_conf_dqrr_cb : qm_tx_dqrr_cb);
+    p_FmtFq->fq_base.cb.ern = p_FmtFq->fq_base.cb.dc_ern = p_FmtFq->fq_base.cb.fqs = qm_err_cb;
+    p_FmtFq->h_Arg = (t_Handle)p_LnxWrpFmDev;
+    if (fqid == 0) {
+        flags |= QMAN_FQ_FLAG_DYNAMIC_FQID;
+        flags &= ~QMAN_FQ_FLAG_NO_MODIFY;
+    } else {
+        flags &= ~QMAN_FQ_FLAG_DYNAMIC_FQID;
+    }
+
+    if (qman_create_fq(fqid, flags, &p_FmtFq->fq_base)) {
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FQ obj - qman_new_fq!!!"));
+        XX_Free(p_FmtFq);
+        return NULL;
+    }
+    fq = &p_FmtFq->fq_base;
+
+    if (!(flags & QMAN_FQ_FLAG_NO_MODIFY)) {
+        initfq.we_mask            = QM_INITFQ_WE_DESTWQ;
+        initfq.fqd.dest.channel   = channel;
+        initfq.fqd.dest.wq        = wq;
+
+        _errno = qman_init_fq(fq, QMAN_INITFQ_FLAG_SCHED, &initfq);
+        if (unlikely(_errno < 0)) {
+            REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FQ obj - qman_init_fq!!!"));
+            qman_destroy_fq(fq, 0);
+            XX_Free(p_FmtFq);
+            return NULL;
+        }
+    }
+
+    DBG(TRACE, ("fqid %d, flags 0x%08x, channel %d, wq %d",qman_fq_fqid(fq),flags,channel,wq));
+
+    return fq;
+}
+
+static t_Error QmEnqueueCB (t_Handle h_Arg, uint32_t fqid, void *p_Fd)
+{
+    t_LnxWrpFmDev   *p_LnxWrpFmDev = (t_LnxWrpFmDev*)h_Arg;
+    int             _errno, timeout=1000000;
+
+    ASSERT_COND(p_LnxWrpFmDev);
+    UNUSED(fqid);
+
+    hcFrmRcv++;
+//MemDisp((uint8_t*)p_Fd,sizeof(t_FmFD));
+    _errno = qman_enqueue(p_LnxWrpFmDev->hc_tx_fq, (struct qm_fd*)p_Fd, 0);
+    if (_errno)
+        RETURN_ERROR(MINOR, E_INVALID_STATE, NO_MSG);
+
+    while (hcFrmRcv && --timeout)
+    {
+        udelay(1);
+        cpu_relax();
+    }
+    BUG_ON(!timeout);
+
+    return E_OK;
+}
+
+static t_LnxWrpFmDev * CreateFmDev(uint8_t  id)
+{
+    t_LnxWrpFmDev   *p_LnxWrpFmDev;
+    int             j;
+
+    p_LnxWrpFmDev = (t_LnxWrpFmDev *)XX_Malloc(sizeof(t_LnxWrpFmDev));
+    if (!p_LnxWrpFmDev)
+    {
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, NO_MSG);
+        return NULL;
+    }
+
+    memset(p_LnxWrpFmDev, 0, sizeof(t_LnxWrpFmDev));
+    p_LnxWrpFmDev->fmDevSettings.advConfig = (t_SysObjectAdvConfigEntry*)XX_Malloc(FM_MAX_NUM_OF_ADV_SETTINGS*sizeof(t_SysObjectAdvConfigEntry));
+    memset(p_LnxWrpFmDev->fmDevSettings.advConfig, 0, (FM_MAX_NUM_OF_ADV_SETTINGS*sizeof(t_SysObjectAdvConfigEntry)));
+    p_LnxWrpFmDev->fmPcdDevSettings.advConfig = (t_SysObjectAdvConfigEntry*)XX_Malloc(FM_MAX_NUM_OF_ADV_SETTINGS*sizeof(t_SysObjectAdvConfigEntry));
+    memset(p_LnxWrpFmDev->fmPcdDevSettings.advConfig, 0, (FM_MAX_NUM_OF_ADV_SETTINGS*sizeof(t_SysObjectAdvConfigEntry)));
+    p_LnxWrpFmDev->hcPort.settings.advConfig = (t_SysObjectAdvConfigEntry*)XX_Malloc(FM_MAX_NUM_OF_ADV_SETTINGS*sizeof(t_SysObjectAdvConfigEntry));
+    memset(p_LnxWrpFmDev->hcPort.settings.advConfig, 0, (FM_MAX_NUM_OF_ADV_SETTINGS*sizeof(t_SysObjectAdvConfigEntry)));
+    for (j=0; j<FM_MAX_NUM_OF_RX_PORTS; j++)
+    {
+        p_LnxWrpFmDev->rxPorts[j].settings.advConfig = (t_SysObjectAdvConfigEntry*)XX_Malloc(FM_MAX_NUM_OF_ADV_SETTINGS*sizeof(t_SysObjectAdvConfigEntry));
+        memset(p_LnxWrpFmDev->rxPorts[j].settings.advConfig, 0, (FM_MAX_NUM_OF_ADV_SETTINGS*sizeof(t_SysObjectAdvConfigEntry)));
+    }
+    for (j=0; j<FM_MAX_NUM_OF_TX_PORTS; j++)
+    {
+        p_LnxWrpFmDev->txPorts[j].settings.advConfig = (t_SysObjectAdvConfigEntry*)XX_Malloc(FM_MAX_NUM_OF_ADV_SETTINGS*sizeof(t_SysObjectAdvConfigEntry));
+        memset(p_LnxWrpFmDev->txPorts[j].settings.advConfig, 0, (FM_MAX_NUM_OF_ADV_SETTINGS*sizeof(t_SysObjectAdvConfigEntry)));
+    }
+    for (j=0; j<FM_MAX_NUM_OF_OP_PORTS; j++)
+    {
+        p_LnxWrpFmDev->opPorts[j].settings.advConfig = (t_SysObjectAdvConfigEntry*)XX_Malloc(FM_MAX_NUM_OF_ADV_SETTINGS*sizeof(t_SysObjectAdvConfigEntry));
+        memset(p_LnxWrpFmDev->opPorts[j].settings.advConfig, 0, (FM_MAX_NUM_OF_ADV_SETTINGS*sizeof(t_SysObjectAdvConfigEntry)));
+    }
+
+    return p_LnxWrpFmDev;
+}
+
+static void DistroyFmDev(t_LnxWrpFmDev *p_LnxWrpFmDev)
+{
+    int             j;
+
+    for (j=0; j<FM_MAX_NUM_OF_OP_PORTS; j++)
+        if (p_LnxWrpFmDev->opPorts[j].settings.advConfig)
+            XX_Free(p_LnxWrpFmDev->opPorts[j].settings.advConfig);
+    for (j=0; j<FM_MAX_NUM_OF_TX_PORTS; j++)
+        if (p_LnxWrpFmDev->txPorts[j].settings.advConfig)
+            XX_Free(p_LnxWrpFmDev->txPorts[j].settings.advConfig);
+    for (j=0; j<FM_MAX_NUM_OF_RX_PORTS; j++)
+        if (p_LnxWrpFmDev->rxPorts[j].settings.advConfig)
+            XX_Free(p_LnxWrpFmDev->rxPorts[j].settings.advConfig);
+    if (p_LnxWrpFmDev->hcPort.settings.advConfig)
+        XX_Free(p_LnxWrpFmDev->hcPort.settings.advConfig);
+    if (p_LnxWrpFmDev->fmPcdDevSettings.advConfig)
+        XX_Free(p_LnxWrpFmDev->fmPcdDevSettings.advConfig);
+    if (p_LnxWrpFmDev->fmDevSettings.advConfig)
+        XX_Free(p_LnxWrpFmDev->fmDevSettings.advConfig);
+
+#ifdef NO_OF_SUPPORT
+    memset(p_LnxWrpFmDev, 0, sizeof(t_LnxWrpFmDev));
+#else
+    XX_Free(p_LnxWrpFmDev);
+#endif /* NO_OF_SUPPORT */
+}
+
+static t_Error FillRestFmInfo(t_LnxWrpFmDev *p_LnxWrpFmDev)
+{
+#define FM_BMI_PPIDS_OFFSET                 0x00080304
+#define FM_DMA_PLR_OFFSET                   0x000c2060
+#define DMA_HIGH_LIODN_MASK                 0x0FFF0000
+#define DMA_LOW_LIODN_MASK                  0x00000FFF
+#define DMA_LIODN_SHIFT                     16
+
+typedef _Packed struct {
+    uint32_t    plr[32];
+} _PackedType t_Plr;
+
+typedef _Packed struct {
+   volatile uint32_t   fmbm_ppid[63];
+} _PackedType t_Ppids;
+
+    t_Plr   *p_Plr;
+    t_Ppids *p_Ppids;
+    int     i;
+    uint8_t physPortId[] = {0x8,0x9,0xa,0xb,0x10};
+
+    p_Plr = CAST_UINT64_TO_POINTER_TYPE(t_Plr, (p_LnxWrpFmDev->fmBaseAddr+FM_DMA_PLR_OFFSET));
+#ifdef MODULE
+    for (i=0;i<FM_MAX_NUM_OF_PARTITIONS/2;i++)
+        p_Plr->plr[i] = 0;
+#endif /* MODULE */
+
+    for (i=0; i<FM_MAX_NUM_OF_PARTITIONS; i++)
+        p_LnxWrpFmDev->fmDevSettings.param.liodnPerPartition[i] = (i%2) ?
+            (p_Plr->plr[i/2] & DMA_LOW_LIODN_MASK) :
+            ((p_Plr->plr[i/2] & DMA_HIGH_LIODN_MASK) >> DMA_LIODN_SHIFT);
+
+    p_Ppids = CAST_UINT64_TO_POINTER_TYPE(t_Ppids, (p_LnxWrpFmDev->fmBaseAddr+FM_BMI_PPIDS_OFFSET));
+
+    for (i=0; i<FM_MAX_NUM_OF_RX_PORTS; i++)
+        p_LnxWrpFmDev->rxPorts[i].settings.param.specificParams.rxParams.rxPartitionId =
+            p_Ppids->fmbm_ppid[physPortId[i]-1];
+
+    return E_OK;
+}
+
+#ifndef NO_OF_SUPPORT
+/* The default address for the Fman microcode in flash. Having a default
+ * allows older systems to continue functioning.  0xEF000000 is the address
+ * where the firmware is normally on a P4080DS.
+ */
+static phys_addr_t P4080_UCAddr = 0xef000000;
+
+
+/**
+ * FmanUcodeAddrParam - process the fman_ucode kernel command-line parameter
+ *
+ * This function is called when the kernel encounters a fman_ucode command-
+ * line parameter.  This parameter contains the address of the Fman microcode
+ * in flash.
+ */
+static int FmanUcodeAddrParam(char *str)
+{
+    unsigned long long l;
+    int ret;
+
+    ret = strict_strtoull(str, 0, &l);
+    if (!ret)
+        P4080_UCAddr = (phys_addr_t) l;
+
+    return ret;
+}
+__setup("fman_ucode=", FmanUcodeAddrParam);
+
+/**
+ * FindFmanMicrocode - find the Fman micrcode in memory
+ *
+ * This function returns a pointer to the QE Firmware blob that holds
+ * the Fman microcode.  We use the QE Firmware structure because Fman microcode
+ * is similar to QE microcode, so there's no point in defining a new layout.
+ *
+ * We also never iounmap() the memory because we might reset the Fman at any
+ * time.
+ */
+static struct qe_firmware *FindFmanMicrocode(void)
+{
+    static struct qe_firmware *P4080_UCPatch;
+
+    if (!P4080_UCPatch) {
+        unsigned long P4080_UCSize;
+        struct qe_header *hdr;
+
+        /* Only map enough to the get the core structure */
+        P4080_UCPatch = ioremap(P4080_UCAddr, sizeof(struct qe_firmware));
+        if (!P4080_UCPatch) {
+            REPORT_ERROR(MAJOR, E_NULL_POINTER, ("ioremap(%llx) returned NULL", (u64) P4080_UCAddr));
+            return NULL;
+        }
+
+        /* Make sure it really is a QE Firmware blob */
+        hdr = &P4080_UCPatch->header;
+        if (!hdr ||
+            (hdr->magic[0] != 'Q') || (hdr->magic[1] != 'E') ||
+            (hdr->magic[2] != 'F')) {
+            REPORT_ERROR(MAJOR, E_NOT_FOUND, ("data at %llx is not a Fman microcode", (u64) P4080_UCAddr));
+            return NULL;
+        }
+
+        /* Now we call ioremap again, this time to pick up the whole blob */
+        P4080_UCSize = sizeof(u32) * P4080_UCPatch->microcode[0].count;
+        iounmap(P4080_UCPatch);
+        P4080_UCPatch = ioremap(P4080_UCAddr, P4080_UCSize);
+        if (!P4080_UCPatch) {
+            REPORT_ERROR(MAJOR, E_NULL_POINTER, ("ioremap(%llx) returned NULL", (u64) P4080_UCAddr));
+            return NULL;
+        }
+    }
+
+    return P4080_UCPatch;
+}
+
+static t_LnxWrpFmDev * ReadFmDevTreeNode (struct of_device *of_dev)
+{
+    t_LnxWrpFmDev       *p_LnxWrpFmDev;
+    struct device_node  *fm_node, *dev_node, *dpa_node;
+    struct of_device_id name;
+    struct resource     res;
+    const uint32_t      *uint32_prop;
+    int                 _errno=0, lenp;
+
+    fm_node = of_dev->node;
+
+    uint32_prop = (uint32_t *)of_get_property(fm_node, "cell-index", &lenp);
+    if (unlikely(uint32_prop == NULL)) {
+        REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("of_get_property(%s, cell-index) failed", fm_node->full_name));
+        return NULL;
+    }
+    BUG_ON(lenp != sizeof(uint32_t));
+    if (*uint32_prop > INTG_MAX_NUM_OF_FM) {
+        REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("fm id!"));
+        return NULL;
+    }
+    p_LnxWrpFmDev = CreateFmDev(*uint32_prop);
+    if (!p_LnxWrpFmDev) {
+        REPORT_ERROR(MAJOR, E_NULL_POINTER, NO_MSG);
+        return NULL;
+    }
+    p_LnxWrpFmDev->dev = &of_dev->dev;
+    p_LnxWrpFmDev->id = *uint32_prop;
+
+    /* Get the FM interrupt */
+    p_LnxWrpFmDev->irq1 = of_irq_to_resource(fm_node, 0, NULL);
+    if (unlikely(p_LnxWrpFmDev->irq1 == NO_IRQ)) {
+        REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("of_irq_to_resource() = %d", NO_IRQ));
+        return NULL;
+    }
+
+    /* Get the FM address */
+    _errno = of_address_to_resource(fm_node, 0, &res);
+    if (unlikely(_errno < 0)) {
+        REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("of_address_to_resource() = %d", _errno));
+        return NULL;
+    }
+
+    p_LnxWrpFmDev->fmBaseAddr = res.start;
+    p_LnxWrpFmDev->fmMemSize = res.end + 1 - res.start;
+
+    uint32_prop = (uint32_t *)of_get_property(fm_node, "clock-frequency", &lenp);
+    if (unlikely(uint32_prop == NULL)) {
+        REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("of_get_property(%s, clock-frequency) failed", fm_node->full_name));
+        return NULL;
+    }
+    BUG_ON(lenp != sizeof(uint32_t));
+    p_LnxWrpFmDev->fmDevSettings.param.fmClkFreq = *uint32_prop;
+
+    /* Get the MURAM base address and size */
+    memset(&name, 0, sizeof(struct of_device_id));
+    BUG_ON(strlen("muram") >= sizeof(name.name));
+    strcpy(name.name, "muram");
+    BUG_ON(strlen("fsl,fman-muram") >= sizeof(name.compatible));
+    strcpy(name.compatible, "fsl,fman-muram");
+    for_each_child_of_node(fm_node, dev_node) {
+        if (likely(of_match_node(&name, dev_node) != NULL)) {
+            _errno = of_address_to_resource(dev_node, 0, &res);
+            if (unlikely(_errno < 0)) {
+                REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("of_address_to_resource() = %d", _errno));
+                return NULL;
+            }
+
+            p_LnxWrpFmDev->fmMuramBaseAddr = res.start;
+            p_LnxWrpFmDev->fmMuramMemSize = res.end + 1 - res.start;
+        }
+    }
+
+    /* Get all PCD nodes */
+    memset(&name, 0, sizeof(struct of_device_id));
+    BUG_ON(strlen("parser") >= sizeof(name.name));
+    strcpy(name.name, "parser");
+    BUG_ON(strlen("fsl,fman-parser") >= sizeof(name.compatible));
+    strcpy(name.compatible, "fsl,fman-parser");
+    for_each_child_of_node(fm_node, dev_node)
+        if (likely(of_match_node(&name, dev_node) != NULL))
+            p_LnxWrpFmDev->prsActive = TRUE;
+
+    memset(&name, 0, sizeof(struct of_device_id));
+    BUG_ON(strlen("keygen") >= sizeof(name.name));
+    strcpy(name.name, "keygen");
+    BUG_ON(strlen("fsl,fman-keygen") >= sizeof(name.compatible));
+    strcpy(name.compatible, "fsl,fman-keygen");
+    for_each_child_of_node(fm_node, dev_node)
+        if (likely(of_match_node(&name, dev_node) != NULL))
+            p_LnxWrpFmDev->kgActive = TRUE;
+
+    memset(&name, 0, sizeof(struct of_device_id));
+    BUG_ON(strlen("cc") >= sizeof(name.name));
+    strcpy(name.name, "cc");
+    BUG_ON(strlen("fsl,fman-cc") >= sizeof(name.compatible));
+    strcpy(name.compatible, "fsl,fman-cc");
+    for_each_child_of_node(fm_node, dev_node)
+        if (likely(of_match_node(&name, dev_node) != NULL))
+            p_LnxWrpFmDev->ccActive = TRUE;
+
+    memset(&name, 0, sizeof(struct of_device_id));
+    BUG_ON(strlen("policer") >= sizeof(name.name));
+    strcpy(name.name, "policer");
+    BUG_ON(strlen("fsl,fman-policer") >= sizeof(name.compatible));
+    strcpy(name.compatible, "fsl,fman-policer");
+    for_each_child_of_node(fm_node, dev_node)
+        if (likely(of_match_node(&name, dev_node) != NULL))
+            p_LnxWrpFmDev->plcrActive = TRUE;
+
+    if (p_LnxWrpFmDev->prsActive || p_LnxWrpFmDev->kgActive ||
+        p_LnxWrpFmDev->ccActive || p_LnxWrpFmDev->plcrActive)
+        p_LnxWrpFmDev->pcdActive = TRUE;
+
+    if (p_LnxWrpFmDev->pcdActive)
+    {
+        const char *str_prop = (char *)of_get_property(fm_node, "fsl,default-pcd", &lenp);
+        if (str_prop) {
+            if (strncmp(str_prop, "3-tuple", strlen("3-tuple")) == 0)
+                p_LnxWrpFmDev->defPcd = e_FM_PCD_3_TUPLE;
+        }
+        else
+            p_LnxWrpFmDev->defPcd = e_NO_PCD;
+    }
+
+    of_node_put(fm_node);
+
+    memset(&name, 0, sizeof(struct of_device_id));
+    BUG_ON(strlen("fsl,dpa-ethernet") >= sizeof(name.compatible));
+    strcpy(name.compatible, "fsl,dpa-ethernet");
+    for_each_matching_node(dpa_node, &name) {
+        struct device_node  *mac_node;
+        const phandle       *phandle_prop;
+
+        phandle_prop = (typeof(phandle_prop))of_get_property(dpa_node, "fsl,fman-mac", &lenp);
+        if (phandle_prop == NULL)
+            continue;
+
+        BUG_ON(lenp != sizeof(phandle));
+
+        mac_node = of_find_node_by_phandle(*phandle_prop);
+        if (unlikely(mac_node == NULL)) {
+            REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("of_find_node_by_phandle() failed"));
+            return NULL;
+        }
+
+        fm_node = of_get_parent(mac_node);
+        if (unlikely(fm_node == NULL)) {
+            REPORT_ERROR(MAJOR, E_NO_DEVICE, ("of_get_parent() = %d", _errno));
+            return NULL;
+        }
+        of_node_put(mac_node);
+
+        uint32_prop = (uint32_t *)of_get_property(fm_node, "cell-index", &lenp);
+        if (unlikely(uint32_prop == NULL)) {
+            REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("of_get_property(%s, cell-index) failed", fm_node->full_name));
+            return NULL;
+        }
+        BUG_ON(lenp != sizeof(uint32_t));
+
+        if (*uint32_prop == p_LnxWrpFmDev->id) {
+            phandle_prop = (typeof(phandle_prop))of_get_property(dpa_node, "fsl,qman-channel", &lenp);
+            if (unlikely(phandle_prop == NULL)) {
+                REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("of_get_property(%s, fsl,qman-channel) failed", dpa_node->full_name));
+                return NULL;
+            }
+            BUG_ON(lenp != sizeof(phandle));
+
+            dev_node = of_find_node_by_phandle(*phandle_prop);
+            if (unlikely(dev_node == NULL)) {
+                REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("of_find_node_by_phandle() failed"));
+                return NULL;
+            }
+
+            uint32_prop = (typeof(uint32_prop))of_get_property(dev_node, "fsl,qman-channel-id", &lenp);
+            if (unlikely(uint32_prop == NULL)) {
+                REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("of_get_property(%s, fsl,qman-channel-id) failed", dev_node->full_name));
+                of_node_put(dev_node);
+                return NULL;
+            }
+            of_node_put(dev_node);
+            BUG_ON(lenp != sizeof(uint32_t));
+            p_LnxWrpFmDev->hcCh = *uint32_prop;
+            break;
+        }
+
+        of_node_put(fm_node);
+    }
+
+    /* Loading the fman-controller code */
+    if (p_LnxWrpFmDev->ccActive) {
+        struct qe_firmware *fw = FindFmanMicrocode();
+
+        if (!fw)
+            /* We already reported an error, so just return NULL*/
+            return NULL;
+
+        p_LnxWrpFmDev->fmDevSettings.param.firmware.p_Code =
+            (void *) fw + fw->microcode[0].code_offset;
+        p_LnxWrpFmDev->fmDevSettings.param.firmware.size =
+            sizeof(u32) * fw->microcode[0].count;
+        DBG(INFO, ("Loading fman-controller code version %d.%d.%d",
+                   fw->microcode[0].major,
+                   fw->microcode[0].minor,
+                   fw->microcode[0].revision));
+    }
+
+    p_LnxWrpFmDev->active = TRUE;
+
+    return p_LnxWrpFmDev;
+}
+
+static t_LnxWrpFmPortDev * ReadFmPortDevTreeNode (struct of_device *of_dev)
+{
+    t_LnxWrpFmDev       *p_LnxWrpFmDev;
+    t_LnxWrpFmPortDev   *p_LnxWrpFmPortDev;
+    struct device_node  *fm_node, *port_node;
+    struct resource     res;
+    const uint32_t      *uint32_prop;
+    int                 _errno=0, lenp;
+
+    port_node = of_dev->node;
+
+    /* Get the FM node */
+    fm_node = of_get_parent(port_node);
+    if (unlikely(fm_node == NULL)) {
+        REPORT_ERROR(MAJOR, E_NO_DEVICE, ("of_get_parent() = %d", _errno));
+        return NULL;
+    }
+
+    p_LnxWrpFmDev = dev_get_drvdata(&of_find_device_by_node(fm_node)->dev);
+    of_node_put(fm_node);
+
+    uint32_prop = (uint32_t *)of_get_property(port_node, "cell-index", &lenp);
+    if (unlikely(uint32_prop == NULL)) {
+        REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("of_get_property(%s, cell-index) failed", port_node->full_name));
+        return NULL;
+    }
+    BUG_ON(lenp != sizeof(uint32_t));
+    if (of_device_is_compatible(port_node, "fsl,fman-port-oh")) {
+        if (unlikely(*uint32_prop >= FM_MAX_NUM_OF_OP_PORTS+1)) {
+            REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("of_get_property(%s, cell-index) failed", port_node->full_name));
+            return NULL;
+        }
+
+        if (*uint32_prop == 0) {
+            p_LnxWrpFmPortDev = &p_LnxWrpFmDev->hcPort;
+            p_LnxWrpFmPortDev->id = 0;
+            p_LnxWrpFmPortDev->settings.param.portType = e_FM_PORT_TYPE_HOST_COMMAND;
+        }
+        else {
+            p_LnxWrpFmPortDev = &p_LnxWrpFmDev->opPorts[*uint32_prop-1];
+            p_LnxWrpFmPortDev->id = *uint32_prop-1;
+            p_LnxWrpFmPortDev->settings.param.portType = e_FM_PORT_TYPE_OFFLINE_PARSING;
+        }
+        p_LnxWrpFmPortDev->settings.param.portId = p_LnxWrpFmPortDev->id;
+
+        uint32_prop = (uint32_t *)of_get_property(port_node, "fsl,qman-channel-id", &lenp);
+        if (uint32_prop == NULL) {
+            REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("missing fsl,qman-channel-id"));
+            return NULL;
+        }
+        BUG_ON(lenp != sizeof(uint32_t));
+        p_LnxWrpFmPortDev->txCh = *uint32_prop;
+        p_LnxWrpFmPortDev->settings.param.specificParams.nonRxParams.deqSubPortal = (p_LnxWrpFmPortDev->txCh & 0x1f);
+    }
+    else if (of_device_is_compatible(port_node, "fsl,fman-port-1g-tx") ||
+             of_device_is_compatible(port_node, "fsl,fman-port-10g-tx")) {
+        if (unlikely(*uint32_prop >= FM_MAX_NUM_OF_TX_PORTS)) {
+            REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("of_get_property(%s, cell-index) failed", port_node->full_name));
+            return NULL;
+        }
+        if (of_device_is_compatible(port_node, "fsl,fman-port-10g-tx"))
+            p_LnxWrpFmPortDev = &p_LnxWrpFmDev->txPorts[*uint32_prop+FM_MAX_NUM_OF_1G_TX_PORTS];
+        else
+            p_LnxWrpFmPortDev = &p_LnxWrpFmDev->txPorts[*uint32_prop];
+
+        p_LnxWrpFmPortDev->id = *uint32_prop;
+        p_LnxWrpFmPortDev->settings.param.portId = p_LnxWrpFmPortDev->id;
+        if (of_device_is_compatible(port_node, "fsl,fman-port-10g-tx"))
+            p_LnxWrpFmPortDev->settings.param.portType = e_FM_PORT_TYPE_TX_10G;
+        else
+            p_LnxWrpFmPortDev->settings.param.portType = e_FM_PORT_TYPE_TX;
+
+        uint32_prop = (uint32_t *)of_get_property(port_node, "fsl,qman-channel-id", &lenp);
+        if (uint32_prop == NULL) {
+            REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("missing fsl,qman-channel-id"));
+            return NULL;
+        }
+        BUG_ON(lenp != sizeof(uint32_t));
+        p_LnxWrpFmPortDev->txCh = *uint32_prop;
+        p_LnxWrpFmPortDev->settings.param.specificParams.nonRxParams.deqSubPortal = (p_LnxWrpFmPortDev->txCh & 0x1f);
+    }
+    else if (of_device_is_compatible(port_node, "fsl,fman-port-1g-rx") ||
+             of_device_is_compatible(port_node, "fsl,fman-port-10g-rx")) {
+        if (unlikely(*uint32_prop >= FM_MAX_NUM_OF_RX_PORTS)) {
+            REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("of_get_property(%s, cell-index) failed", port_node->full_name));
+            return NULL;
+        }
+        if (of_device_is_compatible(port_node, "fsl,fman-port-10g-rx"))
+            p_LnxWrpFmPortDev = &p_LnxWrpFmDev->rxPorts[*uint32_prop+FM_MAX_NUM_OF_1G_RX_PORTS];
+        else
+            p_LnxWrpFmPortDev = &p_LnxWrpFmDev->rxPorts[*uint32_prop];
+
+        p_LnxWrpFmPortDev->id = *uint32_prop;
+        p_LnxWrpFmPortDev->settings.param.portId = p_LnxWrpFmPortDev->id;
+        if (of_device_is_compatible(port_node, "fsl,fman-port-10g-rx"))
+            p_LnxWrpFmPortDev->settings.param.portType = e_FM_PORT_TYPE_RX_10G;
+        else
+            p_LnxWrpFmPortDev->settings.param.portType = e_FM_PORT_TYPE_RX;
+
+        if (p_LnxWrpFmDev->pcdActive)
+            p_LnxWrpFmPortDev->defPcd = p_LnxWrpFmDev->defPcd;
+    }
+    else {
+        REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("Illegal port type"));
+        return NULL;
+    }
+
+    _errno = of_address_to_resource(port_node, 0, &res);
+    if (unlikely(_errno < 0)) {
+        REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("of_address_to_resource() = %d", _errno));
+        return NULL;
+    }
+
+    p_LnxWrpFmPortDev->dev = &of_dev->dev;
+    p_LnxWrpFmPortDev->baseAddr = res.start;
+    p_LnxWrpFmPortDev->memSize = res.end + 1 - res.start;
+    p_LnxWrpFmPortDev->settings.param.h_Fm = p_LnxWrpFmDev->h_Dev;
+    p_LnxWrpFmPortDev->h_LnxWrpFmDev = (t_Handle)p_LnxWrpFmDev;
+
+    of_node_put(port_node);
+
+    p_LnxWrpFmPortDev->active = TRUE;
+
+    return p_LnxWrpFmPortDev;
+}
+#endif /* !NO_OF_SUPPORT */
+
+static void LnxwrpFmDevExceptionsCb(t_Handle h_App, e_FmExceptions exception)
+{
+    t_LnxWrpFmDev       *p_LnxWrpFmDev = (t_LnxWrpFmDev *)h_App;
+
+    ASSERT_COND(p_LnxWrpFmDev);
+
+    DBG(INFO, ("got fm exception %d", exception));
+
+    /* do nothing */
+    UNUSED(exception);
+}
+
+static void LnxwrpFmDevBusErrorCb(t_Handle        h_App,
+                                  e_FmPortType    portType,
+                                  uint8_t         portId,
+                                  uint64_t        addr,
+                                  uint8_t         tnum,
+                                  uint8_t         partition)
+{
+    t_LnxWrpFmDev       *p_LnxWrpFmDev = (t_LnxWrpFmDev *)h_App;
+
+    ASSERT_COND(p_LnxWrpFmDev);
+
+    /* do nothing */
+    UNUSED(portType);UNUSED(portId);UNUSED(addr);UNUSED(tnum);UNUSED(partition);
+}
+
+static void LnxwrpFmPcdDevExceptionsCb( t_Handle h_App, e_FmPcdExceptions exception)
+{
+    t_LnxWrpFmDev       *p_LnxWrpFmDev = (t_LnxWrpFmDev *)h_App;
+
+    ASSERT_COND(p_LnxWrpFmDev);
+
+    DBG(INFO, ("got fm-pcd exception %d", exception));
+
+    /* do nothing */
+    UNUSED(exception);
+}
+
+static void LnxwrpFmPcdDevIndexedExceptionsCb(t_Handle          h_App,
+                                              e_FmPcdExceptions exception,
+                                              uint16_t          index)
+{
+    t_LnxWrpFmDev       *p_LnxWrpFmDev = (t_LnxWrpFmDev *)h_App;
+
+    ASSERT_COND(p_LnxWrpFmDev);
+
+    DBG(INFO, ("got fm-pcd-indexed exception %d, indx %d", exception, index));
+
+    /* do nothing */
+    UNUSED(exception);UNUSED(index);
+}
+
+static t_Error ConfigureFmDev(t_LnxWrpFmDev  *p_LnxWrpFmDev)
+{
+    struct resource     *dev_res;
+    int                 _errno;
+    uint32_t            fmPhysAddr, muramPhysAddr;
+
+    if (!p_LnxWrpFmDev->active)
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("FM not configured!!!"));
+
+    _errno = can_request_irq(p_LnxWrpFmDev->irq1, 0);
+    if (unlikely(_errno < 0))
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("can_request_irq() = %d", _errno));
+    _errno = devm_request_irq(p_LnxWrpFmDev->dev, p_LnxWrpFmDev->irq1, fm_irq, 0, "fman", p_LnxWrpFmDev);
+    if (unlikely(_errno < 0))
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("request_irq(%d) = %d", p_LnxWrpFmDev->irq1, _errno));
+
+    fmPhysAddr = p_LnxWrpFmDev->fmBaseAddr;
+    p_LnxWrpFmDev->res = devm_request_mem_region(p_LnxWrpFmDev->dev, p_LnxWrpFmDev->fmBaseAddr, p_LnxWrpFmDev->fmMemSize, "fman");
+    if (unlikely(p_LnxWrpFmDev->res == NULL))
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("request_mem_region() failed"));
+
+    p_LnxWrpFmDev->fmBaseAddr = CAST_POINTER_TO_UINT64(devm_ioremap(p_LnxWrpFmDev->dev, p_LnxWrpFmDev->fmBaseAddr, p_LnxWrpFmDev->fmMemSize));
+    if (unlikely(p_LnxWrpFmDev->fmBaseAddr == 0))
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("devm_ioremap() failed"));
+
+    muramPhysAddr = p_LnxWrpFmDev->fmMuramBaseAddr;
+    dev_res = __devm_request_region(p_LnxWrpFmDev->dev, p_LnxWrpFmDev->res, p_LnxWrpFmDev->fmMuramBaseAddr, p_LnxWrpFmDev->fmMuramMemSize, "fman-muram");
+    if (unlikely(dev_res == NULL))
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("__devm_request_region() failed"));
+
+    p_LnxWrpFmDev->fmMuramBaseAddr = CAST_POINTER_TO_UINT64(devm_ioremap(p_LnxWrpFmDev->dev, p_LnxWrpFmDev->fmMuramBaseAddr, p_LnxWrpFmDev->fmMuramMemSize));
+    if (unlikely(p_LnxWrpFmDev->fmMuramBaseAddr == 0))
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("devm_ioremap() failed"));
+
+    if (SYS_RegisterIoMap((uint64_t)p_LnxWrpFmDev->fmMuramBaseAddr, (uint64_t)muramPhysAddr, p_LnxWrpFmDev->fmMuramMemSize) != E_OK)
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("FM MURAM memory map"));
+
+    if (SYS_RegisterIoMap((uint64_t)p_LnxWrpFmDev->fmBaseAddr, (uint64_t)fmPhysAddr, p_LnxWrpFmDev->fmMemSize) != E_OK)
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("FM memory map"));
+
+    p_LnxWrpFmDev->fmDevSettings.param.baseAddr     = p_LnxWrpFmDev->fmBaseAddr;
+    p_LnxWrpFmDev->fmDevSettings.param.fmId         = p_LnxWrpFmDev->id;
+    p_LnxWrpFmDev->fmDevSettings.param.irq          = NO_IRQ;
+    p_LnxWrpFmDev->fmDevSettings.param.errIrq       = NO_IRQ;
+    p_LnxWrpFmDev->fmDevSettings.param.f_Exceptions = LnxwrpFmDevExceptionsCb;
+    p_LnxWrpFmDev->fmDevSettings.param.f_BusError   = LnxwrpFmDevBusErrorCb;
+    p_LnxWrpFmDev->fmDevSettings.param.h_App        = p_LnxWrpFmDev;
+
+    return FillRestFmInfo(p_LnxWrpFmDev);
+}
+
+static t_Error ConfigureFmPortDev(t_LnxWrpFmPortDev *p_LnxWrpFmPortDev)
+{
+    t_LnxWrpFmDev       *p_LnxWrpFmDev = (t_LnxWrpFmDev *)p_LnxWrpFmPortDev->h_LnxWrpFmDev;
+    struct resource     *dev_res;
+
+    if (!p_LnxWrpFmPortDev->active)
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("FM port not configured!!!"));
+
+    dev_res = __devm_request_region(p_LnxWrpFmDev->dev, p_LnxWrpFmDev->res, p_LnxWrpFmPortDev->baseAddr, p_LnxWrpFmPortDev->memSize, "fman-port-hc");
+    if (unlikely(dev_res == NULL))
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("__devm_request_region() failed"));
+    p_LnxWrpFmPortDev->baseAddr = CAST_POINTER_TO_UINT64(devm_ioremap(p_LnxWrpFmDev->dev, p_LnxWrpFmPortDev->baseAddr, p_LnxWrpFmPortDev->memSize));
+    if (unlikely(p_LnxWrpFmPortDev->baseAddr == 0))
+        REPORT_ERROR(MAJOR, E_INVALID_STATE, ("devm_ioremap() failed"));
+
+    p_LnxWrpFmPortDev->settings.param.baseAddr = p_LnxWrpFmPortDev->baseAddr;
+
+    return E_OK;
+}
+
+static t_Error InitFmPcdDev(t_LnxWrpFmDev  *p_LnxWrpFmDev)
+{
+    if (p_LnxWrpFmDev->pcdActive)
+    {
+        t_LnxWrpFmPortDev   *p_LnxWrpFmPortDev = &p_LnxWrpFmDev->hcPort;
+        t_FmPcdParams       fmPcdParams;
+        t_Error             err;
+
+        memset(&fmPcdParams, 0, sizeof(fmPcdParams));
+        fmPcdParams.h_Fm        = p_LnxWrpFmDev->h_Dev;
+        fmPcdParams.h_FmMuram   = p_LnxWrpFmDev->h_MuramDev;
+        fmPcdParams.prsSupport  = p_LnxWrpFmDev->prsActive;
+        fmPcdParams.kgSupport   = p_LnxWrpFmDev->kgActive;
+        fmPcdParams.plcrSupport = p_LnxWrpFmDev->plcrActive;
+        fmPcdParams.ccSupport   = p_LnxWrpFmDev->ccActive;
+
+#ifndef CONFIG_GUEST_PARTITION
+        fmPcdParams.f_FmPcdException   = LnxwrpFmPcdDevExceptionsCb;
+        if (fmPcdParams.kgSupport)
+            fmPcdParams.f_FmPcdIdException = LnxwrpFmPcdDevIndexedExceptionsCb;
+        fmPcdParams.h_App              = p_LnxWrpFmDev;
+#endif /* !CONFIG_GUEST_PARTITION */
+
+#ifdef CONFIG_MULTI_PARTITION_SUPPORT
+        fmPcdParams.numOfSchemes = 0;
+        fmPcdParams.numOfClsPlanEntries = 0;
+        fmPcdParams.partitionId = 0;
+#endif  /* CONFIG_MULTI_PARTITION_SUPPORT */
+        fmPcdParams.useHostCommand = TRUE;
+        p_LnxWrpFmDev->hc_tx_fq  =
+            FqAlloc(p_LnxWrpFmDev,
+                    0,
+                    QMAN_FQ_FLAG_TO_DCPORTAL,
+                    p_LnxWrpFmPortDev->txCh,
+                    0);
+        p_LnxWrpFmDev->hc_tx_conf_fq  =
+            FqAlloc(p_LnxWrpFmDev,
+                    0,
+                    QMAN_FQ_FLAG_NO_ENQUEUE,
+                    p_LnxWrpFmDev->hcCh,
+                    7);
+        p_LnxWrpFmDev->hc_tx_err_fq  =
+            FqAlloc(p_LnxWrpFmDev,
+                    0,
+                    QMAN_FQ_FLAG_NO_ENQUEUE,
+                    p_LnxWrpFmDev->hcCh,
+                    7);
+
+        fmPcdParams.hc.portBaseAddr = p_LnxWrpFmPortDev->baseAddr;
+        fmPcdParams.hc.portId = p_LnxWrpFmPortDev->id;
+        fmPcdParams.hc.errFqid = qman_fq_fqid(p_LnxWrpFmDev->hc_tx_err_fq);
+        fmPcdParams.hc.confFqid = qman_fq_fqid(p_LnxWrpFmDev->hc_tx_conf_fq);
+        fmPcdParams.hc.deqSubPortal = (p_LnxWrpFmPortDev->txCh & 0x1f);
+        fmPcdParams.hc.enqFqid = qman_fq_fqid(p_LnxWrpFmDev->hc_tx_fq);
+        fmPcdParams.hc.f_QmEnqueueCB = QmEnqueueCB;
+        fmPcdParams.hc.h_QmArg = (t_Handle)p_LnxWrpFmDev;
+
+        p_LnxWrpFmDev->h_PcdDev = FM_PCD_Config(&fmPcdParams);
+        if(!p_LnxWrpFmDev->h_PcdDev)
+            RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("FM PCD!"));
+
+        if((err = FM_PCD_ConfigPlcrNumOfSharedProfiles(p_LnxWrpFmDev->h_PcdDev,
+                                                       LNXWRP_FM_NUM_OF_SHARED_PROFILES))!= E_OK)
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+
+        if((err = FM_PCD_Init(p_LnxWrpFmDev->h_PcdDev))!= E_OK)
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
+
+    return E_OK;
+}
+
+static t_Error InitFmDev(t_LnxWrpFmDev  *p_LnxWrpFmDev)
+{
+    if (!p_LnxWrpFmDev->active)
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("FM not configured!!!"));
+
+    if ((p_LnxWrpFmDev->h_MuramDev = FM_MURAM_ConfigAndInit(p_LnxWrpFmDev->fmMuramBaseAddr, p_LnxWrpFmDev->fmMuramMemSize)) == NULL)
+        RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("FM-MURAM!"));
+
+    p_LnxWrpFmDev->fmDevSettings.param.h_FmMuram = p_LnxWrpFmDev->h_MuramDev;
+
+    if ((p_LnxWrpFmDev->h_Dev = FM_Config(&p_LnxWrpFmDev->fmDevSettings.param)) == NULL)
+        RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("FM"));
+
+    if (FM_ConfigResetOnInit(p_LnxWrpFmDev->h_Dev, TRUE) != E_OK)
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("FM"));
+
+    if (FM_Init(p_LnxWrpFmDev->h_Dev) != E_OK)
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("FM"));
+
+//    return InitFmPcdDev(p_LnxWrpFmDev);
+    return E_OK;
+}
+
+static t_Error InitFmPort3TupleDefPcd(t_LnxWrpFmPortDev *p_LnxWrpFmPortDev)
+{
+    t_LnxWrpFmDev                       *p_LnxWrpFmDev = (t_LnxWrpFmDev *)p_LnxWrpFmPortDev->h_LnxWrpFmDev;
+    t_FmPcdNetEnvParams                 netEnvParam;
+    t_FmPcdKgSchemeParams               schemeParam;
+    t_FmPortPcdParams                   pcdParam;
+    t_FmPortPcdPrsParams                prsParam;
+    t_FmPortPcdKgParams                 kgParam;
+    uint8_t                             i, j;
+
+    if (!p_LnxWrpFmDev->kgActive)
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("keygen must be enabled for 3-tuple PCD!"));
+
+    if (!p_LnxWrpFmDev->prsActive)
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("parser must be enabled for 3-tuple PCD!"));
+
+    if (p_LnxWrpFmPortDev->pcdNumOfQs < 9)
+        RETURN_ERROR(MINOR, E_INVALID_VALUE, ("Need to save at least 18 queues for 3-tuple PCD!!!"));
+
+    p_LnxWrpFmPortDev->totalNumOfSchemes = p_LnxWrpFmPortDev->numOfSchemesUsed = 2;
+
+    if (AllocSchemesForPort(p_LnxWrpFmDev, p_LnxWrpFmPortDev->totalNumOfSchemes, &p_LnxWrpFmPortDev->schemesBase) != E_OK)
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("No schemes for Rx or OP port for 3-tuple PCD!!!"));
+
+    /* set netEnv */
+    memset(&netEnvParam, 0, sizeof(t_FmPcdNetEnvParams));
+    netEnvParam.numOfDistinctionUnits = 2;
+    netEnvParam.units[0].hdrs[0].hdr = HEADER_TYPE_IPv4; /* no special options */
+    netEnvParam.units[1].hdrs[0].hdr = HEADER_TYPE_ETH;
+    p_LnxWrpFmPortDev->h_DefNetEnv = FM_PCD_SetNetEnvCharacteristics(p_LnxWrpFmDev->h_PcdDev, &netEnvParam);
+    if(!p_LnxWrpFmPortDev->h_DefNetEnv)
+        RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("FM PCD!"));
+
+    for(i=0; i<p_LnxWrpFmPortDev->numOfSchemesUsed; i++)
+    {
+        memset(&schemeParam, 0, sizeof(schemeParam));
+        schemeParam.modify = FALSE;
+        schemeParam.id.relativeSchemeId = i+p_LnxWrpFmPortDev->schemesBase;
+        schemeParam.alwaysDirect = FALSE;
+        schemeParam.netEnvParams.h_NetEnv = p_LnxWrpFmPortDev->h_DefNetEnv;
+        schemeParam.schemeCounter.update = TRUE;
+        schemeParam.schemeCounter.value = 0;
+
+        switch (i)
+        {
+            case (0): /* catch IPv4 */
+                schemeParam.netEnvParams.numOfDistinctionUnits = 1;
+                schemeParam.netEnvParams.unitIds[0] = 0;
+                schemeParam.baseFqid = p_LnxWrpFmPortDev->pcdBaseQ;
+                schemeParam.nextEngine = e_FM_PCD_DONE;
+                schemeParam.numOfUsedFqidMasks = 0;
+                schemeParam.useHash = TRUE;
+                schemeParam.keyExtractAndHashParams.numOfUsedExtracts = 3;
+                for(j=0; j<schemeParam.keyExtractAndHashParams.numOfUsedExtracts; j++)
+                {
+                    schemeParam.keyExtractAndHashParams.extractArray[j].type = e_FM_PCD_EXTRACT_BY_HDR;
+                    schemeParam.keyExtractAndHashParams.extractArray[j].extractParams.extractByHdr.hdr = HEADER_TYPE_IPv4;
+                    schemeParam.keyExtractAndHashParams.extractArray[j].extractParams.extractByHdr.ignoreProtocolValidation = FALSE;
+                    schemeParam.keyExtractAndHashParams.extractArray[j].extractParams.extractByHdr.type = e_FM_PCD_EXTRACT_FULL_FIELD;
+                }
+                schemeParam.keyExtractAndHashParams.extractArray[0].extractParams.extractByHdr.extractByHdrType.fullField.ipv4 = NET_HEADER_FIELD_IPv4_PROTO;
+                schemeParam.keyExtractAndHashParams.extractArray[1].extractParams.extractByHdr.extractByHdrType.fullField.ipv4 = NET_HEADER_FIELD_IPv4_SRC_IP;
+                schemeParam.keyExtractAndHashParams.extractArray[2].extractParams.extractByHdr.extractByHdrType.fullField.ipv4 = NET_HEADER_FIELD_IPv4_DST_IP;
+
+                if(schemeParam.useHash)
+                {
+                    schemeParam.keyExtractAndHashParams.privateDflt0 = 0x01020304;
+                    schemeParam.keyExtractAndHashParams.privateDflt1 = 0x11121314;
+                    schemeParam.keyExtractAndHashParams.numOfUsedDflts = FM_PCD_KG_NUM_OF_DEFAULT_GROUPS;
+                    for(j=0; j<FM_PCD_KG_NUM_OF_DEFAULT_GROUPS; j++)
+                    {
+                        schemeParam.keyExtractAndHashParams.dflts[j].type = (e_FmPcdKgKnownFieldsDfltTypes)j; /* all types */
+                        schemeParam.keyExtractAndHashParams.dflts[j].dfltSelect = e_FM_PCD_KG_DFLT_GBL_0;
+                    }
+                    schemeParam.keyExtractAndHashParams.numOfUsedMasks = 0;
+                    schemeParam.keyExtractAndHashParams.hashShift = 0;
+                    schemeParam.keyExtractAndHashParams.hashDistributionNumOfFqids = 8;
+                }
+                break;
+
+            case (1): /* Garbage collector */
+                schemeParam.netEnvParams.numOfDistinctionUnits = 0;
+                schemeParam.baseFqid = p_LnxWrpFmPortDev->pcdBaseQ+8;
+                break;
+
+            default:
+                break;
+        }
+
+        p_LnxWrpFmPortDev->h_Schemes[i] = FM_PCD_KgSetScheme(p_LnxWrpFmDev->h_PcdDev, &schemeParam);
+        if(!p_LnxWrpFmPortDev->h_Schemes[i])
+            RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("FM_PCD_KgSetScheme failed"));
+    }
+
+    /* initialize PCD parameters */
+    memset(&pcdParam, 0, sizeof( t_FmPortPcdParams));
+    pcdParam.h_NetEnv   = p_LnxWrpFmPortDev->h_DefNetEnv;
+    pcdParam.pcdSupport = e_FM_PORT_PCD_SUPPORT_PRS_AND_KG;
+
+    /* initialize Keygen parameters */
+    memset(&prsParam, 0, sizeof( t_FmPortPcdPrsParams));
+
+    prsParam.parsingOffset = 0;
+    prsParam.firstPrsHdr = HEADER_TYPE_ETH;
+    pcdParam.p_PrsParams = &prsParam;
+
+    /* initialize Parser parameters */
+    memset(&kgParam, 0, sizeof( t_FmPortPcdKgParams));
+    kgParam.numOfSchemes = p_LnxWrpFmPortDev->numOfSchemesUsed;
+    for(i=0;i<kgParam.numOfSchemes;i++)
+        kgParam.h_Schemes[i] = p_LnxWrpFmPortDev->h_Schemes[i];
+
+    pcdParam.p_KgParams = &kgParam;
+
+    return FM_PORT_SetPCD(p_LnxWrpFmPortDev->h_Dev, &pcdParam);
+}
+
+static t_Error InitFmPortDev(t_LnxWrpFmPortDev *p_LnxWrpFmPortDev)
+{
+#define MY_ADV_CONFIG_CHECK_END                                 \
+            RETURN_ERROR(MAJOR, E_INVALID_SELECTION,            \
+                         ("Advanced configuration routine"));   \
+        if (errCode != E_OK)                                    \
+            RETURN_ERROR(MAJOR, errCode, NO_MSG);               \
+    }
+
+    int                 i = 0;
+
+    if (!p_LnxWrpFmPortDev->active || p_LnxWrpFmPortDev->initialized)
+        return E_INVALID_STATE;
+
+    if ((p_LnxWrpFmPortDev->h_Dev = FM_PORT_Config(&p_LnxWrpFmPortDev->settings.param)) == NULL)
+        RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("FM-port"));
+
+    /* Call the driver's advanced configuration routines, if requested:
+       Compare the function pointer of each entry to the available routines,
+       and invoke the matching routine with proper casting of arguments. */
+    while (p_LnxWrpFmPortDev->settings.advConfig[i].p_Function)
+    {
+        ADV_CONFIG_CHECK_START(&(p_LnxWrpFmPortDev->settings.advConfig[i]))
+
+        ADV_CONFIG_CHECK(p_LnxWrpFmPortDev->h_Dev, FM_PORT_ConfigBufferPrefixContent,   PARAMS(1, (t_FmPortBufferPrefixContent*)))
+
+        MY_ADV_CONFIG_CHECK_END
+
+        /* Advance to next advanced configuration entry */
+        i++;
+    }
+
+    if (FM_PORT_Init(p_LnxWrpFmPortDev->h_Dev) != E_OK)
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
+
+    FM_PORT_Disable(p_LnxWrpFmPortDev->h_Dev);
+
+    if ((p_LnxWrpFmPortDev->defPcd != e_NO_PCD) &&
+        (InitFmPort3TupleDefPcd(p_LnxWrpFmPortDev) != E_OK))
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
+
+    p_LnxWrpFmPortDev->initialized = TRUE;
+
+    return E_OK;
+}
+
+static void FreeFmDev(t_LnxWrpFmDev  *p_LnxWrpFmDev)
+{
+    if (!p_LnxWrpFmDev->active)
+        return;
+
+    if (p_LnxWrpFmDev->h_PcdDev)
+        FM_PCD_Free(p_LnxWrpFmDev->h_PcdDev);
+
+    if (p_LnxWrpFmDev->h_Dev)
+        FM_Free(p_LnxWrpFmDev->h_Dev);
+
+    if (p_LnxWrpFmDev->h_MuramDev)
+        FM_MURAM_Free(p_LnxWrpFmDev->h_MuramDev);
+
+    SYS_UnregisterIoMap((uint64_t)p_LnxWrpFmDev->fmMuramBaseAddr);
+    devm_iounmap(p_LnxWrpFmDev->dev, CAST_UINT64_TO_POINTER(p_LnxWrpFmDev->fmMuramBaseAddr));
+    __devm_release_region(p_LnxWrpFmDev->dev, p_LnxWrpFmDev->res, p_LnxWrpFmDev->fmMuramBaseAddr, p_LnxWrpFmDev->fmMuramMemSize);
+    SYS_UnregisterIoMap((uint64_t)p_LnxWrpFmDev->fmBaseAddr);
+    devm_iounmap(p_LnxWrpFmDev->dev, CAST_UINT64_TO_POINTER(p_LnxWrpFmDev->fmBaseAddr));
+    release_mem_region(p_LnxWrpFmDev->fmBaseAddr, p_LnxWrpFmDev->fmMemSize);
+//    devm_release_mem_region(p_LnxWrpFmDev->dev, p_LnxWrpFmDev->fmBaseAddr, p_LnxWrpFmDev->fmMemSize);
+}
+
+static void FreeFmPortDev(t_LnxWrpFmPortDev *p_LnxWrpFmPortDev)
+{
+    t_LnxWrpFmDev       *p_LnxWrpFmDev = (t_LnxWrpFmDev *)p_LnxWrpFmPortDev->h_LnxWrpFmDev;
+
+    if (!p_LnxWrpFmPortDev->active)
+        return;
+
+    if (p_LnxWrpFmPortDev->h_Dev)
+        FM_PORT_Free(p_LnxWrpFmPortDev->h_Dev);
+    devm_iounmap(p_LnxWrpFmDev->dev, CAST_UINT64_TO_POINTER(p_LnxWrpFmPortDev->baseAddr));
+    __devm_release_region(p_LnxWrpFmDev->dev, p_LnxWrpFmDev->res, p_LnxWrpFmPortDev->baseAddr, p_LnxWrpFmPortDev->memSize);
+}
+
+
+/*****************************************************************************/
+/*               API routines for the FM Linux Device                        */
+/*****************************************************************************/
+
+static int fm_open(struct inode *inode, struct file *file)
+{
+    t_LnxWrpFmDev       *p_LnxWrpFmDev = NULL;
+    t_LnxWrpFmPortDev   *p_LnxWrpFmPortDev = NULL;
+    unsigned int        major = imajor(inode);
+    unsigned int        minor = iminor(inode);
+
+    DBG(TRACE, ("Opening minor - %d - ", minor));
+
+    if (file->private_data != NULL)
+        return 0;
+
+#ifdef NO_OF_SUPPORT
+{
+    int                 i;
+    for (i=0; i<INTG_MAX_NUM_OF_FM; i++)
+        if (lnxWrpFm.p_FmDevs[i]->major == major)
+            p_LnxWrpFmDev = lnxWrpFm.p_FmDevs[i];
+}
+#else
+{
+    struct of_device_id name;
+    struct device_node  *fm_node;
+
+    /* Get all the FM nodes */
+    memset(&name, 0, sizeof(struct of_device_id));
+    BUG_ON(strlen("fsl,fman") >= sizeof(name.compatible));
+    strcpy(name.compatible, "fsl,fman");
+    for_each_matching_node(fm_node, &name) {
+        struct of_device    *of_dev;
+
+        of_dev = of_find_device_by_node(fm_node);
+        if (unlikely(of_dev == NULL)) {
+            REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("fm id!"));
+            return -ENXIO;
+        }
+
+        p_LnxWrpFmDev = (t_LnxWrpFmDev *)fm_bind(&of_dev->dev);
+        if (p_LnxWrpFmDev->major == major)
+            break;
+        fm_unbind((struct fm *)p_LnxWrpFmDev);
+        p_LnxWrpFmDev = NULL;
+    }
+}
+#endif /* NO_OF_SUPPORT */
+
+    if (!p_LnxWrpFmDev)
+        return -ENODEV;
+
+    if (minor == DEV_FM_MINOR_BASE)
+        file->private_data = p_LnxWrpFmDev;
+    else if (minor == DEV_FM_PCD_MINOR_BASE)
+        file->private_data = p_LnxWrpFmDev;
+    else {
+        if (minor == DEV_FM_HC_PORT_MINOR_BASE)
+            p_LnxWrpFmPortDev = &p_LnxWrpFmDev->hcPort;
+        else if ((minor >= DEV_FM_OP_PORTS_MINOR_BASE) && (minor < DEV_FM_RX_PORTS_MINOR_BASE))
+            p_LnxWrpFmPortDev = &p_LnxWrpFmDev->opPorts[minor-DEV_FM_OP_PORTS_MINOR_BASE];
+        else if ((minor >= DEV_FM_RX_PORTS_MINOR_BASE) && (minor < DEV_FM_TX_PORTS_MINOR_BASE))
+            p_LnxWrpFmPortDev = &p_LnxWrpFmDev->rxPorts[minor-DEV_FM_RX_PORTS_MINOR_BASE];
+        else if ((minor >= DEV_FM_TX_PORTS_MINOR_BASE) && (minor < DEV_FM_MAX_MINORS))
+            p_LnxWrpFmPortDev = &p_LnxWrpFmDev->txPorts[minor-DEV_FM_TX_PORTS_MINOR_BASE];
+        else
+            return -EINVAL;
+
+        /* if trying to open port, check if it initialized */
+        if (!p_LnxWrpFmPortDev->initialized)
+            return -ENODEV;
+
+        p_LnxWrpFmPortDev = (t_LnxWrpFmPortDev *)fm_port_bind(p_LnxWrpFmPortDev->dev);
+        file->private_data = p_LnxWrpFmPortDev;
+        fm_unbind((struct fm *)p_LnxWrpFmDev);
+    }
+
+    if (file->private_data == NULL)
+         return -ENXIO;
+
+    return 0;
+}
+
+static int fm_close(struct inode *inode, struct file *file)
+{
+    t_LnxWrpFmDev       *p_LnxWrpFmDev;
+    t_LnxWrpFmPortDev   *p_LnxWrpFmPortDev;
+    unsigned int        minor = iminor(inode);
+    int                 err = 0;
+
+    DBG(TRACE, ("Closing minor - %d - ", minor));
+
+    if ((minor == DEV_FM_MINOR_BASE) ||
+        (minor == DEV_FM_PCD_MINOR_BASE))
+    {
+        p_LnxWrpFmDev = (t_LnxWrpFmDev*)file->private_data;
+        if (!p_LnxWrpFmDev)
+            return -ENODEV;
+        fm_unbind((struct fm *)p_LnxWrpFmDev);
+    }
+    else if ((minor == DEV_FM_HC_PORT_MINOR_BASE) ||
+             ((minor >= DEV_FM_OP_PORTS_MINOR_BASE) && (minor < DEV_FM_RX_PORTS_MINOR_BASE)) ||
+             ((minor >= DEV_FM_RX_PORTS_MINOR_BASE) && (minor < DEV_FM_TX_PORTS_MINOR_BASE)) ||
+             ((minor >= DEV_FM_TX_PORTS_MINOR_BASE) && (minor < DEV_FM_MAX_MINORS)))
+    {
+        p_LnxWrpFmPortDev = (t_LnxWrpFmPortDev*)file->private_data;
+        if (!p_LnxWrpFmPortDev)
+            return -ENODEV;
+        fm_port_unbind((struct fm_port *)p_LnxWrpFmPortDev);
+    }
+
+    return err;
+}
+
+static int fm_ioctl(struct inode *inode, struct file *file, unsigned int cmd, unsigned long arg)
+{
+    unsigned int        minor = iminor(inode);
+
+    DBG(TRACE, ("IOCTL minor - %d, cmd - 0x%08x, arg - 0x%08x", minor, cmd, arg));
+
+    if ((minor == DEV_FM_MINOR_BASE) ||
+        (minor == DEV_FM_PCD_MINOR_BASE))
+    {
+        t_LnxWrpFmDev *p_LnxWrpFmDev = ((t_LnxWrpFmDev*)file->private_data);
+        if (!p_LnxWrpFmDev)
+            return -ENODEV;
+        if (LnxwrpFmIOCTL(p_LnxWrpFmDev, cmd, arg))
+            return -EFAULT;
+    }
+    else if ((minor == DEV_FM_HC_PORT_MINOR_BASE) ||
+             ((minor >= DEV_FM_OP_PORTS_MINOR_BASE) && (minor < DEV_FM_RX_PORTS_MINOR_BASE)) ||
+             ((minor >= DEV_FM_RX_PORTS_MINOR_BASE) && (minor < DEV_FM_TX_PORTS_MINOR_BASE)) ||
+             ((minor >= DEV_FM_TX_PORTS_MINOR_BASE) && (minor < DEV_FM_MAX_MINORS)))
+    {
+        t_LnxWrpFmPortDev *p_LnxWrpFmPortDev = ((t_LnxWrpFmPortDev*)file->private_data);
+        if (!p_LnxWrpFmPortDev)
+            return -ENODEV;
+        if (LnxwrpFmPortIOCTL(p_LnxWrpFmPortDev, cmd, arg))
+            return -EFAULT;
+    }
+    else
+    {
+        REPORT_ERROR(MINOR, E_INVALID_VALUE, ("minor"));
+        return -ENODEV;
+    }
+
+    return 0;
+}
+
+/* Globals for FM character device */
+static struct file_operations fm_fops =
+{
+    owner:      THIS_MODULE,
+    ioctl:      fm_ioctl,
+    open:       fm_open,
+    release:    fm_close,
+};
+
+
+#ifndef NO_OF_SUPPORT
+static int /*__devinit*/ fm_probe(struct of_device *of_dev, const struct of_device_id *match)
+{
+    t_LnxWrpFmDev   *p_LnxWrpFmDev;
+    char            fmName[10];
+
+    if ((p_LnxWrpFmDev = ReadFmDevTreeNode(of_dev)) == NULL)
+        return -EIO;
+    if (ConfigureFmDev(p_LnxWrpFmDev) != E_OK)
+        return -EIO;
+    if (InitFmDev(p_LnxWrpFmDev) != E_OK)
+        return -EIO;
+
+    memset(fmName,0,sizeof(fmName));
+    Sprint (fmName, "%s%d", DEV_FM_NAME, p_LnxWrpFmDev->id);
+
+    /* Register to the /dev for IOCTL API */
+    /* Register dynamically a new major number for the character device: */
+    if ((p_LnxWrpFmDev->major = register_chrdev(0, fmName, &fm_fops)) <= 0)
+    {
+        FreeFmDev(p_LnxWrpFmDev);
+        REPORT_ERROR(MAJOR, E_INVALID_STATE, ("Failed to allocate a major number for device \"%s\"", DEV_FM_NAME));
+        return -EIO;
+    }
+
+    /* Register to the /proc for debug and statistics API */
+    if (((p_LnxWrpFmDev->proc_fm = proc_mkdir(fmName, NULL)) == NULL) ||
+        ((p_LnxWrpFmDev->proc_fm_regs = create_proc_read_entry("regs", 0, p_LnxWrpFmDev->proc_fm, fm_proc_dump_regs, p_LnxWrpFmDev)) == NULL) ||
+        ((p_LnxWrpFmDev->proc_fm_stats = create_proc_read_entry("stats", 0, p_LnxWrpFmDev->proc_fm, fm_proc_dump_stats, p_LnxWrpFmDev)) == NULL))
+    {
+        FreeFmDev(p_LnxWrpFmDev);
+        REPORT_ERROR(MAJOR, E_INVALID_STATE, ("Unable to create proc entry - fm!!!"));
+        return -EIO;
+    }
+
+    dev_set_drvdata(p_LnxWrpFmDev->dev, p_LnxWrpFmDev);
+
+    DBG(TRACE, ("FM%d probed", p_LnxWrpFmDev->id));
+
+    return 0;
+}
+
+static int __devexit fm_remove(struct of_device *of_dev)
+{
+    t_LnxWrpFmDev   *p_LnxWrpFmDev;
+    struct device   *dev;
+    char            fmName[10];
+
+    dev = &of_dev->dev;
+    p_LnxWrpFmDev = dev_get_drvdata(dev);
+
+    remove_proc_entry("stats", p_LnxWrpFmDev->proc_fm);
+    remove_proc_entry("regs", p_LnxWrpFmDev->proc_fm);
+    memset(fmName,0,sizeof(fmName));
+    Sprint (fmName, "%s%d", DEV_FM_NAME, p_LnxWrpFmDev->id);
+    remove_proc_entry(fmName, NULL);
+
+    /* Destroy chardev */
+    unregister_chrdev(p_LnxWrpFmDev->major, DEV_FM_NAME);
+
+    FreeFmDev(p_LnxWrpFmDev);
+
+    DistroyFmDev(p_LnxWrpFmDev);
+
+    dev_set_drvdata(dev, NULL);
+
+    return 0;
+}
+
+static const struct of_device_id fm_match[] __devinitconst = {
+    {
+        .compatible    = "fsl,fman"
+    },
+    {}
+};
+#ifndef MODULE
+MODULE_DEVICE_TABLE(of, fm_match);
+#endif /* !MODULE */
+
+static struct of_platform_driver fm_driver = {
+    .name           = "fsl-fman",
+    .match_table    = fm_match,
+    .owner          = THIS_MODULE,
+    .probe          = fm_probe,
+    .remove         = __devexit_p(fm_remove)
+};
+
+static int /*__devinit*/ fm_port_probe(struct of_device *of_dev, const struct of_device_id *match)
+{
+    t_LnxWrpFmPortDev   *p_LnxWrpFmPortDev;
+    struct device       *dev;
+
+    dev = &of_dev->dev;
+
+    if ((p_LnxWrpFmPortDev = ReadFmPortDevTreeNode(of_dev)) == NULL)
+        return -EIO;
+
+    if (ConfigureFmPortDev(p_LnxWrpFmPortDev) != E_OK)
+        return -EIO;
+
+#if 0
+    if ((p_LnxWrpFmPortDev->settings.param.portType != e_FM_PORT_TYPE_RX_10G) &&
+        (p_LnxWrpFmPortDev->settings.param.portType != e_FM_PORT_TYPE_RX) &&
+        (p_LnxWrpFmPortDev->settings.param.portType != e_FM_PORT_TYPE_TX_10G) &&
+        (p_LnxWrpFmPortDev->settings.param.portType != e_FM_PORT_TYPE_TX) &&
+        (InitFmPortDev(p_LnxWrpFmPortDev) != E_OK))
+        return -EIO;
+#endif /* 0 */
+
+    dev_set_drvdata(dev, p_LnxWrpFmPortDev);
+
+    DBG(TRACE, ("FM-port-%s%d probed",
+               (((p_LnxWrpFmPortDev->settings.param.portType == e_FM_PORT_TYPE_RX_10G) ||
+                 (p_LnxWrpFmPortDev->settings.param.portType == e_FM_PORT_TYPE_RX)) ? "rx" :
+                (((p_LnxWrpFmPortDev->settings.param.portType == e_FM_PORT_TYPE_TX_10G) ||
+                  (p_LnxWrpFmPortDev->settings.param.portType == e_FM_PORT_TYPE_TX)) ? "tx" :
+                 ((p_LnxWrpFmPortDev->settings.param.portType == e_FM_PORT_TYPE_OFFLINE_PARSING) ? "op" : "hc"))),
+               p_LnxWrpFmPortDev->id));
+
+    if ((p_LnxWrpFmPortDev->settings.param.portType == e_FM_PORT_TYPE_HOST_COMMAND) &&
+        (InitFmPcdDev((t_LnxWrpFmDev *)p_LnxWrpFmPortDev->h_LnxWrpFmDev) != E_OK))
+        return -EIO;
+
+    return 0;
+}
+
+static int __devexit fm_port_remove(struct of_device *of_dev)
+{
+    t_LnxWrpFmPortDev   *p_LnxWrpFmPortDev;
+    struct device       *dev;
+
+    dev = &of_dev->dev;
+    p_LnxWrpFmPortDev = dev_get_drvdata(dev);
+
+    FreeFmPortDev(p_LnxWrpFmPortDev);
+
+    dev_set_drvdata(dev, NULL);
+
+    return 0;
+}
+
+static const struct of_device_id fm_port_match[] __devinitconst = {
+    {
+        .compatible    = "fsl,fman-port-oh"
+    },
+    {
+        .compatible    = "fsl,fman-port-1g-rx"
+    },
+    {
+        .compatible    = "fsl,fman-port-10g-rx"
+    },
+    {
+        .compatible    = "fsl,fman-port-1g-tx"
+    },
+    {
+        .compatible    = "fsl,fman-port-10g-tx"
+    },
+    {}
+};
+#ifndef MODULE
+MODULE_DEVICE_TABLE(of, fm_port_match);
+#endif /* !MODULE */
+
+static struct of_platform_driver fm_port_driver = {
+    .name           = "fsl-fman-port",
+    .match_table    = fm_port_match,
+    .owner          = THIS_MODULE,
+    .probe          = fm_port_probe,
+    .remove         = __devexit_p(fm_port_remove)
+};
+#endif /* !NO_OF_SUPPORT */
+
+
+t_Handle LNXWRP_FM_Init(void)
+{
+#ifdef NO_OF_SUPPORT
+    t_LnxWrpFmDev   *p_LnxWrpFmDev;
+    char            fmName[10];
+    int             i, j;
+#endif /* NO_OF_SUPPORT */
+
+    memset(&lnxWrpFm, 0, sizeof(lnxWrpFm));
+
+#ifdef NO_OF_SUPPORT
+    for (i=0; i<INTG_MAX_NUM_OF_FM; i++)
+    {
+        p_LnxWrpFmDev = CreateFmDev(i);
+        if (!p_LnxWrpFmDev)
+        {
+            REPORT_ERROR(MAJOR, E_INVALID_HANDLE, ("FM dev obj!"));
+            return NULL;
+        }
+        lnxWrpFm.p_FmDevs[i] = p_LnxWrpFmDev;
+
+        if (i==1)
+        {
+            ConfigureFmDev(p_LnxWrpFmDev);
+            if (InitFmDev(p_LnxWrpFmDev) != E_OK)
+                return NULL;
+
+            /* Register to the /dev for IOCTL API */
+            /* Register dynamically a new major number for the character device: */
+            if ((p_LnxWrpFmDev->major = register_chrdev(0, DEV_FM_NAME, &fm_fops)) <= 0)
+            {
+                REPORT_ERROR(MAJOR, E_INVALID_STATE, ("Failed to allocate a major number for device \"%s\"", DEV_FM_NAME));
+                return NULL;
+            }
+
+            /* Register to the /proc for debug and statistics API */
+            memset(fmName,0,sizeof(fmName));
+            Sprint (fmName, "%s%d", DEV_FM_NAME, p_LnxWrpFmDev->id);
+            if (((p_LnxWrpFmDev->proc_fm = proc_mkdir(fmName, NULL)) == NULL) ||
+                ((p_LnxWrpFmDev->proc_fm_regs = create_proc_read_entry("regs", 0, p_LnxWrpFmDev->proc_fm, fm_proc_dump_regs, p_LnxWrpFmDev)) == NULL) ||
+                ((p_LnxWrpFmDev->proc_fm_stats = create_proc_read_entry("stats", 0, p_LnxWrpFmDev->proc_fm, fm_proc_dump_stats, p_LnxWrpFmDev)) == NULL))
+            {
+                REPORT_ERROR(MAJOR, E_INVALID_STATE, ("Unable to create proc entry - fm!!!"));
+                return NULL;
+            }
+        }
+
+//        lnxWrpFm.h_Mod = p_TdmLnxWrpParam->h_Mod;
+//        lnxWrpFm.f_GetObject = p_TdmLnxWrpParam->f_GetObject;
+    }
+
+#else
+    /* Register to the DTB for basic FM API */
+    of_register_platform_driver(&fm_driver);
+    /* Register to the DTB for basic FM port API */
+    of_register_platform_driver(&fm_port_driver);
+#endif /* !NO_OF_SUPPORT */
+
+    return &lnxWrpFm;
+}
+
+t_Error LNXWRP_FM_Free(t_Handle h_LnxWrpFm)
+{
+#ifdef NO_OF_SUPPORT
+    t_LnxWrpFm          *p_LnxWrpFm = (t_LnxWrpFm *)h_LnxWrpFm;
+    t_LnxWrpFmDev       *p_LnxWrpFmDev;
+    int                 i, j;
+    char                fmName[10];
+
+    for (i=0; i<INTG_MAX_NUM_OF_FM; i++)
+    {
+        p_LnxWrpFmDev = p_LnxWrpFm->p_FmDevs[i];
+
+        remove_proc_entry("stats", p_LnxWrpFmDev->proc_fm);
+        remove_proc_entry("regs", p_LnxWrpFmDev->proc_fm);
+        memset(fmName,0,sizeof(fmName));
+        Sprint (fmName, "%s%d", DEV_FM_NAME, p_LnxWrpFmDev->id);
+        remove_proc_entry(fmName, NULL);
+
+        /* Destroy chardev */
+        unregister_chrdev(p_LnxWrpFmDev->major, DEV_FM_NAME);
+
+        FreeFmDev(p_LnxWrpFmDev);
+
+        DistroyFmDev(p_LnxWrpFmDev);
+    }
+
+#else
+        of_unregister_platform_driver(&fm_port_driver);
+        of_unregister_platform_driver(&fm_driver);
+#endif /* NO_OF_SUPPORT */
+
+    return E_OK;
+}
+
+
+struct fm * fm_bind (struct device *fm_dev)
+{
+    return (struct fm *)(dev_get_drvdata(get_device(fm_dev)));
+}
+EXPORT_SYMBOL(fm_bind);
+
+void fm_unbind(struct fm *fm)
+{
+    t_LnxWrpFmDev       *p_LnxWrpFmDev = (t_LnxWrpFmDev*)fm;
+
+    put_device(p_LnxWrpFmDev->dev);
+}
+EXPORT_SYMBOL(fm_unbind);
+
+struct resource * fm_get_mem_region(struct fm *fm)
+{
+    t_LnxWrpFmDev       *p_LnxWrpFmDev = (t_LnxWrpFmDev*)fm;
+
+    return p_LnxWrpFmDev->res;
+}
+EXPORT_SYMBOL(fm_get_mem_region);
+
+void * fm_get_handle(struct fm *fm)
+{
+    t_LnxWrpFmDev       *p_LnxWrpFmDev = (t_LnxWrpFmDev*)fm;
+
+    return (void *)p_LnxWrpFmDev->h_Dev;
+}
+EXPORT_SYMBOL(fm_get_handle);
+
+struct fm_port * fm_port_bind (struct device *fm_port_dev)
+{
+    return (struct fm_port *)(dev_get_drvdata(get_device(fm_port_dev)));
+}
+EXPORT_SYMBOL(fm_port_bind);
+
+void fm_port_unbind(struct fm_port *port)
+{
+    t_LnxWrpFmPortDev   *p_LnxWrpFmPortDev = (t_LnxWrpFmPortDev*)port;
+
+    put_device(p_LnxWrpFmPortDev->dev);
+}
+EXPORT_SYMBOL(fm_port_unbind);
+
+void * fm_port_get_handle(struct fm_port *port)
+{
+    t_LnxWrpFmPortDev   *p_LnxWrpFmPortDev = (t_LnxWrpFmPortDev*)port;
+
+    return (void *)p_LnxWrpFmPortDev->h_Dev;
+}
+EXPORT_SYMBOL(fm_port_get_handle);
+
+void fm_set_rx_port_params(struct fm_port *port, struct fm_port_rx_params *params)
+{
+    t_LnxWrpFmPortDev   *p_LnxWrpFmPortDev = (t_LnxWrpFmPortDev*)port;
+    int                 i;
+
+    p_LnxWrpFmPortDev->settings.param.specificParams.rxParams.errFqid  = params->errq;
+    p_LnxWrpFmPortDev->settings.param.specificParams.rxParams.dfltFqid = params->defq;
+
+    p_LnxWrpFmPortDev->settings.param.specificParams.rxParams.rxExtBufPools.numOfPoolsUsed = params->num_pools;
+    for (i=0; i<params->num_pools; i++)
+    {
+        p_LnxWrpFmPortDev->settings.param.specificParams.rxParams.rxExtBufPools.rxExtBufPool[i].id =
+            params->pool_param[i].id;
+        p_LnxWrpFmPortDev->settings.param.specificParams.rxParams.rxExtBufPools.rxExtBufPool[i].size =
+            params->pool_param[i].size;
+    }
+
+    p_LnxWrpFmPortDev->buffPrefixContent.privDataSize     = params->priv_data_size;
+    p_LnxWrpFmPortDev->buffPrefixContent.passPrsResult    = params->parse_results;
+
+    ADD_ADV_CONFIG_START(p_LnxWrpFmPortDev->settings.advConfig, FM_MAX_NUM_OF_ADV_SETTINGS)
+
+    ADD_ADV_CONFIG(FM_PORT_ConfigBufferPrefixContent,   ARGS(1, (&p_LnxWrpFmPortDev->buffPrefixContent)));
+
+    ADD_ADV_CONFIG_END
+
+    InitFmPortDev(p_LnxWrpFmPortDev);
+}
+EXPORT_SYMBOL(fm_set_rx_port_params);
+
+void fm_port_pcd_bind (struct fm_port *port, struct fm_port_pcd_param *params)
+{
+    t_LnxWrpFmPortDev   *p_LnxWrpFmPortDev = (t_LnxWrpFmPortDev*)port;
+
+    p_LnxWrpFmPortDev->pcd_owner_params.cb      = params->cb;
+    p_LnxWrpFmPortDev->pcd_owner_params.dev     = params->dev;
+}
+EXPORT_SYMBOL(fm_port_pcd_bind);
+
+void fm_set_tx_port_params(struct fm_port *port, struct fm_port_non_rx_params *params)
+{
+    t_LnxWrpFmPortDev   *p_LnxWrpFmPortDev = (t_LnxWrpFmPortDev*)port;
+
+    p_LnxWrpFmPortDev->settings.param.specificParams.nonRxParams.errFqid  = params->errq;
+    p_LnxWrpFmPortDev->settings.param.specificParams.nonRxParams.dfltFqid = params->defq;
+
+    p_LnxWrpFmPortDev->buffPrefixContent.privDataSize     = params->priv_data_size;
+    p_LnxWrpFmPortDev->buffPrefixContent.passPrsResult    = params->parse_results;
+
+    ADD_ADV_CONFIG_START(p_LnxWrpFmPortDev->settings.advConfig, FM_MAX_NUM_OF_ADV_SETTINGS)
+
+    ADD_ADV_CONFIG(FM_PORT_ConfigBufferPrefixContent,   ARGS(1, (&p_LnxWrpFmPortDev->buffPrefixContent)));
+
+    ADD_ADV_CONFIG_END
+
+    InitFmPortDev(p_LnxWrpFmPortDev);
+}
+EXPORT_SYMBOL(fm_set_tx_port_params);
+
+int fm_get_tx_port_channel(struct fm_port *port)
+{
+    t_LnxWrpFmPortDev   *p_LnxWrpFmPortDev = (t_LnxWrpFmPortDev*)port;
+
+    return p_LnxWrpFmPortDev->txCh;
+}
+EXPORT_SYMBOL(fm_get_tx_port_channel);
+
+int fm_port_enable (struct fm_port *port)
+{
+    t_LnxWrpFmPortDev   *p_LnxWrpFmPortDev = (t_LnxWrpFmPortDev*)port;
+
+    FM_PORT_Enable(p_LnxWrpFmPortDev->h_Dev);
+
+    return 0;
+}
+EXPORT_SYMBOL(fm_port_enable);
+
+void fm_port_disable(struct fm_port *port)
+{
+    t_LnxWrpFmPortDev   *p_LnxWrpFmPortDev = (t_LnxWrpFmPortDev*)port;
+
+    FM_PORT_Disable(p_LnxWrpFmPortDev->h_Dev);
+}
+EXPORT_SYMBOL(fm_port_disable);
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/lnxwrp_fm.h b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/lnxwrp_fm.h
new file mode 100644
index 0000000..975fe3f
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/lnxwrp_fm.h
@@ -0,0 +1,189 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**************************************************************************//**
+ @File          lnxwrp_fm.h
+
+ @Author        Shlomi Gridish
+
+ @Description   FM Linux wrapper functions.
+*//***************************************************************************/
+#ifndef __LNXWRP_FM_H__
+#define __LNXWRP_FM_H__
+
+#include <linux/fsl_qman.h>    /* struct qman_fq */
+
+#include "std_ext.h"
+#include "error_ext.h"
+#include "list_ext.h"
+#include "procbuff_ext.h"
+
+#include "lnxwrp_fm_ext.h"
+
+
+#define __ERR_MODULE__      MODULE_FM
+
+
+#define FM_MAX_NUM_OF_ADV_SETTINGS          10
+
+#define LNXWRP_FM_NUM_OF_SHARED_PROFILES    16
+
+
+typedef enum {
+    e_NO_PCD = 0,
+    e_FM_PCD_3_TUPLE
+} e_LnxWrpFmPortPcdDefUseCase;
+
+
+typedef struct t_FmTestFq {
+    struct qman_fq      fq_base;
+    t_Handle            h_Arg;
+} t_FmTestFq;
+
+typedef struct {
+    uint8_t                     id;
+    bool                        active;
+    bool                        initialized;
+    uint64_t                    baseAddr;
+    uint32_t                    memSize;
+    t_WrpFmPortDevSettings      settings;
+    uint8_t                     totalNumOfSchemes;
+    uint8_t                     schemesBase;
+    uint8_t                     numOfSchemesUsed;
+    uint32_t                    pcdBaseQ;
+    uint16_t                    pcdNumOfQs;
+    struct fm_port_pcd_param    pcd_owner_params;
+    e_LnxWrpFmPortPcdDefUseCase defPcd;
+    t_Handle                    h_DefNetEnv;
+    t_Handle                    h_Schemes[FM_PCD_KG_NUM_OF_SCHEMES];
+    t_FmPortBufferPrefixContent buffPrefixContent;
+    t_Handle                    h_Dev;
+    t_Handle                    h_LnxWrpFmDev;
+    uint16_t                    txCh;
+    struct device               *dev;
+} t_LnxWrpFmPortDev;
+
+typedef struct {
+    uint8_t                     id;
+    bool                        active;
+    uint64_t                    baseAddr;
+    uint32_t                    memSize;
+    t_WrpFmMacDevSettings       settings;
+    t_Handle                    h_Dev;
+    t_Handle                    h_LnxWrpFmDev;
+} t_LnxWrpFmMacDev;
+
+typedef struct {
+    uint8_t                     id;
+    bool                        active;
+    bool                        pcdActive;
+    bool                        prsActive;
+    bool                        kgActive;
+    bool                        ccActive;
+    bool                        plcrActive;
+    e_LnxWrpFmPortPcdDefUseCase defPcd;
+    uint32_t                    usedSchemes;
+    uint8_t                     totalNumOfSharedSchemes;
+    uint8_t                     sharedSchemesBase;
+    uint8_t                     numOfSchemesUsed;
+    uint8_t                     defNetEnvId;
+    uint64_t                    fmBaseAddr;
+    uint32_t                    fmMemSize;
+    uint64_t                    fmMuramBaseAddr;
+    uint32_t                    fmMuramMemSize;
+    int                         irq1;
+    int                         irq2;
+    t_WrpFmDevSettings          fmDevSettings;
+    t_WrpFmPcdDevSettings       fmPcdDevSettings;
+    t_Handle                    h_Dev;
+    uint16_t                    hcCh;
+
+    t_Handle                    h_MuramDev;
+    t_Handle                    h_PcdDev;
+
+    t_LnxWrpFmPortDev           hcPort;
+    t_LnxWrpFmPortDev           opPorts[FM_MAX_NUM_OF_OP_PORTS];
+    t_LnxWrpFmPortDev           rxPorts[FM_MAX_NUM_OF_RX_PORTS];
+    t_LnxWrpFmPortDev           txPorts[FM_MAX_NUM_OF_TX_PORTS];
+    t_LnxWrpFmMacDev            macs[FM_MAX_NUM_OF_MACS];
+
+    struct device               *dev;
+    struct resource             *res;
+    int                         major;
+    struct proc_dir_entry       *proc_fm;
+    struct proc_dir_entry       *proc_fm_regs;
+    struct proc_dir_entry       *proc_fm_stats;
+    struct qman_fq              *hc_tx_conf_fq, *hc_tx_err_fq, *hc_tx_fq;
+} t_LnxWrpFmDev;
+
+typedef struct {
+//    t_Handle h_Mod;
+//    t_Handle (*f_GetObject) (t_Handle h_Mod, e_SysModule devType, ...);
+
+    t_LnxWrpFmDev   *p_FmDevs[INTG_MAX_NUM_OF_FM];
+} t_LnxWrpFm;
+#define LNXWRP_FM_OBJECT(ptr)   LIST_OBJECT(ptr, t_LnxWrpFm, fms[((t_LnxWrpFmDev *)ptr)->id])
+
+
+t_Error  LnxwrpFmIOCTL(t_LnxWrpFmDev *p_LnxWrpFmDev, unsigned int cmd, unsigned long arg);
+t_Error  LnxwrpFmPortIOCTL(t_LnxWrpFmPortDev *p_LnxWrpFmPortDev, unsigned int cmd, unsigned long arg);
+
+
+static __inline__ t_Error AllocSchemesForPort(t_LnxWrpFmDev *p_LnxWrpFmDev, uint8_t numSchemes, uint8_t *p_BaseSchemeNum)
+{
+    uint32_t    schemeMask;
+    uint8_t     i;
+
+    if (!numSchemes)
+        RETURN_ERROR(MINOR, E_INVALID_VALUE, NO_MSG);
+
+    schemeMask = 0x80000000;
+    *p_BaseSchemeNum = 0xff;
+
+    for (i=0; schemeMask && numSchemes; schemeMask>>=1, i++)
+        if ((p_LnxWrpFmDev->usedSchemes & schemeMask) == 0)
+        {
+            p_LnxWrpFmDev->usedSchemes |= schemeMask;
+            numSchemes--;
+            if (*p_BaseSchemeNum==0xff)
+                *p_BaseSchemeNum = i;
+        }
+        else if (*p_BaseSchemeNum!=0xff)
+            RETURN_ERROR(MINOR, E_INVALID_STATE, ("Fragmentation on schemes array!!!"));
+
+    if (numSchemes)
+        RETURN_ERROR(MINOR, E_FULL, ("schemes!!!"));
+    return E_OK;
+}
+
+
+#endif /* __LNXWRP_FM_H__ */
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/lnxwrp_fm_ioctls.c b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/lnxwrp_fm_ioctls.c
new file mode 100644
index 0000000..1e2f239
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/lnxwrp_fm_ioctls.c
@@ -0,0 +1,1012 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**************************************************************************//**
+ @File          lnxwrp_fm.c
+
+ @Author        Shlomi Gridish
+
+ @Description   FM Linux wrapper functions.
+*//***************************************************************************/
+
+/* Linux Headers ------------------- */
+#include <linux/version.h>
+
+#if defined(CONFIG_MODVERSIONS) && !defined(MODVERSIONS)
+#define MODVERSIONS
+#endif
+#ifdef MODVERSIONS
+#include <config/modversions.h>
+#endif /* MODVERSIONS */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/fs.h>
+#include <linux/cdev.h>
+#include <linux/device.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/ioport.h>
+#include <asm/uaccess.h>
+#include <asm/errno.h>
+#include <sysdev/fsl_soc.h>
+
+/* NetCommSw Headers --------------- */
+#include "std_ext.h"
+#include "error_ext.h"
+#include "sprint_ext.h"
+#include "sys_io_ext.h"
+
+#include "fm_ioctls.h"
+#include "fm_pcd_ioctls.h"
+#include "fm_port_ioctls.h"
+
+#include "lnxwrp_fm.h"
+
+
+static t_Error LnxwrpFmPcdIOCTL(t_LnxWrpFmDev *p_LnxWrpFmDev, unsigned int cmd, unsigned long arg)
+{
+    t_Error err = E_READ_FAILED;
+
+    switch (cmd)
+    {
+        case FM_PCD_IOC_PRS_LOAD_SW:
+            break;
+
+        case FM_PCD_IOC_ENABLE:
+            return FM_PCD_Enable(p_LnxWrpFmDev->h_PcdDev);
+        case FM_PCD_IOC_DISABLE:
+            return FM_PCD_Disable(p_LnxWrpFmDev->h_PcdDev);
+
+        case FM_PCD_IOC_FORCE_INTR:
+        {
+            int exception;
+            if (get_user(exception, (int *)arg))
+                break;
+            return FM_PCD_ForceIntr(p_LnxWrpFmDev->h_PcdDev, (e_FmPcdExceptions)exception);
+        }
+
+        case FM_PCD_IOC_SET_EXCEPTION:
+        {
+            ioc_fm_pcd_exception_params_t *param;
+
+            param = (ioc_fm_pcd_exception_params_t *)XX_Malloc(sizeof(ioc_fm_pcd_exception_params_t));
+            if (!param)
+                RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
+
+            if (copy_from_user(param, (ioc_fm_pcd_exception_params_t *)arg, sizeof(ioc_fm_pcd_exception_params_t))) {
+                XX_Free(param);
+                RETURN_ERROR(MINOR, err, NO_MSG);
+            }
+
+            err = FM_PCD_SetException(p_LnxWrpFmDev->h_PcdDev, param->exception, param->enable);
+            XX_Free(param);
+            break;
+        }
+
+        case FM_PCD_IOC_KG_SET_ADDITIONAL_DATA_AFTER_PARSING:
+        {
+            int payloadOffset;
+            if (get_user(payloadOffset, (int *)arg))
+                break;
+            return FM_PCD_KgSetAdditionalDataAfterParsing(p_LnxWrpFmDev->h_PcdDev, (uint8_t)payloadOffset);
+        }
+
+        case FM_PCD_IOC_KG_SET_EMPTY_CLS_PLAN_GRP:
+            return FM_PCD_KgSetEmptyClsPlanGrp(p_LnxWrpFmDev->h_PcdDev);
+        case FM_PCD_IOC_KG_DELETE_EMPTY_CLS_PLAN_GRP:
+            return FM_PCD_KgDeleteEmptyClsPlanGrp(p_LnxWrpFmDev->h_PcdDev);
+
+        case FM_PCD_IOC_KG_SET_DFLT_VALUE:
+        {
+            ioc_fm_pcd_kg_dflt_value_params_t *param;
+
+            param = (ioc_fm_pcd_kg_dflt_value_params_t *)XX_Malloc(sizeof(ioc_fm_pcd_kg_dflt_value_params_t));
+            if (!param)
+                RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
+
+            if (copy_from_user(param, (ioc_fm_pcd_kg_dflt_value_params_t *)arg, sizeof(ioc_fm_pcd_kg_dflt_value_params_t))) {
+                XX_Free(param);
+                RETURN_ERROR(MINOR, err, NO_MSG);
+            }
+
+            err = FM_PCD_KgSetDfltValue(p_LnxWrpFmDev->h_PcdDev, param->valueId, param->value);
+            XX_Free(param);
+            break;
+        }
+
+        case FM_PCD_IOC_SET_NET_ENV_CHARACTERISTICS:
+        {
+            ioc_fm_pcd_net_env_params_t  *param;
+
+            param = (ioc_fm_pcd_net_env_params_t *)XX_Malloc(sizeof(ioc_fm_pcd_net_env_params_t));
+            if (!param)
+                RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
+
+            if (copy_from_user(param, (ioc_fm_pcd_net_env_params_t *)arg, sizeof(ioc_fm_pcd_net_env_params_t))) {
+                XX_Free(param);
+                RETURN_ERROR(MINOR, err, NO_MSG);
+            }
+
+            param->id = FM_PCD_SetNetEnvCharacteristics(p_LnxWrpFmDev->h_PcdDev, (t_FmPcdNetEnvParams*)param);
+            if (param->id && !copy_to_user((ioc_fm_pcd_net_env_params_t *)arg, param, sizeof(ioc_fm_pcd_net_env_params_t)))
+                err = E_OK;
+            XX_Free(param);
+            break;
+        }
+
+        case FM_PCD_IOC_DELETE_NET_ENV_CHARACTERISTICS:
+        {
+            ioc_fm_obj_t id;
+            if (copy_from_user(&id, (ioc_fm_obj_t *)arg, sizeof(ioc_fm_obj_t)))
+                break;
+            return FM_PCD_DeleteNetEnvCharacteristics(p_LnxWrpFmDev->h_PcdDev, id.obj);
+        }
+
+        case FM_PCD_IOC_KG_SET_CLS_PLAN_GRP:
+        {
+            ioc_fm_pcd_kg_cls_plan_grp_params_t *param;
+
+            param = (ioc_fm_pcd_kg_cls_plan_grp_params_t *)XX_Malloc(sizeof(ioc_fm_pcd_kg_cls_plan_grp_params_t));
+            if (!param)
+                RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
+
+            if (copy_from_user(param, (ioc_fm_pcd_kg_cls_plan_grp_params_t *)arg, sizeof(ioc_fm_pcd_kg_cls_plan_grp_params_t))) {
+                XX_Free(param);
+                RETURN_ERROR(MINOR, err, NO_MSG);
+            }
+
+            param->id = FM_PCD_KgSetClsPlanGrp(p_LnxWrpFmDev->h_PcdDev, (t_FmPcdKgClsPlanGrpParams*)param);
+            if (param->id && !copy_to_user((ioc_fm_pcd_kg_cls_plan_grp_params_t *)arg, param, sizeof(ioc_fm_pcd_kg_cls_plan_grp_params_t)))
+                err = E_OK;
+
+            XX_Free(param);
+            break;
+        }
+
+        case FM_PCD_IOC_KG_DEL_CLS_PLAN:
+        {
+            ioc_fm_obj_t id;
+            if (copy_from_user(&id, (ioc_fm_obj_t *)arg, sizeof(ioc_fm_obj_t)))
+                break;
+            return FM_PCD_KgDeleteClsPlanGrp(p_LnxWrpFmDev->h_PcdDev, id.obj);
+        }
+
+        case FM_PCD_IOC_KG_SET_SCHEME:
+        {
+            ioc_fm_pcd_kg_scheme_params_t               *param;
+
+            param = (ioc_fm_pcd_kg_scheme_params_t *)XX_Malloc(sizeof(ioc_fm_pcd_kg_scheme_params_t));
+            if (!param)
+                RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
+
+            if (copy_from_user(param, (ioc_fm_pcd_kg_scheme_params_t *)arg, sizeof(ioc_fm_pcd_kg_scheme_params_t))) {
+                XX_Free(param);
+                RETURN_ERROR(MINOR, err, NO_MSG);
+            }
+
+            param->id = FM_PCD_KgSetScheme(p_LnxWrpFmDev->h_PcdDev, (t_FmPcdKgSchemeParams*)param);
+            if (param->id && !copy_to_user((ioc_fm_pcd_kg_scheme_params_t *)arg, param, sizeof(ioc_fm_pcd_kg_scheme_params_t)))
+                err = E_OK;
+
+            XX_Free(param);
+            break;
+        }
+
+        case FM_PCD_IOC_KG_DEL_SCHEME:
+        {
+            ioc_fm_obj_t id;
+            if (copy_from_user(&id, (ioc_fm_obj_t *)arg, sizeof(ioc_fm_obj_t)))
+                break;
+            return FM_PCD_KgDeleteScheme(p_LnxWrpFmDev->h_PcdDev, id.obj);
+        }
+
+        case FM_PCD_IOC_CC_SET_NODE:
+        {
+            ioc_fm_pcd_cc_node_params_t *param;
+            uint8_t                     gbl_mask[4];
+            uint8_t                     *keys;
+            uint8_t                     *masks;
+            int                         i,k;
+
+            param = (ioc_fm_pcd_cc_node_params_t *)XX_Malloc(sizeof(ioc_fm_pcd_cc_node_params_t));
+            if (!param)
+                RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
+
+            keys = (uint8_t *)XX_Malloc(sizeof(uint8_t)*IOC_FM_PCD_MAX_NUM_OF_KEYS*IOC_FM_PCD_MAX_SIZE_OF_KEY);
+            if (!keys)
+                RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD keys"));
+            memset(keys, 0, sizeof(uint8_t)*IOC_FM_PCD_MAX_NUM_OF_KEYS*IOC_FM_PCD_MAX_SIZE_OF_KEY);
+
+            masks = (uint8_t *)XX_Malloc(sizeof(uint8_t)*IOC_FM_PCD_MAX_NUM_OF_KEYS*IOC_FM_PCD_MAX_SIZE_OF_KEY);
+            if (!masks)
+                RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD masks"));
+            memset(masks, 0, sizeof(uint8_t)*IOC_FM_PCD_MAX_NUM_OF_KEYS*IOC_FM_PCD_MAX_SIZE_OF_KEY);
+
+            if (copy_from_user(param, (ioc_fm_pcd_cc_node_params_t *)arg, sizeof(ioc_fm_pcd_cc_node_params_t))) {
+                XX_Free(param);
+                RETURN_ERROR(MINOR, err, NO_MSG);
+            }
+
+            if (param->keys_params.p_glbl_mask &&
+                (param->keys_params.key_size <= 4)) {
+                if (copy_from_user(&gbl_mask,
+                                   param->keys_params.p_glbl_mask,
+                                   param->keys_params.key_size)) {
+                    XX_Free(masks);
+                    XX_Free(keys);
+                    XX_Free(param);
+                    RETURN_ERROR(MINOR, err, NO_MSG);
+                }
+                param->keys_params.p_glbl_mask = gbl_mask;
+            }
+
+            for (i=0,k=0; i<param->keys_params.num_of_keys; i++, k+=IOC_FM_PCD_MAX_SIZE_OF_KEY) {
+                if (copy_from_user(&keys[k],
+                               param->keys_params.key_params[i].p_key,
+                               param->keys_params.key_size)) {
+                    XX_Free(masks);
+                    XX_Free(keys);
+                    XX_Free(param);
+                    RETURN_ERROR(MINOR, err, NO_MSG);
+                }
+                param->keys_params.key_params[i].p_key = &keys[k];
+
+                if (param->keys_params.key_params[i].p_mask) {
+                    if (copy_from_user(&masks[k],
+                                   param->keys_params.key_params[i].p_mask,
+                                   param->keys_params.key_size)) {
+                        XX_Free(masks);
+                        XX_Free(keys);
+                        XX_Free(param);
+                        RETURN_ERROR(MINOR, err, NO_MSG);
+                    }
+                    param->keys_params.key_params[i].p_mask = &masks[k];
+                }
+            }
+            param->id = FM_PCD_CcSetNode(p_LnxWrpFmDev->h_PcdDev, (t_FmPcdCcNodeParams*)param);
+            if (param->id && !copy_to_user((ioc_fm_pcd_cc_node_params_t *)arg, param, sizeof(ioc_fm_pcd_cc_node_params_t)))
+                err = E_OK;
+
+            XX_Free(masks);
+            XX_Free(keys);
+            XX_Free(param);
+            break;
+        }
+
+        case FM_PCD_IOC_CC_DELETE_NODE:
+        {
+            ioc_fm_obj_t id;
+            if (copy_from_user(&id, (ioc_fm_obj_t *)arg, sizeof(ioc_fm_obj_t)))
+                break;
+            return FM_PCD_CcDeleteNode(p_LnxWrpFmDev->h_PcdDev, id.obj);
+        }
+
+        case FM_PCD_IOC_CC_BUILD_TREE:
+        {
+            ioc_fm_pcd_cc_tree_params_t         *param;
+            ioc_fm_pcd_cc_next_engine_params_t  *next_engine_per_entries_in_grp;
+            uint8_t                             numOfEntriesInGroup;
+            int                                 i;
+
+            param = (ioc_fm_pcd_cc_tree_params_t *)XX_Malloc(sizeof(ioc_fm_pcd_cc_tree_params_t));
+            if (!param)
+                RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
+
+            if (copy_from_user(param, (ioc_fm_pcd_cc_tree_params_t *)arg, sizeof(ioc_fm_pcd_cc_tree_params_t))) {
+                XX_Free(param);
+                RETURN_ERROR(MINOR, err, NO_MSG);
+            }
+
+            for (i=0; i<param->num_of_groups; i++) {
+                if (param->fm_pcd_cc_group_params[i].p_next_engine_per_entries_in_grp) {
+                    numOfEntriesInGroup = (uint8_t)( 0x01 << param->fm_pcd_cc_group_params[i].num_of_distinction_units);
+                    if ((numOfEntriesInGroup ==0 ) || (numOfEntriesInGroup >= 16)) {
+                        XX_Free(param);
+                        RETURN_ERROR(MINOR, E_INVALID_VALUE, ("numOfEntriesInGroup"));
+                    }
+
+                    next_engine_per_entries_in_grp =
+                        (ioc_fm_pcd_cc_next_engine_params_t *)XX_Malloc(numOfEntriesInGroup*sizeof(ioc_fm_pcd_cc_next_engine_params_t));
+                    if (!next_engine_per_entries_in_grp)
+                        RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
+
+                    if (copy_from_user(next_engine_per_entries_in_grp,
+                                       param->fm_pcd_cc_group_params[i].p_next_engine_per_entries_in_grp,
+                                       numOfEntriesInGroup*sizeof(ioc_fm_pcd_cc_next_engine_params_t))) {
+                        XX_Free(param);
+                        RETURN_ERROR(MINOR, err, NO_MSG);
+                    }
+                    param->fm_pcd_cc_group_params[i].p_next_engine_per_entries_in_grp = next_engine_per_entries_in_grp;
+                }
+            }
+
+            param->id = FM_PCD_CcBuildTree(p_LnxWrpFmDev->h_PcdDev, (t_FmPcdCcTreeParams*)param);
+            if (param->id && !copy_to_user((ioc_fm_pcd_cc_tree_params_t *)arg, param, sizeof(ioc_fm_pcd_cc_tree_params_t)))
+                err = E_OK;
+
+            for (i=0; i<param->num_of_groups; i++)
+                if (param->fm_pcd_cc_group_params[i].p_next_engine_per_entries_in_grp)
+                    XX_Free(param->fm_pcd_cc_group_params[i].p_next_engine_per_entries_in_grp);
+            XX_Free(param);
+            break;
+        }
+
+        case FM_PCD_IOC_CC_DELETE_TREE:
+        {
+            ioc_fm_obj_t id;
+            if (copy_from_user(&id, (ioc_fm_obj_t *)arg, sizeof(ioc_fm_obj_t)))
+                break;
+            return FM_PCD_CcDeleteTree(p_LnxWrpFmDev->h_PcdDev, id.obj);
+        }
+
+        case FM_PCD_IOC_PLCR_SET_PROFILE:
+        {
+            ioc_fm_pcd_plcr_profile_params_t            *param;
+
+            param = (ioc_fm_pcd_plcr_profile_params_t *)XX_Malloc(sizeof(ioc_fm_pcd_plcr_profile_params_t));
+            if (!param)
+                RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
+
+            if (copy_from_user(param, (ioc_fm_pcd_plcr_profile_params_t *)arg, sizeof(ioc_fm_pcd_plcr_profile_params_t))) {
+                XX_Free(param);
+                RETURN_ERROR(MINOR, err, NO_MSG);
+            }
+
+            if (!param->modify &&
+                (((t_FmPcdPlcrProfileParams*)param)->id.newParams.profileType != e_FM_PCD_PLCR_SHARED))
+            {
+                t_Handle h_Port;
+
+                switch (((fm_pcd_port_params_t*)((t_FmPcdPlcrProfileParams*)param)->id.newParams.h_FmPort)->port_type)
+                {
+                    case (e_IOC_FM_PORT_TYPE_OFFLINE_PARSING):
+                        h_Port = p_LnxWrpFmDev->opPorts[((fm_pcd_port_params_t*)((t_FmPcdPlcrProfileParams*)param)->id.newParams.h_FmPort)->port_id].h_Dev;
+                        break;
+                    case (e_IOC_FM_PORT_TYPE_RX):
+                        h_Port = p_LnxWrpFmDev->rxPorts[((fm_pcd_port_params_t*)((t_FmPcdPlcrProfileParams*)param)->id.newParams.h_FmPort)->port_id].h_Dev;
+                        break;
+                    case (e_IOC_FM_PORT_TYPE_RX_10G):
+                        h_Port = p_LnxWrpFmDev->rxPorts[((fm_pcd_port_params_t*)((t_FmPcdPlcrProfileParams*)param)->id.newParams.h_FmPort)->port_id + FM_MAX_NUM_OF_1G_RX_PORTS].h_Dev;
+                        break;
+                    default:
+                        XX_Free(param);
+                        RETURN_ERROR(MINOR, E_INVALID_SELECTION, NO_MSG);
+                }
+
+                ((t_FmPcdPlcrProfileParams*)param)->id.newParams.h_FmPort = h_Port;
+            }
+
+            param->id = FM_PCD_PlcrSetProfile(p_LnxWrpFmDev->h_PcdDev, (t_FmPcdPlcrProfileParams*)param);
+            if (param->id && !copy_to_user((ioc_fm_pcd_plcr_profile_params_t *)arg, param, sizeof(ioc_fm_pcd_plcr_profile_params_t)))
+                err = E_OK;
+
+            XX_Free(param);
+            break;
+        }
+
+        case FM_PCD_IOC_PLCR_DEL_PROFILE:
+        {
+            ioc_fm_obj_t id;
+            if (copy_from_user(&id, (ioc_fm_obj_t *)arg, sizeof(ioc_fm_obj_t)))
+                break;
+            return FM_PCD_PlcrDeleteProfile(p_LnxWrpFmDev->h_PcdDev, id.obj);
+        }
+
+        case FM_PCD_IOC_CC_TREE_MODIFY_NEXT_ENGINE:
+        {
+            ioc_fm_pcd_cc_tree_modify_next_engine_params_t            *param;
+
+            param = (ioc_fm_pcd_cc_tree_modify_next_engine_params_t *)XX_Malloc(sizeof(ioc_fm_pcd_cc_tree_modify_next_engine_params_t));
+            if (!param)
+                RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
+
+            if (copy_from_user(param, (ioc_fm_pcd_cc_tree_modify_next_engine_params_t *)arg, sizeof(ioc_fm_pcd_cc_tree_modify_next_engine_params_t))) {
+                XX_Free(param);
+                RETURN_ERROR(MINOR, err, NO_MSG);
+            }
+
+            err = FM_PCD_CcTreeModifyNextEngine(p_LnxWrpFmDev->h_PcdDev,
+                                                param->id,
+                                                param->grp_indx,
+                                                param->indx,
+                                                (t_FmPcdCcNextEngineParams*)(&param->cc_next_engine_params));
+            XX_Free(param);
+            break;
+        }
+
+        case FM_PCD_IOC_CC_NODE_MODIFY_NEXT_ENGINE:
+        {
+            ioc_fm_pcd_cc_node_modify_next_engine_params_t            *param;
+
+            param = (ioc_fm_pcd_cc_node_modify_next_engine_params_t *)XX_Malloc(sizeof(ioc_fm_pcd_cc_node_modify_next_engine_params_t));
+            if (!param)
+                RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
+
+            if (copy_from_user(param, (ioc_fm_pcd_cc_node_modify_next_engine_params_t *)arg, sizeof(ioc_fm_pcd_cc_node_modify_next_engine_params_t))) {
+                XX_Free(param);
+                RETURN_ERROR(MINOR, err, NO_MSG);
+            }
+
+            err = FM_PCD_CcNodeModifyNextEngine(p_LnxWrpFmDev->h_PcdDev,
+                                                param->id,
+                                                param->key_indx,
+                                                (t_FmPcdCcNextEngineParams*)(&param->cc_next_engine_params));
+            XX_Free(param);
+            break;
+        }
+
+        case FM_PCD_IOC_CC_NODE_MODIFY_MISS_NEXT_ENGINE:
+        {
+            ioc_fm_pcd_cc_node_modify_next_engine_params_t            *param;
+
+            param = (ioc_fm_pcd_cc_node_modify_next_engine_params_t *)XX_Malloc(sizeof(ioc_fm_pcd_cc_node_modify_next_engine_params_t));
+            if (!param)
+                RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
+
+            if (copy_from_user(param, (ioc_fm_pcd_cc_node_modify_next_engine_params_t *)arg, sizeof(ioc_fm_pcd_cc_node_modify_next_engine_params_t))) {
+                XX_Free(param);
+                RETURN_ERROR(MINOR, err, NO_MSG);
+            }
+
+            err = FM_PCD_CcNodeModifyMissNextEngine(p_LnxWrpFmDev->h_PcdDev,
+                                                    param->id,
+                                                    (t_FmPcdCcNextEngineParams*)(&param->cc_next_engine_params));
+            XX_Free(param);
+            break;
+        }
+
+        case FM_PCD_IOC_CC_NODE_REMOVE_KEY:
+        {
+            ioc_fm_pcd_cc_node_remove_key_params_t            *param;
+
+            param = (ioc_fm_pcd_cc_node_remove_key_params_t *)XX_Malloc(sizeof(ioc_fm_pcd_cc_node_remove_key_params_t));
+            if (!param)
+                RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
+
+            if (copy_from_user(param, (ioc_fm_pcd_cc_node_remove_key_params_t *)arg, sizeof(ioc_fm_pcd_cc_node_remove_key_params_t))) {
+                XX_Free(param);
+                RETURN_ERROR(MINOR, err, NO_MSG);
+            }
+
+            err = FM_PCD_CcNodeRemoveKey(p_LnxWrpFmDev->h_PcdDev, param->id, param->key_indx);
+            XX_Free(param);
+            break;
+        }
+
+        case FM_PCD_IOC_CC_NODE_ADD_KEY:
+        {
+            ioc_fm_pcd_cc_node_modify_key_and_next_engine_params_t            *param;
+
+            param = (ioc_fm_pcd_cc_node_modify_key_and_next_engine_params_t *)XX_Malloc(sizeof(ioc_fm_pcd_cc_node_modify_key_and_next_engine_params_t));
+            if (!param)
+                RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
+
+            if (copy_from_user(param, (ioc_fm_pcd_cc_node_modify_key_and_next_engine_params_t *)arg, sizeof(ioc_fm_pcd_cc_node_modify_key_and_next_engine_params_t))) {
+                XX_Free(param);
+                RETURN_ERROR(MINOR, err, NO_MSG);
+            }
+
+            err = FM_PCD_CcNodeAddKey(p_LnxWrpFmDev->h_PcdDev,
+                                      param->id,
+                                      param->key_indx,
+                                      param->key_size,
+                                      (t_FmPcdCcKeyParams*)(&param->key_params));
+            XX_Free(param);
+            break;
+        }
+
+        case FM_PCD_IOC_CC_NODE_MODIFY_KEY_AND_NEXT_ENGINE:
+        {
+            ioc_fm_pcd_cc_node_modify_key_and_next_engine_params_t            *param;
+
+            param = (ioc_fm_pcd_cc_node_modify_key_and_next_engine_params_t *)XX_Malloc(sizeof(ioc_fm_pcd_cc_node_modify_key_and_next_engine_params_t));
+            if (!param)
+                RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
+
+            if (copy_from_user(param, (ioc_fm_pcd_cc_node_modify_key_and_next_engine_params_t *)arg, sizeof(ioc_fm_pcd_cc_node_modify_key_and_next_engine_params_t))) {
+                XX_Free(param);
+                RETURN_ERROR(MINOR, err, NO_MSG);
+            }
+
+            err = FM_PCD_CcNodeModifyKeyAndNextEngine(p_LnxWrpFmDev->h_PcdDev,
+                                                      param->id,
+                                                      param->key_indx,
+                                                      param->key_size,
+                                                      (t_FmPcdCcKeyParams*)(&param->key_params));
+            XX_Free(param);
+            break;
+        }
+
+        case FM_PCD_IOC_CC_NODE_MODIFY_KEY:
+        {
+            ioc_fm_pcd_cc_node_modify_key_params_t  *param;
+            uint8_t                                 *key;
+            uint8_t                                 *mask;
+
+            param = (ioc_fm_pcd_cc_node_modify_key_params_t *)XX_Malloc(sizeof(ioc_fm_pcd_cc_node_modify_key_params_t));
+            if (!param)
+                RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
+
+            if (copy_from_user(param, (ioc_fm_pcd_cc_node_modify_key_params_t *)arg, sizeof(ioc_fm_pcd_cc_node_modify_key_params_t))) {
+                XX_Free(param);
+                RETURN_ERROR(MINOR, err, NO_MSG);
+            }
+
+            if (param->p_key) {
+                key = (uint8_t *)XX_Malloc(sizeof(uint8_t)*IOC_FM_PCD_MAX_SIZE_OF_KEY);
+                if (!key) {
+                    XX_Free(param);
+                    RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD key"));
+                }
+                memset(key, 0, sizeof(uint8_t)*IOC_FM_PCD_MAX_SIZE_OF_KEY);
+
+                if (copy_from_user(key, param->p_key, param->key_size)) {
+                    XX_Free(key);
+                    XX_Free(param);
+                    RETURN_ERROR(MINOR, err, NO_MSG);
+                }
+                param->p_key = key;
+            }
+
+            if (param->p_mask) {
+                mask = (uint8_t *)XX_Malloc(sizeof(uint8_t)*IOC_FM_PCD_MAX_SIZE_OF_KEY);
+                if (!mask) {
+                    XX_Free(key);
+                    XX_Free(param);
+                    RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD mask"));
+                }
+                memset(mask, 0, sizeof(uint8_t)*IOC_FM_PCD_MAX_SIZE_OF_KEY);
+
+                if (copy_from_user(mask, param->p_mask, param->key_size)) {
+                    XX_Free(mask);
+                    XX_Free(key);
+                    XX_Free(param);
+                    RETURN_ERROR(MINOR, err, NO_MSG);
+                }
+                param->p_mask = mask;
+            }
+
+            err = FM_PCD_CcNodeModifyKey(p_LnxWrpFmDev->h_PcdDev,
+                                         param->id,
+                                         param->key_indx,
+                                         param->key_size,
+                                         param->p_key,
+                                         param->p_mask);
+            XX_Free(mask);
+            XX_Free(key);
+            XX_Free(param);
+            break;
+        }
+
+        default:
+            RETURN_ERROR(MINOR, E_INVALID_SELECTION, ("IOCTL cmd (0x%08x)!", cmd));
+    }
+
+    return err;
+}
+
+t_Error LnxwrpFmIOCTL(t_LnxWrpFmDev *p_LnxWrpFmDev, unsigned int cmd, unsigned long arg)
+{
+    t_Error err = E_READ_FAILED;
+
+    DBG(TRACE, ("p_LnxWrpFmDev - 0x%08x, cmd - 0x%08x, arg - 0x%08x", (uint32_t)p_LnxWrpFmDev, cmd, arg));
+
+    switch (cmd)
+    {
+        case FM_IOC_SET_PORTS_BANDWIDTH:
+        {
+            ioc_ports_param_t *param;
+
+            param = (ioc_ports_param_t *)XX_Malloc(sizeof(ioc_ports_param_t));
+            if (!param)
+                RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
+
+            if (copy_from_user(param, (ioc_ports_param_t *)arg, sizeof(ioc_ports_param_t)))
+            {
+                XX_Free(param);
+                return err;
+            }
+
+            err =  FM_SetPortsBandwidth(p_LnxWrpFmDev->h_Dev,(t_PortsParam*)param);
+            XX_Free(param);
+            return err;
+        }
+
+        case FM_IOC_GET_REVISION:
+        {
+            ioc_fm_revision_info_t *param;
+
+            param = (ioc_fm_revision_info_t *)XX_Malloc(sizeof(ioc_fm_revision_info_t));
+            if (!param)
+                RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
+
+            FM_GetRevision(p_LnxWrpFmDev->h_Dev, (t_FmRevisionInfo*)param);
+            if (copy_to_user((ioc_fm_revision_info_t *)arg, param, sizeof(ioc_fm_revision_info_t)))
+                err = E_WRITE_FAILED;
+            else
+                err = E_OK;
+
+            XX_Free(param);
+            return err;
+        }
+
+        case FM_IOC_SET_COUNTER:
+        {
+            ioc_fm_counters_params_t *param;
+
+            param = (ioc_fm_counters_params_t *)XX_Malloc(sizeof(ioc_fm_counters_params_t));
+            if (!param)
+                RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
+
+            if (copy_from_user(param, (ioc_fm_counters_params_t *)arg, sizeof(ioc_fm_counters_params_t)))
+            {
+                XX_Free(param);
+                return err;
+            }
+
+            err = FM_SetCounter(p_LnxWrpFmDev->h_Dev, param->cnt, param->val);
+
+            XX_Free(param);
+            return err;
+        }
+
+        case FM_IOC_GET_COUNTER:
+        {
+            ioc_fm_counters_params_t *param;
+
+            param = (ioc_fm_counters_params_t *)XX_Malloc(sizeof(ioc_fm_counters_params_t));
+            if (!param)
+                RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
+
+            if (copy_from_user(param, (ioc_fm_counters_params_t *)arg, sizeof(ioc_fm_counters_params_t)))
+            {
+                XX_Free(param);
+                return err;
+            }
+
+            param->val = FM_GetCounter(p_LnxWrpFmDev->h_Dev, param->cnt);
+            if (copy_to_user((ioc_fm_counters_params_t *)arg, param, sizeof(ioc_fm_counters_params_t)))
+                err = E_WRITE_FAILED;
+
+            XX_Free(param);
+            return err;
+        }
+
+        case FM_IOC_FORCE_INTR:
+        {
+            ioc_fm_exceptions param;
+
+            if (get_user(param, (ioc_fm_exceptions*)arg))
+                break;
+            return FM_ForceIntr(p_LnxWrpFmDev->h_Dev, (e_FmExceptions)param);
+        }
+
+        default:
+            return LnxwrpFmPcdIOCTL(p_LnxWrpFmDev, cmd, arg);
+    }
+
+    RETURN_ERROR(MINOR, E_INVALID_OPERATION, ("IOCTL FM"));
+}
+
+t_Error LnxwrpFmPortIOCTL(t_LnxWrpFmPortDev *p_LnxWrpFmPortDev, unsigned int cmd, unsigned long arg)
+{
+    t_Error err = E_READ_FAILED;
+    DBG(TRACE, ("p_LnxWrpFmPortDev - 0x%08x, cmd - 0x%08x, arg - 0x%08x", (uint32_t)p_LnxWrpFmPortDev, cmd, arg));
+
+    switch (cmd)
+    {
+        case FM_PORT_IOC_DISABLE:
+            FM_PORT_Disable(p_LnxWrpFmPortDev->h_Dev);
+            return E_OK;
+        case FM_PORT_IOC_ENABLE:
+            FM_PORT_Enable(p_LnxWrpFmPortDev->h_Dev);
+            return E_OK;
+
+        case FM_PORT_IOC_SET_ERRORS_ROUTE:
+        {
+            int errs;
+            if (get_user(errs, (int *)arg))
+                break;
+            return FM_PORT_SetErrorsRoute(p_LnxWrpFmPortDev->h_Dev, (fmPortFrameErrSelect_t)errs);
+        }
+
+        case FM_PORT_IOC_ALLOC_PCD_FQIDS:
+        {
+            ioc_fm_port_pcd_fqids_params_t        *param;
+
+            param = (ioc_fm_port_pcd_fqids_params_t *)XX_Malloc(sizeof(ioc_fm_port_pcd_fqids_params_t));
+            if (!param)
+                RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PORT"));
+
+            if (copy_from_user(param, (ioc_fm_port_pcd_fqids_params_t *)arg, sizeof(ioc_fm_port_pcd_fqids_params_t)))
+            {
+                XX_Free(param);
+                return err;
+            }
+
+            if (!p_LnxWrpFmPortDev->pcd_owner_params.cb)
+                RETURN_ERROR(MINOR, E_INVALID_STATE, ("No one to listen on this PCD!!!"));
+
+            if (p_LnxWrpFmPortDev->pcd_owner_params.cb (p_LnxWrpFmPortDev->pcd_owner_params.dev,
+                                                        param->num_fqids,
+                                                        param->alignment,
+                                                        &param->base_fqid))
+                RETURN_ERROR(MINOR, E_INVALID_STATE, ("can't allocate fqids for PCD!!!"));
+
+            if (copy_to_user((ioc_fm_port_pcd_fqids_params_t *)arg, param, sizeof(ioc_fm_port_pcd_fqids_params_t)))
+            {
+                XX_Free(param);
+                RETURN_ERROR(MAJOR, E_WRITE_FAILED, NO_MSG);
+            }
+
+            XX_Free(param);
+            return E_OK;
+        }
+
+        case FM_PORT_IOC_SET_PCD:
+        {
+            ioc_fm_port_pcd_params_t        *port_pcd_params;
+            ioc_fm_port_pcd_prs_params_t    *port_pcd_prs_params;
+            ioc_fm_port_pcd_cc_params_t     *port_pcd_cc_params;
+            ioc_fm_port_pcd_kg_params_t     *port_pcd_kg_params;
+            ioc_fm_port_pcd_plcr_params_t   *port_pcd_plcr_params;
+            uint8_t                         copy_fail = 0;
+
+            if ((port_pcd_params = (ioc_fm_port_pcd_params_t *)XX_Malloc(sizeof(ioc_fm_port_pcd_params_t)))) {
+                if ((port_pcd_prs_params = (ioc_fm_port_pcd_prs_params_t *)XX_Malloc(sizeof(ioc_fm_port_pcd_prs_params_t)))) {
+                    if ((port_pcd_cc_params = (ioc_fm_port_pcd_cc_params_t *)XX_Malloc(sizeof(ioc_fm_port_pcd_cc_params_t)))) {
+                        if ((port_pcd_kg_params = (ioc_fm_port_pcd_kg_params_t *)XX_Malloc(sizeof(ioc_fm_port_pcd_kg_params_t)))) {
+                            port_pcd_plcr_params = (ioc_fm_port_pcd_plcr_params_t *)XX_Malloc(sizeof(ioc_fm_port_pcd_plcr_params_t));
+                            if (!port_pcd_plcr_params) {
+                                XX_Free(port_pcd_params);
+                                XX_Free(port_pcd_prs_params);
+                                XX_Free(port_pcd_cc_params);
+                                XX_Free(port_pcd_kg_params);
+                                RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PORT"));
+                            }
+                        }
+                        else {
+                            XX_Free(port_pcd_params);
+                            XX_Free(port_pcd_prs_params);
+                            XX_Free(port_pcd_cc_params);
+                            RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PORT"));
+                        }
+                    }
+                    else {
+                        XX_Free(port_pcd_params);
+                        XX_Free(port_pcd_prs_params);
+                        RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PORT"));
+                    }
+                }
+                else {
+                    XX_Free(port_pcd_params);
+                    RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PORT"));
+                }
+            }
+            else
+                RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PORT"));
+
+            copy_fail = 0;
+            if (copy_from_user(port_pcd_params, (ioc_fm_port_pcd_params_t *)arg, sizeof(ioc_fm_port_pcd_params_t)))
+                copy_fail = 1;
+            if (port_pcd_params->p_prs_params && !copy_fail)
+            {
+                if (copy_from_user(port_pcd_prs_params,
+                                    port_pcd_params->p_prs_params,
+                                    sizeof(ioc_fm_port_pcd_prs_params_t)))
+                  copy_fail = 1;
+                else
+                  port_pcd_params->p_prs_params = port_pcd_prs_params;
+            }
+            if (port_pcd_params->p_cc_params && !copy_fail)
+            {
+                if (copy_from_user(port_pcd_cc_params,
+                                    port_pcd_params->p_cc_params,
+                                    sizeof(ioc_fm_port_pcd_cc_params_t)))
+                  copy_fail = 1;
+                else
+                  port_pcd_params->p_cc_params = port_pcd_cc_params;
+            }
+            if (port_pcd_params->p_kg_params && !copy_fail)
+            {
+                if (copy_from_user(port_pcd_kg_params,
+                                    port_pcd_params->p_kg_params,
+                                    sizeof(ioc_fm_port_pcd_kg_params_t)))
+                  copy_fail = 1;
+                else
+                  port_pcd_params->p_kg_params = port_pcd_kg_params;
+            }
+            if (port_pcd_params->p_plcr_params && !copy_fail)
+            {
+                if (copy_from_user(port_pcd_plcr_params,
+                                    port_pcd_params->p_plcr_params,
+                                    sizeof(ioc_fm_port_pcd_plcr_params_t)))
+                  copy_fail = 1;
+                else
+                  port_pcd_params->p_plcr_params = port_pcd_plcr_params;
+            }
+            if (!copy_fail)
+               err = FM_PORT_SetPCD(p_LnxWrpFmPortDev->h_Dev, (t_FmPortPcdParams *)port_pcd_params);
+            else
+               err = E_READ_FAILED;
+
+            XX_Free(port_pcd_params);
+            XX_Free(port_pcd_prs_params);
+            XX_Free(port_pcd_cc_params);
+            XX_Free(port_pcd_kg_params);
+            XX_Free(port_pcd_plcr_params);
+            return err;
+        }
+
+        case FM_PORT_IOC_DELETE_PCD:
+            return FM_PORT_DeletePCD(p_LnxWrpFmPortDev->h_Dev);
+
+        case FM_PORT_IOC_PCD_KG_MODIFY_INITIAL_SCHEME:
+        {
+            ioc_fm_pcd_kg_scheme_select_t        *param;
+
+            param = (ioc_fm_pcd_kg_scheme_select_t *)XX_Malloc(sizeof(ioc_fm_pcd_kg_scheme_select_t));
+            if (!param)
+                RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PORT"));
+
+            if (copy_from_user(param, (ioc_fm_pcd_kg_scheme_select_t *)arg, sizeof(ioc_fm_pcd_kg_scheme_select_t)))
+            {
+                XX_Free(param);
+                RETURN_ERROR(MAJOR, E_READ_FAILED, NO_MSG);
+            }
+
+            err =  FM_PORT_PcdKgModifyInitialScheme(p_LnxWrpFmPortDev->h_Dev, (t_FmPcdKgSchemeSelect *)param);
+
+            XX_Free(param);
+            return err;
+        }
+
+        case FM_PORT_IOC_PCD_PLCR_MODIFY_INITIAL_PROFILE:
+        {
+            ioc_fm_obj_t id;
+            if (copy_from_user(&id, (ioc_fm_obj_t *)arg, sizeof(ioc_fm_obj_t)))
+                break;
+            return FM_PORT_PcdPlcrModifyInitialProfile(p_LnxWrpFmPortDev->h_Dev, id.obj);
+        }
+
+        case FM_PORT_IOC_PCD_KG_BIND_SCHEMES:
+        {
+            ioc_fm_pcd_port_schemes_params_t        *param;
+
+            param = (ioc_fm_pcd_port_schemes_params_t *)XX_Malloc(sizeof(ioc_fm_pcd_port_schemes_params_t));
+            if (!param)
+                RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PORT"));
+
+            if (copy_from_user(param, (ioc_fm_pcd_port_schemes_params_t *)arg, sizeof(ioc_fm_pcd_port_schemes_params_t)))
+            {
+                XX_Free(param);
+                RETURN_ERROR(MAJOR, E_WRITE_FAILED, NO_MSG);
+            }
+
+            err = FM_PORT_PcdKgBindSchemes(p_LnxWrpFmPortDev->h_Dev, (t_FmPcdPortSchemesParams *)param);
+
+            XX_Free(param);
+            return err;
+        }
+
+        case FM_PORT_IOC_PCD_KG_UNBIND_SCHEMES:
+        {
+            ioc_fm_pcd_port_schemes_params_t        *param;
+
+            param = (ioc_fm_pcd_port_schemes_params_t *)XX_Malloc(sizeof(ioc_fm_pcd_port_schemes_params_t));
+            if (!param)
+                RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PORT"));
+
+            if (copy_from_user(param, (ioc_fm_pcd_port_schemes_params_t *)arg, sizeof(ioc_fm_pcd_port_schemes_params_t)))
+            {
+                XX_Free(param);
+                RETURN_ERROR(MAJOR, E_WRITE_FAILED, NO_MSG);
+            }
+
+            err =  FM_PORT_PcdKgUnbindSchemes(p_LnxWrpFmPortDev->h_Dev, (t_FmPcdPortSchemesParams *)param);
+
+            XX_Free(param);
+            return err;
+        }
+
+        case FM_PORT_IOC_PCD_PRS_MODIFY_START_OFFSET:
+        {
+            ioc_fm_pcd_prs_start_t        *param;
+
+            param = (ioc_fm_pcd_prs_start_t *)XX_Malloc(sizeof(ioc_fm_pcd_prs_start_t));
+            if (!param)
+                RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PORT"));
+
+            if (copy_from_user(param, (ioc_fm_pcd_prs_start_t *)arg, sizeof(ioc_fm_pcd_prs_start_t)))
+            {
+                XX_Free(param);
+                RETURN_ERROR(MAJOR, E_WRITE_FAILED, NO_MSG);
+            }
+            err = FM_PORT_PcdPrsModifyStartOffset(p_LnxWrpFmPortDev->h_Dev, (t_FmPcdPrsStart *)param);
+
+            XX_Free(param);
+            return err;
+        }
+
+        case FM_PORT_IOC_PCD_PLCR_ALLOC_PROFILES:
+        {
+            int num;
+            if (get_user(num, (int *)arg))
+                break;
+            return FM_PORT_PcdPlcrAllocProfiles(p_LnxWrpFmPortDev->h_Dev, (uint16_t)num);
+        }
+        case FM_PORT_IOC_PCD_PLCR_FREE_PROFILES:
+            return FM_PORT_PcdPlcrFreeProfiles(p_LnxWrpFmPortDev->h_Dev);
+
+        case FM_PORT_IOC_DETACH_PCD:
+            return FM_PORT_DetachPCD(p_LnxWrpFmPortDev->h_Dev);
+
+        case FM_PORT_IOC_ATTACH_PCD:
+            return FM_PORT_AttachPCD(p_LnxWrpFmPortDev->h_Dev);
+
+        case FM_PORT_IOC_PCD_KG_MODIFY_CLS_PLAN_GRP:
+        {
+            ioc_fm_pcd_port_cls_plan_params_t        *param;
+
+            param = (ioc_fm_pcd_port_cls_plan_params_t *)XX_Malloc(sizeof(ioc_fm_pcd_port_cls_plan_params_t));
+            if (!param)
+                RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PORT"));
+
+            if (copy_from_user(param, (ioc_fm_pcd_port_cls_plan_params_t *)arg, sizeof(ioc_fm_pcd_port_cls_plan_params_t)))
+            {
+                XX_Free(param);
+                RETURN_ERROR(MAJOR, E_WRITE_FAILED, NO_MSG);
+            }
+            err = FM_PORT_PcdKgModifyClsPlanGrp (p_LnxWrpFmPortDev->h_Dev,
+                                                 param->use_cls_plan,
+                                                 param->new_cls_plan_grp);
+
+            XX_Free(param);
+            return err;
+        }
+
+        case FM_PORT_IOC_PCD_CC_MODIFY_TREE:
+        {
+            ioc_fm_obj_t id;
+            if (copy_from_user(&id, (ioc_fm_obj_t *)arg, sizeof(ioc_fm_obj_t)))
+                break;
+            return FM_PORT_PcdCcModifyTree(p_LnxWrpFmPortDev->h_Dev, id.obj);
+        }
+
+        default:
+            RETURN_ERROR(MINOR, E_INVALID_SELECTION, ("IOCTL port cmd!"));
+    }
+
+    RETURN_ERROR(MINOR, E_INVALID_OPERATION, ("IOCTL port"));
+}
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/xx/Makefile b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/xx/Makefile
new file mode 100644
index 0000000..96cd972
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/xx/Makefile
@@ -0,0 +1,17 @@
+#
+# Makefile for the Freescale Ethernet controllers
+#
+EXTRA_CFLAGS           += -DVERSION=\"\"
+#
+#Include netcomm SW specific definitions
+include $(srctree)/drivers/net/dpa/NetCommSw/ncsw_config.mk
+
+obj-y		+= fsl-ncsw-xx.o
+
+fsl-ncsw-xx-objs	:=   xx_linux.o udivdi3.o stdlib.o
+# ctype.o
+
+obj-y		+= integrations/
+
+
+
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/xx/ctype.c b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/xx/ctype.c
new file mode 100644
index 0000000..96c73e2
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/xx/ctype.c
@@ -0,0 +1,67 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**************************************************************************//**
+ @File          ctype.c
+
+ @Description   ...
+*//***************************************************************************/
+#include "stdlib_ext.h"
+#include "ctype_ext.h"
+
+
+unsigned char _ctype[] = {
+    _C,_C,_C,_C,_C,_C,_C,_C,                    /* 0-7     */
+    _C,_C|_S,_C|_S,_C|_S,_C|_S,_C|_S,_C,_C,     /* 8-15    */
+    _C,_C,_C,_C,_C,_C,_C,_C,                    /* 16-23   */
+    _C,_C,_C,_C,_C,_C,_C,_C,                    /* 24-31   */
+    _S|_SP,_P,_P,_P,_P,_P,_P,_P,                /* 32-39   */
+    _P,_P,_P,_P,_P,_P,_P,_P,                    /* 40-47   */
+    _D,_D,_D,_D,_D,_D,_D,_D,                    /* 48-55   */
+    _D,_D,_P,_P,_P,_P,_P,_P,                    /* 56-63   */
+    _P,_U|_X,_U|_X,_U|_X,_U|_X,_U|_X,_U|_X,_U,  /* 64-71   */
+    _U,_U,_U,_U,_U,_U,_U,_U,                    /* 72-79   */
+    _U,_U,_U,_U,_U,_U,_U,_U,                    /* 80-87   */
+    _U,_U,_U,_P,_P,_P,_P,_P,                    /* 88-95   */
+    _P,_L|_X,_L|_X,_L|_X,_L|_X,_L|_X,_L|_X,_L,  /* 96-103  */
+    _L,_L,_L,_L,_L,_L,_L,_L,                    /* 104-111 */
+    _L,_L,_L,_L,_L,_L,_L,_L,                    /* 112-119 */
+    _L,_L,_L,_P,_P,_P,_P,_C,                    /* 120-127 */
+    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,            /* 128-143 */
+    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,            /* 144-159 */
+    _S|_SP,_P,_P,_P,_P,_P,_P,_P,_P,_P,_P,_P,_P,_P,_P,_P,    /* 160-175 */
+    _P,_P,_P,_P,_P,_P,_P,_P,_P,_P,_P,_P,_P,_P,_P,_P,        /* 176-191 */
+    _U,_U,_U,_U,_U,_U,_U,_U,_U,_U,_U,_U,_U,_U,_U,_U,        /* 192-207 */
+    _U,_U,_U,_U,_U,_U,_U,_P,_U,_U,_U,_U,_U,_U,_U,_L,        /* 208-223 */
+    _L,_L,_L,_L,_L,_L,_L,_L,_L,_L,_L,_L,_L,_L,_L,_L,        /* 224-239 */
+    _L,_L,_L,_L,_L,_L,_L,_P,_L,_L,_L,_L,_L,_L,_L,_L         /* 240-255 */
+};
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/xx/integrations/Makefile b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/xx/integrations/Makefile
new file mode 100644
index 0000000..e961908
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/xx/integrations/Makefile
@@ -0,0 +1,9 @@
+#
+# Makefile for the Freescale Ethernet controllers
+#
+EXTRA_CFLAGS           += -DVERSION=\"\"
+#
+#Include netcomm SW specific definitions
+include $(srctree)/drivers/net/dpa/NetCommSw/ncsw_config.mk
+#
+obj-y		+= P4080/
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/xx/integrations/P4080/Makefile b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/xx/integrations/P4080/Makefile
new file mode 100644
index 0000000..76f148d
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/xx/integrations/P4080/Makefile
@@ -0,0 +1,13 @@
+#
+# Makefile for the Freescale Ethernet controllers
+#
+EXTRA_CFLAGS           += -DVERSION=\"\"
+#
+#Include netcomm SW specific definitions
+include $(srctree)/drivers/net/dpa/NetCommSw/ncsw_config.mk
+
+EXTRA_CFLAGS += -I$(NCSW)/user/env/linux/kernel/2.6/xx
+
+obj-y		+= xx_integration.o
+
+
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/xx/integrations/P4080/xx_integration.c b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/xx/integrations/P4080/xx_integration.c
new file mode 100644
index 0000000..2881292
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/xx/integrations/P4080/xx_integration.c
@@ -0,0 +1,165 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**************************************************************************//**
+ @File          xx_integration.c
+
+ @Description   XX routines implementation for Linux.
+*//***************************************************************************/
+#include <linux/version.h>
+
+#if defined(CONFIG_MODVERSIONS) && !defined(MODVERSIONS)
+#define MODVERSIONS
+#endif
+#ifdef MODVERSIONS
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+#include <linux/modversions.h>
+#else
+#include <config/modversions.h>
+#endif    /* LINUX_VERSION_CODE */
+#endif /* MODVERSIONS */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/ptrace.h>
+#include <linux/errno.h>
+#include <linux/ioport.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/fs.h>
+#include <linux/vmalloc.h>
+#include <linux/init.h>
+#include <linux/timer.h>
+#include <linux/spinlock.h>
+#include <linux/delay.h>
+#include <linux/proc_fs.h>
+#include <linux/smp_lock.h>
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+#include <linux/tqueue.h>
+#else
+#include <linux/workqueue.h>
+#endif    /* LINUX_VERSION_CODE */
+
+#ifdef BIGPHYSAREA_ENABLE
+#include <linux/bigphysarea.h>
+#endif /* BIGPHYSAREA_ENABLE */
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,18)
+#include <asm/of_device.h>
+#include <sysdev/fsl_soc.h>
+#endif    /* LINUX_VERSION_CODE */
+#include <asm/pgtable.h>
+#include <asm/irq.h>
+#include <asm/bitops.h>
+#include <asm/uaccess.h>
+#include <asm/system.h>
+#include <asm/io.h>
+#include <asm/atomic.h>
+#include <asm/string.h>
+#include <asm/byteorder.h>
+#include <asm/page.h>
+
+#include "error_ext.h"
+#include "std_ext.h"
+#include "mem_ext.h"
+#include "list_ext.h"
+#include "mm_ext.h"
+#include "sys_io_ext.h"
+#include "platform_ext.h"
+
+#include "xx.h"
+
+
+#define __ERR_MODULE__      MODULE_UNKNOWN
+
+void * XX_GetMemPartitionBase(int memPartitionId)
+{
+    switch(memPartitionId)
+    {
+        case(0):
+        case(e_MEM_1ST_DDR_CACHEABLE):
+            return phys_to_virt(0);
+            break;
+        default:
+            REPORT_ERROR(MINOR, E_INVALID_VALUE, ("Memory type!"));
+            return CAST_UINT32_TO_POINTER(ILLEGAL_BASE);
+    }
+    return CAST_UINT32_TO_POINTER(ILLEGAL_BASE);
+}
+
+char * GetDeviceName(int irq)
+{
+    switch (irq)
+    {
+//        case e_DUART1_INTR:
+//            return "NCSW_DUART1";
+        default:
+            return NULL;
+    }
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,22)
+int GetDeviceIrqNum(int irq)
+{
+    struct device_node  *iPar;
+    struct irq_host     *irqHost;
+    uint32_t            hwIrq;
+
+    /* Get the interrupt controller */
+    iPar = of_find_node_by_name(NULL, "mpic");
+    hwIrq = 0;
+
+    ASSERT_COND(iPar != NULL);
+    /* Get the irq host */
+    irqHost = irq_find_host(iPar);
+    of_node_put(iPar);
+
+    /* Create irq mapping */
+    return irq_create_mapping(irqHost, hwIrq);
+}
+#else
+#error "kernel not supported!!!"
+#endif    /* LINUX_VERSION_CODE */
+
+
+void * XX_PhysToVirt(void * addr)
+{
+    return CAST_UINT64_TO_POINTER(SYS_PhysToVirt(CAST_POINTER_TO_UINT64(addr)));
+}
+
+void * XX_VirtToPhys(void * addr)
+{
+    return CAST_UINT64_TO_POINTER(SYS_VirtToPhys(CAST_POINTER_TO_UINT64(addr)));
+}
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/xx/stdlib.c b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/xx/stdlib.c
new file mode 100644
index 0000000..3c0730a
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/xx/stdlib.c
@@ -0,0 +1,264 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/*------------------------------------------------------*/
+/*                                                      */
+/* File: stdlib.c                                       */
+/*                                                      */
+/* Description:                                         */
+/*    Standard library routines (externals)             */
+/*                                                      */
+/* Modifications:                                       */
+/* ==============                                       */
+/*                                                      */
+/*------------------------------------------------------*/
+#include "stdlib_ext.h"
+#include "stdarg_ext.h"
+#include "ctype_ext.h"
+#include "string_ext.h"
+#include "std_ext.h"
+#include "xx_ext.h"
+
+
+#ifdef MODULE
+/**
+ * strtoul - convert a string to an uint32_t
+ * @cp: The start of the string
+ * @endp: A pointer to the end of the parsed string will be placed here
+ * @base: The number base to use
+ */
+uint32_t strtoul(const char *cp,char **endp,uint32_t base)
+{
+    uint32_t result = 0,value;
+
+    if (!base) {
+        base = 10;
+        if (*cp == '0') {
+            base = 8;
+            cp++;
+            if ((*cp == 'x') && isxdigit(cp[1])) {
+                cp++;
+                base = 16;
+            }
+        }
+    }
+    while (isxdigit(*cp) &&
+           (value = (uint32_t)(isdigit(*cp) ? *cp-'0' : toupper((uint8_t)(*cp))-'A'+10)) < base) {
+        result = result*base + value;
+        cp++;
+    }
+    if (endp)
+        *endp = (char *)cp;
+    return result;
+}
+
+/**
+ * strtol - convert a string to a int32_t
+ * @cp: The start of the string
+ * @endp: A pointer to the end of the parsed string will be placed here
+ * @base: The number base to use
+ */
+long strtol(const char *cp,char **endp,uint32_t base)
+{
+    if(*cp=='-')
+        return (long)(-strtoul(cp+1,endp,base));
+    return (long)strtoul(cp,endp,base);
+}
+
+/**
+ * strtoull - convert a string to an uint64_t
+ * @cp: The start of the string
+ * @endp: A pointer to the end of the parsed string will be placed here
+ * @base: The number base to use
+ */
+uint64_t strtoull(const char *cp,char **endp,uint32_t base)
+{
+    uint64_t result = 0,value;
+
+    if (!base) {
+        base = 10;
+        if (*cp == '0') {
+            base = 8;
+            cp++;
+            if ((*cp == 'x') && isxdigit(cp[1])) {
+                cp++;
+                base = 16;
+            }
+        }
+    }
+    while (isxdigit(*cp) && (value = isdigit(*cp) ? *cp-'0' : (islower(*cp)
+        ? toupper((uint8_t)(*cp)) : *cp)-'A'+10) < base) {
+        result = result*base + value;
+        cp++;
+    }
+    if (endp)
+        *endp = (char *)cp;
+    return result;
+}
+
+/**
+ * strtoll - convert a string to a int64
+ * @cp: The start of the string
+ * @endp: A pointer to the end of the parsed string will be placed here
+ * @base: The number base to use
+ */
+long long strtoll(const char *cp,char **endp,uint32_t base)
+{
+    if(*cp=='-')
+        return (long long)(-strtoull(cp+1,endp,base));
+    return (long long)(strtoull(cp,endp,base));
+}
+
+/**
+ * atoi - convert a string to a int
+ * @s: The start of the string
+ */
+int atoi(const char *s)
+{
+    int i=0;
+    const char **tmp_s = &s;
+
+    while (isdigit(**tmp_s))
+        i = i*10 + *((*tmp_s)++) - '0';
+    return i;
+}
+
+/**
+ * strlen - Find the length of a string
+ * @s: The string to be sized
+ */
+size_t strlen(const char * s)
+{
+    const char *sc;
+
+    for (sc = s; *sc != '\0'; ++sc)
+        /* nothing */;
+
+    return sc - s;
+}
+
+/**
+ * strnlen - Find the length of a length-limited string
+ * @s: The string to be sized
+ * @count: The maximum number of bytes to search
+ */
+size_t strnlen(const char * s, size_t count)
+{
+    const char *sc;
+
+    for (sc = s; count-- && *sc != '\0'; ++sc)
+        /* nothing */;
+
+    return sc - s;
+}
+
+/**
+ * strcpy - Copy a %NUL terminated string
+ * @dest: Where to copy the string to
+ * @src: Where to copy the string from
+ */
+char * strcpy(char * dest,const char *src)
+{
+    char *tmp = dest;
+
+    while ((*dest++ = *src++) != '\0')
+        /* nothing */;
+
+    return tmp;
+}
+#endif /* MODULE */
+
+/**
+ * strtok - Split a string into tokens
+ * @s: The string to be searched
+ * @ct: The characters to search for
+ *
+ * WARNING: strtok is deprecated, use strsep instead.
+ */
+char *___strtok;
+
+char * strtok(char * s,const char * ct)
+{
+    char *sbegin, *send;
+
+    sbegin  = s ? s : ___strtok;
+    if (!sbegin) {
+        return NULL;
+    }
+    sbegin += strspn(sbegin,ct);
+    if (*sbegin == '\0') {
+        ___strtok = NULL;
+        return( NULL );
+    }
+    send = strpbrk( sbegin, ct);
+    if (send && *send != '\0')
+        *send++ = '\0';
+    ___strtok = send;
+    return (sbegin);
+}
+
+
+#ifdef MODULE
+/**
+ * strncpy - Copy a length-limited, %NUL-terminated string
+ * @dest: Where to copy the string to
+ * @src: Where to copy the string from
+ * @count: The maximum number of bytes to copy
+ *
+ * Note that unlike userspace strncpy, this does not %NUL-pad the buffer.
+ * However, the result is not %NUL-terminated if the source exceeds
+ * @count bytes.
+ */
+char * strncpy(char * dest,const char *src,size_t count)
+{
+    char *tmp = dest;
+
+    while (count-- && (*dest++ = *src++) != '\0')
+        /* nothing */;
+
+    return tmp;
+}
+
+/**
+ * vsprintf - Format a string and place it in a buffer
+ * @buf: The buffer to place the result into
+ * @fmt: The format string to use
+ * @args: Arguments for the format string
+ *
+ * Call this function if you are already dealing with a va_list.
+ * You probably want sprintf instead.
+ */
+int vsprintf(char *buf, const char *fmt, va_list args)
+{
+    return vsnprintf(buf, INT32_MAX, fmt, args);
+}
+#endif /* MODULE */
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/xx/udivdi3.c b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/xx/udivdi3.c
new file mode 100644
index 0000000..ca2fd17
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/xx/udivdi3.c
@@ -0,0 +1,132 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <linux/version.h>
+
+#if defined(CONFIG_MODVERSIONS) && !defined(MODVERSIONS)
+#define MODVERSIONS
+#endif
+#ifdef MODVERSIONS
+#include <config/modversions.h>
+#endif /* MODVERSIONS */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <asm/div64.h>
+
+
+#define BITS_PER_UNIT  8
+#define SI_TYPE_SIZE (sizeof (SItype) * BITS_PER_UNIT)
+
+
+typedef unsigned int UQItype    __attribute__ ((mode (QI)));
+typedef          int SItype     __attribute__ ((mode (SI)));
+typedef unsigned int USItype    __attribute__ ((mode (SI)));
+typedef          int DItype     __attribute__ ((mode (DI)));
+typedef          int word_type  __attribute__ ((mode (__word__)));
+typedef unsigned int UDItype    __attribute__ ((mode (DI)));
+
+struct DIstruct {SItype low, high;};
+
+typedef union
+{
+  struct DIstruct s;
+  DItype ll;
+} DIunion;
+
+
+/* bit divisor, dividend and result. dynamic precision */
+static __inline__ uint64_t _div64_64(uint64_t dividend, uint64_t divisor)
+{
+    uint32_t d = divisor;
+
+    if (divisor > 0xffffffffULL)
+    {
+        unsigned int shift = fls(divisor >> 32);
+
+        d = divisor >> shift;
+        dividend >>= shift;
+    }
+
+    /* avoid 64 bit division if possible */
+    if (dividend >> 32)
+        do_div(dividend, d);
+    else
+        dividend = (uint32_t) dividend / d;
+
+    return dividend;
+}
+
+UDItype __udivdi3 (UDItype n, UDItype d)
+{
+  return _div64_64(n, d);
+}
+
+DItype __divdi3 (DItype n, DItype d)
+{
+  DItype sign = 1;
+  if (n<0)
+  {
+    sign *= -1;
+    n *= -1;
+  }
+  if (d<0)
+  {
+    sign *= -1;
+    d *= -1;
+  }
+  return sign*_div64_64((UDItype)n, (UDItype)d);
+}
+
+UDItype __umoddi3 (UDItype n, UDItype d)
+{
+  return n-(_div64_64(n, d)*d);
+}
+
+#ifdef MODULE
+word_type __ucmpdi2 (DItype a, DItype b)
+{
+  DIunion au, bu;
+
+  au.ll = a, bu.ll = b;
+
+  if ((USItype) au.s.high < (USItype) bu.s.high)
+    return 0;
+  else if ((USItype) au.s.high > (USItype) bu.s.high)
+    return 2;
+  if ((USItype) au.s.low < (USItype) bu.s.low)
+    return 0;
+  else if ((USItype) au.s.low > (USItype) bu.s.low)
+    return 2;
+  return 1;
+}
+#endif /* MODULE */
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/xx/xx.h b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/xx/xx.h
new file mode 100644
index 0000000..fbe65dd
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/xx/xx.h
@@ -0,0 +1,43 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __XX_H
+#define __XX_H
+
+#include "xx_ext.h"
+
+
+char  * GetDeviceName(int irq);
+int     GetDeviceIrqNum(int irq);
+
+
+#endif /* __XX_H */
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/xx/xx_linux.c b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/xx/xx_linux.c
new file mode 100644
index 0000000..cacee0f
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/xx/xx_linux.c
@@ -0,0 +1,924 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**************************************************************************//**
+ @File          xx_linux.c
+
+ @Description   XX routines implementation for Linux.
+*//***************************************************************************/
+#include <linux/version.h>
+
+#if defined(CONFIG_MODVERSIONS) && !defined(MODVERSIONS)
+#define MODVERSIONS
+#endif
+#ifdef MODVERSIONS
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+#include <linux/modversions.h>
+#else
+#include <config/modversions.h>
+#endif    /* LINUX_VERSION_CODE */
+#endif /* MODVERSIONS */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/ptrace.h>
+#include <linux/errno.h>
+#include <linux/ioport.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/fs.h>
+#include <linux/vmalloc.h>
+#include <linux/init.h>
+#include <linux/timer.h>
+#include <linux/spinlock.h>
+#include <linux/delay.h>
+#include <linux/proc_fs.h>
+#include <linux/smp.h>
+#include <linux/smp_lock.h>
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+#include <linux/tqueue.h>
+#else
+#include <linux/workqueue.h>
+#endif    /* LINUX_VERSION_CODE */
+
+#ifdef BIGPHYSAREA_ENABLE
+#include <linux/bigphysarea.h>
+#endif /* BIGPHYSAREA_ENABLE */
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,18)
+#include <asm/of_device.h>
+#include <sysdev/fsl_soc.h>
+#endif    /* LINUX_VERSION_CODE */
+#include <asm/pgtable.h>
+#include <asm/irq.h>
+#include <asm/bitops.h>
+#include <asm/uaccess.h>
+#include <asm/system.h>
+#include <asm/io.h>
+#include <asm/atomic.h>
+#include <asm/string.h>
+#include <asm/byteorder.h>
+#include <asm/page.h>
+
+#include "error_ext.h"
+#include "std_ext.h"
+#include "mem_ext.h"
+#include "list_ext.h"
+#include "mm_ext.h"
+#include "platform_ext.h"
+
+#include "xx.h"
+
+
+#define __ERR_MODULE__      MODULE_UNKNOWN
+
+#ifdef BIGPHYSAREA_ENABLE
+#define MAX_ALLOCATION_SIZE     128 * 1024 /* Maximum size allocated with kmalloc is 128K */
+
+
+/* FIXME: large allocations => use big phys area */
+/******************************************************************************
+ * routine:     get_nr_pages
+ *
+ * description:
+ *     calculates the number of memory pages for a given size (in bytes)
+ *
+ * arguments:
+ *     size       - the number of bytes
+ *
+ * return code:
+ *     The number of pages
+ *
+ *****************************************************************************/
+static __inline__ uint32_t get_nr_pages (uint32_t size)
+{
+    return (uint32_t)((size >> PAGE_SHIFT) + (size & PAGE_SHIFT ? 1 : 0));
+}
+
+static bool in_big_phys_area (uint32_t addr)
+{
+    uint32_t base, size;
+
+    bigphysarea_get_details (&base, &size);
+    return ((addr >= base) && (addr < base + size));
+}
+#endif /* BIGPHYSAREA_ENABLE */
+
+static void * xx_Malloc(uint32_t n)
+{
+    void        *a;
+    uint32_t    flags;
+
+    flags = XX_DisableAllIntr();
+#ifdef BIGPHYSAREA_ENABLE
+    if (n >= MAX_ALLOCATION_SIZE)
+        a = (void*)bigphysarea_alloc_pages(get_nr_pages(n), 0, GFP_ATOMIC);
+    else
+#endif /* BIGPHYSAREA_ENABLE */
+    a = (void *)kmalloc((uint32_t)n, GFP_ATOMIC);
+    if (!a)
+        XX_Print("No memory for XX_Malloc\n");
+    XX_RestoreAllIntr(flags);
+
+    return a;
+}
+
+static void xx_Free(void *p)
+{
+#ifdef BIGPHYSAREA_ENABLE
+    if (in_big_phys_area ((uint32_t)p))
+        bigphysarea_free_pages(p);
+    else
+#endif /* BIGPHYSAREA_ENABLE */
+    kfree(p);
+}
+
+static void * xx_MallocSmart(uint32_t size, int memPartitionId, uint32_t alignment)
+{
+    void        *returnCode;
+    uint32_t    tmp;
+
+    switch(memPartitionId) {
+       case(0):
+       case(e_MEM_1ST_DDR_CACHEABLE):
+            if (alignment < 4)
+                alignment = 4;
+            tmp = (uint32_t)(xx_Malloc((uint32_t)(size + alignment)));
+            if (tmp == 0)
+                return NULL;
+            returnCode = (void*)((tmp + alignment) & ~(alignment - 1));
+            *(uint32_t*)((uint32_t)returnCode - 4) = tmp;
+            break;
+        default:
+            XX_Print("XX_MallocSmart:Mem type not supported\r\n");
+            return NULL;
+    }
+    return returnCode;
+}
+
+static void xx_FreeSmart(void *p)
+{
+    xx_Free((void *)(*(uint32_t *)((uint32_t)(p)-4)));
+}
+
+
+void XX_Exit(int status)
+{
+    XX_Print("NetCommSw driver can't go on!!!\r\n");
+    BUG();
+}
+
+#define BUF_SIZE    512
+void XX_Print(char *str, ...)
+{
+    va_list args;
+#ifdef CONFIG_SMP
+    char buf[BUF_SIZE];
+#endif /* CONFIG_SMP */
+
+    va_start(args, str);
+#ifdef CONFIG_SMP
+    if (vsnprintf (buf, BUF_SIZE, str, args) >= BUF_SIZE)
+        printk(KERN_WARNING "Illegal string to print!\n    more than %d characters.\n\tString was not printed completelly.\n", BUF_SIZE);
+    printk (KERN_CRIT "cpu%d/%d: %s",hard_smp_processor_id(), smp_processor_id(), buf);
+#else
+    vprintk(str, args);
+#endif /* CONFIG_SMP */
+    va_end(args);
+}
+
+void XX_Fprint(void *file, char *str, ...)
+{
+    va_list args;
+#ifdef CONFIG_SMP
+    char buf[BUF_SIZE];
+#endif /* CONFIG_SMP */
+
+    va_start(args, str);
+#ifdef CONFIG_SMP
+    if (vsnprintf (buf, BUF_SIZE, str, args) >= BUF_SIZE)
+        printk(KERN_WARNING "Illegal string to print!\n    more than %d characters.\n\tString was not printed completelly.\n", BUF_SIZE);
+    printk (KERN_CRIT "cpu%d/%d: %s",hard_smp_processor_id(), smp_processor_id(), buf);
+#else
+    vprintk(str, args);
+#endif /* CONFIG_SMP */
+    va_end(args);
+}
+
+#ifdef DEBUG_XX_MALLOC
+typedef void (*t_ffn)(void *);
+typedef struct {
+    t_ffn       f_free;
+    void        *mem;
+    char        *fname;
+    int         fline;
+    uint32_t    size;
+    t_List      node;
+} t_MemDebug;
+#define MEMDBG_OBJECT(p_List) LIST_OBJECT(p_List, t_MemDebug, node)
+
+LIST(memDbgLst);
+
+
+void * XX_MallocDebug(uint32_t size, char *fname, int line)
+{
+    void       *mem;
+    t_MemDebug *p_MemDbg;
+
+    p_MemDbg = (t_MemDebug *)xx_Malloc(sizeof(t_MemDebug));
+    if (p_MemDbg == NULL)
+        return NULL;
+
+    mem = xx_Malloc(size);
+    if (mem == NULL)
+    {
+        XX_Free(p_MemDbg);
+        return NULL;
+    }
+
+    INIT_LIST(&p_MemDbg->node);
+    p_MemDbg->f_free = xx_Free;
+    p_MemDbg->mem    = mem;
+    p_MemDbg->fname  = fname;
+    p_MemDbg->fline  = line;
+    p_MemDbg->size   = size+sizeof(t_MemDebug);
+    LIST_AddToTail(&p_MemDbg->node, &memDbgLst);
+
+    return mem;
+}
+
+void * XX_MallocSmartDebug(uint32_t size,
+                           int      memPartitionId,
+                           uint32_t align,
+                           char     *fname,
+                           int      line)
+{
+    void       *mem;
+    t_MemDebug *p_MemDbg;
+
+    p_MemDbg = (t_MemDebug *)XX_Malloc(sizeof(t_MemDebug));
+    if (p_MemDbg == NULL)
+        return NULL;
+
+    mem = xx_MallocSmart((uint32_t)size, memPartitionId, align);
+    if (mem == NULL)
+    {
+        XX_Free(p_MemDbg);
+        return NULL;
+    }
+
+    INIT_LIST(&p_MemDbg->node);
+    p_MemDbg->f_free = xx_FreeSmart;
+    p_MemDbg->mem    = mem;
+    p_MemDbg->fname  = fname;
+    p_MemDbg->fline  = line;
+    p_MemDbg->size   = size+sizeof(t_MemDebug);
+    LIST_AddToTail(&p_MemDbg->node, &memDbgLst);
+
+    return mem;
+}
+
+static void debug_free(void *mem)
+{
+    t_List      *p_MemDbgLh = NULL;
+    t_MemDebug  *p_MemDbg;
+    bool        found = FALSE;
+
+    if (LIST_IsEmpty(&memDbgLst))
+    {
+        REPORT_ERROR(MAJOR, E_ALREADY_FREE, ("Unbalanced free (0x%08x)", mem));
+        return;
+    }
+
+    LIST_FOR_EACH(p_MemDbgLh, &memDbgLst)
+    {
+        p_MemDbg = MEMDBG_OBJECT(p_MemDbgLh);
+        if (p_MemDbg->mem == mem)
+        {
+            found = TRUE;
+            break;
+        }
+    }
+
+    if (!found)
+    {
+        REPORT_ERROR(MAJOR, E_NOT_FOUND,
+                     ("Attempt to free unallocated address (0x%08x)",mem));
+        return;
+    }
+
+    LIST_Del(p_MemDbgLh);
+    XX_Free(mem);
+    XX_Free(p_MemDbg);
+}
+
+void XX_FreeSmart(void *p)
+{
+    debug_free(p);
+}
+
+
+void XX_Free(void *p)
+{
+    debug_free(p);
+}
+
+#else /* not DEBUG_XX_MALLOC */
+void * XX_Malloc(uint32_t size)
+{
+    return xx_Malloc(size);
+}
+
+void * XX_MallocSmart(uint32_t size, int memPartitionId, uint32_t alignment)
+{
+    return xx_MallocSmart(size,memPartitionId, alignment);
+}
+
+void XX_FreeSmart(void *p)
+{
+    xx_FreeSmart(p);
+}
+
+
+void XX_Free(void *p)
+{
+    xx_Free(p);
+}
+#endif /* not DEBUG_XX_MALLOC */
+
+
+#if (defined(REPORT_EVENTS) && (REPORT_EVENTS > 0))
+void XX_EventById(uint32_t event, t_Handle appId, uint16_t flags, char *msg)
+{
+    e_Event eventCode = (e_Event)event;
+
+    UNUSED(eventCode);
+    UNUSED(appId);
+    UNUSED(flags);
+    UNUSED(msg);
+}
+#endif /* (defined(REPORT_EVENTS) && ... */
+
+
+uint32_t XX_DisableAllIntr(void)
+{
+    unsigned long flags;
+
+    local_irq_save(flags);
+
+    return (uint32_t)flags;
+}
+
+void XX_RestoreAllIntr(uint32_t flags)
+{
+    local_irq_restore(flags);
+}
+
+t_Error XX_Call( uint32_t qid, t_Error (* f)(t_Handle), t_Handle id, t_Handle appId, uint16_t flags )
+{
+    UNUSED(qid);
+    UNUSED(appId);
+    UNUSED(flags);
+
+    return f(id);
+}
+
+int XX_IsICacheEnable(void)
+{
+    return TRUE;
+}
+
+int XX_IsDCacheEnable(void)
+{
+    return TRUE;
+}
+
+
+typedef struct {
+    t_Isr       *f_Isr;
+    t_Handle    handle;
+} t_InterruptHandler;
+
+
+t_Handle interruptHandlers[0x00010000];
+
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+static void LinuxInterruptHandler(int irq, void * dev_id, struct pt_regs * regs)
+{
+    t_InterruptHandler *p_IntrHndl = (t_InterruptHandler *)dev_id;
+    p_IntrHndl->f_Isr(p_IntrHndl->handle);
+}
+#elif LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19)
+static int LinuxInterruptHandler(int irq, void * dev_id, struct pt_regs * regs)
+{
+    t_InterruptHandler *p_IntrHndl = (t_InterruptHandler *)dev_id;
+    p_IntrHndl->f_Isr(p_IntrHndl->handle);
+    return IRQ_HANDLED;
+}
+#else
+static irqreturn_t LinuxInterruptHandler (int irq, void *dev_id)
+{
+    t_InterruptHandler *p_IntrHndl = (t_InterruptHandler *)dev_id;
+    p_IntrHndl->f_Isr(p_IntrHndl->handle);
+    return IRQ_HANDLED;
+}
+#endif    /* LINUX_VERSION_CODE */
+
+t_Error XX_SetIntr(int irq, t_Isr *f_Isr, t_Handle handle)
+{
+    const char *device;
+    t_InterruptHandler *p_IntrHndl;
+
+    device = GetDeviceName(irq);
+    if (device == NULL)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Interrupt source - %d", irq));
+
+    p_IntrHndl = (t_InterruptHandler *)XX_Malloc(sizeof(t_InterruptHandler));
+    if (p_IntrHndl == NULL)
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, NO_MSG);
+    p_IntrHndl->f_Isr = f_Isr;
+    p_IntrHndl->handle = handle;
+    interruptHandlers[irq] = p_IntrHndl;
+
+    if (request_irq(GetDeviceIrqNum(irq), LinuxInterruptHandler, 0, device, p_IntrHndl) < 0)
+        RETURN_ERROR(MAJOR, E_BUSY, ("Can't get IRQ %s\n", device));
+    disable_irq(GetDeviceIrqNum(irq));
+
+    return E_OK;
+}
+
+t_Error XX_FreeIntr(int irq)
+{
+    t_InterruptHandler *p_IntrHndl = interruptHandlers[irq];
+    free_irq(GetDeviceIrqNum(irq), p_IntrHndl);
+    XX_Free(p_IntrHndl);
+    interruptHandlers[irq] = 0;
+    return E_OK;
+}
+
+t_Error XX_EnableIntr(int irq)
+{
+    enable_irq(GetDeviceIrqNum(irq));
+    return E_OK;
+}
+
+t_Error XX_DisableIntr(int irq)
+{
+    disable_irq(GetDeviceIrqNum(irq));
+    return E_OK;
+}
+
+
+/*****************************************************************************/
+/*                       Tasklet Service Routines                            */
+/*****************************************************************************/
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20)
+typedef struct
+{
+    t_Handle            h_Data;
+    void                (*f_Callback) (void *);
+    struct delayed_work dwork;
+} t_Tasklet;
+
+static void GenericTaskletCallback(struct work_struct *p_Work)
+{
+    t_Tasklet *p_Task = container_of(p_Work, t_Tasklet, dwork.work);
+
+    p_Task->f_Callback(p_Task->h_Data);
+}
+#endif    /* LINUX_VERSION_CODE */
+
+
+t_TaskletHandle XX_InitTasklet (void (*routine)(void *), void *data)
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+    struct tq_struct *p_Task;
+    p_Task = (struct tq_struct *)XX_Malloc(sizeof(struct tq_struct));
+    INIT_TQUEUE(p_Task, routine, data);
+#elif LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20)
+    struct work_struct *p_Task;
+    p_Task = (struct work_struct *)XX_Malloc(sizeof(struct work_struct));
+    INIT_WORK(p_Task, routine, data);
+#else
+    t_Tasklet *p_Task = (t_Tasklet *)XX_Malloc(sizeof(t_Tasklet));
+    INIT_DELAYED_WORK(&p_Task->dwork, GenericTaskletCallback);
+    p_Task->h_Data = data;
+    p_Task->f_Callback = routine;
+#endif    /* LINUX_VERSION_CODE */
+
+    return (t_TaskletHandle)p_Task;
+}
+
+
+void XX_FreeTasklet (t_TaskletHandle h_Tasklet)
+{
+    if (h_Tasklet)
+        XX_Free(h_Tasklet);
+}
+
+int XX_ScheduleTask(t_TaskletHandle h_Tasklet, int immediate)
+{
+    int ans;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+    UNUSED(immediate);
+    ans = queue_task(h_Tasklet, &tq_immediate);
+    mark_bh(IMMEDIATE_BH);
+#elif LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20)
+    if (immediate)
+        ans = schedule_work(h_Tasklet);
+    else
+        ans = schedule_delayed_work(h_Tasklet, 1);
+#else
+    if (immediate)
+        ans = schedule_delayed_work(&((t_Tasklet *)h_Tasklet)->dwork, 0);
+    else
+        ans = schedule_delayed_work(&((t_Tasklet *)h_Tasklet)->dwork, HZ);
+#endif /* LINUX_VERSION_CODE */
+
+    return ans;
+}
+
+void XX_FlushScheduledTasks(void)
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+    flush_scheduled_tasks();
+#else
+    flush_scheduled_work();
+#endif    /* LINUX_VERSION_CODE */
+}
+
+int XX_TaskletIsQueued(t_TaskletHandle h_Tasklet)
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+    return (int)(((struct tq_struct *)h_Tasklet)->sync);
+#elif LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20)
+    return (int)(((struct work_struct *)h_Tasklet)->pending);
+#else
+    return (int)delayed_work_pending(&((t_Tasklet *)h_Tasklet)->dwork);
+#endif    /* LINUX_VERSION_CODE */
+}
+
+void XX_SetTaskletData(t_TaskletHandle h_Tasklet, t_Handle data)
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+    ((struct tq_struct *)h_Tasklet)->data = data;
+#elif LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20)
+    ((struct work_struct *)h_Tasklet)->data = data;
+#else
+    ((t_Tasklet *)h_Tasklet)->h_Data = data;
+#endif    /* LINUX_VERSION_CODE */
+}
+
+t_Handle XX_GetTaskletData(t_TaskletHandle h_Tasklet)
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+    return (t_Handle)(((struct tq_struct *)h_Tasklet)->data);
+#elif LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20)
+    return (t_Handle)(((struct work_struct *)h_Tasklet)->data);
+#else
+    return ((t_Tasklet *)h_Tasklet)->h_Data;
+#endif    /* LINUX_VERSION_CODE */
+}
+
+
+/*****************************************************************************/
+/*                       Semaphore Service Routines                          */
+/*****************************************************************************/
+t_SemaphoreHandle XX_InitSemaphore(int val)
+{
+    struct semaphore *p_Semaphore = (struct semaphore *)XX_Malloc(sizeof(struct semaphore));
+    if (p_Semaphore)
+        sema_init (p_Semaphore, val);
+    return (t_SemaphoreHandle)p_Semaphore;
+}
+
+void XX_FreeSemaphore(t_SemaphoreHandle h_Semaphore)
+{
+    if (h_Semaphore)
+        XX_Free(h_Semaphore);
+}
+
+t_MutexHandle XX_InitMutex(void)
+{
+    return (t_MutexHandle)XX_InitSemaphore(1);
+}
+
+
+t_MutexHandle XX_InitMutexLocked(void)
+{
+    return (t_MutexHandle)XX_InitSemaphore(0);
+}
+
+void XX_FreeMutex(t_MutexHandle h_Mutex)
+{
+    XX_FreeSemaphore(h_Mutex);
+}
+
+void XX_Lock(t_MutexHandle h_Mutex)
+{
+    down((struct semaphore *)h_Mutex);
+}
+
+void XX_Unlock(t_MutexHandle h_Mutex)
+{
+    up((struct semaphore *)h_Mutex);
+}
+
+
+/*****************************************************************************/
+/*                         Spinlock Service Routines                         */
+/*****************************************************************************/
+typedef struct {
+    unsigned long   flags;
+    spinlock_t      *p_Lock;
+} t_Spinlock;
+
+t_SpinlockHandle XX_InitSpinlock(void)
+{
+    t_Spinlock *p_Spinlock = (t_Spinlock *)XX_Malloc(sizeof(t_Spinlock));
+    if (!p_Spinlock)
+        return NULL;
+    memset(p_Spinlock, 0 , sizeof(t_Spinlock));
+    p_Spinlock->p_Lock = (spinlock_t *)XX_Malloc(sizeof(spinlock_t));
+    if (!p_Spinlock->p_Lock)
+    {
+        XX_Free(p_Spinlock);
+        return NULL;
+    }
+
+    spin_lock_init (p_Spinlock->p_Lock);
+    return (t_SpinlockHandle)p_Spinlock;
+}
+
+void XX_FreeSpinlock(t_SpinlockHandle h_Spinlock)
+{
+    if (h_Spinlock)
+    {
+        if (((t_Spinlock *)h_Spinlock)->p_Lock)
+            XX_Free(((t_Spinlock *)h_Spinlock)->p_Lock);
+        XX_Free(h_Spinlock);
+    }
+}
+
+void XX_Spinlock(t_SpinlockHandle h_Spinlock)
+{
+    spin_lock(((t_Spinlock *)h_Spinlock)->p_Lock);
+}
+
+void XX_Spinunlock(t_SpinlockHandle h_Spinlock)
+{
+    spin_unlock(((t_Spinlock *)h_Spinlock)->p_Lock);
+}
+
+void XX_IntrSpinlock(t_SpinlockHandle h_Spinlock)
+{
+    spin_lock_irqsave(((t_Spinlock *)h_Spinlock)->p_Lock, ((t_Spinlock *)h_Spinlock)->flags);
+}
+
+void XX_IntrSpinunlock(t_SpinlockHandle h_Spinlock)
+{
+    spin_unlock_irqrestore(((t_Spinlock *)h_Spinlock)->p_Lock, ((t_Spinlock *)h_Spinlock)->flags);
+}
+
+
+/*****************************************************************************/
+/*                        Timers Service Routines                            */
+/*****************************************************************************/
+/* The time now is in mili sec. resolution */
+uint32_t XX_CurrentTime(void)
+{
+    return (jiffies*1000)/HZ;
+}
+
+
+t_TimerHandle XX_CreateTimer(void)
+{
+    struct timer_list *p_Timer = (struct timer_list *)XX_Malloc(sizeof(struct timer_list));
+    if (p_Timer)
+    {
+        memset(p_Timer, 0, sizeof(struct timer_list));
+        init_timer(p_Timer);
+    }
+    return (t_TimerHandle)p_Timer;
+}
+
+void XX_FreeTimer(t_TimerHandle h_Timer)
+{
+    if (h_Timer)
+        XX_Free(h_Timer);
+}
+
+void XX_StartTimer(t_TimerHandle    h_Timer,
+                   uint32_t         msecs,
+                   bool             periodic,
+                   void             (*f_TimerExpired)(t_Handle),
+                   t_Handle         h_Arg)
+{
+    int                 tmp_jiffies = (msecs*HZ)/1000;
+    struct timer_list   *p_Timer = (struct timer_list *)h_Timer;
+
+    SANITY_CHECK_RETURN((periodic == FALSE), E_NOT_SUPPORTED);
+
+    p_Timer->function = (void (*)(unsigned long))f_TimerExpired;
+    p_Timer->data = (unsigned long)h_Arg;
+    if ((msecs*HZ)%1000)
+        tmp_jiffies++;
+    p_Timer->expires = (jiffies + tmp_jiffies);
+
+    add_timer((struct timer_list *)h_Timer);
+}
+
+void XX_SetTimerData(t_TimerHandle h_Timer, t_Handle data)
+{
+    struct timer_list   *p_Timer = (struct timer_list *)h_Timer;
+
+    p_Timer->data = (unsigned long)data;
+}
+
+t_Handle XX_GetTimerData(t_TimerHandle h_Timer)
+{
+    struct timer_list   *p_Timer = (struct timer_list *)h_Timer;
+
+    return (t_Handle)p_Timer->data;
+}
+
+uint32_t   XX_GetExpirationTime(t_TimerHandle h_Timer)
+{
+    struct timer_list   *p_Timer = (struct timer_list *)h_Timer;
+
+    return (uint32_t)p_Timer->expires;
+}
+
+void XX_StopTimer(t_TimerHandle h_Timer)
+{
+    del_timer((struct timer_list *)h_Timer);
+}
+
+void XX_ModTimer(t_TimerHandle h_Timer, uint32_t msecs)
+{
+    int tmp_jiffies = (msecs*HZ)/1000;
+
+    if ((msecs*HZ)%1000)
+        tmp_jiffies++;
+    mod_timer((struct timer_list *)h_Timer, jiffies + tmp_jiffies);
+}
+
+int XX_TimerIsActive(t_TimerHandle h_Timer)
+{
+  return timer_pending((struct timer_list *)h_Timer);
+}
+
+uint32_t XX_Sleep(uint32_t msecs)
+{
+    int tmp_jiffies = (msecs*HZ)/1000;
+
+    if ((msecs*HZ)%1000)
+        tmp_jiffies++;
+    return schedule_timeout(tmp_jiffies);
+}
+
+/*BEWARE!!!!! UDelay routine is BUSY WAITTING!!!!!*/
+void XX_UDelay(uint32_t usecs)
+{
+    udelay(usecs);
+}
+
+#ifdef CONFIG_MULTI_PARTITION_SUPPORT
+typedef struct {
+    char            *p_Addr;
+    t_MsgHandler    *f_MsgHandlerCB;
+    t_Handle        h_Mod;
+    t_List          node;
+} t_MsgHndlr;
+#define MSG_HNDLR_OBJECT(ptr)  LIST_OBJECT(ptr, t_MsgHndlr, node)
+
+LIST(msgHndlrList);
+
+static void EnqueueMsgHndlr(t_MsgHndlr *p_MsgHndlr)
+{
+    uint32_t   intFlags;
+
+    intFlags = XX_DisableAllIntr();
+    LIST_AddToTail(&p_MsgHndlr->node, &msgHndlrList);
+    XX_RestoreAllIntr(intFlags);
+}
+
+static t_MsgHndlr * DequeueMsgHndlr(void)
+{
+    t_MsgHndlr *p_MsgHndlr = NULL;
+    uint32_t   intFlags;
+
+    intFlags = XX_DisableAllIntr();
+    if (!LIST_IsEmpty(&msgHndlrList))
+    {
+        p_MsgHndlr = MSG_HNDLR_OBJECT(msgHndlrList.p_Next);
+        LIST_DelAndInit(&p_MsgHndlr->node);
+    }
+    XX_RestoreAllIntr(intFlags);
+
+    return p_MsgHndlr;
+}
+
+static t_MsgHndlr * FindMsgHndlr(char *p_Addr)
+{
+    t_MsgHndlr  *p_MsgHndlr;
+    t_List      *p_Pos;
+
+    LIST_FOR_EACH(p_Pos, &msgHndlrList)
+    {
+        p_MsgHndlr = MSG_HNDLR_OBJECT(p_Pos);
+        if (strstr(p_MsgHndlr->p_Addr, p_Addr))
+            return p_MsgHndlr;
+    }
+
+    return NULL;
+}
+
+t_Error XX_RegisterMessageHandler   (char *p_Addr, t_MsgHandler *f_MsgHandlerCB, t_Handle h_Mod)
+{
+    t_MsgHndlr  *p_MsgHndlr;
+    uint32_t    len;
+
+    p_MsgHndlr = (t_MsgHndlr*)XX_Malloc(sizeof(t_MsgHndlr));
+    if (!p_MsgHndlr)
+        RETURN_ERROR(MINOR, E_NO_MEMORY, ("message handler object!!!"));
+    memset(p_MsgHndlr, 0, sizeof(t_MsgHndlr));
+
+    len = strlen(p_Addr);
+    p_MsgHndlr->p_Addr = (char*)XX_Malloc(len+1);
+    strncpy(p_MsgHndlr->p_Addr,p_Addr, (uint32_t)(len+1));
+
+    p_MsgHndlr->f_MsgHandlerCB = f_MsgHandlerCB;
+    p_MsgHndlr->h_Mod = h_Mod;
+    INIT_LIST(&p_MsgHndlr->node);
+    EnqueueMsgHndlr(p_MsgHndlr);
+
+    return E_OK;
+}
+
+t_Error XX_UnregisterMessageHandler (char *p_Addr)
+{
+    t_MsgHndlr *p_MsgHndlr = FindMsgHndlr(p_Addr);
+    if (!p_MsgHndlr)
+        RETURN_ERROR(MINOR, E_NO_DEVICE, ("message handler not found in list!!!"));
+
+    LIST_Del(&p_MsgHndlr->node);
+    XX_Free(p_MsgHndlr->p_Addr);
+    XX_Free(p_MsgHndlr);
+
+    return E_OK;
+}
+
+t_Error XX_SendMessage(char                 *p_DestAddr,
+                       uint32_t             msgId,
+                       uint8_t              msgBody[MSG_BODY_SIZE],
+                       t_MsgCompletionCB    *f_CompletionCB,
+                       t_Handle             h_CBArg)
+{
+    t_Error     ans;
+    t_MsgHndlr  *p_MsgHndlr = FindMsgHndlr(p_DestAddr);
+    if (!p_MsgHndlr)
+        RETURN_ERROR(MINOR, E_NO_DEVICE, ("message handler not found in list!!!"));
+
+    ans = p_MsgHndlr->f_MsgHandlerCB(p_MsgHndlr->h_Mod, msgId, msgBody);
+
+    if (f_CompletionCB)
+        f_CompletionCB(h_CBArg, msgBody);
+
+    return ans;
+}
+#endif /* CONFIG_MULTI_PARTITION_SUPPORT */
diff --git a/drivers/net/dpa/mac-api.c b/drivers/net/dpa/mac-api.c
index 7971a95..3868dfa 100644
--- a/drivers/net/dpa/mac-api.c
+++ b/drivers/net/dpa/mac-api.c
@@ -145,18 +145,6 @@ static int __devinit __cold init(struct mac_device *mac_dev)
 		}
 	}
 
-#ifdef CONFIG_FSL_FMAN_TEST
-	if ((param.enetMode == e_ENET_MODE_XGMII_10000) || param.macId) {
-		err = FM_MAC_ConfigLoopback(priv->mac, true);
-		_errno = -GET_ERROR_TYPE(err);
-		if (unlikely(_errno < 0)) {
-			cpu_dev_err(mac_dev->dev, "%s:%hu:%s(): FM_MAC_ConfigLoopback() = 0x%08x\n",
-				    __file__, __LINE__, __func__, err);
-			goto _return_fm_mac_free;
-		}
-	}
-#endif /* CONFIG_FSL_FMAN_TEST */
-
 	err = FM_MAC_Init(priv->mac);
 	_errno = -GET_ERROR_TYPE(err);
 	if (unlikely(_errno < 0)) {
diff --git a/drivers/net/dpa/mac.c b/drivers/net/dpa/mac.c
index af6de21..6986c4d 100644
--- a/drivers/net/dpa/mac.c
+++ b/drivers/net/dpa/mac.c
@@ -173,19 +173,7 @@ static int __devinit __cold mac_probe(struct of_device *_of_dev, const struct of
 		goto _return_of_node_put;
 	}
 
-#ifdef CONFIG_GUEST_PARTITION
-	uint32_prop = of_get_property(dev_node, "cell-index", &lenp);
-	if (unlikely(uint32_prop == NULL)) {
-		cpu_dev_err(dev, "%s:%hu:%s(): of_get_property(%s, cell-index) failed\n",
-			    __file__, __LINE__, __func__, dev_node->full_name);
-		_errno = -EINVAL;
-		goto _return;
-	}
-	BUG_ON(lenp != sizeof(uint32_t));
-    mac_dev->fm = (void *)*uint32_prop;
-#else
     mac_dev->fm = (void *)fm_get_handle(mac_dev->fm_dev);
-#endif /* CONFIG_GUEST_PARTITION */
 	of_node_put(dev_node);
 
 	/* Get the address of the memory mapped registers */
-- 
1.6.3.3

