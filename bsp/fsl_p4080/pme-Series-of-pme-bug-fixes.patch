From 453e891114829ec4b7b360c368b0fe4438aebd00 Mon Sep 17 00:00:00 2001
From: Jeffrey Ladouceur <Jeffrey.Ladouceur@freescale.com>
Date: Tue, 27 Oct 2009 19:19:19 -0400
Subject: [PATCH 076/148] pme: Series of pme bug fixes.

* Missing check for null pointer and
  check for missing token lookup.

* Added api to header file.
* Change to pass enum by value rather then pointer.

* There is an invalid mask value being applied against
  the value of the PSCL register causing an invalid
  value to be returned.

Signed-off-by: Jeffrey Ladouceur <Jeffrey.Ladouceur@freescale.com>
[Applied FSL SDK 2.0.3 patch "kernel-2.6.30-pme-Series-of-pme-bug-fixes.patch"]
Integrated-by: Yuri Nedel <Yuri.Nedel@windriver.com>
---
 drivers/match/pme2_ctrl.c  |   37 +++++++++++++++----------------------
 drivers/match/pme2_high.c  |   15 ++++++++++++---
 drivers/match/pme2_sys.h   |    1 -
 drivers/match/pme2_sysfs.c |    4 ++--
 include/linux/fsl_pme.h    |    1 +
 5 files changed, 30 insertions(+), 28 deletions(-)

diff --git a/drivers/match/pme2_ctrl.c b/drivers/match/pme2_ctrl.c
index ce9fb6c..e74e21a 100644
--- a/drivers/match/pme2_ctrl.c
+++ b/drivers/match/pme2_ctrl.c
@@ -893,8 +893,6 @@ int pme_attr_get(enum pme_attr attr, u32 *val)
 	case pme_attr_sre_pscl:
 		/* bits 22..31 */
 		attr_val = pme_in(global_pme, SFRCC);
-		/* clear unwanted bits in val*/
-		attr_val &= 0x000000FF;
 		break;
 
 	case pme_attr_sre_max_block_num:
@@ -1196,34 +1194,29 @@ static enum pme_attr stat_list[] = {
 static u64 pme_stats[sizeof(stat_list)/sizeof(enum pme_attr)];
 static DEFINE_SPINLOCK(stat_lock);
 
-int pme_stat_get(enum pme_attr *stat, u64 *value, int reset)
+int pme_stat_get(enum pme_attr stat, u64 *value, int reset)
 {
 	int i, ret = 0;
 	int value_set = 0;
 	u32 val;
 
 	spin_lock_irq(&stat_lock);
-	if (stat == NULL || value == NULL) {
-		pr_err("pme: Invalid stat request %d\n", *stat);
-		ret = -EINVAL;
-	} else {
-		for (i = 0; i < sizeof(stat_list)/sizeof(enum pme_attr); i++) {
-			if (stat_list[i] == *stat) {
-				ret = pme_attr_get(stat_list[i], &val);
-				/* Do I need to check ret */
-				pme_stats[i] += val;
-				*value = pme_stats[i];
-				value_set = 1;
-				if (reset)
-					pme_stats[i] = 0;
-				break;
-			}
-		}
-		if (!value_set) {
-			pr_err("pme: Invalid stat request %d\n", *stat);
-			ret = -EINVAL;
+	for (i = 0; i < sizeof(stat_list)/sizeof(enum pme_attr); i++) {
+		if (stat_list[i] == stat) {
+			ret = pme_attr_get(stat_list[i], &val);
+			/* Do I need to check ret */
+			pme_stats[i] += val;
+			*value = pme_stats[i];
+			value_set = 1;
+			if (reset)
+				pme_stats[i] = 0;
+			break;
 		}
 	}
+	if (!value_set) {
+		pr_err("pme: Invalid stat request %d\n", stat);
+		ret = -EINVAL;
+	}
 	spin_unlock_irq(&stat_lock);
 	return ret;
 }
diff --git a/drivers/match/pme2_high.c b/drivers/match/pme2_high.c
index ff9bae4..729ef21 100644
--- a/drivers/match/pme2_high.c
+++ b/drivers/match/pme2_high.c
@@ -583,6 +583,10 @@ int pme_ctx_ctrl_update_flow(struct pme_ctx *ctx, u32 flags,
 
 	BUG_ON(ctx->flags & PME_CTX_FLAG_DIRECT);
 	token->base_token.cmd_type = pme_cmd_flow_write;
+	memset(&fd, 0, sizeof(fd));
+	token->internal_flow_ptr = pme_hw_flow_new();
+	if (!token->internal_flow_ptr)
+		return -ENOMEM;
 
 	if (flags & PME_CTX_OP_RESETRESLEN) {
 		if (ctx->hw_residue) {
@@ -594,12 +598,12 @@ int pme_ctx_ctrl_update_flow(struct pme_ctx *ctx, u32 flags,
 	/* allocate residue memory if it is being added */
 	if ((flags & PME_CMD_FCW_RES) && params->ren && !ctx->hw_residue) {
 		ctx->hw_residue = pme_hw_residue_new();
-		if (!ctx->hw_residue)
+		if (!ctx->hw_residue) {
+			pme_hw_flow_free(token->internal_flow_ptr);
 			return -ENOMEM;
+		}
 	}
 	/* enqueue the FCW command to PME */
-	memset(&fd, 0, sizeof(fd));
-	token->internal_flow_ptr = pme_hw_flow_new();
 	memcpy(token->internal_flow_ptr, params, sizeof(struct pme_flow));
 	pme_fd_cmd_fcw(&fd, flags & PME_CMD_FCW_ALL,
 			(struct pme_flow *)token->internal_flow_ptr,
@@ -708,6 +712,8 @@ static inline struct pme_ctx_token *pop_matching_token(struct pme_ctx *ctx,
 		}
 	}
 	token = NULL;
+	pr_err("PME2 Could not find matching token!\n");
+	BUG_ON(1);
 found:
 	spin_unlock_irq(&ctx->lock);
 	return token;
@@ -723,6 +729,8 @@ static inline void cb_helper(struct qman_portal *portal, struct pme_ctx *ctx,
 	if (error)
 		do_flags(ctx, 0, 0, PME_CTX_FLAG_DEAD, 0);
 	token = pop_matching_token(ctx, fd);
+	if (unlikely(!token))
+		goto done;
 	if (likely(token->cmd_type == pme_cmd_scan))
 		ctx->cb(ctx, fd, token);
 	else if (token->cmd_type == pme_cmd_pmtcc)
@@ -744,6 +752,7 @@ static inline void cb_helper(struct qman_portal *portal, struct pme_ctx *ctx,
 		}
 		ctrl_token->cb(ctx, fd, ctrl_token);
 	}
+done:
 	/* Consume the frame */
 	if (ctx->flags & PME_CTX_FLAG_EXCLUSIVE)
 		release_exclusive(ctx);
diff --git a/drivers/match/pme2_sys.h b/drivers/match/pme2_sys.h
index 41b6c85..bda1035 100644
--- a/drivers/match/pme2_sys.h
+++ b/drivers/match/pme2_sys.h
@@ -42,6 +42,5 @@
 #include <linux/fsl_pme.h>
 int pme2_create_sysfs_dev_files(struct of_device *ofdev);
 void pme2_remove_sysfs_dev_files(struct of_device *ofdev);
-int pme_stat_get(enum pme_attr *stat, u64 *value, int reset);
 void accumulator_update_interval(u32 interval);
 
diff --git a/drivers/match/pme2_sysfs.c b/drivers/match/pme2_sysfs.c
index 8a5daaa..cafcf79 100644
--- a/drivers/match/pme2_sysfs.c
+++ b/drivers/match/pme2_sysfs.c
@@ -77,7 +77,7 @@ static ssize_t pme_stat_show(struct device *dev,
 	u64 data = 0;
 	int ret = 0;
 
-	ret = pme_stat_get(&attr, &data, 0);
+	ret = pme_stat_get(attr, &data, 0);
 	if (!ret)
 		return snprintf(buf, PAGE_SIZE, "%llu\n", data);
 	else
@@ -99,7 +99,7 @@ static ssize_t pme_stat_store(struct device *dev,
 		pr_err("pme: invalid input %s\n", buf);
 		return -EINVAL;
 	}
-	ret = pme_stat_get(&attr, &data, 1);
+	ret = pme_stat_get(attr, &data, 1);
 	return count;
 }
 
diff --git a/include/linux/fsl_pme.h b/include/linux/fsl_pme.h
index 3bf5477..6415a37 100644
--- a/include/linux/fsl_pme.h
+++ b/include/linux/fsl_pme.h
@@ -698,6 +698,7 @@ enum pme_attr {
 /* Get/set driver attributes */
 int pme_attr_set(enum pme_attr attr, u32 val);
 int pme_attr_get(enum pme_attr attr, u32 *val);
+int pme_stat_get(enum pme_attr stat, u64 *value, int reset);
 #endif /* defined(CONFIG_FSL_PME2_CTRL) */
 
 #endif /* __KERNEL__ */
-- 
1.6.5.2

