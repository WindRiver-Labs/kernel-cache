From ec21b1fa1383c5de705eabb40de5e9711cc42e0b Mon Sep 17 00:00:00 2001
From: Geoff Thorpe <Geoff.Thorpe@freescale.com>
Date: Wed, 11 Nov 2009 21:27:03 -0500
Subject: [PATCH] pme2: extend scan API to support ORP.

Signed-off-by: Bharat Bhushan <Bharat.Bhushan@freescale.com>
Signed-off-by: Geoff Thorpe <Geoff.Thorpe@freescale.com>
[Kevin: Original patch taken from Freescale p4080 SDK 2.0.1 ISO image.
Apply cleanly to kernel 2.6.27]
Integrated-by: Kevin Hao <kexin.hao@windriver.com>
---
 drivers/match/pme2_high.c    |   59 +++++++++++++++++++++--------------------
 drivers/match/pme2_private.h |    1 +
 include/linux/fsl_pme.h      |    7 +++++
 3 files changed, 38 insertions(+), 29 deletions(-)

diff --git a/drivers/match/pme2_high.c b/drivers/match/pme2_high.c
index 61a25c8..ed389f5 100644
--- a/drivers/match/pme2_high.c
+++ b/drivers/match/pme2_high.c
@@ -542,10 +542,9 @@ static int get_work(struct pme_ctx *ctx, u32 flags)
 	return ret;
 }
 
-static int do_work(struct pme_ctx *ctx, u32 flags, struct qm_fd *fd,
-		struct pme_ctx_token *token)
+static inline int do_work(struct pme_ctx *ctx, u32 flags, struct qm_fd *fd,
+		struct pme_ctx_token *token, struct qman_fq *orp_fq, u16 seqnum)
 {
-	u32 seq_num;
 	int ret = get_work(ctx, flags);
 	if (ret)
 		return ret;
@@ -558,16 +557,21 @@ static int do_work(struct pme_ctx *ctx, u32 flags, struct qm_fd *fd,
 	}
 	BUG_ON(sizeof(*fd) != sizeof(token->blob));
 	memcpy(&token->blob, fd, sizeof(*fd));
+
 	spin_lock_irq(&ctx->lock);
-	seq_num = ctx->seq_num++;
-	ctx->seq_num &= QM_EQCR_SEQNUM_SEQMASK; /* rollover at 2^14 */
 	list_add_tail(&token->node, &ctx->tokens);
+	if (!orp_fq) {
+		seqnum = ctx->seq_num++;
+		ctx->seq_num &= QM_EQCR_SEQNUM_SEQMASK; /* rollover at 2^14 */
+		orp_fq = ctx->fqin;
+	}
 	spin_unlock_irq(&ctx->lock);
+
 	if (ctx->flags & PME_CTX_FLAG_NO_ORP)
 		ret = qman_enqueue(ctx->fqin, fd, ctrl2eq(flags));
 	else
 		ret = qman_enqueue_orp(ctx->fqin, fd, ctrl2eq(flags),
-					ctx->fqin, seq_num);
+					orp_fq, seqnum);
 	if (ret) {
 		if (ctx->flags & PME_CTX_FLAG_EXCLUSIVE)
 			release_exclusive(ctx);
@@ -583,10 +587,6 @@ int pme_ctx_ctrl_update_flow(struct pme_ctx *ctx, u32 flags,
 
 	BUG_ON(ctx->flags & PME_CTX_FLAG_DIRECT);
 	token->base_token.cmd_type = pme_cmd_flow_write;
-	memset(&fd, 0, sizeof(fd));
-	token->internal_flow_ptr = pme_hw_flow_new();
-	if (!token->internal_flow_ptr)
-		return -ENOMEM;
 
 	if (flags & PME_CTX_OP_RESETRESLEN) {
 		if (ctx->hw_residue) {
@@ -596,24 +596,19 @@ int pme_ctx_ctrl_update_flow(struct pme_ctx *ctx, u32 flags,
 			flags &= ~PME_CMD_FCW_RES;
 	}
 	/* allocate residue memory if it is being added */
-	if ((flags & PME_CMD_FCW_RES) && params->ren) {
-		spin_lock_irq(&ctx->lock);
-		if (!ctx->hw_residue) {
-			ctx->hw_residue = pme_hw_residue_new();
-			if (!ctx->hw_residue) {
-				spin_unlock_irq(&ctx->lock);
-				pme_hw_flow_free(token->internal_flow_ptr);
-				return -ENOMEM;
-			}
-		}
-		spin_unlock_irq(&ctx->lock);
+	if ((flags & PME_CMD_FCW_RES) && params->ren && !ctx->hw_residue) {
+		ctx->hw_residue = pme_hw_residue_new();
+		if (!ctx->hw_residue)
+			return -ENOMEM;
 	}
 	/* enqueue the FCW command to PME */
+	memset(&fd, 0, sizeof(fd));
+	token->internal_flow_ptr = pme_hw_flow_new();
 	memcpy(token->internal_flow_ptr, params, sizeof(struct pme_flow));
 	pme_fd_cmd_fcw(&fd, flags & PME_CMD_FCW_ALL,
 			(struct pme_flow *)token->internal_flow_ptr,
 			ctx->hw_residue);
-	return do_work(ctx, flags, &fd, &token->base_token);
+	return do_work(ctx, flags, &fd, &token->base_token, NULL, 0);
 }
 EXPORT_SYMBOL(pme_ctx_ctrl_update_flow);
 
@@ -629,7 +624,7 @@ int pme_ctx_ctrl_read_flow(struct pme_ctx *ctx, u32 flags,
 	token->internal_flow_ptr = pme_hw_flow_new();
 	memset(&fd, 0, sizeof(fd));
 	pme_fd_cmd_fcr(&fd, (struct pme_flow *)token->internal_flow_ptr);
-	return do_work(ctx, flags, &fd, &token->base_token);
+	return do_work(ctx, flags, &fd, &token->base_token, NULL, 0);
 }
 EXPORT_SYMBOL(pme_ctx_ctrl_read_flow);
 
@@ -644,7 +639,7 @@ int pme_ctx_ctrl_nop(struct pme_ctx *ctx, u32 flags,
 	fd.addr_hi = 0xfeed;
 	fd.addr_lo = (u32)token;
 	pme_fd_cmd_nop(&fd);
-	return do_work(ctx, flags, &fd, &token->base_token);
+	return do_work(ctx, flags, &fd, &token->base_token, NULL, 0);
 }
 EXPORT_SYMBOL(pme_ctx_ctrl_nop);
 
@@ -654,17 +649,26 @@ int pme_ctx_scan(struct pme_ctx *ctx, u32 flags, struct qm_fd *fd, u32 args,
 	BUG_ON(ctx->flags & PME_CTX_FLAG_PMTCC);
 	token->cmd_type = pme_cmd_scan;
 	pme_fd_cmd_scan(fd, args);
-	return do_work(ctx, flags, fd, token);
+	return do_work(ctx, flags, fd, token, NULL, 0);
 }
 EXPORT_SYMBOL(pme_ctx_scan);
 
+int pme_ctx_scan_orp(struct pme_ctx *ctx, u32 flags, struct qm_fd *fd, u32 args,
+		struct pme_ctx_token *token, struct qman_fq *orp_fq, u16 seqnum)
+{
+	BUG_ON(ctx->flags & PME_CTX_FLAG_PMTCC);
+	pme_fd_cmd_scan(fd, args);
+	return do_work(ctx, flags, fd, token, orp_fq, seqnum);
+}
+EXPORT_SYMBOL(pme_ctx_scan_orp);
+
 int pme_ctx_pmtcc(struct pme_ctx *ctx, u32 flags, struct qm_fd *fd,
 		struct pme_ctx_token *token)
 {
 	BUG_ON(!(ctx->flags & PME_CTX_FLAG_PMTCC));
 	token->cmd_type = pme_cmd_pmtcc;
 	pme_fd_cmd_pmtcc(fd);
-	return do_work(ctx, flags, fd, token);
+	return do_work(ctx, flags, fd, token, NULL, 0);
 }
 EXPORT_SYMBOL(pme_ctx_pmtcc);
 
@@ -734,8 +738,6 @@ static inline void cb_helper(struct qman_portal *portal, struct pme_ctx *ctx,
 	if (error)
 		do_flags(ctx, 0, 0, PME_CTX_FLAG_DEAD, 0);
 	token = pop_matching_token(ctx, fd);
-	if (unlikely(!token))
-		goto done;
 	if (likely(token->cmd_type == pme_cmd_scan))
 		ctx->cb(ctx, fd, token);
 	else if (token->cmd_type == pme_cmd_pmtcc)
@@ -757,7 +759,6 @@ static inline void cb_helper(struct qman_portal *portal, struct pme_ctx *ctx,
 		}
 		ctrl_token->cb(ctx, fd, ctrl_token);
 	}
-done:
 	/* Consume the frame */
 	if (ctx->flags & PME_CTX_FLAG_EXCLUSIVE)
 		release_exclusive(ctx);
diff --git a/drivers/match/pme2_private.h b/drivers/match/pme2_private.h
index 4d3ae3b..069fd58 100644
--- a/drivers/match/pme2_private.h
+++ b/drivers/match/pme2_private.h
@@ -33,6 +33,7 @@
 #include "pme2_sys.h"
 #include <linux/fsl_pme.h>
 
+#undef PME2_DEBUG
 
 #ifdef PME2_DEBUG
 #define PMEPRINFO(fmt, args...) pr_info("PME2: %s: " fmt, __func__, ## args)
diff --git a/include/linux/fsl_pme.h b/include/linux/fsl_pme.h
index 6415a37..c8271df 100644
--- a/include/linux/fsl_pme.h
+++ b/include/linux/fsl_pme.h
@@ -581,6 +581,13 @@ int pme_ctx_scan(struct pme_ctx *ctx, u32 flags, struct qm_fd *fd, u32 args,
 int pme_ctx_pmtcc(struct pme_ctx *ctx, u32 flags, struct qm_fd *fd,
 		struct pme_ctx_token *token);
 
+/* This is extends pme_ctx_scan() to provide ORP support. 'orp_fq' represents
+ * the FQD that is used as the ORP and 'seqnum' is the sequence number to use
+ * for order restoration, these are usually the FQ the frame was dequeued from
+ * and the sequence number of that dequeued frame (respectively). */
+int pme_ctx_scan_orp(struct pme_ctx *ctx, u32 flags, struct qm_fd *fd, u32 args,
+	       struct pme_ctx_token *token, struct qman_fq *orp_fq, u16 seqnum);
+
 /* Precondition: must be PME_CTX_FLAG_EXCLUSIVE */
 int pme_ctx_exclusive_inc(struct pme_ctx *ctx, u32 flags);
 void pme_ctx_exclusive_dec(struct pme_ctx *ctx);
-- 
1.6.0.4

