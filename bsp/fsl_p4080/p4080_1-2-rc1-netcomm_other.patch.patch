From 7ea350a942951d593797b04c3a331159cc908736 Mon Sep 17 00:00:00 2001
From: Shlomi Gridish <gridish@freescale.com>
Date: Fri, 16 Apr 2010 11:47:51 -0400
Subject: [PATCH 011/148] p4080_1-2-rc1-netcomm_other.patch

drivers/net/dpa/NetCommSw/dflags.h
drivers/net/dpa/NetCommSw/etc/error.c
drivers/net/dpa/NetCommSw/etc/list.c
drivers/net/dpa/NetCommSw/etc/Makefile
drivers/net/dpa/NetCommSw/etc/memcpy.c
drivers/net/dpa/NetCommSw/etc/mm.c
drivers/net/dpa/NetCommSw/etc/mm.h
drivers/net/dpa/NetCommSw/etc/sprint.c
drivers/net/dpa/NetCommSw/events_mapping.h
drivers/net/dpa/NetCommSw/Kconfig
drivers/net/dpa/NetCommSw/Makefile
drivers/net/dpa/NetCommSw/ncsw_config.mk

Signed-off-by: Donio Ron <rdonio@freescale.com>
Signed-off-by: Emil Medve <Emilian.Medve@Freescale.com>
Signed-off-by: Kumar Gala <galak@kernel.crashing.org>
Signed-off-by: Shlomi Gridish <gridish@freescale.com>

[Cleanly applied Freescale SDK 2.0.3 patch:
"p4080_1-2-rc1-netcomm_other.patch", original had no
commit header text]
Integrated-by: Yuri Nedel <Yuri.Nedel@windriver.com>
---
 drivers/net/dpa/NetCommSw/Kconfig          |   20 +
 drivers/net/dpa/NetCommSw/Makefile         |   12 +
 drivers/net/dpa/NetCommSw/dflags.h         |   59 ++
 drivers/net/dpa/NetCommSw/etc/Makefile     |   11 +
 drivers/net/dpa/NetCommSw/etc/error.c      |  118 +++
 drivers/net/dpa/NetCommSw/etc/list.c       |   70 ++
 drivers/net/dpa/NetCommSw/etc/memcpy.c     |  671 +++++++++++++++++
 drivers/net/dpa/NetCommSw/etc/mm.c         | 1083 ++++++++++++++++++++++++++++
 drivers/net/dpa/NetCommSw/etc/mm.h         |  101 +++
 drivers/net/dpa/NetCommSw/etc/sprint.c     |   86 +++
 drivers/net/dpa/NetCommSw/events_mapping.h |   51 ++
 drivers/net/dpa/NetCommSw/ncsw_config.mk   |   21 +
 12 files changed, 2303 insertions(+), 0 deletions(-)
 create mode 100644 drivers/net/dpa/NetCommSw/Kconfig
 create mode 100644 drivers/net/dpa/NetCommSw/Makefile
 create mode 100644 drivers/net/dpa/NetCommSw/dflags.h
 create mode 100644 drivers/net/dpa/NetCommSw/etc/Makefile
 create mode 100644 drivers/net/dpa/NetCommSw/etc/error.c
 create mode 100644 drivers/net/dpa/NetCommSw/etc/list.c
 create mode 100644 drivers/net/dpa/NetCommSw/etc/memcpy.c
 create mode 100644 drivers/net/dpa/NetCommSw/etc/mm.c
 create mode 100644 drivers/net/dpa/NetCommSw/etc/mm.h
 create mode 100644 drivers/net/dpa/NetCommSw/etc/sprint.c
 create mode 100644 drivers/net/dpa/NetCommSw/events_mapping.h
 create mode 100644 drivers/net/dpa/NetCommSw/ncsw_config.mk

diff --git a/drivers/net/dpa/NetCommSw/Kconfig b/drivers/net/dpa/NetCommSw/Kconfig
new file mode 100644
index 0000000..70dde1a
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/Kconfig
@@ -0,0 +1,20 @@
+menu "Frame Manager support"
+
+menuconfig FSL_FMAN
+	bool "Freescale Frame Manager (datapath) support"
+	depends on PPC_E500MC
+	default y
+	---help---
+	  If unsure, say Y.
+
+if FSL_FMAN
+
+config FSL_FMAN_TEST
+	bool "Fman test module"
+	default n
+	---help---
+	  This option compiles test code for Fman.
+
+endif # FSL_FMAN
+
+endmenu
diff --git a/drivers/net/dpa/NetCommSw/Makefile b/drivers/net/dpa/NetCommSw/Makefile
new file mode 100644
index 0000000..a92ee12
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/Makefile
@@ -0,0 +1,12 @@
+#
+# Makefile for the Freescale Ethernet controllers
+#
+EXTRA_CFLAGS           += -DVERSION=\"\"
+#
+#Include netcomm SW specific definitions
+include $(srctree)/drivers/net/dpa/NetCommSw/ncsw_config.mk
+#
+obj-y		+= etc/
+obj-y		+= integrations/P4080/
+obj-y		+= Peripherals/FM/
+obj-y		+= user/env/linux/kernel/2.6/
diff --git a/drivers/net/dpa/NetCommSw/dflags.h b/drivers/net/dpa/NetCommSw/dflags.h
new file mode 100644
index 0000000..bc40bcc
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/dflags.h
@@ -0,0 +1,59 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __dflags_h
+#define __dflags_h
+
+#include "events_mapping.h"
+
+
+#define NCSW_LINUX
+
+#define P4080
+
+#define DEBUG_ERRORS        1
+
+#if defined(DEBUG)
+#define DEBUG_GLOBAL_LEVEL  REPORT_LEVEL_INFO
+
+#define DEBUG_XX_MALLOC
+#define DEBUG_MEM_LEAKS
+
+#else
+#define DEBUG_GLOBAL_LEVEL  REPORT_LEVEL_WARNING
+#endif /* (DEBUG) */
+
+#define REPORT_EVENTS       1
+#define EVENT_GLOBAL_LEVEL  REPORT_LEVEL_MINOR
+
+
+#endif /* __dflags_h */
diff --git a/drivers/net/dpa/NetCommSw/etc/Makefile b/drivers/net/dpa/NetCommSw/etc/Makefile
new file mode 100644
index 0000000..ed10553
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/etc/Makefile
@@ -0,0 +1,11 @@
+#
+# Makefile for the Freescale Ethernet controllers
+#
+EXTRA_CFLAGS           += -DVERSION=\"\"
+#
+#Include netcomm SW specific definitions
+include $(srctree)/drivers/net/dpa/NetCommSw/ncsw_config.mk
+
+obj-y		+= fsl-ncsw-etc.o
+
+fsl-ncsw-etc-objs	:= mm.o memcpy.o sprint.o list.o error.o
diff --git a/drivers/net/dpa/NetCommSw/etc/error.c b/drivers/net/dpa/NetCommSw/etc/error.c
new file mode 100644
index 0000000..20590fe
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/etc/error.c
@@ -0,0 +1,118 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/*
+
+ @File          error.c
+
+ @Description   General errors and events reporting utilities.
+*//***************************************************************************/
+
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+
+const char *dbgLevelStrings[] =
+{
+     "CRITICAL"
+    ,"MAJOR"
+    ,"MINOR"
+    ,"WARNING"
+    ,"INFO"
+    ,"TRACE"
+};
+
+const char *errTypeStrings[] =
+{
+     "Invalid State"                        /* E_INVALID_STATE */
+    ,"Invalid Operation"                    /* E_INVALID_OPERATION */
+    ,"Unsupported Operation"                /* E_NOT_SUPPORTED */
+    ,"No Device"                            /* E_NO_DEVICE */
+    ,"Invalid Handle"                       /* E_INVALID_HANDLE */
+    ,"Invalid ID"                           /* E_INVALID_ID */
+    ,"Unexpected NULL Pointer"              /* E_NULL_POINTER */
+    ,"Invalid Value"                        /* E_INVALID_VALUE */
+    ,"Invalid Selection"                    /* E_INVALID_SELECTION */
+    ,"Invalid Communication Mode"           /* E_INVALID_COMM_MODE */
+    ,"Invalid Byte Order"                   /* E_INVALID_BYTE_ORDER */
+    ,"Invalid Memory Type"                  /* E_INVALID_MEMORY_TYPE */
+    ,"Invalid Interrupt Queue"              /* E_INVALID_INTR_QUEUE */
+    ,"Invalid Priority"                     /* E_INVALID_PRIORITY */
+    ,"Invalid Clock"                        /* E_INVALID_CLOCK */
+    ,"Invalid Rate"                         /* E_INVALID_RATE */
+    ,"Invalid Address"                      /* E_INVALID_ADDRESS */
+    ,"Invalid Bus"                          /* E_INVALID_BUS */
+    ,"Conflict In Bus Selection"            /* E_BUS_CONFLICT */
+    ,"Conflict In Settings"                 /* E_CONFLICT */
+    ,"Incorrect Alignment"                  /* E_NOT_ALIGNED */
+    ,"Value Out Of Range"                   /* E_NOT_IN_RANGE */
+    ,"Invalid Frame"                        /* E_INVALID_FRAME */
+    ,"Frame Is Empty"                       /* E_EMPTY_FRAME */
+    ,"Buffer Is Empty"                      /* E_EMPTY_BUFFER */
+    ,"Memory Allocation Failed"             /* E_NO_MEMORY */
+    ,"Resource Not Found"                   /* E_NOT_FOUND */
+    ,"Resource Is Unavailable"              /* E_NOT_AVAILABLE */
+    ,"Resource Already Exists"              /* E_ALREADY_EXISTS */
+    ,"Resource Is Full"                     /* E_FULL */
+    ,"Resource Is Empty"                    /* E_EMPTY */
+    ,"Resource Is Busy"                     /* E_BUSY */
+    ,"Resource Already Free"                /* E_ALREADY_FREE */
+    ,"Read Access Failed"                   /* E_READ_FAILED */
+    ,"Write Access Failed"                  /* E_WRITE_FAILED */
+    ,"Send Operation Failed"                /* E_SEND_FAILED */
+    ,"Receive Operation Failed"             /* E_RECEIVE_FAILED */
+    ,"Operation Timed Out"                  /* E_TIMEOUT */
+};
+
+
+#if (defined(REPORT_EVENTS) && (REPORT_EVENTS > 0))
+
+const char *eventStrings[] =
+{
+     "Rx Discard"                           /* EV_RX_DISCARD */
+    ,"Rx Error"                             /* EV_RX_ERROR */
+    ,"Tx Error"                             /* EV_TX_ERROR */
+    ,"No Buffer Objects"                    /* EV_NO_BUFFERS */
+    ,"No MB-Frame Objects"                  /* EV_NO_MB_FRAMES */
+    ,"No SB-Frame Objects"                  /* EV_NO_SB_FRAMES */
+    ,"Tx Queue Is Full"                     /* EV_TX_QUEUE_FULL */
+    ,"Rx Queue Is Full"                     /* EV_RX_QUEUE_FULL */
+    ,"Interrupts Queue Is Full"             /* EV_INTR_QUEUE_FULL */
+    ,"Data Buffer Is Unavailable"           /* EV_NO_DATA_BUFFER */
+    ,"Objects Pool Is Empty"                /* EV_OBJ_POOL_EMPTY */
+    ,"Illegal bus access"                   /* EV_BUS_ERROR */
+    ,"PTP Tx Timestamps Queue Is Full"      /* EV_PTP_TXTS_QUEUE_FULL */
+    ,"PTP Rx Timestamps Queue Is Full"      /* EV_PTP_RXTS_QUEUE_FULL */
+};
+
+#endif /* (defined(REPORT_EVENTS) && (REPORT_EVENTS > 0)) */
+
+#endif /* (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0)) */
+
diff --git a/drivers/net/dpa/NetCommSw/etc/list.c b/drivers/net/dpa/NetCommSw/etc/list.c
new file mode 100644
index 0000000..e71aed9
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/etc/list.c
@@ -0,0 +1,70 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**************************************************************************//**
+
+ @File          list.c
+
+ @Description   Implementation of list.
+*//***************************************************************************/
+#include "std_ext.h"
+#include "list_ext.h"
+
+
+void LIST_Append(t_List *p_NewList, t_List *p_Head)
+{
+    t_List *p_First = LIST_FIRST(p_NewList);
+
+    if (p_First != p_NewList)
+    {
+        t_List *p_Last  = LIST_LAST(p_NewList);
+        t_List *p_Cur   = LIST_NEXT(p_Head);
+
+        LIST_PREV(p_First) = p_Head;
+        LIST_FIRST(p_Head) = p_First;
+        LIST_NEXT(p_Last)  = p_Cur;
+        LIST_LAST(p_Cur)   = p_Last;
+    }
+}
+
+
+int LIST_NumOfObjs(t_List *p_List)
+{
+    t_List *p_Tmp;
+    int    numOfObjs = 0;
+
+    if (!LIST_IsEmpty(p_List))
+        LIST_FOR_EACH(p_Tmp, p_List)
+            numOfObjs++;
+
+    return numOfObjs;
+}
diff --git a/drivers/net/dpa/NetCommSw/etc/memcpy.c b/drivers/net/dpa/NetCommSw/etc/memcpy.c
new file mode 100644
index 0000000..e43d3b9
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/etc/memcpy.c
@@ -0,0 +1,671 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+
+#include "std_ext.h"
+#include "xx_ext.h"
+#include "memcpy_ext.h"
+
+
+#ifdef CORE_8BIT_ACCESS_ERRATA
+static void MY_MY_WRITE_UINT8(uint8_t *addr, uint8_t val)
+{
+    uint32_t newAddr, newVal;
+    switch ((uint32_t)addr%4)
+    {
+    case (0):
+        newAddr = (uint32_t)addr;
+        newVal = GET_UINT32(*(uint32_t*)newAddr);
+        newVal = (newVal & 0x00ffffff) | (((uint32_t)val)<<24);
+        WRITE_UINT32(*(uint32_t*)newAddr, newVal);
+        break;
+    case (1):
+        newAddr = (((uint32_t)addr>>1)<<1);
+        newVal = GET_UINT32(*(uint32_t*)newAddr);
+        newVal = (newVal & 0xff00ffff) | (((uint32_t)val)<<16);
+        WRITE_UINT32(*(uint32_t*)newAddr, newVal);
+        break;
+    case (2):
+        newAddr = (((uint32_t)addr>>2)<<2);
+        newVal = GET_UINT32(*(uint32_t*)newAddr);
+        newVal = (newVal & 0xffff00ff) | (((uint32_t)val)<<8);
+        WRITE_UINT32(*(uint32_t*)newAddr, newVal);
+        break;
+    case (3):
+        newAddr = (((uint32_t)addr>>3)<<3);
+        newVal = GET_UINT32(*(uint32_t*)newAddr);
+        newVal = (newVal & 0xffffff00) | val;
+        WRITE_UINT32(*(uint32_t*)newAddr, newVal);
+        break;
+    }
+}
+
+static uint8_t MY_MY_GET_UINT8(uint8_t *addr)
+{
+    uint32_t newAddr, newVal=0;
+    switch ((uint32_t)addr%4)
+    {
+    case (0):
+        newAddr = (uint32_t)addr;
+        newVal = GET_UINT32(*(uint32_t*)newAddr);
+        newVal = (newVal & 0xff000000)>>24;
+        break;
+    case (1):
+        newAddr = (((uint32_t)addr>>1)<<1);
+        newVal = GET_UINT32(*(uint32_t*)newAddr);
+        newVal = (newVal & 0x00ff0000)>>16;
+        break;
+    case (2):
+        newAddr = (((uint32_t)addr>>2)<<2);
+        newVal = GET_UINT32(*(uint32_t*)newAddr);
+        newVal = (newVal & 0x0000ff00)>>8;
+        break;
+    case (3):
+        newAddr = (((uint32_t)addr>>3)<<3);
+        newVal = GET_UINT32(*(uint32_t*)newAddr);
+        newVal = (newVal & 0x000000ff);
+        break;
+    }
+
+    return (uint8_t)newVal;
+}
+
+#define MY_WRITE_UINT8(addr,val) MY_MY_WRITE_UINT8(&addr,val)
+#define MY_GET_UINT8(addr) MY_MY_GET_UINT8(&addr)
+#else
+#define MY_WRITE_UINT8 WRITE_UINT8
+#define MY_GET_UINT8   GET_UINT8
+#endif /* CORE_8BIT_ACCESS_ERRATA */
+
+
+void * MemCpy32(void* pDst,void* pSrc, uint32_t size)
+{
+    uint32_t leftAlign;
+    uint32_t rightAlign;
+    uint32_t lastWord;
+    uint32_t currWord;
+    uint32_t *p_Src32;
+    uint32_t *p_Dst32;
+    uint8_t  *p_Src8;
+    uint8_t  *p_Dst8;
+
+    p_Src8 = (uint8_t*)(pSrc);
+    p_Dst8 = (uint8_t*)(pDst);
+    /* first copy byte by byte till the source first alignment
+     * this step is necessary to ensure we do not even try to access
+     * data which is before the source buffer, hence it is not ours.
+     */
+    while(((uint32_t)(p_Src8) & 3) && size) /* (pSrc mod 4) > 0 and size > 0 */
+    {
+        *p_Dst8++ = *p_Src8++;
+        size--;
+    }
+
+    /* align destination (possibly disaligning source)*/
+    while(((uint32_t)(p_Dst8) & 3) && size) /* (pDst mod 4) > 0 and size > 0 */
+    {
+        *p_Dst8++ = *p_Src8++;
+        size--;
+    }
+
+    /* dest is aligned and source is not necessarily aligned */
+    leftAlign = (((uint32_t)(p_Src8) & 3) << 3); /* leftAlign = (pSrc mod 4)*8 */
+    rightAlign = 32 - leftAlign;
+
+
+    if (leftAlign == 0)
+    {
+        /* source is also aligned */
+        p_Src32 = (uint32_t*)(p_Src8);
+        p_Dst32 = (uint32_t*)(p_Dst8);
+        while (size >> 2) /* size >= 4 */
+        {
+            *p_Dst32++ = *p_Src32++;
+            size -= 4;
+        }
+        p_Src8 = (uint8_t*)(p_Src32);
+        p_Dst8 = (uint8_t*)(p_Dst32);
+    }
+    else
+    {
+        /* source is not aligned (destination is aligned)*/
+        p_Src32 = (uint32_t*)(p_Src8 - (leftAlign >> 3));
+        p_Dst32 = (uint32_t*)(p_Dst8);
+        lastWord = *p_Src32++;
+        while(size >> 3) /* size >= 8 */
+        {
+            currWord = *p_Src32;
+            *p_Dst32 = (lastWord << leftAlign) | (currWord >> rightAlign);
+            lastWord = currWord;
+            p_Src32++;
+            p_Dst32++;
+            size -= 4;
+        }
+        p_Dst8 = (uint8_t*)(p_Dst32);
+        p_Src8 = (uint8_t*)(p_Src32) - 4 + (leftAlign >> 3);
+    }
+
+    /* complete the left overs */
+    while (size--)
+        *p_Dst8++ = *p_Src8++;
+
+    return pDst;
+}
+
+void * IO2IOCpy32(void* pDst,void* pSrc, uint32_t size)
+{
+    uint32_t leftAlign;
+    uint32_t rightAlign;
+    uint32_t lastWord;
+    uint32_t currWord;
+    uint32_t *p_Src32;
+    uint32_t *p_Dst32;
+    uint8_t  *p_Src8;
+    uint8_t  *p_Dst8;
+
+    p_Src8 = (uint8_t*)(pSrc);
+    p_Dst8 = (uint8_t*)(pDst);
+    /* first copy byte by byte till the source first alignment
+     * this step is necessary to ensure we do not even try to access
+     * data which is before the source buffer, hence it is not ours.
+     */
+    while(((uint32_t)(p_Src8) & 3) && size) /* (pSrc mod 4) > 0 and size > 0 */
+    {
+        MY_WRITE_UINT8(*p_Dst8, MY_GET_UINT8(*p_Src8));
+        p_Dst8++;p_Src8++;
+        size--;
+    }
+
+    /* align destination (possibly disaligning source)*/
+    while(((uint32_t)(p_Dst8) & 3) && size) /* (pDst mod 4) > 0 and size > 0 */
+    {
+        MY_WRITE_UINT8(*p_Dst8, MY_GET_UINT8(*p_Src8));
+        p_Dst8++;p_Src8++;
+        size--;
+    }
+
+    /* dest is aligned and source is not necessarily aligned */
+    leftAlign = (((uint32_t)(p_Src8) & 3) << 3); /* leftAlign = (pSrc mod 4)*8 */
+    rightAlign = 32 - leftAlign;
+
+    if (leftAlign == 0)
+    {
+        /* source is also aligned */
+        p_Src32 = (uint32_t*)(p_Src8);
+        p_Dst32 = (uint32_t*)(p_Dst8);
+        while (size >> 2) /* size >= 4 */
+        {
+            WRITE_UINT32(*p_Dst32, GET_UINT32(*p_Src32));
+            p_Dst32++;p_Src32++;
+            size -= 4;
+        }
+        p_Src8 = (uint8_t*)(p_Src32);
+        p_Dst8 = (uint8_t*)(p_Dst32);
+    }
+    else
+    {
+        /* source is not aligned (destination is aligned)*/
+        p_Src32 = (uint32_t*)(p_Src8 - (leftAlign >> 3));
+        p_Dst32 = (uint32_t*)(p_Dst8);
+        lastWord = GET_UINT32(*p_Src32);
+        p_Src32++;
+        while(size >> 3) /* size >= 8 */
+        {
+            currWord = GET_UINT32(*p_Src32);
+            WRITE_UINT32(*p_Dst32, (lastWord << leftAlign) | (currWord >> rightAlign));
+            lastWord = currWord;
+            p_Src32++;p_Dst32++;
+            size -= 4;
+        }
+        p_Dst8 = (uint8_t*)(p_Dst32);
+        p_Src8 = (uint8_t*)(p_Src32) - 4 + (leftAlign >> 3);
+    }
+
+    /* complete the left overs */
+    while (size--)
+    {
+        MY_WRITE_UINT8(*p_Dst8, MY_GET_UINT8(*p_Src8));
+        p_Dst8++;p_Src8++;
+    }
+
+    return pDst;
+}
+
+void * Mem2IOCpy32(void* pDst,void* pSrc, uint32_t size)
+{
+    uint32_t leftAlign;
+    uint32_t rightAlign;
+    uint32_t lastWord;
+    uint32_t currWord;
+    uint32_t *p_Src32;
+    uint32_t *p_Dst32;
+    uint8_t  *p_Src8;
+    uint8_t  *p_Dst8;
+
+    p_Src8 = (uint8_t*)(pSrc);
+    p_Dst8 = (uint8_t*)(pDst);
+    /* first copy byte by byte till the source first alignment
+     * this step is necessary to ensure we do not even try to access
+     * data which is before the source buffer, hence it is not ours.
+     */
+    while(((uint32_t)(p_Src8) & 3) && size) /* (pSrc mod 4) > 0 and size > 0 */
+    {
+        MY_WRITE_UINT8(*p_Dst8, *p_Src8);
+        p_Dst8++;p_Src8++;
+        size--;
+    }
+
+    /* align destination (possibly disaligning source)*/
+    while(((uint32_t)(p_Dst8) & 3) && size) /* (pDst mod 4) > 0 and size > 0 */
+    {
+        MY_WRITE_UINT8(*p_Dst8, *p_Src8);
+        p_Dst8++;p_Src8++;
+        size--;
+    }
+
+    /* dest is aligned and source is not necessarily aligned */
+    leftAlign = (((uint32_t)(p_Src8) & 3) << 3); /* leftAlign = (pSrc mod 4)*8 */
+    rightAlign = 32 - leftAlign;
+
+    if (leftAlign == 0)
+    {
+        /* source is also aligned */
+        p_Src32 = (uint32_t*)(p_Src8);
+        p_Dst32 = (uint32_t*)(p_Dst8);
+        while (size >> 2) /* size >= 4 */
+        {
+            WRITE_UINT32(*p_Dst32, *p_Src32);
+            p_Dst32++;p_Src32++;
+            size -= 4;
+        }
+        p_Src8 = (uint8_t*)(p_Src32);
+        p_Dst8 = (uint8_t*)(p_Dst32);
+    }
+    else
+    {
+        /* source is not aligned (destination is aligned)*/
+        p_Src32 = (uint32_t*)(p_Src8 - (leftAlign >> 3));
+        p_Dst32 = (uint32_t*)(p_Dst8);
+        lastWord = *p_Src32++;
+        while(size >> 3) /* size >= 8 */
+        {
+            currWord = *p_Src32;
+            WRITE_UINT32(*p_Dst32, (lastWord << leftAlign) | (currWord >> rightAlign));
+            lastWord = currWord;
+            p_Src32++;p_Dst32++;
+            size -= 4;
+        }
+        p_Dst8 = (uint8_t*)(p_Dst32);
+        p_Src8 = (uint8_t*)(p_Src32) - 4 + (leftAlign >> 3);
+    }
+
+    /* complete the left overs */
+    while (size--)
+    {
+        MY_WRITE_UINT8(*p_Dst8, *p_Src8);
+        p_Dst8++;p_Src8++;
+    }
+
+    return pDst;
+}
+
+void * IO2MemCpy32(void* pDst,void* pSrc, uint32_t size)
+{
+    uint32_t leftAlign;
+    uint32_t rightAlign;
+    uint32_t lastWord;
+    uint32_t currWord;
+    uint32_t *p_Src32;
+    uint32_t *p_Dst32;
+    uint8_t  *p_Src8;
+    uint8_t  *p_Dst8;
+
+    p_Src8 = (uint8_t*)(pSrc);
+    p_Dst8 = (uint8_t*)(pDst);
+    /* first copy byte by byte till the source first alignment
+     * this step is necessary to ensure we do not even try to access
+     * data which is before the source buffer, hence it is not ours.
+     */
+    while(((uint32_t)(p_Src8) & 3) && size) /* (pSrc mod 4) > 0 and size > 0 */
+    {
+        *p_Dst8 = MY_GET_UINT8(*p_Src8);
+        p_Dst8++;p_Src8++;
+        size--;
+    }
+
+    /* align destination (possibly disaligning source)*/
+    while(((uint32_t)(p_Dst8) & 3) && size) /* (pDst mod 4) > 0 and size > 0 */
+    {
+        *p_Dst8 = MY_GET_UINT8(*p_Src8);
+        p_Dst8++;p_Src8++;
+        size--;
+    }
+
+    /* dest is aligned and source is not necessarily aligned */
+    leftAlign = (((uint32_t)(p_Src8) & 3) << 3); /* leftAlign = (pSrc mod 4)*8 */
+    rightAlign = 32 - leftAlign;
+
+    if (leftAlign == 0)
+    {
+        /* source is also aligned */
+        p_Src32 = (uint32_t*)(p_Src8);
+        p_Dst32 = (uint32_t*)(p_Dst8);
+        while (size >> 2) /* size >= 4 */
+        {
+            *p_Dst32 = GET_UINT32(*p_Src32);
+            p_Dst32++;p_Src32++;
+            size -= 4;
+        }
+        p_Src8 = (uint8_t*)(p_Src32);
+        p_Dst8 = (uint8_t*)(p_Dst32);
+    }
+    else
+    {
+        /* source is not aligned (destination is aligned)*/
+        p_Src32 = (uint32_t*)(p_Src8 - (leftAlign >> 3));
+        p_Dst32 = (uint32_t*)(p_Dst8);
+        lastWord = GET_UINT32(*p_Src32);
+        p_Src32++;
+        while(size >> 3) /* size >= 8 */
+        {
+            currWord = GET_UINT32(*p_Src32);
+            *p_Dst32 = (lastWord << leftAlign) | (currWord >> rightAlign);
+            lastWord = currWord;
+            p_Src32++;p_Dst32++;
+            size -= 4;
+        }
+        p_Dst8 = (uint8_t*)(p_Dst32);
+        p_Src8 = (uint8_t*)(p_Src32) - 4 + (leftAlign >> 3);
+    }
+
+    /* complete the left overs */
+    while (size--)
+    {
+        *p_Dst8 = MY_GET_UINT8(*p_Src8);
+        p_Dst8++;p_Src8++;
+    }
+
+    return pDst;
+}
+
+void * MemCpy64(void* pDst,void* pSrc, uint32_t size)
+{
+    uint32_t leftAlign;
+    uint32_t rightAlign;
+    uint64_t lastWord;
+    uint64_t currWord;
+    uint64_t *pSrc64;
+    uint64_t *pDst64;
+    uint8_t  *p_Src8;
+    uint8_t  *p_Dst8;
+
+    p_Src8 = (uint8_t*)(pSrc);
+    p_Dst8 = (uint8_t*)(pDst);
+    /* first copy byte by byte till the source first alignment
+     * this step is necessarily to ensure we do not even try to access
+     * data which is before the source buffer, hence it is not ours.
+     */
+    while(((uint32_t)(p_Src8) & 7) && size) /* (pSrc mod 8) > 0 and size > 0 */
+    {
+        *p_Dst8++ = *p_Src8++;
+        size--;
+    }
+
+    /* align destination (possibly disaligning source)*/
+    while(((uint32_t)(p_Dst8) & 7) && size) /* (pDst mod 8) > 0 and size > 0 */
+    {
+        *p_Dst8++ = *p_Src8++;
+        size--;
+    }
+
+    /* dest is aligned and source is not necessarily aligned */
+    leftAlign = (((uint32_t)(p_Src8) & 7) << 3); /* leftAlign = (pSrc mod 8)*8 */
+    rightAlign = 64 - leftAlign;
+
+
+    if (leftAlign == 0)
+    {
+        /* source is also aligned */
+        pSrc64 = (uint64_t*)(p_Src8);
+        pDst64 = (uint64_t*)(p_Dst8);
+        while (size >> 3) /* size >= 8 */
+        {
+            *pDst64++ = *pSrc64++;
+            size -= 8;
+        }
+        p_Src8 = (uint8_t*)(pSrc64);
+        p_Dst8 = (uint8_t*)(pDst64);
+    }
+    else
+    {
+        /* source is not aligned (destination is aligned)*/
+        pSrc64 = (uint64_t*)(p_Src8 - (leftAlign >> 3));
+        pDst64 = (uint64_t*)(p_Dst8);
+        lastWord = *pSrc64++;
+        while(size >> 4) /* size >= 16 */
+        {
+            currWord = *pSrc64;
+            *pDst64 = (lastWord << leftAlign) | (currWord >> rightAlign);
+            lastWord = currWord;
+            pSrc64++;
+            pDst64++;
+            size -= 8;
+        }
+        p_Dst8 = (uint8_t*)(pDst64);
+        p_Src8 = (uint8_t*)(pSrc64) - 8 + (leftAlign >> 3);
+    }
+
+    /* complete the left overs */
+    while (size--)
+        *p_Dst8++ = *p_Src8++;
+
+    return pDst;
+}
+
+void * MemSet32(void* pDst, uint8_t val, uint32_t size)
+{
+    uint32_t val32;
+    uint32_t *p_Dst32;
+    uint8_t  *p_Dst8;
+
+    p_Dst8 = (uint8_t*)(pDst);
+
+    /* generate four 8-bit val's in 32-bit container */
+    val32  = (uint32_t) val;
+    val32 |= (val32 <<  8);
+    val32 |= (val32 << 16);
+
+    /* align destination to 32 */
+    while(((uint32_t)(p_Dst8) & 3) && size) /* (pDst mod 4) > 0 and size > 0 */
+    {
+        *p_Dst8++ = val;
+        size--;
+    }
+
+    /* 32-bit chunks */
+    p_Dst32 = (uint32_t*)(p_Dst8);
+    while (size >> 2) /* size >= 4 */
+    {
+        *p_Dst32++ = val32;
+        size -= 4;
+    }
+
+    /* complete the leftovers */
+    p_Dst8 = (uint8_t*)(p_Dst32);
+    while (size--)
+        *p_Dst8++ = val;
+
+    return pDst;
+}
+
+void * IOMemSet32(void* pDst, uint8_t val, uint32_t size)
+{
+    uint32_t val32;
+    uint32_t *p_Dst32;
+    uint8_t  *p_Dst8;
+
+    p_Dst8 = (uint8_t*)(pDst);
+
+    /* generate four 8-bit val's in 32-bit container */
+    val32  = (uint32_t) val;
+    val32 |= (val32 <<  8);
+    val32 |= (val32 << 16);
+
+    /* align destination to 32 */
+    while(((uint32_t)(p_Dst8) & 3) && size) /* (pDst mod 4) > 0 and size > 0 */
+    {
+        MY_WRITE_UINT8(*p_Dst8, val);
+        p_Dst8++;
+        size--;
+    }
+
+    /* 32-bit chunks */
+    p_Dst32 = (uint32_t*)(p_Dst8);
+    while (size >> 2) /* size >= 4 */
+    {
+        WRITE_UINT32(*p_Dst32, val32);
+        p_Dst32++;
+        size -= 4;
+    }
+
+    /* complete the leftovers */
+    p_Dst8 = (uint8_t*)(p_Dst32);
+    while (size--)
+    {
+        MY_WRITE_UINT8(*p_Dst8, val);
+        p_Dst8++;
+    }
+
+    return pDst;
+}
+
+void * MemSet64(void* pDst, uint8_t val, uint32_t size)
+{
+    uint64_t val64;
+    uint64_t *pDst64;
+    uint8_t  *p_Dst8;
+
+    p_Dst8 = (uint8_t*)(pDst);
+
+    /* generate four 8-bit val's in 32-bit container */
+    val64  = (uint64_t) val;
+    val64 |= (val64 <<  8);
+    val64 |= (val64 << 16);
+    val64 |= (val64 << 24);
+    val64 |= (val64 << 32);
+
+    /* align destination to 64 */
+    while(((uint32_t)(p_Dst8) & 7) && size) /* (pDst mod 8) > 0 and size > 0 */
+    {
+        *p_Dst8++ = val;
+        size--;
+    }
+
+    /* 64-bit chunks */
+    pDst64 = (uint64_t*)(p_Dst8);
+    while (size >> 4) /* size >= 8 */
+    {
+        *pDst64++ = val64;
+        size -= 8;
+    }
+
+    /* complete the leftovers */
+    p_Dst8 = (uint8_t*)(pDst64);
+    while (size--)
+        *p_Dst8++ = val;
+
+    return pDst;
+}
+
+void MemDisp(uint8_t *p, int size)
+{
+    uint32_t    space = ((uint32_t)p & 0x3);
+    uint8_t     *p_Limit;
+
+    if (space)
+    {
+        p_Limit = (p - space + 4);
+
+        XX_Print("0x%08X: ", (p - space));
+
+        while (space--)
+        {
+            XX_Print("--");
+        }
+        while (size  && (p < p_Limit))
+        {
+            XX_Print("%02x", *(uint8_t*)p);
+            size--;
+            p++;
+        }
+
+        XX_Print(" ");
+        p_Limit += 12;
+
+        while ((size > 3) && (p < p_Limit))
+        {
+            XX_Print("%08x ", *(uint32_t*)p);
+            size -= 4;
+            p += 4;
+        }
+        XX_Print("\r\n");
+    }
+
+    while (size > 15)
+    {
+        XX_Print("0x%08X: %08x %08x %08x %08x\r\n",
+                 p, *(uint32_t *)p, *(uint32_t *)(p + 4),
+                 *(uint32_t *)(p + 8), *(uint32_t *)(p + 12));
+        size -= 16;
+        p += 16;
+    }
+
+    if (size)
+    {
+        XX_Print("0x%08X: ", p);
+
+        while (size > 3)
+        {
+            XX_Print("%08x ", *(uint32_t *)p);
+            size -= 4;
+            p += 4;
+        }
+        while (size)
+        {
+            XX_Print("%02x", *(uint8_t *)p);
+            size--;
+            p++;
+        }
+
+        XX_Print("\r\n");
+    }
+}
diff --git a/drivers/net/dpa/NetCommSw/etc/mm.c b/drivers/net/dpa/NetCommSw/etc/mm.c
new file mode 100644
index 0000000..086711f
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/etc/mm.c
@@ -0,0 +1,1083 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "string_ext.h"
+#include "error_ext.h"
+#include "std_ext.h"
+#include "sprint_ext.h"
+#include "part_ext.h"
+#include "xx_ext.h"
+
+#include "mm.h"
+
+
+/* Prototypes of the internal MM routines */
+static uint64_t MM_GetGreaterAlignment(t_MM *p_MM, uint64_t size, int alignment, char* name);
+
+static t_Error  MM_AddFree(t_MM *p_MM, uint64_t base, uint64_t end);
+static t_Error  MM_CutFree(t_MM *p_MM, uint64_t holdBase, uint64_t holdEnd);
+static void     MM_AddBusy(t_MM *p_MM, t_BusyBlock *p_NewBusyB);
+static t_Error  MM_CutBusy(t_MM *p_MM, uint64_t base, uint64_t end);
+
+static t_Error  MemBlock_Init(t_Handle *memBlock, uint64_t base, uint64_t size);
+static t_Error  FreeBlock_Init(t_Handle *freeBlock, uint64_t base, uint64_t size);
+static t_Error  BusyBlock_Init(t_Handle *busyBlock, uint64_t base, uint64_t size, char *name);
+
+
+/**********************************************************************
+ *                     MM API routines set                            *
+ **********************************************************************/
+
+/*****************************************************************************/
+t_Error MM_Init(t_Handle *h_MM, uint64_t base, uint64_t size)
+{
+    t_MM        *p_MM;
+    uint64_t    newBase, newSize;
+    int         i;
+
+    if (!size)
+    {
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Size (should be positive)"));
+    }
+
+    /* Initializes a new MM object */
+    p_MM = (t_MM *)XX_Malloc(sizeof(t_MM));
+    if (!p_MM)
+    {
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, NO_MSG);
+    }
+
+    /* initializes a new memory block */
+    if ( MemBlock_Init((t_Handle *)&p_MM->memBlocks, base, size) != E_OK )
+    {
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, NO_MSG);
+    }
+
+    /* A busy list is empty */
+    p_MM->busyBlocks = 0;
+
+    /*Initializes a new free block for each free list*/
+    for (i=0; i <= MM_MAX_ALIGNMENT; i++)
+    {
+        newBase = MAKE_ALIGNED( base, (0x1 << i) );
+        newSize = size - (newBase - base);
+
+        if ( FreeBlock_Init((t_Handle *)&p_MM->freeBlocks[i], newBase, newSize ) != E_OK)
+        {
+            RETURN_ERROR(MAJOR, E_NO_MEMORY, NO_MSG);
+        }
+    }
+
+    *h_MM = p_MM;
+
+    return (E_OK);
+}
+
+
+/*****************************************************************************/
+uint64_t MM_Get(t_Handle h_MM, uint64_t size, int alignment, char* name)
+{
+    t_MM        *p_MM = (t_MM *)h_MM;
+    t_FreeBlock *p_FreeB;
+    t_BusyBlock *p_NewBusyB;
+    uint64_t    holdBase, holdEnd;
+    int         i = 0, j;
+
+    SANITY_CHECK_RETURN_VALUE(p_MM, E_INVALID_HANDLE, (uint64_t)ILLEGAL_BASE);
+
+    /* checks that alignment value is greater then zero */
+    if (alignment == 0)
+    {
+        alignment = 1;
+    }
+
+    j = alignment;
+
+    /* checks if alignment is a power of two, if it correct and if the
+       required size is multiple of the given alignment. */
+    while ((j & 0x1) == 0)
+    {
+        i++;
+        j = j >> 1;
+    }
+
+    /* if the given alignment isn't power of two, returns an error */
+    if (j != 1)
+    {
+        REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("alignment (should be power of 2)"));
+        return (uint64_t)ILLEGAL_BASE;
+    }
+
+    if (i > MM_MAX_ALIGNMENT)
+    {
+        return (MM_GetGreaterAlignment(p_MM, size, alignment, name));
+    }
+
+    /* look for a block of the size greater or equal to the required size. */
+    p_FreeB = p_MM->freeBlocks[i];
+    while ( p_FreeB && (p_FreeB->end - p_FreeB->base) < size )
+        p_FreeB = p_FreeB->p_Next;
+
+    /* If such block is found */
+    if ( !p_FreeB )
+        return (uint64_t)(ILLEGAL_BASE);
+
+    holdBase = p_FreeB->base;
+    holdEnd = holdBase + size;
+
+    /* init a new busy block */
+    if ( BusyBlock_Init ( (t_Handle *)&p_NewBusyB, holdBase, size, name ) != E_OK )
+        return (uint64_t)(ILLEGAL_BASE);
+
+    /* calls Update routine to update a lists of free blocks */
+    if ( MM_CutFree ( p_MM, holdBase, holdEnd ) != E_OK )
+        return (uint64_t)(ILLEGAL_BASE);
+
+    /* insert the new busy block into the list of busy blocks */
+    MM_AddBusy ( p_MM, p_NewBusyB );
+
+    return (holdBase);
+}
+
+
+/*****************************************************************************/
+uint64_t MM_GetForce(t_Handle h_MM, uint64_t base, uint64_t size, char* name)
+{
+    t_MM        *p_MM = (t_MM *)h_MM;
+    t_FreeBlock *p_FreeB;
+    t_BusyBlock *p_NewBusyB;
+    bool        blockIsFree = FALSE;
+
+    ASSERT_COND(p_MM);
+
+    p_FreeB = p_MM->freeBlocks[0]; /* The biggest free blocks are in the
+                                      free list with alignment 1 */
+    while ( p_FreeB )
+    {
+        if ( base >= p_FreeB->base && (base+size) <= p_FreeB->end )
+        {
+            blockIsFree = TRUE;
+            break;
+        }
+        else
+            p_FreeB = p_FreeB->p_Next;
+    }
+
+    if ( !blockIsFree )
+        return (uint64_t)(ILLEGAL_BASE);
+
+    /* init a new busy block */
+    if ( BusyBlock_Init ( (t_Handle *)&p_NewBusyB, base, size, name ) != E_OK )
+        return (uint64_t)(ILLEGAL_BASE);
+
+    /* calls Update routine to update a lists of free blocks */
+    if ( MM_CutFree ( p_MM, base, base+size ) != E_OK )
+        return (uint64_t)(ILLEGAL_BASE);
+
+    /* insert the new busy block into the list of busy blocks */
+    MM_AddBusy ( p_MM, p_NewBusyB );
+    return (base);
+}
+
+
+/*****************************************************************************/
+uint64_t MM_GetForceMin(t_Handle h_MM, uint64_t size, int alignment, uint64_t min, char* name)
+{
+    t_MM        *p_MM = (t_MM *)h_MM;
+    t_FreeBlock *p_FreeB;
+    t_BusyBlock *p_NewBusyB;
+    uint64_t    holdBase, holdEnd;
+    int         i=0, j = alignment;
+
+    ASSERT_COND(p_MM);
+
+    /* checks if alignment is a power of two, if it correct and if the
+       required size is multiple of the given alignment. */
+    while ((j & 0x1) == 0)
+    {
+        i++;
+        j = j >> 1;
+    }
+
+    if ( (j != 1) || (i > MM_MAX_ALIGNMENT) )
+    {
+        return (uint64_t)(ILLEGAL_BASE);
+    }
+
+    p_FreeB = p_MM->freeBlocks[i];
+
+    /* look for the first block that contains the minimum
+       base address. If the whole required size may be fit
+       into it, use that block, otherwise look for the next
+       block of size greater or equal to the required size. */
+    while ( p_FreeB && (min >= p_FreeB->end))
+            p_FreeB = p_FreeB->p_Next;
+
+    /* If such block is found */
+    if ( !p_FreeB )
+        return (uint64_t)(ILLEGAL_BASE);
+
+    /* if this block is large enough, use this block */
+    holdBase = ( min <= p_FreeB->base ) ? p_FreeB->base : min;
+    if ((holdBase + size) <= p_FreeB->end )
+    {
+        holdEnd = holdBase + size;
+    }
+    else
+    {
+        p_FreeB = p_FreeB->p_Next;
+        while ( p_FreeB && ((p_FreeB->end - p_FreeB->base) < size) )
+            p_FreeB = p_FreeB->p_Next;
+
+        /* If such block is found */
+        if ( !p_FreeB )
+            return (uint64_t)(ILLEGAL_BASE);
+
+        holdBase = p_FreeB->base;
+        holdEnd = holdBase + size;
+    }
+
+    /* init a new busy block */
+    if ( BusyBlock_Init((t_Handle *)&p_NewBusyB, holdBase, size, name) != E_OK )
+        return (uint64_t)(ILLEGAL_BASE);
+
+    /* calls Update routine to update a lists of free blocks */
+    if ( MM_CutFree( p_MM, holdBase, holdEnd ) != E_OK )
+        return (uint64_t)(ILLEGAL_BASE);
+
+    /* insert the new busy block into the list of busy blocks */
+    MM_AddBusy( p_MM, p_NewBusyB );
+
+    return (holdBase);
+}
+
+
+/*****************************************************************************/
+uint64_t MM_Put(t_Handle h_MM, uint64_t base)
+{
+    t_MM        *p_MM = (t_MM *)h_MM;
+    t_BusyBlock *p_BusyB, *p_PrevBusyB;
+    uint64_t    size;
+
+    ASSERT_COND(p_MM);
+
+    /* Look for a busy block that have the given base value.
+     * That block will be returned back to the memory.
+     */
+    p_PrevBusyB = 0;
+    p_BusyB = p_MM->busyBlocks;
+    while ( p_BusyB && base != p_BusyB->base )
+    {
+        p_PrevBusyB = p_BusyB;
+        p_BusyB = p_BusyB->p_Next;
+    }
+
+    if ( !p_BusyB )
+        return (0);
+
+    if ( MM_AddFree( p_MM, p_BusyB->base, p_BusyB->end ) != E_OK )
+        return (0);
+
+    /* removes a busy block form the list of busy blocks */
+    if ( p_PrevBusyB )
+        p_PrevBusyB->p_Next = p_BusyB->p_Next;
+    else
+        p_MM->busyBlocks = p_BusyB->p_Next;
+
+    size = p_BusyB->end - p_BusyB->base;
+
+    XX_Free(p_BusyB);
+
+    return (size);
+}
+
+
+/*****************************************************************************/
+uint64_t MM_PutForce(t_Handle h_MM, uint64_t base, uint64_t size)
+{
+    t_MM        *p_MM = (t_MM *)h_MM;
+    uint64_t    end = base + size;
+
+    ASSERT_COND(p_MM);
+
+    if ( MM_CutBusy( p_MM, base, end ) != E_OK )
+        return (0);
+
+    if ( MM_AddFree ( p_MM, base, end ) != E_OK )
+        return (0);
+
+    return (size);
+}
+
+
+/*****************************************************************************/
+t_Error MM_Add(t_Handle h_MM, uint64_t base, uint64_t size)
+{
+    t_MM        *p_MM = (t_MM *)h_MM;
+    t_MemBlock  *p_MemB, *p_NewMemB;
+    t_Error     errCode;
+
+    ASSERT_COND(p_MM);
+
+    /* find a last block in the list of memory blocks to insert a new
+     * memory block
+     */
+    p_MemB = p_MM->memBlocks;
+    while ( p_MemB->p_Next )
+    {
+        if ( base >= p_MemB->base && base < p_MemB->end )
+        {
+            RETURN_ERROR(MAJOR, E_ALREADY_EXISTS, NO_MSG);
+        }
+        p_MemB = p_MemB->p_Next;
+    }
+    /* check for a last memory block */
+    if ( base >= p_MemB->base && base < p_MemB->end )
+    {
+        RETURN_ERROR(MAJOR, E_ALREADY_EXISTS, NO_MSG);
+    }
+
+    /* create a new memory block */
+    if ( MemBlock_Init( (t_Handle *)&p_NewMemB, base, size ) != E_OK )
+    {
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, NO_MSG);
+    }
+
+    /* append a new memory block to the end of the list of memory blocks */
+    p_MemB->p_Next = p_NewMemB;
+
+    /* add a new free block to the free lists */
+    errCode = MM_AddFree(p_MM, base, base+size);
+    if (errCode)
+    {
+        p_MemB->p_Next = 0;
+        XX_Free(p_NewMemB);
+        return ((t_Error)errCode);
+    }
+
+    return (E_OK);
+}
+
+
+/*****************************************************************************/
+void        MM_Dump(t_Handle h_MM, void *buff)
+{
+    t_MM        *p_MM = (t_MM *)h_MM;
+    t_FreeBlock *p_FreeB;
+    t_BusyBlock *p_BusyB;
+    int          i;
+
+    p_BusyB = p_MM->busyBlocks;
+    Sprint(buff, "List of busy blocks:\n");
+    while (p_BusyB)
+    {
+        Sprint(buff, "\t0x%lx: (%s: b=0x%lx, e=0x%lx)\n",
+                (uint32_t)p_BusyB, p_BusyB->name, p_BusyB->base, p_BusyB->end );
+        p_BusyB = p_BusyB->p_Next;
+    }
+
+    Sprint(buff, "\nLists of free blocks according to alignment:\n");
+    for (i=0; i <= MM_MAX_ALIGNMENT; i++)
+    {
+        Sprint(buff, "%d alignment:\n", (0x1 << i));
+        p_FreeB = p_MM->freeBlocks[i];
+        while (p_FreeB)
+        {
+            Sprint(buff, "\t0x%lx: (b=0x%lx, e=0x%lx)\n",
+                     (uint32_t)p_FreeB, p_FreeB->base, p_FreeB->end );
+            p_FreeB = p_FreeB->p_Next;
+        }
+        Sprint(buff, "\n");
+    }
+}
+
+
+/**********************************************************************
+ *                     MM internal routines set                       *
+ **********************************************************************/
+
+/****************************************************************
+ *  Routine:    MM_AddFree
+ *
+ *  Description:
+ *      Adds a new free block to the free lists. It updates each
+ *      free list to include a new free block.
+ *      Note, that all free block in each free list are ordered
+ *      by their base address.
+ *
+ *  Arguments:
+ *      p_MM  - pointer to the MM object
+ *      base  - base address of a given free block
+ *      end   - end address of a given free block
+ *
+ *  Return value:
+ *
+ *
+ ****************************************************************/
+static t_Error MM_AddFree(t_MM *p_MM, uint64_t base, uint64_t end)
+{
+    t_FreeBlock *p_PrevB, *p_CurrB, *p_NewB;
+    uint32_t    alignment;
+    uint64_t    alignBase;
+    int         i;
+
+    /* Updates free lists to include  a just released block */
+    for (i=0; i <= MM_MAX_ALIGNMENT; i++)
+    {
+        p_PrevB = p_NewB = 0;
+        p_CurrB = p_MM->freeBlocks[i];
+
+        alignment = (uint32_t)(0x1 << i);
+        alignBase = MAKE_ALIGNED(base, alignment);
+
+        /* Goes to the next free list if there is no block to free */
+        if (alignBase >= end)
+            continue;
+
+        /* Looks for a free block that should be updated */
+        while ( p_CurrB )
+        {
+            if ( alignBase <= p_CurrB->end )
+            {
+                if ( end > p_CurrB->end )
+                {
+                    t_FreeBlock *p_NextB;
+                    while ( p_CurrB->p_Next && end > p_CurrB->p_Next->end )
+                    {
+                        p_NextB = p_CurrB->p_Next;
+                        p_CurrB->p_Next = p_CurrB->p_Next->p_Next;
+                        XX_Free(p_NextB);
+                    }
+
+                    p_NextB = p_CurrB->p_Next;
+                    if ( !p_NextB || (p_NextB && end < p_NextB->base) )
+                    {
+                        p_CurrB->end = end;
+                    }
+                    else
+                    {
+                        p_CurrB->end = p_NextB->end;
+                        p_CurrB->p_Next = p_NextB->p_Next;
+                        XX_Free(p_NextB);
+                    }
+                }
+                else if ( (end < p_CurrB->base) && ((end-alignBase) >= alignment) )
+                {
+                    if ( FreeBlock_Init((t_Handle *)&p_NewB,
+                                        alignBase,
+                                        end-alignBase) != E_OK )
+                    {
+                        RETURN_ERROR(MAJOR, E_NO_MEMORY, NO_MSG);
+                    }
+                    p_NewB->p_Next = p_CurrB;
+                    if (p_PrevB)
+                        p_PrevB->p_Next = p_NewB;
+                    else
+                        p_MM->freeBlocks[i] = p_NewB;
+                    break;
+                }
+
+                if ((alignBase < p_CurrB->base) && (end >= p_CurrB->base))
+                {
+                    p_CurrB->base = alignBase;
+                }
+
+                /* if size of the free block is less then alignment
+                 * deletes that free block from the free list. */
+                if ( (p_CurrB->end - p_CurrB->base) < alignment)
+                {
+                    if ( p_PrevB )
+                        p_PrevB->p_Next = p_CurrB->p_Next;
+                    else
+                        p_MM->freeBlocks[i] = p_CurrB->p_Next;
+                    XX_Free(p_CurrB);
+                }
+                break;
+            }
+            else
+            {
+                p_PrevB = p_CurrB;
+                p_CurrB = p_CurrB->p_Next;
+            }
+        }
+
+        /* If no free block found to be updated, insert a new free block
+         * to the end of the free list.
+         */
+        if ( !p_CurrB && ((((uint64_t)(end-base)) & ((uint64_t)(alignment-1))) == 0) )
+        {
+            if ( FreeBlock_Init((t_Handle *)&p_NewB, alignBase, end-base) != E_OK )
+            {
+                RETURN_ERROR(MAJOR, E_NO_MEMORY, NO_MSG);
+            }
+            if (p_PrevB)
+                p_PrevB->p_Next = p_NewB;
+            else
+                p_MM->freeBlocks[i] = p_NewB;
+        }
+
+        /* Update boundaries of the new free block */
+        if ((alignment == 1) && !p_NewB)
+        {
+            if ( p_CurrB && base > p_CurrB->base )
+                base = p_CurrB->base;
+            if ( p_CurrB && end < p_CurrB->end )
+                end = p_CurrB->end;
+        }
+    }
+
+    return (E_OK);
+}
+
+
+/****************************************************************
+ *  Routine:      MM_CutFree
+ *
+ *  Description:
+ *      Cuts a free block from holdBase to holdEnd from the free lists.
+ *      That is, it updates all free lists of the MM object do
+ *      not include a block of memory from holdBase to holdEnd.
+ *      For each free lists it seek for a free block that holds
+ *      either holdBase or holdEnd. If such block is found it updates it.
+ *
+ *  Arguments:
+ *      p_MM            - pointer to the MM object
+ *      holdBase        - base address of the allocated block
+ *      holdEnd         - end address of the allocated block
+ *
+ *  Return value:
+ *      E_OK is returned on success,
+ *      otherwise returns an error code.
+ *
+ ****************************************************************/
+static t_Error MM_CutFree(t_MM *p_MM, uint64_t holdBase, uint64_t holdEnd)
+{
+    t_FreeBlock *p_PrevB, *p_CurrB, *p_NewB;
+    uint64_t    alignBase, base, end;
+    uint32_t    alignment;
+    int         i;
+
+    for (i=0; i <= MM_MAX_ALIGNMENT; i++)
+    {
+        p_PrevB = p_NewB = 0;
+        p_CurrB = p_MM->freeBlocks[i];
+
+        alignment = (uint32_t)(0x1 << i);
+        alignBase = MAKE_ALIGNED(holdEnd, alignment);
+
+        while ( p_CurrB )
+        {
+            base = p_CurrB->base;
+            end = p_CurrB->end;
+
+            if ( (holdBase <= base) && (holdEnd <= end) && (holdEnd > base) )
+            {
+                if ( alignBase >= end ||
+                     (alignBase < end && ((end-alignBase) < alignment)) )
+                {
+                    if (p_PrevB)
+                        p_PrevB->p_Next = p_CurrB->p_Next;
+                    else
+                        p_MM->freeBlocks[i] = p_CurrB->p_Next;
+                    XX_Free( p_CurrB );
+                }
+                else
+                {
+                    p_CurrB->base = alignBase;
+                }
+                break;
+            }
+            else if ( (holdBase > base) && (holdEnd <= end) )
+            {
+                if ( (holdBase-base) >= alignment )
+                {
+                    if ( (alignBase < end) && ((end-alignBase) >= alignment) )
+                    {
+                        if ( FreeBlock_Init( (t_Handle *)&p_NewB,
+                                             alignBase,
+                                             (end-alignBase)) != E_OK )
+                        {
+                            RETURN_ERROR(MAJOR, E_NO_MEMORY, NO_MSG);
+                        }
+                        p_NewB->p_Next = p_CurrB->p_Next;
+                        p_CurrB->p_Next = p_NewB;
+                    }
+                    p_CurrB->end = holdBase;
+                }
+                else if ( (alignBase < end) && ((end-alignBase) >= alignment) )
+                {
+                    p_CurrB->base = alignBase;
+                }
+                else
+                {
+                    if (p_PrevB)
+                        p_PrevB->p_Next = p_CurrB->p_Next;
+                    else
+                        p_MM->freeBlocks[i] = p_CurrB->p_Next;
+                    XX_Free(p_CurrB);
+                }
+                break;
+            }
+            else
+            {
+                p_PrevB = p_CurrB;
+                p_CurrB = p_CurrB->p_Next;
+            }
+        }
+    }
+
+    return (E_OK);
+}
+
+
+/****************************************************************
+ *  Routine:     MM_AddBusy
+ *
+ *  Description:
+ *      Adds a new busy block to the list of busy blocks. Note,
+ *      that all busy blocks are ordered by their base address in
+ *      the busy list.
+ *
+ *  Arguments:
+ *      MM              - handler to the MM object
+ *      p_NewBusyB      - pointer to the a busy block
+ *
+ *  Return value:
+ *      None.
+ *
+ ****************************************************************/
+static void MM_AddBusy(t_MM *p_MM, t_BusyBlock *p_NewBusyB)
+{
+    t_BusyBlock *p_CurrBusyB, *p_PrevBusyB;
+
+    /* finds a place of a new busy block in the list of busy blocks */
+    p_PrevBusyB = 0;
+    p_CurrBusyB = p_MM->busyBlocks;
+
+    while ( p_CurrBusyB && p_NewBusyB->base > p_CurrBusyB->base )
+    {
+        p_PrevBusyB = p_CurrBusyB;
+        p_CurrBusyB = p_CurrBusyB->p_Next;
+    }
+
+    /* insert the new busy block into the list of busy blocks */
+    if ( p_CurrBusyB )
+        p_NewBusyB->p_Next = p_CurrBusyB;
+    if ( p_PrevBusyB )
+        p_PrevBusyB->p_Next = p_NewBusyB;
+    else
+        p_MM->busyBlocks = p_NewBusyB;
+}
+
+
+/****************************************************************
+ *  Routine:    MM_CutBusy
+ *
+ *  Description:
+ *      Cuts a block from base to end from the list of busy blocks.
+ *      This is done by updating the list of busy blocks do not
+ *      include a given block, that block is going to be free. If a
+ *      given block is a part of some other busy block, so that
+ *      busy block is updated. If there are number of busy blocks
+ *      included in the given block, so all that blocks are removed
+ *      from the busy list and the end blocks are updated.
+ *      If the given block devides some block into two parts, a new
+ *      busy block is added to the busy list.
+ *
+ *  Arguments:
+ *      p_MM  - pointer to the MM object
+ *      base  - base address of a given busy block
+ *      end   - end address of a given busy block
+ *
+ *  Return value:
+ *      E_OK on success, E_NOMEMORY otherwise.
+ *
+ ****************************************************************/
+static t_Error MM_CutBusy(t_MM *p_MM, uint64_t base, uint64_t end)
+{
+    t_BusyBlock  *p_CurrB, *p_PrevB, *p_NewB;
+
+    p_CurrB = p_MM->busyBlocks;
+    p_PrevB = p_NewB = 0;
+
+    while ( p_CurrB )
+    {
+        if ( base < p_CurrB->end )
+        {
+            if ( end > p_CurrB->end )
+            {
+                t_BusyBlock *p_NextB;
+                while ( p_CurrB->p_Next && end >= p_CurrB->p_Next->end )
+                {
+                    p_NextB = p_CurrB->p_Next;
+                    p_CurrB->p_Next = p_CurrB->p_Next->p_Next;
+                    XX_Free(p_NextB);
+                }
+
+                p_NextB = p_CurrB->p_Next;
+                if ( p_NextB && end > p_NextB->base )
+                {
+                    p_NextB->base = end;
+                }
+            }
+
+            if ( base <= p_CurrB->base )
+            {
+                if ( end < p_CurrB->end && end > p_CurrB->base )
+                {
+                    p_CurrB->base = end;
+                }
+                else if ( end >= p_CurrB->end )
+                {
+                    if ( p_PrevB )
+                        p_PrevB->p_Next = p_CurrB->p_Next;
+                    else
+                        p_MM->busyBlocks = p_CurrB->p_Next;
+                    XX_Free(p_CurrB);
+                }
+            }
+            else
+            {
+                if ( end < p_CurrB->end && end > p_CurrB->base )
+                {
+                    if ( BusyBlock_Init((t_Handle *)&p_NewB,
+                                        end,
+                                        p_CurrB->end-end,
+                                        p_CurrB->name ) != E_OK )
+                    {
+                        RETURN_ERROR(MAJOR, E_NO_MEMORY, NO_MSG);
+                    }
+                    p_NewB->p_Next = p_CurrB->p_Next;
+                    p_CurrB->p_Next = p_NewB;
+                }
+                p_CurrB->end = base;
+            }
+            break;
+        }
+        else
+        {
+            p_PrevB = p_CurrB;
+            p_CurrB = p_CurrB->p_Next;
+        }
+    }
+
+    return (E_OK);
+}
+
+
+/****************************************************************
+ *  Routine:   MemBlock_Init
+ *
+ *  Description:
+ *      Initializes a new memory block of "size" bytes and started
+ *      from "base" address.
+ *
+ *  Arguments:
+ *      memBlock- handle to the memBlock object
+ *      base    - base address of the memory block
+ *      size    - size of the memory block
+ *
+ *  Return value:
+ *      E_OK is returned on success. E_NOMEMORY is returned
+ *      if can't allocate memory for memBlock object.
+ ****************************************************************/
+static t_Error MemBlock_Init(t_Handle *memBlock, uint64_t base, uint64_t size)
+{
+    t_MemBlock *p_MemBlock;
+
+    p_MemBlock = (t_MemBlock *)XX_Malloc(sizeof(t_MemBlock));
+    if ( !p_MemBlock )
+    {
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, NO_MSG);
+    }
+
+    p_MemBlock->base = base;
+    p_MemBlock->end = base+size;
+    p_MemBlock->p_Next = 0;
+
+    *memBlock = p_MemBlock;
+
+    return (E_OK);
+}
+
+
+/****************************************************************
+ *  Routine:   FreeBlock_Init
+ *
+ *  Description:
+ *      Initializes a new free block of of "size" bytes and
+ *      started from "base" address.
+ *
+ *  Arguments:
+ *      freeBlock - handle to the freeBlock object
+ *      base      - base address of the free block
+ *      size      - size of the free block
+ *
+ *  Return value:
+ *      E_OK is returned on success. E_NOMEMORY is returned
+ *      if can't allocate memory for a free block.
+ ****************************************************************/
+static t_Error FreeBlock_Init(t_Handle *freeBlock, uint64_t base, uint64_t size)
+{
+    t_FreeBlock *p_FreeBlock;
+
+    p_FreeBlock = (t_FreeBlock *)XX_Malloc(sizeof(t_FreeBlock));
+    if ( !p_FreeBlock )
+    {
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, NO_MSG);
+    }
+
+    p_FreeBlock->base = base;
+    p_FreeBlock->end = base + size;
+    p_FreeBlock->p_Next = 0;
+
+    *freeBlock = p_FreeBlock;
+
+    return (E_OK);
+}
+
+
+/****************************************************************
+ *  Routine:   BusyBlock_Init
+ *
+ *  Description:
+ *      Initializes a new busy block of "size" bytes and started
+ *      rom "base" address. Each busy block has a name that
+ *      specified the purpose of the memory allocation.
+ *
+ *  Arguments:
+ *      busyBlock - handle to the busyBlock object
+ *      base      - base address of the busy block
+ *      size      - size of the busy block
+ *      name      - name that specified the busy block
+ *
+ *  Return value:
+ *      E_OK is returned on success. E_NOMEMORY is returned
+ *      if can't allocate memory for busy block.
+ ****************************************************************/
+static t_Error BusyBlock_Init(t_Handle *busyBlock, uint64_t base, uint64_t size, char *name)
+{
+    t_BusyBlock *p_BusyBlock;
+    int         n, nameLen;
+
+    p_BusyBlock = (t_BusyBlock *)XX_Malloc(sizeof(t_BusyBlock));
+    if ( !p_BusyBlock )
+    {
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, NO_MSG);
+    }
+
+    p_BusyBlock->base = base;
+    p_BusyBlock->end = base + size;
+    nameLen = (int)strlen(name);
+    n = (nameLen > MM_MAX_NAME_LEN - 1) ? MM_MAX_NAME_LEN-1 : nameLen;
+    strncpy(p_BusyBlock->name, name, (uint32_t)n);
+    p_BusyBlock->name[n] = '\0';
+    p_BusyBlock->p_Next = 0;
+
+    *busyBlock = p_BusyBlock;
+
+    return (E_OK);
+}
+
+
+/****************************************************************
+ *  Routine:     MM_GetGreaterAlignment
+ *
+ *  Description:
+ *      Allocates a block of memory according to the given size
+ *      and the alignment. That routine is called from the MM_Get
+ *      routine if the required alignment is greater then MM_MAX_ALIGNMENT.
+ *      In that case, it goes over free blocks of 64 byte align list
+ *      and checks if it has the required size of bytes of the required
+ *      alignment. If no blocks found returns ILLEGAL_BASE.
+ *      After the block is found and data is allocated, it calls
+ *      the internal MM_CutFree routine to update all free lists
+ *      do not include a just allocated block. Of course, each
+ *      free list contains a free blocks with the same alignment.
+ *      It is also creates a busy block that holds
+ *      information about an allocated block.
+ *
+ *  Arguments:
+ *      MM              - handle to the MM object
+ *      size            - size of the MM
+ *      alignment       - index as a power of two defines
+ *                        a required alignment that is greater then 64.
+ *      name            - the name that specifies an allocated block.
+ *
+ *  Return value:
+ *      base address of an allocated block.
+ *      ILLEGAL_BASE if can't allocate a block
+ *
+ ****************************************************************/
+static uint64_t MM_GetGreaterAlignment(t_MM *p_MM, uint64_t size, int alignment, char* name)
+{
+    t_FreeBlock *p_FreeB;
+    t_BusyBlock *p_NewBusyB;
+    uint64_t    holdBase, holdEnd, alignBase = 0;
+
+    /* goes over free blocks of the 64 byte alignment list
+       and look for a block of the suitable size and
+       base address according to the alignment. */
+    p_FreeB = p_MM->freeBlocks[MM_MAX_ALIGNMENT];
+
+    while ( p_FreeB )
+    {
+        alignBase = MAKE_ALIGNED(p_FreeB->base, alignment);
+
+        /* the block is found if the aligned base inside the block
+         * and has the anough size. */
+        if ( alignBase >= p_FreeB->base &&
+             alignBase < p_FreeB->end &&
+             size <= (p_FreeB->end - alignBase) )
+            break;
+        else
+            p_FreeB = p_FreeB->p_Next;
+    }
+
+    /* If such block isn't found */
+    if ( !p_FreeB )
+        return (uint64_t)(ILLEGAL_BASE);
+
+    holdBase = alignBase;
+    holdEnd = alignBase + size;
+
+    /* init a new busy block */
+    if ( BusyBlock_Init ( (t_Handle *)&p_NewBusyB, holdBase, size, name ) != E_OK )
+        return (uint64_t)(ILLEGAL_BASE);
+
+    /* calls Update routine to update a lists of free blocks */
+    if ( MM_CutFree ( p_MM, holdBase, holdEnd ) != E_OK )
+        return (uint64_t)(ILLEGAL_BASE);
+
+    /* insert the new busy block into the list of busy blocks */
+    MM_AddBusy ( p_MM, p_NewBusyB );
+
+    return (holdBase);
+}
+
+
+/*****************************************************************************/
+void MM_Free(t_Handle h_MM)
+{
+    t_MM        *p_MM = (t_MM *)h_MM;
+    t_MemBlock  *p_MemBlock;
+    t_BusyBlock *p_BusyBlock;
+    t_FreeBlock *p_FreeBlock;
+    void        *p_Block;
+    int         i;
+
+    ASSERT_COND(p_MM);
+
+    /* release memory allocated for busy blocks */
+    p_BusyBlock = p_MM->busyBlocks;
+    while ( p_BusyBlock )
+    {
+        p_Block = p_BusyBlock;
+        p_BusyBlock = p_BusyBlock->p_Next;
+        XX_Free(p_Block);
+    }
+
+    /* release memory allocated for free blocks */
+    for (i=0; i <= MM_MAX_ALIGNMENT; i++)
+    {
+        p_FreeBlock = p_MM->freeBlocks[i];
+        while ( p_FreeBlock )
+        {
+            p_Block = p_FreeBlock;
+            p_FreeBlock = p_FreeBlock->p_Next;
+            XX_Free(p_Block);
+        }
+    }
+
+    /* release memory allocated for memory blocks */
+    p_MemBlock = p_MM->memBlocks;
+    while ( p_MemBlock )
+    {
+        p_Block = p_MemBlock;
+        p_MemBlock = p_MemBlock->p_Next;
+        XX_Free(p_Block);
+    }
+
+    /* release memory allocated for MM object itself */
+    XX_Free(p_MM);
+}
+
+
+/*****************************************************************************/
+uint64_t MM_GetMemBlock(t_Handle h_MM, int index)
+{
+    t_MM       *p_MM = (t_MM*)h_MM;
+    t_MemBlock *p_MemBlock;
+    int         i;
+
+    ASSERT_COND(p_MM);
+
+    p_MemBlock = p_MM->memBlocks;
+    for (i=0; i < index; i++)
+        p_MemBlock = p_MemBlock->p_Next;
+
+    if ( p_MemBlock )
+        return (p_MemBlock->base);
+    else
+        return (uint64_t)ILLEGAL_BASE;
+}
+
+
+/*****************************************************************************/
+uint64_t MM_GetBase(t_Handle h_MM)
+{
+    t_MM       *p_MM = (t_MM*)h_MM;
+    t_MemBlock *p_MemBlock;
+
+    ASSERT_COND(p_MM);
+
+    p_MemBlock = p_MM->memBlocks;
+    return  p_MemBlock->base;
+}
+
+
+/*****************************************************************************/
+bool MM_InRange(t_Handle h_MM, uint64_t addr)
+{
+    t_MM       *p_MM = (t_MM*)h_MM;
+    t_MemBlock *p_MemBlock;
+
+    ASSERT_COND(p_MM);
+
+    p_MemBlock = p_MM->memBlocks;
+
+    if ((addr >= p_MemBlock->base) && (addr < p_MemBlock->end))
+        return TRUE;
+    else
+        return FALSE;
+}
+
diff --git a/drivers/net/dpa/NetCommSw/etc/mm.h b/drivers/net/dpa/NetCommSw/etc/mm.h
new file mode 100644
index 0000000..009e16b
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/etc/mm.h
@@ -0,0 +1,101 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/****************************************************************
+ *
+ * File:  mm.h
+ *
+ *
+ * Description:
+ *  MM (Memory Management) object definitions.
+ *  It also includes definitions of the Free Block, Busy Block
+ *  and Memory Block structures used by the MM object.
+ *
+ ****************************************************************/
+
+#ifndef __MM_H
+#define __MM_H
+
+
+#include "mm_ext.h"
+
+#define __ERR_MODULE__  MODULE_MM
+
+
+#define MAKE_ALIGNED(addr, align)    \
+    (((uint64_t)(addr) + ((align) - 1)) & (~((align) - 1)))
+
+
+/* t_MemBlock data stucutre defines parameters of the Memory Block */
+typedef struct t_MemBlock
+{
+    struct t_MemBlock *p_Next;    /* Pointer to the next memory block */
+
+    uint64_t  base;             /* Base address of the memory block */
+    uint64_t  end;              /* End address of the memory block */
+} t_MemBlock;
+
+
+/* t_FreeBlock data stucutre defines parameters of the Free Block */
+typedef struct t_FreeBlock
+{
+    struct t_FreeBlock *p_Next;   /* Pointer to the next free block */
+
+    uint64_t  base;             /* Base address of the block */
+    uint64_t  end;              /* End address of the block */
+} t_FreeBlock;
+
+
+/* t_BusyBlock data stucutre defines parameters of the Busy Block  */
+typedef struct t_BusyBlock
+{
+    struct t_BusyBlock *p_Next;       /* Pointer to the next free block */
+
+    uint64_t  base;                 /* Base address of the block */
+    uint64_t  end;                  /* End address of the block */
+    char  name[MM_MAX_NAME_LEN];    /* That block of memory was allocated for
+                                       something specified by the Name */
+} t_BusyBlock;
+
+
+/* t_MM data structure defines parameters of the MM object */
+typedef struct t_MM
+{
+    t_MemBlock*  memBlocks;     /* List of memory blocks (Memory list) */
+    t_BusyBlock* busyBlocks;    /* List of busy blocks (Busy list) */
+    t_FreeBlock* freeBlocks[MM_MAX_ALIGNMENT + 1];
+                                /* Alignment lists of free blocks (Free lists) */
+} t_MM;
+
+
+#endif
+
diff --git a/drivers/net/dpa/NetCommSw/etc/sprint.c b/drivers/net/dpa/NetCommSw/etc/sprint.c
new file mode 100644
index 0000000..c28341f
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/etc/sprint.c
@@ -0,0 +1,86 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/*------------------------------------------------------*/
+/*                                                      */
+/* File: sprint.c                                       */
+/*                                                      */
+/* Description:                                         */
+/*    Debug routines (externals)                        */
+/*                                                      */
+/* Modifications:                                       */
+/* ==============                                       */
+/*                                                      */
+/*------------------------------------------------------*/
+#include "string_ext.h"
+#include "stdlib_ext.h"
+#include "ctype_ext.h"
+#include "stdarg_ext.h"
+#include "sprint_ext.h"
+#include "std_ext.h"
+#include "xx_ext.h"
+
+
+int Sprint(char * buf, const char *fmt, ...)
+{
+    va_list args;
+    int i;
+
+    va_start(args, fmt);
+    i=vsprintf(buf,fmt,args);
+    va_end(args);
+    return i;
+}
+
+
+int Snprint(char * buf, uint32_t size, const char *fmt, ...)
+{
+    va_list args;
+    int i;
+
+    va_start(args, fmt);
+    i=vsnprintf(buf,size,fmt,args);
+    va_end(args);
+    return i;
+}
+
+
+int Sscan(const char * buf, const char * fmt, ...)
+{
+    va_list args;
+    int i;
+
+    va_start(args,fmt);
+    i = vsscanf(buf,fmt,args);
+    va_end(args);
+    return i;
+}
diff --git a/drivers/net/dpa/NetCommSw/events_mapping.h b/drivers/net/dpa/NetCommSw/events_mapping.h
new file mode 100644
index 0000000..9735ee4
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/events_mapping.h
@@ -0,0 +1,51 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __EVENTS_MAPPING_H
+#define __EVENTS_MAPPING_H
+
+
+#define EV_RX_DISCARD_LEVEL         REPORT_LEVEL_MINOR
+#define EV_RX_ERROR_LEVEL           REPORT_LEVEL_MINOR
+#define EV_TX_ERROR_LEVEL           REPORT_LEVEL_MINOR
+#define EV_NO_BUFFERS_LEVEL         REPORT_LEVEL_MAJOR
+#define EV_NO_MB_FRAMES_LEVEL       REPORT_LEVEL_MAJOR
+#define EV_NO_SB_FRAMES_LEVEL       REPORT_LEVEL_MAJOR
+#define EV_TX_QUEUE_FULL_LEVEL      REPORT_LEVEL_MINOR
+#define EV_RX_QUEUE_FULL_LEVEL      REPORT_LEVEL_MAJOR
+#define EV_INTR_QUEUE_FULL_LEVEL    REPORT_LEVEL_MINOR
+#define EV_NO_DATA_BUFFER_LEVEL     REPORT_LEVEL_MAJOR
+#define EV_OBJ_POOL_EMPTY_LEVEL     REPORT_LEVEL_MAJOR
+#define EV_BUS_ERROR_LEVEL          REPORT_LEVEL_CRITICAL
+
+
+#endif /* __EVENTS_MAPPING_H */
diff --git a/drivers/net/dpa/NetCommSw/ncsw_config.mk b/drivers/net/dpa/NetCommSw/ncsw_config.mk
new file mode 100644
index 0000000..2702f1f
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/ncsw_config.mk
@@ -0,0 +1,21 @@
+#
+# Makefile config for the Freescale NetcommSW
+#
+NET_DPA     = $(srctree)/drivers/net
+DRV_DPA     = $(srctree)/drivers/net/dpa
+NCSW        = $(srctree)/drivers/net/dpa/NetCommSw
+
+EXTRA_CFLAGS +=-include $(NCSW)/dflags.h
+
+EXTRA_CFLAGS += -I$(DRV_DPA)/
+EXTRA_CFLAGS += -I$(NCSW)/inc
+EXTRA_CFLAGS += -I$(NCSW)/inc/etc
+EXTRA_CFLAGS += -I$(NCSW)/inc/Peripherals
+EXTRA_CFLAGS += -I$(NCSW)/inc/integrations
+EXTRA_CFLAGS += -I$(NCSW)/inc/integrations/P4080
+EXTRA_CFLAGS += -I$(NCSW)/user/env/linux/kernel/2.6/inc
+EXTRA_CFLAGS += -I$(NCSW)/user/env/linux/kernel/2.6/inc/system
+EXTRA_CFLAGS += -I$(NCSW)/user/env/linux/kernel/2.6/inc/wrappers/Peripherals
+EXTRA_CFLAGS += -I$(NCSW)/user/env/linux/kernel/2.6/inc/ioctl
+EXTRA_CFLAGS += -I$(NCSW)/user/env/linux/kernel/2.6/inc/ioctl/Peripherals
+EXTRA_CFLAGS += -I$(NCSW)/user/env/linux/kernel/2.6/inc/ioctl/integrations/P4080
-- 
1.6.5.2

