From 9db7a268bd516702f8ff96c8a26da1a1dbf91c6f Mon Sep 17 00:00:00 2001
From: Andy Fleming <afleming@freescale.com>
Date: Thu, 24 Sep 2009 10:07:55 +0800
Subject: [PATCH 33/52] Add PHY support for working RGMII/SGMII

[KevinHao: Original headerless patch taken from Freescale
P4080_WRlinux-rc1_20090904 tarball vendor drop.
Change 36bit dts as what the original patch do for 32bit dts.
Minor context mods in order to port 2.6.27]
Integrated-by: Kevin Hao <kexin.hao@windriver.com>
---
 arch/powerpc/boot/dts/p4080sim.dts                 |   68 +++++++---
 arch/powerpc/boot/dts/p4080sim_36b.dts             |   68 +++++++---
 .../net/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.c   |   87 +++++++++++---
 .../net/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.h   |   22 +++-
 .../NetCommSw/Peripherals/FM/MAC/dtsec_mii_acc.c   |   27 ++---
 .../inc/integrations/P4080/part_integration_ext.h  |    4 +-
 drivers/net/dpa/dpa.c                              |  134 +++++++++++++++++++-
 drivers/net/dpa/dpa.h                              |    1 +
 drivers/net/dpa/mac-api.c                          |   20 +++-
 drivers/net/dpa/mac.c                              |   30 +++--
 drivers/net/dpa/mac.h                              |    2 +
 drivers/net/fsl_pq_mdio.c                          |   17 +++
 drivers/net/phy/vitesse.c                          |   30 +++++-
 13 files changed, 413 insertions(+), 97 deletions(-)

diff --git a/arch/powerpc/boot/dts/p4080sim.dts b/arch/powerpc/boot/dts/p4080sim.dts
index 99ec432..2481d34 100644
--- a/arch/powerpc/boot/dts/p4080sim.dts
+++ b/arch/powerpc/boot/dts/p4080sim.dts
@@ -24,12 +24,14 @@
 		ethernet1 = &enet1;
 		ethernet2 = &enet2;
 		ethernet3 = &enet3;
-		ethernet4 = &enet4;
+/*		ethernet4 = &enet4;
+
 		ethernet5 = &enet5;
 		ethernet6 = &enet6;
 		ethernet7 = &enet7;
 		ethernet8 = &enet8;
 		ethernet9 = &enet9;
+*/
 		serial0 = &serial0;
 		serial1 = &serial1;
 		serial2 = &serial2;
@@ -74,6 +76,7 @@
 		fman0_rx3 = &fman0_rx3;
 		fman0_rx4 = &fman0_rx4;
 
+/*
 		fman1 = &fman1;
 		fman1_oh0 = &fman1_oh0;
 		fman1_oh1 = &fman1_oh1;
@@ -87,6 +90,7 @@
 		fman1_rx2 = &fman1_rx2;
 		fman1_rx3 = &fman1_rx3;
 		fman1_rx4 = &fman1_rx4;
+*/
 		rio0 = &rapidio0;
 		simicsfs = &simicsfs;
 	};
@@ -289,9 +293,11 @@
 			fman@0 {
 				dev-handle = <&fman0>;
 			};
+/*
 			fman@1 {
 				dev-handle = <&fman1>;
 			};
+*/
 		};
 
 		qportal1: qman-portal@4000 {
@@ -316,9 +322,11 @@
 			fman@0 {
 				dev-handle = <&fman0>;
 			};
+/*
 			fman@1 {
 				dev-handle = <&fman1>;
 			};
+*/
 		};
 
 		qportal2: qman-portal@8000 {
@@ -343,9 +351,11 @@
 			fman@0 {
 				dev-handle = <&fman0>;
 			};
+/*
 			fman@1 {
 				dev-handle = <&fman1>;
 			};
+*/
 		};
 
 		qportal3: qman-portal@c000 {
@@ -370,9 +380,11 @@
 			fman@0 {
 				dev-handle = <&fman0>;
 			};
+/*
 			fman@1 {
 				dev-handle = <&fman1>;
 			};
+*/
 		};
 
 		qportal4: qman-portal@10000 {
@@ -397,9 +409,11 @@
 			fman@0 {
 				dev-handle = <&fman0>;
 			};
+/*
 			fman@1 {
 				dev-handle = <&fman1>;
 			};
+*/
 		};
 
 		qportal5: qman-portal@14000 {
@@ -424,9 +438,11 @@
 			fman@0 {
 				dev-handle = <&fman0>;
 			};
+/*
 			fman@1 {
 				dev-handle = <&fman1>;
 			};
+*/
 		};
 
 		qportal6: qman-portal@18000 {
@@ -451,9 +467,11 @@
 			fman@0 {
 				dev-handle = <&fman0>;
 			};
+/*
 			fman@1 {
 				dev-handle = <&fman1>;
 			};
+*/
 		};
 
 		qportal7: qman-portal@1c000 {
@@ -478,9 +496,11 @@
 			fman@0 {
 				dev-handle = <&fman0>;
 			};
+/*
 			fman@1 {
 				dev-handle = <&fman1>;
 			};
+*/
 		};
 
 		qportal8: qman-portal@20000 {
@@ -504,9 +524,11 @@
 			fman@0 {
 				dev-handle = <&fman0>;
 			};
+/*
 			fman@1 {
 				dev-handle = <&fman1>;
 			};
+*/
 		};
 
 		qportal9: qman-portal@24000 {
@@ -530,9 +552,11 @@
 			fman@0 {
 				dev-handle = <&fman0>;
 			};
+/*
 			fman@1 {
 				dev-handle = <&fman1>;
 			};
+*/
 		};
 
 		qpool1: qman-pool@1 {
@@ -1222,18 +1246,27 @@
 				reg = <0xe0000 0x1000>;
 				fsl,port-handles = <&fman0_rx0 &fman0_tx0>;
 				phy-handle = <&phy0>;
-				phy-connection-type = "rgmii-id";
+				phy-connection-type = "sgmii";
 			};
 
-			mdio@e1000 {
+			mdio@e1120 {
 				#address-cells = <1>;
 				#size-cells = <0>;
 				compatible = "fsl,fman-mdio";
-				reg = <0xe1000 0x1000>;
+				reg = <0xe1120 0xee0>;
 				interrupts = <100 1>;
 
 				phy0: ethernet-phy@0 {
-					reg = <0>;
+					reg = <0x1c>;
+				};
+				phy1: ethernet-phy@1 {
+					reg = <0x1d>;
+				};
+				phy2: ethernet-phy@2 {
+					reg = <0x1e>;
+				};
+				phy3: ethernet-phy@3 {
+					reg = <0x1f>;
 				};
 			};
 
@@ -1243,7 +1276,7 @@
 				reg = <0xe2000 0x1000>;
 				fsl,port-handles = <&fman0_rx1 &fman0_tx1>;
 				phy-handle = <&phy1>;
-				phy-connection-type = "rgmii-id";
+				phy-connection-type = "sgmii";
 			};
 
 			mdio@e3000 {
@@ -1252,10 +1285,6 @@
 				compatible = "fsl,fman-mdio";
 				reg = <0xe3000 0x1000>;
 				interrupts = <100 1>;
-
-				phy1: ethernet-phy@0 {
-					reg = <0>;
-				};
 			};
 
 			enet2: ethernet@e4000 {
@@ -1264,7 +1293,7 @@
 				reg = <0xe4000 0x1000>;
 				fsl,port-handles = <&fman0_rx2 &fman0_tx2>;
 				phy-handle = <&phy2>;
-				phy-connection-type = "rgmii-id";
+				phy-connection-type = "sgmii";
 			};
 
 			mdio@e5000 {
@@ -1273,10 +1302,6 @@
 				compatible = "fsl,fman-mdio";
 				reg = <0xe5000 0x1000>;
 				interrupts = <100 1>;
-
-				phy2: ethernet-phy@0 {
-					reg = <0>;
-				};
 			};
 
 			enet3: ethernet@e6000 {
@@ -1285,7 +1310,7 @@
 				reg = <0xe6000 0x1000>;
 				fsl,port-handles = <&fman0_rx3 &fman0_tx3>;
 				phy-handle = <&phy3>;
-				phy-connection-type = "rgmii-id";
+				phy-connection-type = "sgmii";
 			};
 
 			mdio@e7000 {
@@ -1294,12 +1319,8 @@
 				compatible = "fsl,fman-mdio";
 				reg = <0xe7000 0x1000>;
 				interrupts = <100 1>;
-
-				phy3: ethernet-phy@0 {
-					reg = <0>;
-				};
 			};
-
+/*
 			enet4: ethernet@f0000 {
 				cell-index = <0>;
 				compatible = "fsl,p4080-fman-10g-mac", "fsl,fman-10g-mac";
@@ -1320,8 +1341,10 @@
 					reg = <0>;
 				};
 			};
+*/
 		};
 
+/*
 		fman1: fman@500000 {
 			#address-cells = <1>;
 			#size-cells = <1>;
@@ -1572,6 +1595,7 @@
 				};
 			};
 		};
+*/
 	};
 
 	rapidio0: rapidio@fe0c0000 {
@@ -1721,6 +1745,7 @@
 			fsl,qman-channel = <&qpool1>;
 			fsl,fman-mac = <&enet3>;
 		};
+/*
 		ethernet@4 {
 			compatible = "fsl,p4080-dpa-ethernet", "fsl,dpa-ethernet";
 			fsl,qman-channel = <&qpool1>;
@@ -1751,6 +1776,7 @@
 			fsl,qman-channel = <&qpool1>;
 			fsl,fman-mac = <&enet9>;
 		};
+*/
 	};
 
 	localbus@fe124000 {
diff --git a/arch/powerpc/boot/dts/p4080sim_36b.dts b/arch/powerpc/boot/dts/p4080sim_36b.dts
index 1e97bb7..337a982 100644
--- a/arch/powerpc/boot/dts/p4080sim_36b.dts
+++ b/arch/powerpc/boot/dts/p4080sim_36b.dts
@@ -24,12 +24,14 @@
 		ethernet1 = &enet1;
 		ethernet2 = &enet2;
 		ethernet3 = &enet3;
-		ethernet4 = &enet4;
+/*		ethernet4 = &enet4;
+
 		ethernet5 = &enet5;
 		ethernet6 = &enet6;
 		ethernet7 = &enet7;
 		ethernet8 = &enet8;
 		ethernet9 = &enet9;
+*/
 		serial0 = &serial0;
 		serial1 = &serial1;
 		serial2 = &serial2;
@@ -74,6 +76,7 @@
 		fman0_rx3 = &fman0_rx3;
 		fman0_rx4 = &fman0_rx4;
 
+/*
 		fman1 = &fman1;
 		fman1_oh0 = &fman1_oh0;
 		fman1_oh1 = &fman1_oh1;
@@ -87,6 +90,7 @@
 		fman1_rx2 = &fman1_rx2;
 		fman1_rx3 = &fman1_rx3;
 		fman1_rx4 = &fman1_rx4;
+*/
 		rio0 = &rapidio0;
 		simicsfs = &simicsfs;
 	};
@@ -288,9 +292,11 @@
 			fman@0 {
 				dev-handle = <&fman0>;
 			};
+/*
 			fman@1 {
 				dev-handle = <&fman1>;
 			};
+*/
 		};
 
 		qportal1: qman-portal@4000 {
@@ -315,9 +321,11 @@
 			fman@0 {
 				dev-handle = <&fman0>;
 			};
+/*
 			fman@1 {
 				dev-handle = <&fman1>;
 			};
+*/
 		};
 
 		qportal2: qman-portal@8000 {
@@ -342,9 +350,11 @@
 			fman@0 {
 				dev-handle = <&fman0>;
 			};
+/*
 			fman@1 {
 				dev-handle = <&fman1>;
 			};
+*/
 		};
 
 		qportal3: qman-portal@c000 {
@@ -369,9 +379,11 @@
 			fman@0 {
 				dev-handle = <&fman0>;
 			};
+/*
 			fman@1 {
 				dev-handle = <&fman1>;
 			};
+*/
 		};
 
 		qportal4: qman-portal@10000 {
@@ -396,9 +408,11 @@
 			fman@0 {
 				dev-handle = <&fman0>;
 			};
+/*
 			fman@1 {
 				dev-handle = <&fman1>;
 			};
+*/
 		};
 
 		qportal5: qman-portal@14000 {
@@ -423,9 +437,11 @@
 			fman@0 {
 				dev-handle = <&fman0>;
 			};
+/*
 			fman@1 {
 				dev-handle = <&fman1>;
 			};
+*/
 		};
 
 		qportal6: qman-portal@18000 {
@@ -450,9 +466,11 @@
 			fman@0 {
 				dev-handle = <&fman0>;
 			};
+/*
 			fman@1 {
 				dev-handle = <&fman1>;
 			};
+*/
 		};
 
 		qportal7: qman-portal@1c000 {
@@ -477,9 +495,11 @@
 			fman@0 {
 				dev-handle = <&fman0>;
 			};
+/*
 			fman@1 {
 				dev-handle = <&fman1>;
 			};
+*/
 		};
 
 		qportal8: qman-portal@20000 {
@@ -503,9 +523,11 @@
 			fman@0 {
 				dev-handle = <&fman0>;
 			};
+/*
 			fman@1 {
 				dev-handle = <&fman1>;
 			};
+*/
 		};
 
 		qportal9: qman-portal@24000 {
@@ -529,9 +551,11 @@
 			fman@0 {
 				dev-handle = <&fman0>;
 			};
+/*
 			fman@1 {
 				dev-handle = <&fman1>;
 			};
+*/
 		};
 
 		qpool1: qman-pool@1 {
@@ -1221,18 +1245,27 @@
 				reg = <0xe0000 0x1000>;
 				fsl,port-handles = <&fman0_rx0 &fman0_tx0>;
 				phy-handle = <&phy0>;
-				phy-connection-type = "rgmii-id";
+				phy-connection-type = "sgmii";
 			};
 
-			mdio@e1000 {
+			mdio@e1120 {
 				#address-cells = <1>;
 				#size-cells = <0>;
 				compatible = "fsl,fman-mdio";
-				reg = <0xe1000 0x1000>;
+				reg = <0xe1120 0xee0>;
 				interrupts = <100 1>;
 
 				phy0: ethernet-phy@0 {
-					reg = <0>;
+					reg = <0x1c>;
+				};
+				phy1: ethernet-phy@1 {
+					reg = <0x1d>;
+				};
+				phy2: ethernet-phy@2 {
+					reg = <0x1e>;
+				};
+				phy3: ethernet-phy@3 {
+					reg = <0x1f>;
 				};
 			};
 
@@ -1242,7 +1275,7 @@
 				reg = <0xe2000 0x1000>;
 				fsl,port-handles = <&fman0_rx1 &fman0_tx1>;
 				phy-handle = <&phy1>;
-				phy-connection-type = "rgmii-id";
+				phy-connection-type = "sgmii";
 			};
 
 			mdio@e3000 {
@@ -1251,10 +1284,6 @@
 				compatible = "fsl,fman-mdio";
 				reg = <0xe3000 0x1000>;
 				interrupts = <100 1>;
-
-				phy1: ethernet-phy@0 {
-					reg = <0>;
-				};
 			};
 
 			enet2: ethernet@e4000 {
@@ -1263,7 +1292,7 @@
 				reg = <0xe4000 0x1000>;
 				fsl,port-handles = <&fman0_rx2 &fman0_tx2>;
 				phy-handle = <&phy2>;
-				phy-connection-type = "rgmii-id";
+				phy-connection-type = "sgmii";
 			};
 
 			mdio@e5000 {
@@ -1272,10 +1301,6 @@
 				compatible = "fsl,fman-mdio";
 				reg = <0xe5000 0x1000>;
 				interrupts = <100 1>;
-
-				phy2: ethernet-phy@0 {
-					reg = <0>;
-				};
 			};
 
 			enet3: ethernet@e6000 {
@@ -1284,7 +1309,7 @@
 				reg = <0xe6000 0x1000>;
 				fsl,port-handles = <&fman0_rx3 &fman0_tx3>;
 				phy-handle = <&phy3>;
-				phy-connection-type = "rgmii-id";
+				phy-connection-type = "sgmii";
 			};
 
 			mdio@e7000 {
@@ -1293,12 +1318,8 @@
 				compatible = "fsl,fman-mdio";
 				reg = <0xe7000 0x1000>;
 				interrupts = <100 1>;
-
-				phy3: ethernet-phy@0 {
-					reg = <0>;
-				};
 			};
-
+/*
 			enet4: ethernet@f0000 {
 				cell-index = <0>;
 				compatible = "fsl,p4080-fman-10g-mac", "fsl,fman-10g-mac";
@@ -1319,8 +1340,10 @@
 					reg = <0>;
 				};
 			};
+*/
 		};
 
+/*
 		fman1: fman@500000 {
 			#address-cells = <1>;
 			#size-cells = <1>;
@@ -1571,6 +1594,7 @@
 				};
 			};
 		};
+*/
 	};
 
 	rapidio0: rapidio@ffe0c0000 {
@@ -1720,6 +1744,7 @@
 			fsl,qman-channel = <&qpool1>;
 			fsl,fman-mac = <&enet3>;
 		};
+/*
 		ethernet@4 {
 			compatible = "fsl,p4080-dpa-ethernet", "fsl,dpa-ethernet";
 			fsl,qman-channel = <&qpool1>;
@@ -1750,6 +1775,7 @@
 			fsl,qman-channel = <&qpool1>;
 			fsl,fman-mac = <&enet9>;
 		};
+*/
 	};
 
 	localbus@ffe124000 {
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.c b/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.c
index 641814a..fa9b320 100644
--- a/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.c
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.c
@@ -87,6 +87,11 @@ static t_Error CheckInitParameters(t_Dtsec *p_Dtsec)
     if((p_Dtsec->p_DtsecDriverParam)->collisionWindow > MAX_COLLISION_WINDOW)
         RETURN_ERROR(MAJOR, E_INVALID_STATE, ("collisionWindow can't be greater than %d ",MAX_COLLISION_WINDOW ));
 
+    /*  If Auto negotiation process is disabled, need to */
+    /*  Set up the PHY using the MII Management Interface */
+    if (p_Dtsec->p_DtsecDriverParam->tbiPhyAddr > MAX_PHYS)
+        RETURN_ERROR(MAJOR, E_NOT_IN_RANGE, ("PHY address (should be 0-%d)", MAX_PHYS));
+
     return E_OK;
 }
 
@@ -119,6 +124,7 @@ static void SetDefaultParam(t_Dtsec *p_Dtsec, t_DtsecDriverParam *p_DtsecDriverP
     p_DtsecDriverParam->debugMode            = DEFAULT_debugMode;
 
     p_DtsecDriverParam->loopback             = DEFAULT_loopback;
+    p_DtsecDriverParam->tbiPhyAddr           = DEFAULT_tbiPhyAddr;
     p_DtsecDriverParam->actOnRxPauseFrame    = DEFAULT_actOnRxPauseFrame;
     p_DtsecDriverParam->actOnTxPauseFrame    = DEFAULT_actOnTxPauseFrame;
 
@@ -272,7 +278,6 @@ static t_Error DtsecInit(t_Handle h_Dtsec)
 
 /***************ECNTRL************************/
     tmpReg32 = GET_UINT32(p_DtsecMemMap->ecntrl);
-
     if(tmpReg32 & ECNTRL_CFG_RO)
     {
         isRgmii = (( p_Dtsec->enetMode == e_ENET_MODE_RGMII_10)   ||
@@ -303,7 +308,6 @@ static t_Error DtsecInit(t_Handle h_Dtsec)
         if((is100 && !isResetCnfg100) ||
             (!is100 && isResetCnfg100))
           RETURN_ERROR(MAJOR, E_CONFLICT,(" Error. 100 speed interface is not configured properly. Check dTsec cfg switch \n"));
-
     }
     else
     {
@@ -321,13 +325,16 @@ static t_Error DtsecInit(t_Handle h_Dtsec)
             tmpReg32 |= ECNTRL_RPM;
        if((p_Dtsec->enetMode == e_ENET_MODE_RGMII_100) || (p_Dtsec->enetMode == e_ENET_MODE_SGMII_100))
             tmpReg32 |= ECNTRL_R100M;
+#ifdef FM_ENET_SGMII_1000_ERRATA
+       if(p_Dtsec->enetMode == e_ENET_MODE_SGMII_1000)
+            tmpReg32 |= ECNTRL_R100M;
+#endif /* FM_ENET_SGMII_1000_ERRATA */
     }
 
     if (p_DtsecDriverParam->autoZeroCounters)
         tmpReg32 |= ECNTRL_AUTOZ;
     if(p_DtsecDriverParam->statisticsEnable)
-        tmpReg32 |= ECNTRL_STEN ;
-
+        tmpReg32 |= ECNTRL_STEN;
     WRITE_UINT32(p_DtsecMemMap->ecntrl, tmpReg32);
 
 /***************ECNTRL************************/
@@ -380,6 +387,42 @@ static t_Error DtsecInit(t_Handle h_Dtsec)
 
     WRITE_UINT32(p_DtsecMemMap->rctrl, tmpReg32);
 
+    /* Assign a Phy Address to the TBI (TBIPA).            */
+    /* Done also in case that TBI is not selected to avoid */
+    /* conflict with the external PHY’s Physical address   */
+    WRITE_UINT32(p_DtsecMemMap->tbipa, p_DtsecDriverParam->tbiPhyAddr);
+
+    /* Reset the management interface */
+    WRITE_UINT32(p_DtsecMemMap->miimcfg, MIIMCFG_RESET_MGMT);
+
+    /* Setup the MII Mgmt clock speed */
+    WRITE_UINT32(p_DtsecMemMap->miimcfg, MIIMCFG_MGMT_CLOCK_SELECT);
+
+    if(p_Dtsec->enetMode == e_ENET_MODE_SGMII_1000)
+    {
+        uint16_t            tmpReg16;
+
+        /* Configure the TBI PHY Control Register */
+        tmpReg16 = PHY_TBICON_SPEED2 | PHY_TBICON_SRESET;
+
+        DTSEC_MII_WritePhyReg(p_Dtsec, p_DtsecDriverParam->tbiPhyAddr, 17, tmpReg16);
+
+        tmpReg16 = PHY_TBICON_SPEED2;
+
+        DTSEC_MII_WritePhyReg(p_Dtsec, p_DtsecDriverParam->tbiPhyAddr, 17, tmpReg16);
+                        
+        if(!p_DtsecDriverParam->halfDuplex)
+            tmpReg16 |= PHY_CR_FULLDUPLEX | 0x8000 | PHY_CR_ANE;
+
+        DTSEC_MII_WritePhyReg(p_Dtsec, p_DtsecDriverParam->tbiPhyAddr, 0, tmpReg16);
+        
+        tmpReg16 = 0x01a0;
+        DTSEC_MII_WritePhyReg(p_Dtsec, p_DtsecDriverParam->tbiPhyAddr, 4, tmpReg16);
+                        
+        tmpReg16 = 0x1340;
+        DTSEC_MII_WritePhyReg(p_Dtsec, p_DtsecDriverParam->tbiPhyAddr, 0, tmpReg16);                
+    }
+
 /***************RCTRL************************/
 /***************IMASK************************/
     WRITE_UINT32(p_DtsecMemMap->imask, p_DtsecDriverParam->imask);
@@ -408,13 +451,15 @@ static t_Error DtsecInit(t_Handle h_Dtsec)
 /***************MACCFG1***********************/
 /***************MACCFG2***********************/
     tmpReg32 = 0;
-
     if((p_Dtsec->enetMode == e_ENET_MODE_RGMII_10) ||
         (p_Dtsec->enetMode == e_ENET_MODE_RGMII_100)||
         (p_Dtsec->enetMode == e_ENET_MODE_SGMII_10) ||
         (p_Dtsec->enetMode == e_ENET_MODE_SGMII_100))
             tmpReg32 |= MACCFG2_NIBBLE_MODE;
-
+#ifdef FM_ENET_SGMII_1000_ERRATA
+    else if(p_Dtsec->enetMode == e_ENET_MODE_SGMII_1000)
+            tmpReg32 |= MACCFG2_NIBBLE_MODE;
+#endif /* FM_ENET_SGMII_1000_ERRATA */
     else if((p_Dtsec->enetMode == e_ENET_MODE_RGMII_1000) ||
         (p_Dtsec->enetMode == e_ENET_MODE_SGMII_1000)||
         (p_Dtsec->enetMode == e_ENET_MODE_GMII_1000))
@@ -436,8 +481,8 @@ static t_Error DtsecInit(t_Handle h_Dtsec)
         tmpReg32 |= MACCFG2_CRC_EN ;
     if(!p_DtsecDriverParam->halfDuplex)
         tmpReg32 |= MACCFG2_FULL_DUPLEX;
-
     WRITE_UINT32(p_DtsecMemMap->maccfg2, tmpReg32);
+
 /***************MACCFG2***********************/
 /***************IPGIFG************************/
 
@@ -1132,11 +1177,13 @@ static t_Error DtsecSetPromiscuous(t_Handle h_Dtsec, bool newVal)
 static t_Error DtsecAdjustLink(t_Handle h_Dtsec, e_EnetSpeed speed, bool fullDuplex)
 {
     t_Dtsec         *p_Dtsec = (t_Dtsec *)h_Dtsec;
-    t_DtsecMemMap   *p_DtsecMemMap = p_Dtsec->p_MemMap;
+    t_DtsecMemMap   *p_DtsecMemMap;
     uint32_t        tmpReg32;
 
     SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_Dtsec->p_DtsecDriverParam, E_INVALID_HANDLE);
+    p_DtsecMemMap = p_Dtsec->p_MemMap;
+    SANITY_CHECK_RETURN_ERROR(p_DtsecMemMap, E_INVALID_HANDLE);
 
     if (!fullDuplex &&
         ((speed >= e_ENET_SPEED_1000) ||
@@ -1144,16 +1191,16 @@ static t_Error DtsecAdjustLink(t_Handle h_Dtsec, e_EnetSpeed speed, bool fullDup
         RETURN_ERROR(MAJOR, E_CONFLICT, ("Ethernet interface does not support Half Duplex mode"));
 
     p_Dtsec->enetMode = MAKE_ENET_MODE(ENET_INTERFACE_FROM_MODE(p_Dtsec->enetMode), speed);
-    p_Dtsec->p_DtsecDriverParam->halfDuplex = !fullDuplex;
+    p_Dtsec->halfDuplex = !fullDuplex;
 
     tmpReg32 = GET_UINT32(p_DtsecMemMap->maccfg2);
-    if(p_Dtsec->p_DtsecDriverParam->halfDuplex)
+    if(p_Dtsec->halfDuplex)
         tmpReg32 &= ~MACCFG2_FULL_DUPLEX;
     else
         tmpReg32 |= MACCFG2_FULL_DUPLEX;
-    WRITE_UINT32(p_DtsecMemMap->maccfg2, tmpReg32);
 
-    tmpReg32 = GET_UINT32(p_DtsecMemMap->ecntrl);
+	tmpReg32 &= ~(MACCFG2_NIBBLE_MODE | MACCFG2_BYTE_MODE);
+
     if((p_Dtsec->enetMode == e_ENET_MODE_RGMII_10) ||
         (p_Dtsec->enetMode == e_ENET_MODE_RGMII_100)||
         (p_Dtsec->enetMode == e_ENET_MODE_SGMII_10) ||
@@ -1164,7 +1211,17 @@ static t_Error DtsecAdjustLink(t_Handle h_Dtsec, e_EnetSpeed speed, bool fullDup
         (p_Dtsec->enetMode == e_ENET_MODE_SGMII_1000)||
         (p_Dtsec->enetMode == e_ENET_MODE_GMII_1000))
             tmpReg32 |= MACCFG2_BYTE_MODE;
-    WRITE_UINT32(p_DtsecMemMap->ecntrl, tmpReg32);
+    WRITE_UINT32(p_DtsecMemMap->maccfg2, tmpReg32);
+
+    tmpReg32 = GET_UINT32(p_DtsecMemMap->ecntrl);
+    if(!(tmpReg32 & ECNTRL_CFG_RO))
+    {
+        if((p_Dtsec->enetMode == e_ENET_MODE_RGMII_100) || (p_Dtsec->enetMode == e_ENET_MODE_SGMII_100))
+            tmpReg32 |= ECNTRL_R100M;
+        else
+            tmpReg32 &= ~ECNTRL_R100M;
+        WRITE_UINT32(p_DtsecMemMap->ecntrl, tmpReg32);
+    }
 
     return E_OK;
 }
@@ -1302,8 +1359,8 @@ static void InitFmMacControllerDriver(t_FmMacControllerDriver *p_FmMacController
     p_FmMacControllerDriver->f_FM_MAC_GetId                     = DtsecGetId;
     p_FmMacControllerDriver->f_FM_MAC_GetVersion                = DtsecGetVersion;
 
-    p_FmMacControllerDriver->f_FM_MAC_MII_WritePhyReg           = MII_WritePhyReg;
-    p_FmMacControllerDriver->f_FM_MAC_MII_ReadPhyReg            = MII_ReadPhyReg;
+    p_FmMacControllerDriver->f_FM_MAC_MII_WritePhyReg           = DTSEC_MII_WritePhyReg;
+    p_FmMacControllerDriver->f_FM_MAC_MII_ReadPhyReg            = DTSEC_MII_ReadPhyReg;
 
 #if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
     p_FmMacControllerDriver->f_FM_MAC_DumpRegs                  = DtsecDumpRegs;
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.h b/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.h
index cb2e2a1..01c6415 100644
--- a/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.h
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.h
@@ -74,7 +74,7 @@ typedef  uint32_t t_ErrorDisable;
 #define HASH_TABLE_SIZE             256 /* Hash table size (= 32 bits * 8 regs) */
 
 
-#define DTSEC_TO_MII_OFFSET         0x1000  /* number of pattern match registers (entries) */
+#define DTSEC_TO_MII_OFFSET         0x1120  /* number of pattern match registers (entries) */
 
 #define DEFAULT_cam                 0
 
@@ -132,6 +132,7 @@ typedef  uint32_t t_ErrorDisable;
 #define DEFAULT_fifoTxThr           0x10
 #define DEFAULT_fifoTxWatermarkH    0x7e
 #define DEFAULT_fifoRxWatermarkL    0x08
+#define DEFAULT_tbiPhyAddr          5
 
 #define DEFAULT_imask               ((uint32_t)(IMASK_BREN | IMASK_RXCEN | IMASK_MSROEN | IMASK_GTSCEN | \
                                                 IMASK_BTEN | IMASK_TXCEN | IMASK_TXEEN |  IMASK_ABRTEN | \
@@ -139,6 +140,7 @@ typedef  uint32_t t_ErrorDisable;
                                                 IMASK_MAGEN | IMASK_MMRDEN | IMASK_MMWREN |IMASK_GRSCEN| \
                                                 IMASK_TDPEEN |IMASK_RDPEEN)
 
+#define MAX_PHYS                    31 /* maximum number of phys */
 
 #define DTSEC_ID1_ID                0xffff0000
 #define DTSEC_ID1_REV_MJ            0x0000FF00
@@ -265,6 +267,15 @@ typedef  uint32_t t_ErrorDisable;
 #define     MASK12BIT   0x00000FFF
 #define     MASK8BIT    0x000000FF
 
+/* PHY Control Register */
+#define PHY_CR_LOOPBACK     0x4000
+#define PHY_CR_SPEED0       0x2000
+#define PHY_CR_ANE          0x1000
+#define PHY_CR_FULLDUPLEX   0x0100
+#define PHY_CR_SPEED1       0x0040
+#define PHY_TBICON_SPEED2   0x0020
+#define PHY_TBICON_SRESET   0x8000
+
 
 #ifdef __MWERKS__
 #pragma pack(push,1)
@@ -286,7 +297,7 @@ typedef _Packed struct
     volatile uint32_t edis;                 /* 0x010 Error disabled register */
     volatile uint32_t ecntrl;               /* 0x014 E control register */
     volatile uint32_t ptv;                  /* 0x018 Pause time value register */
-    volatile uint32_t DTSEC_RESERVED1;      /* 0x01C TBIPA—TBI PHY address register */
+    volatile uint32_t tbipa;                /* 0x01C TBI PHY address register */
     volatile uint32_t tmr_ctrl;             /* 0x020 Time-stamp Control register */
     volatile uint32_t tmr_pevent;           /* 0x024 Time-stamp event register */
     volatile uint32_t tmr_pemask;           /* 0x028 Timer event mask register */
@@ -308,7 +319,7 @@ typedef _Packed struct
     volatile uint32_t ipgifg;               /* 0x108 IPG/IFG */
     volatile uint32_t hafdup;               /* 0x10C Half-duplex */
     volatile uint32_t maxfrm;               /* 0x110 Maximum frame */
-    volatile uint32_t  DTSEC_RESERVED7[3];  /* 0x114–0x11C register */
+    volatile uint32_t DTSEC_RESERVED7[3];   /* 0x114–0x11C register */
     volatile uint32_t miimcfg;              /* 0x120 MII Mgmt:configuration */
     volatile uint32_t miimcom;              /* 0x124 MII Mgmt:command */
     volatile uint32_t miimadd;              /* 0x128 MII Mgmt:address */
@@ -413,6 +424,7 @@ typedef struct {
     bool        halfDuplex;
     uint16_t    pauseTime;
     uint16_t    pauseExtended;
+    uint8_t     tbiPhyAddr;         /**< TBI Physical address  (1-31)     [DEFAULT_tbiPhyAddr]*/
 
     bool        autoZeroCounters;
     bool        statisticsEnable;
@@ -489,8 +501,8 @@ typedef struct {
     t_DtsecDriverParam          *p_DtsecDriverParam;
 } t_Dtsec;
 
-t_Error MII_WritePhyReg(t_Handle h_Dtsec, uint8_t phyAddr, uint8_t reg, uint16_t data);
-t_Error MII_ReadPhyReg(t_Handle  h_Dtsec, uint8_t phyAddr, uint8_t reg, uint16_t *p_Data);
+t_Error DTSEC_MII_WritePhyReg(t_Handle h_Dtsec, uint8_t phyAddr, uint8_t reg, uint16_t data);
+t_Error DTSEC_MII_ReadPhyReg(t_Handle  h_Dtsec, uint8_t phyAddr, uint8_t reg, uint16_t *p_Data);
 
 
 #endif /* __DTSEC_H */
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/dtsec_mii_acc.c b/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/dtsec_mii_acc.c
index 98a0ba6..64518be 100644
--- a/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/dtsec_mii_acc.c
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/dtsec_mii_acc.c
@@ -42,12 +42,11 @@
 #include "dtsec.h"
 
 
-
 /*****************************************************************************/
-t_Error MII_WritePhyReg(t_Handle h_Dtsec,
-                        uint8_t     phyAddr,
-                        uint8_t     reg,
-                        uint16_t    data)
+t_Error DTSEC_MII_WritePhyReg(t_Handle    h_Dtsec,
+                              uint8_t     phyAddr,
+                              uint8_t     reg,
+                              uint16_t    data)
 {
     t_Dtsec             *p_Dtsec = (t_Dtsec *)h_Dtsec;
     t_MiiAccessMemMap   *p_MiiAccess;
@@ -78,12 +77,11 @@ t_Error MII_WritePhyReg(t_Handle h_Dtsec,
     return E_OK;
 }
 
-
 /*****************************************************************************/
-t_Error MII_ReadPhyReg(t_Handle h_Dtsec,
-                   uint8_t  phyAddr,
-                   uint8_t  reg,
-                   uint16_t *p_Data)
+t_Error DTSEC_MII_ReadPhyReg(t_Handle h_Dtsec,
+                             uint8_t  phyAddr,
+                             uint8_t  reg,
+                             uint16_t *p_Data)
 {
     t_Dtsec             *p_Dtsec = (t_Dtsec *)h_Dtsec;
     t_MiiAccessMemMap   *p_MiiAccess;
@@ -114,14 +112,7 @@ t_Error MII_ReadPhyReg(t_Handle h_Dtsec,
     tmpReg = GET_UINT32(p_MiiAccess->miimcom);
 
     if (*p_Data == 0xffff)
-    {
-        REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("Read wrong data: phyAddr"));
-/*
-        DBG(INFO, ("Read wrong data: phyAddr %d, reg %d, base %08x",
-            phyAddr, reg, (long)p_MiiAccess));
-*/
-    return E_INVALID_VALUE;
-    }
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Read wrong data: phyAddr"));
 
     return E_OK;
 }
diff --git a/drivers/net/dpa/NetCommSw/inc/integrations/P4080/part_integration_ext.h b/drivers/net/dpa/NetCommSw/inc/integrations/P4080/part_integration_ext.h
index 273b46e..dd0d556 100644
--- a/drivers/net/dpa/NetCommSw/inc/integrations/P4080/part_integration_ext.h
+++ b/drivers/net/dpa/NetCommSw/inc/integrations/P4080/part_integration_ext.h
@@ -179,7 +179,7 @@ typedef enum e_TransSrc
 typedef enum e_P4080DeviceName
 {
     e_P4080_REV_INVALID   = 0x00000000,   /**< Invalid revision      */
-    e_P4080E_REV_1_0      = 0x807D0010    /**< P4080E with security, revision 1.0 */
+    e_P4080E_REV_1_0      = 0x80230010    /**< P4080E with security, revision 1.0 */
 } e_P4080DeviceName;
 
 
@@ -299,8 +299,10 @@ uint32_t P4080_GetCcbFactor(t_Handle h_P4080);
 #define FM_PCD_KG_NUM_OF_SCHEMES    32                  /**< Total number of KG schemes */
 #define FM_PCD_MAX_NUM_OF_CLS_PLANS 256                 /**< Number of classification plan entries. */
 
+/* FM erratas */
 #define FM_OP_PARTITION_ERRATA
 #define CORE_8BIT_ACCESS_ERRATA
+#define FM_ENET_SGMII_1000_ERRATA
 
 
 #endif /* __PART_INTEGRATION_EXT_H */
diff --git a/drivers/net/dpa/dpa.c b/drivers/net/dpa/dpa.c
index 21a2933..1ad9cce 100644
--- a/drivers/net/dpa/dpa.c
+++ b/drivers/net/dpa/dpa.c
@@ -1237,6 +1237,58 @@ static const struct qman_fq _egress_fqs __devinitconst = {
 	.cb = {egress_dqrr, egress_ern, egress_dc_ern, egress_fqs}
 };
 
+/* Called every time the controller might need to be made
+ * aware of new link state.  The PHY code conveys this
+ * information through variables in the phydev structure, and this
+ * function converts those variables into the appropriate
+ * register values, and can bring down the device if needed.
+ */
+static void adjust_link(struct net_device *net_dev)
+{
+	const struct dpa_priv_s	*priv;
+	struct phy_device *phydev;
+	int			 _errno = 0;
+//	unsigned long flags;
+
+	priv = (typeof(priv))netdev_priv(net_dev);
+	phydev = priv->phydev;
+
+//	spin_lock_irqsave(&priv->lock, flags);
+
+	if (phydev->link)
+		_errno = priv->mac_dev->adjust_link(priv->mac_dev, phydev->speed, phydev->duplex);
+
+	if (unlikely(_errno < 0))
+		cpu_netdev_err(net_dev, "%s:%hu:%s(): mac_dev->adjust_link() = %d\n",
+			       __file__, __LINE__, __func__, _errno);
+//	spin_unlock_irqrestore(&priv->lock, flags);
+}
+
+/* Initializes driver's PHY state, and attaches to the PHY.
+ * Returns 0 on success.
+ */
+static int init_phy(struct net_device *net_dev)
+{
+	struct dpa_priv_s	*priv;
+	struct phy_device *phydev;
+
+	priv = (typeof(priv))netdev_priv(net_dev);
+
+	phydev = phy_connect(net_dev, priv->mac_dev->phy_id, &adjust_link, 0, priv->mac_dev->phy_if);
+	if (IS_ERR(phydev)) {
+		printk(KERN_ERR "%s: Could not attach to PHY\n", net_dev->name);
+		return PTR_ERR(phydev);
+	}
+
+	/* Remove any features not supported by the controller */
+	phydev->supported &= priv->mac_dev->if_support;
+	phydev->advertising = phydev->supported;
+
+	priv->phydev = phydev;
+
+	return 0;
+}
+
 static struct net_device_stats * __cold dpa_get_stats(struct net_device *net_dev)
 {
 	cpu_netdev_dbg(net_dev, "-> %s:%s()\n", __file__, __func__);
@@ -1407,6 +1459,73 @@ static void __hot dpa_rx(struct work_struct *fd_work)
 		}
 
 		skb->protocol = eth_type_trans(skb, net_dev);
+#if defined(CONFIG_FSL_FMAN_TEST) || defined(CONFIG_FSL_FMAN_TEST_LOOP)
+{
+    struct iphdr    *iph = (struct iphdr *)(skb->data);
+    uint32_t        net;
+    uint32_t        saddr = iph->saddr;
+    uint32_t        daddr = iph->daddr;
+
+    /* If it is ARP packet ... */
+    if (*(uint32_t*)skb->data == 0x00010800)
+    {
+        saddr = *((uint32_t*)(skb->data+14));
+        daddr = *((uint32_t*)(skb->data+24));
+    }
+
+    cpu_dev_dbg (net_dev->dev.parent,
+                 "Src  IP before header-manipulation: %d.%d.%d.%d\n",
+                 (int)((saddr & 0xff000000) >> 24),
+                 (int)((saddr & 0x00ff0000) >> 16),
+                 (int)((saddr & 0x0000ff00) >> 8),
+                 (int)((saddr & 0x000000ff) >> 0));
+    cpu_dev_dbg (net_dev->dev.parent,
+                 "Dest IP before header-manipulation: %d.%d.%d.%d\n",
+                 (int)((daddr & 0xff000000) >> 24),
+                 (int)((daddr & 0x00ff0000) >> 16),
+                 (int)((daddr & 0x0000ff00) >> 8),
+                 (int)((daddr & 0x000000ff) >> 0));
+
+    /* We allow only up to 10 eth ports */
+#if defined(CONFIG_FSL_FMAN_TEST)
+    net   = ((daddr & 0x000000ff) % 10);
+    saddr = (uint32_t)((saddr & ~0x0000ff00) | (net << 8));
+    daddr = (uint32_t)((daddr & ~0x0000ff00) | (net << 8));
+#else /* loopback */
+    net   = saddr;
+    saddr = daddr;
+    daddr = net;
+#endif /* defined(CONFIG_FSL_FMAN_TEST) */
+
+    /* If not ARP ... */
+    if (*(uint32_t*)skb->data != 0x00010800)
+    {
+        iph->check = 0;
+
+        iph->saddr = saddr;
+        iph->daddr = daddr;
+        iph->check = ip_fast_csum((unsigned char *)iph, iph->ihl);
+    }
+    else /* The packet is ARP */
+    {
+        *(uint32_t*)(skb->data+14) = saddr;
+        *(uint32_t*)(skb->data+24) = daddr;
+    }
+
+    cpu_dev_dbg (net_dev->dev.parent,
+                 "Src  IP after  header-manipulation: %d.%d.%d.%d\n",
+                 (int)((saddr & 0xff000000) >> 24),
+                 (int)((saddr & 0x00ff0000) >> 16),
+                 (int)((saddr & 0x0000ff00) >> 8),
+                 (int)((saddr & 0x000000ff) >> 0));
+    cpu_dev_dbg (net_dev->dev.parent,
+                 "Dest IP after  header-manipulation: %d.%d.%d.%d\n",
+                 (int)((daddr & 0xff000000) >> 24),
+                 (int)((daddr & 0x00ff0000) >> 16),
+                 (int)((daddr & 0x0000ff00) >> 8),
+                 (int)((daddr & 0x000000ff) >> 0));
+}
+#endif /* defined(CONFIG_FSL_FMAN_TEST) */
 
 		_errno = netif_rx_ni(skb);
 		if (unlikely(_errno != NET_RX_SUCCESS)) {
@@ -1547,7 +1666,7 @@ _return:
 
 static int __cold dpa_start(struct net_device *net_dev)
 {
-	int			 _errno, i, j;
+	int			 _errno, i=0, j;
 	const struct dpa_priv_s	*priv;
 
 	priv = (typeof(priv))netdev_priv(net_dev);
@@ -1556,7 +1675,15 @@ static int __cold dpa_start(struct net_device *net_dev)
 		cpu_netdev_dbg(net_dev, "-> %s:%s()\n", __file__, __func__);
 
 	if (priv->mac_dev) {
-		for (i = 0; i < ARRAY_SIZE(priv->mac_dev->port_dev); i++)
+		_errno = init_phy(net_dev);
+		if(_errno) {
+			if (netif_msg_ifup(priv))
+				cpu_netdev_err(net_dev, "%s:%hu:%s(): init_phy() = %d\n",
+					       __file__, __LINE__, __func__, _errno);
+			goto _return_port_dev_stop;
+		}
+
+		for (; i < ARRAY_SIZE(priv->mac_dev->port_dev); i++)
 			fm_port_enable(priv->mac_dev->port_dev[i]);
 
 		_errno = priv->mac_dev->start(priv->mac_dev);
@@ -1566,6 +1693,7 @@ static int __cold dpa_start(struct net_device *net_dev)
 					       __file__, __LINE__, __func__, _errno);
 			goto _return_port_dev_stop;
 		}
+		phy_start(priv->phydev);
 	}
 
 	netif_tx_start_all_queues(net_dev);
@@ -1597,6 +1725,8 @@ static int __cold dpa_stop(struct net_device *net_dev)
 
 	_errno = 0;
 	if (priv->mac_dev) {
+		phy_stop(priv->phydev);
+
 		__errno = priv->mac_dev->stop(priv->mac_dev);
 		if (unlikely(__errno < 0)) {
 			if (netif_msg_ifdown(priv))
diff --git a/drivers/net/dpa/dpa.h b/drivers/net/dpa/dpa.h
index ae4ab95..07c00de 100644
--- a/drivers/net/dpa/dpa.h
+++ b/drivers/net/dpa/dpa.h
@@ -69,6 +69,7 @@ struct dpa_priv_s {
 #endif /* CONFIG_FSL_FMAN_TEST */
 
 	struct mac_device	*mac_dev;
+	struct phy_device	*phydev;
 
 	struct work_struct	 fd_work;
 	struct fd_list_head	*fd_list;
diff --git a/drivers/net/dpa/mac-api.c b/drivers/net/dpa/mac-api.c
index 3868dfa..c1bdf28 100644
--- a/drivers/net/dpa/mac-api.c
+++ b/drivers/net/dpa/mac-api.c
@@ -111,13 +111,13 @@ static int __devinit __cold init(struct mac_device *mac_dev)
 
 	priv = (typeof(priv))macdev_priv(mac_dev);
 
-	param.baseAddr =  (uint64_t)((size_t)(mac_dev->vaddr));
+	param.baseAddr =  devm_ioremap(mac_dev->dev, mac_dev->res->start, 0x2000);
 	param.enetMode	= macdev2enetinterface(mac_dev);
 	memcpy(&param.addr, mac_dev->addr, min(sizeof(param.addr), sizeof(mac_dev->addr)));
 	param.f_Exceptions	= mac_exception;
 	param.h_App		= mac_dev;
 	param.macId		= mac_dev->cell_index;
-    param.h_Fm = (t_Handle)mac_dev->fm;
+	param.h_Fm = (t_Handle)mac_dev->fm;
 
 	priv->mac = FM_MAC_Config(&param);
 	if (unlikely(priv->mac == NULL)) {
@@ -226,6 +226,20 @@ static int __cold change_promisc(struct mac_device *mac_dev)
 	return _errno;
 }
 
+static int __cold adjust_link(struct mac_device *mac_dev, uint16_t speed, bool full_duplex)
+{
+	int	 _errno;
+	t_Error	 err;
+
+	err = FM_MAC_AdjustLink(((struct mac_priv_s *)macdev_priv(mac_dev))->mac, speed, full_duplex);
+	_errno = -GET_ERROR_TYPE(err);
+	if (unlikely(_errno < 0))
+		cpu_dev_err(mac_dev->dev, "%s:%hu:%s(): FM_MAC_AdjustLink() = 0x%08x\n",
+			    __file__, __LINE__, __func__, err);
+
+	return _errno;
+}
+
 static int __cold uninit(struct mac_device *mac_dev)
 {
 	int			 _errno, __errno;
@@ -258,6 +272,7 @@ static void __devinit __cold setup_dtsec(struct mac_device *mac_dev)
 	mac_dev->start		= start;
 	mac_dev->stop		= stop;
 	mac_dev->change_promisc	= change_promisc;
+	mac_dev->adjust_link	= adjust_link;
 	mac_dev->uninit		= uninit;
 }
 
@@ -267,6 +282,7 @@ static void __devinit __cold setup_xgmac(struct mac_device *mac_dev)
 	mac_dev->start		= start;
 	mac_dev->stop		= stop;
 	mac_dev->change_promisc	= change_promisc;
+	mac_dev->adjust_link	= adjust_link;
 	mac_dev->uninit		= uninit;
 }
 
diff --git a/drivers/net/dpa/mac.c b/drivers/net/dpa/mac.c
index 6986c4d..1dd40d4 100644
--- a/drivers/net/dpa/mac.c
+++ b/drivers/net/dpa/mac.c
@@ -33,14 +33,25 @@
 #include <linux/module.h>
 #include <linux/of_platform.h>
 #include <linux/device.h>
+#include <linux/phy.h>
 
 #include "dpa-common.h"
 
 #include "lnxwrp_fm_ext.h"
 
+#include "fsl_pq_mdio.h"
 #include "mac.h"
 
 #define PHY_INTERFACE_MODE_XGMII    (PHY_INTERFACE_MODE_RTBI+1)
+#define DTSEC_SUPPORTED \
+	(SUPPORTED_10baseT_Half \
+	| SUPPORTED_10baseT_Full \
+	| SUPPORTED_100baseT_Half \
+	| SUPPORTED_100baseT_Full \
+	| SUPPORTED_1000baseT_Half \
+	| SUPPORTED_1000baseT_Full \
+	| SUPPORTED_Autoneg \
+	| SUPPORTED_MII)
 
 static const char phy_str[][11] __devinitconst =
 {
@@ -130,6 +141,7 @@ static int __devinit __cold mac_probe(struct of_device *_of_dev, const struct of
 	const char		*char_prop;
 	const phandle		*phandle_prop;
 	const uint32_t		*uint32_prop;
+	char bus_name[MII_BUS_ID_SIZE];
 
 	dev = &_of_dev->dev;
 
@@ -277,6 +289,9 @@ static int __devinit __cold mac_probe(struct of_device *_of_dev, const struct of
 	mac_dev->half_duplex	= false;
 	mac_dev->speed		= phy2speed[mac_dev->phy_if];
 	mac_dev->max_speed	= mac_dev->speed;
+	mac_dev->if_support = DTSEC_SUPPORTED;
+	if (strstr(char_prop, "sgmii") && (mac_dev->max_speed == 1000))
+		mac_dev->if_support &= ~SUPPORTED_1000baseT_Half;
 
 	/* Get the rest of the PHY information */
 	phandle_prop = (typeof(phandle_prop))of_get_property(mac_node, "phy-handle", &lenp);
@@ -318,18 +333,11 @@ static int __devinit __cold mac_probe(struct of_device *_of_dev, const struct of
 	of_node_put(dev_node);
 	dev_node = tmp_node;
 
-	/* Get the MDIO bus address */
-	_errno = of_address_to_resource(dev_node, 0, &res);
-	if (unlikely(_errno < 0)) {
-		cpu_dev_err(dev, "%s:%hu:%s(): of_address_to_resource(%s) = %d\n",
-			    __file__, __LINE__, __func__, dev_node->full_name, _errno);
-		goto _return_of_node_put;
-	}
-	of_node_put(dev_node);
-
 	/* Build the PHY id/address */
-	_errno = snprintf(mac_dev->phy_id, sizeof(mac_dev->phy_id), "%llx:%02x",
-			  res.start, *uint32_prop);
+	fsl_pq_mdio_bus_name(bus_name, dev_node);
+	of_node_put(dev_node);
+	_errno = snprintf(mac_dev->phy_id, sizeof(mac_dev->phy_id), "%s:%02x",
+				bus_name, *uint32_prop);
 	if (unlikely(_errno < 0 || _errno >= sizeof(mac_dev->phy_id))) {
 		cpu_dev_err(dev, "%s:%hu:%s(): snprintf() = %d\n",
 			    __file__, __LINE__, __func__, _errno);
diff --git a/drivers/net/dpa/mac.h b/drivers/net/dpa/mac.h
index c95cb18..4fb2619 100644
--- a/drivers/net/dpa/mac.h
+++ b/drivers/net/dpa/mac.h
@@ -53,6 +53,7 @@ struct mac_device {
 	struct fm_port	*port_dev[2];
 
 	phy_interface_t		 phy_if;
+	u32					 if_support;
 	bool			 link;
 	bool			 half_duplex;
 	uint16_t		 speed;
@@ -65,6 +66,7 @@ struct mac_device {
 	int (*start)(struct mac_device *mac_dev);
 	int (*stop)(struct mac_device *mac_dev);
 	int (*change_promisc)(struct mac_device *mac_dev);
+	int (*adjust_link)(struct mac_device *mac_dev, uint16_t speed, bool full_duplex);
 	int (*uninit)(struct mac_device *mac_dev);
 };
 
diff --git a/drivers/net/fsl_pq_mdio.c b/drivers/net/fsl_pq_mdio.c
index 7751f53..af114fb 100644
--- a/drivers/net/fsl_pq_mdio.c
+++ b/drivers/net/fsl_pq_mdio.c
@@ -342,6 +342,13 @@ static int fsl_pq_mdio_probe(struct of_device *ofdev,
 		err = -ENODEV;
 		goto err_free_irqs;
 #endif
+	} else if (of_device_is_compatible(np, "fsl,fman-mdio")) {
+#ifdef CONFIG_FSL_FMAN
+		tbiaddr = 5;
+#else
+		err = -ENODEV;
+		goto err_free_irqs;
+#endif
 	} else {
 		err = -ENODEV;
 		goto err_free_irqs;
@@ -360,7 +367,9 @@ static int fsl_pq_mdio_probe(struct of_device *ofdev,
 	}
 
 	if (tbiaddr == -1) {
+#ifndef CONFIG_FSL_FMAN
 		out_be32(tbipa, 0);
+#endif
 
 		tbiaddr = fsl_pq_mdio_find_free(new_bus);
 	}
@@ -375,7 +384,9 @@ static int fsl_pq_mdio_probe(struct of_device *ofdev,
 		goto err_free_irqs;
 	}
 
+#ifndef CONFIG_FSL_FMAN
 	out_be32(tbipa, tbiaddr);
+#endif
 
 	/*
 	 * The TBIPHY-only buses will find PHYs at every address,
@@ -384,6 +395,9 @@ static int fsl_pq_mdio_probe(struct of_device *ofdev,
 	if (!of_device_is_compatible(np, "fsl,gianfar-mdio"))
 		new_bus->phy_mask = ~(1 << tbiaddr);
 
+	if (of_device_is_compatible(np, "fsl,fman-mdio"))
+		new_bus->phy_mask = 0;
+
 	err = mdiobus_register(new_bus);
 
 	if (err) {
@@ -439,6 +453,9 @@ static struct of_device_id fsl_pq_mdio_match[] = {
 	{
 		.compatible = "fsl,gianfar-mdio",
 	},
+	{
+		.compatible = "fsl,fman-mdio",
+	},
 	{},
 };
 
diff --git a/drivers/net/phy/vitesse.c b/drivers/net/phy/vitesse.c
index 8874497..9f63dd9 100644
--- a/drivers/net/phy/vitesse.c
+++ b/drivers/net/phy/vitesse.c
@@ -133,9 +133,37 @@ static struct phy_driver vsc8244_driver = {
 	.driver 	= { .owner = THIS_MODULE,},
 };
 
+/* Vitesse 823x */
+static struct phy_driver vsc8234_driver = {
+	.phy_id		= 0x000fc620,
+	.name		= "Vitesse VSC8234",
+	.phy_id_mask	= 0x000ffff0,
+	.features	= PHY_GBIT_FEATURES,
+	.flags		= PHY_HAS_INTERRUPT,
+	.config_init	= &vsc824x_config_init,
+	.config_aneg	= &genphy_config_aneg,
+	.read_status	= &genphy_read_status,
+	.ack_interrupt	= &vsc824x_ack_interrupt,
+	.config_intr	= &vsc824x_config_intr,
+	.driver 	= { .owner = THIS_MODULE,},
+};
+
+
 static int __init vsc8244_init(void)
 {
-	return phy_driver_register(&vsc8244_driver);
+	int err;
+
+	err = phy_driver_register(&vsc8244_driver);
+	if (err < 0)
+		return err;
+
+	err = phy_driver_register(&vsc8234_driver);
+	if (err < 0) {
+		phy_driver_unregister(&vsc8244_driver);
+		return err;
+	}
+
+	return err;
 }
 
 static void __exit vsc8244_exit(void)
-- 
1.6.3.3

