From fdeb9994d8c2c3ba6e3ad13357dca301d485f3ab Mon Sep 17 00:00:00 2001
From: Jeffrey Ladouceur <Jeffrey.Ladouceur@freescale.com>
Date: Thu, 17 Sep 2009 20:47:39 -0400
Subject: [PATCH] pme2: Change to use DEVICE_ATTR sysfs

* Change from DRIVER_ATTR to DEVICE_ATTR. Split out sysfs code into
  separate file.
* Added stats_ctrl directory for threshold settings.
* moved bsc_[0..63] sysfs entries into bsc/[0..63] subdirectory.

Signed-off-by: Jeffrey Ladouceur <Jeffrey.Ladouceur@freescale.com>
Signed-off-by: Geoff Thorpe <Geoff.Thorpe@freescale.com>
[Kevin: Original patch taken from Freescale p4080 SDK 2.0 ISO image.
Apply cleanly to kernel 2.6.27]
Integrated-by: Kevin Hao <kexin.hao@windriver.com>
---
 drivers/match/Makefile       |    2 +-
 drivers/match/pme2_ctrl.c    |  570 +++++++++---------------------------------
 drivers/match/pme2_private.h |    1 +
 drivers/match/pme2_sys.h     |    6 +
 drivers/match/pme2_sysfs.c   |  530 +++++++++++++++++++++++++++++++++++++++
 include/linux/fsl_pme.h      |    8 +-
 6 files changed, 661 insertions(+), 456 deletions(-)
 create mode 100644 drivers/match/pme2_sysfs.c

diff --git a/drivers/match/Makefile b/drivers/match/Makefile
index 0a97f89..56aec16 100644
--- a/drivers/match/Makefile
+++ b/drivers/match/Makefile
@@ -1,4 +1,4 @@
-obj-$(CONFIG_FSL_PME2_CTRL)	+= pme2_ctrl.o
+obj-$(CONFIG_FSL_PME2_CTRL)	+= pme2_ctrl.o pme2_sysfs.o
 obj-$(CONFIG_FSL_PME2)		+= pme2.o
 pme2-y				:= pme2_low.o
 pme2-$(CONFIG_FSL_PME2_HIGH)	+= pme2_high.o
diff --git a/drivers/match/pme2_ctrl.c b/drivers/match/pme2_ctrl.c
index 4c80df8..23075ec 100644
--- a/drivers/match/pme2_ctrl.c
+++ b/drivers/match/pme2_ctrl.c
@@ -33,6 +33,11 @@
 #include "pme2_private.h"
 #include "pme2_regs.h"
 
+/* Driver Name is used in naming the sysfs directory
+ * /sys/bus/of_platform/drivers/DRV_NAME
+ */
+#define DRV_NAME	"fsl-pme"
+
 #define DEFAULT_PDSR_SZ (CONFIG_FSL_PME2_PDSRSIZE << 7)
 #define DEFAULT_SRE_SZ  (CONFIG_FSL_PME2_SRESIZE << 5)
 #define PDSR_TBL_ALIGN  (1 << 7)
@@ -199,446 +204,23 @@ static inline u32 __pme_in(struct pme *p, u32 offset)
 #define PME_FACONF_ENABLE   0x00000002
 #define PME_FACONF_RESET    0x00000001
 
-static inline struct pme *pme_create(void *regs)
-{
-	struct pme *res = (struct pme *)regs;
-	pme_out(res, FACONF, 0);
-	pme_out(res, EFQC, PME_EFQC(0, 0));
-	pme_out(res, FACONF, PME_FACONF_ENABLE);
-	/* TODO: these coherency settings for PMFA, DXE, and SRE force all
-	 * transactions to snoop, as the kernel does not yet support flushing in
-	 * dma_map_***() APIs (ie. h/w can not treat otherwise coherent memory
-	 * in a non-coherent manner, temporarily or otherwise). When the kernel
-	 * supports this, we should tune these settings back to;
-	 *     FAMCR = 0x00010001
-	 *      DMCR = 0x00000000
-	 *      SMCR = 0x00000000
-	 */
-	pme_out(res, FAMCR, 0x01010101);
-	pme_out(res, DMCR, 0x00000001);
-	pme_out(res, SMCR, 0x00000211);
-	return res;
-}
-
 /* pme stats accumulator work */
-static int pme_stat_get(enum pme_attr *stat, u64 *value, int reset);
 static void accumulator_update(struct work_struct *work);
-static void accumulator_update_interval(u32 interval);
+void accumulator_update_interval(u32 interval);
 static DECLARE_DELAYED_WORK(accumulator_work, accumulator_update);
 u32 pme_stat_interval = CONFIG_FSL_PME2_STAT_ACCUMULATOR_UPDATE_INTERVAL;
-#define MAX_ACCUMULATOR_INTERVAL 10000
 #define PME_SBE_ERR 0x01000000
 #define PME_DBE_ERR 0x00080000
 #define PME_PME_ERR 0x00000100
 #define PME_ALL_ERR (PME_SBE_ERR | PME_DBE_ERR | PME_PME_ERR)
 
-static ssize_t pme_generic_store(const char *buf, size_t count,
-				enum pme_attr attr)
-{
-	unsigned long val;
-	size_t ret;
-	if (strict_strtoul(buf, 0, &val)) {
-		pr_err("pme: invalid input %s\n",buf);
-		return -EINVAL;
-	}
-	ret = pme_attr_set(attr, val);
-	if (ret) {
-		pr_err("pme: attr_set err attr=%u, val=%lu\n", attr, val);
-		return ret;
-	}
-	return count;
-}
-
-static ssize_t pme_generic_show(char *buf, enum pme_attr attr, const char *fmt)
-{
-	u32 data;
-	int ret;
-
-	ret =  pme_attr_get(attr, &data);
-	if (!ret)
-		return snprintf(buf, PAGE_SIZE, fmt, data);
-	else
-		return ret;
-}
-
-static ssize_t pme_generic_stat_show(char *buf, enum pme_attr attr)
-{
-	u64 data = 0;
-	int ret = 0;
-
-	ret = pme_stat_get(&attr, &data, 0);
-	if (!ret)
-		return snprintf(buf, PAGE_SIZE, "%llu\n", data);
-	else
-		return ret;
-}
-
-static ssize_t pme_generic_stat_store(const char *buf, size_t count,
-				enum pme_attr attr)
-{
-	unsigned long val;
-	u64 data = 0;
-	size_t ret = 0;
-	if (strict_strtoul(buf, 0, &val)) {
-		pr_err("pme: invalid input %s\n", buf);
-		return -EINVAL;
-	}
-	if (val) {
-		pr_err("pme: invalid input %s\n", buf);
-		return -EINVAL;
-	}
-	ret = pme_stat_get(&attr, &data, 1);
-	return count;
-}
-
-#define PME_GENERIC_ATTR(pme_attr, perm, showhex) \
-static ssize_t pme_store_##pme_attr(struct device_driver *pme, const char *buf,\
-					size_t count) \
-{ \
-	return pme_generic_store(buf, count, pme_attr_##pme_attr);\
-} \
-static ssize_t pme_show_##pme_attr(struct device_driver *pme, char *buf) \
-{ \
-	return pme_generic_show(buf, pme_attr_##pme_attr, showhex);\
-} \
-static DRIVER_ATTR( pme_attr, perm, pme_show_##pme_attr, pme_store_##pme_attr);
-
-#define PME_GENERIC_BSC_ATTR(bsc_id, perm, showhex) \
-static ssize_t pme_store_pme_attr_bsc_##bsc_id(struct device_driver *pme,\
-					const char *buf, size_t count) \
-{ \
-	return pme_generic_store(buf, count, pme_attr_bsc(bsc_id));\
-} \
-static ssize_t pme_show_pme_attr_bsc_##bsc_id(struct device_driver *pme,\
-						char *buf) \
-{ \
-	return pme_generic_show(buf, pme_attr_bsc(bsc_id), showhex);\
-} \
-static DRIVER_ATTR(bsc_##bsc_id, perm, pme_show_pme_attr_bsc_##bsc_id, \
-			pme_store_pme_attr_bsc_##bsc_id);
-
-
-#define PME_GENERIC_STAT_ATTR(pme_attr, perm) \
-static ssize_t pme_store_##pme_attr(struct device_driver *pme, const char *buf,\
-					size_t count) \
-{ \
-	return pme_generic_stat_store(buf, count, pme_attr_##pme_attr);\
-} \
-static ssize_t pme_show_##pme_attr(struct device_driver *pme, char *buf) \
-{ \
-	return pme_generic_stat_show(buf, pme_attr_##pme_attr);\
-} \
-static DRIVER_ATTR(pme_attr, perm, pme_show_##pme_attr, pme_store_##pme_attr);
-
-static ssize_t pme_store_update_interval(struct device_driver *pme,
-		const char *buf, size_t count)
-{
-	unsigned long val;
-
-	if (!pme2_have_control()) {
-		PMEPRERR("not on ctrl-plane\n");
-		return -ENODEV;
-	}
-	if (strict_strtoul(buf, 0, &val)) {
-		pr_err("pme: invalid input %s\n", buf);
-		return -EINVAL;
-	}
-	if (val > MAX_ACCUMULATOR_INTERVAL) {
-		pr_err("pme: invalid input %s\n", buf);
-		return -ERANGE;
-	}
-
-	accumulator_update_interval(val);
-	return count;
-}
-static ssize_t pme_show_update_interval(struct device_driver *pme, char *buf)
-{
-	if (!pme2_have_control())
-		return -ENODEV;
-	return snprintf(buf, PAGE_SIZE, "%u\n", pme_stat_interval);
-}
-static DRIVER_ATTR(update_interval, (S_IRUSR | S_IWUSR),
-		pme_show_update_interval, pme_store_update_interval);
-
-#define FMT_0HEX "0x%08x\n"
-#define FMT_HEX  "0x%x\n"
-#define FMT_DEC  "%u\n"
-#define PRIV_RO  S_IRUSR
-#define PRIV_RW  (S_IRUSR | S_IWUSR)
-
-/* Register Interfaces */
-/* read-write; */
-PME_GENERIC_ATTR(efqc_int, PRIV_RW, FMT_DEC);
-PME_GENERIC_ATTR(sw_db, PRIV_RW, FMT_DEC);
-PME_GENERIC_ATTR(dmcr, PRIV_RW, FMT_0HEX);
-PME_GENERIC_ATTR(smcr, PRIV_RW, FMT_0HEX);
-PME_GENERIC_ATTR(famcr, PRIV_RW, FMT_0HEX);
-PME_GENERIC_ATTR(kvlts, PRIV_RW, FMT_DEC);
-PME_GENERIC_ATTR(max_chain_length, PRIV_RW, FMT_DEC);
-PME_GENERIC_ATTR(pattern_range_counter_idx, PRIV_RW, FMT_0HEX);
-PME_GENERIC_ATTR(pattern_range_counter_mask, PRIV_RW, FMT_0HEX);
-PME_GENERIC_ATTR(max_allowed_test_line_per_pattern, PRIV_RW, FMT_DEC);
-PME_GENERIC_ATTR(max_pattern_matches_per_sui, PRIV_RW, FMT_DEC);
-PME_GENERIC_ATTR(max_pattern_evaluations_per_sui, PRIV_RW, FMT_DEC);
-PME_GENERIC_ATTR(report_length_limit, PRIV_RW, FMT_DEC);
-PME_GENERIC_ATTR(end_of_simple_sui_report, PRIV_RW, FMT_DEC);
-PME_GENERIC_ATTR(aim, PRIV_RW, FMT_DEC);
-PME_GENERIC_ATTR(end_of_sui_reaction_ptr, PRIV_RW, FMT_DEC);
-PME_GENERIC_ATTR(sre_pscl, PRIV_RW, FMT_DEC);
-PME_GENERIC_ATTR(sre_max_block_num, PRIV_RW, FMT_DEC);
-PME_GENERIC_ATTR(sre_max_instruction_limit, PRIV_RW, FMT_DEC);
-PME_GENERIC_BSC_ATTR(0, PRIV_RW, FMT_DEC);
-PME_GENERIC_BSC_ATTR(1, PRIV_RW, FMT_DEC);
-PME_GENERIC_BSC_ATTR(2, PRIV_RW, FMT_DEC);
-PME_GENERIC_BSC_ATTR(3, PRIV_RW, FMT_DEC);
-PME_GENERIC_BSC_ATTR(4, PRIV_RW, FMT_DEC);
-PME_GENERIC_BSC_ATTR(5, PRIV_RW, FMT_DEC);
-PME_GENERIC_BSC_ATTR(6, PRIV_RW, FMT_DEC);
-PME_GENERIC_BSC_ATTR(7, PRIV_RW, FMT_DEC);
-PME_GENERIC_BSC_ATTR(8, PRIV_RW, FMT_DEC);
-PME_GENERIC_BSC_ATTR(9, PRIV_RW, FMT_DEC);
-PME_GENERIC_BSC_ATTR(10, PRIV_RW, FMT_DEC);
-PME_GENERIC_BSC_ATTR(11, PRIV_RW, FMT_DEC);
-PME_GENERIC_BSC_ATTR(12, PRIV_RW, FMT_DEC);
-PME_GENERIC_BSC_ATTR(13, PRIV_RW, FMT_DEC);
-PME_GENERIC_BSC_ATTR(14, PRIV_RW, FMT_DEC);
-PME_GENERIC_BSC_ATTR(15, PRIV_RW, FMT_DEC);
-PME_GENERIC_BSC_ATTR(16, PRIV_RW, FMT_DEC);
-PME_GENERIC_BSC_ATTR(17, PRIV_RW, FMT_DEC);
-PME_GENERIC_BSC_ATTR(18, PRIV_RW, FMT_DEC);
-PME_GENERIC_BSC_ATTR(19, PRIV_RW, FMT_DEC);
-PME_GENERIC_BSC_ATTR(20, PRIV_RW, FMT_DEC);
-PME_GENERIC_BSC_ATTR(21, PRIV_RW, FMT_DEC);
-PME_GENERIC_BSC_ATTR(22, PRIV_RW, FMT_DEC);
-PME_GENERIC_BSC_ATTR(23, PRIV_RW, FMT_DEC);
-PME_GENERIC_BSC_ATTR(24, PRIV_RW, FMT_DEC);
-PME_GENERIC_BSC_ATTR(25, PRIV_RW, FMT_DEC);
-PME_GENERIC_BSC_ATTR(26, PRIV_RW, FMT_DEC);
-PME_GENERIC_BSC_ATTR(27, PRIV_RW, FMT_DEC);
-PME_GENERIC_BSC_ATTR(28, PRIV_RW, FMT_DEC);
-PME_GENERIC_BSC_ATTR(29, PRIV_RW, FMT_DEC);
-PME_GENERIC_BSC_ATTR(30, PRIV_RW, FMT_DEC);
-PME_GENERIC_BSC_ATTR(31, PRIV_RW, FMT_DEC);
-PME_GENERIC_BSC_ATTR(32, PRIV_RW, FMT_DEC);
-PME_GENERIC_BSC_ATTR(33, PRIV_RW, FMT_DEC);
-PME_GENERIC_BSC_ATTR(34, PRIV_RW, FMT_DEC);
-PME_GENERIC_BSC_ATTR(35, PRIV_RW, FMT_DEC);
-PME_GENERIC_BSC_ATTR(36, PRIV_RW, FMT_DEC);
-PME_GENERIC_BSC_ATTR(37, PRIV_RW, FMT_DEC);
-PME_GENERIC_BSC_ATTR(38, PRIV_RW, FMT_DEC);
-PME_GENERIC_BSC_ATTR(39, PRIV_RW, FMT_DEC);
-PME_GENERIC_BSC_ATTR(40, PRIV_RW, FMT_DEC);
-PME_GENERIC_BSC_ATTR(41, PRIV_RW, FMT_DEC);
-PME_GENERIC_BSC_ATTR(42, PRIV_RW, FMT_DEC);
-PME_GENERIC_BSC_ATTR(43, PRIV_RW, FMT_DEC);
-PME_GENERIC_BSC_ATTR(44, PRIV_RW, FMT_DEC);
-PME_GENERIC_BSC_ATTR(45, PRIV_RW, FMT_DEC);
-PME_GENERIC_BSC_ATTR(46, PRIV_RW, FMT_DEC);
-PME_GENERIC_BSC_ATTR(47, PRIV_RW, FMT_DEC);
-PME_GENERIC_BSC_ATTR(48, PRIV_RW, FMT_DEC);
-PME_GENERIC_BSC_ATTR(49, PRIV_RW, FMT_DEC);
-PME_GENERIC_BSC_ATTR(50, PRIV_RW, FMT_DEC);
-PME_GENERIC_BSC_ATTR(51, PRIV_RW, FMT_DEC);
-PME_GENERIC_BSC_ATTR(52, PRIV_RW, FMT_DEC);
-PME_GENERIC_BSC_ATTR(53, PRIV_RW, FMT_DEC);
-PME_GENERIC_BSC_ATTR(54, PRIV_RW, FMT_DEC);
-PME_GENERIC_BSC_ATTR(55, PRIV_RW, FMT_DEC);
-PME_GENERIC_BSC_ATTR(56, PRIV_RW, FMT_DEC);
-PME_GENERIC_BSC_ATTR(57, PRIV_RW, FMT_DEC);
-PME_GENERIC_BSC_ATTR(58, PRIV_RW, FMT_DEC);
-PME_GENERIC_BSC_ATTR(59, PRIV_RW, FMT_DEC);
-PME_GENERIC_BSC_ATTR(60, PRIV_RW, FMT_DEC);
-PME_GENERIC_BSC_ATTR(61, PRIV_RW, FMT_DEC);
-PME_GENERIC_BSC_ATTR(62, PRIV_RW, FMT_DEC);
-PME_GENERIC_BSC_ATTR(63, PRIV_RW, FMT_DEC);
-
-/* read-only; */
-PME_GENERIC_ATTR(max_pdsr_index, PRIV_RO, FMT_DEC);
-PME_GENERIC_ATTR(sre_context_size, PRIV_RO, FMT_DEC);
-PME_GENERIC_ATTR(sre_rule_num, PRIV_RO, FMT_DEC);
-PME_GENERIC_ATTR(sre_session_ctx_num, PRIV_RO, FMT_DEC);
-PME_GENERIC_ATTR(sre_max_index_size, PRIV_RO, FMT_DEC);
-PME_GENERIC_ATTR(sre_max_offset_ctrl, PRIV_RO, FMT_DEC);
-PME_GENERIC_ATTR(src_id, PRIV_RO, FMT_DEC);
-PME_GENERIC_ATTR(liodnr, PRIV_RO, FMT_DEC);
-PME_GENERIC_ATTR(rev1, PRIV_RO, FMT_0HEX);
-PME_GENERIC_ATTR(rev2, PRIV_RO, FMT_0HEX);
-PME_GENERIC_ATTR(isr, PRIV_RO, FMT_0HEX);
-
-/* Stats */
-PME_GENERIC_STAT_ATTR(trunci, PRIV_RW);
-PME_GENERIC_STAT_ATTR(rbc, PRIV_RW);
-PME_GENERIC_STAT_ATTR(tbt0ecc1ec, PRIV_RW);
-PME_GENERIC_STAT_ATTR(tbt1ecc1ec, PRIV_RW);
-PME_GENERIC_STAT_ATTR(vlt0ecc1ec, PRIV_RW);
-PME_GENERIC_STAT_ATTR(vlt1ecc1ec, PRIV_RW);
-PME_GENERIC_STAT_ATTR(cmecc1ec, PRIV_RW);
-PME_GENERIC_STAT_ATTR(dxcmecc1ec, PRIV_RW);
-PME_GENERIC_STAT_ATTR(dxemecc1ec, PRIV_RW);
-PME_GENERIC_STAT_ATTR(stnib, PRIV_RW);
-PME_GENERIC_STAT_ATTR(stnis, PRIV_RW);
-PME_GENERIC_STAT_ATTR(stnth1, PRIV_RW);
-PME_GENERIC_STAT_ATTR(stnth2, PRIV_RW);
-PME_GENERIC_STAT_ATTR(stnthv, PRIV_RW);
-PME_GENERIC_STAT_ATTR(stnths, PRIV_RW);
-PME_GENERIC_STAT_ATTR(stnch, PRIV_RW);
-PME_GENERIC_STAT_ATTR(stnpm, PRIV_RW);
-PME_GENERIC_STAT_ATTR(stns1m, PRIV_RW);
-PME_GENERIC_STAT_ATTR(stnpmr, PRIV_RW);
-PME_GENERIC_STAT_ATTR(stndsr, PRIV_RW);
-PME_GENERIC_STAT_ATTR(stnesr, PRIV_RW);
-PME_GENERIC_STAT_ATTR(stns1r, PRIV_RW);
-PME_GENERIC_STAT_ATTR(stnob, PRIV_RW);
-PME_GENERIC_STAT_ATTR(mia_byc, PRIV_RW);
-PME_GENERIC_STAT_ATTR(mia_blc, PRIV_RW);
-
-static struct attribute *pme_drv_attrs[] = {
-	&driver_attr_efqc_int.attr,
-	&driver_attr_sw_db.attr,
-	&driver_attr_dmcr.attr,
-	&driver_attr_smcr.attr,
-	&driver_attr_famcr.attr,
-	&driver_attr_kvlts.attr,
-	&driver_attr_max_chain_length.attr,
-	&driver_attr_pattern_range_counter_idx.attr,
-	&driver_attr_pattern_range_counter_mask.attr,
-	&driver_attr_max_allowed_test_line_per_pattern.attr,
-	&driver_attr_max_pdsr_index.attr,
-	&driver_attr_max_pattern_matches_per_sui.attr,
-	&driver_attr_max_pattern_evaluations_per_sui.attr,
-	&driver_attr_report_length_limit.attr,
-	&driver_attr_end_of_simple_sui_report.attr,
-	&driver_attr_aim.attr,
-	&driver_attr_sre_context_size.attr,
-	&driver_attr_sre_rule_num.attr,
-	&driver_attr_sre_session_ctx_num.attr,
-	&driver_attr_end_of_sui_reaction_ptr.attr,
-	&driver_attr_sre_pscl.attr,
-	&driver_attr_sre_max_block_num.attr,
-	&driver_attr_sre_max_instruction_limit.attr,
-	&driver_attr_sre_max_index_size.attr,
-	&driver_attr_sre_max_offset_ctrl.attr,
-	&driver_attr_src_id.attr,
-	&driver_attr_liodnr.attr,
-	&driver_attr_rev1.attr,
-	&driver_attr_rev2.attr,
-	&driver_attr_isr.attr,
-	&driver_attr_bsc_0.attr,
-	&driver_attr_bsc_1.attr,
-	&driver_attr_bsc_2.attr,
-	&driver_attr_bsc_3.attr,
-	&driver_attr_bsc_4.attr,
-	&driver_attr_bsc_5.attr,
-	&driver_attr_bsc_6.attr,
-	&driver_attr_bsc_7.attr,
-	&driver_attr_bsc_8.attr,
-	&driver_attr_bsc_9.attr,
-	&driver_attr_bsc_10.attr,
-	&driver_attr_bsc_11.attr,
-	&driver_attr_bsc_12.attr,
-	&driver_attr_bsc_13.attr,
-	&driver_attr_bsc_14.attr,
-	&driver_attr_bsc_15.attr,
-	&driver_attr_bsc_16.attr,
-	&driver_attr_bsc_17.attr,
-	&driver_attr_bsc_18.attr,
-	&driver_attr_bsc_19.attr,
-	&driver_attr_bsc_20.attr,
-	&driver_attr_bsc_21.attr,
-	&driver_attr_bsc_22.attr,
-	&driver_attr_bsc_23.attr,
-	&driver_attr_bsc_24.attr,
-	&driver_attr_bsc_25.attr,
-	&driver_attr_bsc_26.attr,
-	&driver_attr_bsc_27.attr,
-	&driver_attr_bsc_28.attr,
-	&driver_attr_bsc_29.attr,
-	&driver_attr_bsc_30.attr,
-	&driver_attr_bsc_31.attr,
-	&driver_attr_bsc_32.attr,
-	&driver_attr_bsc_33.attr,
-	&driver_attr_bsc_34.attr,
-	&driver_attr_bsc_35.attr,
-	&driver_attr_bsc_36.attr,
-	&driver_attr_bsc_37.attr,
-	&driver_attr_bsc_38.attr,
-	&driver_attr_bsc_39.attr,
-	&driver_attr_bsc_40.attr,
-	&driver_attr_bsc_41.attr,
-	&driver_attr_bsc_42.attr,
-	&driver_attr_bsc_43.attr,
-	&driver_attr_bsc_44.attr,
-	&driver_attr_bsc_45.attr,
-	&driver_attr_bsc_46.attr,
-	&driver_attr_bsc_47.attr,
-	&driver_attr_bsc_48.attr,
-	&driver_attr_bsc_49.attr,
-	&driver_attr_bsc_50.attr,
-	&driver_attr_bsc_51.attr,
-	&driver_attr_bsc_52.attr,
-	&driver_attr_bsc_53.attr,
-	&driver_attr_bsc_54.attr,
-	&driver_attr_bsc_55.attr,
-	&driver_attr_bsc_56.attr,
-	&driver_attr_bsc_57.attr,
-	&driver_attr_bsc_58.attr,
-	&driver_attr_bsc_59.attr,
-	&driver_attr_bsc_60.attr,
-	&driver_attr_bsc_61.attr,
-	&driver_attr_bsc_62.attr,
-	&driver_attr_bsc_63.attr,
-	NULL
-};
-
-static struct attribute *pme_drv_stats_attrs[] = {
-	&driver_attr_update_interval.attr,
-	&driver_attr_trunci.attr,
-	&driver_attr_rbc.attr,
-	&driver_attr_tbt0ecc1ec.attr,
-	&driver_attr_tbt1ecc1ec.attr,
-	&driver_attr_vlt0ecc1ec.attr,
-	&driver_attr_vlt1ecc1ec.attr,
-	&driver_attr_cmecc1ec.attr,
-	&driver_attr_dxcmecc1ec.attr,
-	&driver_attr_dxemecc1ec.attr,
-	&driver_attr_stnib.attr,
-	&driver_attr_stnis.attr,
-	&driver_attr_stnth1.attr,
-	&driver_attr_stnth2.attr,
-	&driver_attr_stnthv.attr,
-	&driver_attr_stnths.attr,
-	&driver_attr_stnch.attr,
-	&driver_attr_stnpm.attr,
-	&driver_attr_stns1m.attr,
-	&driver_attr_stnpmr.attr,
-	&driver_attr_stndsr.attr,
-	&driver_attr_stnesr.attr,
-	&driver_attr_stns1r.attr,
-	&driver_attr_stnob.attr,
-	&driver_attr_mia_byc.attr,
-	&driver_attr_mia_blc.attr,
-	NULL
-};
-
-static struct attribute_group pme_drv_attr_grp = {
-	.attrs = pme_drv_attrs
-};
-
-static struct attribute_group pme_drv_stats_attr_grp = {
-	.name  = "stats",
-	.attrs = pme_drv_stats_attrs
-};
-
-static struct attribute_group *pme_drv_attr_groups[] = {
-	&pme_drv_attr_grp,
-	&pme_drv_stats_attr_grp,
-	NULL,
-};
-
 static struct of_device_id of_fsl_pme_ids[] = {
-	{ .compatible = "fsl,pme", },
+	{
+		.compatible = "fsl,pme",
+	},
 	{}
 };
+MODULE_DEVICE_TABLE(of, of_fsl_pme_ids);
 
 /* Pme interrupt handler */
 static irqreturn_t pme_isr(int irq, void *ptr)
@@ -668,34 +250,34 @@ static int of_fsl_pme_remove(struct of_device *ofdev)
 	cancel_delayed_work_sync(&accumulator_work);
 	/* Disable PME..TODO need to wait till it's quiet */
 	pme_out(global_pme, FACONF, PME_FACONF_RESET);
-
 	/* Release interrupt */
 	free_irq(pme_err_irq, &ofdev->dev);
-
+	/* Remove sysfs attribute */
+	pme2_remove_sysfs_dev_files(ofdev);
 	/* Unmap controller region */
 	iounmap(global_pme);
+	global_pme = NULL;
 	return 0;
 }
 
 static int __devinit of_fsl_pme_probe(struct of_device *ofdev,
 				const struct of_device_id *match)
 {
-	u32 __iomem *regs;
-	struct device *dev;
-	struct device_node *nprop;
+	int err = 0;
+	void __iomem *regs;
+	struct device *dev = &ofdev->dev;
+	struct device_node *nprop = ofdev->node;
 	u32 clkfreq = DEFAULT_SRFCC * 1000000;
 	const u32 *value;
 	int srec_aim = 0, srec_esr = 0;
 	u32 srecontextsize_code;
 
-	dev = &ofdev->dev;
-	nprop = ofdev->node;
-
 	pme_err_irq = of_irq_to_resource(nprop, 0, NULL);
 	if (pme_err_irq == NO_IRQ) {
 		dev_err(dev, "Can't get %s property '%s'\n", nprop->full_name,
 			"interrupts");
-		return -ENODEV;
+		err = -ENODEV;
+		goto out;
 	}
 
 	/* Get configuration properties from device tree */
@@ -703,15 +285,33 @@ static int __devinit of_fsl_pme_probe(struct of_device *ofdev,
 	regs = of_iomap(nprop, 0);
 	if (regs == NULL) {
 		dev_err(dev, "of_iomap() failed\n");
-		return -EINVAL;
+		err = -EINVAL;
+		goto out;
 	}
-	/* Global configuration */
-	global_pme = pme_create(regs);
+
+	/* Global configuration, enable pme */
+	global_pme = (struct pme *)regs;
+	pme_out(global_pme, FACONF, 0);
+	pme_out(global_pme, EFQC, PME_EFQC(0, 0));
+	pme_out(global_pme, FACONF, PME_FACONF_ENABLE);
+	/* TODO: these coherency settings for PMFA, DXE, and SRE force all
+	 * transactions to snoop, as the kernel does not yet support flushing in
+	 * dma_map_***() APIs (ie. h/w can not treat otherwise coherent memory
+	 * in a non-coherent manner, temporarily or otherwise). When the kernel
+	 * supports this, we should tune these settings back to;
+	 *     FAMCR = 0x00010001
+	 *      DMCR = 0x00000000
+	 *      SMCR = 0x00000000
+	 */
+	pme_out(global_pme, FAMCR, 0x01010101);
+	pme_out(global_pme, DMCR, 0x00000001);
+	pme_out(global_pme, SMCR, 0x00000211);
 
 	/* Register the pme ISR handler */
-	if (request_irq(pme_err_irq, pme_isr, IRQF_SHARED, "pme-err", dev)) {
+	err = request_irq(pme_err_irq, pme_isr, IRQF_SHARED, "pme-err", dev);
+	if (err) {
 		dev_err(dev, "request_irq() failed\n");
-		return -ENODEV;
+		goto out_unmap_ctrl_region;
 	}
 
 #ifdef CONFIG_FSL_PME2_SRE_AIM
@@ -725,17 +325,18 @@ static int __devinit of_fsl_pme_probe(struct of_device *ofdev,
 			(sre_session_ctx_size < 32) ||
 			(sre_session_ctx_size > (131072))) {
 		dev_err(dev, "invalid sre_session_ctx_size\n");
-		iounmap(global_pme);
-		return -EINVAL;
+		err = -EINVAL;
+		goto out_free_irq;
 	}
 	srecontextsize_code = ilog2(sre_session_ctx_size);
 	srecontextsize_code -= 4;
 
+	/* Configure Clock Frequency */
 	value = of_get_property(nprop, "clock-frequency", NULL);
 	if (value)
 		clkfreq = *value;
-
 	pme_out(global_pme, SFRCC, clkfreq/1000000);
+
 	BUG_ON(sizeof(dxe_a) != 4);
 	pme_out(global_pme, PDSRBAL, (u32)dxe_a);
 	pme_out(global_pme, SCBARL, (u32)sre_a);
@@ -761,7 +362,6 @@ static int __devinit of_fsl_pme_probe(struct of_device *ofdev,
 		(srecontextsize_code << 19) |
 		/* Alternate Inclusive Mode */
 		((srec_aim ? 1 : 0) << 29));
-
 	pme_out(global_pme, SEC1,
 		(CONFIG_FSL_PME2_SRE_MAX_INSTRUCTION_LIMIT << 16) |
 		CONFIG_FSL_PME2_SRE_MAX_BLOCK_NUMBER);
@@ -770,21 +370,36 @@ static int __devinit of_fsl_pme_probe(struct of_device *ofdev,
 	if (pme_stat_interval)
 		schedule_delayed_work(&accumulator_work,
 				msecs_to_jiffies(pme_stat_interval));
+	/* Create sysfs entries */
+	err = pme2_create_sysfs_dev_files(ofdev);
+	if (err)
+		goto out_stop_accumulator;
 
 	/* Enable interrupts */
 	pme_out(global_pme, IER, PME_ALL_ERR);
-
 	dev_info(dev, "ver: 0x%08x\n", pme_in(global_pme, PM_IP_REV1));
 	return 0;
+
+out_stop_accumulator:
+	if (pme_stat_interval) {
+		accumulator_update_interval(0);
+		cancel_delayed_work_sync(&accumulator_work);
+	}
+out_free_irq:
+	free_irq(pme_err_irq, &ofdev->dev);
+out_unmap_ctrl_region:
+	pme_out(global_pme, FACONF, PME_FACONF_RESET);
+	iounmap(global_pme);
+	global_pme = NULL;
+out:
+	return err;
 }
 
 static struct of_platform_driver of_fsl_pme_driver = {
-	.name = "of-fsl-pme",
+	.owner = THIS_MODULE,
+	.name = DRV_NAME,
 	.match_table = of_fsl_pme_ids,
 	.probe = of_fsl_pme_probe,
-	.driver = {
-		.groups = pme_drv_attr_groups,
-	},
 	.remove      = __devexit_p(of_fsl_pme_remove),
 };
 
@@ -869,8 +484,6 @@ int pme_attr_set(enum pme_attr attr, u32 val)
 		attr_val = pme_in(global_pme, EFQC);
 		/* clear efqc_int */
 		attr_val &= mask;
-		/* clear unwanted bits in val*/
-		val &= ~mask;
 		val <<= 28;
 		val |= attr_val;
 		pme_out(global_pme, EFQC, val);
@@ -1054,6 +667,27 @@ int pme_attr_set(enum pme_attr attr, u32 val)
 	case pme_attr_srrr:
 		pme_out(global_pme, SRRR, val);
 		break;
+	case pme_attr_tbt0ecc1th:
+		pme_out(global_pme, TBT0ECC1TH, val);
+		break;
+	case pme_attr_tbt1ecc1th:
+		pme_out(global_pme, TBT1ECC1TH, val);
+		break;
+	case pme_attr_vlt0ecc1th:
+		pme_out(global_pme, VLT0ECC1TH, val);
+		break;
+	case pme_attr_vlt1ecc1th:
+		pme_out(global_pme, VLT1ECC1TH, val);
+		break;
+	case pme_attr_cmecc1th:
+		pme_out(global_pme, CMECC1TH, val);
+		break;
+	case pme_attr_dxcmecc1th:
+		pme_out(global_pme, DXCMECC1TH, val);
+		break;
+	case pme_attr_dxemecc1th:
+		pme_out(global_pme, DXEMECC1TH, val);
+		break;
 
 	default:
 		pr_err("pme: Unknown attr %u\n", attr);
@@ -1320,6 +954,34 @@ int pme_attr_get(enum pme_attr attr, u32 *val)
 		attr_val = pme_in(global_pme, DXEMECC1EC);
 		break;
 
+	case pme_attr_tbt0ecc1th:
+		attr_val = pme_in(global_pme, TBT0ECC1TH);
+		break;
+
+	case pme_attr_tbt1ecc1th:
+		attr_val = pme_in(global_pme, TBT1ECC1TH);
+		break;
+
+	case pme_attr_vlt0ecc1th:
+		attr_val = pme_in(global_pme, VLT0ECC1TH);
+		break;
+
+	case pme_attr_vlt1ecc1th:
+		attr_val = pme_in(global_pme, VLT1ECC1TH);
+		break;
+
+	case pme_attr_cmecc1th:
+		attr_val = pme_in(global_pme, CMECC1TH);
+		break;
+
+	case pme_attr_dxcmecc1th:
+		attr_val = pme_in(global_pme, DXCMECC1TH);
+		break;
+
+	case pme_attr_dxemecc1th:
+		attr_val = pme_in(global_pme, DXEMECC1TH);
+		break;
+
 	case pme_attr_stnib:
 		attr_val = pme_in(global_pme, STNIB);
 		break;
@@ -1461,7 +1123,7 @@ int pme_stat_get(enum pme_attr *stat, u64 *value, int reset)
 }
 EXPORT_SYMBOL(pme_stat_get);
 
-static void accumulator_update_interval(u32 interval)
+void accumulator_update_interval(u32 interval)
 {
 	int schedule = 0;
 
diff --git a/drivers/match/pme2_private.h b/drivers/match/pme2_private.h
index 5597c67..83bddb8 100644
--- a/drivers/match/pme2_private.h
+++ b/drivers/match/pme2_private.h
@@ -132,6 +132,7 @@ struct qman_fq *slabfq_alloc(void);
 void slabfq_free(struct qman_fq *fq);
 
 /* Hook from pme2_high to pme2_ctrl */
+int pme2_have_control(void);
 int pme2_exclusive_set(struct qman_fq *fq);
 int pme2_exclusive_unset(void);
 
diff --git a/drivers/match/pme2_sys.h b/drivers/match/pme2_sys.h
index a935c1e..41b6c85 100644
--- a/drivers/match/pme2_sys.h
+++ b/drivers/match/pme2_sys.h
@@ -38,4 +38,10 @@
 #endif
 #define PME_ASSERT(x) BM_ASSERT(x)
 #include "../hwalloc/bman_sys.h"
+#include <linux/device.h>
+#include <linux/fsl_pme.h>
+int pme2_create_sysfs_dev_files(struct of_device *ofdev);
+void pme2_remove_sysfs_dev_files(struct of_device *ofdev);
+int pme_stat_get(enum pme_attr *stat, u64 *value, int reset);
+void accumulator_update_interval(u32 interval);
 
diff --git a/drivers/match/pme2_sysfs.c b/drivers/match/pme2_sysfs.c
new file mode 100644
index 0000000..f20115e
--- /dev/null
+++ b/drivers/match/pme2_sysfs.c
@@ -0,0 +1,530 @@
+/* Copyright (c) 2008, 2009, Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#include "pme2_sys.h"
+#include "pme2_regs.h"
+#include "pme2_private.h"
+
+#define MAX_ACCUMULATOR_INTERVAL 10000
+extern u32 pme_stat_interval;
+
+/* The pme sysfs contains the following types of attributes
+ * 1) root level: general pme confuration
+ * 2) bsc: bufferpool size configuration
+ * 3) stats: pme statistics
+ */
+static ssize_t pme_store(struct device *dev, struct device_attribute *dev_attr,
+		const char *buf, size_t count, enum pme_attr attr)
+{
+	unsigned long val;
+	size_t ret;
+	if (strict_strtoul(buf, 0, &val)) {
+		dev_dbg(dev, "invalid input %s\n",buf);
+		return -EINVAL;
+	}
+	ret = pme_attr_set(attr, val);
+	if (ret) {
+		dev_err(dev, "attr_set err attr=%u, val=%lu\n", attr, val);
+		return ret;
+	}
+	return count;
+}
+
+static ssize_t pme_show(struct device *dev, struct device_attribute *dev_attr,
+		char *buf, enum pme_attr attr, const char *fmt)
+{
+	u32 data;
+	int ret;
+
+	ret =  pme_attr_get(attr, &data);
+	if (!ret)
+		return snprintf(buf, PAGE_SIZE, fmt, data);
+	return ret;
+}
+
+
+static ssize_t pme_stat_show(struct device *dev,
+	struct device_attribute *dev_attr, char *buf, enum pme_attr attr)
+{
+	u64 data = 0;
+	int ret = 0;
+
+	ret = pme_stat_get(&attr, &data, 0);
+	if (!ret)
+		return snprintf(buf, PAGE_SIZE, "%llu\n", data);
+	else
+		return ret;
+}
+
+static ssize_t pme_stat_store(struct device *dev,
+		struct device_attribute *dev_attr, const char *buf,
+		size_t count, enum pme_attr attr)
+{
+	unsigned long val;
+	u64 data = 0;
+	size_t ret = 0;
+	if (strict_strtoul(buf, 0, &val)) {
+		pr_err("pme: invalid input %s\n", buf);
+		return -EINVAL;
+	}
+	if (val) {
+		pr_err("pme: invalid input %s\n", buf);
+		return -EINVAL;
+	}
+	ret = pme_stat_get(&attr, &data, 1);
+	return count;
+}
+
+
+#define PME_SYSFS_ATTR(pme_attr, perm, showhex) \
+static ssize_t pme_store_##pme_attr(struct device *dev, \
+		struct device_attribute *attr, const char *buf, size_t count) \
+{ \
+	return pme_store(dev, attr, buf, count, pme_attr_##pme_attr);\
+} \
+static ssize_t pme_show_##pme_attr(struct device *dev, \
+		struct device_attribute *attr, char *buf) \
+{ \
+	return pme_show(dev, attr, buf, pme_attr_##pme_attr, showhex);\
+} \
+static DEVICE_ATTR( pme_attr, perm, pme_show_##pme_attr, pme_store_##pme_attr);
+
+
+#define PME_SYSFS_STAT_ATTR(pme_attr, perm) \
+static ssize_t pme_store_##pme_attr(struct device *dev, \
+		struct device_attribute *attr, const char *buf, size_t count) \
+{ \
+	return pme_stat_store(dev, attr, buf, count, pme_attr_##pme_attr);\
+} \
+static ssize_t pme_show_##pme_attr(struct device *dev, \
+		struct device_attribute *attr, char *buf) \
+{ \
+	return pme_stat_show(dev, attr, buf, pme_attr_##pme_attr);\
+} \
+static DEVICE_ATTR(pme_attr, perm, pme_show_##pme_attr, pme_store_##pme_attr);
+
+
+#define PME_SYSFS_BSC_ATTR(bsc_id, perm, showhex) \
+static ssize_t pme_store_bsc_##bsc_id(struct device *dev,\
+		struct device_attribute *attr, const char *buf, size_t count) \
+{ \
+	return pme_store(dev, attr, buf, count, pme_attr_bsc(bsc_id));\
+} \
+static ssize_t pme_show_bsc_##bsc_id(struct device *dev,\
+		struct device_attribute *attr, char *buf) \
+{ \
+	return pme_show(dev, attr, buf, pme_attr_bsc(bsc_id), showhex);\
+} \
+static DEVICE_ATTR(bsc_id, perm, pme_show_bsc_##bsc_id, \
+			pme_store_bsc_##bsc_id);
+
+/* Statistics Ctrl: update interval */
+static ssize_t pme_store_update_interval(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	unsigned long val;
+
+	if (!pme2_have_control()) {
+		PMEPRERR("not on ctrl-plane\n");
+		return -ENODEV;
+	}
+	if (strict_strtoul(buf, 0, &val)) {
+		dev_info(dev, "invalid input %s\n", buf);
+		return -EINVAL;
+	}
+	if (val > MAX_ACCUMULATOR_INTERVAL) {
+		dev_info(dev, "invalid input %s\n", buf);
+		return -ERANGE;
+	}
+	accumulator_update_interval(val);
+	return count;
+}
+static ssize_t pme_show_update_interval(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	if (!pme2_have_control())
+		return -ENODEV;
+	return snprintf(buf, PAGE_SIZE, "%u\n", pme_stat_interval);
+}
+
+#define FMT_0HEX "0x%08x\n"
+#define FMT_HEX  "0x%x\n"
+#define FMT_DEC  "%u\n"
+#define PRIV_RO  S_IRUSR
+#define PRIV_RW  (S_IRUSR | S_IWUSR)
+
+/* Register Interfaces */
+/* read-write; */
+PME_SYSFS_ATTR(efqc_int, PRIV_RW, FMT_DEC);
+PME_SYSFS_ATTR(sw_db, PRIV_RW, FMT_DEC);
+PME_SYSFS_ATTR(dmcr, PRIV_RW, FMT_0HEX);
+PME_SYSFS_ATTR(smcr, PRIV_RW, FMT_0HEX);
+PME_SYSFS_ATTR(famcr, PRIV_RW, FMT_0HEX);
+PME_SYSFS_ATTR(kvlts, PRIV_RW, FMT_DEC);
+PME_SYSFS_ATTR(max_chain_length, PRIV_RW, FMT_DEC);
+PME_SYSFS_ATTR(pattern_range_counter_idx, PRIV_RW, FMT_0HEX);
+PME_SYSFS_ATTR(pattern_range_counter_mask, PRIV_RW, FMT_0HEX);
+PME_SYSFS_ATTR(max_allowed_test_line_per_pattern, PRIV_RW, FMT_DEC);
+PME_SYSFS_ATTR(max_pattern_matches_per_sui, PRIV_RW, FMT_DEC);
+PME_SYSFS_ATTR(max_pattern_evaluations_per_sui, PRIV_RW, FMT_DEC);
+PME_SYSFS_ATTR(report_length_limit, PRIV_RW, FMT_DEC);
+PME_SYSFS_ATTR(end_of_simple_sui_report, PRIV_RW, FMT_DEC);
+PME_SYSFS_ATTR(aim, PRIV_RW, FMT_DEC);
+PME_SYSFS_ATTR(end_of_sui_reaction_ptr, PRIV_RW, FMT_DEC);
+PME_SYSFS_ATTR(sre_pscl, PRIV_RW, FMT_DEC);
+PME_SYSFS_ATTR(sre_max_block_num, PRIV_RW, FMT_DEC);
+PME_SYSFS_ATTR(sre_max_instruction_limit, PRIV_RW, FMT_DEC);
+
+/* read-only; */
+PME_SYSFS_ATTR(max_pdsr_index, PRIV_RO, FMT_DEC);
+PME_SYSFS_ATTR(sre_context_size, PRIV_RO, FMT_DEC);
+PME_SYSFS_ATTR(sre_rule_num, PRIV_RO, FMT_DEC);
+PME_SYSFS_ATTR(sre_session_ctx_num, PRIV_RO, FMT_DEC);
+PME_SYSFS_ATTR(sre_max_index_size, PRIV_RO, FMT_DEC);
+PME_SYSFS_ATTR(sre_max_offset_ctrl, PRIV_RO, FMT_DEC);
+PME_SYSFS_ATTR(src_id, PRIV_RO, FMT_DEC);
+PME_SYSFS_ATTR(liodnr, PRIV_RO, FMT_DEC);
+PME_SYSFS_ATTR(rev1, PRIV_RO, FMT_0HEX);
+PME_SYSFS_ATTR(rev2, PRIV_RO, FMT_0HEX);
+PME_SYSFS_ATTR(isr, PRIV_RO, FMT_0HEX);
+
+/* Buffer Pool Size Configuration */
+PME_SYSFS_BSC_ATTR(0, PRIV_RW, FMT_DEC);
+PME_SYSFS_BSC_ATTR(1, PRIV_RW, FMT_DEC);
+PME_SYSFS_BSC_ATTR(2, PRIV_RW, FMT_DEC);
+PME_SYSFS_BSC_ATTR(3, PRIV_RW, FMT_DEC);
+PME_SYSFS_BSC_ATTR(4, PRIV_RW, FMT_DEC);
+PME_SYSFS_BSC_ATTR(5, PRIV_RW, FMT_DEC);
+PME_SYSFS_BSC_ATTR(6, PRIV_RW, FMT_DEC);
+PME_SYSFS_BSC_ATTR(7, PRIV_RW, FMT_DEC);
+PME_SYSFS_BSC_ATTR(8, PRIV_RW, FMT_DEC);
+PME_SYSFS_BSC_ATTR(9, PRIV_RW, FMT_DEC);
+PME_SYSFS_BSC_ATTR(10, PRIV_RW, FMT_DEC);
+PME_SYSFS_BSC_ATTR(11, PRIV_RW, FMT_DEC);
+PME_SYSFS_BSC_ATTR(12, PRIV_RW, FMT_DEC);
+PME_SYSFS_BSC_ATTR(13, PRIV_RW, FMT_DEC);
+PME_SYSFS_BSC_ATTR(14, PRIV_RW, FMT_DEC);
+PME_SYSFS_BSC_ATTR(15, PRIV_RW, FMT_DEC);
+PME_SYSFS_BSC_ATTR(16, PRIV_RW, FMT_DEC);
+PME_SYSFS_BSC_ATTR(17, PRIV_RW, FMT_DEC);
+PME_SYSFS_BSC_ATTR(18, PRIV_RW, FMT_DEC);
+PME_SYSFS_BSC_ATTR(19, PRIV_RW, FMT_DEC);
+PME_SYSFS_BSC_ATTR(20, PRIV_RW, FMT_DEC);
+PME_SYSFS_BSC_ATTR(21, PRIV_RW, FMT_DEC);
+PME_SYSFS_BSC_ATTR(22, PRIV_RW, FMT_DEC);
+PME_SYSFS_BSC_ATTR(23, PRIV_RW, FMT_DEC);
+PME_SYSFS_BSC_ATTR(24, PRIV_RW, FMT_DEC);
+PME_SYSFS_BSC_ATTR(25, PRIV_RW, FMT_DEC);
+PME_SYSFS_BSC_ATTR(26, PRIV_RW, FMT_DEC);
+PME_SYSFS_BSC_ATTR(27, PRIV_RW, FMT_DEC);
+PME_SYSFS_BSC_ATTR(28, PRIV_RW, FMT_DEC);
+PME_SYSFS_BSC_ATTR(29, PRIV_RW, FMT_DEC);
+PME_SYSFS_BSC_ATTR(30, PRIV_RW, FMT_DEC);
+PME_SYSFS_BSC_ATTR(31, PRIV_RW, FMT_DEC);
+PME_SYSFS_BSC_ATTR(32, PRIV_RW, FMT_DEC);
+PME_SYSFS_BSC_ATTR(33, PRIV_RW, FMT_DEC);
+PME_SYSFS_BSC_ATTR(34, PRIV_RW, FMT_DEC);
+PME_SYSFS_BSC_ATTR(35, PRIV_RW, FMT_DEC);
+PME_SYSFS_BSC_ATTR(36, PRIV_RW, FMT_DEC);
+PME_SYSFS_BSC_ATTR(37, PRIV_RW, FMT_DEC);
+PME_SYSFS_BSC_ATTR(38, PRIV_RW, FMT_DEC);
+PME_SYSFS_BSC_ATTR(39, PRIV_RW, FMT_DEC);
+PME_SYSFS_BSC_ATTR(40, PRIV_RW, FMT_DEC);
+PME_SYSFS_BSC_ATTR(41, PRIV_RW, FMT_DEC);
+PME_SYSFS_BSC_ATTR(42, PRIV_RW, FMT_DEC);
+PME_SYSFS_BSC_ATTR(43, PRIV_RW, FMT_DEC);
+PME_SYSFS_BSC_ATTR(44, PRIV_RW, FMT_DEC);
+PME_SYSFS_BSC_ATTR(45, PRIV_RW, FMT_DEC);
+PME_SYSFS_BSC_ATTR(46, PRIV_RW, FMT_DEC);
+PME_SYSFS_BSC_ATTR(47, PRIV_RW, FMT_DEC);
+PME_SYSFS_BSC_ATTR(48, PRIV_RW, FMT_DEC);
+PME_SYSFS_BSC_ATTR(49, PRIV_RW, FMT_DEC);
+PME_SYSFS_BSC_ATTR(50, PRIV_RW, FMT_DEC);
+PME_SYSFS_BSC_ATTR(51, PRIV_RW, FMT_DEC);
+PME_SYSFS_BSC_ATTR(52, PRIV_RW, FMT_DEC);
+PME_SYSFS_BSC_ATTR(53, PRIV_RW, FMT_DEC);
+PME_SYSFS_BSC_ATTR(54, PRIV_RW, FMT_DEC);
+PME_SYSFS_BSC_ATTR(55, PRIV_RW, FMT_DEC);
+PME_SYSFS_BSC_ATTR(56, PRIV_RW, FMT_DEC);
+PME_SYSFS_BSC_ATTR(57, PRIV_RW, FMT_DEC);
+PME_SYSFS_BSC_ATTR(58, PRIV_RW, FMT_DEC);
+PME_SYSFS_BSC_ATTR(59, PRIV_RW, FMT_DEC);
+PME_SYSFS_BSC_ATTR(60, PRIV_RW, FMT_DEC);
+PME_SYSFS_BSC_ATTR(61, PRIV_RW, FMT_DEC);
+PME_SYSFS_BSC_ATTR(62, PRIV_RW, FMT_DEC);
+PME_SYSFS_BSC_ATTR(63, PRIV_RW, FMT_DEC);
+
+/* Stats Counters*/
+PME_SYSFS_STAT_ATTR(trunci, PRIV_RW);
+PME_SYSFS_STAT_ATTR(rbc, PRIV_RW);
+PME_SYSFS_STAT_ATTR(tbt0ecc1ec, PRIV_RW);
+PME_SYSFS_STAT_ATTR(tbt1ecc1ec, PRIV_RW);
+PME_SYSFS_STAT_ATTR(vlt0ecc1ec, PRIV_RW);
+PME_SYSFS_STAT_ATTR(vlt1ecc1ec, PRIV_RW);
+PME_SYSFS_STAT_ATTR(cmecc1ec, PRIV_RW);
+PME_SYSFS_STAT_ATTR(dxcmecc1ec, PRIV_RW);
+PME_SYSFS_STAT_ATTR(dxemecc1ec, PRIV_RW);
+PME_SYSFS_STAT_ATTR(stnib, PRIV_RW);
+PME_SYSFS_STAT_ATTR(stnis, PRIV_RW);
+PME_SYSFS_STAT_ATTR(stnth1, PRIV_RW);
+PME_SYSFS_STAT_ATTR(stnth2, PRIV_RW);
+PME_SYSFS_STAT_ATTR(stnthv, PRIV_RW);
+PME_SYSFS_STAT_ATTR(stnths, PRIV_RW);
+PME_SYSFS_STAT_ATTR(stnch, PRIV_RW);
+PME_SYSFS_STAT_ATTR(stnpm, PRIV_RW);
+PME_SYSFS_STAT_ATTR(stns1m, PRIV_RW);
+PME_SYSFS_STAT_ATTR(stnpmr, PRIV_RW);
+PME_SYSFS_STAT_ATTR(stndsr, PRIV_RW);
+PME_SYSFS_STAT_ATTR(stnesr, PRIV_RW);
+PME_SYSFS_STAT_ATTR(stns1r, PRIV_RW);
+PME_SYSFS_STAT_ATTR(stnob, PRIV_RW);
+PME_SYSFS_STAT_ATTR(mia_byc, PRIV_RW);
+PME_SYSFS_STAT_ATTR(mia_blc, PRIV_RW);
+
+/* Stats Control */
+PME_SYSFS_ATTR(tbt0ecc1th, PRIV_RW, FMT_DEC);
+PME_SYSFS_ATTR(tbt1ecc1th, PRIV_RW, FMT_DEC);
+PME_SYSFS_ATTR(vlt0ecc1th, PRIV_RW, FMT_DEC);
+PME_SYSFS_ATTR(vlt1ecc1th, PRIV_RW, FMT_DEC);
+PME_SYSFS_ATTR(cmecc1th, PRIV_RW, FMT_DEC);
+PME_SYSFS_ATTR(dxcmecc1th, PRIV_RW, FMT_DEC);
+PME_SYSFS_ATTR(dxemecc1th, PRIV_RW, FMT_DEC);
+
+static DEVICE_ATTR(update_interval, (S_IRUSR | S_IWUSR),
+		pme_show_update_interval, pme_store_update_interval);
+
+static struct attribute *pme_dev_bsc_attributes[] = {
+	&dev_attr_0.attr,
+	&dev_attr_1.attr,
+	&dev_attr_2.attr,
+	&dev_attr_3.attr,
+	&dev_attr_4.attr,
+	&dev_attr_5.attr,
+	&dev_attr_6.attr,
+	&dev_attr_7.attr,
+	&dev_attr_8.attr,
+	&dev_attr_9.attr,
+	&dev_attr_10.attr,
+	&dev_attr_11.attr,
+	&dev_attr_12.attr,
+	&dev_attr_13.attr,
+	&dev_attr_14.attr,
+	&dev_attr_15.attr,
+	&dev_attr_16.attr,
+	&dev_attr_17.attr,
+	&dev_attr_18.attr,
+	&dev_attr_19.attr,
+	&dev_attr_20.attr,
+	&dev_attr_21.attr,
+	&dev_attr_22.attr,
+	&dev_attr_23.attr,
+	&dev_attr_24.attr,
+	&dev_attr_25.attr,
+	&dev_attr_26.attr,
+	&dev_attr_27.attr,
+	&dev_attr_28.attr,
+	&dev_attr_29.attr,
+	&dev_attr_30.attr,
+	&dev_attr_31.attr,
+	&dev_attr_32.attr,
+	&dev_attr_33.attr,
+	&dev_attr_34.attr,
+	&dev_attr_35.attr,
+	&dev_attr_36.attr,
+	&dev_attr_37.attr,
+	&dev_attr_38.attr,
+	&dev_attr_39.attr,
+	&dev_attr_40.attr,
+	&dev_attr_41.attr,
+	&dev_attr_42.attr,
+	&dev_attr_43.attr,
+	&dev_attr_44.attr,
+	&dev_attr_45.attr,
+	&dev_attr_46.attr,
+	&dev_attr_47.attr,
+	&dev_attr_48.attr,
+	&dev_attr_49.attr,
+	&dev_attr_50.attr,
+	&dev_attr_51.attr,
+	&dev_attr_52.attr,
+	&dev_attr_53.attr,
+	&dev_attr_54.attr,
+	&dev_attr_55.attr,
+	&dev_attr_56.attr,
+	&dev_attr_57.attr,
+	&dev_attr_58.attr,
+	&dev_attr_59.attr,
+	&dev_attr_60.attr,
+	&dev_attr_61.attr,
+	&dev_attr_62.attr,
+	&dev_attr_63.attr,
+	NULL
+};
+
+static struct attribute *pme_dev_attributes[] = {
+	&dev_attr_efqc_int.attr,
+	&dev_attr_sw_db.attr,
+	&dev_attr_dmcr.attr,
+	&dev_attr_smcr.attr,
+	&dev_attr_famcr.attr,
+	&dev_attr_kvlts.attr,
+	&dev_attr_max_chain_length.attr,
+	&dev_attr_pattern_range_counter_idx.attr,
+	&dev_attr_pattern_range_counter_mask.attr,
+	&dev_attr_max_allowed_test_line_per_pattern.attr,
+	&dev_attr_max_pdsr_index.attr,
+	&dev_attr_max_pattern_matches_per_sui.attr,
+	&dev_attr_max_pattern_evaluations_per_sui.attr,
+	&dev_attr_report_length_limit.attr,
+	&dev_attr_end_of_simple_sui_report.attr,
+	&dev_attr_aim.attr,
+	&dev_attr_sre_context_size.attr,
+	&dev_attr_sre_rule_num.attr,
+	&dev_attr_sre_session_ctx_num.attr,
+	&dev_attr_end_of_sui_reaction_ptr.attr,
+	&dev_attr_sre_pscl.attr,
+	&dev_attr_sre_max_block_num.attr,
+	&dev_attr_sre_max_instruction_limit.attr,
+	&dev_attr_sre_max_index_size.attr,
+	&dev_attr_sre_max_offset_ctrl.attr,
+	&dev_attr_src_id.attr,
+	&dev_attr_liodnr.attr,
+	&dev_attr_rev1.attr,
+	&dev_attr_rev2.attr,
+	&dev_attr_isr.attr,
+	NULL
+};
+
+static struct attribute *pme_dev_stats_counter_attributes[] = {
+	&dev_attr_trunci.attr,
+	&dev_attr_rbc.attr,
+	&dev_attr_tbt0ecc1ec.attr,
+	&dev_attr_tbt1ecc1ec.attr,
+	&dev_attr_vlt0ecc1ec.attr,
+	&dev_attr_vlt1ecc1ec.attr,
+	&dev_attr_cmecc1ec.attr,
+	&dev_attr_dxcmecc1ec.attr,
+	&dev_attr_dxemecc1ec.attr,
+	&dev_attr_stnib.attr,
+	&dev_attr_stnis.attr,
+	&dev_attr_stnth1.attr,
+	&dev_attr_stnth2.attr,
+	&dev_attr_stnthv.attr,
+	&dev_attr_stnths.attr,
+	&dev_attr_stnch.attr,
+	&dev_attr_stnpm.attr,
+	&dev_attr_stns1m.attr,
+	&dev_attr_stnpmr.attr,
+	&dev_attr_stndsr.attr,
+	&dev_attr_stnesr.attr,
+	&dev_attr_stns1r.attr,
+	&dev_attr_stnob.attr,
+	&dev_attr_mia_byc.attr,
+	&dev_attr_mia_blc.attr,
+	NULL
+};
+
+static struct attribute *pme_dev_stats_ctrl_attributes[] = {
+	&dev_attr_update_interval.attr,
+	&dev_attr_tbt0ecc1th.attr,
+	&dev_attr_tbt1ecc1th.attr,
+	&dev_attr_vlt0ecc1th.attr,
+	&dev_attr_vlt1ecc1th.attr,
+	&dev_attr_cmecc1th.attr,
+	&dev_attr_dxcmecc1th.attr,
+	&dev_attr_dxemecc1th.attr,
+	NULL
+};
+
+/* root level */
+static const struct attribute_group pme_dev_attr_grp = {
+	.name = NULL,	/* put in device directory */
+	.attrs = pme_dev_attributes
+};
+
+/* root/bsc */
+static struct attribute_group pme_dev_bsc_attr_grp = {
+	.name  = "bsc",
+	.attrs = pme_dev_bsc_attributes
+};
+
+/* root/stats */
+static struct attribute_group pme_dev_stats_counters_attr_grp = {
+	.name  = "stats",
+	.attrs = pme_dev_stats_counter_attributes
+};
+
+/* root/stats_ctrl */
+static struct attribute_group pme_dev_stats_ctrl_attr_grp = {
+	.name  = "stats_ctrl",
+	.attrs = pme_dev_stats_ctrl_attributes
+};
+
+
+int pme2_create_sysfs_dev_files(struct of_device *ofdev)
+{
+	int ret;
+
+	ret = sysfs_create_group(&ofdev->dev.kobj, &pme_dev_attr_grp);
+	if (ret)
+		goto done;
+	ret = sysfs_create_group(&ofdev->dev.kobj, &pme_dev_bsc_attr_grp);
+	if (ret)
+		goto del_group_1;
+	ret = sysfs_create_group(&ofdev->dev.kobj, &pme_dev_stats_counters_attr_grp);
+	if (ret)
+		goto del_group_2;
+	ret = sysfs_create_group(&ofdev->dev.kobj, &pme_dev_stats_ctrl_attr_grp);
+	if (ret)
+		goto del_group_3;
+	goto done;
+del_group_3:
+	sysfs_remove_group(&ofdev->dev.kobj, &pme_dev_stats_counters_attr_grp);
+del_group_2:
+	sysfs_remove_group(&ofdev->dev.kobj, &pme_dev_bsc_attr_grp);
+del_group_1:
+	sysfs_remove_group(&ofdev->dev.kobj, &pme_dev_attr_grp);
+done:
+	if (ret)
+		dev_err(&ofdev->dev,
+				"Cannot create dev attributes  ret=%d\n", ret);
+	return ret;
+}
+
+void pme2_remove_sysfs_dev_files(struct of_device *ofdev)
+{
+	sysfs_remove_group(&ofdev->dev.kobj, &pme_dev_stats_ctrl_attr_grp);
+	sysfs_remove_group(&ofdev->dev.kobj, &pme_dev_stats_counters_attr_grp);
+	sysfs_remove_group(&ofdev->dev.kobj, &pme_dev_bsc_attr_grp);
+	sysfs_remove_group(&ofdev->dev.kobj, &pme_dev_attr_grp);
+}
+
+
diff --git a/include/linux/fsl_pme.h b/include/linux/fsl_pme.h
index 18ebdaa..761cc7b 100644
--- a/include/linux/fsl_pme.h
+++ b/include/linux/fsl_pme.h
@@ -653,7 +653,13 @@ enum pme_attr {
 	pme_attr_isr,
 	pme_attr_bsc_first,
 	pme_attr_bsc_last = pme_attr_bsc_first + 63,
-
+	pme_attr_tbt0ecc1th,
+	pme_attr_tbt1ecc1th,
+	pme_attr_vlt0ecc1th,
+	pme_attr_vlt1ecc1th,
+	pme_attr_cmecc1th,
+	pme_attr_dxcmecc1th,
+	pme_attr_dxemecc1th
 };
 
 #define pme_attr_bsc(n) (pme_attr_bsc_first + (n))
-- 
1.6.0.4

