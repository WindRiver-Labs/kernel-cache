From 951a325a47fecdf774650dae6964d9fbe9af82eb Mon Sep 17 00:00:00 2001
From: Michal Simek <michal.simek@xilinx.com>
Date: Mon, 24 Aug 2015 15:25:29 +0200
Subject: [PATCH 292/793] memory/nand: pl353: Rename PL353 names to PL35X

PL353 -> PL35X
pl353 -> pl35x

Keep origin compatible string without any change.

Signed-off-by: Michal Simek <michal.simek@xilinx.com>
---
 drivers/memory/pl35x-smc.c    |  338 ++++++++++++++++++++--------------------
 drivers/mtd/nand/pl35x_nand.c |  300 ++++++++++++++++++------------------
 2 files changed, 319 insertions(+), 319 deletions(-)

diff --git a/drivers/memory/pl35x-smc.c b/drivers/memory/pl35x-smc.c
index 75154d0..c0fa7f4 100644
--- a/drivers/memory/pl35x-smc.c
+++ b/drivers/memory/pl35x-smc.c
@@ -1,5 +1,5 @@
 /*
- * ARM PL353 SMC Driver
+ * ARM PL35X SMC Driver
  *
  * Copyright (C) 2012 - 2014 Xilinx, Inc.
  *
@@ -26,99 +26,99 @@
 #include <linux/slab.h>
 
 /* Register definitions */
-#define PL353_SMC_MEMC_STATUS_OFFS	0	/* Controller status reg, RO */
-#define PL353_SMC_CFG_CLR_OFFS		0xC	/* Clear config reg, WO */
-#define PL353_SMC_DIRECT_CMD_OFFS	0x10	/* Direct command reg, WO */
-#define PL353_SMC_SET_CYCLES_OFFS	0x14	/* Set cycles register, WO */
-#define PL353_SMC_SET_OPMODE_OFFS	0x18	/* Set opmode register, WO */
-#define PL353_SMC_ECC_STATUS_OFFS	0x400	/* ECC status register */
-#define PL353_SMC_ECC_MEMCFG_OFFS	0x404	/* ECC mem config reg */
-#define PL353_SMC_ECC_MEMCMD1_OFFS	0x408	/* ECC mem cmd1 reg */
-#define PL353_SMC_ECC_MEMCMD2_OFFS	0x40C	/* ECC mem cmd2 reg */
-#define PL353_SMC_ECC_VALUE0_OFFS	0x418	/* ECC value 0 reg */
+#define PL35X_SMC_MEMC_STATUS_OFFS	0	/* Controller status reg, RO */
+#define PL35X_SMC_CFG_CLR_OFFS		0xC	/* Clear config reg, WO */
+#define PL35X_SMC_DIRECT_CMD_OFFS	0x10	/* Direct command reg, WO */
+#define PL35X_SMC_SET_CYCLES_OFFS	0x14	/* Set cycles register, WO */
+#define PL35X_SMC_SET_OPMODE_OFFS	0x18	/* Set opmode register, WO */
+#define PL35X_SMC_ECC_STATUS_OFFS	0x400	/* ECC status register */
+#define PL35X_SMC_ECC_MEMCFG_OFFS	0x404	/* ECC mem config reg */
+#define PL35X_SMC_ECC_MEMCMD1_OFFS	0x408	/* ECC mem cmd1 reg */
+#define PL35X_SMC_ECC_MEMCMD2_OFFS	0x40C	/* ECC mem cmd2 reg */
+#define PL35X_SMC_ECC_VALUE0_OFFS	0x418	/* ECC value 0 reg */
 
 /* Controller status register specifc constants */
-#define PL353_SMC_MEMC_STATUS_RAW_INT_1_SHIFT	6
+#define PL35X_SMC_MEMC_STATUS_RAW_INT_1_SHIFT	6
 
 /* Clear configuration register specific constants */
-#define PL353_SMC_CFG_CLR_INT_CLR_1	0x10
-#define PL353_SMC_CFG_CLR_ECC_INT_DIS_1	0x40
-#define PL353_SMC_CFG_CLR_INT_DIS_1	0x2
-#define PL353_SMC_CFG_CLR_DEFAULT_MASK	(PL353_SMC_CFG_CLR_INT_CLR_1 | \
-					 PL353_SMC_CFG_CLR_ECC_INT_DIS_1 | \
-					 PL353_SMC_CFG_CLR_INT_DIS_1)
+#define PL35X_SMC_CFG_CLR_INT_CLR_1	0x10
+#define PL35X_SMC_CFG_CLR_ECC_INT_DIS_1	0x40
+#define PL35X_SMC_CFG_CLR_INT_DIS_1	0x2
+#define PL35X_SMC_CFG_CLR_DEFAULT_MASK	(PL35X_SMC_CFG_CLR_INT_CLR_1 | \
+					 PL35X_SMC_CFG_CLR_ECC_INT_DIS_1 | \
+					 PL35X_SMC_CFG_CLR_INT_DIS_1)
 
 /* Set cycles register specific constants */
-#define PL353_SMC_SET_CYCLES_T0_MASK	0xF
-#define PL353_SMC_SET_CYCLES_T0_SHIFT	0
-#define PL353_SMC_SET_CYCLES_T1_MASK	0xF
-#define PL353_SMC_SET_CYCLES_T1_SHIFT	4
-#define PL353_SMC_SET_CYCLES_T2_MASK	0x7
-#define PL353_SMC_SET_CYCLES_T2_SHIFT	8
-#define PL353_SMC_SET_CYCLES_T3_MASK	0x7
-#define PL353_SMC_SET_CYCLES_T3_SHIFT	11
-#define PL353_SMC_SET_CYCLES_T4_MASK	0x7
-#define PL353_SMC_SET_CYCLES_T4_SHIFT	14
-#define PL353_SMC_SET_CYCLES_T5_MASK	0x7
-#define PL353_SMC_SET_CYCLES_T5_SHIFT	17
-#define PL353_SMC_SET_CYCLES_T6_MASK	0xF
-#define PL353_SMC_SET_CYCLES_T6_SHIFT	20
+#define PL35X_SMC_SET_CYCLES_T0_MASK	0xF
+#define PL35X_SMC_SET_CYCLES_T0_SHIFT	0
+#define PL35X_SMC_SET_CYCLES_T1_MASK	0xF
+#define PL35X_SMC_SET_CYCLES_T1_SHIFT	4
+#define PL35X_SMC_SET_CYCLES_T2_MASK	0x7
+#define PL35X_SMC_SET_CYCLES_T2_SHIFT	8
+#define PL35X_SMC_SET_CYCLES_T3_MASK	0x7
+#define PL35X_SMC_SET_CYCLES_T3_SHIFT	11
+#define PL35X_SMC_SET_CYCLES_T4_MASK	0x7
+#define PL35X_SMC_SET_CYCLES_T4_SHIFT	14
+#define PL35X_SMC_SET_CYCLES_T5_MASK	0x7
+#define PL35X_SMC_SET_CYCLES_T5_SHIFT	17
+#define PL35X_SMC_SET_CYCLES_T6_MASK	0xF
+#define PL35X_SMC_SET_CYCLES_T6_SHIFT	20
 
 /* ECC status register specific constants */
-#define PL353_SMC_ECC_STATUS_BUSY	(1 << 6)
+#define PL35X_SMC_ECC_STATUS_BUSY	(1 << 6)
 
 /* ECC memory config register specific constants */
-#define PL353_SMC_ECC_MEMCFG_MODE_MASK	0xC
-#define PL353_SMC_ECC_MEMCFG_MODE_SHIFT	2
-#define PL353_SMC_ECC_MEMCFG_PGSIZE_MASK	0xC
+#define PL35X_SMC_ECC_MEMCFG_MODE_MASK	0xC
+#define PL35X_SMC_ECC_MEMCFG_MODE_SHIFT	2
+#define PL35X_SMC_ECC_MEMCFG_PGSIZE_MASK	0xC
 
-#define PL353_SMC_DC_UPT_NAND_REGS	((4 << 23) |	/* CS: NAND chip */ \
+#define PL35X_SMC_DC_UPT_NAND_REGS	((4 << 23) |	/* CS: NAND chip */ \
 				 (2 << 21))	/* UpdateRegs operation */
 
-#define PL353_NAND_ECC_CMD1	((0x80)       |	/* Write command */ \
+#define PL35X_NAND_ECC_CMD1	((0x80)       |	/* Write command */ \
 				 (0 << 8)     |	/* Read command */ \
 				 (0x30 << 16) |	/* Read End command */ \
 				 (1 << 24))	/* Read End command calid */
 
-#define PL353_NAND_ECC_CMD2	((0x85)	      |	/* Write col change cmd */ \
+#define PL35X_NAND_ECC_CMD2	((0x85)	      |	/* Write col change cmd */ \
 				 (5 << 8)     |	/* Read col change cmd */ \
 				 (0xE0 << 16) |	/* Read col change end cmd */ \
 				 (1 << 24)) /* Read col change end cmd valid */
-#define PL353_NAND_ECC_BUSY_TIMEOUT	(1 * HZ)
+#define PL35X_NAND_ECC_BUSY_TIMEOUT	(1 * HZ)
 /**
- * struct pl353_smc_data - Private smc driver structure
+ * struct pl35x_smc_data - Private smc driver structure
  * @devclk:		Pointer to the peripheral clock
  * @aperclk:		Pointer to the APER clock
  */
-struct pl353_smc_data {
+struct pl35x_smc_data {
 	struct clk		*memclk;
 	struct clk		*aclk;
 };
 
 /* SMC virtual register base */
-static void __iomem *pl353_smc_base;
+static void __iomem *pl35x_smc_base;
 
 /**
- * pl353_smc_set_buswidth - Set memory buswidth
+ * pl35x_smc_set_buswidth - Set memory buswidth
  * @bw:	Memory buswidth (8 | 16)
  * Return: 0 on success or negative errno.
  */
-int pl353_smc_set_buswidth(unsigned int bw)
+int pl35x_smc_set_buswidth(unsigned int bw)
 {
 
-	if (bw != PL353_SMC_MEM_WIDTH_8  && bw != PL353_SMC_MEM_WIDTH_16)
+	if (bw != PL35X_SMC_MEM_WIDTH_8  && bw != PL35X_SMC_MEM_WIDTH_16)
 		return -EINVAL;
 
-	writel(bw, pl353_smc_base + PL353_SMC_SET_OPMODE_OFFS);
-	writel(PL353_SMC_DC_UPT_NAND_REGS, pl353_smc_base +
-	       PL353_SMC_DIRECT_CMD_OFFS);
+	writel(bw, pl35x_smc_base + PL35X_SMC_SET_OPMODE_OFFS);
+	writel(PL35X_SMC_DC_UPT_NAND_REGS, pl35x_smc_base +
+	       PL35X_SMC_DIRECT_CMD_OFFS);
 
 	return 0;
 }
-EXPORT_SYMBOL_GPL(pl353_smc_set_buswidth);
+EXPORT_SYMBOL_GPL(pl35x_smc_set_buswidth);
 
 /**
- * pl353_smc_set_cycles - Set memory timing parameters
+ * pl35x_smc_set_cycles - Set memory timing parameters
  * @t0:	t_rc		read cycle time
  * @t1:	t_wc		write cycle time
  * @t2:	t_rea/t_ceoe	output enable assertion delay
@@ -129,119 +129,119 @@ EXPORT_SYMBOL_GPL(pl353_smc_set_buswidth);
  *
  * Sets NAND chip specific timing parameters.
  */
-static void pl353_smc_set_cycles(u32 t0, u32 t1, u32 t2, u32 t3, u32
+static void pl35x_smc_set_cycles(u32 t0, u32 t1, u32 t2, u32 t3, u32
 			      t4, u32 t5, u32 t6)
 {
-	t0 &= PL353_SMC_SET_CYCLES_T0_MASK;
-	t1 = (t1 & PL353_SMC_SET_CYCLES_T1_MASK) <<
-			PL353_SMC_SET_CYCLES_T1_SHIFT;
-	t2 = (t2 & PL353_SMC_SET_CYCLES_T2_MASK) <<
-			PL353_SMC_SET_CYCLES_T2_SHIFT;
-	t3 = (t3 & PL353_SMC_SET_CYCLES_T3_MASK) <<
-			PL353_SMC_SET_CYCLES_T3_SHIFT;
-	t4 = (t4 & PL353_SMC_SET_CYCLES_T4_MASK) <<
-			PL353_SMC_SET_CYCLES_T4_SHIFT;
-	t5 = (t5 & PL353_SMC_SET_CYCLES_T5_MASK) <<
-			PL353_SMC_SET_CYCLES_T5_SHIFT;
-	t6 = (t6 & PL353_SMC_SET_CYCLES_T6_MASK) <<
-			PL353_SMC_SET_CYCLES_T6_SHIFT;
+	t0 &= PL35X_SMC_SET_CYCLES_T0_MASK;
+	t1 = (t1 & PL35X_SMC_SET_CYCLES_T1_MASK) <<
+			PL35X_SMC_SET_CYCLES_T1_SHIFT;
+	t2 = (t2 & PL35X_SMC_SET_CYCLES_T2_MASK) <<
+			PL35X_SMC_SET_CYCLES_T2_SHIFT;
+	t3 = (t3 & PL35X_SMC_SET_CYCLES_T3_MASK) <<
+			PL35X_SMC_SET_CYCLES_T3_SHIFT;
+	t4 = (t4 & PL35X_SMC_SET_CYCLES_T4_MASK) <<
+			PL35X_SMC_SET_CYCLES_T4_SHIFT;
+	t5 = (t5 & PL35X_SMC_SET_CYCLES_T5_MASK) <<
+			PL35X_SMC_SET_CYCLES_T5_SHIFT;
+	t6 = (t6 & PL35X_SMC_SET_CYCLES_T6_MASK) <<
+			PL35X_SMC_SET_CYCLES_T6_SHIFT;
 
 	t0 |= t1 | t2 | t3 | t4 | t5 | t6;
 
-	writel(t0, pl353_smc_base + PL353_SMC_SET_CYCLES_OFFS);
-	writel(PL353_SMC_DC_UPT_NAND_REGS, pl353_smc_base +
-	       PL353_SMC_DIRECT_CMD_OFFS);
+	writel(t0, pl35x_smc_base + PL35X_SMC_SET_CYCLES_OFFS);
+	writel(PL35X_SMC_DC_UPT_NAND_REGS, pl35x_smc_base +
+	       PL35X_SMC_DIRECT_CMD_OFFS);
 }
 
 /**
- * pl353_smc_ecc_is_busy_noirq - Read ecc busy flag
+ * pl35x_smc_ecc_is_busy_noirq - Read ecc busy flag
  * Return: the ecc_status bit from the ecc_status register. 1 = busy, 0 = idle
  */
-static int pl353_smc_ecc_is_busy_noirq(void)
+static int pl35x_smc_ecc_is_busy_noirq(void)
 {
-	return !!(readl(pl353_smc_base + PL353_SMC_ECC_STATUS_OFFS) &
-		  PL353_SMC_ECC_STATUS_BUSY);
+	return !!(readl(pl35x_smc_base + PL35X_SMC_ECC_STATUS_OFFS) &
+		  PL35X_SMC_ECC_STATUS_BUSY);
 }
 
 /**
- * pl353_smc_ecc_is_busy - Read ecc busy flag
+ * pl35x_smc_ecc_is_busy - Read ecc busy flag
  * Return: the ecc_status bit from the ecc_status register. 1 = busy, 0 = idle
  */
-int pl353_smc_ecc_is_busy(void)
+int pl35x_smc_ecc_is_busy(void)
 {
 	int ret;
 
-	ret = pl353_smc_ecc_is_busy_noirq();
+	ret = pl35x_smc_ecc_is_busy_noirq();
 
 	return ret;
 }
-EXPORT_SYMBOL_GPL(pl353_smc_ecc_is_busy);
+EXPORT_SYMBOL_GPL(pl35x_smc_ecc_is_busy);
 
 /**
- * pl353_smc_get_ecc_val - Read ecc_valueN registers
+ * pl35x_smc_get_ecc_val - Read ecc_valueN registers
  * @ecc_reg:	Index of the ecc_value reg (0..3)
  * Return: the content of the requested ecc_value register.
  *
  * There are four valid ecc_value registers. The argument is truncated to stay
  * within this valid boundary.
  */
-u32 pl353_smc_get_ecc_val(int ecc_reg)
+u32 pl35x_smc_get_ecc_val(int ecc_reg)
 {
 	u32 addr, reg;
 
 	ecc_reg &= 3;
-	addr = PL353_SMC_ECC_VALUE0_OFFS + (ecc_reg << 2);
-	reg = readl(pl353_smc_base + addr);
+	addr = PL35X_SMC_ECC_VALUE0_OFFS + (ecc_reg << 2);
+	reg = readl(pl35x_smc_base + addr);
 
 	return reg;
 }
-EXPORT_SYMBOL_GPL(pl353_smc_get_ecc_val);
+EXPORT_SYMBOL_GPL(pl35x_smc_get_ecc_val);
 
 /**
- * pl353_smc_get_nand_int_status_raw - Get NAND interrupt status bit
+ * pl35x_smc_get_nand_int_status_raw - Get NAND interrupt status bit
  * Return: the raw_int_status1 bit from the memc_status register
  */
-int pl353_smc_get_nand_int_status_raw(void)
+int pl35x_smc_get_nand_int_status_raw(void)
 {
 	u32 reg;
 
-	reg = readl(pl353_smc_base + PL353_SMC_MEMC_STATUS_OFFS);
-	reg >>= PL353_SMC_MEMC_STATUS_RAW_INT_1_SHIFT;
+	reg = readl(pl35x_smc_base + PL35X_SMC_MEMC_STATUS_OFFS);
+	reg >>= PL35X_SMC_MEMC_STATUS_RAW_INT_1_SHIFT;
 	reg &= 1;
 
 	return reg;
 }
-EXPORT_SYMBOL_GPL(pl353_smc_get_nand_int_status_raw);
+EXPORT_SYMBOL_GPL(pl35x_smc_get_nand_int_status_raw);
 
 /**
- * pl353_smc_clr_nand_int - Clear NAND interrupt
+ * pl35x_smc_clr_nand_int - Clear NAND interrupt
  */
-void pl353_smc_clr_nand_int(void)
+void pl35x_smc_clr_nand_int(void)
 {
-	writel(PL353_SMC_CFG_CLR_INT_CLR_1,
-		pl353_smc_base + PL353_SMC_CFG_CLR_OFFS);
+	writel(PL35X_SMC_CFG_CLR_INT_CLR_1,
+		pl35x_smc_base + PL35X_SMC_CFG_CLR_OFFS);
 }
-EXPORT_SYMBOL_GPL(pl353_smc_clr_nand_int);
+EXPORT_SYMBOL_GPL(pl35x_smc_clr_nand_int);
 
 /**
- * pl353_smc_set_ecc_mode - Set SMC ECC mode
+ * pl35x_smc_set_ecc_mode - Set SMC ECC mode
  * @mode:	ECC mode (BYPASS, APB, MEM)
  * Return: 0 on success or negative errno.
  */
-int pl353_smc_set_ecc_mode(enum pl353_smc_ecc_mode mode)
+int pl35x_smc_set_ecc_mode(enum pl35x_smc_ecc_mode mode)
 {
 	u32 reg;
 	int ret = 0;
 
 	switch (mode) {
-	case PL353_SMC_ECCMODE_BYPASS:
-	case PL353_SMC_ECCMODE_APB:
-	case PL353_SMC_ECCMODE_MEM:
+	case PL35X_SMC_ECCMODE_BYPASS:
+	case PL35X_SMC_ECCMODE_APB:
+	case PL35X_SMC_ECCMODE_MEM:
 
-		reg = readl(pl353_smc_base + PL353_SMC_ECC_MEMCFG_OFFS);
-		reg &= ~PL353_SMC_ECC_MEMCFG_MODE_MASK;
-		reg |= mode << PL353_SMC_ECC_MEMCFG_MODE_SHIFT;
-		writel(reg, pl353_smc_base + PL353_SMC_ECC_MEMCFG_OFFS);
+		reg = readl(pl35x_smc_base + PL35X_SMC_ECC_MEMCFG_OFFS);
+		reg &= ~PL35X_SMC_ECC_MEMCFG_MODE_MASK;
+		reg |= mode << PL35X_SMC_ECC_MEMCFG_MODE_SHIFT;
+		writel(reg, pl35x_smc_base + PL35X_SMC_ECC_MEMCFG_OFFS);
 
 		break;
 	default:
@@ -250,14 +250,14 @@ int pl353_smc_set_ecc_mode(enum pl353_smc_ecc_mode mode)
 
 	return ret;
 }
-EXPORT_SYMBOL_GPL(pl353_smc_set_ecc_mode);
+EXPORT_SYMBOL_GPL(pl35x_smc_set_ecc_mode);
 
 /**
- * pl353_smc_set_ecc_pg_size - Set SMC ECC page size
+ * pl35x_smc_set_ecc_pg_size - Set SMC ECC page size
  * @pg_sz:	ECC page size
  * Return: 0 on success or negative errno.
  */
-int pl353_smc_set_ecc_pg_size(unsigned int pg_sz)
+int pl35x_smc_set_ecc_pg_size(unsigned int pg_sz)
 {
 	u32 reg, sz;
 
@@ -278,59 +278,59 @@ int pl353_smc_set_ecc_pg_size(unsigned int pg_sz)
 		return -EINVAL;
 	}
 
-	reg = readl(pl353_smc_base + PL353_SMC_ECC_MEMCFG_OFFS);
-	reg &= ~PL353_SMC_ECC_MEMCFG_PGSIZE_MASK;
+	reg = readl(pl35x_smc_base + PL35X_SMC_ECC_MEMCFG_OFFS);
+	reg &= ~PL35X_SMC_ECC_MEMCFG_PGSIZE_MASK;
 	reg |= sz;
-	writel(reg, pl353_smc_base + PL353_SMC_ECC_MEMCFG_OFFS);
+	writel(reg, pl35x_smc_base + PL35X_SMC_ECC_MEMCFG_OFFS);
 
 	return 0;
 }
-EXPORT_SYMBOL_GPL(pl353_smc_set_ecc_pg_size);
+EXPORT_SYMBOL_GPL(pl35x_smc_set_ecc_pg_size);
 
-static int __maybe_unused pl353_smc_suspend(struct device *dev)
+static int __maybe_unused pl35x_smc_suspend(struct device *dev)
 {
-	struct pl353_smc_data *pl353_smc = dev_get_drvdata(dev);
+	struct pl35x_smc_data *pl35x_smc = dev_get_drvdata(dev);
 
-	clk_disable(pl353_smc->memclk);
-	clk_disable(pl353_smc->aclk);
+	clk_disable(pl35x_smc->memclk);
+	clk_disable(pl35x_smc->aclk);
 
 	return 0;
 }
 
-static int __maybe_unused pl353_smc_resume(struct device *dev)
+static int __maybe_unused pl35x_smc_resume(struct device *dev)
 {
 	int ret;
-	struct pl353_smc_data *pl353_smc = dev_get_drvdata(dev);
+	struct pl35x_smc_data *pl35x_smc = dev_get_drvdata(dev);
 
-	ret = clk_enable(pl353_smc->aclk);
+	ret = clk_enable(pl35x_smc->aclk);
 	if (ret) {
 		dev_err(dev, "Cannot enable axi domain clock.\n");
 		return ret;
 	}
 
-	ret = clk_enable(pl353_smc->memclk);
+	ret = clk_enable(pl35x_smc->memclk);
 	if (ret) {
 		dev_err(dev, "Cannot enable memory clock.\n");
-		clk_disable(pl353_smc->aclk);
+		clk_disable(pl35x_smc->aclk);
 		return ret;
 	}
 	return ret;
 }
 
-static SIMPLE_DEV_PM_OPS(pl353_smc_dev_pm_ops, pl353_smc_suspend,
-			 pl353_smc_resume);
+static SIMPLE_DEV_PM_OPS(pl35x_smc_dev_pm_ops, pl35x_smc_suspend,
+			 pl35x_smc_resume);
 
 /**
- * pl353_smc_init_nand_interface - Initialize the NAND interface
+ * pl35x_smc_init_nand_interface - Initialize the NAND interface
  * @pdev:	Pointer to the platform_device struct
- * @nand_node:	Pointer to the pl353_nand device_node struct
+ * @nand_node:	Pointer to the pl35x_nand device_node struct
  */
-static void pl353_smc_init_nand_interface(struct platform_device *pdev,
+static void pl35x_smc_init_nand_interface(struct platform_device *pdev,
 				       struct device_node *nand_node)
 {
 	u32 t_rc, t_wc, t_rea, t_wp, t_clr, t_ar, t_rr;
 	int err;
-	unsigned long timeout = jiffies + PL353_NAND_ECC_BUSY_TIMEOUT;
+	unsigned long timeout = jiffies + PL35X_NAND_ECC_BUSY_TIMEOUT;
 
 	/* nand-cycle-<X> property is refer to the NAND flash timing
 	 * mapping between dts and the NAND flash AC timing
@@ -392,7 +392,7 @@ default_nand_timing:
 		t_wp = t_clr = t_ar = 2;
 	}
 
-	pl353_smc_set_buswidth(PL353_SMC_MEM_WIDTH_8);
+	pl35x_smc_set_buswidth(PL35X_SMC_MEM_WIDTH_8);
 
 	/*
 	 * Default assume 50MHz clock (20ns cycle time) and 3V operation
@@ -400,14 +400,14 @@ default_nand_timing:
 	 * Look in to the device datasheet and change its value, This value
 	 * is for 2Gb Numonyx flash.
 	 */
-	pl353_smc_set_cycles(t_rc, t_wc, t_rea, t_wp, t_clr, t_ar, t_rr);
-	writel(PL353_SMC_CFG_CLR_INT_CLR_1,
-		pl353_smc_base + PL353_SMC_CFG_CLR_OFFS);
-	writel(PL353_SMC_DC_UPT_NAND_REGS, pl353_smc_base +
-	       PL353_SMC_DIRECT_CMD_OFFS);
+	pl35x_smc_set_cycles(t_rc, t_wc, t_rea, t_wp, t_clr, t_ar, t_rr);
+	writel(PL35X_SMC_CFG_CLR_INT_CLR_1,
+		pl35x_smc_base + PL35X_SMC_CFG_CLR_OFFS);
+	writel(PL35X_SMC_DC_UPT_NAND_REGS, pl35x_smc_base +
+	       PL35X_SMC_DIRECT_CMD_OFFS);
 	/* Wait till the ECC operation is complete */
 	do {
-		if (pl353_smc_ecc_is_busy_noirq())
+		if (pl35x_smc_ecc_is_busy_noirq())
 			cpu_relax();
 		else
 			break;
@@ -416,10 +416,10 @@ default_nand_timing:
 	if (time_after_eq(jiffies, timeout))
 		dev_err(&pdev->dev, "nand ecc busy status timed out");
 	/* Set the command1 and command2 register */
-	writel(PL353_NAND_ECC_CMD1,
-			pl353_smc_base + PL353_SMC_ECC_MEMCMD1_OFFS);
-	writel(PL353_NAND_ECC_CMD2,
-			pl353_smc_base + PL353_SMC_ECC_MEMCMD2_OFFS);
+	writel(PL35X_NAND_ECC_CMD1,
+			pl35x_smc_base + PL35X_SMC_ECC_MEMCMD1_OFFS);
+	writel(PL35X_NAND_ECC_CMD2,
+			pl35x_smc_base + PL35X_SMC_ECC_MEMCMD2_OFFS);
 }
 
 static const struct of_device_id matches_nor[] = {
@@ -428,63 +428,63 @@ static const struct of_device_id matches_nor[] = {
 };
 
 static const struct of_device_id matches_nand[] = {
-	{ .compatible = "arm,pl353-nand-r2p1" },
+	{ .compatible = "arm,pl35x-nand-r2p1" },
 	{}
 };
 
-static int pl353_smc_probe(struct platform_device *pdev)
+static int pl35x_smc_probe(struct platform_device *pdev)
 {
-	struct pl353_smc_data *pl353_smc;
+	struct pl35x_smc_data *pl35x_smc;
 	struct device_node *child;
 	struct resource *res;
 	int err;
 	struct device_node *of_node = pdev->dev.of_node;
 	const struct of_device_id *matches = NULL;
 
-	pl353_smc = devm_kzalloc(&pdev->dev, sizeof(*pl353_smc), GFP_KERNEL);
-	if (!pl353_smc)
+	pl35x_smc = devm_kzalloc(&pdev->dev, sizeof(*pl35x_smc), GFP_KERNEL);
+	if (!pl35x_smc)
 		return -ENOMEM;
 
 	/* Get the NAND controller virtual address */
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	pl353_smc_base = devm_ioremap_resource(&pdev->dev, res);
-	if (IS_ERR(pl353_smc_base))
-		return PTR_ERR(pl353_smc_base);
+	pl35x_smc_base = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(pl35x_smc_base))
+		return PTR_ERR(pl35x_smc_base);
 
-	pl353_smc->aclk = devm_clk_get(&pdev->dev, "aclk");
-	if (IS_ERR(pl353_smc->aclk)) {
+	pl35x_smc->aclk = devm_clk_get(&pdev->dev, "aclk");
+	if (IS_ERR(pl35x_smc->aclk)) {
 		dev_err(&pdev->dev, "aclk clock not found.\n");
-		return PTR_ERR(pl353_smc->aclk);
+		return PTR_ERR(pl35x_smc->aclk);
 	}
 
-	pl353_smc->memclk = devm_clk_get(&pdev->dev, "memclk");
-	if (IS_ERR(pl353_smc->memclk)) {
+	pl35x_smc->memclk = devm_clk_get(&pdev->dev, "memclk");
+	if (IS_ERR(pl35x_smc->memclk)) {
 		dev_err(&pdev->dev, "memclk clock not found.\n");
-		return PTR_ERR(pl353_smc->memclk);
+		return PTR_ERR(pl35x_smc->memclk);
 	}
 
-	err = clk_prepare_enable(pl353_smc->aclk);
+	err = clk_prepare_enable(pl35x_smc->aclk);
 	if (err) {
 		dev_err(&pdev->dev, "Unable to enable AXI clock.\n");
 		return err;
 	}
 
-	err = clk_prepare_enable(pl353_smc->memclk);
+	err = clk_prepare_enable(pl35x_smc->memclk);
 	if (err) {
 		dev_err(&pdev->dev, "Unable to enable memory clock.\n");
 		goto out_clk_dis_aper;
 	}
 
-	platform_set_drvdata(pdev, pl353_smc);
+	platform_set_drvdata(pdev, pl35x_smc);
 
 	/* clear interrupts */
-	writel(PL353_SMC_CFG_CLR_DEFAULT_MASK,
-		pl353_smc_base + PL353_SMC_CFG_CLR_OFFS);
+	writel(PL35X_SMC_CFG_CLR_DEFAULT_MASK,
+		pl35x_smc_base + PL35X_SMC_CFG_CLR_OFFS);
 
 	/* Find compatible children. Only a single child is supported */
 	for_each_available_child_of_node(of_node, child) {
 		if (of_match_node(matches_nand, child)) {
-			pl353_smc_init_nand_interface(pdev, child);
+			pl35x_smc_init_nand_interface(pdev, child);
 			if (!matches) {
 				matches = matches_nand;
 			} else {
@@ -515,42 +515,42 @@ static int pl353_smc_probe(struct platform_device *pdev)
 	return 0;
 
 out_clk_disable:
-	clk_disable_unprepare(pl353_smc->memclk);
+	clk_disable_unprepare(pl35x_smc->memclk);
 out_clk_dis_aper:
-	clk_disable_unprepare(pl353_smc->aclk);
+	clk_disable_unprepare(pl35x_smc->aclk);
 
 	return err;
 }
 
-static int pl353_smc_remove(struct platform_device *pdev)
+static int pl35x_smc_remove(struct platform_device *pdev)
 {
-	struct pl353_smc_data *pl353_smc = platform_get_drvdata(pdev);
+	struct pl35x_smc_data *pl35x_smc = platform_get_drvdata(pdev);
 
-	clk_disable_unprepare(pl353_smc->memclk);
-	clk_disable_unprepare(pl353_smc->aclk);
+	clk_disable_unprepare(pl35x_smc->memclk);
+	clk_disable_unprepare(pl35x_smc->aclk);
 
 	return 0;
 }
 
 /* Match table for device tree binding */
-static const struct of_device_id pl353_smc_of_match[] = {
+static const struct of_device_id pl35x_smc_of_match[] = {
 	{ .compatible = "arm,pl353-smc-r2p1" },
 	{ },
 };
-MODULE_DEVICE_TABLE(of, pl353_smc_of_match);
+MODULE_DEVICE_TABLE(of, pl35x_smc_of_match);
 
-static struct platform_driver pl353_smc_driver = {
-	.probe		= pl353_smc_probe,
-	.remove		= pl353_smc_remove,
+static struct platform_driver pl35x_smc_driver = {
+	.probe		= pl35x_smc_probe,
+	.remove		= pl35x_smc_remove,
 	.driver		= {
-		.name	= "pl353-smc",
-		.pm	= &pl353_smc_dev_pm_ops,
-		.of_match_table = pl353_smc_of_match,
+		.name	= "pl35x-smc",
+		.pm	= &pl35x_smc_dev_pm_ops,
+		.of_match_table = pl35x_smc_of_match,
 	},
 };
 
-module_platform_driver(pl353_smc_driver);
+module_platform_driver(pl35x_smc_driver);
 
 MODULE_AUTHOR("Xilinx, Inc.");
-MODULE_DESCRIPTION("ARM PL353 SMC Driver");
+MODULE_DESCRIPTION("ARM PL35X SMC Driver");
 MODULE_LICENSE("GPL");
diff --git a/drivers/mtd/nand/pl35x_nand.c b/drivers/mtd/nand/pl35x_nand.c
index f162976..406f1f0 100644
--- a/drivers/mtd/nand/pl35x_nand.c
+++ b/drivers/mtd/nand/pl35x_nand.c
@@ -1,5 +1,5 @@
 /*
- * ARM PL353 NAND Flash Controller Driver
+ * ARM PL35X NAND Flash Controller Driver
  *
  * Copyright (C) 2009 - 2014 Xilinx, Inc.
  *
@@ -30,16 +30,16 @@
 #include <linux/platform_device.h>
 #include <linux/slab.h>
 
-#define PL353_NAND_DRIVER_NAME "pl353-nand"
+#define PL35X_NAND_DRIVER_NAME "pl35x-nand"
 
 /* NAND flash driver defines */
-#define PL353_NAND_CMD_PHASE	1	/* End command valid in command phase */
-#define PL353_NAND_DATA_PHASE	2	/* End command valid in data phase */
-#define PL353_NAND_ECC_SIZE	512	/* Size of data for ECC operation */
+#define PL35X_NAND_CMD_PHASE	1	/* End command valid in command phase */
+#define PL35X_NAND_DATA_PHASE	2	/* End command valid in data phase */
+#define PL35X_NAND_ECC_SIZE	512	/* Size of data for ECC operation */
 
 /* Flash memory controller operating parameters */
 
-#define PL353_NAND_ECC_CONFIG	(BIT(4)  |	/* ECC read at end of page */ \
+#define PL35X_NAND_ECC_CONFIG	(BIT(4)  |	/* ECC read at end of page */ \
 				 (0 << 5))	/* No Jumping */
 
 /* AXI Address definitions */
@@ -52,28 +52,28 @@
 #define COMMAND_PHASE		(0 << 19)
 #define DATA_PHASE		BIT(19)
 
-#define PL353_NAND_ECC_LAST	BIT(ECC_LAST_SHIFT)	/* Set ECC_Last */
-#define PL353_NAND_CLEAR_CS	BIT(CLEAR_CS_SHIFT)	/* Clear chip select */
+#define PL35X_NAND_ECC_LAST	BIT(ECC_LAST_SHIFT)	/* Set ECC_Last */
+#define PL35X_NAND_CLEAR_CS	BIT(CLEAR_CS_SHIFT)	/* Clear chip select */
 
 #define ONDIE_ECC_FEATURE_ADDR	0x90
-#define PL353_NAND_ECC_BUSY_TIMEOUT	(1 * HZ)
-#define PL353_NAND_DEV_BUSY_TIMEOUT	(1 * HZ)
-#define PL353_NAND_LAST_TRANSFER_LENGTH	4
+#define PL35X_NAND_ECC_BUSY_TIMEOUT	(1 * HZ)
+#define PL35X_NAND_DEV_BUSY_TIMEOUT	(1 * HZ)
+#define PL35X_NAND_LAST_TRANSFER_LENGTH	4
 
 /* Inline function for the NAND controller register write */
-static inline void pl353_nand_write32(void __iomem *addr, u32 val)
+static inline void pl35x_nand_write32(void __iomem *addr, u32 val)
 {
 	writel_relaxed((val), (addr));
 }
 
 /**
- * struct pl353_nand_command_format - Defines NAND flash command format
+ * struct pl35x_nand_command_format - Defines NAND flash command format
  * @start_cmd:		First cycle command (Start command)
  * @end_cmd:		Second cycle command (Last command)
  * @addr_cycles:	Number of address cycles required to send the address
  * @end_cmd_valid:	The second cycle command is valid for cmd or data phase
  */
-struct pl353_nand_command_format {
+struct pl35x_nand_command_format {
 	int start_cmd;
 	int end_cmd;
 	u8 addr_cycles;
@@ -81,7 +81,7 @@ struct pl353_nand_command_format {
 };
 
 /**
- * struct pl353_nand_info - Defines the NAND flash driver instance
+ * struct pl35x_nand_info - Defines the NAND flash driver instance
  * @chip:		NAND chip information structure
  * @mtd:		MTD information structure
  * @parts:		Pointer to the mtd_partition structure
@@ -91,7 +91,7 @@ struct pl353_nand_command_format {
  * @row_addr_cycles:	Row address cycles
  * @col_addr_cycles:	Column address cycles
  */
-struct pl353_nand_info {
+struct pl35x_nand_info {
 	struct nand_chip chip;
 	struct mtd_info mtd;
 	struct mtd_partition *parts;
@@ -105,14 +105,14 @@ struct pl353_nand_info {
 /*
  * The NAND flash operations command format
  */
-static const struct pl353_nand_command_format pl353_nand_commands[] = {
-	{NAND_CMD_READ0, NAND_CMD_READSTART, 5, PL353_NAND_CMD_PHASE},
-	{NAND_CMD_RNDOUT, NAND_CMD_RNDOUTSTART, 2, PL353_NAND_CMD_PHASE},
+static const struct pl35x_nand_command_format pl35x_nand_commands[] = {
+	{NAND_CMD_READ0, NAND_CMD_READSTART, 5, PL35X_NAND_CMD_PHASE},
+	{NAND_CMD_RNDOUT, NAND_CMD_RNDOUTSTART, 2, PL35X_NAND_CMD_PHASE},
 	{NAND_CMD_READID, NAND_CMD_NONE, 1, NAND_CMD_NONE},
 	{NAND_CMD_STATUS, NAND_CMD_NONE, 0, NAND_CMD_NONE},
-	{NAND_CMD_SEQIN, NAND_CMD_PAGEPROG, 5, PL353_NAND_DATA_PHASE},
+	{NAND_CMD_SEQIN, NAND_CMD_PAGEPROG, 5, PL35X_NAND_DATA_PHASE},
 	{NAND_CMD_RNDIN, NAND_CMD_NONE, 2, NAND_CMD_NONE},
-	{NAND_CMD_ERASE1, NAND_CMD_ERASE2, 3, PL353_NAND_CMD_PHASE},
+	{NAND_CMD_ERASE1, NAND_CMD_ERASE2, 3, PL35X_NAND_CMD_PHASE},
 	{NAND_CMD_RESET, NAND_CMD_NONE, 0, NAND_CMD_NONE},
 	{NAND_CMD_PARAM, NAND_CMD_NONE, 1, NAND_CMD_NONE},
 	{NAND_CMD_GET_FEATURES, NAND_CMD_NONE, 1, NAND_CMD_NONE},
@@ -126,7 +126,7 @@ static const struct pl353_nand_command_format pl353_nand_commands[] = {
 	 * command, which doesn't fit in to the driver design. The cache program
 	 * command is not supported by NAND subsystem also, look at 1612 line
 	 * number (in nand_write_page function) of nand_base.c file.
-	 * {NAND_CMD_SEQIN, NAND_CMD_CACHEDPROG, 5, PL353_NAND_YES},
+	 * {NAND_CMD_SEQIN, NAND_CMD_CACHEDPROG, 5, PL35X_NAND_YES},
 	 */
 };
 
@@ -192,7 +192,7 @@ static struct nand_bbt_descr bbt_mirror_descr = {
 };
 
 /**
- * pl353_nand_calculate_hwecc - Calculate Hardware ECC
+ * pl35x_nand_calculate_hwecc - Calculate Hardware ECC
  * @mtd:	Pointer to the mtd_info structure
  * @data:	Pointer to the page data
  * @ecc_code:	Pointer to the ECC buffer where ECC data needs to be stored
@@ -202,16 +202,16 @@ static struct nand_bbt_descr bbt_mirror_descr = {
  *
  * Return:	0 on success or error value on failure
  */
-static int pl353_nand_calculate_hwecc(struct mtd_info *mtd,
+static int pl35x_nand_calculate_hwecc(struct mtd_info *mtd,
 				const u8 *data, u8 *ecc_code)
 {
 	u32 ecc_value, ecc_status;
 	u8 ecc_reg, ecc_byte;
-	unsigned long timeout = jiffies + PL353_NAND_ECC_BUSY_TIMEOUT;
+	unsigned long timeout = jiffies + PL35X_NAND_ECC_BUSY_TIMEOUT;
 
 	/* Wait till the ECC operation is complete or timeout */
 	do {
-		if (pl353_smc_ecc_is_busy())
+		if (pl35x_smc_ecc_is_busy())
 			cpu_relax();
 		else
 			break;
@@ -224,7 +224,7 @@ static int pl353_nand_calculate_hwecc(struct mtd_info *mtd,
 
 	for (ecc_reg = 0; ecc_reg < 4; ecc_reg++) {
 		/* Read ECC value for each block */
-		ecc_value = pl353_smc_get_ecc_val(ecc_reg);
+		ecc_value = pl35x_smc_get_ecc_val(ecc_reg);
 		ecc_status = (ecc_value >> 24) & 0xFF;
 		/* ECC value valid */
 		if (ecc_status & 0x40) {
@@ -257,7 +257,7 @@ static int onehot(unsigned short value)
 }
 
 /**
- * pl353_nand_correct_data - ECC correction function
+ * pl35x_nand_correct_data - ECC correction function
  * @mtd:	Pointer to the mtd_info structure
  * @buf:	Pointer to the page data
  * @read_ecc:	Pointer to the ECC value read from spare data area
@@ -269,7 +269,7 @@ static int onehot(unsigned short value)
  *		1 if single bit error found and corrected.
  *		-1 if multiple ECC errors found.
  */
-static int pl353_nand_correct_data(struct mtd_info *mtd, unsigned char *buf,
+static int pl35x_nand_correct_data(struct mtd_info *mtd, unsigned char *buf,
 				unsigned char *read_ecc,
 				unsigned char *calc_ecc)
 {
@@ -307,14 +307,14 @@ static int pl353_nand_correct_data(struct mtd_info *mtd, unsigned char *buf,
 }
 
 /**
- * pl353_nand_read_oob - [REPLACABLE] the most common OOB data read function
+ * pl35x_nand_read_oob - [REPLACABLE] the most common OOB data read function
  * @mtd:	Pointer to the mtd info structure
  * @chip:	Pointer to the NAND chip info structure
  * @page:	Page number to read
  *
  * Return:	Always return zero
  */
-static int pl353_nand_read_oob(struct mtd_info *mtd, struct nand_chip *chip,
+static int pl35x_nand_read_oob(struct mtd_info *mtd, struct nand_chip *chip,
 			    int page)
 {
 	unsigned long data_phase_addr;
@@ -324,26 +324,26 @@ static int pl353_nand_read_oob(struct mtd_info *mtd, struct nand_chip *chip,
 
 	p = chip->oob_poi;
 	chip->read_buf(mtd, p,
-			(mtd->oobsize - PL353_NAND_LAST_TRANSFER_LENGTH));
-	p += (mtd->oobsize - PL353_NAND_LAST_TRANSFER_LENGTH);
+			(mtd->oobsize - PL35X_NAND_LAST_TRANSFER_LENGTH));
+	p += (mtd->oobsize - PL35X_NAND_LAST_TRANSFER_LENGTH);
 
 	data_phase_addr = (unsigned long __force)chip->IO_ADDR_R;
-	data_phase_addr |= PL353_NAND_CLEAR_CS;
+	data_phase_addr |= PL35X_NAND_CLEAR_CS;
 	chip->IO_ADDR_R = (void __iomem * __force)data_phase_addr;
-	chip->read_buf(mtd, p, PL353_NAND_LAST_TRANSFER_LENGTH);
+	chip->read_buf(mtd, p, PL35X_NAND_LAST_TRANSFER_LENGTH);
 
 	return 0;
 }
 
 /**
- * pl353_nand_write_oob - [REPLACABLE] the most common OOB data write function
+ * pl35x_nand_write_oob - [REPLACABLE] the most common OOB data write function
  * @mtd:	Pointer to the mtd info structure
  * @chip:	Pointer to the NAND chip info structure
  * @page:	Page number to write
  *
  * Return:	Zero on success and EIO on failure
  */
-static int pl353_nand_write_oob(struct mtd_info *mtd, struct nand_chip *chip,
+static int pl35x_nand_write_oob(struct mtd_info *mtd, struct nand_chip *chip,
 			     int page)
 {
 	int status = 0;
@@ -353,14 +353,14 @@ static int pl353_nand_write_oob(struct mtd_info *mtd, struct nand_chip *chip,
 	chip->cmdfunc(mtd, NAND_CMD_SEQIN, mtd->writesize, page);
 
 	chip->write_buf(mtd, buf,
-			(mtd->oobsize - PL353_NAND_LAST_TRANSFER_LENGTH));
-	buf += (mtd->oobsize - PL353_NAND_LAST_TRANSFER_LENGTH);
+			(mtd->oobsize - PL35X_NAND_LAST_TRANSFER_LENGTH));
+	buf += (mtd->oobsize - PL35X_NAND_LAST_TRANSFER_LENGTH);
 
 	data_phase_addr = (unsigned long __force)chip->IO_ADDR_W;
-	data_phase_addr |= PL353_NAND_CLEAR_CS;
+	data_phase_addr |= PL35X_NAND_CLEAR_CS;
 	data_phase_addr |= (1 << END_CMD_VALID_SHIFT);
 	chip->IO_ADDR_W = (void __iomem * __force)data_phase_addr;
-	chip->write_buf(mtd, buf, PL353_NAND_LAST_TRANSFER_LENGTH);
+	chip->write_buf(mtd, buf, PL35X_NAND_LAST_TRANSFER_LENGTH);
 
 	/* Send command to program the OOB data */
 	chip->cmdfunc(mtd, NAND_CMD_PAGEPROG, -1, -1);
@@ -370,7 +370,7 @@ static int pl353_nand_write_oob(struct mtd_info *mtd, struct nand_chip *chip,
 }
 
 /**
- * pl353_nand_read_page_raw - [Intern] read raw page data without ecc
+ * pl35x_nand_read_page_raw - [Intern] read raw page data without ecc
  * @mtd:		Pointer to the mtd info structure
  * @chip:		Pointer to the NAND chip info structure
  * @buf:		Pointer to the data buffer
@@ -379,7 +379,7 @@ static int pl353_nand_write_oob(struct mtd_info *mtd, struct nand_chip *chip,
  *
  * Return:	Always return zero
  */
-static int pl353_nand_read_page_raw(struct mtd_info *mtd,
+static int pl35x_nand_read_page_raw(struct mtd_info *mtd,
 				struct nand_chip *chip,
 				uint8_t *buf, int oob_required, int page)
 {
@@ -390,19 +390,19 @@ static int pl353_nand_read_page_raw(struct mtd_info *mtd,
 
 	p = chip->oob_poi;
 	chip->read_buf(mtd, p,
-			(mtd->oobsize - PL353_NAND_LAST_TRANSFER_LENGTH));
-	p += (mtd->oobsize - PL353_NAND_LAST_TRANSFER_LENGTH);
+			(mtd->oobsize - PL35X_NAND_LAST_TRANSFER_LENGTH));
+	p += (mtd->oobsize - PL35X_NAND_LAST_TRANSFER_LENGTH);
 
 	data_phase_addr = (unsigned long __force)chip->IO_ADDR_R;
-	data_phase_addr |= PL353_NAND_CLEAR_CS;
+	data_phase_addr |= PL35X_NAND_CLEAR_CS;
 	chip->IO_ADDR_R = (void __iomem * __force)data_phase_addr;
 
-	chip->read_buf(mtd, p, PL353_NAND_LAST_TRANSFER_LENGTH);
+	chip->read_buf(mtd, p, PL35X_NAND_LAST_TRANSFER_LENGTH);
 	return 0;
 }
 
 /**
- * pl353_nand_write_page_raw - [Intern] raw page write function
+ * pl35x_nand_write_page_raw - [Intern] raw page write function
  * @mtd:		Pointer to the mtd info structure
  * @chip:		Pointer to the NAND chip info structure
  * @buf:		Pointer to the data buffer
@@ -410,7 +410,7 @@ static int pl353_nand_read_page_raw(struct mtd_info *mtd,
  *
  * Return:	Always return zero
  */
-static int pl353_nand_write_page_raw(struct mtd_info *mtd,
+static int pl35x_nand_write_page_raw(struct mtd_info *mtd,
 				    struct nand_chip *chip,
 				    const uint8_t *buf, int oob_required)
 {
@@ -421,15 +421,15 @@ static int pl353_nand_write_page_raw(struct mtd_info *mtd,
 
 	p = chip->oob_poi;
 	chip->write_buf(mtd, p,
-			(mtd->oobsize - PL353_NAND_LAST_TRANSFER_LENGTH));
-	p += (mtd->oobsize - PL353_NAND_LAST_TRANSFER_LENGTH);
+			(mtd->oobsize - PL35X_NAND_LAST_TRANSFER_LENGTH));
+	p += (mtd->oobsize - PL35X_NAND_LAST_TRANSFER_LENGTH);
 
 	data_phase_addr = (unsigned long __force)chip->IO_ADDR_W;
-	data_phase_addr |= PL353_NAND_CLEAR_CS;
+	data_phase_addr |= PL35X_NAND_CLEAR_CS;
 	data_phase_addr |= (1 << END_CMD_VALID_SHIFT);
 	chip->IO_ADDR_W = (void __iomem * __force)data_phase_addr;
 
-	chip->write_buf(mtd, p, PL353_NAND_LAST_TRANSFER_LENGTH);
+	chip->write_buf(mtd, p, PL35X_NAND_LAST_TRANSFER_LENGTH);
 
 	return 0;
 }
@@ -445,7 +445,7 @@ static int pl353_nand_write_page_raw(struct mtd_info *mtd,
  *
  * Return:	Always return zero
  */
-static int pl353_nand_write_page_hwecc(struct mtd_info *mtd,
+static int pl35x_nand_write_page_hwecc(struct mtd_info *mtd,
 				    struct nand_chip *chip, const uint8_t *buf,
 				    int oob_required)
 {
@@ -461,14 +461,14 @@ static int pl353_nand_write_page_hwecc(struct mtd_info *mtd,
 		chip->write_buf(mtd, p, eccsize);
 		p += eccsize;
 	}
-	chip->write_buf(mtd, p, (eccsize - PL353_NAND_LAST_TRANSFER_LENGTH));
-	p += (eccsize - PL353_NAND_LAST_TRANSFER_LENGTH);
+	chip->write_buf(mtd, p, (eccsize - PL35X_NAND_LAST_TRANSFER_LENGTH));
+	p += (eccsize - PL35X_NAND_LAST_TRANSFER_LENGTH);
 
 	/* Set ECC Last bit to 1 */
 	data_phase_addr = (unsigned long __force)chip->IO_ADDR_W;
-	data_phase_addr |= PL353_NAND_ECC_LAST;
+	data_phase_addr |= PL35X_NAND_ECC_LAST;
 	chip->IO_ADDR_W = (void __iomem * __force)data_phase_addr;
-	chip->write_buf(mtd, p, PL353_NAND_LAST_TRANSFER_LENGTH);
+	chip->write_buf(mtd, p, PL35X_NAND_LAST_TRANSFER_LENGTH);
 
 	/* Wait for ECC to be calculated and read the error values */
 	p = buf;
@@ -479,26 +479,26 @@ static int pl353_nand_write_page_hwecc(struct mtd_info *mtd,
 
 	/* Clear ECC last bit */
 	data_phase_addr = (unsigned long __force)chip->IO_ADDR_W;
-	data_phase_addr &= ~PL353_NAND_ECC_LAST;
+	data_phase_addr &= ~PL35X_NAND_ECC_LAST;
 	chip->IO_ADDR_W = (void __iomem * __force)data_phase_addr;
 
 	/* Write the spare area with ECC bytes */
 	oob_ptr = chip->oob_poi;
 	chip->write_buf(mtd, oob_ptr,
-			(mtd->oobsize - PL353_NAND_LAST_TRANSFER_LENGTH));
+			(mtd->oobsize - PL35X_NAND_LAST_TRANSFER_LENGTH));
 
 	data_phase_addr = (unsigned long __force)chip->IO_ADDR_W;
-	data_phase_addr |= PL353_NAND_CLEAR_CS;
+	data_phase_addr |= PL35X_NAND_CLEAR_CS;
 	data_phase_addr |= (1 << END_CMD_VALID_SHIFT);
 	chip->IO_ADDR_W = (void __iomem * __force)data_phase_addr;
-	oob_ptr += (mtd->oobsize - PL353_NAND_LAST_TRANSFER_LENGTH);
-	chip->write_buf(mtd, oob_ptr, PL353_NAND_LAST_TRANSFER_LENGTH);
+	oob_ptr += (mtd->oobsize - PL35X_NAND_LAST_TRANSFER_LENGTH);
+	chip->write_buf(mtd, oob_ptr, PL35X_NAND_LAST_TRANSFER_LENGTH);
 
 	return 0;
 }
 
 /**
- * pl353_nand_write_page_swecc - [REPLACABLE] software ecc based page write function
+ * pl35x_nand_write_page_swecc - [REPLACABLE] software ecc based page write function
  * @mtd:		Pointer to the mtd info structure
  * @chip:		Pointer to the NAND chip info structure
  * @buf:		Pointer to the data buffer
@@ -506,7 +506,7 @@ static int pl353_nand_write_page_hwecc(struct mtd_info *mtd,
  *
  * Return:	Always return zero
  */
-static int pl353_nand_write_page_swecc(struct mtd_info *mtd,
+static int pl35x_nand_write_page_swecc(struct mtd_info *mtd,
 				    struct nand_chip *chip, const uint8_t *buf,
 				    int oob_required)
 {
@@ -530,7 +530,7 @@ static int pl353_nand_write_page_swecc(struct mtd_info *mtd,
 }
 
 /**
- * pl353_nand_read_page_hwecc - Hardware ECC based page read function
+ * pl35x_nand_read_page_hwecc - Hardware ECC based page read function
  * @mtd:		Pointer to the mtd info structure
  * @chip:		Pointer to the NAND chip info structure
  * @buf:		Pointer to the buffer to store read data
@@ -542,7 +542,7 @@ static int pl353_nand_write_page_swecc(struct mtd_info *mtd,
  *
  * Return:	0 always and updates ECC operation status in to MTD structure
  */
-static int pl353_nand_read_page_hwecc(struct mtd_info *mtd,
+static int pl35x_nand_read_page_hwecc(struct mtd_info *mtd,
 				     struct nand_chip *chip,
 				     uint8_t *buf, int oob_required, int page)
 {
@@ -560,14 +560,14 @@ static int pl353_nand_read_page_hwecc(struct mtd_info *mtd,
 		chip->read_buf(mtd, p, eccsize);
 		p += eccsize;
 	}
-	chip->read_buf(mtd, p, (eccsize - PL353_NAND_LAST_TRANSFER_LENGTH));
-	p += (eccsize - PL353_NAND_LAST_TRANSFER_LENGTH);
+	chip->read_buf(mtd, p, (eccsize - PL35X_NAND_LAST_TRANSFER_LENGTH));
+	p += (eccsize - PL35X_NAND_LAST_TRANSFER_LENGTH);
 
 	/* Set ECC Last bit to 1 */
 	data_phase_addr = (unsigned long __force)chip->IO_ADDR_R;
-	data_phase_addr |= PL353_NAND_ECC_LAST;
+	data_phase_addr |= PL35X_NAND_ECC_LAST;
 	chip->IO_ADDR_R = (void __iomem * __force)data_phase_addr;
-	chip->read_buf(mtd, p, PL353_NAND_LAST_TRANSFER_LENGTH);
+	chip->read_buf(mtd, p, PL35X_NAND_LAST_TRANSFER_LENGTH);
 
 	/* Read the calculated ECC value */
 	p = buf;
@@ -575,21 +575,21 @@ static int pl353_nand_read_page_hwecc(struct mtd_info *mtd,
 
 	/* Clear ECC last bit */
 	data_phase_addr = (unsigned long __force)chip->IO_ADDR_R;
-	data_phase_addr &= ~PL353_NAND_ECC_LAST;
+	data_phase_addr &= ~PL35X_NAND_ECC_LAST;
 	chip->IO_ADDR_R = (void __iomem * __force)data_phase_addr;
 
 	/* Read the stored ECC value */
 	oob_ptr = chip->oob_poi;
 	chip->read_buf(mtd, oob_ptr,
-			(mtd->oobsize - PL353_NAND_LAST_TRANSFER_LENGTH));
+			(mtd->oobsize - PL35X_NAND_LAST_TRANSFER_LENGTH));
 
 	/* de-assert chip select */
 	data_phase_addr = (unsigned long __force)chip->IO_ADDR_R;
-	data_phase_addr |= PL353_NAND_CLEAR_CS;
+	data_phase_addr |= PL35X_NAND_CLEAR_CS;
 	chip->IO_ADDR_R = (void __iomem * __force)data_phase_addr;
 
-	oob_ptr += (mtd->oobsize - PL353_NAND_LAST_TRANSFER_LENGTH);
-	chip->read_buf(mtd, oob_ptr, PL353_NAND_LAST_TRANSFER_LENGTH);
+	oob_ptr += (mtd->oobsize - PL35X_NAND_LAST_TRANSFER_LENGTH);
+	chip->read_buf(mtd, oob_ptr, PL35X_NAND_LAST_TRANSFER_LENGTH);
 
 	for (i = 0; i < chip->ecc.total; i++)
 		ecc_code[i] = ~(chip->oob_poi[eccpos[i]]);
@@ -609,7 +609,7 @@ static int pl353_nand_read_page_hwecc(struct mtd_info *mtd,
 }
 
 /**
- * pl353_nand_read_page_swecc - [REPLACABLE] software ecc based page read function
+ * pl35x_nand_read_page_swecc - [REPLACABLE] software ecc based page read function
  * @mtd:		Pointer to the mtd info structure
  * @chip:		Pointer to the NAND chip info structure
  * @buf:		Pointer to the buffer to store read data
@@ -618,7 +618,7 @@ static int pl353_nand_read_page_hwecc(struct mtd_info *mtd,
  *
  * Return:	Always return zero
  */
-static int pl353_nand_read_page_swecc(struct mtd_info *mtd,
+static int pl35x_nand_read_page_swecc(struct mtd_info *mtd,
 				     struct nand_chip *chip,
 				     uint8_t *buf,  int oob_required, int page)
 {
@@ -654,36 +654,36 @@ static int pl353_nand_read_page_swecc(struct mtd_info *mtd,
 }
 
 /**
- * pl353_nand_select_chip - Select the flash device
+ * pl35x_nand_select_chip - Select the flash device
  * @mtd:	Pointer to the mtd info structure
  * @chip:	Pointer to the NAND chip info structure
  *
  * This function is empty as the NAND controller handles chip select line
  * internally based on the chip address passed in command and data phase.
  */
-static void pl353_nand_select_chip(struct mtd_info *mtd, int chip)
+static void pl35x_nand_select_chip(struct mtd_info *mtd, int chip)
 {
 	return;
 }
 
 /**
- * pl353_nand_cmd_function - Send command to NAND device
+ * pl35x_nand_cmd_function - Send command to NAND device
  * @mtd:	Pointer to the mtd_info structure
  * @command:	The command to be sent to the flash device
  * @column:	The column address for this command, -1 if none
  * @page_addr:	The page address for this command, -1 if none
  */
-static void pl353_nand_cmd_function(struct mtd_info *mtd, unsigned int command,
+static void pl35x_nand_cmd_function(struct mtd_info *mtd, unsigned int command,
 				 int column, int page_addr)
 {
 	struct nand_chip *chip = mtd->priv;
-	const struct pl353_nand_command_format *curr_cmd = NULL;
-	struct pl353_nand_info *xnand =
-		container_of(mtd, struct pl353_nand_info, mtd);
+	const struct pl35x_nand_command_format *curr_cmd = NULL;
+	struct pl35x_nand_info *xnand =
+		container_of(mtd, struct pl35x_nand_info, mtd);
 	void __iomem *cmd_addr;
 	unsigned long cmd_data = 0, end_cmd_valid = 0;
 	unsigned long cmd_phase_addr, data_phase_addr, end_cmd, i;
-	unsigned long timeout = jiffies + PL353_NAND_DEV_BUSY_TIMEOUT;
+	unsigned long timeout = jiffies + PL35X_NAND_DEV_BUSY_TIMEOUT;
 	u32 addrcycles;
 
 	if (xnand->end_cmd_pending) {
@@ -699,26 +699,26 @@ static void pl353_nand_cmd_function(struct mtd_info *mtd, unsigned int command,
 	}
 
 	/* Emulate NAND_CMD_READOOB for large page device */
-	if ((mtd->writesize > PL353_NAND_ECC_SIZE) &&
+	if ((mtd->writesize > PL35X_NAND_ECC_SIZE) &&
 	    (command == NAND_CMD_READOOB)) {
 		column += mtd->writesize;
 		command = NAND_CMD_READ0;
 	}
 
 	/* Get the command format */
-	for (i = 0; (pl353_nand_commands[i].start_cmd != NAND_CMD_NONE ||
-		     pl353_nand_commands[i].end_cmd != NAND_CMD_NONE); i++)
-		if (command == pl353_nand_commands[i].start_cmd)
-			curr_cmd = &pl353_nand_commands[i];
+	for (i = 0; (pl35x_nand_commands[i].start_cmd != NAND_CMD_NONE ||
+		     pl35x_nand_commands[i].end_cmd != NAND_CMD_NONE); i++)
+		if (command == pl35x_nand_commands[i].start_cmd)
+			curr_cmd = &pl35x_nand_commands[i];
 
 	if (curr_cmd == NULL)
 		return;
 
 	/* Clear interrupt */
-	pl353_smc_clr_nand_int();
+	pl35x_smc_clr_nand_int();
 
 	/* Get the command phase address */
-	if (curr_cmd->end_cmd_valid == PL353_NAND_CMD_PHASE)
+	if (curr_cmd->end_cmd_valid == PL35X_NAND_CMD_PHASE)
 		end_cmd_valid = 1;
 
 	if (curr_cmd->end_cmd == NAND_CMD_NONE)
@@ -762,11 +762,11 @@ static void pl353_nand_cmd_function(struct mtd_info *mtd, unsigned int command,
 		if (chip->options & NAND_BUSWIDTH_16)
 			column >>= 1;
 		cmd_data = column;
-		if (mtd->writesize > PL353_NAND_ECC_SIZE) {
+		if (mtd->writesize > PL35X_NAND_ECC_SIZE) {
 			cmd_data |= page_addr << 16;
 			/* Another address cycle for devices > 128MiB */
 			if (chip->chipsize > (128 << 20)) {
-				pl353_nand_write32(cmd_addr, cmd_data);
+				pl35x_nand_write32(cmd_addr, cmd_data);
 				cmd_data = (page_addr >> 16);
 			}
 		} else {
@@ -789,7 +789,7 @@ static void pl353_nand_cmd_function(struct mtd_info *mtd, unsigned int command,
 		cmd_data = column;
 	}
 
-	pl353_nand_write32(cmd_addr, cmd_data);
+	pl35x_nand_write32(cmd_addr, cmd_data);
 
 	if (curr_cmd->end_cmd_valid) {
 		xnand->end_cmd = curr_cmd->end_cmd;
@@ -818,12 +818,12 @@ static void pl353_nand_cmd_function(struct mtd_info *mtd, unsigned int command,
 }
 
 /**
- * pl353_nand_read_buf - read chip data into buffer
+ * pl35x_nand_read_buf - read chip data into buffer
  * @mtd:	Pointer to the mtd info structure
  * @buf:	Pointer to the buffer to store read data
  * @len:	Number of bytes to read
  */
-static void pl353_nand_read_buf(struct mtd_info *mtd, uint8_t *buf, int len)
+static void pl35x_nand_read_buf(struct mtd_info *mtd, uint8_t *buf, int len)
 {
 	int i;
 	struct nand_chip *chip = mtd->priv;
@@ -835,12 +835,12 @@ static void pl353_nand_read_buf(struct mtd_info *mtd, uint8_t *buf, int len)
 }
 
 /**
- * pl353_nand_write_buf - write buffer to chip
+ * pl35x_nand_write_buf - write buffer to chip
  * @mtd:	Pointer to the mtd info structure
  * @buf:	Pointer to the buffer to store read data
  * @len:	Number of bytes to write
  */
-static void pl353_nand_write_buf(struct mtd_info *mtd, const uint8_t *buf,
+static void pl35x_nand_write_buf(struct mtd_info *mtd, const uint8_t *buf,
 				int len)
 {
 	int i;
@@ -854,29 +854,29 @@ static void pl353_nand_write_buf(struct mtd_info *mtd, const uint8_t *buf,
 }
 
 /**
- * pl353_nand_device_ready - Check device ready/busy line
+ * pl35x_nand_device_ready - Check device ready/busy line
  * @mtd:	Pointer to the mtd_info structure
  *
  * Return:	0 on busy or 1 on ready state
  */
-static int pl353_nand_device_ready(struct mtd_info *mtd)
+static int pl35x_nand_device_ready(struct mtd_info *mtd)
 {
-	if (pl353_smc_get_nand_int_status_raw()) {
-		pl353_smc_clr_nand_int();
+	if (pl35x_smc_get_nand_int_status_raw()) {
+		pl35x_smc_clr_nand_int();
 		return 1;
 	}
 	return 0;
 }
 
 /**
- * pl353_nand_detect_ondie_ecc - Get the flash ondie ecc state
+ * pl35x_nand_detect_ondie_ecc - Get the flash ondie ecc state
  * @mtd:	Pointer to the mtd_info structure
  *
  * This function enables the ondie ecc for the Micron ondie ecc capable devices
  *
  * Return:	1 on detect, 0 if fail to detect
  */
-static int pl353_nand_detect_ondie_ecc(struct mtd_info *mtd)
+static int pl35x_nand_detect_ondie_ecc(struct mtd_info *mtd)
 {
 	struct nand_chip *nand_chip = mtd->priv;
 	u8 maf_id, dev_id, i, get_feature;
@@ -928,27 +928,27 @@ static int pl353_nand_detect_ondie_ecc(struct mtd_info *mtd)
 }
 
 /**
- * pl353_nand_ecc_init - Initialize the ecc information as per the ecc mode
+ * pl35x_nand_ecc_init - Initialize the ecc information as per the ecc mode
  * @mtd:	Pointer to the mtd_info structure
  * @ondie_ecc_state:	ondie ecc status
  *
  * This function initializes the ecc block and functional pointers as per the
  * ecc mode
  */
-static void pl353_nand_ecc_init(struct mtd_info *mtd, int ondie_ecc_state)
+static void pl35x_nand_ecc_init(struct mtd_info *mtd, int ondie_ecc_state)
 {
 	struct nand_chip *nand_chip = mtd->priv;
 
 	nand_chip->ecc.mode = NAND_ECC_HW;
-	nand_chip->ecc.read_oob = pl353_nand_read_oob;
-	nand_chip->ecc.read_page_raw = pl353_nand_read_page_raw;
+	nand_chip->ecc.read_oob = pl35x_nand_read_oob;
+	nand_chip->ecc.read_page_raw = pl35x_nand_read_page_raw;
 	nand_chip->ecc.strength = 1;
-	nand_chip->ecc.write_oob = pl353_nand_write_oob;
-	nand_chip->ecc.write_page_raw = pl353_nand_write_page_raw;
+	nand_chip->ecc.write_oob = pl35x_nand_write_oob;
+	nand_chip->ecc.write_page_raw = pl35x_nand_write_page_raw;
 
 	if (ondie_ecc_state) {
 		/* bypass the controller ECC block */
-		pl353_smc_set_ecc_mode(PL353_SMC_ECCMODE_BYPASS);
+		pl35x_smc_set_ecc_mode(PL35X_SMC_ECCMODE_BYPASS);
 
 		/*
 		 * The software ECC routines won't work with the
@@ -956,8 +956,8 @@ static void pl353_nand_ecc_init(struct mtd_info *mtd, int ondie_ecc_state)
 		 */
 		nand_chip->ecc.bytes = 0;
 		nand_chip->ecc.layout = &ondie_nand_oob_64;
-		nand_chip->ecc.read_page = pl353_nand_read_page_raw;
-		nand_chip->ecc.write_page = pl353_nand_write_page_raw;
+		nand_chip->ecc.read_page = pl35x_nand_read_page_raw;
+		nand_chip->ecc.write_page = pl35x_nand_write_page_raw;
 		nand_chip->ecc.size = mtd->writesize;
 		/*
 		 * On-Die ECC spare bytes offset 8 is used for ECC codes
@@ -968,19 +968,19 @@ static void pl353_nand_ecc_init(struct mtd_info *mtd, int ondie_ecc_state)
 	} else {
 		/* Hardware ECC generates 3 bytes ECC code for each 512 bytes */
 		nand_chip->ecc.bytes = 3;
-		nand_chip->ecc.calculate = pl353_nand_calculate_hwecc;
-		nand_chip->ecc.correct = pl353_nand_correct_data;
+		nand_chip->ecc.calculate = pl35x_nand_calculate_hwecc;
+		nand_chip->ecc.correct = pl35x_nand_correct_data;
 		nand_chip->ecc.hwctl = NULL;
-		nand_chip->ecc.read_page = pl353_nand_read_page_hwecc;
-		nand_chip->ecc.size = PL353_NAND_ECC_SIZE;
-		nand_chip->ecc.write_page = pl353_nand_write_page_hwecc;
+		nand_chip->ecc.read_page = pl35x_nand_read_page_hwecc;
+		nand_chip->ecc.size = PL35X_NAND_ECC_SIZE;
+		nand_chip->ecc.write_page = pl35x_nand_write_page_hwecc;
 
-		pl353_smc_set_ecc_pg_size(mtd->writesize);
+		pl35x_smc_set_ecc_pg_size(mtd->writesize);
 		switch (mtd->writesize) {
 		case 512:
 		case 1024:
 		case 2048:
-			pl353_smc_set_ecc_mode(PL353_SMC_ECCMODE_APB);
+			pl35x_smc_set_ecc_mode(PL35X_SMC_ECCMODE_APB);
 			break;
 		default:
 			/*
@@ -989,8 +989,8 @@ static void pl353_nand_ecc_init(struct mtd_info *mtd, int ondie_ecc_state)
 			 */
 			nand_chip->ecc.calculate = nand_calculate_ecc;
 			nand_chip->ecc.correct = nand_correct_data;
-			nand_chip->ecc.read_page = pl353_nand_read_page_swecc;
-			nand_chip->ecc.write_page = pl353_nand_write_page_swecc;
+			nand_chip->ecc.read_page = pl35x_nand_read_page_swecc;
+			nand_chip->ecc.write_page = pl35x_nand_write_page_swecc;
 			nand_chip->ecc.size = 256;
 			break;
 		}
@@ -1003,16 +1003,16 @@ static void pl353_nand_ecc_init(struct mtd_info *mtd, int ondie_ecc_state)
 }
 
 /**
- * pl353_nand_probe - Probe method for the NAND driver
+ * pl35x_nand_probe - Probe method for the NAND driver
  * @pdev:	Pointer to the platform_device structure
  *
  * This function initializes the driver data structures and the hardware.
  *
  * Return:	0 on success or error value on failure
  */
-static int pl353_nand_probe(struct platform_device *pdev)
+static int pl35x_nand_probe(struct platform_device *pdev)
 {
-	struct pl353_nand_info *xnand;
+	struct pl35x_nand_info *xnand;
 	struct mtd_info *mtd;
 	struct nand_chip *nand_chip;
 	struct resource *res;
@@ -1036,23 +1036,23 @@ static int pl353_nand_probe(struct platform_device *pdev)
 	nand_chip->priv = xnand;
 	mtd->priv = nand_chip;
 	mtd->owner = THIS_MODULE;
-	mtd->name = PL353_NAND_DRIVER_NAME;
+	mtd->name = PL35X_NAND_DRIVER_NAME;
 
 	/* Set address of NAND IO lines */
 	nand_chip->IO_ADDR_R = xnand->nand_base;
 	nand_chip->IO_ADDR_W = xnand->nand_base;
 
 	/* Set the driver entry points for MTD */
-	nand_chip->cmdfunc = pl353_nand_cmd_function;
-	nand_chip->dev_ready = pl353_nand_device_ready;
-	nand_chip->select_chip = pl353_nand_select_chip;
+	nand_chip->cmdfunc = pl35x_nand_cmd_function;
+	nand_chip->dev_ready = pl35x_nand_device_ready;
+	nand_chip->select_chip = pl35x_nand_select_chip;
 
 	/* If we don't set this delay driver sets 20us by default */
 	nand_chip->chip_delay = 30;
 
 	/* Buffer read/write routines */
-	nand_chip->read_buf = pl353_nand_read_buf;
-	nand_chip->write_buf = pl353_nand_write_buf;
+	nand_chip->read_buf = pl35x_nand_read_buf;
+	nand_chip->write_buf = pl35x_nand_write_buf;
 
 	/* Set the device option and flash width */
 	nand_chip->options = NAND_BUSWIDTH_AUTO;
@@ -1060,7 +1060,7 @@ static int pl353_nand_probe(struct platform_device *pdev)
 
 	platform_set_drvdata(pdev, xnand);
 
-	ondie_ecc_state = pl353_nand_detect_ondie_ecc(mtd);
+	ondie_ecc_state = pl35x_nand_detect_ondie_ecc(mtd);
 
 	/* first scan to find the device and get the page size */
 	if (nand_scan_ident(mtd, 1, NULL)) {
@@ -1072,9 +1072,9 @@ static int pl353_nand_probe(struct platform_device *pdev)
 	xnand->col_addr_cycles =
 				(nand_chip->onfi_params.addr_cycles >> 4) & 0xF;
 
-	pl353_nand_ecc_init(mtd, ondie_ecc_state);
+	pl35x_nand_ecc_init(mtd, ondie_ecc_state);
 	if (nand_chip->options & NAND_BUSWIDTH_16)
-		pl353_smc_set_buswidth(PL353_SMC_MEM_WIDTH_16);
+		pl35x_smc_set_buswidth(PL35X_SMC_MEM_WIDTH_16);
 
 	/* second phase scan */
 	if (nand_scan_tail(mtd)) {
@@ -1090,7 +1090,7 @@ static int pl353_nand_probe(struct platform_device *pdev)
 }
 
 /**
- * pl353_nand_remove - Remove method for the NAND driver
+ * pl35x_nand_remove - Remove method for the NAND driver
  * @pdev:	Pointer to the platform_device structure
  *
  * This function is called if the driver module is being unloaded. It frees all
@@ -1098,9 +1098,9 @@ static int pl353_nand_probe(struct platform_device *pdev)
  *
  * Return:	0 on success or error value on failure
  */
-static int pl353_nand_remove(struct platform_device *pdev)
+static int pl35x_nand_remove(struct platform_device *pdev)
 {
-	struct pl353_nand_info *xnand = platform_get_drvdata(pdev);
+	struct pl35x_nand_info *xnand = platform_get_drvdata(pdev);
 
 	/* Release resources, unregister device */
 	nand_release(&xnand->mtd);
@@ -1111,28 +1111,28 @@ static int pl353_nand_remove(struct platform_device *pdev)
 }
 
 /* Match table for device tree binding */
-static const struct of_device_id pl353_nand_of_match[] = {
+static const struct of_device_id pl35x_nand_of_match[] = {
 	{ .compatible = "arm,pl353-nand-r2p1" },
 	{},
 };
-MODULE_DEVICE_TABLE(of, pl353_nand_of_match);
+MODULE_DEVICE_TABLE(of, pl35x_nand_of_match);
 
 /*
- * pl353_nand_driver - This structure defines the NAND subsystem platform driver
+ * pl35x_nand_driver - This structure defines the NAND subsystem platform driver
  */
-static struct platform_driver pl353_nand_driver = {
-	.probe		= pl353_nand_probe,
-	.remove		= pl353_nand_remove,
+static struct platform_driver pl35x_nand_driver = {
+	.probe		= pl35x_nand_probe,
+	.remove		= pl35x_nand_remove,
 	.driver		= {
-		.name	= PL353_NAND_DRIVER_NAME,
+		.name	= PL35X_NAND_DRIVER_NAME,
 		.owner	= THIS_MODULE,
-		.of_match_table = pl353_nand_of_match,
+		.of_match_table = pl35x_nand_of_match,
 	},
 };
 
-module_platform_driver(pl353_nand_driver);
+module_platform_driver(pl35x_nand_driver);
 
 MODULE_AUTHOR("Xilinx, Inc.");
-MODULE_ALIAS("platform:" PL353_NAND_DRIVER_NAME);
-MODULE_DESCRIPTION("ARM PL353 NAND Flash Driver");
+MODULE_ALIAS("platform:" PL35X_NAND_DRIVER_NAME);
+MODULE_DESCRIPTION("ARM PL35X NAND Flash Driver");
 MODULE_LICENSE("GPL");
-- 
1.7.5.4

