From 401639395d6920e217ad84da1ac40b3d0f7882c3 Mon Sep 17 00:00:00 2001
From: Zhong Hongbo <hongbo.zhong@windriver.com>
Date: Fri, 20 Jul 2012 09:45:31 +0800
Subject: [PATCH 01/36] arm/zynq: Add the base platform file support

SDK: yocto-1.2(http://git.yoctoproject.org/cgit.cgi/meta-zynq/)

Supports Xilinx ZC702 board, SMP, uart, and No HOTPLUG_CPU support

Signed-off-by: Vlad Lungu <vlad.lungu@windriver.com>
Integrated-by: Hongbo Zhong <hongbo.zhong@windriver.com>
---
 arch/arm/Kconfig                           |   11 ++-
 arch/arm/Makefile                          |    1 -
 arch/arm/boot/dts/zc702.dtsi               |   40 +++++++++
 arch/arm/boot/dts/zynq-zc702-sd.dts        |   17 ++++
 arch/arm/mach-zynq/Kconfig                 |   68 ++++++++++++++
 arch/arm/mach-zynq/Makefile                |    4 +-
 arch/arm/mach-zynq/clock.c                 |   74 ++++++++++++++++
 arch/arm/mach-zynq/common.c                |   61 ++++++++++---
 arch/arm/mach-zynq/common.h                |    1 +
 arch/arm/mach-zynq/include/mach/clkdev.h   |    2 +-
 arch/arm/mach-zynq/include/mach/clock.h    |   15 ++++
 arch/arm/mach-zynq/include/mach/zynq_soc.h |   33 +++++--
 arch/arm/mach-zynq/platsmp.c               |  133 ++++++++++++++++++++++++++++
 13 files changed, 435 insertions(+), 25 deletions(-)
 create mode 100644 arch/arm/boot/dts/zc702.dtsi
 create mode 100644 arch/arm/boot/dts/zynq-zc702-sd.dts
 create mode 100644 arch/arm/mach-zynq/Kconfig
 create mode 100644 arch/arm/mach-zynq/clock.c
 create mode 100644 arch/arm/mach-zynq/include/mach/clock.h
 create mode 100644 arch/arm/mach-zynq/platsmp.c

diff --git a/arch/arm/Kconfig b/arch/arm/Kconfig
index d9fb576..239b811 100644
--- a/arch/arm/Kconfig
+++ b/arch/arm/Kconfig
@@ -1007,11 +1007,14 @@ config ARCH_VT8500
 config ARCH_ZYNQ
 	bool "Xilinx Zynq ARM Cortex A9 Platform"
 	select CPU_V7
+	select HAVE_SMP
 	select GENERIC_CLOCKEVENTS
 	select CLKDEV_LOOKUP
 	select ARM_GIC
 	select ARM_AMBA
 	select ICST
+	select GENERIC_TIME
+	select CACHE_L2X0
 	select MIGHT_HAVE_CACHE_L2X0
 	select USE_OF
 	help
@@ -1135,6 +1138,10 @@ source "arch/arm/mach-vt8500/Kconfig"
 
 source "arch/arm/mach-w90x900/Kconfig"
 
+if ARCH_ZYNQ
+source "arch/arm/mach-zynq/Kconfig"
+endif
+
 # Definitions to make life easier
 config ARCH_ACORN
 	bool
@@ -1605,7 +1612,7 @@ config NR_CPUS
 
 config HOTPLUG_CPU
 	bool "Support for hot-pluggable CPUs (EXPERIMENTAL)"
-	depends on SMP && HOTPLUG && EXPERIMENTAL
+	depends on SMP && HOTPLUG && EXPERIMENTAL && !ARCH_ZYNQ
 	help
 	  Say Y here to experiment with turning CPUs off and on.  CPUs
 	  can be controlled through /sys/devices/system/cpu.
@@ -2296,7 +2303,7 @@ menu "Power management options"
 source "kernel/power/Kconfig"
 
 config ARCH_SUSPEND_POSSIBLE
-	depends on !ARCH_S5PC100
+	depends on !ARCH_S5PC100 && !ARCH_ZYNQ
 	depends on CPU_ARM920T || CPU_ARM926T || CPU_SA1100 || \
 		CPU_V6 || CPU_V6K || CPU_V7 || CPU_XSC3 || CPU_XSCALE
 	def_bool y
diff --git a/arch/arm/Makefile b/arch/arm/Makefile
index 98b8e0f..8635db8 100644
--- a/arch/arm/Makefile
+++ b/arch/arm/Makefile
@@ -205,7 +205,6 @@ machine-$(CONFIG_ARCH_ZYNQ)		:= zynq
 plat-$(CONFIG_ARCH_MXC)		:= mxc
 plat-$(CONFIG_ARCH_OMAP)	:= omap
 plat-$(CONFIG_ARCH_S3C64XX)	:= samsung
-plat-$(CONFIG_ARCH_ZYNQ)	:= versatile
 plat-$(CONFIG_PLAT_IOP)		:= iop
 plat-$(CONFIG_PLAT_NOMADIK)	:= nomadik
 plat-$(CONFIG_PLAT_ORION)	:= orion
diff --git a/arch/arm/boot/dts/zc702.dtsi b/arch/arm/boot/dts/zc702.dtsi
new file mode 100644
index 0000000..6ee7802
--- /dev/null
+++ b/arch/arm/boot/dts/zc702.dtsi
@@ -0,0 +1,40 @@
+
+	memory {
+		device_type = "memory";
+		reg = <0x0 0x40000000>;
+	};
+
+	amba@0 {
+		compatible = "simple-bus";
+		#address-cells = <0x1>;
+		#size-cells = <0x1>;
+		ranges;
+
+		intc: intc@f8f01000 {
+			interrupt-controller;
+			compatible = "arm,gic";
+			reg = <0xf8f01000 0x1000>,<0xf8f00100 0x0100>;
+			#interrupt-cells = <0x3>;
+			#address-cells = <1>;
+
+			linux,phandle = <0x1>;
+			phandle = <0x1>;
+		};
+
+		uart@e0001000 {
+			compatible = "xlnx,xuartps";
+			reg = <0xe0001000 0x1000>;
+			interrupts = <0 50 0x04>;
+			clock = <0x2faf080>;
+		};
+
+		pl310@f8f02000 {
+			compatible = "arm,pl310-cache";
+			cache-unified;
+			cache-level = <2>;
+			reg = <0xf8f02000 0x1000>;
+			arm,data-latency = <3 2 2>;
+			arm,tag-latency = <3 2 2>;
+			interrupts = <0 34 4>;
+		};
+	};
diff --git a/arch/arm/boot/dts/zynq-zc702-sd.dts b/arch/arm/boot/dts/zynq-zc702-sd.dts
new file mode 100644
index 0000000..8208852
--- /dev/null
+++ b/arch/arm/boot/dts/zynq-zc702-sd.dts
@@ -0,0 +1,17 @@
+/dts-v1/;
+
+/ {
+	model = "Xilinx ZC702";
+	compatible = "xlnx,zynq-zc702";
+	#address-cells = <0x1>;
+	#size-cells = <0x1>;
+	interrupt-parent = <&intc>;
+
+/*root on SD second partition*/
+	chosen {
+		bootargs = "console=ttyPS0,115200 earlyprintk root=/dev/mmcblk0p2 ro rootwait";
+		linux,stdout-path = "/amba@0/uart@E0001000";
+	};
+
+/include/ "zc702.dtsi"
+};
diff --git a/arch/arm/mach-zynq/Kconfig b/arch/arm/mach-zynq/Kconfig
new file mode 100644
index 0000000..6769828
--- /dev/null
+++ b/arch/arm/mach-zynq/Kconfig
@@ -0,0 +1,68 @@
+if ARCH_ZYNQ
+
+menu "Xilinx Specific Options"
+config ZYNQ_EARLY_UART1
+	bool "Early Printk On UART1 (2nd UART)"
+	default n
+	help
+	  Select if you want to use the 2nd UART (UART1) in Zynq for the early
+	  printk. If not selected, the 1st UART (UART0) is used.
+
+config XILINX_L1_PREFETCH
+	bool "L1 Cache Prefetch"
+	default y
+	help
+	  This option turns on L1 cache prefetching to get the best performance
+	  in many cases. This may not always be the best performance depending on
+	  the usage. There are some cases where this may cause issues when booting.
+
+config XILINX_L2_PREFETCH
+	bool "L2 Cache Prefetch"
+	default y
+	help
+	  This option turns on L2 cache prefetching to get the best performance
+	  in many cases. This may not always be the best performance depending on
+	  the usage.
+
+config XILINX_TEST
+	bool "Testing On Kernel Boot"
+	default n
+	help
+	  Select if you want kernel tests to run on boot.  The tests may take
+	  several minutes on kernel boot.
+
+choice
+        prompt "Xilinx CPU AMP Kernels"
+	default ZXILINX_DEFAULT_KERNEL
+
+config ZYNQ_DEFAULT_KERNEL
+	bool "Run the kernel as normal"
+	help
+	  Select if you want a normal kernel.
+
+config ZYNQ_AMP_CPU0_MASTER
+	bool "Run the Kernel For AMP on CPU0"
+	help
+	  Select if you want to run the kernel on CPU0 while also running
+	  another kernel on CPU1 as a slave with respect to interrupt management.
+	  This causes the kernel to push the 2nd set of device interrupts
+	  to CPU1 so that it has it's own system.
+
+config ZYNQ_AMP_CPU1_SLAVE
+	bool "Run the Kernel For AMP on CPU1"
+	help
+	  Select if you want to run the kernel on CPU1 while also running
+	  another kernel on CPU0 as a master with respect to interrupt management.
+	  This causes the kernel to not touch the GIC distributor when it initializes
+	  as CPU0 takes care of it.
+
+config ZYNQ_CPU1_TEST
+	bool "Run the Kernel On CPU1 For Testing"
+	help
+	  Select if you want to run the kernel on CPU1 without running a kernel on
+	  CPU0 which is really only useful for testing purposes.  The really only
+	  causes interrupts in the GIC to be on CPU1 rather than CPU0.
+
+endchoice
+endmenu
+endif
diff --git a/arch/arm/mach-zynq/Makefile b/arch/arm/mach-zynq/Makefile
index 397268c..7d13a03 100644
--- a/arch/arm/mach-zynq/Makefile
+++ b/arch/arm/mach-zynq/Makefile
@@ -3,4 +3,6 @@
 #
 
 # Common support
-obj-y				:= common.o timer.o
+obj-y:= common.o timer.o clock.o
+
+obj-$(CONFIG_SMP) += platsmp.o
diff --git a/arch/arm/mach-zynq/clock.c b/arch/arm/mach-zynq/clock.c
new file mode 100644
index 0000000..03910cd
--- /dev/null
+++ b/arch/arm/mach-zynq/clock.c
@@ -0,0 +1,74 @@
+/*
+ *  base on linux/arch/arm/plat-versatile/clock.c
+ *
+ *  Copyright (C) 2004 ARM Limited.
+ *  Written by Deep Blue Solutions Limited.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/clk.h>
+#include <linux/mutex.h>
+
+#include <asm/hardware/icst.h>
+
+#include <mach/clkdev.h>
+
+int clk_enable(struct clk *clk)
+{
+	return 0;
+}
+EXPORT_SYMBOL(clk_enable);
+
+void clk_disable(struct clk *clk)
+{
+}
+EXPORT_SYMBOL(clk_disable);
+
+unsigned long clk_get_rate(struct clk *clk)
+{
+	return clk->rate;
+}
+EXPORT_SYMBOL(clk_get_rate);
+
+long clk_round_rate(struct clk *clk, unsigned long rate)
+{
+	long ret = -EIO;
+	if (clk->ops && clk->ops->round)
+		ret = clk->ops->round(clk, rate);
+	return ret;
+}
+EXPORT_SYMBOL(clk_round_rate);
+
+int clk_set_rate(struct clk *clk, unsigned long rate)
+{
+	int ret = -EIO;
+	if (clk->ops && clk->ops->set)
+		ret = clk->ops->set(clk, rate);
+	return ret;
+}
+EXPORT_SYMBOL(clk_set_rate);
+
+long icst_clk_round(struct clk *clk, unsigned long rate)
+{
+	struct icst_vco vco;
+	vco = icst_hz_to_vco(clk->params, rate);
+	return icst_hz(clk->params, vco);
+}
+EXPORT_SYMBOL(icst_clk_round);
+
+int icst_clk_set(struct clk *clk, unsigned long rate)
+{
+	struct icst_vco vco;
+
+	vco = icst_hz_to_vco(clk->params, rate);
+	clk->rate = icst_hz(clk->params, vco);
+	clk->ops->setvco(clk, vco);
+
+	return 0;
+}
+EXPORT_SYMBOL(icst_clk_set);
diff --git a/arch/arm/mach-zynq/common.c b/arch/arm/mach-zynq/common.c
index ab5cfdd..eb9088d 100644
--- a/arch/arm/mach-zynq/common.c
+++ b/arch/arm/mach-zynq/common.c
@@ -22,6 +22,7 @@
 #include <linux/of_irq.h>
 #include <linux/of_platform.h>
 #include <linux/of.h>
+#include <linux/memblock.h>
 
 #include <asm/mach/arch.h>
 #include <asm/mach/map.h>
@@ -45,14 +46,19 @@ static struct of_device_id zynq_of_bus_ids[] __initdata = {
  */
 static void __init xilinx_init_machine(void)
 {
+	of_platform_populate(NULL, zynq_of_bus_ids, NULL, NULL);
+
 #ifdef CONFIG_CACHE_L2X0
 	/*
-	 * 64KB way size, 8-way associativity, parity disabled
+	 * 64KB way size, 8-way associativity, parity disabled,
+	 * prefetching option.
 	 */
-	l2x0_init(PL310_L2CC_BASE, 0x02060000, 0xF0F0FFFF);
+#ifndef CONFIG_XILINX_L2_PREFETCH
+	l2x0_of_init(0x02060000, 0xF0F0FFFF);
+#else
+	l2x0_of_init(0x72060000, 0xF0F0FFFF);
+#endif
 #endif
-
-	of_platform_bus_probe(NULL, zynq_of_bus_ids, NULL);
 }
 
 /**
@@ -78,22 +84,30 @@ static struct map_desc io_desc[] __initdata = {
 		.pfn		= __phys_to_pfn(SCU_PERIPH_PHYS),
 		.length		= SZ_8K,
 		.type		= MT_DEVICE,
-	}, {
-		.virtual	= PL310_L2CC_VIRT,
-		.pfn		= __phys_to_pfn(PL310_L2CC_PHYS),
-		.length		= SZ_4K,
-		.type		= MT_DEVICE,
 	},
-
 #ifdef CONFIG_DEBUG_LL
 	{
-		.virtual	= UART0_VIRT,
-		.pfn		= __phys_to_pfn(UART0_PHYS),
+		.virtual	= LL_UART_VADDR,
+		.pfn		= __phys_to_pfn(LL_UART_PADDR),
 		.length		= SZ_4K,
 		.type		= MT_DEVICE,
 	},
 #endif
-
+	/* create a mapping for the OCM  (256K) leaving a hole for the
+	 * interrupt vectors which are handled in the kernel
+	 */
+	{
+		.virtual	= OCM_LOW_VIRT,
+		.pfn		= __phys_to_pfn(OCM_LOW_PHYS),
+		.length		= (192 * SZ_1K),
+		.type		= MT_DEVICE_CACHED,
+	},
+	{
+		.virtual	= OCM_HIGH_VIRT,
+		.pfn		= __phys_to_pfn(OCM_HIGH_PHYS),
+		.length		= (60 * SZ_1K),
+		.type		= MT_DEVICE,
+	},
 };
 
 /**
@@ -104,8 +118,28 @@ static void __init xilinx_map_io(void)
 	iotable_init(io_desc, ARRAY_SIZE(io_desc));
 }
 
+/**
+ * xilinx_memory_init() - Initialize special memory
+ *
+ * We need to stop things allocating the low memory as DMA can't work in
+ * the 1st 512K of memory.  Using reserve vs remove is not totally clear yet.
+ */
+static void __init xilinx_memory_init(void)
+{
+	/* Reserve the 0-0x4000 addresses (before page tables and kernel)
+	 * which can't be used for DMA
+	 */
+	memblock_reserve(0, 0x4000);
+
+	/* the video frame buffer is in DDR and shouldn't be used by the kernel
+	 * as it will be ioremapped by the frame buffer driver
+	 */
+	memblock_remove(0xF000000, 0x1000000);
+}
+
 static const char *xilinx_dt_match[] = {
 	"xlnx,zynq-ep107",
+	"xlnx,zynq-zc702",
 	NULL
 };
 
@@ -116,4 +150,5 @@ MACHINE_START(XILINX_EP107, "Xilinx Zynq Platform")
 	.init_machine	= xilinx_init_machine,
 	.timer		= &xttcpss_sys_timer,
 	.dt_compat	= xilinx_dt_match,
+	.reserve        = xilinx_memory_init,
 MACHINE_END
diff --git a/arch/arm/mach-zynq/common.h b/arch/arm/mach-zynq/common.h
index a009644..1220617 100644
--- a/arch/arm/mach-zynq/common.h
+++ b/arch/arm/mach-zynq/common.h
@@ -19,6 +19,7 @@
 
 #include <asm/mach/time.h>
 
+void secondary_startup(void);
 extern struct sys_timer xttcpss_sys_timer;
 
 #endif
diff --git a/arch/arm/mach-zynq/include/mach/clkdev.h b/arch/arm/mach-zynq/include/mach/clkdev.h
index c6e73d8..1a0c9ae 100644
--- a/arch/arm/mach-zynq/include/mach/clkdev.h
+++ b/arch/arm/mach-zynq/include/mach/clkdev.h
@@ -17,7 +17,7 @@
 #ifndef __MACH_CLKDEV_H__
 #define __MACH_CLKDEV_H__
 
-#include <plat/clock.h>
+#include <mach/clock.h>
 
 struct clk {
 	unsigned long		rate;
diff --git a/arch/arm/mach-zynq/include/mach/clock.h b/arch/arm/mach-zynq/include/mach/clock.h
new file mode 100644
index 0000000..f3eb576
--- /dev/null
+++ b/arch/arm/mach-zynq/include/mach/clock.h
@@ -0,0 +1,15 @@
+#ifndef MACH_CLOCK_H
+#define MACH_CLOCK_H
+
+#include <asm/hardware/icst.h>
+
+struct clk_ops {
+	long	(*round)(struct clk *, unsigned long);
+	int	(*set)(struct clk *, unsigned long);
+	void	(*setvco)(struct clk *, struct icst_vco);
+};
+
+int icst_clk_set(struct clk *, unsigned long);
+long icst_clk_round(struct clk *, unsigned long);
+
+#endif
diff --git a/arch/arm/mach-zynq/include/mach/zynq_soc.h b/arch/arm/mach-zynq/include/mach/zynq_soc.h
index d0d3f8f..75e9064 100644
--- a/arch/arm/mach-zynq/include/mach/zynq_soc.h
+++ b/arch/arm/mach-zynq/include/mach/zynq_soc.h
@@ -15,21 +15,24 @@
 #ifndef __MACH_XILINX_SOC_H__
 #define __MACH_XILINX_SOC_H__
 
+#define ZYNQ_ADDR_BASE	0xFE000000
+#define ZYNQ_ADDR(x)	(ZYNQ_ADDR_BASE + (x))
+
 #define PERIPHERAL_CLOCK_RATE		2500000
 
 /* For now, all mappings are flat (physical = virtual)
  */
 #define UART0_PHYS			0xE0000000
-#define UART0_VIRT			UART0_PHYS
+#define UART0_VIRT			ZYNQ_ADDR(0x0)
 
-#define TTC0_PHYS			0xF8001000
-#define TTC0_VIRT			TTC0_PHYS
+#define UART1_PHYS			0xE0001000
+#define UART1_VIRT			ZYNQ_ADDR(0x1000)
 
-#define PL310_L2CC_PHYS			0xF8F02000
-#define PL310_L2CC_VIRT			PL310_L2CC_PHYS
+#define TTC0_PHYS			0xF8001000
+#define TTC0_VIRT			ZYNQ_ADDR(0x2000)
 
 #define SCU_PERIPH_PHYS			0xF8F00000
-#define SCU_PERIPH_VIRT			SCU_PERIPH_PHYS
+#define SCU_PERIPH_VIRT			ZYNQ_ADDR(0x3000)
 
 /* The following are intended for the devices that are mapped early */
 
@@ -37,12 +40,28 @@
 #define SCU_PERIPH_BASE			IOMEM(SCU_PERIPH_VIRT)
 #define SCU_GIC_CPU_BASE		(SCU_PERIPH_BASE + 0x100)
 #define SCU_GIC_DIST_BASE		(SCU_PERIPH_BASE + 0x1000)
-#define PL310_L2CC_BASE			IOMEM(PL310_L2CC_VIRT)
 
+#define BOOT_ADDR_OFFSET		0xEFF0
+#define BOOT_STATUS_OFFSET		0xEFF4
+#define BOOT_STATUS_CPU1_UP		1
+
+#define OCM_LOW_PHYS			0xFFFC0000
+#define OCM_LOW_VIRT			ZYNQ_ADDR(0x6000)
+
+#define OCM_HIGH_PHYS			0xFFFF1000
+#define OCM_HIGH_VIRT			ZYNQ_ADDR(0x36000)
+
+#define OCM_LOW_BASE			IOMEM(OCM_LOW_VIRT)
+#define OCM_HIGH_BASE			IOMEM(OCM_HIGH_VIRT)
 /*
  * Mandatory for CONFIG_LL_DEBUG, UART is mapped virtual = physical
  */
+#ifdef CONFIG_ZYNQ_EARLY_UART1
+#define LL_UART_PADDR	UART1_PHYS
+#define LL_UART_VADDR	UART1_VIRT
+#else
 #define LL_UART_PADDR	UART0_PHYS
 #define LL_UART_VADDR	UART0_VIRT
+#endif
 
 #endif
diff --git a/arch/arm/mach-zynq/platsmp.c b/arch/arm/mach-zynq/platsmp.c
new file mode 100644
index 0000000..e0b63c3
--- /dev/null
+++ b/arch/arm/mach-zynq/platsmp.c
@@ -0,0 +1,133 @@
+/*
+ * This file contains Xilinx specific SMP code, used to start up
+ * the second processor.
+ *
+ * Copyright (C) 2011 Xilinx
+ *
+ * based on linux/arch/arm/mach-realview/platsmp.c
+ *
+ * Copyright (C) 2002 ARM Ltd.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#include <linux/init.h>
+#include <linux/errno.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/jiffies.h>
+#include <linux/io.h>
+#include <linux/smp.h>
+
+#include <asm/cacheflush.h>
+#include <asm/smp_scu.h>
+#include <asm/smp_plat.h>
+#include <asm/hardware/gic.h>
+#include <mach/zynq_soc.h>
+#include "common.h"
+
+static DEFINE_SPINLOCK(boot_lock);
+
+void __cpuinit platform_secondary_init(unsigned int cpu)
+{
+	/*
+	 * if any interrupts are already enabled for the primary
+	 * core (e.g. timer irq), then they will not have been enabled
+	 * for us: do so
+	 */
+	gic_secondary_init(0);
+
+	/*
+	 * let the primary processor know we're out of the
+	 * pen, then head off into the C entry point
+	 */
+	__raw_writel(BOOT_STATUS_CPU1_UP, OCM_HIGH_BASE + BOOT_STATUS_OFFSET);
+	wmb();
+
+	/*
+	 * Synchronise with the boot thread.
+	 */
+	spin_lock(&boot_lock);
+	spin_unlock(&boot_lock);
+}
+
+int __cpuinit boot_secondary(unsigned int cpu, struct task_struct *idle)
+{
+	unsigned long timeout;
+
+	/*
+	 * Set synchronisation state between this boot processor
+	 * and the secondary one
+	 */
+	spin_lock(&boot_lock);
+
+	/*
+	 * This is really belt and braces; we hold unintended secondary
+	 * CPUs in the holding pen until we're ready for them.  However,
+	 * since we haven't sent them a soft interrupt, they shouldn't
+	 * be there.
+	 */
+	__raw_writel(0, OCM_HIGH_BASE + BOOT_STATUS_OFFSET);
+
+	__raw_writel(virt_to_phys(secondary_startup),
+					OCM_HIGH_BASE + BOOT_ADDR_OFFSET);
+	wmb();
+
+	/*
+	 * Send an event to wake the secondary core from WFE state.
+	 */
+	sev();
+
+	/*
+	 * Wait for the other CPU to boot, but timeout if it doesn't
+	 */
+	timeout = jiffies + (1 * HZ);
+	while ((__raw_readl(OCM_HIGH_BASE + BOOT_STATUS_OFFSET) !=
+				BOOT_STATUS_CPU1_UP) &&
+				(time_before(jiffies, timeout)))
+		rmb();
+
+	/*
+	 * now the secondary core is starting up let it run its
+	 * calibrations, then wait for it to finish
+	 */
+	spin_unlock(&boot_lock);
+
+	return 0;
+}
+
+/*
+ * Initialise the CPU possible map early - this describes the CPUs
+ * which may be present or become present in the system.
+ */
+void __init smp_init_cpus(void)
+{
+	int i, ncores;
+
+	ncores = scu_get_core_count(SCU_PERIPH_BASE);
+
+	for (i = 0; i < ncores; i++)
+		set_cpu_possible(i, true);
+
+	set_smp_cross_call(gic_raise_softirq);
+}
+
+void __init platform_smp_prepare_cpus(unsigned int max_cpus)
+{
+	int i;
+
+	/*
+	 * Initialise the present map, which describes the set of CPUs
+	 * actually populated at the present time.
+	 */
+	for (i = 0; i < max_cpus; i++)
+		set_cpu_present(i, true);
+
+	scu_enable(SCU_PERIPH_BASE);
+}
-- 
1.7.9.7

