From 7af0dde3d4aeaefdc06cb1cfaf3dfa63dd640e43 Mon Sep 17 00:00:00 2001
From: Hyun Kwon <hyunk@xilinx.com>
Date: Wed, 2 Oct 2013 15:46:52 -0700
Subject: [PATCH 319/509] dma: xilinx: vdma: Don't disable interrupts at
 runtime

https://github.com/analogdevicesinc/linux.git xcomm_zynq
commit 69020f2bba074074b4e2bc820f1f51395c155cac

Enable interrupts when a channel is probed, and disable interrupts
only when a channel is removed. Re-enable interrupts
when a channel gets reset.

Signed-off-by: Hyun Kwon <hyunk@xilinx.com>
Acked-by: Srikanth Thokala <sthokal@xilinx.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 drivers/dma/xilinx/xilinx_axivdma.c |   36 ++++++++++++++++++++++------------
 1 files changed, 23 insertions(+), 13 deletions(-)

diff --git a/drivers/dma/xilinx/xilinx_axivdma.c b/drivers/dma/xilinx/xilinx_axivdma.c
index b9f93fc..aa4e699 100644
--- a/drivers/dma/xilinx/xilinx_axivdma.c
+++ b/drivers/dma/xilinx/xilinx_axivdma.c
@@ -562,13 +562,6 @@ static void xilinx_vdma_start_transfer(struct xilinx_vdma_chan *chan)
 	if (chan->err)
 		goto out_unlock;
 
-	/*
-	 * Enable interrupts
-	 * park/genlock testing does not use interrupts
-	 */
-	vdma_ctrl_set(chan, XILINX_VDMA_REG_DMACR,
-		      XILINX_VDMA_DMAXR_ALL_IRQ_MASK);
-
 	/* Start the transfer */
 	if (chan->has_sg) {
 		struct xilinx_vdma_tx_segment *head, *tail;
@@ -676,10 +669,6 @@ static irqreturn_t xilinx_vdma_irq_handler(int irq, void *data)
 	struct xilinx_vdma_chan *chan = data;
 	u32 status;
 
-	/* Disable all interrupts. */
-	vdma_ctrl_clr(chan, XILINX_VDMA_REG_DMACR,
-		      XILINX_VDMA_DMAXR_ALL_IRQ_MASK);
-
 	/* Read the status and ack the interrupts. */
 	status = vdma_ctrl_read(chan, XILINX_VDMA_REG_DMASR);
 	if (!(status & XILINX_VDMA_DMAXR_ALL_IRQ_MASK))
@@ -756,6 +745,10 @@ static dma_cookie_t xilinx_vdma_tx_submit(struct dma_async_tx_descriptor *tx)
 		err = xilinx_vdma_reset(chan);
 		if (err < 0)
 			return err;
+
+		/* Enable interrupts */
+		vdma_ctrl_set(chan, XILINX_VDMA_REG_DMACR,
+			      XILINX_VDMA_DMAXR_ALL_IRQ_MASK);
 	}
 
 	spin_lock_irqsave(&chan->lock, flags);
@@ -879,9 +872,18 @@ static int xilinx_vdma_slave_config(struct xilinx_vdma_chan *chan,
 				    struct xilinx_vdma_config *cfg)
 {
 	u32 dmacr;
+	int err;
+
+	if (cfg->reset) {
+		err = xilinx_vdma_reset(chan);
+		if (err < 0)
+			return err;
 
-	if (cfg->reset)
-		return xilinx_vdma_reset(chan);
+		/* Enable interrupts */
+		vdma_ctrl_set(chan, XILINX_VDMA_REG_DMACR,
+			      XILINX_VDMA_DMAXR_ALL_IRQ_MASK);
+		return 0;
+	}
 
 	dmacr = vdma_ctrl_read(chan, XILINX_VDMA_REG_DMACR);
 
@@ -990,6 +992,10 @@ static int xilinx_vdma_device_control(struct dma_chan *dchan,
 
 static void xilinx_vdma_chan_remove(struct xilinx_vdma_chan *chan)
 {
+	/* Disable all interrupts */
+	vdma_ctrl_clr(chan, XILINX_VDMA_REG_DMACR,
+		      XILINX_VDMA_DMAXR_ALL_IRQ_MASK);
+
 	irq_dispose_mapping(chan->irq);
 	list_del(&chan->common.device_node);
 }
@@ -1107,6 +1113,10 @@ static int xilinx_vdma_chan_probe(struct xilinx_vdma_device *xdev,
 	list_add_tail(&chan->common.device_node, &xdev->common.channels);
 	xdev->chan[chan->id] = chan;
 
+	/* Enable interrupts */
+	vdma_ctrl_set(chan, XILINX_VDMA_REG_DMACR,
+		      XILINX_VDMA_DMAXR_ALL_IRQ_MASK);
+
 	return 0;
 }
 
-- 
1.7.5.4

