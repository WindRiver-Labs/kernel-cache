From 2228e94fa5f06704fd669629b133e97a905dd1c0 Mon Sep 17 00:00:00 2001
From: Zhixiong Chi <Zhixiong.Chi@windriver.com>
Date: Thu, 12 May 2016 17:53:44 +0800
Subject: [PATCH 2/2] i2c: xi2cps:fix the i2c driver hang up

Due to HW bug the controller might incorrectly transfers 16 bytes of
additional read data from the slave device. When this happens, the
transfer_size register gets corrupted and rolls over to 0xFF as well.
The interrupt handling routine will not be available, so we can't get
the done signal and the driver will hang up.

This commit prevents the rx buffer to overflow. It also prevents rx
counters to wrap leading to incorrect SW timeout.
http://www.xilinx.com/support/answers/61664.html

Signed-off-by: Zhixiong Chi <Zhixiong.Chi@windriver.com>
---
 drivers/i2c/busses/i2c-xilinx_ps.c |  222 ++++++++++++++++++------------------
 1 files changed, 109 insertions(+), 113 deletions(-)

diff --git a/drivers/i2c/busses/i2c-xilinx_ps.c b/drivers/i2c/busses/i2c-xilinx_ps.c
index 19cabf9..cf5e314 100644
--- a/drivers/i2c/busses/i2c-xilinx_ps.c
+++ b/drivers/i2c/busses/i2c-xilinx_ps.c
@@ -90,6 +90,9 @@
 #define XI2CPS_IXR_ALL_INTR_MASK 0x000002FF /* All ISR Mask */
 
 #define XI2CPS_FIFO_DEPTH	16		/* FIFO Depth */
+#define XI2CPS_MAX_TRANSFER_SIZE      255
+/* Transfer size in multiples of data interrupt depth */
+#define XI2CPS_TRANSFER_SIZE  (XI2CPS_MAX_TRANSFER_SIZE - 3)
 #define XI2CPS_TIMEOUT		(50 * HZ)	/* Timeout for bus busy check */
 #define XI2CPS_ENABLED_INTR	0x2EF		/* Enabled Interrupts */
 
@@ -112,6 +115,7 @@
  * @p_recv_buf:		Pointer to receive buffer
  * @send_count:		Number of bytes still expected to send
  * @recv_count:		Number of bytes still expected to receive
+ * @curr_recv_count:	Number of bytes to be receive in current transfer
  * @irq:		IRQ number
  * @cur_timeout:	The current timeout value used by the device
  * @input_clk:		Input clock to I2C controller
@@ -127,6 +131,7 @@ struct xi2cps {
 	unsigned char *p_recv_buf;
 	int send_count;
 	int recv_count;
+	int curr_recv_count;
 	int irq;
 	int cur_timeout;
 	unsigned int input_clk;
@@ -134,6 +139,20 @@ struct xi2cps {
 };
 
 /**
+ * xi2cps_clear_bus_hold() - Clear bus hold bit
+ * @id: Pointer to driver data struct
+ *
+ * Helper to clear the controller's bus hold bit.
+ */
+static void xi2cps_clear_bus_hold(struct xi2cps *id)
+{
+	unsigned int ctrl_reg;
+	ctrl_reg = xi2cps_readreg(XI2CPS_CR_OFFSET);
+	if ((ctrl_reg & XI2CPS_CR_HOLD_BUS_MASK) == XI2CPS_CR_HOLD_BUS_MASK)
+	xi2cps_writereg((ctrl_reg & (~XI2CPS_CR_HOLD_BUS_MASK)),XI2CPS_CR_OFFSET);
+}
+
+/**
  * xi2cps_isr - Interrupt handler for the I2C device
  * @irq:	irq number for the I2C device
  * @ptr:	void pointer to xi2cps structure
@@ -145,131 +164,112 @@ struct xi2cps {
  */
 static irqreturn_t xi2cps_isr(int irq, void *ptr)
 {
-	unsigned int isr_status, avail_bytes;
+	unsigned int isr_status, avail_bytes, updatetx;
 	unsigned int bytes_to_recv, bytes_to_send;
 	unsigned int ctrl_reg = 0;
 	struct xi2cps *id = ptr;
+	/* Signal completion only after everything is updated */
+	int done_flag = 0;
 
 	isr_status = xi2cps_readreg(XI2CPS_ISR_OFFSET);
+	xi2cps_writereg(isr_status, XI2CPS_ISR_OFFSET);
 
-	/* Handling Nack interrupt */
-	if (isr_status & 0x00000004)
-		complete(&id->xfer_done);
+	/* Handling Nack interrupt and Arbitration lost interrupt */
+	if (isr_status & (0x00000004 | 0x00000200))
+		done_flag = 1;
+
+	updatetx = 0;
+	if (id->recv_count > id->curr_recv_count)
+		updatetx = 1;
+
+	/* When recviving, handling Data and tranfer complete interrupts */
+	if (id->p_recv_buf &&
+	    ((isr_status & 0x00000002) || 
+	     (isr_status & 0x00000001))) {
+		while (xi2cps_readreg(XI2CPS_SR_OFFSET) & 0x00000020) {
+			char fifo_byte;
+			if ((id->recv_count < XI2CPS_FIFO_DEPTH) &&
+			    !id->bus_hold_flag)
+				xi2cps_clear_bus_hold(id);
+			fifo_byte = xi2cps_readreg(XI2CPS_DATA_OFFSET);
+			if (id->recv_count) {
+				*(id->p_recv_buf)++ = fifo_byte;
+				id->recv_count--;
+				id->curr_recv_count--;
+			}
 
-	/* Handling Arbitration lost interrupt */
-	if (isr_status & 0x00000200)
-		complete(&id->xfer_done);
+			if (updatetx &&
+			    (id->curr_recv_count == XI2CPS_FIFO_DEPTH + 1))
+				break;
+		}
 
-	/* Handling Data interrupt */
-	if (isr_status & 0x00000002) {
-		/*
-		 * In master mode, if the device has more data to receive.
-		 * Calculate received bytes and update the receive count.
-		 */
-		if ((id->recv_count) > XI2CPS_FIFO_DEPTH) {
-			bytes_to_recv = (XI2CPS_FIFO_DEPTH + 1) -
-				xi2cps_readreg(XI2CPS_XFER_SIZE_OFFSET);
-			id->recv_count -= bytes_to_recv;
-		/*
-		 * Calculate the expected bytes to be received further and
-		 * update in transfer size register. If the expected bytes
-		 * count is less than FIFO size then clear hold bit if there
-		 * are no further messages to be processed
-		 */
-			if (id->recv_count > XI2CPS_FIFO_DEPTH)
-				xi2cps_writereg(XI2CPS_FIFO_DEPTH + 1,
-						XI2CPS_XFER_SIZE_OFFSET);
-			else {
-				xi2cps_writereg(id->recv_count,
-						XI2CPS_XFER_SIZE_OFFSET);
-				if (id->bus_hold_flag == 0)
-					/* Clear the hold bus bit */
-					xi2cps_writereg(
-					(xi2cps_readreg(XI2CPS_CR_OFFSET) &
-					(~XI2CPS_CR_HOLD_BUS_MASK)),
-					XI2CPS_CR_OFFSET);
-			}
-			/* Process the data received */
-			while (bytes_to_recv) {
-				*(id->p_recv_buf)++ =
-					xi2cps_readreg(XI2CPS_DATA_OFFSET);
-				bytes_to_recv = bytes_to_recv - 1;
+		if (updatetx && 
+		    (id->curr_recv_count == XI2CPS_FIFO_DEPTH + 1)) {
+			/* wait while fifo is full */
+			while (xi2cps_readreg(XI2CPS_XFER_SIZE_OFFSET) !=
+			       (id->curr_recv_count - XI2CPS_FIFO_DEPTH))
+				;
+
+			if (((id->recv_count) - XI2CPS_FIFO_DEPTH) >
+			    XI2CPS_TRANSFER_SIZE) {
+				xi2cps_writereg(XI2CPS_TRANSFER_SIZE,
+						  XI2CPS_XFER_SIZE_OFFSET);
+				id->curr_recv_count = XI2CPS_TRANSFER_SIZE +
+						      XI2CPS_FIFO_DEPTH;
+			} else {
+				xi2cps_writereg(id->recv_count -
+						  XI2CPS_FIFO_DEPTH,
+						  XI2CPS_XFER_SIZE_OFFSET);
+				id->curr_recv_count = id->recv_count;
 			}
 		}
+
+		if ((isr_status & 0x00000001) && !id->recv_count) {
+			if (!id->bus_hold_flag)
+				xi2cps_clear_bus_hold(id);
+			done_flag = 1;
+                }
 	}
 
-	/* Handling Transfer Complete interrupt */
-	if (isr_status & 0x00000001) {
-		if ((id->p_recv_buf) == NULL) {
-			/*
-			 * If the device is sending data If there is further
-			 * data to be sent. Calculate the available space
-			 * in FIFO and fill the FIFO with that many bytes.
-			 */
-			if (id->send_count > 0) {
-				avail_bytes = XI2CPS_FIFO_DEPTH -
-				xi2cps_readreg(XI2CPS_XFER_SIZE_OFFSET);
-				if (id->send_count > avail_bytes)
-					bytes_to_send = avail_bytes;
-				else
-					bytes_to_send = id->send_count;
-
-				while (bytes_to_send--) {
-					xi2cps_writereg(
-						(*(id->p_send_buf)++),
-						 XI2CPS_DATA_OFFSET);
-					id->send_count--;
-				}
-			} else {
+	/* When sending, handle transfer complete interrupt */
+	if ((isr_status & 0x00000001) && !id->p_recv_buf) {
 		/*
-		 * Signal the completion of transaction and clear the hold bus
-		 * bit if there are no further messages to be processed.
+		 * If the device is sending data If there is further
+		 * data to be sent. Calculate the available space
+		 * in FIFO and fill the FIFO with that many bytes.
 		 */
-				complete(&id->xfer_done);
-			}
-			if (id->send_count == 0) {
-				if (id->bus_hold_flag == 0) {
-					/* Clear the hold bus bit */
-					ctrl_reg =
-					xi2cps_readreg(XI2CPS_CR_OFFSET);
-					if ((ctrl_reg & XI2CPS_CR_HOLD_BUS_MASK)
-						== XI2CPS_CR_HOLD_BUS_MASK)
-						xi2cps_writereg(
-						(ctrl_reg &
-						(~XI2CPS_CR_HOLD_BUS_MASK)),
-						XI2CPS_CR_OFFSET);
-				}
+		if (id->send_count > 0) {
+			avail_bytes = XI2CPS_FIFO_DEPTH -
+			xi2cps_readreg(XI2CPS_XFER_SIZE_OFFSET);
+			if (id->send_count > avail_bytes)
+				bytes_to_send = avail_bytes;
+			else
+				bytes_to_send = id->send_count;
+
+			while (bytes_to_send--) {
+				xi2cps_writereg(
+					(*(id->p_send_buf)++),
+					 XI2CPS_DATA_OFFSET);
+				id->send_count--;
 			}
 		} else {
-			if (id->bus_hold_flag == 0) {
-				/* Clear the hold bus bit */
-				ctrl_reg =
-				xi2cps_readreg(XI2CPS_CR_OFFSET);
-				if ((ctrl_reg & XI2CPS_CR_HOLD_BUS_MASK)
-					== XI2CPS_CR_HOLD_BUS_MASK)
-					xi2cps_writereg(
-					(ctrl_reg &
-					(~XI2CPS_CR_HOLD_BUS_MASK)),
-					XI2CPS_CR_OFFSET);
-			}
-		/*
-		 * If the device is receiving data, then signal the completion
-		 * of transaction and read the data present in the FIFO.
-		 * Signal the completion of transaction.
-		 */
-			while (xi2cps_readreg(XI2CPS_SR_OFFSET)
-							& 0x00000020) {
-				*(id->p_recv_buf)++ =
-				xi2cps_readreg(XI2CPS_DATA_OFFSET);
-				id->recv_count--;
-			}
-			complete(&id->xfer_done);
+			/*
+			 * Signal the completion of transaction and clear the hold bus
+			 * bit if there are no further messages to be processed.
+			 */
+			done_flag = 1;
 		}
+		if (!id->send_count && !id->bus_hold_flag)
+			xi2cps_clear_bus_hold(id);
 	}
 
 	/* Update the status for errors */
 	id->err_status = isr_status & 0x000002EC;
 	xi2cps_writereg(isr_status, XI2CPS_ISR_OFFSET);
+
+	if (done_flag)
+		complete(&id->xfer_done);
+
 	return IRQ_HANDLED;
 }
 
@@ -308,14 +308,15 @@ static void xi2cps_mrecv(struct xi2cps *id)
 						XI2CPS_ADDR_OFFSET);
 	/*
 	 * The no. of bytes to receive is checked against the limit of
-	 * FIFO depth. Set transfer size register with no. of bytes to
-	 * receive if it is less than FIFO depth and FIFO depth + 1 if
+	 * max transfer size. Set transfer size register with no. of bytes
+	 * receive if it is less than transfer size and transfer size if
 	 * it is more. Enable the interrupts.
 	 */
-	if (id->recv_count > XI2CPS_FIFO_DEPTH)
-		xi2cps_writereg(XI2CPS_FIFO_DEPTH + 1,
+	if (id->recv_count > XI2CPS_TRANSFER_SIZE) {
+		xi2cps_writereg(XI2CPS_TRANSFER_SIZE,
 				XI2CPS_XFER_SIZE_OFFSET);
-	else {
+		id->curr_recv_count = XI2CPS_TRANSFER_SIZE;
+	} else {
 		xi2cps_writereg(id->recv_count, XI2CPS_XFER_SIZE_OFFSET);
 
 	/*
@@ -323,12 +324,7 @@ static void xi2cps_mrecv(struct xi2cps *id)
 	 */
 		if (id->bus_hold_flag == 0) {
 			/* Clear the hold bus bit */
-			ctrl_reg = xi2cps_readreg(XI2CPS_CR_OFFSET);
-			if ((ctrl_reg & XI2CPS_CR_HOLD_BUS_MASK)
-				== XI2CPS_CR_HOLD_BUS_MASK)
-				xi2cps_writereg(
-				(ctrl_reg & (~XI2CPS_CR_HOLD_BUS_MASK)),
-				XI2CPS_CR_OFFSET);
+			xi2cps_clear_bus_hold(id);
 		}
 	}
 	xi2cps_writereg(XI2CPS_ENABLED_INTR, XI2CPS_IER_OFFSET);
-- 
1.7.5.4

