From 3a0f6d9a5539a1d205c88299f16b6d42af36966e Mon Sep 17 00:00:00 2001
From: Lars-Peter Clausen <lars@metafoo.de>
Date: Tue, 25 Jun 2013 15:26:31 +0200
Subject: [PATCH 273/509] ASoC: Move xlnx/ to adi/

https://github.com/analogdevicesinc/linux.git xcomm_zynq_3_10
commit 24a2e9859d1abcfd8bd971797750918333b96651

Now that the audio drivers use the generic dmaengine PCM driver there is nothing
Xilinx specific in here anymore.

Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 sound/soc/Kconfig             |    2 +-
 sound/soc/Makefile            |    2 +-
 sound/soc/adi/Kconfig         |   23 ++++
 sound/soc/adi/Makefile        |   10 ++
 sound/soc/adi/adv7511_hdmi.c  |  105 +++++++++++++++
 sound/soc/adi/axi-i2s.c       |  291 +++++++++++++++++++++++++++++++++++++++++
 sound/soc/adi/axi-spdif.c     |  279 +++++++++++++++++++++++++++++++++++++++
 sound/soc/adi/zed_adau1761.c  |  164 +++++++++++++++++++++++
 sound/soc/xlnx/Kconfig        |   23 ----
 sound/soc/xlnx/Makefile       |   10 --
 sound/soc/xlnx/adi-axi-i2s.c  |  289 ----------------------------------------
 sound/soc/xlnx/adv7511_hdmi.c |  102 --------------
 sound/soc/xlnx/axi-spdif.c    |  266 -------------------------------------
 sound/soc/xlnx/zed_adau1761.c |  164 -----------------------
 14 files changed, 874 insertions(+), 856 deletions(-)
 create mode 100644 sound/soc/adi/Kconfig
 create mode 100644 sound/soc/adi/Makefile
 create mode 100644 sound/soc/adi/adv7511_hdmi.c
 create mode 100644 sound/soc/adi/axi-i2s.c
 create mode 100644 sound/soc/adi/axi-spdif.c
 create mode 100644 sound/soc/adi/zed_adau1761.c
 delete mode 100644 sound/soc/xlnx/Kconfig
 delete mode 100644 sound/soc/xlnx/Makefile
 delete mode 100644 sound/soc/xlnx/adi-axi-i2s.c
 delete mode 100644 sound/soc/xlnx/adv7511_hdmi.c
 delete mode 100644 sound/soc/xlnx/axi-spdif.c
 delete mode 100644 sound/soc/xlnx/zed_adau1761.c

diff --git a/sound/soc/Kconfig b/sound/soc/Kconfig
index 4a4b0ae..6441019 100644
--- a/sound/soc/Kconfig
+++ b/sound/soc/Kconfig
@@ -34,6 +34,7 @@ config SND_SOC_GENERIC_DMAENGINE_PCM
 	select SND_SOC_DMAENGINE_PCM
 
 # All the supported SoCs
+source "sound/soc/adi/Kconfig"
 source "sound/soc/atmel/Kconfig"
 source "sound/soc/au1x/Kconfig"
 source "sound/soc/blackfin/Kconfig"
@@ -54,7 +55,6 @@ source "sound/soc/sh/Kconfig"
 source "sound/soc/tegra/Kconfig"
 source "sound/soc/txx9/Kconfig"
 source "sound/soc/ux500/Kconfig"
-source "sound/soc/xlnx/Kconfig"
 
 # Supported codecs
 source "sound/soc/codecs/Kconfig"
diff --git a/sound/soc/Makefile b/sound/soc/Makefile
index 84ffd98..1e2fb4b 100644
--- a/sound/soc/Makefile
+++ b/sound/soc/Makefile
@@ -12,6 +12,7 @@ endif
 obj-$(CONFIG_SND_SOC)	+= snd-soc-core.o
 obj-$(CONFIG_SND_SOC)	+= codecs/
 obj-$(CONFIG_SND_SOC)	+= generic/
+obj-$(CONFIG_SND_SOC)	+= adi/
 obj-$(CONFIG_SND_SOC)	+= atmel/
 obj-$(CONFIG_SND_SOC)	+= au1x/
 obj-$(CONFIG_SND_SOC)	+= blackfin/
@@ -32,4 +33,3 @@ obj-$(CONFIG_SND_SOC)	+= sh/
 obj-$(CONFIG_SND_SOC)	+= tegra/
 obj-$(CONFIG_SND_SOC)	+= txx9/
 obj-$(CONFIG_SND_SOC)	+= ux500/
-obj-$(CONFIG_SND_SOC)	+= xlnx/
diff --git a/sound/soc/adi/Kconfig b/sound/soc/adi/Kconfig
new file mode 100644
index 0000000..cc00afd
--- /dev/null
+++ b/sound/soc/adi/Kconfig
@@ -0,0 +1,23 @@
+config SND_SOC_ADI
+	tristate "SoC Audio for ADI reference designs"
+	depends on SND_SOC && (MICROBLAZE || ARCH_ZYNQ)
+	select SND_SOC_GENERIC_DMAENGINE_PCM
+
+config SND_SOC_AXI_SPDIF
+	select REGMAP_MMIO
+	tristate
+
+config SND_SOC_ADI_AXI_I2S
+	select REGMAP_MMIO
+	tristate
+
+config SND_SOC_ADV7511_HDMI
+	tristate "ADV7511 HDMI transmitter sound support"
+	depends on SND_SOC_ADI
+	select SND_SOC_AXI_SPDIF
+
+config SND_SOC_ZED_ADAU1761
+	tristate "ZED board sound support"
+	depends on SND_SOC_ADI
+	select SND_SOC_ADI_AXI_I2S
+	select SND_SOC_ADAU1761
diff --git a/sound/soc/adi/Makefile b/sound/soc/adi/Makefile
new file mode 100644
index 0000000..0cee7e9
--- /dev/null
+++ b/sound/soc/adi/Makefile
@@ -0,0 +1,10 @@
+snd-soc-adi-axi-spdif-objs := axi-spdif.o
+snd-soc-adv7511-hdmi-objs := adv7511_hdmi.o
+snd-soc-adi-axi-i2s-objs := axi-i2s.o
+snd-soc-zed-adau1761-objs := zed_adau1761.o
+
+obj-$(CONFIG_SND_SOC_AXI_SPDIF) += snd-soc-adi-axi-spdif.o
+obj-$(CONFIG_SND_SOC_ADI_AXI_I2S) += snd-soc-adi-axi-i2s.o
+
+obj-$(CONFIG_SND_SOC_ADV7511_HDMI) += snd-soc-adv7511-hdmi.o
+obj-$(CONFIG_SND_SOC_ZED_ADAU1761) += snd-soc-zed-adau1761.o
diff --git a/sound/soc/adi/adv7511_hdmi.c b/sound/soc/adi/adv7511_hdmi.c
new file mode 100644
index 0000000..7cc1228
--- /dev/null
+++ b/sound/soc/adi/adv7511_hdmi.c
@@ -0,0 +1,105 @@
+/*
+ *  Copyright (C) 2012, Analog Devices Inc.
+ *	Author: Lars-Peter Clausen <lars@metafoo.de>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under  the terms of the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the License, or (at your
+ *  option) any later version.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/timer.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/of.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/soc.h>
+
+static const struct snd_soc_dapm_widget adv7511_hdmi_dapm_widgets[] = {
+	SND_SOC_DAPM_SPK("Speaker", NULL),
+};
+
+static const struct snd_soc_dapm_route adv7511_hdmi_dapm_routes[] = {
+	{ "Speaker", NULL, "TMDS" },
+};
+
+static struct snd_soc_dai_link hdmi_dai_link = {
+	.name = "HDMI",
+	.stream_name = "HDMI",
+/*	.cpu_dai_name = "75c00000.axi-spdif-tx",
+	.platform_name = "xilinx_pcm_audio.2",
+	.codec_name = adv7511_codec_name,*/
+	.codec_dai_name = "adv7511",
+	.dai_fmt = SND_SOC_DAIFMT_SPDIF |
+			SND_SOC_DAIFMT_NB_NF |
+			SND_SOC_DAIFMT_CBS_CFS,
+};
+
+static struct snd_soc_card hdmi_card = {
+	.name = "HDMI monitor",
+	.owner = THIS_MODULE,
+	.dai_link = &hdmi_dai_link,
+	.num_links = 1,
+	.dapm_widgets = adv7511_hdmi_dapm_widgets,
+	.num_dapm_widgets = ARRAY_SIZE(adv7511_hdmi_dapm_widgets),
+	.dapm_routes = adv7511_hdmi_dapm_routes,
+	.num_dapm_routes = ARRAY_SIZE(adv7511_hdmi_dapm_routes),
+};
+
+static int adv7511_hdmi_probe(struct platform_device *pdev)
+{
+	struct snd_soc_card *card = &hdmi_card;
+	struct device_node *of_node = pdev->dev.of_node;
+
+	if (!of_node)
+		return -ENXIO;
+
+	card->dev = &pdev->dev;
+
+	hdmi_dai_link.codec_of_node = of_parse_phandle(of_node, "audio-codec", 0);
+	hdmi_dai_link.cpu_of_node = of_parse_phandle(of_node, "cpu-dai", 0);
+	hdmi_dai_link.platform_of_node = hdmi_dai_link.cpu_of_node;
+
+	if (!hdmi_dai_link.codec_of_node || !hdmi_dai_link.cpu_of_node)
+		return -ENXIO;
+
+	return snd_soc_register_card(card);
+}
+
+static int adv7511_hdmi_remove(struct platform_device *pdev)
+{
+	struct snd_soc_card *card = platform_get_drvdata(pdev);
+
+	snd_soc_unregister_card(card);
+
+	return 0;
+}
+
+static const struct of_device_id adv7511_hdmi_of_match[] = {
+	{ .compatible = "adv7511-hdmi-snd", },
+	{},
+};
+MODULE_DEVICE_TABLE(of, adv7511_hdmi_of_match);
+
+static struct platform_driver hdmi_card_driver = {
+	.driver = {
+		.name = "adv7511-hdmi-snd",
+		.owner = THIS_MODULE,
+		.of_match_table = adv7511_hdmi_of_match,
+		.pm = &snd_soc_pm_ops,
+	},
+	.probe = adv7511_hdmi_probe,
+	.remove = adv7511_hdmi_remove,
+};
+module_platform_driver(hdmi_card_driver);
+
+MODULE_AUTHOR("Lars-Peter Clausen <lars@metafoo.de>");
+MODULE_DESCRIPTION("ADV7511 HDMI sound driver");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/adi/axi-i2s.c b/sound/soc/adi/axi-i2s.c
new file mode 100644
index 0000000..2970bb3
--- /dev/null
+++ b/sound/soc/adi/axi-i2s.c
@@ -0,0 +1,291 @@
+/*
+ *  Copyright (C) 2012-2013, Analog Devices Inc.
+ *	Author: Lars-Peter Clausen <lars@metafoo.de>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under  the terms of the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the License, or (at your
+ *  option) any later version.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+
+#include <linux/clk.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
+#include <linux/regmap.h>
+#include <linux/slab.h>
+
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/dmaengine_pcm.h>
+
+#define AXI_I2S_REG_RESET	0x00
+#define AXI_I2S_REG_CTRL	0x04
+#define AXI_I2S_REG_CLK_CTRL	0x08
+#define AXI_I2S_REG_STATUS	0x10
+#define AXI_I2S_REG_PERIOD_SIZE	0x18
+
+#define AXI_I2S_REG_RX_FIFO	0x28
+#define AXI_I2S_REG_TX_FIFO	0x2C
+
+#define AXI_I2S_RESET_GLOBAL	BIT(0)
+#define AXI_I2S_RESET_TX_FIFO	BIT(1)
+#define AXI_I2S_RESET_RX_FIFO	BIT(2)
+
+#define AXI_I2S_CTRL_TX_EN	BIT(0)
+#define AXI_I2S_CTRL_RX_EN	BIT(1)
+
+#define AXI_I2S_BITS_PER_FRAME 64
+
+struct axi_i2s {
+	struct regmap *regmap;
+	struct clk *clk;
+	struct clk *clk_i2s;
+
+	struct snd_soc_dai_driver dai_driver;
+
+	struct snd_dmaengine_dai_dma_data capture_dma_data;
+	struct snd_dmaengine_dai_dma_data playback_dma_data;
+
+	struct snd_ratnum ratnum;
+	struct snd_pcm_hw_constraint_ratnums rate_constraints;
+};
+
+static int axi_i2s_trigger(struct snd_pcm_substream *substream, int cmd,
+	struct snd_soc_dai *dai)
+{
+	struct axi_i2s *i2s = snd_soc_dai_get_drvdata(dai);
+	unsigned int mask, val;
+
+	if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)
+		mask = AXI_I2S_CTRL_RX_EN;
+	else
+		mask = AXI_I2S_CTRL_TX_EN;
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		val = mask;
+		break;
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		val = 0;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	regmap_update_bits(i2s->regmap, AXI_I2S_REG_CTRL, mask, val);
+
+	return 0;
+}
+
+static int axi_i2s_hw_params(struct snd_pcm_substream *substream,
+	struct snd_pcm_hw_params *params, struct snd_soc_dai *dai)
+{
+	struct axi_i2s *i2s = snd_soc_dai_get_drvdata(dai);
+	unsigned int bclk_div, frame_size;
+	unsigned int bclk_rate;
+
+	bclk_rate = params_rate(params) * AXI_I2S_BITS_PER_FRAME;
+
+	frame_size = AXI_I2S_BITS_PER_FRAME / 2 - 1;
+	bclk_div = DIV_ROUND_UP(clk_get_rate(i2s->clk_i2s), bclk_rate) / 2 - 1;
+
+	regmap_write(i2s->regmap, AXI_I2S_REG_CLK_CTRL, (frame_size << 16) |
+		bclk_div);
+
+	if (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {
+		unsigned int period_size = params_period_bytes(params) / 4 - 1;
+		regmap_write(i2s->regmap, AXI_I2S_REG_PERIOD_SIZE, period_size);
+	}
+
+	return 0;
+}
+
+static int axi_i2s_startup(struct snd_pcm_substream *substream,
+	struct snd_soc_dai *dai)
+{
+	struct axi_i2s *i2s = snd_soc_dai_get_drvdata(dai);
+	uint32_t mask;
+	int ret;
+
+	if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)
+		mask = AXI_I2S_RESET_RX_FIFO;
+	else
+		mask = AXI_I2S_RESET_TX_FIFO;
+
+	regmap_write(i2s->regmap, AXI_I2S_REG_RESET, mask);
+
+	ret = snd_pcm_hw_constraint_ratnums(substream->runtime, 0,
+			   SNDRV_PCM_HW_PARAM_RATE,
+			   &i2s->rate_constraints);
+	if (ret)
+		return ret;
+
+	return clk_prepare_enable(i2s->clk_i2s);
+}
+
+static void axi_i2s_shutdown(struct snd_pcm_substream *substream,
+	struct snd_soc_dai *dai)
+{
+	struct axi_i2s *i2s = snd_soc_dai_get_drvdata(dai);
+
+	clk_disable_unprepare(i2s->clk_i2s);
+}
+
+static int axi_i2s_dai_probe(struct snd_soc_dai *dai)
+{
+	struct axi_i2s *i2s = snd_soc_dai_get_drvdata(dai);
+
+	dai->playback_dma_data = &i2s->playback_dma_data;
+	dai->capture_dma_data = &i2s->capture_dma_data;
+
+	return 0;
+}
+
+static const struct snd_soc_dai_ops axi_i2s_dai_ops = {
+	.startup = axi_i2s_startup,
+	.shutdown = axi_i2s_shutdown,
+	.trigger = axi_i2s_trigger,
+	.hw_params = axi_i2s_hw_params,
+};
+
+static struct snd_soc_dai_driver axi_i2s_dai = {
+	.probe = axi_i2s_dai_probe,
+	.playback = {
+		.channels_min = 2,
+		.channels_max = 2,
+		.rates = SNDRV_PCM_RATE_8000_192000 | SNDRV_PCM_RATE_KNOT,
+		.formats = SNDRV_PCM_FMTBIT_S32_LE,
+	},
+	.capture = {
+		.channels_min = 2,
+		.channels_max = 2,
+		.rates = SNDRV_PCM_RATE_8000_192000 | SNDRV_PCM_RATE_KNOT,
+		.formats = SNDRV_PCM_FMTBIT_S32_LE,
+	},
+	.ops = &axi_i2s_dai_ops,
+	.symmetric_rates = 1,
+};
+
+static const struct snd_soc_component_driver axi_i2s_component = {
+	.name		= "axi-i2s",
+};
+
+static const struct regmap_config axi_i2s_regmap_config = {
+	.reg_bits = 32,
+	.reg_stride = 4,
+	.val_bits = 32,
+	.max_register = AXI_I2S_REG_PERIOD_SIZE,
+};
+
+static int axi_i2s_probe(struct platform_device *pdev)
+{
+	struct resource *res;
+	struct axi_i2s *i2s;
+	void __iomem *base;
+	int ret;
+
+	i2s = devm_kzalloc(&pdev->dev, sizeof(*i2s), GFP_KERNEL);
+	if (!i2s)
+		return -ENOMEM;
+
+	platform_set_drvdata(pdev, i2s);
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	base = devm_request_and_ioremap(&pdev->dev, res);
+	if (!base)
+		return -EBUSY;
+
+	i2s->regmap = devm_regmap_init_mmio(&pdev->dev, base,
+		&axi_i2s_regmap_config);
+	if (IS_ERR(i2s->regmap))
+		return PTR_ERR(i2s->regmap);
+
+	i2s->clk = devm_clk_get(&pdev->dev, "axi");
+	if (IS_ERR(i2s->clk))
+		return PTR_ERR(i2s->clk);
+
+	i2s->clk_i2s = devm_clk_get(&pdev->dev, "i2s");
+	if (IS_ERR(i2s->clk_i2s))
+		return PTR_ERR(i2s->clk_i2s);
+
+	ret = clk_prepare_enable(i2s->clk);
+	if (ret)
+		return ret;
+
+	i2s->playback_dma_data.addr = res->start + AXI_I2S_REG_TX_FIFO;
+	i2s->playback_dma_data.addr_width = 4;
+	i2s->playback_dma_data.maxburst = 1;
+
+	i2s->capture_dma_data.addr = res->start + AXI_I2S_REG_RX_FIFO;
+	i2s->capture_dma_data.addr_width = 4;
+	i2s->capture_dma_data.maxburst = 1;
+
+	i2s->ratnum.num = clk_get_rate(i2s->clk_i2s) / 2 / AXI_I2S_BITS_PER_FRAME;
+	i2s->ratnum.den_step = 1;
+	i2s->ratnum.den_min = 1;
+	i2s->ratnum.den_max = 64;
+
+	i2s->rate_constraints.rats = &i2s->ratnum;
+	i2s->rate_constraints.nrats = 1;
+
+	regmap_write(i2s->regmap, AXI_I2S_REG_RESET, AXI_I2S_RESET_GLOBAL);
+
+	ret = snd_soc_register_component(&pdev->dev, &axi_i2s_component,
+					 &axi_i2s_dai, 1);
+	if (ret)
+		return ret;
+
+	ret = snd_dmaengine_pcm_register(&pdev->dev, NULL,
+			SND_DMAENGINE_PCM_FLAG_NO_RESIDUE);
+	if (ret)
+		snd_soc_unregister_component(&pdev->dev);
+
+	return ret;
+}
+
+static int axi_i2s_dev_remove(struct platform_device *pdev)
+{
+	struct axi_i2s *i2s = platform_get_drvdata(pdev);
+
+	clk_disable_unprepare(i2s->clk);
+
+	snd_dmaengine_pcm_unregister(&pdev->dev);
+	snd_soc_unregister_component(&pdev->dev);
+
+	return 0;
+}
+
+static const struct of_device_id axi_i2s_of_match[] = {
+	{ .compatible = "adi,axi-i2s-1.00.a", },
+	{},
+};
+MODULE_DEVICE_TABLE(of, axi_i2s_of_match);
+
+static struct platform_driver axi_i2s_driver = {
+	.driver = {
+		.name = "axi-i2s",
+		.owner = THIS_MODULE,
+		.of_match_table = axi_i2s_of_match,
+	},
+	.probe = axi_i2s_probe,
+	.remove = axi_i2s_dev_remove,
+};
+module_platform_driver(axi_i2s_driver);
+
+MODULE_AUTHOR("Lars-Peter Clausen <lars@metafoo.de>");
+MODULE_DESCRIPTION("AXI I2S driver");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/adi/axi-spdif.c b/sound/soc/adi/axi-spdif.c
new file mode 100644
index 0000000..b7aa0e0
--- /dev/null
+++ b/sound/soc/adi/axi-spdif.c
@@ -0,0 +1,279 @@
+/*
+ *  Copyright (C) 2012, Analog Devices Inc.
+ *	Author: Lars-Peter Clausen <lars@metafoo.de>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under  the terms of the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the License, or (at your
+ *  option) any later version.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/of.h>
+#include <linux/clk.h>
+#include <linux/regmap.h>
+
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/initval.h>
+#include <sound/dmaengine_pcm.h>
+
+#define AXI_SPDIF_REG_CTRL	0x0
+#define AXI_SPDIF_REG_STAT	0x4
+#define AXI_SPDIF_REG_TX_FIFO	0xc
+
+#define AXI_SPDIF_CTRL_TXDATA BIT(1)
+#define AXI_SPDIF_CTRL_TXEN BIT(0)
+#define AXI_SPDIF_CTRL_CLKDIV_OFFSET 8
+#define AXI_SPDIF_CTRL_CLKDIV_MASK (0xff << 8)
+
+#define AXI_SPDIF_FREQ_44100	(0x0 << 6)
+#define AXI_SPDIF_FREQ_48000	(0x1 << 6)
+#define AXI_SPDIF_FREQ_32000	(0x2 << 6)
+#define AXI_SPDIF_FREQ_NA	(0x3 << 6)
+
+struct axi_spdif {
+	struct regmap *regmap;
+	struct clk *clk;
+	struct clk *clk_spdif;
+
+	struct snd_dmaengine_dai_dma_data dma_data;
+
+	struct snd_ratnum ratnum;
+	struct snd_pcm_hw_constraint_ratnums rate_constraints;
+};
+
+static int axi_spdif_trigger(struct snd_pcm_substream *substream, int cmd,
+	struct snd_soc_dai *dai)
+{
+	struct axi_spdif *spdif = snd_soc_dai_get_drvdata(dai);
+	unsigned int val;
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		val = AXI_SPDIF_CTRL_TXDATA;
+		break;
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		val = 0;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	regmap_update_bits(spdif->regmap, AXI_SPDIF_REG_CTRL,
+		AXI_SPDIF_CTRL_TXDATA, val);
+
+	return 0;
+}
+
+static int axi_spdif_hw_params(struct snd_pcm_substream *substream,
+	struct snd_pcm_hw_params *params, struct snd_soc_dai *dai)
+{
+	struct axi_spdif *spdif = snd_soc_dai_get_drvdata(dai);
+	unsigned int rate = params_rate(params);
+	unsigned int clkdiv, stat;
+
+	switch (params_rate(params)) {
+	case 32000:
+		stat = AXI_SPDIF_FREQ_32000;
+		break;
+	case 44100:
+		stat = AXI_SPDIF_FREQ_44100;
+		break;
+	case 48000:
+		stat = AXI_SPDIF_FREQ_48000;
+		break;
+	default:
+		stat = AXI_SPDIF_FREQ_NA;
+		break;
+	}
+
+	clkdiv = DIV_ROUND_CLOSEST(clk_get_rate(spdif->clk_spdif),
+			rate * 64 * 2) - 1;
+	clkdiv <<= AXI_SPDIF_CTRL_CLKDIV_OFFSET;
+
+	regmap_write(spdif->regmap, AXI_SPDIF_REG_STAT, stat);
+	regmap_update_bits(spdif->regmap, AXI_SPDIF_REG_CTRL,
+		AXI_SPDIF_CTRL_CLKDIV_MASK, clkdiv);
+
+	return 0;
+}
+
+static int axi_spdif_dai_probe(struct snd_soc_dai *dai)
+{
+	struct axi_spdif *spdif = snd_soc_dai_get_drvdata(dai);
+
+	dai->playback_dma_data = &spdif->dma_data;
+
+	return 0;
+}
+
+static int axi_spdif_startup(struct snd_pcm_substream *substream,
+	struct snd_soc_dai *dai)
+{
+	struct axi_spdif *spdif = snd_soc_dai_get_drvdata(dai);
+	int ret;
+
+	ret = snd_pcm_hw_constraint_ratnums(substream->runtime, 0,
+			   SNDRV_PCM_HW_PARAM_RATE,
+			   &spdif->rate_constraints);
+	if (ret)
+		return ret;
+
+	ret = clk_prepare_enable(spdif->clk_spdif);
+	if (ret)
+		return ret;
+
+	regmap_update_bits(spdif->regmap, AXI_SPDIF_REG_CTRL,
+		AXI_SPDIF_CTRL_TXEN, AXI_SPDIF_CTRL_TXEN);
+
+	return 0;
+}
+
+static void axi_spdif_shutdown(struct snd_pcm_substream *substream,
+	struct snd_soc_dai *dai)
+{
+	struct axi_spdif *spdif = snd_soc_dai_get_drvdata(dai);
+
+	regmap_update_bits(spdif->regmap, AXI_SPDIF_REG_CTRL,
+		AXI_SPDIF_CTRL_TXEN, 0);
+
+	clk_disable_unprepare(spdif->clk_spdif);
+}
+
+static const struct snd_soc_dai_ops axi_spdif_dai_ops = {
+	.startup = axi_spdif_startup,
+	.shutdown = axi_spdif_shutdown,
+	.trigger = axi_spdif_trigger,
+	.hw_params = axi_spdif_hw_params,
+};
+
+static struct snd_soc_dai_driver axi_spdif_dai = {
+	.probe = axi_spdif_dai_probe,
+	.playback = {
+		.channels_min = 2,
+		.channels_max = 2,
+		.rates = SNDRV_PCM_RATE_8000_192000 | SNDRV_PCM_RATE_KNOT,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE,
+	},
+	.ops = &axi_spdif_dai_ops,
+};
+
+static const struct snd_soc_component_driver axi_spdif_component = {
+	.name		= "axi-spdif",
+};
+
+static const struct regmap_config axi_spdif_regmap_config = {
+	.reg_bits = 32,
+	.reg_stride = 4,
+	.val_bits = 32,
+	.max_register = AXI_SPDIF_REG_STAT,
+};
+
+static int axi_spdif_probe(struct platform_device *pdev)
+{
+	struct axi_spdif *spdif;
+	struct resource *res;
+	void __iomem *base;
+	int ret;
+
+	spdif = devm_kzalloc(&pdev->dev, sizeof(*spdif), GFP_KERNEL);
+	if (!spdif)
+		return -ENOMEM;
+
+	platform_set_drvdata(pdev, spdif);
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	base = devm_request_and_ioremap(&pdev->dev, res);
+	if (!base)
+		return -EBUSY;
+
+	spdif->regmap = devm_regmap_init_mmio(&pdev->dev, base,
+					    &axi_spdif_regmap_config);
+	if (IS_ERR(spdif->regmap))
+		return PTR_ERR(spdif->regmap);
+
+	spdif->clk = devm_clk_get(&pdev->dev, "axi");
+	if (IS_ERR(spdif->clk))
+		return PTR_ERR(spdif->clk);
+
+	spdif->clk_spdif = devm_clk_get(&pdev->dev, "spdif");
+	if (IS_ERR(spdif->clk_spdif))
+		return PTR_ERR(spdif->clk_spdif);
+
+	ret = clk_prepare_enable(spdif->clk);
+	if (ret)
+		return ret;
+
+	spdif->dma_data.addr = res->start + AXI_SPDIF_REG_TX_FIFO;
+	spdif->dma_data.addr_width = 4;
+	spdif->dma_data.maxburst = 1;
+
+	spdif->ratnum.num = clk_get_rate(spdif->clk_spdif) / 128;
+	spdif->ratnum.den_step = 1;
+	spdif->ratnum.den_min = 1;
+	spdif->ratnum.den_max = 64;
+
+	spdif->rate_constraints.rats = &spdif->ratnum;
+	spdif->rate_constraints.nrats = 1;
+
+	ret = snd_soc_register_component(&pdev->dev, &axi_spdif_component,
+					 &axi_spdif_dai, 1);
+	if (ret)
+		return ret;
+
+	ret = snd_dmaengine_pcm_register(&pdev->dev, NULL,
+			SND_DMAENGINE_PCM_FLAG_NO_RESIDUE);
+	if (ret)
+		snd_soc_unregister_component(&pdev->dev);
+
+	return ret;
+}
+
+static int axi_spdif_dev_remove(struct platform_device *pdev)
+{
+	struct axi_spdif *spdif = platform_get_drvdata(pdev);
+
+	clk_disable_unprepare(spdif->clk);
+
+	snd_dmaengine_pcm_unregister(&pdev->dev);
+	snd_soc_unregister_component(&pdev->dev);
+
+	return 0;
+}
+
+static const struct of_device_id axi_spdif_of_match[] = {
+	{ .compatible = "adi,axi-spdif-tx-1.00.a", },
+	{},
+};
+MODULE_DEVICE_TABLE(of, axi_spdif_of_match);
+
+static struct platform_driver axi_spdif_driver = {
+	.driver = {
+		.name = "axi-spdif",
+		.owner = THIS_MODULE,
+		.of_match_table = axi_spdif_of_match,
+	},
+	.probe = axi_spdif_probe,
+	.remove = axi_spdif_dev_remove,
+};
+module_platform_driver(axi_spdif_driver);
+
+MODULE_AUTHOR("Lars-Peter Clausen <lars@metafoo.de>");
+MODULE_DESCRIPTION("AXI SPDIF driver");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/adi/zed_adau1761.c b/sound/soc/adi/zed_adau1761.c
new file mode 100644
index 0000000..d64caf65
--- /dev/null
+++ b/sound/soc/adi/zed_adau1761.c
@@ -0,0 +1,164 @@
+/*
+ *  Copyright (C) 2012-2013, Analog Devices Inc.
+ *	Author: Lars-Peter Clausen <lars@metafoo.de>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under  the terms of the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the License, or (at your
+ *  option) any later version.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/timer.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/of.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/soc.h>
+#include "../codecs/adau17x1.h"
+
+static const struct snd_soc_dapm_widget zed_adau1761_widgets[] = {
+	SND_SOC_DAPM_SPK("Line Out", NULL),
+	SND_SOC_DAPM_HP("Headphone Out", NULL),
+	SND_SOC_DAPM_MIC("Mic In", NULL),
+	SND_SOC_DAPM_MIC("Line In", NULL),
+};
+
+static const struct snd_soc_dapm_route zed_adau1761_routes[] = {
+	{ "Line Out", NULL, "LOUT" },
+	{ "Line Out", NULL, "ROUT" },
+	{ "Headphone Out", NULL, "LHP" },
+	{ "Headphone Out", NULL, "RHP" },
+	{ "Mic In", NULL, "MICBIAS" },
+	{ "LINN", NULL, "Mic In" },
+	{ "RINN", NULL, "Mic In" },
+	{ "LAUX", NULL, "Line In" },
+	{ "RAUX", NULL, "Line In" },
+};
+
+static int zed_adau1761_hw_params(struct snd_pcm_substream *substream,
+	struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *codec_dai = rtd->codec_dai;
+	unsigned int pll_rate;
+	int ret;
+
+	switch (params_rate(params)) {
+	case 48000:
+	case 8000:
+	case 12000:
+	case 16000:
+	case 24000:
+	case 32000:
+	case 96000:
+		pll_rate = 48000 * 1024;
+		break;
+	case 44100:
+	case 7350:
+	case 11025:
+	case 14700:
+	case 22050:
+	case 29400:
+	case 88200:
+		pll_rate = 44100 * 1024;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	ret = snd_soc_dai_set_pll(codec_dai, ADAU17X1_PLL,
+			ADAU17X1_PLL_SRC_MCLK, 12288000, pll_rate);
+	if (ret)
+		return ret;
+
+	ret = snd_soc_dai_set_sysclk(codec_dai, ADAU17X1_CLK_SRC_PLL, pll_rate,
+			SND_SOC_CLOCK_IN);
+
+	return ret;
+}
+
+static struct snd_soc_ops zed_adau1761_ops = {
+	.hw_params = zed_adau1761_hw_params,
+};
+
+static struct snd_soc_dai_link zed_adau1761_dai_link = {
+	.name = "adau1761",
+	.stream_name = "adau1761",
+	.codec_dai_name = "adau-hifi",
+	.dai_fmt = SND_SOC_DAIFMT_I2S |
+			SND_SOC_DAIFMT_NB_NF |
+			SND_SOC_DAIFMT_CBS_CFS,
+	.ops = &zed_adau1761_ops,
+};
+
+static struct snd_soc_card zed_adau1761_card = {
+	.name = "ZED ADAU1761",
+	.owner = THIS_MODULE,
+	.dai_link = &zed_adau1761_dai_link,
+	.num_links = 1,
+	.dapm_widgets = zed_adau1761_widgets,
+	.num_dapm_widgets = ARRAY_SIZE(zed_adau1761_widgets),
+	.dapm_routes = zed_adau1761_routes,
+	.num_dapm_routes = ARRAY_SIZE(zed_adau1761_routes),
+	.fully_routed = true,
+};
+
+static int zed_adau1761_probe(struct platform_device *pdev)
+{
+	struct snd_soc_card *card = &zed_adau1761_card;
+	struct device_node *of_node = pdev->dev.of_node;
+
+	if (!of_node)
+		return -ENXIO;
+
+	card->dev = &pdev->dev;
+
+	zed_adau1761_dai_link.codec_of_node = of_parse_phandle(of_node, "audio-codec", 0);
+	zed_adau1761_dai_link.cpu_of_node = of_parse_phandle(of_node, "cpu-dai", 0);
+	zed_adau1761_dai_link.platform_of_node = zed_adau1761_dai_link.cpu_of_node;
+
+	if (!zed_adau1761_dai_link.codec_of_node ||
+		!zed_adau1761_dai_link.cpu_of_node)
+		return -ENXIO;
+
+	return snd_soc_register_card(card);
+}
+
+static int zed_adau1761_remove(struct platform_device *pdev)
+{
+	struct snd_soc_card *card = platform_get_drvdata(pdev);
+
+	snd_soc_unregister_card(card);
+
+	return 0;
+}
+
+static const struct of_device_id zed_adau1761_of_match[] = {
+	{ .compatible = "digilent,zed-sound", },
+	{},
+};
+MODULE_DEVICE_TABLE(of, zed_adau1761_of_match);
+
+static struct platform_driver zed_adau1761_card_driver = {
+	.driver = {
+		.name = "zed-adau1761-snd",
+		.owner = THIS_MODULE,
+		.of_match_table = zed_adau1761_of_match,
+		.pm = &snd_soc_pm_ops,
+	},
+	.probe = zed_adau1761_probe,
+	.remove = zed_adau1761_remove,
+};
+module_platform_driver(zed_adau1761_card_driver);
+
+MODULE_DESCRIPTION("ASoC ZED board ADAU1761 driver");
+MODULE_AUTHOR("Lars-Peter Clausen <lars@metafoo.de>");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:zed-adau1761-snd");
diff --git a/sound/soc/xlnx/Kconfig b/sound/soc/xlnx/Kconfig
deleted file mode 100644
index 3126288..0000000
--- a/sound/soc/xlnx/Kconfig
+++ /dev/null
@@ -1,23 +0,0 @@
-config SND_SOC_XILINX
-	tristate "SoC Audio for Xilinx based boards"
-	depends on SND_SOC && (MICROBLAZE || ARCH_ZYNQ)
-	select SND_SOC_GENERIC_DMAENGINE_PCM
-
-config SND_SOC_AXI_SPDIF
-	select REGMAP_MMIO
-	tristate
-
-config SND_SOC_ADI_AXI_I2S
-	select REGMAP_MMIO
-	tristate
-
-config SND_SOC_ADV7511_HDMI
-	tristate "ADV7511 HDMI transmitter sound support"
-	depends on SND_SOC_XILINX
-	select SND_SOC_AXI_SPDIF
-
-config SND_SOC_ZED_ADAU1761
-	tristate "ZED board sound support"
-	depends on SND_SOC_XILINX
-	select SND_SOC_ADI_AXI_I2S
-	select SND_SOC_ADAU1761
diff --git a/sound/soc/xlnx/Makefile b/sound/soc/xlnx/Makefile
deleted file mode 100644
index 3c4cfbe..0000000
--- a/sound/soc/xlnx/Makefile
+++ /dev/null
@@ -1,10 +0,0 @@
-snd-soc-axi-spdif-objs := axi-spdif.o
-snd-soc-adv7511-hdmi-objs := adv7511_hdmi.o
-snd-soc-adi-axi-i2s-objs := adi-axi-i2s.o
-snd-soc-zed-adau1761-objs := zed_adau1761.o
-
-obj-$(CONFIG_SND_SOC_AXI_SPDIF) += snd-soc-axi-spdif.o
-obj-$(CONFIG_SND_SOC_ADI_AXI_I2S) += snd-soc-adi-axi-i2s.o
-
-obj-$(CONFIG_SND_SOC_ADV7511_HDMI) += snd-soc-adv7511-hdmi.o
-obj-$(CONFIG_SND_SOC_ZED_ADAU1761) += snd-soc-zed-adau1761.o
diff --git a/sound/soc/xlnx/adi-axi-i2s.c b/sound/soc/xlnx/adi-axi-i2s.c
deleted file mode 100644
index a4a3864..0000000
--- a/sound/soc/xlnx/adi-axi-i2s.c
+++ /dev/null
@@ -1,289 +0,0 @@
-/*
- *  Copyright (C) 2012, Analog Devices Inc.
- *	Author: Lars-Peter Clausen <lars@metafoo.de>
- *
- *  This program is free software; you can redistribute it and/or modify it
- *  under  the terms of the GNU General  Public License as published by the
- *  Free Software Foundation;  either version 2 of the License, or (at your
- *  option) any later version.
- *
- *  You should have received a copy of the GNU General Public License along
- *  with this program; if not, write to the Free Software Foundation, Inc.,
- *  675 Mass Ave, Cambridge, MA 02139, USA.
- *
- */
-
-#include <linux/clk.h>
-#include <linux/init.h>
-#include <linux/io.h>
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/of.h>
-#include <linux/platform_device.h>
-#include <linux/regmap.h>
-#include <linux/slab.h>
-
-#include <sound/core.h>
-#include <sound/pcm.h>
-#include <sound/pcm_params.h>
-#include <sound/soc.h>
-#include <sound/dmaengine_pcm.h>
-
-struct axi_i2s {
-	struct regmap *regmap;
-	struct clk *clk;
-	struct clk *clk_i2s;
-
-	struct snd_soc_dai_driver dai_driver;
-
-	struct snd_dmaengine_dai_dma_data capture_dma_data;
-	struct snd_dmaengine_dai_dma_data playback_dma_data;
-
-	struct snd_ratnum ratnum;
-	struct snd_pcm_hw_constraint_ratnums rate_constraints;
-};
-
-#define AXI_I2S_REG_RESET	0x00
-#define AXI_I2S_REG_CTRL	0x04
-#define AXI_I2S_REG_CLK_CTRL	0x08
-#define AXI_I2S_REG_STATUS	0x10
-#define AXI_I2S_REG_PERIOD_SIZE	0x18
-
-#define AXI_I2S_REG_RX_FIFO	0x28
-#define AXI_I2S_REG_TX_FIFO	0x2C
-
-#define AXI_I2S_RESET_GLOBAL	BIT(0)
-#define AXI_I2S_RESET_TX_FIFO	BIT(1)
-#define AXI_I2S_RESET_RX_FIFO	BIT(2)
-
-#define AXI_I2S_CTRL_TX_EN	BIT(0)
-#define AXI_I2S_CTRL_RX_EN	BIT(1)
-
-#define AXI_I2S_BITS_PER_FRAME 64
-
-static int axi_i2s_trigger(struct snd_pcm_substream *substream, int cmd,
-	struct snd_soc_dai *dai)
-{
-	struct axi_i2s *i2s = snd_soc_dai_get_drvdata(dai);
-	unsigned int mask, val;
-
-	if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)
-		mask = AXI_I2S_CTRL_RX_EN;
-	else
-		mask = AXI_I2S_CTRL_TX_EN;
-
-	switch (cmd) {
-	case SNDRV_PCM_TRIGGER_START:
-	case SNDRV_PCM_TRIGGER_RESUME:
-	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
-		val = mask;
-		break;
-	case SNDRV_PCM_TRIGGER_STOP:
-	case SNDRV_PCM_TRIGGER_SUSPEND:
-	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
-		val = 0;
-		break;
-	default:
-		return -EINVAL;
-	}
-
-	regmap_update_bits(i2s->regmap, AXI_I2S_REG_CTRL, mask, val);
-
-	return 0;
-}
-
-static int axi_i2s_hw_params(struct snd_pcm_substream *substream,
-	struct snd_pcm_hw_params *params, struct snd_soc_dai *dai)
-{
-	struct axi_i2s *i2s = snd_soc_dai_get_drvdata(dai);
-	unsigned int bclk_div, frame_size;
-	unsigned int bclk_rate;
-
-	bclk_rate = params_rate(params) * AXI_I2S_BITS_PER_FRAME;
-
-	frame_size = AXI_I2S_BITS_PER_FRAME / 2 - 1;
-	bclk_div = DIV_ROUND_UP(clk_get_rate(i2s->clk_i2s), bclk_rate) / 2 - 1;
-
-	regmap_write(i2s->regmap, AXI_I2S_REG_CLK_CTRL, (frame_size << 16) |
-	    bclk_div);
-
-	if (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {
-	    unsigned int period_size = params_period_bytes(params) / 4 - 1;
-	    regmap_write(i2s->regmap, AXI_I2S_REG_PERIOD_SIZE, period_size);
-	}
-
-	return 0;
-}
-
-static int axi_i2s_startup(struct snd_pcm_substream *substream,
-	struct snd_soc_dai *dai)
-{
-	struct axi_i2s *i2s = snd_soc_dai_get_drvdata(dai);
-	uint32_t mask;
-	int ret;
-
-	if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)
-		mask = AXI_I2S_RESET_RX_FIFO;
-	else
-		mask = AXI_I2S_RESET_TX_FIFO;
-
-	regmap_write(i2s->regmap, AXI_I2S_REG_RESET, mask);
-
-	ret = snd_pcm_hw_constraint_ratnums(substream->runtime, 0,
-			   SNDRV_PCM_HW_PARAM_RATE,
-			   &i2s->rate_constraints);
-	if (ret)
-		return ret;
-
-	return clk_prepare_enable(i2s->clk_i2s);
-}
-
-static void axi_i2s_shutdown(struct snd_pcm_substream *substream,
-	struct snd_soc_dai *dai)
-{
-	struct axi_i2s *i2s = snd_soc_dai_get_drvdata(dai);
-
-	clk_disable_unprepare(i2s->clk_i2s);
-}
-
-static int axi_i2s_dai_probe(struct snd_soc_dai *dai)
-{
-	struct axi_i2s *i2s = snd_soc_dai_get_drvdata(dai);
-
-	dai->playback_dma_data = &i2s->playback_dma_data;
-	dai->capture_dma_data = &i2s->capture_dma_data;
-
-	return 0;
-}
-
-static const struct snd_soc_dai_ops axi_i2s_dai_ops = {
-	.startup = axi_i2s_startup,
-	.shutdown = axi_i2s_shutdown,
-	.trigger = axi_i2s_trigger,
-	.hw_params = axi_i2s_hw_params,
-};
-
-static struct snd_soc_dai_driver axi_i2s_dai = {
-	.probe = axi_i2s_dai_probe,
-	.playback = {
-		.channels_min = 2,
-		.channels_max = 2,
-		.rates = SNDRV_PCM_RATE_8000_192000 | SNDRV_PCM_RATE_KNOT,
-		.formats = SNDRV_PCM_FMTBIT_S32_LE,
-	},
-	.capture = {
-		.channels_min = 2,
-		.channels_max = 2,
-		.rates = SNDRV_PCM_RATE_8000_192000 | SNDRV_PCM_RATE_KNOT,
-		.formats = SNDRV_PCM_FMTBIT_S32_LE,
-	},
-	.ops = &axi_i2s_dai_ops,
-	.symmetric_rates = 1,
-};
-
-static const struct regmap_config axi_i2s_regmap_config = {
-	.reg_bits = 32,
-	.reg_stride = 4,
-	.val_bits = 32,
-	.max_register = AXI_I2S_REG_PERIOD_SIZE,
-};
-
-static int axi_i2s_probe(struct platform_device *pdev)
-{
-	struct resource *res;
-	struct axi_i2s *i2s;
-	void __iomem *base;
-	int ret;
-
-	i2s = devm_kzalloc(&pdev->dev, sizeof(*i2s), GFP_KERNEL);
-	if (!i2s)
-		return -ENOMEM;
-
-	platform_set_drvdata(pdev, i2s);
-
-	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	base = devm_request_and_ioremap(&pdev->dev, res);
-	if (!base)
-		return -EBUSY;
-
-	i2s->regmap = devm_regmap_init_mmio(&pdev->dev, base,
-					    &axi_i2s_regmap_config);
-	if (IS_ERR(i2s->regmap))
-		return PTR_ERR(i2s->regmap);
-
-	i2s->clk = devm_clk_get(&pdev->dev, "axi");
-	if (IS_ERR(i2s->clk))
-		return PTR_ERR(i2s->clk);
-
-	i2s->clk_i2s = devm_clk_get(&pdev->dev, "i2s");
-	if (IS_ERR(i2s->clk_i2s))
-		return PTR_ERR(i2s->clk_i2s);
-
-	ret = clk_prepare_enable(i2s->clk);
-	if (ret)
-	    return ret;
-
-	i2s->playback_dma_data.addr = res->start + AXI_I2S_REG_TX_FIFO;
-	i2s->playback_dma_data.addr_width = 4;
-	i2s->playback_dma_data.maxburst = 1;
-
-	i2s->capture_dma_data.addr = res->start + AXI_I2S_REG_RX_FIFO;
-	i2s->capture_dma_data.addr_width = 4;
-	i2s->capture_dma_data.maxburst = 1;
-
-	ret = snd_soc_register_dai(&pdev->dev, &axi_i2s_dai);
-	if (ret) {
-		dev_err(&pdev->dev, "Failed to register DAI\n");
-		return ret;
-	}
-
-	i2s->ratnum.num = clk_get_rate(i2s->clk_i2s) / 2 / AXI_I2S_BITS_PER_FRAME;
-	i2s->ratnum.den_step = 1;
-	i2s->ratnum.den_min = 1;
-	i2s->ratnum.den_max = 64;
-
-	i2s->rate_constraints.rats = &i2s->ratnum;
-	i2s->rate_constraints.nrats = 1;
-
-	regmap_write(i2s->regmap, AXI_I2S_REG_RESET, AXI_I2S_RESET_GLOBAL);
-
-	ret = snd_dmaengine_pcm_register(&pdev->dev, NULL,
-		SND_DMAENGINE_PCM_FLAG_NO_RESIDUE);
-	if (ret)
-		snd_soc_unregister_dai(&pdev->dev);
-
-	return ret;
-}
-
-static int axi_i2s_dev_remove(struct platform_device *pdev)
-{
-	struct axi_i2s *i2s = platform_get_drvdata(pdev);
-	
-	clk_disable_unprepare(i2s->clk);
-
-	snd_dmaengine_pcm_unregister(&pdev->dev);
-	snd_soc_unregister_dai(&pdev->dev);
-
-	return 0;
-}
-
-static const struct of_device_id axi_i2s_of_match[] = {
-	{ .compatible = "adi,axi-i2s-1.00.a", },
-	{},
-};
-MODULE_DEVICE_TABLE(of, axi_i2s_of_match);
-
-static struct platform_driver axi_i2s_driver = {
-	.driver = {
-		.name = "axi-i2s",
-		.owner = THIS_MODULE,
-		.of_match_table = axi_i2s_of_match,
-	},
-	.probe = axi_i2s_probe,
-	.remove = axi_i2s_dev_remove,
-};
-module_platform_driver(axi_i2s_driver);
-
-MODULE_AUTHOR("Lars-Peter Clausen <lars@metafoo.de>");
-MODULE_DESCRIPTION("AXI I2S driver");
-MODULE_LICENSE("GPL");
diff --git a/sound/soc/xlnx/adv7511_hdmi.c b/sound/soc/xlnx/adv7511_hdmi.c
deleted file mode 100644
index c059c57..0000000
--- a/sound/soc/xlnx/adv7511_hdmi.c
+++ /dev/null
@@ -1,102 +0,0 @@
-/*
- *  Copyright (C) 2012, Analog Devices Inc.
- *	Author: Lars-Peter Clausen <lars@metafoo.de>
- *
- *  This program is free software; you can redistribute it and/or modify it
- *  under  the terms of the GNU General  Public License as published by the
- *  Free Software Foundation;  either version 2 of the License, or (at your
- *  option) any later version.
- *
- *  You should have received a copy of the GNU General Public License along
- *  with this program; if not, write to the Free Software Foundation, Inc.,
- *  675 Mass Ave, Cambridge, MA 02139, USA.
- *
- */
-
-#include <linux/module.h>
-#include <linux/timer.h>
-#include <linux/interrupt.h>
-#include <linux/platform_device.h>
-#include <linux/of.h>
-#include <linux/of_i2c.h>
-#include <sound/core.h>
-#include <sound/pcm.h>
-#include <sound/soc.h>
-
-static const struct snd_soc_dapm_widget adv7511_hdmi_dapm_widgets[] = {
-	SND_SOC_DAPM_SPK("Speaker", NULL),
-};
-
-static const struct snd_soc_dapm_route adv7511_hdmi_dapm_routes[] = {
-	{ "Speaker", NULL, "TMDS" },
-};
-
-static struct snd_soc_dai_link hdmi_dai_link = {
-	.name = "HDMI",
-	.stream_name = "HDMI",
-/*	.cpu_dai_name = "75c00000.axi-spdif-tx",
-	.platform_name = "xilinx_pcm_audio.2",
-	.codec_name = adv7511_codec_name,*/
-	.codec_dai_name = "adv7511",
-	.dai_fmt = SND_SOC_DAIFMT_SPDIF |
-			SND_SOC_DAIFMT_NB_NF |
-			SND_SOC_DAIFMT_CBS_CFS,
-};
-
-static struct snd_soc_card hdmi_card = {
-	.name = "HDMI monitor",
-	.owner = THIS_MODULE,
-	.dai_link = &hdmi_dai_link,
-	.num_links = 1,
-	.dapm_widgets = adv7511_hdmi_dapm_widgets,
-	.num_dapm_widgets = ARRAY_SIZE(adv7511_hdmi_dapm_widgets),
-	.dapm_routes = adv7511_hdmi_dapm_routes,
-	.num_dapm_routes = ARRAY_SIZE(adv7511_hdmi_dapm_routes),
-};
-
-static int adv7511_hdmi_probe(struct platform_device *pdev)
-{
-	struct snd_soc_card *card = &hdmi_card;
-	struct device_node *of_node = pdev->dev.of_node;
-
-	if (!of_node)
-		return -ENXIO;
-
-	card->dev = &pdev->dev;
-
-	hdmi_dai_link.codec_of_node = of_parse_phandle(of_node, "audio-codec", 0);
-	hdmi_dai_link.cpu_of_node = of_parse_phandle(of_node, "cpu-dai", 0);
-	hdmi_dai_link.platform_of_node = hdmi_dai_link.cpu_of_node;
-
-	if (!hdmi_dai_link.codec_of_node || !hdmi_dai_link.cpu_of_node)
-		return -ENXIO;
-
-	return snd_soc_register_card(card);
-}
-
-static int adv7511_hdmi_remove(struct platform_device *pdev)
-{
-	struct snd_soc_card *card = platform_get_drvdata(pdev);
-
-	snd_soc_unregister_card(card);
-
-	return 0;
-}
-
-static const struct of_device_id adv7511_hdmi_of_match[] = {
-	{ .compatible = "adv7511-hdmi-snd", },
-	{},
-};
-MODULE_DEVICE_TABLE(of, adv7511_hdmi_of_match);
-
-static struct platform_driver hdmi_card_driver = {
-	.driver = {
-		.name = "adv7511-hdmi-snd",
-		.owner = THIS_MODULE,
-		.of_match_table = adv7511_hdmi_of_match,
-		.pm = &snd_soc_pm_ops,
-	},
-	.probe = adv7511_hdmi_probe,
-	.remove = adv7511_hdmi_remove,
-};
-module_platform_driver(hdmi_card_driver);
diff --git a/sound/soc/xlnx/axi-spdif.c b/sound/soc/xlnx/axi-spdif.c
deleted file mode 100644
index 3042d62..0000000
--- a/sound/soc/xlnx/axi-spdif.c
+++ /dev/null
@@ -1,266 +0,0 @@
-/*
- *  Copyright (C) 2012, Analog Devices Inc.
- *	Author: Lars-Peter Clausen <lars@metafoo.de>
- *
- *  This program is free software; you can redistribute it and/or modify it
- *  under  the terms of the GNU General  Public License as published by the
- *  Free Software Foundation;  either version 2 of the License, or (at your
- *  option) any later version.
- *
- *  You should have received a copy of the GNU General Public License along
- *  with this program; if not, write to the Free Software Foundation, Inc.,
- *  675 Mass Ave, Cambridge, MA 02139, USA.
- *
- */
-
-#include <linux/init.h>
-#include <linux/io.h>
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/platform_device.h>
-#include <linux/slab.h>
-#include <linux/of.h>
-#include <linux/clk.h>
-#include <linux/regmap.h>
-
-#include <sound/core.h>
-#include <sound/pcm.h>
-#include <sound/pcm_params.h>
-#include <sound/soc.h>
-#include <sound/initval.h>
-#include <sound/dmaengine_pcm.h>
-
-struct axi_spdif {
-	struct regmap *regmap;
-	struct clk *clk;
-	struct clk *clk_spdif;
-
-	struct snd_dmaengine_dai_dma_data dma_data;
-
-	struct snd_ratnum ratnum;
-	struct snd_pcm_hw_constraint_ratnums rate_constraints;
-};
-
-#define AXI_SPDIF_REG_CTRL	0x0
-#define AXI_SPDIF_REG_STAT	0x4
-#define AXI_SPDIF_REG_TX_FIFO	0xc
-
-#define AXI_SPDIF_CTRL_TXDATA BIT(1)
-#define AXI_SPDIF_CTRL_TXEN BIT(0)
-#define AXI_SPDIF_CTRL_CLKDIV_OFFSET 8
-#define AXI_SPDIF_CTRL_CLKDIV_MASK (0xff << 8)
-
-#define AXI_SPDIF_FREQ_44100	(0x0 << 6)
-#define AXI_SPDIF_FREQ_48000	(0x1 << 6)
-#define AXI_SPDIF_FREQ_32000	(0x2 << 6)
-#define AXI_SPDIF_FREQ_NA	(0x3 << 6)
-
-static int axi_spdif_trigger(struct snd_pcm_substream *substream, int cmd,
-	struct snd_soc_dai *dai)
-{
-	struct axi_spdif *spdif = snd_soc_dai_get_drvdata(dai);
-	unsigned int val;
-
-	switch (cmd) {
-	case SNDRV_PCM_TRIGGER_START:
-	case SNDRV_PCM_TRIGGER_RESUME:
-	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
-		val = AXI_SPDIF_CTRL_TXDATA;
-		break;
-	case SNDRV_PCM_TRIGGER_STOP:
-	case SNDRV_PCM_TRIGGER_SUSPEND:
-	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
-		val = 0;
-		break;
-	default:
-		return -EINVAL;
-	}
-
-	regmap_update_bits(spdif->regmap, AXI_SPDIF_REG_CTRL,
-		AXI_SPDIF_CTRL_TXDATA, val);
-
-	return 0;
-}
-
-static int axi_spdif_hw_params(struct snd_pcm_substream *substream,
-	struct snd_pcm_hw_params *params, struct snd_soc_dai *dai)
-{
-	struct axi_spdif *spdif = snd_soc_dai_get_drvdata(dai);
-	unsigned int rate = params_rate(params);
-	unsigned int clkdiv, stat;
-
-	switch (params_rate(params)) {
-	case 32000:
-		stat = AXI_SPDIF_FREQ_32000;
-		break;
-	case 44100:
-		stat = AXI_SPDIF_FREQ_44100;
-		break;
-	case 48000:
-		stat = AXI_SPDIF_FREQ_48000;
-		break;
-	default:
-		stat = AXI_SPDIF_FREQ_NA;
-		break;
-	}
-
-	clkdiv = DIV_ROUND_CLOSEST(clk_get_rate(spdif->clk_spdif), rate * 64 * 2) - 1;
-	clkdiv <<= AXI_SPDIF_CTRL_CLKDIV_OFFSET;
-
-	regmap_write(spdif->regmap, AXI_SPDIF_REG_STAT, stat);
-	regmap_update_bits(spdif->regmap, AXI_SPDIF_REG_CTRL,
-		AXI_SPDIF_CTRL_CLKDIV_MASK, clkdiv);
-
-	return 0;
-}
-
-static int axi_spdif_dai_probe(struct snd_soc_dai *dai)
-{
-	struct axi_spdif *spdif = snd_soc_dai_get_drvdata(dai);
-
-	dai->playback_dma_data = &spdif->dma_data;
-
-	return 0;
-}
-
-static int axi_spdif_startup(struct snd_pcm_substream *substream,
-	struct snd_soc_dai *dai)
-{
-	struct axi_spdif *spdif = snd_soc_dai_get_drvdata(dai);
-	int ret;
-
-	regmap_update_bits(spdif->regmap, AXI_SPDIF_REG_CTRL,
-		AXI_SPDIF_CTRL_TXEN, AXI_SPDIF_CTRL_TXEN);
-
-	ret = snd_pcm_hw_constraint_ratnums(substream->runtime, 0,
-			   SNDRV_PCM_HW_PARAM_RATE,
-			   &spdif->rate_constraints);
-	if (ret)
-		return ret;
-
-	return clk_prepare_enable(spdif->clk_spdif);
-}
-
-static void axi_spdif_shutdown(struct snd_pcm_substream *substream,
-	struct snd_soc_dai *dai)
-{
-	struct axi_spdif *spdif = snd_soc_dai_get_drvdata(dai);
-
-	regmap_update_bits(spdif->regmap, AXI_SPDIF_REG_CTRL,
-		AXI_SPDIF_CTRL_TXEN, 0);
-
-	clk_disable_unprepare(spdif->clk_spdif);
-}
-
-static const struct snd_soc_dai_ops axi_spdif_dai_ops = {
-	.startup = axi_spdif_startup,
-	.shutdown = axi_spdif_shutdown,
-	.trigger = axi_spdif_trigger,
-	.hw_params = axi_spdif_hw_params,
-};
-
-static struct snd_soc_dai_driver axi_spdif_dai = {
-	.probe = axi_spdif_dai_probe,
-	.playback = {
-		.channels_min = 2,
-		.channels_max = 2,
-		.rates = SNDRV_PCM_RATE_8000_192000 | SNDRV_PCM_RATE_KNOT,
-		.formats = SNDRV_PCM_FMTBIT_S16_LE,
-	},
-	.ops = &axi_spdif_dai_ops,
-};
-
-static const struct regmap_config axi_spdif_regmap_config = {
-	.reg_bits = 32,
-	.reg_stride = 4,
-	.val_bits = 32,
-	.max_register = AXI_SPDIF_REG_STAT,
-};
-
-static int axi_spdif_probe(struct platform_device *pdev)
-{
-	struct axi_spdif *spdif;
-	struct resource *res;
-	void __iomem *base;
-	int ret;
-
-	spdif = devm_kzalloc(&pdev->dev, sizeof(*spdif), GFP_KERNEL);
-	if (!spdif)
-		return -ENOMEM;
-
-	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	base = devm_request_and_ioremap(&pdev->dev, res);
-	if (!base)
-		return -EBUSY;
-
-	spdif->regmap = devm_regmap_init_mmio(&pdev->dev, base,
-					    &axi_spdif_regmap_config);
-	if (IS_ERR(spdif->regmap))
-		return PTR_ERR(spdif->regmap);
-
-	spdif->clk = devm_clk_get(&pdev->dev, "axi");
-	if (IS_ERR(spdif->clk))
-		return PTR_ERR(spdif->clk);
-
-	spdif->clk_spdif = devm_clk_get(&pdev->dev, "spdif");
-	if (IS_ERR(spdif->clk_spdif))
-		return PTR_ERR(spdif->clk_spdif);
-
-	ret = clk_prepare_enable(spdif->clk);
-	if (ret)
-	    return ret;
-
-	spdif->dma_data.addr = res->start + AXI_SPDIF_REG_TX_FIFO;
-	spdif->dma_data.addr_width = 4;
-	spdif->dma_data.maxburst = 1;
-
-	spdif->ratnum.num = clk_get_rate(spdif->clk_spdif) / 128;
-	spdif->ratnum.den_step = 1;
-	spdif->ratnum.den_min = 1;
-	spdif->ratnum.den_max = 64;
-
-	spdif->rate_constraints.rats = &spdif->ratnum;
-	spdif->rate_constraints.nrats = 1;
-
-	platform_set_drvdata(pdev, spdif);
-
-	ret = snd_soc_register_dai(&pdev->dev, &axi_spdif_dai);
-	if (ret) {
-		dev_err(&pdev->dev, "Failed to register DAI\n");
-		return ret;
-	}
-
-	regmap_write(spdif->regmap, AXI_SPDIF_REG_CTRL, AXI_SPDIF_CTRL_TXEN);
-
-	return snd_dmaengine_pcm_register(&pdev->dev, NULL,
-		SND_DMAENGINE_PCM_FLAG_NO_RESIDUE);
-}
-
-static int axi_spdif_dev_remove(struct platform_device *pdev)
-{
-	snd_dmaengine_pcm_unregister(&pdev->dev);
-	snd_soc_unregister_dai(&pdev->dev);
-
-	return 0;
-}
-
-static const struct of_device_id axi_spdif_of_match[] = {
-	{ .compatible = "adi,axi-spdif-tx-1.00.a", },
-	{},
-};
-MODULE_DEVICE_TABLE(of, axi_spdif_of_match);
-
-static struct platform_driver axi_spdif_driver = {
-	.driver = {
-		.name = "axi-spdif",
-		.owner = THIS_MODULE,
-		.of_match_table = axi_spdif_of_match,
-	},
-	.probe = axi_spdif_probe,
-	.remove = axi_spdif_dev_remove,
-};
-module_platform_driver(axi_spdif_driver);
-
-MODULE_AUTHOR("Lars-Peter Clausen <lars@metafoo.de>");
-MODULE_DESCRIPTION("AXI SPDIF driver");
-MODULE_LICENSE("GPL");
diff --git a/sound/soc/xlnx/zed_adau1761.c b/sound/soc/xlnx/zed_adau1761.c
deleted file mode 100644
index d64caf65..0000000
--- a/sound/soc/xlnx/zed_adau1761.c
+++ /dev/null
@@ -1,164 +0,0 @@
-/*
- *  Copyright (C) 2012-2013, Analog Devices Inc.
- *	Author: Lars-Peter Clausen <lars@metafoo.de>
- *
- *  This program is free software; you can redistribute it and/or modify it
- *  under  the terms of the GNU General  Public License as published by the
- *  Free Software Foundation;  either version 2 of the License, or (at your
- *  option) any later version.
- *
- *  You should have received a copy of the GNU General Public License along
- *  with this program; if not, write to the Free Software Foundation, Inc.,
- *  675 Mass Ave, Cambridge, MA 02139, USA.
- *
- */
-
-#include <linux/module.h>
-#include <linux/timer.h>
-#include <linux/interrupt.h>
-#include <linux/platform_device.h>
-#include <linux/of.h>
-#include <sound/core.h>
-#include <sound/pcm.h>
-#include <sound/soc.h>
-#include "../codecs/adau17x1.h"
-
-static const struct snd_soc_dapm_widget zed_adau1761_widgets[] = {
-	SND_SOC_DAPM_SPK("Line Out", NULL),
-	SND_SOC_DAPM_HP("Headphone Out", NULL),
-	SND_SOC_DAPM_MIC("Mic In", NULL),
-	SND_SOC_DAPM_MIC("Line In", NULL),
-};
-
-static const struct snd_soc_dapm_route zed_adau1761_routes[] = {
-	{ "Line Out", NULL, "LOUT" },
-	{ "Line Out", NULL, "ROUT" },
-	{ "Headphone Out", NULL, "LHP" },
-	{ "Headphone Out", NULL, "RHP" },
-	{ "Mic In", NULL, "MICBIAS" },
-	{ "LINN", NULL, "Mic In" },
-	{ "RINN", NULL, "Mic In" },
-	{ "LAUX", NULL, "Line In" },
-	{ "RAUX", NULL, "Line In" },
-};
-
-static int zed_adau1761_hw_params(struct snd_pcm_substream *substream,
-	struct snd_pcm_hw_params *params)
-{
-	struct snd_soc_pcm_runtime *rtd = substream->private_data;
-	struct snd_soc_dai *codec_dai = rtd->codec_dai;
-	unsigned int pll_rate;
-	int ret;
-
-	switch (params_rate(params)) {
-	case 48000:
-	case 8000:
-	case 12000:
-	case 16000:
-	case 24000:
-	case 32000:
-	case 96000:
-		pll_rate = 48000 * 1024;
-		break;
-	case 44100:
-	case 7350:
-	case 11025:
-	case 14700:
-	case 22050:
-	case 29400:
-	case 88200:
-		pll_rate = 44100 * 1024;
-		break;
-	default:
-		return -EINVAL;
-	}
-
-	ret = snd_soc_dai_set_pll(codec_dai, ADAU17X1_PLL,
-			ADAU17X1_PLL_SRC_MCLK, 12288000, pll_rate);
-	if (ret)
-		return ret;
-
-	ret = snd_soc_dai_set_sysclk(codec_dai, ADAU17X1_CLK_SRC_PLL, pll_rate,
-			SND_SOC_CLOCK_IN);
-
-	return ret;
-}
-
-static struct snd_soc_ops zed_adau1761_ops = {
-	.hw_params = zed_adau1761_hw_params,
-};
-
-static struct snd_soc_dai_link zed_adau1761_dai_link = {
-	.name = "adau1761",
-	.stream_name = "adau1761",
-	.codec_dai_name = "adau-hifi",
-	.dai_fmt = SND_SOC_DAIFMT_I2S |
-			SND_SOC_DAIFMT_NB_NF |
-			SND_SOC_DAIFMT_CBS_CFS,
-	.ops = &zed_adau1761_ops,
-};
-
-static struct snd_soc_card zed_adau1761_card = {
-	.name = "ZED ADAU1761",
-	.owner = THIS_MODULE,
-	.dai_link = &zed_adau1761_dai_link,
-	.num_links = 1,
-	.dapm_widgets = zed_adau1761_widgets,
-	.num_dapm_widgets = ARRAY_SIZE(zed_adau1761_widgets),
-	.dapm_routes = zed_adau1761_routes,
-	.num_dapm_routes = ARRAY_SIZE(zed_adau1761_routes),
-	.fully_routed = true,
-};
-
-static int zed_adau1761_probe(struct platform_device *pdev)
-{
-	struct snd_soc_card *card = &zed_adau1761_card;
-	struct device_node *of_node = pdev->dev.of_node;
-
-	if (!of_node)
-		return -ENXIO;
-
-	card->dev = &pdev->dev;
-
-	zed_adau1761_dai_link.codec_of_node = of_parse_phandle(of_node, "audio-codec", 0);
-	zed_adau1761_dai_link.cpu_of_node = of_parse_phandle(of_node, "cpu-dai", 0);
-	zed_adau1761_dai_link.platform_of_node = zed_adau1761_dai_link.cpu_of_node;
-
-	if (!zed_adau1761_dai_link.codec_of_node ||
-		!zed_adau1761_dai_link.cpu_of_node)
-		return -ENXIO;
-
-	return snd_soc_register_card(card);
-}
-
-static int zed_adau1761_remove(struct platform_device *pdev)
-{
-	struct snd_soc_card *card = platform_get_drvdata(pdev);
-
-	snd_soc_unregister_card(card);
-
-	return 0;
-}
-
-static const struct of_device_id zed_adau1761_of_match[] = {
-	{ .compatible = "digilent,zed-sound", },
-	{},
-};
-MODULE_DEVICE_TABLE(of, zed_adau1761_of_match);
-
-static struct platform_driver zed_adau1761_card_driver = {
-	.driver = {
-		.name = "zed-adau1761-snd",
-		.owner = THIS_MODULE,
-		.of_match_table = zed_adau1761_of_match,
-		.pm = &snd_soc_pm_ops,
-	},
-	.probe = zed_adau1761_probe,
-	.remove = zed_adau1761_remove,
-};
-module_platform_driver(zed_adau1761_card_driver);
-
-MODULE_DESCRIPTION("ASoC ZED board ADAU1761 driver");
-MODULE_AUTHOR("Lars-Peter Clausen <lars@metafoo.de>");
-MODULE_LICENSE("GPL");
-MODULE_ALIAS("platform:zed-adau1761-snd");
-- 
1.7.5.4

