From d99f602f4809e1fa434505419d2ec3dfa3b4cb7b Mon Sep 17 00:00:00 2001
From: Liming Wang <liming.wang@windriver.com>
Date: Thu, 27 Mar 2014 12:05:56 +0800
Subject: [PATCH 01/20] mtd: m25p80: merge the driver based on v3.9

git://github.com/Xilinx/linux-xlnx.git xilinx-v14.7
commit 79a6cbd5 Merge tag 'v3.9' into master-next

merge following commits:

79a6cbd Merge tag 'v3.9' into master-next
068160c Merge commit 'v3.8' into master-next
7bd6da4 mtd: m25p80: Enable four byte mode for PS_QSPI
01be725 mtd: m25p80: Remove temporary hack
f465ac8 mtd: m25p80: Coding style cleanup
b176606 mtd: m25p80: Move n25q128 to different location
9a550c1 spi: m25p80: Change s25fl064k sector size from 4KB to 32KB for JFFS2
2cc8e81 driver:mtd:m25p80: fallback to 3byte mode for Spansion flashes
444998c Xilinx: ARM: MTD: m25p80: fix dual qspi bug in flash
7dae15f Xilinx: ARM: MTD: Clean up of QSPI dual support
7d0897a Merge branch 'linus' of ../linux-2.6 into master-3.5-4
7c377cf Merge branch 'linus-3.3-rc6' into master-3.3-rc6
e1cb096 Xilinx: ARM: MTD: adding support for sst25wf080 device
9cd5e25 Merge branch 'master' of ../linux-2.6-xarm into master-witharm
92ddb93 Resolved: Merge branch 'master_v3.0'; commit 'v3.0' into master_v3.0
287a301 Xilinx: ARM: QSPI PS driver: Rename driver from pss to ps
c95e98f Resolved: Merge branch 'master_v2.6.39'; commit 'v2.6.39' into master_v2.6.39
ac38ce4 Merge branch 'master' of ../linux-2.6 into master-3.0
3c9c8d4 Merge branch 'grant-mainline-v6' of /home/linnj/linux_arm/devel/linux-2.6 into master-2.6.39-rc7
142d225 Xilinx: ARM: QSPI driver: Add dual memory support
7146b1f Merge /home/linnj/linux_ppc/linux-2.6 into master-2.6.38-rc1
f4d28ad Merge /home/linnj/linux_ppc/linux-2.6 into master-2.6.37
bb2b5cb Change the w25q64 sector size information to support JFFS2. The JFFS2 minimum erase block size is 8KiB while the WinBond w25
8da7861 Xilinx: ARM: QSPI driver: Use 128 byte pages in MTD driver
4bd25e5 Xilinx: SPI flash driver: Add Numonyx flash info

Signed-off-by: Michal Simek <michal.simek@xilinx.com>
[cherry picked the m25p80 driver modification]
Signed-off-by: Liming Wang <liming.wang@windriver.com>
---
 drivers/mtd/devices/m25p80.c |   96 +++++++++++++++++++++++++++++++++--------
 1 files changed, 77 insertions(+), 19 deletions(-)

diff --git a/drivers/mtd/devices/m25p80.c b/drivers/mtd/devices/m25p80.c
index 96b6ad3..0ba554a 100644
--- a/drivers/mtd/devices/m25p80.c
+++ b/drivers/mtd/devices/m25p80.c
@@ -60,6 +60,7 @@
 
 /* Used for Spansion flashes only. */
 #define	OPCODE_BRWR		0x17	/* Bank register write */
+#define	OPCODE_BRRD		0x16	/* Bank register write */
 
 /* Status Register bits. */
 #define	SR_WIP			1	/* Write in progress */
@@ -160,6 +161,9 @@ static inline int write_disable(struct m25p *flash)
  */
 static inline int set_4byte(struct m25p *flash, u32 jedec_id, int enable)
 {
+	int ret;
+	u8 val;
+
 	switch (JEDEC_MFR(jedec_id)) {
 	case CFI_MFR_MACRONIX:
 	case 0xEF /* winbond */:
@@ -168,8 +172,18 @@ static inline int set_4byte(struct m25p *flash, u32 jedec_id, int enable)
 	default:
 		/* Spansion style */
 		flash->command[0] = OPCODE_BRWR;
-		flash->command[1] = enable << 7;
-		return spi_write(flash->spi, flash->command, 2);
+		flash->command[1] = enable << 7 ;
+		ret = spi_write(flash->spi, flash->command, 2);
+
+		/* verify the 4 byte mode is enabled */
+		flash->command[0] = OPCODE_BRRD;
+		spi_write_then_read(flash->spi, flash->command, 1, &val, 1);
+		if (val != enable << 7) {
+			dev_warn(&flash->spi->dev, "fallback to 3-byte address mode\n");
+			dev_warn(&flash->spi->dev, "maximum accessible size is 16MB\n");
+			flash->addr_width = 3;
+		}
+		return ret;
 	}
 }
 
@@ -682,7 +696,7 @@ struct flash_info {
 	u16		flags;
 #define	SECT_4K		0x01		/* OPCODE_BE_4K works uniformly */
 #define	M25P_NO_ERASE	0x02		/* No erase command needed */
-#define	SST_WRITE	0x04		/* use SST byte programming */
+#define	SECT_32K	0x04		/* OPCODE_BE_32K */
 };
 
 #define INFO(_jedec_id, _ext_id, _sector_size, _n_sectors, _flags)	\
@@ -730,7 +744,6 @@ static const struct spi_device_id m25p_ids[] = {
 	{ "en25q32b", INFO(0x1c3016, 0, 64 * 1024,  64, 0) },
 	{ "en25p64", INFO(0x1c2017, 0, 64 * 1024, 128, 0) },
 	{ "en25q64", INFO(0x1c3017, 0, 64 * 1024, 128, SECT_4K) },
-	{ "en25qh256", INFO(0x1c7019, 0, 64 * 1024, 512, 0) },
 
 	/* Everspin */
 	{ "mr25h256", CAT25_INFO(  32 * 1024, 1, 256, 2) },
@@ -743,6 +756,7 @@ static const struct spi_device_id m25p_ids[] = {
 	{ "160s33b",  INFO(0x898911, 0, 64 * 1024,  32, 0) },
 	{ "320s33b",  INFO(0x898912, 0, 64 * 1024,  64, 0) },
 	{ "640s33b",  INFO(0x898913, 0, 64 * 1024, 128, 0) },
+	{ "n25q064",  INFO(0x20ba17, 0, 64 * 1024, 128, 0) },
 
 	/* Macronix */
 	{ "mx25l2005a",  INFO(0xc22012, 0, 64 * 1024,   4, SECT_4K) },
@@ -755,10 +769,12 @@ static const struct spi_device_id m25p_ids[] = {
 	{ "mx25l12855e", INFO(0xc22618, 0, 64 * 1024, 256, 0) },
 	{ "mx25l25635e", INFO(0xc22019, 0, 64 * 1024, 512, 0) },
 	{ "mx25l25655e", INFO(0xc22619, 0, 64 * 1024, 512, 0) },
-	{ "mx66l51235l", INFO(0xc2201a, 0, 64 * 1024, 1024, 0) },
 
 	/* Micron */
-	{ "n25q064",  INFO(0x20ba17, 0, 64 * 1024, 128, 0) },
+	{ "n25q128",  INFO(0x20ba18, 0, 64 * 1024, 256, 0) },
+	{ "n25q256a", INFO(0x20ba19, 0, 64 * 1024, 512, SECT_4K) },
+	/* Numonyx flash n25q128 - FIXME check the name */
+	{ "n25q128",   INFO(0x20bb18, 0, 64 * 1024, 256, 0) },
 	{ "n25q128a11",  INFO(0x20bb18, 0, 64 * 1024, 256, 0) },
 	{ "n25q128a13",  INFO(0x20ba18, 0, 64 * 1024, 256, 0) },
 	{ "n25q256a", INFO(0x20ba19, 0, 64 * 1024, 512, SECT_4K) },
@@ -782,18 +798,22 @@ static const struct spi_device_id m25p_ids[] = {
 	{ "s25sl032a",  INFO(0x010215,      0,  64 * 1024,  64, 0) },
 	{ "s25sl064a",  INFO(0x010216,      0,  64 * 1024, 128, 0) },
 	{ "s25fl016k",  INFO(0xef4015,      0,  64 * 1024,  32, SECT_4K) },
-	{ "s25fl064k",  INFO(0xef4017,      0,  64 * 1024, 128, SECT_4K) },
+	/* s25fl064k supports 4KiB, 32KiB and 64KiB sectors erase size. */
+	/* To support JFFS2, the minimum erase size is 8KiB(>4KiB). */
+	/* And thus, the sector size of s25fl064k is set to 32KiB for */
+	/* JFFS2 support. */
+	{ "s25fl064k",  INFO(0xef4017,      0,  64 * 1024, 128, SECT_32K) },
 
 	/* SST -- large erase sizes are "overlays", "sectors" are 4K */
-	{ "sst25vf040b", INFO(0xbf258d, 0, 64 * 1024,  8, SECT_4K | SST_WRITE) },
-	{ "sst25vf080b", INFO(0xbf258e, 0, 64 * 1024, 16, SECT_4K | SST_WRITE) },
-	{ "sst25vf016b", INFO(0xbf2541, 0, 64 * 1024, 32, SECT_4K | SST_WRITE) },
-	{ "sst25vf032b", INFO(0xbf254a, 0, 64 * 1024, 64, SECT_4K | SST_WRITE) },
-	{ "sst25vf064c", INFO(0xbf254b, 0, 64 * 1024, 128, SECT_4K) },
-	{ "sst25wf512",  INFO(0xbf2501, 0, 64 * 1024,  1, SECT_4K | SST_WRITE) },
-	{ "sst25wf010",  INFO(0xbf2502, 0, 64 * 1024,  2, SECT_4K | SST_WRITE) },
-	{ "sst25wf020",  INFO(0xbf2503, 0, 64 * 1024,  4, SECT_4K | SST_WRITE) },
-	{ "sst25wf040",  INFO(0xbf2504, 0, 64 * 1024,  8, SECT_4K | SST_WRITE) },
+	{ "sst25vf040b", INFO(0xbf258d, 0, 64 * 1024,  8, SECT_4K) },
+	{ "sst25vf080b", INFO(0xbf258e, 0, 64 * 1024, 16, SECT_4K) },
+	{ "sst25vf016b", INFO(0xbf2541, 0, 64 * 1024, 32, SECT_4K) },
+	{ "sst25vf032b", INFO(0xbf254a, 0, 64 * 1024, 64, SECT_4K) },
+	{ "sst25wf512",  INFO(0xbf2501, 0, 64 * 1024,  1, SECT_4K) },
+	{ "sst25wf010",  INFO(0xbf2502, 0, 64 * 1024,  2, SECT_4K) },
+	{ "sst25wf020",  INFO(0xbf2503, 0, 64 * 1024,  4, SECT_4K) },
+	{ "sst25wf040",  INFO(0xbf2504, 0, 64 * 1024,  8, SECT_4K) },
+	{ "sst25wf080",  INFO(0xbf2505, 0, 64 * 1024,  16, SECT_4K) },
 
 	/* ST Microelectronics -- newer production may have feature updates */
 	{ "m25p05",  INFO(0x202010,  0,  32 * 1024,   2, 0) },
@@ -844,10 +864,14 @@ static const struct spi_device_id m25p_ids[] = {
 	{ "w25q32", INFO(0xef4016, 0, 64 * 1024,  64, SECT_4K) },
 	{ "w25q32dw", INFO(0xef6016, 0, 64 * 1024,  64, SECT_4K) },
 	{ "w25x64", INFO(0xef3017, 0, 64 * 1024, 128, SECT_4K) },
-	{ "w25q64", INFO(0xef4017, 0, 64 * 1024, 128, SECT_4K) },
+	/* Winbond -- w25q "blocks" are 64K, "sectors" are 32KiB */
+	/* w25q64 supports 4KiB, 32KiB and 64KiB sectors erase size. */
+	/* To support JFFS2, the minimum erase size is 8KiB(>4KiB). */
+	/* And thus, the sector size of w25q64 is set to 32KiB for */
+	/* JFFS2 support. */
+	{ "w25q64", INFO(0xef4017, 0, 64 * 1024, 128, SECT_32K) },
 	{ "w25q80", INFO(0xef5014, 0, 64 * 1024,  16, SECT_4K) },
 	{ "w25q80bl", INFO(0xef4014, 0, 64 * 1024,  16, SECT_4K) },
-	{ "w25q128", INFO(0xef4018, 0, 64 * 1024, 256, SECT_4K) },
 	{ "w25q256", INFO(0xef4019, 0, 64 * 1024, 512, SECT_4K) },
 
 	/* Catalyst / On Semiconductor -- non-JEDEC */
@@ -1010,6 +1034,37 @@ static int m25p_probe(struct spi_device *spi)
 	flash->mtd.writesize = 1;
 	flash->mtd.flags = MTD_CAP_NORFLASH;
 	flash->mtd.size = info->sector_size * info->n_sectors;
+
+#ifdef CONFIG_SPI_XILINX_PS_QSPI
+	{
+		const unsigned int *prop;
+		const struct device_node *np;
+
+		/* for Zynq, two devices (dual) QSPI (seperate bus) is supported
+		 * in which there can be two devices that appear as one to s/w
+		 * the only way to tell this mode is from the qspi controller
+		 * and if it's used, then the memory is x2 the amount
+		 */
+		np = of_get_next_parent(spi->dev.of_node);
+		prop = of_get_property(np, "is-dual", NULL);
+		if (prop) {
+			if (be32_to_cpup(prop)) {
+				info->sector_size *= 2;
+				flash->mtd.size *= 2;
+				/* This hack bypass the 4 byte mode configuration for the
+				 * qspi flash chip. It sets mtd to 4 byte mode but leave
+				 * the qspi flash in 3 byte mode (or flash default mode).
+				 * This can be issue when two 32MB flash is configured as
+				 * dual mode, it will not work if the qspi flash chip
+				 * is configured in 3 byte mode as it require 4 byte
+				 * addressing to access the entire 32MB
+				 */
+				if (flash->mtd.size > 0x1000000)
+					info->addr_width = 4;
+			}
+		}
+	}
+#endif
 	flash->mtd._erase = m25p80_erase;
 	flash->mtd._read = m25p80_read;
 
@@ -1020,7 +1075,7 @@ static int m25p_probe(struct spi_device *spi)
 	}
 
 	/* sst flash chips use AAI word program */
-	if (info->flags & SST_WRITE)
+	if (JEDEC_MFR(info->jedec_id) == CFI_MFR_SST)
 		flash->mtd._write = sst_write;
 	else
 		flash->mtd._write = m25p80_write;
@@ -1029,6 +1084,9 @@ static int m25p_probe(struct spi_device *spi)
 	if (info->flags & SECT_4K) {
 		flash->erase_opcode = OPCODE_BE_4K;
 		flash->mtd.erasesize = 4096;
+	} else if (info->flags & SECT_32K) {
+		flash->erase_opcode = OPCODE_BE_32K;
+		flash->mtd.erasesize = 32768;
 	} else {
 		flash->erase_opcode = OPCODE_SE;
 		flash->mtd.erasesize = info->sector_size;
-- 
1.7.5.4

