From 89c47abc5d82fca7057bd520195e7dc8fc421258 Mon Sep 17 00:00:00 2001
From: Pallav Joshi <pallav.joshi@xilinx.com>
Date: Mon, 15 Oct 2012 15:07:20 +0530
Subject: [PATCH 41/50] Xilinx: ARM: support for zynq_base_trd

The patch is extracted from the file:
http://download.xilinx.com/kits/zynq_base_trd_14_3.zip
Download and unzip the zip file and get from patches/zynq_base_trd_14_3.patch.

    [ zynq_base_trd patch for 14.3 (2012.3)]
    [ This patch should be applied on top of xilinx-14.3-build2-trd tag
      of git://git.xilinx.com/linux-xlnx.git tree ]

    - Added xvdma driver which uses xilinx_vdma driver for accessing vdma(s)
    - Added xsobel driver which is use for doing h/w sobel filtering
    - Added zynq_base_trd_defconfig for TRD related configuration
    - Enabled vdma driver & xvdma wrapper driver
    - Added dts file with logiCVC, xsobel and xvdma configuration
    - Enabled framebuffer console and two terminals in dts file
    - Modified mousedev driver to adjust mouse sensitivity

Signed-off-by: Pallav Joshi <pallav.joshi@xilinx.com>
[remove arch/arm/configs/zynq_base_trd_defconfig file]
Signed-off-by: Liming Wang <liming.wang@windriver.com>
---
 arch/arm/boot/dts/zynq_base_trd.dts |  420 ++++++++++++++++++++++++++++
 drivers/input/mousedev.c            |   54 ++++-
 drivers/video/Kconfig               |    2 +
 drivers/video/Makefile              |    1 +
 drivers/video/xilinx/Kconfig        |   21 ++
 drivers/video/xilinx/Makefile       |    2 +
 drivers/video/xilinx/xsobel.c       |  513 +++++++++++++++++++++++++++++++++++
 drivers/video/xilinx/xvdma.c        |  490 +++++++++++++++++++++++++++++++++
 8 files changed, 1500 insertions(+), 3 deletions(-)
 create mode 100755 arch/arm/boot/dts/zynq_base_trd.dts
 mode change 100644 => 100755 drivers/input/mousedev.c
 create mode 100755 drivers/video/xilinx/Kconfig
 create mode 100755 drivers/video/xilinx/Makefile
 create mode 100755 drivers/video/xilinx/xsobel.c
 create mode 100755 drivers/video/xilinx/xvdma.c

diff --git a/arch/arm/boot/dts/zynq_base_trd.dts b/arch/arm/boot/dts/zynq_base_trd.dts
new file mode 100755
index 0000000..47dcad9
--- /dev/null
+++ b/arch/arm/boot/dts/zynq_base_trd.dts
@@ -0,0 +1,420 @@
+/dts-v1/;
+
+/ {
+	model = "Xilinx Zynq ZC702";
+	compatible = "xlnx,zynq-zc702";
+	#address-cells = <0x1>;
+	#size-cells = <0x1>;
+	interrupt-parent = <0x1>;
+
+	memory {
+		device_type = "memory";
+		reg = <0x00000000 0x40000000>;
+	};
+	chosen {
+		bootargs = "console=tty0 console=ttyPS0,115200 root=/dev/ram rw ip=192.168.1.10:::255.255.255.0:ZC702:eth0 earlyprintk mem=768M memmap=128M$0x30000000 vmalloc=256M";
+		linux,stdout-path = "/amba@0/uart@E0001000";
+	};
+
+	soc {
+		compatible = "xlnx,zynq";
+		clock-frequency = <33333333>;
+	};
+
+	amba@0 {
+		compatible = "simple-bus";
+		#address-cells = <0x1>;
+		#size-cells = <0x1>;
+		ranges;
+
+		gic: intc@f8f01000 {
+			interrupt-controller;
+			compatible = "arm,cortex-a9-gic";
+			#interrupt-cells = <3>;
+			reg = < 0xf8f01000 0x1000 >,
+			      < 0xf8f00100 0x0100 >;
+		};
+
+		pl310@f8f02000 {
+			compatible = "arm,pl310-cache";
+			cache-unified;
+			cache-level = <2>;
+			reg = <0xf8f02000 0x1000>;
+			arm,data-latency = <3 2 2>;
+			arm,tag-latency = <2 2 2>;
+			interrupts = <0 34 4>;
+		};
+
+		uart@e0001000 {
+			compatible = "xlnx,ps7-uart-1.00.a";
+			reg = <0xe0001000 0x1000>;
+			interrupts = < 0 50 4 >;
+			interrupt-parent = <&gic>;
+			clock = <50000000>;
+		};
+
+		timer@0xf8001000 {
+			compatible = "xlnx,ps7-ttc-1.00.a";
+			reg = <0xf8001000 0x1000>;
+			interrupts = <0 10 4>,<0 11 4>,<0 12 4>;
+			interrupt-parent = <&gic>;
+			clock-frequency-timer0 = <111111111>;
+			clock-frequency-timer1 = <111111111>;
+			clock-frequency-timer2 = <111111111>;
+		};
+
+		timer@f8f00600 {
+			compatible = "arm,cortex-a9-twd-timer";
+			reg = <0xf8f00600 0x20>;
+			interrupts = <1 13 0x301>;
+			interrupt-parent = <&gic>;
+		};
+
+		swdt@f8005000 {
+			device_type = "watchdog";
+			compatible = "xlnx,ps7-wdt-1.00.a";
+			reg = <0xf8005000 0x100>;
+			clock-frequency = <111111111>;
+			interrupts = <0 9 4>;
+			interrupt-parent = <&gic>;
+			reset = <0>;
+			timeout = <10>;
+		};
+
+		scuwdt@f8f00620 {
+			device_type = "watchdog";
+			compatible = "arm,mpcore_wdt";
+			reg = <0xf8f00620 0x20>;
+			clock-frequency = <333333333>;
+			reset = <1>;
+		};
+
+		eth@e000b000 {
+			compatible = "xlnx,ps7-ethernet-1.00.a";
+			reg = <0xe000b000 0x1000>;
+			interrupts = <0 22 4>;
+			interrupt-parent = <&gic>;
+			phy-handle = <&phy0>;
+			xlnx,ptp-enet-clock = <111111111>;
+			xlnx,slcr-div0-1000Mbps = <8>;
+			xlnx,slcr-div0-100Mbps = <8>;
+			xlnx,slcr-div0-10Mbps = <8>;
+			xlnx,slcr-div1-1000Mbps = <1>;
+			xlnx,slcr-div1-100Mbps = <5>;
+			xlnx,slcr-div1-10Mbps = <50>;
+			#address-cells = <0x1>;
+			#size-cells = <0x0>;
+
+			phy0: phy@7 {
+				compatible = "marvell,88e1116r";
+				device_type = "ethernet-phy";
+				reg = <0x7>;
+			};
+		};
+
+		i2c0: i2c@e0004000 {
+			compatible = "xlnx,ps7-i2c-1.00.a";
+			reg = <0xE0004000 0x1000>;
+			interrupts = <0 25 4>;
+			interrupt-parent = <&gic>;
+			bus-id = <0>;
+			input-clk = <111111111>;
+			i2c-clk = <100000>;
+
+			#address-cells = <1>;
+			#size-cells = <0>;
+		};
+
+		sdhci@e0100000 {
+			compatible = "xlnx,ps7-sdhci-1.00.a";
+			reg = <0xe0100000 0x1000>;
+			xlnx,has-cd = <0x1>;
+			interrupts = <0 24 4>;
+			interrupt-parent = <&gic>;
+			clock-frequency = <33333000>;
+		};
+
+		usb@e0002000 {
+			compatible = "xlnx,ps7-usb-1.00.a";
+			reg = <0xe0002000 0x1000>;
+			interrupts = <0 21 4>;
+			interrupt-parent = <&gic>;
+			dr_mode = "host";
+			phy_type = "ulpi";
+		};
+
+		gpio@e000a000 {
+			compatible = "xlnx,ps7-gpio-1.00.a";
+			reg = <0xe000a000 0x1000>;
+			interrupts = <0 20 4>;
+			interrupt-parent = <&gic>;
+		};
+
+		qspi0: spi@e000d000 {
+			compatible = "xlnx,ps7-qspi-1.00.a";
+			reg = <0xE000D000 0x1000>;
+			interrupts = <0 19 4>;
+			interrupt-parent = <&gic>;
+			speed-hz = <200000000>;
+			bus-num = <1>;
+			num-chip-select = <1>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			is-dual = <0>;
+			flash@0 {
+			compatible = "n25q128";
+			reg = <0x0>;
+			spi-max-frequency = <50000000>;
+			#address-cells = <1>;
+			#size-cells = <1>;
+			partition@qspi-fsbl {
+				label = "qspi-fsbl";
+				reg = <0x0 0x80000>;
+				};
+			partition@qspi-u-boot {
+				label = "qspi-u-boot";
+				reg = <0x80000 0x80000>;
+				};
+			partition@qspi-linux {
+				label = "qspi-linux";
+				reg = <0x100000 0x500000>;
+				};
+			partition@qspi-device-tree {
+				label = "qspi-device-tree";
+				reg = <0x600000 0x20000>;
+				};
+			partition@qspi-user {
+				label = "qspi-user";
+				reg = <0x620000 0xE0000>;
+				};
+			partition@qspi-scratch {
+				label = "qspi-scratch";
+				reg = <0x700000 0x100000>;
+				};
+			partition@qspi-rootfs {
+				label = "qspi-rootfs";
+				reg = <0x800000 0x800000>;
+				};
+			};
+		};
+
+		devcfg@f8007000 {
+			compatible = "xlnx,ps7-dev-cfg-1.00.a";
+			reg = <0xf8007000 0x100>;
+			interrupts = <0 8 4>;
+			interrupt-parent = <&gic>;
+		};
+		xadc@f8007100 {
+			compatible = "xlnx,ps7-xadc-1.00.a";
+			reg = <0xf8007100 0x20>;
+			interrupts = <0 7 4>;
+			interrupt-parent = <&gic>;
+		};
+
+		axi_sobel_0: axi-sobel@0x400D0000 {
+			compatible = "xlnx,axi-sobel-1.00.a";
+			reg = < 0x400D0000 0xFFFF>;
+			interrupts = <0 55 4>;
+			interrupt-parent = <&gic>;
+		} ;
+
+		axi_vdma_0: axivdma@0x40090000 {
+			#address-cells = <1>;
+			#size-cells = <1>;
+			compatible = "xlnx,axi-vdma";
+			ranges = < 0x40090000 0x40090000 0xFFFF >;
+			reg = < 0x40090000 0xFFFF >;
+			xlnx,flush-fsync = <0x1>;
+			xlnx,include-sg = <0x0>;
+			xlnx,num-fstores = <0x3>;
+			xlnx,family = "zynq-770";
+			dma-channel@0x40090000 {
+				compatible = "xlnx,axi-vdma-s2mm-channel";
+				interrupt-parent = <&gic>;
+				interrupts = < 0 58 4 >;
+				xlnx,datawidth = <0x08>;
+				xlnx,genlock-mode = <0x0>;
+				xlnx,include-dre = <0x1>;
+				xlnx,device-id = <0x0>;
+			} ;
+		} ;
+
+		axi_vdma_1: axivdma@0x400B0000 {
+			#address-cells = <1>;
+			#size-cells = <1>;
+			compatible = "xlnx,axi-vdma";
+			ranges = < 0x400B0000 0x400B0000 0xFFFF >;
+			reg = < 0x400B0000 0xFFFF >;
+			xlnx,flush-fsync = <0x1>;
+			xlnx,include-sg = <0x0>;
+			xlnx,num-fstores = <0x3>;
+			xlnx,family = "zynq-770";
+			dma-s2mmchannel@0x400B0000 {
+				compatible = "xlnx,axi-vdma-s2mm-channel";
+				interrupt-parent = <&gic>;
+				interrupts = < 0 57 4 >;
+				xlnx,datawidth = <0x08>;
+				xlnx,genlock-mode = <0x0>;
+				xlnx,include-dre = <0x1>;
+				xlnx,device-id = <0x1>;
+			} ;
+			dma-mm2schannel@0x400B0000 {
+				compatible = "xlnx,axi-vdma-mm2s-channel";
+				interrupt-parent = <&gic>;
+				interrupts = < 0 56 4 >;
+				xlnx,datawidth = <0x08>;
+				xlnx,genlock-mode = <0x0>;
+				xlnx,include-dre = <0x1>;
+				xlnx,device-id = <0x1>;
+			} ;
+		} ;
+
+		logicvc0: logicvc@40030000 {
+			compatible = "xylon,logicvc-2.05.b", "xylon,logicvc-2.05.c";
+			reg = <0x40030000 0x6000>;
+			interrupt-parent = <&gic>;
+			interrupts = < 0 59 4 >;
+			buffer-0-offset = <1080>;
+			buffer-1-offset = <1080>;
+			buffer-2-offset = <1080>;
+			buffer-3-offset = <1080>;
+			buffer-4-offset = <1080>;
+			display-interface = <0>;
+			e-data-width = <24>;
+			e-layer = <0>;
+			interconnect-m-axi-arb-priority = <0xf>;
+			ip-license-type = <0>;
+			ip-major-revision = <2>;
+			ip-minor-revision = <5>;
+			ip-patch-level = <0>;
+			layer-0-alpha-mode = <0>;
+			layer-0-data-width = <16>;
+			layer-0-offset = <0x0>;
+			layer-1-alpha-mode = <0>;
+			layer-1-data-width = <24>;
+			layer-1-offset = <3240>;
+			layer-2-alpha-mode = <0>;
+			layer-2-data-width = <24>;
+			layer-2-offset = <6480>;
+			layer-3-alpha-mode = <0>;
+			layer-3-data-width = <24>;
+			layer-3-offset = <9720>;
+			layer-4-alpha-mode = <0>;
+			layer-4-data-width = <24>;
+			layer-4-offset = <12960>;
+			little-endian = <1>;
+			lvds-data-width = <4>;
+			mem-burst = <4>;
+			mplb-awidth = <32>;
+			mplb-dwidth = <64>;
+			mplb-native-dwidth = <32>;
+			mplb-num-masters = <8>;
+			mplb-p2p = <0>;
+			mplb-priority = <3>;
+			mplb-smallest-slave = <32>;
+			mplb-support-bursts = <1>;
+			num-of-layers = <3>;
+			pixel-data-width = <24>;
+			readable-regs = <1>;
+			regs-interface = <2>;
+			regs-little-endian = <1>;
+			row-stride = <2048>;
+			use-background = <0>;
+			use-e-rgb-input = <0>;
+			use-e-vclk-bufgmux = <1>;
+			use-io-hw-serializer = <0>;
+			use-multiplier = <2>;
+			use-serialized-blender = <0>;
+			use-size-position = <1>;
+			use-xtreme-dsp = <2>;
+			vmem-baseaddr = <0x30000000>;
+			vmem-highaddr = <0x37ffffff>;
+			vmem-data-bus-width = <64>;
+			vmem-interface = <2>;
+		};
+
+		xylon-video-params {
+			pixel-data-invert = <0>;
+			pixel-clock-active-high = <1>;
+			pixel-component-format = "ARGB";
+			pixel-component-layer = <0>,<1>;
+			active-layer = <0>;
+			videomode = "1920x1080";
+			640x480 {
+				name = "640x480";
+				refresh = <60>;
+				xres = <640>;
+				yres = <480>;
+				pixclock-khz = <25152>;
+				left-margin = <48>;
+				right-margin = <16>;
+				upper-margin = <31>;
+				lower-margin = <11>;
+				hsync-len = <96>;
+				vsync-len = <2>;
+				sync = <0>;
+				vmode = <0>;
+			};
+			800x480 {
+				name = "800x480";
+				refresh = <60>;
+				xres = <800>;
+				yres = <480>;
+				pixclock-khz = <30000>;
+				left-margin = <40>;
+				right-margin = <40>;
+				upper-margin = <29>;
+				lower-margin = <13>;
+				hsync-len = <48>;
+				vsync-len = <3>;
+				sync = <0>;
+				vmode = <0>;
+			};
+			1280x720 {
+				name = "1280x720";
+				refresh = <60>;
+				xres = <1280>;
+				yres = <720>;
+				pixclock-khz = <74250>;
+				left-margin = <220>;
+				right-margin = <110>;
+				upper-margin = <20>;
+				lower-margin = <5>;
+				hsync-len = <40>;
+				vsync-len = <5>;
+				sync = <0>;
+				vmode = <0>;
+			};
+			1680x1050 {
+				name = "1680x1050";
+				refresh = <60>;
+				xres = <1680>;
+				yres = <1050>;
+				pixclock-khz = <119000>;
+				left-margin = <80>;
+				right-margin = <48>;
+				upper-margin = <21>;
+				lower-margin = <3>;
+				hsync-len = <32>;
+				vsync-len = <6>;
+				sync = <0>;
+				vmode = <0>;
+			};
+			1920x1080 {
+				name = "1920x1080";
+				refresh = <60>;
+				xres = <1920>;
+				yres = <1080>;
+				pixclock-khz = <148500>;
+				left-margin = <148>;
+				right-margin = <88>;
+				upper-margin = <36>;
+				lower-margin = <4>;
+				hsync-len = <44>;
+				vsync-len = <5>;
+				sync = <0>;
+				vmode = <0>;
+			};
+		};
+	};
+};
diff --git a/drivers/input/mousedev.c b/drivers/input/mousedev.c
old mode 100644
new mode 100755
index 0110b5a..53e74fc
--- a/drivers/input/mousedev.c
+++ b/drivers/input/mousedev.c
@@ -53,6 +53,7 @@ module_param(tap_time, uint, 0644);
 MODULE_PARM_DESC(tap_time, "Tap time for touchpads in absolute mode (msecs)");
 
 struct mousedev_hw_data {
+	int x_accum, y_accum;
 	int dx, dy, dz;
 	int x, y;
 	int abs_event;
@@ -127,6 +128,43 @@ static void mixdev_close_devices(void);
 #define fx(i)  (mousedev->old_x[(mousedev->pkt_count - (i)) & 03])
 #define fy(i)  (mousedev->old_y[(mousedev->pkt_count - (i)) & 03])
 
+static int downsample_n = 100;
+static int downsample_d = 350;
+
+static ssize_t get_sensitivity_attr(struct device *dev,
+				struct device_attribute *devattr,
+				char *buf)
+{
+	return sprintf(buf, "%d\n", downsample_n);
+}
+
+static ssize_t set_sensitivity_attr(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t count)
+{
+	int err, val;
+
+	err = strict_strtoul(buf, 10, (unsigned long *)&val);
+	if (err)
+		return err;
+
+	downsample_n = val;
+
+	return count;
+}
+
+static DEVICE_ATTR(sensitivity, S_IWUSR | S_IRUGO,
+	get_sensitivity_attr, set_sensitivity_attr);
+
+static struct attribute *mousedev_attr[] = {
+	&dev_attr_sensitivity.attr,
+	NULL
+};
+
+static struct attribute_group mousedev_attrs = {
+	.attrs = mousedev_attr,
+};
+
 static void mousedev_touchpad_event(struct input_dev *dev,
 				    struct mousedev *mousedev,
 				    unsigned int code, int value)
@@ -137,7 +175,6 @@ static void mousedev_touchpad_event(struct input_dev *dev,
 	switch (code) {
 
 	case ABS_X:
-
 		fx(0) = value;
 		if (mousedev->touch && mousedev->pkt_count >= 2) {
 			size = input_abs_get_max(dev, ABS_X) -
@@ -214,11 +251,17 @@ static void mousedev_rel_event(struct mousedev *mousedev,
 {
 	switch (code) {
 	case REL_X:
-		mousedev->packet.dx += value;
+		mousedev->packet.x_accum += value * downsample_n;
+		mousedev->packet.dx += mousedev->packet.x_accum / downsample_d;
+		mousedev->packet.x_accum -=
+			(mousedev->packet.x_accum / downsample_d) * downsample_d;
 		break;
 
 	case REL_Y:
-		mousedev->packet.dy -= value;
+		mousedev->packet.y_accum += value * downsample_n;
+		mousedev->packet.dy -= mousedev->packet.y_accum / downsample_d;
+		mousedev->packet.y_accum -=
+			(mousedev->packet.y_accum / downsample_d) * downsample_d;
 		break;
 
 	case REL_WHEEL:
@@ -992,6 +1035,9 @@ static int mousedev_connect(struct input_handler *handler,
 		return error;
 	}
 
+	if (sysfs_create_group(&dev->dev.kobj, &mousedev_attrs))
+		pr_err("could not create mouse control file interface\n");
+
 	return 0;
 }
 
@@ -999,6 +1045,8 @@ static void mousedev_disconnect(struct input_handle *handle)
 {
 	struct mousedev *mousedev = handle->private;
 
+	sysfs_remove_group(&mousedev->dev.parent->kobj, &mousedev_attrs);
+
 	mixdev_remove_device(mousedev);
 	mousedev_destroy(mousedev);
 }
diff --git a/drivers/video/Kconfig b/drivers/video/Kconfig
index e70515e..9f6699a 100644
--- a/drivers/video/Kconfig
+++ b/drivers/video/Kconfig
@@ -26,6 +26,8 @@ source "drivers/gpu/drm/Kconfig"
 
 source "drivers/gpu/stub/Kconfig"
 
+source "drivers/video/xilinx/Kconfig"
+
 config VGASTATE
        tristate
        default n
diff --git a/drivers/video/Makefile b/drivers/video/Makefile
index cba9480..ad842ba 100644
--- a/drivers/video/Makefile
+++ b/drivers/video/Makefile
@@ -13,6 +13,7 @@ fb-objs                           := $(fb-y)
 
 obj-$(CONFIG_VT)		  += console/
 obj-$(CONFIG_LOGO)		  += logo/
+obj-$(CONFIG_XILINX_VIDEO_IP)     += xilinx/
 obj-y				  += backlight/
 
 obj-$(CONFIG_EXYNOS_VIDEO)     += exynos/
diff --git a/drivers/video/xilinx/Kconfig b/drivers/video/xilinx/Kconfig
new file mode 100755
index 0000000..24882f3
--- /dev/null
+++ b/drivers/video/xilinx/Kconfig
@@ -0,0 +1,21 @@
+#
+# Xilinx Video configuration
+#
+
+menuconfig XILINX_VIDEO_IP
+	tristate "Xilinx Video IP components"
+	---help---
+	  This adds support to include Xilinx Video IP components.
+
+
+config XILINX_VDMA_WRAPPER
+	tristate "Video DMA Wrapper"
+	depends on XILINX_VIDEO_IP && XILINX_DMA
+	---help---
+	  Enables Video DMA IP component.
+
+config XILINX_SOBEL
+	tristate "SOBEL"
+	depends on XILINX_VIDEO_IP
+	---help---
+	  Enables and configure Hardware Sobel IP.
diff --git a/drivers/video/xilinx/Makefile b/drivers/video/xilinx/Makefile
new file mode 100755
index 0000000..2103e97
--- /dev/null
+++ b/drivers/video/xilinx/Makefile
@@ -0,0 +1,2 @@
+obj-$(CONFIG_XILINX_VDMA_WRAPPER) += xvdma.o
+obj-$(CONFIG_XILINX_SOBEL) += xsobel.o
diff --git a/drivers/video/xilinx/xsobel.c b/drivers/video/xilinx/xsobel.c
new file mode 100755
index 0000000..98a1c56
--- /dev/null
+++ b/drivers/video/xilinx/xsobel.c
@@ -0,0 +1,513 @@
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/cdev.h>
+#include <linux/slab.h>
+#include <linux/fcntl.h>
+#include <linux/sysctl.h>
+#include <linux/fs.h>
+#include <linux/interrupt.h>
+#include <linux/workqueue.h>
+#include <linux/of_address.h>
+#include <linux/of_device.h>
+#include <linux/of_platform.h>
+#include <linux/of_irq.h>
+#include <asm/io.h>
+#include <asm/uaccess.h>
+
+/**
+	debug code
+**/
+#define __DEBUG_PRINT__
+#undef __DEBUG_PRINT__		//comment this line to start debugging
+
+/* Driver Related Macros */
+#define XSOBEL_MAJOR	10
+#define XSOBEL_MINOR	235
+#define DRIVER_NAME	"xsobel"
+
+#define XFILTER_IOCTL_BASE					'S'
+#define XFILTER_INIT						_IO(XFILTER_IOCTL_BASE, 0)
+#define XFILTER_START						_IO(XFILTER_IOCTL_BASE, 1)
+#define XFILTER_STOP						_IO(XFILTER_IOCTL_BASE, 2)
+#define XFILTER_WAIT_FOR_COMPLETION			_IO(XFILTER_IOCTL_BASE, 3)
+
+enum filter_mode
+{
+	E_xFilterContinousRunning,	// runs continuously. Need to issue stop to stop the execution.
+	E_xFilterOnDemandRunning		// runs on demand, each start call corresponds to single frame transfer. Automatically stops after each frame transfer.
+};
+
+struct xFilterConfig
+{
+	u32 height;
+	u32 width;
+	enum filter_mode mode;
+};
+
+// 0x00 : Control signals
+//        bit 0  - ap_start (Read/Write/SC)
+//        bit 1  - ap_done (Read/COR)
+//        bit 2  - ap_idle (Read)
+//        others - reserved
+// 0x04 : Global Interrupt Enable Register
+//        bit 0  - Global Interrupt Enable (Read/Write)
+//        others - reserved
+// 0x08 : IP Interrupt Enable Register (Read/Write)
+//        bit 0  - Channel 0 (ap_done)
+//        others - reserved
+// 0x0c : IP Interrupt Status Register (Read/TOW)
+//        bit 0  - Channel 0 (ap_done)
+//        others - reserved
+// 0x10 : reserved
+// 0x14 : Data signal of rows
+//        bit 31~0 - rows[31:0] (Read/Write)
+// 0x18 : reserved
+// 0x1c : Data signal of cols
+//        bit 31~0 - cols[31:0] (Read/Write)
+// (SC = Self Clear, COR = Clear on Read, TOW = Toggle on Write, COH = Clear on Handshake)
+
+#define XFILTER_REG_AP_CTRL        0x00
+#define XFILTER_REG_GIE            0x04
+#define XFILTER_REG_IER            0x08
+#define XFILTER_REG_ISR            0x0c
+#define XFILTER_REG_ROWS	       0x14
+#define XFILTER_REG_COLS    	   0x1c
+
+
+#define XFILTER_WR(addr, offset, val) \
+			(iowrite32((val), (addr)+(offset)))
+#define XFILTER_RD(addr, offset) \
+			(ioread32((addr) + (offset)))
+
+
+struct xFilter_drvdata {
+	resource_size_t mem_start;	// just for bookmarking
+	resource_size_t mem_end;	// just for bookmarking
+	resource_size_t mem_size;
+
+	int irq;
+	void __iomem *base_address;		/* virt. address of the control registers */
+
+	int init_done;
+	enum filter_mode mode;
+
+	spinlock_t lock;
+
+	struct tasklet_struct tasklet;
+	struct completion *frm_filter_done;
+
+	struct device *dev;
+	struct cdev cdev;				/* Char device structure */
+	dev_t devt;
+};
+
+static int xfilter_dev_id;
+
+int xfilter_isDone(struct xFilter_drvdata *drvdata) // returns 0 if not done
+{
+	return ((XFILTER_RD(drvdata->base_address,XFILTER_REG_AP_CTRL) >> 1 ) & 1);
+}
+
+int xfilter_isIdle(struct xFilter_drvdata *drvdata) // returns 0 if busy
+{
+	return ((XFILTER_RD(drvdata->base_address,XFILTER_REG_AP_CTRL) >> 2 ) & 1);
+}
+
+void xfilter_init_ioctl(struct xFilter_drvdata *drvdata, struct xFilterConfig *data)
+{
+	unsigned long flags;
+	spin_lock_irqsave(&drvdata->lock, flags);
+
+	if (!xfilter_isIdle(drvdata))
+	{
+		spin_unlock_irqrestore(&drvdata->lock, flags);
+		printk("xFilter Error : Init without stopping !! Please stop the filter first\n");
+		return;
+	}
+
+	drvdata->mode = data->mode;
+	XFILTER_WR(drvdata->base_address,XFILTER_REG_ROWS, data->height);
+	XFILTER_WR(drvdata->base_address,XFILTER_REG_COLS, data->width);
+	drvdata->init_done = 1;
+
+	//enable the interrupt global
+	XFILTER_WR(drvdata->base_address,XFILTER_REG_GIE, 1);
+
+	spin_unlock_irqrestore(&drvdata->lock, flags);
+}
+
+void xfilter_start_ioctl(struct xFilter_drvdata *drvdata)
+{
+	unsigned long flags;
+	spin_lock_irqsave(&drvdata->lock, flags);
+
+	if (!drvdata->init_done)
+	{
+		spin_unlock_irqrestore(&drvdata->lock, flags);
+		printk("xFilter Error : called start without doing init !!");
+		return;
+	}
+
+	// do following assertions
+	if (!xfilter_isIdle(drvdata))
+	{
+		spin_unlock_irqrestore(&drvdata->lock, flags);
+		printk("xFilter Error : called start when filter is not idle\n");
+		return;
+	}
+
+	if (drvdata->frm_filter_done)
+	{
+		spin_unlock_irqrestore(&drvdata->lock, flags);
+		printk("xFilter Error : frm_filter_done not NULL .. Shouldn't happen !!");
+		return;
+	}
+
+	// enable the interrupt
+	XFILTER_WR(drvdata->base_address,XFILTER_REG_IER, 1);
+
+	// start the filter
+	XFILTER_WR(drvdata->base_address,XFILTER_REG_AP_CTRL, 1);
+
+	spin_unlock_irqrestore(&drvdata->lock, flags);
+
+}
+
+
+// reset the stat of xfilter and stop the filter.
+// need to redo the init after the stop call.
+void xfilter_stop_ioctl(struct xFilter_drvdata *drvdata)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&drvdata->lock, flags);
+
+	drvdata->init_done = 0;
+	drvdata->mode = E_xFilterOnDemandRunning;
+
+	spin_unlock_irqrestore(&drvdata->lock, flags);
+
+	// leave the spin lock to make sure isr gets the chance.
+
+	spin_lock_irqsave(&drvdata->lock, flags);
+	//disable the global interrupt for xfilter
+	//TODO: make sure we disable this only after ip intr is cleared and disabled.
+	XFILTER_WR(drvdata->base_address,XFILTER_REG_GIE, 0);
+	spin_unlock_irqrestore(&drvdata->lock, flags);
+
+	//TODO: Assert for frm_filter_done == NULL
+	//TODO: wait for the idle
+
+}
+
+void xfilter_wait_ioctl(struct xFilter_drvdata *drvdata)
+{
+	unsigned long flags;
+	static struct completion cmp;
+	unsigned long tmo = msecs_to_jiffies(100);
+
+	// assert tmo for +ve values
+
+	spin_lock_irqsave(&drvdata->lock, flags);
+
+	if (!drvdata->init_done)
+	{
+		spin_unlock_irqrestore(&drvdata->lock, flags);
+		printk("xFilter Error : called wait without doing init !!");
+		return;
+	}
+
+	if (xfilter_isDone(drvdata))
+	{
+		// if the frame is already transfer than return immediately
+		spin_unlock_irqrestore(&drvdata->lock, flags);
+		return;
+	}
+
+	init_completion(&cmp);
+	drvdata->frm_filter_done = &cmp;
+
+	spin_unlock_irqrestore(&drvdata->lock, flags);
+
+	tmo = wait_for_completion_timeout(drvdata->frm_filter_done, tmo);
+	if(0 == tmo )
+		printk("xFilter Error : Timeout while waiting !!");
+
+	spin_lock_irqsave(&drvdata->lock, flags);
+	drvdata->frm_filter_done = NULL;
+	spin_unlock_irqrestore(&drvdata->lock, flags);
+}
+
+static int xsobel_open(struct inode *inode, struct file *file)
+{
+	//printk("Opening Sobel Filter IP driver from %s \n", __func__);
+	return 0;
+}
+
+static int xsobel_release(struct inode *inode, struct file *file)
+{//TODO: clean up
+	return 0;
+}
+
+static long xsobel_ioctl(struct file *file,
+                        unsigned int cmd, unsigned long arg)
+{
+	struct inode *inode = file->f_dentry->d_inode;
+	struct xFilter_drvdata *drvdata = container_of(inode->i_cdev, struct xFilter_drvdata, cdev);
+
+	struct xFilterConfig data;
+
+
+	switch (cmd) {
+	case XFILTER_INIT:
+		if (copy_from_user(&data, (void *)arg,
+				sizeof(data)))
+			return -EFAULT;
+
+		xfilter_init_ioctl(drvdata, &data);
+		break;
+
+	case XFILTER_START:
+		xfilter_start_ioctl(drvdata);
+		break;
+
+	case XFILTER_STOP:
+		xfilter_stop_ioctl(drvdata);
+		break;
+
+	case XFILTER_WAIT_FOR_COMPLETION:
+		xfilter_wait_ioctl(drvdata);
+		break;
+
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+static void xfilter_do_tasklet(unsigned long data)
+{
+	struct xFilter_drvdata *drvdata = (struct xFilter_drvdata *)data;
+	unsigned long flags;
+
+	spin_lock_irqsave(&drvdata->lock, flags);
+
+	if(drvdata->mode == E_xFilterOnDemandRunning)
+	{
+		// Do the sanity check
+		if (!xfilter_isDone(drvdata))
+		{
+			spin_unlock_irqrestore(&drvdata->lock, flags);
+			printk("xFilter Error : In tasklet without ap_done !!");
+			return;
+		}
+
+		// mark the completion here
+		if (drvdata->frm_filter_done)
+		{
+			spin_unlock_irqrestore(&drvdata->lock, flags);
+			complete(drvdata->frm_filter_done);
+			return;
+		}
+	}
+	else
+	{
+		//printk("xFilter Error : In tasklet without E_xFilterOnDemandRunning flag !! Should get here !!");
+	}
+	spin_unlock_irqrestore(&drvdata->lock, flags);
+}
+
+static irqreturn_t filter_intr_handler(int irq, void *data)
+{
+	struct xFilter_drvdata *drvdata = data;
+	u32 stat;
+	unsigned long flags;
+
+	spin_lock_irqsave(&drvdata->lock, flags);
+
+	// Disable the interrupt
+	XFILTER_WR(drvdata->base_address, XFILTER_REG_IER, 0);
+
+	// check which interrupt
+	stat = XFILTER_RD(drvdata->base_address, XFILTER_REG_ISR);
+
+	if(stat == 1) 		// Do the sanity check
+	{
+		// Clear & Ack the interrupts
+		XFILTER_WR(drvdata->base_address, XFILTER_REG_ISR,1);
+
+		// restart frame processing or set completed status
+		if (drvdata->mode == E_xFilterContinousRunning)
+		{
+			spin_unlock_irqrestore(&drvdata->lock, flags);
+			xfilter_start_ioctl(data);
+		}
+		else
+		{
+			spin_unlock_irqrestore(&drvdata->lock, flags);
+			tasklet_schedule(&drvdata->tasklet);
+		}
+
+		return IRQ_HANDLED;
+	}
+	else
+	{
+		// Assert failed
+		printk("xFilter Error : In ISR without ap done !!");
+	}
+	spin_unlock_irqrestore(&drvdata->lock, flags);
+	return IRQ_HANDLED;
+}
+
+
+static const struct file_operations xsobel_fops = {
+	.owner = THIS_MODULE,
+	.open = xsobel_open,
+	.unlocked_ioctl = xsobel_ioctl,
+	.release = xsobel_release,
+};
+
+static int __devinit
+xsobel_of_probe(struct platform_device *op)
+{
+	dev_t devt;
+	struct xFilter_drvdata *drvdata = NULL;
+	struct device *dev = &op->dev;
+	struct resource r_mem;
+	int retval;
+	devt = MKDEV(XSOBEL_MAJOR, XSOBEL_MINOR + xfilter_dev_id);
+
+	drvdata = kzalloc(sizeof(struct xFilter_drvdata), GFP_KERNEL);
+	if (!drvdata) {
+		dev_err(dev, "Couldn't allocate device private record\n");
+		retval = -ENOMEM;
+		goto failed0;
+	}
+	dev_set_drvdata(dev, (void *)drvdata);
+
+	/* Get the Sobel IP controller reg space virtual address */
+	retval = of_address_to_resource(dev->of_node, 0, &r_mem);		/* 0x400D0000 ...SOBEL_BASE */
+	if (retval) {
+		dev_warn(dev, "Invalid Address\n");
+		goto failed1;
+	}
+
+	drvdata->dev = dev;
+	drvdata->devt = devt;
+	drvdata->mem_start = r_mem.start;
+	drvdata->mem_end = r_mem.end;
+	drvdata->mem_size = r_mem.end - r_mem.start + 1;
+
+	if (!request_mem_region(drvdata->mem_start,
+				drvdata->mem_size, DRIVER_NAME)) {
+		dev_err(dev, "Couldn't lock memory region at %Lx\n",
+			(unsigned long long) drvdata->mem_start);
+		retval = -EBUSY;
+		goto failed1;
+	}
+	drvdata->base_address = ioremap(drvdata->mem_start,
+					drvdata->mem_size);
+	if (!drvdata->base_address) {
+		dev_err(dev, "ioremap() failed\n");
+		goto failed2;
+	}
+
+	/* find the IRQ line, if it exists in the device tree */
+	drvdata->irq = irq_of_parse_and_map(dev->of_node, 0);
+	retval = request_irq(drvdata->irq, filter_intr_handler, IRQF_SHARED,
+				"Xilinx-filter-controller", drvdata);
+	if (retval) {
+		dev_err(dev, "unable to request IRQ\n");
+		goto failed2;
+	}
+
+#ifdef	__DEBUG_PRINT__
+	printk("PBJ: Sobel driver Interrupt number is %d \n", drvdata->irq);
+#endif
+
+	cdev_init(&drvdata->cdev, &xsobel_fops);
+	drvdata->cdev.owner = THIS_MODULE;
+	retval = cdev_add(&drvdata->cdev, devt, 1);
+	if (retval) {
+		dev_err(dev, "cdev_add() failed\n");
+		goto failed2;
+	}
+
+	dev_info(dev,
+		"Xilinx Sobel at 0x%08X mapped to 0x%08X",
+		(unsigned int __force)r_mem.start,
+		(unsigned int __force)drvdata->base_address);
+
+	tasklet_init(&drvdata->tasklet, xfilter_do_tasklet, (unsigned long)drvdata);
+
+	drvdata->frm_filter_done = NULL;
+
+	drvdata->init_done = 0;
+	drvdata->mode = E_xFilterOnDemandRunning;
+
+	xfilter_dev_id++;
+	return 0;
+
+failed2:
+	release_mem_region(drvdata->mem_start, drvdata->mem_size);
+failed1:
+	kfree(drvdata);
+failed0:
+	return retval;
+}
+
+static int __devexit xsobel_of_remove(struct platform_device *op)
+{
+	//TODO: check this part.
+	struct xFilter_drvdata *drvdata;
+	struct device *dev = &op->dev;
+
+	drvdata = (struct xFilter_drvdata *)dev_get_drvdata(dev);
+	if (!drvdata)
+		return 0;
+
+	cdev_del(&drvdata->cdev);
+	iounmap(drvdata->base_address);
+	release_mem_region(drvdata->mem_start, drvdata->mem_size);
+	kfree(drvdata);
+	dev_set_drvdata(dev, NULL);
+
+	xfilter_dev_id--;
+
+	return 0;
+}
+
+static const struct of_device_id __devinitconst xsobel_of_match[] = {
+	{ .compatible = "xlnx,axi-sobel-1.00.a", },
+	{},
+};
+MODULE_DEVICE_TABLE(of, xsobel_of_match);
+
+static struct platform_driver xsobel_of_driver = {
+	.probe = xsobel_of_probe,
+	.remove = __devexit_p(xsobel_of_remove),
+	.driver = {
+		.name = DRIVER_NAME,
+		.owner = THIS_MODULE,
+		.of_match_table = xsobel_of_match,
+	},
+};
+
+static int __init xsobel_module_init(void)
+{
+	return platform_driver_register(&xsobel_of_driver);
+}
+
+static void __exit xsobel_module_cleanup(void)
+{
+	platform_driver_unregister(&xsobel_of_driver);
+}
+
+module_init(xsobel_module_init);
+module_exit(xsobel_module_cleanup);
+
+MODULE_AUTHOR("Xilinx, Inc. <source@xilinx.com>");
+MODULE_DESCRIPTION("Xilinx 2D Sobel  Filter Driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/video/xilinx/xvdma.c b/drivers/video/xilinx/xvdma.c
new file mode 100755
index 0000000..7d88c81
--- /dev/null
+++ b/drivers/video/xilinx/xvdma.c
@@ -0,0 +1,490 @@
+/*
+ * xvdma.c
+ *
+ * Xilinx Video DMA Driver
+ *
+ * Author: Xilinx Inc.
+ *
+ * 2002-2006 (c)Xilinx Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/cdev.h>
+#include <linux/slab.h>
+#include <linux/fcntl.h>
+#include <linux/sysctl.h>
+#include <linux/fs.h>
+#include <linux/of_address.h>
+#include <linux/of_device.h>
+#include <linux/of_platform.h>
+#include <asm/io.h>
+#include <asm/uaccess.h>
+#include <linux/dma-mapping.h>
+#include <linux/dmaengine.h>
+#include <linux/amba/xilinx_dma.h>
+
+#define DRIVER_NAME 	"xvdma"
+#define XVDMA_SUSPEND	NULL
+#define XVDMA_RESUME	NULL
+
+#define XVDMA_MAJOR	10
+#define XVDMA_MINOR	224
+
+#define MAX_DEVICES	4
+#define MAX_FRAMES	5
+#define DMA_CHAN_RESET 10
+
+#define XVDMA_IOCTL_BASE	'W'
+#define XVDMA_GET_NUM_DEVICES	_IO(XVDMA_IOCTL_BASE, 0)
+#define XVDMA_GET_DEV_INFO	_IO(XVDMA_IOCTL_BASE, 1)
+#define XVDMA_DEVICE_CONTROL	_IO(XVDMA_IOCTL_BASE, 2)
+#define XVDMA_PREP_BUF		_IO(XVDMA_IOCTL_BASE, 3)
+#define XVDMA_START_TRANSFER	_IO(XVDMA_IOCTL_BASE, 4)
+#define XVDMA_STOP_TRANSFER	_IO(XVDMA_IOCTL_BASE, 5)
+
+#define XVDMA_DEVICE_ID_SHIFT	28
+
+struct xvdma_drvdata {
+        struct device *dev;
+        struct cdev cdev;       /* Char device structure */
+        dev_t devt;
+};
+
+struct xvdma_dev
+{
+	u32 tx_chan;
+	u32 rx_chan;
+	u32 device_id;
+};
+
+struct xvdma_chan_cfg {
+	struct xilinx_dma_config config;
+	u32 chan;
+};
+
+struct xvdma_buf_info {
+	u32 chan;
+	u32 device_id;
+	u32 direction;
+	u32 shared_buffer;
+	u32 mem_type;
+	u32 fixed_buffer;
+	u32 buf_size;
+	u32 addr_base;
+	u32 frm_cnt;
+	u32 callback;
+};
+
+struct xvdma_transfer {
+	u32 chan;
+	u32 wait;
+};
+
+struct chan_buf {
+	u32 device_id;
+	dma_addr_t dma_addr[MAX_FRAMES];
+};
+
+struct xvdma_dev *xvdma_dev_info[MAX_DEVICES + 1];
+static u64 dma_mask = 0xFFFFFFFFUL;
+struct chan_buf chan_buf[MAX_FRAMES];
+u32 num_devices;
+struct completion cmp;
+
+void xvdma_get_dev_info(u32 device_id, struct xvdma_dev *dev)
+{
+	int i;
+
+	for(i = 0; i < MAX_DEVICES; i++) {
+		if (xvdma_dev_info[i]->device_id == device_id)
+			break;
+	}
+	memcpy(dev, xvdma_dev_info[i], sizeof(struct xvdma_dev));
+}
+
+/*
+ * This function is called when an application opens handle to the
+ * bridge driver.
+ */
+static int xvdma_open(struct inode *ip, struct file *filp)
+{
+	return 0;
+}
+
+static int xvdma_release(struct inode *ip, struct file *filp)
+{
+	return 0;
+}
+
+void xvdma_device_control(struct xvdma_chan_cfg *);
+void xvdma_prep_slave_sg(struct xvdma_buf_info *);
+void xvdma_start_transfer(struct xvdma_transfer *);
+void xvdma_stop_transfer(struct dma_chan *);
+
+static long xvdma_ioctl(struct file *file,
+                        unsigned int cmd, unsigned long arg)
+{
+	struct xvdma_dev xvdma_dev;
+	struct xvdma_chan_cfg chan_cfg;
+	struct xvdma_buf_info buf_info;
+	struct xvdma_transfer tx_info;
+	u32 devices, chan;
+
+	switch (cmd) {
+	case XVDMA_GET_NUM_DEVICES:
+	{
+		if (copy_from_user((void *)&devices,
+                                (const void __user *)arg,
+                                sizeof(u32)))
+                        return -EFAULT;
+
+		devices = num_devices;
+		 if (copy_to_user((u32 *)arg,
+                                &devices, sizeof(u32)))
+                        return -EFAULT;
+                break;
+	}
+	case XVDMA_GET_DEV_INFO:
+	{
+		if (copy_from_user((void *)&xvdma_dev,
+                                (const void __user *)arg,
+                                sizeof(struct xvdma_dev)))
+			return -EFAULT;
+
+		xvdma_get_dev_info(xvdma_dev.device_id, &xvdma_dev);
+
+		if (copy_to_user((struct xvdma_dev *)arg,
+                                &xvdma_dev, sizeof(struct xvdma_dev)))
+			return -EFAULT;
+		break;
+	}
+	case XVDMA_DEVICE_CONTROL:
+	{
+		if(copy_from_user((void *)&chan_cfg,
+                                (const void __user *)arg,
+                                sizeof(struct xvdma_chan_cfg)))
+			return -EFAULT;
+
+		xvdma_device_control(&chan_cfg);
+		break;
+	}
+	case XVDMA_PREP_BUF:
+	{
+		if(copy_from_user((void *)&buf_info,
+                                (const void __user *)arg,
+                                sizeof(struct xvdma_buf_info)))
+			return -EFAULT;
+		xvdma_prep_slave_sg(&buf_info);
+		break;
+	}
+	case XVDMA_START_TRANSFER:
+	{
+		if(copy_from_user((void *)&tx_info,
+                                (const void __user *)arg,
+                                sizeof(struct xvdma_transfer)))
+			return -EFAULT;
+
+		xvdma_start_transfer(&tx_info);
+		break;
+	}
+	case XVDMA_STOP_TRANSFER:
+	{
+		if(copy_from_user((void *)&chan,
+                                (const void __user *)arg,
+                                sizeof(u32)))
+			return -EFAULT;
+
+		xvdma_stop_transfer((struct dma_chan *)chan);
+		break;
+	}
+	default:
+		break;
+	}
+	return 0;
+}
+
+static bool xvdma_filter(struct dma_chan *chan, void *param)
+{
+        if (*((int *)chan->private) == *(int *)param) {
+                return true;
+        }
+
+        return false;
+}
+
+void vdma_sync_callback(void *completion)
+{
+	complete(completion);
+}
+
+void xvdma_stop_transfer(struct dma_chan *chan)
+{
+	struct dma_device *chan_dev;
+
+	if (chan) {
+		chan_dev = chan->device;
+		chan_dev->device_control(chan, DMA_TERMINATE_ALL,
+					(unsigned long)NULL);
+	}
+}
+
+void xvdma_start_transfer(struct xvdma_transfer *tx_info)
+{
+	unsigned long tmo = msecs_to_jiffies(3000);
+
+	init_completion(&cmp);
+	if (tx_info->chan)
+		dma_async_issue_pending((struct dma_chan *)tx_info->chan);
+
+	if (tx_info->wait) {
+		tmo = wait_for_completion_timeout(&cmp, tmo);
+		if(0 == tmo )
+			printk("Timeout has occured...\n");
+	}
+}
+
+void xvdma_prep_slave_sg(struct xvdma_buf_info *buf_info)
+{
+	struct dma_chan *chan;
+	struct dma_device *chan_dev;
+	struct dma_async_tx_descriptor *chan_desc;
+	struct scatterlist chansg[MAX_FRAMES];
+	dma_addr_t dma_srcs[MAX_FRAMES];
+	u8 **buf;
+	int buf_size;
+	u32 flags = 0;
+	int i;
+	u32 device_id;
+	u32 frm_cnt = buf_info->frm_cnt;
+
+	buf_size = buf_info->buf_size;
+	chan = (struct dma_chan *) buf_info->chan;
+	device_id = buf_info->device_id;
+
+	if (chan) {
+		flags = DMA_CTRL_ACK | DMA_COMPL_SKIP_DEST_UNMAP | DMA_PREP_INTERRUPT;
+
+		if (buf_info->fixed_buffer) {
+			chan_dev = chan->device;
+			sg_init_table(chansg, frm_cnt);
+			for (i = 0; i < frm_cnt; i++) {
+				if (!buf_info->shared_buffer) {
+					dma_srcs[i] = buf_info->addr_base + i * buf_size;
+					chan_buf[device_id].dma_addr[i] = dma_srcs[i];
+				}
+				sg_dma_address(&chansg[i]) = chan_buf[device_id].dma_addr[i];
+				sg_dma_len(&chansg[i]) = buf_size;
+			}
+		} else {
+			if (!buf_info->shared_buffer) {
+				buf =  kcalloc(frm_cnt + 1, sizeof(u8 *), GFP_KERNEL);
+				if (!buf)
+					printk("buf failed\n");
+
+				for (i = 0; i < frm_cnt; i++) {
+					buf[i] = kmalloc(buf_size, GFP_KERNEL);
+					if (!buf[i])
+						printk("buf[%d] failed\n", i);
+				}
+				buf[i] = NULL;
+			}
+
+			chan_dev = chan->device;
+			sg_init_table(chansg, frm_cnt);
+			for (i = 0; i < frm_cnt; i++) {
+				if (!buf_info->shared_buffer) {
+					dma_srcs[i] = dma_map_single(chan_dev->dev,
+							buf[i], buf_size,
+							buf_info->mem_type);
+					chan_buf[device_id].dma_addr[i] = dma_srcs[i];
+				}
+				sg_dma_address(&chansg[i]) =
+					chan_buf[device_id].dma_addr[i];
+				sg_dma_len(&chansg[i]) = buf_size;
+			}
+		}
+		chan_desc = chan_dev->device_prep_slave_sg(chan, chansg, frm_cnt,
+                                buf_info->direction, flags, NULL);
+		if (buf_info->callback) {
+			chan_desc->callback = vdma_sync_callback;
+			chan_desc->callback_param = &cmp;
+		}
+		chan_desc->tx_submit(chan_desc);
+	}
+}
+
+void xvdma_device_control(struct xvdma_chan_cfg *chan_cfg)
+{
+	struct dma_chan *chan;
+	struct dma_device *chan_dev;
+
+	chan = (struct dma_chan *) chan_cfg->chan;
+
+	if (chan) {
+		chan_dev = chan->device;
+		chan_dev->device_control(chan, DMA_SLAVE_CONFIG,
+					 (unsigned long)&chan_cfg->config);
+	}
+}
+
+void xvdma_add_dev_info (struct dma_chan *tx_chan,
+                                struct dma_chan *rx_chan)
+{
+	static u32 i = 0;
+
+	xvdma_dev_info[i] = (struct xvdma_dev *)
+		kzalloc(sizeof(struct xvdma_dev), GFP_KERNEL);
+
+	xvdma_dev_info[i]->tx_chan = (u32) tx_chan;
+	xvdma_dev_info[i]->rx_chan = (u32) rx_chan;
+	xvdma_dev_info[i]->device_id = i;
+	num_devices++;
+	i++;
+}
+
+void xvdma_scan_channels(void)
+{
+	dma_cap_mask_t mask;
+        u32 match_tx, match_rx;
+	struct dma_chan *tx_chan, *rx_chan;
+	u32 device_id = 0;
+
+	dma_cap_zero(mask);
+	dma_cap_set(DMA_SLAVE | DMA_PRIVATE, mask);
+
+	for(;;) {
+		match_tx = (DMA_TO_DEVICE & 0xFF) | XILINX_DMA_IP_VDMA |
+			(device_id << XVDMA_DEVICE_ID_SHIFT);
+		tx_chan = dma_request_channel(mask, xvdma_filter,
+				(void *)&match_tx);
+		match_rx = (DMA_FROM_DEVICE & 0xFF) | XILINX_DMA_IP_VDMA |
+			(device_id << XVDMA_DEVICE_ID_SHIFT);
+		rx_chan = dma_request_channel(mask, xvdma_filter,
+				(void *)&match_rx);
+
+		if (!tx_chan && !rx_chan)
+			break;
+		else
+			xvdma_add_dev_info(tx_chan, rx_chan);
+
+		device_id++;
+	}
+}
+
+void xvdma_release_channels(void)
+{
+	int i;
+
+	for(i = 0; i < MAX_DEVICES; i++) {
+		if (xvdma_dev_info[i]->tx_chan)
+			dma_release_channel((struct dma_chan *)
+				xvdma_dev_info[i]->tx_chan);
+		if (xvdma_dev_info[i]->rx_chan)
+			dma_release_channel((struct dma_chan *)
+				xvdma_dev_info[i]->rx_chan);
+	}
+}
+
+static const struct file_operations xvdma_fops = {
+	.owner = THIS_MODULE,
+	.open = xvdma_open,
+	.unlocked_ioctl = xvdma_ioctl,
+	.release = xvdma_release,
+};
+
+static int __devinit xvdma_probe(struct platform_device *pdev)
+{
+	dev_t devt;
+	struct xvdma_drvdata *drvdata = NULL;
+	struct device *dev = &pdev->dev;
+	int retval;
+
+	devt = MKDEV(XVDMA_MAJOR, XVDMA_MINOR);
+
+	drvdata = kzalloc(sizeof(struct xvdma_drvdata), GFP_KERNEL);
+	if (!drvdata) {
+		dev_err(dev, "Couldn't allocate device private record\n");
+		retval = -ENOMEM;
+		goto failed0;
+	}
+	dev_set_drvdata(dev, (void *)drvdata);
+
+	drvdata->dev = dev;
+	drvdata->devt = devt;
+
+	cdev_init(&drvdata->cdev, &xvdma_fops);
+        drvdata->cdev.owner = THIS_MODULE;
+        retval = cdev_add(&drvdata->cdev, devt, 1);
+        if (retval) {
+                dev_err(dev, "cdev_add() failed\n");
+                goto failed1;
+        }
+
+	xvdma_scan_channels();
+	dev_info(dev,
+		"Xilinx VDMA probe successful\n \
+		Devices Scanned %d\n", num_devices);
+	return 0;
+
+failed1:
+	kfree(drvdata);
+failed0:
+	return retval;
+}
+
+static int __devexit xvdma_remove(struct platform_device *op)
+{
+        struct xvdma_drvdata *drvdata;
+        struct device *dev = &op->dev;
+
+        drvdata = (struct xvdma_drvdata *)dev_get_drvdata(dev);
+        if (!drvdata)
+                return 0;
+
+	xvdma_release_channels();
+        cdev_del(&drvdata->cdev);
+        kfree(drvdata);
+        dev_set_drvdata(dev, NULL);
+
+        return 0;
+}
+
+static struct platform_driver xvdma_driver = {
+	.driver = {
+		   .name = DRIVER_NAME,
+		   },
+	.probe = xvdma_probe,
+	.remove = __devexit_p(xvdma_remove),
+	.suspend = XVDMA_SUSPEND,
+	.resume = XVDMA_RESUME,
+};
+
+static struct platform_device xvdma_device = {
+	.name = "xvdma",
+	.id = 0,
+	.dev = {
+		.platform_data = NULL,
+		.dma_mask = &dma_mask,
+		.coherent_dma_mask = 0xFFFFFFFF,
+	},
+	.resource = NULL,
+	.num_resources = 0,
+};
+
+static int __init xvdma_init(void)
+{
+	platform_device_register(&xvdma_device);
+
+	return platform_driver_register(&xvdma_driver);
+}
+
+static void __exit xvdma_exit(void)
+{
+	platform_driver_unregister(&xvdma_driver);
+}
+
+module_init(xvdma_init);
+module_exit(xvdma_exit);
-- 
1.7.0

