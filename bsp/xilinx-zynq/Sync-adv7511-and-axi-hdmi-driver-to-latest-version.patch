From acce5238ad1944b9d4bc6938500263bfca015a0c Mon Sep 17 00:00:00 2001
From: Lars-Peter Clausen <lars@metafoo.de>
Date: Mon, 11 Feb 2013 18:43:56 +0100
Subject: [PATCH 224/509] Sync adv7511 and axi-hdmi driver to latest version

https://github.com/analogdevicesinc/linux.git xcomm_zynq
commit 79780a0aefe212f2add80c565091c05f30a81d5b

Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 drivers/gpu/drm/Kconfig                         |    9 +-
 drivers/gpu/drm/Makefile                        |    1 +
 drivers/gpu/drm/adi_axi_hdmi/Kconfig            |    7 +
 drivers/gpu/drm/adi_axi_hdmi/Makefile           |    7 +
 drivers/gpu/drm/adi_axi_hdmi/axi_hdmi_crtc.c    |  191 +++++++++
 drivers/gpu/drm/adi_axi_hdmi/axi_hdmi_crtc.h    |   18 +
 drivers/gpu/drm/adi_axi_hdmi/axi_hdmi_drv.c     |  212 ++++++++++
 drivers/gpu/drm/adi_axi_hdmi/axi_hdmi_drv.h     |   38 ++
 drivers/gpu/drm/adi_axi_hdmi/axi_hdmi_encoder.c |  506 +++++++++++++++++++++++
 drivers/gpu/drm/adi_axi_hdmi/axi_hdmi_encoder.h |   15 +
 drivers/gpu/drm/i2c/adv7511.h                   |  254 +++++++++---
 drivers/gpu/drm/i2c/adv7511_audio.c             |   10 +-
 drivers/gpu/drm/i2c/adv7511_core.c              |  365 +++++++++++++---
 13 files changed, 1494 insertions(+), 139 deletions(-)
 create mode 100644 drivers/gpu/drm/adi_axi_hdmi/Kconfig
 create mode 100644 drivers/gpu/drm/adi_axi_hdmi/Makefile
 create mode 100644 drivers/gpu/drm/adi_axi_hdmi/axi_hdmi_crtc.c
 create mode 100644 drivers/gpu/drm/adi_axi_hdmi/axi_hdmi_crtc.h
 create mode 100644 drivers/gpu/drm/adi_axi_hdmi/axi_hdmi_drv.c
 create mode 100644 drivers/gpu/drm/adi_axi_hdmi/axi_hdmi_drv.h
 create mode 100644 drivers/gpu/drm/adi_axi_hdmi/axi_hdmi_encoder.c
 create mode 100644 drivers/gpu/drm/adi_axi_hdmi/axi_hdmi_encoder.h

diff --git a/drivers/gpu/drm/Kconfig b/drivers/gpu/drm/Kconfig
index 64c69ed..8c5d973 100644
--- a/drivers/gpu/drm/Kconfig
+++ b/drivers/gpu/drm/Kconfig
@@ -164,12 +164,11 @@ config DRM_SAVAGE
 
 config DRM_ENCODER_ADV7511
 	tristate "AV7511 encoder"
-	depends on I2C && DRM
+	depends on DRM && I2C
 	select REGMAP_I2C
-	select DRM_KMS_HELPER
-	select FB_SYS_FILLRECT
-	select FB_SYS_COPYAREA
-	select FB_SYS_IMAGEBLIT
+	select HDMI
+
+source "drivers/gpu/drm/adi_axi_hdmi/Kconfig"
 
 source "drivers/gpu/drm/exynos/Kconfig"
 
diff --git a/drivers/gpu/drm/Makefile b/drivers/gpu/drm/Makefile
index bf7dced..8b3c28d 100644
--- a/drivers/gpu/drm/Makefile
+++ b/drivers/gpu/drm/Makefile
@@ -55,4 +55,5 @@ obj-$(CONFIG_DRM_SHMOBILE) +=shmobile/
 obj-$(CONFIG_DRM_OMAP)	+= omapdrm/
 obj-$(CONFIG_DRM_TILCDC)	+= tilcdc/
 obj-$(CONFIG_DRM_QXL) += qxl/
+obj-$(CONFIG_DRM_ADI_AXI_HDMI) += adi_axi_hdmi/
 obj-y			+= i2c/
diff --git a/drivers/gpu/drm/adi_axi_hdmi/Kconfig b/drivers/gpu/drm/adi_axi_hdmi/Kconfig
new file mode 100644
index 0000000..cf78722
--- /dev/null
+++ b/drivers/gpu/drm/adi_axi_hdmi/Kconfig
@@ -0,0 +1,7 @@
+config DRM_ADI_AXI_HDMI
+	tristate "DRM Support for Analog Devices HDMI FPGA platforms"
+	depends on DRM
+	default	n
+	select DRM_KMS_HELPER
+	select DRM_KMS_CMA_HELPER
+	select VT_HW_CONSOLE_BINDING if FRAMEBUFFER_CONSOLE
diff --git a/drivers/gpu/drm/adi_axi_hdmi/Makefile b/drivers/gpu/drm/adi_axi_hdmi/Makefile
new file mode 100644
index 0000000..053f910
--- /dev/null
+++ b/drivers/gpu/drm/adi_axi_hdmi/Makefile
@@ -0,0 +1,7 @@
+#
+# Makefile for the drm device driver.  This driver provides support for the
+# Direct Rendering Infrastructure (DRI) in XFree86 4.1.0 and higher.
+
+adi_axi_hdmi-y := axi_hdmi_encoder.o axi_hdmi_crtc.o axi_hdmi_drv.o
+
+obj-y += adi_axi_hdmi.o
diff --git a/drivers/gpu/drm/adi_axi_hdmi/axi_hdmi_crtc.c b/drivers/gpu/drm/adi_axi_hdmi/axi_hdmi_crtc.c
new file mode 100644
index 0000000..5dc3ad5
--- /dev/null
+++ b/drivers/gpu/drm/adi_axi_hdmi/axi_hdmi_crtc.c
@@ -0,0 +1,191 @@
+/*
+ * Analog Devices AXI HDMI DRM driver.
+ *
+ * Copyright 2012 Analog Devices Inc.
+ *  Author: Lars-Peter Clausen <lars@metafoo.de>
+ *
+ * Licensed under the GPL-2.
+ */
+
+#include <linux/slab.h>
+#include <linux/dmaengine.h>
+#include <linux/amba/xilinx_dma.h>
+
+#include <drm/drmP.h>
+#include <drm/drm_crtc_helper.h>
+#include <drm/drm_gem_cma_helper.h>
+
+#include "axi_hdmi_crtc.h"
+#include "axi_hdmi_drv.h"
+#include "axi_hdmi_encoder.h"
+
+struct axi_hdmi_crtc {
+	struct drm_crtc drm_crtc;
+	struct dma_chan *dma;
+	struct xilinx_dma_config dma_config;
+	int mode;
+};
+
+static inline struct axi_hdmi_crtc *to_axi_hdmi_crtc(struct drm_crtc *crtc)
+{
+	return container_of(crtc, struct axi_hdmi_crtc, drm_crtc);
+}
+
+static int axi_hdmi_crtc_update(struct drm_crtc *crtc)
+{
+	struct axi_hdmi_crtc *axi_hdmi_crtc = to_axi_hdmi_crtc(crtc);
+	struct drm_display_mode *mode = &crtc->mode;
+	struct drm_framebuffer *fb = crtc->fb;
+	struct dma_async_tx_descriptor *desc;
+	struct drm_gem_cma_object *obj;
+	size_t offset;
+
+	if (!mode || !fb)
+		return -EINVAL;
+
+	if (axi_hdmi_crtc->mode == DRM_MODE_DPMS_ON) {
+		obj = drm_fb_cma_get_gem_obj(fb, 0);
+		if (!obj)
+			return -EINVAL;
+
+		axi_hdmi_crtc->dma_config.hsize = mode->hdisplay * fb->bits_per_pixel / 8;
+		axi_hdmi_crtc->dma_config.vsize = mode->vdisplay;
+		axi_hdmi_crtc->dma_config.stride = fb->pitches[0];
+
+		dmaengine_device_control(axi_hdmi_crtc->dma, DMA_SLAVE_CONFIG,
+			(unsigned long)&axi_hdmi_crtc->dma_config);
+
+		offset = crtc->x * fb->bits_per_pixel / 8 + crtc->y * fb->pitches[0];
+
+		desc = dmaengine_prep_slave_single(axi_hdmi_crtc->dma,
+					obj->paddr + offset,
+					mode->vdisplay * fb->pitches[0],
+					DMA_MEM_TO_DEV, 0);
+		if (!desc) {
+			pr_err("Failed to prepare DMA descriptor\n");
+			return -ENOMEM;
+		} else {
+			dmaengine_submit(desc);
+			dma_async_issue_pending(axi_hdmi_crtc->dma);
+		}
+	} else {
+		dmaengine_terminate_all(axi_hdmi_crtc->dma);
+	}
+
+	return 0;
+}
+
+static void axi_hdmi_crtc_dpms(struct drm_crtc *crtc, int mode)
+{
+	struct axi_hdmi_crtc *axi_hdmi_crtc = to_axi_hdmi_crtc(crtc);
+
+	if (axi_hdmi_crtc->mode != mode) {
+		axi_hdmi_crtc->mode = mode;
+		axi_hdmi_crtc_update(crtc);
+	}
+}
+
+static void axi_hdmi_crtc_prepare(struct drm_crtc *crtc)
+{
+	struct axi_hdmi_crtc *axi_hdmi_crtc = to_axi_hdmi_crtc(crtc);
+
+	dmaengine_terminate_all(axi_hdmi_crtc->dma);
+}
+
+static void axi_hdmi_crtc_commit(struct drm_crtc *crtc)
+{
+	struct axi_hdmi_crtc *axi_hdmi_crtc = to_axi_hdmi_crtc(crtc);
+
+	axi_hdmi_crtc->mode = DRM_MODE_DPMS_ON;
+	axi_hdmi_crtc_update(crtc);
+}
+
+static bool axi_hdmi_crtc_mode_fixup(struct drm_crtc *crtc,
+	const struct drm_display_mode *mode,
+	struct drm_display_mode *adjusted_mode)
+{
+	return true;
+}
+
+static int axi_hdmi_crtc_mode_set(struct drm_crtc *crtc,
+	struct drm_display_mode *mode, struct drm_display_mode *adjusted_mode,
+	int x, int y, struct drm_framebuffer *old_fb)
+{
+	/* We do everything in commit() */
+	return 0;
+}
+
+static int axi_hdmi_crtc_mode_set_base(struct drm_crtc *crtc, int x, int y,
+	struct drm_framebuffer *old_fb)
+{
+	return axi_hdmi_crtc_update(crtc);
+}
+
+static void axi_hdmi_crtc_load_lut(struct drm_crtc *crtc)
+{
+}
+
+static struct drm_crtc_helper_funcs axi_hdmi_crtc_helper_funcs = {
+	.dpms		= axi_hdmi_crtc_dpms,
+	.prepare	= axi_hdmi_crtc_prepare,
+	.commit		= axi_hdmi_crtc_commit,
+	.mode_fixup	= axi_hdmi_crtc_mode_fixup,
+	.mode_set	= axi_hdmi_crtc_mode_set,
+	.mode_set_base	= axi_hdmi_crtc_mode_set_base,
+	.load_lut	= axi_hdmi_crtc_load_lut,
+};
+
+static void axi_hdmi_crtc_destroy(struct drm_crtc *crtc)
+{
+	struct axi_hdmi_crtc *axi_hdmi_crtc = to_axi_hdmi_crtc(crtc);
+
+	drm_crtc_cleanup(crtc);
+	dma_release_channel(axi_hdmi_crtc->dma);
+	kfree(axi_hdmi_crtc);
+}
+
+static struct drm_crtc_funcs axi_hdmi_crtc_funcs = {
+	.set_config	= drm_crtc_helper_set_config,
+	.destroy	= axi_hdmi_crtc_destroy,
+};
+
+static bool xlnx_pcm_filter(struct dma_chan *chan, void *param)
+{
+	struct xlnx_pcm_dma_params *p = param;
+
+	return chan->device->dev->of_node == p->of_node &&
+		chan->chan_id == p->chan_id;
+}
+
+struct drm_crtc *axi_hdmi_crtc_create(struct drm_device *dev)
+{
+	struct axi_hdmi_private *p = dev->dev_private;
+	struct axi_hdmi_crtc *axi_hdmi_crtc;
+	struct drm_crtc *crtc;
+
+	dma_cap_mask_t mask;
+
+	axi_hdmi_crtc = kzalloc(sizeof(*axi_hdmi_crtc), GFP_KERNEL);
+	if (!axi_hdmi_crtc) {
+		DRM_ERROR("failed to allocate axi_hdmi crtc\n");
+		return ERR_PTR(-ENOMEM);
+	}
+
+	crtc = &axi_hdmi_crtc->drm_crtc;
+
+	dma_cap_zero(mask);
+	dma_cap_set(DMA_SLAVE, mask);
+	dma_cap_set(DMA_PRIVATE, mask);
+
+	axi_hdmi_crtc->dma = dma_request_channel(mask, xlnx_pcm_filter,
+						&p->dma_params);
+	if (!axi_hdmi_crtc->dma) {
+		kfree(axi_hdmi_crtc);
+		return ERR_PTR(-EINVAL);
+	}
+
+	drm_crtc_init(dev, crtc, &axi_hdmi_crtc_funcs);
+	drm_crtc_helper_add(crtc, &axi_hdmi_crtc_helper_funcs);
+
+	return crtc;
+}
diff --git a/drivers/gpu/drm/adi_axi_hdmi/axi_hdmi_crtc.h b/drivers/gpu/drm/adi_axi_hdmi/axi_hdmi_crtc.h
new file mode 100644
index 0000000..583a721
--- /dev/null
+++ b/drivers/gpu/drm/adi_axi_hdmi/axi_hdmi_crtc.h
@@ -0,0 +1,18 @@
+/*
+ * Analog Devices AXI HDMI DRM driver.
+ *
+ * Copyright 2012 Analog Devices Inc.
+ *  Author: Lars-Peter Clausen <lars@metafoo.de>
+ *
+ * Licensed under the GPL-2.
+ */
+
+#ifndef _AXI_HDMI_CRTC_H_
+#define _AXI_HDMI_CRTC_H_
+
+struct drm_device;
+struct drm_crtc;
+
+struct drm_crtc* axi_hdmi_crtc_create(struct drm_device *dev);
+
+#endif
diff --git a/drivers/gpu/drm/adi_axi_hdmi/axi_hdmi_drv.c b/drivers/gpu/drm/adi_axi_hdmi/axi_hdmi_drv.c
new file mode 100644
index 0000000..b75396c
--- /dev/null
+++ b/drivers/gpu/drm/adi_axi_hdmi/axi_hdmi_drv.c
@@ -0,0 +1,212 @@
+/*
+ * Analog Devices AXI HDMI DRM driver.
+ *
+ * Copyright 2012 Analog Devices Inc.
+ *  Author: Lars-Peter Clausen <lars@metafoo.de>
+ *
+ * Licensed under the GPL-2.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/of.h>
+#include <linux/i2c.h>
+#include <linux/of_address.h>
+#include <linux/of_i2c.h>
+#include <linux/clk.h>
+
+#include <drm/drmP.h>
+#include <drm/drm.h>
+#include <drm/drm_crtc_helper.h>
+#include <drm/drm_gem_cma_helper.h>
+
+#include "axi_hdmi_drv.h"
+#include "axi_hdmi_crtc.h"
+#include "axi_hdmi_encoder.h"
+
+#define DRIVER_NAME	"axi_hdmi_drm"
+#define DRIVER_DESC	"AXI HDMI DRM"
+#define DRIVER_DATE	"20120930"
+#define DRIVER_MAJOR	1
+#define DRIVER_MINOR	0
+
+static void axi_hdmi_output_poll_changed(struct drm_device *dev)
+{
+	struct axi_hdmi_private *private = dev->dev_private;
+	drm_fbdev_cma_hotplug_event(private->fbdev);
+}
+
+static struct drm_mode_config_funcs axi_hdmi_mode_config_funcs = {
+	.fb_create = drm_fb_cma_create,
+	.output_poll_changed = axi_hdmi_output_poll_changed,
+};
+
+static void axi_hdmi_mode_config_init(struct drm_device *dev)
+{
+	dev->mode_config.min_width = 0;
+	dev->mode_config.min_height = 0;
+
+	dev->mode_config.max_width = 4096;
+	dev->mode_config.max_height = 4096;
+
+	dev->mode_config.funcs = &axi_hdmi_mode_config_funcs;
+}
+
+static int axi_hdmi_load(struct drm_device *dev, unsigned long flags)
+{
+	struct axi_hdmi_private *private = dev_get_drvdata(dev->dev);
+	struct drm_encoder *encoder;
+	int ret;
+
+	dev->dev_private = private;
+
+	drm_mode_config_init(dev);
+
+	/* init kms poll for handling hpd */
+	drm_kms_helper_poll_init(dev);
+
+	axi_hdmi_mode_config_init(dev);
+
+	private->crtc = axi_hdmi_crtc_create(dev);
+	if (IS_ERR(private->crtc)) {
+		ret = PTR_ERR(private->crtc);
+		goto err_crtc;
+	}
+
+	encoder = axi_hdmi_encoder_create(dev);
+	if (IS_ERR(encoder)) {
+	    ret = PTR_ERR(encoder);
+	    goto err_crtc;
+	}
+
+	private->fbdev = drm_fbdev_cma_init(dev, 32, 1, 1);
+	if (IS_ERR(private->fbdev)) {
+		DRM_ERROR("failed to initialize drm fbdev\n");
+		ret = PTR_ERR(private->fbdev);
+		goto err_crtc;
+	}
+
+	return 0;
+
+err_crtc:
+	drm_mode_config_cleanup(dev);
+	return ret;
+}
+
+static int axi_hdmi_unload(struct drm_device *dev)
+{
+	struct axi_hdmi_private *private = dev->dev_private;
+
+	drm_fbdev_cma_fini(private->fbdev);
+	drm_kms_helper_poll_fini(dev);
+	drm_mode_config_cleanup(dev);
+
+	return 0;
+}
+
+static void axi_hdmi_lastclose(struct drm_device *dev)
+{
+	struct axi_hdmi_private *private = dev->dev_private;
+	drm_fbdev_cma_restore_mode(private->fbdev);
+}
+
+static const struct file_operations axi_hdmi_driver_fops = {
+	.owner		= THIS_MODULE,
+	.open		= drm_open,
+	.mmap		= drm_gem_cma_mmap,
+	.poll		= drm_poll,
+	.read		= drm_read,
+	.unlocked_ioctl	= drm_ioctl,
+	.release	= drm_release,
+};
+
+static struct drm_driver axi_hdmi_driver = {
+	.driver_features	= DRIVER_BUS_PLATFORM |
+				  DRIVER_MODESET | DRIVER_GEM,
+	.load			= axi_hdmi_load,
+	.unload			= axi_hdmi_unload,
+	.lastclose		= axi_hdmi_lastclose,
+	.gem_free_object	= drm_gem_cma_free_object,
+	.gem_vm_ops		= &drm_gem_cma_vm_ops,
+	.dumb_create		= drm_gem_cma_dumb_create,
+	.dumb_map_offset	= drm_gem_cma_dumb_map_offset,
+	.dumb_destroy		= drm_gem_cma_dumb_destroy,
+	.fops			= &axi_hdmi_driver_fops,
+	.name			= DRIVER_NAME,
+	.desc			= DRIVER_DESC,
+	.date			= DRIVER_DATE,
+	.major			= DRIVER_MAJOR,
+	.minor			= DRIVER_MINOR,
+};
+
+static int axi_hdmi_platform_probe(struct platform_device *pdev)
+{
+	struct axi_hdmi_private *private;
+	struct of_phandle_args dma_spec;
+	struct device_node *slave_node;
+	struct resource *res;
+	int ret;
+
+	ret = of_parse_phandle_with_args(pdev->dev.of_node, "dma-request",
+			"#dma-cells", 0, &dma_spec);
+	if (ret)
+		return ret;
+
+	private = devm_kzalloc(&pdev->dev, sizeof(*private), GFP_KERNEL);
+	if (!private)
+		return -ENOMEM;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	private->base = devm_request_and_ioremap(&pdev->dev, res);
+	if (!private->base)
+		return -EBUSY;
+
+	private->hdmi_clock = devm_clk_get(&pdev->dev, NULL);
+	if (IS_ERR(private->hdmi_clock))
+		return -EPROBE_DEFER;
+
+	slave_node = of_parse_phandle(pdev->dev.of_node, "encoder-slave", 0);
+	if (!slave_node)
+		return -EINVAL;
+	
+	private->encoder_slave = of_find_i2c_device_by_node(slave_node);
+	of_node_put(slave_node);
+
+	if (!private->encoder_slave)
+		return -EPROBE_DEFER;
+
+	private->dma_params.of_node = dma_spec.np;
+	private->dma_params.chan_id = dma_spec.args[0];
+
+	platform_set_drvdata(pdev, private);
+
+	return drm_platform_init(&axi_hdmi_driver, pdev);
+}
+
+static int axi_hdmi_platform_remove(struct platform_device *pdev)
+{
+	drm_platform_exit(&axi_hdmi_driver, pdev);
+	return 0;
+}
+
+static const struct of_device_id adv7511_encoder_of_match[] = {
+	{ .compatible = "adi,axi-hdmi-1.00.a", },
+	{},
+};
+MODULE_DEVICE_TABLE(of, adv7511_encoder_of_match);
+
+static struct platform_driver adv7511_encoder_driver = {
+	.driver = {
+		.name = "axi-hdmi",
+		.owner = THIS_MODULE,
+		.of_match_table = adv7511_encoder_of_match,
+	},
+	.probe = axi_hdmi_platform_probe,
+	.remove = axi_hdmi_platform_remove,
+};
+module_platform_driver(adv7511_encoder_driver);
+
+MODULE_LICENSE("GPLv2");
+MODULE_AUTHOR("Lars-Peter Clausen <lars@metafoo.de>");
+MODULE_DESCRIPTION("");
diff --git a/drivers/gpu/drm/adi_axi_hdmi/axi_hdmi_drv.h b/drivers/gpu/drm/adi_axi_hdmi/axi_hdmi_drv.h
new file mode 100644
index 0000000..2b8ab90
--- /dev/null
+++ b/drivers/gpu/drm/adi_axi_hdmi/axi_hdmi_drv.h
@@ -0,0 +1,38 @@
+/*
+ * Analog Devices AXI HDMI DRM driver.
+ *
+ * Copyright 2012 Analog Devices Inc.
+ *  Author: Lars-Peter Clausen <lars@metafoo.de>
+ *
+ * Licensed under the GPL-2.
+ */
+
+#ifndef _AXI_HDMI_DRV_H_
+#define _AXI_HDMI_DRV_H_
+
+#include <drm/drm.h>
+#include <drm/drm_fb_cma_helper.h>
+#include <linux/of.h>
+#include <linux/clk.h>
+
+struct xlnx_pcm_dma_params {
+	struct device_node *of_node;
+	int chan_id;
+};
+
+struct axi_hdmi_encoder;
+
+struct axi_hdmi_private {
+	struct drm_fbdev_cma *fbdev;
+	struct drm_crtc *crtc;
+	struct axi_hdmi_encoder *encoder;
+	struct i2c_client *encoder_slave;
+
+	void __iomem *base;
+
+	struct clk *hdmi_clock;
+
+	struct xlnx_pcm_dma_params dma_params;
+};
+
+#endif
diff --git a/drivers/gpu/drm/adi_axi_hdmi/axi_hdmi_encoder.c b/drivers/gpu/drm/adi_axi_hdmi/axi_hdmi_encoder.c
new file mode 100644
index 0000000..754679c
--- /dev/null
+++ b/drivers/gpu/drm/adi_axi_hdmi/axi_hdmi_encoder.c
@@ -0,0 +1,506 @@
+/*
+ * Analog Devices AXI HDMI DRM driver.
+ *
+ * Copyright 2012 Analog Devices Inc.
+ *  Author: Lars-Peter Clausen <lars@metafoo.de>
+ *
+ * Licensed under the GPL-2.
+ */
+
+#include <linux/io.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/debugfs.h>
+#include <linux/clk.h>
+
+#include <drm/drmP.h>
+#include <drm/drm_crtc_helper.h>
+#include <drm/drm_encoder_slave.h>
+
+#include "axi_hdmi_drv.h"
+
+#include "../i2c/adv7511.h"
+
+#define AXI_HDMI_REG_CTRL		0x04
+#define AXI_HDMI_REG_HTIMING1		0x08
+#define AXI_HDMI_REG_HTIMING2		0x0C
+#define AXI_HDMI_REG_VTIMING1		0x10
+#define AXI_HDMI_REG_VTIMING2		0x14
+#define AXI_HDMI_REG_STATUS		0x10
+#define AXI_HDMI_REG_COLOR_PATTERN	0x1c
+
+#define AXI_HDMI_CTRL_ENABLE		BIT(0)
+#define AXI_HDMI_CTRL_CSC_BYPASS	BIT(1)
+#define AXI_HDMI_CTRL_TPG_ENABLE	BIT(2)
+
+#define AXI_HDMI_STATUS_VMDA_UNDERFLOW	BIT(4)
+#define AXI_HDMI_STATUS_VMDA_OVERFLOW	BIT(3)
+#define AXI_HDMI_STATUS_VMDA_BE_ERROR	BIT(2)
+#define AXI_HDMI_STATUS_VMDA_TPM_OOS	BIT(1)
+#define AXI_HDMI_STATUS_HDMI_TPM_OOS	BIT(0)
+
+#define AXI_HDMI_COLOR_PATTERN_ENABLE	BIT(24)
+
+static const struct debugfs_reg32 axi_hdmi_encoder_debugfs_regs[] = {
+	{ "Control", AXI_HDMI_REG_CTRL },
+	{ "HTiming1", AXI_HDMI_REG_HTIMING1 },
+	{ "HTiming2", AXI_HDMI_REG_HTIMING2 },
+	{ "VTiming1", AXI_HDMI_REG_VTIMING1 },
+	{ "VTiming2", AXI_HDMI_REG_VTIMING2 },
+	{ "Status", AXI_HDMI_REG_STATUS },
+	{ "Colorpattern", AXI_HDMI_REG_COLOR_PATTERN },
+};
+
+static const uint16_t adv7511_csc_ycbcr_to_rgb[] = {
+	0x0734, 0x04ad, 0x0000, 0x1c1b,
+	0x1ddc, 0x04ad, 0x1f24, 0x0135,
+	0x0000, 0x04ad, 0x087c, 0x1b77,
+};
+
+struct axi_hdmi_encoder {
+	struct drm_encoder_slave encoder;
+	struct drm_connector connector;
+
+#ifdef CONFIG_DEBUG_FS
+	struct debugfs_regset32 regset;
+#endif
+};
+
+static inline struct axi_hdmi_encoder *to_axi_hdmi_encoder(struct drm_encoder *enc)
+{
+	return container_of(enc, struct axi_hdmi_encoder, encoder.base);
+}
+
+static inline struct drm_encoder *connector_to_encoder(struct drm_connector *connector)
+{
+	struct axi_hdmi_encoder *enc = container_of(connector, struct axi_hdmi_encoder, connector);
+	return &enc->encoder.base;
+}
+
+static int axi_hdmi_connector_init(struct drm_device *dev,
+	struct drm_connector *connector, struct drm_encoder *encoder);
+
+static inline struct drm_encoder_slave_funcs *
+get_slave_funcs(struct drm_encoder *enc)
+{
+	if (!to_encoder_slave(enc))
+		return NULL;
+
+	return to_encoder_slave(enc)->slave_funcs;
+}
+
+#ifdef CONFIG_DEBUG_FS
+
+static int axi_hdmi_debugfs_cp_get(void *data, u64 *val)
+{
+	struct axi_hdmi_private *private = data;
+	*val = ioread32(private->base + AXI_HDMI_REG_COLOR_PATTERN);
+	return 0;
+}
+
+static int axi_hdmi_debugfs_cp_set(void *data, u64 val)
+{
+	struct axi_hdmi_private *private = data;
+	uint32_t cp;
+
+	cp = ioread32(private->base + AXI_HDMI_REG_COLOR_PATTERN);
+	cp &= ~0xffffff;
+	cp |= val & 0xffffff;
+
+	iowrite32(0x0000000, private->base + AXI_HDMI_REG_COLOR_PATTERN);
+	iowrite32(cp, private->base + AXI_HDMI_REG_COLOR_PATTERN);
+
+	return 0;
+}
+DEFINE_SIMPLE_ATTRIBUTE(axi_hdmi_cp_fops, axi_hdmi_debugfs_cp_get,
+	axi_hdmi_debugfs_cp_set, "0x%06llx\n");
+
+enum axi_hdmi_debug_mode {
+	AXI_HDMI_MODE_NORMAL,
+	AXI_HDMI_MODE_TESTPATTERN,
+	AXI_HDMI_MODE_COLORPATTERN,
+	AXI_HDMI_MODE_CSC_BYPASS,
+};
+
+static const char * const axi_hdmi_mode_text[] = {
+	[AXI_HDMI_MODE_NORMAL] = "normal",
+	[AXI_HDMI_MODE_TESTPATTERN] = "testpattern",
+	[AXI_HDMI_MODE_COLORPATTERN] = "colorpattern",
+	[AXI_HDMI_MODE_CSC_BYPASS] = "cscbypass"
+};
+
+static ssize_t axi_hdmi_read_mode(struct file *file, char __user *userbuf,
+	size_t count, loff_t *ppos)
+{
+	struct axi_hdmi_private *private = file->private_data;
+	enum axi_hdmi_debug_mode current_mode;
+	uint32_t ctrl, cp;
+	const char *fmt;
+	size_t len = 0;
+	char buf[50];
+	int i;
+
+	ctrl = ioread32(private->base + AXI_HDMI_REG_CTRL);
+	cp = ioread32(private->base + AXI_HDMI_REG_COLOR_PATTERN);
+
+	if (cp & AXI_HDMI_COLOR_PATTERN_ENABLE)
+		current_mode = AXI_HDMI_MODE_COLORPATTERN;
+	else if (ctrl & AXI_HDMI_CTRL_TPG_ENABLE)
+		current_mode = AXI_HDMI_MODE_TESTPATTERN;
+	else if (ctrl & AXI_HDMI_CTRL_CSC_BYPASS)
+		current_mode = AXI_HDMI_MODE_CSC_BYPASS;
+	else
+		current_mode = AXI_HDMI_MODE_NORMAL;
+	
+	for (i = 0; i < ARRAY_SIZE(axi_hdmi_mode_text); i++) {
+		if (current_mode == i)
+			fmt = "[%s]%c";
+		else
+			fmt = "%s%c";
+		len += scnprintf(buf + len, sizeof(buf), fmt, axi_hdmi_mode_text[i],
+			i == ARRAY_SIZE(axi_hdmi_mode_text) - 1 ? '\n' : ' ');
+	}
+
+	return simple_read_from_buffer(userbuf, count, ppos, buf, len);
+}
+
+static ssize_t axi_hdmi_set_mode(struct file *file, const char __user *userbuf,
+	size_t count, loff_t *ppos)
+{
+	struct axi_hdmi_private *private = file->private_data;
+	uint32_t ctrl, cp;
+	char buf[20];
+	unsigned int i;
+
+	count = min_t(size_t, count, sizeof(buf) - 1);
+	if (copy_from_user(buf, userbuf, count))
+		return -EFAULT;
+
+	buf[count] = '\0';
+
+	for (i = 0; i < ARRAY_SIZE(axi_hdmi_mode_text); i++) {
+		if (sysfs_streq(axi_hdmi_mode_text[i], buf))
+			break;
+	}
+
+	if (i == ARRAY_SIZE(axi_hdmi_mode_text))
+		return -EINVAL;
+
+	ctrl = ioread32(private->base + AXI_HDMI_REG_CTRL);
+	cp = ioread32(private->base + AXI_HDMI_REG_COLOR_PATTERN);
+
+	cp &= ~AXI_HDMI_COLOR_PATTERN_ENABLE;
+	ctrl &= ~(AXI_HDMI_CTRL_CSC_BYPASS | AXI_HDMI_CTRL_TPG_ENABLE);
+
+	switch (i) {
+	case AXI_HDMI_MODE_NORMAL:
+		break;
+	case AXI_HDMI_MODE_TESTPATTERN:
+		ctrl |= AXI_HDMI_CTRL_TPG_ENABLE;
+		break;
+	case AXI_HDMI_MODE_COLORPATTERN:
+		cp |= AXI_HDMI_COLOR_PATTERN_ENABLE;
+		break;
+	case AXI_HDMI_MODE_CSC_BYPASS:
+		ctrl |= AXI_HDMI_CTRL_CSC_BYPASS;
+		break;
+	}
+
+	iowrite32(0, private->base + AXI_HDMI_REG_CTRL);
+	iowrite32(ctrl, private->base + AXI_HDMI_REG_CTRL);
+	iowrite32(cp, private->base + AXI_HDMI_REG_COLOR_PATTERN);
+
+	return count;
+}
+
+static const struct file_operations axi_hdmi_mode_fops = {
+	.open = simple_open,
+	.read = axi_hdmi_read_mode,
+	.write = axi_hdmi_set_mode,
+};
+
+static void axi_hdmi_debugfs_init(struct axi_hdmi_encoder *encoder)
+{
+	struct axi_hdmi_private *priv = encoder->encoder.base.dev->dev_private;
+
+	encoder->regset.base = priv->base;
+	encoder->regset.regs = axi_hdmi_encoder_debugfs_regs;
+	encoder->regset.nregs = ARRAY_SIZE(axi_hdmi_encoder_debugfs_regs);
+
+	debugfs_create_regset32(dev_name(encoder->encoder.base.dev->dev), S_IRUGO, NULL, &encoder->regset);
+	debugfs_create_file("color_pattern", 0600, NULL, priv, &axi_hdmi_cp_fops);
+	debugfs_create_file("mode", 0600, NULL, priv, &axi_hdmi_mode_fops);
+}
+
+#else
+
+static inline void axi_hdmi_debugfs_init(struct axi_hdmi_encoder *enc)
+{
+}
+
+#endif
+
+static void axi_hdmi_encoder_dpms(struct drm_encoder *encoder, int mode)
+{
+	struct axi_hdmi_encoder *axi_hdmi_encoder = to_axi_hdmi_encoder(encoder);
+	struct drm_connector *connector = &axi_hdmi_encoder->connector;
+	struct axi_hdmi_private *private = encoder->dev->dev_private;
+	struct drm_encoder_slave_funcs *sfuncs = get_slave_funcs(encoder);
+	struct adv7511_video_config config;
+
+	switch (mode) {
+	case DRM_MODE_DPMS_ON:
+		iowrite32(AXI_HDMI_CTRL_ENABLE, private->base + AXI_HDMI_REG_CTRL);
+		if (connector->display_info.raw_edid) {
+			struct edid *edid = (struct edid *)connector->display_info.raw_edid;
+			config.hdmi_mode = drm_detect_hdmi_monitor(edid);
+		} else {
+			config.hdmi_mode = false;
+		}
+
+		hdmi_avi_infoframe_init(&config.avi_infoframe);
+
+		config.avi_infoframe.scan_mode = HDMI_SCAN_MODE_UNDERSCAN;
+		config.csc_scaling_factor = ADV7511_CSC_SCALING_4;
+		config.csc_coefficents = adv7511_csc_ycbcr_to_rgb;
+
+		if ((connector->display_info.color_formats & DRM_COLOR_FORMAT_YCRCB422) &&
+			config.hdmi_mode) {
+			config.csc_enable = false;
+			config.avi_infoframe.colorspace = HDMI_COLORSPACE_YUV422;
+		} else {
+			config.csc_enable = true;
+			config.avi_infoframe.colorspace = HDMI_COLORSPACE_RGB;
+		}
+
+		sfuncs->set_config(encoder, &config);
+		break;
+	default:
+		iowrite32(0, private->base + AXI_HDMI_REG_CTRL);
+		break;
+	}
+
+	if (sfuncs && sfuncs->dpms)
+		sfuncs->dpms(encoder, mode);
+}
+
+static bool axi_hdmi_encoder_mode_fixup(struct drm_encoder *encoder,
+	const struct drm_display_mode *mode, struct drm_display_mode *adjusted_mode)
+{
+	struct drm_encoder_slave_funcs *sfuncs = get_slave_funcs(encoder);
+
+	if (sfuncs && sfuncs->mode_fixup)
+		return sfuncs->mode_fixup(encoder, mode, adjusted_mode);
+
+	return true;
+}
+
+static void axi_hdmi_encoder_mode_set(struct drm_encoder *encoder,
+	struct drm_display_mode *mode, struct drm_display_mode *adjusted_mode)
+{
+	struct drm_encoder_slave_funcs *sfuncs = get_slave_funcs(encoder);
+	struct axi_hdmi_private *private = encoder->dev->dev_private;
+	unsigned int h_de_min, h_de_max;
+	unsigned int v_de_min, v_de_max;
+	unsigned int htotal, hactive;
+	unsigned int vtotal, vactive;
+
+	if (sfuncs && sfuncs->mode_set)
+		sfuncs->mode_set(encoder, mode, adjusted_mode);
+
+	htotal = mode->htotal;
+	hactive = mode->hdisplay;
+	vtotal = mode->vtotal;
+	vactive = mode->vdisplay;
+
+	hactive = mode->hsync_end - mode->hsync_start;
+	vactive = mode->vsync_end - mode->vsync_start;
+
+	h_de_min =  htotal - mode->hsync_start;
+	h_de_max =  h_de_min + mode->hdisplay;
+	v_de_min =  vtotal - mode->vsync_start;
+	v_de_max =  v_de_min + mode->vdisplay;
+
+	iowrite32((hactive << 16) | htotal, private->base + AXI_HDMI_REG_HTIMING1);
+	iowrite32((h_de_min << 16) | h_de_max, private->base + AXI_HDMI_REG_HTIMING2);
+	iowrite32((vactive << 16) | vtotal, private->base + AXI_HDMI_REG_VTIMING1);
+	iowrite32((v_de_min << 16) | v_de_max, private->base + AXI_HDMI_REG_VTIMING2);
+
+	clk_set_rate(private->hdmi_clock, mode->clock * 1000);
+}
+
+static void axi_hdmi_encoder_commit(struct drm_encoder *encoder)
+{
+	axi_hdmi_encoder_dpms(encoder, DRM_MODE_DPMS_ON);
+}
+
+static void axi_hdmi_encoder_prepare(struct drm_encoder *encoder)
+{
+	axi_hdmi_encoder_dpms(encoder, DRM_MODE_DPMS_OFF);
+}
+
+static struct drm_crtc *axi_hdmi_encoder_get_crtc(struct drm_encoder *encoder)
+{
+	return encoder->crtc;
+}
+
+static struct drm_encoder_helper_funcs axi_hdmi_encoder_helper_funcs = {
+	.dpms		= axi_hdmi_encoder_dpms,
+	.mode_fixup	= axi_hdmi_encoder_mode_fixup,
+	.mode_set	= axi_hdmi_encoder_mode_set,
+	.prepare	= axi_hdmi_encoder_prepare,
+	.commit		= axi_hdmi_encoder_commit,
+	.get_crtc	= axi_hdmi_encoder_get_crtc,
+};
+
+static void axi_hdmi_encoder_destroy(struct drm_encoder *encoder)
+{
+	struct drm_encoder_slave_funcs *sfuncs = get_slave_funcs(encoder);
+	struct axi_hdmi_encoder *axi_hdmi_encoder =
+		to_axi_hdmi_encoder(encoder);
+
+	if (sfuncs && sfuncs->destroy)
+		sfuncs->destroy(encoder);
+
+	drm_encoder_cleanup(encoder);
+	encoder->dev->mode_config.num_encoder--;
+	kfree(axi_hdmi_encoder);
+}
+
+static struct drm_encoder_funcs axi_hdmi_encoder_funcs = {
+	.destroy = axi_hdmi_encoder_destroy,
+};
+
+struct drm_encoder *axi_hdmi_encoder_create(struct drm_device *dev)
+{
+	struct drm_encoder *encoder;
+	struct drm_connector *connector;
+	struct axi_hdmi_encoder *axi_hdmi_encoder;
+	struct drm_i2c_encoder_driver *encoder_drv;
+	struct axi_hdmi_private *priv = dev->dev_private;
+
+	axi_hdmi_encoder = kzalloc(sizeof(*axi_hdmi_encoder), GFP_KERNEL);
+	if (!axi_hdmi_encoder) {
+		DRM_ERROR("failed to allocate encoder\n");
+		return NULL;
+	}
+
+	encoder = &axi_hdmi_encoder->encoder.base;
+	encoder->possible_crtcs = 1;
+
+	drm_encoder_init(dev, encoder, &axi_hdmi_encoder_funcs,
+			DRM_MODE_ENCODER_TMDS);
+	drm_encoder_helper_add(encoder, &axi_hdmi_encoder_helper_funcs);
+
+	encoder_drv = to_drm_i2c_encoder_driver(priv->encoder_slave->driver);
+	encoder_drv->encoder_init(priv->encoder_slave, dev,
+		&axi_hdmi_encoder->encoder);
+
+	connector = &axi_hdmi_encoder->connector;
+
+	axi_hdmi_connector_init(dev, connector, encoder);
+	axi_hdmi_debugfs_init(axi_hdmi_encoder);
+
+	return encoder;
+}
+
+static int axi_hdmi_connector_get_modes(struct drm_connector *connector)
+{
+	struct drm_encoder *encoder = connector_to_encoder(connector);
+	struct drm_encoder_slave_funcs *sfuncs = get_slave_funcs(encoder);
+	int count = 0;
+
+	kfree(connector->display_info.raw_edid);
+	connector->display_info.raw_edid = NULL;
+
+	if (sfuncs && sfuncs->get_modes)
+		count += sfuncs->get_modes(encoder, connector);
+
+	return count;
+}
+
+static int axi_hdmi_connector_mode_valid(struct drm_connector *connector,
+	struct drm_display_mode *mode)
+{
+	if (mode->clock > 165000)
+		return MODE_CLOCK_HIGH;
+
+	if (mode->flags & DRM_MODE_FLAG_INTERLACE)
+		return MODE_NO_INTERLACE;
+
+	return MODE_OK;
+}
+
+static struct drm_encoder *axi_hdmi_best_encoder(struct drm_connector *connector)
+{
+	return connector_to_encoder(connector);
+}
+
+static struct drm_connector_helper_funcs axi_hdmi_connector_helper_funcs = {
+	.get_modes	= axi_hdmi_connector_get_modes,
+	.mode_valid	= axi_hdmi_connector_mode_valid,
+	.best_encoder	= axi_hdmi_best_encoder,
+};
+
+static enum drm_connector_status axi_hdmi_connector_detect(
+	struct drm_connector *connector, bool force)
+{
+	enum drm_connector_status status = connector_status_unknown;
+	struct drm_encoder *encoder = connector_to_encoder(connector);
+	struct drm_encoder_slave_funcs *sfuncs = get_slave_funcs(encoder);
+
+	if (sfuncs && sfuncs->detect)
+		status = sfuncs->detect(encoder, connector);
+
+	return status;
+}
+
+static void axi_hdmi_connector_destroy(struct drm_connector *connector)
+{
+	drm_sysfs_connector_remove(connector);
+	drm_connector_cleanup(connector);
+}
+
+static struct drm_connector_funcs axi_hdmi_connector_funcs = {
+	.dpms		= drm_helper_connector_dpms,
+	.fill_modes	= drm_helper_probe_single_connector_modes,
+	.detect		= axi_hdmi_connector_detect,
+	.destroy	= axi_hdmi_connector_destroy,
+};
+
+static int axi_hdmi_connector_init(struct drm_device *dev,
+	struct drm_connector *connector, struct drm_encoder *encoder)
+{
+	int type;
+	int err;
+
+	type = DRM_MODE_CONNECTOR_HDMIA;
+	connector->polled = DRM_CONNECTOR_POLL_CONNECT |
+				DRM_CONNECTOR_POLL_DISCONNECT;
+
+	drm_connector_init(dev, connector, &axi_hdmi_connector_funcs, type);
+	drm_connector_helper_add(connector, &axi_hdmi_connector_helper_funcs);
+
+	err = drm_sysfs_connector_add(connector);
+	if (err)
+		goto err_connector;
+
+	connector->encoder = encoder;
+
+	err = drm_mode_connector_attach_encoder(connector, encoder);
+	if (err) {
+		DRM_ERROR("failed to attach a connector to a encoder\n");
+		goto err_sysfs;
+	}
+
+	return 0;
+
+err_sysfs:
+	drm_sysfs_connector_remove(connector);
+err_connector:
+	drm_connector_cleanup(connector);
+	return err;
+}
diff --git a/drivers/gpu/drm/adi_axi_hdmi/axi_hdmi_encoder.h b/drivers/gpu/drm/adi_axi_hdmi/axi_hdmi_encoder.h
new file mode 100644
index 0000000..0e951b5
--- /dev/null
+++ b/drivers/gpu/drm/adi_axi_hdmi/axi_hdmi_encoder.h
@@ -0,0 +1,15 @@
+/*
+ * Analog Devices AXI HDMI DRM driver.
+ *
+ * Copyright 2012 Analog Devices Inc.
+ *  Author: Lars-Peter Clausen <lars@metafoo.de>
+ *
+ * Licensed under the GPL-2.
+ */
+
+#ifndef _AXI_HDMI_ENCODER_H_
+#define _AXI_HDMI_ENCODER_H_
+
+struct drm_encoder *axi_hdmi_encoder_create(struct drm_device *dev);
+
+#endif
diff --git a/drivers/gpu/drm/i2c/adv7511.h b/drivers/gpu/drm/i2c/adv7511.h
index 40a860e..918c669 100644
--- a/drivers/gpu/drm/i2c/adv7511.h
+++ b/drivers/gpu/drm/i2c/adv7511.h
@@ -9,6 +9,8 @@
 #ifndef __ADV7511_H__
 #define __ADV7511_H__
 
+#include <linux/hdmi.h>
+
 #define ADV7511_REG_CHIP_REVISION		0x00
 #define ADV7511_REG_N0				0x01
 #define ADV7511_REG_N1				0x02
@@ -49,6 +51,7 @@
 #define ADV7511_REG_PACKET_I2C_ADDR		0x45
 #define ADV7511_REG_DSD_ENABLE			0x46
 #define ADV7511_REG_VIDEO_INPUT_CFG2		0x48
+#define ADV7511_REG_INFOFRAME_UPDATE		0x4a
 #define ADV7511_REG_GC(x)			(0x4b + (x)) /* 0x4b - 0x51 */
 #define ADV7511_REG_AVI_INFOFRAME_VERSION	0x52
 #define ADV7511_REG_AVI_INFOFRAME_LENGTH	0x53
@@ -173,34 +176,20 @@
 #define ADV7511_I2S_FORMAT_RIGHT_J		1
 #define ADV7511_I2S_FORMAT_LEFT_J		2
 
+#define ADV7511_PACKET(p, x)	    ((p) * 0x20 + (x))
+#define ADV7511_PACKET_SDP(x)	    ADV7511_PACKET(0, x)
+#define ADV7511_PACKET_MPEG(x)	    ADV7511_PACKET(1, x)
+#define ADV7511_PACKET_ACP(x)	    ADV7511_PACKET(2, x)
+#define ADV7511_PACKET_ISRC1(x)	    ADV7511_PACKET(3, x)
+#define ADV7511_PACKET_ISRC2(x)	    ADV7511_PACKET(4, x)
+#define ADV7511_PACKET_GM(x)	    ADV7511_PACKET(5, x)
+#define ADV7511_PACKET_SPARE(x)	    ADV7511_PACKET(6, x)
+
 #include <drm/drmP.h>
 
 struct i2c_client;
 struct regmap;
-
-struct adv7511 {
-	struct i2c_client *i2c_main;
-	struct i2c_client *i2c_edid;
-	struct i2c_client *i2c_packet;
-	struct i2c_client *i2c_cec;
-
-	struct regmap *regmap;
-	enum drm_connector_status status;
-	int dpms_mode;
-
-	unsigned int f_tmds;
-	unsigned int f_audio;
-
-	unsigned int audio_source;
-
-	unsigned int current_edid_segment;
-	uint8_t edid_buf[256];
-
-	wait_queue_head_t wq;
-	struct drm_encoder *encoder;
-
-	bool embedded_sync;
-};
+struct adv7511;
 
 int adv7511_packet_enable(struct adv7511 *adv7511, unsigned int packet);
 int adv7511_packet_disable(struct adv7511 *adv7511, unsigned int packet);
@@ -208,6 +197,28 @@ int adv7511_packet_disable(struct adv7511 *adv7511, unsigned int packet);
 int adv7511_audio_init(struct device *dev);
 void adv7511_audio_exit(struct device *dev);
 
+/**
+ * enum adv7511_input_style - Selects the input format style
+ * ADV7511_INPUT_STYLE1: Use input style 1
+ * ADV7511_INPUT_STYLE2: Use input style 2
+ * ADV7511_INPUT_STYLE3: Use input style 3
+ **/
+enum adv7511_input_style {
+	ADV7511_INPUT_STYLE1 = 2,
+	ADV7511_INPUT_STYLE2 = 1,
+	ADV7511_INPUT_STYLE3 = 3,
+};
+
+/**
+ * enum adv7511_input_id - Selects the input format id
+ * @ADV7511_INPUT_ID_24BIT_RGB444_YCbCr444: Input pixel format is 24-bit 444 RGB
+ *					    or 444 YCbCR with separate syncs
+ * @ADV7511_INPUT_ID_16_20_24BIT_YCbCr422_SEPARATE_SYNC:
+ * @ADV7511_INPUT_ID_16_20_24BIT_YCbCr422_EMBEDDED_SYNC:
+ * @ADV7511_INPUT_ID_8_10_12BIT_YCbCr422_SEPARATE_SYNC:
+ * @ADV7511_INPUT_ID_8_10_12BIT_YCbCr422_EMBEDDED_SYNC:
+ * @ADV7511_INPUT_ID_12_15_16BIT_RGB444_YCbCr444:
+ **/
 enum adv7511_input_id {
 	ADV7511_INPUT_ID_24BIT_RGB444_YCbCr444 = 0,
 	ADV7511_INPUT_ID_16_20_24BIT_YCbCr422_SEPARATE_SYNC = 1,
@@ -217,18 +228,37 @@ enum adv7511_input_id {
 	ADV7511_INPUT_ID_12_15_16BIT_RGB444_YCbCr444 = 5,
 };
 
+/**
+ * enum adv7511_input_bit_justifiction - Selects the input format bit justifiction
+ * ADV7511_INPUT_BIT_JUSTIFICATION_EVENLY: Input bits are evenly distributed
+ * ADV7511_INPUT_BIT_JUSTIFICATION_RIGHT: Input bit signals have right justification
+ * ADV7511_INPUT_BIT_JUSTIFICATION_LEFT: Input bit signals have left justification
+ **/
+enum adv7511_input_bit_justifiction {
+	ADV7511_INPUT_BIT_JUSTIFICATION_EVENLY = 0,
+	ADV7511_INPUT_BIT_JUSTIFICATION_RIGHT = 1,
+	ADV7511_INPUT_BIT_JUSTIFICATION_LEFT = 2,
+};
+
+/**
+ * enum adv7511_input_color_depth - Selects the input format color depth
+ * @ADV7511_INPUT_COLOR_DEPTH_8BIT: Input format color depth is 8 bits per channel
+ * @ADV7511_INPUT_COLOR_DEPTH_10BIT: Input format color dpeth is 10 bits per channel
+ * @ADV7511_INPUT_COLOR_DEPTH_12BIT: Input format color depth is 12 bits per channel
+ **/
 enum adv7511_input_color_depth {
+	ADV7511_INPUT_COLOR_DEPTH_8BIT = 3,
 	ADV7511_INPUT_COLOR_DEPTH_10BIT = 1,
 	ADV7511_INPUT_COLOR_DEPTH_12BIT = 2,
-	ADV7511_INPUT_COLOR_DEPTH_8BIT = 3,
-};
-
-enum adv7511_input_style {
-	ADV7511_INPUT_STYLE2 = 1,
-	ADV7511_INPUT_STYLE1 = 2,
-	ADV7511_INPUT_STYLE3 = 3,
 };
 
+/**
+ * enum adv7511_input_sync_pulse - Selects the sync pulse
+ * @ADV7511_INPUT_SYNC_PULSE_DE: Use the DE signal as sync pulse
+ * @ADV7511_INPUT_SYNC_PULSE_HSYNC: Use the HSYNC signal as sync pulse
+ * @ADV7511_INPUT_SYNC_PULSE_VSYNC: Use the VSYNC signal as sync pulse
+ * @ADV7511_INPUT_SYNC_PULSE_NONE: No external sync pulse signal
+ **/
 enum adv7511_input_sync_pulse {
 	ADV7511_INPUT_SYNC_PULSE_DE = 0,
 	ADV7511_INPUT_SYNC_PULSE_HSYNC = 1,
@@ -236,6 +266,17 @@ enum adv7511_input_sync_pulse {
 	ADV7511_INPUT_SYNC_PULSE_NONE = 3,
 };
 
+/**
+ * enum adv7511_input_clock_delay - Delay for the video data input clock
+ * @ADV7511_INPUT_CLOCK_DELAY_MINUS_1200PS: -1200 pico seconds delay
+ * @ADV7511_INPUT_CLOCK_DELAY_MINUS_800PS: -800 pico seconds delay
+ * @ADV7511_INPUT_CLOCK_DELAY_MINUS_400PS: -400 pico seconds delay
+ * @ADV7511_INPUT_CLOCK_DELAY_NONE: No delay
+ * @ADV7511_INPUT_CLOCK_DELAY_PLUS_400PS: 400 pico seconds delay
+ * @ADV7511_INPUT_CLOCK_DELAY_PLUS_800PS: 800 pico seconds delay
+ * @ADV7511_INPUT_CLOCK_DELAY_PLUS_1200PS: 1200 pico seconds delay
+ * @ADV7511_INPUT_CLOCK_DELAY_PLUS_1600PS: 1600 pico seconds delay
+ **/
 enum adv7511_input_clock_delay {
 	ADV7511_INPUT_CLOCK_DELAY_MINUS_1200PS = 0,
 	ADV7511_INPUT_CLOCK_DELAY_MINUS_800PS = 1,
@@ -247,65 +288,158 @@ enum adv7511_input_clock_delay {
 	ADV7511_INPUT_CLOCK_DELAY_PLUS_1600PS = 7,
 };
 
-enum adv7511_input_bit_justifiction {
-	ADV7511_INPUT_BIT_JUSTIFICATION_EVENLY = 0,
-	ADV7511_INPUT_BIT_JUSTIFICATION_RIGHT = 1,
-	ADV7511_INPUT_BIT_JUSTIFICATION_LEFT = 2,
+/**
+ * enum adv7511_sync_polarity - Polarity for the input sync signals
+ * ADV7511_SYNC_POLARITY_PASSTHROUGH:  Sync polarity matches that of the currently
+ *				    configured mode.
+ * ADV7511_SYNC_POLARITY_LOW:	    Sync polarity is low
+ * ADV7511_SYNC_POLARITY_HIGH:	    Sync polarity is high
+ *
+ * If the polarity is set to either ADV7511_SYNC_POLARITY_LOW or
+ * ADV7511_SYNC_POLARITY_HIGH the ADV7511 will internally invert the signal if
+ * it is required to match the sync polarity setting for the currently selected
+ * mode. If the polarity is set to ADV7511_SYNC_POLARITY_PASSTHROUGH, the ADV7511
+ * will route the signal unchanged, this is useful if the upstream graphics core
+ * will already generate the sync singals with the correct polarity.
+ **/
+enum adv7511_sync_polarity {
+	ADV7511_SYNC_POLARITY_PASSTHROUGH,
+	ADV7511_SYNC_POLARITY_LOW,
+	ADV7511_SYNC_POLARITY_HIGH,
 };
 
-enum adv7511_output_format {
-	ADV7511_OUTPUT_FORMAT_RGB_444 = 0,
-	ADV7511_OUTPUT_FORMAT_YCBCR_422 = 1,
-	ADV7511_OUTPUT_FORMAT_YCBCR_444 = 2,
+/**
+ * enum adv7511_timing_gen_seq - Selects the order in which timing adjustments are performed
+ * @ADV7511_TIMING_GEN_SEQ_SYN_ADJ_FIRST: Sync adjustment first, then DE generation
+ * @ADV7511_TIMING_GEN_SEQ_DE_GEN_FIRST: DE generation first, then sync adjustment
+ *
+ * This setting is only relevant if both DE generation and sync adjustment are
+ * active.
+ **/
+enum adv7511_timing_gen_seq {
+    ADV7511_TIMING_GEN_SEQ_SYN_ADJ_FIRST = 0,
+    ADV7511_TIMING_GEN_SEQ_DE_GEN_FIRST = 1,
 };
 
-enum adv7511_csc_scaling {
-	ADV7511_CSC_SCALING_1 = 0,
-	ADV7511_CSC_SCALING_2 = 1,
-	ADV7511_CSC_SCALING_4 = 2,
+/**
+ * enum adv7511_up_conversion - Selects the upscaling conversion method
+ * @ADV7511_UP_CONVERSION_ZERO_ORDER: Use zero order up conversion
+ * @ADV7511_UP_CONVERSION_FIRST_ORDER: Use first order up conversion
+ *
+ * This used when converting from a 4:2:2 format to a 4:4:4 format.
+ **/
+enum adv7511_up_conversion {
+    ADV7511_UP_CONVERSION_ZERO_ORDER = 0,
+    ADV7511_UP_CONVERSION_FIRST_ORDER = 1,
 };
 
 /**
- * struct adv7511_video_input_config - Describes adv7511 hardware configuration
+ * struct adv7511_link_config - Describes adv7511 hardware configuration
  * @id:				Video input format id
  * @input_style:		Video input format style
  * @sync_pulse:			Select the sync pulse
  * @clock_delay:		Clock delay for the input clock
  * @reverse_bitorder:		Reverse video input signal bitorder
  * @bit_justification:		Video input format bit justification
- * @up_conversion_first_order_interpolation:
+ * @up_conversion:		Selects the upscaling conversion method
  * @input_color_depth:		Input video format color depth
  * @tmds_clock_inversion:	Whether to invert the TDMS clock
- * @vsync_polartity_low:	Whether the vsync polarity is low
- * @hsync_polartity_low:	Whether the hsync polarity is low
- * @csc_enable:			Whether to enable color space conversion
- * @csc_scaling_factor:		Color space conversion scaling factor
- * @csc_coefficents:		Color space conversion coefficents
- * @output_format:		Video output format
- * @timing_gen_sequence:
- * @hdmi_mode:			Whether to use HDMI or DVI output mode
+ * @vsync_polartity:		vsync input signal configuration
+ * @hsync_polartity:		hsync input signal configuration
+ * @timing_gen_seq:		Selects the order in which sync DE generation
+ *				and sync adjustment are performt.
  **/
-struct adv7511_video_input_config {
+struct adv7511_link_config {
 	enum adv7511_input_id id;
 	enum adv7511_input_style input_style;
 	enum adv7511_input_sync_pulse sync_pulse;
 	enum adv7511_input_clock_delay clock_delay;
 	bool reverse_bitorder;
 	enum adv7511_input_bit_justifiction bit_justification;
-	bool up_conversion_first_order_interpolation;
+	enum adv7511_up_conversion up_conversion;
 	enum adv7511_input_color_depth input_color_depth;
 	bool tmds_clock_inversion;
+	enum adv7511_timing_gen_seq timing_gen_seq;
+
+	enum adv7511_sync_polarity vsync_polarity;
+	enum adv7511_sync_polarity hsync_polarity;
+};
+
+/**
+	adi,input-style = 1|2|3;
+	adi,input-id = 
+		"24-bit-rgb444-ycbcr444",
+		"16-20-24-bit-ycbcr422-separate-sync" |
+		"16-20-24-bit-ycbcr422-embedded-sync" |
+		"8-10-12-bit-ycbcr422-separate-sync" |
+		"8-10-12-bit-ycbcr422-embedded-sync" |
+		"12-15-16-bit-rgb444-ycbcr444"
+	adi,sync-pulse = "de","vsync","hsync","none"
+	adi,clock-delay = -1200|-800|-400|0|400|800|1200|1600
+	adi,reverse-bitorder
+	adi,bit-justification = "left"|"right"|"evently";
+	adi,up-conversion = "zero-order"|"first-order"
+	adi,input-color-depth = 8|10|12
+	adi,tdms-clock-inversion
+	adi,vsync-polarity = "low"|"high"|"passthrough"
+	adi,hsync-polarity = "low"|"high"|"passtrhough"
+	adi,timing-gen-seq = "sync-adjustment-first"|"de-generation-first"
+*/
 
-	bool vsync_polartity_low;
-	bool hsync_polartity_low;
+/**
+ * enum adv7511_csc_scaling - Scaling factor for the ADV7511 CSC
+ * @ADV7511_CSC_SCALING_1: CSC results are not scaled
+ * @ADV7511_CSC_SCALING_2: CSC results are scaled by a factor of two
+ * @ADV7511_CSC_SCALING_4: CSC results are scalled by a factor of four
+ **/
+enum adv7511_csc_scaling {
+	ADV7511_CSC_SCALING_1 = 0,
+	ADV7511_CSC_SCALING_2 = 1,
+	ADV7511_CSC_SCALING_4 = 2,
+};
 
+/**
+ * struct adv7511_video_config - Describes adv7511 hardware configuration
+ * @csc_enable:			Whether to enable color space conversion
+ * @csc_scaling_factor:		Color space conversion scaling factor
+ * @csc_coefficents:		Color space conversion coefficents
+ * @hdmi_mode:			Whether to use HDMI or DVI output mode
+ * @avi_infoframe:		HDMI infoframe
+ **/
+struct adv7511_video_config {
 	bool csc_enable;
 	enum adv7511_csc_scaling csc_scaling_factor;
-	uint16_t *csc_coefficents;
+	const uint16_t *csc_coefficents;
 
-	enum adv7511_output_format output_format;
-	int timing_gen_sequence;
 	bool hdmi_mode;
+	struct hdmi_avi_infoframe avi_infoframe;
+};
+
+struct adv7511 {
+	struct i2c_client *i2c_main;
+	struct i2c_client *i2c_edid;
+	struct i2c_client *i2c_packet;
+	struct i2c_client *i2c_cec;
+
+	struct regmap *regmap;
+	struct regmap *packet_memory_regmap;
+	enum drm_connector_status status;
+	int dpms_mode;
+
+	unsigned int f_tmds;
+	unsigned int f_audio;
+
+	unsigned int audio_source;
+
+	unsigned int current_edid_segment;
+	uint8_t edid_buf[256];
+
+	wait_queue_head_t wq;
+	struct drm_encoder *encoder;
+
+	bool embedded_sync;
+	enum adv7511_sync_polarity vsync_polarity;
+	enum adv7511_sync_polarity hsync_polarity;
 };
 
 #endif
diff --git a/drivers/gpu/drm/i2c/adv7511_audio.c b/drivers/gpu/drm/i2c/adv7511_audio.c
index c7f65a7..82b2eb9 100644
--- a/drivers/gpu/drm/i2c/adv7511_audio.c
+++ b/drivers/gpu/drm/i2c/adv7511_audio.c
@@ -23,15 +23,13 @@
 
 #include "adv7511.h"
 
-static const struct snd_kcontrol_new adv7511_controls[] = {
-	SOC_SINGLE("Master Playback Switch", 0, 0, 0, 0),
-};
-
 static const struct snd_soc_dapm_widget adv7511_dapm_widgets[] = {
+	SND_SOC_DAPM_OUTPUT("TDMS"),	
+	SND_SOC_DAPM_AIF_IN("AIFIN", "Playback", 0, SND_SOC_NOPM, 0, 0),
 };
 
 static const struct snd_soc_dapm_route adv7511_routes[] = {
-	{ "TMDS", NULL, "DAI IN" },
+	{ "TMDS", NULL, "AIFIN" },
 };
 
 static void adv7511_calc_cts_n(unsigned int f_tmds, unsigned int fs,
@@ -264,10 +262,8 @@ static int adv7511_resume(struct snd_soc_codec *codec)
 
 static int adv7511_probe(struct snd_soc_codec *codec)
 {
-	struct adv7511 *adv7511 = snd_soc_codec_get_drvdata(codec);
 	int ret;
 
-	codec->control_data = adv7511->regmap;
 	ret = snd_soc_codec_set_cache_io(codec, 0, 0, SND_SOC_REGMAP);
 	if (ret < 0) {
 		dev_err(codec->dev, "Failed to set cache I/O: %d\n", ret);
diff --git a/drivers/gpu/drm/i2c/adv7511_core.c b/drivers/gpu/drm/i2c/adv7511_core.c
index 0693fd4..310ef7c 100644
--- a/drivers/gpu/drm/i2c/adv7511_core.c
+++ b/drivers/gpu/drm/i2c/adv7511_core.c
@@ -18,7 +18,7 @@
 #include <drm/drm_encoder_slave.h>
 #include <drm/drm_edid.h>
 
-static uint8_t adv7511_register_defaults[] = {
+static const uint8_t adv7511_register_defaults[] = {
 	0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* 00 */
 	0x00, 0x00, 0x01, 0x0e, 0xbc, 0x18, 0x01, 0x13,
 	0x25, 0x37, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* 10 */
@@ -54,7 +54,7 @@ static uint8_t adv7511_register_defaults[] = {
 };
 
 /* ADI recommanded values for proper operation. */
-static uint8_t adv7511_fixed_registers[][2] = {
+static const struct reg_default adv7511_fixed_registers[] = {
 	{ 0x98, 0x03 },
 	{ 0x9a, 0xe0 },
 	{ 0x9c, 0x30 },
@@ -72,7 +72,7 @@ static struct adv7511 *encoder_to_adv7511(struct drm_encoder *encoder)
 }
 
 static void adv7511_set_colormap(struct adv7511 *adv7511, bool enable,
-	uint16_t *coeff, unsigned int scaling_factor)
+	const uint16_t *coeff, unsigned int scaling_factor)
 {
 	unsigned int i;
 
@@ -101,32 +101,118 @@ static void adv7511_set_colormap(struct adv7511 *adv7511, bool enable,
 #define ADV7511_HDMI_CFG_MODE_DVI 0x0
 #define ADV7511_HDMI_CFG_MODE_HDMI 0x2
 
+#define ADV7511_PACKET_MEM_SPD		0
+#define ADV7511_PACKET_MEM_MPEG		1
+#define ADV7511_PACKET_MEM_ACP		2
+#define ADV7511_PACKET_MEM_ISRC1	3
+#define ADV7511_PACKET_MEM_ISRC2	4
+#define ADV7511_PACKET_MEM_GM		5
+#define ADV7511_PACKET_MEM_SPARE1	6
+#define ADV7511_PACKET_MEM_SPARE2	7
+
+#define ADV7511_PACKET_MEM_DATA_REG(x) ((x) * 0x20)
+#define ADV7511_PACKET_MEM_UPDATE_REG(x) ((x) * 0x20 + 0x1f)
+#define ADV7511_PACKET_MEM_UPDATE_ENABLE BIT(7)
+#if 0
+static void adv7511_program_infoframe(struct adv7511 *adv7511,
+	const void *buffer, size_t size, unsigned int reg)
+{
+	unsigned int data_reg, update_reg;
+	unsigned int update_bit;
+
+	switch (type) {
+	case AVI:
+		regmap = adv7511->regmap;
+		data_reg = ADV7511_REG_AVI_INFOFRAME_VERSION;
+		update_reg = ADV7511_REG_INFOFRAME_UPDATE;
+		update_bit = BIT(6);
+		break;
+	case AUDIO:
+		regmap = adv7511->regmap;
+		data_reg = ADV7511_REG_AUDIO_INFOFRAME_VERSION;
+		update_reg = ADV7511_REG_INFOFRAME_UPDATE;
+		update_bit = BIT(5);
+		break;
+	case GC:
+		regmap = adv7511->regmap;
+		data_reg = ADV7511_REG_GC(0);
+		update_reg = ADV7511_REG_INFOFRAME_UPDATE;
+		update_bit = BIT(4);
+		break;
+	case SPD:
+		regmap = adv7511->packet_memory_regmap;
+		data_reg = ADV7511_PACKET_MEM_DATA_REG(ADV7511_PACKET_MEM_SPD);
+		data_reg = ADV7511_PACKET_MEM_UPDATE_REG(ADV7511_PACKET_MEM_SPD);
+		update_bit = ADV7511_PACKET_MEM_UPDATE_ENABLE;
+		break;
+	}
+
+	regmap_update_bits(adv7511->regmap, update_reg, update_bit, update_bit);
+
+	regmap_bulk_write(adv7511->regmap, data_reg, buffer, size);
+
+	regmap_update_bits(adv7511->regmap, update_reg, update_bit, 0);
+}
+
+#endif
+
 static void adv7511_set_config(struct drm_encoder *encoder, void *c)
 {
 	struct adv7511 *adv7511 = encoder_to_adv7511(encoder);
-	struct adv7511_video_input_config *config = c;
-	enum adv7511_input_sync_pulse sync_pulse;
+	struct adv7511_video_config *config = c;
 	bool output_format_422, output_format_ycbcr;
 	unsigned int mode;
+	uint8_t infoframe[17];
 
-	adv7511_set_colormap(adv7511, config->csc_enable,
-		config->csc_coefficents, config->csc_scaling_factor);
+	if (config->hdmi_mode) {
+		mode = ADV7511_HDMI_CFG_MODE_HDMI;
 
-	switch (config->output_format) {
-	case ADV7511_OUTPUT_FORMAT_YCBCR_444:
-		output_format_422 = false;
-		output_format_ycbcr = true;
-		break;
-	case ADV7511_OUTPUT_FORMAT_YCBCR_422:
-		output_format_422 = true;
-		output_format_ycbcr = true;
-		break;
-	default:
+		switch (config->avi_infoframe.colorspace) {
+		case HDMI_COLORSPACE_YUV444:
+			output_format_422 = false;
+			output_format_ycbcr = true;
+			break;
+		case HDMI_COLORSPACE_YUV422:
+			output_format_422 = true;
+			output_format_ycbcr = true;
+			break;
+		default:
+			output_format_422 = false;
+			output_format_ycbcr = false;
+			break;
+		}
+	} else {
+		mode = ADV7511_HDMI_CFG_MODE_DVI;
 		output_format_422 = false;
 		output_format_ycbcr = false;
-		break;
 	}
 
+	adv7511_packet_disable(adv7511, ADV7511_PACKET_ENABLE_AVI_INFOFRAME);
+
+	adv7511_set_colormap(adv7511, config->csc_enable,
+		config->csc_coefficents, config->csc_scaling_factor);
+
+	regmap_update_bits(adv7511->regmap, ADV7511_REG_VIDEO_INPUT_CFG1, 0x81,
+		(output_format_422 << 7) | output_format_ycbcr);
+
+	regmap_update_bits(adv7511->regmap, ADV7511_REG_HDCP_HDMI_CFG,
+		ADV7511_HDMI_CFG_MODE_MASK, mode);
+
+	hdmi_avi_infoframe_pack(&config->avi_infoframe, infoframe,
+		sizeof(infoframe));
+
+	/* The AVI infoframe id is not configurable */
+	regmap_bulk_write(adv7511->regmap, ADV7511_REG_AVI_INFOFRAME_VERSION,
+		infoframe + 1, sizeof(infoframe) - 1);
+
+	adv7511_packet_enable(adv7511, ADV7511_PACKET_ENABLE_AVI_INFOFRAME);
+}
+
+static void adv7511_set_link_config(struct adv7511 *adv7511,
+	const struct adv7511_link_config *config)
+{
+	enum adv7511_input_sync_pulse sync_pulse;
+
 	switch (config->id) {
 	case ADV7511_INPUT_ID_12_15_16BIT_RGB444_YCbCr444:
 		sync_pulse = ADV7511_INPUT_SYNC_PULSE_NONE;
@@ -148,33 +234,22 @@ static void adv7511_set_config(struct drm_encoder *encoder, void *c)
 
 	regmap_update_bits(adv7511->regmap, ADV7511_REG_I2C_FREQ_ID_CFG,
 		0xf, config->id);
-	regmap_write(adv7511->regmap, ADV7511_REG_VIDEO_INPUT_CFG1,
-		(output_format_422 << 7) |
-		(config->input_color_depth << 4) |
-		(config->input_style << 2) |
-		output_format_ycbcr);
+	regmap_update_bits(adv7511->regmap, ADV7511_REG_VIDEO_INPUT_CFG1, 0x7e,
+		(config->input_color_depth << 4) | (config->input_style << 2));
 	regmap_write(adv7511->regmap, ADV7511_REG_VIDEO_INPUT_CFG2,
 		(config->reverse_bitorder << 6) |
 		(config->bit_justification << 3));
 	regmap_write(adv7511->regmap, ADV7511_REG_TIMING_GEN_SEQ,
 		(sync_pulse << 2) |
-		(config->timing_gen_sequence << 1));
+		(config->timing_gen_seq << 1));
 	regmap_write(adv7511->regmap, 0xba,
 		(config->clock_delay << 5));
 
 	regmap_update_bits(adv7511->regmap, ADV7511_REG_TMDS_CLOCK_INV,
 		0x08, config->tmds_clock_inversion << 3);
 
-	regmap_update_bits(adv7511->regmap, ADV7511_REG_AVI_INFOFRAME(0),
-		0x60, config->output_format << 5);
-
-	if (config->hdmi_mode)
-		mode = ADV7511_HDMI_CFG_MODE_HDMI;
-	else
-		mode = ADV7511_HDMI_CFG_MODE_DVI;
-
-	regmap_update_bits(adv7511->regmap, ADV7511_REG_HDCP_HDMI_CFG,
-		0x2, mode);
+	adv7511->hsync_polarity = config->hsync_polarity;
+	adv7511->vsync_polarity = config->vsync_polarity;
 }
 
 int adv7511_packet_enable(struct adv7511 *adv7511, unsigned int packet)
@@ -297,7 +372,8 @@ static unsigned int adv7511_is_interrupt_pending(struct adv7511 *adv7511,
 	return pending & irq;
 }
 
-static int adv7511_wait_for_interrupt(struct adv7511 *adv7511, int irq, int timeout)
+static int adv7511_wait_for_interrupt(struct adv7511 *adv7511, int irq,
+	int timeout)
 {
 	unsigned int pending = 0;
 	int ret;
@@ -470,26 +546,29 @@ static enum drm_connector_status adv7511_encoder_detect(struct drm_encoder *enco
 	enum drm_connector_status status;
 	unsigned int val;
 	bool hpd;
+	int ret;
 
-	regmap_read(adv7511->regmap, ADV7511_REG_STATUS, &val);
+	ret = regmap_read(adv7511->regmap, ADV7511_REG_STATUS, &val);
+	if (ret < 0)
+		return connector_status_disconnected;
 
-	/* Cable connected and monitor turned on ? */
-	if (val & (ADV7511_STATUS_HPD)) /* | ADV7511_STATUS_MONITOR_SENSE))*/
+	if (val & ADV7511_STATUS_HPD)
 		status = connector_status_connected;
 	else
 		status = connector_status_disconnected;
 
 	hpd = adv7511_hpd(adv7511);
 
-	/* The chip resets itself when the cable is disconnected, so in case there is
-	 * a pending HPD interrupt and the cable is connected there was at least on
-	 * transition from disconnected to connected and the chip has to be
-	 * reinitialized. */
+	/* The chip resets itself when the cable is disconnected, so in case
+	 * there is a pending HPD interrupt and the cable is connected there was
+	 * at least on transition from disconnected to connected and the chip
+	 * has to be reinitialized. */
 	if (status == connector_status_connected && hpd &&
 		adv7511->dpms_mode == DRM_MODE_DPMS_ON) {
 		regcache_mark_dirty(adv7511->regmap);
 		adv7511_encoder_dpms(encoder, adv7511->dpms_mode);
 		adv7511_get_modes(encoder, connector);
+		status = connector_status_disconnected;
 	} else {
 		/* Renable HDP sensing */
 		regmap_update_bits(adv7511->regmap, ADV7511_REG_POWER2,
@@ -507,6 +586,8 @@ static void adv7511_encoder_mode_set(struct drm_encoder *encoder,
 {
 	struct adv7511 *adv7511 = encoder_to_adv7511(encoder);
 	unsigned int low_refresh_rate;
+	unsigned int hsync_polarity = 0;
+	unsigned int vsync_polarity = 0;
 
 	if (adv7511->embedded_sync) {
 		unsigned int hsync_offset, hsync_len;
@@ -529,6 +610,35 @@ static void adv7511_encoder_mode_set(struct drm_encoder *encoder,
 			((vsync_offset & 0x3f) << 2) | (vsync_len >> 8));
 		regmap_write(adv7511->regmap, ADV7511_REG_SYNC_DECODER(4),
 			vsync_len & 0xff);
+
+		hsync_polarity = !(adj_mode->flags & DRM_MODE_FLAG_PHSYNC);
+		vsync_polarity = !(adj_mode->flags & DRM_MODE_FLAG_PVSYNC);
+	} else {
+		enum adv7511_sync_polarity mode_hsync_polarity;
+		enum adv7511_sync_polarity mode_vsync_polarity;
+
+		/**
+		 * If the input signal is always low or always high we want to
+		 * invert or let it passthrough depending on the polarity of the
+		 * current mode.
+		 **/
+		if (adj_mode->flags & DRM_MODE_FLAG_NHSYNC)
+			mode_hsync_polarity = ADV7511_SYNC_POLARITY_LOW;
+		else
+			mode_hsync_polarity = ADV7511_SYNC_POLARITY_HIGH;
+
+		if (adj_mode->flags & DRM_MODE_FLAG_NVSYNC)
+			mode_vsync_polarity = ADV7511_SYNC_POLARITY_LOW;
+		else
+			mode_vsync_polarity = ADV7511_SYNC_POLARITY_HIGH;
+
+		if (adv7511->hsync_polarity != mode_hsync_polarity &&
+		    adv7511->hsync_polarity != ADV7511_SYNC_POLARITY_PASSTHROUGH)
+			hsync_polarity = 1;
+
+		if (adv7511->vsync_polarity != mode_vsync_polarity &&
+		    adv7511->vsync_polarity != ADV7511_SYNC_POLARITY_PASSTHROUGH)
+			vsync_polarity = 1;
 	}
 
 	if (mode->vrefresh <= 24000)
@@ -542,24 +652,10 @@ static void adv7511_encoder_mode_set(struct drm_encoder *encoder,
 
 	regmap_update_bits(adv7511->regmap, 0xfb,
 		0x6, low_refresh_rate << 1);
+	regmap_update_bits(adv7511->regmap, 0x17,
+		0x60, (vsync_polarity << 6) | (hsync_polarity << 5));
 
 	adv7511->f_tmds = mode->clock;
-
-/*
-	switch (adv7511->color_mode) {
-	case ADV7511_COLOR_MODE_30BIT:
-		adv7511->f_tmds = adv7511->f_tmds * 5 / 4;
-		break;
-	case ADV7511_COLOR_MODE_36BIT:
-		adv7511->f_tmds = adv7511->f_tmds * 3 / 2;
-		break;
-	case ADV7511_COLOR_MODE_48BIT:
-		adv7511->f_tmds = adv7511->f_tmds * 2;
-		break;
-	case ADV7511_COLOR_MODE_24BIT:
-		break;
-	}
-*/
 }
 
 static struct drm_encoder_slave_funcs adv7511_encoder_funcs = {
@@ -583,18 +679,147 @@ static const struct regmap_config adv7511_regmap_config = {
 	.volatile_reg = adv7511_register_volatile,
 };
 
+/*
+	adi,input-id - 
+		0x00: 
+		0x01:
+		0x02:
+		0x03:
+		0x04:
+		0x05:
+	adi,sync-pulse - Selects the sync pulse
+		0x00: Use the DE signal as sync pulse
+		0x01: Use the HSYNC signal as sync pulse
+		0x02: Use the VSYNC signal as sync pulse
+		0x03: No external sync pulse
+	adi,bit-justification -
+		0x00: Evently
+		0x01: Right
+		0x02: Left
+	adi,up-conversion - 
+		0x00: zero-order up conversion
+		0x01: first-order up conversion
+	adi,timing-generation-sequence -
+		0x00: Sync adjustment first, then DE generation
+		0x01: DE generation first then sync adjustment
+	adi,vsync-polarity - Polarity of the vsync signal
+		0x00: Passthrough
+		0x01: Active low
+		0x02: Active high
+	adi,hsync-polarity - Polarity of the hsync signal
+		0x00: Passthrough
+		0x01: Active low
+		0x02: Active high
+	adi,reverse-bitorder - If set the bitorder is reveresed
+	adi,tmds-clock-inversion - If set use tdms clock inversion
+	adi,clock-delay - Clock delay for the video data clock
+		0x00: -1200 ps
+		0x01:  -800 ps
+		0x02:  -400 ps
+		0x03: no dealy
+		0x04:   400 ps
+		0x05:   800 ps
+		0x06:  1200 ps
+		0x07:  1600 ps
+	adi,input-style - Specifies the input style used
+		0x02: Use input style 1
+		0x01: Use input style 2
+		0x03: Use Input style 3
+	adi,input-color-depth - Selects the input format color depth 
+		0x03: 8-bit per channel
+		0x01: 10-bit per channel
+		0x02: 12-bit per channel
+*/
+
+
+static int adv7511_parse_dt(struct adv7511 *adv7511,
+	struct device_node *np, struct adv7511_link_config *config)
+{
+	int ret;
+	u32 val;
+
+	ret = of_property_read_u32(np, "adi,input-id", &val);
+	if (ret < 0)
+		return ret;
+	config->id = val;
+
+	ret = of_property_read_u32(np, "adi,sync-pulse", &val);
+	if (ret < 0)
+		config->sync_pulse = ADV7511_INPUT_SYNC_PULSE_NONE;
+	else
+		config->sync_pulse = val;
+
+	ret = of_property_read_u32(np, "adi,bit-justification", &val);
+	if (ret < 0)
+		return ret;
+	config->bit_justification = val;
+
+	ret = of_property_read_u32(np, "adi,up-conversion", &val);
+	if (ret < 0)
+		config->up_conversion = ADV7511_UP_CONVERSION_ZERO_ORDER;
+	else
+		config->up_conversion = val;
+
+	ret = of_property_read_u32(np, "adi,timing-generation-sequence", &val);
+	if (ret < 0)
+		return ret;
+	config->timing_gen_seq = val;
+
+	ret = of_property_read_u32(np, "adi,vsync-polarity", &val);
+	if (ret < 0)
+		return ret;
+	config->vsync_polarity = val;
+
+	ret = of_property_read_u32(np, "adi,hsync-polarity", &val);
+	if (ret < 0)
+		return ret;
+	config->hsync_polarity = val;
+
+	config->reverse_bitorder = of_property_read_bool(np,
+		"adi,reverse-bitorder");
+	config->tmds_clock_inversion = of_property_read_bool(np,
+		"adi,tmds-clock-inversion");
+
+	ret = of_property_read_u32(np, "adi,clock-delay", &val);
+	if (ret)
+		return ret;
+	config->clock_delay = val;
+
+	ret = of_property_read_u32(np, "adi,input-style", &val);
+	if (ret)
+		return ret;
+	config->input_style = val;
+
+	ret = of_property_read_u32(np, "adi,input-color-depth", &val);
+	if (ret)
+		return ret;
+	config->input_color_depth = val;
+
+	return 0;
+}
+
 static const int edid_i2c_addr = 0x7e;
 static const int packet_i2c_addr = 0x70;
 static const int cec_i2c_addr = 0x78;
 
-static int __devinit adv7511_probe(struct i2c_client *i2c,
+static int adv7511_probe(struct i2c_client *i2c,
 	const struct i2c_device_id *id)
 {
+	struct adv7511_link_config link_config;
 	struct adv7511 *adv7511;
 	unsigned int val;
-	unsigned int i;
 	int ret;
 
+	if (i2c->dev.of_node) {
+		ret = adv7511_parse_dt(adv7511, i2c->dev.of_node, &link_config);
+		if (ret)
+			return ret;
+	} else {
+		if (!i2c->dev.platform_data)
+			return -EINVAL;
+		link_config = *(struct adv7511_link_config *)i2c->dev.platform_data;
+	}
+
 	adv7511 = devm_kzalloc(&i2c->dev, sizeof(*adv7511), GFP_KERNEL);
 	if (!adv7511)
 		return -ENOMEM;
@@ -604,22 +829,26 @@ static int __devinit adv7511_probe(struct i2c_client *i2c,
 		return PTR_ERR(adv7511->regmap);
 
 	ret = regmap_read(adv7511->regmap, ADV7511_REG_CHIP_REVISION, &val);
+	if (ret)
+		return ret;
 	dev_dbg(&i2c->dev, "Rev. %d\n", val);
 
+	ret = regmap_register_patch(adv7511->regmap, adv7511_fixed_registers,
+		ARRAY_SIZE(adv7511_fixed_registers));
+	if (ret)
+		return ret;
+
 	regmap_write(adv7511->regmap, ADV7511_REG_EDID_I2C_ADDR, edid_i2c_addr);
 	regmap_write(adv7511->regmap, ADV7511_REG_PACKET_I2C_ADDR, packet_i2c_addr);
 	regmap_write(adv7511->regmap, ADV7511_REG_CEC_I2C_ADDR, cec_i2c_addr);
+	adv7511_packet_disable(adv7511, 0xffff);
 
 	adv7511->i2c_main = i2c;
 	adv7511->i2c_edid = i2c_new_dummy(i2c->adapter, edid_i2c_addr >> 1);
+	adv7511->i2c_packet = i2c_new_dummy(i2c->adapter, packet_i2c_addr >> 1);
 	if (!adv7511->i2c_edid)
 		return -ENOMEM;
 
-	for (i = 0; i < ARRAY_SIZE(adv7511_fixed_registers); ++i) {
-		regmap_write(adv7511->regmap, adv7511_fixed_registers[i][0],
-				adv7511_fixed_registers[i][1]);
-	}
-
 	if (i2c->irq) {
 		ret = request_threaded_irq(i2c->irq, NULL, adv7511_irq_handler,
 				IRQF_ONESHOT, dev_name(&i2c->dev), adv7511);
@@ -641,6 +870,8 @@ static int __devinit adv7511_probe(struct i2c_client *i2c,
 	i2c_set_clientdata(i2c, adv7511);
 	adv7511_audio_init(&i2c->dev);
 
+	adv7511_set_link_config(adv7511, &link_config);
+
 	return 0;
 
 err_i2c_unregister_device:
@@ -649,7 +880,7 @@ err_i2c_unregister_device:
 	return ret;
 }
 
-static int __devexit adv7511_remove(struct i2c_client *i2c)
+static int adv7511_remove(struct i2c_client *i2c)
 {
 	struct adv7511 *adv7511 = i2c_get_clientdata(i2c);
 
@@ -687,7 +918,7 @@ static struct drm_i2c_encoder_driver adv7511_driver = {
 		},
 		.id_table = adv7511_ids,
 		.probe = adv7511_probe,
-		.remove = __devexit_p(adv7511_remove),
+		.remove = adv7511_remove,
 	},
 
 	.encoder_init = adv7511_encoder_init,
-- 
1.7.5.4

