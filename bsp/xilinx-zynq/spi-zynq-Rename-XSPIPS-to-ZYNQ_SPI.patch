From ed26e0fd95c2c9986351c8749154e2f204dc2b0e Mon Sep 17 00:00:00 2001
From: Michal Simek <michal.simek@xilinx.com>
Date: Wed, 27 Nov 2013 14:31:20 +0100
Subject: [PATCH 050/509] spi: zynq: Rename XSPIPS to ZYNQ_SPI

https://github.com/analogdevicesinc/linux.git xcomm_zynq
commit dfe7738800d9a73aeba0d584156dbd9b45969f39

The same for lower case too.

Signed-off-by: Michal Simek <michal.simek@xilinx.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 drivers/spi/spi-zynq.c |  325 +++++++++++++++++++++++++-----------------------
 1 files changed, 169 insertions(+), 156 deletions(-)

diff --git a/drivers/spi/spi-zynq.c b/drivers/spi/spi-zynq.c
index 1bb81a4..f9d2caf 100644
--- a/drivers/spi/spi-zynq.c
+++ b/drivers/spi/spi-zynq.c
@@ -33,22 +33,22 @@
 /*
  * Name of this driver
  */
-#define XSPIPS_NAME		"xspips"
+#define ZYNQ_SPI_NAME		"zynq_spi"
 
 /*
  * Register offset definitions
  */
-#define XSPIPS_CR_OFFSET	0x00 /* Configuration  Register, RW */
-#define XSPIPS_ISR_OFFSET	0x04 /* Interrupt Status Register, RO */
-#define XSPIPS_IER_OFFSET	0x08 /* Interrupt Enable Register, WO */
-#define XSPIPS_IDR_OFFSET	0x0c /* Interrupt Disable Register, WO */
-#define XSPIPS_IMR_OFFSET	0x10 /* Interrupt Enabled Mask Register, RO */
-#define XSPIPS_ER_OFFSET	0x14 /* Enable/Disable Register, RW */
-#define XSPIPS_DR_OFFSET	0x18 /* Delay Register, RW */
-#define XSPIPS_TXD_OFFSET	0x1C /* Data Transmit Register, WO */
-#define XSPIPS_RXD_OFFSET	0x20 /* Data Receive Register, RO */
-#define XSPIPS_SICR_OFFSET	0x24 /* Slave Idle Count Register, RW */
-#define XSPIPS_THLD_OFFSET	0x28 /* Transmit FIFO Watermark Register,RW */
+#define ZYNQ_SPI_CR_OFFSET	0x00 /* Configuration  Register, RW */
+#define ZYNQ_SPI_ISR_OFFSET	0x04 /* Interrupt Status Register, RO */
+#define ZYNQ_SPI_IER_OFFSET	0x08 /* Interrupt Enable Register, WO */
+#define ZYNQ_SPI_IDR_OFFSET	0x0c /* Interrupt Disable Register, WO */
+#define ZYNQ_SPI_IMR_OFFSET	0x10 /* Interrupt Enabled Mask Register, RO */
+#define ZYNQ_SPI_ER_OFFSET	0x14 /* Enable/Disable Register, RW */
+#define ZYNQ_SPI_DR_OFFSET	0x18 /* Delay Register, RW */
+#define ZYNQ_SPI_TXD_OFFSET	0x1C /* Data Transmit Register, WO */
+#define ZYNQ_SPI_RXD_OFFSET	0x20 /* Data Receive Register, RO */
+#define ZYNQ_SPI_SICR_OFFSET	0x24 /* Slave Idle Count Register, RW */
+#define ZYNQ_SPI_THLD_OFFSET	0x28 /* Transmit FIFO Watermark Register,RW */
 
 /*
  * SPI Configuration Register bit Masks
@@ -56,10 +56,10 @@
  * This register contains various control bits that affect the operation
  * of the SPI controller
  */
-#define XSPIPS_CR_MANSTRT_MASK	0x00010000 /* Manual TX Start */
-#define XSPIPS_CR_CPHA_MASK	0x00000004 /* Clock Phase Control */
-#define XSPIPS_CR_CPOL_MASK	0x00000002 /* Clock Polarity Control */
-#define XSPIPS_CR_SSCTRL_MASK	0x00003C00 /* Slave Select Mask */
+#define ZYNQ_SPI_CR_MANSTRT_MASK	0x00010000 /* Manual TX Start */
+#define ZYNQ_SPI_CR_CPHA_MASK	0x00000004 /* Clock Phase Control */
+#define ZYNQ_SPI_CR_CPOL_MASK	0x00000002 /* Clock Polarity Control */
+#define ZYNQ_SPI_CR_SSCTRL_MASK	0x00003C00 /* Slave Select Mask */
 
 /*
  * SPI Interrupt Registers bit Masks
@@ -67,33 +67,34 @@
  * All the four interrupt registers (Status/Mask/Enable/Disable) have the same
  * bit definitions.
  */
-#define XSPIPS_IXR_TXOW_MASK	0x00000004 /* SPI TX FIFO Overwater */
-#define XSPIPS_IXR_MODF_MASK	0x00000002 /* SPI Mode Fault */
-#define XSPIPS_IXR_RXNEMTY_MASK 0x00000010 /* SPI RX FIFO Not Empty */
-#define XSPIPS_IXR_ALL_MASK	(XSPIPS_IXR_TXOW_MASK | XSPIPS_IXR_MODF_MASK)
+#define ZYNQ_SPI_IXR_TXOW_MASK	0x00000004 /* SPI TX FIFO Overwater */
+#define ZYNQ_SPI_IXR_MODF_MASK	0x00000002 /* SPI Mode Fault */
+#define ZYNQ_SPI_IXR_RXNEMTY_MASK 0x00000010 /* SPI RX FIFO Not Empty */
+#define ZYNQ_SPI_IXR_ALL_MASK	(ZYNQ_SPI_IXR_TXOW_MASK | \
+				 ZYNQ_SPI_IXR_MODF_MASK)
 
 /*
  * SPI Enable Register bit Masks
  *
  * This register is used to enable or disable the SPI controller
  */
-#define XSPIPS_ER_ENABLE_MASK	0x00000001 /* SPI Enable Bit Mask */
+#define ZYNQ_SPI_ER_ENABLE_MASK	0x00000001 /* SPI Enable Bit Mask */
 
 /*
  * Definitions for the status of queue
  */
-#define XSPIPS_QUEUE_STOPPED	0
-#define XSPIPS_QUEUE_RUNNING	1
+#define ZYNQ_SPI_QUEUE_STOPPED	0
+#define ZYNQ_SPI_QUEUE_RUNNING	1
 
 /*
  * Macros for the SPI controller read/write
  */
-#define xspips_read(addr)	__raw_readl(addr)
-#define xspips_write(addr, val)	__raw_writel((val), (addr))
+#define zynq_spi_read(addr)	__raw_readl(addr)
+#define zynq_spi_write(addr, val)	__raw_writel((val), (addr))
 
 
 /**
- * struct xspips - This definition defines spi driver instance
+ * struct zynq_spi - This definition defines spi driver instance
  * @workqueue:		Queue of all the transfers
  * @work:		Information about current transfer
  * @queue:		Head of the queue
@@ -112,7 +113,7 @@
  * @dev_busy:		Device busy flag
  * @done:		Transfer complete status
  */
-struct xspips {
+struct zynq_spi {
 	struct workqueue_struct *workqueue;
 	struct work_struct work;
 	struct list_head queue;
@@ -134,7 +135,7 @@ struct xspips {
 
 
 /**
- * xspips_init_hw - Initialize the hardware and configure the SPI controller
+ * zynq_spi_init_hw - Initialize the hardware and configure the SPI controller
  * @regs_base:		Base address of SPI controller
  *
  * On reset the SPI controller is configured to be in master mode, baud rate
@@ -144,53 +145,54 @@ struct xspips {
  * interrupts, enable manual slave select and manual start, deselect all the
  * chip select lines, and enable the SPI controller.
  */
-static void xspips_init_hw(void __iomem *regs_base)
+static void zynq_spi_init_hw(void __iomem *regs_base)
 {
-	xspips_write(regs_base + XSPIPS_ER_OFFSET, ~XSPIPS_ER_ENABLE_MASK);
-	xspips_write(regs_base + XSPIPS_IDR_OFFSET, 0x7F);
+	zynq_spi_write(regs_base + ZYNQ_SPI_ER_OFFSET,
+		       ~ZYNQ_SPI_ER_ENABLE_MASK);
+	zynq_spi_write(regs_base + ZYNQ_SPI_IDR_OFFSET, 0x7F);
 
 	/* Clear the RX FIFO */
-	while (xspips_read(regs_base + XSPIPS_ISR_OFFSET) &
-			XSPIPS_IXR_RXNEMTY_MASK)
-		xspips_read(regs_base + XSPIPS_RXD_OFFSET);
+	while (zynq_spi_read(regs_base + ZYNQ_SPI_ISR_OFFSET) &
+			ZYNQ_SPI_IXR_RXNEMTY_MASK)
+		zynq_spi_read(regs_base + ZYNQ_SPI_RXD_OFFSET);
 
-	xspips_write(regs_base + XSPIPS_ISR_OFFSET, 0x7F);
-	xspips_write(regs_base + XSPIPS_CR_OFFSET, 0x0000FC01);
-	xspips_write(regs_base + XSPIPS_ER_OFFSET, XSPIPS_ER_ENABLE_MASK);
+	zynq_spi_write(regs_base + ZYNQ_SPI_ISR_OFFSET, 0x7F);
+	zynq_spi_write(regs_base + ZYNQ_SPI_CR_OFFSET, 0x0000FC01);
+	zynq_spi_write(regs_base + ZYNQ_SPI_ER_OFFSET, ZYNQ_SPI_ER_ENABLE_MASK);
 }
 
 /**
- * xspips_chipselect - Select or deselect the chip select line
+ * zynq_spi_chipselect - Select or deselect the chip select line
  * @spi:	Pointer to the spi_device structure
  * @is_on:	Select(1) or deselect (0) the chip select line
  */
-static void xspips_chipselect(struct spi_device *spi, int is_on)
+static void zynq_spi_chipselect(struct spi_device *spi, int is_on)
 {
-	struct xspips *xspi = spi_master_get_devdata(spi->master);
+	struct zynq_spi *xspi = spi_master_get_devdata(spi->master);
 	u32 ctrl_reg;
 	unsigned long flags;
 
 	spin_lock_irqsave(&xspi->ctrl_reg_lock, flags);
 
-	ctrl_reg = xspips_read(xspi->regs + XSPIPS_CR_OFFSET);
+	ctrl_reg = zynq_spi_read(xspi->regs + ZYNQ_SPI_CR_OFFSET);
 
 	if (is_on) {
 		/* Select the slave */
-		ctrl_reg &= ~XSPIPS_CR_SSCTRL_MASK;
+		ctrl_reg &= ~ZYNQ_SPI_CR_SSCTRL_MASK;
 		ctrl_reg |= (((~(0x0001 << spi->chip_select)) << 10) &
-				XSPIPS_CR_SSCTRL_MASK);
+				ZYNQ_SPI_CR_SSCTRL_MASK);
 	} else {
 		/* Deselect the slave */
-		ctrl_reg |= XSPIPS_CR_SSCTRL_MASK;
+		ctrl_reg |= ZYNQ_SPI_CR_SSCTRL_MASK;
 	}
 
-	xspips_write(xspi->regs + XSPIPS_CR_OFFSET, ctrl_reg);
+	zynq_spi_write(xspi->regs + ZYNQ_SPI_CR_OFFSET, ctrl_reg);
 
 	spin_unlock_irqrestore(&xspi->ctrl_reg_lock, flags);
 }
 
 /**
- * xspips_setup_transfer - Configure SPI controller for specified transfer
+ * zynq_spi_setup_transfer - Configure SPI controller for specified transfer
  * @spi:	Pointer to the spi_device structure
  * @transfer:	Pointer to the spi_transfer structure which provides information
  *		about next transfer setup parameters
@@ -207,10 +209,10 @@ static void xspips_chipselect(struct spi_device *spi, int is_on)
  * controller the driver will set the highest or lowest frequency supported by
  * controller.
  */
-static int xspips_setup_transfer(struct spi_device *spi,
+static int zynq_spi_setup_transfer(struct spi_device *spi,
 		struct spi_transfer *transfer)
 {
-	struct xspips *xspi = spi_master_get_devdata(spi->master);
+	struct zynq_spi *xspi = spi_master_get_devdata(spi->master);
 	u8 bits_per_word;
 	u32 ctrl_reg;
 	u32 req_hz;
@@ -231,15 +233,16 @@ static int xspips_setup_transfer(struct spi_device *spi,
 
 	spin_lock_irqsave(&xspi->ctrl_reg_lock, flags);
 
-	xspips_write(xspi->regs + XSPIPS_ER_OFFSET, ~XSPIPS_ER_ENABLE_MASK);
-	ctrl_reg = xspips_read(xspi->regs + XSPIPS_CR_OFFSET);
+	zynq_spi_write(xspi->regs + ZYNQ_SPI_ER_OFFSET,
+		       ~ZYNQ_SPI_ER_ENABLE_MASK);
+	ctrl_reg = zynq_spi_read(xspi->regs + ZYNQ_SPI_CR_OFFSET);
 
 	/* Set the SPI clock phase and clock polarity */
-	ctrl_reg &= (~XSPIPS_CR_CPHA_MASK) & (~XSPIPS_CR_CPOL_MASK);
+	ctrl_reg &= (~ZYNQ_SPI_CR_CPHA_MASK) & (~ZYNQ_SPI_CR_CPOL_MASK);
 	if (spi->mode & SPI_CPHA)
-		ctrl_reg |= XSPIPS_CR_CPHA_MASK;
+		ctrl_reg |= ZYNQ_SPI_CR_CPHA_MASK;
 	if (spi->mode & SPI_CPOL)
-		ctrl_reg |= XSPIPS_CR_CPOL_MASK;
+		ctrl_reg |= ZYNQ_SPI_CR_CPOL_MASK;
 
 	/* Set the clock frequency */
 	if (xspi->speed_hz != req_hz) {
@@ -254,8 +257,9 @@ static int xspips_setup_transfer(struct spi_device *spi,
 		xspi->speed_hz = (frequency / (2 << baud_rate_val));
 	}
 
-	xspips_write(xspi->regs + XSPIPS_CR_OFFSET, ctrl_reg);
-	xspips_write(xspi->regs + XSPIPS_ER_OFFSET, XSPIPS_ER_ENABLE_MASK);
+	zynq_spi_write(xspi->regs + ZYNQ_SPI_CR_OFFSET, ctrl_reg);
+	zynq_spi_write(xspi->regs + ZYNQ_SPI_ER_OFFSET,
+		       ZYNQ_SPI_ER_ENABLE_MASK);
 
 	spin_unlock_irqrestore(&xspi->ctrl_reg_lock, flags);
 
@@ -267,7 +271,7 @@ static int xspips_setup_transfer(struct spi_device *spi,
 }
 
 /**
- * xspips_setup - Configure the SPI controller
+ * zynq_spi_setup - Configure the SPI controller
  * @spi:	Pointer to the spi_device structure
  *
  * Sets the operational mode of SPI controller for the next SPI transfer, sets
@@ -275,7 +279,7 @@ static int xspips_setup_transfer(struct spi_device *spi,
  *
  * returns:	0 on success and error value on error
  */
-static int xspips_setup(struct spi_device *spi)
+static int zynq_spi_setup(struct spi_device *spi)
 {
 	if (!spi->max_speed_hz)
 		return -EINVAL;
@@ -283,29 +287,30 @@ static int xspips_setup(struct spi_device *spi)
 	if (!spi->bits_per_word)
 		spi->bits_per_word = 8;
 
-	return xspips_setup_transfer(spi, NULL);
+	return zynq_spi_setup_transfer(spi, NULL);
 }
 
 /**
- * xspips_fill_tx_fifo - Fills the TX FIFO with as many bytes as possible
- * @xspi:	Pointer to the xspips structure
+ * zynq_spi_fill_tx_fifo - Fills the TX FIFO with as many bytes as possible
+ * @xspi:	Pointer to the zynq_spi structure
  */
-static void xspips_fill_tx_fifo(struct xspips *xspi)
+static void zynq_spi_fill_tx_fifo(struct zynq_spi *xspi)
 {
-	while ((xspips_read(xspi->regs + XSPIPS_ISR_OFFSET) & 0x00000008) == 0
+	while ((zynq_spi_read(xspi->regs + ZYNQ_SPI_ISR_OFFSET) &
+		0x00000008) == 0
 		&& (xspi->remaining_bytes > 0)) {
 		if (xspi->txbuf)
-			xspips_write(xspi->regs + XSPIPS_TXD_OFFSET,
+			zynq_spi_write(xspi->regs + ZYNQ_SPI_TXD_OFFSET,
 					*xspi->txbuf++);
 		else
-			xspips_write(xspi->regs + XSPIPS_TXD_OFFSET, 0);
+			zynq_spi_write(xspi->regs + ZYNQ_SPI_TXD_OFFSET, 0);
 
 		xspi->remaining_bytes--;
 	}
 }
 
 /**
- * xspips_irq - Interrupt service routine of the SPI controller
+ * zynq_spi_irq - Interrupt service routine of the SPI controller
  * @irq:	IRQ number
  * @dev_id:	Pointer to the xspi structure
  *
@@ -318,29 +323,29 @@ static void xspips_fill_tx_fifo(struct xspips *xspi)
  *
  * returns:	IRQ_HANDLED always
  */
-static irqreturn_t xspips_irq(int irq, void *dev_id)
+static irqreturn_t zynq_spi_irq(int irq, void *dev_id)
 {
-	struct xspips *xspi = dev_id;
+	struct zynq_spi *xspi = dev_id;
 	u32 intr_status;
 
-	intr_status = xspips_read(xspi->regs + XSPIPS_ISR_OFFSET);
-	xspips_write(xspi->regs + XSPIPS_ISR_OFFSET, intr_status);
-	xspips_write(xspi->regs + XSPIPS_IDR_OFFSET, XSPIPS_IXR_ALL_MASK);
+	intr_status = zynq_spi_read(xspi->regs + ZYNQ_SPI_ISR_OFFSET);
+	zynq_spi_write(xspi->regs + ZYNQ_SPI_ISR_OFFSET, intr_status);
+	zynq_spi_write(xspi->regs + ZYNQ_SPI_IDR_OFFSET, ZYNQ_SPI_IXR_ALL_MASK);
 
-	if (intr_status & XSPIPS_IXR_MODF_MASK) {
+	if (intr_status & ZYNQ_SPI_IXR_MODF_MASK) {
 		/* Indicate that transfer is completed, the SPI subsystem will
 		 * identify the error as the remaining bytes to be
 		 * transferred is non-zero */
 		complete(&xspi->done);
-	} else if (intr_status & XSPIPS_IXR_TXOW_MASK) {
+	} else if (intr_status & ZYNQ_SPI_IXR_TXOW_MASK) {
 		u32 ctrl_reg;
 
 		/* Read out the data from the RX FIFO */
-		while (xspips_read(xspi->regs + XSPIPS_ISR_OFFSET) &
-				XSPIPS_IXR_RXNEMTY_MASK) {
+		while (zynq_spi_read(xspi->regs + ZYNQ_SPI_ISR_OFFSET) &
+				ZYNQ_SPI_IXR_RXNEMTY_MASK) {
 			u8 data;
 
-			data = xspips_read(xspi->regs + XSPIPS_RXD_OFFSET);
+			data = zynq_spi_read(xspi->regs + ZYNQ_SPI_RXD_OFFSET);
 			if (xspi->rxbuf)
 				*xspi->rxbuf++ = data;
 
@@ -356,16 +361,18 @@ static irqreturn_t xspips_irq(int irq, void *dev_id)
 
 		if (xspi->remaining_bytes) {
 			/* There is more data to send */
-			xspips_fill_tx_fifo(xspi);
+			zynq_spi_fill_tx_fifo(xspi);
 
-			xspips_write(xspi->regs + XSPIPS_IER_OFFSET,
-					XSPIPS_IXR_ALL_MASK);
+			zynq_spi_write(xspi->regs + ZYNQ_SPI_IER_OFFSET,
+					ZYNQ_SPI_IXR_ALL_MASK);
 
 			spin_lock(&xspi->ctrl_reg_lock);
 
-			ctrl_reg = xspips_read(xspi->regs + XSPIPS_CR_OFFSET);
-			ctrl_reg |= XSPIPS_CR_MANSTRT_MASK;
-			xspips_write(xspi->regs + XSPIPS_CR_OFFSET, ctrl_reg);
+			ctrl_reg = zynq_spi_read(xspi->regs +
+						 ZYNQ_SPI_CR_OFFSET);
+			ctrl_reg |= ZYNQ_SPI_CR_MANSTRT_MASK;
+			zynq_spi_write(xspi->regs + ZYNQ_SPI_CR_OFFSET,
+				       ctrl_reg);
 
 			spin_unlock(&xspi->ctrl_reg_lock);
 		} else {
@@ -378,7 +385,7 @@ static irqreturn_t xspips_irq(int irq, void *dev_id)
 }
 
 /**
- * xspips_start_transfer - Initiates the SPI transfer
+ * zynq_spi_start_transfer - Initiates the SPI transfer
  * @spi:	Pointer to the spi_device structure
  * @transfer:	Pointer to the spi_transfer structure which provide information
  *		about next transfer parameters
@@ -388,10 +395,10 @@ static irqreturn_t xspips_irq(int irq, void *dev_id)
  *
  * returns:	Number of bytes transferred in the last transfer
  */
-static int xspips_start_transfer(struct spi_device *spi,
+static int zynq_spi_start_transfer(struct spi_device *spi,
 			struct spi_transfer *transfer)
 {
-	struct xspips *xspi = spi_master_get_devdata(spi->master);
+	struct zynq_spi *xspi = spi_master_get_devdata(spi->master);
 	u32 ctrl_reg;
 	unsigned long flags;
 
@@ -400,16 +407,16 @@ static int xspips_start_transfer(struct spi_device *spi,
 	xspi->remaining_bytes = transfer->len;
 	INIT_COMPLETION(xspi->done);
 
-	xspips_fill_tx_fifo(xspi);
+	zynq_spi_fill_tx_fifo(xspi);
 
-	xspips_write(xspi->regs + XSPIPS_IER_OFFSET, XSPIPS_IXR_ALL_MASK);
+	zynq_spi_write(xspi->regs + ZYNQ_SPI_IER_OFFSET, ZYNQ_SPI_IXR_ALL_MASK);
 
 	spin_lock_irqsave(&xspi->ctrl_reg_lock, flags);
 
 	/* Start the transfer by enabling manual start bit */
-	ctrl_reg = xspips_read(xspi->regs + XSPIPS_CR_OFFSET);
-	ctrl_reg |= XSPIPS_CR_MANSTRT_MASK;
-	xspips_write(xspi->regs + XSPIPS_CR_OFFSET, ctrl_reg);
+	ctrl_reg = zynq_spi_read(xspi->regs + ZYNQ_SPI_CR_OFFSET);
+	ctrl_reg |= ZYNQ_SPI_CR_MANSTRT_MASK;
+	zynq_spi_write(xspi->regs + ZYNQ_SPI_CR_OFFSET, ctrl_reg);
 
 	spin_unlock_irqrestore(&xspi->ctrl_reg_lock, flags);
 
@@ -419,19 +426,21 @@ static int xspips_start_transfer(struct spi_device *spi,
 }
 
 /**
- * xspips_work_queue - Get the transfer request from queue to perform transfers
+ * zynq_spi_work_queue - Perform transfers
  * @work:	Pointer to the work_struct structure
+ *
+ * Get the transfer request from queue to perform transfers
  */
-static void xspips_work_queue(struct work_struct *work)
+static void zynq_spi_work_queue(struct work_struct *work)
 {
-	struct xspips *xspi = container_of(work, struct xspips, work);
+	struct zynq_spi *xspi = container_of(work, struct zynq_spi, work);
 	unsigned long flags;
 
 	spin_lock_irqsave(&xspi->trans_queue_lock, flags);
 	xspi->dev_busy = 1;
 
 	if (list_empty(&xspi->queue) ||
-		xspi->queue_state == XSPIPS_QUEUE_STOPPED) {
+		xspi->queue_state == ZYNQ_SPI_QUEUE_STOPPED) {
 		xspi->dev_busy = 0;
 		spin_unlock_irqrestore(&xspi->trans_queue_lock, flags);
 		return;
@@ -452,13 +461,13 @@ static void xspips_work_queue(struct work_struct *work)
 		list_for_each_entry(transfer, &msg->transfers, transfer_list) {
 			if ((transfer->bits_per_word || transfer->speed_hz) &&
 								cs_change) {
-				status = xspips_setup_transfer(spi, transfer);
+				status = zynq_spi_setup_transfer(spi, transfer);
 				if (status < 0)
 					break;
 			}
 
 			if (cs_change)
-				xspips_chipselect(spi, 1);
+				zynq_spi_chipselect(spi, 1);
 
 			cs_change = transfer->cs_change;
 
@@ -469,7 +478,7 @@ static void xspips_work_queue(struct work_struct *work)
 			}
 
 			if (transfer->len)
-				status = xspips_start_transfer(spi, transfer);
+				status = zynq_spi_start_transfer(spi, transfer);
 
 			if (status != transfer->len) {
 				if (status > 0)
@@ -487,14 +496,14 @@ static void xspips_work_queue(struct work_struct *work)
 			if (transfer->transfer_list.next == &msg->transfers)
 				break;
 
-			xspips_chipselect(spi, 0);
+			zynq_spi_chipselect(spi, 0);
 		}
 
 		msg->status = status;
 		msg->complete(msg->context);
 
 		if (!(status == 0 && cs_change))
-			xspips_chipselect(spi, 0);
+			zynq_spi_chipselect(spi, 0);
 
 		spin_lock_irqsave(&xspi->trans_queue_lock, flags);
 	}
@@ -503,20 +512,21 @@ static void xspips_work_queue(struct work_struct *work)
 }
 
 /**
- * xspips_transfer - Add a new transfer request at the tail of work queue
+ * zynq_spi_transfer - Add a new transfer request at the tail of work queue
  * @spi:	Pointer to the spi_device structure
  * @message:	Pointer to the spi_transfer structure which provide information
  *		about next transfer parameters
  *
  * returns:	0 on success and error value on error
  */
-static int xspips_transfer(struct spi_device *spi, struct spi_message *message)
+static int zynq_spi_transfer(struct spi_device *spi,
+			     struct spi_message *message)
 {
-	struct xspips *xspi = spi_master_get_devdata(spi->master);
+	struct zynq_spi *xspi = spi_master_get_devdata(spi->master);
 	struct spi_transfer *transfer;
 	unsigned long flags;
 
-	if (xspi->queue_state == XSPIPS_QUEUE_STOPPED)
+	if (xspi->queue_state == ZYNQ_SPI_QUEUE_STOPPED)
 		return -ESHUTDOWN;
 
 	message->actual_length = 0;
@@ -544,44 +554,44 @@ static int xspips_transfer(struct spi_device *spi, struct spi_message *message)
 }
 
 /**
- * xspips_start_queue - Starts the queue of the SPI driver
- * @xspi:	Pointer to the xspips structure
+ * zynq_spi_start_queue - Starts the queue of the SPI driver
+ * @xspi:	Pointer to the zynq_spi structure
  *
  * returns:	0 on success and error value on error
  */
-static inline int xspips_start_queue(struct xspips *xspi)
+static inline int zynq_spi_start_queue(struct zynq_spi *xspi)
 {
 	unsigned long flags;
 
 	spin_lock_irqsave(&xspi->trans_queue_lock, flags);
 
-	if (xspi->queue_state == XSPIPS_QUEUE_RUNNING || xspi->dev_busy) {
+	if (xspi->queue_state == ZYNQ_SPI_QUEUE_RUNNING || xspi->dev_busy) {
 		spin_unlock_irqrestore(&xspi->trans_queue_lock, flags);
 		return -EBUSY;
 	}
 
-	xspi->queue_state = XSPIPS_QUEUE_RUNNING;
+	xspi->queue_state = ZYNQ_SPI_QUEUE_RUNNING;
 	spin_unlock_irqrestore(&xspi->trans_queue_lock, flags);
 
 	return 0;
 }
 
 /**
- * xspips_stop_queue - Stops the queue of the SPI driver
- * @xspi:	Pointer to the xspips structure
+ * zynq_spi_stop_queue - Stops the queue of the SPI driver
+ * @xspi:	Pointer to the zynq_spi structure
  *
  * This function waits till queue is empty and then stops the queue.
  * Maximum time out is set to 5 seconds.
  *
  * returns:	0 on success and error value on error
  */
-static inline int xspips_stop_queue(struct xspips *xspi)
+static inline int zynq_spi_stop_queue(struct zynq_spi *xspi)
 {
 	unsigned long flags;
 	unsigned limit = 500;
 	int ret = 0;
 
-	if (xspi->queue_state != XSPIPS_QUEUE_RUNNING)
+	if (xspi->queue_state != ZYNQ_SPI_QUEUE_RUNNING)
 		return ret;
 
 	spin_lock_irqsave(&xspi->trans_queue_lock, flags);
@@ -596,7 +606,7 @@ static inline int xspips_stop_queue(struct xspips *xspi)
 		ret = -EBUSY;
 
 	if (ret == 0)
-		xspi->queue_state = XSPIPS_QUEUE_STOPPED;
+		xspi->queue_state = ZYNQ_SPI_QUEUE_STOPPED;
 
 	spin_unlock_irqrestore(&xspi->trans_queue_lock, flags);
 
@@ -604,16 +614,16 @@ static inline int xspips_stop_queue(struct xspips *xspi)
 }
 
 /**
- * xspips_destroy_queue - Destroys the queue of the SPI driver
- * @xspi:	Pointer to the xspips structure
+ * zynq_spi_destroy_queue - Destroys the queue of the SPI driver
+ * @xspi:	Pointer to the zynq_spi structure
  *
  * returns:	0 on success and error value on error
  */
-static inline int xspips_destroy_queue(struct xspips *xspi)
+static inline int zynq_spi_destroy_queue(struct zynq_spi *xspi)
 {
 	int ret;
 
-	ret = xspips_stop_queue(xspi);
+	ret = zynq_spi_stop_queue(xspi);
 	if (ret != 0)
 		return ret;
 
@@ -622,7 +632,7 @@ static inline int xspips_destroy_queue(struct xspips *xspi)
 	return 0;
 }
 
-static int xspips_clk_notifier_cb(struct notifier_block *nb,
+static int zynq_spi_clk_notifier_cb(struct notifier_block *nb,
 		unsigned long event, void *data)
 {
 	switch (event) {
@@ -642,18 +652,18 @@ static int xspips_clk_notifier_cb(struct notifier_block *nb,
 }
 
 /**
- * xspips_probe - Probe method for the SPI driver
+ * zynq_spi_probe - Probe method for the SPI driver
  * @pdev:	Pointer to the platform_device structure
  *
  * This function initializes the driver data structures and the hardware.
  *
  * returns:	0 on success and error value on error
  */
-static int xspips_probe(struct platform_device *pdev)
+static int zynq_spi_probe(struct platform_device *pdev)
 {
 	int ret = 0;
 	struct spi_master *master;
-	struct xspips *xspi;
+	struct zynq_spi *xspi;
 	struct resource *res;
 
 	master = spi_alloc_master(&pdev->dev, sizeof(*xspi));
@@ -679,7 +689,7 @@ static int xspips_probe(struct platform_device *pdev)
 		goto remove_master;
 	}
 
-	ret = devm_request_irq(&pdev->dev, xspi->irq, xspips_irq,
+	ret = devm_request_irq(&pdev->dev, xspi->irq, zynq_spi_irq,
 			       0, pdev->name, xspi);
 	if (ret != 0) {
 		ret = -ENXIO;
@@ -713,13 +723,13 @@ static int xspips_probe(struct platform_device *pdev)
 		goto clk_dis_aper;
 	}
 
-	xspi->clk_rate_change_nb.notifier_call = xspips_clk_notifier_cb;
+	xspi->clk_rate_change_nb.notifier_call = zynq_spi_clk_notifier_cb;
 	xspi->clk_rate_change_nb.next = NULL;
 	if (clk_notifier_register(xspi->devclk, &xspi->clk_rate_change_nb))
 		dev_warn(&pdev->dev, "Unable to register clock notifier.\n");
 
 	/* SPI controller initializations */
-	xspips_init_hw(xspi->regs);
+	zynq_spi_init_hw(xspi->regs);
 
 	init_completion(&xspi->done);
 
@@ -729,8 +739,8 @@ static int xspips_probe(struct platform_device *pdev)
 		dev_err(&pdev->dev, "couldn't determine num-chip-select\n");
 		goto clk_notif_unreg;
 	}
-	master->setup = xspips_setup;
-	master->transfer = xspips_transfer;
+	master->setup = zynq_spi_setup;
+	master->transfer = zynq_spi_transfer;
 	master->mode_bits = SPI_CPOL | SPI_CPHA;
 
 	xspi->speed_hz = clk_get_rate(xspi->devclk) / 2;
@@ -741,10 +751,10 @@ static int xspips_probe(struct platform_device *pdev)
 	spin_lock_init(&xspi->trans_queue_lock);
 	spin_lock_init(&xspi->ctrl_reg_lock);
 
-	xspi->queue_state = XSPIPS_QUEUE_STOPPED;
+	xspi->queue_state = ZYNQ_SPI_QUEUE_STOPPED;
 	xspi->dev_busy = 0;
 
-	INIT_WORK(&xspi->work, xspips_work_queue);
+	INIT_WORK(&xspi->work, zynq_spi_work_queue);
 	xspi->workqueue =
 		create_singlethread_workqueue(dev_name(&pdev->dev));
 	if (!xspi->workqueue) {
@@ -753,7 +763,7 @@ static int xspips_probe(struct platform_device *pdev)
 		goto clk_notif_unreg;
 	}
 
-	ret = xspips_start_queue(xspi);
+	ret = zynq_spi_start_queue(xspi);
 	if (ret != 0) {
 		dev_err(&pdev->dev, "problem starting queue\n");
 		goto remove_queue;
@@ -771,7 +781,7 @@ static int xspips_probe(struct platform_device *pdev)
 	return ret;
 
 remove_queue:
-	(void)xspips_destroy_queue(xspi);
+	(void)zynq_spi_destroy_queue(xspi);
 clk_notif_unreg:
 	clk_notifier_unregister(xspi->devclk, &xspi->clk_rate_change_nb);
 	clk_disable_unprepare(xspi->devclk);
@@ -787,7 +797,7 @@ remove_master:
 }
 
 /**
- * xspips_remove - Remove method for the SPI driver
+ * zynq_spi_remove - Remove method for the SPI driver
  * @pdev:	Pointer to the platform_device structure
  *
  * This function is called if a device is physically removed from the system or
@@ -796,17 +806,18 @@ remove_master:
  *
  * returns:	0 on success and error value on error
  */
-static int xspips_remove(struct platform_device *pdev)
+static int zynq_spi_remove(struct platform_device *pdev)
 {
 	struct spi_master *master = platform_get_drvdata(pdev);
-	struct xspips *xspi = spi_master_get_devdata(master);
+	struct zynq_spi *xspi = spi_master_get_devdata(master);
 	int ret = 0;
 
-	ret = xspips_destroy_queue(xspi);
+	ret = zynq_spi_destroy_queue(xspi);
 	if (ret != 0)
 		return ret;
 
-	xspips_write(xspi->regs + XSPIPS_ER_OFFSET, ~XSPIPS_ER_ENABLE_MASK);
+	zynq_spi_write(xspi->regs + ZYNQ_SPI_ER_OFFSET,
+		       ~ZYNQ_SPI_ER_ENABLE_MASK);
 
 	clk_notifier_unregister(xspi->devclk, &xspi->clk_rate_change_nb);
 	clk_disable_unprepare(xspi->devclk);
@@ -824,26 +835,27 @@ static int xspips_remove(struct platform_device *pdev)
 
 #ifdef CONFIG_PM_SLEEP
 /**
- * xspips_suspend - Suspend method for the SPI driver
+ * zynq_spi_suspend - Suspend method for the SPI driver
  * @dev:	Address of the platform_device structure
  *
  * This function stops the SPI driver queue and disables the SPI controller
  *
  * returns:	0 on success and error value on error
  */
-static int xspips_suspend(struct device *dev)
+static int zynq_spi_suspend(struct device *dev)
 {
 	struct platform_device *pdev = container_of(dev,
 			struct platform_device, dev);
 	struct spi_master *master = platform_get_drvdata(pdev);
-	struct xspips *xspi = spi_master_get_devdata(master);
+	struct zynq_spi *xspi = spi_master_get_devdata(master);
 	int ret = 0;
 
-	ret = xspips_stop_queue(xspi);
+	ret = zynq_spi_stop_queue(xspi);
 	if (ret != 0)
 		return ret;
 
-	xspips_write(xspi->regs + XSPIPS_ER_OFFSET, ~XSPIPS_ER_ENABLE_MASK);
+	zynq_spi_write(xspi->regs + ZYNQ_SPI_ER_OFFSET,
+		       ~ZYNQ_SPI_ER_ENABLE_MASK);
 
 	clk_disable(xspi->devclk);
 	clk_disable(xspi->aperclk);
@@ -853,19 +865,19 @@ static int xspips_suspend(struct device *dev)
 }
 
 /**
- * xspips_resume - Resume method for the SPI driver
+ * zynq_spi_resume - Resume method for the SPI driver
  * @dev:	Address of the platform_device structure
  *
  * This function starts the SPI driver queue and initializes the SPI controller
  *
  * returns:	0 on success and error value on error
  */
-static int xspips_resume(struct device *dev)
+static int zynq_spi_resume(struct device *dev)
 {
 	struct platform_device *pdev = container_of(dev,
 			struct platform_device, dev);
 	struct spi_master *master = platform_get_drvdata(pdev);
-	struct xspips *xspi = spi_master_get_devdata(master);
+	struct zynq_spi *xspi = spi_master_get_devdata(master);
 	int ret = 0;
 
 	ret = clk_enable(xspi->aperclk);
@@ -881,9 +893,9 @@ static int xspips_resume(struct device *dev)
 		return ret;
 	}
 
-	xspips_init_hw(xspi->regs);
+	zynq_spi_init_hw(xspi->regs);
 
-	ret = xspips_start_queue(xspi);
+	ret = zynq_spi_start_queue(xspi);
 	if (ret != 0) {
 		dev_err(&pdev->dev, "problem starting queue (%d)\n", ret);
 		return ret;
@@ -894,32 +906,33 @@ static int xspips_resume(struct device *dev)
 }
 #endif /* ! CONFIG_PM_SLEEP */
 
-static SIMPLE_DEV_PM_OPS(xspips_dev_pm_ops, xspips_suspend, xspips_resume);
+static SIMPLE_DEV_PM_OPS(zynq_spi_dev_pm_ops, zynq_spi_suspend,
+			 zynq_spi_resume);
 
 /* Work with hotplug and coldplug */
-MODULE_ALIAS("platform:" XSPIPS_NAME);
+MODULE_ALIAS("platform:" ZYNQ_SPI_NAME);
 
-static struct of_device_id xspips_of_match[] = {
+static struct of_device_id zynq_spi_of_match[] = {
 	{ .compatible = "xlnx,ps7-spi-1.00.a", },
 	{ /* end of table */}
 };
-MODULE_DEVICE_TABLE(of, xspips_of_match);
+MODULE_DEVICE_TABLE(of, zynq_spi_of_match);
 
 /*
- * xspips_driver - This structure defines the SPI subsystem platform driver
+ * zynq_spi_driver - This structure defines the SPI subsystem platform driver
  */
-static struct platform_driver xspips_driver = {
-	.probe	= xspips_probe,
-	.remove	= xspips_remove,
+static struct platform_driver zynq_spi_driver = {
+	.probe	= zynq_spi_probe,
+	.remove	= zynq_spi_remove,
 	.driver = {
-		.name = XSPIPS_NAME,
+		.name = ZYNQ_SPI_NAME,
 		.owner = THIS_MODULE,
-		.of_match_table = xspips_of_match,
-		.pm = &xspips_dev_pm_ops,
+		.of_match_table = zynq_spi_of_match,
+		.pm = &zynq_spi_dev_pm_ops,
 	},
 };
 
-module_platform_driver(xspips_driver);
+module_platform_driver(zynq_spi_driver);
 
 MODULE_AUTHOR("Xilinx, Inc.");
 MODULE_DESCRIPTION("Xilinx Zynq SPI driver");
-- 
1.7.5.4

