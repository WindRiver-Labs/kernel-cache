From ec035086f80a0ec60cd7d895765d4904a6423d65 Mon Sep 17 00:00:00 2001
From: Soren Brinkmann <soren.brinkmann@xilinx.com>
Date: Thu, 29 Nov 2012 09:45:15 -0800
Subject: [PATCH 4/4] gpio: xilinxps: Fix interrupts

git://github.com/Xilinx/linux-xlnx.git xilinx-v14.7
commit 6e403c93d75478a8e29cf4d06f9490b00e0902d5

This patch makes the GPIO interrupts work and they can be
used to resume from suspend.

Also we have to adjust the numbers of interrupts for zynq
because several subsystems - e.g. GPIO, PCIe
use virtual IRQs beyond 128, thus this number must be increased.

Let's allocate IRQs 128-256 for PCIe
and IRQs 256-512(ARCH_NR_GPIOS) for GPIOs.
Also chnage XGPIOPS_IRQBASE to reflect this.

Signed-off-by: Soren Brinkmann <soren.brinkmann@xilinx.com>
Signed-off-by: Michal Simek <michal.simek@xilinx.com>
[cherry picked the xilinx gpio interrupt modification only
remove suspend code]
Signed-off-by: Liming Wang <liming.wang@windriver.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 drivers/gpio/gpio-xilinxps.c |   59 +++++++++++++++++++++--------------------
 1 files changed, 30 insertions(+), 29 deletions(-)

diff --git a/drivers/gpio/gpio-xilinxps.c b/drivers/gpio/gpio-xilinxps.c
index a4ebadb..c1bac97 100644
--- a/drivers/gpio/gpio-xilinxps.c
+++ b/drivers/gpio/gpio-xilinxps.c
@@ -23,8 +23,10 @@
 #include <linux/interrupt.h>
 #include <linux/platform_device.h>
 #include <linux/slab.h>
+#include <asm/mach/irq.h>
 
 #define DRIVER_NAME "xgpiops"
+#define XGPIOPS_NR_GPIOS	118
 
 /* Register offsets for the GPIO device */
 
@@ -75,6 +77,7 @@ static unsigned int xgpiops_pin_table[] = {
 struct xgpiops {
 	struct gpio_chip chip;
 	void __iomem *base_addr;
+	unsigned int irq;
 	spinlock_t gpio_lock;
 };
 
@@ -280,6 +283,13 @@ static int xgpiops_dir_out(struct gpio_chip *chip, unsigned int pin, int state)
 	return 0;
 }
 
+static int xgpiops_to_irq(struct gpio_chip *chip, unsigned offset)
+{
+	if (offset < XGPIOPS_NR_GPIOS)
+		return XGPIOPS_IRQBASE + offset;
+	return -ENODEV;
+}
+
 /**
  * xgpiops_irq_ack - Acknowledge the interrupt of a gpio pin
  * @irq_data: irq data containing irq number of gpio pin for the interrupt
@@ -293,16 +303,12 @@ static void xgpiops_irq_ack(struct irq_data *irq_data)
 	struct xgpiops *gpio =
 			(struct xgpiops *)irq_data_get_irq_chip_data(irq_data);
 	unsigned int device_pin_num, bank_num, bank_pin_num;
-	unsigned int irq_sts;
 
 	/* get pin num within the device */
 	device_pin_num = irq_to_gpio(irq_data->irq);
 	xgpiops_get_bank_pin(device_pin_num, &bank_num, &bank_pin_num);
-	irq_sts = xgpiops_readreg(gpio->base_addr +
-				   XGPIOPS_INTSTS_OFFSET(bank_num)) |
-				   (1 << bank_pin_num);
-	xgpiops_writereg(irq_sts,
-			  gpio->base_addr + (XGPIOPS_INTSTS_OFFSET(bank_num)));
+	xgpiops_writereg(1 << bank_pin_num, gpio->base_addr +
+			(XGPIOPS_INTSTS_OFFSET(bank_num)));
 }
 
 /**
@@ -317,15 +323,11 @@ static void xgpiops_irq_mask(struct irq_data *irq_data)
 {
 	struct xgpiops *gpio = (struct xgpiops *)irq_data_get_irq_chip_data(irq_data);
 	unsigned int device_pin_num, bank_num, bank_pin_num;
-	unsigned int irq_dis;
 
 	/* get pin num within the device */
 	device_pin_num = irq_to_gpio(irq_data->irq);
 	xgpiops_get_bank_pin(device_pin_num, &bank_num, &bank_pin_num);
-	irq_dis = xgpiops_readreg(gpio->base_addr +
-				   XGPIOPS_INTDIS_OFFSET(bank_num)) |
-				   (1 << bank_pin_num);
-	xgpiops_writereg(irq_dis,
+	xgpiops_writereg(1 << bank_pin_num,
 			  gpio->base_addr + XGPIOPS_INTDIS_OFFSET(bank_num));
 }
 
@@ -342,15 +344,11 @@ static void xgpiops_irq_unmask(struct irq_data *irq_data)
 {
 	struct xgpiops *gpio = (struct xgpiops *)irq_data_get_irq_chip_data(irq_data);
 	unsigned int device_pin_num, bank_num, bank_pin_num;
-	unsigned int irq_en;
 
 	/* get pin num within the device */
 	device_pin_num = irq_to_gpio(irq_data->irq);
 	xgpiops_get_bank_pin(device_pin_num, &bank_num, &bank_pin_num);
-	irq_en = xgpiops_readreg(gpio->base_addr +
-				  XGPIOPS_INTEN_OFFSET(bank_num)) |
-				  (1 << bank_pin_num);
-	xgpiops_writereg(irq_en,
+	xgpiops_writereg(1 << bank_pin_num,
 			  gpio->base_addr + XGPIOPS_INTEN_OFFSET(bank_num));
 }
 
@@ -453,35 +451,35 @@ void xgpiops_irqhandler(unsigned int irq, struct irq_desc *desc)
 	unsigned int int_sts, int_enb, bank_num;
 	struct irq_desc *gpio_irq_desc;
 	struct irq_chip *chip = irq_desc_get_chip(desc);
-	struct irq_data *irq_data = irq_get_chip_data(irq);
 
-	chip->irq_ack(irq_data);
+	chained_irq_enter(chip, desc);
+
 	for (bank_num = 0; bank_num < 4; bank_num++) {
 		int_sts = xgpiops_readreg(gpio->base_addr +
 					   XGPIOPS_INTSTS_OFFSET(bank_num));
 		int_enb = xgpiops_readreg(gpio->base_addr +
 					   XGPIOPS_INTMASK_OFFSET(bank_num));
-		/*
-		 * handle only the interrupts which are enabled in interrupt
-		 * mask register
-		 */
 		int_sts &= ~int_enb;
+
 		for (; int_sts != 0; int_sts >>= 1, gpio_irq++) {
 			if ((int_sts & 1) == 0)
 				continue;
-			BUG_ON(!(irq_desc[gpio_irq].handle_irq));
 			gpio_irq_desc = irq_to_desc(gpio_irq);
-			chip->irq_ack(irq_data);
+			BUG_ON(!gpio_irq_desc);
+			chip = irq_desc_get_chip(gpio_irq_desc);
+			BUG_ON(!chip);
+			chip->irq_ack(&gpio_irq_desc->irq_data);
 
 			/* call the pin specific handler */
-			irq_desc[gpio_irq].handle_irq(gpio_irq,
-						      &irq_desc[gpio_irq]);
+			generic_handle_irq(gpio_irq);
 		}
 		/* shift to first virtual irq of next bank */
 		gpio_irq = (int)irq_get_handler_data(irq) +
 				(xgpiops_pin_table[bank_num] + 1);
 	}
-	chip->irq_unmask(irq_data);
+
+	chip = irq_desc_get_chip(desc);
+	chained_irq_exit(chip, desc);
 }
 
 /**
@@ -536,6 +534,7 @@ static int __init xgpiops_probe(struct platform_device *pdev)
 	}
 
 	irq_num = platform_get_irq(pdev, 0);
+	gpio->irq = irq_num;
 
 	/* configure the gpio chip */
 	chip = &gpio->chip;
@@ -546,9 +545,10 @@ static int __init xgpiops_probe(struct platform_device *pdev)
 	chip->set = xgpiops_set_value;
 	chip->direction_input = xgpiops_dir_in;
 	chip->direction_output = xgpiops_dir_out;
+	chip->to_irq = xgpiops_to_irq;
 	chip->dbg_show = NULL;
 	chip->base = 0;		/* default pin base */
-	chip->ngpio = 246;
+	chip->ngpio = XGPIOPS_NR_GPIOS;
 	chip->can_sleep = 0;
 
 	/* report a bug if gpio chip registration fails */
@@ -572,11 +572,12 @@ static int __init xgpiops_probe(struct platform_device *pdev)
 	 * each pin
 	 */
 	gpio_irq = XGPIOPS_IRQBASE;
-	for (pin_num = 0; pin_num < ARCH_NR_GPIOS; pin_num++, gpio_irq++) {
+	for (pin_num = 0; pin_num < XGPIOPS_NR_GPIOS; pin_num++, gpio_irq++) {
 		irq_set_chip(gpio_irq, &xgpiops_irqchip);
 		irq_set_chip_data(gpio_irq, (void *)gpio);
 		irq_set_handler(gpio_irq, handle_simple_irq);
 		irq_set_status_flags(gpio_irq, IRQF_VALID);
+		irq_clear_status_flags(gpio_irq, IRQ_NOREQUEST);
 	}
 
 	irq_set_handler_data(irq_num, (void *)(XGPIOPS_IRQBASE));
-- 
1.7.5.4

