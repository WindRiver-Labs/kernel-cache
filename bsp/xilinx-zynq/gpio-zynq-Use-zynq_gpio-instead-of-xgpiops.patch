From 7d43f95573d0caa8c2413d743f787fda92544c1d Mon Sep 17 00:00:00 2001
From: Michal Simek <michal.simek@xilinx.com>
Date: Thu, 7 Nov 2013 13:08:11 +0100
Subject: [PATCH 465/509] gpio: zynq: Use zynq_gpio instead of xgpiops

https://github.com/analogdevicesinc/linux.git xcomm_zynq
commit 4c98cdf0f85097de306cdd510489816b405400bf

Rename all functions/variables/etc in the driver.

Signed-off-by: Michal Simek <michal.simek@xilinx.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 drivers/gpio/gpio-zynq.c |  337 ++++++++++++++++++++++++----------------------
 1 files changed, 173 insertions(+), 164 deletions(-)

diff --git a/drivers/gpio/gpio-zynq.c b/drivers/gpio/gpio-zynq.c
index 66a75b0..816a513 100644
--- a/drivers/gpio/gpio-zynq.c
+++ b/drivers/gpio/gpio-zynq.c
@@ -26,49 +26,49 @@
 #include <linux/irqdomain.h>
 #include <linux/irqchip/chained_irq.h>
 
-#define DRIVER_NAME "xgpiops"
-#define XGPIOPS_NR_GPIOS	118
+#define DRIVER_NAME "zynq_gpio"
+#define ZYNQ_GPIO_NR_GPIOS	118
 
 static struct irq_domain *irq_domain;
 
 /* Register offsets for the GPIO device */
 
-#define XGPIOPS_DATA_LSW_OFFSET(BANK)	(0x000 + (8 * BANK)) /* LSW Mask &
+#define ZYNQ_GPIO_DATA_LSW_OFFSET(BANK)	(0x000 + (8 * BANK)) /* LSW Mask &
 								Data -WO */
-#define XGPIOPS_DATA_MSW_OFFSET(BANK)	(0x004 + (8 * BANK)) /* MSW Mask &
+#define ZYNQ_GPIO_DATA_MSW_OFFSET(BANK)	(0x004 + (8 * BANK)) /* MSW Mask &
 								Data -WO */
-#define XGPIOPS_DATA_OFFSET(BANK)	(0x040 + (4 * BANK)) /* Data Register
+#define ZYNQ_GPIO_DATA_OFFSET(BANK)	(0x040 + (4 * BANK)) /* Data Register
 								-RW */
-#define XGPIOPS_DIRM_OFFSET(BANK)	(0x204 + (0x40 * BANK)) /* Direction
+#define ZYNQ_GPIO_DIRM_OFFSET(BANK)	(0x204 + (0x40 * BANK)) /* Direction
 								mode reg-RW */
-#define XGPIOPS_OUTEN_OFFSET(BANK)	(0x208 + (0x40 * BANK)) /* Output
+#define ZYNQ_GPIO_OUTEN_OFFSET(BANK)	(0x208 + (0x40 * BANK)) /* Output
 								enable reg-RW
 								 */
-#define XGPIOPS_INTMASK_OFFSET(BANK)	(0x20C + (0x40 * BANK)) /* Interrupt
+#define ZYNQ_GPIO_INTMASK_OFFSET(BANK)	(0x20C + (0x40 * BANK)) /* Interrupt
 								mask reg-RO */
-#define XGPIOPS_INTEN_OFFSET(BANK)	(0x210 + (0x40 * BANK)) /* Interrupt
+#define ZYNQ_GPIO_INTEN_OFFSET(BANK)	(0x210 + (0x40 * BANK)) /* Interrupt
 								enable reg-WO
 								 */
-#define XGPIOPS_INTDIS_OFFSET(BANK)	(0x214 + (0x40 * BANK)) /* Interrupt
+#define ZYNQ_GPIO_INTDIS_OFFSET(BANK)	(0x214 + (0x40 * BANK)) /* Interrupt
 								disable reg-WO
 								 */
-#define XGPIOPS_INTSTS_OFFSET(BANK)	(0x218 + (0x40 * BANK)) /* Interrupt
+#define ZYNQ_GPIO_INTSTS_OFFSET(BANK)	(0x218 + (0x40 * BANK)) /* Interrupt
 								status reg-RO
 								 */
-#define XGPIOPS_INTTYPE_OFFSET(BANK)	(0x21C + (0x40 * BANK)) /* Interrupt
+#define ZYNQ_GPIO_INTTYPE_OFFSET(BANK)	(0x21C + (0x40 * BANK)) /* Interrupt
 								type reg-RW
 								 */
-#define XGPIOPS_INTPOL_OFFSET(BANK)	(0x220 + (0x40 * BANK)) /* Interrupt
+#define ZYNQ_GPIO_INTPOL_OFFSET(BANK)	(0x220 + (0x40 * BANK)) /* Interrupt
 								polarity reg
 								-RW */
-#define XGPIOPS_INTANY_OFFSET(BANK)	(0x224 + (0x40 * BANK)) /* Interrupt on
+#define ZYNQ_GPIO_INTANY_OFFSET(BANK)	(0x224 + (0x40 * BANK)) /* Interrupt on
 								any, reg-RW */
 
 /* Read/Write access to the GPIO PS registers */
-#define xgpiops_readreg(offset)		__raw_readl(offset)
-#define xgpiops_writereg(val, offset)	__raw_writel(val, offset)
+#define zynq_gpio_readreg(offset)		__raw_readl(offset)
+#define zynq_gpio_writereg(val, offset)	__raw_writel(val, offset)
 
-static unsigned int xgpiops_pin_table[] = {
+static unsigned int zynq_gpio_pin_table[] = {
 	31, /* 0 - 31 */
 	53, /* 32 - 53 */
 	85, /* 54 - 85 */
@@ -76,12 +76,12 @@ static unsigned int xgpiops_pin_table[] = {
 };
 
 /**
- * struct xgpiops - gpio device private data structure
+ * struct zynq_gpio - gpio device private data structure
  * @chip:	instance of the gpio_chip
  * @base_addr:	base address of the GPIO device
  * @gpio_lock:	lock used for synchronization
  */
-struct xgpiops {
+struct zynq_gpio {
 	struct gpio_chip chip;
 	void __iomem *base_addr;
 	unsigned int irq;
@@ -91,7 +91,7 @@ struct xgpiops {
 };
 
 /**
- * xgpiops_get_bank_pin - Get the bank number and pin number within that bank
+ * zynq_gpio_get_bank_pin - Get the bank number and pin number within that bank
  * for a given pin in the GPIO device
  * @pin_num:	gpio pin number within the device
  * @bank_num:	an output parameter used to return the bank number of the gpio
@@ -101,43 +101,43 @@ struct xgpiops {
  *
  * Returns the bank number.
  */
-static inline void xgpiops_get_bank_pin(unsigned int pin_num,
+static inline void zynq_gpio_get_bank_pin(unsigned int pin_num,
 					 unsigned int *bank_num,
 					 unsigned int *bank_pin_num)
 {
 	for (*bank_num = 0; *bank_num < 4; (*bank_num)++)
-		if (pin_num <= xgpiops_pin_table[*bank_num])
+		if (pin_num <= zynq_gpio_pin_table[*bank_num])
 			break;
 
 	if (*bank_num == 0)
 		*bank_pin_num = pin_num;
 	else
-		*bank_pin_num = pin_num %
-					(xgpiops_pin_table[*bank_num - 1] + 1);
+		*bank_pin_num = pin_num % (zynq_gpio_pin_table[*bank_num - 1] +
+				1);
 }
 
 /**
- * xgpiops_get_value - Get the state of the specified pin of GPIO device
+ * zynq_gpio_get_value - Get the state of the specified pin of GPIO device
  * @chip:	gpio_chip instance to be worked on
  * @pin:	gpio pin number within the device
  *
  * This function reads the state of the specified pin of the GPIO device.
  * It returns 0 if the pin is low, 1 if pin is high.
  */
-static int xgpiops_get_value(struct gpio_chip *chip, unsigned int pin)
+static int zynq_gpio_get_value(struct gpio_chip *chip, unsigned int pin)
 {
 	unsigned int bank_num, bank_pin_num;
-	struct xgpiops *gpio = container_of(chip, struct xgpiops, chip);
+	struct zynq_gpio *gpio = container_of(chip, struct zynq_gpio, chip);
 
-	xgpiops_get_bank_pin(pin, &bank_num, &bank_pin_num);
+	zynq_gpio_get_bank_pin(pin, &bank_num, &bank_pin_num);
 
-	return (xgpiops_readreg(gpio->base_addr +
-				 XGPIOPS_DATA_OFFSET(bank_num)) >>
+	return (zynq_gpio_readreg(gpio->base_addr +
+				 ZYNQ_GPIO_DATA_OFFSET(bank_num)) >>
 		bank_pin_num) & 1;
 }
 
 /**
- * xgpiops_set_value - Modify the state of the pin with specified value
+ * zynq_gpio_set_value - Modify the state of the pin with specified value
  * @chip:	gpio_chip instance to be worked on
  * @pin:	gpio pin number within the device
  * @state:	value used to modify the state of the specified pin
@@ -146,21 +146,21 @@ static int xgpiops_get_value(struct gpio_chip *chip, unsigned int pin)
  * upper 16 bits) based on the given pin number and sets the state of a
  * gpio pin to the specified value. The state is either 0 or non-zero.
  */
-static void xgpiops_set_value(struct gpio_chip *chip, unsigned int pin,
+static void zynq_gpio_set_value(struct gpio_chip *chip, unsigned int pin,
 			       int state)
 {
 	unsigned long flags;
 	unsigned int reg_offset;
 	unsigned int bank_num, bank_pin_num;
-	struct xgpiops *gpio = container_of(chip, struct xgpiops, chip);
+	struct zynq_gpio *gpio = container_of(chip, struct zynq_gpio, chip);
 
-	xgpiops_get_bank_pin(pin, &bank_num, &bank_pin_num);
+	zynq_gpio_get_bank_pin(pin, &bank_num, &bank_pin_num);
 
 	if (bank_pin_num >= 16) {
 		bank_pin_num -= 16; /* only 16 data bits in bit maskable reg */
-		reg_offset = XGPIOPS_DATA_MSW_OFFSET(bank_num);
+		reg_offset = ZYNQ_GPIO_DATA_MSW_OFFSET(bank_num);
 	} else {
-		reg_offset = XGPIOPS_DATA_LSW_OFFSET(bank_num);
+		reg_offset = ZYNQ_GPIO_DATA_LSW_OFFSET(bank_num);
 	}
 
 	/*
@@ -173,129 +173,138 @@ static void xgpiops_set_value(struct gpio_chip *chip, unsigned int pin,
 					       0xFFFF0000);
 
 	spin_lock_irqsave(&gpio->gpio_lock, flags);
-	xgpiops_writereg(state, gpio->base_addr + reg_offset);
+	zynq_gpio_writereg(state, gpio->base_addr + reg_offset);
 	spin_unlock_irqrestore(&gpio->gpio_lock, flags);
 }
 
 /**
- * xgpiops_dir_in - Set the direction of the specified GPIO pin as input
+ * zynq_gpio_dir_in - Set the direction of the specified GPIO pin as input
  * @chip:	gpio_chip instance to be worked on
  * @pin:	gpio pin number within the device
  *
  * This function uses the read-modify-write sequence to set the direction of
  * the gpio pin as input. Returns 0 always.
  */
-static int xgpiops_dir_in(struct gpio_chip *chip, unsigned int pin)
+static int zynq_gpio_dir_in(struct gpio_chip *chip, unsigned int pin)
 {
 	unsigned int reg, bank_num, bank_pin_num;
-	struct xgpiops *gpio = container_of(chip, struct xgpiops, chip);
+	struct zynq_gpio *gpio = container_of(chip, struct zynq_gpio, chip);
 
-	xgpiops_get_bank_pin(pin, &bank_num, &bank_pin_num);
+	zynq_gpio_get_bank_pin(pin, &bank_num, &bank_pin_num);
 	/* clear the bit in direction mode reg to set the pin as input */
-	reg = xgpiops_readreg(gpio->base_addr + XGPIOPS_DIRM_OFFSET(bank_num));
+	reg = zynq_gpio_readreg(gpio->base_addr +
+				ZYNQ_GPIO_DIRM_OFFSET(bank_num));
 	reg &= ~(1 << bank_pin_num);
-	xgpiops_writereg(reg, gpio->base_addr + XGPIOPS_DIRM_OFFSET(bank_num));
+	zynq_gpio_writereg(reg, gpio->base_addr +
+			   ZYNQ_GPIO_DIRM_OFFSET(bank_num));
 
 	return 0;
 }
 
 /**
- * xgpiops_dir_out - Set the direction of the specified GPIO pin as output
+ * zynq_gpio_dir_out - Set the direction of the specified GPIO pin as output
  * @chip:	gpio_chip instance to be worked on
  * @pin:	gpio pin number within the device
  * @state:	value to be written to specified pin
  *
  * This function sets the direction of specified GPIO pin as output, configures
- * the Output Enable register for the pin and uses xgpiops_set to set the state
- * of the pin to the value specified. Returns 0 always.
+ * the Output Enable register for the pin and uses zynq_gpio_set to set
+ * the state of the pin to the value specified. Returns 0 always.
  */
-static int xgpiops_dir_out(struct gpio_chip *chip, unsigned int pin, int state)
+static int zynq_gpio_dir_out(struct gpio_chip *chip, unsigned int pin,
+			     int state)
 {
-	struct xgpiops *gpio = container_of(chip, struct xgpiops, chip);
+	struct zynq_gpio *gpio = container_of(chip, struct zynq_gpio, chip);
 	unsigned int reg, bank_num, bank_pin_num;
 
-	xgpiops_get_bank_pin(pin, &bank_num, &bank_pin_num);
+	zynq_gpio_get_bank_pin(pin, &bank_num, &bank_pin_num);
 
 	/* set the GPIO pin as output */
-	reg = xgpiops_readreg(gpio->base_addr + XGPIOPS_DIRM_OFFSET(bank_num));
+	reg = zynq_gpio_readreg(gpio->base_addr +
+				ZYNQ_GPIO_DIRM_OFFSET(bank_num));
 	reg |= 1 << bank_pin_num;
-	xgpiops_writereg(reg, gpio->base_addr + XGPIOPS_DIRM_OFFSET(bank_num));
+	zynq_gpio_writereg(reg, gpio->base_addr +
+				ZYNQ_GPIO_DIRM_OFFSET(bank_num));
 
 	/* configure the output enable reg for the pin */
-	reg = xgpiops_readreg(gpio->base_addr + XGPIOPS_OUTEN_OFFSET(bank_num));
+	reg = zynq_gpio_readreg(gpio->base_addr +
+				ZYNQ_GPIO_OUTEN_OFFSET(bank_num));
 	reg |= 1 << bank_pin_num;
-	xgpiops_writereg(reg, gpio->base_addr + XGPIOPS_OUTEN_OFFSET(bank_num));
+	zynq_gpio_writereg(reg, gpio->base_addr +
+				ZYNQ_GPIO_OUTEN_OFFSET(bank_num));
 
 	/* set the state of the pin */
-	xgpiops_set_value(chip, pin, state);
+	zynq_gpio_set_value(chip, pin, state);
 	return 0;
 }
 
-static int xgpiops_to_irq(struct gpio_chip *chip, unsigned offset)
+static int zynq_gpio_to_irq(struct gpio_chip *chip, unsigned offset)
 {
 	return irq_find_mapping(irq_domain, offset);
 }
 
 /**
- * xgpiops_irq_ack - Acknowledge the interrupt of a gpio pin
- * @irq_data: irq data containing irq number of gpio pin for the irq to ack
+ * zynq_gpio_irq_ack - Acknowledge the interrupt of a gpio pin
+ * @irq_data:	irq data containing irq number of gpio pin for the interrupt
+ *		to ack
  *
  * This function calculates gpio pin number from irq number and sets the bit
  * in the Interrupt Status Register of the corresponding bank, to ACK the irq.
  */
-static void xgpiops_irq_ack(struct irq_data *irq_data)
+static void zynq_gpio_irq_ack(struct irq_data *irq_data)
 {
-	struct xgpiops *gpio = (struct xgpiops *)
-				irq_data_get_irq_chip_data(irq_data);
+	struct zynq_gpio *gpio = (struct zynq_gpio *)
+				 irq_data_get_irq_chip_data(irq_data);
 	unsigned int device_pin_num, bank_num, bank_pin_num;
 
 	device_pin_num = irq_data->hwirq;
-	xgpiops_get_bank_pin(device_pin_num, &bank_num, &bank_pin_num);
-	xgpiops_writereg(1 << bank_pin_num, gpio->base_addr +
-			(XGPIOPS_INTSTS_OFFSET(bank_num)));
+	zynq_gpio_get_bank_pin(device_pin_num, &bank_num, &bank_pin_num);
+	zynq_gpio_writereg(1 << bank_pin_num, gpio->base_addr +
+			(ZYNQ_GPIO_INTSTS_OFFSET(bank_num)));
 }
 
 /**
- * xgpiops_irq_mask - Disable the interrupts for a gpio pin
+ * zynq_gpio_irq_mask - Disable the interrupts for a gpio pin
  * @irq:	irq number of gpio pin for which interrupt is to be disabled
  *
  * This function calculates gpio pin number from irq number and sets the
  * bit in the Interrupt Disable register of the corresponding bank to disable
  * interrupts for that pin.
  */
-static void xgpiops_irq_mask(struct irq_data *irq_data)
+static void zynq_gpio_irq_mask(struct irq_data *irq_data)
 {
-	struct xgpiops *gpio = (struct xgpiops *)
-				irq_data_get_irq_chip_data(irq_data);
+	struct zynq_gpio *gpio = (struct zynq_gpio *)
+				 irq_data_get_irq_chip_data(irq_data);
 	unsigned int device_pin_num, bank_num, bank_pin_num;
 
 	device_pin_num = irq_data->hwirq;
-	xgpiops_get_bank_pin(device_pin_num, &bank_num, &bank_pin_num);
-	xgpiops_writereg(1 << bank_pin_num,
-			  gpio->base_addr + XGPIOPS_INTDIS_OFFSET(bank_num));
+	zynq_gpio_get_bank_pin(device_pin_num, &bank_num, &bank_pin_num);
+	zynq_gpio_writereg(1 << bank_pin_num,
+			  gpio->base_addr + ZYNQ_GPIO_INTDIS_OFFSET(bank_num));
 }
 
 /**
- * xgpiops_irq_unmask - Enable the interrupts for a gpio pin
- * @irq_data: irq data containing irq number of gpio pin for the irq to enable
+ * zynq_gpio_irq_unmask - Enable the interrupts for a gpio pin
+ * @irq_data:	irq data containing irq number of gpio pin for the interrupt
+ *		to enable
  *
  * This function calculates the gpio pin number from irq number and sets the
  * bit in the Interrupt Enable register of the corresponding bank to enable
  * interrupts for that pin.
  */
-static void xgpiops_irq_unmask(struct irq_data *irq_data)
+static void zynq_gpio_irq_unmask(struct irq_data *irq_data)
 {
-	struct xgpiops *gpio = irq_data_get_irq_chip_data(irq_data);
+	struct zynq_gpio *gpio = irq_data_get_irq_chip_data(irq_data);
 	unsigned int device_pin_num, bank_num, bank_pin_num;
 
 	device_pin_num = irq_data->hwirq;
-	xgpiops_get_bank_pin(device_pin_num, &bank_num, &bank_pin_num);
-	xgpiops_writereg(1 << bank_pin_num,
-			  gpio->base_addr + XGPIOPS_INTEN_OFFSET(bank_num));
+	zynq_gpio_get_bank_pin(device_pin_num, &bank_num, &bank_pin_num);
+	zynq_gpio_writereg(1 << bank_pin_num,
+			  gpio->base_addr + ZYNQ_GPIO_INTEN_OFFSET(bank_num));
 }
 
 /**
- * xgpiops_set_irq_type - Set the irq type for a gpio pin
+ * zynq_gpio_set_irq_type - Set the irq type for a gpio pin
  * @irq_data:	irq data containing irq number of gpio pin
  * @type:	interrupt type that is to be set for the gpio pin
  *
@@ -308,21 +317,21 @@ static void xgpiops_irq_unmask(struct irq_data *irq_data)
  * TYPE-LEVEL_HIGH,   INT_TYPE - 0, INT_POLARITY - 1,  INT_ANY - NA;
  * TYPE-LEVEL_LOW,    INT_TYPE - 0, INT_POLARITY - 0,  INT_ANY - NA
  */
-static int xgpiops_set_irq_type(struct irq_data *irq_data, unsigned int type)
+static int zynq_gpio_set_irq_type(struct irq_data *irq_data, unsigned int type)
 {
-	struct xgpiops *gpio = irq_data_get_irq_chip_data(irq_data);
+	struct zynq_gpio *gpio = irq_data_get_irq_chip_data(irq_data);
 	unsigned int device_pin_num, bank_num, bank_pin_num;
 	unsigned int int_type, int_pol, int_any;
 
 	device_pin_num = irq_data->hwirq;
-	xgpiops_get_bank_pin(device_pin_num, &bank_num, &bank_pin_num);
+	zynq_gpio_get_bank_pin(device_pin_num, &bank_num, &bank_pin_num);
 
-	int_type = xgpiops_readreg(gpio->base_addr +
-				    XGPIOPS_INTTYPE_OFFSET(bank_num));
-	int_pol = xgpiops_readreg(gpio->base_addr +
-				   XGPIOPS_INTPOL_OFFSET(bank_num));
-	int_any = xgpiops_readreg(gpio->base_addr +
-				   XGPIOPS_INTANY_OFFSET(bank_num));
+	int_type = zynq_gpio_readreg(gpio->base_addr +
+				    ZYNQ_GPIO_INTTYPE_OFFSET(bank_num));
+	int_pol = zynq_gpio_readreg(gpio->base_addr +
+				   ZYNQ_GPIO_INTPOL_OFFSET(bank_num));
+	int_any = zynq_gpio_readreg(gpio->base_addr +
+				   ZYNQ_GPIO_INTANY_OFFSET(bank_num));
 
 	/*
 	 * based on the type requested, configure the INT_TYPE, INT_POLARITY
@@ -355,37 +364,37 @@ static int xgpiops_set_irq_type(struct irq_data *irq_data, unsigned int type)
 		return -EINVAL;
 	}
 
-	xgpiops_writereg(int_type,
-			  gpio->base_addr + XGPIOPS_INTTYPE_OFFSET(bank_num));
-	xgpiops_writereg(int_pol,
-			  gpio->base_addr + XGPIOPS_INTPOL_OFFSET(bank_num));
-	xgpiops_writereg(int_any,
-			  gpio->base_addr + XGPIOPS_INTANY_OFFSET(bank_num));
+	zynq_gpio_writereg(int_type,
+			  gpio->base_addr + ZYNQ_GPIO_INTTYPE_OFFSET(bank_num));
+	zynq_gpio_writereg(int_pol,
+			  gpio->base_addr + ZYNQ_GPIO_INTPOL_OFFSET(bank_num));
+	zynq_gpio_writereg(int_any,
+			  gpio->base_addr + ZYNQ_GPIO_INTANY_OFFSET(bank_num));
 	return 0;
 }
 
-static int xgpiops_set_wake(struct irq_data *data, unsigned int on)
+static int zynq_gpio_set_wake(struct irq_data *data, unsigned int on)
 {
 	if (on)
-		xgpiops_irq_unmask(data);
+		zynq_gpio_irq_unmask(data);
 	else
-		xgpiops_irq_mask(data);
+		zynq_gpio_irq_mask(data);
 
 	return 0;
 }
 
 /* irq chip descriptor */
-static struct irq_chip xgpiops_irqchip = {
+static struct irq_chip zynq_gpio_irqchip = {
 	.name		= DRIVER_NAME,
-	.irq_ack	= xgpiops_irq_ack,
-	.irq_mask	= xgpiops_irq_mask,
-	.irq_unmask	= xgpiops_irq_unmask,
-	.irq_set_type	= xgpiops_set_irq_type,
-	.irq_set_wake	= xgpiops_set_wake,
+	.irq_ack	= zynq_gpio_irq_ack,
+	.irq_mask	= zynq_gpio_irq_mask,
+	.irq_unmask	= zynq_gpio_irq_unmask,
+	.irq_set_type	= zynq_gpio_set_irq_type,
+	.irq_set_wake	= zynq_gpio_set_wake,
 };
 
 /**
- * xgpiops_irqhandler - IRQ handler for the gpio banks of a gpio device
+ * zynq_gpio_irqhandler - IRQ handler for the gpio banks of a gpio device
  * @irq:	irq number of the gpio bank where interrupt has occurred
  * @desc:	irq descriptor instance of the 'irq'
  *
@@ -395,9 +404,9 @@ static struct irq_chip xgpiops_irqchip = {
  * application for that pin.
  * Note: A bug is reported if no handler is set for the gpio pin.
  */
-static void xgpiops_irqhandler(unsigned int irq, struct irq_desc *desc)
+static void zynq_gpio_irqhandler(unsigned int irq, struct irq_desc *desc)
 {
-	struct xgpiops *gpio = (struct xgpiops *)irq_get_handler_data(irq);
+	struct zynq_gpio *gpio = (struct zynq_gpio *)irq_get_handler_data(irq);
 	int gpio_irq = gpio->irq_base;
 	unsigned int int_sts, int_enb, bank_num;
 	struct irq_desc *gpio_irq_desc;
@@ -406,10 +415,10 @@ static void xgpiops_irqhandler(unsigned int irq, struct irq_desc *desc)
 	chained_irq_enter(chip, desc);
 
 	for (bank_num = 0; bank_num < 4; bank_num++) {
-		int_sts = xgpiops_readreg(gpio->base_addr +
-					   XGPIOPS_INTSTS_OFFSET(bank_num));
-		int_enb = xgpiops_readreg(gpio->base_addr +
-					   XGPIOPS_INTMASK_OFFSET(bank_num));
+		int_sts = zynq_gpio_readreg(gpio->base_addr +
+					   ZYNQ_GPIO_INTSTS_OFFSET(bank_num));
+		int_enb = zynq_gpio_readreg(gpio->base_addr +
+					   ZYNQ_GPIO_INTMASK_OFFSET(bank_num));
 		int_sts &= ~int_enb;
 
 		for (; int_sts != 0; int_sts >>= 1, gpio_irq++) {
@@ -425,7 +434,7 @@ static void xgpiops_irqhandler(unsigned int irq, struct irq_desc *desc)
 			generic_handle_irq(gpio_irq);
 		}
 		/* shift to first virtual irq of next bank */
-		gpio_irq = gpio->irq_base + xgpiops_pin_table[bank_num] + 1;
+		gpio_irq = gpio->irq_base + zynq_gpio_pin_table[bank_num] + 1;
 	}
 
 	chip = irq_desc_get_chip(desc);
@@ -433,10 +442,10 @@ static void xgpiops_irqhandler(unsigned int irq, struct irq_desc *desc)
 }
 
 #ifdef CONFIG_PM_SLEEP
-static int xgpiops_suspend(struct device *dev)
+static int zynq_gpio_suspend(struct device *dev)
 {
 	struct platform_device *pdev = to_platform_device(dev);
-	struct xgpiops *gpio = platform_get_drvdata(pdev);
+	struct zynq_gpio *gpio = platform_get_drvdata(pdev);
 
 	if (!device_may_wakeup(dev)) {
 		if (!pm_runtime_suspended(dev))
@@ -447,10 +456,10 @@ static int xgpiops_suspend(struct device *dev)
 	return 0;
 }
 
-static int xgpiops_resume(struct device *dev)
+static int zynq_gpio_resume(struct device *dev)
 {
 	struct platform_device *pdev = to_platform_device(dev);
-	struct xgpiops *gpio = platform_get_drvdata(pdev);
+	struct zynq_gpio *gpio = platform_get_drvdata(pdev);
 
 	if (!device_may_wakeup(dev)) {
 		if (!pm_runtime_suspended(dev))
@@ -462,30 +471,30 @@ static int xgpiops_resume(struct device *dev)
 #endif
 
 #ifdef CONFIG_PM_RUNTIME
-static int xgpiops_runtime_suspend(struct device *dev)
+static int zynq_gpio_runtime_suspend(struct device *dev)
 {
 	struct platform_device *pdev = to_platform_device(dev);
-	struct xgpiops *gpio = platform_get_drvdata(pdev);
+	struct zynq_gpio *gpio = platform_get_drvdata(pdev);
 
 	clk_disable(gpio->clk);
 
 	return 0;
 }
 
-static int xgpiops_runtime_resume(struct device *dev)
+static int zynq_gpio_runtime_resume(struct device *dev)
 {
 	struct platform_device *pdev = to_platform_device(dev);
-	struct xgpiops *gpio = platform_get_drvdata(pdev);
+	struct zynq_gpio *gpio = platform_get_drvdata(pdev);
 
 	return clk_enable(gpio->clk);
 }
 
-static int xgpiops_idle(struct device *dev)
+static int zynq_gpio_idle(struct device *dev)
 {
 	return pm_schedule_suspend(dev, 1);
 }
 
-static int xgpiops_request(struct gpio_chip *chip, unsigned offset)
+static int zynq_gpio_request(struct gpio_chip *chip, unsigned offset)
 {
 	int ret;
 
@@ -498,39 +507,39 @@ static int xgpiops_request(struct gpio_chip *chip, unsigned offset)
 	return ret < 0 ? ret : 0;
 }
 
-static void xgpiops_free(struct gpio_chip *chip, unsigned offset)
+static void zynq_gpio_free(struct gpio_chip *chip, unsigned offset)
 {
 	pm_runtime_put_sync(chip->dev);
 }
 
-static void xgpiops_pm_runtime_init(struct platform_device *pdev)
+static void zynq_gpio_pm_runtime_init(struct platform_device *pdev)
 {
-	struct xgpiops *gpio = platform_get_drvdata(pdev);
+	struct zynq_gpio *gpio = platform_get_drvdata(pdev);
 
 	clk_disable(gpio->clk);
 	pm_runtime_enable(&pdev->dev);
 }
 
 #else /* ! CONFIG_PM_RUNTIME */
-#define xgpiops_request	NULL
-#define xgpiops_free	NULL
-static void xgpiops_pm_runtime_init(struct platform_device *pdev) {}
+#define zynq_gpio_request	NULL
+#define zynq_gpio_free	NULL
+static void zynq_gpio_pm_runtime_init(struct platform_device *pdev) {}
 #endif /* ! CONFIG_PM_RUNTIME */
 
 #if defined(CONFIG_PM_RUNTIME) || defined(CONFIG_PM_SLEEP)
-static const struct dev_pm_ops xgpiops_dev_pm_ops = {
-	SET_SYSTEM_SLEEP_PM_OPS(xgpiops_suspend, xgpiops_resume)
-	SET_RUNTIME_PM_OPS(xgpiops_runtime_suspend, xgpiops_runtime_resume,
-			xgpiops_idle)
+static const struct dev_pm_ops zynq_gpio_dev_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(zynq_gpio_suspend, zynq_gpio_resume)
+	SET_RUNTIME_PM_OPS(zynq_gpio_runtime_suspend, zynq_gpio_runtime_resume,
+			zynq_gpio_idle)
 };
-#define XGPIOPS_PM	(&xgpiops_dev_pm_ops)
+#define ZYNQ_GPIO_PM	(&zynq_gpio_dev_pm_ops)
 
 #else /*! CONFIG_PM_RUNTIME || ! CONFIG_PM_SLEEP */
-#define XGPIOPS_PM	NULL
+#define ZYNQ_GPIO_PM	NULL
 #endif /*! CONFIG_PM_RUNTIME */
 
 /**
- * xgpiops_probe - Initialization method for a xgpiops device
+ * zynq_gpio_probe - Initialization method for a zynq_gpio device
  * @pdev:	platform device instance
  *
  * This function allocates memory resources for the gpio device and registers
@@ -539,17 +548,17 @@ static const struct dev_pm_ops xgpiops_dev_pm_ops = {
  * Note: Interrupts are disabled for all the banks during initialization.
  * Returns 0 on success, negative error otherwise.
  */
-static int xgpiops_probe(struct platform_device *pdev)
+static int zynq_gpio_probe(struct platform_device *pdev)
 {
 	int ret;
 	unsigned int irq_num;
-	struct xgpiops *gpio;
+	struct zynq_gpio *gpio;
 	struct gpio_chip *chip;
 	resource_size_t remap_size;
 	struct resource *mem_res = NULL;
 	int pin_num, bank_num, gpio_irq;
 
-	gpio = kzalloc(sizeof(struct xgpiops), GFP_KERNEL);
+	gpio = kzalloc(sizeof(struct zynq_gpio), GFP_KERNEL);
 	if (!gpio) {
 		dev_err(&pdev->dev,
 			"couldn't allocate memory for gpio private data\n");
@@ -587,19 +596,19 @@ static int xgpiops_probe(struct platform_device *pdev)
 
 	/* configure the gpio chip */
 	chip = &gpio->chip;
-	chip->label = "xgpiops";
+	chip->label = "zynq_gpio";
 	chip->owner = THIS_MODULE;
 	chip->dev = &pdev->dev;
-	chip->get = xgpiops_get_value;
-	chip->set = xgpiops_set_value;
-	chip->request = xgpiops_request;
-	chip->free = xgpiops_free;
-	chip->direction_input = xgpiops_dir_in;
-	chip->direction_output = xgpiops_dir_out;
-	chip->to_irq = xgpiops_to_irq;
+	chip->get = zynq_gpio_get_value;
+	chip->set = zynq_gpio_set_value;
+	chip->request = zynq_gpio_request;
+	chip->free = zynq_gpio_free;
+	chip->direction_input = zynq_gpio_dir_in;
+	chip->direction_output = zynq_gpio_dir_out;
+	chip->to_irq = zynq_gpio_to_irq;
 	chip->dbg_show = NULL;
 	chip->base = 0;		/* default pin base */
-	chip->ngpio = XGPIOPS_NR_GPIOS;
+	chip->ngpio = ZYNQ_GPIO_NR_GPIOS;
 	chip->can_sleep = 0;
 
 	gpio->irq_base = irq_alloc_descs(-1, 0, chip->ngpio, 0);
@@ -639,27 +648,27 @@ static int xgpiops_probe(struct platform_device *pdev)
 
 	/* disable interrupts for all banks */
 	for (bank_num = 0; bank_num < 4; bank_num++) {
-		xgpiops_writereg(0xffffffff, gpio->base_addr +
-				  XGPIOPS_INTDIS_OFFSET(bank_num));
+		zynq_gpio_writereg(0xffffffff, gpio->base_addr +
+				  ZYNQ_GPIO_INTDIS_OFFSET(bank_num));
 	}
 
 	/*
 	 * set the irq chip, handler and irq chip data for callbacks for
 	 * each pin
 	 */
-	for (pin_num = 0; pin_num < min_t(int, XGPIOPS_NR_GPIOS,
+	for (pin_num = 0; pin_num < min_t(int, ZYNQ_GPIO_NR_GPIOS,
 						(int)chip->ngpio); pin_num++) {
 		gpio_irq = irq_find_mapping(irq_domain, pin_num);
-		irq_set_chip_and_handler(gpio_irq, &xgpiops_irqchip,
+		irq_set_chip_and_handler(gpio_irq, &zynq_gpio_irqchip,
 							handle_simple_irq);
 		irq_set_chip_data(gpio_irq, (void *)gpio);
 		set_irq_flags(gpio_irq, IRQF_VALID);
 	}
 
 	irq_set_handler_data(irq_num, (void *)gpio);
-	irq_set_chained_handler(irq_num, xgpiops_irqhandler);
+	irq_set_chained_handler(irq_num, zynq_gpio_irqhandler);
 
-	xgpiops_pm_runtime_init(pdev);
+	zynq_gpio_pm_runtime_init(pdev);
 
 	device_set_wakeup_capable(&pdev->dev, 1);
 
@@ -680,9 +689,9 @@ err_free_gpio:
 	return ret;
 }
 
-static int xgpiops_remove(struct platform_device *pdev)
+static int zynq_gpio_remove(struct platform_device *pdev)
 {
-	struct xgpiops *gpio = platform_get_drvdata(pdev);
+	struct zynq_gpio *gpio = platform_get_drvdata(pdev);
 
 	clk_disable_unprepare(gpio->clk);
 	clk_put(gpio->clk);
@@ -690,29 +699,29 @@ static int xgpiops_remove(struct platform_device *pdev)
 	return 0;
 }
 
-static struct of_device_id xgpiops_of_match[] = {
+static struct of_device_id zynq_gpio_of_match[] = {
 	{ .compatible = "xlnx,ps7-gpio-1.00.a", },
 	{ /* end of table */}
 };
-MODULE_DEVICE_TABLE(of, xgpiops_of_match);
+MODULE_DEVICE_TABLE(of, zynq_gpio_of_match);
 
-static struct platform_driver xgpiops_driver = {
+static struct platform_driver zynq_gpio_driver = {
 	.driver	= {
 		.name	= DRIVER_NAME,
 		.owner	= THIS_MODULE,
-		.pm	= XGPIOPS_PM,
-		.of_match_table = xgpiops_of_match,
+		.pm	= ZYNQ_GPIO_PM,
+		.of_match_table = zynq_gpio_of_match,
 	},
-	.probe		= xgpiops_probe,
-	.remove		= xgpiops_remove,
+	.probe		= zynq_gpio_probe,
+	.remove		= zynq_gpio_remove,
 };
 
 /**
- * xgpiops_init - Initial driver registration call
+ * zynq_gpio_init - Initial driver registration call
  */
-static int __init xgpiops_init(void)
+static int __init zynq_gpio_init(void)
 {
-	return platform_driver_register(&xgpiops_driver);
+	return platform_driver_register(&zynq_gpio_driver);
 }
 
-postcore_initcall(xgpiops_init);
+postcore_initcall(zynq_gpio_init);
-- 
1.7.5.4

