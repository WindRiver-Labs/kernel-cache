From a9de0cc1bf5f142671c7d6c5328e19f7914d01e8 Mon Sep 17 00:00:00 2001
From: John Linn <john.linn@xilinx.com>
Date: Mon, 7 Feb 2011 16:01:43 -0700
Subject: [PATCH 352/509] Xilinx: ARM: DMA: Adding support for AXI DMA engines

https://github.com/analogdevicesinc/linux.git xcomm_zynq
commit 8ed06c8fef7d9624c58c2f6806966b9c1c6ee974

Some lite testing has been done. Platform data was added to the
driver and the user has to set it up manually to match the
soft IP configuration (in devices.c).  There are 2 tests in
drivers/dma that can be renamed dmatest.c and then used to
test the appropriate DMA engine.

Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 drivers/dma/xilinx_dma.c |  421 ++++++++++++++++++++++++++++++++++++++++++++--
 1 files changed, 408 insertions(+), 13 deletions(-)

diff --git a/drivers/dma/xilinx_dma.c b/drivers/dma/xilinx_dma.c
index d6c858f..083a042 100644
--- a/drivers/dma/xilinx_dma.c
+++ b/drivers/dma/xilinx_dma.c
@@ -25,6 +25,8 @@
  *
  */
 
+// #define TEST_DMA_WITH_LOOPBACK
+
 #include <linux/init.h>
 #include <linux/module.h>
 #include <linux/slab.h>
@@ -34,6 +36,11 @@
 #include <linux/of_platform.h>
 #include <linux/of_address.h>
 #include <linux/amba/xilinx_dma.h>
+#include <linux/string.h>
+
+#include <asm/io.h>
+#include <linux/amba/xilinx_dma.h>
+#include <linux/platform_device.h>
 
 /* General register bits definitions
  */
@@ -114,8 +121,9 @@
 
 /* IO accessors
  */
-#define DMA_OUT(addr, val)  (out_le32(addr, val))
-#define DMA_IN(addr)  (in_le32(addr))
+
+#define DMA_OUT(addr, val)  (iowrite32(val, addr))
+#define DMA_IN(addr)  (ioread32(addr))
 
 /* Hardware descriptor
  *
@@ -707,14 +715,13 @@ static void xilinx_dma_update_completed_cookie(struct xilinx_dma_chan *chan)
 
 	/* Get the last completed descriptor, update the cookie to that */
 	list_for_each_entry(desc, &chan->active_list, node) {
-		if (chan->has_SG) {
+		if ((!(chan->feature & XILINX_DMA_IP_VDMA)) && chan->has_SG) {
 			hw = &desc->hw;
 
 			/* If a BD has no status bits set, hw has it */
-			if (!hw->status & XILINX_DMA_BD_STS_ALL_MASK) {
+			if (!(hw->status & XILINX_DMA_BD_STS_ALL_MASK)) {
 				break;
-			}
-			else {
+			} else {
 				done = 1;
 				cookie = desc->async_tx.cookie;
 			}
@@ -1118,6 +1125,9 @@ static struct dma_async_tx_descriptor *xilinx_dma_prep_slave_sg(
 				first = new;
 				if (direction == DMA_TO_DEVICE) {
 					hw->control |= XILINX_DMA_BD_SOP;
+#ifdef TEST_DMA_WITH_LOOPBACK
+					hw->app_4 = copy;
+#endif
 				}
 			} else {
 				prev_hw = &(prev->hw);
@@ -1470,6 +1480,16 @@ static int my_log(int value)
 	return i;
 }
 
+
+#ifdef CONFIG_OF
+
+static void xilinx_dma_chan_remove(struct xilinx_dma_chan *chan)
+{
+	irq_dispose_mapping(chan->irq);
+	list_del(&chan->common.device_node);
+	kfree(chan);
+}
+
 /*
  * Probing channels
  *
@@ -1647,13 +1667,6 @@ out_return:
 	return err;
 }
 
-static void xilinx_dma_chan_remove(struct xilinx_dma_chan *chan)
-{
-	irq_dispose_mapping(chan->irq);
-	list_del(&chan->common.device_node);
-	kfree(chan);
-}
-
 static int __devinit xilinx_dma_of_probe(struct platform_device *op,
 			const struct of_device_id *match)
 {
@@ -1846,5 +1859,387 @@ static void __exit xilinx_dma_exit(void)
 subsys_initcall(xilinx_dma_init);
 module_exit(xilinx_dma_exit);
 
+#else
+
+/**************************************************/
+/* Platform bus to support ARM before device tree */
+/**************************************************/
+
+/* The following probe and chan_probe functions were
+   copied from the OF section above, then modified
+   to use platform data.
+*/
+
+static void xilinx_dma_chan_remove(struct xilinx_dma_chan *chan)
+{
+	free_irq(chan->irq, chan);
+	list_del(&chan->common.device_node);
+	kfree(chan);
+}
+
+/*
+ * Probing channels
+ *
+ * . Get channel features from the device tree entry
+ * . Initialize special channel handling routines
+ */
+static int __devinit xilinx_dma_chan_probe(struct platform_device *pdev, 
+				struct xilinx_dma_device *xdev,
+				struct dma_channel_config *channel_config, 
+				int channel_num, u32 feature)
+{
+	struct xilinx_dma_chan *chan;
+	int err;
+	u32 width = 0;
+	struct resource *res;
+
+	/* alloc channel */
+
+
+	chan = kzalloc(sizeof(*chan), GFP_KERNEL);
+	if (!chan) {
+		dev_err(xdev->dev, "no free memory for DMA channels!\n");
+		err = -ENOMEM;
+		goto out_return;
+	}
+
+	chan->feature = feature;
+	chan->is_lite = 0;
+	chan->has_DRE = 0;
+	chan->has_SG = 0;
+	chan->max_len = XILINX_DMA_MAX_TRANS_LEN;
+
+	if (channel_config->include_dre) 
+		chan->has_DRE = 1;
+
+	if (channel_config->genlock_mode)
+		chan->genlock = 1;
+
+	width = channel_config->datawidth >> 3;
+	chan->feature |= width - 1;
+
+	if (feature & XILINX_DMA_IP_CDMA) {
+
+		chan->direction = DMA_BIDIRECTIONAL;
+		chan->start_transfer = xilinx_cdma_start_transfer;
+
+		chan->has_SG = (xdev->feature & XILINX_DMA_FTR_HAS_SG) >>
+		         XILINX_DMA_FTR_HAS_SG_SHIFT;
+
+		if (channel_config->lite_mode) {
+			chan->is_lite = 1;
+			chan->max_len = width * channel_config->max_burst_len;
+		}
+	}
+
+	if (feature & XILINX_DMA_IP_DMA) {
+		chan->has_SG = 1;
+		chan->start_transfer = xilinx_dma_start_transfer;
+
+		if (!strcmp(channel_config->type, "axi-dma-mm2s-channel")) {
+			chan->direction = DMA_TO_DEVICE;
+		}
+
+		if (!strcmp(channel_config->type, "axi-dma-s2mm-channel")) {
+			chan->direction = DMA_FROM_DEVICE;
+		}
+	}
+
+	if (feature & XILINX_DMA_IP_VDMA) {
+
+		chan->start_transfer = xilinx_vdma_start_transfer;
+
+		chan->has_SG = (xdev->feature & XILINX_DMA_FTR_HAS_SG) >>
+		         XILINX_DMA_FTR_HAS_SG_SHIFT;
+
+		if (!strcmp(channel_config->type, "axi-vdma-mm2s-channel")) {
+
+			printk("axi-vdma-mm2s-channel found\n");
+
+			chan->direction = DMA_TO_DEVICE;
+			if (!chan->has_SG) {
+				chan->addr_regs = (struct vdma_addr_regs *)
+				    ((u32)xdev->regs + XILINX_VDMA_DIRECT_REG_OFFSET);
+			}
+		}
+
+		if (!strcmp(channel_config->type, "axi-vdma-s2mm-channel")) {
+
+			printk("axi-vdma-s2mm-channel found\n");
+
+			chan->direction = DMA_FROM_DEVICE;
+			if (!chan->has_SG) {
+				chan->addr_regs = (struct vdma_addr_regs *)
+				    ((u32)xdev->regs + XILINX_VDMA_DIRECT_REG_OFFSET +
+				    XILINX_VDMA_CHAN_DIRECT_REG_SIZE);
+			}
+		}
+	}
+
+	chan->regs = (struct xdma_regs *)xdev->regs;
+	chan->id = 0;
+
+	if (chan->direction == DMA_FROM_DEVICE) {
+		chan->regs = (struct xdma_regs *)((u32)xdev->regs +
+		                       XILINX_DMA_RX_CHANNEL_OFFSET);
+		chan->id = 1;
+	}
+
+	/* Used by dmatest channel matching in slave transfers
+	 * Can change it to be a structure to have more matching information
+	 */
+	chan->private = (chan->direction & 0xFF) |
+	          (chan->feature & XILINX_DMA_IP_MASK);
+	chan->common.private = (void *)&(chan->private);
+
+	if (!chan->has_DRE) {
+		xdev->common.copy_align = my_log(width);
+	}
+
+	chan->dev = xdev->dev;
+	xdev->chan[chan->id] = chan;
+
+	tasklet_init(&chan->tasklet, dma_do_tasklet, (unsigned long)chan);
+
+	/* Initialize the channel */
+	if (dma_init(chan)) {
+		dev_err(xdev->dev, "Reset channel failed\n");
+		goto out_free_chan;
+	}
+
+
+	spin_lock_init(&chan->lock);
+	INIT_LIST_HEAD(&chan->pending_list);
+	INIT_LIST_HEAD(&chan->active_list);
+
+	chan->common.device = &xdev->common;
+
+	/* setup the interrupt for the channel */
+
+	res = platform_get_resource(pdev, IORESOURCE_IRQ, channel_num);
+	chan->irq = res->start;
+
+	err = request_irq(chan->irq, dma_intr_handler, IRQF_SHARED,
+	                  "xilinx-dma-controller", chan);
+	if (err) {
+		dev_err(xdev->dev, "unable to request IRQ\n");
+		goto out_free_irq;
+	} else 
+		dev_info(&pdev->dev, "using irq %d\n", chan->irq);
+
+	/* Add the channel to DMA device channel list */
+	list_add_tail(&chan->common.device_node, &xdev->common.channels);
+	xdev->common.chancnt++;
+
+	return 0;
+
+out_free_irq:
+	free_irq(chan->irq, chan);
+out_free_chan:
+	kfree(chan);
+out_return:
+	return err;
+}
+
+static int __devinit xilinx_dma_probe(struct platform_device *pdev)
+{
+	struct xilinx_dma_device *xdev;
+	int err;
+	int num_frames = 0;
+	struct resource *res;
+	struct device *dev = &pdev->dev;
+	struct dma_device_config *dma_config;
+	int channel;
+
+	dev_info(&pdev->dev, "Probing xilinx axi dma engines\n");
+
+	xdev = kzalloc(sizeof(struct xilinx_dma_device), GFP_KERNEL);
+	if (!xdev) {
+		dev_err(&pdev->dev, "Not enough memory for device\n");
+		err = -ENOMEM;
+		goto out_return;
+	}
+
+	xdev->dev = &(pdev->dev);
+	INIT_LIST_HEAD(&xdev->common.channels);
+
+	xdev->feature = 0;
+
+	/* iomap registers */
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		printk(KERN_ERR "get_resource for MEM resource for dev %d "
+		       "failed\n", pdev->id);
+		err = -ENOMEM;
+		goto out_return;
+	} else {
+		dev_info(&pdev->dev, "device %d actual base is %x\n",
+		       pdev->id, (unsigned int)res->start);
+	}
+	if (!request_mem_region(res->start, 0x1000, "xilinx_axidma")) {
+		printk(KERN_ERR "memory request failue for base %x\n",
+		       (unsigned int)res->start);
+		err = -ENOMEM;
+		goto out_return;
+	}
+
+	xdev->regs = ioremap(res->start, 0x1000);
+	pr_info("dma base remapped: %lx\n", (unsigned long)xdev->regs);
+	if (!xdev->regs) {
+		dev_err(&pdev->dev, "unable to iomap registers\n");
+		err = -ENOMEM;
+		goto out_free_xdev;
+	} 
+
+	dma_config = (struct dma_device_config *)dev->platform_data;
+
+	/* Axi CDMA only does memcpy
+	 */	
+	if (!strcmp(dma_config->type, "axi-cdma")) {
+
+		pr_info("found an axi-cdma configuration\n");
+		xdev->feature |= XILINX_DMA_IP_CDMA;
+
+		if (dma_config->include_sg) {
+			xdev->feature |= XILINX_DMA_FTR_HAS_SG;
+		}
+
+		dma_cap_set(DMA_MEMCPY, xdev->common.cap_mask);
+		xdev->common.device_prep_dma_memcpy = xilinx_dma_prep_memcpy;
+		xdev->common.device_control = xilinx_dma_device_control;
+		xdev->common.device_issue_pending = xilinx_cdma_issue_pending;
+	}
+	
+	/* Axi DMA and VDMA only do slave transfers
+	 */
+	if (!strcmp(dma_config->type, "axi-dma")) {
+
+		pr_info("found an axi-dma configuration\n");
+
+		xdev->feature |= XILINX_DMA_IP_DMA;
+		if (dma_config->sg_include_stscntrl_strm)
+			xdev->feature |= XILINX_DMA_FTR_STSCNTRL_STRM;
+
+		dma_cap_set(DMA_SLAVE, xdev->common.cap_mask);
+		dma_cap_set(DMA_PRIVATE, xdev->common.cap_mask);
+		xdev->common.device_prep_slave_sg = xilinx_dma_prep_slave_sg;
+		xdev->common.device_control = xilinx_dma_device_control;
+		xdev->common.device_issue_pending = xilinx_dma_issue_pending;
+	}
+	
+	if (!strcmp(dma_config->type, "axi-vdma")) {
+
+		pr_info("found an axi-vdma configuration\n");
+
+		xdev->feature |= XILINX_DMA_IP_VDMA;
+
+		if (dma_config->include_sg) {
+			xdev->feature |= XILINX_DMA_FTR_HAS_SG;
+		}
+
+		num_frames = dma_config->num_fstores;
+
+		dma_cap_set(DMA_SLAVE, xdev->common.cap_mask);
+		dma_cap_set(DMA_PRIVATE, xdev->common.cap_mask);
+		xdev->common.device_prep_slave_sg = xilinx_vdma_prep_slave_sg;
+		xdev->common.device_control = xilinx_vdma_device_control;
+		xdev->common.device_issue_pending = xilinx_vdma_issue_pending;
+	}
+	
+	xdev->common.device_alloc_chan_resources =
+	                    xilinx_dma_alloc_chan_resources;
+	xdev->common.device_free_chan_resources =
+	                    xilinx_dma_free_chan_resources;
+	xdev->common.device_tx_status = xilinx_tx_status;
+	xdev->common.dev = &pdev->dev;
+
+	dev_set_drvdata(&pdev->dev, xdev);
+
+	for (channel = 0; channel < dma_config->channel_count; channel++)
+		xilinx_dma_chan_probe(pdev, xdev, &dma_config->channel_config[channel], 
+					channel, xdev->feature);
+
+	if (xdev->feature & XILINX_DMA_IP_VDMA) {
+		int i;
+
+		for (i = 0; i < XILINX_DMA_MAX_CHANS_PER_DEVICE; i++) {
+			if (xdev->chan[i]) {
+				xdev->chan[i]->num_frms = num_frames;
+			}
+		}
+	}
+
+	dma_async_device_register(&xdev->common);
+
+	return 0;
+
+out_free_xdev:
+	kfree(xdev);
+
+out_return:
+	return err;
+}
+
+
+static int __exit xilinx_dma_remove(struct platform_device *pdev)
+{
+	struct xilinx_dma_device *xdev = platform_get_drvdata(pdev);
+	int i;
+ 
+#if 1
+	dma_async_device_unregister(&xdev->common);
+#endif
+	for (i = 0; i < 2; i++) {
+		if (xdev->chan[i])
+			xilinx_dma_chan_remove(xdev->chan[i]);
+	}
+	
+	iounmap(xdev->regs);
+	dev_set_drvdata(&pdev->dev, NULL);
+	kfree(xdev);
+
+	return 0;
+}
+
+static void xilinx_dma_shutdown(struct platform_device *pdev)
+{
+	struct xilinx_dma_device *xdev = platform_get_drvdata(pdev);
+	int i;
+
+	for(i = 0; i < 2; i++) {
+		dma_halt(xdev->chan[i]);
+	}	 
+}
+
+static struct platform_driver xilinx_dma_driver = {
+	.probe = xilinx_dma_probe,
+	.remove = __exit_p(xilinx_dma_remove),
+	.shutdown = xilinx_dma_shutdown,
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = "xilinx-axidma",
+	},
+};
+
+/*----------------------------------------------------------------------------*/
+/* Module Init / Exit                                                         */
+/*----------------------------------------------------------------------------*/
+
+static __init int xilinx_dma_init(void)
+{
+	int status;
+	status = platform_driver_register(&xilinx_dma_driver);
+	return status;
+}
+module_init(xilinx_dma_init);
+
+static void __exit xilinx_dma_exit(void)
+{
+	platform_driver_unregister(&xilinx_dma_driver);
+}
+
+module_exit(xilinx_dma_exit);
+#endif
+
 MODULE_DESCRIPTION("Xilinx DMA/CDMA/VDMA driver");
 MODULE_LICENSE("GPL");
-- 
1.7.5.4

