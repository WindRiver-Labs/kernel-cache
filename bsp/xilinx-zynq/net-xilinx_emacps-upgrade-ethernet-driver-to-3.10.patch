From eaa60c4793270f0b939d563ce02c9b41aa7a2450 Mon Sep 17 00:00:00 2001
From: Liming Wang <liming.wang@windriver.com>
Date: Thu, 27 Feb 2014 15:56:24 +0800
Subject: [PATCH 1/7] net: xilinx_emacps: upgrade ethernet driver to 3.10

The patch based on commit:
https://github.com/Xilinx/linux-xlnx/commit/852ddaa8975b9e2d22d10c1a0fed6cd7010db3e4

Because the original driver is not stable and mature, upgrade the driver
to 3.10. Copy the corresponding file from above commit.

And fix following compiling error:
error: 'struct net_local' has no member named 'compare'

Also update the dtb file to make ethernet driver work properly.

Signed-off-by: Liming Wang <liming.wang@windriver.com>
---
 arch/arm/boot/dts/zc702.dtsi                |   26 +-
 drivers/net/ethernet/xilinx/xilinx_emacps.c | 2378 +++++++++++++++------------
 2 files changed, 1308 insertions(+), 1096 deletions(-)

diff --git a/arch/arm/boot/dts/zc702.dtsi b/arch/arm/boot/dts/zc702.dtsi
index 0eaccca..76fce53 100644
--- a/arch/arm/boot/dts/zc702.dtsi
+++ b/arch/arm/boot/dts/zc702.dtsi
@@ -169,8 +169,12 @@
 			compatible = "xlnx,ps7-ethernet-1.00.a";
 			reg = <0xe000b000 0x1000>;
 			interrupts = <0 0x16 0x4>;
-			phy-handle = <0x2>;
-			xlnx,ptp-enet-clock = <111111111>;
+			phy-handle = <&phy0>;
+			phy-mode = "rgmii-id";
+			xlnx,enet-reset = "MIO 11";
+			xlnx,eth-mode = <0x1>;
+			xlnx,has-mdio = <0x1>;
+			xlnx,ptp-enet-clock = <111111115>;
 			xlnx,slcr-div0-1000Mbps = <8>;
 			xlnx,slcr-div0-100Mbps = <8>;
 			xlnx,slcr-div0-10Mbps = <8>;
@@ -179,15 +183,15 @@
 			xlnx,slcr-div1-10Mbps = <50>;
 			#address-cells = <0x1>;
 			#size-cells = <0x0>;
-
-			phy@23 {
-				compatible = "marvell,88e1111";
-				device_type = "ethernet-phy";
-				reg = <0x7>;
-				marvell,reg-init = <0x2 0x15 0x0 0x20>;
-				linux,phandle = <0x2>;
-				phandle = <0x2>;
-			};
+			mdio {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				phy0: phy@7 {
+					compatible = "marvell,88e1116r";
+					device_type = "ethernet-phy";
+					reg = <7>;
+				} ;
+			} ;
 		};
 
 		qspi@e000d000 {
diff --git a/drivers/net/ethernet/xilinx/xilinx_emacps.c b/drivers/net/ethernet/xilinx/xilinx_emacps.c
index edd358b..038a8b7 100644
--- a/drivers/net/ethernet/xilinx/xilinx_emacps.c
+++ b/drivers/net/ethernet/xilinx/xilinx_emacps.c
@@ -4,7 +4,7 @@
  * Author: Xilinx, Inc.
  *
  * 2010 (c) Xilinx, Inc. This file is licensed uner the terms of the GNU
- * General Public License version 2.1. This program is licensed "as is"
+ * General Public License version 2. This program is licensed "as is"
  * without any warranty of any kind, whether express or implied.
  *
  * This is a driver for xilinx processor sub-system (ps) ethernet device.
@@ -15,12 +15,6 @@
  * TODO:
  * 1. JUMBO frame is not enabled per EPs spec. Please update it if this
  *    support is added in and set MAX_MTU to 9000.
- * 2. For PEEP boards the Linux PHY driver state machine is not used. Hence
- *    no autonegotiation happens for PEEP. The speed of 100 Mbps is used and
- *    it is fixed. The speed cannot be changed to 10 Mbps or 1000 Mbps. However
- *    for Zynq there is no such issue and it can work at all 3 speeds after
- *    autonegotiation.
- * 3. The SLCR clock divisors are hard coded for PEEP board.
  */
 
 #include <linux/module.h>
@@ -39,16 +33,522 @@
 #include <linux/vmalloc.h>
 #include <linux/version.h>
 #include <linux/of.h>
-#include <mach/slcr.h>
 #include <linux/interrupt.h>
 #include <linux/clocksource.h>
 #include <linux/timecompare.h>
 #include <linux/net_tstamp.h>
-#ifdef CONFIG_OF
+#include <linux/pm_runtime.h>
+#include <linux/clk.h>
+#include <linux/of_net.h>
 #include <linux/of_address.h>
 #include <linux/of_mdio.h>
+#include <linux/timer.h>
+
+/************************** Constant Definitions *****************************/
+
+/* Must be shorter than length of ethtool_drvinfo.driver field to fit */
+#define DRIVER_NAME			"xemacps"
+#define DRIVER_DESCRIPTION		"Xilinx Tri-Mode Ethernet MAC driver"
+#define DRIVER_VERSION			"1.00a"
+
+/* Transmission timeout is 3 seconds. */
+#define TX_TIMEOUT			(3*HZ)
+
+/* for RX skb IP header word-aligned */
+#define RX_IP_ALIGN_OFFSET		2
+
+/* DMA buffer descriptors must be aligned on a 4-byte boundary. */
+#define ALIGNMENT_BD			8
+
+/* Maximum value for hash bits. 2**6 */
+#define XEMACPS_MAX_HASH_BITS		64
+
+/* MDC clock division
+ * currently supporting 8, 16, 32, 48, 64, 96, 128, 224.
+ */
+enum { MDC_DIV_8 = 0, MDC_DIV_16, MDC_DIV_32, MDC_DIV_48,
+MDC_DIV_64, MDC_DIV_96, MDC_DIV_128, MDC_DIV_224 };
+
+/* Specify the receive buffer size in bytes, 64, 128, 192, 10240 */
+#define XEMACPS_RX_BUF_SIZE		1536
+
+/* Number of receive buffer bytes as a unit, this is HW setup */
+#define XEMACPS_RX_BUF_UNIT		64
+
+/* Default SEND and RECV buffer descriptors (BD) numbers.
+ * BD Space needed is (XEMACPS_SEND_BD_CNT+XEMACPS_RECV_BD_CNT)*8
+ */
+#undef  DEBUG
+#define DEBUG
+
+#define XEMACPS_SEND_BD_CNT		256
+#define XEMACPS_RECV_BD_CNT		256
+
+#define XEMACPS_NAPI_WEIGHT		64
+
+/* Register offset definitions. Unless otherwise noted, register access is
+ * 32 bit. Names are self explained here.
+ */
+#define XEMACPS_NWCTRL_OFFSET		0x00000000 /* Network Control reg */
+#define XEMACPS_NWCFG_OFFSET		0x00000004 /* Network Config reg */
+#define XEMACPS_NWSR_OFFSET		0x00000008 /* Network Status reg */
+#define XEMACPS_USERIO_OFFSET		0x0000000C /* User IO reg */
+#define XEMACPS_DMACR_OFFSET		0x00000010 /* DMA Control reg */
+#define XEMACPS_TXSR_OFFSET		0x00000014 /* TX Status reg */
+#define XEMACPS_RXQBASE_OFFSET		0x00000018 /* RX Q Base address reg */
+#define XEMACPS_TXQBASE_OFFSET		0x0000001C /* TX Q Base address reg */
+#define XEMACPS_RXSR_OFFSET		0x00000020 /* RX Status reg */
+#define XEMACPS_ISR_OFFSET		0x00000024 /* Interrupt Status reg */
+#define XEMACPS_IER_OFFSET		0x00000028 /* Interrupt Enable reg */
+#define XEMACPS_IDR_OFFSET		0x0000002C /* Interrupt Disable reg */
+#define XEMACPS_IMR_OFFSET		0x00000030 /* Interrupt Mask reg */
+#define XEMACPS_PHYMNTNC_OFFSET		0x00000034 /* Phy Maintaince reg */
+#define XEMACPS_RXPAUSE_OFFSET		0x00000038 /* RX Pause Time reg */
+#define XEMACPS_TXPAUSE_OFFSET		0x0000003C /* TX Pause Time reg */
+#define XEMACPS_HASHL_OFFSET		0x00000080 /* Hash Low address reg */
+#define XEMACPS_HASHH_OFFSET		0x00000084 /* Hash High address reg */
+#define XEMACPS_LADDR1L_OFFSET		0x00000088 /* Specific1 addr low */
+#define XEMACPS_LADDR1H_OFFSET		0x0000008C /* Specific1 addr high */
+#define XEMACPS_LADDR2L_OFFSET		0x00000090 /* Specific2 addr low */
+#define XEMACPS_LADDR2H_OFFSET		0x00000094 /* Specific2 addr high */
+#define XEMACPS_LADDR3L_OFFSET		0x00000098 /* Specific3 addr low */
+#define XEMACPS_LADDR3H_OFFSET		0x0000009C /* Specific3 addr high */
+#define XEMACPS_LADDR4L_OFFSET		0x000000A0 /* Specific4 addr low */
+#define XEMACPS_LADDR4H_OFFSET		0x000000A4 /* Specific4 addr high */
+#define XEMACPS_MATCH1_OFFSET		0x000000A8 /* Type ID1 Match reg */
+#define XEMACPS_MATCH2_OFFSET		0x000000AC /* Type ID2 Match reg */
+#define XEMACPS_MATCH3_OFFSET		0x000000B0 /* Type ID3 Match reg */
+#define XEMACPS_MATCH4_OFFSET		0x000000B4 /* Type ID4 Match reg */
+#define XEMACPS_WOL_OFFSET		0x000000B8 /* Wake on LAN reg */
+#define XEMACPS_STRETCH_OFFSET		0x000000BC /* IPG Stretch reg */
+#define XEMACPS_SVLAN_OFFSET		0x000000C0 /* Stacked VLAN reg */
+#define XEMACPS_MODID_OFFSET		0x000000FC /* Module ID reg */
+#define XEMACPS_OCTTXL_OFFSET		0x00000100 /* Octects transmitted Low
+						reg */
+#define XEMACPS_OCTTXH_OFFSET		0x00000104 /* Octects transmitted High
+						reg */
+#define XEMACPS_TXCNT_OFFSET		0x00000108 /* Error-free Frmaes
+						transmitted counter */
+#define XEMACPS_TXBCCNT_OFFSET		0x0000010C /* Error-free Broadcast
+						Frames counter*/
+#define XEMACPS_TXMCCNT_OFFSET		0x00000110 /* Error-free Multicast
+						Frame counter */
+#define XEMACPS_TXPAUSECNT_OFFSET	0x00000114 /* Pause Frames Transmitted
+						Counter */
+#define XEMACPS_TX64CNT_OFFSET		0x00000118 /* Error-free 64 byte Frames
+						Transmitted counter */
+#define XEMACPS_TX65CNT_OFFSET		0x0000011C /* Error-free 65-127 byte
+						Frames Transmitted counter */
+#define XEMACPS_TX128CNT_OFFSET		0x00000120 /* Error-free 128-255 byte
+						Frames Transmitted counter */
+#define XEMACPS_TX256CNT_OFFSET		0x00000124 /* Error-free 256-511 byte
+						Frames transmitted counter */
+#define XEMACPS_TX512CNT_OFFSET		0x00000128 /* Error-free 512-1023 byte
+						Frames transmitted counter */
+#define XEMACPS_TX1024CNT_OFFSET	0x0000012C /* Error-free 1024-1518 byte
+						Frames transmitted counter */
+#define XEMACPS_TX1519CNT_OFFSET	0x00000130 /* Error-free larger than
+						1519 byte Frames transmitted
+						Counter */
+#define XEMACPS_TXURUNCNT_OFFSET	0x00000134 /* TX under run error
+						Counter */
+#define XEMACPS_SNGLCOLLCNT_OFFSET	0x00000138 /* Single Collision Frame
+						Counter */
+#define XEMACPS_MULTICOLLCNT_OFFSET	0x0000013C /* Multiple Collision Frame
+						Counter */
+#define XEMACPS_EXCESSCOLLCNT_OFFSET	0x00000140 /* Excessive Collision Frame
+						Counter */
+#define XEMACPS_LATECOLLCNT_OFFSET	0x00000144 /* Late Collision Frame
+						Counter */
+#define XEMACPS_TXDEFERCNT_OFFSET	0x00000148 /* Deferred Transmission
+						Frame Counter */
+#define XEMACPS_CSENSECNT_OFFSET	0x0000014C /* Carrier Sense Error
+						Counter */
+#define XEMACPS_OCTRXL_OFFSET		0x00000150 /* Octects Received register
+						Low */
+#define XEMACPS_OCTRXH_OFFSET		0x00000154 /* Octects Received register
+						High */
+#define XEMACPS_RXCNT_OFFSET		0x00000158 /* Error-free Frames
+						Received Counter */
+#define XEMACPS_RXBROADCNT_OFFSET	0x0000015C /* Error-free Broadcast
+						Frames Received Counter */
+#define XEMACPS_RXMULTICNT_OFFSET	0x00000160 /* Error-free Multicast
+						Frames Received Counter */
+#define XEMACPS_RXPAUSECNT_OFFSET	0x00000164 /* Pause Frames
+						Received Counter */
+#define XEMACPS_RX64CNT_OFFSET		0x00000168 /* Error-free 64 byte Frames
+						Received Counter */
+#define XEMACPS_RX65CNT_OFFSET		0x0000016C /* Error-free 65-127 byte
+						Frames Received Counter */
+#define XEMACPS_RX128CNT_OFFSET		0x00000170 /* Error-free 128-255 byte
+						Frames Received Counter */
+#define XEMACPS_RX256CNT_OFFSET		0x00000174 /* Error-free 256-512 byte
+						Frames Received Counter */
+#define XEMACPS_RX512CNT_OFFSET		0x00000178 /* Error-free 512-1023 byte
+						Frames Received Counter */
+#define XEMACPS_RX1024CNT_OFFSET	0x0000017C /* Error-free 1024-1518 byte
+						Frames Received Counter */
+#define XEMACPS_RX1519CNT_OFFSET	0x00000180 /* Error-free 1519-max byte
+						Frames Received Counter */
+#define XEMACPS_RXUNDRCNT_OFFSET	0x00000184 /* Undersize Frames Received
+						Counter */
+#define XEMACPS_RXOVRCNT_OFFSET		0x00000188 /* Oversize Frames Received
+						Counter */
+#define XEMACPS_RXJABCNT_OFFSET		0x0000018C /* Jabbers Received
+						Counter */
+#define XEMACPS_RXFCSCNT_OFFSET		0x00000190 /* Frame Check Sequence
+						Error Counter */
+#define XEMACPS_RXLENGTHCNT_OFFSET	0x00000194 /* Length Field Error
+						Counter */
+#define XEMACPS_RXSYMBCNT_OFFSET	0x00000198 /* Symbol Error Counter */
+#define XEMACPS_RXALIGNCNT_OFFSET	0x0000019C /* Alignment Error
+						Counter */
+#define XEMACPS_RXRESERRCNT_OFFSET	0x000001A0 /* Receive Resource Error
+						Counter */
+#define XEMACPS_RXORCNT_OFFSET		0x000001A4 /* Receive Overrun */
+#define XEMACPS_RXIPCCNT_OFFSET		0x000001A8 /* IP header Checksum Error
+						Counter */
+#define XEMACPS_RXTCPCCNT_OFFSET	0x000001AC /* TCP Checksum Error
+						Counter */
+#define XEMACPS_RXUDPCCNT_OFFSET	0x000001B0 /* UDP Checksum Error
+						Counter */
+
+#define XEMACPS_1588S_OFFSET		0x000001D0 /* 1588 Timer Seconds */
+#define XEMACPS_1588NS_OFFSET		0x000001D4 /* 1588 Timer Nanoseconds */
+#define XEMACPS_1588ADJ_OFFSET		0x000001D8 /* 1588 Timer Adjust */
+#define XEMACPS_1588INC_OFFSET		0x000001DC /* 1588 Timer Increment */
+#define XEMACPS_PTPETXS_OFFSET		0x000001E0 /* PTP Event Frame
+						Transmitted Seconds */
+#define XEMACPS_PTPETXNS_OFFSET		0x000001E4 /* PTP Event Frame
+						Transmitted Nanoseconds */
+#define XEMACPS_PTPERXS_OFFSET		0x000001E8 /* PTP Event Frame Received
+						Seconds */
+#define XEMACPS_PTPERXNS_OFFSET		0x000001EC /* PTP Event Frame Received
+						Nanoseconds */
+#define XEMACPS_PTPPTXS_OFFSET		0x000001E0 /* PTP Peer Frame
+						Transmitted Seconds */
+#define XEMACPS_PTPPTXNS_OFFSET		0x000001E4 /* PTP Peer Frame
+						Transmitted Nanoseconds */
+#define XEMACPS_PTPPRXS_OFFSET		0x000001E8 /* PTP Peer Frame Received
+						Seconds */
+#define XEMACPS_PTPPRXNS_OFFSET		0x000001EC /* PTP Peer Frame Received
+						Nanoseconds */
+
+/* network control register bit definitions */
+#define XEMACPS_NWCTRL_FLUSH_DPRAM_MASK	0x00040000
+#define XEMACPS_NWCTRL_RXTSTAMP_MASK	0x00008000 /* RX Timestamp in CRC */
+#define XEMACPS_NWCTRL_ZEROPAUSETX_MASK	0x00001000 /* Transmit zero quantum
+						pause frame */
+#define XEMACPS_NWCTRL_PAUSETX_MASK	0x00000800 /* Transmit pause frame */
+#define XEMACPS_NWCTRL_HALTTX_MASK	0x00000400 /* Halt transmission
+						after current frame */
+#define XEMACPS_NWCTRL_STARTTX_MASK	0x00000200 /* Start tx (tx_go) */
+
+#define XEMACPS_NWCTRL_STATWEN_MASK	0x00000080 /* Enable writing to
+						stat counters */
+#define XEMACPS_NWCTRL_STATINC_MASK	0x00000040 /* Increment statistic
+						registers */
+#define XEMACPS_NWCTRL_STATCLR_MASK	0x00000020 /* Clear statistic
+						registers */
+#define XEMACPS_NWCTRL_MDEN_MASK	0x00000010 /* Enable MDIO port */
+#define XEMACPS_NWCTRL_TXEN_MASK	0x00000008 /* Enable transmit */
+#define XEMACPS_NWCTRL_RXEN_MASK	0x00000004 /* Enable receive */
+#define XEMACPS_NWCTRL_LOOPEN_MASK	0x00000002 /* local loopback */
+
+/* name network configuration register bit definitions */
+#define XEMACPS_NWCFG_BADPREAMBEN_MASK	0x20000000 /* disable rejection of
+						non-standard preamble */
+#define XEMACPS_NWCFG_IPDSTRETCH_MASK	0x10000000 /* enable transmit IPG */
+#define XEMACPS_NWCFG_FCSIGNORE_MASK	0x04000000 /* disable rejection of
+						FCS error */
+#define XEMACPS_NWCFG_HDRXEN_MASK	0x02000000 /* RX half duplex */
+#define XEMACPS_NWCFG_RXCHKSUMEN_MASK	0x01000000 /* enable RX checksum
+						offload */
+#define XEMACPS_NWCFG_PAUSECOPYDI_MASK	0x00800000 /* Do not copy pause
+						Frames to memory */
+#define XEMACPS_NWCFG_MDC_SHIFT_MASK	18 /* shift bits for MDC */
+#define XEMACPS_NWCFG_MDCCLKDIV_MASK	0x001C0000 /* MDC Mask PCLK divisor */
+#define XEMACPS_NWCFG_FCSREM_MASK	0x00020000 /* Discard FCS from
+						received frames */
+#define XEMACPS_NWCFG_LENGTHERRDSCRD_MASK 0x00010000
+/* RX length error discard */
+#define XEMACPS_NWCFG_RXOFFS_MASK	0x0000C000 /* RX buffer offset */
+#define XEMACPS_NWCFG_PAUSEEN_MASK	0x00002000 /* Enable pause TX */
+#define XEMACPS_NWCFG_RETRYTESTEN_MASK	0x00001000 /* Retry test */
+#define XEMACPS_NWCFG_1000_MASK		0x00000400 /* Gigbit mode */
+#define XEMACPS_NWCFG_EXTADDRMATCHEN_MASK	0x00000200
+/* External address match enable */
+#define XEMACPS_NWCFG_UCASTHASHEN_MASK	0x00000080 /* Receive unicast hash
+						frames */
+#define XEMACPS_NWCFG_MCASTHASHEN_MASK	0x00000040 /* Receive multicast hash
+						frames */
+#define XEMACPS_NWCFG_BCASTDI_MASK	0x00000020 /* Do not receive
+						broadcast frames */
+#define XEMACPS_NWCFG_COPYALLEN_MASK	0x00000010 /* Copy all frames */
+
+#define XEMACPS_NWCFG_NVLANDISC_MASK	0x00000004 /* Receive only VLAN
+						frames */
+#define XEMACPS_NWCFG_FDEN_MASK		0x00000002 /* Full duplex */
+#define XEMACPS_NWCFG_100_MASK		0x00000001 /* 10 or 100 Mbs */
+
+/* network status register bit definitaions */
+#define XEMACPS_NWSR_MDIOIDLE_MASK	0x00000004 /* PHY management idle */
+#define XEMACPS_NWSR_MDIO_MASK		0x00000002 /* Status of mdio_in */
+
+/* MAC address register word 1 mask */
+#define XEMACPS_LADDR_MACH_MASK		0x0000FFFF /* Address bits[47:32]
+						bit[31:0] are in BOTTOM */
+
+/* DMA control register bit definitions */
+#define XEMACPS_DMACR_RXBUF_MASK	0x00FF0000 /* Mask bit for RX buffer
+						size */
+#define XEMACPS_DMACR_RXBUF_SHIFT	16 /* Shift bit for RX buffer
+						size */
+#define XEMACPS_DMACR_TCPCKSUM_MASK	0x00000800 /* enable/disable TX
+						checksum offload */
+#define XEMACPS_DMACR_TXSIZE_MASK	0x00000400 /* TX buffer memory size */
+#define XEMACPS_DMACR_RXSIZE_MASK	0x00000300 /* RX buffer memory size */
+#define XEMACPS_DMACR_ENDIAN_MASK	0x00000080 /* Endian configuration */
+#define XEMACPS_DMACR_BLENGTH_MASK	0x0000001F /* Buffer burst length */
+#define XEMACPS_DMACR_BLENGTH_INCR16	0x00000010 /* Buffer burst length */
+#define XEMACPS_DMACR_BLENGTH_INCR8	0x00000008 /* Buffer burst length */
+#define XEMACPS_DMACR_BLENGTH_INCR4	0x00000004 /* Buffer burst length */
+#define XEMACPS_DMACR_BLENGTH_SINGLE	0x00000002 /* Buffer burst length */
+
+/* transmit status register bit definitions */
+#define XEMACPS_TXSR_HRESPNOK_MASK	0x00000100 /* Transmit hresp not OK */
+#define XEMACPS_TXSR_COL1000_MASK	0x00000080 /* Collision Gbs mode */
+#define XEMACPS_TXSR_URUN_MASK		0x00000040 /* Transmit underrun */
+#define XEMACPS_TXSR_TXCOMPL_MASK	0x00000020 /* Transmit completed OK */
+#define XEMACPS_TXSR_BUFEXH_MASK	0x00000010 /* Transmit buffs exhausted
+						mid frame */
+#define XEMACPS_TXSR_TXGO_MASK		0x00000008 /* Status of go flag */
+#define XEMACPS_TXSR_RXOVR_MASK		0x00000004 /* Retry limit exceeded */
+#define XEMACPS_TXSR_COL100_MASK	0x00000002 /* Collision 10/100  mode */
+#define XEMACPS_TXSR_USEDREAD_MASK	0x00000001 /* TX buffer used bit set */
+
+#define XEMACPS_TXSR_ERROR_MASK	(XEMACPS_TXSR_HRESPNOK_MASK |		\
+					XEMACPS_TXSR_COL1000_MASK |	\
+					XEMACPS_TXSR_URUN_MASK |	\
+					XEMACPS_TXSR_BUFEXH_MASK |	\
+					XEMACPS_TXSR_RXOVR_MASK |	\
+					XEMACPS_TXSR_COL100_MASK |	\
+					XEMACPS_TXSR_USEDREAD_MASK)
+
+/* receive status register bit definitions */
+#define XEMACPS_RXSR_HRESPNOK_MASK	0x00000008 /* Receive hresp not OK */
+#define XEMACPS_RXSR_RXOVR_MASK		0x00000004 /* Receive overrun */
+#define XEMACPS_RXSR_FRAMERX_MASK	0x00000002 /* Frame received OK */
+#define XEMACPS_RXSR_BUFFNA_MASK	0x00000001 /* RX buffer used bit set */
+
+#define XEMACPS_RXSR_ERROR_MASK	(XEMACPS_RXSR_HRESPNOK_MASK | \
+					XEMACPS_RXSR_RXOVR_MASK | \
+					XEMACPS_RXSR_BUFFNA_MASK)
+
+/* interrupts bit definitions
+ * Bits definitions are same in XEMACPS_ISR_OFFSET,
+ * XEMACPS_IER_OFFSET, XEMACPS_IDR_OFFSET, and XEMACPS_IMR_OFFSET
+ */
+#define XEMACPS_IXR_PTPPSTX_MASK	0x02000000 /* PTP Psync transmitted */
+#define XEMACPS_IXR_PTPPDRTX_MASK	0x01000000 /* PTP Pdelay_req
+							transmitted */
+#define XEMACPS_IXR_PTPSTX_MASK		0x00800000 /* PTP Sync transmitted */
+#define XEMACPS_IXR_PTPDRTX_MASK	0x00400000 /* PTP Delay_req
+							transmitted */
+#define XEMACPS_IXR_PTPPSRX_MASK	0x00200000 /* PTP Psync received */
+#define XEMACPS_IXR_PTPPDRRX_MASK	0x00100000 /* PTP Pdelay_req
+							received */
+#define XEMACPS_IXR_PTPSRX_MASK		0x00080000 /* PTP Sync received */
+#define XEMACPS_IXR_PTPDRRX_MASK	0x00040000 /* PTP Delay_req received */
+#define XEMACPS_IXR_PAUSETX_MASK	0x00004000 /* Pause frame
+							transmitted */
+#define XEMACPS_IXR_PAUSEZERO_MASK	0x00002000 /* Pause time has reached
+							zero */
+#define XEMACPS_IXR_PAUSENZERO_MASK	0x00001000 /* Pause frame received */
+#define XEMACPS_IXR_HRESPNOK_MASK	0x00000800 /* hresp not ok */
+#define XEMACPS_IXR_RXOVR_MASK		0x00000400 /* Receive overrun
+							occurred */
+#define XEMACPS_IXR_TXCOMPL_MASK	0x00000080 /* Frame transmitted ok */
+#define XEMACPS_IXR_TXEXH_MASK		0x00000040 /* Transmit err occurred or
+							no buffers*/
+#define XEMACPS_IXR_RETRY_MASK		0x00000020 /* Retry limit exceeded */
+#define XEMACPS_IXR_URUN_MASK		0x00000010 /* Transmit underrun */
+#define XEMACPS_IXR_TXUSED_MASK		0x00000008 /* Tx buffer used bit read */
+#define XEMACPS_IXR_RXUSED_MASK		0x00000004 /* Rx buffer used bit read */
+#define XEMACPS_IXR_FRAMERX_MASK	0x00000002 /* Frame received ok */
+#define XEMACPS_IXR_MGMNT_MASK		0x00000001 /* PHY management complete */
+#define XEMACPS_IXR_ALL_MASK		0x03FC7FFE /* Everything except MDIO */
+
+#define XEMACPS_IXR_TX_ERR_MASK	(XEMACPS_IXR_TXEXH_MASK |		\
+					XEMACPS_IXR_RETRY_MASK |	\
+					XEMACPS_IXR_URUN_MASK |		\
+					XEMACPS_IXR_TXUSED_MASK)
+
+#define XEMACPS_IXR_RX_ERR_MASK	(XEMACPS_IXR_HRESPNOK_MASK |		\
+					XEMACPS_IXR_RXUSED_MASK |	\
+					XEMACPS_IXR_RXOVR_MASK)
+/* PHY Maintenance bit definitions */
+#define XEMACPS_PHYMNTNC_OP_MASK	0x40020000 /* operation mask bits */
+#define XEMACPS_PHYMNTNC_OP_R_MASK	0x20000000 /* read operation */
+#define XEMACPS_PHYMNTNC_OP_W_MASK	0x10000000 /* write operation */
+#define XEMACPS_PHYMNTNC_ADDR_MASK	0x0F800000 /* Address bits */
+#define XEMACPS_PHYMNTNC_REG_MASK	0x007C0000 /* register bits */
+#define XEMACPS_PHYMNTNC_DATA_MASK	0x0000FFFF /* data bits */
+#define XEMACPS_PHYMNTNC_PHYAD_SHIFT_MASK	23 /* Shift bits for PHYAD */
+#define XEMACPS_PHYMNTNC_PHREG_SHIFT_MASK	18 /* Shift bits for PHREG */
+
+/* Wake on LAN bit definition */
+#define XEMACPS_WOL_MCAST_MASK		0x00080000
+#define XEMACPS_WOL_SPEREG1_MASK	0x00040000
+#define XEMACPS_WOL_ARP_MASK		0x00020000
+#define XEMACPS_WOL_MAGIC_MASK		0x00010000
+#define XEMACPS_WOL_ARP_ADDR_MASK	0x0000FFFF
+
+/* Buffer descriptor status words offset */
+#define XEMACPS_BD_ADDR_OFFSET		0x00000000 /**< word 0/addr of BDs */
+#define XEMACPS_BD_STAT_OFFSET		0x00000004 /**< word 1/status of BDs */
+
+/* Transmit buffer descriptor status words bit positions.
+ * Transmit buffer descriptor consists of two 32-bit registers,
+ * the first - word0 contains a 32-bit address pointing to the location of
+ * the transmit data.
+ * The following register - word1, consists of various information to
+ * control transmit process.  After transmit, this is updated with status
+ * information, whether the frame was transmitted OK or why it had failed.
+ */
+#define XEMACPS_TXBUF_USED_MASK		0x80000000 /* Used bit. */
+#define XEMACPS_TXBUF_WRAP_MASK		0x40000000 /* Wrap bit, last
+							descriptor */
+#define XEMACPS_TXBUF_RETRY_MASK	0x20000000 /* Retry limit exceeded */
+#define XEMACPS_TXBUF_EXH_MASK		0x08000000 /* Buffers exhausted */
+#define XEMACPS_TXBUF_LAC_MASK		0x04000000 /* Late collision. */
+#define XEMACPS_TXBUF_NOCRC_MASK	0x00010000 /* No CRC */
+#define XEMACPS_TXBUF_LAST_MASK		0x00008000 /* Last buffer */
+#define XEMACPS_TXBUF_LEN_MASK		0x00003FFF /* Mask for length field */
+
+#define XEMACPS_TXBUF_ERR_MASK		0x3C000000 /* Mask for length field */
+
+/* Receive buffer descriptor status words bit positions.
+ * Receive buffer descriptor consists of two 32-bit registers,
+ * the first - word0 contains a 32-bit word aligned address pointing to the
+ * address of the buffer. The lower two bits make up the wrap bit indicating
+ * the last descriptor and the ownership bit to indicate it has been used.
+ * The following register - word1, contains status information regarding why
+ * the frame was received (the filter match condition) as well as other
+ * useful info.
+ */
+#define XEMACPS_RXBUF_BCAST_MASK	0x80000000 /* Broadcast frame */
+#define XEMACPS_RXBUF_MULTIHASH_MASK	0x40000000 /* Multicast hashed frame */
+#define XEMACPS_RXBUF_UNIHASH_MASK	0x20000000 /* Unicast hashed frame */
+#define XEMACPS_RXBUF_EXH_MASK		0x08000000 /* buffer exhausted */
+#define XEMACPS_RXBUF_AMATCH_MASK	0x06000000 /* Specific address
+						matched */
+#define XEMACPS_RXBUF_IDFOUND_MASK	0x01000000 /* Type ID matched */
+#define XEMACPS_RXBUF_IDMATCH_MASK	0x00C00000 /* ID matched mask */
+#define XEMACPS_RXBUF_VLAN_MASK		0x00200000 /* VLAN tagged */
+#define XEMACPS_RXBUF_PRI_MASK		0x00100000 /* Priority tagged */
+#define XEMACPS_RXBUF_VPRI_MASK		0x000E0000 /* Vlan priority */
+#define XEMACPS_RXBUF_CFI_MASK		0x00010000 /* CFI frame */
+#define XEMACPS_RXBUF_EOF_MASK		0x00008000 /* End of frame. */
+#define XEMACPS_RXBUF_SOF_MASK		0x00004000 /* Start of frame. */
+#define XEMACPS_RXBUF_LEN_MASK		0x00003FFF /* Mask for length field */
+
+#define XEMACPS_RXBUF_WRAP_MASK		0x00000002 /* Wrap bit, last BD */
+#define XEMACPS_RXBUF_NEW_MASK		0x00000001 /* Used bit.. */
+#define XEMACPS_RXBUF_ADD_MASK		0xFFFFFFFC /* Mask for address */
+
+#define XEAMCPS_GEN_PURPOSE_TIMER_LOAD	100 /* timeout value is msecs */
+
+#define XEMACPS_GMII2RGMII_FULLDPLX		BMCR_FULLDPLX
+#define XEMACPS_GMII2RGMII_SPEED1000		BMCR_SPEED1000
+#define XEMACPS_GMII2RGMII_SPEED100		BMCR_SPEED100
+#define XEMACPS_GMII2RGMII_REG_NUM			0x10
+
+#ifdef CONFIG_XILINX_PS_EMAC_HWTSTAMP
+#define NS_PER_SEC			1000000000ULL /* Nanoseconds per
+							second */
 #endif
-#include "xilinx_emacps.h"
+
+#define xemacps_read(base, reg)						\
+	__raw_readl(((void __iomem *)(base)) + (reg))
+#define xemacps_write(base, reg, val)					\
+	__raw_writel((val), ((void __iomem *)(base)) + (reg))
+
+struct ring_info {
+	struct sk_buff *skb;
+	dma_addr_t mapping;
+	size_t len;
+};
+
+/* DMA buffer descriptor structure. Each BD is two words */
+struct xemacps_bd {
+	u32 addr;
+	u32 ctrl;
+};
+
+
+/* Our private device data. */
+struct net_local {
+	void __iomem *baseaddr;
+	struct clk *devclk;
+	struct clk *aperclk;
+	struct notifier_block clk_rate_change_nb;
+
+	struct device_node *phy_node;
+	struct device_node *gmii2rgmii_phy_node;
+	struct ring_info *tx_skb;
+	struct ring_info *rx_skb;
+
+	struct xemacps_bd *rx_bd;
+	struct xemacps_bd *tx_bd;
+
+	dma_addr_t rx_bd_dma; /* physical address */
+	dma_addr_t tx_bd_dma; /* physical address */
+
+	u32 tx_bd_ci;
+	u32 tx_bd_tail;
+	u32 rx_bd_ci;
+
+	u32 tx_bd_freecnt;
+
+	spinlock_t tx_lock;
+	spinlock_t rx_lock;
+	spinlock_t nwctrlreg_lock;
+
+	struct platform_device *pdev;
+	struct net_device *ndev; /* this device */
+	struct tasklet_struct tx_bdreclaim_tasklet;
+	struct workqueue_struct *txtimeout_handler_wq;
+	struct work_struct txtimeout_reinit;
+
+	struct napi_struct napi; /* napi information for device */
+	struct net_device_stats stats; /* Statistics for this device */
+
+	struct timer_list gen_purpose_timer; /* Used for stats update */
+
+	/* Manage internal timer for packet timestamping */
+	struct cyclecounter cycles;
+	struct timecounter clock;
+	struct timecompare compare;
+	struct hwtstamp_config hwtstamp_config;
+
+	struct mii_bus *mii_bus;
+	struct phy_device *phy_dev;
+	struct phy_device *gmii2rgmii_phy_dev;
+	phy_interface_t phy_interface;
+	unsigned int link;
+	unsigned int speed;
+	unsigned int duplex;
+	/* RX ip/tcp/udp checksum */
+	unsigned ip_summed;
+	unsigned int enetnum;
+	unsigned int lastrxfrmscntr;
+#ifdef CONFIG_XILINX_PS_EMAC_HWTSTAMP
+	unsigned int ptpenetclk;
+#endif
+};
+#define to_net_local(_nb)	container_of(_nb, struct net_local,\
+		clk_rate_change_nb)
 
 static struct net_device_ops netdev_ops;
 
@@ -140,38 +640,22 @@ static int xemacps_mdio_reset(struct mii_bus *bus)
 	return 0;
 }
 
-static void xemacps_phy_init(struct net_device *ndev)
+/**
+ * xemacps_set_freq() - Set a clock to a new frequency
+ * @clk		Pointer to the clock to change
+ * @rate	New frequency in Hz
+ * @dev		Pointer to the struct device
+ */
+static void xemacps_set_freq(struct clk *clk, long rate, struct device *dev)
 {
-	struct net_local *lp = netdev_priv(ndev);
-	u16 regval;
-	int i = 0;
-
-	/* set RX delay */
-	regval = xemacps_mdio_read(lp->mii_bus, lp->phy_dev->addr, 20);
-	/* 0x0080 for 100Mbps, 0x0060 for 1Gbps. */
-	regval |= 0x0080;
-	xemacps_mdio_write(lp->mii_bus, lp->phy_dev->addr, 20, regval);
-
-	/* 0x2100 for 100Mbps, 0x0140 for 1Gbps. */
-	xemacps_mdio_write(lp->mii_bus, lp->phy_dev->addr, 0, 0x2100);
-
-	regval = xemacps_mdio_read(lp->mii_bus, lp->phy_dev->addr, 0);
-	regval |= 0x8000;
-	xemacps_mdio_write(lp->mii_bus, lp->phy_dev->addr, 0, regval);
-	for (i = 0; i < 10; i++)
-		mdelay(500);
-#ifdef DEBUG_VERBOSE
-	printk(KERN_INFO "GEM: phy register dump, start from 0, four in a row.");
-	for (i = 0; i <= 30; i++) {
-		if (!(i%4))
-			printk("\n %02d:  ", i);
-		regval = xemacps_mdio_read(lp->mii_bus, lp->phy_dev->addr, i);
-		printk(" 0x%08x", regval);
-	}
-	printk("\n");
-#endif
-}
+	rate = clk_round_rate(clk, rate);
+	if (rate < 0)
+		return;
 
+	dev_info(dev, "Set clk to %ld Hz\n", rate);
+	if (clk_set_rate(clk, rate))
+		dev_err(dev, "Setting new clock rate failed.\n");
+}
 
 /**
  * xemacps_adjust_link - handles link status changes, such as speed,
@@ -182,57 +666,57 @@ static void xemacps_adjust_link(struct net_device *ndev)
 {
 	struct net_local *lp = netdev_priv(ndev);
 	struct phy_device *phydev = lp->phy_dev;
-	unsigned long flags;
+	struct phy_device *gmii2rgmii_phydev = lp->gmii2rgmii_phy_dev;
 	int status_change = 0;
 	u32 regval;
-	u32 regval1;
-	u32 slcroffset;
-
-	spin_lock_irqsave(&lp->lock, flags);
-	if (lp->enetnum == 0) {
-		regval1 = xslcr_read(XSLCR_EMAC0_CLK_CTRL_OFFSET);
-		regval1 &= XEMACPS_SLCR_DIV_MASK;
-		slcroffset = XSLCR_EMAC0_CLK_CTRL_OFFSET;
-	} else {
-		regval1 = xslcr_read(XSLCR_EMAC1_CLK_CTRL_OFFSET);
-		regval1 &= XEMACPS_SLCR_DIV_MASK;
-		slcroffset = XSLCR_EMAC1_CLK_CTRL_OFFSET;
-	}
+	u16 gmii2rgmii_reg = 0;
 
 	if (phydev->link) {
 		if ((lp->speed != phydev->speed) ||
-		    (lp->duplex != phydev->duplex)) {
+			(lp->duplex != phydev->duplex)) {
 			regval = xemacps_read(lp->baseaddr,
 				XEMACPS_NWCFG_OFFSET);
-			if (phydev->duplex)
+			regval &= ~(XEMACPS_NWCFG_FDEN_MASK |
+					XEMACPS_NWCFG_1000_MASK |
+					XEMACPS_NWCFG_100_MASK);
+
+			if (phydev->duplex) {
 				regval |= XEMACPS_NWCFG_FDEN_MASK;
-			else
-				regval &= ~XEMACPS_NWCFG_FDEN_MASK;
+				gmii2rgmii_reg |= XEMACPS_GMII2RGMII_FULLDPLX;
+			}
 
 			if (phydev->speed == SPEED_1000) {
 				regval |= XEMACPS_NWCFG_1000_MASK;
-				regval1 |= ((lp->slcr_div1_1000Mbps) << 20);
-				regval1 |= ((lp->slcr_div0_1000Mbps) << 8);
-				xslcr_write(slcroffset, regval1);
-			} else
-				regval &= ~XEMACPS_NWCFG_1000_MASK;
-
-			if (phydev->speed == SPEED_100) {
+				gmii2rgmii_reg |= XEMACPS_GMII2RGMII_SPEED1000;
+				xemacps_set_freq(lp->devclk, 125000000,
+						&lp->pdev->dev);
+			}
+			else if (phydev->speed == SPEED_100) {
 				regval |= XEMACPS_NWCFG_100_MASK;
-				regval1 |= ((lp->slcr_div1_100Mbps) << 20);
-				regval1 |= ((lp->slcr_div0_100Mbps) << 8);
-				xslcr_write(slcroffset, regval1);
-			} else
-				regval &= ~XEMACPS_NWCFG_100_MASK;
-
-			if (phydev->speed == SPEED_10) {
-				regval1 |= ((lp->slcr_div1_10Mbps) << 20);
-				regval1 |= ((lp->slcr_div0_10Mbps) << 8);
-				xslcr_write(slcroffset, regval1);
+				gmii2rgmii_reg |= XEMACPS_GMII2RGMII_SPEED100;
+				xemacps_set_freq(lp->devclk, 25000000,
+						&lp->pdev->dev);
+			}
+			else if (phydev->speed == SPEED_10) {
+				xemacps_set_freq(lp->devclk, 2500000,
+						&lp->pdev->dev);
+			}
+			else {
+				dev_err(&lp->pdev->dev,
+					"%s: unknown PHY speed %d\n",
+					__func__, phydev->speed);
+				return;
 			}
 
 			xemacps_write(lp->baseaddr, XEMACPS_NWCFG_OFFSET,
-				regval);
+			regval);
+
+			if (gmii2rgmii_phydev != NULL) {
+				xemacps_mdio_write(lp->mii_bus,
+					gmii2rgmii_phydev->addr,
+					XEMACPS_GMII2RGMII_REG_NUM,
+					gmii2rgmii_reg);
+			}
 
 			lp->speed = phydev->speed;
 			lp->duplex = phydev->duplex;
@@ -245,17 +729,44 @@ static void xemacps_adjust_link(struct net_device *ndev)
 		status_change = 1;
 	}
 
-	spin_unlock_irqrestore(&lp->lock, flags);
-
 	if (status_change) {
-		if (phydev->link) {
-			printk(KERN_INFO "%s: link up (%d/%s)\n",
-				ndev->name, phydev->speed,
+		if (phydev->link)
+			dev_info(&lp->pdev->dev, "link up (%d/%s)\n",
+				phydev->speed,
 				DUPLEX_FULL == phydev->duplex ?
 				"FULL" : "HALF");
-		} else {
-			printk(KERN_INFO "%s: link down\n", ndev->name);
-		}
+		else
+			dev_info(&lp->pdev->dev, "link down\n");
+	}
+}
+
+static int xemacps_clk_notifier_cb(struct notifier_block *nb, unsigned long
+		event, void *data)
+{
+/*
+	struct clk_notifier_data *ndata = data;
+	struct net_local *nl = to_net_local(nb);
+*/
+
+	switch (event) {
+	case PRE_RATE_CHANGE:
+		/* if a rate change is announced we need to check whether we can
+		 * maintain the current frequency by changing the clock
+		 * dividers.
+		 * I don't see how this can be done using the current fmwk!?
+		 * For now we always allow the rate change. Otherwise we would
+		 * even prevent ourself to change the rate.
+		 */
+		return NOTIFY_OK;
+	case POST_RATE_CHANGE:
+		/* not sure this will work. actually i'm sure it does not. this
+		 * callback is not allowed to call back into COMMON_CLK, what
+		 * adjust_link() does...*/
+		/*xemacps_adjust_link(nl->ndev); would likely lock up kernel */
+		return NOTIFY_OK;
+	case ABORT_RATE_CHANGE:
+	default:
+		return NOTIFY_DONE;
 	}
 }
 
@@ -269,47 +780,23 @@ static int xemacps_mii_probe(struct net_device *ndev)
 {
 	struct net_local *lp = netdev_priv(ndev);
 	struct phy_device *phydev = NULL;
-#ifndef CONFIG_OF
-	int phy_addr;
-#endif
 
-#ifdef CONFIG_OF
 	if (lp->phy_node) {
 		phydev = of_phy_connect(lp->ndev,
 					lp->phy_node,
-					xemacps_adjust_link,
+					&xemacps_adjust_link,
 					0,
-					PHY_INTERFACE_MODE_RGMII_ID);
+					lp->phy_interface);
 	}
 	if (!phydev) {
-		printk(KERN_ERR "%s: no PHY found\n", ndev->name);
+		dev_err(&lp->pdev->dev, "%s: no PHY found\n", ndev->name);
 		return -1;
 	}
-#else
-	for (phy_addr = 0; phy_addr < PHY_MAX_ADDR; phy_addr++) {
-		if (lp->mii_bus->phy_map[phy_addr]) {
-			phydev = lp->mii_bus->phy_map[phy_addr];
-			break;
-		}
-	}
 
-	if (!phydev) {
-		printk(KERN_ERR "%s: no PHY found\n", ndev->name);
-		return -1;
-	}
-
-	phydev = phy_connect(ndev, dev_name(&phydev->dev),
-		&xemacps_adjust_link, 0, PHY_INTERFACE_MODE_RGMII_ID);
-
-	if (IS_ERR(phydev)) {
-		printk(KERN_ERR "%s: can not connect phy\n", ndev->name);
-		return -2;
-	}
-#endif
-#ifdef DEBUG
-	printk(KERN_INFO "GEM: phydev %p, phydev->phy_id 0x%x, phydev->addr 0x%x\n",
+	dev_dbg(&lp->pdev->dev,
+		"GEM: phydev %p, phydev->phy_id 0x%x, phydev->addr 0x%x\n",
 		phydev, phydev->phy_id, phydev->addr);
-#endif
+
 	phydev->supported &= (PHY_GBIT_FEATURES | SUPPORTED_Pause |
 							SUPPORTED_Asym_Pause);
 	phydev->advertising = phydev->supported;
@@ -319,21 +806,27 @@ static int xemacps_mii_probe(struct net_device *ndev)
 	lp->duplex  = -1;
 	lp->phy_dev = phydev;
 
-#ifdef CONFIG_OF
-	if (lp->board_type == BOARD_TYPE_ZYNQ)
-		phy_start(lp->phy_dev);
-	else
-		xemacps_phy_init(lp->ndev);
-#else
 	phy_start(lp->phy_dev);
-#endif
-#ifdef DEBUG
-	printk(KERN_INFO "%s, phy_addr 0x%x, phy_id 0x%08x\n",
-			ndev->name, lp->phy_dev->addr, lp->phy_dev->phy_id);
 
-	printk(KERN_INFO "%s, attach [%s] phy driver\n", ndev->name,
+	dev_dbg(&lp->pdev->dev, "phy_addr 0x%x, phy_id 0x%08x\n",
+			lp->phy_dev->addr, lp->phy_dev->phy_id);
+
+	dev_dbg(&lp->pdev->dev, "attach [%s] phy driver\n",
 			lp->phy_dev->drv->name);
-#endif
+
+	if (lp->gmii2rgmii_phy_node) {
+		phydev = of_phy_connect(lp->ndev,
+					lp->gmii2rgmii_phy_node,
+					NULL,
+					0, 0);
+		if (!phydev) {
+			dev_err(&lp->pdev->dev, "%s: no gmii to rgmii converter found\n",
+			ndev->name);
+			return -1;
+		}
+		lp->gmii2rgmii_phy_dev = phydev;
+	} else
+		lp->gmii2rgmii_phy_dev = NULL;
 
 	return 0;
 }
@@ -346,10 +839,9 @@ static int xemacps_mii_probe(struct net_device *ndev)
 static int xemacps_mii_init(struct net_local *lp)
 {
 	int rc = -ENXIO, i;
-#ifdef CONFIG_OF
 	struct resource res;
 	struct device_node *np = of_get_parent(lp->phy_node);
-#endif
+	struct device_node *npp;
 
 	lp->mii_bus = mdiobus_alloc();
 	if (lp->mii_bus == NULL) {
@@ -372,17 +864,13 @@ static int xemacps_mii_init(struct net_local *lp)
 
 	for (i = 0; i < PHY_MAX_ADDR; i++)
 		lp->mii_bus->irq[i] = PHY_POLL;
-#ifdef CONFIG_OF
-	of_address_to_resource(np, 0, &res);
+	npp = of_get_parent(np);
+	of_address_to_resource(npp, 0, &res);
 	snprintf(lp->mii_bus->id, MII_BUS_ID_SIZE, "%.8llx",
 		 (unsigned long long)res.start);
 	if (of_mdiobus_register(lp->mii_bus, np))
 		goto err_out_free_mdio_irq;
-#else
-	snprintf(lp->mii_bus->id, MII_BUS_ID_SIZE, "%x", lp->pdev->id);
-	if (mdiobus_register(lp->mii_bus))
-		goto err_out_free_mdio_irq;
-#endif
+
 	return 0;
 
 err_out_free_mdio_irq:
@@ -398,7 +886,7 @@ err_out:
  * MAC address is not valid, reconfigure with a good one.
  * @lp: local device instance pointer
  **/
-static void __init xemacps_update_hwaddr(struct net_local *lp)
+static void xemacps_update_hwaddr(struct net_local *lp)
 {
 	u32 regvall;
 	u16 regvalh;
@@ -418,10 +906,11 @@ static void __init xemacps_update_hwaddr(struct net_local *lp)
 	} else {
 		dev_info(&lp->pdev->dev, "invalid address, use assigned\n");
 		random_ether_addr(lp->ndev->dev_addr);
-		printk(KERN_INFO "MAC updated %02x:%02x:%02x:%02x:%02x:%02x\n",
-			lp->ndev->dev_addr[0], lp->ndev->dev_addr[1],
-			lp->ndev->dev_addr[2], lp->ndev->dev_addr[3],
-			lp->ndev->dev_addr[4], lp->ndev->dev_addr[5]);
+		dev_info(&lp->pdev->dev,
+				"MAC updated %02x:%02x:%02x:%02x:%02x:%02x\n",
+				lp->ndev->dev_addr[0], lp->ndev->dev_addr[1],
+				lp->ndev->dev_addr[2], lp->ndev->dev_addr[3],
+				lp->ndev->dev_addr[4], lp->ndev->dev_addr[5]);
 	}
 }
 
@@ -448,7 +937,8 @@ static void xemacps_set_hwaddr(struct net_local *lp)
 #ifdef DEBUG
 	regvall = xemacps_read(lp->baseaddr, XEMACPS_LADDR1L_OFFSET);
 	regvalh = xemacps_read(lp->baseaddr, XEMACPS_LADDR1H_OFFSET);
-	printk(KERN_INFO "GEM: MAC 0x%08x, 0x%08x, %02x:%02x:%02x:%02x:%02x:%02x\n",
+	dev_dbg(&lp->pdev->dev,
+			"MAC 0x%08x, 0x%08x, %02x:%02x:%02x:%02x:%02x:%02x\n",
 		regvall, regvalh,
 		(regvall & 0xff), ((regvall >> 8) & 0xff),
 		((regvall >> 16) & 0xff), (regvall >> 24),
@@ -481,355 +971,11 @@ static void xemacps_reset_hw(struct net_local *lp)
 
 	/* Disable all interrupts */
 	xemacps_write(lp->baseaddr, XEMACPS_IDR_OFFSET, ~0UL);
+	synchronize_irq(lp->ndev->irq);
 	regisr = xemacps_read(lp->baseaddr, XEMACPS_ISR_OFFSET);
 	xemacps_write(lp->baseaddr, XEMACPS_ISR_OFFSET, regisr);
 }
 
-/**
- * xemacps_bdringalloc - reserve locations in BD list.
- * @ringptr: pointer to the BD ring instance to be worked on.
- * @numbd: number of BDs to allocate.
- * @bdptr: output parameter points to the first BD available for
- *         modification.
- * return 0 on success, negative value if not enough BDs.
- **/
-int xemacps_bdringalloc(struct xemacps_bdring *ringptr, unsigned numbd,
-		struct xemacps_bd **bdptr)
-{
-	/* Enough free BDs available for the request? */
-	if (ringptr->freecnt < numbd)
-		return NETDEV_TX_BUSY;
-
-	/* Set the return argument and move FreeHead forward */
-	*bdptr = ringptr->freehead;
-	XEMACPS_RING_SEEKAHEAD(ringptr, ringptr->freehead, numbd);
-	ringptr->freecnt -= numbd;
-	ringptr->precnt  += numbd;
-	return 0;
-}
-
-/**
- * xemacps_bdringunalloc - Fully or partially undo xemacps_bdringalloc().
- * @ringptr: pointer to the BD ring instance to be worked on.
- * @numbd: number of BDs to unallocate.
- * @bdptr: points to the first of BDs to be unallocated.
- * return 0 on success, negative value if error.
- **/
-int xemacps_bdringunalloc(struct xemacps_bdring *ringptr, unsigned numbd,
-		struct xemacps_bd *bdptr)
-{
-	/* Enough BDs in the free state for the request? */
-	if (ringptr->precnt < numbd)
-		return -ENOSPC;
-
-	/* Set the return argument and move FreeHead backward */
-	XEMACPS_RING_SEEKBACK(ringptr, ringptr->freehead, numbd);
-	ringptr->freecnt += numbd;
-	ringptr->precnt  -= numbd;
-	return 0;
-}
-
-#ifdef DEBUG_VERBOSE
-static void print_ring(struct xemacps_bdring *ring)
-{
-	int i;
-	unsigned regval;
-	struct xemacps_bd *bd;
-
-	printk(KERN_INFO "freehead %p prehead %p hwhead %p \
-		hwtail %p posthead %p\n", ring->freehead, ring->prehead,
-		ring->hwhead, ring->hwtail, ring->posthead);
-	printk(KERN_INFO "freecnt %d hwcnt %d precnt %d \
-		postcnt %d allcnt %d\n",
-		ring->freecnt, ring->hwcnt, ring->precnt,
-		ring->postcnt, ring->allcnt);
-
-	bd = (struct xemacps_bd *)ring->firstbdaddr;
-	for (i = 0; i < XEMACPS_RECV_BD_CNT; i++) {
-		regval = xemacps_read(bd, XEMACPS_BD_ADDR_OFFSET);
-		printk(KERN_INFO "BD %p: ADDR: 0x%08x\n", bd, regval);
-		regval = xemacps_read(bd, XEMACPS_BD_STAT_OFFSET);
-		printk(KERN_INFO "BD %p: STAT: 0x%08x\n", bd, regval);
-		bd++;
-	}
-}
-#endif
-
-/**
- * xemacps_bdringtohw - Enqueue a set of BDs to hardware that were
- * previously allocated by xemacps_bdringalloc().
- * @ringptr: pointer to the BD ring instance to be worked on.
- * @numbd: number of BDs to hardware.
- * @bdptr: points to the first of BDs to be processed.
- * return 0 on success, negative value if error.
- **/
-int xemacps_bdringtohw(struct xemacps_bdring *ringptr, unsigned numbd,
-		struct xemacps_bd *bdptr)
-{
-	struct xemacps_bd *curbdptr;
-	unsigned int i;
-	unsigned int regval;
-
-	/* if no bds to process, simply return. */
-	if (numbd == 0)
-		return 0;
-
-	/* Make sure we are in sync with xemacps_bdringalloc() */
-	if ((ringptr->precnt < numbd) || (ringptr->prehead != bdptr))
-		return -ENOSPC;
-
-	curbdptr = bdptr;
-	for (i = 0; i < numbd; i++) {
-		/* Assign ownership back to hardware */
-		if (ringptr->is_rx) {
-			xemacps_write(curbdptr, XEMACPS_BD_STAT_OFFSET, 0);
-			wmb();
-
-			regval = xemacps_read(curbdptr, XEMACPS_BD_ADDR_OFFSET);
-			regval &= ~XEMACPS_RXBUF_NEW_MASK;
-			xemacps_write(curbdptr, XEMACPS_BD_ADDR_OFFSET, regval);
-		} else {
-			regval = xemacps_read(curbdptr, XEMACPS_BD_STAT_OFFSET);
-			/* clear used bit - hardware to own this descriptor */
-			regval &= ~XEMACPS_TXBUF_USED_MASK;
-			xemacps_write(curbdptr, XEMACPS_BD_STAT_OFFSET, regval);
-		}
-		wmb();
-		curbdptr = XEMACPS_BDRING_NEXT(ringptr, curbdptr);
-	}
-	/* Adjust ring pointers & counters */
-	XEMACPS_RING_SEEKAHEAD(ringptr, ringptr->prehead, numbd);
-	ringptr->hwtail  = curbdptr;
-	ringptr->precnt -= numbd;
-	ringptr->hwcnt  += numbd;
-
-	return 0;
-}
-
-/**
- * xemacps_bdringfromhwtx - returns a set of BD(s) that have been
- * processed by hardware in tx direction.
- * @ringptr: pointer to the BD ring instance to be worked on.
- * @bdlimit: maximum number of BDs to return in the set.
- * @bdptr: output parameter points to the first BD available for
- *         examination.
- * return number of BDs processed by hardware.
- **/
-u32 xemacps_bdringfromhwtx(struct xemacps_bdring *ringptr, unsigned bdlimit,
-		struct xemacps_bd **bdptr)
-{
-	struct xemacps_bd *curbdptr;
-	u32 bdstr = 0;
-	unsigned int bdcount = 0;
-	unsigned int bdpartialcount = 0;
-	unsigned int sop = 0;
-
-	curbdptr = ringptr->hwhead;
-
-	/* If no BDs in work group, then there's nothing to search */
-	if (ringptr->hwcnt == 0) {
-		*bdptr = NULL;
-		return 0;
-	}
-
-	if (bdlimit > ringptr->hwcnt)
-		bdlimit = ringptr->hwcnt;
-
-	/* Starting at hwhead, keep moving forward in the list until:
-	 *  - ringptr->hwtail is reached.
-	 *  - The number of requested BDs has been processed
-	 */
-	while (bdcount < bdlimit) {
-		/* Read the status */
-		bdstr = xemacps_read(curbdptr, XEMACPS_BD_STAT_OFFSET);
-
-		if (sop == 0) {
-				if (bdstr & XEMACPS_TXBUF_USED_MASK)
-					sop = 1;
-				else
-					break;
-		}
-
-		if (sop == 1) {
-			bdcount++;
-			bdpartialcount++;
-		}
-		/* hardware has processed this BD so check the "last" bit.
-		 * If it is clear, then there are more BDs for the current
-		 * packet. Keep a count of these partial packet BDs.
-		 */
-		if ((sop == 1) && (bdstr & XEMACPS_TXBUF_LAST_MASK)) {
-			sop = 0;
-			bdpartialcount = 0;
-		}
-
-		/* Move on to next BD in work group */
-		curbdptr = XEMACPS_BDRING_NEXT(ringptr, curbdptr);
-	}
-
-	/* Subtract off any partial packet BDs found */
-	bdcount -= bdpartialcount;
-
-	/* If bdcount is non-zero then BDs were found to return. Set return
-	 * parameters, update pointers and counters, return number of BDs
-	 */
-	if (bdcount > 0) {
-		*bdptr = ringptr->hwhead;
-		ringptr->hwcnt   -= bdcount;
-		ringptr->postcnt += bdcount;
-		XEMACPS_RING_SEEKAHEAD(ringptr, ringptr->hwhead, bdcount);
-		return bdcount;
-	} else {
-		*bdptr = NULL;
-		return 0;
-	}
-}
-
-/**
- * xemacps_bdringfromhwrx - returns a set of BD(s) that have been
- * processed by hardware in rx direction.
- * @ringptr: pointer to the BD ring instance to be worked on.
- * @bdlimit: maximum number of BDs to return in the set.
- * @bdptr: output parameter points to the first BD available for
- *         examination.
- * return number of BDs processed by hardware.
- **/
-u32 xemacps_bdringfromhwrx(struct xemacps_bdring *ringptr, int bdlimit,
-		struct xemacps_bd **bdptr)
-{
-	struct xemacps_bd *curbdptr;
-	u32 bdadd = 0;
-	int bdcount = 0;
-	curbdptr = ringptr->hwhead;
-
-	/* If no BDs in work group, then there's nothing to search */
-	if (ringptr->hwcnt == 0) {
-		*bdptr = NULL;
-		return 0;
-	}
-
-	if (bdlimit > ringptr->hwcnt)
-		bdlimit = ringptr->hwcnt;
-
-	/* Starting at hwhead, keep moving forward in the list until:
-	 *  - A BD is encountered with its new/used bit set which means
-	 *    hardware has not completed processing of that BD.
-	 *  - ringptr->hwtail is reached.
-	 *  - The number of requested BDs has been processed
-	 */
-	while (bdcount < bdlimit) {
-		/* Read the status word to see if BD has been processed. */
-		bdadd = xemacps_read(curbdptr, XEMACPS_BD_ADDR_OFFSET);
-		if (bdadd & XEMACPS_RXBUF_NEW_MASK)
-			bdcount++;
-		else
-			break;
-
-		/* Move on to next BD in work group */
-		curbdptr = XEMACPS_BDRING_NEXT(ringptr, curbdptr);
-	}
-
-	/* If bdcount is non-zero then BDs were found to return. Set return
-	 * parameters, update pointers and counters, return number of BDs
-	 */
-	if (bdcount > 0) {
-		*bdptr = ringptr->hwhead;
-		ringptr->hwcnt   -= bdcount;
-		ringptr->postcnt += bdcount;
-		XEMACPS_RING_SEEKAHEAD(ringptr, ringptr->hwhead, bdcount);
-		return bdcount;
-	} else {
-		*bdptr = NULL;
-		return 0;
-	}
-}
-
-/**
- * xemacps_bdringfree - Free a set of BDs that has been retrieved with
- * xemacps_bdringfromhw().
- * previously allocated by xemacps_bdringalloc().
- * @ringptr: pointer to the BD ring instance to be worked on.
- * @numbd: number of BDs to allocate.
- * @bdptr: the head of BD list returned by xemacps_bdringfromhw().
- * return 0 on success, negative value if error.
- **/
-int xemacps_bdringfree(struct xemacps_bdring *ringptr, unsigned numbd,
-		struct xemacps_bd *bdptr)
-{
-	/* if no bds to free, simply return. */
-	if (0 == numbd)
-		return 0;
-
-	/* Make sure we are in sync with xemacps_bdringfromhw() */
-	if ((ringptr->postcnt < numbd) || (ringptr->posthead != bdptr)) {
-		printk(KERN_ERR "GEM: Improper bdringfree()\n");
-		return -ENOSPC;
-	}
-
-	/* Update pointers and counters */
-	ringptr->freecnt += numbd;
-	ringptr->postcnt -= numbd;
-	XEMACPS_RING_SEEKAHEAD(ringptr, ringptr->posthead, numbd);
-	return 0;
-}
-
-
-/**
- * xemacps_DmaSetupRecvBuffers - allocates socket buffers (sk_buff's)
- * up to the number of free RX buffer descriptors. Then it sets up the RX
- * buffer descriptors to DMA into the socket_buffers.
- * @ndev: the net_device
- **/
-static void xemacps_DmaSetupRecvBuffers(struct net_device *ndev)
-{
-	struct net_local *lp;
-	struct xemacps_bdring *rxringptr;
-	struct xemacps_bd *bdptr;
-	struct sk_buff *new_skb;
-	u32 new_skb_baddr;
-	int free_bd_count;
-	int num_sk_buffs;
-	int bdidx;
-	int result;
-
-	lp = (struct net_local *) netdev_priv(ndev);
-	rxringptr = &lp->rx_ring;
-	free_bd_count = rxringptr->freecnt;
-
-	for (num_sk_buffs = 0; num_sk_buffs < free_bd_count; num_sk_buffs++) {
-		new_skb = netdev_alloc_skb(ndev, XEMACPS_RX_BUF_SIZE);
-		if (new_skb == NULL)
-			break;
-
-		result = xemacps_bdringalloc(rxringptr, 1, &bdptr);
-		if (result) {
-			printk(KERN_ERR "%s RX bdringalloc() error.\n",
-					 lp->ndev->name);
-			break;
-		}
-
-		/* Get dma handle of skb->data */
-		new_skb_baddr = (u32) dma_map_single(ndev->dev.parent,
-			new_skb->data, XEMACPS_RX_BUF_SIZE, DMA_FROM_DEVICE);
-
-		XEMACPS_SET_BUFADDR_RX(bdptr, new_skb_baddr);
-		bdidx = XEMACPS_BD_TO_INDEX(rxringptr, bdptr);
-		lp->rx_skb[bdidx].skb = new_skb;
-		lp->rx_skb[bdidx].mapping = new_skb_baddr;
-		wmb();
-
-		/* enqueue RxBD with the attached skb buffers such that it is
-		 * ready for frame reception
-		 */
-		result = xemacps_bdringtohw(rxringptr, 1, bdptr);
-		if (result) {
-			printk(KERN_ERR "%s: bdringtohw unsuccessful (%d)\n",
-				ndev->name, result);
-			break;
-		}
-	}
-}
-
 #ifdef CONFIG_XILINX_PS_EMAC_HWTSTAMP
 
 /**
@@ -935,55 +1081,45 @@ xemacps_tx_hwtstamp(struct net_local *lp,
  **/
 static int xemacps_rx(struct net_local *lp, int budget)
 {
-	u32 regval, len = 0;
-	struct sk_buff *skb = NULL;
-	struct xemacps_bd *bdptr, *bdptrfree;
-	unsigned int numbdfree, numbd = 0, bdidx = 0, rc = 0;
-
-	numbd = xemacps_bdringfromhwrx(&lp->rx_ring, budget, &bdptr);
-
-	numbdfree = numbd;
-	bdptrfree = bdptr;
-
-#ifdef DEBUG_VERBOSE
-	printk(KERN_INFO "GEM: %s: numbd %d\n",
-			__func__, numbd);
-#endif
-
-	while (numbd) {
-		bdidx = XEMACPS_BD_TO_INDEX(&lp->rx_ring, bdptr);
-		regval = xemacps_read(bdptr, XEMACPS_BD_STAT_OFFSET);
+	struct xemacps_bd *cur_p;
+	u32 len;
+	struct sk_buff *skb;
+	struct sk_buff *new_skb;
+	u32 new_skb_baddr;
+	unsigned int numbdfree = 0;
+	u32 size = 0;
+	u32 packets = 0;
+	u32 regval;
 
-#ifdef DEBUG_VERBOSE
-		printk(KERN_INFO "GEM: %s: RX BD index %d, BDptr %p, BD_STAT 0x%08x\n",
-			__func__, bdidx, bdptr, regval);
-#endif
+	cur_p = &lp->rx_bd[lp->rx_bd_ci];
+	regval = cur_p->addr;
+	rmb();
+	while (numbdfree < budget) {
+		if (!(regval & XEMACPS_RXBUF_NEW_MASK))
+			break;
 
-		/* look for start of packet */
-		if (!(regval & XEMACPS_RXBUF_SOF_MASK) ||
-		    !(regval & XEMACPS_RXBUF_EOF_MASK)) {
-			printk(KERN_INFO "GEM: %s: SOF and EOF not set (0x%08x) BD %p\n",
-				__func__, regval, bdptr);
-			return 0;
+		new_skb = netdev_alloc_skb(lp->ndev, XEMACPS_RX_BUF_SIZE);
+		if (new_skb == NULL) {
+			dev_err(&lp->ndev->dev, "no memory for new sk_buff\n");
+			break;
 		}
+		/* Get dma handle of skb->data */
+		new_skb_baddr = (u32) dma_map_single(lp->ndev->dev.parent,
+					new_skb->data,
+					XEMACPS_RX_BUF_SIZE,
+					DMA_FROM_DEVICE);
 
 		/* the packet length */
-		len = regval & XEMACPS_RXBUF_LEN_MASK;
-
-		skb = lp->rx_skb[bdidx].skb;
+		len = cur_p->ctrl & XEMACPS_RXBUF_LEN_MASK;
+		rmb();
+		skb = lp->rx_skb[lp->rx_bd_ci].skb;
 		dma_unmap_single(lp->ndev->dev.parent,
-						lp->rx_skb[bdidx].mapping,
-						XEMACPS_RX_BUF_SIZE,
-						DMA_FROM_DEVICE);
-
-		lp->rx_skb[bdidx].skb = NULL;
-		lp->rx_skb[bdidx].mapping = 0;
+				lp->rx_skb[lp->rx_bd_ci].mapping,
+				lp->rx_skb[lp->rx_bd_ci].len,
+				DMA_FROM_DEVICE);
 
 		/* setup received skb and send it upstream */
 		skb_put(skb, len);  /* Tell the skb how much data we got. */
-		skb->dev = lp->ndev;
-
-		/* Why does this return the protocol in network bye order ? */
 		skb->protocol = eth_type_trans(skb, lp->ndev);
 
 		skb->ip_summed = lp->ip_summed;
@@ -1012,23 +1148,30 @@ static int xemacps_rx(struct net_local *lp, int budget)
 			}
 		}
 #endif /* CONFIG_XILINX_PS_EMAC_HWTSTAMP */
-
-		lp->stats.rx_packets++;
-		lp->stats.rx_bytes += len;
+		size += len;
+		packets++;
 		netif_receive_skb(skb);
 
-		bdptr = XEMACPS_BDRING_NEXT(&lp->rx_ring, bdptr);
-		numbd--;
-	}
-
-	/* Make used BDs available */
-	rc = xemacps_bdringfree(&lp->rx_ring, numbdfree, bdptrfree);
-	if (rc)
-		printk(KERN_ERR "%s RX bdringfree() error.\n", lp->ndev->name);
+		cur_p->addr = (cur_p->addr & ~XEMACPS_RXBUF_ADD_MASK)
+					| (new_skb_baddr);
+		lp->rx_skb[lp->rx_bd_ci].skb = new_skb;
+		lp->rx_skb[lp->rx_bd_ci].mapping = new_skb_baddr;
+		lp->rx_skb[lp->rx_bd_ci].len = XEMACPS_RX_BUF_SIZE;
 
-	/* Refill RX buffers */
-	xemacps_DmaSetupRecvBuffers(lp->ndev);
+		cur_p->ctrl = 0;
+		cur_p->addr &= (~XEMACPS_RXBUF_NEW_MASK);
+		wmb();
 
+		lp->rx_bd_ci++;
+		lp->rx_bd_ci = lp->rx_bd_ci % XEMACPS_RECV_BD_CNT;
+		cur_p = &lp->rx_bd[lp->rx_bd_ci];
+		regval = cur_p->addr;
+		rmb();
+		numbdfree++;
+	}
+	wmb();
+	lp->stats.rx_packets += packets;
+	lp->stats.rx_bytes += size;
 	return numbdfree;
 }
 
@@ -1043,87 +1186,107 @@ static int xemacps_rx_poll(struct napi_struct *napi, int budget)
 	int work_done = 0;
 	u32 regval;
 
-	regval = xemacps_read(lp->baseaddr, XEMACPS_RXSR_OFFSET);
-	xemacps_write(lp->baseaddr, XEMACPS_RXSR_OFFSET, regval);
-
-	while (work_done < budget) {
-
-		dev_dbg(&lp->pdev->dev, "poll RX status 0x%x weight 0x%x\n",
-			regval, budget);
-
-		if (!(regval & XEMACPS_RXSR_FRAMERX_MASK)) {
-			dev_dbg(&lp->pdev->dev, "No RX complete status 0x%x\n",
-				regval);
-			napi_complete(napi);
+	spin_lock(&lp->rx_lock);
+	while (1) {
+		regval = xemacps_read(lp->baseaddr, XEMACPS_RXSR_OFFSET);
+		xemacps_write(lp->baseaddr, XEMACPS_RXSR_OFFSET, regval);
+		if (regval & XEMACPS_RXSR_HRESPNOK_MASK)
+			dev_err(&lp->pdev->dev, "RX error 0x%x\n", regval);
 
-			/* We disable RX interrupts in interrupt service
-			 * routine, now it is time to enable it back.
-			 */
-			regval = (XEMACPS_IXR_FRAMERX_MASK |
-					 XEMACPS_IXR_RX_ERR_MASK);
-			xemacps_write(lp->baseaddr, XEMACPS_IER_OFFSET, regval);
+		work_done += xemacps_rx(lp, budget - work_done);
+		if (work_done >= budget)
 			break;
-		}
 
-		work_done += xemacps_rx(lp, budget - work_done);
+		napi_complete(napi);
+		/* We disabled RX interrupts in interrupt service
+		 * routine, now it is time to enable it back.
+		 */
+		xemacps_write(lp->baseaddr,
+			XEMACPS_IER_OFFSET, XEMACPS_IXR_FRAMERX_MASK);
 
-		regval = xemacps_read(lp->baseaddr, XEMACPS_RXSR_OFFSET);
-		xemacps_write(lp->baseaddr, XEMACPS_RXSR_OFFSET, regval);
+		/* If a packet has come in between the last check of the BD
+		 * list and unmasking the interrupts, we may have missed the
+		 * interrupt, so reschedule here.
+		 */
+		if ((lp->rx_bd[lp->rx_bd_ci].addr & XEMACPS_RXBUF_NEW_MASK)
+		&&  napi_reschedule(napi)) {
+			xemacps_write(lp->baseaddr,
+				XEMACPS_IDR_OFFSET, XEMACPS_IXR_FRAMERX_MASK);
+			continue;
+		}
+		break;
 	}
-
+	spin_unlock(&lp->rx_lock);
 	return work_done;
 }
 
 /**
- * xemacps_tx_poll - tx isr handler routine
+ * xemacps_tx_poll - tx bd reclaim tasklet handler
  * @data: pointer to network interface device structure
  **/
-static void xemacps_tx_poll(struct net_device *ndev)
+static void xemacps_tx_poll(unsigned long data)
 {
+	struct net_device *ndev = (struct net_device *)data;
 	struct net_local *lp = netdev_priv(ndev);
-	u32 regval, bdlen = 0;
-	struct xemacps_bd *bdptr, *bdptrfree;
+	u32 regval;
+	u32 len = 0;
+	unsigned int bdcount = 0;
+	unsigned int bdpartialcount = 0;
+	unsigned int sop = 0;
+	struct xemacps_bd *cur_p;
+	u32 cur_i;
+	u32 numbdstofree;
+	u32 numbdsinhw;
 	struct ring_info *rp;
 	struct sk_buff *skb;
-	unsigned int numbd, numbdfree, bdidx, rc;
+	unsigned long flags;
 
+	spin_lock(&lp->tx_lock);
 	regval = xemacps_read(lp->baseaddr, XEMACPS_TXSR_OFFSET);
 	xemacps_write(lp->baseaddr, XEMACPS_TXSR_OFFSET, regval);
 	dev_dbg(&lp->pdev->dev, "TX status 0x%x\n", regval);
+	if (regval & (XEMACPS_TXSR_HRESPNOK_MASK | XEMACPS_TXSR_BUFEXH_MASK))
+		dev_err(&lp->pdev->dev, "TX error 0x%x\n", regval);
 
-	/* If this error is seen, it is in deep trouble and nothing
-	 * we can do to revive hardware other than reset hardware.
-	 * Or try to close this interface and reopen it.
-	 */
-	if (regval & (XEMACPS_TXSR_URUN_MASK | XEMACPS_TXSR_RXOVR_MASK |
-		XEMACPS_TXSR_HRESPNOK_MASK | XEMACPS_TXSR_COL1000_MASK |
-		XEMACPS_TXSR_BUFEXH_MASK)) {
-		printk(KERN_ERR "%s: TX ERROR 0x%x\n",
-			ndev->name, regval);
-		lp->stats.tx_errors++;
-	}
+	cur_i = lp->tx_bd_ci;
+	cur_p = &lp->tx_bd[cur_i];
+	numbdsinhw = XEMACPS_SEND_BD_CNT - lp->tx_bd_freecnt;
+	while (bdcount < numbdsinhw) {
+		if (sop == 0) {
+			if (cur_p->ctrl & XEMACPS_TXBUF_USED_MASK)
+				sop = 1;
+			else
+				break;
+		}
 
-	/* This may happen when a buffer becomes complete
-	 * between reading the ISR and scanning the descriptors.
-	 * Nothing to worry about.
-	 */
-	if (!(regval & XEMACPS_TXSR_TXCOMPL_MASK))
-		goto tx_poll_out;
+		bdcount++;
+		bdpartialcount++;
 
-	numbd = xemacps_bdringfromhwtx(&lp->tx_ring, XEMACPS_SEND_BD_CNT,
-		&bdptr);
-	numbdfree = numbd;
-	bdptrfree = bdptr;
+		/* hardware has processed this BD so check the "last" bit.
+		 * If it is clear, then there are more BDs for the current
+		 * packet. Keep a count of these partial packet BDs.
+		 */
+		if (cur_p->ctrl & XEMACPS_TXBUF_LAST_MASK) {
+			sop = 0;
+			bdpartialcount = 0;
+		}
 
-	while (numbd) {
-		regval  = xemacps_read(bdptr, XEMACPS_BD_STAT_OFFSET);
-		rmb();
-		bdlen = regval & XEMACPS_TXBUF_LEN_MASK;
-		bdidx = XEMACPS_BD_TO_INDEX(&lp->tx_ring, bdptr);
-		rp = &lp->tx_skb[bdidx];
+		cur_i++;
+		cur_i = cur_i % XEMACPS_SEND_BD_CNT;
+		cur_p = &lp->tx_bd[cur_i];
+	}
+	numbdstofree = bdcount - bdpartialcount;
+	lp->tx_bd_freecnt += numbdstofree;
+	numbdsinhw -= numbdstofree;
+	if (!numbdstofree)
+		goto tx_poll_out;
+
+	cur_p = &lp->tx_bd[lp->tx_bd_ci];
+	while (numbdstofree) {
+		rp = &lp->tx_skb[lp->tx_bd_ci];
 		skb = rp->skb;
 
-		BUG_ON(skb == NULL);
+		len += (cur_p->ctrl & XEMACPS_TXBUF_LEN_MASK);
 
 #ifdef CONFIG_XILINX_PS_EMAC_HWTSTAMP
 		if ((lp->hwtstamp_config.tx_type == HWTSTAMP_TX_ON) &&
@@ -1144,42 +1307,43 @@ static void xemacps_tx_poll(struct net_device *ndev)
 		}
 #endif /* CONFIG_XILINX_PS_EMAC_HWTSTAMP */
 
-		dma_unmap_single(&lp->pdev->dev, rp->mapping, skb->len,
+		dma_unmap_single(&lp->pdev->dev, rp->mapping, rp->len,
 			DMA_TO_DEVICE);
 		rp->skb = NULL;
-		dev_kfree_skb_irq(skb);
-#ifdef DEBUG_VERBOSE_TX
-		printk(KERN_INFO "GEM: TX bd index %d BD_STAT 0x%08x after sent.\n",
-			bdidx, regval);
-#endif
+		dev_kfree_skb(skb);
 		/* log tx completed packets and bytes, errors logs
 		 * are in other error counters.
 		 */
-		if (regval & XEMACPS_TXBUF_LAST_MASK) {
-			if (!(regval & XEMACPS_TXBUF_ERR_MASK)) {
-				lp->stats.tx_packets++;
-				lp->stats.tx_bytes += bdlen;
-			} else {
-				lp->stats.tx_errors++;
-			}
+		if (cur_p->ctrl & XEMACPS_TXBUF_LAST_MASK) {
+			lp->stats.tx_packets++;
+			lp->stats.tx_bytes += len;
+			len = 0;
 		}
 
-		/* Preserve used and wrap bits; clear everything else. */
-		regval &= (XEMACPS_TXBUF_USED_MASK | XEMACPS_TXBUF_WRAP_MASK);
-		xemacps_write(bdptr, XEMACPS_BD_STAT_OFFSET, regval);
+		/* Set used bit, preserve wrap bit; clear everything else. */
+		cur_p->ctrl |= XEMACPS_TXBUF_USED_MASK;
+		cur_p->ctrl &= (XEMACPS_TXBUF_USED_MASK |
+					XEMACPS_TXBUF_WRAP_MASK);
 
-		bdptr = XEMACPS_BDRING_NEXT(&lp->tx_ring, bdptr);
-		numbd--;
-		wmb();
+		lp->tx_bd_ci++;
+		lp->tx_bd_ci = lp->tx_bd_ci % XEMACPS_SEND_BD_CNT;
+		cur_p = &lp->tx_bd[lp->tx_bd_ci];
+		numbdstofree--;
 	}
+	wmb();
 
-	rc = xemacps_bdringfree(&lp->tx_ring, numbdfree, bdptrfree);
-	if (rc)
-		printk(KERN_ERR "%s TX bdringfree() error.\n", ndev->name);
+	if (numbdsinhw) {
+		spin_lock_irqsave(&lp->nwctrlreg_lock, flags);
+		regval = xemacps_read(lp->baseaddr, XEMACPS_NWCTRL_OFFSET);
+		regval |= XEMACPS_NWCTRL_STARTTX_MASK;
+		xemacps_write(lp->baseaddr, XEMACPS_NWCTRL_OFFSET, regval);
+		spin_unlock_irqrestore(&lp->nwctrlreg_lock, flags);
+	}
+
+	netif_wake_queue(ndev);
 
 tx_poll_out:
-	if (netif_queue_stopped(ndev))
-		netif_start_queue(ndev);
+	spin_unlock(&lp->tx_lock);
 }
 
 /**
@@ -1193,54 +1357,38 @@ static irqreturn_t xemacps_interrupt(int irq, void *dev_id)
 	struct net_device *ndev = dev_id;
 	struct net_local *lp = netdev_priv(ndev);
 	u32 regisr;
-
-	spin_lock(&lp->lock);
+	u32 regctrl;
 
 	regisr = xemacps_read(lp->baseaddr, XEMACPS_ISR_OFFSET);
-	rmb();
-
-	if (unlikely(!regisr)) {
-		spin_unlock(&lp->lock);
+	if (unlikely(!regisr))
 		return IRQ_NONE;
-	}
 
-	while (regisr) {
+	xemacps_write(lp->baseaddr, XEMACPS_ISR_OFFSET, regisr);
 
-		/* Log errors here. ISR status is cleared;
-		 * this must be recorded here.
-		 */
-		if (regisr & XEMACPS_IXR_RX_ERR_MASK)
-			lp->stats.rx_errors++;
-
-		/* RX interrupts */
-		if (regisr &
-		(XEMACPS_IXR_FRAMERX_MASK | XEMACPS_IXR_RX_ERR_MASK)) {
-
-			if (napi_schedule_prep(&lp->napi)) {
-				/* acknowledge RX interrupt and disable it,
-				 * napi will be the one processing it.  */
-				xemacps_write(lp->baseaddr,
-					XEMACPS_IDR_OFFSET,
-					(XEMACPS_IXR_FRAMERX_MASK |
-					 XEMACPS_IXR_RX_ERR_MASK));
-				dev_dbg(&lp->pdev->dev,
-					"schedule RX softirq\n");
-				__napi_schedule(&lp->napi);
-			}
+	while (regisr) {
+		if (regisr & (XEMACPS_IXR_TXCOMPL_MASK |
+				XEMACPS_IXR_TX_ERR_MASK)) {
+			tasklet_schedule(&lp->tx_bdreclaim_tasklet);
 		}
 
-		/* TX interrupts */
-		if (regisr &
-		(XEMACPS_IXR_TXCOMPL_MASK | XEMACPS_IXR_TX_ERR_MASK))
-			xemacps_tx_poll(ndev);
+		if (regisr & XEMACPS_IXR_RXUSED_MASK) {
+			spin_lock(&lp->nwctrlreg_lock);
+			regctrl = xemacps_read(lp->baseaddr,
+					XEMACPS_NWCTRL_OFFSET);
+			regctrl |= XEMACPS_NWCTRL_FLUSH_DPRAM_MASK;
+			xemacps_write(lp->baseaddr,
+					XEMACPS_NWCTRL_OFFSET, regctrl);
+			spin_unlock(&lp->nwctrlreg_lock);
+		}
 
-		/* acknowledge interrupt and clear it */
-		xemacps_write(lp->baseaddr, XEMACPS_ISR_OFFSET, regisr);
-		wmb();
+		if (regisr & XEMACPS_IXR_FRAMERX_MASK) {
+			xemacps_write(lp->baseaddr,
+				XEMACPS_IDR_OFFSET, XEMACPS_IXR_FRAMERX_MASK);
+			napi_schedule(&lp->napi);
+		}
 		regisr = xemacps_read(lp->baseaddr, XEMACPS_ISR_OFFSET);
-		rmb();
+		xemacps_write(lp->baseaddr, XEMACPS_ISR_OFFSET, regisr);
 	}
-	spin_unlock(&lp->lock);
 
 	return IRQ_HANDLED;
 }
@@ -1256,7 +1404,7 @@ static void xemacps_clean_rings(struct net_local *lp)
 		if (lp->rx_skb && lp->rx_skb[i].skb) {
 			dma_unmap_single(lp->ndev->dev.parent,
 					 lp->rx_skb[i].mapping,
-					 XEMACPS_RX_BUF_SIZE,
+					 lp->rx_skb[i].len,
 					 DMA_FROM_DEVICE);
 
 			dev_kfree_skb(lp->rx_skb[i].skb);
@@ -1269,7 +1417,7 @@ static void xemacps_clean_rings(struct net_local *lp)
 		if (lp->tx_skb && lp->tx_skb[i].skb) {
 			dma_unmap_single(lp->ndev->dev.parent,
 					 lp->tx_skb[i].mapping,
-					 lp->tx_skb[i].skb->len,
+					 lp->tx_skb[i].len,
 					 DMA_TO_DEVICE);
 
 			dev_kfree_skb(lp->tx_skb[i].skb);
@@ -1318,6 +1466,21 @@ static void xemacps_descriptor_free(struct net_local *lp)
 static int xemacps_descriptor_init(struct net_local *lp)
 {
 	int size;
+	struct sk_buff *new_skb;
+	u32 new_skb_baddr;
+	u32 i;
+	struct xemacps_bd *cur_p;
+	u32 regval;
+
+	lp->tx_skb = NULL;
+	lp->rx_skb = NULL;
+	lp->rx_bd = NULL;
+	lp->tx_bd = NULL;
+
+	/* Reset the indexes which are used for accessing the BDs */
+	lp->tx_bd_ci = 0;
+	lp->tx_bd_tail = 0;
+	lp->rx_bd_ci = 0;
 
 	size = XEMACPS_SEND_BD_CNT * sizeof(struct ring_info);
 	lp->tx_skb = kzalloc(size, GFP_KERNEL);
@@ -1328,6 +1491,10 @@ static int xemacps_descriptor_init(struct net_local *lp)
 	if (!lp->rx_skb)
 		goto err_out;
 
+	/*
+	 * Set up RX buffer descriptors.
+	 */
+
 	size = XEMACPS_RECV_BD_CNT * sizeof(struct xemacps_bd);
 	lp->rx_bd = dma_alloc_coherent(&lp->pdev->dev, size,
 			&lp->rx_bd_dma, GFP_KERNEL);
@@ -1336,6 +1503,38 @@ static int xemacps_descriptor_init(struct net_local *lp)
 	dev_dbg(&lp->pdev->dev, "RX ring %d bytes at 0x%x mapped %p\n",
 			size, lp->rx_bd_dma, lp->rx_bd);
 
+	for (i = 0; i < XEMACPS_RECV_BD_CNT; i++) {
+		cur_p = &lp->rx_bd[i];
+
+		new_skb = netdev_alloc_skb(lp->ndev, XEMACPS_RX_BUF_SIZE);
+		if (new_skb == NULL) {
+			dev_err(&lp->ndev->dev, "alloc_skb error %d\n", i);
+			goto err_out;
+		}
+
+		/* Get dma handle of skb->data */
+		new_skb_baddr = (u32) dma_map_single(lp->ndev->dev.parent,
+							new_skb->data,
+							XEMACPS_RX_BUF_SIZE,
+							DMA_FROM_DEVICE);
+
+		/* set wrap bit for last BD */
+		regval = (new_skb_baddr & XEMACPS_RXBUF_ADD_MASK);
+		if (i == XEMACPS_RECV_BD_CNT - 1)
+			regval |= XEMACPS_RXBUF_WRAP_MASK;
+		cur_p->addr = regval;
+		cur_p->ctrl = 0;
+		wmb();
+
+		lp->rx_skb[i].skb = new_skb;
+		lp->rx_skb[i].mapping = new_skb_baddr;
+		lp->rx_skb[i].len = XEMACPS_RX_BUF_SIZE;
+	}
+
+	/*
+	 * Set up TX buffer descriptors.
+	 */
+
 	size = XEMACPS_SEND_BD_CNT * sizeof(struct xemacps_bd);
 	lp->tx_bd = dma_alloc_coherent(&lp->pdev->dev, size,
 			&lp->tx_bd_dma, GFP_KERNEL);
@@ -1344,12 +1543,26 @@ static int xemacps_descriptor_init(struct net_local *lp)
 	dev_dbg(&lp->pdev->dev, "TX ring %d bytes at 0x%x mapped %p\n",
 			size, lp->tx_bd_dma, lp->tx_bd);
 
-#ifdef DEBUG
-	printk(KERN_INFO "GEM: lp->tx_bd %p lp->tx_bd_dma %p lp->tx_skb %p\n",
+	for (i = 0; i < XEMACPS_SEND_BD_CNT; i++) {
+		cur_p = &lp->tx_bd[i];
+		/* set wrap bit for last BD */
+		cur_p->addr = 0;
+		regval = XEMACPS_TXBUF_USED_MASK;
+		if (i == XEMACPS_SEND_BD_CNT - 1)
+			regval |= XEMACPS_TXBUF_WRAP_MASK;
+		cur_p->ctrl = regval;
+	}
+	wmb();
+
+	lp->tx_bd_freecnt = XEMACPS_SEND_BD_CNT;
+
+	dev_dbg(&lp->pdev->dev,
+		"lp->tx_bd %p lp->tx_bd_dma %p lp->tx_skb %p\n",
 		lp->tx_bd, (void *)lp->tx_bd_dma, lp->tx_skb);
-	printk(KERN_INFO "GEM: lp->rx_bd %p lp->rx_bd_dma %p lp->rx_skb %p\n",
+	dev_dbg(&lp->pdev->dev,
+		"lp->rx_bd %p lp->rx_bd_dma %p lp->rx_skb %p\n",
 		lp->rx_bd, (void *)lp->rx_bd_dma, lp->rx_skb);
-#endif
+
 	return 0;
 
 err_out:
@@ -1357,89 +1570,6 @@ err_out:
 	return -ENOMEM;
 }
 
-/**
- * xemacps_setup_ring - Setup both TX and RX BD rings
- * @lp: local device instance pointer
- * return 0 on success, negative value if error
- **/
-static int xemacps_setup_ring(struct net_local *lp)
-{
-	int i;
-	u32 regval;
-	struct xemacps_bd *bdptr;
-
-	lp->rx_ring.separation   = (sizeof(struct xemacps_bd) +
-		(ALIGNMENT_BD - 1)) & ~(ALIGNMENT_BD - 1);
-	lp->rx_ring.physbaseaddr = lp->rx_bd_dma;
-	lp->rx_ring.firstbdaddr  = (u32)lp->rx_bd;
-	lp->rx_ring.lastbdaddr   = (u32)(lp->rx_bd +
-		(XEMACPS_RECV_BD_CNT - 1) * sizeof(struct xemacps_bd));
-	lp->rx_ring.length       = lp->rx_ring.lastbdaddr -
-		lp->rx_ring.firstbdaddr + lp->rx_ring.separation;
-	lp->rx_ring.freehead     = (struct xemacps_bd *)lp->rx_bd;
-	lp->rx_ring.prehead      = (struct xemacps_bd *)lp->rx_bd;
-	lp->rx_ring.hwhead       = (struct xemacps_bd *)lp->rx_bd;
-	lp->rx_ring.hwtail       = (struct xemacps_bd *)lp->rx_bd;
-	lp->rx_ring.posthead     = (struct xemacps_bd *)lp->rx_bd;
-	lp->rx_ring.allcnt       = XEMACPS_RECV_BD_CNT;
-	lp->rx_ring.freecnt      = XEMACPS_RECV_BD_CNT;
-	lp->rx_ring.precnt       = 0;
-	lp->rx_ring.hwcnt        = 0;
-	lp->rx_ring.postcnt      = 0;
-	lp->rx_ring.is_rx        = 1;
-
-	bdptr = (struct xemacps_bd *)lp->rx_ring.firstbdaddr;
-
-	/* Setup RX BD ring structure and populate buffer address. */
-	for (i = 0; i < (XEMACPS_RECV_BD_CNT - 1); i++) {
-		xemacps_write(bdptr, XEMACPS_BD_STAT_OFFSET, 0);
-		xemacps_write(bdptr, XEMACPS_BD_ADDR_OFFSET, 0);
-		bdptr = XEMACPS_BDRING_NEXT(&lp->rx_ring, bdptr);
-	}
-	/* wrap bit set for last BD, bdptr is moved to last here */
-	xemacps_write(bdptr, XEMACPS_BD_STAT_OFFSET, 0);
-	xemacps_write(bdptr, XEMACPS_BD_ADDR_OFFSET, XEMACPS_RXBUF_WRAP_MASK);
-
-	/* Allocate RX skbuffs; set descriptor buffer addresses */
-	xemacps_DmaSetupRecvBuffers(lp->ndev);
-
-	lp->tx_ring.separation   = (sizeof(struct xemacps_bd) +
-		(ALIGNMENT_BD - 1)) & ~(ALIGNMENT_BD - 1);
-	lp->tx_ring.physbaseaddr = lp->tx_bd_dma;
-	lp->tx_ring.firstbdaddr  = (u32)lp->tx_bd;
-	lp->tx_ring.lastbdaddr   = (u32)(lp->tx_bd +
-		(XEMACPS_SEND_BD_CNT - 1) * sizeof(struct xemacps_bd));
-	lp->tx_ring.length       = lp->tx_ring.lastbdaddr -
-		lp->tx_ring.firstbdaddr + lp->tx_ring.separation;
-	lp->tx_ring.freehead     = (struct xemacps_bd *)lp->tx_bd;
-	lp->tx_ring.prehead      = (struct xemacps_bd *)lp->tx_bd;
-	lp->tx_ring.hwhead       = (struct xemacps_bd *)lp->tx_bd;
-	lp->tx_ring.hwtail       = (struct xemacps_bd *)lp->tx_bd;
-	lp->tx_ring.posthead     = (struct xemacps_bd *)lp->tx_bd;
-	lp->tx_ring.allcnt       = XEMACPS_SEND_BD_CNT;
-	lp->tx_ring.freecnt      = XEMACPS_SEND_BD_CNT;
-	lp->tx_ring.precnt       = 0;
-	lp->tx_ring.hwcnt        = 0;
-	lp->tx_ring.postcnt      = 0;
-	lp->tx_ring.is_rx        = 0;
-
-	bdptr = (struct xemacps_bd *)lp->tx_ring.firstbdaddr;
-
-	/* Setup TX BD ring structure and assert used bit initially. */
-	for (i = 0; i < (XEMACPS_SEND_BD_CNT - 1); i++) {
-		xemacps_write(bdptr, XEMACPS_BD_ADDR_OFFSET, 0);
-		xemacps_write(bdptr, XEMACPS_BD_STAT_OFFSET,
-			XEMACPS_TXBUF_USED_MASK);
-		bdptr = XEMACPS_BDRING_NEXT(&lp->tx_ring, bdptr);
-	}
-	/* wrap bit set for last BD, bdptr is moved to last here */
-	xemacps_write(bdptr, XEMACPS_BD_ADDR_OFFSET, 0);
-	regval = (XEMACPS_TXBUF_WRAP_MASK | XEMACPS_TXBUF_USED_MASK);
-	xemacps_write(bdptr, XEMACPS_BD_STAT_OFFSET, regval);
-
-	return 0;
-}
-
 #ifdef CONFIG_XILINX_PS_EMAC_HWTSTAMP
 /*
  * Initialize the GEM Time Stamp Unit
@@ -1505,10 +1635,7 @@ static void xemacps_init_hw(struct net_local *lp)
 	regval |= XEMACPS_NWCFG_100_MASK;
 	regval |= XEMACPS_NWCFG_HDRXEN_MASK;
 
-#ifdef CONFIG_OF
-	if (lp->board_type == BOARD_TYPE_ZYNQ)
-		regval |= (MDC_DIV_224 << XEMACPS_NWCFG_MDC_SHIFT_MASK);
-#endif
+	regval |= (MDC_DIV_224 << XEMACPS_NWCFG_MDC_SHIFT_MASK);
 	if (lp->ndev->flags & IFF_PROMISC)	/* copy all */
 		regval |= XEMACPS_NWCFG_COPYALLEN_MASK;
 	if (!(lp->ndev->flags & IFF_BROADCAST))	/* No broadcast */
@@ -1516,10 +1643,8 @@ static void xemacps_init_hw(struct net_local *lp)
 	xemacps_write(lp->baseaddr, XEMACPS_NWCFG_OFFSET, regval);
 
 	/* Init TX and RX DMA Q address */
-	xemacps_write(lp->baseaddr, XEMACPS_RXQBASE_OFFSET,
-		lp->rx_ring.physbaseaddr);
-	xemacps_write(lp->baseaddr, XEMACPS_TXQBASE_OFFSET,
-		lp->tx_ring.physbaseaddr);
+	xemacps_write(lp->baseaddr, XEMACPS_RXQBASE_OFFSET, lp->rx_bd_dma);
+	xemacps_write(lp->baseaddr, XEMACPS_TXQBASE_OFFSET, lp->tx_bd_dma);
 
 	/* DMACR configurations */
 	regval  = (((XEMACPS_RX_BUF_SIZE / XEMACPS_RX_BUF_UNIT) +
@@ -1555,6 +1680,122 @@ static void xemacps_init_hw(struct net_local *lp)
 }
 
 /**
+ * xemacps_resetrx_for_no_rxdata - Resets the Rx if there is no data
+ * for a while (presently 100 msecs)
+ * @data: Used for net_local instance pointer
+ **/
+static void xemacps_resetrx_for_no_rxdata(unsigned long data)
+{
+	struct net_local *lp = (struct net_local *)data;
+	unsigned long regctrl;
+	unsigned long tempcntr;
+	unsigned long flags;
+
+	tempcntr = xemacps_read(lp->baseaddr, XEMACPS_RXCNT_OFFSET);
+	if ((!tempcntr) && (!(lp->lastrxfrmscntr))) {
+		spin_lock_irqsave(&lp->nwctrlreg_lock, flags);
+		regctrl = xemacps_read(lp->baseaddr,
+				XEMACPS_NWCTRL_OFFSET);
+		regctrl &= (~XEMACPS_NWCTRL_RXEN_MASK);
+		xemacps_write(lp->baseaddr,
+				XEMACPS_NWCTRL_OFFSET, regctrl);
+		regctrl = xemacps_read(lp->baseaddr, XEMACPS_NWCTRL_OFFSET);
+		regctrl |= (XEMACPS_NWCTRL_RXEN_MASK);
+		xemacps_write(lp->baseaddr, XEMACPS_NWCTRL_OFFSET, regctrl);
+		spin_unlock_irqrestore(&lp->nwctrlreg_lock, flags);
+	}
+	lp->lastrxfrmscntr = tempcntr;
+}
+
+/**
+ * xemacps_update_stats - Update the statistic structure entries from
+ * the corresponding emacps hardware statistic registers
+ * @data: Used for net_local instance pointer
+ **/
+static void xemacps_update_stats(unsigned long data)
+{
+	struct net_local *lp = (struct net_local *)data;
+	struct net_device_stats *nstat = &lp->stats;
+	u32 cnt;
+
+	cnt = xemacps_read(lp->baseaddr, XEMACPS_RXUNDRCNT_OFFSET);
+	nstat->rx_errors += cnt;
+	nstat->rx_length_errors += cnt;
+
+	cnt = xemacps_read(lp->baseaddr, XEMACPS_RXOVRCNT_OFFSET);
+	nstat->rx_errors += cnt;
+	nstat->rx_length_errors += cnt;
+
+	cnt = xemacps_read(lp->baseaddr, XEMACPS_RXJABCNT_OFFSET);
+	nstat->rx_errors += cnt;
+	nstat->rx_length_errors += cnt;
+
+	cnt = xemacps_read(lp->baseaddr, XEMACPS_RXFCSCNT_OFFSET);
+	nstat->rx_errors += cnt;
+	nstat->rx_crc_errors += cnt;
+
+	cnt = xemacps_read(lp->baseaddr, XEMACPS_RXLENGTHCNT_OFFSET);
+	nstat->rx_errors += cnt;
+	nstat->rx_length_errors += cnt;
+
+	cnt = xemacps_read(lp->baseaddr, XEMACPS_RXALIGNCNT_OFFSET);
+	nstat->rx_errors += cnt;
+	nstat->rx_frame_errors += cnt;
+
+	cnt = xemacps_read(lp->baseaddr, XEMACPS_RXRESERRCNT_OFFSET);
+	nstat->rx_errors += cnt;
+	nstat->rx_missed_errors += cnt;
+
+	cnt = xemacps_read(lp->baseaddr, XEMACPS_RXORCNT_OFFSET);
+	nstat->rx_errors += cnt;
+	nstat->rx_fifo_errors += cnt;
+
+	cnt = xemacps_read(lp->baseaddr, XEMACPS_TXURUNCNT_OFFSET);
+	nstat->tx_errors += cnt;
+	nstat->tx_fifo_errors += cnt;
+
+	cnt = xemacps_read(lp->baseaddr, XEMACPS_SNGLCOLLCNT_OFFSET);
+	nstat->collisions += cnt;
+
+	cnt = xemacps_read(lp->baseaddr, XEMACPS_MULTICOLLCNT_OFFSET);
+	nstat->collisions += cnt;
+
+	cnt = xemacps_read(lp->baseaddr, XEMACPS_EXCESSCOLLCNT_OFFSET);
+	nstat->tx_errors += cnt;
+	nstat->tx_aborted_errors += cnt;
+	nstat->collisions += cnt;
+
+	cnt = xemacps_read(lp->baseaddr, XEMACPS_LATECOLLCNT_OFFSET);
+	nstat->tx_errors += cnt;
+	nstat->collisions += cnt;
+
+	cnt = xemacps_read(lp->baseaddr, XEMACPS_CSENSECNT_OFFSET);
+	nstat->tx_errors += cnt;
+	nstat->tx_carrier_errors += cnt;
+}
+
+/**
+ * xemacps_gen_purpose_timerhandler - Timer handler that is called at regular
+ * intervals upon expiry of the gen_purpose_timer defined in net_local struct.
+ * @data: Used for net_local instance pointer
+ *
+ * This timer handler is used to update the statistics by calling the API
+ * xemacps_update_stats. The statistics register can typically overflow pretty
+ * quickly under heavy load conditions. This timer is used to periodically
+ * read the stats registers and update the corresponding stats structure
+ * entries. The stats registers when read reset to 0.
+ **/
+static void xemacps_gen_purpose_timerhandler(unsigned long data)
+{
+	struct net_local *lp = (struct net_local *)data;
+
+	xemacps_update_stats(data);
+	xemacps_resetrx_for_no_rxdata(data);
+	mod_timer(&(lp->gen_purpose_timer),
+		jiffies + msecs_to_jiffies(XEAMCPS_GEN_PURPOSE_TIMER_LOAD));
+}
+
+/**
  * xemacps_open - Called when a network device is made active
  * @ndev: network interface device structure
  * return 0 on success, negative value if error
@@ -1572,50 +1813,58 @@ static int xemacps_open(struct net_device *ndev)
 {
 	struct net_local *lp = netdev_priv(ndev);
 	int rc;
-	unsigned long flags;
 
-	spin_lock_irqsave(&lp->lock, flags);
 	dev_dbg(&lp->pdev->dev, "open\n");
-	if (!is_valid_ether_addr(ndev->dev_addr)) {
-		spin_unlock_irqrestore(&lp->lock, flags);
+	if (!is_valid_ether_addr(ndev->dev_addr))
 		return  -EADDRNOTAVAIL;
-	}
 
 	rc = xemacps_descriptor_init(lp);
 	if (rc) {
-		printk(KERN_ERR "%s Unable to allocate DMA memory, rc %d\n",
-		ndev->name, rc);
-		spin_unlock_irqrestore(&lp->lock, flags);
+		dev_err(&lp->pdev->dev,
+			"Unable to allocate DMA memory, rc %d\n", rc);
 		return rc;
 	}
 
-	rc = xemacps_setup_ring(lp);
-	if (rc) {
-		printk(KERN_ERR "%s Unable to setup BD rings, rc %d\n",
-		ndev->name, rc);
-		spin_unlock_irqrestore(&lp->lock, flags);
-		return rc;
+	rc = pm_runtime_get_sync(&lp->pdev->dev);
+	if (rc < 0) {
+		dev_err(&lp->pdev->dev,
+			"pm_runtime_get_sync() failed, rc %d\n", rc);
+		goto err_free_rings;
 	}
+
 	xemacps_init_hw(lp);
-	napi_enable(&lp->napi);
 	rc = xemacps_mii_probe(ndev);
 	if (rc != 0) {
-		printk(KERN_ERR "%s mii_probe fail.\n", lp->mii_bus->name);
+		dev_err(&lp->pdev->dev,
+			"%s mii_probe fail.\n", lp->mii_bus->name);
 		if (rc == (-2)) {
 			mdiobus_unregister(lp->mii_bus);
 			kfree(lp->mii_bus->irq);
 			mdiobus_free(lp->mii_bus);
 		}
-		spin_unlock_irqrestore(&lp->lock, flags);
-		return -ENXIO;
+		rc = -ENXIO;
+		goto err_pm_put;
 	}
 
-	spin_unlock_irqrestore(&lp->lock, flags);
-	netif_carrier_on(ndev);
+	setup_timer(&(lp->gen_purpose_timer), xemacps_gen_purpose_timerhandler,
+							(unsigned long)lp);
+	mod_timer(&(lp->gen_purpose_timer),
+		jiffies + msecs_to_jiffies(XEAMCPS_GEN_PURPOSE_TIMER_LOAD));
 
+	napi_enable(&lp->napi);
+	netif_carrier_on(ndev);
 	netif_start_queue(ndev);
+	tasklet_enable(&lp->tx_bdreclaim_tasklet);
 
 	return 0;
+
+err_pm_put:
+	xemacps_reset_hw(lp);
+	pm_runtime_put(&lp->pdev->dev);
+err_free_rings:
+	xemacps_descriptor_free(lp);
+
+	return rc;
 }
 
 /**
@@ -1631,25 +1880,29 @@ static int xemacps_open(struct net_device *ndev)
 static int xemacps_close(struct net_device *ndev)
 {
 	struct net_local *lp = netdev_priv(ndev);
-	unsigned long flags;
 
+	del_timer_sync(&(lp->gen_purpose_timer));
 	netif_stop_queue(ndev);
 	napi_disable(&lp->napi);
-	spin_lock_irqsave(&lp->lock, flags);
-	xemacps_reset_hw(lp);
+	tasklet_disable(&lp->tx_bdreclaim_tasklet);
 	netif_carrier_off(ndev);
-	spin_unlock_irqrestore(&lp->lock, flags);
 	if (lp->phy_dev)
 		phy_disconnect(lp->phy_dev);
+	if (lp->gmii2rgmii_phy_node)
+		phy_disconnect(lp->gmii2rgmii_phy_dev);
+	xemacps_reset_hw(lp);
+	mdelay(500);
 	xemacps_descriptor_free(lp);
 
+	pm_runtime_put(&lp->pdev->dev);
+
 	return 0;
 }
 
 /**
  * xemacps_reinit_for_txtimeout - work queue scheduled for the tx timeout
  * handling.
- * @data: queue work structure
+ * @ndev: queue work structure
  **/
 static void xemacps_reinit_for_txtimeout(struct work_struct *data)
 {
@@ -1659,43 +1912,39 @@ static void xemacps_reinit_for_txtimeout(struct work_struct *data)
 
 	netif_stop_queue(lp->ndev);
 	napi_disable(&lp->napi);
-	spin_lock_bh(&lp->lock);
+	tasklet_disable(&lp->tx_bdreclaim_tasklet);
+	spin_lock_bh(&lp->tx_lock);
 	xemacps_reset_hw(lp);
-	spin_unlock_bh(&lp->lock);
-	if (lp->phy_dev){
-		if (lp->board_type == BOARD_TYPE_ZYNQ)
-			phy_stop(lp->phy_dev);
-	}
+	spin_unlock_bh(&lp->tx_lock);
 
-	xemacps_descriptor_free(lp);
+	if (lp->phy_dev)
+		phy_stop(lp->phy_dev);
 
+	xemacps_descriptor_free(lp);
 	rc = xemacps_descriptor_init(lp);
 	if (rc) {
-		printk(KERN_ERR "%s Unable to allocate DMA memory, rc %d\n",
-		lp->ndev->name, rc);
+		dev_err(&lp->pdev->dev,
+			"Unable to allocate DMA memory, rc %d\n", rc);
 		return;
 	}
 
-	rc = xemacps_setup_ring(lp);
-	if (rc) {
-		printk(KERN_ERR "%s Unable to setup BD rings, rc %d\n",
-		lp->ndev->name, rc);
-		return;
-	}
 	xemacps_init_hw(lp);
 
 	lp->link    = 0;
 	lp->speed   = 0;
 	lp->duplex  = -1;
+
 	if (lp->phy_dev)
 		phy_start(lp->phy_dev);
+
 	napi_enable(&lp->napi);
+	tasklet_enable(&lp->tx_bdreclaim_tasklet);
 	lp->ndev->trans_start = jiffies;
 	netif_wake_queue(lp->ndev);
 }
 
 /**
- * xemacps_tx_timeout - callback uses when the transmitter has not made
+ * xemacps_tx_timeout - callback used when the transmitter has not made
  * any progress for dev->watchdog ticks.
  * @ndev: network interface device structure
  **/
@@ -1708,7 +1957,6 @@ static void xemacps_tx_timeout(struct net_device *ndev)
 	queue_work(lp->txtimeout_handler_wq, &lp->txtimeout_reinit);
 }
 
-
 /**
  * xemacps_set_mac_address - set network interface mac address
  * @ndev: network interface device structure
@@ -1725,11 +1973,11 @@ static int xemacps_set_mac_address(struct net_device *ndev, void *addr)
 
 	if (!is_valid_ether_addr(hwaddr->sa_data))
 		return -EADDRNOTAVAIL;
-#ifdef DEBUG
-	printk(KERN_INFO "GEM: hwaddr 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\n",
+
+	dev_dbg(&lp->pdev->dev, "hwaddr 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\n",
 		hwaddr->sa_data[0], hwaddr->sa_data[1], hwaddr->sa_data[2],
 		hwaddr->sa_data[3], hwaddr->sa_data[4], hwaddr->sa_data[5]);
-#endif
+
 	memcpy(ndev->dev_addr, hwaddr->sa_data, ndev->addr_len);
 
 	xemacps_set_hwaddr(lp);
@@ -1746,47 +1994,28 @@ static int xemacps_start_xmit(struct sk_buff *skb, struct net_device *ndev)
 {
 	struct net_local *lp = netdev_priv(ndev);
 	dma_addr_t  mapping;
-	unsigned int nr_frags, bdidx, len;
-	int i, rc;
+	unsigned int nr_frags, len;
+	int i;
 	u32 regval;
-	struct xemacps_bd *bdptr, *bdptrs;
 	void       *virt_addr;
 	skb_frag_t *frag;
+	struct xemacps_bd *cur_p;
 	unsigned long flags;
+	u32 bd_tail;
 
-#ifdef DEBUG_VERBOSE_TX
-	printk(KERN_INFO "%s: TX data:", __func__);
-	for (i = 0; i < 48; i++) {
-		if (!(i % 16))
-			printk("\n");
-		printk(KERN_INFO " %02x", (unsigned int)skb->data[i]);
-	}
-	printk("\n");
-#endif
-
-	spin_lock_irqsave(&lp->lock, flags);
 	nr_frags = skb_shinfo(skb)->nr_frags + 1;
+	spin_lock_bh(&lp->tx_lock);
 
-	if (nr_frags < lp->tx_ring.freecnt) {
-		rc = xemacps_bdringalloc(&lp->tx_ring, nr_frags, &bdptr);
-		if (rc) {
-			netif_stop_queue(ndev); /* stop send queue */
-			spin_unlock_irqrestore(&lp->lock, flags);
-			return rc;
-		}
-	} else {
+	if (nr_frags > lp->tx_bd_freecnt) {
 		netif_stop_queue(ndev); /* stop send queue */
-		spin_unlock_irqrestore(&lp->lock, flags);
+		spin_unlock_bh(&lp->tx_lock);
 		return NETDEV_TX_BUSY;
 	}
 
+	bd_tail = lp->tx_bd_tail;
+	cur_p = &lp->tx_bd[bd_tail];
+	lp->tx_bd_freecnt -= nr_frags;
 	frag = &skb_shinfo(skb)->frags[0];
-	bdptrs = bdptr;
-
-#ifdef DEBUG_VERBOSE_TX
-	printk(KERN_INFO "GEM: TX nr_frags %d, skb->len 0x%x, skb_headlen(skb) 0x%x\n",
-		nr_frags, skb->len, skb_headlen(skb));
-#endif
 
 	for (i = 0; i < nr_frags; i++) {
 		if (i == 0) {
@@ -1794,62 +2023,55 @@ static int xemacps_start_xmit(struct sk_buff *skb, struct net_device *ndev)
 			mapping = dma_map_single(&lp->pdev->dev, skb->data,
 				len, DMA_TO_DEVICE);
 		} else {
-			len = frag->size;
+			len = skb_frag_size(frag);
 			virt_addr = skb_frag_address(frag);
 			mapping = dma_map_single(&lp->pdev->dev, virt_addr,
 				len, DMA_TO_DEVICE);
 			frag++;
+			skb_get(skb);
 		}
 
-		bdidx = XEMACPS_BD_TO_INDEX(&lp->tx_ring, bdptr);
+		lp->tx_skb[lp->tx_bd_tail].skb = skb;
+		lp->tx_skb[lp->tx_bd_tail].mapping = mapping;
+		lp->tx_skb[lp->tx_bd_tail].len = len;
+		cur_p->addr = mapping;
 
-		lp->tx_skb[bdidx].skb = skb;
-		lp->tx_skb[bdidx].mapping = mapping;
-		wmb();
-
-		xemacps_write(bdptr, XEMACPS_BD_ADDR_OFFSET, mapping);
-		wmb();
-
-		regval = xemacps_read(bdptr, XEMACPS_BD_STAT_OFFSET);
-		/* Preserve only critical status bits.  Packet is NOT to be
-		 * committed to hardware at this time.
-		 */
+		/* preserve critical status bits */
+		regval = cur_p->ctrl;
 		regval &= (XEMACPS_TXBUF_USED_MASK | XEMACPS_TXBUF_WRAP_MASK);
 		/* update length field */
 		regval |= ((regval & ~XEMACPS_TXBUF_LEN_MASK) | len);
+		/* commit second to last buffer to hardware */
+		if (i != 0)
+			regval &= ~XEMACPS_TXBUF_USED_MASK;
 		/* last fragment of this packet? */
 		if (i == (nr_frags - 1))
 			regval |= XEMACPS_TXBUF_LAST_MASK;
-		xemacps_write(bdptr, XEMACPS_BD_STAT_OFFSET, regval);
+		cur_p->ctrl = regval;
 
-#ifdef DEBUG_VERBOSE_TX
-		printk(KERN_INFO "GEM: TX BD index %d, BDptr %p, BD_STAT 0x%08x\n",
-			bdidx, bdptr, regval);
-#endif
-		bdptr = XEMACPS_BDRING_NEXT(&lp->tx_ring, bdptr);
+		lp->tx_bd_tail++;
+		lp->tx_bd_tail = lp->tx_bd_tail % XEMACPS_SEND_BD_CNT;
+		cur_p = &(lp->tx_bd[lp->tx_bd_tail]);
 	}
 	wmb();
 
-	rc = xemacps_bdringtohw(&lp->tx_ring, nr_frags, bdptrs);
+	/* commit first buffer to hardware -- do this after
+	 * committing the other buffers to avoid an underrun */
+	cur_p = &lp->tx_bd[bd_tail];
+	regval = cur_p->ctrl;
+	regval &= ~XEMACPS_TXBUF_USED_MASK;
+	cur_p->ctrl = regval;
+	wmb();
 
-	if (rc) {
-		netif_stop_queue(ndev);
-		dev_kfree_skb(skb);
-		lp->stats.tx_dropped++;
-		xemacps_bdringunalloc(&lp->tx_ring, nr_frags, bdptrs);
-		printk(KERN_ERR "%s can not send, commit TX buffer desc\n",
-			ndev->name);
-		spin_unlock_irqrestore(&lp->lock, flags);
-		return rc;
-	} else {
-		regval = xemacps_read(lp->baseaddr, XEMACPS_NWCTRL_OFFSET);
-		xemacps_write(lp->baseaddr, XEMACPS_NWCTRL_OFFSET,
+	spin_lock_irqsave(&lp->nwctrlreg_lock, flags);
+	regval = xemacps_read(lp->baseaddr, XEMACPS_NWCTRL_OFFSET);
+	xemacps_write(lp->baseaddr, XEMACPS_NWCTRL_OFFSET,
 			(regval | XEMACPS_NWCTRL_STARTTX_MASK));
-	}
-	ndev->trans_start = jiffies;
-	spin_unlock_irqrestore(&lp->lock, flags);
+	spin_unlock_irqrestore(&lp->nwctrlreg_lock, flags);
 
-	return rc;
+	spin_unlock_bh(&lp->tx_lock);
+	ndev->trans_start = jiffies;
+	return 0;
 }
 
 /*
@@ -1947,8 +2169,9 @@ static void xemacps_set_hashtable(struct net_device *ndev)
 		hash_index = calc_mac_hash(mc_addr);
 
 		if (hash_index >= XEMACPS_MAX_HASH_BITS) {
-			printk(KERN_ERR "hash calculation out of range %d\n",
-				hash_index);
+			dev_err(&lp->pdev->dev,
+					"hash calculation out of range %d\n",
+					hash_index);
 			break;
 		}
 		if (hash_index < 32)
@@ -2087,13 +2310,12 @@ xemacps_get_drvinfo(struct net_device *ndev, struct ethtool_drvinfo *ed)
 static void
 xemacps_get_ringparam(struct net_device *ndev, struct ethtool_ringparam *erp)
 {
-	struct net_local *lp = netdev_priv(ndev);
 	memset(erp, 0, sizeof(struct ethtool_ringparam));
 
 	erp->rx_max_pending = XEMACPS_RECV_BD_CNT;
 	erp->tx_max_pending = XEMACPS_SEND_BD_CNT;
-	erp->rx_pending = lp->rx_ring.hwcnt;
-	erp->tx_pending = lp->tx_ring.hwcnt;
+	erp->rx_pending = 0;
+	erp->tx_pending = 0;
 }
 
 /**
@@ -2106,11 +2328,10 @@ static void
 xemacps_get_wol(struct net_device *ndev, struct ethtool_wolinfo *ewol)
 {
 	struct net_local *lp = netdev_priv(ndev);
-	unsigned long flags;
 	u32 regval;
 
 	ewol->supported = WAKE_MAGIC | WAKE_ARP | WAKE_UCAST | WAKE_MCAST;
-	spin_lock_irqsave(&lp->lock, flags);
+
 	regval = xemacps_read(lp->baseaddr, XEMACPS_WOL_OFFSET);
 	if (regval | XEMACPS_WOL_MCAST_MASK)
 		ewol->wolopts |= WAKE_MCAST;
@@ -2120,7 +2341,7 @@ xemacps_get_wol(struct net_device *ndev, struct ethtool_wolinfo *ewol)
 		ewol->wolopts |= WAKE_UCAST;
 	if (regval | XEMACPS_WOL_MAGIC_MASK)
 		ewol->wolopts |= WAKE_MAGIC;
-	spin_unlock_irqrestore(&lp->lock, flags);
+
 }
 
 /**
@@ -2137,13 +2358,11 @@ static int
 xemacps_set_wol(struct net_device *ndev, struct ethtool_wolinfo *ewol)
 {
 	struct net_local *lp = netdev_priv(ndev);
-	unsigned long flags;
 	u32 regval;
 
 	if (ewol->wolopts & ~(WAKE_MAGIC | WAKE_ARP | WAKE_UCAST | WAKE_MCAST))
 		return -EOPNOTSUPP;
 
-	spin_lock_irqsave(&lp->lock, flags);
 	regval  = xemacps_read(lp->baseaddr, XEMACPS_WOL_OFFSET);
 	regval &= ~(XEMACPS_WOL_MCAST_MASK | XEMACPS_WOL_ARP_MASK |
 		XEMACPS_WOL_SPEREG1_MASK | XEMACPS_WOL_MAGIC_MASK);
@@ -2158,7 +2377,6 @@ xemacps_set_wol(struct net_device *ndev, struct ethtool_wolinfo *ewol)
 		regval |= XEMACPS_WOL_MCAST_MASK;
 
 	xemacps_write(lp->baseaddr, XEMACPS_WOL_OFFSET, regval);
-	spin_unlock_irqrestore(&lp->lock, flags);
 
 	return 0;
 }
@@ -2176,16 +2394,13 @@ xemacps_get_pauseparam(struct net_device *ndev,
 		struct ethtool_pauseparam *epauseparm)
 {
 	struct net_local *lp = netdev_priv(ndev);
-	unsigned long flags;
 	u32 regval;
 
 	epauseparm->autoneg  = 0;
 	epauseparm->rx_pause = 0;
 
-	spin_lock_irqsave(&lp->lock, flags);
 	regval = xemacps_read(lp->baseaddr, XEMACPS_NWCFG_OFFSET);
 	epauseparm->tx_pause = regval & XEMACPS_NWCFG_PAUSEEN_MASK;
-	spin_unlock_irqrestore(&lp->lock, flags);
 }
 
 /**
@@ -2202,17 +2417,14 @@ xemacps_set_pauseparam(struct net_device *ndev,
 		struct ethtool_pauseparam *epauseparm)
 {
 	struct net_local *lp = netdev_priv(ndev);
-	unsigned long flags;
 	u32 regval;
 
 	if (netif_running(ndev)) {
-		printk(KERN_ERR
-			"%s: Please stop netif before apply configruation\n",
-			ndev->name);
+		dev_err(&lp->pdev->dev,
+			"Please stop netif before apply configruation\n");
 		return -EFAULT;
 	}
 
-	spin_lock_irqsave(&lp->lock, flags);
 	regval = xemacps_read(lp->baseaddr, XEMACPS_NWCFG_OFFSET);
 
 	if (epauseparm->tx_pause)
@@ -2221,8 +2433,6 @@ xemacps_set_pauseparam(struct net_device *ndev,
 		regval &= ~XEMACPS_NWCFG_PAUSEEN_MASK;
 
 	xemacps_write(lp->baseaddr, XEMACPS_NWCFG_OFFSET, regval);
-	spin_unlock_irqrestore(&lp->lock, flags);
-
 	return 0;
 }
 
@@ -2236,50 +2446,7 @@ static struct net_device_stats
 	struct net_local *lp = netdev_priv(ndev);
 	struct net_device_stats *nstat = &lp->stats;
 
-	nstat->rx_errors +=
-		(xemacps_read(lp->baseaddr, XEMACPS_RXUNDRCNT_OFFSET) +
-		xemacps_read(lp->baseaddr, XEMACPS_RXOVRCNT_OFFSET) +
-		xemacps_read(lp->baseaddr, XEMACPS_RXJABCNT_OFFSET) +
-		xemacps_read(lp->baseaddr, XEMACPS_RXFCSCNT_OFFSET) +
-		xemacps_read(lp->baseaddr, XEMACPS_RXLENGTHCNT_OFFSET) +
-		xemacps_read(lp->baseaddr, XEMACPS_RXSYMBCNT_OFFSET) +
-		xemacps_read(lp->baseaddr, XEMACPS_RXALIGNCNT_OFFSET) +
-		xemacps_read(lp->baseaddr, XEMACPS_RXRESERRCNT_OFFSET) +
-		xemacps_read(lp->baseaddr, XEMACPS_RXORCNT_OFFSET) +
-		xemacps_read(lp->baseaddr, XEMACPS_RXIPCCNT_OFFSET) +
-		xemacps_read(lp->baseaddr, XEMACPS_RXTCPCCNT_OFFSET) +
-		xemacps_read(lp->baseaddr, XEMACPS_RXUDPCCNT_OFFSET));
-	nstat->rx_length_errors +=
-		(xemacps_read(lp->baseaddr, XEMACPS_RXUNDRCNT_OFFSET) +
-		xemacps_read(lp->baseaddr, XEMACPS_RXOVRCNT_OFFSET) +
-		xemacps_read(lp->baseaddr, XEMACPS_RXJABCNT_OFFSET) +
-		xemacps_read(lp->baseaddr, XEMACPS_RXLENGTHCNT_OFFSET));
-	nstat->rx_over_errors +=
-		xemacps_read(lp->baseaddr, XEMACPS_RXRESERRCNT_OFFSET);
-	nstat->rx_crc_errors +=
-		xemacps_read(lp->baseaddr, XEMACPS_RXFCSCNT_OFFSET);
-	nstat->rx_frame_errors +=
-		xemacps_read(lp->baseaddr, XEMACPS_RXALIGNCNT_OFFSET);
-	nstat->rx_fifo_errors +=
-		xemacps_read(lp->baseaddr, XEMACPS_RXORCNT_OFFSET);
-	nstat->tx_errors +=
-		(xemacps_read(lp->baseaddr, XEMACPS_TXURUNCNT_OFFSET) +
-		xemacps_read(lp->baseaddr, XEMACPS_SNGLCOLLCNT_OFFSET) +
-		xemacps_read(lp->baseaddr, XEMACPS_MULTICOLLCNT_OFFSET) +
-		xemacps_read(lp->baseaddr, XEMACPS_EXCESSCOLLCNT_OFFSET) +
-		xemacps_read(lp->baseaddr, XEMACPS_LATECOLLCNT_OFFSET) +
-		xemacps_read(lp->baseaddr, XEMACPS_CSENSECNT_OFFSET));
-	nstat->tx_aborted_errors +=
-		xemacps_read(lp->baseaddr, XEMACPS_EXCESSCOLLCNT_OFFSET);
-	nstat->tx_carrier_errors +=
-		xemacps_read(lp->baseaddr, XEMACPS_CSENSECNT_OFFSET);
-	nstat->tx_fifo_errors +=
-		xemacps_read(lp->baseaddr, XEMACPS_TXURUNCNT_OFFSET);
-	nstat->collisions +=
-		(xemacps_read(lp->baseaddr, XEMACPS_SNGLCOLLCNT_OFFSET) +
-		xemacps_read(lp->baseaddr, XEMACPS_MULTICOLLCNT_OFFSET) +
-		xemacps_read(lp->baseaddr, XEMACPS_EXCESSCOLLCNT_OFFSET) +
-		xemacps_read(lp->baseaddr, XEMACPS_LATECOLLCNT_OFFSET));
+	xemacps_update_stats((unsigned long)lp);
 	return nstat;
 }
 
@@ -2287,7 +2454,7 @@ static struct ethtool_ops xemacps_ethtool_ops = {
 	.get_settings   = xemacps_get_settings,
 	.set_settings   = xemacps_set_settings,
 	.get_drvinfo    = xemacps_get_drvinfo,
-	.get_link       = ethtool_op_get_link,       /* ethtool default */
+	.get_link       = ethtool_op_get_link, /* ethtool default */
 	.get_ringparam  = xemacps_get_ringparam,
 	.get_wol        = xemacps_get_wol,
 	.set_wol        = xemacps_set_wol,
@@ -2378,7 +2545,7 @@ static int xemacps_ioctl(struct net_device *ndev, struct ifreq *rq, int cmd)
 		return xemacps_hwtstamp_ioctl(ndev, rq, cmd);
 #endif
 	default:
-		printk(KERN_INFO "GEM: ioctl %d not implemented.\n", cmd);
+		dev_info(&lp->pdev->dev, "ioctl %d not implemented.\n", cmd);
 		return -EOPNOTSUPP;
 	}
 
@@ -2389,14 +2556,13 @@ static int xemacps_ioctl(struct net_device *ndev, struct ifreq *rq, int cmd)
  * @pdev: Pointer to platform device structure
  *
  * Return 0 on success, negative value if error
- **/
-static int __init xemacps_probe(struct platform_device *pdev)
+ */
+static int xemacps_probe(struct platform_device *pdev)
 {
 	struct resource *r_mem = NULL;
 	struct resource *r_irq = NULL;
 	struct net_device *ndev;
 	struct net_local *lp;
-	struct device_node *np;
 	const void *prop;
 	u32 regval = 0;
 	int rc = -ENXIO;
@@ -2422,7 +2588,9 @@ static int __init xemacps_probe(struct platform_device *pdev)
 	lp->pdev = pdev;
 	lp->ndev = ndev;
 
-	spin_lock_init(&lp->lock);
+	spin_lock_init(&lp->tx_lock);
+	spin_lock_init(&lp->rx_lock);
+	spin_lock_init(&lp->nwctrlreg_lock);
 
 	lp->baseaddr = ioremap(r_mem->start, (r_mem->end - r_mem->start + 1));
 	if (!lp->baseaddr) {
@@ -2431,148 +2599,138 @@ static int __init xemacps_probe(struct platform_device *pdev)
 		goto err_out_free_netdev;
 	}
 
-	xemacps_reset_hw(lp);
-
-#ifdef DEBUG
-	printk(KERN_INFO "GEM: BASEADDRESS hw: %p virt: %p\n",
+	dev_dbg(&lp->pdev->dev, "BASEADDRESS hw: %p virt: %p\n",
 			(void *)r_mem->start, lp->baseaddr);
-#endif
 
 	ndev->irq = platform_get_irq(pdev, 0);
 
-	rc = request_irq(ndev->irq, xemacps_interrupt, IRQF_SAMPLE_RANDOM,
-		ndev->name, ndev);
-	if (rc) {
-		printk(KERN_ERR "%s: Unable to request IRQ %p, error %d\n",
-		ndev->name, r_irq, rc);
-		goto err_out_iounmap;
-	}
-
-	ndev->netdev_ops	 = &netdev_ops;
-	ndev->watchdog_timeo     = TX_TIMEOUT;
-	ndev->ethtool_ops        = &xemacps_ethtool_ops;
-	ndev->base_addr          = r_mem->start;
-	ndev->features           = NETIF_F_IP_CSUM;
+	ndev->netdev_ops = &netdev_ops;
+	ndev->watchdog_timeo = TX_TIMEOUT;
+	ndev->ethtool_ops = &xemacps_ethtool_ops;
+	ndev->base_addr = r_mem->start;
+	ndev->features = NETIF_F_IP_CSUM | NETIF_F_SG;
 	netif_napi_add(ndev, &lp->napi, xemacps_rx_poll, XEMACPS_NAPI_WEIGHT);
 
 	lp->ip_summed = CHECKSUM_UNNECESSARY;
-#ifdef CONFIG_OF
-	lp->board_type = BOARD_TYPE_ZYNQ;
-#endif
 
 	rc = register_netdev(ndev);
 	if (rc) {
 		dev_err(&pdev->dev, "Cannot register net device, aborting.\n");
-		goto err_out_free_irq;
+		goto err_out_iounmap;
 	}
 
-#ifdef CONFIG_OF
 	if (ndev->irq == 54)
 		lp->enetnum = 0;
 	else
 		lp->enetnum = 1;
 
-	np = of_get_next_parent(lp->pdev->dev.of_node);
-	np = of_get_next_parent(np);
-	prop = of_get_property(np, "compatible", NULL);
-
-	if (prop != NULL) {
-		if ((strcmp((const char *)prop, "xlnx,zynq-ep107")) == 0)
-			lp->board_type = BOARD_TYPE_PEEP;
-		else
-			lp->board_type = BOARD_TYPE_ZYNQ;
-	} else {
-		lp->board_type = BOARD_TYPE_ZYNQ;
+	if (lp->enetnum == 0)
+		lp->aperclk = clk_get_sys("GEM0_APER", NULL);
+	else
+		lp->aperclk = clk_get_sys("GEM1_APER", NULL);
+	if (IS_ERR(lp->aperclk)) {
+		dev_err(&pdev->dev, "APER clock not found.\n");
+		rc = PTR_ERR(lp->aperclk);
+		goto err_out_unregister_netdev;
+	}
+	if (lp->enetnum == 0)
+		lp->devclk = clk_get_sys("GEM0", NULL);
+	else
+		lp->devclk = clk_get_sys("GEM1", NULL);
+	if (IS_ERR(lp->devclk)) {
+		dev_err(&pdev->dev, "Device clock not found.\n");
+		rc = PTR_ERR(lp->devclk);
+		goto err_out_clk_put_aper;
 	}
 
-	if (lp->board_type == BOARD_TYPE_ZYNQ) {
-		prop = of_get_property(lp->pdev->dev.of_node,
-					"xlnx,slcr-div0-1000Mbps", NULL);
-		if (prop)
-			lp->slcr_div0_1000Mbps = (u32)be32_to_cpup(prop);
-		else
-			lp->slcr_div0_1000Mbps = XEMACPS_DFLT_SLCR_DIV0_1000;
-
-		prop = of_get_property(lp->pdev->dev.of_node,
-					"xlnx,slcr-div1-1000Mbps", NULL);
-		if (prop)
-			lp->slcr_div1_1000Mbps = (u32)be32_to_cpup(prop);
-		else
-			lp->slcr_div1_1000Mbps = XEMACPS_DFLT_SLCR_DIV1_1000;
-
-		prop = of_get_property(lp->pdev->dev.of_node,
-					"xlnx,slcr-div0-100Mbps", NULL);
-		if (prop)
-			lp->slcr_div0_100Mbps = (u32)be32_to_cpup(prop);
-		else
-			lp->slcr_div0_100Mbps = XEMACPS_DFLT_SLCR_DIV0_100;
-
-		prop = of_get_property(lp->pdev->dev.of_node,
-					"xlnx,slcr-div1-100Mbps", NULL);
-		if (prop)
-			lp->slcr_div1_100Mbps = (u32)be32_to_cpup(prop);
-		else
-			lp->slcr_div1_100Mbps = XEMACPS_DFLT_SLCR_DIV1_100;
+	rc = clk_prepare_enable(lp->aperclk);
+	if (rc) {
+		dev_err(&pdev->dev, "Unable to enable APER clock.\n");
+		goto err_out_clk_put;
+	}
+	rc = clk_prepare_enable(lp->devclk);
+	if (rc) {
+		dev_err(&pdev->dev, "Unable to enable device clock.\n");
+		goto err_out_clk_dis_aper;
+	}
 
-		prop = of_get_property(lp->pdev->dev.of_node,
-					"xlnx,slcr-div0-10Mbps", NULL);
-		if (prop)
-			lp->slcr_div0_10Mbps = (u32)be32_to_cpup(prop);
-		else
-			lp->slcr_div0_10Mbps = XEMACPS_DFLT_SLCR_DIV0_10;
+	lp->clk_rate_change_nb.notifier_call = xemacps_clk_notifier_cb;
+	lp->clk_rate_change_nb.next = NULL;
+	if (clk_notifier_register(lp->devclk, &lp->clk_rate_change_nb))
+		dev_warn(&pdev->dev,
+			"Unable to register clock notifier.\n");
 
-		prop = of_get_property(lp->pdev->dev.of_node,
-					"xlnx,slcr-div1-10Mbps", NULL);
-		if (prop)
-			lp->slcr_div1_10Mbps = (u32)be32_to_cpup(prop);
-		else
-			lp->slcr_div1_10Mbps = XEMACPS_DFLT_SLCR_DIV1_10;
-	}
 #ifdef CONFIG_XILINX_PS_EMAC_HWTSTAMP
-	if (lp->board_type == BOARD_TYPE_ZYNQ) {
-		prop = of_get_property(lp->pdev->dev.of_node,
-					"xlnx,ptp-enet-clock", NULL);
-		if (prop)
-			lp->ptpenetclk = (u32)be32_to_cpup(prop);
-		else
-			lp->ptpenetclk = 133333328;
-	} else {
-		lp->ptpenetclk = PEEP_TSU_CLK;
-	}
+	prop = of_get_property(lp->pdev->dev.of_node,
+				"xlnx,ptp-enet-clock", NULL);
+	if (prop)
+		lp->ptpenetclk = (u32)be32_to_cpup(prop);
+	else
+		lp->ptpenetclk = 133333328;
 #endif
+
 	lp->phy_node = of_parse_phandle(lp->pdev->dev.of_node,
 						"phy-handle", 0);
-
-	if (lp->board_type == BOARD_TYPE_ZYNQ) {
-		/* Set MDIO clock divider */
-		regval = (MDC_DIV_224 << XEMACPS_NWCFG_MDC_SHIFT_MASK);
-		xemacps_write(lp->baseaddr, XEMACPS_NWCFG_OFFSET, regval);
+	lp->gmii2rgmii_phy_node = of_parse_phandle(lp->pdev->dev.of_node,
+						"gmii2rgmii-phy-handle", 0);
+	rc = of_get_phy_mode(lp->pdev->dev.of_node);
+	if (rc < 0) {
+		dev_err(&lp->pdev->dev, "error in getting phy i/f\n");
+		goto err_out_unregister_clk_notifier;
 	}
-#endif
+
+	lp->phy_interface = rc;
+
+	/* Set MDIO clock divider */
+	regval = (MDC_DIV_224 << XEMACPS_NWCFG_MDC_SHIFT_MASK);
+	xemacps_write(lp->baseaddr, XEMACPS_NWCFG_OFFSET, regval);
+
 
 	regval = XEMACPS_NWCTRL_MDEN_MASK;
 	xemacps_write(lp->baseaddr, XEMACPS_NWCTRL_OFFSET, regval);
 
-	if (xemacps_mii_init(lp) != 0) {
-		printk(KERN_ERR "%s: error in xemacps_mii_init\n", ndev->name);
-		goto err_out_unregister_netdev;
+	rc = xemacps_mii_init(lp);
+	if (rc) {
+		dev_err(&lp->pdev->dev, "error in xemacps_mii_init\n");
+		goto err_out_unregister_clk_notifier;
 	}
 
 	xemacps_update_hwaddr(lp);
+	tasklet_init(&lp->tx_bdreclaim_tasklet, xemacps_tx_poll,
+		     (unsigned long) ndev);
+	tasklet_disable(&lp->tx_bdreclaim_tasklet);
 
 	lp->txtimeout_handler_wq = create_singlethread_workqueue(DRIVER_NAME);
 	INIT_WORK(&lp->txtimeout_reinit, xemacps_reinit_for_txtimeout);
+
 	platform_set_drvdata(pdev, ndev);
+	pm_runtime_set_active(&pdev->dev);
+	pm_runtime_enable(&pdev->dev);
+
+	dev_info(&lp->pdev->dev, "pdev->id %d, baseaddr 0x%08lx, irq %d\n",
+		pdev->id, ndev->base_addr, ndev->irq);
 
-	printk(KERN_INFO "%s, pdev->id %d, baseaddr 0x%08lx, irq %d\n",
-		ndev->name, pdev->id, ndev->base_addr, ndev->irq);
+	rc = request_irq(ndev->irq, xemacps_interrupt, 0,
+		ndev->name, ndev);
+	if (rc) {
+		dev_err(&lp->pdev->dev, "Unable to request IRQ %p, error %d\n",
+				r_irq, rc);
+		goto err_out_unregister_clk_notifier;
+	}
 
 	return 0;
 
+err_out_unregister_clk_notifier:
+	clk_notifier_unregister(lp->devclk, &lp->clk_rate_change_nb);
+	clk_disable_unprepare(lp->devclk);
+err_out_clk_dis_aper:
+	clk_disable_unprepare(lp->aperclk);
+err_out_clk_put:
+	clk_put(lp->devclk);
+err_out_clk_put_aper:
+	clk_put(lp->aperclk);
 err_out_unregister_netdev:
 	unregister_netdev(ndev);
-err_out_free_irq:
-	free_irq(ndev->irq, ndev);
 err_out_iounmap:
 	iounmap(lp->baseaddr);
 err_out_free_netdev:
@@ -2587,16 +2745,14 @@ err_out:
  * @pdev: Pointer to the platform device structure
  *
  * return: 0 on success
- **/
-static int __exit xemacps_remove(struct platform_device *pdev)
+ */
+static int xemacps_remove(struct platform_device *pdev)
 {
 	struct net_device *ndev = platform_get_drvdata(pdev);
 	struct net_local *lp;
 
 	if (ndev) {
 		lp = netdev_priv(ndev);
-		if (lp->phy_dev)
-			phy_disconnect(lp->phy_dev);
 
 		mdiobus_unregister(lp->mii_bus);
 		kfree(lp->mii_bus->irq);
@@ -2604,25 +2760,44 @@ static int __exit xemacps_remove(struct platform_device *pdev)
 		unregister_netdev(ndev);
 		free_irq(ndev->irq, ndev);
 		iounmap(lp->baseaddr);
+
+		clk_notifier_unregister(lp->devclk, &lp->clk_rate_change_nb);
+		if (!pm_runtime_suspended(&pdev->dev)) {
+			clk_disable_unprepare(lp->devclk);
+			clk_disable_unprepare(lp->aperclk);
+		} else {
+			clk_unprepare(lp->devclk);
+			clk_unprepare(lp->aperclk);
+		}
+		clk_put(lp->devclk);
+		clk_put(lp->aperclk);
+
 		free_netdev(ndev);
-		platform_set_drvdata(pdev, NULL);
 	}
 
 	return 0;
 }
 
+#ifdef CONFIG_PM
+#ifdef CONFIG_PM_SLEEP
 /**
  * xemacps_suspend - Suspend event
- * @pdev: Pointer to platform device structure
- * @state: State of the device
+ * @device: Pointer to device structure
  *
  * Return 0
- **/
-static int xemacps_suspend(struct platform_device *pdev, pm_message_t state)
+ */
+static int xemacps_suspend(struct device *device)
 {
+	struct platform_device *pdev = container_of(device,
+			struct platform_device, dev);
 	struct net_device *ndev = platform_get_drvdata(pdev);
+	struct net_local *lp = netdev_priv(ndev);
 
 	netif_device_detach(ndev);
+	if (!pm_runtime_suspended(device)) {
+		clk_disable(lp->devclk);
+		clk_disable(lp->aperclk);
+	}
 	return 0;
 }
 
@@ -2630,15 +2805,82 @@ static int xemacps_suspend(struct platform_device *pdev, pm_message_t state)
  * xemacps_resume - Resume after previous suspend
  * @pdev: Pointer to platform device structure
  *
- * Return 0
- **/
-static int xemacps_resume(struct platform_device *pdev)
+ * Returns 0 on success, errno otherwise.
+ */
+static int xemacps_resume(struct device *device)
 {
+	struct platform_device *pdev = container_of(device,
+			struct platform_device, dev);
 	struct net_device *ndev = platform_get_drvdata(pdev);
+	struct net_local *lp = netdev_priv(ndev);
+
+	if (!pm_runtime_suspended(device)) {
+		int ret;
 
+		ret = clk_enable(lp->aperclk);
+		if (ret)
+			return ret;
+
+		ret = clk_enable(lp->devclk);
+		if (ret) {
+			clk_disable(lp->aperclk);
+			return ret;
+		}
+	}
 	netif_device_attach(ndev);
 	return 0;
 }
+#endif /* ! CONFIG_PM_SLEEP */
+
+#ifdef CONFIG_PM_RUNTIME
+static int xemacps_runtime_idle(struct device *dev)
+{
+	return pm_schedule_suspend(dev, 1);
+}
+
+static int xemacps_runtime_resume(struct device *device)
+{
+	int ret;
+	struct platform_device *pdev = container_of(device,
+			struct platform_device, dev);
+	struct net_device *ndev = platform_get_drvdata(pdev);
+	struct net_local *lp = netdev_priv(ndev);
+
+	ret = clk_enable(lp->aperclk);
+	if (ret)
+		return ret;
+
+	ret = clk_enable(lp->devclk);
+	if (ret) {
+		clk_disable(lp->aperclk);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int xemacps_runtime_suspend(struct device *device)
+{
+	struct platform_device *pdev = container_of(device,
+			struct platform_device, dev);
+	struct net_device *ndev = platform_get_drvdata(pdev);
+	struct net_local *lp = netdev_priv(ndev);
+
+	clk_disable(lp->devclk);
+	clk_disable(lp->aperclk);
+	return 0;
+}
+#endif /* CONFIG_PM_RUNTIME */
+
+static const struct dev_pm_ops xemacps_dev_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(xemacps_suspend, xemacps_resume)
+	SET_RUNTIME_PM_OPS(xemacps_runtime_suspend, xemacps_runtime_resume,
+			xemacps_runtime_idle)
+};
+#define XEMACPS_PM	(&xemacps_dev_pm_ops)
+#else /* ! CONFIG_PM */
+#define XEMACPS_PM	NULL
+#endif /* ! CONFIG_PM */
 
 static struct net_device_ops netdev_ops = {
 	.ndo_open		= xemacps_open,
@@ -2652,59 +2894,25 @@ static struct net_device_ops netdev_ops = {
 	.ndo_get_stats		= xemacps_get_stats,
 };
 
-
-#ifdef CONFIG_OF
-static struct of_device_id xemacps_of_match[] __devinitdata = {
+static struct of_device_id xemacps_of_match[] = {
 	{ .compatible = "xlnx,ps7-ethernet-1.00.a", },
 	{ /* end of table */}
 };
 MODULE_DEVICE_TABLE(of, xemacps_of_match);
-#else
-#define xemacps_of_match NULL
-#endif /* CONFIG_OF */
-
 
 static struct platform_driver xemacps_driver = {
 	.probe   = xemacps_probe,
-	.remove  = __exit_p(xemacps_remove),
-	.suspend = xemacps_suspend,
-	.resume  = xemacps_resume,
+	.remove  = xemacps_remove,
 	.driver  = {
 		.name  = DRIVER_NAME,
 		.owner = THIS_MODULE,
 		.of_match_table = xemacps_of_match,
+		.pm = XEMACPS_PM,
 	},
 };
 
-/**
- * xemacps_init - Initial driver registration call
- *
- * Retunrs whether the driver registration was successful or not.
- **/
-static int __init xemacps_init(void)
-{
-    /*
-     * No kernel boot options used,
-     * so we just need to register the driver.
-     * If we are sure the device is non-hotpluggable, call
-     * platform_driver_probe(&xemacps_driver, xemacps_probe);
-     * to remove run-once probe from memory.
-     * Typical use for system-on-chip processor.
-     */
-	return platform_driver_probe(&xemacps_driver, xemacps_probe);
-}
-
-/**
- * xemacps_exit - Driver unregistration call
- **/
-static void __exit xemacps_exit(void)
-{
-	platform_driver_unregister(&xemacps_driver);
-}
-
-module_init(xemacps_init);
-module_exit(xemacps_exit);
+module_platform_driver(xemacps_driver);
 
 MODULE_AUTHOR("Xilinx, Inc.");
-MODULE_DESCRIPTION(Xilinx Ethernet driver);
-MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Xilinx Ethernet driver");
+MODULE_LICENSE("GPL v2");
-- 
1.7.0

