From 94f9655c2cff589195a8841c226d84a973ac56aa Mon Sep 17 00:00:00 2001
From: Nicolae Rosia <nicolae.rosia@certsign.ro>
Date: Tue, 2 Dec 2014 21:33:34 +0200
Subject: [PATCH 007/456] arm: zynq: xilinx_axidma: fix race condition in
 xilinx_chan_desc_cleanup

xilinx_chan_desc_cleanup uses a spinlock to prevent multiple threads
from accessing the same descriptor. The problem arrises when there
are at least two descriptors in active_list which require callback
and are both done because before callback, the spinlock is released.
Suppose the following:
- Thread 1 acquires the lock, enters the loop with desc pointing
to A and _desc pointing to B. Deletes A from the list, releases the lock,
and makes the callback.
- Thread 2 acquires the lock, enters the loop with desc pointing
to B and _desc pointing to next element. Deletes B from the list,
releases the lock.
- Thread 1 reacquires the lock, does the next iteration of the loop with
desc pointing to B (which was deleted by Thread 2) - race condition.

The proposed solution is to iterate while there are elements in the list,
get the head descriptor and remove it from list before callback.

Signed-off-by: Nicolae Rosia <nicolae.rosia@certsign.ro>
Reported-by: Joseph Zavodny <joseph.zavodny@jhuapl.edu>
Signed-off-by: Michal Simek <michal.simek@xilinx.com>
(cherry picked from commit 2e0eef9126e87ad9371f169f49825f415875641a)
---
 drivers/dma/xilinx/xilinx_axidma.c |    7 +++++--
 1 files changed, 5 insertions(+), 2 deletions(-)

diff --git a/drivers/dma/xilinx/xilinx_axidma.c b/drivers/dma/xilinx/xilinx_axidma.c
index a214c10..98e8482 100644
--- a/drivers/dma/xilinx/xilinx_axidma.c
+++ b/drivers/dma/xilinx/xilinx_axidma.c
@@ -240,15 +240,18 @@ static enum dma_status xilinx_dma_desc_status(struct xilinx_dma_chan *chan,
 
 static void xilinx_chan_desc_cleanup(struct xilinx_dma_chan *chan)
 {
-	struct xilinx_dma_desc_sw *desc, *_desc;
+	struct xilinx_dma_desc_sw *desc;
 	unsigned long flags;
 
 	spin_lock_irqsave(&chan->lock, flags);
 
-	list_for_each_entry_safe(desc, _desc, &chan->active_list, node) {
+	while (!list_empty(&chan->active_list)) {
 		dma_async_tx_callback callback;
 		void *callback_param;
 
+		desc = list_first_entry(&chan->active_list,
+			struct xilinx_dma_desc_sw, node);
+
 		if (xilinx_dma_desc_status(chan, desc) == DMA_IN_PROGRESS)
 			break;
 
-- 
1.7.5.4

