From 91f2e00c7d332be26069776782e1f4120c822e66 Mon Sep 17 00:00:00 2001
From: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date: Wed, 22 May 2013 22:35:10 +0200
Subject: [PATCH 294/509] dma: xilinx: vdma: Use of_property_read_u32() to
 read u32 DT properties

https://github.com/analogdevicesinc/linux.git xcomm_zynq
commit 40b505a42245780e739b10f22eede70c4e52c27d

Replace the of_get_property() calls with of_property_read_u32() DT
properties that store a single unsigned integer.

Return an error when the xlnx,device-id or xlnx,num-fstores property
isn't set.

Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Acked-by: Srikanth Thokala <sthokal@xilinx.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 drivers/dma/xilinx/xilinx_axivdma.c |   39 +++++++++++++++++++---------------
 1 files changed, 22 insertions(+), 17 deletions(-)

diff --git a/drivers/dma/xilinx/xilinx_axivdma.c b/drivers/dma/xilinx/xilinx_axivdma.c
index 7dd06c3..14cdf90 100644
--- a/drivers/dma/xilinx/xilinx_axivdma.c
+++ b/drivers/dma/xilinx/xilinx_axivdma.c
@@ -1050,8 +1050,8 @@ static int xilinx_vdma_chan_probe(struct xilinx_vdma_device *xdev,
 {
 	struct xilinx_vdma_chan *chan;
 	int err;
-	const __be32 *value;
-	u32 width = 0, device_id = 0, flush_fsync = 0;
+	u32 width = 0, device_id, flush_fsync = 0;
+	u32 value;
 
 	/* Alloc channel */
 	chan = devm_kzalloc(xdev->dev, sizeof(*chan), GFP_KERNEL);
@@ -1069,9 +1069,9 @@ static int xilinx_vdma_chan_probe(struct xilinx_vdma_device *xdev,
 	if (of_property_read_bool(node, "xlnx,genlock-mode"))
 		chan->genlock = true;
 
-	value = (int *)of_get_property(node, "xlnx,datawidth", NULL);
-	if (value) {
-		width = be32_to_cpup(value) >> 3; /* Convert bits to bytes */
+	err = of_property_read_u32(node, "xlnx,datawidth", &value);
+	if (!err) {
+		width = value >> 3; /* Convert bits to bytes */
 
 		/* If data width is greater than 8 bytes, DRE is not in hw */
 		if (width > 8)
@@ -1080,9 +1080,11 @@ static int xilinx_vdma_chan_probe(struct xilinx_vdma_device *xdev,
 		chan->feature |= width - 1;
 	}
 
-	value = (int *)of_get_property(node, "xlnx,device-id", NULL);
-	if (value)
-		device_id = be32_to_cpup(value);
+	err = of_property_read_u32(node, "xlnx,device-id", &device_id);
+	if (err < 0) {
+		dev_err(xdev->dev, "missing xlnx,device-id property\n");
+		return err;
+	}
 
 	flush_fsync = (xdev->feature & XILINX_VDMA_FTR_FLUSH_MASK) >>
 			XILINX_VDMA_FTR_FLUSH_SHIFT;
@@ -1203,8 +1205,8 @@ static int xilinx_vdma_of_probe(struct platform_device *op)
 	struct device_node *child, *node;
 	struct resource *io;
 	int err, i;
-	const __be32 *value;
-	int num_frames = 0;
+	int num_frames;
+	u32 value;
 
 	dev_info(&op->dev, "Probing xilinx axi vdma engine\n");
 
@@ -1233,14 +1235,17 @@ static int xilinx_vdma_of_probe(struct platform_device *op)
 		if (of_property_read_bool(node, "xlnx,include-sg"))
 			xdev->feature |= XILINX_VDMA_FTR_HAS_SG;
 
-		value = of_get_property(node, "xlnx,num-fstores", NULL);
-		if (value)
-			num_frames = be32_to_cpup(value);
+		err = of_property_read_u32(node, "xlnx,num-fstores",
+					   &num_frames);
+		if (err < 0) {
+			dev_err(xdev->dev,
+				"missing xlnx,num-fstores property\n");
+			return err;
+		}
 
-		value = of_get_property(node, "xlnx,flush-fsync", NULL);
-		if (value)
-			xdev->feature |= be32_to_cpup(value) <<
-				XILINX_VDMA_FTR_FLUSH_SHIFT;
+		err = of_property_read_u32(node, "xlnx,flush-fsync", &value);
+		if (!err)
+			xdev->feature |= value << XILINX_VDMA_FTR_FLUSH_SHIFT;
 
 		dma_cap_set(DMA_SLAVE, xdev->common.cap_mask);
 		dma_cap_set(DMA_PRIVATE, xdev->common.cap_mask);
-- 
1.7.5.4

