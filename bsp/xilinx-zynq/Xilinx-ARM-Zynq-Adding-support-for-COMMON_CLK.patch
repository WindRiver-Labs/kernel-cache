From 2fc86a7a07492611114b12432e120169b06ff2ec Mon Sep 17 00:00:00 2001
From: Soren Brinkmann <soren.brinkmann@xilinx.com>
Date: Thu, 9 Aug 2012 05:51:07 -0700
Subject: [PATCH 37/50] Xilinx: ARM: Zynq: Adding support for COMMON_CLK

git://git.xilinx.com/linux-xlnx.git master
commit e2cb56241b4b0c905ceeb7796be4990c29d2aef9

Initial support for the common clock framework.
Added implemenatations modelling the PLLs and some of the peripheral clocks
in Zynq.
These implementations do not yet provide full functionality

Signed-off-by: Soren Brinkmann <soren.brinkmann@xilinx.com>
Signed-off-by: Liming Wang <liming.wang@windriver.com>
---
 arch/arm/Kconfig                           |    1 +
 arch/arm/mach-zynq/Makefile                |    2 +-
 arch/arm/mach-zynq/common.c                |   12 +-
 arch/arm/mach-zynq/include/mach/clk.h      |   40 +++
 arch/arm/mach-zynq/include/mach/clkdev.h   |   32 --
 arch/arm/mach-zynq/include/mach/zynq_soc.h |   31 ++
 drivers/clk/Makefile                       |    1 +
 drivers/clk/zynq/Makefile                  |    3 +
 drivers/clk/zynq/clk.c                     |  396 +++++++++++++++++++++
 drivers/clk/zynq/clk621.c                  |  171 +++++++++
 drivers/clk/zynq/peripheral_clk.c          |  515 ++++++++++++++++++++++++++++
 drivers/clk/zynq/pll.c                     |  407 ++++++++++++++++++++++
 12 files changed, 1576 insertions(+), 35 deletions(-)
 create mode 100644 arch/arm/mach-zynq/include/mach/clk.h
 delete mode 100644 arch/arm/mach-zynq/include/mach/clkdev.h
 create mode 100644 drivers/clk/zynq/Makefile
 create mode 100644 drivers/clk/zynq/clk.c
 create mode 100644 drivers/clk/zynq/clk621.c
 create mode 100644 drivers/clk/zynq/peripheral_clk.c
 create mode 100644 drivers/clk/zynq/pll.c

diff --git a/arch/arm/Kconfig b/arch/arm/Kconfig
index 717efd3..229e83a 100644
--- a/arch/arm/Kconfig
+++ b/arch/arm/Kconfig
@@ -1030,6 +1030,7 @@ config ARCH_ZYNQ
 	select ISA_DMA_API
 	select GENERIC_TIME
 	select ARCH_REQUIRE_GPIOLIB
+	select COMMON_CLK
 	select CACHE_L2X0
 	select MIGHT_HAVE_CACHE_L2X0
 	select USE_OF
diff --git a/arch/arm/mach-zynq/Makefile b/arch/arm/mach-zynq/Makefile
index 487abe8..19cd3d2 100644
--- a/arch/arm/mach-zynq/Makefile
+++ b/arch/arm/mach-zynq/Makefile
@@ -3,7 +3,7 @@
 #
 
 # Common support
-obj-y:= common.o timer.o clock.o board_zc702.o platform_devices.o \
+obj-y:= common.o timer.o board_zc702.o platform_devices.o \
 	slcr.o pl330.o scu_gtimer.o
 
 obj-$(CONFIG_SMP) += platsmp.o
diff --git a/arch/arm/mach-zynq/common.c b/arch/arm/mach-zynq/common.c
index 18443de..d41ce07 100644
--- a/arch/arm/mach-zynq/common.c
+++ b/arch/arm/mach-zynq/common.c
@@ -18,7 +18,6 @@
 #include <linux/kernel.h>
 #include <linux/cpumask.h>
 #include <linux/platform_device.h>
-#include <linux/clk.h>
 #include <linux/of_irq.h>
 #include <linux/of_platform.h>
 #include <linux/of.h>
@@ -32,7 +31,7 @@
 #include <asm/hardware/cache-l2x0.h>
 
 #include <mach/zynq_soc.h>
-#include <mach/clkdev.h>
+#include <mach/clk.h>
 #include <mach/slcr.h>
 #include "common.h"
 
@@ -47,6 +46,7 @@ static struct of_device_id zynq_of_bus_ids[] __initdata = {
  */
 void __init xilinx_init_machine(void)
 {
+	zynq_clock_init();
 	of_platform_populate(NULL, zynq_of_bus_ids, NULL, NULL);
 
 #ifdef CONFIG_CACHE_L2X0
@@ -110,6 +110,14 @@ static struct map_desc io_desc[] __initdata = {
 		.length		= (60 * SZ_1K),
 		.type		= MT_DEVICE,
 	},
+
+	/* SLCR space for clock stuff for now */
+	{
+		.virtual	= SLCR_BASE_VIRT,
+		.pfn		= __phys_to_pfn(SLCR_BASE_PHYS),
+		.length		= (3 * SZ_1K),
+		.type		= MT_DEVICE,
+	},
 };
 
 /**
diff --git a/arch/arm/mach-zynq/include/mach/clk.h b/arch/arm/mach-zynq/include/mach/clk.h
new file mode 100644
index 0000000..38e163c
--- /dev/null
+++ b/arch/arm/mach-zynq/include/mach/clk.h
@@ -0,0 +1,40 @@
+/*
+ *  Copyright (C) 2012 Xilinx
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __MACH_CLK__H__
+#define __MACH_CLK__H__
+
+void zynq_clock_init(void);
+
+struct clk *clk_register_zynq_gd1m(const char *name,
+		void __iomem *clkctrl, const char **pnames,
+		spinlock_t *lock);
+struct clk *clk_register_zynq_gd2m(const char *name,
+		void __iomem *clkctrl, const char **pnames, u8 num_parents,
+		spinlock_t *lock);
+struct clk *clk_register_zynq_d2m(const char *name,
+		void __iomem *clkctrl, const char **pnames, spinlock_t *lock);
+struct clk *clk_register_zynq_d1m(const char *name,
+		void __iomem *clkctrl, const char **pnames, u8 num_parents,
+		spinlock_t *lock);
+
+struct clk *clk_register_zynq_pll(const char *name, void __iomem *pllctrl,
+		void __iomem *pllcfg, void __iomem *pllstatus, u8 lockbit,
+		spinlock_t *lock);
+
+struct clk *clk_register_zynq_clk621(const char *name,
+		void __iomem *clkctrl, void __iomem *clk621,
+		unsigned int basediv,
+		unsigned int divadd, const char **pnames, u8 num_parents,
+		spinlock_t *lock);
+#endif
diff --git a/arch/arm/mach-zynq/include/mach/clkdev.h b/arch/arm/mach-zynq/include/mach/clkdev.h
deleted file mode 100644
index 1a0c9ae..0000000
--- a/arch/arm/mach-zynq/include/mach/clkdev.h
+++ /dev/null
@@ -1,32 +0,0 @@
-/*
- * arch/arm/mach-zynq/include/mach/clkdev.h
- *
- *  Copyright (C) 2011 Xilinx, Inc.
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-
-#ifndef __MACH_CLKDEV_H__
-#define __MACH_CLKDEV_H__
-
-#include <mach/clock.h>
-
-struct clk {
-	unsigned long		rate;
-	const struct clk_ops	*ops;
-	const struct icst_params *params;
-	void __iomem		*vcoreg;
-};
-
-#define __clk_get(clk) ({ 1; })
-#define __clk_put(clk) do { } while (0)
-
-#endif
diff --git a/arch/arm/mach-zynq/include/mach/zynq_soc.h b/arch/arm/mach-zynq/include/mach/zynq_soc.h
index 9f71d90..2bda12a 100644
--- a/arch/arm/mach-zynq/include/mach/zynq_soc.h
+++ b/arch/arm/mach-zynq/include/mach/zynq_soc.h
@@ -54,6 +54,37 @@
 
 #define OCM_LOW_BASE			IOMEM(OCM_LOW_VIRT)
 #define OCM_HIGH_BASE			IOMEM(OCM_HIGH_VIRT)
+
+#define SLCR_BASE_VIRT			0xf8000000
+#define SLCR_BASE_PHYS			0xf8000000
+
+#define SLCR_ARMPLL_CTRL		(SLCR_BASE_VIRT | 0x100)
+#define SLCR_DDRPLL_CTRL		(SLCR_BASE_VIRT | 0x104)
+#define SLCR_IOPLL_CTRL			(SLCR_BASE_VIRT | 0x108)
+#define SLCR_PLL_STATUS			(SLCR_BASE_VIRT | 0x10c)
+#define SLCR_ARMPLL_CFG			(SLCR_BASE_VIRT | 0x110)
+#define SLCR_DDRPLL_CFG			(SLCR_BASE_VIRT | 0x114)
+#define SLCR_IOPLL_CFG			(SLCR_BASE_VIRT | 0x118)
+#define SLCR_ARM_CLK_CTRL		(SLCR_BASE_VIRT | 0x120)
+#define SLCR_DDR_CLK_CTRL		(SLCR_BASE_VIRT | 0x124)
+#define SLCR_DCI_CLK_CTRL		(SLCR_BASE_VIRT | 0x128)
+#define SLCR_APER_CLK_CTRL		(SLCR_BASE_VIRT | 0x12c)
+#define SLCR_GEM0_CLK_CTRL		(SLCR_BASE_VIRT | 0x140)
+#define SLCR_GEM1_CLK_CTRL		(SLCR_BASE_VIRT | 0x144)
+#define SLCR_SMC_CLK_CTRL		(SLCR_BASE_VIRT | 0x148)
+#define SLCR_LQSPI_CLK_CTRL		(SLCR_BASE_VIRT | 0x14c)
+#define SLCR_SDIO_CLK_CTRL		(SLCR_BASE_VIRT | 0x150)
+#define SLCR_UART_CLK_CTRL		(SLCR_BASE_VIRT | 0x154)
+#define SLCR_SPI_CLK_CTRL		(SLCR_BASE_VIRT | 0x158)
+#define SLCR_CAN_CLK_CTRL		(SLCR_BASE_VIRT | 0x15c)
+#define SLCR_DBG_CLK_CTRL		(SLCR_BASE_VIRT | 0x164)
+#define SLCR_PCAP_CLK_CTRL		(SLCR_BASE_VIRT | 0x168)
+#define SLCR_FPGA0_CLK_CTRL		(SLCR_BASE_VIRT | 0x170)
+#define SLCR_FPGA1_CLK_CTRL		(SLCR_BASE_VIRT | 0x180)
+#define SLCR_FPGA2_CLK_CTRL		(SLCR_BASE_VIRT | 0x190)
+#define SLCR_FPGA3_CLK_CTRL		(SLCR_BASE_VIRT | 0x1a0)
+#define SLCR_621_TRUE			(SLCR_BASE_VIRT | 0x1c4)
+
 /*
  * Mandatory for CONFIG_LL_DEBUG, UART is mapped virtual = physical
  */
diff --git a/drivers/clk/Makefile b/drivers/clk/Makefile
index 24aa714..d467c5d 100644
--- a/drivers/clk/Makefile
+++ b/drivers/clk/Makefile
@@ -2,3 +2,4 @@
 obj-$(CONFIG_CLKDEV_LOOKUP)	+= clkdev.o
 obj-$(CONFIG_COMMON_CLK)	+= clk.o clk-fixed-rate.o clk-gate.o \
 				   clk-mux.o clk-divider.o clk-fixed-factor.o
+obj-$(CONFIG_ARCH_ZYNQ)		+= zynq/
diff --git a/drivers/clk/zynq/Makefile b/drivers/clk/zynq/Makefile
new file mode 100644
index 0000000..62d931a
--- /dev/null
+++ b/drivers/clk/zynq/Makefile
@@ -0,0 +1,3 @@
+# Zynq clock specific Makefile
+
+obj-$(CONFIG_ARCH_ZYNQ)	+= clk.o clk621.o peripheral_clk.o pll.o
diff --git a/drivers/clk/zynq/clk.c b/drivers/clk/zynq/clk.c
new file mode 100644
index 0000000..444a759
--- /dev/null
+++ b/drivers/clk/zynq/clk.c
@@ -0,0 +1,396 @@
+/*
+ * Zynq clock initalization code
+ * Code is based on clock code from the orion/kirkwood architecture.
+ *
+ *  Copyright (C) 2012 Xilinx
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/clk-provider.h>
+#include <linux/clkdev.h>
+#include <mach/zynq_soc.h>
+#include <mach/clk.h>
+
+static DEFINE_SPINLOCK(armpll_lock);
+static DEFINE_SPINLOCK(ddrpll_lock);
+static DEFINE_SPINLOCK(iopll_lock);
+static DEFINE_SPINLOCK(armclk_lock);
+static DEFINE_SPINLOCK(ddrclk_lock);
+static DEFINE_SPINLOCK(dciclk_lock);
+static DEFINE_SPINLOCK(smcclk_lock);
+static DEFINE_SPINLOCK(lqspiclk_lock);
+static DEFINE_SPINLOCK(pcapclk_lock);
+static DEFINE_SPINLOCK(gem0clk_lock);
+static DEFINE_SPINLOCK(gem1clk_lock);
+static DEFINE_SPINLOCK(fpga0clk_lock);
+static DEFINE_SPINLOCK(fpga1clk_lock);
+static DEFINE_SPINLOCK(fpga2clk_lock);
+static DEFINE_SPINLOCK(fpga3clk_lock);
+static DEFINE_SPINLOCK(canclk_lock);
+static DEFINE_SPINLOCK(sdioclk_lock);
+static DEFINE_SPINLOCK(uartclk_lock);
+static DEFINE_SPINLOCK(spiclk_lock);
+static DEFINE_SPINLOCK(dbgclk_lock);
+static DEFINE_SPINLOCK(aperclk_lock);
+
+
+/* Clock parent arrays */
+static const char *cpu_parents[] __initdata = {"ARMPLL", "ARMPLL",
+	"DDRPLL", "IOPLL"};
+static const char *def_periph_parents[] __initdata = {"IOPLL", "IOPLL",
+	"ARMPLL", "DDRPLL"};
+static const char *gem_parents[] __initdata = {"IOPLL", "IOPLL", "ARMPLL",
+	"DDRPLL", "GEM0EMIO", "GEM0EMIO", "GEM0EMIO", "GEM0EMIO"};
+static const char *dbg_parents[] __initdata = {"IOPLL", "IOPLL", "ARMPLL",
+	"DDRPLL", "DBGEMIOTRC", "DBGEMIOTRC", "DBGEMIOTRC", "DBGEMIOTRC"};
+static const char *dci_parents[] __initdata = {"DDRPLL"};
+static const char *clk621_parents[] __initdata = {"CPU_MASTER_CLK"};
+
+/**
+ * zynq_clkdev_add() - Add a clock device
+ * @con_id: Connection identifier
+ * @dev_id: Device identifier
+ * @clk: Struct clock to associate with given connection and device.
+ *
+ * Create a clkdev entry for a given device/clk
+ */
+static void __init zynq_clkdev_add(const char *con_id, const char *dev_id,
+		struct clk *clk)
+{
+	if (clk_register_clkdev(clk, con_id, dev_id))
+		pr_warn("Adding clkdev failed.");
+}
+
+/**
+ * zynq_clock_init() - Clock initalization
+ *
+ * Register clocks and clock devices with the common clock framework.
+ * Prepare and enable is called here for all clocks. This should be done
+ * by device drivers eventually and completely removed from here
+ */
+void __init zynq_clock_init(void)
+{
+	struct clk *clk;
+
+	pr_info("Zynq clock init\n");
+
+	clk = clk_register_fixed_rate(NULL, "PS_CLK", NULL, CLK_IS_ROOT,
+			33333333);
+	clk = clk_register_zynq_pll("ARMPLL",
+			(void __iomem *)SLCR_ARMPLL_CTRL,
+			(void __iomem *)SLCR_ARMPLL_CFG,
+			(void __iomem *)SLCR_PLL_STATUS, 0, &armpll_lock);
+	clk = clk_register_zynq_pll("DDRPLL",
+			(void __iomem *)SLCR_DDRPLL_CTRL,
+			(void __iomem *)SLCR_DDRPLL_CFG,
+			(void __iomem *)SLCR_PLL_STATUS, 1, &ddrpll_lock);
+	clk = clk_register_zynq_pll("IOPLL",
+			(void __iomem *)SLCR_IOPLL_CTRL,
+			(void __iomem *)SLCR_IOPLL_CFG,
+			(void __iomem *)SLCR_PLL_STATUS, 2, &iopll_lock);
+
+	/* CPU clocks */
+	clk = clk_register_zynq_d1m("CPU_MASTER_CLK",
+			(void __iomem *)SLCR_ARM_CLK_CTRL, cpu_parents, 4,
+			&armclk_lock);
+	clk = clk_register_gate(NULL, "CPU_6OR4X_CLK", "CPU_MASTER_CLK",
+			CLK_SET_RATE_PARENT, (void __iomem *)SLCR_ARM_CLK_CTRL,
+			24, 0, &armclk_lock);
+	zynq_clkdev_add(NULL, "CPU_6OR4X_CLK", clk);
+	clk_prepare(clk);
+	clk_enable(clk);
+	clk = clk_register_fixed_factor(NULL, "CPU_3OR2X_DIV_CLK",
+			"CPU_MASTER_CLK", 0, 1, 2);
+	clk = clk_register_gate(NULL, "CPU_3OR2X_CLK", "CPU_3OR2X_DIV_CLK", 0,
+			(void __iomem *)SLCR_ARM_CLK_CTRL, 25, 0,
+			&armclk_lock);
+	zynq_clkdev_add(NULL, "smp_twd", clk);
+	clk_prepare(clk);
+	clk_enable(clk);
+	clk = clk_register_zynq_clk621("CPU_1X_DIV_CLK",
+		(void __iomem *)SLCR_ARM_CLK_CTRL,
+		(void __iomem *)SLCR_621_TRUE, 4, 2, clk621_parents, 1,
+		&armclk_lock);
+	clk = clk_register_zynq_clk621("CPU_2X_DIV_CLK",
+		(void __iomem *)SLCR_ARM_CLK_CTRL,
+		(void __iomem *)SLCR_621_TRUE, 2, 1, clk621_parents, 1,
+		&armclk_lock);
+	clk = clk_register_gate(NULL, "CPU_2X_CLK", "CPU_2X_DIV_CLK", 0,
+			(void __iomem *)SLCR_ARM_CLK_CTRL, 26, 0,
+			&armclk_lock);
+	clk_prepare(clk);
+	clk_enable(clk);
+	clk = clk_register_gate(NULL, "CPU_1X_CLK", "CPU_1X_DIV_CLK", 0,
+			(void __iomem *)SLCR_ARM_CLK_CTRL, 27, 0,
+			&armclk_lock);
+	zynq_clkdev_add(NULL, "CPU_1X_CLK", clk);
+	clk_prepare(clk);
+	clk_enable(clk);
+	/* DDR clocks */
+	clk = clk_register_divider(NULL, "DDR_2X_DIV_CLK", "DDRPLL", 0,
+			(void __iomem *)SLCR_DDR_CLK_CTRL, 26, 6,
+			CLK_DIVIDER_ONE_BASED, &ddrclk_lock);
+	clk = clk_register_gate(NULL, "DDR_2X_CLK", "DDR_2X_DIV_CLK", 0,
+			(void __iomem *)SLCR_DDR_CLK_CTRL, 1, 0,
+			&ddrclk_lock);
+	clk_prepare(clk);
+	clk_enable(clk);
+	clk = clk_register_divider(NULL, "DDR_3X_DIV_CLK", "DDRPLL", 0,
+			(void __iomem *)SLCR_DDR_CLK_CTRL, 20, 6,
+			CLK_DIVIDER_ONE_BASED, &ddrclk_lock);
+	clk = clk_register_gate(NULL, "DDR_3X_CLK", "DDR_3X_DIV_CLK", 0,
+			(void __iomem *)SLCR_DDR_CLK_CTRL, 0, 0,
+			&ddrclk_lock);
+	clk_prepare(clk);
+	clk_enable(clk);
+	clk = clk_register_zynq_gd2m("DCI_CLK",
+			(void __iomem *)SLCR_DCI_CLK_CTRL, dci_parents, 1,
+			&dciclk_lock);
+	clk_prepare(clk);
+	clk_enable(clk);
+	/* Peripheral clocks */
+	clk = clk_register_zynq_gd1m("SMC_CLK",
+			(void __iomem *)SLCR_SMC_CLK_CTRL, def_periph_parents,
+			&smcclk_lock);
+	clk_prepare(clk);
+	clk_enable(clk);
+	zynq_clkdev_add(NULL, "SMC", clk);
+
+	clk = clk_register_zynq_gd1m("LQSPI_CLK",
+			(void __iomem *)SLCR_LQSPI_CLK_CTRL, def_periph_parents,
+			&lqspiclk_lock);
+	clk_prepare(clk);
+	clk_enable(clk);
+	zynq_clkdev_add(NULL, "LQSPI", clk);
+
+	clk = clk_register_zynq_gd1m("PCAP_CLK",
+			(void __iomem *)SLCR_PCAP_CLK_CTRL, def_periph_parents,
+			&pcapclk_lock);
+	clk_prepare(clk);
+	clk_enable(clk);
+	zynq_clkdev_add(NULL, "PCAP", clk);
+
+	clk = clk_register_zynq_gd2m("GEM0_CLK",
+			(void __iomem *)SLCR_GEM0_CLK_CTRL, gem_parents, 8,
+			&gem0clk_lock);
+	clk_prepare(clk);
+	clk_enable(clk);
+	zynq_clkdev_add(NULL, "GEM0", clk);
+	clk = clk_register_zynq_gd2m("GEM1_CLK",
+			(void __iomem *)SLCR_GEM1_CLK_CTRL, gem_parents, 8,
+			&gem1clk_lock);
+	clk_prepare(clk);
+	clk_enable(clk);
+	zynq_clkdev_add(NULL, "GEM1", clk);
+
+	clk = clk_register_zynq_d2m("FPGA0_CLK",
+			(void __iomem *)SLCR_FPGA0_CLK_CTRL, def_periph_parents,
+			&fpga0clk_lock);
+	clk_prepare(clk);
+	clk_enable(clk);
+	zynq_clkdev_add(NULL, "FPGA0", clk);
+	clk = clk_register_zynq_d2m("FPGA1_CLK",
+			(void __iomem *)SLCR_FPGA1_CLK_CTRL, def_periph_parents,
+			&fpga1clk_lock);
+	clk_prepare(clk);
+	clk_enable(clk);
+	zynq_clkdev_add(NULL, "FPGA1", clk);
+	clk = clk_register_zynq_d2m("FPGA2_CLK",
+			(void __iomem *)SLCR_FPGA2_CLK_CTRL, def_periph_parents,
+			&fpga2clk_lock);
+	clk_prepare(clk);
+	clk_enable(clk);
+	zynq_clkdev_add(NULL, "FPGA2", clk);
+	clk = clk_register_zynq_d2m("FPGA3_CLK",
+			(void __iomem *)SLCR_FPGA3_CLK_CTRL, def_periph_parents,
+			&fpga3clk_lock);
+	clk_prepare(clk);
+	clk_enable(clk);
+	zynq_clkdev_add(NULL, "FPGA3", clk);
+	clk = clk_register_zynq_d2m("CAN_MASTER_CLK",
+			(void __iomem *)SLCR_CAN_CLK_CTRL, def_periph_parents,
+			&canclk_lock);
+
+	clk = clk_register_zynq_d1m("SDIO_MASTER_CLK",
+			(void __iomem *)SLCR_SDIO_CLK_CTRL, def_periph_parents,
+			4, &sdioclk_lock);
+	clk = clk_register_zynq_d1m("UART_MASTER_CLK",
+			(void __iomem *)SLCR_UART_CLK_CTRL, def_periph_parents,
+			4, &uartclk_lock);
+	clk = clk_register_zynq_d1m("SPI_MASTER_CLK",
+			(void __iomem *)SLCR_SPI_CLK_CTRL, def_periph_parents,
+			4, &spiclk_lock);
+	clk = clk_register_zynq_d1m("DBG_MASTER_CLK",
+			(void __iomem *)SLCR_DBG_CLK_CTRL, dbg_parents, 8,
+			&dbgclk_lock);
+
+	clk = clk_register_gate(NULL, "CAN0_CLK", "CAN_MASTER_CLK",
+			CLK_SET_RATE_PARENT, (void __iomem *)SLCR_CAN_CLK_CTRL,
+			0, 0, &canclk_lock);
+	clk_prepare(clk);
+	clk_enable(clk);
+	zynq_clkdev_add(NULL, "CAN0", clk);
+	clk = clk_register_gate(NULL, "CAN1_CLK", "CAN_MASTER_CLK",
+			CLK_SET_RATE_PARENT, (void __iomem *)SLCR_CAN_CLK_CTRL,
+			1, 0, &canclk_lock);
+	clk_prepare(clk);
+	clk_enable(clk);
+	zynq_clkdev_add(NULL, "CAN1", clk);
+
+	clk = clk_register_gate(NULL, "SDIO0_CLK", "SDIO_MASTER_CLK",
+			CLK_SET_RATE_PARENT, (void __iomem *)SLCR_SDIO_CLK_CTRL,
+			0, 0, &sdioclk_lock);
+	clk_prepare(clk);
+	clk_enable(clk);
+	zynq_clkdev_add(NULL, "SDIO0", clk);
+	clk = clk_register_gate(NULL, "SDIO1_CLK", "SDIO_MASTER_CLK",
+			CLK_SET_RATE_PARENT, (void __iomem *)SLCR_SDIO_CLK_CTRL,
+			1, 0, &sdioclk_lock);
+	clk_prepare(clk);
+	clk_enable(clk);
+	zynq_clkdev_add(NULL, "SDIO1", clk);
+
+	clk = clk_register_gate(NULL, "UART0_CLK", "UART_MASTER_CLK",
+			CLK_SET_RATE_PARENT, (void __iomem *)SLCR_UART_CLK_CTRL,
+			0, 0, &uartclk_lock);
+	clk_prepare(clk);
+	clk_enable(clk);
+	zynq_clkdev_add(NULL, "UART0", clk);
+	clk = clk_register_gate(NULL, "UART1_CLK", "UART_MASTER_CLK",
+			CLK_SET_RATE_PARENT, (void __iomem *)SLCR_UART_CLK_CTRL,
+			1, 0, &uartclk_lock);
+	clk_prepare(clk);
+	clk_enable(clk);
+	zynq_clkdev_add(NULL, "UART1", clk);
+
+	clk = clk_register_gate(NULL, "SPI0_CLK", "SPI_MASTER_CLK",
+			CLK_SET_RATE_PARENT, (void __iomem *)SLCR_SPI_CLK_CTRL,
+			0, 0, &spiclk_lock);
+	clk_prepare(clk);
+	clk_enable(clk);
+	zynq_clkdev_add(NULL, "SPI0", clk);
+	clk = clk_register_gate(NULL, "SPI1_CLK", "SPI_MASTER_CLK",
+			CLK_SET_RATE_PARENT, (void __iomem *)SLCR_SPI_CLK_CTRL,
+			1, 0, &spiclk_lock);
+	clk_prepare(clk);
+	clk_enable(clk);
+	zynq_clkdev_add(NULL, "SPI1", clk);
+	clk = clk_register_gate(NULL, "DBGTRC_CLK", "DBG_MASTER_CLK",
+			CLK_SET_RATE_PARENT, (void __iomem *)SLCR_DBG_CLK_CTRL,
+			0, 0, &dbgclk_lock);
+	clk_prepare(clk);
+	clk_enable(clk);
+	zynq_clkdev_add(NULL, "DBGTRC", clk);
+
+	clk = clk_register_gate(NULL, "DBG1X_CLK", "DBG_MASTER_CLK",
+			CLK_SET_RATE_PARENT, (void __iomem *)SLCR_DBG_CLK_CTRL,
+			1, 0, &dbgclk_lock);
+	clk_prepare(clk);
+	clk_enable(clk);
+	zynq_clkdev_add(NULL, "DBG1X", clk);
+
+	/* One gated clock for all APER clocks. */
+	clk = clk_register_gate(NULL, "DMA_CPU2X", "CPU_2X_CLK", 0,
+			(void __iomem *)SLCR_APER_CLK_CTRL, 0, 0,
+			&aperclk_lock);
+	clk_prepare(clk);
+	clk_enable(clk);
+	clk = clk_register_gate(NULL, "USB0_CPU1X", "CPU_1X_CLK", 0,
+			(void __iomem *)SLCR_APER_CLK_CTRL, 2, 0,
+			&aperclk_lock);
+	clk_prepare(clk);
+	clk_enable(clk);
+	clk = clk_register_gate(NULL, "USB1_CPU1X", "CPU_1X_CLK", 0,
+			(void __iomem *)SLCR_APER_CLK_CTRL, 3, 0,
+			&aperclk_lock);
+	clk_prepare(clk);
+	clk_enable(clk);
+	clk = clk_register_gate(NULL, "GEM0_CPU1X", "CPU_1X_CLK", 0,
+			(void __iomem *)SLCR_APER_CLK_CTRL, 6, 0,
+			&aperclk_lock);
+	zynq_clkdev_add(NULL, "GEM0_APER", clk);
+	clk_prepare(clk);
+	clk_enable(clk);
+	clk = clk_register_gate(NULL, "GEM1_CPU1X", "CPU_1X_CLK", 0,
+			(void __iomem *)SLCR_APER_CLK_CTRL, 7, 0,
+			&aperclk_lock);
+	clk_prepare(clk);
+	clk_enable(clk);
+	zynq_clkdev_add(NULL, "GEM1_APER", clk);
+	clk = clk_register_gate(NULL, "SDI0_CPU1X", "CPU_1X_CLK", 0,
+			(void __iomem *)SLCR_APER_CLK_CTRL, 10, 0,
+			&aperclk_lock);
+	clk_prepare(clk);
+	clk_enable(clk);
+	clk = clk_register_gate(NULL, "SDI1_CPU1X", "CPU_1X_CLK", 0,
+			(void __iomem *)SLCR_APER_CLK_CTRL, 11, 0,
+			&aperclk_lock);
+	clk_prepare(clk);
+	clk_enable(clk);
+	clk = clk_register_gate(NULL, "SPI0_CPU1X", "CPU_1X_CLK", 0,
+			(void __iomem *)SLCR_APER_CLK_CTRL, 14, 0,
+			&aperclk_lock);
+	clk_prepare(clk);
+	clk_enable(clk);
+	clk = clk_register_gate(NULL, "SPI1_CPU1X", "CPU_1X_CLK", 0,
+			(void __iomem *)SLCR_APER_CLK_CTRL, 15, 0,
+			&aperclk_lock);
+	clk_prepare(clk);
+	clk_enable(clk);
+	clk = clk_register_gate(NULL, "CAN0_CPU1X", "CPU_1X_CLK", 0,
+			(void __iomem *)SLCR_APER_CLK_CTRL, 16, 0,
+			&aperclk_lock);
+	clk_prepare(clk);
+	clk_enable(clk);
+	clk = clk_register_gate(NULL, "CAN1_CPU1X", "CPU_1X_CLK", 0,
+			(void __iomem *)SLCR_APER_CLK_CTRL, 17, 0,
+			&aperclk_lock);
+	clk_prepare(clk);
+	clk_enable(clk);
+	clk = clk_register_gate(NULL, "I2C0_CPU1X", "CPU_1X_CLK", 0,
+			(void __iomem *)SLCR_APER_CLK_CTRL, 18, 0,
+			&aperclk_lock);
+	clk_prepare(clk);
+	clk_enable(clk);
+	clk = clk_register_gate(NULL, "I2C1_CPU1X", "CPU_1X_CLK", 0,
+			(void __iomem *)SLCR_APER_CLK_CTRL, 19, 0,
+			&aperclk_lock);
+	clk_prepare(clk);
+	clk_enable(clk);
+	clk = clk_register_gate(NULL, "UART0_CPU1X", "CPU_1X_CLK", 0,
+			(void __iomem *)SLCR_APER_CLK_CTRL, 20, 0,
+			&aperclk_lock);
+	clk_prepare(clk);
+	clk_enable(clk);
+	zynq_clkdev_add(NULL, "UART0_APER", clk);
+	clk = clk_register_gate(NULL, "UART1_CPU1X", "CPU_1X_CLK", 0,
+			(void __iomem *)SLCR_APER_CLK_CTRL, 21, 0,
+			&aperclk_lock);
+	zynq_clkdev_add(NULL, "UART1_APER", clk);
+	clk_prepare(clk);
+	clk_enable(clk);
+	clk = clk_register_gate(NULL, "GPIO_CPU1X", "CPU_1X_CLK", 0,
+			(void __iomem *)SLCR_APER_CLK_CTRL, 22, 0,
+			&aperclk_lock);
+	zynq_clkdev_add(NULL, "GPIO_APER", clk);
+	clk_prepare(clk);
+	clk_enable(clk);
+	clk = clk_register_gate(NULL, "LQSPI_CPU1X", "CPU_1X_CLK", 0,
+			(void __iomem *)SLCR_APER_CLK_CTRL, 23, 0,
+			&aperclk_lock);
+	clk_prepare(clk);
+	clk_enable(clk);
+	clk = clk_register_gate(NULL, "SMC_CPU1X", "CPU_1X_CLK", 0,
+			(void __iomem *)SLCR_APER_CLK_CTRL, 24, 0,
+			&aperclk_lock);
+	clk_prepare(clk);
+	clk_enable(clk);
+}
diff --git a/drivers/clk/zynq/clk621.c b/drivers/clk/zynq/clk621.c
new file mode 100644
index 0000000..9c04475
--- /dev/null
+++ b/drivers/clk/zynq/clk621.c
@@ -0,0 +1,171 @@
+/*
+ * A try to model the Zynq CPU_1X and CPU_2X clocks. These clocks depend on the
+ * setting in the clk621_true register. They have the same clock parent
+ * (CPU_MASTER_CLK/CPU_6OR4X) but a common 'divider'.
+ *
+ *  Copyright (C) 2012 Xilinx
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/clk-provider.h>
+#include <linux/err.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+
+/**
+ * struct zynq_clk621
+ * @hw:		Handle between common and hardware-specific interfaces
+ * @clkctrl:	Pointer to clock control register
+ * @clk621:	Pointer to CLK_621_TRUE register
+ * @basediv:	Base clock divider
+ * @divadd:	Clock divider increment for 621 mode
+ * @lock:	Register lock
+ */
+struct zynq_clk621 {
+	struct clk_hw	hw;
+	void __iomem	*clkctrl;
+	void __iomem	*clk621;
+	unsigned int	basediv;
+	unsigned int	divadd;
+	spinlock_t	*lock;
+};
+#define to_zynq_clk621(_hw) container_of(_hw,\
+		struct zynq_clk621, hw);
+#define CLK621_MASK 1
+#define CLK621_SHIFT 0
+
+/**
+ * zynq_clk621_round_rate() - Round a clock frequency
+ * @hw:		Handle between common and hardware-specific interfaces
+ * @rate:	Desired clock frequency
+ * @prate:	Clock frequency of parent clock
+ * Returns frequency closest to @rate the hardware can generate.
+ */
+static long zynq_clk621_round_rate(struct clk_hw *hw, unsigned long rate,
+		unsigned long *prate)
+{
+	unsigned long rerror1;
+	unsigned long rerror2;
+	long rate1;
+	long rate2;
+	struct zynq_clk621 *clk = to_zynq_clk621(hw);
+
+	rate1 = *prate / clk->basediv;
+	rate2 = *prate / (clk->basediv + clk->divadd);
+
+	if (rate1 > rate)
+		rerror1 = rate1 - rate;
+	else
+		rerror1 = rate - rate1;
+	if (rate2 > rate)
+		rerror2 = rate2 - rate;
+	else
+		rerror2 = rate - rate1;
+	if (rerror1 > rerror2)
+		return rate2;
+	else
+		return rate1;
+}
+
+/**
+ * zynq_clk621_recalc_rate() - Recalculate clock frequency
+ * @hw:			Handle between common and hardware-specific interfaces
+ * @parent_rate:	Clock frequency of parent clock
+ * Returns current clock frequency.
+ */
+static unsigned long zynq_clk621_recalc_rate(struct clk_hw *hw,
+		unsigned long parent_rate)
+{
+	unsigned int div;
+	struct zynq_clk621 *clk = to_zynq_clk621(hw);
+
+	div = clk->basediv;
+
+	if ((readl(clk->clk621) & CLK621_MASK) >> CLK621_SHIFT)
+		div += clk->divadd;
+	return parent_rate / div;
+}
+
+
+/**
+ * zynq_clk621_set_rate() - Change clock frequncy
+ * @hw:		Handle between common and hardware-specific interfaces
+ * @rate:	Desired clock frequency
+ * @prate:	Clock frequency of parent clock
+ * Returns 0 on success, negative errno otherwise.
+ *
+ * I doubt we can safely set a new rate. Changing the rate of one of these
+ * clocks will also affect the other. We cannot model this kind of dependency on
+ * the same hierarchical level
+ */
+static int zynq_clk621_set_rate(struct clk_hw *hw, unsigned long rate,
+		unsigned long prate)
+{
+	return -EINVAL;
+}
+
+static struct clk_ops zynq_clk621_ops = {
+	.set_rate = zynq_clk621_set_rate,
+	.round_rate = zynq_clk621_round_rate,
+	.recalc_rate = zynq_clk621_recalc_rate
+};
+
+/**
+ * clk_register_zynq_clk621() - Register a clk621 with the clock framework
+ * @name:	Clock name
+ * @clkctrl:	Pointer to clock control register
+ * @clk621:	Pointer to CLK_621_TRUE register
+ * @basediv:	Base clock divider
+ * @divadd:	Clock divider increment for 621 mode
+ * @pnames:	Array of names of clock parents
+ * @num_parents:Number of parents
+ * @lock:	Register lock
+ * Returns clk_register() return value or errpointer.
+ */
+struct clk *clk_register_zynq_clk621(const char *name,
+		void __iomem *clkctrl, void __iomem *clk621,
+		unsigned int basediv,
+		unsigned int divadd, const char **pnames, u8 num_parents,
+		spinlock_t *lock)
+{
+	struct clk *ret;
+	struct zynq_clk621 *clk;
+	struct clk_init_data initd = {
+		.name = name,
+		.ops = &zynq_clk621_ops,
+		.parent_names = pnames,
+		.num_parents = num_parents,
+		.flags = 0
+	};
+
+	clk = kmalloc(sizeof(*clk), GFP_KERNEL);
+	clk->hw.init = &initd;
+
+	if (!clk) {
+		pr_err("%s: could not allocate Zynq clk\n", __func__);
+		return ERR_PTR(-ENOMEM);
+	}
+
+	/* Populate the struct */
+	clk->clkctrl = clkctrl;
+	clk->clk621 = clk621;
+	clk->basediv = basediv;
+	clk->divadd = divadd;
+	clk->lock = lock;
+
+	ret = clk_register(NULL, &clk->hw);
+
+	if (IS_ERR(ret))
+		kfree(clk);
+
+	return ret;
+}
diff --git a/drivers/clk/zynq/peripheral_clk.c b/drivers/clk/zynq/peripheral_clk.c
new file mode 100644
index 0000000..c3c47ae
--- /dev/null
+++ b/drivers/clk/zynq/peripheral_clk.c
@@ -0,0 +1,515 @@
+/**
+ * Xilinx Zynq Clock Implementations for Peripheral clocks.
+ *
+ * zynq_periphclk_* where * is one of:
+ * d1m: 1 divisor register, muxable
+ * d2m: 2 divisor registers, muxable
+ * gd1m: 1 divisor register, muxable, gateable
+ * gd2m: 2 divisor registers, muxable, gateable
+ *
+ *
+ *  Copyright (C) 2012 Xilinx
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/clk-provider.h>
+#include <linux/err.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+
+/**
+ * struct zynq_periph_clk
+ * @hw:		handle between common and hardware-specific interfaces
+ * @clkctrl:	CLK control register
+ * @lock:	register lock
+ */
+struct zynq_periph_clk {
+	struct clk_hw	hw;
+	void __iomem	*clkctrl;
+	spinlock_t	*lock;
+};
+#define to_zynq_periph_clk(_hw)\
+	container_of(_hw, struct zynq_periph_clk, hw)
+#define CLKCTRL_DIV_MASK	0x3f00
+#define CLKCTRL_DIV_SHIFT	8
+#define CLKCTRL_DIV1_MASK	CLKCTRL_DIV_MASK
+#define CLKCTRL_DIV1_SHIFT	CLKCTRL_DIV_SHIFT
+#define CLKCTRL_DIV2_MASK	0x3f00000
+#define CLKCTRL_DIV2_SHIFT	20
+/*
+ * This is a hack: We have clocks with 0 - 3 bit muxes. If present they start
+ * all in the corresponding clk_ctrl reg. If narrower than 3 bits the bit fiels
+ * is write ignore/read zero. Alternatively we could save the mask and shift
+ * values in the zynq_periph_clk_* struct, like the clk-mux implementation.
+ */
+#define CLKCTRL_CLKSRC_MASK	0x70
+#define CLKCTRL_CLKSRC_SHIFT	4
+#define CLKCTRL_ENABLE_MASK	1
+#define CLKCTRL_ENABLE_SHIFT	0
+
+/* Clock gating ops for peripheral clocks featuring 1 gate */
+/**
+ * zynq_periphclk_gate1_enable - Enable clock
+ * @hw:		Handle between common and hardware-specific interfaces
+ * Returns 0 on success
+ */
+static int zynq_periphclk_gate1_enable(struct clk_hw *hw)
+{
+	u32 reg;
+	unsigned long flags = 0;
+	struct zynq_periph_clk *clk =
+		to_zynq_periph_clk(hw);
+
+	spin_lock_irqsave(clk->lock, flags);
+	reg = readl(clk->clkctrl);
+	reg |= CLKCTRL_ENABLE_MASK;
+	writel(reg, clk->clkctrl);
+	spin_unlock_irqrestore(clk->lock, flags);
+
+	return 0;
+}
+
+/**
+ * zynq_periphclk_gate1_disable - Disable clock
+ * @hw:		Handle between common and hardware-specific interfaces
+ * Returns 0 on success
+ */
+static void zynq_periphclk_gate1_disable(struct clk_hw *hw)
+{
+	u32 reg;
+	unsigned long flags = 0;
+	struct zynq_periph_clk *clk =
+		to_zynq_periph_clk(hw);
+
+	spin_lock_irqsave(clk->lock, flags);
+	reg = readl(clk->clkctrl);
+	reg &= ~CLKCTRL_ENABLE_MASK;
+	writel(reg, clk->clkctrl);
+	spin_unlock_irqrestore(clk->lock, flags);
+}
+
+/**
+ * zynq_periphclk_gate1_is_enabled - Check if a clock is enabled
+ * @hw:		Handle between common and hardware-specific interfaces
+ * Returns 1 if the clock is enabled, 0 otherwise.
+ */
+static int zynq_periphclk_gate1_is_enabled(struct clk_hw *hw)
+{
+	u32 reg;
+	unsigned long flags = 0;
+	struct zynq_periph_clk *clk =
+		to_zynq_periph_clk(hw);
+
+	/* do we need lock for read? */
+	spin_lock_irqsave(clk->lock, flags);
+	reg = readl(clk->clkctrl);
+	spin_unlock_irqrestore(clk->lock, flags);
+
+	return (reg & CLKCTRL_ENABLE_MASK) >> CLKCTRL_ENABLE_SHIFT;
+}
+
+/* Rate set/get functions for peripheral clocks with a single divisor */
+/**
+ * zynq_periphclk_div1_set_rate() - Change clock frequncy
+ * @hw:		Handle between common and hardware-specific interfaces
+ * @rate:	Desired clock frequency
+ * @prate:	Clock frequency of parent clock
+ * Returns 0 on success, negative errno otherwise.
+ */
+static int zynq_periphclk_div1_set_rate(struct clk_hw *hw, unsigned long rate,
+		unsigned long prate)
+{
+	u32 div = DIV_ROUND_CLOSEST(prate, rate);
+	u32 reg;
+	unsigned long flags = 0;
+	struct zynq_periph_clk *clk =
+		to_zynq_periph_clk(hw);
+
+	if ((div < 1) || (div > 0x3f))
+		return -EINVAL;
+
+	spin_lock_irqsave(clk->lock, flags);
+
+	reg = readl(clk->clkctrl);
+	reg &= ~CLKCTRL_DIV_MASK;
+	reg |= div << CLKCTRL_DIV_SHIFT;
+	writel(reg, clk->clkctrl);
+
+	spin_unlock_irqrestore(clk->lock, flags);
+
+	return 0;
+}
+
+/**
+ * zynq_periphclk_div1_round_rate() - Round a clock frequency
+ * @hw:		Handle between common and hardware-specific interfaces
+ * @rate:	Desired clock frequency
+ * @prate:	Clock frequency of parent clock
+ * Returns frequency closest to @rate the hardware can generate.
+ */
+static long zynq_periphclk_div1_round_rate(struct clk_hw *hw,
+		unsigned long rate, unsigned long *prate)
+{
+	long div;
+
+	div = DIV_ROUND_CLOSEST(*prate, rate);
+	if (div < 1)
+		div = 1;
+	if (div > 0x3f)
+		div = 0x3f;
+
+	return *prate / div;
+}
+
+/**
+ * zynq_periphclk_div1_recalc_rate() - Recalculate clock frequency
+ * @hw:			Handle between common and hardware-specific interfaces
+ * @parent_rate:	Clock frequency of parent clock
+ * Returns current clock frequency.
+ */
+static unsigned long zynq_periphclk_div1_recalc_rate(struct clk_hw *hw,
+		unsigned long parent_rate)
+{
+	u32 div;
+	struct zynq_periph_clk *clk =
+		to_zynq_periph_clk(hw);
+
+	/*
+	 * makes probably sense to redundantly save div in the struct
+	 * zynq_periphclk_gd1m to save the IO access. Do we need spinlock for
+	 * read access?
+	 */
+	div = (readl(clk->clkctrl) & CLKCTRL_DIV_MASK) >> CLKCTRL_DIV_SHIFT;
+	if (div < 1)
+		div = 1;
+
+	return parent_rate / div;
+}
+
+/* Rate set/get functions for peripheral clocks with two divisors */
+/**
+ * zynq_periphclk_get_best_divs2 - Calculate best divisors values
+ * @inputrate: Clock input frequency
+ * @targetrate: Desired output frequency
+ * @div1: Value for divisor 1 (return value)
+ * @div2: Value for divisor 2 (return value)
+ * Returns the resulting frequency or zero if no valid divisors are found.
+ *
+ * Calculate the best divisors values to achieve a given target frequency for a
+ * given input frequency for clocks with two dividers fields
+ */
+static unsigned long
+zynq_periphclk_get_best_divs2(const unsigned long inputrate,
+		const unsigned long targetrate, u32 *div1, u32 *div2)
+{
+	u32 d1;
+	u32 d2;
+	unsigned long calcrate;
+	unsigned long bestrate = 0;
+	unsigned int error;
+	unsigned int besterror = ~0;
+
+	/* Probably micro-optimizing, but probably worth thinking about reducing
+	 * the iterations and/or getting rid of some divisions */
+	for (d1 = 1; d1 <= 0x3f; d1++) {
+		d2 = DIV_ROUND_CLOSEST(inputrate / d1, targetrate);
+		if ((d2 < 1) || (d2 > 0x3f))
+			continue;
+		calcrate = (inputrate / d1) / d2;
+
+		if (calcrate > targetrate)
+			error = calcrate - targetrate;
+		else
+			error = targetrate - calcrate;
+
+		if (error < besterror) {
+			*div1 = d1;
+			*div2 = d2;
+			bestrate = calcrate;
+			besterror = error;
+		}
+	}
+
+	return bestrate;
+}
+
+/**
+ * zynq_periphclk_div2_set_rate() - Change clock frequncy
+ * @hw:		Handle between common and hardware-specific interfaces
+ * @rate:	Desired clock frequency
+ * @prate:	Clock frequency of parent clock
+ * Returns 0 on success, negative errno otherwise.
+ */
+static int zynq_periphclk_div2_set_rate(struct clk_hw *hw, unsigned long rate,
+		unsigned long prate)
+{
+	u32 div1;
+	u32 div2;
+	u32 reg;
+	unsigned long flags = 0;
+	struct zynq_periph_clk *clk =
+		to_zynq_periph_clk(hw);
+
+	if (!zynq_periphclk_get_best_divs2(prate, rate, &div1, &div2))
+		return -EINVAL;
+
+	spin_lock_irqsave(clk->lock, flags);
+
+	reg = readl(clk->clkctrl);
+	reg &= ~CLKCTRL_DIV1_MASK;
+	reg &= ~CLKCTRL_DIV2_MASK;
+	reg |= div1 << CLKCTRL_DIV1_SHIFT;
+	reg |= div2 << CLKCTRL_DIV2_SHIFT;
+	writel(reg, clk->clkctrl);
+
+	spin_unlock_irqrestore(clk->lock, flags);
+
+	return 0;
+}
+
+/**
+ * zynq_periphclk_div2_round_rate() - Round a clock frequency
+ * @hw:		Handle between common and hardware-specific interfaces
+ * @rate:	Desired clock frequency
+ * @prate:	Clock frequency of parent clock
+ * Returns frequency closest to @rate the hardware can generate.
+ */
+static long zynq_periphclk_div2_round_rate(struct clk_hw *hw,
+		unsigned long rate, unsigned long *prate)
+{
+	u32 div1;
+	u32 div2;
+	long ret;
+
+	ret = zynq_periphclk_get_best_divs2(*prate, rate, &div1, &div2);
+	if (!ret)
+		return -EINVAL;
+
+	return ret;
+}
+
+/**
+ * zynq_periphclk_div1_recalc_rate() - Recalculate clock frequency
+ * @hw:			Handle between common and hardware-specific interfaces
+ * @parent_rate:	Clock frequency of parent clock
+ * Returns current clock frequency.
+ */
+static unsigned long zynq_periphclk_div2_recalc_rate(struct clk_hw *hw,
+		unsigned long parent_rate)
+{
+	u32 div1;
+	u32 div2;
+	struct zynq_periph_clk *clk =
+		to_zynq_periph_clk(hw);
+
+	/*
+	 * makes probably sense to redundantly save div in the struct
+	 * zynq_periphclk_gd1m to save the IO access. Should we use spinlock for
+	 * reading?
+	 */
+	div1 = (readl(clk->clkctrl) & CLKCTRL_DIV1_MASK) >> CLKCTRL_DIV1_SHIFT;
+	div2 = (readl(clk->clkctrl) & CLKCTRL_DIV2_MASK) >> CLKCTRL_DIV2_SHIFT;
+	if (div1 < 1)
+		div1 = 1;
+	if (div2 < 1)
+		div2 = 1;
+
+	return (parent_rate / div1) / div2;
+}
+
+/* Muxing functions for peripheral clocks */
+/**
+ * zynq_periphclk_set_parent() - Reparent clock
+ * @hw:		Handle between common and hardware-specific interfaces
+ * @index:	Index of new parent.
+ * Returns 0 on success, negative errno otherwise.
+ */
+static int zynq_periphclk_set_parent(struct clk_hw *hw, u8 index)
+{
+	u32 reg;
+	unsigned long flags = 0;
+	struct zynq_periph_clk *clk =
+		to_zynq_periph_clk(hw);
+
+	spin_lock_irqsave(clk->lock, flags);
+
+	reg = readl(clk->clkctrl);
+	reg &= ~CLKCTRL_CLKSRC_MASK;
+	reg |= index << CLKCTRL_CLKSRC_SHIFT;
+	writel(reg, clk->clkctrl);
+
+	spin_unlock_irqrestore(clk->lock, flags);
+
+	return 0;
+}
+
+/**
+ * zynq_periphclk_get_parent() - Reparent clock
+ * @hw:		Handle between common and hardware-specific interfaces
+ * Returns the index of the current clock parent.
+ */
+static u8 zynq_periphclk_get_parent(struct clk_hw *hw)
+{
+	struct zynq_periph_clk *clk =
+		to_zynq_periph_clk(hw);
+
+	return (readl(clk->clkctrl) & CLKCTRL_CLKSRC_MASK) >>
+		CLKCTRL_CLKSRC_SHIFT;
+}
+
+/* Clk register functions */
+/**
+ * clk_register_zynq_common() - Register a clock with the clock framework
+ * @name:	Clock name
+ * @clkctrl:	Pointer to clock control register
+ * @ops:	Pointer to the struct clock_ops
+ * @pnames:	Array of names of clock parents
+ * @num_parents:Number of parents
+ * @lock:	Register lock
+ * Returns clk_register() return value or errpointer.
+ */
+static struct clk *clk_register_zynq_common(const char *name,
+		void __iomem *clkctrl, struct clk_ops *ops,
+		const char **pnames, u8 num_parents, spinlock_t *lock)
+{
+	struct clk *ret;
+	struct zynq_periph_clk *clk;
+	struct clk_init_data initd = {
+		.name = name,
+		.ops = ops,
+		.parent_names = pnames,
+		.num_parents = num_parents,
+		.flags = 0
+	};
+
+	clk = kmalloc(sizeof(*clk), GFP_KERNEL);
+	clk->hw.init = &initd;
+
+	if (!clk) {
+		pr_err("%s: could not allocate Zynq clock\n", __func__);
+		return ERR_PTR(-ENOMEM);
+	}
+
+	/* Populate the struct */
+	clk->clkctrl = clkctrl;
+	clk->lock = lock;
+
+	ret = clk_register(NULL, &clk->hw);
+	if (IS_ERR(ret))
+		kfree(clk);
+
+	return ret;
+}
+
+/* Clock ops structs for the different peripheral clock types */
+static struct clk_ops zynq_periphclk_gd1m_ops = {
+	.enable = zynq_periphclk_gate1_enable,
+	.disable = zynq_periphclk_gate1_disable,
+	.is_enabled = zynq_periphclk_gate1_is_enabled,
+	.set_parent = zynq_periphclk_set_parent,
+	.get_parent = zynq_periphclk_get_parent,
+	.set_rate = zynq_periphclk_div1_set_rate,
+	.round_rate = zynq_periphclk_div1_round_rate,
+	.recalc_rate = zynq_periphclk_div1_recalc_rate
+};
+
+static struct clk_ops zynq_periphclk_gd2m_ops = {
+	.enable = zynq_periphclk_gate1_enable,
+	.disable = zynq_periphclk_gate1_disable,
+	.is_enabled = zynq_periphclk_gate1_is_enabled,
+	.set_parent = zynq_periphclk_set_parent,
+	.get_parent = zynq_periphclk_get_parent,
+	.set_rate = zynq_periphclk_div2_set_rate,
+	.round_rate = zynq_periphclk_div2_round_rate,
+	.recalc_rate = zynq_periphclk_div2_recalc_rate
+};
+
+static struct clk_ops zynq_periphclk_d2m_ops = {
+	.set_parent = zynq_periphclk_set_parent,
+	.get_parent = zynq_periphclk_get_parent,
+	.set_rate = zynq_periphclk_div2_set_rate,
+	.round_rate = zynq_periphclk_div2_round_rate,
+	.recalc_rate = zynq_periphclk_div2_recalc_rate
+};
+
+static struct clk_ops zynq_periphclk_d1m_ops = {
+	.set_parent = zynq_periphclk_set_parent,
+	.get_parent = zynq_periphclk_get_parent,
+	.set_rate = zynq_periphclk_div1_set_rate,
+	.round_rate = zynq_periphclk_div1_round_rate,
+	.recalc_rate = zynq_periphclk_div1_recalc_rate
+};
+
+/* Clock register functions for the different peripheral clock types */
+/**
+ * clk_register_zynq_gd1m() - Register a gd1m clock with the clock framework
+ * @name:	Clock name
+ * @clkctrl:	Pointer to clock control register
+ * @pnames:	Array of names of clock parents
+ * @lock:	Register lock
+ * Returns clk_register() return value or errpointer.
+ */
+struct clk *clk_register_zynq_gd1m(const char *name,
+		void __iomem *clkctrl, const char **pnames, spinlock_t *lock)
+{
+	return clk_register_zynq_common(name, clkctrl, &zynq_periphclk_gd1m_ops,
+			pnames, 4, lock);
+}
+
+/**
+ * clk_register_zynq_gd2m() - Register a gd2m clock with the clock framework
+ * @name:	Clock name
+ * @clkctrl:	Pointer to clock control register
+ * @pnames:	Array of names of clock parents
+ * @num_parents:Number of parents
+ * @lock:	Register lock
+ * Returns clk_register() return value or errpointer.
+ */
+struct clk *clk_register_zynq_gd2m(const char *name,
+		void __iomem *clkctrl, const char **pnames, u8 num_parents,
+		spinlock_t *lock)
+{
+	return clk_register_zynq_common(name, clkctrl, &zynq_periphclk_gd2m_ops,
+			pnames, num_parents, lock);
+}
+
+/**
+ * clk_register_zynq_d2m() - Register a d2m clock with the clock framework
+ * @name:	Clock name
+ * @clkctrl:	Pointer to clock control register
+ * @pnames:	Array of names of clock parents
+ * @lock:	Register lock
+ * Returns clk_register() return value or errpointer.
+ */
+struct clk *clk_register_zynq_d2m(const char *name,
+		void __iomem *clkctrl, const char **pnames, spinlock_t *lock)
+{
+	return clk_register_zynq_common(name, clkctrl, &zynq_periphclk_d2m_ops,
+			pnames, 4, lock);
+}
+
+/**
+ * clk_register_zynq_d1m() - Register a d1m clock with the clock framework
+ * @name:	Clock name
+ * @clkctrl:	Pointer to clock control register
+ * @pnames:	Array of names of clock parents
+ * @num_parents:Number of parents
+ * @lock:	Register lock
+ * Returns clk_register() return value or errpointer.
+ */
+struct clk *clk_register_zynq_d1m(const char *name,
+		void __iomem *clkctrl, const char **pnames, u8 num_parents,
+		spinlock_t *lock)
+{
+	return clk_register_zynq_common(name, clkctrl, &zynq_periphclk_d1m_ops,
+			pnames, num_parents, lock);
+}
diff --git a/drivers/clk/zynq/pll.c b/drivers/clk/zynq/pll.c
new file mode 100644
index 0000000..d65f972
--- /dev/null
+++ b/drivers/clk/zynq/pll.c
@@ -0,0 +1,407 @@
+/**
+ * Clock implementation modeling the PLLs used in Xilinx Zynq.
+ * All PLLs are sourced by the fixed rate PS_CLK.
+ * Rate is adjustable by reprogramming the feedback divider.
+ * PLLs can be bypassed. When the bypass bit is set the PLL_OUT = PS_CLK
+ *
+ * The bypass functionality is modelled as mux. The parent clock is the same in
+ * both cases, but only in one case the input clock is multiplied by fbdiv.
+ * Bypassing the PLL also shuts it down.
+ *
+ * Functions to set a new rate are provided, though they are only compile
+ * tested!!! There is no code calling those, yet.
+ *
+ *  Copyright (C) 2012 Xilinx
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/clk-provider.h>
+#include <linux/err.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+
+/**
+ * struct zynq_pll
+ * @hw:		Handle between common and hardware-specific interfaces
+ * @pllctrl:	PLL control register
+ * @pllcfg:	PLL config register
+ * @pllstatus:	PLL status register
+ * @lock:	Register lock
+ * @lockbit:	Indicates the associated PLL_LOCKED bit in the PLL status
+ *		register.
+ * @bypassed:	Indicates PLL bypass. 1 = bypassed, 0 = PLL output
+ */
+struct zynq_pll {
+	struct clk_hw	hw;
+	void __iomem	*pllctrl;
+	void __iomem	*pllcfg;
+	void __iomem	*pllstatus;
+	spinlock_t	*lock;
+	u8		lockbit;
+	u8		bypassed;
+};
+#define to_zynq_pll(_hw)	container_of(_hw, struct zynq_pll, hw)
+
+/* Register bitfield defines */
+#define PLLCTRL_FBDIV_MASK	0x7f000
+#define PLLCTRL_FBDIV_SHIFT	12
+#define PLLCTRL_BYPASS_MASK	0x10
+#define PLLCTRL_BYPASS_SHIFT	4
+#define PLLCTRL_PWRDWN_MASK	2
+#define PLLCTRL_PWRDWN_SHIFT	1
+#define PLLCTRL_RESET_MASK	1
+#define PLLCTRL_RESET_SHIFT	0
+#define PLLCFG_PLLRES_MASK	0xf0
+#define PLLCFG_PLLRES_SHIFT	4
+#define PLLCFG_PLLCP_MASK	0xf00
+#define PLLCFG_PLLCP_SHIFT	8
+#define PLLCFG_LOCKCNT_MASK	0x3ff000
+#define PLLCFG_LOCKCNT_SHIFT	12
+
+/**
+ * zynq_pll_get_params() - Get PLL parameters for given feedback divider
+ * @fbdiv: Desired feedback divider
+ * @rpll_cp: PLL_CP value (return value)
+ * @rpll_res: PLL_RES value (return value)
+ * @rlock_cnt: LOCK_CNT value (return value)
+ * Returns 0 on success.
+ */
+static int zynq_pll_get_pll_params(unsigned int fbdiv, u32 *rpll_cp,
+		u32 *rpll_res, u32 *rlock_cnt)
+{
+	unsigned int pll_cp;
+	unsigned int pll_res;
+	unsigned int lock_cnt;
+
+	/* Check that fbdiv is in a valid range */
+	if ((fbdiv < 13) || (fbdiv > 66))
+		return -EINVAL;
+
+	/* Set other PLL parameters according to target fbdiv */
+	if ((fbdiv >= 41) && (fbdiv <= 47))
+		pll_cp = 3;
+	else
+		pll_cp = 2;
+
+	if (fbdiv <= 15)
+		pll_res = 6;
+	else if ((fbdiv >= 16) && (fbdiv <= 19))
+		pll_res = 10;
+	else if ((fbdiv >= 31) && (fbdiv <= 40))
+		pll_res = 2;
+	else if (fbdiv >= 48)
+		pll_res = 4;
+	else
+		pll_res = 12;
+
+	switch (fbdiv) {
+	case 13:
+		lock_cnt = 750;
+		break;
+	case 14:
+		lock_cnt = 700;
+		break;
+	case 15:
+		lock_cnt = 650;
+		break;
+	case 16:
+		lock_cnt = 625;
+		break;
+	case 17:
+		lock_cnt = 575;
+		break;
+	case 18:
+		lock_cnt = 550;
+		break;
+	case 19:
+		lock_cnt = 525;
+		break;
+	case 20:
+		lock_cnt = 500;
+		break;
+	case 21:
+		lock_cnt = 475;
+		break;
+	case 22:
+		lock_cnt = 450;
+		break;
+	case 23:
+		lock_cnt = 425;
+		break;
+	case 24:
+	case 25:
+		lock_cnt = 400;
+		break;
+	case 26:
+		lock_cnt = 375;
+		break;
+	case 27:
+	case 28:
+		lock_cnt = 350;
+		break;
+	case 29:
+	case 30:
+		lock_cnt = 325;
+		break;
+	case 31:
+	case 32:
+	case 33:
+		lock_cnt = 300;
+		break;
+	case 34:
+	case 35:
+	case 36:
+		lock_cnt = 275;
+		break;
+	default:
+		lock_cnt = 250;
+		break;
+	}
+
+	*rpll_cp = pll_cp;
+	*rpll_res = pll_res;
+	*rlock_cnt = lock_cnt;
+	return 0;
+}
+
+/**
+ * zynq_pll_set_rate() - Change frequency of a PLL
+ * @hw:		Handle between common and hardware-specific interfaces
+ * @rate:	Desired clock frequency
+ * @prate:	Clock frequency of parent clock
+ * Returns 0 on success, negative errno otherwise.
+ */
+static int zynq_pll_set_rate(struct clk_hw *hw, unsigned long rate,
+		unsigned long prate)
+{
+	struct zynq_pll *clk = to_zynq_pll(hw);
+	u32 reg, fbdiv, pll_res, pll_cp, lock_cnt;
+	unsigned long flags;
+
+	/*
+	 * Set a new rate to the PLL includes bypassing and resetting the PLL,
+	 * hence the connected subsystem will see old_f->bypass_f->new_f. Every
+	 * driver must register clock notifiers for its clock to make sure it is
+	 * asked for rate changes. This way it can make sure it can work with
+	 * new_f and do whatever is necessary to continue working after such a
+	 * change.
+	 */
+	/* Rate change is only possible if not bypassed */
+	if (clk->bypassed)
+		return -EINVAL;
+
+	fbdiv = DIV_ROUND_CLOSEST(rate, prate);
+	if (zynq_pll_get_pll_params(fbdiv, &pll_cp, &pll_res, &lock_cnt))
+		return -EINVAL;
+
+	spin_lock_irqsave(clk->lock, flags);
+
+	/* Write new parameters */
+	reg = readl(clk->pllctrl);
+	reg &= ~PLLCTRL_FBDIV_MASK;
+	reg |= (fbdiv << PLLCTRL_FBDIV_SHIFT) & PLLCTRL_FBDIV_MASK;
+	writel(reg, clk->pllctrl);
+
+	reg = (pll_res << PLLCFG_PLLRES_SHIFT) & PLLCFG_PLLRES_MASK;
+	reg |= (pll_cp << PLLCFG_PLLCP_SHIFT) & PLLCFG_PLLCP_MASK;
+	reg |= (lock_cnt << PLLCFG_LOCKCNT_SHIFT) & PLLCFG_LOCKCNT_MASK;
+	writel(reg, clk->pllcfg);
+
+	/* bypass PLL */
+	reg = readl(clk->pllctrl);
+	reg |= PLLCTRL_BYPASS_MASK;
+	writel(reg, clk->pllctrl);
+	/* reset PLL */
+	reg |= PLLCTRL_RESET_MASK;
+	writel(reg, clk->pllctrl);
+	reg &= ~PLLCTRL_RESET_MASK;
+	writel(reg, clk->pllctrl);
+	/* wait for PLL lock */
+	while (readl(clk->pllstatus) & (1 << clk->lockbit)) ;
+	/* remove bypass */
+	reg &= ~PLLCTRL_BYPASS_MASK;
+	writel(reg, clk->pllctrl);
+
+	spin_unlock_irqrestore(clk->lock, flags);
+
+	return 0;
+}
+
+/**
+ * zynq_pll_round_rate() - Round a clock frequency
+ * @hw:		Handle between common and hardware-specific interfaces
+ * @rate:	Desired clock frequency
+ * @prate:	Clock frequency of parent clock
+ * Returns frequency closest to @rate the hardware can generate.
+ */
+static long zynq_pll_round_rate(struct clk_hw *hw, unsigned long rate,
+		unsigned long *prate)
+{
+	struct zynq_pll *clk = to_zynq_pll(hw);
+	u32 fbdiv;
+
+	if (clk->bypassed)
+		return *prate;
+
+	fbdiv = DIV_ROUND_CLOSEST(rate, *prate);
+	if (fbdiv < 13)
+		fbdiv = 13;
+	else if (fbdiv > 66)
+		fbdiv = 66;
+
+	return *prate * fbdiv;
+}
+
+/**
+ * zynq_pll_recalc_rate() - Recalculate clock frequency
+ * @hw:			Handle between common and hardware-specific interfaces
+ * @parent_rate:	Clock frequency of parent clock
+ * Returns current clock frequency.
+ */
+static unsigned long zynq_pll_recalc_rate(struct clk_hw *hw, unsigned long
+		parent_rate)
+{
+	struct zynq_pll *clk = to_zynq_pll(hw);
+	u32 fbdiv;
+
+	/* makes probably sense to redundantly save fbdiv in the struct
+	 * zynq_pll to save the IO access. */
+	fbdiv = (readl(clk->pllctrl) & PLLCTRL_FBDIV_MASK) >>
+		PLLCTRL_FBDIV_SHIFT;
+
+	return parent_rate * fbdiv;
+}
+
+/**
+ * zynq_pll_set_parent() - Reparent clock
+ * @hw:		Handle between common and hardware-specific interfaces
+ * @index:	Index of new parent.
+ * Returns 0 on success, negative errno otherwise.
+ */
+static int zynq_pll_set_parent(struct clk_hw *hw, u8 index)
+{
+	unsigned long flags = 0;
+	u32 reg;
+	struct zynq_pll *clk = to_zynq_pll(hw);
+
+	/*
+	 * We assume bypassing is a preparation for sleep mode, thus not only
+	 * set the bypass bit, but also power down the whole PLL.
+	 * For this reason, removing the bypass must do the power up sequence
+	 */
+	switch (index) {
+	case 0:
+		/* Power up PLL and wait for lock before removing bypass */
+		spin_lock_irqsave(clk->lock, flags);
+
+		reg = readl(clk->pllctrl);
+		reg &= ~(PLLCTRL_RESET_MASK | PLLCTRL_PWRDWN_MASK);
+		writel(reg, clk->pllctrl);
+		while (readl(clk->pllstatus) & (1 << clk->lockbit)) ;
+
+		reg = readl(clk->pllctrl);
+		reg &= ~PLLCTRL_BYPASS_MASK;
+		writel(reg, clk->pllctrl);
+
+		spin_unlock_irqrestore(clk->lock, flags);
+
+		clk->bypassed = 0;
+		break;
+	case 1:
+		/* Set bypass bit and shut down PLL */
+		spin_lock_irqsave(clk->lock, flags);
+
+		reg = readl(clk->pllctrl);
+		reg |= PLLCTRL_BYPASS_MASK;
+		writel(reg, clk->pllctrl);
+		reg |= PLLCTRL_RESET_MASK | PLLCTRL_PWRDWN_MASK;
+		writel(reg, clk->pllctrl);
+
+		spin_unlock_irqrestore(clk->lock, flags);
+
+		clk->bypassed = 1;
+		break;
+	default:
+		/* Is this correct error code? */
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+/**
+ * zynq_pll_get_parent() - Reparent clock
+ * @hw:		Handle between common and hardware-specific interfaces
+ * Returns the index of the current clock parent.
+ */
+static u8 zynq_pll_get_parent(struct clk_hw *hw)
+{
+	struct zynq_pll *clk = to_zynq_pll(hw);
+
+	return clk->bypassed;
+}
+
+const struct clk_ops zynq_pll_ops = {
+	.set_parent = zynq_pll_set_parent,
+	.get_parent = zynq_pll_get_parent,
+	.set_rate = zynq_pll_set_rate,
+	.round_rate = zynq_pll_round_rate,
+	.recalc_rate = zynq_pll_recalc_rate
+};
+
+/**
+ * clk_register_zynq_pll() - Register PLL with the clock framework
+ * @name:	Clock name
+ * @pllctrl:	Pointer to PLL control register
+ * @pllcfg:	Pointer to PLL configuration register
+ * @pllstatus:	Pointer to PLL status register
+ * @lockbit:	Indicates the associated PLL_LOCKED bit in the PLL status
+ *		register.
+ * @lock:	Register lock
+ * Returns clk_register() return value or errpointer.
+ */
+struct clk *clk_register_zynq_pll(const char *name, void __iomem *pllctrl,
+		void __iomem *pllcfg, void __iomem *pllstatus, u8 lockbit,
+		spinlock_t *lock)
+{
+	struct zynq_pll *clk;
+	const char *pnames[] = {"PS_CLK", "PS_CLK"};
+	struct clk_init_data initd = {
+		.name = name,
+		.ops = &zynq_pll_ops,
+		.parent_names = pnames,
+		.num_parents = 2,
+		.flags = 0
+	};
+
+	clk = kmalloc(sizeof(*clk), GFP_KERNEL);
+	clk->hw.init = &initd;
+
+	if (!clk) {
+		pr_err("%s: could not allocate Zynq PLL clk\n", __func__);
+		return ERR_PTR(-ENOMEM);
+	}
+
+	/* Populate the struct */
+	clk->pllctrl = pllctrl;
+	clk->pllcfg = pllcfg;
+	clk->pllstatus = pllstatus;
+	clk->lockbit = lockbit;
+	clk->lock = lock;
+
+	if (readl(clk->pllctrl) & PLLCTRL_BYPASS_MASK)
+		clk->bypassed = 1;
+	else
+		clk->bypassed = 0;
+
+	return clk_register(NULL, &clk->hw);
+}
-- 
1.7.0

