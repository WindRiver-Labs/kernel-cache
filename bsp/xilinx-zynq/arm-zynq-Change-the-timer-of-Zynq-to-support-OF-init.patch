From 4a8464104d78ee8687113e2e92f34f52f6c4f6b4 Mon Sep 17 00:00:00 2001
From: Zhong Hongbo <hongbo.zhong@windriver.com>
Date: Fri, 20 Jul 2012 09:54:18 +0800
Subject: [PATCH 04/36] arm/zynq: Change the timer of Zynq to support OF
 initialization

SDK: yocto-1.2(http://git.yoctoproject.org/cgit.cgi/meta-zynq/)

Signed-off-by: Vlad Lungu <vlad.lungu@windriver.com>
Integrated-by: Hongbo Zhong <hongbo.zhong@windriver.com>
---
 arch/arm/boot/dts/zc702.dtsi               |   10 +++
 arch/arm/mach-zynq/common.c                |    5 --
 arch/arm/mach-zynq/include/mach/zynq_soc.h |    2 -
 arch/arm/mach-zynq/timer.c                 |  102 ++++++++++++++++++++++++----
 4 files changed, 98 insertions(+), 21 deletions(-)

diff --git a/arch/arm/boot/dts/zc702.dtsi b/arch/arm/boot/dts/zc702.dtsi
index b655f58..b529a68 100644
--- a/arch/arm/boot/dts/zc702.dtsi
+++ b/arch/arm/boot/dts/zc702.dtsi
@@ -37,4 +37,14 @@
 			arm,tag-latency = <3 2 2>;
 			interrupts = <0 34 4>;
 		};
+
+		timer@0xf8001000 {
+			compatible = "xlnx,ps7-ttc-1.00.a";
+			reg = <0xf8001000 0x1000>;
+			interrupts = <0x0 0x0a 0x04>,<0x0 0x0b 0x04>,<0x0 0x0c 0x04>;
+			clock-frequency-timer0 = <111111111>;
+			clock-frequency-timer1 = <111111111>;
+			clock-frequency-timer2 = <111111111>;
+		};
+
 	};
diff --git a/arch/arm/mach-zynq/common.c b/arch/arm/mach-zynq/common.c
index eba134e..0434447 100644
--- a/arch/arm/mach-zynq/common.c
+++ b/arch/arm/mach-zynq/common.c
@@ -78,11 +78,6 @@ void __init xilinx_irq_init(void)
  */
 static struct map_desc io_desc[] __initdata = {
 	{
-		.virtual	= TTC0_VIRT,
-		.pfn		= __phys_to_pfn(TTC0_PHYS),
-		.length		= SZ_4K,
-		.type		= MT_DEVICE,
-	}, {
 		.virtual	= SCU_PERIPH_VIRT,
 		.pfn		= __phys_to_pfn(SCU_PERIPH_PHYS),
 		.length		= SZ_8K,
diff --git a/arch/arm/mach-zynq/include/mach/zynq_soc.h b/arch/arm/mach-zynq/include/mach/zynq_soc.h
index 75e9064..ae95c25 100644
--- a/arch/arm/mach-zynq/include/mach/zynq_soc.h
+++ b/arch/arm/mach-zynq/include/mach/zynq_soc.h
@@ -29,14 +29,12 @@
 #define UART1_VIRT			ZYNQ_ADDR(0x1000)
 
 #define TTC0_PHYS			0xF8001000
-#define TTC0_VIRT			ZYNQ_ADDR(0x2000)
 
 #define SCU_PERIPH_PHYS			0xF8F00000
 #define SCU_PERIPH_VIRT			ZYNQ_ADDR(0x3000)
 
 /* The following are intended for the devices that are mapped early */
 
-#define TTC0_BASE			IOMEM(TTC0_VIRT)
 #define SCU_PERIPH_BASE			IOMEM(SCU_PERIPH_VIRT)
 #define SCU_GIC_CPU_BASE		(SCU_PERIPH_BASE + 0x100)
 #define SCU_GIC_DIST_BASE		(SCU_PERIPH_BASE + 0x1000)
diff --git a/arch/arm/mach-zynq/timer.c b/arch/arm/mach-zynq/timer.c
index c2c96cc..fc3b1c5 100644
--- a/arch/arm/mach-zynq/timer.c
+++ b/arch/arm/mach-zynq/timer.c
@@ -23,6 +23,9 @@
 #include <linux/clocksource.h>
 #include <linux/clockchips.h>
 #include <linux/io.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
 
 #include <asm/mach/time.h>
 #include <mach/zynq_soc.h>
@@ -47,7 +50,6 @@
 #define XTTCPSS_CLOCKSOURCE	0	/* Timer 1 as a generic timekeeping */
 #define XTTCPSS_CLOCKEVENT	1	/* Timer 2 as a clock event */
 
-#define XTTCPSS_TIMER_BASE		TTC0_BASE
 #define XTTCPCC_EVENT_TIMER_IRQ		(IRQ_TIMERCOUNTER0 + 1)
 /*
  * Timer Register Offset Definitions of Timer 1, Increment base address by 4
@@ -65,9 +67,12 @@
 
 #define XTTCPSS_CNT_CNTRL_DISABLE_MASK	0x1
 
-/* Setup the timers to use pre-scaling */
-
-#define TIMER_RATE (PERIPHERAL_CLOCK_RATE / 32)
+/* Setup the timers to use pre-scaling, using a fixed value for now that
+ * will work across most input frequency, but it may need to be more dynamic
+ */
+#define PRESCALE_EXPONENT	11	/* 2 ^ PRESCALE_EXPONENT = PRESCALE */
+#define PRESCALE		2048	/* The exponent must match this */
+#define CLK_CNTRL_PRESCALE (((PRESCALE_EXPONENT - 1) << 1) | 0x1)
 
 /**
  * struct xttcpss_timer - This definition defines local timer structure
@@ -76,6 +81,7 @@
  **/
 struct xttcpss_timer {
 	void __iomem *base_addr;
+	int frequency;
 };
 
 static struct xttcpss_timer timers[2];
@@ -146,11 +152,10 @@ static void __init xttcpss_timer_hardware_init(void)
 	 * with no interrupt and it rolls over at 0xFFFF. Pre-scale
 	   it by 32 also. Let it start running now.
 	 */
-	timers[XTTCPSS_CLOCKSOURCE].base_addr = XTTCPSS_TIMER_BASE;
-
 	__raw_writel(0x0, timers[XTTCPSS_CLOCKSOURCE].base_addr +
 				XTTCPSS_IER_OFFSET);
-	__raw_writel(0x9, timers[XTTCPSS_CLOCKSOURCE].base_addr +
+	__raw_writel(CLK_CNTRL_PRESCALE,
+				timers[XTTCPSS_CLOCKSOURCE].base_addr +
 				XTTCPSS_CLK_CNTRL_OFFSET);
 	__raw_writel(0x10, timers[XTTCPSS_CLOCKSOURCE].base_addr +
 				XTTCPSS_CNT_CNTRL_OFFSET);
@@ -159,12 +164,10 @@ static void __init xttcpss_timer_hardware_init(void)
 	 * is prescaled by 32 using the interval interrupt. Leave it
 	 * disabled for now.
 	 */
-
-	timers[XTTCPSS_CLOCKEVENT].base_addr = XTTCPSS_TIMER_BASE + 4;
-
 	__raw_writel(0x23, timers[XTTCPSS_CLOCKEVENT].base_addr +
 			XTTCPSS_CNT_CNTRL_OFFSET);
-	__raw_writel(0x9, timers[XTTCPSS_CLOCKEVENT].base_addr +
+	__raw_writel(CLK_CNTRL_PRESCALE,
+			timers[XTTCPSS_CLOCKEVENT].base_addr +
 			XTTCPSS_CLK_CNTRL_OFFSET);
 	__raw_writel(0x1, timers[XTTCPSS_CLOCKEVENT].base_addr +
 			XTTCPSS_IER_OFFSET);
@@ -231,7 +234,7 @@ static void xttcpss_set_mode(enum clock_event_mode mode,
 
 	switch (mode) {
 	case CLOCK_EVT_MODE_PERIODIC:
-		xttcpss_set_interval(timer, TIMER_RATE / HZ);
+		xttcpss_set_interval(timer, timer->frequency / HZ);
 		break;
 	case CLOCK_EVT_MODE_ONESHOT:
 	case CLOCK_EVT_MODE_UNUSED:
@@ -271,13 +274,84 @@ static struct clock_event_device xttcpss_clockevent = {
  **/
 static void __init xttcpss_timer_init(void)
 {
+	u32 irq;
+	struct device_node *timer = NULL;
+	void *prop1 = NULL;
+	void *prop2 = NULL;
+	u32 timer_baseaddr;
+	const char *timer_list[] = {
+		"xlnx,ps7-ttc-1.00.a",
+		NULL
+	};
+
+	/* Get the 1st Triple Timer Counter (TTC) block from the device tree
+	 * and use it, but if missing use some defaults for now to help the
+	 * transition, note that the event timer uses the interrupt and it's
+	 * the 2nd TTC hence the +1 for the interrupt and the
+	 * irq_of_parse_and_map(,1)
+	 */
+	timer = of_find_compatible_node(NULL, NULL, timer_list[0]);
+	if (timer) {
+		timer_baseaddr = (u32)of_iomap(timer, 0);
+
+		WARN_ON(!timer_baseaddr);
+		irq = irq_of_parse_and_map(timer, 1);
+		WARN_ON(!irq);
+
+		/* For now, let's play nice and not crash the kernel if the
+		 * device tree was not updated to have all the timer irqs,
+		 * this can be removed at a later date when old device trees
+		 * are gone.
+		 */
+		if (irq == NO_IRQ) {
+			printk(KERN_ERR "Timer irq missing, using default\n");
+			irq = irq_of_parse_and_map(timer, 0) + 1;
+		}
+		prop1 = (void *)of_get_property(timer,
+						"clock-frequency-timer0", NULL);
+		prop2 = (void *)of_get_property(timer,
+						"clock-frequency-timer1", NULL);
+	} else {
+		printk(KERN_ERR "No compatible timer found, using default\n");
+		timer_baseaddr = (u32)ioremap(TTC0_PHYS, SZ_4K);
+		irq = IRQ_TIMERCOUNTER0 + 1;
+	}
+
+	/* If there is clock-frequency property than use it, otherwise use
+	 * a default that may not be the right timing, but might boot the
+	 * kernel, the event timer is the only one that needs the frequency,
+	 * but make them match.
+	 */
+	if (prop1)
+		timers[XTTCPSS_CLOCKSOURCE].frequency = be32_to_cpup(prop1)
+								/ PRESCALE;
+	else {
+		printk(KERN_ERR "No clock-frequency specified for timer\n");
+		timers[XTTCPSS_CLOCKSOURCE].frequency = PERIPHERAL_CLOCK_RATE
+								 / PRESCALE;
+	}
+	if (prop2)
+		timers[XTTCPSS_CLOCKEVENT].frequency = be32_to_cpup(prop2)
+								/ PRESCALE;
+	else {
+		printk(KERN_ERR "No clock-frequency specified for timer\n");
+		timers[XTTCPSS_CLOCKEVENT].frequency = PERIPHERAL_CLOCK_RATE
+							 / PRESCALE;
+	}
+
+	timers[XTTCPSS_CLOCKSOURCE].base_addr = (void __iomem *)timer_baseaddr;
+	timers[XTTCPSS_CLOCKEVENT].base_addr =
+					(void __iomem *)timer_baseaddr + 4;
+
 	xttcpss_timer_hardware_init();
-	clocksource_register_hz(&clocksource_xttcpss, TIMER_RATE);
+	clocksource_register_hz(&clocksource_xttcpss,
+				timers[XTTCPSS_CLOCKSOURCE].frequency);
 
 	/* Calculate the parameters to allow the clockevent to operate using
 	   integer math
 	*/
-	clockevents_calc_mult_shift(&xttcpss_clockevent, TIMER_RATE, 4);
+	clockevents_calc_mult_shift(&xttcpss_clockevent,
+				    timers[XTTCPSS_CLOCKEVENT].frequency, 4);
 
 	xttcpss_clockevent.max_delta_ns =
 		clockevent_delta2ns(0xfffe, &xttcpss_clockevent);
-- 
1.7.9.7

