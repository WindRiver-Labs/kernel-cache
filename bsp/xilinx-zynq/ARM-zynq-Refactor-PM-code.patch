From ff37311ed54173ff492782cfc73c6b259614bdf7 Mon Sep 17 00:00:00 2001
From: Soren Brinkmann <soren.brinkmann@xilinx.com>
Date: Wed, 30 Jul 2014 09:13:08 -0700
Subject: [PATCH 161/182] ARM: zynq: Refactor PM code

This patch comes from:
  https://github.com/Xilinx/linux-xlnx.git

Some PM features are enabled in zynq_pm_late_init() that are independent
of suspend support. Hence the code is refactored to always do the common
PM init.

Signed-off-by: Soren Brinkmann <soren.brinkmann@xilinx.com>
Signed-off-by: Michal Simek <michal.simek@xilinx.com>
(cherry picked from commit 7f4abd2f6e6901490418d452c65163779ff11a8d)
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 arch/arm/mach-zynq/Makefile |    4 +-
 arch/arm/mach-zynq/common.h |    8 ----
 arch/arm/mach-zynq/pm.c     |   91 ++++++++++++++++++++++++-------------------
 3 files changed, 53 insertions(+), 50 deletions(-)

diff --git a/arch/arm/mach-zynq/Makefile b/arch/arm/mach-zynq/Makefile
index 30ae83d..a2fcb6c 100644
--- a/arch/arm/mach-zynq/Makefile
+++ b/arch/arm/mach-zynq/Makefile
@@ -3,12 +3,12 @@
 #
 
 # Common support
-obj-y				:= common.o slcr.o zynq_ocm.o
+obj-y				:= common.o slcr.o zynq_ocm.o pm.o
 
 obj-$(CONFIG_PCI_MSI)           += xaxipcie-msi.o
 obj-$(CONFIG_SMP)		+= headsmp.o platsmp.o
 ORIG_AFLAGS := $(KBUILD_AFLAGS)
 KBUILD_AFLAGS = $(subst -march=armv6k,,$(ORIG_AFLAGS))
 AFLAGS_suspend.o 		+=-Wa,-march=armv7-a -mcpu=cortex-a9
-obj-$(CONFIG_SUSPEND)		+= pm.o suspend.o
+obj-$(CONFIG_SUSPEND)		+= suspend.o
 obj-$(CONFIG_XILINX_AXIPCIE)    += xaxipcie.o
diff --git a/arch/arm/mach-zynq/common.h b/arch/arm/mach-zynq/common.h
index 0b60098..8a3a282 100644
--- a/arch/arm/mach-zynq/common.h
+++ b/arch/arm/mach-zynq/common.h
@@ -45,15 +45,7 @@ extern void zynq_slcr_init_postload_fpga(void);
 extern void __iomem *zynq_slcr_base;
 extern void __iomem *zynq_scu_base;
 
-#ifdef CONFIG_SUSPEND
 int zynq_pm_late_init(void);
-#else
-static inline int zynq_pm_late_init(void)
-{
-	return 0;
-}
-#endif
-
 extern unsigned int zynq_sys_suspend_sz;
 int zynq_sys_suspend(void __iomem *ddrc_base, void __iomem *slcr_base);
 
diff --git a/arch/arm/mach-zynq/pm.c b/arch/arm/mach-zynq/pm.c
index 0524c15..1e03589 100644
--- a/arch/arm/mach-zynq/pm.c
+++ b/arch/arm/mach-zynq/pm.c
@@ -44,6 +44,8 @@
 #define DDRC_SELFREFRESH_MASK	BIT(12)
 
 static void __iomem *ddrc_base;
+
+#ifdef CONFIG_SUSPEND
 static void __iomem *ocm_base;
 
 static int zynq_pm_prepare_late(void)
@@ -112,30 +114,6 @@ static const struct platform_suspend_ops zynq_pm_ops = {
 };
 
 /**
- * zynq_pm_ioremap() - Create IO mappings
- * @comp:	DT compatible string
- * Returns a pointer to the mapped memory or NULL.
- *
- * Remap the memory region for a compatible DT node.
- */
-static void __iomem *zynq_pm_ioremap(const char *comp)
-{
-	struct device_node *np;
-	void __iomem *base = NULL;
-
-	np = of_find_compatible_node(NULL, NULL, comp);
-	if (np) {
-		base = of_iomap(np, 0);
-		of_node_put(np);
-	} else {
-		pr_warn("%s: no compatible node found for '%s'\n", __func__,
-				comp);
-	}
-
-	return base;
-}
-
-/**
  * zynq_pm_remap_ocm() - Remap OCM
  * Returns a pointer to the mapped memory or NULL.
  *
@@ -192,6 +170,53 @@ static void __iomem *zynq_pm_remap_ocm(void)
 	return base;
 }
 
+static void zynq_pm_suspend_init(void)
+{
+	ocm_base = zynq_pm_remap_ocm();
+	if (!ocm_base) {
+		pr_warn("%s: Unable to map OCM.\n", __func__);
+	} else {
+		/*
+		 * Copy code to suspend system into OCM. The suspend code
+		 * needs to run from OCM as DRAM may no longer be available
+		 * when the PLL is stopped.
+		 */
+		memcpy((__force void *)ocm_base, &zynq_sys_suspend,
+			zynq_sys_suspend_sz);
+		flush_icache_range((unsigned long)ocm_base,
+			(unsigned long)(ocm_base) + zynq_sys_suspend_sz);
+	}
+
+	suspend_set_ops(&zynq_pm_ops);
+}
+#else	/* CONFIG_SUSPEND */
+static void zynq_pm_suspend_init(void) { };
+#endif	/* CONFIG_SUSPEND */
+
+/**
+ * zynq_pm_ioremap() - Create IO mappings
+ * @comp:	DT compatible string
+ * Returns a pointer to the mapped memory or NULL.
+ *
+ * Remap the memory region for a compatible DT node.
+ */
+static void __iomem *zynq_pm_ioremap(const char *comp)
+{
+	struct device_node *np;
+	void __iomem *base = NULL;
+
+	np = of_find_compatible_node(NULL, NULL, comp);
+	if (np) {
+		base = of_iomap(np, 0);
+		of_node_put(np);
+	} else {
+		pr_warn("%s: no compatible node found for '%s'\n", __func__,
+				comp);
+	}
+
+	return base;
+}
+
 int __init zynq_pm_late_init(void)
 {
 	u32 reg;
@@ -214,22 +239,8 @@ int __init zynq_pm_late_init(void)
 		writel(reg, ddrc_base + DDRC_DRAM_PARAM_REG3_OFFS);
 	}
 
-	ocm_base = zynq_pm_remap_ocm();
-	if (!ocm_base) {
-		pr_warn("%s: Unable to map OCM.\n", __func__);
-	} else {
-		/*
-		 * Copy code to suspend system into OCM. The suspend code
-		 * needs to run from OCM as DRAM may no longer be available
-		 * when the PLL is stopped.
-		 */
-		memcpy((__force void *)ocm_base, &zynq_sys_suspend,
-			zynq_sys_suspend_sz);
-		flush_icache_range((unsigned long)ocm_base,
-			(unsigned long)(ocm_base) + zynq_sys_suspend_sz);
-	}
-
-	suspend_set_ops(&zynq_pm_ops);
+	/* set up suspend */
+	zynq_pm_suspend_init();
 
 	return 0;
 }
-- 
1.7.5.4

