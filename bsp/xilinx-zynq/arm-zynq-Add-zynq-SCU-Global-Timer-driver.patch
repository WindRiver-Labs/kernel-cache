From f5917a24e97d8add4d21ea6cff2c8fb4b3fa5238 Mon Sep 17 00:00:00 2001
From: Zhong Hongbo <hongbo.zhong@windriver.com>
Date: Fri, 13 Jul 2012 12:53:10 +0800
Subject: [PATCH 10/36] arm/zynq: Add zynq SCU Global Timer driver

SDK: yocto-1.2(http://git.yoctoproject.org/cgit.cgi/meta-zynq/)

Signed-off-by: Vlad Lungu <vlad.lungu@windriver.com>
Integrated-by: Hongbo Zhong <hongbo.zhong@windriver.com>
---
 arch/arm/mach-zynq/Makefile                |    2 +-
 arch/arm/mach-zynq/include/mach/zynq_soc.h |    1 +
 arch/arm/mach-zynq/platform_devices.c      |   18 ++
 arch/arm/mach-zynq/scu_gtimer.c            |  320 ++++++++++++++++++++++++++++
 4 files changed, 340 insertions(+), 1 deletion(-)
 create mode 100644 arch/arm/mach-zynq/scu_gtimer.c

diff --git a/arch/arm/mach-zynq/Makefile b/arch/arm/mach-zynq/Makefile
index 3c3b0e4..aaf0ab7 100644
--- a/arch/arm/mach-zynq/Makefile
+++ b/arch/arm/mach-zynq/Makefile
@@ -4,6 +4,6 @@
 
 # Common support
 obj-y:= common.o timer.o clock.o board_zc702.o platform_devices.o \
-	slcr.o pl330.o
+	slcr.o pl330.o scu_gtimer.o
 
 obj-$(CONFIG_SMP) += platsmp.o
diff --git a/arch/arm/mach-zynq/include/mach/zynq_soc.h b/arch/arm/mach-zynq/include/mach/zynq_soc.h
index f0d3040..9f71d90 100644
--- a/arch/arm/mach-zynq/include/mach/zynq_soc.h
+++ b/arch/arm/mach-zynq/include/mach/zynq_soc.h
@@ -39,6 +39,7 @@
 
 #define SCU_PERIPH_BASE			IOMEM(SCU_PERIPH_VIRT)
 #define SCU_GIC_CPU_BASE		(SCU_PERIPH_BASE + 0x100)
+#define SCU_GLOBAL_TIMER_BASE		(SCU_PERIPH_BASE + 0x200)
 #define SCU_GIC_DIST_BASE		(SCU_PERIPH_BASE + 0x1000)
 
 #define BOOT_ADDR_OFFSET		0xEFF0
diff --git a/arch/arm/mach-zynq/platform_devices.c b/arch/arm/mach-zynq/platform_devices.c
index a762e5f..372413d 100644
--- a/arch/arm/mach-zynq/platform_devices.c
+++ b/arch/arm/mach-zynq/platform_devices.c
@@ -17,6 +17,7 @@
 #include <linux/device.h>
 #include <linux/module.h>
 #include <asm/pmu.h>
+#include <asm/io.h>
 #include <mach/zynq_soc.h>
 #include <mach/irqs.h>
 #include <mach/dma.h>
@@ -91,10 +92,27 @@ static struct platform_device xilinx_pmu_device = {
 	.resource	= &xilinx_pmu_resource,
 };
 
+static struct resource zynq_scugtimer_resource[] = {
+	[0] = {
+		.start = SCU_GLOBAL_TIMER_BASE,
+		.end   = SCU_GLOBAL_TIMER_BASE + 0x400 - 1,
+		.flags = IORESOURCE_MEM,
+	},
+};
+
+struct platform_device xilinx_scutimer_device = {
+	.name = "xscugtimer",
+	.id = 0,
+	.num_resources	  = ARRAY_SIZE(zynq_scugtimer_resource),
+	.resource	  = zynq_scugtimer_resource,
+	.dev.platform_data = NULL,
+};
+
 /* add all platform devices to the following table so they
  * will be registered
  */
 struct platform_device *xilinx_pdevices[] __initdata = {
+	&xilinx_scutimer_device,
 	&dmac_device0,
 	/* &dmac_device1, */
 #ifdef CONFIG_XILINX_TEST
diff --git a/arch/arm/mach-zynq/scu_gtimer.c b/arch/arm/mach-zynq/scu_gtimer.c
new file mode 100644
index 0000000..e76409d
--- /dev/null
+++ b/arch/arm/mach-zynq/scu_gtimer.c
@@ -0,0 +1,320 @@
+/*
+ * Xilinx SCU Global Timer driver
+ *
+ * The only purpose for this driver is to create sysfs attributes under the
+ * driver that allow all the registers of the SCU Global timer to be read and
+ * written from user space easily.
+ *
+ * The attributes will be visible in the /sys/devices/platform/xscugtimer.0
+ * and this driver is a prototype to see if it really meets the needs.
+ *
+ * The counter and compare registers are provided as 32 bit attributes which
+ * map to the hardware registers and as 64 bit attributes for easier use.
+ *
+ * Copyright (c) 2011 Xilinx Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program; if not, write to the Free
+ * Software Foundation, Inc., 675 Mass Ave, Cambridge, MA
+ * 02139, USA.
+ */
+
+#include <linux/export.h>
+#include <linux/platform_device.h>
+#include <linux/io.h>
+
+#include <mach/zynq_soc.h>
+
+#define DRIVER_NAME "xscugtimer"
+
+#define XSCUGTIMER_COUNTER0_OFFSET		0x00 /* Control Register */
+#define XSCUGTIMER_COUNTER1_OFFSET		0x04 /* Control Register */
+#define XSCUGTIMER_CONTROL_OFFSET		0x08 /* Control Register */
+#define XSCUGTIMER_IRQ_STATUS_OFFSET		0x0C /* Control Register */
+#define XSCUGTIMER_COMPARE0_OFFSET		0x10 /* Control Register */
+#define XSCUGTIMER_COMPARE1_OFFSET		0x14 /* Control Register */
+#define XSCUGTIMER_AUTOINCR_OFFSET		0x18 /* Control Register */
+
+/************ Constant Definitions *************/
+
+/* There can only ever be one instance of this device since there is only
+ * one global timer in one SCU. No spin lock is being used as there is no
+ * read modify writes happening at this point since it's real simple.
+ */
+static void __iomem *base_address;
+
+/*
+ * Register read/write access routines
+ */
+#define xscugtimer_writereg(offset, val) \
+		__raw_writel(val, base_address + offset)
+#define xscugtimer_readreg(offset) \
+		__raw_readl(base_address + offset)
+
+/* For now, the following macro is used to generate unique functions for each
+ * register in the SCU global timer that correlate to sysfs attributes. This
+ * should be able to be done without the macro by using the attr input in a
+ * function but it was not working. This is a bit ugly as a get and set function
+ * is generated for each attribute.
+ */
+
+/**
+ * xscugtimer_set_xxxx_reg() - This function sets a register in the timer
+ *	with the given value.
+ * @dev:	Pointer to the device structure.
+ * @attr:	Pointer to the device attribute structure.
+ * @buf:	Pointer to the buffer location for the configuration
+ *		data.
+ * @size:	The number of bytes used from the buffer
+ * returns:	negative error if the string could not be converted
+ *		or the size of the buffer.
+ *
+ **/
+/**
+ * xscugtimer_get_xxxx_reg() - The function returns the value read from the timer
+ * @dev:	Pointer to the device structure.
+ * @attr:	Pointer to the device attribute structure.
+ * @buf:	Pointer to the buffer location for the configuration
+ *		data.
+ * returns:	Size of the buffer.
+ *
+ **/
+#define xscugtimer_config_attr(name, offset)				\
+static ssize_t xscugtimer_set_##name##_reg(struct device *dev,		\
+				     struct device_attribute *attr,	\
+				     const char *buf, size_t size)	\
+{									\
+	unsigned long reg;						\
+	int status;							\
+									\
+	status = strict_strtoul(buf, 16, &reg);				\
+	if (status)							\
+		return status;						\
+									\
+	xscugtimer_writereg(offset, reg);				\
+	return size;							\
+}									\
+static ssize_t xscugtimer_get_##name##_reg(struct device *dev,		\
+	struct device_attribute *attr,					\
+	char *buf)							\
+{									\
+	u32 reg;							\
+	int status;							\
+									\
+	reg = xscugtimer_readreg(offset);				\
+	status = sprintf(buf, "%X\n", reg);				\
+									\
+	return status;							\
+}									\
+static DEVICE_ATTR(name, 0644, xscugtimer_get_##name##_reg,		\
+				xscugtimer_set_##name##_reg);
+
+/**
+ * xscugtimer_set64_xxxx_reg() - This function sets a register in the timer
+ *				 with the given 64 bit value.
+ * @dev:	Pointer to the device structure.
+ * @attr:	Pointer to the device attribute structure.
+ * @buf:	Pointer to the buffer location for the configuration
+ *		data.
+ * @size:	The number of bytes used from the buffer
+ * returns:	negative error if the string could not be converted
+ *		or the size of the buffer.
+ *
+ **/
+/**
+ * xscugtimer_get64_xxxx_reg() - The function returns the 64 bit value read
+ *				 from the timer register
+ * @dev:	Pointer to the device structure.
+ * @attr:	Pointer to the device attribute structure.
+ * @buf:	Pointer to the buffer location for the configuration
+ *		data.
+ * returns:	Size of the buffer.
+ *
+ **/
+#define xscugtimer_config_attr64(name, offset)				\
+static ssize_t xscugtimer_set_##name##64_reg(struct device *dev,	\
+				     struct device_attribute *attr,	\
+				     const char *buf, size_t size)	\
+{									\
+	unsigned long long reg;						\
+	int status;							\
+									\
+	status = strict_strtoull(buf, 16, &reg);			\
+	if (status)							\
+		return status;						\
+									\
+	xscugtimer_writereg(offset + 4, (reg >> 32));			\
+	xscugtimer_writereg(offset, reg & 0xFFFFFFFF);			\
+	return size;							\
+}									\
+static ssize_t xscugtimer_get_##name##64_reg(struct device *dev,	\
+	struct device_attribute *attr,					\
+	char *buf)							\
+{									\
+	unsigned long long reg;						\
+	int status;							\
+									\
+	reg = (((unsigned long long)xscugtimer_readreg(offset + 4) << 32) | \
+			xscugtimer_readreg(offset));			\
+	status = sprintf(buf, "%llX\n", reg);				\
+									\
+	return status;							\
+}									\
+static DEVICE_ATTR(name, 0644, xscugtimer_get_##name##64_reg,		\
+				xscugtimer_set_##name##64_reg);
+
+
+/* create the sysfs attributes for each SCU global timer register, the
+ * counter and compare registers are provided as 32 attributes which map
+ * to the hardware and 64 bit attributes for easier use
+ */
+xscugtimer_config_attr64(counter, XSCUGTIMER_COUNTER0_OFFSET);
+xscugtimer_config_attr(counter0, XSCUGTIMER_COUNTER0_OFFSET);
+xscugtimer_config_attr(counter1, XSCUGTIMER_COUNTER1_OFFSET);
+xscugtimer_config_attr(control, XSCUGTIMER_CONTROL_OFFSET);
+xscugtimer_config_attr(irq_status, XSCUGTIMER_IRQ_STATUS_OFFSET);
+xscugtimer_config_attr64(compare, XSCUGTIMER_COMPARE0_OFFSET);
+xscugtimer_config_attr(compare0, XSCUGTIMER_COMPARE0_OFFSET);
+xscugtimer_config_attr(compare1, XSCUGTIMER_COMPARE1_OFFSET);
+xscugtimer_config_attr(autoincr, XSCUGTIMER_AUTOINCR_OFFSET);
+
+static const struct attribute *xscugtimer_attrs[] = {
+	&dev_attr_counter.attr,
+	&dev_attr_counter0.attr,
+	&dev_attr_counter1.attr,
+	&dev_attr_control.attr,
+	&dev_attr_irq_status.attr,
+	&dev_attr_compare.attr,
+	&dev_attr_compare0.attr,
+	&dev_attr_compare1.attr,
+	&dev_attr_autoincr.attr,
+	NULL,
+};
+
+static const struct attribute_group xscugtimer_attr_group = {
+	.attrs = (struct attribute **) xscugtimer_attrs,
+};
+
+/**
+ * xscugtimer_drv_probe -  Probe call for the device.
+ *
+ * @pdev:	handle to the platform device structure.
+ *
+ * It does all the memory allocation and registration for the device.
+ * Returns 0 on success, negative error otherwise.
+ **/
+static int __devinit xscugtimer_drv_probe(struct platform_device *pdev)
+{
+	struct resource *res;
+	int ret = -ENOMEM;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (res == NULL) {
+		dev_err(&pdev->dev, "cannot find IO resource\n");
+		ret = -ENOENT;
+		goto failed0;
+	}
+
+	if (!request_mem_region(res->start, resource_size(res), pdev->name)) {
+		dev_err(&pdev->dev, "Couldn't lock memory region at %Lx\n",
+			(unsigned long long) res->start);
+		ret = -EBUSY;
+		goto failed0;
+	}
+
+	base_address = ioremap(res->start, resource_size(res));
+	if (!base_address) {
+		dev_err(&pdev->dev, "ioremap() failed\n");
+		goto failed1;
+	}
+
+	dev_info(&pdev->dev, "ioremap 0x%llx to 0x%p with size 0x%llx\n",
+		 (unsigned long long) res->start,
+		 base_address,
+		 (unsigned long long) resource_size(res));
+
+
+	/* create sysfs files for the device */
+	ret = sysfs_create_group(&(pdev->dev.kobj), &xscugtimer_attr_group);
+	if (ret) {
+		dev_err(&pdev->dev, "Failed to create sysfs attr group\n");
+		goto failed2;
+	}
+
+	return 0;		/* Success */
+
+ failed2:
+	iounmap(base_address);
+
+ failed1:
+	release_mem_region(res->start, resource_size(res));
+ failed0:
+
+	return ret;
+}
+
+/**
+ * xscugtimer_drv_remove -  Remove call for the device.
+ *
+ * @pdev:	handle to the platform device structure.
+ *
+ * Unregister the device after releasing the resources.
+ * Returns 0 or error status.
+ **/
+static int __devexit xscugtimer_drv_remove(struct platform_device *pdev)
+{
+	struct xscugtimer_drvdata *drvdata;
+	struct resource *res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+
+	drvdata = (struct xscugtimer_drvdata *)dev_get_drvdata(&pdev->dev);
+
+	if (!drvdata)
+		return -ENODEV;
+
+
+	sysfs_remove_group(&pdev->dev.kobj, &xscugtimer_attr_group);
+
+
+	iounmap(base_address);
+	release_mem_region(res->start, res->end - res->start + 1);
+
+	return 0;		/* Success */
+}
+
+/* Driver Structure */
+static struct platform_driver xscugtimer_platform_driver = {
+	.probe = xscugtimer_drv_probe,
+	.remove = __devexit_p(xscugtimer_drv_remove),
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = DRIVER_NAME,
+	},
+};
+
+/**
+ * xscugtimer_module_init -  register the Device Configuration.
+ *
+ * Returns 0 on success, otherwise negative error.
+ */
+static int __init xscugtimer_init(void)
+{
+	return platform_driver_register(&xscugtimer_platform_driver);
+}
+
+/**
+ * xscugtimer_module_exit -  Unregister the Device Configuration.
+ */
+static void __exit xscugtimer_exit(void)
+{
+	platform_driver_unregister(&xscugtimer_platform_driver);
+
+}
+
+/* This driver is assumed to be in the BSP and started up all the time. */
+
+device_initcall(xscugtimer_init);
-- 
1.7.9.7

