From c36b7c4bb9e8d9c1428499381168197cdbdff5d4 Mon Sep 17 00:00:00 2001
From: Zhong Hongbo <hongbo.zhong@windriver.com>
Date: Tue, 21 Aug 2012 16:23:29 +0800
Subject: [PATCH 31/36] Xilinx: ARM: EmacPs: Fixed issues in Tx Timeout
 callback

The existing Tx timeout was not initializing the MAC with
correct speed and duplex settings. Because of this after
the Tx Timeout the MAC was failing to transmit and receive
ethernet traffic. This patch fixes this issue.

Signed-off-by: Anirudha <anirudh@xilinx.com>
Integrated-by: Hongbo Zhong <hongbo.zhong@windriver.com>
---
 drivers/net/ethernet/xilinx/xilinx_emacps.c |   39 ++++++++++++++++++---------
 1 file changed, 27 insertions(+), 12 deletions(-)

diff --git a/drivers/net/ethernet/xilinx/xilinx_emacps.c b/drivers/net/ethernet/xilinx/xilinx_emacps.c
index df871dc..3be9170 100644
--- a/drivers/net/ethernet/xilinx/xilinx_emacps.c
+++ b/drivers/net/ethernet/xilinx/xilinx_emacps.c
@@ -1636,30 +1636,45 @@ static int xemacps_close(struct net_device *ndev)
  **/
 static void xemacps_tx_timeout(struct net_device *ndev)
 {
-	unsigned long flags;
 	struct net_local *lp = netdev_priv(ndev);
 	int rc;
 
 	printk(KERN_ERR "%s transmit timeout %lu ms, reseting...\n",
 		ndev->name, TX_TIMEOUT * 1000UL / HZ);
-	lp->stats.tx_errors++;
-
-	spin_lock_irqsave(&lp->lock, flags);
-
 	netif_stop_queue(ndev);
+
+	spin_lock(&lp->lock);
 	napi_disable(&lp->napi);
 	xemacps_reset_hw(lp);
-	xemacps_clean_rings(lp);
-	rc  = xemacps_setup_ring(lp);
-	if (rc)
-		printk(KERN_ERR "%s Unable to setup BD or rings, rc %d\n",
+	xemacps_descriptor_free(lp);
+	if (lp->phy_dev)
+		phy_stop(lp->phy_dev);
+	rc = xemacps_descriptor_init(lp);
+	if (rc) {
+		printk(KERN_ERR "%s Unable to allocate DMA memory, rc %d\n",
+		ndev->name, rc);
+		spin_unlock(&lp->lock);
+		return;
+	}
+
+	rc = xemacps_setup_ring(lp);
+	if (rc) {
+		printk(KERN_ERR "%s Unable to setup BD rings, rc %d\n",
 		ndev->name, rc);
+		spin_unlock(&lp->lock);
+		return;
+	}
 	xemacps_init_hw(lp);
-	ndev->trans_start = jiffies;
+
+	lp->link    = 0;
+	lp->speed   = 0;
+	lp->duplex  = -1;
+	if (lp->phy_dev)
+		phy_start(lp->phy_dev);
 	napi_enable(&lp->napi);
-	netif_wake_queue(ndev);
 
-	spin_unlock_irqrestore(&lp->lock, flags);
+	spin_unlock(&lp->lock);
+	netif_start_queue(ndev);
 }
 
 /**
-- 
1.7.9.7

