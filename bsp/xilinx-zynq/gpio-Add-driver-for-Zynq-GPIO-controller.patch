From 3b56fac93f41cd4f436d57e909a7d0bc3e01eb40 Mon Sep 17 00:00:00 2001
From: Harini Katakam <harinik@xilinx.com>
Date: Wed, 6 Apr 2016 14:29:00 +0800
Subject: [PATCH 4/4] gpio: Add driver for Zynq GPIO controller

Add support for GPIO controller used by Xilinx Zynq.
cherry pick from https://github.com/Xilinx/linux-xlnx/releases
/tag/xilinx-v2015.4.01

upstreamlink:https://github.com/Xilinx/linux-xlnx/commits/master/
drivers/gpio/gpio-zynq.c

Signed-off-by: Hu <yadi.hu@windriver.com>
---
 drivers/gpio/Kconfig     |    6 +-
 drivers/gpio/gpio-zynq.c |  609 +++++++++++++++++++++++++++-------------------
 2 files changed, 360 insertions(+), 255 deletions(-)

diff --git a/drivers/gpio/Kconfig b/drivers/gpio/Kconfig
index 64cc4f0..bcf5ae1 100644
--- a/drivers/gpio/Kconfig
+++ b/drivers/gpio/Kconfig
@@ -323,11 +323,11 @@ config GPIO_XILINX
 	  Say yes here to support the Xilinx FPGA GPIO device
 
 config GPIO_ZYNQ
-	tristate "Xilinx ZYNQ GPIO support"
+	tristate "Xilinx Zynq GPIO support"
 	depends on ARCH_ZYNQ
-	select GENERIC_IRQ_CHIP
+	select GPIOLIB_IRQCHIP
 	help
-	  Say yes here to support Xilinx ZYNQ GPIO controller.
+	  Say yes here to support Xilinx Zynq GPIO controller.
 
 config GPIO_XTENSA
 	bool "Xtensa GPIO32 support"
diff --git a/drivers/gpio/gpio-zynq.c b/drivers/gpio/gpio-zynq.c
index c7f65eb..806d747 100644
--- a/drivers/gpio/gpio-zynq.c
+++ b/drivers/gpio/gpio-zynq.c
@@ -9,31 +9,65 @@
  * version.
  */
 
+#include <linux/bitops.h>
 #include <linux/clk.h>
-#include <linux/gpio.h>
+#include <linux/gpio/driver.h>
 #include <linux/init.h>
 #include <linux/interrupt.h>
 #include <linux/io.h>
-#include <linux/irq.h>
-#include <linux/irqchip/chained_irq.h>
-#include <linux/irqdomain.h>
 #include <linux/module.h>
 #include <linux/platform_device.h>
 #include <linux/pm_runtime.h>
+#include <linux/of.h>
 
 #define DRIVER_NAME "zynq-gpio"
-#define ZYNQ_GPIO_NR_GPIOS	118
 
-static struct irq_domain *irq_domain;
+/* Maximum banks */
+#define ZYNQ_GPIO_MAX_BANK	4
+#define ZYNQMP_GPIO_MAX_BANK	6
+
+#define ZYNQ_GPIO_BANK0_NGPIO	32
+#define ZYNQ_GPIO_BANK1_NGPIO	22
+#define ZYNQ_GPIO_BANK2_NGPIO	32
+#define ZYNQ_GPIO_BANK3_NGPIO	32
+
+#define ZYNQMP_GPIO_BANK0_NGPIO 26
+#define ZYNQMP_GPIO_BANK1_NGPIO 26
+#define ZYNQMP_GPIO_BANK2_NGPIO 26
+#define ZYNQMP_GPIO_BANK3_NGPIO 32
+#define ZYNQMP_GPIO_BANK4_NGPIO 32
+#define ZYNQMP_GPIO_BANK5_NGPIO 32
+
+#define	ZYNQ_GPIO_NR_GPIOS	118
+#define	ZYNQMP_GPIO_NR_GPIOS	174
+
+#define ZYNQ_GPIO_BANK0_PIN_MIN(str)	0
+#define ZYNQ_GPIO_BANK0_PIN_MAX(str)	(ZYNQ_GPIO_BANK0_PIN_MIN(str) + \
+					ZYNQ##str##_GPIO_BANK0_NGPIO - 1)
+#define ZYNQ_GPIO_BANK1_PIN_MIN(str)	(ZYNQ_GPIO_BANK0_PIN_MAX(str) + 1)
+#define ZYNQ_GPIO_BANK1_PIN_MAX(str)	(ZYNQ_GPIO_BANK1_PIN_MIN(str) + \
+					ZYNQ##str##_GPIO_BANK1_NGPIO - 1)
+#define ZYNQ_GPIO_BANK2_PIN_MIN(str)	(ZYNQ_GPIO_BANK1_PIN_MAX(str) + 1)
+#define ZYNQ_GPIO_BANK2_PIN_MAX(str)	(ZYNQ_GPIO_BANK2_PIN_MIN(str) + \
+					ZYNQ##str##_GPIO_BANK2_NGPIO - 1)
+#define ZYNQ_GPIO_BANK3_PIN_MIN(str)	(ZYNQ_GPIO_BANK2_PIN_MAX(str) + 1)
+#define ZYNQ_GPIO_BANK3_PIN_MAX(str)	(ZYNQ_GPIO_BANK3_PIN_MIN(str) + \
+					ZYNQ##str##_GPIO_BANK3_NGPIO - 1)
+#define ZYNQ_GPIO_BANK4_PIN_MIN(str)	(ZYNQ_GPIO_BANK3_PIN_MAX(str) + 1)
+#define ZYNQ_GPIO_BANK4_PIN_MAX(str)	(ZYNQ_GPIO_BANK4_PIN_MIN(str) + \
+					ZYNQ##str##_GPIO_BANK4_NGPIO - 1)
+#define ZYNQ_GPIO_BANK5_PIN_MIN(str)	(ZYNQ_GPIO_BANK4_PIN_MAX(str) + 1)
+#define ZYNQ_GPIO_BANK5_PIN_MAX(str)	(ZYNQ_GPIO_BANK5_PIN_MIN(str) + \
+					ZYNQ##str##_GPIO_BANK5_NGPIO - 1)
 
-/* Register offsets for the GPIO device */
 
+/* Register offsets for the GPIO device */
 /* LSW Mask & Data -WO */
 #define ZYNQ_GPIO_DATA_LSW_OFFSET(BANK)	(0x000 + (8 * BANK))
 /* MSW Mask & Data -WO */
 #define ZYNQ_GPIO_DATA_MSW_OFFSET(BANK)	(0x004 + (8 * BANK))
 /* Data Register-RW */
-#define ZYNQ_GPIO_DATA_OFFSET(BANK)	(0x040 + (4 * BANK))
+#define ZYNQ_GPIO_DATA_RO_OFFSET(BANK)	(0x060 + (4 * BANK))
 /* Direction mode reg-RW */
 #define ZYNQ_GPIO_DIRM_OFFSET(BANK)	(0x204 + (0x40 * BANK))
 /* Output enable reg-RW */
@@ -53,33 +87,9 @@ static struct irq_domain *irq_domain;
 /* Interrupt on any, reg-RW */
 #define ZYNQ_GPIO_INTANY_OFFSET(BANK)	(0x224 + (0x40 * BANK))
 
-/* Read/Write access to the GPIO PS registers */
-static inline u32 zynq_gpio_readreg(void __iomem *offset)
-{
-	return readl_relaxed(offset);
-}
-
-static inline void zynq_gpio_writereg(void __iomem *offset, u32 val)
-{
-	writel_relaxed(val, offset);
-}
-
-static unsigned int zynq_gpio_pin_table[] = {
-	31, /* 0 - 31 */
-	53, /* 32 - 53 */
-	85, /* 54 - 85 */
-	117 /* 86 - 117 */
-};
-
-/* Maximum banks */
-#define ZYNQ_GPIO_MAX_BANK	4
-
 /* Disable all interrupts mask */
 #define ZYNQ_GPIO_IXR_DISABLE_ALL	0xFFFFFFFF
 
-/* GPIO pin high */
-#define ZYNQ_GPIO_PIN_HIGH 1
-
 /* Mid pin number of a bank */
 #define ZYNQ_GPIO_MID_PIN_NUM 16
 
@@ -90,19 +100,37 @@ static unsigned int zynq_gpio_pin_table[] = {
  * struct zynq_gpio - gpio device private data structure
  * @chip:	instance of the gpio_chip
  * @base_addr:	base address of the GPIO device
- * @irq:	irq associated with the controller
- * @irq_base:	base of IRQ number for interrupt
  * @clk:	clock resource for this controller
+ * @irq:	interrupt for the GPIO device
+ * @p_data:	pointer to platform data
  */
 struct zynq_gpio {
 	struct gpio_chip chip;
 	void __iomem *base_addr;
-	unsigned int irq;
-	unsigned int irq_base;
 	struct clk *clk;
+	int irq;
+	const struct zynq_platform_data *p_data;
 };
 
 /**
+ * struct zynq_platform_data -  zynq gpio platform data structure
+ * @label:	string to store in gpio->label
+ * @ngpio:	max number of gpio pins
+ * @max_bank:	maximum number of gpio banks
+ * @bank_min:	this array represents bank's min pin
+ * @bank_max:	this array represents bank's max pin
+*/
+struct zynq_platform_data {
+	const char *label;
+	u16 ngpio;
+	int max_bank;
+	int bank_min[ZYNQMP_GPIO_MAX_BANK];
+	int bank_max[ZYNQMP_GPIO_MAX_BANK];
+};
+
+static struct irq_chip zynq_gpio_level_irqchip;
+static struct irq_chip zynq_gpio_edge_irqchip;
+/**
  * zynq_gpio_get_bank_pin - Get the bank number and pin number within that bank
  * for a given pin in the GPIO device
  * @pin_num:	gpio pin number within the device
@@ -111,21 +139,29 @@ struct zynq_gpio {
  * @bank_pin_num: an output parameter used to return pin number within a bank
  *		  for the given gpio pin
  *
- * Returns the bank number.
+ * Returns the bank number and pin offset within the bank.
  */
 static inline void zynq_gpio_get_bank_pin(unsigned int pin_num,
 					  unsigned int *bank_num,
-					  unsigned int *bank_pin_num)
+					  unsigned int *bank_pin_num,
+					  struct zynq_gpio *gpio)
 {
-	for (*bank_num = 0; *bank_num < ZYNQ_GPIO_MAX_BANK; (*bank_num)++)
-		if (pin_num <= zynq_gpio_pin_table[*bank_num])
-			break;
-
-	if (!(*bank_num))
-		*bank_pin_num = pin_num;
-	else
-		*bank_pin_num = pin_num %
-				(zynq_gpio_pin_table[*bank_num - 1] + 1);
+	int bank;
+
+	for (bank = 0; bank < gpio->p_data->max_bank; bank++) {
+		if ((pin_num >= gpio->p_data->bank_min[bank]) &&
+			(pin_num <= gpio->p_data->bank_max[bank])) {
+				*bank_num = bank;
+				*bank_pin_num = pin_num -
+						gpio->p_data->bank_min[bank];
+				return;
+		}
+	}
+
+	/* default */
+	WARN(true, "invalid GPIO pin number: %u", pin_num);
+	*bank_num = 0;
+	*bank_pin_num = 0;
 }
 
 /**
@@ -139,14 +175,16 @@ static inline void zynq_gpio_get_bank_pin(unsigned int pin_num,
  */
 static int zynq_gpio_get_value(struct gpio_chip *chip, unsigned int pin)
 {
-	unsigned int bank_num, bank_pin_num, data;
+	u32 data;
+	unsigned int bank_num, bank_pin_num;
 	struct zynq_gpio *gpio = container_of(chip, struct zynq_gpio, chip);
 
-	zynq_gpio_get_bank_pin(pin, &bank_num, &bank_pin_num);
+	zynq_gpio_get_bank_pin(pin, &bank_num, &bank_pin_num, gpio);
+
+	data = readl_relaxed(gpio->base_addr +
+			     ZYNQ_GPIO_DATA_RO_OFFSET(bank_num));
 
-	data = zynq_gpio_readreg(gpio->base_addr +
-				 ZYNQ_GPIO_DATA_OFFSET(bank_num));
-	return (data >> bank_pin_num) & ZYNQ_GPIO_PIN_HIGH;
+	return (data >> bank_pin_num) & 1;
 }
 
 /**
@@ -165,7 +203,7 @@ static void zynq_gpio_set_value(struct gpio_chip *chip, unsigned int pin,
 	unsigned int reg_offset, bank_num, bank_pin_num;
 	struct zynq_gpio *gpio = container_of(chip, struct zynq_gpio, chip);
 
-	zynq_gpio_get_bank_pin(pin, &bank_num, &bank_pin_num);
+	zynq_gpio_get_bank_pin(pin, &bank_num, &bank_pin_num, gpio);
 
 	if (bank_pin_num >= ZYNQ_GPIO_MID_PIN_NUM) {
 		/* only 16 data bits in bit maskable reg */
@@ -179,12 +217,11 @@ static void zynq_gpio_set_value(struct gpio_chip *chip, unsigned int pin,
 	 * get the 32 bit value to be written to the mask/data register where
 	 * the upper 16 bits is the mask and lower 16 bits is the data
 	 */
-	if (state)
-		state = 1;
+	state = !!state;
 	state = ~(1 << (bank_pin_num + ZYNQ_GPIO_MID_PIN_NUM)) &
 		((state << bank_pin_num) | ZYNQ_GPIO_UPPER_MASK);
 
-	zynq_gpio_writereg(gpio->base_addr + reg_offset, state);
+	writel_relaxed(state, gpio->base_addr + reg_offset);
 }
 
 /**
@@ -199,16 +236,20 @@ static void zynq_gpio_set_value(struct gpio_chip *chip, unsigned int pin,
  */
 static int zynq_gpio_dir_in(struct gpio_chip *chip, unsigned int pin)
 {
-	unsigned int reg, bank_num, bank_pin_num;
+	u32 reg;
+	unsigned int bank_num, bank_pin_num;
 	struct zynq_gpio *gpio = container_of(chip, struct zynq_gpio, chip);
 
-	zynq_gpio_get_bank_pin(pin, &bank_num, &bank_pin_num);
+	zynq_gpio_get_bank_pin(pin, &bank_num, &bank_pin_num, gpio);
+
+	/* bank 0 pins 7 and 8 are special and cannot be used as inputs */
+	if (bank_num == 0 && (bank_pin_num == 7 || bank_pin_num == 8))
+		return -EINVAL;
+
 	/* clear the bit in direction mode reg to set the pin as input */
-	reg = zynq_gpio_readreg(gpio->base_addr +
-				ZYNQ_GPIO_DIRM_OFFSET(bank_num));
-	reg &= ~(1 << bank_pin_num);
-	zynq_gpio_writereg(gpio->base_addr + ZYNQ_GPIO_DIRM_OFFSET(bank_num),
-			   reg);
+	reg = readl_relaxed(gpio->base_addr + ZYNQ_GPIO_DIRM_OFFSET(bank_num));
+	reg &= ~BIT(bank_pin_num);
+	writel_relaxed(reg, gpio->base_addr + ZYNQ_GPIO_DIRM_OFFSET(bank_num));
 
 	return 0;
 }
@@ -228,55 +269,27 @@ static int zynq_gpio_dir_in(struct gpio_chip *chip, unsigned int pin)
 static int zynq_gpio_dir_out(struct gpio_chip *chip, unsigned int pin,
 			     int state)
 {
+	u32 reg;
+	unsigned int bank_num, bank_pin_num;
 	struct zynq_gpio *gpio = container_of(chip, struct zynq_gpio, chip);
-	unsigned int reg, bank_num, bank_pin_num;
 
-	zynq_gpio_get_bank_pin(pin, &bank_num, &bank_pin_num);
+	zynq_gpio_get_bank_pin(pin, &bank_num, &bank_pin_num, gpio);
 
 	/* set the GPIO pin as output */
-	reg = zynq_gpio_readreg(gpio->base_addr +
-				ZYNQ_GPIO_DIRM_OFFSET(bank_num));
-	reg |= 1 << bank_pin_num;
-	zynq_gpio_writereg(gpio->base_addr + ZYNQ_GPIO_DIRM_OFFSET(bank_num),
-			   reg);
+	reg = readl_relaxed(gpio->base_addr + ZYNQ_GPIO_DIRM_OFFSET(bank_num));
+	reg |= BIT(bank_pin_num);
+	writel_relaxed(reg, gpio->base_addr + ZYNQ_GPIO_DIRM_OFFSET(bank_num));
 
 	/* configure the output enable reg for the pin */
-	reg = zynq_gpio_readreg(gpio->base_addr +
-				ZYNQ_GPIO_OUTEN_OFFSET(bank_num));
-	reg |= 1 << bank_pin_num;
-	zynq_gpio_writereg(gpio->base_addr + ZYNQ_GPIO_OUTEN_OFFSET(bank_num),
-			   reg);
+	reg = readl_relaxed(gpio->base_addr + ZYNQ_GPIO_OUTEN_OFFSET(bank_num));
+	reg |= BIT(bank_pin_num);
+	writel_relaxed(reg, gpio->base_addr + ZYNQ_GPIO_OUTEN_OFFSET(bank_num));
 
 	/* set the state of the pin */
 	zynq_gpio_set_value(chip, pin, state);
 	return 0;
 }
 
-static int zynq_gpio_to_irq(struct gpio_chip *chip, unsigned offset)
-{
-	return irq_find_mapping(irq_domain, offset);
-}
-
-/**
- * zynq_gpio_irq_ack - Acknowledge the interrupt of a gpio pin
- * @irq_data:	irq data containing irq number of gpio pin for the interrupt
- *		to ack
- *
- * This function calculates gpio pin number from irq number and sets the bit
- * in the Interrupt Status Register of the corresponding bank, to ACK the irq.
- */
-static void zynq_gpio_irq_ack(struct irq_data *irq_data)
-{
-	struct zynq_gpio *gpio = (struct zynq_gpio *)
-				 irq_data_get_irq_chip_data(irq_data);
-	unsigned int device_pin_num, bank_num, bank_pin_num;
-
-	device_pin_num = irq_data->hwirq;
-	zynq_gpio_get_bank_pin(device_pin_num, &bank_num, &bank_pin_num);
-	zynq_gpio_writereg(gpio->base_addr + ZYNQ_GPIO_INTSTS_OFFSET(bank_num),
-			   1 << bank_pin_num);
-}
-
 /**
  * zynq_gpio_irq_mask - Disable the interrupts for a gpio pin
  * @irq_data:	per irq and chip data passed down to chip functions
@@ -287,14 +300,13 @@ static void zynq_gpio_irq_ack(struct irq_data *irq_data)
  */
 static void zynq_gpio_irq_mask(struct irq_data *irq_data)
 {
-	struct zynq_gpio *gpio = (struct zynq_gpio *)
-				 irq_data_get_irq_chip_data(irq_data);
 	unsigned int device_pin_num, bank_num, bank_pin_num;
+	struct zynq_gpio *gpio = irq_data_get_irq_chip_data(irq_data);
 
 	device_pin_num = irq_data->hwirq;
-	zynq_gpio_get_bank_pin(device_pin_num, &bank_num, &bank_pin_num);
-	zynq_gpio_writereg(gpio->base_addr + ZYNQ_GPIO_INTDIS_OFFSET(bank_num),
-			   1 << bank_pin_num);
+	zynq_gpio_get_bank_pin(device_pin_num, &bank_num, &bank_pin_num, gpio);
+	writel_relaxed(BIT(bank_pin_num),
+		       gpio->base_addr + ZYNQ_GPIO_INTDIS_OFFSET(bank_num));
 }
 
 /**
@@ -308,13 +320,55 @@ static void zynq_gpio_irq_mask(struct irq_data *irq_data)
  */
 static void zynq_gpio_irq_unmask(struct irq_data *irq_data)
 {
+	unsigned int device_pin_num, bank_num, bank_pin_num;
 	struct zynq_gpio *gpio = irq_data_get_irq_chip_data(irq_data);
+
+	device_pin_num = irq_data->hwirq;
+	zynq_gpio_get_bank_pin(device_pin_num, &bank_num, &bank_pin_num, gpio);
+	writel_relaxed(BIT(bank_pin_num),
+		       gpio->base_addr + ZYNQ_GPIO_INTEN_OFFSET(bank_num));
+}
+
+/**
+ * zynq_gpio_irq_ack - Acknowledge the interrupt of a gpio pin
+ * @irq_data:	irq data containing irq number of gpio pin for the interrupt
+ *		to ack
+ *
+ * This function calculates gpio pin number from irq number and sets the bit
+ * in the Interrupt Status Register of the corresponding bank, to ACK the irq.
+ */
+static void zynq_gpio_irq_ack(struct irq_data *irq_data)
+{
 	unsigned int device_pin_num, bank_num, bank_pin_num;
+	struct zynq_gpio *gpio = irq_data_get_irq_chip_data(irq_data);
 
 	device_pin_num = irq_data->hwirq;
-	zynq_gpio_get_bank_pin(device_pin_num, &bank_num, &bank_pin_num);
-	zynq_gpio_writereg(gpio->base_addr + ZYNQ_GPIO_INTEN_OFFSET(bank_num),
-			   1 << bank_pin_num);
+	zynq_gpio_get_bank_pin(device_pin_num, &bank_num, &bank_pin_num, gpio);
+	writel_relaxed(BIT(bank_pin_num),
+		       gpio->base_addr + ZYNQ_GPIO_INTSTS_OFFSET(bank_num));
+}
+
+/**
+ * zynq_gpio_irq_enable - Enable the interrupts for a gpio pin
+ * @irq_data:	irq data containing irq number of gpio pin for the interrupt
+ *		to enable
+ *
+ * Clears the INTSTS bit and unmasks the given interrrupt.
+ */
+static void zynq_gpio_irq_enable(struct irq_data *irq_data)
+{
+	/*
+	 * The Zynq GPIO controller does not disable interrupt detection when
+	 * the interrupt is masked and only disables the propagation of the
+	 * interrupt. This means when the controller detects an interrupt
+	 * condition while the interrupt is logically disabled it will propagate
+	 * that interrupt event once the interrupt is enabled. This will cause
+	 * the interrupt consumer to see spurious interrupts to prevent this
+	 * first make sure that the interrupt is not asserted and then enable
+	 * it.
+	 */
+	zynq_gpio_irq_ack(irq_data);
+	zynq_gpio_irq_unmask(irq_data);
 }
 
 /**
@@ -334,19 +388,19 @@ static void zynq_gpio_irq_unmask(struct irq_data *irq_data)
  */
 static int zynq_gpio_set_irq_type(struct irq_data *irq_data, unsigned int type)
 {
-	struct zynq_gpio *gpio = irq_data_get_irq_chip_data(irq_data);
+	u32 int_type, int_pol, int_any;
 	unsigned int device_pin_num, bank_num, bank_pin_num;
-	unsigned int int_type, int_pol, int_any;
+	struct zynq_gpio *gpio = irq_data_get_irq_chip_data(irq_data);
 
 	device_pin_num = irq_data->hwirq;
-	zynq_gpio_get_bank_pin(device_pin_num, &bank_num, &bank_pin_num);
+	zynq_gpio_get_bank_pin(device_pin_num, &bank_num, &bank_pin_num, gpio);
 
-	int_type = zynq_gpio_readreg(gpio->base_addr +
-				     ZYNQ_GPIO_INTTYPE_OFFSET(bank_num));
-	int_pol = zynq_gpio_readreg(gpio->base_addr +
-				    ZYNQ_GPIO_INTPOL_OFFSET(bank_num));
-	int_any = zynq_gpio_readreg(gpio->base_addr +
-				    ZYNQ_GPIO_INTANY_OFFSET(bank_num));
+	int_type = readl_relaxed(gpio->base_addr +
+				 ZYNQ_GPIO_INTTYPE_OFFSET(bank_num));
+	int_pol = readl_relaxed(gpio->base_addr +
+				ZYNQ_GPIO_INTPOL_OFFSET(bank_num));
+	int_any = readl_relaxed(gpio->base_addr +
+				ZYNQ_GPIO_INTANY_OFFSET(bank_num));
 
 	/*
 	 * based on the type requested, configure the INT_TYPE, INT_POLARITY
@@ -354,60 +408,101 @@ static int zynq_gpio_set_irq_type(struct irq_data *irq_data, unsigned int type)
 	 */
 	switch (type) {
 	case IRQ_TYPE_EDGE_RISING:
-		int_type |= (1 << bank_pin_num);
-		int_pol |= (1 << bank_pin_num);
-		int_any &= ~(1 << bank_pin_num);
+		int_type |= BIT(bank_pin_num);
+		int_pol |= BIT(bank_pin_num);
+		int_any &= ~BIT(bank_pin_num);
 		break;
 	case IRQ_TYPE_EDGE_FALLING:
-		int_type |= (1 << bank_pin_num);
-		int_pol &= ~(1 << bank_pin_num);
-		int_any &= ~(1 << bank_pin_num);
+		int_type |= BIT(bank_pin_num);
+		int_pol &= ~BIT(bank_pin_num);
+		int_any &= ~BIT(bank_pin_num);
 		break;
 	case IRQ_TYPE_EDGE_BOTH:
-		int_type |= (1 << bank_pin_num);
-		int_any |= (1 << bank_pin_num);
+		int_type |= BIT(bank_pin_num);
+		int_any |= BIT(bank_pin_num);
 		break;
 	case IRQ_TYPE_LEVEL_HIGH:
-		int_type &= ~(1 << bank_pin_num);
-		int_pol |= (1 << bank_pin_num);
+		int_type &= ~BIT(bank_pin_num);
+		int_pol |= BIT(bank_pin_num);
 		break;
 	case IRQ_TYPE_LEVEL_LOW:
-		int_type &= ~(1 << bank_pin_num);
-		int_pol &= ~(1 << bank_pin_num);
+		int_type &= ~BIT(bank_pin_num);
+		int_pol &= ~BIT(bank_pin_num);
 		break;
 	default:
 		return -EINVAL;
 	}
 
-	zynq_gpio_writereg(gpio->base_addr +
-			   ZYNQ_GPIO_INTTYPE_OFFSET(bank_num), int_type);
-	zynq_gpio_writereg(gpio->base_addr + ZYNQ_GPIO_INTPOL_OFFSET(bank_num),
-			   int_pol);
-	zynq_gpio_writereg(gpio->base_addr + ZYNQ_GPIO_INTANY_OFFSET(bank_num),
-			   int_any);
+	writel_relaxed(int_type,
+		       gpio->base_addr + ZYNQ_GPIO_INTTYPE_OFFSET(bank_num));
+	writel_relaxed(int_pol,
+		       gpio->base_addr + ZYNQ_GPIO_INTPOL_OFFSET(bank_num));
+	writel_relaxed(int_any,
+		       gpio->base_addr + ZYNQ_GPIO_INTANY_OFFSET(bank_num));
+
+	if (type & IRQ_TYPE_LEVEL_MASK) {
+		__irq_set_chip_handler_name_locked(irq_data->irq,
+			&zynq_gpio_level_irqchip, handle_fasteoi_irq, NULL);
+	} else {
+		__irq_set_chip_handler_name_locked(irq_data->irq,
+			&zynq_gpio_edge_irqchip, handle_level_irq, NULL);
+	}
+
 	return 0;
 }
 
 static int zynq_gpio_set_wake(struct irq_data *data, unsigned int on)
 {
-	if (on)
-		zynq_gpio_irq_unmask(data);
-	else
-		zynq_gpio_irq_mask(data);
+	struct zynq_gpio *gpio = irq_data_get_irq_chip_data(data);
+
+	irq_set_irq_wake(gpio->irq, on);
 
 	return 0;
 }
 
 /* irq chip descriptor */
-static struct irq_chip zynq_gpio_irqchip = {
+static struct irq_chip zynq_gpio_level_irqchip = {
+	.name		= DRIVER_NAME,
+	.irq_enable	= zynq_gpio_irq_enable,
+	.irq_eoi	= zynq_gpio_irq_ack,
+	.irq_mask	= zynq_gpio_irq_mask,
+	.irq_unmask	= zynq_gpio_irq_unmask,
+	.irq_set_type	= zynq_gpio_set_irq_type,
+	.irq_set_wake	= zynq_gpio_set_wake,
+	.flags		= IRQCHIP_EOI_THREADED | IRQCHIP_EOI_IF_HANDLED |
+			  IRQCHIP_MASK_ON_SUSPEND,
+};
+
+static struct irq_chip zynq_gpio_edge_irqchip = {
 	.name		= DRIVER_NAME,
+	.irq_enable	= zynq_gpio_irq_enable,
 	.irq_ack	= zynq_gpio_irq_ack,
 	.irq_mask	= zynq_gpio_irq_mask,
 	.irq_unmask	= zynq_gpio_irq_unmask,
 	.irq_set_type	= zynq_gpio_set_irq_type,
 	.irq_set_wake	= zynq_gpio_set_wake,
+	.flags		= IRQCHIP_MASK_ON_SUSPEND,
 };
 
+static void zynq_gpio_handle_bank_irq(struct zynq_gpio *gpio,
+				      unsigned int bank_num,
+				      unsigned long pending)
+{
+	unsigned int bank_offset = gpio->p_data->bank_min[bank_num];
+	struct irq_domain *irqdomain = gpio->chip.irqdomain;
+	int offset;
+
+	if (!pending)
+		return;
+
+	for_each_set_bit(offset, &pending, 32) {
+		unsigned int gpio_irq;
+
+		gpio_irq = irq_find_mapping(irqdomain, offset + bank_offset);
+		generic_handle_irq(gpio_irq);
+	}
+}
+
 /**
  * zynq_gpio_irqhandler - IRQ handler for the gpio banks of a gpio device
  * @irq:	irq number of the gpio bank where interrupt has occurred
@@ -421,51 +516,32 @@ static struct irq_chip zynq_gpio_irqchip = {
  */
 static void zynq_gpio_irqhandler(unsigned int irq, struct irq_desc *desc)
 {
-	struct zynq_gpio *gpio = (struct zynq_gpio *)irq_get_handler_data(irq);
-	int gpio_irq = gpio->irq_base;
-	unsigned int int_sts, int_enb, bank_num;
-	struct irq_desc *gpio_irq_desc;
-	struct irq_chip *chip = irq_desc_get_chip(desc);
-
-	chained_irq_enter(chip, desc);
-
-	for (bank_num = 0; bank_num < ZYNQ_GPIO_MAX_BANK; bank_num++) {
-		int_sts = zynq_gpio_readreg(gpio->base_addr +
-					    ZYNQ_GPIO_INTSTS_OFFSET(bank_num));
-		int_enb = zynq_gpio_readreg(gpio->base_addr +
-					    ZYNQ_GPIO_INTMASK_OFFSET(bank_num));
-		int_sts &= ~int_enb;
-
-		for (; int_sts != 0; int_sts >>= 1, gpio_irq++) {
-			if (!(int_sts & 1))
-				continue;
-			gpio_irq_desc = irq_to_desc(gpio_irq);
-			BUG_ON(!gpio_irq_desc);
-			chip = irq_desc_get_chip(gpio_irq_desc);
-			BUG_ON(!chip);
-			chip->irq_ack(&gpio_irq_desc->irq_data);
-
-			/* call the pin specific handler */
-			generic_handle_irq(gpio_irq);
-		}
-		/* shift to first virtual irq of next bank */
-		gpio_irq = gpio->irq_base + zynq_gpio_pin_table[bank_num] + 1;
+	u32 int_sts, int_enb;
+	unsigned int bank_num;
+	struct zynq_gpio *gpio = irq_get_handler_data(irq);
+	struct irq_chip *irqchip = irq_desc_get_chip(desc);
+
+	chained_irq_enter(irqchip, desc);
+
+	for (bank_num = 0; bank_num < gpio->p_data->max_bank; bank_num++) {
+		int_sts = readl_relaxed(gpio->base_addr +
+					ZYNQ_GPIO_INTSTS_OFFSET(bank_num));
+		int_enb = readl_relaxed(gpio->base_addr +
+					ZYNQ_GPIO_INTMASK_OFFSET(bank_num));
+		zynq_gpio_handle_bank_irq(gpio, bank_num, int_sts & ~int_enb);
 	}
 
-	chip = irq_desc_get_chip(desc);
-	chained_irq_exit(chip, desc);
+	chained_irq_exit(irqchip, desc);
 }
 
 static int __maybe_unused zynq_gpio_suspend(struct device *dev)
 {
 	struct platform_device *pdev = to_platform_device(dev);
-	struct zynq_gpio *gpio = platform_get_drvdata(pdev);
+	int irq = platform_get_irq(pdev, 0);
+	struct irq_data *data = irq_get_irq_data(irq);
 
-	if (!device_may_wakeup(dev)) {
-		if (!pm_runtime_suspended(dev))
-			clk_disable(gpio->clk);
-		return 0;
-	}
+	if (!irqd_is_wakeup_set(data))
+		return pm_runtime_force_suspend(dev);
 
 	return 0;
 }
@@ -473,12 +549,11 @@ static int __maybe_unused zynq_gpio_suspend(struct device *dev)
 static int __maybe_unused zynq_gpio_resume(struct device *dev)
 {
 	struct platform_device *pdev = to_platform_device(dev);
-	struct zynq_gpio *gpio = platform_get_drvdata(pdev);
+	int irq = platform_get_irq(pdev, 0);
+	struct irq_data *data = irq_get_irq_data(irq);
 
-	if (!device_may_wakeup(dev)) {
-		if (!pm_runtime_suspended(dev))
-			return clk_enable(gpio->clk);
-	}
+	if (!irqd_is_wakeup_set(data))
+		return pm_runtime_force_resume(dev);
 
 	return 0;
 }
@@ -488,7 +563,7 @@ static int __maybe_unused zynq_gpio_runtime_suspend(struct device *dev)
 	struct platform_device *pdev = to_platform_device(dev);
 	struct zynq_gpio *gpio = platform_get_drvdata(pdev);
 
-	clk_disable(gpio->clk);
+	clk_disable_unprepare(gpio->clk);
 
 	return 0;
 }
@@ -498,12 +573,7 @@ static int __maybe_unused zynq_gpio_runtime_resume(struct device *dev)
 	struct platform_device *pdev = to_platform_device(dev);
 	struct zynq_gpio *gpio = platform_get_drvdata(pdev);
 
-	return clk_enable(gpio->clk);
-}
-
-static int __maybe_unused zynq_gpio_idle(struct device *dev)
-{
-	return pm_schedule_suspend(dev, 1);
+	return clk_prepare_enable(gpio->clk);
 }
 
 static int zynq_gpio_request(struct gpio_chip *chip, unsigned offset)
@@ -521,15 +591,55 @@ static int zynq_gpio_request(struct gpio_chip *chip, unsigned offset)
 
 static void zynq_gpio_free(struct gpio_chip *chip, unsigned offset)
 {
-	pm_runtime_put_sync(chip->dev);
+	pm_runtime_put(chip->dev);
 }
 
 static const struct dev_pm_ops zynq_gpio_dev_pm_ops = {
 	SET_SYSTEM_SLEEP_PM_OPS(zynq_gpio_suspend, zynq_gpio_resume)
-	SET_RUNTIME_PM_OPS(zynq_gpio_runtime_suspend, zynq_gpio_runtime_resume,
-			   zynq_gpio_idle)
+	SET_RUNTIME_PM_OPS(zynq_gpio_runtime_suspend,
+			zynq_gpio_runtime_resume, NULL)
+};
+
+static const struct zynq_platform_data zynqmp_gpio_def = {
+	.label = "zynqmp_gpio",
+	.ngpio = ZYNQMP_GPIO_NR_GPIOS,
+	.max_bank = ZYNQMP_GPIO_MAX_BANK,
+	.bank_min[0] = ZYNQ_GPIO_BANK0_PIN_MIN(MP),
+	.bank_max[0] = ZYNQ_GPIO_BANK0_PIN_MAX(MP),
+	.bank_min[1] = ZYNQ_GPIO_BANK1_PIN_MIN(MP),
+	.bank_max[1] = ZYNQ_GPIO_BANK1_PIN_MAX(MP),
+	.bank_min[2] = ZYNQ_GPIO_BANK2_PIN_MIN(MP),
+	.bank_max[2] = ZYNQ_GPIO_BANK2_PIN_MAX(MP),
+	.bank_min[3] = ZYNQ_GPIO_BANK3_PIN_MIN(MP),
+	.bank_max[3] = ZYNQ_GPIO_BANK3_PIN_MAX(MP),
+	.bank_min[4] = ZYNQ_GPIO_BANK4_PIN_MIN(MP),
+	.bank_max[4] = ZYNQ_GPIO_BANK4_PIN_MAX(MP),
+	.bank_min[5] = ZYNQ_GPIO_BANK5_PIN_MIN(MP),
+	.bank_max[5] = ZYNQ_GPIO_BANK5_PIN_MAX(MP),
+};
+
+static const struct zynq_platform_data zynq_gpio_def = {
+	.label = "zynq_gpio",
+	.ngpio = ZYNQ_GPIO_NR_GPIOS,
+	.max_bank = ZYNQ_GPIO_MAX_BANK,
+	.bank_min[0] = ZYNQ_GPIO_BANK0_PIN_MIN(),
+	.bank_max[0] = ZYNQ_GPIO_BANK0_PIN_MAX(),
+	.bank_min[1] = ZYNQ_GPIO_BANK1_PIN_MIN(),
+	.bank_max[1] = ZYNQ_GPIO_BANK1_PIN_MAX(),
+	.bank_min[2] = ZYNQ_GPIO_BANK2_PIN_MIN(),
+	.bank_max[2] = ZYNQ_GPIO_BANK2_PIN_MAX(),
+	.bank_min[3] = ZYNQ_GPIO_BANK3_PIN_MIN(),
+	.bank_max[3] = ZYNQ_GPIO_BANK3_PIN_MAX(),
 };
 
+static const struct of_device_id zynq_gpio_of_match[] = {
+	{ .compatible = "xlnx,zynq-gpio-1.0", .data = (void *)&zynq_gpio_def },
+	{ .compatible = "xlnx,zynqmp-gpio-1.0",
+					.data = (void *)&zynqmp_gpio_def },
+	{ /* end of table */ }
+};
+MODULE_DEVICE_TABLE(of, zynq_gpio_of_match);
+
 /**
  * zynq_gpio_probe - Initialization method for a zynq_gpio device
  * @pdev:	platform device instance
@@ -543,16 +653,22 @@ static const struct dev_pm_ops zynq_gpio_dev_pm_ops = {
  */
 static int zynq_gpio_probe(struct platform_device *pdev)
 {
-	int ret, pin_num, bank_num, gpio_irq;
-	unsigned int irq_num;
+	int ret, bank_num;
 	struct zynq_gpio *gpio;
 	struct gpio_chip *chip;
 	struct resource *res;
+	const struct of_device_id *match;
 
 	gpio = devm_kzalloc(&pdev->dev, sizeof(*gpio), GFP_KERNEL);
 	if (!gpio)
 		return -ENOMEM;
 
+	match = of_match_node(zynq_gpio_of_match, pdev->dev.of_node);
+	if (!match) {
+		dev_err(&pdev->dev, "of_match_node() failed\n");
+		return -EINVAL;
+	}
+	gpio->p_data = match->data;
 	platform_set_drvdata(pdev, gpio);
 
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
@@ -560,12 +676,15 @@ static int zynq_gpio_probe(struct platform_device *pdev)
 	if (IS_ERR(gpio->base_addr))
 		return PTR_ERR(gpio->base_addr);
 
-	irq_num = platform_get_irq(pdev, 0);
-	gpio->irq = irq_num;
+	gpio->irq = platform_get_irq(pdev, 0);
+	if (gpio->irq < 0) {
+		dev_err(&pdev->dev, "invalid IRQ\n");
+		return gpio->irq;
+	}
 
 	/* configure the gpio chip */
 	chip = &gpio->chip;
-	chip->label = "zynq_gpio";
+	chip->label = gpio->p_data->label;
 	chip->owner = THIS_MODULE;
 	chip->dev = &pdev->dev;
 	chip->get = zynq_gpio_get_value;
@@ -574,69 +693,54 @@ static int zynq_gpio_probe(struct platform_device *pdev)
 	chip->free = zynq_gpio_free;
 	chip->direction_input = zynq_gpio_dir_in;
 	chip->direction_output = zynq_gpio_dir_out;
-	chip->to_irq = zynq_gpio_to_irq;
-	chip->dbg_show = NULL;
-	chip->base = 0;		/* default pin base */
-	chip->ngpio = ZYNQ_GPIO_NR_GPIOS;
-	chip->can_sleep = 0;
-
-	gpio->irq_base = irq_alloc_descs(-1, 0, chip->ngpio, 0);
-	if (gpio->irq_base < 0) {
-		dev_err(&pdev->dev, "Couldn't allocate IRQ numbers\n");
-		return -ENODEV;
-	}
-
-	irq_domain = irq_domain_add_legacy(pdev->dev.of_node,
-					   chip->ngpio, gpio->irq_base, 0,
-					   &irq_domain_simple_ops, NULL);
-
-	/* report a bug if gpio chip registration fails */
-	ret = gpiochip_add(chip);
-	if (ret < 0)
-		return ret;
+	chip->base = -1;
+	chip->ngpio = gpio->p_data->ngpio;
 
 	/* Enable GPIO clock */
 	gpio->clk = devm_clk_get(&pdev->dev, NULL);
 	if (IS_ERR(gpio->clk)) {
 		dev_err(&pdev->dev, "input clock not found.\n");
-		gpiochip_remove(chip);
 		return PTR_ERR(gpio->clk);
 	}
 	ret = clk_prepare_enable(gpio->clk);
 	if (ret) {
 		dev_err(&pdev->dev, "Unable to enable clock.\n");
-		gpiochip_remove(chip);
 		return ret;
 	}
 
-	/* disable interrupts for all banks */
-	for (bank_num = 0; bank_num < ZYNQ_GPIO_MAX_BANK; bank_num++) {
-		zynq_gpio_writereg(gpio->base_addr +
-				   ZYNQ_GPIO_INTDIS_OFFSET(bank_num),
-				   ZYNQ_GPIO_IXR_DISABLE_ALL);
+	/* report a bug if gpio chip registration fails */
+	ret = gpiochip_add(chip);
+	if (ret) {
+		dev_err(&pdev->dev, "Failed to add gpio chip\n");
+		goto err_disable_clk;
 	}
 
-	/*
-	 * set the irq chip, handler and irq chip data for callbacks for
-	 * each pin
-	 */
-	for (pin_num = 0; pin_num < min_t(int, ZYNQ_GPIO_NR_GPIOS,
-					  (int)chip->ngpio); pin_num++) {
-		gpio_irq = irq_find_mapping(irq_domain, pin_num);
-		irq_set_chip_and_handler(gpio_irq, &zynq_gpio_irqchip,
-					 handle_simple_irq);
-		irq_set_chip_data(gpio_irq, (void *)gpio);
-		set_irq_flags(gpio_irq, IRQF_VALID);
+	/* disable interrupts for all banks */
+	for (bank_num = 0; bank_num < gpio->p_data->max_bank; bank_num++)
+		writel_relaxed(ZYNQ_GPIO_IXR_DISABLE_ALL, gpio->base_addr +
+			       ZYNQ_GPIO_INTDIS_OFFSET(bank_num));
+
+	ret = gpiochip_irqchip_add(chip, &zynq_gpio_edge_irqchip, 0,
+				   handle_level_irq, IRQ_TYPE_NONE);
+	if (ret) {
+		dev_err(&pdev->dev, "Failed to add irq chip\n");
+		goto err_rm_gpiochip;
 	}
 
-	irq_set_handler_data(irq_num, (void *)gpio);
-	irq_set_chained_handler(irq_num, zynq_gpio_irqhandler);
+	gpiochip_set_chained_irqchip(chip, &zynq_gpio_edge_irqchip, gpio->irq,
+				     zynq_gpio_irqhandler);
 
+	pm_runtime_set_active(&pdev->dev);
 	pm_runtime_enable(&pdev->dev);
 
-	device_set_wakeup_capable(&pdev->dev, 1);
-
 	return 0;
+
+err_rm_gpiochip:
+	gpiochip_remove(chip);
+err_disable_clk:
+	clk_disable_unprepare(gpio->clk);
+
+	return ret;
 }
 
 /**
@@ -649,26 +753,22 @@ static int zynq_gpio_remove(struct platform_device *pdev)
 {
 	struct zynq_gpio *gpio = platform_get_drvdata(pdev);
 
+	pm_runtime_get_sync(&pdev->dev);
+	gpiochip_remove(&gpio->chip);
 	clk_disable_unprepare(gpio->clk);
 	device_set_wakeup_capable(&pdev->dev, 0);
+	pm_runtime_disable(&pdev->dev);
 	return 0;
 }
 
-static struct of_device_id zynq_gpio_of_match[] = {
-	{ .compatible = "xlnx,zynq-gpio-1.0", },
-	{ /* end of table */ }
-};
-MODULE_DEVICE_TABLE(of, zynq_gpio_of_match);
-
 static struct platform_driver zynq_gpio_driver = {
 	.driver	= {
-		.name	= DRIVER_NAME,
-		.owner	= THIS_MODULE,
-		.pm	= &zynq_gpio_dev_pm_ops,
+		.name = DRIVER_NAME,
+		.pm = &zynq_gpio_dev_pm_ops,
 		.of_match_table = zynq_gpio_of_match,
 	},
-	.probe		= zynq_gpio_probe,
-	.remove		= zynq_gpio_remove,
+	.probe = zynq_gpio_probe,
+	.remove = zynq_gpio_remove,
 };
 
 /**
@@ -680,9 +780,14 @@ static int __init zynq_gpio_init(void)
 {
 	return platform_driver_register(&zynq_gpio_driver);
 }
-
 postcore_initcall(zynq_gpio_init);
 
-MODULE_AUTHOR("Xilinx, Inc.");
+static void __exit zynq_gpio_exit(void)
+{
+	platform_driver_unregister(&zynq_gpio_driver);
+}
+module_exit(zynq_gpio_exit);
+
+MODULE_AUTHOR("Xilinx Inc.");
 MODULE_DESCRIPTION("Zynq GPIO driver");
 MODULE_LICENSE("GPL");
-- 
1.7.5.4

