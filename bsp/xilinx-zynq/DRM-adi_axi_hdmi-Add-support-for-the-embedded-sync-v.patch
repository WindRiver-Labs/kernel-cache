From 6db0a09ec1caa66230614fcc1a8ba41d6444e8eb Mon Sep 17 00:00:00 2001
From: Lars-Peter Clausen <lars@metafoo.de>
Date: Tue, 30 Apr 2013 16:37:33 +0200
Subject: [PATCH 233/509] DRM: adi_axi_hdmi: Add support for the embedded sync
 variant

https://github.com/analogdevicesinc/linux.git xcomm_zynq
commit 34c751f6d9fdb0c3cfc7980c160dc69013534e01

Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 drivers/gpu/drm/adi_axi_hdmi/axi_hdmi_drv.c     |    6 ++-
 drivers/gpu/drm/adi_axi_hdmi/axi_hdmi_drv.h     |    1 +
 drivers/gpu/drm/adi_axi_hdmi/axi_hdmi_encoder.c |   37 ++++++++++++++--------
 3 files changed, 28 insertions(+), 16 deletions(-)

diff --git a/drivers/gpu/drm/adi_axi_hdmi/axi_hdmi_drv.c b/drivers/gpu/drm/adi_axi_hdmi/axi_hdmi_drv.c
index 16542f0..4b05090 100644
--- a/drivers/gpu/drm/adi_axi_hdmi/axi_hdmi_drv.c
+++ b/drivers/gpu/drm/adi_axi_hdmi/axi_hdmi_drv.c
@@ -143,6 +143,7 @@ static struct drm_driver axi_hdmi_driver = {
 
 static int axi_hdmi_platform_probe(struct platform_device *pdev)
 {
+	struct device_node *np = pdev->dev.of_node;
 	struct axi_hdmi_private *private;
 	struct device_node *slave_node;
 	struct resource *res;
@@ -160,11 +161,12 @@ static int axi_hdmi_platform_probe(struct platform_device *pdev)
 	if (IS_ERR(private->hdmi_clock))
 		return -EPROBE_DEFER;
 
-	slave_node = of_parse_phandle(pdev->dev.of_node, "encoder-slave", 0);
+	slave_node = of_parse_phandle(np, "encoder-slave", 0);
 	if (!slave_node)
 		return -EINVAL;
 
-	private->is_rgb = of_property_read_bool(pdev->dev.of_node, "adi,is-rgb");
+	private->is_rgb = of_property_read_bool(np, "adi,is-rgb");
+	private->embedded_sync = of_property_read_bool(np, "adi,embedded-sync");
 	
 	private->encoder_slave = of_find_i2c_device_by_node(slave_node);
 	of_node_put(slave_node);
diff --git a/drivers/gpu/drm/adi_axi_hdmi/axi_hdmi_drv.h b/drivers/gpu/drm/adi_axi_hdmi/axi_hdmi_drv.h
index a594440..4bd8d94 100644
--- a/drivers/gpu/drm/adi_axi_hdmi/axi_hdmi_drv.h
+++ b/drivers/gpu/drm/adi_axi_hdmi/axi_hdmi_drv.h
@@ -35,6 +35,7 @@ struct axi_hdmi_private {
 	struct dma_chan *dma;
 
 	bool is_rgb;
+	bool embedded_sync;
 };
 
 #endif
diff --git a/drivers/gpu/drm/adi_axi_hdmi/axi_hdmi_encoder.c b/drivers/gpu/drm/adi_axi_hdmi/axi_hdmi_encoder.c
index 65b3981..a841e4e 100644
--- a/drivers/gpu/drm/adi_axi_hdmi/axi_hdmi_encoder.c
+++ b/drivers/gpu/drm/adi_axi_hdmi/axi_hdmi_encoder.c
@@ -32,6 +32,9 @@
 #define AXI_HDMI_REG_STATUS		0x10
 #define AXI_HDMI_REG_COLOR_PATTERN	0x1c
 
+#define AXI_HDMI_REG_ES_HTIMING		0x08
+#define AXI_HDMI_REG_ES_VTIMING		0x0C
+
 #define AXI_HDMI_CTRL_ENABLE		BIT(0)
 #define AXI_HDMI_CTRL_CSC_BYPASS	BIT(1)
 #define AXI_HDMI_CTRL_TPG_ENABLE	BIT(2)
@@ -320,22 +323,28 @@ static void axi_hdmi_encoder_mode_set(struct drm_encoder *encoder,
 		sfuncs->mode_set(encoder, mode, adjusted_mode);
 
 	htotal = mode->htotal;
-	hactive = mode->hdisplay;
 	vtotal = mode->vtotal;
-	vactive = mode->vdisplay;
-
-	hactive = mode->hsync_end - mode->hsync_start;
-	vactive = mode->vsync_end - mode->vsync_start;
 
-	h_de_min =  htotal - mode->hsync_start;
-	h_de_max =  h_de_min + mode->hdisplay;
-	v_de_min =  vtotal - mode->vsync_start;
-	v_de_max =  v_de_min + mode->vdisplay;
-
-	iowrite32((hactive << 16) | htotal, private->base + AXI_HDMI_REG_HTIMING1);
-	iowrite32((h_de_min << 16) | h_de_max, private->base + AXI_HDMI_REG_HTIMING2);
-	iowrite32((vactive << 16) | vtotal, private->base + AXI_HDMI_REG_VTIMING1);
-	iowrite32((v_de_min << 16) | v_de_max, private->base + AXI_HDMI_REG_VTIMING2);
+	if (private->embedded_sync) {
+		vactive = mode->vdisplay;
+		hactive = mode->hdisplay;
+
+		iowrite32((hactive << 16) | htotal, private->base + AXI_HDMI_REG_ES_HTIMING);
+		iowrite32((vactive << 16) | vtotal, private->base + AXI_HDMI_REG_ES_VTIMING);
+	} else {
+		hactive = mode->hsync_end - mode->hsync_start;
+		vactive = mode->vsync_end - mode->vsync_start;
+
+		h_de_min =  htotal - mode->hsync_start;
+		h_de_max =  h_de_min + mode->hdisplay;
+		v_de_min =  vtotal - mode->vsync_start;
+		v_de_max =  v_de_min + mode->vdisplay;
+
+		iowrite32((hactive << 16) | htotal, private->base + AXI_HDMI_REG_HTIMING1);
+		iowrite32((h_de_min << 16) | h_de_max, private->base + AXI_HDMI_REG_HTIMING2);
+		iowrite32((vactive << 16) | vtotal, private->base + AXI_HDMI_REG_VTIMING1);
+		iowrite32((v_de_min << 16) | v_de_max, private->base + AXI_HDMI_REG_VTIMING2);
+	}
 
 	clk_set_rate(private->hdmi_clock, mode->clock * 1000);
 }
-- 
1.7.5.4

