From 4d314be731fbee0140b66522341d550d24790a1f Mon Sep 17 00:00:00 2001
From: Zumeng Chen <zumeng.chen@windriver.com>
Date: Thu, 15 Oct 2015 11:38:16 +0800
Subject: [PATCH 67/80] mtd: spi-nor: Support for > 128 Mbit flash devices

This commit 9d87843b comes from:
    https://github.com/Xilinx/linux-xlnx.git

This patch adds support for >128Mbit flash devices.
While the default in spi-nor.c is 4 byte addressing, this patch adds
bank selection and uses the same 3 byte read commands.
Required parameters are added in spi_nor struct.
read_ear and write_ear functions are added with support for commands
used by spansion and micron.
spi_nor_write_ext and spi_nor_read_ext will:
- Check if bank change is required for current address to be accessed and
  change the bank.
- Call spi_nor_read/spi_nor_write functions for an operations within the
  bank bounds.
- Repeat above till required transfer is completed.

Signed-off-by: Harini Katakam <harinik@xilinx.com>
Signed-off-by: Michal Simek <michal.simek@xilinx.com>
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 drivers/mtd/devices/m25p80.c  |   8 +-
 drivers/mtd/spi-nor/spi-nor.c | 240 +++++++++++++++++++++++++++++++++++++-----
 include/linux/mtd/spi-nor.h   |   8 ++
 3 files changed, 228 insertions(+), 28 deletions(-)

diff --git a/drivers/mtd/devices/m25p80.c b/drivers/mtd/devices/m25p80.c
index f8f2464..861d0a4 100644
--- a/drivers/mtd/devices/m25p80.c
+++ b/drivers/mtd/devices/m25p80.c
@@ -50,11 +50,11 @@ static int m25p80_read_reg(struct spi_nor *nor, u8 code, u8 *val, int len)
 
 static void m25p_addr2cmd(struct spi_nor *nor, unsigned int addr, u8 *cmd)
 {
+	int i;
+
 	/* opcode is in cmd[0] */
-	cmd[1] = addr >> (nor->addr_width * 8 -  8);
-	cmd[2] = addr >> (nor->addr_width * 8 - 16);
-	cmd[3] = addr >> (nor->addr_width * 8 - 24);
-	cmd[4] = addr >> (nor->addr_width * 8 - 32);
+	for (i = 1; i <= nor->addr_width; i++)
+		cmd[i] = addr >> (nor->addr_width * 8 - i * 8);
 }
 
 static int m25p_cmdsz(struct spi_nor *nor)
diff --git a/drivers/mtd/spi-nor/spi-nor.c b/drivers/mtd/spi-nor/spi-nor.c
index 5df35ea..5c213f4 100644
--- a/drivers/mtd/spi-nor/spi-nor.c
+++ b/drivers/mtd/spi-nor/spi-nor.c
@@ -198,6 +198,37 @@ static inline int set_4byte(struct spi_nor *nor, struct flash_info *info,
 		return nor->write_reg(nor, SPINOR_OP_BRWR, nor->cmd_buf, 1, 0);
 	}
 }
+
+/**
+ * read_ear - Get the extended/bank address register value
+ * @nor:	Pointer to the flash control structure
+ *
+ * This routine reads the Extended/bank address register value
+ *
+ * Return:	Negative if error occured.
+ */
+static int read_ear(struct spi_nor *nor, struct flash_info *info)
+{
+	int ret;
+	u8 val;
+	u8 code;
+
+	/* This is actually Spansion */
+	if (JEDEC_MFR(info) == CFI_MFR_AMD)
+		code = SPINOR_OP_BRRD;
+	/* This is actually Micron */
+	else if (JEDEC_MFR(info) == CFI_MFR_ST)
+		code = SPINOR_OP_RDEAR;
+	else
+		return -EINVAL;
+
+	ret = nor->read_reg(nor, code, &val, 1);
+	if (ret < 0)
+		return ret;
+
+	return val;
+}
+
 static inline int spi_nor_sr_ready(struct spi_nor *nor)
 {
 	int sr = read_sr(nor);
@@ -257,6 +288,50 @@ static int spi_nor_wait_till_ready(struct spi_nor *nor)
 	return -ETIMEDOUT;
 }
 
+
+/*
+ * Update Extended Address/bank selection Register.
+ * Call with flash->lock locked.
+ */
+static int write_ear(struct spi_nor *nor, u32 addr)
+{
+	u8 code;
+	u8 ear;
+	int ret;
+
+	/* Wait until finished previous write command. */
+	if (wait_till_ready(nor))
+		return 1;
+
+	if (nor->mtd->size <= (0x1000000) << nor->shift)
+		return 0;
+
+	addr = addr % (u32) nor->mtd->size;
+	ear = addr >> 24;
+
+	if ((!nor->isstacked) && (ear == nor->curbank))
+		return 0;
+
+	if (nor->isstacked && (nor->mtd->size <= 0x2000000))
+		return 0;
+
+	if (JEDEC_MFR(nor->jedec_id) == CFI_MFR_AMD)
+		code = SPINOR_OP_BRWR;
+	if (JEDEC_MFR(nor->jedec_id) == CFI_MFR_ST) {
+		write_enable(nor);
+		code = SPINOR_OP_WREAR;
+	}
+	nor->cmd_buf[0] = ear;
+
+	ret = nor->write_reg(nor, code, nor->cmd_buf, 1, 0);
+	if (ret < 0)
+		return ret;
+
+	nor->curbank = ear;
+
+	return 0;
+}
+
 /*
  * Erase the whole flash memory
  *
@@ -781,27 +856,67 @@ static int spi_nor_read(struct mtd_info *mtd, loff_t from, size_t len,
 	struct spi_nor *nor = mtd_to_spi_nor(mtd);
 	int ret;
 
+	ret = nor->read(nor, from, len, retlen, buf);
+
+	return ret;
+}
+
+static int spi_nor_read_ext(struct mtd_info *mtd, loff_t from, size_t len,
+			    size_t *retlen, u_char *buf)
+{
+	struct spi_nor *nor = mtd_to_spi_nor(mtd);
+	u32 addr = from;
+	u32 offset = from;
+	u32 read_len = 0;
+	u32 actual_len = 0;
+	u32 read_count = 0;
+	u32 rem_bank_len = 0;
+	u8 bank = 0;
+	int ret;
+
+#define OFFSET_16_MB 0x1000000
+
 	dev_dbg(nor->dev, "from 0x%08x, len %zd\n", (u32)from, len);
 
 	ret = spi_nor_lock_and_prep(nor, SPI_NOR_OPS_READ);
 	if (ret)
 		return ret;
 
-	if (nor->isparallel == 1)
-		from /= 2;
-	if (nor->isstacked == 1) {
-		if (from >= (nor->mtd->size / 2)) {
-			from = from - (nor->mtd->size / 2);
-			nor->spi->master->flags |= SPI_MASTER_U_PAGE;
-		} else {
-			nor->spi->master->flags &= ~SPI_MASTER_U_PAGE;
+	while (len) {
+		bank = addr / (OFFSET_16_MB << nor->shift);
+		rem_bank_len = ((OFFSET_16_MB << nor->shift) * (bank + 1)) -
+				addr;
+		offset = addr;
+		if (nor->isparallel == 1)
+			offset /= 2;
+		if (nor->isstacked == 1) {
+			if (offset >= (nor->mtd->size / 2)) {
+				offset = offset - (nor->mtd->size / 2);
+				nor->spi->master->flags |= SPI_MASTER_U_PAGE;
+			} else {
+				nor->spi->master->flags &= ~SPI_MASTER_U_PAGE;
+			}
 		}
+		write_ear(nor, offset);
+		if (len < rem_bank_len)
+			read_len = len;
+		else
+			read_len = rem_bank_len;
+
+		ret = spi_nor_read(mtd, offset, read_len, &actual_len, buf);
+		if (ret)
+			return ret;
+
+		addr += actual_len;
+		len -= actual_len;
+		buf += actual_len;
+		read_count += actual_len;
 	}
 
-	ret = nor->read(nor, from, len, retlen, buf);
+	*retlen = read_count;
 
 	spi_nor_unlock_and_unprep(nor, SPI_NOR_OPS_READ);
-	return ret;
+	return 0;
 }
 
 static int sst_write(struct mtd_info *mtd, loff_t to, size_t len,
@@ -883,22 +998,13 @@ static int spi_nor_write(struct mtd_info *mtd, loff_t to, size_t len,
 	int ret;
 
 	dev_dbg(nor->dev, "to 0x%08x, len %zd\n", (u32)to, len);
-
-	ret = spi_nor_lock_and_prep(nor, SPI_NOR_OPS_WRITE);
+	/* Wait until finished previous write command. */
+	ret = spi_nor_wait_till_ready(nor);
 	if (ret)
 		return ret;
 
 	write_enable(nor);
 
-	if (nor->isstacked == 1) {
-		if (to >= (nor->mtd->size / 2)) {
-			to = to - (nor->mtd->size / 2);
-			nor->spi->master->flags |= SPI_MASTER_U_PAGE;
-		} else {
-			nor->spi->master->flags &= ~SPI_MASTER_U_PAGE;
-		}
-	}
-
 	page_offset = to & (nor->page_size - 1);
 
 	/* do all the bytes fit onto one page? */
@@ -926,8 +1032,75 @@ static int spi_nor_write(struct mtd_info *mtd, loff_t to, size_t len,
 		}
 	}
 
-	ret = spi_nor_wait_till_ready(nor);
+	return 0;
+}
+static int spi_nor_write_ext(struct mtd_info *mtd, loff_t to, size_t len,
+			     size_t *retlen, const u_char *buf)
+{
+	struct spi_nor *nor = mtd_to_spi_nor(mtd);
+	u32 addr = to;
+	u32 offset = to;
+	u32 write_len = 0;
+	u32 actual_len = 0;
+	u32 write_count = 0;
+	u32 rem_bank_len = 0;
+	u8 bank = 0;
+	u8 stack_shift = 0;
+	int ret;
+
+#define OFFSET_16_MB 0x1000000
+
+	dev_dbg(nor->dev, "to 0x%08x, len %zd\n", (u32)to, len);
+
+	ret = spi_nor_lock_and_prep(nor, SPI_NOR_OPS_WRITE);
+	if (ret)
+		return ret;
+	if (nor->isparallel)
+		nor->spi->master->flags |= SPI_DATA_STRIPE;
+
+	while (len) {
+		actual_len = 0;
+		if (nor->addr_width == 3) {
+			bank = addr / (OFFSET_16_MB << nor->shift);
+			rem_bank_len = ((OFFSET_16_MB << nor->shift) *
+							(bank + 1)) - addr;
+		}
+		offset = addr;
+
+		if (nor->isstacked == 1) {
+			stack_shift = 1;
+			if (offset >= (nor->mtd->size / 2)) {
+				offset = offset - (nor->mtd->size / 2);
+				nor->spi->master->flags |= SPI_MASTER_U_PAGE;
+			} else {
+				nor->spi->master->flags &= ~SPI_MASTER_U_PAGE;
+			}
+		}
+		/* Die cross over issue is not handled */
+		if (nor->addr_width == 4)
+			rem_bank_len = (nor->mtd->size >> stack_shift) - offset;
+		if (nor->addr_width == 3)
+			write_ear(nor, (offset >> nor->shift));
+		if (len < rem_bank_len)
+			write_len = len;
+		else
+			write_len = rem_bank_len;
+
+		ret = spi_nor_write(mtd, offset, write_len, &actual_len, buf);
+		if (ret)
+			goto write_err;
+
+		addr += actual_len;
+		len -= actual_len;
+		buf += actual_len;
+		write_count += actual_len;
+	}
+
+	*retlen = write_count;
+
 write_err:
+	if (nor->isparallel)
+		nor->spi->master->flags &= ~SPI_DATA_STRIPE;
 	spi_nor_unlock_and_unprep(nor, SPI_NOR_OPS_WRITE);
 	return ret;
 }
@@ -1148,7 +1321,7 @@ int spi_nor_scan(struct spi_nor *nor, const char *name, enum read_mode mode)
 	mtd->flags = MTD_CAP_NORFLASH;
 	mtd->size = info->sector_size * info->n_sectors;
 	mtd->_erase = spi_nor_erase;
-	mtd->_read = spi_nor_read;
+	mtd->_read = spi_nor_read_ext;
 
 	{
 #ifdef CONFIG_OF
@@ -1212,7 +1385,7 @@ int spi_nor_scan(struct spi_nor *nor, const char *name, enum read_mode mode)
 	if (info->flags & SST_WRITE)
 		mtd->_write = sst_write;
 	else
-		mtd->_write = spi_nor_write;
+		mtd->_write = spi_nor_write_ext;
 
 	if (info->flags & USE_FSR)
 		nor->flags |= SNOR_F_USE_FSR;
@@ -1235,6 +1408,7 @@ int spi_nor_scan(struct spi_nor *nor, const char *name, enum read_mode mode)
 	if (info->flags & SPI_NOR_NO_ERASE)
 		mtd->flags |= MTD_NO_ERASE;
 
+	nor->jedec_id = info->jedec_id;
 	mtd->dev.parent = dev;
 	nor->page_size = info->page_size;
 	mtd->writebufsize = nor->page_size;
@@ -1290,6 +1464,21 @@ int spi_nor_scan(struct spi_nor *nor, const char *name, enum read_mode mode)
 	if (info->addr_width)
 		nor->addr_width = info->addr_width;
 	else if (mtd->size > 0x1000000) {
+#ifdef CONFIG_OF
+		np_spi = of_get_next_parent(np);
+		if (of_property_match_string(np_spi, "compatible",
+					     "xlnx,zynq-qspi-1.0") >= 0) {
+			int status;
+
+			nor->addr_width = 3;
+			set_4byte(nor, info->jedec_id, 0);
+			status = read_ear(nor, info->jedec_id);
+			if (status < 0)
+				dev_warn(dev, "failed to read ear reg\n");
+			else
+				nor->curbank = status & EAR_SEGMENT_MASK;
+		} else {
+#endif
 		/* enable 4-byte addressing if the device exceeds 16MiB */
 		nor->addr_width = 4;
 		if (JEDEC_MFR(info) == CFI_MFR_AMD) {
@@ -1314,6 +1503,9 @@ int spi_nor_scan(struct spi_nor *nor, const char *name, enum read_mode mode)
 			mtd->erasesize = info->sector_size;
 		} else
 			set_4byte(nor, info, 1);
+#ifdef CONFIG_OF
+		}
+#endif
 	} else {
 		nor->addr_width = 3;
 	}
diff --git a/include/linux/mtd/spi-nor.h b/include/linux/mtd/spi-nor.h
index 6a06020..ff58017 100644
--- a/include/linux/mtd/spi-nor.h
+++ b/include/linux/mtd/spi-nor.h
@@ -36,6 +36,8 @@
 #define SPINOR_OP_RDID		0x9f	/* Read JEDEC ID */
 #define SPINOR_OP_RDCR		0x35	/* Read configuration register */
 #define SPINOR_OP_RDFSR		0x70	/* Read flag status register */
+#define SPINOR_OP_WREAR		0xc5	/* Write Extended Address Register */
+#define SPINOR_OP_RDEAR		0xc8	/* Read Extended Address Register */
 
 /* 4-byte address opcodes - used on Spansion and some Macronix flashes. */
 #define SPINOR_OP_READ4		0x13	/* Read data bytes (low frequency) */
@@ -56,6 +58,7 @@
 
 /* Used for Spansion flashes only. */
 #define SPINOR_OP_BRWR		0x17	/* Bank register write */
+#define	SPINOR_OP_BRRD		0x16	/* Bank register read */
 
 /* Used for Micron flashes only. */
 #define SPINOR_OP_RD_EVCR      0x65    /* Read EVCR register */
@@ -81,6 +84,9 @@
 /* Configuration Register bits. */
 #define CR_QUAD_EN_SPAN		0x2	/* Spansion Quad I/O */
 
+/* Extended/Bank Address Register bits */
+#define EAR_SEGMENT_MASK	0x7	/* 128 Mb segment mask */
+
 enum read_mode {
 	SPI_NOR_NORMAL = 0,
 	SPI_NOR_FAST,
@@ -172,6 +178,8 @@ struct spi_nor {
 	u8			read_dummy;
 	u8			program_opcode;
 	enum read_mode		flash_read;
+	u32			jedec_id;
+	u16			curbank;
 	bool			shift;
 	bool			isparallel;
 	bool			isstacked;
-- 
2.0.2

