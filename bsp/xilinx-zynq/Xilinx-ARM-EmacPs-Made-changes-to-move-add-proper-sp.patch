From 636fbd4c1ecb3c48a5f904c0b60e90be7f4be453 Mon Sep 17 00:00:00 2001
From: Zhong Hongbo <hongbo.zhong@windriver.com>
Date: Tue, 21 Aug 2012 16:28:15 +0800
Subject: [PATCH 35/36] Xilinx: ARM: EmacPs: Made changes to move/add proper
 spin_locks

The existing code had some potential issues for SMP case with
regards to spin lock handling. This patch fixes all such issues
and puts proper spin_locks (and unlocks) at appropriate places.

Signed-off-by: Anirudha <anirudh@xilinx.com>
Integrated-by: Hongbo Zhong <hongbo.zhong@windriver.com>
---
 drivers/net/ethernet/xilinx/xilinx_emacps.c |   30 ++++++++++++++++++---------
 1 file changed, 20 insertions(+), 10 deletions(-)

diff --git a/drivers/net/ethernet/xilinx/xilinx_emacps.c b/drivers/net/ethernet/xilinx/xilinx_emacps.c
index 80b6da7..0e7f34f 100644
--- a/drivers/net/ethernet/xilinx/xilinx_emacps.c
+++ b/drivers/net/ethernet/xilinx/xilinx_emacps.c
@@ -1194,12 +1194,14 @@ static irqreturn_t xemacps_interrupt(int irq, void *dev_id)
 	struct net_local *lp = netdev_priv(ndev);
 	u32 regisr;
 
+	spin_lock(&lp->lock);
+
 	regisr = xemacps_read(lp->baseaddr, XEMACPS_ISR_OFFSET);
 
-	if (unlikely(!regisr))
+	if (unlikely(!regisr)) {
+		spin_unlock(&lp->lock);
 		return IRQ_NONE;
-
-	spin_lock(&lp->lock);
+	}
 
 	while (regisr) {
 		/* acknowledge interrupt and clear it */
@@ -1567,15 +1569,20 @@ static int xemacps_open(struct net_device *ndev)
 {
 	struct net_local *lp = netdev_priv(ndev);
 	int rc;
+	unsigned long flags;
 
+	spin_lock_irqsave(&lp->lock, flags);
 	dev_dbg(&lp->pdev->dev, "open\n");
-	if (!is_valid_ether_addr(ndev->dev_addr))
+	if (!is_valid_ether_addr(ndev->dev_addr)) {
+		spin_unlock_irqrestore(&lp->lock, flags);
 		return  -EADDRNOTAVAIL;
+	}
 
 	rc = xemacps_descriptor_init(lp);
 	if (rc) {
 		printk(KERN_ERR "%s Unable to allocate DMA memory, rc %d\n",
 		ndev->name, rc);
+		spin_unlock_irqrestore(&lp->lock, flags);
 		return rc;
 	}
 
@@ -1583,6 +1590,7 @@ static int xemacps_open(struct net_device *ndev)
 	if (rc) {
 		printk(KERN_ERR "%s Unable to setup BD rings, rc %d\n",
 		ndev->name, rc);
+		spin_unlock_irqrestore(&lp->lock, flags);
 		return rc;
 	}
 	xemacps_init_hw(lp);
@@ -1595,9 +1603,11 @@ static int xemacps_open(struct net_device *ndev)
 			kfree(lp->mii_bus->irq);
 			mdiobus_free(lp->mii_bus);
 		}
+		spin_unlock_irqrestore(&lp->lock, flags);
 		return -ENXIO;
 	}
 
+	spin_unlock_irqrestore(&lp->lock, flags);
 	netif_carrier_on(ndev);
 
 	netif_start_queue(ndev);
@@ -1724,6 +1734,7 @@ static int xemacps_start_xmit(struct sk_buff *skb, struct net_device *ndev)
 	struct xemacps_bd *bdptr, *bdptrs;
 	void       *virt_addr;
 	skb_frag_t *frag;
+	unsigned long flags;
 
 #ifdef DEBUG_VERBOSE_TX
 	printk(KERN_INFO "%s: TX data:", __func__);
@@ -1735,19 +1746,19 @@ static int xemacps_start_xmit(struct sk_buff *skb, struct net_device *ndev)
 	printk("\n");
 #endif
 
+	spin_lock_irqsave(&lp->lock, flags);
 	nr_frags = skb_shinfo(skb)->nr_frags + 1;
-	spin_lock_irq(&lp->lock);
 
 	if (nr_frags < lp->tx_ring.freecnt) {
 		rc = xemacps_bdringalloc(&lp->tx_ring, nr_frags, &bdptr);
 		if (rc) {
 			netif_stop_queue(ndev); /* stop send queue */
-			spin_unlock_irq(&lp->lock);
+			spin_unlock_irqrestore(&lp->lock, flags);
 			return rc;
 		}
 	} else {
 		netif_stop_queue(ndev); /* stop send queue */
-		spin_unlock_irq(&lp->lock);
+		spin_unlock_irqrestore(&lp->lock, flags);
 		return NETDEV_TX_BUSY;
 	}
 
@@ -1810,16 +1821,15 @@ static int xemacps_start_xmit(struct sk_buff *skb, struct net_device *ndev)
 		xemacps_bdringunalloc(&lp->tx_ring, nr_frags, bdptrs);
 		printk(KERN_ERR "%s can not send, commit TX buffer desc\n",
 			ndev->name);
-		spin_unlock_irq(&lp->lock);
+		spin_unlock_irqrestore(&lp->lock, flags);
 		return rc;
 	} else {
 		regval = xemacps_read(lp->baseaddr, XEMACPS_NWCTRL_OFFSET);
 		xemacps_write(lp->baseaddr, XEMACPS_NWCTRL_OFFSET,
 			(regval | XEMACPS_NWCTRL_STARTTX_MASK));
 	}
-
-	spin_unlock_irq(&lp->lock);
 	ndev->trans_start = jiffies;
+	spin_unlock_irqrestore(&lp->lock, flags);
 
 	return rc;
 }
-- 
1.7.9.7

