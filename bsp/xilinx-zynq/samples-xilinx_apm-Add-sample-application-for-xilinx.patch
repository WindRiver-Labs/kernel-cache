From cc47488ff055090f9f8ca05f4ab62a46d89df74c Mon Sep 17 00:00:00 2001
From: Subbaraya Sundeep Bhatta <subbaraya.sundeep.bhatta@xilinx.com>
Date: Mon, 16 Sep 2013 18:15:25 +0530
Subject: [PATCH 030/793] samples: xilinx_apm: Add sample application for
 xilinx_apm

Added xilinx AXI performance monitor sample application

Signed-off-by: Subbaraya Sundeep Bhatta <sbhatta@xilinx.com>
Signed-off-by: Michal Simek <michal.simek@xilinx.com>
---
 samples/xilinx_apm/Makefile   |   71 +++
 samples/xilinx_apm/main.c     |  134 +++++
 samples/xilinx_apm/xaxipmon.c | 1239 +++++++++++++++++++++++++++++++++++++++++
 samples/xilinx_apm/xaxipmon.h |  936 +++++++++++++++++++++++++++++++
 4 files changed, 2380 insertions(+), 0 deletions(-)
 create mode 100644 samples/xilinx_apm/Makefile
 create mode 100644 samples/xilinx_apm/main.c
 create mode 100644 samples/xilinx_apm/xaxipmon.c
 create mode 100644 samples/xilinx_apm/xaxipmon.h

diff --git a/samples/xilinx_apm/Makefile b/samples/xilinx_apm/Makefile
new file mode 100644
index 0000000..6182750
--- /dev/null
+++ b/samples/xilinx_apm/Makefile
@@ -0,0 +1,71 @@
+#
+# 'make depend' uses makedepend to automatically generate dependencies
+#               (dependencies are added to end of Makefile)
+# 'make'        build executable file 'mycc'
+# 'make clean'  removes all .o and executable files
+#
+
+# define the C compiler to use
+CC = $(CROSS_COMPILE)gcc
+
+# define any compile-time flags
+CFLAGS = -Wall -g
+
+# define any directories containing header files other than /usr/include
+#
+INCLUDES =
+
+# define library paths in addition to /usr/lib
+#   if I wanted to include libraries not in /usr/lib I'd specify
+#   their path using -Lpath, something like:
+LFLAGS =
+
+# define any libraries to link into executable:
+#   if I want to link in libraries (libx.so or libx.a) I use the -llibname
+#   option, something like (this will link in libmylib.so and libm.so:
+LIBS =  -lm
+
+# define the C source files
+SRCS = main.c xaxipmon.c
+
+# define the C object files
+#
+# This uses Suffix Replacement within a macro:
+#   $(name:string1=string2)
+#         For each word in 'name' replace 'string1' with 'string2'
+# Below we are replacing the suffix .c of all words in the macro SRCS
+# with the .o suffix
+#
+OBJS = $(SRCS:.c=.o)
+
+# define the executable file
+MAIN = main
+
+#
+# The following part of the makefile is generic; it can be used to
+# build any executable just by changing the definitions above and by
+# deleting dependencies appended to the file from 'make depend'
+#
+
+.PHONY: depend clean
+
+all:    $(MAIN)
+	@echo  Xilinx AXI Performance Monitor application compiled
+
+$(MAIN): $(OBJS)
+	$(CC) $(CFLAGS) $(INCLUDES) -o $(MAIN) $(OBJS) $(LFLAGS) $(LIBS)
+
+# this is a suffix replacement rule for building .o's from .c's
+# it uses automatic variables $<: the name of the prerequisite of
+# the rule(a .c file) and $@: the name of the target of the rule (a .o file)
+# (see the gnu make manual section about automatic variables)
+.c.o:
+	$(CC) $(CFLAGS) $(INCLUDES) -c $<  -o $@
+
+clean:
+	$(RM) *.o *~ $(MAIN)
+
+depend: $(SRCS)
+	makedepend $(INCLUDES) $^
+
+# DO NOT DELETE THIS LINE -- make depend needs it
diff --git a/samples/xilinx_apm/main.c b/samples/xilinx_apm/main.c
new file mode 100644
index 0000000..d4c8f2a
--- /dev/null
+++ b/samples/xilinx_apm/main.c
@@ -0,0 +1,134 @@
+/*
+ * Xilinx AXI Performance Monitor Example
+ *
+ * Copyright (c) 2013 Xilinx Inc.
+ *
+ * The code may be used by anyone for any purpose and can serve as a
+ * starting point for developing applications using Xilinx AXI
+ * Performance Monitor.
+ *
+ * This example based on Xilinx AXI Performance Monitor UIO driver shows
+ * sequence to read metrics from Xilinx AXI Performance Monitor IP.
+ * User need to provide the uio device file with option -d:
+ * main -d /dev/uio0, say /dev/uio0 as device file for AXI Performance
+ * Monitor driver. User need not clear Interrupt Status Register after
+ * waiting for interrupt on read since driver clears it.
+ */
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <string.h>
+#include <sys/mman.h>
+#include <fcntl.h>
+#include <sys/stat.h>
+#include <errno.h>
+#include <sys/msg.h>
+#include <sys/ipc.h>
+#include <stdint.h>
+#include "xaxipmon.h"
+
+#define MAP_SIZE 4096
+
+void usage(void)
+{
+	printf("*argv[0] -d <UIO_DEV_FILE> -i|-o <VALUE>\n");
+	printf(" -d UIO device file. e.g. /dev/uio0");
+	return;
+}
+
+static void start(int fd)
+{
+	u8 slot = 2;
+	int tmp;
+	u32 isr;
+
+	setmetrics(slot, XAPM_METRIC_SET_4, XAPM_METRIC_COUNTER_0);
+	setsampleinterval(0x3FFFFFF);
+
+	loadsic();
+
+	intrenable(XAPM_IXR_SIC_OVERFLOW_MASK);
+
+	intrglobalenable();
+
+	enablemetricscounter();
+
+	enablesic();
+
+	isr = intrgetstatus();
+	/* Wait for SIC overflow interrupt */
+	if (read(fd, &tmp, 4) < 0)
+		perror("Read\n");
+	/* Driver clears the interrupt and occured interrupt status is
+		stored in param->isr */
+	isr = intrgetstatus();
+	if (isr & XAPM_IXR_SIC_OVERFLOW_MASK)
+		disablesic();
+
+	disablemetricscounter();
+
+	intrdisable(XAPM_IXR_SIC_OVERFLOW_MASK);
+
+	intrglobaldisable();
+
+	printf("Required metrics: %u\n",
+		getsampledmetriccounter(XAPM_METRIC_COUNTER_0) *
+		params->scalefactor);
+}
+
+int main(int argc, char *argv[])
+{
+	int c;
+	char *uiod;
+	int fd;
+
+	while ((c = getopt(argc, argv, "d:h")) != -1) {
+		switch (c) {
+		case 'd':
+			uiod = optarg;
+			break;
+		case 'h':
+			usage();
+			return 0;
+		default:
+			printf("invalid option: %c\n", (char)c);
+			usage();
+			return -1;
+		}
+	}
+
+	/* Open the UIO device file */
+	fd = open(uiod, O_RDWR);
+	if (fd < 1) {
+		perror(argv[0]);
+		printf("Invalid UIO device file:%s.\n", uiod);
+		usage();
+		return -1;
+	}
+
+	baseaddr = (u32)mmap(0, MAP_SIZE , PROT_READ|PROT_WRITE,
+				MAP_SHARED , fd, 0);
+	if ((u32 *)baseaddr == MAP_FAILED)
+		perror("mmap failed\n");
+
+	/* mmap the UIO device */
+	params = (struct xapm_param *)mmap(0, MAP_SIZE , PROT_READ|PROT_WRITE,
+				MAP_SHARED , fd, getpagesize());
+	if (params == MAP_FAILED)
+		perror("mmap failed\n");
+
+	if (params->mode == 1)
+		printf("AXI PMON is in Advanced Mode\n");
+	else if (params->mode == 2)
+		printf("AXI PMON is in Profile Mode\n");
+	else
+		printf("AXI PMON is in trace Mode\n");
+
+	start(fd);
+
+	close(fd);
+	munmap((u32 *)baseaddr, MAP_SIZE);
+	munmap(params, MAP_SIZE);
+
+	return 0;
+}
diff --git a/samples/xilinx_apm/xaxipmon.c b/samples/xilinx_apm/xaxipmon.c
new file mode 100644
index 0000000..ef50713
--- /dev/null
+++ b/samples/xilinx_apm/xaxipmon.c
@@ -0,0 +1,1239 @@
+#include "xaxipmon.h"
+/*****************************************************************************/
+/**
+*
+* This function resets all Metric Counters and Sampled Metric Counters of
+* AXI Performance Monitor.
+*
+* @return	XST_SUCCESS
+*
+*
+* @note		None.
+*
+******************************************************************************/
+int resetmetriccounter(void)
+{
+	u32 regval;
+
+	/*
+	 * Write the reset value to the Control register to reset
+	 * Metric counters
+	 */
+	regval = readreg(baseaddr, XAPM_CTL_OFFSET);
+	writereg(baseaddr, XAPM_CTL_OFFSET,
+					(regval | XAPM_CR_MCNTR_RESET_MASK));
+	/*
+	 * Release from Reset
+	 */
+	writereg(baseaddr, XAPM_CTL_OFFSET,
+				(regval & ~(XAPM_CR_MCNTR_RESET_MASK)));
+	return XST_SUCCESS;
+
+}
+
+/*****************************************************************************/
+/**
+*
+* This function resets Global Clock Counter of AXI Performance Monitor
+*
+* @return	None.
+*
+* @note		None.
+*
+******************************************************************************/
+void resetglobalclkcounter(void)
+{
+
+	u32 regval;
+
+	/*
+	 * Write the reset value to the Control register to reset
+	 * Global Clock Counter
+	 */
+	regval = readreg(baseaddr, XAPM_CTL_OFFSET);
+	writereg(baseaddr, XAPM_CTL_OFFSET,
+					(regval | XAPM_CR_GCC_RESET_MASK));
+
+	/*
+	 * Release from Reset
+	 */
+	writereg(baseaddr, XAPM_CTL_OFFSET,
+				(regval & ~(XAPM_CR_GCC_RESET_MASK)));
+
+}
+
+/*****************************************************************************/
+/**
+*
+* This function resets Streaming FIFO of AXI Performance Monitor
+*
+* @return	XST_SUCCESS
+*
+* @note		None.
+*
+******************************************************************************/
+int resetfifo(void)
+{
+	u32 regval;
+
+	/* Check Event Logging is enabled in Hardware */
+	if (params->eventlog == 0)
+		/*Event Logging not enabled in Hardware*/
+		return XST_SUCCESS;
+
+	/*
+	 * Write the reset value to the Control register to reset
+	 * FIFO
+	 */
+	regval = readreg(baseaddr, XAPM_CTL_OFFSET);
+	writereg(baseaddr, XAPM_CTL_OFFSET,
+					(regval | XAPM_CR_FIFO_RESET_MASK));
+	/*
+	 * Release from Reset
+	 */
+	writereg(baseaddr, XAPM_CTL_OFFSET,
+				(regval & ~(XAPM_CR_FIFO_RESET_MASK)));
+
+	return XST_SUCCESS;
+}
+
+/****************************************************************************/
+/**
+*
+* This function sets Ranges for Incrementers depending on parameters passed.
+*
+* @param	incrementer specifies the Incrementer for which Ranges
+*		need to be set
+* @param	rangehigh specifies the Upper limit in 32 bit Register
+* @param	rangelow specifies the Lower limit in 32 bit Register
+*
+* @return	None.
+*
+* @note		None
+*
+*****************************************************************************/
+void setincrementerrange(u8 incrementer, u16 rangehigh, u16 rangelow)
+{
+	u32 regval;
+
+	/*
+	 * Write to the specified Range register
+	 */
+	regval = rangehigh << 16;
+	regval |= rangelow;
+	writereg(baseaddr,
+		(XAPM_RANGE0_OFFSET + (incrementer * 16)), regval);
+}
+
+/****************************************************************************/
+/**
+*
+* This function returns the Ranges of Incrementers Registers.
+*
+* @param	incrementer specifies the Incrementer for which Ranges
+*		need to be returned.
+* @param	rangehigh specifies the user reference variable which returns
+*		the Upper Range Value of the specified Incrementer.
+* @param	rangelow specifies the user reference variable which returns
+*		the Lower Range Value of the specified Incrementer.
+*
+* @return	None.
+*
+* @note		None
+*
+*****************************************************************************/
+void getincrementerrange(u8 incrementer, u16 *rangehigh, u16 *rangelow)
+{
+	u32 regval;
+
+	regval = readreg(baseaddr, (XAPM_RANGE0_OFFSET +
+					(incrementer * 16)));
+
+	*rangelow = regval & 0xFFFF;
+	*rangehigh = (regval >> 16) & 0xFFFF;
+}
+
+/****************************************************************************/
+/**
+*
+* This function sets the Sample Interval Register
+*
+* @param	sampleinterval is the Sample Interval
+*
+* @return	None
+*
+* @note		None.
+*
+*****************************************************************************/
+void setsampleinterval(u32 sampleinterval)
+{
+	/*
+	 * Set Sample Interval
+	 */
+	writereg(baseaddr, XAPM_SI_LOW_OFFSET, sampleinterval);
+
+}
+
+/****************************************************************************/
+/**
+*
+* This function returns the contents of Sample Interval Register
+*
+* @param	sampleinterval is a pointer where Sample Interval register
+*		contents are returned.
+* @return	None.
+*
+* @note		None.
+*
+******************************************************************************/
+void getsampleinterval(u32 *sampleinterval)
+{
+	/*
+	 * Set Sample Interval Lower
+	 */
+	*sampleinterval = readreg(baseaddr, XAPM_SI_LOW_OFFSET);
+
+}
+
+/****************************************************************************/
+/**
+*
+* This function sets metrics for specified Counter in the corresponding
+* Metric Selector Register.
+*
+* @param	slot is the slot ID for which specified counter has to
+*		be connected.
+* @param	metrics is one of the Metric Sets. User has to use
+*		XAPM_METRIC_SET_* macros in xaxipmon.h for this parameter
+* @param	counter is the Counter Number.
+*		The valid values are 0 to 9.
+*
+* @return	XST_SUCCESS if Success
+*		XST_FAILURE if Failure
+*
+* @note		None.
+*
+*****************************************************************************/
+int setmetrics(u8 slot, u8 metrics, u8 counter)
+{
+	u32 regval;
+	u32 mask;
+
+	/* Find mask value to force zero in counternum byte range */
+	if (counter == 0 || counter == 4 || counter == 8)
+		mask = 0xFFFFFF00;
+	else if (counter == 1 || counter == 5 || counter == 9)
+		mask = 0xFFFF00FF;
+	else if (counter == 2 || counter == 6)
+		mask = 0xFF00FFFF;
+	else
+		mask = 0x00FFFFFF;
+
+	if (counter <= 3) {
+		regval = readreg(baseaddr, XAPM_MSR0_OFFSET);
+		regval = regval & mask;
+		regval = regval | (metrics << (counter * 8));
+		regval = regval | (slot << (counter * 8 + 5));
+		writereg(baseaddr, XAPM_MSR0_OFFSET, regval);
+	} else if ((counter >= 4) && (counter <= 7)) {
+		counter = counter - 4;
+		regval = readreg(baseaddr, XAPM_MSR1_OFFSET);
+		regval = regval & mask;
+		regval = regval | (metrics << (counter * 8));
+		regval = regval | (slot << (counter * 8 + 5));
+		writereg(baseaddr, XAPM_MSR1_OFFSET, regval);
+	} else {
+		counter = counter - 8;
+		regval = readreg(baseaddr, XAPM_MSR2_OFFSET);
+
+		regval = regval & mask;
+		regval = regval | (metrics << (counter * 8));
+		regval = regval | (slot << (counter * 8 + 5));
+		writereg(baseaddr, XAPM_MSR2_OFFSET, regval);
+	}
+	return XST_SUCCESS;
+}
+
+/*****************************************************************************/
+/**
+*
+* This function returns metrics in the specified Counter from the corresponding
+* Metric Selector Register.
+*
+* @param	counter is the Counter Number.
+*		The valid values are 0 to 9.
+* @param	metrics is a reference parameter from application where metrics
+*		of specified counter is filled.
+* @praram	slot is a reference parameter in which slot Id of
+*		specified counter is filled
+* @return	XST_SUCCESS if Success
+*		XST_FAILURE if Failure
+*
+* @note		None.
+*
+*****************************************************************************/
+int getmetrics(u8 counter, u8 *metrics, u8 *slot)
+{
+	u32 regval;
+
+	if (counter <= 3) {
+		regval = readreg(baseaddr, XAPM_MSR0_OFFSET);
+		*metrics = (regval >> (counter * 8)) & 0x1F;
+		*slot	= (regval >> (counter * 8 + 5)) & 0x7;
+	} else if ((counter >= 4) && (counter <= 7)) {
+		counter = counter - 4;
+		regval = readreg(baseaddr, XAPM_MSR1_OFFSET);
+		*metrics = (regval >> (counter * 8)) & 0x1F;
+		*slot	= (regval >> (counter * 8 + 5)) & 0x7;
+	} else {
+		counter = counter - 8;
+		regval = readreg(baseaddr, XAPM_MSR2_OFFSET);
+		*metrics = (regval >> (counter * 8)) & 0x1F;
+		*slot	= (regval >> (counter * 8 + 5)) & 0x7;
+	}
+	return XST_SUCCESS;
+}
+
+/****************************************************************************/
+/**
+*
+* This function returns the contents of the Global Clock Counter Register.
+*
+* @param	cnthigh is the user space pointer with which upper 32 bits
+*		of Global Clock Counter has to be filled
+* @param	cntlow is the user space pointer with which lower 32 bits
+*		of Global Clock Counter has to be filled
+*
+* @return	None.
+*
+* @note		None.
+*
+*****************************************************************************/
+void getglobalclkcounter(u32 *cnthigh, u32 *cntlow)
+{
+	*cnthigh = 0x0;
+	*cntlow  = 0x0;
+
+	/*
+	 * If Counter width is 64 bit then Counter Value has to be
+	 * filled at CntHighValue address also.
+	 */
+	if (params->globalcntwidth == 64) {
+		/* Bits[63:32] exists at XAPM_GCC_HIGH_OFFSET */
+		*cnthigh = readreg(baseaddr, XAPM_GCC_HIGH_OFFSET);
+	}
+	/* Bits[31:0] exists at XAPM_GCC_LOW_OFFSET */
+	*cntlow = readreg(baseaddr, XAPM_GCC_LOW_OFFSET);
+}
+
+/****************************************************************************/
+/**
+*
+* This function returns the contents of the Metric Counter Register.
+*
+* @param	counter is the number of the Metric Counter to be read.
+*		Use the XAPM_METRIC_COUNTER* defines for the counter number in
+*		xaxipmon.h. The valid values are 0 (XAPM_METRIC_COUNTER_0) to
+*		9 (XAPM_METRIC_COUNTER_9).
+* @return	regval is the content of specified Metric Counter.
+*
+* @note		None.
+*
+*****************************************************************************/
+u32 getmetriccounter(u32 counter)
+{
+	u32 regval;
+
+	regval = readreg(baseaddr,
+				(XAPM_MC0_OFFSET + (counter * 16)));
+	return regval;
+}
+
+/****************************************************************************/
+/**
+*
+* This function returns the contents of the Sampled Metric Counter Register.
+*
+* @param	counter is the number of the Sampled Metric Counter to read.
+*		Use the XAPM_METRIC_COUNTER* defines for the counter number in
+*		xaxipmon.h. The valid values are 0 (XAPM_METRIC_COUNTER_0) to
+*		9 (XAPM_METRIC_COUNTER_9).
+*
+* @return	regval is the content of specified Sampled Metric Counter.
+*
+* @note		None.
+*
+*****************************************************************************/
+u32 getsampledmetriccounter(u32 counter)
+{
+	u32 regval;
+
+	regval = readreg(baseaddr, (XAPM_SMC0_OFFSET +
+						(counter * 16)));
+	return regval;
+}
+
+/****************************************************************************/
+/**
+*
+* This function returns the contents of the Incrementer Register.
+*
+* @param	incrementer is the number of the Incrementer register to
+*		read.Use the XAPM_INCREMENTER_* defines for the Incrementer
+*		number.The valid values are 0 (XAPM_INCREMENTER_0) to
+*		9 (XAPM_INCREMENTER_9).
+* @param	incrementer is the number of the specified Incrementer
+*		register
+* @return	regval is content of specified Metric Incrementer register.
+*
+* @note		None.
+*
+*****************************************************************************/
+u32 getincrementer(u32 incrementer)
+{
+	u32 regval;
+
+	regval = readreg(baseaddr, (XAPM_INC0_OFFSET +
+						(incrementer * 16)));
+	return regval;
+}
+
+/****************************************************************************/
+/**
+*
+* This function returns the contents of the Sampled Incrementer Register.
+*
+* @param	incrementer is the number of the Sampled Incrementer
+*		register to read.Use the XAPM_INCREMENTER_* defines for the
+*		Incrementer number.The valid values are 0 (XAPM_INCREMENTER_0)
+*		to 9 (XAPM_INCREMENTER_9).
+* @param	incrementer is the number of the specified Sampled
+*		Incrementer register
+* @return	regval is content of specified Sampled Incrementer register.
+*
+* @note		None.
+*
+*****************************************************************************/
+u32 getsampledincrementer(u32 incrementer)
+{
+	u32 regval;
+
+	regval = readreg(baseaddr, (XAPM_SINC0_OFFSET +
+					(incrementer * 16)));
+	return regval;
+}
+
+/****************************************************************************/
+/**
+*
+* This function sets Software-written Data Register.
+*
+* @param	swdata is the Software written Data.
+*
+* @return	None.
+*
+* @note		None.
+*
+*****************************************************************************/
+void setswdatareg(u32 swdata)
+{
+	/*
+	 * Set Software-written Data Register
+	 */
+	writereg(baseaddr, XAPM_SWD_OFFSET, swdata);
+}
+
+/****************************************************************************/
+/**
+*
+* This function returns contents of Software-written Data Register.
+*
+* @return	swdata.
+*
+* @note		None.
+*
+*****************************************************************************/
+u32 getswdatareg(void)
+{
+	u32 swdata;
+
+	/*
+	 * Set Metric Selector Register
+	 */
+	swdata = (u32)readreg(baseaddr, XAPM_SWD_OFFSET);
+	return swdata;
+}
+
+/*****************************************************************************/
+/**
+*
+* This function enables the following in the AXI Performance Monitor:
+*   - Event logging
+*
+* @param        flagenables is a value to write to the flag enables
+*               register defined by XAPM_FEC_OFFSET. It is recommended
+*               to use the XAPM_FEC_*_MASK mask bits to generate.
+*               A value of 0x0 will disable all events to the event
+*               log streaming FIFO.
+*
+* @return       XST_SUCCESS
+*
+* @note         None
+*
+******************************************************************************/
+int starteventlog(u32 flagenables)
+{
+	u32 regval;
+
+	/* Read current register value */
+	regval = readreg(baseaddr, XAPM_CTL_OFFSET);
+	/* Now write to flag enables register */
+	writereg(baseaddr, XAPM_FEC_OFFSET, flagenables);
+	/* Write the new value to the Control register to
+	 *	enable event logging */
+	writereg(baseaddr, XAPM_CTL_OFFSET,
+			regval | XAPM_CR_EVENTLOG_ENABLE_MASK);
+	return XST_SUCCESS;
+}
+
+/*****************************************************************************/
+/**
+*
+* This function disables the following in the AXI Performance Monitor:
+*   - Event logging
+*
+* @return       XST_SUCCESS
+*
+* @note         None
+*
+******************************************************************************/
+int stopeventlog(void)
+{
+	u32 regval;
+
+	/* Read current register value */
+	regval = readreg(baseaddr, XAPM_CTL_OFFSET);
+
+	/* Write the new value to the Control register to disable
+	 * event logging */
+	writereg(baseaddr, XAPM_CTL_OFFSET,
+				regval & ~XAPM_CR_EVENTLOG_ENABLE_MASK);
+
+	return XST_SUCCESS;
+}
+
+/*****************************************************************************/
+/**
+*
+* This function enables the following in the AXI Performance Monitor:
+*   - Global clock counter
+*   - All metric counters
+*   - All sampled metric counters
+*
+* @param    sampleinterval is the sample interval
+* @return   XST_SUCCESS
+*
+* @note	    None
+******************************************************************************/
+int startcounters(u32 sampleinterval)
+{
+	u32 regval;
+
+	/* Read current register value */
+	regval = readreg(baseaddr, XAPM_CTL_OFFSET);
+
+	/* Global Clock Counter is present in Advanced Mode only */
+	if (params->mode == 1)
+		regval = regval | XAPM_CR_GCC_ENABLE_MASK;
+	/*
+	 * Write the new value to the Control register to enable
+	 * global clock counter and metric counters
+	 */
+	writereg(baseaddr, XAPM_CTL_OFFSET, regval | XAPM_CR_MCNTR_ENABLE_MASK);
+
+	/* Set, enable, and load sampled counters */
+	setsampleinterval(sampleinterval);
+	loadsic();
+	enablesic();
+
+	return XST_SUCCESS;
+}
+
+/****************************************************************************/
+/**
+*
+* This function disables the following in the AXI Performance Monitor:
+*   - Global clock counter
+*   - All metric counters
+*
+* @return       XST_SUCCESS
+*
+* @note         None
+*
+******************************************************************************/
+int stopcounters(void)
+{
+	u32 regval;
+
+	/* Read current register value */
+	regval = readreg(baseaddr, XAPM_CTL_OFFSET);
+
+	/* Global Clock Counter is present in Advanced Mode only */
+	if (params->mode == 1)
+		regval = regval & ~XAPM_CR_GCC_ENABLE_MASK;
+
+	/*
+	 * Write the new value to the Control register to disable
+	 * global clock counter and metric counters
+	 */
+	writereg(baseaddr, XAPM_CTL_OFFSET,
+			regval & ~XAPM_CR_MCNTR_ENABLE_MASK);
+
+	return XST_SUCCESS;
+}
+
+/*****************************************************************************/
+/**
+*
+* This function enables Metric Counters.
+*
+* @return	None
+*
+* @note		None
+*
+******************************************************************************/
+void enablemetricscounter(void)
+{
+	u32 regval;
+
+	regval = readreg(baseaddr, XAPM_CTL_OFFSET);
+	writereg(baseaddr, XAPM_CTL_OFFSET,
+					regval | XAPM_CR_MCNTR_ENABLE_MASK);
+}
+/****************************************************************************/
+/**
+*
+* This function disables the Metric Counters.
+*
+* @return	None
+*
+* @note		None
+*
+*****************************************************************************/
+void disablemetricscounter(void)
+{
+	u32 regval;
+
+	regval = readreg(baseaddr, XAPM_CTL_OFFSET);
+
+	writereg(baseaddr, XAPM_CTL_OFFSET,
+					regval & ~(XAPM_CR_MCNTR_ENABLE_MASK));
+}
+
+/****************************************************************************/
+/**
+*
+* This function sets the Upper and Lower Ranges for specified Metric Counter
+* Log Enable Register.Event Logging starts when corresponding Metric Counter
+* value falls in between these ranges
+*
+* @param	counter is the Metric Counter number for which
+*		Ranges are to be assigned.Use the XAPM_METRIC_COUNTER*
+*		defines for the counter number in xaxipmon.h.
+*		The valid values are 0 (XAPM_METRIC_COUNTER_0) to
+*		9 (XAPM_METRIC_COUNTER_9).
+* @param	rangehigh specifies the Upper limit in 32 bit Register
+* @param	rangelow specifies the Lower limit in 32 bit Register
+* @return	None
+*
+* @note		None.
+*
+*****************************************************************************/
+void setlogenableranges(u32 counter, u16 rangehigh, u16 rangelow)
+{
+	u32 regval;
+
+	/*
+	 * Write the specified Ranges to corresponding Metric Counter Log
+	 * Enable Register
+	 */
+	regval = rangehigh << 16;
+	regval |= rangelow;
+	writereg(baseaddr, (XAPM_MC0LOGEN_OFFSET +
+					(counter * 16)), regval);
+}
+
+/****************************************************************************/
+/**
+*
+* This function returns the Ranges of specified Metric Counter Log
+* Enable Register.
+*
+* @param	counter is the Metric Counter number for which
+*		Ranges are to be returned.Use the XAPM_METRIC_COUNTER*
+*		defines for the counter number in xaxipmon.h.
+*		The valid values are 0 (XAPM_METRIC_COUNTER_0) to
+*		9 (XAPM_METRIC_COUNTER_9).
+*
+* @param	rangehigh specifies the user reference variable which returns
+*		the Upper Range Value of the specified Metric Counter
+*		Log Enable Register.
+* @param	rangelow specifies the user reference variable which returns
+*		the Lower Range Value of the specified Metric Counter
+*		Log Enable Register.
+*
+* @note		None.
+*
+*****************************************************************************/
+void getlogenableranges(u32 counter, u16 *rangehigh, u16 *rangelow)
+{
+	u32 regval;
+
+	regval = readreg(baseaddr,
+				(XAPM_MC0LOGEN_OFFSET + (counter * 16)));
+
+	*rangelow = regval & 0xFFFF;
+	*rangehigh = (regval >> 16) & 0xFFFF;
+}
+
+/*****************************************************************************/
+/**
+*
+* This function enables Event Logging.
+*
+* @return	None
+*
+* @note		None
+*
+******************************************************************************/
+void enableeventlog(void)
+{
+	u32 regval;
+
+	regval = readreg(baseaddr, XAPM_CTL_OFFSET);
+	writereg(baseaddr, XAPM_CTL_OFFSET,
+				regval | XAPM_CR_EVENTLOG_ENABLE_MASK);
+}
+
+/*****************************************************************************/
+/**
+*
+* This function enables External trigger pulse so that Metric Counters can be
+* started on external trigger pulse for a slot.
+*
+*
+* @return	None
+*
+* @note		None
+*
+******************************************************************************/
+void enablemctrigger(void)
+{
+	u32 regval;
+
+	regval = readreg(baseaddr, XAPM_CTL_OFFSET);
+	writereg(baseaddr, XAPM_CTL_OFFSET,
+			regval | XAPM_CR_MCNTR_EXTTRIGGER_MASK);
+}
+
+/****************************************************************************/
+/**
+*
+* This function disables the External trigger pulse used to start Metric
+* Counters on external trigger pulse for a slot.
+*
+* @return	None
+*
+* @note		None
+*
+*****************************************************************************/
+void disablemctrigger(void)
+{
+	u32 regval;
+
+	regval = readreg(baseaddr, XAPM_CTL_OFFSET);
+
+	writereg(baseaddr, XAPM_CTL_OFFSET,
+			regval & ~(XAPM_CR_MCNTR_EXTTRIGGER_MASK));
+}
+
+/*****************************************************************************/
+/**
+*
+* This function enables External trigger pulse for Event Log
+* so that Event Logging can be started on external trigger pulse for a slot.
+*
+* @return	None
+*
+* @note		None
+*
+******************************************************************************/
+void enableeventlogtrigger(void)
+{
+	u32 regval;
+
+	regval = readreg(baseaddr, XAPM_CTL_OFFSET);
+	writereg(baseaddr, XAPM_CTL_OFFSET,
+				regval | XAPM_CR_EVTLOG_EXTTRIGGER_MASK);
+}
+
+/****************************************************************************/
+/**
+*
+* This function disables the External trigger pulse used to start Event
+* Log on external trigger pulse for a slot.
+*
+* @return	None
+*
+* @note		None
+*
+*****************************************************************************/
+void disableeventlogtrigger(void)
+{
+	u32 regval;
+
+	regval = readreg(baseaddr, XAPM_CTL_OFFSET);
+
+	writereg(baseaddr, XAPM_CTL_OFFSET,
+				regval & ~(XAPM_CR_EVTLOG_EXTTRIGGER_MASK));
+}
+
+/****************************************************************************/
+/**
+*
+* This function returns a name for a given Metric.
+*
+* @param        metrics is one of the Metric Sets. User has to use
+*               XAPM_METRIC_SET_* macros in xaxipmon.h for this parameter
+*
+* @return       const char *
+*
+* @note         None
+*
+*****************************************************************************/
+const char *getmetricname(u8 metrics)
+{
+	if (metrics == XAPM_METRIC_SET_0)
+		return "Write Transaction Count";
+	if (metrics == XAPM_METRIC_SET_1)
+		return "Read Transaction Count";
+	if (metrics == XAPM_METRIC_SET_2)
+		return "Write Byte Count";
+	if (metrics == XAPM_METRIC_SET_3)
+		return "Read Byte Count";
+	if (metrics == XAPM_METRIC_SET_4)
+		return "Write Beat Count";
+	if (metrics == XAPM_METRIC_SET_5)
+		return "Total Read Latency";
+	if (metrics == XAPM_METRIC_SET_6)
+		return "Total Write Latency";
+	if (metrics == XAPM_METRIC_SET_7)
+		return "Slv_Wr_Idle_Cnt";
+	if (metrics == XAPM_METRIC_SET_8)
+		return "Mst_Rd_Idle_Cnt";
+	if (metrics == XAPM_METRIC_SET_9)
+		return "Num_BValids";
+	if (metrics == XAPM_METRIC_SET_10)
+		return "Num_WLasts";
+	if (metrics == XAPM_METRIC_SET_11)
+		return "Num_RLasts";
+	if (metrics == XAPM_METRIC_SET_12)
+		return "Minimum Write Latency";
+	if (metrics == XAPM_METRIC_SET_13)
+		return "Maximum Write Latency";
+	if (metrics == XAPM_METRIC_SET_14)
+		return "Minimum Read Latency";
+	if (metrics == XAPM_METRIC_SET_15)
+		return "Maximum Read Latency";
+	if (metrics == XAPM_METRIC_SET_16)
+		return "Transfer Cycle Count";
+	if (metrics == XAPM_METRIC_SET_17)
+		return "Packet Count";
+	if (metrics == XAPM_METRIC_SET_18)
+		return "Data Byte Count";
+	if (metrics == XAPM_METRIC_SET_19)
+		return "Position Byte Count";
+	if (metrics == XAPM_METRIC_SET_20)
+		return "Null Byte Count";
+	if (metrics == XAPM_METRIC_SET_21)
+		return "Slv_Idle_Cnt";
+	if (metrics == XAPM_METRIC_SET_22)
+		return "Mst_Idle_Cnt";
+	if (metrics == XAPM_METRIC_SET_30)
+		return "External event count";
+	return "Unsupported";
+}
+
+/****************************************************************************/
+/**
+*
+* This function sets Write ID in Latency ID register to capture Write
+* Latency metrics.
+*
+* @param	writeid is the Write ID to be written in Latency ID register.
+*
+* @return	None.
+*
+* @note		None.
+*
+*****************************************************************************/
+void setwriteid(u16 writeid)
+{
+	u32 regval;
+
+	regval = readreg(baseaddr, XAPM_ID_OFFSET);
+	regval = regval & ~(XAPM_ID_WID_MASK);
+	regval = regval | writeid;
+	writereg(baseaddr, XAPM_ID_OFFSET, regval);
+}
+
+/****************************************************************************/
+/**
+*
+* This function sets Read ID in Latency ID register to capture
+* Read Latency metrics.
+*
+* @param	readid is the Read ID to be written in Latency ID register.
+*
+* @return	None.
+*
+* @note		None.
+*
+*****************************************************************************/
+void setreadid(u16 readid)
+{
+	u32 regval;
+
+	regval = readreg(baseaddr, XAPM_ID_OFFSET);
+	regval = regval & ~(XAPM_ID_RID_MASK);
+	regval = regval | (readid << 16);
+	writereg(baseaddr, XAPM_ID_OFFSET, regval);
+}
+
+/****************************************************************************/
+/**
+*
+* This function returns Write ID in Latency ID register.
+*
+* @return	writeid is the required Write ID in Latency ID register.
+*
+* @note		None.
+*
+*****************************************************************************/
+u16 getwriteid(void)
+{
+
+	u16 writeid;
+	u32 regval;
+
+	regval = readreg(baseaddr, XAPM_ID_OFFSET);
+	writeid = regval & XAPM_ID_WID_MASK;
+
+	return writeid;
+}
+
+/****************************************************************************/
+/**
+*
+* This function returns Read ID in Latency ID register.
+*
+* @return	readid is the required Read ID in Latency ID register.
+*
+* @note		None.
+*
+*****************************************************************************/
+u16 getreadid(void)
+{
+
+	u16 readid;
+	u32 regval;
+
+	regval = readreg(baseaddr, XAPM_ID_OFFSET);
+	regval = regval & XAPM_ID_RID_MASK;
+	readid = regval >> 16;
+
+	return readid;
+}
+
+/*****************************************************************************/
+/**
+*
+* This function sets Latency Start point to calculate write latency.
+*
+* @param	Param can be 0 - XAPM_LATENCY_ADDR_ISSUE
+*		or 1 - XAPM_LATENCY_ADDR_ACCEPT
+* @return	None
+*
+* @note		None
+*
+******************************************************************************/
+void setwrlatencystart(u8 param)
+{
+	u32 regval;
+
+	regval = readreg(baseaddr, XAPM_CTL_OFFSET);
+	if (param == XAPM_LATENCY_ADDR_ACCEPT)
+		writereg(baseaddr, XAPM_CTL_OFFSET, regval |
+				XAPM_CR_WRLATENCY_START_MASK);
+	else
+		writereg(baseaddr, XAPM_CTL_OFFSET, readreg(baseaddr,
+			XAPM_CTL_OFFSET) & ~(XAPM_CR_WRLATENCY_START_MASK));
+}
+
+/*****************************************************************************/
+/**
+*
+* This function sets Latency End point to calculate write latency.
+*
+* @param	Param can be 0 - XAPM_LATENCY_LASTWR
+*		or 1 - XAPM_LATENCY_FIRSTWR
+* @return	None
+*
+* @note		None
+*
+******************************************************************************/
+void setwrlatencyend(u8 param)
+{
+	u32 regval;
+
+	regval = readreg(baseaddr, XAPM_CTL_OFFSET);
+	if (param == XAPM_LATENCY_FIRSTWR)
+		writereg(baseaddr, XAPM_CTL_OFFSET, regval |
+					XAPM_CR_WRLATENCY_END_MASK);
+	else
+		writereg(baseaddr, XAPM_CTL_OFFSET, readreg(baseaddr,
+			XAPM_CTL_OFFSET) & ~(XAPM_CR_WRLATENCY_END_MASK));
+}
+
+/*****************************************************************************/
+/**
+*
+* This function sets Latency Start point to calculate read latency.
+*
+* @param	Param can be 0 - XAPM_LATENCY_ADDR_ISSUE
+*		or 1 - XAPM_LATENCY_ADDR_ACCEPT
+* @return	None
+*
+* @note		None
+*
+******************************************************************************/
+void setrdlatencystart(u8 param)
+{
+	u32 regval;
+
+	regval = readreg(baseaddr, XAPM_CTL_OFFSET);
+	if (param == XAPM_LATENCY_ADDR_ACCEPT)
+		writereg(baseaddr, XAPM_CTL_OFFSET, regval |
+					XAPM_CR_RDLATENCY_START_MASK);
+	else
+		writereg(baseaddr, XAPM_CTL_OFFSET, readreg(baseaddr,
+			XAPM_CTL_OFFSET) & ~(XAPM_CR_RDLATENCY_START_MASK));
+}
+
+/*****************************************************************************/
+/**
+*
+* This function sets Latency End point to calculate read latency.
+*
+* @param	Param can be 0 - XAPM_LATENCY_LASTRD
+*		or 1 - XAPM_LATENCY_FIRSTRD
+* @return	None
+*
+* @note		None
+*
+******************************************************************************/
+void setrdlatencyend(u8 param)
+{
+	u32 regval;
+
+	regval = readreg(baseaddr, XAPM_CTL_OFFSET);
+	if (param == XAPM_LATENCY_FIRSTRD)
+		writereg(baseaddr, XAPM_CTL_OFFSET, regval |
+				XAPM_CR_RDLATENCY_END_MASK);
+	else
+		writereg(baseaddr, XAPM_CTL_OFFSET, readreg(baseaddr,
+			XAPM_CTL_OFFSET) & ~(XAPM_CR_RDLATENCY_END_MASK));
+}
+
+/*****************************************************************************/
+/**
+*
+* This function returns Write Latency Start point.
+*
+* @return	Returns 0 - XAPM_LATENCY_ADDR_ISSUE or
+*			1 - XAPM_LATENCY_ADDR_ACCEPT
+*
+* @note		None
+*
+******************************************************************************/
+u8 getwrlatencystart(void)
+{
+	u8 regval;
+
+	regval = readreg(baseaddr, XAPM_CTL_OFFSET);
+	regval = regval & XAPM_CR_WRLATENCY_START_MASK;
+	if (regval != XAPM_LATENCY_ADDR_ISSUE)
+		return XAPM_LATENCY_ADDR_ACCEPT;
+	else
+		return XAPM_LATENCY_ADDR_ISSUE;
+}
+
+/*****************************************************************************/
+/**
+*
+* This function returns Write Latency End point.
+*
+* @return	Returns 0 - XAPM_LATENCY_LASTWR or
+*			1 - XAPM_LATENCY_FIRSTWR.
+*
+* @note		None
+*
+******************************************************************************/
+u8 getwrlatencyend(void)
+{
+	u8 regval;
+
+	regval = readreg(baseaddr, XAPM_CTL_OFFSET);
+	regval = regval & XAPM_CR_WRLATENCY_END_MASK;
+	if (regval != XAPM_LATENCY_LASTWR)
+		return XAPM_LATENCY_FIRSTWR;
+	else
+		return XAPM_LATENCY_LASTWR;
+}
+
+/*****************************************************************************/
+/**
+*
+* This function returns read Latency Start point.
+*
+* @return	Returns 0 - XAPM_LATENCY_ADDR_ISSUE or
+*			1 - XAPM_LATENCY_ADDR_ACCEPT
+*
+* @note		None
+*
+******************************************************************************/
+u8 getrdlatencystart(void)
+{
+	u8 regval;
+
+	regval = readreg(baseaddr, XAPM_CTL_OFFSET);
+	regval = regval & XAPM_CR_RDLATENCY_START_MASK;
+
+	if (regval != XAPM_LATENCY_ADDR_ISSUE)
+		return	XAPM_LATENCY_ADDR_ACCEPT;
+	else
+		return XAPM_LATENCY_ADDR_ISSUE;
+}
+
+/*****************************************************************************/
+/**
+*
+* This function returns Read Latency End point.
+*
+* @return	Returns 0 - XAPM_LATENCY_LASTRD or
+*			1 - XAPM_LATENCY_FIRSTRD.
+*
+* @note		None
+*
+******************************************************************************/
+u8 getrdlatencyend(void)
+{
+	u8 regval;
+
+	regval = readreg(baseaddr, XAPM_CTL_OFFSET);
+	regval = regval & XAPM_CR_RDLATENCY_END_MASK;
+	if (regval != XAPM_LATENCY_LASTRD)
+		return XAPM_LATENCY_FIRSTRD;
+	else
+		return XAPM_LATENCY_LASTRD;
+
+}
+
+/****************************************************************************/
+/**
+*
+* This function sets Write ID Mask in ID Mask register.
+*
+* @param	wrmask is the Write ID mask to be written in ID register.
+*
+* @return	None.
+*
+* @note		None.
+*
+*****************************************************************************/
+void setwriteidmask(u16 wrmask)
+{
+	u32 regval;
+
+	regval = readreg(baseaddr, XAPM_IDMASK_OFFSET);
+	regval = regval & ~(XAPM_MASKID_WID_MASK);
+	regval = regval | wrmask;
+	writereg(baseaddr, XAPM_IDMASK_OFFSET, regval);
+}
+
+/****************************************************************************/
+/**
+*
+* This function sets Read ID Mask in ID Mask register.
+*
+* @param	rdmask is the Read ID mask to be written in ID Mask register.
+*
+* @return	None.
+*
+* @note		None.
+*
+*****************************************************************************/
+void setreadidmask(u16 rdmask)
+{
+	u32 regval;
+
+	regval = readreg(baseaddr, XAPM_IDMASK_OFFSET);
+	regval = regval & ~(XAPM_MASKID_RID_MASK);
+	regval = regval | (rdmask << 16);
+	writereg(baseaddr, XAPM_IDMASK_OFFSET, regval);
+}
+
+/****************************************************************************/
+/**
+*
+* This function returns Write ID Mask in ID Mask register.
+*
+* @return	wrmask is the required Write ID Mask in ID Mask register.
+*
+* @note		None.
+*
+*****************************************************************************/
+u16 getwriteidmask(void)
+{
+
+	u16 wrmask;
+	u32 regval;
+
+	regval = readreg(baseaddr, XAPM_IDMASK_OFFSET);
+	wrmask = regval & XAPM_MASKID_WID_MASK;
+
+	return wrmask;
+}
+
+/****************************************************************************/
+/**
+*
+* This function returns Read ID Mask in ID Mask register.
+*
+* @return	rdmask is the required Read ID Mask in ID Mask register.
+*
+* @note		None.
+*
+*****************************************************************************/
+u16 getreadidmask(void)
+{
+
+	u16 rdmask;
+	u32 regval;
+
+	regval = readreg(baseaddr, XAPM_IDMASK_OFFSET);
+	regval = regval & XAPM_MASKID_RID_MASK;
+	rdmask = regval >> 16;
+
+	return rdmask;
+}
diff --git a/samples/xilinx_apm/xaxipmon.h b/samples/xilinx_apm/xaxipmon.h
new file mode 100644
index 0000000..5d1342c
--- /dev/null
+++ b/samples/xilinx_apm/xaxipmon.h
@@ -0,0 +1,936 @@
+#ifndef XAXIPMON_H /* Prevent circular inclusions */
+#define XAXIPMON_H /* by using protection macros  */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <stdint.h>
+
+
+#define XST_SUCCESS	0
+#define XST_FAILURE	1
+
+#ifndef TRUE
+#define TRUE		1
+#endif
+
+#ifndef FALSE
+#define FALSE		0
+#endif
+
+#ifndef NULL
+#define NULL		0
+#endif
+
+#define XAPM_GCC_HIGH_OFFSET		0x0000	/* Global Clock Counter
+							32 to 63 bits  */
+#define XAPM_GCC_LOW_OFFSET		0x0004	/* Global Clock Counter Lower
+							0-31 bits  */
+#define XAPM_SI_HIGH_OFFSET		0x0020	/* Sample Interval MSB */
+#define XAPM_SI_LOW_OFFSET		0x0024	/* Sample Interval LSB */
+#define XAPM_SICR_OFFSET		0x0028	/* Sample Interval Control
+							Register */
+#define XAPM_SR_OFFSET			0x002C	/* Sample Register */
+#define XAPM_GIE_OFFSET			0x0030	/* Global Interrupt Enable
+							Register */
+#define XAPM_IE_OFFSET			0x0034	/* Interrupt Enable Register */
+#define XAPM_IS_OFFSET			0x0038	/* Interrupt Status Register */
+
+#define XAPM_MSR0_OFFSET		0x0044	/* Metric Selector 0 Register*/
+#define XAPM_MSR1_OFFSET		0x0048	/* Metric Selector 1 Register*/
+#define XAPM_MSR2_OFFSET		0x004C	/* Metric Selector 2 Register*/
+
+#define XAPM_MC0_OFFSET			0x0100	/* Metric Counter 0 Register */
+#define XAPM_INC0_OFFSET		0x0104	/* Incrementer 0 Register */
+#define XAPM_RANGE0_OFFSET		0x0108	/* Range 0 Register */
+#define XAPM_MC0LOGEN_OFFSET		0x010C	/* Metric Counter 0
+							Log Enable Register */
+#define XAPM_MC1_OFFSET			0x0110	/* Metric Counter 1 Register */
+#define XAPM_INC1_OFFSET		0x0114	/* Incrementer 1 Register */
+#define XAPM_RANGE1_OFFSET		0x0118	/* Range 1 Register */
+#define XAPM_MC1LOGEN_OFFSET		0x011C	/* Metric Counter 1
+							Log Enable Register */
+#define XAPM_MC2_OFFSET			0x0120	/* Metric Counter 2 Register */
+#define XAPM_INC2_OFFSET		0x0124	/* Incrementer 2 Register */
+#define XAPM_RANGE2_OFFSET		0x0128	/* Range 2 Register */
+#define XAPM_MC2LOGEN_OFFSET		0x012C	/* Metric Counter 2
+							Log Enable Register */
+#define XAPM_MC3_OFFSET			0x0130	/* Metric Counter 3 Register */
+#define XAPM_INC3_OFFSET		0x0134	/* Incrementer 3 Register */
+#define XAPM_RANGE3_OFFSET		0x0138	/* Range 3 Register */
+#define XAPM_MC3LOGEN_OFFSET		0x013C	/* Metric Counter 3
+							Log Enable Register */
+#define XAPM_MC4_OFFSET			0x0140	/* Metric Counter 4 Register */
+#define XAPM_INC4_OFFSET		0x0144	/* Incrementer 4 Register */
+#define XAPM_RANGE4_OFFSET		0x0148	/* Range 4 Register */
+#define XAPM_MC4LOGEN_OFFSET		0x014C	/* Metric Counter 4
+							Log Enable Register */
+#define XAPM_MC5_OFFSET			0x0150	/* Metric Counter 5
+							Register */
+#define XAPM_INC5_OFFSET		0x0154	/* Incrementer 5 Register */
+#define XAPM_RANGE5_OFFSET		0x0158	/* Range 5 Register */
+#define XAPM_MC5LOGEN_OFFSET		0x015C	/* Metric Counter 5
+							Log Enable Register */
+#define XAPM_MC6_OFFSET			0x0160	/* Metric Counter 6
+							Register */
+#define XAPM_INC6_OFFSET		0x0164	/* Incrementer 6 Register */
+#define XAPM_RANGE6_OFFSET		0x0168	/* Range 6 Register */
+#define XAPM_MC6LOGEN_OFFSET		0x016C	/* Metric Counter 6
+							Log Enable Register */
+#define XAPM_MC7_OFFSET			0x0170	/* Metric Counter 7
+							Register */
+#define XAPM_INC7_OFFSET		0x0174	/* Incrementer 7 Register */
+#define XAPM_RANGE7_OFFSET		0x0178	/* Range 7 Register */
+#define XAPM_MC7LOGEN_OFFSET		0x017C	/* Metric Counter 7
+							Log Enable Register */
+#define XAPM_MC8_OFFSET			0x0180	/* Metric Counter 8
+							Register */
+#define XAPM_INC8_OFFSET		0x0184	/* Incrementer 8 Register */
+#define XAPM_RANGE8_OFFSET		0x0188	/* Range 8 Register */
+#define XAPM_MC8LOGEN_OFFSET		0x018C	/* Metric Counter 8
+							Log Enable Register */
+#define XAPM_MC9_OFFSET			0x0190	/* Metric Counter 9
+							Register */
+#define XAPM_INC9_OFFSET		0x0194	/* Incrementer 9 Register */
+#define XAPM_RANGE9_OFFSET		0x0198	/* Range 9 Register */
+#define XAPM_MC9LOGEN_OFFSET		0x019C	/* Metric Counter 9
+							Log Enable Register */
+
+#define XAPM_MC10_OFFSET		0x01A0	/* Metric Counter 10
+							Register */
+#define XAPM_MC11_OFFSET		0x01B0	/* Metric Counter 11
+							Register */
+#define XAPM_MC12_OFFSET		0x0500	/* Metric Counter 12
+							Register */
+#define XAPM_MC13_OFFSET		0x0510	/* Metric Counter 13
+							Register */
+#define XAPM_MC14_OFFSET		0x0520	/* Metric Counter 14
+							Register */
+#define XAPM_MC15_OFFSET		0x0530	/* Metric Counter 15
+							Register */
+#define XAPM_MC16_OFFSET		0x0540	/* Metric Counter 16
+							Register */
+#define XAPM_MC17_OFFSET		0x0550	/* Metric Counter 17
+							Register */
+#define XAPM_MC18_OFFSET		0x0560	/* Metric Counter 18
+							Register */
+#define XAPM_MC19_OFFSET		0x0570	/* Metric Counter 19
+							Register */
+#define XAPM_MC20_OFFSET		0x0580	/* Metric Counter 20
+							Register */
+#define XAPM_MC21_OFFSET		0x0590	/* Metric Counter 21
+							Register */
+#define XAPM_MC22_OFFSET		0x05A0	/* Metric Counter 22
+							Register */
+#define XAPM_MC23_OFFSET		0x05B0	/* Metric Counter 23
+							Register */
+#define XAPM_MC24_OFFSET		0x0700	/* Metric Counter 24
+							Register */
+#define XAPM_MC25_OFFSET		0x0710	/* Metric Counter 25
+							Register */
+#define XAPM_MC26_OFFSET		0x0720	/* Metric Counter 26
+							Register */
+#define XAPM_MC27_OFFSET		0x0730	/* Metric Counter 27
+							Register */
+#define XAPM_MC28_OFFSET		0x0740	/* Metric Counter 28
+							Register */
+#define XAPM_MC29_OFFSET		0x0750	/* Metric Counter 29
+							Register */
+#define XAPM_MC30_OFFSET		0x0760	/* Metric Counter 30
+							Register */
+#define XAPM_MC31_OFFSET		0x0770	/* Metric Counter 31
+							Register */
+#define XAPM_MC32_OFFSET		0x0780	/* Metric Counter 32
+							Register */
+#define XAPM_MC33_OFFSET		0x0790	/* Metric Counter 33
+							Register */
+#define XAPM_MC34_OFFSET		0x07A0	/* Metric Counter 34
+							Register */
+#define XAPM_MC35_OFFSET		0x07B0	/* Metric Counter 35
+							Register */
+#define XAPM_MC36_OFFSET		0x0900	/* Metric Counter 36
+							Register */
+#define XAPM_MC37_OFFSET		0x0910	/* Metric Counter 37
+							Register */
+#define XAPM_MC38_OFFSET		0x0920	/* Metric Counter 38
+							Register */
+#define XAPM_MC39_OFFSET		0x0930	/* Metric Counter 39
+							Register */
+#define XAPM_MC40_OFFSET		0x0940	/* Metric Counter 40
+							Register */
+#define XAPM_MC41_OFFSET		0x0950	/* Metric Counter 41
+							Register */
+#define XAPM_MC42_OFFSET		0x0960	/* Metric Counter 42
+							Register */
+#define XAPM_MC43_OFFSET		0x0970	/* Metric Counter 43
+							Register */
+#define XAPM_MC44_OFFSET		0x0980	/* Metric Counter 44
+							Register */
+#define XAPM_MC45_OFFSET		0x0990	/* Metric Counter 45
+							Register */
+#define XAPM_MC46_OFFSET		0x09A0	/* Metric Counter 46
+							Register */
+#define XAPM_MC47_OFFSET		0x09B0	/* Metric Counter 47
+							Register */
+
+#define XAPM_SMC0_OFFSET		0x0200	/* Sampled Metric Counter
+							0 Register */
+#define XAPM_SINC0_OFFSET		0x0204	/* Sampled Incrementer
+							0 Register */
+#define XAPM_SMC1_OFFSET		0x0210	/* Sampled Metric Counter
+							1 Register */
+#define XAPM_SINC1_OFFSET		0x0214	/* Sampled Incrementer
+							1 Register */
+#define XAPM_SMC2_OFFSET		0x0220	/* Sampled Metric Counter
+							2 Register */
+#define XAPM_SINC2_OFFSET		0x0224	/* Sampled Incrementer
+							2 Register */
+#define XAPM_SMC3_OFFSET		0x0230	/* Sampled Metric Counter
+							3 Register */
+#define XAPM_SINC3_OFFSET		0x0234	/* Sampled Incrementer
+							3 Register */
+#define XAPM_SMC4_OFFSET		0x0240	/* Sampled Metric Counter
+							4 Register */
+#define XAPM_SINC4_OFFSET		0x0244	/* Sampled Incrementer
+							4 Register */
+#define XAPM_SMC5_OFFSET		0x0250	/* Sampled Metric Counter
+							5 Register */
+#define XAPM_SINC5_OFFSET		0x0254	/* Sampled Incrementer
+							5 Register */
+#define XAPM_SMC6_OFFSET		0x0260	/* Sampled Metric Counter
+							6 Register */
+#define XAPM_SINC6_OFFSET		0x0264	/* Sampled Incrementer
+							6 Register */
+#define XAPM_SMC7_OFFSET		0x0270	/* Sampled Metric Counter
+							7 Register */
+#define XAPM_SINC7_OFFSET		0x0274	/* Sampled Incrementer
+							7 Register */
+#define XAPM_SMC8_OFFSET		0x0280	/* Sampled Metric Counter
+							8 Register */
+#define XAPM_SINC8_OFFSET		0x0284	/* Sampled Incrementer
+							8 Register */
+#define XAPM_SMC9_OFFSET		0x0290	/* Sampled Metric Counter
+							9 Register */
+#define XAPM_SINC9_OFFSET		0x0294	/* Sampled Incrementer
+							9 Register */
+#define XAPM_SMC10_OFFSET		0x02A0	/* Sampled Metric Counter
+							10 Register */
+#define XAPM_SMC11_OFFSET		0x02B0	/* Sampled Metric Counter
+							11 Register */
+#define XAPM_SMC12_OFFSET		0x0600	/* Sampled Metric Counter
+							12 Register */
+#define XAPM_SMC13_OFFSET		0x0610	/* Sampled Metric Counter
+							13 Register */
+#define XAPM_SMC14_OFFSET		0x0620	/* Sampled Metric Counter
+							14 Register */
+#define XAPM_SMC15_OFFSET		0x0630	/* Sampled Metric Counter
+							15 Register */
+#define XAPM_SMC16_OFFSET		0x0640	/* Sampled Metric Counter
+							16 Register */
+#define XAPM_SMC17_OFFSET		0x0650	/* Sampled Metric Counter
+							17 Register */
+#define XAPM_SMC18_OFFSET		0x0660	/* Sampled Metric Counter
+							18 Register */
+#define XAPM_SMC19_OFFSET		0x0670	/* Sampled Metric Counter
+							19 Register */
+#define XAPM_SMC20_OFFSET		0x0680	/* Sampled Metric Counter
+							20 Register */
+#define XAPM_SMC21_OFFSET		0x0690	/* Sampled Metric Counter
+							21 Register */
+#define XAPM_SMC22_OFFSET		0x06A0	/* Sampled Metric Counter
+							22 Register */
+#define XAPM_SMC23_OFFSET		0x06B0	/* Sampled Metric Counter
+							23 Register */
+#define XAPM_SMC24_OFFSET		0x0800	/* Sampled Metric Counter
+							24 Register */
+#define XAPM_SMC25_OFFSET		0x0810	/* Sampled Metric Counter
+							25 Register */
+#define XAPM_SMC26_OFFSET		0x0820	/* Sampled Metric Counter
+							26 Register */
+#define XAPM_SMC27_OFFSET		0x0830	/* Sampled Metric Counter
+							27 Register */
+#define XAPM_SMC28_OFFSET		0x0840	/* Sampled Metric Counter
+							28 Register */
+#define XAPM_SMC29_OFFSET		0x0850	/* Sampled Metric Counter
+							29 Register */
+#define XAPM_SMC30_OFFSET		0x0860	/* Sampled Metric Counter
+							30 Register */
+#define XAPM_SMC31_OFFSET		0x0870	/* Sampled Metric Counter
+							31 Register */
+#define XAPM_SMC32_OFFSET		0x0880	/* Sampled Metric Counter
+							32 Register */
+#define XAPM_SMC33_OFFSET		0x0890	/* Sampled Metric Counter
+							33 Register */
+#define XAPM_SMC34_OFFSET		0x08A0	/* Sampled Metric Counter
+							34 Register */
+#define XAPM_SMC35_OFFSET		0x08B0	/* Sampled Metric Counter
+							35 Register */
+#define XAPM_SMC36_OFFSET		0x0A00	/* Sampled Metric Counter
+							36 Register */
+#define XAPM_SMC37_OFFSET		0x0A10	/* Sampled Metric Counter
+							37 Register */
+#define XAPM_SMC38_OFFSET		0x0A20	/* Sampled Metric Counter
+							38 Register */
+#define XAPM_SMC39_OFFSET		0x0A30	/* Sampled Metric Counter
+							39 Register */
+#define XAPM_SMC40_OFFSET		0x0A40	/* Sampled Metric Counter
+							40 Register */
+#define XAPM_SMC41_OFFSET		0x0A50	/* Sampled Metric Counter
+							41 Register */
+#define XAPM_SMC42_OFFSET		0x0A60	/* Sampled Metric Counter
+							42 Register */
+#define XAPM_SMC43_OFFSET		0x0A70	/* Sampled Metric Counter
+							43 Register */
+#define XAPM_SMC44_OFFSET		0x0A80	/* Sampled Metric Counter
+							44 Register */
+#define XAPM_SMC45_OFFSET		0x0A90	/* Sampled Metric Counter
+							45 Register */
+#define XAPM_SMC46_OFFSET		0x0AA0	/* Sampled Metric Counter
+							46 Register */
+#define XAPM_SMC47_OFFSET		0x0AB0	/* Sampled Metric Counter
+							47 Register */
+
+#define XAPM_CTL_OFFSET			0x0300	/* Control Register */
+
+#define XAPM_ID_OFFSET			0x0304	/* Latency ID Register */
+
+#define XAPM_IDMASK_OFFSET		0x0308	/* ID Mask Register */
+
+#define XAPM_FEC_OFFSET			0x0400	/* flag Enable
+							Control Register */
+
+#define XAPM_SWD_OFFSET			0x0404	/* Software-written
+							Data Register */
+
+#define XAPM_SICR_MCNTR_RST_MASK	0x00000100 /* Enable the Metric
+							Counter Reset */
+#define XAPM_SICR_LOAD_MASK		0x00000002 /* Load the Sample Interval
+							Register Value into
+							the counter */
+#define XAPM_SICR_ENABLE_MASK		0x00000001 /* Enable the downcounter */
+
+#define XAPM_IXR_MC9_OVERFLOW_MASK	0x00001000	/**< Metric Counter 9
+							  *  Overflow> */
+#define XAPM_IXR_MC8_OVERFLOW_MASK	0x00000800	/**< Metric Counter 8
+							  *  Overflow> */
+#define XAPM_IXR_MC7_OVERFLOW_MASK	0x00000400	/**< Metric Counter 7
+							  *  Overflow> */
+#define XAPM_IXR_MC6_OVERFLOW_MASK	0x00000200	/**< Metric Counter 6
+							  *  Overflow> */
+#define XAPM_IXR_MC5_OVERFLOW_MASK	0x00000100	/**< Metric Counter 5
+							  *  Overflow> */
+#define XAPM_IXR_MC4_OVERFLOW_MASK	0x00000080	/**< Metric Counter 4
+							  *  Overflow> */
+#define XAPM_IXR_MC3_OVERFLOW_MASK	0x00000040	/**< Metric Counter 3
+							  *  Overflow> */
+#define XAPM_IXR_MC2_OVERFLOW_MASK	0x00000020	/**< Metric Counter 2
+							  *  Overflow> */
+#define XAPM_IXR_MC1_OVERFLOW_MASK	0x00000010	/**< Metric Counter 1
+							  *  Overflow> */
+#define XAPM_IXR_MC0_OVERFLOW_MASK	0x00000008	/**< Metric Counter 0
+							  *  Overflow> */
+#define XAPM_IXR_FIFO_FULL_MASK		0x00000004	/**< Event Log FIFO
+							  *  full> */
+#define XAPM_IXR_SIC_OVERFLOW_MASK	0x00000002	/**< Sample Interval
+							  * Counter Overflow */
+#define XAPM_IXR_GCC_OVERFLOW_MASK	0x00000001	/**< Global Clock
+							Counter Overflow */
+#define XAPM_IXR_ALL_MASK		(XAPM_IXR_SIC_OVERFLOW_MASK | \
+					XAPM_IXR_GCC_OVERFLOW_MASK |  \
+					XAPM_IXR_FIFO_FULL_MASK | \
+					XAPM_IXR_MC0_OVERFLOW_MASK | \
+					XAPM_IXR_MC1_OVERFLOW_MASK | \
+					XAPM_IXR_MC2_OVERFLOW_MASK | \
+					XAPM_IXR_MC3_OVERFLOW_MASK | \
+					XAPM_IXR_MC4_OVERFLOW_MASK | \
+					XAPM_IXR_MC5_OVERFLOW_MASK | \
+					XAPM_IXR_MC6_OVERFLOW_MASK | \
+					XAPM_IXR_MC7_OVERFLOW_MASK | \
+					XAPM_IXR_MC8_OVERFLOW_MASK | \
+					XAPM_IXR_MC9_OVERFLOW_MASK)
+
+#define XAPM_CR_FIFO_RESET_MASK			0x02000000
+						/**< FIFO Reset */
+#define XAPM_CR_MUXSEL_MASK			0x01000000
+						/**< Mux Selector mask */
+#define XAPM_CR_GCC_RESET_MASK			0x00020000
+						/**< Global Clk
+						  Counter Reset */
+#define XAPM_CR_GCC_ENABLE_MASK			0x00010000
+						/**< Global Clk
+						   Counter Enable */
+#define XAPM_CR_EVTLOG_EXTTRIGGER_MASK		0x00000200
+						/**< Enable External trigger
+						to start event Log */
+#define XAPM_CR_EVENTLOG_ENABLE_MASK		0x00000100
+						/**< Event Log Enable */
+#define XAPM_CR_RDLATENCY_END_MASK		0x00000080
+						/**< Write Latency
+							End point */
+#define XAPM_CR_RDLATENCY_START_MASK		0x00000040
+						/**< Read Latency
+							Start point */
+#define XAPM_CR_WRLATENCY_END_MASK		0x00000020
+						/**< Write Latency
+							End point */
+#define XAPM_CR_WRLATENCY_START_MASK		0x00000010
+						/**< Write Latency
+							Start point */
+#define XAPM_CR_IDFILTER_ENABLE_MASK		0x00000008
+						/**< ID Filter Enable */
+#define XAPM_CR_MCNTR_EXTTRIGGER_MASK		0x00000004
+						/**< Enable External
+						   trigger to start
+						   Metric Counters  */
+#define XAPM_CR_MCNTR_RESET_MASK		0x00000002
+						/**< Metrics Counter
+						   Reset */
+#define XAPM_CR_MCNTR_ENABLE_MASK		0x00000001
+						/**< Metrics Counter
+							Enable */
+
+#define XAPM_ID_RID_MASK			0xFFFF0000 /**< Read ID */
+
+#define XAPM_ID_WID_MASK			0x0000FFFF /**< Write ID */
+
+#define XAPM_MASKID_RID_MASK			0xFFFF0000 /**< Read ID Mask */
+
+#define XAPM_MASKID_WID_MASK			0x0000FFFF /**< Write ID Mask*/
+
+
+#define XAPM_MAX_COUNTERS		10 /**< Maximum number of Counters */
+#define XAPM_MAX_COUNTERS_PROFILE	48 /**< Maximum number of Counters in
+						profile mode */
+
+#define XAPM_METRIC_COUNTER_0	0 /**< Metric Counter 0 Register Index */
+#define XAPM_METRIC_COUNTER_1	1 /**< Metric Counter 1 Register Index */
+#define XAPM_METRIC_COUNTER_2	2 /**< Metric Counter 2 Register Index */
+#define XAPM_METRIC_COUNTER_3	3 /**< Metric Counter 3 Register Index */
+#define XAPM_METRIC_COUNTER_4	4 /**< Metric Counter 4 Register Index */
+#define XAPM_METRIC_COUNTER_5	5 /**< Metric Counter 5 Register Index */
+#define XAPM_METRIC_COUNTER_6	6 /**< Metric Counter 6 Register Index */
+#define XAPM_METRIC_COUNTER_7	7 /**< Metric Counter 7 Register Index */
+#define XAPM_METRIC_COUNTER_8	8 /**< Metric Counter 8 Register Index */
+#define XAPM_METRIC_COUNTER_9	9 /**< Metric Counter 9 Register Index */
+
+#define XAPM_INCREMENTER_0	0 /**< Metric Counter 0 Register Index */
+#define XAPM_INCREMENTER_1	1 /**< Metric Counter 0 Register Index */
+#define XAPM_INCREMENTER_2	2 /**< Metric Counter 0 Register Index */
+#define XAPM_INCREMENTER_3	3 /**< Metric Counter 0 Register Index */
+#define XAPM_INCREMENTER_4	4 /**< Metric Counter 0 Register Index */
+#define XAPM_INCREMENTER_5	5 /**< Metric Counter 0 Register Index */
+#define XAPM_INCREMENTER_6	6 /**< Metric Counter 0 Register Index */
+#define XAPM_INCREMENTER_7	7 /**< Metric Counter 0 Register Index */
+#define XAPM_INCREMENTER_8	8 /**< Metric Counter 0 Register Index */
+#define XAPM_INCREMENTER_9	9 /**< Metric Counter 0 Register Index */
+
+#define XAPM_METRIC_SET_0	0 /**< Write Transaction Count */
+#define XAPM_METRIC_SET_1	1 /**< Read Transaction Count */
+#define XAPM_METRIC_SET_2	2 /**< Write Byte Count */
+#define XAPM_METRIC_SET_3	3 /**< Read Byte Count */
+#define XAPM_METRIC_SET_4	4 /**< Write Beat Count */
+#define XAPM_METRIC_SET_5	5 /**< Total Read Latency */
+#define XAPM_METRIC_SET_6	6 /**< Total Write Latency */
+#define XAPM_METRIC_SET_7	7 /**< Slv_Wr_Idle_Cnt */
+#define XAPM_METRIC_SET_8	8 /**< Mst_Rd_Idle_Cnt */
+#define XAPM_METRIC_SET_9	9 /**< Num_BValids */
+#define XAPM_METRIC_SET_10	10 /**< Num_WLasts */
+#define XAPM_METRIC_SET_11	11 /**< Num_RLasts */
+#define XAPM_METRIC_SET_12	12 /**< Minimum Write Latency */
+#define XAPM_METRIC_SET_13	13 /**< Maximum Write Latency */
+#define XAPM_METRIC_SET_14	14 /**< Minimum Read Latency */
+#define XAPM_METRIC_SET_15	15 /**< Maximum Read Latency */
+#define XAPM_METRIC_SET_16	16 /**< Transfer Cycle Count */
+#define XAPM_METRIC_SET_17	17 /**< Packet Count */
+#define XAPM_METRIC_SET_18	18 /**< Data Byte Count */
+#define XAPM_METRIC_SET_19	19 /**< Position Byte Count */
+#define XAPM_METRIC_SET_20	20 /**< Null Byte Count */
+#define XAPM_METRIC_SET_21	21 /**< Slv_Idle_Cnt */
+#define XAPM_METRIC_SET_22	22 /**< Mst_Idle_Cnt */
+#define XAPM_METRIC_SET_30	30 /**< External event count */
+
+#define XAPM_MAX_AGENTS		8 /**< Maximum number of Agents */
+
+#define XAPM_FLAG_WRADDR	0x00000001 /**< Write Address flag */
+#define XAPM_FLAG_FIRSTWR	0x00000002 /**< First Write flag */
+#define XAPM_FLAG_LASTWR	0x00000004 /**< Last Write flag */
+#define XAPM_FLAG_RESPONSE	0x00000008 /**< Response flag */
+#define XAPM_FLAG_RDADDR	0x00000010 /**< Read Address flag */
+#define XAPM_FLAG_FIRSTRD	0x00000020 /**< First Read flag */
+#define XAPM_FLAG_LASTRD	0x00000040 /**< Last Read flag */
+#define XAPM_FLAG_SWDATA	0x00010000 /**< Software-written Data flag */
+#define XAPM_FLAG_EVENT		0x00020000 /**< Last Read flag */
+#define XAPM_FLAG_EVNTSTOP	0x00040000 /**< Last Read flag */
+#define XAPM_FLAG_EVNTSTART	0x00080000 /**< Last Read flag */
+#define XAPM_FLAG_GCCOVF	0x00100000 /**< Global Clock Counter Overflow
+					     *  flag */
+#define XAPM_FLAG_SCLAPSE	0x00200000 /**< Sample Counter Lapse flag */
+#define XAPM_FLAG_MC0		0x00400000 /**< Metric Counter 0 flag */
+#define XAPM_FLAG_MC1		0x00800000 /**< Metric Counter 1 flag */
+#define XAPM_FLAG_MC2		0x01000000 /**< Metric Counter 2 flag */
+#define XAPM_FLAG_MC3		0x02000000 /**< Metric Counter 3 flag */
+#define XAPM_FLAG_MC4		0x04000000 /**< Metric Counter 4 flag */
+#define XAPM_FLAG_MC5		0x08000000 /**< Metric Counter 5 flag */
+#define XAPM_FLAG_MC6		0x10000000 /**< Metric Counter 6 flag */
+#define XAPM_FLAG_MC7		0x20000000 /**< Metric Counter 7 flag */
+#define XAPM_FLAG_MC8		0x40000000 /**< Metric Counter 8 flag */
+#define XAPM_FLAG_MC9		0x80000000 /**< Metric Counter 9 flag */
+
+#define XAPM_LATENCY_ADDR_ISSUE		0 /**< Address Issue as start
+					point for Latency calculation*/
+#define XAPM_LATENCY_ADDR_ACCEPT	1 /**< Address Acceptance as start
+					point for Latency calculation*/
+#define XAPM_LATENCY_LASTRD		0 /**< Last Read as end point for
+					Latency calculation */
+#define XAPM_LATENCY_LASTWR		0 /**< Last Write as end point for
+					Latency calculation */
+#define XAPM_LATENCY_FIRSTRD		1 /**< First Read as end point for
+					Latency calculation */
+#define XAPM_LATENCY_FIRSTWR		1 /**< First Write as end point for
+					Latency calculation */
+
+#define XAPM_MODE_TRACE			2 /**< APM in Trace mode */
+
+#define XAPM_MODE_PROFILE		1 /**< APM in Profile mode */
+
+#define XAPM_MODE_ADVANCED		0 /**< APM in Advanced mode */
+
+typedef unsigned char u8;
+typedef uint16_t u16;
+typedef uint32_t u32;
+
+u32 baseaddr;
+
+struct xapm_param {
+	u32	mode;
+	u32	maxslots;
+	u32	eventcnt;
+	u32	eventlog;
+	u32	sampledcnt;
+	u32	numcounters;
+	u32	metricwidth;
+	u32	sampledwidth;
+	u32	globalcntwidth;
+	u32     scalefactor;
+	u32	isr;
+};
+
+static struct xapm_param *params;
+
+/*****************************************************************************/
+/**
+*
+* Read a register of the AXI Performance Monitor device. This macro provides
+* register access to all registers using the register offsets defined above.
+*
+* @param	baseaddr contains the base address of the device.
+* @param	regoffset is the offset of the register to read.
+*
+* @return	The contents of the register.
+*
+* @note		C-style Signature:
+*		u32 readreg(u32 baseaddr, u32 regoffset);
+*
+******************************************************************************/
+#define readreg(baseaddr, regoffset) \
+			(*(u32 *)(baseaddr + regoffset))
+
+/*****************************************************************************/
+/**
+*
+* Write a register of the AXI Performance Monitor device. This macro provides
+* register access to all registers using the register offsets defined above.
+*
+* @param	baseaddr contains the base address of the device.
+* @param	regoffset is the offset of the register to write.
+* @param	data is the value to write to the register.
+*
+* @return	None.
+*
+* @note		C-style Signature:
+*		void writereg(u32 baseaddr,
+*					u32 regoffset,u32 Data)
+*
+******************************************************************************/
+#define writereg(baseaddr, regoffset, data) \
+				(*(u32 *)(baseaddr + regoffset) = data)
+
+/****************************************************************************/
+/**
+*
+* This routine enables the Global Interrupt.
+*
+* @note		C-Style signature:
+*		void intrglobalenable()
+*
+*****************************************************************************/
+#define intrglobalenable()			\
+		writereg(baseaddr, XAPM_GIE_OFFSET, 1)
+
+
+/****************************************************************************/
+/**
+*
+* This routine disables the Global Interrupt.
+*
+* @note		C-Style signature:
+*		void intrglobaldisable(void)
+*
+*****************************************************************************/
+#define intrglobaldisable()				\
+		writereg(baseaddr, XAPM_GIE_OFFSET, 0)
+
+/****************************************************************************/
+/**
+*
+* This routine enables interrupt(s). Use the XAPM_IXR_* constants defined in
+* xaxipmon_hw.h to create the bit-mask to enable interrupts.
+*
+* @param	mask is the mask to enable. Bit positions of 1 will be enabled.
+*		Bit positions of 0 will keep the previous setting. This mask is
+*		formed by OR'ing XAPM_IXR__* bits defined in xaxipmon_hw.h.
+*
+* @return	None.
+*
+* @note		C-Style signature:
+*		void intrenable(u32 mask)
+*
+*****************************************************************************/
+#define intrenable(mask)				     \
+	writereg(baseaddr, XAPM_IE_OFFSET, readreg(baseaddr, \
+			XAPM_IE_OFFSET) | mask);
+
+
+/****************************************************************************/
+/**
+*
+* This routine disable interrupt(s). Use the XAPM_IXR_* constants defined in
+* xaxipmon_hw.h to create the bit-mask to disable interrupts.
+*
+* @param	mask is the mask to disable. Bit positions of 1 will be
+*		disabled. Bit positions of 0 will keep the previous setting.
+*		This mask is formed by OR'ing XAPM_IXR_* bits defined in
+*		xaxipmon_hw.h.
+*
+* @return	None.
+*
+* @note		C-Style signature:
+*		void intrdisable(u32 mask)
+*
+*****************************************************************************/
+#define intrdisable(mask)				     \
+	writereg(baseaddr, XAPM_IE_OFFSET, readreg(baseaddr, \
+						XAPM_IE_OFFSET) | mask);
+
+/****************************************************************************/
+/**
+*
+* This routine clears the specified interrupt(s).
+*
+* @param	mask is the mask to clear. Bit positions of 1 will be cleared.
+*		This mask is formed by OR'ing XAPM_IXR_* bits defined in
+*		xaxipmon_hw.h.
+*
+* @return	None.
+*
+* @note		C-Style signature:
+*		void intrclear(u32 mask)
+*
+*****************************************************************************/
+#define intrclear(mask)				     \
+	writereg(baseaddr, XAPM_IS_OFFSET, readreg(baseaddr, \
+				XAPM_IS_OFFSET) | mask);
+
+/****************************************************************************/
+/**
+*
+* This routine returns the Interrupt Status Register.
+*
+* @return	isr value updated by kernel driver
+*
+* @note		This macro returns isr value updated by kernel driver.
+*		C-Style signature:
+*		void intrgetstatus(void)
+*
+*****************************************************************************/
+#define intrgetstatus()		(params->isr)
+
+/****************************************************************************/
+/**
+*
+* This routine returns the Interrupt Status Register.
+*
+* @return       Interrupt Status Register contents
+*
+* @note         C-Style signature:
+*               void intrhwgetstatus(void)
+*
+*****************************************************************************/
+#define intrhwgetstatus()         (params->isr)
+
+/****************************************************************************/
+/**
+*
+* This function enables the Global Clock Counter.
+*
+* @note		C-Style signature:
+*		void enablegcc(void);
+*
+*****************************************************************************/
+#define enablegcc() \
+	writereg(baseaddr, XAPM_CTL_OFFSET, readreg(baseaddr, \
+			XAPM_CTL_OFFSET) | XAPM_CR_GCC_ENABLE_MASK);
+
+/****************************************************************************/
+/**
+*
+* This function disbles the Global Clock Counter.
+*
+* @note		C-Style signature:
+*		void disablegcc(void);
+*
+*****************************************************************************/
+#define disablegcc() \
+	writereg(baseaddr, XAPM_CTL_OFFSET, readreg(baseaddr, \
+			XAPM_CTL_OFFSET) & ~(XAPM_CR_GCC_ENABLE_MASK));
+
+/****************************************************************************/
+/**
+*
+* This function enables the specified flag in flag Control Register.
+*
+* @param	flag is one of the XAPM_FLAG_* masks defined in xaxipmon.h
+*
+* @return	None
+*
+* @note		C-Style signature:
+*		void enableflag(void);
+*
+*****************************************************************************/
+#define enableflag(flag) \
+	writereg(baseaddr, XAPM_FEC_OFFSET, \
+			readreg(baseaddr, XAPM_FEC_OFFSET) | flag);
+
+/****************************************************************************/
+/**
+*
+* This function disables the specified flag in flag Control Register.
+*
+* @param	flag is one of the XAPM_FLAG_* masks defined in xaxipmon.h*
+* @return	None
+*
+* @note		C-Style signature:
+*		void disableflag(void);
+*
+*****************************************************************************/
+#define disableflag(flag) \
+	writereg(baseaddr, XAPM_FEC_OFFSET, \
+			readreg(baseaddr, XAPM_FEC_OFFSET) & ~(flag));
+
+/****************************************************************************/
+/**
+*
+* This function loads the sample interval register value into the sample
+* interval counter.
+*
+* @note		C-Style signature:
+*		void loadsic(void);
+*
+*****************************************************************************/
+#define loadsic() \
+		writereg(baseaddr, XAPM_SICR_OFFSET, XAPM_SICR_LOAD_MASK)
+
+
+/****************************************************************************/
+/**
+*
+* This enables the down count of the sample interval counter.
+*
+* @note		C-Style signature:
+*	   void enablesic(void);
+*
+*****************************************************************************/
+#define enablesic() \
+	writereg(baseaddr, XAPM_SICR_OFFSET, XAPM_SICR_ENABLE_MASK)
+
+/****************************************************************************/
+/**
+*
+* This disables the down count of the sample interval counter.
+*
+* @note		C-Style signature:
+*	    void disablesic(void);
+*
+*****************************************************************************/
+#define disablesic() \
+	writereg(baseaddr, XAPM_SICR_OFFSET, \
+	readreg(baseaddr, XAPM_SICR_OFFSET) & ~(XAPM_SICR_ENABLE_MASK));
+
+/****************************************************************************/
+/**
+*
+* This enables Reset of Metric Counters when Sample Interval Counter lapses.
+*
+* @note		C-Style signature:
+*		void enablemcreset(void);
+*
+*****************************************************************************/
+#define enablemcreset() \
+	writereg(baseaddr, XAPM_SICR_OFFSET, XAPM_SICR_MCNTR_RST_MASK);
+
+/****************************************************************************/
+/**
+*
+* This disables the down count of the sample interval counter.
+*
+* @note		C-Style signature:
+*		void disablemcreset(void);
+*
+*****************************************************************************/
+#define disablemcreset() \
+	writereg(baseaddr, XAPM_SICR_OFFSET, \
+	readreg(baseaddr, XAPM_SICR_OFFSET) & ~(XAPM_SICR_MCNTR_RST_MASK));
+
+/****************************************************************************/
+/**
+*
+* This function enables the ID Filter Masking.
+*
+* @note		C-Style signature:
+*		void enableidfilter(void);
+*
+*****************************************************************************/
+#define enableidfilter()			\
+	writereg(baseaddr, XAPM_CTL_OFFSET, readreg(baseaddr, \
+			XAPM_CTL_OFFSET) | XAPM_CR_IDFILTER_ENABLE_MASK);
+
+/****************************************************************************/
+/**
+*
+* This function disbles the ID Filter masking.
+*
+* @note		C-Style signature:
+*		void disableidfilter(void);
+*
+*****************************************************************************/
+#define disableidfilter() \
+	writereg(baseaddr, XAPM_CTL_OFFSET, readreg(baseaddr, \
+			XAPM_CTL_OFFSET) & ~(XAPM_CR_IDFILTER_ENABLE_MASK));
+
+/****************************************************************************/
+/**
+*
+* This function samples Metric Counters to Sampled Metric Counters by
+* reading Sample Register and also returns interval. i.e. the number of
+* clocks in between previous read to the current read of sample register.
+*
+* @return	Interval. i.e. the number of clocks in between previous
+*		read to the current read of sample register.
+*
+* @note		C-Style signature:
+*		u32 samplemetrics(void);
+*
+*****************************************************************************/
+#define samplemetrics()		readreg(baseaddr, XAPM_SR_OFFSET);
+
+
+/************************** Function Prototypes *****************************/
+
+int resetmetriccounter(void);
+
+void resetglobalclkcounter(void);
+
+int resetfifo(void);
+
+void setincrementerrange(u8 incrementer, u16 rangehigh, u16 rangelow);
+
+void getincrementerrange(u8 incrementer, u16 *rangehigh, u16 *rangelow);
+
+void setsampleinterval(u32 sampleinterval);
+
+void getsampleinterval(u32 *sampleinterval);
+
+int setmetrics(u8 slot, u8 metrics, u8 counter);
+
+int getmetrics(u8 counter, u8 *metrics, u8 *slot);
+void getglobalclkcounter(u32 *cnthigh, u32 *cntlow);
+
+u32 getmetriccounter(u32 counter);
+
+u32 getsampledmetriccounter(u32 counter);
+
+u32 getincrementer(u32 incrementer);
+
+u32 getsampledincrementer(u32 incrementer);
+
+void setswdatareg(u32 swdata);
+
+u32 getswdatareg(void);
+
+int starteventlog(u32 flagenables);
+
+int stopeventlog(void);
+
+int startcounters(u32 sampleinterval);
+
+int stopcounters(void);
+
+void enablemetricscounter(void);
+
+void disablemetricscounter(void);
+
+void setlogenableranges(u32 counter, u16 rangehigh, u16 rangelow);
+
+void getlogenableranges(u32 counter, u16 *rangehigh, u16 *rangelow);
+
+void enableeventlog(void);
+
+void enablemctrigger(void);
+
+void disablemctrigger(void);
+
+void enableeventlogtrigger(void);
+
+void disableeventlogtrigger(void);
+
+const char *getmetricname(u8 metrics);
+
+void setwriteid(u16 writeid);
+
+void setreadid(u16 readid);
+
+u16 getwriteid(void);
+
+u16 getreadid(void);
+
+void setwrlatencystart(u8 param);
+
+void setwrlatencyend(u8 param);
+
+void setrdlatencystart(u8 param);
+
+void setrdlatencyend(u8 param);
+
+u8 getwrlatencystart(void);
+
+u8 getwrlatencyend(void);
+
+u8 getrdlatencystart(void);
+
+u8 getrdlatencyend(void);
+
+void setwriteidmask(u16 wrmask);
+
+void setreadidmask(u16 rdmask);
+
+u16 getwriteidmask(void);
+
+u16 getreadidmask(void);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif  /* End of protection macro. */
-- 
1.7.5.4

