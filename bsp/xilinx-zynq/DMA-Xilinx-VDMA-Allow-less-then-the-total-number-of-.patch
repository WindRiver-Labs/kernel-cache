From 01bba4755b153a89d6b7e2c34f97979f368b37bc Mon Sep 17 00:00:00 2001
From: Lars-Peter Clausen <lars@metafoo.de>
Date: Wed, 7 Mar 2012 11:12:58 +0100
Subject: [PATCH 361/509] DMA: Xilinx: VDMA: Allow less then the total number
 of frames

https://github.com/analogdevicesinc/linux.git xcomm_zynq
commit 00074c693eea242b04e83e885badc9218ae2f8cf

Although the dma controller expects the exact number of frames it was
configured for we can allow transfers with less than that number of frames, if
the total number of frames is a multiple of it. This is done by repeating the
frames until the total number of frames has been reached.

Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 drivers/dma/xilinx_dma.c |   90 +++++++++++++++++++++++----------------------
 1 files changed, 46 insertions(+), 44 deletions(-)

diff --git a/drivers/dma/xilinx_dma.c b/drivers/dma/xilinx_dma.c
index c929c2a..70edbbe 100644
--- a/drivers/dma/xilinx_dma.c
+++ b/drivers/dma/xilinx_dma.c
@@ -1234,7 +1234,7 @@ static struct dma_async_tx_descriptor *xilinx_vdma_prep_slave_sg(
 	struct xilinx_dma_chan *chan;
 	struct xilinx_dma_desc_sw *first = NULL, *prev = NULL, *new = NULL;
 	struct xilinx_dma_desc_hw *hw = NULL, *prev_hw = NULL;
-	int i;
+	unsigned int i, j;
 	struct scatterlist *sg;
 	dma_addr_t dma_src;
 
@@ -1247,7 +1247,7 @@ static struct dma_async_tx_descriptor *xilinx_vdma_prep_slave_sg(
 		return NULL;
 
 	/* Enforce one sg entry for one frame */
-	if (sg_len != chan->num_frms) {
+	if (chan->num_frms % sg_len != 0) {
 		dev_err(chan->dev, "number of entries %d not the "
 		    "same as num stores %d\n", sg_len, chan->num_frms);
 
@@ -1261,56 +1261,58 @@ static struct dma_async_tx_descriptor *xilinx_vdma_prep_slave_sg(
 		     chan->config.stride);
 	}
 
-	/* Build transactions using information in the scatter gather list
-	 */
-	for_each_sg(sgl, sg, sg_len, i) {
+	for (j = 0; j < chan->num_frms / sg_len; ++j) {
+		/* Build transactions using information in the scatter gather list
+		 */
+		for_each_sg(sgl, sg, sg_len, i) {
 
-		/* Allocate the link descriptor from DMA pool */
-		new = xilinx_dma_alloc_descriptor(chan);
-		if (!new) {
-			dev_err(chan->dev, "No free memory for "
-			    "link descriptor\n");
-			goto fail;
-		}
+			/* Allocate the link descriptor from DMA pool */
+			new = xilinx_dma_alloc_descriptor(chan);
+			if (!new) {
+				dev_err(chan->dev, "No free memory for "
+					"link descriptor\n");
+				goto fail;
+			}
 
-		/*
-		 * Calculate the maximum number of bytes to transfer,
-		 * making sure it is less than the hw limit
-		 */
-		hw = &(new->hw);
+			/*
+			 * Calculate the maximum number of bytes to transfer,
+			 * making sure it is less than the hw limit
+			 */
+			hw = &(new->hw);
 
-		dma_src = sg_dma_address(sg);
-		if (chan->has_SG) {
-			hw->buf_addr = dma_src;
+			dma_src = sg_dma_address(sg);
+			if (chan->has_SG) {
+				hw->buf_addr = dma_src;
 
-			/* Fill in the descriptor */
-			hw->addr_vsize = chan->config.vsize;
-			hw->hsize = chan->config.hsize;
-			hw->control = (chan->config.frm_dly <<
-					XILINX_VDMA_FRMDLY_SHIFT) |
-					chan->config.stride;
-		} else {
-			/* Update the registers */
-			DMA_OUT(&(chan->addr_regs->buf_addr[i]), dma_src);
-		}
+				/* Fill in the descriptor */
+				hw->addr_vsize = chan->config.vsize;
+				hw->hsize = chan->config.hsize;
+				hw->control = (chan->config.frm_dly <<
+						XILINX_VDMA_FRMDLY_SHIFT) |
+						chan->config.stride;
+			} else {
+				/* Update the registers */
+				DMA_OUT(&(chan->addr_regs->buf_addr[j * sg_len + i]), dma_src);
+			}
 
-		/* If this is not the first descriptor, chain the
-		 * current descriptor after the previous descriptor
-		 */
-		if (!first) {
-			first = new;
-		} else {
-			prev_hw = &(prev->hw);
-			prev_hw->next_desc = new->async_tx.phys;
-		}
+			/* If this is not the first descriptor, chain the
+			 * current descriptor after the previous descriptor
+			 */
+			if (!first) {
+				first = new;
+			} else {
+				prev_hw = &(prev->hw);
+				prev_hw->next_desc = new->async_tx.phys;
+			}
 
-		new->async_tx.cookie = 0;
-		async_tx_ack(&new->async_tx);
+			new->async_tx.cookie = 0;
+			async_tx_ack(&new->async_tx);
 
-		prev = new;
+			prev = new;
 
-		/* Insert the link descriptor into the list */
-		list_add_tail(&new->node, &first->tx_list);
+			/* Insert the link descriptor into the list */
+			list_add_tail(&new->node, &first->tx_list);
+		}
 	}
 
 	/* Link the last BD with the first BD */
-- 
1.7.5.4

