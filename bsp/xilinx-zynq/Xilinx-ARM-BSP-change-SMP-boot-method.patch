From f4dd8957ae0588fd51356007b86f40c4e8de5ed9 Mon Sep 17 00:00:00 2001
From: Zhong Hongbo <hongbo.zhong@windriver.com>
Date: Mon, 8 Apr 2013 14:03:16 +0800
Subject: [PATCH 01/13] Xilinx: ARM: BSP: change SMP boot method

git://git.xilinx.com/linux-xlnx.git master
commit 3c31138d449dd1f40c581682345971316e2bb104

The 2nd CPU booting was dependent on the Boot ROM.
This updates it to match what Petalogix was doing
which is a reset of the 2nd CPU so that it's not
dependent on the Boot ROM.

This is needed (or more work on old way) to support
hot plug of the 2nd CPU.

Signed-off-by: John Linn <john.linn@xilinx.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 arch/arm/mach-zynq/platsmp.c |  122 ++++++++++++++++++++++++++++++------------
 1 files changed, 88 insertions(+), 34 deletions(-)

diff --git a/arch/arm/mach-zynq/platsmp.c b/arch/arm/mach-zynq/platsmp.c
index e0b63c3..b097eb8 100644
--- a/arch/arm/mach-zynq/platsmp.c
+++ b/arch/arm/mach-zynq/platsmp.c
@@ -17,13 +17,13 @@
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  */
+#include <linux/module.h>
 #include <linux/init.h>
 #include <linux/errno.h>
 #include <linux/delay.h>
 #include <linux/device.h>
 #include <linux/jiffies.h>
 #include <linux/io.h>
-#include <linux/smp.h>
 
 #include <asm/cacheflush.h>
 #include <asm/smp_scu.h>
@@ -44,22 +44,81 @@ void __cpuinit platform_secondary_init(unsigned int cpu)
 	gic_secondary_init(0);
 
 	/*
-	 * let the primary processor know we're out of the
-	 * pen, then head off into the C entry point
-	 */
-	__raw_writel(BOOT_STATUS_CPU1_UP, OCM_HIGH_BASE + BOOT_STATUS_OFFSET);
-	wmb();
-
-	/*
 	 * Synchronise with the boot thread.
 	 */
 	spin_lock(&boot_lock);
 	spin_unlock(&boot_lock);
 }
 
+/* Store pointer to ioremap area which points to address 0x0 */
+static u8 *zero;
+
+/*
+ * Store pointer to SLCR registers. SLCR driver can't be used because
+ * it is not initialized yet and this code is used for bootup the second CPU
+ */
+#define SLCR_UNLOCK	0xDF0D
+#define SLCR_LOCK	0x767B
+
+static u8 *slcr;
+
+int zynq_cpu1_start(u32 address)
+{
+	if (!slcr) {
+		printk(KERN_INFO "Map SLCR registers\n");
+		/* Remap the SLCR registers to be able to work with cpu1 */
+		slcr = ioremap(0xF8000000, PAGE_SIZE);
+		if (!slcr) {
+			printk(KERN_WARNING
+				"!!!! SLCR jump vectors can't be used !!!!\n");
+			return -1;
+		}
+	}
+
+	/* MS: Expectation that SLCR are directly map and accessible */
+	/* Not possible to jump to non aligned address */
+	if (!(address & 3) && (!address || (address >= 0xC))) {
+		__raw_writel(SLCR_UNLOCK, slcr + 0x8); /* UNLOCK SLCR */
+		__raw_writel(0x22, slcr + 0x244); /* stop CLK and reset CPU1 */
+
+		/*
+		 * This is elegant way how to jump to any address
+		 * 0x0: Load address at 0x8 to r0
+		 * 0x4: Jump by mov instruction
+		 * 0x8: Jumping address
+		 */
+		if (address && address >= 0xC) {
+			if (!zero) {
+				printk(KERN_WARNING
+					"BOOTUP jump vectors is not mapped!\n");
+				return -1;
+			}
+			__raw_writel(0xe59f0000, zero + 0x0);/* 0:ldr r0, [8] */
+			__raw_writel(0xe1a0f000, zero + 0x4);/* 4:mov pc, r0 */
+			__raw_writel(address, zero + 0x8);/* 8:.word address */
+		}
+
+		flush_cache_all();
+		outer_flush_all();
+		wmb();
+
+		__raw_writel(0x20, slcr + 0x244); /* enable CPU1 */
+		__raw_writel(0x0, slcr + 0x244); /* enable CLK for CPU1 */
+		__raw_writel(SLCR_LOCK, slcr + 0x4); /* LOCK SLCR */
+
+		return 0;
+	}
+
+	printk(KERN_WARNING "Can't start CPU1: Wrong starting address %x\n",
+								address);
+
+	return -1;
+}
+EXPORT_SYMBOL(zynq_cpu1_start);
+
 int __cpuinit boot_secondary(unsigned int cpu, struct task_struct *idle)
 {
-	unsigned long timeout;
+	int ret;
 
 	/*
 	 * Set synchronisation state between this boot processor
@@ -67,32 +126,10 @@ int __cpuinit boot_secondary(unsigned int cpu, struct task_struct *idle)
 	 */
 	spin_lock(&boot_lock);
 
-	/*
-	 * This is really belt and braces; we hold unintended secondary
-	 * CPUs in the holding pen until we're ready for them.  However,
-	 * since we haven't sent them a soft interrupt, they shouldn't
-	 * be there.
-	 */
-	__raw_writel(0, OCM_HIGH_BASE + BOOT_STATUS_OFFSET);
-
-	__raw_writel(virt_to_phys(secondary_startup),
-					OCM_HIGH_BASE + BOOT_ADDR_OFFSET);
-	wmb();
-
-	/*
-	 * Send an event to wake the secondary core from WFE state.
-	 */
-	sev();
-
-	/*
-	 * Wait for the other CPU to boot, but timeout if it doesn't
-	 */
-	timeout = jiffies + (1 * HZ);
-	while ((__raw_readl(OCM_HIGH_BASE + BOOT_STATUS_OFFSET) !=
-				BOOT_STATUS_CPU1_UP) &&
-				(time_before(jiffies, timeout)))
-		rmb();
 
+	ret = zynq_cpu1_start(virt_to_phys(secondary_startup));
+	if (ret)
+		return -1;
 	/*
 	 * now the secondary core is starting up let it run its
 	 * calibrations, then wait for it to finish
@@ -123,6 +160,23 @@ void __init platform_smp_prepare_cpus(unsigned int max_cpus)
 	int i;
 
 	/*
+	 * Remap the first three addresses at zero which are used
+	 * for 32bit long jump for SMP. Look at zynq_cpu1_start()
+	 */
+#if CONFIG_PHYS_OFFSET
+	zero = ioremap(0, 12);
+	if (!zero) {
+		printk(KERN_WARNING
+			"!!!! BOOTUP jump vectors can't be used !!!!\n");
+		while (1)
+			;
+	}
+#else
+	/* The first three addresses at zero are already mapped */
+	zero = (u8 *)CONFIG_PAGE_OFFSET;
+#endif
+
+	/*
 	 * Initialise the present map, which describes the set of CPUs
 	 * actually populated at the present time.
 	 */
-- 
1.7.5.4

