From 97c7a31aca9b410cddb93d68ddccdfe29bcfd293 Mon Sep 17 00:00:00 2001
From: Michal Simek <michal.simek@xilinx.com>
Date: Wed, 27 Nov 2013 14:14:34 +0100
Subject: [PATCH 372/509] zynq: usb: Replace XUSBPS by ZYNQ

https://github.com/analogdevicesinc/linux.git xcomm_zynq
commit 74130b6c18efc6ac8545debdbdd9c8776f4e1a97

Fix all usb drivers together.

Signed-off-by: Michal Simek <michal.simek@xilinx.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 drivers/usb/gadget/zynq_udc.c  |  643 ++++++++++++++++++++--------------------
 drivers/usb/host/ehci-hcd.c    |    2 +-
 drivers/usb/host/ehci-zynq.c   |  148 +++++-----
 drivers/usb/host/ehci-zynq.h   |    8 +-
 drivers/usb/host/zynq-dr-of.c  |  108 ++++----
 drivers/usb/phy/phy-zynq-usb.c |  458 ++++++++++++++--------------
 include/linux/usb/zynq_otg.h   |   12 +-
 include/linux/xilinx_devices.h |   32 +-
 8 files changed, 707 insertions(+), 704 deletions(-)

diff --git a/drivers/usb/gadget/zynq_udc.c b/drivers/usb/gadget/zynq_udc.c
index efece2a..b9bcd6e 100644
--- a/drivers/usb/gadget/zynq_udc.c
+++ b/drivers/usb/gadget/zynq_udc.c
@@ -262,12 +262,12 @@ struct ep_td_struct {
 
 /* ### driver private data
  */
-struct xusbps_req {
+struct zynq_req {
 	struct usb_request req;
 	struct list_head queue;
 	/* ep_queue() func will add
 	   a request->queue into a udc_ep->queue 'd tail */
-	struct xusbps_ep *ep;
+	struct zynq_ep *ep;
 	unsigned mapped:1;
 
 	struct ep_td_struct *head, *tail;	/* For dTD List
@@ -277,10 +277,10 @@ struct xusbps_req {
 
 #define REQ_UNCOMPLETE			1
 
-struct xusbps_ep {
+struct zynq_ep {
 	struct usb_ep ep;
 	struct list_head queue;
-	struct xusbps_udc *udc;
+	struct zynq_udc *udc;
 	struct ep_queue_head *qh;
 	struct usb_gadget *gadget;
 
@@ -292,16 +292,16 @@ struct xusbps_ep {
 #define EP_DIR_IN	1
 #define EP_DIR_OUT	0
 
-struct xusbps_udc {
+struct zynq_udc {
 	struct usb_gadget gadget;
 	struct usb_gadget_driver *driver;
 	struct completion *done;	/* to make sure release() is done */
-	struct xusbps_ep *eps;
+	struct zynq_ep *eps;
 	unsigned int max_ep;
 	unsigned int irq;
 
-	/* xusbps otg transceiver */
-	struct xusbps_otg	*xotg;
+	/* zynq otg transceiver */
+	struct zynq_otg	*xotg;
 
 	struct usb_ctrlrequest local_setup_buff;
 	spinlock_t lock;
@@ -312,9 +312,9 @@ struct xusbps_udc {
 	unsigned remote_wakeup:1;
 
 	struct ep_queue_head *ep_qh;	/* Endpoints Queue-Head */
-	struct xusbps_req *status_req;	/* ep0 status request */
+	struct zynq_req *status_req;	/* ep0 status request */
 	struct dma_pool *td_pool;	/* dma pool for DTD */
-	enum xusbps_usb2_phy_modes phy_mode;
+	enum zynq_usb2_phy_modes phy_mode;
 
 	size_t ep_qh_size;		/* size after alignment adjustment*/
 	dma_addr_t ep_qh_dma;		/* dma address of QH */
@@ -368,7 +368,7 @@ struct xusbps_udc {
 					* 2 + ((windex & USB_DIR_IN) ? 1 : 0))
 
 
-static int xusbps_udc_clk_notifier_cb(struct notifier_block *nb,
+static int zynq_udc_clk_notifier_cb(struct notifier_block *nb,
 		unsigned long event, void *data)
 {
 
@@ -387,9 +387,9 @@ static int xusbps_udc_clk_notifier_cb(struct notifier_block *nb,
 	}
 }
 
-static int xusbps_udc_clk_init(struct platform_device *pdev)
+static int zynq_udc_clk_init(struct platform_device *pdev)
 {
-	struct xusbps_usb2_platform_data *pdata = pdev->dev.platform_data;
+	struct zynq_usb2_platform_data *pdata = pdev->dev.platform_data;
 	int rc;
 
 	rc = clk_prepare_enable(pdata->clk);
@@ -398,7 +398,7 @@ static int xusbps_udc_clk_init(struct platform_device *pdev)
 		goto err_out_clk_put;
 	}
 
-	pdata->clk_rate_change_nb.notifier_call = xusbps_udc_clk_notifier_cb;
+	pdata->clk_rate_change_nb.notifier_call = zynq_udc_clk_notifier_cb;
 	pdata->clk_rate_change_nb.next = NULL;
 	if (clk_notifier_register(pdata->clk, &pdata->clk_rate_change_nb))
 		dev_warn(&pdev->dev, "Unable to register clock notifier.\n");
@@ -411,9 +411,9 @@ err_out_clk_put:
 	return rc;
 }
 
-static void xusbps_udc_clk_release(struct platform_device *pdev)
+static void zynq_udc_clk_release(struct platform_device *pdev)
 {
-	struct xusbps_usb2_platform_data *pdata = pdev->dev.platform_data;
+	struct zynq_usb2_platform_data *pdata = pdev->dev.platform_data;
 
 	clk_disable_unprepare(pdata->clk);
 }
@@ -421,16 +421,16 @@ static void xusbps_udc_clk_release(struct platform_device *pdev)
 
 #define	DMA_ADDR_INVALID	(~(dma_addr_t)0)
 
-static const char driver_name[] = "xusbps-udc";
+static const char driver_name[] = "zynq-udc";
 static const char driver_desc[] = DRIVER_DESC;
 
 static struct usb_dr_device __iomem *dr_regs;
 
 /* it is initialized in probe()  */
-static struct xusbps_udc *udc_controller;
+static struct zynq_udc *udc_controller;
 
 static const struct usb_endpoint_descriptor
-xusbps_ep0_desc = {
+zynq_ep0_desc = {
 	.bLength =		USB_DT_ENDPOINT_SIZE,
 	.bDescriptorType =	USB_DT_ENDPOINT,
 	.bEndpointAddress =	0,
@@ -438,14 +438,14 @@ xusbps_ep0_desc = {
 	.wMaxPacketSize =	USB_MAX_CTRL_PAYLOAD,
 };
 
-static void xusbps_ep_fifo_flush(struct usb_ep *_ep);
+static void zynq_ep_fifo_flush(struct usb_ep *_ep);
 
-static inline u32 xusbps_readl(const unsigned __iomem *addr)
+static inline u32 zynq_readl(const unsigned __iomem *addr)
 {
 	return readl(addr);
 }
 
-static inline void xusbps_writel(u32 val32, unsigned __iomem *addr)
+static inline void zynq_writel(u32 val32, unsigned __iomem *addr)
 {
 	writel(val32, addr);
 }
@@ -458,15 +458,15 @@ static inline void xusbps_writel(u32 val32, unsigned __iomem *addr)
  * @status : request status to be set, only works when
  *	request is still in progress.
  *--------------------------------------------------------------*/
-static void done(struct xusbps_ep *ep, struct xusbps_req *req, int status)
+static void done(struct zynq_ep *ep, struct zynq_req *req, int status)
 {
-	struct xusbps_udc *udc = NULL;
+	struct zynq_udc *udc = NULL;
 	unsigned char stopped = ep->stopped;
 	struct ep_td_struct *curr_td, *next_td;
 	int j;
 
-	udc = (struct xusbps_udc *)ep->udc;
-	/* Removed the req from xusbps_ep->queue */
+	udc = (struct zynq_udc *)ep->udc;
+	/* Removed the req from zynq_ep->queue */
 	list_del_init(&req->queue);
 
 	/* req.status should be set as -EINPROGRESS in ep_queue() */
@@ -520,18 +520,18 @@ static void done(struct xusbps_ep *ep, struct xusbps_req *req, int status)
  * nuke(): delete all requests related to this ep
  * called with spinlock held
  *--------------------------------------------------------------*/
-static void nuke(struct xusbps_ep *ep, int status)
+static void nuke(struct zynq_ep *ep, int status)
 {
 	ep->stopped = 1;
 
 	/* Flush fifo */
-	xusbps_ep_fifo_flush(&ep->ep);
+	zynq_ep_fifo_flush(&ep->ep);
 
 	/* Whether this eq has request linked */
 	while (!list_empty(&ep->queue)) {
-		struct xusbps_req *req = NULL;
+		struct zynq_req *req = NULL;
 
-		req = list_entry(ep->queue.next, struct xusbps_req, queue);
+		req = list_entry(ep->queue.next, struct zynq_req, queue);
 		done(ep, req, status);
 	}
 }
@@ -540,45 +540,45 @@ static void nuke(struct xusbps_ep *ep, int status)
 	Internal Hardware related function
  ------------------------------------------------------------------*/
 
-static int dr_controller_setup(struct xusbps_udc *udc)
+static int dr_controller_setup(struct zynq_udc *udc)
 {
 	unsigned int tmp, portctrl;
 	unsigned long timeout;
-#define XUSBPS_UDC_RESET_TIMEOUT 1000
+#define ZYNQ_UDC_RESET_TIMEOUT 1000
 
 	/* Config PHY interface */
-	portctrl = xusbps_readl(&dr_regs->portsc1);
+	portctrl = zynq_readl(&dr_regs->portsc1);
 	portctrl &= ~(PORTSCX_PHY_TYPE_SEL | PORTSCX_PORT_WIDTH);
 	switch (udc->phy_mode) {
-	case XUSBPS_USB2_PHY_ULPI:
+	case ZYNQ_USB2_PHY_ULPI:
 		portctrl |= PORTSCX_PTS_ULPI;
 		break;
-	case XUSBPS_USB2_PHY_UTMI_WIDE:
+	case ZYNQ_USB2_PHY_UTMI_WIDE:
 		portctrl |= PORTSCX_PTW_16BIT;
 		/* fall through */
-	case XUSBPS_USB2_PHY_UTMI:
+	case ZYNQ_USB2_PHY_UTMI:
 		portctrl |= PORTSCX_PTS_UTMI;
 		break;
-	case XUSBPS_USB2_PHY_SERIAL:
+	case ZYNQ_USB2_PHY_SERIAL:
 		portctrl |= PORTSCX_PTS_FSLS;
 		break;
 	default:
 		return -EINVAL;
 	}
-	xusbps_writel(portctrl, &dr_regs->portsc1);
+	zynq_writel(portctrl, &dr_regs->portsc1);
 
 	/* Stop and reset the usb controller */
-	tmp = xusbps_readl(&dr_regs->usbcmd);
+	tmp = zynq_readl(&dr_regs->usbcmd);
 	tmp &= ~USB_CMD_RUN_STOP;
-	xusbps_writel(tmp, &dr_regs->usbcmd);
+	zynq_writel(tmp, &dr_regs->usbcmd);
 
-	tmp = xusbps_readl(&dr_regs->usbcmd);
+	tmp = zynq_readl(&dr_regs->usbcmd);
 	tmp |= USB_CMD_CTRL_RESET;
-	xusbps_writel(tmp, &dr_regs->usbcmd);
+	zynq_writel(tmp, &dr_regs->usbcmd);
 
 	/* Wait for reset to complete */
-	timeout = jiffies + XUSBPS_UDC_RESET_TIMEOUT;
-	while (xusbps_readl(&dr_regs->usbcmd) & USB_CMD_CTRL_RESET) {
+	timeout = jiffies + ZYNQ_UDC_RESET_TIMEOUT;
+	while (zynq_readl(&dr_regs->usbcmd) & USB_CMD_CTRL_RESET) {
 		if (time_after(jiffies, timeout)) {
 			ERR("udc reset timeout!\n");
 			return -ETIMEDOUT;
@@ -587,33 +587,33 @@ static int dr_controller_setup(struct xusbps_udc *udc)
 	}
 
 	/* Set the controller as device mode */
-	tmp = xusbps_readl(&dr_regs->usbmode);
+	tmp = zynq_readl(&dr_regs->usbmode);
 	tmp |= USB_MODE_CTRL_MODE_DEVICE;
 	/* Disable Setup Lockout */
 	tmp |= USB_MODE_SETUP_LOCK_OFF;
-	xusbps_writel(tmp, &dr_regs->usbmode);
+	zynq_writel(tmp, &dr_regs->usbmode);
 
 	/* Set OTG Terminate bit */
-	tmp = xusbps_readl(&dr_regs->otgsc);
+	tmp = zynq_readl(&dr_regs->otgsc);
 	tmp |= OTGSC_CTRL_OTG_TERM;
-	xusbps_writel(tmp, &dr_regs->otgsc);
+	zynq_writel(tmp, &dr_regs->otgsc);
 
 	/* Clear the setup status */
-	xusbps_writel(0, &dr_regs->usbsts);
+	zynq_writel(0, &dr_regs->usbsts);
 
 	tmp = udc->ep_qh_dma;
 	tmp &= USB_EP_LIST_ADDRESS_MASK;
-	xusbps_writel(tmp, &dr_regs->endpointlistaddr);
+	zynq_writel(tmp, &dr_regs->endpointlistaddr);
 
 	VDBG("vir[qh_base] is %p phy[qh_base] is 0x%8x reg is 0x%8x",
 		udc->ep_qh, (int)tmp,
-		xusbps_readl(&dr_regs->endpointlistaddr));
+		zynq_readl(&dr_regs->endpointlistaddr));
 
 	return 0;
 }
 
 /* Enable DR irq and set controller to run state */
-static void dr_controller_run(struct xusbps_udc *udc)
+static void dr_controller_run(struct zynq_udc *udc)
 {
 	u32 temp;
 
@@ -636,7 +636,7 @@ static void dr_controller_run(struct xusbps_udc *udc)
 		| USB_INTR_DEVICE_SUSPEND | USB_INTR_SYS_ERR_EN;
 #endif
 
-	xusbps_writel(temp, &dr_regs->usbintr);
+	zynq_writel(temp, &dr_regs->usbintr);
 
 	/*
 	 * Enable disconnect notification using B session end interrupt.
@@ -644,37 +644,37 @@ static void dr_controller_run(struct xusbps_udc *udc)
 	 * in AR# 47538
 	 */
 	if (!gadget_is_otg(&udc->gadget)) {
-		temp = xusbps_readl(&dr_regs->otgsc);
+		temp = zynq_readl(&dr_regs->otgsc);
 		temp |= OTGSC_BSEIE;
-		xusbps_writel(temp, &dr_regs->otgsc);
+		zynq_writel(temp, &dr_regs->otgsc);
 	}
 
 	/* Clear stopped bit */
 	udc->stopped = 0;
 
 	/* Set the controller as device mode */
-	temp = xusbps_readl(&dr_regs->usbmode);
+	temp = zynq_readl(&dr_regs->usbmode);
 	temp |= USB_MODE_CTRL_MODE_DEVICE;
 	temp |= USB_MODE_SETUP_LOCK_OFF;
-	xusbps_writel(temp, &dr_regs->usbmode);
+	zynq_writel(temp, &dr_regs->usbmode);
 
 	/* Set OTG Terminate bit */
-	temp = xusbps_readl(&dr_regs->otgsc);
+	temp = zynq_readl(&dr_regs->otgsc);
 	temp |= OTGSC_CTRL_OTG_TERM;
-	xusbps_writel(temp, &dr_regs->otgsc);
+	zynq_writel(temp, &dr_regs->otgsc);
 
 	/* Set controller to Run */
-	temp = xusbps_readl(&dr_regs->usbcmd);
+	temp = zynq_readl(&dr_regs->usbcmd);
 	temp |= USB_CMD_RUN_STOP;
-	xusbps_writel(temp, &dr_regs->usbcmd);
+	zynq_writel(temp, &dr_regs->usbcmd);
 }
 
-static void dr_controller_stop(struct xusbps_udc *udc)
+static void dr_controller_stop(struct zynq_udc *udc)
 {
 	unsigned int tmp;
 
 	/* disable all INTR */
-	xusbps_writel(0, &dr_regs->usbintr);
+	zynq_writel(0, &dr_regs->usbintr);
 
 	/* Set stopped bit for isr */
 	udc->stopped = 1;
@@ -683,9 +683,9 @@ static void dr_controller_stop(struct xusbps_udc *udc)
 /*	usb_sys_regs->control = 0; */
 
 	/* set controller to Stop */
-	tmp = xusbps_readl(&dr_regs->usbcmd);
+	tmp = zynq_readl(&dr_regs->usbcmd);
 	tmp &= ~USB_CMD_RUN_STOP;
-	xusbps_writel(tmp, &dr_regs->usbcmd);
+	zynq_writel(tmp, &dr_regs->usbcmd);
 }
 
 static void dr_ep_setup(unsigned char ep_num, unsigned char dir,
@@ -693,7 +693,7 @@ static void dr_ep_setup(unsigned char ep_num, unsigned char dir,
 {
 	unsigned int tmp_epctrl = 0;
 
-	tmp_epctrl = xusbps_readl(&dr_regs->endptctrl[ep_num]);
+	tmp_epctrl = zynq_readl(&dr_regs->endptctrl[ep_num]);
 	if (dir) {
 		if (ep_num)
 			tmp_epctrl |= EPCTRL_TX_DATA_TOGGLE_RST;
@@ -708,7 +708,7 @@ static void dr_ep_setup(unsigned char ep_num, unsigned char dir,
 				<< EPCTRL_RX_EP_TYPE_SHIFT);
 	}
 
-	xusbps_writel(tmp_epctrl, &dr_regs->endptctrl[ep_num]);
+	zynq_writel(tmp_epctrl, &dr_regs->endptctrl[ep_num]);
 }
 
 static void
@@ -716,7 +716,7 @@ dr_ep_change_stall(unsigned char ep_num, unsigned char dir, int value)
 {
 	u32 tmp_epctrl = 0;
 
-	tmp_epctrl = xusbps_readl(&dr_regs->endptctrl[ep_num]);
+	tmp_epctrl = zynq_readl(&dr_regs->endptctrl[ep_num]);
 
 	if (value) {
 		/* set the stall bit */
@@ -734,7 +734,7 @@ dr_ep_change_stall(unsigned char ep_num, unsigned char dir, int value)
 			tmp_epctrl |= EPCTRL_RX_DATA_TOGGLE_RST;
 		}
 	}
-	xusbps_writel(tmp_epctrl, &dr_regs->endptctrl[ep_num]);
+	zynq_writel(tmp_epctrl, &dr_regs->endptctrl[ep_num]);
 }
 
 /* Get stall status of a specific ep
@@ -743,7 +743,7 @@ static int dr_ep_get_stall(unsigned char ep_num, unsigned char dir)
 {
 	u32 epctrl;
 
-	epctrl = xusbps_readl(&dr_regs->endptctrl[ep_num]);
+	epctrl = zynq_readl(&dr_regs->endptctrl[ep_num]);
 	if (dir)
 		return (epctrl & EPCTRL_TX_EP_STALL) ? 1 : 0;
 	else
@@ -759,7 +759,7 @@ static int dr_ep_get_stall(unsigned char ep_num, unsigned char dir)
  * @zlt: Zero Length Termination Select (1: disable; 0: enable)
  * @mult: Mult field
  ------------------------------------------------------------------*/
-static void struct_ep_qh_setup(struct xusbps_udc *udc, unsigned char ep_num,
+static void struct_ep_qh_setup(struct zynq_udc *udc, unsigned char ep_num,
 		unsigned char dir, unsigned char ep_type,
 		unsigned int max_pkt_len,
 		unsigned int zlt, unsigned char mult)
@@ -795,10 +795,10 @@ static void struct_ep_qh_setup(struct xusbps_udc *udc, unsigned char ep_num,
 }
 
 /* Setup qh structure and ep register for ep0. */
-static void ep0_setup(struct xusbps_udc *udc)
+static void ep0_setup(struct zynq_udc *udc)
 {
 	/* the intialization of an ep includes: fields in QH, Regs,
-	 * xusbps_ep struct */
+	 * zynq_ep struct */
 	struct_ep_qh_setup(udc, 0, USB_RECV, USB_ENDPOINT_XFER_CONTROL,
 			USB_MAX_CTRL_PAYLOAD, 1, 0);
 	struct_ep_qh_setup(udc, 0, USB_SEND, USB_ENDPOINT_XFER_CONTROL,
@@ -820,17 +820,17 @@ static void ep0_setup(struct xusbps_udc *udc)
  * the driver will enable or disable the relevant endpoints
  * ep0 doesn't use this routine. It is always enabled.
 -------------------------------------------------------------------------*/
-static int xusbps_ep_enable(struct usb_ep *_ep,
+static int zynq_ep_enable(struct usb_ep *_ep,
 		const struct usb_endpoint_descriptor *desc)
 {
-	struct xusbps_udc *udc = NULL;
-	struct xusbps_ep *ep = NULL;
+	struct zynq_udc *udc = NULL;
+	struct zynq_ep *ep = NULL;
 	unsigned short max = 0;
 	unsigned char mult = 0, zlt;
 	int retval = -EINVAL;
 	unsigned long flags = 0;
 
-	ep = container_of(_ep, struct xusbps_ep, ep);
+	ep = container_of(_ep, struct zynq_ep, ep);
 
 	/* catch various bogus parameters */
 	if (!_ep || !desc
@@ -910,15 +910,15 @@ en_done:
  * @ep : the ep being unconfigured. May not be ep0
  * Any pending and uncomplete req will complete with status (-ESHUTDOWN)
 *---------------------------------------------------------------------*/
-static int xusbps_ep_disable(struct usb_ep *_ep)
+static int zynq_ep_disable(struct usb_ep *_ep)
 {
-	struct xusbps_udc *udc = NULL;
-	struct xusbps_ep *ep = NULL;
+	struct zynq_udc *udc = NULL;
+	struct zynq_ep *ep = NULL;
 	unsigned long flags = 0;
 	u32 epctrl;
 	int ep_num;
 
-	ep = container_of(_ep, struct xusbps_ep, ep);
+	ep = container_of(_ep, struct zynq_ep, ep);
 	if (!_ep || !ep->ep.desc) {
 		VDBG("%s not enabled", _ep ? ep->ep.name : NULL);
 		return -EINVAL;
@@ -926,14 +926,14 @@ static int xusbps_ep_disable(struct usb_ep *_ep)
 
 	/* disable ep on controller */
 	ep_num = ep_index(ep);
-	epctrl = xusbps_readl(&dr_regs->endptctrl[ep_num]);
+	epctrl = zynq_readl(&dr_regs->endptctrl[ep_num]);
 	if (ep_is_in(ep))
 		epctrl &= ~EPCTRL_TX_ENABLE;
 	else
 		epctrl &= ~EPCTRL_RX_ENABLE;
-	xusbps_writel(epctrl, &dr_regs->endptctrl[ep_num]);
+	zynq_writel(epctrl, &dr_regs->endptctrl[ep_num]);
 
-	udc = (struct xusbps_udc *)ep->udc;
+	udc = (struct zynq_udc *)ep->udc;
 	spin_lock_irqsave(&udc->lock, flags);
 
 	/* nuke all pending requests (does flush) */
@@ -953,9 +953,9 @@ static int xusbps_ep_disable(struct usb_ep *_ep)
  * Returns the request, or null if one could not be allocated
 *---------------------------------------------------------------------*/
 static struct usb_request *
-xusbps_alloc_request(struct usb_ep *_ep, gfp_t gfp_flags)
+zynq_alloc_request(struct usb_ep *_ep, gfp_t gfp_flags)
 {
-	struct xusbps_req *req = NULL;
+	struct zynq_req *req = NULL;
 
 	req = kzalloc(sizeof *req, gfp_flags);
 	if (!req)
@@ -967,18 +967,18 @@ xusbps_alloc_request(struct usb_ep *_ep, gfp_t gfp_flags)
 	return &req->req;
 }
 
-static void xusbps_free_request(struct usb_ep *_ep, struct usb_request *_req)
+static void zynq_free_request(struct usb_ep *_ep, struct usb_request *_req)
 {
-	struct xusbps_req *req = NULL;
+	struct zynq_req *req = NULL;
 
-	req = container_of(_req, struct xusbps_req, req);
+	req = container_of(_req, struct zynq_req, req);
 
 	if (_req)
 		kfree(req);
 }
 
 /*-------------------------------------------------------------------------*/
-static void xusbps_queue_td(struct xusbps_ep *ep, struct xusbps_req *req)
+static void zynq_queue_td(struct zynq_ep *ep, struct zynq_req *req)
 {
 	int i = ep_index(ep) * 2 + ep_is_in(ep);
 	u32 temp, bitmask, tmp_stat;
@@ -994,40 +994,41 @@ static void xusbps_queue_td(struct xusbps_ep *ep, struct xusbps_req *req)
 	/* check if the pipe is empty */
 	if (!(list_empty(&ep->queue))) {
 		/* Add td to the end */
-		struct xusbps_req *lastreq;
-		lastreq = list_entry(ep->queue.prev, struct xusbps_req, queue);
+		struct zynq_req *lastreq;
+		lastreq = list_entry(ep->queue.prev, struct zynq_req, queue);
 		lastreq->tail->next_td_ptr =
 			cpu_to_le32(req->head->td_dma & DTD_ADDR_MASK);
 		wmb();
 		/* Read prime bit, if 1 goto done */
-		if (xusbps_readl(&dr_regs->endpointprime) & bitmask)
+		if (zynq_readl(&dr_regs->endpointprime) & bitmask)
 			goto out;
 
 		do {
 			/* Set ATDTW bit in USBCMD */
-			temp = xusbps_readl(&dr_regs->usbcmd);
-			xusbps_writel(temp | USB_CMD_ATDTW, &dr_regs->usbcmd);
+			temp = zynq_readl(&dr_regs->usbcmd);
+			zynq_writel(temp | USB_CMD_ATDTW, &dr_regs->usbcmd);
 
 			/* Read correct status bit */
-			tmp_stat = xusbps_readl(&dr_regs->endptstatus) &
+			tmp_stat = zynq_readl(&dr_regs->endptstatus) &
 				bitmask;
 
 #ifdef CONFIG_USB_ZYNQ_ERRATA_DT654401
 			/* Workaround for USB errata DT# 654401 */
-			temp = xusbps_readl(&dr_regs->usbcmd);
+			temp = zynq_readl(&dr_regs->usbcmd);
 			if (temp & USB_CMD_ATDTW) {
 				udelay(5);
-				if (xusbps_readl(&dr_regs->usbcmd) & USB_CMD_ATDTW)
+				if (zynq_readl(&dr_regs->usbcmd) &
+				    USB_CMD_ATDTW)
 					break;
 			}
 		} while (1);
 #else
-		} while (!(xusbps_readl(&dr_regs->usbcmd) & USB_CMD_ATDTW));
+		} while (!(zynq_readl(&dr_regs->usbcmd) & USB_CMD_ATDTW));
 #endif
 
 		/* Write ATDTW bit to 0 */
-		temp = xusbps_readl(&dr_regs->usbcmd);
-		xusbps_writel(temp & ~USB_CMD_ATDTW, &dr_regs->usbcmd);
+		temp = zynq_readl(&dr_regs->usbcmd);
+		zynq_writel(temp & ~USB_CMD_ATDTW, &dr_regs->usbcmd);
 
 		if (tmp_stat)
 			goto out;
@@ -1049,7 +1050,7 @@ static void xusbps_queue_td(struct xusbps_ep *ep, struct xusbps_req *req)
 	temp = ep_is_in(ep)
 		? (1 << (ep_index(ep) + 16))
 		: (1 << (ep_index(ep)));
-	xusbps_writel(temp, &dr_regs->endpointprime);
+	zynq_writel(temp, &dr_regs->endpointprime);
 out:
 	return;
 }
@@ -1060,7 +1061,7 @@ out:
  * @dma: return dma address of the dTD
  * @is_last: return flag if it is the last dTD of the request
  * return: pointer to the built dTD */
-static struct ep_td_struct *xusbps_build_dtd(struct xusbps_req *req, unsigned
+static struct ep_td_struct *zynq_build_dtd(struct zynq_req *req, unsigned
 		*length, dma_addr_t *dma, int *is_last)
 {
 	u32 swap_temp;
@@ -1120,7 +1121,7 @@ static struct ep_td_struct *xusbps_build_dtd(struct xusbps_req *req, unsigned
 }
 
 /* Generate dtd chain for a request */
-static int xusbps_req_to_dtd(struct xusbps_req *req)
+static int zynq_req_to_dtd(struct zynq_req *req)
 {
 	unsigned	count;
 	int		is_last;
@@ -1129,7 +1130,7 @@ static int xusbps_req_to_dtd(struct xusbps_req *req)
 	dma_addr_t dma;
 
 	do {
-		dtd = xusbps_build_dtd(req, &count, &dma, &is_last);
+		dtd = zynq_build_dtd(req, &count, &dma, &is_last);
 		if (dtd == NULL)
 			return -ENOMEM;
 
@@ -1155,11 +1156,11 @@ static int xusbps_req_to_dtd(struct xusbps_req *req)
 
 /* queues (submits) an I/O request to an endpoint */
 static int
-xusbps_ep_queue(struct usb_ep *_ep, struct usb_request *_req, gfp_t gfp_flags)
+zynq_ep_queue(struct usb_ep *_ep, struct usb_request *_req, gfp_t gfp_flags)
 {
-	struct xusbps_ep *ep = container_of(_ep, struct xusbps_ep, ep);
-	struct xusbps_req *req = container_of(_req, struct xusbps_req, req);
-	struct xusbps_udc *udc;
+	struct zynq_ep *ep = container_of(_ep, struct zynq_ep, ep);
+	struct zynq_req *req = container_of(_req, struct zynq_req, req);
+	struct zynq_udc *udc;
 	unsigned long flags;
 
 	/* catch various bogus parameters */
@@ -1207,8 +1208,8 @@ xusbps_ep_queue(struct usb_ep *_ep, struct usb_request *_req, gfp_t gfp_flags)
 	spin_lock_irqsave(&udc->lock, flags);
 
 	/* build dtds and push them to device queue */
-	if (!xusbps_req_to_dtd(req)) {
-		xusbps_queue_td(ep, req);
+	if (!zynq_req_to_dtd(req)) {
+		zynq_queue_td(ep, req);
 	} else {
 		spin_unlock_irqrestore(&udc->lock, flags);
 		return -ENOMEM;
@@ -1227,10 +1228,10 @@ xusbps_ep_queue(struct usb_ep *_ep, struct usb_request *_req, gfp_t gfp_flags)
 }
 
 /* dequeues (cancels, unlinks) an I/O request from an endpoint */
-static int xusbps_ep_dequeue(struct usb_ep *_ep, struct usb_request *_req)
+static int zynq_ep_dequeue(struct usb_ep *_ep, struct usb_request *_req)
 {
-	struct xusbps_ep *ep = container_of(_ep, struct xusbps_ep, ep);
-	struct xusbps_req *req;
+	struct zynq_ep *ep = container_of(_ep, struct zynq_ep, ep);
+	struct zynq_req *req;
 	unsigned long flags;
 	int ep_num, stopped, ret = 0;
 	u32 epctrl;
@@ -1244,12 +1245,12 @@ static int xusbps_ep_dequeue(struct usb_ep *_ep, struct usb_request *_req)
 	/* Stop the ep before we deal with the queue */
 	ep->stopped = 1;
 	ep_num = ep_index(ep);
-	epctrl = xusbps_readl(&dr_regs->endptctrl[ep_num]);
+	epctrl = zynq_readl(&dr_regs->endptctrl[ep_num]);
 	if (ep_is_in(ep))
 		epctrl &= ~EPCTRL_TX_ENABLE;
 	else
 		epctrl &= ~EPCTRL_RX_ENABLE;
-	xusbps_writel(epctrl, &dr_regs->endptctrl[ep_num]);
+	zynq_writel(epctrl, &dr_regs->endptctrl[ep_num]);
 
 	/* make sure it's actually queued on this endpoint */
 	list_for_each_entry(req, &ep->queue, queue) {
@@ -1264,30 +1265,30 @@ static int xusbps_ep_dequeue(struct usb_ep *_ep, struct usb_request *_req)
 	/* The request is in progress, or completed but not dequeued */
 	if (ep->queue.next == &req->queue) {
 		_req->status = -ECONNRESET;
-		xusbps_ep_fifo_flush(_ep);	/* flush current transfer */
+		zynq_ep_fifo_flush(_ep);	/* flush current transfer */
 
 		/* The request isn't the last request in this ep queue */
 		if (req->queue.next != &ep->queue) {
 			struct ep_queue_head *qh;
-			struct xusbps_req *next_req;
+			struct zynq_req *next_req;
 
 			qh = ep->qh;
 			next_req = list_entry(req->queue.next, struct
-					xusbps_req, queue);
+					zynq_req, queue);
 
 			/* Point the QH to the first TD of next request */
-			xusbps_writel((u32) next_req->head,
+			zynq_writel((u32) next_req->head,
 				(void __force __iomem *)&qh->curr_dtd_ptr);
 		}
 
 		/* The request hasn't been processed, patch up the TD chain */
 	} else {
-		struct xusbps_req *prev_req;
+		struct zynq_req *prev_req;
 
-		prev_req = list_entry(req->queue.prev, struct xusbps_req,
+		prev_req = list_entry(req->queue.prev, struct zynq_req,
 				queue);
-		xusbps_writel(
-		xusbps_readl((void __force __iomem *)&req->tail->next_td_ptr),
+		zynq_writel(
+		zynq_readl((void __force __iomem *)&req->tail->next_td_ptr),
 			(void __force __iomem *)&prev_req->tail->next_td_ptr);
 
 	}
@@ -1295,12 +1296,12 @@ static int xusbps_ep_dequeue(struct usb_ep *_ep, struct usb_request *_req)
 	done(ep, req, -ECONNRESET);
 
 	/* Enable EP */
-out:	epctrl = xusbps_readl(&dr_regs->endptctrl[ep_num]);
+out:	epctrl = zynq_readl(&dr_regs->endptctrl[ep_num]);
 	if (ep_is_in(ep))
 		epctrl |= EPCTRL_TX_ENABLE;
 	else
 		epctrl |= EPCTRL_RX_ENABLE;
-	xusbps_writel(epctrl, &dr_regs->endptctrl[ep_num]);
+	zynq_writel(epctrl, &dr_regs->endptctrl[ep_num]);
 	ep->stopped = stopped;
 
 	spin_unlock_irqrestore(&ep->udc->lock, flags);
@@ -1315,15 +1316,15 @@ out:	epctrl = xusbps_readl(&dr_regs->endptctrl[ep_num]);
  * @value: 1--set halt  0--clear halt
  * Returns zero, or a negative error code.
 *----------------------------------------------------------------*/
-static int xusbps_ep_set_halt(struct usb_ep *_ep, int value)
+static int zynq_ep_set_halt(struct usb_ep *_ep, int value)
 {
-	struct xusbps_ep *ep = NULL;
+	struct zynq_ep *ep = NULL;
 	unsigned long flags = 0;
 	int status = -EOPNOTSUPP;	/* operation not supported */
 	unsigned char ep_dir = 0, ep_num = 0;
-	struct xusbps_udc *udc = NULL;
+	struct zynq_udc *udc = NULL;
 
-	ep = container_of(_ep, struct xusbps_ep, ep);
+	ep = container_of(_ep, struct zynq_ep, ep);
 	udc = ep->udc;
 	if (!_ep || !ep->ep.desc) {
 		status = -EINVAL;
@@ -1362,12 +1363,12 @@ out:
 	return status;
 }
 
-static int xusbps_ep_set_wedge(struct usb_ep *_ep)
+static int zynq_ep_set_wedge(struct usb_ep *_ep)
 {
-	struct xusbps_ep *ep = NULL;
+	struct zynq_ep *ep = NULL;
 	unsigned long flags = 0;
 
-	ep = container_of(_ep, struct xusbps_ep, ep);
+	ep = container_of(_ep, struct zynq_ep, ep);
 
 	if (!ep || !ep->ep.desc)
 		return -EINVAL;
@@ -1379,18 +1380,18 @@ static int xusbps_ep_set_wedge(struct usb_ep *_ep)
 	return usb_ep_set_halt(_ep);
 }
 
-static void xusbps_ep_fifo_flush(struct usb_ep *_ep)
+static void zynq_ep_fifo_flush(struct usb_ep *_ep)
 {
-	struct xusbps_ep *ep;
+	struct zynq_ep *ep;
 	int ep_num, ep_dir;
 	u32 bits;
 	unsigned long timeout;
-#define XUSBPS_UDC_FLUSH_TIMEOUT 1000
+#define ZYNQ_UDC_FLUSH_TIMEOUT 1000
 
 	if (!_ep) {
 		return;
 	} else {
-		ep = container_of(_ep, struct xusbps_ep, ep);
+		ep = container_of(_ep, struct zynq_ep, ep);
 		if (!ep->ep.desc)
 			return;
 	}
@@ -1404,12 +1405,12 @@ static void xusbps_ep_fifo_flush(struct usb_ep *_ep)
 	else
 		bits = 1 << ep_num;
 
-	timeout = jiffies + XUSBPS_UDC_FLUSH_TIMEOUT;
+	timeout = jiffies + ZYNQ_UDC_FLUSH_TIMEOUT;
 	do {
-		xusbps_writel(bits, &dr_regs->endptflush);
+		zynq_writel(bits, &dr_regs->endptflush);
 
 		/* Wait until flush complete */
-		while (xusbps_readl(&dr_regs->endptflush)) {
+		while (zynq_readl(&dr_regs->endptflush)) {
 			if (time_after(jiffies, timeout)) {
 				ERR("ep flush timeout\n");
 				return;
@@ -1417,22 +1418,22 @@ static void xusbps_ep_fifo_flush(struct usb_ep *_ep)
 			cpu_relax();
 		}
 		/* See if we need to flush again */
-	} while (xusbps_readl(&dr_regs->endptstatus) & bits);
+	} while (zynq_readl(&dr_regs->endptstatus) & bits);
 }
 
-static struct usb_ep_ops xusbps_ep_ops = {
-	.enable = xusbps_ep_enable,
-	.disable = xusbps_ep_disable,
+static struct usb_ep_ops zynq_ep_ops = {
+	.enable = zynq_ep_enable,
+	.disable = zynq_ep_disable,
 
-	.alloc_request = xusbps_alloc_request,
-	.free_request = xusbps_free_request,
+	.alloc_request = zynq_alloc_request,
+	.free_request = zynq_free_request,
 
-	.queue = xusbps_ep_queue,
-	.dequeue = xusbps_ep_dequeue,
+	.queue = zynq_ep_queue,
+	.dequeue = zynq_ep_dequeue,
 
-	.set_halt = xusbps_ep_set_halt,
-	.set_wedge = xusbps_ep_set_wedge,
-	.fifo_flush = xusbps_ep_fifo_flush,	/* flush fifo */
+	.set_halt = zynq_ep_set_halt,
+	.set_wedge = zynq_ep_set_wedge,
+	.fifo_flush = zynq_ep_fifo_flush,	/* flush fifo */
 };
 
 /*-------------------------------------------------------------------------
@@ -1442,17 +1443,17 @@ static struct usb_ep_ops xusbps_ep_ops = {
 /*----------------------------------------------------------------------
  * Get the current frame number (from DR frame_index Reg )
  *----------------------------------------------------------------------*/
-static int xusbps_get_frame(struct usb_gadget *gadget)
+static int zynq_get_frame(struct usb_gadget *gadget)
 {
-	return (int)(xusbps_readl(&dr_regs->frindex) & USB_FRINDEX_MASKS);
+	return (int)(zynq_readl(&dr_regs->frindex) & USB_FRINDEX_MASKS);
 }
 
 /*-----------------------------------------------------------------------
  * Tries to wake up the host connected to this gadget
  -----------------------------------------------------------------------*/
-static int xusbps_wakeup(struct usb_gadget *gadget)
+static int zynq_wakeup(struct usb_gadget *gadget)
 {
-	struct xusbps_udc *udc = container_of(gadget, struct xusbps_udc,
+	struct zynq_udc *udc = container_of(gadget, struct zynq_udc,
 			gadget);
 	u32 portsc;
 
@@ -1460,37 +1461,37 @@ static int xusbps_wakeup(struct usb_gadget *gadget)
 	if (!udc->remote_wakeup)
 		return -ENOTSUPP;
 
-	portsc = xusbps_readl(&dr_regs->portsc1);
+	portsc = zynq_readl(&dr_regs->portsc1);
 	/* not suspended? */
 	if (!(portsc & PORTSCX_PORT_SUSPEND))
 		return 0;
 	/* trigger force resume */
 	portsc |= PORTSCX_PORT_FORCE_RESUME;
-	xusbps_writel(portsc, &dr_regs->portsc1);
+	zynq_writel(portsc, &dr_regs->portsc1);
 	return 0;
 }
 
-static int can_pullup(struct xusbps_udc *udc)
+static int can_pullup(struct zynq_udc *udc)
 {
 	return udc->driver && udc->softconnect && udc->vbus_active;
 }
 
 /* Notify controller that VBUS is powered, Called by whatever
    detects VBUS sessions */
-static int xusbps_vbus_session(struct usb_gadget *gadget, int is_active)
+static int zynq_vbus_session(struct usb_gadget *gadget, int is_active)
 {
-	struct xusbps_udc	*udc;
+	struct zynq_udc	*udc;
 	unsigned long	flags;
 
-	udc = container_of(gadget, struct xusbps_udc, gadget);
+	udc = container_of(gadget, struct zynq_udc, gadget);
 	spin_lock_irqsave(&udc->lock, flags);
 	VDBG("VBUS %s", is_active ? "on" : "off");
 	udc->vbus_active = (is_active != 0);
 	if (can_pullup(udc))
-		xusbps_writel((xusbps_readl(&dr_regs->usbcmd) |
+		zynq_writel((zynq_readl(&dr_regs->usbcmd) |
 					USB_CMD_RUN_STOP), &dr_regs->usbcmd);
 	else
-		xusbps_writel((xusbps_readl(&dr_regs->usbcmd) &
+		zynq_writel((zynq_readl(&dr_regs->usbcmd) &
 					~USB_CMD_RUN_STOP), &dr_regs->usbcmd);
 	spin_unlock_irqrestore(&udc->lock, flags);
 	return 0;
@@ -1503,11 +1504,11 @@ static int xusbps_vbus_session(struct usb_gadget *gadget, int is_active)
  *
  * Returns zero on success, else negative errno.
  */
-static int xusbps_vbus_draw(struct usb_gadget *gadget, unsigned mA)
+static int zynq_vbus_draw(struct usb_gadget *gadget, unsigned mA)
 {
-	struct xusbps_udc *udc;
+	struct zynq_udc *udc;
 
-	udc = container_of(gadget, struct xusbps_udc, gadget);
+	udc = container_of(gadget, struct zynq_udc, gadget);
 	if (udc->transceiver)
 		return usb_phy_set_power(udc->transceiver, mA);
 	return -ENOTSUPP;
@@ -1516,32 +1517,32 @@ static int xusbps_vbus_draw(struct usb_gadget *gadget, unsigned mA)
 /* Change Data+ pullup status
  * this func is used by usb_gadget_connect/disconnet
  */
-static int xusbps_pullup(struct usb_gadget *gadget, int is_on)
+static int zynq_pullup(struct usb_gadget *gadget, int is_on)
 {
-	struct xusbps_udc *udc;
+	struct zynq_udc *udc;
 
-	udc = container_of(gadget, struct xusbps_udc, gadget);
+	udc = container_of(gadget, struct zynq_udc, gadget);
 	udc->softconnect = (is_on != 0);
 	if (can_pullup(udc))
-		xusbps_writel((xusbps_readl(&dr_regs->usbcmd) |
+		zynq_writel((zynq_readl(&dr_regs->usbcmd) |
 					USB_CMD_RUN_STOP), &dr_regs->usbcmd);
 	else
-		xusbps_writel((xusbps_readl(&dr_regs->usbcmd) &
+		zynq_writel((zynq_readl(&dr_regs->usbcmd) &
 					~USB_CMD_RUN_STOP), &dr_regs->usbcmd);
 
 	return 0;
 }
 
-static void udc_reset_ep_queue(struct xusbps_udc *udc, u8 pipe)
+static void udc_reset_ep_queue(struct zynq_udc *udc, u8 pipe)
 {
-	struct xusbps_ep *ep = get_ep_by_pipe(udc, pipe);
+	struct zynq_ep *ep = get_ep_by_pipe(udc, pipe);
 
 	if (ep->name)
 		nuke(ep, -ESHUTDOWN);
 }
 
 /* Clear up all ep queues */
-static int reset_queues(struct xusbps_udc *udc)
+static int reset_queues(struct zynq_udc *udc)
 {
 	u8 pipe;
 
@@ -1560,10 +1561,10 @@ static int reset_queues(struct xusbps_udc *udc)
 /*----------------------------------------------------------------
  * OTG Related changes
  *--------------------------------------------------------------*/
-static int xusbps_udc_start_peripheral(struct usb_phy  *otg)
+static int zynq_udc_start_peripheral(struct usb_phy  *otg)
 {
 	struct usb_gadget	*gadget = otg->otg->gadget;
-	struct xusbps_udc *udc = container_of(gadget, struct xusbps_udc,
+	struct zynq_udc *udc = container_of(gadget, struct zynq_udc,
 						gadget);
 	unsigned long flags = 0;
 	unsigned int tmp;
@@ -1577,7 +1578,7 @@ static int xusbps_udc_start_peripheral(struct usb_phy  *otg)
 		/* A-device HABA resets the controller */
 		tmp = udc->ep_qh_dma;
 		tmp &= USB_EP_LIST_ADDRESS_MASK;
-		xusbps_writel(tmp, &dr_regs->endpointlistaddr);
+		zynq_writel(tmp, &dr_regs->endpointlistaddr);
 	}
 	ep0_setup(udc);
 	dr_controller_run(udc);
@@ -1591,10 +1592,10 @@ static int xusbps_udc_start_peripheral(struct usb_phy  *otg)
 	return 0;
 }
 
-static int xusbps_udc_stop_peripheral(struct usb_phy *otg)
+static int zynq_udc_stop_peripheral(struct usb_phy *otg)
 {
 	struct usb_gadget	*gadget = otg->otg->gadget;
-	struct xusbps_udc *udc = container_of(gadget, struct xusbps_udc,
+	struct zynq_udc *udc = container_of(gadget, struct zynq_udc,
 						gadget);
 
 	dr_controller_stop(udc);
@@ -1611,7 +1612,7 @@ static int xusbps_udc_stop_peripheral(struct usb_phy *otg)
  * Hook to gadget drivers
  * Called by initialization code of gadget drivers
 *----------------------------------------------------------------*/
-static int xusbps_udc_start(struct usb_gadget *g,
+static int zynq_udc_start(struct usb_gadget *g,
 				struct usb_gadget_driver *driver)
 {
 	int retval = 0;
@@ -1639,9 +1640,9 @@ static int xusbps_udc_start(struct usb_gadget *g,
 		}
 		/* Exporting start and stop routines */
 		udc_controller->xotg->start_peripheral =
-					xusbps_udc_start_peripheral;
+					zynq_udc_start_peripheral;
 		udc_controller->xotg->stop_peripheral =
-					xusbps_udc_stop_peripheral;
+					zynq_udc_stop_peripheral;
 
 		if (!udc_controller->transceiver->otg->default_a &&
 					udc_controller->stopped &&
@@ -1653,7 +1654,7 @@ static int xusbps_udc_start(struct usb_gadget *g,
 			udc_controller->usb_state = USB_STATE_ATTACHED;
 			udc_controller->ep0_state = WAIT_FOR_SETUP;
 			udc_controller->ep0_dir = 0;
-			xusbps_update_transceiver();
+			zynq_update_transceiver();
 		}
 	} else {
 		/* Enable DR IRQ reg and Set usbcmd reg  Run bit */
@@ -1679,10 +1680,10 @@ static int xusbps_udc_start(struct usb_gadget *g,
 }
 
 /* Disconnect from gadget driver */
-static int xusbps_udc_stop(struct usb_gadget *g,
+static int zynq_udc_stop(struct usb_gadget *g,
 		struct usb_gadget_driver *driver)
 {
-	struct xusbps_ep *loop_ep;
+	struct zynq_ep *loop_ep;
 	unsigned long flags;
 
 	if (udc_controller->transceiver)
@@ -1718,36 +1719,36 @@ static int xusbps_udc_stop(struct usb_gadget *g,
 }
 
 /* defined in gadget.h */
-static struct usb_gadget_ops xusbps_gadget_ops = {
-	.get_frame = xusbps_get_frame,
-	.wakeup = xusbps_wakeup,
-/*	.set_selfpowered = xusbps_set_selfpowered, */ /* Always selfpowered */
-	.vbus_session = xusbps_vbus_session,
-	.vbus_draw = xusbps_vbus_draw,
-	.pullup = xusbps_pullup,
-	.udc_start = xusbps_udc_start,
-	.udc_stop = xusbps_udc_stop,
+static struct usb_gadget_ops zynq_gadget_ops = {
+	.get_frame = zynq_get_frame,
+	.wakeup = zynq_wakeup,
+/*	.set_selfpowered = zynq_set_selfpowered, */ /* Always selfpowered */
+	.vbus_session = zynq_vbus_session,
+	.vbus_draw = zynq_vbus_draw,
+	.pullup = zynq_pullup,
+	.udc_start = zynq_udc_start,
+	.udc_stop = zynq_udc_stop,
 };
 
 /* Set protocol stall on ep0, protocol stall will automatically be cleared
    on new transaction */
-static void ep0stall(struct xusbps_udc *udc)
+static void ep0stall(struct zynq_udc *udc)
 {
 	u32 tmp;
 
 	/* must set tx and rx to stall at the same time */
-	tmp = xusbps_readl(&dr_regs->endptctrl[0]);
+	tmp = zynq_readl(&dr_regs->endptctrl[0]);
 	tmp |= EPCTRL_TX_EP_STALL | EPCTRL_RX_EP_STALL;
-	xusbps_writel(tmp, &dr_regs->endptctrl[0]);
+	zynq_writel(tmp, &dr_regs->endptctrl[0]);
 	udc->ep0_state = WAIT_FOR_SETUP;
 	udc->ep0_dir = 0;
 }
 
 /* Prime a status phase for ep0 */
-static int ep0_prime_status(struct xusbps_udc *udc, int direction)
+static int ep0_prime_status(struct zynq_udc *udc, int direction)
 {
-	struct xusbps_req *req = udc->status_req;
-	struct xusbps_ep *ep;
+	struct zynq_req *req = udc->status_req;
+	struct zynq_ep *ep;
 
 	if (direction == EP_DIR_IN)
 		udc->ep0_dir = USB_DIR_IN;
@@ -1768,8 +1769,8 @@ static int ep0_prime_status(struct xusbps_udc *udc, int direction)
 				ep_is_in(ep) ? DMA_TO_DEVICE : DMA_FROM_DEVICE);
 	req->mapped = 1;
 
-	if (xusbps_req_to_dtd(req) == 0)
-		xusbps_queue_td(ep, req);
+	if (zynq_req_to_dtd(req) == 0)
+		zynq_queue_td(ep, req);
 	else
 		return -ENOMEM;
 
@@ -1781,7 +1782,7 @@ static int ep0_prime_status(struct xusbps_udc *udc, int direction)
 /*
  * ch9 Set address
  */
-static void ch9setaddress(struct xusbps_udc *udc, u16 value, u16 index, u16
+static void ch9setaddress(struct zynq_udc *udc, u16 value, u16 index, u16
 		length)
 {
 	/* Save the new address to device struct */
@@ -1796,12 +1797,12 @@ static void ch9setaddress(struct xusbps_udc *udc, u16 value, u16 index, u16
 /*
  * ch9 Get status
  */
-static void ch9getstatus(struct xusbps_udc *udc, u8 request_type, u16 value,
+static void ch9getstatus(struct zynq_udc *udc, u8 request_type, u16 value,
 		u16 index, u16 length)
 {
 	u16 tmp = 0;		/* Status, cpu endian */
-	struct xusbps_req *req;
-	struct xusbps_ep *ep;
+	struct zynq_req *req;
+	struct zynq_ep *ep;
 
 	ep = &udc->eps[0];
 
@@ -1815,7 +1816,7 @@ static void ch9getstatus(struct xusbps_udc *udc, u8 request_type, u16 value,
 		tmp = 0;
 	} else if ((request_type & USB_RECIP_MASK) == USB_RECIP_ENDPOINT) {
 		/* Get endpoint status */
-		struct xusbps_ep *target_ep;
+		struct zynq_ep *target_ep;
 
 		target_ep = get_ep_by_pipe(udc, get_pipe_by_windex(index));
 
@@ -1843,8 +1844,8 @@ static void ch9getstatus(struct xusbps_udc *udc, u8 request_type, u16 value,
 	req->mapped = 1;
 
 	/* prime the data phase */
-	if ((xusbps_req_to_dtd(req) == 0))
-		xusbps_queue_td(ep, req);
+	if ((zynq_req_to_dtd(req) == 0))
+		zynq_queue_td(ep, req);
 	else			/* no mem */
 		goto stall;
 
@@ -1855,7 +1856,7 @@ stall:
 	ep0stall(udc);
 }
 
-static void setup_received_irq(struct xusbps_udc *udc,
+static void setup_received_irq(struct zynq_udc *udc,
 		struct usb_ctrlrequest *setup)
 {
 	u16 wValue = le16_to_cpu(setup->wValue);
@@ -1892,7 +1893,7 @@ static void setup_received_irq(struct xusbps_udc *udc,
 		if ((setup->bRequestType & (USB_RECIP_MASK | USB_TYPE_MASK))
 				== (USB_RECIP_ENDPOINT | USB_TYPE_STANDARD)) {
 			int pipe = get_pipe_by_windex(wIndex);
-			struct xusbps_ep *ep;
+			struct zynq_ep *ep;
 
 			if (wValue != 0 || wLength != 0 || pipe > udc->max_ep)
 				break;
@@ -1900,10 +1901,10 @@ static void setup_received_irq(struct xusbps_udc *udc,
 
 			spin_unlock(&udc->lock);
 			if (setup->bRequest == USB_REQ_SET_FEATURE) {
-				 rc = xusbps_ep_set_halt(&ep->ep, 1);
+				rc = zynq_ep_set_halt(&ep->ep, 1);
 			} else {
 				if (!ep->wedge)
-					rc = xusbps_ep_set_halt(&ep->ep, 0);
+					rc = zynq_ep_set_halt(&ep->ep, 0);
 				else
 					rc = 0;
 			}
@@ -1949,9 +1950,9 @@ status_phase:
 					u32 tmp;
 					/* Wait for status phase to complete */
 					mdelay(1);
-					tmp = xusbps_readl(&dr_regs->portsc1);
+					tmp = zynq_readl(&dr_regs->portsc1);
 					tmp |= (testsel << 16);
-					xusbps_writel(tmp, &dr_regs->portsc1);
+					zynq_writel(tmp, &dr_regs->portsc1);
 				}
 			}
 		}
@@ -1988,13 +1989,13 @@ status_phase:
 
 /* Process request for Data or Status phase of ep0
  * prime status phase if needed */
-static void ep0_req_complete(struct xusbps_udc *udc, struct xusbps_ep *ep0,
-		struct xusbps_req *req)
+static void ep0_req_complete(struct zynq_udc *udc, struct zynq_ep *ep0,
+		struct zynq_req *req)
 {
 	if (udc->usb_state == USB_STATE_ADDRESS) {
 		/* Set the new address */
 		u32 new_address = (u32) udc->device_address;
-		xusbps_writel(new_address << USB_DEVICE_ADDRESS_BIT_POS,
+		zynq_writel(new_address << USB_DEVICE_ADDRESS_BIT_POS,
 				&dr_regs->deviceaddr);
 	}
 
@@ -2025,7 +2026,7 @@ static void ep0_req_complete(struct xusbps_udc *udc, struct xusbps_ep *ep0,
 
 /* Tripwire mechanism to ensure a setup packet payload is extracted without
  * being corrupted by another incoming setup packet */
-static void tripwire_handler(struct xusbps_udc *udc, u8 ep_num, u8 *buffer_ptr)
+static void tripwire_handler(struct zynq_udc *udc, u8 ep_num, u8 *buffer_ptr)
 {
 	u32 temp;
 	struct ep_queue_head *qh;
@@ -2033,27 +2034,27 @@ static void tripwire_handler(struct xusbps_udc *udc, u8 ep_num, u8 *buffer_ptr)
 	qh = &udc->ep_qh[ep_num * 2 + EP_DIR_OUT];
 
 	/* Clear bit in ENDPTSETUPSTAT */
-	temp = xusbps_readl(&dr_regs->endptsetupstat);
-	xusbps_writel(temp | (1 << ep_num), &dr_regs->endptsetupstat);
+	temp = zynq_readl(&dr_regs->endptsetupstat);
+	zynq_writel(temp | (1 << ep_num), &dr_regs->endptsetupstat);
 
 	/* while a hazard exists when setup package arrives */
 	do {
 		/* Set Setup Tripwire */
-		temp = xusbps_readl(&dr_regs->usbcmd);
-		xusbps_writel(temp | USB_CMD_SUTW, &dr_regs->usbcmd);
+		temp = zynq_readl(&dr_regs->usbcmd);
+		zynq_writel(temp | USB_CMD_SUTW, &dr_regs->usbcmd);
 
 		/* Copy the setup packet to local buffer */
 		memcpy(buffer_ptr, (u8 *) qh->setup_buffer, 8);
-	} while (!(xusbps_readl(&dr_regs->usbcmd) & USB_CMD_SUTW));
+	} while (!(zynq_readl(&dr_regs->usbcmd) & USB_CMD_SUTW));
 
 	/* Clear Setup Tripwire */
-	temp = xusbps_readl(&dr_regs->usbcmd);
-	xusbps_writel(temp & ~USB_CMD_SUTW, &dr_regs->usbcmd);
+	temp = zynq_readl(&dr_regs->usbcmd);
+	zynq_writel(temp & ~USB_CMD_SUTW, &dr_regs->usbcmd);
 }
 
 /* process-ep_req(): free the completed Tds for this req */
-static int process_ep_req(struct xusbps_udc *udc, int pipe,
-		struct xusbps_req *curr_req)
+static int process_ep_req(struct zynq_udc *udc, int pipe,
+		struct zynq_req *curr_req)
 {
 	struct ep_td_struct *curr_td;
 	int	td_complete, actual, remaining_length, j, tmp;
@@ -2129,16 +2130,16 @@ static int process_ep_req(struct xusbps_udc *udc, int pipe,
 }
 
 /* Process a DTD completion interrupt */
-static void dtd_complete_irq(struct xusbps_udc *udc)
+static void dtd_complete_irq(struct zynq_udc *udc)
 {
 	u32 bit_pos;
 	int i, ep_num, direction, bit_mask, status;
-	struct xusbps_ep *curr_ep;
-	struct xusbps_req *curr_req, *temp_req;
+	struct zynq_ep *curr_ep;
+	struct zynq_req *curr_req, *temp_req;
 
 	/* Clear the bits in the register */
-	bit_pos = xusbps_readl(&dr_regs->endptcomplete);
-	xusbps_writel(bit_pos, &dr_regs->endptcomplete);
+	bit_pos = zynq_readl(&dr_regs->endptcomplete);
+	zynq_writel(bit_pos, &dr_regs->endptcomplete);
 
 	if (!bit_pos)
 		return;
@@ -2169,6 +2170,8 @@ static void dtd_complete_irq(struct xusbps_udc *udc)
 					status, ep_num);
 			if (status == REQ_UNCOMPLETE)
 				break;
+			/* Clear the endpoint complete events */
+			zynq_writel(bit_pos, &dr_regs->endptcomplete);
 			/* write back status to req */
 			curr_req->req.status = status;
 
@@ -2182,14 +2185,14 @@ static void dtd_complete_irq(struct xusbps_udc *udc)
 }
 
 /* Process a port change interrupt */
-static void port_change_irq(struct xusbps_udc *udc)
+static void port_change_irq(struct zynq_udc *udc)
 {
 	u32 speed;
 
 	/* Bus resetting is finished */
-	if (!(xusbps_readl(&dr_regs->portsc1) & PORTSCX_PORT_RESET)) {
+	if (!(zynq_readl(&dr_regs->portsc1) & PORTSCX_PORT_RESET)) {
 		/* Get the speed */
-		speed = (xusbps_readl(&dr_regs->portsc1)
+		speed = (zynq_readl(&dr_regs->portsc1)
 				& PORTSCX_PORT_SPEED_MASK);
 		switch (speed) {
 		case PORTSCX_PORT_SPEED_HIGH:
@@ -2213,7 +2216,7 @@ static void port_change_irq(struct xusbps_udc *udc)
 }
 
 /* Process suspend interrupt */
-static void suspend_irq(struct xusbps_udc *udc)
+static void suspend_irq(struct zynq_udc *udc)
 {
 	udc->resume_state = udc->usb_state;
 	udc->usb_state = USB_STATE_SUSPENDED;
@@ -2224,7 +2227,7 @@ static void suspend_irq(struct xusbps_udc *udc)
 			udc->xotg->hsm.b_bus_suspend = 1;
 			/* notify transceiver the state changes */
 			if (spin_trylock(&udc->xotg->wq_lock)) {
-				xusbps_update_transceiver();
+				zynq_update_transceiver();
 				spin_unlock(&udc->xotg->wq_lock);
 			}
 		} else {
@@ -2233,7 +2236,7 @@ static void suspend_irq(struct xusbps_udc *udc)
 				udc->xotg->hsm.b_bus_req = 1;
 				/* notify transceiver the state changes */
 				if (spin_trylock(&udc->xotg->wq_lock)) {
-					xusbps_update_transceiver();
+					zynq_update_transceiver();
 					spin_unlock(&udc->xotg->wq_lock);
 				}
 			}
@@ -2245,7 +2248,7 @@ static void suspend_irq(struct xusbps_udc *udc)
 		udc->driver->suspend(&udc->gadget);
 }
 
-static void bus_resume(struct xusbps_udc *udc)
+static void bus_resume(struct zynq_udc *udc)
 {
 	udc->usb_state = udc->resume_state;
 	udc->resume_state = 0;
@@ -2256,14 +2259,14 @@ static void bus_resume(struct xusbps_udc *udc)
 }
 
 /* Process reset interrupt */
-static void reset_irq(struct xusbps_udc *udc)
+static void reset_irq(struct zynq_udc *udc)
 {
 	u32 temp;
 	unsigned long timeout;
 
 	/* Clear the device address */
-	temp = xusbps_readl(&dr_regs->deviceaddr);
-	xusbps_writel(temp & ~USB_DEVICE_ADDRESS_MASK, &dr_regs->deviceaddr);
+	temp = zynq_readl(&dr_regs->deviceaddr);
+	zynq_writel(temp & ~USB_DEVICE_ADDRESS_MASK, &dr_regs->deviceaddr);
 
 	udc->device_address = 0;
 
@@ -2277,15 +2280,15 @@ static void reset_irq(struct xusbps_udc *udc)
 	udc->gadget.a_alt_hnp_support = 0;
 
 	/* Clear all the setup token semaphores */
-	temp = xusbps_readl(&dr_regs->endptsetupstat);
-	xusbps_writel(temp, &dr_regs->endptsetupstat);
+	temp = zynq_readl(&dr_regs->endptsetupstat);
+	zynq_writel(temp, &dr_regs->endptsetupstat);
 
 	/* Clear all the endpoint complete status bits */
-	temp = xusbps_readl(&dr_regs->endptcomplete);
-	xusbps_writel(temp, &dr_regs->endptcomplete);
+	temp = zynq_readl(&dr_regs->endptcomplete);
+	zynq_writel(temp, &dr_regs->endptcomplete);
 
 	timeout = jiffies + 100;
-	while (xusbps_readl(&dr_regs->endpointprime)) {
+	while (zynq_readl(&dr_regs->endpointprime)) {
 		/* Wait until all endptprime bits cleared */
 		if (time_after(jiffies, timeout)) {
 			ERR("Timeout for reset\n");
@@ -2295,7 +2298,7 @@ static void reset_irq(struct xusbps_udc *udc)
 	}
 
 	/* Write 1s to the flush register */
-	xusbps_writel(0xffffffff, &dr_regs->endptflush);
+	zynq_writel(0xffffffff, &dr_regs->endptflush);
 
 	VDBG("Bus reset");
 	/* Reset all the queues, include XD, dTD, EP queue
@@ -2307,9 +2310,9 @@ static void reset_irq(struct xusbps_udc *udc)
 /*
  * USB device controller interrupt handler
  */
-static irqreturn_t xusbps_udc_irq(int irq, void *_udc)
+static irqreturn_t zynq_udc_irq(int irq, void *_udc)
 {
-	struct xusbps_udc *udc = _udc;
+	struct zynq_udc *udc = _udc;
 	u32 irq_src, otg_sts;
 	irqreturn_t status = IRQ_NONE;
 	unsigned long flags;
@@ -2333,11 +2336,11 @@ static irqreturn_t xusbps_udc_irq(int irq, void *_udc)
 	}
 #endif
 	spin_lock_irqsave(&udc->lock, flags);
-	irq_src = xusbps_readl(&dr_regs->usbsts) &
-		xusbps_readl(&dr_regs->usbintr);
+	irq_src = zynq_readl(&dr_regs->usbsts) &
+		zynq_readl(&dr_regs->usbintr);
 
 	/* Clear notification bits */
-	xusbps_writel(irq_src, &dr_regs->usbsts);
+	zynq_writel(irq_src, &dr_regs->usbsts);
 
 	/*
 	 * Check disconnect event from B session end interrupt.
@@ -2345,9 +2348,9 @@ static irqreturn_t xusbps_udc_irq(int irq, void *_udc)
 	 * in AR# 47538
 	 */
 	if (!gadget_is_otg(&udc->gadget)) {
-		otg_sts = xusbps_readl(&dr_regs->otgsc);
+		otg_sts = zynq_readl(&dr_regs->otgsc);
 		if (otg_sts & OTGSC_BSEIS) {
-			xusbps_writel(otg_sts, &dr_regs->otgsc);
+			zynq_writel(otg_sts, &dr_regs->otgsc);
 			reset_queues(udc);
 			status = IRQ_HANDLED;
 		}
@@ -2357,7 +2360,7 @@ static irqreturn_t xusbps_udc_irq(int irq, void *_udc)
 
 	/* Need to resume? */
 	if (udc->usb_state == USB_STATE_SUSPENDED)
-		if ((xusbps_readl(&dr_regs->portsc1) &
+		if ((zynq_readl(&dr_regs->portsc1) &
 					PORTSCX_PORT_SUSPEND) == 0)
 			bus_resume(udc);
 
@@ -2365,7 +2368,7 @@ static irqreturn_t xusbps_udc_irq(int irq, void *_udc)
 	if (irq_src & USB_STS_INT) {
 		VDBG("Packet int");
 		/* Setup package, we only support ep0 as control ep */
-		if (xusbps_readl(&dr_regs->endptsetupstat) &
+		if (zynq_readl(&dr_regs->endptsetupstat) &
 						EP_SETUP_STATUS_EP0) {
 			tripwire_handler(udc, 0,
 					(u8 *) (&udc->local_setup_buff));
@@ -2374,7 +2377,7 @@ static irqreturn_t xusbps_udc_irq(int irq, void *_udc)
 		}
 
 		/* completion of dtd */
-		if (xusbps_readl(&dr_regs->endptcomplete)) {
+		if (zynq_readl(&dr_regs->endptcomplete)) {
 			dtd_complete_irq(udc);
 			status = IRQ_HANDLED;
 		}
@@ -2396,16 +2399,16 @@ static irqreturn_t xusbps_udc_irq(int irq, void *_udc)
 #ifdef CONFIG_USB_ZYNQ_PHY
 		if (gadget_is_otg(&udc->gadget)) {
 			/* Clear any previous suspend status bit */
-			temp = xusbps_readl(&dr_regs->usbsts);
+			temp = zynq_readl(&dr_regs->usbsts);
 			if (temp & USB_INTR_DEVICE_SUSPEND) {
 				udc->usb_state = USB_STATE_SUSPENDED;
 				temp |= USB_INTR_DEVICE_SUSPEND;
-				xusbps_writel(temp, &dr_regs->usbsts);
+				zynq_writel(temp, &dr_regs->usbsts);
 			}
 			/* Enable suspend interrupt */
-			temp = xusbps_readl(&dr_regs->usbintr);
+			temp = zynq_readl(&dr_regs->usbintr);
 			temp |= USB_INTR_DEVICE_SUSPEND;
-			xusbps_writel(temp, &dr_regs->usbintr);
+			zynq_writel(temp, &dr_regs->usbintr);
 		}
 #endif
 		status = IRQ_HANDLED;
@@ -2431,16 +2434,16 @@ static irqreturn_t xusbps_udc_irq(int irq, void *_udc)
 
 #include <linux/seq_file.h>
 
-static const char proc_filename[] = "driver/xusbps_udc";
+static const char proc_filename[] = "driver/zynq_udc";
 
-static int xusbps_proc_read(struct seq_file *m, void *v)
+static int zynq_proc_read(struct seq_file *m, void *v)
 {
 	unsigned long flags;
 	int i;
 	u32 tmp_reg;
-	struct xusbps_ep *ep = NULL;
-	struct xusbps_req *req;
-	struct xusbps_udc *udc = udc_controller;
+	struct zynq_ep *ep = NULL;
+	struct zynq_req *req;
+	struct zynq_udc *udc = udc_controller;
 
 	spin_lock_irqsave(&udc->lock, flags);
 
@@ -2452,14 +2455,14 @@ static int xusbps_proc_read(struct seq_file *m, void *v)
 			udc->driver ? udc->driver->driver.name : "(none)");
 
 	/* ------ DR Registers ----- */
-	tmp_reg = xusbps_readl(&dr_regs->usbcmd);
+	tmp_reg = zynq_readl(&dr_regs->usbcmd);
 	seq_printf(m, "USBCMD reg:\n"
 			"SetupTW: %d\n"
 			"Run/Stop: %s\n\n",
 			(tmp_reg & USB_CMD_SUTW) ? 1 : 0,
 			(tmp_reg & USB_CMD_RUN_STOP) ? "Run" : "Stop");
 
-	tmp_reg = xusbps_readl(&dr_regs->usbsts);
+	tmp_reg = zynq_readl(&dr_regs->usbsts);
 	seq_printf(m, "USB Status Reg:\n"
 			"Dr Suspend: %d Reset Received: %d System Error: %s "
 			"USB Error Interrupt: %s\n\n",
@@ -2468,7 +2471,7 @@ static int xusbps_proc_read(struct seq_file *m, void *v)
 			(tmp_reg & USB_STS_SYS_ERR) ? "Err" : "Normal",
 			(tmp_reg & USB_STS_ERR) ? "Err detected" : "No err");
 
-	tmp_reg = xusbps_readl(&dr_regs->usbintr);
+	tmp_reg = zynq_readl(&dr_regs->usbintr);
 	seq_printf(m, "USB Intrrupt Enable Reg:\n"
 			"Sleep Enable: %d SOF Received Enable: %d "
 			"Reset Enable: %d\n"
@@ -2483,20 +2486,20 @@ static int xusbps_proc_read(struct seq_file *m, void *v)
 			(tmp_reg & USB_INTR_ERR_INT_EN) ? 1 : 0,
 			(tmp_reg & USB_INTR_INT_EN) ? 1 : 0);
 
-	tmp_reg = xusbps_readl(&dr_regs->frindex);
+	tmp_reg = zynq_readl(&dr_regs->frindex);
 	seq_printf(m, "USB Frame Index Reg: Frame Number is 0x%x\n\n",
 			(tmp_reg & USB_FRINDEX_MASKS));
 
-	tmp_reg = xusbps_readl(&dr_regs->deviceaddr);
+	tmp_reg = zynq_readl(&dr_regs->deviceaddr);
 	seq_printf(m, "USB Device Address Reg: Device Addr is 0x%x\n\n",
 			(tmp_reg & USB_DEVICE_ADDRESS_MASK));
 
-	tmp_reg = xusbps_readl(&dr_regs->endpointlistaddr);
+	tmp_reg = zynq_readl(&dr_regs->endpointlistaddr);
 	seq_printf(m, "USB Endpoint List Address Reg: "
 			"Device Addr is 0x%x\n\n",
 			(tmp_reg & USB_EP_LIST_ADDRESS_MASK));
 
-	tmp_reg = xusbps_readl(&dr_regs->portsc1);
+	tmp_reg = zynq_readl(&dr_regs->portsc1);
 	seq_printf(m, "USB Port Status&Control Reg:\n"
 		"Port Transceiver Type : %s Port Speed: %s\n"
 		"PHY Low Power Suspend: %s Port Reset: %s "
@@ -2542,7 +2545,7 @@ static int xusbps_proc_read(struct seq_file *m, void *v)
 		(tmp_reg & PORTSCX_CURRENT_CONNECT_STATUS) ?
 		"Attached" : "Not-Att");
 
-	tmp_reg = xusbps_readl(&dr_regs->usbmode);
+	tmp_reg = zynq_readl(&dr_regs->usbmode);
 	seq_printf(m, "USB Mode Reg: Controller Mode is: %s\n\n", ({
 				char *s;
 				switch (tmp_reg & USB_MODE_CTRL_MODE_HOST) {
@@ -2558,19 +2561,19 @@ static int xusbps_proc_read(struct seq_file *m, void *v)
 				s;
 			}));
 
-	tmp_reg = xusbps_readl(&dr_regs->endptsetupstat);
+	tmp_reg = zynq_readl(&dr_regs->endptsetupstat);
 	seq_printf(m, "Endpoint Setup Status Reg: SETUP on ep 0x%x\n\n",
 			(tmp_reg & EP_SETUP_STATUS_MASK));
 
 	for (i = 0; i < udc->max_ep / 2; i++) {
-		tmp_reg = xusbps_readl(&dr_regs->endptctrl[i]);
+		tmp_reg = zynq_readl(&dr_regs->endptctrl[i]);
 		seq_printf(m, "EP Ctrl Reg [0x%x]: = [0x%x]\n",
 				i, tmp_reg);
 	}
-	tmp_reg = xusbps_readl(&dr_regs->endpointprime);
+	tmp_reg = zynq_readl(&dr_regs->endpointprime);
 	seq_printf(m, "EP Prime Reg = [0x%x]\n\n", tmp_reg);
 
-	/* ------xusbps_udc, xusbps_ep, xusbps_request structure information
+	/* ------zynq_udc, zynq_ep, zynq_request structure information
 	 * ----- */
 	ep = &udc->eps[0];
 	seq_printf(m, "For %s Maxpkt is 0x%x index is 0x%x\n",
@@ -2616,20 +2619,20 @@ static int xusbps_proc_read(struct seq_file *m, void *v)
 /*
  * seq_file wrappers for procfile show routines.
  */
-static int xusbps_proc_open(struct inode *inode, struct file *file)
+static int zynq_proc_open(struct inode *inode, struct file *file)
 {
-	return single_open(file, xusbps_proc_read, NULL);
+	return single_open(file, zynq_proc_read, NULL);
 }
 
-static const struct file_operations proc_xusbps_fops = {
-	.open		= xusbps_proc_open,
+static const struct file_operations proc_zynq_fops = {
+	.open		= zynq_proc_open,
 	.read		= seq_read,
 	.llseek		= seq_lseek,
 	.release	= seq_release,
 };
 
 #define create_proc_file()	proc_create(proc_filename, \
-					0, NULL, &proc_xusbps_fops)
+					0, NULL, &proc_zynq_fops)
 
 #define remove_proc_file()	remove_proc_entry(proc_filename, NULL)
 
@@ -2643,7 +2646,7 @@ static const struct file_operations proc_xusbps_fops = {
 /*-------------------------------------------------------------------------*/
 
 /* Release udc structures */
-static void xusbps_udc_release(struct device *dev)
+static void zynq_udc_release(struct device *dev)
 {
 	complete(udc_controller->done);
 	dma_free_coherent(dev->parent, udc_controller->ep_qh_size,
@@ -2658,10 +2661,10 @@ static void xusbps_udc_release(struct device *dev)
  * init resource for globle controller
  * Return the udc handle on success or NULL on failure
  ------------------------------------------------------------------*/
-static int struct_udc_setup(struct xusbps_udc *udc,
+static int struct_udc_setup(struct zynq_udc *udc,
 		struct platform_device *pdev)
 {
-	struct xusbps_usb2_platform_data *pdata;
+	struct zynq_usb2_platform_data *pdata;
 	size_t size;
 
 	pdata = pdev->dev.platform_data;
@@ -2669,7 +2672,7 @@ static int struct_udc_setup(struct xusbps_udc *udc,
 
 	udc->eps = kzalloc(sizeof(*udc->eps) * udc->max_ep, GFP_KERNEL);
 	if (!udc->eps) {
-		dev_err(&pdev->dev, "malloc xusbps_ep failed\n");
+		dev_err(&pdev->dev, "malloc zynq_ep failed\n");
 		return -1;
 	}
 
@@ -2692,9 +2695,9 @@ static int struct_udc_setup(struct xusbps_udc *udc,
 	udc->ep_qh_size = size;
 
 	/* Initialize ep0 status request structure */
-	/* FIXME: xusbps_alloc_request() ignores ep argument */
-	udc->status_req = container_of(xusbps_alloc_request(NULL, GFP_KERNEL),
-			struct xusbps_req, req);
+	/* FIXME: zynq_alloc_request() ignores ep argument */
+	udc->status_req = container_of(zynq_alloc_request(NULL, GFP_KERNEL),
+			struct zynq_req, req);
 	/* allocate a small amount of memory to get valid address */
 	udc->status_req->req.buf = kmalloc(8, GFP_KERNEL);
 
@@ -2707,21 +2710,21 @@ static int struct_udc_setup(struct xusbps_udc *udc,
 }
 
 /*----------------------------------------------------------------
- * Setup the xusbps_ep struct for eps
- * Link xusbps_ep->ep to gadget->ep_list
+ * Setup the zynq_ep struct for eps
+ * Link zynq_ep->ep to gadget->ep_list
  * ep0out is not used so do nothing here
  * ep0in should be taken care
  *--------------------------------------------------------------*/
-static int struct_ep_setup(struct xusbps_udc *udc,
+static int struct_ep_setup(struct zynq_udc *udc,
 				unsigned char index, char *name, int link)
 {
-	struct xusbps_ep *ep = &udc->eps[index];
+	struct zynq_ep *ep = &udc->eps[index];
 
 	ep->udc = udc;
 	strcpy(ep->name, name);
 	ep->ep.name = ep->name;
 
-	ep->ep.ops = &xusbps_ep_ops;
+	ep->ep.ops = &zynq_ep_ops;
 	ep->stopped = 0;
 
 	/* for ep0: maxP defined in desc
@@ -2745,12 +2748,12 @@ static int struct_ep_setup(struct xusbps_udc *udc,
  * all intialization operations implemented here except enabling usb_intr reg
  * board setup should have been done in the platform code
  */
-static int xusbps_udc_probe(struct platform_device *pdev)
+static int zynq_udc_probe(struct platform_device *pdev)
 {
 	int ret = -ENODEV;
 	unsigned int i;
 	u32 dccparams;
-	struct xusbps_usb2_platform_data *pdata;
+	struct zynq_usb2_platform_data *pdata;
 
 	pdata = pdev->dev.platform_data;
 	if (!pdata) {
@@ -2785,12 +2788,12 @@ static int xusbps_udc_probe(struct platform_device *pdev)
 	}
 #endif
 	/* Initialize USB clocks */
-	ret = xusbps_udc_clk_init(pdev);
+	ret = zynq_udc_clk_init(pdev);
 	if (ret < 0)
 		goto err_kfree;
 
 	/* Read Device Controller Capability Parameters register */
-	dccparams = xusbps_readl(&dr_regs->dccparams);
+	dccparams = zynq_readl(&dr_regs->dccparams);
 	if (!(dccparams & DCCPARAMS_DC)) {
 		dev_err(&pdev->dev, "This SOC doesn't support device role\n");
 		ret = -ENODEV;
@@ -2806,7 +2809,7 @@ static int xusbps_udc_probe(struct platform_device *pdev)
 		goto err_iounmap;
 	}
 
-	ret = devm_request_irq(&pdev->dev, udc_controller->irq, xusbps_udc_irq,
+	ret = devm_request_irq(&pdev->dev, udc_controller->irq, zynq_udc_irq,
 				IRQF_SHARED, driver_name, udc_controller);
 	if (ret != 0) {
 		dev_err(&pdev->dev, "cannot request irq %d err %d\n",
@@ -2831,7 +2834,7 @@ static int xusbps_udc_probe(struct platform_device *pdev)
 #endif
 
 	/* Setup gadget structure */
-	udc_controller->gadget.ops = &xusbps_gadget_ops;
+	udc_controller->gadget.ops = &zynq_gadget_ops;
 	udc_controller->gadget.max_speed = USB_SPEED_HIGH;
 	udc_controller->gadget.ep0 = &udc_controller->eps[0].ep;
 	INIT_LIST_HEAD(&udc_controller->gadget.ep_list);
@@ -2842,7 +2845,7 @@ static int xusbps_udc_probe(struct platform_device *pdev)
 
 	/* Setup gadget.dev and register with kernel */
 	dev_set_name(&udc_controller->gadget.dev, "gadget");
-	udc_controller->gadget.dev.release = xusbps_udc_release;
+	udc_controller->gadget.dev.release = zynq_udc_release;
 	udc_controller->gadget.dev.parent = &pdev->dev;
 
 	/* setup QH and epctrl for ep0 */
@@ -2853,7 +2856,7 @@ static int xusbps_udc_probe(struct platform_device *pdev)
 	/* for ep0: the desc defined here;
 	 * for other eps, gadget layer called ep_enable with defined desc
 	 */
-	udc_controller->eps[0].ep.desc = &xusbps_ep0_desc;
+	udc_controller->eps[0].ep.desc = &zynq_ep0_desc;
 	udc_controller->eps[0].ep.maxpacket = USB_MAX_CTRL_PAYLOAD;
 
 	/* setup the udc->eps[] for non-control endpoints and link
@@ -2892,7 +2895,7 @@ err_del_udc:
 err_unregister:
 	device_unregister(&udc_controller->gadget.dev);
 err_iounmap:
-	xusbps_udc_clk_release(pdev);
+	zynq_udc_clk_release(pdev);
 err_kfree:
 	kfree(udc_controller);
 	udc_controller = NULL;
@@ -2902,7 +2905,7 @@ err_kfree:
 /* Driver removal function
  * Free resources and finish pending transactions
  */
-static int __exit xusbps_udc_remove(struct platform_device *pdev)
+static int __exit zynq_udc_remove(struct platform_device *pdev)
 {
 	DECLARE_COMPLETION(done);
 
@@ -2912,7 +2915,7 @@ static int __exit xusbps_udc_remove(struct platform_device *pdev)
 	usb_del_gadget_udc(&udc_controller->gadget);
 	udc_controller->done = &done;
 
-	xusbps_udc_clk_release(pdev);
+	zynq_udc_clk_release(pdev);
 
 	/* DR has been stopped in usb_gadget_unregister_driver() */
 	remove_proc_file();
@@ -2936,10 +2939,10 @@ static int __exit xusbps_udc_remove(struct platform_device *pdev)
  * Modify Power management attributes
  * Used by OTG statemachine to disable gadget temporarily
  -----------------------------------------------------------------*/
-static int xusbps_udc_suspend(struct device *dev)
+static int zynq_udc_suspend(struct device *dev)
 {
 	struct platform_device *pdev = to_platform_device(dev);
-	struct xusbps_usb2_platform_data *pdata = pdev->dev.platform_data;
+	struct zynq_usb2_platform_data *pdata = pdev->dev.platform_data;
 
 	dr_controller_stop(udc_controller);
 
@@ -2952,10 +2955,10 @@ static int xusbps_udc_suspend(struct device *dev)
  * Invoked on USB resume. May be called in_interrupt.
  * Here we start the DR controller and enable the irq
  *-----------------------------------------------------------------*/
-static int xusbps_udc_resume(struct device *dev)
+static int zynq_udc_resume(struct device *dev)
 {
 	struct platform_device *pdev = to_platform_device(dev);
-	struct xusbps_usb2_platform_data *pdata = pdev->dev.platform_data;
+	struct zynq_usb2_platform_data *pdata = pdev->dev.platform_data;
 	int ret;
 
 	ret = clk_enable(pdata->clk);
@@ -2975,13 +2978,13 @@ static int xusbps_udc_resume(struct device *dev)
 	return 0;
 }
 
-static const struct dev_pm_ops xusbps_udc_dev_pm_ops = {
-	SET_SYSTEM_SLEEP_PM_OPS(xusbps_udc_suspend, xusbps_udc_resume)
+static const struct dev_pm_ops zynq_udc_dev_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(zynq_udc_suspend, zynq_udc_resume)
 };
-#define XUSBPS_UDC_PM	(&xusbps_udc_dev_pm_ops)
+#define ZYNQ_UDC_PM	(&zynq_udc_dev_pm_ops)
 
 #else /* ! CONFIG_PM_SLEEP */
-#define XUSBPS_UDC_PM	NULL
+#define ZYNQ_UDC_PM	NULL
 #endif /* ! CONFIG_PM_SLEEP */
 
 /*-------------------------------------------------------------------------
@@ -2989,13 +2992,13 @@ static const struct dev_pm_ops xusbps_udc_dev_pm_ops = {
 --------------------------------------------------------------------------*/
 
 static struct platform_driver udc_driver = {
-	.probe   = xusbps_udc_probe,
-	.remove  = xusbps_udc_remove,
+	.probe   = zynq_udc_probe,
+	.remove  = zynq_udc_remove,
 	/* these suspend and resume are not usb suspend and resume */
 	.driver  = {
 		.name = (char *)driver_name,
 		.owner = THIS_MODULE,
-		.pm = XUSBPS_UDC_PM,
+		.pm = ZYNQ_UDC_PM,
 	},
 };
 
@@ -3004,4 +3007,4 @@ module_platform_driver(udc_driver);
 MODULE_DESCRIPTION(DRIVER_DESC);
 MODULE_AUTHOR(DRIVER_AUTHOR);
 MODULE_LICENSE("GPL");
-MODULE_ALIAS("platform:xusbps-udc");
+MODULE_ALIAS("platform:zynq-udc");
diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 041f18e..39fdbf8 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1302,7 +1302,7 @@ MODULE_LICENSE ("GPL");
 
 #ifdef CONFIG_USB_EHCI_ZYNQ
 #include "ehci-zynq.c"
-#define PLATFORM_DRIVER		ehci_xusbps_driver
+#define PLATFORM_DRIVER		ehci_zynq_driver
 #endif
 
 #ifdef CONFIG_USB_W90X900_EHCI
diff --git a/drivers/usb/host/ehci-zynq.c b/drivers/usb/host/ehci-zynq.c
index b1df18a..2cb5179 100644
--- a/drivers/usb/host/ehci-zynq.c
+++ b/drivers/usb/host/ehci-zynq.c
@@ -28,16 +28,16 @@
 /********************************************************************
  * OTG related functions
  ********************************************************************/
-static int ehci_xusbps_reinit(struct ehci_hcd *ehci);
+static int ehci_zynq_reinit(struct ehci_hcd *ehci);
 
 /* This connection event is useful when a OTG test device is connected.
    In that case, the device connect notify event will not be generated
    since the device will be suspended before complete enumeration.
 */
-static int ehci_xusbps_update_device(struct usb_hcd *hcd, struct usb_device
+static int ehci_zynq_update_device(struct usb_hcd *hcd, struct usb_device
 		*udev)
 {
-	struct xusbps_otg *xotg = xceiv_to_xotg(hcd->phy);
+	struct zynq_otg *xotg = xceiv_to_xotg(hcd->phy);
 
 	if (udev->portnum == hcd->self.otg_port) {
 		/* HNP test device */
@@ -47,13 +47,13 @@ static int ehci_xusbps_update_device(struct usb_hcd *hcd, struct usb_device
 				xotg->hsm.b_conn = 1;
 			else
 				xotg->hsm.a_conn = 1;
-			xusbps_update_transceiver();
+			zynq_update_transceiver();
 		}
 	}
 	return 0;
 }
 
-static void ehci_xusbps_start_hnp(struct ehci_hcd *ehci)
+static void ehci_zynq_start_hnp(struct ehci_hcd *ehci)
 {
 	const unsigned	port = ehci_to_hcd(ehci)->self.otg_port - 1;
 	struct usb_hcd *hcd = ehci_to_hcd(ehci);
@@ -69,17 +69,17 @@ static void ehci_xusbps_start_hnp(struct ehci_hcd *ehci)
 	otg_start_hnp(hcd->phy->otg);
 }
 
-static int ehci_xusbps_otg_start_host(struct usb_phy *otg)
+static int ehci_zynq_otg_start_host(struct usb_phy *otg)
 {
 	struct usb_hcd		*hcd = bus_to_hcd(otg->otg->host);
-	struct xusbps_otg *xotg =
+	struct zynq_otg *xotg =
 			xceiv_to_xotg(hcd->phy);
 
 	usb_add_hcd(hcd, xotg->irq, IRQF_SHARED);
 	return 0;
 }
 
-static int ehci_xusbps_otg_stop_host(struct usb_phy *otg)
+static int ehci_zynq_otg_stop_host(struct usb_phy *otg)
 {
 	struct usb_hcd		*hcd = bus_to_hcd(otg->otg->host);
 
@@ -88,7 +88,7 @@ static int ehci_xusbps_otg_stop_host(struct usb_phy *otg)
 }
 #endif
 
-static int xusbps_ehci_clk_notifier_cb(struct notifier_block *nb,
+static int zynq_ehci_clk_notifier_cb(struct notifier_block *nb,
 		unsigned long event, void *data)
 {
 
@@ -111,7 +111,7 @@ static int xusbps_ehci_clk_notifier_cb(struct notifier_block *nb,
 /* always called with process context; sleeping is OK */
 
 /**
- * usb_hcd_xusbps_probe - initialize XUSBPS-based HCDs
+ * usb_hcd_zynq_probe - initialize ZYNQ-based HCDs
  * @driver: Driver to be used for this HCD
  * @pdev: USB Host Controller being probed
  * Context: !in_interrupt()
@@ -119,18 +119,18 @@ static int xusbps_ehci_clk_notifier_cb(struct notifier_block *nb,
  * Allocates basic resources for this USB host controller.
  *
  */
-static int usb_hcd_xusbps_probe(const struct hc_driver *driver,
+static int usb_hcd_zynq_probe(const struct hc_driver *driver,
 			     struct platform_device *pdev)
 {
-	struct xusbps_usb2_platform_data *pdata;
+	struct zynq_usb2_platform_data *pdata;
 	struct usb_hcd *hcd;
 	int irq;
 	int retval;
 
-	pr_debug("initializing XUSBPS-SOC USB Controller\n");
+	pr_debug("initializing ZYNQ-SOC USB Controller\n");
 
 	/* Need platform data for setup */
-	pdata = (struct xusbps_usb2_platform_data *)pdev->dev.platform_data;
+	pdata = (struct zynq_usb2_platform_data *)pdev->dev.platform_data;
 	if (!pdata) {
 		dev_err(&pdev->dev,
 			"No platform data for %s.\n", dev_name(&pdev->dev));
@@ -141,9 +141,9 @@ static int usb_hcd_xusbps_probe(const struct hc_driver *driver,
 	 * This is a host mode driver, verify that we're supposed to be
 	 * in host mode.
 	 */
-	if (!((pdata->operating_mode == XUSBPS_USB2_DR_HOST) ||
-	      (pdata->operating_mode == XUSBPS_USB2_MPH_HOST) ||
-	      (pdata->operating_mode == XUSBPS_USB2_DR_OTG))) {
+	if (!((pdata->operating_mode == ZYNQ_USB2_DR_HOST) ||
+	      (pdata->operating_mode == ZYNQ_USB2_MPH_HOST) ||
+	      (pdata->operating_mode == ZYNQ_USB2_DR_OTG))) {
 		dev_err(&pdev->dev, "Non Host Mode configured for %s. Wrong \
 				driver linked.\n", dev_name(&pdev->dev));
 		return -ENODEV;
@@ -170,7 +170,7 @@ static int usb_hcd_xusbps_probe(const struct hc_driver *driver,
 		goto err2;
 	}
 
-	pdata->clk_rate_change_nb.notifier_call = xusbps_ehci_clk_notifier_cb;
+	pdata->clk_rate_change_nb.notifier_call = zynq_ehci_clk_notifier_cb;
 	pdata->clk_rate_change_nb.next = NULL;
 	if (clk_notifier_register(pdata->clk, &pdata->clk_rate_change_nb))
 		dev_warn(&pdev->dev, "Unable to register clock notifier.\n");
@@ -186,7 +186,7 @@ static int usb_hcd_xusbps_probe(const struct hc_driver *driver,
 
 #ifdef CONFIG_USB_ZYNQ_PHY
 	if (pdata->otg) {
-		struct xusbps_otg *xotg;
+		struct zynq_otg *xotg;
 		struct ehci_hcd *ehci = hcd_to_ehci(hcd);
 
 		hcd->self.otg_port = 1;
@@ -196,11 +196,11 @@ static int usb_hcd_xusbps_probe(const struct hc_driver *driver,
 		if (retval)
 			goto err_out_clk_unreg_notif;
 		xotg = xceiv_to_xotg(hcd->phy);
-		ehci->start_hnp = ehci_xusbps_start_hnp;
-		xotg->start_host = ehci_xusbps_otg_start_host;
-		xotg->stop_host = ehci_xusbps_otg_stop_host;
+		ehci->start_hnp = ehci_zynq_start_hnp;
+		xotg->start_host = ehci_zynq_otg_start_host;
+		xotg->stop_host = ehci_zynq_otg_stop_host;
 		/* inform otg driver about host driver */
-		xusbps_update_transceiver();
+		zynq_update_transceiver();
 	} else {
 		retval = usb_add_hcd(hcd, irq, IRQF_SHARED);
 		if (retval)
@@ -238,17 +238,17 @@ err1:
 /* may be called with controller, bus, and devices active */
 
 /**
- * usb_hcd_xusbps_remove - shutdown processing for XUSBPS-based HCDs
+ * usb_hcd_zynq_remove - shutdown processing for ZYNQ-based HCDs
  * @dev: USB Host Controller being removed
  * Context: !in_interrupt()
  *
- * Reverses the effect of usb_hcd_xusbps_probe().
+ * Reverses the effect of usb_hcd_zynq_probe().
  *
  */
-static void usb_hcd_xusbps_remove(struct usb_hcd *hcd,
+static void usb_hcd_zynq_remove(struct usb_hcd *hcd,
 			       struct platform_device *pdev)
 {
-	struct xusbps_usb2_platform_data *pdata = pdev->dev.platform_data;
+	struct zynq_usb2_platform_data *pdata = pdev->dev.platform_data;
 
 	usb_remove_hcd(hcd);
 
@@ -263,8 +263,8 @@ static void usb_hcd_xusbps_remove(struct usb_hcd *hcd,
 	clk_disable_unprepare(pdata->clk);
 }
 
-static void ehci_xusbps_setup_phy(struct ehci_hcd *ehci,
-			       enum xusbps_usb2_phy_modes phy_mode,
+static void ehci_zynq_setup_phy(struct ehci_hcd *ehci,
+			       enum zynq_usb2_phy_modes phy_mode,
 			       unsigned int port_offset)
 {
 	u32 portsc;
@@ -273,40 +273,40 @@ static void ehci_xusbps_setup_phy(struct ehci_hcd *ehci,
 	portsc &= ~(PORT_PTS_MSK | PORT_PTS_PTW);
 
 	switch (phy_mode) {
-	case XUSBPS_USB2_PHY_ULPI:
+	case ZYNQ_USB2_PHY_ULPI:
 		portsc |= PORT_PTS_ULPI;
 		break;
-	case XUSBPS_USB2_PHY_SERIAL:
+	case ZYNQ_USB2_PHY_SERIAL:
 		portsc |= PORT_PTS_SERIAL;
 		break;
-	case XUSBPS_USB2_PHY_UTMI_WIDE:
+	case ZYNQ_USB2_PHY_UTMI_WIDE:
 		portsc |= PORT_PTS_PTW;
 		/* fall through */
-	case XUSBPS_USB2_PHY_UTMI:
+	case ZYNQ_USB2_PHY_UTMI:
 		portsc |= PORT_PTS_UTMI;
 		break;
-	case XUSBPS_USB2_PHY_NONE:
+	case ZYNQ_USB2_PHY_NONE:
 		break;
 	}
 	ehci_writel(ehci, portsc, &ehci->regs->port_status[port_offset]);
 }
 
-static void ehci_xusbps_usb_setup(struct ehci_hcd *ehci)
+static void ehci_zynq_usb_setup(struct ehci_hcd *ehci)
 {
 	struct usb_hcd *hcd = ehci_to_hcd(ehci);
-	struct xusbps_usb2_platform_data *pdata;
+	struct zynq_usb2_platform_data *pdata;
 
 	pdata = hcd->self.controller->platform_data;
 
-	if ((pdata->operating_mode == XUSBPS_USB2_DR_HOST) ||
-			(pdata->operating_mode == XUSBPS_USB2_DR_OTG))
-		ehci_xusbps_setup_phy(ehci, pdata->phy_mode, 0);
+	if ((pdata->operating_mode == ZYNQ_USB2_DR_HOST) ||
+			(pdata->operating_mode == ZYNQ_USB2_DR_OTG))
+		ehci_zynq_setup_phy(ehci, pdata->phy_mode, 0);
 
-	if (pdata->operating_mode == XUSBPS_USB2_MPH_HOST) {
-		if (pdata->port_enables & XUSBPS_USB2_PORT0_ENABLED)
-			ehci_xusbps_setup_phy(ehci, pdata->phy_mode, 0);
-		if (pdata->port_enables & XUSBPS_USB2_PORT1_ENABLED)
-			ehci_xusbps_setup_phy(ehci, pdata->phy_mode, 1);
+	if (pdata->operating_mode == ZYNQ_USB2_MPH_HOST) {
+		if (pdata->port_enables & ZYNQ_USB2_PORT0_ENABLED)
+			ehci_zynq_setup_phy(ehci, pdata->phy_mode, 0);
+		if (pdata->port_enables & ZYNQ_USB2_PORT1_ENABLED)
+			ehci_zynq_setup_phy(ehci, pdata->phy_mode, 1);
 	}
 }
 
@@ -333,13 +333,13 @@ static void ehci_port_power(struct ehci_hcd *ehci, int is_on)
 }
 
 /* called after powerup, by probe or system-pm "wakeup" */
-static int ehci_xusbps_reinit(struct ehci_hcd *ehci)
+static int ehci_zynq_reinit(struct ehci_hcd *ehci)
 {
 #ifdef CONFIG_USB_ZYNQ_PHY
 	struct usb_hcd *hcd = ehci_to_hcd(ehci);
 #endif
 
-	ehci_xusbps_usb_setup(ehci);
+	ehci_zynq_usb_setup(ehci);
 #ifdef CONFIG_USB_ZYNQ_PHY
 	/* Don't turn off port power in OTG mode */
 	if (!hcd->phy)
@@ -349,7 +349,7 @@ static int ehci_xusbps_reinit(struct ehci_hcd *ehci)
 	return 0;
 }
 
-struct ehci_xusbps {
+struct ehci_zynq {
 	struct ehci_hcd	ehci;
 
 #ifdef CONFIG_PM
@@ -359,7 +359,7 @@ struct ehci_xusbps {
 };
 
 /* called during probe() after chip reset completes */
-static int ehci_xusbps_setup(struct usb_hcd *hcd)
+static int ehci_zynq_setup(struct usb_hcd *hcd)
 {
 	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
 	int retval;
@@ -389,11 +389,11 @@ static int ehci_xusbps_setup(struct usb_hcd *hcd)
 
 	ehci_reset(ehci);
 
-	retval = ehci_xusbps_reinit(ehci);
+	retval = ehci_zynq_reinit(ehci);
 	return retval;
 }
 
-static void ehci_xusbps_shutdown(struct usb_hcd *hcd)
+static void ehci_zynq_shutdown(struct usb_hcd *hcd)
 {
 	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
 
@@ -402,10 +402,10 @@ static void ehci_xusbps_shutdown(struct usb_hcd *hcd)
 }
 
 #ifdef CONFIG_PM_SLEEP
-static int ehci_xusbps_drv_suspend(struct device *dev)
+static int ehci_zynq_drv_suspend(struct device *dev)
 {
 	struct usb_hcd *hcd = dev_get_drvdata(dev);
-	struct xusbps_usb2_platform_data *pdata = dev->platform_data;
+	struct zynq_usb2_platform_data *pdata = dev->platform_data;
 
 	ehci_prepare_ports_for_controller_suspend(hcd_to_ehci(hcd),
 			device_may_wakeup(dev));
@@ -415,11 +415,11 @@ static int ehci_xusbps_drv_suspend(struct device *dev)
 	return 0;
 }
 
-static int ehci_xusbps_drv_resume(struct device *dev)
+static int ehci_zynq_drv_resume(struct device *dev)
 {
 	struct usb_hcd *hcd = dev_get_drvdata(dev);
 	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
-	struct xusbps_usb2_platform_data *pdata = dev->platform_data;
+	struct zynq_usb2_platform_data *pdata = dev->platform_data;
 	int ret;
 
 	ret = clk_enable(pdata->clk);
@@ -433,25 +433,25 @@ static int ehci_xusbps_drv_resume(struct device *dev)
 	usb_root_hub_lost_power(hcd->self.root_hub);
 
 	ehci_reset(ehci);
-	ehci_xusbps_reinit(ehci);
+	ehci_zynq_reinit(ehci);
 
 	return 0;
 }
 
-static const struct dev_pm_ops ehci_xusbps_pm_ops = {
-	SET_SYSTEM_SLEEP_PM_OPS(ehci_xusbps_drv_suspend, ehci_xusbps_drv_resume)
+static const struct dev_pm_ops ehci_zynq_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(ehci_zynq_drv_suspend, ehci_zynq_drv_resume)
 };
-#define EHCI_XUSBPS_PM_OPS	(&ehci_xusbps_pm_ops)
+#define EHCI_ZYNQ_PM_OPS	(&ehci_zynq_pm_ops)
 
 #else /* ! CONFIG_PM_SLEEP */
-#define EHCI_XUSBPS_PM_OPS	NULL
+#define EHCI_ZYNQ_PM_OPS	NULL
 #endif /* ! CONFIG_PM_SLEEP */
 
 
-static const struct hc_driver ehci_xusbps_hc_driver = {
+static const struct hc_driver ehci_zynq_hc_driver = {
 	.description = hcd_name,
 	.product_desc = "Xilinx Zynq USB EHCI Host Controller",
-	.hcd_priv_size = sizeof(struct ehci_xusbps),
+	.hcd_priv_size = sizeof(struct ehci_zynq),
 
 	/*
 	 * generic hardware linkage
@@ -462,10 +462,10 @@ static const struct hc_driver ehci_xusbps_hc_driver = {
 	/*
 	 * basic lifecycle operations
 	 */
-	.reset = ehci_xusbps_setup,
+	.reset = ehci_zynq_setup,
 	.start = ehci_run,
 	.stop = ehci_stop,
-	.shutdown = ehci_xusbps_shutdown,
+	.shutdown = ehci_zynq_shutdown,
 
 	/*
 	 * managing i/o requests and associated device resources
@@ -492,36 +492,36 @@ static const struct hc_driver ehci_xusbps_hc_driver = {
 
 	.clear_tt_buffer_complete = ehci_clear_tt_buffer_complete,
 #ifdef CONFIG_USB_ZYNQ_PHY
-	.update_device = ehci_xusbps_update_device,
+	.update_device = ehci_zynq_update_device,
 #endif
 };
 
-static int ehci_xusbps_drv_probe(struct platform_device *pdev)
+static int ehci_zynq_drv_probe(struct platform_device *pdev)
 {
 	if (usb_disabled())
 		return -ENODEV;
 
 	/* FIXME we only want one one probe() not two */
-	return usb_hcd_xusbps_probe(&ehci_xusbps_hc_driver, pdev);
+	return usb_hcd_zynq_probe(&ehci_zynq_hc_driver, pdev);
 }
 
-static int ehci_xusbps_drv_remove(struct platform_device *pdev)
+static int ehci_zynq_drv_remove(struct platform_device *pdev)
 {
 	struct usb_hcd *hcd = platform_get_drvdata(pdev);
 
 	/* FIXME we only want one one remove() not two */
-	usb_hcd_xusbps_remove(hcd, pdev);
+	usb_hcd_zynq_remove(hcd, pdev);
 	return 0;
 }
 
-MODULE_ALIAS("platform:xusbps-ehci");
+MODULE_ALIAS("platform:zynq-ehci");
 
-static struct platform_driver ehci_xusbps_driver = {
-	.probe = ehci_xusbps_drv_probe,
-	.remove = ehci_xusbps_drv_remove,
+static struct platform_driver ehci_zynq_driver = {
+	.probe = ehci_zynq_drv_probe,
+	.remove = ehci_zynq_drv_remove,
 	.shutdown = usb_hcd_platform_shutdown,
 	.driver = {
-		.name = "xusbps-ehci",
-		.pm = EHCI_XUSBPS_PM_OPS,
+		.name = "zynq-ehci",
+		.pm = EHCI_ZYNQ_PM_OPS,
 	},
 };
diff --git a/drivers/usb/host/ehci-zynq.h b/drivers/usb/host/ehci-zynq.h
index 609c5b9..42e6c81 100644
--- a/drivers/usb/host/ehci-zynq.h
+++ b/drivers/usb/host/ehci-zynq.h
@@ -20,14 +20,14 @@
 
 #include <linux/usb/zynq_otg.h>
 
-/* offsets for the non-ehci registers in the XUSBPS SOC USB controller */
-#define XUSBPS_SOC_USB_ULPIVP	0x170
-#define XUSBPS_SOC_USB_PORTSC1	0x184
+/* offsets for the non-ehci registers in the ZYNQ SOC USB controller */
+#define ZYNQ_SOC_USB_ULPIVP	0x170
+#define ZYNQ_SOC_USB_PORTSC1	0x184
 #define PORT_PTS_MSK		(3<<30)
 #define PORT_PTS_UTMI		(0<<30)
 #define PORT_PTS_ULPI		(2<<30)
 #define	PORT_PTS_SERIAL		(3<<30)
 #define PORT_PTS_PTW		(1<<28)
-#define XUSBPS_SOC_USB_PORTSC2	0x188
+#define ZYNQ_SOC_USB_PORTSC2	0x188
 
 #endif /* _EHCI_ZYNQ_H */
diff --git a/drivers/usb/host/zynq-dr-of.c b/drivers/usb/host/zynq-dr-of.c
index a4d9812..814f663 100644
--- a/drivers/usb/host/zynq-dr-of.c
+++ b/drivers/usb/host/zynq-dr-of.c
@@ -31,35 +31,35 @@
 
 static u64 dma_mask = 0xFFFFFFF0;
 
-struct xusbps_dev_data {
+struct zynq_dev_data {
 	char *dr_mode;		/* controller mode */
 	char *drivers[3];	/* drivers to instantiate for this mode */
-	enum xusbps_usb2_operating_modes op_mode;	/* operating mode */
+	enum zynq_usb2_operating_modes op_mode;	/* operating mode */
 };
 
-struct xusbps_host_data {
+struct zynq_host_data {
 	struct clk *clk;
 };
 
-static struct xusbps_dev_data dr_mode_data[] = {
+static struct zynq_dev_data dr_mode_data[] = {
 	{
 		.dr_mode = "host",
-		.drivers = { "xusbps-ehci", NULL, NULL, },
-		.op_mode = XUSBPS_USB2_DR_HOST,
+		.drivers = { "zynq-ehci", NULL, NULL, },
+		.op_mode = ZYNQ_USB2_DR_HOST,
 	},
 	{
 		.dr_mode = "otg",
-		.drivers = { "xusbps-otg", "xusbps-ehci", "xusbps-udc", },
-		.op_mode = XUSBPS_USB2_DR_OTG,
+		.drivers = { "zynq-otg", "zynq-ehci", "zynq-udc", },
+		.op_mode = ZYNQ_USB2_DR_OTG,
 	},
 	{
 		.dr_mode = "peripheral",
-		.drivers = { "xusbps-udc", NULL, NULL, },
-		.op_mode = XUSBPS_USB2_DR_DEVICE,
+		.drivers = { "zynq-udc", NULL, NULL, },
+		.op_mode = ZYNQ_USB2_DR_DEVICE,
 	},
 };
 
-static struct xusbps_dev_data *get_dr_mode_data(
+static struct zynq_dev_data *get_dr_mode_data(
 		struct device_node *np)
 {
 	const unsigned char *prop;
@@ -77,31 +77,31 @@ static struct xusbps_dev_data *get_dr_mode_data(
 	return &dr_mode_data[0]; /* mode not specified, use host */
 }
 
-static enum xusbps_usb2_phy_modes determine_usb_phy(const char *phy_type)
+static enum zynq_usb2_phy_modes determine_usb_phy(const char *phy_type)
 {
 	if (!phy_type)
-		return XUSBPS_USB2_PHY_NONE;
+		return ZYNQ_USB2_PHY_NONE;
 	if (!strcasecmp(phy_type, "ulpi"))
-		return XUSBPS_USB2_PHY_ULPI;
+		return ZYNQ_USB2_PHY_ULPI;
 	if (!strcasecmp(phy_type, "utmi"))
-		return XUSBPS_USB2_PHY_UTMI;
+		return ZYNQ_USB2_PHY_UTMI;
 	if (!strcasecmp(phy_type, "utmi_wide"))
-		return XUSBPS_USB2_PHY_UTMI_WIDE;
+		return ZYNQ_USB2_PHY_UTMI_WIDE;
 	if (!strcasecmp(phy_type, "serial"))
-		return XUSBPS_USB2_PHY_SERIAL;
+		return ZYNQ_USB2_PHY_SERIAL;
 
-	return XUSBPS_USB2_PHY_NONE;
+	return ZYNQ_USB2_PHY_NONE;
 }
 
-static struct platform_device *xusbps_device_register(
+static struct platform_device *zynq_device_register(
 					struct platform_device *ofdev,
-					struct xusbps_usb2_platform_data *pdata,
+					struct zynq_usb2_platform_data *pdata,
 					const char *name, int id)
 {
 	struct platform_device *pdev;
 	const struct resource *res = ofdev->resource;
 	unsigned int num = ofdev->num_resources;
-	struct xusbps_usb2_platform_data *pdata1;
+	struct zynq_usb2_platform_data *pdata1;
 	int retval;
 
 	pdev = platform_device_alloc(name, id);
@@ -141,13 +141,13 @@ error:
 	return ERR_PTR(retval);
 }
 
-static int xusbps_dr_of_probe(struct platform_device *ofdev)
+static int zynq_dr_of_probe(struct platform_device *ofdev)
 {
 	struct device_node *np = ofdev->dev.of_node;
 	struct platform_device *usb_dev;
-	struct xusbps_usb2_platform_data data, *pdata;
-	struct xusbps_dev_data *dev_data;
-	struct xusbps_host_data *hdata;
+	struct zynq_usb2_platform_data data, *pdata;
+	struct zynq_dev_data *dev_data;
+	struct zynq_host_data *hdata;
 	const unsigned char *prop;
 	static unsigned int idx;
 	struct resource *res;
@@ -198,12 +198,12 @@ static int xusbps_dr_of_probe(struct platform_device *ofdev)
 	pdata->clk = hdata->clk;
 
 	/* If ULPI phy type, set it up */
-	if (pdata->phy_mode == XUSBPS_USB2_PHY_ULPI) {
+	if (pdata->phy_mode == ZYNQ_USB2_PHY_ULPI) {
 		pdata->ulpi = otg_ulpi_create(&ulpi_viewport_access_ops,
 			ULPI_OTG_DRVVBUS | ULPI_OTG_DRVVBUS_EXT);
 		if (pdata->ulpi) {
 			pdata->ulpi->io_priv = pdata->regs +
-							XUSBPS_SOC_USB_ULPIVP;
+							ZYNQ_SOC_USB_ULPIVP;
 
 			phy_init = usb_phy_init(pdata->ulpi);
 			if (phy_init) {
@@ -221,7 +221,7 @@ static int xusbps_dr_of_probe(struct platform_device *ofdev)
 	for (i = 0; i < ARRAY_SIZE(dev_data->drivers); i++) {
 		if (!dev_data->drivers[i])
 			continue;
-		usb_dev = xusbps_device_register(ofdev, pdata,
+		usb_dev = zynq_device_register(ofdev, pdata,
 					dev_data->drivers[i], idx);
 		if (IS_ERR(usb_dev)) {
 			dev_err(&ofdev->dev, "Can't register usb device\n");
@@ -244,9 +244,9 @@ static int __unregister_subdev(struct device *dev, void *d)
 	return 0;
 }
 
-static int xusbps_dr_of_remove(struct platform_device *ofdev)
+static int zynq_dr_of_remove(struct platform_device *ofdev)
 {
-	struct xusbps_host_data *hdata = platform_get_drvdata(ofdev);
+	struct zynq_host_data *hdata = platform_get_drvdata(ofdev);
 
 	device_for_each_child(&ofdev->dev, NULL, __unregister_subdev);
 	clk_disable_unprepare(hdata->clk);
@@ -254,18 +254,18 @@ static int xusbps_dr_of_remove(struct platform_device *ofdev)
 }
 
 #ifdef CONFIG_PM_SLEEP
-static int xusbps_dr_of_suspend(struct device *dev)
+static int zynq_dr_of_suspend(struct device *dev)
 {
-	struct xusbps_host_data *hdata = dev_get_drvdata(dev);
+	struct zynq_host_data *hdata = dev_get_drvdata(dev);
 
 	clk_disable(hdata->clk);
 
 	return 0;
 }
 
-static int xusbps_dr_of_resume(struct device *dev)
+static int zynq_dr_of_resume(struct device *dev)
 {
-	struct xusbps_host_data *hdata = dev_get_drvdata(dev);
+	struct zynq_host_data *hdata = dev_get_drvdata(dev);
 	int ret;
 
 	ret = clk_enable(hdata->clk);
@@ -278,51 +278,51 @@ static int xusbps_dr_of_resume(struct device *dev)
 }
 #endif /* CONFIG_PM_SLEEP */
 
-static SIMPLE_DEV_PM_OPS(xusbps_pm_ops, xusbps_dr_of_suspend,
-		xusbps_dr_of_resume);
+static SIMPLE_DEV_PM_OPS(zynq_pm_ops, zynq_dr_of_suspend,
+		zynq_dr_of_resume);
 
-static const struct of_device_id xusbps_dr_of_match[] = {
+static const struct of_device_id zynq_dr_of_match[] = {
 	{ .compatible = "xlnx,ps7-usb-1.00.a" },
 	{},
 };
-MODULE_DEVICE_TABLE(of, xusbps_dr_of_match);
+MODULE_DEVICE_TABLE(of, zynq_dr_of_match);
 
-static struct platform_driver xusbps_dr_driver = {
+static struct platform_driver zynq_dr_driver = {
 	.driver = {
-		.name = "xusbps-dr",
+		.name = "zynq-dr",
 		.owner = THIS_MODULE,
-		.of_match_table = xusbps_dr_of_match,
-		.pm = &xusbps_pm_ops,
+		.of_match_table = zynq_dr_of_match,
+		.pm = &zynq_pm_ops,
 	},
-	.probe	= xusbps_dr_of_probe,
-	.remove	= xusbps_dr_of_remove,
+	.probe	= zynq_dr_of_probe,
+	.remove	= zynq_dr_of_remove,
 };
 
 #ifdef CONFIG_USB_ZYNQ_PHY
-extern struct platform_driver xusbps_otg_driver;
+extern struct platform_driver zynq_otg_driver;
 
-static int __init xusbps_dr_init(void)
+static int __init zynq_dr_init(void)
 {
 	int retval;
 
 	/* Register otg driver first */
-	retval = platform_driver_register(&xusbps_otg_driver);
+	retval = platform_driver_register(&zynq_otg_driver);
 	if (retval != 0)
 		return retval;
 
-	return platform_driver_register(&xusbps_dr_driver);
+	return platform_driver_register(&zynq_dr_driver);
 }
-module_init(xusbps_dr_init);
+module_init(zynq_dr_init);
 
-static void __exit xusbps_dr_exit(void)
+static void __exit zynq_dr_exit(void)
 {
-	platform_driver_unregister(&xusbps_dr_driver);
+	platform_driver_unregister(&zynq_dr_driver);
 }
-module_exit(xusbps_dr_exit);
+module_exit(zynq_dr_exit);
 #else
-module_platform_driver(xusbps_dr_driver);
+module_platform_driver(zynq_dr_driver);
 #endif
 
-MODULE_DESCRIPTION("XUSBPS DR OF devices driver");
+MODULE_DESCRIPTION("ZYNQ DR OF devices driver");
 MODULE_AUTHOR("Xilinx");
 MODULE_LICENSE("GPL");
diff --git a/drivers/usb/phy/phy-zynq-usb.c b/drivers/usb/phy/phy-zynq-usb.c
index e1fa625..1f9a1f4 100644
--- a/drivers/usb/phy/phy-zynq-usb.c
+++ b/drivers/usb/phy/phy-zynq-usb.c
@@ -39,16 +39,16 @@
 #include <linux/xilinx_devices.h>
 #include <linux/usb/zynq_otg.h>
 
-#define	DRIVER_NAME	"xusbps-otg"
+#define	DRIVER_NAME	"zynq-otg"
 
 static const char driver_name[] = DRIVER_NAME;
 
 /* HSM timers */
-static inline struct xusbps_otg_timer *otg_timer_initializer
+static inline struct zynq_otg_timer *otg_timer_initializer
 (void (*function)(unsigned long), unsigned long expires, unsigned long data)
 {
-	struct xusbps_otg_timer *timer;
-	timer = kmalloc(sizeof(struct xusbps_otg_timer), GFP_KERNEL);
+	struct zynq_otg_timer *timer;
+	timer = kmalloc(sizeof(struct zynq_otg_timer), GFP_KERNEL);
 	if (timer == NULL)
 		return timer;
 
@@ -58,17 +58,17 @@ static inline struct xusbps_otg_timer *otg_timer_initializer
 	return timer;
 }
 
-static struct xusbps_otg_timer *a_wait_vrise_tmr, *a_aidl_bdis_tmr,
+static struct zynq_otg_timer *a_wait_vrise_tmr, *a_aidl_bdis_tmr,
 	*b_se0_srp_tmr, *b_srp_init_tmr;
 
 static struct list_head active_timers;
 
-static struct xusbps_otg *the_transceiver;
+static struct zynq_otg *the_transceiver;
 
 /* host/client notify transceiver when event affects HNP state */
-void xusbps_update_transceiver(void)
+void zynq_update_transceiver(void)
 {
-	struct xusbps_otg *xotg = the_transceiver;
+	struct zynq_otg *xotg = the_transceiver;
 
 	dev_dbg(xotg->dev, "transceiver is updated\n");
 
@@ -77,9 +77,9 @@ void xusbps_update_transceiver(void)
 
 	queue_work(xotg->qwork, &xotg->work);
 }
-EXPORT_SYMBOL(xusbps_update_transceiver);
+EXPORT_SYMBOL(zynq_update_transceiver);
 
-static int xusbps_otg_set_host(struct usb_otg *otg,
+static int zynq_otg_set_host(struct usb_otg *otg,
 					struct usb_bus *host)
 {
 	otg->host = host;
@@ -94,7 +94,7 @@ static int xusbps_otg_set_host(struct usb_otg *otg,
 	return 0;
 }
 
-static int xusbps_otg_set_peripheral(struct usb_otg *otg,
+static int zynq_otg_set_peripheral(struct usb_otg *otg,
 					struct usb_gadget *gadget)
 {
 	otg->gadget = gadget;
@@ -109,16 +109,16 @@ static int xusbps_otg_set_peripheral(struct usb_otg *otg,
 	return 0;
 }
 
-static int xusbps_otg_set_power(struct usb_phy *otg,
+static int zynq_otg_set_power(struct usb_phy *otg,
 				unsigned mA)
 {
 	return 0;
 }
 
 /* A-device drives vbus, controlled through PMIC CHRGCNTL register*/
-static int xusbps_otg_set_vbus(struct usb_otg *otg, bool enabled)
+static int zynq_otg_set_vbus(struct usb_otg *otg, bool enabled)
 {
-	struct xusbps_otg		*xotg = the_transceiver;
+	struct zynq_otg		*xotg = the_transceiver;
 	u32 val;
 
 	dev_dbg(xotg->dev, "%s <--- %s\n", __func__, enabled ? "on" : "off");
@@ -140,9 +140,9 @@ static int xusbps_otg_set_vbus(struct usb_otg *otg, bool enabled)
 }
 
 /* Charge vbus for VBUS pulsing in SRP */
-static void xusbps_otg_chrg_vbus(int on)
+static void zynq_otg_chrg_vbus(int on)
 {
-	struct xusbps_otg	*xotg = the_transceiver;
+	struct zynq_otg	*xotg = the_transceiver;
 	u32	val;
 
 	val = readl(xotg->base + CI_OTGSC) & ~OTGSC_INTSTS_MASK;
@@ -160,9 +160,9 @@ static void xusbps_otg_chrg_vbus(int on)
 #if 0
 
 /* Discharge vbus through a resistor to ground */
-static void xusbps_otg_dischrg_vbus(int on)
+static void zynq_otg_dischrg_vbus(int on)
 {
-	struct xusbps_otg	*xotg = the_transceiver;
+	struct zynq_otg	*xotg = the_transceiver;
 	u32	val;
 
 	val = readl(xotg->base + CI_OTGSC) & ~OTGSC_INTSTS_MASK;
@@ -179,9 +179,9 @@ static void xusbps_otg_dischrg_vbus(int on)
 #endif
 
 /* Start SRP */
-static int xusbps_otg_start_srp(struct usb_otg *otg)
+static int zynq_otg_start_srp(struct usb_otg *otg)
 {
-	struct xusbps_otg		*xotg = the_transceiver;
+	struct zynq_otg		*xotg = the_transceiver;
 	u32				val;
 
 	dev_warn(xotg->dev, "Starting SRP...\n");
@@ -203,7 +203,7 @@ static int xusbps_otg_start_srp(struct usb_otg *otg)
 		dev_dbg(xotg->dev, "no b_sess_vld interrupt\n");
 
 		xotg->hsm.b_sess_vld = 1;
-		xusbps_update_transceiver();
+		zynq_update_transceiver();
 		return 0;
 	}
 
@@ -215,9 +215,9 @@ static int xusbps_otg_start_srp(struct usb_otg *otg)
 	writel(val, xotg->base + CI_OTGSC);
 
 	/* Start VBus SRP, drive vbus to generate VBus pulse */
-	xusbps_otg_chrg_vbus(1);
+	zynq_otg_chrg_vbus(1);
 	msleep(15);
-	xusbps_otg_chrg_vbus(0);
+	zynq_otg_chrg_vbus(0);
 
 	/* Enable interrupt - b_sess_vld*/
 	val = readl(xotg->base + CI_OTGSC);
@@ -231,7 +231,7 @@ static int xusbps_otg_start_srp(struct usb_otg *otg)
 		dev_dbg(xotg->dev, "no b_sess_vld interrupt\n");
 
 		xotg->hsm.b_sess_vld = 1;
-		xusbps_update_transceiver();
+		zynq_update_transceiver();
 	}
 
 	dev_dbg(xotg->dev, "%s <---\n", __func__);
@@ -239,9 +239,9 @@ static int xusbps_otg_start_srp(struct usb_otg *otg)
 }
 
 /* Start HNP */
-static int xusbps_otg_start_hnp(struct usb_otg *otg)
+static int zynq_otg_start_hnp(struct usb_otg *otg)
 {
-	struct xusbps_otg	*xotg = the_transceiver;
+	struct zynq_otg	*xotg = the_transceiver;
 	unsigned long flag = 0;
 
 	dev_warn(xotg->dev, "Starting HNP...\n");
@@ -261,7 +261,7 @@ static int xusbps_otg_start_hnp(struct usb_otg *otg)
 
 	if (flag) {
 		if (spin_trylock(&xotg->wq_lock)) {
-			xusbps_update_transceiver();
+			zynq_update_transceiver();
 			spin_unlock(&xotg->wq_lock);
 		}
 	} else
@@ -272,32 +272,32 @@ static int xusbps_otg_start_hnp(struct usb_otg *otg)
 }
 
 /* stop SOF via bus_suspend */
-static void xusbps_otg_loc_sof(int on)
+static void zynq_otg_loc_sof(int on)
 {
 	/* Not used */
 }
 
-static void xusbps_otg_phy_low_power(int on)
+static void zynq_otg_phy_low_power(int on)
 {
 	/* Not used */
 }
 
 /* After drv vbus, add 2 ms delay to set PHCD */
-static void xusbps_otg_phy_low_power_wait(int on)
+static void zynq_otg_phy_low_power_wait(int on)
 {
-	struct xusbps_otg	*xotg = the_transceiver;
+	struct zynq_otg	*xotg = the_transceiver;
 
 	dev_dbg(xotg->dev, "add 2ms delay before programing PHCD\n");
 
 	mdelay(2);
-	xusbps_otg_phy_low_power(on);
+	zynq_otg_phy_low_power(on);
 }
 
 #ifdef CONFIG_PM_SLEEP
 /* Enable/Disable OTG interrupt */
-static void xusbps_otg_intr(int on)
+static void zynq_otg_intr(int on)
 {
-	struct xusbps_otg		*xotg = the_transceiver;
+	struct zynq_otg		*xotg = the_transceiver;
 	u32				val;
 
 	dev_dbg(xotg->dev, "%s ---> %s\n", __func__, on ? "on" : "off");
@@ -318,15 +318,15 @@ static void xusbps_otg_intr(int on)
 #endif
 
 /* set HAAR: Hardware Assist Auto-Reset */
-static void xusbps_otg_HAAR(int on)
+static void zynq_otg_HAAR(int on)
 {
 	/* Not used */
 }
 
 /* set HABA: Hardware Assist B-Disconnect to A-Connect */
-static void xusbps_otg_HABA(int on)
+static void zynq_otg_HABA(int on)
 {
-	struct xusbps_otg		*xotg = the_transceiver;
+	struct zynq_otg		*xotg = the_transceiver;
 	u32				val;
 
 	dev_dbg(xotg->dev, "%s ---> %s\n", __func__, on ? "on" : "off");
@@ -342,9 +342,9 @@ static void xusbps_otg_HABA(int on)
 	dev_dbg(xotg->dev, "%s <---\n", __func__);
 }
 
-static int xusbps_otg_check_se0_srp(int on)
+static int zynq_otg_check_se0_srp(int on)
 {
-	struct xusbps_otg	*xotg = the_transceiver;
+	struct zynq_otg	*xotg = the_transceiver;
 	int			delay_time = TB_SE0_SRP * 10;
 	u32			val;
 
@@ -368,9 +368,9 @@ static void set_tmout(unsigned long indicator)
 	*(int *)indicator = 1;
 }
 
-static void xusbps_otg_msg(unsigned long indicator)
+static void zynq_otg_msg(unsigned long indicator)
 {
-	struct xusbps_otg	*xotg = the_transceiver;
+	struct zynq_otg	*xotg = the_transceiver;
 
 	switch (indicator) {
 	case 2:
@@ -391,7 +391,7 @@ static void xusbps_otg_msg(unsigned long indicator)
 }
 
 /* Initialize timers */
-static int xusbps_otg_init_timers(struct otg_hsm *hsm)
+static int zynq_otg_init_timers(struct otg_hsm *hsm)
 {
 	/* HSM used timers */
 	a_wait_vrise_tmr = otg_timer_initializer(&set_tmout, TA_WAIT_VRISE,
@@ -415,7 +415,7 @@ static int xusbps_otg_init_timers(struct otg_hsm *hsm)
 }
 
 /* Free timers */
-static void xusbps_otg_free_timers(void)
+static void zynq_otg_free_timers(void)
 {
 	kfree(a_wait_vrise_tmr);
 	kfree(a_aidl_bdis_tmr);
@@ -424,21 +424,21 @@ static void xusbps_otg_free_timers(void)
 }
 
 /* The timeout callback function to set time out bit */
-static void xusbps_otg_timer_fn(unsigned long indicator)
+static void zynq_otg_timer_fn(unsigned long indicator)
 {
-	struct xusbps_otg *xotg = the_transceiver;
+	struct zynq_otg *xotg = the_transceiver;
 
 	*(int *)indicator = 1;
 
 	dev_dbg(xotg->dev, "kernel timer - timeout\n");
 
-	xusbps_update_transceiver();
+	zynq_update_transceiver();
 }
 
 /* kernel timer used instead of HW based interrupt */
-static void xusbps_otg_add_ktimer(enum xusbps_otg_timer_type timers)
+static void zynq_otg_add_ktimer(enum zynq_otg_timer_type timers)
 {
-	struct xusbps_otg		*xotg = the_transceiver;
+	struct zynq_otg		*xotg = the_transceiver;
 	unsigned long		j = jiffies;
 	unsigned long		data, time;
 
@@ -484,7 +484,7 @@ static void xusbps_otg_add_ktimer(enum xusbps_otg_timer_type timers)
 	}
 
 	xotg->hsm_timer.data = data;
-	xotg->hsm_timer.function = xusbps_otg_timer_fn;
+	xotg->hsm_timer.function = zynq_otg_timer_fn;
 	xotg->hsm_timer.expires = j + time * HZ / 1000; /* milliseconds */
 
 	add_timer(&xotg->hsm_timer);
@@ -493,11 +493,11 @@ static void xusbps_otg_add_ktimer(enum xusbps_otg_timer_type timers)
 }
 
 /* Add timer to timer list */
-static void xusbps_otg_add_timer(void *gtimer)
+static void zynq_otg_add_timer(void *gtimer)
 {
-	struct xusbps_otg *xotg = the_transceiver;
-	struct xusbps_otg_timer *timer = (struct xusbps_otg_timer *)gtimer;
-	struct xusbps_otg_timer *tmp_timer;
+	struct zynq_otg *xotg = the_transceiver;
+	struct zynq_otg_timer *timer = (struct zynq_otg_timer *)gtimer;
+	struct zynq_otg_timer *tmp_timer;
 	u32	val32;
 
 	/* Check if the timer is already in the active list,
@@ -519,11 +519,11 @@ static void xusbps_otg_add_timer(void *gtimer)
 }
 
 /* Remove timer from the timer list; clear timeout status */
-static void xusbps_otg_del_timer(void *gtimer)
+static void zynq_otg_del_timer(void *gtimer)
 {
-	struct xusbps_otg *xotg = the_transceiver;
-	struct xusbps_otg_timer *timer = (struct xusbps_otg_timer *)gtimer;
-	struct xusbps_otg_timer *tmp_timer, *del_tmp;
+	struct zynq_otg *xotg = the_transceiver;
+	struct zynq_otg_timer *timer = (struct zynq_otg_timer *)gtimer;
+	struct zynq_otg_timer *tmp_timer, *del_tmp;
 	u32 val32;
 
 	list_for_each_entry_safe(tmp_timer, del_tmp, &active_timers, list)
@@ -537,10 +537,10 @@ static void xusbps_otg_del_timer(void *gtimer)
 }
 
 /* Reduce timer count by 1, and find timeout conditions.*/
-static int xusbps_otg_tick_timer(u32 *int_sts)
+static int zynq_otg_tick_timer(u32 *int_sts)
 {
-	struct xusbps_otg	*xotg = the_transceiver;
-	struct xusbps_otg_timer *tmp_timer, *del_tmp;
+	struct zynq_otg	*xotg = the_transceiver;
+	struct zynq_otg_timer *tmp_timer, *del_tmp;
 	int expired = 0;
 
 	list_for_each_entry_safe(tmp_timer, del_tmp, &active_timers, list) {
@@ -562,7 +562,7 @@ static int xusbps_otg_tick_timer(u32 *int_sts)
 
 static void reset_otg(void)
 {
-	struct xusbps_otg	*xotg = the_transceiver;
+	struct zynq_otg	*xotg = the_transceiver;
 	int			delay_time = 1000;
 	u32			val;
 
@@ -581,7 +581,7 @@ static void reset_otg(void)
 
 static void set_host_mode(void)
 {
-	struct xusbps_otg	*xotg = the_transceiver;
+	struct zynq_otg	*xotg = the_transceiver;
 	u32			val;
 
 	reset_otg();
@@ -592,7 +592,7 @@ static void set_host_mode(void)
 
 static void set_client_mode(void)
 {
-	struct xusbps_otg	*xotg = the_transceiver;
+	struct zynq_otg	*xotg = the_transceiver;
 	u32			val;
 
 	reset_otg();
@@ -603,7 +603,7 @@ static void set_client_mode(void)
 
 static void init_hsm(void)
 {
-	struct xusbps_otg		*xotg = the_transceiver;
+	struct zynq_otg		*xotg = the_transceiver;
 	u32				val32;
 
 	/* read OTGSC after reset */
@@ -643,13 +643,13 @@ static void init_hsm(void)
 	/* no system error */
 	xotg->hsm.a_clr_err = 0;
 
-	xusbps_otg_phy_low_power_wait(1);
+	zynq_otg_phy_low_power_wait(1);
 }
 
 #ifdef CONFIG_PM_SLEEP
 static void update_hsm(void)
 {
-	struct xusbps_otg		*xotg = the_transceiver;
+	struct zynq_otg		*xotg = the_transceiver;
 	u32				val32;
 
 	/* read OTGSC */
@@ -668,7 +668,7 @@ static void update_hsm(void)
 
 static irqreturn_t otg_dummy_irq(int irq, void *_dev)
 {
-	struct xusbps_otg	*xotg = the_transceiver;
+	struct zynq_otg	*xotg = the_transceiver;
 	void __iomem		*reg_base = _dev;
 	u32			val;
 	u32			int_mask = 0;
@@ -692,7 +692,7 @@ static irqreturn_t otg_dummy_irq(int irq, void *_dev)
 	if (xotg->hsm.b_conn) {
 		xotg->hsm.b_conn = 0;
 		if (spin_trylock(&xotg->wq_lock)) {
-			xusbps_update_transceiver();
+			zynq_update_transceiver();
 			spin_unlock(&xotg->wq_lock);
 		}
 	}
@@ -702,7 +702,7 @@ static irqreturn_t otg_dummy_irq(int irq, void *_dev)
 
 static irqreturn_t otg_irq(int irq, void *_dev)
 {
-	struct xusbps_otg		*xotg = _dev;
+	struct zynq_otg		*xotg = _dev;
 	u32				int_sts, int_en;
 	u32				int_mask = 0;
 	int				flag = 0;
@@ -764,12 +764,12 @@ static irqreturn_t otg_irq(int irq, void *_dev)
 
 	if (int_mask & OTGSC_1MSS) {
 		/* need to schedule otg_work if any timer is expired */
-		if (xusbps_otg_tick_timer(&int_sts))
+		if (zynq_otg_tick_timer(&int_sts))
 			flag = 1;
 	}
 
 	if (flag)
-		xusbps_update_transceiver();
+		zynq_update_transceiver();
 
 	spin_unlock_irqrestore(&xotg->lock, flags);
 	return IRQ_HANDLED;
@@ -789,7 +789,7 @@ static irqreturn_t otg_irq(int irq, void *_dev)
 static int xotg_usbdev_notify(struct notifier_block *self,
 			       unsigned long action, void *dev)
 {
-	struct xusbps_otg	*xotg = the_transceiver;
+	struct zynq_otg	*xotg = the_transceiver;
 	struct usb_phy *otg = &xotg->otg;
 	unsigned long otg_port;
 	struct usb_device *udev_otg = NULL;
@@ -828,17 +828,17 @@ static int xotg_usbdev_notify(struct notifier_block *self,
 		break;
 	}
 	if (flag)
-		xusbps_update_transceiver();
+		zynq_update_transceiver();
 
 	return NOTIFY_OK;
 }
 
-static void xusbps_otg_work(struct work_struct *work)
+static void zynq_otg_work(struct work_struct *work)
 {
-	struct xusbps_otg		*xotg;
+	struct zynq_otg		*xotg;
 	int				retval;
 
-	xotg = container_of(work, struct xusbps_otg, work);
+	xotg = container_of(work, struct zynq_otg, work);
 
 	dev_dbg(xotg->dev, "%s: old state = %s\n", __func__,
 		usb_otg_state_string(xotg->otg.state));
@@ -847,25 +847,25 @@ static void xusbps_otg_work(struct work_struct *work)
 	case OTG_STATE_UNDEFINED:
 	case OTG_STATE_B_IDLE:
 		if (!xotg->hsm.id) {
-			xusbps_otg_del_timer(b_srp_init_tmr);
+			zynq_otg_del_timer(b_srp_init_tmr);
 			del_timer_sync(&xotg->hsm_timer);
 
 			xotg->otg.otg->default_a = 1;
 			xotg->hsm.a_srp_det = 0;
 
-			xusbps_otg_chrg_vbus(0);
+			zynq_otg_chrg_vbus(0);
 			set_host_mode();
-			xusbps_otg_phy_low_power(1);
+			zynq_otg_phy_low_power(1);
 
 			xotg->otg.state = OTG_STATE_A_IDLE;
-			xusbps_update_transceiver();
+			zynq_update_transceiver();
 		} else if (xotg->hsm.b_sess_vld) {
-			xusbps_otg_del_timer(b_srp_init_tmr);
+			zynq_otg_del_timer(b_srp_init_tmr);
 			del_timer_sync(&xotg->hsm_timer);
 			xotg->hsm.b_bus_req = 0;
 			xotg->hsm.b_sess_end = 0;
 			xotg->hsm.a_bus_suspend = 0;
-			xusbps_otg_chrg_vbus(0);
+			zynq_otg_chrg_vbus(0);
 
 			if (xotg->start_peripheral) {
 				xotg->start_peripheral(&xotg->otg);
@@ -881,27 +881,27 @@ static void xusbps_otg_work(struct work_struct *work)
 			xotg->hsm.b_bus_req = 0;
 
 			/* No silence failure */
-			xusbps_otg_msg(6);
+			zynq_otg_msg(6);
 			dev_warn(xotg->dev, "SRP failed\n");
 		} else if (xotg->hsm.b_bus_req && xotg->hsm.b_sess_end) {
 			del_timer_sync(&xotg->hsm_timer);
 			/* workaround for b_se0_srp detection */
-			retval = xusbps_otg_check_se0_srp(0);
+			retval = zynq_otg_check_se0_srp(0);
 			if (retval) {
 				xotg->hsm.b_bus_req = 0;
 				dev_dbg(xotg->dev, "LS isn't SE0, try later\n");
 			} else {
 				/* clear the PHCD before start srp */
-				xusbps_otg_phy_low_power(0);
+				zynq_otg_phy_low_power(0);
 
 				/* Start SRP */
-				xusbps_otg_add_timer(b_srp_init_tmr);
+				zynq_otg_add_timer(b_srp_init_tmr);
 				xotg->otg.otg->start_srp(xotg->otg.otg);
-				xusbps_otg_del_timer(b_srp_init_tmr);
-				xusbps_otg_add_ktimer(TB_SRP_FAIL_TMR);
+				zynq_otg_del_timer(b_srp_init_tmr);
+				zynq_otg_add_ktimer(TB_SRP_FAIL_TMR);
 
 				/* reset PHY low power mode here */
-				xusbps_otg_phy_low_power_wait(1);
+				zynq_otg_phy_low_power_wait(1);
 			}
 		}
 		break;
@@ -912,13 +912,13 @@ static void xusbps_otg_work(struct work_struct *work)
 
 			/* Turn off VBus */
 			xotg->otg.otg->set_vbus(xotg->otg.otg, false);
-			xusbps_otg_chrg_vbus(0);
+			zynq_otg_chrg_vbus(0);
 			set_host_mode();
-			xusbps_otg_phy_low_power(1);
+			zynq_otg_phy_low_power(1);
 			xotg->otg.state = OTG_STATE_A_IDLE;
-			xusbps_update_transceiver();
+			zynq_update_transceiver();
 		} else if (xotg->hsm.b_sess_vld) {
-			xusbps_otg_chrg_vbus(0);
+			zynq_otg_chrg_vbus(0);
 			if (xotg->start_peripheral) {
 				xotg->start_peripheral(&xotg->otg);
 				xotg->otg.state = OTG_STATE_B_PERIPHERAL;
@@ -932,7 +932,7 @@ static void xusbps_otg_work(struct work_struct *work)
 			xotg->otg.otg->default_a = 1;
 			xotg->hsm.a_srp_det = 0;
 
-			xusbps_otg_chrg_vbus(0);
+			zynq_otg_chrg_vbus(0);
 
 			if (xotg->stop_peripheral)
 				xotg->stop_peripheral(&xotg->otg);
@@ -941,9 +941,9 @@ static void xusbps_otg_work(struct work_struct *work)
 					"client driver has been removed.\n");
 
 			set_host_mode();
-			xusbps_otg_phy_low_power(1);
+			zynq_otg_phy_low_power(1);
 			xotg->otg.state = OTG_STATE_A_IDLE;
-			xusbps_update_transceiver();
+			zynq_update_transceiver();
 		} else if (!xotg->hsm.b_sess_vld) {
 			xotg->hsm.b_hnp_enable = 0;
 			xotg->hsm.b_bus_req = 0;
@@ -966,7 +966,7 @@ static void xusbps_otg_work(struct work_struct *work)
 				dev_dbg(xotg->dev,
 					"client driver has been removed.\n");
 
-			xusbps_otg_HAAR(1);
+			zynq_otg_HAAR(1);
 			xotg->hsm.a_conn = 0;
 
 			xotg->otg.state = OTG_STATE_B_WAIT_ACON;
@@ -977,7 +977,7 @@ static void xusbps_otg_work(struct work_struct *work)
 						"host driver not loaded.\n");
 
 			xotg->hsm.a_bus_resume = 0;
-			xusbps_otg_add_ktimer(TB_ASE0_BRST_TMR);
+			zynq_otg_add_ktimer(TB_ASE0_BRST_TMR);
 		}
 		break;
 
@@ -989,9 +989,9 @@ static void xusbps_otg_work(struct work_struct *work)
 			xotg->otg.otg->default_a = 1;
 			xotg->hsm.a_srp_det = 0;
 
-			xusbps_otg_chrg_vbus(0);
+			zynq_otg_chrg_vbus(0);
 
-			xusbps_otg_HAAR(0);
+			zynq_otg_HAAR(0);
 			if (xotg->stop_host)
 				xotg->stop_host(&xotg->otg);
 			else
@@ -999,9 +999,9 @@ static void xusbps_otg_work(struct work_struct *work)
 					"host driver has been removed.\n");
 
 			set_host_mode();
-			xusbps_otg_phy_low_power(1);
+			zynq_otg_phy_low_power(1);
 			xotg->otg.state = OTG_STATE_A_IDLE;
-			xusbps_update_transceiver();
+			zynq_update_transceiver();
 		} else if (!xotg->hsm.b_sess_vld) {
 			/* delete hsm timer for b_ase0_brst_tmr */
 			del_timer_sync(&xotg->hsm_timer);
@@ -1009,8 +1009,8 @@ static void xusbps_otg_work(struct work_struct *work)
 			xotg->hsm.b_hnp_enable = 0;
 			xotg->hsm.b_bus_req = 0;
 
-			xusbps_otg_chrg_vbus(0);
-			xusbps_otg_HAAR(0);
+			zynq_otg_chrg_vbus(0);
+			zynq_otg_HAAR(0);
 
 			if (xotg->stop_host)
 				xotg->stop_host(&xotg->otg);
@@ -1019,23 +1019,23 @@ static void xusbps_otg_work(struct work_struct *work)
 					"host driver has been removed.\n");
 
 			set_client_mode();
-			xusbps_otg_phy_low_power(1);
+			zynq_otg_phy_low_power(1);
 			xotg->otg.state = OTG_STATE_B_IDLE;
 		} else if (xotg->hsm.a_conn) {
 			/* delete hsm timer for b_ase0_brst_tmr */
 			del_timer_sync(&xotg->hsm_timer);
 
-			xusbps_otg_HAAR(0);
+			zynq_otg_HAAR(0);
 			xotg->otg.state = OTG_STATE_B_HOST;
-			xusbps_update_transceiver();
+			zynq_update_transceiver();
 		} else if (xotg->hsm.a_bus_resume ||
 				xotg->hsm.b_ase0_brst_tmout) {
 			dev_warn(xotg->dev, "A device connect failed\n");
 			/* delete hsm timer for b_ase0_brst_tmr */
 			del_timer_sync(&xotg->hsm_timer);
 
-			xusbps_otg_HAAR(0);
-			xusbps_otg_msg(7);
+			zynq_otg_HAAR(0);
+			zynq_otg_msg(7);
 
 			if (xotg->stop_host)
 				xotg->stop_host(&xotg->otg);
@@ -1059,7 +1059,7 @@ static void xusbps_otg_work(struct work_struct *work)
 			xotg->otg.otg->default_a = 1;
 			xotg->hsm.a_srp_det = 0;
 
-			xusbps_otg_chrg_vbus(0);
+			zynq_otg_chrg_vbus(0);
 
 			if (xotg->stop_host)
 				xotg->stop_host(&xotg->otg);
@@ -1068,14 +1068,14 @@ static void xusbps_otg_work(struct work_struct *work)
 					"host driver has been removed.\n");
 
 			set_host_mode();
-			xusbps_otg_phy_low_power(1);
+			zynq_otg_phy_low_power(1);
 			xotg->otg.state = OTG_STATE_A_IDLE;
-			xusbps_update_transceiver();
+			zynq_update_transceiver();
 		} else if (!xotg->hsm.b_sess_vld) {
 			xotg->hsm.b_hnp_enable = 0;
 			xotg->hsm.b_bus_req = 0;
 
-			xusbps_otg_chrg_vbus(0);
+			zynq_otg_chrg_vbus(0);
 			if (xotg->stop_host)
 				xotg->stop_host(&xotg->otg);
 			else
@@ -1083,12 +1083,12 @@ static void xusbps_otg_work(struct work_struct *work)
 					"host driver has been removed.\n");
 
 			set_client_mode();
-			xusbps_otg_phy_low_power(1);
+			zynq_otg_phy_low_power(1);
 			xotg->otg.state = OTG_STATE_B_IDLE;
 		} else if ((!xotg->hsm.b_bus_req) ||
 				(!xotg->hsm.a_conn)) {
 			xotg->hsm.b_bus_req = 0;
-			xusbps_otg_loc_sof(0);
+			zynq_otg_loc_sof(0);
 
 			/* Fix: The kernel crash in usb_port_suspend
 				during HNP */
@@ -1117,57 +1117,57 @@ static void xusbps_otg_work(struct work_struct *work)
 			xotg->hsm.b_bus_req = 0;
 			xotg->hsm.vbus_srp_up = 0;
 
-			xusbps_otg_chrg_vbus(0);
+			zynq_otg_chrg_vbus(0);
 			set_client_mode();
-			xusbps_otg_phy_low_power(1);
+			zynq_otg_phy_low_power(1);
 			xotg->otg.state = OTG_STATE_B_IDLE;
-			xusbps_update_transceiver();
+			zynq_update_transceiver();
 		} else if (!xotg->hsm.a_bus_drop &&
 			(xotg->hsm.a_srp_det || xotg->hsm.a_bus_req)) {
 			dev_warn(xotg->dev,
 			"SRP detected or User has requested for the Bus\n");
-			xusbps_otg_phy_low_power(0);
+			zynq_otg_phy_low_power(0);
 
 			/* Turn on VBus */
 			xotg->otg.otg->set_vbus(xotg->otg.otg, true);
 
 			xotg->hsm.vbus_srp_up = 0;
 			xotg->hsm.a_wait_vrise_tmout = 0;
-			xusbps_otg_add_timer(a_wait_vrise_tmr);
+			zynq_otg_add_timer(a_wait_vrise_tmr);
 			xotg->otg.state = OTG_STATE_A_WAIT_VRISE;
-			xusbps_update_transceiver();
+			zynq_update_transceiver();
 		} else if (!xotg->hsm.a_bus_drop && xotg->hsm.a_sess_vld) {
 			xotg->hsm.vbus_srp_up = 1;
 		} else if (!xotg->hsm.a_sess_vld && xotg->hsm.vbus_srp_up) {
 			msleep(10);
-			xusbps_otg_phy_low_power(0);
+			zynq_otg_phy_low_power(0);
 
 			/* Turn on VBus */
 			xotg->otg.otg->set_vbus(xotg->otg.otg, true);
 			xotg->hsm.a_srp_det = 1;
 			xotg->hsm.vbus_srp_up = 0;
 			xotg->hsm.a_wait_vrise_tmout = 0;
-			xusbps_otg_add_timer(a_wait_vrise_tmr);
+			zynq_otg_add_timer(a_wait_vrise_tmr);
 			xotg->otg.state = OTG_STATE_A_WAIT_VRISE;
-			xusbps_update_transceiver();
+			zynq_update_transceiver();
 		} else if (!xotg->hsm.a_sess_vld &&
 				!xotg->hsm.vbus_srp_up) {
-			xusbps_otg_phy_low_power(1);
+			zynq_otg_phy_low_power(1);
 		}
 		break;
 	case OTG_STATE_A_WAIT_VRISE:
 		if (xotg->hsm.id) {
-			xusbps_otg_del_timer(a_wait_vrise_tmr);
+			zynq_otg_del_timer(a_wait_vrise_tmr);
 			xotg->hsm.b_bus_req = 0;
 			xotg->otg.otg->default_a = 0;
 
 			/* Turn off VBus */
 			xotg->otg.otg->set_vbus(xotg->otg.otg, false);
 			set_client_mode();
-			xusbps_otg_phy_low_power_wait(1);
+			zynq_otg_phy_low_power_wait(1);
 			xotg->otg.state = OTG_STATE_B_IDLE;
 		} else if (xotg->hsm.a_vbus_vld) {
-			xusbps_otg_del_timer(a_wait_vrise_tmr);
+			zynq_otg_del_timer(a_wait_vrise_tmr);
 			xotg->hsm.b_conn = 0;
 			if (xotg->start_host)
 				xotg->start_host(&xotg->otg);
@@ -1175,7 +1175,7 @@ static void xusbps_otg_work(struct work_struct *work)
 				dev_dbg(xotg->dev, "host driver not loaded.\n");
 				break;
 			}
-			xusbps_otg_add_ktimer(TA_WAIT_BCON_TMR);
+			zynq_otg_add_ktimer(TA_WAIT_BCON_TMR);
 			xotg->otg.state = OTG_STATE_A_WAIT_BCON;
 		} else if (xotg->hsm.a_wait_vrise_tmout) {
 			xotg->hsm.b_conn = 0;
@@ -1187,13 +1187,13 @@ static void xusbps_otg_work(struct work_struct *work)
 						"host driver not loaded.\n");
 					break;
 				}
-				xusbps_otg_add_ktimer(TA_WAIT_BCON_TMR);
+				zynq_otg_add_ktimer(TA_WAIT_BCON_TMR);
 				xotg->otg.state = OTG_STATE_A_WAIT_BCON;
 			} else {
 
 				/* Turn off VBus */
 				xotg->otg.otg->set_vbus(xotg->otg.otg, false);
-				xusbps_otg_phy_low_power_wait(1);
+				zynq_otg_phy_low_power_wait(1);
 				xotg->otg.state = OTG_STATE_A_VBUS_ERR;
 			}
 		}
@@ -1215,9 +1215,9 @@ static void xusbps_otg_work(struct work_struct *work)
 			/* Turn off VBus */
 			xotg->otg.otg->set_vbus(xotg->otg.otg, false);
 			set_client_mode();
-			xusbps_otg_phy_low_power_wait(1);
+			zynq_otg_phy_low_power_wait(1);
 			xotg->otg.state = OTG_STATE_B_IDLE;
-			xusbps_update_transceiver();
+			zynq_update_transceiver();
 		} else if (!xotg->hsm.a_vbus_vld) {
 			/* delete hsm timer for a_wait_bcon_tmr */
 			del_timer_sync(&xotg->hsm_timer);
@@ -1230,7 +1230,7 @@ static void xusbps_otg_work(struct work_struct *work)
 
 			/* Turn off VBus */
 			xotg->otg.otg->set_vbus(xotg->otg.otg, false);
-			xusbps_otg_phy_low_power_wait(1);
+			zynq_otg_phy_low_power_wait(1);
 			xotg->otg.state = OTG_STATE_A_VBUS_ERR;
 		} else if (xotg->hsm.a_bus_drop ||
 				(xotg->hsm.a_wait_bcon_tmout &&
@@ -1273,9 +1273,9 @@ static void xusbps_otg_work(struct work_struct *work)
 			/* Turn off VBus */
 			xotg->otg.otg->set_vbus(xotg->otg.otg, false);
 			set_client_mode();
-			xusbps_otg_phy_low_power_wait(1);
+			zynq_otg_phy_low_power_wait(1);
 			xotg->otg.state = OTG_STATE_B_IDLE;
-			xusbps_update_transceiver();
+			zynq_update_transceiver();
 		} else if (xotg->hsm.a_bus_drop ||
 				(xotg->otg.otg->host &&
 				!xotg->otg.otg->host->b_hnp_enable &&
@@ -1298,7 +1298,7 @@ static void xusbps_otg_work(struct work_struct *work)
 
 			/* Turn off VBus */
 			xotg->otg.otg->set_vbus(xotg->otg.otg, false);
-			xusbps_otg_phy_low_power_wait(1);
+			zynq_otg_phy_low_power_wait(1);
 			xotg->otg.state = OTG_STATE_A_VBUS_ERR;
 		} else if (xotg->otg.otg->host &&
 				xotg->otg.otg->host->b_hnp_enable &&
@@ -1317,23 +1317,23 @@ static void xusbps_otg_work(struct work_struct *work)
 						xotg->irq);
 			}
 			/* set HABA */
-			xusbps_otg_HABA(1);
+			zynq_otg_HABA(1);
 			xotg->hsm.b_bus_resume = 0;
 			xotg->hsm.a_aidl_bdis_tmout = 0;
-			xusbps_otg_loc_sof(0);
+			zynq_otg_loc_sof(0);
 			/* clear PHCD to enable HW timer */
-			xusbps_otg_phy_low_power(0);
-			xusbps_otg_add_timer(a_aidl_bdis_tmr);
+			zynq_otg_phy_low_power(0);
+			zynq_otg_add_timer(a_aidl_bdis_tmr);
 			xotg->otg.state = OTG_STATE_A_SUSPEND;
 		} else if (!xotg->hsm.b_conn || !xotg->hsm.a_bus_req) {
-			xusbps_otg_add_ktimer(TA_WAIT_BCON_TMR);
+			zynq_otg_add_ktimer(TA_WAIT_BCON_TMR);
 			xotg->otg.state = OTG_STATE_A_WAIT_BCON;
 		}
 		break;
 	case OTG_STATE_A_SUSPEND:
 		if (xotg->hsm.id) {
-			xusbps_otg_del_timer(a_aidl_bdis_tmr);
-			xusbps_otg_HABA(0);
+			zynq_otg_del_timer(a_aidl_bdis_tmr);
+			zynq_otg_HABA(0);
 			free_irq(xotg->irq, xotg->base);
 			xotg->otg.otg->default_a = 0;
 			xotg->hsm.b_bus_req = 0;
@@ -1347,22 +1347,22 @@ static void xusbps_otg_work(struct work_struct *work)
 			/* Turn off VBus */
 			xotg->otg.otg->set_vbus(xotg->otg.otg, false);
 			set_client_mode();
-			xusbps_otg_phy_low_power(1);
+			zynq_otg_phy_low_power(1);
 			xotg->otg.state = OTG_STATE_B_IDLE;
-			xusbps_update_transceiver();
+			zynq_update_transceiver();
 		} else if (xotg->hsm.a_bus_req ||
 				xotg->hsm.b_bus_resume) {
-			xusbps_otg_del_timer(a_aidl_bdis_tmr);
-			xusbps_otg_HABA(0);
+			zynq_otg_del_timer(a_aidl_bdis_tmr);
+			zynq_otg_HABA(0);
 			free_irq(xotg->irq, xotg->base);
 			xotg->hsm.a_suspend_req = 0;
-			xusbps_otg_loc_sof(1);
+			zynq_otg_loc_sof(1);
 			xotg->otg.state = OTG_STATE_A_HOST;
 		} else if (xotg->hsm.a_aidl_bdis_tmout ||
 				xotg->hsm.a_bus_drop) {
 			dev_warn(xotg->dev, "B disconnect timeout\n");
-			xusbps_otg_del_timer(a_aidl_bdis_tmr);
-			xusbps_otg_HABA(0);
+			zynq_otg_del_timer(a_aidl_bdis_tmr);
+			zynq_otg_HABA(0);
 			free_irq(xotg->irq, xotg->base);
 			if (xotg->stop_host)
 				xotg->stop_host(&xotg->otg);
@@ -1375,8 +1375,8 @@ static void xusbps_otg_work(struct work_struct *work)
 			xotg->otg.state = OTG_STATE_A_WAIT_VFALL;
 		} else if (!xotg->hsm.b_conn && xotg->otg.otg->host &&
 				xotg->otg.otg->host->b_hnp_enable) {
-			xusbps_otg_del_timer(a_aidl_bdis_tmr);
-			xusbps_otg_HABA(0);
+			zynq_otg_del_timer(a_aidl_bdis_tmr);
+			zynq_otg_HABA(0);
 			free_irq(xotg->irq, xotg->base);
 
 			if (xotg->stop_host)
@@ -1395,11 +1395,11 @@ static void xusbps_otg_work(struct work_struct *work)
 			else
 				dev_dbg(xotg->dev,
 					"client driver not loaded.\n");
-			xusbps_otg_add_ktimer(TB_BUS_SUSPEND_TMR);
+			zynq_otg_add_ktimer(TB_BUS_SUSPEND_TMR);
 			break;
 		} else if (!xotg->hsm.a_vbus_vld) {
-			xusbps_otg_del_timer(a_aidl_bdis_tmr);
-			xusbps_otg_HABA(0);
+			zynq_otg_del_timer(a_aidl_bdis_tmr);
+			zynq_otg_HABA(0);
 			free_irq(xotg->irq, xotg->base);
 			if (xotg->stop_host)
 				xotg->stop_host(&xotg->otg);
@@ -1409,7 +1409,7 @@ static void xusbps_otg_work(struct work_struct *work)
 
 			/* Turn off VBus */
 			xotg->otg.otg->set_vbus(xotg->otg.otg, false);
-			xusbps_otg_phy_low_power_wait(1);
+			zynq_otg_phy_low_power_wait(1);
 			xotg->otg.state = OTG_STATE_A_VBUS_ERR;
 		}
 		break;
@@ -1428,9 +1428,9 @@ static void xusbps_otg_work(struct work_struct *work)
 			/* Turn off VBus */
 			xotg->otg.otg->set_vbus(xotg->otg.otg, false);
 			set_client_mode();
-			xusbps_otg_phy_low_power_wait(1);
+			zynq_otg_phy_low_power_wait(1);
 			xotg->otg.state = OTG_STATE_B_IDLE;
-			xusbps_update_transceiver();
+			zynq_update_transceiver();
 		} else if (!xotg->hsm.a_vbus_vld) {
 			/* delete hsm timer for b_bus_suspend_tmr */
 			del_timer_sync(&xotg->hsm_timer);
@@ -1443,7 +1443,7 @@ static void xusbps_otg_work(struct work_struct *work)
 
 			/* Turn off VBus */
 			xotg->otg.otg->set_vbus(xotg->otg.otg, false);
-			xusbps_otg_phy_low_power_wait(1);
+			zynq_otg_phy_low_power_wait(1);
 			xotg->otg.state = OTG_STATE_A_VBUS_ERR;
 		} else if (xotg->hsm.a_bus_drop) {
 			/* delete hsm timer for b_bus_suspend_tmr */
@@ -1475,7 +1475,7 @@ static void xusbps_otg_work(struct work_struct *work)
 			else
 				dev_dbg(xotg->dev,
 						"host driver not loaded.\n");
-			xusbps_otg_add_ktimer(TA_WAIT_BCON_TMR);
+			zynq_otg_add_ktimer(TA_WAIT_BCON_TMR);
 		} else if (xotg->hsm.b_bus_suspend_tmout) {
 			u32	val;
 			val = readl(xotg->base + CI_PORTSC1);
@@ -1494,7 +1494,7 @@ static void xusbps_otg_work(struct work_struct *work)
 			else
 				dev_dbg(xotg->dev,
 						"host driver not loaded.\n");
-			xusbps_otg_add_ktimer(TA_WAIT_BCON_TMR);
+			zynq_otg_add_ktimer(TA_WAIT_BCON_TMR);
 		}
 		break;
 	case OTG_STATE_A_VBUS_ERR:
@@ -1503,40 +1503,40 @@ static void xusbps_otg_work(struct work_struct *work)
 			xotg->hsm.a_clr_err = 0;
 			xotg->hsm.a_srp_det = 0;
 			set_client_mode();
-			xusbps_otg_phy_low_power(1);
+			zynq_otg_phy_low_power(1);
 			xotg->otg.state = OTG_STATE_B_IDLE;
-			xusbps_update_transceiver();
+			zynq_update_transceiver();
 		} else if (xotg->hsm.a_clr_err) {
 			xotg->hsm.a_clr_err = 0;
 			xotg->hsm.a_srp_det = 0;
 			reset_otg();
 			init_hsm();
 			if (xotg->otg.state == OTG_STATE_A_IDLE)
-				xusbps_update_transceiver();
+				zynq_update_transceiver();
 		} else {
 			/* FW will clear PHCD bit when any VBus
 			 * event detected. Reset PHCD to 1 again */
-			xusbps_otg_phy_low_power(1);
+			zynq_otg_phy_low_power(1);
 		}
 		break;
 	case OTG_STATE_A_WAIT_VFALL:
 		if (xotg->hsm.id) {
 			xotg->otg.otg->default_a = 0;
 			set_client_mode();
-			xusbps_otg_phy_low_power(1);
+			zynq_otg_phy_low_power(1);
 			xotg->otg.state = OTG_STATE_B_IDLE;
-			xusbps_update_transceiver();
+			zynq_update_transceiver();
 		} else if (xotg->hsm.a_bus_req) {
 
 			/* Turn on VBus */
 			xotg->otg.otg->set_vbus(xotg->otg.otg, true);
 			xotg->hsm.a_wait_vrise_tmout = 0;
-			xusbps_otg_add_timer(a_wait_vrise_tmr);
+			zynq_otg_add_timer(a_wait_vrise_tmr);
 			xotg->otg.state = OTG_STATE_A_WAIT_VRISE;
 		} else if (!xotg->hsm.a_sess_vld) {
 			xotg->hsm.a_srp_det = 0;
 			set_host_mode();
-			xusbps_otg_phy_low_power(1);
+			zynq_otg_phy_low_power(1);
 			xotg->otg.state = OTG_STATE_A_IDLE;
 		}
 		break;
@@ -1551,7 +1551,7 @@ static void xusbps_otg_work(struct work_struct *work)
 static ssize_t
 show_registers(struct device *_dev, struct device_attribute *attr, char *buf)
 {
-	struct xusbps_otg	*xotg = the_transceiver;
+	struct zynq_otg	*xotg = the_transceiver;
 	char			*next;
 	unsigned		size, t;
 
@@ -1585,7 +1585,7 @@ static DEVICE_ATTR(registers, S_IRUGO, show_registers, NULL);
 static ssize_t
 show_hsm(struct device *_dev, struct device_attribute *attr, char *buf)
 {
-	struct xusbps_otg		*xotg = the_transceiver;
+	struct zynq_otg		*xotg = the_transceiver;
 	char				*next;
 	unsigned			size, t;
 
@@ -1667,7 +1667,7 @@ static DEVICE_ATTR(hsm, S_IRUGO, show_hsm, NULL);
 static ssize_t
 get_a_bus_req(struct device *dev, struct device_attribute *attr, char *buf)
 {
-	struct xusbps_otg	*xotg = the_transceiver;
+	struct zynq_otg	*xotg = the_transceiver;
 	char			*next;
 	unsigned		size, t;
 
@@ -1685,7 +1685,7 @@ static ssize_t
 set_a_bus_req(struct device *dev, struct device_attribute *attr,
 		const char *buf, size_t count)
 {
-	struct xusbps_otg		*xotg = the_transceiver;
+	struct zynq_otg		*xotg = the_transceiver;
 
 	if (!xotg->otg.otg->default_a)
 		return -1;
@@ -1703,7 +1703,7 @@ set_a_bus_req(struct device *dev, struct device_attribute *attr,
 		dev_dbg(xotg->dev, "User request: a_bus_req = 1\n");
 	}
 	if (spin_trylock(&xotg->wq_lock)) {
-		xusbps_update_transceiver();
+		zynq_update_transceiver();
 		spin_unlock(&xotg->wq_lock);
 	}
 	return count;
@@ -1713,7 +1713,7 @@ static DEVICE_ATTR(a_bus_req, S_IRUGO | S_IWUSR, get_a_bus_req, set_a_bus_req);
 static ssize_t
 get_a_bus_drop(struct device *dev, struct device_attribute *attr, char *buf)
 {
-	struct xusbps_otg	*xotg = the_transceiver;
+	struct zynq_otg	*xotg = the_transceiver;
 	char			*next;
 	unsigned		size, t;
 
@@ -1731,7 +1731,7 @@ static ssize_t
 set_a_bus_drop(struct device *dev, struct device_attribute *attr,
 		const char *buf, size_t count)
 {
-	struct xusbps_otg		*xotg = the_transceiver;
+	struct zynq_otg		*xotg = the_transceiver;
 
 	if (!xotg->otg.otg->default_a)
 		return -1;
@@ -1748,7 +1748,7 @@ set_a_bus_drop(struct device *dev, struct device_attribute *attr,
 		dev_dbg(xotg->dev, "User request: and a_bus_req = 0\n");
 	}
 	if (spin_trylock(&xotg->wq_lock)) {
-		xusbps_update_transceiver();
+		zynq_update_transceiver();
 		spin_unlock(&xotg->wq_lock);
 	}
 	return count;
@@ -1759,7 +1759,7 @@ static DEVICE_ATTR(a_bus_drop, S_IRUGO | S_IWUSR, get_a_bus_drop,
 static ssize_t
 get_b_bus_req(struct device *dev, struct device_attribute *attr, char *buf)
 {
-	struct xusbps_otg	*xotg = the_transceiver;
+	struct zynq_otg	*xotg = the_transceiver;
 	char			*next;
 	unsigned		size, t;
 
@@ -1777,7 +1777,7 @@ static ssize_t
 set_b_bus_req(struct device *dev, struct device_attribute *attr,
 		const char *buf, size_t count)
 {
-	struct xusbps_otg		*xotg = the_transceiver;
+	struct zynq_otg		*xotg = the_transceiver;
 
 	if (xotg->otg.otg->default_a)
 		return -1;
@@ -1793,7 +1793,7 @@ set_b_bus_req(struct device *dev, struct device_attribute *attr,
 		dev_dbg(xotg->dev, "User request: b_bus_req = 1\n");
 	}
 	if (spin_trylock(&xotg->wq_lock)) {
-		xusbps_update_transceiver();
+		zynq_update_transceiver();
 		spin_unlock(&xotg->wq_lock);
 	}
 	return count;
@@ -1804,7 +1804,7 @@ static ssize_t
 set_a_clr_err(struct device *dev, struct device_attribute *attr,
 		const char *buf, size_t count)
 {
-	struct xusbps_otg		*xotg = the_transceiver;
+	struct zynq_otg		*xotg = the_transceiver;
 
 	if (!xotg->otg.otg->default_a)
 		return -1;
@@ -1816,7 +1816,7 @@ set_a_clr_err(struct device *dev, struct device_attribute *attr,
 		dev_dbg(xotg->dev, "User request: a_clr_err = 1\n");
 	}
 	if (spin_trylock(&xotg->wq_lock)) {
-		xusbps_update_transceiver();
+		zynq_update_transceiver();
 		spin_unlock(&xotg->wq_lock);
 	}
 	return count;
@@ -1835,7 +1835,7 @@ static DEVICE_ATTR(a_clr_err, S_IWUSR, NULL, set_a_clr_err);
  **/
 static int suspend_otg_device(struct usb_phy *otg)
 {
-	struct xusbps_otg		*xotg = the_transceiver;
+	struct zynq_otg		*xotg = the_transceiver;
 	unsigned long otg_port = otg->otg->host->otg_port;
 	struct usb_device *udev;
 	int err;
@@ -1860,7 +1860,7 @@ static ssize_t
 do_hnp(struct device *dev, struct device_attribute *attr,
 		const char *buf, size_t count)
 {
-	struct xusbps_otg		*xotg = the_transceiver;
+	struct zynq_otg		*xotg = the_transceiver;
 	unsigned long ret;
 
 	if (count > 2)
@@ -1886,7 +1886,7 @@ do_hnp(struct device *dev, struct device_attribute *attr,
 }
 static DEVICE_ATTR(do_hnp, S_IWUSR, NULL, do_hnp);
 
-static int xusbps_otg_clk_notifier_cb(struct notifier_block *nb,
+static int zynq_otg_clk_notifier_cb(struct notifier_block *nb,
 		unsigned long event, void *data)
 {
 
@@ -1919,15 +1919,15 @@ static struct attribute_group debug_dev_attr_group = {
 	.attrs = inputs_attrs,
 };
 
-static int xusbps_otg_remove(struct platform_device *pdev)
+static int zynq_otg_remove(struct platform_device *pdev)
 {
-	struct xusbps_otg *xotg = the_transceiver;
+	struct zynq_otg *xotg = the_transceiver;
 
 	if (xotg->qwork) {
 		flush_workqueue(xotg->qwork);
 		destroy_workqueue(xotg->qwork);
 	}
-	xusbps_otg_free_timers();
+	zynq_otg_free_timers();
 
 	/* disable OTGSC interrupt as OTGSC doesn't change in reset */
 	writel(0, xotg->base + CI_OTGSC);
@@ -1942,13 +1942,13 @@ static int xusbps_otg_remove(struct platform_device *pdev)
 	return 0;
 }
 
-static int xusbps_otg_probe(struct platform_device *pdev)
+static int zynq_otg_probe(struct platform_device *pdev)
 {
 	int			retval;
 	u32			val32;
-	struct xusbps_otg	*xotg;
-	char			qname[] = "xusbps_otg_queue";
-	struct xusbps_usb2_platform_data *pdata;
+	struct zynq_otg	*xotg;
+	char			qname[] = "zynq_otg_queue";
+	struct zynq_usb2_platform_data *pdata;
 
 	pdata = pdev->dev.platform_data;
 	if (!pdata)
@@ -1983,7 +1983,7 @@ static int xusbps_otg_probe(struct platform_device *pdev)
 		retval = -ENOMEM;
 		goto err;
 	}
-	INIT_WORK(&xotg->work, xusbps_otg_work);
+	INIT_WORK(&xotg->work, zynq_otg_work);
 
 	xotg->clk = pdata->clk;
 	retval = clk_prepare_enable(xotg->clk);
@@ -1992,7 +1992,7 @@ static int xusbps_otg_probe(struct platform_device *pdev)
 		goto err;
 	}
 
-	xotg->clk_rate_change_nb.notifier_call = xusbps_otg_clk_notifier_cb;
+	xotg->clk_rate_change_nb.notifier_call = zynq_otg_clk_notifier_cb;
 	xotg->clk_rate_change_nb.next = NULL;
 	if (clk_notifier_register(xotg->clk, &xotg->clk_rate_change_nb))
 		dev_warn(&pdev->dev, "Unable to register clock notifier.\n");
@@ -2001,12 +2001,12 @@ static int xusbps_otg_probe(struct platform_device *pdev)
 	xotg->dev = &pdev->dev;
 	xotg->otg.dev = xotg->dev;
 	xotg->otg.label = driver_name;
-	xotg->otg.otg->set_host = xusbps_otg_set_host;
-	xotg->otg.otg->set_peripheral = xusbps_otg_set_peripheral;
-	xotg->otg.set_power = xusbps_otg_set_power;
-	xotg->otg.otg->set_vbus = xusbps_otg_set_vbus;
-	xotg->otg.otg->start_srp = xusbps_otg_start_srp;
-	xotg->otg.otg->start_hnp = xusbps_otg_start_hnp;
+	xotg->otg.otg->set_host = zynq_otg_set_host;
+	xotg->otg.otg->set_peripheral = zynq_otg_set_peripheral;
+	xotg->otg.set_power = zynq_otg_set_power;
+	xotg->otg.otg->set_vbus = zynq_otg_set_vbus;
+	xotg->otg.otg->start_srp = zynq_otg_start_srp;
+	xotg->otg.otg->start_hnp = zynq_otg_start_hnp;
 	xotg->otg.state = OTG_STATE_UNDEFINED;
 
 	if (usb_add_phy(&xotg->otg, USB_PHY_TYPE_USB2)) {
@@ -2022,7 +2022,7 @@ static int xusbps_otg_probe(struct platform_device *pdev)
 	spin_lock_init(&xotg->lock);
 	spin_lock_init(&xotg->wq_lock);
 	INIT_LIST_HEAD(&active_timers);
-	retval = xusbps_otg_init_timers(&xotg->hsm);
+	retval = zynq_otg_init_timers(&xotg->hsm);
 	if (retval) {
 		dev_dbg(&pdev->dev, "Failed to init timers\n");
 		goto err_out_clk_disable;
@@ -2068,7 +2068,7 @@ static int xusbps_otg_probe(struct platform_device *pdev)
 	}
 
 	if (xotg->otg.state == OTG_STATE_A_IDLE)
-		xusbps_update_transceiver();
+		zynq_update_transceiver();
 
 	return 0;
 
@@ -2076,7 +2076,7 @@ err_out_clk_disable:
 	clk_notifier_unregister(xotg->clk, &xotg->clk_rate_change_nb);
 	clk_disable_unprepare(xotg->clk);
 err:
-	xusbps_otg_remove(pdev);
+	zynq_otg_remove(pdev);
 
 	return retval;
 }
@@ -2084,17 +2084,17 @@ err:
 #ifdef CONFIG_PM_SLEEP
 static void transceiver_suspend(struct platform_device *pdev)
 {
-	xusbps_otg_phy_low_power(1);
+	zynq_otg_phy_low_power(1);
 }
 
-static int xusbps_otg_suspend(struct device *dev)
+static int zynq_otg_suspend(struct device *dev)
 {
 	struct platform_device *pdev = to_platform_device(dev);
-	struct xusbps_otg		*xotg = the_transceiver;
+	struct zynq_otg		*xotg = the_transceiver;
 	int				ret = 0;
 
 	/* Disbale OTG interrupts */
-	xusbps_otg_intr(0);
+	zynq_otg_intr(0);
 
 	if (xotg->irq)
 		free_irq(xotg->irq, xotg);
@@ -2114,7 +2114,7 @@ static int xusbps_otg_suspend(struct device *dev)
 		transceiver_suspend(pdev);
 		break;
 	case OTG_STATE_A_WAIT_VRISE:
-		xusbps_otg_del_timer(a_wait_vrise_tmr);
+		zynq_otg_del_timer(a_wait_vrise_tmr);
 		xotg->hsm.a_srp_det = 0;
 
 		/* Turn off VBus */
@@ -2151,8 +2151,8 @@ static int xusbps_otg_suspend(struct device *dev)
 		transceiver_suspend(pdev);
 		break;
 	case OTG_STATE_A_SUSPEND:
-		xusbps_otg_del_timer(a_aidl_bdis_tmr);
-		xusbps_otg_HABA(0);
+		zynq_otg_del_timer(a_aidl_bdis_tmr);
+		zynq_otg_HABA(0);
 		if (xotg->stop_host)
 			xotg->stop_host(&xotg->otg);
 		else
@@ -2201,7 +2201,7 @@ static int xusbps_otg_suspend(struct device *dev)
 		/* delete hsm timer for b_ase0_brst_tmr */
 		del_timer_sync(&xotg->hsm_timer);
 
-		xusbps_otg_HAAR(0);
+		zynq_otg_HAAR(0);
 
 		if (xotg->stop_host)
 			xotg->stop_host(&xotg->otg);
@@ -2226,10 +2226,10 @@ static void transceiver_resume(struct platform_device *pdev)
 	/* Not used */
 }
 
-static int xusbps_otg_resume(struct device *dev)
+static int zynq_otg_resume(struct device *dev)
 {
 	struct platform_device *pdev = to_platform_device(dev);
-	struct xusbps_otg	*xotg = the_transceiver;
+	struct zynq_otg	*xotg = the_transceiver;
 	int			ret = 0;
 
 	ret = clk_enable(xotg->clk);
@@ -2240,9 +2240,9 @@ static int xusbps_otg_resume(struct device *dev)
 
 	transceiver_resume(pdev);
 
-	xotg->qwork = create_singlethread_workqueue("xusbps_otg_queue");
+	xotg->qwork = create_singlethread_workqueue("zynq_otg_queue");
 	if (!xotg->qwork) {
-		dev_dbg(&pdev->dev, "cannot create xusbps otg workqueuen");
+		dev_dbg(&pdev->dev, "cannot create zynq otg workqueuen");
 		ret = -ENOMEM;
 		goto error;
 	}
@@ -2255,44 +2255,44 @@ static int xusbps_otg_resume(struct device *dev)
 	}
 
 	/* enable OTG interrupts */
-	xusbps_otg_intr(1);
+	zynq_otg_intr(1);
 
 	update_hsm();
 
-	xusbps_update_transceiver();
+	zynq_update_transceiver();
 
 	return ret;
 error:
-	xusbps_otg_intr(0);
+	zynq_otg_intr(0);
 	transceiver_suspend(pdev);
 	return ret;
 }
 
-static const struct dev_pm_ops xusbps_otg_dev_pm_ops = {
-	SET_SYSTEM_SLEEP_PM_OPS(xusbps_otg_suspend, xusbps_otg_resume)
+static const struct dev_pm_ops zynq_otg_dev_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(zynq_otg_suspend, zynq_otg_resume)
 };
-#define XUSBPS_OTG_PM	(&xusbps_otg_dev_pm_ops)
+#define ZYNQ_OTG_PM	(&zynq_otg_dev_pm_ops)
 
 #else /* ! CONFIG_PM_SLEEP */
-#define XUSBPS_OTG_PM	NULL
+#define ZYNQ_OTG_PM	NULL
 #endif /* ! CONFIG_PM_SLEEP */
 
 #ifndef CONFIG_USB_ZYNQ_DR_OF
-static struct platform_driver xusbps_otg_driver = {
+static struct platform_driver zynq_otg_driver = {
 #else
-struct platform_driver xusbps_otg_driver = {
+struct platform_driver zynq_otg_driver = {
 #endif
-	.probe		= xusbps_otg_probe,
-	.remove		= xusbps_otg_remove,
+	.probe		= zynq_otg_probe,
+	.remove		= zynq_otg_remove,
 	.driver		= {
 		.owner	= THIS_MODULE,
 		.name	= DRIVER_NAME,
-		.pm	= XUSBPS_OTG_PM,
+		.pm	= ZYNQ_OTG_PM,
 	},
 };
 
 #ifndef CONFIG_USB_ZYNQ_DR_OF
-module_platform_driver(xusbps_otg_driver);
+module_platform_driver(zynq_otg_driver);
 #endif
 
 MODULE_AUTHOR("Xilinx, Inc.");
diff --git a/include/linux/usb/zynq_otg.h b/include/linux/usb/zynq_otg.h
index 65fb20f..1027a5e 100644
--- a/include/linux/usb/zynq_otg.h
+++ b/include/linux/usb/zynq_otg.h
@@ -71,7 +71,7 @@
 
 #define INTR_DUMMY_MASK (USBSTS_SLI | USBSTS_URI | USBSTS_PCI)
 
-enum xusbps_otg_timer_type {
+enum zynq_otg_timer_type {
 	TA_WAIT_VRISE_TMR,
 	TA_WAIT_BCON_TMR,
 	TA_AIDL_BDIS_TMR,
@@ -91,7 +91,7 @@ enum xusbps_otg_timer_type {
 #define TB_SRP_FAIL	5500
 #define TB_BUS_SUSPEND	500
 
-struct xusbps_otg_timer {
+struct zynq_otg_timer {
 	unsigned long expires;	/* Number of count increase to timeout */
 	unsigned long count;	/* Tick counter */
 	void (*function)(unsigned long);	/* Timeout function */
@@ -164,7 +164,7 @@ struct otg_hsm {
 	int vbus_srp_up;
 };
 
-struct xusbps_otg {
+struct zynq_otg {
 	struct usb_phy		otg;
 	struct usb_phy		*ulpi;
 
@@ -206,11 +206,11 @@ struct xusbps_otg {
 };
 
 static inline
-struct xusbps_otg *xceiv_to_xotg(struct usb_phy *otg)
+struct zynq_otg *xceiv_to_xotg(struct usb_phy *otg)
 {
-	return container_of(otg, struct xusbps_otg, otg);
+	return container_of(otg, struct zynq_otg, otg);
 }
 
-void xusbps_update_transceiver(void);
+void zynq_update_transceiver(void);
 
 #endif /* __ZYNQ_OTG_H__ */
diff --git a/include/linux/xilinx_devices.h b/include/linux/xilinx_devices.h
index 4db514f..aaa03b2 100644
--- a/include/linux/xilinx_devices.h
+++ b/include/linux/xilinx_devices.h
@@ -21,28 +21,28 @@
 #include <linux/platform_device.h>
 
 /*- PS USB Controller IP -*/
-enum xusbps_usb2_operating_modes {
-	XUSBPS_USB2_MPH_HOST,
-	XUSBPS_USB2_DR_HOST,
-	XUSBPS_USB2_DR_DEVICE,
-	XUSBPS_USB2_DR_OTG,
+enum zynq_usb2_operating_modes {
+	ZYNQ_USB2_MPH_HOST,
+	ZYNQ_USB2_DR_HOST,
+	ZYNQ_USB2_DR_DEVICE,
+	ZYNQ_USB2_DR_OTG,
 };
 
-enum xusbps_usb2_phy_modes {
-	XUSBPS_USB2_PHY_NONE,
-	XUSBPS_USB2_PHY_ULPI,
-	XUSBPS_USB2_PHY_UTMI,
-	XUSBPS_USB2_PHY_UTMI_WIDE,
-	XUSBPS_USB2_PHY_SERIAL,
+enum zynq_usb2_phy_modes {
+	ZYNQ_USB2_PHY_NONE,
+	ZYNQ_USB2_PHY_ULPI,
+	ZYNQ_USB2_PHY_UTMI,
+	ZYNQ_USB2_PHY_UTMI_WIDE,
+	ZYNQ_USB2_PHY_SERIAL,
 };
 
 struct clk;
 struct platform_device;
 
-struct xusbps_usb2_platform_data {
+struct zynq_usb2_platform_data {
 	/* board specific information */
-	enum xusbps_usb2_operating_modes	operating_mode;
-	enum xusbps_usb2_phy_modes	phy_mode;
+	enum zynq_usb2_operating_modes	operating_mode;
+	enum zynq_usb2_phy_modes	phy_mode;
 	unsigned int			port_enables;
 	unsigned int			workaround;
 
@@ -63,8 +63,8 @@ struct xusbps_usb2_platform_data {
 	unsigned	invert_pwr_fault:1;
 };
 
-#define XUSBPS_USB2_PORT0_ENABLED	0x00000001
-#define XUSBPS_USB2_PORT1_ENABLED	0x00000002
+#define ZYNQ_USB2_PORT0_ENABLED	0x00000001
+#define ZYNQ_USB2_PORT1_ENABLED	0x00000002
 
 #endif /* _XILINX_DEVICE_H_ */
 #endif /* __KERNEL__ */
-- 
1.7.5.4

