From 0b98aef598354c64fa87c49687f2a42d27ddcc6f Mon Sep 17 00:00:00 2001
From: Zumeng Chen <zumeng.chen@windriver.com>
Date: Tue, 24 Mar 2015 14:24:31 +0800
Subject: [PATCH] mtd: m25p80: fix a wrong name and a right order based on
 mainline

The old style of flash_info->flags is too bad to read well, so adjust
them according to the mainline commit d928a259.

And fix a wrong issue from E_FSR into USE_FSR, meanwhile SECT_32K
is a SDK stuff from Xilinx, which is not very clear.

Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>

diff --git a/drivers/mtd/devices/m25p80.c b/drivers/mtd/devices/m25p80.c
index fe5b870034fe..4f179112ef38 100644
--- a/drivers/mtd/devices/m25p80.c
+++ b/drivers/mtd/devices/m25p80.c
@@ -1095,14 +1095,15 @@ struct flash_info {
 	u16		addr_width;
 
 	u16		flags;
-#define	SECT_4K		0x01		/* OPCODE_BE_4K works uniformly */
-#define	M25P_NO_ERASE	0x02		/* No erase command needed */
-#define	SST_WRITE	0x04		/* use SST byte programming */
-#define	M25P_NO_FR	0x08		/* Can't do fastread */
-#define	SECT_4K_PMC	0x10		/* OPCODE_BE_4K_PMC works uniformly */
-#define	M25P80_QUAD_READ	0x20    /* Flash supports Quad Read */
-#define	SECT_32K	0x80		/* OPCODE_BE_32K */
-#define E_FSR		0x40		/* Flag SR exists for flash */
+#define	SECT_4K			0x01	/* SPINOR_OP_BE_4K works uniformly */
+#define	M25P_NO_ERASE		0x02	/* No erase command needed */
+#define	SST_WRITE		0x04	/* use SST byte programming */
+#define	M25P_NO_FR		0x08	/* Can't do fastread */
+#define	SECT_4K_PMC		0x10	/* SPINOR_OP_BE_4K_PMC works uniformly */
+#define	M25P80_DUAL_READ	0x20    /* Flash supports Dual Read */
+#define	M25P80_QUAD_READ	0x40    /* Flash supports Quad Read */
+#define	USE_FSR			0x80	/* use flag status register */
+#define	SECT_32K		0x80	/* OPCODE_BE_32K */
 };
 
 #define INFO(_jedec_id, _ext_id, _sector_size, _n_sectors, _flags)	\
@@ -1190,19 +1191,19 @@ static const struct spi_device_id m25p_ids[] = {
 	/* Numonyx flash n25q128 - FIXME check the name */
 	{ "n25q128",   INFO(0x20bb18, 0, 64 * 1024, 256, M25P80_QUAD_READ) },
 	{ "n25q128a11",  INFO(0x20bb18, 0, 64 * 1024, 256,
-			      E_FSR | M25P80_QUAD_READ) },
+			      USE_FSR | M25P80_QUAD_READ) },
 	{ "n25q128a13",  INFO(0x20ba18, 0, 64 * 1024, 256,
-			      E_FSR | M25P80_QUAD_READ) },
+			      USE_FSR | M25P80_QUAD_READ) },
 	{ "n25q256a13", INFO(0x20ba19,  0, 64 * 1024,  512,
-			     SECT_4K | E_FSR | M25P80_QUAD_READ) },
+			     SECT_4K | USE_FSR | M25P80_QUAD_READ) },
 	{ "n25q256a11", INFO(0x20bb19,  0, 64 * 1024,  512,
-			     SECT_4K | E_FSR | M25P80_QUAD_READ) },
+			     SECT_4K | USE_FSR | M25P80_QUAD_READ) },
 	{ "n25q512a13", INFO(0x20ba20,  0, 64 * 1024,  1024,
-			     SECT_4K | E_FSR | M25P80_QUAD_READ) },
+			     SECT_4K | USE_FSR | M25P80_QUAD_READ) },
 	{ "n25q512a11", INFO(0x20bb20,  0, 64 * 1024,  1024,
-			     SECT_4K | E_FSR | M25P80_QUAD_READ) },
+			     SECT_4K | USE_FSR | M25P80_QUAD_READ) },
 	{ "n25q00aa13", INFO(0x20ba21,  0, 64 * 1024,  2048,
-			     SECT_4K | E_FSR | M25P80_QUAD_READ) },
+			     SECT_4K | USE_FSR | M25P80_QUAD_READ) },
 
 	/* PMC */
 	{ "pm25lv512",   INFO(0,        0, 32 * 1024,    2, SECT_4K_PMC) },
@@ -1543,7 +1544,7 @@ static int m25p_probe(struct spi_device *spi)
 	if (info->flags & M25P_NO_ERASE)
 		flash->mtd.flags |= MTD_NO_ERASE;
 
-	if (info->flags & E_FSR)
+	if (info->flags & USE_FSR)
 		flash->check_fsr = 1;
 
 	flash->jedec_id = info->jedec_id;
-- 
2.1.0

