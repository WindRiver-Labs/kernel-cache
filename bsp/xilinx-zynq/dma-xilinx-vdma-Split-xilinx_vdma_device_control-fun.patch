From ec48c4b11b4a9a6080c5862e82d2462217e50462 Mon Sep 17 00:00:00 2001
From: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date: Thu, 23 May 2013 00:28:16 +0200
Subject: [PATCH 305/509] dma: xilinx: vdma: Split
 xilinx_vdma_device_control() function

https://github.com/analogdevicesinc/linux.git xcomm_zynq
commit cdcfc538c67d9cdbc1943dcc33444f51c383265c

Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Acked-by: Srikanth Thokala <sthokal@xilinx.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 drivers/dma/xilinx/xilinx_axivdma.c |  191 +++++++++++++++++++----------------
 1 files changed, 102 insertions(+), 89 deletions(-)

diff --git a/drivers/dma/xilinx/xilinx_axivdma.c b/drivers/dma/xilinx/xilinx_axivdma.c
index 015bccc..a9e20e9 100644
--- a/drivers/dma/xilinx/xilinx_axivdma.c
+++ b/drivers/dma/xilinx/xilinx_axivdma.c
@@ -882,119 +882,132 @@ fail:
 	return NULL;
 }
 
-/*
- * Run-time configuration for Axi VDMA, supports:
- * . halt the channel
- * . configure interrupt coalescing and inter-packet delay threshold
- * . start/stop parking
- * . enable genlock
- * . set transfer information using config struct
- */
-static int xilinx_vdma_device_control(struct dma_chan *dchan,
-				enum dma_ctrl_cmd cmd, unsigned long arg)
+static void xilinx_vdma_terminate_all(struct xilinx_vdma_chan *chan)
 {
-	struct xilinx_vdma_chan *chan = to_xilinx_chan(dchan);
 	unsigned long flags;
 
-	if (cmd == DMA_TERMINATE_ALL) {
-		/* Halt the DMA engine */
-		xilinx_vdma_halt(chan);
-
-		spin_lock_irqsave(&chan->lock, flags);
-
-		/* Remove and free all of the descriptors in the lists */
-		xilinx_vdma_free_desc_list(chan, &chan->pending_list);
-		xilinx_vdma_free_desc_list(chan, &chan->active_list);
+	/* Halt the DMA engine */
+	xilinx_vdma_halt(chan);
 
-		spin_unlock_irqrestore(&chan->lock, flags);
-		return 0;
-	} else if (cmd == DMA_SLAVE_CONFIG) {
-		struct xilinx_vdma_config *cfg =
-				(struct xilinx_vdma_config *)arg;
-		u32 reg;
-
-		if (cfg->reset) {
-			xilinx_vdma_reset(chan);
-			return 0;
-		}
+	spin_lock_irqsave(&chan->lock, flags);
 
-		reg = vdma_ctrl_read(chan, XILINX_VDMA_REG_DMACR);
+	/* Remove and free all of the descriptors in the lists */
+	xilinx_vdma_free_desc_list(chan, &chan->pending_list);
+	xilinx_vdma_free_desc_list(chan, &chan->active_list);
 
-		/* If vsize is -1, it is park-related operations */
-		if (cfg->vsize == -1) {
-			if (cfg->park)
-				reg &= ~XILINX_VDMA_DMACR_CIRC_EN;
-			else
-				reg |= XILINX_VDMA_DMACR_CIRC_EN;
+	spin_unlock_irqrestore(&chan->lock, flags);
+}
 
-			vdma_ctrl_write(chan, XILINX_VDMA_REG_DMACR, reg);
-			return 0;
-		}
+static int xilinx_vdma_slave_config(struct xilinx_vdma_chan *chan,
+				    struct xilinx_vdma_config *cfg)
+{
+	u32 dmacr;
 
-		/* If hsize is -1, it is interrupt threshold settings */
-		if (cfg->hsize == -1) {
-			if (cfg->coalesc <= XILINX_VDMA_DMACR_FRAME_COUNT_MAX) {
-				reg &= ~XILINX_VDMA_DMACR_FRAME_COUNT_MASK;
-				reg |= cfg->coalesc <<
-					XILINX_VDMA_DMACR_FRAME_COUNT_SHIFT;
-				chan->config.coalesc = cfg->coalesc;
-			}
-
-			if (cfg->delay <= XILINX_VDMA_DMACR_DELAY_MAX) {
-				reg &= ~XILINX_VDMA_DMACR_DELAY_MASK;
-				reg |= cfg->delay << XILINX_VDMA_DMACR_DELAY_SHIFT;
-				chan->config.delay = cfg->delay;
-			}
-
-			vdma_ctrl_write(chan, XILINX_VDMA_REG_DMACR, reg);
-			return 0;
-		}
+	if (cfg->reset) {
+		xilinx_vdma_reset(chan);
+		return 0;
+	}
 
-		/* Transfer information */
-		chan->config.vsize = cfg->vsize;
-		chan->config.hsize = cfg->hsize;
-		chan->config.stride = cfg->stride;
-		chan->config.frm_dly = cfg->frm_dly;
-		chan->config.park = cfg->park;
-		chan->config.direction = cfg->direction;
-
-		/* genlock settings */
-		chan->config.gen_lock = cfg->gen_lock;
-		chan->config.master = cfg->master;
-
-		if (cfg->gen_lock) {
-			if (chan->genlock) {
-				reg |= XILINX_VDMA_DMACR_GENLOCK_EN;
-				reg |= cfg->master << XILINX_VDMA_DMACR_MASTER_SHIFT;
-			}
-		}
+	dmacr = vdma_ctrl_read(chan, XILINX_VDMA_REG_DMACR);
 
-		chan->config.frm_cnt_en = cfg->frm_cnt_en;
+	/* If vsize is -1, it is park-related operations */
+	if (cfg->vsize == -1) {
 		if (cfg->park)
-			chan->config.park_frm = cfg->park_frm;
+			dmacr &= ~XILINX_VDMA_DMACR_CIRC_EN;
 		else
-			chan->config.park_frm = -1;
+			dmacr |= XILINX_VDMA_DMACR_CIRC_EN;
 
-		chan->config.coalesc = cfg->coalesc;
-		chan->config.delay = cfg->delay;
+		vdma_ctrl_write(chan, XILINX_VDMA_REG_DMACR, dmacr);
+		return 0;
+	}
+
+	/* If hsize is -1, it is interrupt threshold settings */
+	if (cfg->hsize == -1) {
 		if (cfg->coalesc <= XILINX_VDMA_DMACR_FRAME_COUNT_MAX) {
-			reg |= cfg->coalesc << XILINX_VDMA_DMACR_FRAME_COUNT_SHIFT;
+			dmacr &= ~XILINX_VDMA_DMACR_FRAME_COUNT_MASK;
+			dmacr |= cfg->coalesc <<
+				 XILINX_VDMA_DMACR_FRAME_COUNT_SHIFT;
 			chan->config.coalesc = cfg->coalesc;
 		}
 
 		if (cfg->delay <= XILINX_VDMA_DMACR_DELAY_MAX) {
-			reg |= cfg->delay << XILINX_VDMA_DMACR_DELAY_SHIFT;
+			dmacr &= ~XILINX_VDMA_DMACR_DELAY_MASK;
+			dmacr |= cfg->delay << XILINX_VDMA_DMACR_DELAY_SHIFT;
 			chan->config.delay = cfg->delay;
 		}
 
-		/* FSync Source selection */
-		reg &= ~XILINX_VDMA_DMACR_FSYNCSRC_MASK;
-		reg |= cfg->ext_fsync << XILINX_VDMA_DMACR_FSYNCSRC_SHIFT;
+		vdma_ctrl_write(chan, XILINX_VDMA_REG_DMACR, dmacr);
+		return 0;
+	}
+
+	/* Transfer information */
+	chan->config.vsize = cfg->vsize;
+	chan->config.hsize = cfg->hsize;
+	chan->config.stride = cfg->stride;
+	chan->config.frm_dly = cfg->frm_dly;
+	chan->config.park = cfg->park;
+	chan->config.direction = cfg->direction;
+
+	/* genlock settings */
+	chan->config.gen_lock = cfg->gen_lock;
+	chan->config.master = cfg->master;
+
+	if (cfg->gen_lock && chan->genlock) {
+		dmacr |= XILINX_VDMA_DMACR_GENLOCK_EN;
+		dmacr |= cfg->master << XILINX_VDMA_DMACR_MASTER_SHIFT;
+	}
+
+	chan->config.frm_cnt_en = cfg->frm_cnt_en;
+	if (cfg->park)
+		chan->config.park_frm = cfg->park_frm;
+	else
+		chan->config.park_frm = -1;
+
+	chan->config.coalesc = cfg->coalesc;
+	chan->config.delay = cfg->delay;
+	if (cfg->coalesc <= XILINX_VDMA_DMACR_FRAME_COUNT_MAX) {
+		dmacr |= cfg->coalesc << XILINX_VDMA_DMACR_FRAME_COUNT_SHIFT;
+		chan->config.coalesc = cfg->coalesc;
+	}
+
+	if (cfg->delay <= XILINX_VDMA_DMACR_DELAY_MAX) {
+		dmacr |= cfg->delay << XILINX_VDMA_DMACR_DELAY_SHIFT;
+		chan->config.delay = cfg->delay;
+	}
+
+	/* FSync Source selection */
+	dmacr &= ~XILINX_VDMA_DMACR_FSYNCSRC_MASK;
+	dmacr |= cfg->ext_fsync << XILINX_VDMA_DMACR_FSYNCSRC_SHIFT;
+
+	vdma_ctrl_write(chan, XILINX_VDMA_REG_DMACR, dmacr);
+	return 0;
+}
 
-		vdma_ctrl_write(chan, XILINX_VDMA_REG_DMACR, reg);
+/*
+ * Run-time configuration for Axi VDMA, supports:
+ * . halt the channel
+ * . configure interrupt coalescing and inter-packet delay threshold
+ * . start/stop parking
+ * . enable genlock
+ * . set transfer information using config struct
+ */
+static int xilinx_vdma_device_control(struct dma_chan *dchan,
+				      enum dma_ctrl_cmd cmd, unsigned long arg)
+{
+	struct xilinx_vdma_chan *chan = to_xilinx_chan(dchan);
+
+	switch (cmd) {
+	case DMA_TERMINATE_ALL:
+		xilinx_vdma_terminate_all(chan);
 		return 0;
-	} else
+
+	case DMA_SLAVE_CONFIG:
+		return xilinx_vdma_slave_config(chan,
+					(struct xilinx_vdma_config *)arg);
+
+	default:
 		return -ENXIO;
+	}
 }
 
 /* -----------------------------------------------------------------------------
-- 
1.7.5.4

