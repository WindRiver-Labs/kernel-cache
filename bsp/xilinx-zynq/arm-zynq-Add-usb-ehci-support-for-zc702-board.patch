From 954c513c6e3e03cafa9e37e426704c0f398b5b53 Mon Sep 17 00:00:00 2001
From: Zhong Hongbo <hongbo.zhong@windriver.com>
Date: Thu, 5 Jul 2012 14:48:21 +0800
Subject: [PATCH 17/36] arm/zynq: Add usb ehci support for zc702 board

SDK: yocto-1.2(http://git.yoctoproject.org/cgit.cgi/meta-zynq/)

Signed-off-by: Vlad Lungu <vlad.lungu@windriver.com>
Integrated-by: Hongbo Zhong <hongbo.zhong@windriver.com>
---
 arch/arm/Kconfig                                 |    1 +
 arch/arm/boot/dts/zc702.dtsi                     |    9 +
 arch/arm/mach-zynq/include/mach/xilinx_devices.h |   44 +++
 drivers/usb/host/Kconfig                         |   12 +
 drivers/usb/host/Makefile                        |    1 +
 drivers/usb/host/ehci-hcd.c                      |   52 ++-
 drivers/usb/host/ehci-hub.c                      |   26 +-
 drivers/usb/host/ehci-xilinx-usbps.c             |  455 ++++++++++++++++++++++
 drivers/usb/host/ehci-xilinx-usbps.h             |   33 ++
 drivers/usb/host/ehci.h                          |    4 +
 drivers/usb/host/xusbps-dr-of.c                  |  263 +++++++++++++
 include/linux/usb/xilinx_usbps_otg.h             |  212 ++++++++++
 12 files changed, 1109 insertions(+), 3 deletions(-)
 create mode 100644 drivers/usb/host/ehci-xilinx-usbps.c
 create mode 100644 drivers/usb/host/ehci-xilinx-usbps.h
 create mode 100644 drivers/usb/host/xusbps-dr-of.c
 create mode 100644 include/linux/usb/xilinx_usbps_otg.h

diff --git a/arch/arm/Kconfig b/arch/arm/Kconfig
index aaabb38..4e902fe 100644
--- a/arch/arm/Kconfig
+++ b/arch/arm/Kconfig
@@ -1019,6 +1019,7 @@ config ARCH_ZYNQ
 	select CACHE_L2X0
 	select MIGHT_HAVE_CACHE_L2X0
 	select USE_OF
+	select USB_ARCH_HAS_EHCI if USB_SUPPORT
 	help
 	  Support for Xilinx Zynq ARM Cortex A9 Platform
 endchoice
diff --git a/arch/arm/boot/dts/zc702.dtsi b/arch/arm/boot/dts/zc702.dtsi
index 86b2e5c..a011c8e 100644
--- a/arch/arm/boot/dts/zc702.dtsi
+++ b/arch/arm/boot/dts/zc702.dtsi
@@ -52,6 +52,15 @@
 			clock-frequency-timer2 = <111111111>;
 		};
 
+		/*host,peripheral,otg*/
+		usb@e0002000 {
+			compatible = "xlnx,ps7-usb-1.00.a";
+			reg = <0xe0002000 0x1000>;
+			interrupts = <0x0 0x15 0x4>;
+			dr_mode = "host";
+			phy_type = "ulpi";
+		};
+
 		gpio@e000a000 {
 			compatible = "xlnx,ps7-gpio-1.00.a";
 			reg = <0xe000a000 0x1000>;
diff --git a/arch/arm/mach-zynq/include/mach/xilinx_devices.h b/arch/arm/mach-zynq/include/mach/xilinx_devices.h
index 10b255d..3f1cbbe 100644
--- a/arch/arm/mach-zynq/include/mach/xilinx_devices.h
+++ b/arch/arm/mach-zynq/include/mach/xilinx_devices.h
@@ -30,6 +30,50 @@ struct xi2cps_platform_data {
 	unsigned int input_clk;
 	unsigned int i2c_clk;
 };
+
+/*- PS USB Controller IP -*/
+enum xusbps_usb2_operating_modes {
+	XUSBPS_USB2_MPH_HOST,
+	XUSBPS_USB2_DR_HOST,
+	XUSBPS_USB2_DR_DEVICE,
+	XUSBPS_USB2_DR_OTG,
+};
+
+enum xusbps_usb2_phy_modes {
+	XUSBPS_USB2_PHY_NONE,
+	XUSBPS_USB2_PHY_ULPI,
+	XUSBPS_USB2_PHY_UTMI,
+	XUSBPS_USB2_PHY_UTMI_WIDE,
+	XUSBPS_USB2_PHY_SERIAL,
+};
+
+struct clk;
+struct platform_device;
+
+struct xusbps_usb2_platform_data {
+	/* board specific information */
+	enum xusbps_usb2_operating_modes	operating_mode;
+	enum xusbps_usb2_phy_modes	phy_mode;
+	unsigned int			port_enables;
+	unsigned int			workaround;
+
+	int		(*init)(struct platform_device *);
+	void		(*exit)(struct platform_device *);
+	void __iomem	*regs;		/* ioremap'd register base */
+	struct usb_phy	*otg;
+	int		irq;
+	struct clk	*clk;
+	unsigned	big_endian_mmio:1;
+	unsigned	big_endian_desc:1;
+	unsigned	es:1;		/* need USBMODE:ES */
+	unsigned	le_setup_buf:1;
+	unsigned	have_sysif_regs:1;
+	unsigned	invert_drvvbus:1;
+	unsigned	invert_pwr_fault:1;
+};
+
+#define XUSBPS_USB2_PORT0_ENABLED	0x00000001
+#define XUSBPS_USB2_PORT1_ENABLED	0x00000002
 #endif
 
 #endif /* __KERNEL__ */
diff --git a/drivers/usb/host/Kconfig b/drivers/usb/host/Kconfig
index 7748646..c0c399ba 100644
--- a/drivers/usb/host/Kconfig
+++ b/drivers/usb/host/Kconfig
@@ -130,6 +130,18 @@ config XPS_USB_HCD_XILINX
 		support both high speed and full speed devices, or high speed
 		devices only.
 
+config USB_XUSBPS_DR_OF
+	tristate
+
+config USB_EHCI_XUSBPS
+	bool "Support for Xilinx PS EHCI USB controller"
+	depends on USB_EHCI_HCD && ARCH_ZYNQ
+	select USB_EHCI_ROOT_HUB_TT
+	select USB_XUSBPS_DR_OF if OF
+	---help---
+		Xilinx PS USB host controller core is EHCI compilant and has
+		transaction translator built-in.
+
 config USB_FSL_MPH_DR_OF
 	tristate
 
diff --git a/drivers/usb/host/Makefile b/drivers/usb/host/Makefile
index 0982bcc..17539ff 100644
--- a/drivers/usb/host/Makefile
+++ b/drivers/usb/host/Makefile
@@ -39,5 +39,6 @@ obj-$(CONFIG_USB_ISP1760_HCD)	+= isp1760.o
 obj-$(CONFIG_USB_HWA_HCD)	+= hwa-hc.o
 obj-$(CONFIG_USB_IMX21_HCD)	+= imx21-hcd.o
 obj-$(CONFIG_USB_FSL_MPH_DR_OF)	+= fsl-mph-dr-of.o
+obj-$(CONFIG_USB_XUSBPS_DR_OF)	+= xusbps-dr-of.o
 obj-$(CONFIG_USB_OCTEON2_COMMON) += octeon2-common.o
 obj-$(CONFIG_MIPS_ALCHEMY)	+= alchemy-common.o
diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 6bdfc8d..7c92423 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -478,8 +478,13 @@ static void ehci_turn_off_all_ports(struct ehci_hcd *ehci)
 static void ehci_silence_controller(struct ehci_hcd *ehci)
 {
 	ehci_halt(ehci);
+#ifdef CONFIG_USB_XUSBPS_OTG
+	/* turn off for non-otg port */
+	if (!ehci->transceiver)
+		ehci_turn_off_all_ports(ehci);
+#else
 	ehci_turn_off_all_ports(ehci);
-
+#endif
 	/* make BIOS/etc use companion controller during reboot */
 	ehci_writel(ehci, 0, &ehci->regs->configured_flag);
 
@@ -571,7 +576,13 @@ static void ehci_stop (struct usb_hcd *hcd)
 		ehci_quiesce (ehci);
 
 	ehci_silence_controller(ehci);
+
+#ifdef CONFIG_USB_XUSBPS_OTG
+	if (!ehci->transceiver)
+		ehci_reset(ehci);
+#else
 	ehci_reset (ehci);
+#endif
 	spin_unlock_irq(&ehci->lock);
 
 	remove_sysfs_files(ehci);
@@ -733,6 +744,9 @@ static int ehci_run (struct usb_hcd *hcd)
 	struct ehci_hcd		*ehci = hcd_to_ehci (hcd);
 	u32			temp;
 	u32			hcc_params;
+#if defined(CONFIG_ARCH_ZYNQ)
+	void __iomem *non_ehci = hcd->regs;
+#endif
 
 	hcd->uses_new_polling = 1;
 
@@ -803,6 +817,11 @@ static int ehci_run (struct usb_hcd *hcd)
 	ehci_writel(ehci, INTR_MASK,
 		    &ehci->regs->intr_enable); /* Turn On Interrupts */
 
+#if defined(CONFIG_ARCH_ZYNQ)
+	/* Modifying FIFO Burst Threshold value from 2 to 8 */
+	temp = readl(non_ehci + 0x164);
+	ehci_writel(ehci, 0x00080000, non_ehci + 0x164);
+#endif
 	/* GRR this is run-once init(), being done every time the HC starts.
 	 * So long as they're part of class devices, we can't do it init()
 	 * since the class device isn't created that early.
@@ -854,6 +873,32 @@ static irqreturn_t ehci_irq (struct usb_hcd *hcd)
 
 	status = ehci_readl(ehci, &ehci->regs->status);
 
+#ifdef CONFIG_USB_XUSBPS_OTG
+	if (ehci->transceiver) {
+		/* A device */
+		if (ehci->transceiver->otg->default_a &&
+			(ehci->transceiver->state == OTG_STATE_A_PERIPHERAL)) {
+			spin_unlock(&ehci->lock);
+			return IRQ_NONE;
+		}
+		/* B device */
+		if (!ehci->transceiver->otg->default_a &&
+			((ehci->transceiver->state != OTG_STATE_B_WAIT_ACON) &&
+			(ehci->transceiver->state != OTG_STATE_B_HOST))) {
+			spin_unlock(&ehci->lock);
+			return IRQ_NONE;
+		}
+		/*
+		 * If HABA is set and B-disconnect occurs, don't process
+		 * that interrupt.
+		 */
+		if (ehci_is_TDI(ehci) && tdi_in_host_mode(ehci) == 0) {
+			spin_unlock(&ehci->lock);
+			return IRQ_NONE;
+		}
+	}
+#endif
+
 	/* e.g. cardbus physical eject */
 	if (status == ~(u32) 0) {
 		ehci_dbg (ehci, "device removed\n");
@@ -1300,6 +1345,11 @@ MODULE_LICENSE ("GPL");
 #define XILINX_OF_PLATFORM_DRIVER	ehci_hcd_xilinx_of_driver
 #endif
 
+#ifdef CONFIG_USB_EHCI_XUSBPS
+#include "ehci-xilinx-usbps.c"
+#define	PLATFORM_DRIVER		ehci_xusbps_driver
+#endif
+
 #ifdef CONFIG_PLAT_ORION
 #include "ehci-orion.c"
 #define	PLATFORM_DRIVER		ehci_orion_driver
diff --git a/drivers/usb/host/ehci-hub.c b/drivers/usb/host/ehci-hub.c
index 38fe076..1754aae 100644
--- a/drivers/usb/host/ehci-hub.c
+++ b/drivers/usb/host/ehci-hub.c
@@ -578,7 +578,6 @@ ehci_hub_status_data (struct usb_hcd *hcd, char *buf)
 		mask = PORT_CSC | PORT_PEC | PORT_OCC;
 	else
 		mask = PORT_CSC | PORT_PEC;
-	// PORT_RESUME from hardware ~= PORT_STAT_C_SUSPEND
 
 	/* no hub change reports (bit 0) for now (power, ...) */
 
@@ -872,7 +871,7 @@ static int ehci_hub_control (
 			retval = handshake(ehci, status_reg,
 					PORT_RESET, 0, 1000);
 			if (retval != 0) {
-				ehci_err (ehci, "port %d reset error %d\n",
+				ehci_err(ehci, "port %d reset error %d\n",
 					wIndex + 1, retval);
 				goto error;
 			}
@@ -983,9 +982,23 @@ static int ehci_hub_control (
 			 * Set appropriate bit thus could put phy into low power
 			 * mode if we have hostpc feature
 			 */
+#ifdef CONFIG_USB_XUSBPS_OTG
+			if (ehci->transceiver &&
+				(hcd->self.otg_port == (wIndex + 1)) &&
+				(hcd->self.b_hnp_enable ||
+					 hcd->self.is_b_host))
+				ehci->start_hnp(ehci);
+			else {
+				temp &= ~PORT_WKCONN_E;
+				temp |= PORT_WKDISC_E | PORT_WKOC_E;
+				ehci_writel(ehci, temp | PORT_SUSPEND,
+					    status_reg);
+			}
+#else
 			temp &= ~PORT_WKCONN_E;
 			temp |= PORT_WKDISC_E | PORT_WKOC_E;
 			ehci_writel(ehci, temp | PORT_SUSPEND, status_reg);
+#endif
 			if (hostpc_reg) {
 				spin_unlock_irqrestore(&ehci->lock, flags);
 				msleep(5);/* 5ms for HCD enter low pwr mode */
@@ -1001,9 +1014,18 @@ static int ehci_hub_control (
 			set_bit(wIndex, &ehci->suspended_ports);
 			break;
 		case USB_PORT_FEAT_POWER:
+#ifdef CONFIG_USB_XUSBPS_OTG
+			/* Check if otg is enabled */
+			if (!ehci->transceiver) {
+				if (HCS_PPC(ehci->hcs_params))
+					ehci_writel(ehci, temp | PORT_POWER,
+							status_reg);
+			}
+#else
 			if (HCS_PPC (ehci->hcs_params))
 				ehci_writel(ehci, temp | PORT_POWER,
 						status_reg);
+#endif
 			break;
 		case USB_PORT_FEAT_RESET:
 			if (temp & PORT_RESUME)
diff --git a/drivers/usb/host/ehci-xilinx-usbps.c b/drivers/usb/host/ehci-xilinx-usbps.c
new file mode 100644
index 0000000..993b245
--- /dev/null
+++ b/drivers/usb/host/ehci-xilinx-usbps.c
@@ -0,0 +1,455 @@
+/*
+ * Xilinx PS USB Host Controller Driver.
+ *
+ * Copyright (C) 2011 Xilinx, Inc.
+ *
+ * This file is based on ehci-fsl.c file with few minor modifications
+ * to support Xilinx PS USB controller.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+ * Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/delay.h>
+#include <linux/pm.h>
+#include <linux/platform_device.h>
+#include <linux/usb/otg.h>
+#include <linux/usb/xilinx_usbps_otg.h>
+#include <mach/xilinx_devices.h>
+
+#include "ehci-xilinx-usbps.h"
+
+#ifdef CONFIG_USB_XUSBPS_OTG
+/********************************************************************
+ * OTG related functions
+ ********************************************************************/
+static int ehci_xusbps_reinit(struct ehci_hcd *ehci);
+
+/* This connection event is useful when a OTG test device is connected.
+   In that case, the device connect notify event will not be generated
+   since the device will be suspended before complete enumeration.
+*/
+static int ehci_xusbps_update_device(struct usb_hcd *hcd, struct usb_device
+		*udev)
+{
+	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
+	struct xusbps_otg *xotg = xceiv_to_xotg(ehci->transceiver);
+
+	if (udev->portnum == hcd->self.otg_port) {
+		/* HNP test device */
+		if ((le16_to_cpu(udev->descriptor.idVendor) == 0x1a0a &&
+			le16_to_cpu(udev->descriptor.idProduct) == 0xbadd)) {
+			if (xotg->phy.otg->default_a == 1)
+				xotg->hsm.b_conn = 1;
+			else
+				xotg->hsm.a_conn = 1;
+			xusbps_update_transceiver();
+		}
+	}
+	return 0;
+}
+
+static void ehci_xusbps_start_hnp(struct ehci_hcd *ehci)
+{
+	const unsigned	port = ehci_to_hcd(ehci)->self.otg_port - 1;
+	unsigned long	flags;
+	u32 portsc;
+
+	local_irq_save(flags);
+	portsc = ehci_readl(ehci, &ehci->regs->port_status[port]);
+	portsc |= PORT_SUSPEND;
+	ehci_writel(ehci, portsc, &ehci->regs->port_status[port]);
+	local_irq_restore(flags);
+
+	otg_start_hnp(ehci->transceiver->otg);
+}
+
+static int ehci_xusbps_otg_start_host(struct usb_phy *otg)
+{
+	struct usb_hcd	*hcd = bus_to_hcd(otg->otg->host);
+	struct xusbps_otg *xotg =
+			xceiv_to_xotg(hcd_to_ehci(hcd)->transceiver);
+
+	usb_add_hcd(hcd, xotg->irq, IRQF_SHARED | IRQF_DISABLED);
+	return 0;
+}
+
+static int ehci_xusbps_otg_stop_host(struct usb_phy *otg)
+{
+	struct usb_hcd	*hcd = bus_to_hcd(otg->otg->host);
+
+	usb_remove_hcd(hcd);
+	return 0;
+}
+#endif
+
+/* configure so an HC device and id are always provided */
+/* always called with process context; sleeping is OK */
+
+/**
+ * usb_hcd_xusbps_probe - initialize XUSBPS-based HCDs
+ * @driver: Driver to be used for this HCD
+ * @pdev: USB Host Controller being probed
+ * Context: !in_interrupt()
+ *
+ * Allocates basic resources for this USB host controller.
+ *
+ */
+static int usb_hcd_xusbps_probe(const struct hc_driver *driver,
+			     struct platform_device *pdev)
+{
+	struct xusbps_usb2_platform_data *pdata;
+	struct usb_hcd *hcd;
+	int irq;
+	int retval;
+#ifdef CONFIG_USB_XUSBPS_OTG
+	struct xusbps_otg *xotg;
+	struct ehci_hcd *ehci;
+#endif
+
+	pr_debug("initializing XUSBPS-SOC USB Controller\n");
+
+	/* Need platform data for setup */
+	pdata = (struct xusbps_usb2_platform_data *)pdev->dev.platform_data;
+	if (!pdata) {
+		dev_err(&pdev->dev,
+			"No platform data for %s.\n", dev_name(&pdev->dev));
+		return -ENODEV;
+	}
+
+	/*
+	 * This is a host mode driver, verify that we're supposed to be
+	 * in host mode.
+	 */
+	if (!((pdata->operating_mode == XUSBPS_USB2_DR_HOST) ||
+	      (pdata->operating_mode == XUSBPS_USB2_MPH_HOST) ||
+	      (pdata->operating_mode == XUSBPS_USB2_DR_OTG))) {
+		dev_err(&pdev->dev, "Non Host Mode configured for %s. Wrong \
+				driver linked.\n", dev_name(&pdev->dev));
+		return -ENODEV;
+	}
+
+	hcd = usb_create_hcd(driver, &pdev->dev, dev_name(&pdev->dev));
+	if (!hcd) {
+		retval = -ENOMEM;
+		goto err1;
+	}
+
+	irq = pdata->irq;
+	hcd->regs = pdata->regs;
+
+	if (hcd->regs == NULL) {
+		dev_dbg(&pdev->dev, "error mapping memory\n");
+		retval = -EFAULT;
+		goto err2;
+	}
+
+	if (pdata->otg)
+		hcd->self.otg_port = 1;
+	/*
+	 * do platform specific init: check the clock, grab/config pins, etc.
+	 */
+	if (pdata->init && pdata->init(pdev)) {
+		retval = -ENODEV;
+		goto err2;
+	}
+
+#ifdef CONFIG_USB_XUSBPS_OTG
+	ehci = hcd_to_ehci(hcd);
+	if (pdata->otg) {
+		ehci->transceiver = pdata->otg;
+		retval = otg_set_host(ehci->transceiver->otg,
+				&ehci_to_hcd(ehci)->self);
+		if (retval)
+			return retval;
+		xotg = xceiv_to_xotg(ehci->transceiver);
+		ehci->start_hnp = ehci_xusbps_start_hnp;
+		xotg->start_host = ehci_xusbps_otg_start_host;
+		xotg->stop_host = ehci_xusbps_otg_stop_host;
+		/* inform otg driver about host driver */
+		xusbps_update_transceiver();
+	} else {
+		retval = usb_add_hcd(hcd, irq, IRQF_DISABLED | IRQF_SHARED);
+		if (retval != 0)
+			goto err2;
+	}
+#else
+	/* Don't need to set host mode here. It will be done by tdi_reset() */
+	retval = usb_add_hcd(hcd, irq, IRQF_DISABLED | IRQF_SHARED);
+	if (retval != 0)
+		goto err2;
+#endif
+	return retval;
+
+err2:
+	usb_put_hcd(hcd);
+err1:
+	dev_err(&pdev->dev, "init %s fail, %d\n", dev_name(&pdev->dev), retval);
+	if (pdata->exit)
+		pdata->exit(pdev);
+
+	return retval;
+}
+
+/* may be called without controller electrically present */
+/* may be called with controller, bus, and devices active */
+
+/**
+ * usb_hcd_xusbps_remove - shutdown processing for XUSBPS-based HCDs
+ * @dev: USB Host Controller being removed
+ * Context: !in_interrupt()
+ *
+ * Reverses the effect of usb_hcd_xusbps_probe().
+ *
+ */
+static void usb_hcd_xusbps_remove(struct usb_hcd *hcd,
+			       struct platform_device *pdev)
+{
+	struct xusbps_usb2_platform_data *pdata = pdev->dev.platform_data;
+
+	usb_remove_hcd(hcd);
+
+	/*
+	 * do platform specific un-initialization:
+	 * release iomux pins, disable clock, etc.
+	 */
+	if (pdata->exit)
+		pdata->exit(pdev);
+	usb_put_hcd(hcd);
+}
+
+static void ehci_xusbps_setup_phy(struct ehci_hcd *ehci,
+			       enum xusbps_usb2_phy_modes phy_mode,
+			       unsigned int port_offset)
+{
+	u32 portsc;
+
+	portsc = ehci_readl(ehci, &ehci->regs->port_status[port_offset]);
+	portsc &= ~(PORT_PTS_MSK | PORT_PTS_PTW);
+
+	switch (phy_mode) {
+	case XUSBPS_USB2_PHY_ULPI:
+		portsc |= PORT_PTS_ULPI;
+		break;
+	case XUSBPS_USB2_PHY_SERIAL:
+		portsc |= PORT_PTS_SERIAL;
+		break;
+	case XUSBPS_USB2_PHY_UTMI_WIDE:
+		portsc |= PORT_PTS_PTW;
+		/* fall through */
+	case XUSBPS_USB2_PHY_UTMI:
+		portsc |= PORT_PTS_UTMI;
+		break;
+	case XUSBPS_USB2_PHY_NONE:
+		break;
+	}
+	ehci_writel(ehci, portsc, &ehci->regs->port_status[port_offset]);
+}
+
+static void ehci_xusbps_usb_setup(struct ehci_hcd *ehci)
+{
+	struct usb_hcd *hcd = ehci_to_hcd(ehci);
+	struct xusbps_usb2_platform_data *pdata;
+
+	pdata = hcd->self.controller->platform_data;
+
+	if ((pdata->operating_mode == XUSBPS_USB2_DR_HOST) ||
+			(pdata->operating_mode == XUSBPS_USB2_DR_OTG))
+		ehci_xusbps_setup_phy(ehci, pdata->phy_mode, 0);
+
+	if (pdata->operating_mode == XUSBPS_USB2_MPH_HOST) {
+		if (pdata->port_enables & XUSBPS_USB2_PORT0_ENABLED)
+			ehci_xusbps_setup_phy(ehci, pdata->phy_mode, 0);
+		if (pdata->port_enables & XUSBPS_USB2_PORT1_ENABLED)
+			ehci_xusbps_setup_phy(ehci, pdata->phy_mode, 1);
+	}
+}
+
+/* called after powerup, by probe or system-pm "wakeup" */
+static int ehci_xusbps_reinit(struct ehci_hcd *ehci)
+{
+	ehci_xusbps_usb_setup(ehci);
+#ifdef CONFIG_USB_XUSBPS_OTG
+	/* Don't turn off port power in OTG mode */
+	if (!ehci->transceiver)
+#endif
+		ehci_port_power(ehci, 0);
+
+	return 0;
+}
+
+struct ehci_xusbps {
+	struct ehci_hcd	ehci;
+
+#ifdef CONFIG_PM
+	/* Saved USB PHY settings, need to restore after deep sleep. */
+	u32 usb_ctrl;
+#endif
+};
+
+/* called during probe() after chip reset completes */
+static int ehci_xusbps_setup(struct usb_hcd *hcd)
+{
+	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
+	int retval;
+
+	/* EHCI registers start at offset 0x100 */
+	ehci->caps = hcd->regs + 0x100;
+	ehci->regs = hcd->regs + 0x100 +
+	    HC_LENGTH(ehci, ehci_readl(ehci, &ehci->caps->hc_capbase));
+	dbg_hcs_params(ehci, "reset");
+	dbg_hcc_params(ehci, "reset");
+
+	/* cache this readonly data; minimize chip reads */
+	ehci->hcs_params = ehci_readl(ehci, &ehci->caps->hcs_params);
+
+	hcd->has_tt = 1;
+
+	retval = ehci_halt(ehci);
+	if (retval)
+		return retval;
+
+	/* data structure init */
+	retval = ehci_init(hcd);
+	if (retval)
+		return retval;
+
+	ehci->sbrn = 0x20;
+
+	ehci_reset(ehci);
+
+	retval = ehci_xusbps_reinit(ehci);
+	return retval;
+}
+
+#ifdef CONFIG_PM
+
+static int ehci_xusbps_drv_suspend(struct device *dev)
+{
+	struct usb_hcd *hcd = dev_get_drvdata(dev);
+
+	ehci_prepare_ports_for_controller_suspend(hcd_to_ehci(hcd),
+			device_may_wakeup(dev));
+
+	return 0;
+}
+
+static int ehci_xusbps_drv_resume(struct device *dev)
+{
+	struct usb_hcd *hcd = dev_get_drvdata(dev);
+	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
+
+	ehci_prepare_ports_for_controller_resume(ehci);
+
+	usb_root_hub_lost_power(hcd->self.root_hub);
+
+	ehci_reset(ehci);
+	ehci_xusbps_reinit(ehci);
+
+	return 0;
+}
+
+static int ehci_xusbps_drv_restore(struct device *dev)
+{
+	struct usb_hcd *hcd = dev_get_drvdata(dev);
+
+	usb_root_hub_lost_power(hcd->self.root_hub);
+	return 0;
+}
+
+static struct dev_pm_ops ehci_xusbps_pm_ops = {
+	.suspend = ehci_xusbps_drv_suspend,
+	.resume = ehci_xusbps_drv_resume,
+	.restore = ehci_xusbps_drv_restore,
+};
+
+#define EHCI_XUSBPS_PM_OPS		(&ehci_xusbps_pm_ops)
+#else
+#define EHCI_XUSBPS_PM_OPS		NULL
+#endif /* CONFIG_PM */
+
+static const struct hc_driver ehci_xusbps_hc_driver = {
+	.description = hcd_name,
+	.product_desc = "Xilinx PS USB EHCI Host Controller",
+	.hcd_priv_size = sizeof(struct ehci_xusbps),
+
+	/*
+	 * generic hardware linkage
+	 */
+	.irq = ehci_irq,
+	.flags = HCD_USB2 | HCD_MEMORY,
+
+	/*
+	 * basic lifecycle operations
+	 */
+	.reset = ehci_xusbps_setup,
+	.start = ehci_run,
+	.stop = ehci_stop,
+	.shutdown = ehci_shutdown,
+
+	/*
+	 * managing i/o requests and associated device resources
+	 */
+	.urb_enqueue = ehci_urb_enqueue,
+	.urb_dequeue = ehci_urb_dequeue,
+	.endpoint_disable = ehci_endpoint_disable,
+	.endpoint_reset = ehci_endpoint_reset,
+
+	/*
+	 * scheduling support
+	 */
+	.get_frame_number = ehci_get_frame,
+
+	/*
+	 * root hub support
+	 */
+	.hub_status_data = ehci_hub_status_data,
+	.hub_control = ehci_hub_control,
+	.bus_suspend = ehci_bus_suspend,
+	.bus_resume = ehci_bus_resume,
+	.relinquish_port = ehci_relinquish_port,
+	.port_handed_over = ehci_port_handed_over,
+
+	.clear_tt_buffer_complete = ehci_clear_tt_buffer_complete,
+#ifdef CONFIG_USB_XUSBPS_OTG
+	.update_device = ehci_xusbps_update_device,
+#endif
+};
+
+static int ehci_xusbps_drv_probe(struct platform_device *pdev)
+{
+	if (usb_disabled())
+		return -ENODEV;
+
+	/* FIXME we only want one one probe() not two */
+	return usb_hcd_xusbps_probe(&ehci_xusbps_hc_driver, pdev);
+}
+
+static int ehci_xusbps_drv_remove(struct platform_device *pdev)
+{
+	struct usb_hcd *hcd = platform_get_drvdata(pdev);
+
+	/* FIXME we only want one one remove() not two */
+	usb_hcd_xusbps_remove(hcd, pdev);
+	return 0;
+}
+
+MODULE_ALIAS("platform:xusbps-ehci");
+
+static struct platform_driver ehci_xusbps_driver = {
+	.probe = ehci_xusbps_drv_probe,
+	.remove = ehci_xusbps_drv_remove,
+	.shutdown = usb_hcd_platform_shutdown,
+	.driver = {
+		.name = "xusbps-ehci",
+		.pm = EHCI_XUSBPS_PM_OPS,
+	},
+};
diff --git a/drivers/usb/host/ehci-xilinx-usbps.h b/drivers/usb/host/ehci-xilinx-usbps.h
new file mode 100644
index 0000000..bb0f2d4
--- /dev/null
+++ b/drivers/usb/host/ehci-xilinx-usbps.h
@@ -0,0 +1,33 @@
+/*
+ * Xilinx PS USB Host Controller Driver Header file.
+ *
+ * Copyright (C) 2011 Xilinx, Inc.
+ *
+ * This file is based on ehci-fsl.h file with few minor modifications
+ * to support Xilinx PS USB controller.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+ * Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef _EHCI_XILINX_XUSBPS_H
+#define _EHCI_XILINX_XUSBPS_H
+
+#include <linux/usb/xilinx_usbps_otg.h>
+
+/* offsets for the non-ehci registers in the XUSBPS SOC USB controller */
+#define XUSBPS_SOC_USB_ULPIVP	0x170
+#define XUSBPS_SOC_USB_PORTSC1	0x184
+#define PORT_PTS_MSK		(3<<30)
+#define PORT_PTS_UTMI		(0<<30)
+#define PORT_PTS_ULPI		(2<<30)
+#define	PORT_PTS_SERIAL		(3<<30)
+#define PORT_PTS_PTW		(1<<28)
+#define XUSBPS_SOC_USB_PORTSC2	0x188
+
+#endif				/* _EHCI_XILINX_XUSBPS_H */
diff --git a/drivers/usb/host/ehci.h b/drivers/usb/host/ehci.h
index 2694ed6..7e21a81 100644
--- a/drivers/usb/host/ehci.h
+++ b/drivers/usb/host/ehci.h
@@ -120,6 +120,10 @@ struct ehci_hcd {			/* one per controller */
 	unsigned long		resuming_ports;		/* which ports have
 			started to resume */
 
+#ifdef CONFIG_USB_XUSBPS_OTG
+	void (*start_hnp)(struct ehci_hcd *ehci);
+#endif
+
 	/* per-HC memory pools (could be per-bus, but ...) */
 	struct dma_pool		*qh_pool;	/* qh per active urb */
 	struct dma_pool		*qtd_pool;	/* one or more per qh */
diff --git a/drivers/usb/host/xusbps-dr-of.c b/drivers/usb/host/xusbps-dr-of.c
new file mode 100644
index 0000000..6f3dc1d
--- /dev/null
+++ b/drivers/usb/host/xusbps-dr-of.c
@@ -0,0 +1,263 @@
+/*
+ * Xilinx PS USB Driver for device tree support.
+ *
+ * Copyright (C) 2011 Xilinx, Inc.
+ *
+ * This file is based on fsl-mph-dr-of.c file with few minor modifications
+ * to support Xilinx PS USB controller.
+ *
+ * Setup platform devices needed by the dual-role USB controller modules
+ * based on the description in flat device tree.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+ * Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#include <linux/kernel.h>
+#include <linux/platform_device.h>
+#include <linux/err.h>
+#include <linux/io.h>
+#include <linux/of_platform.h>
+#include <linux/clk.h>
+#include <linux/string.h>
+#include <linux/export.h>
+#include <linux/module.h>
+#include <mach/xilinx_devices.h>
+
+static u64 dma_mask = 0xFFFFFFF0;
+
+struct xusbps_dev_data {
+	char *dr_mode;		/* controller mode */
+	char *drivers[3];	/* drivers to instantiate for this mode */
+	enum xusbps_usb2_operating_modes op_mode;	/* operating mode */
+};
+
+struct xusbps_dev_data dr_mode_data[] __devinitdata = {
+	{
+		.dr_mode = "host",
+		.drivers = { "xusbps-ehci", NULL, NULL, },
+		.op_mode = XUSBPS_USB2_DR_HOST,
+	},
+	{
+		.dr_mode = "otg",
+		.drivers = { "xusbps-otg", "xusbps-ehci", "xusbps-udc", },
+		.op_mode = XUSBPS_USB2_DR_OTG,
+	},
+	{
+		.dr_mode = "peripheral",
+		.drivers = { "xusbps-udc", NULL, NULL, },
+		.op_mode = XUSBPS_USB2_DR_DEVICE,
+	},
+};
+
+struct xusbps_dev_data * __devinit get_dr_mode_data(struct device_node *np)
+{
+	const unsigned char *prop;
+	int i;
+
+	prop = of_get_property(np, "dr_mode", NULL);
+	if (prop) {
+		for (i = 0; i < ARRAY_SIZE(dr_mode_data); i++) {
+			if (!strcmp(prop, dr_mode_data[i].dr_mode))
+				return &dr_mode_data[i];
+		}
+	}
+	pr_warn("%s: Invalid 'dr_mode' property, fallback to host mode\n",
+		np->full_name);
+	return &dr_mode_data[0]; /* mode not specified, use host */
+}
+
+static enum xusbps_usb2_phy_modes __devinit determine_usb_phy(const char
+					*phy_type)
+{
+	if (!phy_type)
+		return XUSBPS_USB2_PHY_NONE;
+	if (!strcasecmp(phy_type, "ulpi"))
+		return XUSBPS_USB2_PHY_ULPI;
+	if (!strcasecmp(phy_type, "utmi"))
+		return XUSBPS_USB2_PHY_UTMI;
+	if (!strcasecmp(phy_type, "utmi_wide"))
+		return XUSBPS_USB2_PHY_UTMI_WIDE;
+	if (!strcasecmp(phy_type, "serial"))
+		return XUSBPS_USB2_PHY_SERIAL;
+
+	return XUSBPS_USB2_PHY_NONE;
+}
+
+struct platform_device * __devinit xusbps_device_register(
+					struct platform_device *ofdev,
+					struct xusbps_usb2_platform_data *pdata,
+					const char *name, int id)
+{
+	struct platform_device *pdev;
+	const struct resource *res = ofdev->resource;
+	unsigned int num = ofdev->num_resources;
+	struct xusbps_usb2_platform_data *pdata1;
+	int retval;
+
+	pdev = platform_device_alloc(name, id);
+	if (!pdev) {
+		retval = -ENOMEM;
+		goto error;
+	}
+
+	pdev->dev.parent = &ofdev->dev;
+
+	pdev->dev.coherent_dma_mask = ofdev->dev.coherent_dma_mask;
+	pdev->dev.dma_mask = &dma_mask;
+
+	retval = platform_device_add_data(pdev, pdata, sizeof(*pdata));
+	if (retval)
+		goto error;
+
+	if (num) {
+		retval = platform_device_add_resources(pdev, res, num);
+		if (retval)
+			goto error;
+	}
+
+	retval = platform_device_add(pdev);
+	if (retval)
+		goto error;
+
+	pdata1 = pdev->dev.platform_data;
+	/* Copy the otg transceiver pointer into host/device platform data */
+	if (pdata1->otg)
+		pdata->otg = pdata1->otg;
+
+	return pdev;
+
+error:
+	platform_device_put(pdev);
+	return ERR_PTR(retval);
+}
+
+static const struct of_device_id xusbps_dr_of_match[];
+
+static int __devinit xusbps_dr_of_probe(struct platform_device *ofdev)
+{
+	struct device_node *np = ofdev->dev.of_node;
+	struct platform_device *usb_dev;
+	struct xusbps_usb2_platform_data data, *pdata;
+	struct xusbps_dev_data *dev_data;
+	const struct of_device_id *match;
+	const unsigned char *prop;
+	static unsigned int idx;
+	struct resource *res;
+	int i;
+
+	if (!of_device_is_available(np))
+		return -ENODEV;
+
+	match = of_match_device(xusbps_dr_of_match, &ofdev->dev);
+	if (!match)
+		return -ENODEV;
+
+	pdata = &data;
+	if (match->data)
+		memcpy(pdata, match->data, sizeof(data));
+	else
+		memset(pdata, 0, sizeof(data));
+
+	res = platform_get_resource(ofdev, IORESOURCE_IRQ, 0);
+	if (!res) {
+		dev_err(&ofdev->dev,
+			"IRQ not found\n");
+		return -ENODEV;
+	}
+	pdata->irq = res->start;
+
+	res = platform_get_resource(ofdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		dev_err(&ofdev->dev,
+			"Register base not found");
+		return -ENODEV;
+	}
+
+	if (!request_mem_region(res->start, res->end - res->start + 1,
+						ofdev->name)) {
+		dev_dbg(&ofdev->dev, "Controller already in use\n");
+		return -EBUSY;
+	}
+
+	pdata->regs = ioremap(res->start, res->end - res->start + 1);
+	if (!pdata->regs) {
+		dev_err(&ofdev->dev, "unable to iomap registers\n");
+		release_mem_region(res->start, resource_size(res));
+		return -EFAULT;
+	}
+
+	dev_data = get_dr_mode_data(np);
+	pdata->operating_mode = dev_data->op_mode;
+
+	prop = of_get_property(np, "phy_type", NULL);
+	pdata->phy_mode = determine_usb_phy(prop);
+
+	for (i = 0; i < ARRAY_SIZE(dev_data->drivers); i++) {
+		if (!dev_data->drivers[i])
+			continue;
+		usb_dev = xusbps_device_register(ofdev, pdata,
+					dev_data->drivers[i], idx);
+		if (IS_ERR(usb_dev)) {
+			dev_err(&ofdev->dev, "Can't register usb device\n");
+			return PTR_ERR(usb_dev);
+		}
+	}
+	idx++;
+	return 0;
+}
+
+static int __devexit __unregister_subdev(struct device *dev, void *d)
+{
+	platform_device_unregister(to_platform_device(dev));
+	return 0;
+}
+
+static int __devexit xusbps_dr_of_remove(struct platform_device *ofdev)
+{
+	struct resource *res;
+
+	res = platform_get_resource(ofdev, IORESOURCE_MEM, 0);
+	release_mem_region(res->start, resource_size(res));
+
+	device_for_each_child(&ofdev->dev, NULL, __unregister_subdev);
+	return 0;
+}
+
+static struct xusbps_usb2_platform_data xusbps_pdata;
+
+static const struct of_device_id xusbps_dr_of_match[] = {
+	{ .compatible = "xlnx,ps7-usb-1.00.a", .data = &xusbps_pdata, },
+	{},
+};
+
+static struct platform_driver xusbps_dr_driver = {
+	.driver = {
+		.name = "xusbps-dr",
+		.owner = THIS_MODULE,
+		.of_match_table = xusbps_dr_of_match,
+	},
+	.probe	= xusbps_dr_of_probe,
+	.remove	= __devexit_p(xusbps_dr_of_remove),
+};
+
+static int __init xusbps_dr_init(void)
+{
+	return platform_driver_register(&xusbps_dr_driver);
+}
+module_init(xusbps_dr_init);
+
+static void __exit xusbps_dr_exit(void)
+{
+	platform_driver_unregister(&xusbps_dr_driver);
+}
+module_exit(xusbps_dr_exit);
+
+MODULE_DESCRIPTION("XUSBPS DR OF devices driver");
+MODULE_AUTHOR("Xilinx");
+MODULE_LICENSE("GPL");
diff --git a/include/linux/usb/xilinx_usbps_otg.h b/include/linux/usb/xilinx_usbps_otg.h
new file mode 100644
index 0000000..bed88dc
--- /dev/null
+++ b/include/linux/usb/xilinx_usbps_otg.h
@@ -0,0 +1,212 @@
+/*
+ * Xilinx PS USB OTG Driver Header file.
+ *
+ * Copyright 2011 Xilinx, Inc.
+ *
+ * This file is based on langwell_otg.h file with few minor modifications
+ * to support Xilinx PS USB controller.
+ *
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License version 2 as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+ * Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef __XILINX_XUSBPS_OTG_H
+#define __XILINX_XUSBPS_OTG_H
+
+#define CI_USBCMD		0x140
+#	define USBCMD_RST		BIT(1)
+#	define USBCMD_RS		BIT(0)
+#define CI_USBSTS		0x144
+#	define USBSTS_SLI		BIT(8)
+#	define USBSTS_URI		BIT(6)
+#	define USBSTS_PCI		BIT(2)
+#define CI_PORTSC1		0x184
+#	define PORTSC_PP		BIT(12)
+#	define PORTSC_LS		(BIT(11) | BIT(10))
+#	define PORTSC_SUSP		BIT(7)
+#	define PORTSC_CCS		BIT(0)
+#define CI_OTGSC		0x1a4
+#	define OTGSC_DPIE		BIT(30)
+#	define OTGSC_1MSE		BIT(29)
+#	define OTGSC_BSEIE		BIT(28)
+#	define OTGSC_BSVIE		BIT(27)
+#	define OTGSC_ASVIE		BIT(26)
+#	define OTGSC_AVVIE		BIT(25)
+#	define OTGSC_IDIE		BIT(24)
+#	define OTGSC_DPIS		BIT(22)
+#	define OTGSC_1MSS		BIT(21)
+#	define OTGSC_BSEIS		BIT(20)
+#	define OTGSC_BSVIS		BIT(19)
+#	define OTGSC_ASVIS		BIT(18)
+#	define OTGSC_AVVIS		BIT(17)
+#	define OTGSC_IDIS		BIT(16)
+#	define OTGSC_DPS		BIT(14)
+#	define OTGSC_1MST		BIT(13)
+#	define OTGSC_BSE		BIT(12)
+#	define OTGSC_BSV		BIT(11)
+#	define OTGSC_ASV		BIT(10)
+#	define OTGSC_AVV		BIT(9)
+#	define OTGSC_ID			BIT(8)
+#	define OTGSC_HABA		BIT(7)
+#	define OTGSC_HADP		BIT(6)
+#	define OTGSC_IDPU		BIT(5)
+#	define OTGSC_DP			BIT(4)
+#	define OTGSC_OT			BIT(3)
+#	define OTGSC_HAAR		BIT(2)
+#	define OTGSC_VC			BIT(1)
+#	define OTGSC_VD			BIT(0)
+#	define OTGSC_INTEN_MASK		(0x7f << 24)
+#	define OTGSC_INT_MASK		(0x5f << 24)
+#	define OTGSC_INTSTS_MASK	(0x7f << 16)
+#define CI_USBMODE		0x1a8
+#	define USBMODE_CM		(BIT(1) | BIT(0))
+#	define USBMODE_IDLE		0
+#	define USBMODE_DEVICE		0x2
+#	define USBMODE_HOST		0x3
+
+#define INTR_DUMMY_MASK (USBSTS_SLI | USBSTS_URI | USBSTS_PCI)
+
+enum xusbps_otg_timer_type {
+	TA_WAIT_VRISE_TMR,
+	TA_WAIT_BCON_TMR,
+	TA_AIDL_BDIS_TMR,
+	TB_ASE0_BRST_TMR,
+	TB_SE0_SRP_TMR,
+	TB_SRP_INIT_TMR,
+	TB_SRP_FAIL_TMR,
+	TB_BUS_SUSPEND_TMR
+};
+
+#define TA_WAIT_VRISE	100
+#define TA_WAIT_BCON	30000
+#define TA_AIDL_BDIS	15000
+#define TB_ASE0_BRST	5000
+#define TB_SE0_SRP	2
+#define TB_SRP_INIT	100
+#define TB_SRP_FAIL	5500
+#define TB_BUS_SUSPEND	500
+
+struct xusbps_otg_timer {
+	unsigned long expires;	/* Number of count increase to timeout */
+	unsigned long count;	/* Tick counter */
+	void (*function)(unsigned long);	/* Timeout function */
+	unsigned long data;	/* Data passed to function */
+	struct list_head list;
+};
+
+/* This is a common data structure to
+ * save values of the OTG state machine */
+struct otg_hsm {
+	/* Input */
+	int a_bus_resume;
+	int a_bus_suspend;
+	int a_conn;
+	int a_sess_vld;
+	int a_srp_det;
+	int a_vbus_vld;
+	int b_bus_resume;
+	int b_bus_suspend;
+	int b_conn;
+	int b_se0_srp;
+	int b_ssend_srp;
+	int b_sess_end;
+	int b_sess_vld;
+	int id;
+/* id values */
+#define ID_B		0x05
+#define ID_A		0x04
+#define ID_ACA_C	0x03
+#define ID_ACA_B	0x02
+#define ID_ACA_A	0x01
+	int power_up;
+	int adp_change;
+	int test_device;
+
+	/* Internal variables */
+	int a_set_b_hnp_en;
+	int b_srp_done;
+	int b_hnp_enable;
+	int hnp_poll_enable;
+
+	/* Timeout indicator for timers */
+	int a_wait_vrise_tmout;
+	int a_wait_bcon_tmout;
+	int a_aidl_bdis_tmout;
+	int a_bidl_adis_tmout;
+	int a_bidl_adis_tmr;
+	int a_wait_vfall_tmout;
+	int b_ase0_brst_tmout;
+	int b_bus_suspend_tmout;
+	int b_srp_init_tmout;
+	int b_srp_fail_tmout;
+	int b_srp_fail_tmr;
+	int b_adp_sense_tmout;
+
+	/* Informative variables */
+	int a_bus_drop;
+	int a_bus_req;
+	int a_clr_err;
+	int b_bus_req;
+	int a_suspend_req;
+	int b_bus_suspend_vld;
+
+	/* Output */
+	int drv_vbus;
+	int loc_conn;
+	int loc_sof;
+
+	/* Others */
+	int vbus_srp_up;
+};
+
+struct xusbps_otg {
+	struct usb_phy phy;
+
+	struct otg_hsm hsm;
+
+	/* base address */
+	void __iomem *base;
+
+	/* irq */
+	int irq;
+
+	/* atomic notifier for interrupt context */
+	struct atomic_notifier_head	otg_notifier;
+
+	/* start/stop USB Host function */
+	int	(*start_host)(struct usb_phy *otg);
+	int	(*stop_host)(struct usb_phy *otg);
+
+	/* start/stop USB Peripheral function */
+	int	(*start_peripheral)(struct usb_phy *otg);
+	int	(*stop_peripheral)(struct usb_phy *otg);
+
+	struct device			*dev;
+
+	unsigned			region;
+
+	struct work_struct		work;
+	struct workqueue_struct		*qwork;
+	struct timer_list		hsm_timer;
+
+	spinlock_t			lock;
+	spinlock_t			wq_lock;
+
+	struct notifier_block		xotg_notifier;
+};
+
+static inline
+struct xusbps_otg *xceiv_to_xotg(struct usb_phy *otg)
+{
+	return container_of(otg, struct xusbps_otg, phy);
+}
+
+void xusbps_update_transceiver(void);
+void xusbps1_update_transceiver(void);
+
+#endif /* __XILINX_XUSBPS_OTG_H__ */
-- 
1.7.9.7

