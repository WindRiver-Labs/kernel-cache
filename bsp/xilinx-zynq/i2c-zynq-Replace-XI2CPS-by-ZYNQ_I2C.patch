From 420f33375742e2d6c8f202d28d882187ad158388 Mon Sep 17 00:00:00 2001
From: Michal Simek <michal.simek@xilinx.com>
Date: Wed, 27 Nov 2013 14:22:33 +0100
Subject: [PATCH 166/509] i2c: zynq: Replace XI2CPS by ZYNQ_I2C

https://github.com/analogdevicesinc/linux.git xcomm_zynq
commit 7852e2d576604843b4ac9563ddc6ada77437913b

The same for lower case too.

Signed-off-by: Michal Simek <michal.simek@xilinx.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 drivers/i2c/busses/i2c-zynq.c |  404 +++++++++++++++++++++--------------------
 1 files changed, 208 insertions(+), 196 deletions(-)

diff --git a/drivers/i2c/busses/i2c-zynq.c b/drivers/i2c/busses/i2c-zynq.c
index 1120ebc..a752fce 100644
--- a/drivers/i2c/busses/i2c-zynq.c
+++ b/drivers/i2c/busses/i2c-zynq.c
@@ -41,27 +41,29 @@
  * Register Map
  * Register offsets for the I2C device.
  */
-#define XI2CPS_CR_OFFSET	0x00 /* Control Register, RW */
-#define XI2CPS_SR_OFFSET	0x04 /* Status Register, RO */
-#define XI2CPS_ADDR_OFFSET	0x08 /* I2C Address Register, RW */
-#define XI2CPS_DATA_OFFSET	0x0C /* I2C Data Register, RW */
-#define XI2CPS_ISR_OFFSET	0x10 /* Interrupt Status Register, RW */
-#define XI2CPS_XFER_SIZE_OFFSET 0x14 /* Transfer Size Register, RW */
-#define XI2CPS_SLV_PAUSE_OFFSET 0x18 /* Slave monitor pause Register, RW */
-#define XI2CPS_TIME_OUT_OFFSET	0x1C /* Time Out Register, RW */
-#define XI2CPS_IMR_OFFSET	0x20 /* Interrupt Mask Register, RO */
-#define XI2CPS_IER_OFFSET	0x24 /* Interrupt Enable Register, WO */
-#define XI2CPS_IDR_OFFSET	0x28 /* Interrupt Disable Register, WO */
+#define ZYNQ_I2C_CR_OFFSET	0x00 /* Control Register, RW */
+#define ZYNQ_I2C_SR_OFFSET	0x04 /* Status Register, RO */
+#define ZYNQ_I2C_ADDR_OFFSET	0x08 /* I2C Address Register, RW */
+#define ZYNQ_I2C_DATA_OFFSET	0x0C /* I2C Data Register, RW */
+#define ZYNQ_I2C_ISR_OFFSET	0x10 /* Interrupt Status Register, RW */
+#define ZYNQ_I2C_XFER_SIZE_OFFSET	0x14 /* Transfer Size Register, RW */
+/* Slave monitor pause Register, RW */
+#define ZYNQ_I2C_SLV_PAUSE_OFFSET	0x18
+#define ZYNQ_I2C_TIME_OUT_OFFSET	0x1C /* Time Out Register, RW */
+#define ZYNQ_I2C_IMR_OFFSET	0x20 /* Interrupt Mask Register, RO */
+#define ZYNQ_I2C_IER_OFFSET	0x24 /* Interrupt Enable Register, WO */
+#define ZYNQ_I2C_IDR_OFFSET	0x28 /* Interrupt Disable Register, WO */
 
 /*
  * Control Register Bit mask definitions
  * This register contains various control bits that affect the operation of the
  * I2C controller.
  */
-#define XI2CPS_CR_HOLD_BUS_MASK 0x00000010 /* Hold Bus bit */
-#define XI2CPS_CR_RW_MASK	0x00000001 /* Read or Write Master transfer
-					    * 0= Transmitter, 1= Receiver */
-#define XI2CPS_CR_CLR_FIFO_MASK 0x00000040 /* 1 = Auto init FIFO to zeroes */
+#define ZYNQ_I2C_CR_HOLD_BUS_MASK	0x00000010 /* Hold Bus bit */
+/* Read or Write Master transfer 0= Transmitter, 1= Receiver */
+#define ZYNQ_I2C_CR_RW_MASK		0x00000001
+/* 1 = Auto init FIFO to zeroes */
+#define ZYNQ_I2C_CR_CLR_FIFO_MASK	0x00000040
 
 /*
  * I2C Address Register Bit mask definitions
@@ -69,34 +71,34 @@
  * bits. A write access to this register always initiates a transfer if the I2C
  * is in master mode.
  */
-#define XI2CPS_ADDR_MASK	0x000003FF /* I2C Address Mask */
+#define ZYNQ_I2C_ADDR_MASK	0x000003FF /* I2C Address Mask */
 
 /*
  * I2C Interrupt Registers Bit mask definitions
  * All the four interrupt registers (Status/Mask/Enable/Disable) have the same
  * bit definitions.
  */
-#define XI2CPS_IXR_ALL_INTR_MASK 0x000002FF /* All ISR Mask */
+#define ZYNQ_I2C_IXR_ALL_INTR_MASK	0x000002FF /* All ISR Mask */
 
-#define XI2CPS_FIFO_DEPTH	16		/* FIFO Depth */
-#define XI2CPS_TIMEOUT		(50 * HZ)	/* Timeout for bus busy check */
-#define XI2CPS_ENABLED_INTR	0x2EF		/* Enabled Interrupts */
+#define ZYNQ_I2C_FIFO_DEPTH	16		/* FIFO Depth */
+#define ZYNQ_I2C_TIMEOUT	(50 * HZ)	/* Timeout for bus busy check */
+#define ZYNQ_I2C_ENABLED_INTR	0x2EF		/* Enabled Interrupts */
 
-#define XI2CPS_DATA_INTR_DEPTH (XI2CPS_FIFO_DEPTH - 2)/* FIFO depth at which
+#define ZYNQ_I2C_DATA_INTR_DEPTH (ZYNQ_I2C_FIFO_DEPTH - 2)/* FIFO depth at which
 							 * the DATA interrupt
 							 * occurs
 							 */
-#define XI2CPS_MAX_TRANSFER_SIZE	255 /* Max transfer size */
-#define XI2CPS_TRANSFER_SIZE	(XI2CPS_MAX_TRANSFER_SIZE - 3) /* Transfer size
-					in multiples of data interrupt depth */
+#define ZYNQ_I2C_MAX_TRANSFER_SIZE	255 /* Max transfer size */
+/* Transfer size in multiples of data interrupt depth */
+#define ZYNQ_I2C_TRANSFER_SIZE	(ZYNQ_I2C_MAX_TRANSFER_SIZE - 3)
 
-#define DRIVER_NAME		"xi2cps"
+#define DRIVER_NAME		"zynq_i2c"
 
-#define xi2cps_readreg(offset)		__raw_readl(id->membase + offset)
-#define xi2cps_writereg(val, offset)	__raw_writel(val, id->membase + offset)
+#define zynq_i2c_readreg(offset)	__raw_readl(id->membase + offset)
+#define zynq_i2c_writereg(val, offset)	__raw_writel(val, id->membase + offset)
 
 /**
- * struct xi2cps - I2C device private data structure
+ * struct zynq_i2c - I2C device private data structure
  * @membase:		Base address of the I2C device
  * @adap:		I2C adapter instance
  * @p_msg:		Message pointer
@@ -115,7 +117,7 @@
  * @clk:		Pointer to struct clk
  * @clk_rate_change_nb:	Notifier block for clock rate changes
  */
-struct xi2cps {
+struct zynq_i2c {
 	void __iomem *membase;
 	struct i2c_adapter adap;
 	struct i2c_msg	*p_msg;
@@ -135,27 +137,28 @@ struct xi2cps {
 	struct notifier_block	clk_rate_change_nb;
 };
 
-#define to_xi2cps(_nb)	container_of(_nb, struct xi2cps, clk_rate_change_nb)
+#define to_zynq_i2c(_nb)	container_of(_nb, struct zynq_i2c, \
+					     clk_rate_change_nb)
 #define MAX_F_ERR 10000
 
 /**
- * xi2cps_isr - Interrupt handler for the I2C device
+ * zynq_i2c_isr - Interrupt handler for the I2C device
  * @irq:	irq number for the I2C device
- * @ptr:	void pointer to xi2cps structure
+ * @ptr:	void pointer to zynq_i2c structure
  *
  * Returns IRQ_HANDLED always
  *
  * This function handles the data interrupt, transfer complete interrupt and
  * the error interrupts of the I2C device.
  */
-static irqreturn_t xi2cps_isr(int irq, void *ptr)
+static irqreturn_t zynq_i2c_isr(int irq, void *ptr)
 {
 	unsigned int isr_status, avail_bytes;
 	unsigned int bytes_to_recv, bytes_to_send;
 	unsigned int ctrl_reg = 0;
-	struct xi2cps *id = ptr;
+	struct zynq_i2c *id = ptr;
 
-	isr_status = xi2cps_readreg(XI2CPS_ISR_OFFSET);
+	isr_status = zynq_i2c_readreg(ZYNQ_I2C_ISR_OFFSET);
 
 	/* Handling Nack interrupt */
 	if (isr_status & 0x00000004)
@@ -167,39 +170,41 @@ static irqreturn_t xi2cps_isr(int irq, void *ptr)
 
 	/* Handling Data interrupt */
 	if (isr_status & 0x00000002) {
-		if (id->recv_count >= XI2CPS_DATA_INTR_DEPTH) {
+		if (id->recv_count >= ZYNQ_I2C_DATA_INTR_DEPTH) {
 			/* Always read data interrupt threshold bytes */
-			bytes_to_recv = XI2CPS_DATA_INTR_DEPTH;
+			bytes_to_recv = ZYNQ_I2C_DATA_INTR_DEPTH;
 			id->recv_count = id->recv_count -
-						XI2CPS_DATA_INTR_DEPTH;
-			avail_bytes = xi2cps_readreg(XI2CPS_XFER_SIZE_OFFSET);
+						ZYNQ_I2C_DATA_INTR_DEPTH;
+			avail_bytes = zynq_i2c_readreg(
+						ZYNQ_I2C_XFER_SIZE_OFFSET);
 			/*
 			 * if the tranfer size register value is zero, then
 			 * check for the remaining bytes and update the
 			 * transfer size register.
 			 */
 			if (avail_bytes == 0) {
-				if (id->recv_count  > XI2CPS_TRANSFER_SIZE)
-					xi2cps_writereg(XI2CPS_TRANSFER_SIZE,
-						XI2CPS_XFER_SIZE_OFFSET);
+				if (id->recv_count  > ZYNQ_I2C_TRANSFER_SIZE)
+					zynq_i2c_writereg(
+						ZYNQ_I2C_TRANSFER_SIZE,
+						ZYNQ_I2C_XFER_SIZE_OFFSET);
 				else
-					xi2cps_writereg(id->recv_count,
-						XI2CPS_XFER_SIZE_OFFSET);
+					zynq_i2c_writereg(id->recv_count,
+						ZYNQ_I2C_XFER_SIZE_OFFSET);
 			}
 			/* Process the data received */
 			while (bytes_to_recv) {
 				*(id->p_recv_buf)++ =
-					xi2cps_readreg(XI2CPS_DATA_OFFSET);
+					zynq_i2c_readreg(ZYNQ_I2C_DATA_OFFSET);
 				bytes_to_recv = bytes_to_recv - 1;
 			}
 
 			if ((id->bus_hold_flag == 0) &&
-				(id->recv_count <= XI2CPS_FIFO_DEPTH)) {
+				(id->recv_count <= ZYNQ_I2C_FIFO_DEPTH)) {
 				/* Clear the hold bus bit */
-				xi2cps_writereg(
-					(xi2cps_readreg(XI2CPS_CR_OFFSET) &
-					(~XI2CPS_CR_HOLD_BUS_MASK)),
-					XI2CPS_CR_OFFSET);
+				zynq_i2c_writereg(
+					(zynq_i2c_readreg(ZYNQ_I2C_CR_OFFSET) &
+					(~ZYNQ_I2C_CR_HOLD_BUS_MASK)),
+					ZYNQ_I2C_CR_OFFSET);
 			}
 		}
 	}
@@ -213,17 +218,17 @@ static irqreturn_t xi2cps_isr(int irq, void *ptr)
 			 * in FIFO and fill the FIFO with that many bytes.
 			 */
 			if (id->send_count > 0) {
-				avail_bytes = XI2CPS_FIFO_DEPTH -
-				xi2cps_readreg(XI2CPS_XFER_SIZE_OFFSET);
+				avail_bytes = ZYNQ_I2C_FIFO_DEPTH -
+				zynq_i2c_readreg(ZYNQ_I2C_XFER_SIZE_OFFSET);
 				if (id->send_count > avail_bytes)
 					bytes_to_send = avail_bytes;
 				else
 					bytes_to_send = id->send_count;
 
 				while (bytes_to_send--) {
-					xi2cps_writereg(
+					zynq_i2c_writereg(
 						(*(id->p_send_buf)++),
-						 XI2CPS_DATA_OFFSET);
+						 ZYNQ_I2C_DATA_OFFSET);
 					id->send_count--;
 				}
 			} else {
@@ -238,26 +243,27 @@ static irqreturn_t xi2cps_isr(int irq, void *ptr)
 				if (id->bus_hold_flag == 0) {
 					/* Clear the hold bus bit */
 					ctrl_reg =
-					xi2cps_readreg(XI2CPS_CR_OFFSET);
-					if ((ctrl_reg & XI2CPS_CR_HOLD_BUS_MASK)
-						== XI2CPS_CR_HOLD_BUS_MASK)
-						xi2cps_writereg(
+					zynq_i2c_readreg(ZYNQ_I2C_CR_OFFSET);
+					if ((ctrl_reg &
+					     ZYNQ_I2C_CR_HOLD_BUS_MASK)
+						== ZYNQ_I2C_CR_HOLD_BUS_MASK)
+						zynq_i2c_writereg(
 						(ctrl_reg &
-						(~XI2CPS_CR_HOLD_BUS_MASK)),
-						XI2CPS_CR_OFFSET);
+						(~ZYNQ_I2C_CR_HOLD_BUS_MASK)),
+						ZYNQ_I2C_CR_OFFSET);
 				}
 			}
 		} else {
 			if (id->bus_hold_flag == 0) {
 				/* Clear the hold bus bit */
 				ctrl_reg =
-				xi2cps_readreg(XI2CPS_CR_OFFSET);
-				if ((ctrl_reg & XI2CPS_CR_HOLD_BUS_MASK)
-					== XI2CPS_CR_HOLD_BUS_MASK)
-					xi2cps_writereg(
+				zynq_i2c_readreg(ZYNQ_I2C_CR_OFFSET);
+				if ((ctrl_reg & ZYNQ_I2C_CR_HOLD_BUS_MASK)
+					== ZYNQ_I2C_CR_HOLD_BUS_MASK)
+					zynq_i2c_writereg(
 					(ctrl_reg &
-					(~XI2CPS_CR_HOLD_BUS_MASK)),
-					XI2CPS_CR_OFFSET);
+					(~ZYNQ_I2C_CR_HOLD_BUS_MASK)),
+					ZYNQ_I2C_CR_OFFSET);
 			}
 			/*
 			 * If the device is receiving data, then signal
@@ -265,10 +271,10 @@ static irqreturn_t xi2cps_isr(int irq, void *ptr)
 			 * present in the FIFO. Signal the completion of
 			 * transaction.
 			 */
-			while (xi2cps_readreg(XI2CPS_SR_OFFSET)
+			while (zynq_i2c_readreg(ZYNQ_I2C_SR_OFFSET)
 							& 0x00000020) {
 				*(id->p_recv_buf)++ =
-					xi2cps_readreg(XI2CPS_DATA_OFFSET);
+					zynq_i2c_readreg(ZYNQ_I2C_DATA_OFFSET);
 				id->recv_count--;
 			}
 			complete(&id->xfer_done);
@@ -277,16 +283,16 @@ static irqreturn_t xi2cps_isr(int irq, void *ptr)
 
 	/* Update the status for errors */
 	id->err_status = isr_status & 0x000002EC;
-	xi2cps_writereg(isr_status, XI2CPS_ISR_OFFSET);
+	zynq_i2c_writereg(isr_status, ZYNQ_I2C_ISR_OFFSET);
 	return IRQ_HANDLED;
 }
 
 /**
- * xi2cps_mrecv - Prepare and start a master receive operation
+ * zynq_i2c_mrecv - Prepare and start a master receive operation
  * @id:		pointer to the i2c device structure
  *
  */
-static void xi2cps_mrecv(struct xi2cps *id)
+static void zynq_i2c_mrecv(struct zynq_i2c *id)
 {
 	unsigned int ctrl_reg;
 	unsigned int isr_status;
@@ -301,54 +307,56 @@ static void xi2cps_mrecv(struct xi2cps *id)
 	 * HOLD bus bit if it is more than FIFO depth.
 	 * Clear the interrupts in interrupt status register.
 	 */
-	ctrl_reg = xi2cps_readreg(XI2CPS_CR_OFFSET);
-	ctrl_reg |= (XI2CPS_CR_RW_MASK | XI2CPS_CR_CLR_FIFO_MASK);
+	ctrl_reg = zynq_i2c_readreg(ZYNQ_I2C_CR_OFFSET);
+	ctrl_reg |= (ZYNQ_I2C_CR_RW_MASK | ZYNQ_I2C_CR_CLR_FIFO_MASK);
 
 	if ((id->p_msg->flags & I2C_M_RECV_LEN) == I2C_M_RECV_LEN)
 		id->recv_count = I2C_SMBUS_BLOCK_MAX + 1;
 
-	if (id->recv_count > XI2CPS_FIFO_DEPTH)
-		ctrl_reg |= XI2CPS_CR_HOLD_BUS_MASK;
+	if (id->recv_count > ZYNQ_I2C_FIFO_DEPTH)
+		ctrl_reg |= ZYNQ_I2C_CR_HOLD_BUS_MASK;
 
-	xi2cps_writereg(ctrl_reg, XI2CPS_CR_OFFSET);
+	zynq_i2c_writereg(ctrl_reg, ZYNQ_I2C_CR_OFFSET);
 
-	isr_status = xi2cps_readreg(XI2CPS_ISR_OFFSET);
-	xi2cps_writereg(isr_status, XI2CPS_ISR_OFFSET);
+	isr_status = zynq_i2c_readreg(ZYNQ_I2C_ISR_OFFSET);
+	zynq_i2c_writereg(isr_status, ZYNQ_I2C_ISR_OFFSET);
 
-	xi2cps_writereg((id->p_msg->addr & XI2CPS_ADDR_MASK),
-						XI2CPS_ADDR_OFFSET);
+	zynq_i2c_writereg((id->p_msg->addr & ZYNQ_I2C_ADDR_MASK),
+						ZYNQ_I2C_ADDR_OFFSET);
 	/*
 	 * The no. of bytes to receive is checked against the limit of
 	 * max transfer size. Set transfer size register with no of bytes
 	 * receive if it is less than transfer size and transfer size if
 	 * it is more. Enable the interrupts.
 	 */
-	if (id->recv_count > XI2CPS_TRANSFER_SIZE)
-		xi2cps_writereg(XI2CPS_TRANSFER_SIZE, XI2CPS_XFER_SIZE_OFFSET);
+	if (id->recv_count > ZYNQ_I2C_TRANSFER_SIZE)
+		zynq_i2c_writereg(ZYNQ_I2C_TRANSFER_SIZE,
+				  ZYNQ_I2C_XFER_SIZE_OFFSET);
 	else
-		xi2cps_writereg(id->recv_count, XI2CPS_XFER_SIZE_OFFSET);
+		zynq_i2c_writereg(id->recv_count, ZYNQ_I2C_XFER_SIZE_OFFSET);
 	/*
 	 * Clear the bus hold flag if bytes to receive is less than FIFO size.
 	 */
 	if (id->bus_hold_flag == 0 &&
 		((id->p_msg->flags & I2C_M_RECV_LEN) != I2C_M_RECV_LEN) &&
-		(id->recv_count <= XI2CPS_FIFO_DEPTH)) {
+		(id->recv_count <= ZYNQ_I2C_FIFO_DEPTH)) {
 			/* Clear the hold bus bit */
-			ctrl_reg = xi2cps_readreg(XI2CPS_CR_OFFSET);
-			if ((ctrl_reg & XI2CPS_CR_HOLD_BUS_MASK) ==
-					XI2CPS_CR_HOLD_BUS_MASK)
-				xi2cps_writereg(
-					(ctrl_reg & (~XI2CPS_CR_HOLD_BUS_MASK)),
-					XI2CPS_CR_OFFSET);
+			ctrl_reg = zynq_i2c_readreg(ZYNQ_I2C_CR_OFFSET);
+			if ((ctrl_reg & ZYNQ_I2C_CR_HOLD_BUS_MASK) ==
+					ZYNQ_I2C_CR_HOLD_BUS_MASK)
+				zynq_i2c_writereg(
+					(ctrl_reg &
+					 (~ZYNQ_I2C_CR_HOLD_BUS_MASK)),
+					ZYNQ_I2C_CR_OFFSET);
 	}
-	xi2cps_writereg(XI2CPS_ENABLED_INTR, XI2CPS_IER_OFFSET);
+	zynq_i2c_writereg(ZYNQ_I2C_ENABLED_INTR, ZYNQ_I2C_IER_OFFSET);
 }
 
 /**
- * xi2cps_msend - Prepare and start a master send operation
+ * zynq_i2c_msend - Prepare and start a master send operation
  * @id:		pointer to the i2c device
  */
-static void xi2cps_msend(struct xi2cps *id)
+static void zynq_i2c_msend(struct zynq_i2c *id)
 {
 	unsigned int avail_bytes;
 	unsigned int bytes_to_send;
@@ -366,24 +374,24 @@ static void xi2cps_msend(struct xi2cps *id)
 	 * HOLD bus bit if it is more than FIFO depth.
 	 * Clear the interrupts in interrupt status register.
 	 */
-	ctrl_reg = xi2cps_readreg(XI2CPS_CR_OFFSET);
-	ctrl_reg &= ~XI2CPS_CR_RW_MASK;
-	ctrl_reg |= XI2CPS_CR_CLR_FIFO_MASK;
+	ctrl_reg = zynq_i2c_readreg(ZYNQ_I2C_CR_OFFSET);
+	ctrl_reg &= ~ZYNQ_I2C_CR_RW_MASK;
+	ctrl_reg |= ZYNQ_I2C_CR_CLR_FIFO_MASK;
 
-	if ((id->send_count) > XI2CPS_FIFO_DEPTH)
-		ctrl_reg |= XI2CPS_CR_HOLD_BUS_MASK;
-	xi2cps_writereg(ctrl_reg, XI2CPS_CR_OFFSET);
+	if ((id->send_count) > ZYNQ_I2C_FIFO_DEPTH)
+		ctrl_reg |= ZYNQ_I2C_CR_HOLD_BUS_MASK;
+	zynq_i2c_writereg(ctrl_reg, ZYNQ_I2C_CR_OFFSET);
 
-	isr_status = xi2cps_readreg(XI2CPS_ISR_OFFSET);
-	xi2cps_writereg(isr_status, XI2CPS_ISR_OFFSET);
+	isr_status = zynq_i2c_readreg(ZYNQ_I2C_ISR_OFFSET);
+	zynq_i2c_writereg(isr_status, ZYNQ_I2C_ISR_OFFSET);
 
 	/*
 	 * Calculate the space available in FIFO. Check the message length
 	 * against the space available, and fill the FIFO accordingly.
 	 * Enable the interrupts.
 	 */
-	avail_bytes = XI2CPS_FIFO_DEPTH -
-				xi2cps_readreg(XI2CPS_XFER_SIZE_OFFSET);
+	avail_bytes = ZYNQ_I2C_FIFO_DEPTH -
+				zynq_i2c_readreg(ZYNQ_I2C_XFER_SIZE_OFFSET);
 
 	if (id->send_count > avail_bytes)
 		bytes_to_send = avail_bytes;
@@ -391,12 +399,12 @@ static void xi2cps_msend(struct xi2cps *id)
 		bytes_to_send = id->send_count;
 
 	while (bytes_to_send--) {
-		xi2cps_writereg((*(id->p_send_buf)++), XI2CPS_DATA_OFFSET);
+		zynq_i2c_writereg((*(id->p_send_buf)++), ZYNQ_I2C_DATA_OFFSET);
 		id->send_count--;
 	}
 
-	xi2cps_writereg((id->p_msg->addr & XI2CPS_ADDR_MASK),
-						XI2CPS_ADDR_OFFSET);
+	zynq_i2c_writereg((id->p_msg->addr & ZYNQ_I2C_ADDR_MASK),
+						ZYNQ_I2C_ADDR_OFFSET);
 
 	/*
 	 * Clear the bus hold flag if there is no more data
@@ -404,18 +412,18 @@ static void xi2cps_msend(struct xi2cps *id)
 	 */
 	if (id->bus_hold_flag == 0 && id->send_count == 0) {
 		/* Clear the hold bus bit */
-		ctrl_reg = xi2cps_readreg(XI2CPS_CR_OFFSET);
-		if ((ctrl_reg & XI2CPS_CR_HOLD_BUS_MASK) ==
-				XI2CPS_CR_HOLD_BUS_MASK)
-			xi2cps_writereg(
-				(ctrl_reg & (~XI2CPS_CR_HOLD_BUS_MASK)),
-				XI2CPS_CR_OFFSET);
+		ctrl_reg = zynq_i2c_readreg(ZYNQ_I2C_CR_OFFSET);
+		if ((ctrl_reg & ZYNQ_I2C_CR_HOLD_BUS_MASK) ==
+				ZYNQ_I2C_CR_HOLD_BUS_MASK)
+			zynq_i2c_writereg(
+				(ctrl_reg & (~ZYNQ_I2C_CR_HOLD_BUS_MASK)),
+				ZYNQ_I2C_CR_OFFSET);
 	}
-	xi2cps_writereg(XI2CPS_ENABLED_INTR, XI2CPS_IER_OFFSET);
+	zynq_i2c_writereg(ZYNQ_I2C_ENABLED_INTR, ZYNQ_I2C_IER_OFFSET);
 }
 
 /**
- * xi2cps_master_reset - Reset the interface
+ * zynq_i2c_master_reset - Reset the interface
  * @adap:	pointer to the i2c adapter driver instance
  *
  * Returns none
@@ -423,30 +431,30 @@ static void xi2cps_msend(struct xi2cps *id)
  * This function cleanup the fifos, clear the hold bit and status
  * and disable the interrupts.
  */
-static void xi2cps_master_reset(struct i2c_adapter *adap)
+static void zynq_i2c_master_reset(struct i2c_adapter *adap)
 {
-	struct xi2cps *id = adap->algo_data;
+	struct zynq_i2c *id = adap->algo_data;
 	u32 regval;
 
 	/* Disable the interrupts */
-	xi2cps_writereg(XI2CPS_IXR_ALL_INTR_MASK, XI2CPS_IDR_OFFSET);
+	zynq_i2c_writereg(ZYNQ_I2C_IXR_ALL_INTR_MASK, ZYNQ_I2C_IDR_OFFSET);
 	/* Clear the hold bit and fifos */
-	regval = xi2cps_readreg(XI2CPS_CR_OFFSET);
-	regval &= ~XI2CPS_CR_HOLD_BUS_MASK;
-	regval |= XI2CPS_CR_CLR_FIFO_MASK;
-	xi2cps_writereg(regval, XI2CPS_CR_OFFSET);
+	regval = zynq_i2c_readreg(ZYNQ_I2C_CR_OFFSET);
+	regval &= ~ZYNQ_I2C_CR_HOLD_BUS_MASK;
+	regval |= ZYNQ_I2C_CR_CLR_FIFO_MASK;
+	zynq_i2c_writereg(regval, ZYNQ_I2C_CR_OFFSET);
 	/* Update the transfercount register to zero */
-	xi2cps_writereg(0x0, XI2CPS_XFER_SIZE_OFFSET);
+	zynq_i2c_writereg(0x0, ZYNQ_I2C_XFER_SIZE_OFFSET);
 	/* Clear the interupt status register */
-	regval = xi2cps_readreg(XI2CPS_ISR_OFFSET);
-	xi2cps_writereg(regval, XI2CPS_ISR_OFFSET);
+	regval = zynq_i2c_readreg(ZYNQ_I2C_ISR_OFFSET);
+	zynq_i2c_writereg(regval, ZYNQ_I2C_ISR_OFFSET);
 	/* Clear the status register */
-	regval =  xi2cps_readreg(XI2CPS_SR_OFFSET);
-	xi2cps_writereg(regval, XI2CPS_SR_OFFSET);
+	regval =  zynq_i2c_readreg(ZYNQ_I2C_SR_OFFSET);
+	zynq_i2c_writereg(regval, ZYNQ_I2C_SR_OFFSET);
 }
 
 /**
- * xi2cps_master_xfer - The main i2c transfer function
+ * zynq_i2c_master_xfer - The main i2c transfer function
  * @adap:	pointer to the i2c adapter driver instance
  * @msgs:	pointer to the i2c message structure
  * @num:	the number of messages to transfer
@@ -457,21 +465,21 @@ static void xi2cps_master_reset(struct i2c_adapter *adap)
  * modified by user. Then initiates the send/recv activity based on the
  * transfer message received.
  */
-static int xi2cps_master_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs,
+static int zynq_i2c_master_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs,
 				int num)
 {
-	struct xi2cps *id = adap->algo_data;
+	struct zynq_i2c *id = adap->algo_data;
 	unsigned int count, retries;
 	unsigned long timeout;
 	int ret;
 
 	/* Waiting for bus-ready. If bus not ready, it returns after timeout */
-	timeout = jiffies + XI2CPS_TIMEOUT;
-	while ((xi2cps_readreg(XI2CPS_SR_OFFSET)) & 0x00000100) {
+	timeout = jiffies + ZYNQ_I2C_TIMEOUT;
+	while ((zynq_i2c_readreg(ZYNQ_I2C_SR_OFFSET)) & 0x00000100) {
 		if (time_after(jiffies, timeout)) {
 			dev_warn(id->adap.dev.parent,
 					"timedout waiting for bus ready\n");
-			xi2cps_master_reset(adap);
+			zynq_i2c_master_reset(adap);
 			return -ETIMEDOUT;
 		}
 		schedule_timeout(1);
@@ -479,8 +487,8 @@ static int xi2cps_master_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs,
 
 	/* The bus is free. Set the new timeout value if updated */
 	if (id->adap.timeout != id->cur_timeout) {
-		xi2cps_writereg((id->adap.timeout & 0xFF),
-					XI2CPS_TIME_OUT_OFFSET);
+		zynq_i2c_writereg((id->adap.timeout & 0xFF),
+					ZYNQ_I2C_TIME_OUT_OFFSET);
 		id->cur_timeout = id->adap.timeout;
 	}
 
@@ -490,8 +498,8 @@ static int xi2cps_master_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs,
 	 */
 	if (num > 1) {
 		id->bus_hold_flag = 1;
-		xi2cps_writereg((xi2cps_readreg(XI2CPS_CR_OFFSET) |
-				XI2CPS_CR_HOLD_BUS_MASK), XI2CPS_CR_OFFSET);
+		zynq_i2c_writereg((zynq_i2c_readreg(ZYNQ_I2C_CR_OFFSET) |
+				ZYNQ_I2C_CR_HOLD_BUS_MASK), ZYNQ_I2C_CR_OFFSET);
 	} else {
 		id->bus_hold_flag = 0;
 	}
@@ -509,21 +517,22 @@ retry:
 
 		/* Check for the TEN Bit mode on each msg */
 		if (msgs->flags & I2C_M_TEN) {
-			xi2cps_writereg((xi2cps_readreg(XI2CPS_CR_OFFSET) &
-					(~0x00000004)), XI2CPS_CR_OFFSET);
+			zynq_i2c_writereg(
+				(zynq_i2c_readreg(ZYNQ_I2C_CR_OFFSET) &
+					(~0x00000004)), ZYNQ_I2C_CR_OFFSET);
 		} else {
-			if ((xi2cps_readreg(XI2CPS_CR_OFFSET) & 0x00000004)
+			if ((zynq_i2c_readreg(ZYNQ_I2C_CR_OFFSET) & 0x00000004)
 								== 0)
-				xi2cps_writereg(
-					(xi2cps_readreg(XI2CPS_CR_OFFSET) |
-					 (0x00000004)), XI2CPS_CR_OFFSET);
+				zynq_i2c_writereg(
+					(zynq_i2c_readreg(ZYNQ_I2C_CR_OFFSET) |
+					 (0x00000004)), ZYNQ_I2C_CR_OFFSET);
 		}
 
 		/* Check for the R/W flag on each msg */
 		if (msgs->flags & I2C_M_RD)
-			xi2cps_mrecv(id);
+			zynq_i2c_mrecv(id);
 		else
-			xi2cps_msend(id);
+			zynq_i2c_msend(id);
 
 		/* Wait for the signal of completion */
 		ret = wait_for_completion_interruptible_timeout(
@@ -531,10 +540,11 @@ retry:
 		if (ret == 0) {
 			dev_err(id->adap.dev.parent,
 				 "timeout waiting on completion\n");
-			xi2cps_master_reset(adap);
+			zynq_i2c_master_reset(adap);
 			return -ETIMEDOUT;
 		}
-		xi2cps_writereg(XI2CPS_IXR_ALL_INTR_MASK, XI2CPS_IDR_OFFSET);
+		zynq_i2c_writereg(ZYNQ_I2C_IXR_ALL_INTR_MASK,
+				  ZYNQ_I2C_IDR_OFFSET);
 
 		/* If it is bus arbitration error, try again */
 		if (id->err_status & 0x00000200) {
@@ -551,7 +561,7 @@ retry:
 		}
 		/* Report the other error interrupts to application as EIO */
 		if (id->err_status & 0x000000E4) {
-			xi2cps_master_reset(adap);
+			zynq_i2c_master_reset(adap);
 			num = -EIO;
 			break;
 		}
@@ -564,25 +574,25 @@ retry:
 }
 
 /**
- * xi2cps_func - Returns the supported features of the I2C driver
+ * zynq_i2c_func - Returns the supported features of the I2C driver
  * @adap:	pointer to the i2c adapter structure
  *
  * Returns 32 bit value, each bit corresponding to a feature
  */
-static u32 xi2cps_func(struct i2c_adapter *adap)
+static u32 zynq_i2c_func(struct i2c_adapter *adap)
 {
 	return I2C_FUNC_I2C | I2C_FUNC_10BIT_ADDR |
 		(I2C_FUNC_SMBUS_EMUL & ~I2C_FUNC_SMBUS_QUICK) |
 		I2C_FUNC_SMBUS_BLOCK_DATA;
 }
 
-static const struct i2c_algorithm xi2cps_algo = {
-	.master_xfer	= xi2cps_master_xfer,
-	.functionality	= xi2cps_func,
+static const struct i2c_algorithm zynq_i2c_algo = {
+	.master_xfer	= zynq_i2c_master_xfer,
+	.functionality	= zynq_i2c_func,
 };
 
 /**
- * xi2cps_calc_divs() - Calculate clock dividers
+ * zynq_i2c_calc_divs() - Calculate clock dividers
  * @f:		I2C clock frequency
  * @input_clk:	Input clock frequency
  * @a:		First divider (return value)
@@ -593,7 +603,7 @@ static const struct i2c_algorithm xi2cps_algo = {
  * f is used as input and output variable. As input it is used as target I2C
  * frequency. On function exit f holds the actually resulting I2C frequency.
  */
-static int xi2cps_calc_divs(unsigned int *f, unsigned int input_clk,
+static int zynq_i2c_calc_divs(unsigned int *f, unsigned int input_clk,
 		unsigned int *a, unsigned int *b, unsigned int *err)
 {
 	unsigned int fscl = *f;
@@ -643,7 +653,7 @@ static int xi2cps_calc_divs(unsigned int *f, unsigned int input_clk,
 }
 
 /**
- * xi2cps_setclk - This function sets the serial clock rate for the I2C device
+ * zynq_i2c_setclk - This function sets the serial clock rate for the I2C device
  * @fscl:	The clock frequency in Hz
  * @id:		Pointer to the I2C device structure
  *
@@ -658,43 +668,43 @@ static int xi2cps_calc_divs(unsigned int *f, unsigned int input_clk,
  * clock rate. The clock can not be faster than the input clock divide by 22.
  * The two most common clock rates are 100KHz and 400KHz.
  */
-static int xi2cps_setclk(unsigned int fscl, struct xi2cps *id)
+static int zynq_i2c_setclk(unsigned int fscl, struct zynq_i2c *id)
 {
 	unsigned int div_a, div_b;
 	unsigned int ctrl_reg;
 	unsigned int err;
 	int ret = 0;
 
-	ret = xi2cps_calc_divs(&fscl, id->input_clk, &div_a, &div_b, &err);
+	ret = zynq_i2c_calc_divs(&fscl, id->input_clk, &div_a, &div_b, &err);
 	if (ret)
 		return ret;
 
-	ctrl_reg = xi2cps_readreg(XI2CPS_CR_OFFSET);
+	ctrl_reg = zynq_i2c_readreg(ZYNQ_I2C_CR_OFFSET);
 	ctrl_reg &= ~(0x0000C000 | 0x00003F00);
 	ctrl_reg |= ((div_a << 14) | (div_b << 8));
-	xi2cps_writereg(ctrl_reg, XI2CPS_CR_OFFSET);
+	zynq_i2c_writereg(ctrl_reg, ZYNQ_I2C_CR_OFFSET);
 
 	return 0;
 }
 
 /**
- * xi2cps_clk_notifier_cb - Clock rate change callback
+ * zynq_i2c_clk_notifier_cb - Clock rate change callback
  * @nb:		Pointer to notifier block
  * @event:	Notification reason
  * @data:	Pointer to notification data object
  * Returns NOTIFY_STOP if the rate change should be aborted, NOTIFY_OK
  * otherwise.
  *
- * This function is called when the xi2cps input clock frequency changes. In the
- * pre-rate change notification here it is determined if the rate change may be
- * allowed or not.
+ * This function is called when the zynq_i2c input clock frequency changes.
+ * In the pre-rate change notification here it is determined if the rate change
+ * may be allowed or not.
  * In th post-change case necessary adjustments are conducted.
  */
-static int xi2cps_clk_notifier_cb(struct notifier_block *nb, unsigned long
+static int zynq_i2c_clk_notifier_cb(struct notifier_block *nb, unsigned long
 		event, void *data)
 {
 	struct clk_notifier_data *ndata = data;
-	struct xi2cps *id = to_xi2cps(nb);
+	struct zynq_i2c *id = to_zynq_i2c(nb);
 
 	if (id->suspended)
 		return NOTIFY_OK;
@@ -714,7 +724,8 @@ static int xi2cps_clk_notifier_cb(struct notifier_block *nb, unsigned long
 		unsigned int err = 0;
 		int ret;
 
-		ret = xi2cps_calc_divs(&fscl, input_clk, &div_a, &div_b, &err);
+		ret = zynq_i2c_calc_divs(&fscl, input_clk, &div_a, &div_b,
+					 &err);
 		if (ret)
 			return NOTIFY_STOP;
 		if (err > MAX_F_ERR)
@@ -726,7 +737,7 @@ static int xi2cps_clk_notifier_cb(struct notifier_block *nb, unsigned long
 		id->input_clk = ndata->new_rate;
 		/* We probably need to stop the HW before this and restart
 		 * afterwards */
-		xi2cps_setclk(id->i2c_clk, id);
+		zynq_i2c_setclk(id->i2c_clk, id);
 		return NOTIFY_OK;
 	case ABORT_RATE_CHANGE:
 	default:
@@ -736,17 +747,17 @@ static int xi2cps_clk_notifier_cb(struct notifier_block *nb, unsigned long
 
 #ifdef CONFIG_PM_SLEEP
 /**
- * xi2cps_suspend - Suspend method for the driver
+ * zynq_i2c_suspend - Suspend method for the driver
  * @_dev:	Address of the platform_device structure
  * Returns 0 on success and error value on error
  *
  * Put the driver into low power mode.
  */
-static int xi2cps_suspend(struct device *_dev)
+static int zynq_i2c_suspend(struct device *_dev)
 {
 	struct platform_device *pdev = container_of(_dev,
 			struct platform_device, dev);
-	struct xi2cps *xi2c = platform_get_drvdata(pdev);
+	struct zynq_i2c *xi2c = platform_get_drvdata(pdev);
 
 	clk_disable(xi2c->clk);
 	xi2c->suspended = 1;
@@ -755,17 +766,17 @@ static int xi2cps_suspend(struct device *_dev)
 }
 
 /**
- * xi2cps_resume - Resume from suspend
+ * zynq_i2c_resume - Resume from suspend
  * @_dev:	Address of the platform_device structure
  * Returns 0 on success and error value on error
  *
  * Resume operation after suspend.
  */
-static int xi2cps_resume(struct device *_dev)
+static int zynq_i2c_resume(struct device *_dev)
 {
 	struct platform_device *pdev = container_of(_dev,
 			struct platform_device, dev);
-	struct xi2cps *xi2c = platform_get_drvdata(pdev);
+	struct zynq_i2c *xi2c = platform_get_drvdata(pdev);
 	int ret;
 
 	ret = clk_enable(xi2c->clk);
@@ -780,14 +791,15 @@ static int xi2cps_resume(struct device *_dev)
 }
 #endif
 
-static SIMPLE_DEV_PM_OPS(xi2cps_dev_pm_ops, xi2cps_suspend, xi2cps_resume);
+static SIMPLE_DEV_PM_OPS(zynq_i2c_dev_pm_ops, zynq_i2c_suspend,
+			 zynq_i2c_resume);
 
 /************************/
 /* Platform bus binding */
 /************************/
 
 /**
- * xi2cps_probe - Platform registration call
+ * zynq_i2c_probe - Platform registration call
  * @pdev:	Handle to the platform device structure
  *
  * Returns zero on success, negative error otherwise
@@ -796,18 +808,18 @@ static SIMPLE_DEV_PM_OPS(xi2cps_dev_pm_ops, xi2cps_suspend, xi2cps_resume);
  * device. User can modify the address mode to 10 bit address mode using the
  * ioctl call with option I2C_TENBIT.
  */
-static int xi2cps_probe(struct platform_device *pdev)
+static int zynq_i2c_probe(struct platform_device *pdev)
 {
 	struct resource *r_mem = NULL;
-	struct xi2cps *id;
+	struct zynq_i2c *id;
 	int ret = 0;
 	const unsigned int *prop;
 	/*
-	 * Allocate memory for xi2cps structure.
+	 * Allocate memory for zynq_i2c structure.
 	 * Initialize the structure to zero and set the platform data.
 	 * Obtain the resource base address from platform data and remap it.
 	 * Get the irq resource from platform data.Initialize the adapter
-	 * structure members and also xi2cps structure.
+	 * structure members and also zynq_i2c structure.
 	 */
 	id = devm_kzalloc(&pdev->dev, sizeof(*id), GFP_KERNEL);
 	if (!id)
@@ -830,7 +842,7 @@ static int xi2cps_probe(struct platform_device *pdev)
 		return -ENXIO;
 	}
 	id->adap.dev.of_node = pdev->dev.of_node;
-	id->adap.algo = (struct i2c_algorithm *) &xi2cps_algo;
+	id->adap.algo = (struct i2c_algorithm *) &zynq_i2c_algo;
 	id->adap.timeout = 0x1F;	/* Default timeout value */
 	id->adap.retries = 3;		/* Default retry value. */
 	id->adap.algo_data = id;
@@ -849,7 +861,7 @@ static int xi2cps_probe(struct platform_device *pdev)
 		dev_err(&pdev->dev, "Unable to enable clock.\n");
 		return ret;
 	}
-	id->clk_rate_change_nb.notifier_call = xi2cps_clk_notifier_cb;
+	id->clk_rate_change_nb.notifier_call = zynq_i2c_clk_notifier_cb;
 	id->clk_rate_change_nb.next = NULL;
 	if (clk_notifier_register(id->clk, &id->clk_rate_change_nb))
 		dev_warn(&pdev->dev, "Unable to register clock notifier.\n");
@@ -868,17 +880,17 @@ static int xi2cps_probe(struct platform_device *pdev)
 	 * Set the timeout and I2C clock and request the IRQ(ISR mapped).
 	 * Call to the i2c_add_numbered_adapter registers the adapter.
 	 */
-	xi2cps_writereg(0x0000000E, XI2CPS_CR_OFFSET);
-	xi2cps_writereg(id->adap.timeout, XI2CPS_TIME_OUT_OFFSET);
+	zynq_i2c_writereg(0x0000000E, ZYNQ_I2C_CR_OFFSET);
+	zynq_i2c_writereg(id->adap.timeout, ZYNQ_I2C_TIME_OUT_OFFSET);
 
-	ret = xi2cps_setclk(id->i2c_clk, id);
+	ret = zynq_i2c_setclk(id->i2c_clk, id);
 	if (ret < 0) {
 		dev_err(&pdev->dev, "invalid SCL clock: %dkHz\n", id->i2c_clk);
 		ret = -EINVAL;
 		goto err_clk_dis;
 	}
 
-	ret = devm_request_irq(&pdev->dev, id->irq, xi2cps_isr, 0,
+	ret = devm_request_irq(&pdev->dev, id->irq, zynq_i2c_isr, 0,
 				 DRIVER_NAME, id);
 	if (ret) {
 		dev_err(&pdev->dev, "cannot get irq %d\n", id->irq);
@@ -902,16 +914,16 @@ err_clk_dis:
 }
 
 /**
- * xi2cps_remove - Unregister the device after releasing the resources
+ * zynq_i2c_remove - Unregister the device after releasing the resources
  * @pdev:	Handle to the platform device structure
  *
  * Returns zero always
  *
  * This function frees all the resources allocated to the device.
  */
-static int xi2cps_remove(struct platform_device *pdev)
+static int zynq_i2c_remove(struct platform_device *pdev)
 {
-	struct xi2cps *id = platform_get_drvdata(pdev);
+	struct zynq_i2c *id = platform_get_drvdata(pdev);
 
 	i2c_del_adapter(&id->adap);
 	clk_notifier_unregister(id->clk, &id->clk_rate_change_nb);
@@ -920,24 +932,24 @@ static int xi2cps_remove(struct platform_device *pdev)
 	return 0;
 }
 
-static const struct of_device_id xi2cps_of_match[] = {
+static const struct of_device_id zynq_i2c_of_match[] = {
 	{ .compatible = "xlnx,ps7-i2c-1.00.a", },
 	{ /* end of table */}
 };
-MODULE_DEVICE_TABLE(of, xi2cps_of_match);
+MODULE_DEVICE_TABLE(of, zynq_i2c_of_match);
 
-static struct platform_driver xi2cps_drv = {
+static struct platform_driver zynq_i2c_drv = {
 	.driver = {
 		.name  = DRIVER_NAME,
 		.owner = THIS_MODULE,
-		.of_match_table = xi2cps_of_match,
-		.pm = &xi2cps_dev_pm_ops,
+		.of_match_table = zynq_i2c_of_match,
+		.pm = &zynq_i2c_dev_pm_ops,
 	},
-	.probe  = xi2cps_probe,
-	.remove = xi2cps_remove,
+	.probe  = zynq_i2c_probe,
+	.remove = zynq_i2c_remove,
 };
 
-module_platform_driver(xi2cps_drv);
+module_platform_driver(zynq_i2c_drv);
 
 MODULE_AUTHOR("Xilinx, Inc.");
 MODULE_DESCRIPTION("Xilinx Zynq I2C bus driver");
-- 
1.7.5.4

