From 0c65a3759a321ec3c11779efd984d53ba0015388 Mon Sep 17 00:00:00 2001
From: Zumeng Chen <zumeng.chen@windriver.com>
Date: Tue, 15 Dec 2015 15:31:25 +0800
Subject: [PATCH 10/10] ASoC: Add support for virtual switch controls

https://github.com/analogdevicesinc/linux.git xcomm_zynq_3_10
commit 376a50a17fdabe4530f703a9d7bebd963f383e05

Virtual switches are similar to virtual MUX controls. It does not have a
representation in the actual hardware but allows to control the DAPM routing by
enabling or disabling a input path into the mixer. This is useful if we want to
present a way to the user to for example mute a path despite the absence of a
separate mute control in hardware.

More specific this will be used by the ADAU1361 driver where the hardware has
a mute control for each of the DAC output paths, but we have to make sure that
the path is muted whenever the DAC is disabled. So the mute switches needs
to be controlled by DAPM so it can disable them before disabling the DAC. On the
other hand we still want to be to mute individual paths. This will be
accomplished by using virtual switch controls.

Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 sound/soc/codecs/adau1761.c |   24 ++++++++++-----
 sound/soc/soc-dapm.c        |   67 +++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 83 insertions(+), 8 deletions(-)

diff --git a/sound/soc/codecs/adau1761.c b/sound/soc/codecs/adau1761.c
index a1baeee..82cf290 100644
--- a/sound/soc/codecs/adau1761.c
+++ b/sound/soc/codecs/adau1761.c
@@ -64,6 +64,18 @@
 
 #define ADAU1761_FIRMWARE "adau1761.bin"
 
+int snd_soc_dapm_put_volsw_virt(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol);
+int snd_soc_dapm_get_volsw_virt(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol);
+
+#define SOC_DAPM_SINGLE_VIRT_ZYNQ(xname, shift, max) \
+{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \
+	.info = snd_soc_info_volsw, \
+	.get = snd_soc_dapm_get_volsw_virt, \
+	.put = snd_soc_dapm_put_volsw_virt, \
+	.private_value =  SOC_SINGLE_VALUE(SND_SOC_NOPM, shift, max, 0, 0) }
+
 static const struct reg_default adau1761_reg_defaults[] = {
 	{ ADAU1761_DEJITTER,			0x03 },
 	{ ADAU1761_DIGMIC_JACKDETECT,		0x00 },
@@ -203,10 +215,8 @@ static const struct snd_kcontrol_new adau1761_mono_controls[] = {
 };
 
 static const struct snd_kcontrol_new adau1761_left_mixer_controls[] = {
-	SOC_DAPM_SINGLE_AUTODISABLE("Left DAC Switch",
-		ADAU1761_PLAY_MIXER_LEFT0, 5, 1, 0),
-	SOC_DAPM_SINGLE_AUTODISABLE("Right DAC Switch",
-		ADAU1761_PLAY_MIXER_LEFT0, 6, 1, 0),
+	SOC_DAPM_SINGLE_VIRT_ZYNQ("Left DAC Switch", 0, 1),
+	SOC_DAPM_SINGLE_VIRT_ZYNQ("Right DAC Switch", 0, 1),
 	SOC_DAPM_SINGLE_TLV("Aux Bypass Volume",
 		ADAU1761_PLAY_MIXER_LEFT0, 1, 8, 0, adau1761_sidetone_tlv),
 	SOC_DAPM_SINGLE_TLV("Right Bypass Volume",
@@ -216,10 +226,8 @@ static const struct snd_kcontrol_new adau1761_left_mixer_controls[] = {
 };
 
 static const struct snd_kcontrol_new adau1761_right_mixer_controls[] = {
-	SOC_DAPM_SINGLE_AUTODISABLE("Left DAC Switch",
-		ADAU1761_PLAY_MIXER_RIGHT0, 5, 1, 0),
-	SOC_DAPM_SINGLE_AUTODISABLE("Right DAC Switch",
-		ADAU1761_PLAY_MIXER_RIGHT0, 6, 1, 0),
+	SOC_DAPM_SINGLE_VIRT_ZYNQ("Left DAC Switch", 0, 1),
+	SOC_DAPM_SINGLE_VIRT_ZYNQ("Right DAC Switch", 0, 1),
 	SOC_DAPM_SINGLE_TLV("Aux Bypass Volume",
 		ADAU1761_PLAY_MIXER_RIGHT0, 1, 8, 0, adau1761_sidetone_tlv),
 	SOC_DAPM_SINGLE_TLV("Right Bypass Volume",
diff --git a/sound/soc/soc-dapm.c b/sound/soc/soc-dapm.c
index b6c12dc..0ac4401 100644
--- a/sound/soc/soc-dapm.c
+++ b/sound/soc/soc-dapm.c
@@ -2898,6 +2898,73 @@ int snd_soc_dapm_put_volsw(struct snd_kcontrol *kcontrol,
 }
 EXPORT_SYMBOL_GPL(snd_soc_dapm_put_volsw);
 
+#ifdef CONFIG_SND_SOC_ZED_ADAU1761
+/**
+ * snd_soc_dapm_get_volsw_virt - virtual dapm mixer get callback
+ * @kcontrol: mixer control
+ * @ucontrol: control element information
+ *
+ * Callback to get the value of a virtual dapm mixer control.
+ *
+ * Returns 0 for success.
+ */
+int snd_soc_dapm_get_volsw_virt(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_dapm_widget_list *wlist = snd_kcontrol_chip(kcontrol);
+	struct snd_soc_dapm_widget *widget = wlist->widgets[0];
+
+	if(widget)
+		ucontrol->value.integer.value[0] = 0x1;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_dapm_get_volsw_virt);
+
+/**
+ * snd_soc_dapm_put_volsw_virt - virtual dapm mixer set callback
+ * @kcontrol: mixer control
+ * @ucontrol: control element information
+ *
+ * Callback to set the value of a virutal dapm mixer control.
+ *
+ * Returns 0 for success.
+ */
+int snd_soc_dapm_put_volsw_virt(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_dapm_widget_list *wlist = snd_kcontrol_chip(kcontrol);
+	struct snd_soc_dapm_context *dapm = snd_soc_dapm_kcontrol_dapm(kcontrol);
+	struct snd_soc_card *card = dapm->card;
+	struct soc_mixer_control *mc =
+		(struct soc_mixer_control *)kcontrol->private_value;
+	unsigned int mask = (1 << fls(mc->max)) - 1;
+	unsigned int shift = mc->shift;
+	unsigned int val, connect;
+	int wi;
+
+	val = ucontrol->value.integer.value[0] & mask;
+
+	mask = mask << shift;
+	val = val << shift;
+
+	if (val)
+		connect = 1;
+	else
+		connect = 0;
+
+	mutex_lock_nested(&card->dapm_mutex, SND_SOC_DAPM_CLASS_RUNTIME);
+
+	for (wi = 0; wi < wlist->num_widgets; wi++) {
+			soc_dapm_mixer_update_power(card, kcontrol, connect);
+	}
+
+	mutex_unlock(&card->dapm_mutex);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_dapm_put_volsw_virt);
+#endif
+
 /**
  * snd_soc_dapm_get_enum_double - dapm enumerated double mixer get callback
  * @kcontrol: mixer control
-- 
1.7.5.4

