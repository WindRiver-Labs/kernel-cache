From 9fb19eef32eeef92aee27a63d569f33c3e207dfd Mon Sep 17 00:00:00 2001
From: Nicolae Rosia <nicolae.rosia@certsign.ro>
Date: Mon, 5 Jan 2015 18:12:13 +0200
Subject: [PATCH 030/456] ARM: zynq: xilinx_axidma: fix race condition in
 dma_intr_handler

On SMP platform when in IRQ, another CPU may be executing different
parts of the driver, which may read/write registers. Fix this by
acquiring the lock before read/write-ing the DMA registers.

Signed-off-by: Nicolae Rosia <nicolae.rosia@certsign.ro>
Signed-off-by: Michal Simek <michal.simek@xilinx.com>
(cherry picked from commit da2d296bb6b89f7bc7644f6b552b9766ac1c17d5)
---
 drivers/dma/xilinx/xilinx_axidma.c |   17 ++++++++++++-----
 1 files changed, 12 insertions(+), 5 deletions(-)

diff --git a/drivers/dma/xilinx/xilinx_axidma.c b/drivers/dma/xilinx/xilinx_axidma.c
index 332b71b..30f8e02 100644
--- a/drivers/dma/xilinx/xilinx_axidma.c
+++ b/drivers/dma/xilinx/xilinx_axidma.c
@@ -505,10 +505,15 @@ static irqreturn_t dma_intr_handler(int irq, void *data)
 {
 	struct xilinx_dma_chan *chan = data;
 	u32 stat;
+	irqreturn_t ret = IRQ_HANDLED;
+
+	spin_lock(&chan->lock);
 
 	stat = dma_read(chan, XILINX_DMA_STATUS_OFFSET);
-	if (!(stat & XILINX_DMA_XR_IRQ_ALL_MASK))
-		return IRQ_NONE;
+	if (!(stat & XILINX_DMA_XR_IRQ_ALL_MASK)) {
+		ret = IRQ_NONE;
+		goto out_unlock;
+	}
 
 	/* Ack the interrupts */
 	dma_write(chan, XILINX_DMA_STATUS_OFFSET,
@@ -532,14 +537,16 @@ static irqreturn_t dma_intr_handler(int irq, void *data)
 		dev_dbg(chan->dev, "Inter-packet latency too long\n");
 
 	if (stat & XILINX_DMA_XR_IRQ_IOC_MASK) {
-		spin_lock(&chan->lock);
 		xilinx_dma_update_completed_cookie(chan);
 		xilinx_dma_start_transfer(chan);
-		spin_unlock(&chan->lock);
 	}
 
+out_unlock:
+	spin_unlock(&chan->lock);
+
 	tasklet_schedule(&chan->tasklet);
-	return IRQ_HANDLED;
+
+	return ret;
 }
 
 static void dma_do_tasklet(unsigned long data)
-- 
1.7.5.4

