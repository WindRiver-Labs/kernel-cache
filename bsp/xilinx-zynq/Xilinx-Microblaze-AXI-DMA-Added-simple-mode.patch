From ee281a349af2d2067e57f1aca3a887ee5676fa90 Mon Sep 17 00:00:00 2001
From: SrikanthT <sthokal@xilinx.com>
Date: Tue, 22 Nov 2011 12:34:58 +0530
Subject: [PATCH 356/509] Xilinx: Microblaze: AXI DMA: Added simple mode.

https://github.com/analogdevicesinc/linux.git xcomm_zynq
commit 72cb09331fd5eb0f629a38c8d54d29cc811fd316

Added support for Simple Mode AXI DMA.

Signed-off-by: SrikanthT <sthokal@xilinx.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 drivers/dma/xilinx_dma.c |   63 ++++++++++++++++++++++++++++++++++++++-------
 1 files changed, 53 insertions(+), 10 deletions(-)

diff --git a/drivers/dma/xilinx_dma.c b/drivers/dma/xilinx_dma.c
index e27c54f..698318c 100644
--- a/drivers/dma/xilinx_dma.c
+++ b/drivers/dma/xilinx_dma.c
@@ -25,6 +25,7 @@
  *
  */
 
+
 #include <linux/init.h>
 #include <linux/module.h>
 #include <linux/slab.h>
@@ -522,6 +523,7 @@ static void xilinx_dma_start_transfer(struct xilinx_dma_chan *chan)
 {
 	unsigned long flags;
 	struct xilinx_dma_desc_sw *desch, *desct;
+	struct xilinx_dma_desc_hw *hw;
 
 	if (chan->err)
 		return;
@@ -546,28 +548,66 @@ static void xilinx_dma_start_transfer(struct xilinx_dma_chan *chan)
 	if (chan->err)
 		goto out_unlock;
 
-	desch = list_first_entry(&chan->pending_list,
-			struct xilinx_dma_desc_sw, node);
+	if (chan->has_SG) {
+		desch = list_first_entry(&chan->pending_list,
+				struct xilinx_dma_desc_sw, node);
+
+		desct = container_of(chan->pending_list.prev,
+				struct xilinx_dma_desc_sw, node);
+
+		DMA_OUT(&chan->regs->cdr, desch->async_tx.phys);
+
+		dma_start(chan);
+
+		if (chan->err)
+			goto out_unlock;
+		list_splice_tail_init(&chan->pending_list, &chan->active_list);
+
+		/* Enable interrupts
+		*/
+		DMA_OUT(&chan->regs->cr,
+			DMA_IN(&chan->regs->cr) | XILINX_DMA_XR_IRQ_ALL_MASK);
+
+		/* Update tail ptr register and start the transfer
+		*/
+		DMA_OUT(&chan->regs->tdr, desct->async_tx.phys);
+		goto out_unlock;
+	}
+
+	/* In simple mode
+	*/
+
+	dma_halt(chan);
 
-	desct = container_of(chan->pending_list.prev,
-			struct xilinx_dma_desc_sw, node);
+	if (chan->err)
+		goto out_unlock;
 
-	DMA_OUT(&chan->regs->cdr, desch->async_tx.phys);
+	printk(KERN_INFO "xilinx_dma_start_transfer::simple DMA mode\n");
+
+	desch = list_first_entry(&chan->pending_list,
+				struct xilinx_dma_desc_sw, node);
+
+	list_del(&desch->node);
+	list_add_tail(&desch->node, &chan->active_list);
 
 	dma_start(chan);
 
 	if (chan->err)
 		goto out_unlock;
-	list_splice_tail_init(&chan->pending_list, &chan->active_list);
+
+	hw = &desch->hw;
 
 	/* Enable interrupts
 	*/
 	DMA_OUT(&chan->regs->cr,
 		DMA_IN(&chan->regs->cr) | XILINX_DMA_XR_IRQ_ALL_MASK);
 
-	/* Update tail ptr register and start the transfer
+	DMA_OUT(&chan->regs->src, hw->buf_addr);
+
+	/* Start the transfer
 	*/
-	DMA_OUT(&chan->regs->tdr, desct->async_tx.phys);
+	DMA_OUT(&chan->regs->btt_ref,
+		hw->control & XILINX_DMA_MAX_TRANS_LEN);
 
 out_unlock:
 	spin_unlock_irqrestore(&chan->lock, flags);
@@ -1552,7 +1592,9 @@ static int __devinit xilinx_dma_chan_probe(struct xilinx_dma_device *xdev,
 	}
 
 	if (feature & XILINX_DMA_IP_DMA) {
-		chan->has_SG = 1;
+		chan->has_SG = (xdev->feature & XILINX_DMA_FTR_HAS_SG) >>
+					XILINX_DMA_FTR_HAS_SG_SHIFT;
+
 		chan->start_transfer = xilinx_dma_start_transfer;
 
 		if (of_device_is_compatible(node,
@@ -1713,7 +1755,8 @@ static int __devinit xilinx_dma_of_probe(struct platform_device *op,
 				NULL);
 		if (value) {
 			if (be32_to_cpup(value) == 1) {
-				xdev->feature |= XILINX_DMA_FTR_STSCNTRL_STRM;
+				xdev->feature |= (XILINX_DMA_FTR_STSCNTRL_STRM |
+							XILINX_DMA_FTR_HAS_SG);
 			}
 		}
 
-- 
1.7.5.4

