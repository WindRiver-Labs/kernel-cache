From 8df33b008f8fe42a0b2ab9967f2656dff0863607 Mon Sep 17 00:00:00 2001
From: Zhong Hongbo <hongbo.zhong@windriver.com>
Date: Thu, 18 Sep 2014 15:45:42 +0800
Subject: [PATCH 182/182] pcie: msi: Using the cascade irq handler instead of
 registering irq action

I think the hardware specification for the ZYNQ'S pci interrupt as the
following

1. Disable CONFIG_PCI_MSI
All the pci device will share the pci host irq.

2. Enable CONFIG_PCI_MSI.

In the arm enviroment, all the msi interrupt just only
chain to the pci host irq.

Up to now, The kernel implement the first enviroment. But in the second
conditions, at first the PCI host will register irq using the request_irq
method. If some msi generate the irq request, there will be called for
the request_irq handle. The handle will read the msi register and call
generic_handle_irq to deal with the relatively msi irq.

In preempt-rt, The handle is threaded thought request_irq to register
handle in the no NO_THREAD flags. So It is unsafe in the tread to deal
with msi interrupt.

So using the chain interrupt method, when the mis irq is triggered,
the system will call the handle with no thread. So that is safe.

WARNING: at kernel/irq/handle.c:148 handle_irq_event_percpu+0x1cc/0x450()
irq 214 handler irq_default_primary_handler+0x0/0x1c enabled interrupts
Modules linked in:
CPU: 1 PID: 29 Comm: irq/91-zynqpcie Not tainted 3.10.38-ltsi-rt34-WR6.0.0.0_preempt-rt #11
hub 1-1:1.0: USB hub found
hub 1-1:1.0: 4 ports detected
[<80017628>] (unwind_backtrace+0x0/0xec) from [<8001264c>] (show_stack+0x20/0x24)
[<8001264c>] (show_stack+0x20/0x24) from [<806e6eec>] (dump_stack+0x20/0x28)
[<806e6eec>] (dump_stack+0x20/0x28) from [<8002976c>] (warn_slowpath_common+0x5c/0x7c)
[<8002976c>] (warn_slowpath_common+0x5c/0x7c) from [<800297cc>] (warn_slowpath_fmt+0x40/0x48)
[<800297cc>] (warn_slowpath_fmt+0x40/0x48) from [<800b3ea4>] (handle_irq_event_percpu+0x1cc/0x450)
[<800b3ea4>] (handle_irq_event_percpu+0x1cc/0x450) from [<800b4174>] (handle_irq_event+0x4c/0x6c)
[<800b4174>] (handle_irq_event+0x4c/0x6c) from [<800b6ce4>] (handle_simple_irq+0xac/0xbc)
[<800b6ce4>] (handle_simple_irq+0xac/0xbc) from [<800b3484>] (generic_handle_irq+0x30/0x40)
[<800b3484>] (generic_handle_irq+0x30/0x40) from [<80020dd0>] (xaxi_pcie_intr_handler+0x21c/0x32c)
[<80020dd0>] (xaxi_pcie_intr_handler+0x21c/0x32c) from [<800b4d1c>] (irq_forced_thread_fn+0x30/0x60)
[<800b4d1c>] (irq_forced_thread_fn+0x30/0x60) from [<800b4fb0>] (irq_thread+0xec/0x180)
[<800b4fb0>] (irq_thread+0xec/0x180) from [<800558a0>] (kthread+0xb4/0xbc)
[<800558a0>] (kthread+0xb4/0xbc) from [<8000dee8>] (ret_from_fork+0x14/0x20)
---[ end trace 0000000000000002 ]---

Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
(cherry picked from commit 9a63fdcd8c8cac779e6d85acd1008b2a04c37692)
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 arch/arm/mach-zynq/xaxipcie.c |   27 +++++++++++++++++++++++++--
 1 files changed, 25 insertions(+), 2 deletions(-)

diff --git a/arch/arm/mach-zynq/xaxipcie.c b/arch/arm/mach-zynq/xaxipcie.c
index 8926d89..eb07ebf 100644
--- a/arch/arm/mach-zynq/xaxipcie.c
+++ b/arch/arm/mach-zynq/xaxipcie.c
@@ -26,6 +26,7 @@
 #include <linux/kernel.h>
 #include <linux/interrupt.h>
 #include <linux/irq.h>
+#include <linux/irqchip/chained_irq.h>
 #include <linux/clk.h>
 #include <linux/delay.h>
 #include <linux/export.h>
@@ -644,7 +645,7 @@ static int xaxi_pcie_map_irq(const struct pci_dev *dev, u8 slot, u8 pin)
 }
 
 /* Interrupt handler */
-static irqreturn_t xaxi_pcie_intr_handler(int irq, void *data)
+static irqreturn_t xaxi_pcie_handler(int irq, void *data)
 {
 	struct xaxi_pcie_port *port = (struct xaxi_pcie_port *)data;
 	u32 val = 0, mask = 0;
@@ -794,6 +795,22 @@ static irqreturn_t xaxi_pcie_intr_handler(int irq, void *data)
 	return IRQ_HANDLED;
 }
 
+#ifdef CONFIG_PCI_MSI
+static void xaxi_pcie_intr_handler(unsigned int irq, struct irq_desc *desc)
+{
+	struct irq_chip *chip = irq_get_chip(irq);
+
+	chained_irq_enter(chip, desc);
+	xaxi_pcie_handler(irq, irq_get_handler_data(irq));
+	chained_irq_exit(chip, desc);
+}
+#else
+static irqreturn_t xaxi_pcie_intr_handler(int irq, void *data)
+{
+	return xaxi_pcie_handler(irq, data)
+}
+#endif
+
 /**
  * xaxi_pcie_init_port - Initialize hardware
  * @port: A pointer to a pcie port that needs to be initialized
@@ -805,9 +822,10 @@ static irqreturn_t xaxi_pcie_intr_handler(int irq, void *data)
 static int xaxi_pcie_init_port(struct xaxi_pcie_port *port)
 {
 	void __iomem *base_addr_remap = NULL;
-	int err = 0;
 #ifdef CONFIG_PCI_MSI
 	unsigned long xaxipcie_msg_addr;
+#else
+	int err = 0;
 #endif
 
 	base_addr_remap = ioremap(port->reg_base, port->reg_len);
@@ -865,6 +883,10 @@ static int xaxi_pcie_init_port(struct xaxi_pcie_port *port)
 	 */
 	bridge_enable(port->base_addr_remap);
 
+#if CONFIG_PCI_MSI
+	irq_set_handler_data(port->irq_num, port);
+	irq_set_chained_handler(port->irq_num, xaxi_pcie_intr_handler);
+#else
 	/* Register Interrupt Handler */
 	err = request_irq(port->irq_num, xaxi_pcie_intr_handler,
 					IRQF_SHARED, "zynqpcie", port);
@@ -872,6 +894,7 @@ static int xaxi_pcie_init_port(struct xaxi_pcie_port *port)
 		pr_err("%s: Could not allocate interrupt\n", __func__);
 		return err;
 	}
+#endif
 
 	return 0;
 }
-- 
1.7.5.4

