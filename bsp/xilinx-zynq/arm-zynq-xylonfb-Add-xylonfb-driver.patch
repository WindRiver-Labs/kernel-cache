From f2ea2dca2afddff39f515c296a9a0f826eb82c0d Mon Sep 17 00:00:00 2001
From: Liming Wang <liming.wang@windriver.com>
Date: Thu, 6 Dec 2012 20:44:15 +0800
Subject: [PATCH 39/50] arm/zynq, xylonfb: Add xylonfb driver

Taken from git tree:
git://git.xilinx.com/linux-xlnx.git tag xilinx-14.3-build2-trd

Mainly taken from the commit:

commit 2c13b866 Xilinx: ARM: Frame buffer driver release from Xylon (4th July)

	- Driver reorganized and divided in 3 major functional blocks.
	- Some driver functionality re-implemented to mach the above architecture
	- Added support for runtime display resolution change
	- Added IOCTL functionality for advanced usage of logiCVC capabilities
	- Added standard and specific logiCVC video mode timing parameters settin
	   > Standard parameters are calculated by kernel submodule
	   > specific parameters are defined in DTS
	- Added new DTS configuration parameters

Signed-off-by: Davor Joja <davor.joja@logicbricks.com>
Signed-off-by: Pallav Joshi <pallav.joshi@xilinx.com>
Signed-off-by: Liming Wang <liming.wang@windriver.com>
---
 drivers/video/Kconfig                              |    2 +
 drivers/video/Makefile                             |    1 +
 drivers/video/xylon/Kconfig                        |    1 +
 drivers/video/xylon/Makefile                       |    1 +
 drivers/video/xylon/xylonfb/Kconfig                |   55 +
 drivers/video/xylon/xylonfb/Makefile               |    2 +
 drivers/video/xylon/xylonfb/core/logicvc.h         |  165 +++
 drivers/video/xylon/xylonfb/core/xylonfb-ioctl.c   |  515 +++++++
 drivers/video/xylon/xylonfb/core/xylonfb-pixclk.c  |  136 ++
 drivers/video/xylon/xylonfb/core/xylonfb.c         | 1493 ++++++++++++++++++++
 drivers/video/xylon/xylonfb/core/xylonfb.h         |  130 ++
 drivers/video/xylon/xylonfb/of/Makefile            |    4 +
 drivers/video/xylon/xylonfb/of/xylonfb-of.c        |  432 ++++++
 drivers/video/xylon/xylonfb/platform/Makefile      |    4 +
 .../xylon/xylonfb/platform/xylonfb-platform.c      |  207 +++
 include/linux/xylonfb.h                            |   73 +
 include/linux/xylonfb_platform.h                   |   58 +
 17 files changed, 3279 insertions(+), 0 deletions(-)
 create mode 100644 drivers/video/xylon/Kconfig
 create mode 100644 drivers/video/xylon/Makefile
 create mode 100644 drivers/video/xylon/xylonfb/Kconfig
 create mode 100644 drivers/video/xylon/xylonfb/Makefile
 create mode 100644 drivers/video/xylon/xylonfb/core/logicvc.h
 create mode 100644 drivers/video/xylon/xylonfb/core/xylonfb-ioctl.c
 create mode 100644 drivers/video/xylon/xylonfb/core/xylonfb-pixclk.c
 create mode 100644 drivers/video/xylon/xylonfb/core/xylonfb.c
 create mode 100644 drivers/video/xylon/xylonfb/core/xylonfb.h
 create mode 100644 drivers/video/xylon/xylonfb/of/Makefile
 create mode 100644 drivers/video/xylon/xylonfb/of/xylonfb-of.c
 create mode 100644 drivers/video/xylon/xylonfb/platform/Makefile
 create mode 100644 drivers/video/xylon/xylonfb/platform/xylonfb-platform.c
 create mode 100644 include/linux/xylonfb.h
 create mode 100644 include/linux/xylonfb_platform.h

diff --git a/drivers/video/Kconfig b/drivers/video/Kconfig
index 2d1811a..e70515e 100644
--- a/drivers/video/Kconfig
+++ b/drivers/video/Kconfig
@@ -2490,6 +2490,8 @@ config FB_PUV3_UNIGFX
 	  Choose this option if you want to use the Unigfx device as a
 	  framebuffer device. Without the support of PCI & AGP.
 
+source "drivers/video/xylon/Kconfig"
+
 source "drivers/video/omap/Kconfig"
 source "drivers/video/omap2/Kconfig"
 source "drivers/video/exynos/Kconfig"
diff --git a/drivers/video/Makefile b/drivers/video/Makefile
index e3b14b0..cba9480 100644
--- a/drivers/video/Makefile
+++ b/drivers/video/Makefile
@@ -136,6 +136,7 @@ obj-$(CONFIG_FB_SM501)            += sm501fb.o
 obj-$(CONFIG_FB_UDL)		  += udlfb.o
 obj-$(CONFIG_FB_SMSCUFX)	  += smscufx.o
 obj-$(CONFIG_FB_XILINX)           += xilinxfb.o
+obj-$(CONFIG_FB_XYLON)            += xylon/
 obj-$(CONFIG_SH_MIPI_DSI)	  += sh_mipi_dsi.o
 obj-$(CONFIG_FB_SH_MOBILE_HDMI)	  += sh_mobile_hdmi.o
 obj-$(CONFIG_FB_SH_MOBILE_MERAM)  += sh_mobile_meram.o
diff --git a/drivers/video/xylon/Kconfig b/drivers/video/xylon/Kconfig
new file mode 100644
index 0000000..b67a430
--- /dev/null
+++ b/drivers/video/xylon/Kconfig
@@ -0,0 +1 @@
+source "drivers/video/xylon/xylonfb/Kconfig"
diff --git a/drivers/video/xylon/Makefile b/drivers/video/xylon/Makefile
new file mode 100644
index 0000000..b5b9b2f
--- /dev/null
+++ b/drivers/video/xylon/Makefile
@@ -0,0 +1 @@
+obj-$(CONFIG_FB_XYLON) += xylonfb/
diff --git a/drivers/video/xylon/xylonfb/Kconfig b/drivers/video/xylon/xylonfb/Kconfig
new file mode 100644
index 0000000..a1dca06
--- /dev/null
+++ b/drivers/video/xylon/xylonfb/Kconfig
@@ -0,0 +1,55 @@
+menuconfig FB_XYLON
+	tristate "Xylon logiCVC frame buffer support"
+	depends on FB
+	default n
+	select FB_CFB_FILLRECT
+	select FB_CFB_COPYAREA
+	select FB_CFB_IMAGEBLIT
+	help
+	  Choose this option if you want to use the Xylon logiCVC as frame
+	  buffer device. Without the support of PCI & AGP.
+
+choice
+	prompt "Xylon frame buffer driver type"
+	depends on FB_XYLON
+	default FB_XYLON_PLATFORM
+
+config FB_XYLON_PLATFORM
+	bool "Xylon logiCVC frame buffer platform driver"
+	help
+	  Choose this option if you want to use the Xylon frame buffer driver
+	  as platform driver type. This is selected by default.
+
+config FB_XYLON_OF
+	bool "Xylon logiCVC frame buffer Open Firmware driver"
+	help
+	  Choose this option if you want to use the Xylon frame buffer driver
+	  as Open Firmware driver type.
+endchoice
+
+choice
+	prompt "Xylon logiCVC pixel clock source"
+	depends on FB_XYLON
+	default FB_XYLON_ZYNQ_PS_PIXCLK
+
+config FB_XYLON_EXT_PIXCLK
+	bool "External pixel clock"
+	help
+	  Pixel clock is generated from external clock generator which is not
+	  controllable by Xylon framebuffer driver.
+
+config FB_XYLON_ZYNQ_PS_PIXCLK
+	bool "Zynq PS pixel clock"
+	help
+	  Support for pixel clock generation from Zynq PS internal clock generator.
+
+config FB_XYLON_ZC702_PIXCLK
+	bool "ZC702 board pixel clock"
+	select SYSFS
+	select I2C
+	select MISC_DEVICES
+	select SI570
+	select ADV7511
+	help
+	  Support for pixel clock generation from ZC702 SI570 clock generator.
+endchoice
diff --git a/drivers/video/xylon/xylonfb/Makefile b/drivers/video/xylon/xylonfb/Makefile
new file mode 100644
index 0000000..d5e6ec2
--- /dev/null
+++ b/drivers/video/xylon/xylonfb/Makefile
@@ -0,0 +1,2 @@
+obj-$(CONFIG_FB_XYLON_OF) += of/
+obj-$(CONFIG_FB_XYLON_PLATFORM) += platform/
diff --git a/drivers/video/xylon/xylonfb/core/logicvc.h b/drivers/video/xylon/xylonfb/core/logicvc.h
new file mode 100644
index 0000000..9f70f51
--- /dev/null
+++ b/drivers/video/xylon/xylonfb/core/logicvc.h
@@ -0,0 +1,165 @@
+/*
+ * Xylon logiCVC IP core v2.05c definitions
+ *
+ * Author: Xylon d.o.o.
+ * e-mail: davor.joja@logicbricks.com
+ *
+ * 2012 (c) Xylon d.o.o.
+ *
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2.  This program is licensed "as is" without any warranty of any
+ * kind, whether express or implied.
+ */
+
+#ifndef __LOGICVC_H__
+#define __LOGICVC_H__
+
+/* All logiCVC registers are 32 bit registers */
+/* All logiCVC registers are at 8 byte distance */
+#define LOGICVC_REG_DIST_USED      8
+/* R_HSY_FP */
+#define LOGICVC_SHSY_FP_ROFF      (0  * LOGICVC_REG_DIST_USED)
+/* R_HSY */
+#define LOGICVC_SHSY_ROFF         (1  * LOGICVC_REG_DIST_USED)
+/* R_HSY_BP */
+#define LOGICVC_SHSY_BP_ROFF      (2  * LOGICVC_REG_DIST_USED)
+/* R_HSY_RES */
+#define LOGICVC_SHSY_RES_ROFF     (3  * LOGICVC_REG_DIST_USED)
+/* R_VSY_FP */
+#define LOGICVC_SVSY_FP_ROFF      (4  * LOGICVC_REG_DIST_USED)
+/* R_VSY */
+#define LOGICVC_SVSY_ROFF         (5  * LOGICVC_REG_DIST_USED)
+/* R_VSY_BP */
+#define LOGICVC_SVSY_BP_ROFF      (6  * LOGICVC_REG_DIST_USED)
+/* R_VSY_RES */
+#define LOGICVC_SVSY_RES_ROFF     (7  * LOGICVC_REG_DIST_USED)
+/* R_CTRL */
+#define LOGICVC_SCTRL_ROFF        (8  * LOGICVC_REG_DIST_USED)
+/* R_DTYPE */
+#define LOGICVC_SDTYPE_ROFF       (9  * LOGICVC_REG_DIST_USED)
+/* R_BACKGROUND */
+#define LOGICVC_BACKCOL_ROFF      (10 * LOGICVC_REG_DIST_USED)
+/* R_DOUBLE_VBUFF */
+#define LOGICVC_DOUBLE_VBUFF_ROFF (11 * LOGICVC_REG_DIST_USED)
+/* R_DOUBLE_CLUT */
+#define LOGICVC_DOUBLE_CLUT_ROFF  (12 * LOGICVC_REG_DIST_USED)
+/* R_INT */
+#define LOGICVC_INT_ROFF          (13 * LOGICVC_REG_DIST_USED)
+/* R_INT_MASK */
+#define LOGICVC_INT_MASK_ROFF     (14 * LOGICVC_REG_DIST_USED)
+/* R_PWRCTRL */
+#define LOGICVC_SPWRCTRL_ROFF     (15 * LOGICVC_REG_DIST_USED)
+
+/* logiCVC layer registers base and distance between the layers */
+/* distance between groups of layer registers */
+#define LOGICVC_LAYER_DISTANCE   (16  * LOGICVC_REG_DIST_USED)
+/* offset to the beginning of layer 0 registers */
+#define LOGICVC_LAYER0_BASE_ROFF (32  * LOGICVC_REG_DIST_USED)
+/* offset to the beginning of layer 1 registers */
+#define LOGICVC_LAYER1_BASE_ROFF \
+	(LOGICVC_LAYER0_BASE_ROFF + LOGICVC_LAYER_DISTANCE * 1)
+/* offset to the beginning of layer 2 registers */
+#define LOGICVC_LAYER2_BASE_ROFF \
+	(LOGICVC_LAYER0_BASE_ROFF + LOGICVC_LAYER_DISTANCE * 2)
+/* offset to the beginning of layer 3 registers */
+#define LOGICVC_LAYER3_BASE_ROFF \
+	(LOGICVC_LAYER0_BASE_ROFF + LOGICVC_LAYER_DISTANCE * 3)
+/* offset to the beginning of layer 4 registers */
+#define LOGICVC_LAYER4_BASE_ROFF \
+	(LOGICVC_LAYER0_BASE_ROFF + LOGICVC_LAYER_DISTANCE * 4)
+
+/* logiCVC layer registers offsets (common for each layer) */
+/*  LH_OFFSET */
+#define LOGICVC_LAYER_HOR_OFF_ROFF (0 * LOGICVC_REG_DIST_USED)
+/*  LV_OFFSET */
+#define LOGICVC_LAYER_VER_OFF_ROFF (1 * LOGICVC_REG_DIST_USED)
+/*  LH_POSITION */
+#define LOGICVC_LAYER_HOR_POS_ROFF (2 * LOGICVC_REG_DIST_USED)
+/*  LV_POSITION */
+#define LOGICVC_LAYER_VER_POS_ROFF (3 * LOGICVC_REG_DIST_USED)
+/*  LH_WIDTH */
+#define LOGICVC_LAYER_WIDTH_ROFF   (4 * LOGICVC_REG_DIST_USED)
+/*  LV_HEIGHT */
+#define LOGICVC_LAYER_HEIGHT_ROFF  (5 * LOGICVC_REG_DIST_USED)
+/*  ALPHA */
+#define LOGICVC_LAYER_ALPHA_ROFF   (6 * LOGICVC_REG_DIST_USED)
+/*  CTRL */
+#define LOGICVC_LAYER_CTRL_ROFF    (7 * LOGICVC_REG_DIST_USED)
+/*  TRANSPARENT */
+#define LOGICVC_LAYER_TRANSP_ROFF  (8 * LOGICVC_REG_DIST_USED)
+
+/* logiCVC interrupt bits */
+#define LOGICVC_L0_VBUFF_SW_INT   0x01
+#define LOGICVC_L1_VBUFF_SW_INT   0x02
+#define LOGICVC_L2_VBUFF_SW_INT   0x04
+#define LOGICVC_L3_VBUFF_SW_INT   0x08
+#define LOGICVC_L4_VBUFF_SW_INT   0x10
+#define LOGICVC_V_SYNC_INT        0x20
+#define LOGICVC_E_VIDEO_VALID_INT 0x40
+#define LOGICVC_L0_CLUT_SW_INT    0x100
+#define LOGICVC_L1_CLUT_SW_INT    0x200
+#define LOGICVC_L2_CLUT_SW_INT    0x400
+#define LOGICVC_L3_CLUT_SW_INT    0x800
+#define LOGICVC_L4_CLUT_SW_INT    0x1000
+
+/* logiCVC layer base offsets */
+#define LOGICVC_LAYER_BASE_OFFSET 0x100
+#define LOGICVC_LAYER_0_OFFSET    0
+#define LOGICVC_LAYER_1_OFFSET    0x80
+#define LOGICVC_LAYER_2_OFFSET    0x100
+#define LOGICVC_LAYER_3_OFFSET    0x180
+#define LOGICVC_LAYER_4_OFFSET    0x200
+
+/* logiCVC layer CLUT base offsets */
+#define LOGICVC_CLUT_BASE_OFFSET      0x1000
+#define LOGICVC_CLUT_L0_CLUT_0_OFFSET 0
+#define LOGICVC_CLUT_L0_CLUT_1_OFFSET 0x800
+#define LOGICVC_CLUT_L1_CLUT_0_OFFSET 0x1000
+#define LOGICVC_CLUT_L1_CLUT_1_OFFSET 0x1800
+#define LOGICVC_CLUT_L2_CLUT_0_OFFSET 0x2000
+#define LOGICVC_CLUT_L2_CLUT_1_OFFSET 0x2800
+#define LOGICVC_CLUT_L3_CLUT_0_OFFSET 0x3000
+#define LOGICVC_CLUT_L3_CLUT_1_OFFSET 0x3800
+#define LOGICVC_CLUT_L4_CLUT_0_OFFSET 0x4000
+#define LOGICVC_CLUT_L4_CLUT_1_OFFSET 0x4800
+#define LOGICVC_CLUT_REGISTER_SIZE    8
+#define LOGICVC_CLUT_0_INDEX_OFFSET   2
+#define LOGICVC_CLUT_1_INDEX_OFFSET   1
+
+/* logiCVC register and CLUT base offsets */
+#define LOGICVC_GENERAL_REGISTERS_RANGE 0x100
+#define LOGICVC_REGISTERS_RANGE         0x6000
+
+/* logiCVC register initial values */
+#define CTRL_REG_INIT 0x001F
+#define SD_REG_INIT   0
+
+/* logiCVC display power signals */
+#define LOGICVC_EN_BLIGHT_MSK 0x01
+#define LOGICVC_EN_VDD_MSK    0x02
+#define LOGICVC_EN_VEE_MSK    0x04
+#define LOGICVC_V_EN_MSK      0x08
+
+/* logiCVC various definitions */
+#define LOGICVC_PIX_DATA_INVERT        0x80
+#define LOGICVC_PIX_ACT_HIGH           0x100
+#define LOGICVC_SWAP_RB                0x10
+#define LOGICVC_MAX_LAYERS             5
+#define LOGICVC_LAYER_ON               0x10
+#define LOGICVC_MAX_XRES               2048
+#define LOGICVC_MAX_VRES               2048
+#define TRANSPARENT_COLOR_8BPP         0x25       /* dummy */
+#define TRANSPARENT_COLOR_8BPP_CLUT_16 0xF813     /* dummy */
+#define TRANSPARENT_COLOR_8BPP_CLUT_24 0x00FF009C /* dummy */
+#define TRANSPARENT_COLOR_16BPP        0xF813     /* dummy */
+#define TRANSPARENT_COLOR_24BPP        0x00FF009C /* dummy */
+#define BACKGROUND_COLOR               0x00000000
+
+enum xylonfb_alpha_format {
+	LOGICVC_LAYER_ALPHA = 0,
+	LOGICVC_PIXEL_ALPHA,
+	LOGICVC_CLUT_16BPP_ALPHA,
+	LOGICVC_CLUT_32BPP_ALPHA
+};
+
+#endif /* __LOGICVC_H__ */
diff --git a/drivers/video/xylon/xylonfb/core/xylonfb-ioctl.c b/drivers/video/xylon/xylonfb/core/xylonfb-ioctl.c
new file mode 100644
index 0000000..996134c
--- /dev/null
+++ b/drivers/video/xylon/xylonfb/core/xylonfb-ioctl.c
@@ -0,0 +1,515 @@
+/*
+ * Xylon logiCVC frame buffer driver IOCTL functions
+ *
+ * Author: Xylon d.o.o.
+ * e-mail: davor.joja@logicbricks.com
+ *
+ * This driver was based on skeletonfb.c and other fb video drivers.
+ * 2012 Xylon d.o.o.
+ *
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2.  This program is licensed "as is" without any warranty of any
+ * kind, whether express or implied.
+ */
+
+
+#include <linux/uaccess.h>
+#include <linux/xylonfb.h>
+#include "logicvc.h"
+#include "xylonfb.h"
+
+
+static int xylonfb_get_vblank(struct fb_vblank *vblank, struct fb_info *fbi)
+{
+	vblank->flags |= FB_VBLANK_HAVE_VSYNC;
+
+	return 0;
+}
+
+static int xylonfb_wait_for_vsync(u32 crt, struct fb_info *fbi)
+{
+	struct xylonfb_layer_data *layer_data = fbi->par;
+	struct xylonfb_common_data *common_data = layer_data->xylonfb_cd;
+	u32 imr;
+	int ret, cnt;
+
+	mutex_lock(&common_data->irq_mutex);
+
+	cnt = common_data->xylonfb_vsync.cnt;
+
+	/* prepare LOGICVC V-sync interrupt */
+	imr = readl(layer_data->reg_base_virt + LOGICVC_INT_MASK_ROFF);
+	imr &= (~LOGICVC_V_SYNC_INT);
+	/* clear LOGICVC V-sync interrupt */
+	writel(LOGICVC_V_SYNC_INT, layer_data->reg_base_virt + LOGICVC_INT_ROFF);
+	/* enable LOGICVC V-sync interrupt */
+	writel(imr, layer_data->reg_base_virt + LOGICVC_INT_MASK_ROFF);
+
+	ret = wait_event_interruptible_timeout(
+			common_data->xylonfb_vsync.wait,
+			(cnt != common_data->xylonfb_vsync.cnt), HZ/10);
+
+	/* disable LOGICVC V-sync interrupt */
+	imr |= LOGICVC_V_SYNC_INT;
+	writel(imr, layer_data->reg_base_virt + LOGICVC_INT_MASK_ROFF);
+
+	mutex_unlock(&common_data->irq_mutex);
+
+	if (ret < 0)
+		return ret;
+	else if (ret == 0)
+		return -ETIMEDOUT;
+
+	return 0;
+}
+
+static unsigned int alpha_normalized(unsigned int alpha,
+	unsigned int used_bits, bool get)
+{
+	if (get)
+		return ((((255 << 16) / ((1 << used_bits)-1)) * alpha) >> 16);
+	else
+		return (alpha / (255 / ((1 << used_bits)-1)));
+}
+
+static int xylonfb_layer_alpha(struct xylonfb_layer_data *layer_data,
+	unsigned int *alpha, bool get)
+{
+	unsigned int used_bits;
+
+	if (layer_data->layer_fix.alpha_mode != LOGICVC_LAYER_ALPHA)
+		return -EPERM;
+
+	switch (layer_data->layer_fix.bpp_virt) {
+	case 8:
+		used_bits = 3;
+		break;
+	case 16:
+		used_bits = 6;
+		break;
+	case 32:
+		used_bits = 8;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	if (get) {
+		*alpha =
+			readl(layer_data->layer_reg_base_virt + LOGICVC_LAYER_ALPHA_ROFF);
+		*alpha &= (0xFF >> (8-used_bits));
+	}
+
+	/* get/set normalized alpha value */
+	*alpha = alpha_normalized(*alpha, used_bits, get);
+
+	if (!get)
+		writel(*alpha,
+			layer_data->layer_reg_base_virt + LOGICVC_LAYER_ALPHA_ROFF);
+
+	return 0;
+}
+
+static int xylonfb_layer_color_rgb(struct xylonfb_layer_data *layer_data,
+	struct xylonfb_layer_color *layer_color, unsigned int reg_offset, bool get)
+{
+	void *base;
+	u32 raw_rgb, r, g, b;
+	int bpp, alpha_mode;
+
+	if (reg_offset == LOGICVC_LAYER_TRANSP_ROFF) {
+		base = layer_data->layer_reg_base_virt;
+		bpp = layer_data->layer_fix.bpp_virt;
+		alpha_mode = layer_data->layer_fix.alpha_mode;
+	} else {
+		base = layer_data->reg_base_virt;
+		bpp = layer_data->xylonfb_cd->bg_layer_bpp;
+		alpha_mode = layer_data->xylonfb_cd->bg_layer_alpha_mode;
+	}
+
+	if (get) {
+		raw_rgb = readl(base + reg_offset);
+check_bpp_get:
+		/* convert HW color format to RGB-888 */
+		switch (bpp) {
+		case 8:
+			switch (alpha_mode) {
+			case LOGICVC_CLUT_16BPP_ALPHA:
+				/* RGB-565 */
+				bpp = 16;
+				goto check_bpp_get;
+				break;
+			case LOGICVC_CLUT_32BPP_ALPHA:
+				/* RGB-888 */
+				bpp = 32;
+				goto check_bpp_get;
+				break;
+			default:
+				/* RGB-332 */
+				r = raw_rgb >> 5;
+				r = (((r << 3) | r) << 2) | (r >> 1);
+				g = (raw_rgb >> 2) & 0x07;
+				g = (((g << 3) | g) << 2) | (g >> 1);
+				b = raw_rgb & 0x03;
+				b = (b << 6) | (b << 4) | (b << 2) | b;
+				break;
+			}
+			break;
+		case 16:
+			/* RGB-565 */
+			r = raw_rgb >> 11;
+			r = (r << 3) | (r >> 2);
+			g = (raw_rgb >> 5) & 0x3F;
+			g = (g << 2) | (g >> 4);
+			b = raw_rgb & 0x1F;
+			b = (b << 3) | (b >> 2);
+			break;
+		case 32:
+			/* RGB-888 */
+			r = raw_rgb >> 16;
+			g = (raw_rgb >> 8) & 0xFF;
+			b = raw_rgb & 0xFF;
+			break;
+		default:
+			raw_rgb = r = g = b = 0;
+		}
+		layer_color->raw_rgb = raw_rgb;
+		layer_color->r = (u8)r;
+		layer_color->g = (u8)g;
+		layer_color->b = (u8)b;
+	} else {
+		if (layer_color->use_raw) {
+			raw_rgb = layer_color->raw_rgb;
+		} else {
+			r = layer_color->r;
+			g = layer_color->g;
+			b = layer_color->b;
+check_bpp_set:
+			/* convert RGB-888 to HW color format */
+			switch (bpp) {
+			case 8:
+				switch (alpha_mode) {
+				case LOGICVC_CLUT_16BPP_ALPHA:
+					/* RGB-565 */
+					bpp = 16;
+					goto check_bpp_set;
+					break;
+				case LOGICVC_CLUT_32BPP_ALPHA:
+					/* RGB-888 */
+					bpp = 32;
+					goto check_bpp_set;
+					break;
+				default:
+					raw_rgb =
+						(r & 0xE0) | ((g & 0xE0) >> 3) | ((b & 0xC0) >> 6);
+					break;
+				}
+				break;
+			case 16:
+				raw_rgb =
+					((r & 0xF8) << 8) | ((g & 0xFC) << 3) | ((b & 0xF8) >> 3);
+				break;
+			case 32:
+				raw_rgb = (r << 16) | (g << 8) | b;
+				break;
+			default:
+				raw_rgb = 0;
+			}
+		}
+		writel(raw_rgb, base + reg_offset);
+	}
+
+	return 0;
+}
+
+static int xylonfb_layer_pos_sz(struct fb_info *fbi,
+	struct xylonfb_layer_pos_size *layer_pos_sz, bool get)
+{
+	struct xylonfb_layer_data *layer_data = fbi->par;
+	u32 x, y, width, height, xres, yres;
+
+	xres = fbi->var.xres;
+	yres = fbi->var.yres;
+
+	if (get) {
+		x = readl(layer_data->layer_reg_base_virt + LOGICVC_LAYER_HOR_POS_ROFF);
+		layer_pos_sz->x = xres - (x + 1);
+		y = readl(layer_data->layer_reg_base_virt + LOGICVC_LAYER_VER_POS_ROFF);
+		layer_pos_sz->y = yres - (y + 1);
+		layer_pos_sz->width =
+			readl(layer_data->layer_reg_base_virt + LOGICVC_LAYER_WIDTH_ROFF);
+		layer_pos_sz->width += 1;
+		layer_pos_sz->height =
+			readl(layer_data->layer_reg_base_virt + LOGICVC_LAYER_HEIGHT_ROFF);
+		layer_pos_sz->height += 1;
+	} else {
+		x = layer_pos_sz->x;
+		y = layer_pos_sz->y;
+		width = layer_pos_sz->width;
+		height = layer_pos_sz->height;
+
+		if ((x > xres) || (y > yres))
+			return -EINVAL;
+
+		if ((x + width) > xres) {
+			width = xres - x;
+			layer_pos_sz->width = width;
+		}
+		if ((y + height) > yres) {
+			height = yres - y;
+			layer_pos_sz->height = height;
+		}
+
+		writel((width - 1),
+			layer_data->layer_reg_base_virt + LOGICVC_LAYER_WIDTH_ROFF);
+		writel((height - 1),
+			layer_data->layer_reg_base_virt + LOGICVC_LAYER_HEIGHT_ROFF);
+		writel((xres - (x + 1)),
+			layer_data->layer_reg_base_virt + LOGICVC_LAYER_HOR_POS_ROFF);
+		writel((yres - (y + 1)),
+			layer_data->layer_reg_base_virt + LOGICVC_LAYER_VER_POS_ROFF);
+	}
+
+	return 0;
+}
+
+int xylonfb_ioctl(struct fb_info *fbi, unsigned int cmd, unsigned long arg)
+{
+	struct xylonfb_layer_data *layer_data = fbi->par;
+	union {
+		struct fb_vblank vblank;
+		struct xylonfb_layer_color layer_color;
+		struct xylonfb_layer_pos_size layer_pos_sz;
+		struct xylonfb_hw_access hw_access;
+	} ioctl;
+	void __user *argp = (void __user *)arg;
+	u32 var32;
+	unsigned long val, layer_buffs, layer_id;
+	int ret = 0;
+
+	switch (cmd) {
+	case FBIOGET_VBLANK:
+		driver_devel("FBIOGET_VBLANK\n");
+		if (copy_from_user(&ioctl.vblank, argp, sizeof(ioctl.vblank)))
+			return -EFAULT;
+		ret = xylonfb_get_vblank(&ioctl.vblank, fbi);
+		if (!ret)
+			if (copy_to_user(argp, &ioctl.vblank, sizeof(ioctl.vblank)))
+				ret = -EFAULT;
+		break;
+
+	case FBIO_WAITFORVSYNC:
+		driver_devel("FBIO_WAITFORVSYNC\n");
+		if (get_user(var32, (u32 __user *)arg))
+			return -EFAULT;
+		ret = xylonfb_wait_for_vsync(var32, fbi);
+		break;
+
+	case XYLONFB_GET_LAYER_IDX:
+		driver_devel("XYLONFB_GET_LAYER_IDX\n");
+		val = layer_data->layer_fix.layer_fix_info & 0x0F;
+		put_user(val, (unsigned long __user *)arg);
+		break;
+
+	case XYLONFB_GET_LAYER_ALPHA:
+		driver_devel("XYLONFB_GET_LAYER_ALPHA\n");
+		ret = xylonfb_layer_alpha(layer_data, (unsigned int *)&val, true);
+		if (!ret)
+			put_user(val, (unsigned long __user *)arg);
+		break;
+
+	case XYLONFB_SET_LAYER_ALPHA:
+		driver_devel("XYLONFB_SET_LAYER_ALPHA\n");
+		if (get_user(val, (unsigned long __user *)arg))
+			return -EFAULT;
+		mutex_lock(&layer_data->layer_mutex);
+		ret = xylonfb_layer_alpha(layer_data, (unsigned int *)&val, false);
+		mutex_unlock(&layer_data->layer_mutex);
+		break;
+
+	case XYLONFB_LAYER_COLOR_TRANSP:
+		driver_devel("XYLONFB_LAYER_COLOR_TRANSP\n");
+		if (get_user(val, (unsigned long __user *)arg))
+			return -EFAULT;
+		mutex_lock(&layer_data->layer_mutex);
+		var32 =
+			readl(layer_data->layer_reg_base_virt + LOGICVC_LAYER_CTRL_ROFF);
+		if (val)
+			var32 |= (1 << 1); /* logiCVC layer transparency disabled */
+		else
+			var32 &= ~(1 << 1); /* logiCVC layer transparency enabled */
+		writel(var32,
+			layer_data->layer_reg_base_virt + LOGICVC_LAYER_CTRL_ROFF);
+		mutex_unlock(&layer_data->layer_mutex);
+		break;
+
+	case XYLONFB_GET_LAYER_COLOR_TRANSP:
+		driver_devel("XYLONFB_GET_LAYER_COLOR_TRANSP\n");
+		if (copy_from_user(&ioctl.layer_color, argp,
+			sizeof(ioctl.layer_color)))
+			return -EFAULT;
+		ret = xylonfb_layer_color_rgb(layer_data, &ioctl.layer_color,
+			LOGICVC_LAYER_TRANSP_ROFF, true);
+		if (!ret)
+			if (copy_to_user(argp, &ioctl.layer_color,
+				sizeof(ioctl.layer_color)))
+				ret = -EFAULT;
+		break;
+
+	case XYLONFB_SET_LAYER_COLOR_TRANSP:
+		driver_devel("XYLONFB_SET_LAYER_COLOR_TRANSP\n");
+		if (copy_from_user(&ioctl.layer_color, argp,
+			sizeof(ioctl.layer_color)))
+			return -EFAULT;
+		mutex_lock(&layer_data->layer_mutex);
+		ret = xylonfb_layer_color_rgb(layer_data, &ioctl.layer_color,
+			LOGICVC_LAYER_TRANSP_ROFF, false);
+		mutex_unlock(&layer_data->layer_mutex);
+		break;
+
+	case XYLONFB_GET_LAYER_SIZE_POS:
+		driver_devel("XYLONFB_GET_LAYER_SIZE_POS\n");
+		if (copy_from_user(&ioctl.layer_pos_sz, argp,
+			sizeof(ioctl.layer_pos_sz)))
+			return -EFAULT;
+		ret = xylonfb_layer_pos_sz(fbi, &ioctl.layer_pos_sz, true);
+		if (!ret)
+			if (copy_to_user(argp, &ioctl.layer_pos_sz,
+				sizeof(ioctl.layer_pos_sz)))
+				ret = -EFAULT;
+		break;
+
+	case XYLONFB_SET_LAYER_SIZE_POS:
+		driver_devel("XYLONFB_SET_LAYER_SIZE_POS\n");
+		if (copy_from_user(&ioctl.layer_pos_sz, argp,
+			sizeof(ioctl.layer_pos_sz)))
+			return -EFAULT;
+		mutex_lock(&layer_data->layer_mutex);
+		ret = xylonfb_layer_pos_sz(fbi, &ioctl.layer_pos_sz, false);
+		if (!ret)
+			if (copy_to_user(argp, &ioctl.layer_pos_sz,
+				sizeof(ioctl.layer_pos_sz)))
+				ret = -EFAULT;
+		mutex_unlock(&layer_data->layer_mutex);
+		break;
+
+	case XYLONFB_GET_LAYER_BUFFER:
+		driver_devel("XYLONFB_GET_LAYER_BUFFER\n");
+		layer_id = layer_data->layer_fix.layer_fix_info & 0x0F;
+		var32 = readl(layer_data->reg_base_virt + LOGICVC_DOUBLE_VBUFF_ROFF);
+		var32 >>= ((layer_id << 1)); /* get buffer */
+		val = var32 & 0x03;
+		put_user(val, (unsigned long __user *)arg);
+		break;
+
+	case XYLONFB_SET_LAYER_BUFFER:
+		driver_devel("XYLONFB_SET_LAYER_BUFFER\n");
+		if (get_user(val, (unsigned long __user *)arg))
+			return -EFAULT;
+		layer_buffs = layer_data->layer_fix.layer_fix_info >> 4;
+		if (val >= layer_buffs)
+			return -EINVAL;
+		layer_id = layer_data->layer_fix.layer_fix_info & 0x0F;
+		mutex_lock(&layer_data->layer_mutex);
+		var32 = readl(layer_data->reg_base_virt + LOGICVC_DOUBLE_VBUFF_ROFF);
+		var32 |= (1 << (10 + layer_id)); /* set layer */
+		var32 &= ~(0x03 << (layer_id << 1)); /* clear previous buffer */
+		var32 |= (val << (layer_id << 1)); /* set buffer */
+		writel(var32, layer_data->reg_base_virt + LOGICVC_DOUBLE_VBUFF_ROFF);
+		ret = xylonfb_wait_for_vsync(var32, fbi);
+		mutex_unlock(&layer_data->layer_mutex);
+		break;
+
+	case XYLONFB_GET_LAYER_BUFFER_OFFSET:
+		driver_devel("XYLONFB_GET_LAYER_BUFFER_OFFSET\n");
+		layer_buffs = layer_data->layer_fix.layer_fix_info >> 4;
+		layer_id = layer_data->layer_fix.layer_fix_info & 0x0F;
+		var32 = readl(layer_data->reg_base_virt + LOGICVC_DOUBLE_VBUFF_ROFF);
+		var32 >>= ((layer_id << 1)); /* get buffer */
+		var32 &= 0x03;
+		val = layer_data->layer_fix.height / layer_buffs;
+		val *= var32;
+		put_user(val, (unsigned long __user *)arg);
+		break;
+
+	case XYLONFB_GET_LAYER_BUFFERS_NUM:
+		driver_devel("XYLONFB_GET_LAYER_BUFFERS_NUM\n");
+		layer_buffs = layer_data->layer_fix.layer_fix_info >> 4;
+		put_user(layer_buffs, (unsigned long __user *)arg);
+		break;
+
+	case XYLONFB_GET_BACKGROUND_COLOR:
+		driver_devel("XYLONFB_GET_BACKGROUND_COLOR\n");
+		if (layer_data->xylonfb_cd->bg_layer_bpp == 0)
+			return -EPERM;
+		if (copy_from_user(&ioctl.layer_color, argp,
+			sizeof(ioctl.layer_color)))
+			return -EFAULT;
+		ret = xylonfb_layer_color_rgb(layer_data, &ioctl.layer_color,
+			LOGICVC_BACKCOL_ROFF, true);
+		if (!ret)
+			if (copy_to_user(argp, &ioctl.layer_color,
+				sizeof(ioctl.layer_color)))
+				ret = -EFAULT;
+		break;
+
+	case XYLONFB_SET_BACKGROUND_COLOR:
+		driver_devel("XYLONFB_SET_BACKGROUND_COLOR\n");
+		if (layer_data->xylonfb_cd->bg_layer_bpp == 0)
+			return -EPERM;
+		if (copy_from_user(&ioctl.layer_color, argp,
+			sizeof(ioctl.layer_color)))
+			return -EFAULT;
+		mutex_lock(&layer_data->layer_mutex);
+		ret = xylonfb_layer_color_rgb(layer_data, &ioctl.layer_color,
+			LOGICVC_BACKCOL_ROFF, false);
+		mutex_unlock(&layer_data->layer_mutex);
+		break;
+
+	case XYLONFB_LAYER_EXT_BUFF_SWITCH:
+		driver_devel("XYLONFB_LAYER_EXT_BUFF_SWITCH\n");
+		if (get_user(val, (unsigned long __user *)arg))
+			return -EFAULT;
+		mutex_lock(&layer_data->layer_mutex);
+		var32 =
+			readl(layer_data->layer_reg_base_virt + LOGICVC_LAYER_CTRL_ROFF);
+		if (val)
+			var32 |= (1 << 2);
+		else
+			var32 &= ~(1 << 2);
+		writel(var32,
+			layer_data->layer_reg_base_virt + LOGICVC_LAYER_CTRL_ROFF);
+		mutex_unlock(&layer_data->layer_mutex);
+		break;
+
+	case XYLONFB_READ_HW_REG:
+		driver_devel("XYLONFB_READ_HW_REG\n");
+		if (copy_from_user(&ioctl.hw_access, argp,
+			sizeof(ioctl.hw_access)))
+			return -EFAULT;
+		ioctl.hw_access.value =
+			readl(layer_data->reg_base_virt + ioctl.hw_access.offset);
+		if (copy_to_user(argp, &ioctl.hw_access,
+			sizeof(ioctl.hw_access)))
+			ret = -EFAULT;
+		break;
+
+	case XYLONFB_WRITE_HW_REG:
+		driver_devel("XYLONFB_READ_HW_REG\n");
+		if (copy_from_user(&ioctl.hw_access, argp,
+			sizeof(ioctl.hw_access)))
+			return -EFAULT;
+		writel(ioctl.hw_access.value,
+			layer_data->reg_base_virt + ioctl.hw_access.offset);
+		if (copy_to_user(argp, &ioctl.hw_access,
+			sizeof(ioctl.hw_access)))
+			ret = -EFAULT;
+		break;
+
+	default:
+		driver_devel("IOCTL_ERROR\n");
+		ret = -EINVAL;
+	}
+
+	return ret;
+}
diff --git a/drivers/video/xylon/xylonfb/core/xylonfb-pixclk.c b/drivers/video/xylon/xylonfb/core/xylonfb-pixclk.c
new file mode 100644
index 0000000..35af7cc
--- /dev/null
+++ b/drivers/video/xylon/xylonfb/core/xylonfb-pixclk.c
@@ -0,0 +1,136 @@
+/*
+ * Xylon logiCVC frame buffer driver pixel clock generation
+ *
+ * Author: Xylon d.o.o.
+ * e-mail: davor.joja@logicbricks.com
+ *
+ * 2012 (c) Xylon d.o.o.
+ *
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2.  This program is licensed "as is" without any warranty of any
+ * kind, whether express or implied.
+ */
+
+
+/*
+ * This file implements HW dependent functionality for controlling pixel clock
+ * generation on various HW platforms.
+ */
+
+
+#define HW_PIXEL_CLOCK_CHANGE_SUPPORTED 1
+
+
+#if defined(CONFIG_FB_XYLON_EXT_PIXCLK)
+
+#if defined (HW_PIXEL_CLOCK_CHANGE_SUPPORTED)
+#undef HW_PIXEL_CLOCK_CHANGE_SUPPORTED
+#endif
+#define HW_PIXEL_CLOCK_CHANGE_SUPPORTED 0
+int xylonfb_hw_pixclk_set(unsigned long pixclk_khz)
+{
+	pr_info("Pixel clock change not supported\n");
+	return 0;
+}
+
+#elif defined(CONFIG_FB_XYLON_ZYNQ_PS_PIXCLK)
+
+int xylonfb_hw_pixclk_set(unsigned long pixclk_khz)
+{
+	unsigned long pllclk, sysclk;
+	unsigned long div, delta, delta_dec, delta_inc;
+	void *slcr_regs, *clk_regs, *rst_reg;
+
+	/* all clock values are in kHz */
+	pllclk = 1000000;
+	sysclk = 100000;
+
+	slcr_regs = ioremap_nocache(0xF8000004, 8);
+	if (!slcr_regs) {
+		pr_err("Error mapping SLCR\n");
+		return -EBUSY;
+	}
+	clk_regs = ioremap_nocache(0xF8000170, 32);
+	if (!clk_regs) {
+		pr_err("Error setting xylonfb pixelclock\n");
+		iounmap(slcr_regs);
+		return -EBUSY;
+	}
+	rst_reg = ioremap_nocache(0xF8000240, 4);
+	if (!rst_reg) {
+		pr_err("Error setting xylonfb pixelclock\n");
+		iounmap(clk_regs);
+		iounmap(slcr_regs);
+		return -EBUSY;
+	}
+
+	/* unlock register access */
+	writel(0xDF0D, (slcr_regs+4));
+	/* calculate system clock divisor */
+//	div = pllclk / sysclk;
+	/* prepare for register writting */
+//	div = (div + 0x1000) << 8;
+	/* set system clock */
+//	writel(div, clk_regs);
+	/* calculate video clock divisor */
+	div = pllclk / pixclk_khz;
+	delta = (pllclk / div) - pixclk_khz;
+	if (delta != 0) {
+		delta_inc = pixclk_khz - (pllclk / (div+1));
+		delta_dec = (pllclk / (div-1)) - pixclk_khz;
+		if (delta < delta_inc) {
+			if (delta > delta_dec)
+				div--;
+			//else
+			//	div = div;
+		} else {
+			if (delta > delta_dec) {
+				if (delta_inc > delta_dec)
+					div--;
+				else
+					div++;
+			} else {
+				div++;
+			}
+		}
+	}
+	/* prepare for register writting */
+	div = (div + 0x1000) << 8;
+	/* set video clock */
+	writel(div, (clk_regs+0x10));
+	/* reset FPGA */
+//	writel(0, rst_reg);
+//	writel(0x1, rst_reg);
+//	writel(0, rst_reg);
+	/* lock register access */
+	writel(0x767B, slcr_regs);
+
+	iounmap(rst_reg);
+	iounmap(clk_regs);
+	iounmap(slcr_regs);
+
+	return 0;
+}
+
+#elif defined(CONFIG_FB_XYLON_ZC702_PIXCLK)
+
+#include <linux/i2c/si570.h>
+
+int xylonfb_hw_pixclk_set(unsigned long pixclk_khz)
+{
+	struct i2c_client *si570_client;
+
+	si570_client = get_i2c_client_si570();
+	if (si570_client)
+		return set_frequency_si570(&si570_client->dev, (pixclk_khz * 1000));
+	else
+		return -EPERM;
+}
+
+#endif
+
+
+bool xylonfb_hw_pixclk_change(void)
+{
+	return HW_PIXEL_CLOCK_CHANGE_SUPPORTED;
+}
diff --git a/drivers/video/xylon/xylonfb/core/xylonfb.c b/drivers/video/xylon/xylonfb/core/xylonfb.c
new file mode 100644
index 0000000..539bedc
--- /dev/null
+++ b/drivers/video/xylon/xylonfb/core/xylonfb.c
@@ -0,0 +1,1493 @@
+/*
+ * Xylon logiCVC frame buffer driver core functions
+ *
+ * Author: Xylon d.o.o.
+ * e-mail: davor.joja@logicbricks.com
+ *
+ * This driver was based on skeletonfb.c and other framebuffer video drivers.
+ * 2012 Xylon d.o.o.
+ *
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2.  This program is licensed "as is" without any warranty of any
+ * kind, whether express or implied.
+ */
+
+/*
+	Usefull driver information:
+	- driver does not support multiple instances of logiCVC-ML
+	- logiCVC-ML background layer is recomended
+	- platform driver default resolution is set with defines in xylonfb-vmode.h
+ */
+
+
+#include <linux/module.h>
+#include <linux/dma-mapping.h>
+#include <linux/delay.h>
+#include <linux/uaccess.h>
+#include <linux/console.h>
+#include "xylonfb.h"
+
+
+#define XYLONFB_PSEUDO_PALETTE_SZ 256
+
+
+static struct xylonfb_vmode_data xylonfb_vmode = {
+	.fb_vmode = {
+		.refresh = 60,
+		.xres = 1024,
+		.yres = 768,
+		.pixclock = KHZ2PICOS(65000),
+		.left_margin = 160,
+		.right_margin = 24,
+		.upper_margin = 29,
+		.lower_margin = 3,
+		.hsync_len = 136,
+		.vsync_len = 6,
+		.vmode = FB_VMODE_NONINTERLACED
+	},
+	.fb_vmode_name = "1024x768"
+};
+
+static unsigned short logicvc_layer_reg_offset[] = {
+	(LOGICVC_LAYER_BASE_OFFSET + LOGICVC_LAYER_0_OFFSET),
+	(LOGICVC_LAYER_BASE_OFFSET + LOGICVC_LAYER_1_OFFSET),
+	(LOGICVC_LAYER_BASE_OFFSET + LOGICVC_LAYER_2_OFFSET),
+	(LOGICVC_LAYER_BASE_OFFSET + LOGICVC_LAYER_3_OFFSET),
+	(LOGICVC_LAYER_BASE_OFFSET + LOGICVC_LAYER_4_OFFSET)
+};
+
+static unsigned short logicvc_clut_reg_offset[] = {
+	(LOGICVC_CLUT_BASE_OFFSET + LOGICVC_CLUT_L0_CLUT_0_OFFSET),
+	(LOGICVC_CLUT_BASE_OFFSET + LOGICVC_CLUT_L0_CLUT_1_OFFSET),
+	(LOGICVC_CLUT_BASE_OFFSET + LOGICVC_CLUT_L1_CLUT_0_OFFSET),
+	(LOGICVC_CLUT_BASE_OFFSET + LOGICVC_CLUT_L1_CLUT_1_OFFSET),
+	(LOGICVC_CLUT_BASE_OFFSET + LOGICVC_CLUT_L2_CLUT_0_OFFSET),
+	(LOGICVC_CLUT_BASE_OFFSET + LOGICVC_CLUT_L2_CLUT_1_OFFSET),
+	(LOGICVC_CLUT_BASE_OFFSET + LOGICVC_CLUT_L3_CLUT_0_OFFSET),
+	(LOGICVC_CLUT_BASE_OFFSET + LOGICVC_CLUT_L3_CLUT_1_OFFSET),
+	(LOGICVC_CLUT_BASE_OFFSET + LOGICVC_CLUT_L4_CLUT_0_OFFSET),
+	(LOGICVC_CLUT_BASE_OFFSET + LOGICVC_CLUT_L4_CLUT_1_OFFSET)
+};
+
+static char *xylonfb_mode_option;
+
+/* Function declarations */
+static int xylonfb_set_timings(struct fb_info *fbi, int bpp);
+static void xylonfb_logicvc_disp_ctrl(struct fb_info *fbi, bool enable);
+static void xylonfb_start_logicvc(struct fb_info *fbi);
+static void xylonfb_stop_logicvc(struct fb_info *fbi);
+static void xylonfb_enable_logicvc_layer(struct fb_info *fbi);
+static void xylonfb_disable_logicvc_layer(struct fb_info *fbi);
+
+
+extern int xylonfb_hw_pixclk_set(unsigned long pixclk_khz);
+extern bool xylonfb_hw_pixclk_change(void);
+
+
+static irqreturn_t xylonfb_isr(int irq, void *dev_id)
+{
+	struct fb_info **afbi = (struct fb_info **)dev_id;
+	struct fb_info *fbi = afbi[0];
+	struct xylonfb_layer_data *layer_data = fbi->par;
+	struct xylonfb_common_data *common_data = layer_data->xylonfb_cd;
+	u32 isr;
+
+	driver_devel("%s IRQ %d\n", __func__, irq);
+
+	isr = readl(layer_data->reg_base_virt + LOGICVC_INT_ROFF);
+	if (isr & LOGICVC_V_SYNC_INT) {
+		writel(LOGICVC_V_SYNC_INT,
+			layer_data->reg_base_virt + LOGICVC_INT_ROFF);
+		common_data->xylonfb_vsync.cnt++;
+		wake_up_interruptible(&common_data->xylonfb_vsync.wait);
+		return IRQ_HANDLED;
+	} else {
+		return IRQ_NONE;
+	}
+}
+
+static int xylonfb_open(struct fb_info *fbi, int user)
+{
+	struct xylonfb_layer_data *layer_data = fbi->par;
+
+	driver_devel("%s\n", __func__);
+
+	if (layer_data->layer_use_ref == 0) {
+		/* turn on layer */
+		xylonfb_enable_logicvc_layer(fbi);
+		/* set layer ON flag */
+		layer_data->layer_flags |= LOGICVC_LAYER_ON;
+	}
+	layer_data->layer_use_ref++;
+	layer_data->xylonfb_cd->xylonfb_use_ref++;
+
+	return 0;
+}
+
+static int xylonfb_release(struct fb_info *fbi, int user)
+{
+	struct xylonfb_layer_data *layer_data = fbi->par;
+
+	driver_devel("%s\n", __func__);
+
+	layer_data->layer_use_ref--;
+	if (layer_data->layer_use_ref == 0) {
+		/* turn off layer */
+		xylonfb_disable_logicvc_layer(fbi);
+		/* set layer OFF flag */
+		layer_data->layer_flags &= (~LOGICVC_LAYER_ON);
+	}
+	layer_data->xylonfb_cd->xylonfb_use_ref--;
+
+	return 0;
+}
+
+static int xylonfb_check_var(struct fb_var_screeninfo *var, struct fb_info *fbi)
+{
+	driver_devel("%s\n", __func__);
+
+	/* HW layer bpp value can not be changed */
+	if (var->bits_per_pixel != fbi->var.bits_per_pixel) {
+		if (var->bits_per_pixel == 24)
+			var->bits_per_pixel = 32;
+		else
+			return -EINVAL;
+	}
+
+	if (var->xres > LOGICVC_MAX_XRES)
+		var->xres = LOGICVC_MAX_XRES;
+	if (var->yres > LOGICVC_MAX_VRES)
+		var->yres = LOGICVC_MAX_VRES;
+
+	if (var->xres_virtual > fbi->var.xres_virtual)
+		var->xres_virtual = fbi->var.xres_virtual;
+	if (var->yres_virtual > fbi->var.yres_virtual)
+		var->yres_virtual = fbi->var.yres_virtual;
+
+	if (fbi->var.xres != 0)
+		if ((var->xoffset + fbi->var.xres) >= fbi->var.xres_virtual)
+			var->xoffset = fbi->var.xres_virtual - fbi->var.xres - 1;
+	if (fbi->var.yres != 0)
+		if ((var->yoffset + fbi->var.yres) >= fbi->var.yres_virtual)
+			var->yoffset = fbi->var.yres_virtual - fbi->var.yres - 1;
+
+	var->transp.offset = fbi->var.transp.offset;
+	var->transp.length = fbi->var.transp.length;
+	var->transp.msb_right = fbi->var.transp.msb_right;
+	var->red.offset = fbi->var.red.offset;
+	var->red.length = fbi->var.red.length;
+	var->red.msb_right = fbi->var.red.msb_right;
+	var->green.offset = fbi->var.green.offset;
+	var->green.length = fbi->var.green.length;
+	var->green.msb_right = fbi->var.green.msb_right;
+	var->blue.offset = fbi->var.blue.offset;
+	var->blue.length = fbi->var.blue.length;
+	var->blue.msb_right = fbi->var.blue.msb_right;
+	var->height = fbi->var.height;
+	var->width = fbi->var.width;
+	var->sync = fbi->var.sync;
+	var->rotate = fbi->var.rotate;
+
+	return 0;
+}
+
+static int xylonfb_set_par(struct fb_info *fbi)
+{
+	struct xylonfb_layer_data *layer_data = fbi->par;
+	struct xylonfb_common_data *common_data = layer_data->xylonfb_cd;
+	int rc;
+	char vmode_opt[20+1];
+
+	driver_devel("%s\n", __func__);
+
+	if ((fbi->var.xres > LOGICVC_MAX_XRES) ||
+		(fbi->var.yres > LOGICVC_MAX_VRES)) {
+		return -EINVAL;
+	}
+
+	if (common_data->xylonfb_flags & FB_VMODE_SET)
+		return 0;
+
+	if (xylonfb_hw_pixclk_change()) {
+		xylonfb_stop_logicvc(fbi);
+		xylonfb_logicvc_disp_ctrl(fbi, false);
+
+		if (!(common_data->xylonfb_flags & FB_VMODE_INIT)) {
+			sprintf(vmode_opt, "%dx%dM-%d@%d",
+				fbi->var.xres, fbi->var.yres,
+				fbi->var.bits_per_pixel,
+				common_data->vmode_data_current.fb_vmode.refresh);
+			if (!strcmp(common_data->vmode_data.fb_vmode_name, vmode_opt)) {
+				common_data->vmode_data_current = common_data->vmode_data;
+			} else {
+				xylonfb_mode_option = vmode_opt;
+				xylonfb_set_timings(fbi, fbi->var.bits_per_pixel);
+				xylonfb_mode_option = NULL;
+			}
+		}
+
+		rc = xylonfb_hw_pixclk_set(
+			PICOS2KHZ(common_data->vmode_data_current.fb_vmode.pixclock));
+		if (rc) {
+			pr_err("Error xylonfb changing pixel clock\n");
+			return rc;
+		}
+
+		xylonfb_start_logicvc(fbi);
+		xylonfb_logicvc_disp_ctrl(fbi, true);
+	}
+
+	pr_info("xylonfb video mode: %dx%d-%d@%d\n",
+		fbi->var.xres, fbi->var.yres, fbi->var.bits_per_pixel,
+		common_data->vmode_data_current.fb_vmode.refresh);
+
+	/* set flag used for finding video mode only once */
+	if (common_data->xylonfb_flags & FB_VMODE_INIT)
+		common_data->xylonfb_flags |= FB_VMODE_SET;
+	/* used only when resolution is changed */
+	if (!(common_data->xylonfb_flags & FB_VMODE_SET))
+		xylonfb_enable_logicvc_layer(fbi);
+
+	return 0;
+}
+
+static int xylonfb_set_color_hw(u16 *transp, u16 *red, u16 *green, u16 *blue,
+	int len, int idx, struct fb_info *fbi)
+{
+	struct xylonfb_layer_data *layer_data = fbi->par;
+	struct layer_fix_data *lfdata = &layer_data->layer_fix;
+	u32 pixel;
+	int bpp_virt, toff, roff, goff, boff;
+
+	driver_devel("%s\n", __func__);
+
+	bpp_virt = lfdata->bpp_virt;
+
+	toff = fbi->var.transp.offset;
+	roff = fbi->var.red.offset;
+	goff = fbi->var.green.offset;
+	boff = fbi->var.blue.offset;
+
+	if (fbi->fix.visual == FB_VISUAL_PSEUDOCOLOR) {
+		u32 clut_value;
+
+		if (idx > 255 || len > 256)
+			return -EINVAL;
+
+		if (lfdata->alpha_mode == LOGICVC_CLUT_16BPP_ALPHA) {
+			if (transp) {
+				while (len > 0) {
+					clut_value =
+						((((transp[idx] & 0xFC) >> 2) << toff) |
+						(((red[idx] & 0xF8) >> 3) << roff) |
+						(((green[idx] & 0xFC) >> 2) << goff) |
+						(((blue[idx] & 0xF8) >> 3) << boff));
+					writel(clut_value, layer_data->layer_clut_base_virt +
+						(idx*LOGICVC_CLUT_REGISTER_SIZE));
+					len--;
+					idx++;
+				}
+			} else {
+				while (len > 0) {
+					clut_value =
+						((0x3F << toff) |
+						(((red[idx] & 0xF8) >> 3) << roff) |
+						(((green[idx] & 0xFC) >> 2) << goff) |
+						(((blue[idx] & 0xF8) >> 3) << boff));
+					writel(clut_value, layer_data->layer_clut_base_virt +
+						(idx*LOGICVC_CLUT_REGISTER_SIZE));
+					len--;
+					idx++;
+				}
+			}
+		} else if (lfdata->alpha_mode == LOGICVC_CLUT_32BPP_ALPHA) {
+			if (transp) {
+				while (len > 0) {
+					clut_value =
+						(((transp[idx] & 0xFF) << toff) |
+						((red[idx] & 0xFF) << roff) |
+						((green[idx] & 0xFF) << goff) |
+						((blue[idx] & 0xFF) << boff));
+					writel(clut_value, layer_data->layer_clut_base_virt +
+						(idx*LOGICVC_CLUT_REGISTER_SIZE));
+					len--;
+					idx++;
+				}
+			} else {
+				while (len > 0) {
+					clut_value =
+						((0xFF << toff) |
+						((red[idx] & 0xFF) << roff) |
+						((green[idx] & 0xFF) << goff) |
+						((blue[idx] & 0xFF) << boff));
+					writel(clut_value, layer_data->layer_clut_base_virt +
+						(idx*LOGICVC_CLUT_REGISTER_SIZE));
+					len--;
+					idx++;
+				}
+			}
+		}
+	} else if (fbi->fix.visual == FB_VISUAL_TRUECOLOR) {
+		if (bpp_virt == 8) {
+			if (lfdata->alpha_mode == LOGICVC_LAYER_ALPHA) {
+				while (len > 0) {
+					pixel = ((((red[idx] & 0xE0) >> 5) << roff) |
+						(((green[idx] & 0xE0) >> 5) << goff) |
+						(((blue[idx] & 0xC0) >> 6) << boff));
+					((u32 *)(fbi->pseudo_palette))[idx] =
+						(pixel << 24) | (pixel << 16) | (pixel << 8) | pixel;
+					len--;
+					idx++;
+				}
+			} else if (lfdata->alpha_mode == LOGICVC_PIXEL_ALPHA) {
+				if (transp) {
+					while (len > 0) {
+						pixel = ((((transp[idx] & 0xE0) >> 5) << toff) |
+							(((red[idx] & 0xE0) >> 5) << roff) |
+							(((green[idx] & 0xE0) >> 5) << goff) |
+							(((blue[idx] & 0xC0) >> 6) << boff));
+						((u32 *)(fbi->pseudo_palette))[idx] =
+							(pixel << 16) | pixel;
+						len--;
+						idx++;
+					}
+				} else {
+					while (len > 0) {
+						pixel = ((0x07 << toff) |
+							(((red[idx] & 0xE0) >> 5) << roff) |
+							(((green[idx] & 0xE0) >> 5) << goff) |
+							(((blue[idx] & 0xC0) >> 6) << boff));
+						((u32 *)(fbi->pseudo_palette))[idx] =
+							(pixel << 16) | pixel;
+						len--;
+						idx++;
+					}
+				}
+			}
+		} else if (bpp_virt == 16) {
+			if (lfdata->alpha_mode == LOGICVC_LAYER_ALPHA) {
+				while (len > 0) {
+					pixel = ((((red[idx] & 0xF8) >> 3) << roff) |
+						(((green[idx] & 0xFC) >> 2) << goff) |
+						(((blue[idx] & 0xF8) >> 3) << boff));
+					((u32 *)(fbi->pseudo_palette))[idx] =
+						(pixel << 16) | pixel;
+					len--;
+					idx++;
+				}
+			} else if (lfdata->alpha_mode == LOGICVC_PIXEL_ALPHA) {
+				if (transp) {
+					while (len > 0) {
+						((u32 *)(fbi->pseudo_palette))[idx] =
+							((((transp[idx] & 0xFC) >> 2) << toff) |
+							(((red[idx] & 0xF8) >> 3) << roff) |
+							(((green[idx] & 0xFC) >> 2) << goff) |
+							(((blue[idx] & 0xF8) >> 3) << boff));
+						len--;
+						idx++;
+					}
+				} else {
+					while (len > 0) {
+						((u32 *)(fbi->pseudo_palette))[idx] =
+							((0x3F << toff) |
+							(((red[idx] & 0xF8) >> 3) << roff) |
+							(((green[idx] & 0xFC) >> 2) << goff) |
+							(((blue[idx] & 0xF8) >> 3) << boff));
+						len--;
+						idx++;
+					}
+				}
+			}
+		} else if (bpp_virt == 32) {
+			if (lfdata->alpha_mode == LOGICVC_LAYER_ALPHA) {
+				while (len > 0) {
+					((u32 *)(fbi->pseudo_palette))[idx] =
+						(((red[idx] & 0xFF) << roff) |
+						((green[idx] & 0xFF) << goff) |
+						((blue[idx] & 0xFF) << boff));
+					len--;
+					idx++;
+				}
+			} else if (lfdata->alpha_mode == LOGICVC_PIXEL_ALPHA) {
+				if (transp) {
+					while (len > 0) {
+						((u32 *)(fbi->pseudo_palette))[idx] =
+							(((transp[idx] & 0xFF) << toff) |
+							((red[idx] & 0xFF) << roff) |
+							((green[idx] & 0xFF) << goff) |
+							((blue[idx] & 0xFF) << boff));
+						len--;
+						idx++;
+					}
+				} else {
+					while (len > 0) {
+						((u32 *)(fbi->pseudo_palette))[idx] =
+							((0xFF << toff) |
+							((red[idx] & 0xFF) << roff) |
+							((green[idx] & 0xFF) << goff) |
+							((blue[idx] & 0xFF) << boff));
+						len--;
+						idx++;
+					}
+				}
+			}
+		}
+	} else {
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int xylonfb_set_color_reg(unsigned regno, unsigned red, unsigned green,
+	unsigned blue, unsigned transp, struct fb_info *fbi)
+{
+	driver_devel("%s\n", __func__);
+
+	return xylonfb_set_color_hw(
+			(u16 *)&transp,
+			(u16 *)&red,
+			(u16 *)&green,
+			(u16 *)&blue,
+			1, regno, fbi);
+}
+
+static int xylonfb_set_cmap(struct fb_cmap *cmap, struct fb_info *fbi)
+{
+	driver_devel("%s\n", __func__);
+
+	return
+		xylonfb_set_color_hw(cmap->transp, cmap->red, cmap->green, cmap->blue,
+			cmap->len, cmap->start, fbi);
+}
+
+static void xylonfb_set_pixels(struct fb_info *fbi,
+	struct xylonfb_layer_data *layer_data, int bpp, unsigned int pix)
+{
+	u32* vmem;
+	u8 *vmem8;
+	u16 *vmem16;
+	u32 *vmem32;
+	int x, y, pix_off;
+
+	driver_devel("%s\n", __func__);
+
+	vmem = layer_data->fb_virt +
+		(fbi->var.xoffset * (fbi->var.bits_per_pixel/4)) +
+		(fbi->var.yoffset * fbi->var.xres_virtual *
+		(fbi->var.bits_per_pixel/4));
+
+	switch (bpp) {
+	case 8:
+		vmem8 = (u8 *)vmem;
+		for (y = fbi->var.yoffset; y < fbi->var.yres; y++) {
+			pix_off = (y * fbi->var.xres_virtual);
+			for (x = fbi->var.xoffset; x < fbi->var.xres; x++)
+				vmem8[pix_off+x] = pix;
+		}
+		break;
+	case 16:
+		vmem16 = (u16 *)vmem;
+		for (y = fbi->var.yoffset; y < fbi->var.yres; y++) {
+			pix_off = (y * fbi->var.xres_virtual);
+			for (x = fbi->var.xoffset; x < fbi->var.xres; x++)
+				vmem16[pix_off+x] = pix;
+		}
+		break;
+	case 32:
+		vmem32 = (u32 *)vmem;
+		for (y = fbi->var.yoffset; y < fbi->var.yres; y++) {
+			pix_off = (y * fbi->var.xres_virtual);
+			for (x = fbi->var.xoffset; x < fbi->var.xres; x++)
+				vmem32[pix_off+x] = pix;
+		}
+		break;
+	}
+}
+
+static int xylonfb_blank(int blank_mode, struct fb_info *fbi)
+{
+	struct xylonfb_layer_data *layer_data = fbi->par;
+	struct layer_fix_data *lfdata = &layer_data->layer_fix;
+	u32 pix, reg;
+	int i;
+
+	driver_devel("%s\n", __func__);
+
+	switch (blank_mode) {
+	case FB_BLANK_UNBLANK:
+		driver_devel("FB_BLANK_UNBLANK\n");
+		reg = readl(layer_data->reg_base_virt + LOGICVC_SPWRCTRL_ROFF);
+		reg |= LOGICVC_V_EN_MSK;
+		writel(reg, layer_data->reg_base_virt + LOGICVC_SPWRCTRL_ROFF);
+		mdelay(50);
+		break;
+
+	case FB_BLANK_NORMAL:
+		driver_devel("FB_BLANK_NORMAL\n");
+		switch (lfdata->bpp_virt) {
+		case 8:
+			switch (lfdata->alpha_mode) {
+			case LOGICVC_LAYER_ALPHA:
+				xylonfb_set_pixels(fbi, layer_data, 8, 0x00);
+				break;
+			case LOGICVC_PIXEL_ALPHA:
+				xylonfb_set_pixels(fbi, layer_data, 16, 0xFF00);
+				break;
+			case LOGICVC_CLUT_16BPP_ALPHA:
+			case LOGICVC_CLUT_32BPP_ALPHA:
+				for (i = 0; i < 256; i++) {
+					pix = readl(layer_data->layer_clut_base_virt +
+						(i*LOGICVC_CLUT_REGISTER_SIZE));
+					pix &= 0x00FFFFFF;
+					if (pix == 0)
+						break;
+				}
+				xylonfb_set_pixels(fbi, layer_data, 8, i);
+				break;
+			}
+			break;
+		case 16:
+			switch (lfdata->alpha_mode) {
+			case LOGICVC_LAYER_ALPHA:
+				xylonfb_set_pixels(fbi, layer_data, 16, 0x0000);
+				break;
+			case LOGICVC_PIXEL_ALPHA:
+				xylonfb_set_pixels(fbi, layer_data, 32, 0xFF000000);
+				break;
+			}
+			break;
+		case 32:
+			xylonfb_set_pixels(fbi, layer_data, 32, 0xFF000000);
+			break;
+		}
+		break;
+
+	case FB_BLANK_POWERDOWN:
+		driver_devel("FB_BLANK_POWERDOWN\n");
+		reg = readl(layer_data->reg_base_virt + LOGICVC_SPWRCTRL_ROFF);
+		reg &= ~LOGICVC_V_EN_MSK;
+		writel(reg, layer_data->reg_base_virt + LOGICVC_SPWRCTRL_ROFF);
+		mdelay(50);
+		break;
+
+	case FB_BLANK_VSYNC_SUSPEND:
+	case FB_BLANK_HSYNC_SUSPEND:
+	default:
+		driver_devel("FB_BLANK_ not supported!\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int xylonfb_pan_display(struct fb_var_screeninfo *var,
+	struct fb_info *fbi)
+{
+	struct xylonfb_layer_data *layer_data = fbi->par;
+
+	driver_devel("%s\n", __func__);
+
+	if (fbi->var.xoffset == var->xoffset && fbi->var.yoffset == var->yoffset)
+		return 0;
+
+	/* check for negative values */
+	if (var->xoffset < 0)
+		var->xoffset += var->xres;
+	if (var->yoffset < 0)
+		var->yoffset += var->yres;
+
+	if (var->vmode & FB_VMODE_YWRAP) {
+		if (var->yoffset > fbi->var.yres_virtual ||
+			var->xoffset) {
+			return -EINVAL;
+		}
+	} else {
+		if (var->xoffset + var->xres > fbi->var.xres_virtual ||
+			var->yoffset + var->yres > fbi->var.yres_virtual) {
+			/* if smaller then physical layer video memory allow panning */
+			if ((var->xoffset + var->xres > layer_data->layer_fix.width)
+					||
+				(var->yoffset + var->yres > layer_data->layer_fix.height)) {
+				return -EINVAL;
+			}
+		}
+	}
+	fbi->var.xoffset = var->xoffset;
+	fbi->var.yoffset = var->yoffset;
+	if (var->vmode & FB_VMODE_YWRAP)
+		fbi->var.vmode |= FB_VMODE_YWRAP;
+	else
+		fbi->var.vmode &= ~FB_VMODE_YWRAP;
+	/* set layer memory X offset */
+	writel(var->xoffset,
+		(layer_data->layer_reg_base_virt + LOGICVC_LAYER_HOR_OFF_ROFF));
+	/* set layer memory Y offset */
+	writel(var->yoffset,
+		(layer_data->layer_reg_base_virt + LOGICVC_LAYER_VER_OFF_ROFF));
+	/* apply changes in logiCVC */
+	writel((var->yres-1),
+		(layer_data->layer_reg_base_virt + LOGICVC_LAYER_VER_POS_ROFF));
+
+	return 0;
+}
+
+
+static struct fb_ops xylonfb_ops = {
+	.owner = THIS_MODULE,
+	.fb_open = xylonfb_open,
+	.fb_release = xylonfb_release,
+	.fb_check_var = xylonfb_check_var,
+	.fb_set_par = xylonfb_set_par,
+	.fb_setcolreg = xylonfb_set_color_reg,
+	.fb_setcmap = xylonfb_set_cmap,
+	.fb_blank = xylonfb_blank,
+	.fb_pan_display = xylonfb_pan_display,
+	.fb_fillrect = cfb_fillrect,
+	.fb_copyarea = cfb_copyarea,
+	.fb_imageblit = cfb_imageblit,
+	.fb_cursor = NULL,
+	.fb_rotate = NULL,
+	.fb_sync = NULL,
+	.fb_ioctl = xylonfb_ioctl,
+	.fb_mmap = NULL,
+	.fb_get_caps = NULL,
+	.fb_destroy = NULL,
+};
+
+
+static int xylonfb_find_next_layer(struct layer_fix_data *lfdata,
+	int layers, int curr)
+{
+	u32 address, temp_address, loop_address;
+	int i, next;
+
+	driver_devel("%s\n", __func__);
+
+	address = lfdata[curr].offset * lfdata[curr].width * lfdata[curr].bpp;
+	temp_address = 0xFFFFFFFF;
+	next = -1;
+
+	for (i = 0; i < layers; i++) {
+		loop_address = lfdata[i].offset * lfdata[i].width * lfdata[i].bpp;
+		if (address < loop_address
+				&&
+			loop_address < temp_address) {
+			next = i;
+			temp_address = loop_address;
+		}
+	}
+
+	return next;
+}
+
+static void xylonfb_set_yvirt(struct layer_fix_data *lfdata,
+	unsigned long vmem_base_addr, unsigned long vmem_high_addr,
+	int layers, int curr)
+{
+	int next;
+
+	driver_devel("%s\n", __func__);
+
+	next = xylonfb_find_next_layer(lfdata, layers, curr);
+
+	if (next != -1) {
+		lfdata[curr].height =
+			((lfdata[next].width * (lfdata[next].bpp/8) *
+			lfdata[next].offset)
+				-
+			(lfdata[curr].width * (lfdata[curr].bpp/8) *
+			lfdata[curr].offset)) /
+			(lfdata[curr].width * (lfdata[curr].bpp/8));
+	} else { /* last physical logiCVC layer */
+		/* FIXME - this is fixed for 1920x1080 tripple buffering,
+			but it should be read from somewhere */
+		lfdata[curr].height = 3240;
+		while (1) {
+			if (((lfdata[curr].width * (lfdata[curr].bpp/8) *
+				lfdata[curr].height)
+					+
+				(lfdata[curr].width * (lfdata[curr].bpp/8) *
+				lfdata[curr].offset))
+					<=
+				(vmem_high_addr - vmem_base_addr))
+				break;
+			lfdata[curr].height -= 64; /* FIXME - magic number? */
+		}
+	}
+
+	lfdata[curr].layer_fix_info |=
+		((lfdata[curr].height / lfdata[curr].buffer_offset) << 4);
+}
+
+static int xylonfb_map(int id, int layers, struct device *dev,
+	struct xylonfb_layer_data *layer_data,
+	unsigned long vmem_base_addr, u32 reg_base_phys, void *reg_base_virt)
+{
+	struct layer_fix_data *lfdata = &layer_data->layer_fix;
+
+	driver_devel("%s\n", __func__);
+
+	/* logiCVC register mapping */
+	layer_data->reg_base_phys = reg_base_phys;
+	layer_data->reg_base_virt = reg_base_virt;
+	/* Video memory mapping */
+	layer_data->fb_phys = vmem_base_addr +
+		(lfdata->width * (lfdata->bpp/8) * lfdata->offset);
+	layer_data->fb_size =
+		lfdata->width * (lfdata->bpp/8) * lfdata->height;
+
+	if (layer_data->xylonfb_cd->xylonfb_flags & FB_DMA_BUFFER) {
+		/* NOT USED FOR NOW! */
+		layer_data->fb_virt = dma_alloc_writecombine(dev,
+			PAGE_ALIGN(layer_data->fb_size),
+			&layer_data->fb_phys, GFP_KERNEL);
+	} else {
+		layer_data->fb_virt =
+			ioremap_wc(layer_data->fb_phys, layer_data->fb_size);
+	}
+	/* check memory mappings */
+	if (!layer_data->reg_base_virt || !layer_data->fb_virt) {
+		pr_err("Error xylonfb ioremap REGS 0x%X FB 0x%X\n",
+			(unsigned int)layer_data->reg_base_virt,
+			(unsigned int)layer_data->fb_virt);
+		return -ENOMEM;
+	}
+	//memset_io((void __iomem *)layer_data->fb_virt, 0, layer_data->fb_size);
+	layer_data->layer_reg_base_virt =
+		layer_data->reg_base_virt + logicvc_layer_reg_offset[id];
+	layer_data->layer_clut_base_virt =
+		layer_data->reg_base_virt +
+		logicvc_clut_reg_offset[id*LOGICVC_CLUT_0_INDEX_OFFSET];
+	layer_data->layer_use_ref = 0;
+	layer_data->layer_flags = 0;
+
+	return 0;
+}
+
+static void xylonfb_set_fbi_timings(struct fb_info *fbi)
+{
+	struct xylonfb_layer_data *layer_data = fbi->par;
+	struct xylonfb_common_data *common_data = layer_data->xylonfb_cd;
+	struct fb_var_screeninfo *var = &fbi->var;
+
+	driver_devel("%s\n", __func__);
+
+	var->xres = common_data->vmode_data_current.fb_vmode.xres;
+	var->yres = common_data->vmode_data_current.fb_vmode.yres;
+	var->pixclock = common_data->vmode_data_current.fb_vmode.pixclock;
+	var->left_margin = common_data->vmode_data_current.fb_vmode.left_margin;
+	var->right_margin = common_data->vmode_data_current.fb_vmode.right_margin;
+	var->upper_margin = common_data->vmode_data_current.fb_vmode.upper_margin;
+	var->lower_margin = common_data->vmode_data_current.fb_vmode.lower_margin;
+	var->hsync_len = common_data->vmode_data_current.fb_vmode.hsync_len;
+	var->vsync_len = common_data->vmode_data_current.fb_vmode.vsync_len;
+	var->sync = common_data->vmode_data_current.fb_vmode.sync;
+	var->vmode = common_data->vmode_data_current.fb_vmode.vmode;
+}
+
+static void xylonfb_set_hw_specifics(struct fb_info *fbi,
+	struct xylonfb_layer_data *layer_data, struct layer_fix_data *lfdata,
+	u32 reg_base_phys)
+{
+	driver_devel("%s\n", __func__);
+
+	fbi->fix.smem_start = layer_data->fb_phys;
+	fbi->fix.smem_len = layer_data->fb_size;
+	fbi->fix.type = FB_TYPE_PACKED_PIXELS;
+	if ((lfdata->bpp == 8) &&
+		((lfdata->alpha_mode == LOGICVC_CLUT_16BPP_ALPHA) ||
+		(lfdata->alpha_mode == LOGICVC_CLUT_32BPP_ALPHA))) {
+		fbi->fix.visual = FB_VISUAL_PSEUDOCOLOR;
+	} else {
+		/*
+			Other logiCVC layer pixel formats:
+			- 8 bpp: LAYER or PIXEL alpha
+			  It is not true color, RGB triplet is stored in 8 bits.
+			- 16 bpp:
+			  LAYER alpha: RGB triplet is stored in 16 bits
+			  PIXEL alpha: ARGB quadriplet is stored in 32 bits
+			- 32 bpp: LAYER or PIXEL alpha
+			  True color, RGB triplet or ARGB quadriplet is stored in 32 bits.
+		*/
+		fbi->fix.visual = FB_VISUAL_TRUECOLOR;
+	}
+	/* sanity check */
+	if ((lfdata->bpp != 8) &&
+		((lfdata->alpha_mode == LOGICVC_CLUT_16BPP_ALPHA) ||
+		(lfdata->alpha_mode == LOGICVC_CLUT_32BPP_ALPHA))) {
+		pr_warning("xylonfb invalid layer alpha!\n");
+		lfdata->alpha_mode = LOGICVC_LAYER_ALPHA;
+	}
+
+	fbi->fix.xpanstep = 1;
+	fbi->fix.ypanstep = 1;
+	fbi->fix.ywrapstep = LOGICVC_MAX_VRES;
+	fbi->fix.line_length = lfdata->width * (lfdata->bpp/8);
+	fbi->fix.mmio_start = reg_base_phys;
+	fbi->fix.mmio_len = LOGICVC_REGISTERS_RANGE;
+	fbi->fix.accel = FB_ACCEL_NONE;
+
+	fbi->var.xres_virtual = lfdata->width;
+	if (lfdata->height <= LOGICVC_MAX_VRES)
+		fbi->var.yres_virtual = lfdata->height;
+	else
+		fbi->var.yres_virtual = LOGICVC_MAX_VRES;
+	fbi->var.bits_per_pixel = lfdata->bpp;
+
+	/*	Set values according to logiCVC layer data width configuration:
+		- layer data width can be 1, 2, 4 bytes
+		- layer data width for 16 bpp can be 2 or 4 bytes */
+	if (lfdata->alpha_mode == LOGICVC_LAYER_ALPHA) {
+		fbi->var.transp.offset = 0;
+		fbi->var.transp.length = 0;
+	}
+	switch (lfdata->bpp_virt) {
+	case 8:
+		switch (lfdata->alpha_mode) {
+		case LOGICVC_PIXEL_ALPHA:
+			fbi->var.transp.offset = 8;
+			fbi->var.transp.length = 3;
+
+		case LOGICVC_LAYER_ALPHA:
+			fbi->var.red.offset = 5;
+			fbi->var.red.length = 3;
+			fbi->var.green.offset = 2;
+			fbi->var.green.length = 3;
+			fbi->var.blue.offset = 0;
+			fbi->var.blue.length = 2;
+			break;
+
+		case LOGICVC_CLUT_16BPP_ALPHA:
+			fbi->var.transp.offset = 24;
+			fbi->var.transp.length = 6;
+			fbi->var.red.offset = 19;
+			fbi->var.red.length = 5;
+			fbi->var.green.offset = 10;
+			fbi->var.green.length = 6;
+			fbi->var.blue.offset = 3;
+			fbi->var.blue.length = 5;
+			break;
+
+		case LOGICVC_CLUT_32BPP_ALPHA:
+			fbi->var.transp.offset = 24;
+			fbi->var.transp.length = 8;
+			fbi->var.red.offset = 16;
+			fbi->var.red.length = 8;
+			fbi->var.green.offset = 8;
+			fbi->var.green.length = 8;
+			fbi->var.blue.offset = 0;
+			fbi->var.blue.length = 8;
+			break;
+		}
+		break;
+	case 16:
+		switch (lfdata->alpha_mode) {
+		case LOGICVC_PIXEL_ALPHA:
+			fbi->var.transp.offset = 24;
+			fbi->var.transp.length = 6;
+
+		case LOGICVC_LAYER_ALPHA:
+			fbi->var.red.offset = 11;
+			fbi->var.red.length = 5;
+			fbi->var.green.offset = 5;
+			fbi->var.green.length = 6;
+			fbi->var.blue.offset = 0;
+			fbi->var.blue.length = 5;
+			break;
+		}
+		break;
+	case 32:
+		switch (lfdata->alpha_mode) {
+		case LOGICVC_PIXEL_ALPHA:
+			fbi->var.transp.offset = 24;
+			fbi->var.transp.length = 8;
+
+		case LOGICVC_LAYER_ALPHA:
+			fbi->var.red.offset = 16;
+			fbi->var.red.length = 8;
+			fbi->var.green.offset = 8;
+			fbi->var.green.length = 8;
+			fbi->var.blue.offset = 0;
+			fbi->var.blue.length = 8;
+			break;
+		}
+		break;
+	}
+	fbi->var.transp.msb_right = 0;
+	fbi->var.red.msb_right = 0;
+	fbi->var.green.msb_right = 0;
+	fbi->var.blue.msb_right = 0;
+	fbi->var.activate = FB_ACTIVATE_NOW;
+	fbi->var.height = 0;
+	fbi->var.width = 0;
+	fbi->var.sync = 0;
+	fbi->var.rotate = 0;
+}
+
+static int xylonfb_set_timings(struct fb_info *fbi, int bpp)
+{
+	struct xylonfb_layer_data *layer_data = fbi->par;
+	struct xylonfb_common_data *common_data = layer_data->xylonfb_cd;
+	struct fb_var_screeninfo fb_var;
+	int rc;
+
+	driver_devel("%s\n", __func__);
+
+	if ((common_data->xylonfb_flags & FB_VMODE_INIT) &&
+		memchr(common_data->vmode_data.fb_vmode_name, 'x', 10)) {
+		common_data->vmode_data_current = common_data->vmode_data;
+		return 0;
+	}
+
+	rc = fb_find_mode(&fb_var, fbi, xylonfb_mode_option, NULL, 0,
+		&xylonfb_vmode.fb_vmode, bpp);
+#ifdef DEBUG
+	switch (rc) {
+	case 0:
+		pr_err("Error xylonfb video mode\n"
+			"using driver default mode %dx%d-%d@%d\n",
+			xylonfb_vmode.fb_vmode.xres, xylonfb_vmode.fb_vmode.yres,
+			bpp, xylonfb_vmode.fb_vmode.refresh);
+		break;
+	case 1:
+		driver_devel("xylonfb video mode %s\n", xylonfb_mode_option);
+		break;
+	case 2:
+		pr_notice("xylonfb video mode %s with ignored refresh rate\n",
+			xylonfb_mode_option);
+		break;
+	case 3:
+		pr_notice("xylonfb default video mode %dx%d-%d@%d\n",
+			xylonfb_vmode.fb_vmode.xres,
+			xylonfb_vmode.fb_vmode.yres,
+			bpp, xylonfb_vmode.fb_vmode.refresh);
+		break;
+	case 4:
+		pr_notice("xylonfb video mode fallback\n");
+		break;
+	}
+#endif
+
+	common_data->vmode_data_current.ctrl_reg =
+		common_data->vmode_data.ctrl_reg;
+	common_data->vmode_data_current.fb_vmode.refresh =
+		common_data->vmode_data.fb_vmode.refresh;
+	sprintf(common_data->vmode_data_current.fb_vmode_name,
+		"%dx%dM-%d@%d",
+		fb_var.xres, fb_var.yres, fb_var.bits_per_pixel,
+		common_data->vmode_data_current.fb_vmode.refresh);
+	common_data->vmode_data_current.fb_vmode.xres = fb_var.xres;
+	common_data->vmode_data_current.fb_vmode.yres = fb_var.yres;
+	common_data->vmode_data_current.fb_vmode.pixclock = fb_var.pixclock;
+	common_data->vmode_data_current.fb_vmode.left_margin = fb_var.left_margin;
+	common_data->vmode_data_current.fb_vmode.right_margin = fb_var.right_margin;
+	common_data->vmode_data_current.fb_vmode.upper_margin = fb_var.upper_margin;
+	common_data->vmode_data_current.fb_vmode.lower_margin = fb_var.lower_margin;
+	common_data->vmode_data_current.fb_vmode.hsync_len = fb_var.hsync_len;
+	common_data->vmode_data_current.fb_vmode.vsync_len = fb_var.vsync_len;
+	common_data->vmode_data_current.fb_vmode.sync = fb_var.sync;
+	common_data->vmode_data_current.fb_vmode.vmode = fb_var.vmode;
+
+	if (!memchr(common_data->vmode_data.fb_vmode_name, 'x', 10))
+		common_data->vmode_data = common_data->vmode_data_current;
+
+	return rc;
+}
+
+static int xylonfb_register_fb(struct fb_info *fbi,
+	struct xylonfb_layer_data *layer_data,
+	u32 reg_base_phys, int id, int *regfb)
+{
+	struct xylonfb_common_data *common_data = layer_data->xylonfb_cd;
+	struct layer_fix_data *lfdata = &layer_data->layer_fix;
+	int alpha;
+
+	driver_devel("%s\n", __func__);
+
+	fbi->flags = FBINFO_DEFAULT;
+	fbi->screen_base = (char __iomem *)layer_data->fb_virt;
+	fbi->screen_size = layer_data->fb_size;
+	fbi->pseudo_palette = kzalloc(sizeof(u32) * XYLONFB_PSEUDO_PALETTE_SZ,
+		GFP_KERNEL);
+	fbi->fbops = &xylonfb_ops;
+
+	sprintf(fbi->fix.id, "Xylon FB%d", id);
+	xylonfb_set_hw_specifics(fbi, layer_data, lfdata, reg_base_phys);
+	if (!(common_data->xylonfb_flags & FB_DEFAULT_VMODE_SET)) {
+		xylonfb_set_timings(fbi, fbi->var.bits_per_pixel);
+		common_data->xylonfb_flags |= FB_DEFAULT_VMODE_SET;
+	}
+	xylonfb_set_fbi_timings(fbi);
+
+	if (lfdata->alpha_mode == LOGICVC_LAYER_ALPHA)
+		alpha = 0;
+	else
+		alpha = 1;
+	if (fb_alloc_cmap(&fbi->cmap, 256, alpha))
+		return -ENOMEM;
+
+	*regfb = register_framebuffer(fbi);
+	if (*regfb) {
+		pr_err("Error xylonfb registering xylonfb %d\n", id);
+		return -EINVAL;
+	}
+	pr_info("xylonfb %d registered\n", id);
+	/* after fb driver registration, values in struct fb_info
+		must not be changed anywhere else except in xylonfb_set_par */
+
+	return 0;
+}
+
+static void xylonfb_init_layer_regs(struct xylonfb_layer_data *layer_data)
+{
+	u32 reg_val;
+
+	switch (layer_data->layer_fix.bpp_virt) {
+	case 8:
+		switch (layer_data->layer_fix.alpha_mode) {
+		case LOGICVC_CLUT_16BPP_ALPHA:
+			reg_val = TRANSPARENT_COLOR_8BPP_CLUT_16;
+			break;
+		case LOGICVC_CLUT_32BPP_ALPHA:
+			reg_val = TRANSPARENT_COLOR_8BPP_CLUT_24;
+			break;
+		default:
+			reg_val = TRANSPARENT_COLOR_8BPP;
+			break;
+		}
+		break;
+	case 16:
+		reg_val = TRANSPARENT_COLOR_16BPP;
+		break;
+	case 32:
+		reg_val = TRANSPARENT_COLOR_24BPP;
+		break;
+	default:
+		reg_val = TRANSPARENT_COLOR_24BPP;
+		break;
+	}
+	writel(reg_val,
+		(layer_data->layer_reg_base_virt + LOGICVC_LAYER_TRANSP_ROFF));
+
+	reg_val = layer_data->layer_ctrl;
+	writel(reg_val,
+		(layer_data->layer_reg_base_virt + LOGICVC_LAYER_CTRL_ROFF));
+}
+
+static void xylonfb_logicvc_disp_ctrl(struct fb_info *fbi, bool enable)
+{
+	struct xylonfb_layer_data *layer_data = fbi->par;
+	struct xylonfb_common_data *common_data = layer_data->xylonfb_cd;
+	u32 val;
+
+	driver_devel("%s\n", __func__);
+
+	if (enable) {
+		val = LOGICVC_EN_VDD_MSK;
+		writel(val, layer_data->reg_base_virt + LOGICVC_SPWRCTRL_ROFF);
+		mdelay(common_data->power_on_delay);
+		val |= LOGICVC_V_EN_MSK;
+		writel(val, layer_data->reg_base_virt + LOGICVC_SPWRCTRL_ROFF);
+		mdelay(common_data->signal_on_delay);
+		val |= LOGICVC_EN_BLIGHT_MSK;
+		writel(val, layer_data->reg_base_virt + LOGICVC_SPWRCTRL_ROFF);
+	} else {
+		writel(0, layer_data->reg_base_virt + LOGICVC_SPWRCTRL_ROFF);
+	}
+}
+
+static void xylonfb_enable_logicvc_layer(struct fb_info *fbi)
+{
+	struct xylonfb_layer_data *layer_data = fbi->par;
+	u32 reg;
+
+	driver_devel("%s\n", __func__);
+
+	reg = readl(layer_data->layer_reg_base_virt + LOGICVC_LAYER_CTRL_ROFF);
+	reg |= 0x01;
+	writel(reg, (layer_data->layer_reg_base_virt + LOGICVC_LAYER_CTRL_ROFF));
+}
+
+static void xylonfb_disable_logicvc_layer(struct fb_info *fbi)
+{
+	struct xylonfb_layer_data *layer_data = fbi->par;
+	u32 reg;
+
+	driver_devel("%s\n", __func__);
+
+	reg = readl(layer_data->layer_reg_base_virt + LOGICVC_LAYER_CTRL_ROFF);
+	reg &= ~0x01;
+	writel(reg, (layer_data->layer_reg_base_virt + LOGICVC_LAYER_CTRL_ROFF));
+}
+
+static void xylonfb_start_logicvc(struct fb_info *fbi)
+{
+	struct xylonfb_layer_data *layer_data = fbi->par;
+	struct xylonfb_common_data *common_data = layer_data->xylonfb_cd;
+
+	driver_devel("%s\n", __func__);
+
+	writel(common_data->vmode_data_current.fb_vmode.right_margin-1,
+		layer_data->reg_base_virt + LOGICVC_SHSY_FP_ROFF);
+	writel(common_data->vmode_data_current.fb_vmode.hsync_len-1,
+		layer_data->reg_base_virt + LOGICVC_SHSY_ROFF);
+	writel(common_data->vmode_data_current.fb_vmode.left_margin-1,
+		layer_data->reg_base_virt + LOGICVC_SHSY_BP_ROFF);
+	writel(common_data->vmode_data_current.fb_vmode.xres-1,
+		layer_data->reg_base_virt + LOGICVC_SHSY_RES_ROFF);
+	writel(common_data->vmode_data_current.fb_vmode.lower_margin-1,
+		layer_data->reg_base_virt + LOGICVC_SVSY_FP_ROFF);
+	writel(common_data->vmode_data_current.fb_vmode.vsync_len-1,
+		layer_data->reg_base_virt + LOGICVC_SVSY_ROFF);
+	writel(common_data->vmode_data_current.fb_vmode.upper_margin-1,
+		layer_data->reg_base_virt + LOGICVC_SVSY_BP_ROFF);
+	writel(common_data->vmode_data_current.fb_vmode.yres-1,
+		layer_data->reg_base_virt + LOGICVC_SVSY_RES_ROFF);
+	writel(common_data->vmode_data_current.ctrl_reg,
+		layer_data->reg_base_virt + LOGICVC_SCTRL_ROFF);
+	writel(SD_REG_INIT, layer_data->reg_base_virt + LOGICVC_SDTYPE_ROFF);
+
+	driver_devel("\n" \
+		"logiCVC HW parameters:\n" \
+		"    Horizontal Front Porch: %d pixclks\n" \
+		"    Horizontal Sync:        %d pixclks\n" \
+		"    Horizontal Back Porch:  %d pixclks\n" \
+		"    Vertical Front Porch:   %d pixclks\n" \
+		"    Vertical Sync:          %d pixclks\n" \
+		"    Vertical Back Porch:    %d pixclks\n" \
+		"    Pixel Clock:            %d ps\n" \
+		"    Horizontal Res:         %d\n" \
+		"    Vertical Res:           %d\n" \
+		"\n", \
+		common_data->vmode_data_current.fb_vmode.right_margin,
+		common_data->vmode_data_current.fb_vmode.hsync_len,
+		common_data->vmode_data_current.fb_vmode.left_margin,
+		common_data->vmode_data_current.fb_vmode.lower_margin,
+		common_data->vmode_data_current.fb_vmode.vsync_len,
+		common_data->vmode_data_current.fb_vmode.upper_margin,
+		common_data->vmode_data_current.fb_vmode.pixclock,
+		common_data->vmode_data_current.fb_vmode.xres,
+		common_data->vmode_data_current.fb_vmode.yres);
+}
+
+static void xylonfb_stop_logicvc(struct fb_info *fbi)
+{
+	struct xylonfb_layer_data *layer_data = fbi->par;
+	struct xylonfb_common_data *common_data = layer_data->xylonfb_cd;
+	struct fb_info **afbi =
+		(struct fb_info **)dev_get_drvdata(common_data->dev);
+	int i;
+
+	driver_devel("%s\n", __func__);
+
+	if (afbi) {
+		for (i = 0; i < common_data->layers; i++)
+			xylonfb_disable_logicvc_layer(afbi[i]);
+	}
+}
+
+static void xylonfb_start(struct fb_info **afbi, int layers)
+{
+	struct xylonfb_layer_data *layer_data;
+	int i;
+
+	driver_devel("%s\n", __func__);
+
+	/* turn OFF all layers except already used ones */
+	for (i = 0; i < layers; i++) {
+		layer_data = (struct xylonfb_layer_data *)afbi[i]->par;
+		if (layer_data->layer_flags & LOGICVC_LAYER_ON)
+			continue;
+		/* turn off layer */
+		xylonfb_disable_logicvc_layer(afbi[i]);
+	}
+	/* print layer parameters */
+	for (i = 0; i < layers; i++) {
+		layer_data = (struct xylonfb_layer_data *)afbi[i]->par;
+		driver_devel("logiCVC layer %d\n" \
+			"    Registers Base Address:     0x%X\n" \
+			"    Layer Video Memory Address: 0x%X\n" \
+			"    X resolution:               %d\n" \
+			"    Y resolution:               %d\n" \
+			"    X resolution (virtual):     %d\n" \
+			"    Y resolution (virtual):     %d\n" \
+			"    Line length (bytes):        %d\n" \
+			"    Bits per Pixel:             %d\n" \
+			"\n", \
+			i,
+			(unsigned int)layer_data->reg_base_phys,
+			(unsigned int)layer_data->fb_phys,
+			afbi[i]->var.xres,
+			afbi[i]->var.yres,
+			afbi[i]->var.xres_virtual,
+			afbi[i]->var.yres_virtual,
+			afbi[i]->fix.line_length,
+			afbi[i]->var.bits_per_pixel);
+	}
+}
+
+int xylonfb_init_driver(struct xylonfb_init_data *init_data)
+{
+	struct device *dev;
+	struct fb_info **afbi;
+	struct fb_info *fbi;
+	struct xylonfb_common_data *common_data;
+	struct xylonfb_layer_data *layer_data;
+	struct resource *reg_res, *irq_res;
+	void *reg_base_virt;
+	u32 reg_base_phys;
+	int reg_range, layers, active_layer;
+	int i, rc;
+	int regfb[LOGICVC_MAX_LAYERS];
+	driver_devel("%s\n", __func__);
+
+	dev = &init_data->pdev->dev;
+
+	reg_res = platform_get_resource(init_data->pdev, IORESOURCE_MEM, 0);
+	irq_res = platform_get_resource(init_data->pdev, IORESOURCE_IRQ, 0);
+	if ((!reg_res) || (!irq_res)) {
+		pr_err("Error xylonfb resources\n");
+		return -ENODEV;
+	}
+
+	layers = init_data->layers;
+	active_layer = init_data->active_layer;
+	if (active_layer >= layers) {
+		pr_err("Error xylonfb default layer (set 0)\n");
+		active_layer = 0;
+	}
+
+	afbi = kzalloc(sizeof(struct fb_info *) * layers, GFP_KERNEL);
+	common_data = kzalloc(sizeof(struct xylonfb_common_data), GFP_KERNEL);
+	if (!afbi || !common_data) {
+		pr_err("Error xylonfb allocating internal data\n");
+		rc = -ENOMEM;
+		goto err_mem;
+	}
+
+	common_data->layers = layers;
+	common_data->xylonfb_flags |= FB_VMODE_INIT;
+
+	sprintf(init_data->vmode_data.fb_vmode_name, "%sM-%d@%d",
+		init_data->vmode_data.fb_vmode_name,
+		init_data->lfdata[active_layer].bpp,
+		init_data->vmode_data.fb_vmode.refresh);
+	if (init_data->vmode_params_set) {
+		common_data->vmode_data = init_data->vmode_data;
+	} else {
+		xylonfb_mode_option = init_data->vmode_data.fb_vmode_name;
+		common_data->vmode_data.ctrl_reg = init_data->vmode_data.ctrl_reg;
+		common_data->vmode_data.fb_vmode.refresh =
+			init_data->vmode_data.fb_vmode.refresh;
+	}
+
+	layer_data = NULL;
+
+	reg_base_phys = reg_res->start;
+	reg_range = reg_res->end - reg_res->start;
+	reg_base_virt = ioremap_nocache(reg_base_phys, reg_range);
+
+	/* load layer parameters for all layers */
+	for (i = 0; i < layers; i++)
+		regfb[i] = -1;
+
+	/* make /dev/fb0 to be default active layer
+	   no matter how hw layers are organized */
+	for (i = active_layer; i < layers; i++) {
+		if (regfb[i] != -1)
+			continue;
+
+		fbi = framebuffer_alloc(sizeof(struct xylonfb_layer_data), dev);
+		if (!fbi) {
+			pr_err("Error xylonfb allocate info\n");
+			rc = -ENOMEM;
+			goto err_fb;
+		}
+		afbi[i] = fbi;
+		layer_data = fbi->par;
+		layer_data->xylonfb_cd = common_data;
+
+		xylonfb_set_yvirt(init_data->lfdata,
+			init_data->vmem_base_addr, init_data->vmem_high_addr, layers, i);
+
+		layer_data->layer_fix = init_data->lfdata[i];
+
+		rc = xylonfb_map(i, layers, dev, layer_data,
+			init_data->vmem_base_addr, reg_base_phys, reg_base_virt);
+		if (rc)
+			goto err_fb;
+
+		layer_data->layer_ctrl = init_data->layer_ctrl[i];
+		xylonfb_init_layer_regs(layer_data);
+
+		rc = xylonfb_register_fb(fbi, layer_data, reg_base_phys, i, &regfb[i]);
+		if (rc)
+			goto err_fb;
+
+		mutex_init(&layer_data->layer_mutex);
+
+		/* register following layers in HW configuration order */
+		if (active_layer > 0) {
+			i = -1; /* after for loop increment i will be zero */
+			active_layer = -1;
+		}
+
+		driver_devel( \
+			"    Layer ID %d\n" \
+			"    Layer offset %u\n" \
+			"    Layer buffer offset %hd\n" \
+			"    Layer buffers %d\n" \
+			"    Layer width %d pixels\n" \
+			"    Layer height %d lines\n" \
+			"    Layer bits per pixel %d\n" \
+			"    Layer bits per pixel (virtual) %d\n" \
+			"    Layer FB size %ld bytes\n", \
+			(layer_data->layer_fix.layer_fix_info & 0x0F),
+			layer_data->layer_fix.offset,
+			layer_data->layer_fix.buffer_offset,
+			(layer_data->layer_fix.layer_fix_info >> 4),
+			layer_data->layer_fix.width,
+			layer_data->layer_fix.height,
+			layer_data->layer_fix.bpp,
+			layer_data->layer_fix.bpp_virt,
+			layer_data->fb_size);
+	}
+
+	common_data->bg_layer_bpp = init_data->bg_layer_bpp;
+	common_data->bg_layer_alpha_mode = init_data->bg_layer_alpha_mode;
+	driver_devel("BG layer %dbpp\n", init_data->bg_layer_bpp);
+
+	common_data->xylonfb_irq = irq_res->start;
+	if (request_irq(common_data->xylonfb_irq, xylonfb_isr,
+			IRQF_TRIGGER_HIGH, DEVICE_NAME, afbi)) {
+		common_data->xylonfb_irq = 0;
+		goto err_fb;
+	}
+
+#if defined(__LITTLE_ENDIAN)
+	common_data->xylonfb_flags |= FB_MEMORY_LE;
+#endif
+	mutex_init(&common_data->irq_mutex);
+	init_waitqueue_head(&common_data->xylonfb_vsync.wait);
+	common_data->xylonfb_use_ref = 0;
+
+	common_data->xylonfb_flags &=
+		~(FB_VMODE_INIT | FB_DEFAULT_VMODE_SET | FB_VMODE_SET);
+	xylonfb_mode_option = NULL;
+
+	common_data->dev = dev;
+	dev_set_drvdata(dev, (void *)afbi);
+
+	/* start HW */
+	xylonfb_start(afbi, layers);
+
+	return 0;
+
+err_fb:
+	if (common_data->xylonfb_irq != 0)
+		free_irq(common_data->xylonfb_irq, afbi);
+	if (layer_data->reg_base_virt)
+		iounmap(layer_data->reg_base_virt);
+	for (i = layers-1; i >= 0; i--) {
+		fbi = afbi[i];
+		if (!fbi)
+			continue;
+		layer_data = fbi->par;
+		if (regfb[i] == 0)
+			unregister_framebuffer(fbi);
+		else
+			regfb[i] = 0;
+		if (fbi->cmap.red)
+			fb_dealloc_cmap(&fbi->cmap);
+		if (layer_data) {
+			if (common_data->xylonfb_flags & FB_DMA_BUFFER) {
+				/* NOT USED FOR NOW! */
+				dma_free_coherent(dev, PAGE_ALIGN(fbi->fix.smem_len),
+					layer_data->fb_virt, layer_data->fb_phys);
+			} else {
+				if (layer_data->fb_virt)
+					iounmap(layer_data->fb_virt);
+			}
+			kfree(fbi->pseudo_palette);
+			framebuffer_release(fbi);
+		}
+	}
+
+err_mem:
+	if (common_data)
+		kfree(common_data);
+	if (afbi)
+		kfree(afbi);
+
+	dev_set_drvdata(dev, NULL);
+
+	return rc;
+}
+
+int xylonfb_deinit_driver(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct fb_info **afbi = (struct fb_info **)dev_get_drvdata(dev);
+	struct fb_info *fbi = afbi[0];
+	struct xylonfb_layer_data *layer_data = fbi->par;
+	struct xylonfb_common_data *common_data = layer_data->xylonfb_cd;
+	int i;
+	bool logicvc_unmap;
+
+	driver_devel("%s\n", __func__);
+
+	if (common_data->xylonfb_use_ref) {
+		pr_err("Error xylonfb in use\n");
+		return -EINVAL;
+	}
+
+	logicvc_unmap = false;
+
+	free_irq(common_data->xylonfb_irq, afbi);
+	for (i = common_data->layers-1; i >= 0; i--) {
+		fbi = afbi[i];
+		layer_data = fbi->par;
+		xylonfb_disable_logicvc_layer(fbi);
+		if (!logicvc_unmap) {
+			iounmap(layer_data->reg_base_virt);
+			logicvc_unmap = true;
+		}
+		unregister_framebuffer(fbi);
+		fb_dealloc_cmap(&fbi->cmap);
+		if (common_data->xylonfb_flags & FB_DMA_BUFFER) {
+			dma_free_coherent(dev, PAGE_ALIGN(fbi->fix.smem_len),
+				layer_data->fb_virt, layer_data->fb_phys);
+		} else {
+			iounmap(layer_data->fb_virt);
+		}
+		kfree(fbi->pseudo_palette);
+		framebuffer_release(fbi);
+	}
+
+	kfree(common_data);
+	kfree(afbi);
+
+	dev_set_drvdata(dev, NULL);
+
+	return 0;
+}
+
+#ifndef MODULE
+int xylonfb_get_params(char *options)
+{
+	char *this_opt;
+
+	driver_devel("%s\n", __func__);
+
+	if (!options || !*options)
+		return 0;
+
+	while ((this_opt = strsep(&options, ",")) != NULL) {
+		if (!*this_opt)
+			continue;
+		xylonfb_mode_option = this_opt;
+	}
+	return 0;
+}
+#endif
diff --git a/drivers/video/xylon/xylonfb/core/xylonfb.h b/drivers/video/xylon/xylonfb/core/xylonfb.h
new file mode 100644
index 0000000..fb920d4
--- /dev/null
+++ b/drivers/video/xylon/xylonfb/core/xylonfb.h
@@ -0,0 +1,130 @@
+/*
+ * Xylon logiCVC frame buffer driver internal data structures
+ *
+ * Author: Xylon d.o.o.
+ * e-mail: davor.joja@logicbricks.com
+ *
+ * 2012 (c) Xylon d.o.o.
+ *
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2.  This program is licensed "as is" without any warranty of any
+ * kind, whether express or implied.
+ */
+
+#ifndef __XYLON_FB_DATA_H__
+#define __XYLON_FB_DATA_H__
+
+
+#include <linux/wait.h>
+#include <linux/mutex.h>
+#include <linux/fb.h>
+#include "logicvc.h"
+
+
+#define DRIVER_NAME "xylonfb"
+#define DEVICE_NAME "logicvc"
+#define DRIVER_DESCRIPTION "Xylon logiCVC frame buffer driver"
+#define DRIVER_VERSION "1.0"
+
+/* FB driver flags */
+#define FB_DMA_BUFFER        0x01
+#define FB_MEMORY_LE         0x02
+#define FB_VMODE_INIT        0x10
+#define FB_DEFAULT_VMODE_SET 0x20
+#define FB_VMODE_SET         0x40
+
+
+#ifdef DEBUG
+#define driver_devel(format, ...) \
+	do { \
+		printk(KERN_INFO format, ## __VA_ARGS__); \
+	} while (0)
+#else
+#define driver_devel(format, ...)
+#endif
+
+
+#define VMODE_NAME_SZ 20
+struct xylonfb_vmode_data {
+	u32 ctrl_reg;
+	struct fb_videomode fb_vmode;
+	char fb_vmode_name[VMODE_NAME_SZ+1];
+};
+
+struct layer_fix_data {
+	unsigned int offset;
+	unsigned short buffer_offset;
+	unsigned short width;
+	unsigned short height;
+	unsigned char bpp;
+	unsigned char bpp_virt;
+	unsigned char alpha_mode;
+	unsigned char layer_fix_info;	/* higher 4 bits: number of layer buffers */
+									/* lower 4 bits: layer ID */
+};
+
+struct xylonfb_sync {
+	wait_queue_head_t wait;
+	unsigned int cnt;
+};
+
+struct xylonfb_common_data {
+	struct device *dev;
+	struct mutex irq_mutex;
+	struct xylonfb_sync xylonfb_vsync;
+	struct xylonfb_vmode_data vmode_data;
+	struct xylonfb_vmode_data vmode_data_current;
+	/* Delay after applying display power and
+		before applying display signals */
+	unsigned int power_on_delay;
+	/* Delay after applying display signal and
+		before applying display backlight power supply */
+	unsigned int signal_on_delay;
+	unsigned char layers;
+	unsigned char xylonfb_irq;
+	unsigned char xylonfb_use_ref;
+	unsigned char xylonfb_flags;
+	unsigned char xylonfb_used_layer;
+	unsigned char bg_layer_bpp;
+	unsigned char bg_layer_alpha_mode;
+};
+
+struct xylonfb_layer_data {
+	struct xylonfb_common_data *xylonfb_cd;
+	struct mutex layer_mutex;
+	dma_addr_t reg_base_phys;
+	dma_addr_t fb_phys;
+	void *reg_base_virt;
+	void *fb_virt;
+	unsigned long fb_size;
+	void *layer_reg_base_virt;
+	void *layer_clut_base_virt;
+	struct layer_fix_data layer_fix;
+	unsigned char layer_ctrl;
+	unsigned char layer_flags;
+	unsigned char layer_use_ref;
+};
+
+struct xylonfb_init_data {
+	struct platform_device *pdev;
+	struct xylonfb_vmode_data vmode_data;
+	struct layer_fix_data lfdata[LOGICVC_MAX_LAYERS];
+	unsigned long vmem_base_addr;
+	unsigned long vmem_high_addr;
+	unsigned char layer_ctrl[LOGICVC_MAX_LAYERS];
+	unsigned char layers;
+	unsigned char active_layer;
+	unsigned char bg_layer_bpp;
+	unsigned char bg_layer_alpha_mode;
+	bool vmode_params_set;
+};
+
+
+/* xylonfb core interface functions */
+extern int xylonfb_get_params(char *options);
+extern int xylonfb_init_driver(struct xylonfb_init_data *init_data);
+extern int xylonfb_deinit_driver(struct platform_device *pdev);
+extern int xylonfb_ioctl(struct fb_info *fbi,
+	unsigned int cmd, unsigned long arg);
+
+#endif /* __XYLON_FB_DATA_H__ */
diff --git a/drivers/video/xylon/xylonfb/of/Makefile b/drivers/video/xylon/xylonfb/of/Makefile
new file mode 100644
index 0000000..fe80f39
--- /dev/null
+++ b/drivers/video/xylon/xylonfb/of/Makefile
@@ -0,0 +1,4 @@
+obj-$(CONFIG_FB_XYLON) += xylonfb.o
+xylonfb-objs := ../core/xylonfb.o ../core/xylonfb-ioctl.o \
+	../core/xylonfb-pixclk.o
+xylonfb-$(CONFIG_FB_XYLON_OF) += xylonfb-of.o
diff --git a/drivers/video/xylon/xylonfb/of/xylonfb-of.c b/drivers/video/xylon/xylonfb/of/xylonfb-of.c
new file mode 100644
index 0000000..1dd86b1
--- /dev/null
+++ b/drivers/video/xylon/xylonfb/of/xylonfb-of.c
@@ -0,0 +1,432 @@
+/*
+ * Xylon logiCVC frame buffer Open Firmware driver
+ *
+ * Author: Xylon d.o.o.
+ * e-mail: davor.joja@logicbricks.com
+ *
+ * 2012 Xylon d.o.o.
+ *
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2.  This program is licensed "as is" without any warranty of any
+ * kind, whether express or implied.
+ */
+
+
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/errno.h>
+#include <linux/of.h>
+#include "../core/xylonfb.h"
+
+
+static void set_ctrl_reg(struct xylonfb_init_data *init_data,
+	unsigned long pix_data_invert, unsigned long pix_clk_act_high)
+{
+	u32 sync = init_data->vmode_data.fb_vmode.sync;
+	u32 ctrl = CTRL_REG_INIT;
+
+	if (sync & (1<<0)) {	//FB_SYNC_HOR_HIGH_ACT
+		ctrl &= (~(1<<1));
+	}
+	if (sync & (1<<1)) {	// FB_SYNC_VERT_HIGH_ACT
+		ctrl &= (~(1<<3));
+	}
+	if (pix_data_invert) {
+		ctrl |= LOGICVC_PIX_DATA_INVERT;
+	}
+	if (pix_clk_act_high) {
+		ctrl |= LOGICVC_PIX_ACT_HIGH;
+	}
+
+	init_data->vmode_data.ctrl_reg = ctrl;
+}
+
+static int xylonfb_parse_vram_info(struct device_node *np,
+	unsigned long *vmem_base_addr, unsigned long *vmem_high_addr)
+{
+	u32 const *prop;
+	int size;
+
+	prop = of_get_property(np, "vmem-baseaddr", &size);
+	if (!prop) {
+		pr_err("Error xylonfb getting VRAM address begin\n");
+		return -EINVAL;
+	}
+	*vmem_base_addr = be32_to_cpup(prop);
+
+	prop = of_get_property(np, "vmem-highaddr", &size);
+	if (!prop) {
+		pr_err("Error xylonfb getting VRAM address end\n");
+		return -EINVAL;
+	}
+	*vmem_high_addr = be32_to_cpup(prop);
+
+	return 0;
+}
+
+static int xylonfb_parse_layer_info(struct device_node *np,
+	struct xylonfb_init_data *init_data)
+{
+	u32 const *prop;
+	unsigned int layers, bg_bpp, bg_alpha_mode;
+	int size;
+	char bg_layer_name[25];
+
+	prop = of_get_property(np, "num-of-layers", &size);
+	if (!prop) {
+		pr_err("Error getting number of layers\n");
+		return -EINVAL;
+	}
+	layers = be32_to_cpup(prop);
+
+	prop = of_get_property(np, "use-background", &size);
+	if (!prop) {
+		pr_err("Error getting use background\n");
+		return -EINVAL;
+	}
+	if (be32_to_cpup(prop) == 1) {
+		layers--;
+
+		sprintf(bg_layer_name, "layer-%d-data-width", layers);
+		prop = of_get_property(np, bg_layer_name, &size);
+		if (!prop)
+			bg_bpp = 16;
+		else
+			bg_bpp = be32_to_cpup(prop);
+		if (bg_bpp == 24)
+			bg_bpp = 32;
+
+		sprintf(bg_layer_name, "layer-%d-alpha-mode", layers);
+		prop = of_get_property(np, bg_layer_name, &size);
+		if (!prop) {
+			bg_alpha_mode = LOGICVC_LAYER_ALPHA;
+		} else {
+			bg_alpha_mode = be32_to_cpup(prop);
+		}
+	} else {
+		bg_bpp = 0;
+		bg_alpha_mode = 0;
+		pr_debug("xylonfb no BG layer\n");
+	}
+
+	init_data->layers = (unsigned char)layers;
+	init_data->bg_layer_bpp = (unsigned char)bg_bpp;
+	init_data->bg_layer_alpha_mode = (unsigned char)bg_alpha_mode;
+
+	return 0;
+}
+
+static int xylonfb_parse_vmode_info(struct device_node *np,
+	struct xylonfb_init_data *init_data)
+{
+	struct device_node *dn, *vmode_dn;
+	u32 const *prop;
+	char *c;
+	unsigned long pix_data_invert, pix_clk_act_high;
+	int size, tmp;
+
+	init_data->active_layer = 0;
+	init_data->vmode_params_set = false;
+
+	dn = of_find_node_by_name(NULL, "xylon-video-params");
+	if (dn == NULL) {
+		pr_err("Error getting video mode parameters\n");
+		return -ENOENT;
+	}
+
+	pix_data_invert = 0;
+	prop = of_get_property(dn, "pixel-data-invert", &size);
+	if (!prop)
+		pr_err("Error getting pixel data invert\n");
+	else
+		pix_data_invert = be32_to_cpup(prop);
+	pix_clk_act_high = 0;
+	prop = of_get_property(dn, "pixel-clock-active-high", &size);
+	if (!prop)
+		pr_err("Error getting pixel active edge\n");
+	else
+		pix_clk_act_high = be32_to_cpup(prop);
+
+	prop = of_get_property(dn, "pixel-component-format", &size);
+	if (prop) {
+		if (!strcmp("ABGR", (char *)prop)) {
+			prop = of_get_property(dn, "pixel-component-layer", &size);
+			if (prop) {
+				while(size > 0) {
+					tmp = be32_to_cpup(prop);
+					init_data->layer_ctrl[tmp] = LOGICVC_SWAP_RB;
+					prop++;
+					size -= sizeof(prop);
+				}
+			}
+		}
+	}
+
+	prop = of_get_property(dn, "active-layer", &size);
+	if (prop) {
+		tmp = be32_to_cpup(prop);
+		init_data->active_layer = (unsigned char)tmp;
+	} else {
+		pr_info("xylonfb setting default layer to %d\n",
+			init_data->active_layer);
+	}
+
+	prop = of_get_property(dn, "videomode", &size);
+	if (prop) {
+		if (strlen((char *)prop) <= VMODE_NAME_SZ) {
+			strcpy(init_data->vmode_data.fb_vmode_name, (char *)prop);
+			vmode_dn =
+				of_find_node_by_name(dn, init_data->vmode_data.fb_vmode_name);
+			c = strchr((char *)prop, '_');
+			if (c)
+				*c = 0;
+			strcpy(init_data->vmode_data.fb_vmode_name, (char *)prop);
+		} else {
+			vmode_dn = NULL;
+			pr_err("Error videomode name to long\n");
+		}
+		if (vmode_dn) {
+			prop = of_get_property(vmode_dn, "refresh", &size);
+			if (!prop)
+				pr_err("Error getting refresh rate\n");
+			else
+				init_data->vmode_data.fb_vmode.refresh = be32_to_cpup(prop);
+
+			prop = of_get_property(vmode_dn, "xres", &size);
+			if (!prop)
+				pr_err("Error getting xres\n");
+			else
+				init_data->vmode_data.fb_vmode.xres = be32_to_cpup(prop);
+
+			prop = of_get_property(vmode_dn, "yres", &size);
+			if (!prop)
+				pr_err("Error getting yres\n");
+			else
+				init_data->vmode_data.fb_vmode.yres = be32_to_cpup(prop);
+
+			prop = of_get_property(vmode_dn, "pixclock-khz", &size);
+			if (!prop)
+				pr_err("Error getting pixclock-khz\n");
+			else
+				init_data->vmode_data.fb_vmode.pixclock =
+					KHZ2PICOS(be32_to_cpup(prop));
+
+			prop = of_get_property(vmode_dn, "left-margin", &size);
+			if (!prop)
+				pr_err("Error getting left-margin\n");
+			else
+				init_data->vmode_data.fb_vmode.left_margin = be32_to_cpup(prop);
+
+			prop = of_get_property(vmode_dn, "right-margin", &size);
+			if (!prop)
+				pr_err("Error getting right-margin\n");
+			else
+				init_data->vmode_data.fb_vmode.right_margin = be32_to_cpup(prop);
+
+			prop = of_get_property(vmode_dn, "upper-margin", &size);
+			if (!prop)
+				pr_err("Error getting upper-margin\n");
+			else
+				init_data->vmode_data.fb_vmode.upper_margin = be32_to_cpup(prop);
+
+			prop = of_get_property(vmode_dn, "lower-margin", &size);
+			if (!prop)
+				pr_err("Error getting lower-margin\n");
+			else
+				init_data->vmode_data.fb_vmode.lower_margin = be32_to_cpup(prop);
+
+			prop = of_get_property(vmode_dn, "hsync-len", &size);
+			if (!prop)
+				pr_err("Error getting hsync-len\n");
+			else
+				init_data->vmode_data.fb_vmode.hsync_len = be32_to_cpup(prop);
+
+			prop = of_get_property(vmode_dn, "vsync-len", &size);
+			if (!prop)
+				pr_err("Error getting vsync-len\n");
+			else
+				init_data->vmode_data.fb_vmode.vsync_len = be32_to_cpup(prop);
+
+			prop = of_get_property(vmode_dn, "sync", &size);
+			if (!prop)
+				pr_err("Error getting sync\n");
+			else
+				init_data->vmode_data.fb_vmode.sync = be32_to_cpup(prop);
+
+			prop = of_get_property(vmode_dn, "vmode", &size);
+			if (!prop)
+				pr_err("Error getting vmode\n");
+			else
+				init_data->vmode_data.fb_vmode.vmode = be32_to_cpup(prop);
+
+			init_data->vmode_params_set = true;
+		} else {
+			init_data->vmode_data.fb_vmode.refresh = 60;
+		}
+	} else {
+		pr_info("xylonfb using default driver video mode\n");
+	}
+
+	set_ctrl_reg(init_data, pix_data_invert, pix_clk_act_high);
+
+	return 0;
+}
+
+static int xylonfb_parse_layer_params(struct device_node *np,
+	int id, struct layer_fix_data *lfdata)
+{
+	u32 const *prop;
+	int size;
+	char layer_property_name[25];
+
+	sprintf(layer_property_name, "layer-%d-offset", id);
+	prop = of_get_property(np, layer_property_name, &size);
+	if (!prop) {
+		pr_err("Error getting layer offset\n");
+		return -EINVAL;
+	} else {
+		lfdata->offset = be32_to_cpup(prop);
+	}
+
+	sprintf(layer_property_name, "buffer-%d-offset", id);
+	prop = of_get_property(np, layer_property_name, &size);
+	if (!prop) {
+		pr_err("Error getting buffer offset\n");
+		return -EINVAL;
+	} else {
+		lfdata->buffer_offset = be32_to_cpup(prop);
+	}
+
+	prop = of_get_property(np, "row-stride", &size);
+	if (!prop)
+		lfdata->width = 1024;
+	else
+		lfdata->width = be32_to_cpup(prop);
+
+	sprintf(layer_property_name, "layer-%d-alpha-mode", id);
+	prop = of_get_property(np, layer_property_name, &size);
+	if (!prop) {
+		pr_err("Error getting layer alpha mode\n");
+		return -EINVAL;
+	} else {
+		lfdata->alpha_mode = be32_to_cpup(prop);
+	}
+
+	sprintf(layer_property_name, "layer-%d-data-width", id);
+	prop = of_get_property(np, layer_property_name, &size);
+	if (!prop)
+		lfdata->bpp = 16;
+	else
+		lfdata->bpp = be32_to_cpup(prop);
+	if (lfdata->bpp == 24)
+		lfdata->bpp = 32;
+
+	lfdata->bpp_virt = lfdata->bpp;
+
+	switch (lfdata->bpp) {
+		case 8:
+			if (lfdata->alpha_mode == LOGICVC_PIXEL_ALPHA)
+				lfdata->bpp = 16;
+			break;
+		case 16:
+			if (lfdata->alpha_mode == LOGICVC_PIXEL_ALPHA)
+				lfdata->bpp = 32;
+			break;
+	}
+
+	lfdata->layer_fix_info = id;
+
+	return 0;
+}
+
+
+static int xylonfb_of_probe(struct platform_device *pdev)
+{
+	struct xylonfb_init_data init_data;
+	int i, rc;
+
+	memset(&init_data, 0, sizeof(struct xylonfb_init_data));
+
+	init_data.pdev = pdev;
+
+	rc = xylonfb_parse_vram_info(pdev->dev.of_node,
+		&init_data.vmem_base_addr, &init_data.vmem_high_addr);
+	if (rc)
+		return rc;
+	rc = xylonfb_parse_layer_info(pdev->dev.of_node, &init_data);
+	if (rc)
+		return rc;
+	/* if Device-Tree contains video mode options do not use
+	   kernel command line video mode options */
+	xylonfb_parse_vmode_info(pdev->dev.of_node, &init_data);
+
+	for (i = 0; i < init_data.layers; i++) {
+		rc = xylonfb_parse_layer_params(pdev->dev.of_node, i,
+			&init_data.lfdata[i]);
+		if (rc)
+			return rc;
+	}
+
+	return xylonfb_init_driver(&init_data);
+}
+
+static int xylonfb_of_remove(struct platform_device *pdev)
+{
+	return xylonfb_deinit_driver(pdev);
+}
+
+
+static struct of_device_id xylonfb_of_match[] __devinitdata = {
+	{ .compatible = "xylon,logicvc-2.05.c" },
+	{/* end of table */},
+};
+MODULE_DEVICE_TABLE(of, xylonfb_of_match);
+
+
+static struct platform_driver xylonfb_of_driver = {
+	.probe = xylonfb_of_probe,
+	.remove = xylonfb_of_remove,
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = DEVICE_NAME,
+		.of_match_table = xylonfb_of_match,
+	},
+};
+
+
+static int __init xylonfb_of_init(void)
+{
+#ifndef MODULE
+	char *option = NULL;
+	/*
+	 *  For kernel boot options (in 'video=xxxfb:<options>' format)
+	 */
+	if (fb_get_options(DRIVER_NAME, &option))
+		return -ENODEV;
+	/* Set internal module parameters */
+	xylonfb_get_params(option);
+#endif
+	if (platform_driver_register(&xylonfb_of_driver)) {
+		pr_err("Error xylonfb driver registration\n");
+		return -ENODEV;
+	}
+
+	return 0;
+}
+
+static void __exit xylonfb_of_exit(void)
+{
+	platform_driver_unregister(&xylonfb_of_driver);
+}
+
+
+#ifndef MODULE
+late_initcall(xylonfb_of_init);
+#else
+module_init(xylonfb_of_init);
+module_exit(xylonfb_of_exit);
+#endif
+
+MODULE_LICENSE("GPL v2");
+MODULE_DESCRIPTION(DRIVER_DESCRIPTION);
+MODULE_VERSION(DRIVER_VERSION);
diff --git a/drivers/video/xylon/xylonfb/platform/Makefile b/drivers/video/xylon/xylonfb/platform/Makefile
new file mode 100644
index 0000000..7930e6b
--- /dev/null
+++ b/drivers/video/xylon/xylonfb/platform/Makefile
@@ -0,0 +1,4 @@
+obj-$(CONFIG_FB_XYLON) += xylonfb.o
+xylonfb-objs := ../core/xylonfb.o ../core/xylonfb-ioctl.o \
+	../core/xylonfb-pixclk.o
+xylonfb-$(CONFIG_FB_XYLON_PLATFORM) += xylonfb-platform.o
diff --git a/drivers/video/xylon/xylonfb/platform/xylonfb-platform.c b/drivers/video/xylon/xylonfb/platform/xylonfb-platform.c
new file mode 100644
index 0000000..35d328e
--- /dev/null
+++ b/drivers/video/xylon/xylonfb/platform/xylonfb-platform.c
@@ -0,0 +1,207 @@
+/*
+ * Xylon logiCVC frame buffer platform driver
+ *
+ * Author: Xylon d.o.o.
+ * e-mail: davor.joja@logicbricks.com
+ *
+ * This driver was based on skeletonfb.c and other fb video drivers.
+ * 2012 Xylon d.o.o.
+ *
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2.  This program is licensed "as is" without any warranty of any
+ * kind, whether express or implied.
+ */
+
+
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/errno.h>
+#include <linux/xylonfb_platform.h>
+#include "../core/xylonfb.h"
+
+
+static void xylonfb_get_platform_layer_params(
+	struct xylonfb_platform_layer_params *lparams,
+	struct layer_fix_data *lfdata, int id)
+{
+	lfdata->offset = lparams->offset;
+	lfdata->buffer_offset = lparams->buffer_offset;
+	lfdata->bpp = lparams->bpp;
+	lfdata->bpp_virt = lparams->bpp;
+	lfdata->alpha_mode = lparams->alpha_mode;
+
+	switch (lfdata->bpp) {
+		case 8:
+			if (lfdata->alpha_mode == LOGICVC_PIXEL_ALPHA)
+				lfdata->bpp = 16;
+			break;
+		case 16:
+			if (lfdata->alpha_mode == LOGICVC_PIXEL_ALPHA)
+				lfdata->bpp = 32;
+			break;
+	}
+
+	lfdata->layer_fix_info = id;
+}
+
+static int xylonfb_platform_probe(struct platform_device *pdev)
+{
+	struct xylonfb_init_data init_data;
+	struct xylonfb_platform_data *pdata;
+	int i;
+
+	memset(&init_data, 0, sizeof(struct xylonfb_init_data));
+
+	init_data.pdev = pdev;
+
+	pdata = (struct xylonfb_platform_data *)pdev->dev.platform_data;
+	init_data.vmem_base_addr = pdata->vmem_base_addr;
+	init_data.vmem_high_addr = pdata->vmem_high_addr;
+	init_data.vmode_data.ctrl_reg = pdata->ctrl_reg;
+	init_data.layers = pdata->num_layers;
+	init_data.active_layer = pdata->active_layer;
+	init_data.bg_layer_bpp = pdata->bg_layer_bpp;
+	init_data.bg_layer_alpha_mode = pdata->bg_layer_alpha_mode;
+	init_data.vmode_params_set = false;
+
+	for (i = 0; i < init_data.layers; i++) {
+		xylonfb_get_platform_layer_params(
+			&pdata->layer_params[i],
+			&init_data.lfdata[i], i);
+		init_data.lfdata[i].width = pdata->row_stride;
+		init_data.layer_ctrl[i] = pdata->layer_params[i].ctrl;
+	}
+
+	return xylonfb_init_driver(&init_data);
+}
+
+static int xylonfb_platform_remove(struct platform_device *pdev)
+{
+	return xylonfb_deinit_driver(pdev);
+}
+
+
+/* logiCVC parameters for Xylon Zynq-ZC702 2D3D referent design */
+static struct xylonfb_platform_layer_params logicvc_0_layer_params[] = {
+	{
+		.offset = 7290,
+		.buffer_offset = 1080,
+		.bpp = 32,
+		.alpha_mode = LOGICVC_PIXEL_ALPHA,
+		.ctrl = 0,
+	},
+	{
+		.offset = 4050,
+		.buffer_offset = 1080,
+		.bpp = 32,
+		.alpha_mode = LOGICVC_LAYER_ALPHA,
+		.ctrl = 0,
+	},
+	{
+		.offset = 0,
+		.buffer_offset = 1080,
+		.bpp = 32,
+		.alpha_mode = LOGICVC_LAYER_ALPHA,
+		.ctrl = 0,
+	},
+	{
+		.offset = 12960,
+		.buffer_offset = 1080,
+		.bpp = 8,
+		.alpha_mode = LOGICVC_CLUT_32BPP_ALPHA,
+		.ctrl = 0,
+	},
+};
+
+static struct xylonfb_platform_data logicvc_0_platform_data = {
+	.layer_params = logicvc_0_layer_params,
+	.ctrl_reg = (CTRL_REG_INIT | LOGICVC_PIX_ACT_HIGH),
+	.vmem_base_addr = 0x30000000,
+	.vmem_high_addr = 0x3FFFFFFF,
+	.row_stride = 2048,
+	.num_layers = ARRAY_SIZE(logicvc_0_layer_params),
+	.active_layer = 3,
+	.bg_layer_bpp = 32,
+	.bg_layer_alpha_mode = LOGICVC_LAYER_ALPHA,
+};
+
+static struct resource logicvc_0_resource[] = {
+	{
+		.start = 0x40030000,
+		.end = (0x40030000 + LOGICVC_REGISTERS_RANGE),
+		.flags = IORESOURCE_MEM,
+	},
+	{
+		.start = 90,
+		.end = 90,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device logicvc_device = {
+	.name = DEVICE_NAME,
+	.id = 0,
+	.dev = {
+		.platform_data = &logicvc_0_platform_data,
+	},
+	.resource = logicvc_0_resource,
+	.num_resources = ARRAY_SIZE(logicvc_0_resource),
+};
+
+
+static struct platform_driver xylonfb_driver = {
+	.probe = xylonfb_platform_probe,
+	.remove = xylonfb_platform_remove,
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = DEVICE_NAME,
+	},
+};
+
+
+static int __init xylonfb_platform_init(void)
+{
+	int err;
+
+#ifndef MODULE
+	char *option = NULL;
+	/*
+	 *  For kernel boot options (in 'video=xxxfb:<options>' format)
+	 */
+	if (fb_get_options(DRIVER_NAME, &option))
+		return -ENODEV;
+	/* Set internal module parameters */
+	xylonfb_get_params(option);
+#endif
+	err = platform_device_register(&logicvc_device);
+	if (err) {
+		pr_err("Error xylonfb device registration\n");
+		return err;
+	}
+	err = platform_driver_register(&xylonfb_driver);
+	if (err) {
+		pr_err("Error xylonfb driver registration\n");
+		platform_device_unregister(&logicvc_device);
+		return err;
+	}
+
+	return 0;
+}
+
+static void __exit xylonfb_platform_exit(void)
+{
+	platform_driver_unregister(&xylonfb_driver);
+	platform_device_unregister(&logicvc_device);
+}
+
+
+#ifndef MODULE
+late_initcall(xylonfb_platform_init);
+#else
+module_init(xylonfb_platform_init);
+module_exit(xylonfb_platform_exit);
+#endif
+
+MODULE_LICENSE("GPL v2");
+MODULE_DESCRIPTION(DRIVER_DESCRIPTION);
+MODULE_VERSION(DRIVER_VERSION);
diff --git a/include/linux/xylonfb.h b/include/linux/xylonfb.h
new file mode 100644
index 0000000..fd87d8e
--- /dev/null
+++ b/include/linux/xylonfb.h
@@ -0,0 +1,73 @@
+/*
+ * Xylon logiCVC frame buffer driver IOCTL parameters
+ *
+ * Author: Xylon d.o.o.
+ * e-mail: davor.joja@logicbricks.com
+ *
+ * 2012 (c) Xylon d.o.o.
+ *
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2.  This program is licensed "as is" without any warranty of any
+ * kind, whether express or implied.
+ */
+
+#ifndef __XYLON_FB_H__
+#define __XYLON_FB_H__
+
+
+#include <linux/types.h>
+
+
+struct xylonfb_layer_color {
+	__u32 raw_rgb;
+	__u8 use_raw;
+	__u8 r;
+	__u8 g;
+	__u8 b;
+};
+
+struct xylonfb_layer_pos_size {
+	__u16 x;
+	__u16 y;
+	__u16 width;
+	__u16 height;
+};
+
+struct xylonfb_hw_access {
+	__u32 offset;
+	__u32 value;
+};
+
+
+#define XYLONFB_IOW(num, dtype)  _IOW('x', num, dtype)
+#define XYLONFB_IOR(num, dtype)  _IOR('x', num, dtype)
+#define XYLONFB_IOWR(num, dtype) _IOWR('x', num, dtype)
+#define XYLONFB_IO(num)          _IO('x', num)
+
+#define XYLONFB_GET_LAYER_IDX           XYLONFB_IOR(30, unsigned int)
+#define XYLONFB_GET_LAYER_ALPHA         XYLONFB_IOR(31, unsigned int)
+#define XYLONFB_SET_LAYER_ALPHA         XYLONFB_IOW(32, unsigned int)
+#define XYLONFB_LAYER_COLOR_TRANSP      XYLONFB_IOW(33, unsigned int)
+#define XYLONFB_GET_LAYER_COLOR_TRANSP \
+	XYLONFB_IOR(34, struct xylonfb_layer_color)
+#define XYLONFB_SET_LAYER_COLOR_TRANSP \
+	XYLONFB_IOW(35, struct xylonfb_layer_color)
+#define XYLONFB_GET_LAYER_SIZE_POS \
+	XYLONFB_IOR(36, struct xylonfb_layer_pos_size)
+#define XYLONFB_SET_LAYER_SIZE_POS \
+	XYLONFB_IOW(37, struct xylonfb_layer_pos_size)
+#define XYLONFB_GET_LAYER_BUFFER        XYLONFB_IOR(38, unsigned int)
+#define XYLONFB_SET_LAYER_BUFFER        XYLONFB_IOW(39, unsigned int)
+#define XYLONFB_GET_LAYER_BUFFER_OFFSET XYLONFB_IOR(40, unsigned int)
+#define XYLONFB_GET_LAYER_BUFFERS_NUM   XYLONFB_IOR(41, unsigned int)
+#define XYLONFB_GET_BACKGROUND_COLOR \
+	XYLONFB_IOR(42, struct xylonfb_layer_color)
+#define XYLONFB_SET_BACKGROUND_COLOR \
+	XYLONFB_IOW(43, struct xylonfb_layer_color)
+#define XYLONFB_LAYER_EXT_BUFF_SWITCH   XYLONFB_IOW(43, unsigned int)
+#define XYLONFB_READ_HW_REG \
+	XYLONFB_IOR(44, struct xylonfb_hw_access)
+#define XYLONFB_WRITE_HW_REG \
+	XYLONFB_IOW(45, struct xylonfb_hw_access)
+
+#endif /* __XYLON_FB_H__ */
diff --git a/include/linux/xylonfb_platform.h b/include/linux/xylonfb_platform.h
new file mode 100644
index 0000000..f1f4183
--- /dev/null
+++ b/include/linux/xylonfb_platform.h
@@ -0,0 +1,58 @@
+/*
+ * Xylon logiCVC frame buffer driver platform data structures
+ *
+ * Author: Xylon d.o.o.
+ * e-mail: davor.joja@logicbricks.com
+ *
+ * 2012 (c) Xylon d.o.o.
+ *
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2.  This program is licensed "as is" without any warranty of any
+ * kind, whether express or implied.
+ */
+
+#ifndef	__XYLON_FB_PLATFORM_H__
+#define __XYLON_FB_PLATFORM_H__
+
+
+#include <linux/types.h>
+
+
+/* Framebuffer driver platform layer structure */
+struct xylonfb_platform_layer_params
+{
+	/* Layer memory offset in lines */
+	unsigned int offset;
+	/* Layer buffer memory offset in lines */
+	unsigned short buffer_offset;
+	/* Layer bits per pixel */
+	unsigned char bpp;
+	/* Layer alpha mode */
+	unsigned char alpha_mode;
+	/* Layer control register value */
+	unsigned char ctrl;
+};
+
+/* Framebuffer driver platform data structure */
+struct xylonfb_platform_data
+{
+	struct xylonfb_platform_layer_params *layer_params;
+	/* logiCVC Control Register value */
+	u32 ctrl_reg;
+	/* Physical starting address of the video memory */
+	unsigned long vmem_base_addr;
+	/* Physical ending address of the video memory */
+	unsigned long vmem_high_addr;
+	/* Layer row stride in pixels */
+	unsigned short row_stride;
+	/* Number of logiCVC layers */
+	unsigned char num_layers;
+	/* logiCVC layer ID for FB console */
+	unsigned char active_layer;
+	/* Background layer bits per pixel */
+	unsigned char bg_layer_bpp;
+	/* Background layer alpha mode */
+	unsigned char bg_layer_alpha_mode;
+};
+
+#endif /* __XYLON_FB_PLATFORM_H__ */
-- 
1.7.0

