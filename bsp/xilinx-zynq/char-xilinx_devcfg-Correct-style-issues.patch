From 26ce1622b6a630d3291646ce177e40c146dc33b5 Mon Sep 17 00:00:00 2001
From: Soren Brinkmann <soren.brinkmann@xilinx.com>
Date: Fri, 4 Jan 2013 10:28:43 -0800
Subject: [PATCH 016/793] char: xilinx_devcfg: Correct style issues

Mostly getting rid of unneeded line breaks.

Signed-off-by: Soren Brinkmann <soren.brinkmann@xilinx.com>
---
 drivers/char/xilinx_devcfg.c |  517 ++++++++++++++++--------------------------
 1 files changed, 200 insertions(+), 317 deletions(-)

diff --git a/drivers/char/xilinx_devcfg.c b/drivers/char/xilinx_devcfg.c
index 02dde55..7e82013 100644
--- a/drivers/char/xilinx_devcfg.c
+++ b/drivers/char/xilinx_devcfg.c
@@ -45,7 +45,7 @@
 /* An array, which is set to true when the device is registered. */
 static DEFINE_MUTEX(xdevcfg_mutex);
 
-/************ Constant Definitions *************/
+/* Constant Definitions */
 #define XDCFG_CTRL_OFFSET		0x00 /* Control Register */
 #define XDCFG_LOCK_OFFSET		0x04 /* Lock Register */
 #define XDCFG_INT_STS_OFFSET		0x0C /* Interrupt Status Register */
@@ -109,7 +109,6 @@ static DEFINE_MUTEX(xdevcfg_mutex);
  * @lock: Instance of spinlock
  * @base_address: The virtual device base address of the device registers
  * @is_partial_bitstream: Status bit to indicate partial/full bitstream
- *
  */
 struct xdevcfg_drvdata {
 	struct device *dev;
@@ -126,9 +125,7 @@ struct xdevcfg_drvdata {
 	bool is_partial_bitstream;
 };
 
-/*
- * Register read/write access routines
- */
+/* Register read/write access routines */
 #define xdevcfg_writereg(offset, val)	__raw_writel(val, offset)
 #define xdevcfg_readreg(offset)		__raw_readl(offset)
 
@@ -138,40 +135,45 @@ struct xdevcfg_drvdata {
  */
 static void xdevcfg_reset_pl(void __iomem *base_address)
 {
-
 	/*
-	 * Create a rising edge on PCFG_INIT. PCFG_INIT follows PCFG_PROG_B, so we need to
-	 * poll it after setting PCFG_PROG_B to make sure that the rising edge happens.
+	 * Create a rising edge on PCFG_INIT. PCFG_INIT follows PCFG_PROG_B,
+	 * so we need to * poll it after setting PCFG_PROG_B to make sure that
+	 * the rising edge happens.
 	 */
 	xdevcfg_writereg(base_address + XDCFG_CTRL_OFFSET,
-		(xdevcfg_readreg(base_address + XDCFG_CTRL_OFFSET) | XDCFG_CTRL_PCFG_PROG_B_MASK));
-	while(!(xdevcfg_readreg(base_address + XDCFG_STATUS_OFFSET) & XDCFG_STATUS_PCFG_INIT_MASK));
+			(xdevcfg_readreg(base_address + XDCFG_CTRL_OFFSET) |
+			 XDCFG_CTRL_PCFG_PROG_B_MASK));
+	while (!(xdevcfg_readreg(base_address + XDCFG_STATUS_OFFSET) &
+				XDCFG_STATUS_PCFG_INIT_MASK))
+		;
 
 	xdevcfg_writereg(base_address + XDCFG_CTRL_OFFSET,
-		(xdevcfg_readreg(base_address + XDCFG_CTRL_OFFSET) & ~XDCFG_CTRL_PCFG_PROG_B_MASK));
-	while(xdevcfg_readreg(base_address + XDCFG_STATUS_OFFSET) & XDCFG_STATUS_PCFG_INIT_MASK);
+			(xdevcfg_readreg(base_address + XDCFG_CTRL_OFFSET) &
+			 ~XDCFG_CTRL_PCFG_PROG_B_MASK));
+	while (xdevcfg_readreg(base_address + XDCFG_STATUS_OFFSET) &
+			XDCFG_STATUS_PCFG_INIT_MASK)
+		;
 
 	xdevcfg_writereg(base_address + XDCFG_CTRL_OFFSET,
-		(xdevcfg_readreg(base_address + XDCFG_CTRL_OFFSET) | XDCFG_CTRL_PCFG_PROG_B_MASK));
-	while(!(xdevcfg_readreg(base_address + XDCFG_STATUS_OFFSET) & XDCFG_STATUS_PCFG_INIT_MASK));
-
+			(xdevcfg_readreg(base_address + XDCFG_CTRL_OFFSET) |
+			 XDCFG_CTRL_PCFG_PROG_B_MASK));
+	while (!(xdevcfg_readreg(base_address + XDCFG_STATUS_OFFSET) &
+				XDCFG_STATUS_PCFG_INIT_MASK))
+		;
 }
 
 /**
  * xdevcfg_irq() - The main interrupt handler.
  * @irq:	The interrupt number.
  * @data:	Pointer to the driver data structure.
- *
  * returns: IRQ_HANDLED after the interrupt is handled.
- *
  **/
 static irqreturn_t xdevcfg_irq(int irq, void *data)
 {
-
 	u32 intr_status;
-	struct xdevcfg_drvdata *drvdata = (struct xdevcfg_drvdata *)data;
+	struct xdevcfg_drvdata *drvdata = data;
 
-	spin_lock(&(drvdata->lock));
+	spin_lock(&drvdata->lock);
 
 	intr_status = xdevcfg_readreg(drvdata->base_address +
 					XDCFG_INT_STS_OFFSET);
@@ -180,16 +182,14 @@ static irqreturn_t xdevcfg_irq(int irq, void *data)
 	xdevcfg_writereg(drvdata->base_address + XDCFG_INT_STS_OFFSET,
 				intr_status);
 
-	if ((intr_status & XDCFG_IXR_DMA_DONE_MASK) ==
-		XDCFG_IXR_DMA_DONE_MASK)
+	if ((intr_status & XDCFG_IXR_DMA_DONE_MASK) == XDCFG_IXR_DMA_DONE_MASK)
 		drvdata->dma_done = 1;
 
 	if ((intr_status & XDCFG_IXR_ERROR_FLAGS_MASK) ==
 			XDCFG_IXR_ERROR_FLAGS_MASK)
 		drvdata->error_status = 1;
 
-
-	spin_unlock(&(drvdata->lock));
+	spin_unlock(&drvdata->lock);
 
 	return IRQ_HANDLED;
 }
@@ -202,11 +202,10 @@ static irqreturn_t xdevcfg_irq(int irq, void *data)
  * @count:	The number of bytes to be written.
  * @ppos:	Pointer to the offset value
  * returns:	Success or error status.
- *
  **/
 static ssize_t
-xdevcfg_write(struct file *file, const char __user *buf,
-		size_t count, loff_t *ppos)
+xdevcfg_write(struct file *file, const char __user *buf, size_t count,
+		loff_t *ppos)
 {
 	u32 *kbuf;
 	int status;
@@ -220,8 +219,7 @@ xdevcfg_write(struct file *file, const char __user *buf,
 	if (status)
 		return status;
 
-	kbuf = dma_alloc_coherent(drvdata->dev, count,
-					&dma_addr, GFP_KERNEL);
+	kbuf = dma_alloc_coherent(drvdata->dev, count, &dma_addr, GFP_KERNEL);
 	if (!kbuf) {
 		status = -ENOMEM;
 		return status;
@@ -231,9 +229,7 @@ xdevcfg_write(struct file *file, const char __user *buf,
 		status = -EFAULT;
 		goto error;
 	}
-	/*
-	 * Enable DMA and error interrupts
-	 */
+	/* Enable DMA and error interrupts */
 	xdevcfg_writereg(drvdata->base_address + XDCFG_INT_STS_OFFSET,
 				XDCFG_IXR_ALL_MASK);
 
@@ -245,9 +241,7 @@ xdevcfg_write(struct file *file, const char __user *buf,
 	drvdata->dma_done = 0;
 	drvdata->error_status = 0;
 
-	/*
-	 * Initiate DMA write command
-	 */
+	/* Initiate DMA write command */
 	if (count < 0x1000)
 		xdevcfg_writereg(drvdata->base_address +
 			XDCFG_DMA_SRC_ADDR_OFFSET, (u32)(dma_addr + 1));
@@ -257,13 +251,11 @@ xdevcfg_write(struct file *file, const char __user *buf,
 
 	xdevcfg_writereg(drvdata->base_address + XDCFG_DMA_DEST_ADDR_OFFSET,
 				(u32)XDCFG_DMA_INVALID_ADDRESS);
-	/*
-	 * Convert number of bytes to number of words.
-	 */
+	/* Convert number of bytes to number of words.  */
 	if (count % 4)
-		transfer_length	= (count/4 + 1);
+		transfer_length	= (count / 4 + 1);
 	else
-		transfer_length	= count/4;
+		transfer_length	= count / 4;
 	xdevcfg_writereg(drvdata->base_address + XDCFG_DMA_SRC_LEN_OFFSET,
 				transfer_length);
 	xdevcfg_writereg(drvdata->base_address + XDCFG_DMA_DEST_LEN_OFFSET, 0);
@@ -271,7 +263,6 @@ xdevcfg_write(struct file *file, const char __user *buf,
 	timeout = jiffies + msecs_to_jiffies(1000);
 
 	while (!drvdata->dma_done) {
-
 		if (time_after(jiffies, timeout)) {
 				status = -ETIMEDOUT;
 				goto error;
@@ -281,9 +272,7 @@ xdevcfg_write(struct file *file, const char __user *buf,
 	if (drvdata->error_status)
 		status = drvdata->error_status;
 
-	/*
-	 * Disable the DMA and error interrupts
-	 */
+	/* Disable the DMA and error interrupts */
 	intr_reg = xdevcfg_readreg(drvdata->base_address +
 					XDCFG_INT_MASK_OFFSET);
 	xdevcfg_writereg(drvdata->base_address + XDCFG_INT_MASK_OFFSET,
@@ -298,10 +287,8 @@ xdevcfg_write(struct file *file, const char __user *buf,
 
 	status = count;
 
-
- error:
-	dma_free_coherent(drvdata->dev, count,
-			kbuf, dma_addr);
+error:
+	dma_free_coherent(drvdata->dev, count, kbuf, dma_addr);
 	mutex_unlock(&drvdata->sem);
 	return status;
 }
@@ -314,8 +301,7 @@ xdevcfg_write(struct file *file, const char __user *buf,
  * @count:	The number of bytes read.
  * @ppos:	Pointer to the offsetvalue
  * returns:	Success or error status.
- *
- **/
+ */
 static ssize_t
 xdevcfg_read(struct file *file, char __user *buf, size_t count, loff_t *ppos)
 {
@@ -331,8 +317,7 @@ xdevcfg_read(struct file *file, char __user *buf, size_t count, loff_t *ppos)
 		return status;
 
 	/* Get new data from the ICAP, and return was requested. */
-	kbuf = dma_alloc_coherent(drvdata->dev, count,
-					&dma_addr, GFP_KERNEL);
+	kbuf = dma_alloc_coherent(drvdata->dev, count, &dma_addr, GFP_KERNEL);
 	if (!kbuf) {
 		status = -ENOMEM;
 		return status;
@@ -341,43 +326,35 @@ xdevcfg_read(struct file *file, char __user *buf, size_t count, loff_t *ppos)
 	drvdata->dma_done = 0;
 	drvdata->error_status = 0;
 
-	/*
-	 * Enable DMA and error interrupts
-	 */
+	/* Enable DMA and error interrupts */
 	xdevcfg_writereg(drvdata->base_address + XDCFG_INT_STS_OFFSET,
 				XDCFG_IXR_ALL_MASK);
 
 	xdevcfg_writereg(drvdata->base_address + XDCFG_INT_MASK_OFFSET,
 				(u32) (~(XDCFG_IXR_DMA_DONE_MASK |
 				XDCFG_IXR_ERROR_FLAGS_MASK)));
-	/*
-	 * Initiate DMA read command
-	 */
+	/* Initiate DMA read command */
 	xdevcfg_writereg(drvdata->base_address + XDCFG_DMA_SRC_ADDR_OFFSET,
 				(u32)XDCFG_DMA_INVALID_ADDRESS);
 	xdevcfg_writereg(drvdata->base_address + XDCFG_DMA_DEST_ADDR_OFFSET,
 				(u32)dma_addr);
-	xdevcfg_writereg(drvdata->base_address + XDCFG_DMA_SRC_LEN_OFFSET,
-				0);
+	xdevcfg_writereg(drvdata->base_address + XDCFG_DMA_SRC_LEN_OFFSET, 0);
 	xdevcfg_writereg(drvdata->base_address + XDCFG_DMA_DEST_LEN_OFFSET,
-				count/4);
+				count / 4);
 
 	timeout = jiffies + msecs_to_jiffies(1000);
 
 	while (!drvdata->dma_done) {
-
 		if (time_after(jiffies, timeout)) {
-				status = -ETIMEDOUT;
-				goto error;
+			status = -ETIMEDOUT;
+			goto error;
 		}
 	}
 
 	if (drvdata->error_status)
 		status = drvdata->error_status;
 
-	/*
-	 * Disable and clear DMA and error interrupts
-	 */
+	/* Disable and clear DMA and error interrupts */
 	intr_reg = xdevcfg_readreg(drvdata->base_address +
 					XDCFG_INT_MASK_OFFSET);
 	xdevcfg_writereg(drvdata->base_address + XDCFG_INT_MASK_OFFSET,
@@ -399,8 +376,7 @@ xdevcfg_read(struct file *file, char __user *buf, size_t count, loff_t *ppos)
 
 	status = count;
  error:
-	dma_free_coherent(drvdata->dev, count,
-			kbuf, dma_addr);
+	dma_free_coherent(drvdata->dev, count, kbuf, dma_addr);
 	mutex_unlock(&drvdata->sem);
 
 	return status;
@@ -410,10 +386,8 @@ xdevcfg_read(struct file *file, char __user *buf, size_t count, loff_t *ppos)
  * xdevcfg_open() - The is the driver open function.
  * @inode:	Pointer to the inode structure of this device.
  * @file:	Pointer to the file structure.
- *
  * returns:	Success or error status.
- *
- **/
+ */
 static int xdevcfg_open(struct inode *inode, struct file *file)
 {
 	struct xdevcfg_drvdata *drvdata;
@@ -433,26 +407,30 @@ static int xdevcfg_open(struct inode *inode, struct file *file)
 	file->private_data = drvdata;
 	drvdata->is_open = 1;
 
-	/* If is_partial_bitstream is set, then PROG_B is not asserted
+	/*
+	 * If is_partial_bitstream is set, then PROG_B is not asserted
 	 * (xdevcfg_reset_pl function) and also xslcr_init_preload_fpga and
 	 * xslcr_init_postload_fpga functions are not invoked.
 	 */
 	if (!drvdata->is_partial_bitstream)
 		xslcr_init_preload_fpga();
 
-	/* Only do the reset of the PL for Zynq as it causes problems on the EP107
-	 * and the issue is not understood, but not worth investigating as the emulation
-	 * platform is very different than silicon and not a complete implementation
-	 * Also, do not reset if it is a partial bitstream.
+	/*
+	 * Only do the reset of the PL for Zynq as it causes problems on the
+	 * EP107 and the issue is not understood, but not worth investigating
+	 * as the emulation platform is very different than silicon and not a
+	 * complete implementation. Also, do not reset if it is a partial
+	 * bitstream.
 	 */
-	if ( (!drvdata->ep107) && (!drvdata->is_partial_bitstream) )
+	if ((!drvdata->ep107) && (!drvdata->is_partial_bitstream))
 		xdevcfg_reset_pl(drvdata->base_address);
 
-	xdevcfg_writereg(drvdata->base_address + XDCFG_INT_STS_OFFSET, XDCFG_IXR_PCFG_DONE_MASK);
+	xdevcfg_writereg(drvdata->base_address + XDCFG_INT_STS_OFFSET,
+			XDCFG_IXR_PCFG_DONE_MASK);
 
- error:
+error:
 	mutex_unlock(&drvdata->sem);
- out:
+out:
 	return status;
 }
 
@@ -460,10 +438,8 @@ static int xdevcfg_open(struct inode *inode, struct file *file)
  * xdevcfg_release() - The is the driver release function.
  * @inode:	Pointer to the inode structure of this device.
  * @file:	Pointer to the file structure.
- *
  * returns:	Success.
- *
- **/
+ */
 static int xdevcfg_release(struct inode *inode, struct file *file)
 {
 	struct xdevcfg_drvdata *drvdata = file->private_data;
@@ -499,40 +475,37 @@ static const struct file_operations xdevcfg_fops = {
  * @size:	The number of bytes used from the buffer
  * returns:	negative error if the string could not be converted
  *		or the size of the buffer.
- *
- **/
+ */
 static ssize_t xdevcfg_set_dap_en(struct device *dev,
-				     struct device_attribute *attr,
-				     const char *buf, size_t size)
+		struct device_attribute *attr, const char *buf, size_t size)
 {
 	u32 ctrl_reg_status;
 	unsigned long flags;
 	unsigned long mask_bit;
 	int status;
-	struct xdevcfg_drvdata *drvdata =
-		(struct xdevcfg_drvdata *)dev_get_drvdata(dev);
+	struct xdevcfg_drvdata *drvdata = dev_get_drvdata(dev);
 
 	ctrl_reg_status = xdevcfg_readreg(drvdata->base_address +
 				XDCFG_CTRL_OFFSET);
-	spin_lock_irqsave(&(drvdata->lock), flags);
+	spin_lock_irqsave(&drvdata->lock, flags);
 
 	status = strict_strtoul(buf, 10, &mask_bit);
 
 	if (status) {
-		spin_unlock_irqrestore(&(drvdata->lock), flags);
+		spin_unlock_irqrestore(&drvdata->lock, flags);
 		return status;
 	}
 
 	if (mask_bit > 7) {
-		spin_unlock_irqrestore(&(drvdata->lock), flags);
+		spin_unlock_irqrestore(&drvdata->lock, flags);
 		return -EINVAL;
 	}
 
 	xdevcfg_writereg(drvdata->base_address + XDCFG_CTRL_OFFSET,
-				(ctrl_reg_status |
-				(((u32)mask_bit) & XDCFG_CTRL_DAP_EN_MASK)));
+			(ctrl_reg_status |
+			 (((u32)mask_bit) & XDCFG_CTRL_DAP_EN_MASK)));
 
-	spin_unlock_irqrestore(&(drvdata->lock), flags);
+	spin_unlock_irqrestore(&drvdata->lock, flags);
 
 	return size;
 }
@@ -545,19 +518,16 @@ static ssize_t xdevcfg_set_dap_en(struct device *dev,
  * @buf:	Pointer to the buffer location for the configuration
  *		data.
  * returns:	Size of the buffer.
- *
- **/
+ */
 static ssize_t xdevcfg_show_dap_en_status(struct device *dev,
 		struct device_attribute *attr, char *buf)
 {
 	u32 dap_en_status;
 	int status;
-	struct xdevcfg_drvdata *drvdata =
-		(struct xdevcfg_drvdata *)dev_get_drvdata(dev);
+	struct xdevcfg_drvdata *drvdata = dev_get_drvdata(dev);
 
 	dap_en_status = xdevcfg_readreg(drvdata->base_address +
-				XDCFG_CTRL_OFFSET) &
-				XDCFG_CTRL_DAP_EN_MASK;
+				XDCFG_CTRL_OFFSET) & XDCFG_CTRL_DAP_EN_MASK;
 
 	status = sprintf(buf, "%d\n", dap_en_status);
 
@@ -576,18 +546,15 @@ static DEVICE_ATTR(enable_dap, 0644, xdevcfg_show_dap_en_status,
  *		data.
  * @size:	The number of bytes used from the buffer
  * returns:	-EINVAL if invalid parameter is sent or size
- *
- **/
+ */
 static ssize_t xdevcfg_set_dbgen(struct device *dev,
-				     struct device_attribute *attr,
-				     const char *buf, size_t size)
+		struct device_attribute *attr, const char *buf, size_t size)
 {
 	u32 ctrl_reg_status;
 	unsigned long flags;
 	unsigned long mask_bit;
 	int status;
-	struct xdevcfg_drvdata *drvdata =
-			(struct xdevcfg_drvdata *)dev_get_drvdata(dev);
+	struct xdevcfg_drvdata *drvdata = dev_get_drvdata(dev);
 
 	ctrl_reg_status = xdevcfg_readreg(drvdata->base_address +
 				XDCFG_CTRL_OFFSET);
@@ -600,17 +567,16 @@ static ssize_t xdevcfg_set_dbgen(struct device *dev,
 	if (mask_bit > 1)
 		return -EINVAL;
 
-	spin_lock_irqsave(&(drvdata->lock), flags);
+	spin_lock_irqsave(&drvdata->lock, flags);
 
 	if (mask_bit)
 		xdevcfg_writereg(drvdata->base_address + XDCFG_CTRL_OFFSET,
-					(ctrl_reg_status |
-					XDCFG_CTRL_DBGEN_MASK));
+				(ctrl_reg_status | XDCFG_CTRL_DBGEN_MASK));
 	else
 		xdevcfg_writereg(drvdata->base_address + XDCFG_CTRL_OFFSET,
-					(ctrl_reg_status &
-					(~XDCFG_CTRL_DBGEN_MASK)));
-	spin_unlock_irqrestore(&(drvdata->lock), flags);
+				(ctrl_reg_status & (~XDCFG_CTRL_DBGEN_MASK)));
+
+	spin_unlock_irqrestore(&drvdata->lock, flags);
 
 	return size;
 }
@@ -623,19 +589,16 @@ static ssize_t xdevcfg_set_dbgen(struct device *dev,
  * @buf:	Pointer to the buffer location for the configuration
  *		data.
  * returns:	Size of the buffer.
- *
- **/
+ */
 static ssize_t xdevcfg_show_dbgen_status(struct device *dev,
 		struct device_attribute *attr, char *buf)
 {
 	u32 dbgen_status;
 	ssize_t status;
-	struct xdevcfg_drvdata *drvdata =
-			(struct xdevcfg_drvdata *)dev_get_drvdata(dev);
+	struct xdevcfg_drvdata *drvdata = dev_get_drvdata(dev);
 
 	dbgen_status = xdevcfg_readreg(drvdata->base_address +
-				XDCFG_CTRL_OFFSET) &
-				XDCFG_CTRL_DBGEN_MASK;
+				XDCFG_CTRL_OFFSET) & XDCFG_CTRL_DBGEN_MASK;
 
 	status = sprintf(buf, "%d\n", (dbgen_status >> 3));
 
@@ -654,18 +617,15 @@ static DEVICE_ATTR(enable_dbg_in, 0644, xdevcfg_show_dbgen_status,
  *		data.
  * @size:	The number of bytes used from the buffer
  * returns:	-EINVAL if invalid parameter is sent or size
- *
- **/
+ */
 static ssize_t xdevcfg_set_niden(struct device *dev,
-				     struct device_attribute *attr,
-				     const char *buf, size_t size)
+		struct device_attribute *attr, const char *buf, size_t size)
 {
 	u32 ctrl_reg_status;
 	unsigned long flags;
 	unsigned long mask_bit;
 	int status;
-	struct xdevcfg_drvdata *drvdata =
-			(struct xdevcfg_drvdata *)dev_get_drvdata(dev);
+	struct xdevcfg_drvdata *drvdata = dev_get_drvdata(dev);
 
 	ctrl_reg_status = xdevcfg_readreg(drvdata->base_address +
 				XDCFG_CTRL_OFFSET);
@@ -678,18 +638,16 @@ static ssize_t xdevcfg_set_niden(struct device *dev,
 	if (mask_bit > 1)
 		return -EINVAL;
 
-	spin_lock_irqsave(&(drvdata->lock), flags);
+	spin_lock_irqsave(&drvdata->lock, flags);
 
 	if (mask_bit)
 		xdevcfg_writereg(drvdata->base_address + XDCFG_CTRL_OFFSET,
-					(ctrl_reg_status |
-					XDCFG_CTRL_NIDEN_MASK));
+				(ctrl_reg_status | XDCFG_CTRL_NIDEN_MASK));
 	else
 		xdevcfg_writereg(drvdata->base_address + XDCFG_CTRL_OFFSET,
-					(ctrl_reg_status &
-					(~XDCFG_CTRL_NIDEN_MASK)));
+				(ctrl_reg_status & (~XDCFG_CTRL_NIDEN_MASK)));
 
-	spin_unlock_irqrestore(&(drvdata->lock), flags);
+	spin_unlock_irqrestore(&drvdata->lock, flags);
 
 	return size;
 }
@@ -702,19 +660,16 @@ static ssize_t xdevcfg_set_niden(struct device *dev,
  * @buf:	Pointer to the buffer location for the configuration
  *		data.
  * returns:	Size of the buffer.
- *
- **/
+ */
 static ssize_t xdevcfg_show_niden_status(struct device *dev,
 		struct device_attribute *attr, char *buf)
 {
 	u32 niden_status;
 	ssize_t status;
-	struct xdevcfg_drvdata *drvdata =
-			(struct xdevcfg_drvdata *)dev_get_drvdata(dev);
+	struct xdevcfg_drvdata *drvdata = dev_get_drvdata(dev);
 
 	niden_status = xdevcfg_readreg(drvdata->base_address +
-				XDCFG_CTRL_OFFSET) &
-				XDCFG_CTRL_NIDEN_MASK;
+				XDCFG_CTRL_OFFSET) & XDCFG_CTRL_NIDEN_MASK;
 
 	status = sprintf(buf, "%d\n", (niden_status >> 4));
 
@@ -733,18 +688,15 @@ static DEVICE_ATTR(enable_dbg_nonin, 0644, xdevcfg_show_niden_status,
  *		data.
  * @size:	The number of bytes used from the buffer
  * returns:	-EINVAL if invalid parameter is sent or size
- *
- **/
+ */
 static ssize_t xdevcfg_set_spiden(struct device *dev,
-				     struct device_attribute *attr,
-				     const char *buf, size_t size)
+		struct device_attribute *attr, const char *buf, size_t size)
 {
 	u32 ctrl_reg_status;
 	unsigned long flags;
 	unsigned long mask_bit;
 	int status;
-	struct xdevcfg_drvdata *drvdata =
-			(struct xdevcfg_drvdata *)dev_get_drvdata(dev);
+	struct xdevcfg_drvdata *drvdata = dev_get_drvdata(dev);
 
 	ctrl_reg_status = xdevcfg_readreg(drvdata->base_address +
 				XDCFG_CTRL_OFFSET);
@@ -757,19 +709,17 @@ static ssize_t xdevcfg_set_spiden(struct device *dev,
 	if (mask_bit > 1)
 		return -EINVAL;
 
-	spin_lock_irqsave(&(drvdata->lock), flags);
-	if (mask_bit) {
+	spin_lock_irqsave(&drvdata->lock, flags);
 
+	if (mask_bit)
 		xdevcfg_writereg(drvdata->base_address + XDCFG_CTRL_OFFSET,
-					(ctrl_reg_status |
-					XDCFG_CTRL_SPIDEN_MASK));
-	} else {
+				(ctrl_reg_status | XDCFG_CTRL_SPIDEN_MASK));
+	else
 
 		xdevcfg_writereg(drvdata->base_address + XDCFG_CTRL_OFFSET,
-					(ctrl_reg_status &
-					(~XDCFG_CTRL_SPIDEN_MASK)));
-	}
-	spin_unlock_irqrestore(&(drvdata->lock), flags);
+				(ctrl_reg_status & (~XDCFG_CTRL_SPIDEN_MASK)));
+
+	spin_unlock_irqrestore(&drvdata->lock, flags);
 
 	return size;
 }
@@ -782,19 +732,16 @@ static ssize_t xdevcfg_set_spiden(struct device *dev,
  * @buf:	Pointer to the buffer location for the configuration
  *		data.
  * returns:	Size of the buffer.
- *
- **/
+ */
 static ssize_t xdevcfg_show_spiden_status(struct device *dev,
 		struct device_attribute *attr, char *buf)
 {
 	u32 spiden_status;
 	ssize_t status;
-	struct xdevcfg_drvdata *drvdata =
-			(struct xdevcfg_drvdata *)dev_get_drvdata(dev);
+	struct xdevcfg_drvdata *drvdata = dev_get_drvdata(dev);
 
 	spiden_status = xdevcfg_readreg(drvdata->base_address +
-				XDCFG_CTRL_OFFSET) &
-				XDCFG_CTRL_SPIDEN_MASK;
+			XDCFG_CTRL_OFFSET) & XDCFG_CTRL_SPIDEN_MASK;
 
 	status = sprintf(buf, "%d\n", (spiden_status >> 5));
 
@@ -813,18 +760,15 @@ static DEVICE_ATTR(enable_sec_dbg_in, 0644, xdevcfg_show_spiden_status,
  *		data.
  * @size:	The number of bytes used from the buffer
  * returns:	-EINVAL if invalid parameter is sent or the size of buffer
- *
- **/
+ */
 static ssize_t xdevcfg_set_spniden(struct device *dev,
-				     struct device_attribute *attr,
-				     const char *buf, size_t size)
+		struct device_attribute *attr, const char *buf, size_t size)
 {
 	u32 ctrl_reg_status;
 	unsigned long flags;
 	unsigned long mask_bit;
 	ssize_t status;
-	struct xdevcfg_drvdata *drvdata =
-			(struct xdevcfg_drvdata *)dev_get_drvdata(dev);
+	struct xdevcfg_drvdata *drvdata = dev_get_drvdata(dev);
 
 	ctrl_reg_status = xdevcfg_readreg(drvdata->base_address +
 				XDCFG_CTRL_OFFSET);
@@ -836,18 +780,16 @@ static ssize_t xdevcfg_set_spniden(struct device *dev,
 	if (mask_bit > 1)
 		return -EINVAL;
 
-	spin_lock_irqsave(&(drvdata->lock), flags);
+	spin_lock_irqsave(&drvdata->lock, flags);
 
 	if (mask_bit)
 		xdevcfg_writereg(drvdata->base_address + XDCFG_CTRL_OFFSET,
-					(ctrl_reg_status |
-				XDCFG_CTRL_SPNIDEN_MASK));
+				(ctrl_reg_status | XDCFG_CTRL_SPNIDEN_MASK));
 	else
 		xdevcfg_writereg(drvdata->base_address + XDCFG_CTRL_OFFSET,
-					(ctrl_reg_status &
-				(~XDCFG_CTRL_SPNIDEN_MASK)));
+				(ctrl_reg_status & (~XDCFG_CTRL_SPNIDEN_MASK)));
 
-	spin_unlock_irqrestore(&(drvdata->lock), flags);
+	spin_unlock_irqrestore(&drvdata->lock, flags);
 
 	return size;
 }
@@ -860,19 +802,16 @@ static ssize_t xdevcfg_set_spniden(struct device *dev,
  * @buf:	Pointer to the buffer location for the configuration
  *		data.
  * returns:	Size of the buffer.
- *
- **/
+ */
 static ssize_t xdevcfg_show_spniden_status(struct device *dev,
 		struct device_attribute *attr, char *buf)
 {
 	u32 spniden_status;
 	ssize_t status;
-	struct xdevcfg_drvdata *drvdata =
-		(struct xdevcfg_drvdata *)dev_get_drvdata(dev);
+	struct xdevcfg_drvdata *drvdata = dev_get_drvdata(dev);
 
 	spniden_status = xdevcfg_readreg(drvdata->base_address +
-				XDCFG_CTRL_OFFSET) &
-				XDCFG_CTRL_SPNIDEN_MASK;
+			XDCFG_CTRL_OFFSET) & XDCFG_CTRL_SPNIDEN_MASK;
 
 	status = sprintf(buf, "%d\n", (spniden_status >> 6));
 
@@ -891,18 +830,15 @@ static DEVICE_ATTR(enable_sec_dbg_nonin, 0644, xdevcfg_show_spniden_status,
  *		data.
  * @size:	The number of bytes used from the buffer
  * returns:	-EINVAL if invalid parameter is sent or size
- *
- **/
+ */
 static ssize_t xdevcfg_set_seu(struct device *dev,
-				     struct device_attribute *attr,
-				     const char *buf, size_t size)
+		struct device_attribute *attr, const char *buf, size_t size)
 {
 	u32 ctrl_reg_status;
 	unsigned long flags;
 	unsigned long mask_bit;
 	ssize_t status;
-	struct xdevcfg_drvdata *drvdata =
-			(struct xdevcfg_drvdata *)dev_get_drvdata(dev);
+	struct xdevcfg_drvdata *drvdata = dev_get_drvdata(dev);
 
 	ctrl_reg_status = xdevcfg_readreg(drvdata->base_address +
 				XDCFG_CTRL_OFFSET);
@@ -915,18 +851,16 @@ static ssize_t xdevcfg_set_seu(struct device *dev,
 	if (mask_bit > 1)
 		return -EINVAL;
 
-	spin_lock_irqsave(&(drvdata->lock), flags);
+	spin_lock_irqsave(&drvdata->lock, flags);
 
 	if (mask_bit)
 		xdevcfg_writereg(drvdata->base_address + XDCFG_CTRL_OFFSET,
-					(ctrl_reg_status |
-					XDCFG_CTRL_SEU_EN_MASK));
+				(ctrl_reg_status | XDCFG_CTRL_SEU_EN_MASK));
 	else
 		xdevcfg_writereg(drvdata->base_address + XDCFG_CTRL_OFFSET,
-					(ctrl_reg_status &
-					(~XDCFG_CTRL_SEU_EN_MASK)));
+				(ctrl_reg_status & (~XDCFG_CTRL_SEU_EN_MASK)));
 
-	spin_unlock_irqrestore(&(drvdata->lock), flags);
+	spin_unlock_irqrestore(&drvdata->lock, flags);
 
 	return size;
 }
@@ -939,19 +873,16 @@ static ssize_t xdevcfg_set_seu(struct device *dev,
  * @buf:	Pointer to the buffer location for the configuration
  *		data.
  * returns:	size of the buffer.
- *
- **/
+ */
 static ssize_t xdevcfg_show_seu_status(struct device *dev,
 		struct device_attribute *attr, char *buf)
 {
 	u32 seu_status;
 	ssize_t status;
-	struct xdevcfg_drvdata *drvdata =
-			(struct xdevcfg_drvdata *)dev_get_drvdata(dev);
+	struct xdevcfg_drvdata *drvdata = dev_get_drvdata(dev);
 
 	seu_status = xdevcfg_readreg(drvdata->base_address +
-				XDCFG_CTRL_OFFSET) &
-				XDCFG_CTRL_SEU_EN_MASK;
+			XDCFG_CTRL_OFFSET) & XDCFG_CTRL_SEU_EN_MASK;
 
 	status = sprintf(buf, "%d\n", (seu_status > 8));
 
@@ -960,7 +891,6 @@ static ssize_t xdevcfg_show_seu_status(struct device *dev,
 
 static DEVICE_ATTR(enable_seu, 0644, xdevcfg_show_seu_status, xdevcfg_set_seu);
 
-
 /**
  * xdevcfg_set_aes() - This function sets the AES_EN bits in the
  * control register with either all 1s or all 0s.
@@ -973,17 +903,15 @@ static DEVICE_ATTR(enable_seu, 0644, xdevcfg_show_seu_status, xdevcfg_set_seu);
  *
  * The user must send only one bit in the buffer to notify whether he wants to
  * either set or reset these bits.
- **/
+ */
 static ssize_t xdevcfg_set_aes(struct device *dev,
-				     struct device_attribute *attr,
-				     const char *buf, size_t size)
+		struct device_attribute *attr, const char *buf, size_t size)
 {
 	u32 ctrl_reg_status;
 	unsigned long flags;
 	unsigned long mask_bit;
 	int status;
-	struct xdevcfg_drvdata *drvdata =
-			(struct xdevcfg_drvdata *)dev_get_drvdata(dev);
+	struct xdevcfg_drvdata *drvdata = dev_get_drvdata(dev);
 
 	ctrl_reg_status = xdevcfg_readreg(drvdata->base_address +
 				XDCFG_CTRL_OFFSET);
@@ -997,18 +925,18 @@ static ssize_t xdevcfg_set_aes(struct device *dev,
 		return -EINVAL;
 
 
-	spin_lock_irqsave(&(drvdata->lock), flags);
+	spin_lock_irqsave(&drvdata->lock, flags);
 
 	if (mask_bit)
 		xdevcfg_writereg(drvdata->base_address + XDCFG_CTRL_OFFSET,
-					(ctrl_reg_status |
-					XDCFG_CTRL_PCFG_AES_EN_MASK));
+				(ctrl_reg_status |
+				 XDCFG_CTRL_PCFG_AES_EN_MASK));
 	else
 		xdevcfg_writereg(drvdata->base_address + XDCFG_CTRL_OFFSET,
-					(ctrl_reg_status &
-					(~XDCFG_CTRL_PCFG_AES_EN_MASK)));
+				(ctrl_reg_status &
+				 (~XDCFG_CTRL_PCFG_AES_EN_MASK)));
 
-	spin_unlock_irqrestore(&(drvdata->lock), flags);
+	spin_unlock_irqrestore(&drvdata->lock, flags);
 
 	return size;
 }
@@ -1021,20 +949,16 @@ static ssize_t xdevcfg_set_aes(struct device *dev,
  * @buf:	Pointer to the buffer location for the configuration
  *		data.
  * returns:	size of the buffer.
- *
- **/
+ */
 static ssize_t xdevcfg_show_aes_status(struct device *dev,
 		struct device_attribute *attr, char *buf)
 {
 	u32 aes_status;
 	ssize_t status;
-	struct xdevcfg_drvdata *drvdata =
-		(struct xdevcfg_drvdata *)dev_get_drvdata(dev);
+	struct xdevcfg_drvdata *drvdata = dev_get_drvdata(dev);
 
 	aes_status = xdevcfg_readreg(drvdata->base_address +
-				XDCFG_CTRL_OFFSET) &
-				XDCFG_CTRL_PCFG_AES_EN_MASK;
-
+			XDCFG_CTRL_OFFSET) & XDCFG_CTRL_PCFG_AES_EN_MASK;
 
 	status = sprintf(buf, "%d\n", (aes_status >> 9));
 
@@ -1052,18 +976,15 @@ static DEVICE_ATTR(enable_aes, 0644, xdevcfg_show_aes_status, xdevcfg_set_aes);
  *		data.
  * @size:	The number of bytes used from the buffer
  * returns:	-EINVAL if invalid parameter is sent or size
- *
- **/
+ */
 static ssize_t xdevcfg_set_aes_en_lock(struct device *dev,
-				     struct device_attribute *attr,
-				     const char *buf, size_t size)
+		struct device_attribute *attr, const char *buf, size_t size)
 {
 	u32 aes_en_lock_status;
 	unsigned long flags;
 	unsigned long mask_bit;
 	ssize_t status;
-	struct xdevcfg_drvdata *drvdata =
-		(struct xdevcfg_drvdata *)dev_get_drvdata(dev);
+	struct xdevcfg_drvdata *drvdata = dev_get_drvdata(dev);
 
 	aes_en_lock_status = xdevcfg_readreg(drvdata->base_address +
 				XDCFG_LOCK_OFFSET);
@@ -1076,18 +997,17 @@ static ssize_t xdevcfg_set_aes_en_lock(struct device *dev,
 	if (mask_bit > 1)
 		return -EINVAL;
 
-	spin_lock_irqsave(&(drvdata->lock), flags);
+	spin_lock_irqsave(&drvdata->lock, flags);
 
 	if (mask_bit)
 		xdevcfg_writereg(drvdata->base_address + XDCFG_LOCK_OFFSET,
-					(aes_en_lock_status |
-					XDCFG_LOCK_AES_EN_MASK));
+				(aes_en_lock_status | XDCFG_LOCK_AES_EN_MASK));
 	else
 		xdevcfg_writereg(drvdata->base_address + XDCFG_LOCK_OFFSET,
-					(aes_en_lock_status &
-					(~XDCFG_LOCK_AES_EN_MASK)));
+				(aes_en_lock_status &
+				 (~XDCFG_LOCK_AES_EN_MASK)));
 
-	spin_unlock_irqrestore(&(drvdata->lock), flags);
+	spin_unlock_irqrestore(&drvdata->lock, flags);
 
 	return size;
 }
@@ -1100,19 +1020,16 @@ static ssize_t xdevcfg_set_aes_en_lock(struct device *dev,
  * @buf:	Pointer to the buffer location for the configuration
  *		data.
  * returns:	size of the buffer.
- *
- **/
+ */
 static ssize_t xdevcfg_show_aes_en_lock_status(struct device *dev,
 		struct device_attribute *attr, char *buf)
 {
 	u32 aes_en_lock_status;
 	ssize_t status;
-	struct xdevcfg_drvdata *drvdata =
-		(struct xdevcfg_drvdata *)dev_get_drvdata(dev);
+	struct xdevcfg_drvdata *drvdata = dev_get_drvdata(dev);
 
 	aes_en_lock_status = xdevcfg_readreg(drvdata->base_address +
-				XDCFG_LOCK_OFFSET) &
-				XDCFG_LOCK_AES_EN_MASK;
+			XDCFG_LOCK_OFFSET) & XDCFG_LOCK_AES_EN_MASK;
 
 	status = sprintf(buf, "%d\n", (aes_en_lock_status >> 3));
 
@@ -1131,18 +1048,15 @@ static DEVICE_ATTR(aes_en_lock, 0644, xdevcfg_show_aes_en_lock_status,
  *		data.
  * @size:	The number of bytes used from the buffer
  * returns:	-EINVAL if invalid parameter is sent or size
- *
- **/
+ */
 static ssize_t xdevcfg_set_seu_lock(struct device *dev,
-				     struct device_attribute *attr,
-				     const char *buf, size_t size)
+		struct device_attribute *attr, const char *buf, size_t size)
 {
 	u32 seu_lock_status;
 	unsigned long flags;
 	unsigned long mask_bit;
 	ssize_t status;
-	struct xdevcfg_drvdata *drvdata =
-			(struct xdevcfg_drvdata *)dev_get_drvdata(dev);
+	struct xdevcfg_drvdata *drvdata = dev_get_drvdata(dev);
 
 	seu_lock_status = xdevcfg_readreg(drvdata->base_address +
 				XDCFG_LOCK_OFFSET);
@@ -1155,18 +1069,16 @@ static ssize_t xdevcfg_set_seu_lock(struct device *dev,
 	if (mask_bit > 1)
 		return -EINVAL;
 
-	spin_lock_irqsave(&(drvdata->lock), flags);
+	spin_lock_irqsave(&drvdata->lock, flags);
 
 	if (mask_bit)
 		xdevcfg_writereg(drvdata->base_address + XDCFG_LOCK_OFFSET,
-					(seu_lock_status |
-					XDCFG_LOCK_SEU_MASK));
+				(seu_lock_status | XDCFG_LOCK_SEU_MASK));
 	else
 		xdevcfg_writereg(drvdata->base_address + XDCFG_LOCK_OFFSET,
-					(seu_lock_status  &
-					(~XDCFG_LOCK_SEU_MASK)));
+				(seu_lock_status  & (~XDCFG_LOCK_SEU_MASK)));
 
-	spin_unlock_irqrestore(&(drvdata->lock), flags);
+	spin_unlock_irqrestore(&drvdata->lock, flags);
 
 	return size;
 }
@@ -1179,19 +1091,16 @@ static ssize_t xdevcfg_set_seu_lock(struct device *dev,
  * @buf:	Pointer to the buffer location for the configuration
  *		data.
  * returns:	size of the buffer.
- *
- **/
+ */
 static ssize_t xdevcfg_show_seu_lock_status(struct device *dev,
 		struct device_attribute *attr, char *buf)
 {
 	u32 seu_lock_status;
 	ssize_t status;
-	struct xdevcfg_drvdata *drvdata =
-			(struct xdevcfg_drvdata *)dev_get_drvdata(dev);
+	struct xdevcfg_drvdata *drvdata = dev_get_drvdata(dev);
 
 	seu_lock_status = xdevcfg_readreg(drvdata->base_address +
-				XDCFG_LOCK_OFFSET) &
-				XDCFG_LOCK_SEU_MASK;
+			XDCFG_LOCK_OFFSET) & XDCFG_LOCK_SEU_MASK;
 
 	status = sprintf(buf, "%d\n", (seu_lock_status >> 2));
 
@@ -1201,7 +1110,6 @@ static ssize_t xdevcfg_show_seu_lock_status(struct device *dev,
 static DEVICE_ATTR(seu_lock, 0644, xdevcfg_show_seu_lock_status,
 					xdevcfg_set_seu_lock);
 
-
 /**
  * xdevcfg_set_dbg_lock() - This function sets the LOCK_DBG bit in the
  * lock register.
@@ -1211,18 +1119,15 @@ static DEVICE_ATTR(seu_lock, 0644, xdevcfg_show_seu_lock_status,
  *		data.
  * @size:	The number of bytes used from the buffer
  * returns:	-EINVAL if invalid parameter is sent or size
- *
- **/
+ */
 static ssize_t xdevcfg_set_dbg_lock(struct device *dev,
-				     struct device_attribute *attr,
-				     const char *buf, size_t size)
+		struct device_attribute *attr, const char *buf, size_t size)
 {
 	u32 lock_reg_status;
 	unsigned long flags;
 	unsigned long mask_bit;
 	ssize_t status;
-	struct xdevcfg_drvdata *drvdata =
-		(struct xdevcfg_drvdata *)dev_get_drvdata(dev);
+	struct xdevcfg_drvdata *drvdata = dev_get_drvdata(dev);
 
 	lock_reg_status = xdevcfg_readreg(drvdata->base_address +
 				XDCFG_LOCK_OFFSET);
@@ -1234,18 +1139,16 @@ static ssize_t xdevcfg_set_dbg_lock(struct device *dev,
 	if (mask_bit > 1)
 		return -EINVAL;
 
-	spin_lock_irqsave(&(drvdata->lock), flags);
+	spin_lock_irqsave(&drvdata->lock, flags);
 
 	if (mask_bit)
 		xdevcfg_writereg(drvdata->base_address + XDCFG_LOCK_OFFSET,
-					(lock_reg_status |
-					XDCFG_LOCK_DBG_MASK));
+				(lock_reg_status | XDCFG_LOCK_DBG_MASK));
 	else
 		xdevcfg_writereg(drvdata->base_address + XDCFG_LOCK_OFFSET,
-					(lock_reg_status &
-					(~XDCFG_LOCK_DBG_MASK)));
+				(lock_reg_status & (~XDCFG_LOCK_DBG_MASK)));
 
-	spin_unlock_irqrestore(&(drvdata->lock), flags);
+	spin_unlock_irqrestore(&drvdata->lock, flags);
 
 	return size;
 }
@@ -1258,19 +1161,16 @@ static ssize_t xdevcfg_set_dbg_lock(struct device *dev,
  * @buf:	Pointer to the buffer location for the configuration
  *		data.
  * returns:	size of the buffer.
- *
- **/
+ */
 static ssize_t xdevcfg_show_dbg_lock_status(struct device *dev,
 		struct device_attribute *attr, char *buf)
 {
 	u32 dbg_lock_status;
 	ssize_t status;
-	struct xdevcfg_drvdata *drvdata =
-		(struct xdevcfg_drvdata *)dev_get_drvdata(dev);
+	struct xdevcfg_drvdata *drvdata = dev_get_drvdata(dev);
 
 	dbg_lock_status = xdevcfg_readreg(drvdata->base_address +
-				XDCFG_LOCK_OFFSET) &
-				XDCFG_LOCK_DBG_MASK;
+			XDCFG_LOCK_OFFSET) & XDCFG_LOCK_DBG_MASK;
 
 	status = sprintf(buf, "%d\n", dbg_lock_status);
 
@@ -1288,19 +1188,16 @@ static DEVICE_ATTR(dbg_lock, 0644, xdevcfg_show_dbg_lock_status,
  * @buf:	Pointer to the buffer location for the configuration
  *		data.
  * returns:	size of the buffer.
- *
- **/
+ */
 static ssize_t xdevcfg_show_prog_done_status(struct device *dev,
 		struct device_attribute *attr, char *buf)
 {
 	u32 prog_done_status;
 	ssize_t status;
-	struct xdevcfg_drvdata *drvdata =
-		(struct xdevcfg_drvdata *)dev_get_drvdata(dev);
+	struct xdevcfg_drvdata *drvdata = dev_get_drvdata(dev);
 
 	prog_done_status = xdevcfg_readreg(drvdata->base_address +
-				XDCFG_INT_STS_OFFSET) &
-				XDCFG_IXR_PCFG_DONE_MASK;
+			XDCFG_INT_STS_OFFSET) & XDCFG_IXR_PCFG_DONE_MASK;
 
 	status = sprintf(buf, "%d\n", (prog_done_status >> 2));
 
@@ -1322,16 +1219,13 @@ static DEVICE_ATTR(prog_done, 0644, xdevcfg_show_prog_done_status,
  *		data.
  * @size:	The number of bytes used from the buffer
  * returns:	-EINVAL if invalid parameter is sent or size
- *
- **/
+ */
 static ssize_t xdevcfg_set_is_partial_bitstream(struct device *dev,
-				     struct device_attribute *attr,
-				     const char *buf, size_t size)
+		struct device_attribute *attr, const char *buf, size_t size)
 {
 	unsigned long mask_bit;
 	ssize_t status;
-	struct xdevcfg_drvdata *drvdata =
-		(struct xdevcfg_drvdata *)dev_get_drvdata(dev);
+	struct xdevcfg_drvdata *drvdata = dev_get_drvdata(dev);
 
 	status = strict_strtoul(buf, 10, &mask_bit);
 
@@ -1357,14 +1251,12 @@ static ssize_t xdevcfg_set_is_partial_bitstream(struct device *dev,
  * @buf:	Pointer to the buffer location for the configuration
  *		data.
  * returns:	size of the buffer.
- *
- **/
+ */
 static ssize_t xdevcfg_show_is_partial_bitstream_status(struct device *dev,
 		struct device_attribute *attr, char *buf)
 {
 	ssize_t status;
-	struct xdevcfg_drvdata *drvdata =
-		(struct xdevcfg_drvdata *)dev_get_drvdata(dev);
+	struct xdevcfg_drvdata *drvdata = dev_get_drvdata(dev);
 
 	status = sprintf(buf, "%d\n", drvdata->is_partial_bitstream);
 
@@ -1400,10 +1292,10 @@ static const struct attribute_group xdevcfg_attr_group = {
  * xdevcfg_drv_probe -  Probe call for the device.
  *
  * @pdev:	handle to the platform device structure.
+ * Returns 0 on success, negative error otherwise.
  *
  * It does all the memory allocation and registration for the device.
- * Returns 0 on success, negative error otherwise.
- **/
+ */
 static int __devinit xdevcfg_drv_probe(struct platform_device *pdev)
 {
 	struct resource *regs_res, *irq_res;
@@ -1417,7 +1309,6 @@ static int __devinit xdevcfg_drv_probe(struct platform_device *pdev)
 
 	regs_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	if (!regs_res) {
-
 		dev_err(&pdev->dev, "Invalid address\n");
 		return -ENODEV;
 	}
@@ -1430,27 +1321,25 @@ static int __devinit xdevcfg_drv_probe(struct platform_device *pdev)
 
 	devt = MKDEV(XDEVCFG_MAJOR, XDEVCFG_MINOR);
 
-	retval = register_chrdev_region(devt,
-					XDEVCFG_DEVICES,
-					DRIVER_NAME);
+	retval = register_chrdev_region(devt, XDEVCFG_DEVICES, DRIVER_NAME);
 	if (retval < 0)
 		return retval;
 
-	drvdata = kzalloc(sizeof(struct xdevcfg_drvdata), GFP_KERNEL);
+	drvdata = kzalloc(sizeof(*drvdata), GFP_KERNEL);
 	if (!drvdata) {
-		dev_err(&pdev->dev, "Couldn't allocate device private \
-					record\n");
+		dev_err(&pdev->dev,
+				"Couldn't allocate device private record\n");
 		retval = -ENOMEM;
 		goto failed0;
 	}
 
-	dev_set_drvdata(&pdev->dev, (void *)drvdata);
+	dev_set_drvdata(&pdev->dev, drvdata);
 
 	if (!request_mem_region(regs_res->start,
-					regs_res->end - regs_res->start + 1,
-					DRIVER_NAME)) {
+				regs_res->end - regs_res->start + 1,
+				DRIVER_NAME)) {
 		dev_err(&pdev->dev, "Couldn't lock memory region at %Lx\n",
-			(unsigned long long) regs_res->start);
+			(unsigned long long)regs_res->start);
 		retval = -EBUSY;
 		goto failed1;
 	}
@@ -1484,9 +1373,10 @@ static int __devinit xdevcfg_drv_probe(struct platform_device *pdev)
 		 drvdata->base_address,
 		 (unsigned long long) (regs_res->end - regs_res->start + 1));
 
-	/* Figure out from the device tree if this is running on the EP107 emulation
-	 * platform as it doesn't match the silicon exactly and the driver needs
-	 * to work accordingly.
+	/*
+	 * Figure out from the device tree if this is running on the EP107
+	 * emulation platform as it doesn't match the silicon exactly and the
+	 * driver needs to work accordingly.
 	 */
 	np = of_get_next_parent(pdev->dev.of_node);
 	np = of_get_next_parent(np);
@@ -1499,9 +1389,7 @@ static int __devinit xdevcfg_drv_probe(struct platform_device *pdev)
 			drvdata->ep107 = 0;
 	}
 
-	/*
-	 * Unlock the device
-	 */
+	/* Unlock the device */
 	xdevcfg_writereg(drvdata->base_address + XDCFG_UNLOCK_OFFSET,
 				0x757BDF0D);
 
@@ -1541,20 +1429,15 @@ static int __devinit xdevcfg_drv_probe(struct platform_device *pdev)
 
 	return 0;		/* Success */
 
- failed3:
+failed3:
 	iounmap(drvdata->base_address);
-
- failed2:
+failed2:
 	release_mem_region(regs_res->start,
 				regs_res->end - regs_res->start + 1);
-
- failed1:
+failed1:
 	kfree(drvdata);
-
- failed0:
-	/*
-	 * Unregister char driver
-	 */
+failed0:
+	/* Unregister char driver */
 	unregister_chrdev_region(devt, XDEVCFG_DEVICES);
 
 	return retval;
@@ -1564,16 +1447,16 @@ static int __devinit xdevcfg_drv_probe(struct platform_device *pdev)
  * xdevcfg_drv_remove -  Remove call for the device.
  *
  * @pdev:	handle to the platform device structure.
+ * Returns 0 or error status.
  *
  * Unregister the device after releasing the resources.
- * Returns 0 or error status.
- **/
+ */
 static int __devexit xdevcfg_drv_remove(struct platform_device *pdev)
 {
 	struct xdevcfg_drvdata *drvdata;
 	struct resource *res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 
-	drvdata = (struct xdevcfg_drvdata *)dev_get_drvdata(&pdev->dev);
+	drvdata = dev_get_drvdata(&pdev->dev);
 
 	if (!drvdata)
 		return -ENODEV;
-- 
1.7.5.4

