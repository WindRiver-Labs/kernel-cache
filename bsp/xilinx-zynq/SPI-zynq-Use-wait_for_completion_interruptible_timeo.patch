From 3f517388dc2f3d94518939e2f401a2a358e9a076 Mon Sep 17 00:00:00 2001
From: Harini Katakam <harini.katakam@xilinx.com>
Date: Fri, 7 Mar 2014 18:58:16 +0530
Subject: [PATCH 068/509] SPI: zynq: Use
 wait_for_completion_interruptible_timeout and reset
 when < 1

https://github.com/analogdevicesinc/linux.git xcomm_zynq
commit f676f64e06e2fd9f73d2b37a31fe4a394c139963

Used wait_for_completion_interruptible_timeout and reset controller
when return is zero (timeout) or less than zero (interrupt).
Implemented zynq_spi_reset_controller to be used for reset.

Signed-off-by: Harini Katakam <harinik@xilinx.com>
Signed-off-by: Michal Simek <michal.simek@xilinx.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 drivers/spi/spi-zynq.c |   28 +++++++++++++++++++++++++---
 1 files changed, 25 insertions(+), 3 deletions(-)

diff --git a/drivers/spi/spi-zynq.c b/drivers/spi/spi-zynq.c
index 16a7fd7..e0c72e1 100644
--- a/drivers/spi/spi-zynq.c
+++ b/drivers/spi/spi-zynq.c
@@ -381,6 +381,23 @@ static irqreturn_t zynq_spi_irq(int irq, void *dev_id)
 }
 
 /**
+ * zynq_spi_reset_controller - Resets SPI controller
+ * @spi:	Pointer to the spi_device structure
+ *
+ * This function disables the interrupts, de-asserts the chip select and
+ * disables the SPI controller.
+ */
+static void zynq_spi_reset_controller(struct spi_device *spi)
+{
+	struct zynq_spi *xspi = spi_master_get_devdata(spi->master);
+
+	zynq_spi_write(xspi->regs + ZYNQ_SPI_IDR_OFFSET,
+			ZYNQ_SPI_IXR_ALL_MASK);
+	zynq_spi_chipselect(spi, 0);
+	zynq_spi_write(xspi->regs + ZYNQ_SPI_ER_OFFSET, 0);
+}
+
+/**
  * zynq_spi_start_transfer - Initiates the SPI transfer
  * @spi:	Pointer to the spi_device structure
  * @transfer:	Pointer to the spi_transfer structure which provide information
@@ -417,9 +434,14 @@ static int zynq_spi_start_transfer(struct spi_device *spi,
 
 	spin_unlock_irqrestore(&xspi->ctrl_reg_lock, flags);
 
-	ret = wait_for_completion_timeout(&xspi->done, 5 * HZ);
-	if (ret == 0)
-		return -EIO;
+	ret = wait_for_completion_interruptible_timeout(&xspi->done, 5 * HZ);
+	if (ret < 1) {
+		zynq_spi_reset_controller(spi);
+		if (!ret)
+			return -ETIMEDOUT;
+
+		return ret;
+	}
 
 	return (transfer->len) - (xspi->remaining_bytes);
 }
-- 
1.7.5.4

