From 34d428025fdfa3a6d3a68ececa450dc5693ca6dd Mon Sep 17 00:00:00 2001
From: Soren Brinkmann <soren.brinkmann@xilinx.com>
Date: Wed, 27 Jun 2012 06:37:00 -0700
Subject: [PATCH 38/50] Xilinx: ARM: Adding cpufreq support.

git://git.xilinx.com/linux-xlnx.git master
commit 2cb1e58829c118fee88b416534c5744a97a44a5f

Adding cpufreq and OPP to mach-zynq in preparation for DVFS.
The current driver provides very simple frequency scaling functionality.
The whole code is based on OMAP's cpufreq driver.

Signed-off-by: Soren Brinkmann <soren.brinkmann@xilinx.com>
Signed-off-by: Liming Wang <liming.wang@windriver.com>
---
 arch/arm/Kconfig                       |    2 +
 arch/arm/mach-zynq/common.c            |   70 +++++++++
 arch/arm/mach-zynq/include/mach/pdev.h |   19 +++
 arch/arm/mach-zynq/platform_devices.c  |   48 ++++++
 drivers/cpufreq/Kconfig.arm            |    8 +
 drivers/cpufreq/Makefile               |    1 +
 drivers/cpufreq/zynq-cpufreq.c         |  257 ++++++++++++++++++++++++++++++++
 7 files changed, 405 insertions(+), 0 deletions(-)
 create mode 100644 arch/arm/mach-zynq/include/mach/pdev.h
 create mode 100644 drivers/cpufreq/zynq-cpufreq.c

diff --git a/arch/arm/Kconfig b/arch/arm/Kconfig
index 229e83a..c2b9387 100644
--- a/arch/arm/Kconfig
+++ b/arch/arm/Kconfig
@@ -1035,6 +1035,8 @@ config ARCH_ZYNQ
 	select MIGHT_HAVE_CACHE_L2X0
 	select USE_OF
 	select USB_ARCH_HAS_EHCI if USB_SUPPORT
+	select ARCH_HAS_CPUFREQ
+	select ARCH_HAS_OPP
 	help
 	  Support for Xilinx Zynq ARM Cortex A9 Platform
 endchoice
diff --git a/arch/arm/mach-zynq/common.c b/arch/arm/mach-zynq/common.c
index d41ce07..8df986a 100644
--- a/arch/arm/mach-zynq/common.c
+++ b/arch/arm/mach-zynq/common.c
@@ -18,6 +18,8 @@
 #include <linux/kernel.h>
 #include <linux/cpumask.h>
 #include <linux/platform_device.h>
+#include <linux/clk.h>
+#include <linux/opp.h>
 #include <linux/of_irq.h>
 #include <linux/of_platform.h>
 #include <linux/of.h>
@@ -32,6 +34,7 @@
 
 #include <mach/zynq_soc.h>
 #include <mach/clk.h>
+#include <mach/pdev.h>
 #include <mach/slcr.h>
 #include "common.h"
 
@@ -40,6 +43,72 @@ static struct of_device_id zynq_of_bus_ids[] __initdata = {
 	{}
 };
 
+#ifdef CONFIG_CPU_FREQ
+/**
+ * xilinx_opp_init() - Register OPPs
+ *
+ * Registering frequency/voltage operating points for voltage and frequency
+ * scaling. Currently we only support frequency scaling.
+ */
+static void __init xilinx_opp_init(void)
+{
+	struct platform_device *pdev = xilinx_get_pdev_by_name("zynq-dvfs");
+	struct device *dev;
+	int ret = 0;
+	long freq;
+	struct clk *cpuclk = clk_get_sys("CPU_6OR4X_CLK", NULL);
+
+	if (IS_ERR(pdev)) {
+		pr_warn("Xilinx OOP init: No device. DVFS not available.");
+		return;
+	}
+	dev = &pdev->dev;
+
+	if (IS_ERR(cpuclk)) {
+		pr_warn("Xilinx OOP init: CPU clock not found. DVFS not available.");
+		return;
+	}
+
+	/* frequency/voltage operating points. For now use f only */
+	/* We need some conditionals to enable the max frequencies for the right
+	 * parts only. */
+	/* -3E(?) max f = 1GHz */
+	freq = clk_round_rate(cpuclk, 1000000000);
+	if (abs(1000000000 - freq) < 50000000)
+		ret |= opp_add(dev, freq, 0);
+	/* -3 parts max f = 800 MHz */
+	freq = clk_round_rate(cpuclk, 800000000);
+	if (abs(800000000 - freq) < 10000000)
+		ret |= opp_add(dev, freq, 0);
+	freq = clk_round_rate(cpuclk, 666666667);
+	if (abs(666666667 - freq) < 10000000)
+		ret |= opp_add(dev, freq, 0);
+	freq = clk_round_rate(cpuclk, 555555556);
+	if (abs(555555556 - freq) < 10000000)
+		ret |= opp_add(dev, freq, 0);
+	freq = clk_round_rate(cpuclk, 444444444);
+	if (abs(444444444 - freq) < 10000000)
+		ret |= opp_add(dev, freq, 0);
+	freq = clk_round_rate(cpuclk, 333333333);
+	if (abs(333333333 - freq) < 10000000)
+		ret |= opp_add(dev, freq, 0);
+	freq = clk_round_rate(cpuclk, 222222222);
+	if (abs(222222222 - freq) < 10000000)
+		ret |= opp_add(dev, freq, 0);
+	freq = clk_round_rate(cpuclk, 111111111);
+	if (abs(111111111 - freq) < 10000000)
+		ret |= opp_add(dev, freq, 0);
+	freq = clk_round_rate(cpuclk, 50000000);
+	if (abs(50000000 - freq) < 5000000)
+		ret |= opp_add(dev, freq, 0);
+
+	if (ret)
+		pr_warn("Error adding OPPs.");
+}
+#else
+static void __init xilinx_opp_init(void) {}
+#endif
+
 /**
  * xilinx_init_machine() - System specific initialization, intended to be
  *			   called from board specific initialization.
@@ -62,6 +131,7 @@ void __init xilinx_init_machine(void)
 #endif
 
 	platform_device_init();
+	xilinx_opp_init();
 }
 
 static const struct of_device_id xilinx_dt_irq_match[] __initconst = {
diff --git a/arch/arm/mach-zynq/include/mach/pdev.h b/arch/arm/mach-zynq/include/mach/pdev.h
new file mode 100644
index 0000000..1761a1a
--- /dev/null
+++ b/arch/arm/mach-zynq/include/mach/pdev.h
@@ -0,0 +1,19 @@
+/*
+ *  Copyright (C) 2012 Xilinx
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __MAC_PDEV_H__
+#define __MAC_PDEV_H__
+
+struct platform_device *xilinx_get_pdev_by_name(const char *nm);
+
+#endif
diff --git a/arch/arm/mach-zynq/platform_devices.c b/arch/arm/mach-zynq/platform_devices.c
index 372413d..1288da4 100644
--- a/arch/arm/mach-zynq/platform_devices.c
+++ b/arch/arm/mach-zynq/platform_devices.c
@@ -16,6 +16,7 @@
 #include <linux/platform_device.h>
 #include <linux/device.h>
 #include <linux/module.h>
+#include <linux/slab.h>
 #include <asm/pmu.h>
 #include <asm/io.h>
 #include <mach/zynq_soc.h>
@@ -108,6 +109,10 @@ struct platform_device xilinx_scutimer_device = {
 	.dev.platform_data = NULL,
 };
 
+static struct platform_device xilinx_dvfs_device = {
+	.name = "zynq-dvfs"
+};
+
 /* add all platform devices to the following table so they
  * will be registered
  */
@@ -119,8 +124,49 @@ struct platform_device *xilinx_pdevices[] __initdata = {
 	&xilinx_dma_test,
 #endif
 	&xilinx_pmu_device,
+	&xilinx_dvfs_device,
+};
+
+/* Maintain a list of platform devices */
+static LIST_HEAD(xilinx_pdevlist);
+struct xilinx_pdevlist_entry {
+	struct list_head lh;
+	struct platform_device *pdev;
 };
 
+/**
+ * xilinx_add_pdevlist() - Add platform device to list
+ * @pdev: The platform device to add to the list
+ */
+static void xilinx_add_pdevlist(struct platform_device *pdev)
+{
+	struct xilinx_pdevlist_entry *entry = kmalloc(sizeof(*entry),
+			GFP_KERNEL);
+	if (!entry) {
+		pr_warn("Adding PDEV to list failed.");
+		return;
+	}
+	entry->pdev = pdev;
+	list_add_tail(&entry->lh, &xilinx_pdevlist);
+}
+
+/**
+ * xilinx_get_pdev_by_name - Find a platform device by name
+ * @nm: Name of the Platform device searched.
+ * Returns a pointer to the found struct platform_device or error pointer if no
+ * platform device is found.
+ */
+struct platform_device *xilinx_get_pdev_by_name(const char *nm)
+{
+	struct xilinx_pdevlist_entry *tmp;
+
+	list_for_each_entry(tmp, &xilinx_pdevlist, lh) {
+		if (!strcmp(tmp->pdev->name, nm))
+			return tmp->pdev;
+	}
+	return ERR_PTR(-ENODEV);
+}
+EXPORT_SYMBOL(xilinx_get_pdev_by_name);
 
 /**
  * platform_device_init - Initialize all the platform devices.
@@ -147,6 +193,8 @@ void __init platform_device_init(void)
 		if (ret)
 			pr_info("Unable to register platform device '%s': %d\n",
 				(*devptr)->name, ret);
+		else
+			xilinx_add_pdevlist(*devptr);
 	}
 
 }
diff --git a/drivers/cpufreq/Kconfig.arm b/drivers/cpufreq/Kconfig.arm
index d131953..c10f382 100644
--- a/drivers/cpufreq/Kconfig.arm
+++ b/drivers/cpufreq/Kconfig.arm
@@ -85,3 +85,11 @@ config ARM_VEXPRESS_BL_CPUFREQ
 	  platform.
 
 	  If in doubt, say N.
+
+config ARM_ZYNQ_CPUFREQ
+	bool "Xilinx Zynq"
+	depends on ARCH_ZYNQ
+	default n
+	select CPU_FREQ_TABLE
+	help
+	  This adds the CPUFreq driver for Xilinx Zynq SoCs.
diff --git a/drivers/cpufreq/Makefile b/drivers/cpufreq/Makefile
index 7c620a8..cd85be2 100644
--- a/drivers/cpufreq/Makefile
+++ b/drivers/cpufreq/Makefile
@@ -49,6 +49,7 @@ obj-$(CONFIG_ARM_EXYNOS4X12_CPUFREQ)	+= exynos4x12-cpufreq.o
 obj-$(CONFIG_ARM_EXYNOS5250_CPUFREQ)	+= exynos5250-cpufreq.o
 obj-$(CONFIG_ARM_OMAP2PLUS_CPUFREQ)     += omap-cpufreq.o
 obj-$(CONFIG_ARM_VEXPRESS_BL_CPUFREQ)	+= vexpress_bL_cpufreq.o
+obj-$(CONFIG_ARM_ZYNQ_CPUFREQ)     	+= zynq-cpufreq.o
 
 ##################################################################################
 # PowerPC platform drivers
diff --git a/drivers/cpufreq/zynq-cpufreq.c b/drivers/cpufreq/zynq-cpufreq.c
new file mode 100644
index 0000000..28a7ece
--- /dev/null
+++ b/drivers/cpufreq/zynq-cpufreq.c
@@ -0,0 +1,257 @@
+/*
+ * CPU frequency scaling for Zynq
+ *
+ * Based on drivers/cpufreq/omap-cpufreq.c,
+ * Copyright (C) 2005 Nokia Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#include <linux/kernel.h>
+#include <linux/cpufreq.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/err.h>
+#include <linux/clk.h>
+#include <linux/cpu.h>
+#include <linux/cpumask.h>
+#include <linux/module.h>
+#include <linux/opp.h>
+#include <linux/platform_device.h>
+#include <asm/smp_plat.h>
+#include <asm/cpu.h>
+#include <mach/pdev.h>
+
+#ifdef CONFIG_SMP
+struct lpj_info {
+	unsigned long	ref;
+	unsigned int	freq;
+};
+
+static DEFINE_PER_CPU(struct lpj_info, lpj_ref);
+static struct lpj_info global_lpj_ref;
+#endif
+
+static atomic_t freq_table_users = ATOMIC_INIT(0);
+static struct cpufreq_frequency_table *freq_table;
+static struct device *mpu_dev;
+static struct clk *cpuclk;
+
+static int zynq_verify_speed(struct cpufreq_policy *policy)
+{
+	if (!freq_table)
+		return -EINVAL;
+	return cpufreq_frequency_table_verify(policy, freq_table);
+}
+
+static unsigned int zynq_getspeed(unsigned int cpu)
+{
+	unsigned long rate;
+
+	if (cpu >= num_present_cpus())
+		return 0;
+
+	rate = clk_get_rate(cpuclk) / 1000;
+	return rate;
+}
+
+static int zynq_target(struct cpufreq_policy *policy,
+		       unsigned int target_freq,
+		       unsigned int relation)
+{
+	unsigned int i;
+	int ret = 0;
+	struct cpufreq_freqs freqs;
+	unsigned long freq, volt = 0, volt_old = 0;
+
+	if (!freq_table) {
+		dev_err(mpu_dev, "%s: cpu%d: no freq table!\n", __func__,
+				policy->cpu);
+		return -EINVAL;
+	}
+
+	ret = cpufreq_frequency_table_target(policy, freq_table, target_freq,
+			relation, &i);
+	if (ret) {
+		dev_dbg(mpu_dev, "%s: cpu%d: no freq match for %d(ret=%d)\n",
+			__func__, policy->cpu, target_freq, ret);
+		return ret;
+	}
+	freqs.new = freq_table[i].frequency;
+	if (!freqs.new) {
+		dev_err(mpu_dev, "%s: cpu%d: no match for freq %d\n", __func__,
+			policy->cpu, target_freq);
+		return -EINVAL;
+	}
+
+	freqs.old = zynq_getspeed(policy->cpu);
+	freqs.cpu = policy->cpu;
+
+	if (freqs.old == freqs.new && policy->cur == freqs.new)
+		return ret;
+
+	/* notifiers */
+	for_each_cpu(i, policy->cpus) {
+		freqs.cpu = i;
+		cpufreq_notify_transition(&freqs, CPUFREQ_PRECHANGE);
+	}
+
+	freq = freqs.new * 1000;
+
+	dev_dbg(mpu_dev, "cpufreq-zynq: %u MHz, %ld mV --> %u MHz, %ld mV\n",
+		freqs.old / 1000, volt_old ? volt_old / 1000 : -1,
+		freqs.new / 1000, volt ? volt / 1000 : -1);
+
+	ret = clk_set_rate(cpuclk, freqs.new * 1000);
+
+	freqs.new = zynq_getspeed(policy->cpu);
+#ifdef CONFIG_SMP
+	/*
+	 * Note that loops_per_jiffy is not updated on SMP systems in
+	 * cpufreq driver. So, update the per-CPU loops_per_jiffy value
+	 * on frequency transition. We need to update all dependent CPUs.
+	 */
+	for_each_cpu(i, policy->cpus) {
+		struct lpj_info *lpj = &per_cpu(lpj_ref, i);
+		if (!lpj->freq) {
+			lpj->ref = per_cpu(cpu_data, i).loops_per_jiffy;
+			lpj->freq = freqs.old;
+		}
+
+		per_cpu(cpu_data, i).loops_per_jiffy =
+			cpufreq_scale(lpj->ref, lpj->freq, freqs.new);
+	}
+
+	/* And don't forget to adjust the global one */
+	if (!global_lpj_ref.freq) {
+		global_lpj_ref.ref = loops_per_jiffy;
+		global_lpj_ref.freq = freqs.old;
+	}
+	loops_per_jiffy = cpufreq_scale(global_lpj_ref.ref, global_lpj_ref.freq,
+					freqs.new);
+#endif
+
+	/* notifiers */
+	for_each_cpu(i, policy->cpus) {
+		freqs.cpu = i;
+		cpufreq_notify_transition(&freqs, CPUFREQ_POSTCHANGE);
+	}
+
+	return ret;
+}
+
+static inline void freq_table_free(void)
+{
+	if (atomic_dec_and_test(&freq_table_users))
+		opp_free_cpufreq_table(mpu_dev, &freq_table);
+}
+
+static int __cpuinit zynq_cpu_init(struct cpufreq_policy *policy)
+{
+	int result = 0;
+
+	cpuclk = clk_get_sys("CPU_6OR4X_CLK", NULL);
+	if (IS_ERR(cpuclk)) {
+		pr_warn("Xilinx: cpufreq: Clock not found.");
+		return PTR_ERR(cpuclk);
+	}
+
+	if (policy->cpu >= num_possible_cpus()) {
+		result = -EINVAL;
+		goto fail_ck;
+	}
+
+	policy->cur = policy->min = policy->max = zynq_getspeed(policy->cpu);
+
+	if (atomic_inc_return(&freq_table_users) == 1)
+		result = opp_init_cpufreq_table(mpu_dev, &freq_table);
+
+	if (result) {
+		dev_err(mpu_dev, "%s: cpu%d: failed creating freq table[%d]\n",
+				__func__, policy->cpu, result);
+		goto fail_ck;
+	}
+
+	result = cpufreq_frequency_table_cpuinfo(policy, freq_table);
+	if (result)
+		goto fail_table;
+
+	cpufreq_frequency_table_get_attr(freq_table, policy->cpu);
+
+	policy->min = policy->cpuinfo.min_freq;
+	policy->max = policy->cpuinfo.max_freq;
+	policy->cur = zynq_getspeed(policy->cpu);
+
+	/*
+	 * On Zynq configuartion, both processors share the voltage
+	 * and clock. So both CPUs needs to be scaled together and hence
+	 * needs software co-ordination. Use cpufreq affected_cpus
+	 * interface to handle this scenario. Additional is_smp() check
+	 * is to keep SMP_ON_UP build working.
+	 */
+	if (is_smp()) {
+		policy->shared_type = CPUFREQ_SHARED_TYPE_ANY;
+		cpumask_setall(policy->cpus);
+	}
+
+	/* FIXME: what's the actual transition time? */
+	policy->cpuinfo.transition_latency = 300 * 1000;
+
+	return 0;
+
+fail_table:
+	freq_table_free();
+fail_ck:
+	clk_put(cpuclk);
+	return result;
+}
+
+static int zynq_cpu_exit(struct cpufreq_policy *policy)
+{
+	clk_put(cpuclk);
+	return 0;
+}
+
+static struct freq_attr *zynq_cpufreq_attr[] = {
+	&cpufreq_freq_attr_scaling_available_freqs,
+	NULL,
+};
+
+static struct cpufreq_driver zynq_cpufreq_driver = {
+	.flags		= CPUFREQ_STICKY,
+	.verify		= zynq_verify_speed,
+	.target		= zynq_target,
+	.get		= zynq_getspeed,
+	.init		= zynq_cpu_init,
+	.exit		= zynq_cpu_exit,
+	.name		= "Zynq cpufreq",
+	.attr		= zynq_cpufreq_attr,
+};
+
+static int __init zynq_cpufreq_init(void)
+{
+	struct platform_device *pdev = xilinx_get_pdev_by_name("zynq-dvfs");
+
+	if (IS_ERR(pdev)) {
+		pr_warn("Xilinx: cpufreq: Device not found.");
+		return -EINVAL;
+	}
+	mpu_dev = &pdev->dev;
+	return cpufreq_register_driver(&zynq_cpufreq_driver);
+}
+
+static void __exit zynq_cpufreq_exit(void)
+{
+	cpufreq_unregister_driver(&zynq_cpufreq_driver);
+}
+
+MODULE_DESCRIPTION("cpufreq driver for Zynq");
+MODULE_LICENSE("GPL");
+module_init(zynq_cpufreq_init);
+module_exit(zynq_cpufreq_exit);
-- 
1.7.0

