From 42f4266bf33b93adb55d6ce2dcb0641ec2ba21b9 Mon Sep 17 00:00:00 2001
From: Zhong Hongbo <hongbo.zhong@windriver.com>
Date: Thu, 12 Jul 2012 15:28:05 +0800
Subject: [PATCH 16/36] arm/zynq: Add GPIO support for zc702 board

SDK: yocto-1.2(http://git.yoctoproject.org/cgit.cgi/meta-zynq/)

Signed-off-by: Vlad Lungu <vlad.lungu@windriver.com>
Integrated-by: Hongbo Zhong <hongbo.zhong@windriver.com>
---
 arch/arm/Kconfig                       |    1 +
 arch/arm/boot/dts/zc702.dtsi           |    6 +
 arch/arm/mach-zynq/include/mach/gpio.h |   66 ++++
 arch/arm/mach-zynq/include/mach/irqs.h |    3 +-
 drivers/gpio/Kconfig                   |    6 +
 drivers/gpio/Makefile                  |    1 +
 drivers/gpio/gpio-xilinxps.c           |  625 ++++++++++++++++++++++++++++++++
 7 files changed, 707 insertions(+), 1 deletion(-)
 create mode 100644 arch/arm/mach-zynq/include/mach/gpio.h
 create mode 100644 drivers/gpio/gpio-xilinxps.c

diff --git a/arch/arm/Kconfig b/arch/arm/Kconfig
index 9efb78f..aaabb38 100644
--- a/arch/arm/Kconfig
+++ b/arch/arm/Kconfig
@@ -1015,6 +1015,7 @@ config ARCH_ZYNQ
 	select ICST
 	select ISA_DMA_API
 	select GENERIC_TIME
+	select ARCH_REQUIRE_GPIOLIB
 	select CACHE_L2X0
 	select MIGHT_HAVE_CACHE_L2X0
 	select USE_OF
diff --git a/arch/arm/boot/dts/zc702.dtsi b/arch/arm/boot/dts/zc702.dtsi
index fe2e599..86b2e5c 100644
--- a/arch/arm/boot/dts/zc702.dtsi
+++ b/arch/arm/boot/dts/zc702.dtsi
@@ -52,6 +52,12 @@
 			clock-frequency-timer2 = <111111111>;
 		};
 
+		gpio@e000a000 {
+			compatible = "xlnx,ps7-gpio-1.00.a";
+			reg = <0xe000a000 0x1000>;
+			interrupts = <0x0 0x14 0x0>;
+		};
+
 		i2c@e0004000 {
 			compatible = "xlnx,ps7-i2c-1.00.a";
 			reg = <0xe0004000 0x1000>;
diff --git a/arch/arm/mach-zynq/include/mach/gpio.h b/arch/arm/mach-zynq/include/mach/gpio.h
new file mode 100644
index 0000000..4d54f4c
--- /dev/null
+++ b/arch/arm/mach-zynq/include/mach/gpio.h
@@ -0,0 +1,66 @@
+/*
+ * Xilinx PSS GPIO Header File
+ * arch/arm/mach-xilinx/gpio.h
+ *
+ * 2009 (c) Xilinx, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation; either version 2 of the License, or (at your option) any later
+ * version.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc., 675 Mass
+ * Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef __ASM_ARCH_GPIO_H
+#define __ASM_ARCH_GPIO_H
+
+
+#define ARCH_NR_GPIOS		512
+#define XGPIOPS_IRQBASE		128
+
+struct xgpio_platform_data {
+	unsigned int	state;
+	unsigned int	dir;
+	unsigned int	width;
+};
+
+extern int gpio_direction_input(unsigned gpio);
+extern int gpio_direction_output(unsigned gpio, int value);
+extern int __gpio_get_value(unsigned gpio);
+extern void __gpio_set_value(unsigned gpio, int value);
+extern int __gpio_cansleep(unsigned gpio);
+
+static inline int gpio_get_value(unsigned gpio)
+{
+	return __gpio_get_value(gpio);
+}
+
+static inline void gpio_set_value(unsigned gpio, int value)
+{
+	__gpio_set_value(gpio, value);
+}
+
+static inline int gpio_cansleep(unsigned int gpio)
+{
+	return __gpio_cansleep(gpio);
+}
+
+#include <asm-generic/gpio.h>
+
+static inline unsigned int gpio_to_irq(unsigned int pin)
+{
+	return pin + XGPIOPS_IRQBASE;
+}
+
+static inline unsigned int irq_to_gpio(unsigned int irq)
+{
+	return irq - XGPIOPS_IRQBASE;
+}
+
+void xgpiodf_set_bypass_mode(struct gpio_chip *chip, unsigned int pin);
+void xgpiodf_set_normal_mode(struct gpio_chip *chip, unsigned int pin);
+
+#endif /* __ASM_ARCH_GPIO_H */
diff --git a/arch/arm/mach-zynq/include/mach/irqs.h b/arch/arm/mach-zynq/include/mach/irqs.h
index 03f68ca..870518d 100644
--- a/arch/arm/mach-zynq/include/mach/irqs.h
+++ b/arch/arm/mach-zynq/include/mach/irqs.h
@@ -15,8 +15,9 @@
 #ifndef __MACH_IRQS_H
 #define __MACH_IRQS_H
 
-#define ARCH_NR_GPIOS	118
 #define NR_IRQS		128
+#define ARCH_NR_GPIOS	512
+#define XGPIOPS_IRQBASE	128
 
 #define IRQ_LOCALTIMER	29
 
diff --git a/drivers/gpio/Kconfig b/drivers/gpio/Kconfig
index e2392f9..0da9afa 100644
--- a/drivers/gpio/Kconfig
+++ b/drivers/gpio/Kconfig
@@ -155,6 +155,12 @@ config GPIO_XILINX
 	help
 	  Say yes here to support the Xilinx FPGA GPIO device
 
+config GPIO_XILINX_PS
+	tristate "Xilinx GPIO PS"
+	depends on ARCH_ZYNQ
+	help
+	  Say yes here to support Xilinx GPIO PS controller
+
 config GPIO_VR41XX
 	tristate "NEC VR4100 series General-purpose I/O Uint support"
 	depends on CPU_VR41XX
diff --git a/drivers/gpio/Makefile b/drivers/gpio/Makefile
index 6845e15..c1a9de8 100644
--- a/drivers/gpio/Makefile
+++ b/drivers/gpio/Makefile
@@ -65,3 +65,4 @@ obj-$(CONFIG_GPIO_WM831X)	+= gpio-wm831x.o
 obj-$(CONFIG_GPIO_WM8350)	+= gpio-wm8350.o
 obj-$(CONFIG_GPIO_WM8994)	+= gpio-wm8994.o
 obj-$(CONFIG_GPIO_XILINX)	+= gpio-xilinx.o
+obj-$(CONFIG_GPIO_XILINX_PS)    += gpio-xilinxps.o
diff --git a/drivers/gpio/gpio-xilinxps.c b/drivers/gpio/gpio-xilinxps.c
new file mode 100644
index 0000000..a4ebadb
--- /dev/null
+++ b/drivers/gpio/gpio-xilinxps.c
@@ -0,0 +1,625 @@
+/*
+ * Xilinx PS GPIO device driver
+ *
+ * 2009-2011 (c) Xilinx, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation; either version 2 of the License, or (at your option) any later
+ * version.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc., 675 Mass
+ * Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/export.h>
+#include <linux/module.h>
+#include <linux/io.h>
+#include <linux/irq.h>
+#include <linux/gpio.h>
+#include <linux/init.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+
+#define DRIVER_NAME "xgpiops"
+
+/* Register offsets for the GPIO device */
+
+/* LSW Mask & Data-WO */
+#define XGPIOPS_DATA_LSW_OFFSET(BANK)	(0x000 + (8 * BANK))
+/* MSW Mask & Data-WO */
+#define XGPIOPS_DATA_MSW_OFFSET(BANK)	(0x004 + (8 * BANK))
+/* Data Register-RW */
+#define XGPIOPS_DATA_OFFSET(BANK)	(0x040 + (4 * BANK))
+/* Bypass mode reg -RW */
+#define XGPIOPS_BYPM_OFFSET(BANK)	(0x200 + (0x40 * BANK))
+/* Direction mode reg-RW */
+#define XGPIOPS_DIRM_OFFSET(BANK)	(0x204 + (0x40 * BANK))
+/* Output enable reg-RW */
+#define XGPIOPS_OUTEN_OFFSET(BANK)	(0x208 + (0x40 * BANK))
+/* Interrupt mask reg-RO */
+#define XGPIOPS_INTMASK_OFFSET(BANK)	(0x20C + (0x40 * BANK))
+/* Interrupt enable reg-WO */
+#define XGPIOPS_INTEN_OFFSET(BANK)	(0x210 + (0x40 * BANK))
+/* Interrupt disable reg-WO */
+#define XGPIOPS_INTDIS_OFFSET(BANK)	(0x214 + (0x40 * BANK))
+/* Interrupt status reg-RO */
+#define XGPIOPS_INTSTS_OFFSET(BANK)	(0x218 + (0x40 * BANK))
+/* Interrupt type reg-RW */
+#define XGPIOPS_INTTYPE_OFFSET(BANK)	(0x21C + (0x40 * BANK))
+/* Interrupt polarity reg-RW */
+#define XGPIOPS_INTPOL_OFFSET(BANK)	(0x220 + (0x40 * BANK))
+/* Interrupt on any, reg-RW */
+#define XGPIOPS_INTANY_OFFSET(BANK)	(0x224 + (0x40 * BANK))
+
+/* Read/Write access to the GPIO PS registers */
+#define xgpiops_readreg(offset)		__raw_readl(offset)
+#define xgpiops_writereg(val, offset)	__raw_writel(val, offset)
+
+static unsigned int xgpiops_pin_table[] = {
+	31, /* 0 - 31 */
+	53, /* 32 - 53 */
+	85, /* 54 - 85 */
+	117 /* 86 - 117 */
+};
+
+/**
+ * struct xgpiops - gpio device private data structure
+ * @chip:	instance of the gpio_chip
+ * @base_addr:	base address of the GPIO device
+ * @gpio_lock:	lock used for synchronization
+ */
+struct xgpiops {
+	struct gpio_chip chip;
+	void __iomem *base_addr;
+	spinlock_t gpio_lock;
+};
+
+/**
+ * xgpiops_get_bank_pin - Get the bank number and pin number within that bank
+ * for a given pin in the GPIO device
+ * @pin_num:	gpio pin number within the device
+ * @bank_num:	an output parameter used to return the bank number of the gpio
+ *		pin
+ * @bank_pin_num: an output parameter used to return pin number within a bank
+ *		  for the given gpio pin
+ *
+ * Returns the bank number.
+ */
+static inline void xgpiops_get_bank_pin(unsigned int pin_num,
+					 unsigned int *bank_num,
+					 unsigned int *bank_pin_num)
+{
+	for (*bank_num = 0; *bank_num < 4; (*bank_num)++)
+		if (pin_num <= xgpiops_pin_table[*bank_num])
+			break;
+
+	if (*bank_num == 0)
+		*bank_pin_num = pin_num;
+	else
+		*bank_pin_num = pin_num %
+					(xgpiops_pin_table[*bank_num - 1] + 1);
+}
+
+/**
+ * xgpiops_set_bypass_mode - Set the GPIO pin in bypass mode
+ * @chip:	gpio_chip instance to be worked on
+ * @pin:	gpio pin number within the device
+ *
+ * This function sets the specified pin of the GPIO device in bypass mode.
+ */
+void xgpiops_set_bypass_mode(struct gpio_chip *chip, unsigned int pin)
+{
+	unsigned long flags;
+	unsigned int bypm_reg, bank_num, bank_pin_num;
+	struct xgpiops *gpio = container_of(chip, struct xgpiops, chip);
+
+	xgpiops_get_bank_pin(pin, &bank_num, &bank_pin_num);
+
+	spin_lock_irqsave(&gpio->gpio_lock, flags);
+
+	bypm_reg = xgpiops_readreg(gpio->base_addr +
+				    XGPIOPS_BYPM_OFFSET(bank_num));
+	bypm_reg |= 1 << bank_pin_num;
+	xgpiops_writereg(bypm_reg,
+			  gpio->base_addr + XGPIOPS_BYPM_OFFSET(bank_num));
+
+	spin_unlock_irqrestore(&gpio->gpio_lock, flags);
+}
+EXPORT_SYMBOL(xgpiops_set_bypass_mode);
+
+/**
+ * xgpiops_set_normal_mode - Set the GPIO pin in normal mode
+ * @chip:	gpio_chip instance to be worked on
+ * @pin:	gpio pin number within the device
+ *
+ * This function sets the specified pin of the GPIO device in normal (i,e)
+ * software controlled mode.
+ */
+void xgpiops_set_normal_mode(struct gpio_chip *chip, unsigned int pin)
+{
+	unsigned long flags;
+	unsigned int bypm_reg, bank_num, bank_pin_num;
+	struct xgpiops *gpio = container_of(chip, struct xgpiops, chip);
+
+	xgpiops_get_bank_pin(pin, &bank_num, &bank_pin_num);
+
+	spin_lock_irqsave(&gpio->gpio_lock, flags);
+
+	bypm_reg = xgpiops_readreg(gpio->base_addr +
+				    XGPIOPS_BYPM_OFFSET(bank_num));
+	bypm_reg &= ~(1 << bank_pin_num);
+	xgpiops_writereg(bypm_reg,
+			  gpio->base_addr + XGPIOPS_BYPM_OFFSET(bank_num));
+
+	spin_unlock_irqrestore(&gpio->gpio_lock, flags);
+}
+EXPORT_SYMBOL(xgpiops_set_normal_mode);
+
+/**
+ * xgpiops_get_value - Get the state of the specified pin of GPIO device
+ * @chip:	gpio_chip instance to be worked on
+ * @pin:	gpio pin number within the device
+ *
+ * This function reads the state of the specified pin of the GPIO device.
+ * It returns 0 if the pin is low, 1 if pin is high.
+ */
+static int xgpiops_get_value(struct gpio_chip *chip, unsigned int pin)
+{
+	unsigned int bank_num, bank_pin_num;
+	struct xgpiops *gpio = container_of(chip, struct xgpiops, chip);
+
+	xgpiops_get_bank_pin(pin, &bank_num, &bank_pin_num);
+
+	return (xgpiops_readreg(gpio->base_addr +
+				 XGPIOPS_DATA_OFFSET(bank_num)) >>
+		bank_pin_num) & 1;
+}
+
+/**
+ * xgpiops_set_value - Modify the state of the pin with specified value
+ * @chip:	gpio_chip instance to be worked on
+ * @pin:	gpio pin number within the device
+ * @state:	value used to modify the state of the specified pin
+ *
+ * This function calculates the register offset (i.e to lower 16 bits or
+ * upper 16 bits) based on the given pin number and sets the state of a
+ * gpio pin to the specified value. The state is either 0 or non-zero.
+ */
+static void xgpiops_set_value(struct gpio_chip *chip, unsigned int pin,
+			       int state)
+{
+	unsigned long flags;
+	unsigned int reg_offset;
+	unsigned int bank_num, bank_pin_num;
+	struct xgpiops *gpio = container_of(chip, struct xgpiops, chip);
+
+	xgpiops_get_bank_pin(pin, &bank_num, &bank_pin_num);
+
+	if (bank_pin_num >= 16) {
+		bank_pin_num -= 16; /* only 16 data bits in bit maskable reg */
+		reg_offset = XGPIOPS_DATA_MSW_OFFSET(bank_num);
+	} else
+		reg_offset = XGPIOPS_DATA_LSW_OFFSET(bank_num);
+
+	/*
+	 * get the 32 bit value to be written to the mask/data register where
+	 * the upper 16 bits is the mask and lower 16 bits is the data
+	 */
+	if (state)
+		state = 1;
+
+	state = ~(1 << (bank_pin_num + 16)) & ((state << bank_pin_num) |
+					       0xFFFF0000);
+
+	spin_lock_irqsave(&gpio->gpio_lock, flags);
+	xgpiops_writereg(state, gpio->base_addr + reg_offset);
+	spin_unlock_irqrestore(&gpio->gpio_lock, flags);
+}
+
+/**
+ * xgpiops_dir_in - Set the direction of the specified GPIO pin as input
+ * @chip:	gpio_chip instance to be worked on
+ * @pin:	gpio pin number within the device
+ *
+ * This function uses the read-modify-write sequence to set the direction of
+ * the gpio pin as input. Returns 0 always.
+ */
+static int xgpiops_dir_in(struct gpio_chip *chip, unsigned int pin)
+{
+	unsigned int reg, bank_num, bank_pin_num;
+	struct xgpiops *gpio = container_of(chip, struct xgpiops, chip);
+
+	xgpiops_get_bank_pin(pin, &bank_num, &bank_pin_num);
+	/* clear the bit in direction mode reg to set the pin as input */
+	reg = xgpiops_readreg(gpio->base_addr +
+			       XGPIOPS_DIRM_OFFSET(bank_num));
+	reg &= ~(1 << bank_pin_num);
+	xgpiops_writereg(reg,
+			  gpio->base_addr + XGPIOPS_DIRM_OFFSET(bank_num));
+
+	return 0;
+}
+
+/**
+ * xgpiops_dir_out - Set the direction of the specified GPIO pin as output
+ * @chip:	gpio_chip instance to be worked on
+ * @pin:	gpio pin number within the device
+ * @state:	value to be written to specified pin
+ *
+ * This function sets the direction of specified GPIO pin as output, configures
+ * the Output Enable register for the pin and uses xgpiops_set to set the state
+ * of the pin to the value specified. Returns 0 always.
+ */
+static int xgpiops_dir_out(struct gpio_chip *chip, unsigned int pin, int state)
+{
+	struct xgpiops *gpio = container_of(chip, struct xgpiops, chip);
+	unsigned int reg, bank_num, bank_pin_num;
+
+	xgpiops_get_bank_pin(pin, &bank_num, &bank_pin_num);
+
+	/* set the GPIO pin as output */
+	reg = xgpiops_readreg(gpio->base_addr +
+			       XGPIOPS_DIRM_OFFSET(bank_num));
+	reg |= 1 << bank_pin_num;
+	xgpiops_writereg(reg,
+			  gpio->base_addr + XGPIOPS_DIRM_OFFSET(bank_num));
+
+	/* configure the output enable reg for the pin */
+	reg = xgpiops_readreg(gpio->base_addr +
+			       XGPIOPS_OUTEN_OFFSET(bank_num));
+	reg |= 1 << bank_pin_num;
+	xgpiops_writereg(reg,
+			  gpio->base_addr + XGPIOPS_OUTEN_OFFSET(bank_num));
+
+	/* set the state of the pin */
+	xgpiops_set_value(chip, pin, state);
+	return 0;
+}
+
+/**
+ * xgpiops_irq_ack - Acknowledge the interrupt of a gpio pin
+ * @irq_data: irq data containing irq number of gpio pin for the interrupt
+ *	      to ack
+ *
+ * This function calculates gpio pin number from irq number and sets the bit
+ * in the Interrupt Status Register of the corresponding bank, to ACK the irq.
+ */
+static void xgpiops_irq_ack(struct irq_data *irq_data)
+{
+	struct xgpiops *gpio =
+			(struct xgpiops *)irq_data_get_irq_chip_data(irq_data);
+	unsigned int device_pin_num, bank_num, bank_pin_num;
+	unsigned int irq_sts;
+
+	/* get pin num within the device */
+	device_pin_num = irq_to_gpio(irq_data->irq);
+	xgpiops_get_bank_pin(device_pin_num, &bank_num, &bank_pin_num);
+	irq_sts = xgpiops_readreg(gpio->base_addr +
+				   XGPIOPS_INTSTS_OFFSET(bank_num)) |
+				   (1 << bank_pin_num);
+	xgpiops_writereg(irq_sts,
+			  gpio->base_addr + (XGPIOPS_INTSTS_OFFSET(bank_num)));
+}
+
+/**
+ * xgpiops_irq_mask - Disable the interrupts for a gpio pin
+ * @irq: irq number of gpio pin for which interrupt is to be disabled
+ *
+ * This function calculates gpio pin number from irq number and sets the
+ * bit in the Interrupt Disable register of the corresponding bank to disable
+ * interrupts for that pin.
+ */
+static void xgpiops_irq_mask(struct irq_data *irq_data)
+{
+	struct xgpiops *gpio = (struct xgpiops *)irq_data_get_irq_chip_data(irq_data);
+	unsigned int device_pin_num, bank_num, bank_pin_num;
+	unsigned int irq_dis;
+
+	/* get pin num within the device */
+	device_pin_num = irq_to_gpio(irq_data->irq);
+	xgpiops_get_bank_pin(device_pin_num, &bank_num, &bank_pin_num);
+	irq_dis = xgpiops_readreg(gpio->base_addr +
+				   XGPIOPS_INTDIS_OFFSET(bank_num)) |
+				   (1 << bank_pin_num);
+	xgpiops_writereg(irq_dis,
+			  gpio->base_addr + XGPIOPS_INTDIS_OFFSET(bank_num));
+}
+
+/**
+ * xgpiops_irq_unmask - Enable the interrupts for a gpio pin
+ * @irq_data: irq data containing irq number of gpio pin for the interrupt
+ *	      to enable
+ *
+ * This function calculates the gpio pin number from irq number and sets the
+ * bit in the Interrupt Enable register of the corresponding bank to enable
+ * interrupts for that pin.
+ */
+static void xgpiops_irq_unmask(struct irq_data *irq_data)
+{
+	struct xgpiops *gpio = (struct xgpiops *)irq_data_get_irq_chip_data(irq_data);
+	unsigned int device_pin_num, bank_num, bank_pin_num;
+	unsigned int irq_en;
+
+	/* get pin num within the device */
+	device_pin_num = irq_to_gpio(irq_data->irq);
+	xgpiops_get_bank_pin(device_pin_num, &bank_num, &bank_pin_num);
+	irq_en = xgpiops_readreg(gpio->base_addr +
+				  XGPIOPS_INTEN_OFFSET(bank_num)) |
+				  (1 << bank_pin_num);
+	xgpiops_writereg(irq_en,
+			  gpio->base_addr + XGPIOPS_INTEN_OFFSET(bank_num));
+}
+
+/**
+ * xgpiops_set_irq_type - Set the irq type for a gpio pin
+ * @irq_data: irq data containing irq number of gpio pin
+ * @type:	interrupt type that is to be set for the gpio pin
+ *
+ * This function gets the gpio pin number and its bank from the gpio pin number
+ * and configures the INT_TYPE, INT_POLARITY and INT_ANY registers. Returns 0,
+ * negative error otherwise.
+ * TYPE-EDGE_RISING,  INT_TYPE - 1, INT_POLARITY - 1,  INT_ANY - 0;
+ * TYPE-EDGE_FALLING, INT_TYPE - 1, INT_POLARITY - 0,  INT_ANY - 0;
+ * TYPE-EDGE_BOTH,    INT_TYPE - 1, INT_POLARITY - NA, INT_ANY - 1;
+ * TYPE-LEVEL_HIGH,   INT_TYPE - 0, INT_POLARITY - 1,  INT_ANY - NA;
+ * TYPE-LEVEL_LOW,    INT_TYPE - 0, INT_POLARITY - 0,  INT_ANY - NA
+ */
+static int xgpiops_set_irq_type(struct irq_data *irq_data, unsigned int type)
+{
+	struct xgpiops *gpio =
+			(struct xgpiops *)irq_data_get_irq_chip_data(irq_data);
+	unsigned int device_pin_num, bank_num, bank_pin_num;
+	unsigned int int_type, int_pol, int_any;
+
+	/* get pin num within the device */
+	device_pin_num = irq_to_gpio(irq_data->irq);
+	xgpiops_get_bank_pin(device_pin_num, &bank_num, &bank_pin_num);
+
+	int_type = xgpiops_readreg(gpio->base_addr +
+				    XGPIOPS_INTTYPE_OFFSET(bank_num));
+	int_pol = xgpiops_readreg(gpio->base_addr +
+				   XGPIOPS_INTPOL_OFFSET(bank_num));
+	int_any = xgpiops_readreg(gpio->base_addr +
+				   XGPIOPS_INTANY_OFFSET(bank_num));
+
+	/*
+	 * based on the type requested, configure the INT_TYPE, INT_POLARITY
+	 * and INT_ANY registers
+	 */
+	switch (type) {
+	case IRQ_TYPE_EDGE_RISING:
+		int_type |= (1 << bank_pin_num);
+		int_pol |= (1 << bank_pin_num);
+		int_any &= ~(1 << bank_pin_num);
+		break;
+	case IRQ_TYPE_EDGE_FALLING:
+		int_type |= (1 << bank_pin_num);
+		int_pol &= ~(1 << bank_pin_num);
+		int_any &= ~(1 << bank_pin_num);
+		break;
+	case IRQ_TYPE_EDGE_BOTH:
+		int_type |= (1 << bank_pin_num);
+		int_any |= (1 << bank_pin_num);
+		break;
+	case IRQ_TYPE_LEVEL_HIGH:
+		int_type &= ~(1 << bank_pin_num);
+		int_pol |= (1 << bank_pin_num);
+		break;
+	case IRQ_TYPE_LEVEL_LOW:
+		int_type &= ~(1 << bank_pin_num);
+		int_pol &= ~(1 << bank_pin_num);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	xgpiops_writereg(int_type,
+			  gpio->base_addr + XGPIOPS_INTTYPE_OFFSET(bank_num));
+	xgpiops_writereg(int_pol,
+			  gpio->base_addr + XGPIOPS_INTPOL_OFFSET(bank_num));
+	xgpiops_writereg(int_any,
+			  gpio->base_addr + XGPIOPS_INTANY_OFFSET(bank_num));
+	return 0;
+}
+
+/* irq chip descriptor */
+static struct irq_chip xgpiops_irqchip = {
+	.name		= DRIVER_NAME,
+	.irq_ack	= xgpiops_irq_ack,
+	.irq_mask	= xgpiops_irq_mask,
+	.irq_unmask	= xgpiops_irq_unmask,
+	.irq_set_type	= xgpiops_set_irq_type,
+};
+
+/**
+ * xgpiops_irqhandler - IRQ handler for the gpio banks of a gpio device
+ * @irq:	irq number of the gpio bank where interrupt has occurred
+ * @desc:	irq descriptor instance of the 'irq'
+ *
+ * This function reads the Interrupt Status Register of each bank to get the
+ * gpio pin number which has triggered an interrupt. It then acks the triggered
+ * interrupt and calls the pin specific handler set by the higher layer
+ * application for that pin.
+ * Note: A bug is reported if no handler is set for the gpio pin.
+ */
+void xgpiops_irqhandler(unsigned int irq, struct irq_desc *desc)
+{
+	int gpio_irq = (int)irq_get_handler_data(irq);
+	struct xgpiops *gpio = (struct xgpiops *)irq_get_chip_data(gpio_irq);
+	unsigned int int_sts, int_enb, bank_num;
+	struct irq_desc *gpio_irq_desc;
+	struct irq_chip *chip = irq_desc_get_chip(desc);
+	struct irq_data *irq_data = irq_get_chip_data(irq);
+
+	chip->irq_ack(irq_data);
+	for (bank_num = 0; bank_num < 4; bank_num++) {
+		int_sts = xgpiops_readreg(gpio->base_addr +
+					   XGPIOPS_INTSTS_OFFSET(bank_num));
+		int_enb = xgpiops_readreg(gpio->base_addr +
+					   XGPIOPS_INTMASK_OFFSET(bank_num));
+		/*
+		 * handle only the interrupts which are enabled in interrupt
+		 * mask register
+		 */
+		int_sts &= ~int_enb;
+		for (; int_sts != 0; int_sts >>= 1, gpio_irq++) {
+			if ((int_sts & 1) == 0)
+				continue;
+			BUG_ON(!(irq_desc[gpio_irq].handle_irq));
+			gpio_irq_desc = irq_to_desc(gpio_irq);
+			chip->irq_ack(irq_data);
+
+			/* call the pin specific handler */
+			irq_desc[gpio_irq].handle_irq(gpio_irq,
+						      &irq_desc[gpio_irq]);
+		}
+		/* shift to first virtual irq of next bank */
+		gpio_irq = (int)irq_get_handler_data(irq) +
+				(xgpiops_pin_table[bank_num] + 1);
+	}
+	chip->irq_unmask(irq_data);
+}
+
+/**
+ * xgpiops_probe - Initialization method for a xgpiops device
+ * @pdev:	platform device instance
+ *
+ * This function allocates memory resources for the gpio device and registers
+ * all the banks of the device. It will also set up interrupts for the gpio
+ * pins.
+ * Note: Interrupts are disabled for all the banks during initialization.
+ * Returns 0 on success, negative error otherwise.
+ */
+static int __init xgpiops_probe(struct platform_device *pdev)
+{
+	int ret;
+	unsigned int irq_num;
+	struct xgpiops *gpio;
+	struct gpio_chip *chip;
+	resource_size_t remap_size;
+	struct resource *mem_res = NULL;
+	int pin_num, bank_num, gpio_irq;
+
+	gpio = kzalloc(sizeof(struct xgpiops), GFP_KERNEL);
+	if (!gpio) {
+		dev_err(&pdev->dev, "couldn't allocate memory for gpio private "
+			"data\n");
+		return -ENOMEM;
+	}
+
+	platform_set_drvdata(pdev, gpio);
+
+	mem_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!mem_res) {
+		dev_err(&pdev->dev, "No memory resource\n");
+		ret = -ENODEV;
+		goto err_free_gpio;
+	}
+
+	remap_size = mem_res->end - mem_res->start + 1;
+	if (!request_mem_region(mem_res->start, remap_size, pdev->name)) {
+		dev_err(&pdev->dev, "Cannot request IO\n");
+		ret = -ENXIO;
+		goto err_free_gpio;
+	}
+
+	gpio->base_addr = ioremap(mem_res->start, remap_size);
+	if (gpio->base_addr == NULL) {
+		dev_err(&pdev->dev, "Couldn't ioremap memory at 0x%08lx\n",
+			(unsigned long)mem_res->start);
+		ret = -ENOMEM;
+		goto err_release_region;
+	}
+
+	irq_num = platform_get_irq(pdev, 0);
+
+	/* configure the gpio chip */
+	chip = &gpio->chip;
+	chip->label = "xgpiops";
+	chip->owner = THIS_MODULE;
+	chip->dev = &pdev->dev;
+	chip->get = xgpiops_get_value;
+	chip->set = xgpiops_set_value;
+	chip->direction_input = xgpiops_dir_in;
+	chip->direction_output = xgpiops_dir_out;
+	chip->dbg_show = NULL;
+	chip->base = 0;		/* default pin base */
+	chip->ngpio = 246;
+	chip->can_sleep = 0;
+
+	/* report a bug if gpio chip registration fails */
+	ret = gpiochip_add(chip);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "gpio chip registration failed\n");
+		goto err_iounmap;
+	} else
+		dev_info(&pdev->dev, "gpio at 0x%08lx mapped to 0x%08lx\n",
+			 (unsigned long)mem_res->start,
+			 (unsigned long)gpio->base_addr);
+
+	/* disable interrupts for all banks */
+	for (bank_num = 0; bank_num < 4; bank_num++) {
+		xgpiops_writereg(0xffffffff, gpio->base_addr +
+				  XGPIOPS_INTDIS_OFFSET(bank_num));
+	}
+
+	/*
+	 * set the irq chip, handler and irq chip data for callbacks for
+	 * each pin
+	 */
+	gpio_irq = XGPIOPS_IRQBASE;
+	for (pin_num = 0; pin_num < ARCH_NR_GPIOS; pin_num++, gpio_irq++) {
+		irq_set_chip(gpio_irq, &xgpiops_irqchip);
+		irq_set_chip_data(gpio_irq, (void *)gpio);
+		irq_set_handler(gpio_irq, handle_simple_irq);
+		irq_set_status_flags(gpio_irq, IRQF_VALID);
+	}
+
+	irq_set_handler_data(irq_num, (void *)(XGPIOPS_IRQBASE));
+	irq_set_chained_handler(irq_num, xgpiops_irqhandler);
+
+	return 0;
+
+err_iounmap:
+	iounmap(gpio->base_addr);
+err_release_region:
+	release_mem_region(mem_res->start, remap_size);
+err_free_gpio:
+	platform_set_drvdata(pdev, NULL);
+	kfree(gpio);
+
+	return ret;
+}
+
+#ifdef CONFIG_OF
+static struct of_device_id xgpiops_of_match[] __devinitdata = {
+	{ .compatible = "xlnx,ps7-gpio-1.00.a", },
+	{ /* end of table */}
+};
+MODULE_DEVICE_TABLE(of, xgpiops_of_match);
+#endif
+
+static struct platform_driver xgpiops_driver = {
+	.driver	= {
+		.name	= DRIVER_NAME,
+		.owner	= THIS_MODULE,
+#ifdef CONFIG_OF
+		.of_match_table = xgpiops_of_match,
+#endif
+	},
+	.probe		= xgpiops_probe,
+};
+
+/**
+ * xgpiops_init - Initial driver registration call
+ */
+static int __init xgpiops_init(void)
+{
+	return platform_driver_register(&xgpiops_driver);
+}
+
+subsys_initcall(xgpiops_init);
-- 
1.7.9.7

