From e4541bb0a43a8c1eb938e61459d07eefee57e079 Mon Sep 17 00:00:00 2001
From: Lars-Peter Clausen <lars@metafoo.de>
Date: Fri, 13 Jul 2012 15:35:38 +0200
Subject: [PATCH 220/509] DRM: adv7511: Sync to latest version

https://github.com/analogdevicesinc/linux.git xcomm_zynq
commit 7d307a6481f99972f4b7dd871b9421aeb5322e42

Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 drivers/gpu/drm/i2c/adv7511.h       |   75 +++++++++++++++++++++++++++--------
 drivers/gpu/drm/i2c/adv7511_audio.c |   47 ++++++++++------------
 drivers/gpu/drm/i2c/adv7511_core.c  |   74 ++++++++++++++++++++--------------
 3 files changed, 123 insertions(+), 73 deletions(-)

diff --git a/drivers/gpu/drm/i2c/adv7511.h b/drivers/gpu/drm/i2c/adv7511.h
index a80916a..ebfc053 100644
--- a/drivers/gpu/drm/i2c/adv7511.h
+++ b/drivers/gpu/drm/i2c/adv7511.h
@@ -1,3 +1,11 @@
+/**
+ * Analog Devices ADV7511 HDMI transmitter driver
+ *
+ * Copyright 2012 Analog Devices Inc.
+ *
+ * Licensed under the GPL-2.
+ */
+
 #ifndef __ADV7511_H__
 #define __ADV7511_H__
 
@@ -15,6 +23,14 @@
 #define ADV7511_REG_AUDIO_CONFIG		0x0b
 #define ADV7511_REG_I2S_CONFIG			0x0c
 #define ADV7511_REG_I2S_WIDTH			0x0d
+#define ADV7511_REG_AUDIO_SUB_SRC0		0x0e
+#define ADV7511_REG_AUDIO_SUB_SRC1		0x0f
+#define ADV7511_REG_AUDIO_SUB_SRC2		0x10
+#define ADV7511_REG_AUDIO_SUB_SRC3		0x11
+#define ADV7511_REG_AUDIO_CFG1			0x12
+#define ADV7511_REG_AUDIO_CFG2			0x13
+#define ADV7511_REG_AUDIO_CFG3			0x14
+#define ADV7511_REG_I2C_FREQ_ID_CFG		0x15
 #define ADV7511_REG_VIDEO_INPUT_CFG1		0x16
 #define ADV7511_REG_CSC_UPPER(x)		(0x18 + (x) * 2)
 #define ADV7511_REG_CSC_LOWER(x)		(0x19 + (x) * 2)
@@ -46,17 +62,18 @@
 #define ADV7511_REG_INT(x)			(0x96 + (x))
 #define ADV7511_REG_INPUT_CLK_DIV		0x9d
 #define ADV7511_REG_PLL_STATUS			0x9e
-#define ADV7511_REG_POWER_DOWN			0xa1
+#define ADV7511_REG_HDMI_POWER			0xa1
 #define ADV7511_REG_HDCP_HDMI_CFG		0xaf
 #define ADV7511_REG_AN(x)			(0xb0 + (x)) /* 0xb0 - 0xb7 */
 #define ADV7511_REG_HDCP_STATUS			0xb8
 #define ADV7511_REG_BCAPS			0xbe
 #define ADV7511_REG_BKSV(x)			(0xc0 + (x)) /* 0xc0 - 0xc3 */
 #define ADV7511_REG_EDID_SEGMENT		0xc4
-#define ADV7511_REG_DDC_CONTROLLER_STATUS	0xc8
+#define ADV7511_REG_DDC_STATUS			0xc8
 #define ADV7511_REG_EDID_READ_CTRL		0xc9
 #define ADV7511_REG_BSTATUS(x)			(0xca + (x)) /* 0xca - 0xcb */
 #define ADV7511_REG_TIMING_GEN_SEQ		0xd0
+#define ADV7511_REG_POWER2			0xd6
 #define ADV7511_REG_HSYNC_PLACEMENT_MSB		0xfa
 
 #define ADV7511_REG_SYNC_ADJUSTMENT(x)		(0xd7 + (x)) /* 0xd7 - 0xdc */
@@ -133,6 +150,14 @@
 #define ADV7511_PACKET_ENABLE_SPARE2		BIT(1)
 #define ADV7511_PACKET_ENABLE_SPARE1		BIT(0)
 
+#define ADV7511_REG_POWER2_HDP_SRC_MASK		0xc0
+#define ADV7511_REG_POWER2_HDP_SRC_BOTH		0x00
+#define ADV7511_REG_POWER2_HDP_SRC_HDP		0x40
+#define ADV7511_REG_POWER2_HDP_SRC_CEC		0x80
+#define ADV7511_REG_POWER2_HDP_SRC_NONE		0xc0
+#define ADV7511_REG_POWER2_TDMS_ENABLE		BIT(4)
+#define ADV7511_REG_POWER2_GATE_INPUT_CLK	BIT(0)
+
 #define ADV7511_LOW_REFRESH_RATE_NONE 0x0
 #define ADV7511_LOW_REFRESH_RATE_24HZ 0x1
 #define ADV7511_LOW_REFRESH_RATE_25HZ 0x2
@@ -212,17 +237,6 @@ enum adv7511_input_clock_delay {
 	ADV7511_INPUT_CLOCK_DELAY_PLUS_1600PS = 7,
 };
 
-enum adv7511_input_adjust_delay {
-	ADV7511_INPUT_ADJUST_DELAY_MINUS_1200PS = 0,
-	ADV7511_INPUT_ADJUST_DELAY_MINUS_800PS = 1,
-	ADV7511_INPUT_ADJUST_DELAY_MINUS_400PS = 2,
-	ADV7511_INPUT_ADJUST_DELAY_NONE = 3,
-	ADV7511_INPUT_ADJUST_DELAY_PLUS_400PS = 4,
-	ADV7511_INPUT_ADJUST_DELAY_PLUS_800PS = 5,
-	ADV7511_INPUT_ADJUST_DELAY_PLUS_1200PS = 6,
-	ADV7511_INPUT_ADJUST_DELAY_INVERT_CLK = 7,
-};
-
 enum adv7511_input_bit_justifiction {
 	ADV7511_INPUT_BIT_JUSTIFICATION_EVENLY = 0,
 	ADV7511_INPUT_BIT_JUSTIFICATION_RIGHT = 1,
@@ -235,6 +249,32 @@ enum adv7511_output_format {
 	ADV7511_OUTPUT_FORMAT_YCBCR_444 = 2,
 };
 
+enum adv7511_csc_scaling {
+	ADV7511_CSC_SCALING_1 = 0,
+	ADV7511_CSC_SCALING_2 = 1,
+	ADV7511_CSC_SCALING_4 = 2,
+};
+
+/**
+ * struct adv7511_video_input_config - Describes adv7511 hardware configuration
+ * @id:				Video input format id
+ * @input_style:		Video input format style
+ * @sync_pulse:			Select the sync pulse
+ * @clock_delay:		Clock delay for the input clock
+ * @reverse_bitorder:		Reverse video input signal bitorder
+ * @bit_justification:		Video input format bit justification
+ * @up_conversion_first_order_interpolation:
+ * @input_color_depth:		Input video format color depth
+ * @tmds_clock_inversion:	Whether to invert the TDMS clock
+ * @vsync_polartity_low:	Whether the vsync polarity is low
+ * @hsync_polartity_low:	Whether the hsync polarity is low
+ * @csc_enable:			Whether to enable color space conversion
+ * @csc_scaling_factor:		Color space conversion scaling factor
+ * @csc_coefficents:		Color space conversion coefficents
+ * @output_format:		Video output format
+ * @timing_gen_sequence:
+ * @hdmi_mode:			Whether to use HDMI or DVI output mode
+ **/
 struct adv7511_video_input_config {
 	enum adv7511_input_id id;
 	enum adv7511_input_style input_style;
@@ -242,18 +282,19 @@ struct adv7511_video_input_config {
 	enum adv7511_input_clock_delay clock_delay;
 	bool reverse_bitorder;
 	enum adv7511_input_bit_justifiction bit_justification;
-	bool vsync_polartity_low;
-	bool hsync_polartity_low;
 	bool up_conversion_first_order_interpolation;
 	enum adv7511_input_color_depth input_color_depth;
 	bool tmds_clock_inversion;
 
+	bool vsync_polartity_low;
+	bool hsync_polartity_low;
+
 	bool csc_enable;
-	int csc_scaling_factor;
+	enum adv7511_csc_scaling csc_scaling_factor;
 	uint16_t *csc_coefficents;
 
 	enum adv7511_output_format output_format;
-	int timing_generation_sequence;
+	int timing_gen_sequence;
 	bool hdmi_mode;
 };
 
diff --git a/drivers/gpu/drm/i2c/adv7511_audio.c b/drivers/gpu/drm/i2c/adv7511_audio.c
index 9fb9948..6ca4e7c 100644
--- a/drivers/gpu/drm/i2c/adv7511_audio.c
+++ b/drivers/gpu/drm/i2c/adv7511_audio.c
@@ -1,3 +1,11 @@
+/**
+ * Analog Devices ADV7511 HDMI transmitter driver
+ *
+ * Copyright 2012 Analog Devices Inc.
+ *
+ * Licensed under the GPL-2.
+ */
+
 #include <linux/module.h>
 #include <linux/moduleparam.h>
 #include <linux/init.h>
@@ -15,12 +23,8 @@
 
 #include "adv7511.h"
 
-static const DECLARE_TLV_DB_SCALE(adv7511_levelshift_tlv, 0, 100, 0);
-
 static const struct snd_kcontrol_new adv7511_controls[] = {
 	SOC_SINGLE("Master Playback Switch", 0, 0, 0, 0),
-	SOC_SINGLE_TLV("Master Playback Volume", 0, 0, 45, 0,
-		adv7511_levelshift_tlv),
 };
 
 static const struct snd_soc_dapm_widget adv7511_dapm_widgets[] = {
@@ -122,10 +126,12 @@ static int adv7511_hw_params(struct snd_pcm_substream *substream,
 	adv7511->f_audio = params_rate(params);
 
 	adv7511_update_cts_n(adv7511);
-
-	regmap_update_bits(adv7511->regmap, 0x14, 0x0f, len);
-	regmap_update_bits(adv7511->regmap, 0x15, 0xf0, rate << 4);
-
+/*
+	regmap_update_bits(adv7511->regmap, ADV7511_REG_AUDIO_CFG3,
+	    ADV7511_REG_AUDIO_CFG3_LEN_MASK, len);
+	regmap_update_bits(adv7511->regmap, ADV7511_REG_AUDIO_CFG4,
+	    ADV7511_REG_AUDIO_CFG4_RATE_MASK, rate << 4);
+*/
 	return 0;
 }
 
@@ -171,7 +177,6 @@ static int adv7511_set_dai_fmt(struct snd_soc_dai *codec_dai,
 		return -EINVAL;
 	}
 
-	/* clock inversion */
 	switch (fmt & SND_SOC_DAIFMT_INV_MASK) {
 	case SND_SOC_DAIFMT_NB_NF:
 		invert_clock = 0;
@@ -183,9 +188,9 @@ static int adv7511_set_dai_fmt(struct snd_soc_dai *codec_dai,
 		return -EINVAL;
 	}
 
-	regmap_update_bits(adv7511->regmap, 0x0a, 0x70, audio_source << 4);
-	regmap_update_bits(adv7511->regmap, 0x0b, BIT(6), invert_clock << 6);
-	regmap_update_bits(adv7511->regmap, 0x0c, 0x03, i2s_format);
+	regmap_update_bits(adv7511->regmap, ADV7511_REG_AUDIO_SOURCE, 0x70, audio_source << 4);
+	regmap_update_bits(adv7511->regmap, ADV7511_REG_AUDIO_CONFIG, BIT(6), invert_clock << 6);
+	regmap_update_bits(adv7511->regmap, ADV7511_REG_I2S_CONFIG, 0x03, i2s_format);
 
 	adv7511->audio_source = audio_source;
 
@@ -203,7 +208,7 @@ static int adv7511_set_bias_level(struct snd_soc_codec *codec,
 		case ADV7511_AUDIO_SOURCE_I2S:
 			break;
 		case ADV7511_AUDIO_SOURCE_SPDIF:
-			regmap_update_bits(adv7511->regmap, 0x0b, BIT(7), BIT(7));
+			regmap_update_bits(adv7511->regmap, ADV7511_REG_AUDIO_CONFIG, BIT(7), BIT(7));
 			break;
 		}
 		break;
@@ -219,7 +224,7 @@ static int adv7511_set_bias_level(struct snd_soc_codec *codec,
 		}
 		break;
 	case SND_SOC_BIAS_STANDBY:
-		regmap_update_bits(adv7511->regmap, 0x0b, BIT(7), 0);
+		regmap_update_bits(adv7511->regmap, ADV7511_REG_AUDIO_CONFIG, BIT(7), 0);
 		break;
 	case SND_SOC_BIAS_OFF:
 		break;
@@ -256,15 +261,12 @@ static struct snd_soc_dai_driver adv7511_dai = {
 
 static int adv7511_suspend(struct snd_soc_codec *codec)
 {
-	adv7511_set_bias_level(codec, SND_SOC_BIAS_OFF);
-	return 0;
+	return adv7511_set_bias_level(codec, SND_SOC_BIAS_OFF);
 }
 
 static int adv7511_resume(struct snd_soc_codec *codec)
 {
-	adv7511_set_bias_level(codec, SND_SOC_BIAS_STANDBY);
-
-	return 0;
+	return adv7511_set_bias_level(codec, SND_SOC_BIAS_STANDBY);
 }
 
 static int adv7511_probe(struct snd_soc_codec *codec)
@@ -279,9 +281,7 @@ static int adv7511_probe(struct snd_soc_codec *codec)
 		return ret;
 	}
 
-	adv7511_set_bias_level(codec, SND_SOC_BIAS_STANDBY);
-
-	return 0;
+	return adv7511_set_bias_level(codec, SND_SOC_BIAS_STANDBY);
 }
 
 static int adv7511_remove(struct snd_soc_codec *codec)
@@ -297,9 +297,6 @@ static struct snd_soc_codec_driver adv7511_codec_driver = {
 	.resume		    = adv7511_resume,
 	.set_bias_level	    = adv7511_set_bias_level,
 
-/*
-	.controls	    = adv7511_controls,
-	.num_controls	    = ARRAY_SIZE(adv7511_controls),*/
 	.dapm_widgets	    = adv7511_dapm_widgets,
 	.num_dapm_widgets   = ARRAY_SIZE(adv7511_dapm_widgets),
 	.dapm_routes	    = adv7511_routes,
diff --git a/drivers/gpu/drm/i2c/adv7511_core.c b/drivers/gpu/drm/i2c/adv7511_core.c
index 096ff90..d67ec22 100644
--- a/drivers/gpu/drm/i2c/adv7511_core.c
+++ b/drivers/gpu/drm/i2c/adv7511_core.c
@@ -1,3 +1,10 @@
+/**
+ * Analog Devices ADV7511 HDMI transmitter driver
+ *
+ * Copyright 2012 Analog Devices Inc.
+ *
+ * Licensed under the GPL-2.
+ */
 
 #include <linux/slab.h>
 #include <linux/module.h>
@@ -90,6 +97,7 @@ static void adv7511_set_colormap(struct adv7511 *adv7511, bool enable,
 		ADV7511_CSC_UPDATE_MODE, 0);
 }
 
+#define ADV7511_HDMI_CFG_MODE_MASK 0x2
 #define ADV7511_HDMI_CFG_MODE_DVI 0x0
 #define ADV7511_HDMI_CFG_MODE_HDMI 0x2
 
@@ -101,8 +109,8 @@ static void adv7511_set_config(struct drm_encoder *encoder, void *c)
 	bool output_format_422, output_format_ycbcr;
 	unsigned int mode;
 
-	adv7511_set_colormap(adv7511, config->csc_enable, config->csc_coefficents,
-		config->csc_scaling_factor);
+	adv7511_set_colormap(adv7511, config->csc_enable,
+		config->csc_coefficents, config->csc_scaling_factor);
 
 	switch (config->output_format) {
 	case ADV7511_OUTPUT_FORMAT_YCBCR_444:
@@ -138,7 +146,8 @@ static void adv7511_set_config(struct drm_encoder *encoder, void *c)
 		break;
 	}
 
-	regmap_update_bits(adv7511->regmap, 0x15, 0xf, config->id);
+	regmap_update_bits(adv7511->regmap, ADV7511_REG_I2C_FREQ_ID_CFG,
+		0xf, config->id);
 	regmap_write(adv7511->regmap, ADV7511_REG_VIDEO_INPUT_CFG1,
 		(output_format_422 << 7) |
 		(config->input_color_depth << 4) |
@@ -149,9 +158,9 @@ static void adv7511_set_config(struct drm_encoder *encoder, void *c)
 		(config->bit_justification << 3));
 	regmap_write(adv7511->regmap, ADV7511_REG_TIMING_GEN_SEQ,
 		(sync_pulse << 2) |
-		(config->timing_generation_sequence << 1));
-/*	regmap_write(adv7511->regmap, 0xba,
-		(config->clock_delay << 5));*/
+		(config->timing_gen_sequence << 1));
+	regmap_write(adv7511->regmap, 0xba,
+		(config->clock_delay << 5));
 
 	regmap_update_bits(adv7511->regmap, ADV7511_REG_TMDS_CLOCK_INV,
 		0x08, config->tmds_clock_inversion << 3);
@@ -229,7 +238,7 @@ static bool adv7511_register_volatile(struct device *dev, unsigned int reg)
 	case ADV7511_REG_BKSV(2):
 	case ADV7511_REG_BKSV(3):
 	case ADV7511_REG_BKSV(4):
-	case ADV7511_REG_DDC_CONTROLLER_STATUS:
+	case ADV7511_REG_DDC_STATUS:
 	case ADV7511_REG_BSTATUS(0):
 	case ADV7511_REG_BSTATUS(1):
 	case ADV7511_REG_CHIP_ID_HIGH:
@@ -315,8 +324,8 @@ static int adv7511_wait_for_interrupt(struct adv7511 *adv7511, int irq, int time
 	return pending;
 }
 
-int adv7511_get_edid_block(void *data,
-	unsigned char *buf, int block, int len)
+static int adv7511_get_edid_block(void *data, unsigned char *buf,
+	int block, int len)
 {
 	struct drm_encoder *encoder = data;
 	struct adv7511 *adv7511 = encoder_to_adv7511(encoder);
@@ -330,7 +339,10 @@ int adv7511_get_edid_block(void *data,
 
 	if (adv7511->current_edid_segment != block / 2) {
 		unsigned int status;
-		regmap_read(adv7511->regmap, 0xc8, &status);
+
+		ret = regmap_read(adv7511->regmap, ADV7511_REG_DDC_STATUS, &status);
+		if (ret < 0)
+			return ret;
 		printk("edid status: %x\n", status);
 
 		if (status != 2) {
@@ -437,7 +449,9 @@ static void adv7511_encoder_dpms(struct drm_encoder *encoder, int mode)
 		 * avoid this we ignore the HDP pin for the first few seconds
 		 * after enabeling the output.
 		 */
-		regmap_update_bits(adv7511->regmap, 0xd6, 0xc0, 0xc0);
+		regmap_update_bits(adv7511->regmap, ADV7511_REG_POWER2,
+				ADV7511_REG_POWER2_HDP_SRC_MASK,
+				ADV7511_REG_POWER2_HDP_SRC_NONE);
 		/* Most of the registers are reset during power down or when HPD is low */
 		regcache_sync(adv7511->regmap);
 		break;
@@ -480,10 +494,12 @@ static enum drm_connector_status adv7511_encoder_detect(struct drm_encoder *enco
 		adv7511->dpms_mode == DRM_MODE_DPMS_ON) {
 		regcache_mark_dirty(adv7511->regmap);
 		adv7511_encoder_dpms(encoder, adv7511->dpms_mode);
-/*		adv7511_get_modes(encoder, connector);*/
+		adv7511_get_modes(encoder, connector);
 	} else {
 		/* Renable HDP sensing */
-		regmap_update_bits(adv7511->regmap, 0xd6, 0xc0, 0x0);
+		regmap_update_bits(adv7511->regmap, ADV7511_REG_POWER2,
+				ADV7511_REG_POWER2_HDP_SRC_MASK,
+				ADV7511_REG_POWER2_HDP_SRC_BOTH);
 	}
 
 	adv7511->status = status;
@@ -536,16 +552,16 @@ static void adv7511_encoder_mode_set(struct drm_encoder *encoder,
 
 /*
 	switch (adv7511->color_mode) {
-	case COLOR_MODE_30BIT:
+	case ADV7511_COLOR_MODE_30BIT:
 		adv7511->f_tmds = adv7511->f_tmds * 5 / 4;
 		break;
-	case COLOR_MODE_36BIT:
+	case ADV7511_COLOR_MODE_36BIT:
 		adv7511->f_tmds = adv7511->f_tmds * 3 / 2;
 		break;
-	case COLOR_MODE_48BIT:
+	case ADV7511_COLOR_MODE_48BIT:
 		adv7511->f_tmds = adv7511->f_tmds * 2;
 		break;
-	case COLOR_MODE_24BIT:
+	case ADV7511_COLOR_MODE_24BIT:
 		break;
 	}
 */
@@ -588,7 +604,7 @@ static int __devinit adv7511_probe(struct i2c_client *i2c,
 	if (!adv7511)
 		return -ENOMEM;
 
-	adv7511->regmap = regmap_init_i2c(i2c, &adv7511_regmap_config);
+	adv7511->regmap = devm_regmap_init_i2c(i2c, &adv7511_regmap_config);
 	if (IS_ERR(adv7511->regmap))
 		return PTR_ERR(adv7511->regmap);
 
@@ -601,8 +617,8 @@ static int __devinit adv7511_probe(struct i2c_client *i2c,
 
 	adv7511->i2c_main = i2c;
 	adv7511->i2c_edid = i2c_new_dummy(i2c->adapter, edid_i2c_addr >> 1);
-	adv7511->i2c_packet = i2c_new_dummy(i2c->adapter, packet_i2c_addr >> 1);
-	adv7511->i2c_cec = i2c_new_dummy(i2c->adapter, cec_i2c_addr >> 1);
+	if (!adv7511->i2c_edid)
+		return -ENOMEM;
 
 	for (i = 0; i < ARRAY_SIZE(adv7511_fixed_registers); ++i) {
 		regmap_write(adv7511->regmap, adv7511_fixed_registers[i][0],
@@ -610,10 +626,10 @@ static int __devinit adv7511_probe(struct i2c_client *i2c,
 	}
 
 	if (i2c->irq) {
-		ret = request_threaded_irq(i2c->irq, NULL, adv7511_irq_handler, 0,
-				dev_name(&i2c->dev), adv7511);
+		ret = request_threaded_irq(i2c->irq, NULL, adv7511_irq_handler,
+				IRQF_ONESHOT, dev_name(&i2c->dev), adv7511);
 		if (ret)
-			goto err_regmap_exit;
+			goto err_i2c_unregister_device;
 
 		init_waitqueue_head(&adv7511->wq);
 	}
@@ -632,8 +648,8 @@ static int __devinit adv7511_probe(struct i2c_client *i2c,
 
 	return 0;
 
-err_regmap_exit:
-	regmap_exit(adv7511->regmap);
+err_i2c_unregister_device:
+	i2c_unregister_device(adv7511->i2c_edid);
 
 	return ret;
 }
@@ -642,15 +658,11 @@ static int __devexit adv7511_remove(struct i2c_client *i2c)
 {
 	struct adv7511 *adv7511 = i2c_get_clientdata(i2c);
 
+	i2c_unregister_device(adv7511->i2c_edid);
+
 	if (i2c->irq)
 		free_irq(i2c->irq, adv7511);
 
-	regmap_exit(adv7511->regmap);
-
-	i2c_unregister_device(adv7511->i2c_edid);
-	i2c_unregister_device(adv7511->i2c_packet);
-	i2c_unregister_device(adv7511->i2c_cec);
-
 	return 0;
 }
 
-- 
1.7.5.4

