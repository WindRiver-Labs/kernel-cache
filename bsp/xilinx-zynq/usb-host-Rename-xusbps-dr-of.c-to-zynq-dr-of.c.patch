From 78b94c9de02e1fd5c64785e12d4c3e7f3d45e522 Mon Sep 17 00:00:00 2001
From: Michal Simek <michal.simek@xilinx.com>
Date: Wed, 27 Nov 2013 13:45:33 +0100
Subject: [PATCH 369/509] usb: host: Rename xusbps-dr-of.c to zynq-dr-of.c

https://github.com/analogdevicesinc/linux.git xcomm_zynq
commit fab1f18f68966a9551dbead51a0c2e5c1d45e65b

Use name which should be used in mainline.

Signed-off-by: Michal Simek <michal.simek@xilinx.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 arch/arm/configs/xilinx_zynq702_defconfig |    3 +-
 drivers/usb/gadget/Kconfig                |    2 +-
 drivers/usb/host/Kconfig                  |    4 +-
 drivers/usb/host/Makefile                 |    2 +-
 drivers/usb/host/xusbps-dr-of.c           |  328 -----------------------------
 drivers/usb/host/zynq-dr-of.c             |  328 +++++++++++++++++++++++++++++
 drivers/usb/phy/phy-zynq-usb.c            |    4 +-
 7 files changed, 336 insertions(+), 335 deletions(-)
 delete mode 100644 drivers/usb/host/xusbps-dr-of.c
 create mode 100644 drivers/usb/host/zynq-dr-of.c

diff --git a/arch/arm/configs/xilinx_zynq702_defconfig b/arch/arm/configs/xilinx_zynq702_defconfig
index b35cee8..8133041 100644
--- a/arch/arm/configs/xilinx_zynq702_defconfig
+++ b/arch/arm/configs/xilinx_zynq702_defconfig
@@ -1701,7 +1701,8 @@ CONFIG_USB_OTG=y
 CONFIG_USB_EHCI_HCD=y
 CONFIG_USB_EHCI_ROOT_HUB_TT=y
 # CONFIG_USB_EHCI_TT_NEWSCHED is not set
-CONFIG_USB_XUSBPS_DR_OF=y
+CONFIG_USB_EHCI_PCI=y
+CONFIG_USB_ZYNQ_DR_OF=y
 CONFIG_USB_EHCI_XUSBPS=y
 # CONFIG_USB_EHCI_HCD_PLATFORM is not set
 # CONFIG_USB_OXU210HP_HCD is not set
diff --git a/drivers/usb/gadget/Kconfig b/drivers/usb/gadget/Kconfig
index f668079..7dfbb8b 100644
--- a/drivers/usb/gadget/Kconfig
+++ b/drivers/usb/gadget/Kconfig
@@ -191,7 +191,7 @@ config USB_ZYNQ
 	depends on ARCH_ZYNQ
 	default USB_GADGET
 	select USB_GADGET_DUALSPEED
-	select USB_XUSBPS_DR_OF if OF
+	select USB_ZYNQ_DR_OF if OF
 	select USB_GADGET_SELECTED
 	help
 	   Xilinx Zynq USB controller core supports device mode.
diff --git a/drivers/usb/host/Kconfig b/drivers/usb/host/Kconfig
index abe0baf..6cd731f 100644
--- a/drivers/usb/host/Kconfig
+++ b/drivers/usb/host/Kconfig
@@ -132,7 +132,7 @@ config XPS_USB_HCD_XILINX
 		support both high speed and full speed devices, or high speed
 		devices only.
 
-config USB_XUSBPS_DR_OF
+config USB_ZYNQ_DR_OF
 	tristate
 	select USB_PHY
 	select USB_ULPI
@@ -142,7 +142,7 @@ config USB_EHCI_ZYNQ
 	bool "Support for Xilinx Zynq EHCI USB controller"
 	depends on USB_EHCI_HCD && ARCH_ZYNQ
 	select USB_EHCI_ROOT_HUB_TT
-	select USB_XUSBPS_DR_OF
+	select USB_ZYNQ_DR_OF
 	---help---
 		Xilinx Zynq USB host controller core is EHCI compilant and has
 		transaction translator built-in.
diff --git a/drivers/usb/host/Makefile b/drivers/usb/host/Makefile
index b279cde..40a877a 100644
--- a/drivers/usb/host/Makefile
+++ b/drivers/usb/host/Makefile
@@ -49,7 +49,7 @@ obj-$(CONFIG_USB_ISP1760_HCD)	+= isp1760.o
 obj-$(CONFIG_USB_HWA_HCD)	+= hwa-hc.o
 obj-$(CONFIG_USB_IMX21_HCD)	+= imx21-hcd.o
 obj-$(CONFIG_USB_FSL_MPH_DR_OF)	+= fsl-mph-dr-of.o
-obj-$(CONFIG_USB_XUSBPS_DR_OF)	+= xusbps-dr-of.o
+obj-$(CONFIG_USB_ZYNQ_DR_OF)	+= zynq-dr-of.o
 obj-$(CONFIG_USB_OCTEON2_COMMON) += octeon2-common.o
 obj-$(CONFIG_USB_HCD_BCMA)	+= bcma-hcd.o
 obj-$(CONFIG_USB_HCD_SSB)	+= ssb-hcd.o
diff --git a/drivers/usb/host/xusbps-dr-of.c b/drivers/usb/host/xusbps-dr-of.c
deleted file mode 100644
index b132072..0000000
--- a/drivers/usb/host/xusbps-dr-of.c
+++ /dev/null
@@ -1,328 +0,0 @@
-/*
- * Xilinx Zynq USB Driver for device tree support.
- *
- * Copyright (C) 2011 Xilinx, Inc.
- *
- * This file is based on fsl-mph-dr-of.c file with few minor modifications
- * to support Xilinx Zynq USB controller.
- *
- * Setup platform devices needed by the dual-role USB controller modules
- * based on the description in flat device tree.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published by
- * the Free Software Foundation; either version 2 of the License, or (at your
- * option) any later version.
- */
-
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/platform_device.h>
-#include <linux/xilinx_devices.h>
-#include <linux/err.h>
-#include <linux/io.h>
-#include <linux/of_platform.h>
-#include <linux/slab.h>
-#include <linux/string.h>
-#include <linux/clk.h>
-#include <linux/usb/ulpi.h>
-
-#include "ehci-xilinx-usbps.h"
-
-static u64 dma_mask = 0xFFFFFFF0;
-
-struct xusbps_dev_data {
-	char *dr_mode;		/* controller mode */
-	char *drivers[3];	/* drivers to instantiate for this mode */
-	enum xusbps_usb2_operating_modes op_mode;	/* operating mode */
-};
-
-struct xusbps_host_data {
-	struct clk *clk;
-};
-
-static struct xusbps_dev_data dr_mode_data[] = {
-	{
-		.dr_mode = "host",
-		.drivers = { "xusbps-ehci", NULL, NULL, },
-		.op_mode = XUSBPS_USB2_DR_HOST,
-	},
-	{
-		.dr_mode = "otg",
-		.drivers = { "xusbps-otg", "xusbps-ehci", "xusbps-udc", },
-		.op_mode = XUSBPS_USB2_DR_OTG,
-	},
-	{
-		.dr_mode = "peripheral",
-		.drivers = { "xusbps-udc", NULL, NULL, },
-		.op_mode = XUSBPS_USB2_DR_DEVICE,
-	},
-};
-
-static struct xusbps_dev_data *get_dr_mode_data(
-		struct device_node *np)
-{
-	const unsigned char *prop;
-	int i;
-
-	prop = of_get_property(np, "dr_mode", NULL);
-	if (prop) {
-		for (i = 0; i < ARRAY_SIZE(dr_mode_data); i++) {
-			if (!strcmp(prop, dr_mode_data[i].dr_mode))
-				return &dr_mode_data[i];
-		}
-	}
-	pr_warn("%s: Invalid 'dr_mode' property, fallback to host mode\n",
-		np->full_name);
-	return &dr_mode_data[0]; /* mode not specified, use host */
-}
-
-static enum xusbps_usb2_phy_modes determine_usb_phy(const char *phy_type)
-{
-	if (!phy_type)
-		return XUSBPS_USB2_PHY_NONE;
-	if (!strcasecmp(phy_type, "ulpi"))
-		return XUSBPS_USB2_PHY_ULPI;
-	if (!strcasecmp(phy_type, "utmi"))
-		return XUSBPS_USB2_PHY_UTMI;
-	if (!strcasecmp(phy_type, "utmi_wide"))
-		return XUSBPS_USB2_PHY_UTMI_WIDE;
-	if (!strcasecmp(phy_type, "serial"))
-		return XUSBPS_USB2_PHY_SERIAL;
-
-	return XUSBPS_USB2_PHY_NONE;
-}
-
-static struct platform_device *xusbps_device_register(
-					struct platform_device *ofdev,
-					struct xusbps_usb2_platform_data *pdata,
-					const char *name, int id)
-{
-	struct platform_device *pdev;
-	const struct resource *res = ofdev->resource;
-	unsigned int num = ofdev->num_resources;
-	struct xusbps_usb2_platform_data *pdata1;
-	int retval;
-
-	pdev = platform_device_alloc(name, id);
-	if (!pdev) {
-		retval = -ENOMEM;
-		goto error;
-	}
-
-	pdev->dev.parent = &ofdev->dev;
-
-	pdev->dev.coherent_dma_mask = ofdev->dev.coherent_dma_mask;
-	pdev->dev.dma_mask = &dma_mask;
-
-	retval = platform_device_add_data(pdev, pdata, sizeof(*pdata));
-	if (retval)
-		goto error;
-
-	if (num) {
-		retval = platform_device_add_resources(pdev, res, num);
-		if (retval)
-			goto error;
-	}
-
-	retval = platform_device_add(pdev);
-	if (retval)
-		goto error;
-
-	pdata1 = pdev->dev.platform_data;
-	/* Copy the otg transceiver pointer into host/device platform data */
-	if (pdata1->otg)
-		pdata->otg = pdata1->otg;
-
-	return pdev;
-
-error:
-	platform_device_put(pdev);
-	return ERR_PTR(retval);
-}
-
-static int xusbps_dr_of_probe(struct platform_device *ofdev)
-{
-	struct device_node *np = ofdev->dev.of_node;
-	struct platform_device *usb_dev;
-	struct xusbps_usb2_platform_data data, *pdata;
-	struct xusbps_dev_data *dev_data;
-	struct xusbps_host_data *hdata;
-	const unsigned char *prop;
-	static unsigned int idx;
-	struct resource *res;
-	int i, phy_init;
-	int ret;
-
-	pdata = &data;
-	memset(pdata, 0, sizeof(data));
-
-	res = platform_get_resource(ofdev, IORESOURCE_IRQ, 0);
-	if (IS_ERR(res)) {
-		dev_err(&ofdev->dev,
-			"IRQ not found\n");
-		return PTR_ERR(res);
-	}
-	pdata->irq = res->start;
-
-	res = platform_get_resource(ofdev, IORESOURCE_MEM, 0);
-	pdata->regs = devm_ioremap_resource(&ofdev->dev, res);
-	if (IS_ERR(pdata->regs)) {
-		dev_err(&ofdev->dev, "unable to iomap registers\n");
-		return PTR_ERR(pdata->regs);
-	}
-
-	dev_data = get_dr_mode_data(np);
-	pdata->operating_mode = dev_data->op_mode;
-
-	prop = of_get_property(np, "phy_type", NULL);
-	pdata->phy_mode = determine_usb_phy(prop);
-
-	hdata = devm_kzalloc(&ofdev->dev, sizeof(*hdata), GFP_KERNEL);
-	if (!hdata)
-		return -ENOMEM;
-	platform_set_drvdata(ofdev, hdata);
-
-	hdata->clk = devm_clk_get(&ofdev->dev, NULL);
-	if (IS_ERR(hdata->clk)) {
-		dev_err(&ofdev->dev, "input clock not found.\n");
-		return PTR_ERR(hdata->clk);
-	}
-
-	ret = clk_prepare_enable(hdata->clk);
-	if (ret) {
-		dev_err(&ofdev->dev, "Unable to enable APER clock.\n");
-		return ret;
-	}
-
-	pdata->clk = hdata->clk;
-
-	/* If ULPI phy type, set it up */
-	if (pdata->phy_mode == XUSBPS_USB2_PHY_ULPI) {
-		pdata->ulpi = otg_ulpi_create(&ulpi_viewport_access_ops,
-			ULPI_OTG_DRVVBUS | ULPI_OTG_DRVVBUS_EXT);
-		if (pdata->ulpi) {
-			pdata->ulpi->io_priv = pdata->regs +
-							XUSBPS_SOC_USB_ULPIVP;
-
-			phy_init = usb_phy_init(pdata->ulpi);
-			if (phy_init) {
-				dev_err(&ofdev->dev,
-					"Unable to init USB phy, missing?\n");
-				ret = -ENODEV;
-				goto err_out_clk_disable;
-			}
-		} else {
-			dev_err(&ofdev->dev,
-				"Unable to create ULPI transceiver\n");
-		}
-	}
-
-	for (i = 0; i < ARRAY_SIZE(dev_data->drivers); i++) {
-		if (!dev_data->drivers[i])
-			continue;
-		usb_dev = xusbps_device_register(ofdev, pdata,
-					dev_data->drivers[i], idx);
-		if (IS_ERR(usb_dev)) {
-			dev_err(&ofdev->dev, "Can't register usb device\n");
-			ret = PTR_ERR(usb_dev);
-			goto err_out_clk_disable;
-		}
-	}
-	idx++;
-	return 0;
-
-err_out_clk_disable:
-	clk_disable_unprepare(hdata->clk);
-
-	return ret;
-}
-
-static int __unregister_subdev(struct device *dev, void *d)
-{
-	platform_device_unregister(to_platform_device(dev));
-	return 0;
-}
-
-static int xusbps_dr_of_remove(struct platform_device *ofdev)
-{
-	struct xusbps_host_data *hdata = platform_get_drvdata(ofdev);
-
-	device_for_each_child(&ofdev->dev, NULL, __unregister_subdev);
-	clk_disable_unprepare(hdata->clk);
-	return 0;
-}
-
-#ifdef CONFIG_PM_SLEEP
-static int xusbps_dr_of_suspend(struct device *dev)
-{
-	struct xusbps_host_data *hdata = dev_get_drvdata(dev);
-
-	clk_disable(hdata->clk);
-
-	return 0;
-}
-
-static int xusbps_dr_of_resume(struct device *dev)
-{
-	struct xusbps_host_data *hdata = dev_get_drvdata(dev);
-	int ret;
-
-	ret = clk_enable(hdata->clk);
-	if (ret) {
-		dev_err(dev, "cannot enable clock. resume failed\n");
-		return ret;
-	}
-
-	return 0;
-}
-#endif /* CONFIG_PM_SLEEP */
-
-static SIMPLE_DEV_PM_OPS(xusbps_pm_ops, xusbps_dr_of_suspend,
-		xusbps_dr_of_resume);
-
-static const struct of_device_id xusbps_dr_of_match[] = {
-	{ .compatible = "xlnx,ps7-usb-1.00.a" },
-	{},
-};
-MODULE_DEVICE_TABLE(of, xusbps_dr_of_match);
-
-static struct platform_driver xusbps_dr_driver = {
-	.driver = {
-		.name = "xusbps-dr",
-		.owner = THIS_MODULE,
-		.of_match_table = xusbps_dr_of_match,
-		.pm = &xusbps_pm_ops,
-	},
-	.probe	= xusbps_dr_of_probe,
-	.remove	= xusbps_dr_of_remove,
-};
-
-#ifdef CONFIG_USB_ZYNQ_PHY
-extern struct platform_driver xusbps_otg_driver;
-
-static int __init xusbps_dr_init(void)
-{
-	int retval;
-
-	/* Register otg driver first */
-	retval = platform_driver_register(&xusbps_otg_driver);
-	if (retval != 0)
-		return retval;
-
-	return platform_driver_register(&xusbps_dr_driver);
-}
-module_init(xusbps_dr_init);
-
-static void __exit xusbps_dr_exit(void)
-{
-	platform_driver_unregister(&xusbps_dr_driver);
-}
-module_exit(xusbps_dr_exit);
-#else
-module_platform_driver(xusbps_dr_driver);
-#endif
-
-MODULE_DESCRIPTION("XUSBPS DR OF devices driver");
-MODULE_AUTHOR("Xilinx");
-MODULE_LICENSE("GPL");
diff --git a/drivers/usb/host/zynq-dr-of.c b/drivers/usb/host/zynq-dr-of.c
new file mode 100644
index 0000000..b132072
--- /dev/null
+++ b/drivers/usb/host/zynq-dr-of.c
@@ -0,0 +1,328 @@
+/*
+ * Xilinx Zynq USB Driver for device tree support.
+ *
+ * Copyright (C) 2011 Xilinx, Inc.
+ *
+ * This file is based on fsl-mph-dr-of.c file with few minor modifications
+ * to support Xilinx Zynq USB controller.
+ *
+ * Setup platform devices needed by the dual-role USB controller modules
+ * based on the description in flat device tree.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/xilinx_devices.h>
+#include <linux/err.h>
+#include <linux/io.h>
+#include <linux/of_platform.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/clk.h>
+#include <linux/usb/ulpi.h>
+
+#include "ehci-xilinx-usbps.h"
+
+static u64 dma_mask = 0xFFFFFFF0;
+
+struct xusbps_dev_data {
+	char *dr_mode;		/* controller mode */
+	char *drivers[3];	/* drivers to instantiate for this mode */
+	enum xusbps_usb2_operating_modes op_mode;	/* operating mode */
+};
+
+struct xusbps_host_data {
+	struct clk *clk;
+};
+
+static struct xusbps_dev_data dr_mode_data[] = {
+	{
+		.dr_mode = "host",
+		.drivers = { "xusbps-ehci", NULL, NULL, },
+		.op_mode = XUSBPS_USB2_DR_HOST,
+	},
+	{
+		.dr_mode = "otg",
+		.drivers = { "xusbps-otg", "xusbps-ehci", "xusbps-udc", },
+		.op_mode = XUSBPS_USB2_DR_OTG,
+	},
+	{
+		.dr_mode = "peripheral",
+		.drivers = { "xusbps-udc", NULL, NULL, },
+		.op_mode = XUSBPS_USB2_DR_DEVICE,
+	},
+};
+
+static struct xusbps_dev_data *get_dr_mode_data(
+		struct device_node *np)
+{
+	const unsigned char *prop;
+	int i;
+
+	prop = of_get_property(np, "dr_mode", NULL);
+	if (prop) {
+		for (i = 0; i < ARRAY_SIZE(dr_mode_data); i++) {
+			if (!strcmp(prop, dr_mode_data[i].dr_mode))
+				return &dr_mode_data[i];
+		}
+	}
+	pr_warn("%s: Invalid 'dr_mode' property, fallback to host mode\n",
+		np->full_name);
+	return &dr_mode_data[0]; /* mode not specified, use host */
+}
+
+static enum xusbps_usb2_phy_modes determine_usb_phy(const char *phy_type)
+{
+	if (!phy_type)
+		return XUSBPS_USB2_PHY_NONE;
+	if (!strcasecmp(phy_type, "ulpi"))
+		return XUSBPS_USB2_PHY_ULPI;
+	if (!strcasecmp(phy_type, "utmi"))
+		return XUSBPS_USB2_PHY_UTMI;
+	if (!strcasecmp(phy_type, "utmi_wide"))
+		return XUSBPS_USB2_PHY_UTMI_WIDE;
+	if (!strcasecmp(phy_type, "serial"))
+		return XUSBPS_USB2_PHY_SERIAL;
+
+	return XUSBPS_USB2_PHY_NONE;
+}
+
+static struct platform_device *xusbps_device_register(
+					struct platform_device *ofdev,
+					struct xusbps_usb2_platform_data *pdata,
+					const char *name, int id)
+{
+	struct platform_device *pdev;
+	const struct resource *res = ofdev->resource;
+	unsigned int num = ofdev->num_resources;
+	struct xusbps_usb2_platform_data *pdata1;
+	int retval;
+
+	pdev = platform_device_alloc(name, id);
+	if (!pdev) {
+		retval = -ENOMEM;
+		goto error;
+	}
+
+	pdev->dev.parent = &ofdev->dev;
+
+	pdev->dev.coherent_dma_mask = ofdev->dev.coherent_dma_mask;
+	pdev->dev.dma_mask = &dma_mask;
+
+	retval = platform_device_add_data(pdev, pdata, sizeof(*pdata));
+	if (retval)
+		goto error;
+
+	if (num) {
+		retval = platform_device_add_resources(pdev, res, num);
+		if (retval)
+			goto error;
+	}
+
+	retval = platform_device_add(pdev);
+	if (retval)
+		goto error;
+
+	pdata1 = pdev->dev.platform_data;
+	/* Copy the otg transceiver pointer into host/device platform data */
+	if (pdata1->otg)
+		pdata->otg = pdata1->otg;
+
+	return pdev;
+
+error:
+	platform_device_put(pdev);
+	return ERR_PTR(retval);
+}
+
+static int xusbps_dr_of_probe(struct platform_device *ofdev)
+{
+	struct device_node *np = ofdev->dev.of_node;
+	struct platform_device *usb_dev;
+	struct xusbps_usb2_platform_data data, *pdata;
+	struct xusbps_dev_data *dev_data;
+	struct xusbps_host_data *hdata;
+	const unsigned char *prop;
+	static unsigned int idx;
+	struct resource *res;
+	int i, phy_init;
+	int ret;
+
+	pdata = &data;
+	memset(pdata, 0, sizeof(data));
+
+	res = platform_get_resource(ofdev, IORESOURCE_IRQ, 0);
+	if (IS_ERR(res)) {
+		dev_err(&ofdev->dev,
+			"IRQ not found\n");
+		return PTR_ERR(res);
+	}
+	pdata->irq = res->start;
+
+	res = platform_get_resource(ofdev, IORESOURCE_MEM, 0);
+	pdata->regs = devm_ioremap_resource(&ofdev->dev, res);
+	if (IS_ERR(pdata->regs)) {
+		dev_err(&ofdev->dev, "unable to iomap registers\n");
+		return PTR_ERR(pdata->regs);
+	}
+
+	dev_data = get_dr_mode_data(np);
+	pdata->operating_mode = dev_data->op_mode;
+
+	prop = of_get_property(np, "phy_type", NULL);
+	pdata->phy_mode = determine_usb_phy(prop);
+
+	hdata = devm_kzalloc(&ofdev->dev, sizeof(*hdata), GFP_KERNEL);
+	if (!hdata)
+		return -ENOMEM;
+	platform_set_drvdata(ofdev, hdata);
+
+	hdata->clk = devm_clk_get(&ofdev->dev, NULL);
+	if (IS_ERR(hdata->clk)) {
+		dev_err(&ofdev->dev, "input clock not found.\n");
+		return PTR_ERR(hdata->clk);
+	}
+
+	ret = clk_prepare_enable(hdata->clk);
+	if (ret) {
+		dev_err(&ofdev->dev, "Unable to enable APER clock.\n");
+		return ret;
+	}
+
+	pdata->clk = hdata->clk;
+
+	/* If ULPI phy type, set it up */
+	if (pdata->phy_mode == XUSBPS_USB2_PHY_ULPI) {
+		pdata->ulpi = otg_ulpi_create(&ulpi_viewport_access_ops,
+			ULPI_OTG_DRVVBUS | ULPI_OTG_DRVVBUS_EXT);
+		if (pdata->ulpi) {
+			pdata->ulpi->io_priv = pdata->regs +
+							XUSBPS_SOC_USB_ULPIVP;
+
+			phy_init = usb_phy_init(pdata->ulpi);
+			if (phy_init) {
+				dev_err(&ofdev->dev,
+					"Unable to init USB phy, missing?\n");
+				ret = -ENODEV;
+				goto err_out_clk_disable;
+			}
+		} else {
+			dev_err(&ofdev->dev,
+				"Unable to create ULPI transceiver\n");
+		}
+	}
+
+	for (i = 0; i < ARRAY_SIZE(dev_data->drivers); i++) {
+		if (!dev_data->drivers[i])
+			continue;
+		usb_dev = xusbps_device_register(ofdev, pdata,
+					dev_data->drivers[i], idx);
+		if (IS_ERR(usb_dev)) {
+			dev_err(&ofdev->dev, "Can't register usb device\n");
+			ret = PTR_ERR(usb_dev);
+			goto err_out_clk_disable;
+		}
+	}
+	idx++;
+	return 0;
+
+err_out_clk_disable:
+	clk_disable_unprepare(hdata->clk);
+
+	return ret;
+}
+
+static int __unregister_subdev(struct device *dev, void *d)
+{
+	platform_device_unregister(to_platform_device(dev));
+	return 0;
+}
+
+static int xusbps_dr_of_remove(struct platform_device *ofdev)
+{
+	struct xusbps_host_data *hdata = platform_get_drvdata(ofdev);
+
+	device_for_each_child(&ofdev->dev, NULL, __unregister_subdev);
+	clk_disable_unprepare(hdata->clk);
+	return 0;
+}
+
+#ifdef CONFIG_PM_SLEEP
+static int xusbps_dr_of_suspend(struct device *dev)
+{
+	struct xusbps_host_data *hdata = dev_get_drvdata(dev);
+
+	clk_disable(hdata->clk);
+
+	return 0;
+}
+
+static int xusbps_dr_of_resume(struct device *dev)
+{
+	struct xusbps_host_data *hdata = dev_get_drvdata(dev);
+	int ret;
+
+	ret = clk_enable(hdata->clk);
+	if (ret) {
+		dev_err(dev, "cannot enable clock. resume failed\n");
+		return ret;
+	}
+
+	return 0;
+}
+#endif /* CONFIG_PM_SLEEP */
+
+static SIMPLE_DEV_PM_OPS(xusbps_pm_ops, xusbps_dr_of_suspend,
+		xusbps_dr_of_resume);
+
+static const struct of_device_id xusbps_dr_of_match[] = {
+	{ .compatible = "xlnx,ps7-usb-1.00.a" },
+	{},
+};
+MODULE_DEVICE_TABLE(of, xusbps_dr_of_match);
+
+static struct platform_driver xusbps_dr_driver = {
+	.driver = {
+		.name = "xusbps-dr",
+		.owner = THIS_MODULE,
+		.of_match_table = xusbps_dr_of_match,
+		.pm = &xusbps_pm_ops,
+	},
+	.probe	= xusbps_dr_of_probe,
+	.remove	= xusbps_dr_of_remove,
+};
+
+#ifdef CONFIG_USB_ZYNQ_PHY
+extern struct platform_driver xusbps_otg_driver;
+
+static int __init xusbps_dr_init(void)
+{
+	int retval;
+
+	/* Register otg driver first */
+	retval = platform_driver_register(&xusbps_otg_driver);
+	if (retval != 0)
+		return retval;
+
+	return platform_driver_register(&xusbps_dr_driver);
+}
+module_init(xusbps_dr_init);
+
+static void __exit xusbps_dr_exit(void)
+{
+	platform_driver_unregister(&xusbps_dr_driver);
+}
+module_exit(xusbps_dr_exit);
+#else
+module_platform_driver(xusbps_dr_driver);
+#endif
+
+MODULE_DESCRIPTION("XUSBPS DR OF devices driver");
+MODULE_AUTHOR("Xilinx");
+MODULE_LICENSE("GPL");
diff --git a/drivers/usb/phy/phy-zynq-usb.c b/drivers/usb/phy/phy-zynq-usb.c
index 4f58b6f..e9e7e9e 100644
--- a/drivers/usb/phy/phy-zynq-usb.c
+++ b/drivers/usb/phy/phy-zynq-usb.c
@@ -2277,7 +2277,7 @@ static const struct dev_pm_ops xusbps_otg_dev_pm_ops = {
 #define XUSBPS_OTG_PM	NULL
 #endif /* ! CONFIG_PM_SLEEP */
 
-#ifndef CONFIG_USB_XUSBPS_DR_OF
+#ifndef CONFIG_USB_ZYNQ_DR_OF
 static struct platform_driver xusbps_otg_driver = {
 #else
 struct platform_driver xusbps_otg_driver = {
@@ -2291,7 +2291,7 @@ struct platform_driver xusbps_otg_driver = {
 	},
 };
 
-#ifndef CONFIG_USB_XUSBPS_DR_OF
+#ifndef CONFIG_USB_ZYNQ_DR_OF
 module_platform_driver(xusbps_otg_driver);
 #endif
 
-- 
1.7.5.4

