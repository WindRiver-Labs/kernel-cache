From 272361ed3c5e3c8a3e02359d6c68e80683a241f5 Mon Sep 17 00:00:00 2001
From: Zumeng Chen <zumeng.chen@windriver.com>
Date: Fri, 26 Dec 2014 10:48:43 +0800
Subject: [PATCH 001/182] arm: zynq: add mach support for 3.14.x

This patch comes from:
  https://github.com/Xilinx/linux-xlnx.git

And it's a diff stuff since there is not easy to find the same base
line between our 3.14.x and xilinx 3.14.x, and there is not so much
files as well.

Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 arch/arm/mach-zynq/Kconfig        |   50 ++-
 arch/arm/mach-zynq/Makefile       |    9 +-
 arch/arm/mach-zynq/Makefile.boot  |    3 -
 arch/arm/mach-zynq/common.c       |   71 +++-
 arch/arm/mach-zynq/common.h       |   18 +
 arch/arm/mach-zynq/pm.c           |  281 ++++++++++
 arch/arm/mach-zynq/slcr.c         |  149 +++++-
 arch/arm/mach-zynq/suspend.S      |  135 +++++
 arch/arm/mach-zynq/xaxipcie-msi.c |  186 +++++++
 arch/arm/mach-zynq/xaxipcie.c     | 1054 +++++++++++++++++++++++++++++++++++++
 arch/arm/mach-zynq/zynq_ocm.c     |  244 +++++++++
 11 files changed, 2168 insertions(+), 32 deletions(-)
 delete mode 100644 arch/arm/mach-zynq/Makefile.boot
 create mode 100644 arch/arm/mach-zynq/pm.c
 create mode 100644 arch/arm/mach-zynq/suspend.S
 create mode 100644 arch/arm/mach-zynq/xaxipcie-msi.c
 create mode 100644 arch/arm/mach-zynq/xaxipcie.c
 create mode 100644 arch/arm/mach-zynq/zynq_ocm.c

diff --git a/arch/arm/mach-zynq/Kconfig b/arch/arm/mach-zynq/Kconfig
index 6b04260..7bd55db 100644
--- a/arch/arm/mach-zynq/Kconfig
+++ b/arch/arm/mach-zynq/Kconfig
@@ -1,18 +1,54 @@
 config ARCH_ZYNQ
 	bool "Xilinx Zynq ARM Cortex A9 Platform" if ARCH_MULTI_V7
+	select ARCH_HAS_CPUFREQ
+	select ARCH_HAS_OPP
+	select ARCH_REQUIRE_GPIOLIB
 	select ARM_AMBA
 	select ARM_GIC
-	select COMMON_CLK
-	select CPU_V7
+	select ARM_GLOBAL_TIMER
+	select CACHE_L2X0
+	select CADENCE_TTC_TIMER
+	select GENERIC_ALLOCATOR
 	select GENERIC_CLOCKEVENTS
 	select HAVE_ARM_SCU if SMP
 	select HAVE_ARM_TWD if SMP
+	select HAVE_SMP
 	select ICST
+	select MFD_SYSCON
 	select MIGHT_HAVE_CACHE_L2X0
-	select USE_OF
-	select HAVE_SMP
-	select SPARSE_IRQ
-	select CADENCE_TTC_TIMER
-	select ARM_GLOBAL_TIMER
+	select MIGHT_HAVE_PCI
 	help
 	  Support for Xilinx Zynq ARM Cortex A9 Platform
+
+if ARCH_ZYNQ
+
+menu "Xilinx Specific Options"
+
+config XILINX_L1_PREFETCH
+	bool "L1 Cache Prefetch"
+	default y
+	help
+	  This option turns on L1 cache prefetching to get the best performance
+	  in many cases. This may not always be the best performance depending on
+	  the usage. There are some cases where this may cause issues when booting.
+
+config XILINX_L2_PREFETCH
+	bool "L2 Cache Prefetch"
+	default y
+	help
+	  This option turns on L2 cache prefetching to get the best performance
+	  in many cases. This may not always be the best performance depending on
+	  the usage.
+
+config XILINX_AXIPCIE
+	bool "Xilinx AXI PCIe host bridge support"
+	select PCI
+	select ARCH_SUPPORTS_MSI
+	help
+	  Say 'Y' here if you want kernel to support the Xilinx AXI PCIe
+	  Host Bridge. This supports Message Signal Interrupts (MSI), if you
+	  want to use this feature select CONFIG_PCI_MSI from 'Bus Support ->'.
+
+endmenu
+
+endif
diff --git a/arch/arm/mach-zynq/Makefile b/arch/arm/mach-zynq/Makefile
index 1b25d92..e5dfdbc 100644
--- a/arch/arm/mach-zynq/Makefile
+++ b/arch/arm/mach-zynq/Makefile
@@ -3,8 +3,15 @@
 #
 
 # Common support
-obj-y				:= common.o slcr.o
+obj-y				:= common.o slcr.o zynq_ocm.o
+
+obj-$(CONFIG_PCI_MSI)           += xaxipcie-msi.o
 CFLAGS_REMOVE_hotplug.o		=-march=armv6k
 CFLAGS_hotplug.o 		=-Wa,-march=armv7-a -mcpu=cortex-a9
 obj-$(CONFIG_HOTPLUG_CPU)	+= hotplug.o
 obj-$(CONFIG_SMP)		+= headsmp.o platsmp.o
+ORIG_AFLAGS := $(KBUILD_AFLAGS)
+KBUILD_AFLAGS = $(subst -march=armv6k,,$(ORIG_AFLAGS))
+AFLAGS_suspend.o 		+=-Wa,-march=armv7-a -mcpu=cortex-a9
+obj-$(CONFIG_SUSPEND)		+= pm.o suspend.o
+obj-$(CONFIG_XILINX_AXIPCIE)    += xaxipcie.o
diff --git a/arch/arm/mach-zynq/Makefile.boot b/arch/arm/mach-zynq/Makefile.boot
deleted file mode 100644
index 760a0ef..0000000
--- a/arch/arm/mach-zynq/Makefile.boot
+++ /dev/null
@@ -1,3 +0,0 @@
-   zreladdr-y	+= 0x00008000
-params_phys-y	:= 0x00000100
-initrd_phys-y	:= 0x00800000
diff --git a/arch/arm/mach-zynq/common.c b/arch/arm/mach-zynq/common.c
index 8c09a83..84e488b 100644
--- a/arch/arm/mach-zynq/common.c
+++ b/arch/arm/mach-zynq/common.c
@@ -16,9 +16,9 @@
 
 #include <linux/init.h>
 #include <linux/kernel.h>
-#include <linux/cpumask.h>
 #include <linux/platform_device.h>
 #include <linux/clk.h>
+#include <linux/clk-provider.h>
 #include <linux/clk/zynq.h>
 #include <linux/clocksource.h>
 #include <linux/of_address.h>
@@ -46,10 +46,17 @@ void __iomem *zynq_scu_base;
  * zynq_memory_init - Initialize special memory
  *
  * We need to stop things allocating the low memory as DMA can't work in
- * the 1st 512K of memory.
+ * the 1st 512K of memory.  Using reserve vs remove is not totally clear yet.
  */
 static void __init zynq_memory_init(void)
 {
+	/*
+	 * Reserve the 0-0x4000 addresses (before swapper page tables
+	 * and kernel) which can't be used for DMA.
+	 * 0x0 - 0x4000 - reserving below not to be used by DMA
+	 * 0x4000 - 0x8000 swapper page table
+	 * 0x8000 - 0x80000 kernel .text
+	 */
 	if (!__pa(PAGE_OFFSET))
 		memblock_reserve(__pa(PAGE_OFFSET), __pa(swapper_pg_dir));
 }
@@ -58,25 +65,74 @@ static struct platform_device zynq_cpuidle_device = {
 	.name = "cpuidle-zynq",
 };
 
+#ifdef CONFIG_CACHE_L2X0
+static int __init zynq_l2c_init(void)
+{
+	u32 auxctrl;
+
+	/*
+	 * 64KB way size, 8-way associativity, parity disabled,
+	 * prefetching option, shared attribute override enable
+	 */
+	auxctrl = L2X0_AUX_CTRL_SHARE_OVERRIDE_EN_MASK |
+			L2X0_AUX_CTRL_WAY_SIZE64K_MASK |
+			L2X0_AUX_CTRL_REPLACE_POLICY_RR_MASK;
+#ifdef CONFIG_XILINX_L2_PREFETCH
+	auxctrl |= L2X0_AUX_CTRL_EARLY_BRESP_EN_MASK |
+			L2X0_AUX_CTRL_INSTR_PREFETCH_EN_MASK |
+			L2X0_AUX_CTRL_DATA_PREFETCH_EN_MASK;
+#endif
+	return l2x0_of_init(auxctrl, 0xF0F0FFFF);
+}
+early_initcall(zynq_l2c_init);
+#endif
+
+
+#ifdef CONFIG_XILINX_L1_PREFETCH
+static void __init zynq_data_prefetch_enable(void *info)
+{
+	/*
+	 * Enable prefetching in aux control register. L2 prefetch must
+	 * only be enabled if the slave supports it (PL310 does)
+	 */
+	asm volatile ("mrc   p15, 0, r1, c1, c0, 1\n"
+		      "orr   r1, r1, #6\n"
+		      "mcr   p15, 0, r1, c1, c0, 1\n"
+		      : : : "r1");
+}
+#endif
+
+static void __init zynq_init_late(void)
+{
+	zynq_pm_late_init();
+
+#ifdef CONFIG_XILINX_L1_PREFETCH
+	on_each_cpu(zynq_data_prefetch_enable, NULL, 0);
+#endif
+}
+
 /**
  * zynq_init_machine - System specific initialization, intended to be
  *		       called from board specific initialization.
  */
 static void __init zynq_init_machine(void)
 {
-	/*
-	 * 64KB way size, 8-way associativity, parity disabled
-	 */
-	l2x0_of_init(0x02060000, 0xF0F0FFFF);
+	struct platform_device_info devinfo = { .name = "cpufreq-cpu0", };
 
 	of_platform_populate(NULL, of_default_bus_match_table, NULL, NULL);
 
 	platform_device_register(&zynq_cpuidle_device);
+	platform_device_register_full(&devinfo);
+
+	zynq_slcr_init();
 }
 
 static void __init zynq_timer_init(void)
 {
-	zynq_slcr_init();
+	zynq_early_slcr_init();
+
+	zynq_clock_init();
+	of_clk_init(NULL);
 	clocksource_of_init();
 }
 
@@ -128,6 +184,7 @@ DT_MACHINE_START(XILINX_EP107, "Xilinx Zynq Platform")
 	.map_io		= zynq_map_io,
 	.init_irq	= zynq_irq_init,
 	.init_machine	= zynq_init_machine,
+	.init_late	= zynq_init_late,
 	.init_time	= zynq_timer_init,
 	.dt_compat	= zynq_dt_match,
 	.reserve	= zynq_memory_init,
diff --git a/arch/arm/mach-zynq/common.h b/arch/arm/mach-zynq/common.h
index c22c92c..1a5a534 100644
--- a/arch/arm/mach-zynq/common.h
+++ b/arch/arm/mach-zynq/common.h
@@ -20,11 +20,14 @@
 void zynq_secondary_startup(void);
 
 extern int zynq_slcr_init(void);
+extern int zynq_early_slcr_init(void);
 extern void zynq_slcr_system_reset(void);
 extern void zynq_slcr_cpu_stop(int cpu);
 extern void zynq_slcr_cpu_start(int cpu);
+extern u32 zynq_slcr_get_ocm_config(void);
 
 #ifdef CONFIG_SMP
+extern void zynq_secondary_startup(void);
 extern void secondary_startup(void);
 extern char zynq_secondary_trampoline;
 extern char zynq_secondary_trampoline_jump;
@@ -33,10 +36,25 @@ extern int zynq_cpun_start(u32 address, int cpu);
 extern struct smp_operations zynq_smp_ops __initdata;
 #endif
 
+extern void zynq_slcr_init_preload_fpga(void);
+extern void zynq_slcr_init_postload_fpga(void);
+
 extern void __iomem *zynq_slcr_base;
 extern void __iomem *zynq_scu_base;
 
 /* Hotplug */
 extern void zynq_platform_cpu_die(unsigned int cpu);
 
+#ifdef CONFIG_SUSPEND
+int zynq_pm_late_init(void);
+#else
+static inline int zynq_pm_late_init(void)
+{
+	return 0;
+}
+#endif
+
+extern unsigned int zynq_sys_suspend_sz;
+int zynq_sys_suspend(void __iomem *ddrc_base, void __iomem *slcr_base);
+
 #endif
diff --git a/arch/arm/mach-zynq/pm.c b/arch/arm/mach-zynq/pm.c
new file mode 100644
index 0000000..1396d59
--- /dev/null
+++ b/arch/arm/mach-zynq/pm.c
@@ -0,0 +1,281 @@
+/*
+ * Suspend support for Zynq
+ *
+ *  Copyright (C) 2012 Xilinx
+ *
+ *  Soren Brinkmann <soren.brinkmann@xilinx.com>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <linux/bitops.h>
+#include <linux/clk.h>
+#include <linux/clk/zynq.h>
+#include <linux/err.h>
+#include <linux/genalloc.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/of_address.h>
+#include <linux/of_device.h>
+#include <linux/slab.h>
+#include <linux/suspend.h>
+#include <asm/cacheflush.h>
+#include <asm/hardware/cache-l2x0.h>
+#include <asm/mach/map.h>
+#include <asm/suspend.h>
+#include "common.h"
+
+#define DDRC_CTRL_REG1_OFFS		0x60
+#define DDRC_DRAM_PARAM_REG3_OFFS	0x20
+#define SCU_CTRL			0
+
+#define DDRC_CLOCKSTOP_MASK	BIT(23)
+#define DDRC_SELFREFRESH_MASK	BIT(12)
+#define SCU_STBY_EN_MASK	BIT(5)
+
+static void __iomem *ddrc_base;
+static void __iomem *ocm_base;
+
+static int zynq_pm_prepare_late(void)
+{
+	return zynq_clk_suspend_early();
+}
+
+static void zynq_pm_wake(void)
+{
+	zynq_clk_resume_late();
+}
+
+static int zynq_pm_suspend(unsigned long arg)
+{
+	u32 reg;
+	int (*zynq_suspend_ptr)(void __iomem *, void __iomem *);
+	int do_ddrpll_bypass = 1;
+
+	/* Enable DDR self-refresh and clock stop */
+	if (ddrc_base) {
+		reg = readl(ddrc_base + DDRC_CTRL_REG1_OFFS);
+		reg |= DDRC_SELFREFRESH_MASK;
+		writel(reg, ddrc_base + DDRC_CTRL_REG1_OFFS);
+
+		reg = readl(ddrc_base + DDRC_DRAM_PARAM_REG3_OFFS);
+		reg |= DDRC_CLOCKSTOP_MASK;
+		writel(reg, ddrc_base + DDRC_DRAM_PARAM_REG3_OFFS);
+	} else {
+		do_ddrpll_bypass = 0;
+	}
+
+	/* SCU standby mode */
+	if (zynq_scu_base) {
+		reg = readl(zynq_scu_base + SCU_CTRL);
+		reg |= SCU_STBY_EN_MASK;
+		writel(reg, zynq_scu_base + SCU_CTRL);
+	}
+
+	/* Topswitch clock stop disable */
+	zynq_clk_topswitch_disable();
+
+	/* A9 clock gating */
+	asm volatile ("mrc  p15, 0, r12, c15, c0, 0\n"
+		      "orr  r12, r12, #1\n"
+		      "mcr  p15, 0, r12, c15, c0, 0\n"
+		      : /* no outputs */
+		      : /* no inputs */
+		      : "r12");
+
+	if (ocm_base) {
+		/*
+		 * Copy code to suspend system into OCM. The suspend code
+		 * needs to run from OCM as DRAM may no longer be available
+		 * when the PLL is stopped.
+		 */
+		memcpy((__force void *)ocm_base, &zynq_sys_suspend,
+			zynq_sys_suspend_sz);
+		flush_icache_range((unsigned long)ocm_base,
+			(unsigned long)(ocm_base) + zynq_sys_suspend_sz);
+		zynq_suspend_ptr = (__force void *)ocm_base;
+	} else {
+		do_ddrpll_bypass = 0;
+	}
+
+	/* Transfer to suspend code in OCM */
+	if (do_ddrpll_bypass) {
+		/*
+		 * Going this way will turn off DDR related clocks and the DDR
+		 * PLL. I.e. We might brake sub systems relying on any of this
+		 * clocks. And even worse: If there are any other masters in the
+		 * system (e.g. in the PL) accessing DDR they are screwed.
+		 */
+		flush_cache_all();
+		if (zynq_suspend_ptr(ddrc_base, zynq_slcr_base))
+			pr_warn("DDR self refresh failed.\n");
+	} else {
+		WARN_ONCE(1, "DRAM self-refresh not available\n");
+		cpu_do_idle();
+	}
+
+	/* Topswitch clock stop enable */
+	zynq_clk_topswitch_enable();
+
+	/* SCU standby mode */
+	if (zynq_scu_base) {
+		reg = readl(zynq_scu_base + SCU_CTRL);
+		reg &= ~SCU_STBY_EN_MASK;
+		writel(reg, zynq_scu_base + SCU_CTRL);
+	}
+
+	/* A9 clock gating */
+	asm volatile ("mrc  p15, 0, r12, c15, c0, 0\n"
+		      "bic  r12, r12, #1\n"
+		      "mcr  p15, 0, r12, c15, c0, 0\n"
+		      : /* no outputs */
+		      : /* no inputs */
+		      : "r12");
+
+	/* Disable DDR self-refresh and clock stop */
+	if (ddrc_base) {
+		reg = readl(ddrc_base + DDRC_CTRL_REG1_OFFS);
+		reg &= ~DDRC_SELFREFRESH_MASK;
+		writel(reg, ddrc_base + DDRC_CTRL_REG1_OFFS);
+
+		reg = readl(ddrc_base + DDRC_DRAM_PARAM_REG3_OFFS);
+		reg &= ~DDRC_CLOCKSTOP_MASK;
+		writel(reg, ddrc_base + DDRC_DRAM_PARAM_REG3_OFFS);
+	}
+
+	return 0;
+}
+
+static int zynq_pm_enter(suspend_state_t suspend_state)
+{
+	switch (suspend_state) {
+	case PM_SUSPEND_STANDBY:
+	case PM_SUSPEND_MEM:
+		outer_disable();
+		cpu_suspend(0, zynq_pm_suspend);
+		outer_resume();
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static const struct platform_suspend_ops zynq_pm_ops = {
+	.prepare_late	= zynq_pm_prepare_late,
+	.enter		= zynq_pm_enter,
+	.wake		= zynq_pm_wake,
+	.valid		= suspend_valid_only_mem,
+};
+
+/**
+ * zynq_pm_ioremap() - Create IO mappings
+ * @comp:	DT compatible string
+ * Returns a pointer to the mapped memory or NULL.
+ *
+ * Remap the memory region for a compatible DT node.
+ */
+static void __iomem *zynq_pm_ioremap(const char *comp)
+{
+	struct device_node *np;
+	void __iomem *base = NULL;
+
+	np = of_find_compatible_node(NULL, NULL, comp);
+	if (np) {
+		base = of_iomap(np, 0);
+		of_node_put(np);
+	} else {
+		pr_warn("%s: no compatible node found for '%s'\n", __func__,
+				comp);
+	}
+
+	return base;
+}
+
+/**
+ * zynq_pm_remap_ocm() - Remap OCM
+ * Returns a pointer to the mapped memory or NULL.
+ *
+ * Remap the OCM.
+ */
+static void __iomem *zynq_pm_remap_ocm(void)
+{
+	struct device_node *np;
+	const char *comp = "xlnx,zynq-ocmc-1.0";
+	void __iomem *base = NULL;
+
+	np = of_find_compatible_node(NULL, NULL, comp);
+	if (np) {
+		struct device *dev;
+		unsigned long pool_addr;
+		unsigned long pool_addr_virt;
+		struct gen_pool *pool;
+
+		of_node_put(np);
+
+		dev = &(of_find_device_by_node(np)->dev);
+
+		/* Get OCM pool from device tree or platform data */
+		pool = dev_get_gen_pool(dev);
+		if (!pool) {
+			pr_warn("%s: OCM pool is not available\n", __func__);
+			return NULL;
+		}
+
+		pool_addr_virt = gen_pool_alloc(pool, zynq_sys_suspend_sz);
+		if (!pool_addr_virt) {
+			pr_warn("%s: Can't get OCM poll\n", __func__);
+			return NULL;
+		}
+		pool_addr = gen_pool_virt_to_phys(pool, pool_addr_virt);
+		if (!pool_addr) {
+			pr_warn("%s: Can't get physical address of OCM pool\n",
+				__func__);
+			return NULL;
+		}
+		base = __arm_ioremap(pool_addr, zynq_sys_suspend_sz,
+				     MT_MEMORY_RWX);
+		if (!base) {
+			pr_warn("%s: IOremap OCM pool failed\n", __func__);
+			return NULL;
+		}
+		pr_debug("%s: Remap OCM %s from %lx to %lx\n", __func__, comp,
+			 pool_addr_virt, (unsigned long)base);
+	} else {
+		pr_warn("%s: no compatible node found for '%s'\n", __func__,
+				comp);
+	}
+
+	return base;
+}
+
+int __init zynq_pm_late_init(void)
+{
+	ddrc_base = zynq_pm_ioremap("xlnx,zynq-ddrc-1.0");
+	if (!ddrc_base)
+		pr_warn("%s: Unable to map DDRC IO memory.\n", __func__);
+
+	/*
+	 * FIXME: should be done by an ocm driver which then provides allocators
+	 */
+	ocm_base = zynq_pm_remap_ocm();
+	if (!ocm_base)
+		pr_warn("%s: Unable to map OCM.\n", __func__);
+
+	suspend_set_ops(&zynq_pm_ops);
+
+	return 0;
+}
diff --git a/arch/arm/mach-zynq/slcr.c b/arch/arm/mach-zynq/slcr.c
index 1836d5a..6e72a85 100644
--- a/arch/arm/mach-zynq/slcr.c
+++ b/arch/arm/mach-zynq/slcr.c
@@ -15,21 +15,77 @@
  */
 
 #include <linux/io.h>
+#include <linux/module.h>
+#include <linux/mfd/syscon.h>
 #include <linux/of_address.h>
+#include <linux/regmap.h>
 #include <linux/clk/zynq.h>
 #include "common.h"
 
 /* register offsets */
 #define SLCR_UNLOCK_OFFSET		0x8   /* SCLR unlock register */
+
 #define SLCR_PS_RST_CTRL_OFFSET		0x200 /* PS Software Reset Control */
+#define SLCR_FPGA_RST_CTRL_OFFSET	0x240 /* FPGA Software Reset Control */
 #define SLCR_A9_CPU_RST_CTRL_OFFSET	0x244 /* CPU Software Reset Control */
 #define SLCR_REBOOT_STATUS_OFFSET	0x258 /* PS Reboot Status */
+#define SLCR_LVL_SHFTR_EN_OFFSET	0x900 /* Level Shifters Enable */
+#define SLCR_OCM_CFG_OFFSET		0x910 /* OCM Address Mapping */
 
 #define SLCR_UNLOCK_MAGIC		0xDF0D
 #define SLCR_A9_CPU_CLKSTOP		0x10
 #define SLCR_A9_CPU_RST			0x1
 
 void __iomem *zynq_slcr_base;
+static struct regmap *zynq_slcr_regmap;
+
+/**
+ * zynq_slcr_write - Write to a register in SLCR block
+ *
+ * @val:	Value to write to the register
+ * @offset:	Register offset in SLCR block
+ *
+ * Return:	a negative value on error, 0 on success
+ */
+static int zynq_slcr_write(u32 val, u32 offset)
+{
+	if (!zynq_slcr_regmap) {
+		writel(val, zynq_slcr_base + offset);
+		return 0;
+	}
+
+	return regmap_write(zynq_slcr_regmap, offset, val);
+}
+
+/**
+ * zynq_slcr_read - Read a register in SLCR block
+ *
+ * @val:	Pointer to value to be read from SLCR
+ * @offset:	Register offset in SLCR block
+ *
+ * Return:	a negative value on error, 0 on success
+ */
+static int zynq_slcr_read(u32 *val, u32 offset)
+{
+	if (zynq_slcr_regmap)
+		return regmap_read(zynq_slcr_regmap, offset, val);
+
+	*val = readl(zynq_slcr_base + offset);
+
+	return 0;
+}
+
+/**
+ * zynq_slcr_unlock - Unlock SLCR registers
+ *
+ * Return:	a negative value on error, 0 on success
+ */
+static inline int zynq_slcr_unlock(void)
+{
+	zynq_slcr_write(SLCR_UNLOCK_MAGIC, SLCR_UNLOCK_OFFSET);
+
+	return 0;
+}
 
 /**
  * zynq_slcr_system_reset - Reset the entire system.
@@ -43,29 +99,73 @@ void zynq_slcr_system_reset(void)
 	 * Note that this seems to require raw i/o
 	 * functions or there's a lockup?
 	 */
-	writel(SLCR_UNLOCK_MAGIC, zynq_slcr_base + SLCR_UNLOCK_OFFSET);
+	zynq_slcr_unlock();
 
 	/*
 	 * Clear 0x0F000000 bits of reboot status register to workaround
 	 * the FSBL not loading the bitstream after soft-reboot
 	 * This is a temporary solution until we know more.
 	 */
-	reboot = readl(zynq_slcr_base + SLCR_REBOOT_STATUS_OFFSET);
-	writel(reboot & 0xF0FFFFFF, zynq_slcr_base + SLCR_REBOOT_STATUS_OFFSET);
-	writel(1, zynq_slcr_base + SLCR_PS_RST_CTRL_OFFSET);
+	zynq_slcr_read(&reboot, SLCR_REBOOT_STATUS_OFFSET);
+	zynq_slcr_write(reboot & 0xF0FFFFFF, SLCR_REBOOT_STATUS_OFFSET);
+	zynq_slcr_write(1, SLCR_PS_RST_CTRL_OFFSET);
 }
 
 /**
+ * zynq_slcr_get_ocm_config - Get SLCR OCM config
+ *
+ * return:	OCM config bits
+ */
+u32 zynq_slcr_get_ocm_config(void)
+{
+	u32 ret;
+
+	zynq_slcr_read(&ret, SLCR_OCM_CFG_OFFSET);
+	return ret;
+}
+
+/**
+ * zynq_slcr_init_preload_fpga - Disable communication from the PL to PS.
+ */
+void zynq_slcr_init_preload_fpga(void)
+{
+	/* Assert FPGA top level output resets */
+	zynq_slcr_write(0xF, SLCR_FPGA_RST_CTRL_OFFSET);
+
+	/* Disable level shifters */
+	zynq_slcr_write(0, SLCR_LVL_SHFTR_EN_OFFSET);
+
+	/* Enable output level shifters */
+	zynq_slcr_write(0xA, SLCR_LVL_SHFTR_EN_OFFSET);
+}
+EXPORT_SYMBOL(zynq_slcr_init_preload_fpga);
+
+/**
+ * zynq_slcr_init_postload_fpga - Re-enable communication from the PL to PS.
+ */
+void zynq_slcr_init_postload_fpga(void)
+{
+	/* Enable level shifters */
+	zynq_slcr_write(0xf, SLCR_LVL_SHFTR_EN_OFFSET);
+
+	/* Deassert AXI interface resets */
+	zynq_slcr_write(0, SLCR_FPGA_RST_CTRL_OFFSET);
+}
+EXPORT_SYMBOL(zynq_slcr_init_postload_fpga);
+
+/**
  * zynq_slcr_cpu_start - Start cpu
  * @cpu:	cpu number
  */
 void zynq_slcr_cpu_start(int cpu)
 {
-	u32 reg = readl(zynq_slcr_base + SLCR_A9_CPU_RST_CTRL_OFFSET);
+	u32 reg;
+
+	zynq_slcr_read(&reg, SLCR_A9_CPU_RST_CTRL_OFFSET);
 	reg &= ~(SLCR_A9_CPU_RST << cpu);
-	writel(reg, zynq_slcr_base + SLCR_A9_CPU_RST_CTRL_OFFSET);
+	zynq_slcr_write(reg, SLCR_A9_CPU_RST_CTRL_OFFSET);
 	reg &= ~(SLCR_A9_CPU_CLKSTOP << cpu);
-	writel(reg, zynq_slcr_base + SLCR_A9_CPU_RST_CTRL_OFFSET);
+	zynq_slcr_write(reg, SLCR_A9_CPU_RST_CTRL_OFFSET);
 }
 
 /**
@@ -74,19 +174,40 @@ void zynq_slcr_cpu_start(int cpu)
  */
 void zynq_slcr_cpu_stop(int cpu)
 {
-	u32 reg = readl(zynq_slcr_base + SLCR_A9_CPU_RST_CTRL_OFFSET);
+	u32 reg;
+
+	zynq_slcr_read(&reg, SLCR_A9_CPU_RST_CTRL_OFFSET);
 	reg |= (SLCR_A9_CPU_CLKSTOP | SLCR_A9_CPU_RST) << cpu;
-	writel(reg, zynq_slcr_base + SLCR_A9_CPU_RST_CTRL_OFFSET);
+	zynq_slcr_write(reg, SLCR_A9_CPU_RST_CTRL_OFFSET);
 }
 
 /**
- * zynq_slcr_init
- * Returns 0 on success, negative errno otherwise.
+ * zynq_slcr_init - Regular slcr driver init
+ *
+ * Return:	0 on success, negative errno otherwise.
  *
  * Called early during boot from platform code to remap SLCR area.
  */
 int __init zynq_slcr_init(void)
 {
+	zynq_slcr_regmap = syscon_regmap_lookup_by_compatible("xlnx,zynq-slcr");
+	if (IS_ERR(zynq_slcr_regmap)) {
+		pr_err("%s: failed to find zynq-slcr\n", __func__);
+		return -ENODEV;
+	}
+
+	return 0;
+}
+
+/**
+ * zynq_early_slcr_init - Early slcr init function
+ *
+ * Return:	0 on success, negative errno otherwise.
+ *
+ * Called very early during boot from platform code to unlock SLCR.
+ */
+int __init zynq_early_slcr_init(void)
+{
 	struct device_node *np;
 
 	np = of_find_compatible_node(NULL, NULL, "xlnx,zynq-slcr");
@@ -101,13 +222,13 @@ int __init zynq_slcr_init(void)
 		BUG();
 	}
 
+	np->data = (__force void *)zynq_slcr_base;
+
 	/* unlock the SLCR so that registers can be changed */
-	writel(SLCR_UNLOCK_MAGIC, zynq_slcr_base + SLCR_UNLOCK_OFFSET);
+	zynq_slcr_unlock();
 
 	pr_info("%s mapped to %p\n", np->name, zynq_slcr_base);
 
-	zynq_clock_init(zynq_slcr_base);
-
 	of_node_put(np);
 
 	return 0;
diff --git a/arch/arm/mach-zynq/suspend.S b/arch/arm/mach-zynq/suspend.S
new file mode 100644
index 0000000..a632f47
--- /dev/null
+++ b/arch/arm/mach-zynq/suspend.S
@@ -0,0 +1,135 @@
+/*
+ * Suspend support for Zynq
+ *
+ *  Copyright (C) 2012 Xilinx
+ *
+ *  Soren Brinkmann <soren.brinkmann@xilinx.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/linkage.h>
+
+#define DDRPLL_CTRL_OFFS	0x104
+#define PLLSTATUS_OFFS		0x10c
+#define DDR_CLK_CTRL_OFFS	0x124
+#define DCI_CLK_CTRL_OFFS	0x128
+#define DDR_CMD_STA_OFFS	0x618
+#define MODE_STS_OFFS		0x54
+
+#define PLL_RESET_MASK		1
+#define PLL_PWRDWN_MASK		(1 << 1)
+#define PLL_BYPASS_MASK		(1 << 4)
+#define DCICLK_ENABLE_MASK	1
+#define DDRCLK_ENABLE_MASK	3
+#define DDR_LOCK_MASK		(1 << 1)
+#define DDR_STATUS_MASK		7
+
+#define DDR_OPMODE_SR		3
+#define MAXTRIES		100
+
+	.text
+
+/**
+ * zynq_sys_suspend - Enter suspend
+ * @ddrc_base:	Base address of the DDRC
+ * @slcr_base:	Base address of the SLCR
+ * Returns -1 if DRAM subsystem is not gated off, 0 otherwise.
+ *
+ * This function is moved into OCM and finishes the suspend operation. I.e. DDR
+ * related clocks are gated off and the DDR PLL is bypassed.
+ */
+ENTRY(zynq_sys_suspend)
+	dsb
+	/* Check DDRC is in self-refresh mode */
+	ldr	r2, [r0, #MODE_STS_OFFS]
+	and	r2, #DDR_STATUS_MASK
+	cmp	r2, #DDR_OPMODE_SR
+	movweq	r3, #0xff00
+	bne	suspend
+
+	mov	r3, #0
+	/* Wait for command queue empty */
+1:	cmp	r3, #MAXTRIES
+	movweq	r3, #0xff00
+	beq	suspend
+	ldr	r2, [r1, #DDR_CMD_STA_OFFS]
+	cmp	r2, #0
+	addne	r3, #1
+	bne	1b
+
+	dsb
+
+	/* Stop DDR clocks */
+	ldr	r2, [r1, #DDR_CLK_CTRL_OFFS]
+	bic	r2, #DDRCLK_ENABLE_MASK
+	str	r2, [r1, #DDR_CLK_CTRL_OFFS]
+
+	dmb
+
+	ldr	r2, [r1, #DCI_CLK_CTRL_OFFS]
+	bic	r2, #DCICLK_ENABLE_MASK
+	str	r2, [r1, #DCI_CLK_CTRL_OFFS]
+
+	dmb
+
+	/* Bypass and powerdown DDR PLL */
+	ldr	r2, [r1, #DDRPLL_CTRL_OFFS]
+	orr	r2, #PLL_BYPASS_MASK
+	str	r2, [r1, #DDRPLL_CTRL_OFFS]
+	orr	r2, #(PLL_PWRDWN_MASK | PLL_RESET_MASK)
+	str	r2, [r1, #DDRPLL_CTRL_OFFS]
+
+suspend:
+	wfi
+	dsb
+	cmp	r3, #0xff00
+	moveq	r0, #-1
+	beq	exit
+
+	/* Power up DDR PLL */
+	ldr	r2, [r1, #DDRPLL_CTRL_OFFS]
+	bic	r2, #(PLL_PWRDWN_MASK | PLL_RESET_MASK)
+	str	r2, [r1, #DDRPLL_CTRL_OFFS]
+	/* wait for lock */
+1:	ldr	r2, [r1, #PLLSTATUS_OFFS]
+	and	r2, #DDR_LOCK_MASK
+	cmp	r2, #0
+	beq	1b
+
+	dsb
+
+	/* Disable PLL bypass */
+	ldr	r2, [r1, #DDRPLL_CTRL_OFFS]
+	bic	r2, #PLL_BYPASS_MASK
+	str	r2, [r1, #DDRPLL_CTRL_OFFS]
+
+	dmb
+
+	/* Start DDR clocks */
+	ldr	r2, [r1, #DCI_CLK_CTRL_OFFS]
+	orr	r2, #DCICLK_ENABLE_MASK
+	str	r2, [r1, #DCI_CLK_CTRL_OFFS]
+
+	dmb
+
+	ldr	r2, [r1, #DDR_CLK_CTRL_OFFS]
+	orr	r2, #DDRCLK_ENABLE_MASK
+	str	r2, [r1, #DDR_CLK_CTRL_OFFS]
+
+	dsb
+
+	mov	r0, #0
+exit:	bx	lr
+
+ENTRY(zynq_sys_suspend_sz)
+	.word	. - zynq_sys_suspend
+
+	ENDPROC(zynq_sys_suspend)
diff --git a/arch/arm/mach-zynq/xaxipcie-msi.c b/arch/arm/mach-zynq/xaxipcie-msi.c
new file mode 100644
index 0000000..43500e0
--- /dev/null
+++ b/arch/arm/mach-zynq/xaxipcie-msi.c
@@ -0,0 +1,186 @@
+/*
+ * Xilinx PCIe IP hardware MSI initialisation
+ *
+ * Copyright (c) 2012 Xilinx, Inc.
+ *
+ * This program has adopted some work from PCI/PCIE support for AMCC
+ * PowerPC boards written by Benjamin Herrenschmidt.
+ * Copyright 2007 Ben. Herrenschmidt <benh@kernel.crashing.org>, IBM Corp.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+
+#include <linux/msi.h>
+#include <linux/irq.h>
+#include <linux/irqdomain.h>
+#include <linux/module.h>
+
+#define XILINX_NUM_MSI_IRQS	128
+
+static DECLARE_BITMAP(msi_irq_in_use, XILINX_NUM_MSI_IRQS);
+
+static unsigned long xaxipcie_msg_addr;
+static struct irq_domain *xaxipcie_irq_domain;
+static int xaxipcie_msi_irq_base;
+
+/* Dynamic irq allocate and deallocation */
+
+/**
+ * create_irq- Dynamic irq allocate
+ * void
+ *
+ * @return: Interrupt number allocated/ error
+ *
+ * @note: None
+ */
+int create_irq(void)
+{
+	int irq, pos;
+again:
+	pos = find_first_zero_bit(msi_irq_in_use, XILINX_NUM_MSI_IRQS);
+
+	irq = irq_find_mapping(xaxipcie_irq_domain, pos);
+
+	/* test_and_set_bit operates on 32-bits at a time */
+	if (test_and_set_bit(pos, msi_irq_in_use))
+		goto again;
+
+	dynamic_irq_init(irq);
+	set_irq_flags(irq, IRQF_VALID);
+
+	return irq;
+}
+
+/**
+ * destroy_irq- Dynamic irq de-allocate
+ * @irq: Interrupt number to de-allocate
+ *
+ * @return: None
+ *
+ * @note: None
+ */
+void destroy_irq(unsigned int irq)
+{
+	int pos = irq - xaxipcie_msi_irq_base;
+
+	dynamic_irq_cleanup(irq);
+
+	clear_bit(pos, msi_irq_in_use);
+}
+
+/**
+ * arch_teardown_msi_irq-Teardown the Interrupt
+ * @irq: Interrupt number to teardown
+ *
+ * @return: None
+ *
+ * @note: This function  is called when pci_disable_msi is called
+ */
+void arch_teardown_msi_irq(unsigned int irq)
+{
+	destroy_irq(irq);
+}
+
+/**
+ * xilinx_msi_nop-No operation handler
+ * @irq: Interrupt number
+ *
+ * @return: None
+ *
+ * @note: None
+ */
+static void xilinx_msi_nop(struct irq_data *d)
+{
+	return;
+}
+
+static struct irq_chip xilinx_msi_chip = {
+		.name = "PCIe-MSI",
+		.irq_ack = xilinx_msi_nop,
+		.irq_enable = unmask_msi_irq,
+		.irq_disable = mask_msi_irq,
+		.irq_mask = mask_msi_irq,
+		.irq_unmask = unmask_msi_irq,
+};
+
+/**
+ * arch_setup_msi_irq-Setup MSI interrupt
+ * @pdev: Pointer to current pci device structure
+ * @desc: Pointer to MSI description structure
+ *
+ * @return: Error/ no-error
+ *
+ * @note: This function  is called when pci_enable_msi is called
+ */
+int arch_setup_msi_irq(struct pci_dev *pdev, struct msi_desc *desc)
+{
+	int irq = create_irq();
+	struct msi_msg msg;
+
+	if (irq < 0)
+		return irq;
+
+	irq_set_msi_desc(irq, desc);
+
+	msg.address_hi = 0x00000000;
+	msg.address_lo = xaxipcie_msg_addr;
+	msg.data = irq;
+
+	pr_debug("irq %d addr_hi %08x low %08x data %08x\n",
+			irq, msg.address_hi, msg.address_lo, msg.data);
+
+	write_msi_msg(irq, &msg);
+
+	irq_set_chip_and_handler(irq, &xilinx_msi_chip, handle_simple_irq);
+
+	return 0;
+}
+
+
+/**
+ * xaxipcie_alloc_msi_irqdescs - allocate msi irq descs
+ * @node: Pointer to device node structure
+ * @msg_addr: PCIe MSI message address
+ *
+ * @return: Allocated MSI IRQ Base/ error
+ *
+ * @note: This function is called when xaxipcie_init_port() is called
+ */
+int xaxipcie_alloc_msi_irqdescs(struct device_node *node,
+					unsigned long msg_addr)
+{
+	/* Store the PCIe MSI message address */
+	xaxipcie_msg_addr = msg_addr;
+
+	/* Allocate MSI IRQ descriptors */
+	xaxipcie_msi_irq_base = irq_alloc_descs(-1, 0,
+					XILINX_NUM_MSI_IRQS, 0);
+
+	if (xaxipcie_msi_irq_base < 0)
+		return -ENODEV;
+
+	/* Register IRQ domain */
+	xaxipcie_irq_domain = irq_domain_add_legacy(node,
+				XILINX_NUM_MSI_IRQS,
+				xaxipcie_msi_irq_base,
+				0, &irq_domain_simple_ops, NULL);
+
+	if (!xaxipcie_irq_domain)
+		return -ENOMEM;
+
+	return xaxipcie_msi_irq_base;
+}
+EXPORT_SYMBOL(xaxipcie_alloc_msi_irqdescs);
diff --git a/arch/arm/mach-zynq/xaxipcie.c b/arch/arm/mach-zynq/xaxipcie.c
new file mode 100644
index 0000000..8926d89
--- /dev/null
+++ b/arch/arm/mach-zynq/xaxipcie.c
@@ -0,0 +1,1054 @@
+/*
+ * Xilinx AXI PCIe IP hardware initialation, setup and
+ * configuration spaces access file.
+ *
+ * Copyright (c) 2012 Xilinx, Inc.
+ *
+ * This program has adopted some work from PCI/PCIE support for AMCC
+ * PowerPC boards written by Benjamin Herrenschmidt.
+ * Copyright 2007 Ben. Herrenschmidt <benh@kernel.crashing.org>, IBM Corp.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/kernel.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/export.h>
+#include <linux/of_address.h>
+#include <linux/of.h>
+#include <linux/of_irq.h>
+#include <linux/init.h>
+#include <linux/bootmem.h>
+#include <linux/io.h>
+#include <linux/slab.h>
+#include <linux/sizes.h>
+#include <linux/irqdomain.h>
+#include <linux/pci.h>
+#include <asm/mach/pci.h>
+
+/* Register definitions */
+#define PCIE_CFG_CMD			0x00000004
+#define PCIE_CFG_CLS			0x00000008
+#define PCIE_CFG_HDR			0x0000000C
+#define PCIE_CFG_AD1			0x00000010
+#define PCIE_CFG_AD2			0x00000014
+#define PCIE_CFG_BUS			0x00000018
+#define PCIE_CFG_IO			0x0000001C
+#define PCIE_CFG_MEM			0x00000020
+#define PCIE_CFG_PREF_MEM		0x00000024
+#define PCIE_CFG_PREF_BASE_UPPER	0x00000028
+#define PCIE_CFG_PREF_LIMIT_UPPER	0x0000002c
+#define PCIE_CFG_IO_UPPER		0x00000030
+
+#define XAXIPCIE_REG_VSECC		0x00000128
+#define XAXIPCIE_REG_VSECH		0x0000012c
+#define XAXIPCIE_REG_BIR		0x00000130
+#define XAXIPCIE_REG_BSCR		0x00000134
+#define XAXIPCIE_REG_IDR		0x00000138
+#define XAXIPCIE_REG_IMR		0x0000013c
+#define XAXIPCIE_REG_BLR		0x00000140
+#define XAXIPCIE_REG_PSCR		0x00000144
+#define XAXIPCIE_REG_RPSC		0x00000148
+#define XAXIPCIE_REG_MSIBASE1		0x0000014c
+#define XAXIPCIE_REG_MSIBASE2		0x00000150
+#define XAXIPCIE_REG_RPEFR		0x00000154
+#define XAXIPCIE_REG_RPIFR1		0x00000158
+#define XAXIPCIE_REG_RPIFR2		0x0000015c
+#define XAXIPCIE_REG_VSECC2		0x00000200
+#define XAXIPCIE_REG_VSECH2		0x00000204
+
+/* Interrupt register defines */
+#define XAXIPCIE_INTR_LINK_DOWN		(1 << 0)
+#define XAXIPCIE_INTR_ECRC_ERR		(1 << 1)
+#define XAXIPCIE_INTR_STR_ERR		(1 << 2)
+#define XAXIPCIE_INTR_HOT_RESET		(1 << 3)
+#define XAXIPCIE_INTR_CFG_COMPL		(7 << 5)
+#define XAXIPCIE_INTR_CFG_TIMEOUT	(1 << 8)
+#define XAXIPCIE_INTR_CORRECTABLE	(1 << 9)
+#define XAXIPCIE_INTR_NONFATAL		(1 << 10)
+#define XAXIPCIE_INTR_FATAL		(1 << 11)
+#define XAXIPCIE_INTR_INTX		(1 << 16)
+#define XAXIPCIE_INTR_MSI		(1 << 17)
+#define XAXIPCIE_INTR_SLV_UNSUPP	(1 << 20)
+#define XAXIPCIE_INTR_SLV_UNEXP		(1 << 21)
+#define XAXIPCIE_INTR_SLV_COMPL		(1 << 22)
+#define XAXIPCIE_INTR_SLV_ERRP		(1 << 23)
+#define XAXIPCIE_INTR_SLV_CMPABT	(1 << 24)
+#define XAXIPCIE_INTR_SLV_ILLBUR	(1 << 25)
+#define XAXIPCIE_INTR_MST_DECERR	(1 << 26)
+#define XAXIPCIE_INTR_MST_SLVERR	(1 << 27)
+#define XAXIPCIE_INTR_MST_ERRP		(1 << 28)
+
+#define BUS_LOC_SHIFT			20
+#define DEV_LOC_SHIFT			12
+#define PRIMARY_BUS			1
+#define PORT_REG_SIZE			0x1000
+#define PORT_HEADER_SIZE		0x128
+
+#define XAXIPCIE_LOCAL_CNFG_BASE	0x00000000
+#define XAXIPCIE_REG_BASE		0x00000128
+#define XAXIPCIE_REG_PSCR_LNKUP		0x00000800
+#define XAXIPCIE_REG_IMR_MASKALL	0x1FF30FED
+#define XAXIPCIE_REG_IDR_MASKALL	0xFFFFFFFF
+#define XAXIPCIE_REG_RPSC_BEN		0x00000001
+#define BUS_MASTER_ENABLE		0x00000004
+
+#define XAXIPCIE_ACCESS8	1
+#define XAXIPCIE_ACCESS16	2
+
+#define XAXIPCIE_MEM_SPACE	2
+#define XAXIPCIE_MEM_SPACE64	3
+
+/* Config structure for PCIe */
+struct xaxi_pcie_of_config {
+	u32 num_instances;
+	u32 device_id;
+	u32 device_type;
+	u32 ecam_base;
+	u32 ecam_high;
+	u32 baseaddr;
+	u32 highaddr;
+	u32 bars_num;
+	u32 irq_num;
+	u32 reg_base;
+	u32 reg_len;
+	u32 pcie2axibar_0;
+	u32 pcie2axibar_1;
+	const __be32 *ranges;
+	int range_len;
+	u32 address_cells;
+};
+
+/* PCIe Root Port Structure */
+struct xaxi_pcie_port {
+	struct device_node *node;
+	u32 reg_base;
+	u32 reg_len;
+	u32 ecam_base;
+	u32 ecam_high;
+	u32 baseaddr;
+	u32 highaddr;
+	u32 header_addr;
+	u8 index;
+	u8 type;
+	u8 link_up;
+	u8 bars_num;
+	u32 irq_num;
+	const __be32 *ranges;
+	int range_len;
+	u32 pna;
+	u8 __iomem *base_addr_remap;
+	u8 __iomem *header_remap;
+	u8 __iomem *ecam_remap;
+	u32 pcie2axibar_0;
+	u32 pcie2axibar_1;
+	u32 root_bus_nr;
+	u32 first_busno;
+	u32 last_busno;
+	resource_size_t isa_mem_phys;
+	resource_size_t isa_mem_size;
+	resource_size_t pci_mem_offset;
+	struct resource io_resource;
+	struct resource mem_resources[3];
+	char mem_space_name[16];
+};
+
+static struct xaxi_pcie_port *xaxi_pcie_ports;
+static int xaxi_pcie_port_cnt;
+static int last_bus_on_record;
+
+/* ISA Memory physical address */
+static resource_size_t isa_mem_base;
+
+#ifdef CONFIG_PCI_MSI
+static int xaxipcie_msi_irq_base;
+
+int xaxipcie_alloc_msi_irqdescs(struct device_node *node,
+				unsigned long msg_addr);
+#endif
+
+/* Macros */
+#define is_link_up(base_address)	\
+	((readl(base_address + XAXIPCIE_REG_PSCR) &	\
+	XAXIPCIE_REG_PSCR_LNKUP) ? 1 : 0)
+
+#define bridge_enable(base_address)	\
+	writel((readl(base_address + XAXIPCIE_REG_RPSC) |	\
+		XAXIPCIE_REG_RPSC_BEN), \
+		(base_address + XAXIPCIE_REG_RPSC))
+
+/**
+ * xaxi_pcie_verify_config
+ * @port: A pointer to a pcie port that needs to be handled
+ * @bus: Bus structure of current bus
+ * @devfun: device/function
+ *
+ * @return: Error / no error
+ *
+ * @note: Make sure we can handle this configuration call on our
+ *        device.
+ */
+static int xaxi_pcie_verify_config(struct xaxi_pcie_port *port,
+				struct pci_bus *bus,
+				unsigned int devfn)
+{
+	static int message;
+
+	/* Endpoint can not generate upstream(remote) config cycles */
+	if ((!port->type) && bus->number != port->first_busno)
+		return PCIBIOS_DEVICE_NOT_FOUND;
+
+	/* Check we are within the mapped range */
+	if (bus->number > port->last_busno) {
+		if (!message) {
+			pr_warn("Warning! Probing bus %u out of range !\n",
+				bus->number);
+			message++;
+		}
+		return PCIBIOS_DEVICE_NOT_FOUND;
+	}
+
+	/* The other side of the RC has only one device as well */
+	if (bus->number == (port->first_busno + 1) &&
+		PCI_SLOT(devfn) != 0)
+		return PCIBIOS_DEVICE_NOT_FOUND;
+
+	/* Check if we have a link */
+	if (!port->link_up)
+		port->link_up = is_link_up(port->base_addr_remap);
+
+	if ((bus->number != port->first_busno) && !port->link_up)
+		return PCIBIOS_DEVICE_NOT_FOUND;
+
+	return 0;
+}
+
+/**
+ * xaxi_pcie_get_config_base
+ * @port: A pointer to a pcie port that needs to be handled
+ * @bus: Bus structure of current bus
+ * @devfun: Device/function
+ * @where: Offset from base
+ *
+ * @return: Base address of the configuration space needed to be
+ *          accessed.
+ *
+ * @note: Get the base address of the configuration space for this
+ *        pcie device.
+ */
+static void __iomem *xaxi_pcie_get_config_base(
+				struct xaxi_pcie_port *port,
+				struct pci_bus *bus,
+				unsigned int devfn, int where)
+{
+	int relbus;
+
+	relbus = ((bus->number << BUS_LOC_SHIFT) | (devfn << DEV_LOC_SHIFT));
+
+	return port->header_remap + relbus + where;
+}
+
+/**
+ * xaxi_pcie_read_config - Read config reg.
+ * @port: A pointer to a pcie port that needs to be handled
+ * @bus: Bus structure of current bus
+ * @devfun: Device/function
+ * @where: Offset from base
+ * @size: Byte/word/dword
+ * @val: A pointer to value read
+ *
+ * @return: Error / no error
+ *
+ *
+ * @note: Read byte/word/dword from pcie device config reg.
+ */
+static int xaxi_pcie_read_config(struct pci_bus *bus,
+				unsigned int devfn,
+				int where,
+				int size,
+				u32 *val)
+{
+	struct pci_sys_data *sys = bus->sysdata;
+	struct xaxi_pcie_port *port = sys->private_data;
+	void __iomem *addr;
+
+	if (xaxi_pcie_verify_config(port, bus, devfn) != 0)
+		return PCIBIOS_DEVICE_NOT_FOUND;
+
+	addr = xaxi_pcie_get_config_base(port, bus, devfn, where);
+
+	if ((bus->number == 0) && devfn > 0) {
+		*val = 0xFFFFFFFF;
+		return PCIBIOS_SUCCESSFUL;
+	}
+
+	switch (size) {
+	case XAXIPCIE_ACCESS8:
+		*val = readb(addr);
+		break;
+	case XAXIPCIE_ACCESS16:
+		*val = readw(addr);
+		break;
+	default:
+		*val = readl(addr);
+		break;
+	}
+
+	return PCIBIOS_SUCCESSFUL;
+}
+
+/**
+ * xaxi_pcie_write_config - Write config reg.
+ * @port: A pointer to a pcie port that needs to be handled
+ * @bus: Bus structure of current bus
+ * @devfun: Device/function
+ * @where: Offset from base
+ * @size: Byte/word/dword
+ * @val: Value to be written to device
+ *
+ * @return: Error / no error
+ *
+ *
+ * @note: Write byte/word/dword to pcie device config reg.
+ */
+static int xaxi_pcie_write_config(struct pci_bus *bus,
+				unsigned int devfn,
+				int where,
+				int size,
+				u32 val)
+{
+	struct pci_sys_data *sys = bus->sysdata;
+	struct xaxi_pcie_port *port = sys->private_data;
+	void __iomem *addr;
+
+	if (xaxi_pcie_verify_config(port, bus, devfn) != 0)
+		return PCIBIOS_DEVICE_NOT_FOUND;
+
+	addr = xaxi_pcie_get_config_base(port, bus, devfn, where);
+
+	if ((bus->number == 0) && devfn > 0)
+		return PCIBIOS_SUCCESSFUL;
+
+	switch (size) {
+	case XAXIPCIE_ACCESS8:
+		writeb(val, addr);
+		break;
+	case XAXIPCIE_ACCESS16:
+		writew(val, addr);
+		break;
+	default:
+		writel(val, addr);
+		break;
+	}
+
+	wmb();
+
+	return PCIBIOS_SUCCESSFUL;
+}
+
+/**
+ * xaxi_pcie_set_bridge_resource - Setup base & limit registers of config space.
+ * @port: Pointer to a root port
+ *
+ * @return: None
+ *
+ * @note: None
+ */
+static void xaxi_pcie_set_bridge_resource(struct xaxi_pcie_port *port)
+{
+	const __be32 *ranges = port->ranges;
+	int rlen = port->range_len;
+	int np = port->pna + 5;
+	u32 pci_space;
+	unsigned long long pci_addr, size;
+	u32 val = 0;
+
+	while ((rlen -= np * 4) >= 0) {
+		pci_space = be32_to_cpup(ranges);
+		pci_addr = of_read_number(ranges + 1, 2);
+		size = of_read_number(ranges + port->pna + 3, 2);
+
+		pr_info("%s:pci_space: 0x%08x pci_addr:0x%016llx size: 0x%016llx\n",
+			__func__, pci_space, pci_addr, size);
+
+		ranges += np;
+
+		switch ((pci_space >> 24) & 0x3) {
+		case XAXIPCIE_MEM_SPACE:	/* PCI Memory space */
+			pr_info("%s:Setting resource in Memory Space\n",
+								__func__);
+			writel(port->pcie2axibar_0,
+					port->header_remap +
+						PCIE_CFG_AD1);
+			writel(port->pcie2axibar_1,
+					port->header_remap +
+						PCIE_CFG_AD2);
+			break;
+		case XAXIPCIE_MEM_SPACE64:	/* PCI 64 bits Memory space */
+			pr_info("%s:Setting resource in Prefetchable Memory Space\n",
+				__func__);
+
+			val = ((pci_addr >> 16) & 0xfff0) |
+					((pci_addr + size - 1) & 0xfff00000);
+
+			writel(val, port->header_remap +
+						PCIE_CFG_PREF_MEM);
+
+			val = ((pci_addr >> 32) & 0xffffffff);
+			writel(val, port->header_remap +
+						PCIE_CFG_PREF_BASE_UPPER);
+
+			val = (((pci_addr + size - 1) >> 32) & 0xffffffff);
+			writel(val, port->header_remap +
+						PCIE_CFG_PREF_LIMIT_UPPER);
+			break;
+		}
+	}
+}
+
+static int xaxi_pcie_hookup_resources(struct xaxi_pcie_port *port,
+					struct pci_sys_data *sys)
+{
+	struct resource *res;
+	int i;
+
+	/* Hookup Memory resources */
+	for (i = 0; i < 3; ++i) {
+		res = &port->mem_resources[i];
+		snprintf(port->mem_space_name, sizeof(port->mem_space_name),
+			"PCIe %d MEM", port->index);
+		port->mem_space_name[sizeof(port->mem_space_name) - 1] = 0;
+		res->name = port->mem_space_name;
+
+		if (!res->flags) {
+			if (i > 0)
+				continue;
+			/* Workaround for lack of MEM resource only on 32-bit */
+			res->start = port->pci_mem_offset;
+			res->end = (resource_size_t)-1LL;
+			res->flags = IORESOURCE_MEM;
+		}
+		if (request_resource(&iomem_resource, res))
+			panic("Request PCIe%d Memory resource failed\n",
+					port->index);
+		pci_add_resource_offset(&sys->resources,
+				res, port->pci_mem_offset);
+
+		pr_info("PCI: PHB MEM resource %d = %016llx-%016llx [%lx]\n",
+			i, (unsigned long long)res->start,
+			(unsigned long long)res->end,
+			(unsigned long)res->flags);
+	}
+
+	return 0;
+}
+
+static void xaxi_pcie_process_bridge_OF_ranges(struct xaxi_pcie_port *port,
+					int primary)
+{
+	/* The address cells of PCIe node */
+	int pna = port->pna;
+	int np = pna + 5;
+	int memno = 0, isa_hole = -1;
+	u32 pci_space;
+	unsigned long long pci_addr, cpu_addr, pci_next, cpu_next, size;
+	unsigned long long isa_mb = 0;
+	struct resource *res;
+	const __be32 *ranges = port->ranges;
+	int rlen = port->range_len;
+	struct device_node *node = port->node;
+
+	pr_info("PCI host bridge %s %s ranges:\n",
+		node->full_name, primary ? "(primary)" : "");
+
+	/* Parse it */
+	pr_debug("Parsing ranges property...\n");
+	while ((rlen -= np * 4) >= 0) {
+		/* Read next ranges element */
+		pci_space = be32_to_cpup(ranges);
+		pci_addr = of_read_number(ranges + 1, 2);
+		cpu_addr = of_translate_address(node, ranges + 3);
+		size = of_read_number(ranges + pna + 3, 2);
+
+		pr_debug("pci_space: 0x%08x pci_addr:0x%016llx\n",
+				pci_space, pci_addr);
+		pr_debug("cpu_addr:0x%016llx size:0x%016llx\n", cpu_addr, size);
+
+		ranges += np;
+
+		/* If we failed translation or got a zero-sized region
+		 * (some FW try to feed us with non sensical zero sized regions
+		 * such as power3 which look like some kind of attempt
+		 * at exposing the VGA memory hole)
+		 */
+		if (cpu_addr == OF_BAD_ADDR || size == 0)
+			continue;
+
+		/* Now consume following elements while they are contiguous */
+		for (; rlen >= np * sizeof(u32);
+			ranges += np, rlen -= np * 4) {
+			if (be32_to_cpup(ranges) != pci_space)
+				break;
+			pci_next = of_read_number(ranges + 1, 2);
+			cpu_next = of_translate_address(node, ranges + 3);
+			if (pci_next != pci_addr + size ||
+				cpu_next != cpu_addr + size)
+				break;
+			size += of_read_number(ranges + pna + 3, 2);
+		}
+
+		/* Act based on address space type */
+		res = NULL;
+		switch ((pci_space >> 24) & 0x3) {
+		case XAXIPCIE_MEM_SPACE:	/* PCI Memory space */
+		case XAXIPCIE_MEM_SPACE64:	/* PCI 64 bits Memory space */
+			pr_info("MEM 0x%016llx..0x%016llx -> 0x%016llx %s\n",
+				cpu_addr, cpu_addr + size - 1, pci_addr,
+				(pci_space & 0x40000000) ? "Prefetch" : "");
+
+			/* We support only 3 memory ranges */
+			if (memno >= 3) {
+				pr_info("\\--> Skipped (too many) !\n");
+				continue;
+			}
+			/* Handles ISA memory hole space here */
+			if (pci_addr == 0) {
+				isa_mb = cpu_addr;
+				isa_hole = memno;
+				if (primary || isa_mem_base == 0)
+					isa_mem_base = cpu_addr;
+				port->isa_mem_phys = cpu_addr;
+				port->isa_mem_size = size;
+			}
+
+			/* We get the PCI/Mem offset from the first range or
+			 * the, current one if the offset came from an ISA
+			 * hole. If they don't match, bugger.
+			 */
+			if (memno == 0 ||
+				(isa_hole >= 0 && pci_addr != 0 &&
+					port->pci_mem_offset == isa_mb))
+				port->pci_mem_offset = cpu_addr - pci_addr;
+			else if (pci_addr != 0 &&
+				port->pci_mem_offset != cpu_addr - pci_addr) {
+				pr_info("\\--> Skipped (offset mismatch) !\n");
+				continue;
+			}
+
+			/* Build resource */
+			res = &port->mem_resources[memno++];
+			res->flags = IORESOURCE_MEM;
+			if (pci_space & 0x40000000)
+				res->flags |= IORESOURCE_PREFETCH;
+			res->start = cpu_addr;
+			break;
+		}
+		if (res != NULL) {
+			res->name = node->full_name;
+			res->end = res->start + size - 1;
+			res->parent = NULL;
+			res->sibling = NULL;
+			res->child = NULL;
+		}
+	}
+
+	/* If there's an ISA hole and the pci_mem_offset is -not- matching
+	 * the ISA hole offset, then we need to remove the ISA hole from
+	 * the resource list for that brige
+	 */
+	if (isa_hole >= 0 && port->pci_mem_offset != isa_mb) {
+		unsigned int next = isa_hole + 1;
+		pr_info("Removing ISA hole at 0x%016llx\n", isa_mb);
+		if (next < memno)
+			memmove(&port->mem_resources[isa_hole],
+				&port->mem_resources[next],
+				sizeof(struct resource) * (memno - next));
+		port->mem_resources[--memno].flags = 0;
+	}
+}
+
+static struct pci_ops xaxi_pcie_ops = {
+	.read  = xaxi_pcie_read_config,
+	.write = xaxi_pcie_write_config,
+};
+
+static int xaxi_pcie_setup(int nr, struct pci_sys_data *sys)
+{
+	u32 val;
+	struct xaxi_pcie_port *port = &xaxi_pcie_ports[nr];
+
+	sys->private_data = port;
+
+	/* Get bus range */
+	port->first_busno = last_bus_on_record;
+
+	val = readl(port->base_addr_remap + XAXIPCIE_REG_PSCR);
+	val = readl(port->header_remap + XAXIPCIE_REG_BIR);
+	val = (val >> 16) & 0x7;
+	port->last_busno = (((port->reg_base - port->reg_len - 1) >> 20)
+						& 0xFF) & val;
+
+	/* Write primary, secondary and subordinate bus numbers */
+	val = port->first_busno;
+	val |= ((port->first_busno + 1) << 8);
+	val |= (port->last_busno << 16);
+
+	writel(val, (port->header_remap + PCIE_CFG_BUS));
+	last_bus_on_record = port->last_busno + 1;
+
+	xaxi_pcie_set_bridge_resource(port);
+
+	/* Parse outbound mapping resources */
+	xaxi_pcie_process_bridge_OF_ranges(port, PRIMARY_BUS);
+	xaxi_pcie_hookup_resources(port, sys);
+
+	return 1;
+}
+
+static struct pci_bus __init *xaxi_pcie_scan_bus(int nr,
+				struct pci_sys_data *sys)
+{
+	struct xaxi_pcie_port *port;
+
+	if (nr >= xaxi_pcie_port_cnt)
+		return NULL;
+
+	port = &xaxi_pcie_ports[nr];
+	port->root_bus_nr = sys->busnr;
+
+	return pci_scan_root_bus(NULL, sys->busnr, &xaxi_pcie_ops, sys,
+			&sys->resources);
+}
+
+static int xaxi_pcie_map_irq(const struct pci_dev *dev, u8 slot, u8 pin)
+{
+	struct pci_sys_data *sys = dev->sysdata;
+	struct xaxi_pcie_port *port = sys->private_data;
+
+	return port->irq_num;
+}
+
+/* Interrupt handler */
+static irqreturn_t xaxi_pcie_intr_handler(int irq, void *data)
+{
+	struct xaxi_pcie_port *port = (struct xaxi_pcie_port *)data;
+	u32 val = 0, mask = 0;
+	u32 status;
+	u32 msi_addr = 0;
+	u32 msi_data = 0;
+
+	/* Read interrupt decode and mask registers */
+	val = readl(port->header_remap + XAXIPCIE_REG_IDR);
+	mask = readl(port->header_remap + XAXIPCIE_REG_IMR);
+
+	status = val & mask;
+	if (!status)
+		return IRQ_NONE;
+
+	if (status & XAXIPCIE_INTR_LINK_DOWN)
+		pr_err("Link Down\n");
+
+	if (status & XAXIPCIE_INTR_ECRC_ERR)
+		pr_warn("ECRC failed\n");
+
+	if (status & XAXIPCIE_INTR_STR_ERR)
+		pr_warn("Streaming error\n");
+
+	if (status & XAXIPCIE_INTR_HOT_RESET)
+		pr_info("Hot reset\n");
+
+	if (status & XAXIPCIE_INTR_CFG_TIMEOUT)
+		pr_warn("ECAM access timeout\n");
+
+	if (status & XAXIPCIE_INTR_CORRECTABLE) {
+		pr_warn("Correctable error message\n");
+		val = readl(port->header_remap +
+				XAXIPCIE_REG_RPEFR);
+		if (val & (1 << 18)) {
+			writel(0xFFFFFFFF,
+				port->base_addr_remap +
+				XAXIPCIE_REG_RPEFR);
+			pr_debug("Requester ID %d\n", (val & 0xffff));
+		}
+	}
+
+	if (status & XAXIPCIE_INTR_NONFATAL) {
+		pr_warn("Non fatal error message\n");
+		val = readl((port->header_remap) +
+				XAXIPCIE_REG_RPEFR);
+		if (val & (1 << 18)) {
+			writel(0xFFFFFFFF,
+				port->base_addr_remap +
+				XAXIPCIE_REG_RPEFR);
+			pr_debug("Requester ID %d\n", (val & 0xffff));
+		}
+	}
+
+	if (status & XAXIPCIE_INTR_FATAL) {
+		pr_warn("Fatal error message\n");
+		val = readl(port->header_remap +
+				XAXIPCIE_REG_RPEFR);
+		if (val & (1 << 18)) {
+			writel(0xFFFFFFFF,
+				port->base_addr_remap +
+				XAXIPCIE_REG_RPEFR);
+			pr_debug("Requester ID %d\n", (val & 0xffff));
+		}
+	}
+
+	if (status & XAXIPCIE_INTR_INTX) {
+		/* INTx interrupt received */
+		val = readl(port->header_remap + XAXIPCIE_REG_RPIFR1);
+
+		/* Check whether interrupt valid */
+		if (!(val & (1 << 31))) {
+			pr_warn("RP Intr FIFO1 read error\n");
+			return IRQ_HANDLED;
+		}
+
+		/* Check MSI or INTX */
+		if (!(val & (1 << 30))) {
+			if (val & (1 << 29))
+				pr_debug("INTx assert\n");
+			else
+				pr_debug("INTx deassert\n");
+		}
+
+		/* Clear interrupt FIFO register 1 */
+		writel(0xFFFFFFFF,
+			port->base_addr_remap + XAXIPCIE_REG_RPIFR1);
+	}
+
+	if (status & XAXIPCIE_INTR_MSI) {
+		/* MSI Interrupt */
+		val = readl(port->header_remap + XAXIPCIE_REG_RPIFR1);
+
+		if (!(val & (1 << 31))) {
+			pr_warn("RP Intr FIFO1 read error\n");
+			return IRQ_HANDLED;
+		}
+
+		if (val & (1 << 30)) {
+			msi_addr = (val >> 16) & 0x7FF;
+			msi_data = readl(port->header_remap +
+					XAXIPCIE_REG_RPIFR2) & 0xFFFF;
+			pr_debug("%s: msi_addr %08x msi_data %08x\n",
+					__func__, msi_addr, msi_data);
+		}
+
+		/* Clear interrupt FIFO register 1 */
+		writel(0xFFFFFFFF,
+			port->base_addr_remap + XAXIPCIE_REG_RPIFR1);
+#ifdef CONFIG_PCI_MSI
+		/* Handle MSI Interrupt */
+		if (msi_data >= xaxipcie_msi_irq_base)
+			generic_handle_irq(msi_data);
+#endif
+	}
+
+	if (status & XAXIPCIE_INTR_SLV_UNSUPP)
+		pr_warn("Slave unsupported request\n");
+
+	if (status & XAXIPCIE_INTR_SLV_UNEXP)
+		pr_warn("Slave unexpected completion\n");
+
+	if (status & XAXIPCIE_INTR_SLV_COMPL)
+		pr_warn("Slave completion timeout\n");
+
+	if (status & XAXIPCIE_INTR_SLV_ERRP)
+		pr_warn("Slave Error Poison\n");
+
+	if (status & XAXIPCIE_INTR_SLV_CMPABT)
+		pr_warn("Slave Completer Abort\n");
+
+	if (status & XAXIPCIE_INTR_SLV_ILLBUR)
+		pr_warn("Slave Illegal Burst\n");
+
+	if (status & XAXIPCIE_INTR_MST_DECERR)
+		pr_warn("Master decode error\n");
+
+	if (status & XAXIPCIE_INTR_MST_SLVERR)
+		pr_warn("Master slave error\n");
+
+	if (status & XAXIPCIE_INTR_MST_ERRP)
+		pr_warn("Master error poison\n");
+
+	/* Clear the Interrupt Decode register */
+	writel(status, port->base_addr_remap + XAXIPCIE_REG_IDR);
+
+	return IRQ_HANDLED;
+}
+
+/**
+ * xaxi_pcie_init_port - Initialize hardware
+ * @port: A pointer to a pcie port that needs to be initialized
+ *
+ * @return: Error / no error
+ *
+ * @note: None
+ */
+static int xaxi_pcie_init_port(struct xaxi_pcie_port *port)
+{
+	void __iomem *base_addr_remap = NULL;
+	int err = 0;
+#ifdef CONFIG_PCI_MSI
+	unsigned long xaxipcie_msg_addr;
+#endif
+
+	base_addr_remap = ioremap(port->reg_base, port->reg_len);
+	if (!base_addr_remap)
+		return -ENOMEM;
+
+	port->base_addr_remap = base_addr_remap;
+
+	/* make sure it is root port before touching header */
+	if (port->type) {
+		port->header_remap = base_addr_remap;
+		writel(BUS_MASTER_ENABLE,
+			port->base_addr_remap + PCIE_CFG_CMD);
+	}
+
+#ifdef CONFIG_PCI_MSI
+	xaxipcie_msg_addr = port->reg_base & ~0xFFF;	/* 4KB aligned */
+	writel(0x0, port->base_addr_remap +
+				XAXIPCIE_REG_MSIBASE1);
+
+	writel(xaxipcie_msg_addr, port->base_addr_remap +
+				XAXIPCIE_REG_MSIBASE2);
+
+	xaxipcie_msi_irq_base = xaxipcie_alloc_msi_irqdescs(port->node,
+					xaxipcie_msg_addr);
+	if (xaxipcie_msi_irq_base < 0) {
+		pr_err("%s: Couldn't allocate MSI IRQ numbers\n",
+					 __func__);
+		return -ENODEV;
+	}
+#endif
+
+	port->link_up = is_link_up(port->base_addr_remap);
+	if (!port->link_up)
+		pr_info("%s: LINK IS DOWN\n", __func__);
+	else
+		pr_info("%s: LINK IS UP\n", __func__);
+
+	/* Disable all interrupts*/
+	writel(~XAXIPCIE_REG_IDR_MASKALL,
+		port->base_addr_remap + XAXIPCIE_REG_IMR);
+
+	/* Clear pending interrupts*/
+	writel(readl(port->base_addr_remap + XAXIPCIE_REG_IDR) &
+			XAXIPCIE_REG_IMR_MASKALL,
+			port->base_addr_remap + XAXIPCIE_REG_IDR);
+
+	/* Enable all interrupts*/
+	writel(XAXIPCIE_REG_IMR_MASKALL,
+			port->base_addr_remap + XAXIPCIE_REG_IMR);
+
+	/*
+	 * Bridge enable must be done after enumeration,
+	 * but there is no callback defined
+	 */
+	bridge_enable(port->base_addr_remap);
+
+	/* Register Interrupt Handler */
+	err = request_irq(port->irq_num, xaxi_pcie_intr_handler,
+					IRQF_SHARED, "zynqpcie", port);
+	if (err) {
+		pr_err("%s: Could not allocate interrupt\n", __func__);
+		return err;
+	}
+
+	return 0;
+}
+
+static struct xaxi_pcie_port *
+xaxi_pcie_instantiate_port_info(struct xaxi_pcie_of_config *config,
+					struct device_node *node)
+{
+	struct xaxi_pcie_port *port;
+	int port_num;
+
+	port_num = config->device_id;
+	port = &xaxi_pcie_ports[port_num];
+	port->node = of_node_get(node);
+	port->index = port_num;
+	port->type = config->device_type;
+	port->reg_base = config->reg_base;
+	port->reg_len = config->reg_len;
+	port->bars_num  = config->bars_num;
+	port->irq_num   = config->irq_num;
+	port->header_addr = port->reg_base + XAXIPCIE_LOCAL_CNFG_BASE;
+	port->pcie2axibar_0 = config->pcie2axibar_0;
+	port->pcie2axibar_1 = config->pcie2axibar_1;
+	port->ranges = config->ranges;
+	port->range_len = config->range_len;
+	port->pna = config->address_cells;
+
+	return port;
+}
+
+/**
+ * xaxi_get_pcie_of_config - Read info from device tree
+ * @node: A pointer to device node to read from
+ * @info: A pointer to xilinx_pcie_node struct to write device tree
+ *	info into to.
+ *
+ * @return: Error / no error
+ *
+ * @note: Read related info from device tree
+ */
+static int xaxi_pcie_get_of_config(struct device_node *node,
+		struct xaxi_pcie_of_config *info)
+{
+	const __be32 *value;
+	int rlen;
+
+	info->num_instances = 1;
+
+	value = of_get_property(node, "xlnx,device-num", &rlen);
+
+	info->device_id = 0;
+
+	value = of_get_property(node, "xlnx,include-rc", &rlen);
+	if (value)
+		info->device_type = be32_to_cpup(value);
+	else
+		return -ENODEV;
+
+	value = of_get_property(node, "reg", &rlen);
+	if (value) {
+		info->reg_base =
+			be32_to_cpup(value);
+		info->reg_len =
+			be32_to_cpup(value + 1);
+	} else
+		return -ENODEV;
+
+	value = of_get_property(node, "xlnx,pciebar-num", &rlen);
+	if (value)
+		info->bars_num = be32_to_cpup(value);
+	else
+		return -ENODEV;
+
+	info->irq_num = irq_of_parse_and_map(node, 0);
+
+	/* Get address translation parameters */
+	value = of_get_property(node, "xlnx,pciebar2axibar-0", &rlen);
+	if (value) {
+		info->pcie2axibar_0 =
+			be32_to_cpup(value);
+	} else
+		return -ENODEV;
+
+	value = of_get_property(node, "xlnx,pciebar2axibar-1", &rlen);
+	if (value) {
+		info->pcie2axibar_1 =
+			be32_to_cpup(value);
+	} else
+		return -ENODEV;
+
+	/* The address cells of PCIe node */
+	info->address_cells = of_n_addr_cells(node);
+
+	/* Get ranges property */
+	value = of_get_property(node, "ranges", &rlen);
+	if (value) {
+		info->ranges = value;
+		info->range_len = rlen;
+	} else
+		return -ENODEV;
+
+	return 0;
+}
+
+static int __init xaxi_pcie_of_probe(struct device_node *node)
+{
+	int err = 0;
+	struct xaxi_pcie_of_config config;
+	struct xaxi_pcie_port *port;
+
+	err = xaxi_pcie_get_of_config(node, &config);
+	if (err) {
+		pr_err("%s: Invalid Configuration\n", __func__);
+		return err;
+	}
+
+	if (!xaxi_pcie_port_cnt) {
+		xaxi_pcie_port_cnt = config.num_instances;
+
+		if (xaxi_pcie_port_cnt) {
+			xaxi_pcie_ports = (struct xaxi_pcie_port *)
+				kzalloc(xaxi_pcie_port_cnt *
+				sizeof(struct xaxi_pcie_port), GFP_KERNEL);
+
+			if (!xaxi_pcie_ports) {
+				pr_err("%s: Memory allocation failed\n",
+					__func__);
+				return -ENOMEM;
+			}
+		} else /* not suppose to be here
+			* when we don't have pcie ports */
+			return -ENODEV;
+	}
+
+	port = xaxi_pcie_instantiate_port_info(&config, node);
+	err = xaxi_pcie_init_port(port);
+	if (err) {
+		pr_err("%s: Port Initalization failed\n", __func__);
+		return err;
+	}
+
+	return err;
+}
+
+static struct of_device_id xaxi_pcie_match[] = {
+	{ .compatible = "xlnx,axi-pcie-1.05.a" ,},
+	{}
+};
+
+static struct hw_pci xaxi_pcie_hw __initdata = {
+	.nr_controllers = 1,
+	.setup          = xaxi_pcie_setup,
+	.scan           = xaxi_pcie_scan_bus,
+	.map_irq        = xaxi_pcie_map_irq,
+};
+
+static int __init xaxi_pcie_init(void)
+{
+	int err;
+	int init = 0;
+	struct device_node *node;
+
+	for_each_matching_node(node, xaxi_pcie_match) {
+		err = xaxi_pcie_of_probe(node);
+		if (err) {
+			pr_err("%s: Root Port Probe failed\n", __func__);
+
+			return err;
+		}
+		pr_info("AXI PCIe Root Port Probe Successful\n");
+		init++;
+	}
+
+	if (init)
+		pci_common_init(&xaxi_pcie_hw);
+
+	return 0;
+}
+
+subsys_initcall(xaxi_pcie_init);
diff --git a/arch/arm/mach-zynq/zynq_ocm.c b/arch/arm/mach-zynq/zynq_ocm.c
new file mode 100644
index 0000000..805255d
--- /dev/null
+++ b/arch/arm/mach-zynq/zynq_ocm.c
@@ -0,0 +1,244 @@
+/*
+ * Copyright (C) 2013 Xilinx
+ *
+ * Based on "Generic on-chip SRAM allocation driver"
+ *
+ * Copyright (C) 2012 Philipp Zabel, Pengutronix
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/kernel.h>
+#include <linux/err.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/of_irq.h>
+#include <linux/platform_device.h>
+#include <linux/genalloc.h>
+
+#include "common.h"
+
+#define ZYNQ_OCM_HIGHADDR	0xfffc0000
+#define ZYNQ_OCM_LOWADDR	0x0
+#define ZYNQ_OCM_BLOCK_SIZE	0x10000
+#define ZYNQ_OCM_BLOCKS		4
+#define ZYNQ_OCM_GRANULARITY	32
+
+#define ZYNQ_OCM_PARITY_CTRL	0x0
+#define ZYNQ_OCM_PARITY_ENABLE	0x1e
+
+#define ZYNQ_OCM_PARITY_ERRADDRESS	0x4
+
+#define ZYNQ_OCM_IRQ_STS		0x8
+#define ZYNQ_OCM_IRQ_STS_ERR_MASK	0x7
+
+struct zynq_ocm_dev {
+	void __iomem *base;
+	int irq;
+	struct gen_pool *pool;
+	struct resource res[ZYNQ_OCM_BLOCKS];
+};
+
+/**
+ * zynq_ocm_irq_handler - Interrupt service routine of the OCM controller
+ * @irq:	IRQ number
+ * @data:	Pointer to the zynq_ocm_dev structure
+ *
+ * Return:	IRQ_HANDLED when handled; IRQ_NONE otherwise.
+ */
+static irqreturn_t zynq_ocm_irq_handler(int irq, void *data)
+{
+	u32 sts;
+	u32 err_addr;
+	struct zynq_ocm_dev *zynq_ocm = data;
+
+	/* check status */
+	sts = readl(zynq_ocm->base + ZYNQ_OCM_IRQ_STS);
+	if (sts & ZYNQ_OCM_IRQ_STS_ERR_MASK) {
+		/* check error address */
+		err_addr = readl(zynq_ocm->base + ZYNQ_OCM_PARITY_ERRADDRESS);
+		pr_err("%s: OCM err intr generated at 0x%04x (stat: 0x%08x).",
+		       __func__, err_addr, sts & ZYNQ_OCM_IRQ_STS_ERR_MASK);
+		return IRQ_HANDLED;
+	}
+	pr_warn("%s: Interrupt generated by OCM, but no error is found.",
+		__func__);
+
+	return IRQ_NONE;
+}
+
+/**
+ * zynq_ocm_probe - Probe method for the OCM driver
+ * @pdev:	Pointer to the platform_device structure
+ *
+ * This function initializes the driver data structures and the hardware.
+ *
+ * Return:	0 on success and error value on failure
+ */
+static int zynq_ocm_probe(struct platform_device *pdev)
+{
+	int ret;
+	struct zynq_ocm_dev *zynq_ocm;
+	u32 i, ocm_config, curr;
+	struct resource *res;
+
+	ocm_config = zynq_slcr_get_ocm_config();
+
+	zynq_ocm = devm_kzalloc(&pdev->dev, sizeof(*zynq_ocm), GFP_KERNEL);
+	if (!zynq_ocm)
+		return -ENOMEM;
+
+	zynq_ocm->pool = devm_gen_pool_create(&pdev->dev,
+					      ilog2(ZYNQ_OCM_GRANULARITY), -1);
+	if (!zynq_ocm->pool)
+		return -ENOMEM;
+
+	curr = 0; /* For storing current struct resource for OCM */
+	for (i = 0; i < ZYNQ_OCM_BLOCKS; i++) {
+		u32 base, start, end;
+
+		/* Setup base address for 64kB OCM block */
+		if (ocm_config & BIT(i))
+			base = ZYNQ_OCM_HIGHADDR;
+		else
+			base = ZYNQ_OCM_LOWADDR;
+
+		/* Calculate start and end block addresses */
+		start = i * ZYNQ_OCM_BLOCK_SIZE + base;
+		end = start + (ZYNQ_OCM_BLOCK_SIZE - 1);
+
+		/* Concatenate OCM blocks together to get bigger pool */
+		if (i > 0 && start == (zynq_ocm->res[curr - 1].end + 1)) {
+			zynq_ocm->res[curr - 1].end = end;
+		} else {
+#ifdef CONFIG_SMP
+			/*
+			 * OCM block if placed at 0x0 has special meaning
+			 * for SMP because jump trampoline is added there.
+			 * Ensure that this address won't be allocated.
+			 */
+			if (!base) {
+				u32 trampoline_code_size =
+					&zynq_secondary_trampoline_end -
+					&zynq_secondary_trampoline;
+				dev_dbg(&pdev->dev,
+					"Allocate reset vector table %dB\n",
+					trampoline_code_size);
+				/* postpone start offset */
+				start += trampoline_code_size;
+			}
+#endif
+			/* First resource is always initialized */
+			zynq_ocm->res[curr].start = start;
+			zynq_ocm->res[curr].end = end;
+			zynq_ocm->res[curr].flags = IORESOURCE_MEM;
+			curr++; /* Increment curr value */
+		}
+		dev_dbg(&pdev->dev, "OCM block %d, start %x, end %x\n",
+			i, start, end);
+	}
+
+	/*
+	 * Separate pool allocation from OCM block detection to ensure
+	 * the biggest possible pool.
+	 */
+	for (i = 0; i < ZYNQ_OCM_BLOCKS; i++) {
+		unsigned long size;
+		void __iomem *virt_base;
+
+		/* Skip all zero size resources */
+		if (zynq_ocm->res[i].end == 0)
+			break;
+		dev_dbg(&pdev->dev, "OCM resources %d, start %x, end %x\n",
+			i, zynq_ocm->res[i].start, zynq_ocm->res[i].end);
+		size = resource_size(&zynq_ocm->res[i]);
+		virt_base = devm_ioremap_resource(&pdev->dev,
+						  &zynq_ocm->res[i]);
+		if (IS_ERR(virt_base))
+			return PTR_ERR(virt_base);
+
+		ret = gen_pool_add_virt(zynq_ocm->pool,
+					(unsigned long)virt_base,
+					zynq_ocm->res[i].start, size, -1);
+		if (ret < 0) {
+			dev_err(&pdev->dev, "Gen pool failed\n");
+			return ret;
+		}
+		dev_info(&pdev->dev, "ZYNQ OCM pool: %ld KiB @ 0x%p\n",
+			 size / 1024, virt_base);
+	}
+
+	/* Get OCM config space */
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	zynq_ocm->base = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(zynq_ocm->base))
+		return PTR_ERR(zynq_ocm->base);
+
+	/* Allocate OCM parity IRQ */
+	zynq_ocm->irq = platform_get_irq(pdev, 0);
+	if (zynq_ocm->irq < 0) {
+		dev_err(&pdev->dev, "irq resource not found\n");
+		return zynq_ocm->irq;
+	}
+	ret = devm_request_irq(&pdev->dev, zynq_ocm->irq, zynq_ocm_irq_handler,
+			       0, pdev->name, zynq_ocm);
+	if (ret != 0) {
+		dev_err(&pdev->dev, "request_irq failed\n");
+		return ret;
+	}
+
+	/* Enable parity errors */
+	writel(ZYNQ_OCM_PARITY_ENABLE, zynq_ocm->base + ZYNQ_OCM_PARITY_CTRL);
+
+	platform_set_drvdata(pdev, zynq_ocm);
+
+	return 0;
+}
+
+/**
+ * zynq_ocm_remove - Remove method for the OCM driver
+ * @pdev:	Pointer to the platform_device structure
+ *
+ * This function is called if a device is physically removed from the system or
+ * if the driver module is being unloaded. It frees all resources allocated to
+ * the device.
+ *
+ * Return:	0 on success and error value on failure
+ */
+static int zynq_ocm_remove(struct platform_device *pdev)
+{
+	struct zynq_ocm_dev *zynq_ocm = platform_get_drvdata(pdev);
+
+	if (gen_pool_avail(zynq_ocm->pool) < gen_pool_size(zynq_ocm->pool))
+		dev_dbg(&pdev->dev, "removed while SRAM allocated\n");
+
+	return 0;
+}
+
+static struct of_device_id zynq_ocm_dt_ids[] = {
+	{ .compatible = "xlnx,zynq-ocmc-1.0" },
+	{ /* end of table */ }
+};
+
+static struct platform_driver zynq_ocm_driver = {
+	.driver = {
+		.name = "zynq-ocm",
+		.of_match_table = zynq_ocm_dt_ids,
+	},
+	.probe = zynq_ocm_probe,
+	.remove = zynq_ocm_remove,
+};
+
+static int __init zynq_ocm_init(void)
+{
+	return platform_driver_register(&zynq_ocm_driver);
+}
+
+arch_initcall(zynq_ocm_init);
-- 
1.7.5.4

