From d6b0bef69d06c2872d88fe5b237e5f701024ee7b Mon Sep 17 00:00:00 2001
From: Haiqing Bai <Haiqing.Bai@windriver.com>
Date: Mon, 16 May 2011 09:35:48 +0800
Subject: [PATCH 3/7] modified comcerto c1k msp related files

Signed-off-by: Haiqing Bai <Haiqing.Bai@windriver.com>
---
 arch/arm/mach-comcerto/include/mach/msp_ioctl.h |   56 +++
 drivers/mtd/nand/comcerto-nand.c                |    2 +-
 drivers/net/comcerto/Kconfig                    |    9 +
 drivers/net/comcerto/Makefile                   |    4 +
 drivers/net/comcerto/comcerto_coredump.c        |  320 ++++++++++++
 drivers/net/comcerto/comcerto_msp.c             |  315 ++++++++++++
 drivers/net/comcerto/comcerto_msp.h             |  204 ++++++++
 drivers/net/comcerto/comcerto_smi_lock.h        |   83 ++++
 drivers/net/comcerto/comcerto_smi_part.c        |   62 +++
 drivers/net/comcerto/comcerto_smi_part.h        |   39 ++
 drivers/net/comcerto/comcerto_smi_queue.c       |   45 ++
 drivers/net/comcerto/comcerto_smi_queue.h       |  115 +++++
 drivers/net/comcerto/comcerto_ved.c             |  587 +++++++++++++++++++++++
 drivers/net/comcerto/comcerto_ved.h             |  106 ++++
 14 files changed, 1946 insertions(+), 1 deletions(-)
 create mode 100644 arch/arm/mach-comcerto/include/mach/msp_ioctl.h
 create mode 100644 drivers/net/comcerto/comcerto_coredump.c
 create mode 100644 drivers/net/comcerto/comcerto_msp.c
 create mode 100644 drivers/net/comcerto/comcerto_msp.h
 create mode 100644 drivers/net/comcerto/comcerto_smi_lock.h
 create mode 100644 drivers/net/comcerto/comcerto_smi_part.c
 create mode 100644 drivers/net/comcerto/comcerto_smi_part.h
 create mode 100644 drivers/net/comcerto/comcerto_smi_queue.c
 create mode 100644 drivers/net/comcerto/comcerto_smi_queue.h
 create mode 100644 drivers/net/comcerto/comcerto_ved.c
 create mode 100644 drivers/net/comcerto/comcerto_ved.h

diff --git a/arch/arm/mach-comcerto/include/mach/msp_ioctl.h b/arch/arm/mach-comcerto/include/mach/msp_ioctl.h
new file mode 100644
index 0000000..b7231fd
--- /dev/null
+++ b/arch/arm/mach-comcerto/include/mach/msp_ioctl.h
@@ -0,0 +1,56 @@
+/*
+ *  arch/arm/mach-comcerto/include/mach/msp_ioctl.h
+ *
+ *  Copyright (C) 2004,2005 Mindspeed Technologies, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef _MSP_IOCTL_H
+#define _MSP_IOCTL_H
+
+struct MSP_IOCTL_IMAGE
+{
+	void *buf;
+	unsigned long len;
+};
+
+struct MSP_IOCTL_MEM_DUMP
+{
+	void *buf;
+	unsigned long addr;
+	unsigned long len;
+};
+
+#ifdef __KERNEL__
+int msp_ioctl_from_csp(unsigned int cmd, unsigned long arg);
+
+/* Only valid when called from the CSP */
+#define MSP_IOCTL_RESET_MSP_LOAD_FROM_KERNELBUF		_IOR(MSP_IOC_TYPE, 5, struct MSP_IOCTL_IMAGE)
+#define MSP_IOCTL_RESET_MSP_DUMP_TO_KERNELBUF		_IOWR(MSP_IOC_TYPE, 6, struct MSP_IOCTL_IMAGE)
+
+#endif
+
+#define MSP_IOC_TYPE					'm'
+#define MSP_IOCTL_DISPLAY_MSP_FROM_NORFLASH		_IO(MSP_IOC_TYPE, 1)
+#define MSP_IOCTL_RESET_MSP_LOAD_FROM_NORFLASH		_IO(MSP_IOC_TYPE, 2)
+#define MSP_IOCTL_RESET_MSP_LOAD_FROM_BUF		_IOR(MSP_IOC_TYPE, 3, struct MSP_IOCTL_IMAGE)
+#define MSP_IOCTL_RESET_MSP_DUMP_TO_BUF			_IOR(MSP_IOC_TYPE, 4, struct MSP_IOCTL_MEM_DUMP)
+
+#define MSP_DEVICE_NAME		"/dev/msp"
+
+#define MSP_DEVICE_MAJOR_NUM	237         /* this could be whatever you want, as long as it does not conflict with other modules */
+
+#endif /* _MSP_IOCTL_H */
diff --git a/drivers/mtd/nand/comcerto-nand.c b/drivers/mtd/nand/comcerto-nand.c
index ec5966b..ca06567 100644
--- a/drivers/mtd/nand/comcerto-nand.c
+++ b/drivers/mtd/nand/comcerto-nand.c
@@ -66,7 +66,7 @@ void comcerto_nand_hwcontrol(struct mtd_info *mtd, int cmd, unsigned int ctrl)
 
 	if (cmd != NAND_CMD_NONE)
 		writeb(cmd, chip->IO_ADDR_W);
-	mdelay(1);
+	udelay(20);
 }
 
 int comcerto_nand_ready(struct mtd_info *mtd)
diff --git a/drivers/net/comcerto/Kconfig b/drivers/net/comcerto/Kconfig
index 8309b41..89dcd13 100644
--- a/drivers/net/comcerto/Kconfig
+++ b/drivers/net/comcerto/Kconfig
@@ -9,3 +9,12 @@ config COMCERTO_ETH
 	depends on NET_COMCERTO
 	default y
 
+config COMCERTO_VED
+	tristate "Mindspeed's Comcerto Control over Virtual Ethernet Driver"
+	depends on  NET_COMCERTO
+	default y
+
+config COMCERTO_MSP_COREDUMP
+	tristate "MSP Coredump Functionality"
+	depends on COMCERTO_VED
+	default y
diff --git a/drivers/net/comcerto/Makefile b/drivers/net/comcerto/Makefile
index 4f9850b..c552aad 100644
--- a/drivers/net/comcerto/Makefile
+++ b/drivers/net/comcerto/Makefile
@@ -8,3 +8,7 @@ ifeq ($(CONFIG_ARCH_M83XXX),y)
                         comcerto_mii.o c1000_ethtool.o
 endif
 
+obj-$(CONFIG_COMCERTO_VED) += comcerto_ved_driver.o
+comcerto_ved_driver-objs := comcerto_ved.o comcerto_smi_part.o comcerto_smi_queue.o comcerto_msp.o
+
+obj-$(CONFIG_COMCERTO_MSP_COREDUMP) += comcerto_coredump.o
diff --git a/drivers/net/comcerto/comcerto_coredump.c b/drivers/net/comcerto/comcerto_coredump.c
new file mode 100644
index 0000000..c97b56f
--- /dev/null
+++ b/drivers/net/comcerto/comcerto_coredump.c
@@ -0,0 +1,320 @@
+/*
+ * drivers/net/comcerto/ comcerto_sysfs.c
+ *
+  *  Copyright (C) 2006 Mindspeed Technologies, Inc.
+  *
+  * This program is free software; you can redistribute it and/or modify
+  * it under the terms of the GNU General Public License as published by
+  * the Free Software Foundation; either version 2 of the License, or
+  * (at your option) any later version.
+  *
+  * This program is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  * GNU General Public License for more details.
+  *
+  * You should have received a copy of the GNU General Public License
+  * along with this program; if not, write to the Free Software
+  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+  */
+
+#include <linux/kernel.h>
+#include <linux/vmalloc.h>
+#include <linux/proc_fs.h>
+#include <linux/module.h>
+#include <mach/msp_ioctl.h>
+#include <asm/io.h>
+#include <asm/uaccess.h>
+
+
+#define MSP_DEVICE_NAME						"/dev/msp"
+#define MSP_DEVICE_MAJOR_NUM			237 /* This could be whatever you want, as long as it does not conflict with other modules */
+#define USER											(1 << 2)
+#define KERNEL										(1 << 3)
+
+
+/*
+ * memcpy_fromio_toxxx - Copies the specified memory to the user space buffer.
+ * @dst: destination buffer
+ * @src: source buffer
+ * @len: size
+ * @flags: flag
+ *
+ * Returns: 0 on success, -1 on error.
+ */
+int memcpy_fromio_toxxx(void *dst, void *src, unsigned long len, u8 flags)
+{
+	unsigned long len_now;
+	void *buf;
+	int rc;
+
+	if (flags & KERNEL)
+	{
+		memcpy_fromio(dst, src, len);
+	}
+	else if (flags & USER)
+	{
+		buf = vmalloc(SZ_128K);
+		
+		if (!buf)
+		{
+			printk(KERN_ERR "error allocating temporary buffer\n");
+			rc = -ENOMEM;
+			goto err;
+		}
+
+		while (len)
+		{
+			len_now = len > SZ_128K ? SZ_128K : len;
+
+			memcpy_fromio(buf, src, len_now);
+
+			if (copy_to_user(dst, buf, len_now))
+			{
+				printk(KERN_ERR "error copying to user\n");
+				rc = -EFAULT;
+				goto err1;
+			}
+
+			src += len_now;
+			dst += len_now;
+			len -= len_now;
+		}
+
+		vfree(buf);
+	}
+
+	return 0;
+
+err1:
+	vfree(buf);
+
+err:
+	return rc;
+}
+
+
+/*
+ * comcerto_dump_msp - Desides from where (memory address) to copy the info.
+ * @addr: base address from where to dump memory
+ * @buf: user space buffer
+ * @len: size
+ * @flags: flag
+ *
+ * Returns: len on success, -1 on error.
+ */
+int comcerto_dump_msp(unsigned long addr, void *buf, unsigned long len, u8 flags)
+{
+	unsigned long aram_size;
+	unsigned long offset;
+	int rc;
+
+	if (!len)
+	{
+		printk(KERN_ERR "MSP coredump invalid size\n");
+		rc = -EINVAL;
+		goto err;
+	}
+
+	aram_size = ARAM_MEMORY_SIZE;
+
+	if ((SDRAM_MSP_MEMORY_PHY <= addr)  && (addr < (SDRAM_MSP_MEMORY_PHY + SDRAM_MSP_MEMORY_SIZE)))
+	{
+		offset = addr - SDRAM_MSP_MEMORY_PHY;
+
+		if ((offset + len) > SDRAM_MSP_MEMORY_SIZE)
+			len = SDRAM_MSP_MEMORY_SIZE - offset;
+
+		rc = memcpy_fromio_toxxx(buf, (void *)SDRAM_MSP_MEMORY_VADDR + offset, len, flags);
+
+		if (rc)
+			goto err;
+	}
+	else if ((COMCERTO_AHB_ARAM_BASE <= addr) && (addr < (COMCERTO_AHB_ARAM_BASE + aram_size)))
+	{
+		offset = addr - COMCERTO_AHB_ARAM_BASE;
+
+		if ((offset + len) > aram_size)
+			len = aram_size - offset;
+
+		rc = memcpy_fromio_toxxx(buf, (void *)ARAM_MEMORY_VADDR + offset, len, flags);
+
+		if (rc)
+			goto err;
+	}
+	else 
+	{
+		printk(KERN_ERR "Invalid coredump memory range %#lx-%#lx\n", addr, addr + len - 1);
+		rc = -EINVAL;
+		goto err;
+	}
+
+	return len;
+
+  err:
+		return rc;
+}
+
+
+/*
+ * msp_ioctl_from_csp - Switches to different ioctl commands and calls appropriate functions. 
+ * @cmd: ioctl command
+ * @arg: buffer address
+ *
+ * Returns: 0 on success, -1 on error.
+ */
+int msp_ioctl_from_csp(unsigned int cmd, unsigned long arg)
+{
+	struct MSP_IOCTL_MEM_DUMP *dump;
+	int rc = 0;
+
+	switch (cmd)
+	{
+		case MSP_IOCTL_RESET_MSP_DUMP_TO_BUF:
+			printk(KERN_INFO "MSP memdump (to user buffer)\n");
+			dump = (struct MSP_IOCTL_MEM_DUMP *) arg;
+			rc = comcerto_dump_msp(dump->addr, dump->buf, dump->len, USER);
+
+			if (rc < 0)
+				break;
+
+			dump->len = rc;
+			rc = 0;
+			break;
+
+		default:
+			printk(KERN_ERR "invalid MSP ioctl (%#x)\n", cmd);
+			rc = -EINVAL;
+			break;
+	}
+
+	return rc;
+}
+
+
+/*
+ * msp_ioctl - Device driver's ioctl function.
+ *
+ * Returns: 0 on success, -1 on error.
+ */
+static int msp_ioctl(struct inode *inode, struct file *file, unsigned int cmd, unsigned long arg)
+{
+	struct MSP_IOCTL_MEM_DUMP dump;
+	int rc;
+
+	printk(KERN_INFO "msp_ioctl(%#lx, %#lx, %#lx)\n", (unsigned long)file, (unsigned long)cmd, arg);
+
+	if (_IOC_TYPE(cmd) != MSP_IOC_TYPE)
+	{
+		rc = -EINVAL;
+		goto err;
+	}
+
+	switch (cmd)
+	{
+		case MSP_IOCTL_RESET_MSP_DUMP_TO_BUF:
+			if (copy_from_user(&dump, (struct MSP_IOCTL_MEM_DUMP *)arg, sizeof(struct MSP_IOCTL_MEM_DUMP)))
+			{
+				printk(KERN_ERR "msp_ioctl: error copying data from user space\n");
+				rc = -EFAULT;
+				goto err;
+			}
+
+			rc = msp_ioctl_from_csp(cmd, (unsigned long)&dump);
+
+			if (rc)
+				goto err;
+
+			if (copy_to_user((struct MSP_IOCTL_MEM_DUMP *)arg, &dump, sizeof(struct MSP_IOCTL_MEM_DUMP)))
+			{
+				printk(KERN_ERR "msp_ioctl: error copying data to user space\n");
+				rc = -EFAULT;
+				goto err;
+			}
+			break;
+		
+		default:
+			rc = -EINVAL;
+			goto err;
+			break;
+	}
+
+	return 0;
+
+  err:
+		return rc;
+}
+
+
+/*
+ * msp_open - Device driver's open function.
+ *
+ * Returns: 0 on success, -1 on error.
+ */
+static int msp_open(struct inode *inode, struct file *file)
+{
+	printk(KERN_INFO "msp_open(%#lx)\n", (unsigned long)file);
+
+	return 0;
+}
+
+
+/*
+ * msp_release - Device driver's release function.
+ *
+ * Returns: 0 on success, -1 on error.
+ */
+static int msp_release(struct inode *inode, struct file *file)
+{
+	printk(KERN_INFO "msp_release(%#lx)\n", (unsigned long)file);
+
+	return 0;
+}
+
+/*
+ * Device driver's file operations structure.
+ */
+struct file_operations msp_fops =
+{
+	.owner = THIS_MODULE,
+	.open = msp_open,
+	.release = msp_release,
+	.ioctl = msp_ioctl,
+};
+
+
+/*
+ * msp_init_module - Device driver's init_module function.
+ *
+ * Returns: 0 on success, -1 on error.
+ */
+static int __init msp_init_module(void)
+{
+	if (register_chrdev(MSP_DEVICE_MAJOR_NUM, MSP_DEVICE_NAME, &msp_fops))
+	{
+		printk(KERN_ERR "Unable to register char device");
+		goto err1;
+	}
+
+	return 0;
+
+	err1:
+		return -1;
+}
+
+
+/*
+ * msp_cleanup_module - Device driver's cleanup_module function.
+ *
+ * Returns: 0 on success, -1 on error.
+ */
+static void __exit msp_cleanup_module(void)
+{
+	unregister_chrdev(MSP_DEVICE_MAJOR_NUM, MSP_DEVICE_NAME);
+}
+
+EXPORT_SYMBOL(msp_ioctl_from_csp);
+
+module_init(msp_init_module);
+module_exit(msp_cleanup_module);
+
diff --git a/drivers/net/comcerto/comcerto_msp.c b/drivers/net/comcerto/comcerto_msp.c
new file mode 100644
index 0000000..43e05bf
--- /dev/null
+++ b/drivers/net/comcerto/comcerto_msp.c
@@ -0,0 +1,315 @@
+/*
+ *  linux/driver/net/comcerto/comcerto_msp.c
+ *
+ *  Copyright (C) 2004,2008 Mindspeed Technologies, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/module.h>
+
+#include <linux/kernel.h>
+#include <linux/vmalloc.h>
+#include <linux/interrupt.h>
+#include <linux/sysctl.h>
+#include <linux/proc_fs.h>
+#include <linux/timer.h>
+#include <linux/sched.h>
+
+#include <asm/irq.h>
+#include <asm/sizes.h>
+#include <mach/hardware.h>
+#include <mach/debug.h>
+#include <mach/memory.h>
+#include <asm/io.h>
+#include <asm/uaccess.h>
+#include <asm/delay.h>
+
+#include "comcerto_msp.h"
+
+/* Export msp_info address */
+unsigned long SPDRV_ACP_MSP_Phyaddr;
+EXPORT_SYMBOL(SPDRV_ACP_MSP_Phyaddr);
+
+/**
+ * dump_elf_headers - 
+ *
+ *
+ */
+static void dump_elf_headers(Elf32_Ehdr *this_elf_header)
+{
+	PDEBUG (MSP_INIT, "ELF_HEADER (%#x)", sizeof(Elf32_Ehdr));
+
+	PDEBUG (MSP_INIT, "File header information (ELF)");
+	PDEBUG (MSP_INIT, "Machine class : %d", this_elf_header->e_ident[EI_CLASS]);
+	PDEBUG (MSP_INIT, "Data encoding: %d", this_elf_header->e_ident[EI_DATA]);
+	PDEBUG (MSP_INIT, "Machine type: %d", this_elf_header->e_machine);
+	PDEBUG (MSP_INIT, "File type: %d", this_elf_header->e_type);
+	PDEBUG (MSP_INIT, "Image Entry point: 0x%08X", this_elf_header->e_entry);
+	PDEBUG (MSP_INIT, "Program header offset: 0x%08X", this_elf_header->e_phoff);
+	PDEBUG (MSP_INIT, "Section header offset: 0x%08X", this_elf_header->e_shoff);
+	PDEBUG (MSP_INIT, "Flags: 0x%08X", this_elf_header->e_flags);
+	PDEBUG (MSP_INIT, "Header size: 0x%04X", this_elf_header->e_ehsize);
+	PDEBUG (MSP_INIT, "Program header entry size: 0x%04X", this_elf_header->e_phentsize);
+	PDEBUG (MSP_INIT, "Program header entries: 0x%04X", this_elf_header->e_phnum);
+	PDEBUG (MSP_INIT, "Section header entry size: 0x%04X", this_elf_header->e_shentsize);
+	PDEBUG (MSP_INIT, "Section header entries: 0x%04X", this_elf_header->e_shnum);
+	PDEBUG (MSP_INIT, "String table section index: 0x%04X", this_elf_header->e_shstrndx);
+}
+
+/**
+ * comcerto_download_elf_image - 
+ *
+ *
+ */
+static int download_elf_image(struct _code_info *code_info)
+{
+	int i;
+	int rc = 0;
+	char *section_name;
+	Elf32_Ehdr *this_elf_header = (Elf32_Ehdr *)(code_info->code);
+	Elf32_Half number_of_section = this_elf_header->e_shnum;
+	/* pointer to the Section header.  */
+	Elf32_Shdr *this_section_headers = (Elf32_Shdr *) (code_info->code + this_elf_header->e_shoff);
+	Elf32_Off string_section_offset = this_section_headers[this_elf_header->e_shstrndx].sh_offset;
+	u32 checksum_program_addr=0;
+	if (!number_of_section)
+	{
+		PDEBUG(MSP_ERR, "Invalid of section = %d ", number_of_section);
+		rc = -1;
+		goto out;
+	}
+	dump_elf_headers(this_elf_header);
+	
+	/* parse all sections */
+	for (i = 0; i < number_of_section; i++)
+	{
+		section_name = code_info->code  + string_section_offset + this_section_headers[i].sh_name;
+		if (!strncmp(section_name, "msp_proc", 8))
+		{
+				code_info->proc_addr = this_section_headers[i].sh_addr;
+				PDEBUG (MSP_INIT, "proc_addr at 0x%08x", code_info->proc_addr);
+				//clean the memory
+				_memset_io(msp_to_virt(this_section_headers[i].sh_addr), 0, this_section_headers[i].sh_size);
+		} 
+		
+		/* retrieve the section name from the ELF buffer */
+		if (!strncmp(section_name, "CHECKSUM", 8))
+		{
+				checksum_program_addr = *((u32 *) (code_info->code + this_section_headers[i].sh_offset));
+				PDEBUG (MSP_INIT, "checksum prog at 0x%08x", checksum_program_addr);
+		} 
+		else if ((this_section_headers[i].sh_flags != SHF_MIPS_ADDR) && 
+		    (this_section_headers[i].sh_flags != 0)) 
+		{
+			/* retrieve the section name from the ELF buffer */
+			
+			if ((this_section_headers[i].sh_type & 3) == SHT_PROGBITS)
+			{
+				PDEBUG (MSP_INIT, "%s section: %d bytes to load at addr:0x%08x from elf offset: %d",
+					section_name,
+					this_section_headers[i].sh_size,
+					this_section_headers[i].sh_addr,
+					this_section_headers[i].sh_offset);
+				
+				memcpy(
+					msp_to_virt(this_section_headers[i].sh_addr),
+					(void*)(code_info->code + this_section_headers[i].sh_offset),
+					this_section_headers[i].sh_size);
+			}
+		}
+	}
+	// every think weent OK
+	code_info->program_addr = this_elf_header->e_entry;
+	
+	
+out:
+	return rc;
+}
+
+void msp_set_resethandler(struct comcerto_msp *msp, unsigned long base_address)
+{
+	__raw_writel(0xE59FF018, msp->vectors_base);	/* LDR PC, [PC,#20] */
+	__raw_writel(base_address, msp->vectors_base + 0x00000020);	/* jump to msp start */
+}
+
+
+int msp_ready(struct comcerto_msp *msp, u32 timeout)
+{
+	u32 count = 0;
+
+	PDEBUG(MSP_FUNC, "msp_ready()");
+
+	/* timeout is passed in ms, set it in jiffies */
+	timeout = (timeout * HZ) / 1000;
+	
+	while (!msp->info || !msp->info->ready) {
+		set_current_state(TASK_UNINTERRUPTIBLE);
+		schedule_timeout(1);
+
+		if (++count >= timeout) {
+			printk(KERN_ERR "Didn't receive ack from MSP\n");
+			msp->info = NULL;
+			goto err;
+		}
+	}
+
+	printk(KERN_INFO "MSP is running\n");
+
+	return 1;
+
+ err:
+	return 0;
+}
+
+
+int msp_start(struct comcerto_msp *msp)
+{
+	PDEBUG(MSP_FUNC, "msp_start()");
+
+	msp->state = MSP_STARTING;
+	msp->alert_seen = 0;
+
+#if defined (CONFIG_ARCH_M83XXX)
+	 __raw_writel(__raw_readl(COMCERTO_BLOCK_RESET_REG) |  ARM1_AHB_RST, COMCERTO_BLOCK_RESET_REG);
+#else
+	__raw_writel(0x80000000, COMCERTO_INTC_ARM1_CONTROL_REG);
+#endif
+
+	if (!msp_ready(msp, 8000)) {
+		printk(KERN_ERR "start_ved: failed to start the MSP\n");
+		goto err;
+	}
+
+	//start timer
+	init_timer(&msp->timer_expire);
+	msp->timer_expire.function = msp_poll;
+	msp->timer_expire.expires = jiffies+((10*HZ)/10); // 1second
+	msp->timer_expire.data = (unsigned long) msp;
+	add_timer(&msp->timer_expire);
+	msp->state = MSP_RUNNING;
+
+	// Copy MSP/ACP shared mem location for sp_driver
+	SPDRV_ACP_MSP_Phyaddr = msp->info->SPDRV_ACP_MSP_Phyaddr;
+
+	return 0;
+ err:
+ 	return -1;
+}
+
+void msp_alert(struct comcerto_msp *msp)
+{
+	struct AlertType *alert;
+	struct MSP_STACK_FRAME *frame;
+	unsigned int *sp;
+	
+	if (msp->info) {
+		while (msp->info->AlertNumber != msp->alert_seen) {
+			alert = (struct AlertType *) msp_to_virt(msp->info->saveAlert) + msp->alert_seen;
+			msp->alert_seen++;
+			printk(KERN_CRIT "MSP alert : type : 0x%x, channel=%d \n", alert->type & 0xff, alert->channel);
+			printk(KERN_CRIT "MSP alert : link register : 0x%X, ID =0x%X \n", alert->abort_lr, alert->UniqueID);
+			if (alert->type & 0x8000) {
+				frame = (struct MSP_STACK_FRAME *)msp_to_virt(msp->info->AlertFrame);
+				sp = (unsigned int *)msp_to_virt(frame->sp);
+				sp++;
+				printk(KERN_CRIT "MSP alert : \n");
+				printk(KERN_CRIT "r0 = 0x%08X, r1 = 0x%08X, r2 = 0x%08X, r3 = 0x%08X \n", frame->r0, frame->r1, frame->r2, frame->r3);
+				printk(KERN_CRIT "r4 = 0x%08X, r5 = 0x%08X, r6 = 0x%08X, r7 = 0x%08X \n", frame->r4, frame->r5, frame->r6, frame->r7);
+				printk(KERN_CRIT "r8 = 0x%08X, r9 = 0x%08X, r10 = 0x%08X, r11 = 0x%08X \n", frame->r8, frame->r9, frame->r10,
+				       frame->r11);
+				printk(KERN_CRIT "r12 = 0x%08X, sp = 0x%08X, lr = 0x%08X, \n", frame->r12, frame->sp, frame->lr);
+				printk(KERN_CRIT "sp dump : \n");
+				printk(KERN_CRIT "0x%08X, 0x%08X, 0x%08X, 0x%08X \n", *sp, *(sp + 1), *(sp + 2), *(sp + 3));
+				sp += 4;
+				printk(KERN_CRIT "0x%08X, 0x%08X, 0x%08X, 0x%08X \n", *sp, *(sp + 1), *(sp + 2), *(sp + 3));
+				sp += 4;
+				printk(KERN_CRIT "0x%08X, 0x%08X, 0x%08X, 0x%08X \n", *sp, *(sp + 1), *(sp + 2), *(sp + 3));
+				sp += 4;
+				printk(KERN_CRIT "0x%08X, 0x%08X, 0x%08X, 0x%08X \n ", *sp, *(sp + 1), *(sp + 2), *(sp + 3));
+				sp += 4;
+				printk(KERN_CRIT "0x%08X, 0x%08X, 0x%08X, 0x%08X \n", *sp, *(sp + 1), *(sp + 2), *(sp + 3));
+				sp += 4;
+				printk(KERN_CRIT "0x%08X, 0x%08X, 0x%08X, 0x%08X \n", *sp, *(sp + 1), *(sp + 2), *(sp + 3));
+				sp += 4;
+				printk(KERN_CRIT "0x%08X, 0x%08X, 0x%08X, 0x%08X \n", *sp, *(sp + 1), *(sp + 2), *(sp + 3));
+				sp += 4;
+				printk(KERN_CRIT "0x%08X, 0x%08X, 0x%08X, 0x%08X \n", *sp, *(sp + 1), *(sp + 2), *(sp + 3));
+				sp += 4;
+			}
+		}
+	}
+}
+void msp_poll(unsigned long arg)
+{
+	struct comcerto_msp *msp = (struct comcerto_msp *) arg;
+
+	//check for Alerts
+	msp_alert(msp);
+
+	switch (msp->state)
+	{
+		case MSP_RESETTING:
+		case MSP_RESET:
+		case MSP_STARTING:
+		case MSP_CRASHED:
+			break;
+		case MSP_RUNNING:
+			{
+				if(msp->info->Heartbeat == 0)
+				{
+					printk(KERN_CRIT "MSP Heart beat Failure \n");
+					msp_alert(msp);
+					msp->state = MSP_CRASHED;
+				}
+				msp->info->Heartbeat= 0;
+			}
+			break;
+	}
+	msp->timer_expire.expires = jiffies+((10*HZ)/10); // 1second
+	add_timer(&msp->timer_expire);
+}
+
+int comcerto_download_to_msp(struct comcerto_msp *msp)
+{
+	struct _code_info *code_info = &msp->code_info;
+
+	if(download_elf_image(code_info)==0)
+	{
+		//download went OK retrieve information
+		msp->info = msp_to_virt(msp->code_info.proc_addr);
+		return 0;
+	}
+	return -1;
+}
+
+int comcerto_start_msp(struct comcerto_msp *msp)
+{
+	struct _code_info *code_info = &msp->code_info;
+	msp_set_resethandler(msp, code_info->program_addr);
+	return msp_start(msp);
+}
+
+void comcerto_stop_msp(struct comcerto_msp *msp)
+{
+#if defined (CONFIG_ARCH_M83XXX)
+	 	__raw_writel(__raw_readl(COMCERTO_BLOCK_RESET_REG) &  ~ARM1_AHB_RST, COMCERTO_BLOCK_RESET_REG);
+#else
+		__raw_writel(0, COMCERTO_INTC_ARM1_CONTROL_REG);
+#endif	
+
+	msp->state = MSP_RESET;
+	del_timer(&msp->timer_expire);
+}
diff --git a/drivers/net/comcerto/comcerto_msp.h b/drivers/net/comcerto/comcerto_msp.h
new file mode 100644
index 0000000..95a3fc4
--- /dev/null
+++ b/drivers/net/comcerto/comcerto_msp.h
@@ -0,0 +1,204 @@
+/*
+ *  linux/drivers/net/comcerto/comcerto_msp.h
+ *
+ *  Copyright (C) 2006 Mindspeed Technologies, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __COMCERTO_MSP_H__
+#define __COMCERTO_MSP_H__
+
+#include <linux/firmware.h>
+#include <linux/elf.h>
+#include <mach/debug.h>
+#include <linux/netdevice.h>
+
+/* copied from usr/include/elf.h */
+#ifndef _ELF_H
+#define	_ELF_H 1
+#define EM_ARM		40		/* ARM */
+
+#define SHF_MIPS_ADDR 0x40000000
+#define SHT_PROGBITS 1
+#endif
+
+enum MSP_states {
+	MSP_RESETTING = 0,
+	MSP_RESET,
+	MSP_STARTING,
+	MSP_RUNNING,
+	MSP_CRASHED
+};
+
+#if 0
+struct _AIF_HEADER {
+	u32 BL_DecompressCode;	/*00    */
+	u32 BL_SelfRelocCode;	/*04    */
+	u32 BL_DbgInitZeroInit;	/*08    */
+	u32 EntryPointOffset;	/*0C    */
+	u32 ProgramExitInstr;	/*10    */
+	u32 ImageReadOnlySize;	/*14    in bytes */
+	u32 ImageReadWriteSize;	/*18    in bytes */
+	u32 ImageDebugSize;	/*1C    */
+	u32 ImageZeroInitSize;	/*20    */
+	u32 ImageDebugType;	/*24    */
+	u32 ImageBase;	/*28    32 bit address */
+	u32 WorkSpace;	/*2C    */
+	u32 AddressMode;	/*30    */
+	u32 DataBase;		/*34    32 bit address */
+	u32 FirstFatOffset;	/*38    byte offset in file */
+	u32 Reserved2;	/*3C    */
+	u32 DebugInitInstr;	/*40    */
+	u32 ZeroInitCode[15];	/*44...80 */
+};
+
+struct _FAT_AIF_HEADER {
+	u32 NextFatOffset;	/*byte offset in file */
+	u32 LoadAddress;	/*32 bit address */
+	u32 Size;		/*in bytes */
+	u8 region_name[32];
+};
+#endif
+
+enum DevName {
+	Chagall_64 = 0,		// Chagall 64 channels (M82530-xx)
+	Chagall_32,		// Chagall 32 channels (M82520-xx)
+	Chagall_16,		// Chagall 16 channels (M82510-xx)
+	Chagall_8,		// Chagall 8 channels (M82505-xx)
+	Miro_HP,		// Miro Communications Convergence Processor (HP Process) (M82610-16P, -14R, -14)
+	Miro_Anyport,		// Miro (RAS/Voice) (M82600-xx)
+	Miro_Wireless,		// Miro Wireless Access Processor (M82620-xx)
+	Miro_LV,		// Miro Communications Convergence Processor (1st version assembled) (LV Process) (HP prototypes) (M82610-11P15P)
+	Miro_Mini_64,		// This is not a real bonding option
+	Miro_Mini_32,		// This is not a real bonding option
+	Miro_Mini_16,		// This is not a real bonding option
+	Miro_Mini_8,		// This is not a real bonding option
+	Picasso,		// Picasso ===> 12
+	Chagall2_32,		// Chagall2_32 - M82515 (monet chip, but functions like a chagall device)
+	Chagall2_16,		// Chagall2_16 - M82511 (monet chip, but functions like a chagall device)
+	Chagall2_8,		// Chagall2_8  - M82506  (monet chip, but functions like a chagall device)
+	Chagall2_4,		// Chagall2_4  - M82501  (monet chip, but functions like a chagall device)
+	Slave_Chagall2_32,	// This is not a real bonding option   ===> 17
+	Slave_Chagall2_16,	// This is not a real bonding option
+	Slave_Chagall2_8,	// This is not a real bonding option
+	Slave_Chagall2_4,	// This is not a real bonding option
+	Chagall2_24,		// Chagall2_24 - M82514 (monet chip, but functions like a chagall device) ====> 21
+	Slave_Chagall2_24,	// This is not a real bonding option
+	Chagall_48,		//  Chagall 48 channels (M82524 -xx)   === > 23
+	Miro_Mini_48,		// This is not a real bonding option
+	//
+	//device types from 25 to 56 currently free
+	//
+	Monet_data = 57,	// Monet data only (M82803-xx)
+	Monet_16,		// Monet 16 channels (M82801-xx)
+	Monet_32,		// Monet 32 channels (M82805-xx)
+	Monet_48,		// Monet 48 channels (M82810-xx)
+	Monet_64,		// Monet 64 channels (M82815-xx)
+	Monet_64HP,		// Monet 64 high performace channels (M82820-xx)
+};
+
+struct MSP_STACK_FRAME {
+	unsigned int r0;
+	unsigned int r1;
+	unsigned int r2;
+	unsigned int r3;
+	unsigned int r4;
+	unsigned int r5;
+	unsigned int r6;
+	unsigned int r7;
+	unsigned int r8;
+	unsigned int r9;
+	unsigned int r10;
+	unsigned int r11;
+	unsigned int r12;
+	unsigned int sp;
+	unsigned int lr;
+	unsigned int pc;
+};
+
+struct AlertType {
+	unsigned short type;
+	unsigned short channel;
+	unsigned short UniqueID;
+	unsigned short filler1;
+	unsigned int abort_lr;
+	unsigned int filler2;
+};
+
+struct _code_info {
+	u8 *code;
+	u32 size;
+
+	u32 checksum_program_addr;
+	u32 program_addr;
+	u32 proc_addr;
+	u32 checksum;
+};
+
+struct msp_info {
+	unsigned long ABI_rev;
+	volatile unsigned long lock;
+	unsigned long Device;
+	unsigned long Revision;
+	char msp_version[32];
+	char spu_version[16];
+//
+	unsigned long CSPtoMSPQueuePhyaddr;
+	unsigned long MSPtoCSPQueuePhyaddr;
+	unsigned long SMRXCSPhyaddr;
+	unsigned long SMTXCSPhyaddr;
+	unsigned long SPDRV_ACP_MSP_Phyaddr;
+//
+	unsigned long ERAMsize;
+	unsigned long ARAMsize;
+	unsigned long IRAMsize;
+	unsigned short ARMfreq;
+	unsigned short AMBAfreq;
+	unsigned short SPUfreq;
+	unsigned long VOIP_ipaddr;
+	volatile unsigned int IPoffload;
+	volatile unsigned int ready;
+	volatile unsigned int Heartbeat;
+	volatile unsigned int AlertNumber;
+	volatile unsigned long AlertFrame;
+	volatile unsigned long saveAlert;
+};
+
+
+struct comcerto_msp
+{
+	int alert_seen;
+	unsigned long last_tick;
+
+	int watchdog_disable;
+	int ipoffload_enable;
+	int ipoffload_suspend;
+
+	int state;
+
+	volatile struct msp_info *info;
+	struct _code_info code_info;
+	struct sk_buff_head MSP_list;
+	struct timer_list timer_expire;
+	struct ctl_table_header *sysctl_header;
+	void* __iomem vectors_base;
+};
+
+int comcerto_download_to_msp(struct comcerto_msp *msp);
+int comcerto_start_msp(struct comcerto_msp *msp);
+void comcerto_stop_msp(struct comcerto_msp *msp);
+void msp_poll(unsigned long arg);
+#endif
diff --git a/drivers/net/comcerto/comcerto_smi_lock.h b/drivers/net/comcerto/comcerto_smi_lock.h
new file mode 100644
index 0000000..31ca991
--- /dev/null
+++ b/drivers/net/comcerto/comcerto_smi_lock.h
@@ -0,0 +1,83 @@
+/*
+ *  linux/drivers/net/comcerto/comcerto_smi_lock.h
+ *
+ *  Copyright (C) 2006 Mindspeed Technologies, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __COMCERTO_SMI_LOCK_H__
+#define __COMCERTO_SMI_LOCK_H__
+
+/*
+ *	SWPB() for locking.
+ *	*bytep must be NCNB.
+ *	On a non-ARM, you'll need to do something else.
+ */
+static inline unsigned char SWPB(u8 v, volatile u8 * bytep)
+{
+	unsigned char ret;
+	__asm__ __volatile__("swpb %0, %1, [%2]":"=&r"(ret)
+			     :"r"(v), "r"(bytep)
+			     :"memory");
+	return (ret);
+}
+
+/*
+ *	SFL_lock()
+ *	Spin to lock. Always succeeds.
+ */
+#if defined (CONFIG_ARCH_M83XXX)
+static inline void SFL_lock(volatile void *lockp)
+{
+	volatile unsigned long long t;
+
+	do {
+		t = *(volatile u32 *)((u32) lockp + 0x100000);
+	} while (t & 0x1);
+
+}
+#else
+static inline unsigned long SFL_lock(volatile void *lockp)
+{
+	unsigned char t;
+
+	do {
+		t = SWPB(0xFF, (volatile unsigned char *)lockp);
+	} while (t == 0xff);
+
+	return t;
+}
+#endif
+/*
+ *	SFL_unlock()
+ *	Unlock. Always succeeds.
+ */
+#if defined (CONFIG_ARCH_M83XXX)
+static inline void SFL_unlock(volatile void *lockp)
+{
+	*(volatile unsigned char *) lockp = 0;
+}
+#else
+static inline void SFL_unlock(volatile void *lockp)
+{
+	unsigned char t;
+
+	t = SWPB(0x00, (volatile unsigned char *)lockp);
+
+}
+#endif
+
+#endif /* __COMCERTO_SMI_LOCK_H__ */
diff --git a/drivers/net/comcerto/comcerto_smi_part.c b/drivers/net/comcerto/comcerto_smi_part.c
new file mode 100644
index 0000000..fd545b4
--- /dev/null
+++ b/drivers/net/comcerto/comcerto_smi_part.c
@@ -0,0 +1,62 @@
+/*
+ *  linux/drivers/net/comcerto/comcerto_smi_part.c
+ *
+ *  Copyright (C) 2006 Mindspeed Technologies, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/kernel.h>
+#include <asm/io.h>
+#include <mach/hardware.h>
+
+#include "comcerto_smi_part.h"
+#include "comcerto_smi_lock.h"
+
+void *SFL_alloc_part(struct FASTPART *fp)
+{
+	void *v;
+	unsigned long flags;
+//	PDEBUG(SMI_PART, "SFL_alloc_part: partition=%x\n", (unsigned long) fp);
+
+	local_irq_save(flags);  
+	SFL_lock(&fp->lock);
+
+	if (fp->freeblk) {
+		v = msp_to_virt(fp->freeblk);
+		fp->freeblk = __raw_readl(v);
+	} else
+		v = NULL;
+
+	SFL_unlock(&fp->lock);
+	local_irq_restore(flags);
+
+	return v;
+}
+
+void SFL_free_part(struct FASTPART *fp, void *v)
+{
+	unsigned long flags; 
+//	PDEBUG(SMI_PART, "SFL_free_part: partition=%x, %x\n", (unsigned long) fp, (unsigned long)v);
+
+	local_irq_save(flags); 
+	SFL_lock(&fp->lock);
+
+	__raw_writel(fp->freeblk, v);
+	fp->freeblk = virt_to_msp(v);
+
+	SFL_unlock(&fp->lock);
+	local_irq_restore(flags);
+}
diff --git a/drivers/net/comcerto/comcerto_smi_part.h b/drivers/net/comcerto/comcerto_smi_part.h
new file mode 100644
index 0000000..a809c6a
--- /dev/null
+++ b/drivers/net/comcerto/comcerto_smi_part.h
@@ -0,0 +1,39 @@
+/*
+ *  linux/drivers/net/comcerto/comcerto_smi_part.h
+ *
+ *  Copyright (C) 2006 Mindspeed Technologies, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __COMCERTO_SMI_PART_H
+#define __COMCERTO_SMI_PART_H
+
+struct FASTPART {
+	volatile u8 lock;
+	u8 reserved1;
+	volatile unsigned long freeblk;
+	unsigned long storage;
+	u32 blksz;
+	u32 blkcnt;
+	u32 *end_of_storage;
+	u16 reserved2;
+	u32 freecnt;
+};
+
+void *SFL_alloc_part(struct FASTPART *fp);
+void SFL_free_part(struct FASTPART *fp, void *v);
+
+#endif /* __COMCERTO_SMI_PART_H */
diff --git a/drivers/net/comcerto/comcerto_smi_queue.c b/drivers/net/comcerto/comcerto_smi_queue.c
new file mode 100644
index 0000000..13b376a
--- /dev/null
+++ b/drivers/net/comcerto/comcerto_smi_queue.c
@@ -0,0 +1,45 @@
+/*
+ *  linux/drivers/net/comcerto/comcerto_smi_queue.c
+ *
+ *  Copyright (C) 2006 Mindspeed Technologies, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/kernel.h>
+#include <asm/io.h>
+#include <mach/hardware.h>
+#include <mach/debug.h>
+
+#include "comcerto_smi_queue.h"
+
+struct FASTQUEUE *smi_queue_init(struct SMIQUEUE *psmiq, u32 physaddr, void (*genint_cpu0) (void))
+{
+	struct FASTQUEUE *fpq;
+
+	//fpq = (struct FASTQUEUE *) msp_to_virt(physaddr);
+	fpq = (struct FASTQUEUE *) aram_to_virt(physaddr);
+
+	PDEBUG(SMI_PART, "Comcerto SMI: fpq(PA): %#lx", (unsigned long)physaddr);
+	PDEBUG(SMI_PART, "Comcerto SMI: fpq(VA): %#lx", (unsigned long)fpq);
+
+	if (fpq) {
+		psmiq->fpq = fpq;
+		psmiq->storage_virt = msp_to_virt(fpq->storage);
+		psmiq->genint_cpu0 = genint_cpu0;
+	}
+
+	return (fpq);
+}
diff --git a/drivers/net/comcerto/comcerto_smi_queue.h b/drivers/net/comcerto/comcerto_smi_queue.h
new file mode 100644
index 0000000..6ac7a94
--- /dev/null
+++ b/drivers/net/comcerto/comcerto_smi_queue.h
@@ -0,0 +1,115 @@
+/*
+ *  linux/drivers/net/comcerto/comcerto_smi_queue.h
+ *
+ *  Copyright (C) 2006 Mindspeed Technologies, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __COMCERTO_SMI_QUEUE_H
+#define __COMCERTO_SMI_QUEUE_H
+
+#include <linux/types.h>	/* size_t */
+
+#include <asm/io.h>
+#include <mach/hardware.h>
+#include <mach/irq.h>
+
+#include "comcerto_smi_lock.h"
+
+/* shared structure (can't be modified without MSP modification) */
+struct FASTQUEUE {
+	unsigned long storage;
+	u32 sema;
+	u16 lock;
+	volatile u16 get;
+	volatile u16 put;
+	u16 size;
+};
+
+/* private structure (CSP only) */
+struct SMIQUEUE {
+	u32 PtrOffset;			/* IRAM ptr offset to Queue pointer */
+	unsigned long *storage_virt;	/* Virtual Address of fpq->storage */
+	struct FASTQUEUE *fpq;			/* queue pointer */
+	void (*genint_cpu0) (void);	/* CSP to MSP generate interrupt function */
+};
+
+struct FASTQUEUE *smi_queue_init(struct SMIQUEUE *psmiq, u32 PtrOffset, void (*genint_cpu0) (void));
+
+static inline void SFL_genint_cpu0(void)
+{
+	comcerto_softirq_set(IRQ_PTP1);
+}
+
+static inline int SFL_enqueue(struct SMIQUEUE *psmiq, void *vaddr)
+{
+	struct FASTQUEUE *fpq = psmiq->fpq;
+	unsigned long flags;
+	u16 put;
+	int rc = 0;
+
+	local_irq_save(flags);
+	SFL_lock(&fpq->lock);
+	put = fpq->put;
+
+	if (++put >= fpq->size)
+		put = 0;
+
+	if (put != fpq->get) {
+		rc = 1;
+		psmiq->storage_virt[fpq->put] = (unsigned long)virt_to_msp(vaddr);
+		fpq->put = put;
+		if (psmiq->genint_cpu0)
+			psmiq->genint_cpu0();
+	}
+
+	SFL_unlock(&fpq->lock);
+	local_irq_restore(flags);
+
+	return rc;
+}
+
+static inline void *SFL_dequeue(struct SMIQUEUE *psmiq)
+{
+	struct FASTQUEUE *fpq = psmiq->fpq;
+	unsigned long flags;
+	u32 get;
+	void *v;
+
+	local_irq_save(flags); 
+	SFL_lock(&fpq->lock);
+	get = fpq->get;
+
+	if (fpq->put != get) {
+		v = msp_to_virt(psmiq->storage_virt[get++]);
+		if (get == fpq->size)
+			get = 0;
+		fpq->get = get;
+	} else
+		v = NULL;
+
+	SFL_unlock(&fpq->lock);
+	local_irq_restore(flags);
+
+	return v;
+}
+
+static inline int SFL_queue_empty(struct FASTQUEUE *fpq)
+{
+	return (fpq->get == fpq->put);
+}
+
+#endif /* __COMCERTO_SMI_QUEUE_H */
diff --git a/drivers/net/comcerto/comcerto_ved.c b/drivers/net/comcerto/comcerto_ved.c
new file mode 100644
index 0000000..2a221d9
--- /dev/null
+++ b/drivers/net/comcerto/comcerto_ved.c
@@ -0,0 +1,587 @@
+ /*
+  *  linux/drivers/net/comcerto/comcerto_ved.c
+  *
+  *  Copyright (C) 2006 Mindspeed Technologies, Inc.
+  *
+  * This program is free software; you can redistribute it and/or modify
+  * it under the terms of the GNU General Public License as published by
+  * the Free Software Foundation; either version 2 of the License, or
+  * (at your option) any later version.
+  *
+  * This program is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  * GNU General Public License for more details.
+  *
+  * You should have received a copy of the GNU General Public License
+  * along with this program; if not, write to the Free Software
+  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+  */
+
+#include <linux/kernel.h>
+#include <linux/interrupt.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/dma-mapping.h>
+
+#include <net/ip.h>
+#include <net/sock.h>
+
+#include <asm/irq.h>
+#include <asm/delay.h>
+#include <asm/mach/irq.h>
+#include <mach/irq.h>
+#include <mach/hardware.h>
+#include <mach/memory.h>
+#include <mach/debug.h>
+
+#include <linux/platform_device.h>
+#include <linux/firmware.h>
+
+#include "comcerto_ved.h"
+#include "comcerto_smi_part.h"
+#include "comcerto_smi_queue.h"
+#include "comcerto_msp.h"
+
+char ctrl_mac[6] = { 0x00, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE };
+
+#define IP_SEC_HEADROOM	40
+#define PKT_BUF_SZ (1540+IP_SEC_HEADROOM)	/* Size of each rx buffer */
+
+#define VED_STATE_RESET		0
+#define VED_STATE_DIRECT	1
+#define VED_STATE_MSP		2
+#define VED_STATE_CHANGING	3
+
+#define NAPI_WA 1
+
+int ved_state = VED_STATE_RESET;
+
+static int ved_xmit(struct sk_buff *skb, struct net_device *dev);
+static struct net_device_stats *ved_get_stats(struct net_device *dev);
+void ved_rx(struct net_device *dev, int len, char *buf);
+irqreturn_t ved_interrupt(int irq, void *dev_id);
+int device_open(struct net_device *dev);
+int device_release(struct net_device *dev);
+void ved_tx_timeout(struct net_device *dev);
+int ved_rebuild_header(struct sk_buff *skb);
+
+int ved_header(struct sk_buff *skb, struct net_device *dev, unsigned short type, const void *daddr, const void *saddr, unsigned int len);
+
+int ved_ioctl(struct net_device *dev, struct ifreq *rq, int cmd);
+static int ved_write_packet(struct sk_buff *skb, struct net_device *dev);
+static int ved_read_packet(struct net_device *dev, struct FDesc * ThisFdesc);
+static int ved_poll(struct napi_struct *napi, int budget);
+
+static int __init ctrl_init(struct net_device *dev);
+
+void ved_set_eth_header(char *set_eth);
+
+
+static int start_ved(struct net_device *dev);
+static int stop_ved(void);
+
+/* fake multicast ability */
+static void set_multicast_list(struct net_device *dev)
+{
+
+}
+static const struct net_device_ops ctrl_netdev_ops = {
+	.ndo_init = ctrl_init, 
+	.ndo_open = device_open,
+	.ndo_stop = device_release,
+	.ndo_start_xmit = ved_xmit,
+	.ndo_get_stats = ved_get_stats,
+	.ndo_set_multicast_list = set_multicast_list,
+};
+static const struct header_ops ctrl_header_ops = {
+	.create = ved_header, 
+	.rebuild = ved_rebuild_header,
+};
+/*
+struct net_device ctrl_dev[1] = {
+      //{init:ctrl_init,}
+};
+*/
+struct net_device *ctrl_dev;
+
+static struct platform_device *msp_coprocessor;
+
+
+static int __init ctrl_init(struct net_device *dev)
+{
+	struct ved_priv *priv = netdev_priv(dev);
+
+	//SET_MODULE_OWNER(dev);
+
+	/* Initialize the device structure. */
+	/*priv = kmalloc(sizeof(struct ved_priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+	*/
+	memset(priv, 0, sizeof(struct ved_priv));
+	
+	priv->dev = dev;
+
+	spin_lock_init(&priv->lock);
+	// init private section
+	priv->default_packet_type = PROTID_ETH;
+	priv->state = 0; /* closed */
+
+	/* Fill in device structure with ethernet-generic values. */
+	ether_setup(dev);
+	
+	//dev->do_ioctl = ved_ioctl;
+	dev->irq = IRQ_CTRL;
+	
+	netif_napi_add(dev, &priv->napi, ved_poll, 32);
+	
+	dev->flags &= ~IFF_MULTICAST;
+	dev->flags |= IFF_NOARP;
+
+	skb_queue_head_init(&priv->msp.MSP_list);
+
+	netif_stop_queue(dev);
+	printk(KERN_DEBUG "%s init\n", CTRL);
+	return 0;
+}
+
+static int ved_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+	struct ved_priv *priv = (struct ved_priv *)netdev_priv(dev);
+	unsigned long flags;
+	int rc;
+
+	spin_lock_irqsave(&priv->lock, flags);
+
+	rc = ved_write_packet(skb, dev);
+
+	if (rc) {
+		priv->stats.tx_dropped++;
+	} else {
+		priv->stats.tx_packets++;
+		priv->stats.tx_bytes += skb->len;
+		dev->trans_start = jiffies;	/* save the timestamp */
+	}
+
+	spin_unlock_irqrestore(&priv->lock, flags);
+
+	return 0;
+}
+
+static inline void ved_ack_MSP(void)
+{
+	comcerto_softirq_set(IRQ_PTP1);
+}
+
+irqreturn_t ved_interrupt(int irq, void *dev_id)
+{
+	struct net_device *dev = (struct net_device *)dev_id;
+	struct ved_priv *priv = netdev_priv(dev);
+
+	spin_lock(&priv->lock);
+
+	if (napi_schedule_prep(&priv->napi)) {
+
+		comcerto_softirq_set(irq);
+		PDEBUG(VED_RX_FUNC, "%s  ved_interruptRX : schedule poll\n", dev->name);
+		disable_irq_nosync(irq);
+		__napi_schedule(&priv->napi);
+	} else {
+		PDEBUG(VED_RX_FUNC, "%s ved_interruptRX bug! interrupt while in poll\n", dev->name);
+		/* FIX by disabling interrupts  */
+		//disable_irq(irq);
+	}
+
+	/* Unlock the device and we are done */
+	spin_unlock(&priv->lock);
+
+	return IRQ_HANDLED;
+}
+
+int ved_rebuild_header(struct sk_buff *skb)
+{
+	struct ethhdr *eth = (struct ethhdr *)skb->data;
+	struct net_device *dev = skb->dev;
+
+	memcpy(eth->h_source, dev->dev_addr, dev->addr_len);
+	memcpy(eth->h_dest, dev->dev_addr, dev->addr_len);
+	eth->h_dest[ETH_ALEN - 1] ^= 0x01;	/* dest is us xor 1 */
+
+	return 0;
+}
+
+int ved_header(struct sk_buff *skb, struct net_device *dev, unsigned short type, const void *daddr, const void *saddr, unsigned int len)
+{
+	struct ethhdr *eth = (struct ethhdr *)skb_push(skb, ETH_HLEN);
+
+	eth->h_proto = htons(type);
+	memcpy(eth->h_source, saddr ? saddr : dev->dev_addr, dev->addr_len);
+	memcpy(eth->h_dest, daddr ? daddr : dev->dev_addr, dev->addr_len);
+
+	eth->h_dest[ETH_ALEN - 1] ^= 0x01;	/* dest is us xor 1 */
+
+	return (dev->hard_header_len);
+}
+
+int device_open(struct net_device *dev)
+{
+	struct ved_priv *priv = netdev_priv(dev);
+	const struct firmware *fw_entry;
+	int rc = 0;
+
+	/* Check if the interface is alredy open (MSP already download)*/
+	if(priv->state == 1)
+		return rc;
+
+	comcerto_stop_msp(&priv->msp);
+
+	might_sleep();
+
+	if(request_firmware(&fw_entry,"msp.axf",&msp_coprocessor->dev) !=0 ) {
+		printk(KERN_ERR "Error finding the Firmware\n");
+		rc = -ETIMEDOUT;
+		goto out;
+	}
+	
+	priv->msp.code_info.code = fw_entry->data;
+	priv->msp.code_info.size = fw_entry->size;
+	if (SDRAM_MSP_MEMORY_PHY) // MSP @ address 0x0
+		priv->msp.vectors_base = ioremap(0x00000000, 0x40);
+	else
+		priv->msp.vectors_base = (void *)SDRAM_MSP_MEMORY_VADDR;
+
+	if(!priv->msp.vectors_base) {
+		printk(KERN_ERR "Cannot map msp vectors, aborting.\n");
+		goto out;
+	}
+
+	comcerto_download_to_msp(&priv->msp);
+	
+	if(comcerto_start_msp(&priv->msp) < 0)
+		goto out;
+	
+	start_ved(dev);
+
+	napi_enable(&priv->napi);
+	rc = request_irq(dev->irq, ved_interrupt, IRQF_SHARED, "comcerto_ved", dev);
+	if (rc) {
+		printk(KERN_ERR "Failed to get the IRQ = %d\n", dev->irq);
+		goto out;
+	}
+
+	netif_start_queue(dev);
+	priv->state = 1; /* open */
+	
+	
+     out:
+	release_firmware(fw_entry);
+	return rc;
+}
+
+int device_release(struct net_device *dev)
+{
+	struct ved_priv *priv = netdev_priv(dev);
+
+	PDEBUG(VED_STATE,"%s device_release state %d", CTRL, priv->state);
+
+	/* do nothing if interface is already down */
+	if(priv->state == 1)
+	{
+		netif_stop_queue(dev);	/* can't transmit any more */
+		
+		/* disable irq */
+		free_irq(dev->irq, dev);
+
+		/* reset MSP device */
+		comcerto_stop_msp(&priv->msp);
+		if (SDRAM_MSP_MEMORY_PHY) // MSP @ address 0x0
+			iounmap(priv->msp.vectors_base );
+
+		stop_ved();
+		priv->state = 0;
+	}
+
+	return 0;
+}
+
+static struct net_device_stats *ved_get_stats(struct net_device *dev)
+{
+	return &(((struct ved_priv *)netdev_priv(dev))->stats);
+}
+
+static void ved_setup(struct net_device *dev)
+{
+	ether_setup(dev);
+
+	/* Initialize the device structure. */
+	dev->netdev_ops = &ctrl_netdev_ops;
+	dev->header_ops	= &ctrl_header_ops;
+	dev->destructor = free_netdev;
+
+	/* Fill in device structure with ethernet-generic values. */
+	dev->tx_queue_len = 0;
+	dev->flags |= IFF_NOARP;
+	dev->flags &= ~IFF_MULTICAST;
+}
+
+int __init ved_init_module(void)
+{
+	int rc;
+//	PDEBUG(VED_INIT_FUNC,"ved_init_module");
+
+	/* Find a name for this unit */
+	ctrl_dev = alloc_netdev(sizeof(struct ved_priv), "ved%d", ved_setup);
+	if (!ctrl_dev) {
+		printk(KERN_ERR "ved_init_module: failed to alloc device %s\n", CTRL);
+		rc = -ENOMEM;
+		goto err0;
+	}
+	rc = dev_alloc_name(ctrl_dev, CTRL);
+	if (rc < 0) {
+		printk(KERN_ERR "ved_init_module: failed to alloc device name %s\n", CTRL);
+		goto err1;
+	}
+
+	rc = register_netdev(ctrl_dev);
+	if (rc) {
+		printk(KERN_ERR "ved_init_module: failed to register dev %s\n", CTRL);
+		goto err1;
+	}
+
+	/* assign the MAC address for second virtual device */
+	memcpy_fromio(ctrl_dev->dev_addr, ctrl_mac, ETH_ALEN);
+	msp_coprocessor = platform_device_register_simple("MSP Copro", -1, NULL, 0);
+
+	return 0;
+
+      err1:
+	free_netdev(ctrl_dev);	
+      err0:
+	return rc;
+}
+
+static void __exit ved_cleanup_module(void)
+{
+	unregister_netdev(ctrl_dev);
+	free_netdev(ctrl_dev);
+}
+
+/**
+ *	ved_read_packet - read and process an REALPACKET (Ethernet) frame 
+ *	@dev: device id
+ *	@ThisFdesc: Frame descriptor to parse
+ *
+ *	This function read and process received frame descriptor non pre-processed by MSP . (ethernet frames)
+ */
+static int ved_read_packet(struct net_device *dev, struct FDesc *ThisFdesc)
+{
+	struct ved_priv *priv = (struct ved_priv *)netdev_priv(dev);
+	char *data_addr;
+	int length, offset, reason;
+	struct sk_buff *skb;
+
+	PDEBUG(VED_RX_FUNC, "%s : ved_read_packet: entry\n", dev->name);
+
+	skb = dev_alloc_skb(PKT_BUF_SZ);
+
+	if (skb) {
+		length = ThisFdesc->Length;
+		offset = ThisFdesc->Offset;
+
+		ThisFdesc->FStatus = 0;
+		data_addr = (char *)msp_to_virt(ThisFdesc->Payload + offset);
+
+		skb_reserve(skb, NET_IP_ALIGN);
+		memcpy(skb_put(skb, length), data_addr, length);
+		skb->dev = dev;
+		skb->protocol = eth_type_trans(skb, dev);
+
+		if (unlikely(skb->tail > skb->end))
+			skb_over_panic(skb, length, current_text_addr());
+
+		if((reason = netif_receive_skb(skb)))
+		{
+			priv->stats.rx_dropped++;
+			PDEBUG(VED_RX_FUNC, "WARN: skb not delivered - reason %lx - proto %lx\n", (unsigned long)reason, (unsigned long)skb->protocol);
+		}
+		
+		priv->stats.rx_packets++;
+		priv->stats.rx_bytes += length;
+		dev->last_rx = jiffies;
+		
+	} else {
+		PDEBUG(VED_RX_FUNC, "%s ved_read_packet: low on mem - packet dropped\n", dev->name);
+		priv->stats.rx_dropped++;
+		return 0;
+	}
+	PDEBUG(VED_RX_FUNC, "%s : ved_read_packet: exit\n", dev->name);
+
+	return 1;
+}
+
+static int ved_poll(struct napi_struct *napi, int budget)
+{
+
+	struct ved_priv *priv = container_of(napi, struct ved_priv, napi);
+	struct net_device *dev = priv->dev;
+	struct FDesc * ThisFdesc = NULL;
+	int done;
+	int rx_work_limit = budget;
+	int received = 0;
+
+	PDEBUG(VED_RX_FUNC, "%s : ved_poll: entry\n", dev->name);
+
+restart_poll:
+	do {
+		comcerto_irq_ack(dev->irq);
+
+		while (!SFL_queue_empty(priv->rx_smiq.fpq)) {
+
+			if (--rx_work_limit < 0) {
+				goto not_done;
+			}
+
+			ThisFdesc = SFL_dequeue(&priv->rx_smiq);
+
+			done = ved_read_packet(dev, ThisFdesc);
+			//SFL_free_part(msp_to_virt(ThisFdesc->fpart), ThisFdesc);
+			SFL_free_part(aram_to_virt(ThisFdesc->fpart), ThisFdesc);
+			if (!done)
+				goto not_done;
+			else
+				received++;
+			break;
+			
+		}
+
+	}
+	while (comcerto_softirq_check(dev->irq));
+
+//	PDEBUG(VED_RX_FUNC, "%s ved_poll : done %d packets \n", dev->name, received);
+
+	/* we are happy/done, no more packets on ring; put us back
+	   to where we can start processing interrupts again */
+	napi_complete(napi);
+	//enable_irq(dev->irq);
+
+	/* The last op happens after poll completion. Which means the following:
+	 * 1. it can race with disabling irqs in irq handler (which are done to
+	 * schedule polls)
+	 * 2. it can race with dis/enabling irqs in other poll threads
+	 * 3. if an irq raised after the begining of the outer  beginning
+	 * loop(marked in the code above), it will be immediately
+	 * triggered here.
+	 *
+	 * Summarizing: the logic may results in some redundant irqs both
+	 * due to races in masking and due to too late acking of already
+	 * processed irqs. The good news: no events are ever lost.
+	 */
+
+	/* Let's have a last chance to process any missing interrupts we may 
+	* we may have missed while the IRQs line was masqued. Before leaving
+	* poll mode, we check if data have been posted in the queue from MSP.
+	* If true, then the IRQ line is disabled again and a new loop of polling
+	* is scheduled. This double check work arround is well known in NAPI 
+	* based implementation (see documentations/NAPI_HOWTO.txt - appendix2)
+	*/
+#if NAPI_WA
+	if(!SFL_queue_empty(priv->rx_smiq.fpq) && napi_reschedule(napi)) {
+		//disable_irq(dev->irq);
+		goto restart_poll;
+	}
+#endif
+	enable_irq(dev->irq);
+	return 0;		/* done */
+
+      not_done:
+
+	PDEBUG(VED_RX_FUNC, "%s ved_poll : not done %d packets \n", dev->name, received);
+
+	if (!received) {
+		received = 1;
+	}
+
+	return 1;		/* not_done */
+}
+
+static int ved_write_packet(struct sk_buff *skb, struct net_device *dev)
+{
+	struct ved_priv *priv = (struct ved_priv *)netdev_priv(dev);
+	struct FDesc *ThisFdesc;
+	struct u8 *buf;
+	u32 offset;
+
+	PDEBUG(VED_TX_FUNC, "%s ved_write_packet : entry \n", dev->name);
+	PDEBUG(VED_TX_FUNC, "%s : ved_write_packet: packet protocol %x \n", dev->name, skb->protocol);
+
+	
+	ThisFdesc = SFL_alloc_part(priv->tx_smipart);
+	if (!ThisFdesc) {
+		dev_kfree_skb(skb);
+		return -ENOMEM;
+	}
+
+	offset = NET_IP_ALIGN;
+	buf = msp_to_virt(ThisFdesc->Payload) + offset;
+	
+	memcpy(buf, skb->data, skb->len);
+
+	ThisFdesc->Offset = offset;
+
+	ThisFdesc->Next = (unsigned long) NULL;
+	ThisFdesc->Length = (u32) (skb->len);
+	ThisFdesc->FStatus = 0;
+	ThisFdesc->protocol = priv->default_packet_type;
+
+	// free the original skb (local generation)
+	dev_kfree_skb(skb);
+
+	if (SFL_enqueue(&priv->tx_smiq, ThisFdesc) == 0) {
+		PDEBUG(VED_TX_FUNC, "ved_write_packet QUEUE FULL !!!! %lx \n", (unsigned long) ThisFdesc);
+		SFL_free_part(priv->tx_smipart, ThisFdesc);
+		return -ENOMEM;
+	}
+	PDEBUG(VED_TX_FUNC, "%s ved_write_packet : exit \n", dev->name);
+
+	return 0;
+
+}
+
+static int stop_ved(void)
+{
+	struct net_device *dev;
+	struct ved_priv *priv;
+
+	dev = ctrl_dev;
+	priv = (struct ved_priv *)netdev_priv(dev);
+	
+	return 0;
+}
+
+static int start_ved(struct net_device *dev)
+{
+	struct ved_priv *priv= (struct ved_priv *)netdev_priv(dev);
+	struct msp_info *info= (struct msp_info *)priv->msp.info;
+	
+	if(info)
+	{
+		PDEBUG(VED_INIT_FUNC, "info \n\tDevice=%lx\n\tRevision=%lx\n\tspu_version=%s\n\tCSPtoMSPQueuePhyaddr=%lx\n\tMSPtoCSPQueuePhyaddr=%lx\n\tSMRXCSPhyaddr=%lx\n\tSMTXCSPhyaddr=%lx\n\t",(unsigned long) info->Device,(unsigned long) info->Revision, info->spu_version,(unsigned long) info->CSPtoMSPQueuePhyaddr,(unsigned long) info->MSPtoCSPQueuePhyaddr,(unsigned long) info->SMRXCSPhyaddr,(unsigned long) info->SMTXCSPhyaddr);
+		printk(KERN_INFO "MSP version is : %s\n", info->msp_version);
+
+//		priv->tx_smipart =  (struct FASTPART *)  msp_to_virt(info->SMRXCSPhyaddr);
+		priv->tx_smipart =  (struct FASTPART *)  aram_to_virt(info->SMRXCSPhyaddr);
+//		priv->rx_smipart =  (struct FASTPART *)  msp_to_virt(info->SMRXCSPhyaddr);
+		priv->rx_smipart =  (struct FASTPART *)  aram_to_virt(info->SMRXCSPhyaddr);
+
+		smi_queue_init(&priv->tx_smiq, info->CSPtoMSPQueuePhyaddr, SFL_genint_cpu0);
+		smi_queue_init(&priv->rx_smiq, info->MSPtoCSPQueuePhyaddr, NULL);
+		ved_ack_MSP();
+		return 0;
+	}
+	return -1;
+}
+
+module_init(ved_init_module);
+module_exit(ved_cleanup_module);
+MODULE_LICENSE("GPL");
diff --git a/drivers/net/comcerto/comcerto_ved.h b/drivers/net/comcerto/comcerto_ved.h
new file mode 100644
index 0000000..6cfcad1
--- /dev/null
+++ b/drivers/net/comcerto/comcerto_ved.h
@@ -0,0 +1,106 @@
+/*
+ *  linux/drivers/net/comcerto/comcerto_ved.h
+ *
+ *  Copyright (C) 2006 Mindspeed Technologies, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef _COMCERTO_VED_H
+#define _COMCERTO_VED_H
+
+#include <linux/netdevice.h>	/* struct device, and other headers */
+
+#include "comcerto_smi_part.h"
+#include "comcerto_smi_queue.h"
+#include "comcerto_msp.h"
+
+#define VED_SKB_POOL_SIZE	512
+
+/* Default timeout period */
+#define VED_TIMEOUT 5		/* In jiffies */
+
+// Protocol index definition
+typedef enum {
+	PROTID_RAW,
+	PROTID_ETH,
+	PROTID_PPP,
+	PROTID_IPV4,
+	PROTID_IPV6,
+	PROTID_CSME,
+	PROTID_ARP,
+	PROTID_VLAN,
+	PROTID_UDP,
+	PROTID_TCP,
+	PROTID_ICMP,
+	PROTID_CSM_API,
+	MAX_PROTOCOL,
+	PROTO_INVALID
+} ProtocolIndex;
+
+#define IRQ_CTRL	IRQ_PTP0
+
+
+#define CTRL	"eth1"
+
+
+/*
+ * This structure is private to each device. It is used to pass
+ * packets in and out, so there is place for a packet
+ */
+
+struct ved_priv {
+	struct net_device_stats stats;
+	struct net_device    *dev;
+	struct napi_struct   napi;
+	spinlock_t lock;
+
+	struct _SKB_POOL *skbpool;	// skb pool for MSP to CSP buffer (max MTU size)
+
+	// smi (share memory interface)
+	struct FASTPART *tx_smipart;	// CSP to MSP Fdesc fast part
+	struct FASTPART *rx_smipart;	// MSP to CSP Fdesc fast part
+	struct SMIQUEUE tx_smiq;
+	struct SMIQUEUE rx_smiq;
+	u32 default_packet_type;
+	struct comcerto_msp msp;
+	int state;
+};
+
+struct BDesc {
+	unsigned long BPtr;
+	volatile u32 BControl;
+};
+
+struct FDesc {
+	unsigned long Next;
+	volatile u32 System;
+	volatile u32 FStatus;
+	volatile u32 FControl;
+	struct BDesc BDesc;
+	u32 Dummy[6];
+	u16 Length;
+	u16 Offset;
+	u16 protocol;
+	u16 proto_length;
+	struct sk_buff *skb;
+	unsigned long fpart;
+	u32 Dummy1;		// Tail
+	u32 DMA_addr;		// nFdesc used by MSP or local phy addr of FDESC (only used in direct EMAC control mode)
+	u32 pSFdesc;		// CSP musn't touch this value
+	unsigned long Payload;
+};
+
+#endif /* _COMCERTO_VED_H */
-- 
1.7.0

