From 315868113518d0713780c9e7942e66da4e41a2df Mon Sep 17 00:00:00 2001
From: Yue Tao <yue.tao@windriver.com>
Date: Sun, 26 May 2013 23:03:29 -0700
Subject: [PATCH 1/7] Add tdm support to voip driver

Signed-off-by: Feng Feng <feng.feng@windriver.com>
---
 arch/arm/mach-comcerto/Makefile                    |    2 +-
 arch/arm/mach-comcerto/board-c1kmfcn_evm.c         |   25 ++
 arch/arm/mach-comcerto/comcerto-1000.c             |    1 +
 .../mach-comcerto/include/mach/comcerto-common.h   |   52 ++++
 arch/arm/mach-comcerto/sysfstdm.c                  |  255 ++++++++++++++++++++
 5 files changed, 334 insertions(+), 1 deletions(-)
 create mode 100644 arch/arm/mach-comcerto/include/mach/comcerto-common.h
 create mode 100644 arch/arm/mach-comcerto/sysfstdm.c

diff --git a/arch/arm/mach-comcerto/Makefile b/arch/arm/mach-comcerto/Makefile
index 6260c63..3fc55eb 100644
--- a/arch/arm/mach-comcerto/Makefile
+++ b/arch/arm/mach-comcerto/Makefile
@@ -4,7 +4,7 @@
 
 # Object file lists.
 
-obj-y := irq.o time.o
+obj-y := irq.o time.o sysfstdm.o
 
 obj-$(CONFIG_ARCH_M83XXX)			+= comcerto-1000.o pwrmgmt_c1000.o
 obj-$(CONFIG_EVM_C1KMFCN_EVM)			+= board-c1kmfcn_evm.o
diff --git a/arch/arm/mach-comcerto/board-c1kmfcn_evm.c b/arch/arm/mach-comcerto/board-c1kmfcn_evm.c
index 9bb817e..5c2cabb 100644
--- a/arch/arm/mach-comcerto/board-c1kmfcn_evm.c
+++ b/arch/arm/mach-comcerto/board-c1kmfcn_evm.c
@@ -32,6 +32,7 @@
 #include <mach/hardware.h>
 #include <mach/nand.h>
 #include <mach/gpio.h>
+#include <mach/comcerto-common.h>
 
 static u32 EXP_NAND_SEL;
 
@@ -516,6 +517,29 @@ static struct platform_device comcerto_usb0_device = {
 };
 #endif
 
+
+static struct comcerto_tdm_data comcerto_tdm_pdata = {
+	.fsoutput = 1, /* Generic Pad Control and Version ID Register[2] */
+	.fspolarity = 0, /* 28 FSYNC_FALL(RISE)_EDGE */
+	.fshwidth = 1, /* High_Phase_Width[10:0] */
+	.fslwidth = 0xFF, /* Low_Phase_Width[10:0] */
+	.clockhz = 2048000, /* INC_VALUE[29:0] According to the desired TDM clock output frequency, this field should be configured 
+*/
+	.clockout = 1, /* 0 -> set bit 21, clear bit 20 in COMCERTO_GPIO_IOCTRL_REG 
+	(software control, clock input)
+	1 -> set bit 21 and 20 in COMCERTO_GPIO_IOCTRL_REG
+	(software control, clock output)
+	2 -> clear bit 21 in COMCERTO_GPIO_IOCTRL_REG (hardware control) */
+};
+
+static struct platform_device comcerto_tdm_device = {
+	.name   = "comcerto-tdm",
+	.id             = 0,
+	.dev.platform_data = &comcerto_tdm_pdata,
+	.num_resources  = 0,
+	.resource = NULL,
+};
+
 static struct platform_device *comcerto_devices[] __initdata = {
 	&comcerto_uart,
 	&comcerto_fbpoolA_device,
@@ -535,6 +559,7 @@ static struct platform_device *comcerto_devices[] __initdata = {
 				defined(CONFIG_USB_EHCI_COMCERTO_83XX_MODULE)
 	&comcerto_usb0_device,
 #endif
+	&comcerto_tdm_device,
 };
 
 #if defined(CONFIG_CONFIG_I2C_BOARDINFO)
diff --git a/arch/arm/mach-comcerto/comcerto-1000.c b/arch/arm/mach-comcerto/comcerto-1000.c
index 399311d..08a011a 100644
--- a/arch/arm/mach-comcerto/comcerto-1000.c
+++ b/arch/arm/mach-comcerto/comcerto-1000.c
@@ -315,4 +315,5 @@ void __init device_init(void)
 	writel(readl(COMCERTO_BLOCK_RESET_REG) & ~(GEMAC0_RST | GEMAC1_RST), COMCERTO_BLOCK_RESET_REG);
 	udelay(15);
 	writel(readl(COMCERTO_BLOCK_RESET_REG) | GEMAC0_RST | GEMAC1_RST, COMCERTO_BLOCK_RESET_REG);
+	writel(readl(COMCERTO_BLOCK_RESET_REG) | TDM_RST, COMCERTO_BLOCK_RESET_REG);
 }
diff --git a/arch/arm/mach-comcerto/include/mach/comcerto-common.h b/arch/arm/mach-comcerto/include/mach/comcerto-common.h
new file mode 100644
index 0000000..3c60a1b
--- /dev/null
+++ b/arch/arm/mach-comcerto/include/mach/comcerto-common.h
@@ -0,0 +1,52 @@
+/*
+ *  arch/arm/mach-comcerto/include/mach/comcerto-common.h
+ *
+ *  Copyright (C) 2004,2005 Mindspeed Technologies, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __ASM_ARCH_HARDWARE_H
+#error "Do not include this directly, instead #include <asm/hardware.h>"
+#endif
+
+#ifndef __ASM_COMCERTO_COMMON_H__
+#define __ASM_COMCERTO_COMMON_H__
+
+#include <asm/types.h>
+
+struct comcerto_tdm_data {
+	u8 fsoutput; /* Generic Pad Control and Version ID Register[2] */ 
+	u8 fspolarity; /*  28 FSYNC_FALL(RISE)_EDGE */
+	u16 fshwidth; /* High_Phase_Width[10:0] */
+	u16 fslwidth; /* Low_Phase_Width[26:16]] */
+	u32 clockhz; /* INC_VALUE[29:0] According to the desired TDM clock output frequency, this field should be configured */
+	u8 clockout; /* IO Control Register[21]  hardware or software control selection  IO Control Register[20] pads are input (output) */
+};
+
+/* L210 cache controller value 
+    // Configure Aux:
+    //   [11:9]=[8:6]=[2:0]=001 RAM LAT = 2 cycles 
+    //   [5:3]=000    Data write latency is 1
+    //   [12]=0       WRAP access is enabled
+    //   [16:13]=1000 8-way cache
+    //   [19:17]=001  16KB way
+    //   [20]=1       Event bus is enabled
+    //   [21]=1       Parity is enabled
+    //   [22]=0       Shared accesses treated as noncacheable
+    //   [23]=0       HPROT is used
+    //   [24]=1       Abort generation of exclusive access disabled  
+*/
+#endif
diff --git a/arch/arm/mach-comcerto/sysfstdm.c b/arch/arm/mach-comcerto/sysfstdm.c
new file mode 100644
index 0000000..d431edc
--- /dev/null
+++ b/arch/arm/mach-comcerto/sysfstdm.c
@@ -0,0 +1,255 @@
+ /*
+  *  Copyright (C) 2008 Mindspeed Technologies, Inc.
+  *
+  * This program is free software; you can redistribute it and/or modify
+  * it under the terms of the GNU General Public License as published by
+  * the Free Software Foundation; either version 2 of the License, or
+  * (at your option) any later version.
+  *
+  * This program is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  * GNU General Public License for more details.
+  *
+  * You should have received a copy of the GNU General Public License
+  * along with this program; if not, write to the Free Software
+  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+  */
+
+#include <linux/kernel.h>
+#include <linux/device.h>
+#include <linux/string.h>
+#include <linux/platform_device.h>
+#include <asm/io.h>
+#include <mach/comcerto-common.h>
+#include <asm/div64.h>
+
+
+static void fsync_output_set(unsigned int fsoutput)
+{
+	/* Generic Pad Control and Version ID Register[2] */ 
+	if (fsoutput)
+		__raw_writel(__raw_readl(COMCERTO_GPIO_PAD_CTRL) | (1 << 2), COMCERTO_GPIO_PAD_CTRL);
+	else
+		__raw_writel(__raw_readl(COMCERTO_GPIO_PAD_CTRL) & ~(1 << 2), COMCERTO_GPIO_PAD_CTRL);
+}
+
+static void fsync_polarity_set(unsigned int fspolarity)
+{
+	/* 28 FSYNC_FALL(RISE)_EDGE */
+	if (fspolarity)
+		__raw_writel(__raw_readl(COMCERTO_CLK_FSYNC_CNTRL) | (1 << 28), COMCERTO_CLK_FSYNC_CNTRL);
+	else
+		__raw_writel(__raw_readl(COMCERTO_CLK_FSYNC_CNTRL) & ~(1 << 28), COMCERTO_CLK_FSYNC_CNTRL);
+}
+
+static void fsync_lphase_set(u32 fslwidth)
+{
+	u32 val;
+
+	/* Low_Phase_Width[26:16]] 7ff- maximum */
+	if (fslwidth > 0x7FF) {
+		printk(KERN_ERR "%s: Low Phase width value is out of range %#x > 0x7FF", __func__, fslwidth);
+		return;
+	}
+
+	val = __raw_readl(COMCERTO_CLK_FSYNC_CNTRL) & ~(0x7FF << 16);
+	__raw_writel(val | ((fslwidth & 0x7FF) << 16), COMCERTO_CLK_FSYNC_CNTRL);
+}
+
+static void fsync_hphase_set(u32 fshwidth)
+{
+	u32 val;
+
+	/* High_Phase_Width[10:0]] 7ff- maximum */
+	if (fshwidth > 0x7FF) {
+		printk(KERN_ERR "%s: High Phase width value is out of range %#x > 0x7FF", __func__, fshwidth);
+		return;
+	}
+
+	val = __raw_readl(COMCERTO_CLK_FSYNC_CNTRL) & ~(0x7FF);
+	__raw_writel(val | ((fshwidth & 0x7FF)), COMCERTO_CLK_FSYNC_CNTRL);
+}
+
+#if defined(CONFIG_ARCH_M83XXX)
+#define COMCERTO_TDMGENERATED_CLK	(COMCERTO_PHYCLK * 1000000)
+#else
+#define COMCERTO_TDMGENERATED_CLK	COMCERTO_AHBCLK
+#endif
+
+static void clock_frequency_set(unsigned long clockhz)
+{
+	unsigned long long clc_data = clockhz;
+
+	/* get frequency resolution on an 32-bit accumulator */
+	clc_data = clc_data * (1ULL << 32) + COMCERTO_TDMGENERATED_CLK / 2;
+
+	do_div(clc_data, COMCERTO_TDMGENERATED_CLK);
+
+	__raw_writel((clc_data & 0x3FFFFFFF) | (__raw_readl(COMCERTO_CLK_TDM_CLK_CNTRL) & ~0x3FFFFFFF), COMCERTO_CLK_TDM_CLK_CNTRL);
+}
+
+static void clock_output_set(unsigned long clockout)
+{
+#if defined(CONFIG_ARCH_M83XXX)
+	switch (clockout) {
+	case 0:
+		__raw_writel((0x2 << 14) | (__raw_readl(COMCERTO_GPIO_BOOTSTRAP_OVERRIDE) & ~(0x3 << 14)), COMCERTO_GPIO_BOOTSTRAP_OVERRIDE);
+		break;
+	case 1:
+		__raw_writel((0x3 << 14) | (__raw_readl(COMCERTO_GPIO_BOOTSTRAP_OVERRIDE) & ~(0x3 << 14)), COMCERTO_GPIO_BOOTSTRAP_OVERRIDE);
+		break;
+	case 2:
+		__raw_writel((0x0 << 14) | (__raw_readl(COMCERTO_GPIO_BOOTSTRAP_OVERRIDE) & ~(0x3 << 14)), COMCERTO_GPIO_BOOTSTRAP_OVERRIDE);
+		break;
+	default:
+		printk(KERN_ERR "%s: Unknown clock output value\n", __func__);
+	}
+#else
+	/* Enable TDM block */
+	__raw_writel(0x55555555, COMCERTO_GPIO_LOCK_REG); /* Unlock COMCERTO_GPIO_IOCTRL_REG register write access */
+	switch (clockout) {
+	case 0:
+		__raw_writel((0x2 << 20) | (__raw_readl(COMCERTO_GPIO_IOCTRL_REG)& ~(0x3 << 20)), COMCERTO_GPIO_IOCTRL_REG);
+		break;
+	case 1:
+		__raw_writel((0x3 << 20) | (__raw_readl(COMCERTO_GPIO_IOCTRL_REG) & ~(0x3 << 20)), COMCERTO_GPIO_IOCTRL_REG);
+		break;
+	case 2:
+		__raw_writel((0x0 << 20) | (__raw_readl(COMCERTO_GPIO_IOCTRL_REG) & ~(0x3 << 20)), COMCERTO_GPIO_IOCTRL_REG);
+		break;
+	default:
+		printk(KERN_ERR "%s: Unknown clock output value \n", __func__);
+	}
+#endif
+}	
+
+static ssize_t tdm_data_read(struct device *dev,
+				  struct device_attribute *attr, char *buf)
+{
+	unsigned long long clc_data;
+
+	if (strcmp("fs_polarity", attr->attr.name) == 0) /* 28 FSYNC_FALL(RISE)_EDGE */
+		return sprintf(buf, "%d\n", (__raw_readl(COMCERTO_CLK_FSYNC_CNTRL) >> 28) & 0x1);
+	else if (strcmp("fs_lwidth", attr->attr.name) == 0) /* Low_Phase_Width[26:16]] */
+		return sprintf(buf, "%x\n", (__raw_readl(COMCERTO_CLK_FSYNC_CNTRL) >> 16) & 0x7FF);
+	else if (strcmp("fs_hwidth", attr->attr.name) == 0) /* High_Phase_Width[10:0] */
+		return sprintf(buf, "%x\n", (__raw_readl(COMCERTO_CLK_FSYNC_CNTRL) & 0x7FF));
+	else if (strcmp("fs_output", attr->attr.name) == 0) /* Generic Pad Control and Version ID Register[2] */
+		return sprintf(buf, "%d\n", (__raw_readl(COMCERTO_GPIO_PAD_CTRL) >> 2) & 0x1);
+	else if (strcmp("clock_output", attr->attr.name) == 0)
+#if defined(CONFIG_ARCH_M83XXX)
+		return sprintf(buf, "%d\n", (__raw_readl(COMCERTO_GPIO_SYSTEM_CONFIG) >> 9) & 0x1);
+#else
+		return sprintf(buf, "%d\n", (__raw_readl(COMCERTO_GPIO_SYSTEM_CONFIG) >> 7) & 0x1);
+#endif
+	else if (strcmp("clock_hz", attr->attr.name) == 0) {
+		/* INC_VALUE[29:0] According to the desired TDM clock output frequency, this field should be configured */
+		clc_data = (__raw_readl(COMCERTO_CLK_TDM_CLK_CNTRL) & 0x3FFFFFFF);/* get frequency from resolution on an 32-bit accumulator */
+		clc_data = (clc_data * COMCERTO_TDMGENERATED_CLK + (1ULL << 31)) >> 32;
+		return sprintf(buf, "%lu\n", (unsigned long) clc_data);
+	}
+	else
+	{
+		printk(KERN_ERR "%s: Unknown file attribute\n", __func__);
+		return -1;
+	}
+}
+
+static ssize_t tdm_data_write(struct device *dev,
+				 struct device_attribute *attr,
+				 const char *buf, size_t count)
+{
+	unsigned long tdm_data = simple_strtoul(buf, NULL, 0);
+
+	if (strcmp("fs_polarity", attr->attr.name) == 0)
+		fsync_polarity_set(tdm_data);
+	else if (strcmp("fs_lwidth", attr->attr.name) == 0)
+		fsync_lphase_set(tdm_data);
+	else if (strcmp("fs_hwidth", attr->attr.name) == 0)
+		fsync_hphase_set(tdm_data);
+	else if (strcmp("fs_output", attr->attr.name) == 0)
+		fsync_output_set(tdm_data);
+	else if (strcmp("clock_hz", attr->attr.name) == 0)
+		clock_frequency_set(tdm_data);
+	else if (strcmp("clock_output", attr->attr.name) == 0)
+		clock_output_set(tdm_data);
+	else
+		printk(KERN_ERR "%s: Unknown file attribute \n", __func__);
+
+	return count;
+}
+
+static struct device_attribute fsoutput_attr = __ATTR(fs_output, 0644, tdm_data_read, tdm_data_write);
+static struct device_attribute fspolarity_attr = __ATTR(fs_polarity, 0644, tdm_data_read, tdm_data_write);
+static struct device_attribute fshwidth_attr = __ATTR(fs_hwidth, 0644, tdm_data_read, tdm_data_write);
+static struct device_attribute fslwidth_attr = __ATTR(fs_lwidth, 0644, tdm_data_read, tdm_data_write);
+static struct device_attribute clockhz_attr = __ATTR(clock_hz, 0644, tdm_data_read, tdm_data_write);
+static struct device_attribute clockout_attr = __ATTR(clock_output, 0644, tdm_data_read, tdm_data_write);
+
+static int comcerto_tdm_probe(struct platform_device *pdev)
+{
+	struct comcerto_tdm_data *pdata = (struct comcerto_tdm_data *)pdev->dev.platform_data;
+	int ret = 0;
+
+	/* Inital configuration of tdm bus */
+	fsync_polarity_set(pdata->fspolarity);
+	fsync_lphase_set(pdata->fslwidth);
+	fsync_hphase_set(pdata->fshwidth);
+	clock_frequency_set(pdata->clockhz);
+	clock_output_set(pdata->clockout);
+	fsync_output_set(pdata->fsoutput);
+
+	__raw_writel((__raw_readl(COMCERTO_CLK_TDM_CLK_CNTRL) & ~(0x3 << 30)) | (0x2 << 30), COMCERTO_CLK_TDM_CLK_CNTRL);
+	__raw_writel((__raw_readl(COMCERTO_CLK_FSYNC_CNTRL) & ~(0x1 << 29)) | (0x1 << 29), COMCERTO_CLK_FSYNC_CNTRL);
+
+	/* Creating sysfs files */
+	ret |= device_create_file(&pdev->dev, &fsoutput_attr);
+	ret |= device_create_file(&pdev->dev, &fspolarity_attr);
+	ret |= device_create_file(&pdev->dev, &fshwidth_attr);
+	ret |= device_create_file(&pdev->dev, &fslwidth_attr);
+	ret |= device_create_file(&pdev->dev, &clockhz_attr);
+	ret |= device_create_file(&pdev->dev, &clockout_attr);
+
+	return ret;
+}
+
+static int comcerto_tdm_remove(struct platform_device *pdev)
+{
+	device_remove_file(&pdev->dev, &fsoutput_attr);
+	device_remove_file(&pdev->dev, &fspolarity_attr);
+	device_remove_file(&pdev->dev, &fshwidth_attr);
+	device_remove_file(&pdev->dev, &fslwidth_attr);
+	device_remove_file(&pdev->dev, &clockhz_attr);
+	device_remove_file(&pdev->dev, &clockout_attr);
+
+	return 0;
+}
+
+/* Structure for a device driver */
+static struct platform_driver comcerto_tdm_driver = {
+	.probe = comcerto_tdm_probe,
+	.remove = comcerto_tdm_remove,
+	.driver	= {
+		.name = "comcerto-tdm",
+	},
+};
+
+static int  comcerto_tdm_init(void)
+{
+	int ret = 0;
+
+	ret = platform_driver_register(&comcerto_tdm_driver);
+
+	return ret;
+}
+
+static void  comcerto_tdm_exit(void)
+{
+	platform_driver_unregister(&comcerto_tdm_driver);
+}
+
+module_init(comcerto_tdm_init);
+module_exit(comcerto_tdm_exit);
+
+MODULE_LICENSE("GPL");
-- 
1.7.0

