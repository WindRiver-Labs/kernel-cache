From 697c69b4cf365312761e1e5be7262271c0407098 Mon Sep 17 00:00:00 2001
From: Haiqing Bai <Haiqing.Bai@windriver.com>
Date: Mon, 16 May 2011 09:43:06 +0800
Subject: [PATCH 5/7] modified comcerto c1k csme protocol and other

Signed-off-by: Haiqing Bai <Haiqing.Bai@windriver.com>
---
 arch/arm/mach-comcerto/include/mach/debug.h  |   66 ++
 arch/arm/mach-comcerto/include/mach/memory.h |    3 +
 drivers/net/comcerto/Kconfig                 |    7 +-
 drivers/net/comcerto/Makefile                |    4 +-
 drivers/net/comcerto/c1000_eth.c             |    3 +
 drivers/net/comcerto/c1000_sysfs.c           |  109 +++
 drivers/net/comcerto/comcerto_fpp.c          |    1 +
 drivers/net/comcerto/comcerto_fpp.h          |    1 -
 drivers/net/comcerto/comcerto_msp.h          |    1 -
 drivers/net/comcerto/fci.c                   |  917 ++++++++++++++++++++++++++
 drivers/net/comcerto/fci.h                   |  143 ++++
 include/linux/netlink.h                      |    6 +-
 include/linux/skbuff.h                       |    8 +-
 include/net/flow.h                           |    7 +
 include/net/netns/xfrm.h                     |    3 +
 include/net/xfrm.h                           |   47 ++
 net/bridge/br_forward.c                      |    4 +
 net/core/flow.c                              |   78 +++
 net/core/skbuff.c                            |    3 +
 net/ipv4/Kconfig                             |    6 +
 net/ipv4/Makefile                            |    2 +-
 net/ipv4/ip_output.c                         |    5 +
 net/key/af_key.c                             |  724 ++++++++++++++++++++-
 net/xfrm/xfrm_input.c                        |   22 +
 net/xfrm/xfrm_output.c                       |   43 ++
 net/xfrm/xfrm_policy.c                       |  102 +++-
 net/xfrm/xfrm_state.c                        |   90 +++-
 27 files changed, 2385 insertions(+), 20 deletions(-)
 create mode 100644 arch/arm/mach-comcerto/include/mach/debug.h
 create mode 100644 drivers/net/comcerto/c1000_sysfs.c
 create mode 100644 drivers/net/comcerto/fci.c
 create mode 100644 drivers/net/comcerto/fci.h

diff --git a/arch/arm/mach-comcerto/include/mach/debug.h b/arch/arm/mach-comcerto/include/mach/debug.h
new file mode 100644
index 0000000..9cb5603
--- /dev/null
+++ b/arch/arm/mach-comcerto/include/mach/debug.h
@@ -0,0 +1,66 @@
+/*
+ *  arch/arm/mach-comcerto/include/mach/debug.h
+ *
+ *  Copyright (C) 2004,2005 Mindspeed Technologies, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef _DEBUG_H
+#define _DEBUG_H
+
+#include <linux/kernel.h>
+
+/* debug messages: to disable comment the next line */
+#define DEBUG_MSG
+
+/* several debug levels: 1 enables, 0 disables */
+
+#define DEBUG_ALWAYS 		1
+
+/* prints general information */
+#define DEBUG_INFO		1
+
+/* prints timing information */
+#define DEBUG_TIMING		0
+
+#define DEBUG_DISPLAY 		1
+
+#define VED_INIT_FUNC		1
+#define VED_RX_FUNC		0
+#define VED_TX_FUNC		0
+#define VED_STATE		0
+#define SMI_PART		0
+
+#define SKB_POOL_ERR		1
+#define SKB_POOL_INIT		0
+#define SKB_POOL_FUNC		0
+
+#define MSP_ERR			1
+#define MSP_INIT		0
+#define MSP_FUNC		0
+
+
+/* add other debug messages types here */
+
+/* the debug macro */
+#ifdef DEBUG_MSG
+#define info(fmt, args...) printk(KERN_INFO __FILE__ ": " fmt "\n" , ## args)
+#define PDEBUG(type, fmt, args...) do {if(type) info ("%d: " fmt, __LINE__ , ## args);} while(0)
+#else
+#define PDEBUG(type, fmt, args...) do{} while(0)
+#endif
+
+#endif	/* _DEBUG_H */
diff --git a/arch/arm/mach-comcerto/include/mach/memory.h b/arch/arm/mach-comcerto/include/mach/memory.h
index 9cd7413..e2fe498 100644
--- a/arch/arm/mach-comcerto/include/mach/memory.h
+++ b/arch/arm/mach-comcerto/include/mach/memory.h
@@ -30,6 +30,9 @@
 #define __pfn_to_bus(x)		__pfn_to_phys(x)
 #define __bus_to_pfn(x)		__phys_to_pfn(x)
 
+#define msp_to_virt(p)          (void*) ((unsigned long)p - SDRAM_MSP_MEMORY_PHY + SDRAM_MSP_MEMORY_VADDR)
+#define virt_to_msp(v)          ((unsigned long)v + SDRAM_MSP_MEMORY_PHY - SDRAM_MSP_MEMORY_VADDR)
+
 #define aram_to_virt(p)         (void *)(((unsigned long)p - COMCERTO_AHB_ARAM_BASE) + ARAM_MEMORY_VADDR)
 #define virt_to_aram(v)         (((unsigned long)v - ARAM_MEMORY_VADDR) + COMCERTO_AHB_ARAM_BASE)
 
diff --git a/drivers/net/comcerto/Kconfig b/drivers/net/comcerto/Kconfig
index e73bded..6de9b2a 100644
--- a/drivers/net/comcerto/Kconfig
+++ b/drivers/net/comcerto/Kconfig
@@ -11,7 +11,12 @@ config COMCERTO_ETH
 
 config COMCERTO_FPP
 	tristate "Mindspeed's Fast Packet Processor Driver"
-	depends on (ARCH_M83XXX || ARCH_M821XX)
+	depends on NET_COMCERTO
+	default m
+
+config COMCERTO_FCI
+	tristate "Mindspeed's Fast Control Interface Stack"
+	depends on NET_COMCERTO && COMCERTO_FPP
 	default m
 
 config COMCERTO_VED
diff --git a/drivers/net/comcerto/Makefile b/drivers/net/comcerto/Makefile
index d45b5cd..a5ab9a5 100644
--- a/drivers/net/comcerto/Makefile
+++ b/drivers/net/comcerto/Makefile
@@ -5,7 +5,7 @@ ifeq ($(CONFIG_ARCH_M821XX),y)
 endif
 ifeq ($(CONFIG_ARCH_M83XXX),y)
 	obj-$(CONFIG_COMCERTO_ETH) += c1000_fbpool.o c1000_eth.o c1000_gemac.o comcerto_gem_AL.o \
-                        comcerto_mii.o c1000_ethtool.o
+                        comcerto_mii.o c1000_ethtool.o c1000_sysfs.o
 endif
 
 obj-$(CONFIG_COMCERTO_VED) += comcerto_ved_driver.o
@@ -13,4 +13,6 @@ comcerto_ved_driver-objs := comcerto_ved.o comcerto_smi_part.o comcerto_smi_queu
 
 obj-$(CONFIG_COMCERTO_MSP_COREDUMP) += comcerto_coredump.o
 
+obj-$(CONFIG_COMCERTO_FCI) += fci.o
+
 obj-$(CONFIG_COMCERTO_FPP) += comcerto_fpp.o fpp_csme.o
diff --git a/drivers/net/comcerto/c1000_eth.c b/drivers/net/comcerto/c1000_eth.c
index 34f5731..6717ff6 100644
--- a/drivers/net/comcerto/c1000_eth.c
+++ b/drivers/net/comcerto/c1000_eth.c
@@ -74,6 +74,7 @@ extern int c1k_emac_checksum(struct eth_c1k_priv *priv, u32 status, u8 *ip_summe
 extern irqreturn_t c1k_gemac_interrupt(int irq, void *dev_id);
 extern void c1k_gemac_setduplex(struct net_device *dev, int duplex);
 extern void c1k_gemac_setspeed(struct net_device *dev, int speed);
+extern void c1k_init_sysfs(struct net_device *dev);
 
 extern int c1k_gemac_init(struct net_device *dev);
 
@@ -1427,6 +1428,8 @@ static int c1k_eth_probe(struct platform_device *pdev)
 	}
 
 	priv->default_priority = DEFAULT_PRIORITY;
+	/* Create all the sysfs files */
+	c1k_init_sysfs(dev);
 
 	/* Default Admittance block configuration */
 	priv->RxRingSize = DEFAULT_RX_DESC_NT;
diff --git a/drivers/net/comcerto/c1000_sysfs.c b/drivers/net/comcerto/c1000_sysfs.c
new file mode 100644
index 0000000..b0018bf
--- /dev/null
+++ b/drivers/net/comcerto/c1000_sysfs.c
@@ -0,0 +1,109 @@
+/*
+ * drivers/net/comcerto/ c1000_sysfs.c
+ *
+  *  Copyright (C) 2006 Mindspeed Technologies, Inc.
+  *
+  * This program is free software; you can redistribute it and/or modify
+  * it under the terms of the GNU General Public License as published by
+  * the Free Software Foundation; either version 2 of the License, or
+  * (at your option) any later version.
+  *
+  * This program is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  * GNU General Public License for more details.
+  *
+  * You should have received a copy of the GNU General Public License
+  * along with this program; if not, write to the Free Software
+  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+  */
+
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/errno.h>
+#include <linux/unistd.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/etherdevice.h>
+#include <linux/spinlock.h>
+#include <linux/mm.h>
+#include <linux/device.h>
+
+#include "c1000_eth.h"
+#include "comcerto_gemac.h"
+
+extern void c1k_eth_enable_fast_path(struct net_device *dev, unsigned short state);
+
+#define C1K_ATTR(_name) \
+static ssize_t c1k_show_##_name(struct device *dev, \
+	 struct device_attribute *attr, char *buf); \
+static ssize_t c1k_set_##_name(struct device *dev, \
+		struct device_attribute *attr, \
+		const char *buf, size_t count); \
+static DEVICE_ATTR(_name, 0644, c1k_show_##_name, c1k_set_##_name)
+
+#define C1K_CREATE_FILE(_dev, _name) \
+	device_create_file(&_dev->dev, &dev_attr_##_name)
+
+C1K_ATTR(default_priority);
+C1K_ATTR(fast_path_enable);
+
+
+static ssize_t c1k_show_default_priority(struct device *dev,
+				  struct device_attribute *attr, char *buf)
+{
+	struct eth_c1k_priv *priv = netdev_priv(to_net_dev(dev));
+
+	return sprintf(buf, "%d\n", priv->default_priority);
+}
+
+
+static ssize_t c1k_set_default_priority(struct device *dev,
+				 struct device_attribute *attr,
+				 const char *buf, size_t count)
+{
+	struct eth_c1k_priv *priv = netdev_priv(to_net_dev(dev));
+	priv->default_priority = simple_strtoul(buf, NULL, 0);
+	return count;
+}
+
+
+
+static ssize_t c1k_show_fast_path_enable(struct device *dev,
+				  struct device_attribute *attr, char *buf)
+{
+	struct eth_c1k_priv *priv = netdev_priv(to_net_dev(dev));
+
+	printk(KERN_INFO "%s\n", __func__);
+
+	return sprintf(buf, "%d\n", priv->fast_path_enabled);
+}
+
+
+static ssize_t c1k_set_fast_path_enable(struct device *dev,
+				 struct device_attribute *attr,
+				 const char *buf, size_t count)
+{
+	unsigned int state = simple_strtoul(buf, NULL, 0);
+
+	printk(KERN_INFO "%s %d\n", __func__, state);
+
+	c1k_eth_enable_fast_path(to_net_dev(dev), state);
+
+	return count;
+}
+
+
+void c1k_init_sysfs(struct net_device *dev)
+{
+	struct eth_c1k_priv *priv = netdev_priv(dev);
+
+	/* Initialize the default values */
+	priv->default_priority = DEFAULT_PRIORITY;
+	priv->fast_path_enabled = DEFAULT_FAST_PATH_STATE;
+	
+	/* Create our sysfs files */
+	C1K_CREATE_FILE(dev, default_priority);
+	C1K_CREATE_FILE(dev, fast_path_enable);
+}
diff --git a/drivers/net/comcerto/comcerto_fpp.c b/drivers/net/comcerto/comcerto_fpp.c
index 874aacf..8123903 100644
--- a/drivers/net/comcerto/comcerto_fpp.c
+++ b/drivers/net/comcerto/comcerto_fpp.c
@@ -219,6 +219,7 @@ int comcerto_fpp_register_event_cb(void *cb)
 
 	return 0;
 }
+EXPORT_SYMBOL(comcerto_fpp_register_event_cb);
 
 /**
  * comcerto_fpp_read - 
diff --git a/drivers/net/comcerto/comcerto_fpp.h b/drivers/net/comcerto/comcerto_fpp.h
index ef4cd87..43cc609 100644
--- a/drivers/net/comcerto/comcerto_fpp.h
+++ b/drivers/net/comcerto/comcerto_fpp.h
@@ -23,7 +23,6 @@
 
 #include <linux/firmware.h>
 #include <linux/elf.h>
-#include <mach/debug.h>
 #include <linux/netdevice.h>
 
 
diff --git a/drivers/net/comcerto/comcerto_msp.h b/drivers/net/comcerto/comcerto_msp.h
index 95a3fc4..91b16ab 100644
--- a/drivers/net/comcerto/comcerto_msp.h
+++ b/drivers/net/comcerto/comcerto_msp.h
@@ -23,7 +23,6 @@
 
 #include <linux/firmware.h>
 #include <linux/elf.h>
-#include <mach/debug.h>
 #include <linux/netdevice.h>
 
 /* copied from usr/include/elf.h */
diff --git a/drivers/net/comcerto/fci.c b/drivers/net/comcerto/fci.c
new file mode 100644
index 0000000..9649e5f
--- /dev/null
+++ b/drivers/net/comcerto/fci.c
@@ -0,0 +1,917 @@
+/*
+ *
+ *  Copyright (C) 2007 Mindspeed Technologies, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/version.h>
+#include <linux/socket.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/netlink.h>
+#include <linux/skbuff.h>
+#include <linux/proc_fs.h>
+#include <net/sock.h>
+//#include <net/fe.h>
+#include <linux/timer.h>
+#include <linux/time.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,33)
+#include <net/net_namespace.h>
+#endif
+#include "fci.h"
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Mindspeed Technologies");
+MODULE_DESCRIPTION("Fast Control Interface");
+
+static char __initdata fci_version[] = "0.02";
+
+/* Statics functions prototypes */
+static int fci_vop_inbound_parser(FCI_MSG *fci_msg);
+static int fci_fe_inbound_parser(FCI_MSG *fci_msg, struct sk_buff *skb);
+static int fci_handle_local_command(FCI_MSG *fci_msg);
+static void fci_dump_msg(FCI_MSG *fci_msg);
+static int fci_fe_register(void);
+static void fci_fe_unregister(void);
+#if LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,33)
+static void fci_fe_inbound_data(struct sk_buff *skb);
+static void fci_vop_inbound_data(struct sk_buff *skb);
+#else
+static void fci_fe_inbound_data(struct sock *sk, int len);
+static void fci_vop_inbound_data(struct sock *sk, int len);
+#endif
+static int fci_type_to_nl_type (int fci_nl_type);
+static int fci_fe_init(void);
+static void fci_fe_exit(void);
+
+/* Global struture managing the FCI module */
+FCI *this_fci;
+
+/* define FPP_FE to connect FCI driver to the FPP Forward Engine */
+/* if not defined the CSP Forward Engine is used */
+#define FPP_FE
+//#undef FPP_FE
+
+/* define FCI_STAT_TIMER to perform message rate measurment every second */
+#define FCI_STAT_TIMER
+//#undef FCI_STAT_TIMER
+
+/* define FCI_TX_TEST to simulate outbound message every second*/
+//#define FCI_TX_TEST
+#undef FCI_TX_TEST
+
+#ifdef FCI_STAT_TIMER
+void fci_msg_rate (unsigned long data);
+struct timer_list msg_rate_timer;
+unsigned long max_msg_rate = 0;
+unsigned long previous_rx_msg = 0;
+unsigned long previous_tx_msg = 0;
+#endif
+
+#ifdef FCI_TX_TEST
+void fci_tx_test (unsigned long data);
+struct timer_list tx_test_timer;
+#endif
+
+/************************** COMMON FUNCTIONS *********************************/
+
+/*
+ * fci_init -
+ *
+ *
+ */
+static int fci_init(void)
+{
+	int rc;
+
+	if ((this_fci = kmalloc (sizeof (FCI), GFP_KERNEL)) == NULL)
+	{
+		printk(KERN_ERR "FCI: out of memory (%d)\n", sizeof (FCI));
+
+		this_fci->stats.mem_alloc_err++;
+		rc = -ENOMEM;
+		goto err0;
+	}
+
+	/* zeroed the fci main structure */
+	memset(this_fci, 0, sizeof(FCI));
+
+	/* Initialize Fast Forward support in FCI */
+	if((rc = fci_fe_init()) < 0)
+	{
+		printk(KERN_ERR "FCI: fci_fe_init() failed\n");
+		goto err1;
+	}
+	
+	/* Open others required sockets here */
+
+	return 0;
+
+err1:
+	kfree(this_fci);
+err0:
+	return rc;
+}
+
+
+static void fci_exit(void)
+{
+	fci_fe_exit();
+
+	kfree(this_fci);
+}
+
+/*
+ * fci_open_netlink -
+ *
+ * Create new NETLINK socket for the given protocol 
+ */
+static int fci_open_netlink (unsigned long proto)
+{
+	FCI_PRINTK(FCI_NL, "fci_open_netlink() FCI type %ld\n", proto);
+
+	if(proto == FCI_NL_FF)
+	{			
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,33)
+		if((this_fci->fci_nl_sock[FCI_NL_FF] = netlink_kernel_create (&init_net, NETLINK_FF, NL_FF_GROUP, 
+									            fci_fe_inbound_data, NULL, THIS_MODULE)) == 0)
+#else
+		if((this_fci->fci_nl_sock[FCI_NL_FF] = netlink_kernel_create (NETLINK_FF, NL_FF_GROUP, fci_fe_inbound_data, THIS_MODULE)) == 0)
+#endif
+		{
+			this_fci->stats.kernel_create_err++;
+
+			return -ENOMEM;
+		}
+	}
+	else if(proto == FCI_NL_VOP)
+	{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,33)
+		if((this_fci->fci_nl_sock[FCI_NL_VOP] = netlink_kernel_create (&init_net, NETLINK_VOP, NL_VOP_GROUP, 
+									              fci_vop_inbound_data, NULL, THIS_MODULE)) == 0)
+#else
+		if((this_fci->fci_nl_sock[FCI_NL_VOP] = netlink_kernel_create (NETLINK_VOP, NL_VOP_GROUP, fci_vop_inbound_data, THIS_MODULE)) == 0)
+#endif
+		{
+			this_fci->stats.kernel_create_err++;
+
+			return -ENOMEM;
+		}
+	}
+	else
+	{
+		this_fci->stats.unknown_sock_type++;
+
+		return -ESOCKTNOSUPPORT;
+	}
+	
+	return 0;
+}
+
+static void fci_close_netlink (unsigned long proto)
+{
+	/* release netlink socket */
+	sock_release(this_fci->fci_nl_sock[proto]->sk_socket);
+}
+
+/*
+ * fci_outbound_data -
+ *
+ * This callback is invoked whenever the kernel space sends
+ * message to the user space.
+ */
+static int fci_outbound_data(int nl_type, struct sk_buff *skb, int group, int mode)
+{
+	struct nlmsghdr *nlh;
+	int msg_length = skb->len;
+	gfp_t allocation = in_interrupt() ? GFP_ATOMIC : GFP_KERNEL;
+	int rc = 0;
+
+	FCI_PRINTK(FCI_OUTBOUND, "\nfci_outbound_data() size=%d bytes, FCI nl_sock_type %d pid %d\n", msg_length, fci_type_to_nl_type(nl_type), group);
+
+	/* prepare netlink message for kernel to user space direction */
+	nlh = (struct nlmsghdr *)skb_push(skb, NLMSG_HDRLEN);
+
+	/* whole length of the message i.e. header + payload */
+	nlh->nlmsg_len = NLMSG_SPACE(msg_length);
+
+	/* add padding at the end if needed */
+	skb_put(skb, nlh->nlmsg_len - skb->len);
+
+	/* from kernel */
+	nlh->nlmsg_pid = 0;
+
+	nlh->nlmsg_flags = 0;
+
+	NETLINK_CB(skb).pid = 0;	/* from kernel */
+
+	/* if mode is zero then group is the client's pid used for unicast command response */
+	if(mode == FCI_UNICAST)
+	{
+		/* unicast */
+		NETLINK_CB(skb).dst_group = 0;	
+	
+		/* send message to user space process */
+		netlink_unicast (this_fci->fci_nl_sock[nl_type], skb, group, MSG_DONTWAIT);
+	}
+	else
+	{
+		/* send message only if at least one user space client is listening the socket */
+		if (netlink_has_listeners(this_fci->fci_nl_sock[nl_type], group))
+		{
+			/* the group we want to talk to */
+			NETLINK_CB(skb).dst_group = group;
+	
+			/* send message all user space listeners */
+			rc = netlink_broadcast(this_fci->fci_nl_sock[nl_type], skb, 0, group, allocation);
+			if (rc < 0)
+			{
+				if (printk_ratelimit())
+					printk(KERN_ERR "FCI: netlink_broadcast() failed (rc=%d)\n", rc);
+		
+				goto err_exit;
+			}
+		}
+		else
+		{
+			/* this skb has not been used */
+			kfree_skb(skb);
+		}
+	}
+
+	/* Update sucess stats */
+	this_fci->tx_seq++;
+
+	this_fci->stats.tx_msg++;
+
+	this_fci->stats.sock_stats[nl_type].tx_msg++;
+
+	return 0;
+
+err_exit:
+	/* Update error stats */
+	this_fci->stats.tx_msg_err++;
+
+	this_fci->stats.sock_stats[nl_type].tx_msg_err++;
+	
+	return rc;
+}
+
+
+/*
+ * fci_handle_local_command -
+ *
+ *
+ */
+static int fci_handle_local_command(FCI_MSG *fci_msg)
+{
+	return 0;
+}
+
+
+/*
+ * fci_get_msg_from_skb -
+ *
+ *
+ */
+FCI_MSG *fci_get_msg_from_skb(struct sk_buff *skb)
+{
+	struct nlmsghdr *nlh;
+	FCI_MSG *fci_msg;
+
+	/* process netlink message pointed by skb->data */
+	nlh = (struct nlmsghdr *)skb->data;
+
+	/* get message payload (i.e. the command we're waiting for) */
+	fci_msg = NLMSG_DATA(nlh);
+
+	fci_dump_msg(fci_msg);
+
+	return fci_msg;
+}
+
+
+static int fci_send_ack_data(int nl_sock_type, int pid, struct sk_buff *skb, u16 fcode, u16 ack_value)
+{
+	FCI_MSG *fci_msg;
+	int length = skb->len;
+	int rc;
+
+	skb_push(skb, FCI_MSG_HDR_SIZE);
+
+	fci_msg = (FCI_MSG *)skb->data;
+
+	fci_msg->fcode = fcode;
+	if (length >= 2) {
+		/* Overwrite the first word on the payload */
+		fci_msg->length = length;
+		fci_msg->payload[0] = ack_value;
+	} else {
+		/* Add one word to the payload */
+		fci_msg->length = 2;
+		fci_msg->payload[0] = ack_value;
+		skb_put(skb, 2);
+	}
+
+	FCI_PRINTK(FCI_ACK, "fci_send_ack_data(): sending ack data ack_value=0x%x: socket id %d extra bytes: %d\n", ack_value, pid, length);
+
+	fci_dump_msg(fci_msg);
+
+	if ((rc = fci_outbound_data(nl_sock_type, skb, pid, FCI_UNICAST)) < 0)
+	{
+		printk(KERN_ERR "FCI: fci_outbound_data() failed for acknowledgement\n");
+
+		return rc;
+	}
+
+	return 0;
+}
+
+/*
+ * fci_send_ack -
+ *
+ */
+static int fci_send_ack(int nl_sock_type, int pid, struct sk_buff *skb, u16 fcode, u16 ack_value)
+{
+	return fci_send_ack_data(nl_sock_type, pid, skb, fcode, ack_value);
+}
+
+
+/*
+ * fci_dump_msg -
+ *
+ *
+ */
+static void fci_dump_msg(FCI_MSG *fci_msg)
+{
+	int i;
+
+	FCI_PRINTK(FCI_DUMP, "fci msg: fcode 0x%04x size %d bytes -> ", fci_msg->fcode, fci_msg->length);
+
+	for(i = 0; i < fci_msg->length / 2; i++)
+		FCI_PRINTK(FCI_DUMP, "%04x ", fci_msg->payload[i]);
+
+	FCI_PRINTK(FCI_DUMP, "\n");
+}
+
+
+/*
+ * fci_type_to_nl_type -
+ *
+ *
+ */
+static int fci_type_to_nl_type (int fci_nl_type)
+{
+	int nl_type;
+
+	switch(fci_nl_type)
+	{
+		case FCI_NL_FF:
+			nl_type = NETLINK_FF;
+		break;
+
+		case FCI_NL_VOP:
+			nl_type = NETLINK_VOP;
+		break;
+
+		default:
+			nl_type = -1;
+		break;
+	}
+
+	return nl_type;
+}
+
+
+
+/****************************** Fast Forward Support ********************************/
+
+/*
+ * fci_fe_init -
+ *
+ *
+ */
+static int fci_fe_init(void)
+{
+	int rc;
+
+	/* Create netlink socket for Fast Forward */
+	if((rc = fci_open_netlink((unsigned long) FCI_NL_FF)) < 0)
+	{
+		printk(KERN_ERR "FCI: fci_open_netlink() failed (FCI type %d)\n", FCI_NL_FF);
+		goto err0;
+	}
+
+	/* Connect to the Forward Engine */
+	if((rc = fci_fe_register()) < 0)
+	{
+		printk(KERN_ERR "FCI: fci_fe_register() failed\n");	
+		goto err1;
+	}
+
+	return 0;
+
+err1:
+	fci_close_netlink(FCI_NL_FF);
+err0:
+	return rc;
+}
+
+/*
+ * fci_fe_exit -
+ *
+ *
+ */
+static void fci_fe_exit(void)
+{
+	fci_fe_unregister();
+	fci_close_netlink(FCI_NL_FF);
+}
+
+
+/*
+ * fci_fe_register -
+ *
+ */
+static int fci_fe_register(void)
+{
+	int rc;
+	/* register the FCI module to the FPP Forward Engine */
+	if((rc = comcerto_fpp_register_event_cb((void *)fci_outbound_fe_data)) < 0)
+	{
+		printk(KERN_ERR "FCI: fpp_register_event_cb() failed !\n");
+
+		return rc;
+	}
+	return 0;
+}
+
+/*
+ * fci_fe_unregister -
+ *
+ */
+static void fci_fe_unregister(void)
+{
+	/* disconect FCI module from the FPP Forward Engine */
+	comcerto_fpp_register_event_cb(NULL);
+}
+
+/*
+ * fci_alloc_msg - allocates a skb suitable for containing a FCI netlink message
+ *
+ */
+static struct sk_buff *fci_alloc_msg(void)
+{
+	struct sk_buff *skb;
+	gfp_t allocation = in_interrupt() ? GFP_ATOMIC : GFP_KERNEL;
+	int align;
+
+	skb = alloc_skb(NLMSG_SPACE(FCI_MSG_SIZE) + NLMSG_ALIGNTO, allocation);
+	if (!skb)
+	{
+		printk(KERN_ERR "FCI: alloc_skb() failed\n");
+
+		this_fci->stats.mem_alloc_err++;
+
+		goto err;
+	}
+
+	/* make sure the skb is aligned */
+	align = NLMSG_ALIGN((unsigned long)skb->data) - (unsigned long)skb->data;
+	skb_reserve(skb, align);
+
+	/* reserve enough room for netlink header */
+	skb_reserve(skb, NLMSG_HDRLEN);
+
+	return skb;
+
+err:
+	return NULL;
+}
+
+/*
+ * fci_outbound_fe_data -
+ *
+ * This callback is invoked whenever the forward engine sends
+ * message to the user space.
+ */
+int fci_outbound_fe_data(u16 fcode, u16 len, u16 *payload)
+{
+	FCI_MSG *fci_msg;
+	struct sk_buff *skb;
+	int rc;
+
+	FCI_PRINTK(FCI_OUTBOUND, "\nFCI: fci_outbound_fe_data()\n");
+
+	skb = fci_alloc_msg();
+	if (!skb)
+	{
+		this_fci->stats.rx_msg_err++;
+		rc = -ENOMEM;
+		goto err;
+	}
+
+	fci_msg = (FCI_MSG *)skb->data;
+
+	fci_msg->fcode = fcode;
+	fci_msg->length = len;
+
+	/* build fci message with sender's data */
+	memcpy(fci_msg->payload, payload, len);
+
+	skb_put(skb, len + FCI_MSG_HDR_SIZE);
+
+	/* pass data to the netlink subsystem */
+	return fci_outbound_data(FCI_NL_FF, skb, NL_FF_GROUP, FCI_MULTICAST);
+
+err:
+	return rc;
+}
+
+/*
+ * fci_fe_inbound_data -
+ *
+ * This callback is invoked whenever the user space sends a netlink
+ * message of the NETLINK_FF protocol type to the kernel.
+ */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,33)
+void fci_fe_inbound_data(struct sk_buff *skb)
+{
+	struct sk_buff *nskb;
+	FCI_MSG *fci_msg;
+	int rc;
+
+	FCI_PRINTK(FCI_INBOUND, "\nFCI: fci_fe_inbound_data()\n");
+
+	/* extract fci message from skb */
+	fci_msg = fci_get_msg_from_skb(skb);
+
+	this_fci->stats.rx_msg++;
+
+	this_fci->stats.sock_stats[FCI_NL_FF].rx_msg++;
+
+	nskb = fci_alloc_msg();
+	if (nskb)
+	{
+
+		/* reserve space to add the fci header */
+		skb_reserve(nskb, FCI_MSG_HDR_SIZE);
+
+		/* Process command received from User Space */
+		rc = fci_fe_inbound_parser(fci_msg, nskb);
+		if (rc < 0)
+			this_fci->stats.rx_msg_err++;
+
+		fci_send_ack_data(FCI_NL_FF, NETLINK_CB(skb).pid, nskb, fci_msg->fcode, rc);
+	}
+	else
+		this_fci->stats.rx_msg_err++;
+}
+#else /* LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,33) */
+void fci_fe_inbound_data(struct sock *sk, int len)
+{
+	struct sk_buff *skb, *nskb;
+	FCI_MSG *fci_msg;
+	int rc;
+
+	FCI_PRINTK(FCI_INBOUND, "\nFCI: fci_fe_inbound_data()\n");
+
+	while((skb = skb_dequeue(&sk->sk_receive_queue)))
+	{
+		/* extract fci message from skb */
+		fci_msg = fci_get_msg_from_skb(skb);
+
+		this_fci->stats.rx_msg++;
+
+		this_fci->stats.sock_stats[FCI_NL_FF].rx_msg++;
+
+		nskb = fci_alloc_msg();
+		if (nskb)
+		{
+
+			/* reserve space to add the fci header */
+			skb_reserve(nskb, FCI_MSG_HDR_SIZE);
+
+			/* Process command received from User Space */
+			rc = fci_fe_inbound_parser(fci_msg, nskb);
+			if (rc < 0)
+				this_fci->stats.rx_msg_err++;
+
+			fci_send_ack_data(FCI_NL_FF, NETLINK_CB(skb).pid, nskb, fci_msg->fcode, rc);
+		}
+		else
+			this_fci->stats.rx_msg_err++;
+
+		kfree_skb(skb);
+	}
+}
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,33) */
+
+/*
+ * fci_fe_inbound_parser -
+ *
+ *
+ */
+static int fci_fe_inbound_parser(FCI_MSG *fci_msg, struct sk_buff *skb)
+{
+	u16 rlen;
+	int rc;
+
+	FCI_PRINTK(FCI_INBOUND, "FCI: fci_fe_inbound_parser()\n");
+
+	/* check if command if for local use (i.e. FCI control) */
+	if((fci_msg->fcode & FCI_LOCAL_CMD_MASK) == FCI_LOCAL_CMD_MASK)
+	{
+		rc = fci_handle_local_command(fci_msg);
+	}
+	
+	/* Send payload to the Forward Engine command parser */
+	else
+	{
+		FCI_PRINTK(FCI_INBOUND, "FCI: fci_fe_inbound_parser()\n");
+		rlen = 0;
+		rc = fpp_command_parser(fci_msg->fcode, fci_msg->length, fci_msg->payload, &rlen, (u16 *)skb->data);
+
+		if (rlen > FCI_MSG_MAX_PAYLOAD)
+			rlen = FCI_MSG_MAX_PAYLOAD;
+
+		skb_put(skb, rlen);
+	}
+
+	return rc;
+}
+
+
+/***************************** MINDSPEED VOP API SUPPORT ********************************/
+
+/*
+ * fci_vop_inbound_data -
+ *
+ * This callback is invoked whenever the user space sends a netlink
+ * message of the NETLINK_VOP protocol type to the kernel.
+ */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,33)
+void fci_vop_inbound_data(struct sk_buff *skb)
+{
+	struct sk_buff *nskb;
+	FCI_MSG *fci_msg;
+	int rc;
+
+	FCI_PRINTK(FCI_INBOUND, "\nFCI: fci_vop_inbound_data()\n");
+
+	/* extract fci message from skb */
+	fci_msg = fci_get_msg_from_skb(skb);
+		
+	this_fci->stats.rx_msg++;
+
+	this_fci->stats.sock_stats[FCI_NL_VOP].rx_msg++;
+
+	nskb = fci_alloc_msg();
+	if (nskb) {
+		/* reserve space to add the fci header and return code later on */
+		skb_reserve(nskb, FCI_MSG_HDR_SIZE);
+
+		/* Process command received from User Space */
+		rc = fci_vop_inbound_parser(fci_msg);
+
+		fci_send_ack(FCI_NL_VOP, NETLINK_CB(skb).pid, nskb, fci_msg->fcode, rc);
+	} else
+		this_fci->stats.rx_msg_err++;
+}
+#else /* LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,33) */
+void fci_vop_inbound_data(struct sock *sk, int len)
+{
+	struct sk_buff *skb, *nskb;
+	FCI_MSG *fci_msg;
+	int rc;
+
+	FCI_PRINTK(FCI_INBOUND, "\nFCI: fci_vop_inbound_data()\n");
+
+	while((skb = skb_dequeue(&sk->sk_receive_queue)) != NULL)
+	{
+		/* extract fci message from skb */
+		fci_msg = fci_get_msg_from_skb(skb);
+		
+		this_fci->stats.rx_msg++;
+	
+		this_fci->stats.sock_stats[FCI_NL_VOP].rx_msg++;
+
+		nskb = fci_alloc_msg();
+		if (nskb) {
+			/* reserve space to add the fci header and return code later on */
+			skb_reserve(nskb, FCI_MSG_HDR_SIZE);
+
+			/* Process command received from User Space */
+			rc = fci_vop_inbound_parser(fci_msg);
+
+			fci_send_ack(FCI_NL_VOP, NETLINK_CB(skb).pid, nskb, fci_msg->fcode, rc);
+		} else
+			this_fci->stats.rx_msg_err++;
+
+		kfree_skb(skb);
+	}
+}
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,33) */
+
+/*
+ * fci_vop_inbound_parser -
+ *
+ *
+ */
+static int fci_vop_inbound_parser(FCI_MSG *fci_msg)
+{
+	int rc = 0;
+
+	FCI_PRINTK(FCI_INBOUND, "FCI: fci_vop_inbound_parser()\n");
+
+	/* check if command if for local use (i.e. FCI control) */
+	if((fci_msg->fcode & FCI_LOCAL_CMD_MASK) == FCI_LOCAL_CMD_MASK)
+	{
+		rc = fci_handle_local_command(fci_msg);
+	}
+
+	/* Send payload to the MSP command parser */
+	else
+	{
+		//rc = data_to_msp(fci_msg->fcode, fci_msg->length, fci_msg->payload);
+	}
+
+	return rc;
+}
+
+
+/***************************** MISCS FUNCTIONS ********************************/
+
+/**
+ *  fci_proc_info -
+ *
+ *
+ */
+int fci_proc_info(char* page, char** start, off_t off, int count, int *eof, void* data)
+{
+	int len = 0;
+	
+	len += sprintf(page+len, "\n");
+	len += sprintf(page+len, "FCI Messages:\n");
+	len += sprintf(page+len, "Sent:%ld\n", this_fci->stats.tx_msg);
+	len += sprintf(page+len, "Received:%ld\n", this_fci->stats.rx_msg);
+	len += sprintf(page+len, "Sent errors:%ld\n", this_fci->stats.tx_msg_err);
+	len += sprintf(page+len, "Received errors:%ld\n", this_fci->stats.rx_msg_err);
+#ifdef FCI_STAT_TIMER
+	len += sprintf(page+len, "Max messages per second: %ld\n", max_msg_rate);
+#endif
+	len += sprintf(page+len, "\n");
+	len += sprintf(page+len, "Fast Forward Messages:\n");
+	len += sprintf(page+len, "Sent:%ld\n", this_fci->stats.sock_stats[FCI_NL_FF].tx_msg);
+	len += sprintf(page+len, "Received:%ld\n", this_fci->stats.sock_stats[FCI_NL_FF].rx_msg);
+	len += sprintf(page+len, "Sent errors:%ld\n", this_fci->stats.sock_stats[FCI_NL_FF].tx_msg_err);
+	len += sprintf(page+len, "Received errors:%ld\n", this_fci->stats.sock_stats[FCI_NL_FF].rx_msg_err);
+	len += sprintf(page+len, "\n");
+	/*
+	len += sprintf(page+len, "MSP VoP Messages:\n");
+	len += sprintf(page+len, "Sent:%ld\n", this_fci->stats.sock_stats[FCI_NL_VOP].tx_msg);
+	len += sprintf(page+len, "Received:%ld\n", this_fci->stats.sock_stats[FCI_NL_VOP].rx_msg);
+	len += sprintf(page+len, "Sent errors:%ld\n", this_fci->stats.sock_stats[FCI_NL_VOP].tx_msg_err);
+	len += sprintf(page+len, "Received errors:%ld\n", this_fci->stats.sock_stats[FCI_NL_VOP].rx_msg_err);
+	*/
+	len += sprintf(page+len, "\n");
+	len += sprintf(page+len, "Errors:\n");
+	len += sprintf(page+len, "Memory allocation errors:%ld\n", this_fci->stats.mem_alloc_err);
+	len += sprintf(page+len, "Kernel socket creation errors:%ld\n", this_fci->stats.kernel_create_err);
+	len += sprintf(page+len, "Unknow socket type:%ld\n", this_fci->stats.unknown_sock_type);
+
+	return len;
+}
+
+
+#ifdef FCI_TX_TEST
+/*
+ * fci_tx_test -
+ *
+ */
+void fci_tx_test (unsigned long data)
+{
+	u16 fcode = 0x7777;
+	u16 payload[2] = {0x1234, 0xabcd};
+
+	/* multicast test */
+	fci_outbound_fe_data(fcode, sizeof(payload), payload);
+
+	tx_test_timer.expires = jiffies + (1 * HZ / 10);
+
+	add_timer(&tx_test_timer);
+}
+#endif
+
+
+#ifdef FCI_STAT_TIMER
+/*
+ * fci_msg_rate -
+ *
+ */
+void fci_msg_rate (unsigned long data)
+{
+	unsigned long num_msg = 0;
+
+	num_msg = (this_fci->stats.rx_msg - previous_rx_msg) + (this_fci->stats.tx_msg - previous_tx_msg);
+
+	if(max_msg_rate < num_msg)
+	{
+		max_msg_rate = num_msg;
+	}
+
+	previous_rx_msg = this_fci->stats.rx_msg;
+	previous_tx_msg = this_fci->stats.tx_msg;
+	
+	msg_rate_timer.expires = jiffies + (1 * HZ);
+
+	add_timer(&msg_rate_timer);
+}
+#endif
+
+
+/*
+ * fci_module_init -
+ *
+ */
+static int fci_module_init(void)
+{
+	int rc;
+
+	FCI_PRINTK(FCI_INIT, "Initializing Fast Control Interface v%s\n", fci_version);
+
+	if((rc = fci_init()) < 0)
+	{
+		printk(KERN_ERR "FCI: fci init failed\n");
+	
+		return rc;
+	}
+
+	/* Create /proc/fci entry */
+	create_proc_read_entry("fci", 0, 0, fci_proc_info, NULL);
+
+#ifdef FCI_STAT_TIMER
+        init_timer (&msg_rate_timer);
+
+	msg_rate_timer.function = fci_msg_rate;
+
+	msg_rate_timer.expires = jiffies + (1 * HZ);
+
+        add_timer(&msg_rate_timer);
+#endif
+
+#ifdef FCI_TX_TEST
+	FCI_PRINTK(FCI_INIT, "FCI Self Tx Test is running (10 message/sec)\n");
+
+        init_timer (&tx_test_timer);
+
+	tx_test_timer.function = fci_tx_test;
+
+	tx_test_timer.expires = jiffies + (1 * HZ / 10);
+
+        add_timer(&tx_test_timer);
+#endif
+
+	return 0;
+}
+
+
+/*
+ * fci_module_exit -
+ *
+ */
+static void fci_module_exit(void)
+{
+	FCI_PRINTK(FCI_INIT, "Unloading Fast Control Interface\n");
+
+#ifdef FCI_TX_TEST
+	del_timer(&tx_test_timer);
+#endif
+
+#ifdef FCI_STAT_TIMER
+	del_timer(&msg_rate_timer);
+#endif
+
+	/* Remove /proc/fci entry */
+	remove_proc_entry("fci", NULL);
+
+	/* clean-up before leaving */
+	fci_exit();
+}
+
+
+module_init(fci_module_init);
+module_exit(fci_module_exit);
diff --git a/drivers/net/comcerto/fci.h b/drivers/net/comcerto/fci.h
new file mode 100644
index 0000000..18aaba8
--- /dev/null
+++ b/drivers/net/comcerto/fci.h
@@ -0,0 +1,143 @@
+/*
+ *
+ *  Copyright (C) 2007 Mindspeed Technologies, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef _FCI_H
+#define _FCI_H
+
+/*
+* Prototypes
+*/
+
+/* CSP Forward Engine API */
+// extern int fe_register_ops(t_fe_ops *fe_ops);
+extern int fe_deregister_ops(void);
+extern int fe_command_parser(unsigned short fcode, unsigned short length, unsigned short *payload);
+
+/* FPP Forward Engine API*/
+extern int fpp_command_parser(unsigned short fcode, unsigned short length, unsigned short *payload, unsigned short *, unsigned short *);
+extern int comcerto_fpp_register_event_cb(void *cb);
+
+/* FCI functions public functions */
+int fci_outbound_fe_data(unsigned short fcode, unsigned short len, unsigned short *payload);
+int fci_proc_info(char* page, char** start, off_t off, int count, int *eof, void* data);
+
+#ifndef NETLINK_FF
+#define NETLINK_FF 30
+#endif
+
+#ifndef NETLINK_VOP
+#define NETLINK_VOP 31
+#endif
+
+#ifndef NETLINK_KEY
+#define NETLINK_KEY 32
+#endif
+
+
+/*
+* Debug macros
+*/
+
+#define FCI_PRINT	0
+#define FCI_INIT	0
+#define FCI_STAT	0
+#define FCI_OUTBOUND	0
+#define FCI_INBOUND	0
+#define FCI_DUMP	0
+#define FCI_NL		0
+#define FCI_ACK		0
+
+#ifdef FCI_PRINT
+#define FCI_PRINTK(type, info, args...) do {if(type) printk(KERN_DEBUG info, ## args);} while(0);
+#else
+#define FCI_PRINTK(type, info, args...) do {} while(0);
+#endif
+
+/* Numbers of user space clients the FCI module can handles */
+#define FCI_MAX_CLIENT		8
+
+/* Supported netlink protocol type NETLINK_FF, NETLINK_VOP */
+#define FCI_NL_FF		0
+#define FCI_NL_VOP		1
+#define FCI_MAX_PROTO		2 
+
+/* unicast/ multicast definitions */
+#define FCI_UNICAST		0
+#define FCI_MULTICAST		1
+
+/* Netlink multicast groups supported by FCI */
+#define NL_FF_GROUP	1
+#define NL_VOP_GROUP	2
+
+/* FCI message definitions*/
+#define FCI_MSG_MAX_PAYLOAD	256
+#define FCI_MSG_HDR_SIZE 	4 /* fcode + length */
+#define FCI_MSG_SIZE		(FCI_MSG_MAX_PAYLOAD + FCI_MSG_HDR_SIZE)
+
+/* Some function codes understood by the FCI module */
+#define FCI_LOCAL_CMD_MASK	0xFC00
+
+/*
+* Structures
+*
+*/
+typedef struct t_FCI_MSG
+{
+	/* message data */
+	unsigned short fcode;
+	unsigned short length;
+	unsigned short payload[(FCI_MSG_MAX_PAYLOAD/sizeof(unsigned short))];
+} FCI_MSG;
+
+
+typedef struct t_FCI_SOCK_STATS
+{
+	unsigned long tx_msg;
+	unsigned long rx_msg;
+	unsigned long tx_msg_err;
+	unsigned long rx_msg_err;
+} FCI_SOCK_STATS;
+
+
+typedef struct t_FCI_STATS
+{
+	/* Globlas Statistics*/
+	unsigned long tx_msg;
+	unsigned long rx_msg;
+	unsigned long tx_msg_err;
+	unsigned long rx_msg_err;
+	unsigned long mem_alloc_err;
+	unsigned long kernel_create_err;
+	unsigned long unknown_sock_type;
+	/* Per socket type statistics*/
+	FCI_SOCK_STATS sock_stats[FCI_MAX_PROTO];
+} FCI_STATS;
+
+
+typedef struct t_FCI
+{
+	struct sock *fci_nl_sock[FCI_MAX_PROTO];
+	FCI_STATS stats;
+	unsigned long tx_seq;
+	unsigned long rx_seq;
+} FCI;
+
+
+
+#endif /* _FCI_H */
diff --git a/include/linux/netlink.h b/include/linux/netlink.h
index 59d0669..00b0d7e 100644
--- a/include/linux/netlink.h
+++ b/include/linux/netlink.h
@@ -24,8 +24,12 @@
 /* leave room for NETLINK_DM (DM Events) */
 #define NETLINK_SCSITRANSPORT	18	/* SCSI Transports */
 #define NETLINK_ECRYPTFS	19
+#define NETLINK_FF              30
+#define NETLINK_VOP             31
+#define NETLINK_KEY             32
+
+#define MAX_LINKS 33		
 
-#define MAX_LINKS 32		
 
 struct net;
 
diff --git a/include/linux/skbuff.h b/include/linux/skbuff.h
index ae43750..f3e6aa8 100644
--- a/include/linux/skbuff.h
+++ b/include/linux/skbuff.h
@@ -351,7 +351,9 @@ struct sk_buff {
 				nf_trace:1;
 	kmemcheck_bitfield_end(flags1);
 	__be16			protocol;
-
+#if defined(CONFIG_INET_IPSEC_OFFLOAD) || defined(CONFIG_INET6_IPSEC_OFFLOAD)
+	__u32			ipsec_offload;
+#endif
 	void			(*destructor)(struct sk_buff *skb);
 #if defined(CONFIG_NF_CONNTRACK) || defined(CONFIG_NF_CONNTRACK_MODULE)
 	struct nf_conntrack	*nfct;
@@ -1369,8 +1371,12 @@ static inline int skb_network_offset(const struct sk_buff *skb)
  * headroom, you should not reduce this.
  */
 #ifndef NET_SKB_PAD
+#if defined(CONFIG_ARCH_M83XXX)
+#define NET_SKB_PAD	128
+#else
 #define NET_SKB_PAD	32
 #endif
+#endif
 
 extern int ___pskb_trim(struct sk_buff *skb, unsigned int len);
 
diff --git a/include/net/flow.h b/include/net/flow.h
index 809970b..96d1c13 100644
--- a/include/net/flow.h
+++ b/include/net/flow.h
@@ -89,8 +89,15 @@ struct sock;
 typedef int (*flow_resolve_t)(struct net *net, struct flowi *key, u16 family,
 			      u8 dir, void **objp, atomic_t **obj_refp);
 
+#if defined(CONFIG_INET_IPSEC_OFFLOAD) || defined(CONFIG_INET6_IPSEC_OFFLOAD)
+extern void *flow_cache_lookup(struct net *net, struct flowi *key, u16 family,
+			       u8 dir, u8 *new_flow, flow_resolve_t resolver);
+extern void flow_cache_remove(struct flowi *fl, 
+				unsigned short family, unsigned short dir);
+#else
 extern void *flow_cache_lookup(struct net *net, struct flowi *key, u16 family,
 			       u8 dir, flow_resolve_t resolver);
+#endif
 extern void flow_cache_flush(void);
 extern atomic_t flow_cache_genid;
 
diff --git a/include/net/netns/xfrm.h b/include/net/netns/xfrm.h
index 74f119a..7b03183 100644
--- a/include/net/netns/xfrm.h
+++ b/include/net/netns/xfrm.h
@@ -27,6 +27,9 @@ struct netns_xfrm {
 	struct hlist_head	*state_bydst;
 	struct hlist_head	*state_bysrc;
 	struct hlist_head	*state_byspi;
+#if defined(CONFIG_INET_IPSEC_OFFLOAD) || defined(CONFIG_INET6_IPSEC_OFFLOAD)
+	struct hlist_head	*state_byh;
+#endif
 	unsigned int		state_hmask;
 	unsigned int		state_num;
 	struct work_struct	state_hash_work;
diff --git a/include/net/xfrm.h b/include/net/xfrm.h
index 70be8e3..bea7c4a 100644
--- a/include/net/xfrm.h
+++ b/include/net/xfrm.h
@@ -135,7 +135,11 @@ struct xfrm_state {
 	};
 	struct hlist_node	bysrc;
 	struct hlist_node	byspi;
+#if defined(CONFIG_INET_IPSEC_OFFLOAD) || defined(CONFIG_INET6_IPSEC_OFFLOAD)
+	struct hlist_node 	byh;
 
+	u16			handle;
+#endif
 	atomic_t		refcnt;
 	spinlock_t		lock;
 
@@ -224,6 +228,11 @@ struct xfrm_state {
 	/* Private data of this transformer, format is opaque,
 	 * interpreted by xfrm_type methods. */
 	void			*data;
+#if defined(CONFIG_INET_IPSEC_OFFLOAD) || defined(CONFIG_INET6_IPSEC_OFFLOAD)
+	 /* Intended direction of this state, used for offloading */
+	int	dir;
+	int	offloaded;	
+#endif
 };
 
 static inline struct net *xs_net(struct xfrm_state *x)
@@ -243,6 +252,13 @@ enum {
 	XFRM_STATE_EXPIRED,
 	XFRM_STATE_DEAD
 };
+#if defined(CONFIG_INET_IPSEC_OFFLOAD) || defined(CONFIG_INET6_IPSEC_OFFLOAD)
+enum {
+	 XFRM_STATE_DIR_UNKNOWN,
+	 XFRM_STATE_DIR_IN,
+	 XFRM_STATE_DIR_OUT,
+};
+#endif
 
 /* callback structure passed from either netlink or pfkey */
 struct km_event {
@@ -286,6 +302,9 @@ struct xfrm_policy_afinfo {
 
 extern int xfrm_policy_register_afinfo(struct xfrm_policy_afinfo *afinfo);
 extern int xfrm_policy_unregister_afinfo(struct xfrm_policy_afinfo *afinfo);
+#if defined(CONFIG_INET_IPSEC_OFFLOAD) || defined(CONFIG_INET6_IPSEC_OFFLOAD)
+extern struct xfrm_policy_afinfo *xfrm_policy_get_afinfo(unsigned short family);
+#endif
 extern void km_policy_notify(struct xfrm_policy *xp, int dir, struct km_event *c);
 extern void km_state_notify(struct xfrm_state *x, struct km_event *c);
 
@@ -916,6 +935,34 @@ struct sec_path {
 	struct xfrm_state	*xvec[XFRM_MAX_DEPTH];
 };
 
+#if defined(CONFIG_INET_IPSEC_OFFLOAD) || defined(CONFIG_INET6_IPSEC_OFFLOAD)
+struct xfrm_input_shared
+{
+	struct sk_buff 		*skb;
+	int 			xfrm_nr, first, xfrm_encap;
+	struct xfrm_state 	*xfrm_vec[XFRM_MAX_DEPTH];
+	__u16 			encap_type;
+	int 			decaps;
+	u32			seq, spi;
+	unsigned int   nhoff;
+	int 			nexthdr;
+	int 			(*callback)(struct xfrm_input_shared *sh);
+	atomic_t		refcnt;
+};
+
+
+static inline void xfrm_shared_get(struct xfrm_input_shared *sh)
+{
+	atomic_inc(&sh->refcnt);
+}
+
+static inline void xfrm_shared_put(struct xfrm_input_shared *sh)
+{
+	if (atomic_dec_and_test(&sh->refcnt)) {
+		kfree(sh);
+	}
+}
+#endif
 static inline struct sec_path *
 secpath_get(struct sec_path *sp)
 {
diff --git a/net/bridge/br_forward.c b/net/bridge/br_forward.c
index 7a241c3..77cafcf 100644
--- a/net/bridge/br_forward.c
+++ b/net/bridge/br_forward.c
@@ -41,7 +41,11 @@ static inline unsigned packet_length(const struct sk_buff *skb)
 int br_dev_queue_push_xmit(struct sk_buff *skb)
 {
 	/* drop mtu oversized packets except gso */
+#if defined(CONFIG_INET_IPSEC_OFFLOAD) || defined(CONFIG_INET6_IPSEC_OFFLOAD)
+	if (packet_length(skb) > skb->dev->mtu && !skb_is_gso(skb) && (!skb->ipsec_offload))
+#else
 	if (packet_length(skb) > skb->dev->mtu && !skb_is_gso(skb))
+#endif
 		kfree_skb(skb);
 	else {
 		/* ip_refrag calls ip_fragment, doesn't copy the MAC header. */
diff --git a/net/core/flow.c b/net/core/flow.c
index 9601587..1511fc6 100644
--- a/net/core/flow.c
+++ b/net/core/flow.c
@@ -22,6 +22,9 @@
 #include <linux/cpumask.h>
 #include <linux/mutex.h>
 #include <net/flow.h>
+#if defined(CONFIG_INET_IPSEC_OFFLOAD) || defined(CONFIG_INET6_IPSEC_OFFLOAD)
+#include <net/xfrm.h>
+#endif
 #include <asm/atomic.h>
 #include <linux/security.h>
 
@@ -165,13 +168,23 @@ static int flow_key_compare(struct flowi *key1, struct flowi *key2)
 	return 0;
 }
 
+#if defined(CONFIG_INET_IPSEC_OFFLOAD) || defined(CONFIG_INET6_IPSEC_OFFLOAD)
+void *flow_cache_lookup(struct net *net, struct flowi *key, u16 family, u8 dir,
+			u8 *new_flow, flow_resolve_t resolver)
+#else
 void *flow_cache_lookup(struct net *net, struct flowi *key, u16 family, u8 dir,
 			flow_resolve_t resolver)
+#endif
 {
 	struct flow_cache_entry *fle, **head;
 	unsigned int hash;
 	int cpu;
 
+#if defined(CONFIG_INET_IPSEC_OFFLOAD) || defined(CONFIG_INET6_IPSEC_OFFLOAD)
+	if (new_flow)
+		*new_flow = 0;
+#endif
+
 	local_bh_disable();
 	cpu = smp_processor_id();
 
@@ -237,6 +250,10 @@ nocache:
 			fle->object_ref = obj_ref;
 			if (obj)
 				atomic_inc(fle->object_ref);
+#if defined(CONFIG_INET_IPSEC_OFFLOAD) || defined(CONFIG_INET6_IPSEC_OFFLOAD)
+			if (new_flow)
+				*new_flow = 1;
+#endif
 		}
 		local_bh_enable();
 
@@ -307,6 +324,67 @@ void flow_cache_flush(void)
 	put_online_cpus();
 }
 
+#if defined(CONFIG_INET_IPSEC_OFFLOAD) || defined(CONFIG_INET6_IPSEC_OFFLOAD)
+void flow_cache_remove(struct flowi *fl, 
+			unsigned short family, unsigned short dir)
+{
+ 	struct flow_cache_entry *fle, *prev, **head;
+	unsigned int hash;
+	int cpu;
+
+	local_bh_disable();
+	cpu = smp_processor_id();
+
+	hash = flow_hash_code(fl, cpu);
+	head = &flow_table(cpu)[hash];
+	prev = NULL;
+	for (fle = *head; fle; fle = fle->next) {
+		if((fle->family == family) && (fle->dir == dir) && (flow_key_compare(&fle->key, fl) == 0)) {
+			if (prev) 
+			     prev->next = fle->next;
+			else
+			    *head = fle->next;
+			flow_entry_kill(cpu, fle);
+			break;
+		}
+		prev = fle;
+	}	
+	local_bh_enable();
+}
+
+void flow_cache_flush_xfmr(void* h)
+{
+	int i;
+	int cpu;
+	struct xfrm_state *x = (struct xfrm_state *)h;
+	struct flow_cache_entry *fle, *prev;
+	struct flow_cache_entry **head;;
+
+	local_bh_disable();
+
+	cpu = smp_processor_id();
+
+	for (i = 0; i < flow_hash_size; i++) {
+		head = &flow_table(cpu)[i];
+		prev = NULL;
+		
+		for (fle = *head; fle; fle = fle->next) {
+			if (xfrm_selector_match(&x->sel, &fle->key, fle->family)) {
+				if (prev) 
+				     prev->next = fle->next;
+				else
+				    *head = fle->next;
+				flow_entry_kill(cpu, fle);
+				break;
+			}
+			prev = fle;
+		}	
+	}
+
+	local_bh_enable();
+}
+#endif
+
 static void __init flow_cache_cpu_prepare(int cpu)
 {
 	struct tasklet_struct *tasklet;
diff --git a/net/core/skbuff.c b/net/core/skbuff.c
index df6bea8..98d7e94 100644
--- a/net/core/skbuff.c
+++ b/net/core/skbuff.c
@@ -610,6 +610,9 @@ static void __copy_skb_header(struct sk_buff *new, const struct sk_buff *old)
 #ifdef CONFIG_XFRM
 	new->sp			= secpath_get(old->sp);
 #endif
+#if defined(CONFIG_INET_IPSEC_OFFLOAD) || defined(CONFIG_INET6_IPSEC_OFFLOAD)
+        new->ipsec_offload      = old->ipsec_offload;
+#endif
 	memcpy(new->cb, old->cb, sizeof(old->cb));
 	new->csum		= old->csum;
 	new->local_df		= old->local_df;
diff --git a/net/ipv4/Kconfig b/net/ipv4/Kconfig
index 0c94a1a..1a1dd12 100644
--- a/net/ipv4/Kconfig
+++ b/net/ipv4/Kconfig
@@ -351,6 +351,12 @@ config INET_ESP
 
 	  If unsure, say Y.
 
+config INET_IPSEC_OFFLOAD
+	bool "IPsec Fast Path Processing offload"
+	depends on (INET_ESP || INET_AH) && COMCERTO_FPP
+		---help---
+	  Support for IPsec FPP offload.
+
 config INET_IPCOMP
 	tristate "IP: IPComp transformation"
 	select INET_XFRM_TUNNEL
diff --git a/net/ipv4/Makefile b/net/ipv4/Makefile
index 80ff87c..9aec2dd 100644
--- a/net/ipv4/Makefile
+++ b/net/ipv4/Makefile
@@ -23,7 +23,7 @@ obj-$(CONFIG_NET_IPIP) += ipip.o
 obj-$(CONFIG_NET_IPGRE) += ip_gre.o
 obj-$(CONFIG_SYN_COOKIES) += syncookies.o
 obj-$(CONFIG_INET_AH) += ah4.o
-obj-$(CONFIG_INET_ESP) += esp4.o
+obj-$(CONFIG_INET_IPSEC_OFFLOAD) += esp4.o
 obj-$(CONFIG_INET_IPCOMP) += ipcomp.o
 obj-$(CONFIG_INET_XFRM_TUNNEL) += xfrm4_tunnel.o
 obj-$(CONFIG_INET_XFRM_MODE_BEET) += xfrm4_mode_beet.o
diff --git a/net/ipv4/ip_output.c b/net/ipv4/ip_output.c
index 4bede23..839f68a 100644
--- a/net/ipv4/ip_output.c
+++ b/net/ipv4/ip_output.c
@@ -230,7 +230,12 @@ static int ip_finish_output(struct sk_buff *skb)
 		return dst_output(skb);
 	}
 #endif
+#if defined(CONFIG_INET_IPSEC_OFFLOAD)
+	if ((skb->ipsec_offload == 0) &&
+		skb->len > ip_skb_dst_mtu(skb) && !skb_is_gso(skb))
+#else
 	if (skb->len > ip_skb_dst_mtu(skb) && !skb_is_gso(skb))
+#endif
 		return ip_fragment(skb, ip_finish_output2);
 	else
 		return ip_finish_output2(skb);
diff --git a/net/key/af_key.c b/net/key/af_key.c
index ba9a3fc..3ca6f29 100644
--- a/net/key/af_key.c
+++ b/net/key/af_key.c
@@ -30,8 +30,169 @@
 #include <net/net_namespace.h>
 #include <net/netns/generic.h>
 #include <net/xfrm.h>
+#include <net/netlink.h>
 
 #include <net/sock.h>
+#include <net/ip6_route.h>
+
+#if defined(CONFIG_INET_IPSEC_OFFLOAD)|| defined(CONFIG_INET6_IPSEC_OFFLOAD)
+#define NLKEY_SUPPORT 1
+#else 
+#undef NLKEY_SUPPORT
+#endif 
+
+#ifdef NLKEY_SUPPORT
+#include <net/dsfield.h>
+#include <net/inet_ecn.h>
+#include <net/ipv6.h>
+
+
+extern struct dst_entry *xfrm_dst_lookup(struct xfrm_state *x, int tos,
+						xfrm_address_t *prev_saddr,
+						xfrm_address_t *prev_daddr,
+						int family);
+extern int xfrm_get_tos(struct flowi *fl, int family);
+extern int ipsec_nlkey_flow(u16 xfrm_nr, u16 *xfrm_handle, 
+		struct flowi *fl, u16 family, u16 dir);
+
+
+#define	NLKEY_SA_CREATE		0x0A01
+#define NLKEY_SA_DELETE		0x0A02
+#define NLKEY_SA_FLUSH 		0x0A03
+#define NLKEY_SA_SET_KEYS	0x0A04
+#define NLKEY_SA_SET_TUNNEL	0x0A05
+#define NLKEY_SA_SET_NATT	0x0A06
+#define	NLKEY_SA_SET_STATE	0x0A07
+#define	NLKEY_SA_SET_LIFETIME	0x0A08
+#define	NLKEY_SA_NOTIFY		0x0A09
+#define	NLKEY_FLOW_ADD		0x0A11
+#define NLKEY_FLOW_REMOVE	0x0A12
+#define NLKEY_FLOW_NOTIFY	0x0A13
+#define NLKEY_NULL_MSG		0x0000
+
+#define NLKEY_HDR_LEN		4
+#define NLKEY_MSG_LEN 		256
+
+#define NLKEY_MAX_NUM_KEYS	2
+#define NLKEY_MAX_KEY_LEN	(256 / 8)
+
+struct nlkey_msg {
+	/* message data */
+	unsigned short fcode;
+	unsigned short length;
+	unsigned short payload[(NLKEY_MSG_LEN /sizeof(unsigned short))];
+};
+/* sizeof(nlkey_msg) = 4 + 256 */
+
+struct nlkey_sa_id {
+	unsigned int spi;
+	unsigned char sa_type;
+	unsigned char proto_family;
+	unsigned char replay_window;
+	unsigned char rsvd;
+	unsigned int dst_ip[4];
+	unsigned short mtu;
+	unsigned short dev_mtu;
+
+};
+/* sizeof(nlkey_sa_id) = 24 */
+
+struct nlkey_sa_create {
+	unsigned short sagd;
+	unsigned short rsvd;
+	struct nlkey_sa_id said;
+};
+/* sizeof(nlkey_sa_delete) = 28 */
+
+struct nlkey_sa_delete {
+	unsigned short sagd;
+	unsigned short rsvd;
+};
+/* sizeof(nlkey_sa_delete) = 4 */
+
+struct nlkey_sa_set_tunnel {
+	unsigned short sagd;
+	unsigned char rsvd;
+	unsigned char proto_family;
+	union {
+		struct iphdr 	 ipv4h;
+		struct ipv6hdr ipv6h;
+	} h;
+};
+/* sizeof(nlkey_sa_set_tunnel) = 36 */
+
+struct nlkey_sa_set_natt {
+	unsigned short sagd;
+	unsigned short rsvd;
+};
+/* sizeof(nlkey_sa_set_natt) = 4 */
+
+struct nlkey_sa_set_state {
+	unsigned short sagd;
+	unsigned short rsvd;
+	unsigned short state;
+	unsigned short rsvd2;
+};
+/* sizeof(nlkey_sa_set_natt) = 8 */
+
+struct nlkey_key_desc {
+	unsigned short key_bits;
+	unsigned char key_alg;
+	unsigned char  key_type;
+	unsigned char key[NLKEY_MAX_KEY_LEN]; 
+};
+/* sizeof(nlkey_key_desc) =  36 */
+
+struct nlkey_sa_set_keys {
+	unsigned short sagd;
+	unsigned short rsvd;	
+	unsigned short num_keys;
+	unsigned short rsvd2;
+	struct nlkey_key_desc keys[NLKEY_MAX_NUM_KEYS];
+};
+/* sizeof(nlkey_sa_set_keys) =  80 */
+
+struct nlkey_lifetime_desc {
+	unsigned int allocations;
+	unsigned int bytes[2];
+};
+/* sizeof(nlkey_sa_set_lifetime) =  12 */
+
+struct nlkey_sa_set_lifetime {
+	unsigned short sagd;
+	unsigned short rsvd;
+	struct nlkey_lifetime_desc hard_time;
+	struct nlkey_lifetime_desc soft_time;
+	struct nlkey_lifetime_desc current_time;
+};
+/* sizeof(nlkey_sa_set_lifetime) =  40 */
+
+/* SA notifications */
+#define IPSEC_SOFT_EXPIRE 0
+#define IPSEC_HARD_EXPIRE 1
+
+struct nlkey_sa_notify {
+	unsigned short sagd;
+	unsigned short rsvd;
+	unsigned int  action;
+};
+/* sizeof(nlkey_sa_notify) = 8 */
+
+
+static int ipsec_nlkey_send(struct net *net, struct xfrm_state *x, struct km_event *c);
+static void ipsec_nlkey_rcv(struct sk_buff *skb);
+static void ipsec_nlkey_init(void);
+static unsigned short ipsec_sacode_to_nlkeycode(unsigned short sa_code);
+static struct sk_buff * ipsec_xfrm2nlkey (struct net *net, struct xfrm_state *x, 
+					struct km_event *c, unsigned short *msg_id);
+static void ipsec_nlkey_set_said(struct net *net, struct xfrm_state *x, struct km_event *c, struct nlkey_sa_id *said);
+
+/* netlink NETLINK_KEY socket */
+struct sock *nlkey_socket = NULL;
+
+#endif
+/************************************************************************************/
+
 
 #define _X2KEY(x) ((x) == XFRM_INF ? 0 : (x))
 #define _KEY2X(x) ((x) == 0 ? XFRM_INF : (x))
@@ -99,7 +260,7 @@ static void pfkey_sock_destruct(struct sock *sk)
 	skb_queue_purge(&sk->sk_receive_queue);
 
 	if (!sock_flag(sk, SOCK_DEAD)) {
-		printk("Attempt to release alive pfkey socket: %p\n", sk);
+		printk(KERN_ERR "Attempt to release alive pfkey socket: %p\n", sk);
 		return;
 	}
 
@@ -1402,7 +1563,7 @@ static inline int event2poltype(int event)
 	case XFRM_MSG_POLEXPIRE:
 	//	return SADB_X_SPDEXPIRE;
 	default:
-		printk("pfkey: Unknown policy event %d\n", event);
+		printk(KERN_ERR "pfkey: Unknown policy event %d\n", event);
 		break;
 	}
 
@@ -1421,7 +1582,7 @@ static inline int event2keytype(int event)
 	case XFRM_MSG_EXPIRE:
 		return SADB_EXPIRE;
 	default:
-		printk("pfkey: Unknown SA event %d\n", event);
+		printk(KERN_ERR "pfkey: Unknown SA event %d\n", event);
 		break;
 	}
 
@@ -1429,7 +1590,11 @@ static inline int event2keytype(int event)
 }
 
 /* ADD/UPD/DEL */
+#if NLKEY_SUPPORT
+static int key_notify_sa(struct net *net, struct xfrm_state *x, struct km_event *c)
+#else
 static int key_notify_sa(struct xfrm_state *x, struct km_event *c)
+#endif
 {
 	struct sk_buff *skb;
 	struct sadb_msg *hdr;
@@ -1450,6 +1615,10 @@ static int key_notify_sa(struct xfrm_state *x, struct km_event *c)
 
 	pfkey_broadcast(skb, GFP_ATOMIC, BROADCAST_ALL, NULL, xs_net(x));
 
+#ifdef NLKEY_SUPPORT
+	/* now sent message also to the user space through NETLINK_KEY socket*/
+	ipsec_nlkey_send(net, x, c);
+#endif
 	return 0;
 }
 
@@ -1688,7 +1857,11 @@ static int unicast_flush_resp(struct sock *sk, struct sadb_msg *ihdr)
 	return pfkey_broadcast(skb, GFP_ATOMIC, BROADCAST_ONE, sk, sock_net(sk));
 }
 
+#if defined(NLKEY_SUPPORT)
+static int key_notify_sa_flush(struct net *net, struct km_event *c)
+#else
 static int key_notify_sa_flush(struct km_event *c)
+#endif
 {
 	struct sk_buff *skb;
 	struct sadb_msg *hdr;
@@ -1707,6 +1880,11 @@ static int key_notify_sa_flush(struct km_event *c)
 
 	pfkey_broadcast(skb, GFP_ATOMIC, BROADCAST_ALL, NULL, c->net);
 
+#ifdef NLKEY_SUPPORT
+	/* now sent message also to the user space through NETLINK_KEY socket*/
+	ipsec_nlkey_send(net, NULL, c);
+#endif
+
 	return 0;
 }
 
@@ -2919,7 +3097,11 @@ static int key_notify_policy_expire(struct xfrm_policy *xp, struct km_event *c)
 	return 0;
 }
 
+#if defined(NLKEY_SUPPORT)
+static int key_notify_sa_expire(struct net *net, struct xfrm_state *x, struct km_event *c)
+#else
 static int key_notify_sa_expire(struct xfrm_state *x, struct km_event *c)
+#endif
 {
 	struct sk_buff *out_skb;
 	struct sadb_msg *out_hdr;
@@ -2946,6 +3128,11 @@ static int key_notify_sa_expire(struct xfrm_state *x, struct km_event *c)
 	out_hdr->sadb_msg_pid = 0;
 
 	pfkey_broadcast(out_skb, GFP_ATOMIC, BROADCAST_REGISTERED, NULL, xs_net(x));
+
+#ifdef NLKEY_SUPPORT
+	/* now sent message also to the user space through NETLINK_KEY socket*/
+	ipsec_nlkey_send(net, x, c);
+#endif
 	return 0;
 }
 
@@ -2957,19 +3144,21 @@ static int pfkey_send_notify(struct xfrm_state *x, struct km_event *c)
 	if (atomic_read(&net_pfkey->socks_nr) == 0)
 		return 0;
 
+	printk(KERN_INFO "pfkey_send_notify: SA event %d\n", c->event);
+
 	switch (c->event) {
 	case XFRM_MSG_EXPIRE:
-		return key_notify_sa_expire(x, c);
+		return key_notify_sa_expire(net, x, c);
 	case XFRM_MSG_DELSA:
 	case XFRM_MSG_NEWSA:
 	case XFRM_MSG_UPDSA:
-		return key_notify_sa(x, c);
+		return key_notify_sa(net, x, c);
 	case XFRM_MSG_FLUSHSA:
-		return key_notify_sa_flush(c);
+		return key_notify_sa_flush(net, c);
 	case XFRM_MSG_NEWAE: /* not yet supported */
 		break;
 	default:
-		printk("pfkey: Unknown SA event %d\n", c->event);
+		printk(KERN_ERR "pfkey: Unknown SA event %d\n", c->event);
 		break;
 	}
 
@@ -2993,7 +3182,7 @@ static int pfkey_send_policy_notify(struct xfrm_policy *xp, int dir, struct km_e
 			break;
 		return key_notify_policy_flush(c);
 	default:
-		printk("pfkey: Unknown policy event %d\n", c->event);
+		printk(KERN_ERR "pfkey: Unknown policy event %d\n", c->event);
 		break;
 	}
 
@@ -3733,6 +3922,512 @@ static struct xfrm_mgr pfkeyv2_mgr =
 	.migrate	= pfkey_send_migrate,
 };
 
+
+#ifdef NLKEY_SUPPORT
+extern  struct xfrm_state *xfrm_state_lookup_byhandle(u16 handle);
+
+static unsigned short ipsec_sacode_to_nlkeycode(unsigned short sa_code)
+{
+	unsigned nlkey_code;
+
+	switch (sa_code) 
+	{
+		case XFRM_MSG_DELSA:
+			nlkey_code = NLKEY_SA_DELETE;
+			break;
+		case XFRM_MSG_NEWSA:
+		case XFRM_MSG_UPDSA:
+			nlkey_code = NLKEY_SA_CREATE;
+			break;
+		case XFRM_MSG_FLUSHSA:
+			nlkey_code = NLKEY_SA_FLUSH;
+			break;
+		case XFRM_MSG_EXPIRE:
+			nlkey_code = NLKEY_SA_SET_STATE;
+			break;
+		default:
+			nlkey_code = NLKEY_NULL_MSG;
+			break;
+	}
+
+	return nlkey_code;
+}
+
+static void ipsec_nlkey_rcv(struct sk_buff *skb)
+{
+	struct nlmsghdr *nlh = NULL;
+	struct nlkey_msg *msg = NULL;
+	struct flowi flow;
+	unsigned short *p;
+	unsigned short family, dir;
+	struct xfrm_state *x;
+	struct nlkey_sa_notify sa_notify_msg;
+
+	/* extract message from skb */
+	nlh = (struct nlmsghdr *)skb->data;
+
+	msg = (struct nlkey_msg *)NLMSG_DATA(nlh);
+	
+	printk(KERN_INFO "ipsec_nlkey_rcv fcode: 0x%x length: %d bytes\n",msg->fcode,msg->length);
+	
+	/* process command received from user space */
+	switch(msg->fcode)
+	{
+		case NLKEY_FLOW_REMOVE:
+			printk(KERN_INFO "ipsec_nlkey_rcv NLKEY_FLOW_REMOVE\n");
+			p = msg->payload;
+			memcpy(&flow, p, sizeof(struct flowi)); p += sizeof(struct flowi)/2;
+			family = *p; p++;
+			dir = *p; p++;
+			flow_cache_remove(&flow, family, dir);
+			break;
+
+		case NLKEY_SA_NOTIFY:
+			printk(KERN_INFO "ipsec_nlkey_rcv NLKEY_SA_NOTIFY\n");
+			memcpy(&sa_notify_msg, msg->payload, sizeof(struct nlkey_sa_notify));
+			x = xfrm_state_lookup_byhandle(sa_notify_msg.sagd);
+			if (x) {
+				spin_lock(&x->lock);
+				
+				if (sa_notify_msg.action) { 
+					// hard expired
+					x->km.state = XFRM_STATE_EXPIRED;
+					tasklet_hrtimer_start(&x->mtimer, ktime_set(0,0), HRTIMER_MODE_REL);
+				}
+				else if (!x->km.dying) {
+					 x->km.dying = 1;
+					 km_state_expired(x, 0, 0);
+				}	
+				
+				spin_unlock(&x->lock);
+				xfrm_state_put(x);
+			}				
+			break;
+		default:
+			printk(KERN_INFO "ipsec_nlkey_rcv fcode 0x%x not supported\n", msg->fcode);
+			break;
+	}
+
+}
+
+extern struct dst_entry *__xfrm_dst_lookup(struct net *net, int tos,
+						  xfrm_address_t *saddr,
+						  xfrm_address_t *daddr,
+						  int family);
+static void ipsec_nlkey_set_said(struct net *net, struct xfrm_state *x, 
+				struct km_event *c, struct nlkey_sa_id *said)
+{
+
+	struct flowi fl;
+	int tos;
+	xfrm_address_t saddr, daddr;
+	struct dst_entry *dst;
+
+	memset(&fl, 0, sizeof(struct flowi));
+
+	/* SPI */
+	said->spi = x->id.spi;
+	/* SA Type (AH or ESP) */
+	said->sa_type = x->id.proto;
+	/* Protocol Family (IPv4 or IPv6) */
+	said->proto_family = x->props.family;
+	/* Replay window */
+	said->replay_window = x->props.replay_window;
+	/* Destination IP Address */
+	if(x->props.family == AF_INET6) {
+		memcpy(&said->dst_ip, x->id.daddr.a6, sizeof(struct in6_addr));
+		ipv6_addr_copy(&fl.fl6_dst, (struct in6_addr *)x->id.daddr.a6);
+	}
+	else {
+		said->dst_ip[0] = x->id.daddr.a4;
+		fl.fl4_dst = x->id.daddr.a4;
+	}
+	said->mtu = 0;
+
+	xfrm_flowi_addr_get(&fl, &saddr, &daddr, x->props.family);
+
+	tos = xfrm_get_tos(&fl, x->props.family);
+	if (tos < 0) {
+		printk(KERN_ERR "%s:%d: FIXME\n",__FUNCTION__,__LINE__);	
+		while(1);
+	}
+	
+	dst = __xfrm_dst_lookup(net, tos, NULL, &daddr, x->props.family);
+	if (IS_ERR(dst)) {
+		printk(KERN_ERR "%s:%d: FIXME\n",__FUNCTION__,__LINE__);
+		while(1);
+	}
+	said->dev_mtu = dst_mtu(dst);
+	said->mtu = xfrm_state_mtu(x,dst_mtu(dst));	
+
+	dst_release(dst);
+}
+
+static struct sk_buff * ipsec_xfrm2nlkey (struct net *net, struct xfrm_state *x, 
+					struct km_event *c, unsigned short *msg_id)
+{
+	struct nlkey_sa_id sa_id_msg;
+	struct nlkey_sa_create sa_create_msg;
+	struct nlkey_sa_delete sa_delete_msg;
+	struct nlkey_sa_set_keys sa_set_keys_msg;
+	struct nlkey_sa_set_tunnel sa_set_tunnel_msg;
+	struct nlkey_sa_set_natt sa_set_natt_msg;
+	struct nlkey_sa_set_state sa_set_state_msg;
+	struct nlkey_sa_set_lifetime sa_set_lifetime_msg;
+	struct nlkey_msg msg;
+	struct sk_buff *skb = NULL;
+	struct nlmsghdr *nlh = NULL;
+	gfp_t allocation = in_interrupt() ? GFP_ATOMIC : GFP_KERNEL;
+	unsigned char tunnel, keys, natt, state, lifetime;
+
+	/* supported SA informations */
+	keys = 1; state = 1; tunnel = 1; lifetime = 1; natt = 0; 
+
+	/* next message to build */
+	memset(&msg, 0, sizeof(struct nlkey_msg));
+	msg.fcode = *msg_id;
+	
+	printk(KERN_INFO "\n\nipsec_xfrm2nlkey: processing event 0x%x\n", msg.fcode);
+
+	switch (msg.fcode)
+	{
+		case NLKEY_SA_CREATE:
+			printk(KERN_INFO "ipsec_xfrm2nlkey: NLKEY_SA_CREATE\n");
+			if(x) {
+				/* some check before builing message */
+				if((x->id.proto != IPPROTO_ESP) && (x->id.proto != IPPROTO_AH)) {
+					printk(KERN_ERR "ipsec_xfrm2nlkey: protocol %d not supported\n", x->id.proto);
+					*msg_id = NLKEY_NULL_MSG;
+					goto exit;
+				}	
+				memset(&sa_create_msg, 0, sizeof(struct nlkey_sa_create));	
+
+				/* SA global handler */
+				sa_create_msg.sagd = x->handle;
+
+				/* SA identifier */
+				ipsec_nlkey_set_said(net, x, c, &sa_create_msg.said);
+				memcpy(msg.payload, &sa_create_msg, sizeof(struct nlkey_sa_create));
+				msg.length = sizeof(struct nlkey_sa_create);
+				*msg_id = NLKEY_SA_SET_KEYS; /* next message */
+			} else {
+				*msg_id = NLKEY_NULL_MSG; /* next message */
+				goto exit;
+			}
+			
+			break;
+
+		case NLKEY_SA_SET_KEYS:
+			printk(KERN_INFO "ipsec_xfrm2nlkey: NLKEY_SA_SET_KEYS\n");
+			if(keys) {
+				memset(&sa_set_keys_msg, 0, sizeof(struct nlkey_sa_set_keys));
+
+				/* SA global handler */
+				sa_set_keys_msg.sagd = x->handle; 
+				
+				/* auth key */
+				if(x->aalg) {
+					if (x->aalg->alg_key_len) {
+						sa_set_keys_msg.keys[sa_set_keys_msg.num_keys].key_bits = x->aalg->alg_key_len;
+						sa_set_keys_msg.keys[sa_set_keys_msg.num_keys].key_alg = x->props.aalgo;
+						sa_set_keys_msg.keys[sa_set_keys_msg.num_keys].key_type = 0;
+						memcpy(sa_set_keys_msg.keys[sa_set_keys_msg.num_keys].key, x->aalg->alg_key,(sa_set_keys_msg.keys[sa_set_keys_msg.num_keys].key_bits / 8));
+						printk(KERN_INFO "ipsec_xfrm2nlkey: AUTH - algo %d key %d bits\n", sa_set_keys_msg.keys[sa_set_keys_msg.num_keys].key_alg, sa_set_keys_msg.keys[sa_set_keys_msg.num_keys].key_bits);
+						sa_set_keys_msg.num_keys++;
+					}
+				}
+				/* encrypt key */
+				if(x->ealg) {
+					if (x->ealg->alg_key_len) {
+
+						sa_set_keys_msg.keys[sa_set_keys_msg.num_keys].key_bits = x->ealg->alg_key_len;
+						sa_set_keys_msg.keys[sa_set_keys_msg.num_keys].key_alg = x->props.ealgo;
+						sa_set_keys_msg.keys[sa_set_keys_msg.num_keys].key_type = 1;
+						memcpy(sa_set_keys_msg.keys[sa_set_keys_msg.num_keys].key, x->ealg->alg_key,(sa_set_keys_msg.keys[sa_set_keys_msg.num_keys].key_bits / 8));
+						printk(KERN_INFO "ipsec_xfrm2nlkey: ENCRYPT - algo %d key %d bits\n", sa_set_keys_msg.keys[sa_set_keys_msg.num_keys].key_alg, sa_set_keys_msg.keys[sa_set_keys_msg.num_keys].key_bits);
+						sa_set_keys_msg.num_keys++;
+					}
+				}
+				memcpy(msg.payload, &sa_set_keys_msg, sizeof(struct nlkey_sa_set_keys));
+				msg.length = sizeof(struct nlkey_sa_set_keys);
+				*msg_id = NLKEY_SA_SET_TUNNEL; /* next message */
+			} else {
+				*msg_id = NLKEY_SA_SET_TUNNEL; /* next message */
+				goto exit;
+			}
+			break;
+
+		case NLKEY_SA_SET_TUNNEL:
+			printk(KERN_INFO "ipsec_xfrm2nlkey: NLKEY_SA_SET_TUNNEL\n");
+			if(tunnel && (x->props.mode == XFRM_MODE_TUNNEL)) {
+				memset(&sa_set_tunnel_msg, 0, sizeof(struct nlkey_sa_set_tunnel));
+
+				/* SA global handler */
+				sa_set_tunnel_msg.sagd = x->handle; 
+
+				/* Tunnel */
+				sa_set_tunnel_msg.proto_family = x->props.family;
+				if(x->props.family == AF_INET6) {
+					struct ipv6hdr *top_iph = &sa_set_tunnel_msg.h.ipv6h;
+					int dsfield;
+					top_iph->version = 6;
+					top_iph->priority = 0;
+					top_iph->flow_lbl[0] = 0;
+					top_iph->flow_lbl[1] = 0;
+					top_iph->flow_lbl[2] = 0;
+					top_iph->nexthdr = IPPROTO_IPIP;	
+					dsfield = ipv6_get_dsfield(top_iph);
+					dsfield = INET_ECN_encapsulate(dsfield, dsfield);
+					if (x->props.flags & XFRM_STATE_NOECN)
+						dsfield &= ~INET_ECN_MASK;
+					ipv6_change_dsfield(top_iph, 0, dsfield);
+					top_iph->hop_limit = 64;
+					memcpy(&top_iph->daddr, x->id.daddr.a6, sizeof(struct in6_addr));
+					memcpy(&top_iph->saddr, x->props.saddr.a6, sizeof(struct in6_addr));
+					printk(KERN_INFO "ipsec_xfrm2nlkey: IPv6 tunnel\n");
+					printk(KERN_INFO "dst: %x %x %x %x\n", x->id.daddr.a6[0], x->id.daddr.a6[1], x->id.daddr.a6[2], x->id.daddr.a6[3]);
+					printk(KERN_INFO "src: %x %x %x %x\n", x->props.saddr.a6[0], x->props.saddr.a6[1], x->props.saddr.a6[2], x->props.saddr.a6[3]);
+				}
+				else {
+					struct iphdr *top_iph = &sa_set_tunnel_msg.h.ipv4h;
+					top_iph->ihl = 5;
+					top_iph->version = 4;
+					top_iph->tos = 0;
+					top_iph->frag_off = 0; 
+					top_iph->ttl = 64;
+					top_iph->saddr = x->props.saddr.a4;
+					top_iph->daddr = x->id.daddr.a4;
+					printk(KERN_INFO "ipsec_xfrm2nlkey: IPv4 tunnel dst:%x - src:%x \n", x->id.daddr.a4, x->props.saddr.a4);
+				}
+				memcpy(msg.payload, &sa_set_tunnel_msg, sizeof(struct nlkey_sa_set_tunnel));
+				msg.length = sizeof(struct nlkey_sa_set_tunnel);
+				*msg_id = NLKEY_SA_SET_NATT; /* next message */
+			} else {
+				*msg_id = NLKEY_SA_SET_NATT; /* next message */
+				goto exit;	
+			} 
+			break;
+
+		case NLKEY_SA_SET_NATT:
+			printk(KERN_INFO "ipsec_xfrm2nlkey: NLKEY_SA_SET_NATT\n");
+			if(natt) {
+				memset(&sa_set_natt_msg, 0, sizeof(struct nlkey_sa_set_natt));
+
+				/* SA global handler */
+				sa_set_natt_msg.sagd = x->handle; 
+				
+				/* NATT */
+				/* TODO */	
+
+				memcpy(msg.payload, &sa_set_natt_msg, sizeof(struct nlkey_sa_set_natt));
+				msg.length = sizeof(struct nlkey_sa_set_natt);
+				*msg_id = NLKEY_SA_SET_LIFETIME; /* next message */
+			} else {
+				*msg_id = NLKEY_SA_SET_LIFETIME; /* next message */
+				goto exit;	
+			}
+			break;
+
+		case NLKEY_SA_SET_LIFETIME:
+			printk(KERN_INFO "ipsec_xfrm2nlkey: NLKEY_SA_SET_LIFETIME\n");
+			if(lifetime) {
+				memset(&sa_set_lifetime_msg, 0, sizeof(struct nlkey_sa_set_lifetime));
+
+				/* SA global handler */
+				sa_set_lifetime_msg.sagd = x->handle;
+
+				/* hard time */
+				sa_set_lifetime_msg.hard_time.allocations =  _X2KEY(x->lft.hard_packet_limit);
+				if(_X2KEY(x->lft.hard_byte_limit))
+					memcpy(sa_set_lifetime_msg.hard_time.bytes, &x->lft.hard_byte_limit, sizeof(uint64_t));
+
+				/* soft time */
+				sa_set_lifetime_msg.soft_time.allocations =  _X2KEY(x->lft.soft_packet_limit);
+				if(_X2KEY(x->lft.soft_byte_limit))
+					memcpy(sa_set_lifetime_msg.soft_time.bytes, &x->lft.soft_byte_limit, sizeof(uint64_t));
+
+				/* current time */
+				sa_set_lifetime_msg.current_time.allocations = x->curlft.packets;
+				memcpy(sa_set_lifetime_msg.current_time.bytes, &x->curlft.bytes, sizeof(uint64_t));
+
+				memcpy(msg.payload, &sa_set_lifetime_msg, sizeof(struct nlkey_sa_set_lifetime));
+				msg.length = sizeof(struct nlkey_sa_set_lifetime);
+				*msg_id = NLKEY_SA_SET_STATE; /* next message */
+			} else {
+				*msg_id = NLKEY_SA_SET_STATE; /* next message */
+				goto exit;	
+			}
+			break;
+
+		case NLKEY_SA_SET_STATE:
+			printk(KERN_INFO "ipsec_xfrm2nlkey: NLKEY_SET_STATE\n");
+			if(state) {
+				memset(&sa_set_state_msg, 0, sizeof(struct nlkey_sa_set_state));
+				memset(&sa_id_msg, 0, sizeof(struct nlkey_sa_id));
+
+				/* SA global handler */
+				sa_set_state_msg.sagd = x->handle; 
+				/* State */
+				sa_set_state_msg.state = x->km.state;
+				// TODO: set the offloaded state once ack received !
+				x->offloaded = 1;
+				atomic_inc(&flow_cache_genid);
+
+				memcpy(msg.payload, &sa_set_state_msg, sizeof(struct nlkey_sa_set_state));
+				msg.length = sizeof(struct nlkey_sa_set_state);
+				*msg_id = NLKEY_NULL_MSG; /* next message */
+			} else {
+				*msg_id = NLKEY_NULL_MSG; /* next message */
+				goto exit;
+			}
+			break;
+		
+		case NLKEY_SA_DELETE:
+			printk(KERN_INFO "ipsec_xfrm2nlkey: NLKEY_SA_DELETE\n");
+			memset(&sa_delete_msg, 0, sizeof(struct nlkey_sa_delete));
+			
+			/* SA global handler */
+			sa_delete_msg.sagd = x->handle;
+			memcpy(msg.payload, &sa_delete_msg, sizeof(struct nlkey_sa_delete));
+			msg.length = sizeof(struct nlkey_sa_delete);
+			atomic_inc(&flow_cache_genid);
+
+
+			*msg_id = NLKEY_NULL_MSG; /* next message */
+			break;
+
+		case NLKEY_SA_FLUSH:
+			printk(KERN_INFO "ipsec_xfrm2nlkey: NLKEY_SA_FLUSH\n");
+			/* No data required for flush SA command */
+			atomic_inc(&flow_cache_genid);
+
+			*msg_id = NLKEY_NULL_MSG; /* next message */
+			break;
+
+		default:
+			printk(KERN_ERR "ipsec_xfrm2nlkey: event 0x%x not supported\n", c->event);
+			*msg_id = NLKEY_NULL_MSG; /* next message */
+			break;
+	}
+
+	/* prepare netlink message for kernel to user space direction */
+	if(msg.length > NLKEY_MSG_LEN)
+	{
+		printk(KERN_ERR "ipsec_xfrm2nlkey: maximum message size reached (%d bytes)\n", msg.length);
+		goto exit;
+	}
+
+	skb = alloc_skb(NLMSG_SPACE(NLKEY_MSG_LEN + NLKEY_HDR_LEN), allocation);
+	if (skb == NULL)
+		goto exit;
+		
+	nlh = (struct nlmsghdr *)skb_put(skb, NLMSG_SPACE(NLKEY_HDR_LEN + msg.length));
+	memcpy(NLMSG_DATA(nlh), (unsigned char *)&msg, (NLKEY_HDR_LEN + msg.length));
+	
+	/* whole length of the message i.e. header + payload */
+	nlh->nlmsg_len = NLMSG_SPACE(NLKEY_HDR_LEN + msg.length);
+
+	/* from kernel */
+	nlh->nlmsg_pid = 0;
+	nlh->nlmsg_flags = 0;
+	NETLINK_CB(skb).pid = 0;
+	NETLINK_CB(skb).dst_group = 1;
+exit:
+	return skb;
+}
+
+static int ipsec_nlkey_send(struct net *net, struct xfrm_state *x, struct km_event *c)
+{
+	struct sk_buff *skb;
+	unsigned short msg_type;
+	int rc = 0;
+	
+	/* We may generate more than one message when adding new SA (sa_create + sa_set_state + sa_set_tunnel...) */
+	msg_type = ipsec_sacode_to_nlkeycode((unsigned short)c->event);
+
+	while(msg_type != NLKEY_NULL_MSG)
+	{			
+		/* build nlkey message */
+		skb = ipsec_xfrm2nlkey(net, x, c, &msg_type);
+		
+		if(skb != NULL)
+			if((rc = netlink_broadcast(nlkey_socket, skb, 0, 1, GFP_ATOMIC)) < 0)
+				return rc;
+	}
+
+	return rc;
+}
+
+
+int ipsec_nlkey_flow(u16 xfrm_nr, u16 *xfrm_handle, struct flowi *fl, u16 family, u16 dir)
+{
+	struct sk_buff *skb;
+	struct nlkey_msg msg;
+	struct nlmsghdr *nlh = NULL;
+	unsigned short *p;
+	gfp_t allocation = in_interrupt() ? GFP_ATOMIC : GFP_KERNEL;
+
+	
+	printk(KERN_INFO "ipsec_nlkey_flow \n");
+
+	/* next message to build */
+	memset(&msg, 0, sizeof(struct nlkey_msg));
+	msg.fcode = NLKEY_FLOW_ADD;
+
+	// Number of SA for this flow
+	p = msg.payload;
+	*p++ = xfrm_nr;
+	msg.length += sizeof(unsigned short);
+	// SA handles list
+	memcpy(p, xfrm_handle, xfrm_nr*sizeof(unsigned short));
+	msg.length += xfrm_nr*sizeof(unsigned short);
+	p+=xfrm_nr;
+	// flow family
+	*p++ = family;
+	msg.length += sizeof(unsigned short);
+	// flow family
+	*p++ = dir;
+	msg.length += sizeof(unsigned short);
+	// flow descriptor
+	memcpy(p, fl, sizeof(struct flowi));
+	msg.length +=sizeof(struct flowi);
+	p+=sizeof(struct flowi) / sizeof(u16);
+
+	skb = alloc_skb(NLMSG_SPACE(NLKEY_MSG_LEN + NLKEY_HDR_LEN), allocation);
+	if (skb == NULL)
+		return -ENOMEM;
+
+	/* prepare netlink message for kernel to user space direction */
+	nlh = (struct nlmsghdr *)skb_put(skb, NLMSG_SPACE(NLKEY_HDR_LEN + msg.length));
+	memcpy(NLMSG_DATA(nlh), (unsigned char *)&msg, (NLKEY_HDR_LEN + msg.length));
+	
+	/* whole length of the message i.e. header + payload */
+	nlh->nlmsg_len = NLMSG_SPACE(NLKEY_HDR_LEN + msg.length);
+
+	/* from kernel */
+	nlh->nlmsg_pid = 0; 
+	nlh->nlmsg_flags = 0;
+	NETLINK_CB(skb).pid = 0;
+	NETLINK_CB(skb).dst_group = 1;	
+
+		
+	return(netlink_broadcast(nlkey_socket, skb, 0, 1, GFP_ATOMIC));
+
+	
+}
+EXPORT_SYMBOL(ipsec_nlkey_flow);
+
+
+static void ipsec_nlkey_init(void)
+{	
+	printk(KERN_INFO "Initializing NETLINK_KEY socket\n");
+	
+	nlkey_socket = netlink_kernel_create(&init_net, NETLINK_KEY, 1,
+				     ipsec_nlkey_rcv, NULL, THIS_MODULE);
+}
+#endif
+
+
 static int __net_init pfkey_net_init(struct net *net)
 {
 	struct netns_pfkey *net_pfkey = net_generic(net, pfkey_net_id);
@@ -3761,14 +4456,21 @@ static struct pernet_operations pfkey_net_ops = {
 	.size = sizeof(struct netns_pfkey),
 };
 
+
 static void __exit ipsec_pfkey_exit(void)
 {
 	xfrm_unregister_km(&pfkeyv2_mgr);
 	sock_unregister(PF_KEY);
 	unregister_pernet_subsys(&pfkey_net_ops);
 	proto_unregister(&key_proto);
+
+#ifdef NLKEY_SUPPORT
+	/* release NETLINK_KEY socket */
+	sock_release(nlkey_socket->sk_socket);
+#endif
 }
 
+
 static int __init ipsec_pfkey_init(void)
 {
 	int err = proto_register(&key_proto, 0);
@@ -3785,6 +4487,12 @@ static int __init ipsec_pfkey_init(void)
 	err = xfrm_register_km(&pfkeyv2_mgr);
 	if (err != 0)
 		goto out_sock_unregister;
+
+#ifdef NLKEY_SUPPORT
+	/* create NETLINK_KEY socket for IPSec offload on Comcerto */
+	ipsec_nlkey_init();
+#endif
+
 out:
 	return err;
 
diff --git a/net/xfrm/xfrm_input.c b/net/xfrm/xfrm_input.c
index 45f1c98..9d755e3 100644
--- a/net/xfrm/xfrm_input.c
+++ b/net/xfrm/xfrm_input.c
@@ -14,6 +14,14 @@
 #include <net/ip.h>
 #include <net/xfrm.h>
 
+#if !defined(CONFIG_ARCH_M83XXX)  /* FIXME: Check this for c100 */
+#if defined(CONFIG_INET6_IPSEC_OFFLOAD)	
+#include <net/protocol.h>
+#include <linux/icmpv6.h>
+#include <net/rawv6.h>
+#include <net/addrconf.h>
+#endif
+#endif
 static struct kmem_cache *secpath_cachep __read_mostly;
 
 void __secpath_destroy(struct sec_path *sp)
@@ -160,6 +168,20 @@ int xfrm_input(struct sk_buff *skb, int nexthdr, __be32 spi, int encap_type)
 		}
 
 		skb->sp->xvec[skb->sp->len++] = x;
+#if !defined(CONFIG_ARCH_M83XXX)  /* FIXME: Check this for c100 */
+#if defined(CONFIG_INET6_IPSEC_OFFLOAD)	
+		// Send data back to fpp if packet fits in 4Kb buffer... else soft decryption
+		if ((x->offloaded) && ( (skb->len + (skb->data - skb_mac_header(skb))) < (SZ_4K - 64 - sizeof(struct skb_shared_info)))) {
+			// Only fragemented and reassembled packet may comes here -> re-send reassembly packets to original input interface.
+			skb->ipsec_offload = 1;
+			skb_push(skb, skb->data - skb_mac_header(skb));
+			dev_queue_xmit(skb);
+			spin_unlock(&x->lock);
+			xfrm_state_put(x);
+			return -1;
+		}
+#endif	
+#endif
 
 		spin_lock(&x->lock);
 		if (unlikely(x->km.state != XFRM_STATE_VALID)) {
diff --git a/net/xfrm/xfrm_output.c b/net/xfrm/xfrm_output.c
index 6a32915..0f9a543 100644
--- a/net/xfrm/xfrm_output.c
+++ b/net/xfrm/xfrm_output.c
@@ -43,11 +43,31 @@ static int xfrm_output_one(struct sk_buff *skb, int err)
 	struct dst_entry *dst = skb_dst(skb);
 	struct xfrm_state *x = dst->xfrm;
 	struct net *net = xs_net(x);
+#if defined(CONFIG_INET_IPSEC_OFFLOAD) || defined(CONFIG_INET6_IPSEC_OFFLOAD)
+	struct xfrm_state *xfrm_vec[XFRM_MAX_DEPTH];
+	int xfrm_nr = 0;
+	int i;
+#endif
 
 	if (err <= 0)
 		goto resume;
 
 	do {
+#if defined(CONFIG_INET_IPSEC_OFFLOAD) || defined(CONFIG_INET6_IPSEC_OFFLOAD)
+		if (x->offloaded)  {
+			if (xfrm_nr == XFRM_MAX_DEPTH) {
+				err = -ENOBUFS;
+				goto out_exit;
+			}
+
+			if (!x->curlft.use_time) 
+				x->curlft.use_time = get_seconds();
+
+			xfrm_vec[xfrm_nr++] = x;
+			skb->ipsec_offload = 1;
+			goto next_dst;
+		}
+#endif
 		err = xfrm_state_check_space(x, skb);
 		if (err) {
 			XFRM_INC_STATS(net, LINUX_MIB_XFRMOUTERROR);
@@ -95,6 +115,9 @@ resume:
 			goto error_nolock;
 		}
 
+#if defined(CONFIG_INET_IPSEC_OFFLOAD) || defined(CONFIG_INET6_IPSEC_OFFLOAD)
+next_dst:
+#endif
 		dst = dst_pop(dst);
 		if (!dst) {
 			XFRM_INC_STATS(net, LINUX_MIB_XFRMOUTERROR);
@@ -106,6 +129,26 @@ resume:
 	} while (x && !(x->outer_mode->flags & XFRM_MODE_FLAG_TUNNEL));
 
 	err = 0;
+#if defined(CONFIG_INET_IPSEC_OFFLOAD) || defined(CONFIG_INET6_IPSEC_OFFLOAD)
+	if (!skb->sp || atomic_read(&skb->sp->refcnt) != 1) {
+		struct sec_path *sp;
+
+		sp = secpath_dup(skb->sp);
+		if (!sp)
+			goto error_nolock;
+		if (skb->sp)
+			secpath_put(skb->sp);
+		skb->sp = sp;
+	}
+	if (xfrm_nr + skb->sp->len > XFRM_MAX_DEPTH)
+		goto error_nolock;
+
+	memcpy(skb->sp->xvec + skb->sp->len, xfrm_vec,
+	       xfrm_nr * sizeof(xfrm_vec[0]));
+	skb->sp->len += xfrm_nr;
+	for (i = 0; i < skb->sp->len; i++)
+		xfrm_state_hold(skb->sp->xvec[i]);
+#endif
 
 out_exit:
 	return err;
diff --git a/net/xfrm/xfrm_policy.c b/net/xfrm/xfrm_policy.c
index 843e066..50e96ca 100644
--- a/net/xfrm/xfrm_policy.c
+++ b/net/xfrm/xfrm_policy.c
@@ -47,7 +47,14 @@ static struct kmem_cache *xfrm_dst_cache __read_mostly;
 static HLIST_HEAD(xfrm_policy_gc_list);
 static DEFINE_SPINLOCK(xfrm_policy_gc_lock);
 
+#if defined(CONFIG_INET_IPSEC_OFFLOAD) || defined(CONFIG_INET6_IPSEC_OFFLOAD)
+extern int ipsec_nlkey_flow(u16 xfrm_nr, u16 *xfrm_handle,
+                struct flowi *fl, u16 family, u16 dir);
+#endif
+
+#if !defined(CONFIG_INET_IPSEC_OFFLOAD) && defined(CONFIG_INET6_IPSEC_OFFLOAD)
 static struct xfrm_policy_afinfo *xfrm_policy_get_afinfo(unsigned short family);
+#endif
 static void xfrm_policy_put_afinfo(struct xfrm_policy_afinfo *afinfo);
 static void xfrm_init_pmtu(struct dst_entry *dst);
 
@@ -88,7 +95,10 @@ int xfrm_selector_match(struct xfrm_selector *sel, struct flowi *fl,
 	return 0;
 }
 
-static inline struct dst_entry *__xfrm_dst_lookup(struct net *net, int tos,
+#if !defined(CONFIG_INET_IPSEC_OFFLOAD) && !defined(CONFIG_INET6_IPSEC_OFFLOAD) 
+static inline 
+#endif
+struct dst_entry *__xfrm_dst_lookup(struct net *net, int tos,
 						  xfrm_address_t *saddr,
 						  xfrm_address_t *daddr,
 						  int family)
@@ -106,8 +116,14 @@ static inline struct dst_entry *__xfrm_dst_lookup(struct net *net, int tos,
 
 	return dst;
 }
+#if defined(CONFIG_INET_IPSEC_OFFLOAD) || defined(CONFIG_INET6_IPSEC_OFFLOAD)
+EXPORT_SYMBOL(__xfrm_dst_lookup);
+#endif
 
-static inline struct dst_entry *xfrm_dst_lookup(struct xfrm_state *x, int tos,
+#if !defined(CONFIG_INET_IPSEC_OFFLOAD) && !defined(CONFIG_INET6_IPSEC_OFFLOAD) 
+static inline 
+#endif
+struct dst_entry *xfrm_dst_lookup(struct xfrm_state *x, int tos,
 						xfrm_address_t *prev_saddr,
 						xfrm_address_t *prev_daddr,
 						int family)
@@ -137,6 +153,9 @@ static inline struct dst_entry *xfrm_dst_lookup(struct xfrm_state *x, int tos,
 
 	return dst;
 }
+#if defined(CONFIG_INET_IPSEC_OFFLOAD) || defined(CONFIG_INET6_IPSEC_OFFLOAD)
+EXPORT_SYMBOL(xfrm_dst_lookup);
+#endif
 
 static inline unsigned long make_jiffies(long secs)
 {
@@ -1312,7 +1331,10 @@ xfrm_find_bundle(struct flowi *fl, struct xfrm_policy *policy, unsigned short fa
 	return x;
 }
 
-static inline int xfrm_get_tos(struct flowi *fl, int family)
+#if !defined(CONFIG_INET_IPSEC_OFFLOAD) && !defined(CONFIG_INET6_IPSEC_OFFLOAD)
+static inline 
+#endif
+int xfrm_get_tos(struct flowi *fl, int family)
 {
 	struct xfrm_policy_afinfo *afinfo = xfrm_policy_get_afinfo(family);
 	int tos;
@@ -1326,6 +1348,9 @@ static inline int xfrm_get_tos(struct flowi *fl, int family)
 
 	return tos;
 }
+#if defined(CONFIG_INET_IPSEC_OFFLOAD) || defined(CONFIG_INET6_IPSEC_OFFLOAD)
+EXPORT_SYMBOL(xfrm_get_tos);
+#endif
 
 static inline struct xfrm_dst *xfrm_alloc_dst(struct net *net, int family)
 {
@@ -1441,7 +1466,12 @@ static struct dst_entry *xfrm_bundle_create(struct xfrm_policy *policy,
 		xdst->route = dst;
 		memcpy(&dst1->metrics, &dst->metrics, sizeof(dst->metrics));
 
+#if defined(CONFIG_INET_IPSEC_OFFLOAD) || defined(CONFIG_INET6_IPSEC_OFFLOAD)
+		if ((xfrm[i]->props.mode != XFRM_MODE_TRANSPORT) &&
+			(!xfrm[i]->offloaded)) {
+#else
 		if (xfrm[i]->props.mode != XFRM_MODE_TRANSPORT) {
+#endif
 			family = xfrm[i]->props.family;
 			dst = xfrm_dst_lookup(xfrm[i], tos, &saddr, &daddr,
 					      family);
@@ -1567,6 +1597,9 @@ int __xfrm_lookup(struct net *net, struct dst_entry **dst_p, struct flowi *fl,
 	int err;
 	u32 genid;
 	u16 family;
+#if defined(CONFIG_INET_IPSEC_OFFLOAD) || defined(CONFIG_INET6_IPSEC_OFFLOAD)
+	u8 new_flow = 0;
+#endif
 	u8 dir = policy_to_flow_dir(XFRM_POLICY_OUT);
 
 restart:
@@ -1593,8 +1626,13 @@ restart:
 		    !net->xfrm.policy_count[XFRM_POLICY_OUT])
 			goto nopol;
 
+#if defined(CONFIG_INET_IPSEC_OFFLOAD) || defined(CONFIG_INET6_IPSEC_OFFLOAD)
+		policy = flow_cache_lookup(net, fl, dst_orig->ops->family,
+					   dir, &new_flow, xfrm_policy_lookup);
+#else
 		policy = flow_cache_lookup(net, fl, dst_orig->ops->family,
 					   dir, xfrm_policy_lookup);
+#endif
 		err = PTR_ERR(policy);
 		if (IS_ERR(policy)) {
 			XFRM_INC_STATS(net, LINUX_MIB_XFRMOUTPOLERROR);
@@ -1777,6 +1815,29 @@ restart:
 		dst_hold(dst);
 		write_unlock_bh(&policy->lock);
 	}
+#if defined(CONFIG_INET_IPSEC_OFFLOAD) || defined(CONFIG_INET6_IPSEC_OFFLOAD)
+	if (new_flow) {
+		struct dst_entry *dst1 = dst;
+		struct xfrm_state *x; 
+		u16	xfrm_handle[XFRM_POLICY_TYPE_MAX];
+
+		xfrm_nr = 0;
+		memset(xfrm_handle, 0, XFRM_POLICY_TYPE_MAX*sizeof(u16));		
+		while((x = dst1->xfrm) != NULL) {
+			if (!x->offloaded) 
+				goto std_path;
+			xfrm_handle[xfrm_nr++] = x->handle;
+			dst1 = dst1->child;
+			if (dst1 == NULL) {
+				err = -EHOSTUNREACH;
+				goto error;
+			}	
+		}
+		// sent flow notification to cmm with sa_handle
+		ipsec_nlkey_flow(xfrm_nr, xfrm_handle, fl, family, (unsigned short)dir);
+	}
+std_path:
+#endif
 	*dst_p = dst;
 	dst_release(dst_orig);
 	xfrm_pols_put(pols, npols);
@@ -1915,6 +1976,9 @@ int __xfrm_policy_check(struct sock *sk, int dir, struct sk_buff *skb,
 	int xfrm_nr;
 	int pi;
 	int reverse;
+#if defined(CONFIG_INET_IPSEC_OFFLOAD) || defined(CONFIG_INET6_IPSEC_OFFLOAD)
+	u8 new_flow = 0;
+#endif
 	struct flowi fl;
 	u8 fl_dir;
 	int xerr_idx = -1;
@@ -1953,8 +2017,13 @@ int __xfrm_policy_check(struct sock *sk, int dir, struct sk_buff *skb,
 	}
 
 	if (!pol)
+#if defined(CONFIG_INET_IPSEC_OFFLOAD) || defined(CONFIG_INET6_IPSEC_OFFLOAD)
+		pol = flow_cache_lookup(net, &fl, family, fl_dir, &new_flow,
+					xfrm_policy_lookup);
+#else
 		pol = flow_cache_lookup(net, &fl, family, fl_dir,
 					xfrm_policy_lookup);
+#endif
 
 	if (IS_ERR(pol)) {
 		XFRM_INC_STATS(net, LINUX_MIB_XFRMINPOLERROR);
@@ -2043,6 +2112,25 @@ int __xfrm_policy_check(struct sock *sk, int dir, struct sk_buff *skb,
 			goto reject;
 		}
 
+#if defined(CONFIG_INET_IPSEC_OFFLOAD) || defined(CONFIG_INET6_IPSEC_OFFLOAD)
+		if (new_flow) {
+			struct xfrm_state *x; 
+			u16	xfrm_handle[XFRM_POLICY_TYPE_MAX];
+
+			xfrm_nr = 0;
+			memset(xfrm_handle, 0, XFRM_POLICY_TYPE_MAX*sizeof(u16));		
+			for (i=skb->sp->len-1; i>=0; i--) {
+				x = skb->sp->xvec[i];
+				if (!x->offloaded) 
+					goto std_path;
+				xfrm_handle[xfrm_nr++] = x->handle;
+			}
+			// sent flow notification to cmm with sa_handle
+			ipsec_nlkey_flow(xfrm_nr, xfrm_handle, &fl, family, fl_dir);
+		}
+
+std_path:
+#endif
 		xfrm_pols_put(pols, npols);
 		return 1;
 	}
@@ -2402,7 +2490,10 @@ static void __net_init xfrm_dst_ops_init(struct net *net)
 	read_unlock_bh(&xfrm_policy_afinfo_lock);
 }
 
-static struct xfrm_policy_afinfo *xfrm_policy_get_afinfo(unsigned short family)
+#if !defined(CONFIG_INET_IPSEC_OFFLOAD) && !defined(CONFIG_INET6_IPSEC_OFFLOAD)
+static 
+#endif
+struct xfrm_policy_afinfo *xfrm_policy_get_afinfo(unsigned short family)
 {
 	struct xfrm_policy_afinfo *afinfo;
 	if (unlikely(family >= NPROTO))
@@ -2413,6 +2504,9 @@ static struct xfrm_policy_afinfo *xfrm_policy_get_afinfo(unsigned short family)
 		read_unlock(&xfrm_policy_afinfo_lock);
 	return afinfo;
 }
+#if defined(CONFIG_INET_IPSEC_OFFLOAD) || defined(CONFIG_INET6_IPSEC_OFFLOAD)
+EXPORT_SYMBOL(xfrm_policy_get_afinfo);
+#endif
 
 static void xfrm_policy_put_afinfo(struct xfrm_policy_afinfo *afinfo)
 {
diff --git a/net/xfrm/xfrm_state.c b/net/xfrm/xfrm_state.c
index 2175712..b9127ff 100644
--- a/net/xfrm/xfrm_state.c
+++ b/net/xfrm/xfrm_state.c
@@ -39,6 +39,9 @@ static DEFINE_SPINLOCK(xfrm_state_lock);
 
 static unsigned int xfrm_state_hashmax __read_mostly = 1 * 1024 * 1024;
 static unsigned int xfrm_state_genid;
+#if defined(CONFIG_INET_IPSEC_OFFLOAD) || defined(CONFIG_INET6_IPSEC_OFFLOAD)
+static unsigned short xfrm_state_handle;
+#endif
 
 static struct xfrm_state_afinfo *xfrm_state_get_afinfo(unsigned int family);
 static void xfrm_state_put_afinfo(struct xfrm_state_afinfo *afinfo);
@@ -73,11 +76,20 @@ xfrm_spi_hash(struct net *net, xfrm_address_t *daddr, __be32 spi, u8 proto, unsi
 	return __xfrm_spi_hash(daddr, spi, proto, family, net->xfrm.state_hmask);
 }
 
+#if defined(CONFIG_INET_IPSEC_OFFLOAD) || defined(CONFIG_INET6_IPSEC_OFFLOAD)
+static void xfrm_hash_transfer(struct hlist_head *list,
+			       struct hlist_head *ndsttable,
+			       struct hlist_head *nsrctable,
+			       struct hlist_head *nspitable,
+			       struct hlist_head *nhtable,
+			       unsigned int nhashmask)
+#else
 static void xfrm_hash_transfer(struct hlist_head *list,
 			       struct hlist_head *ndsttable,
 			       struct hlist_head *nsrctable,
 			       struct hlist_head *nspitable,
 			       unsigned int nhashmask)
+#endif
 {
 	struct hlist_node *entry, *tmp;
 	struct xfrm_state *x;
@@ -101,6 +113,11 @@ static void xfrm_hash_transfer(struct hlist_head *list,
 					    nhashmask);
 			hlist_add_head(&x->byspi, nspitable+h);
 		}
+#if defined(CONFIG_INET_IPSEC_OFFLOAD) || defined(CONFIG_INET6_IPSEC_OFFLOAD)
+		if (x->handle) {
+			hlist_add_head(&x->byh, nhtable+(x->handle & nhashmask));
+		}
+#endif
 	}
 }
 
@@ -115,6 +132,9 @@ static void xfrm_hash_resize(struct work_struct *work)
 {
 	struct net *net = container_of(work, struct net, xfrm.state_hash_work);
 	struct hlist_head *ndst, *nsrc, *nspi, *odst, *osrc, *ospi;
+#if defined(CONFIG_INET_IPSEC_OFFLOAD) || defined(CONFIG_INET6_IPSEC_OFFLOAD)
+	struct hlist_head *nh, *oh;
+#endif
 	unsigned long nsize, osize;
 	unsigned int nhashmask, ohashmask;
 	int i;
@@ -137,21 +157,36 @@ static void xfrm_hash_resize(struct work_struct *work)
 		goto out_unlock;
 	}
 
+#if defined(CONFIG_INET_IPSEC_OFFLOAD) || defined(CONFIG_INET6_IPSEC_OFFLOAD)
+	nh = xfrm_hash_alloc(nsize);
+	if (!nh) {
+		xfrm_hash_free(ndst, nsize);
+		xfrm_hash_free(nsrc, nsize);
+		xfrm_hash_free(nspi, nsize);
+		goto out_unlock;
+	}
+#endif
 	spin_lock_bh(&xfrm_state_lock);
 
 	nhashmask = (nsize / sizeof(struct hlist_head)) - 1U;
 	for (i = net->xfrm.state_hmask; i >= 0; i--)
-		xfrm_hash_transfer(net->xfrm.state_bydst+i, ndst, nsrc, nspi,
+		xfrm_hash_transfer(net->xfrm.state_bydst+i, ndst, nsrc, nspi, nh,
 				   nhashmask);
 
 	odst = net->xfrm.state_bydst;
 	osrc = net->xfrm.state_bysrc;
 	ospi = net->xfrm.state_byspi;
+#if defined(CONFIG_INET_IPSEC_OFFLOAD) || defined(CONFIG_INET6_IPSEC_OFFLOAD)
+	oh   = net->xfrm.state_byh;
+#endif
 	ohashmask = net->xfrm.state_hmask;
 
 	net->xfrm.state_bydst = ndst;
 	net->xfrm.state_bysrc = nsrc;
 	net->xfrm.state_byspi = nspi;
+#if defined(CONFIG_INET_IPSEC_OFFLOAD) || defined(CONFIG_INET6_IPSEC_OFFLOAD)
+	net->xfrm.state_byh   = nh;
+#endif
 	net->xfrm.state_hmask = nhashmask;
 
 	spin_unlock_bh(&xfrm_state_lock);
@@ -160,6 +195,9 @@ static void xfrm_hash_resize(struct work_struct *work)
 	xfrm_hash_free(odst, osize);
 	xfrm_hash_free(osrc, osize);
 	xfrm_hash_free(ospi, osize);
+#if defined(CONFIG_INET_IPSEC_OFFLOAD) || defined(CONFIG_INET6_IPSEC_OFFLOAD)
+	xfrm_hash_free(oh,   osize);
+#endif
 
 out_unlock:
 	mutex_unlock(&hash_resize_mutex);
@@ -513,6 +551,9 @@ struct xfrm_state *xfrm_state_alloc(struct net *net)
 		INIT_HLIST_NODE(&x->bydst);
 		INIT_HLIST_NODE(&x->bysrc);
 		INIT_HLIST_NODE(&x->byspi);
+#if defined(CONFIG_INET_IPSEC_OFFLOAD) || defined(CONFIG_INET6_IPSEC_OFFLOAD)
+		INIT_HLIST_NODE(&x->byh);
+#endif
 		tasklet_hrtimer_init(&x->mtimer, xfrm_timer_handler, CLOCK_REALTIME, HRTIMER_MODE_ABS);
 		setup_timer(&x->rtimer, xfrm_replay_timer_handler,
 				(unsigned long)x);
@@ -523,6 +564,12 @@ struct xfrm_state *xfrm_state_alloc(struct net *net)
 		x->lft.hard_packet_limit = XFRM_INF;
 		x->replay_maxage = 0;
 		x->replay_maxdiff = 0;
+#if defined(CONFIG_INET_IPSEC_OFFLOAD) || defined(CONFIG_INET6_IPSEC_OFFLOAD)
+		x->handle = xfrm_state_handle++;
+		if (x->handle == 0)
+			x->handle = xfrm_state_handle++;
+		hlist_add_head(&x->byh, net->xfrm.state_byh+(x->handle & net->xfrm.state_hmask));
+#endif
 		x->inner_mode = NULL;
 		x->inner_mode_iaf = NULL;
 		spin_lock_init(&x->lock);
@@ -1403,6 +1450,37 @@ xfrm_state_lookup_byaddr(struct net *net, u32 mark,
 }
 EXPORT_SYMBOL(xfrm_state_lookup_byaddr);
 
+#if defined(CONFIG_INET_IPSEC_OFFLOAD) || defined(CONFIG_INET6_IPSEC_OFFLOAD)
+struct xfrm_state *__xfrm_state_lookup_byhandle(struct net *net, u16 handle)
+{
+	unsigned int h = (handle & net->xfrm.state_hmask);
+	struct xfrm_state *x;
+	struct hlist_node *entry;
+
+	hlist_for_each_entry(x, entry, net->xfrm.state_byh+h, byh) {
+		if (x->handle != handle)
+			continue;
+	
+		xfrm_state_hold(x);
+		return x;
+	}
+
+	return NULL;
+}
+
+struct xfrm_state *
+xfrm_state_lookup_byhandle(struct net *net, u16 handle)
+{
+	struct xfrm_state *x;
+
+	spin_lock_bh(&xfrm_state_lock);
+	x = __xfrm_state_lookup_byhandle(net, handle);
+	spin_unlock_bh(&xfrm_state_lock);
+	return x;
+}
+EXPORT_SYMBOL(xfrm_state_lookup_byhandle);
+#endif
+
 struct xfrm_state *
 xfrm_find_acq(struct net *net, struct xfrm_mark *mark, u8 mode, u32 reqid, u8 proto,
 	      xfrm_address_t *daddr, xfrm_address_t *saddr,
@@ -2107,6 +2185,12 @@ int __net_init xfrm_state_init(struct net *net)
 	net->xfrm.state_byspi = xfrm_hash_alloc(sz);
 	if (!net->xfrm.state_byspi)
 		goto out_byspi;
+#if defined(CONFIG_INET_IPSEC_OFFLOAD) || defined(CONFIG_INET6_IPSEC_OFFLOAD)
+	net->xfrm.state_byh = xfrm_hash_alloc(sz);
+	if (!net->xfrm.state_byh)
+		goto out_byh;
+	get_random_bytes(&xfrm_state_handle, sizeof(xfrm_state_handle));
+#endif
 	net->xfrm.state_hmask = ((sz / sizeof(struct hlist_head)) - 1);
 
 	net->xfrm.state_num = 0;
@@ -2116,6 +2200,10 @@ int __net_init xfrm_state_init(struct net *net)
 	init_waitqueue_head(&net->xfrm.km_waitq);
 	return 0;
 
+#if defined(CONFIG_INET_IPSEC_OFFLOAD) || defined(CONFIG_INET6_IPSEC_OFFLOAD)
+out_byh:
+	xfrm_hash_free(net->xfrm.state_byspi, sz);
+#endif
 out_byspi:
 	xfrm_hash_free(net->xfrm.state_bysrc, sz);
 out_bysrc:
-- 
1.7.0

