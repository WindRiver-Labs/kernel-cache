From 4cce7937138b756ef81ab5d488e9f972e00ca61e Mon Sep 17 00:00:00 2001
From: Haiqing Bai <Haiqing.Bai@windriver.com>
Date: Mon, 16 May 2011 09:37:15 +0800
Subject: [PATCH 4/7] modified comcerto c1k fpp related files

Signed-off-by: Haiqing Bai <Haiqing.Bai@windriver.com>
---
 drivers/net/comcerto/Kconfig        |    5 +
 drivers/net/comcerto/Makefile       |    2 +
 drivers/net/comcerto/c1000_eth.c    |  242 ++++++++-
 drivers/net/comcerto/comcerto_fpp.c | 1083 +++++++++++++++++++++++++++++++++++
 drivers/net/comcerto/comcerto_fpp.h |  198 +++++++
 drivers/net/comcerto/fpp_csme.c     |  236 ++++++++
 drivers/net/comcerto/if_csmencaps.h |   84 +++
 7 files changed, 1839 insertions(+), 11 deletions(-)
 create mode 100644 drivers/net/comcerto/comcerto_fpp.c
 create mode 100644 drivers/net/comcerto/comcerto_fpp.h
 create mode 100644 drivers/net/comcerto/fpp_csme.c
 create mode 100644 drivers/net/comcerto/if_csmencaps.h

diff --git a/drivers/net/comcerto/Kconfig b/drivers/net/comcerto/Kconfig
index 89dcd13..e73bded 100644
--- a/drivers/net/comcerto/Kconfig
+++ b/drivers/net/comcerto/Kconfig
@@ -9,6 +9,11 @@ config COMCERTO_ETH
 	depends on NET_COMCERTO
 	default y
 
+config COMCERTO_FPP
+	tristate "Mindspeed's Fast Packet Processor Driver"
+	depends on (ARCH_M83XXX || ARCH_M821XX)
+	default m
+
 config COMCERTO_VED
 	tristate "Mindspeed's Comcerto Control over Virtual Ethernet Driver"
 	depends on  NET_COMCERTO
diff --git a/drivers/net/comcerto/Makefile b/drivers/net/comcerto/Makefile
index c552aad..d45b5cd 100644
--- a/drivers/net/comcerto/Makefile
+++ b/drivers/net/comcerto/Makefile
@@ -12,3 +12,5 @@ obj-$(CONFIG_COMCERTO_VED) += comcerto_ved_driver.o
 comcerto_ved_driver-objs := comcerto_ved.o comcerto_smi_part.o comcerto_smi_queue.o comcerto_msp.o
 
 obj-$(CONFIG_COMCERTO_MSP_COREDUMP) += comcerto_coredump.o
+
+obj-$(CONFIG_COMCERTO_FPP) += comcerto_fpp.o fpp_csme.o
diff --git a/drivers/net/comcerto/c1000_eth.c b/drivers/net/comcerto/c1000_eth.c
index 4abaa9b..34f5731 100644
--- a/drivers/net/comcerto/c1000_eth.c
+++ b/drivers/net/comcerto/c1000_eth.c
@@ -46,6 +46,7 @@
 #include <net/xfrm.h>
 #endif
 
+#include "comcerto_fpp.h" 
 #include "c1000_eth.h"
 #include "c1000_fbpool.h"
 #include "comcerto_mii.h"
@@ -57,6 +58,8 @@ extern struct comcerto_eth_platform_data comcerto_gem1_pdata;
 extern struct ethtool_ops c1k_ethtool_ops;
 extern  struct xfrm_state *xfrm_state_lookup_byhandle(struct net *net, u16 handle);
 
+static struct fpp_ops *eth_fpp_ops = NULL;
+
 #define PKT_HEADROOM	(64 + 2)
 #define PKT_BUF_SZ	1536
 
@@ -74,6 +77,19 @@ extern void c1k_gemac_setspeed(struct net_device *dev, int speed);
 
 extern int c1k_gemac_init(struct net_device *dev);
 
+static void c1k_eth_poolA_cb(struct c1k_fbpool *fbpool)
+{
+	void *ret_ptr;
+
+	while ((ret_ptr = c1k_fbpool_get(fbpool))) {
+                ret_ptr = 
+			(void *) ((unsigned long )ret_ptr & ~(FPP_SKB_SIZE - 1));
+
+		kfree(ret_ptr);
+	}
+         
+}
+
 static void c1k_eth_poolB_cb(struct c1k_fbpool *fbpool)
 {
 	void *ret_ptr;
@@ -193,7 +209,45 @@ static void c1k_phy_stop(struct net_device *dev)
 
 static int c1k_fast_path_set(struct net_device *dev, unsigned short state)
 {
+	struct eth_c1k_priv *priv = netdev_priv(dev);
+	unsigned char msg[20];
+	int rc = 0;
+
+	if (netif_msg_drv(priv))
+		printk (KERN_INFO "%s: %s %d\n", __func__, dev->name, state);
+
+	memset(msg, 0, 20);
+
+	if (priv->id)
+		msg[0] = 1;
+	else
+		msg[0] = 0;
+
+	if (state) {
+		c1k_set_tx_csum(dev, 0);
+
+		strcpy(msg + 2, dev->name);
+		memcpy(msg + 14, dev->dev_addr, 6);
+
+		if ((rc = eth_fpp_ops->write(CMD_TX_ENABLE, 20, (unsigned short *)msg)) != 0)
+			goto err;
+
+		if ((rc = eth_fpp_ops->write(CMD_RX_ENABLE, 2, (unsigned short *)msg)) != 0)
+			goto err;
+	} else {
+		if ((rc = eth_fpp_ops->write(CMD_RX_DISABLE, 2, (unsigned short *)msg)) != 0)
+			goto err;
+
+		if ((rc = eth_fpp_ops->write(CMD_TX_DISABLE, 2, (unsigned short *)msg)) != 0)
+			goto err;
+
+		c1k_set_tx_csum(dev, 1);
+	}
+
 	return 0;
+
+err:
+	return -1;
 }
 
 /* Bring the controller up and running */
@@ -301,6 +355,13 @@ int c1k_eth_open(struct net_device *dev)
 		priv->rx_coal_time = DEFAULT_RX_COAL_TIME;
 	}
 
+	priv->poolA = c1k_fbpool_open(0, c1k_eth_poolA_cb);
+	if (!priv->poolA) {
+		printk(KERN_ERR "%s %s: failed to open free buffer pool A\n", dev->name, __func__);
+		rc = -EINVAL;
+		goto err0;
+	}
+
 	priv->poolB = c1k_fbpool_open(1, c1k_eth_poolB_cb);
 	if (!priv->poolB) {
 		printk(KERN_ERR "%s %s: failed to open free buffer pool B\n", dev->name, __func__);
@@ -391,6 +452,9 @@ err2:
 	c1k_fbpool_close(priv->poolB);
 
 err1:
+	c1k_fbpool_close(priv->poolA);
+
+err0:
 	return rc;
 }
 
@@ -420,6 +484,7 @@ int c1k_eth_close(struct net_device *dev)
 		c1k_phy_stop(dev);
 
 	c1k_fbpool_close(priv->poolB);
+	c1k_fbpool_close(priv->poolA);
 
 	return 0;
 }
@@ -598,8 +663,16 @@ static void c1k_eth_release_buffers(struct net_device *dev)
 	for (i = 0; i < priv->RxRingSize; i++) {
 		ThisRXdesc = priv->RxBase + i;
 
+		if (priv->fast_path_enabled) {
+			if (!(ThisRXdesc->rx_extstatus & GEMRX_OWN))
+				continue;
+		}
 		data = phys_to_virt(ThisRXdesc->rx_data);
-		offset = PKT_HEADROOM;
+
+		if (priv->fast_path_enabled)
+			offset = (ThisRXdesc->rx_extstatus & RX_STA_L3OFF_MASK) >> RX_STA_L3OFF_POS;
+		else
+			offset = PKT_HEADROOM;
 
 		length = (ThisRXdesc->rx_status & RX_STA_LEN_MASK) >> RX_STA_LEN_POS;
 
@@ -611,7 +684,14 @@ static void c1k_eth_release_buffers(struct net_device *dev)
 		/* preserve stagger offset */
 		data -= offset;
 		__dma_single_cpu_to_dev(data, PKT_BUF_SZ + PKT_HEADROOM, DMA_FROM_DEVICE);
-		kfree((void *)((unsigned long)data & ~(FPP_SKB_SIZE - 1)));
+
+		if (priv->fast_path_enabled) {
+			if (c1k_fbpool_put(priv->poolA, data) != 0)
+				// buffer pool overflow -> release data
+				kfree((void *)((unsigned long)data & ~(FPP_SKB_SIZE - 1)));
+		}
+		else
+			kfree((void *)((unsigned long)data & ~(FPP_SKB_SIZE - 1)));
 
 		ThisRXdesc->rx_extstatus = 0;
 
@@ -631,7 +711,10 @@ static int c1k_eth_init_buffers(struct net_device *dev)
 	if (netif_msg_drv(priv))
 		printk (KERN_INFO "%s: %s\n", __func__, dev->name);
 
-	priv->RxBase = priv->ARAM_baseaddr_v;
+	if (priv->fast_path_enabled)
+		priv->RxBase = priv->expt_baseaddr_v;
+	else
+		priv->RxBase = priv->ARAM_baseaddr_v;
 
 	memset(priv->RxBase, 0, priv->RxRingSize * sizeof(struct tRXdesc));
 	if (!priv->fast_path_enabled) {
@@ -652,11 +735,22 @@ static int c1k_eth_init_buffers(struct net_device *dev)
 	ThisRXdesc = priv->RxBase + priv->RxRingSize - 1;
 	ThisRXdesc->rx_status |= GEMRX_WRAP;
 
-	writel(virt_to_aram(priv->RxBase), priv->baseaddr + GEM_IP + GEM_RX_QPTR);
-
-	/* init Tx ring */
+	if (!priv->fast_path_enabled)
+		writel(virt_to_aram(priv->RxBase), priv->baseaddr + GEM_IP + GEM_RX_QPTR);
+	else {
+		// inform FPP exception path about the base address through SMI
+		writel((u32)priv->expt_baseaddr_p-(u32)priv->expt_baseaddr_v+(u32)priv->RxBase, priv->fpp_smi_baseaddr + FPP_SMI_RXBASE);
+	}
+	
+	// init Tx ring
 	priv->TxBase = (struct tTXdesc *) (priv->RxBase + priv->RxRingSize);
 
+#if defined(CONFIG_INET_IPSEC_OFFLOAD) || defined(CONFIG_INET6_IPSEC_OFFLOAD)
+	if (priv->fast_path_enabled) {
+		priv->TxextBase = (struct tTXextdesc *) (priv->TxBase + priv->TxRingSize);
+	}
+#endif
+
 	memset(priv->TxBase, 0, priv->TxRingSize * sizeof(struct tTXdesc));
 	ThisTXdesc = priv->TxBase;
 
@@ -668,6 +762,18 @@ static int c1k_eth_init_buffers(struct net_device *dev)
 
 	if (!priv->fast_path_enabled)
 		writel(virt_to_aram(priv->TxBase), priv->baseaddr + GEM_IP + GEM_QUEUE_BASE0);
+	else {
+		 // inform FPP exception path about the base address through SMI
+		writel((u32)priv->expt_baseaddr_p-(u32)priv->expt_baseaddr_v+(u32)priv->TxBase, priv->fpp_smi_baseaddr + FPP_SMI_TXBASE);
+#if defined(CONFIG_INET_IPSEC_OFFLOAD) || defined(CONFIG_INET6_IPSEC_OFFLOAD)
+		writel((u32)priv->expt_baseaddr_p-(u32)priv->expt_baseaddr_v+(u32)priv->TxextBase, priv->fpp_smi_baseaddr + FPP_SMI_TXEXTBASE);
+#endif
+	}
+
+	if (priv->fast_path_enabled) {
+		if (c1k_fbpool_fill(priv->poolA, FPP_SKB_SIZE, GFP_KERNEL, 1))
+			goto err;
+	}
 
 	priv->RxtocleanIndex = 0;
 	priv->RxtofillIndex = 0;
@@ -727,6 +833,38 @@ c1k_hardware_send_packet(struct net_device *dev, struct sk_buff *skb)
 		if ((priv->flags & TX_CSUM_OFFLOAD_ENABLED) && (skb->ip_summed == CHECKSUM_PARTIAL))
 			txctl |= GEMTX_L4_CSUM | GEMTX_L3_CSUM;
 	}
+	else
+	{
+		u32 queuenum;
+		if ((priv->flags & TX_CSUM_OFFLOAD_ENABLED) && (skb->ip_summed == CHECKSUM_PARTIAL))
+			txctl |= GEMTX_EXPT_L34_CSUM;
+		/* Get the FPP queue number from the CONNMARK value */
+#if defined(CONFIG_IP_NF_CONNTRACK_MARK) || defined(CONFIG_NF_CONNTRACK_MARK)
+		if (skb->nfct)
+		{
+			enum ip_conntrack_info cinfo;
+			struct nf_conn *ct;
+			ct = nf_ct_get(skb, &cinfo);
+			if (ct)
+			{
+				u_int32_t connmark;
+				connmark = ct->mark;
+				if ((connmark & 0x80000000) && priv->id != 0)
+					connmark >>= 16;
+				queuenum = connmark;
+			}
+			else
+				queuenum = 0;
+		}
+		else  /* continued after #endif ... */
+#endif
+		/*else*/ if (skb->mark & 0x1F)
+			queuenum = skb->mark;
+		else
+			queuenum = priv->default_priority;
+		txctl |= (queuenum << GEMTX_EXPT_QOS_SHIFT) & GEMTX_EXPT_QOS_MASK;
+	}
+
 
 	if (priv->Txtosend == (priv->TxRingSize - 1))
 		txctl |= GEMTX_WRAP;
@@ -849,10 +987,17 @@ static int c1k_eth_rx_refill(struct net_device *dev)
 				/* preserve stagger offset */
 				data += ((ThisRXdesc->rx_data - offset) & (FPP_SKB_SIZE - 1));
 				__dma_single_cpu_to_dev(data, PKT_BUF_SZ + PKT_HEADROOM, DMA_FROM_DEVICE);
-				ThisRXdesc->rx_data = virt_to_phys(data) + PKT_HEADROOM;
-				/* unlock descriptor */
-				*(volatile u32 *) &ThisRXdesc->rx_extstatus = 0;
-				if (netif_msg_drv(priv))
+
+				if (priv->fast_path_enabled) {
+					if (c1k_fbpool_put(priv->poolA, data) != 0)
+						// buffer pool overflow -> release data
+						kfree((void *)((unsigned long)data & ~(FPP_SKB_SIZE - 1)));
+				}
+				else
+					ThisRXdesc->rx_data = virt_to_phys(data) + PKT_HEADROOM;
+				// unlock descriptor;
+				*(volatile u32*) &ThisRXdesc->rx_extstatus = 0;
+			if (netif_msg_drv(priv))
 					printk(KERN_INFO "%s %s refill poolA refill %p\n", dev->name, __func__, data);
 			} else {
 				if (netif_msg_rx_err(priv))
@@ -1032,7 +1177,14 @@ pkt_drop:
 				/* preserve stagger offset */
 				data += ((rx_data - offset) & (FPP_SKB_SIZE - 1));
 				__dma_single_cpu_to_dev(data, PKT_BUF_SZ + PKT_HEADROOM, DMA_FROM_DEVICE);
-				ThisRXdesc->rx_data = virt_to_phys(data) + PKT_HEADROOM;
+
+				if (priv->fast_path_enabled) {
+	  			if (c1k_fbpool_put(priv->poolA, data) != 0)
+	  				// buffer pool overflow -> release data
+	  				kfree((void *)((unsigned long)data & ~(FPP_SKB_SIZE - 1)));
+	  		}
+	  		else
+	  			ThisRXdesc->rx_data = virt_to_phys(data) + PKT_HEADROOM;
 
 				/* unlock descriptor */
 				*(volatile u32 *)&ThisRXdesc->rx_extstatus = 0;
@@ -1354,6 +1506,16 @@ static void c1k_adjust_link(struct net_device *dev)
 			priv->oldlink = 1;
 		}
 
+		if (new_state)
+			if (priv->fast_path_enabled) {
+				u16 data[3];
+
+				data[0] = priv->id;
+				data[1] = phydev->speed;
+				data[2] = phydev->duplex;
+
+				eth_fpp_ops->write_atomic(CMD_LINK_UP, 6, data);
+			}
 	} else if (priv->oldlink) {
 		new_state = 1;
 		priv->oldlink = 0;
@@ -1466,6 +1628,64 @@ static int __init hwaddress_setup(char *str)
 
 __setup("hwaddress=", hwaddress_setup);
 
+int comcerto_eth_register_fpp_ops(struct fpp_ops *ops)
+{
+	eth_fpp_ops = ops;
+
+	return 0;
+}
+EXPORT_SYMBOL(comcerto_eth_register_fpp_ops);
+
+
+void comcerto_eth_unregister_fpp_ops(void)
+{
+	eth_fpp_ops = NULL;
+}
+EXPORT_SYMBOL(comcerto_eth_unregister_fpp_ops);
+
+int c1k_eth_enable_fast_path(struct net_device *dev, unsigned short state)
+{
+	struct eth_c1k_priv *priv = netdev_priv(dev);
+	int rc = 0;
+
+	if (priv->fast_path_enabled == state)
+		goto out;
+
+	if (state) {
+		if (!eth_fpp_ops) {
+			printk(KERN_ERR "%s(): Can't enable fast path, fpp ops not registered\n", __func__);
+			goto out;
+		}
+
+		if (!try_module_get(eth_fpp_ops->owner))
+			goto out;
+	}
+
+	rtnl_lock();
+	if (dev->flags & IFF_UP) {
+		rc = c1k_eth_close(dev);
+		if (rc)
+			goto out_unlock;
+
+		priv->fast_path_enabled = state;
+		rc = c1k_eth_open(dev);
+		if (rc)
+			goto out_unlock;
+
+		c1k_eth_set_multi(dev);
+	} else
+		priv->fast_path_enabled = state;
+
+out_unlock:
+	if (!state && eth_fpp_ops)
+		module_put(eth_fpp_ops->owner);
+
+	rtnl_unlock();
+
+out:
+	return rc;
+}
+
 static int __init c1k_eth_init(void)
 {
 	return platform_driver_register(&c1k_eth_driver);
diff --git a/drivers/net/comcerto/comcerto_fpp.c b/drivers/net/comcerto/comcerto_fpp.c
new file mode 100644
index 0000000..874aacf
--- /dev/null
+++ b/drivers/net/comcerto/comcerto_fpp.c
@@ -0,0 +1,1083 @@
+ /*
+  *  linux/drivers/net/comcerto/comcerto_fpp.c
+  *
+  *  Copyright (C) 2006 Mindspeed Technologies, Inc.
+  *
+  * This program is free software; you can redistribute it and/or modify
+  * it under the terms of the GNU General Public License as published by
+  * the Free Software Foundation; either version 2 of the License, or
+  * (at your option) any later version.
+  *
+  * This program is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  * GNU General Public License for more details.
+  *
+  * You should have received a copy of the GNU General Public License
+  * along with this program; if not, write to the Free Software
+  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+  */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/string.h>
+#include <linux/dma-mapping.h>
+#include <linux/sched.h>
+
+
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/delay.h>
+#include <asm/mach/irq.h>
+#include <mach/hardware.h>
+#include <mach/memory.h>
+#include <mach/debug.h>
+#include <mach/irq.h>
+#include <asm/sizes.h>
+#include <asm/uaccess.h>
+
+#include <linux/platform_device.h>
+#include <linux/firmware.h>
+#include <linux/interrupt.h>
+#include <linux/elf.h>
+
+#include "comcerto_fpp.h"
+#include "c1000_eth.h"
+
+const char comcerto_fpp_driver_name[] = "Comcerto Fast Path Processor Driver";
+const char comcerto_fpp_driver_version[] = "1.0";
+struct mutex fpp_mutex; 
+
+static struct device fpp_device = {
+	.init_name = "ghost0",
+};
+
+static int comcerto_fpp_write_atomic(u16 fcode, u16 length, u16 *payload);
+static int comcerto_fpp_write(u16 fcode, u16 length, u16 *payload);
+extern int comcerto_eth_register_fpp_ops(struct fpp_ops *ops);
+extern void comcerto_eth_unregister_fpp_ops(void);
+extern int dci_kioctl(unsigned int cmd, unsigned int flag, struct sk_buff *this_skb);
+
+#if defined(CONFIG_ARCH_M821XX) || defined(CONFIG_ARCH_M822XX)
+struct {
+	struct list_head buffer_list;
+	spinlock_t lock;
+} fpp_pool;
+
+
+static void fpp_add_buffer(void *buffer)
+{
+	unsigned long flags;
+
+//	printk (KERN_INFO "add_buffer: %lx %lx\n", (unsigned long)buffer, virt_to_phys(buffer));
+
+	spin_lock_irqsave(&fpp_pool.lock, flags);
+	list_add((struct list_head *) buffer, &fpp_pool.buffer_list);
+	spin_unlock_irqrestore(&fpp_pool.lock, flags);
+}
+
+static void fpp_del_buffer(void *buffer) 
+{
+	unsigned long flags;
+
+//	printk (KERN_INFO "del_buffer: %lx %lx\n", (unsigned long)buffer, virt_to_phys(buffer));
+
+	spin_lock_irqsave(&fpp_pool.lock, flags);
+	list_del((struct list_head *)buffer);
+	spin_unlock_irqrestore(&fpp_pool.lock, flags);
+}
+
+
+/**
+ * comcerto_fpp_pool_reset - 
+ *
+ *
+ */
+static void comcerto_fpp_pool_reset(void)
+{
+	struct list_head *head, *tmp;
+	unsigned long flags;
+
+	spin_lock_irqsave(&fpp_pool.lock, flags);
+
+	list_for_each_safe(head, tmp, &fpp_pool.buffer_list) {
+//		printk(KERN_INFO "free_buffer: %lx %lx\n", (unsigned long)head, virt_to_phys(head));
+		list_del(head);
+		kfree(head);
+	}
+
+	spin_unlock_irqrestore(&fpp_pool.lock, flags);
+}
+
+/**
+ * comcerto_fpp_pool_init - 
+ *
+ *
+ */
+static int comcerto_fpp_pool_init(void)
+{
+	int total = 0;
+	int n, i;
+	u16 cmd[128];
+	u32 *pool;
+	void *ptr;
+	int rc;
+
+	INIT_LIST_HEAD(&fpp_pool.buffer_list);
+	spin_lock_init(&fpp_pool.lock);
+
+	// populate packets buffer pool
+	do {
+		if (total)
+			cmd[0] = 0;
+		else
+			/* Reset the FPP buffer pool */
+			cmd[0] = 1;
+
+		cmd[1] = 0;
+		pool = (u32 *)&cmd[2];
+		n = min(63, (FPP_PKT_POOL_SIZE - total));
+		for (i = 0; i < n; i++) {
+			ptr = kmalloc(FPP_SKB_SIZE, GFP_KERNEL | GFP_DMA);
+			if (!ptr) {
+				printk(KERN_ERR "comcerto_fpp: unable to allocate FPP's buffer pool\n");
+				rc = -ENOMEM;
+				goto err;
+			}
+
+			dma_cache_maint(ptr, FPP_SKB_SIZE, DMA_FROM_DEVICE);
+
+//			printk(KERN_INFO "%d %d %lx %lx\n", total, i, (unsigned long)ptr,  virt_to_phys(ptr));
+
+			*pool++ = virt_to_phys(ptr);
+			total++;
+
+			/* add to internal hash table for linux buffer track/release */
+			fpp_add_buffer(ptr);
+		}
+
+		rc = comcerto_fpp_write(CMD_RX_FILL_BUFFERPOOL, 2 * sizeof(u16) + n * sizeof(u32), cmd);
+		if (rc)
+			goto err;
+
+	} while (total < FPP_PKT_POOL_SIZE);
+
+	return 0;
+
+err:
+	comcerto_fpp_pool_reset();	
+	return rc;
+}
+#endif /* defined(CONFIG_ARCH_M821XX) || defined(CONFIG_ARCH_M822XX) */
+
+static struct fpp_ops ops = {
+	.write = comcerto_fpp_write,
+	.write_atomic = comcerto_fpp_write_atomic,
+#if defined(CONFIG_ARCH_M821XX) || defined(CONFIG_ARCH_M822XX)
+	.add_buffer = fpp_add_buffer,
+	.del_buffer = fpp_del_buffer,
+#endif
+	.owner = THIS_MODULE,
+};
+
+/**
+ * comcerto_fpp_register_to_eth -
+ *
+ */
+static int comcerto_fpp_register_to_eth(void)
+{
+	int rc;
+
+	/* register the FPP module to the Ethernet Driver */
+	rc = comcerto_eth_register_fpp_ops(&ops);
+	if (rc)
+	{
+		printk(KERN_ERR "comcerto_eth_register_fpp_ops() failed !\n");
+		goto err;
+	}
+
+	return 0;
+
+err:
+	return rc;
+}
+
+/**
+ * comcerto_fpp_register_event_cb -
+ *
+ */
+int comcerto_fpp_register_event_cb(void *cb)
+{
+	struct comcerto_fpp *fpp = dev_get_drvdata(&fpp_device);
+
+	/* register FCI callback used for asynchrounous event */
+	fpp->event_cb = (FPP_EVENT_CB)cb;
+
+	//printk(KERN_INFO "FPP: %s()\n", __func__);
+
+	return 0;
+}
+
+/**
+ * comcerto_fpp_read - 
+ *
+ *
+ */
+static int comcerto_fpp_read(u16 *fcode, u16 *length, u16 *payload)
+{
+	int rc = -EIO;
+
+	//printk(KERN_INFO "%s\n", __func__);
+
+	/* get function code */
+	*fcode = (__raw_readl(CMD_MBOX_1_ADDR) >> 16);
+
+	/* get message length */
+	*length = (__raw_readl(CMD_MBOX_1_ADDR) & 0x0000FFFF);
+
+	if (*length > FPP_MAX_MSG_LENGTH)
+	{
+		printk(KERN_ERR "%s: message length(%d) above (%d)\n", __func__, *length, FPP_MAX_MSG_LENGTH);
+		*length = FPP_MAX_MSG_LENGTH;
+	}
+
+	rc = 0;
+
+	/* copy message data */
+	memcpy(payload, CMD_DATA_ADDR, *length);
+
+	/* new message processed clear busy bit */
+	__raw_writel(0, CMD_MBOX_0_ADDR);
+
+	//printk(KERN_INFO "%s done\n", __func__);
+
+	return rc;
+}
+
+/**
+* comcerto_fpp_check_ack
+* 
+*/
+static int comcerto_fpp_check_ack(unsigned long timeout)
+{
+	unsigned long end = jiffies + 2;
+
+	//printk(KERN_INFO "%s\n", __func__);
+
+	/* do busy-wait for up to 1 clock tick */
+
+	while (time_before(jiffies, end))
+	{
+		if ((__raw_readl(CMD_MBOX_0_ADDR) & M0_ACK) != 0)
+			return 0;
+
+		if (need_resched())
+			schedule();
+	}
+
+	/* if we get this far, we need to release the cpu to other tasks */
+
+	end = end + (timeout * HZ) / 1000 - 2;
+	while (time_before(jiffies, end))
+	{
+		if ((__raw_readl(CMD_MBOX_0_ADDR) & M0_ACK) != 0)
+			return 0;
+
+		set_current_state(TASK_UNINTERRUPTIBLE);
+		schedule_timeout(1);
+	}
+
+	if ((__raw_readl(CMD_MBOX_0_ADDR) & M0_ACK) != 0)
+		return 0;
+
+	printk(KERN_ERR "%s: didn't receive ack from FPP m0(%x) m1(%x)\n", __func__, __raw_readl(CMD_MBOX_0_ADDR), __raw_readl(CMD_MBOX_1_ADDR));
+
+	__raw_writel(0, CMD_MBOX_0_ADDR);
+
+	return -EIO;
+}
+
+
+/**
+ * comcerto_fpp_cmd - 
+ *
+ *
+ */
+static int comcerto_fpp_cmd(struct comcerto_fpp *fpp, u16 fcode, 
+		u16 length, u16 *payload, u16 *rlen_user, u16 *rbuf_user)
+{
+	u16 rfcode;
+	u16 rbuf_local[128];
+	u16 rlen_local;
+	u16 *rlen;
+	u16 *rbuf;
+	int rc;
+
+	mutex_lock(&fpp->mutex);
+
+	/* message length must no be greater than 256 bytes*/
+	if (length > FPP_MAX_MSG_LENGTH) {
+		printk(KERN_ERR "%s: msg length(%d) too big\n", __func__, length);
+		rc = -EINVAL;
+		goto out;
+	}
+
+	if (rlen_user && rbuf_user)
+	{
+		rlen = rlen_user;
+		rbuf = rbuf_user;
+	}
+	else
+	{
+		rlen = &rlen_local;
+		rbuf = rbuf_local;
+	}
+
+	*rlen = 0;
+
+	//printk(KERN_INFO "%s: fcode 0x%x length %d\n", __func__, fcode, length);
+
+	/* check if message can be sent */
+	if (__raw_readl(CMD_MBOX_0_ADDR) & M0_CMD)
+	{
+		printk(KERN_ERR "%s: can not send command m0(%x)\n", __func__, __raw_readl(CMD_MBOX_0_ADDR));
+		rc = -EIO;
+		goto out;
+	}
+
+	/* write function code and length to mailbox */
+	__raw_writel((fcode << 16 ) | length, CMD_MBOX_1_ADDR);
+
+	/* write message data to fifo */
+	memcpy(CMD_DATA_ADDR, payload, length);
+		
+	/* new message sent raise busy bit */
+	__raw_writel(M0_CMD, CMD_MBOX_0_ADDR);
+
+	/* new message raise from host irq */
+	comcerto_softirq_set(FPP_IRQ_FROMHOST);
+	
+	//printk(KERN_INFO "%s... done\n", __func__);
+
+	/* read ack from FPP */
+	if ((rc = comcerto_fpp_check_ack(5000)) < 0)
+		goto out;
+
+	/* ack has been posted by FPP read data */
+	if ((rc = comcerto_fpp_read(&rfcode, rlen, rbuf)) < 0)
+		goto out;
+
+	if (rfcode != fcode)
+	{
+		printk(KERN_ERR "%s: response function code(%x) doesn't match command (%x)\n", __func__, rfcode, fcode);
+		rc = -EIO;
+		goto out;
+	}
+
+	rc = rbuf[0];
+
+out:
+	mutex_unlock(&fpp->mutex);
+
+	return rc;
+}
+
+/**
+ * comcerto_fpp_write - 
+ *
+ *
+ */
+static int comcerto_fpp_write(u16 fcode, u16 length, u16 *payload)
+{
+	struct comcerto_fpp *fpp = dev_get_drvdata(&fpp_device);
+
+	return comcerto_fpp_cmd(fpp, fcode, length, payload, NULL, NULL);
+}
+
+static void comcerto_fpp_workqueue(struct work_struct *work)
+{
+	struct comcerto_fpp *fpp = container_of(work, struct comcerto_fpp, work);
+	struct fpp_msg *msg;
+	unsigned long flags;
+
+	spin_lock_irqsave(&fpp->lock, flags);
+	while (!list_empty(&fpp->msg_list)) {
+		msg = list_entry(fpp->msg_list.next, struct fpp_msg, list);
+		list_del(&msg->list);
+
+		spin_unlock_irqrestore(&fpp->lock, flags);
+
+		comcerto_fpp_cmd(fpp, msg->fcode, msg->length, msg->payload, NULL, NULL);
+
+		kfree(msg);
+
+		spin_lock_irqsave(&fpp->lock, flags);
+	}
+
+	spin_unlock_irqrestore(&fpp->lock, flags);
+}
+
+/**
+ ** comcerto_fpp_write_atomic - 
+ **
+ **
+ **/
+static int comcerto_fpp_write_atomic(u16 fcode, u16 length, u16 *payload)
+{
+	struct comcerto_fpp *fpp = dev_get_drvdata(&fpp_device);
+	struct fpp_msg *msg;
+	unsigned long flags;
+	int rc;
+
+	if (length > FPP_MAX_MSG_LENGTH) {
+		rc = -EINVAL;
+		goto err0;
+	}
+
+	msg = kmalloc(sizeof(struct fpp_msg) + length, GFP_ATOMIC);
+	if (!msg) {
+		rc = -ENOMEM;
+		goto err0;
+	}
+
+	msg->payload = (u16 *)(msg + 1);
+
+	msg->fcode = fcode;
+	msg->length = length;
+	memcpy(msg->payload, payload, length);
+
+	spin_lock_irqsave(&fpp->lock, flags);
+
+	list_add(&msg->list, &fpp->msg_list);
+
+	spin_unlock_irqrestore(&fpp->lock, flags);
+
+	schedule_work(&fpp->work);
+
+	return 0;
+
+err0:
+	return rc;
+}
+
+/**
+ * comcerto_fpp_read_event - 
+ *		This function is called from a tasklet 
+ *		and perform handling of the asynchronous event from the FPP.
+ */
+static int comcerto_fpp_read_event(u16 *fcode, u16 *length, u16 *payload)
+{
+	int rc = -EIO;
+
+	//printk(KERN_INFO "%s\n", __func__);
+
+	if ((__raw_readl(EVENT_MBOX_0_ADDR) & M0_EVENT) == 0)
+	{
+		printk(KERN_ERR "%s: no event available m0(%x)\n", __func__, __raw_readl(EVENT_MBOX_0_ADDR));
+		goto out;
+	}
+
+	/* get function code */
+	*fcode = (__raw_readl(EVENT_MBOX_1_ADDR) >> 16);
+
+	/* get message length */
+	*length = (__raw_readl(EVENT_MBOX_1_ADDR) & 0x0000FFFF);
+
+	if (*length > FPP_MAX_MSG_LENGTH)
+	{
+		printk(KERN_ERR "%s: event length(%d) above (%d)\n", __func__, *length, FPP_MAX_MSG_LENGTH);
+		*length = FPP_MAX_MSG_LENGTH;
+	}
+
+	rc = 0;
+
+	/* copy message data */
+	memcpy(payload, EVENT_DATA_ADDR, *length);
+
+	/* new message processed clear busy bit */
+	__raw_writel(0, EVENT_MBOX_0_ADDR);
+
+	/* new read from host irq */
+	comcerto_softirq_set(FPP_IRQ_TOHOST);
+
+	//printk(KERN_INFO "%s done: fcode 0x%x length %d\n", __func__, *fcode, *length);
+out:
+	return rc;
+}
+
+/**
+ * fpp_command_parser -
+ *
+ *          This function is called by upper layer
+ *          to give message to FPP Forward Engine.
+ *
+ */
+int fpp_command_parser(u16 fc, u16 length, u16 *data, u16 *rlen, u16 *rdata)
+{
+	struct comcerto_fpp *fpp = dev_get_drvdata(&fpp_device);
+
+	return comcerto_fpp_cmd(fpp, fc, length, data,rlen,rdata);
+}
+EXPORT_SYMBOL(fpp_command_parser);
+
+/**
+ * fpp_set_resethandler - 
+ *
+ *
+ */
+static int fpp_set_resethandler(unsigned long base_address)
+{
+	int rc = 0;
+	void *vectors_base;
+
+	if (SDRAM_MSP_MEMORY_PHY) // MSP @ address 0x0
+		vectors_base = ioremap(0x00000000, 0x40);
+	else
+		vectors_base = (void*)SDRAM_MSP_MEMORY_VADDR;
+
+	if (!vectors_base) {
+		printk(KERN_ERR "Cannot map fpp vectors, aborting.\n");
+		rc = -ENOMEM;
+		goto out;
+	}
+
+	__raw_writel(0xE59FF018, vectors_base);	/* LDR PC, [PC,#20] */
+	__raw_writel(base_address, vectors_base + 0x00000020);	/* jump to msp start */
+
+out:
+	if (SDRAM_MSP_MEMORY_PHY)
+		iounmap(vectors_base);
+
+	return rc;
+}
+
+
+/**
+ * download_elf_image - 
+ *
+ *
+ */
+static int download_elf_image(struct _code_info *code_info)
+{
+	int i;
+	int rc = 0;
+	char *section_name;
+	Elf32_Ehdr *this_elf_header = (Elf32_Ehdr *)(code_info->code);
+	Elf32_Half number_of_section = this_elf_header->e_shnum;
+	/* pointer to the Section header.  */
+	Elf32_Shdr *this_section_headers = (Elf32_Shdr *) (code_info->code + this_elf_header->e_shoff);
+	Elf32_Off string_section_offset = this_section_headers[this_elf_header->e_shstrndx].sh_offset;
+	u32 checksum_program_addr=0;
+
+	//printk(KERN_INFO "%s\n", __func__);
+
+	if (!number_of_section)
+	{
+		PDEBUG(MSP_ERR, "Invalid of section = %d ", number_of_section);
+		rc = -EINVAL;
+		goto out;
+	}
+	
+	/* parse all sections */
+	for (i = 0; i < number_of_section; i++)
+	{
+		section_name = code_info->code  + string_section_offset + this_section_headers[i].sh_name;
+		if (!strncmp(section_name, "svc_stack", 8))
+		{
+				code_info->stack_addr = this_section_headers[i].sh_addr;
+				code_info->stack_size = this_section_headers[i].sh_size;
+				PDEBUG (MSP_INIT, "stack_addr at 0x%08x", code_info->stack_addr);
+		} 
+		
+		/* retrieve the section name from the ELF buffer */
+		if (!strncmp(section_name, "CHECKSUM", 8))
+		{
+				checksum_program_addr = *((u32 *) (code_info->code + this_section_headers[i].sh_offset));
+				PDEBUG (MSP_INIT, "checksum prog at 0x%08x", checksum_program_addr);
+		} 
+		else if ((this_section_headers[i].sh_flags != SHF_MIPS_ADDR) && 
+		    (this_section_headers[i].sh_flags != 0)) 
+		{
+			/* retrieve the section name from the ELF buffer */
+			
+			if ((this_section_headers[i].sh_type & 3) == SHT_PROGBITS)
+			{
+				PDEBUG (MSP_INIT, "%s section: %d bytes to load at addr:0x%08x from elf offset: %d",
+					section_name,
+					this_section_headers[i].sh_size,
+					this_section_headers[i].sh_addr,
+					this_section_headers[i].sh_offset);
+				if ((this_section_headers[i].sh_addr >= COMCERTO_AHB_ARAM_BASE) && (this_section_headers[i].sh_addr <= (COMCERTO_AHB_ARAM_BASE + ARAM_MEMORY_SIZE)))
+				memcpy(
+					aram_to_virt(this_section_headers[i].sh_addr),
+					(void*)(code_info->code + this_section_headers[i].sh_offset),
+					this_section_headers[i].sh_size);
+					
+				else					
+				memcpy(
+					msp_to_virt(this_section_headers[i].sh_addr),
+					(void*)(code_info->code + this_section_headers[i].sh_offset),
+					this_section_headers[i].sh_size);
+			}
+		}
+	}
+	/* everything went OK */
+	code_info->program_addr = this_elf_header->e_entry;
+
+out:
+	return rc;
+
+}
+
+/**
+ * comcerto_fpp_download - 
+ *
+ *
+ */
+static int comcerto_fpp_download(struct comcerto_fpp *fpp)
+{
+	struct _code_info *code_info = &fpp->code_info;
+	int rc;
+
+	//printk(KERN_INFO "%s\n", __func__);
+
+	rc = download_elf_image(code_info); 
+	if (rc)
+	{
+		printk(KERN_INFO "FPP download done\n");
+		goto err;
+	}
+
+	return 0;
+
+err:
+	return rc;
+}
+
+/**
+ * comcerto_fpp_check_ready - 
+ *
+ *
+ */
+static int comcerto_fpp_check_ready(struct comcerto_fpp *fpp, unsigned long timeout)
+{
+	u8 version[32] = {0, };
+	unsigned long end = jiffies + (timeout * HZ) / 1000;
+	int rc = 0;
+
+	//printk(KERN_INFO "%s\n", __func__);
+
+	while (time_before(jiffies, end))
+	{
+		if (__raw_readl(CMD_MBOX_0_ADDR) == TX_MAGIC)
+			goto ready;
+
+		set_current_state(TASK_UNINTERRUPTIBLE);
+		schedule_timeout(1);
+	}
+
+	if (__raw_readl(CMD_MBOX_0_ADDR) == TX_MAGIC)
+		goto ready;
+
+	printk(KERN_ERR "%s: didn't receive ack from FPP %x\n", __func__, __raw_readl(CMD_MBOX_0_ADDR));
+	rc = -EIO;
+	goto out;
+
+ready:
+	/* get firmware version */
+	memcpy(version, CMD_DATA_ADDR, sizeof(version) - 1);
+
+	__raw_writel(0, CMD_MBOX_0_ADDR);
+
+	printk(KERN_INFO "FPP is running %s\n", version);
+
+out:
+	return rc;
+}
+
+
+/**
+ *  comcerto_fpp_fill_v2_fifo -
+ *
+ *
+ */
+static void fill_v2_fifo(struct sk_buff *this_fifo_skb, u16 index, u16 cmd_class, u16 cmd_type,
+				u16 func_code, u16 number_of_params, ...)
+{
+	va_list param_list;
+	int i;
+
+	put_fifo_header(this_fifo_skb, index, cmd_class, cmd_type, func_code);	
+
+	((u16 *)this_fifo_skb->tail)[0] += number_of_params * 2;
+
+	va_start(param_list, number_of_params);
+
+	for (i = 0; i < number_of_params; i++)
+	{
+		((u16 *)this_fifo_skb->tail)[i + 4] =  va_arg (param_list, int);
+	}
+
+	va_end(param_list);
+
+	put_fifo_padding(this_fifo_skb);
+}
+
+
+static int comcerto_fpp_SPAWN_TASK(u32 entry_point, u32 stack_ptr, unsigned short stacksize)
+{
+	struct sk_buff *this_skb;
+	unsigned short channel_id;
+	int rc;
+
+//	printk(KERN_INFO "%s: %x %x %x\n", __func__, entry_point, stack_ptr, stacksize);
+
+	this_skb = dev_alloc_skb(1024);
+	if (this_skb == NULL)
+	{
+		printk(KERN_ERR "%s: skb alloc failed\n", __func__);
+		rc = -ENOMEM;
+		goto err0;
+	}
+	skb_reserve(this_skb, 32);
+
+	channel_id = COMCERTO_SUPVSR;
+	memcpy(skb_put(this_skb, 2), &channel_id, 2);
+
+	fill_v2_fifo(this_skb, 0, CMD_CLASS_CONFIGURATION_DEVICE, CMD_TYPE_CONFIGURATION_CHANGE, DEVICE_SPAWN_BGTASK, 5,
+			entry_point & 0xffff, entry_point >> 16,
+			stack_ptr & 0xffff, stack_ptr >> 16,
+			stacksize);
+
+	rc = dci_kioctl(DCI_KIOC_DEV_WRITE_MSG, 1, this_skb);         
+	if (rc)
+	{
+		printk(KERN_ERR "%s: dci_kioctl() failed\n", __func__);
+		
+		goto err1;
+	}
+
+	return 0;
+
+err1:
+	dev_kfree_skb(this_skb);
+
+err0:
+	return rc;
+}
+
+static int comcerto_fpp_KILL_TASK(u32 entry_point, u32 stack_ptr, unsigned short stacksize)
+{
+	struct sk_buff *this_skb;
+	unsigned short channel_id;
+	int rc;
+
+	printk(KERN_INFO "%s: %x %x %x\n", __func__, entry_point, stack_ptr, stacksize);
+
+	this_skb = dev_alloc_skb(1024);
+	if (this_skb == NULL)
+	{
+		printk(KERN_ERR "%s: skb alloc failed\n", __func__);
+		rc = -ENOMEM;
+		goto err0;
+	}
+	skb_reserve(this_skb, 32);
+
+	channel_id = COMCERTO_SUPVSR;
+	memcpy(skb_put(this_skb, 2), &channel_id, 2);
+
+	fill_v2_fifo(this_skb, 0, CMD_CLASS_CONFIGURATION_DEVICE, CMD_TYPE_CONFIGURATION_CHANGE, DEVICE_KILL_BGTASK, 0);
+
+	rc = dci_kioctl(DCI_KIOC_DEV_WRITE_MSG, 1, this_skb);
+	if (rc)
+	{
+		printk(KERN_ERR "%s: dci_kioctl() failed\n", __func__);
+		
+		goto err1;
+	}
+
+	return 0;
+
+err1:
+	dev_kfree_skb(this_skb);
+
+err0:
+	return rc;
+}
+
+/**
+ * comcerto_fpp_start - 
+ *
+ *
+ */
+static int comcerto_fpp_start(struct comcerto_fpp *fpp)
+{
+	int arm1_running;
+	int rc;
+
+	//printk(KERN_INFO "%s\n", __func__);
+
+	// is ARM1 already running MSP code ?
+#if defined (CONFIG_ARCH_M83XXX)
+	arm1_running = (__raw_readl(COMCERTO_BLOCK_RESET_REG) & ARM1_AHB_RST);
+#else
+	arm1_running = (__raw_readl(COMCERTO_INTC_ARM1_CONTROL_REG) &  0x80000000);
+#endif
+
+	/* clear FPP ready status register */
+	__raw_writel(0, CMD_MBOX_0_ADDR);
+	__raw_writel(0, EVENT_MBOX_0_ADDR);
+
+	if (arm1_running) {
+		rc = comcerto_fpp_SPAWN_TASK(fpp->code_info.program_addr, fpp->code_info.stack_addr, fpp->code_info.stack_size);
+		if (rc)
+			goto err;
+		fpp->voice_is_running = 1;
+	}
+	else
+	{
+		rc = fpp_set_resethandler(fpp->code_info.program_addr);
+		if (rc) {
+			printk(KERN_ERR "%s: failed to set FPP reset vectors\n", __func__);
+			goto err;
+		}
+		
+#if defined (CONFIG_ARCH_M83XXX)
+	 	__raw_writel(__raw_readl(COMCERTO_BLOCK_RESET_REG) | ARM1_AHB_RST, COMCERTO_BLOCK_RESET_REG);
+#else
+		__raw_writel(0x80000000, COMCERTO_INTC_ARM1_CONTROL_REG);
+#endif	
+	}
+	
+	rc = comcerto_fpp_check_ready(fpp, 8000); 
+	if (rc) {
+		printk(KERN_ERR "%s: failed to start FPP\n", __func__);
+		goto err;
+	}
+
+	return 0;
+err:
+	return rc;
+
+}
+
+/**
+ * comcerto_fpp_interrupt - 
+ *
+ *
+ */
+irqreturn_t comcerto_fpp_interrupt(int irq, void *dev_id)
+{
+	struct device *dev = (struct device *)dev_id;
+	struct comcerto_fpp *fpp = dev_get_drvdata(dev);
+
+	//disable_irq(fpp->irq);
+	tasklet_schedule(&fpp->event_tasklet);
+
+	return IRQ_HANDLED;
+}
+
+/**
+ * comcerto_fpp_tasklet - 
+ *
+ *
+ */
+static void comcerto_fpp_tasklet(unsigned long arg)
+{
+	struct comcerto_fpp *fpp = (struct comcerto_fpp *)arg;
+	struct fpp_event event;
+
+	event.length = sizeof(event.payload);
+	if (comcerto_fpp_read_event(&event.fcode, &event.length, &event.payload[0]) == 0)
+	{
+		/* call FCI callback */
+		if (fpp->event_cb != NULL)
+		{	
+			fpp->event_cb(event.fcode, event.length, &event.payload[0]);
+		}
+
+	}
+
+	//enable_irq(fpp->irq);
+}
+
+/**
+ * comcerto_fpp_init - 
+ *
+ *
+ */
+static int comcerto_fpp_init(struct device *dev)
+{
+	struct comcerto_fpp *fpp;
+	const struct firmware *fw_entry;
+	int rc = 0;
+
+	//printk(KERN_INFO "comcerto_fpp_init\n");
+
+	fpp = (struct comcerto_fpp *)kzalloc(sizeof(struct comcerto_fpp), GFP_KERNEL);
+	if (fpp == NULL) {
+		rc = -ENOMEM;
+		goto err0;
+	}	
+
+	mutex_init(&fpp->mutex);
+
+	INIT_WORK(&fpp->work, comcerto_fpp_workqueue);
+
+	INIT_LIST_HEAD(&fpp->msg_list);
+	spin_lock_init(&fpp->lock);
+
+	dev_set_drvdata(dev, fpp);
+
+	if (request_firmware(&fw_entry,"fpp.axf", dev) !=0 ) {
+		printk(KERN_ERR "Error finding FPP firmware\n");
+		rc = -ETIMEDOUT;
+		goto err1;
+	}
+	
+	fpp->code_info.code = fw_entry->data;
+	fpp->code_info.size = fw_entry->size;
+
+	rc = comcerto_fpp_download(fpp); 
+	if (rc)
+		goto err2;
+
+	rc = comcerto_fpp_start(fpp); 
+	if (rc)
+		goto err2;
+
+#if defined(CONFIG_ARCH_M821XX) || defined(CONFIG_ARCH_M822XX)
+	rc = comcerto_fpp_pool_init();
+	if (rc)
+		goto err2;
+#endif
+
+	fpp->irq = FPP_IRQ_EVENT;
+
+	tasklet_init(&fpp->event_tasklet, comcerto_fpp_tasklet, (unsigned long)fpp);
+	
+	rc = request_irq(fpp->irq, comcerto_fpp_interrupt, IRQF_SHARED, comcerto_fpp_driver_name, dev);
+	if (rc) {
+		printk(KERN_INFO "comcerto_fpp: failed to get the irq: %d\n", fpp->irq);
+		goto err2;
+	}
+
+	release_firmware(fw_entry);
+	return 0;
+
+err2:
+	release_firmware(fw_entry);
+
+err1:
+	kfree(fpp);
+
+err0:
+	return rc;
+}
+
+/**
+ * comcerto_fpp_reset - 
+ *
+ *
+ */
+static int comcerto_fpp_reset(struct device *dev)
+{
+	struct comcerto_fpp *fpp = dev_get_drvdata(dev);
+
+	struct fpp_msg *msg;
+	unsigned long flags;
+	
+	//printk(KERN_INFO "comcerto_fpp_reset\n");
+
+	if (fpp->voice_is_running) {
+		comcerto_fpp_KILL_TASK(fpp->code_info.program_addr, fpp->code_info.stack_addr, fpp->code_info.stack_size);
+	} else {
+#if defined (CONFIG_ARCH_M83XXX)
+		__raw_writel(__raw_readl(COMCERTO_BLOCK_RESET_REG) & ~ARM1_AHB_RST, COMCERTO_BLOCK_RESET_REG);
+#else
+
+		__raw_writel(0x00000000, COMCERTO_INTC_ARM1_CONTROL_REG);
+#endif
+	}
+
+#if defined(CONFIG_ARCH_M821XX) || defined(CONFIG_ARCH_M822XX)
+	comcerto_fpp_pool_reset();
+#endif
+	free_irq(fpp->irq, dev);
+
+	flush_scheduled_work();
+
+	spin_lock_irqsave(&fpp->lock, flags);
+	while (!list_empty(&fpp->msg_list)) {
+		msg = list_entry(fpp->msg_list.next, struct fpp_msg, list);
+		list_del(&msg->list);
+		spin_unlock_irqrestore(&fpp->lock, flags);
+
+		kfree(msg);
+
+		spin_lock_irqsave(&fpp->lock, flags);
+	}
+	spin_unlock_irqrestore(&fpp->lock, flags);
+
+	kfree(fpp);
+
+	return 0;
+}
+
+/**
+ * comcerto_fpp_module_init - 
+ *
+ *
+ */
+static int __init comcerto_fpp_module_init(void)
+{
+	int rc;
+
+	printk(KERN_INFO "%s\n", __func__);
+
+	rc = device_register(&fpp_device);
+	if (rc)
+		goto err0;
+
+
+
+	rc = comcerto_fpp_init(&fpp_device); 
+	if (rc)
+		goto err1;
+
+	rc = comcerto_fpp_register_to_eth(); 
+	if (rc)
+		goto err2;
+
+	return 0;
+err2:
+	comcerto_fpp_reset(&fpp_device);
+err1:
+	put_device(&fpp_device);
+err0:
+	return rc;
+}
+
+
+/**
+ * comcerto_fpp_exit - 
+ *
+ *
+ */
+static void __exit comcerto_fpp_module_exit(void)
+{
+	comcerto_eth_unregister_fpp_ops();
+
+	comcerto_fpp_reset(&fpp_device);
+	
+	device_unregister(&fpp_device);
+
+	printk(KERN_INFO "%s\n", __func__);
+}
+
+module_init(comcerto_fpp_module_init);
+module_exit(comcerto_fpp_module_exit);
+
+MODULE_LICENSE("GPL");
diff --git a/drivers/net/comcerto/comcerto_fpp.h b/drivers/net/comcerto/comcerto_fpp.h
new file mode 100644
index 0000000..ef4cd87
--- /dev/null
+++ b/drivers/net/comcerto/comcerto_fpp.h
@@ -0,0 +1,198 @@
+/*
+ *  linux/drivers/net/comcerto/comcerto_msp.h
+ *
+ *  Copyright (C) 2006 Mindspeed Technologies, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __COMCERTO_FPP_H__
+#define __COMCERTO_FPP_H__
+
+#include <linux/firmware.h>
+#include <linux/elf.h>
+#include <mach/debug.h>
+#include <linux/netdevice.h>
+
+
+/* copied from usr/include/elf.h */
+#ifndef _ELF_H
+#define	_ELF_H 1
+#define EM_ARM		40		/* ARM */
+
+#define SHF_MIPS_ADDR 0x40000000
+#define SHT_PROGBITS 1
+#endif
+
+#define FPP_PKT_POOL_SIZE	768
+
+/* FPP mailboxes and fifos registers */
+
+#define CMD_MBOX_0_ADDR		aram_to_virt(0x0A000000)
+#define CMD_MBOX_1_ADDR		aram_to_virt(0x0A000004)
+#define EVENT_MBOX_0_ADDR	aram_to_virt(0x0A000010) 
+#define EVENT_MBOX_1_ADDR	aram_to_virt(0x0A000014)
+
+#define CMD_DATA_ADDR		aram_to_virt(0x0A000020)
+#define EVENT_DATA_ADDR		aram_to_virt(0x0A000220)
+
+#define M0_CMD	0x00000001	
+#define M0_ACK	0x00000002
+#define M0_EVENT	0x00000004
+
+#define TX_MAGIC	0x4D535044	/* set by FPP when ready */
+
+
+#define FPP_MAX_MSG_LENGTH	256 /* expressed in U8 -> 256 bytes*/
+
+struct fpp_ops {
+	int (*write)(unsigned short fcode, unsigned short len, unsigned short *payload);
+	int (*write_atomic)(unsigned short fcode, unsigned short len, unsigned short *payload);
+
+	void (*add_buffer)(void *buffer);
+	void (*del_buffer)(void *buffer);
+	void *owner;
+};
+
+typedef void (*FPP_EVENT_CB)(u16, u16, u16*);
+
+struct _code_info {
+	u8 *code;
+	u32 size;
+	u32 checksum_program_addr;
+	u32 program_addr;
+	u32 stack_addr;
+	u32 stack_size;
+	u32 checksum;
+};
+
+struct fpp_event {
+	
+	u16 fcode;
+	u16 length;
+	u16 payload[128];
+};
+
+struct fpp_msg {
+	struct list_head list;
+	u16 fcode;
+	u16 length;
+	u16 *payload;
+};
+
+struct comcerto_fpp
+{
+	struct _code_info code_info;
+	struct tasklet_struct event_tasklet;
+	FPP_EVENT_CB event_cb;
+	int irq;
+	struct list_head msg_list;
+	spinlock_t lock;
+	struct mutex mutex;
+	struct work_struct work;
+	int voice_is_running;
+};
+
+/* FPP API definitions */
+//0x0000 -> 0x00FF : RX module
+#define CMD_RX_ENABLE		0x0001
+#define CMD_RX_DISABLE		0x0002
+#define CMD_RX_FILL_BUFFERPOOL	0x0006
+
+//0x0100 -> 0x01FF : Ethernet module
+
+//0x0200 -> 0x02FF : IPv4 module
+
+//0x0300 -> 0x03FF : QM module
+
+//0x0400 -> 0x04FF : Scheduler module
+
+//0x0500 -> 0x05FF : TX module
+#define CMD_TX_ENABLE	0x0501
+#define CMD_TX_DISABLE	0x0502
+#define CMD_LINK_UP	0x0504
+
+
+
+#define COMCERTO_SUPVSR			0xffff
+#define CMD_CLASS_STATISTICS_CHANNEL		0x01
+#define CMD_CLASS_CONFIGURATION_CHANNEL		0x02
+#define CMD_CLASS_LEGACY_MSG				0x03
+#define CMD_CLASS_ETH_BOOT_LDR				0x04
+#define CMD_CLASS_STATISTICS_DEVICE			0x05
+#define CMD_CLASS_CONFIGURATION_DEVICE		0x06
+
+#define CMD_CLASS_REFERENCE_DIAGNOSTIC		0xc1
+#define CMD_CLASS_OPEN_DIAGNOSTIC			0xc2
+
+/* Command types for Command class 0x02/0x06 */
+#define CMD_TYPE_CONFIGURATION_CHANGE		0x00
+#define CMD_TYPE_CONFIGURATION_QUERY		0x01
+#define CMD_TYPE_ACKNOWLEDGEMENT			0x02
+#define CMD_TYPE_INDICATION					0x03
+#define CMD_TYPE_QUERY_RESPONSE				0x04
+#define CMD_TYPE_INDICATION_RESPONSE		0x05
+
+#define DEVICE_SPAWN_BGTASK		0x04F0	
+#define DEVICE_KILL_BGTASK			0x04F1	
+
+#define DCI_KIOC_SET_CFG		0
+#define DCI_KIOC_DEV_GET_INFO		1
+#define DCI_KIOC_DEV_INIT		2
+#define DCI_KIOC_DEV_RESET		3
+#define DCI_KIOC_DEV_WRITE_MSG		4
+#define DCI_KIOC_DEV_READ_MSG		5
+#define DCI_KIOC_DEV_GET_STATE		6
+
+
+
+/*
+ * put_fifo_header -
+ *
+ * Puts msg header at end of skb. skb->tail is not updated.
+ *
+ */
+static inline void put_fifo_header(struct sk_buff *this_fifo_skb, u16 index, u16 cmd_class, u16 cmd_type, u16 func_code)
+{
+	((u16 *)this_fifo_skb->tail)[0] = ((index & 0xff)  << 8) | 8;
+	((u16 *)this_fifo_skb->tail)[1] = ((cmd_class & 0xff) << 8) | (cmd_type & 0xff);
+	((u16 *)this_fifo_skb->tail)[2] = func_code;
+	((u16 *)this_fifo_skb->tail)[3] = 0x0000;
+}
+
+/**
+ * put_fifo_padding -
+ *
+ * Puts msg padding at end of skb. skb->tail is moved down to match the payload & padding added to the message.
+ * skb->tail should point to beginning of msg header.
+ *
+ */
+static inline void put_fifo_padding(struct sk_buff *this_fifo_skb)
+{
+	int padding;
+	u16 msg_length = ((u16 *)this_fifo_skb->tail)[0] & 0xff;
+
+	skb_put(this_fifo_skb, msg_length);
+
+	if (msg_length & 0x3)
+	{
+		padding = 4 - (msg_length & 0x3);
+
+		memset(this_fifo_skb->tail, 0, padding);
+		skb_put(this_fifo_skb, padding);
+	}
+}
+
+#endif
diff --git a/drivers/net/comcerto/fpp_csme.c b/drivers/net/comcerto/fpp_csme.c
new file mode 100644
index 0000000..7c88695
--- /dev/null
+++ b/drivers/net/comcerto/fpp_csme.c
@@ -0,0 +1,236 @@
+/*
+ *  Copyright (C) 2008 Mindspeed Technologies, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/kernel.h>
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+
+#include <linux/net.h>
+#include <net/sock.h>
+#include <linux/if.h>
+#include <linux/tcp.h>
+#include <linux/in.h>
+#include <asm/uaccess.h>
+#include <linux/file.h>
+#include <linux/socket.h>
+#include <linux/smp_lock.h>
+#include <linux/slab.h>
+#include <linux/sockios.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,33)
+#include <net/net_namespace.h>
+#endif
+#include "if_csmencaps.h"
+
+#define SOL_CSM_ENCAPS		269
+#define CSME_ACK_ENABLE		1
+#define MAX_MSP_MSG_LEN		1500
+
+/* we consider that msp on this interface */
+#define INTERFACE		"eth1"
+
+#define DCI_KIOC_DEV_WRITE_MSG	4
+
+/* global csme socket structure */
+struct sockaddr_csme sockaddrcsme;
+struct socket *sock;
+struct csme_ackopt ack_opt;
+
+/* Target mac address */
+unsigned char dev_mac[6]={0x00,0x11,0x22,0x33,0x44,0x55};
+unsigned char rcv_buff[MAX_MSP_MSG_LEN];
+
+int fppcsm_send(struct socket *sock, struct sockaddr_csme *addr, unsigned char *buf, int len)
+{
+	struct msghdr msg;
+	struct iovec iov;
+	mm_segment_t oldfs;
+	int size = 0;
+
+	if (sock->sk == NULL)
+		return 0;
+
+	iov.iov_base = buf;
+	iov.iov_len = len;
+
+	msg.msg_flags = 0;
+	msg.msg_name = addr;
+	msg.msg_namelen = sizeof(struct sockaddr_csme);
+	msg.msg_control = NULL;
+	msg.msg_controllen = 0;
+	msg.msg_iov = &iov;
+	msg.msg_iovlen = 1;
+	msg.msg_control = NULL;
+
+	/* this hack should be done to be abble to use sockets in kernel space */
+	oldfs = get_fs();
+	set_fs(KERNEL_DS);
+	size = sock_sendmsg(sock, &msg, len);
+	set_fs(oldfs);
+
+	if (size < 0)
+		printk(KERN_ERR "fpp_csm: fppcsm_sendmsg error: %d\n", size);
+
+	return size;
+}
+
+int fppcsm_recv(struct socket* sock, struct sockaddr_csme * addr, unsigned char* buf, int len)
+{
+	struct msghdr msg;
+	struct iovec iov;
+	mm_segment_t oldfs;
+	int size = 0;
+
+	if (sock->sk == NULL) 
+		return 0;
+
+	iov.iov_base = buf;
+	iov.iov_len = len;
+
+	msg.msg_flags = 0;
+	msg.msg_name = addr;
+	msg.msg_namelen  = sizeof(struct sockaddr_csme);
+	msg.msg_control = NULL;
+	msg.msg_controllen = 0;
+	msg.msg_iov = &iov;
+	msg.msg_iovlen = 1;
+	msg.msg_control = NULL;
+
+	oldfs = get_fs();
+	set_fs(KERNEL_DS);
+	size = sock_recvmsg(sock, &msg, len, msg.msg_flags);
+	set_fs(oldfs);
+
+	if (size < 0)
+		printk(KERN_ERR "fpp_csm: fppcsm_recv error: %d\n", size);
+	
+	return size;
+}
+
+int dci_kioctl(unsigned int cmd, unsigned int flag, struct sk_buff *this_skb)
+{
+	mm_segment_t oldfs;
+	struct sockaddr_csme stSockAddr;
+	int size = 0;
+	int retval = -1; 
+
+	if (cmd == DCI_KIOC_DEV_WRITE_MSG)
+	{
+		retval = sock_create(AF_CSME, SOCK_DGRAM, 0, &sock);
+		if (retval < 0)
+		{
+			printk(KERN_ERR "fpp_csm: error %d creating socket.\n", retval);
+			goto err;
+		}
+
+		memcpy(&stSockAddr, &sockaddrcsme, sizeof(struct sockaddr_csme));
+		/* we are not in boot phase*/
+		stSockAddr.scsme_flags = 0x1;
+
+		oldfs = get_fs();
+		set_fs(KERNEL_DS);
+		retval = sock_setsockopt(sock, SOL_CSM_ENCAPS, CSME_ACK_ENABLE, (char *)&ack_opt, sizeof(struct csme_ackopt));
+		set_fs(oldfs);
+
+		if (retval < 0)
+		{
+			printk(KERN_ERR "fpp_csm: setsockopt failed %d;\n", retval);
+			goto err;
+		}
+
+		stSockAddr.scsme_channelid = *(unsigned short *)this_skb->data;
+		this_skb->data = skb_pull(this_skb, 2);
+
+		size = fppcsm_send(sock, &stSockAddr, (unsigned char *)this_skb->data, this_skb->len);
+
+		if (size < 0)
+		{
+			printk(KERN_ERR "fpp_csm: dci_kioctl error %d faild to send.\n", size);
+			goto err_sock_release;
+		}
+		else	
+			/* it is expected from dci to free sk_buff */
+			dev_kfree_skb(this_skb);
+
+		size = fppcsm_recv(sock, &stSockAddr, (unsigned char *)rcv_buff, MAX_MSP_MSG_LEN);
+
+		if (size < 0) 
+		{
+			printk(KERN_ERR "fpp_csm: dci_kioctl error %d faild to recive.\n", size);
+			goto err_sock_release;
+		}
+
+		/* we should have time between  opened and closed socket as shot as possible */
+		sock_release(sock);
+	}
+	else 
+		goto err;
+
+	/* dci_kioctl returns 0 if success */
+	return 0;
+
+err_sock_release:
+	sock_release(sock); /* we should have time between  opened and closed socket as shot as possible */
+err:
+	return -EINVAL;
+}
+EXPORT_SYMBOL(dci_kioctl);
+
+static int __init gateway_init_module (void)
+{
+	struct net_device *dev;
+
+	/* do nothing just prepare information for using csmencaps protocol */
+	/* We do not create socket here due to have a shortest time between opened/closed socket */
+	sockaddrcsme.scsme_family = AF_CSME;
+
+	/* this is used to get index of interface (just instead of if_nametoindex("eth1"); */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,33)
+	dev = dev_get_by_name(INTERFACE);
+#else
+	dev = dev_get_by_name(&init_net, INTERFACE);
+#endif
+      
+	if (!dev)
+	{
+		printk(KERN_ERR "fpp_csm: dev_get_by_name(%s) failed\n", INTERFACE);
+		return -1;
+	}
+
+	sockaddrcsme.scsme_ifindex = dev->ifindex;
+	dev_put(dev);
+	memcpy(&sockaddrcsme.scsme_devmac, dev_mac, 6);
+	sockaddrcsme.scsme_opcode = __constant_htons(CSME_OPCODE_CONTROL); /* the CSME_OPCODE_CONTROL must be in BE */
+	memcpy(&ack_opt.scsme_devmac, &sockaddrcsme.scsme_devmac, 6);
+	ack_opt.scsme_ifindex = sockaddrcsme.scsme_ifindex;
+	ack_opt.ack_suppression = 0;
+
+	return 0;
+}
+
+static void __exit gateway_cleanup_module (void)
+{
+	/* do nothing (opening/closing socket in implemented in dci_kioctl() */
+}
+
+
+module_init (gateway_init_module);
+module_exit (gateway_cleanup_module);
+
+MODULE_LICENSE("GPL");
diff --git a/drivers/net/comcerto/if_csmencaps.h b/drivers/net/comcerto/if_csmencaps.h
new file mode 100644
index 0000000..0d72957
--- /dev/null
+++ b/drivers/net/comcerto/if_csmencaps.h
@@ -0,0 +1,84 @@
+/* Copyright © 2004-2010 Mindspeed Technologies, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __LINUX_IF_CSM_ENCAPS_H
+#define __LINUX_IF_CSM_ENCAPS_H
+
+#include <linux/if_ether.h>     /* for ETH_DATA_LEN */
+
+#define CSME_VERSION_MAJOR	0
+#define CSME_VERSION_MINOR	12
+#define CSME_VERSION_MICRO	1
+
+#define CSME_VERSION	(a,b,c) (((a) << 16) + ((b) << 8) + (c))
+#define CSME_RELEASE 	CSME_VERSION(CSME_VERSION_MAJOR, CSME_VERSION_MINOR, CSME_VERSION_MICRO)
+
+#define SOL_CSME  	269
+
+/* Packet types */
+#define ETH_P_CSME	0x889B
+#define AF_CSME		27
+#define PF_CSME		AF_CSME
+
+
+
+struct csme_cmd {
+	int noofcommands;
+};
+
+/* the definitions below must match the one defined in teth.h of the GTL user */
+
+/* values for get/set options */
+#define CSME_ACK_ENABLE		1
+#define CSME_TARGET_RESET	2
+#define CSME_USER_SET		3
+
+struct sockaddr_csme {
+	sa_family_t	scsme_family;		/* AF_XXX family */
+	int		scsme_ifindex;		/* interface index */
+	unsigned char	scsme_devmac[6];	/* device MAC address */
+	unsigned short	scsme_opcode;		/* opcode */
+	unsigned short	scsme_channelid;	/* channel ID  */
+	unsigned short	scsme_flags;		/* 1 == boot message */
+	long long	scsme_user;		/* 64 bit field, specific to caller code, driver doesn't touch it */
+};
+
+#define	CSME_OPCODE_NOOP		0x0000
+#define	CSME_OPCODE_CONTROL		0x0001
+#define	CSME_OPCODE_RESERVED		0x0002
+#define CSME_OPCODE_UNIFIED_DIAGNOSTICS	0x0003
+#define CSME_OPCODE_REMOTE_MEDIA	0x0004
+#define CSME_OPCODES_NUMBER		5
+
+
+struct csme_ackopt {
+	unsigned char	scsme_devmac[6];	/* Target Device MAC */
+	int		scsme_ifindex;		/* interface index */
+	unsigned char	ack_suppression;	/* 0 = ACK Packet is required(default) */
+						/* 1 = ACK packet must be suppressed */
+};
+
+struct csme_resetopt {
+	unsigned char	scsme_devmac[6];	/* Target Device MAC */
+	unsigned char	scsme_newmac[6];	/* Target Device new MAC */
+};
+
+struct csme_usersetopt {
+	unsigned char	scsme_devmac[6];	/* Target Device MAC */
+	long long	csme_user;
+};
+#endif	/* __LINUX_IF_CSM_ENCAPS_H */
-- 
1.7.0

