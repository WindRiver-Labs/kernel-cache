From 2b60f6204611e1a8af663f1c244ac3472387a040 Mon Sep 17 00:00:00 2001
From: Wang Hui <Hui.Wang@windriver.com>
Date: Wed, 27 May 2009 09:58:47 +0800
Subject: [PATCH] imx27_mach/pm: add static pm support in imx27ads bsp

Add static pm interface in imx27ads to support pm_suspend
operations.
Add pm suspend test interface via proc/sysfs interface.
Add set_wake implementation in irq_chip to support register wakeup
source from device driver.

Original patch taken from rev C1 board support ISO image for imx27ads.
imx27_ads_20071219-rel3-ltib.iso in product CD.

Signed-off-by: Wang Hui <Hui.Wang@windriver.com>
---
 arch/arm/mach-mx2/Makefile |    1 +
 arch/arm/mach-mx2/mxc_pm.c |  115 +++++++++++++++++++++++++++++++++++
 arch/arm/mach-mx2/pm.c     |  143 ++++++++++++++++++++++++++++++++++++++++++++
 arch/arm/plat-mxc/irq.c    |   46 ++++++++++++++
 4 files changed, 305 insertions(+), 0 deletions(-)
 create mode 100644 arch/arm/mach-mx2/mxc_pm.c
 create mode 100644 arch/arm/mach-mx2/pm.c

diff --git a/arch/arm/mach-mx2/Makefile b/arch/arm/mach-mx2/Makefile
index a4c9e7e..9371d75 100644
--- a/arch/arm/mach-mx2/Makefile
+++ b/arch/arm/mach-mx2/Makefile
@@ -12,3 +12,4 @@ obj-$(CONFIG_MACH_MX27) += clock_imx27.o
 obj-$(CONFIG_MACH_MX27ADS) += mx27ads.o
 obj-$(CONFIG_MACH_PCM038) += pcm038.o
 obj-$(CONFIG_MACH_PCM970_BASEBOARD) += pcm970-baseboard.o
+obj-$(CONFIG_PM) += pm.o mxc_pm.o
diff --git a/arch/arm/mach-mx2/mxc_pm.c b/arch/arm/mach-mx2/mxc_pm.c
new file mode 100644
index 0000000..6a66cfb
--- /dev/null
+++ b/arch/arm/mach-mx2/mxc_pm.c
@@ -0,0 +1,115 @@
+/*
+ * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <asm-arm/plat-mxc/mxc_pm.h>
+#include <asm/proc-fns.h>
+#include <mach/system.h>
+#include <mach/common.h>
+#include <asm/irq.h>
+#include <asm/cacheflush.h>
+#include <asm/io.h>
+
+#include "crm_regs.h"
+
+extern void mxc_pic_enter_suspend(void);
+extern void mxc_pic_exit_suspend(void);
+
+/*!
+ * Implement steps required to transition to low-power modes.
+ *
+ * @param       mode    The desired low-power mode. Possible values are,
+ *                      DOZE_MODE
+ *                      WAIT_MODE
+ *                      STOP_MODE
+ *                      DSM_MODE
+ */
+void mxc_pm_lowpower(s32 mode)
+{
+	u32 interrupt_disabled = 0, cscr = 0;
+
+	local_irq_disable();
+	flush_cache_all();
+
+	/* WAIT and DOZE execute WFI only */
+	switch (mode) {
+	case STOP_MODE:
+	case DSM_MODE:
+		mxc_pic_enter_suspend();
+
+		interrupt_disabled = 1;
+		/* Clear MPEN and SPEN to disable MPLL/SPLL */
+		cscr = __raw_readl(CCM_CSCR);
+		__raw_writel(cscr & 0xFFFFFFFC, CCM_CSCR);
+		break;
+	}
+
+	/* Executes WFI */
+	arch_idle();
+
+	if (interrupt_disabled) {
+		mxc_pic_exit_suspend();
+
+		__raw_writel(cscr, CCM_CSCR);
+	}
+
+	local_irq_enable();
+}
+
+/*
+ * This API is not supported on i.MX27
+ */
+int mxc_pm_intscale(long armfreq, long ahbfreq, long ipfreq)
+{
+	return -MXC_PM_API_NOT_SUPPORTED;
+}
+
+/*
+ * This API is not supported on i.MX27
+ */
+int mxc_pm_pllscale(long armfreq, long ahbfreq, long ipfreq)
+{
+	return -MXC_PM_API_NOT_SUPPORTED;
+}
+
+/*!
+ * This function is used to load the module.
+ *
+ * @return   Returns an Integer on success
+ */
+static int __init mxc_pm_init_module(void)
+{
+	printk(KERN_INFO "MX27: Power management module initialized\n");
+	return 0;
+}
+
+/*!
+ * This function is used to unload the module
+ */
+static void __exit mxc_pm_cleanup_module(void)
+{
+	printk(KERN_INFO "MX27: Power management module exit\n");
+}
+
+module_init(mxc_pm_init_module);
+module_exit(mxc_pm_cleanup_module);
+
+EXPORT_SYMBOL(mxc_pm_lowpower);
+EXPORT_SYMBOL(mxc_pm_pllscale);
+EXPORT_SYMBOL(mxc_pm_intscale);
+
+MODULE_AUTHOR("Freescale Semiconductor");
+MODULE_DESCRIPTION("i.MX27 low level PM driver");
+MODULE_LICENSE("GPL");
diff --git a/arch/arm/mach-mx2/pm.c b/arch/arm/mach-mx2/pm.c
new file mode 100644
index 0000000..0c14b49
--- /dev/null
+++ b/arch/arm/mach-mx2/pm.c
@@ -0,0 +1,143 @@
+/*
+ * linux/arch/arm/mach-mx2/pm.c
+ *
+ * MX27 Power Management Routines
+ *
+ * Original code for the SA11x0:
+ * Copyright (c) 2001 Cliff Brake <cbrake@accelent.com>
+ *
+ * Modified for the PXA250 by Nicolas Pitre:
+ * Copyright (c) 2002 Monta Vista Software, Inc.
+ *
+ * Modified for the OMAP1510 by David Singleton:
+ * Copyright (c) 2002 Monta Vista Software, Inc.
+ *
+ * Cleanup 2004 for OMAP1510/1610 by Dirk Behme <dirk.behme@de.bosch.com>
+ *
+ * Modified for the MX27
+ * Copyright 2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
+ * NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/pm.h>
+#include <linux/sched.h>
+#include <linux/proc_fs.h>
+#include <linux/suspend.h>
+#include <linux/sysctl.h>
+
+#include <asm/io.h>
+#include <asm-arm/plat-mxc/mxc_pm.h>
+
+/*
+ * TODO: whatta save?
+ */
+
+static int mx27_pm_enter(suspend_state_t state)
+{
+	pr_debug("Hi, from mx27_pm_enter\n");
+	switch (state) {
+	case PM_SUSPEND_MEM:
+		mxc_pm_lowpower(STOP_MODE);
+		break;
+
+	case PM_SUSPEND_STANDBY:
+		mxc_pm_lowpower(WAIT_MODE);
+		break;
+
+	case PM_SUSPEND_STOP:
+		mxc_pm_lowpower(DSM_MODE);
+		break;
+
+	default:
+		return -1;
+	}
+	return 0;
+}
+
+/*
+ * Called after processes are frozen, but before we shut down devices.
+ */
+static int mx27_pm_prepare(void)
+{
+	return 0;
+}
+
+/*
+ * Called after devices are re-setup, but before processes are thawed.
+ */
+static int mx27_pm_finish(void)
+{
+	return 0;
+}
+
+static int pm_do_sleep(ctl_table *ctl, int write, struct file *file,
+		       void __user *buffer, size_t *len, loff_t *ppos)
+{
+	int retval = 0;
+
+	if (!write)
+		*len = 0;
+	else
+		retval = pm_suspend(PM_SUSPEND_MEM);
+
+	return retval;
+}
+
+struct platform_suspend_ops mx27_pm_ops = {
+	.prepare = mx27_pm_prepare,
+	.enter = mx27_pm_enter,
+	.finish = mx27_pm_finish,
+	.valid = suspend_valid_only_mem,
+};
+
+static struct ctl_table pm_table[] = {
+	{
+		.ctl_name	= CTL_UNNUMBERED,
+		.procname	= "sleep",
+		.data		= NULL,
+		.maxlen		= 0,
+		.mode		= 0600,
+		.proc_handler	= &pm_do_sleep
+	},
+	{}
+};
+
+static struct ctl_table pm_dir_table[] = {
+	{
+		.ctl_name	= CTL_UNNUMBERED,
+		.procname	= "pm",
+		.mode		= 0555,
+		.child		= pm_table
+	},
+	{}
+};
+
+static int __init mx27_pm_init(void)
+{
+	pr_debug("Power Management for Freescale MX27\n");
+	suspend_set_ops(&mx27_pm_ops);
+	register_sysctl_table(pm_dir_table);
+
+	return 0;
+}
+
+late_initcall(mx27_pm_init);
diff --git a/arch/arm/plat-mxc/irq.c b/arch/arm/plat-mxc/irq.c
index a872c69..6ddb9d5 100644
--- a/arch/arm/plat-mxc/irq.c
+++ b/arch/arm/plat-mxc/irq.c
@@ -54,6 +54,11 @@
 #define IIM_PROD_REV_SH		3
 #define IIM_PROD_REV_LEN	5
 
+#define IRQ_BIT(irq)  (1 << (irq))
+
+static u32 saved_wakeup_low = 0, saved_wakeup_high = 0;
+static u32 suspend_wakeup_low = 0, suspend_wakeup_high = 0;
+
 /* Disable interrupt number "irq" in the AVIC */
 static void mxc_mask_irq(unsigned int irq)
 {
@@ -66,12 +71,53 @@ static void mxc_unmask_irq(unsigned int irq)
 	__raw_writel(irq, AVIC_INTENNUM);
 }
 
+static int mxc_set_wake_irq(unsigned int irq, unsigned int enable)
+{
+	u32 *wakeup_intr;
+	u32 irq_bit;
+
+	if (irq < 32) {
+		wakeup_intr = &suspend_wakeup_low;
+		irq_bit = IRQ_BIT(irq);
+	} else {
+		wakeup_intr = &suspend_wakeup_high;
+		irq_bit = IRQ_BIT(irq - 32);
+	}
+
+	if (enable) {
+		*wakeup_intr |= irq_bit;
+	} else {
+		*wakeup_intr &= ~irq_bit;
+	}
+
+
+	return 0;
+}
+
 static struct irq_chip mxc_avic_chip = {
 	.ack = mxc_mask_irq,
 	.mask = mxc_mask_irq,
 	.unmask = mxc_unmask_irq,
+	.set_wake = mxc_set_wake_irq,
 };
 
+#ifdef CONFIG_PM
+void mxc_pic_enter_suspend(void)
+{
+	saved_wakeup_high = __raw_readl(AVIC_INTENABLEH);
+	saved_wakeup_low = __raw_readl(AVIC_INTENABLEL);
+
+	__raw_writel(suspend_wakeup_high, AVIC_INTENABLEH);
+	__raw_writel(suspend_wakeup_low, AVIC_INTENABLEL);
+}
+
+void mxc_pic_exit_suspend(void)
+{
+	__raw_writel(saved_wakeup_high, AVIC_INTENABLEH);
+	__raw_writel(saved_wakeup_low, AVIC_INTENABLEL);
+}
+#endif	/* CONFIG_PM */
+
 /*
  * This function initializes the AVIC hardware and disables all the
  * interrupts. It registers the interrupt enable and disable functions
-- 
1.5.5.1

