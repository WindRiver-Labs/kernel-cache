From f6c61282d051ac3a926a78082824664f3c44acc5 Mon Sep 17 00:00:00 2001
From: Chunbo Luo <chunbo.luo@windriver.com>
Date: Fri, 18 Apr 2008 16:13:30 +0800
Subject: [PATCH] patches-imx27ads/imx27ads_platfom

Signed-off-by: Liming Wang <liming.wang@windriver.com>
---
 arch/arm/mach-mx27/Kconfig        |   11 +
 arch/arm/mach-mx27/Makefile       |    9 +
 arch/arm/mach-mx27/Makefile.boot  |    3 +
 arch/arm/mach-mx27/clock.c        | 1324 +++++++++++++++++++++++++++++++++++++
 arch/arm/mach-mx27/crm_regs.h     |  189 ++++++
 arch/arm/mach-mx27/devices.c      |  520 +++++++++++++++
 arch/arm/mach-mx27/dma.c          |  536 +++++++++++++++
 arch/arm/mach-mx27/gpio_mux.c     |  302 +++++++++
 arch/arm/mach-mx27/gpio_mux.h     |   76 +++
 arch/arm/mach-mx27/mm.c           |   55 ++
 arch/arm/mach-mx27/mx27ads.c      |  704 ++++++++++++++++++++
 arch/arm/mach-mx27/mx27ads_gpio.c | 1172 ++++++++++++++++++++++++++++++++
 arch/arm/mach-mx27/serial.c       |  269 ++++++++
 arch/arm/mach-mx27/serial.h       |  165 +++++
 arch/arm/mach-mx27/system.c       |   69 ++
 arch/arm/mach-mx27/time.c         |  169 +++++
 16 files changed, 5573 insertions(+), 0 deletions(-)
 create mode 100644 arch/arm/mach-mx27/Kconfig
 create mode 100644 arch/arm/mach-mx27/Makefile
 create mode 100644 arch/arm/mach-mx27/Makefile.boot
 create mode 100644 arch/arm/mach-mx27/clock.c
 create mode 100644 arch/arm/mach-mx27/crm_regs.h
 create mode 100644 arch/arm/mach-mx27/devices.c
 create mode 100644 arch/arm/mach-mx27/dma.c
 create mode 100644 arch/arm/mach-mx27/gpio_mux.c
 create mode 100644 arch/arm/mach-mx27/gpio_mux.h
 create mode 100644 arch/arm/mach-mx27/mm.c
 create mode 100644 arch/arm/mach-mx27/mx27ads.c
 create mode 100644 arch/arm/mach-mx27/mx27ads_gpio.c
 create mode 100644 arch/arm/mach-mx27/serial.c
 create mode 100644 arch/arm/mach-mx27/serial.h
 create mode 100644 arch/arm/mach-mx27/system.c
 create mode 100644 arch/arm/mach-mx27/time.c

diff --git a/arch/arm/mach-mx27/Kconfig b/arch/arm/mach-mx27/Kconfig
new file mode 100644
index 0000000..4a536b2
--- /dev/null
+++ b/arch/arm/mach-mx27/Kconfig
@@ -0,0 +1,11 @@
+menu "MX27 Options"
+	depends on ARCH_MX27
+
+config MACH_MX27ADS
+	bool "Support MX27ADS platforms"
+	default y
+	help
+	  Include support for MX27ADS platform. This includes specific
+	  configurations for the board and its peripherals.
+
+endmenu
diff --git a/arch/arm/mach-mx27/Makefile b/arch/arm/mach-mx27/Makefile
new file mode 100644
index 0000000..cb0c1eb
--- /dev/null
+++ b/arch/arm/mach-mx27/Makefile
@@ -0,0 +1,9 @@
+#
+# Makefile for the linux kernel.
+#
+
+# Object file lists.
+
+obj-y		:= mm.o time.o dma.o gpio_mux.o clock.o devices.o serial.o system.o
+obj-$(CONFIG_MACH_MX27ADS)	+= mx27ads.o mx27ads_gpio.o
+
diff --git a/arch/arm/mach-mx27/Makefile.boot b/arch/arm/mach-mx27/Makefile.boot
new file mode 100644
index 0000000..696831d
--- /dev/null
+++ b/arch/arm/mach-mx27/Makefile.boot
@@ -0,0 +1,3 @@
+   zreladdr-y	:= 0xA0008000
+params_phys-y	:= 0xA0000100
+initrd_phys-y	:= 0xA0800000
diff --git a/arch/arm/mach-mx27/clock.c b/arch/arm/mach-mx27/clock.c
new file mode 100644
index 0000000..923269b
--- /dev/null
+++ b/arch/arm/mach-mx27/clock.c
@@ -0,0 +1,1324 @@
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file clock.c
+ * @brief API for setting up and retrieving clocks.
+ *
+ * This file contains API for setting up and retrieving clocks.
+ *
+ * @ingroup CLOCKS
+ */
+
+#include <linux/module.h>
+#include <linux/spinlock.h>
+#include <asm/io.h>
+#include <asm/arch/clock.h>
+#include "crm_regs.h"
+#include <asm/div64.h>
+/*!
+ * Spinlock to protect CRM register accesses
+ */
+static DEFINE_SPINLOCK(mxc_crm_lock);
+
+/*!
+ * define a variable & macro to control the perclk2.
+ */
+#define MXC_CLK_PCLK2_CSPI1	0
+#define MXC_CLK_PCLK2_CSPI2	1
+#define MXC_CLK_PCLK2_CSPI3	2
+#define MXC_CLK_PCLK2_SDHC1	3
+#define MXC_CLK_PCLK2_SDHC2	4
+static int g_perclk2_map = 0;
+
+/*!
+ * g_emma_clock_map is defined to control the emma_clock .
+ * emma_clock will be disabled until emma_prp_clk and emma_pp_clk are closed.
+ */
+#define MXC_CLK_EMMA_PRP	0
+#define MXC_CLK_EMMA_PP		1
+static int g_emma_clock_map = 0;
+
+/*
+ * Bit fields
+ */
+#define CLKSRC_NO_CLK		0
+#define CLKSRC_PERCLK		1
+#define CLKSRC_PERCLK_4		2
+#define CLKSRC_EXT_PAD		3
+
+/*
+ * Get Clock errors
+ */
+#define ERR_CLK_NO_SUPPORT	1
+
+/*!
+ * This function enables the perclk2.
+ * @param	source each bit of source indicate the clock status of mdoule
+ *		which is using emma clk
+ * @return      none.
+ */
+static void inline __enable_perclk2(unsigned long source)
+{
+	unsigned long reg;
+
+	BUG_ON(source > 31);
+	if (g_perclk2_map == 0) {
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		reg |= CCM_PCCR1_PERCLK2;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+	}
+	g_perclk2_map |= (1 << source);
+}
+
+/*!
+ * This function disables the perclk2.
+ * @param	source each bit of source indicate the clock status of mdoule
+ *		which is using emma clk
+ * @return      none.
+ */
+static void inline __disable_perclk2(unsigned long source)
+{
+	unsigned long reg;
+
+	BUG_ON(source > 31);
+	g_perclk2_map &= ~(1 << source);
+	if (g_perclk2_map == 0) {
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		reg &= ~CCM_PCCR1_PERCLK2;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+	}
+}
+
+/*!
+ * This function enables the emma clock.
+ * @param	source each bit of source indicate the clock status of mdoule
+ *		which is using emma clk
+ * @return 	none
+ */
+static void inline __enable_emma_clk(unsigned long source)
+{
+	unsigned long reg;
+
+	if (g_emma_clock_map == 0) {
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		reg |= CCM_PCCR0_EMMA;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		reg |= CCM_PCCR1_HCLK_EMMA;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+	}
+	g_emma_clock_map |= (1 << source);
+}
+
+/*!
+ * This function disables the emma clock.
+ * @param	source each bit of source indicate the clock status of mdoule
+ *		which is using emma clk
+ * @return 	none
+ */
+static void inline __disable_emma_clk(unsigned long source)
+{
+	unsigned long reg;
+
+	g_emma_clock_map &= ~(1 << source);
+	if (g_emma_clock_map == 0) {
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		reg &= ~CCM_PCCR0_EMMA;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		reg &= ~CCM_PCCR1_HCLK_EMMA;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+	}
+}
+
+/*
+ * This function returns the clock CKIH clock input value.
+ */
+static unsigned long mxc_clock_ckih(void)
+{
+	static unsigned long g_clk_ckih = 0;
+
+	if (g_clk_ckih == 0) {
+		if ((__raw_readw(PBC_VERSION_REG) & CKIH_27MHZ_BIT_SET) == 0) {
+			g_clk_ckih = CKIH_CLK_FREQ_27MHZ;
+		} else {
+			g_clk_ckih = CKIH_CLK_FREQ;
+		}
+		pr_info("Clock input source is %ld\n", g_clk_ckih);
+	}
+
+	return g_clk_ckih;
+}
+
+/*!
+ * This function returns the PLL output value in Hz based on pll.
+ * @param       pll     PLL as defined in enum plls
+ * @return      PLL value in Hz.
+ */
+unsigned long mxc_pll_clock(enum plls pll)
+{
+	unsigned long mfi = 0, mfn = 0, mfd = 0, pdf = 0;
+	unsigned long ref_clk = 0, prcs = 0;
+	unsigned long reg, cscr;
+	unsigned long long temp;
+
+	cscr = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_CSCR);
+	if (pll == MCUPLL) {
+		prcs = (cscr & CCM_CSCR_MCU);
+		if (prcs == CCM_CSCR_MCU) {
+			ref_clk = mxc_clock_ckih();
+		} else {
+			ref_clk = CKIL_CLK_FREQ;
+		}
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_MPCTL0);
+		pdf = (reg & CCM_MPCTL0_PD_MASK) >> CCM_MPCTL0_PD_OFFSET;
+		mfd = (reg & CCM_MPCTL0_MFD_MASK) >> CCM_MPCTL0_MFD_OFFSET;
+		mfi = (reg & CCM_MPCTL0_MFI_MASK) >> CCM_MPCTL0_MFI_OFFSET;
+		mfn = (reg & CCM_MPCTL0_MFN_MASK) >> CCM_MPCTL0_MFN_OFFSET;
+	} else if (pll == SERIALPLL) {
+		prcs = (cscr & CCM_CSCR_SP);
+		if (prcs == CCM_CSCR_SP) {
+			ref_clk = mxc_clock_ckih();
+		} else {
+			ref_clk = CKIL_CLK_FREQ;
+		}
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_SPCTL0);
+		pdf = (reg & CCM_SPCTL0_PD_MASK) >> CCM_SPCTL0_PD_OFFSET;
+		mfd = (reg & CCM_SPCTL0_MFD_MASK) >> CCM_SPCTL0_MFD_OFFSET;
+		mfi = (reg & CCM_SPCTL0_MFI_MASK) >> CCM_SPCTL0_MFI_OFFSET;
+		mfn = (reg & CCM_SPCTL0_MFN_MASK) >> CCM_SPCTL0_MFN_OFFSET;
+	} else {
+		printk(KERN_ERR "\nUnknown pll: %d\n\n", pll);
+		BUG();		/* oops */
+	}
+
+	mfi = (mfi <= 5) ? 5 : mfi;
+	temp = (unsigned long long)2 *ref_clk * mfn;
+	do_div(temp, mfd + 1);
+	temp = (unsigned long long)2 *ref_clk * mfi + temp;
+	do_div(temp, pdf + 1);
+
+	return (unsigned long)temp;
+}
+
+/*!
+ * This function returns the mcu main clock frequency
+ *
+ * @return      mcu main clock value in Hz.
+ */
+static unsigned long mxc_mcu_main_clock(void)
+{
+	return mxc_pll_clock(MCUPLL);
+}
+
+/*!
+ * This function returns the GPT module clock frequency
+ *
+ * @param       gpt_ctrl     GPT control register value
+ * @param       perclk       PERCLK1 frequency in Hz
+ *
+ * @return      GPT clock frequency value in Hz.
+ */
+static unsigned long mxc_get_gpt_clk(unsigned long gpt_ctrl,
+				     unsigned long perclk)
+{
+	unsigned long ret_val = 0;
+	int clksrc;
+
+	/*
+	 * Three possibilities
+	 */
+	clksrc = (gpt_ctrl & (~GPT_CTRL_MASK)) >> (GPT_CTRL_OFFSET);
+	switch (clksrc) {
+	case CLKSRC_PERCLK:
+		ret_val = perclk;
+		break;
+	case CLKSRC_PERCLK_4:
+		ret_val = (perclk / 4);
+		break;
+	case CLKSRC_NO_CLK:
+	case CLKSRC_EXT_PAD:
+		printk(KERN_ERR
+		       "Warning: GPT clock source not supported !!!\n");
+		return -ERR_CLK_NO_SUPPORT;
+	default:
+		ret_val = CKIL_CLK_FREQ;
+		break;
+	}
+
+	return ret_val;
+}
+
+/*!
+ * This function returns the main clock values in Hz.
+ *
+ * @param       clk     as defined in enum mxc_clocks
+ *
+ * @return      clock value in Hz
+ */
+unsigned long mxc_get_clocks(enum mxc_clocks clk)
+{
+	unsigned long pll, spll, ret_val = 0, hclk, gpt_ctrl;
+	unsigned long presc_pdf, ipg_pdf, nfc_pdf, usb_pdf;
+	unsigned long cscr = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_CSCR);
+	unsigned long pcdr0 =
+	    __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCDR0);
+	unsigned long pcdr1 =
+	    __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCDR1);
+
+	unsigned long fclk, ipgclk, perclk1, perclk2, perclk3, perclk4;
+	unsigned long bclk_pdf;
+	unsigned long perclk1_pdf, perclk2_pdf, perclk3_pdf, perclk4_pdf;
+	unsigned long clk_src;
+	unsigned long ssi1_pdf = 0;
+	unsigned long ssi2_pdf = 0;
+	unsigned long vpu_pdf = 0;
+	presc_pdf = (cscr & CCM_CSCR_PRESC_MASK) >> CCM_CSCR_PRESC_OFFSET;
+	bclk_pdf = (cscr & CCM_CSCR_BCLK_MASK) >> CCM_CSCR_BCLK_OFFSET;
+	ipg_pdf = (cscr & CCM_CSCR_IPDIV) >> CCM_CSCR_IPDIV_OFFSET;
+	perclk1_pdf =
+	    (pcdr1 & CCM_PCDR1_PERDIV1_MASK) >> CCM_PCDR1_PERDIV1_OFFSET;
+	perclk2_pdf =
+	    (pcdr1 & CCM_PCDR1_PERDIV2_MASK) >> CCM_PCDR1_PERDIV2_OFFSET;
+	perclk3_pdf =
+	    (pcdr1 & CCM_PCDR1_PERDIV3_MASK) >> CCM_PCDR1_PERDIV3_OFFSET;
+	perclk4_pdf =
+	    (pcdr1 & CCM_PCDR1_PERDIV4_MASK) >> CCM_PCDR1_PERDIV4_OFFSET;
+
+	pll = mxc_mcu_main_clock();
+	spll = mxc_pll_clock(SERIALPLL);
+	fclk = pll / (presc_pdf + 1);
+	hclk = fclk / (bclk_pdf + 1);
+	ipgclk = hclk / (ipg_pdf + 1);
+	perclk1 = pll / (perclk1_pdf + 1);
+	perclk2 = pll / (perclk2_pdf + 1);
+	perclk3 = pll / (perclk3_pdf + 1);
+	perclk4 = pll / (perclk4_pdf + 1);
+	switch (clk) {
+	case CKIL_CLK:
+		ret_val = CKIL_CLK_FREQ;
+		break;
+	case CKIH_CLK:
+		ret_val = mxc_clock_ckih();
+		break;
+	case CPU_CLK:
+		ret_val = fclk;
+		break;
+	case AHB_CLK:
+		ret_val = hclk;
+		break;
+	case PERCLK1:
+	case UART6_BAUD:
+	case UART5_BAUD:
+	case UART4_BAUD:
+	case UART3_BAUD:
+	case UART2_BAUD:
+	case UART1_BAUD:
+		ret_val = perclk1;
+		break;
+	case GPT6_CLK:
+		gpt_ctrl = __raw_readl(MXC_GPT_TCTL(6));
+		ret_val = mxc_get_gpt_clk(gpt_ctrl, perclk1);
+		break;
+	case GPT5_CLK:
+		gpt_ctrl = __raw_readl(MXC_GPT_TCTL(5));
+		ret_val = mxc_get_gpt_clk(gpt_ctrl, perclk1);
+		break;
+	case GPT4_CLK:
+		gpt_ctrl = __raw_readl(MXC_GPT_TCTL(4));
+		ret_val = mxc_get_gpt_clk(gpt_ctrl, perclk1);
+		break;
+	case GPT3_CLK:
+		gpt_ctrl = __raw_readl(MXC_GPT_TCTL(3));
+		ret_val = mxc_get_gpt_clk(gpt_ctrl, perclk1);
+		break;
+	case GPT2_CLK:
+		gpt_ctrl = __raw_readl(MXC_GPT_TCTL(2));
+		ret_val = mxc_get_gpt_clk(gpt_ctrl, perclk1);
+		break;
+	case GPT1_CLK:
+		gpt_ctrl = __raw_readl(MXC_GPT_TCTL(1));
+		ret_val = mxc_get_gpt_clk(gpt_ctrl, perclk1);
+		break;
+	case PWM_CLK:
+		ret_val = perclk1;
+		break;
+	case PERCLK2:
+	case SDHC2_CLK:
+	case SDHC1_CLK:
+	case CSPI3_CLK:
+	case CSPI2_CLK:
+	case CSPI1_CLK:
+		ret_val = perclk2;
+		break;
+	case PERCLK3:
+	case LCDC_CLK:
+		ret_val = perclk3;
+		break;
+	case PERCLK4:
+	case CSI_BAUD:
+		ret_val = perclk4;
+		break;
+	case USB_CLK:
+		usb_pdf = (cscr & CCM_CSCR_USB_MASK) >> CCM_CSCR_USB_OFFSET;
+		ret_val = spll / (usb_pdf + 1);
+		break;
+	case SSI1_BAUD:
+		ssi1_pdf = (pcdr0 & CCM_PCDR0_SSI1BAUDDIV_MASK) >>
+		    CCM_PCDR0_SSI1BAUDDIV_OFFSET;
+		clk_src = (cscr & CCM_CSCR_SSI1) >> CCM_CSCR_SSI1_OFFSET;
+		if (clk_src)
+			ret_val = pll / (ssi1_pdf + 1);
+		else
+			ret_val = spll / (ssi1_pdf + 1);
+		break;
+	case SSI2_BAUD:
+		ssi1_pdf = (pcdr0 & CCM_PCDR0_SSI2BAUDDIV_MASK) >>
+		    CCM_PCDR0_SSI2BAUDDIV_OFFSET;
+		clk_src = (cscr & CCM_CSCR_SSI2) >> CCM_CSCR_SSI2_OFFSET;
+		if (clk_src)
+			ret_val = pll / (ssi2_pdf + 1);
+		else
+			ret_val = spll / (ssi2_pdf + 1);
+		break;
+	case NFC_CLK:
+		nfc_pdf = (pcdr0 & CCM_PCDR0_NFCDIV_MASK) >>
+		    CCM_PCDR0_NFCDIV_OFFSET;
+		ret_val = hclk / (nfc_pdf + 1);
+		break;
+	case VPU_BAUD:
+		vpu_pdf = (pcdr0 & CCM_PCDR0_VPUDIV_MASK) >>
+		    CCM_PCDR0_VPUDIV_OFFSET;
+		clk_src = (cscr & CCM_CSCR_VPU) >> CCM_CSCR_VPU_OFFSET;
+		if (clk_src)
+			ret_val = pll / (vpu_pdf + 1);
+		else
+			ret_val = spll / (vpu_pdf + 1);
+		break;
+	case OWIRE_CLK:
+	default:
+		ret_val = ipgclk;
+		break;
+	}
+	return ret_val;
+}
+
+/*!
+ * This function returns the parent clock values in Hz.
+ *
+ * @param       clk     as defined in enum mxc_clocks
+ *
+ * @return      clock value in Hz
+ */
+unsigned long mxc_get_clocks_parent(enum mxc_clocks clk)
+{
+	unsigned long ret_val = 0;
+
+	switch (clk) {
+	case CSI_BAUD:
+		ret_val = mxc_mcu_main_clock();
+		break;
+	default:
+		break;
+	}
+	return ret_val;
+}
+
+/*!
+ * This function sets the PLL source for a clock.
+ *
+ * @param clk     as defined in enum mxc_clocks
+ * @param pll_num the PLL that you wish to use as source for this clock
+ */
+void mxc_set_clocks_pll(enum mxc_clocks clk, enum plls pll_num)
+{
+	unsigned long cscr;
+	unsigned long flags;
+
+	spin_lock_irqsave(&mxc_crm_lock, flags);
+	cscr = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_CSCR);
+
+	switch (clk) {
+	case SSI1_BAUD:
+		cscr = (cscr & (~CCM_CSCR_SSI1)) |
+		    (pll_num << CCM_CSCR_SSI1_OFFSET);
+		break;
+	case SSI2_BAUD:
+		cscr = (cscr & (~CCM_CSCR_SSI2)) |
+		    (pll_num << CCM_CSCR_SSI2_OFFSET);
+		break;
+	case VPU_BAUD:
+		cscr = (cscr & (~CCM_CSCR_VPU)) |
+		    (pll_num << CCM_CSCR_VPU_OFFSET);
+		break;
+	default:
+		printk(KERN_ERR
+		       "This clock does not have ability to choose its clock source\n");
+		break;
+	}
+	__raw_writel(cscr, IO_ADDRESS(CCM_BASE_ADDR) + CCM_CSCR);
+	spin_unlock_irqrestore(&mxc_crm_lock, flags);
+	return;
+}
+
+/*!
+ * This function sets the divider value for a clock.
+ *
+ * @param clk as defined in enum mxc_clocks
+ * @param div the division factor to be used for the clock (For SSI & CSI, pass
+ *	   in 2 times the expected division value to account for FP vals on certain
+ *	   platforms)
+ */
+void mxc_set_clocks_div(enum mxc_clocks clk, unsigned int div)
+{
+	unsigned long reg;
+	unsigned long flags;
+
+	spin_lock_irqsave(&mxc_crm_lock, flags);
+
+	switch (clk) {
+	case SSI2_BAUD:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCDR0);
+		reg = (reg & (~CCM_PCDR0_SSI2BAUDDIV_MASK)) |
+		    ((div - 1) << CCM_PCDR0_SSI2BAUDDIV_OFFSET);
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCDR0);
+		break;
+	case SSI1_BAUD:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCDR0);
+		reg = (reg & (~CCM_PCDR0_SSI1BAUDDIV_MASK)) |
+		    ((div - 1) << CCM_PCDR0_SSI1BAUDDIV_OFFSET);
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCDR0);
+		break;
+	case NFC_CLK:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCDR0);
+		reg = (reg & (~CCM_PCDR0_NFCDIV_MASK)) |
+		    ((div - 1) << CCM_PCDR0_NFCDIV_OFFSET);
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCDR0);
+		break;
+	case VPU_BAUD:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCDR0);
+		reg = (reg & (~CCM_PCDR0_VPUDIV_MASK)) |
+		    ((div - 1) << CCM_PCDR0_VPUDIV_OFFSET);
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCDR0);
+		break;
+	case PERCLK1:
+	case UART6_BAUD:
+	case UART5_BAUD:
+	case UART4_BAUD:
+	case UART3_BAUD:
+	case UART2_BAUD:
+	case UART1_BAUD:
+	case GPT6_CLK:
+	case GPT5_CLK:
+	case GPT4_CLK:
+	case GPT3_CLK:
+	case GPT2_CLK:
+	case GPT1_CLK:
+	case PWM_CLK:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCDR1);
+		reg = (reg & (~CCM_PCDR1_PERDIV1_MASK)) |
+		    ((div - 1) << CCM_PCDR1_PERDIV1_OFFSET);
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCDR1);
+		break;
+	case PERCLK2:
+	case SDHC2_CLK:
+	case SDHC1_CLK:
+	case CSPI3_CLK:
+	case CSPI2_CLK:
+	case CSPI1_CLK:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCDR1);
+		reg = (reg & (~CCM_PCDR1_PERDIV2_MASK)) |
+		    ((div - 1) << CCM_PCDR1_PERDIV2_OFFSET);
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCDR1);
+		break;
+	case PERCLK3:
+	case LCDC_CLK:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCDR1);
+		reg = (reg & (~CCM_PCDR1_PERDIV3_MASK)) |
+		    ((div - 1) << CCM_PCDR1_PERDIV3_OFFSET);
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCDR1);
+		break;
+	case PERCLK4:
+	case CSI_BAUD:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCDR1);
+		reg = (reg & (~CCM_PCDR1_PERDIV4_MASK)) |
+		    ((div - 1) << CCM_PCDR1_PERDIV4_OFFSET);
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCDR1);
+		break;
+	case USB_CLK:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_CSCR);
+		reg = (reg & (~CCM_CSCR_USB_MASK)) |
+		    ((div - 1) << CCM_CSCR_USB_OFFSET);
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_CSCR);
+		break;
+	case IPG_CLK:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_CSCR);
+		reg = (reg & (~CCM_CSCR_IPDIV)) |
+		    ((div - 1) << CCM_CSCR_IPDIV_OFFSET);
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_CSCR);
+		break;
+	case CPU_CLK:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_CSCR);
+		reg = (reg & (~CCM_CSCR_PRESC_MASK)) |
+		    ((div - 1) << CCM_CSCR_PRESC_OFFSET);
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_CSCR);
+		break;
+	case AHB_CLK:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_CSCR);
+		reg = (reg & (~CCM_CSCR_BCLK_MASK)) |
+		    ((div - 1) << CCM_CSCR_BCLK_OFFSET);
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_CSCR);
+		break;
+	default:
+		break;
+	}
+
+	spin_unlock_irqrestore(&mxc_crm_lock, flags);
+}
+
+/*!
+ * This function is called to enable the individual module clocks
+ *
+ * @param       clk     as defined in enum mxc_clocks
+ */
+void mxc_clks_enable(enum mxc_clocks clk)
+{
+	unsigned long flags;
+	unsigned long reg;
+
+	spin_lock_irqsave(&mxc_crm_lock, flags);
+	switch (clk) {
+	case CSI_BAUD:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		reg |= CCM_PCCR1_PERCLK4;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		reg |= CCM_PCCR1_HCLK_CSI;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		break;
+	case DMA_CLK:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		reg |= CCM_PCCR0_DMA;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		reg |= CCM_PCCR1_HCLK_DMA;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		break;
+	case RTIC_CLK:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		reg |= CCM_PCCR0_RTIC;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		reg |= CCM_PCCR1_HCLK_RTIC;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		break;
+	case BROM_CLK:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		reg |= CCM_PCCR1_HCLK_BROM;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		break;
+	case EMMA_PRP_CLK:
+		__enable_emma_clk(MXC_CLK_EMMA_PRP);
+		break;
+	case EMMA_PP_CLK:
+		__enable_emma_clk(MXC_CLK_EMMA_PP);
+		break;
+	case LCDC_CLK:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		reg |= CCM_PCCR1_PERCLK3;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		reg |= CCM_PCCR0_LCDC;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		reg |= CCM_PCCR1_HCLK_LCDC;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		break;
+	case SLCDC_CLK:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		reg |= CCM_PCCR0_SLCDC;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		reg |= CCM_PCCR1_HCLK_SLCDC;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		break;
+	case USB_CLK:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		reg |= CCM_PCCR1_USBOTG;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		reg |= CCM_PCCR1_HCLK_USBOTG;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		break;
+	case FEC_CLK:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		reg |= CCM_PCCR0_FEC;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		reg |= CCM_PCCR1_HCLK_FEC;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		break;
+	case EMI_CLK:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		reg |= CCM_PCCR1_HCLK_EMI;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		break;
+	case ATA_CLK:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		reg |= CCM_PCCR1_HCLK_ATA;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		break;
+	case VPU_BAUD:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		reg |= CCM_PCCR1_VPU_BAUD;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		reg |= CCM_PCCR1_HCLK_VPU;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		break;
+	case SAHARA2_CLK:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		reg |= CCM_PCCR0_SAHARA;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		reg |= CCM_PCCR1_HCLK_SAHARA;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		break;
+	case SSI1_BAUD:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		reg |= CCM_PCCR1_SSI1_BAUD;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		reg |= CCM_PCCR0_SSI1_IPG;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		break;
+	case SSI2_BAUD:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		reg |= CCM_PCCR1_SSI2_BAUD;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		reg |= CCM_PCCR0_SSI2_IPG;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		break;
+	case NFC_CLK:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		reg |= CCM_PCCR1_NFC_BAUD;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		break;
+	case MSTICK1_BAUD:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		reg |= CCM_PCCR1_MSHC_BAUD;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		reg |= CCM_PCCR0_MSHC;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		break;
+	case UART1_BAUD:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		reg |= CCM_PCCR1_UART1;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		break;
+	case UART2_BAUD:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		reg |= CCM_PCCR1_UART2;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		break;
+	case UART3_BAUD:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		reg |= CCM_PCCR1_UART3;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		break;
+	case UART4_BAUD:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		reg |= CCM_PCCR1_UART4;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		break;
+	case UART5_BAUD:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		reg |= CCM_PCCR1_UART5;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		break;
+	case UART6_BAUD:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		reg |= CCM_PCCR1_UART6;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		break;
+	case WDOG_CLK:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		reg |= CCM_PCCR1_WDT;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		break;
+
+	case CSPI3_CLK:
+		__enable_perclk2(MXC_CLK_PCLK2_CSPI3);
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		reg |= CCM_PCCR0_CSPI3;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		break;
+	case CSPI2_CLK:
+		__enable_perclk2(MXC_CLK_PCLK2_CSPI2);
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		reg |= CCM_PCCR0_CSPI2;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		break;
+	case CSPI1_CLK:
+		__enable_perclk2(MXC_CLK_PCLK2_CSPI1);
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		reg |= CCM_PCCR0_CSPI1;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		break;
+	case GPIO_CLK:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		reg |= CCM_PCCR0_GPIO;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		break;
+	case GPT3_CLK:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		reg |= CCM_PCCR0_GPT3;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		break;
+	case GPT2_CLK:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		reg |= CCM_PCCR0_GPT2;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		break;
+	case GPT1_CLK:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		reg |= CCM_PCCR0_GPT1;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		break;
+	case GPT4_CLK:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		reg |= CCM_PCCR0_GPT4;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		break;
+	case GPT5_CLK:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		reg |= CCM_PCCR0_GPT5;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		break;
+	case GPT6_CLK:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		reg |= CCM_PCCR0_GPT6;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		break;
+	case I2C1_CLK:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		reg |= CCM_PCCR0_I2C1;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		break;
+	case I2C2_CLK:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		reg |= CCM_PCCR0_I2C2;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		break;
+	case IIM_CLK:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		reg |= CCM_PCCR0_IIM;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		break;
+	case KPP_CLK:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		reg |= CCM_PCCR0_KPP;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		break;
+	case OWIRE_CLK:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		reg |= CCM_PCCR0_OWIRE;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		break;
+	case PWM_CLK:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		reg |= CCM_PCCR0_PWM;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		break;
+	case RTC_CLK:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		reg |= CCM_PCCR0_RTC;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		break;
+	case SCC_CLK:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		reg |= CCM_PCCR0_SCC;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		break;
+	case SDHC2_CLK:
+		__enable_perclk2(MXC_CLK_PCLK2_SDHC2);
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		reg |= CCM_PCCR0_SDHC2;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		break;
+	case SDHC1_CLK:
+		__enable_perclk2(MXC_CLK_PCLK2_SDHC1);
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		reg |= CCM_PCCR0_SDHC1;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		break;
+	case SDHC3_CLK:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		reg |= CCM_PCCR0_SDHC3;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		break;
+
+	default:
+		break;
+	}
+	spin_unlock_irqrestore(&mxc_crm_lock, flags);
+}
+
+/*!
+ * This function is called to disable the individual module clocks
+ *
+ * @param       clk     as defined in enum mxc_clocks
+ */
+void mxc_clks_disable(enum mxc_clocks clk)
+{
+	unsigned long flags;
+	unsigned long reg;
+
+	spin_lock_irqsave(&mxc_crm_lock, flags);
+	switch (clk) {
+	case CSI_BAUD:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		reg &= ~CCM_PCCR1_HCLK_CSI;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		reg &= ~CCM_PCCR1_PERCLK4;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		break;
+	case DMA_CLK:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		reg &= ~CCM_PCCR0_DMA;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		reg &= ~CCM_PCCR1_HCLK_DMA;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		break;
+	case RTIC_CLK:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		reg &= ~CCM_PCCR0_RTIC;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		reg &= ~CCM_PCCR1_HCLK_RTIC;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		break;
+	case BROM_CLK:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		reg &= ~CCM_PCCR1_HCLK_BROM;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		break;
+	case EMMA_PRP_CLK:
+		__disable_emma_clk(MXC_CLK_EMMA_PRP);
+		break;
+	case EMMA_PP_CLK:
+		__disable_emma_clk(MXC_CLK_EMMA_PP);
+		break;
+		break;
+	case LCDC_CLK:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		reg &= ~CCM_PCCR0_LCDC;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		reg &= ~CCM_PCCR1_HCLK_LCDC;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		reg &= ~CCM_PCCR1_PERCLK3;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		break;
+	case SLCDC_CLK:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		reg &= ~CCM_PCCR0_SLCDC;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		reg &= ~CCM_PCCR1_HCLK_SLCDC;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		break;
+	case USB_CLK:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		reg &= ~CCM_PCCR1_USBOTG;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		reg &= ~CCM_PCCR1_HCLK_USBOTG;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		break;
+	case FEC_CLK:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		reg &= ~CCM_PCCR1_HCLK_FEC;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		reg &= ~CCM_PCCR0_FEC;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		break;
+	case EMI_CLK:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		reg &= ~CCM_PCCR1_HCLK_EMI;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		break;
+	case ATA_CLK:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		reg &= ~CCM_PCCR1_HCLK_ATA;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		break;
+	case VPU_BAUD:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		reg &= ~CCM_PCCR1_VPU_BAUD;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		reg &= ~CCM_PCCR1_HCLK_VPU;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		break;
+	case SAHARA2_CLK:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		reg &= ~CCM_PCCR0_SAHARA;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		reg &= ~CCM_PCCR1_HCLK_SAHARA;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		break;
+	case SSI1_BAUD:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		reg &= ~CCM_PCCR1_SSI1_BAUD;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		reg &= ~CCM_PCCR0_SSI1_IPG;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		break;
+	case SSI2_BAUD:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		reg &= ~CCM_PCCR1_SSI2_BAUD;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		reg &= ~CCM_PCCR0_SSI2_IPG;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		break;
+	case NFC_CLK:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		reg &= ~CCM_PCCR1_NFC_BAUD;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		break;
+	case MSTICK1_BAUD:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		reg &= ~CCM_PCCR1_MSHC_BAUD;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		reg &= ~CCM_PCCR0_MSHC;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		break;
+	case UART1_BAUD:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		reg &= ~CCM_PCCR1_UART1;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		break;
+	case UART2_BAUD:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		reg &= ~CCM_PCCR1_UART2;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		break;
+	case UART3_BAUD:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		reg &= ~CCM_PCCR1_UART3;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		break;
+	case UART4_BAUD:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		reg &= ~CCM_PCCR1_UART4;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		break;
+	case UART5_BAUD:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		reg &= ~CCM_PCCR1_UART5;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		break;
+	case UART6_BAUD:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		reg &= ~CCM_PCCR1_UART6;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		break;
+	case WDOG_CLK:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		reg &= ~CCM_PCCR1_WDT;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		break;
+	case CSPI3_CLK:
+		__disable_perclk2(MXC_CLK_PCLK2_CSPI3);
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		reg &= ~CCM_PCCR0_CSPI3;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		break;
+	case CSPI2_CLK:
+		__disable_perclk2(MXC_CLK_PCLK2_CSPI2);
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		reg &= ~CCM_PCCR0_CSPI2;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		break;
+	case CSPI1_CLK:
+		__disable_perclk2(MXC_CLK_PCLK2_CSPI1);
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		reg &= ~CCM_PCCR0_CSPI1;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		break;
+	case GPIO_CLK:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		reg &= ~CCM_PCCR0_GPIO;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		break;
+	case GPT3_CLK:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		reg &= ~CCM_PCCR0_GPT3;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		break;
+	case GPT2_CLK:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		reg &= ~CCM_PCCR0_GPT2;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		break;
+	case GPT1_CLK:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		reg &= ~CCM_PCCR0_GPT1;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		break;
+	case GPT4_CLK:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		reg &= ~CCM_PCCR0_GPT4;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		break;
+	case GPT5_CLK:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		reg &= ~CCM_PCCR0_GPT5;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		break;
+	case GPT6_CLK:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		reg &= ~CCM_PCCR0_GPT6;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		break;
+	case I2C1_CLK:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		reg &= ~CCM_PCCR0_I2C1;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		break;
+	case I2C2_CLK:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		reg &= ~CCM_PCCR0_I2C2;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		break;
+	case IIM_CLK:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		reg &= ~CCM_PCCR0_IIM;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		break;
+	case KPP_CLK:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		reg &= ~CCM_PCCR0_KPP;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		break;
+	case OWIRE_CLK:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		reg &= ~CCM_PCCR0_OWIRE;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		break;
+	case PWM_CLK:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		reg &= ~CCM_PCCR0_PWM;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		break;
+	case RTC_CLK:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		reg &= ~CCM_PCCR0_RTC;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		break;
+	case SCC_CLK:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		reg &= ~CCM_PCCR0_SCC;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		break;
+	case SDHC2_CLK:
+		__disable_perclk2(MXC_CLK_PCLK2_SDHC2);
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		reg &= ~CCM_PCCR0_SDHC2;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		break;
+	case SDHC1_CLK:
+		__disable_perclk2(MXC_CLK_PCLK2_SDHC1);
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		reg &= ~CCM_PCCR0_SDHC1;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		break;
+	case SDHC3_CLK:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		reg &= ~CCM_PCCR0_SDHC3;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		break;
+	default:
+		break;
+	}
+	spin_unlock_irqrestore(&mxc_crm_lock, flags);
+}
+
+/*!
+ * This function is used to modify PLL registers to generate the required
+ * frequency.
+ *
+ * @param  pll_num  the PLL that you wish to modify
+ * @param  mfi      multiplication factor integer part
+ * @param  pdf      pre-division factor
+ * @param  mfd      multiplication factor denominator
+ * @param  mfn      multiplication factor numerator
+ */
+void mxc_pll_set(enum plls pll_num, unsigned int mfi, unsigned int pdf,
+		 unsigned int mfd, unsigned int mfn)
+{
+	unsigned long cscr;
+	unsigned long flags;
+	unsigned long new_pll = 0;
+
+	spin_lock_irqsave(&mxc_crm_lock, flags);
+
+	if (pll_num == MCUPLL) {
+		/* Change the Pll value      */
+		new_pll = (mfi << CCM_MPCTL0_MFI_OFFSET) |
+		    (mfn << CCM_MPCTL0_MFN_OFFSET) |
+		    (mfd << CCM_MPCTL0_MFD_OFFSET) |
+		    (pdf << CCM_MPCTL0_PD_OFFSET);
+
+		__raw_writel(new_pll, IO_ADDRESS(CCM_BASE_ADDR) + CCM_MPCTL0);
+		/* Swap to reference clock and disable PLL */
+		cscr = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_CSCR);
+		cscr |= CCM_CSCR_MPLLRES;
+		__raw_writel(cscr, IO_ADDRESS(CCM_BASE_ADDR) + CCM_CSCR);
+	} else {
+		if (pll_num == SERIALPLL) {
+			/* Change the Pll value      */
+			new_pll = (mfi << CCM_SPCTL0_MFI_OFFSET) |
+			    (mfn << CCM_SPCTL0_MFN_OFFSET) |
+			    (mfd << CCM_SPCTL0_MFD_OFFSET) |
+			    (pdf << CCM_SPCTL0_PD_OFFSET);
+
+			__raw_writel(new_pll,
+				     IO_ADDRESS(CCM_BASE_ADDR) + CCM_SPCTL0);
+			/* Swap to reference clock and disable PLL */
+			cscr =
+			    __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_CSCR);
+			cscr |= CCM_CSCR_SPLLRES;
+			__raw_writel(cscr,
+				     IO_ADDRESS(CCM_BASE_ADDR) + CCM_CSCR);
+		}
+	}
+
+	spin_unlock_irqrestore(&mxc_crm_lock, flags);
+}
+
+/*!
+ * Configure clock output on CKO pins
+ *
+ * @param   output  clock output pin
+ * @param   clk     clock source to output
+ * @param   div     CLKO divider
+ *
+ */
+void mxc_set_clock_output(enum mxc_clk_out output, enum mxc_clocks clk, int div)
+{
+	unsigned long flags;
+	unsigned long reg;
+
+	if (output != CKO) {
+		return;
+	}
+
+	spin_lock_irqsave(&mxc_crm_lock, flags);
+
+	switch (clk) {
+	case CKIH_CLK:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_CCSR);
+		reg = (reg & (~0x1f)) | 0x2;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_CCSR);
+
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCDR0);
+		reg = (reg & (~0x03c00000)) | 0x02000000 | ((div - 1) << 22);
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCDR0);
+
+		break;
+	default:
+		break;
+	};
+
+	spin_unlock_irqrestore(&mxc_crm_lock, flags);
+	return;
+}
+
+/*!
+ * This function is called to read the contents of a CCM_MCU register
+ *
+ * @param reg_offset the CCM_MCU register that will read
+ *
+ * @return the register contents
+ */
+unsigned long mxc_ccm_get_reg(unsigned int reg_offset)
+{
+	/* TODO */
+	return 0xFFFFFFFF;
+}
+
+/*!
+ * This function is called to modify the contents of a CCM_MCU register
+ *
+ * @param reg_offset the CCM_MCU register that will read
+ * @param mask       the mask to be used to clear the bits that are to be modified
+ * @param data       the data that should be written to the register
+ */
+void mxc_ccm_modify_reg(unsigned int reg_offset, unsigned int mask,
+			unsigned int data)
+{
+	/* TODO */
+}
+
+EXPORT_SYMBOL(mxc_pll_set);
+EXPORT_SYMBOL(mxc_pll_clock);
+EXPORT_SYMBOL(mxc_get_clocks);
+EXPORT_SYMBOL(mxc_set_clocks_pll);
+EXPORT_SYMBOL(mxc_set_clocks_div);
+EXPORT_SYMBOL(mxc_clks_disable);
+EXPORT_SYMBOL(mxc_clks_enable);
+EXPORT_SYMBOL(mxc_ccm_get_reg);
+EXPORT_SYMBOL(mxc_ccm_modify_reg);
+EXPORT_SYMBOL(mxc_set_clock_output);
+EXPORT_SYMBOL(mxc_get_clocks_parent);
diff --git a/arch/arm/mach-mx27/crm_regs.h b/arch/arm/mach-mx27/crm_regs.h
new file mode 100644
index 0000000..d078e6a
--- /dev/null
+++ b/arch/arm/mach-mx27/crm_regs.h
@@ -0,0 +1,189 @@
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#ifndef __ARCH_ARM_MACH_MX27_CRM_REGS_H__
+#define __ARCH_ARM_MACH_MX27_CRM_REGS_H__
+
+#include <asm/arch/hardware.h>
+
+/* Register offsets */
+#define CCM_CSCR				0x0
+#define CCM_MPCTL0				0x4
+#define CCM_MPCTL1				0x8
+#define CCM_SPCTL0				0xC
+#define CCM_SPCTL1				0x10
+#define CCM_OSC26MCTL				0x14
+#define CCM_PCDR0				0x18
+#define CCM_PCDR1				0x1c
+#define CCM_PCCR0				0x20
+#define CCM_PCCR1				0x24
+#define CCM_CCSR				0x28
+#define CCM_PMCTL				0x2c
+#define CCM_PMCOUNT				0x30
+#define CCM_WKGDCTL				0x34
+
+#define CCM_CSCR_USB_OFFSET			28
+#define CCM_CSCR_USB_MASK			(0x7 << 28)
+#define CCM_CSCR_SD_OFFSET			24
+#define CCM_CSCR_SD_MASK			(0x3 << 24)
+#define CCM_CSCR_SSI2				(1 << 23)
+#define CCM_CSCR_SSI2_OFFSET			23
+#define CCM_CSCR_SSI1				(1 << 22)
+#define CCM_CSCR_SSI1_OFFSET			22
+#define CCM_CSCR_VPU				(1 << 21)
+#define CCM_CSCR_VPU_OFFSET			21
+#define CCM_CSCR_MSHC				(1 << 20)
+#define CCM_CSCR_SPLLRES			(1 << 19)
+#define CCM_CSCR_MPLLRES			(1 << 18)
+#define CCM_CSCR_SP				(1 << 17)
+#define CCM_CSCR_MCU				(1 << 16)
+#define CCM_CSCR_PRESC_OFFSET			13
+#define CCM_CSCR_PRESC_MASK			(0x7 << 13)
+#define CCM_CSCR_BCLK_OFFSET			9
+#define CCM_CSCR_BCLK_MASK			(0xf << 9)
+#define CCM_CSCR_IPDIV_OFFSET			8
+#define CCM_CSCR_IPDIV				(1 << 8)
+#define CCM_CSCR_OSC26MDIV			(1 << 4)
+#define CCM_CSCR_OSC26M				(1 << 3)
+#define CCM_CSCR_FPM				(1 << 2)
+#define CCM_CSCR_SPEN				(1 << 1)
+#define CCM_CSCR_MPEN				1
+
+#define CCM_MPCTL0_CPLM				(1 << 31)
+#define CCM_MPCTL0_PD_OFFSET			26
+#define CCM_MPCTL0_PD_MASK			(0xf << 26)
+#define CCM_MPCTL0_MFD_OFFSET			16
+#define CCM_MPCTL0_MFD_MASK			(0x3ff << 16)
+#define CCM_MPCTL0_MFI_OFFSET			10
+#define CCM_MPCTL0_MFI_MASK			(0xf << 10)
+#define CCM_MPCTL0_MFN_OFFSET			0
+#define CCM_MPCTL0_MFN_MASK			0x3ff
+
+#define CCM_MPCTL1_LF				(1 << 15)
+#define CCM_MPCTL1_BRMO				(1 << 6)
+
+#define CCM_SPCTL0_CPLM				(1 << 31)
+#define CCM_SPCTL0_PD_OFFSET			26
+#define CCM_SPCTL0_PD_MASK			(0xf << 26)
+#define CCM_SPCTL0_MFD_OFFSET			16
+#define CCM_SPCTL0_MFD_MASK			(0x3ff << 16)
+#define CCM_SPCTL0_MFI_OFFSET			10
+#define CCM_SPCTL0_MFI_MASK			(0xf << 10)
+#define CCM_SPCTL0_MFN_OFFSET			0
+#define CCM_SPCTL0_MFN_MASK			0x3ff
+
+#define CCM_SPCTL1_LF				(1 << 15)
+#define CCM_SPCTL1_BRMO				(1 << 6)
+
+#define CCM_OSC26MCTL_PEAK_OFFSET		16
+#define CCM_OSC26MCTL_PEAK_MASK			(0x3 << 16)
+#define CCM_OSC26MCTL_AGC_OFFSET		8
+#define CCM_OSC26MCTL_AGC_MASK			(0x3f << 8)
+#define CCM_OSC26MCTL_ANATEST_OFFSET		0
+#define CCM_OSC26MCTL_ANATEST_MASK		0x3f
+
+#define CCM_PCDR0_SSI2BAUDDIV_OFFSET		26
+#define CCM_PCDR0_SSI2BAUDDIV_MASK		(0x3f << 26)
+#define CCM_PCDR0_CLKO_EN			25
+#define CCM_PCDR0_CLKODIV_OFFSET		22
+#define CCM_PCDR0_CLKODIV_MASK			(0x7 << 22)
+#define CCM_PCDR0_SSI1BAUDDIV_OFFSET		16
+#define CCM_PCDR0_SSI1BAUDDIV_MASK		(0x3f << 16)
+#define CCM_PCDR0_NFCDIV_OFFSET			12
+#define CCM_PCDR0_NFCDIV_MASK			(0xf << 12)
+#define CCM_PCDR0_VPUDIV_OFFSET			8
+#define CCM_PCDR0_VPUDIV_MASK			(0xf << 8)
+#define CCM_PCDR0_MSHCDIV_OFFSET		0
+#define CCM_PCDR0_MSHCDIV_MASK			0x1f
+
+#define CCM_PCDR1_PERDIV4_OFFSET		24
+#define CCM_PCDR1_PERDIV4_MASK			(0x3f << 24)
+#define CCM_PCDR1_PERDIV3_OFFSET		16
+#define CCM_PCDR1_PERDIV3_MASK			(0x3f << 16)
+#define CCM_PCDR1_PERDIV2_OFFSET		8
+#define CCM_PCDR1_PERDIV2_MASK			(0x3f << 8)
+#define CCM_PCDR1_PERDIV1_OFFSET		0
+#define CCM_PCDR1_PERDIV1_MASK			0x3f
+
+#define CCM_PCCR0_CSPI1				(1 << 31)
+#define CCM_PCCR0_CSPI2				(1 << 30)
+#define CCM_PCCR0_CSPI3				(1 << 29)
+#define CCM_PCCR0_DMA				(1 << 28)
+#define CCM_PCCR0_EMMA				(1 << 27)
+#define CCM_PCCR0_FEC				(1 << 26)
+#define CCM_PCCR0_GPIO				(1 << 25)
+#define CCM_PCCR0_GPT1				(1 << 24)
+#define CCM_PCCR0_GPT2				(1 << 23)
+#define CCM_PCCR0_GPT3				(1 << 22)
+#define CCM_PCCR0_GPT4				(1 << 21)
+#define CCM_PCCR0_GPT5				(1 << 20)
+#define CCM_PCCR0_GPT6				(1 << 19)
+#define CCM_PCCR0_I2C1				(1 << 18)
+#define CCM_PCCR0_I2C2				(1 << 17)
+#define CCM_PCCR0_IIM				(1 << 16)
+#define CCM_PCCR0_KPP				(1 << 15)
+#define CCM_PCCR0_LCDC				(1 << 14)
+#define CCM_PCCR0_MSHC				(1 << 13)
+#define CCM_PCCR0_OWIRE				(1 << 12)
+#define CCM_PCCR0_PWM				(1 << 11)
+#define CCM_PCCR0_RTC				(1 << 9)
+#define CCM_PCCR0_RTIC				(1 << 8)
+#define CCM_PCCR0_SAHARA			(1 << 7)
+#define CCM_PCCR0_SCC				(1 << 6)
+#define CCM_PCCR0_SDHC1				(1 << 5)
+#define CCM_PCCR0_SDHC2				(1 << 4)
+#define CCM_PCCR0_SDHC3				(1 << 3)
+#define CCM_PCCR0_SLCDC				(1 << 2)
+#define CCM_PCCR0_SSI1_IPG			(1 << 1)
+#define CCM_PCCR0_SSI2_IPG			(1 << 0)
+
+#define CCM_PCCR1_UART1				(1 << 31)
+#define CCM_PCCR1_UART2				(1 << 30)
+#define CCM_PCCR1_UART3				(1 << 29)
+#define CCM_PCCR1_UART4				(1 << 28)
+#define CCM_PCCR1_UART5				(1 << 27)
+#define CCM_PCCR1_UART6				(1 << 26)
+#define CCM_PCCR1_USBOTG			(1 << 25)
+#define CCM_PCCR1_WDT				(1 << 24)
+#define CCM_PCCR1_HCLK_ATA			(1 << 23)
+#define CCM_PCCR1_HCLK_BROM			(1 << 22)
+#define CCM_PCCR1_HCLK_CSI			(1 << 21)
+#define CCM_PCCR1_HCLK_DMA			(1 << 20)
+#define CCM_PCCR1_HCLK_EMI			(1 << 19)
+#define CCM_PCCR1_HCLK_EMMA			(1 << 18)
+#define CCM_PCCR1_HCLK_FEC			(1 << 17)
+#define CCM_PCCR1_HCLK_VPU			(1 << 16)
+#define CCM_PCCR1_HCLK_LCDC			(1 << 15)
+#define CCM_PCCR1_HCLK_RTIC			(1 << 14)
+#define CCM_PCCR1_HCLK_SAHARA			(1 << 13)
+#define CCM_PCCR1_HCLK_SLCDC			(1 << 12)
+#define CCM_PCCR1_HCLK_USBOTG			(1 << 11)
+#define CCM_PCCR1_PERCLK1			(1 << 10)
+#define CCM_PCCR1_PERCLK2			(1 << 9)
+#define CCM_PCCR1_PERCLK3			(1 << 8)
+#define CCM_PCCR1_PERCLK4			(1 << 7)
+#define CCM_PCCR1_VPU_BAUD			(1 << 6)
+#define CCM_PCCR1_SSI1_BAUD			(1 << 5)
+#define CCM_PCCR1_SSI2_BAUD			(1 << 4)
+#define CCM_PCCR1_NFC_BAUD			(1 << 3)
+#define CCM_PCCR1_MSHC_BAUD			(1 << 2)
+
+#define CCM_CCSR_32KSR				(1 << 15)
+#define CCM_CCSR_CLKMODE1			(1 << 9)
+#define CCM_CCSR_CLKMODE0			(1 << 8)
+#define CCM_CCSR_CLKOSEL_OFFSET			0
+#define CCM_CCSR_CLKOSEL_MASK			0x1f
+
+#define SYS_FMCR		0x14	/*  Functional Muxing Control Reg */
+
+#endif				/* __ARCH_ARM_MACH_MX27_CRM_REGS_H__ */
diff --git a/arch/arm/mach-mx27/devices.c b/arch/arm/mach-mx27/devices.c
new file mode 100644
index 0000000..7e6dec3
--- /dev/null
+++ b/arch/arm/mach-mx27/devices.c
@@ -0,0 +1,520 @@
+/*
+ * Author: MontaVista Software, Inc.
+ *       <source@mvista.com>
+ *
+ * Based on the OMAP devices.c
+ *
+ * 2005 (c) MontaVista Software, Inc. This file is licensed under the
+ * terms of the GNU General Public License version 2. This program is
+ * licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ *
+ * Copyright 2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+
+#include <linux/spi/spi.h>
+
+#include <asm/hardware.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/gpio.h>
+#if defined(CONFIG_MMC_MXC) || defined(CONFIG_MMC_MXC_MODULE)
+#include <asm/arch/mmc.h>
+#endif
+ /*!
+  * @file devices.c
+  * @brief device configurations including nor/nand/watchdog for mx27.
+  *
+  * @ingroup MSL
+  */
+
+static void mxc_nop_release(struct device *dev)
+{
+	/* Nothing */
+}
+
+#if defined(CONFIG_W1_MASTER_MXC) || defined(CONFIG_W1_MASTER_MXC_MODULE)
+static struct platform_device mxc_w1_devices = {
+	.name = "mxc_w1",
+	.dev = {
+		.release = mxc_nop_release,
+		},
+	.id = 0
+};
+
+static void mxc_init_owire(void)
+{
+	(void)platform_device_register(&mxc_w1_devices);
+}
+#else
+static inline void mxc_init_owire(void)
+{
+}
+#endif
+
+#if defined(CONFIG_MXC_RTC) || defined(CONFIG_MXC_RTC_MODULE)
+
+static struct platform_device mxc_rtc_device = {
+	.name = "mxc_rtc",
+	.id = 0,
+};
+static void mxc_init_rtc(void)
+{
+	(void)platform_device_register(&mxc_rtc_device);
+}
+#else
+static inline void mxc_init_rtc(void)
+{
+}
+#endif
+#if defined(CONFIG_MXC_WATCHDOG) || defined(CONFIG_MXC_WATCHDOG_MODULE)
+
+static struct resource wdt_resources[] = {
+	{
+	 .start = WDOG_BASE_ADDR,
+	 .end = WDOG_BASE_ADDR + 0x30,
+	 .flags = IORESOURCE_MEM,
+	 },
+};
+
+static struct platform_device mxc_wdt_device = {
+	.name = "mxc_wdt",
+	.id = 0,
+	.dev = {
+		.release = mxc_nop_release,
+		},
+	.num_resources = ARRAY_SIZE(wdt_resources),
+	.resource = wdt_resources,
+};
+
+static void mxc_init_wdt(void)
+{
+	mxc_clks_enable(WDOG_CLK);
+	(void)platform_device_register(&mxc_wdt_device);
+}
+#else
+static inline void mxc_init_wdt(void)
+{
+}
+#endif
+
+/* MMC device data */
+
+#if defined(CONFIG_MMC_MXC) || defined(CONFIG_MMC_MXC_MODULE)
+
+extern unsigned int sdhc_get_card_det_status(struct device *dev);
+extern int sdhc_init_card_det(int id);
+
+static struct mxc_mmc_platform_data mmc_data = {
+	.ocr_mask = MMC_VDD_27_28 | MMC_VDD_28_29 | MMC_VDD_29_30,
+	.min_clk = 150000,
+	.max_clk = 25000000,
+	.card_inserted_state = 0,
+	.status = sdhc_get_card_det_status,
+};
+
+/*!
+ * Resource definition for the SDHC1
+ */
+static struct resource mxcsdhc1_resources[] = {
+	[0] = {
+	       .start = SDHC1_BASE_ADDR,
+	       .end = SDHC1_BASE_ADDR + SZ_4K - 1,
+	       .flags = IORESOURCE_MEM,
+	       },
+	[1] = {
+	       .start = INT_SDHC1,
+	       .end = INT_SDHC1,
+	       .flags = IORESOURCE_IRQ,
+	       },
+	[2] = {
+	       .start = 0,
+	       .end = 0,
+	       .flags = IORESOURCE_IRQ,
+	       },
+	[3] = {
+	       .start = MXC_SDIO1_CARD_IRQ,
+	       .end = MXC_SDIO1_CARD_IRQ,
+	       .flags = IORESOURCE_IRQ,
+	       },
+};
+
+/*!
+ * Resource definition for the SDHC2
+ */
+static struct resource mxcsdhc2_resources[] = {
+	[0] = {
+	       .start = SDHC2_BASE_ADDR,
+	       .end = SDHC2_BASE_ADDR + SZ_4K - 1,
+	       .flags = IORESOURCE_MEM,
+	       },
+	[1] = {
+	       .start = INT_SDHC2,
+	       .end = INT_SDHC2,
+	       .flags = IORESOURCE_IRQ,
+	       },
+	[2] = {
+	       .start = 0,
+	       .end = 0,
+	       .flags = IORESOURCE_IRQ,
+	       },
+	[3] = {
+	       .start = MXC_SDIO2_CARD_IRQ,
+	       .end = MXC_SDIO2_CARD_IRQ,
+	       .flags = IORESOURCE_IRQ,
+	       },
+};
+
+/*! Device Definition for MXC SDHC1 */
+static struct platform_device mxcsdhc1_device = {
+	.name = "mxcmci",
+	.id = 0,
+	.dev = {
+		.release = mxc_nop_release,
+		.platform_data = &mmc_data,
+		},
+	.num_resources = ARRAY_SIZE(mxcsdhc1_resources),
+	.resource = mxcsdhc1_resources,
+};
+
+/*! Device Definition for MXC SDHC2 */
+static struct platform_device mxcsdhc2_device = {
+	.name = "mxcmci",
+	.id = 1,
+	.dev = {
+		.release = mxc_nop_release,
+		.platform_data = &mmc_data,
+		},
+	.num_resources = ARRAY_SIZE(mxcsdhc2_resources),
+	.resource = mxcsdhc2_resources,
+};
+
+#ifdef CONFIG_MXC_SDHC3
+/*!
+ * Resource definition for the SDHC3
+ */
+static struct resource mxcsdhc3_resources[] = {
+	[0] = {
+	       .start = SDHC3_BASE_ADDR,
+	       .end = SDHC3_BASE_ADDR + SZ_4K - 1,
+	       .flags = IORESOURCE_MEM,
+	       },
+	[1] = {
+	       .start = INT_SDHC3,
+	       .end = INT_SDHC3,
+	       .flags = IORESOURCE_IRQ,
+	       },
+	[2] = {
+	       .start = 0,
+	       .end = 0,
+	       .flags = IORESOURCE_IRQ,
+	       },
+	[3] = {
+	       .start = MXC_SDIO3_CARD_IRQ,
+	       .end = MXC_SDIO3_CARD_IRQ,
+	       .flags = IORESOURCE_IRQ,
+	       },
+};
+
+/*! Device Definition for MXC SDHC3 */
+static struct platform_device mxcsdhc3_device = {
+	.name = "mxcmci",
+	.id = 2,
+	.dev = {
+		.release = mxc_nop_release,
+		.platform_data = &mmc_data,
+		},
+	.num_resources = ARRAY_SIZE(mxcsdhc3_resources),
+	.resource = mxcsdhc3_resources,
+};
+#endif
+
+static inline void mxc_init_mmc(void)
+{
+	int cd_irq;
+
+	cd_irq = sdhc_init_card_det(0);
+	if (cd_irq) {
+		mxcsdhc1_device.resource[2].start = cd_irq;
+		mxcsdhc1_device.resource[2].end = cd_irq;
+	}
+	cd_irq = sdhc_init_card_det(1);
+	if (cd_irq) {
+		mxcsdhc2_device.resource[2].start = cd_irq;
+		mxcsdhc2_device.resource[2].end = cd_irq;
+	}
+
+	mxc_clks_enable(PERCLK2);
+
+	mxc_clks_enable(SDHC1_CLK);
+	(void)platform_device_register(&mxcsdhc1_device);
+
+	mxc_clks_enable(SDHC2_CLK);
+	(void)platform_device_register(&mxcsdhc2_device);
+
+#ifdef CONFIG_MXC_SDHC3
+	mxc_clks_enable(SDHC3_CLK);
+	(void)platform_device_register(&mxcsdhc3_device);
+#endif
+}
+#else
+static inline void mxc_init_mmc(void)
+{
+}
+#endif
+
+/* SPI controller and device data */
+#if defined(CONFIG_SPI_MXC) || defined(CONFIG_SPI_MXC_MODULE)
+
+#ifdef CONFIG_SPI_MXC_SELECT1
+/*!
+ * Resource definition for the CSPI1
+ */
+static struct resource mxcspi1_resources[] = {
+	[0] = {
+	       .start = CSPI1_BASE_ADDR,
+	       .end = CSPI1_BASE_ADDR + SZ_4K - 1,
+	       .flags = IORESOURCE_MEM,
+	       },
+	[1] = {
+	       .start = INT_CSPI1,
+	       .end = INT_CSPI1,
+	       .flags = IORESOURCE_IRQ,
+	       },
+};
+
+/*! Platform Data for MXC CSPI1 */
+static struct mxc_spi_master mxcspi1_data = {
+	.bus_num = 1,
+	.maxchipselect = 4,
+	.spi_version = 0,
+	.clock = CSPI1_CLK,
+};
+
+/*! Device Definition for MXC CSPI1 */
+static struct platform_device mxcspi1_device = {
+	.name = "mxc_spi",
+	.id = 1,
+	.dev = {
+		.release = mxc_nop_release,
+		.platform_data = &mxcspi1_data,
+		},
+	.num_resources = ARRAY_SIZE(mxcspi1_resources),
+	.resource = mxcspi1_resources,
+};
+
+#endif				/* CONFIG_SPI_MXC_SELECT1 */
+
+#ifdef CONFIG_SPI_MXC_SELECT2
+/*!
+ * Resource definition for the CSPI2
+ */
+static struct resource mxcspi2_resources[] = {
+	[0] = {
+	       .start = CSPI2_BASE_ADDR,
+	       .end = CSPI2_BASE_ADDR + SZ_4K - 1,
+	       .flags = IORESOURCE_MEM,
+	       },
+	[1] = {
+	       .start = INT_CSPI2,
+	       .end = INT_CSPI2,
+	       .flags = IORESOURCE_IRQ,
+	       },
+};
+
+/*! Platform Data for MXC CSPI2 */
+static struct mxc_spi_master mxcspi2_data = {
+	.bus_num = 2,
+	.maxchipselect = 4,
+	.spi_version = 0,
+	.clock = CSPI2_CLK,
+};
+
+/*! Device Definition for MXC CSPI2 */
+static struct platform_device mxcspi2_device = {
+	.name = "mxc_spi",
+	.id = 2,
+	.dev = {
+		.release = mxc_nop_release,
+		.platform_data = &mxcspi2_data,
+		},
+	.num_resources = ARRAY_SIZE(mxcspi2_resources),
+	.resource = mxcspi2_resources,
+};
+#endif				/* CONFIG_SPI_MXC_SELECT2 */
+
+#ifdef CONFIG_SPI_MXC_SELECT3
+/*!
+ * Resource definition for the CSPI3
+ */
+static struct resource mxcspi3_resources[] = {
+	[0] = {
+	       .start = CSPI3_BASE_ADDR,
+	       .end = CSPI3_BASE_ADDR + SZ_4K - 1,
+	       .flags = IORESOURCE_MEM,
+	       },
+	[1] = {
+	       .start = INT_CSPI3,
+	       .end = INT_CSPI3,
+	       .flags = IORESOURCE_IRQ,
+	       },
+};
+
+/*! Platform Data for MXC CSPI3 */
+static struct mxc_spi_master mxcspi3_data = {
+	.bus_num = 3,
+	.maxchipselect = 4,
+	.spi_version = 0,
+	.clock = CSPI3_CLK,
+};
+
+/*! Device Definition for MXC CSPI3 */
+static struct platform_device mxcspi3_device = {
+	.name = "mxc_spi",
+	.id = 3,
+	.dev = {
+		.release = mxc_nop_release,
+		.platform_data = &mxcspi3_data,
+		},
+	.num_resources = ARRAY_SIZE(mxcspi3_resources),
+	.resource = mxcspi3_resources,
+};
+#endif				/* CONFIG_SPI_MXC_SELECT3 */
+
+static inline void mxc_init_spi(void)
+{
+#ifdef CONFIG_SPI_MXC_SELECT1
+	if (platform_device_register(&mxcspi1_device) < 0)
+		printk("Error: Registering the SPI Controller_1\n");
+#endif				/* CONFIG_SPI_MXC_SELECT1 */
+#ifdef CONFIG_SPI_MXC_SELECT2
+	if (platform_device_register(&mxcspi2_device) < 0)
+		printk("Error: Registering the SPI Controller_2\n");
+#endif				/* CONFIG_SPI_MXC_SELECT2 */
+#ifdef CONFIG_SPI_MXC_SELECT3
+	if (platform_device_register(&mxcspi3_device) < 0)
+		printk("Error: Registering the SPI Controller_3\n");
+#endif				/* CONFIG_SPI_MXC_SELECT3 */
+}
+#else
+static inline void mxc_init_spi(void)
+{
+}
+#endif
+
+#ifdef	CONFIG_MXC_VPU
+/*! Platform Data for MXC VPU */
+static struct platform_device mxcvpu_device = {
+	.name = "mxc_vpu",
+	.dev = {
+		.release = mxc_nop_release,
+		},
+	.id = 0,
+};
+
+static inline void mxc_init_vpu(void)
+{
+	if (platform_device_register(&mxcvpu_device) < 0)
+		printk(KERN_ERR "Error: Registering the VPU.\n");
+}
+#else
+static inline void mxc_init_vpu(void)
+{
+}
+#endif
+
+#ifdef  CONFIG_MXC_IRDA
+/*
+ * Resource definition for the MXC IrDA
+ */
+static struct resource mxcirda_resources[] = {
+	[0] = {
+		.start	= UART3_BASE_ADDR,
+		.end	= UART3_BASE_ADDR + SZ_4K - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= INT_UART3,
+		.end	= INT_UART3,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+/* Platform Data for MXC IrDA */
+static struct platform_device mxcirda_device = {
+	.name = "mxc_irda",
+	.dev = {
+		.release = mxc_nop_release,
+	},
+	.id = 0,
+	.num_resources = ARRAY_SIZE(mxcirda_resources),
+	.resource = mxcirda_resources,
+};
+
+static inline void mxc_init_irda(void)
+{
+	if (platform_device_register(&mxcirda_device) < 0)
+		printk(KERN_ERR "Error: Registering the MXC IrDA.\n");
+	printk("IrDA: MXC IrDA registered\n");
+}
+#else
+static inline void mxc_init_irda(void)
+{
+}
+#endif
+
+struct mxc_gpio_port mxc_gpio_ports[GPIO_PORT_NUM] = {
+	{
+	 .num = 0,
+	 .base = IO_ADDRESS(GPIO_BASE_ADDR),
+	 .irq = INT_GPIO,
+	 .virtual_irq_start = MXC_GPIO_INT_BASE,
+	 },
+	{
+	 .num = 1,
+	 .base = IO_ADDRESS(GPIO_BASE_ADDR) + 0x100,
+	 .irq = INT_GPIO,
+	 .virtual_irq_start = MXC_GPIO_INT_BASE + GPIO_NUM_PIN,
+	 },
+	{
+	 .num = 2,
+	 .base = IO_ADDRESS(GPIO_BASE_ADDR) + 0x200,
+	 .irq = INT_GPIO,
+	 .virtual_irq_start = MXC_GPIO_INT_BASE + GPIO_NUM_PIN * 2,
+	 },
+	{
+	 .num = 3,
+	 .base = IO_ADDRESS(GPIO_BASE_ADDR) + 0x300,
+	 .irq = INT_GPIO,
+	 .virtual_irq_start = MXC_GPIO_INT_BASE + GPIO_NUM_PIN * 3,
+	 },
+	{
+	 .num = 4,
+	 .base = IO_ADDRESS(GPIO_BASE_ADDR) + 0x400,
+	 .irq = INT_GPIO,
+	 .virtual_irq_start = MXC_GPIO_INT_BASE + GPIO_NUM_PIN * 4,
+	 },
+	{
+	 .num = 5,
+	 .base = IO_ADDRESS(GPIO_BASE_ADDR) + 0x500,
+	 .irq = INT_GPIO,
+	 .virtual_irq_start = MXC_GPIO_INT_BASE + GPIO_NUM_PIN * 5,
+	 },
+};
+
+static int __init mxc_init_devices(void)
+{
+	mxc_init_wdt();
+	mxc_init_mmc();
+	mxc_init_spi();
+	mxc_init_rtc();
+	mxc_init_owire();
+	mxc_init_vpu();
+	mxc_init_irda();
+	return 0;
+}
+
+arch_initcall(mxc_init_devices);
diff --git a/arch/arm/mach-mx27/dma.c b/arch/arm/mach-mx27/dma.c
new file mode 100644
index 0000000..e60f0f0
--- /dev/null
+++ b/arch/arm/mach-mx27/dma.c
@@ -0,0 +1,536 @@
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ *@file dma.c
+ *@brief This file contains the dma parameter which is depend on the platform  .
+ * @ingroup DMA
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <asm/dma.h>
+
+/*!
+ * @brief  the structure stored device_id and dma_info pointer
+ */
+typedef struct dma_info_entry_s {
+	mxc_dma_device_t device;
+	/* if there are two dma_info , first is for reading, another is for writing */
+	mx2_dma_info_t *info;
+} dma_info_entry_t;
+
+/*!
+ * @brief dma_info from memory to memory for dma testing
+ */
+static mx2_dma_info_t ram2ram_dma_info = {
+	.dma_chan = MXC_DMA_DYNAMIC_CHANNEL,
+	.mode = 0,
+	.rto_en = 0,
+	.dir = 0,
+	.dma_chaining = 0,.ren = 0,
+	.burstLength = 4,.request = 0,.busuntils = 0,
+	.sourceType = DMA_TYPE_LINEAR,.sourcePort = TRANSFER_32BIT,
+	.destType = DMA_TYPE_LINEAR,.destPort = TRANSFER_32BIT,
+	.M2D_Valid = 0
+};
+
+/*!
+ * @brief dma_info from 2D memory to 2D memory for dma testing
+ */
+static mx2_dma_info_t ram2d2ram2d_dma_info = {
+	.dma_chan = MXC_DMA_DYNAMIC_CHANNEL,
+	.mode = 0,
+	.rto_en = 0,
+	.dir = 0,
+	.rto_en = 0,
+	.dma_chaining = 0,.ren = 0,
+	.burstLength = 4,.request = 0,.busuntils = 0,
+	.sourceType = DMA_TYPE_2D,.sourcePort = TRANSFER_32BIT,
+	.destType = DMA_TYPE_2D,.destPort = TRANSFER_32BIT,
+	.M2D_Valid = 1,.msel = 0,.W = 0x80,.X = 0x40,.Y = 0x10
+};
+
+/*!
+ * @brief dma_info from memory to 2D memory for dma testing
+ */
+static mx2_dma_info_t ram2ram2d_dma_info = {
+	.dma_chan = MXC_DMA_DYNAMIC_CHANNEL,
+	.mode = 0,
+	.rto_en = 0,
+	.dir = 0,
+	.dma_chaining = 0,.ren = 0,
+	.burstLength = 4,.request = 0,.busuntils = 0,
+	.sourceType = DMA_TYPE_LINEAR,.sourcePort = TRANSFER_32BIT,
+	.destType = DMA_TYPE_2D,.destPort = TRANSFER_32BIT,
+	.M2D_Valid = 1,.msel = 0,.W = 0x100,.X = 0x80,.Y = 0x10
+};
+
+/*!
+ * @brief dma_info from 2D memory to memory for dma testing
+ */
+static mx2_dma_info_t ram2d2ram_dma_info = {
+	.dma_chan = MXC_DMA_DYNAMIC_CHANNEL,
+	.mode = 0,
+	.rto_en = 0,
+	.dir = 0,
+	.dma_chaining = 0,.ren = 0,
+	.burstLength = 4,.request = 0,.busuntils = 0,
+	.sourceType = DMA_TYPE_2D,.sourcePort = TRANSFER_32BIT,
+	.destType = DMA_TYPE_LINEAR,.destPort = TRANSFER_32BIT,
+	.M2D_Valid = 1,.msel = 0,.W = 0x100,.X = 0x100,.Y = 0x10
+};
+
+/*!
+ * @brief dma_info with dma chaining feature for dma testing
+ */
+static mx2_dma_info_t hw_chaining_dma_info = {
+	.dma_chan = MXC_DMA_DYNAMIC_CHANNEL,
+	.mode = 0,
+	.rto_en = 0,
+	.dir = 0,
+	.dma_chaining = 1,.ren = 0,
+	.burstLength = 4,.request = 0,.busuntils = 0,
+	.sourceType = DMA_TYPE_LINEAR,.sourcePort = TRANSFER_32BIT,
+	.destType = DMA_TYPE_LINEAR,.destPort = TRANSFER_32BIT,
+	.M2D_Valid = 0,
+};
+
+/*!
+ * @brief dma_info without dma chaining feature for dma testing
+ */
+static mx2_dma_info_t sw_chaining_dma_info = {
+	.dma_chan = MXC_DMA_DYNAMIC_CHANNEL,
+	.mode = 0,
+	.rto_en = 0,
+	.dir = 0,
+	.dma_chaining = 0,.ren = 0,
+	.burstLength = 4,.request = 0,.busuntils = 0,
+	.sourceType = DMA_TYPE_LINEAR,.sourcePort = TRANSFER_32BIT,
+	.destType = DMA_TYPE_LINEAR,.destPort = TRANSFER_32BIT,
+	.M2D_Valid = 0,
+};
+
+/*!
+ * @brief dma_info for ATA recieveing
+ */
+static mx2_dma_info_t ata_rx_dma_info = {
+	.dma_chan = MXC_DMA_DYNAMIC_CHANNEL,
+	.mode = 0,
+	.rto_en = 0,
+	.dir = 0,
+	.dma_chaining = 0,.ren = 1,
+	.burstLength = 32,.request = 29,.busuntils = 0,
+	.sourceType = DMA_TYPE_FIFO,.sourcePort = TRANSFER_32BIT,
+	.destType = DMA_TYPE_LINEAR,.destPort = TRANSFER_32BIT,
+	.per_address = (ATA_BASE_ADDR + 0x18),
+	.M2D_Valid = 0,
+};
+
+/*!
+ * @brief: dma_info for ATA transmitting
+ */
+static mx2_dma_info_t ata_tx_dma_info = {
+	.dma_chan = MXC_DMA_DYNAMIC_CHANNEL,
+	.mode = 1,
+	.rto_en = 0,
+	.dir = 0,
+	.dma_chaining = 0,.ren = 1,
+	.burstLength = 32,.request = 28,.busuntils = 0,
+	.sourceType = DMA_TYPE_FIFO,.sourcePort = TRANSFER_32BIT,
+	.destType = DMA_TYPE_LINEAR,.destPort = TRANSFER_32BIT,
+	.per_address = (ATA_BASE_ADDR + 0x18),
+	.M2D_Valid = 0,
+};
+
+/*!
+ * @brief dma_info for UART1 recieveing
+ */
+static mx2_dma_info_t uart1_rx_dma_info = {
+	.dma_chan = MXC_DMA_DYNAMIC_CHANNEL,
+	.mode = 0,
+	.rto_en = 1,
+	.dir = 0,
+	.dma_chaining = 0,.ren = 1,
+	.burstLength = 1,.request = 26,.busuntils = 8,
+	.sourceType = DMA_TYPE_FIFO,.sourcePort = TRANSFER_8BIT,
+	.destType = DMA_TYPE_LINEAR,.destPort = TRANSFER_8BIT,
+	.per_address = (UART1_BASE_ADDR),
+	.M2D_Valid = 0,
+};
+
+/*!
+ * @brief: dma_info for UART1 transmitting
+ */
+static mx2_dma_info_t uart1_tx_dma_info = {
+	.dma_chan = MXC_DMA_DYNAMIC_CHANNEL,
+	.mode = 1,
+	.rto_en = 0,
+	.dir = 0,
+	.dma_chaining = 0,.ren = 1,
+	.burstLength = 1,.request = 27,.busuntils = 0,
+	.sourceType = DMA_TYPE_FIFO,.sourcePort = TRANSFER_8BIT,
+	.destType = DMA_TYPE_LINEAR,.destPort = TRANSFER_8BIT,
+	.per_address = (UART1_BASE_ADDR + 0x40),
+	.M2D_Valid = 0,
+};
+
+/*!
+ * @brief dma_info for UART2 recieveing
+ */
+static mx2_dma_info_t uart2_rx_dma_info = {
+	.dma_chan = MXC_DMA_DYNAMIC_CHANNEL,
+	.mode = 0,
+	.rto_en = 0,
+	.dir = 0,
+	.dma_chaining = 0,.ren = 1,
+	.burstLength = 1,.request = 24,.busuntils = 0,
+	.sourceType = DMA_TYPE_FIFO,.sourcePort = TRANSFER_8BIT,
+	.destType = DMA_TYPE_LINEAR,.destPort = TRANSFER_8BIT,
+	.per_address = (UART2_BASE_ADDR),
+	.M2D_Valid = 0,
+};
+
+/*!
+ * @brief: dma_info for UART2 transmitting
+ */
+static mx2_dma_info_t uart2_tx_dma_info = {
+	.dma_chan = MXC_DMA_DYNAMIC_CHANNEL,
+	.mode = 1,
+	.rto_en = 0,
+	.dir = 0,
+	.dma_chaining = 0,.ren = 1,
+	.burstLength = 1,.request = 25,.busuntils = 0,
+	.sourceType = DMA_TYPE_FIFO,.sourcePort = TRANSFER_8BIT,
+	.destType = DMA_TYPE_LINEAR,.destPort = TRANSFER_8BIT,
+	.per_address = (UART2_BASE_ADDR + 0x40),
+	.M2D_Valid = 0,
+};
+
+/*!
+ * @brief dma_info for UART3 recieveing
+ */
+static mx2_dma_info_t uart3_rx_dma_info = {
+	.dma_chan = MXC_DMA_DYNAMIC_CHANNEL,
+	.mode = 0,
+	.rto_en = 0,
+	.dir = 0,
+	.dma_chaining = 0,.ren = 1,
+	.burstLength = 1,.request = 22,.busuntils = 0,
+	.sourceType = DMA_TYPE_FIFO,.sourcePort = TRANSFER_8BIT,
+	.destType = DMA_TYPE_LINEAR,.destPort = TRANSFER_8BIT,
+	.per_address = (UART3_BASE_ADDR),
+	.M2D_Valid = 0,
+};
+
+/*!
+ * @brief: dma_info for UART3 transmitting
+ */
+static mx2_dma_info_t uart3_tx_dma_info = {
+	.dma_chan = MXC_DMA_DYNAMIC_CHANNEL,
+	.mode = 1,
+	.rto_en = 0,
+	.dir = 0,
+	.dma_chaining = 0,.ren = 1,
+	.burstLength = 1,.request = 23,.busuntils = 0,
+	.sourceType = DMA_TYPE_FIFO,.sourcePort = TRANSFER_8BIT,
+	.destType = DMA_TYPE_LINEAR,.destPort = TRANSFER_8BIT,
+	.per_address = (UART3_BASE_ADDR + 0x40),
+	.M2D_Valid = 0,
+};
+
+/*!
+ * @brief dma_info for UART4 recieveing
+ */
+static mx2_dma_info_t uart4_rx_dma_info = {
+	.dma_chan = MXC_DMA_DYNAMIC_CHANNEL,
+	.mode = 0,
+	.rto_en = 0,
+	.dir = 0,
+	.dma_chaining = 0,.ren = 1,
+	.burstLength = 1,.request = 20,.busuntils = 0,
+	.sourceType = DMA_TYPE_FIFO,.sourcePort = TRANSFER_8BIT,
+	.destType = DMA_TYPE_LINEAR,.destPort = TRANSFER_8BIT,
+	.per_address = (UART4_BASE_ADDR),
+	.M2D_Valid = 0,
+};
+
+/*!
+ * @brief: dma_info for UART4transmitting
+ */
+static mx2_dma_info_t uart4_tx_dma_info = {
+	.dma_chan = MXC_DMA_DYNAMIC_CHANNEL,
+	.mode = 1,
+	.rto_en = 0,
+	.dir = 0,
+	.dma_chaining = 0,.ren = 1,
+	.burstLength = 1,.request = 21,.busuntils = 0,
+	.sourceType = DMA_TYPE_FIFO,.sourcePort = TRANSFER_8BIT,
+	.destType = DMA_TYPE_LINEAR,.destPort = TRANSFER_8BIT,
+	.per_address = (UART4_BASE_ADDR + 0x40),
+	.M2D_Valid = 0,
+};
+
+/*!
+ * @brief dma_info for UART5 recieveing
+ */
+static mx2_dma_info_t uart5_rx_dma_info = {
+	.dma_chan = MXC_DMA_DYNAMIC_CHANNEL,
+	.mode = 0,
+	.rto_en = 0,
+	.dir = 0,
+	.dma_chaining = 0,.ren = 1,
+	.burstLength = 1,.request = 32,.busuntils = 0,
+	.sourceType = DMA_TYPE_FIFO,.sourcePort = TRANSFER_8BIT,
+	.destType = DMA_TYPE_LINEAR,.destPort = TRANSFER_8BIT,
+	.per_address = (UART5_BASE_ADDR),
+	.M2D_Valid = 0,
+};
+
+/*!
+ * @brief: dma_info for UART5 transmitting
+ */
+static mx2_dma_info_t uart5_tx_dma_info = {
+	.dma_chan = MXC_DMA_DYNAMIC_CHANNEL,
+	.mode = 1,
+	.rto_en = 0,
+	.dir = 0,
+	.dma_chaining = 0,.ren = 1,
+	.burstLength = 1,.request = 33,.busuntils = 0,
+	.sourceType = DMA_TYPE_FIFO,.sourcePort = TRANSFER_8BIT,
+	.destType = DMA_TYPE_LINEAR,.destPort = TRANSFER_8BIT,
+	.per_address = (UART5_BASE_ADDR + 0x40),
+	.M2D_Valid = 0,
+};
+
+/*!
+ * @brief dma_info for UART6 recieveing
+ */
+static mx2_dma_info_t uart6_rx_dma_info = {
+	.dma_chan = MXC_DMA_DYNAMIC_CHANNEL,
+	.mode = 0,
+	.rto_en = 0,
+	.dir = 0,
+	.dma_chaining = 0,.ren = 1,
+	.burstLength = 1,.request = 34,.busuntils = 0,
+	.sourceType = DMA_TYPE_FIFO,.sourcePort = TRANSFER_8BIT,
+	.destType = DMA_TYPE_LINEAR,.destPort = TRANSFER_8BIT,
+	.per_address = (UART6_BASE_ADDR),
+	.M2D_Valid = 0,
+};
+
+/*!
+ * @brief: dma_info for UART6 transmitting
+ */
+static mx2_dma_info_t uart6_tx_dma_info = {
+	.dma_chan = MXC_DMA_DYNAMIC_CHANNEL,
+	.mode = 1,
+	.rto_en = 0,
+	.dir = 0,
+	.dma_chaining = 0,.ren = 1,
+	.burstLength = 1,.request = 35,.busuntils = 0,
+	.sourceType = DMA_TYPE_FIFO,.sourcePort = TRANSFER_8BIT,
+	.destType = DMA_TYPE_LINEAR,.destPort = TRANSFER_8BIT,
+	.per_address = (UART6_BASE_ADDR + 0x40),
+	.M2D_Valid = 0,
+};
+
+static mx2_dma_info_t ssi1_16bit_rx0_dma_info = {
+	.dma_chan = MXC_DMA_DYNAMIC_CHANNEL,
+	.mode = 0,
+	.rto_en = 0,
+	.dir = 0,
+	.dma_chaining = MXC_SOUND_CAPTURE_CHAIN_DMA,.ren = 1,
+	.burstLength = 8,.request = DMA_REQ_SSI1_RX0,.busuntils = 0,
+	.sourceType = DMA_TYPE_FIFO,.sourcePort = DMA_MEM_SIZE_16,
+	.destType = DMA_TYPE_LINEAR,.destPort = DMA_MEM_SIZE_32,
+	.per_address = (SSI1_BASE_ADDR + 0x08),
+	.M2D_Valid = 0,
+};
+
+static mx2_dma_info_t ssi1_16bit_tx0_dma_info = {
+	.dma_chan = MXC_DMA_DYNAMIC_CHANNEL,
+	.mode = 1,
+	.rto_en = 0,
+	.dir = 0,
+	.dma_chaining = MXC_SOUND_PLAYBACK_CHAIN_DMA,.ren = 1,
+	.burstLength = 8,.request = DMA_REQ_SSI1_TX0,.busuntils = 0,
+	.sourceType = DMA_TYPE_FIFO,.sourcePort = DMA_MEM_SIZE_16,
+	.destType = DMA_TYPE_LINEAR,.destPort = DMA_MEM_SIZE_32,
+	.per_address = (SSI1_BASE_ADDR),
+	.M2D_Valid = 0,
+};
+
+static mx2_dma_info_t ssi2_16bit_rx0_dma_info = {
+	.dma_chan = MXC_DMA_DYNAMIC_CHANNEL,
+	.mode = 0,
+	.rto_en = 0,
+	.dir = 0,
+	.dma_chaining = MXC_SOUND_CAPTURE_CHAIN_DMA,.ren = 1,
+	.burstLength = 8,.request = DMA_REQ_SSI2_RX0,.busuntils = 0,
+	.sourceType = DMA_TYPE_FIFO,.sourcePort = DMA_MEM_SIZE_16,
+	.destType = DMA_TYPE_LINEAR,.destPort = DMA_MEM_SIZE_32,
+	.per_address = (SSI2_BASE_ADDR + 0x08),
+	.M2D_Valid = 0,
+};
+
+static mx2_dma_info_t ssi2_16bit_tx0_dma_info = {
+	.dma_chan = MXC_DMA_DYNAMIC_CHANNEL,
+	.mode = 1,
+	.rto_en = 0,
+	.dir = 0,
+	.dma_chaining = MXC_SOUND_PLAYBACK_CHAIN_DMA,.ren = 1,
+	.burstLength = 8,.request = DMA_REQ_SSI2_TX0,.busuntils = 0,
+	.sourceType = DMA_TYPE_FIFO,.sourcePort = DMA_MEM_SIZE_16,
+	.destType = DMA_TYPE_LINEAR,.destPort = DMA_MEM_SIZE_32,
+	.per_address = (SSI2_BASE_ADDR),
+	.M2D_Valid = 0,
+};
+
+static mx2_dma_info_t mmc1_width1_dma_info = {
+	.dma_chan = MXC_DMA_DYNAMIC_CHANNEL,
+	.mode = 0,
+	.rto_en = 0,
+	.dir = 0,
+	.dma_chaining = 0,.ren = 1,
+	.burstLength = 16,.request = DMA_REQ_SDHC1,.busuntils = 0,
+	.sourceType = DMA_TYPE_FIFO,.sourcePort = DMA_MEM_SIZE_32,
+	.destType = DMA_TYPE_LINEAR,.destPort = DMA_MEM_SIZE_32,
+	.per_address = (SDHC1_BASE_ADDR + 0x38),
+	.M2D_Valid = 0,
+};
+
+static mx2_dma_info_t mmc1_width4_dma_info = {
+	.dma_chan = MXC_DMA_DYNAMIC_CHANNEL,
+	.mode = 0,
+	.rto_en = 0,
+	.dir = 0,
+	.dma_chaining = 0,.ren = 1,
+	.burstLength = 0,.request = DMA_REQ_SDHC1,.busuntils = 0,
+	.sourceType = DMA_TYPE_FIFO,.sourcePort = DMA_MEM_SIZE_32,
+	.destType = DMA_TYPE_LINEAR,.destPort = DMA_MEM_SIZE_32,
+	.per_address = (SDHC1_BASE_ADDR + 0x38),
+	.M2D_Valid = 0,
+};
+
+static mx2_dma_info_t mmc2_width1_dma_info = {
+	.dma_chan = MXC_DMA_DYNAMIC_CHANNEL,
+	.mode = 0,
+	.rto_en = 0,
+	.dir = 0,
+	.dma_chaining = 0,.ren = 1,
+	.burstLength = 16,.request = DMA_REQ_SDHC2,.busuntils = 0,
+	.sourceType = DMA_TYPE_FIFO,.sourcePort = DMA_MEM_SIZE_32,
+	.destType = DMA_TYPE_LINEAR,.destPort = DMA_MEM_SIZE_32,
+	.per_address = (SDHC2_BASE_ADDR + 0x38),
+	.M2D_Valid = 0,
+};
+
+static mx2_dma_info_t mmc2_width4_dma_info = {
+	.dma_chan = MXC_DMA_DYNAMIC_CHANNEL,
+	.mode = 0,
+	.rto_en = 0,
+	.dir = 0,
+	.dma_chaining = 0,.ren = 1,
+	.burstLength = 0,.request = DMA_REQ_SDHC2,.busuntils = 0,
+	.sourceType = DMA_TYPE_FIFO,.sourcePort = DMA_MEM_SIZE_32,
+	.destType = DMA_TYPE_LINEAR,.destPort = DMA_MEM_SIZE_32,
+	.per_address = (SDHC2_BASE_ADDR + 0x38),
+	.M2D_Valid = 0,
+};
+
+/*!
+ * @brief dma info array which is actived
+ *    DEVICE_ID  RX/(RX&TX)	TX
+ */
+static dma_info_entry_t active_dma_info[] = {
+	{MXC_DMA_TEST_RAM2RAM, &ram2ram_dma_info},
+	{MXC_DMA_TEST_RAM2D2RAM2D, &ram2d2ram2d_dma_info},
+	{MXC_DMA_TEST_RAM2RAM2D, &ram2ram2d_dma_info},
+	{MXC_DMA_TEST_RAM2D2RAM, &ram2d2ram_dma_info},
+	{MXC_DMA_TEST_HW_CHAINING, &hw_chaining_dma_info},
+	{MXC_DMA_TEST_SW_CHAINING, &sw_chaining_dma_info},
+	{MXC_DMA_ATA_RX, &ata_rx_dma_info},
+	{MXC_DMA_ATA_TX, &ata_tx_dma_info},
+	{MXC_DMA_UART1_RX, &uart1_rx_dma_info},
+	{MXC_DMA_UART1_TX, &uart1_tx_dma_info},
+	{MXC_DMA_UART2_RX, &uart2_rx_dma_info},
+	{MXC_DMA_UART2_TX, &uart2_tx_dma_info},
+	{MXC_DMA_UART3_RX, &uart3_rx_dma_info},
+	{MXC_DMA_UART3_TX, &uart3_tx_dma_info},
+	{MXC_DMA_UART4_RX, &uart4_rx_dma_info},
+	{MXC_DMA_UART4_TX, &uart4_tx_dma_info},
+	{MXC_DMA_UART5_RX, &uart5_rx_dma_info},
+	{MXC_DMA_UART5_TX, &uart5_tx_dma_info},
+	{MXC_DMA_UART6_RX, &uart6_rx_dma_info},
+	{MXC_DMA_UART6_TX, &uart6_tx_dma_info},
+	{MXC_DMA_SSI1_16BIT_RX0, &ssi1_16bit_rx0_dma_info},
+	{MXC_DMA_SSI1_16BIT_TX0, &ssi1_16bit_tx0_dma_info},
+	{MXC_DMA_SSI2_16BIT_RX0, &ssi2_16bit_rx0_dma_info},
+	{MXC_DMA_SSI2_16BIT_TX0, &ssi2_16bit_tx0_dma_info},
+	{MXC_DMA_MMC1_WIDTH_1, &mmc1_width1_dma_info},
+	{MXC_DMA_MMC1_WIDTH_4, &mmc1_width4_dma_info},
+	{MXC_DMA_MMC2_WIDTH_1, &mmc2_width1_dma_info},
+	{MXC_DMA_MMC2_WIDTH_4, &mmc2_width4_dma_info},
+};
+
+/*!
+ * @brief the number of actived dma info
+ */
+static int dma_info_entrys =
+    sizeof(active_dma_info) / sizeof(active_dma_info[0]);
+
+/*!
+ * @brief get the dma info by channel_id
+ */
+mx2_dma_info_t *mxc_dma_get_info(mxc_dma_device_t channel_id)
+{
+	dma_info_entry_t *p = active_dma_info;
+	int i;
+	for (i = 0; i < dma_info_entrys; i++, p++) {
+		if (p->device == channel_id)
+			return p->info;
+	}
+	return NULL;
+}
+
+/*!
+ * @brief: scan dma parameter list . And collect information about which channels are dynamic .
+ */
+void mxc_dma_load_info(mxc_dma_channel_t * dma)
+{
+	int i, idx;
+	dma_info_entry_t *p = active_dma_info;
+
+	BUG_ON(dma == NULL);
+	BUG_ON(p == NULL);
+
+	for (i = 0; i < MXC_DMA_CHANNELS; i++) {
+		dma[i].dynamic = 1;
+	}
+
+	for (i = 0; i < dma_info_entrys; i++, p++) {
+		BUG_ON((p->info == NULL));
+
+		idx = p->info->dma_chan;
+
+		BUG_ON(((idx >= MAX_DMA_CHANNELS)
+			&& (idx != MXC_DMA_DYNAMIC_CHANNEL)));
+		if ((idx < 0) || (idx == MXC_DMA_DYNAMIC_CHANNEL))
+			continue;
+		dma[idx].dynamic = 0;
+	}
+}
+
+EXPORT_SYMBOL(mxc_dma_get_info);
+EXPORT_SYMBOL(mxc_dma_load_info);
diff --git a/arch/arm/mach-mx27/gpio_mux.c b/arch/arm/mach-mx27/gpio_mux.c
new file mode 100644
index 0000000..f10c871
--- /dev/null
+++ b/arch/arm/mach-mx27/gpio_mux.c
@@ -0,0 +1,302 @@
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ *@file gpio_mux.c
+ *@brief This file contains the IOMUX implementation details.
+ * @ingroup GPIO
+ */
+
+#include <linux/kernel.h>
+#include <linux/cache.h>
+#include <linux/spinlock.h>
+
+#include <asm/io.h>
+#include <asm/hardware.h>
+#include <asm/arch/gpio.h>
+#include "gpio_mux.h"
+
+/*!
+ * This structure defines the offset of registers in gpio module.
+ */
+enum gpio_reg {
+	GPIO_GIUS = 0x20,
+	GPIO_GPR = 0x38,
+	GPIO_PUEN = 0x40,
+	GPIO_DDIR = 0x00,
+	GPIO_OCR1 = 0x04,
+	GPIO_OCR2 = 0x08,
+	GPIO_ICONFA1 = 0x0C,
+	GPIO_ICONFA2 = 0x10,
+	GPIO_ICONFB1 = 0x14,
+	GPIO_ICONFB2 = 0x18,
+};
+
+/*!
+ * This enumeration data type defines the configuration for input mode.
+ */
+typedef enum {
+	GPIO_INPUT_GPIO = 0x00,
+	GPIO_INPUT_INTR = 0x01,
+	GPIO_INPUT_LOW = 0x02,
+	GPIO_INPUT_HIGH = 0x03
+} gpio_input_cfg_t;
+
+/*!
+ * This enumeration data type defines the configuration for output mode.
+ */
+typedef enum {
+	GPIO_OUTPUT_A = 0x00,
+	GPIO_OUTPUT_B = 0x01,
+	GPIO_OUTPUT_C = 0x02,
+	GPIO_OUTPUT_DR = 0x03
+} gpio_output_cfg_t;
+
+extern struct mxc_gpio_port mxc_gpio_ports[];
+
+/*!
+ * defines a spinlock to protected the accessing to gpio pin.
+ */
+DEFINE_SPINLOCK(gpio_mux_lock);
+
+/*!
+ * This function enable or disable the pullup feature to the pin.
+ * @param port  	a pointer of gpio port
+ * @param index 	the index of the  pin in the port
+ * @param en		0 if disable pullup, otherwise enable it.
+ * @return		none
+ */
+static inline void _gpio_set_puen(struct mxc_gpio_port *port, u32 index,
+				  bool en)
+{
+	u32 reg;
+
+	reg = __raw_readl(port->base + GPIO_PUEN);
+	if (en) {
+		reg |= 1 << index;
+	} else {
+		reg &= ~(1 << index);
+	}
+	__raw_writel(reg, port->base + GPIO_PUEN);
+}
+
+/*!
+ * This function set the input configuration A.
+ * @param port  	a pointer of gpio port
+ * @param index 	the index of the  pin in the port
+ * @param config	a mode as define in \b #gpio_input_cfg_t
+ * @return		none
+ */
+static inline void _gpio_set_iconfa(struct mxc_gpio_port *port, u32 index,
+				    gpio_input_cfg_t config)
+{
+	u32 reg, val;
+	u32 mask;
+
+	mask = 0x3 << ((index % 16) << 1);
+
+	if (index >= 16) {
+		reg = port->base + GPIO_ICONFA2;
+		val = config << ((index - 16) * 2);
+	} else {
+		reg = port->base + GPIO_ICONFA1;
+		val = config << (index * 2);
+	}
+	val |= __raw_readl(reg) & ~(mask);
+	__raw_writel(val, reg);
+}
+
+/*!
+ * This function set the input configuration B.
+ * @param port  	a pointer of gpio port
+ * @param index 	the index of the  pin in the port
+ * @param config	a mode as define in \b #gpio_input_cfg_t
+ * @return		none
+ */
+static inline void _gpio_set_iconfb(struct mxc_gpio_port *port, u32 index,
+				    gpio_input_cfg_t config)
+{
+	u32 reg, val;
+	u32 mask;
+
+	mask = 0x3 << ((index % 16) << 1);
+
+	if (index >= 16) {
+		reg = port->base + GPIO_ICONFB2;
+		val = config << ((index - 16) * 2);
+	} else {
+		reg = port->base + GPIO_ICONFB1;
+		val = config << (index * 2);
+	}
+	val |= __raw_readl(reg) & (~mask);
+	__raw_writel(val, reg);
+}
+
+/*!
+ * This function set the output configuration.
+ * @param port  	a pointer of gpio port
+ * @param index 	the index of the  pin in the port
+ * @param config	a mode as define in \b #gpio_output_cfg_t
+ * @return		none
+ */
+static inline void _gpio_set_ocr(struct mxc_gpio_port *port, u32 index,
+				 gpio_output_cfg_t config)
+{
+	u32 reg, val;
+	u32 mask;
+
+	mask = 0x3 << ((index % 16) << 1);
+	if (index >= 16) {
+		reg = port->base + GPIO_OCR2;
+		val = config << ((index - 16) * 2);
+	} else {
+		reg = port->base + GPIO_OCR1;
+		val = config << (index * 2);
+	}
+	val |= __raw_readl(reg) & (~mask);
+	__raw_writel(val, reg);
+}
+
+/*!
+ *@brief gpio_config_mux - just configure the mode of the gpio pin.
+ *@param pin   a pin number as defined in \b #iomux_pin_name_t
+ *@param mode  a module as define in \b #gpio_mux_mode_t;
+ *	GPIO_MUX_PRIMARY set pin to work as primary function.
+ *	GPIO_MUX_ALT set pin to work as alternate function.
+ *	GPIO_MUX_GPIO set pin to work as output function based the data register
+ *	GPIO_MUX_INPUT1 set pin to work as input function connected with  A_OUT
+ *	GPIO_MUX_INPUT2 set pin to work as input function connected with B_OUT
+ *	GPIO_MUX_OUTPUT1 set pin to work as output function connected with A_IN
+ *	GPIO_MUX_OUTPUT2 set pin to work as output function connected with B_IN
+ *	GPIO_MUX_OUTPUT3 set pin to work as output function connected with C_IN
+ *@return      0 if successful, Non-zero otherwise
+ */
+
+int gpio_config_mux(iomux_pin_name_t pin, gpio_mux_mode_t mode)
+{
+	unsigned long lock_flags;
+	u32 gius_reg, gpr_reg;
+	struct mxc_gpio_port *port;
+	u32 index, gpio = IOMUX_TO_GPIO(pin);
+
+	port = &(mxc_gpio_ports[GPIO_TO_PORT(gpio)]);
+	index = GPIO_TO_INDEX(gpio);
+
+	pr_debug("%s: Configuring PORT %c, bit %d\n",
+		 __FUNCTION__, port->num + 'A', index);
+
+	spin_lock_irqsave(&gpio_mux_lock, lock_flags);
+
+	gius_reg = __raw_readl(port->base + GPIO_GIUS);
+	gpr_reg = __raw_readl(port->base + GPIO_GPR);
+
+	switch (mode) {
+	case GPIO_MUX_PRIMARY:
+		gius_reg &= ~(1L << index);
+		gpr_reg &= ~(1L << index);
+		break;
+	case GPIO_MUX_ALT:
+		gius_reg &= ~(1L << index);
+		gpr_reg |= (1L << index);
+		break;
+	case GPIO_MUX_GPIO:
+		gius_reg |= (1L << index);
+		_gpio_set_ocr(port, index, GPIO_OUTPUT_DR);
+		break;
+	case GPIO_MUX_INPUT1:
+		gius_reg |= (1L << index);
+		_gpio_set_iconfa(port, index, GPIO_INPUT_GPIO);
+		break;
+	case GPIO_MUX_INPUT2:
+		gius_reg |= (1L << index);
+		_gpio_set_iconfb(port, index, GPIO_INPUT_GPIO);
+		break;
+	case GPIO_MUX_OUTPUT1:
+		gius_reg |= (1L << index);
+		_gpio_set_ocr(port, index, GPIO_OUTPUT_A);
+		break;
+	case GPIO_MUX_OUTPUT2:
+		gius_reg |= (1L << index);
+		_gpio_set_ocr(port, index, GPIO_OUTPUT_B);
+		break;
+	case GPIO_MUX_OUTPUT3:
+		gius_reg |= (1L << index);
+		_gpio_set_ocr(port, index, GPIO_OUTPUT_C);
+		break;
+	default:
+		spin_unlock_irqrestore(&gpio_mux_lock, lock_flags);
+		return -1;
+	}
+
+	__raw_writel(gius_reg, port->base + GPIO_GIUS);
+	__raw_writel(gpr_reg, port->base + GPIO_GPR);
+
+	spin_unlock_irqrestore(&gpio_mux_lock, lock_flags);
+	return 0;
+}
+
+/*!
+ * This function is just used to enable or disable the pull up feature .
+ * @param pin   a pin number as defined in \b #iomux_pin_name_t
+ * @param en    0 if disable, Non-zero enable
+ * @return      0 if successful, Non-zero otherwise
+ */
+int gpio_set_puen(iomux_pin_name_t pin, bool en)
+{
+	unsigned long lock_flags;
+
+	struct mxc_gpio_port *port;
+	u32 index, gpio = IOMUX_TO_GPIO(pin);
+
+	port = &(mxc_gpio_ports[GPIO_TO_PORT(gpio)]);
+	index = GPIO_TO_INDEX(gpio);
+
+	pr_debug("%s: Configuring output mode of PORT %c, bit %d\n",
+		 __FUNCTION__, port->num + 'A', index);
+
+	spin_lock_irqsave(&gpio_mux_lock, lock_flags);
+
+	_gpio_set_puen(port, index, en);
+	spin_unlock_irqrestore(&gpio_mux_lock, lock_flags);
+	return 0;
+
+}
+
+/*!
+ * This function is just used to request a pin and configure it.
+ * @param pin	a pin number as defined in \b #iomux_pin_name_t
+ * @param mode	a module as define in \b #gpio_mux_mode_t;
+ * @return	0 if successful, Non-zero otherwise
+ */
+int gpio_request_mux(iomux_pin_name_t pin, gpio_mux_mode_t mode)
+{
+	int ret;
+	ret = mxc_request_gpio(pin);
+	if (ret == 0) {
+		ret = gpio_config_mux(pin, mode);
+		if (ret) {
+			mxc_free_gpio(pin);
+		}
+	}
+	return ret;
+}
+
+/*!
+ * This function is just used to release a pin.
+ * @param pin	a pin number as defined in \b #iomux_pin_name_t
+ * @return	none
+ */
+void gpio_free_mux(iomux_pin_name_t pin)
+{
+	mxc_free_gpio(pin);
+}
diff --git a/arch/arm/mach-mx27/gpio_mux.h b/arch/arm/mach-mx27/gpio_mux.h
new file mode 100644
index 0000000..153fdb0
--- /dev/null
+++ b/arch/arm/mach-mx27/gpio_mux.h
@@ -0,0 +1,76 @@
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ *@file gpio_mux.h
+ *@brief This file contains the private definition  .
+ * @ingroup GPIO
+ */
+
+#ifndef __ARCH_ARM_MACH_MX27_GPIO_MUX_H__
+#define __ARCH_ARM_MACH_MX27_GPIO_MUX_H__
+
+/*!
+ * This enumeration data type defines the modes of the pin .
+ *	GPIO_MUX_PRIMARY is the primary mode.
+ *	GPIO_MUX_ALT is the alternate mode.
+ *	GPIO_MUX_GPIO is the output mode and the signal source is data register.
+ *	GPIO_MUX_INPUT1 is the input mode and the signal destination is A_OUT.
+ *	GPIO_MUX_INPUT2 is the input mode and the signal destination is B_OUT.
+ *	GPIO_MUX_OUTPUT1 is the output mode and the signal destination is A_IN.
+ *	GPIO_MUX_OUTPUT2 is the output mode and the signal destination is B_IN.
+ *	GPIO_MUX_OUTPUT3 is the output mode and the signal destination is C_IN.
+ */
+typedef enum {
+	GPIO_MUX_PRIMARY,
+	GPIO_MUX_ALT,
+	GPIO_MUX_GPIO,
+	GPIO_MUX_INPUT1,
+	GPIO_MUX_INPUT2,
+	GPIO_MUX_OUTPUT1,
+	GPIO_MUX_OUTPUT2,
+	GPIO_MUX_OUTPUT3,
+} gpio_mux_mode_t;
+
+/*!
+ * This function is just used to request a pin and configure it.
+ * @param pin	a pin number as defined in \b #iomux_pin_name_t
+ * @param mode	a module as define in \b #gpio_mux_mode_t;
+ * @return	0 if successful, Non-zero otherwise
+ */
+extern int gpio_request_mux(iomux_pin_name_t pin, gpio_mux_mode_t mode);
+
+/*!
+ * This function is just used to configure a pin .
+ * @param pin	a pin number as defined in \b #iomux_pin_name_t
+ * @param mode	a module as define in \b #gpio_mux_mode_t;
+ * @return	0 if successful, Non-zero otherwise
+ */
+extern int gpio_config_mux(iomux_pin_name_t pin, gpio_mux_mode_t mode);
+
+/*!
+ * This function is just used to enable or disable the pull up feature .
+ * @param pin   a pin number as defined in \b #iomux_pin_name_t
+ * @param en    0 if disable, Non-zero enable
+ * @return      0 if successful, Non-zero otherwise
+ */
+extern int gpio_set_puen(iomux_pin_name_t pin, bool en);
+
+/*!
+ * This function is just used to release a pin.
+ * @param pin	a pin number as defined in \b #iomux_pin_name_t
+ * @return	none
+ */
+extern void gpio_free_mux(iomux_pin_name_t pin);
+
+#endif				/* __ARCH_ARM_MACH_MX27_GPIO_MUX_H__ */
diff --git a/arch/arm/mach-mx27/mm.c b/arch/arm/mach-mx27/mm.c
new file mode 100644
index 0000000..d63d328
--- /dev/null
+++ b/arch/arm/mach-mx27/mm.c
@@ -0,0 +1,55 @@
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file mm.c
+ *
+ * @brief This file creates static mapping between physical to virtual memory.
+ *
+ * @ingroup Memory
+ */
+
+#include <linux/mm.h>
+#include <linux/init.h>
+
+#include <asm/hardware.h>
+#include <asm/pgtable.h>
+#include <asm/mach/map.h>
+
+static struct map_desc mxc_io_desc[] __initdata = {
+	{
+	 .virtual = AIPI_BASE_ADDR_VIRT,
+	 .pfn = __phys_to_pfn(AIPI_BASE_ADDR),
+	 .length = AIPI_SIZE,
+	 .type = MT_DEVICE},
+	{
+	 .virtual = SAHB1_BASE_ADDR_VIRT,
+	 .pfn = __phys_to_pfn(SAHB1_BASE_ADDR),
+	 .length = SAHB1_SIZE,
+	 .type = MT_DEVICE},
+	{
+	 .virtual = X_MEMC_BASE_ADDR_VIRT,
+	 .pfn = __phys_to_pfn(X_MEMC_BASE_ADDR),
+	 .length = X_MEMC_SIZE,
+	 .type = MT_DEVICE},
+	{
+	 .virtual = CS4_BASE_ADDR_VIRT,
+	 .pfn = __phys_to_pfn(CS4_BASE_ADDR),
+	 .length = CS4_SIZE,
+	 .type = MT_DEVICE}
+};
+
+void __init mxc_map_io(void)
+{
+	iotable_init(mxc_io_desc, ARRAY_SIZE(mxc_io_desc));
+}
diff --git a/arch/arm/mach-mx27/mx27ads.c b/arch/arm/mach-mx27/mx27ads.c
new file mode 100644
index 0000000..ab4aac6
--- /dev/null
+++ b/arch/arm/mach-mx27/mx27ads.c
@@ -0,0 +1,704 @@
+/*
+ *  Copyright (C) 2000 Deep Blue Solutions Ltd
+ *  Copyright (C) 2002 Shane Nay (shane@minirl.com)
+ *  Copyright 2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/types.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+#include <linux/init.h>
+#include <linux/ioport.h>
+#include <linux/device.h>
+#include <linux/input.h>
+#include <linux/nodemask.h>
+#include <linux/spi/spi.h>
+#include <linux/serial_8250.h>
+#if defined(CONFIG_MTD) || defined(CONFIG_MTD_MODULE)
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/mach/flash.h>
+#endif
+
+#include <asm/hardware.h>
+#include <asm/irq.h>
+#include <asm/setup.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <asm/mach/irq.h>
+#include <asm/arch/memory.h>
+#include <asm/arch/hardware.h>
+#include <asm/arch/gpio.h>
+#include <asm/arch/clock.h>
+#if defined(CONFIG_KEYBOARD_MXC) || defined(CONFIG_KEYBOARD_MXC_MODULE)
+#include <asm/mach/keypad.h>
+#endif
+#include "gpio_mux.h"
+
+/*!
+ * @file mx27ads.c
+ * @brief This file contains the board specific initialization routines.
+ *
+ * @ingroup System
+ */
+
+extern void mxc_map_io(void);
+extern void mxc_init_irq(void);
+extern struct sys_timer mxc_timer;
+
+static char command_line[COMMAND_LINE_SIZE];
+static int mxc_card_status;
+int mxc_board_is_ads = 1;
+
+static void mxc_nop_release(struct device *dev)
+{
+	/* Nothing */
+}
+
+#if defined(CONFIG_KEYBOARD_MXC) || defined(CONFIG_KEYBOARD_MXC_MODULE)
+
+/*!
+ * This array is used for mapping mx27 ADS keypad scancodes to input keyboard
+ * keycodes.
+ */
+static u16 mxckpd_keycodes[(MAXROW * MAXCOL)] = {
+	KEY_KP9, KEY_LEFTSHIFT, KEY_0, KEY_KPASTERISK, KEY_RECORD, KEY_POWER,
+	KEY_KP8, KEY_9, KEY_8, KEY_7, KEY_KP5, KEY_VOLUMEDOWN,
+	KEY_KP7, KEY_6, KEY_5, KEY_4, KEY_KP4, KEY_VOLUMEUP,
+	KEY_KP6, KEY_3, KEY_2, KEY_1, KEY_KP3, KEY_DOWN,
+	KEY_BACK, KEY_RIGHT, KEY_ENTER, KEY_LEFT, KEY_HOME, KEY_KP2,
+	KEY_END, KEY_F2, KEY_UP, KEY_F1, KEY_F4, KEY_KP1,
+};
+
+static struct keypad_data evb_6_by_6_keypad = {
+	.rowmax = 6,
+	.colmax = 6,
+	.irq = INT_KPP,
+	.learning = 0,
+	.delay = 2,
+	.matrix = mxckpd_keycodes,
+};
+
+static struct resource mxc_kpp_resources[] = {
+	[0] = {
+	       .start = INT_KPP,
+	       .end = INT_KPP,
+	       .flags = IORESOURCE_IRQ,
+	       }
+};
+
+/* mxc keypad driver */
+static struct platform_device mxc_keypad_device = {
+	.name = "mxc_keypad",
+	.id = 0,
+	.num_resources = ARRAY_SIZE(mxc_kpp_resources),
+	.resource = mxc_kpp_resources,
+	.dev = {
+		.release = mxc_nop_release,
+		.platform_data = &evb_6_by_6_keypad,
+		},
+};
+
+static void mxc_init_keypad(void)
+{
+	printk("mx27ads.c: registering mxc keypad device...\n");
+	(void)platform_device_register(&mxc_keypad_device);
+}
+#else
+static inline void mxc_init_keypad(void)
+{
+}
+#endif
+
+/* MTD NOR flash */
+
+#if defined(CONFIG_MTD_MXC) || defined(CONFIG_MTD_MXC_MODULE)
+
+static struct mtd_partition mxc_nor_partitions[] = {
+	{
+	 .name = "Bootloader",
+	 .size = 512 * 1024,
+	 .offset = 0x00000000,
+	 .mask_flags = MTD_WRITEABLE	/* force read-only */
+	 },
+	{
+	 .name = "nor.Kernel",
+	 .size = 2 * 1024 * 1024,
+	 .offset = MTDPART_OFS_APPEND,
+	 .mask_flags = 0},
+	{
+	 .name = "nor.userfs",
+	 .size = 14 * 1024 * 1024,
+	 .offset = MTDPART_OFS_APPEND,
+	 .mask_flags = 0},
+	{
+	 .name = "nor.rootfs",
+	 .size = 12 * 1024 * 1024,
+	 .offset = MTDPART_OFS_APPEND,
+	 .mask_flags = MTD_WRITEABLE},
+	{
+	 .name = "FIS directory",
+	 .size = 12 * 1024,
+	 .offset = 0x01FE0000,
+	 .mask_flags = MTD_WRITEABLE	/* force read-only */
+	 },
+	{
+	 .name = "Redboot config",
+	 .size = MTDPART_SIZ_FULL,
+	 .offset = 0x01FFF000,
+	 .mask_flags = MTD_WRITEABLE	/* force read-only */
+	 },
+};
+
+static struct flash_platform_data mxc_flash_data = {
+	.map_name = "cfi_probe",
+	.width = 2,
+	.parts = mxc_nor_partitions,
+	.nr_parts = ARRAY_SIZE(mxc_nor_partitions),
+};
+
+static struct resource mxc_flash_resource = {
+	.start = 0xc0000000,
+	.end = 0xc0000000 + 0x02000000 - 1,
+	.flags = IORESOURCE_MEM,
+
+};
+
+static struct platform_device mxc_nor_mtd_device = {
+	.name = "mxc_nor_flash",
+	.id = 0,
+	.dev = {
+		.release = mxc_nop_release,
+		.platform_data = &mxc_flash_data,
+		},
+	.num_resources = 1,
+	.resource = &mxc_flash_resource,
+};
+
+static void mxc_init_nor_mtd(void)
+{
+	(void)platform_device_register(&mxc_nor_mtd_device);
+}
+#else
+static void mxc_init_nor_mtd(void)
+{
+}
+#endif
+
+/* MTD NAND flash */
+
+#if defined(CONFIG_MTD_NAND_MXC) || defined(CONFIG_MTD_NAND_MXC_MODULE)
+
+static struct mtd_partition mxc_nand_partitions[4] = {
+	{
+	 .name = "IPL-SPL",
+	 .offset = 0,
+	 .size = 128 * 1024},
+	{
+	 .name = "nand.kernel",
+	 .offset = MTDPART_OFS_APPEND,
+	 .size = 4 * 1024 * 1024},
+	{
+	 .name = "nand.rootfs",
+	 .offset = MTDPART_OFS_APPEND,
+	 .size = 22 * 1024 * 1024},
+	{
+	 .name = "nand.userfs",
+	 .offset = MTDPART_OFS_APPEND,
+	 .size = MTDPART_SIZ_FULL},
+};
+
+static struct flash_platform_data mxc_nand_data = {
+	.parts = mxc_nand_partitions,
+	.nr_parts = ARRAY_SIZE(mxc_nand_partitions),
+	.width = 1,
+};
+
+static struct platform_device mxc_nand_mtd_device = {
+	.name = "mxc_nand_flash",
+	.id = 0,
+	.dev = {
+		.release = mxc_nop_release,
+		.platform_data = &mxc_nand_data,
+		},
+};
+
+static void mxc_init_nand_mtd(void)
+{
+	(void)platform_device_register(&mxc_nand_mtd_device);
+}
+#else
+static inline void mxc_init_nand_mtd(void)
+{
+}
+#endif
+
+#if defined(CONFIG_FB_MXC_SYNC_PANEL) || defined(CONFIG_FB_MXC_SYNC_PANEL_MODULE)
+static const char fb_default_mode[] = "Sharp-QVGA";
+
+/* mxc lcd driver */
+static struct platform_device mxc_fb_device = {
+	.name = "mxc_sdc_fb",
+	.id = 0,
+	.dev = {
+		.release = mxc_nop_release,
+		.platform_data = &fb_default_mode,
+		.coherent_dma_mask = 0xFFFFFFFF,
+		},
+};
+
+static void mxc_init_fb(void)
+{
+	(void)platform_device_register(&mxc_fb_device);
+}
+#else
+static inline void mxc_init_fb(void)
+{
+}
+#endif
+
+static struct spi_board_info mxc_spi_board_info[] __initdata = {
+	{
+	 .modalias = "pmic_spi",
+	 .irq = IOMUX_TO_IRQ(MX27_PIN_TOUT),
+	 .max_speed_hz = 4000000,
+	 .bus_num = 1,
+	 .chip_select = 0,
+	 },
+};
+
+#if 0
+#define MXC_CARD_DEBUG
+#endif
+
+static const int pbc_card_bit[4][3] = {
+	/* BSTAT            IMR enable       IMR removal */
+	{PBC_BSTAT_SD2_DET, PBC_INTR_SD2_EN, PBC_INTR_SD2_R_EN},
+	{PBC_BSTAT_SD3_DET, PBC_INTR_SD3_EN, PBC_INTR_SD3_R_EN},
+	{PBC_BSTAT_MS_DET, PBC_INTR_MS_EN, PBC_INTR_MS_R_EN},
+	{PBC_BSTAT_SD1_DET, PBC_INTR_SD1_EN, PBC_INTR_SD1_R_EN},
+};
+
+/*!
+ * Check if a SD card has been inserted or not.
+ *
+ * @param  num		a card number as defined in \b enum \b mxc_card_no
+ * @return 0 if a card is not present; non-zero otherwise.
+ */
+int mxc_card_detected(enum mxc_card_no num)
+{
+	u32 status;
+
+	status = __raw_readw(PBC_BSTAT1_REG);
+	return ((status & MXC_BSTAT_BIT(num)) == 0);
+}
+
+/*
+ * Check if there is any state change by reading the IMR register and the
+ * previous and current states of the board status register (offset 0x28).
+ * A state change is defined to be card insertion OR removal. So the driver
+ * may have to call the mxc_card_detected() function to see if it is card
+ * insertion or removal.
+ *
+ * @param  mask		current IMR value
+ * @param  s0		previous status register value (offset 0x28)
+ * @param  s1		current status register value (offset 0x28)
+ *
+ * @return 0 if no card status change OR the corresponding bits in the IMR
+ *           (passed in as 'mask') is NOT set.
+ *         A non-zero value indicates some card state changes. For example,
+ *         0b0001 means SD3 has a card state change (bit0 is set) AND its
+ *               associated insertion or removal bits in IMR is SET.
+ *         0b0100 means SD1 has a card state change (bit2 is set) AND its
+ *               associated insertion or removal bits in IMR is SET.
+ *         0b1001 means both MS and SD3 have state changes
+ */
+static u32 mxc_card_state_changed(u32 mask, u32 s0, u32 s1)
+{
+	u32 i, retval = 0;
+	u32 stat = (s0 ^ s1) & 0x7800;
+
+	if (stat == 0)
+		return 0;
+
+	for (i = MXC_CARD_MIN; i <= MXC_CARD_MAX; i++) {
+		if ((stat & pbc_card_bit[i][0]) != 0 &&
+		    (mask & (pbc_card_bit[i][1] | pbc_card_bit[i][2])) != 0) {
+			retval |= 1 << i;
+		}
+	}
+#ifdef MXC_CARD_DEBUG
+	printk("\nmask=%x, s0=%x, s1=%x\n", mask, s0, s1);
+	printk("retval=%x, stat=%x\n", retval, stat);
+#endif
+	return retval;
+}
+
+/*!
+ * Interrupt handler for the expio (CPLD) to deal with interrupts from
+ * FEC, external UART, CS8900 Ethernet and SD cards, etc.
+ */
+static void mxc_expio_irq_handler(u32 irq, struct irq_desc *desc)
+{
+	u32 imr, card_int, i;
+	u32 int_valid;
+	u32 expio_irq;
+	u32 stat = __raw_readw(PBC_BSTAT1_REG);
+
+	desc->chip->mask(irq);	/* irq = gpio irq number */
+
+	imr = __raw_readw(PBC_INTMASK_SET_REG);
+
+	card_int = mxc_card_state_changed(imr, mxc_card_status, stat);
+	mxc_card_status = stat;
+
+	if (card_int != 0) {
+		for (i = MXC_CARD_MIN; i <= MXC_CARD_MAX - 1; i++) {
+			if ((card_int & (1 << i)) != 0) {
+				pr_info("card no %d state changed\n", i);
+			}
+		}
+	}
+
+	/* Bits defined in PBC_INTSTATUS_REG at 0x2C */
+	int_valid = __raw_readw(PBC_INTSTATUS_REG) & imr;
+	/*  combined with the card interrupt valid information */
+	int_valid = (int_valid & 0x0F8E) | (card_int << PBC_INTR_SD2_EN_BIT);
+
+	if (unlikely(!int_valid)) {
+		printk(KERN_ERR "\nEXPIO: Spurious interrupt:0x%0x\n\n",
+		       int_valid);
+		pr_info("CPLD IMR(0x38)=0x%x, BSTAT1(0x28)=0x%x\n", imr, stat);
+		goto out;
+	}
+
+	expio_irq = MXC_EXP_IO_BASE;
+	for (; int_valid != 0; int_valid >>= 1, expio_irq++) {
+		struct irq_desc *d;
+		if ((int_valid & 1) == 0)
+			continue;
+		d = irq_desc + expio_irq;
+		if (unlikely(!(d->handle_irq))) {
+			printk(KERN_ERR "\nEXPIO irq: %d unhandeled\n",
+			       expio_irq);
+			BUG();	/* oops */
+		}
+		d->handle_irq(expio_irq, d);
+	}
+
+      out:
+	desc->chip->ack(irq);
+	desc->chip->unmask(irq);
+}
+
+#ifdef MXC_CARD_DEBUG
+
+static irqreturn_t mxc_sd_test_handler(int irq, void *desc)
+{
+	int s = -1;
+
+	printk("%s(irq=%d) for ", __FUNCTION__, irq);
+	if (irq == EXPIO_INT_SD1_EN) {
+		printk("SD1");
+		s = MXC_CARD_SD1;
+	} else if (irq == EXPIO_INT_SD2_EN) {
+		printk("SD2");
+		s = MXC_CARD_SD2;
+	} else if (irq == EXPIO_INT_SD3_EN) {
+		printk("SD3");
+		s = MXC_CARD_SD3;
+	} else if (irq == EXPIO_INT_MS_EN) {
+		printk("MS");
+		s = MXC_CARD_MS;
+	} else {
+		printk("None!!!!");
+	}
+	if (mxc_card_detected(s)) {
+		printk(" inserted\n");
+	} else {
+		printk(" removed\n");
+	}
+
+	return IRQ_HANDLED;
+}
+#endif				/* MXC_CARD_DEBUG */
+
+/*
+ * Disable an expio pin's interrupt by setting the bit in the imr.
+ * @param irq		an expio virtual irq number
+ */
+static void expio_mask_irq(u32 irq)
+{
+	u32 expio = MXC_IRQ_TO_EXPIO(irq);
+
+	/* mask the interrupt */
+	if (irq < EXPIO_INT_SD2_EN) {
+		__raw_writew(1 << expio, PBC_INTMASK_CLEAR_REG);
+	} else {
+		irq -= EXPIO_INT_SD2_EN;
+		/* clear both SDx_EN and SDx_R_EN bits */
+		__raw_writew((pbc_card_bit[irq][1] | pbc_card_bit[irq][2]),
+			     PBC_INTMASK_CLEAR_REG);
+	}
+}
+
+/*
+ * Acknowledge an expanded io pin's interrupt by clearing the bit in the isr.
+ * @param irq		an expanded io virtual irq number
+ */
+static void expio_ack_irq(u32 irq)
+{
+	u32 expio = MXC_IRQ_TO_EXPIO(irq);
+	/* clear the interrupt status */
+	__raw_writew(1 << expio, PBC_INTSTATUS_REG);
+	/* mask the interrupt */
+	expio_mask_irq(irq);
+}
+
+/*
+ * Enable a expio pin's interrupt by clearing the bit in the imr.
+ * @param irq		an expio virtual irq number
+ */
+static void expio_unmask_irq(u32 irq)
+{
+	u32 expio = MXC_IRQ_TO_EXPIO(irq);
+
+	/* unmask the interrupt */
+	if (irq < EXPIO_INT_SD2_EN) {
+		if (irq == EXPIO_INT_XUART_INTA) {
+			/* Set 8250 MCR register bit 3 - Forces the INT (A-B
+			 * outputs to the active mode and sets OP2 to logic 0.
+			 * This is needed to avoid spurious int caused by the
+			 * internal CPLD pull-up for the interrupt pin.
+			 */
+			u16 val = __raw_readw(MXC_LL_EXTUART_VADDR + 8);
+			__raw_writew(val | 0x8, MXC_LL_EXTUART_VADDR + 8);
+		}
+		__raw_writew(1 << expio, PBC_INTMASK_SET_REG);
+	} else {
+		irq -= EXPIO_INT_SD2_EN;
+
+		if (mxc_card_detected(irq)) {
+			__raw_writew(pbc_card_bit[irq][2], PBC_INTMASK_SET_REG);
+		} else {
+			__raw_writew(pbc_card_bit[irq][1], PBC_INTMASK_SET_REG);
+		}
+	}
+}
+
+static struct irq_chip expio_irq_chip = {
+	.ack = expio_ack_irq,
+	.mask = expio_mask_irq,
+	.unmask = expio_unmask_irq,
+};
+
+static int __init mxc_expio_init(void)
+{
+	int i, ver;
+
+	ver = (__raw_readw(PBC_VERSION_REG) >> 8) & 0xFF;
+	if ((ver & 0x80) != 0) {
+		pr_info("MX27 ADS EXPIO(CPLD) hardware\n");
+		pr_info("CPLD version: 0x%x\n", ver);
+	} else {
+		mxc_board_is_ads = 0;
+		ver &= 0x0F;
+		pr_info("MX27 EVB EXPIO(CPLD) hardware\n");
+		if (ver == 0xF || ver <= MXC_CPLD_VER_1_50)
+			pr_info("Wrong CPLD version: %d\n", ver);
+		else {
+			pr_info("CPLD version: %d\n", ver);
+		}
+	}
+
+	mxc_card_status = __raw_readw(PBC_BSTAT1_REG);
+
+#ifdef MXC_CARD_DEBUG
+	for (i = MXC_CARD_MIN; i <= MXC_CARD_MAX; i++) {
+		if (mxc_card_detected(i)) {
+			pr_info("Card %d is detected\n", 3 - i);
+		}
+	}
+#endif
+	/*
+	 * Configure INT line as GPIO input
+	 */
+	gpio_config_mux(MX27_PIN_TIN, GPIO_MUX_GPIO);
+	mxc_set_gpio_direction(MX27_PIN_TIN, 1);
+
+	/* disable the interrupt and clear the status */
+	__raw_writew(0xFFFF, PBC_INTMASK_CLEAR_REG);
+	__raw_writew(0xFFFF, PBC_INTSTATUS_REG);
+
+	for (i = MXC_EXP_IO_BASE; i < (MXC_EXP_IO_BASE + MXC_MAX_EXP_IO_LINES);
+	     i++) {
+		set_irq_chip(i, &expio_irq_chip);
+		set_irq_handler(i, handle_level_irq);
+		set_irq_flags(i, IRQF_VALID);
+	}
+	set_irq_type(EXPIO_PARENT_INT, IRQT_HIGH);
+	set_irq_chained_handler(EXPIO_PARENT_INT, mxc_expio_irq_handler);
+
+	return 0;
+}
+
+#if defined(CONFIG_SERIAL_8250) || defined(CONFIG_SERIAL_8250_MODULE)
+
+/*!
+ * The serial port definition structure. The fields contain:
+ * {UART, CLK, PORT, IRQ, FLAGS}
+ */
+static struct plat_serial8250_port serial_platform_data[] = {
+	{
+	 .membase = (void __iomem *)(CS4_BASE_ADDR_VIRT + 0x20000),
+	 .mapbase = (unsigned long)(CS4_BASE_ADDR + 0x20000),
+	 .irq = EXPIO_INT_XUART_INTA,
+	 .uartclk = 3686400,
+	 .regshift = 1,
+	 .iotype = UPIO_MEM,
+	 .flags = UPF_BOOT_AUTOCONF | UPF_SKIP_TEST | UPF_AUTO_IRQ,
+	 /*.pm = serial_platform_pm, */
+	 },
+	{},
+};
+
+/*!
+ * REVISIT: document me
+ */
+static struct platform_device serial_device = {
+	.name = "serial8250",
+	.id = 0,
+	.dev = {
+		.platform_data = &serial_platform_data[0],
+		},
+};
+
+/*!
+ * REVISIT: document me
+ */
+static int __init mxc_init_extuart(void)
+{
+	int value;
+	/*reset ext uart in cpld */
+	__raw_writew(PBC_BCTRL1_URST, PBC_BCTRL1_SET_REG);
+	/*delay some time for reset finish */
+	for (value = 0; value < 1000; value++) ;
+	__raw_writew(PBC_BCTRL1_URST, PBC_BCTRL1_CLEAR_REG);
+	return platform_device_register(&serial_device);
+}
+#else
+static inline int mxc_init_extuart(void)
+{
+	return 0;
+}
+#endif
+
+#if defined(CONFIG_MXC_PMIC_MC13783) && defined(CONFIG_SND_MXC_PMIC)
+extern void gpio_ssi_active(int ssi_num);
+
+static inline int mxc_init_pmic_audio(void)
+{
+	/* Assign CLK_26M to CLKO */
+	mxc_set_clock_output(CKO, CKIH_CLK, 1);
+	gpio_ssi_active(0);
+	gpio_ssi_active(1);
+	mxc_clks_enable(SSI1_BAUD);
+	mxc_clks_enable(SSI2_BAUD);
+	return 0;
+}
+#else
+static inline int mxc_init_pmic_audio(void)
+{
+	return 0;
+}
+#endif
+
+static void mxc_board_init(void)
+{
+	pr_info("AIPI VA base: 0x%x\n", IO_ADDRESS(AIPI_BASE_ADDR));
+	mxc_gpio_init();
+	mxc_expio_init();
+	mxc_init_keypad();
+	mxc_init_nor_mtd();
+	mxc_init_nand_mtd();
+	mxc_init_extuart();
+	mxc_init_pmic_audio();
+#ifdef MXC_CARD_DEBUG
+	request_irq(EXPIO_INT_SD1_EN, mxc_sd_test_handler, 0, "SD_card1", NULL);
+	request_irq(EXPIO_INT_SD2_EN, mxc_sd_test_handler, 0, "SD_card2", NULL);
+	request_irq(EXPIO_INT_SD3_EN, mxc_sd_test_handler, 0, "SD_card3", NULL);
+	request_irq(EXPIO_INT_MS_EN, mxc_sd_test_handler, 0, "MS_card", NULL);
+#endif
+
+	spi_register_board_info(mxc_spi_board_info,
+				ARRAY_SIZE(mxc_spi_board_info));
+
+	mxc_init_fb();
+}
+
+static void __init fixup_mxc_board(struct machine_desc *desc, struct tag *tags,
+				   char **cmdline, struct meminfo *mi)
+{
+#ifdef CONFIG_KGDB_8250
+	int i;
+	for (i = 0;
+	     i <
+	     (sizeof(serial_platform_data) / sizeof(serial_platform_data[0]));
+	     i += 1)
+		kgdb8250_add_platform_port(i, &serial_platform_data[i]);
+#endif
+
+	/* Store command line for use on mxc_board_init */
+	strcpy(command_line, *cmdline);
+
+#ifdef CONFIG_DISCONTIGMEM
+	do {
+		int nid;
+		mi->nr_banks = MXC_NUMNODES;
+		for (nid = 0; nid < mi->nr_banks; nid++) {
+			SET_NODE(mi, nid);
+		}
+	} while (0);
+#endif
+}
+
+EXPORT_SYMBOL(mxc_card_detected);
+EXPORT_SYMBOL(mxc_board_is_ads);
+
+/*
+ * The following uses standard kernel macros define in arch.h in order to
+ * initialize __mach_desc_MX27ADS data structure.
+ */
+/* *INDENT-OFF* */
+MACHINE_START(MX27ADS, "Freescale i.MX27ADS")
+	/* maintainer: Freescale Semiconductor, Inc. */
+#ifdef CONFIG_SERIAL_8250_CONSOLE
+	.phys_io	= CS4_BASE_ADDR,
+	.io_pg_offst	= ((CS4_BASE_ADDR_VIRT) >> 18) & 0xfffc,
+#else
+	.phys_io	= AIPI_BASE_ADDR,
+	.io_pg_offst	= ((AIPI_BASE_ADDR_VIRT) >> 18) & 0xfffc,
+#endif
+	.boot_params	= PHYS_OFFSET_ASM + 0x100,
+	.fixup		= fixup_mxc_board,
+	.map_io	= mxc_map_io,
+	.init_irq	= mxc_init_irq,
+	.init_machine	= mxc_board_init,
+	.timer		= &mxc_timer,
+MACHINE_END
diff --git a/arch/arm/mach-mx27/mx27ads_gpio.c b/arch/arm/mach-mx27/mx27ads_gpio.c
new file mode 100644
index 0000000..8983c27
--- /dev/null
+++ b/arch/arm/mach-mx27/mx27ads_gpio.c
@@ -0,0 +1,1172 @@
+/*
+ *  Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/errno.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <asm/io.h>
+#include <asm/hardware.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/gpio.h>
+
+#include "gpio_mux.h"
+#include "crm_regs.h"
+
+static int g_uart_activated[MXC_UART_NR] = { 0, 0, 0, 0, 0, 0 };
+
+/*!
+ * @file mx27ads_gpio.c
+ *
+ * @brief This file contains all the GPIO setup functions for the board.
+ *
+ * @ingroup GPIO
+ */
+
+/*!
+ * Setup GPIO for a UART port to be active
+ *
+ * @param  port         a UART port
+ * @param  no_irda      indicates if the port is used for SIR
+ */
+void gpio_uart_active(int port, int no_irda)
+{
+	if (port < 0 || port >= MXC_UART_NR) {
+		pr_info("Wrong port number: %d\n", port);
+		BUG();
+	}
+
+	if (g_uart_activated[port]) {
+		pr_info("UART %d has been activated multiple times\n", port + 1);
+		return;
+	}
+	g_uart_activated[port] = 1;
+
+	switch (port) {
+	case 0:
+		gpio_request_mux(MX27_PIN_UART1_TXD, GPIO_MUX_PRIMARY);
+		gpio_request_mux(MX27_PIN_UART1_RXD, GPIO_MUX_PRIMARY);
+		gpio_request_mux(MX27_PIN_UART1_CTS, GPIO_MUX_PRIMARY);
+		gpio_request_mux(MX27_PIN_UART1_RTS, GPIO_MUX_PRIMARY);
+		break;
+	case 1:
+		gpio_request_mux(MX27_PIN_UART2_TXD, GPIO_MUX_PRIMARY);
+		gpio_request_mux(MX27_PIN_UART2_RXD, GPIO_MUX_PRIMARY);
+		gpio_request_mux(MX27_PIN_UART2_CTS, GPIO_MUX_PRIMARY);
+		gpio_request_mux(MX27_PIN_UART2_RTS, GPIO_MUX_PRIMARY);
+		break;
+	case 2:
+		gpio_request_mux(MX27_PIN_UART3_TXD, GPIO_MUX_PRIMARY);
+		gpio_request_mux(MX27_PIN_UART3_RXD, GPIO_MUX_PRIMARY);
+		gpio_request_mux(MX27_PIN_UART3_CTS, GPIO_MUX_PRIMARY);
+		gpio_request_mux(MX27_PIN_UART3_RTS, GPIO_MUX_PRIMARY);
+
+		/* Enable IRDA in CPLD */
+		__raw_writew(PBC_BCTRL2_IRDA_EN, PBC_BCTRL2_CLEAR_REG);
+		break;
+	case 3:
+		gpio_request_mux(MX27_PIN_USBH1_TXDM, GPIO_MUX_ALT);
+		gpio_request_mux(MX27_PIN_USBH1_RXDP, GPIO_MUX_ALT);
+		gpio_request_mux(MX27_PIN_USBH1_TXDP, GPIO_MUX_ALT);
+		gpio_request_mux(MX27_PIN_USBH1_FS, GPIO_MUX_ALT);
+		break;
+	case 4:
+		gpio_request_mux(MX27_PIN_CSI_D6, GPIO_MUX_ALT);
+		gpio_request_mux(MX27_PIN_CSI_D7, GPIO_MUX_ALT);
+		gpio_request_mux(MX27_PIN_CSI_VSYNC, GPIO_MUX_ALT);
+		gpio_request_mux(MX27_PIN_CSI_HSYNC, GPIO_MUX_ALT);
+		break;
+	case 5:
+		gpio_request_mux(MX27_PIN_CSI_D0, GPIO_MUX_ALT);
+		gpio_request_mux(MX27_PIN_CSI_D1, GPIO_MUX_ALT);
+		gpio_request_mux(MX27_PIN_CSI_D2, GPIO_MUX_ALT);
+		gpio_request_mux(MX27_PIN_CSI_D3, GPIO_MUX_ALT);
+		break;
+	default:
+		break;
+	}
+}
+
+/*!
+ * Setup GPIO for a UART port to be inactive
+ *
+ * @param  port         a UART port
+ * @param  no_irda      indicates if the port is used for SIR
+ */
+void gpio_uart_inactive(int port, int no_irda)
+{
+	if (port < 0 || port >= MXC_UART_NR) {
+		pr_info("Wrong port number: %d\n", port);
+		BUG();
+	}
+
+	if (g_uart_activated[port] == 0) {
+		pr_info("UART %d has not been activated \n", port + 1);
+		return;
+	}
+	g_uart_activated[port] = 0;
+
+	switch (port) {
+	case 0:
+		gpio_free_mux(MX27_PIN_UART1_TXD);
+		gpio_free_mux(MX27_PIN_UART1_RXD);
+		gpio_free_mux(MX27_PIN_UART1_CTS);
+		gpio_free_mux(MX27_PIN_UART1_RTS);
+		break;
+	case 1:
+		gpio_free_mux(MX27_PIN_UART2_TXD);
+		gpio_free_mux(MX27_PIN_UART2_RXD);
+		gpio_free_mux(MX27_PIN_UART2_CTS);
+		gpio_free_mux(MX27_PIN_UART2_RTS);
+		break;
+	case 2:
+		gpio_free_mux(MX27_PIN_UART3_TXD);
+		gpio_free_mux(MX27_PIN_UART3_RXD);
+		gpio_free_mux(MX27_PIN_UART3_CTS);
+		gpio_free_mux(MX27_PIN_UART3_RTS);
+
+		/* Disable IRDA in CPLD */
+		__raw_writew(PBC_BCTRL2_IRDA_EN, PBC_BCTRL2_SET_REG);
+		break;
+	case 3:
+		gpio_free_mux(MX27_PIN_USBH1_TXDM);
+		gpio_free_mux(MX27_PIN_USBH1_RXDP);
+		gpio_free_mux(MX27_PIN_USBH1_TXDP);
+		gpio_free_mux(MX27_PIN_USBH1_FS);
+		break;
+	case 4:
+		gpio_free_mux(MX27_PIN_CSI_D6);
+		gpio_free_mux(MX27_PIN_CSI_D7);
+		gpio_free_mux(MX27_PIN_CSI_VSYNC);
+		gpio_free_mux(MX27_PIN_CSI_HSYNC);
+		break;
+	case 5:
+		gpio_free_mux(MX27_PIN_CSI_D0);
+		gpio_free_mux(MX27_PIN_CSI_D1);
+		gpio_free_mux(MX27_PIN_CSI_D2);
+		gpio_free_mux(MX27_PIN_CSI_D3);
+		break;
+	default:
+		break;
+	}
+}
+
+/*!
+ * Configure the IOMUX GPR register to receive shared SDMA UART events
+ *
+ * @param  port         a UART port
+ */
+void config_uartdma_event(int port)
+{
+	return;
+}
+
+/*!
+ * Setup GPIO for USB, Total 34 signals
+ * PIN Configuration for USBOTG:   High/Full speed OTG
+ *	PE2,PE1,PE0,PE24,PE25 -- PRIMARY
+ *	PC7 - PC13  -- PRIMARY
+ *	PB23,PB24 -- PRIMARY
+ * PIN Configuration for USBH2:    : High/Full/Low speed host
+ *	PA0 - PA4 -- PRIMARY
+ *	PD19, PD20,PD21,PD22,PD23,PD24,PD26 --Alternate (SECONDARY)
+ * PIN Configuration for USBH1:  Full/low speed host
+ *	PB25 - PB31  -- PRIMARY
+ *	PB22  -- PRIMARY
+ */
+void gpio_usbh1_active(void)
+{
+	gpio_request_mux(MX27_PIN_USBH1_SUSP, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_USBH1_RCV, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_USBH1_FS, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_USBH1_OE_B, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_USBH1_TXDM, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_USBH1_TXDP, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_USBH1_RXDM, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_USBH1_RXDP, GPIO_MUX_PRIMARY);
+}
+void gpio_usbh1_inactive(void)
+{
+	gpio_free_mux(MX27_PIN_USBH1_SUSP);
+	gpio_free_mux(MX27_PIN_USBH1_RCV);
+	gpio_free_mux(MX27_PIN_USBH1_FS);
+	gpio_free_mux(MX27_PIN_USBH1_OE_B);
+	gpio_free_mux(MX27_PIN_USBH1_TXDM);
+	gpio_free_mux(MX27_PIN_USBH1_TXDP);
+	gpio_free_mux(MX27_PIN_USBH1_RXDM);
+	gpio_free_mux(MX27_PIN_USBH1_RXDP);
+}
+
+/*
+ * conflicts with CSPI1 (MC13783) and CSPI2 (Connector)
+ */
+void gpio_usbh2_active(void)
+{
+	gpio_set_puen(MX27_PIN_USBH2_CLK, 0);
+	gpio_set_puen(MX27_PIN_USBH2_DIR, 0);
+	gpio_set_puen(MX27_PIN_USBH2_DATA7, 0);
+	gpio_set_puen(MX27_PIN_USBH2_NXT, 0);
+	gpio_set_puen(MX27_PIN_USBH2_STP, 0);
+	gpio_set_puen(MX27_PIN_CSPI2_SS2, 0);
+	gpio_set_puen(MX27_PIN_CSPI2_SS1, 0);
+	gpio_set_puen(MX27_PIN_CSPI2_SS0, 0);
+	gpio_set_puen(MX27_PIN_CSPI2_SCLK, 0);
+	gpio_set_puen(MX27_PIN_CSPI2_MISO, 0);
+	gpio_set_puen(MX27_PIN_CSPI2_MOSI, 0);
+	gpio_set_puen(MX27_PIN_CSPI1_SS2, 0);
+
+	gpio_request_mux(MX27_PIN_USBH2_CLK, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_USBH2_DIR, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_USBH2_DATA7, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_USBH2_NXT, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_USBH2_STP, GPIO_MUX_PRIMARY);
+
+	gpio_request_mux(MX27_PIN_CSPI2_SS2, GPIO_MUX_ALT);
+	gpio_request_mux(MX27_PIN_CSPI2_SS1, GPIO_MUX_ALT);
+	gpio_request_mux(MX27_PIN_CSPI2_SS0, GPIO_MUX_ALT);
+	gpio_request_mux(MX27_PIN_CSPI2_SCLK, GPIO_MUX_ALT);
+	gpio_request_mux(MX27_PIN_CSPI2_MISO, GPIO_MUX_ALT);
+	gpio_request_mux(MX27_PIN_CSPI2_MOSI, GPIO_MUX_ALT);
+	gpio_request_mux(MX27_PIN_CSPI1_SS2, GPIO_MUX_ALT);
+}
+void gpio_usbh2_inactive(void)
+{
+	gpio_free_mux(MX27_PIN_USBH2_CLK);
+	gpio_free_mux(MX27_PIN_USBH2_DIR);
+	gpio_free_mux(MX27_PIN_USBH2_DATA7);
+	gpio_free_mux(MX27_PIN_USBH2_NXT);
+	gpio_free_mux(MX27_PIN_USBH2_STP);
+
+	gpio_free_mux(MX27_PIN_CSPI2_SS2);
+	gpio_free_mux(MX27_PIN_CSPI2_SS1);
+	gpio_free_mux(MX27_PIN_CSPI2_SS0);
+	gpio_free_mux(MX27_PIN_CSPI2_SCLK);
+	gpio_free_mux(MX27_PIN_CSPI2_MISO);
+	gpio_free_mux(MX27_PIN_CSPI2_MOSI);
+	gpio_free_mux(MX27_PIN_CSPI1_SS2);
+
+	gpio_set_puen(MX27_PIN_USBH2_CLK, 1);
+	gpio_set_puen(MX27_PIN_USBH2_DIR, 1);
+	gpio_set_puen(MX27_PIN_USBH2_DATA7, 1);
+	gpio_set_puen(MX27_PIN_USBH2_NXT, 1);
+	gpio_set_puen(MX27_PIN_USBH2_STP, 1);
+	gpio_set_puen(MX27_PIN_CSPI2_SS2, 1);
+	gpio_set_puen(MX27_PIN_CSPI2_SS1, 1);
+	gpio_set_puen(MX27_PIN_CSPI2_SS0, 1);
+	gpio_set_puen(MX27_PIN_CSPI2_SCLK, 1);
+	gpio_set_puen(MX27_PIN_CSPI2_MISO, 1);
+	gpio_set_puen(MX27_PIN_CSPI2_MOSI, 1);
+	gpio_set_puen(MX27_PIN_CSPI1_SS2, 1);
+}
+
+void gpio_usbotg_hs_active(void)
+{
+	gpio_request_mux(MX27_PIN_USBOTG_DATA5, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_USBOTG_DATA6, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_USBOTG_DATA0, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_USBOTG_DATA2, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_USBOTG_DATA1, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_USBOTG_DATA3, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_USBOTG_DATA4, GPIO_MUX_PRIMARY);
+
+	gpio_request_mux(MX27_PIN_USBOTG_DIR, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_USBOTG_STP, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_USBOTG_NXT, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_USBOTG_CLK, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_USBOTG_DATA7, GPIO_MUX_PRIMARY);
+
+	gpio_request_mux(MX27_PIN_USB_OC_B, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_USB_PWR, GPIO_MUX_PRIMARY);
+}
+
+void gpio_usbotg_hs_inactive(void)
+{
+	gpio_free_mux(MX27_PIN_USBOTG_DATA5);
+	gpio_free_mux(MX27_PIN_USBOTG_DATA6);
+	gpio_free_mux(MX27_PIN_USBOTG_DATA0);
+	gpio_free_mux(MX27_PIN_USBOTG_DATA2);
+	gpio_free_mux(MX27_PIN_USBOTG_DATA1);
+	gpio_free_mux(MX27_PIN_USBOTG_DATA3);
+	gpio_free_mux(MX27_PIN_USBOTG_DATA4);
+
+	gpio_free_mux(MX27_PIN_USBOTG_DIR);
+	gpio_free_mux(MX27_PIN_USBOTG_STP);
+	gpio_free_mux(MX27_PIN_USBOTG_NXT);
+	gpio_free_mux(MX27_PIN_USBOTG_CLK);
+	gpio_free_mux(MX27_PIN_USBOTG_DATA7);
+
+	gpio_free_mux(MX27_PIN_USB_OC_B);
+	gpio_free_mux(MX27_PIN_USB_PWR);
+}
+
+void gpio_usbotg_fs_active(void)
+{
+	return gpio_usbotg_hs_active();
+}
+
+void gpio_usbotg_fs_inactive(void)
+{
+	return gpio_usbotg_hs_inactive();
+}
+
+/*!
+ * end Setup GPIO for USB
+ *
+ */
+
+/************************************************************************/
+/* for i2c gpio                                                         */
+/* I2C1:  PD17,PD18 -- Primary 					*/
+/* I2C2:  PC5,PC6    -- Primary					*/
+/************************************************************************/
+/*!
+* Setup GPIO for an I2C device to be active
+*
+* @param  i2c_num         an I2C device
+*/
+void gpio_i2c_active(int i2c_num)
+{
+	switch (i2c_num) {
+	case 0:
+		gpio_request_mux(MX27_PIN_I2C_CLK, GPIO_MUX_PRIMARY);
+		gpio_request_mux(MX27_PIN_I2C_DATA, GPIO_MUX_PRIMARY);
+		break;
+	case 1:
+		gpio_request_mux(MX27_PIN_I2C2_SCL, GPIO_MUX_PRIMARY);
+		gpio_request_mux(MX27_PIN_I2C2_SDA, GPIO_MUX_PRIMARY);
+		break;
+	default:
+		printk("gpio_i2c_active no compatible I2C adapter\n");
+		break;
+	}
+}
+
+/*!
+ *  * Setup GPIO for an I2C device to be inactive
+ *   *
+ *    * @param  i2c_num         an I2C device
+ */
+void gpio_i2c_inactive(int i2c_num)
+{
+	switch (i2c_num) {
+	case 0:
+		gpio_free_mux(MX27_PIN_I2C_CLK);
+		gpio_free_mux(MX27_PIN_I2C_DATA);
+		break;
+	case 1:
+		gpio_free_mux(MX27_PIN_I2C2_SCL);
+		gpio_free_mux(MX27_PIN_I2C2_SDA);
+		break;
+	default:
+		break;
+	}
+}
+
+/*!
+ * Setup GPIO for a CSPI device to be active
+ *
+ * @param  cspi_mod         an CSPI device
+ */
+void gpio_spi_active(int cspi_mod)
+{
+	switch (cspi_mod) {
+	case 0:
+		/* SPI1 */
+		gpio_request_mux(MX27_PIN_CSPI1_MOSI, GPIO_MUX_PRIMARY);
+		gpio_request_mux(MX27_PIN_CSPI1_MISO, GPIO_MUX_PRIMARY);
+		gpio_request_mux(MX27_PIN_CSPI1_SCLK, GPIO_MUX_PRIMARY);
+		gpio_request_mux(MX27_PIN_CSPI1_RDY, GPIO_MUX_PRIMARY);
+		gpio_request_mux(MX27_PIN_CSPI1_SS0, GPIO_MUX_PRIMARY);
+		gpio_request_mux(MX27_PIN_CSPI1_SS1, GPIO_MUX_PRIMARY);
+		gpio_request_mux(MX27_PIN_CSPI1_SS2, GPIO_MUX_PRIMARY);
+		break;
+	case 1:
+		/*SPI2  */
+		gpio_request_mux(MX27_PIN_CSPI2_MOSI, GPIO_MUX_PRIMARY);
+		gpio_request_mux(MX27_PIN_CSPI2_MISO, GPIO_MUX_PRIMARY);
+		gpio_request_mux(MX27_PIN_CSPI2_SCLK, GPIO_MUX_PRIMARY);
+		gpio_request_mux(MX27_PIN_CSPI2_SS0, GPIO_MUX_PRIMARY);
+		gpio_request_mux(MX27_PIN_CSPI2_SS1, GPIO_MUX_PRIMARY);
+		gpio_request_mux(MX27_PIN_CSPI2_SS2, GPIO_MUX_PRIMARY);
+		break;
+	case 2:
+		/*SPI3  */
+		gpio_request_mux(MX27_PIN_SD1_D0, GPIO_MUX_ALT);
+		gpio_request_mux(MX27_PIN_SD1_CMD, GPIO_MUX_ALT);
+		gpio_request_mux(MX27_PIN_SD1_CLK, GPIO_MUX_ALT);
+		gpio_request_mux(MX27_PIN_SD1_D3, GPIO_MUX_ALT);
+		break;
+
+	default:
+		break;
+	}
+}
+
+/*!
+ * Setup GPIO for a CSPI device to be inactive
+ *
+ * @param  cspi_mod         a CSPI device
+ */
+void gpio_spi_inactive(int cspi_mod)
+{
+	switch (cspi_mod) {
+	case 0:
+		/* SPI1 */
+		gpio_free_mux(MX27_PIN_CSPI1_MOSI);
+		gpio_free_mux(MX27_PIN_CSPI1_MISO);
+		gpio_free_mux(MX27_PIN_CSPI1_SCLK);
+		gpio_free_mux(MX27_PIN_CSPI1_RDY);
+		gpio_free_mux(MX27_PIN_CSPI1_SS0);
+		gpio_free_mux(MX27_PIN_CSPI1_SS1);
+		gpio_free_mux(MX27_PIN_CSPI1_SS2);
+		break;
+	case 1:
+		/*SPI2  */
+		gpio_free_mux(MX27_PIN_CSPI2_MOSI);
+		gpio_free_mux(MX27_PIN_CSPI2_MISO);
+		gpio_free_mux(MX27_PIN_CSPI2_SCLK);
+		gpio_free_mux(MX27_PIN_CSPI2_SS0);
+		gpio_free_mux(MX27_PIN_CSPI2_SS1);
+		gpio_free_mux(MX27_PIN_CSPI2_SS2);
+		break;
+	case 2:
+		/*SPI3  */
+		gpio_free_mux(MX27_PIN_SD1_D0);
+		gpio_free_mux(MX27_PIN_SD1_CMD);
+		gpio_free_mux(MX27_PIN_SD1_CLK);
+		gpio_free_mux(MX27_PIN_SD1_D3);
+		break;
+
+	default:
+		break;
+	}
+}
+
+/*!
+ * Setup GPIO for a nand flash device to be active
+ *
+ */
+void gpio_nand_active(void)
+{
+	unsigned long reg;
+	reg = __raw_readl(IO_ADDRESS(SYSCTRL_BASE_ADDR) + SYS_FMCR);
+	reg &= ~(1 << 4);
+	__raw_writel(reg, IO_ADDRESS(SYSCTRL_BASE_ADDR) + SYS_FMCR);
+
+	gpio_request_mux(MX27_PIN_NFRB, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_NFCE_B, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_NFWP_B, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_NFCLE, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_NFALE, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_NFRE_B, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_NFWE_B, GPIO_MUX_PRIMARY);
+}
+
+/*!
+ * Setup GPIO for a nand flash device to be inactive
+ *
+ */
+void gpio_nand_inactive(void)
+{
+	gpio_free_mux(MX27_PIN_NFRB);
+	gpio_free_mux(MX27_PIN_NFCE_B);
+	gpio_free_mux(MX27_PIN_NFWP_B);
+	gpio_free_mux(MX27_PIN_NFCLE);
+	gpio_free_mux(MX27_PIN_NFALE);
+	gpio_free_mux(MX27_PIN_NFRE_B);
+	gpio_free_mux(MX27_PIN_NFWE_B);
+}
+
+/*!
+ * Setup GPIO for CSI device to be active
+ *
+ */
+void gpio_sensor_active(void)
+{
+	gpio_request_mux(MX27_PIN_CSI_D0, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_CSI_D1, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_CSI_D2, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_CSI_D3, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_CSI_D4, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_CSI_MCLK, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_CSI_PIXCLK, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_CSI_D5, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_CSI_D6, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_CSI_D7, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_CSI_VSYNC, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_CSI_HSYNC, GPIO_MUX_PRIMARY);
+
+	__raw_writew(0x400, PBC_BCTRL2_SET_REG);
+}
+
+void gpio_sensor_inactive(void)
+{
+	gpio_free_mux(MX27_PIN_CSI_D0);
+	gpio_free_mux(MX27_PIN_CSI_D1);
+	gpio_free_mux(MX27_PIN_CSI_D2);
+	gpio_free_mux(MX27_PIN_CSI_D3);
+	gpio_free_mux(MX27_PIN_CSI_D4);
+	gpio_free_mux(MX27_PIN_CSI_MCLK);
+	gpio_free_mux(MX27_PIN_CSI_PIXCLK);
+	gpio_free_mux(MX27_PIN_CSI_D5);
+	gpio_free_mux(MX27_PIN_CSI_D6);
+	gpio_free_mux(MX27_PIN_CSI_D7);
+	gpio_free_mux(MX27_PIN_CSI_VSYNC);
+	gpio_free_mux(MX27_PIN_CSI_HSYNC);
+
+	__raw_writew(0x400, PBC_BCTRL2_CLEAR_REG);
+}
+
+/*!
+ * Setup GPIO for LCDC device to be active
+ *
+ */
+void gpio_lcdc_active(void)
+{
+	gpio_request_mux(MX27_PIN_LSCLK, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_LD0, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_LD1, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_LD2, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_LD3, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_LD4, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_LD5, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_LD6, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_LD7, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_LD8, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_LD9, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_LD10, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_LD11, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_LD12, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_LD13, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_LD14, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_LD15, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_LD16, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_LD17, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_REV, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_CLS, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_PS, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_SPL_SPR, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_HSYNC, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_VSYNC, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_CONTRAST, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_OE_ACD, GPIO_MUX_PRIMARY);
+}
+
+/*!
+ * Setup GPIO for LCDC device to be inactive
+ *
+ */
+void gpio_lcdc_inactive(void)
+{
+	gpio_free_mux(MX27_PIN_LSCLK);
+	gpio_free_mux(MX27_PIN_LD0);
+	gpio_free_mux(MX27_PIN_LD1);
+	gpio_free_mux(MX27_PIN_LD2);
+	gpio_free_mux(MX27_PIN_LD3);
+	gpio_free_mux(MX27_PIN_LD4);
+	gpio_free_mux(MX27_PIN_LD5);
+	gpio_free_mux(MX27_PIN_LD6);
+	gpio_free_mux(MX27_PIN_LD7);
+	gpio_free_mux(MX27_PIN_LD8);
+	gpio_free_mux(MX27_PIN_LD9);
+	gpio_free_mux(MX27_PIN_LD10);
+	gpio_free_mux(MX27_PIN_LD11);
+	gpio_free_mux(MX27_PIN_LD12);
+	gpio_free_mux(MX27_PIN_LD13);
+	gpio_free_mux(MX27_PIN_LD14);
+	gpio_free_mux(MX27_PIN_LD15);
+	gpio_free_mux(MX27_PIN_LD16);
+	gpio_free_mux(MX27_PIN_LD17);
+	gpio_free_mux(MX27_PIN_REV);
+	gpio_free_mux(MX27_PIN_CLS);
+	gpio_free_mux(MX27_PIN_PS);
+	gpio_free_mux(MX27_PIN_SPL_SPR);
+	gpio_free_mux(MX27_PIN_HSYNC);
+	gpio_free_mux(MX27_PIN_VSYNC);
+	gpio_free_mux(MX27_PIN_CONTRAST);
+	gpio_free_mux(MX27_PIN_OE_ACD);
+}
+
+/*!
+ * Setup GPIO PA25 low to start hard reset FS453 TV encoder
+ *
+ */
+void gpio_fs453_reset_low(void)
+{
+	gpio_free_mux(MX27_PIN_CLS);
+	if (gpio_request_mux(MX27_PIN_CLS, GPIO_MUX_GPIO)) {
+		printk("bug: request GPIO PA25 failed.\n");
+		return;
+	}
+
+	/* PA25 (CLS) as output */
+	mxc_set_gpio_direction(MX27_PIN_CLS, 0);
+	gpio_config_mux(MX27_PIN_CLS, GPIO_MUX_GPIO);
+	mxc_set_gpio_dataout(MX27_PIN_CLS, 0);
+}
+
+/*!
+ * Setup GPIO PA25 high to end hard reset FS453 TV encoder
+ *
+ */
+void gpio_fs453_reset_high(void)
+{
+	gpio_free_mux(MX27_PIN_CLS);
+	if (gpio_request_mux(MX27_PIN_CLS, GPIO_MUX_GPIO)) {
+		printk("bug: request GPIO PA25 failed.\n");
+		return;
+	}
+
+	/* PA25 (CLS) as output */
+	mxc_set_gpio_direction(MX27_PIN_CLS, 0);
+	gpio_config_mux(MX27_PIN_CLS, GPIO_MUX_GPIO);
+	mxc_set_gpio_dataout(MX27_PIN_CLS, 1);
+}
+
+/*!
+ * This function configures the IOMux block for PMIC standard operations.
+ *
+ */
+void gpio_pmic_active(void)
+{
+	gpio_config_mux(MX27_PIN_TOUT, GPIO_MUX_GPIO);
+	mxc_set_gpio_direction(MX27_PIN_TOUT, 1);
+}
+
+/*!
+ * GPIO settings not required for keypad
+ *
+ */
+void gpio_keypad_active(void)
+{
+}
+
+/*!
+ * GPIO settings not required for keypad
+ *
+ */
+void gpio_keypad_inactive(void)
+{
+}
+
+/*!
+ * Setup GPIO for ATA device to be active
+ *
+ */
+void gpio_ata_active(void)
+{
+	gpio_request_mux(MX27_PIN_ATA_DATA0, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_ATA_DATA1, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_ATA_DATA2, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_ATA_DATA3, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_ATA_DATA4, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_ATA_DATA5, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_ATA_DATA6, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_ATA_DATA7, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_ATA_DATA8, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_ATA_DATA9, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_ATA_DATA10, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_ATA_DATA11, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_ATA_DATA12, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_ATA_DATA13, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_ATA_DATA14, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_ATA_DATA15, GPIO_MUX_PRIMARY);
+
+	gpio_request_mux(MX27_PIN_PC_CD1_B, GPIO_MUX_ALT);
+	gpio_request_mux(MX27_PIN_PC_CD2_B, GPIO_MUX_ALT);
+	gpio_request_mux(MX27_PIN_PC_WAIT_B, GPIO_MUX_ALT);
+	gpio_request_mux(MX27_PIN_PC_READY, GPIO_MUX_ALT);
+	gpio_request_mux(MX27_PIN_PC_PWRON, GPIO_MUX_ALT);
+	gpio_request_mux(MX27_PIN_PC_VS1, GPIO_MUX_ALT);
+	gpio_request_mux(MX27_PIN_PC_VS2, GPIO_MUX_ALT);
+	gpio_request_mux(MX27_PIN_PC_BVD1, GPIO_MUX_ALT);
+	gpio_request_mux(MX27_PIN_PC_BVD2, GPIO_MUX_ALT);
+	gpio_request_mux(MX27_PIN_PC_RST, GPIO_MUX_ALT);
+	gpio_request_mux(MX27_PIN_IOIS16, GPIO_MUX_ALT);
+	gpio_request_mux(MX27_PIN_PC_RW_B, GPIO_MUX_ALT);
+	gpio_request_mux(MX27_PIN_PC_POE, GPIO_MUX_ALT);
+
+	printk("ATA interface call clock enable ATA CLK \n");
+	mxc_clks_enable(ATA_CLK);
+}
+
+/*!
+ * Setup GPIO for ATA device to be inactive
+ *
+ */
+void gpio_ata_inactive(void)
+{
+	printk("ATA interface call clock disable ATA CLK \n");
+	mxc_clks_disable(ATA_CLK);
+
+	gpio_free_mux(MX27_PIN_ATA_DATA0);
+	gpio_free_mux(MX27_PIN_ATA_DATA1);
+	gpio_free_mux(MX27_PIN_ATA_DATA2);
+	gpio_free_mux(MX27_PIN_ATA_DATA3);
+	gpio_free_mux(MX27_PIN_ATA_DATA4);
+	gpio_free_mux(MX27_PIN_ATA_DATA5);
+	gpio_free_mux(MX27_PIN_ATA_DATA6);
+	gpio_free_mux(MX27_PIN_ATA_DATA7);
+	gpio_free_mux(MX27_PIN_ATA_DATA8);
+	gpio_free_mux(MX27_PIN_ATA_DATA9);
+	gpio_free_mux(MX27_PIN_ATA_DATA10);
+	gpio_free_mux(MX27_PIN_ATA_DATA11);
+	gpio_free_mux(MX27_PIN_ATA_DATA12);
+	gpio_free_mux(MX27_PIN_ATA_DATA13);
+	gpio_free_mux(MX27_PIN_ATA_DATA14);
+	gpio_free_mux(MX27_PIN_ATA_DATA15);
+
+	gpio_free_mux(MX27_PIN_PC_CD1_B);
+	gpio_free_mux(MX27_PIN_PC_CD2_B);
+	gpio_free_mux(MX27_PIN_PC_WAIT_B);
+	gpio_free_mux(MX27_PIN_PC_READY);
+	gpio_free_mux(MX27_PIN_PC_PWRON);
+	gpio_free_mux(MX27_PIN_PC_VS1);
+	gpio_free_mux(MX27_PIN_PC_VS2);
+	gpio_free_mux(MX27_PIN_PC_BVD1);
+	gpio_free_mux(MX27_PIN_PC_BVD2);
+	gpio_free_mux(MX27_PIN_PC_RST);
+	gpio_free_mux(MX27_PIN_IOIS16);
+	gpio_free_mux(MX27_PIN_PC_RW_B);
+	gpio_free_mux(MX27_PIN_PC_POE);
+}
+
+/*!
+ * Setup GPIO for FEC device to be active
+ *
+ */
+void gpio_fec_active(void)
+{
+	gpio_request_mux(MX27_PIN_ATA_DATA15, GPIO_MUX_OUTPUT1);
+	mxc_set_gpio_direction(MX27_PIN_ATA_DATA15, 0);
+	gpio_request_mux(MX27_PIN_ATA_DATA14, GPIO_MUX_OUTPUT1);
+	mxc_set_gpio_direction(MX27_PIN_ATA_DATA14, 0);
+	gpio_request_mux(MX27_PIN_ATA_DATA13, GPIO_MUX_INPUT1);
+	mxc_set_gpio_direction(MX27_PIN_ATA_DATA13, 1);
+	gpio_request_mux(MX27_PIN_ATA_DATA12, GPIO_MUX_INPUT1);
+	mxc_set_gpio_direction(MX27_PIN_ATA_DATA12, 1);
+	gpio_request_mux(MX27_PIN_ATA_DATA11, GPIO_MUX_INPUT1);
+	mxc_set_gpio_direction(MX27_PIN_ATA_DATA11, 1);
+	gpio_request_mux(MX27_PIN_ATA_DATA10, GPIO_MUX_INPUT1);
+	mxc_set_gpio_direction(MX27_PIN_ATA_DATA10, 1);
+	gpio_request_mux(MX27_PIN_ATA_DATA9, GPIO_MUX_INPUT1);
+	mxc_set_gpio_direction(MX27_PIN_ATA_DATA9, 1);
+	gpio_request_mux(MX27_PIN_ATA_DATA8, GPIO_MUX_INPUT1);
+	mxc_set_gpio_direction(MX27_PIN_ATA_DATA8, 1);
+	gpio_request_mux(MX27_PIN_ATA_DATA7, GPIO_MUX_OUTPUT1);
+	mxc_set_gpio_direction(MX27_PIN_ATA_DATA7, 0);
+
+	gpio_request_mux(MX27_PIN_ATA_DATA6, GPIO_MUX_ALT);
+	gpio_request_mux(MX27_PIN_ATA_DATA5, GPIO_MUX_INPUT1);
+	mxc_set_gpio_direction(MX27_PIN_ATA_DATA5, 1);
+	gpio_request_mux(MX27_PIN_ATA_DATA4, GPIO_MUX_INPUT1);
+	mxc_set_gpio_direction(MX27_PIN_ATA_DATA4, 1);
+	gpio_request_mux(MX27_PIN_ATA_DATA3, GPIO_MUX_INPUT1);
+	mxc_set_gpio_direction(MX27_PIN_ATA_DATA3, 1);
+	gpio_request_mux(MX27_PIN_ATA_DATA2, GPIO_MUX_INPUT1);
+	mxc_set_gpio_direction(MX27_PIN_ATA_DATA2, 1);
+	gpio_request_mux(MX27_PIN_ATA_DATA1, GPIO_MUX_OUTPUT1);
+	mxc_set_gpio_direction(MX27_PIN_ATA_DATA1, 0);
+	gpio_request_mux(MX27_PIN_ATA_DATA0, GPIO_MUX_OUTPUT1);
+	mxc_set_gpio_direction(MX27_PIN_ATA_DATA0, 0);
+	gpio_request_mux(MX27_PIN_SD3_CLK, GPIO_MUX_OUTPUT1);
+	mxc_set_gpio_direction(MX27_PIN_SD3_CLK, 0);
+	gpio_request_mux(MX27_PIN_SD3_CMD, GPIO_MUX_OUTPUT1);
+	mxc_set_gpio_direction(MX27_PIN_SD3_CMD, 0);
+
+	__raw_writew(PBC_BCTRL2_ATAFEC_EN, PBC_BCTRL2_CLEAR_REG);
+	__raw_writew(PBC_BCTRL2_ATAFEC_SEL, PBC_BCTRL2_SET_REG);
+}
+
+/*!
+ * Setup GPIO for FEC device to be inactive
+ *
+ */
+void gpio_fec_inactive(void)
+{
+	gpio_free_mux(MX27_PIN_ATA_DATA0);
+	gpio_free_mux(MX27_PIN_ATA_DATA1);
+	gpio_free_mux(MX27_PIN_ATA_DATA2);
+	gpio_free_mux(MX27_PIN_ATA_DATA3);
+	gpio_free_mux(MX27_PIN_ATA_DATA4);
+	gpio_free_mux(MX27_PIN_ATA_DATA5);
+	gpio_free_mux(MX27_PIN_ATA_DATA6);
+	gpio_free_mux(MX27_PIN_ATA_DATA7);
+	gpio_free_mux(MX27_PIN_ATA_DATA8);
+	gpio_free_mux(MX27_PIN_ATA_DATA9);
+	gpio_free_mux(MX27_PIN_ATA_DATA10);
+	gpio_free_mux(MX27_PIN_ATA_DATA11);
+	gpio_free_mux(MX27_PIN_ATA_DATA12);
+	gpio_free_mux(MX27_PIN_ATA_DATA13);
+	gpio_free_mux(MX27_PIN_ATA_DATA14);
+	gpio_free_mux(MX27_PIN_ATA_DATA15);
+
+	gpio_free_mux(MX27_PIN_SD3_CMD);
+	gpio_free_mux(MX27_PIN_SD3_CLK);
+}
+
+/*!
+ * Setup GPIO for SLCDC device to be active
+ *
+ */
+void gpio_slcdc_active(int type)
+{
+	switch (type) {
+	case 0:
+		gpio_request_mux(MX27_PIN_SSI3_CLK, GPIO_MUX_ALT);	/* CLK */
+		gpio_request_mux(MX27_PIN_SSI3_TXDAT, GPIO_MUX_ALT);	/* CS  */
+		gpio_request_mux(MX27_PIN_SSI3_RXDAT, GPIO_MUX_ALT);	/* RS  */
+		gpio_request_mux(MX27_PIN_SSI3_FS, GPIO_MUX_ALT);	/* D0  */
+		break;
+
+	case 1:
+		gpio_request_mux(MX27_PIN_SD2_D1, GPIO_MUX_GPIO);	/* CLK */
+		gpio_request_mux(MX27_PIN_SD2_D2, GPIO_MUX_GPIO);	/* D0  */
+		gpio_request_mux(MX27_PIN_SD2_D3, GPIO_MUX_GPIO);	/* RS  */
+		gpio_request_mux(MX27_PIN_SD2_CMD, GPIO_MUX_GPIO);	/* CS  */
+		break;
+
+	case 2:
+		gpio_request_mux(MX27_PIN_LD0, GPIO_MUX_GPIO);
+		gpio_request_mux(MX27_PIN_LD1, GPIO_MUX_GPIO);
+		gpio_request_mux(MX27_PIN_LD2, GPIO_MUX_GPIO);
+		gpio_request_mux(MX27_PIN_LD3, GPIO_MUX_GPIO);
+		gpio_request_mux(MX27_PIN_LD4, GPIO_MUX_GPIO);
+		gpio_request_mux(MX27_PIN_LD5, GPIO_MUX_GPIO);
+		gpio_request_mux(MX27_PIN_LD6, GPIO_MUX_GPIO);
+		gpio_request_mux(MX27_PIN_LD7, GPIO_MUX_GPIO);
+		gpio_request_mux(MX27_PIN_LD8, GPIO_MUX_GPIO);
+		gpio_request_mux(MX27_PIN_LD9, GPIO_MUX_GPIO);
+		gpio_request_mux(MX27_PIN_LD10, GPIO_MUX_GPIO);
+		gpio_request_mux(MX27_PIN_LD11, GPIO_MUX_GPIO);
+		gpio_request_mux(MX27_PIN_LD12, GPIO_MUX_GPIO);
+		gpio_request_mux(MX27_PIN_LD13, GPIO_MUX_GPIO);
+		gpio_request_mux(MX27_PIN_LD14, GPIO_MUX_GPIO);
+		gpio_request_mux(MX27_PIN_LD15, GPIO_MUX_GPIO);
+		break;
+
+	default:
+		break;
+	}
+
+	return;
+}
+
+/*!
+ * Setup GPIO for SLCDC device to be inactive
+ *
+ */
+void gpio_slcdc_inactive(int type)
+{
+	switch (type) {
+	case 0:
+		gpio_free_mux(MX27_PIN_SSI3_CLK);	/* CLK */
+		gpio_free_mux(MX27_PIN_SSI3_TXDAT);	/* CS  */
+		gpio_free_mux(MX27_PIN_SSI3_RXDAT);	/* RS  */
+		gpio_free_mux(MX27_PIN_SSI3_FS);	/* D0  */
+		break;
+
+	case 1:
+		gpio_free_mux(MX27_PIN_SD2_D1);	/* CLK */
+		gpio_free_mux(MX27_PIN_SD2_D2);	/* D0  */
+		gpio_free_mux(MX27_PIN_SD2_D3);	/* RS  */
+		gpio_free_mux(MX27_PIN_SD2_CMD);	/* CS  */
+		break;
+
+	case 2:
+		gpio_free_mux(MX27_PIN_LD0);
+		gpio_free_mux(MX27_PIN_LD1);
+		gpio_free_mux(MX27_PIN_LD2);
+		gpio_free_mux(MX27_PIN_LD3);
+		gpio_free_mux(MX27_PIN_LD4);
+		gpio_free_mux(MX27_PIN_LD5);
+		gpio_free_mux(MX27_PIN_LD6);
+		gpio_free_mux(MX27_PIN_LD7);
+		gpio_free_mux(MX27_PIN_LD8);
+		gpio_free_mux(MX27_PIN_LD9);
+		gpio_free_mux(MX27_PIN_LD10);
+		gpio_free_mux(MX27_PIN_LD11);
+		gpio_free_mux(MX27_PIN_LD12);
+		gpio_free_mux(MX27_PIN_LD13);
+		gpio_free_mux(MX27_PIN_LD14);
+		gpio_free_mux(MX27_PIN_LD15);
+		break;
+
+	default:
+		break;
+	}
+
+	return;
+}
+
+void gpio_ssi_active(int ssi_num)
+{
+	switch (ssi_num) {
+	case 0:
+		gpio_request_mux(MX27_PIN_SSI1_FS, GPIO_MUX_PRIMARY);
+		gpio_request_mux(MX27_PIN_SSI1_RXDAT, GPIO_MUX_PRIMARY);
+		gpio_request_mux(MX27_PIN_SSI1_TXDAT, GPIO_MUX_PRIMARY);
+		gpio_request_mux(MX27_PIN_SSI1_CLK, GPIO_MUX_PRIMARY);
+		gpio_set_puen(MX27_PIN_SSI1_FS, 0);
+		gpio_set_puen(MX27_PIN_SSI1_RXDAT, 0);
+		gpio_set_puen(MX27_PIN_SSI1_TXDAT, 0);
+		gpio_set_puen(MX27_PIN_SSI1_CLK, 0);
+		break;
+	case 1:
+		gpio_request_mux(MX27_PIN_SSI2_FS, GPIO_MUX_PRIMARY);
+		gpio_request_mux(MX27_PIN_SSI2_RXDAT, GPIO_MUX_PRIMARY);
+		gpio_request_mux(MX27_PIN_SSI2_TXDAT, GPIO_MUX_PRIMARY);
+		gpio_request_mux(MX27_PIN_SSI2_CLK, GPIO_MUX_PRIMARY);
+		gpio_set_puen(MX27_PIN_SSI2_FS, 0);
+		gpio_set_puen(MX27_PIN_SSI2_RXDAT, 0);
+		gpio_set_puen(MX27_PIN_SSI2_TXDAT, 0);
+		gpio_set_puen(MX27_PIN_SSI2_CLK, 0);
+		break;
+	default:
+		break;
+	}
+	return;
+}
+
+/*!
+ *  * Setup GPIO for a SSI port to be inactive
+ *   *
+ *    * @param  ssi_num         an SSI port num
+ */
+
+void gpio_ssi_inactive(int ssi_num)
+{
+	switch (ssi_num) {
+	case 0:
+		gpio_free_mux(MX27_PIN_SSI1_FS);
+		gpio_free_mux(MX27_PIN_SSI1_RXDAT);
+		gpio_free_mux(MX27_PIN_SSI1_TXDAT);
+		gpio_free_mux(MX27_PIN_SSI1_CLK);
+		break;
+	case 1:
+		gpio_free_mux(MX27_PIN_SSI2_FS);
+		gpio_free_mux(MX27_PIN_SSI2_RXDAT);
+		gpio_free_mux(MX27_PIN_SSI2_TXDAT);
+		gpio_free_mux(MX27_PIN_SSI2_CLK);
+		break;
+	default:
+		break;
+	}
+	return;
+}
+
+/*!
+ * Setup GPIO for SDHC to be active
+ *
+ * @param module SDHC module number
+ */
+void gpio_sdhc_active(int module)
+{
+	u16 data;
+	switch (module) {
+	case 0:
+		gpio_request_mux(MX27_PIN_SD1_CLK, GPIO_MUX_PRIMARY);
+		gpio_request_mux(MX27_PIN_SD1_CMD, GPIO_MUX_PRIMARY);
+		gpio_request_mux(MX27_PIN_SD1_D0, GPIO_MUX_PRIMARY);
+		gpio_request_mux(MX27_PIN_SD1_D1, GPIO_MUX_PRIMARY);
+		gpio_request_mux(MX27_PIN_SD1_D2, GPIO_MUX_PRIMARY);
+		gpio_request_mux(MX27_PIN_SD1_D3, GPIO_MUX_PRIMARY);
+		/* 22k pull up for sd1 dat3 pins */
+		data = __raw_readw(IO_ADDRESS(SYSCTRL_BASE_ADDR + 0x54));
+		data |= 0x0c;
+		__raw_writew(data, IO_ADDRESS(SYSCTRL_BASE_ADDR + 0x54));
+		/*mxc_clks_enable(SDHC1_CLK);
+		   mxc_clks_enable(PERCLK2); */
+		break;
+	case 1:
+		gpio_request_mux(MX27_PIN_SD2_CLK, GPIO_MUX_PRIMARY);
+		gpio_request_mux(MX27_PIN_SD2_CMD, GPIO_MUX_PRIMARY);
+		gpio_request_mux(MX27_PIN_SD2_D0, GPIO_MUX_PRIMARY);
+		gpio_request_mux(MX27_PIN_SD2_D1, GPIO_MUX_PRIMARY);
+		gpio_request_mux(MX27_PIN_SD2_D2, GPIO_MUX_PRIMARY);
+		gpio_request_mux(MX27_PIN_SD2_D3, GPIO_MUX_PRIMARY);
+		/* 22k pull up for sd2 pins */
+		data = __raw_readw(IO_ADDRESS(SYSCTRL_BASE_ADDR + 0x54));
+		data &= ~0xfff0;
+		data |= 0xfff0;
+		__raw_writew(data, IO_ADDRESS(SYSCTRL_BASE_ADDR + 0x54));
+		/*mxc_clks_enable(SDHC2_CLK);
+		   mxc_clks_enable(PERCLK2); */
+		break;
+	case 2:
+		gpio_request_mux(MX27_PIN_SD3_CLK, GPIO_MUX_PRIMARY);
+		gpio_request_mux(MX27_PIN_SD3_CMD, GPIO_MUX_PRIMARY);
+		gpio_request_mux(MX27_PIN_ATA_DATA0, GPIO_MUX_ALT);
+		gpio_request_mux(MX27_PIN_ATA_DATA1, GPIO_MUX_ALT);
+		gpio_request_mux(MX27_PIN_ATA_DATA2, GPIO_MUX_ALT);
+		gpio_request_mux(MX27_PIN_ATA_DATA3, GPIO_MUX_ALT);
+		/*mxc_clks_enable(SDHC3_CLK);
+		   mxc_clks_enable(PERCLK2); */
+		break;
+	default:
+		break;
+	}
+}
+
+/*!
+ * Setup GPIO for SDHC1 to be inactive
+ *
+ * @param module SDHC module number
+ */
+void gpio_sdhc_inactive(int module)
+{
+	switch (module) {
+	case 0:
+		gpio_free_mux(MX27_PIN_SD1_CLK);
+		gpio_free_mux(MX27_PIN_SD1_CMD);
+		gpio_free_mux(MX27_PIN_SD1_D0);
+		gpio_free_mux(MX27_PIN_SD1_D1);
+		gpio_free_mux(MX27_PIN_SD1_D2);
+		gpio_free_mux(MX27_PIN_SD1_D3);
+		/*mxc_clks_disable(SDHC1_CLK); */
+		break;
+	case 1:
+		gpio_free_mux(MX27_PIN_SD2_CLK);
+		gpio_free_mux(MX27_PIN_SD2_CMD);
+		gpio_free_mux(MX27_PIN_SD2_D0);
+		gpio_free_mux(MX27_PIN_SD2_D1);
+		gpio_free_mux(MX27_PIN_SD2_D2);
+		gpio_free_mux(MX27_PIN_SD2_D3);
+		/*mxc_clks_disable(SDHC2_CLK); */
+		break;
+	case 2:
+		gpio_free_mux(MX27_PIN_SD3_CLK);
+		gpio_free_mux(MX27_PIN_SD3_CMD);
+		gpio_free_mux(MX27_PIN_ATA_DATA0);
+		gpio_free_mux(MX27_PIN_ATA_DATA1);
+		gpio_free_mux(MX27_PIN_ATA_DATA2);
+		gpio_free_mux(MX27_PIN_ATA_DATA3);
+		/*mxc_clks_disable(SDHC3_CLK); */
+		break;
+	default:
+		break;
+	}
+}
+
+/*
+ * Probe for the card. If present the GPIO data would be set.
+ */
+int sdhc_get_card_det_status(struct device *dev)
+{
+	return 0;
+}
+
+/*
+ * Return the card detect pin.
+ */
+int sdhc_init_card_det(int id)
+{
+	int ret = 0;
+	switch (id) {
+	case 0:
+		ret = EXPIO_INT_SD1_EN;
+		break;
+	case 1:
+		ret = EXPIO_INT_SD2_EN;
+		break;
+	default:
+		ret = 0;
+		break;
+	}
+	return ret;
+}
+
+/*
+ * Power on/off Sharp QVGA panel.
+ */
+void board_power_lcd(int on)
+{
+	if (on)
+		__raw_writew(PBC_BCTRL1_LCDON, PBC_BCTRL1_SET_REG);
+	else
+		__raw_writew(PBC_BCTRL1_LCDON, PBC_BCTRL1_CLEAR_REG);
+}
+
+void gpio_owire_active(void)
+{
+	gpio_request_mux(MX27_PIN_RTCK, GPIO_MUX_ALT);
+}
+
+void gpio_owire_inactive(void)
+{
+	gpio_request_mux(MX27_PIN_RTCK, GPIO_MUX_PRIMARY);
+}
+
+void gpio_irda_active(void)
+{
+	gpio_uart_active(2, 0);
+	mxc_clks_enable(UART2_BAUD);
+	/* Band width select */
+	//__raw_writew(PBC_BCTRL2_IRDA_SD, PBC_BCTRL2_SET_REG);
+}
+
+void gpio_irda_inactive(void)
+{
+	mxc_clks_disable(UART2_BAUD);
+	gpio_uart_inactive(2, 0);
+}
+
+unsigned int irda_get_clocks(void)
+{
+	return mxc_get_clocks(UART2_BAUD);
+}
+
+EXPORT_SYMBOL(gpio_uart_active);
+EXPORT_SYMBOL(gpio_uart_inactive);
+EXPORT_SYMBOL(config_uartdma_event);
+EXPORT_SYMBOL(gpio_usbh1_active);
+EXPORT_SYMBOL(gpio_usbh1_inactive);
+EXPORT_SYMBOL(gpio_usbh2_active);
+EXPORT_SYMBOL(gpio_usbh2_inactive);
+EXPORT_SYMBOL(gpio_usbotg_hs_active);
+EXPORT_SYMBOL(gpio_usbotg_hs_inactive);
+EXPORT_SYMBOL(gpio_usbotg_fs_active);
+EXPORT_SYMBOL(gpio_usbotg_fs_inactive);
+EXPORT_SYMBOL(gpio_i2c_active);
+EXPORT_SYMBOL(gpio_i2c_inactive);
+EXPORT_SYMBOL(gpio_spi_active);
+EXPORT_SYMBOL(gpio_spi_inactive);
+EXPORT_SYMBOL(gpio_nand_active);
+EXPORT_SYMBOL(gpio_nand_inactive);
+EXPORT_SYMBOL(gpio_sensor_active);
+EXPORT_SYMBOL(gpio_sensor_inactive);
+EXPORT_SYMBOL(gpio_lcdc_active);
+EXPORT_SYMBOL(gpio_lcdc_inactive);
+EXPORT_SYMBOL(gpio_fs453_reset_low);
+EXPORT_SYMBOL(gpio_fs453_reset_high);
+EXPORT_SYMBOL(gpio_pmic_active);
+EXPORT_SYMBOL(gpio_keypad_active);
+EXPORT_SYMBOL(gpio_keypad_inactive);
+EXPORT_SYMBOL(gpio_ata_active);
+EXPORT_SYMBOL(gpio_ata_inactive);
+EXPORT_SYMBOL(gpio_fec_active);
+EXPORT_SYMBOL(gpio_fec_inactive);
+EXPORT_SYMBOL(gpio_slcdc_active);
+EXPORT_SYMBOL(gpio_slcdc_inactive);
+EXPORT_SYMBOL(gpio_ssi_active);
+EXPORT_SYMBOL(gpio_ssi_inactive);
+EXPORT_SYMBOL(gpio_sdhc_active);
+EXPORT_SYMBOL(gpio_sdhc_inactive);
+EXPORT_SYMBOL(sdhc_get_card_det_status);
+EXPORT_SYMBOL(sdhc_init_card_det);
+EXPORT_SYMBOL(board_power_lcd);
+EXPORT_SYMBOL(gpio_owire_active);
+EXPORT_SYMBOL(gpio_owire_inactive);
+EXPORT_SYMBOL(gpio_irda_active);
+EXPORT_SYMBOL(gpio_irda_inactive);
+EXPORT_SYMBOL(irda_get_clocks);
+
diff --git a/arch/arm/mach-mx27/serial.c b/arch/arm/mach-mx27/serial.c
new file mode 100644
index 0000000..0153ae9
--- /dev/null
+++ b/arch/arm/mach-mx27/serial.c
@@ -0,0 +1,269 @@
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+/*!
+ * @file serial.c
+ *
+ * @brief This file contains the UART initiliazation.
+ *
+ * @ingroup System
+ */
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/serial.h>
+#include <asm/hardware.h>
+#include <asm/arch/mxc_uart.h>
+#include "serial.h"
+
+#if defined(CONFIG_SERIAL_MXC) || defined(CONFIG_SERIAL_MXC_MODULE)
+
+/*!
+ * This is an array where each element holds information about a UART port,
+ * like base address of the UART, interrupt numbers etc. This structure is
+ * passed to the serial_core.c file. Based on which UART is used, the core file
+ * passes back the appropriate port structure as an argument to the control
+ * functions.
+ */
+static uart_mxc_port mxc_ports[] = {
+	[0] = {
+	       .port = {
+			.membase = (void *)IO_ADDRESS(UART1_BASE_ADDR),
+			.mapbase = UART1_BASE_ADDR,
+			.iotype = SERIAL_IO_MEM,
+			.irq = UART1_INT1,
+			.fifosize = 32,
+			.flags = ASYNC_BOOT_AUTOCONF,
+			.line = 0,
+			},
+	       .ints_muxed = UART1_MUX_INTS,
+	       .irqs = {UART1_INT2, UART1_INT3},
+	       .mode = UART1_MODE,
+	       .ir_mode = UART1_IR,
+	       .enabled = UART1_ENABLED,
+	       .hardware_flow = UART1_HW_FLOW,
+	       .cts_threshold = UART1_UCR4_CTSTL,
+	       .dma_enabled = UART1_DMA_ENABLE,
+	       .dma_rxbuf_size = UART1_DMA_RXBUFSIZE,
+	       .rx_threshold = UART1_UFCR_RXTL,
+	       .tx_threshold = UART1_UFCR_TXTL,
+	       .shared = UART1_SHARED_PERI,
+	       .clock_id = UART1_BAUD,
+	       .dma_tx_id = MXC_DMA_UART1_TX,
+	       .dma_rx_id = MXC_DMA_UART1_RX,
+	       .rxd_mux = MXC_UART_RXDMUX,
+	       },
+	[1] = {
+	       .port = {
+			.membase = (void *)IO_ADDRESS(UART2_BASE_ADDR),
+			.mapbase = UART2_BASE_ADDR,
+			.iotype = SERIAL_IO_MEM,
+			.irq = UART2_INT1,
+			.fifosize = 32,
+			.flags = ASYNC_BOOT_AUTOCONF,
+			.line = 1,
+			},
+	       .ints_muxed = UART2_MUX_INTS,
+	       .irqs = {UART2_INT2, UART2_INT3},
+	       .mode = UART2_MODE,
+	       .ir_mode = UART2_IR,
+	       .enabled = UART2_ENABLED,
+	       .hardware_flow = UART2_HW_FLOW,
+	       .cts_threshold = UART2_UCR4_CTSTL,
+	       .dma_enabled = UART2_DMA_ENABLE,
+	       .dma_rxbuf_size = UART2_DMA_RXBUFSIZE,
+	       .rx_threshold = UART2_UFCR_RXTL,
+	       .tx_threshold = UART2_UFCR_TXTL,
+	       .shared = UART2_SHARED_PERI,
+	       .clock_id = UART2_BAUD,
+	       .dma_tx_id = MXC_DMA_UART2_TX,
+	       .dma_rx_id = MXC_DMA_UART2_RX,
+	       .rxd_mux = MXC_UART_RXDMUX,
+	       },
+	[2] = {
+	       .port = {
+			.membase = (void *)IO_ADDRESS(UART3_BASE_ADDR),
+			.mapbase = UART3_BASE_ADDR,
+			.iotype = SERIAL_IO_MEM,
+			.irq = UART3_INT1,
+			.fifosize = 32,
+			.flags = ASYNC_BOOT_AUTOCONF,
+			.line = 2,
+			},
+	       .ints_muxed = UART3_MUX_INTS,
+	       .irqs = {UART3_INT2, UART3_INT3},
+	       .mode = UART3_MODE,
+	       .ir_mode = UART3_IR,
+	       .enabled = UART3_ENABLED,
+	       .hardware_flow = UART3_HW_FLOW,
+	       .cts_threshold = UART3_UCR4_CTSTL,
+	       .dma_enabled = UART3_DMA_ENABLE,
+	       .dma_rxbuf_size = UART3_DMA_RXBUFSIZE,
+	       .rx_threshold = UART3_UFCR_RXTL,
+	       .tx_threshold = UART3_UFCR_TXTL,
+	       .shared = UART3_SHARED_PERI,
+	       .clock_id = UART3_BAUD,
+	       .dma_tx_id = MXC_DMA_UART3_TX,
+	       .dma_rx_id = MXC_DMA_UART3_RX,
+	       .rxd_mux = MXC_UART_IR_RXDMUX,
+	       },
+	[3] = {
+	       .port = {
+			.membase = (void *)IO_ADDRESS(UART4_BASE_ADDR),
+			.mapbase = UART4_BASE_ADDR,
+			.iotype = SERIAL_IO_MEM,
+			.irq = UART4_INT1,
+			.fifosize = 32,
+			.flags = ASYNC_BOOT_AUTOCONF,
+			.line = 3,
+			},
+	       .ints_muxed = UART4_MUX_INTS,
+	       .irqs = {UART4_INT2, UART4_INT3},
+	       .mode = UART4_MODE,
+	       .ir_mode = UART4_IR,
+	       .enabled = UART4_ENABLED,
+	       .hardware_flow = UART4_HW_FLOW,
+	       .cts_threshold = UART4_UCR4_CTSTL,
+	       .dma_enabled = UART4_DMA_ENABLE,
+	       .dma_rxbuf_size = UART4_DMA_RXBUFSIZE,
+	       .rx_threshold = UART4_UFCR_RXTL,
+	       .tx_threshold = UART4_UFCR_TXTL,
+	       .shared = UART4_SHARED_PERI,
+	       .clock_id = UART4_BAUD,
+	       .dma_tx_id = MXC_DMA_UART4_TX,
+	       .dma_rx_id = MXC_DMA_UART4_RX,
+	       .rxd_mux = MXC_UART_RXDMUX,
+	       },
+	[4] = {
+	       .port = {
+			.membase = (void *)IO_ADDRESS(UART5_BASE_ADDR),
+			.mapbase = UART5_BASE_ADDR,
+			.iotype = SERIAL_IO_MEM,
+			.irq = UART5_INT1,
+			.fifosize = 32,
+			.flags = ASYNC_BOOT_AUTOCONF,
+			.line = 4,
+			},
+	       .ints_muxed = UART5_MUX_INTS,
+	       .irqs = {UART5_INT2, UART5_INT3},
+	       .mode = UART5_MODE,
+	       .ir_mode = UART5_IR,
+	       .enabled = UART5_ENABLED,
+	       .hardware_flow = UART5_HW_FLOW,
+	       .cts_threshold = UART5_UCR4_CTSTL,
+	       .dma_enabled = UART5_DMA_ENABLE,
+	       .dma_rxbuf_size = UART5_DMA_RXBUFSIZE,
+	       .rx_threshold = UART5_UFCR_RXTL,
+	       .tx_threshold = UART5_UFCR_TXTL,
+	       .shared = UART5_SHARED_PERI,
+	       .clock_id = UART5_BAUD,
+	       .dma_tx_id = MXC_DMA_UART5_TX,
+	       .dma_rx_id = MXC_DMA_UART5_RX,
+	       .rxd_mux = MXC_UART_RXDMUX,
+	       },
+	[5] = {
+	       .port = {
+			.membase = (void *)IO_ADDRESS(UART6_BASE_ADDR),
+			.mapbase = UART6_BASE_ADDR,
+			.iotype = SERIAL_IO_MEM,
+			.irq = UART6_INT1,
+			.fifosize = 32,
+			.flags = ASYNC_BOOT_AUTOCONF,
+			.line = 5,
+			},
+	       .ints_muxed = UART6_MUX_INTS,
+	       .irqs = {UART6_INT2, UART6_INT3},
+	       .mode = UART6_MODE,
+	       .ir_mode = UART6_IR,
+	       .enabled = UART6_ENABLED,
+	       .hardware_flow = UART6_HW_FLOW,
+	       .cts_threshold = UART6_UCR4_CTSTL,
+	       .dma_enabled = UART6_DMA_ENABLE,
+	       .dma_rxbuf_size = UART6_DMA_RXBUFSIZE,
+	       .rx_threshold = UART6_UFCR_RXTL,
+	       .tx_threshold = UART6_UFCR_TXTL,
+	       .shared = UART6_SHARED_PERI,
+	       .clock_id = UART6_BAUD,
+	       .dma_tx_id = MXC_DMA_UART6_TX,
+	       .dma_rx_id = MXC_DMA_UART6_RX,
+	       .rxd_mux = MXC_UART_RXDMUX,
+	       },
+};
+
+static struct platform_device mxc_uart_device1 = {
+	.name = "mxcintuart",
+	.id = 0,
+	.dev = {
+		.platform_data = &mxc_ports[0],
+		},
+};
+
+static struct platform_device mxc_uart_device2 = {
+	.name = "mxcintuart",
+	.id = 1,
+	.dev = {
+		.platform_data = &mxc_ports[1],
+		},
+};
+
+static struct platform_device mxc_uart_device3 = {
+	.name = "mxcintuart",
+	.id = 2,
+	.dev = {
+		.platform_data = &mxc_ports[2],
+		},
+};
+
+static struct platform_device mxc_uart_device4 = {
+	.name = "mxcintuart",
+	.id = 3,
+	.dev = {
+		.platform_data = &mxc_ports[3],
+		},
+};
+static struct platform_device mxc_uart_device5 = {
+	.name = "mxcintuart",
+	.id = 4,
+	.dev = {
+		.platform_data = &mxc_ports[4],
+		},
+};
+static struct platform_device mxc_uart_device6 = {
+	.name = "mxcintuart",
+	.id = 5,
+	.dev = {
+		.platform_data = &mxc_ports[5],
+		},
+};
+
+static int __init mxc_init_uart(void)
+{
+	/* Register all the MXC UART platform device structures */
+	platform_device_register(&mxc_uart_device1);
+	platform_device_register(&mxc_uart_device2);
+#ifndef CONFIG_MXC_IRDA
+	platform_device_register(&mxc_uart_device3);
+#endif
+	platform_device_register(&mxc_uart_device4);
+
+	platform_device_register(&mxc_uart_device5);
+	platform_device_register(&mxc_uart_device6);
+	return 0;
+}
+
+#else
+static int __init mxc_init_uart(void)
+{
+	return 0;
+}
+#endif
+
+arch_initcall(mxc_init_uart);
diff --git a/arch/arm/mach-mx27/serial.h b/arch/arm/mach-mx27/serial.h
new file mode 100644
index 0000000..1b22c31
--- /dev/null
+++ b/arch/arm/mach-mx27/serial.h
@@ -0,0 +1,165 @@
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#ifndef __ARCH_ARM_MACH_MX27_SERIAL_H__
+#define __ARCH_ARM_MACH_MX27_SERIAL_H__
+
+#include <asm/arch/mxc_uart.h>
+
+/* UART 1 configuration */
+/*!
+ * This option allows to choose either an interrupt-driven software controlled
+ * hardware flow control (set this option to 0) or hardware-driven hardware
+ * flow control (set this option to 1).
+ */
+#define UART1_HW_FLOW           1
+/*!
+ * This specifies the threshold at which the CTS pin is deasserted by the
+ * RXFIFO. Set this value in Decimal to anything from 0 to 32 for
+ * hardware-driven hardware flow control. Read the HW spec while specifying
+ * this value. When using interrupt-driven software controlled hardware
+ * flow control set this option to -1.
+ */
+#define UART1_UCR4_CTSTL        16
+/*!
+ * This is option to enable (set this option to 1) or disable DMA data transfer
+ */
+#define UART1_DMA_ENABLE        0
+/*!
+ * Specify the size of the DMA receive buffer. The buffer size should be same with
+ * sub buffer size which is defined in mxc_uart.c for all data can be transfered.
+ */
+#define UART1_DMA_RXBUFSIZE     128
+/*!
+ * Specify the MXC UART's Receive Trigger Level. This controls the threshold at
+ * which a maskable interrupt is generated by the RxFIFO. Set this value in
+ * Decimal to anything from 0 to 32. Read the HW spec while specifying this
+ * value.
+ */
+#define UART1_UFCR_RXTL         16
+/*!
+ * Specify the MXC UART's Transmit Trigger Level. This controls the threshold at
+ * which a maskable interrupt is generated by the TxFIFO. Set this value in
+ * Decimal to anything from 0 to 32. Read the HW spec while specifying this
+ * value.
+ */
+#define UART1_UFCR_TXTL		16
+/* UART 2 configuration */
+#define UART2_HW_FLOW		1
+#define UART2_UCR4_CTSTL	16
+#define UART2_DMA_ENABLE	0
+#define UART2_DMA_RXBUFSIZE	512
+#define UART2_UFCR_RXTL		16
+#define UART2_UFCR_TXTL		16
+/* UART 3 configuration */
+#define UART3_HW_FLOW		0
+#define UART3_UCR4_CTSTL	-1
+#define UART3_DMA_ENABLE	0
+#define UART3_DMA_RXBUFSIZE	512
+#define UART3_UFCR_RXTL		16
+#define UART3_UFCR_TXTL		16
+/* UART 4 configuration */
+#define UART4_HW_FLOW		1
+#define UART4_UCR4_CTSTL	16
+#define UART4_DMA_ENABLE	0
+#define UART4_DMA_RXBUFSIZE	512
+#define UART4_UFCR_RXTL		16
+#define UART4_UFCR_TXTL		16
+/* UART 5 configuration */
+#define UART5_HW_FLOW		1
+#define UART5_UCR4_CTSTL	16
+#define UART5_DMA_ENABLE	0
+#define UART5_DMA_RXBUFSIZE	512
+#define UART5_UFCR_RXTL		16
+#define UART5_UFCR_TXTL		16
+/* UART 6 configuration */
+#define UART6_HW_FLOW		1
+#define UART6_UCR4_CTSTL	16
+#define UART6_DMA_ENABLE	0
+#define UART6_DMA_RXBUFSIZE	512
+#define UART6_UFCR_RXTL		16
+#define UART6_UFCR_TXTL		16
+/*
+ * UART Chip level Configuration that a user may not have to edit. These
+ * configuration vary depending on how the UART module is integrated with
+ * the ARM core
+ */
+/*
+ * Is the MUXED interrupt output sent to the ARM core
+ */
+#define INTS_NOTMUXED		0
+#define INTS_MUXED		1
+/* UART 1 configuration */
+/*!
+ * This define specifies whether the muxed ANDed interrupt line or the
+ * individual interrupts from the UART port is integrated with the ARM core.
+ * There exists a define like this for each UART port. Valid values that can
+ * be used are \b INTS_NOTMUXED or \b INTS_MUXED.
+ */
+#define UART1_MUX_INTS		INTS_MUXED
+/*!
+ * This define specifies the transmitter interrupt number or the interrupt
+ * number of the ANDed interrupt in case the interrupts are muxed. There exists
+ * a define like this for each UART port.
+ */
+#define UART1_INT1		INT_UART1
+/*!
+ * This define specifies the receiver interrupt number. If the interrupts of
+ * the UART are muxed, then we specify here a dummy value -1. There exists a
+ * define like this for each UART port.
+ */
+#define UART1_INT2		-1
+/*!
+ * This specifies the master interrupt number. If the interrupts of the UART
+ * are muxed, then we specify here a dummy value of -1. There exists a define
+ * like this for each UART port.
+ */
+#define UART1_INT3		-1
+/*!
+ * This specifies if the UART is a shared peripheral. It holds the shared
+ * peripheral number if it is shared or -1 if it is not shared. There exists
+ * a define like this for each UART port.
+ */
+#define UART1_SHARED_PERI	-1
+/* UART 2 configuration */
+#define UART2_MUX_INTS		INTS_MUXED
+#define UART2_INT1		INT_UART2
+#define UART2_INT2		-1
+#define UART2_INT3		-1
+#define UART2_SHARED_PERI	-1
+/* UART 3 configuration */
+#define UART3_MUX_INTS		INTS_MUXED
+#define UART3_INT1		INT_UART3
+#define UART3_INT2		-1
+#define UART3_INT3		-1
+#define UART3_SHARED_PERI	-1
+/* UART 4 configuration */
+#define UART4_MUX_INTS		INTS_MUXED
+#define UART4_INT1		INT_UART4
+#define UART4_INT2		-1
+#define UART4_INT3		-1
+#define UART4_SHARED_PERI	-1
+/* UART 5 configuration */
+#define UART5_MUX_INTS		INTS_MUXED
+#define UART5_INT1		INT_UART5
+#define UART5_INT2		-1
+#define UART5_INT3		-1
+#define UART5_SHARED_PERI	-1
+/* UART 6 configuration */
+#define UART6_MUX_INTS		INTS_MUXED
+#define UART6_INT1		INT_UART6
+#define UART6_INT2		-1
+#define UART6_INT3		-1
+#define UART6_SHARED_PERI	-1
+
+#endif				/* __ARCH_ARM_MACH_MX27_SERIAL_H__ */
diff --git a/arch/arm/mach-mx27/system.c b/arch/arm/mach-mx27/system.c
new file mode 100644
index 0000000..526ce2f
--- /dev/null
+++ b/arch/arm/mach-mx27/system.c
@@ -0,0 +1,69 @@
+/*
+ * Copyright (C) 1999 ARM Limited
+ * Copyright (C) 2000 Deep Blue Solutions Ltd
+ * Copyright 2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <asm/io.h>
+#include <asm/arch/hardware.h>
+#include <asm/proc-fns.h>
+#include <asm/system.h>
+#include <asm/arch/clock.h>
+
+/*!
+ * @defgroup MSL Machine Specific Layer (MSL)
+ */
+
+/*!
+ * @defgroup System System-wide Misc Files for MSL
+ * @ingroup MSL
+ */
+
+/*!
+ * @file system.c
+ * @brief This file contains idle and reset functions.
+ *
+ * @ingroup System
+ */
+
+/*!
+ * This function puts the CPU into idle mode. It is called by default_idle()
+ * in process.c file.
+ */
+void arch_idle(void)
+{
+	/*
+	 * This should do all the clock switching
+	 * and wait for interrupt tricks.
+	 */
+	cpu_do_idle();
+}
+
+#define WDT_WCR_WDE		0x0004
+
+/*
+ * This function resets the system. It is called by machine_restart().
+ *
+ * @param  mode         indicates different kinds of resets
+ */
+void arch_reset(char mode)
+{
+	volatile u16 v;
+	mxc_clks_enable(WDOG_CLK);
+	v = __raw_readw(IO_ADDRESS(WDOG_BASE_ADDR));
+	__raw_writew(v | WDT_WCR_WDE, IO_ADDRESS(WDOG_BASE_ADDR));
+}
diff --git a/arch/arm/mach-mx27/time.c b/arch/arm/mach-mx27/time.c
new file mode 100644
index 0000000..93f4854
--- /dev/null
+++ b/arch/arm/mach-mx27/time.c
@@ -0,0 +1,169 @@
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/* System Timer Interrupt reconfigured to run in free-run mode.
+ * Author: Vitaly Wool
+ * Copyright 2004 MontaVista Software Inc.
+ */
+
+/*!
+ * @file time.c
+ * @brief This file contains OS tick implementations.
+ *
+ * This file contains OS tick implementations.
+ *
+ * @ingroup Timers
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <asm/hardware.h>
+#include <asm/io.h>
+#include <asm/mach/time.h>
+
+#include <asm/arch/hardware.h>
+#include <asm/arch/clock.h>
+
+#ifndef __noinstrument
+#define __noinstrument
+#endif
+
+/* OS tick defines */
+#define MXC_GPT_INT_TICK		INT_GPT
+#define MXC_GPT_CLOCK_TICK		GPT1_CLK
+#define MXC_GPT_TCMP_TICK		MXC_GPT_TCMP(MXC_TIMER_GPT1)
+#define MXC_GPT_TSTAT_TICK		MXC_GPT_TSTAT(MXC_TIMER_GPT1)
+#define MXC_GPT_TCTL_TICK		MXC_GPT_TCTL(MXC_TIMER_GPT1)
+#define MXC_GPT_TPRER_TICK		MXC_GPT_TPRER(MXC_TIMER_GPT1)
+#define MXC_GPT_TCN_TICK		MXC_GPT_TCN(MXC_TIMER_GPT1)
+/* High resolution timer defines */
+#define MXC_GPT_INT_HRT			INT_GPT2
+#define MXC_GPT_CLOCK_HRT		GPT2_CLK
+#define MXC_GPT_TCMP_HRT		MXC_GPT_TCMP(MXC_TIMER_GPT2)
+#define MXC_GPT_TSTAT_HRT		MXC_GPT_TSTAT(MXC_TIMER_GPT2)
+#define MXC_GPT_TCTL_HRT		MXC_GPT_TCTL(MXC_TIMER_GPT2)
+#define MXC_GPT_TPRER_HRT		MXC_GPT_TPRER(MXC_TIMER_GPT2)
+#define MXC_GPT_TCN_HRT			MXC_GPT_TCN(MXC_TIMER_GPT2)
+
+/*!
+ * This is the timer interrupt service routine to do required tasks.
+ *
+ * @param  irq          GPT interrupt source number (not used)
+ * @param  dev_id       this parameter is not used
+ * @param  regs         pointer to a structure containing the processor
+ *                      registers and state prior to servicing the interrupt
+ * @return always returns \b IRQ_HANDLED as defined in
+ *         include/linux/interrupt.h.
+ */
+static irqreturn_t mxc_timer_interrupt(int irq, void *dev_id)
+{
+	unsigned int next_match;
+
+	do {
+		timer_tick();
+		next_match = __raw_readl(MXC_GPT_TCMP_TICK) + LATCH;
+		__raw_writel(GPT_TSTAT_COMP, MXC_GPT_TSTAT_TICK);
+		__raw_writel(next_match, MXC_GPT_TCMP_TICK);
+	} while ((signed long)(next_match - __raw_readl(MXC_GPT_TCN_TICK)) <=
+		 0);
+
+	return IRQ_HANDLED;
+}
+
+/*!
+ * This function is used to obtain the number of microseconds since the last
+ * timer interrupt. Note that interrupts is disabled by do_gettimeofday().
+ *
+ * @return the number of microseconds since the last timer interrupt.
+ */
+static unsigned long __noinstrument mxc_gettimeoffset(void)
+{
+	unsigned long ticks_to_match, elapsed, usec, tick_usec, i;
+
+	/* Get ticks before next timer match */
+	ticks_to_match =
+	    __raw_readl(MXC_GPT_TCMP_TICK) - __raw_readl(MXC_GPT_TCN_TICK);
+
+	/* We need elapsed ticks since last match */
+	elapsed = LATCH - ticks_to_match;
+
+	/* Now convert them to usec */
+	/* Insure no overflow when calculating the usec below */
+	for (i = 1, tick_usec = tick_nsec / 1000;; i *= 2) {
+		tick_usec /= i;
+		if ((0xFFFFFFFF / tick_usec) > elapsed)
+			break;
+	}
+	usec = (unsigned long)(elapsed * tick_usec) / (LATCH / i);
+
+	return usec;
+}
+
+/*!
+ * The OS tick timer interrupt structure.
+ */
+static struct irqaction timer_irq = {
+	.name = "MXC Timer Tick",
+	.flags = IRQF_DISABLED | IRQF_TIMER,
+	.handler = mxc_timer_interrupt
+};
+
+/*!
+ * This function is used to initialize the GPT to produce an interrupt
+ * every 10 msec. It is called by the start_kernel() during system startup.
+ */
+void __init mxc_init_time(void)
+{
+	u32 reg, v;
+
+	mxc_clks_enable(MXC_GPT_CLOCK_TICK);
+	__raw_writel(0, MXC_GPT_TCTL_TICK);
+	__raw_writel(GPT_TCTL_SWR, MXC_GPT_TCTL_TICK);
+
+	while ((__raw_readl(MXC_GPT_TCTL_TICK) & GPT_TCTL_SWR) != 0)
+		mb();
+
+	reg = GPT_TCTL_FRR | GPT_TCTL_COMPEN | GPT_TCTL_SRC_PER1;
+
+	__raw_writel(reg, MXC_GPT_TCTL_TICK);
+
+	v = mxc_get_clocks(MXC_GPT_CLOCK_TICK);
+	__raw_writel((v / CLOCK_TICK_RATE) - 1, MXC_GPT_TPRER_TICK);
+
+	if ((v % CLOCK_TICK_RATE) != 0) {
+		pr_info("\nWARNING: Can't generate CLOCK_TICK_RATE at %d Hz\n",
+			CLOCK_TICK_RATE);
+	}
+	pr_info("Actual CLOCK_TICK_RATE is %d Hz\n",
+		v / ((__raw_readl(MXC_GPT_TPRER_TICK) & 0x7FF) + 1));
+
+	reg = __raw_readl(MXC_GPT_TCN_TICK);
+	reg += LATCH;
+	__raw_writel(reg, MXC_GPT_TCMP_TICK);
+
+	setup_irq(MXC_GPT_INT_TICK, &timer_irq);
+
+	reg = __raw_readl(MXC_GPT_TCTL_TICK) | GPT_TCTL_TEN;
+	__raw_writel(reg, MXC_GPT_TCTL_TICK);
+
+#ifdef CONFIG_KFI
+	os_timer_initialized = 1;
+#endif
+}
+
+struct sys_timer mxc_timer = {
+	.init = mxc_init_time,
+	.offset = mxc_gettimeoffset,
+};
-- 
1.5.5.1

