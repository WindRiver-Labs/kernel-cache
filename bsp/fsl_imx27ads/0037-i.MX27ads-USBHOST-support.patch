From e9da649f5ccd156aa7d4543d53538afeee78387b Mon Sep 17 00:00:00 2001
From: Alexander Smirnov <asmirnov@embeddedalley.com>
Date: Mon, 29 Dec 2008 20:06:29 +0300
Subject: [PATCH] i.MX27ads USBHOST support

i.MX27ads USBHOST (High Speed) support has been added. This is available
if the CONFIG_USB is set.

Signed-off-by: Alexander Smirnov <asmirnov@embeddedalley.com>
---
 arch/arm/mach-mx2/mx27ads.c |  148 +++++++++++++++++++++++++++++++++++++++++++
 1 files changed, 148 insertions(+), 0 deletions(-)

diff --git a/arch/arm/mach-mx2/mx27ads.c b/arch/arm/mach-mx2/mx27ads.c
index 3c923c4..5adc338 100644
--- a/arch/arm/mach-mx2/mx27ads.c
+++ b/arch/arm/mach-mx2/mx27ads.c
@@ -29,6 +29,7 @@
 #include <linux/i2c.h>
 #include <linux/spi/spi.h>
 #include <linux/dma-mapping.h>
+#include <linux/delay.h>
 
 #include <asm/mach-types.h>
 #include <asm/mach/arch.h>
@@ -49,6 +50,9 @@
 #include <mach/imx_ssi.h>
 #include <mach/imx_dam.h>
 #include <mach/imx_sound.h>
+#include <mach/mxc_ehci.h>
+#include <mach/ulpi.h>
+#include <mach/arc_otg.h>
 
 #include "devices.h"
 
@@ -742,6 +746,142 @@ static struct imx_ssi_platform_data mx27ads_ssi1 = {
 };
 #endif
 
+#ifdef CONFIG_USB
+static int mxc_usbh1_pins[] = {
+	PB22_PF_USBH1_SUSP,
+	PB25_PF_USBH1_RCV,
+	PB26_PF_USBH1_FS,
+	PB27_PF_USBH1_OE_B,
+	PB28_PF_USBH1_TXDM,
+	PB29_PF_USBH1_TXDP,
+	PB30_PF_USBH1_RXDM,
+	PB31_PF_USBH1_RXDP,
+};
+
+static int mx27ads_usbh1_init(struct platform_device *pdev)
+{
+	int ret;
+	uint32_t temp;
+
+	ret = mxc_gpio_setup_multiple_pins(mxc_usbh1_pins,
+					   ARRAY_SIZE(mxc_usbh1_pins),
+					   MXC_GPIO_ALLOC_MODE_NORMAL, "usbh1");
+	if (ret)
+		return ret;
+
+	__raw_writew(PBC_BCTRL3_FSH_MOD, PBC_BCTRL3_CLEAR_REG);
+	__raw_writew(PBC_BCTRL3_FSH_VBUS_EN, PBC_BCTRL3_CLEAR_REG);
+
+	temp = readl(IO_ADDRESS(OTG_BASE_ADDR) + 0x600);
+	temp &= ~(UCTRL_H1SIC_MASK | UCTRL_BPE);/* disable bypass mode */
+	temp |= UCTRL_H1SIC_SU6 |		/* single-ended / unidir. */
+		UCTRL_H1WIE | UCTRL_H1DT |	/* disable H1 TLL */
+		UCTRL_H1PM;			/* power mask */
+	writel(temp, IO_ADDRESS(OTG_BASE_ADDR) + 0x600);
+
+	temp = readl(IO_ADDRESS(OTG_BASE_ADDR) + 0x384);
+	temp &= ~PORTSC_PTS_MASK;
+	temp |= PORTSC_PTS_SERIAL;
+	writel(temp, IO_ADDRESS(OTG_BASE_ADDR) + 0x384);
+
+	return 0;
+}
+
+struct mxc_usb2_platform_data ehci1_pdata = {
+	.init = mx27ads_usbh1_init,
+};
+
+static int mxc_usbh2_pins[] = {
+	PA0_PF_USBH2_CLK,
+	PA1_PF_USBH2_DIR,
+	PA2_PF_USBH2_DATA7,
+	PA3_PF_USBH2_NXT,
+	PA4_PF_USBH2_STP,
+	PD19_AF_USBH2_DATA4,
+	PD20_AF_USBH2_DATA3,
+	PD21_AF_USBH2_DATA6,
+	PD22_AF_USBH2_DATA0,
+	PD23_AF_USBH2_DATA2,
+	PD24_AF_USBH2_DATA1,
+	PD26_AF_USBH2_DATA5,
+};
+
+static int isp1504_set_vbus_power(void __iomem *view, int on)
+{
+	int vid, pid, ret = 0;
+
+	vid = (ulpi_read(ISP1504_VID_HIGH, view) << 8) |
+	       ulpi_read(ISP1504_VID_LOW, view);
+	pid = (ulpi_read(ISP1504_PID_HIGH, view) << 8) |
+	       ulpi_read(ISP1504_PID_LOW, view);
+
+	pr_info("ULPI Vendor ID 0x%x    Product ID 0x%x\n", vid, pid);
+	if (vid != 0x4cc || pid != 0x1504) {
+		pr_err("No ISP1504 found\n");
+		return -1;
+	}
+
+	if (on) {
+		ret = ulpi_set(DRV_VBUS_EXT |	/* enable external Vbus */
+			       DRV_VBUS |	/* enable internal Vbus */
+			       USE_EXT_VBUS_IND | /* use external indicator */
+			       CHRG_VBUS,	/* charge Vbus */
+			       ISP1504_OTGCTL, view);
+	} else {
+		ret = ulpi_clear(DRV_VBUS_EXT |	/* disable external Vbus */
+				 DRV_VBUS,	/* disable internal Vbus */
+				 ISP1504_OTGCTL, view);
+
+		ret |= ulpi_set(USE_EXT_VBUS_IND | /* use external indicator */
+				DISCHRG_VBUS,	/* discharge Vbus */
+				ISP1504_OTGCTL, view);
+	}
+
+	return ret;
+}
+
+static int mx27ads_usbh2_init(struct platform_device *pdev)
+{
+	int ret;
+	uint32_t temp;
+
+	ret = mxc_gpio_setup_multiple_pins(mxc_usbh2_pins,
+					   ARRAY_SIZE(mxc_usbh2_pins),
+					   MXC_GPIO_ALLOC_MODE_NORMAL, "usbh2");
+	if (ret)
+		return ret;
+
+	__raw_writew(PBC_BCTRL3_HSH_EN, PBC_BCTRL3_CLEAR_REG);
+
+	temp = readl(IO_ADDRESS(OTG_BASE_ADDR) + 0x600);
+	temp &= ~(UCTRL_H2SIC_MASK | UCTRL_BPE);/* disable bypass mode */
+	temp |= UCTRL_H2WIE |			/* wakeup intr enable */
+		UCTRL_H2UIE |			/* ULPI intr enable */
+		UCTRL_H2DT |			/* disable H2 TLL */
+		UCTRL_H2PM;			/* power mask */
+	writel(temp, IO_ADDRESS(OTG_BASE_ADDR) + 0x600);
+
+	temp = readl(IO_ADDRESS(OTG_BASE_ADDR) + 0x584);
+	temp &= ~PORTSC_PTS_MASK;		/* set ULPI xcvr */
+	temp |= PORTSC_PTS_ULPI;
+	writel(temp, IO_ADDRESS(OTG_BASE_ADDR) + 0x584);
+
+	mdelay(10);
+
+	ret = isp1504_set_vbus_power((void *)IO_ADDRESS(OTG_BASE_ADDR + 0x570), 1);
+	if (ret)
+		mxc_gpio_setup_multiple_pins(mxc_usbh2_pins,
+					     ARRAY_SIZE(mxc_usbh2_pins),
+					     MXC_GPIO_ALLOC_MODE_RELEASE,
+					     "usbh2");
+	return ret;
+}
+
+struct mxc_usb2_platform_data ehci2_pdata = {
+	.init = mx27ads_usbh2_init,
+};
+#endif
+
 static struct platform_device *platform_devices[] __initdata = {
 	&mx27ads_nor_mtd_device,
 #ifdef CONFIG_SND
@@ -794,6 +934,14 @@ static void __init mx27ads_board_init(void)
 	mxc_register_device(&imx_ssi_device0, &mx27ads_ssi0);
 	mxc_register_device(&imx_ssi_device1, &mx27ads_ssi1);
 #endif
+#ifdef CONFIG_USB
+	/* USB_HOST1 conflicts with UART3 pins */
+	mxc_register_device(&mxc_ehci1, &ehci1_pdata);
+#if (!defined(CONFIG_SPI_MXC_SELECT1) && !defined(CONFIG_SPI_MXC_SELECT2))
+	/* USB_HOST2 conflicts with SPI1 and SPI2 pins */
+	mxc_register_device(&mxc_ehci2, &ehci2_pdata);
+#endif
+#endif
 
 	platform_add_devices(platform_devices, ARRAY_SIZE(platform_devices));
 }
-- 
1.5.5.1

