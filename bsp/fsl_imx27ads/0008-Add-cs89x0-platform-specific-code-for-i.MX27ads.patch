From 752b618bced226d9fa09b85178348a950a55c249 Mon Sep 17 00:00:00 2001
From: Alexander Smirnov <asmirnov@embeddedalley.com>
Date: Tue, 9 Dec 2008 21:54:47 +0300
Subject: [PATCH] Add cs89x0 platform specific code for i.MX27ads

Add cs89x0 platform specific code for i.MX27ads

Signed-off-by: Alexander Smirnov <asmirnov@embeddedalley.com>
---
 arch/arm/mach-mx2/Kconfig   |    1 +
 arch/arm/mach-mx2/mx27ads.c |  127 ++++++++++++++++++++++++++++++++++++++++++-
 2 files changed, 127 insertions(+), 1 deletions(-)

diff --git a/arch/arm/mach-mx2/Kconfig b/arch/arm/mach-mx2/Kconfig
index 1eaa97c..ade750b 100644
--- a/arch/arm/mach-mx2/Kconfig
+++ b/arch/arm/mach-mx2/Kconfig
@@ -13,6 +13,7 @@ comment "MX2 Platforms"
 config MACH_MX27ADS
 	bool "MX27ADS platform"
 	depends on MACH_MX27
+	select ISA
 	help
 	  Include support for MX27ADS platform. This includes specific
 	  configurations for the board and its peripherals.
diff --git a/arch/arm/mach-mx2/mx27ads.c b/arch/arm/mach-mx2/mx27ads.c
index 4ce56ef..6672174 100644
--- a/arch/arm/mach-mx2/mx27ads.c
+++ b/arch/arm/mach-mx2/mx27ads.c
@@ -25,8 +25,10 @@
 #include <linux/mtd/physmap.h>
 #include <mach/common.h>
 #include <mach/hardware.h>
+#include <linux/interrupt.h>
 #include <asm/mach-types.h>
 #include <asm/mach/arch.h>
+#include <asm/mach/irq.h>
 #include <asm/mach/time.h>
 #include <asm/mach/map.h>
 #include <mach/gpio.h>
@@ -56,6 +58,122 @@ static struct platform_device mx27ads_nor_mtd_device = {
 	.resource = &mx27ads_flash_resource,
 };
 
+#if defined(CONFIG_CS89x0) || defined(CONFIG_CS89x0_MODULE)
+/*! Null terminated portlist used to probe for the CS8900A device on ISA Bus
+ * Add 3 to reset the page window before probing (fixes eth probe when deployed
+ * using nand_boot)
+ */
+unsigned int netcard_portlist[] = { CS8900A_BASE_ADDRESS + 3, 0 };
+EXPORT_SYMBOL(netcard_portlist);
+
+/*!
+ * The CS8900A has 4 IRQ pins, which is software selectable, CS8900A interrupt
+ * pin 0 is used for interrupt generation.
+ */
+unsigned int cs8900_irq_map[] = { CS8900AIRQ, 0, 0, 0 };
+EXPORT_SYMBOL(cs8900_irq_map);
+#endif
+
+/*!
+ * Interrupt handler for the expio (CPLD) to deal with interrupts from
+ * FEC, external UART, CS8900 Ethernet and SD cards, etc.
+ */
+static void mxc_expio_irq_handler(u32 irq, struct irq_desc *desc)
+{
+	u32 imr;
+	u32 int_valid;
+	u32 expio_irq;
+
+	desc->chip->mask(irq);	/* irq = gpio irq number */
+
+	imr = __raw_readw(PBC_INTMASK_SET_REG);
+
+	/* Bits defined in PBC_INTSTATUS_REG at 0x2C */
+	int_valid = __raw_readw(PBC_INTSTATUS_REG) & imr;
+
+	if (unlikely(!int_valid))
+		goto out;
+
+	expio_irq = MXC_EXP_IO_BASE;
+	for (; int_valid != 0; int_valid >>= 1, expio_irq++) {
+		if ((int_valid & 1) == 0)
+			continue;
+
+		generic_handle_irq(expio_irq);
+	}
+
+out:
+	desc->chip->ack(irq);
+	desc->chip->unmask(irq);
+}
+/*
+ * Disable an expio pin's interrupt by setting the bit in the imr.
+ * @param irq		an expio virtual irq number
+ */
+static void expio_mask_irq(u32 irq)
+{
+	u32 expio = MXC_IRQ_TO_EXPIO(irq);
+
+	/* mask the interrupt */
+	__raw_writew(1 << expio, PBC_INTMASK_CLEAR_REG);
+	__raw_readw(PBC_INTMASK_CLEAR_REG);
+}
+
+/*
+ * Acknowledge an expanded io pin's interrupt by clearing the bit in the isr.
+ * @param irq		an expanded io virtual irq number
+ */
+static void expio_ack_irq(u32 irq)
+{
+	u32 expio = MXC_IRQ_TO_EXPIO(irq);
+
+	/* clear the interrupt status */
+	__raw_writew(1 << expio, PBC_INTSTATUS_REG);
+}
+
+/*
+ * Enable a expio pin's interrupt by clearing the bit in the imr.
+ * @param irq		an expio virtual irq number
+ */
+static void expio_unmask_irq(u32 irq)
+{
+	u32 expio = MXC_IRQ_TO_EXPIO(irq);
+
+	/* unmask the interrupt */
+	__raw_writew(1 << expio, PBC_INTMASK_SET_REG);
+}
+
+static struct irq_chip expio_irq_chip = {
+	.ack = expio_ack_irq,
+	.mask = expio_mask_irq,
+	.unmask = expio_unmask_irq,
+};
+
+static int __init mx2_expio_init(void)
+{
+	int i;
+
+	/*
+	 * Configure INT line as GPIO input
+	 */
+	/* disable the interrupt and clear the status */
+	__raw_writew(0xFFFF, PBC_INTMASK_CLEAR_REG);
+	__raw_writew(0xFFFF, PBC_INTSTATUS_REG);
+
+	for (i = MXC_EXP_IO_BASE; i < (MXC_EXP_IO_BASE + MXC_MAX_EXP_IO_LINES);
+	     i++) {
+		set_irq_chip(i, &expio_irq_chip);
+		set_irq_handler(i, handle_level_irq);
+		set_irq_flags(i, IRQF_VALID);
+	}
+	set_irq_type(IRQ_GPIOC((PC15_PF_TIN & GPIO_PIN_MASK)),
+					IRQ_TYPE_LEVEL_HIGH);
+	set_irq_chained_handler(IRQ_GPIOC((PC15_PF_TIN & GPIO_PIN_MASK)),
+					mxc_expio_irq_handler);
+
+	return 0;
+}
+
 static int mxc_uart0_pins[] = {
 	PE12_PF_UART1_TXD,
 	PE13_PF_UART1_RXD,
@@ -291,13 +409,20 @@ void __init mx27ads_map_io(void)
 	iotable_init(mx27ads_io_desc, ARRAY_SIZE(mx27ads_io_desc));
 }
 
+void __init mx27ads_init_irq(void)
+{
+	mxc_init_irq();
+	mx2_expio_init();
+}
+
+
 MACHINE_START(MX27ADS, "Freescale i.MX27ADS")
 	/* maintainer: Freescale Semiconductor, Inc. */
 	.phys_io        = AIPI_BASE_ADDR,
 	.io_pg_offst    = ((AIPI_BASE_ADDR_VIRT) >> 18) & 0xfffc,
 	.boot_params    = PHYS_OFFSET + 0x100,
 	.map_io         = mx27ads_map_io,
-	.init_irq       = mxc_init_irq,
+	.init_irq       = mx27ads_init_irq,
 	.init_machine   = mx27ads_board_init,
 	.timer          = &mx27ads_timer,
 MACHINE_END
-- 
1.6.0.2.GIT

