From 2b076cc1119af6c554edf97d9f49a29dec27f3cc Mon Sep 17 00:00:00 2001
From: Alexander Smirnov <asmirnov@embeddedalley.com>
Date: Mon, 29 Dec 2008 20:56:28 +0300
Subject: [PATCH] i.MX27: keypad support

i.MX27: keypad support

Signed-off-by: Alexander Smirnov <asmirnov@embeddedalley.com>
---
 arch/arm/plat-mxc/include/mach/keypad.h |   30 +++
 drivers/input/keyboard/Kconfig          |    9 +
 drivers/input/keyboard/Makefile         |    1 +
 drivers/input/keyboard/mxc-keypad.c     |  431 +++++++++++++++++++++++++++++++
 4 files changed, 471 insertions(+), 0 deletions(-)
 create mode 100644 arch/arm/plat-mxc/include/mach/keypad.h
 create mode 100644 drivers/input/keyboard/mxc-keypad.c

diff --git a/arch/arm/plat-mxc/include/mach/keypad.h b/arch/arm/plat-mxc/include/mach/keypad.h
new file mode 100644
index 0000000..4458413
--- /dev/null
+++ b/arch/arm/plat-mxc/include/mach/keypad.h
@@ -0,0 +1,30 @@
+/*
+ * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#ifndef __ASM_ARCH_MXC_KEYPAD_H__
+#define __ASM_ARCH_MXC_KEYPAD_H__
+
+#include <linux/types.h>
+
+struct keypad_data {
+	int rowmax;
+	int colmax;
+	int numkeys;
+
+	int debounce;
+	int delay;
+
+	u16 *matrix;
+};
+
+#endif /* __ASM_ARCH_MXC_KEYPAD_H__ */
diff --git a/drivers/input/keyboard/Kconfig b/drivers/input/keyboard/Kconfig
index e4d0436..be87a90 100644
--- a/drivers/input/keyboard/Kconfig
+++ b/drivers/input/keyboard/Kconfig
@@ -100,6 +100,15 @@ config KEYBOARD_LOCOMO
 	  To compile this driver as a module, choose M here: the
 	  module will be called locomokbd.
 
+config KEYBOARD_MXC
+	tristate "MXC Keypad support"
+	depends on MACH_MX27ADS || MACH_MX31ADS
+	help
+	  Say Y here if your use the keypad on i.MX ADS devices
+
+	  To compile this driver as a module, chose M here: the
+	  module will be called mxc-keypad.
+
 config KEYBOARD_XTKBD
 	tristate "XT keyboard"
 	select SERIO
diff --git a/drivers/input/keyboard/Makefile b/drivers/input/keyboard/Makefile
index ae47fff..4e8c8aa 100644
--- a/drivers/input/keyboard/Makefile
+++ b/drivers/input/keyboard/Makefile
@@ -11,6 +11,7 @@ obj-$(CONFIG_KEYBOARD_XTKBD)		+= xtkbd.o
 obj-$(CONFIG_KEYBOARD_AMIGA)		+= amikbd.o
 obj-$(CONFIG_KEYBOARD_ATARI)		+= atakbd.o
 obj-$(CONFIG_KEYBOARD_LOCOMO)		+= locomokbd.o
+obj-$(CONFIG_KEYBOARD_MXC)			+= mxc-keypad.o
 obj-$(CONFIG_KEYBOARD_NEWTON)		+= newtonkbd.o
 obj-$(CONFIG_KEYBOARD_STOWAWAY)		+= stowaway.o
 obj-$(CONFIG_KEYBOARD_CORGI)		+= corgikbd.o
diff --git a/drivers/input/keyboard/mxc-keypad.c b/drivers/input/keyboard/mxc-keypad.c
new file mode 100644
index 0000000..6931a8c
--- /dev/null
+++ b/drivers/input/keyboard/mxc-keypad.c
@@ -0,0 +1,431 @@
+/*
+ * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file mxc_keyb.c
+ *
+ * @brief Driver for the Freescale Semiconductor MXC keypad port.
+ *
+ * The keypad driver is designed as a standard Input driver which interacts
+ * with low level keypad port hardware. Upon opening, the Keypad driver
+ * initializes the keypad port. When the keypad interrupt happens the driver
+ * calles keypad polling timer and scans the keypad matrix for key
+ * press/release. If all key press/release happened it comes out of timer and
+ * waits for key press interrupt. The scancode for key press and release events
+ * are passed to Input subsytem.
+ *
+ * @ingroup keypad
+ */
+
+#include <mach/clock.h>
+#include <mach/gpio.h>
+#include <mach/keypad.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/input.h>
+#include <linux/platform_device.h>
+#include <linux/input.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/spinlock.h>
+#include <linux/clk.h>
+#include <linux/timer.h>
+
+#define SCAN_INTERVAL	10 /* HZ */
+
+/*
+ * register defines
+ */
+#define KPP_CR		IO_ADDRESS(KPP_BASE_ADDR + 0x00)
+#define KPP_SR		IO_ADDRESS(KPP_BASE_ADDR + 0x02)
+#define KPP_DDR		IO_ADDRESS(KPP_BASE_ADDR + 0x04)
+#define KPP_DR		IO_ADDRESS(KPP_BASE_ADDR + 0x06)
+
+#define MXC_MAXROWS		0x8
+#define MXC_MAXCOLS		0x8
+
+enum {
+	KPP_PRESS_INT	= 0x1,
+	KPP_RELEASE_INT,
+	KPP_PRESS_SYNC	= 0x4,
+	KPP_RELEASE_SYNC	= 0x8,
+	KPP_PRESS_EN	= 0x100,
+	KPP_RELEASE_EN	= 0x200,
+	KPP_CLOCK_EN	= 0x400
+};
+
+struct mxckeypad {
+	struct input_dev *input;
+	struct timer_list timer;
+	struct clk *clk;
+	struct device *dev;
+
+	int irq;
+	unsigned int rows;
+	unsigned int cols;
+	unsigned int numkeys;
+	unsigned int status[MXC_MAXROWS][MXC_MAXCOLS];
+	u16 *keycodes;
+
+	spinlock_t lock;
+	spinlock_t reg_lock;
+};
+
+static int mxckeypad_reg_read(struct mxckeypad *mxckeypad, u32 reg)
+{
+	int ret;
+	spin_lock(&mxckeypad->reg_lock);
+	ret = __raw_readw(reg);
+	spin_unlock(&mxckeypad->reg_lock);
+	return ret;
+}
+
+static void mxckeypad_reg_write(struct mxckeypad *mxckeypad, u32 reg, u32 val)
+{
+	spin_lock(&mxckeypad->reg_lock);
+	__raw_writew(val, reg);
+	spin_unlock(&mxckeypad->reg_lock);
+}
+
+#ifdef CONFIG_PM
+static int mxckeypad_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	struct mxckeypad *mxckeypad =
+		(struct mxckeypad *) platform_get_drvdata(pdev);
+
+	del_timer_sync(&mxckeypad->timer);
+	if (device_may_wakeup(&pdev->dev)) {
+		enable_irq_wake(mxckeypad->irq);
+	} else {
+		disable_irq(mxckeypad->irq);
+		clk_disable(mxckeypad->clk);
+		gpio_keypad_inactive();
+	}
+	return 0;
+}
+
+static int mxckeypad_resume(struct platform_device *pdev)
+{
+	struct mxckeypad *mxckeypad =
+		(struct mxckeypad *) platform_get_drvdata(pdev);
+
+	if (device_may_wakeup(&pdev->dev)) {
+		disable_irq_wake(mxckeypad->irq);
+	} else {
+		gpio_keypad_active();
+		clk_enable(mxckeypad->clk);
+		enable_irq(mxckeypad->irq);
+	}
+
+	init_timer(&mxckeypad->timer);
+
+	return 0;
+}
+#else
+#define mxckeypad_suspend	NULL
+#define mxckeypad_resume	NULL
+#endif
+
+static int mxckeypad_scan(struct mxckeypad *mxckeypad)
+{
+	int reg_val;
+	int i, j, key_pressed = 0;
+	unsigned long flags;
+
+	spin_lock_irqsave(&mxckeypad->lock, flags);
+	disable_irq(mxckeypad->irq);
+	for (i = 0; i < mxckeypad->cols; i++) {
+		reg_val = mxckeypad_reg_read(mxckeypad, KPP_DR);
+		reg_val |= 0xff00;
+		mxckeypad_reg_write(mxckeypad, KPP_DR, reg_val);
+
+		/*
+		 * discharge keypad capacitance
+		 */
+		reg_val = mxckeypad_reg_read(mxckeypad, KPP_CR);
+		mxckeypad_reg_write(mxckeypad, KPP_CR, reg_val & 0xff);
+
+		udelay(2);
+
+		reg_val = mxckeypad_reg_read(mxckeypad, KPP_CR);
+		mxckeypad_reg_write(mxckeypad, KPP_CR, reg_val | (0xff << 8));
+
+		/*
+		 * read column bits
+		 */
+		reg_val = mxckeypad_reg_read(mxckeypad, KPP_DR);
+		reg_val &= ~(0x100 << i);
+		mxckeypad_reg_write(mxckeypad, KPP_DR, reg_val);
+
+		udelay(5);
+
+		reg_val = mxckeypad_reg_read(mxckeypad, KPP_DR);
+		for (j = 0; j < mxckeypad->rows; j++) {
+			int k = ~reg_val & (1 << j);
+
+			if (mxckeypad->status[j][i] != k) {
+				int keycode =
+					mxckeypad->keycodes
+						[(j * mxckeypad->rows) + i];
+				input_report_key(mxckeypad->input,
+							keycode, !!k);
+			}
+			mxckeypad->status[j][i] = k;
+			if (k)
+				key_pressed++;
+		}
+	}
+	mxckeypad_reg_write(mxckeypad, KPP_DR, 0);
+
+	reg_val = mxckeypad_reg_read(mxckeypad, KPP_SR);
+	reg_val |= KPP_PRESS_INT | KPP_RELEASE_INT;
+	reg_val |= KPP_RELEASE_SYNC | KPP_PRESS_EN;
+	mxckeypad_reg_write(mxckeypad, KPP_SR, reg_val);
+
+	input_sync(mxckeypad->input);
+
+	if (key_pressed)
+		mod_timer(&mxckeypad->timer,
+			jiffies + msecs_to_jiffies(SCAN_INTERVAL));
+
+	enable_irq(mxckeypad->irq);
+	spin_unlock_irqrestore(&mxckeypad->lock, flags);
+
+	return 0;
+}
+
+/*
+ * mxc keypad interrupt handler.
+ */
+static irqreturn_t mxckeypad_interrupt(int irq, void *dev)
+{
+	struct mxckeypad *mxckeypad = dev;
+	int reg_val;
+
+	reg_val = mxckeypad_reg_read(mxckeypad, KPP_SR);
+	if (reg_val & KPP_PRESS_INT) {
+		reg_val &= ~KPP_PRESS_INT;
+		mxckeypad_reg_write(mxckeypad, KPP_SR, reg_val);
+
+		mxckeypad_scan(dev);
+	}
+
+	return IRQ_HANDLED;
+}
+
+/*
+ * mxc timer checking for released keys
+ */
+static void mxckeypad_timer_callback(unsigned long data)
+{
+	struct mxckeypad *mxckeypad = (struct mxckeypad *) data;
+
+	mxckeypad_scan(mxckeypad);
+}
+
+static int __init mxckeypad_probe(struct platform_device *pdev)
+{
+	struct mxckeypad *mxckeypad;
+	struct input_dev *input_dev;
+	struct keypad_data *keypad_data =
+		(struct keypad_data *) pdev->dev.platform_data;
+	struct clk *clk;
+	int reg_val, irq;
+	int ret = 0, i;
+
+	mxckeypad = kzalloc(sizeof(struct mxckeypad), GFP_KERNEL);
+	input_dev = input_allocate_device();
+	if (!mxckeypad || !input_dev) {
+		ret = -ENOMEM;
+		goto err1;
+	}
+	mxckeypad->input = input_dev;
+
+	irq = platform_get_irq(pdev, 0);
+	mxckeypad->irq = irq;
+	if (irq < 0) {
+		dev_err(&pdev->dev, "failed to get mxc-keypad irq\n");
+		ret = -ENXIO;
+		goto err1;
+	}
+
+	if (!keypad_data->colmax || !keypad_data->rowmax) {
+		dev_err(&pdev->dev, "failed to get row or column count\n");
+		ret = -EINVAL;
+		goto err1;
+	}
+	mxckeypad->rows = keypad_data->rowmax;
+	mxckeypad->cols = keypad_data->colmax;
+	mxckeypad->dev = &pdev->dev;
+
+	if (!keypad_data->matrix) {
+		dev_err(&pdev->dev, "failed to get keyboard scan codes\n");
+		ret = -EINVAL;
+		goto err1;
+	}
+	mxckeypad->keycodes = keypad_data->matrix;
+	mxckeypad->numkeys = keypad_data->numkeys;
+
+	input_dev->name = "mxc-keypad";
+	input_dev->phys = "mxc-keypad/input0";
+	input_dev->dev.parent = &pdev->dev;
+
+	input_dev->id.bustype = BUS_HOST;
+	input_dev->id.vendor = 0x0001;
+	input_dev->id.product = 0x0001;
+	input_dev->id.version = 0x0100;
+	input_dev->evbit[0] = BIT(EV_KEY) | BIT(EV_REP);
+	input_dev->keycode = mxckeypad->keycodes;
+	input_dev->keycodesize = sizeof(unsigned char);
+	input_dev->keycodemax = mxckeypad->numkeys;
+
+	ret = request_irq(irq, mxckeypad_interrupt,
+			IRQF_SHARED | IRQF_SAMPLE_RANDOM,
+			"mxc-keypad", mxckeypad);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "unable to register"
+			" mxc-keypad interrupt\n");
+		ret = -ENXIO;
+		goto err1;
+	}
+
+	clk = clk_get(&pdev->dev, "kpp_clk");
+	if (!clk) {
+		dev_err(&pdev->dev, "unable to find kpp_clk clock\n");
+		ret = -ENXIO;
+		goto err2;
+	}
+	clk_enable(clk);
+	gpio_keypad_active();
+
+	/*
+	 * enable rows and columns for the keypad
+	 */
+	reg_val = mxckeypad_reg_read(mxckeypad, KPP_CR);
+	reg_val |= (1 << mxckeypad->rows) - 1;
+	reg_val |= ((1 << mxckeypad->cols) - 1) << 8;
+	mxckeypad_reg_write(mxckeypad, KPP_CR, reg_val);
+
+	/*
+	 * clear data register
+	 */
+	reg_val = mxckeypad_reg_read(mxckeypad, KPP_DR);
+	mxckeypad_reg_write(mxckeypad, KPP_DR, reg_val & 0xff);
+
+	/*
+     * set columns as outputs and rows as inputs
+     */
+	mxckeypad_reg_write(mxckeypad, KPP_DDR, 0xff << 8);
+
+	reg_val = mxckeypad_reg_read(mxckeypad, KPP_SR);
+	reg_val |= KPP_PRESS_INT | KPP_RELEASE_INT;
+	reg_val |= KPP_PRESS_SYNC | KPP_RELEASE_SYNC;
+	mxckeypad_reg_write(mxckeypad, KPP_SR, reg_val);
+
+	reg_val |= KPP_PRESS_EN;
+	reg_val &= ~KPP_RELEASE_EN;
+	mxckeypad_reg_write(mxckeypad, KPP_SR, reg_val);
+
+	__set_bit(EV_KEY, input_dev->evbit);
+	for (i = 0; i < keypad_data->numkeys; i++)
+		__set_bit(keypad_data->matrix[i], input_dev->keybit);
+
+	ret = input_register_device(input_dev);
+	if (ret < 0) {
+		dev_err(&pdev->dev,
+			"unable to register mxc-keypad input device\n");
+		ret = -ENXIO;
+		goto err2;
+	}
+	platform_set_drvdata(pdev, mxckeypad);
+
+	init_timer(&mxckeypad->timer);
+	mxckeypad->timer.data = (unsigned long) mxckeypad;
+	mxckeypad->timer.function = mxckeypad_timer_callback;
+
+	spin_lock_init(&mxckeypad->lock);
+	spin_lock_init(&mxckeypad->reg_lock);
+
+	device_init_wakeup(&pdev->dev, 1);
+
+	return 0;
+
+err2:
+	free_irq(mxckeypad->irq, mxckeypad);
+err1:
+	input_free_device(input_dev);
+	kfree(mxckeypad);
+	return ret;
+}
+
+static int mxckeypad_remove(struct platform_device *dev)
+{
+	struct mxckeypad *mxckeypad =
+			(struct mxckeypad *) platform_get_drvdata(dev);
+	int reg_val;
+
+	/*
+	 * disable keypad
+	 */
+	mxckeypad_reg_write(mxckeypad, KPP_CR, 0);
+	mxckeypad_reg_write(mxckeypad, KPP_DR, 0);
+	mxckeypad_reg_write(mxckeypad, KPP_DDR, 0);
+
+	reg_val = mxckeypad_reg_read(mxckeypad, KPP_SR);
+	reg_val |= KPP_PRESS_INT | KPP_PRESS_EN;
+	reg_val &= ~(KPP_RELEASE_SYNC | KPP_RELEASE_EN);
+	mxckeypad_reg_write(mxckeypad, KPP_SR, reg_val);
+
+	clk_disable(mxckeypad->clk);
+	clk_put(mxckeypad->clk);
+
+	gpio_keypad_inactive();
+
+	del_timer_sync(&mxckeypad->timer);
+	input_unregister_device(mxckeypad->input);
+
+	free_irq(mxckeypad->irq, mxckeypad);
+	kfree(mxckeypad);
+
+	return 0;
+}
+
+static struct platform_driver mxckeypad_driver = {
+	.probe		= mxckeypad_probe,
+	.remove		= __devexit_p(mxckeypad_remove),
+	.suspend	= mxckeypad_suspend,
+	.resume		= mxckeypad_resume,
+	.driver		= {
+		.name 	= "mxc_keypad",
+		.owner	= THIS_MODULE,
+	},
+};
+
+static int __devinit mxckeypad_init(void)
+{
+	return platform_driver_register(&mxckeypad_driver);
+}
+
+static void __exit mxckeypad_exit(void)
+{
+	platform_driver_unregister(&mxckeypad_driver);
+}
+
+module_init(mxckeypad_init);
+module_exit(mxckeypad_exit);
+
+MODULE_AUTHOR("Matthew Ranostay <mranostay@embeddedalley.com");
+MODULE_DESCRIPTION("i.MX Keypad Driver");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("platform:mxc_keypad");
-- 
1.6.0.3

