From 300ab52d6139e8f26e69beb6e25ba0fc319665b3 Mon Sep 17 00:00:00 2001
From: Vladimir Barinov <vbarinov@embeddedlley.com>
Date: Wed, 11 Feb 2009 18:42:40 +0300
Subject: [PATCH 56/77] Focus FS453 TV Encoder support

Add Focus FS453 TV Encoder support

Signed-off-by: Vladimir Barinov <vbarinov@embeddedlley.com>
---
 drivers/video/Kconfig  |    7 +
 drivers/video/Makefile |    1 +
 drivers/video/fs453.c  |  442 ++++++++++++++++++++++++++++++++++++++++++++++++
 drivers/video/fs453.h  |  134 +++++++++++++++
 4 files changed, 584 insertions(+), 0 deletions(-)
 create mode 100644 drivers/video/fs453.c
 create mode 100644 drivers/video/fs453.h

diff --git a/drivers/video/Kconfig b/drivers/video/Kconfig
index 1f50361..cf9d28f 100644
--- a/drivers/video/Kconfig
+++ b/drivers/video/Kconfig
@@ -395,6 +395,13 @@ config FB_IMX
 	select FB_CFB_COPYAREA
 	select FB_CFB_IMAGEBLIT
 
+config FS453_ENCODER
+	tristate "Focus FS453 TV Encoder"
+	depends on FB_IMX
+	default n
+	help
+	   Focus FS453 TV Encoder
+
 config FB_CYBER2000
 	tristate "CyberPro 2000/2010/5000 support"
 	depends on FB && PCI && (BROKEN || !SPARC64)
diff --git a/drivers/video/Makefile b/drivers/video/Makefile
index f8fb3d0..3a0ab3c 100644
--- a/drivers/video/Makefile
+++ b/drivers/video/Makefile
@@ -107,6 +107,7 @@ obj-$(CONFIG_FB_MAXINE)		  += maxinefb.o
 obj-$(CONFIG_FB_METRONOME)        += metronomefb.o
 obj-$(CONFIG_FB_S1D13XXX)	  += s1d13xxxfb.o
 obj-$(CONFIG_FB_SH7760)		  += sh7760fb.o
+obj-$(CONFIG_FS453_ENCODER)	  += fs453.o
 obj-$(CONFIG_FB_IMX)              += imxfb.o
 obj-$(CONFIG_FB_S3C2410)	  += s3c2410fb.o
 obj-$(CONFIG_FB_FSL_DIU)	  += fsl-diu-fb.o
diff --git a/drivers/video/fs453.c b/drivers/video/fs453.c
new file mode 100644
index 0000000..9fa36c3
--- /dev/null
+++ b/drivers/video/fs453.c
@@ -0,0 +1,442 @@
+/*
+ * Copyright 2005-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @defgroup FS453 Focus FS453 TV Encoder Driver
+ */
+/*!
+ * @file fs453.c
+ * @brief Driver for FS453/4 TV encoder
+ *
+ * @ingroup FS453
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/i2c.h>
+#include <linux/ioctl.h>
+#include <linux/video_encoder.h>
+
+#include "fs453.h"
+
+/*
+ * FIXME: VGA mode is not defined by video_encoder.h
+ * while FS453 supports VGA output.
+ */
+#ifndef VIDEO_ENCODER_VGA
+#define VIDEO_ENCODER_VGA	32
+#endif
+
+/*!
+ * This stucture contains the status of FS453.
+ */
+struct fs453_data {
+	int norm;
+	int input;
+	int output;
+	int enable;
+};
+
+/*!
+ * This structure contains all the register values needed to program the
+ * TV encoder chip.  This structure is instantiated and initialized for
+ * each supported output standard.
+ */
+struct fs453_presets {
+	u32 mode;		/*! Video mode */
+	u16 qpr;		/*! Quick Program Register */
+	u16 pwr_mgmt;		/*! Power Management */
+	u16 iho;		/*! Input Horizontal Offset */
+	u16 ivo;		/*! Input Vertical Offset */
+	u16 ihw;		/*! Input Horizontal Width */
+	u16 vsc;		/*! Vertical Scaling Coefficient */
+	u16 hsc;		/*! Horizontal Scaling Coefficient */
+	u16 bypass;		/*! Bypass */
+	u16 misc;		/*! Miscellaneous Bits Register */
+	u8 misc46;		/*! Miscellaneous Bits Register 46 */
+	u8 misc47;		/*! Miscellaneous Bits Register 47 */
+	u32 ncon;		/*! Numerator of NCO Word */
+	u32 ncod;		/*! Denominator of NCO Word */
+	u16 pllm;		/*! PLL M and Pump Control */
+	u16 plln;		/*! PLL N */
+	u16 pllpd;		/*! PLL Post-Divider */
+	u16 vid_cntl0;		/*! Video Control 0 */
+	u16 dac_cntl;		/*! DAC Control */
+	u16 fifo_lat;		/*! FIFO Latency */
+};
+
+static struct fs453_presets fs453_vga_presets = {
+	.mode = VIDEO_ENCODER_VGA,
+	.qpr = 0x9cb0,
+	.pwr_mgmt = 0x0408,
+	.misc = 0x0103,
+	.ncon = 0x00000000,
+	.ncod = 0x00000000,
+	.misc46 = 0xa9,
+	.misc47 = 0x00,
+	.pllm = 0x317f,
+	.plln = 0x008e,
+	.pllpd = 0x0202,
+	.vid_cntl0 = 0x4006,
+	.dac_cntl = 0x00e4,
+	.fifo_lat = 0x0082,
+};
+
+static struct fs453_presets fs453_ntsc_presets = {
+	.mode = VIDEO_ENCODER_NTSC,
+	.qpr = 0x9c48,
+	.pwr_mgmt = 0x0200,
+	.misc = 0x0103,
+	.ncon = 0x00000001,
+	.ncod = 0x00000001,
+	.misc46 = 0x01,
+	.misc47 = 0x00,
+	.pllm = 0x4000 | (296 - 17),
+	.plln = 30 - 1,
+	.pllpd = ((10 - 1) << 8) | (10 - 1),
+	.iho = 0,
+	.ivo = 40,
+	.ihw = 768,
+	.vsc = 789,
+	.hsc = 0x0000,
+	.bypass = 0x000a,
+	.vid_cntl0 = 0x0340,
+	.dac_cntl = 0x00e4,
+	.fifo_lat = 0x0082,
+};
+
+static struct fs453_presets fs453_pal_presets = {
+	.mode = VIDEO_ENCODER_PAL,
+	.qpr = 0x9c41,
+	.pwr_mgmt = 0x0200,
+	.misc = 0x0103,
+	.ncon = 0x00000001,
+	.ncod = 0x00000001,
+	.misc46 = 0x01,
+	.misc47 = 0x00,
+	.pllm = 0x4000 | (296 - 17),
+	.plln = 30 - 1,
+	.pllpd = ((10 - 1) << 8) | (10 - 1),
+	.iho = 0,
+	.ivo = 19,
+	.ihw = 768,
+	.vsc = 8200,
+	.hsc = 0x0000,
+	.bypass = 0x000a,
+	.vid_cntl0 = 0x0340,
+	.dac_cntl = 0x00e4,
+	.fifo_lat = 0x0082,
+};
+
+static int fs453_preset(struct i2c_client *client,
+			struct fs453_presets *presets);
+static int fs453_enable(struct i2c_client *client, int enable);
+
+static struct i2c_driver fs453_driver;
+/*
+ * FIXME: fs453_client will represent the first FS453 device found by
+ * the I2C subsystem, which means fs453_ioctl() always works on the
+ * first FS453 device.
+ */
+static struct i2c_client *fs453_client = 0;
+
+static int fs453_command(struct i2c_client *client, unsigned int cmd, void *arg)
+{
+	int val;
+	char *smode = 0;
+	struct video_encoder_capability *cap;
+	struct fs453_data *data = i2c_get_clientdata(client);
+	int ret = 0;
+
+	switch (cmd) {
+	case ENCODER_GET_CAPABILITIES:
+		cap = arg;
+		cap->flags =
+		    VIDEO_ENCODER_PAL | VIDEO_ENCODER_NTSC | VIDEO_ENCODER_VGA;
+		cap->inputs = 1;
+		cap->outputs = 1;
+		break;
+	case ENCODER_SET_NORM:
+		val = *(int *)arg;
+		switch (val) {
+		case VIDEO_ENCODER_PAL:
+			ret = fs453_preset(client, &fs453_pal_presets);
+			smode = "PAL";
+			break;
+		case VIDEO_ENCODER_NTSC:
+			ret = fs453_preset(client, &fs453_ntsc_presets);
+			smode = "NTSC";
+			break;
+		case VIDEO_ENCODER_VGA:
+			ret = fs453_preset(client, &fs453_vga_presets);
+			smode = "VGA";
+			break;
+		default:
+			ret = -EINVAL;
+			break;
+		}
+		if (!ret) {
+			data->norm = val;
+			data->enable = 1;
+			pr_debug("FS453: switched to %s\n", smode);
+		}
+		break;
+	case ENCODER_SET_INPUT:
+		val = *(int *)arg;
+		/* We have only one input */
+		if (val != 0)
+			return -EINVAL;
+		data->input = val;
+		break;
+	case ENCODER_SET_OUTPUT:
+		val = *(int *)arg;
+		/* We have only one output */
+		if (val != 0)
+			return -EINVAL;
+		data->output = val;
+		break;
+	case ENCODER_ENABLE_OUTPUT:
+		val = *(int *)arg;
+		if ((ret = fs453_enable(client, val)) == 0)
+			data->enable = val;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return ret;
+}
+
+/*!
+ * @brief Function to read TV encoder registers on the i2c bus
+ * @param     client	I2C client structure
+ * @param     reg	The register number
+ * @param     value	Pointer to buffer to receive the read data
+ * @param     len	Number of 16-bit register words to read
+ * @return    0 on success, others on failure
+ */
+static int fs453_read(struct i2c_client *client, u8 reg, u32 * value, u32 len)
+{
+	if (len == 1)
+		*value = i2c_smbus_read_byte_data(client, reg);
+	else if (len == 2)
+		*value = i2c_smbus_read_word_data(client, reg);
+	else if (len == 4) {
+		*(u16 *) value = i2c_smbus_read_word_data(client, reg);
+		*((u16 *) value + 1) =
+		    i2c_smbus_read_word_data(client, reg + 2);
+	} else
+		return -EINVAL;
+
+	return 0;
+}
+
+/*!
+ * @brief Function to write a TV encoder register on the i2c bus
+ * @param     client	I2C client structure
+ * @param     reg	The register number
+ * @param     value	The value to write
+ * @param     len	Number of words to write (must be 1)
+ * @return    0 on success, others on failure
+ */
+static int fs453_write(struct i2c_client *client, u8 reg, u32 value, u32 len)
+{
+	if (len == 1)
+		return i2c_smbus_write_byte_data(client, reg, (u8) value);
+	else if (len == 2)
+		return i2c_smbus_write_word_data(client, reg, (u16) value);
+	else if (len == 4)
+		return i2c_smbus_write_block_data(client, reg, len,
+						  (u8 *) & value);
+	else
+		return -EINVAL;
+}
+
+/*!
+ * @brief Function to initialize the TV encoder
+ * @param     client	I2C client structure
+ * @param     presets	FS453 pre-defined register values
+ * @return    0 on success; ENODEV if the encoder wasn't found
+ */
+static int fs453_preset(struct i2c_client *client,
+			struct fs453_presets *presets)
+{
+	u32 data;
+
+	if (!client)
+		return -ENODEV;
+
+	/* set the clock level */
+	fs453_write(client, FS453_CR, CR_GCC_CK_LVL, 2);
+
+	/* soft reset the encoder */
+	fs453_read(client, FS453_CR, &data, 2);
+	fs453_write(client, FS453_CR, data | CR_SRESET, 2);
+	fs453_write(client, FS453_CR, data & ~CR_SRESET, 2);
+
+	fs453_write(client, FS453_BYPASS, presets->bypass, 2);
+
+	/* Write the QPR (Quick Programming Register). */
+	fs453_write(client, FS453_QPR, presets->qpr, 2);
+
+	if (presets->mode != VIDEO_ENCODER_VGA) {
+		/* set up the NCO and PLL */
+		fs453_write(client, FS453_NCON, presets->ncon, 4);
+		fs453_write(client, FS453_NCOD, presets->ncod, 4);
+		fs453_write(client, FS453_PLL_M_PUMP, presets->pllm, 2);
+		fs453_write(client, FS453_PLL_N, presets->plln, 2);
+		fs453_write(client, FS453_PLL_PDIV, presets->pllpd, 2);
+
+		/* latch the NCO and PLL settings */
+		fs453_read(client, FS453_CR, &data, 2);
+		fs453_write(client, FS453_CR, data | CR_NCO_EN, 2);
+		fs453_write(client, FS453_CR, data & ~CR_NCO_EN, 2);
+	}
+
+	/* customize */
+	fs453_write(client, FS453_PWR_MGNT, presets->pwr_mgmt, 2);
+
+	fs453_write(client, FS453_IHO, presets->iho, 2);
+	fs453_write(client, FS453_IVO, presets->ivo, 2);
+	fs453_write(client, FS453_IHW, presets->ihw, 2);
+	fs453_write(client, FS453_VSC, presets->vsc, 2);
+	fs453_write(client, FS453_HSC, presets->hsc, 2);
+
+	fs453_write(client, FS453_MISC, presets->misc, 2);
+
+	fs453_write(client, FS453_VID_CNTL0, presets->vid_cntl0, 2);
+	fs453_write(client, FS453_MISC_46, presets->misc46, 1);
+	fs453_write(client, FS453_MISC_47, presets->misc47, 1);
+
+	fs453_write(client, FS453_DAC_CNTL, presets->dac_cntl, 2);
+	fs453_write(client, FS453_FIFO_LAT, presets->fifo_lat, 2);
+
+	return 0;
+}
+
+/*!
+ * @brief Function to enable/disable the TV encoder
+ * @param     client	I2C client structure
+ * @param     enable	0 to disable, others to enable
+ * @return    0 on success; ENODEV if the encoder wasn't found
+ */
+static int fs453_enable(struct i2c_client *client, int enable)
+{
+	struct fs453_data *data;
+
+	if (!client)
+		return -ENODEV;
+
+	data = i2c_get_clientdata(client);
+
+	if (enable)
+		return fs453_command(client, ENCODER_SET_NORM, &data->norm);
+	else
+		return fs453_write(client, FS453_PWR_MGNT, 0x3BFF, 2);
+}
+
+int fs453_startup(unsigned int cmd, void *arg)
+{
+	int chip_id;
+
+	if (!fs453_client)
+		return -ENODEV;
+
+	chip_id = i2c_smbus_read_word_data(fs453_client, FS453_ID);
+	if (chip_id != FS453_CHIP_ID) {
+		pr_info("FS453: TV encoder not present\n");
+		return -ENODEV;
+	}
+
+	pr_info("FS453: TV encoder present, ID=0x%04X\n", chip_id);
+
+	return fs453_command(fs453_client, cmd, arg);
+}
+
+EXPORT_SYMBOL(fs453_startup);
+
+static int fs453_probe(struct i2c_client *client,
+		       const struct i2c_device_id *did)
+{
+	struct fs453_data *fs453_data;
+	struct i2c_adapter *adapter = to_i2c_adapter(client->dev.parent);
+
+	pr_info("FS453/4 driver, (c) 2005 Freescale Semiconductor, Inc.\n");
+
+	if (!i2c_check_functionality(adapter,
+				     I2C_FUNC_SMBUS_WORD_DATA |
+				     I2C_FUNC_SMBUS_BYTE_DATA)) {
+		dev_warn(&adapter->dev,
+			 "I2C-Adapter doesn't support I2C_FUNC_SMBUS_WORD\n");
+		return -EIO;
+	}
+
+	fs453_data = kzalloc(sizeof(struct fs453_data), GFP_KERNEL);
+	if (!fs453_data)
+		return -ENOMEM;
+	
+	/* FS453 default status */
+	fs453_data->input = 0;
+	fs453_data->output = 0;
+	fs453_data->norm = 0;
+	fs453_data->enable = 0;
+	i2c_set_clientdata(client, fs453_data);
+
+	fs453_client = client;
+
+	return 0;
+}
+
+static int fs453_remove(struct i2c_client *client)
+{
+	struct fs453_data *fs453_data = i2c_get_clientdata(client);
+
+	kfree(fs453_data);
+
+	return 0;	
+}
+
+static const struct i2c_device_id fs453_id[] = {
+	{ "fs453", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, fs453_id);
+
+static struct i2c_driver fs453_driver = {
+	.driver = {
+		   .owner = THIS_MODULE,
+		   .name = "FS453 driver",
+		   },
+	.probe = fs453_probe,
+	.remove = fs453_remove,
+	.id_table = fs453_id,
+	.command = fs453_command,
+};
+
+static int __init fs453_init(void)
+{
+	return i2c_add_driver(&fs453_driver);
+}
+
+static void __exit fs453_exit(void)
+{
+	i2c_del_driver(&fs453_driver);
+}
+
+module_init(fs453_init);
+module_exit(fs453_exit);
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("FS453/4 TV encoder driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/video/fs453.h b/drivers/video/fs453.h
new file mode 100644
index 0000000..1edd114
--- /dev/null
+++ b/drivers/video/fs453.h
@@ -0,0 +1,134 @@
+/*
+ * Copyright 2005-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+ /*!
+  * @file fs453.h
+  * @brief Driver for FS453/4 TV encoder
+  *
+  * @ingroup FS453
+  */
+
+#ifndef __FS453_H__
+#define __FS453_H__
+
+/* I2C address of the FS453 chip */
+
+#define I2C1_BUS	0
+#define FS453_I2C_ADDR	0x6A
+
+/*!
+ *
+ * FS453 register file
+ *
+ */
+#define FS453_IHO		0x00	/*! Input Horizontal Offset */
+#define FS453_IVO		0x02	/*! Input Vertical Offset */
+#define FS453_IHW		0x04	/*! Input Horizontal Width */
+#define FS453_VSC		0x06	/*! Vertical Scaling Coefficient */
+#define FS453_HSC		0x08	/*! Horizontal Scaling Coefficient */
+#define FS453_BYPASS		0x0A	/*! BYPASS */
+#define FS453_CR		0x0C	/*! Command Register */
+#define FS453_MISC		0x0E	/*! Miscellaneous Bits Register */
+#define FS453_NCON		0x10	/*! Numerator of NCO Word */
+#define FS453_NCOD		0x14	/*! Denominator of NCO Word */
+#define FS453_PLL_M_PUMP	0x18	/*! PLL M and Pump Control */
+#define FS453_PLL_N		0x1A	/*! PLL N */
+#define FS453_PLL_PDIV		0x1C	/*! PLL Post-Divider */
+#define FS453_SHP		0x24	/*! Sharpness Filter */
+#define FS453_FLK		0x26	/*! Filcker Filter Coefficient */
+#define FS453_GPIO		0x28	/*! General Purpose I/O, Output Enab */
+#define FS453_ID		0x32	/*! Part Identification Number */
+#define FS453_STATUS		0x34	/*! Status Port */
+#define FS453_FIFO_SP		0x36	/*! FIFO Status Port Fill/Underrun */
+#define FS453_FIFO_LAT		0x38	/*! FIFO Latency */
+#define FS453_CHR_FREQ		0x40	/*! Chroma Subcarrier Frequency */
+#define FS453_CHR_PHASE		0x44	/*! Chroma Phase */
+#define FS453_MISC_45		0x45	/*! Miscellaneous Bits Register 45 */
+#define FS453_MISC_46		0x46	/*! Miscellaneous Bits Register 46 */
+#define FS453_MISC_47		0x47	/*! Miscellaneous Bits Register 47 */
+#define FS453_HSYNC_WID		0x48	/*! HSync Width */
+#define FS453_BURST_WID		0x49	/*! Burst Width */
+#define FS453_BPORCH		0x4A	/*! Back Porch Width */
+#define FS453_CB_BURST		0x4B	/*! Cb Burst Amplitude */
+#define FS453_CR_BURST		0x4C	/*! Cr Burst Amplitude */
+#define FS453_MISC_4D		0x4D	/*! Miscellaneous Bits Register 4D */
+#define FS453_BLACK_LVL		0x4E	/*! Black Level */
+#define FS453_BLANK_LVL		0x50	/*! Blank Level */
+#define FS453_NUM_LINES		0x57	/*! Number of Lines */
+#define FS453_WHITE_LVL		0x5E	/*! White Level */
+#define FS453_CB_GAIN		0x60	/*! Cb Color Saturation */
+#define FS453_CR_GAIN		0x62	/*! Cr Color Saturation */
+#define FS453_TINT		0x65	/*! Tint */
+#define FS453_BR_WAY		0x69	/*! Width of Breezeway */
+#define FS453_FR_PORCH		0x6C	/*! Front Porch */
+#define FS453_NUM_PIXELS	0x71	/*! Total num. of luma/chroma Pixels */
+#define FS453_1ST_LINE		0x73	/*! First Video Line */
+#define FS453_MISC_74		0x74	/*! Miscellaneous Bits Register 74 */
+#define FS453_SYNC_LVL		0x75	/*! Sync Level */
+#define FS453_VBI_BL_LVL	0x7C	/*! VBI Blank Level */
+#define FS453_SOFT_RST		0x7E	/*! Encoder Soft Reset */
+#define FS453_ENC_VER		0x7F	/*! Encoder Version */
+#define FS453_WSS_CONFIG	0x80	/*! WSS Configuration Register */
+#define FS453_WSS_CLK		0x81	/*! WSS Clock */
+#define FS453_WSS_DATAF1	0x83	/*! WSS Data Field 1 */
+#define FS453_WSS_DATAF0	0x86	/*! WSS Data Field 0 */
+#define FS453_WSS_LNF1		0x89	/*! WSS Line Number Field 1 */
+#define FS453_WSS_LNF0		0x8A	/*! WSS Line Number Field 0 */
+#define FS453_WSS_LVL		0x8B	/*! WSS Level */
+#define FS453_MISC_8D		0x8D	/*! Miscellaneous Bits Register 8D */
+#define FS453_VID_CNTL0		0x92	/*! Video Control 0 */
+#define FS453_HD_FP_SYNC	0x94	/*! Horiz. Front Porch & HSync Width */
+#define FS453_HD_YOFF_BP	0x96	/*! HDTV Lum. Offset & Back Porch */
+#define FS453_SYNC_DL		0x98	/*! Sync Delay Value */
+#define FS453_LD_DET		0x9C	/*! DAC Load Detect */
+#define FS453_DAC_CNTL		0x9E	/*! DAC Control */
+#define FS453_PWR_MGNT		0xA0	/*! Power Management */
+#define FS453_RED_MTX		0xA2	/*! RGB to YCrCb Matrix Red Coeff. */
+#define FS453_GRN_MTX		0xA4	/*! RGB to YCrCb Matrix Green Coeff. */
+#define FS453_BLU_MTX		0xA6	/*! RGB to YCrCb Matrix Blue Coeff. */
+#define FS453_RED_SCL		0xA8	/*! RGB to YCrCb Scaling Red Coeff. */
+#define FS453_GRN_SCL		0xAA	/*! RGB to YCrCb Scaling Green Coeff. */
+#define FS453_BLU_SCL		0xAC	/*! RGB to YCrCb Scaling Blue Coeff. */
+#define FS453_CC_FIELD_1	0xAE	/*! Closed Caption Field 1 Data */
+#define FS453_CC_FIELD_2	0xB0	/*! Closed Caption Field 2 Data */
+#define FS453_CC_CONTROL	0xB2	/*! Closed Caption Control */
+#define FS453_CC_BLANK_VALUE	0xB4	/*! Closed Caption Blanking Value */
+#define FS453_CC_BLANK_SAMPLE	0xB6	/*! Closed Caption Blanking Sample */
+#define FS453_HACT_ST		0xB8	/*! HDTV Horizontal Active Start */
+#define FS453_HACT_WD		0xBA	/*! HDTV Horizontal Active Width */
+#define FS453_VACT_ST		0xBC	/*! HDTV Veritical Active Width */
+#define FS453_VACT_HT		0xBE	/*! HDTV Veritical Active Height */
+#define FS453_PR_PB_SCALING	0xC0	/*! Pr and Pb Relative Scaling */
+#define FS453_LUMA_BANDWIDTH	0xC2	/*! Luminance Frequency Response */
+#define FS453_QPR		0xC4	/*! Quick Program Register */
+
+/*! Command register bits */
+
+#define CR_GCC_CK_LVL		0x2000	/*! Graphics Controller switching lev */
+#define CR_P656_LVL		0x1000	/*! Pixel Port Output switching level */
+#define CR_P656_IN		0x0800	/*! Pixel Port In */
+#define CR_P656_OUT		0x0400	/*! Pixel Port Out */
+#define CR_CBAR_480P		0x0200	/*! 480P Color Bars */
+#define CR_PAL_NTSCIN		0x0100	/*! PAL or NTSC input */
+#define CR_SYNC_MS		0x0080	/*! Sync Master or Slave */
+#define CR_FIFO_CLR		0x0040	/*! FIFO Clear */
+#define CR_CACQ_CLR		0x0020	/*! CACQ Clear */
+#define CR_CDEC_BP		0x0010	/*! Chroma Decimator Bypass */
+#define CR_NCO_EN		0x0002	/*! Enable NCO Latch */
+#define CR_SRESET		0x0001	/*! Soft Reset */
+
+/*! Chip ID register bits */
+
+#define FS453_CHIP_ID		0xFE05	/*! Chip ID register expected value */
+
+#endif				/* __FS453_H__ */
-- 
1.6.3.1

