From 4146c220a1d28faf8065e67f3c44ff365daac7ac Mon Sep 17 00:00:00 2001
From: builder <builder@black.easi.ru>
Date: Fri, 6 Feb 2009 18:11:27 +0300
Subject: [PATCH] Driver for OV2640 CMOS Image Sensor from Omnivision

Driver for OV2640 CMOS Image Sensor from Omnivision

Signed-off-by: Vladimir Barinov <vbarinov@embeddedlley.com>
---
 drivers/media/video/Kconfig     |    6 +
 drivers/media/video/Makefile    |    1 +
 drivers/media/video/ov2640.c    |  302 +++++++++++++++++++++++++++
 drivers/media/video/ov2640.h    |  426 +++++++++++++++++++++++++++++++++++++++
 include/media/v4l2-chip-ident.h |    1 +
 5 files changed, 736 insertions(+), 0 deletions(-)
 create mode 100644 drivers/media/video/ov2640.c
 create mode 100644 drivers/media/video/ov2640.h

diff --git a/drivers/media/video/Kconfig b/drivers/media/video/Kconfig
index 6a27d07..380451e 100644
--- a/drivers/media/video/Kconfig
+++ b/drivers/media/video/Kconfig
@@ -989,6 +989,12 @@ config MT9V022_PCA9536_SWITCH
 	  Select this if your MT9V022 camera uses a PCA9536 I2C GPIO
 	  extender to switch between 8 and 10 bit datawidth modes
 
+config SOC_CAMERA_OV2640
+	tristate "OmniVision OV2640 sensor support"
+	depends on VIDEO_MX27 && I2C
+	help
+	  This driver supports OV2640 cameras from OmniVision
+
 config SOC_CAMERA_PLATFORM
 	tristate "platform camera support"
 	depends on SOC_CAMERA
diff --git a/drivers/media/video/Makefile b/drivers/media/video/Makefile
index ab094a5..64c1a72 100644
--- a/drivers/media/video/Makefile
+++ b/drivers/media/video/Makefile
@@ -145,6 +145,7 @@ obj-$(CONFIG_SOC_CAMERA)	+= soc_camera.o
 obj-$(CONFIG_SOC_CAMERA_MT9M001)	+= mt9m001.o
 obj-$(CONFIG_SOC_CAMERA_MT9V022)	+= mt9v022.o
 obj-$(CONFIG_SOC_CAMERA_PLATFORM)	+= soc_camera_platform.o
+obj-$(CONFIG_SOC_CAMERA_OV2640)		+= ov2640.o
 
 obj-$(CONFIG_VIDEO_AU0828) += au0828/
 
diff --git a/drivers/media/video/ov2640.c b/drivers/media/video/ov2640.c
new file mode 100644
index 0000000..454d6d1
--- /dev/null
+++ b/drivers/media/video/ov2640.c
@@ -0,0 +1,302 @@
+/*
+ * Driver for OV2640 CMOS Image Sensor from Omnivision
+ *
+ * Copyright (C) 2009, Vladimir Barinov <vbarinov@embeddedalley.com>
+ * Based on mt9m001 driver,
+ * Copyright (C) 2008, Guennadi Liakhovetski <kernel@pengutronix.de>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/videodev2.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/log2.h>
+#include <linux/gpio.h>
+
+#include <media/v4l2-common.h>
+#include <media/v4l2-chip-ident.h>
+#include <media/soc_camera.h>
+
+/* TODO: replace the FSL init array to driver form */
+#include "ov2640.h"
+
+/* 0v2640 i2c address 0x30
+ * The platform has to define i2c_board_info
+ * and call i2c_register_board_info() */
+
+/* ov2640 selected register addresses */
+#define OV2640_MIDH	0x1C
+#define OV2640_MIDL	0x1D
+#define OV2640_BANK	0xFF
+
+static const struct soc_camera_data_format ov2640_colour_formats[] = {
+	{
+		.name		= "4:2:2, packed, UYVY",
+		.depth		= 16,
+		.fourcc		= V4L2_PIX_FMT_UYVY,
+		.colorspace	= V4L2_COLORSPACE_JPEG,
+	},
+};
+
+struct ov2640 {
+	struct i2c_client *client;
+	struct soc_camera_device icd;
+	int model;	/* V4L2_IDENT_OV2640* codes from v4l2-chip-ident.h */
+};
+
+static int reg_read(struct soc_camera_device *icd, const u8 reg)
+{
+	struct ov2640 *ov2640 = container_of(icd, struct ov2640, icd);
+	struct i2c_client *client = ov2640->client;
+	s32 data = i2c_smbus_read_byte_data(client, reg);
+	return data;
+}
+
+static int reg_write(struct soc_camera_device *icd, const u8 reg,
+		     const u8 data)
+{
+	struct ov2640 *ov2640 = container_of(icd, struct ov2640, icd);
+	return i2c_smbus_write_byte_data(ov2640->client, reg, data);
+}
+
+static int reg_set(struct soc_camera_device *icd, const u8 reg,
+		   const u8 data)
+{
+	int ret;
+
+	ret = reg_read(icd, reg);
+	if (ret < 0)
+		return ret;
+	return reg_write(icd, reg, ret | data);
+}
+
+static int reg_clear(struct soc_camera_device *icd, const u8 reg,
+		     const u8 data)
+{
+	int ret;
+
+	ret = reg_read(icd, reg);
+	if (ret < 0)
+		return ret;
+	return reg_write(icd, reg, ret & ~data);
+}
+
+static int ov2640_init(struct soc_camera_device *icd)
+{
+	return 0;
+}
+
+static int ov2640_release(struct soc_camera_device *icd)
+{
+	return 0;
+}
+
+static int ov2640_start_capture(struct soc_camera_device *icd)
+{
+	return 0;
+}
+
+static int ov2640_stop_capture(struct soc_camera_device *icd)
+{
+	return 0;
+}
+
+static int ov2640_set_bus_param(struct soc_camera_device *icd,
+				 unsigned long flags)
+{
+	return 0;
+}
+
+static unsigned long ov2640_query_bus_param(struct soc_camera_device *icd)
+{
+	/* currently ov2640 has all capture_format parameters fixed */
+	return SOCAM_PCLK_SAMPLE_RISING |
+		SOCAM_HSYNC_ACTIVE_HIGH |
+		SOCAM_VSYNC_ACTIVE_HIGH |
+		SOCAM_MASTER;
+}
+
+static int ov2640_set_fmt_cap(struct soc_camera_device *icd,
+		__u32 pixfmt, struct v4l2_rect *rect)
+{
+	if ((rect->width == 800) && (rect->height == 600))
+		ov2640_init_800_600(icd);
+
+	if ((rect->width == 1600) && (rect->height == 1120))
+		ov2640_init_1600_1120(icd);
+
+	return 0;
+}
+
+static int ov2640_try_fmt_cap(struct soc_camera_device *icd,
+			       struct v4l2_format *f)
+{
+	/* currently only 2 window formats are supported 800x600, 1600x1120 */
+	if (((f->fmt.pix.width == 800) && (f->fmt.pix.height == 600)) ||
+	    ((f->fmt.pix.width == 1600) && (f->fmt.pix.height == 1120)))
+		return 0;
+
+	return -EINVAL;
+}
+
+static int ov2640_get_chip_id(struct soc_camera_device *icd,
+			       struct v4l2_chip_ident *id)
+{
+	struct ov2640 *ov2640 = container_of(icd, struct ov2640, icd);
+
+	if (id->match_type != V4L2_CHIP_MATCH_I2C_ADDR)
+		return -EINVAL;
+
+	if (id->match_chip != ov2640->client->addr)
+		return -ENODEV;
+
+	id->ident	= ov2640->model;
+	id->revision	= 0;
+
+	return 0;
+}
+
+/* Interface active, can use i2c. If it fails, it can indeed mean, that
+ * this wasn't our capture interface, so, we wait for the right one */
+static int ov2640_video_probe(struct soc_camera_device *icd)
+{
+	struct ov2640 *ov2640 = container_of(icd, struct ov2640, icd);
+	u32 data;
+	int ret = 0;
+
+	/* We must have a parent by now. And it cannot be a wrong one.
+	 * So this entire test is completely redundant. */
+	if (!icd->dev.parent ||
+	    to_soc_camera_host(icd->dev.parent)->nr != icd->link->bus_id)
+		return -ENODEV;
+
+	/* Read out the chip ID registers */
+	reg_set(icd, OV2640_BANK, 1);
+	data = reg_read(icd, OV2640_MIDH);
+	data = (data << 8) | reg_read(icd, OV2640_MIDL);
+
+	ov2640->model = V4L2_IDENT_OV2640;
+	icd->formats = ov2640_colour_formats;
+	icd->num_formats = ARRAY_SIZE(ov2640_colour_formats);
+
+	dev_info(&icd->dev, "Detected a OV2640 chip ID %x\n", data);
+
+	/* Now that we know the model, we can start video */
+	ret = soc_camera_video_start(icd);
+
+	return ret;
+}
+
+static void ov2640_video_remove(struct soc_camera_device *icd)
+{
+	struct ov2640 *ov2640 = container_of(icd, struct ov2640, icd);
+
+	dev_dbg(&icd->dev, "Video %x removed: %p, %p\n", ov2640->client->addr,
+		ov2640->icd.dev.parent, ov2640->icd.vdev);
+
+	soc_camera_video_stop(&ov2640->icd);
+}
+
+static struct soc_camera_ops ov2640_ops = {
+	.owner			= THIS_MODULE,
+	.probe			= ov2640_video_probe,
+	.remove			= ov2640_video_remove,
+	.init			= ov2640_init,
+	.release		= ov2640_release,
+	.start_capture		= ov2640_start_capture,
+	.stop_capture		= ov2640_stop_capture,
+	.set_fmt_cap		= ov2640_set_fmt_cap,
+	.try_fmt_cap		= ov2640_try_fmt_cap,
+	.set_bus_param		= ov2640_set_bus_param,
+	.query_bus_param	= ov2640_query_bus_param,
+	.get_chip_id		= ov2640_get_chip_id,
+};
+
+static int ov2640_probe(struct i2c_client *client,
+			 const struct i2c_device_id *did)
+{
+	struct ov2640 *ov2640;
+	struct soc_camera_device *icd;
+	struct i2c_adapter *adapter = to_i2c_adapter(client->dev.parent);
+	struct soc_camera_link *icl = client->dev.platform_data;
+	int ret;
+
+	if (!icl) {
+		dev_err(&client->dev, "OV2640 driver needs platform data\n");
+		return -EINVAL;
+	}
+
+	if (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_WORD_DATA)) {
+		dev_warn(&adapter->dev,
+			 "I2C-Adapter doesn't support I2C_FUNC_SMBUS_WORD\n");
+		return -EIO;
+	}
+
+	ov2640 = kzalloc(sizeof(struct ov2640), GFP_KERNEL);
+	if (!ov2640)
+		return -ENOMEM;
+
+	ov2640->client = client;
+	i2c_set_clientdata(client, ov2640);
+
+	/* Second stage probe - when a capture adapter is there */
+	icd = &ov2640->icd;
+	icd->ops	= &ov2640_ops;
+	icd->control	= &client->dev;
+	icd->link	= icl;
+
+	ret = soc_camera_device_register(icd);
+	if (ret)
+		goto eisdr;
+
+	return 0;
+
+eisdr:
+	kfree(ov2640);
+	return ret;
+}
+
+static int ov2640_remove(struct i2c_client *client)
+{
+	struct ov2640 *ov2640 = i2c_get_clientdata(client);
+
+	soc_camera_device_unregister(&ov2640->icd);
+	kfree(ov2640);
+
+	return 0;
+}
+
+static const struct i2c_device_id ov2640_id[] = {
+	{ "ov2640", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, ov2640_id);
+
+static struct i2c_driver ov2640_i2c_driver = {
+	.driver = {
+		.name = "ov2640",
+	},
+	.probe		= ov2640_probe,
+	.remove		= ov2640_remove,
+	.id_table	= ov2640_id,
+};
+
+static int __init ov2640_mod_init(void)
+{
+	return i2c_add_driver(&ov2640_i2c_driver);
+}
+
+static void __exit ov2640_mod_exit(void)
+{
+	i2c_del_driver(&ov2640_i2c_driver);
+}
+
+module_init(ov2640_mod_init);
+module_exit(ov2640_mod_exit);
+
+MODULE_DESCRIPTION("Omnivision OV2640 Camera driver");
+MODULE_AUTHOR("Vladimir Barinov <vbarinov@embeddedalley.com>");
+MODULE_LICENSE("GPL");
diff --git a/drivers/media/video/ov2640.h b/drivers/media/video/ov2640.h
new file mode 100644
index 0000000..c59dd3b
--- /dev/null
+++ b/drivers/media/video/ov2640.h
@@ -0,0 +1,426 @@
+/*
+ * Copyright 2005-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/delay.h>
+
+static int reg_write(struct soc_camera_device *icd, const u8 reg,
+                     const u8 data);
+#define ov2640_write_reg(a,b) reg_write(icd,a,b)
+
+/* should be replaced by width and height version. */
+static int ov2640_init_1600_1120(struct soc_camera_device *icd)
+{
+	ov2640_write_reg(0xff, 1);
+	ov2640_write_reg(0x12, 0x80);
+	udelay(1000);
+	ov2640_write_reg(0xff, 0x00);
+	ov2640_write_reg(0x2c, 0xff);
+	ov2640_write_reg(0x2e, 0xdf);
+	ov2640_write_reg(0xff, 0x01);
+	ov2640_write_reg(0x3c, 0x32);
+	ov2640_write_reg(0x11, 0x01);
+	ov2640_write_reg(0x09, 0x00);
+	ov2640_write_reg(0x04, 0x28);
+	ov2640_write_reg(0x13, 0xe5);
+	ov2640_write_reg(0x14, 0x48);
+	ov2640_write_reg(0x2c, 0x0c);
+	ov2640_write_reg(0x33, 0x78);
+	ov2640_write_reg(0x3a, 0x33);
+	ov2640_write_reg(0x3b, 0xfb);
+	ov2640_write_reg(0x3e, 0x00);
+	ov2640_write_reg(0x43, 0x11);
+	ov2640_write_reg(0x16, 0x10);
+	ov2640_write_reg(0x39, 0x82);
+	ov2640_write_reg(0x35, 0x88);
+	ov2640_write_reg(0x22, 0x0a);
+	ov2640_write_reg(0x37, 0x40);
+	ov2640_write_reg(0x23, 0x00);
+	ov2640_write_reg(0x34, 0xa0);
+	ov2640_write_reg(0x36, 0x1a);
+	ov2640_write_reg(0x06, 0x02);
+	ov2640_write_reg(0x07, 0xc0);
+	ov2640_write_reg(0x0d, 0xb7);
+	ov2640_write_reg(0x0e, 0x01);
+	ov2640_write_reg(0x4c, 0x00);
+	ov2640_write_reg(0x4a, 0x81);
+	ov2640_write_reg(0x21, 0x99);
+	ov2640_write_reg(0x24, 0x40);
+	ov2640_write_reg(0x25, 0x38);
+	ov2640_write_reg(0x26, 0x82);
+	ov2640_write_reg(0x5c, 0x00);
+	ov2640_write_reg(0x63, 0x00);
+	ov2640_write_reg(0x46, 0x3f);
+	ov2640_write_reg(0x0c, 0x3c);
+	ov2640_write_reg(0x5d, 0x55);
+	ov2640_write_reg(0x5e, 0x7d);
+	ov2640_write_reg(0x5f, 0x7d);
+	ov2640_write_reg(0x60, 0x55);
+	ov2640_write_reg(0x61, 0x70);
+	ov2640_write_reg(0x62, 0x80);
+	ov2640_write_reg(0x7c, 0x05);
+	ov2640_write_reg(0x20, 0x80);
+	ov2640_write_reg(0x28, 0x30);
+	ov2640_write_reg(0x6c, 0x00);
+	ov2640_write_reg(0x6d, 0x80);
+	ov2640_write_reg(0x6e, 0x00);
+	ov2640_write_reg(0x70, 0x02);
+	ov2640_write_reg(0x71, 0x94);
+	ov2640_write_reg(0x73, 0xc1);
+	ov2640_write_reg(0x3d, 0x34);
+	ov2640_write_reg(0x5a, 0x57);
+	ov2640_write_reg(0x4f, 0xbb);
+	ov2640_write_reg(0x50, 0x9c);
+	ov2640_write_reg(0xff, 0x00);
+	ov2640_write_reg(0xe5, 0x7f);
+	ov2640_write_reg(0xf9, 0xc0);
+	ov2640_write_reg(0x41, 0x24);
+	ov2640_write_reg(0x44, 0x06);
+	ov2640_write_reg(0xe0, 0x14);
+	ov2640_write_reg(0x76, 0xff);
+	ov2640_write_reg(0x33, 0xa0);
+	ov2640_write_reg(0x42, 0x20);
+	ov2640_write_reg(0x43, 0x18);
+	ov2640_write_reg(0x4c, 0x00);
+	ov2640_write_reg(0x87, 0xd0);
+	ov2640_write_reg(0xd7, 0x03);
+	ov2640_write_reg(0xd9, 0x10);
+	ov2640_write_reg(0xd3, 0x82);
+	ov2640_write_reg(0xc8, 0x08);
+	ov2640_write_reg(0xc9, 0x80);
+	ov2640_write_reg(0x7c, 0x00);
+	ov2640_write_reg(0x7d, 0x00);
+	ov2640_write_reg(0x7c, 0x03);
+	ov2640_write_reg(0x7d, 0x48);
+	ov2640_write_reg(0x7d, 0x48);
+	ov2640_write_reg(0x7c, 0x08);
+	ov2640_write_reg(0x7d, 0x20);
+	ov2640_write_reg(0x7d, 0x10);
+	ov2640_write_reg(0x7d, 0x0e);
+	ov2640_write_reg(0x90, 0x00);
+	ov2640_write_reg(0x91, 0x0e);
+	ov2640_write_reg(0x91, 0x1a);
+	ov2640_write_reg(0x91, 0x31);
+	ov2640_write_reg(0x91, 0x5a);
+	ov2640_write_reg(0x91, 0x69);
+	ov2640_write_reg(0x91, 0x75);
+	ov2640_write_reg(0x91, 0x7e);
+	ov2640_write_reg(0x91, 0x88);
+	ov2640_write_reg(0x91, 0x8f);
+	ov2640_write_reg(0x91, 0x96);
+	ov2640_write_reg(0x91, 0xa3);
+	ov2640_write_reg(0x91, 0xaf);
+	ov2640_write_reg(0x91, 0xc4);
+	ov2640_write_reg(0x91, 0xd7);
+	ov2640_write_reg(0x91, 0xe8);
+	ov2640_write_reg(0x91, 0x20);
+
+	ov2640_write_reg(0x92, 0x00);
+	ov2640_write_reg(0x93, 0x06);
+	ov2640_write_reg(0x93, 0xe3);
+	ov2640_write_reg(0x93, 0x03);
+	ov2640_write_reg(0x93, 0x03);
+	ov2640_write_reg(0x93, 0x00);
+	ov2640_write_reg(0x93, 0x02);
+	ov2640_write_reg(0x93, 0x00);
+	ov2640_write_reg(0x93, 0x00);
+	ov2640_write_reg(0x93, 0x00);
+	ov2640_write_reg(0x93, 0x00);
+	ov2640_write_reg(0x93, 0x00);
+	ov2640_write_reg(0x93, 0x00);
+	ov2640_write_reg(0x93, 0x00);
+
+	ov2640_write_reg(0x96, 0x00);
+	ov2640_write_reg(0x97, 0x08);
+	ov2640_write_reg(0x97, 0x19);
+	ov2640_write_reg(0x97, 0x02);
+	ov2640_write_reg(0x97, 0x0c);
+	ov2640_write_reg(0x97, 0x24);
+	ov2640_write_reg(0x97, 0x30);
+	ov2640_write_reg(0x97, 0x28);
+	ov2640_write_reg(0x97, 0x26);
+	ov2640_write_reg(0x97, 0x02);
+	ov2640_write_reg(0x97, 0x98);
+	ov2640_write_reg(0x97, 0x80);
+	ov2640_write_reg(0x97, 0x00);
+	ov2640_write_reg(0x97, 0x00);
+
+	ov2640_write_reg(0xa4, 0x00);
+	ov2640_write_reg(0xa8, 0x00);
+	ov2640_write_reg(0xc5, 0x11);
+	ov2640_write_reg(0xc6, 0x51);
+	ov2640_write_reg(0xbf, 0x80);
+	ov2640_write_reg(0xc7, 0x10);
+	ov2640_write_reg(0xb6, 0x66);
+	ov2640_write_reg(0xb8, 0xa5);
+	ov2640_write_reg(0xb7, 0x64);
+	ov2640_write_reg(0xb9, 0x7c);
+	ov2640_write_reg(0xb3, 0xaf);
+	ov2640_write_reg(0xb4, 0x97);
+	ov2640_write_reg(0xb5, 0xff);
+	ov2640_write_reg(0xb0, 0xc5);
+	ov2640_write_reg(0xb1, 0x94);
+	ov2640_write_reg(0xb2, 0x0f);
+	ov2640_write_reg(0xc4, 0x5c);
+
+	ov2640_write_reg(0xa6, 0x00);
+	ov2640_write_reg(0xa7, 0x20);
+	ov2640_write_reg(0xa7, 0xd8);
+	ov2640_write_reg(0xa7, 0x1b);
+	ov2640_write_reg(0xa7, 0x31);
+	ov2640_write_reg(0xa7, 0x00);
+	ov2640_write_reg(0xa7, 0x18);
+	ov2640_write_reg(0xa7, 0x20);
+	ov2640_write_reg(0xa7, 0xd8);
+	ov2640_write_reg(0xa7, 0x19);
+	ov2640_write_reg(0xa7, 0x31);
+	ov2640_write_reg(0xa7, 0x00);
+	ov2640_write_reg(0xa7, 0x18);
+	ov2640_write_reg(0xa7, 0x20);
+	ov2640_write_reg(0xa7, 0xd8);
+	ov2640_write_reg(0xa7, 0x19);
+	ov2640_write_reg(0xa7, 0x31);
+	ov2640_write_reg(0xa7, 0x00);
+	ov2640_write_reg(0xa7, 0x18);
+
+	ov2640_write_reg(0xc0, 0xc8);
+	ov2640_write_reg(0xc1, 0x96);
+	ov2640_write_reg(0x86, 0x3d);
+	ov2640_write_reg(0x50, 0x00);
+	ov2640_write_reg(0x51, 0x90);
+	ov2640_write_reg(0x52, 0x18);
+	ov2640_write_reg(0x53, 0x00);
+	ov2640_write_reg(0x54, 0x00);
+	ov2640_write_reg(0x55, 0x88);
+	ov2640_write_reg(0x57, 0x00);
+	ov2640_write_reg(0x5a, 0x90);
+	ov2640_write_reg(0x5b, 0x18);
+	ov2640_write_reg(0x5c, 0x05);
+	ov2640_write_reg(0xc3, 0xef);
+	ov2640_write_reg(0x7f, 0x00);
+	ov2640_write_reg(0xda, 0x01);
+	ov2640_write_reg(0xe5, 0x1f);
+	ov2640_write_reg(0xe1, 0x67);
+	ov2640_write_reg(0xe0, 0x00);
+	ov2640_write_reg(0xdd, 0x7f);
+	ov2640_write_reg(0x05, 0x00);
+
+	return 0;
+}
+
+static int ov2640_init_800_600(struct soc_camera_device *icd)
+{
+	ov2640_write_reg(0xff, 0x00);
+	ov2640_write_reg(0xff, 0x01);
+	ov2640_write_reg(0x12, 0x80);
+	udelay(1000);
+	ov2640_write_reg(0xff, 0x00);
+	ov2640_write_reg(0x2c, 0xff);
+	ov2640_write_reg(0x2e, 0xdf);
+	ov2640_write_reg(0xff, 0x01);
+	ov2640_write_reg(0x3c, 0x32);
+	ov2640_write_reg(0x11, 0x01);
+	ov2640_write_reg(0x09, 0x00);
+	ov2640_write_reg(0x04, 0x28);
+	ov2640_write_reg(0x13, 0xe5);
+	ov2640_write_reg(0x14, 0x48);
+	ov2640_write_reg(0x2c, 0x0c);
+	ov2640_write_reg(0x33, 0x78);
+	ov2640_write_reg(0x3a, 0x33);
+	ov2640_write_reg(0x3b, 0xfb);
+	ov2640_write_reg(0x3e, 0x00);
+	ov2640_write_reg(0x43, 0x11);
+	ov2640_write_reg(0x16, 0x10);
+	ov2640_write_reg(0x39, 0x92);
+	ov2640_write_reg(0x35, 0xda);
+	ov2640_write_reg(0x22, 0x1a);
+	ov2640_write_reg(0x37, 0xc3);
+	ov2640_write_reg(0x23, 0x00);
+	ov2640_write_reg(0x34, 0xc0);
+	ov2640_write_reg(0x36, 0x1a);
+	ov2640_write_reg(0x06, 0x88);
+	ov2640_write_reg(0x07, 0xc0);
+	ov2640_write_reg(0x0d, 0x87);
+	ov2640_write_reg(0x0e, 0x41);
+	ov2640_write_reg(0x4c, 0x00);
+	ov2640_write_reg(0x4a, 0x81);
+	ov2640_write_reg(0x21, 0x99);
+	ov2640_write_reg(0x24, 0x40);
+	ov2640_write_reg(0x25, 0x38);
+	ov2640_write_reg(0x26, 0x82);
+	ov2640_write_reg(0x5c, 0x00);
+	ov2640_write_reg(0x63, 0x00);
+	ov2640_write_reg(0x46, 0x22);
+	ov2640_write_reg(0x0c, 0x3c);
+	ov2640_write_reg(0x5d, 0x55);
+	ov2640_write_reg(0x5e, 0x7d);
+	ov2640_write_reg(0x5f, 0x7d);
+	ov2640_write_reg(0x60, 0x55);
+	ov2640_write_reg(0x61, 0x70);
+	ov2640_write_reg(0x62, 0x80);
+	ov2640_write_reg(0x7c, 0x05);
+	ov2640_write_reg(0x20, 0x80);
+	ov2640_write_reg(0x28, 0x30);
+	ov2640_write_reg(0x6c, 0x00);
+	ov2640_write_reg(0x6d, 0x80);
+	ov2640_write_reg(0x6e, 0x00);
+	ov2640_write_reg(0x70, 0x02);
+	ov2640_write_reg(0x71, 0x94);
+	ov2640_write_reg(0x73, 0xc1);
+	ov2640_write_reg(0x12, 0x40);
+	ov2640_write_reg(0x17, 0x11);
+	ov2640_write_reg(0x18, 0x43);
+	ov2640_write_reg(0x19, 0x00);
+	ov2640_write_reg(0x1a, 0x4b);
+	ov2640_write_reg(0x32, 0x09);
+	ov2640_write_reg(0x37, 0xc0);
+	ov2640_write_reg(0x4f, 0xca);
+	ov2640_write_reg(0x50, 0xa8);
+	ov2640_write_reg(0x6d, 0x00);
+	ov2640_write_reg(0x3d, 0x38);
+	ov2640_write_reg(0xff, 0x00);
+	ov2640_write_reg(0xe5, 0x7f);
+	ov2640_write_reg(0xf9, 0xc0);
+	ov2640_write_reg(0x41, 0x24);
+	ov2640_write_reg(0x44, 0x06);
+	ov2640_write_reg(0xe0, 0x14);
+	ov2640_write_reg(0x76, 0xff);
+	ov2640_write_reg(0x33, 0xa0);
+	ov2640_write_reg(0x42, 0x20);
+	ov2640_write_reg(0x43, 0x18);
+	ov2640_write_reg(0x4c, 0x00);
+	ov2640_write_reg(0x87, 0xd0);
+	ov2640_write_reg(0x88, 0x3f);
+	ov2640_write_reg(0xd7, 0x03);
+	ov2640_write_reg(0xd9, 0x10);
+	ov2640_write_reg(0xd3, 0x82);
+	ov2640_write_reg(0xc8, 0x08);
+	ov2640_write_reg(0xc9, 0x80);
+	ov2640_write_reg(0x7c, 0x00);
+	ov2640_write_reg(0x7d, 0x00);
+	ov2640_write_reg(0x7c, 0x03);
+	ov2640_write_reg(0x7d, 0x48);
+	ov2640_write_reg(0x7d, 0x48);
+	ov2640_write_reg(0x7c, 0x08);
+	ov2640_write_reg(0x7d, 0x20);
+	ov2640_write_reg(0x7d, 0x10);
+	ov2640_write_reg(0x7d, 0x0e);
+	ov2640_write_reg(0x90, 0x00);
+	ov2640_write_reg(0x91, 0x0e);
+	ov2640_write_reg(0x91, 0x1a);
+	ov2640_write_reg(0x91, 0x31);
+	ov2640_write_reg(0x91, 0x5a);
+	ov2640_write_reg(0x91, 0x69);
+	ov2640_write_reg(0x91, 0x75);
+	ov2640_write_reg(0x91, 0x7e);
+	ov2640_write_reg(0x91, 0x88);
+	ov2640_write_reg(0x91, 0x8f);
+	ov2640_write_reg(0x91, 0x96);
+	ov2640_write_reg(0x91, 0xa3);
+	ov2640_write_reg(0x91, 0xaf);
+	ov2640_write_reg(0x91, 0xc4);
+	ov2640_write_reg(0x91, 0xd7);
+	ov2640_write_reg(0x91, 0xe8);
+	ov2640_write_reg(0x91, 0x20);
+
+	ov2640_write_reg(0x92, 0x00);
+	ov2640_write_reg(0x93, 0x06);
+	ov2640_write_reg(0x93, 0xe3);
+	ov2640_write_reg(0x93, 0x03);
+	ov2640_write_reg(0x93, 0x03);
+	ov2640_write_reg(0x93, 0x00);
+	ov2640_write_reg(0x93, 0x02);
+	ov2640_write_reg(0x93, 0x00);
+	ov2640_write_reg(0x93, 0x00);
+	ov2640_write_reg(0x93, 0x00);
+	ov2640_write_reg(0x93, 0x00);
+	ov2640_write_reg(0x93, 0x00);
+	ov2640_write_reg(0x93, 0x00);
+	ov2640_write_reg(0x93, 0x00);
+
+	ov2640_write_reg(0x96, 0x00);
+	ov2640_write_reg(0x97, 0x08);
+	ov2640_write_reg(0x97, 0x19);
+	ov2640_write_reg(0x97, 0x02);
+	ov2640_write_reg(0x97, 0x0c);
+	ov2640_write_reg(0x97, 0x24);
+	ov2640_write_reg(0x97, 0x30);
+	ov2640_write_reg(0x97, 0x28);
+	ov2640_write_reg(0x97, 0x26);
+	ov2640_write_reg(0x97, 0x02);
+	ov2640_write_reg(0x97, 0x98);
+	ov2640_write_reg(0x97, 0x80);
+	ov2640_write_reg(0x97, 0x00);
+	ov2640_write_reg(0x97, 0x00);
+
+	ov2640_write_reg(0xa4, 0x00);
+	ov2640_write_reg(0xa8, 0x00);
+	ov2640_write_reg(0xc5, 0x11);
+	ov2640_write_reg(0xc6, 0x51);
+	ov2640_write_reg(0xbf, 0x80);
+	ov2640_write_reg(0xc7, 0x10);
+	ov2640_write_reg(0xb6, 0x66);
+	ov2640_write_reg(0xb8, 0xa5);
+	ov2640_write_reg(0xb7, 0x64);
+	ov2640_write_reg(0xb9, 0x7c);
+	ov2640_write_reg(0xb3, 0xaf);
+	ov2640_write_reg(0xb4, 0x97);
+	ov2640_write_reg(0xb5, 0xff);
+	ov2640_write_reg(0xb0, 0xc5);
+	ov2640_write_reg(0xb1, 0x94);
+	ov2640_write_reg(0xb2, 0x0f);
+	ov2640_write_reg(0xc4, 0x5c);
+
+	ov2640_write_reg(0xa6, 0x00);
+	ov2640_write_reg(0xa7, 0x20);
+	ov2640_write_reg(0xa7, 0xd8);
+	ov2640_write_reg(0xa7, 0x1b);
+	ov2640_write_reg(0xa7, 0x31);
+	ov2640_write_reg(0xa7, 0x00);
+	ov2640_write_reg(0xa7, 0x18);
+	ov2640_write_reg(0xa7, 0x20);
+	ov2640_write_reg(0xa7, 0xd8);
+	ov2640_write_reg(0xa7, 0x19);
+	ov2640_write_reg(0xa7, 0x31);
+	ov2640_write_reg(0xa7, 0x00);
+	ov2640_write_reg(0xa7, 0x18);
+	ov2640_write_reg(0xa7, 0x20);
+	ov2640_write_reg(0xa7, 0xd8);
+	ov2640_write_reg(0xa7, 0x19);
+	ov2640_write_reg(0xa7, 0x31);
+	ov2640_write_reg(0xa7, 0x00);
+	ov2640_write_reg(0xa7, 0x18);
+
+	ov2640_write_reg(0xc0, 0x64);
+	ov2640_write_reg(0xc1, 0x4b);
+	ov2640_write_reg(0x86, 0x1d);
+	ov2640_write_reg(0x50, 0x00);
+	ov2640_write_reg(0x51, 0xc8);
+	ov2640_write_reg(0x52, 0x96);
+	ov2640_write_reg(0x53, 0x00);
+	ov2640_write_reg(0x54, 0x00);
+	ov2640_write_reg(0x55, 0x00);
+	ov2640_write_reg(0x57, 0x00);
+	ov2640_write_reg(0x5a, 0xc8);
+	ov2640_write_reg(0x5b, 0x96);
+	ov2640_write_reg(0x5c, 0x00);
+	ov2640_write_reg(0xc3, 0xef);
+	ov2640_write_reg(0x7f, 0x00);
+	ov2640_write_reg(0xda, 0x01);
+	ov2640_write_reg(0xe5, 0x1f);
+	ov2640_write_reg(0xe1, 0x67);
+	ov2640_write_reg(0xe0, 0x00);
+	ov2640_write_reg(0xdd, 0x7f);
+	ov2640_write_reg(0x05, 0x00);
+
+	return 0;
+}
diff --git a/include/media/v4l2-chip-ident.h b/include/media/v4l2-chip-ident.h
index 41b509b..4b9f8e4 100644
--- a/include/media/v4l2-chip-ident.h
+++ b/include/media/v4l2-chip-ident.h
@@ -60,6 +60,7 @@ enum {
 
 	/* OmniVision sensors: reserved range 250-299 */
 	V4L2_IDENT_OV7670 = 250,
+	V4L2_IDENT_OV2640 = 255,
 
 	/* Conexant MPEG encoder/decoders: reserved range 410-420 */
 	V4L2_IDENT_CX23415 = 415,
-- 
1.5.5.1

