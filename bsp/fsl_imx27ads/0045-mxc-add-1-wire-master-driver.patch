From 203074c2f6cd6a1a370331148f4cd6af945f91dd Mon Sep 17 00:00:00 2001
From: Alexander Smirnov <asmirnov@embeddedalley.com>
Date: Mon, 29 Dec 2008 22:23:24 +0300
Subject: [PATCH 45/77] mxc: add 1-wire master driver

This patch adds support for the 1-wire master interface for i.MX27 and
i.MX31.

In addition to the upstream patch we also define the GPIO pins used
by the mx27 and mx31.

Signed-off-by: Quinn Jensen <quinn.jensen@freescale.com>
Signed-off-by: Luotao Fu <l.fu@pengutronix.de>
Signed-off-by: Sascha Hauer <s.hauer@pengutronix.de>
Signed-off-by: Alexander Smirnov <asmirnov@embeddedalley.com>

Merged from pengutronix.de
---
 arch/arm/plat-mxc/include/mach/iomux-mx1-mx2.h |    2 +
 drivers/w1/masters/Kconfig                     |    6 +
 drivers/w1/masters/Makefile                    |    2 +
 drivers/w1/masters/mxc_w1.c                    |  239 ++++++++++++++++++++++++
 4 files changed, 249 insertions(+), 0 deletions(-)
 create mode 100644 drivers/w1/masters/mxc_w1.c

diff --git a/arch/arm/plat-mxc/include/mach/iomux-mx1-mx2.h b/arch/arm/plat-mxc/include/mach/iomux-mx1-mx2.h
index 641ac8d..cfbddfd 100644
--- a/arch/arm/plat-mxc/include/mach/iomux-mx1-mx2.h
+++ b/arch/arm/plat-mxc/include/mach/iomux-mx1-mx2.h
@@ -401,6 +401,8 @@ extern int mxc_gpio_setup_multiple_pins(const int *pin_list, unsigned count,
 #define PE13_PF_UART1_RXD	(GPIO_PORTE | GPIO_IN  | GPIO_PF | 13)
 #define PE14_PF_UART1_CTS	(GPIO_PORTE | GPIO_OUT | GPIO_PF | 14)
 #define PE15_PF_UART1_RTS	(GPIO_PORTE | GPIO_IN  | GPIO_PF | 15)
+#define PE16_PF_RTCK		(GPIO_PORTE | GPIO_OUT | GPIO_PF | 16)
+#define PE16_AF_RTCK		(GPIO_PORTE | GPIO_OUT | GPIO_AF | 16)
 #define PE18_PF_SDHC1_D0	(GPIO_PORTE | GPIO_PF | 18)
 #define PE18_AF_CSPI3_MISO	(GPIO_PORTE | GPIO_IN  | GPIO_AF | 18)
 #define PE19_PF_SDHC1_D1	(GPIO_PORTE | GPIO_PF | 19)
diff --git a/drivers/w1/masters/Kconfig b/drivers/w1/masters/Kconfig
index 636d4f7..d01baea 100644
--- a/drivers/w1/masters/Kconfig
+++ b/drivers/w1/masters/Kconfig
@@ -34,6 +34,12 @@ config W1_MASTER_DS2482
 	  This driver can also be built as a module.  If so, the module
 	  will be called ds2482.
 
+config W1_MASTER_MXC
+	tristate "Freescale MXC driver for 1-wire"
+	depends on W1 && ARCH_MXC
+	help
+	  Say Y here to enable MXC 1-wire host
+
 config W1_MASTER_DS1WM
 	tristate "Maxim DS1WM 1-wire busmaster"
 	depends on W1 && ARM
diff --git a/drivers/w1/masters/Makefile b/drivers/w1/masters/Makefile
index 1daeb6e..3c3e0b2 100644
--- a/drivers/w1/masters/Makefile
+++ b/drivers/w1/masters/Makefile
@@ -5,6 +5,8 @@
 obj-$(CONFIG_W1_MASTER_MATROX)		+= matrox_w1.o
 obj-$(CONFIG_W1_MASTER_DS2490)		+= ds2490.o
 obj-$(CONFIG_W1_MASTER_DS2482)		+= ds2482.o
+obj-$(CONFIG_W1_MASTER_MXC)		+= mxc_w1.o
+
 obj-$(CONFIG_W1_MASTER_DS1WM)		+= ds1wm.o
 obj-$(CONFIG_HDQ_MASTER_OMAP)		+= omap_hdq.o
 obj-$(CONFIG_W1_MASTER_GPIO)		+= w1-gpio.o
diff --git a/drivers/w1/masters/mxc_w1.c b/drivers/w1/masters/mxc_w1.c
new file mode 100644
index 0000000..5439574
--- /dev/null
+++ b/drivers/w1/masters/mxc_w1.c
@@ -0,0 +1,239 @@
+/*
+ * Copyright 2005-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2008 Luotao Fu, kernel@pengutronix.de
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+#include <linux/delay.h>
+
+#include <mach/iomux-mx1-mx2.h>
+
+#include "../w1.h"
+#include "../w1_int.h"
+#include "../w1_log.h"
+
+static int __devinit mxc_w1_probe(struct platform_device *pdev);
+static int __devexit mxc_w1_remove(struct platform_device *pdev);
+
+/* According to the mx27 Datasheet the reset procedure should take up to about
+ * 1350us. We set the timeout to 500*100us = 50ms for sure */
+#define MXC_W1_RESET_TIMEOUT 500
+/* According to the mx27 Datasheet the write0 procedure should take up to about
+ * 120us, while write1/Read procedure should take up to about 120us for write
+ * and about 60us for read. We set the timeout to 100*100us = 10ms for sure */
+#define MXC_W1_RW_TIMEOUT 100
+
+/*
+ * MXC W1 Register offsets
+ */
+#define MXC_W1_CONTROL          0x00
+#define MXC_W1_TIME_DIVIDER     0x02
+#define MXC_W1_RESET            0x04
+#define MXC_W1_COMMAND          0x06
+#define MXC_W1_TXRX             0x08
+#define MXC_W1_INTERRUPT        0x0A
+#define MXC_W1_INTERRUPT_EN     0x0C
+
+static struct platform_driver mxc_w1_driver = {
+	.driver = {
+		   .name = "mxc_w1",
+		   },
+	.probe = mxc_w1_probe,
+	.remove = mxc_w1_remove,
+};
+
+struct mxc_w1_device {
+	void *base_address;
+	unsigned long found;
+	unsigned int clkdiv;
+	struct clk *clk;
+	struct w1_bus_master *bus_master;
+};
+
+/*
+ * this is the low level routine to
+ * reset the device on the One Wire interface
+ * on the hardware
+ */
+static u8 mxc_w1_ds2_reset_bus(void *data)
+{
+	u8 reg_val, rc = 1;
+	unsigned int timeout_cnt = 0;
+
+	struct mxc_w1_device *dev = (struct mxc_w1_device *)data;
+
+	__raw_writeb(0x80, (dev->base_address + MXC_W1_CONTROL));
+
+	while (1) {
+		reg_val = __raw_readb(dev->base_address + MXC_W1_CONTROL);
+
+		if (((reg_val >> 7) & 0x1) == 0 ||
+		    timeout_cnt > MXC_W1_RESET_TIMEOUT) {
+			rc = 0;
+			break;
+		} else
+			timeout_cnt++;
+
+		udelay(100);
+	}
+	return (reg_val >> 7) & 0x1;
+}
+
+/*
+ * this is the low level routine to read/write a bit on the One Wire
+ * interface on the hardware. It does write 0 if parameter bit is set
+ * to 0, otherwise a write 1/read.
+ */
+static u8 mxc_w1_ds2_touch_bit(void *data, u8 bit)
+{
+	u8 reg_val;
+	u8 ret = 0;
+	unsigned int timeout_cnt = 0;
+
+	struct mxc_w1_device *dev = (struct mxc_w1_device *)data;
+	void __iomem *ctrl_addr = dev->base_address + MXC_W1_CONTROL;
+
+	if (0 == bit) {
+		__raw_writeb((1 << 5), ctrl_addr);
+		while (1) {
+			reg_val = __raw_readb(ctrl_addr);
+
+			if (((reg_val >> 5) & 0x1) == 0 ||
+			    timeout_cnt > MXC_W1_RW_TIMEOUT)
+				break;
+			else
+				timeout_cnt++;
+			udelay(100);
+		}
+	} else {
+		__raw_writeb((1 << 4), ctrl_addr);
+
+		while (1) {
+			reg_val = __raw_readb(ctrl_addr);
+
+			if (((reg_val >> 4) & 0x1) == 0 ||
+			    timeout_cnt > MXC_W1_RW_TIMEOUT)
+				break;
+			else
+				timeout_cnt++;
+			udelay(100);
+		}
+
+		reg_val = (((__raw_readb(ctrl_addr)) >> 3) & 0x1);
+		ret = (u8) (reg_val);
+	}
+
+	return ret;
+}
+
+/*
+ * this routine sets the One Wire clock
+ * to a value of 1 Mhz, as required by
+ * hardware.
+ */
+static void mxc_w1_hw_init(struct mxc_w1_device *dev)
+{
+	clk_enable(dev->clk);
+
+	__raw_writeb(dev->clkdiv, dev->base_address + MXC_W1_TIME_DIVIDER);
+
+	return;
+}
+
+static int __devinit mxc_w1_probe(struct platform_device *pdev)
+{
+	struct mxc_w1_device *dev;
+	int err = 0;
+
+	dev = kzalloc(sizeof(struct mxc_w1_device) +
+		      sizeof(struct w1_bus_master), GFP_KERNEL);
+
+	if (!dev)
+		return -ENOMEM;
+
+	dev->clk = clk_get(&pdev->dev, "owire_clk");
+	dev->bus_master = (struct w1_bus_master *)(dev + 1);
+	dev->found = 1;
+	dev->clkdiv = (clk_get_rate(dev->clk) / 1000000) - 1;
+	dev->base_address = (void __iomem *)
+	    IO_ADDRESS(OWIRE_BASE_ADDR);
+
+	mxc_w1_hw_init(dev);
+
+	dev->bus_master->data = dev;
+	dev->bus_master->reset_bus = &mxc_w1_ds2_reset_bus;
+	dev->bus_master->touch_bit = &mxc_w1_ds2_touch_bit;
+
+	err = w1_add_master_device(dev->bus_master);
+
+	if (err)
+		goto err_out_free_device;
+
+	platform_set_drvdata(pdev, dev);
+	return 0;
+
+err_out_free_device:
+	kfree(dev);
+	return err;
+}
+
+/*
+ * disassociate the w1 device from the driver
+ */
+static int mxc_w1_remove(struct platform_device *pdev)
+{
+	struct mxc_w1_device *dev = platform_get_drvdata(pdev);
+
+	clk_disable(dev->clk);
+	clk_put(dev->clk);
+
+	if (dev->found)
+		w1_remove_master_device(dev->bus_master);
+
+	platform_set_drvdata(pdev, NULL);
+
+	return 0;
+}
+
+static int __init mxc_w1_init(void)
+{
+	int ret;
+
+	printk(KERN_INFO "Serial: MXC OWire driver\n");
+
+	mxc_gpio_mode(PE16_AF_RTCK);
+
+	ret = platform_driver_register(&mxc_w1_driver);
+
+	return ret;
+}
+
+static void mxc_w1_exit(void)
+{
+	mxc_gpio_mode(PE16_PF_RTCK);
+	platform_driver_unregister(&mxc_w1_driver);
+}
+
+module_init(mxc_w1_init);
+module_exit(mxc_w1_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Freescale Semiconductors Inc");
+MODULE_DESCRIPTION("Driver for One-Wire on MXC");
-- 
1.6.3.1

