From 286fa3b7d91151bfe528783e645369427e491fce Mon Sep 17 00:00:00 2001
From: Alexander Smirnov <asmirnov@embeddedalley.com>
Date: Mon, 29 Dec 2008 19:04:30 +0300
Subject: [PATCH 29/77] MXC: Modify driver to work also on imx2

This patch modifies the existing imx1 driver to also support the imx2 family
of processors.

TODO: check function on imx3

Signed-off-by: Juergen Beisert <j.beisert@pengutronix.de>
Signed-off-by: Sascha Hauer <s.hauer@pengutronix.de>
Signed-off-by: Alexander Smirnov <asmirnov@embeddedalley.com>

Merged from pengutronix.com
---
 arch/arm/mach-imx/include/mach/imxfb.h |    2 +
 arch/arm/plat-mxc/include/mach/imxfb.h |   85 ++++++++++++
 drivers/video/Kconfig                  |    2 +-
 drivers/video/imxfb.c                  |  222 ++++++++++++++++++++------------
 4 files changed, 227 insertions(+), 84 deletions(-)
 create mode 100644 arch/arm/plat-mxc/include/mach/imxfb.h

diff --git a/arch/arm/mach-imx/include/mach/imxfb.h b/arch/arm/mach-imx/include/mach/imxfb.h
index 870d0d9..0fe8001 100644
--- a/arch/arm/mach-imx/include/mach/imxfb.h
+++ b/arch/arm/mach-imx/include/mach/imxfb.h
@@ -76,6 +76,8 @@ struct imx_fb_platform_data {
 	u_char * fixed_screen_cpu;
 	dma_addr_t fixed_screen_dma;
 
+	int (*init)(struct platform_device*);
+	int (*exit)(struct platform_device*);
 	void (*lcd_power)(int);
 	void (*backlight_power)(int);
 };
diff --git a/arch/arm/plat-mxc/include/mach/imxfb.h b/arch/arm/plat-mxc/include/mach/imxfb.h
new file mode 100644
index 0000000..9179e90
--- /dev/null
+++ b/arch/arm/plat-mxc/include/mach/imxfb.h
@@ -0,0 +1,85 @@
+/*
+ * This structure describes the machine which we are running on.
+ */
+
+#define PCR_TFT		(1 << 31)
+#define PCR_COLOR	(1 << 30)
+#define PCR_PBSIZ_1	(0 << 28)
+#define PCR_PBSIZ_2	(1 << 28)
+#define PCR_PBSIZ_4	(2 << 28)
+#define PCR_PBSIZ_8	(3 << 28)
+#define PCR_BPIX_1	(0 << 25)
+#define PCR_BPIX_2	(1 << 25)
+#define PCR_BPIX_4	(2 << 25)
+#define PCR_BPIX_8	(3 << 25)
+#define PCR_BPIX_12	(4 << 25)
+#define PCR_BPIX_16	(4 << 25)
+#define PCR_PIXPOL	(1 << 24)
+#define PCR_FLMPOL	(1 << 23)
+#define PCR_LPPOL	(1 << 22)
+#define PCR_CLKPOL	(1 << 21)
+#define PCR_OEPOL	(1 << 20)
+#define PCR_SCLKIDLE	(1 << 19)
+#define PCR_END_SEL	(1 << 18)
+#define PCR_END_BYTE_SWAP ( 1<< 17)
+#define PCR_REV_VS	(1 << 16)
+#define PCR_ACD_SEL	(1 << 15)
+#define PCR_ACD(x)	(((x) & 0x7f) << 8)
+#define PCR_SCLK_SEL	(1 << 7)
+#define PCR_SHARP	(1 << 6)
+#define PCR_PCD(x)	((x) & 0x3f)
+
+#define PWMR_CLS(x)	(((x) & 0x1ff) << 16)
+#define PWMR_LDMSK	(1 << 15)
+#define PWMR_SCR1	(1 << 10)
+#define PWMR_SCR0	(1 << 9)
+#define PWMR_CC_EN	(1 << 8)
+#define PWMR_PW(x)	((x) & 0xff)
+
+#define LSCR1_PS_RISE_DELAY(x)    (((x) & 0x7f) << 26)
+#define LSCR1_CLS_RISE_DELAY(x)   (((x) & 0x3f) << 16)
+#define LSCR1_REV_TOGGLE_DELAY(x) (((x) & 0xf) << 8)
+#define LSCR1_GRAY2(x)            (((x) & 0xf) << 4)
+#define LSCR1_GRAY1(x)            (((x) & 0xf))
+
+#define DMACR_BURST	(1 << 31)
+#define DMACR_HM(x)	(((x) & 0xf) << 16)
+#define DMACR_TM(x)	((x) &0xf)
+
+struct imx_fb_platform_data {
+	u_long		pixclock;
+
+	u_short		xres;
+	u_short		yres;
+
+	u_int		nonstd;
+	u_char		bpp;
+	u_char		hsync_len;
+	u_char		left_margin;
+	u_char		right_margin;
+
+	u_char		vsync_len;
+	u_char		upper_margin;
+	u_char		lower_margin;
+	u_char		sync;
+
+	u_int		cmap_greyscale:1,
+			cmap_inverse:1,
+			cmap_static:1,
+			unused:29;
+
+	u_int		pcr;
+	u_int		pwmr;
+	u_int		lscr1;
+	u_int		dmacr;
+
+	u_char * fixed_screen_cpu;
+	dma_addr_t fixed_screen_dma;
+
+	int (*init)(struct platform_device*);
+	int (*exit)(struct platform_device*);
+	void (*lcd_power)(int);
+	void (*backlight_power)(int);
+};
+
+void set_imx_fb_info(struct imx_fb_platform_data *);
diff --git a/drivers/video/Kconfig b/drivers/video/Kconfig
index 07a0f73..1f50361 100644
--- a/drivers/video/Kconfig
+++ b/drivers/video/Kconfig
@@ -390,7 +390,7 @@ config FB_SA1100
 
 config FB_IMX
 	tristate "Motorola i.MX LCD support"
-	depends on FB && ARM && ARCH_IMX
+	depends on FB && ARM && (ARCH_IMX || ARCH_MX2)
 	select FB_CFB_FILLRECT
 	select FB_CFB_COPYAREA
 	select FB_CFB_IMAGEBLIT
diff --git a/drivers/video/imxfb.c b/drivers/video/imxfb.c
index 4757ec6..03df41b 100644
--- a/drivers/video/imxfb.c
+++ b/drivers/video/imxfb.c
@@ -27,6 +27,7 @@
 #include <linux/init.h>
 #include <linux/ioport.h>
 #include <linux/cpufreq.h>
+#include <linux/clk.h>
 #include <linux/platform_device.h>
 #include <linux/dma-mapping.h>
 #include <linux/io.h>
@@ -44,7 +45,11 @@
 
 #define LCDC_SIZE	0x04
 #define SIZE_XMAX(x)	((((x) >> 4) & 0x3f) << 20)
+#ifdef CONFIG_ARCH_IMX
 #define SIZE_YMAX(y)	((y) & 0x1ff)
+#else
+#define SIZE_YMAX(y)	((y) & 0x3ff)
+#endif
 
 #define LCDC_VPW	0x08
 #define VPW_VPW(x)	((x) & 0x3ff)
@@ -54,7 +59,11 @@
 #define CPOS_CC0	(1<<30)
 #define CPOS_OP		(1<<28)
 #define CPOS_CXP(x)	(((x) & 3ff) << 16)
+#ifdef CONFIG_ARCH_IMX
 #define CPOS_CYP(y)	((y) & 0x1ff)
+#else
+#define CPOS_CYP(y)	((y) & 0x3ff)
+#endif
 
 #define LCDC_LCWHB	0x10
 #define LCWHB_BK_EN	(1<<31)
@@ -63,9 +72,15 @@
 #define LCWHB_BD(x)	((x) & 0xff)
 
 #define LCDC_LCHCC	0x14
+#ifdef CONFIG_ARCH_IMX
 #define LCHCC_CUR_COL_R(r) (((r) & 0x1f) << 11)
 #define LCHCC_CUR_COL_G(g) (((g) & 0x3f) << 5)
 #define LCHCC_CUR_COL_B(b) ((b) & 0x1f)
+#else
+#define LCHCC_CUR_COL_R(r) (((r) & 0x3f) << 12)
+#define LCHCC_CUR_COL_G(g) (((g) & 0x3f) << 6)
+#define LCHCC_CUR_COL_B(b) ((b) & 0x3f)
+#endif
 
 #define LCDC_PCR	0x18
 
@@ -119,6 +134,8 @@ struct imxfb_rgb {
 struct imxfb_info {
 	struct platform_device  *pdev;
 	void __iomem		*regs;
+	struct clk		*clk;
+	char			enabled;
 
 	u_int			max_bpp;
 	u_int			max_xres;
@@ -180,9 +197,6 @@ static struct imxfb_rgb def_rgb_8 = {
 	.transp = {.offset = 0, .length = 0,},
 };
 
-static int imxfb_activate_var(struct fb_var_screeninfo *var,
-		struct fb_info *info);
-
 static inline u_int chan_to_field(u_int chan, struct fb_bitfield *bf)
 {
 	chan &= 0xffff;
@@ -327,8 +341,6 @@ static int imxfb_set_par(struct fb_info *info)
 	struct imxfb_info *fbi = info->par;
 	struct fb_var_screeninfo *var = &info->var;
 
-	pr_debug("set_par\n");
-
 	if (var->bits_per_pixel == 16)
 		info->fix.visual = FB_VISUAL_TRUECOLOR;
 	else if (!fbi->cmap_static)
@@ -345,50 +357,64 @@ static int imxfb_set_par(struct fb_info *info)
 	info->fix.line_length = var->xres_virtual * var->bits_per_pixel / 8;
 	fbi->palette_size = var->bits_per_pixel == 8 ? 256 : 16;
 
-	imxfb_activate_var(var, info);
+	if (var->bits_per_pixel == 16)
+		fb_dealloc_cmap(&info->cmap);
+	else
+		fb_alloc_cmap(&info->cmap, 1 << info->var.bits_per_pixel, 0);
 
 	return 0;
 }
 
 static void imxfb_enable_controller(struct imxfb_info *fbi)
 {
-	pr_debug("Enabling LCD controller\n");
-
-	/* initialize LCDC */
-	writel(readl(fbi->regs + LCDC_RMCR) & ~RMCR_LCDC_EN,
-		fbi->regs + LCDC_RMCR);	/* just to be safe... */
+	struct imx_fb_platform_data *pdata = fbi->pdev->dev.platform_data;
+	int ret;
 
-	writel(fbi->screen_dma, fbi->regs + LCDC_SSA);
+	if (!fbi->enabled) {
+		if (clk_enable(fbi->clk) != 0)
+			printk("Warning: Could not enable clock!");
+		pr_debug("LCD clock enabled\n");
 
-	/* physical screen start address	    */
-	writel(VPW_VPW(fbi->max_xres * fbi->max_bpp / 8 / 4),
-		fbi->regs + LCDC_VPW);
-
-	/* panning offset 0 (0 pixel offset)        */
-	writel(0x00000000, fbi->regs + LCDC_POS);
+		if (pdata->init) {
+			ret = (pdata->init)(fbi->pdev);
+			pr_debug("GPIOs enabled\n");
+			if (ret != 0)
+				pr_err("Failing to enable LCD pins\n");
+		}
 
-	/* disable hardware cursor */
-	writel(readl(fbi->regs + LCDC_CPOS) & ~(CPOS_CC0 | CPOS_CC1),
-		fbi->regs + LCDC_CPOS);
+		if (pdata->lcd_power) {
+			pdata->lcd_power(1);
+			pr_debug("Display's power enabled\n");
+		}
 
-	writel(RMCR_LCDC_EN, fbi->regs + LCDC_RMCR);
+		if (pdata->backlight_power) {
+			pdata->backlight_power(1);
+			pr_debug("Backlight's power enabled\n");
+		}
 
-	if (fbi->backlight_power)
-		fbi->backlight_power(1);
-	if (fbi->lcd_power)
-		fbi->lcd_power(1);
+		fbi->enabled = 1;
+	}
 }
 
 static void imxfb_disable_controller(struct imxfb_info *fbi)
 {
-	pr_debug("Disabling LCD controller\n");
+	struct imx_fb_platform_data *pdata = fbi->pdev->dev.platform_data;
+	int ret;
 
-	if (fbi->backlight_power)
-		fbi->backlight_power(0);
-	if (fbi->lcd_power)
-		fbi->lcd_power(0);
+	if (pdata->backlight_power)
+		pdata->backlight_power(0);
+	if (pdata->lcd_power)
+		pdata->lcd_power(0);
 
-	writel(0, fbi->regs + LCDC_RMCR);
+	writel(0, fbi->regs + LCDC_RMCR);	/* for IMX only */
+
+	clk_disable(fbi->clk);
+
+	if (pdata->exit) {
+		ret = (pdata->exit)(fbi->pdev);
+		if (ret != 0)
+			pr_err("Failing to disable LCD pins\n");
+	}
 }
 
 static int imxfb_blank(int blank, struct fb_info *info)
@@ -423,66 +449,68 @@ static struct fb_ops imxfb_ops = {
 	.fb_blank	= imxfb_blank,
 };
 
-/*
- * imxfb_activate_var():
- *	Configures LCD Controller based on entries in var parameter.  Settings are
- *	only written to the controller if changes were made.
- */
-static int imxfb_activate_var(struct fb_var_screeninfo *var, struct fb_info *info)
+/* enable the LCD controller with basic setup for the connected display. */
+static void imxfb_setup_display(struct imxfb_info *fbi)
 {
-	struct imxfb_info *fbi = info->par;
-	pr_debug("var: xres=%d hslen=%d lm=%d rm=%d\n",
-		var->xres, var->hsync_len,
-		var->left_margin, var->right_margin);
-	pr_debug("var: yres=%d vslen=%d um=%d bm=%d\n",
-		var->yres, var->vsync_len,
-		var->upper_margin, var->lower_margin);
-
-#if DEBUG_VAR
-	if (var->xres < 16        || var->xres > 1024)
-		printk(KERN_ERR "%s: invalid xres %d\n",
-			info->fix.id, var->xres);
-	if (var->hsync_len < 1    || var->hsync_len > 64)
-		printk(KERN_ERR "%s: invalid hsync_len %d\n",
-			info->fix.id, var->hsync_len);
-	if (var->left_margin > 255)
-		printk(KERN_ERR "%s: invalid left_margin %d\n",
-			info->fix.id, var->left_margin);
-	if (var->right_margin > 255)
-		printk(KERN_ERR "%s: invalid right_margin %d\n",
-			info->fix.id, var->right_margin);
-	if (var->yres < 1 || var->yres > 511)
-		printk(KERN_ERR "%s: invalid yres %d\n",
-			info->fix.id, var->yres);
-	if (var->vsync_len > 100)
-		printk(KERN_ERR "%s: invalid vsync_len %d\n",
-			info->fix.id, var->vsync_len);
-	if (var->upper_margin > 63)
-		printk(KERN_ERR "%s: invalid upper_margin %d\n",
-			info->fix.id, var->upper_margin);
-	if (var->lower_margin > 255)
-		printk(KERN_ERR "%s: invalid lower_margin %d\n",
-			info->fix.id, var->lower_margin);
+	u32 pixel_clk, pcr;
+	struct imx_fb_platform_data *pinfo = fbi->pdev->dev.platform_data;
+
+#ifdef CONFIG_ARCH_IMX
+	writel(readl(fbi->regs + LCDC_RMCR) & ~RMCR_LCDC_EN,
+		fbi->regs + LCDC_RMCR);	/* just to be safe... */
 #endif
 
-	writel(HCR_H_WIDTH(var->hsync_len) |
-		HCR_H_WAIT_1(var->right_margin) |
-		HCR_H_WAIT_2(var->left_margin),
+	/* physical screen start address */
+	writel(fbi->screen_dma, fbi->regs + LCDC_SSA);
+
+	/* dimension of this display */
+	writel(SIZE_XMAX(pinfo->xres) | SIZE_YMAX(pinfo->yres),
+			fbi->regs + LCDC_SIZE);
+
+	/* virtual page width */
+	writel(VPW_VPW(fbi->max_xres * fbi->max_bpp / 8 / 4),
+		fbi->regs + LCDC_VPW);
+
+	/* setup the pixel clock */
+	pixel_clk = clk_get_rate(fbi->clk);
+
+	pcr = (pixel_clk + ((pinfo->pixclock * 1000UL) / 2)) / (pinfo->pixclock * 1000UL);
+	if (--pcr > 0x3F) {
+		pcr = 0x3F;
+		printk("Must limit pixel clock to %luHz\n", clk_get_rate(fbi->clk) / pcr);
+	}
+
+	/* add sync polarities */
+	pcr |= fbi->pcr & ~0x3F;
+	writel(pcr, fbi->regs + LCDC_PCR);
+
+	/* setup sync behaviour */
+	writel(HCR_H_WIDTH(pinfo->hsync_len - 1) |
+		HCR_H_WAIT_1(pinfo->right_margin - 1) |
+		HCR_H_WAIT_2(pinfo->left_margin - 3),
 		fbi->regs + LCDC_HCR);
 
-	writel(VCR_V_WIDTH(var->vsync_len) |
-		VCR_V_WAIT_1(var->lower_margin) |
-		VCR_V_WAIT_2(var->upper_margin),
+	writel(VCR_V_WIDTH(pinfo->vsync_len) |
+		VCR_V_WAIT_1(pinfo->lower_margin) |
+		VCR_V_WAIT_2(pinfo->upper_margin),
 		fbi->regs + LCDC_VCR);
 
-	writel(SIZE_XMAX(var->xres) | SIZE_YMAX(var->yres),
-			fbi->regs + LCDC_SIZE);
-	writel(fbi->pcr, fbi->regs + LCDC_PCR);
+	/* PWM contrast control register */
 	writel(fbi->pwmr, fbi->regs + LCDC_PWMR);
+
+	/* special setup for Sharp displays */
 	writel(fbi->lscr1, fbi->regs + LCDC_LSCR1);
+
+	/* dma watermarks for this mode */
 	writel(fbi->dmacr, fbi->regs + LCDC_DMACR);
 
-	return 0;
+	/* activate refresh */
+#ifdef CONFIG_ARCH_IMX
+	writel(readl(fbi->regs + LCDC_RMCR) | RMCR_LCDC_EN,
+		fbi->regs + LCDC_RMCR);
+#else
+	writel(0x00000000, fbi->regs + LCDC_RMCR);
+#endif
 }
 
 #ifdef CONFIG_PM
@@ -612,6 +640,8 @@ static int __init imxfb_probe(struct platform_device *pdev)
 	if (ret < 0)
 		goto failed_init;
 
+	fbi->pdev = pdev;
+
 	res = request_mem_region(res->start, resource_size(res),
 				DRIVER_NAME);
 	if (!res) {
@@ -625,6 +655,15 @@ static int __init imxfb_probe(struct platform_device *pdev)
 		goto failed_ioremap;
 	}
 
+	fbi->clk = clk_get(&pdev->dev, "lcdc_clk");
+	if (fbi->clk == NULL) {
+		dev_err(&pdev->dev,
+			"Cannot get the clock for IMX LCD unit %d\n",
+			pdev->id);
+		ret = -ENODEV;
+		goto failed_getclock;
+	}
+
 	if (!pdata->fixed_screen_cpu) {
 		fbi->map_size = PAGE_ALIGN(info->fix.smem_len);
 		fbi->map_cpu = dma_alloc_writecombine(&pdev->dev,
@@ -654,7 +693,18 @@ static int __init imxfb_probe(struct platform_device *pdev)
 	 * This makes sure that our colour bitfield
 	 * descriptors are correctly initialised.
 	 */
-	imxfb_check_var(&info->var, info);
+	imxfb_setup_display(fbi);
+	ret = imxfb_check_var(&info->var, info);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to get suitable mode\n");
+		goto failed_cmap;
+	}
+
+	ret = imxfb_set_par(info);
+	if (ret) {
+		dev_err(&pdev->dev, "Failed to set parameters\n");
+		goto failed_cmap;
+	}
 
 	ret = fb_alloc_cmap(&info->cmap, 1 << info->var.bits_per_pixel, 0);
 	if (ret < 0)
@@ -662,7 +712,7 @@ static int __init imxfb_probe(struct platform_device *pdev)
 
 	imxfb_set_par(info);
 	ret = register_framebuffer(info);
-	if (ret < 0) {
+	if (ret) {
 		dev_err(&pdev->dev, "failed to register framebuffer\n");
 		goto failed_register;
 	}
@@ -678,6 +728,8 @@ failed_cmap:
 		dma_free_writecombine(&pdev->dev,fbi->map_size,fbi->map_cpu,
 			fbi->map_dma);
 failed_map:
+	clk_put(fbi->clk);
+failed_getclock:
 	iounmap(fbi->regs);
 failed_ioremap:
 	release_mem_region(res->start, res->end - res->start);
@@ -707,6 +759,10 @@ static int __devexit imxfb_remove(struct platform_device *pdev)
 
 	iounmap(fbi->regs);
 	release_mem_region(res->start, res->end - res->start + 1);
+
+	clk_disable(fbi->clk);
+	clk_put(fbi->clk);
+
 	platform_set_drvdata(pdev, NULL);
 
 	return 0;
-- 
1.6.3.1

