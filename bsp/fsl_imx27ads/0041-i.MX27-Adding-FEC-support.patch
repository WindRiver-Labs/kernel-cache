From 5ebb9838054d5f351a9da2789ddfbb0d25c45e86 Mon Sep 17 00:00:00 2001
From: Alexander Smirnov <asmirnov@embeddedalley.com>
Date: Mon, 29 Dec 2008 20:17:12 +0300
Subject: [PATCH] i.MX27: Adding FEC support

i.MX27: Adding network support (reference only)

This patch adds network support for the phyCORE-i.MX27 cpu module (aka
pcm038). The patch is here for reference only and to make it possible
for people to actually work with the board. It is more or less a copy of
the original ifdef-cluttered patch from Freescale, cleaned up to only
contain i.MX27-FEC code and does not even follow the driver model
correctly. Has to be reworked before it can go into the mainline.

Some cleanups:
-Removed unused PHYs
-Removed unused boards

Signed-off-by: Juergen Beisert <j.beisert@pengutronix.de>
Signed-off-by: Sascha Hauer <s.hauer@pengutronix.de>
Signed-off-by: Alexander Smirnov <asmirnov@embeddedalley.com>

Merged from pengutronix.com
---
 drivers/net/Kconfig   |    7 +
 drivers/net/Makefile  |    1 +
 drivers/net/fec_mx2.c | 1721 +++++++++++++++++++++++++++++++++++++++++++++++++
 drivers/net/fec_mx2.h |  173 +++++
 4 files changed, 1902 insertions(+), 0 deletions(-)
 create mode 100644 drivers/net/fec_mx2.c
 create mode 100644 drivers/net/fec_mx2.h

diff --git a/drivers/net/Kconfig b/drivers/net/Kconfig
index 280f7de..d157536 100644
--- a/drivers/net/Kconfig
+++ b/drivers/net/Kconfig
@@ -1833,6 +1833,13 @@ config FEC_MPC52xx_MDIO
 	  If not sure, enable.
 	  If compiled as module, it will be called 'fec_mpc52xx_phy.ko'.
 
+config FEC_MX2
+	tristate "FEC ethernet controller"
+	depends on ARCH_MX2
+	help
+	  Say Y here if you want to use the built-in 10/100 Fast ethernet
+	  controller on some Motorola/Freescale processors.
+
 config NE_H8300
 	tristate "NE2000 compatible support for H8/300"
 	depends on H8300
diff --git a/drivers/net/Makefile b/drivers/net/Makefile
index de81c8a..b709fa5 100644
--- a/drivers/net/Makefile
+++ b/drivers/net/Makefile
@@ -105,6 +105,7 @@ obj-$(CONFIG_FEC_MPC52xx) += fec_mpc52xx.o
 ifeq ($(CONFIG_FEC_MPC52xx_MDIO),y)
 	obj-$(CONFIG_FEC_MPC52xx) += fec_mpc52xx_phy.o
 endif
+obj-$(CONFIG_FEC_MX2) += fec_mx2.o
 obj-$(CONFIG_68360_ENET) += 68360enet.o
 obj-$(CONFIG_WD80x3) += wd.o 8390.o
 obj-$(CONFIG_EL2) += 3c503.o 8390p.o
diff --git a/drivers/net/fec_mx2.c b/drivers/net/fec_mx2.c
new file mode 100644
index 0000000..52b4fd3
--- /dev/null
+++ b/drivers/net/fec_mx2.c
@@ -0,0 +1,1721 @@
+/*
+ * Fast Ethernet Controller (FEC) driver for Motorola MPC8xx.
+ * Copyright (c) 1997 Dan Malek (dmalek@jlc.net)
+ *
+ * This version of the driver is specific to the FADS implementation,
+ * since the board contains control registers external to the processor
+ * for the control of the LevelOne LXT970 transceiver.  The MPC860T manual
+ * describes connections using the internal parallel port I/O, which
+ * is basically all of Port D.
+ *
+ * Right now, I am very wasteful with the buffers.  I allocate memory
+ * pages and then divide them into 2K frame buffers.  This way I know I
+ * have buffers large enough to hold one frame within one buffer descriptor.
+ * Once I get this working, I will use 64 or 128 byte CPM buffers, which
+ * will be much more memory efficient and will easily handle lots of
+ * small packets.
+ *
+ * Much better multiple PHY support by Magnus Damm.
+ * Copyright (c) 2000 Ericsson Radio Systems AB.
+ *
+ * Support for FEC controller of ColdFire processors.
+ * Copyright (c) 2001-2005 Greg Ungerer (gerg@snapgear.com)
+ *
+ * Bug fixes and cleanup by Philippe De Muyter (phdm@macqel.be)
+ * Copyright (c) 2004-2006 Macq Electronique SA.
+ */
+/*
+ * Copyright 2006-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/ptrace.h>
+#include <linux/errno.h>
+#include <linux/ioport.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/pci.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+#include <linux/spinlock.h>
+#include <linux/workqueue.h>
+#include <linux/bitops.h>
+#include <linux/clk.h>
+#include <linux/kthread.h>
+#include <linux/delay.h>
+#include <linux/io.h>
+
+#include <asm/irq.h>
+#include <asm/uaccess.h>
+#include <asm/pgtable.h>
+
+#include <mach/hardware.h>
+#include <mach/iim.h>
+#include "fec_mx2.h"
+#define FEC_ALIGNMENT  (0x0F)	/*FEC needs 128bits(32bytes) alignment */
+
+#define FEC_ADDR_ALIGNMENT(x) ((unsigned char *)(((unsigned long )(x) + (FEC_ALIGNMENT)) & (~FEC_ALIGNMENT)))
+
+#if defined(CONFIG_FEC2)
+#define	FEC_MAX_PORTS	2
+#else
+#define	FEC_MAX_PORTS	1
+#endif
+
+/*
+ * Define the fixed address of the FEC hardware.
+ */
+static unsigned int fec_hw[] = {
+	(IO_ADDRESS(FEC_BASE_ADDR)),
+};
+
+static unsigned char fec_mac_default[] = {
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+};
+
+/*
+ * Some hardware gets it MAC address out of local flash memory.
+ * if this is non-zero then assume it is the address to get MAC from.
+ */
+#define	FEC_FLASHMAC	0
+
+/* Forward declarations of some structures to support different PHYs
+*/
+
+typedef struct {
+	uint mii_data;
+	void (*funct) (uint mii_reg, struct net_device *dev);
+} phy_cmd_t;
+
+typedef struct {
+	uint id;
+	char *name;
+
+	const phy_cmd_t *config;
+	const phy_cmd_t *startup;
+	const phy_cmd_t *ack_int;
+	const phy_cmd_t *shutdown;
+} phy_info_t;
+
+/* The number of Tx and Rx buffers.  These are allocated from the page
+ * pool.  The code may assume these are power of two, so it it best
+ * to keep them that size.
+ * We don't need to allocate pages for the transmitter.  We just use
+ * the skbuffer directly.
+ */
+#define FEC_ENET_RX_PAGES	8
+#define FEC_ENET_RX_FRSIZE	2048
+#define FEC_ENET_RX_FRPPG	(PAGE_SIZE / FEC_ENET_RX_FRSIZE)
+#define RX_RING_SIZE		(FEC_ENET_RX_FRPPG * FEC_ENET_RX_PAGES)
+#define FEC_ENET_TX_FRSIZE	2048
+#define FEC_ENET_TX_FRPPG	(PAGE_SIZE / FEC_ENET_TX_FRSIZE)
+#define TX_RING_SIZE		16	/* Must be power of two */
+#define TX_RING_MOD_MASK	15	/*   for this to work */
+
+#if (((RX_RING_SIZE + TX_RING_SIZE) * 8) > PAGE_SIZE)
+#error "FEC: descriptor ring size constants too large"
+#endif
+
+/* Interrupt events/masks.
+*/
+#define FEC_ENET_HBERR	((uint)0x80000000)	/* Heartbeat error */
+#define FEC_ENET_BABR	((uint)0x40000000)	/* Babbling receiver */
+#define FEC_ENET_BABT	((uint)0x20000000)	/* Babbling transmitter */
+#define FEC_ENET_GRA	((uint)0x10000000)	/* Graceful stop complete */
+#define FEC_ENET_TXF	((uint)0x08000000)	/* Full frame transmitted */
+#define FEC_ENET_TXB	((uint)0x04000000)	/* A buffer was transmitted */
+#define FEC_ENET_RXF	((uint)0x02000000)	/* Full frame received */
+#define FEC_ENET_RXB	((uint)0x01000000)	/* A buffer was received */
+#define FEC_ENET_MII	((uint)0x00800000)	/* MII interrupt */
+#define FEC_ENET_EBERR	((uint)0x00400000)	/* SDMA bus error */
+#define FEC_ENET_MASK   ((uint)0xffc00000)
+
+/* The FEC stores dest/src/type, data, and checksum for receive packets.
+ */
+#define PKT_MAXBUF_SIZE		1518
+#define PKT_MINBUF_SIZE		64
+#define PKT_MAXBLR_SIZE		1520
+
+/*
+ * The 5270/5271/5280/5282/532x RX control register also contains maximum frame
+ * size bits. Other FEC hardware does not, so we need to take that into
+ * account when setting it.
+ */
+#define	OPT_FRAME_SIZE	(PKT_MAXBUF_SIZE << 16)
+
+/* The FEC buffer descriptors track the ring buffers.  The rx_bd_base and
+ * tx_bd_base always point to the base of the buffer descriptors.  The
+ * cur_rx and cur_tx point to the currently available buffer.
+ * The dirty_tx tracks the current buffer that is being sent by the
+ * controller.  The cur_tx and dirty_tx are equal under both completely
+ * empty and completely full conditions.  The empty/ready indicator in
+ * the buffer descriptor determines the actual condition.
+ */
+struct fec_enet_private {
+	/* Hardware registers of the FEC device */
+	volatile fec_t *hwp;
+
+	struct net_device *netdev;
+
+	/* The saved address of a sent-in-place packet/buffer, for skfree(). */
+	unsigned char *tx_bounce[TX_RING_SIZE];
+	struct sk_buff *tx_skbuff[TX_RING_SIZE];
+	struct sk_buff *rx_skbuff[RX_RING_SIZE];
+	ushort skb_cur;
+	ushort skb_dirty;
+
+	/* CPM dual port RAM relative addresses.
+	 */
+	void *cbd_mem_base;	/* save the virtual base address of rx&tx buffer descripter */
+	cbd_t *rx_bd_base;	/* Address of Rx and Tx buffers. */
+	cbd_t *tx_bd_base;
+	cbd_t *cur_rx, *cur_tx;	/* The next free ring entry */
+	cbd_t *dirty_tx;	/* The ring entries to be free()ed. */
+	struct net_device_stats stats;
+	uint tx_full;
+	spinlock_t lock;
+
+	uint phy_id;
+	uint phy_id_done;
+	uint phy_status;
+	uint phy_speed;
+	phy_info_t const *phy;
+	struct work_struct phy_task;
+
+	uint sequence_done;
+	uint mii_phy_task_queued;
+
+	uint phy_addr;
+
+	int index;
+	int opened;
+	int link;
+	int old_link;
+	int full_duplex;
+
+	struct clk *clk;
+};
+
+static int fec_enet_start_xmit(struct sk_buff *skb, struct net_device *dev);
+static void fec_enet_mii(struct net_device *dev);
+static irqreturn_t fec_enet_interrupt(int irq, void *dev_id);
+static void fec_enet_tx(struct net_device *dev);
+static void fec_enet_rx(struct net_device *dev);
+static int fec_enet_close(struct net_device *dev);
+static struct net_device_stats *fec_enet_get_stats(struct net_device *dev);
+static void set_multicast_list(struct net_device *dev);
+static void fec_restart(struct net_device *dev, int duplex);
+static void fec_stop(struct net_device *dev);
+static void fec_set_mac_address(struct net_device *dev);
+
+static inline void fec_dcache_inv_range(void *start, void *end);
+static inline void fec_dcache_flush_range(void *start, void *end);
+
+/*
+ *  fec_copy_threshold controls the copy when recieving ethernet frame.
+ *     If ethernet header aligns 4bytes, the ip header and upper header will not aligns 4bytes.
+ *     The resean is ethernet header is 14bytes.
+ *     And the max size of tcp & ip header is 128bytes. Normally it is 40bytes.
+ *     So I set the default value between 128 to 256.
+ */
+static int fec_copy_threshold = 192;
+
+/*
+ * fec_device records the devices created for cleanup
+ */
+struct net_device *fec_device[FEC_MAX_PORTS];
+
+/* MII processing.  We keep this as simple as possible.  Requests are
+ * placed on the list (if there is room).  When the request is finished
+ * by the MII, an optional function may be called.
+ */
+typedef struct mii_list {
+	uint mii_regval;
+	void (*mii_func) (uint val, struct net_device *dev);
+	struct mii_list *mii_next;
+} mii_list_t;
+
+#define		NMII	20
+static mii_list_t mii_cmds[NMII];
+static mii_list_t *mii_free;
+static mii_list_t *mii_head;
+static mii_list_t *mii_tail;
+
+static int mii_queue(struct net_device *dev, int request,
+		     void (*func) (uint, struct net_device *));
+
+/* Make MII read/write commands for the FEC.
+*/
+#define mk_mii_read(REG)	(0x60020000 | ((REG & 0x1f) << 18))
+#define mk_mii_write(REG, VAL)	(0x50020000 | ((REG & 0x1f) << 18) | \
+						(VAL & 0xffff))
+#define mk_mii_end	0
+
+/* Transmitter timeout.
+*/
+#define TX_TIMEOUT (2*HZ)
+
+/* Register definitions for the PHY.
+*/
+
+#define MII_REG_CR          0	/* Control Register                         */
+#define MII_REG_SR          1	/* Status Register                          */
+#define MII_REG_PHYIR1      2	/* PHY Identification Register 1            */
+#define MII_REG_PHYIR2      3	/* PHY Identification Register 2            */
+#define MII_REG_ANAR        4	/* A-N Advertisement Register               */
+#define MII_REG_ANLPAR      5	/* A-N Link Partner Ability Register        */
+#define MII_REG_ANER        6	/* A-N Expansion Register                   */
+#define MII_REG_ANNPTR      7	/* A-N Next Page Transmit Register          */
+#define MII_REG_ANLPRNPR    8	/* A-N Link Partner Received Next Page Reg. */
+
+/* values for phy_status */
+
+#define PHY_CONF_ANE	0x0001	/* 1 auto-negotiation enabled */
+#define PHY_CONF_LOOP	0x0002	/* 1 loopback mode enabled */
+#define PHY_CONF_SPMASK	0x00f0	/* mask for speed */
+#define PHY_CONF_10HDX	0x0010	/* 10 Mbit half duplex supported */
+#define PHY_CONF_10FDX	0x0020	/* 10 Mbit full duplex supported */
+#define PHY_CONF_100HDX	0x0040	/* 100 Mbit half duplex supported */
+#define PHY_CONF_100FDX	0x0080	/* 100 Mbit full duplex supported */
+
+#define PHY_STAT_LINK	0x0100	/* 1 up - 0 down */
+#define PHY_STAT_FAULT	0x0200	/* 1 remote fault */
+#define PHY_STAT_ANC	0x0400	/* 1 auto-negotiation complete  */
+#define PHY_STAT_SPMASK	0xf000	/* mask for speed */
+#define PHY_STAT_10HDX	0x1000	/* 10 Mbit half duplex selected */
+#define PHY_STAT_10FDX	0x2000	/* 10 Mbit full duplex selected */
+#define PHY_STAT_100HDX	0x4000	/* 100 Mbit half duplex selected */
+#define PHY_STAT_100FDX	0x8000	/* 100 Mbit full duplex selected */
+
+static int fec_enet_start_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+	struct fec_enet_private *fep;
+	volatile fec_t *fecp;
+	volatile cbd_t *bdp;
+	unsigned short status;
+
+	fep = netdev_priv(dev);
+	fecp = (volatile fec_t *)dev->base_addr;
+
+	if (!fep->link) {
+		/* Link is down or autonegotiation is in progress. */
+		return 1;
+	}
+
+	/* Fill in a Tx ring entry */
+	bdp = fep->cur_tx;
+
+	status = bdp->cbd_sc;
+#ifndef final_version
+	if (status & BD_ENET_TX_READY) {
+		/* Ooops.  All transmit buffers are full.  Bail out.
+		 * This should not happen, since dev->tbusy should be set.
+		 */
+		printk("%s: tx queue full!.\n", dev->name);
+		return 1;
+	}
+#endif
+
+	/* Clear all of the status flags.
+	 */
+	status &= ~BD_ENET_TX_STATS;
+
+	/* Set buffer length and buffer pointer.
+	 */
+	bdp->cbd_bufaddr = __pa(skb->data);
+	bdp->cbd_datlen = skb->len;
+
+	/*
+	 *      On some FEC implementations data must be aligned on
+	 *      4-byte boundaries. Use bounce buffers to copy data
+	 *      and get it aligned. Ugh.
+	 */
+	if ((bdp->cbd_bufaddr) & FEC_ALIGNMENT) {
+		unsigned int index;
+		index = bdp - fep->tx_bd_base;
+		memcpy(fep->tx_bounce[index], (void *)skb->data, skb->len);
+		bdp->cbd_bufaddr = __pa(fep->tx_bounce[index]);
+	}
+
+	/* Save skb pointer.
+	 */
+	fep->tx_skbuff[fep->skb_cur] = skb;
+
+	fep->stats.tx_bytes += skb->len;
+	fep->skb_cur = (fep->skb_cur + 1) & TX_RING_MOD_MASK;
+
+	/* Push the data cache so the CPM does not get stale memory
+	 * data.
+	 */
+	fec_dcache_flush_range(__va(bdp->cbd_bufaddr), __va(bdp->cbd_bufaddr) +
+			       bdp->cbd_datlen);
+
+	spin_lock_irq(&fep->lock);
+
+	/* Send it on its way.  Tell FEC it's ready, interrupt when done,
+	 * it's the last BD of the frame, and to put the CRC on the end.
+	 */
+
+	status |= (BD_ENET_TX_READY | BD_ENET_TX_INTR
+		   | BD_ENET_TX_LAST | BD_ENET_TX_TC);
+	bdp->cbd_sc = status;
+
+	dev->trans_start = jiffies;
+
+	/* Trigger transmission start */
+	fecp->fec_x_des_active = 0x01000000;
+
+	/* If this was the last BD in the ring, start at the beginning again.
+	 */
+	if (status & BD_ENET_TX_WRAP) {
+		bdp = fep->tx_bd_base;
+	} else {
+		bdp++;
+	}
+
+	if (bdp == fep->dirty_tx) {
+		fep->tx_full = 1;
+		netif_stop_queue(dev);
+	}
+
+	fep->cur_tx = (cbd_t *) bdp;
+
+	spin_unlock_irq(&fep->lock);
+
+	return 0;
+}
+
+static void fec_timeout(struct net_device *dev)
+{
+	struct fec_enet_private *fep = netdev_priv(dev);
+
+	printk("%s: transmit timed out.\n", dev->name);
+	fep->stats.tx_errors++;
+#ifndef final_version
+	{
+		int i;
+		cbd_t *bdp;
+
+		printk
+		    ("Ring data dump: cur_tx %lx%s, dirty_tx %lx cur_rx: %lx\n",
+		     (unsigned long)fep->cur_tx, fep->tx_full ? " (full)" : "",
+		     (unsigned long)fep->dirty_tx, (unsigned long)fep->cur_rx);
+
+		bdp = fep->tx_bd_base;
+		printk(" tx: %u buffers\n", TX_RING_SIZE);
+		for (i = 0; i < TX_RING_SIZE; i++) {
+			printk("  %08x: %04x %04x %08x\n",
+			       (uint) bdp,
+			       bdp->cbd_sc,
+			       bdp->cbd_datlen, (int)bdp->cbd_bufaddr);
+			bdp++;
+		}
+
+		bdp = fep->rx_bd_base;
+		printk(" rx: %lu buffers\n", (unsigned long)RX_RING_SIZE);
+		for (i = 0; i < RX_RING_SIZE; i++) {
+			printk("  %08x: %04x %04x %08x\n",
+			       (uint) bdp,
+			       bdp->cbd_sc,
+			       bdp->cbd_datlen, (int)bdp->cbd_bufaddr);
+			bdp++;
+		}
+	}
+#endif
+	fec_restart(dev, fep->full_duplex);
+	netif_wake_queue(dev);
+}
+
+/* The interrupt handler.
+ * This is called from the MPC core interrupt.
+ */
+static irqreturn_t fec_enet_interrupt(int irq, void *dev_id)
+{
+	struct net_device *dev = dev_id;
+	volatile fec_t *fecp;
+	uint int_events;
+	int handled = 0;
+
+	fecp = (volatile fec_t *)dev->base_addr;
+	/* Get the interrupt events that caused us to be here.
+	 */
+	while ((int_events = fecp->fec_ievent) != 0) {
+		fecp->fec_ievent = int_events;
+
+		/* Handle receive event in its own function.
+		 */
+		if (int_events & (FEC_ENET_RXF | FEC_ENET_RXB)) {
+
+			handled = 1;
+			fec_enet_rx(dev);
+		}
+
+		/* Transmit OK, or non-fatal error. Update the buffer
+		   descriptors. FEC handles all errors, we just discover
+		   them as part of the transmit process.
+		 */
+		if (int_events & (FEC_ENET_TXF | FEC_ENET_TXB)) {
+			handled = 1;
+			fec_enet_tx(dev);
+		}
+
+		if (int_events & FEC_ENET_MII) {
+			handled = 1;
+			fec_enet_mii(dev);
+		}
+
+	}
+	return IRQ_RETVAL(handled);
+}
+
+static void fec_enet_tx(struct net_device *dev)
+{
+	struct fec_enet_private *fep;
+	volatile cbd_t *bdp;
+	unsigned short status;
+	struct sk_buff *skb;
+
+	fep = netdev_priv(dev);
+	spin_lock(&fep->lock);
+	bdp = fep->dirty_tx;
+
+	while (((status = bdp->cbd_sc) & BD_ENET_TX_READY) == 0) {
+		if (bdp == fep->cur_tx && fep->tx_full == 0)
+			break;
+
+		skb = fep->tx_skbuff[fep->skb_dirty];
+		/* Check for errors. */
+		if (status & (BD_ENET_TX_HB | BD_ENET_TX_LC |
+			      BD_ENET_TX_RL | BD_ENET_TX_UN | BD_ENET_TX_CSL)) {
+			fep->stats.tx_errors++;
+			if (status & BD_ENET_TX_HB)	/* No heartbeat */
+				fep->stats.tx_heartbeat_errors++;
+			if (status & BD_ENET_TX_LC)	/* Late collision */
+				fep->stats.tx_window_errors++;
+			if (status & BD_ENET_TX_RL)	/* Retrans limit */
+				fep->stats.tx_aborted_errors++;
+			if (status & BD_ENET_TX_UN)	/* Underrun */
+				fep->stats.tx_fifo_errors++;
+			if (status & BD_ENET_TX_CSL)	/* Carrier lost */
+				fep->stats.tx_carrier_errors++;
+		} else {
+			fep->stats.tx_packets++;
+		}
+
+#ifndef final_version
+		if (status & BD_ENET_TX_READY)
+			printk("HEY! Enet xmit interrupt and TX_READY.\n");
+#endif
+		/* Deferred means some collisions occurred during transmit,
+		 * but we eventually sent the packet OK.
+		 */
+		if (status & BD_ENET_TX_DEF)
+			fep->stats.collisions++;
+
+		/* Free the sk buffer associated with this last transmit.
+		 */
+		dev_kfree_skb_any(skb);
+		fep->tx_skbuff[fep->skb_dirty] = NULL;
+		fep->skb_dirty = (fep->skb_dirty + 1) & TX_RING_MOD_MASK;
+
+		/* Update pointer to next buffer descriptor to be transmitted.
+		 */
+		if (status & BD_ENET_TX_WRAP)
+			bdp = fep->tx_bd_base;
+		else
+			bdp++;
+
+		/* Since we have freed up a buffer, the ring is no longer
+		 * full.
+		 */
+		if (fep->tx_full) {
+			fep->tx_full = 0;
+			if (netif_queue_stopped(dev))
+				netif_wake_queue(dev);
+		}
+	}
+	fep->dirty_tx = (cbd_t *) bdp;
+	spin_unlock(&fep->lock);
+}
+
+/* During a receive, the cur_rx points to the current incoming buffer.
+ * When we update through the ring, if the next incoming buffer has
+ * not been given to the system, we just set the empty indicator,
+ * effectively tossing the packet.
+ */
+static void fec_enet_rx(struct net_device *dev)
+{
+	struct fec_enet_private *fep;
+	volatile fec_t *fecp;
+	volatile cbd_t *bdp;
+	unsigned short status;
+	struct sk_buff *skb;
+	ushort pkt_len;
+	__u8 *data;
+	int rx_index;
+
+	fep = netdev_priv(dev);
+	fecp = (volatile fec_t *)dev->base_addr;
+
+	/* First, grab all of the stats for the incoming packet.
+	 * These get messed up if we get called due to a busy condition.
+	 */
+	bdp = fep->cur_rx;
+
+	while (!((status = bdp->cbd_sc) & BD_ENET_RX_EMPTY)) {
+		rx_index = bdp - fep->rx_bd_base;
+#ifndef final_version
+		/* Since we have allocated space to hold a complete frame,
+		 * the last indicator should be set.
+		 */
+		if ((status & BD_ENET_RX_LAST) == 0)
+			printk("FEC ENET: rcv is not +last\n");
+#endif
+
+		if (!fep->opened)
+			goto rx_processing_done;
+
+		/* Check for errors. */
+		if (status & (BD_ENET_RX_LG | BD_ENET_RX_SH | BD_ENET_RX_NO |
+			      BD_ENET_RX_CR | BD_ENET_RX_OV)) {
+			fep->stats.rx_errors++;
+			if (status & (BD_ENET_RX_LG | BD_ENET_RX_SH)) {
+				/* Frame too long or too short. */
+				fep->stats.rx_length_errors++;
+			}
+			if (status & BD_ENET_RX_NO)	/* Frame alignment */
+				fep->stats.rx_frame_errors++;
+			if (status & BD_ENET_RX_CR)	/* CRC Error */
+				fep->stats.rx_crc_errors++;
+			if (status & BD_ENET_RX_OV)	/* FIFO overrun */
+				fep->stats.rx_fifo_errors++;
+		}
+
+		/* Report late collisions as a frame error.
+		 * On this error, the BD is closed, but we don't know what we
+		 * have in the buffer.  So, just drop this frame on the floor.
+		 */
+		if (status & BD_ENET_RX_CL) {
+			fep->stats.rx_errors++;
+			fep->stats.rx_frame_errors++;
+			goto rx_processing_done;
+		}
+
+		/* Process the incoming frame.
+		 */
+		fep->stats.rx_packets++;
+		pkt_len = bdp->cbd_datlen;
+		fep->stats.rx_bytes += pkt_len;
+		data = (__u8 *) __va(bdp->cbd_bufaddr);
+		fec_dcache_inv_range(data, data + pkt_len - 4);
+
+		/* This does 16 byte alignment, exactly what we need.
+		 * The packet length includes FCS, but we don't want to
+		 * include that when passing upstream as it messes up
+		 * bridging applications.
+		 */
+		if ((pkt_len - 4) < fec_copy_threshold) {
+			skb = dev_alloc_skb(pkt_len);
+		} else {
+			skb = dev_alloc_skb(FEC_ENET_RX_FRSIZE);
+		}
+
+		if (skb == NULL) {
+			printk("%s: Memory squeeze, dropping packet.\n",
+			       dev->name);
+			fep->stats.rx_dropped++;
+		} else {
+			if ((pkt_len - 4) < fec_copy_threshold) {
+				skb_reserve(skb, 2);	/*skip 2bytes, so ipheader is align 4bytes */
+				skb_put(skb, pkt_len - 4);	/* Make room */
+				skb_copy_to_linear_data(skb,
+							(unsigned char *)data,
+							pkt_len - 4);
+			} else {
+				struct sk_buff *pskb = fep->rx_skbuff[rx_index];
+
+				fep->rx_skbuff[rx_index] = skb;
+				skb->data = FEC_ADDR_ALIGNMENT(skb->data);
+				bdp->cbd_bufaddr = __pa(skb->data);
+				skb_put(pskb, pkt_len - 4);	/* Make room */
+				skb = pskb;
+			}
+			skb->dev = dev;
+			skb->protocol = eth_type_trans(skb, dev);
+			netif_rx(skb);
+		}
+	      rx_processing_done:
+
+		/* Clear the status flags for this buffer.
+		 */
+		status &= ~BD_ENET_RX_STATS;
+
+		/* Mark the buffer empty.
+		 */
+		status |= BD_ENET_RX_EMPTY;
+		bdp->cbd_sc = status;
+
+		/* Update BD pointer to next entry.
+		 */
+		if (status & BD_ENET_RX_WRAP)
+			bdp = fep->rx_bd_base;
+		else
+			bdp++;
+
+		/* Doing this here will keep the FEC running while we process
+		 * incoming frames.  On a heavily loaded network, we should be
+		 * able to keep up at the expense of system resources.
+		 */
+		fecp->fec_r_des_active = 0x01000000;
+	}			/* while (!((status = bdp->cbd_sc) & BD_ENET_RX_EMPTY)) */
+	fep->cur_rx = (cbd_t *) bdp;
+}
+
+/* called from interrupt context */
+static void fec_enet_mii(struct net_device *dev)
+{
+	struct fec_enet_private *fep;
+	volatile fec_t *ep;
+	mii_list_t *mip;
+	uint mii_reg;
+
+	fep = netdev_priv(dev);
+	ep = fep->hwp;
+	mii_reg = ep->fec_mii_data;
+
+	spin_lock(&fep->lock);
+
+	if ((mip = mii_head) == NULL) {
+		printk("MII and no head!\n");
+		goto unlock;
+	}
+
+	if (mip->mii_func != NULL)
+		(*(mip->mii_func)) (mii_reg, dev);
+
+	mii_head = mip->mii_next;
+	mip->mii_next = mii_free;
+	mii_free = mip;
+
+	if ((mip = mii_head) != NULL)
+		ep->fec_mii_data = mip->mii_regval;
+
+      unlock:
+	spin_unlock(&fep->lock);
+}
+
+static int
+mii_queue(struct net_device *dev, int regval,
+	  void (*func) (uint, struct net_device *))
+{
+	struct fec_enet_private *fep;
+	unsigned long flags;
+	mii_list_t *mip;
+	int retval;
+
+	/* Add PHY address to register command.
+	 */
+	fep = netdev_priv(dev);
+	regval |= fep->phy_addr << 23;
+
+	retval = 0;
+
+	spin_lock_irqsave(&fep->lock, flags);
+
+	if ((mip = mii_free) != NULL) {
+		mii_free = mip->mii_next;
+		mip->mii_regval = regval;
+		mip->mii_func = func;
+		mip->mii_next = NULL;
+		if (mii_head) {
+			mii_tail->mii_next = mip;
+			mii_tail = mip;
+		} else {
+			mii_head = mii_tail = mip;
+			fep->hwp->fec_mii_data = regval;
+		}
+	} else {
+		retval = 1;
+	}
+
+	spin_unlock_irqrestore(&fep->lock, flags);
+
+	return (retval);
+}
+
+static void mii_do_cmd(struct net_device *dev, const phy_cmd_t *c)
+{
+	int k;
+
+	if (!c)
+		return;
+
+	for (k = 0; (c + k)->mii_data != mk_mii_end; k++) {
+		mii_queue(dev, (c + k)->mii_data, (c + k)->funct);
+	}
+}
+
+static void mii_parse_sr(uint mii_reg, struct net_device *dev)
+{
+	struct fec_enet_private *fep = netdev_priv(dev);
+	volatile uint *s = &(fep->phy_status);
+	uint status;
+
+	status = *s & ~(PHY_STAT_LINK | PHY_STAT_FAULT | PHY_STAT_ANC);
+
+	if (mii_reg & 0x0004)
+		status |= PHY_STAT_LINK;
+	if (mii_reg & 0x0010)
+		status |= PHY_STAT_FAULT;
+	if (mii_reg & 0x0020)
+		status |= PHY_STAT_ANC;
+
+	*s = status;
+}
+
+static void mii_parse_cr(uint mii_reg, struct net_device *dev)
+{
+	struct fec_enet_private *fep = netdev_priv(dev);
+	volatile uint *s = &(fep->phy_status);
+	uint status;
+	status = *s & ~(PHY_CONF_ANE | PHY_CONF_LOOP);
+
+	if (mii_reg & 0x1000)
+		status |= PHY_CONF_ANE;
+	if (mii_reg & 0x4000)
+		status |= PHY_CONF_LOOP;
+	*s = status;
+}
+
+static void mii_parse_anar(uint mii_reg, struct net_device *dev)
+{
+	struct fec_enet_private *fep = netdev_priv(dev);
+	volatile uint *s = &(fep->phy_status);
+	uint status;
+	status = *s & ~(PHY_CONF_SPMASK);
+
+	if (mii_reg & 0x0020)
+		status |= PHY_CONF_10HDX;
+	if (mii_reg & 0x0040)
+		status |= PHY_CONF_10FDX;
+	if (mii_reg & 0x0080)
+		status |= PHY_CONF_100HDX;
+	if (mii_reg & 0x00100)
+		status |= PHY_CONF_100FDX;
+	*s = status;
+}
+
+/* ------------------------------------------------------------------------- */
+/* AMD AM79C874 phy                                                          */
+
+/* register definitions for the 874 */
+
+#define MII_AM79C874_MFR       16	/* Miscellaneous Feature Register */
+#define MII_AM79C874_ICSR      17	/* Interrupt/Status Register      */
+#define MII_AM79C874_DR        18	/* Diagnostic Register            */
+#define MII_AM79C874_PMLR      19	/* Power and Loopback Register    */
+#define MII_AM79C874_MCR       21	/* ModeControl Register           */
+#define MII_AM79C874_DC        23	/* Disconnect Counter             */
+#define MII_AM79C874_REC       24	/* Recieve Error Counter          */
+
+static void mii_parse_am79c874_dr(uint mii_reg, struct net_device *dev)
+{
+	struct fec_enet_private *fep = netdev_priv(dev);
+	volatile uint *s = &(fep->phy_status);
+	uint status;
+
+	status = *s & ~(PHY_STAT_SPMASK | PHY_STAT_ANC);
+
+	if (mii_reg & 0x0080)
+		status |= PHY_STAT_ANC;
+	if (mii_reg & 0x0400)
+		status |=
+		    ((mii_reg & 0x0800) ? PHY_STAT_100FDX : PHY_STAT_100HDX);
+	else
+		status |=
+		    ((mii_reg & 0x0800) ? PHY_STAT_10FDX : PHY_STAT_10HDX);
+
+	*s = status;
+}
+
+static phy_cmd_t const phy_cmd_am79c874_config[] = {
+	{mk_mii_read(MII_REG_CR), mii_parse_cr},
+	{mk_mii_read(MII_REG_ANAR), mii_parse_anar},
+	{mk_mii_read(MII_AM79C874_DR), mii_parse_am79c874_dr},
+	{mk_mii_end,}
+};
+static phy_cmd_t const phy_cmd_am79c874_startup[] = {	/* enable interrupts */
+	{mk_mii_write(MII_AM79C874_ICSR, 0xff00), NULL},
+	{mk_mii_write(MII_REG_CR, 0x1200), NULL},	/* autonegotiate */
+	{mk_mii_read(MII_REG_SR), mii_parse_sr},
+	{mk_mii_end,}
+};
+static phy_cmd_t const phy_cmd_am79c874_ack_int[] = {
+	/* find out the current status */
+	{mk_mii_read(MII_REG_SR), mii_parse_sr},
+	{mk_mii_read(MII_AM79C874_DR), mii_parse_am79c874_dr},
+	/* we only need to read ISR to acknowledge */
+	{mk_mii_read(MII_AM79C874_ICSR), NULL},
+	{mk_mii_end,}
+};
+static phy_cmd_t const phy_cmd_am79c874_shutdown[] = {	/* disable interrupts */
+	{mk_mii_write(MII_AM79C874_ICSR, 0x0000), NULL},
+	{mk_mii_end,}
+};
+static phy_info_t const phy_info_am79c874 = {
+	.id = 0x00022561,
+	.name = "AM79C874",
+	.config = phy_cmd_am79c874_config,
+	.startup = phy_cmd_am79c874_startup,
+	.ack_int = phy_cmd_am79c874_ack_int,
+	.shutdown = phy_cmd_am79c874_shutdown
+};
+
+/* ------------------------------------------------------------------------- */
+
+static phy_info_t const *const phy_info[] = {
+	&phy_info_am79c874,
+	NULL
+};
+
+/*
+ * do some initializtion based architecture of this chip
+ */
+static void inline fec_arch_init(void)
+{
+	struct clk *clk;
+	clk = clk_get(NULL, "fec_clk");
+	clk_enable(clk);
+	clk_put(clk);
+	return;
+}
+
+/*
+ * do some cleanup based architecture of this chip
+ */
+static void inline fec_arch_exit(void)
+{
+	struct clk *clk;
+	clk = clk_get(NULL, "fec_clk");
+	clk_disable(clk);
+	clk_put(clk);
+	return;
+}
+
+/*
+ * Code specific to Freescale i.MXC
+ */
+static void inline fec_request_intrs(struct net_device *dev)
+{
+	/* Setup interrupt handlers. */
+	if (request_irq(MXC_INT_FEC, fec_enet_interrupt, 0, "fec", dev) != 0)
+		panic("FEC: Could not allocate FEC IRQ(%d)!\n", MXC_INT_FEC);
+}
+
+static void inline fec_release_intrs(struct net_device *dev)
+{
+	disable_irq(MXC_INT_FEC);
+
+	free_irq(MXC_INT_FEC, dev);
+}
+
+static void inline fec_set_mii(struct net_device *dev,
+				   struct fec_enet_private *fep)
+{
+	u32 rate;
+	struct clk *clk;
+	volatile fec_t *fecp;
+	fecp = fep->hwp;
+	fecp->fec_r_cntrl = OPT_FRAME_SIZE | 0x04;
+	fecp->fec_x_cntrl = 0x00;
+
+	/*
+	 * Set MII speed to 2.5 MHz
+	 */
+	clk = clk_get(NULL, "fec_clk");
+	rate = clk_get_rate(clk);
+	clk_put(clk);
+
+	fep->phy_speed = ((((rate / 2 + 4999999) / 2500000) / 2) & 0x3F) << 1;
+	fecp->fec_mii_speed = fep->phy_speed;
+	fec_restart(dev, 0);
+}
+
+#define FEC_IIM_BASE    IO_ADDRESS(IIM_BASE_ADDR)
+static void inline fec_get_mac(struct net_device *dev)
+{
+	struct fec_enet_private *fep = netdev_priv(dev);
+	volatile fec_t *fecp;
+	unsigned char *iap, tmpaddr[ETH_ALEN];
+	int i;
+	unsigned long l;
+	unsigned char mac_preinitialized;
+	unsigned long fec_mac_base = FEC_IIM_BASE + MXC_IIMKEY0;
+	fecp = fep->hwp;
+
+	if (mx27_revision() >= CHIP_REV_2_0)
+		fec_mac_base = FEC_IIM_BASE + MXC_IIMMAC;
+
+	/* check if mac address was already initialized by firmware */
+	l = fecp->fec_addr_low;
+	tmpaddr[0] = (unsigned char)((l & 0xFF000000) >> 24);
+	tmpaddr[1] = (unsigned char)((l & 0x00FF0000) >> 16);
+	tmpaddr[2] = (unsigned char)((l & 0x0000FF00) >> 8);
+	tmpaddr[3] = (unsigned char)((l & 0x000000FF) >> 0);
+	l = fecp->fec_addr_high;
+	tmpaddr[4] = (unsigned char)((l & 0xFF000000) >> 24);
+	tmpaddr[5] = (unsigned char)((l & 0x00FF0000) >> 16);
+
+	for (i = 0; i < ETH_ALEN; i++)
+		mac_preinitialized |= tmpaddr[i];
+
+	if (mac_preinitialized) {
+		iap = &tmpaddr[0];
+		goto set_mac;
+	}
+
+	/* get mac accress from iim; feature is undocumented */
+	for (i = 0; i < ETH_ALEN; i++)
+		tmpaddr[ETH_ALEN - 1 - i] = __raw_readb(fec_mac_base + i * 4);
+
+	iap = &tmpaddr[0];
+
+	mac_preinitialized = 0x00;	/* uninitialized if all 00 */
+	for (i = 0; i < ETH_ALEN; i++)
+		mac_preinitialized |= tmpaddr[i];
+	if (mac_preinitialized) {
+		iap = fec_mac_default;
+		goto set_mac;
+	}
+
+	mac_preinitialized = 0xff;	/* uninitialized if all FF */
+	for (i = 0; i < ETH_ALEN; i++)
+		mac_preinitialized &= tmpaddr[i];
+	if (mac_preinitialized != 0xff) {
+		iap = fec_mac_default;
+		goto set_mac;
+	}
+
+	iap = &tmpaddr[0];
+
+      set_mac:
+	memcpy(dev->dev_addr, iap, ETH_ALEN);
+
+	/* Adjust MAC if using default MAC address */
+	if (iap == fec_mac_default)
+		dev->dev_addr[ETH_ALEN - 1] =
+		    fec_mac_default[ETH_ALEN - 1] + fep->index;
+}
+
+static void inline fec_enable_phy_intr(void)
+{
+}
+
+static void inline fec_disable_phy_intr(void)
+{
+}
+
+static void inline fec_phy_ack_intr(void)
+{
+}
+
+static void inline fec_localhw_setup(void)
+{
+}
+
+/*
+ * invalidate dcache related with the virtual memory range(start, end)
+ */
+static void inline fec_dcache_inv_range(void *start, void *end)
+{
+	dma_sync_single(NULL, (unsigned long)__pa(start),
+			(unsigned long)(end - start), DMA_FROM_DEVICE);
+	return;
+}
+
+/*
+ * flush dcache related with the virtual memory range(start, end)
+ */
+static void inline fec_dcache_flush_range(void *start, void *end)
+{
+	dma_sync_single(NULL, (unsigned long)__pa(start),
+			(unsigned long)(end - start), DMA_BIDIRECTIONAL);
+	return;
+}
+
+/*
+ * map memory space (addr, addr+size) to uncachable erea.
+ */
+static unsigned long inline fec_map_uncache(unsigned long addr, int size)
+{
+	return (unsigned long)ioremap(__pa(addr), size);
+}
+
+/*
+ * unmap memory erea started with addr from uncachable erea.
+ */
+static void inline fec_unmap_uncache(void *addr)
+{
+	return iounmap(addr);
+}
+
+static void mii_display_config(struct work_struct *work)
+{
+	struct fec_enet_private *fep =
+	    container_of(work, struct fec_enet_private, phy_task);
+	struct net_device *dev = fep->netdev;
+	uint status = fep->phy_status;
+
+	/*
+	 ** When we get here, phy_task is already removed from
+	 ** the workqueue.  It is thus safe to allow to reuse it.
+	 */
+	fep->mii_phy_task_queued = 0;
+	printk("%s: config: auto-negotiation ", dev->name);
+
+	if (status & PHY_CONF_ANE)
+		printk("on");
+	else
+		printk("off");
+
+	if (status & PHY_CONF_100FDX)
+		printk(", 100FDX");
+	if (status & PHY_CONF_100HDX)
+		printk(", 100HDX");
+	if (status & PHY_CONF_10FDX)
+		printk(", 10FDX");
+	if (status & PHY_CONF_10HDX)
+		printk(", 10HDX");
+	if (!(status & PHY_CONF_SPMASK))
+		printk(", No speed/duplex selected?");
+
+	if (status & PHY_CONF_LOOP)
+		printk(", loopback enabled");
+
+	printk(".\n");
+
+	fep->sequence_done = 1;
+}
+
+/* mii_queue_config is called in interrupt context from fec_enet_mii */
+static void mii_queue_config(uint mii_reg, struct net_device *dev)
+{
+	struct fec_enet_private *fep = netdev_priv(dev);
+
+	if (fep->mii_phy_task_queued)
+		return;
+
+	fep->mii_phy_task_queued = 1;
+	INIT_WORK(&fep->phy_task, mii_display_config);
+	schedule_work(&fep->phy_task);
+}
+
+phy_cmd_t const phy_cmd_config[] = {
+	{mk_mii_read(MII_REG_CR), mii_queue_config},
+	{mk_mii_end,}
+};
+
+/* Read remainder of PHY ID.
+*/
+static void mii_discover_phy3(uint mii_reg, struct net_device *dev)
+{
+	struct fec_enet_private *fep;
+	int i;
+
+	fep = netdev_priv(dev);
+	fep->phy_id |= (mii_reg & 0xffff);
+	printk("fec: PHY @ 0x%x, ID 0x%08x", fep->phy_addr, fep->phy_id);
+
+	for (i = 0; phy_info[i]; i++) {
+		if (phy_info[i]->id == (fep->phy_id >> 4))
+			break;
+	}
+
+	if (phy_info[i])
+		printk(" -- %s\n", phy_info[i]->name);
+	else
+		printk(" -- unknown PHY!\n");
+
+	fep->phy = phy_info[i];
+	fep->phy_id_done = 1;
+}
+
+/* Scan all of the MII PHY addresses looking for someone to respond
+ * with a valid ID.  This usually happens quickly.
+ */
+static void mii_discover_phy(uint mii_reg, struct net_device *dev)
+{
+	struct fec_enet_private *fep;
+	volatile fec_t *fecp;
+	uint phytype;
+
+	fep = netdev_priv(dev);
+	fecp = fep->hwp;
+
+	if (fep->phy_addr < 32) {
+		if ((phytype = (mii_reg & 0xffff)) != 0xffff && phytype != 0) {
+			/* Got first part of ID, now get remainder.
+			 */
+			fep->phy_id = phytype << 16;
+			mii_queue(dev, mk_mii_read(MII_REG_PHYIR2),
+				  mii_discover_phy3);
+		} else {
+			fep->phy_addr++;
+			mii_queue(dev, mk_mii_read(MII_REG_PHYIR1),
+				  mii_discover_phy);
+		}
+	} else {
+		printk("FEC: No PHY device found.\n");
+		/* Disable external MII interface */
+		fecp->fec_mii_speed = fep->phy_speed = 0;
+		fec_disable_phy_intr();
+	}
+}
+
+static int fec_enet_open(struct net_device *dev)
+{
+	struct fec_enet_private *fep = netdev_priv(dev);
+
+	/* I should reset the ring buffers here, but I don't yet know
+	 * a simple way to do that.
+	 */
+	fec_set_mac_address(dev);
+
+	fep->sequence_done = 0;
+	fep->link = 0;
+
+	if (fep->phy) {
+		mii_do_cmd(dev, fep->phy->ack_int);
+		mii_do_cmd(dev, fep->phy->config);
+		mii_do_cmd(dev, phy_cmd_config);	/* display configuration */
+
+		/* Poll until the PHY tells us its configuration
+		 * (not link state).
+		 * Request is initiated by mii_do_cmd above, but answer
+		 * comes by interrupt.
+		 * This should take about 25 usec per register at 2.5 MHz,
+		 * and we read approximately 5 registers.
+		 */
+		while (!fep->sequence_done)
+			schedule();
+
+		mii_do_cmd(dev, fep->phy->startup);
+
+		/* Set the initial link state to true. A lot of hardware
+		 * based on this device does not implement a PHY interrupt,
+		 * so we are never notified of link change.
+		 */
+		fep->link = 1;
+	} else {
+		fep->link = 1;	/* lets just try it and see */
+		/* no phy,  go full duplex,  it's most likely a hub chip */
+		fec_restart(dev, 1);
+	}
+
+	fep->opened = 1;
+	return 0;		/* Success */
+}
+
+static int fec_enet_close(struct net_device *dev)
+{
+	struct fec_enet_private *fep = netdev_priv(dev);
+
+	/* Don't know what to do yet.
+	 */
+	fep->opened = 0;
+	if (fep->link) {
+		fec_stop(dev);
+	}
+	return 0;
+}
+
+static struct net_device_stats *fec_enet_get_stats(struct net_device *dev)
+{
+	struct fec_enet_private *fep = netdev_priv(dev);
+
+	return &fep->stats;
+}
+
+/* Set or clear the multicast filter for this adaptor.
+ * Skeleton taken from sunlance driver.
+ * The CPM Ethernet implementation allows Multicast as well as individual
+ * MAC address filtering.  Some of the drivers check to make sure it is
+ * a group multicast address, and discard those that are not.  I guess I
+ * will do the same for now, but just remove the test if you want
+ * individual filtering as well (do the upper net layers want or support
+ * this kind of feature?).
+ */
+
+#define HASH_BITS	6	/* #bits in hash */
+#define CRC32_POLY	0xEDB88320
+
+static void set_multicast_list(struct net_device *dev)
+{
+	struct fec_enet_private *fep;
+	volatile fec_t *ep;
+	struct dev_mc_list *dmi;
+	unsigned int i, j, bit, data, crc;
+	unsigned char hash;
+
+	fep = netdev_priv(dev);
+	ep = fep->hwp;
+
+	if (dev->flags & IFF_PROMISC) {
+		ep->fec_r_cntrl |= 0x0008;
+	} else {
+
+		ep->fec_r_cntrl &= ~0x0008;
+
+		if (dev->flags & IFF_ALLMULTI) {
+			/* Catch all multicast addresses, so set the
+			 * filter to all 1's.
+			 */
+			ep->fec_hash_table_high = 0xffffffff;
+			ep->fec_hash_table_low = 0xffffffff;
+		} else {
+			/* Clear filter and add the addresses in hash register.
+			 */
+			ep->fec_hash_table_high = 0;
+			ep->fec_hash_table_low = 0;
+
+			dmi = dev->mc_list;
+
+			for (j = 0; j < dev->mc_count; j++, dmi = dmi->next) {
+				/* Only support group multicast for now.
+				 */
+				if (!(dmi->dmi_addr[0] & 1))
+					continue;
+
+				/* calculate crc32 value of mac address
+				 */
+				crc = 0xffffffff;
+
+				for (i = 0; i < dmi->dmi_addrlen; i++) {
+					data = dmi->dmi_addr[i];
+					for (bit = 0; bit < 8;
+					     bit++, data >>= 1) {
+						crc =
+						    (crc >> 1) ^
+						    (((crc ^ data) & 1) ?
+						     CRC32_POLY : 0);
+					}
+				}
+
+				/* only upper 6 bits (HASH_BITS) are used
+				   which point to specific bit in he hash registers
+				 */
+				hash = (crc >> (32 - HASH_BITS)) & 0x3f;
+
+				if (hash > 31)
+					ep->fec_hash_table_high |=
+					    1 << (hash - 32);
+				else
+					ep->fec_hash_table_low |= 1 << hash;
+			}
+		}
+	}
+}
+
+/* Set a MAC change in hardware.
+ */
+static void fec_set_mac_address(struct net_device *dev)
+{
+	volatile fec_t *fecp;
+
+	fecp = ((struct fec_enet_private *)netdev_priv(dev))->hwp;
+
+	/* Set station address. */
+	fecp->fec_addr_low = dev->dev_addr[3] | (dev->dev_addr[2] << 8) |
+	    (dev->dev_addr[1] << 16) | (dev->dev_addr[0] << 24);
+	fecp->fec_addr_high = (dev->dev_addr[5] << 16) |
+	    (dev->dev_addr[4] << 24);
+
+}
+
+/* Initialize the FEC Ethernet on 860T (or ColdFire 5272).
+ */
+
+int __init fec_enet_init(struct net_device *dev)
+{
+	struct fec_enet_private *fep = netdev_priv(dev);
+	unsigned long mem_addr;
+	volatile cbd_t *bdp;
+	cbd_t *cbd_base;
+	struct sk_buff *pskb;
+	volatile fec_t *fecp;
+	int i, j;
+	static int index = 0;
+
+	/* Only allow us to be probed once. */
+	if (index >= FEC_MAX_PORTS)
+		return -ENXIO;
+
+	spin_lock_init(&(fep->lock));
+
+	/* Allocate memory for buffer descriptors.
+	 */
+	mem_addr = __get_free_page(GFP_KERNEL);
+	if (mem_addr == 0) {
+		printk("FEC: allocate descriptor memory failed?\n");
+		return -ENOMEM;
+	}
+
+	fep->cbd_mem_base = (void *)mem_addr;
+	/* Create an Ethernet device instance.
+	 */
+	fecp = (volatile fec_t *)fec_hw[index];
+
+	fep->index = index;
+	fep->hwp = fecp;
+	fep->netdev = dev;
+
+	/* Whack a reset.  We should wait for this.
+	 */
+	fecp->fec_ecntrl = 1;
+	udelay(10);
+
+	/* Set the Ethernet address.  If using multiple Enets on the 8xx,
+	 * this needs some work to get unique addresses.
+	 *
+	 * This is our default MAC address unless the user changes
+	 * it via eth_mac_addr (our dev->set_mac_addr handler).
+	 */
+	fec_get_mac(dev);
+
+	cbd_base = (cbd_t *) fec_map_uncache(mem_addr, PAGE_SIZE);
+	if (cbd_base == NULL) {
+		free_page(mem_addr);
+		printk("FEC: map descriptor memory to uncacheable failed?\n");
+		return -ENOMEM;
+	}
+
+	/* Set receive and transmit descriptor base.
+	 */
+	fep->rx_bd_base = cbd_base;
+	fep->tx_bd_base = cbd_base + RX_RING_SIZE;
+
+	fep->dirty_tx = fep->cur_tx = fep->tx_bd_base;
+	fep->cur_rx = fep->rx_bd_base;
+
+	fep->skb_cur = fep->skb_dirty = 0;
+
+	/* Initialize the receive buffer descriptors.
+	 */
+	bdp = fep->rx_bd_base;
+	for (i = 0; i < RX_RING_SIZE; i++, bdp++) {
+		pskb = dev_alloc_skb(FEC_ENET_RX_FRSIZE);
+		if (pskb == NULL) {
+			for (; i > 0; i--) {
+				if (fep->rx_skbuff[i - 1]) {
+					kfree_skb(fep->rx_skbuff[i - 1]);
+					fep->rx_skbuff[i - 1] = NULL;
+				}
+			}
+			printk
+			    ("FEC: allocate skb fail when initializing rx buffer \n");
+			free_page(mem_addr);
+			return -ENOMEM;
+		}
+		fep->rx_skbuff[i] = pskb;
+		pskb->data = FEC_ADDR_ALIGNMENT(pskb->data);
+		bdp->cbd_sc = BD_ENET_RX_EMPTY;
+		bdp->cbd_bufaddr = __pa(pskb->data);
+	}
+	/* Set the last buffer to wrap.
+	 */
+	bdp--;
+	bdp->cbd_sc |= BD_SC_WRAP;
+
+	/* ...and the same for transmmit.
+	 */
+	bdp = fep->tx_bd_base;
+	for (i = 0, j = FEC_ENET_TX_FRPPG; i < TX_RING_SIZE; i++) {
+		if (j >= FEC_ENET_TX_FRPPG) {
+			mem_addr = __get_free_page(GFP_KERNEL);
+			j = 1;
+		} else {
+			mem_addr += FEC_ENET_TX_FRSIZE;
+			j++;
+		}
+		fep->tx_bounce[i] = (unsigned char *)mem_addr;
+
+		/* Initialize the BD for every fragment in the page.
+		 */
+		bdp->cbd_sc = 0;
+		bdp->cbd_bufaddr = 0;
+		bdp++;
+	}
+
+	/* Set the last buffer to wrap.
+	 */
+	bdp--;
+	bdp->cbd_sc |= BD_SC_WRAP;
+
+	/* Set receive and transmit descriptor base.
+	 */
+	fecp->fec_r_des_start = __pa((uint) (fep->cbd_mem_base));
+	fecp->fec_x_des_start =
+	    __pa((uint) (fep->cbd_mem_base + RX_RING_SIZE * sizeof(cbd_t)));
+
+	/* Install our interrupt handlers. This varies depending on
+	 * the architecture.
+	 */
+	fec_request_intrs(dev);
+
+	/* Clear and enable interrupts */
+	fecp->fec_ievent = FEC_ENET_MASK;
+	fecp->fec_imask =
+	    FEC_ENET_TXF | FEC_ENET_TXB | FEC_ENET_RXF | FEC_ENET_RXB |
+	    FEC_ENET_MII;
+
+	fecp->fec_hash_table_high = 0;
+	fecp->fec_hash_table_low = 0;
+	fecp->fec_r_buff_size = PKT_MAXBLR_SIZE;
+	fecp->fec_ecntrl = 2;
+	fecp->fec_r_des_active = 0x01000000;
+
+	dev->base_addr = (unsigned long)fecp;
+
+	/* The FEC Ethernet specific entries in the device structure. */
+	dev->open = fec_enet_open;
+	dev->hard_start_xmit = fec_enet_start_xmit;
+	dev->tx_timeout = fec_timeout;
+	dev->watchdog_timeo = TX_TIMEOUT;
+	dev->stop = fec_enet_close;
+	dev->get_stats = fec_enet_get_stats;
+	dev->set_multicast_list = set_multicast_list;
+
+	for (i = 0; i < NMII - 1; i++)
+		mii_cmds[i].mii_next = &mii_cmds[i + 1];
+	mii_free = mii_cmds;
+
+	/* setup MII interface */
+	fec_set_mii(dev, fep);
+
+	/* Queue up command to detect the PHY and initialize the
+	 * remainder of the interface.
+	 */
+	fep->phy_id_done = 0;
+	fep->phy_addr = 0;
+	mii_queue(dev, mk_mii_read(MII_REG_PHYIR1), mii_discover_phy);
+
+	index++;
+	return 0;
+}
+
+/* This function is called to start or restart the FEC during a link
+ * change.  This only happens when switching between half and full
+ * duplex.
+ */
+static void fec_restart(struct net_device *dev, int duplex)
+{
+	struct fec_enet_private *fep;
+	volatile cbd_t *bdp;
+	volatile fec_t *fecp;
+	int i;
+
+	fep = netdev_priv(dev);
+	fecp = fep->hwp;
+
+	/* Whack a reset.  We should wait for this.
+	 */
+	fecp->fec_ecntrl = 1;
+	udelay(10);
+
+	/* Enable interrupts we wish to service.
+	 */
+	fecp->fec_imask =
+	    FEC_ENET_TXF | FEC_ENET_TXB | FEC_ENET_RXF | FEC_ENET_RXB |
+	    FEC_ENET_MII;
+
+	/* Clear any outstanding interrupt.
+	 *
+	 */
+	fecp->fec_ievent = FEC_ENET_MASK;
+
+	fec_enable_phy_intr();
+
+	/* Set station address.
+	 */
+	fec_set_mac_address(dev);
+
+	/* Reset all multicast.
+	 */
+	fecp->fec_hash_table_high = 0;
+	fecp->fec_hash_table_low = 0;
+
+	/* Set maximum receive buffer size.
+	 */
+	fecp->fec_r_buff_size = PKT_MAXBLR_SIZE;
+
+	fec_localhw_setup();
+
+	/* Set receive and transmit descriptor base.
+	 */
+	fecp->fec_r_des_start = __pa((uint) (fep->cbd_mem_base));
+	fecp->fec_x_des_start =
+	    __pa((uint) (fep->cbd_mem_base + RX_RING_SIZE * sizeof(cbd_t)));
+
+	fep->dirty_tx = fep->cur_tx = fep->tx_bd_base;
+	fep->cur_rx = fep->rx_bd_base;
+
+	/* Reset SKB transmit buffers.
+	 */
+	fep->skb_cur = fep->skb_dirty = 0;
+	for (i = 0; i <= TX_RING_MOD_MASK; i++) {
+		if (fep->tx_skbuff[i] != NULL) {
+			dev_kfree_skb_any(fep->tx_skbuff[i]);
+			fep->tx_skbuff[i] = NULL;
+		}
+	}
+
+	/* Initialize the receive buffer descriptors.
+	 */
+	bdp = fep->rx_bd_base;
+	for (i = 0; i < RX_RING_SIZE; i++) {
+
+		/* Initialize the BD for every fragment in the page.
+		 */
+		bdp->cbd_sc = BD_ENET_RX_EMPTY;
+		bdp++;
+	}
+
+	/* Set the last buffer to wrap.
+	 */
+	bdp--;
+	bdp->cbd_sc |= BD_SC_WRAP;
+
+	/* ...and the same for transmmit.
+	 */
+	bdp = fep->tx_bd_base;
+	for (i = 0; i < TX_RING_SIZE; i++) {
+
+		/* Initialize the BD for every fragment in the page.
+		 */
+		bdp->cbd_sc = 0;
+		bdp->cbd_bufaddr = 0;
+		bdp++;
+	}
+
+	/* Set the last buffer to wrap.
+	 */
+	bdp--;
+	bdp->cbd_sc |= BD_SC_WRAP;
+
+	/* Enable MII mode.
+	 */
+	if (duplex) {
+		fecp->fec_r_cntrl = OPT_FRAME_SIZE | 0x04;	/* MII enable */
+		fecp->fec_x_cntrl = 0x04;	/* FD enable */
+	} else {
+		/* MII enable|No Rcv on Xmit */
+		fecp->fec_r_cntrl = OPT_FRAME_SIZE | 0x06;
+		fecp->fec_x_cntrl = 0x00;
+	}
+	fep->full_duplex = duplex;
+
+	/* Set MII speed.
+	 */
+	fecp->fec_mii_speed = fep->phy_speed;
+
+	/* And last, enable the transmit and receive processing.
+	 */
+	fecp->fec_ecntrl = 2;
+	fecp->fec_r_des_active = 0x01000000;
+
+	netif_start_queue(dev);
+}
+
+static void fec_stop(struct net_device *dev)
+{
+	volatile fec_t *fecp;
+	struct fec_enet_private *fep;
+
+	netif_stop_queue(dev);
+
+	fep = netdev_priv(dev);
+	fecp = fep->hwp;
+
+	/*
+	 ** We cannot expect a graceful transmit stop without link !!!
+	 */
+	if (fep->link) {
+		fecp->fec_x_cntrl = 0x01;	/* Graceful transmit stop */
+		udelay(10);
+		if (!(fecp->fec_ievent & FEC_ENET_GRA))
+			printk
+			    ("fec_stop : Graceful transmit stop did not complete !\n");
+	}
+
+	/* Whack a reset.  We should wait for this.
+	 */
+	fecp->fec_ecntrl = 1;
+	udelay(10);
+
+	/* Clear outstanding MII command interrupts.
+	 */
+	fecp->fec_ievent = FEC_ENET_MII;
+	fec_enable_phy_intr();
+
+	fecp->fec_imask = FEC_ENET_MII;
+	fecp->fec_mii_speed = fep->phy_speed;
+}
+
+static int __init fec_enet_module_init(void)
+{
+	struct net_device *dev;
+	int i, j, err;
+
+	printk("FEC ENET Version 0.2\n");
+	fec_arch_init();
+
+	for (i = 0; (i < FEC_MAX_PORTS); i++) {
+		dev = alloc_etherdev(sizeof(struct fec_enet_private));
+		if (!dev)
+			return -ENOMEM;
+		err = fec_enet_init(dev);
+		if (err) {
+			free_netdev(dev);
+			continue;
+		}
+		if (register_netdev(dev) != 0) {
+			free_netdev(dev);
+			return -EIO;
+		}
+
+		fec_device[i] = dev;
+
+		printk("%s: ethernet ", dev->name);
+		for (j = 0; (j < 5); j++)
+			printk("%02x:", dev->dev_addr[j]);
+		printk("%02x\n", dev->dev_addr[5]);
+	}
+	return 0;
+}
+
+module_init(fec_enet_module_init);
+
+static void __exit fec_enet_module_cleanup(void)
+{
+	struct net_device *dev;
+	int i;
+
+	for (i = 0; (i < FEC_MAX_PORTS); i++) {
+		dev = fec_device[i];
+		fec_release_intrs(dev);
+		unregister_netdev(dev);
+		free_netdev(dev);
+		fec_device[i] = NULL;
+	}
+
+	fec_arch_exit();
+}
+
+module_exit(fec_enet_module_cleanup);
+
+MODULE_LICENSE("GPL");
diff --git a/drivers/net/fec_mx2.h b/drivers/net/fec_mx2.h
new file mode 100644
index 0000000..6af2ad0
--- /dev/null
+++ b/drivers/net/fec_mx2.h
@@ -0,0 +1,173 @@
+/****************************************************************************/
+
+/*
+ *	fec.h  --  Fast Ethernet Controller for Motorola ColdFire SoC
+ *		   processors.
+ *
+ *	(C) Copyright 2000-2005, Greg Ungerer (gerg@snapgear.com)
+ *	(C) Copyright 2000-2001, Lineo (www.lineo.com)
+ */
+
+/****************************************************************************/
+#ifndef FEC_H
+#define	FEC_H
+/****************************************************************************/
+
+#if defined(CONFIG_M523x) || defined(CONFIG_M527x) || defined(CONFIG_M528x) || \
+    defined(CONFIG_M520x) || defined(CONFIG_M532x) || defined(CONFIG_ARCH_MXC)
+/*
+ *	Just figures, Motorola would have to change the offsets for
+ *	registers in the same peripheral device on different models
+ *	of the ColdFire!
+ */
+typedef struct fec {
+	unsigned long fec_reserved0;
+	unsigned long fec_ievent;	/* Interrupt event reg */
+	unsigned long fec_imask;	/* Interrupt mask reg */
+	unsigned long fec_reserved1;
+	unsigned long fec_r_des_active;	/* Receive descriptor reg */
+	unsigned long fec_x_des_active;	/* Transmit descriptor reg */
+	unsigned long fec_reserved2[3];
+	unsigned long fec_ecntrl;	/* Ethernet control reg */
+	unsigned long fec_reserved3[6];
+	unsigned long fec_mii_data;	/* MII manage frame reg */
+	unsigned long fec_mii_speed;	/* MII speed control reg */
+	unsigned long fec_reserved4[7];
+	unsigned long fec_mib_ctrlstat;	/* MIB control/status reg */
+	unsigned long fec_reserved5[7];
+	unsigned long fec_r_cntrl;	/* Receive control reg */
+	unsigned long fec_reserved6[15];
+	unsigned long fec_x_cntrl;	/* Transmit Control reg */
+	unsigned long fec_reserved7[7];
+	unsigned long fec_addr_low;	/* Low 32bits MAC address */
+	unsigned long fec_addr_high;	/* High 16bits MAC address */
+	unsigned long fec_opd;	/* Opcode + Pause duration */
+	unsigned long fec_reserved8[10];
+	unsigned long fec_hash_table_high;	/* High 32bits hash table */
+	unsigned long fec_hash_table_low;	/* Low 32bits hash table */
+	unsigned long fec_grp_hash_table_high;	/* High 32bits hash table */
+	unsigned long fec_grp_hash_table_low;	/* Low 32bits hash table */
+	unsigned long fec_reserved9[7];
+	unsigned long fec_x_wmrk;	/* FIFO transmit water mark */
+	unsigned long fec_reserved10;
+	unsigned long fec_r_bound;	/* FIFO receive bound reg */
+	unsigned long fec_r_fstart;	/* FIFO receive start reg */
+	unsigned long fec_reserved11[11];
+	unsigned long fec_r_des_start;	/* Receive descriptor ring */
+	unsigned long fec_x_des_start;	/* Transmit descriptor ring */
+	unsigned long fec_r_buff_size;	/* Maximum receive buff size */
+} fec_t;
+
+#else
+
+/*
+ *	Define device register set address map.
+ */
+typedef struct fec {
+	unsigned long fec_ecntrl;	/* Ethernet control reg */
+	unsigned long fec_ievent;	/* Interrupt even reg */
+	unsigned long fec_imask;	/* Interrupt mask reg */
+	unsigned long fec_ivec;	/* Interrupt vec status reg */
+	unsigned long fec_r_des_active;	/* Receive descriptor reg */
+	unsigned long fec_x_des_active;	/* Transmit descriptor reg */
+	unsigned long fec_reserved1[10];
+	unsigned long fec_mii_data;	/* MII manage frame reg */
+	unsigned long fec_mii_speed;	/* MII speed control reg */
+	unsigned long fec_reserved2[17];
+	unsigned long fec_r_bound;	/* FIFO receive bound reg */
+	unsigned long fec_r_fstart;	/* FIFO receive start reg */
+	unsigned long fec_reserved3[4];
+	unsigned long fec_x_wmrk;	/* FIFO transmit water mark */
+	unsigned long fec_reserved4;
+	unsigned long fec_x_fstart;	/* FIFO transmit start reg */
+	unsigned long fec_reserved5[21];
+	unsigned long fec_r_cntrl;	/* Receive control reg */
+	unsigned long fec_max_frm_len;	/* Maximum frame length reg */
+	unsigned long fec_reserved6[14];
+	unsigned long fec_x_cntrl;	/* Transmit Control reg */
+	unsigned long fec_reserved7[158];
+	unsigned long fec_addr_low;	/* Low 32bits MAC address */
+	unsigned long fec_addr_high;	/* High 16bits MAC address */
+	unsigned long fec_hash_table_high;	/* High 32bits hash table */
+	unsigned long fec_hash_table_low;	/* Low 32bits hash table */
+	unsigned long fec_r_des_start;	/* Receive descriptor ring */
+	unsigned long fec_x_des_start;	/* Transmit descriptor ring */
+	unsigned long fec_r_buff_size;	/* Maximum receive buff size */
+	unsigned long reserved8[9];
+	unsigned long fec_fifo_ram[112];	/* FIFO RAM buffer */
+} fec_t;
+
+#endif /* CONFIG_M5272 */
+
+/*
+ *	Define the buffer descriptor structure.
+ */
+/* Please see "Receive Buffer Descriptor Field Definitions" in Specification.
+ * It's LE.
+ */
+#ifdef CONFIG_ARCH_MXC
+typedef struct bufdesc {
+	unsigned short cbd_datlen;	/* Data length */
+	unsigned short cbd_sc;	/* Control and status info */
+	unsigned long cbd_bufaddr;	/* Buffer address */
+} cbd_t;
+#else
+typedef struct bufdesc {
+	unsigned short cbd_sc;	/* Control and status info */
+	unsigned short cbd_datlen;	/* Data length */
+	unsigned long cbd_bufaddr;	/* Buffer address */
+} cbd_t;
+#endif
+
+/*
+ *	The following definitions courtesy of commproc.h, which where
+ *	Copyright (c) 1997 Dan Malek (dmalek@jlc.net).
+ */
+#define BD_SC_EMPTY     ((ushort)0x8000)	/* Recieve is empty */
+#define BD_SC_READY     ((ushort)0x8000)	/* Transmit is ready */
+#define BD_SC_WRAP      ((ushort)0x2000)	/* Last buffer descriptor */
+#define BD_SC_INTRPT    ((ushort)0x1000)	/* Interrupt on change */
+#define BD_SC_CM        ((ushort)0x0200)	/* Continous mode */
+#define BD_SC_ID        ((ushort)0x0100)	/* Rec'd too many idles */
+#define BD_SC_P         ((ushort)0x0100)	/* xmt preamble */
+#define BD_SC_BR        ((ushort)0x0020)	/* Break received */
+#define BD_SC_FR        ((ushort)0x0010)	/* Framing error */
+#define BD_SC_PR        ((ushort)0x0008)	/* Parity error */
+#define BD_SC_OV        ((ushort)0x0002)	/* Overrun */
+#define BD_SC_CD        ((ushort)0x0001)	/* ?? */
+
+/* Buffer descriptor control/status used by Ethernet receive.
+*/
+#define BD_ENET_RX_EMPTY        ((ushort)0x8000)
+#define BD_ENET_RX_WRAP         ((ushort)0x2000)
+#define BD_ENET_RX_INTR         ((ushort)0x1000)
+#define BD_ENET_RX_LAST         ((ushort)0x0800)
+#define BD_ENET_RX_FIRST        ((ushort)0x0400)
+#define BD_ENET_RX_MISS         ((ushort)0x0100)
+#define BD_ENET_RX_LG           ((ushort)0x0020)
+#define BD_ENET_RX_NO           ((ushort)0x0010)
+#define BD_ENET_RX_SH           ((ushort)0x0008)
+#define BD_ENET_RX_CR           ((ushort)0x0004)
+#define BD_ENET_RX_OV           ((ushort)0x0002)
+#define BD_ENET_RX_CL           ((ushort)0x0001)
+#define BD_ENET_RX_STATS        ((ushort)0x013f)	/* All status bits */
+
+/* Buffer descriptor control/status used by Ethernet transmit.
+*/
+#define BD_ENET_TX_READY        ((ushort)0x8000)
+#define BD_ENET_TX_PAD          ((ushort)0x4000)
+#define BD_ENET_TX_WRAP         ((ushort)0x2000)
+#define BD_ENET_TX_INTR         ((ushort)0x1000)
+#define BD_ENET_TX_LAST         ((ushort)0x0800)
+#define BD_ENET_TX_TC           ((ushort)0x0400)
+#define BD_ENET_TX_DEF          ((ushort)0x0200)
+#define BD_ENET_TX_HB           ((ushort)0x0100)
+#define BD_ENET_TX_LC           ((ushort)0x0080)
+#define BD_ENET_TX_RL           ((ushort)0x0040)
+#define BD_ENET_TX_RCMASK       ((ushort)0x003c)
+#define BD_ENET_TX_UN           ((ushort)0x0002)
+#define BD_ENET_TX_CSL          ((ushort)0x0001)
+#define BD_ENET_TX_STATS        ((ushort)0x03ff)	/* All status bits */
+
+/****************************************************************************/
+#endif /* FEC_H */
-- 
1.6.0.3

