From fe5fa394bd25c0ac83083658864e7bc2b987ca24 Mon Sep 17 00:00:00 2001
From: Alexander Smirnov <asmirnov@embeddedalley.com>
Date: Mon, 29 Dec 2008 19:17:51 +0300
Subject: [PATCH] i.MX27 CPU: Add an ALSA driver for i.MX27

This patch adds an ALSA sound driver to play and capture some noise in
conjunction with an external PMIC MC13783-device. Sound will be exchanged
via two SSI units. One for playback, one for capture. The driver must be
configured by an BSP. This means, it must configure what external SSI
channels are connected to the PMIC. Four are possible, two of them must be
selected.

Note: The PMIC, the SSI units and the DAM unit are fragile beasts ;-)

Note: Not intended for mainline yet, as it needs a special DMA API.

sha:
- do not claim we can do mono and let alsa handle it
- merge snd_imx_*_open
- some general cleanup
- Take some steps towards SOC, add finer grained controls

Signed-off-by: Juergen Beisert <j.beisert@pengutronix.de>
Signed-off-by: Sascha Hauer <s.hauer@pengutronix.de>
Signed-off-by: Alexander Smirnov <asmirnov@embeddedalley.com>

Merged from pengutronix.com
---
 arch/arm/plat-mxc/include/mach/imx_sound.h |   34 ++
 sound/arm/Kconfig                          |   11 +
 sound/arm/Makefile                         |    3 +
 sound/arm/imx2-dam.c                       |  202 ++++++++
 sound/arm/imx2-dam.h                       |   20 +
 sound/arm/imx2-pcm.c                       |  697 ++++++++++++++++++++++++++++
 sound/arm/imx2-ssi.c                       |  447 ++++++++++++++++++
 sound/arm/imx2-ssi.h                       |   44 ++
 sound/arm/mc13783.c                        |  513 ++++++++++++++++++++
 sound/arm/mc13783.h                        |   26 +
 sound/arm/soc-wrapper.c                    |  236 ++++++++++
 11 files changed, 2233 insertions(+), 0 deletions(-)
 create mode 100644 arch/arm/plat-mxc/include/mach/imx_sound.h
 create mode 100644 sound/arm/imx2-dam.c
 create mode 100644 sound/arm/imx2-dam.h
 create mode 100644 sound/arm/imx2-pcm.c
 create mode 100644 sound/arm/imx2-ssi.c
 create mode 100644 sound/arm/imx2-ssi.h
 create mode 100644 sound/arm/mc13783.c
 create mode 100644 sound/arm/mc13783.h
 create mode 100644 sound/arm/soc-wrapper.c

diff --git a/arch/arm/plat-mxc/include/mach/imx_sound.h b/arch/arm/plat-mxc/include/mach/imx_sound.h
new file mode 100644
index 0000000..3c60054
--- /dev/null
+++ b/arch/arm/plat-mxc/include/mach/imx_sound.h
@@ -0,0 +1,34 @@
+/*
+ * Copyright 2008 Juergen Beisert, kernel@pengutronix.de
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+
+#ifndef __SOUND_ARM_IMX_SOUND_H
+#define __SOUND_ARM_IMX_SOUND_H
+
+#define IMX_SUPPORTED_SSI_UNITS 2
+
+struct imx_sound_connection {
+	int cpu_port;	/* from 1 to 4 on i.MX27, 0 unused */
+	int dev_port;	/* I2S device specific. 1 to 2 for PMIC MC13783, 0 unused */
+};
+
+struct imx_sound_platform_data {
+	struct imx_sound_connection connection[IMX_SUPPORTED_SSI_UNITS];
+	int (*init)(struct platform_device *pdev);
+	void (*exit)(struct platform_device *pdev);
+};
+
+#endif
diff --git a/sound/arm/Kconfig b/sound/arm/Kconfig
index 8acd721..b239353 100644
--- a/sound/arm/Kconfig
+++ b/sound/arm/Kconfig
@@ -28,6 +28,17 @@ config SND_ARMAACI
 	select SND_PCM
 	select SND_AC97_CODEC
 
+config SND_IMX2_PCM
+	tristate "i.MX27/MC13783 driver"
+	depends on SND && ARCH_MX2
+	select SND_PCM
+	help
+	  Say Y here to include support for i.MX27 based CPU cards with
+	  sound output based on the external MC13783 chip (aka PMIC).
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called snd-mc13783.
+
 config SND_PXA2XX_PCM
 	tristate
 	select SND_PCM
diff --git a/sound/arm/Makefile b/sound/arm/Makefile
index 2831bb8..e7f7d42 100644
--- a/sound/arm/Makefile
+++ b/sound/arm/Makefile
@@ -16,6 +16,9 @@ snd-pxa2xx-ac97-objs		:= pxa2xx-ac97.o
 
 obj-$(CONFIG_SND) += omap/
 
+snd-mc13783-objs		:= imx2-pcm.o imx2-ssi.o imx2-dam.o mc13783.o devdma.o
+obj-$(CONFIG_SND_IMX2_PCM)	+= snd-mc13783.o
+
 #
 ## Define the header file locations for PMIC drivers.
 #
diff --git a/sound/arm/imx2-dam.c b/sound/arm/imx2-dam.c
new file mode 100644
index 0000000..7da2594
--- /dev/null
+++ b/sound/arm/imx2-dam.c
@@ -0,0 +1,202 @@
+/*
+ * Copyright 2008 Juergen Beisert, kernel@pengutronix.de
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+
+#include <linux/platform_device.h>
+#include <mach/imx_dam.h>
+#include <asm/io.h>
+
+#define DRV_NAME "mxc-dam"
+
+struct dam_data {
+	void __iomem *io;
+	struct platform_device *pdev;
+};
+
+/*
+ * Table of internal DAM port mappings to their offchip
+ * SSI pin groups. This is verified for the i.MX27 CPU.
+ */
+static const int DAM_routing[] = {
+	3,	/* SSI1_* pin group is port 4 at the DAM unit */
+	4,	/* SSI2_* pin group is port 5 at the DAM unit */
+	5,	/* SSI3_* pin group is port 6 at the DAM unit */
+	2	/* SSI4_* pin group is port 3 at the DAM unit */
+};
+
+/* there is only one unit in this CPU */
+static struct dam_data dam;
+
+/* this unit has hardly predictable register offsets */
+static const unsigned int reg_offsets[] = {
+	DAM_HPCR1, DAM_HPCR2, DAM_HPCR3, DAM_PPCR1, DAM_PPCR2, DAM_PPCR3
+};
+
+#define    _reg_DAM_HPCR(a)	reg_offsets[a]	/* 0..1 */
+#define    _reg_DAM_PPCR(a)	reg_offsets[a]	/* 2..5 */
+
+/*
+ * Route an internal SSI channel (1 or 2) as a slave to two
+ * of the four SSI pin groups (1 to 4).
+ * Note: 6-wire mode and i2s data only. This means no network
+ * feature on this bus.
+ *
+ * This means:
+ *
+ *  SSI unit       DAM@SSI         DAM@per       SSI_pin
+ * ---------------------------------------------------------------------------
+ *    SRCK(in)    SRCK(out)                      SSI?_CLK (2)
+ *    SRFS(in)    SRFS(out)                      SSI?_FS (2)
+ *    SRXD(in)                      Da           SSI?_RXD (2)
+ *    STCK(in)    TCLK(out)         CLK          SSI?_CLK (1)
+ *    STFS(in)    TFS(out)          FS           SSI?_FS (1)
+ *    STXD(out)                     Db           SSI?_TXD (1)
+ *
+ * -> ssi_pin1 means the output channel, ssi_pin2 means the input channel.
+ * -> RXD from ssi_pin1 is not used, TXD from ssi_pin2 is not used.
+s */
+
+/*
+ * Route an internal SSI channel (1 or 2) as a slave to one
+ * of the four SSI pin groups (1 to 4).
+ * Note: 4-wire mode and i2s data only. This means no network
+ * feature on this bus.
+ *
+ * This means:
+ *
+ *  SSI unit      DAM@SSI          DAM@per        SSI_pin
+ * ---------------------------------------------------------------------------
+ *    SRCK (in)
+ *    SRFS (in)
+ *    SRXD (in)                      Da           SSI?_RXD
+ *    STCK (in)    TCLK(out)         CLK          SSI?_CLK
+ *    STFS (in)    TFS(out)          FS           SSI?_FS
+ *    STXD (out)                     Db           SSI?_TXD
+ */
+int dam_configure_sync_slave(int ssi_unit, int ssi_pin)
+{
+	int host_port, target_port;
+	u32 host_val, target_val;
+
+	if (ssi_unit == 0 || ssi_pin == 0) {
+		dev_err(&dam.pdev->dev, "DAM: Source or target port not defined\n");
+		return -ENODEV;
+	}
+
+	host_port = ssi_unit - 1;
+	target_port = DAM_routing[ssi_pin - 1];
+
+	pr_debug("DAM: Connecting SSI%d's port %d to peripheral port %d\n",
+		ssi_unit, ssi_unit, target_port + 1);
+
+	/* starting to configure the host port */
+	host_val = DAM_HPCR_SYN;	/* 4wire mode */
+	/* where the RxD signal comes from */
+	host_val |= DAM_HPCR_RXDSEL(target_port);
+	/*
+	 * SSI@STFS(in) <-- DAM@TFS(out)
+	 * SSI@STCK(in) <-- DAM@TCLK(out)
+	 */
+	host_val |= DAM_HPCR_TFSDIR;	/* TFS is output at this port */
+	host_val |= DAM_HPCR_TCLKDIR;	/* TCLK is output at this port */
+	/*
+	 * DAM@TFS(out) select from which other port and route to port's TFS (not RFS)
+	 * DAM@TCLK(out) select from which other port and route to port's TCLK (not TCLK)
+	 */
+	host_val |= DAM_HPCR_TFCSEL(target_port);
+
+	/* and now configure the port to the peripheral */
+	target_val = DAM_PPCR_SYN;	/* 4wire mode */
+	/* where the RxD signal comes from */
+	target_val |= DAM_PPCR_RXDSEL(host_port);
+
+	iowrite32(target_val, dam.io + reg_offsets[target_port]);
+	iowrite32(host_val, dam.io + reg_offsets[host_port]);
+
+	pr_debug("H1: %08X, H2: %08X, S1: %08X, S2: %08X, S3: %08X, S4: %08X\n",
+		ioread32(dam.io + _reg_DAM_HPCR(0)),
+		ioread32(dam.io + _reg_DAM_HPCR(1)),
+		ioread32(dam.io + _reg_DAM_PPCR(2)),
+		ioread32(dam.io + _reg_DAM_PPCR(3)),
+		ioread32(dam.io + _reg_DAM_PPCR(4)),
+		ioread32(dam.io + _reg_DAM_PPCR(5)));
+	return 0;
+}
+
+static int __devinit mx2_dam_probe(struct platform_device *pdev)
+{
+	struct resource *res;
+	int ret;
+
+	pr_info("Probing i.MX DAM unit\n");
+
+	dam.pdev = pdev;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (res == NULL) {
+		dev_err(&pdev->dev, "No resource data for IMX DAM\n");
+		return -ENODEV;
+	}
+
+	if (!request_mem_region(res->start, res->end - res->start + 1, DRV_NAME)) {
+		dev_err(&pdev->dev, "request_mem_region failed for IMX DAM\n");
+		return -EBUSY;
+	}
+
+	dam.io = ioremap(res->start, res->end - res->start + 1);
+	if (dam.io == NULL) {
+		dev_err(&pdev->dev, "Mapping region failed for IMX DAM\n");
+		ret = -ENODEV;
+		goto err1;
+	}
+
+	return 0;	/* return happy */
+
+err1:
+	release_mem_region(res->start, res->end - res->start + 1);
+	return ret;
+}
+
+static int __devexit mx2_dam_remove(struct platform_device *pdev)
+{
+	struct resource *res;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	release_mem_region(res->start, res->end - res->start + 1);
+	iounmap(dam.io);
+	dam.io = NULL;
+
+	return 0;
+}
+
+static struct platform_driver mx2_dam_driver = {
+	.driver = {
+		.name		= DRV_NAME,
+		.owner		= THIS_MODULE,
+	},
+	.probe		= mx2_dam_probe,
+	.remove		= __devexit_p(mx2_dam_remove),
+};
+
+int __init mx2_dam_init(void)
+{
+	return platform_driver_register(&mx2_dam_driver);
+}
+
+void __exit mx2_dam_exit(void)
+{
+	platform_driver_unregister(&mx2_dam_driver);
+}
diff --git a/sound/arm/imx2-dam.h b/sound/arm/imx2-dam.h
new file mode 100644
index 0000000..67ee901
--- /dev/null
+++ b/sound/arm/imx2-dam.h
@@ -0,0 +1,20 @@
+/*
+ * Copyright 2008 Juergen Beisert, kernel@pengutronix.de
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+
+extern int mx2_dam_init(void);
+extern void mx2_dam_exit(void);
+extern int dam_configure_sync_slave(int, int);
diff --git a/sound/arm/imx2-pcm.c b/sound/arm/imx2-pcm.c
new file mode 100644
index 0000000..aa3933f
--- /dev/null
+++ b/sound/arm/imx2-pcm.c
@@ -0,0 +1,697 @@
+/*
+ * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2008 Juergen Beisert, kernel@pengutronix.de
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ *
+ * Note:
+ * This driver works very close to the MC13783 (aka PMIC). There are so many
+ * dependencies between the i.MX27 SSI and the PMIC and other strange behaviors
+ * on both side, that it is very hard to bring them into a layerd design, where
+ * one layer do not know the requirements of the other layer.
+ *
+ * Currently only filesizes up to 2^32 are supported to play and record at
+ * once. This would change, if the DMA API would change.
+ */
+
+#include <linux/platform_device.h>
+#include <linux/errno.h>
+#include <linux/dma-mapping.h>
+#include <linux/soundcard.h>
+#ifdef CONFIG_PM
+#include <linux/pm.h>
+#endif /* CONFIG_PM */
+
+#include <mach/dma.h>
+#include <mach/dma-mx1-mx2.h>
+#include <mach/imx_sound.h>
+
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/initval.h>
+#include <sound/control.h>
+
+#include "devdma.h"
+#include "mc13783.h"
+#include "imx2-dam.h"
+#include "imx2-ssi.h"
+
+#define DRV_NAME "imx-alsa"
+
+/*
+ * PMIC driver buffer policy.
+ * Customize here if the sound is not correct
+ */
+#define MAX_BUFFER_SIZE  			(64*1024)
+#define DMA_BUF_SIZE				(16*1024)
+#define MIN_PERIOD_SIZE				2048
+#define MIN_PERIOD				8
+#define MAX_PERIOD				255
+
+#define SOUND_CARD_NAME				"imx sound"
+
+#define PLAYBACK 0
+#define RECORD 1
+
+/* runtime info on a per stream base */
+struct imx_sound_channel {
+	int dmac;	/* DMA channel handle */
+	struct device *dev;
+	int ssi;	/* iss channel to be used for this stream (0 or 1) */
+	int tgt_bus;	/* target's bus number (0 or 1) at PMIC side */
+
+	void __iomem *fifo_io;	/* physical address of the FIFO to write to or read from */
+
+	/* DMA buffer description */
+	void *base;		/* physical address of the DMA buffer in memory */
+	void *adr;		/* virtual address of the DMA buffer */
+	int size;		/* buffer size */
+	int sg_count;
+	struct scatterlist *sg_list;
+
+	/* stream information */
+	int period;		/* bytes per period */
+	int periods;		/* count of periods in this buffer */
+	char enabled;		/* 1 if DMA should keep activated */
+
+	/* consumed data information */
+	unsigned int offset;	/* current pointer (=period) where the DMA unit reads from or writes to */
+
+	struct snd_pcm_substream *substream;
+};
+
+struct imx_snd_card {
+	struct snd_card *card;
+	struct snd_pcm *pcm;
+	int ssi_unit;	/* internal SSI unit (0 or 1) */
+	int tgt_bus;	/* PMIC's bus number (0 or 1) */
+};
+
+/* ################### internals ####################### */
+
+/* Called by the DMA framework when a period has elapsed */
+static void snd_imx_dma_progression(int channel, void *data,
+					struct scatterlist *sg)
+{
+	struct imx_sound_channel *channel_info = data;
+
+	if (sg != NULL) {
+		channel_info->offset = (unsigned long)sg->dma_address -
+					(unsigned long)channel_info->base;
+		snd_pcm_period_elapsed(channel_info->substream);
+	}
+}
+
+/* called when the DMA unit has finished the buffer.
+ * it should not happen, but whith a playback or capturing
+ * size of 2^32 bytes it will happen!
+ */
+static void snd_imx_dma_callback(int channel, void *data)
+{
+	struct imx_sound_channel *channel_info = data;
+
+	pr_info("Too large audio file. Size exceeds 2^32-1!\n");
+	pr_info("Close the steam and reopen it!\n");
+	pr_info("Appologize for the inconvience!\n");
+
+	/* report period's end */
+	snd_pcm_period_elapsed(channel_info->substream);
+}
+
+static void snd_imx_dma_err_callback(int channel, void *data, int err)
+{
+	struct imx_sound_channel *channel_info = data;
+
+	pr_debug("DMA error callback called\n");
+
+	pr_debug("DMA timeout on channel %d -%s%s%s%s\n",
+		 channel_info->dmac,
+		 err & IMX_DMA_ERR_BURST ?    " burst":"",
+		 err & IMX_DMA_ERR_REQUEST ?  " request":"",
+		 err & IMX_DMA_ERR_TRANSFER ? " transfer":"",
+		 err & IMX_DMA_ERR_BUFFER ?   " buffer":"");
+	imx_ssi_transmit_enable(channel_info->ssi);
+}
+
+/* ################### ALSA generic ####################### */
+
+static int snd_imx_pcm_mmap(struct snd_pcm_substream *substream, struct vm_area_struct *vma)
+{
+	return devdma_mmap(NULL, substream, vma);
+}
+
+static snd_pcm_uframes_t snd_imx_pcm_pointer(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct imx_sound_channel *channel_info = runtime->private_data;
+
+	return bytes_to_frames(substream->runtime,
+		channel_info->offset == channel_info->size ? 0 : channel_info->offset);
+}
+
+/*
+ * This is called when the hardware parameter (hw_params) are set up by the
+ * application, that is, once when the buffer size, the period size, the format,
+ * etc. are defined for the pcm substream.
+ */
+static int snd_imx_pcm_hw_params(struct snd_pcm_substream *substream,
+				struct snd_pcm_hw_params *hw_params)
+{
+	struct imx_snd_card *imx_card = snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct imx_sound_channel *channel_info = runtime->private_data;
+	unsigned char *dma_adr;
+	int err = -EINVAL, i;
+
+	pr_debug("%s called\n", __func__);
+
+	err = mc13783_pcm_hw_params(substream, hw_params);
+	if (err)
+		return err;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		err = devdma_hw_alloc(imx_card[PLAYBACK].card->dev, substream,
+					params_buffer_bytes(hw_params));
+	if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)
+		err = devdma_hw_alloc(imx_card[RECORD].card->dev, substream,
+					params_buffer_bytes(hw_params));
+	if (err < 0)
+		return err;
+
+	pr_debug("DMA area: 0x%p, addr: 0x%p, size: %u\n",
+		runtime->dma_area, (void*)runtime->dma_addr, runtime->dma_bytes);
+
+	channel_info->base = (void*)runtime->dma_addr;
+	channel_info->adr = runtime->dma_area ;
+	channel_info->offset = 0;
+	channel_info->size = params_buffer_bytes(hw_params);
+	channel_info->periods = params_periods(hw_params);
+	channel_info->period = params_period_bytes(hw_params);
+
+	dma_adr = channel_info->base;
+
+	if (channel_info->sg_count != channel_info->periods) {
+		if (channel_info->sg_list != NULL)
+			kfree(channel_info->sg_list);
+		/* unsing sg_alloc_table() instead? */
+		channel_info->sg_list = kcalloc(channel_info->periods + 1,
+				sizeof(struct scatterlist), GFP_KERNEL);
+		pr_debug("Allocating scatter/gather list with %d+1 entries\n",
+				channel_info->periods);
+		if (channel_info->sg_list == NULL)
+			return -ENOMEM;
+		channel_info->sg_count = channel_info->periods + 1;
+	} else
+		pr_debug("Reuse previous scatter/gather memory\n");
+
+	sg_init_table(channel_info->sg_list, channel_info->sg_count);
+
+	for (i=0; i < channel_info->periods; i++) {
+		channel_info->sg_list[i].page_link = 0;
+		channel_info->sg_list[i].offset = 0;	/* FIXME */
+		channel_info->sg_list[i].dma_address = (dma_addr_t)dma_adr;
+		channel_info->sg_list[i].length = channel_info->period;
+
+		dma_adr += channel_info->period;
+	}
+
+	/* close the loop */
+	sg_chain(channel_info->sg_list, channel_info->sg_count, channel_info->sg_list);
+
+	pr_debug("Activating %d periods with %d bytes each\n",
+			channel_info->periods, channel_info->period);
+
+	return 0;
+}
+
+static int snd_imx_pcm_hw_free(struct snd_pcm_substream *substream)
+{
+	struct imx_snd_card *imx_card = snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct imx_sound_channel *channel_info = runtime->private_data;
+
+	pr_debug("%s called\n", __func__);
+
+	if (channel_info->sg_list != NULL) {
+		kfree(channel_info->sg_list);
+		channel_info->sg_list = NULL;
+	}
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		devdma_hw_free(imx_card[PLAYBACK].card->dev, substream);
+	if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)
+		devdma_hw_free(imx_card[RECORD].card->dev, substream);
+
+	return 0;
+}
+
+static int snd_imx_pcm_prepare(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct imx_sound_channel *channel_info = runtime->private_data;
+	int err = -EINVAL;
+	void __iomem *fifo_io;
+
+	pr_debug("%s called\n", __func__);
+
+	setup_channel_to_iis_slave(channel_info->ssi);
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		fifo_io = imx_get_dma_tx_address(channel_info->ssi, 0);
+		err = imx_dma_setup_sg(channel_info->dmac, channel_info->sg_list,
+				       channel_info->sg_count,
+				       -1, /* TODO largest possible size */
+				       (unsigned int)fifo_io,
+				       DMA_MODE_WRITE);
+	}
+	if (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {
+		fifo_io = imx_get_dma_rx_address(channel_info->ssi, 0);
+		err = imx_dma_setup_sg(channel_info->dmac, channel_info->sg_list,
+				       channel_info->sg_count,
+				       -1, /* TODO largest possible size */
+				       (unsigned int)fifo_io,
+				       DMA_MODE_READ);
+	}
+	if (err < 0) {
+		pr_err("Can't setup scatter/gather DMA\n");
+		return err;
+	}
+
+	return 0;
+}
+
+static int snd_imx_pcm_close(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct imx_sound_channel *channel_info = runtime->private_data;
+
+	pr_debug("%s called\n", __func__);
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		imx_ssi_transmit_disable(channel_info->ssi);
+
+	if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)
+		imx_ssi_receive_disable(channel_info->ssi);
+
+	imx_dma_disable(channel_info->dmac);
+
+	imx_ssi_disable(channel_info->ssi);
+	imx_dma_free(channel_info->dmac);
+
+	if (channel_info->sg_list != NULL)
+		kfree(channel_info->sg_list);
+
+	kfree(channel_info);
+	runtime->private_data = NULL;
+
+	return 0;
+}
+
+static int snd_imx_pcm_trigger(struct snd_pcm_substream *substream, int cmd)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct imx_sound_channel *channel_info = runtime->private_data;
+	int err = 0;
+
+	pr_debug("%s called\n", __func__);
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+		pr_debug("IMX: SNDRV_PCM_TRIGGER_START\n");
+		channel_info->enabled = 1;
+
+		imx_dma_enable(channel_info->dmac);
+
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+			imx_ssi_transmit_enable(channel_info->ssi);
+
+		if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)
+			imx_ssi_receive_enable(channel_info->ssi);
+		break;
+
+	case SNDRV_PCM_TRIGGER_STOP:
+		pr_debug("IMX: SNDRV_PCM_TRIGGER_STOP\n");
+		channel_info->enabled = 0;
+		imx_dma_disable(channel_info->dmac);
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+			imx_ssi_transmit_disable(channel_info->ssi);
+
+		if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)
+			imx_ssi_receive_disable(channel_info->ssi);
+
+		/* this clears the FIFO: 1-0-1 */
+		imx_ssi_disable(channel_info->ssi);
+		imx_ssi_enable(channel_info->ssi);
+		break;
+
+#if 0
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+		break;
+
+	case SNDRV_PCM_TRIGGER_RESUME:
+		break;
+#endif
+
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		pr_debug("IMX: SNDRV_PCM_TRIGGER_PAUSE_PUSH\n");
+		channel_info->enabled = 0;
+
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+			imx_ssi_transmit_disable(channel_info->ssi);
+
+		if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)
+			imx_ssi_receive_disable(channel_info->ssi);
+
+		/* TODO DMA stop required when SSI is stopped? */
+		imx_dma_disable(channel_info->dmac);
+		break;
+
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		pr_debug("IMX: SNDRV_PCM_TRIGGER_PAUSE_RELEASE\n");
+		channel_info->enabled = 1;
+
+		imx_dma_enable(channel_info->dmac);	/* TODO */
+
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+			imx_ssi_transmit_enable(channel_info->ssi);
+
+		if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)
+			imx_ssi_receive_enable(channel_info->ssi);
+		break;
+
+	default:
+		err = -EINVAL;
+		break;
+	}
+
+	return err;
+}
+
+/* ########### ALSA API ##################### */
+
+#define IMX_PLAYBACK_RATES (SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_11025 | \
+		SNDRV_PCM_RATE_16000 | SNDRV_PCM_RATE_22050 | \
+		SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_44100 | \
+		SNDRV_PCM_RATE_48000 | SNDRV_PCM_RATE_64000 | \
+		SNDRV_PCM_RATE_96000)
+
+#define IMX_CAPTURE_RATES (SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_16000)
+
+/* capabilities of the PMIC */
+static struct snd_pcm_hardware snd_imx_hardware = {
+	.info = SNDRV_PCM_INFO_INTERLEAVED |
+		SNDRV_PCM_INFO_BLOCK_TRANSFER |
+		SNDRV_PCM_INFO_MMAP |
+		SNDRV_PCM_INFO_MMAP_VALID |
+		SNDRV_PCM_INFO_PAUSE |
+		SNDRV_PCM_INFO_RESUME,
+	.formats = SNDRV_PCM_FMTBIT_S16_LE,
+	.rate_min = 8000,
+	.channels_min = 2,
+	.channels_max = 2,
+	.buffer_bytes_max = MAX_BUFFER_SIZE,
+	.period_bytes_min = MIN_PERIOD_SIZE,
+	.period_bytes_max = DMA_BUF_SIZE,
+	.periods_min = MIN_PERIOD,
+	.periods_max = MAX_PERIOD,
+	.fifo_size = 0,
+};
+
+static int snd_imx_open(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct imx_snd_card *imx_card = snd_pcm_substream_chip(substream);
+	struct imx_sound_channel *channel_info;
+	int channel, burst_length;
+	int err, dma_req;
+
+	pr_debug("%s called\n", __func__);
+
+	channel_info = kzalloc(sizeof(struct imx_sound_channel), GFP_KERNEL);
+	if (channel_info == NULL)
+		return -ENOMEM;
+
+	runtime->private_data = channel_info;
+	channel_info->substream = substream;
+
+	runtime->hw = snd_imx_hardware;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		channel = PLAYBACK;
+		runtime->hw.rates = IMX_PLAYBACK_RATES;
+		runtime->hw.rate_max = 96000;
+		burst_length = DMA_TXFIFO_BURST * 2;
+		dma_req = imx_get_dma_tx_channel(imx_card[channel].ssi_unit, 0);	/* for FIFO TX0 */
+		if (dma_req < 0)
+			return dma_req;
+	} else {
+		channel = RECORD;
+		runtime->hw.rates = IMX_CAPTURE_RATES;
+		runtime->hw.rate_max = 16000;
+		burst_length = DMA_RXFIFO_BURST * 2;
+		dma_req = imx_get_dma_rx_channel(imx_card[channel].ssi_unit, 0);	/* for FIFO TX0 */
+		if (dma_req < 0)
+			return dma_req;
+	}
+
+	channel_info->dev = imx_card[channel].card->dev;
+
+	/* FIXME Approx interrupts per buffer */
+	err = snd_pcm_hw_constraint_integer(runtime, SNDRV_PCM_HW_PARAM_PERIODS);
+	if (err < 0)
+		goto on_error_1;
+
+	/* setup DMA controller for playback */
+	channel_info->dmac = imx_dma_request_by_prio(DRV_NAME, DMA_PRIO_HIGH);
+	if (channel_info->dmac < 0) {
+		pr_err("Failed to claim the audio DMA\n");
+		goto on_error_1;
+	}
+
+	pr_debug("Got DMA channel %u for usage\n", channel_info->dmac);
+
+	err = imx_dma_setup_handlers(channel_info->dmac,
+				snd_imx_dma_callback,
+				snd_imx_dma_err_callback, channel_info);
+	if (err != 0) {
+		pr_err("Failed to setup the DMA handler\n");
+		err = -EIO;
+		goto on_error_2;
+	}
+
+	err = imx_dma_setup_progression_handler(channel_info->dmac, snd_imx_dma_progression);
+	if (err != 0) {
+		pr_err("Failed to setup the DMA handler\n");
+		err = -EIO;
+		goto on_error_2;
+	}
+
+	channel_info->ssi = imx_card[channel].ssi_unit;
+	channel_info->tgt_bus = imx_card[channel].tgt_bus;
+
+	/*
+	 * we are working with 16 bit words. So we must write
+	 * each sample as two 16 bit words.
+	 */
+	err = imx_dma_config_channel(channel_info->dmac,
+			IMX_DMA_MEMSIZE_16 | IMX_DMA_TYPE_FIFO,
+			IMX_DMA_MEMSIZE_32 | IMX_DMA_TYPE_LINEAR,
+			dma_req, 1);
+	if (err < 0) {
+		pr_debug("Cannot configure DMA channel\n");
+		goto on_error_2;
+	}
+
+	imx_dma_config_burstlen(channel_info->dmac, burst_length);
+
+	pr_debug("Burstlen for DMA channel %u is now: %u\n", channel_info->dmac, burst_length);
+
+	return 0;
+
+on_error_2:
+	imx_dma_free(channel_info->dmac);
+on_error_1:
+	kfree(channel_info);
+	return err;
+}
+
+static struct snd_pcm_ops snd_card_imx_ops = {
+	.open = snd_imx_open,
+	.close = snd_imx_pcm_close,
+	.ioctl = snd_pcm_lib_ioctl,
+	.hw_params = snd_imx_pcm_hw_params,
+	.hw_free = snd_imx_pcm_hw_free,
+	.prepare = snd_imx_pcm_prepare,
+	.trigger = snd_imx_pcm_trigger,
+	.pointer = snd_imx_pcm_pointer,
+	.mmap    = snd_imx_pcm_mmap
+};
+
+/* ##################################################################### */
+
+static int __devinit snd_imx_pcm_streams(struct imx_snd_card *imx_sound, int device)
+{
+	struct snd_pcm *pcm;
+	int err;
+
+	err = snd_pcm_new(imx_sound->card,
+			  SOUND_CARD_NAME,
+			  device,
+			  1,	/* one playback stream possible */
+			  1,	/* one capture stream possible */
+			  &pcm);
+
+	if (err < 0)
+		return err;
+
+	/* one substream instance is to playback some noise */
+	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK,
+			&snd_card_imx_ops);
+
+	/* one substream instance is to capture some noise */
+	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE,
+			&snd_card_imx_ops);
+
+	pcm->private_data = imx_sound;
+	imx_sound->pcm = pcm;
+	pcm->info_flags = 0;
+	strncpy(pcm->name, SOUND_CARD_NAME, sizeof(pcm->name));
+
+	return 0;
+}
+
+static int __devinit snd_imx_probe(struct platform_device *pdev)
+{
+	int err, i;
+	struct snd_card *card;
+	struct imx_snd_card *imx_card;
+	struct imx_sound_platform_data *pdata;
+
+	/* register the soundcard */
+	card = snd_card_new(-1, "PMICaudio", THIS_MODULE, 2 * sizeof(struct imx_snd_card));
+	if (card == NULL) {
+		return -ENOMEM;
+	}
+
+	pdata = pdev->dev.platform_data;
+	if (pdata == NULL) {
+		pr_err("No platformdata available. Giving up\n");
+		err = -ENODEV;
+		goto nodev;
+	}
+
+	imx_card = (struct imx_snd_card*)&card[1];
+
+	card->private_data = imx_card;
+
+	card->dev = &pdev->dev;
+
+	/* FIXME: Where to know how many SSI units we should use here? */
+
+	imx_card[PLAYBACK].ssi_unit = 0;
+	imx_card[PLAYBACK].tgt_bus = pdata->connection[0].dev_port - 1;
+	imx_card[PLAYBACK].card = card;
+
+	imx_card[RECORD].ssi_unit = 1;
+	imx_card[RECORD].tgt_bus = pdata->connection[1].dev_port - 1;
+	imx_card[RECORD].card = card;
+
+	err = snd_imx_pcm_streams(imx_card, 0);	/* TODO ...the ID */
+	if (err < 0)
+		goto nodev;
+
+	strcpy(card->driver, "MXC");
+	strcpy(card->shortname, "PMIC-audio");
+	sprintf(card->longname, "MXC Freescale with PMIC");
+
+	err = snd_card_register(card);
+	if (err < 0) {
+		pr_err("Cannot register sound card. Giving up\n");
+		return err;
+	}
+
+	platform_set_drvdata(pdev, card);
+
+	err = snd_imx_create_ctl(card, NULL);
+	if (err < 0 )
+		pr_debug("snd_imx_create_ctl() returns %d!\n", err);
+
+	/* route the SSI unit signals and activate the external SSI pins */
+	if (pdata->init)
+		(pdata->init)(pdev);
+
+	for (i=0; i < IMX_SUPPORTED_SSI_UNITS; i++) {
+		if (pdata->connection[i].cpu_port &&
+				pdata->connection[i].dev_port)
+			dam_configure_sync_slave(imx_card[i].ssi_unit + 1,
+				pdata->connection[i].cpu_port);
+	}
+
+	return 0;
+
+nodev:
+	snd_card_free(card);
+	return err;
+}
+
+static int __devexit snd_imx_remove(struct platform_device *pdev)
+{
+	struct snd_card *card = platform_get_drvdata(pdev);
+
+	snd_card_free(card);
+	platform_set_drvdata(pdev, NULL);
+
+	return 0;
+}
+
+static struct platform_driver imx_sound_driver = {
+	.driver = {
+		.name = DRV_NAME,
+	},
+	.probe = snd_imx_probe,
+	.remove = __devexit_p(snd_imx_remove),
+#ifdef CONFIG_PM
+	.suspend = NULL, /* TODO snd_mxc_audio_suspend */
+	.resume = NULL, /* TODO snd_mxc_audio_resume */
+#endif
+};
+
+
+static int __init imx_sound_init(void)
+{
+	int rc;
+
+	rc = mx2_dam_init();	/* activate DAM related driver part */
+	if (rc != 0)
+		return rc;
+	rc = mx2_ssi_init();	/* activate SSI related driver part */
+	if (rc != 0)
+		return rc;
+	return platform_driver_register(&imx_sound_driver);
+}
+
+static void __exit imx_sound_exit(void)
+{
+	platform_driver_unregister(&imx_sound_driver);
+	mx2_ssi_exit();
+	mx2_dam_exit();
+}
+
+module_init(imx_sound_init);
+module_exit(imx_sound_exit);
+
+MODULE_AUTHOR("FREESCALE SEMICONDUCTOR");
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("MXC driver for ALSA");
diff --git a/sound/arm/imx2-ssi.c b/sound/arm/imx2-ssi.c
new file mode 100644
index 0000000..7d8da20
--- /dev/null
+++ b/sound/arm/imx2-ssi.c
@@ -0,0 +1,447 @@
+/*
+ * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2008 Juergen Beisert, kernel@pengutronix.de
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ *
+ * Note: This implementation was done very close the external PMIC MC13783.
+ * The MC13783 seems like a regular I2S device, but it isn't. It does various
+ * things in a very special way. But also this SSI unit does some things in
+ * very special way. And the datasheet keeps silent.
+ */
+
+#include <linux/platform_device.h>
+#include <linux/interrupt.h>
+#include <linux/clk.h>
+#include <linux/io.h>
+#include <mach/imx_ssi.h>
+#include "imx2-ssi.h"
+
+#define DRV_NAME "mxc-ssi"
+
+struct ssi_private {
+	void __iomem *io;
+	struct platform_device *pdev;
+	struct clk *clk;
+};
+
+/* global data for all SSI units */
+static struct ssi_private unit[2];
+
+/* global access control */
+static spinlock_t ssi_lock;
+
+static void set_reg_bits(unsigned int mask, unsigned int data,
+		unsigned int offset, unsigned int id)
+{
+	u32 reg = 0;
+	unsigned long flags = 0;
+
+	spin_lock_irqsave(&ssi_lock, flags);
+	reg = ioread32(unit[id].io + offset);
+	reg = (reg & (~mask)) | data;
+	iowrite32(reg, unit[id].io + offset);
+	spin_unlock_irqrestore(&ssi_lock, flags);
+}
+
+
+static unsigned long get_reg(unsigned int offset, unsigned int id)
+{
+	u32 reg = 0;
+	unsigned long flags = 0;
+
+	spin_lock_irqsave(&ssi_lock, flags);
+	reg = ioread32(unit[id].io + offset);
+	spin_unlock_irqrestore(&ssi_lock, flags);
+
+	return reg;
+}
+
+static void set_reg(unsigned int data, int offset, unsigned int id)
+{
+	unsigned long flags = 0;
+
+	spin_lock_irqsave(&ssi_lock, flags);
+	iowrite32(data, unit[id].io + offset);
+	spin_unlock_irqrestore(&ssi_lock, flags);
+}
+
+/*
+ * Setup an SSI channel to I2S slave mode.
+ *****************
+ * Note: This setup is for an external MC13783! I guess it will not work
+ * with any other I2S device!
+ *****************
+ *
+ * What we want:
+ * FS:  __################________________##
+ * TX:  ..FEDCBA9876543210FEDCBA9876543210..
+ *             rigth          left
+ * This seems to work only with i2s master mode. Not slave.
+ *
+ * Do not use the i2s slave mode! Its useless, as it only transfers one word
+ * per sync. All other bits to define more than one word will be ignored.
+ * Same with "normal mode" without network. No chance to get it work with an
+ * external standard i2s device.
+ *
+ * Only "normal mode" plus "network mode" will work like an i2s bus.
+ *
+ * In normal + network mode DC determines "Words Per Frame":
+ *             WS=16          DC=2
+ * FS:  __#_______________________________#_
+ * TX:  ..FEDCBA9876543210FEDCBA9876543210..
+ *        |    rigth     ||   left       |
+ *
+ * From the datasheet:
+ * If STFS is configured as input, the external device should drive STFS
+ * during rising edge of STCK or SRCK.
+ *
+ * The external device must provide:
+ * - high active FS for one bit
+ * - new data in falling edge, stable at rising edge
+ *
+ * The receive side. PMIC sends (depends on its setup!):
+ *             WS=16          DC=4
+ * FS:  __#______________________________________________________________#
+ * TX:  ..FEDCBA9876543210FEDCBA9876543210FEDCBA9876543210FEDCBA9876543210..
+ *      --|    rigth     ||   left       |--------------------------------
+ *
+ */
+int setup_channel_to_iis_slave(int id)
+{
+	u32 scr;
+
+	BUG_ON(unit[id].io == NULL);
+
+	pr_debug("%s called for unit %d\n", __func__, id);
+
+	scr = SSI_SCR_SYN | SSI_SCR_NET;
+
+	/* disable this unit */
+	set_reg(scr, SSI_SCR, id);
+
+	set_reg(SSI_STCR_TFEN0 |	/* FIFO 0 enabled */
+		SSI_STCR_TXBIT0 |	/* MSB first, data bits 0...15 are valid */
+		SSI_STCR_TSCKP |	/* send @falling edge */
+		SSI_STCR_TFSL |		/* one-bit-long-frame */
+		SSI_STCR_TEFS,		/* shift */
+		SSI_STCR, id);
+
+	set_reg(SSI_SRCR_RFEN0 |	/* FIFO 0 enabled */
+		SSI_SRCR_RXBIT0 |
+		SSI_SRCR_RSCKP |	/* capture @rising edge */
+		SSI_SRCR_RFSL |		/* one-bit-long-frame */
+		SSI_SRCR_REFS,
+		SSI_SRCR, id);
+
+	/* Used timeslot definitions:        __####____####____####____
+	 * bit 0: first timeslot after sync    ____    ____    ____
+	 * bit 1: second timeslot after sync       ____    ____    ____
+	 */
+	set_reg(0xFFFFFFFC, SSI_STMSK, id);
+	/*
+	 * these RX settings must correspond with the settings in PMIC's
+	 * reg 39 codec time slot settings
+	 */
+	set_reg(0xFFFFFFFC, SSI_SRMSK, id);
+
+	/*
+	 * Watermark settings:
+	 * TX FIFO: Set to 6. This means the request is active if more than
+	 * five FIFO slots are empty. For this case the DMA burst length
+	 * can be up to six words (three samples = six slots)
+	 * RX FIFO: Set to 4. This means the request is active when 4 or more
+	 * slots are in the FIFO.
+	 *
+	 * Note: A word is 8, 16 or 24 bit, a sample is of two
+	 * words (left/right) there
+	 */
+	set_reg(SSI_SFCSR_RFWM0(DMA_RXFIFO_BURST) |
+		SSI_SFCSR_TFWM0(DMA_TXFIFO_BURST), SSI_SFCSR, id);
+
+	/*
+	 * We want to provide I2S. This means we always need two words per
+	 * sample signal. In this case 16 bit per word, 32 bit per sample.
+	 * PMIC sends always 4 words (=2 samples) per sync!
+	 */
+	set_reg(SSI_STCCR_WL(16) | SSI_STCCR_DC(1), SSI_STCCR, id);
+	set_reg(SSI_SRCCR_WL(16) | SSI_SRCCR_DC(3), SSI_SRCCR, id);
+
+	/* enable the unit */
+	set_reg(scr | SSI_SCR_SSIEN, SSI_SCR, id);
+
+	return 0;
+}
+
+/* id: SSI unit, fifo: FIFO 0 or 1 of this unit */
+int imx_get_dma_tx_channel(int id, int fifo)
+{
+	struct resource *res;
+
+	BUG_ON(unit[id].io == NULL);
+
+	if (fifo < 0 || fifo > 1)	/* FIXME maybe i.MX27 specific */
+		return -ENODEV;
+
+	res = platform_get_resource_byname(unit[id].pdev,
+					IORESOURCE_DMA, fifo ? "tx1" : "tx0");
+
+	if (res == NULL)
+		return -1;
+
+	return res->start;
+}
+
+/* return physical address of the FIFO register */
+void __iomem *imx_get_dma_tx_address(int id, int fifo)
+{
+	struct resource *res;
+	void __iomem *adr;
+
+	BUG_ON(unit[id].io == NULL);
+
+	if (fifo < 0 || fifo > 1)	/* FIXME imx27 specific */
+		return NULL;
+
+	res = platform_get_resource(unit[id].pdev, IORESOURCE_MEM, 0);
+
+	if (res == NULL)
+		return NULL;
+
+	adr = (void __iomem *)res->start + (fifo ? SSI_STX1 : SSI_STX0);
+
+	return adr;
+}
+
+/* id: SSI unit, fifo: FIFO 0 or 1 of this unit */
+int imx_get_dma_rx_channel(int id, int fifo)
+{
+	struct resource *res;
+
+	BUG_ON(unit[id].io == NULL);
+
+	if (fifo < 0 || fifo > 1)	/* FIXME imx27 specific */
+		return -ENODEV;
+
+	res = platform_get_resource_byname(unit[id].pdev,
+					IORESOURCE_DMA, fifo ? "rx1" : "rx0");
+
+	if (res == NULL)
+		return -1;
+
+	return res->start;
+}
+
+/* return physical address of the FIFO register */
+void __iomem *imx_get_dma_rx_address(int id, int fifo)
+{
+	struct resource *res;
+	void __iomem *adr;
+
+	BUG_ON(unit[id].io == NULL);
+
+	if (fifo < 0 || fifo > 1)	/* FIXME imx27 specific */
+		return NULL;
+
+	res = platform_get_resource(unit[id].pdev, IORESOURCE_MEM, 0);
+
+	if (res == NULL)
+		return NULL;
+
+	adr = (void __iomem *)res->start + (fifo ? SSI_SRX1 : SSI_SRX0);
+
+	return adr;
+}
+
+void imx_ssi_transmit_enable(int id)
+{
+	pr_debug("%s called\n", __func__);
+
+	BUG_ON(unit[id].io == NULL);
+	set_reg_bits(SSI_SCR_SSIEN, 0, SSI_SCR, id);
+	set_reg_bits(SSI_SIER_TDMAE, SSI_SIER_TDMAE, SSI_SIER, id);
+	set_reg_bits(SSI_SCR_TE, SSI_SCR_TE, SSI_SCR, id);
+	set_reg_bits(SSI_SCR_SSIEN, SSI_SCR_SSIEN, SSI_SCR, id);
+}
+
+void imx_ssi_receive_enable(int id)
+{
+	pr_debug("%s called\n", __func__);
+
+	BUG_ON(unit[id].io == NULL);
+	/* disable unit */
+	set_reg_bits(SSI_SCR_SSIEN, 0, SSI_SCR, id);
+	set_reg_bits(SSI_SIER_RDMAE, SSI_SIER_RDMAE, SSI_SIER, id);
+	/* enable receive */
+	set_reg_bits(SSI_SCR_RE, SSI_SCR_RE, SSI_SCR, id);
+	/* enable unit */
+	set_reg_bits(SSI_SCR_SSIEN, SSI_SCR_SSIEN, SSI_SCR, id);
+}
+
+void imx_ssi_transmit_disable(int id)
+{
+	pr_debug("%s called\n", __func__);
+
+	BUG_ON(unit[id].io == NULL);
+	set_reg_bits(SSI_SCR_SSIEN, 0, SSI_SCR, id);
+	set_reg_bits(SSI_SCR_TE, 0, SSI_SCR, id);
+	/* TODO: do we need a reset here? Or is SCR_TE=0 enough? */
+	set_reg_bits(SSI_SIER_TDMAE, 0, SSI_SIER, id);
+}
+
+
+void imx_ssi_receive_disable(int id)
+{
+	pr_debug("%s called\n", __func__);
+
+	BUG_ON(unit[id].io == NULL);
+	/* disable unit */
+	set_reg_bits(SSI_SCR_SSIEN, 0, SSI_SCR, id);
+	set_reg_bits(SSI_SCR_RE, 0, SSI_SCR, id);
+	set_reg_bits(SSI_SIER_RDMAE, 0, SSI_SIER, id);
+}
+
+/* power up this unit */
+void imx_ssi_enable(int id)
+{
+	pr_debug("%s called\n", __func__);
+
+	BUG_ON(unit[id].io == NULL);
+	set_reg_bits(SSI_SCR_SSIEN, SSI_SCR_SSIEN, SSI_SCR, id);
+}
+
+/* power down this unit */
+void imx_ssi_disable(int id)
+{
+	pr_debug("%s called\n", __func__);
+
+	BUG_ON(unit[id].io == NULL);
+	set_reg_bits(SSI_SCR_SSIEN, 0, SSI_SCR, id);
+}
+
+static int __devinit mx2_iss_probe(struct platform_device *pdev)
+{
+	struct imx_ssi_platform_data *pdata;
+	struct resource *res;
+	int ret, id;
+
+	pdata = pdev->dev.platform_data;
+
+	id = pdev->id;
+	pr_info("Probing i.MX SSI unit %d\n", id);
+
+	if (unit[id].io != NULL)
+		return -EBUSY;
+
+	unit[id].pdev = pdev;
+
+	/* FIXME do it later, when someone wants to play a sound */
+	if (pdata->init)
+		(pdata->init)(pdev);
+
+	unit[id].clk = clk_get(&pdev->dev, "ssi_clk");
+	if (unit[id].clk == NULL) {
+		dev_err(&pdev->dev, "Cannot get the clock for IMX SSI unit %d\n",
+			pdev->id);
+		ret = -ENODEV;
+		goto err1;
+	}
+	/* FIXME do it later, when someone wants to play a sound */
+	ret = clk_enable(unit[id].clk);
+	if (ret != 0) {
+		dev_err(&pdev->dev, "Cannot enable the clock for IMX SSI unit %d\n",
+			pdev->id);
+		ret = -ENODEV;
+		goto err2;
+	}
+
+	/* external clock (if used) should never greater than 1/4 ipg_clk! */
+	pr_debug("Main clock for SSI is: %luHz\n", clk_get_rate(unit[id].clk));
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (res == NULL) {
+		ret = -ENODEV;
+		goto err2;
+	}
+
+	if (!request_mem_region(res->start, res->end - res->start + 1, DRV_NAME)) {
+		dev_err(&pdev->dev, "request_mem_region failed for IMX SSI %d\n",
+			pdev->id);
+		ret = -EBUSY;
+		goto err2;
+	}
+	unit[id].io = ioremap(res->start, res->end - res->start + 1);
+	if (unit[id].io == NULL) {
+		dev_err(&pdev->dev, "Mapping region failed for IMX SSI %d\n",
+			pdev->id);
+		ret = -ENODEV;
+		goto err3;
+	}
+
+	return 0;	/* return happy */
+
+err3:
+	release_mem_region(res->start, res->end - res->start + 1);
+	clk_disable(unit[id].clk);
+err2:
+	clk_put(unit[id].clk);
+err1:
+	if (pdata->exit)
+		(pdata->exit)(pdev);
+	return ret;
+}
+
+static int __devexit mx2_iss_remove(struct platform_device *pdev)
+{
+	struct imx_ssi_platform_data *pdata = pdev->dev.platform_data;
+	struct resource *res;
+	int id;
+
+	id = pdev->id;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	clk_disable(unit[id].clk);
+	clk_put(unit[id].clk);
+	if (pdata->exit)
+		(pdata->exit)(pdev);
+	release_mem_region(res->start, res->end - res->start + 1);
+	iounmap(unit[id].io);
+	unit[id].io = NULL;
+
+	return 0;
+}
+
+static struct platform_driver mx2_iss_driver = {
+	.driver = {
+		.name		= DRV_NAME,
+		.owner		= THIS_MODULE,
+	},
+	.probe		= mx2_iss_probe,
+	.remove		= __devexit_p(mx2_iss_remove),
+#ifdef CONFIG_PM
+	.suspend	= NULL, /* TODO mx2_ssi_suspend */
+	.resume		= NULL	/* TODO mx2_ssi_resume */
+#endif
+};
+
+int __init mx2_ssi_init(void)
+{
+	spin_lock_init(&ssi_lock);
+	return platform_driver_register(&mx2_iss_driver);
+}
+
+void __exit mx2_ssi_exit(void)
+{
+	platform_driver_unregister(&mx2_iss_driver);
+}
diff --git a/sound/arm/imx2-ssi.h b/sound/arm/imx2-ssi.h
new file mode 100644
index 0000000..f28980b
--- /dev/null
+++ b/sound/arm/imx2-ssi.h
@@ -0,0 +1,44 @@
+/*
+ * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2008 Juergen Beisert, kernel@pengutronix.de
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+
+#ifndef __SOUND_ARM_IMX2_SSI_H
+#define __SOUND_ARM_IMX2_SSI_H
+
+extern void imx_ssi_enable(int);
+extern void imx_ssi_disable(int);
+
+extern void imx_ssi_transmit_enable(int);
+extern void imx_ssi_transmit_disable(int);
+extern void imx_ssi_receive_enable(int);
+extern void imx_ssi_receive_disable(int);
+
+extern int imx_get_dma_tx_channel(int, int);
+extern int imx_get_dma_rx_channel(int, int);
+extern void __iomem *imx_get_dma_tx_address(int, int);
+extern void __iomem *imx_get_dma_rx_address(int, int);
+extern int setup_channel_to_iis_slave(int);
+
+/* to handle it like a module */
+extern int mx2_ssi_init(void);
+extern void mx2_ssi_exit(void);
+
+/* possible DMA bursts in FIFO entries */
+#define DMA_TXFIFO_BURST	0x6
+#define DMA_RXFIFO_BURST	0x4
+
+#endif /* __SOUND_ARM_IMX2_SSI_H */
diff --git a/sound/arm/mc13783.c b/sound/arm/mc13783.c
new file mode 100644
index 0000000..b438eb2
--- /dev/null
+++ b/sound/arm/mc13783.c
@@ -0,0 +1,513 @@
+/*
+ * Copyright 2008 Juergen Beisert, kernel@pengutronix.de
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+
+#include <sound/core.h>
+#include <sound/control.h>
+#include <sound/pcm.h>
+
+#include "soc-wrapper.c"
+#include "mc13783.h"
+
+#define PMIC_REG_MODE_0 32
+#define PMIC_AUDIO_RX_0 36
+#define PMIC_AUDIO_RX_1 37
+#define PMIC_AUDIO_TX 38
+#define PMIC_SSI_NETOWRK 39
+#define PMIC_AUDIO_CODEC 40
+#define PMIC_AUDIO_DAC 41
+
+struct mc13783_cache {
+	u32 reg_36;
+	u32 reg_37;
+	u32 reg_38;
+	u32 reg_39;
+	u32 reg_40;
+	u32 reg_41;
+};
+
+/* register cache */
+static struct mc13783_cache regs;
+
+/* counts if the PMIC is in use */
+static int mx13783_active;
+
+/* power up */
+static int mc13783_enable(void)
+{
+	pr_info("%s called\n", __func__);
+
+	if (!mx13783_active) {
+		pr_debug("Audio enabled\n");
+		regs.reg_36 |= 0x1;	/* VAUDIOON -> supply audio part */
+		regs.reg_36 |= 0x2;	/* BIAS enable */
+#if 0
+	/* This crashes the system! */
+		pmic_read(PMIC_REG_MODE_0, &t);
+		t &= 0x07;
+		t |= 0x01;
+		pmic_write(PMIC_REG_MODE_0, t);
+#endif
+		pmic_write(PMIC_AUDIO_RX_0, regs.reg_36);
+		pmic_write(PMIC_AUDIO_RX_1, regs.reg_37);
+		pmic_write(PMIC_AUDIO_TX, regs.reg_38);
+		pmic_write(PMIC_SSI_NETOWRK, regs.reg_39);
+		pmic_write(PMIC_AUDIO_CODEC, regs.reg_40);
+		pmic_write(PMIC_AUDIO_DAC, regs.reg_41);
+	}
+
+	mx13783_active++;	/* one more user */
+
+	return 0;
+}
+
+/* save power */
+static int mc13783_disable(void)
+{
+	pr_info("%s called\n", __func__);
+
+	if (mx13783_active)
+		mx13783_active--;	/* one less user */
+	else
+		return 0;
+
+	if (!mx13783_active) {
+		pr_debug("Audio disabled\n");
+#if 0
+	/* This crashes the system! */
+		pmic_read(PMIC_REG_MODE_0, &t);
+		t &= 0x07;
+		pmic_write(PMIC_REG_MODE_0, t);
+#endif
+		regs.reg_36 &= ~0x1;	/* VAUDIOON -> switch off audio part */
+		regs.reg_36 &= ~0x2;	/* BIAS disable */
+		pmic_write(PMIC_AUDIO_RX_0, regs.reg_36);
+	}
+
+	return 0;
+}
+
+/* channel: SSI1 (=0) or SSI2 (=1) to be used */
+static int mc13783_setup_i2s_master_DAC(int channel, unsigned int rate)
+{
+	pr_debug("%s: Setup channel %d with rate no %u\n", __func__,
+			channel + 1, rate);
+
+	regs.reg_39 |= (3 << 12);	/* two timeslots, TS0 and TS1 */
+	if (channel == 1)
+		/* connect the DAC to SSI pin group 2 */
+		regs.reg_41 |= 1;
+	else
+		/* connect the DAC to SSI pin group 1 */
+		regs.reg_41 &= ~1;
+
+	/* FIXME CLIA is board specific: Here 26MHz */
+	regs.reg_41 &= ~(1 << 1);
+	regs.reg_41 &= ~(1 << 2);	/* DAC is master */
+
+	/* FIXME clock and fs inversion? */
+	regs.reg_41 &= ~(3 << 3);
+
+	/* CLK: 1 = valid@rising, 0 = valid@falling edge -> verified */
+	regs.reg_41 |= (1 << 3);
+	/* FS: 1 = #__######, 0 = _###_____ -> verified */
+	regs.reg_41 |= (0 << 4);
+
+	regs.reg_41 &= ~(0x3 << 5);
+	/* short fs with offset -1 (for network mode) -> verified */
+	regs.reg_41 |= (0x2 << 5);
+
+	regs.reg_41 &= ~(0x7 << 7);
+	regs.reg_41 |= (0x4 << 7);	/* FIXME fixed to 26MHz input */
+	regs.reg_41 |= (1 << 11);	/* DAC power up */
+	regs.reg_41 |= (1 << 12);	/* enable FS and CLK out */
+	regs.reg_41 |= (1 << 15);	/* reset filter */
+
+	/* setup the clock speed */
+	regs.reg_41 &= ~(0xf << 17);
+	regs.reg_41 |= rate << 17;
+
+	pmic_write(PMIC_SSI_NETOWRK, regs.reg_39);
+	pmic_write(PMIC_AUDIO_DAC, regs.reg_41);
+
+	return 0;
+}
+
+/* channel: SSI1 (=0) or SSI2 (=1) to be used */
+static int mc13783_setup_i2s_master_CODEC(int channel, unsigned int rate)
+{
+	pr_debug("%s: Setup channel %d with rate no %u\n", __func__,
+			channel + 1, rate);
+
+	regs.reg_39 &= ~(0xFFF << 0);
+	regs.reg_39 |= (0x00 << 2);	/* primary timeslot RX/TX(?) is 0 */
+	regs.reg_39 |= (0x01 << 4);	/* secondary timeslot TX is 1 */
+	regs.reg_39 |= (0x01 << 6);	/* secondary timeslot RX is 1 */
+
+	if (channel == 1)
+		/* connect the CODEC to SSI pin group 2 */
+		regs.reg_40 |= 1;
+	else
+		/* connect the CODEC to SSI pin group 1 */
+		regs.reg_40 &= ~1;
+
+	regs.reg_40 &= ~(1 << 1);	/* CLIA is board specific: Here 26MHz */
+	regs.reg_40 &= ~(1 << 2);	/* CODEC is master */
+
+	/* FIXME clock and fs inversion? */
+	regs.reg_40 &= ~(3 << 3);
+
+	/* CLK: 1 = valid@rising, 0 = valid@falling edge -> verified */
+	regs.reg_40 |= (1 << 3);
+	/* FS: 1 = #__######, 0 = _###_____ -> verified */
+	regs.reg_40 |= (0 << 4);
+
+	regs.reg_40 &= ~(0x3 << 5);
+	/*
+	 * PMIC always generates 4 time slots per sync.
+	 * So 8kHz sample rate uses a 512kHz clock,
+	 * and 16kHz uses a 10.24kHz clock.
+	 * With a long fs only the first timeslot contains data.
+	 * With a short fs it uses the first two timeslots.
+	 */
+	/* short fs with offset -1 (for network mode) -> verified */
+	regs.reg_40 |= (0x01 << 5);
+
+	regs.reg_40 &= ~(0x7 << 7);
+	/* fixed to 26MHz input FIXME: platform_info */
+	regs.reg_40 |= (0x4 << 7);
+
+	regs.reg_40 |= (1 << 11);	/* CODEC power up */
+	regs.reg_40 |= (1 << 12);	/* enable FS and CLK out */
+	regs.reg_40 &= ~(1 << 13);	/* activate FS and CLK out */
+	regs.reg_40 |= (1 << 15);	/* reset filter */
+	regs.reg_40 &= ~(1 << 16);	/* CODEC not bypassed */
+	regs.reg_40 &= ~(1 << 17);	/* disable CODEC's analog loopback */
+	regs.reg_40 &= ~(1 << 18);	/* disable CODEC's digital loopback */
+
+	/* setup the clock speed */
+
+	switch (rate) {
+	case 0:
+		regs.reg_40 &= ~(1 << 10);
+		break;
+	case 1:
+		regs.reg_40 |= (1 << 10);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	pmic_write(PMIC_SSI_NETOWRK, regs.reg_39);
+	pmic_write(PMIC_AUDIO_CODEC, regs.reg_40);
+
+	return 0;
+}
+
+/* sample rates supported by PMIC for stereo playback operations on StDac. */
+static unsigned int mc13783_rates[] = {
+	8000, 11025, 12000, 16000,
+	22050, 24000, 32000,44100,
+	48000, 64000, 96000
+};
+
+int mc13783_pcm_hw_params(struct snd_pcm_substream *substream,
+	struct snd_pcm_hw_params *params)
+{
+	unsigned int rate = params_rate(params);
+	int i;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		for (i = 0; i < ARRAY_SIZE(mc13783_rates); i++) {
+			if (rate == mc13783_rates[i]) {
+				mc13783_setup_i2s_master_DAC(0, i);
+				return 0;
+			}
+		}
+	} else {
+		mc13783_setup_i2s_master_CODEC(1, rate == 8000 ? 0 : 1);
+		return 0;
+	}
+
+	return -EINVAL;
+}
+
+/* setup reset behaviour */
+static int mc13783_init(void)
+{
+	pr_debug("%s called\n", __func__);
+
+	/* these are the reset values */
+	regs.reg_36 = 0x001000;
+	regs.reg_37 = 0x00D35A;
+	regs.reg_38 = 0x420000;
+	regs.reg_39 = 0x013060;
+	regs.reg_40 = 0x180027;
+	regs.reg_41 = 0x0E0004;
+
+	pmic_write(PMIC_AUDIO_RX_0, regs.reg_36);
+	pmic_write(PMIC_AUDIO_RX_1, regs.reg_37);
+	pmic_write(PMIC_AUDIO_TX, regs.reg_38);
+	pmic_write(PMIC_SSI_NETOWRK, regs.reg_39);
+	pmic_write(PMIC_AUDIO_CODEC, regs.reg_40);
+	pmic_write(PMIC_AUDIO_DAC, regs.reg_41);
+
+	return 0;
+}
+
+static int mc13783_asp_val;
+
+static int mc13783_get_asp(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	ucontrol->value.integer.value[0] = mc13783_asp_val;
+	return 0;
+}
+
+static int mc13783_put_asp(struct snd_kcontrol *kcontrol,
+        struct snd_ctl_elem_value *ucontrol)
+{
+	printk("%s %ld\n", __func__, ucontrol->value.integer.value[0]);
+
+	mc13783_asp_val = ucontrol->value.integer.value[0];
+//	mc13783_put(3, 4, mc13783_asp_val);
+
+	return 0;
+}
+
+static int mc13783_alsp_val;
+
+static int mc13783_get_alsp(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	ucontrol->value.integer.value[0] = mc13783_alsp_val;
+	return 0;
+}
+
+static int mc13783_put_alsp(struct snd_kcontrol *kcontrol,
+        struct snd_ctl_elem_value *ucontrol)
+{
+	printk("%s %ld\n", __func__, ucontrol->value.integer.value[0]);
+
+	mc13783_alsp_val = ucontrol->value.integer.value[0];
+//	mc13783_put(5, 7, mc13783_alsp_val);
+
+	return 0;
+}
+
+static int mc13783_pcm_get(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	int val;
+
+	pmic_read(36, &val);
+	ucontrol->value.enumerated.item[0] = (val >> 22) & 1;
+
+        return 0;
+}
+
+static int mc13783_pcm_put(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	unsigned int r36, r37;
+
+	pmic_read(36, &r36);
+	pmic_read(37, &r37);
+
+	r36 &= ~(1 << 22);
+	r37 &= ~(1 << 5);
+
+	if (ucontrol->value.enumerated.item[0]) {
+		r36 |= (1 << 22);
+		r37 |= (1 << 5);
+	} else {
+		r36 &= ~(1 << 22);
+		r37 &= ~(1 << 5);
+	}
+
+	pmic_write(36, r36);
+	pmic_write(37, r37);
+
+        return 0;
+}
+
+static int mc13783_linein_get(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	int val;
+
+	pmic_read(36, &val);
+	ucontrol->value.enumerated.item[0] = (val >> 23) & 1;
+
+        return 0;
+}
+
+static int mc13783_linein_put(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	unsigned int r36, r37;
+
+	pmic_read(36, &r36);
+	pmic_read(37, &r37);
+
+	r36 &= ~(1 << 23);
+	r37 &= ~(1 << 10);
+
+	if (ucontrol->value.enumerated.item[0]) {
+		r36 |= (1 << 23);
+		r37 |= (1 << 10);
+	} else {
+		r36 &= ~(1 << 23);
+		r37 &= ~(1 << 10);
+	}
+
+	pmic_write(36, r36);
+	pmic_write(37, r37);
+
+        return 0;
+}
+
+static int mc13783_capure_cache;
+
+static int mc13783_get_capture(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	printk("%s: %d\n", __func__, mc13783_capure_cache);
+	ucontrol->value.enumerated.item[0] = mc13783_capure_cache;
+        return 0;
+}
+
+#define AMC1REN (1 << 5)
+#define AMC2EN  (1 << 9)
+#define ATXINEN (1 << 11)
+#define RXINREC (1 << 13)
+#define AMC1LEN (1 << 7)
+
+static int mc13783_put_capture(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	unsigned int r38, change;
+
+	pmic_read(38, &r38);
+
+	change = (mc13783_capure_cache != ucontrol->value.enumerated.item[0]);
+	mc13783_capure_cache = ucontrol->value.enumerated.item[0];
+	r38 &= ~(AMC1REN | AMC2EN | ATXINEN | RXINREC | AMC1LEN);
+	printk("%s: %d\n", __func__, mc13783_capure_cache);
+	switch (mc13783_capure_cache) {
+	case 0:
+		break;
+	case 1:
+		r38 |= RXINREC;
+		break;
+	case 2:
+		r38 |= AMC1REN | AMC1LEN;
+		break;
+	case 3:
+		r38 |= AMC1REN;
+		break;
+	case 4:
+		r38 |= AMC2EN;
+		break;
+	case 5:
+		r38 |= AMC1LEN | AMC2EN;
+		break;
+	case 6:
+		r38 |= ATXINEN;
+		break;
+	case 7:
+		r38 |= AMC1LEN | ATXINEN;
+		break;
+	case 8:
+		r38 |= AMC1LEN | RXINREC;
+		break;
+	case 9:
+		r38 |= AMC1LEN;
+		break;
+	default:
+		break;
+	}
+
+	pmic_write(38, r38);
+
+	return change;
+}
+
+static const char *mc13783_asp[] = {"Off", "Codec", "Right"};
+static const char *mc13783_alsp[] = {"Off", "Codec", "Right"};
+
+static const char *mc13783_ahs[] = {"Codec", "Mixer"};
+
+static const char *mc13783_arxout[] = {"Codec", "Mixer"};
+
+static const char *mc13783_capture[] = {"off/off", "rxinl/rxinr",
+	"mc1lin/mc1rin", "off/mc1rin", "off/mc2in", "mc1lin/mc2in",
+	"off/txin", "mc1lin/txin", "mc1lin/rxinr", "mc1lin/off"};
+
+static const char *mc13783_3d_mixer[] = {"Stereo", "Phase Mix", "Mono", "Mono Mix"};
+
+static const struct soc_enum mc13783_enum[] = {
+	SOC_ENUM_SINGLE_EXT(ARRAY_SIZE(mc13783_asp), mc13783_asp),
+	SOC_ENUM_SINGLE_EXT(ARRAY_SIZE(mc13783_alsp), mc13783_alsp),
+
+	SOC_ENUM_SINGLE(36, 11, ARRAY_SIZE(mc13783_ahs), mc13783_ahs),
+	SOC_ENUM_SINGLE(36, 17, ARRAY_SIZE(mc13783_arxout), mc13783_arxout),
+
+	SOC_ENUM_SINGLE_EXT(ARRAY_SIZE(mc13783_capture), mc13783_capture),
+	SOC_ENUM_SINGLE(37, 16, ARRAY_SIZE(mc13783_3d_mixer), mc13783_3d_mixer),
+};
+
+static struct snd_kcontrol_new mc13783_control_list[] = {
+	/* Output Routing */
+	SOC_ENUM_EXT("Asp Source", mc13783_enum[0], mc13783_get_asp, mc13783_put_asp),
+	SOC_ENUM_EXT("Alsp Source", mc13783_enum[1], mc13783_get_alsp, mc13783_put_alsp),
+	SOC_ENUM("Ahs Source", mc13783_enum[2]),
+	SOC_SINGLE("Ahsr enable", 36, 9, 1, 0),
+	SOC_SINGLE("Ahsl enable", 36, 10, 1, 0),
+	SOC_ENUM("Arxout Source", mc13783_enum[3]),
+	SOC_SINGLE("ArxoutR enable", 36, 16, 1, 0),
+	SOC_SINGLE("ArxoutL enable", 36, 15, 1, 0),
+	SOC_SINGLE_EXT("PCM Playback Switch", 0, 0, 1, 0, mc13783_pcm_get, mc13783_pcm_put),
+	SOC_SINGLE("PCM Playback Volume", 37, 6, 15, 0),
+	SOC_SINGLE_EXT("Line in Switch", 0, 0, 1, 0, mc13783_linein_get, mc13783_linein_put),
+	SOC_SINGLE("Line in Volume", 37, 12, 15, 0),
+	SOC_ENUM_EXT("Capture Source", mc13783_enum[4], mc13783_get_capture, mc13783_put_capture),
+	SOC_DOUBLE("PCM Capture Volume", 38, 19, 14, 31, 0),
+	SOC_ENUM("3D Control - Switch", mc13783_enum[5]),
+};
+
+int __devinit snd_imx_create_ctl(struct snd_card *card, void *p_value)
+{
+	int err, i;
+
+	pr_debug("%s called\n", __FUNCTION__);
+
+	mc13783_init();
+	mc13783_enable();
+
+	for (i=0; i < ARRAY_SIZE(mc13783_control_list); i++) {
+		err = snd_ctl_add(card,
+			snd_ctl_new1(&mc13783_control_list[i], p_value));
+		if (err < 0) {
+			pr_debug("Cannot register %s\n",
+				mc13783_control_list[i].name);
+			return err;
+		}
+		pr_debug("%s registered\n", mc13783_control_list[i].name);
+	}
+	return 0;	/* return happy */
+}
+
diff --git a/sound/arm/mc13783.h b/sound/arm/mc13783.h
new file mode 100644
index 0000000..f1cd113
--- /dev/null
+++ b/sound/arm/mc13783.h
@@ -0,0 +1,26 @@
+/*
+ * Copyright 2008 Juergen Beisert, kernel@pengutronix.de
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+
+#ifndef MC13783_MIXER_H
+#define MC13783_MIXER_H
+
+extern int snd_imx_create_ctl(struct snd_card*, void *);
+
+extern int mc13783_pcm_hw_params(struct snd_pcm_substream *substream,
+	struct snd_pcm_hw_params *params);
+
+#endif /* MC13783_MIXER_H */
diff --git a/sound/arm/soc-wrapper.c b/sound/arm/soc-wrapper.c
new file mode 100644
index 0000000..e53043c
--- /dev/null
+++ b/sound/arm/soc-wrapper.c
@@ -0,0 +1,236 @@
+
+#define SOC_SHIFT_LEFT		8
+#define SOC_SHIFT_RIGHT		13
+#define SOC_SHIFT_MAX		18
+#define SOC_SHIFT_INVERT	26
+
+#define SOC_ENUM_EXT(xname, xenum, xhandler_get, xhandler_put) \
+{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \
+	.info = snd_soc_info_enum_ext, \
+	.get = xhandler_get, .put = xhandler_put, \
+	.private_value = (unsigned long)&xenum }
+
+#define SOC_ENUM_SINGLE_EXT(xmask, xtexts) \
+{	.mask = xmask, .texts = xtexts }
+
+#define SOC_ENUM(xname, xenum) \
+{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname,\
+	.info = snd_soc_info_enum_double, \
+	.get = snd_soc_get_enum_double, .put = snd_soc_put_enum_double, \
+	.private_value = (unsigned long)&xenum }
+
+#define SOC_ENUM_DOUBLE(xreg, xshift_l, xshift_r, xmask, xtexts) \
+{	.reg = xreg, .shift_l = xshift_l, .shift_r = xshift_r, \
+	.mask = xmask, .texts = xtexts }
+#define SOC_ENUM_SINGLE(xreg, xshift, xmask, xtexts) \
+	SOC_ENUM_DOUBLE(xreg, xshift, xshift, xmask, xtexts)
+
+#define SOC_SINGLE_VALUE(reg, shift, max, invert) ((reg) | ((shift) << SOC_SHIFT_LEFT) |\
+	((shift) << SOC_SHIFT_RIGHT) | ((max) << SOC_SHIFT_MAX) | ((invert) << SOC_SHIFT_INVERT))
+
+#define SOC_DOUBLE(xname, reg, shift_left, shift_right, max, invert) \
+{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = (xname),\
+	.info = snd_soc_info_volsw, .get = snd_soc_get_volsw, \
+	.put = snd_soc_put_volsw, \
+	.private_value = (reg) | ((shift_left) << SOC_SHIFT_LEFT) | \
+		((shift_right) << SOC_SHIFT_RIGHT) | ((max) << SOC_SHIFT_MAX) | ((invert) << SOC_SHIFT_INVERT) }
+
+#define SOC_SINGLE_EXT(xname, xreg, xshift, xmask, xinvert,\
+	 xhandler_get, xhandler_put) \
+{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \
+	.info = snd_soc_info_volsw, \
+	.get = xhandler_get, .put = xhandler_put, \
+	.private_value = SOC_SINGLE_VALUE(xreg, xshift, xmask, xinvert) }
+
+#define SOC_SINGLE(xname, reg, shift, max, invert) \
+{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \
+	.info = snd_soc_info_volsw, .get = snd_soc_get_volsw,\
+	.put = snd_soc_put_volsw, \
+	.private_value =  SOC_SINGLE_VALUE(reg, shift, max, invert) }
+
+struct soc_enum {
+	unsigned short reg;
+	unsigned short reg2;
+	unsigned char shift_l;
+	unsigned char shift_r;
+	unsigned int mask;
+	const char **texts;
+	void *dapm;
+};
+
+extern int pmic_read(int reg_num, unsigned int *reg_val);
+extern int pmic_write(int reg_num, const unsigned int reg_val);
+
+static unsigned int snd_soc_read(int reg)
+{
+	unsigned int val;
+
+	pmic_read(reg, &val);
+
+	return val;
+}
+
+static void snd_soc_write(int reg, int val)
+{
+	pmic_write(reg, val);
+}
+
+static int snd_soc_info_enum_ext(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_info *uinfo)
+{
+	struct soc_enum *e = (struct soc_enum *)kcontrol->private_value;
+
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
+	uinfo->count = 1;
+	uinfo->value.enumerated.items = e->mask;
+
+	if (uinfo->value.enumerated.item > e->mask - 1)
+		uinfo->value.enumerated.item = e->mask - 1;
+	strcpy(uinfo->value.enumerated.name,
+		e->texts[uinfo->value.enumerated.item]);
+	return 0;
+}
+
+static int snd_soc_info_volsw(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_info *uinfo)
+{
+	int max = (kcontrol->private_value >> SOC_SHIFT_MAX) & 0xff;
+	int shift = (kcontrol->private_value >> SOC_SHIFT_LEFT) & 0x1f;
+	int rshift = (kcontrol->private_value >> SOC_SHIFT_RIGHT) & 0x1f;
+
+	if (max == 1)
+		uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+	else
+		uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+
+	uinfo->count = shift == rshift ? 1 : 2;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = max;
+	return 0;
+}
+
+static int snd_soc_get_volsw(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	int reg = kcontrol->private_value & 0xff;
+	int shift = (kcontrol->private_value >> SOC_SHIFT_LEFT) & 0x1f;
+	int rshift = (kcontrol->private_value >> SOC_SHIFT_RIGHT) & 0x1f;
+	int max = (kcontrol->private_value >> SOC_SHIFT_MAX) & 0xff;
+	int mask = (1 << fls(max)) - 1;
+	int invert = (kcontrol->private_value >> SOC_SHIFT_INVERT) & 0x01;
+
+	ucontrol->value.integer.value[0] =
+		(snd_soc_read(reg) >> shift) & mask;
+	if (shift != rshift)
+		ucontrol->value.integer.value[1] =
+			(snd_soc_read(reg) >> rshift) & mask;
+	if (invert) {
+		ucontrol->value.integer.value[0] =
+			max - ucontrol->value.integer.value[0];
+		if (shift != rshift)
+			ucontrol->value.integer.value[1] =
+				max - ucontrol->value.integer.value[1];
+	}
+
+	return 0;
+}
+
+static int snd_soc_update_bits(unsigned short reg,
+				unsigned int mask, unsigned int value)
+{
+	int change;
+	unsigned int old, new;
+
+//	mutex_lock(&io_mutex);
+	old = snd_soc_read(reg);
+	new = (old & ~mask) | value;
+	change = old != new;
+	if (change)
+		snd_soc_write(reg, new);
+
+//	mutex_unlock(&io_mutex);
+	return change;
+}
+
+static int snd_soc_put_volsw(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	int reg = kcontrol->private_value & 0xff;
+	int shift = (kcontrol->private_value >> SOC_SHIFT_LEFT) & 0x1f;
+	int rshift = (kcontrol->private_value >> SOC_SHIFT_RIGHT) & 0x1f;
+	int max = (kcontrol->private_value >> SOC_SHIFT_MAX) & 0xff;
+	int mask = (1 << fls(max)) - 1;
+	int invert = (kcontrol->private_value >> SOC_SHIFT_INVERT) & 0x01;
+	unsigned int val, val2, val_mask;
+
+	val = (ucontrol->value.integer.value[0] & mask);
+	if (invert)
+		val = max - val;
+	val_mask = mask << shift;
+	val = val << shift;
+	if (shift != rshift) {
+		val2 = (ucontrol->value.integer.value[1] & mask);
+		if (invert)
+			val2 = max - val2;
+		val_mask |= mask << rshift;
+		val |= val2 << rshift;
+	}
+	return snd_soc_update_bits(reg, val_mask, val);
+}
+
+static int snd_soc_info_enum_double(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_info *uinfo)
+{
+	struct soc_enum *e = (struct soc_enum *)kcontrol->private_value;
+
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
+	uinfo->count = e->shift_l == e->shift_r ? 1 : 2;
+	uinfo->value.enumerated.items = e->mask;
+
+	if (uinfo->value.enumerated.item > e->mask - 1)
+		uinfo->value.enumerated.item = e->mask - 1;
+	strcpy(uinfo->value.enumerated.name,
+		e->texts[uinfo->value.enumerated.item]);
+	return 0;
+}
+
+static int snd_soc_get_enum_double(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct soc_enum *e = (struct soc_enum *)kcontrol->private_value;
+	unsigned int val, bitmask;
+
+	for (bitmask = 1; bitmask < e->mask; bitmask <<= 1)
+		;
+	val = snd_soc_read(e->reg);
+	ucontrol->value.enumerated.item[0]
+		= (val >> e->shift_l) & (bitmask - 1);
+	if (e->shift_l != e->shift_r)
+		ucontrol->value.enumerated.item[1] =
+			(val >> e->shift_r) & (bitmask - 1);
+
+	return 0;
+}
+
+static int snd_soc_put_enum_double(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct soc_enum *e = (struct soc_enum *)kcontrol->private_value;
+	unsigned int val;
+	unsigned int mask, bitmask;
+
+	for (bitmask = 1; bitmask < e->mask; bitmask <<= 1)
+		;
+	if (ucontrol->value.enumerated.item[0] > e->mask - 1)
+		return -EINVAL;
+	val = ucontrol->value.enumerated.item[0] << e->shift_l;
+	mask = (bitmask - 1) << e->shift_l;
+	if (e->shift_l != e->shift_r) {
+		if (ucontrol->value.enumerated.item[1] > e->mask - 1)
+			return -EINVAL;
+		val |= ucontrol->value.enumerated.item[1] << e->shift_r;
+		mask |= (bitmask - 1) << e->shift_r;
+	}
+
+	return snd_soc_update_bits(e->reg, mask, val);
+}
-- 
1.5.5.1

