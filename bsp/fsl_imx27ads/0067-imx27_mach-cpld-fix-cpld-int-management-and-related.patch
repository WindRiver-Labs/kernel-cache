From 2b6b55739b63dda13b968a6c25a0f95a676bd452 Mon Sep 17 00:00:00 2001
From: Wang Hui <Hui.Wang@windriver.com>
Date: Wed, 27 May 2009 09:58:48 +0800
Subject: [PATCH] imx27_mach/cpld: fix cpld int management and related device init code

Rework CPLD interrupt management functions.
Based on new CPLD interrupt management, adding SD/MMC insert
and readonly detect functions.
Based on new CPLD interrupt management, adding 8250 serial
support.

Original patch taken from rev C1 board support ISO image for imx27ads.
imx27_ads_20071219-rel3-ltib.iso in product CD.

Signed-off-by: Wang Hui <Hui.Wang@windriver.com>
---
 arch/arm/mach-mx2/mx27ads.c |  211 +++++++++++++++++++++++++++++++++++++++----
 1 files changed, 194 insertions(+), 17 deletions(-)

diff --git a/arch/arm/mach-mx2/mx27ads.c b/arch/arm/mach-mx2/mx27ads.c
index 1385fe2..bbe5f0e 100644
--- a/arch/arm/mach-mx2/mx27ads.c
+++ b/arch/arm/mach-mx2/mx27ads.c
@@ -34,6 +34,7 @@
 #include <linux/clk.h>
 #include <media/soc_camera.h>
 #include <linux/video_encoder.h> 
+#include <linux/serial_8250.h>
 
 #include <asm/mach-types.h>
 #include <asm/mach/arch.h>
@@ -64,6 +65,7 @@
 #include <mach/imx_cam.h>
 
 #include "devices.h"
+static int mxc_card_status;
 
 /* ADS's NOR flash */
 static struct mtd_partition mxc_nor_partitions[] = {
@@ -231,25 +233,93 @@ unsigned int cs8900_irq_map[] = { CS8900AIRQ, 0, 0, 0 };
 EXPORT_SYMBOL(cs8900_irq_map);
 #endif
 
+static const int pbc_card_bit[4][3] = {
+	/* BSTAT            IMR enable       IMR removal */
+	{PBC_BSTAT_SD2_DET, PBC_INTR_SD2_EN, PBC_INTR_SD2_R_EN},
+	{PBC_BSTAT_SD3_DET, PBC_INTR_SD3_EN, PBC_INTR_SD3_R_EN},
+	{PBC_BSTAT_MS_DET, PBC_INTR_MS_EN, PBC_INTR_MS_R_EN},
+	{PBC_BSTAT_SD1_DET, PBC_INTR_SD1_EN, PBC_INTR_SD1_R_EN},
+};
+
+/*!
+ * Check if a SD card has been inserted or not.
+ *
+ * @param  num		a card number as defined in \b enum \b mxc_card_no
+ * @return 0 if a card is not present; non-zero otherwise.
+ */
+int mxc_card_detected(enum mxc_card_no num)
+{
+	u32 status;
+
+	status = __raw_readw(PBC_BSTAT1_REG);
+	return ((status & MXC_BSTAT_BIT(num)) == 0);
+}
+
+
+/*
+ * Check if there is any state change by reading the IMR register and the
+ * previous and current states of the board status register (offset 0x28).
+ * A state change is defined to be card insertion OR removal. So the driver
+ * may have to call the mxc_card_detected() function to see if it is card
+ * insertion or removal.
+ *
+ * @param  mask		current IMR value
+ * @param  s0		previous status register value (offset 0x28)
+ * @param  s1		current status register value (offset 0x28)
+ *
+ * @return 0 if no card status change OR the corresponding bits in the IMR
+ *           (passed in as 'mask') is NOT set.
+ *         A non-zero value indicates some card state changes. For example,
+ *         0b0001 means SD3 has a card state change (bit0 is set) AND its
+ *               associated insertion or removal bits in IMR is SET.
+ *         0b0100 means SD1 has a card state change (bit2 is set) AND its
+ *               associated insertion or removal bits in IMR is SET.
+ *         0b1001 means both MS and SD3 have state changes
+ */
+static u32 mxc_card_state_changed(u32 mask, u32 s0, u32 s1)
+{
+	u32 i, retval = 0;
+	u32 stat = (s0 ^ s1) & 0x7800;
+
+	if (stat == 0)
+		return 0;
+
+	for (i = MXC_CARD_MIN; i <= MXC_CARD_MAX; i++) {
+		if ((stat & pbc_card_bit[i][0]) != 0 &&
+		    (mask & (pbc_card_bit[i][1] | pbc_card_bit[i][2])) != 0) {
+			retval |= 1 << i;
+		}
+	}
+
+	return retval;
+}
+
 /*!
  * Interrupt handler for the expio (CPLD) to deal with interrupts from
  * FEC, external UART, CS8900 Ethernet and SD cards, etc.
  */
 static void mxc_expio_irq_handler(u32 irq, struct irq_desc *desc)
 {
-	u32 imr;
+	u32 imr, card_int;
 	u32 int_valid;
 	u32 expio_irq;
+	u32 stat = __raw_readw(PBC_BSTAT1_REG);
 
 	desc->chip->mask(irq);	/* irq = gpio irq number */
 
 	imr = __raw_readw(PBC_INTMASK_SET_REG);
 
+	card_int = mxc_card_state_changed(imr, mxc_card_status, stat);
+	mxc_card_status = stat;
 	/* Bits defined in PBC_INTSTATUS_REG at 0x2C */
 	int_valid = __raw_readw(PBC_INTSTATUS_REG) & imr;
+	/*  combined with the card interrupt valid information */
+	int_valid = (int_valid & 0x0F8E) | (card_int << PBC_INTR_SD2_EN_BIT);
 
-	if (unlikely(!int_valid))
+	if (unlikely(!int_valid)) {
+		pr_info("CPLD IMR(0x38)=0x%x, BSTAT1(0x28)=0x%x\n", imr, stat);
 		goto out;
+	}
 
 	expio_irq = MXC_EXP_IO_BASE;
 	for (; int_valid != 0; int_valid >>= 1, expio_irq++) {
@@ -272,8 +342,23 @@ static void expio_mask_irq(u32 irq)
 	u32 expio = MXC_IRQ_TO_EXPIO(irq);
 
 	/* mask the interrupt */
-	__raw_writew(1 << expio, PBC_INTMASK_CLEAR_REG);
-	__raw_readw(PBC_INTMASK_CLEAR_REG);
+	if (irq < EXPIO_INT_SD2_EN) {
+		__raw_writew(1 << expio, PBC_INTMASK_CLEAR_REG);
+	} else {
+		irq -= EXPIO_INT_SD2_EN;
+		/* clear both SDx_EN and SDx_R_EN bits */
+		__raw_writew((pbc_card_bit[irq][1] | pbc_card_bit[irq][2]),
+			     PBC_INTMASK_CLEAR_REG);
+	}
+}
+
+
+static void expio_disable_irq(u32 irq)
+{
+	struct irq_desc *desc = irq_desc + (IRQ_GPIOC((PC15_PF_TIN & GPIO_PIN_MASK)));
+
+	expio_mask_irq(irq);
+	desc->chip->ack((IRQ_GPIOC((PC15_PF_TIN & GPIO_PIN_MASK))));
 }
 
 /*
@@ -285,7 +370,10 @@ static void expio_ack_irq(u32 irq)
 	u32 expio = MXC_IRQ_TO_EXPIO(irq);
 
 	/* clear the interrupt status */
-	__raw_writew(1 << expio, PBC_INTSTATUS_REG);
+	if(irq >= EXPIO_INT_LOW_BAT && irq <= EXPIO_INT_FSH_OVR) {
+		__raw_writew(1 << expio, PBC_INTSTATUS_REG);
+		__raw_readw(PBC_INTSTATUS_REG);
+	}
 }
 
 /*
@@ -297,18 +385,54 @@ static void expio_unmask_irq(u32 irq)
 	u32 expio = MXC_IRQ_TO_EXPIO(irq);
 
 	/* unmask the interrupt */
-	__raw_writew(1 << expio, PBC_INTMASK_SET_REG);
+	if (irq < EXPIO_INT_SD2_EN) {
+		if (irq == EXPIO_INT_XUART_INTA) {
+			/* Set 8250 MCR register bit 3 - Forces the INT (A-B
+			 * outputs to the active mode and sets OP2 to logic 0.
+			 * This is needed to avoid spurious int caused by the
+			 * internal CPLD pull-up for the interrupt pin.
+			 */
+			u16 val = __raw_readw(MXC_LL_EXTUART_VADDR + 8);
+			__raw_writew(val | 0x8, MXC_LL_EXTUART_VADDR + 8);
+		}
+		__raw_writew(1 << expio, PBC_INTMASK_SET_REG);
+	} else {
+		irq -= EXPIO_INT_SD2_EN;
+
+		if (mxc_card_detected(irq)) {
+			__raw_writew(pbc_card_bit[irq][2], PBC_INTMASK_SET_REG);
+		} else {
+			__raw_writew(pbc_card_bit[irq][1], PBC_INTMASK_SET_REG);
+		}
+	}
 }
 
 static struct irq_chip expio_irq_chip = {
 	.ack = expio_ack_irq,
 	.mask = expio_mask_irq,
 	.unmask = expio_unmask_irq,
+	.disable = expio_disable_irq,
 };
 
 static int __init mx2_expio_init(void)
 {
-	int i;
+	int i, ver;
+
+	ver = (__raw_readw(PBC_VERSION_REG) >> 8) & 0xFF;
+	if ((ver & 0x80) != 0) {
+		pr_info("MX27 ADS EXPIO(CPLD) hardware\n");
+		pr_info("CPLD version: 0x%x\n", ver);
+	} else {
+		ver &= 0x0F;
+		pr_info("MX27 EVB EXPIO(CPLD) hardware\n");
+		if (ver == 0xF || ver <= MXC_CPLD_VER_1_50)
+			pr_info("Wrong CPLD version: %d\n", ver);
+		else {
+			pr_info("CPLD version: %d\n", ver);
+		}
+	}
+
+	mxc_card_status = __raw_readw(PBC_BSTAT1_REG);
 
 	/*
 	 * Configure INT line as GPIO input
@@ -555,13 +679,11 @@ static int mx27ads_sdhc1_init(struct device *dev, irq_handler_t detect_irq, void
         if(ret)
                 return ret;
 
-        ret = request_irq(IRQ_GPIOE(21), detect_irq, 0,
+        ret = request_irq(EXPIO_INT_SD1_EN, detect_irq, 0,
                                 "imx-mmc-detect", data);
         if (ret)
                 goto out_release_gpio;
 
-        set_irq_type(IRQ_GPIOE(21), IRQF_TRIGGER_RISING);
-
         return 0;
 
 out_release_gpio:
@@ -589,13 +711,11 @@ static int mx27ads_sdhc2_init(struct device *dev, irq_handler_t detect_irq, void
 	if(ret)
 		return ret;
 
-	ret = request_irq(IRQ_GPIOB(7), detect_irq, 0,
+	ret = request_irq(EXPIO_INT_SD2_EN, detect_irq, 0,
 				"imx-mmc-detect", data);
 	if (ret)
 		goto out_release_gpio;
 
-	set_irq_type(IRQ_GPIOB(7), IRQF_TRIGGER_RISING);
-
 	return 0;
 
 out_release_gpio:
@@ -613,7 +733,7 @@ static void mx27ads_sdhc1_exit(struct device *dev, void *data)
 			ARRAY_SIZE(mx27ads_sdhc1_pins),
 			MXC_GPIO_ALLOC_MODE_RELEASE,
 			"sdhc1");
-	free_irq(IRQ_GPIOB(7), data);
+	free_irq(EXPIO_INT_SD1_EN, data);
 }
 
 static void mx27ads_sdhc2_exit(struct device *dev, void *data)
@@ -622,17 +742,29 @@ static void mx27ads_sdhc2_exit(struct device *dev, void *data)
                         ARRAY_SIZE(mx27ads_sdhc2_pins),
                         MXC_GPIO_ALLOC_MODE_RELEASE,
                         "sdhc2");
-        free_irq(IRQ_GPIOE(21), data);
+        free_irq(EXPIO_INT_SD2_EN, data);
+}
+
+static int mx27ads_sdhc1_get_ro(struct device *dev)
+{
+	return  (__raw_readw(PBC_BSTAT1_REG) & PBC_BSTAT_SD1_WP) != 0;
+}
+
+static int mx27ads_sdhc2_get_ro(struct device *dev)
+{
+	return  (__raw_readw(PBC_BSTAT1_REG) & PBC_BSTAT_SD2_WP) != 0;
 }
 
 static struct imxmmc_platform_data sdhc1_pdata = {
 	.init = mx27ads_sdhc1_init,
+	.get_ro = mx27ads_sdhc1_get_ro,
 	.exit = mx27ads_sdhc1_exit,
 };
 
 static struct imxmmc_platform_data sdhc2_pdata = {
-        .init = mx27ads_sdhc2_init,
-        .exit = mx27ads_sdhc2_exit,
+	.init = mx27ads_sdhc2_init,
+	.get_ro = mx27ads_sdhc2_get_ro,
+	.exit = mx27ads_sdhc2_exit,
 };
 #endif /* CONFIG_MMC */
 
@@ -1433,6 +1565,48 @@ static struct platform_device *platform_devices[] __initdata = {
 #endif /* W1_MASTER_MXC */
 };
 
+#if defined(CONFIG_SERIAL_8250) || defined(CONFIG_SERIAL_8250_MODULE)
+/*!
+
+* The serial port definition structure.
+
+*/
+static struct plat_serial8250_port serial_platform_data[] = {
+        {
+                .membase  = (void *)(PBC_SC16C652_UARTA_REG),
+                .mapbase  = (unsigned long)(CS4_BASE_ADDR + (PBC_SC16C652_UARTA_REG - PBC_BASE_ADDRESS)),
+                .irq      = EXPIO_INT_XUART_INTA,
+                .uartclk  = 3686400,
+                .regshift = 1,
+                .iotype   = UPIO_MEM,
+                .flags    = UPF_BOOT_AUTOCONF | UPF_AUTO_IRQ | UPF_SKIP_TEST,
+        },
+        {},
+};
+
+static struct platform_device serial_device = {
+        .name   = "serial8250",
+        .id     = 0,
+        .dev    = {
+                .platform_data = serial_platform_data,
+        },
+};
+
+static int __init mxc_init_extuart(void)
+{
+	__raw_writew(PBC_BCTRL1_URST, PBC_BCTRL1_SET_REG);
+	mdelay(100);
+	__raw_writew(PBC_BCTRL1_URST, PBC_BCTRL1_CLEAR_REG);
+
+        return platform_device_register(&serial_device);
+}
+#else
+static inline int mxc_init_extuart(void)
+{
+        return 0;
+}
+#endif
+
 static void __init mx27ads_board_init(void)
 {
 	gpio_fec_active();
@@ -1441,6 +1615,9 @@ static void __init mx27ads_board_init(void)
 	mxc_register_device(&mxc_uart_device1, &uart_pdata[1]);
 	mxc_register_device(&mxc_uart_device2, &uart_pdata[2]);
 	mxc_register_device(&mxc_uart_device3, &uart_pdata[3]);
+
+	mxc_init_extuart();
+
 #ifndef CONFIG_VIDEO_MX27
 	/* CSI pins conflict with UART4 and UAT5 pins */
 	mxc_register_device(&mxc_uart_device4, &uart_pdata[4]);
-- 
1.5.5.1

