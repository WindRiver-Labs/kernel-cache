From d0fef56ce7f82efcbc1af41495bc8eafeb98e5ca Mon Sep 17 00:00:00 2001
From: Weiwei Wang <weiwei.wang@windriver.com>
Date: Fri, 12 Jun 2009 21:25:41 +0800
Subject: [PATCH 71/77] mx27ads: Add USB OTG support

Original reference code source taken from Freescale
BSP Global Package Pool.
http://www.bitshrine.org/gpp/linux-2.6.24-imx_2.3.2.bz2

Removing RP11 and RP12 will enable OTG Controller + ISP1504
transceiver on board mx27ads, so here add platform-wide code
which matches MXC OTG driver to implement OTG functionality.
Also, USBH1 USBH2 and OTG+ISP1301 platform-wide code are
modified to match the adjusted host and udc drivers.

Signed-off-by: Weiwei Wang <weiwei.wang@windriver.com>
---
 arch/arm/mach-mx2/devices.c               |   58 ++++-
 arch/arm/mach-mx2/devices.h               |    2 +
 arch/arm/mach-mx2/mx27ads.c               |  435 +++++++++++++++++++++++++----
 arch/arm/plat-mxc/include/mach/mx27_usb.h |   33 +++
 4 files changed, 469 insertions(+), 59 deletions(-)
 create mode 100644 arch/arm/plat-mxc/include/mach/mx27_usb.h

diff --git a/arch/arm/mach-mx2/devices.c b/arch/arm/mach-mx2/devices.c
index 305e340..aded21e 100644
--- a/arch/arm/mach-mx2/devices.c
+++ b/arch/arm/mach-mx2/devices.c
@@ -522,9 +522,22 @@ struct platform_device mxc_dam_device = {
 	.resource = &mxc_dam_resources
 };
 
+#ifdef CONFIG_MACH_MX27
+
 static u64 otg_dmamask = ~(u32) 0;
 
-static struct resource mxc_otg_resources[] = {
+static struct resource mxc_otg_udc_resources[] = {
+	{
+		.start = OTG_BASE_ADDR + 0x000,
+		.end   = OTG_BASE_ADDR + 0x1ff,
+		.flags = IORESOURCE_MEM,
+	}, {
+		.start = MXC_INT_USB3,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+static struct resource mxc_otg_host_resources[] = {
 	{
 		.start = OTG_BASE_ADDR + 0x000,
 		.end   = OTG_BASE_ADDR + 0x1ff,
@@ -535,15 +548,47 @@ static struct resource mxc_otg_resources[] = {
 	},
 };
 
+static struct resource mxc_isp1504_resources[] = {
+	{
+		.start = OTG_BASE_ADDR + 0x000,
+		.end   = OTG_BASE_ADDR + 0x1ff,
+		.flags = IORESOURCE_MEM,
+	}, {
+		.start = MXC_INT_USB3,
+		.flags = IORESOURCE_IRQ,
+	},
+};
 struct platform_device mxc_otg = {
+	.name = "isp1504_arc",
+	.id = -1,
+	.dev = {
+		.coherent_dma_mask = 0xffffffff,
+		.dma_mask = &otg_dmamask,
+	},
+	.resource = mxc_isp1504_resources,
+	.num_resources = ARRAY_SIZE(mxc_isp1504_resources),
+};
+
+struct platform_device mxc_otg_udc = {
 	.name = "fsl-usb2-udc",
-	.id = 0,
+	.id = -1,
 	.dev = {
 		.coherent_dma_mask = 0xffffffff,
 		.dma_mask = &otg_dmamask,
 	},
-	.resource = mxc_otg_resources,
-	.num_resources = ARRAY_SIZE(mxc_otg_resources),
+	.resource = mxc_otg_udc_resources,
+	.num_resources = ARRAY_SIZE(mxc_otg_udc_resources),
+};
+
+struct platform_device mxc_otg_host = {
+	.name = "fsl-ehci",
+	.id = 2,
+	.dev = {
+		.coherent_dma_mask = 0xffffffff,
+		.dma_mask = &otg_dmamask,
+	},
+	.resource = mxc_otg_host_resources,
+	.num_resources = ARRAY_SIZE(mxc_otg_host_resources),
 };
 
 static struct resource mxc_ehci1_resources[] = {
@@ -560,7 +605,7 @@ static struct resource mxc_ehci1_resources[] = {
 static u64 ehci1_dmamask = ~(u32) 0;
 
 struct platform_device mxc_ehci1 = {
-	.name = "mxc-ehci",
+	.name = "fsl-ehci",
 	.id = 0,
 	.dev = {
 		.coherent_dma_mask = 0xffffffff,
@@ -584,7 +629,7 @@ static struct resource mxc_ehci2_resources[] = {
 static u64 ehci2_dmamask = ~(u32) 0;
 
 struct platform_device mxc_ehci2 = {
-	.name = "mxc-ehci",
+	.name = "fsl-ehci",
 	.id = 1,
 	.dev = {
 		.coherent_dma_mask = 0xffffffff,
@@ -594,6 +639,7 @@ struct platform_device mxc_ehci2 = {
 	.resource = mxc_ehci2_resources,
 };
 
+#endif
 
 /*
  * Resource definition for the MXC SDHC
diff --git a/arch/arm/mach-mx2/devices.h b/arch/arm/mach-mx2/devices.h
index 01e09bc..70ac906 100644
--- a/arch/arm/mach-mx2/devices.h
+++ b/arch/arm/mach-mx2/devices.h
@@ -26,6 +26,8 @@ extern struct platform_device imx_ssi_device0;
 extern struct platform_device imx_ssi_device1;
 extern struct platform_device mxc_dam_device;
 extern struct platform_device mxc_otg;
+extern struct platform_device mxc_otg_udc;
+extern struct platform_device mxc_otg_host;
 extern struct platform_device mxc_ehci1;
 extern struct platform_device mxc_ehci2;
 extern struct platform_device mxc_sdhc_device0;
diff --git a/arch/arm/mach-mx2/mx27ads.c b/arch/arm/mach-mx2/mx27ads.c
index 4a06b3b..2bc7d8d 100644
--- a/arch/arm/mach-mx2/mx27ads.c
+++ b/arch/arm/mach-mx2/mx27ads.c
@@ -35,6 +35,8 @@
 #include <media/soc_camera.h>
 #include <linux/video_encoder.h> 
 #include <linux/serial_8250.h>
+#include <linux/fsl_devices.h>
+#include <linux/usb/otg.h>
 
 #include <asm/mach-types.h>
 #include <asm/mach/arch.h>
@@ -1242,6 +1244,34 @@ static struct imx_ssi_platform_data mx27ads_ssi1 = {
 #endif
 
 #ifdef CONFIG_USB
+
+static struct clk *usb_clk;
+static struct clk *usb_ahb_clk;
+/*
+ * make sure USB_CLK is running at 60 MHz +/- 1000 Hz
+ */
+static int check_usbclk(void)
+{
+	unsigned long freq;
+
+	usb_ahb_clk = clk_get(NULL, "usb_ahb_clk");
+	if (clk_enable(usb_ahb_clk)) {
+		printk(KERN_ERR "clk_enable(usb_ahb_clk) failed\n");
+		return -EINVAL;
+	}
+	clk_put(usb_ahb_clk);
+
+	usb_clk = clk_get(NULL, "usb_clk");
+	freq = clk_get_rate(usb_clk);
+	clk_put(usb_clk);
+	if ((freq < 59999000) || (freq > 60001000)) {
+		printk(KERN_ERR "USB_CLK=%lu, should be 60MHz\n", freq);
+		return -1;
+	}
+
+	return 0;
+}
+
 static int mxc_usbh1_pins[] = {
 	PB22_PF_USBH1_SUSP,
 	PB25_PF_USBH1_RCV,
@@ -1253,17 +1283,25 @@ static int mxc_usbh1_pins[] = {
 	PB31_PF_USBH1_RXDP,
 };
 
-static int mx27ads_usbh1_init(struct platform_device *pdev)
+static int mx27ads_usbh1_init(void)
 {
 	int ret;
 	uint32_t temp;
 
+	if (check_usbclk() != 0)
+		return -EINVAL;
+
 	ret = mxc_gpio_setup_multiple_pins(mxc_usbh1_pins,
 					   ARRAY_SIZE(mxc_usbh1_pins),
 					   MXC_GPIO_ALLOC_MODE_NORMAL, "usbh1");
 	if (ret)
 		return ret;
 
+	if (clk_enable(usb_clk)) {
+		printk(KERN_ERR "%s clk_enable(usb_clk) failed\n", __func__);
+		return -EINVAL;
+	}
+
 	__raw_writew(PBC_BCTRL3_FSH_MOD, PBC_BCTRL3_CLEAR_REG);
 	__raw_writew(PBC_BCTRL3_FSH_VBUS_EN, PBC_BCTRL3_CLEAR_REG);
 
@@ -1281,9 +1319,23 @@ static int mx27ads_usbh1_init(struct platform_device *pdev)
 
 	return 0;
 }
+static void mx27ads_usbh1_uninit(void)
+{
+	mxc_gpio_setup_multiple_pins(mxc_usbh1_pins,
+					ARRAY_SIZE(mxc_usbh1_pins),
+					MXC_GPIO_ALLOC_MODE_RELEASE,
+					"usbh1");
+}
 
-struct mxc_usb2_platform_data ehci1_pdata = {
-	.init = mx27ads_usbh1_init,
+struct arc_usb_config ehci1_pdata = {
+	.name            = "Host 1",
+	.platform_init   = mx27ads_usbh1_init,
+	.platform_uninit = mx27ads_usbh1_uninit,
+	.xcvr_type       = PORTSC_PTS_SERIAL,
+	.usbmode         = (u32) &UH1_USBMODE,
+	.power_budget    = 500,		/* 500 mA max power */
+	.suspended       = 0,
+	.already_suspended = 0,
 };
 
 static int mxc_usbh2_pins[] = {
@@ -1335,11 +1387,14 @@ static int isp1504_set_vbus_power(void __iomem *view, int on)
 	return ret;
 }
 
-static int mx27ads_usbh2_init(struct platform_device *pdev)
+static int mx27ads_usbh2_init(void)
 {
 	int ret;
 	uint32_t temp;
 
+	if (check_usbclk() != 0)
+		return -EINVAL;
+
 	ret = mxc_gpio_setup_multiple_pins(mxc_usbh2_pins,
 					   ARRAY_SIZE(mxc_usbh2_pins),
 					   MXC_GPIO_ALLOC_MODE_NORMAL, "usbh2");
@@ -1348,6 +1403,11 @@ static int mx27ads_usbh2_init(struct platform_device *pdev)
 
 	__raw_writew(PBC_BCTRL3_HSH_EN, PBC_BCTRL3_CLEAR_REG);
 
+	if (clk_enable(usb_clk)) {
+		printk(KERN_ERR "%s clk_enable(usb_clk) failed\n", __func__);
+		return -EINVAL;
+	}
+
 	temp = readl(IO_ADDRESS(OTG_BASE_ADDR) + 0x600);
 	temp &= ~(UCTRL_H2SIC_MASK | UCTRL_BPE);/* disable bypass mode */
 	temp |= UCTRL_H2WIE |			/* wakeup intr enable */
@@ -1363,50 +1423,35 @@ static int mx27ads_usbh2_init(struct platform_device *pdev)
 
 	mdelay(10);
 
-	ret = isp1504_set_vbus_power((void *)IO_ADDRESS(OTG_BASE_ADDR + 0x570), 1);
-	if (ret)
-		mxc_gpio_setup_multiple_pins(mxc_usbh2_pins,
-					     ARRAY_SIZE(mxc_usbh2_pins),
-					     MXC_GPIO_ALLOC_MODE_RELEASE,
-					     "usbh2");
-	return ret;
+	return 0;
 }
 
-struct mxc_usb2_platform_data ehci2_pdata = {
-	.init = mx27ads_usbh2_init,
-};
-#endif
-
-#if defined(CONFIG_W1_MASTER_MXC) || defined(CONFIG_W1_MASTER_MXC_MODULE)
-static struct platform_device mx27ads_w1_device = {
-	.name = "mxc_w1",
-	.id = 0
-};
-
-static int mxc_owire_pins[] = {
-	PE16_AF_RTCK
-};
-
-void gpio_owire_active(void)
+static void mx27ads_usbh2_uninit(void)
 {
-	mxc_gpio_setup_multiple_pins(mxc_owire_pins,
-			ARRAY_SIZE(mxc_owire_pins),
-			MXC_GPIO_ALLOC_MODE_NORMAL, "1-WIRE");
+	mxc_gpio_setup_multiple_pins(mxc_usbh2_pins,
+					ARRAY_SIZE(mxc_usbh2_pins),
+					MXC_GPIO_ALLOC_MODE_RELEASE,
+					"usbh2");
 }
-EXPORT_SYMBOL(gpio_owire_active);
 
-void gpio_owire_inactive(void)
+static void usbh2_set_vbus_power(int on)
 {
-	mxc_gpio_setup_multiple_pins(mxc_owire_pins,
-			ARRAY_SIZE(mxc_owire_pins),
-			MXC_GPIO_ALLOC_MODE_RELEASE, "1-WIRE");
+	isp1504_set_vbus_power((void __iomem *)&UH2_ULPIVIEW, on);
 }
-EXPORT_SYMBOL(gpio_owire_inactive);
 
-#endif /* W1_MASTER_MXC */
+struct arc_usb_config ehci2_pdata = {
+	.name            = "Host 2",
+	.platform_init   = mx27ads_usbh2_init,
+	.platform_uninit = mx27ads_usbh2_uninit,
+	.set_vbus_power  = usbh2_set_vbus_power,
+	.xcvr_type       = PORTSC_PTS_ULPI,
+	.usbmode         = (u32) &UH2_USBMODE,
+	.power_budget    = 500,		/* 500 mA max power */
+	.suspended       = 0,
+	.already_suspended = 0,
+};
 
-#if defined(CONFIG_USB) && defined(CONFIG_I2C)
-static int mxc_gadget_pins[] = {
+static int mxc_otg_pins[] = {
 	PC7_PF_USBOTG_DATA5,
 	PC8_PF_USBOTG_DATA6,
 	PC9_PF_USBOTG_DATA0,
@@ -1423,15 +1468,16 @@ static int mxc_gadget_pins[] = {
 	PB23_PF_USB_PWR,
 };
 
-static int mx27ads_gadget_init(struct platform_device *pdev)
+#if defined(CONFIG_USB_EHCI_ARC_OTGFS) && defined(CONFIG_I2C)
+static int mx27ads_1301_udc_init(struct platform_device *pdev)
 {
 	int ret;
 	uint32_t temp;
 
-	ret = mxc_gpio_setup_multiple_pins(mxc_gadget_pins,
-					   ARRAY_SIZE(mxc_gadget_pins),
+	ret = mxc_gpio_setup_multiple_pins(mxc_otg_pins,
+					   ARRAY_SIZE(mxc_otg_pins),
 					   MXC_GPIO_ALLOC_MODE_NORMAL,
-					   "gadget");
+					   "otg");
 	if (ret)
 		return ret;
 
@@ -1439,6 +1485,11 @@ static int mx27ads_gadget_init(struct platform_device *pdev)
 	__raw_writew(PBC_BCTRL3_OTG_HS_EN, PBC_BCTRL3_CLEAR_REG);
 	__raw_writew(PBC_BCTRL3_OTG_VBUS_EN, PBC_BCTRL3_CLEAR_REG);
 
+	if (clk_enable(usb_clk)) {
+		printk(KERN_ERR "%s clk_enable(usb_clk) failed\n", __func__);
+		return -EINVAL;
+	}
+
 	/* SET TRANCIEVER:
 	 * set USBCTRL for device operation
 	 * disable: bypass mode
@@ -1464,23 +1515,280 @@ static int mx27ads_gadget_init(struct platform_device *pdev)
 	return 0;
 }
 
-static int mx27ads_gadget_exit(struct platform_device *pdev)
+static void mx27ads_1301_udc_exit(struct fsl_usb2_platform_data *pdata)
 {
 	/* Configure CPLD */
 	__raw_writew(PBC_BCTRL3_OTG_HS_EN, PBC_BCTRL3_SET_REG);
 
-	return mxc_gpio_setup_multiple_pins(mxc_gadget_pins,
-					    ARRAY_SIZE(mxc_gadget_pins),
+	mxc_gpio_setup_multiple_pins(mxc_otg_pins,
+					    ARRAY_SIZE(mxc_otg_pins),
 					    MXC_GPIO_ALLOC_MODE_RELEASE,
-					    "gadget");
+					    "otg");
+}
+
+struct fsl_usb2_platform_data pdata_1301_udc = {
+	.platform_init = mx27ads_1301_udc_init,
+	.platform_uninit = mx27ads_1301_udc_exit,
+	.phy_mode = FSL_USB2_PHY_SERIAL,
+};
+#endif
+
+#if defined(CONFIG_USB_GADGET_ARC_OTGFS) && defined(CONFIG_I2C)
+static int mx27ads_1301_host_init(void)
+{
+	int ret;
+	uint32_t temp;
+
+	if (check_usbclk() != 0)
+		return -EINVAL;
+
+	/* Single Ended Unidirectional Mode */
+	isp1301_set_serial_dev(0, 1);
+
+	ret = mxc_gpio_setup_multiple_pins(mxc_otg_pins,
+					   ARRAY_SIZE(mxc_otg_pins),
+					   MXC_GPIO_ALLOC_MODE_NORMAL,
+					   "otg");
+	if (ret)
+		return ret;
+
+	/* Configure CPLD */
+	__raw_writew(PBC_BCTRL3_OTG_VBUS_EN, PBC_BCTRL3_CLEAR_REG);
+
+	if (clk_enable(usb_clk)) {
+		printk(KERN_ERR "%s clk_enable(usb_clk) failed\n", __func__);
+		return -EINVAL;
+	}
+
+	/* SET TRANCIEVER:
+	 * set USBCTRL for device operation
+	 * USBCTRL address = OTG_BASE_ADDR + 0x600
+	 * disable: bypass mode
+	 * set: differential/unidir/6 wire, OTG wakeup intr enable,
+	 *      power mask
+	 */
+	temp = readl(IO_ADDRESS(OTG_BASE_ADDR) + 0x600);
+	temp &= ~UCTRL_OSIC_MASK;
+	temp &= ~UCTRL_BPE;
+	/* Single Ended Unidirectional Mode */
+	temp |= UCTRL_OSIC_SU6 | UCTRL_OWIE | UCTRL_OPM;
+	writel(temp, IO_ADDRESS(OTG_BASE_ADDR) + 0x600);
+
+	/* need reset */
+	UOG_USBCMD |= UCMD_RESET;
+	mdelay(10);
+
+	return 0;
+}
+
+static void mx27ads_1301_host_exit(void)
+{
+	/* Configure CPLD */
+	__raw_writew(PBC_BCTRL3_OTG_VBUS_EN, PBC_BCTRL3_SET_REG);
+
+	mxc_gpio_setup_multiple_pins(mxc_otg_pins,
+					ARRAY_SIZE(mxc_otg_pins),
+					MXC_GPIO_ALLOC_MODE_RELEASE,
+					"otg");
+}
+
+struct arc_usb_config pdata_1301_host = {
+	.name            = "OTG FS Host",
+	.platform_init   = mx27ads_1301_host_init,
+	.platform_uninit = mx27ads_1301_host_exit,
+	.set_vbus_power  = isp1301_set_vbus_power,
+	.xcvr_type       = PORTSC_PTS_SERIAL,
+	.usbmode         = (u32) &UOG_USBMODE,
+	.does_otg        = 1,
+	.power_budget    = 500,		/* 500 mA max power */
+	.suspended       = 0,
+	.already_suspended = 0,
+};
+#endif
+
+#if defined(CONFIG_USB_OTG) || defined(CONFIG_USB_EHCI_ARC_OTGHS)\
+			    || defined(CONFIG_USB_GADGET_ARC_OTGHS)
+
+static struct otg_transceiver *xceiv;
+
+/**
+ * otg_get_transceiver - find the (single) OTG transceiver driver
+ *
+ * Returns the transceiver driver, after getting a refcount to it; or
+ * null if there is no such transceiver.  The caller is responsible for
+ * releasing that count.
+ */
+struct otg_transceiver *otg_get_transceiver(void)
+{
+	if (xceiv)
+		get_device(xceiv->dev);
+	return xceiv;
+}
+EXPORT_SYMBOL(otg_get_transceiver);
+
+int otg_set_transceiver(struct otg_transceiver *x)
+{
+	if (xceiv && x)
+		return -EBUSY;
+	xceiv = x;
+	return 0;
+}
+EXPORT_SYMBOL(otg_set_transceiver);
+
+
+static int otg_used;
+static void otg_hs_set_xcvr(void)
+{
+	u32 tmp;
+	struct clk *usbclk;
+
+	/* set ULPI xcvr */
+	tmp = UOG_PORTSC1 & ~PORTSC_PTS_MASK;
+	tmp |= PORTSC_PTS_ULPI;
+	UOG_PORTSC1 = tmp;
+
+	/* need to reset the controller here so that the ID pin
+	 * is correctly detected.
+	 */
+	UOG_USBCMD |= UCMD_RESET;
+
+	/* allow controller to reset, and leave time for
+	 * the ULPI transceiver to reset too.
+	 */
+	mdelay(100);
+
+	/* Turn off the usbpll for ulpi tranceivers */
+	usbclk = clk_get(NULL, "usb_clk");
+	clk_disable(usbclk);
+	clk_put(usbclk);
+}
+
+static int mx27ads_1504_otg_init(struct platform_device *pdev)
+{
+	int ret;
+
+	if (!otg_used) {
+
+		if (check_usbclk() != 0)
+			return -EINVAL;
+
+		ret = mxc_gpio_setup_multiple_pins(mxc_otg_pins,
+						   ARRAY_SIZE(mxc_otg_pins),
+						   MXC_GPIO_ALLOC_MODE_NORMAL,
+						   "otg");
+		if (ret) {
+			printk(KERN_ERR "reserve pin error\n");
+			return ret;
+		}
+
+		mdelay(1);
+
+		if (clk_enable(usb_clk)) {
+			printk(KERN_ERR "%s clk_enable(usb_clk) failed\n", __func__);
+			return -EINVAL;
+		}
+
+		/* enable OTG/HS */
+		__raw_writew(PBC_BCTRL3_OTG_HS_EN, PBC_BCTRL3_CLEAR_REG);
+
+		USBCTRL &= ~UCTRL_BPE;	/* disable bypass mode */
+		USBCTRL |= UCTRL_OUIE |	/* ULPI intr enable */
+			   UCTRL_OWIE |	/* OTG wakeup intr enable */
+			   UCTRL_OPM;	/* power mask */
+
+		otg_hs_set_xcvr();	/* set transciever type */
+	}
+
+	ulpi_set(ID_PULL_UP, ISP1504_OTGCTL, (void __iomem *)&UOG_ULPIVIEW);
+	otg_used++;
+	return 0;
+}
+
+static void mx27ads_1504_otg_exit(struct fsl_usb2_platform_data *pdata)
+{
+	otg_used--;
+	if (!otg_used) {
+		/* disable  OTG/HS */
+		__raw_writew(PBC_BCTRL3_OTG_HS_EN, PBC_BCTRL3_SET_REG);
+
+		mxc_gpio_setup_multiple_pins(mxc_otg_pins,
+						ARRAY_SIZE(mxc_otg_pins),
+						MXC_GPIO_ALLOC_MODE_RELEASE,
+						"otg");
+	}
+}
+
+static void otg_1504_set_vbus_power(int on)
+{
+	isp1504_set_vbus_power((void __iomem *)&UOG_ULPIVIEW, on);
 }
 
-struct mxc_gadget_platform_data gadget_pdata = {
-	.init = mx27ads_gadget_init,
-	.exit = mx27ads_gadget_exit,
+#ifdef CONFIG_USB_EHCI_ARC_OTGHS
+struct arc_usb_config pdata_1504_host = {
+	.name            = "OTG HS Host",
+	.platform_init   = (int (*)(void))mx27ads_1504_otg_init,
+	.platform_uninit = (void (*)(void))mx27ads_1504_otg_exit,
+	.set_vbus_power  = otg_1504_set_vbus_power,
+	.xcvr_type       = PORTSC_PTS_ULPI,
+	.usbmode         = (u32) &UOG_USBMODE,
+	.does_otg        = 1,
+	.power_budget    = 500,		/* 500 mA max power */
+	.suspended       = 0,
+	.already_suspended = 0,
+
 };
 #endif
 
+#ifdef CONFIG_USB_GADGET_ARC_OTGHS
+struct fsl_usb2_platform_data pdata_1504_udc = {
+	.platform_init = mx27ads_1504_otg_init,
+	.platform_uninit = mx27ads_1504_otg_exit,
+	.phy_mode = FSL_USB2_PHY_ULPI,
+};
+#endif
+
+#ifdef CONFIG_USB_OTG
+static struct fsl_usb2_platform_data pdata_1504_otg = {
+	.name              = "isp1504",
+	.platform_init     = mx27ads_1504_otg_init,
+	.platform_uninit   = mx27ads_1504_otg_exit,
+	.phy_mode          = FSL_USB2_PHY_ULPI,
+	.power_budget      = 500,		/* 500 mA max power */
+};
+#endif
+#endif
+#endif /* CONFIG_USB */
+
+#if defined(CONFIG_W1_MASTER_MXC) || defined(CONFIG_W1_MASTER_MXC_MODULE)
+static struct platform_device mx27ads_w1_device = {
+	.name = "mxc_w1",
+	.id = 0
+};
+
+static int mxc_owire_pins[] = {
+	PE16_AF_RTCK
+};
+
+void gpio_owire_active(void)
+{
+	mxc_gpio_setup_multiple_pins(mxc_owire_pins,
+			ARRAY_SIZE(mxc_owire_pins),
+			MXC_GPIO_ALLOC_MODE_NORMAL, "1-WIRE");
+}
+EXPORT_SYMBOL(gpio_owire_active);
+
+void gpio_owire_inactive(void)
+{
+	mxc_gpio_setup_multiple_pins(mxc_owire_pins,
+			ARRAY_SIZE(mxc_owire_pins),
+			MXC_GPIO_ALLOC_MODE_RELEASE, "1-WIRE");
+}
+EXPORT_SYMBOL(gpio_owire_inactive);
+
+#endif /* W1_MASTER_MXC */
+
+
+
 #ifdef CONFIG_VIDEO_MX27
 static int mxc_csi_pins[] = {
 	PB10_PF_CSI_D0,
@@ -1674,19 +1982,40 @@ static void __init mx27ads_board_init(void)
 	mxc_register_device(&imx_ssi_device0, &mx27ads_ssi0);
 	mxc_register_device(&imx_ssi_device1, &mx27ads_ssi1);
 #endif
+
 #ifdef CONFIG_USB
+#ifdef CONFIG_USB_EHCI_ARC_H1
 	/* USB_HOST1 conflicts with UART3 pins */
 	mxc_register_device(&mxc_ehci1, &ehci1_pdata);
-#ifndef CONFIG_SPI_MXC_SELECT2
+#endif
+
+#if defined(CONFIG_USB_EHCI_ARC_H2) && !defined(CONFIG_SPI_MXC_SELECT2)
 	/* USB_HOST2 conflicts with SPI2 pins */
 	mxc_register_device(&mxc_ehci2, &ehci2_pdata);
 #endif
+
+#if defined(CONFIG_USB_EHCI_ARC_OTGFS) && defined(CONFIG_I2C)
+	mxc_register_device(&mxc_otg_host, &pdata_1301_host);
+#endif
+
+#if defined(CONFIG_USB_GADGET_ARC_OTGFS) && defined(CONFIG_I2C)
+	mxc_register_device(&mxc_otg_udc, &pdata_1301_udc);
+#endif
+
+#ifdef CONFIG_USB_OTG
+	mxc_register_device(&mxc_otg, &pdata_1504_otg);
 #endif
 
-#if defined(CONFIG_USB) && defined(CONFIG_I2C)
-	mxc_register_device(&mxc_otg, &gadget_pdata);
+#ifdef CONFIG_USB_EHCI_ARC_OTGHS
+	mxc_register_device(&mxc_otg_host, &pdata_1504_host);
 #endif
 
+#ifdef CONFIG_USB_GADGET_ARC_OTGHS
+	mxc_register_device(&mxc_otg_udc, &pdata_1504_udc);
+#endif
+
+#endif /* CONFIG_USB */
+
 #ifdef CONFIG_MMC
 	mxc_register_device(&mxc_sdhc_device0, &sdhc1_pdata);
         mxc_register_device(&mxc_sdhc_device1, &sdhc2_pdata);
diff --git a/arch/arm/plat-mxc/include/mach/mx27_usb.h b/arch/arm/plat-mxc/include/mach/mx27_usb.h
new file mode 100644
index 0000000..39173c6
--- /dev/null
+++ b/arch/arm/plat-mxc/include/mach/mx27_usb.h
@@ -0,0 +1,33 @@
+/*
+ * Copyright 2005-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/* ehci_arc_hc_driver.flags value */
+#define FSL_PLATFORM_HC_FLAGS (HCD_USB2 | HCD_USB2)
+
+static inline int fsl_platform_verify(struct platform_device *pdev)
+{
+	return 0;
+}
+
+static inline void fsl_platform_usb_setup(struct usb_hcd *hcd)
+{
+}
+
+static inline void fsl_platform_set_host_mode(struct usb_hcd *hcd)
+{
+	unsigned int temp;
+
+	/* set host mode */
+	temp = readl(hcd->regs + 0x1a8);
+	writel(temp | USBMODE_CM_HOST, hcd->regs + 0x1a8);
+}
-- 
1.6.3.1

