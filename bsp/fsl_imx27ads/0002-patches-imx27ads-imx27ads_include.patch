From d24a7cd739c38153a898c0470b9785f3e937c367 Mon Sep 17 00:00:00 2001
From: Chunbo Luo <chunbo.luo@windriver.com>
Date: Fri, 18 Apr 2008 16:13:29 +0800
Subject: [PATCH] patches-imx27ads/imx27ads_include

Signed-off-by: Liming Wang <liming.wang@windriver.com>
---
 include/asm-arm/arch-mxc/board-mx27ads.h |  456 ++++++++++++++++++++++++++++++
 include/asm-arm/arch-mxc/dma.h           |    4 +
 include/asm-arm/arch-mxc/dpm.h           |  151 ++++++++++
 include/asm-arm/arch-mxc/gpio.h          |    8 +
 include/asm-arm/arch-mxc/hardware.h      |    8 +
 include/asm-arm/arch-mxc/mx27.h          |  358 +++++++++++++++++++++++
 include/asm-arm/arch-mxc/mx27_pins.h     |  214 ++++++++++++++
 include/asm-arm/arch-mxc/mx27_usb.h      |   33 +++
 include/asm-arm/arch-mxc/mx2_dma.h       |  261 +++++++++++++++++
 include/asm-arm/arch-mxc/mxc.h           |   24 ++
 10 files changed, 1517 insertions(+), 0 deletions(-)
 create mode 100644 include/asm-arm/arch-mxc/board-mx27ads.h
 create mode 100644 include/asm-arm/arch-mxc/dpm.h
 create mode 100644 include/asm-arm/arch-mxc/mx27.h
 create mode 100644 include/asm-arm/arch-mxc/mx27_pins.h
 create mode 100644 include/asm-arm/arch-mxc/mx27_usb.h
 create mode 100644 include/asm-arm/arch-mxc/mx2_dma.h

diff --git a/include/asm-arm/arch-mxc/board-mx27ads.h b/include/asm-arm/arch-mxc/board-mx27ads.h
new file mode 100644
index 0000000..23a7475
--- /dev/null
+++ b/include/asm-arm/arch-mxc/board-mx27ads.h
@@ -0,0 +1,456 @@
+/*
+ * Copyright 2005-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#ifndef __ASM_ARCH_MXC_BOARD_MX27ADS_H__
+#define __ASM_ARCH_MXC_BOARD_MX27ADS_H__
+
+/*!
+ * @defgroup BRDCFG Board Configuration Options
+ * @ingroup MSL
+ */
+
+/*!
+ * @file board-mx27ads.h
+ *
+ * @brief This file contains all the board level configuration options.
+ *
+ * It currently hold the options defined for MX27 ADS Platform.
+ *
+ * @ingroup BRDCFG
+ */
+
+/*
+ * Include Files
+ */
+#include <asm/arch/board.h>
+
+#define CKIH_CLK_FREQ		26000000	/* 26M reference clk */
+#define CKIH_CLK_FREQ_27MHZ	27000000
+#define CKIL_CLK_FREQ		(32768 * 1024)	/* 32.768k oscillator in */
+#define CKIH_27MHZ_BIT_SET	(1 << 3)
+
+/* Start of physical RAM */
+#define PHYS_OFFSET		UL(0xA0000000)
+
+/* Size of contiguous memory for DMA and other h/w blocks */
+#define CONSISTENT_DMA_SIZE	SZ_8M
+
+/* I2C configuration */
+/*!
+ * This defines the number of I2C modules in the MXC platform
+ */
+#define I2C_NR			1
+/*!
+ * This define specifies the frequency divider value to be written into
+ * the I2C \b IFDR register.
+ */
+#define I2C1_FRQ_DIV		0x17
+
+/*!
+ * @name MXC UART EVB board level configurations
+ */
+/*! @{ */
+/*!
+ * Specify the max baudrate for the MXC UARTs for your board, do not specify a max
+ * baudrate greater than 1500000. This is used while specifying the UART Power
+ * management constraints.
+ */
+#define MAX_UART_BAUDRATE	1500000
+/*!
+ * Specifies if the Irda transmit path is inverting
+ */
+#define MXC_IRDA_TX_INV	0
+/*!
+ * Specifies if the Irda receive path is inverting
+ */
+#define MXC_IRDA_RX_INV	0
+/* UART 1 configuration */
+/*!
+ * This define specifies if the UART port is configured to be in DTE or
+ * DCE mode. There exists a define like this for each UART port. Valid
+ * values that can be used are \b MODE_DTE or \b MODE_DCE.
+ */
+#define UART1_MODE		MODE_DCE
+/*!
+ * This define specifies if the UART is to be used for IRDA. There exists a
+ * define like this for each UART port. Valid values that can be used are
+ * \b IRDA or \b NO_IRDA.
+ */
+#define UART1_IR		NO_IRDA
+/*!
+ * This define is used to enable or disable a particular UART port. If
+ * disabled, the UART will not be registered in the file system and the user
+ * will not be able to access it. There exists a define like this for each UART
+ * port. Specify a value of 1 to enable the UART and 0 to disable it.
+ */
+#define UART1_ENABLED		1
+/*! @} */
+/* UART 2 configuration */
+#define UART2_MODE		MODE_DCE
+#define UART2_IR		NO_IRDA
+#define UART2_ENABLED		1
+/* UART 3 configuration */
+#define UART3_MODE		MODE_DCE
+#define UART3_IR		IRDA
+#define UART3_ENABLED		1
+/* UART 4 configuration */
+#define UART4_MODE		MODE_DTE
+#define UART4_IR		NO_IRDA
+#define UART4_ENABLED		0	/* Disable UART 4 as its pins are shared with ATA */
+/* UART 5 configuration */
+#define UART5_MODE		MODE_DTE
+#define UART5_IR		NO_IRDA
+#define UART5_ENABLED		1
+/* UART 6 configuration */
+#define UART6_MODE		MODE_DTE
+#define UART6_IR		NO_IRDA
+#define UART6_ENABLED		1
+
+#define MXC_LL_EXTUART_PADDR	(CS4_BASE_ADDR + 0x20000)
+#define MXC_LL_EXTUART_VADDR	(CS4_BASE_ADDR_VIRT + 0x20000)
+#define MXC_LL_EXTUART_16BIT_BUS
+
+#define MXC_LL_UART_PADDR	UART1_BASE_ADDR
+#define MXC_LL_UART_VADDR	AIPI_IO_ADDRESS(UART1_BASE_ADDR)
+
+/*!
+ * @name Memory Size parameters
+ */
+/*! @{ */
+/*!
+ * Size of SDRAM memory
+ */
+#define SDRAM_MEM_SIZE		SZ_128M
+/*! @} */
+
+/*! @{ */
+/*!
+ * @name Keypad Configurations
+ */
+/*! @{ */
+/*!
+ * Maximum number of rows (0 to 7)
+ */
+#define MAXROW		6
+/*!
+ * Maximum number of columns (0 to 7)
+ */
+#define MAXCOL		6
+/*! @} */
+
+/*!
+ * @name PBC Controller parameters
+ */
+/*! @{ */
+/*!
+ * Base address of PBC controller, CS4
+ */
+#define PBC_BASE_ADDRESS	IO_ADDRESS(CS4_BASE_ADDR)
+#define PBC_REG_ADDR(offset)	(PBC_BASE_ADDRESS + (offset))
+
+/*!
+ * PBC Interupt name definitions
+ */
+#define PBC_GPIO1_0	0
+#define PBC_GPIO1_1	1
+#define PBC_GPIO1_2	2
+#define PBC_GPIO1_3	3
+#define PBC_GPIO1_4	4
+#define PBC_GPIO1_5	5
+
+#define PBC_INTR_MAX_NUM 6
+#define PBC_INTR_SHARED_MAX_NUM 8
+
+/* When the PBC address connection is fixed in h/w, defined as 1 */
+#define PBC_ADDR_SH	0
+
+/* Offsets for the PBC Controller register */
+/*!
+ * PBC Board version register offset
+ */
+#define PBC_VERSION_REG	PBC_REG_ADDR(0x00000 >> PBC_ADDR_SH)
+/*!
+ * PBC Board control register 1 set address.
+ */
+#define PBC_BCTRL1_SET_REG	PBC_REG_ADDR(0x00008 >> PBC_ADDR_SH)
+/*!
+ * PBC Board control register 1 clear address.
+ */
+#define PBC_BCTRL1_CLEAR_REG	PBC_REG_ADDR(0x0000C >> PBC_ADDR_SH)
+/*!
+ * PBC Board control register 2 set address.
+ */
+#define PBC_BCTRL2_SET_REG	PBC_REG_ADDR(0x00010 >> PBC_ADDR_SH)
+/*!
+ * PBC Board control register 2 clear address.
+ */
+#define PBC_BCTRL2_CLEAR_REG	PBC_REG_ADDR(0x00014 >> PBC_ADDR_SH)
+/*!
+ * PBC Board control register 3 set address.
+ */
+#define PBC_BCTRL3_SET_REG	PBC_REG_ADDR(0x00018 >> PBC_ADDR_SH)
+/*!
+ * PBC Board control register 3 clear address.
+ */
+#define PBC_BCTRL3_CLEAR_REG	PBC_REG_ADDR(0x0001C >> PBC_ADDR_SH)
+/*!
+ * PBC Board control register 3 set address.
+ */
+#define PBC_BCTRL4_SET_REG	PBC_REG_ADDR(0x00020 >> PBC_ADDR_SH)
+/*!
+ * PBC Board control register 4 clear address.
+ */
+#define PBC_BCTRL4_CLEAR_REG	PBC_REG_ADDR(0x00024 >> PBC_ADDR_SH)
+/*!PBC_ADDR_SH
+ * PBC Board status register 1.
+ */
+#define PBC_BSTAT1_REG		PBC_REG_ADDR(0x00028 >> PBC_ADDR_SH)
+/*!
+ * PBC Board interrupt status register.
+ */
+#define PBC_INTSTATUS_REG	PBC_REG_ADDR(0x0002C >> PBC_ADDR_SH)
+/*!
+ * PBC Board interrupt current status register.
+ */
+#define PBC_INTCURR_STATUS_REG  PBC_REG_ADDR(0x00034 >> PBC_ADDR_SH)
+/*!
+ * PBC Interrupt mask register set address.
+ */
+#define PBC_INTMASK_SET_REG	PBC_REG_ADDR(0x00038 >> PBC_ADDR_SH)
+/*!
+ * PBC Interrupt mask register clear address.
+ */
+#define PBC_INTMASK_CLEAR_REG   PBC_REG_ADDR(0x0003C >> PBC_ADDR_SH)
+/*!
+ * External UART A.
+ */
+#define PBC_SC16C652_UARTA_REG  PBC_REG_ADDR(0x20000 >> PBC_ADDR_SH)
+/*!
+ * UART 4 Expanding Signal Status.
+ */
+#define PBC_UART_STATUS_REG	PBC_REG_ADDR(0x22000 >> PBC_ADDR_SH)
+/*!
+ * UART 4 Expanding Signal Control Set.
+ */
+#define PBC_UCTRL_SET_REG	PBC_REG_ADDR(0x24000 >> PBC_ADDR_SH)
+/*!
+ * UART 4 Expanding Signal Control Clear.
+ */
+#define PBC_UCTRL_CLR_REG	PBC_REG_ADDR(0x26000 >> PBC_ADDR_SH)
+/*!
+ * Ethernet Controller IO base address.
+ */
+#define PBC_CS8900A_IOBASE_REG  PBC_REG_ADDR(0x40000 >> PBC_ADDR_SH)
+/*!
+ * Ethernet Controller Memory base address.
+ */
+#define PBC_CS8900A_MEMBASE_REG PBC_REG_ADDR(0x42000 >> PBC_ADDR_SH)
+/*!
+ * Ethernet Controller DMA base address.
+ */
+#define PBC_CS8900A_DMABASE_REG PBC_REG_ADDR(0x44000 >> PBC_ADDR_SH)
+
+/* PBC Board Version Register bit definition */
+#define PBC_VERSION_ADS	0x8000	/* Bit15=1 means version for ads */
+#define PBC_VERSION_EVB_REVB	0x4000	/* BIT14=1 means version for evb revb */
+
+/* PBC Board Control Register 1 bit definitions */
+#define PBC_BCTRL1_ERST	0x0001	/* Ethernet Reset */
+#define PBC_BCTRL1_URST	0x0002	/* Reset External UART controller */
+#define PBC_BCTRL1_FRST	0x0004	/* FEC Reset */
+#define PBC_BCTRL1_ESLEEP	0x0010	/* Enable ethernet Sleep */
+#define PBC_BCTRL1_LCDON	0x0800	/* Enable the LCD */
+
+/* PBC Board Control Register 2 bit definitions */
+#define PBC_BCTRL2_VCC_EN	0x0004	/*   Enable VCC */
+#define PBC_BCTRL2_VPP_EN	0x0008	/*   Enable Vpp */
+#define PBC_BCTRL2_ATAFEC_EN	0X0010
+#define PBC_BCTRL2_ATAFEC_SEL	0X0020
+#define PBC_BCTRL2_ATA_EN	0X0040
+#define PBC_BCTRL2_IRDA_SD	0X0080
+#define PBC_BCTRL2_IRDA_EN	0X0100
+#define PBC_BCTRL2_CCTL10	0X0200
+#define PBC_BCTRL2_CCTL11	0X0400
+
+/* PBC Board Control Register 3 bit definitions */
+#define PBC_BCTRL3_HSH_EN	0X0020
+#define PBC_BCTRL3_FSH_MOD	0X0040
+#define PBC_BCTRL3_OTG_HS_EN	0X0080
+#define PBC_BCTRL3_OTG_VBUS_EN	0X0100
+#define PBC_BCTRL3_FSH_VBUS_EN	0X0200
+#define PBC_BCTRL3_USB_OTG_ON	0X0800
+#define PBC_BCTRL3_USB_FSH_ON	0X1000
+
+/* PBC Board Control Register 4 bit definitions */
+#define PBC_BCTRL4_REGEN_SEL	0X0001
+#define PBC_BCTRL4_USER_OFF	0X0002
+#define PBC_BCTRL4_VIB_EN	0X0004
+#define PBC_BCTRL4_PWRGT1_EN	0X0008
+#define PBC_BCTRL4_PWRGT2_EN	0X0010
+#define PBC_BCTRL4_STDBY_PRI	0X0020
+
+#ifndef __ASSEMBLY__
+/*!
+ * Enumerations for SD cards and memory stick card. This corresponds to
+ * the card EN bits in the IMR: SD1_EN | MS_EN | SD3_EN | SD2_EN.
+ */
+enum mxc_card_no {
+	MXC_CARD_SD2 = 0,
+	MXC_CARD_SD3,
+	MXC_CARD_MS,
+	MXC_CARD_SD1,
+	MXC_CARD_MIN = MXC_CARD_SD2,
+	MXC_CARD_MAX = MXC_CARD_SD1,
+};
+#endif
+
+#define MXC_CPLD_VER_1_50	0x01
+
+/*!
+ * PBC BSTAT Register bit definitions
+ */
+#define PBC_BSTAT_PRI_INT	0X0001
+#define PBC_BSTAT_USB_BYP	0X0002
+#define PBC_BSTAT_ATA_IOCS16	0X0004
+#define PBC_BSTAT_ATA_CBLID	0X0008
+#define PBC_BSTAT_ATA_DASP	0X0010
+#define PBC_BSTAT_PWR_RDY	0X0020
+#define PBC_BSTAT_SD3_WP	0X0100
+#define PBC_BSTAT_SD2_WP	0X0200
+#define PBC_BSTAT_SD1_WP	0X0400
+#define PBC_BSTAT_SD3_DET	0X0800
+#define PBC_BSTAT_SD2_DET	0X1000
+#define PBC_BSTAT_SD1_DET	0X2000
+#define PBC_BSTAT_MS_DET	0X4000
+#define PBC_BSTAT_SD3_DET_BIT	11
+#define PBC_BSTAT_SD2_DET_BIT	12
+#define PBC_BSTAT_SD1_DET_BIT	13
+#define PBC_BSTAT_MS_DET_BIT	14
+#define MXC_BSTAT_BIT(n)	((n == MXC_CARD_SD2) ? PBC_BSTAT_SD2_DET : \
+				 ((n == MXC_CARD_SD3) ? PBC_BSTAT_SD3_DET : \
+				 ((n == MXC_CARD_SD1) ? PBC_BSTAT_SD1_DET : \
+				 ((n == MXC_CARD_MS) ? PBC_BSTAT_MS_DET : 0x0))))
+
+/*!
+ * PBC UART Control Register bit definitions
+ */
+#define PBC_UCTRL_DCE_DCD	0X0001
+#define PBC_UCTRL_DCE_DSR	0X0002
+#define PBC_UCTRL_DCE_RI	0X0004
+#define PBC_UCTRL_DTE_DTR	0X0100
+
+/*!
+ * PBC UART Status Register bit definitions
+ */
+#define PBC_USTAT_DTE_DCD	0X0001
+#define PBC_USTAT_DTE_DSR	0X0002
+#define PBC_USTAT_DTE_RI	0X0004
+#define PBC_USTAT_DCE_DTR	0X0100
+
+/*!
+ * PBC Interupt mask register bit definitions
+ */
+#define PBC_INTR_SD3_R_EN_BIT	4
+#define PBC_INTR_SD2_R_EN_BIT	0
+#define PBC_INTR_SD1_R_EN_BIT	6
+#define PBC_INTR_MS_R_EN_BIT	5
+#define PBC_INTR_SD3_EN_BIT	13
+#define PBC_INTR_SD2_EN_BIT	12
+#define PBC_INTR_MS_EN_BIT	14
+#define PBC_INTR_SD1_EN_BIT	15
+
+#define PBC_INTR_SD2_R_EN	0x0001
+#define PBC_INTR_LOW_BAT	0X0002
+#define PBC_INTR_OTG_FSOVER	0X0004
+#define PBC_INTR_FSH_OVER	0X0008
+#define PBC_INTR_SD3_R_EN	0x0010
+#define PBC_INTR_MS_R_EN	0x0020
+#define PBC_INTR_SD1_R_EN	0x0040
+#define PBC_INTR_FEC_INT	0X0080
+#define PBC_INTR_ENET_INT	0X0100
+#define PBC_INTR_OTGFS_INT	0X0200
+#define PBC_INTR_XUART_INT	0X0400
+#define PBC_INTR_CCTL12	0X0800
+#define PBC_INTR_SD2_EN	0x1000
+#define PBC_INTR_SD3_EN	0x2000
+#define PBC_INTR_MS_EN		0x4000
+#define PBC_INTR_SD1_EN	0x8000
+
+/*! @} */
+
+/* For interrupts like xuart, enet etc */
+#define EXPIO_PARENT_INT	IOMUX_TO_IRQ(MX27_PIN_TIN)
+#define MXC_MAX_EXP_IO_LINES	16
+
+/*
+ * This corresponds to PBC_INTMASK_SET_REG at offset 0x38.
+ *
+ */
+#define EXPIO_INT_LOW_BAT	(MXC_EXP_IO_BASE + 1)
+#define EXPIO_INT_OTG_FS_OVR	(MXC_EXP_IO_BASE + 2)
+#define EXPIO_INT_FSH_OVR	(MXC_EXP_IO_BASE + 3)
+#define EXPIO_INT_RES4		(MXC_EXP_IO_BASE + 4)
+#define EXPIO_INT_RES5		(MXC_EXP_IO_BASE + 5)
+#define EXPIO_INT_RES6		(MXC_EXP_IO_BASE + 6)
+#define EXPIO_INT_FEC		(MXC_EXP_IO_BASE + 7)
+#define EXPIO_INT_ENET_INT	(MXC_EXP_IO_BASE + 8)
+#define EXPIO_INT_OTG_FS_INT	(MXC_EXP_IO_BASE + 9)
+#define EXPIO_INT_XUART_INTA	(MXC_EXP_IO_BASE + 10)
+#define EXPIO_INT_CCTL12_INT	(MXC_EXP_IO_BASE + 11)
+#define EXPIO_INT_SD2_EN	(MXC_EXP_IO_BASE + 12)
+#define EXPIO_INT_SD3_EN	(MXC_EXP_IO_BASE + 13)
+#define EXPIO_INT_MS_EN	(MXC_EXP_IO_BASE + 14)
+#define EXPIO_INT_SD1_EN	(MXC_EXP_IO_BASE + 15)
+
+/*! This is System IRQ used by CS8900A for interrupt generation taken from platform.h */
+#define CS8900AIRQ		EXPIO_INT_ENET_INT
+/*! This is I/O Base address used to access registers of CS8900A on MXC ADS */
+#define CS8900A_BASE_ADDRESS	(PBC_CS8900A_IOBASE_REG + 0x300)
+
+#define MXC_PMIC_INT_LINE	IOMUX_TO_IRQ(MX27_PIN_TOUT)
+
+/*!
+* This is used to detect if the CPLD version is for mx27 evb board rev-a
+*/
+#define PBC_CPLD_VERSION_IS_REVA() \
+	 ((__raw_readw(PBC_VERSION_REG) & \
+	 (PBC_VERSION_ADS | PBC_VERSION_EVB_REVB))\
+	 == 0)
+
+/*! This is used to active or inactive ata signal in CPLD .
+ *  It is dependent with hardware
+ */
+#define PBC_ATA_SIGNAL_ACTIVE() \
+	 __raw_writew(		\
+			 PBC_BCTRL2_ATAFEC_EN |PBC_BCTRL2_ATAFEC_SEL | PBC_BCTRL2_ATA_EN, PBC_BCTRL2_CLEAR_REG)
+
+#define PBC_ATA_SIGNAL_INACTIVE() \
+	 __raw_writew(  \
+			 PBC_BCTRL2_ATAFEC_EN |PBC_BCTRL2_ATAFEC_SEL | PBC_BCTRL2_ATA_EN, PBC_BCTRL2_SET_REG)
+
+#define MXC_SOUND_PLAYBACK_CHAIN_DMA_EN
+#define MXC_SOUND_CAPTURE_CHAIN_DMA_EN
+
+#ifdef MXC_SOUND_PLAYBACK_CHAIN_DMA_EN
+#define MXC_SOUND_PLAYBACK_CHAIN_DMA	1
+#else
+#define MXC_SOUND_PLAYBACK_CHAIN_DMA	0
+#endif
+
+#ifdef MXC_SOUND_CAPTURE_CHAIN_DMA_EN
+#define MXC_SOUND_CAPTURE_CHAIN_DMA	1
+#else
+#define MXC_SOUND_CAPTURE_CHAIN_DMA	0
+#endif
+
+#endif				/* __ASM_ARCH_MXC_BOARD_MX27ADS_H__ */
diff --git a/include/asm-arm/arch-mxc/dma.h b/include/asm-arm/arch-mxc/dma.h
index e154d7e..8d3bafa 100644
--- a/include/asm-arm/arch-mxc/dma.h
+++ b/include/asm-arm/arch-mxc/dma.h
@@ -115,7 +115,11 @@ typedef struct mxc_dma_requestbuf {
 	int num_of_bytes;	/*!< the length of this transfer : bytes */
 } mxc_dma_requestbuf_t;
 
+#if defined(CONFIG_ARCH_MX27)
+#include <asm/arch/mx2_dma.h>
+#else
 #include <asm/arch/sdma.h>
+#endif
 
 /*!
  * This function is generally called by the driver at open time.
diff --git a/include/asm-arm/arch-mxc/dpm.h b/include/asm-arm/arch-mxc/dpm.h
new file mode 100644
index 0000000..8d2d3fd
--- /dev/null
+++ b/include/asm-arm/arch-mxc/dpm.h
@@ -0,0 +1,151 @@
+/* REVISIT Doxygen fixups */
+/*
+ * DPM for Freescale MXC
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ * Copyright (C) 2002-2004, MontaVista Software <source@mvista.com>
+ *
+ * Initially based on include/asm-arm/arch-omap/omap_dpm.h
+ */
+
+#ifndef __ASM_ARCH_MXC_DPM_H__
+#define __ASM_ARCH_MXC_DPM_H__
+
+#include <asm/io.h>
+#include <asm/timex.h>
+
+/*!
+ * @defgroup DPM Dynamic Power Management
+ * @ingroup MSL
+ */
+
+/*!
+ * @file dpm.h
+ *
+ * @brief This file provides DPM support hooks for the Freescale MXC
+ *
+ * @ingroup DPM
+ */
+
+/*!
+ * machine dependent operating state
+ *
+ * An operating state is a cpu execution state that has implications for power
+ * management. The DPM will select operating points based largely on the
+ * current operating state.
+ *
+ * DPM_STATES is the number of supported operating states. Valid operating
+ * states are from 0 to DPM_STATES-1 but when setting an operating state the
+ * kernel should only specify a state from the set of "base states" and should
+ * do so by name.  During the context switch the new operating state is simply
+ * extracted from current->dpm_state.
+ *
+ * task states:
+ *
+ * APIs that reference task states use the range -(DPM_TASK_STATE_LIMIT + 1)
+ * through +DPM_TASK_STATE_LIMIT.  This value is added to DPM_TASK_STATE to
+ * obtain the downward or upward adjusted task state value. The
+ * -(DPM_TASK_STATE_LIMIT + 1) value is interpreted specially, and equates to
+ * DPM_NO_STATE.
+ *
+ * Tasks inherit their task operating states across calls to
+ * fork(). DPM_TASK_STATE is the default operating state for all tasks, and is
+ * inherited from init.  Tasks can change (or have changed) their tasks states
+ * using the DPM_SET_TASK_STATE variant of the sys_dpm() system call.
+ */
+#define DPM_IDLE_TASK_STATE	0
+#define DPM_IDLE_STATE		1
+#define DPM_SLEEP_STATE	2
+#define DPM_BASE_STATES	3
+
+#define DPM_TASK_STATE_LIMIT 4
+#define DPM_TASK_STATE		(DPM_BASE_STATES + DPM_TASK_STATE_LIMIT)
+#define DPM_STATES		(DPM_TASK_STATE + DPM_TASK_STATE_LIMIT + 1)
+#define DPM_TASK_STATES	(DPM_STATES - DPM_BASE_STATES)
+
+#define DPM_STATE_NAMES			\
+{ "idle-task", "idle", "sleep",		\
+  "task-4", "task-3", "task-2", "task-1",	\
+  "task",					\
+  "task+1", "task+2", "task+3", "task+4"	\
+}
+
+#define DPM_PARAM_NAMES				\
+{ "core", "ahb",     \
+  "ip", "mode" }
+
+/*!
+ * MD operating point parameters
+ */
+#define DPM_CORE_FREQ		0
+#define DPM_AHB_FREQ		1
+#define DPM_IP_FREQ		2
+#define DPM_MODE		3
+
+#define DPM_PP_NBR 4
+
+#ifndef __ASSEMBLER__
+
+#include <linux/types.h>
+#include <linux/proc_fs.h>
+
+#define dpm_time()	get_cycles()
+
+extern unsigned long clock_to_usecs(unsigned long);
+#define dpm_time_to_usec(ticks) (clock_to_usecs(ticks))
+
+/*!
+ * The register values only include the bits manipulated by the DPM
+ * system - other bits that also happen to reside in these registers are
+ * not represented here.
+ */
+struct dpm_regs {
+};
+
+/*!
+ * Instances of this structure define valid MXC operating points for DPM.
+ * Voltages are represented in mV, and frequencies are represented in KHz.
+ */
+struct dpm_md_opt {
+	unsigned int cpu;	/* in KHz */
+	unsigned int ahb;	/* in KHz */
+	unsigned int ip;	/* in KHz */
+	unsigned int mode;
+	struct dpm_regs regs;	/* Register values */
+};
+
+#ifdef CONFIG_MACH_MX27ADS
+#define ARM_MAX 400000000
+#define ARM_MIN 33250000
+#define AHB_MAX 133000000
+#define AHB_MIN 33250000
+#define IPG_MAX 66500000
+#define IPG_MIN 16625000
+#else
+#define ARM_MAX 532000000
+#define ARM_MIN 133000000
+#define AHB_MAX AHB_FREQ
+#define AHB_MIN AHB_FREQ
+#define IPG_MAX IPG_FREQ
+#define IPG_MIN IPG_FREQ
+#endif
+
+#define DPM_MODE_SLEEP 0
+#define DPM_MODE_RUN 1
+#define DPM_MODE_WAIT 2
+#define DPM_MODE_STOP 3
+#endif				/* __ASSEMBLER__ */
+#endif				/* __ASM_ARCH_MXC_DPM_H__ */
diff --git a/include/asm-arm/arch-mxc/gpio.h b/include/asm-arm/arch-mxc/gpio.h
index 9a47adb..afd876c 100644
--- a/include/asm-arm/arch-mxc/gpio.h
+++ b/include/asm-arm/arch-mxc/gpio.h
@@ -57,11 +57,19 @@ enum gpio_prio {
  * by the external hardware.
  */
 typedef enum gpio_int_cfg {
+#if defined(CONFIG_ARCH_MX27)
+	GPIO_INT_LOW_LEV = 0x3,	/*!< low level sensitive */
+	GPIO_INT_HIGH_LEV = 0x2,	/*!< high level sensitive */
+	GPIO_INT_RISE_EDGE = 0x0,	/*!< rising edge sensitive */
+	GPIO_INT_FALL_EDGE = 0x1,	/*!< falling edge sensitive */
+	GPIO_INT_NONE = 0x4	/*!< No interrupt */
+#else
 	GPIO_INT_LOW_LEV = 0x0,	/*!< low level sensitive */
 	GPIO_INT_HIGH_LEV = 0x1,	/*!< high level sensitive */
 	GPIO_INT_RISE_EDGE = 0x2,	/*!< rising edge sensitive */
 	GPIO_INT_FALL_EDGE = 0x3,	/*!< falling edge sensitive */
 	GPIO_INT_NONE = 0x4	/*!< No interrupt */
+#endif
 } gpio_edge_t;
 
 typedef irqreturn_t(*gpio_irq_handler) (int, void *);
diff --git a/include/asm-arm/arch-mxc/hardware.h b/include/asm-arm/arch-mxc/hardware.h
index 2461d35..a0b4e47 100644
--- a/include/asm-arm/arch-mxc/hardware.h
+++ b/include/asm-arm/arch-mxc/hardware.h
@@ -18,6 +18,10 @@
 #include <asm/arch/board-mx31.h>
 #endif
 
+#ifdef CONFIG_ARCH_MX27
+#include <asm/arch/mx27.h>
+#endif
+
 #include <asm/arch/mxc.h>
 
 /*
@@ -29,6 +33,10 @@
 # include <asm/arch/board-mx31ads.h>
 #endif
 
+#ifdef CONFIG_MACH_MX27ADS
+#include <asm/arch/board-mx27ads.h>
+#endif
+
 /* This is used to turn on/off debugging */
 #define MXC_TRACE
 #ifdef MXC_TRACE
diff --git a/include/asm-arm/arch-mxc/mx27.h b/include/asm-arm/arch-mxc/mx27.h
new file mode 100644
index 0000000..6e5fbeb
--- /dev/null
+++ b/include/asm-arm/arch-mxc/mx27.h
@@ -0,0 +1,358 @@
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @defgroup MSL Machine Specific Layer (MSL)
+ */
+
+/*!
+ * @defgroup System System-wide Misc Files for MSL
+ * @ingroup MSL
+ */
+
+/*!
+ * @file mx27.h
+ * @brief This file contains register definitions.
+ *
+ * @ingroup System
+ */
+
+#ifndef __ASM_ARCH_MXC_MX27_H__
+#define __ASM_ARCH_MXC_MX27_H__
+
+#ifndef __ASM_ARCH_MXC_HARDWARE_H__
+#error "Do not include directly."
+#endif
+
+#include <asm/arch/mx27_pins.h>
+
+/*!
+ * defines the OS clock tick rate
+ */
+#define CLOCK_TICK_RATE	13300000
+
+#define ATA_BASE_CLK		(AHB_CLK)
+
+/*!
+ * Register an interrupt handler for the SMN as well as the SCC.  In some
+ * implementations, the SMN is not connected at all, and in others, it is
+ * on the same interrupt line as the SCM. Comment this line out accordingly
+ */
+#define USE_SMN_INTERRUPT
+
+/*!
+ * UART Chip level Configuration that a user may not have to edit. These
+ * configuration vary depending on how the UART module is integrated with
+ * the ARM core
+ */
+#define MXC_UART_NR 6
+/*!
+ * This option is used to set or clear the RXDMUXSEL bit in control reg 3.
+ * Certain platforms need this bit to be set in order to receive Irda data.
+ */
+#define MXC_UART_IR_RXDMUX	0x0004
+/*!
+ * This option is used to set or clear the RXDMUXSEL bit in control reg 3.
+ * Certain platforms need this bit to be set in order to receive UART data.
+ */
+#define MXC_UART_RXDMUX	0x0004
+
+/*
+ * IRAM
+ */
+#define IRAM_BASE_ADDR	0xFFFF4C00	/* internal ram */
+
+/*
+ *  Register offests.
+ */
+#define AIPI_BASE_ADDR		0x10000000
+#define AIPI_BASE_ADDR_VIRT	0xD4000000
+#define AIPI_SIZE		SZ_1M
+
+#define DMA_BASE_ADDR		(AIPI_BASE_ADDR + 0x01000)
+#define WDOG_BASE_ADDR		(AIPI_BASE_ADDR + 0x02000)
+#define GPT1_BASE_ADDR		(AIPI_BASE_ADDR + 0x03000)
+#define GPT2_BASE_ADDR		(AIPI_BASE_ADDR + 0x04000)
+#define GPT3_BASE_ADDR		(AIPI_BASE_ADDR + 0x05000)
+#define PWM_BASE_ADDR		(AIPI_BASE_ADDR + 0x06000)
+#define RTC_BASE_ADDR		(AIPI_BASE_ADDR + 0x07000)
+#define KPP_BASE_ADDR		(AIPI_BASE_ADDR + 0x08000)
+#define OWIRE_BASE_ADDR	(AIPI_BASE_ADDR + 0x09000)
+#define UART1_BASE_ADDR	(AIPI_BASE_ADDR + 0x0A000)
+#define UART2_BASE_ADDR	(AIPI_BASE_ADDR + 0x0B000)
+#define UART3_BASE_ADDR	(AIPI_BASE_ADDR + 0x0C000)
+#define UART4_BASE_ADDR	(AIPI_BASE_ADDR + 0x0D000)
+#define CSPI1_BASE_ADDR	(AIPI_BASE_ADDR + 0x0E000)
+#define CSPI2_BASE_ADDR	(AIPI_BASE_ADDR + 0x0F000)
+#define SSI1_BASE_ADDR		(AIPI_BASE_ADDR + 0x10000)
+#define SSI2_BASE_ADDR		(AIPI_BASE_ADDR + 0x11000)
+#define I2C_BASE_ADDR		(AIPI_BASE_ADDR + 0x12000)
+#define SDHC1_BASE_ADDR	(AIPI_BASE_ADDR + 0x13000)
+#define SDHC2_BASE_ADDR	(AIPI_BASE_ADDR + 0x14000)
+#define GPIO_BASE_ADDR		(AIPI_BASE_ADDR + 0x15000)
+#define AUDMUX_BASE_ADDR	(AIPI_BASE_ADDR + 0x16000)
+
+#define CSPI3_BASE_ADDR	(AIPI_BASE_ADDR + 0x17000)
+#define MSHC_BASE_ADDR		(AIPI_BASE_ADDR + 0x18000)
+#define GPT5_BASE_ADDR		(AIPI_BASE_ADDR + 0x19000)
+#define GPT4_BASE_ADDR		(AIPI_BASE_ADDR + 0x1A000)
+#define UART5_BASE_ADDR	(AIPI_BASE_ADDR + 0x1B000)
+#define UART6_BASE_ADDR	(AIPI_BASE_ADDR + 0x1C000)
+#define I2C2_BASE_ADDR		(AIPI_BASE_ADDR + 0x1D000)
+#define SDHC3_BASE_ADDR	(AIPI_BASE_ADDR + 0x1E000)
+#define GPT6_BASE_ADDR		(AIPI_BASE_ADDR + 0x1F000)
+
+#define LCDC_BASE_ADDR		(AIPI_BASE_ADDR + 0x21000)
+#define SLCDC_BASE_ADDR	(AIPI_BASE_ADDR + 0x22000)
+#define VPU_BASE_ADDR		(AIPI_BASE_ADDR + 0x23000)
+#define USBOTG_BASE_ADDR	(AIPI_BASE_ADDR + 0x24000)
+/* for mx27*/
+#define OTG_BASE_ADDR		USBOTG_BASE_ADDR
+#define SAHARA_BASE_ADDR	(AIPI_BASE_ADDR + 0x25000)
+#define EMMA_BASE_ADDR		(AIPI_BASE_ADDR + 0x26400)
+#define CCM_BASE_ADDR		(AIPI_BASE_ADDR + 0x27000)
+#define SYSCTRL_BASE_ADDR	(AIPI_BASE_ADDR + 0x27800)
+#define IIM_BASE_ADDR		(AIPI_BASE_ADDR + 0x28000)
+
+#define RTIC_BASE_ADDR		(AIPI_BASE_ADDR + 0x2A000)
+#define FEC_BASE_ADDR		(AIPI_BASE_ADDR + 0x2B000)
+#define SCC_BASE_ADDR		(AIPI_BASE_ADDR + 0x2C000)
+#define ETB_BASE_ADDR		(AIPI_BASE_ADDR + 0x3B000)
+#define ETB_RAM_BASE_ADDR	(AIPI_BASE_ADDR + 0x3C000)
+
+#define JAM_BASE_ADDR		(AIPI_BASE_ADDR + 0x3E000)
+#define MAX_BASE_ADDR		(AIPI_BASE_ADDR + 0x3F000)
+
+/*
+ * ROMP and AVIC
+ */
+#define ROMP_BASE_ADDR		0x10041000
+
+#define AVIC_BASE_ADDR		0x10040000
+
+#define SAHB1_BASE_ADDR	0x80000000
+#define SAHB1_BASE_ADDR_VIRT	0xD4100000
+#define SAHB1_SIZE		SZ_1M
+
+#define CSI_BASE_ADDR		(SAHB1_BASE_ADDR + 0x0000)
+#define ATA_BASE_ADDR		(SAHB1_BASE_ADDR + 0x1000)
+
+/*
+ * NAND, SDRAM, WEIM, M3IF, EMI controllers
+ */
+#define X_MEMC_BASE_ADDR	0xD8000000
+#define X_MEMC_BASE_ADDR_VIRT	0xD4200000
+#define X_MEMC_SIZE		SZ_1M
+
+#define NFC_BASE_ADDR		(X_MEMC_BASE_ADDR)
+#define SDRAMC_BASE_ADDR	(X_MEMC_BASE_ADDR + 0x1000)
+#define WEIM_BASE_ADDR		(X_MEMC_BASE_ADDR + 0x2000)
+#define M3IF_BASE_ADDR		(X_MEMC_BASE_ADDR + 0x3000)
+#define PCMCIA_CTL_BASE_ADDR	(X_MEMC_BASE_ADDR + 0x4000)
+
+/*
+ * Memory regions and CS
+ */
+#define SDRAM_BASE_ADDR	0xA0000000
+#define CSD1_BASE_ADDR		0xB0000000
+
+#define CS0_BASE_ADDR		0xC0000000
+#define CS1_BASE_ADDR		0xC8000000
+#define CS2_BASE_ADDR		0xD0000000
+#define CS3_BASE_ADDR		0xD2000000
+#define CS4_BASE_ADDR		0xD4000000
+#define CS4_BASE_ADDR_VIRT	0xEB000000
+#define CS4_SIZE		SZ_1M
+#define CS5_BASE_ADDR		0xD6000000
+#define PCMCIA_MEM_BASE_ADDR	0xDC000000
+
+/*!
+ * This macro defines the physical to virtual address mapping for all the
+ * peripheral modules. It is used by passing in the physical address as x
+ * and returning the virtual address. If the physical address is not mapped,
+ * it returns 0xDEADBEEF
+ */
+#define IO_ADDRESS(x)   \
+	 (((x >= AIPI_BASE_ADDR) && (x < (AIPI_BASE_ADDR + AIPI_SIZE))) ? AIPI_IO_ADDRESS(x):\
+	 ((x >= SAHB1_BASE_ADDR) && (x < (SAHB1_BASE_ADDR + SAHB1_SIZE))) ? SAHB1_IO_ADDRESS(x):\
+	 ((x >= CS4_BASE_ADDR) && (x < (CS4_BASE_ADDR + CS4_SIZE))) ? CS4_IO_ADDRESS(x):\
+	 ((x >= X_MEMC_BASE_ADDR) && (x < (X_MEMC_BASE_ADDR + X_MEMC_SIZE))) ? X_MEMC_IO_ADDRESS(x):\
+	 0xDEADBEEF)
+
+/*
+ * define the address mapping macros: in physical address order
+ */
+
+#define AIPI_IO_ADDRESS(x)  \
+	 (((x) - AIPI_BASE_ADDR) + AIPI_BASE_ADDR_VIRT)
+
+#define AVIC_IO_ADDRESS(x)	AIPI_IO_ADDRESS(x)
+
+#define SAHB1_IO_ADDRESS(x)  \
+	 (((x) - SAHB1_BASE_ADDR) + SAHB1_BASE_ADDR_VIRT)
+
+#define CS4_IO_ADDRESS(x)  \
+	 (((x) - CS4_BASE_ADDR) + CS4_BASE_ADDR_VIRT)
+
+#define X_MEMC_IO_ADDRESS(x)  \
+	 (((x) - X_MEMC_BASE_ADDR) + X_MEMC_BASE_ADDR_VIRT)
+
+#define PCMCIA_IO_ADDRESS(x) \
+	 (((x) - X_MEMC_BASE_ADDR) + X_MEMC_BASE_ADDR_VIRT)
+
+/*
+ *  MX27 ADS Interrupt numbers
+ */
+#define INT_CCM		63
+#define INT_IIM		62
+#define INT_LCDC		61
+#define INT_SLCDC		60
+#define INT_SAHARA		59
+#define INT_SCC_SCM		58
+#define INT_SCC_SMN		57
+#define INT_USB3		56
+#define INT_USB2		55
+#define INT_USB1		54
+#define INT_VPU		53
+#define INT_EMMAPP		52
+#define INT_EMMAPRP		51
+#define INT_FEC		50
+#define INT_UART5		49
+#define INT_UART6		48
+#define INT_DMACH15		47
+#define INT_DMACH14		46
+#define INT_DMACH13		45
+#define INT_DMACH12		44
+#define INT_DMACH11		43
+#define INT_DMACH10		42
+#define INT_DMACH9		41
+#define INT_DMACH8		40
+#define INT_DMACH7		39
+#define INT_DMACH6		38
+#define INT_DMACH5		37
+#define INT_DMACH4		36
+#define INT_DMACH3		35
+#define INT_DMACH2		34
+#define INT_DMACH1		33
+#define INT_DMACH0		32
+#define INT_CSI		31
+#define INT_ATA		30
+#define INT_NANDFC		29
+#define INT_PCMCIA		28
+#define INT_WDOG		27
+#define INT_GPT1		26
+#define INT_GPT2		25
+#define INT_GPT3		24
+#define INT_GPT		INT_GPT1
+#define INT_PWM		23
+#define INT_RTC		22
+#define INT_KPP		21
+#define INT_UART1		20
+#define INT_UART2		19
+#define INT_UART3		18
+#define INT_UART4		17
+#define INT_CSPI1		16
+#define INT_CSPI2		15
+#define INT_SSI1		14
+#define INT_SSI2		13
+#define INT_I2C		12
+#define INT_SDHC1		11
+#define INT_SDHC2		10
+#define INT_SDHC3		9
+#define INT_GPIO		8
+#define INT_SDHC		7
+#define INT_CSPI3		6
+#define INT_RTIC		5
+#define INT_GPT4		4
+#define INT_GPT5		3
+#define INT_GPT6		2
+#define INT_I2C2		1
+
+#define MXC_MAX_INT_LINES	64
+#define MXC_MAX_EXT_LINES	0
+
+#define MXC_MUX_GPIO_INTERRUPTS 1
+#define MXC_GPIO_INT_BASE		(MXC_MAX_INT_LINES)
+
+#define MXC_MAX_GPIO_LINES      (GPIO_NUM_PIN * GPIO_PORT_NUM)
+#define MXC_MAX_VIRTUAL_INTS	16
+
+#define MXC_EXP_IO_BASE         (MXC_GPIO_INT_BASE + MXC_MAX_GPIO_LINES)
+
+/*!
+ * Number of GPIO port as defined in the IC Spec
+ */
+#define GPIO_PORT_NUM		6
+/*!
+ * Number of GPIO pins per port
+ */
+#define GPIO_NUM_PIN		32
+
+#define DMA_REQ_NFC		37
+#define DMA_REQ_SDHC3		36
+#define DMA_REQ_UART6_RX	35
+#define DMA_REQ_UART6_TX	34
+#define DMA_REQ_UART5_RX	33
+#define DMA_REQ_UART5_TX	32
+#define DMA_REQ_CSI_RX		31
+#define DMA_REQ_CSI_STAT	30
+#define DMA_REQ_ATA_RCV	29
+#define DMA_REQ_ATA_TX		28
+#define DMA_REQ_UART1_TX	27
+#define DMA_REQ_UART1_RX	26
+#define DMA_REQ_UART2_TX	25
+#define DMA_REQ_UART2_RX	24
+#define DMA_REQ_UART3_TX	23
+#define DMA_REQ_UART3_RX	22
+#define DMA_REQ_UART4_TX	21
+#define DMA_REQ_UART4_RX	20
+#define DMA_REQ_CSPI1_TX	19
+#define DMA_REQ_CSPI1_RX	18
+#define DMA_REQ_CSPI2_TX	17
+#define DMA_REQ_CSPI2_RX	16
+#define DMA_REQ_SSI1_TX1	15
+#define DMA_REQ_SSI1_RX1	14
+#define DMA_REQ_SSI1_TX0	13
+#define DMA_REQ_SSI1_RX0	12
+#define DMA_REQ_SSI2_TX1	11
+#define DMA_REQ_SSI2_RX1	10
+#define DMA_REQ_SSI2_TX0	9
+#define DMA_REQ_SSI2_RX0	8
+#define DMA_REQ_SDHC1		7
+#define DMA_REQ_SDHC2		6
+#define DMA_REQ_MSHC		4
+#define DMA_REQ_EXT		3
+#define DMA_REQ_CSPI3_TX	2
+#define DMA_REQ_CSPI3_RX	1
+
+#define MXC_TIMER_GPT1		1
+#define MXC_TIMER_GPT2		2
+#define MXC_TIMER_GPT3		3
+#define MXC_TIMER_GPT4		4
+#define MXC_TIMER_GPT5		5
+#define MXC_TIMER_GPT6		6
+
+/*!
+ * NFMS bit in FMCR register for pagesize of nandflash
+ */
+#define NFMS (*((volatile u32 *)IO_ADDRESS(SYSCTRL_BASE_ADDR+0x14)))
+
+#define NFMS_BIT 5
+
+/*
+ * GPT clock source mask and offset bit definition
+ */
+#define GPT_CTRL_MASK		0xFFFFFFF1
+#define GPT_CTRL_OFFSET	1
+
+#endif				/* __ASM_ARCH_MXC_MX27_H__ */
diff --git a/include/asm-arm/arch-mxc/mx27_pins.h b/include/asm-arm/arch-mxc/mx27_pins.h
new file mode 100644
index 0000000..b107b8b
--- /dev/null
+++ b/include/asm-arm/arch-mxc/mx27_pins.h
@@ -0,0 +1,214 @@
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#ifndef __ASM_ARCH_MXC_MX27_PINS_H__
+#define __ASM_ARCH_MXC_MX27_PINS_H__
+
+#ifndef __ASSEMBLY__
+
+/*!
+ * Starting bit position within each entry of \b iomux_pins to represent the
+ * gpio port number (0-based) for that pin. For non-gpio pins, the bits will
+ * be all 1's for error checking in the functions. (gpio port 7 is invalid)
+ */
+#define MUX_IO_P	29
+
+/*!
+ * Starting bit position within each entry of \b iomux_pins to represent the
+ * gpio offset bit (0-based) for that pin. For non-gpio pins, the bits will
+ * be all 0's since they are don't cares. So for port 2 pin 21, bit 31-24
+ * will be (1 << MUX_IO_P) | (21 << MUX_IO_I).
+ */
+#define MUX_IO_I	24
+
+#define _MX27_BUILD_PIN(gp,gi) (((gp) << MUX_IO_P) | ((gi) << MUX_IO_I))
+
+typedef enum iomux_pins {
+	MX27_PIN_USBH2_CLK = _MX27_BUILD_PIN(0, 0),
+	MX27_PIN_USBH2_DIR = _MX27_BUILD_PIN(0, 1),
+	MX27_PIN_USBH2_DATA7 = _MX27_BUILD_PIN(0, 2),
+	MX27_PIN_USBH2_NXT = _MX27_BUILD_PIN(0, 3),
+	MX27_PIN_USBH2_STP = _MX27_BUILD_PIN(0, 4),
+	MX27_PIN_LSCLK = _MX27_BUILD_PIN(0, 5),
+	MX27_PIN_LD0 = _MX27_BUILD_PIN(0, 6),
+	MX27_PIN_LD1 = _MX27_BUILD_PIN(0, 7),
+	MX27_PIN_LD2 = _MX27_BUILD_PIN(0, 8),
+	MX27_PIN_LD3 = _MX27_BUILD_PIN(0, 9),
+	MX27_PIN_LD4 = _MX27_BUILD_PIN(0, 10),
+	MX27_PIN_LD5 = _MX27_BUILD_PIN(0, 11),
+	MX27_PIN_LD6 = _MX27_BUILD_PIN(0, 12),
+	MX27_PIN_LD7 = _MX27_BUILD_PIN(0, 13),
+	MX27_PIN_LD8 = _MX27_BUILD_PIN(0, 14),
+	MX27_PIN_LD9 = _MX27_BUILD_PIN(0, 15),
+	MX27_PIN_LD10 = _MX27_BUILD_PIN(0, 16),
+	MX27_PIN_LD11 = _MX27_BUILD_PIN(0, 17),
+	MX27_PIN_LD12 = _MX27_BUILD_PIN(0, 18),
+	MX27_PIN_LD13 = _MX27_BUILD_PIN(0, 19),
+	MX27_PIN_LD14 = _MX27_BUILD_PIN(0, 20),
+	MX27_PIN_LD15 = _MX27_BUILD_PIN(0, 21),
+	MX27_PIN_LD16 = _MX27_BUILD_PIN(0, 22),
+	MX27_PIN_LD17 = _MX27_BUILD_PIN(0, 23),
+	MX27_PIN_REV = _MX27_BUILD_PIN(0, 24),
+	MX27_PIN_CLS = _MX27_BUILD_PIN(0, 25),
+	MX27_PIN_PS = _MX27_BUILD_PIN(0, 26),
+	MX27_PIN_SPL_SPR = _MX27_BUILD_PIN(0, 27),
+	MX27_PIN_HSYNC = _MX27_BUILD_PIN(0, 28),
+	MX27_PIN_VSYNC = _MX27_BUILD_PIN(0, 29),
+	MX27_PIN_CONTRAST = _MX27_BUILD_PIN(0, 30),
+	MX27_PIN_OE_ACD = _MX27_BUILD_PIN(0, 31),
+
+	MX27_PIN_SD2_D0 = _MX27_BUILD_PIN(1, 4),
+	MX27_PIN_SD2_D1 = _MX27_BUILD_PIN(1, 5),
+	MX27_PIN_SD2_D2 = _MX27_BUILD_PIN(1, 6),
+	MX27_PIN_SD2_D3 = _MX27_BUILD_PIN(1, 7),
+	MX27_PIN_SD2_CMD = _MX27_BUILD_PIN(1, 8),
+	MX27_PIN_SD2_CLK = _MX27_BUILD_PIN(1, 9),
+	MX27_PIN_CSI_D0 = _MX27_BUILD_PIN(1, 10),
+	MX27_PIN_CSI_D1 = _MX27_BUILD_PIN(1, 11),
+	MX27_PIN_CSI_D2 = _MX27_BUILD_PIN(1, 12),
+	MX27_PIN_CSI_D3 = _MX27_BUILD_PIN(1, 13),
+	MX27_PIN_CSI_D4 = _MX27_BUILD_PIN(1, 14),
+	MX27_PIN_CSI_MCLK = _MX27_BUILD_PIN(1, 15),
+	MX27_PIN_CSI_PIXCLK = _MX27_BUILD_PIN(1, 16),
+	MX27_PIN_CSI_D5 = _MX27_BUILD_PIN(1, 17),
+	MX27_PIN_CSI_D6 = _MX27_BUILD_PIN(1, 18),
+	MX27_PIN_CSI_D7 = _MX27_BUILD_PIN(1, 19),
+	MX27_PIN_CSI_VSYNC = _MX27_BUILD_PIN(1, 20),
+	MX27_PIN_CSI_HSYNC = _MX27_BUILD_PIN(1, 21),
+	MX27_PIN_USBH1_SUSP = _MX27_BUILD_PIN(1, 22),
+	MX27_PIN_USB_PWR = _MX27_BUILD_PIN(1, 23),
+	MX27_PIN_USB_OC_B = _MX27_BUILD_PIN(1, 24),
+	MX27_PIN_USBH1_RCV = _MX27_BUILD_PIN(1, 25),
+	MX27_PIN_USBH1_FS = _MX27_BUILD_PIN(1, 26),
+	MX27_PIN_USBH1_OE_B = _MX27_BUILD_PIN(1, 27),
+	MX27_PIN_USBH1_TXDM = _MX27_BUILD_PIN(1, 28),
+	MX27_PIN_USBH1_TXDP = _MX27_BUILD_PIN(1, 29),
+	MX27_PIN_USBH1_RXDM = _MX27_BUILD_PIN(1, 30),
+	MX27_PIN_USBH1_RXDP = _MX27_BUILD_PIN(1, 31),
+
+	MX27_PIN_I2C2_SDA = _MX27_BUILD_PIN(2, 5),
+	MX27_PIN_I2C2_SCL = _MX27_BUILD_PIN(2, 6),
+	MX27_PIN_USBOTG_DATA5 = _MX27_BUILD_PIN(2, 7),
+	MX27_PIN_USBOTG_DATA6 = _MX27_BUILD_PIN(2, 8),
+	MX27_PIN_USBOTG_DATA0 = _MX27_BUILD_PIN(2, 9),
+	MX27_PIN_USBOTG_DATA2 = _MX27_BUILD_PIN(2, 10),
+	MX27_PIN_USBOTG_DATA1 = _MX27_BUILD_PIN(2, 11),
+	MX27_PIN_USBOTG_DATA4 = _MX27_BUILD_PIN(2, 12),
+	MX27_PIN_USBOTG_DATA3 = _MX27_BUILD_PIN(2, 13),
+	MX27_PIN_TOUT = _MX27_BUILD_PIN(2, 14),
+	MX27_PIN_TIN = _MX27_BUILD_PIN(2, 15),
+	MX27_PIN_SSI4_FS = _MX27_BUILD_PIN(2, 16),
+	MX27_PIN_SSI4_RXDAT = _MX27_BUILD_PIN(2, 17),
+	MX27_PIN_SSI4_TXDAT = _MX27_BUILD_PIN(2, 18),
+	MX27_PIN_SSI4_CLK = _MX27_BUILD_PIN(2, 19),
+	MX27_PIN_SSI1_FS = _MX27_BUILD_PIN(2, 20),
+	MX27_PIN_SSI1_RXDAT = _MX27_BUILD_PIN(2, 21),
+	MX27_PIN_SSI1_TXDAT = _MX27_BUILD_PIN(2, 22),
+	MX27_PIN_SSI1_CLK = _MX27_BUILD_PIN(2, 23),
+	MX27_PIN_SSI2_FS = _MX27_BUILD_PIN(2, 24),
+	MX27_PIN_SSI2_RXDAT = _MX27_BUILD_PIN(2, 25),
+	MX27_PIN_SSI2_TXDAT = _MX27_BUILD_PIN(2, 26),
+	MX27_PIN_SSI2_CLK = _MX27_BUILD_PIN(2, 27),
+	MX27_PIN_SSI3_FS = _MX27_BUILD_PIN(2, 28),
+	MX27_PIN_SSI3_RXDAT = _MX27_BUILD_PIN(2, 29),
+	MX27_PIN_SSI3_TXDAT = _MX27_BUILD_PIN(2, 30),
+	MX27_PIN_SSI3_CLK = _MX27_BUILD_PIN(2, 31),
+
+	MX27_PIN_SD3_CMD = _MX27_BUILD_PIN(3, 0),
+	MX27_PIN_SD3_CLK = _MX27_BUILD_PIN(3, 1),
+	MX27_PIN_ATA_DATA0 = _MX27_BUILD_PIN(3, 2),
+	MX27_PIN_ATA_DATA1 = _MX27_BUILD_PIN(3, 3),
+	MX27_PIN_ATA_DATA2 = _MX27_BUILD_PIN(3, 4),
+	MX27_PIN_ATA_DATA3 = _MX27_BUILD_PIN(3, 5),
+	MX27_PIN_ATA_DATA4 = _MX27_BUILD_PIN(3, 6),
+	MX27_PIN_ATA_DATA5 = _MX27_BUILD_PIN(3, 7),
+	MX27_PIN_ATA_DATA6 = _MX27_BUILD_PIN(3, 8),
+	MX27_PIN_ATA_DATA7 = _MX27_BUILD_PIN(3, 9),
+	MX27_PIN_ATA_DATA8 = _MX27_BUILD_PIN(3, 10),
+	MX27_PIN_ATA_DATA9 = _MX27_BUILD_PIN(3, 11),
+	MX27_PIN_ATA_DATA10 = _MX27_BUILD_PIN(3, 12),
+	MX27_PIN_ATA_DATA11 = _MX27_BUILD_PIN(3, 13),
+	MX27_PIN_ATA_DATA12 = _MX27_BUILD_PIN(3, 14),
+	MX27_PIN_ATA_DATA13 = _MX27_BUILD_PIN(3, 15),
+	MX27_PIN_ATA_DATA14 = _MX27_BUILD_PIN(3, 16),
+	MX27_PIN_I2C_DATA = _MX27_BUILD_PIN(3, 17),
+	MX27_PIN_I2C_CLK = _MX27_BUILD_PIN(3, 18),
+	MX27_PIN_CSPI2_SS2 = _MX27_BUILD_PIN(3, 19),
+	MX27_PIN_CSPI2_SS1 = _MX27_BUILD_PIN(3, 20),
+	MX27_PIN_CSPI2_SS0 = _MX27_BUILD_PIN(3, 21),
+	MX27_PIN_CSPI2_SCLK = _MX27_BUILD_PIN(3, 22),
+	MX27_PIN_CSPI2_MISO = _MX27_BUILD_PIN(3, 23),
+	MX27_PIN_CSPI2_MOSI = _MX27_BUILD_PIN(3, 24),
+	MX27_PIN_CSPI1_RDY = _MX27_BUILD_PIN(3, 25),
+	MX27_PIN_CSPI1_SS2 = _MX27_BUILD_PIN(3, 26),
+	MX27_PIN_CSPI1_SS1 = _MX27_BUILD_PIN(3, 27),
+	MX27_PIN_CSPI1_SS0 = _MX27_BUILD_PIN(3, 28),
+	MX27_PIN_CSPI1_SCLK = _MX27_BUILD_PIN(3, 29),
+	MX27_PIN_CSPI1_MISO = _MX27_BUILD_PIN(3, 30),
+	MX27_PIN_CSPI1_MOSI = _MX27_BUILD_PIN(3, 31),
+
+	MX27_PIN_USBOTG_NXT = _MX27_BUILD_PIN(4, 0),
+	MX27_PIN_USBOTG_STP = _MX27_BUILD_PIN(4, 1),
+	MX27_PIN_USBOTG_DIR = _MX27_BUILD_PIN(4, 2),
+	MX27_PIN_UART2_CTS = _MX27_BUILD_PIN(4, 3),
+	MX27_PIN_UART2_RTS = _MX27_BUILD_PIN(4, 4),
+	MX27_PIN_PWMO = _MX27_BUILD_PIN(4, 5),
+	MX27_PIN_UART2_TXD = _MX27_BUILD_PIN(4, 6),
+	MX27_PIN_UART2_RXD = _MX27_BUILD_PIN(4, 7),
+	MX27_PIN_UART3_TXD = _MX27_BUILD_PIN(4, 8),
+	MX27_PIN_UART3_RXD = _MX27_BUILD_PIN(4, 9),
+	MX27_PIN_UART3_CTS = _MX27_BUILD_PIN(4, 10),
+	MX27_PIN_UART3_RTS = _MX27_BUILD_PIN(4, 11),
+	MX27_PIN_UART1_TXD = _MX27_BUILD_PIN(4, 12),
+	MX27_PIN_UART1_RXD = _MX27_BUILD_PIN(4, 13),
+	MX27_PIN_UART1_CTS = _MX27_BUILD_PIN(4, 14),
+	MX27_PIN_UART1_RTS = _MX27_BUILD_PIN(4, 15),
+	MX27_PIN_RTCK = _MX27_BUILD_PIN(4, 16),
+	MX27_PIN_RESET_OUT_B = _MX27_BUILD_PIN(4, 17),
+	MX27_PIN_SD1_D0 = _MX27_BUILD_PIN(4, 18),
+	MX27_PIN_SD1_D1 = _MX27_BUILD_PIN(4, 19),
+	MX27_PIN_SD1_D2 = _MX27_BUILD_PIN(4, 20),
+	MX27_PIN_SD1_D3 = _MX27_BUILD_PIN(4, 21),
+	MX27_PIN_SD1_CMD = _MX27_BUILD_PIN(4, 22),
+	MX27_PIN_SD1_CLK = _MX27_BUILD_PIN(4, 23),
+	MX27_PIN_USBOTG_CLK = _MX27_BUILD_PIN(4, 24),
+	MX27_PIN_USBOTG_DATA7 = _MX27_BUILD_PIN(4, 25),
+
+	MX27_PIN_NFRB = _MX27_BUILD_PIN(5, 0),
+	MX27_PIN_NFCLE = _MX27_BUILD_PIN(5, 1),
+	MX27_PIN_NFWP_B = _MX27_BUILD_PIN(5, 2),
+	MX27_PIN_NFCE_B = _MX27_BUILD_PIN(5, 3),
+	MX27_PIN_NFALE = _MX27_BUILD_PIN(5, 4),
+	MX27_PIN_NFRE_B = _MX27_BUILD_PIN(5, 5),
+	MX27_PIN_NFWE_B = _MX27_BUILD_PIN(5, 6),
+	MX27_PIN_PC_POE = _MX27_BUILD_PIN(5, 7),
+	MX27_PIN_PC_RW_B = _MX27_BUILD_PIN(5, 8),
+	MX27_PIN_IOIS16 = _MX27_BUILD_PIN(5, 9),
+	MX27_PIN_PC_RST = _MX27_BUILD_PIN(5, 10),
+	MX27_PIN_PC_BVD2 = _MX27_BUILD_PIN(5, 11),
+	MX27_PIN_PC_BVD1 = _MX27_BUILD_PIN(5, 12),
+	MX27_PIN_PC_VS2 = _MX27_BUILD_PIN(5, 13),
+	MX27_PIN_PC_VS1 = _MX27_BUILD_PIN(5, 14),
+	MX27_PIN_CLKO = _MX27_BUILD_PIN(5, 15),
+	MX27_PIN_PC_PWRON = _MX27_BUILD_PIN(5, 16),
+	MX27_PIN_PC_READY = _MX27_BUILD_PIN(5, 17),
+	MX27_PIN_PC_WAIT_B = _MX27_BUILD_PIN(5, 18),
+	MX27_PIN_PC_CD2_B = _MX27_BUILD_PIN(5, 19),
+	MX27_PIN_PC_CD1_B = _MX27_BUILD_PIN(5, 20),
+	MX27_PIN_CS4_B = _MX27_BUILD_PIN(5, 21),
+	MX27_PIN_CS5_B = _MX27_BUILD_PIN(5, 22),
+	MX27_PIN_ATA_DATA15 = _MX27_BUILD_PIN(5, 23),
+} iomux_pin_name_t;
+
+#endif				/* __ASSEMBLY__ */
+#endif				/* __ASM_ARCH_MXC_MX27_PINS_H__ */
diff --git a/include/asm-arm/arch-mxc/mx27_usb.h b/include/asm-arm/arch-mxc/mx27_usb.h
new file mode 100644
index 0000000..39173c6
--- /dev/null
+++ b/include/asm-arm/arch-mxc/mx27_usb.h
@@ -0,0 +1,33 @@
+/*
+ * Copyright 2005-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/* ehci_arc_hc_driver.flags value */
+#define FSL_PLATFORM_HC_FLAGS (HCD_USB2 | HCD_USB2)
+
+static inline int fsl_platform_verify(struct platform_device *pdev)
+{
+	return 0;
+}
+
+static inline void fsl_platform_usb_setup(struct usb_hcd *hcd)
+{
+}
+
+static inline void fsl_platform_set_host_mode(struct usb_hcd *hcd)
+{
+	unsigned int temp;
+
+	/* set host mode */
+	temp = readl(hcd->regs + 0x1a8);
+	writel(temp | USBMODE_CM_HOST, hcd->regs + 0x1a8);
+}
diff --git a/include/asm-arm/arch-mxc/mx2_dma.h b/include/asm-arm/arch-mxc/mx2_dma.h
new file mode 100644
index 0000000..d3605a5
--- /dev/null
+++ b/include/asm-arm/arch-mxc/mx2_dma.h
@@ -0,0 +1,261 @@
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#ifndef __ASM_ARCH_MXC_MX2_H__
+#define __ASM_ARCH_MXC_MX2_H__
+
+/*!
+*@defgroup DMA DMA driver
+*/
+
+/*!
+ *@file mx2_dma.h
+ *@brief DMA driver header file
+ *
+ * @ingroup DMA
+ *
+ */
+
+#include <asm/hardware.h>
+#include <asm/dma.h>
+#include <stdarg.h>
+
+#define MXC_DMA_INTR_0		32
+
+#define DMA_DCR	0x000	/*  32bit dma control reg */
+#define DMA_DISR	0x004	/*  32bit dma interrupt status reg */
+#define DMA_DIMR	0x008	/*  32bit dma interrupt mask reg */
+#define DMA_DBTOSR	0x00c	/*  32bit dma burst timeout stat reg */
+#define DMA_DRTOSR	0x010	/*  32bit dma req timeout status reg */
+#define DMA_DSESR	0x014	/*  32bit dma transfer err status reg */
+#define DMA_DBOSR	0x018	/*  32bit dma buffer overflow stat reg */
+#define DMA_DBTOCR	0x01c	/*  32bit dma burst timeout ctrl reg */
+
+#define DMA_WSRA		0x040	/*  32bit dma W-size A reg */
+#define DMA_XSRA		0x044	/*  32bit dma X-size A reg */
+#define DMA_YSRA		0x048	/*  32bit dma Y-size A reg */
+#define DMA_WSRB		0x04C	/*  32bit dma W-size B reg */
+#define DMA_XSRB		0x050	/*  32bit dma X-size B reg */
+#define DMA_YSRB		0x054	/*  32bit dma Y-size B reg */
+
+#define DMA_CH_BASE(x)	(0x080+0x040*(x))
+
+#define DMA_SAR(x)		(DMA_CH_BASE(x)+0x000)
+#define DMA_DAR(x)		(DMA_CH_BASE(x)+0x004)
+#define DMA_CNTR(x)		(DMA_CH_BASE(x)+0x008)
+#define DMA_CCR(x)		(DMA_CH_BASE(x)+0x00C)	/*  32bit dma ch0 control reg */
+#define DMA_RSSR(x)		(DMA_CH_BASE(x)+0x010)	/*  32bit dma ch0 req source sel reg */
+#define DMA_BLR(x)		(DMA_CH_BASE(x)+0x014)	/*  32bit dma ch0 burst lenght reg */
+#define DMA_RTOR(x)		(DMA_CH_BASE(x)+0x018)	/*  32bit dma ch0 req time out reg */
+#define DMA_BUCR(x)		(DMA_CH_BASE(x)+0x018)	/*  32bit dma ch0 bus utilization reg */
+#define DMA_CCNR(x)		(DMA_CH_BASE(x)+0x01C)	/*  32bit dma ch0 */
+
+#define DMA_TCR			0x480	/*32bit dma test control reg */
+#define DMA_TFIFOA		0x484	/*  32bit dma test fifo A reg */
+#define DMA_TDRR		0x488	/*  32bit dma test request reg */
+#define DMA_TDIPR		0x48c	/*  32bit dma test in progress reg */
+#define DMA_TFIFOB		0x490	/*  32bit dma test fifo B reg */
+
+/*!
+ * This defines maximum DMA address
+ */
+#define MAX_DMA_ADDRESS 0xffffffff
+
+#define MXC_DMA_CHANNELS 16
+#define MAX_DMA_CHANNELS MXC_DMA_CHANNELS
+
+#define MX_DMA_CHANNELS		MXC_DMA_CHANNELS
+
+/*!@def DMA_MEM_SIZE_8 DMA access port size, 8 bit*/
+/*!@def DMA_MEM_SIZE_16 DMA access port size, 16 bit*/
+/*!@def DMA_MEM_SIZE_32 DMA access port size, 32 bit*/
+#define DMA_MEM_SIZE_8		0x1
+#define DMA_MEM_SIZE_16	0x2
+#define DMA_MEM_SIZE_32	0x0
+
+/*!@def DMA_TYPE_LINEAR DMA transfer type, linear*/
+/*!@def DMA_TYPE_2D DMA transfer type, 2D*/
+/*!@def DMA_TYPE_FIFO DMA transfer type, FIFO*/
+/*!@def DMA_TYPE_EBE DMA transfer type, end-of-burst enable FIFO*/
+#define DMA_TYPE_LINEAR	0x0
+#define DMA_TYPE_2D		0x01
+#define DMA_TYPE_FIFO		0x2
+#define DMA_TYPE_EBE		0x3
+
+/*!@def DMA_DONE DMA transfer done*/
+/*!@def DMA_BURST_TIMEOUT DMA transfer timeout error*/
+/*!@def DMA_REQUEST_TIMEOUT DMA transfer request timeout error*/
+/*!@def DMA_TRANSFER_ERROR DMA transfer error*/
+/*!@def DMA_BUFFER_OVERFLOW DMA transfer buffer overflow error*/
+#define DMA_DONE		0x1000
+#define DMA_BURST_TIMEOUT 	0x1
+#define DMA_REQUEST_TIMEOUT 	0x2
+#define DMA_TRANSFER_ERROR	0x4
+#define DMA_BUFFER_OVERFLOW	0x8
+
+/*!@brief DMA control register*/
+typedef struct {
+	volatile u32 CEN:1;	/*!< Dma channel enable */
+	volatile u32 FRC:1;	/*!<  Force a dma cycle bit */
+	volatile u32 RPT:1;	/*!<  Repeat bit */
+	volatile u32 REN:1;	/*!<   Request enable bit */
+	volatile u32 SSIZ:2;	/*!<   Source port size, 2 bit in length */
+	volatile u32 DSIZ:2;	/*!<  Dest port size, 2 bit in length */
+	volatile u32 MSEL:1;	/*!<  2D memory register set  bit */
+	volatile u32 MDIR:1;	/*!< Transfer direction, inversed or normal */
+	volatile u32 SMOD:2;	/*!<  Source mode, 2 bit in length */
+	volatile u32 DMOD:2;	/*!<  Dest mode, 2 bit in length */
+	volatile u32 ACRPT:1;	/*!<  Auto clear repeat bit */
+	volatile u32 Reserver:17;	/*!<  Reserved bits */
+
+} dma_regs_control;
+
+#define DMA_CTL_CEN 0x1
+#define DMA_CTL_FRC 0x2
+#define DMA_CTL_RPT 0x4
+#define DMA_CTL_REN 0x8
+
+#define DMA_CTL_MSEL 0x100
+#define DMA_CTL_MDIR 0x200
+#define DMA_CTL_ACRPT 0x4000
+
+#define DMA_CTL_GET_SSIZ(x) (((x)>>4)&0x3)
+#define DMA_CTL_GET_DSIZ(x) (((x)>>6)&0x3)
+#define DMA_CTL_GET_SMOD(x) (((x)>>10)&0x3)
+#define DMA_CTL_GET_DMOD(x) (((x)>>12)&0x3)
+
+#define DMA_CTL_SET_SSIZ(x,value) 	do{ \
+									(x)&=~(0x3<<4); \
+									(x)|=(value)<<4; 		\
+								}while(0)
+
+#define DMA_CTL_SET_DSIZ(x,value) 	do{ \
+									(x)&=~(0x3<<6); \
+									(x)|=(value)<<6; 		\
+								}while(0)
+
+#define DMA_CTL_SET_SMOD(x,value) 	do{ \
+									(x)&=~(0x3<<10); \
+									(x)|=(value)<<10; 		\
+								}while(0)
+
+#define DMA_CTL_SET_DMOD(x,value) 	do{ \
+									(x)&=~(0x3<<12); \
+									(x)|=(value)<<12; 		\
+								}while(0)
+
+typedef struct {
+	volatile u32 SourceAddr;
+	volatile u32 DestAddr;
+	volatile u32 Count;
+	volatile u32 Ctl;
+	volatile u32 RequestSource;
+	volatile u32 BurstLength;
+	union {
+		volatile u32 ReqTimeout;
+		volatile u32 BusUtilt;
+	};
+	volatile u32 transferd;
+} dma_regs_t;
+
+#ifndef TRANSFER_32BIT
+/*!
+ * This defines DMA access data size
+ */
+
+#define TRANSFER_8BIT		DMA_MEM_SIZE_8
+#define TRANSFER_16BIT		DMA_MEM_SIZE_16
+#define TRANSFER_32BIT		DMA_MEM_SIZE_32
+
+#endif
+
+/*!
+ * This defines maximum device name length passed during mxc_request_dma().
+ */
+#define MAX_DEVNAME_LENGTH 32
+#define MAX_BD_SIZE	32
+
+/*!
+ * Structure containing dma channel parameters.
+ */
+typedef struct {
+	unsigned long dma_chan;	/*!< the dma channel information: dynamic or channel number */
+	u32 mode:1;		/*!< the initialized dma mode, 0 for dma read, 1 for dma write */
+	u32 rto_en:1;		/*!< enable request-timeout. It is valid when REN=1 */
+	u32 dir:1;		/*!< Transfer direction, 0 for increment, 1 for decrement */
+	u32 dma_chaining:1;	/*!< Autoclear bit for chainbuffer */
+	u32 ren:1;		/*!< enable transfer based request signal */
+	u32 M2D_Valid:1;	/*!< enable 2D address module. 0 for disable it. 1 for enabled it */
+	u32 msel:1;		/*!<2D memory selection, 0 for set A, 1 for set B */
+	u32 burstLength;	/*!< Channel burst length */
+	u32 request;		/*!< Request source. */
+	u32 busuntils;		/*!< when REN=0, Bus utilization, otherwise it it request timeout */
+	u32 sourceType;		/*!< Source type, see DMA_TYPE_* */
+	u32 sourcePort;		/*!< Source port size, see DMA_MEM_SIZE_* */
+	u32 destType;		/*!< Destination type, see DMA_TYPE_* */
+	u32 destPort;		/*!< Destination port size, see DMA_MEM_SIZE_* */
+	__u32 per_address;	/*< Peripheral source/destination
+				 *   physical address
+				 */
+	u32 W;			/*!< 2D Wide-size */
+	u32 X;			/*!< 2D X-size */
+	u32 Y;			/*!< 2D Y-size */
+} mx2_dma_info_t;
+
+/*!
+ * Structure of dma buffer descriptor
+ */
+typedef struct {
+	unsigned long state;	/*!< dma bd state */
+	int mode;		/*!< the dma mode of this bd */
+	unsigned long count;	/*!< the length of the dma transfer */
+	unsigned long src_addr;	/*!< the source address of the dma transfer */
+	unsigned long dst_addr;	/*!< the destination address of the dma transfer */
+} mx2_dma_bd_t;
+
+/*!
+ * the states of dma buffer descriptor
+ */
+#define DMA_BD_ST_BUSY	0x20000000	/*!< dma bd is transfering or has be configured into controller */
+#define DMA_BD_ST_PEND	0x10000000	/*!< dma bd is waiting to be configured into controller */
+#define DMA_BD_ST_LAST	0x08000000	/*!< dma bd is the last dma bd which is built in one dma transfer request
+					 * When completed this bd, the callback function must be called.
+					 */
+
+/*!
+ *  This structure containing the private information for MX2
+ */
+typedef struct mx2_dma_priv_s {
+	unsigned int dma_chaining:1;	/* 1: using headware dma chaining feature */
+	unsigned int ren:1;	/* 1: dma start besed on request signal */
+	unsigned long trans_bytes;	/* To store the transfered data bytes in this transfer */
+	mx2_dma_info_t *dma_info;	/* To store the pointer for dma parameter for reading and wirting */
+	int bd_rd;		/* the read index of bd ring */
+	int bd_wr;		/* the write index of bd ring */
+	atomic_t bd_used;	/* the valid bd number in bd ring */
+	mx2_dma_bd_t *bd_ring;	/* the pointer of bd ring */
+	unsigned long dma_base;	/* register base address of this channel */
+	int dma_irq;		/* irq number of this channel */
+} mx2_dma_priv_t;
+
+/*!
+ * @brief get the dma info by channel_id
+ */
+extern mx2_dma_info_t *mxc_dma_get_info(mxc_dma_device_t channel_id);
+
+/*!
+ * @brief: scan dma parameter list . And collect information about which channels are dynamic .
+ */
+extern void mxc_dma_load_info(mxc_dma_channel_t * dma);
+
+#endif
diff --git a/include/asm-arm/arch-mxc/mxc.h b/include/asm-arm/arch-mxc/mxc.h
index 1f44eb3..04f2138 100644
--- a/include/asm-arm/arch-mxc/mxc.h
+++ b/include/asm-arm/arch-mxc/mxc.h
@@ -45,6 +45,29 @@
  * GPT  Register definitions             *
  *****************************************
  */
+#if defined(CONFIG_ARCH_MX27)
+#define GPT_BASE_ADDR(x)	(GPT ##x## _BASE_ADDR)
+#define MXC_GPT_TCTL(x)		(IO_ADDRESS(GPT_BASE_ADDR(x) + 0x00))
+#define MXC_GPT_TPRER(x)	(IO_ADDRESS(GPT_BASE_ADDR(x) + 0x04))
+#define MXC_GPT_TCMP(x)		(IO_ADDRESS(GPT_BASE_ADDR(x) + 0x08))
+#define MXC_GPT_TCR(x)		(IO_ADDRESS(GPT_BASE_ADDR(x) + 0x0C))
+#define MXC_GPT_TCN(x)		(IO_ADDRESS(GPT_BASE_ADDR(x) + 0x10))
+#define MXC_GPT_TSTAT(x)	(IO_ADDRESS(GPT_BASE_ADDR(x) + 0x14))
+#define MXC_GPT_GPTCNT		MXC_GPT_TCN(MXC_TIMER_GPT1)
+#define GPT_TSTAT_COMP		(1 << 0)
+#define GPT_TSTAT_CAPT		(1 << 1)
+#define GPT_TCTL_TEN		(1 << 0)
+#define GPT_TCTL_SRC_PER1	(1 << 1)
+#define GPT_TCTL_SRC_PER1_DIV4	(2 << 1)
+#define GPT_TCTL_SRC_TIN	(3 << 1)
+#define GPT_TCTL_SRC_32K	(4 << 1)
+#define GPT_TCTL_COMPEN		(1 << 4)
+#define GPT_TCTL_CAPTEN		(1 << 5)
+#define GPT_TCTL_FRR		(1 << 8)
+#define GPT_TCTL_OM		(1 << 9)
+#define GPT_TCTL_CC		(1 << 10)
+#define GPT_TCTL_SWR		(1 << 15)
+#else
 #define MXC_GPT_GPTCR		IO_ADDRESS(GPT1_BASE_ADDR + 0x00)
 #define MXC_GPT_GPTPR		IO_ADDRESS(GPT1_BASE_ADDR + 0x04)
 #define MXC_GPT_GPTSR		IO_ADDRESS(GPT1_BASE_ADDR + 0x08)
@@ -55,6 +78,7 @@
 #define MXC_GPT_GPTICR1		IO_ADDRESS(GPT1_BASE_ADDR + 0x1C)
 #define MXC_GPT_GPTICR2		IO_ADDRESS(GPT1_BASE_ADDR + 0x20)
 #define MXC_GPT_GPTCNT		IO_ADDRESS(GPT1_BASE_ADDR + 0x24)
+#endif				/* #if defined(CONFIG_ARCH_MX27) */
 
 /* GPT Control register bit definitions */
 #define GPTCR_FO3			(1 << 31)
