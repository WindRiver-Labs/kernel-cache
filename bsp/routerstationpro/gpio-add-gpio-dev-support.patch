From 00e0a07ae927b8c15d087219adf0773ca1bb5a90 Mon Sep 17 00:00:00 2001
From: Zumeng Chen <zumeng.chen@windriver.com>
Date: Sun, 9 Jan 2011 23:36:55 +0800
Subject: [PATCH 08/10] gpio: add gpio dev support

Patches come from backfire_10.03
  backfire/target/linux/generic-2.6/patches-2.6.32:
    410-gpio_buttons.patch
    420-gpiodev.patch

Integrated-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 drivers/char/Kconfig              |    8 ++
 drivers/char/Makefile             |    1 +
 drivers/char/gpio_dev.c           |  196 +++++++++++++++++++++++++++++++++
 drivers/input/misc/Kconfig        |   16 +++
 drivers/input/misc/Makefile       |    1 +
 drivers/input/misc/gpio_buttons.c |  215 +++++++++++++++++++++++++++++++++++++
 drivers/mtd/mtdchar.c             |    4 +-
 drivers/mtd/mtdpart.c             |    2 +-
 drivers/mtd/nand/rb4xx_nand.c     |    1 +
 drivers/net/phy/rtl8306.c         |   43 ++++----
 drivers/watchdog/ar71xx_wdt.c     |    2 +-
 11 files changed, 464 insertions(+), 25 deletions(-)
 create mode 100644 drivers/char/gpio_dev.c
 create mode 100644 drivers/input/misc/gpio_buttons.c

diff --git a/drivers/char/Kconfig b/drivers/char/Kconfig
index 43d3395..35dd8fc 100644
--- a/drivers/char/Kconfig
+++ b/drivers/char/Kconfig
@@ -1047,6 +1047,14 @@ config CS5535_GPIO
 
 	  If compiled as a module, it will be called cs5535_gpio.
 
+config GPIO_DEVICE
+	tristate "GPIO device support"
+	depends on GENERIC_GPIO
+	help
+	  Say Y to enable Linux GPIO device support.  This allows control of
+	  GPIO pins using a character device
+
+
 config RAW_DRIVER
 	tristate "RAW driver (/dev/raw/rawN)"
 	depends on BLOCK
diff --git a/drivers/char/Makefile b/drivers/char/Makefile
index ba53ec9..bf93937 100644
--- a/drivers/char/Makefile
+++ b/drivers/char/Makefile
@@ -82,6 +82,7 @@ obj-$(CONFIG_SCx200_GPIO)	+= scx200_gpio.o
 obj-$(CONFIG_PC8736x_GPIO)	+= pc8736x_gpio.o
 obj-$(CONFIG_NSC_GPIO)		+= nsc_gpio.o
 obj-$(CONFIG_CS5535_GPIO)	+= cs5535_gpio.o
+obj-$(CONFIG_GPIO_DEVICE)	+= gpio_dev.o
 obj-$(CONFIG_GPIO_TB0219)	+= tb0219.o
 obj-$(CONFIG_TELCLOCK)		+= tlclk.o
 
diff --git a/drivers/char/gpio_dev.c b/drivers/char/gpio_dev.c
new file mode 100644
index 0000000..c91c639
--- /dev/null
+++ b/drivers/char/gpio_dev.c
@@ -0,0 +1,196 @@
+/*
+ * character device wrapper for generic gpio layer
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA02111-1307USA
+ *
+ * Feedback, Bugs...  blogic@openwrt.org
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <asm/uaccess.h>
+#include <asm/io.h>
+#include <asm/gpio.h>
+#include <asm/atomic.h>
+#include <linux/init.h>
+#include <linux/genhd.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/gpio_dev.h>
+
+#define DRVNAME		"gpiodev"
+#define DEVNAME		"gpio"
+
+static int dev_major;
+static unsigned int gpio_access_mask;
+static struct class *gpiodev_class;
+
+/* Counter is 1, if the device is not opened and zero (or less) if opened. */
+static atomic_t gpio_open_cnt = ATOMIC_INIT(1);
+
+static int
+gpio_ioctl(struct inode *inode, struct file *file, unsigned int cmd, unsigned long arg)
+{
+	int retval = 0;
+
+	if (((1 << arg) & gpio_access_mask) != (1 << arg)) {
+		retval = -EINVAL;
+		goto out;
+	}
+
+	switch (cmd) {
+	case GPIO_GET:
+		retval = gpio_get_value(arg);
+		break;
+
+	case GPIO_SET:
+		gpio_set_value(arg, 1);
+		break;
+
+	case GPIO_CLEAR:
+		gpio_set_value(arg, 0);
+		break;
+
+	case GPIO_DIR_IN:
+		gpio_direction_input(arg);
+		break;
+
+	case GPIO_DIR_OUT:
+		gpio_direction_output(arg, 0);
+		break;
+
+	default:
+		retval = -EINVAL;
+		break;
+	}
+
+out:
+	return retval;
+}
+
+static int
+gpio_open(struct inode *inode, struct file *file)
+{
+	int result = 0;
+	unsigned int dev_minor = MINOR(inode->i_rdev);
+
+	if (dev_minor != 0) {
+		printk(KERN_ERR DRVNAME ": trying to access unknown minor device -> %d\n", dev_minor);
+		result = -ENODEV;
+		goto out;
+	}
+
+	/* FIXME: We should really allow multiple applications to open the device
+	 *        at the same time, as long as the apps access different IO pins.
+	 *        The generic gpio-registration functions can be used for that.
+	 *        Two new IOCTLs have to be introduced for that. Need to check userspace
+	 *        compatibility first. --mb */
+	if (!atomic_dec_and_test(&gpio_open_cnt)) {
+		atomic_inc(&gpio_open_cnt);
+		printk(KERN_ERR DRVNAME ": Device with minor ID %d already in use\n", dev_minor);
+		result = -EBUSY;
+		goto out;
+	}
+
+out:
+	return result;
+}
+
+static int
+gpio_close(struct inode *inode, struct file *file)
+{
+	smp_mb__before_atomic_inc();
+	atomic_inc(&gpio_open_cnt);
+
+	return 0;
+}
+
+struct file_operations gpio_fops = {
+	compat_ioctl:		gpio_ioctl,
+	open:		gpio_open,
+	release:	gpio_close
+};
+
+static int
+gpio_probe(struct platform_device *dev)
+{
+	int result = 0;
+
+	dev_major = register_chrdev(0, DEVNAME, &gpio_fops);
+	if (!dev_major) {
+		printk(KERN_ERR DRVNAME ": Error whilst opening %s \n", DEVNAME);
+		result = -ENODEV;
+		goto out;
+	}
+
+	gpiodev_class = class_create(THIS_MODULE, DRVNAME);
+	device_create(gpiodev_class, NULL, MKDEV(dev_major, 0), dev, DEVNAME);
+
+	printk(KERN_INFO DRVNAME ": gpio device registered with major %d\n", dev_major);
+
+	if (dev->num_resources != 1) {
+		printk(KERN_ERR DRVNAME ": device may only have 1 resource\n");
+		result = -ENODEV;
+		goto out;
+	}
+
+	gpio_access_mask = dev->resource[0].start;
+
+	printk(KERN_INFO DRVNAME ": gpio platform device registered with access mask %08X\n", gpio_access_mask);
+out:
+	return result;
+}
+
+static int
+gpio_remove(struct platform_device *dev)
+{
+	unregister_chrdev(dev_major, DEVNAME);
+	return 0;
+}
+
+static struct
+platform_driver gpio_driver = {
+	.probe = gpio_probe,
+	.remove = gpio_remove,
+	.driver = {
+		.name = "GPIODEV",
+		.owner = THIS_MODULE,
+	},
+};
+
+static int __init
+gpio_mod_init(void)
+{
+	int ret = platform_driver_register(&gpio_driver);
+	if (ret)
+		printk(KERN_INFO DRVNAME ": Error registering platfom driver!");
+
+	return ret;
+}
+
+static void __exit
+gpio_mod_exit(void)
+{
+	platform_driver_unregister(&gpio_driver);
+}
+
+module_init (gpio_mod_init);
+module_exit (gpio_mod_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("John Crispin / OpenWrt");
+MODULE_DESCRIPTION("Character device for for generic gpio api");
diff --git a/drivers/input/misc/Kconfig b/drivers/input/misc/Kconfig
index b99b8cb..3439b79 100644
--- a/drivers/input/misc/Kconfig
+++ b/drivers/input/misc/Kconfig
@@ -448,4 +448,20 @@ config INPUT_ADXL34X_SPI
 	  To compile this driver as a module, choose M here: the
 	  module will be called adxl34x-spi.
 
+config INPUT_GPIO_BUTTONS
+	tristate "Polled GPIO buttons interface"
+	depends on GENERIC_GPIO
+	select INPUT_POLLDEV
+	help
+	  This driver implements support for buttons connected
+	  to GPIO pins of various CPUs (and some other chips).
+
+	  Say Y here if your device has buttons connected
+	  directly to such GPIO pins.  Your board-specific
+	  setup logic must also provide a platform device,
+	  with configuration data saying which GPIOs are used.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called gpio-buttons.
+
 endif
diff --git a/drivers/input/misc/Makefile b/drivers/input/misc/Makefile
index 1fe1f6c..3791050 100644
--- a/drivers/input/misc/Makefile
+++ b/drivers/input/misc/Makefile
@@ -42,4 +42,5 @@ obj-$(CONFIG_INPUT_WINBOND_CIR)		+= winbond-cir.o
 obj-$(CONFIG_INPUT_WISTRON_BTNS)	+= wistron_btns.o
 obj-$(CONFIG_INPUT_WM831X_ON)		+= wm831x-on.o
 obj-$(CONFIG_INPUT_YEALINK)		+= yealink.o
+obj-$(CONFIG_INPUT_GPIO_BUTTONS)	+= gpio_buttons.o
 
diff --git a/drivers/input/misc/gpio_buttons.c b/drivers/input/misc/gpio_buttons.c
new file mode 100644
index 0000000..22b9951
--- /dev/null
+++ b/drivers/input/misc/gpio_buttons.c
@@ -0,0 +1,215 @@
+/*
+ *  Driver for buttons on GPIO lines not capable of generating interrupts
+ *
+ *  Copyright (C) 2007-2010 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2010 Nuno Goncalves <nunojpg@gmail.com>
+ *
+ *  This file was based on: /drivers/input/misc/cobalt_btns.c
+ *	Copyright (C) 2007 Yoichi Yuasa <yoichi_yuasa@tripeaks.co.jp>
+ *
+ *  also was based on: /drivers/input/keyboard/gpio_keys.c
+ *	Copyright 2005 Phil Blundell
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+
+#include <linux/input.h>
+#include <linux/input-polldev.h>
+#include <linux/ioport.h>
+#include <linux/platform_device.h>
+
+#include <linux/gpio_buttons.h>
+
+#include <asm/gpio.h>
+
+#define DRV_NAME	"gpio-buttons"
+#define DRV_VERSION	"0.1.2"
+#define PFX		DRV_NAME ": "
+
+struct gpio_button_data {
+	int last_state;
+	int count;
+};
+
+struct gpio_buttons_dev {
+	struct input_polled_dev *poll_dev;
+	struct gpio_buttons_platform_data *pdata;
+	struct gpio_button_data *data;
+};
+
+static void gpio_buttons_poll(struct input_polled_dev *dev)
+{
+	struct gpio_buttons_dev *bdev = dev->private;
+	struct gpio_buttons_platform_data *pdata = bdev->pdata;
+	struct input_dev *input = dev->input;
+	int i;
+
+	for (i = 0; i < bdev->pdata->nbuttons; i++) {
+		struct gpio_button *button = &pdata->buttons[i];
+		unsigned int type = button->type ?: EV_KEY;
+		int state;
+
+		if (bdev->data[i].count < button->threshold) {
+			bdev->data[i].count++;
+			continue;
+		}
+
+		state = gpio_get_value(button->gpio) ? 1 : 0;
+		if (state != bdev->data[i].last_state) {
+			input_event(input, type, button->code,
+				    !!(state ^ button->active_low));
+			input_sync(input);
+			bdev->data[i].count = 0;
+			bdev->data[i].last_state = state;
+		}
+	}
+}
+
+static int __devinit gpio_buttons_probe(struct platform_device *pdev)
+{
+	struct gpio_buttons_platform_data *pdata = pdev->dev.platform_data;
+	struct gpio_buttons_dev *bdev;
+	struct input_polled_dev *poll_dev;
+	struct input_dev *input;
+	int error, i;
+
+	if (!pdata)
+		return -ENXIO;
+
+	bdev = kzalloc(sizeof(struct gpio_buttons_dev) +
+		       sizeof(struct gpio_button_data) *pdata->nbuttons,
+		       GFP_KERNEL);
+	if (!bdev) {
+		printk(KERN_ERR DRV_NAME "no memory for device\n");
+		return -ENOMEM;
+	}
+
+	bdev->data = (struct gpio_button_data *) &bdev[1];
+
+	poll_dev = input_allocate_polled_device();
+	if (!poll_dev) {
+		printk(KERN_ERR DRV_NAME "no memory for polled device\n");
+		error = -ENOMEM;
+		goto err_free_bdev;
+	}
+
+	poll_dev->private = bdev;
+	poll_dev->poll = gpio_buttons_poll;
+	poll_dev->poll_interval = pdata->poll_interval;
+
+	input = poll_dev->input;
+
+	input->evbit[0] = BIT(EV_KEY);
+	input->name = pdev->name;
+	input->phys = "gpio-buttons/input0";
+	input->dev.parent = &pdev->dev;
+
+	input->id.bustype = BUS_HOST;
+	input->id.vendor = 0x0001;
+	input->id.product = 0x0001;
+	input->id.version = 0x0100;
+
+	for (i = 0; i < pdata->nbuttons; i++) {
+		struct gpio_button *button = &pdata->buttons[i];
+		unsigned int gpio = button->gpio;
+		unsigned int type = button->type ?: EV_KEY;
+
+		error = gpio_request(gpio, button->desc ?
+				button->desc : DRV_NAME);
+		if (error) {
+			printk(KERN_ERR PFX "unable to claim gpio %u, "
+				"error %d\n", gpio, error);
+			goto err_free_gpio;
+		}
+
+		error = gpio_direction_input(gpio);
+		if (error) {
+			printk(KERN_ERR PFX "unable to set direction on "
+				"gpio %u, error %d\n", gpio, error);
+			goto err_free_gpio;
+		}
+
+		input_set_capability(input, type, button->code);
+		bdev->data[i].last_state = gpio_get_value(button->gpio) ? 1 : 0;
+	}
+
+	bdev->poll_dev = poll_dev;
+	bdev->pdata = pdata;
+	platform_set_drvdata(pdev, bdev);
+
+	error = input_register_polled_device(poll_dev);
+	if (error) {
+		printk(KERN_ERR PFX "unable to register polled device, "
+			"error %d\n", error);
+		goto err_free_gpio;
+	}
+
+	return 0;
+
+err_free_gpio:
+	for (i = i - 1; i >= 0; i--)
+		gpio_free(pdata->buttons[i].gpio);
+
+	input_free_polled_device(poll_dev);
+
+err_free_bdev:
+	kfree(bdev);
+
+	platform_set_drvdata(pdev, NULL);
+	return error;
+}
+
+static int __devexit gpio_buttons_remove(struct platform_device *pdev)
+{
+	struct gpio_buttons_dev *bdev = platform_get_drvdata(pdev);
+	struct gpio_buttons_platform_data *pdata = bdev->pdata;
+	int i;
+
+	input_unregister_polled_device(bdev->poll_dev);
+
+	for (i = 0; i < pdata->nbuttons; i++)
+		gpio_free(pdata->buttons[i].gpio);
+
+	input_free_polled_device(bdev->poll_dev);
+
+	kfree(bdev);
+	platform_set_drvdata(pdev, NULL);
+
+	return 0;
+}
+
+static struct platform_driver gpio_buttons_driver = {
+	.probe	= gpio_buttons_probe,
+	.remove	= __devexit_p(gpio_buttons_remove),
+	.driver	= {
+		.name	= DRV_NAME,
+		.owner	= THIS_MODULE,
+	},
+};
+
+static int __init gpio_buttons_init(void)
+{
+	printk(KERN_INFO DRV_NAME " driver version " DRV_VERSION "\n");
+	return platform_driver_register(&gpio_buttons_driver);
+}
+
+static void __exit gpio_buttons_exit(void)
+{
+	platform_driver_unregister(&gpio_buttons_driver);
+}
+
+module_init(gpio_buttons_init);
+module_exit(gpio_buttons_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Gabor Juhos <juhosg at openwrt.org>");
+MODULE_VERSION(DRV_VERSION);
+MODULE_DESCRIPTION("Polled buttons driver for CPU GPIOs");
+
diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index 3049593..7dd90e8 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -770,7 +770,7 @@ static int mtd_ioctl(struct file *file, u_int cmd, u_long arg)
 	{
 		struct erase_info_user einfo;
 
-		printk ("#####%s  %d  ISLOCKED=0x%x cmd=0x%x\n", __func__, __ILNE__, MEMISLOCKED, cmd);
+		printk ("#####%s  %d  ISLOCKED=0x%x cmd=0x%x\n", __func__, __LINE__, MEMISLOCKED, cmd);
 		if (copy_from_user(&einfo, argp, sizeof(einfo)))
 			return -EFAULT;
 
@@ -817,7 +817,7 @@ static int mtd_ioctl(struct file *file, u_int cmd, u_long arg)
 #ifdef CONFIG_MTD_PARTITIONS
 	case MTDREFRESH:
 	{
-		printk ("#####%s  %d  FRESH=0x%x cmd=0x%x\n", __func__, __ILNE__, MTDREFRESH, cmd);
+		printk ("#####%s  %d  FRESH=0x%x cmd=0x%x\n", __func__, __LINE__, MTDREFRESH, cmd);
 		ret = refresh_mtd_partitions(mtd);
 		break;
 	}
diff --git a/drivers/mtd/mtdpart.c b/drivers/mtd/mtdpart.c
index ca189e4..3628197 100644
--- a/drivers/mtd/mtdpart.c
+++ b/drivers/mtd/mtdpart.c
@@ -701,7 +701,7 @@ static int split_rootfs_data(struct mtd_info *master, struct mtd_info *rpart, co
 	printk(KERN_INFO "mtd: partition \"%s\" created automatically, ofs=%llX, len=%llX \n",
 		ROOTFS_SPLIT_NAME, dpart->offset, dpart->size);
 
-	slave = add_one_partition(master, dpart, 0, split_offset);
+	slave = allocate_partition(master, dpart, 0, split_offset);
 	if (!slave) {
 		kfree(dpart);
 		return -ENOMEM;
diff --git a/drivers/mtd/nand/rb4xx_nand.c b/drivers/mtd/nand/rb4xx_nand.c
index 5087794..de07a70 100644
--- a/drivers/mtd/nand/rb4xx_nand.c
+++ b/drivers/mtd/nand/rb4xx_nand.c
@@ -13,6 +13,7 @@
  */
 
 #include <linux/init.h>
+#include <linux/slab.h>
 #include <linux/mtd/nand.h>
 #include <linux/mtd/mtd.h>
 #include <linux/mtd/partitions.h>
diff --git a/drivers/net/phy/rtl8306.c b/drivers/net/phy/rtl8306.c
index 3d0fe81..87c661a 100644
--- a/drivers/net/phy/rtl8306.c
+++ b/drivers/net/phy/rtl8306.c
@@ -26,7 +26,7 @@
 #include <linux/delay.h>
 #include <linux/phy.h>
 
-/* #define DEBUG 1 */
+//#define DEBUG 1
 
 /* Global (PHY0) */
 #define RTL8306_REG_PAGE		16
@@ -134,8 +134,8 @@ enum rtl_regidx {
 	RTL_REG_VLAN_TAG_ONLY,
 	RTL_REG_VLAN_TAG_AWARE,
 #define RTL_VLAN_ENUM(id) \
-	(RTL_REG_VLAN##id##_VID, \
-	RTL_REG_VLAN##id##_PORTMASK)
+	RTL_REG_VLAN##id##_VID, \
+	RTL_REG_VLAN##id##_PORTMASK
 	RTL_VLAN_ENUM(0),
 	RTL_VLAN_ENUM(1),
 	RTL_VLAN_ENUM(2),
@@ -153,7 +153,7 @@ enum rtl_regidx {
 	RTL_VLAN_ENUM(14),
 	RTL_VLAN_ENUM(15),
 #define RTL_PORT_ENUM(id) \
-	(RTL_REG_PORT##id##_PVID, \
+	RTL_REG_PORT##id##_PVID, \
 	RTL_REG_PORT##id##_NULL_VID_REPLACE, \
 	RTL_REG_PORT##id##_NON_PVID_DISCARD, \
 	RTL_REG_PORT##id##_VID_INSERT, \
@@ -164,7 +164,7 @@ enum rtl_regidx {
 	RTL_REG_PORT##id##_NRESTART, \
 	RTL_REG_PORT##id##_DUPLEX, \
 	RTL_REG_PORT##id##_RXEN, \
-	RTL_REG_PORT##id##_TXEN)
+	RTL_REG_PORT##id##_TXEN
 	RTL_PORT_ENUM(0),
 	RTL_PORT_ENUM(1),
 	RTL_PORT_ENUM(2),
@@ -200,18 +200,18 @@ static const struct rtl_reg rtl_regs[] = {
 	[RTL_REG_VLAN_ENABLE]    = { 0, 0, 18,  1,  8, 1 },
 
 #define RTL_VLAN_REGS(id, phy, page, regofs) \
-	([RTL_REG_VLAN##id##_VID] = { page, phy, 25 + regofs, 12, 0, 0 }, \
-	[RTL_REG_VLAN##id##_PORTMASK] = { page, phy, 24 + regofs, 6, 0, 0 })
-	RTL_VLAN_REGS(0, 0, 0, 0),
-	RTL_VLAN_REGS(1, 1, 0, 0),
-	RTL_VLAN_REGS(2, 2, 0, 0),
-	RTL_VLAN_REGS(3, 3, 0, 0),
-	RTL_VLAN_REGS(4, 4, 0, 0),
-	RTL_VLAN_REGS(5, 0, 1, 2),
-	RTL_VLAN_REGS(6, 1, 1, 2),
-	RTL_VLAN_REGS(7, 2, 1, 2),
-	RTL_VLAN_REGS(8, 3, 1, 2),
-	RTL_VLAN_REGS(9, 4, 1, 2),
+	[RTL_REG_VLAN##id##_VID] = { page, phy, 25 + regofs, 12, 0, 0 }, \
+	[RTL_REG_VLAN##id##_PORTMASK] = { page, phy, 24 + regofs, 6, 0, 0 }
+	RTL_VLAN_REGS( 0, 0, 0, 0),
+	RTL_VLAN_REGS( 1, 1, 0, 0),
+	RTL_VLAN_REGS( 2, 2, 0, 0),
+	RTL_VLAN_REGS( 3, 3, 0, 0),
+	RTL_VLAN_REGS( 4, 4, 0, 0),
+	RTL_VLAN_REGS( 5, 0, 1, 2),
+	RTL_VLAN_REGS( 6, 1, 1, 2),
+	RTL_VLAN_REGS( 7, 2, 1, 2),
+	RTL_VLAN_REGS( 8, 3, 1, 2),
+	RTL_VLAN_REGS( 9, 4, 1, 2),
 	RTL_VLAN_REGS(10, 0, 1, 4),
 	RTL_VLAN_REGS(11, 1, 1, 4),
 	RTL_VLAN_REGS(12, 2, 1, 4),
@@ -220,7 +220,7 @@ static const struct rtl_reg rtl_regs[] = {
 	RTL_VLAN_REGS(15, 0, 1, 6),
 
 #define REG_PORT_SETTING(port, phy) \
-	([RTL_REG_PORT##port##_SPEED] = { 0, phy, 0, 1, 13, 0 }, \
+	[RTL_REG_PORT##port##_SPEED] = { 0, phy, 0, 1, 13, 0 }, \
 	[RTL_REG_PORT##port##_NWAY] = { 0, phy, 0, 1, 12, 0 }, \
 	[RTL_REG_PORT##port##_NRESTART] = { 0, phy, 0, 1, 9, 0 }, \
 	[RTL_REG_PORT##port##_DUPLEX] = { 0, phy, 0, 1, 8, 0 }, \
@@ -230,7 +230,7 @@ static const struct rtl_reg rtl_regs[] = {
 	[RTL_REG_PORT##port##_NULL_VID_REPLACE] = { 0, phy, 22, 1, 12, 0 }, \
 	[RTL_REG_PORT##port##_NON_PVID_DISCARD] = { 0, phy, 22, 1, 11, 0 }, \
 	[RTL_REG_PORT##port##_VID_INSERT] = { 0, phy, 22, 2, 9, 0 }, \
-	[RTL_REG_PORT##port##_TAG_INSERT] = { 0, phy, 22, 2, 0, 0 })
+	[RTL_REG_PORT##port##_TAG_INSERT] = { 0, phy, 22, 2, 0, 0 }
 
 	REG_PORT_SETTING(0, 0),
 	REG_PORT_SETTING(1, 1),
@@ -659,7 +659,8 @@ rtl_set_ports(struct switch_dev *dev, struct switch_val *val)
 	unsigned int oldmask;
 	int i;
 
-	for (i = 0; i < val->len; i++) {
+	for(i = 0; i < val->len; i++)
+	{
 		struct switch_port *port = &val->value.ports[i];
 		bool tagged = false;
 
@@ -878,7 +879,7 @@ rtl8306_config_init(struct phy_device *pdev)
 	chipid = rtl_get(dev, RTL_REG_CHIPID);
 	chipver = rtl_get(dev, RTL_REG_CHIPVER);
 	chiptype = rtl_get(dev, RTL_REG_CHIPTYPE);
-	switch (chiptype) {
+	switch(chiptype) {
 	case 0:
 	case 2:
 		strncpy(priv->hwname, RTL_NAME_S, sizeof(priv->hwname));
diff --git a/drivers/watchdog/ar71xx_wdt.c b/drivers/watchdog/ar71xx_wdt.c
index c1bf463..c46a3ae 100644
--- a/drivers/watchdog/ar71xx_wdt.c
+++ b/drivers/watchdog/ar71xx_wdt.c
@@ -197,7 +197,7 @@ static int ar71xx_wdt_ioctl(struct inode *inode, struct file *file,
 static const struct file_operations ar71xx_wdt_fops = {
 	.owner		= THIS_MODULE,
 	.write		= ar71xx_wdt_write,
-	.ioctl		= ar71xx_wdt_ioctl,
+	.compat_ioctl	= ar71xx_wdt_ioctl,
 	.open		= ar71xx_wdt_open,
 	.release	= ar71xx_wdt_release,
 };
-- 
1.7.0.4

