From 8b6b2da7417d883570848ed662f2830081a97270 Mon Sep 17 00:00:00 2001
From: Zumeng Chen <zumeng.chen@windriver.com>
Date: Thu, 24 Nov 2011 15:30:58 +0800
Subject: [PATCH 22/41] Integrate mips fixes from 3.0 for ar71xx

which from the following git repo.
  git://nbd.name/openwrt.git
  300-mips_expose_boot_raw.patch
  301-mips_image_cmdline_hack.patch
  302-mips_use_generic_thread_info_allocator.patch
  303-mips_fix_kexec.patch
  304-mips_disable_fpu.patch
  305-mips_module_reloc.patch
  306-mips_mem_functions_performance.patch
  307-mips_oprofile_fix.patch

Integrated-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 arch/mips/Kconfig                    |   24 +++-
 arch/mips/Makefile                   |    5 +
 arch/mips/include/asm/module.h       |    5 +
 arch/mips/include/asm/string.h       |   33 ++++
 arch/mips/kernel/head.S              |    2 -
 arch/mips/kernel/machine_kexec.c     |    2 +-
 arch/mips/kernel/module.c            |  274 +++++++++++++++++++++++++++++++---
 arch/mips/lib/Makefile               |    2 +-
 arch/mips/lib/memcmp.c               |   22 +++
 arch/mips/math-emu/Makefile          |    6 +-
 arch/mips/math-emu/cp1emu.c          |   18 ++-
 arch/mips/math-emu/dsemul.c          |    7 +
 arch/mips/math-emu/kernel_linkage.c  |   35 ++++-
 arch/mips/oprofile/op_model_mipsxx.c |   12 ++
 14 files changed, 410 insertions(+), 37 deletions(-)
 create mode 100644 arch/mips/lib/memcmp.c

diff --git a/arch/mips/Kconfig b/arch/mips/Kconfig
index 37287cd..93a7de2 100644
--- a/arch/mips/Kconfig
+++ b/arch/mips/Kconfig
@@ -869,9 +869,6 @@ config ARC
 config ARCH_MAY_HAVE_PC_FDC
 	bool
 
-config BOOT_RAW
-	bool
-
 config CEVT_BCM1480
 	bool
 
@@ -956,6 +953,17 @@ config I8259
 config MIPS_BONITO64
 	bool
 
+config MIPS_FPU_EMU
+	bool "Enable FPU emulation"
+	default y
+	help
+	   This option allows building a kernel with or without the Algorithmics
+	   FPU emulator enabled. Turning off this option results in a kernel which
+	   does not catch floating operations exceptions. Make sure that your toolchain
+	   is configured to enable software floating point emulation in that case.
+		
+	   If unsure say Y here.
+
 config MIPS_MSC
 	bool
 
@@ -2329,6 +2337,16 @@ config USE_OF
 	help
 	  Include support for flattened device tree machine descriptions.
 
+config BOOT_RAW
+	bool "Enable the kernel to be executed from the load address"
+	default n
+	help
+	 Allow the kernel to be executed from the load address for
+	 bootloaders which cannot read the ELF format. This places
+	 a jump to start_kernel at the load address.
+
+	 If unsure, say N.
+
 endmenu
 
 config LOCKDEP_SUPPORT
diff --git a/arch/mips/Makefile b/arch/mips/Makefile
index 2a6af27..fc48d30 100644
--- a/arch/mips/Makefile
+++ b/arch/mips/Makefile
@@ -90,8 +90,13 @@ all-$(CONFIG_SYS_SUPPORTS_ZBOOT)+= vmlinuz
 cflags-y			+= -G 0 -mno-abicalls -fno-pic -pipe
 cflags-y			+= -msoft-float
 LDFLAGS_vmlinux			+= -G 0 -static -n -nostdlib
+ifdef CONFIG_ATHEROS_AR71XX
+KBUILD_AFLAGS_MODULE		+= -mno-long-calls
+KBUILD_CFLAGS_MODULE		+= -mno-long-calls
+else
 KBUILD_AFLAGS_MODULE		+= -mlong-calls
 KBUILD_CFLAGS_MODULE		+= -mlong-calls
+endif
 
 cflags-y += -ffreestanding
 
diff --git a/arch/mips/include/asm/module.h b/arch/mips/include/asm/module.h
index bc01a02..bc872d3 100644
--- a/arch/mips/include/asm/module.h
+++ b/arch/mips/include/asm/module.h
@@ -9,6 +9,11 @@ struct mod_arch_specific {
 	struct list_head dbe_list;
 	const struct exception_table_entry *dbe_start;
 	const struct exception_table_entry *dbe_end;
+
+	void *phys_plt_tbl;
+	void *virt_plt_tbl;
+	unsigned int phys_plt_offset;
+	unsigned int virt_plt_offset;
 };
 
 typedef uint8_t Elf64_Byte;		/* Type for a 8-bit quantity.  */
diff --git a/arch/mips/include/asm/string.h b/arch/mips/include/asm/string.h
index 436e3ad..5a66ec4 100644
--- a/arch/mips/include/asm/string.h
+++ b/arch/mips/include/asm/string.h
@@ -133,11 +133,44 @@ strncmp(__const__ char *__cs, __const__ char *__ct, size_t __count)
 
 #define __HAVE_ARCH_MEMSET
 extern void *memset(void *__s, int __c, size_t __count);
+#define memset(__s, __c, len)					\
+({								\
+	size_t __len = (len);					\
+	void *__ret;						\
+	if (__builtin_constant_p(len) && __len >= 64)		\
+		__ret = memset((__s), (__c), __len);		\
+	else							\
+		__ret = __builtin_memset((__s), (__c), __len);	\
+	__ret;							\
+})
 
 #define __HAVE_ARCH_MEMCPY
 extern void *memcpy(void *__to, __const__ void *__from, size_t __n);
+#define memcpy(dst, src, len)					\
+({								\
+	size_t __len = (len);					\
+	void *__ret;						\
+	if (__builtin_constant_p(len) && __len >= 64)		\
+		__ret = memcpy((dst), (src), __len);		\
+	else							\
+		__ret = __builtin_memcpy((dst), (src), __len);	\
+	__ret;							\
+})
 
 #define __HAVE_ARCH_MEMMOVE
 extern void *memmove(void *__dest, __const__ void *__src, size_t __n);
+#define memmove(dst, src, len)					\
+({								\
+	size_t __len = (len);					\
+	void *__ret;						\
+	if (__builtin_constant_p(len) && __len >= 64)		\
+		__ret = memmove((dst), (src), __len);		\
+	else							\
+		__ret = __builtin_memmove((dst), (src), __len);	\
+	__ret;							\
+})
+
+#define __HAVE_ARCH_MEMCMP
+#define memcmp(src1, src2, len) __builtin_memcmp((src1), (src2), (len))
 
 #endif /* _ASM_STRING_H */
diff --git a/arch/mips/kernel/head.S b/arch/mips/kernel/head.S
index 57a8029..5bb5240 100644
--- a/arch/mips/kernel/head.S
+++ b/arch/mips/kernel/head.S
@@ -121,8 +121,6 @@
 #endif
 	.endm
 
-	j kernel_entry
-	nop
 #ifndef CONFIG_NO_EXCEPT_FILL
 	/*
 	 * Reserved space for exception handlers.
diff --git a/arch/mips/kernel/machine_kexec.c b/arch/mips/kernel/machine_kexec.c
index 85beb9b..c9567a1 100644
--- a/arch/mips/kernel/machine_kexec.c
+++ b/arch/mips/kernel/machine_kexec.c
@@ -52,7 +52,7 @@ machine_kexec(struct kimage *image)
 	reboot_code_buffer =
 	  (unsigned long)page_address(image->control_code_page);
 
-	kexec_start_address = image->start;
+	kexec_start_address = (unsigned long) phys_to_virt(image->start);
 	kexec_indirection_page =
 		(unsigned long) phys_to_virt(image->head & PAGE_MASK);
 
diff --git a/arch/mips/kernel/module.c b/arch/mips/kernel/module.c
index dd940b7..dcad842 100644
--- a/arch/mips/kernel/module.c
+++ b/arch/mips/kernel/module.c
@@ -45,6 +45,117 @@ static struct mips_hi16 *mips_hi16_list;
 static LIST_HEAD(dbe_list);
 static DEFINE_SPINLOCK(dbe_lock);
 
+/*
+ * Get the potential max trampolines size required of the init and
+ * non-init sections. Only used if we cannot find enough contiguous
+ * physically mapped memory to put the module into.
+ */
+static unsigned int
+get_plt_size(const Elf_Ehdr *hdr, const Elf_Shdr *sechdrs,
+             const char *secstrings, unsigned int symindex, bool is_init)
+{
+	unsigned long ret = 0;
+	unsigned int i, j;
+	Elf_Sym *syms;
+
+	/* Everything marked ALLOC (this includes the exported symbols) */
+	for (i = 1; i < hdr->e_shnum; ++i) {
+		unsigned int info = sechdrs[i].sh_info;
+
+		if (sechdrs[i].sh_type != SHT_REL
+		    && sechdrs[i].sh_type != SHT_RELA)
+			continue;
+
+		/* Not a valid relocation section? */
+		if (info >= hdr->e_shnum)
+			continue;
+
+		/* Don't bother with non-allocated sections */
+		if (!(sechdrs[info].sh_flags & SHF_ALLOC))
+			continue;
+
+		/* If it's called *.init*, and we're not init, we're
+                   not interested */
+		if ((strstr(secstrings + sechdrs[i].sh_name, ".init") != 0)
+		    != is_init)
+			continue;
+
+		syms = (Elf_Sym *) sechdrs[symindex].sh_addr;
+		if (sechdrs[i].sh_type == SHT_REL) {
+			Elf_Mips_Rel *rel = (void *) sechdrs[i].sh_addr;
+			unsigned int size = sechdrs[i].sh_size / sizeof(*rel);
+
+			for (j = 0; j < size; ++j) {
+				Elf_Sym *sym;
+
+				if (ELF_MIPS_R_TYPE(rel[j]) != R_MIPS_26)
+					continue;
+
+				sym = syms + ELF_MIPS_R_SYM(rel[j]);
+				if (!is_init && sym->st_shndx != SHN_UNDEF)
+					continue;
+
+				ret += 4 * sizeof(int);
+			}
+		} else {
+			Elf_Mips_Rela *rela = (void *) sechdrs[i].sh_addr;
+			unsigned int size = sechdrs[i].sh_size / sizeof(*rela);
+
+			for (j = 0; j < size; ++j) {
+				Elf_Sym *sym;
+
+				if (ELF_MIPS_R_TYPE(rela[j]) != R_MIPS_26)
+					continue;
+
+				sym = syms + ELF_MIPS_R_SYM(rela[j]);
+				if (!is_init && sym->st_shndx != SHN_UNDEF)
+					continue;
+
+				ret += 4 * sizeof(int);
+			}
+		}
+	}
+
+	return ret;
+}
+
+#ifndef MODULE_START
+static void *alloc_phys(unsigned long size)
+{
+	unsigned order;
+	struct page *page;
+	struct page *p;
+
+	size = PAGE_ALIGN(size);
+	order = get_order(size);
+
+	page = alloc_pages(GFP_KERNEL | __GFP_NORETRY | __GFP_NOWARN |
+			__GFP_THISNODE, order);
+	if (!page)
+		return NULL;
+
+	split_page(page, order);
+
+	for (p = page + (size >> PAGE_SHIFT); p < page + (1 << order); ++p)
+		__free_page(p);
+
+	return page_address(page);
+}
+#endif
+
+static void free_phys(void *ptr, unsigned long size)
+{
+	struct page *page;
+	struct page *end;
+
+	page = virt_to_page(ptr);
+	end = page + (PAGE_ALIGN(size) >> PAGE_SHIFT);
+
+	for (; page < end; ++page)
+		__free_page(page);
+}
+
+
 void *module_alloc(unsigned long size)
 {
 #ifdef MODULE_START
@@ -52,21 +163,99 @@ void *module_alloc(unsigned long size)
 				GFP_KERNEL, PAGE_KERNEL, -1,
 				__builtin_return_address(0));
 #else
+	void *ptr;
+
 	if (size == 0)
 		return NULL;
-	return vmalloc(size);
+
+	ptr = alloc_phys(size);
+
+	/* If we failed to allocate physically contiguous memory,
+	 * fall back to regular vmalloc. The module loader code will
+	 * create jump tables to handle long jumps */
+	if (!ptr)
+		return vmalloc(size);
+
+	return ptr;
+#endif
+}
+
+static inline bool is_phys_addr(void *ptr)
+{
+#ifdef CONFIG_64BIT
+	return (KSEGX((unsigned long)ptr) == CKSEG0);
+#else
+	return (KSEGX(ptr) == KSEG0);
 #endif
 }
 
 /* Free memory returned from module_alloc */
 void module_free(struct module *mod, void *module_region)
 {
-	vfree(module_region);
+	if (is_phys_addr(module_region)) {
+		if (mod->module_init == module_region)
+			free_phys(module_region, mod->init_size);
+		else if (mod->module_core == module_region)
+			free_phys(module_region, mod->core_size);
+		else
+			BUG();
+	} else {
+		vfree(module_region);
+	}
+}
+
+static void *__module_alloc(int size, bool phys)
+{
+	void *ptr;
+
+	if (phys)
+		ptr = kmalloc(size, GFP_KERNEL);
+	else
+		ptr = vmalloc(size);
+	return ptr;
+}
+
+static void __module_free(void *ptr)
+{
+	if (is_phys_addr(ptr))
+		kfree(ptr);
+	else
+		vfree(ptr);
 }
 
 int module_frob_arch_sections(Elf_Ehdr *hdr, Elf_Shdr *sechdrs,
 			      char *secstrings, struct module *mod)
 {
+	unsigned int symindex = 0;
+	unsigned int core_size, init_size;
+	int i;
+
+	for (i = 1; i < hdr->e_shnum; i++)
+		if (sechdrs[i].sh_type == SHT_SYMTAB)
+			symindex = i;
+
+	core_size = get_plt_size(hdr, sechdrs, secstrings, symindex, false);
+	init_size = get_plt_size(hdr, sechdrs, secstrings, symindex, true);
+
+	mod->arch.phys_plt_offset = 0;
+	mod->arch.virt_plt_offset = 0;
+	mod->arch.phys_plt_tbl = NULL;
+	mod->arch.virt_plt_tbl = NULL;
+
+	if ((core_size + init_size) == 0)
+		return 0;
+
+	mod->arch.phys_plt_tbl = __module_alloc(core_size + init_size, 1);
+	if (!mod->arch.phys_plt_tbl)
+		return -ENOMEM;
+
+	mod->arch.virt_plt_tbl = __module_alloc(core_size + init_size, 0);
+	if (!mod->arch.virt_plt_tbl) {
+		__module_free(mod->arch.phys_plt_tbl);
+		mod->arch.phys_plt_tbl = NULL;
+		return -ENOMEM;
+	}
+
 	return 0;
 }
 
@@ -89,28 +278,36 @@ static int apply_r_mips_32_rela(struct module *me, u32 *location, Elf_Addr v)
 	return 0;
 }
 
-static int apply_r_mips_26_rel(struct module *me, u32 *location, Elf_Addr v)
+static Elf_Addr add_plt_entry_to(unsigned *plt_offset,
+				 void *start, Elf_Addr v)
 {
-	if (v % 4) {
-		pr_err("module %s: dangerous R_MIPS_26 REL relocation\n",
-		       me->name);
-		return -ENOEXEC;
-	}
+	unsigned *tramp = start + *plt_offset;
+	*plt_offset += 4 * sizeof(int);
 
-	if ((v & 0xf0000000) != (((unsigned long)location + 4) & 0xf0000000)) {
-		printk(KERN_ERR
-		       "module %s: relocation overflow\n",
-		       me->name);
-		return -ENOEXEC;
-	}
+	/* adjust carry for addiu */
+	if (v & 0x00008000)
+		v += 0x10000;
 
-	*location = (*location & ~0x03ffffff) |
-	            ((*location + (v >> 2)) & 0x03ffffff);
+	tramp[0] = 0x3c190000 | (v >> 16);      /* lui t9, hi16 */
+	tramp[1] = 0x27390000 | (v & 0xffff);   /* addiu t9, t9, lo16 */
+	tramp[2] = 0x03200008;                  /* jr t9 */
+	tramp[3] = 0x00000000;                  /* nop */
 
-	return 0;
+	return (Elf_Addr) tramp;
 }
 
-static int apply_r_mips_26_rela(struct module *me, u32 *location, Elf_Addr v)
+static Elf_Addr add_plt_entry(struct module *me, void *location, Elf_Addr v)
+{
+	if (is_phys_addr(location))
+		return add_plt_entry_to(&me->arch.phys_plt_offset,
+				me->arch.phys_plt_tbl, v);
+	else
+		return add_plt_entry_to(&me->arch.virt_plt_offset,
+				me->arch.virt_plt_tbl, v);
+
+}
+
+static int set_r_mips_26(struct module *me, u32 *location, u32 ofs, Elf_Addr v)
 {
 	if (v % 4) {
 		pr_err("module %s: dangerous R_MIPS_26 RELArelocation\n",
@@ -119,17 +316,31 @@ static int apply_r_mips_26_rela(struct module *me, u32 *location, Elf_Addr v)
 	}
 
 	if ((v & 0xf0000000) != (((unsigned long)location + 4) & 0xf0000000)) {
-		printk(KERN_ERR
+	    v = add_plt_entry(me, location, v + (ofs << 2));
+		if (!v) {
+			printk(KERN_ERR
 		       "module %s: relocation overflow\n",
 		       me->name);
-		return -ENOEXEC;
+			return -ENOEXEC;
+		}
+		ofs = 0;
 	}
 
-	*location = (*location & ~0x03ffffff) | ((v >> 2) & 0x03ffffff);
+	*location = (*location & ~0x03ffffff) | ((ofs + (v >> 2)) & 0x03ffffff);
 
 	return 0;
 }
 
+static int apply_r_mips_26_rel(struct module *me, u32 *location, Elf_Addr v)
+{
+	return set_r_mips_26(me, location, *location & 0x03ffffff, v);
+}
+
+static int apply_r_mips_26_rela(struct module *me, u32 *location, Elf_Addr v)
+{
+	return set_r_mips_26(me, location, 0, v);
+}
+
 static int apply_r_mips_hi16_rel(struct module *me, u32 *location, Elf_Addr v)
 {
 	struct mips_hi16 *n;
@@ -397,11 +608,32 @@ int module_finalize(const Elf_Ehdr *hdr,
 		list_add(&me->arch.dbe_list, &dbe_list);
 		spin_unlock_irq(&dbe_lock);
 	}
+
+	/* Get rid of the fixup trampoline if we're running the module
+	 * from physically mapped address space */
+	if (me->arch.phys_plt_offset == 0) {
+		__module_free(me->arch.phys_plt_tbl);
+		me->arch.phys_plt_tbl = NULL;
+	}
+	if (me->arch.virt_plt_offset == 0) {
+		__module_free(me->arch.virt_plt_tbl);
+		me->arch.virt_plt_tbl = NULL;
+	}
+
 	return 0;
 }
 
 void module_arch_cleanup(struct module *mod)
 {
+	if (mod->arch.phys_plt_tbl) {
+		__module_free(mod->arch.phys_plt_tbl);
+		mod->arch.phys_plt_tbl = NULL;
+	}
+	if (mod->arch.virt_plt_tbl) {
+		__module_free(mod->arch.virt_plt_tbl);
+		mod->arch.virt_plt_tbl = NULL;
+	}
+
 	spin_lock_irq(&dbe_lock);
 	list_del(&mod->arch.dbe_list);
 	spin_unlock_irq(&dbe_lock);
diff --git a/arch/mips/lib/Makefile b/arch/mips/lib/Makefile
index b2cad4f..6ac2032 100644
--- a/arch/mips/lib/Makefile
+++ b/arch/mips/lib/Makefile
@@ -3,7 +3,7 @@
 #
 
 lib-y	+= csum_partial.o delay.o memcpy.o memcpy-inatomic.o memset.o \
-	   strlen_user.o strncpy_user.o strnlen_user.o uncached.o
+	   strlen_user.o strncpy_user.o strnlen_user.o uncached.o memcmp.o
 
 obj-y			+= iomap.o
 obj-$(CONFIG_PCI)	+= iomap-pci.o
diff --git a/arch/mips/lib/memcmp.c b/arch/mips/lib/memcmp.c
new file mode 100644
index 0000000..35ef164
--- /dev/null
+++ b/arch/mips/lib/memcmp.c
@@ -0,0 +1,22 @@
+/*
+ *  copied from linux/lib/string.c
+ *
+ *  Copyright (C) 1991, 1992  Linus Torvalds
+ */
+
+#include <linux/module.h>
+#include <linux/string.h>
+
+#undef memcmp
+int memcmp(const void *cs, const void *ct, size_t count)
+{
+	const unsigned char *su1, *su2;
+	int res = 0;
+
+	for (su1 = cs, su2 = ct; 0 < count; ++su1, ++su2, count--)
+		if ((res = *su1 - *su2) != 0)
+			break;
+	return res;
+}
+EXPORT_SYMBOL(memcmp);
+
diff --git a/arch/mips/math-emu/Makefile b/arch/mips/math-emu/Makefile
index 9660723..62dab5a 100644
--- a/arch/mips/math-emu/Makefile
+++ b/arch/mips/math-emu/Makefile
@@ -2,11 +2,13 @@
 # Makefile for the Linux/MIPS kernel FPU emulation.
 #
 
-obj-y	:= cp1emu.o ieee754m.o ieee754d.o ieee754dp.o ieee754sp.o ieee754.o \
+obj-y	:=	kernel_linkage.o dsemul.o cp1emu.o
+
+obj-$(CONFIG_MIPS_FPU_EMU)	+= ieee754m.o ieee754d.o ieee754dp.o ieee754sp.o ieee754.o \
 	   ieee754xcpt.o dp_frexp.o dp_modf.o dp_div.o dp_mul.o dp_sub.o \
 	   dp_add.o dp_fsp.o dp_cmp.o dp_logb.o dp_scalb.o dp_simple.o \
 	   dp_tint.o dp_fint.o dp_tlong.o dp_flong.o sp_frexp.o sp_modf.o \
 	   sp_div.o sp_mul.o sp_sub.o sp_add.o sp_fdp.o sp_cmp.o sp_logb.o \
 	   sp_scalb.o sp_simple.o sp_tint.o sp_fint.o sp_tlong.o sp_flong.o \
-	   dp_sqrt.o sp_sqrt.o kernel_linkage.o dsemul.o
+	   dp_sqrt.o sp_sqrt.o
 
diff --git a/arch/mips/math-emu/cp1emu.c b/arch/mips/math-emu/cp1emu.c
index d32cb05..4fc9f64 100644
--- a/arch/mips/math-emu/cp1emu.c
+++ b/arch/mips/math-emu/cp1emu.c
@@ -58,7 +58,11 @@
 #define __mips 4
 
 /* Function which emulates a floating point instruction. */
+#ifdef CONFIG_DEBUG_FS
+DEFINE_PER_CPU(struct mips_fpu_emulator_stats, fpuemustats);
+#endif
 
+#ifdef CONFIG_MIPS_FPU_EMU
 static int fpu_emu(struct pt_regs *, struct mips_fpu_struct *,
 	mips_instruction);
 
@@ -69,10 +73,6 @@ static int fpux_emu(struct pt_regs *,
 
 /* Further private data for which no space exists in mips_fpu_struct */
 
-#ifdef CONFIG_DEBUG_FS
-DEFINE_PER_CPU(struct mips_fpu_emulator_stats, fpuemustats);
-#endif
-
 /* Control registers */
 
 #define FPCREG_RID	0	/* $0  = revision id */
@@ -1361,7 +1361,6 @@ int fpu_emulator_cop1Handler(struct pt_regs *xcp, struct mips_fpu_struct *ctx,
 
 	return sig;
 }
-
 #ifdef CONFIG_DEBUG_FS
 
 static int fpuemu_stat_get(void *data, u64 *val)
@@ -1410,4 +1409,11 @@ static int __init debugfs_fpuemu(void)
 	return 0;
 }
 __initcall(debugfs_fpuemu);
-#endif
+#endif /* CONFIG_DEBUGFS */
+#else
+int fpu_emulator_cop1Handler(struct pt_regs *xcp, struct mips_fpu_struct *ctx,
+        int has_fpu)
+{
+	return 0;
+}
+#endif /* CONFIG_MIPS_FPU_EMU */
diff --git a/arch/mips/math-emu/dsemul.c b/arch/mips/math-emu/dsemul.c
index 3c4a8c5..410b27e 100644
--- a/arch/mips/math-emu/dsemul.c
+++ b/arch/mips/math-emu/dsemul.c
@@ -109,6 +109,7 @@ int mips_dsemul(struct pt_regs *regs, mips_instruction ir, unsigned long cpc)
 	return SIGILL;		/* force out of emulation loop */
 }
 
+#ifdef CONFIG_MIPS_FPU_EMU
 int do_dsemulret(struct pt_regs *xcp)
 {
 	struct emuframe __user *fr;
@@ -165,3 +166,9 @@ int do_dsemulret(struct pt_regs *xcp)
 
 	return 1;
 }
+#else
+int do_dsemulret(struct pt_regs *xcp)
+{
+	return 0;
+}
+#endif /* CONFIG_MIPS_FPU_EMU */
diff --git a/arch/mips/math-emu/kernel_linkage.c b/arch/mips/math-emu/kernel_linkage.c
index 52e6c58..c1d923e 100644
--- a/arch/mips/math-emu/kernel_linkage.c
+++ b/arch/mips/math-emu/kernel_linkage.c
@@ -29,6 +29,7 @@
 
 #define SIGNALLING_NAN 0x7ff800007ff80000LL
 
+#ifdef CONFIG_MIPS_FPU_EMU
 void fpu_emulator_init_fpu(void)
 {
 	static int first = 1;
@@ -112,4 +113,36 @@ int fpu_emulator_restore_context32(struct sigcontext32 __user *sc)
 
 	return err;
 }
-#endif
+#endif	/* CONFIG_64BIT */
+#else
+
+void fpu_emulator_init_fpu(void)
+{
+	printk(KERN_INFO "FPU emulator disabled, make sure your toolchain"
+		"was compiled with software floating point support (soft-float)\n");
+	return;
+}
+
+int fpu_emulator_save_context(struct sigcontext __user *sc)
+{
+	return 0;
+}
+
+int fpu_emulator_restore_context(struct sigcontext __user *sc)
+{
+	return 0;
+}
+
+int fpu_emulator_save_context32(struct sigcontext32 __user *sc)
+{
+	return 0;
+}
+
+int fpu_emulator_restore_context32(struct sigcontext32 __user *sc)
+{
+	return 0;
+}
+
+#ifdef CONFIG_64BIT
+#endif	/* CONFIG_64BIT */
+#endif /* CONFIG_MIPS_FPU_EMU */
diff --git a/arch/mips/oprofile/op_model_mipsxx.c b/arch/mips/oprofile/op_model_mipsxx.c
index 54759f1..86cf234 100644
--- a/arch/mips/oprofile/op_model_mipsxx.c
+++ b/arch/mips/oprofile/op_model_mipsxx.c
@@ -298,6 +298,11 @@ static void reset_counters(void *arg)
 	}
 }
 
+static irqreturn_t mipsxx_perfcount_int(int irq, void *dev_id)
+{
+	return mipsxx_perfcount_handler();
+}
+
 static int __init mipsxx_init(void)
 {
 	int counters;
@@ -374,6 +379,10 @@ static int __init mipsxx_init(void)
 	save_perf_irq = perf_irq;
 	perf_irq = mipsxx_perfcount_handler;
 
+	if (cp0_perfcount_irq >= 0)
+		return request_irq(cp0_perfcount_irq, mipsxx_perfcount_int,
+			IRQF_SHARED, "Perfcounter", save_perf_irq);
+
 	return 0;
 }
 
@@ -381,6 +390,9 @@ static void mipsxx_exit(void)
 {
 	int counters = op_model_mipsxx_ops.num_counters;
 
+	if (cp0_perfcount_irq >= 0)
+		free_irq(cp0_perfcount_irq, save_perf_irq);
+
 	counters = counters_per_cpu_to_total(counters);
 	on_each_cpu(reset_counters, (void *)(long)counters, 1);
 
-- 
1.7.4.1

