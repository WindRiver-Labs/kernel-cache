From 1b094f87e6aae7633944a72f350301e7dd445e68 Mon Sep 17 00:00:00 2001
From: Zumeng Chen <zumeng.chen@windriver.com>
Date: Wed, 29 Sep 2010 09:38:42 +0800
Subject: [PATCH 01/41] Add arch suport for ar71xx

Which is downloaded from the following:
  https://dev.openwrt.org/browser/branches
  branches_backfire_target_linux_ar71xx_files-r23140.zip

Integrated-By: Zumeng Chen <zumegn.chen@windriver.com>
---
 arch/mips/Kconfig                     |   18 +
 arch/mips/Makefile                    |    7 +
 arch/mips/ar71xx/Kconfig              |  256 +++++++++++++++
 arch/mips/ar71xx/Makefile             |   54 +++
 arch/mips/ar71xx/ar71xx.c             |  177 ++++++++++
 arch/mips/ar71xx/dev-ap91-eth.c       |   70 ++++
 arch/mips/ar71xx/dev-ap91-eth.h       |   23 ++
 arch/mips/ar71xx/dev-ap91-pci.c       |  114 +++++++
 arch/mips/ar71xx/dev-ap91-pci.h       |   21 ++
 arch/mips/ar71xx/dev-ap94-pci.c       |  159 +++++++++
 arch/mips/ar71xx/dev-ap94-pci.h       |   28 ++
 arch/mips/ar71xx/dev-ar913x-wmac.c    |   68 ++++
 arch/mips/ar71xx/dev-ar913x-wmac.h    |   19 ++
 arch/mips/ar71xx/dev-dsa.c            |   50 +++
 arch/mips/ar71xx/dev-dsa.h            |   20 ++
 arch/mips/ar71xx/dev-gpio-buttons.c   |   58 ++++
 arch/mips/ar71xx/dev-gpio-buttons.h   |   25 ++
 arch/mips/ar71xx/dev-leds-gpio.c      |   56 ++++
 arch/mips/ar71xx/dev-leds-gpio.h      |   21 ++
 arch/mips/ar71xx/dev-m25p80.c         |   30 ++
 arch/mips/ar71xx/dev-m25p80.h         |   16 +
 arch/mips/ar71xx/dev-pb42-pci.c       |   40 +++
 arch/mips/ar71xx/dev-pb42-pci.h       |   21 ++
 arch/mips/ar71xx/dev-pb9x-pci.c       |   33 ++
 arch/mips/ar71xx/dev-pb9x-pci.h       |   22 ++
 arch/mips/ar71xx/dev-usb.c            |  181 +++++++++++
 arch/mips/ar71xx/dev-usb.h            |   17 +
 arch/mips/ar71xx/devices.c            |  575 +++++++++++++++++++++++++++++++++
 arch/mips/ar71xx/devices.h            |   48 +++
 arch/mips/ar71xx/early_printk.c       |   30 ++
 arch/mips/ar71xx/gpio.c               |  182 +++++++++++
 arch/mips/ar71xx/irq.c                |  295 +++++++++++++++++
 arch/mips/ar71xx/mach-ap81.c          |  140 ++++++++
 arch/mips/ar71xx/mach-ap83.c          |  266 +++++++++++++++
 arch/mips/ar71xx/mach-aw-nr580.c      |  101 ++++++
 arch/mips/ar71xx/mach-dir-600-a1.c    |  138 ++++++++
 arch/mips/ar71xx/mach-dir-615-c1.c    |  173 ++++++++++
 arch/mips/ar71xx/mach-dir-825-b1.c    |  192 +++++++++++
 arch/mips/ar71xx/mach-mzk-w04nu.c     |  165 ++++++++++
 arch/mips/ar71xx/mach-mzk-w300nh.c    |  158 +++++++++
 arch/mips/ar71xx/mach-pb42.c          |   71 ++++
 arch/mips/ar71xx/mach-pb44.c          |  207 ++++++++++++
 arch/mips/ar71xx/mach-pb92.c          |  109 +++++++
 arch/mips/ar71xx/mach-rb4xx.c         |  290 +++++++++++++++++
 arch/mips/ar71xx/mach-rb750.c         |  133 ++++++++
 arch/mips/ar71xx/mach-tew-632brp.c    |  149 +++++++++
 arch/mips/ar71xx/mach-tl-wr1043nd.c   |  156 +++++++++
 arch/mips/ar71xx/mach-tl-wr741nd.c    |  131 ++++++++
 arch/mips/ar71xx/mach-tl-wr841n.c     |  143 ++++++++
 arch/mips/ar71xx/mach-tl-wr941nd.c    |  142 ++++++++
 arch/mips/ar71xx/mach-ubnt.c          |  281 ++++++++++++++++
 arch/mips/ar71xx/mach-wndr3700.c      |  209 ++++++++++++
 arch/mips/ar71xx/mach-wnr2000.c       |  148 +++++++++
 arch/mips/ar71xx/mach-wp543.c         |   99 ++++++
 arch/mips/ar71xx/mach-wrt160nl.c      |  158 +++++++++
 arch/mips/ar71xx/mach-wrt400n.c       |  168 ++++++++++
 arch/mips/ar71xx/mach-wzr-hp-g300nh.c |  265 +++++++++++++++
 arch/mips/ar71xx/machtype.h           |   59 ++++
 arch/mips/ar71xx/nvram.c              |   75 +++++
 arch/mips/ar71xx/nvram.h              |   19 ++
 arch/mips/ar71xx/pci.c                |   93 ++++++
 arch/mips/ar71xx/prom.c               |  166 ++++++++++
 arch/mips/ar71xx/setup.c              |  310 ++++++++++++++++++
 63 files changed, 7648 insertions(+), 0 deletions(-)
 create mode 100644 arch/mips/ar71xx/Kconfig
 create mode 100644 arch/mips/ar71xx/Makefile
 create mode 100644 arch/mips/ar71xx/ar71xx.c
 create mode 100644 arch/mips/ar71xx/dev-ap91-eth.c
 create mode 100644 arch/mips/ar71xx/dev-ap91-eth.h
 create mode 100644 arch/mips/ar71xx/dev-ap91-pci.c
 create mode 100644 arch/mips/ar71xx/dev-ap91-pci.h
 create mode 100644 arch/mips/ar71xx/dev-ap94-pci.c
 create mode 100644 arch/mips/ar71xx/dev-ap94-pci.h
 create mode 100644 arch/mips/ar71xx/dev-ar913x-wmac.c
 create mode 100644 arch/mips/ar71xx/dev-ar913x-wmac.h
 create mode 100644 arch/mips/ar71xx/dev-dsa.c
 create mode 100644 arch/mips/ar71xx/dev-dsa.h
 create mode 100644 arch/mips/ar71xx/dev-gpio-buttons.c
 create mode 100644 arch/mips/ar71xx/dev-gpio-buttons.h
 create mode 100644 arch/mips/ar71xx/dev-leds-gpio.c
 create mode 100644 arch/mips/ar71xx/dev-leds-gpio.h
 create mode 100644 arch/mips/ar71xx/dev-m25p80.c
 create mode 100644 arch/mips/ar71xx/dev-m25p80.h
 create mode 100644 arch/mips/ar71xx/dev-pb42-pci.c
 create mode 100644 arch/mips/ar71xx/dev-pb42-pci.h
 create mode 100644 arch/mips/ar71xx/dev-pb9x-pci.c
 create mode 100644 arch/mips/ar71xx/dev-pb9x-pci.h
 create mode 100644 arch/mips/ar71xx/dev-usb.c
 create mode 100644 arch/mips/ar71xx/dev-usb.h
 create mode 100644 arch/mips/ar71xx/devices.c
 create mode 100644 arch/mips/ar71xx/devices.h
 create mode 100644 arch/mips/ar71xx/early_printk.c
 create mode 100644 arch/mips/ar71xx/gpio.c
 create mode 100644 arch/mips/ar71xx/irq.c
 create mode 100644 arch/mips/ar71xx/mach-ap81.c
 create mode 100644 arch/mips/ar71xx/mach-ap83.c
 create mode 100644 arch/mips/ar71xx/mach-aw-nr580.c
 create mode 100644 arch/mips/ar71xx/mach-dir-600-a1.c
 create mode 100644 arch/mips/ar71xx/mach-dir-615-c1.c
 create mode 100644 arch/mips/ar71xx/mach-dir-825-b1.c
 create mode 100644 arch/mips/ar71xx/mach-mzk-w04nu.c
 create mode 100644 arch/mips/ar71xx/mach-mzk-w300nh.c
 create mode 100644 arch/mips/ar71xx/mach-pb42.c
 create mode 100644 arch/mips/ar71xx/mach-pb44.c
 create mode 100644 arch/mips/ar71xx/mach-pb92.c
 create mode 100644 arch/mips/ar71xx/mach-rb4xx.c
 create mode 100644 arch/mips/ar71xx/mach-rb750.c
 create mode 100644 arch/mips/ar71xx/mach-tew-632brp.c
 create mode 100644 arch/mips/ar71xx/mach-tl-wr1043nd.c
 create mode 100644 arch/mips/ar71xx/mach-tl-wr741nd.c
 create mode 100644 arch/mips/ar71xx/mach-tl-wr841n.c
 create mode 100644 arch/mips/ar71xx/mach-tl-wr941nd.c
 create mode 100644 arch/mips/ar71xx/mach-ubnt.c
 create mode 100644 arch/mips/ar71xx/mach-wndr3700.c
 create mode 100644 arch/mips/ar71xx/mach-wnr2000.c
 create mode 100644 arch/mips/ar71xx/mach-wp543.c
 create mode 100644 arch/mips/ar71xx/mach-wrt160nl.c
 create mode 100644 arch/mips/ar71xx/mach-wrt400n.c
 create mode 100644 arch/mips/ar71xx/mach-wzr-hp-g300nh.c
 create mode 100644 arch/mips/ar71xx/machtype.h
 create mode 100644 arch/mips/ar71xx/nvram.c
 create mode 100644 arch/mips/ar71xx/nvram.h
 create mode 100644 arch/mips/ar71xx/pci.c
 create mode 100644 arch/mips/ar71xx/prom.c
 create mode 100644 arch/mips/ar71xx/setup.c

diff --git a/arch/mips/Kconfig b/arch/mips/Kconfig
index b762223..1b66312 100644
--- a/arch/mips/Kconfig
+++ b/arch/mips/Kconfig
@@ -85,6 +85,23 @@ config ATH79
 	help
 	  Support for the Atheros AR71XX/AR724X/AR913X SoCs.
 
+config ATHEROS_AR71XX
+	bool "Atheros AR71xx based boards"
+	select CEVT_R4K
+	select CSRC_R4K
+	select DMA_NONCOHERENT
+	select HW_HAS_PCI
+	select IRQ_CPU
+	select ARCH_REQUIRE_GPIOLIB
+	select SYS_HAS_CPU_MIPS32_R1
+	select SYS_HAS_CPU_MIPS32_R2
+	select SYS_SUPPORTS_32BIT_KERNEL
+	select SYS_SUPPORTS_BIG_ENDIAN
+	select SYS_HAS_EARLY_PRINTK
+	select MIPS_MACHINE
+	help
+	  Support for Atheros AR71xx based boards.
+
 config BCM47XX
 	bool "Broadcom BCM47XX based boards"
 	select CEVT_R4K
@@ -786,6 +803,7 @@ endchoice
 
 source "arch/mips/alchemy/Kconfig"
 source "arch/mips/ath79/Kconfig"
+source "arch/mips/ar71xx/Kconfig"
 source "arch/mips/bcm63xx/Kconfig"
 source "arch/mips/jazz/Kconfig"
 source "arch/mips/jz4740/Kconfig"
diff --git a/arch/mips/Makefile b/arch/mips/Makefile
index 884819c..010bafb 100644
--- a/arch/mips/Makefile
+++ b/arch/mips/Makefile
@@ -158,6 +158,13 @@ cflags-$(CONFIG_CPU_CAVIUM_OCTEON) += -Wa,-march=octeon
 endif
 cflags-$(CONFIG_CAVIUM_CN63XXP1) += -Wa,-mfix-cn63xxp1
 
+#
+# Atheros AR71xx
+#
+core-$(CONFIG_ATHEROS_AR71XX)	+= arch/mips/ar71xx/
+cflags-$(CONFIG_ATHEROS_AR71XX)	+= -I$(srctree)/arch/mips/include/asm/mach-ar71xx
+load-$(CONFIG_ATHEROS_AR71XX)	+= 0xffffffff80060000
+
 cflags-$(CONFIG_CPU_R4000_WORKAROUNDS)	+= $(call cc-option,-mfix-r4000,)
 cflags-$(CONFIG_CPU_R4400_WORKAROUNDS)	+= $(call cc-option,-mfix-r4400,)
 cflags-$(CONFIG_CPU_DADDI_WORKAROUNDS)	+= $(call cc-option,-mno-daddi,)
diff --git a/arch/mips/ar71xx/Kconfig b/arch/mips/ar71xx/Kconfig
new file mode 100644
index 0000000..c471e3f
--- /dev/null
+++ b/arch/mips/ar71xx/Kconfig
@@ -0,0 +1,256 @@
+if ATHEROS_AR71XX
+
+menu "Atheros AR71xx machine selection"
+
+config AR71XX_MACH_AP81
+	bool "Atheros AP81 board support"
+	select AR71XX_DEV_M25P80
+	select AR71XX_DEV_AR913X_WMAC
+	select AR71XX_DEV_GPIO_BUTTONS
+	select AR71XX_DEV_LEDS_GPIO
+	select AR71XX_DEV_USB
+	default n
+
+config AR71XX_MACH_AP83
+	bool "Atheros AP83 board support"
+	select AR71XX_DEV_AR913X_WMAC
+	select AR71XX_DEV_GPIO_BUTTONS
+	select AR71XX_DEV_LEDS_GPIO
+	select AR71XX_DEV_USB
+	default n
+
+config AR71XX_MACH_DIR_600_A1
+	bool "D-Link DIR-600 rev. A1 support"
+	select AR71XX_DEV_AP91_ETH
+	select AR71XX_DEV_AP91_PCI if PCI
+	select AR71XX_DEV_M25P80
+	select AR71XX_DEV_GPIO_BUTTONS
+	select AR71XX_DEV_LEDS_GPIO
+	select AR71XX_NVRAM
+	default n
+
+config AR71XX_MACH_DIR_615_C1
+	bool "D-Link DIR-615 rev. C1 support"
+	select AR71XX_DEV_M25P80
+	select AR71XX_DEV_AR913X_WMAC
+	select AR71XX_DEV_GPIO_BUTTONS
+	select AR71XX_DEV_LEDS_GPIO
+	select AR71XX_NVRAM
+	default n
+
+config AR71XX_MACH_DIR_825_B1
+	bool "D-Link DIR-825 rev. B1 board support"
+	select AR71XX_DEV_M25P80
+	select AR71XX_DEV_AP94_PCI if PCI
+	select AR71XX_DEV_GPIO_BUTTONS
+	select AR71XX_DEV_LEDS_GPIO
+	select AR71XX_DEV_USB
+	default n
+
+config AR71XX_MACH_PB42
+	bool "Atheros PB42 board support"
+	select AR71XX_DEV_M25P80
+	select AR71XX_DEV_GPIO_BUTTONS
+	select AR71XX_DEV_PB42_PCI if PCI
+	default n
+
+config AR71XX_MACH_PB44
+	bool "Atheros PB44 board support"
+	select AR71XX_DEV_GPIO_BUTTONS
+	select AR71XX_DEV_PB42_PCI if PCI
+	select AR71XX_DEV_LEDS_GPIO
+	select AR71XX_DEV_USB
+	default n
+
+config AR71XX_MACH_PB92
+	bool "Atheros PB92 board support"
+	select AR71XX_DEV_GPIO_BUTTONS
+	select AR71XX_DEV_PB9X_PCI if PCI
+	select AR71XX_DEV_LEDS_GPIO
+	select AR71XX_DEV_USB
+	default n
+
+config AR71XX_MACH_AW_NR580
+	bool "AzureWave AW-NR580 board support"
+	select AR71XX_DEV_M25P80
+	select AR71XX_DEV_GPIO_BUTTONS
+	select AR71XX_DEV_PB42_PCI if PCI
+	select AR71XX_DEV_LEDS_GPIO
+	default n
+
+config AR71XX_MACH_WZR_HP_G300NH
+	bool "Buffalo WZR-HP-G300NH board support"
+	select AR71XX_DEV_AR913X_WMAC
+	select AR71XX_DEV_GPIO_BUTTONS
+	select AR71XX_DEV_LEDS_GPIO
+	select AR71XX_DEV_USB
+	default y
+
+config AR71XX_MACH_WP543
+	bool "Compex WP543/WPJ543 board support"
+	select MYLOADER
+	select AR71XX_DEV_M25P80
+	select AR71XX_DEV_GPIO_BUTTONS
+	select AR71XX_DEV_PB42_PCI if PCI
+	select AR71XX_DEV_LEDS_GPIO
+	select AR71XX_DEV_USB
+	default n
+
+config AR71XX_MACH_WRT160NL
+	bool "Linksys WRT160NL board support"
+	select AR71XX_DEV_M25P80
+	select AR71XX_DEV_AR913X_WMAC
+	select AR71XX_DEV_GPIO_BUTTONS
+	select AR71XX_DEV_LEDS_GPIO
+	select AR71XX_DEV_USB
+	select AR71XX_NVRAM
+	default n
+
+config AR71XX_MACH_WRT400N
+	bool "Linksys WRT400N board support"
+	select AR71XX_DEV_AP94_PCI if PCI
+	select AR71XX_DEV_M25P80
+	select AR71XX_DEV_GPIO_BUTTONS
+	select AR71XX_DEV_LEDS_GPIO
+	default n
+
+config AR71XX_MACH_RB4XX
+	bool "MikroTik RouterBOARD 4xx series support"
+	select AR71XX_DEV_GPIO_BUTTONS
+	select AR71XX_DEV_LEDS_GPIO
+	select AR71XX_DEV_USB
+	default n
+
+config AR71XX_MACH_RB750
+	bool "MikroTik RouterBOARD 750 support"
+	select AR71XX_DEV_AP91_ETH
+	default n
+
+config AR71XX_MACH_WNDR3700
+	bool "NETGEAR WNDR3700 board support"
+	select AR71XX_DEV_M25P80
+	select AR71XX_DEV_AP94_PCI if PCI
+	select AR71XX_DEV_GPIO_BUTTONS
+	select AR71XX_DEV_LEDS_GPIO
+	select AR71XX_DEV_USB
+	default n
+
+config AR71XX_MACH_WNR2000
+	bool "NETGEAR WNR2000 board support"
+	select AR71XX_DEV_M25P80
+	select AR71XX_DEV_AR913X_WMAC
+	select AR71XX_DEV_GPIO_BUTTONS
+	select AR71XX_DEV_LEDS_GPIO
+	default n
+
+config AR71XX_MACH_MZK_W04NU
+	bool "Planex MZK-W04NU board support"
+	select AR71XX_DEV_M25P80
+	select AR71XX_DEV_AR913X_WMAC
+	select AR71XX_DEV_GPIO_BUTTONS
+	select AR71XX_DEV_LEDS_GPIO
+	select AR71XX_DEV_USB
+	default n
+
+config AR71XX_MACH_MZK_W300NH
+	bool "Planex MZK-W300NH board support"
+	select AR71XX_DEV_M25P80
+	select AR71XX_DEV_AR913X_WMAC
+	select AR71XX_DEV_GPIO_BUTTONS
+	select AR71XX_DEV_LEDS_GPIO
+	default n
+
+config AR71XX_MACH_TL_WR741ND
+	bool "TP-LINK TL-WR741ND support"
+	select AR71XX_DEV_M25P80
+	select AR71XX_DEV_AP91_PCI if PCI
+	select AR71XX_DEV_GPIO_BUTTONS
+	select AR71XX_DEV_LEDS_GPIO
+	default n
+
+config AR71XX_MACH_TL_WR841N_V1
+	bool "TP-LINK TL-WR841N v1 support"
+	select AR71XX_DEV_M25P80
+	select AR71XX_DEV_PB42_PCI if PCI
+	select AR71XX_DEV_DSA
+	select AR71XX_DEV_GPIO_BUTTONS
+	select AR71XX_DEV_LEDS_GPIO
+	default n
+
+config AR71XX_MACH_TL_WR941ND
+	bool "TP-LINK TL-WR941ND support"
+	select AR71XX_DEV_M25P80
+	select AR71XX_DEV_AR913X_WMAC
+	select AR71XX_DEV_DSA
+	select AR71XX_DEV_GPIO_BUTTONS
+	select AR71XX_DEV_LEDS_GPIO
+	default n
+
+config AR71XX_MACH_TL_WR1043ND
+	bool "TP-LINK TL-WR1043ND support"
+	select AR71XX_DEV_M25P80
+	select AR71XX_DEV_AR913X_WMAC
+	select AR71XX_DEV_GPIO_BUTTONS
+	select AR71XX_DEV_LEDS_GPIO
+	select AR71XX_DEV_USB
+	default n
+
+config AR71XX_MACH_TEW_632BRP
+	bool "TRENDnet TEW-632BRP support"
+	select AR71XX_DEV_M25P80
+	select AR71XX_DEV_AR913X_WMAC
+	select AR71XX_DEV_GPIO_BUTTONS
+	select AR71XX_DEV_LEDS_GPIO
+	select AR71XX_NVRAM
+	default n
+
+config AR71XX_MACH_UBNT
+	bool "Ubiquiti AR71xx based boards support"
+	select AR71XX_DEV_M25P80
+	select AR71XX_DEV_AP91_PCI if PCI
+	select AR71XX_DEV_GPIO_BUTTONS
+	select AR71XX_DEV_LEDS_GPIO
+	select AR71XX_DEV_PB42_PCI if PCI
+	select AR71XX_DEV_USB
+	default n
+
+endmenu
+
+config AR71XX_DEV_M25P80
+	def_bool n
+
+config AR71XX_DEV_AP91_PCI
+	def_bool n
+
+config AR71XX_DEV_AP91_ETH
+	select AR71XX_DEV_DSA
+	def_bool n
+
+config AR71XX_DEV_AP94_PCI
+	def_bool n
+
+config AR71XX_DEV_AR913X_WMAC
+	def_bool n
+
+config AR71XX_DEV_DSA
+	def_bool n
+
+config AR71XX_DEV_GPIO_BUTTONS
+	def_bool n
+
+config AR71XX_DEV_LEDS_GPIO
+	def_bool n
+
+config AR71XX_DEV_PB42_PCI
+	def_bool n
+
+config AR71XX_DEV_PB9X_PCI
+	def_bool n
+
+config AR71XX_DEV_USB
+	def_bool n
+
+config AR71XX_NVRAM
+	def_bool n
+
+endif
diff --git a/arch/mips/ar71xx/Makefile b/arch/mips/ar71xx/Makefile
new file mode 100644
index 0000000..e24df57
--- /dev/null
+++ b/arch/mips/ar71xx/Makefile
@@ -0,0 +1,54 @@
+#
+# Makefile for the Atheros AR71xx SoC specific parts of the kernel
+#
+# Copyright (C) 2008-2009 Gabor Juhos <juhosg@openwrt.org>
+# Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+#
+# This program is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License version 2 as published
+# by the Free Software Foundation.
+
+obj-y	:= prom.o irq.o setup.o devices.o gpio.o ar71xx.o
+
+obj-$(CONFIG_EARLY_PRINTK)		+= early_printk.o
+obj-$(CONFIG_PCI)			+= pci.o
+
+obj-$(CONFIG_AR71XX_DEV_AP91_ETH)	+= dev-ap91-eth.o
+obj-$(CONFIG_AR71XX_DEV_AP91_PCI)	+= dev-ap91-pci.o
+obj-$(CONFIG_AR71XX_DEV_AP94_PCI)	+= dev-ap94-pci.o
+obj-$(CONFIG_AR71XX_DEV_AR913X_WMAC)	+= dev-ar913x-wmac.o
+obj-$(CONFIG_AR71XX_DEV_DSA)		+= dev-dsa.o
+obj-$(CONFIG_AR71XX_DEV_GPIO_BUTTONS)	+= dev-gpio-buttons.o
+obj-$(CONFIG_AR71XX_DEV_LEDS_GPIO)	+= dev-leds-gpio.o
+obj-$(CONFIG_AR71XX_DEV_M25P80)		+= dev-m25p80.o
+obj-$(CONFIG_AR71XX_DEV_PB42_PCI)	+= dev-pb42-pci.o
+obj-$(CONFIG_AR71XX_DEV_PB9X_PCI)	+= dev-pb9x-pci.o
+obj-$(CONFIG_AR71XX_DEV_USB)		+= dev-usb.o
+
+obj-$(CONFIG_AR71XX_NVRAM)		+= nvram.o
+
+obj-$(CONFIG_AR71XX_MACH_AP81)		+= mach-ap81.o
+obj-$(CONFIG_AR71XX_MACH_AP83)		+= mach-ap83.o
+obj-$(CONFIG_AR71XX_MACH_AW_NR580)	+= mach-aw-nr580.o
+obj-$(CONFIG_AR71XX_MACH_DIR_600_A1)	+= mach-dir-600-a1.o
+obj-$(CONFIG_AR71XX_MACH_DIR_615_C1)	+= mach-dir-615-c1.o
+obj-$(CONFIG_AR71XX_MACH_DIR_825_B1)	+= mach-dir-825-b1.o
+obj-$(CONFIG_AR71XX_MACH_MZK_W04NU)	+= mach-mzk-w04nu.o
+obj-$(CONFIG_AR71XX_MACH_MZK_W300NH)	+= mach-mzk-w300nh.o
+obj-$(CONFIG_AR71XX_MACH_PB42)		+= mach-pb42.o
+obj-$(CONFIG_AR71XX_MACH_PB44)		+= mach-pb44.o
+obj-$(CONFIG_AR71XX_MACH_PB92)		+= mach-pb92.o
+obj-$(CONFIG_AR71XX_MACH_RB4XX)		+= mach-rb4xx.o
+obj-$(CONFIG_AR71XX_MACH_RB750)		+= mach-rb750.o
+obj-$(CONFIG_AR71XX_MACH_TEW_632BRP)	+= mach-tew-632brp.o
+obj-$(CONFIG_AR71XX_MACH_TL_WR741ND)	+= mach-tl-wr741nd.o
+obj-$(CONFIG_AR71XX_MACH_TL_WR841N_V1)	+= mach-tl-wr841n.o
+obj-$(CONFIG_AR71XX_MACH_TL_WR941ND)	+= mach-tl-wr941nd.o
+obj-$(CONFIG_AR71XX_MACH_TL_WR1043ND)	+= mach-tl-wr1043nd.o
+obj-$(CONFIG_AR71XX_MACH_UBNT)		+= mach-ubnt.o
+obj-$(CONFIG_AR71XX_MACH_WNDR3700)	+= mach-wndr3700.o
+obj-$(CONFIG_AR71XX_MACH_WNR2000)	+= mach-wnr2000.o
+obj-$(CONFIG_AR71XX_MACH_WP543)		+= mach-wp543.o
+obj-$(CONFIG_AR71XX_MACH_WRT160NL)	+= mach-wrt160nl.o
+obj-$(CONFIG_AR71XX_MACH_WRT400N)	+= mach-wrt400n.o
+obj-$(CONFIG_AR71XX_MACH_WZR_HP_G300NH)	+= mach-wzr-hp-g300nh.o
diff --git a/arch/mips/ar71xx/ar71xx.c b/arch/mips/ar71xx/ar71xx.c
new file mode 100644
index 0000000..5d05562
--- /dev/null
+++ b/arch/mips/ar71xx/ar71xx.c
@@ -0,0 +1,177 @@
+/*
+ *  AR71xx SoC routines
+ *
+ *  Copyright (C) 2008-2009 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/mutex.h>
+
+#include <asm/mach-ar71xx/ar71xx.h>
+
+static DEFINE_MUTEX(ar71xx_flash_mutex);
+
+void __iomem *ar71xx_ddr_base;
+EXPORT_SYMBOL_GPL(ar71xx_ddr_base);
+
+void __iomem *ar71xx_pll_base;
+EXPORT_SYMBOL_GPL(ar71xx_pll_base);
+
+void __iomem *ar71xx_reset_base;
+EXPORT_SYMBOL_GPL(ar71xx_reset_base);
+
+void __iomem *ar71xx_gpio_base;
+EXPORT_SYMBOL_GPL(ar71xx_gpio_base);
+
+void __iomem *ar71xx_usb_ctrl_base;
+EXPORT_SYMBOL_GPL(ar71xx_usb_ctrl_base);
+
+void ar71xx_device_stop(u32 mask)
+{
+	unsigned long flags;
+	u32 mask_inv;
+	u32 t;
+
+	switch (ar71xx_soc) {
+	case AR71XX_SOC_AR7130:
+	case AR71XX_SOC_AR7141:
+	case AR71XX_SOC_AR7161:
+		local_irq_save(flags);
+		t = ar71xx_reset_rr(AR71XX_RESET_REG_RESET_MODULE);
+		ar71xx_reset_wr(AR71XX_RESET_REG_RESET_MODULE, t | mask);
+		local_irq_restore(flags);
+		break;
+
+	case AR71XX_SOC_AR7240:
+	case AR71XX_SOC_AR7241:
+	case AR71XX_SOC_AR7242:
+		mask_inv = mask & RESET_MODULE_USB_OHCI_DLL_7240;
+		local_irq_save(flags);
+		t = ar71xx_reset_rr(AR724X_RESET_REG_RESET_MODULE);
+		t |= mask;
+		t &= ~mask_inv;
+		ar71xx_reset_wr(AR724X_RESET_REG_RESET_MODULE, t);
+		local_irq_restore(flags);
+		break;
+
+	case AR71XX_SOC_AR9130:
+	case AR71XX_SOC_AR9132:
+		local_irq_save(flags);
+		t = ar71xx_reset_rr(AR91XX_RESET_REG_RESET_MODULE);
+		ar71xx_reset_wr(AR91XX_RESET_REG_RESET_MODULE, t | mask);
+		local_irq_restore(flags);
+		break;
+
+	default:
+		BUG();
+	}
+}
+EXPORT_SYMBOL_GPL(ar71xx_device_stop);
+
+void ar71xx_device_start(u32 mask)
+{
+	unsigned long flags;
+	u32 mask_inv;
+	u32 t;
+
+	switch (ar71xx_soc) {
+	case AR71XX_SOC_AR7130:
+	case AR71XX_SOC_AR7141:
+	case AR71XX_SOC_AR7161:
+		local_irq_save(flags);
+		t = ar71xx_reset_rr(AR71XX_RESET_REG_RESET_MODULE);
+		ar71xx_reset_wr(AR71XX_RESET_REG_RESET_MODULE, t & ~mask);
+		local_irq_restore(flags);
+		break;
+
+	case AR71XX_SOC_AR7240:
+	case AR71XX_SOC_AR7241:
+	case AR71XX_SOC_AR7242:
+		mask_inv = mask & RESET_MODULE_USB_OHCI_DLL_7240;
+		local_irq_save(flags);
+		t = ar71xx_reset_rr(AR724X_RESET_REG_RESET_MODULE);
+		t &= ~mask;
+		t |= mask_inv;
+		ar71xx_reset_wr(AR724X_RESET_REG_RESET_MODULE, t);
+		local_irq_restore(flags);
+		break;
+
+	case AR71XX_SOC_AR9130:
+	case AR71XX_SOC_AR9132:
+		local_irq_save(flags);
+		t = ar71xx_reset_rr(AR91XX_RESET_REG_RESET_MODULE);
+		ar71xx_reset_wr(AR91XX_RESET_REG_RESET_MODULE, t & ~mask);
+		local_irq_restore(flags);
+		break;
+
+	default:
+		BUG();
+	}
+}
+EXPORT_SYMBOL_GPL(ar71xx_device_start);
+
+int ar71xx_device_stopped(u32 mask)
+{
+	unsigned long flags;
+	u32 t;
+
+	switch (ar71xx_soc) {
+	case AR71XX_SOC_AR7130:
+	case AR71XX_SOC_AR7141:
+	case AR71XX_SOC_AR7161:
+		local_irq_save(flags);
+		t = ar71xx_reset_rr(AR71XX_RESET_REG_RESET_MODULE);
+		local_irq_restore(flags);
+		break;
+
+	case AR71XX_SOC_AR7240:
+	case AR71XX_SOC_AR7241:
+	case AR71XX_SOC_AR7242:
+		local_irq_save(flags);
+		t = ar71xx_reset_rr(AR724X_RESET_REG_RESET_MODULE);
+		local_irq_restore(flags);
+		break;
+
+	case AR71XX_SOC_AR9130:
+	case AR71XX_SOC_AR9132:
+		local_irq_save(flags);
+		t = ar71xx_reset_rr(AR91XX_RESET_REG_RESET_MODULE);
+		local_irq_restore(flags);
+		break;
+
+	default:
+		BUG();
+	}
+
+	return ((t & mask) == mask);
+}
+EXPORT_SYMBOL_GPL(ar71xx_device_stopped);
+
+void ar71xx_ddr_flush(u32 reg)
+{
+	ar71xx_ddr_wr(reg, 1);
+	while ((ar71xx_ddr_rr(reg) & 0x1));
+
+	ar71xx_ddr_wr(reg, 1);
+	while ((ar71xx_ddr_rr(reg) & 0x1));
+}
+EXPORT_SYMBOL_GPL(ar71xx_ddr_flush);
+
+void ar71xx_flash_acquire(void)
+{
+	mutex_lock(&ar71xx_flash_mutex);
+}
+EXPORT_SYMBOL_GPL(ar71xx_flash_acquire);
+
+void ar71xx_flash_release(void)
+{
+	mutex_unlock(&ar71xx_flash_mutex);
+}
+EXPORT_SYMBOL_GPL(ar71xx_flash_release);
diff --git a/arch/mips/ar71xx/dev-ap91-eth.c b/arch/mips/ar71xx/dev-ap91-eth.c
new file mode 100644
index 0000000..c48af45c
--- /dev/null
+++ b/arch/mips/ar71xx/dev-ap91-eth.c
@@ -0,0 +1,70 @@
+/*
+ *  Atheros AP91 reference board ethernet initialization
+ *
+ *  Copyright (C) 2010 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include "devices.h"
+#include "dev-dsa.h"
+#include "dev-ap91-eth.h"
+
+static struct dsa_chip_data ap91_dsa_chip = {
+	.port_names[0]  = "cpu",
+	.port_names[1]  = "lan1",
+	.port_names[2]  = "lan2",
+	.port_names[3]  = "lan3",
+	.port_names[4]  = "lan4",
+};
+
+static struct dsa_platform_data ap91_dsa_data = {
+	.nr_chips	= 1,
+	.chip		= &ap91_dsa_chip,
+};
+
+static void ap91_eth_set_port_name(unsigned port, const char *name)
+{
+	if (port < 1 || port > 5)
+		return;
+
+	if (name)
+		ap91_dsa_chip.port_names[port] = (char *) name;
+}
+
+void __init ap91_eth_init(u8 *mac_addr, const char *port_names[])
+{
+	if (mac_addr)
+		ar71xx_set_mac_base(mac_addr);
+
+	if (port_names) {
+		int i;
+
+		for (i = 0; i < AP91_ETH_NUM_PORT_NAMES; i++)
+			ap91_eth_set_port_name(i + 1, port_names[i]);
+	}
+
+	/* WAN port */
+	ar71xx_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ar71xx_eth0_data.speed = SPEED_100;
+	ar71xx_eth0_data.duplex = DUPLEX_FULL;
+	ar71xx_eth0_data.fifo_cfg1 = 0x0fff0000;
+	ar71xx_eth0_data.fifo_cfg2 = 0x00001fff;
+	ar71xx_eth0_data.fifo_cfg3 = 0x008001ff;
+
+	/* LAN ports */
+	ar71xx_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ar71xx_eth1_data.speed = SPEED_1000;
+	ar71xx_eth1_data.duplex = DUPLEX_FULL;
+	ar71xx_eth1_data.fifo_cfg1 = 0x0fff0000;
+	ar71xx_eth1_data.fifo_cfg2 = 0x00001fff;
+	ar71xx_eth1_data.fifo_cfg3 = 0x008001ff;
+
+	ar71xx_add_device_mdio(0x0);
+	ar71xx_add_device_eth(1);
+	ar71xx_add_device_eth(0);
+
+	ar71xx_add_device_dsa(1, &ap91_dsa_data);
+}
diff --git a/arch/mips/ar71xx/dev-ap91-eth.h b/arch/mips/ar71xx/dev-ap91-eth.h
new file mode 100644
index 0000000..d9cd214
--- /dev/null
+++ b/arch/mips/ar71xx/dev-ap91-eth.h
@@ -0,0 +1,23 @@
+/*
+ *  Atheros AP91 reference board ethernet initialization
+ *
+ *  Copyright (C) 2010 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#ifndef _AR71XX_DEV_AP91_ETH_H
+#define _AR71XX_DEV_AP91_ETH_H
+
+#define AP91_ETH_NUM_PORT_NAMES	4
+
+#if defined(CONFIG_AR71XX_DEV_AP91_ETH)
+void ap91_eth_init(u8 *mac_addr, const char *port_names[]) __init;
+#else
+static inline void ap91_eth_init(u8 *mac_addr) { }
+#endif
+
+#endif /* _AR71XX_DEV_AP91_ETH_H */
+
diff --git a/arch/mips/ar71xx/dev-ap91-pci.c b/arch/mips/ar71xx/dev-ap91-pci.c
new file mode 100644
index 0000000..e81a01a
--- /dev/null
+++ b/arch/mips/ar71xx/dev-ap91-pci.c
@@ -0,0 +1,114 @@
+/*
+ *  Atheros AP91 reference board PCI initialization
+ *
+ *  Copyright (C) 2009 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/pci.h>
+#include <linux/ath9k_platform.h>
+#include <linux/delay.h>
+
+#include <asm/mach-ar71xx/ar71xx.h>
+#include <asm/mach-ar71xx/pci.h>
+
+#include "dev-ap91-pci.h"
+
+static struct ath9k_platform_data ap91_wmac_data;
+static char ap91_wmac_mac[6];
+static int ap91_pci_fixup_enabled;
+
+static struct ar71xx_pci_irq ap91_pci_irqs[] __initdata = {
+	{
+		.slot	= 0,
+		.pin	= 1,
+		.irq	= AR71XX_PCI_IRQ_DEV0,
+	}
+};
+
+static int ap91_pci_plat_dev_init(struct pci_dev *dev)
+{
+	switch(PCI_SLOT(dev->devfn)) {
+	case 0:
+		dev->dev.platform_data = &ap91_wmac_data;
+		break;
+	}
+
+	return 0;
+}
+
+static void ap91_pci_fixup(struct pci_dev *dev)
+{
+	void __iomem *mem;
+	u16 *cal_data;
+	u16 cmd;
+	u32 val;
+
+	if (!ap91_pci_fixup_enabled)
+		return;
+
+	printk(KERN_INFO "PCI: fixup device %s\n", pci_name(dev));
+
+	cal_data = ap91_wmac_data.eeprom_data;
+	if (*cal_data != 0xa55a) {
+		printk(KERN_ERR "PCI: no calibration data found for %s\n",
+		       pci_name(dev));
+		return;
+	}
+
+	mem = ioremap(AR71XX_PCI_MEM_BASE, 0x10000);
+	if (!mem) {
+		printk(KERN_ERR "PCI: ioremap error for device %s\n",
+		       pci_name(dev));
+		return;
+	}
+
+	/* Setup the PCI device to allow access to the internal registers */
+	pci_write_config_dword(dev, PCI_BASE_ADDRESS_0, 0xffff);
+	pci_read_config_word(dev, PCI_COMMAND, &cmd);
+	cmd |= PCI_COMMAND_MASTER | PCI_COMMAND_MEMORY;
+	pci_write_config_word(dev, PCI_COMMAND, cmd);
+
+        /* set pointer to first reg address */
+	cal_data += 3;
+	while (*cal_data != 0xffff) {
+		u32 reg;
+		reg = *cal_data++;
+		val = *cal_data++;
+		val |= (*cal_data++) << 16;
+
+		__raw_writel(val, mem + reg);
+		udelay(100);
+	}
+
+	pci_read_config_dword(dev, PCI_VENDOR_ID, &val);
+	dev->vendor = val & 0xffff;
+	dev->device = (val >> 16) & 0xffff;
+
+	pci_read_config_dword(dev, PCI_CLASS_REVISION, &val);
+	dev->revision = val & 0xff;
+	dev->class = val >> 8; /* upper 3 bytes */
+
+	iounmap(mem);
+}
+DECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_ATHEROS, PCI_ANY_ID, ap91_pci_fixup);
+
+void __init ap91_pci_init(u8 *cal_data, u8 *mac_addr)
+{
+	if (cal_data)
+		memcpy(ap91_wmac_data.eeprom_data, cal_data,
+		       sizeof(ap91_wmac_data.eeprom_data));
+
+	if (mac_addr) {
+		memcpy(ap91_wmac_mac, mac_addr, sizeof(ap91_wmac_mac));
+		ap91_wmac_data.macaddr = ap91_wmac_mac;
+	}
+
+	ar71xx_pci_plat_dev_init = ap91_pci_plat_dev_init;
+	ar71xx_pci_init(ARRAY_SIZE(ap91_pci_irqs), ap91_pci_irqs);
+
+	ap91_pci_fixup_enabled = 1;
+}
diff --git a/arch/mips/ar71xx/dev-ap91-pci.h b/arch/mips/ar71xx/dev-ap91-pci.h
new file mode 100644
index 0000000..d6f2e52
--- /dev/null
+++ b/arch/mips/ar71xx/dev-ap91-pci.h
@@ -0,0 +1,21 @@
+/*
+ *  Atheros AP91 reference board PCI initialization
+ *
+ *  Copyright (C) 2009 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#ifndef _AR71XX_DEV_AP91_PCI_H
+#define _AR71XX_DEV_AP91_PCI_H
+
+#if defined(CONFIG_AR71XX_DEV_AP91_PCI)
+void ap91_pci_init(u8 *cal_data, u8 *mac_addr) __init;
+#else
+static inline void ap91_pci_init(u8 *cal_data, u8 *mac_addr) { }
+#endif
+
+#endif /* _AR71XX_DEV_AP91_PCI_H */
+
diff --git a/arch/mips/ar71xx/dev-ap94-pci.c b/arch/mips/ar71xx/dev-ap94-pci.c
new file mode 100644
index 0000000..bfa668f
--- /dev/null
+++ b/arch/mips/ar71xx/dev-ap94-pci.c
@@ -0,0 +1,159 @@
+/*
+ *  Atheros AP94 reference board PCI initialization
+ *
+ *  Copyright (C) 2009-2010 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/pci.h>
+#include <linux/ath9k_platform.h>
+#include <linux/delay.h>
+
+#include <asm/mach-ar71xx/ar71xx.h>
+#include <asm/mach-ar71xx/pci.h>
+
+#include "dev-ap94-pci.h"
+
+static struct ath9k_platform_data ap94_wmac0_data;
+static struct ath9k_platform_data ap94_wmac1_data;
+static char ap94_wmac0_mac[6];
+static char ap94_wmac1_mac[6];
+static int ap94_pci_fixup_enabled;
+
+static struct ar71xx_pci_irq ap94_pci_irqs[] __initdata = {
+        {
+                .slot   = 0,
+                .pin    = 1,
+                .irq    = AR71XX_PCI_IRQ_DEV0,
+        }, {
+                .slot   = 1,
+                .pin    = 1,
+                .irq    = AR71XX_PCI_IRQ_DEV1,
+        }
+};
+
+static int ap94_pci_plat_dev_init(struct pci_dev *dev)
+{
+	switch(PCI_SLOT(dev->devfn)) {
+	case 17:
+		dev->dev.platform_data = &ap94_wmac0_data;
+		break;
+
+	case 18:
+		dev->dev.platform_data = &ap94_wmac1_data;
+		break;
+	}
+
+	return 0;
+}
+
+static void ap94_pci_fixup(struct pci_dev *dev)
+{
+	void __iomem *mem;
+	u16 *cal_data;
+	u16 cmd;
+	u32 bar0;
+	u32 val;
+
+	if (!ap94_pci_fixup_enabled)
+		return;
+
+	switch (PCI_SLOT(dev->devfn)) {
+	case 17:
+		cal_data = ap94_wmac0_data.eeprom_data;
+		break;
+	case 18:
+		cal_data = ap94_wmac1_data.eeprom_data;
+		break;
+	default:
+		return;
+	}
+
+	if (*cal_data != 0xa55a) {
+		printk(KERN_ERR "PCI: no calibration data found for %s\n",
+		       pci_name(dev));
+		return;
+	}
+
+	mem = ioremap(AR71XX_PCI_MEM_BASE, 0x10000);
+	if (!mem) {
+		printk(KERN_ERR "PCI: ioremap error for device %s\n",
+		       pci_name(dev));
+		return;
+	}
+
+	printk(KERN_INFO "PCI: fixup device %s\n", pci_name(dev));
+
+	pci_read_config_dword(dev, PCI_BASE_ADDRESS_0, &bar0);
+
+	/* Setup the PCI device to allow access to the internal registers */
+	pci_write_config_dword(dev, PCI_BASE_ADDRESS_0, AR71XX_PCI_MEM_BASE);
+	pci_read_config_word(dev, PCI_COMMAND, &cmd);
+	cmd |= PCI_COMMAND_MASTER | PCI_COMMAND_MEMORY;
+	pci_write_config_word(dev, PCI_COMMAND, cmd);
+
+	/* set pointer to first reg address */
+	cal_data += 3;
+	while (*cal_data != 0xffff) {
+		u32 reg;
+		reg = *cal_data++;
+		val = *cal_data++;
+		val |= (*cal_data++) << 16;
+
+		__raw_writel(val, mem + reg);
+		udelay(100);
+	}
+
+	pci_read_config_dword(dev, PCI_VENDOR_ID, &val);
+	dev->vendor = val & 0xffff;
+	dev->device = (val >> 16) & 0xffff;
+
+	pci_read_config_dword(dev, PCI_CLASS_REVISION, &val);
+	dev->revision = val & 0xff;
+	dev->class = val >> 8; /* upper 3 bytes */
+
+	pci_read_config_word(dev, PCI_COMMAND, &cmd);
+	cmd &= ~(PCI_COMMAND_MASTER | PCI_COMMAND_MEMORY);
+	pci_write_config_word(dev, PCI_COMMAND, cmd);
+
+	pci_write_config_dword(dev, PCI_BASE_ADDRESS_0, bar0);
+
+	iounmap(mem);
+}
+DECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_ATHEROS, PCI_ANY_ID, ap94_pci_fixup);
+
+void __init ap94_pci_enable_quirk_wndr3700(void)
+{
+	ap94_wmac0_data.quirk_wndr3700 = 1;
+	ap94_wmac1_data.quirk_wndr3700 = 1;
+}
+
+void __init ap94_pci_init(u8 *cal_data0, u8 *mac_addr0,
+			  u8 *cal_data1, u8 *mac_addr1)
+{
+	if (cal_data0)
+		memcpy(ap94_wmac0_data.eeprom_data, cal_data0,
+		       sizeof(ap94_wmac0_data.eeprom_data));
+
+	if (cal_data1)
+		memcpy(ap94_wmac1_data.eeprom_data, cal_data1,
+		       sizeof(ap94_wmac1_data.eeprom_data));
+
+	if (mac_addr0) {
+		memcpy(ap94_wmac0_mac, mac_addr0, sizeof(ap94_wmac0_mac));
+		ap94_wmac0_data.macaddr = ap94_wmac0_mac;
+	}
+
+	if (mac_addr1) {
+		memcpy(ap94_wmac1_mac, mac_addr1, sizeof(ap94_wmac1_mac));
+		ap94_wmac1_data.macaddr = ap94_wmac1_mac;
+	}
+
+	ar71xx_pci_plat_dev_init = ap94_pci_plat_dev_init;
+	ar71xx_pci_init(ARRAY_SIZE(ap94_pci_irqs), ap94_pci_irqs);
+
+	ap94_pci_fixup_enabled = 1;
+}
diff --git a/arch/mips/ar71xx/dev-ap94-pci.h b/arch/mips/ar71xx/dev-ap94-pci.h
new file mode 100644
index 0000000..e69ba55
--- /dev/null
+++ b/arch/mips/ar71xx/dev-ap94-pci.h
@@ -0,0 +1,28 @@
+/*
+ *  Atheros AP94 reference board PCI initialization
+ *
+ *  Copyright (C) 2009-2010 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#ifndef _AR71XX_DEV_AP94_PCI_H
+#define _AR71XX_DEV_AP94_PCI_H
+
+#if defined(CONFIG_AR71XX_DEV_AP94_PCI)
+void ap94_pci_init(u8 *cal_data0, u8 *mac_addr0,
+		   u8 *cal_data1, u8 *mac_addr1) __init;
+
+void ap94_pci_enable_quirk_wndr3700(void) __init;
+
+#else
+static inline void ap94_pci_init(u8 *cal_data0, u8 *mac_addr0,
+				 u8 *cal_data1, u8 *mac_addr1) {}
+
+static inline void ap94_pci_enable_quirk_wndr3700(void) {}
+#endif
+
+#endif /* _AR71XX_DEV_AP94_PCI_H */
+
diff --git a/arch/mips/ar71xx/dev-ar913x-wmac.c b/arch/mips/ar71xx/dev-ar913x-wmac.c
new file mode 100644
index 0000000..024d290
--- /dev/null
+++ b/arch/mips/ar71xx/dev-ar913x-wmac.c
@@ -0,0 +1,68 @@
+/*
+ *  Atheros AR913x SoC built-in WMAC device support
+ *
+ *  Copyright (C) 2008-2009 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  Parts of this file are based on Atheros' 2.6.15 BSP
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/etherdevice.h>
+#include <linux/platform_device.h>
+#include <linux/ath9k_platform.h>
+
+#include <asm/mach-ar71xx/ar71xx.h>
+
+#include "dev-ar913x-wmac.h"
+
+static struct ath9k_platform_data ar913x_wmac_data;
+static char ar913x_wmac_mac[6];
+
+static struct resource ar913x_wmac_resources[] = {
+	{
+		.start	= AR91XX_WMAC_BASE,
+		.end	= AR91XX_WMAC_BASE + AR91XX_WMAC_SIZE - 1,
+		.flags	= IORESOURCE_MEM,
+	}, {
+		.start	= AR71XX_CPU_IRQ_IP2,
+		.end	= AR71XX_CPU_IRQ_IP2,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device ar913x_wmac_device = {
+	.name		= "ath9k",
+	.id		= -1,
+	.resource	= ar913x_wmac_resources,
+	.num_resources	= ARRAY_SIZE(ar913x_wmac_resources),
+	.dev = {
+		.platform_data = &ar913x_wmac_data,
+	},
+};
+
+void __init ar913x_add_device_wmac(u8 *cal_data, u8 *mac_addr)
+{
+	if (cal_data)
+		memcpy(ar913x_wmac_data.eeprom_data, cal_data,
+		       sizeof(ar913x_wmac_data.eeprom_data));
+
+	if (mac_addr) {
+		memcpy(ar913x_wmac_mac, mac_addr, sizeof(ar913x_wmac_mac));
+		ar913x_wmac_data.macaddr = ar913x_wmac_mac;
+	}
+
+	ar71xx_device_stop(RESET_MODULE_AMBA2WMAC);
+	mdelay(10);
+
+	ar71xx_device_start(RESET_MODULE_AMBA2WMAC);
+	mdelay(10);
+
+	platform_device_register(&ar913x_wmac_device);
+}
diff --git a/arch/mips/ar71xx/dev-ar913x-wmac.h b/arch/mips/ar71xx/dev-ar913x-wmac.h
new file mode 100644
index 0000000..72d8d72
--- /dev/null
+++ b/arch/mips/ar71xx/dev-ar913x-wmac.h
@@ -0,0 +1,19 @@
+/*
+ *  Atheros AR913x SoC built-in WMAC device support
+ *
+ *  Copyright (C) 2008-2009 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  Parts of this file are based on Atheros' 2.6.15 BSP
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#ifndef _AR71XX_DEV_AR913X_WMAC_H
+#define _AR71XX_DEV_AR913X_WMAC_H
+
+void ar913x_add_device_wmac(u8 *cal_data, u8 *mac_addr) __init;
+
+#endif /* _AR71XX_DEV_AR913X_WMAC_H */
diff --git a/arch/mips/ar71xx/dev-dsa.c b/arch/mips/ar71xx/dev-dsa.c
new file mode 100644
index 0000000..c2877f2
--- /dev/null
+++ b/arch/mips/ar71xx/dev-dsa.c
@@ -0,0 +1,50 @@
+/*
+ *  Atheros AR71xx DSA switch device support
+ *
+ *  Copyright (C) 2008-2009 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/init.h>
+#include <linux/platform_device.h>
+
+#include <asm/mach-ar71xx/ar71xx.h>
+
+#include "devices.h"
+#include "dev-dsa.h"
+
+static struct platform_device ar71xx_dsa_switch_device = {
+	.name		= "dsa",
+	.id		= 0,
+};
+
+void __init ar71xx_add_device_dsa(unsigned int id,
+				  struct dsa_platform_data *d)
+{
+	int i;
+
+	switch (id) {
+	case 0:
+		d->netdev = &ar71xx_eth0_device.dev;
+		break;
+	case 1:
+		d->netdev = &ar71xx_eth1_device.dev;
+		break;
+	default:
+		printk(KERN_ERR
+			"ar71xx: invalid ethernet id %d for DSA switch\n",
+			id);
+		return;
+	}
+
+	for (i = 0; i < d->nr_chips; i++)
+		d->chip[i].mii_bus = &ar71xx_mdio_device.dev;
+
+	ar71xx_dsa_switch_device.dev.platform_data = d;
+
+	platform_device_register(&ar71xx_dsa_switch_device);
+}
diff --git a/arch/mips/ar71xx/dev-dsa.h b/arch/mips/ar71xx/dev-dsa.h
new file mode 100644
index 0000000..2b11882
--- /dev/null
+++ b/arch/mips/ar71xx/dev-dsa.h
@@ -0,0 +1,20 @@
+/*
+ *  Atheros AR71xx DSA switch device support
+ *
+ *  Copyright (C) 2008-2009 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#ifndef _AR71XX_DEV_DSA_H
+#define _AR71XX_DEV_DSA_H
+
+#include <net/dsa.h>
+
+void ar71xx_add_device_dsa(unsigned int id,
+			   struct dsa_platform_data *d) __init;
+
+#endif /* _AR71XX_DEV_DSA_H */
diff --git a/arch/mips/ar71xx/dev-gpio-buttons.c b/arch/mips/ar71xx/dev-gpio-buttons.c
new file mode 100644
index 0000000..df7416d
--- /dev/null
+++ b/arch/mips/ar71xx/dev-gpio-buttons.c
@@ -0,0 +1,58 @@
+/*
+ *  Atheros AR71xx GPIO button support
+ *
+ *  Copyright (C) 2008-2009 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include "linux/init.h"
+#include <linux/platform_device.h>
+
+#include "dev-gpio-buttons.h"
+
+void __init ar71xx_add_device_gpio_buttons(int id,
+					   unsigned poll_interval,
+					   unsigned nbuttons,
+					   struct gpio_button *buttons)
+{
+	struct platform_device *pdev;
+	struct gpio_buttons_platform_data pdata;
+	struct gpio_button *p;
+	int err;
+
+	p = kmalloc(nbuttons * sizeof(*p), GFP_KERNEL);
+	if (!p)
+		return;
+
+	memcpy(p, buttons, nbuttons * sizeof(*p));
+
+	pdev = platform_device_alloc("gpio-buttons", id);
+	if (!pdev)
+		goto err_free_buttons;
+
+	memset(&pdata, 0, sizeof(pdata));
+	pdata.poll_interval = poll_interval;
+	pdata.nbuttons = nbuttons;
+	pdata.buttons = p;
+
+	err = platform_device_add_data(pdev, &pdata, sizeof(pdata));
+	if (err)
+		goto err_put_pdev;
+
+
+	err = platform_device_add(pdev);
+	if (err)
+		goto err_put_pdev;
+
+	return;
+
+err_put_pdev:
+	platform_device_put(pdev);
+
+err_free_buttons:
+	kfree(p);
+}
diff --git a/arch/mips/ar71xx/dev-gpio-buttons.h b/arch/mips/ar71xx/dev-gpio-buttons.h
new file mode 100644
index 0000000..97e9fe5
--- /dev/null
+++ b/arch/mips/ar71xx/dev-gpio-buttons.h
@@ -0,0 +1,25 @@
+/*
+ *  Atheros AR71xx GPIO button support
+ *
+ *  Copyright (C) 2008-2009 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#ifndef _AR71XX_DEV_GPIO_BUTTONS_H
+#define _AR71XX_DEV_GPIO_BUTTONS_H
+
+#include <linux/input.h>
+#include <linux/gpio_buttons.h>
+
+#include <asm/mach-ar71xx/platform.h>
+
+void ar71xx_add_device_gpio_buttons(int id,
+				    unsigned poll_interval,
+				    unsigned nbuttons,
+				    struct gpio_button *buttons) __init;
+
+#endif /* _AR71XX_DEV_GPIO_BUTTONS_H */
diff --git a/arch/mips/ar71xx/dev-leds-gpio.c b/arch/mips/ar71xx/dev-leds-gpio.c
new file mode 100644
index 0000000..7066ddc
--- /dev/null
+++ b/arch/mips/ar71xx/dev-leds-gpio.c
@@ -0,0 +1,56 @@
+/*
+ *  Atheros AR71xx GPIO LED device support
+ *
+ *  Copyright (C) 2008-2009 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  Parts of this file are based on Atheros' 2.6.15 BSP
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/init.h>
+#include <linux/platform_device.h>
+
+#include "dev-leds-gpio.h"
+
+void __init ar71xx_add_device_leds_gpio(int id, unsigned num_leds,
+					struct gpio_led *leds)
+{
+	struct platform_device *pdev;
+	struct gpio_led_platform_data pdata;
+	struct gpio_led *p;
+	int err;
+
+	p = kmalloc(num_leds * sizeof(*p), GFP_KERNEL);
+	if (!p)
+		return;
+
+	memcpy(p, leds, num_leds * sizeof(*p));
+
+	pdev = platform_device_alloc("leds-gpio", id);
+	if (!pdev)
+		goto err_free_leds;
+
+	memset(&pdata, 0, sizeof(pdata));
+	pdata.num_leds = num_leds;
+	pdata.leds = p;
+
+	err = platform_device_add_data(pdev, &pdata, sizeof(pdata));
+	if (err)
+		goto err_put_pdev;
+
+	err = platform_device_add(pdev);
+	if (err)
+		goto err_put_pdev;
+
+	return;
+
+err_put_pdev:
+	platform_device_put(pdev);
+
+err_free_leds:
+	kfree(p);
+}
diff --git a/arch/mips/ar71xx/dev-leds-gpio.h b/arch/mips/ar71xx/dev-leds-gpio.h
new file mode 100644
index 0000000..ab4a89d
--- /dev/null
+++ b/arch/mips/ar71xx/dev-leds-gpio.h
@@ -0,0 +1,21 @@
+/*
+ *  Atheros AR71xx GPIO LED device support
+ *
+ *  Copyright (C) 2008-2009 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#ifndef _AR71XX_DEV_LEDS_GPIO_H
+#define _AR71XX_DEV_LEDS_GPIO_H
+
+#include <linux/leds.h>
+
+void ar71xx_add_device_leds_gpio(int id,
+				 unsigned num_leds,
+				 struct gpio_led *leds) __init;
+
+#endif /* _AR71XX_DEV_LEDS_GPIO_H */
diff --git a/arch/mips/ar71xx/dev-m25p80.c b/arch/mips/ar71xx/dev-m25p80.c
new file mode 100644
index 0000000..666b508
--- /dev/null
+++ b/arch/mips/ar71xx/dev-m25p80.c
@@ -0,0 +1,30 @@
+/*
+ *  Copyright (C) 2009 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/init.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/flash.h>
+
+#include "devices.h"
+#include "dev-m25p80.h"
+
+static struct spi_board_info ar71xx_spi_info[] = {
+	{
+		.bus_num	= 0,
+		.chip_select	= 0,
+		.max_speed_hz	= 25000000,
+		.modalias	= "m25p80",
+	}
+};
+
+void __init ar71xx_add_device_m25p80(struct flash_platform_data *pdata)
+{
+	ar71xx_spi_info[0].platform_data = pdata;
+	ar71xx_add_device_spi(NULL, ar71xx_spi_info,
+			      ARRAY_SIZE(ar71xx_spi_info));
+}
diff --git a/arch/mips/ar71xx/dev-m25p80.h b/arch/mips/ar71xx/dev-m25p80.h
new file mode 100644
index 0000000..0b8e56d
--- /dev/null
+++ b/arch/mips/ar71xx/dev-m25p80.h
@@ -0,0 +1,16 @@
+/*
+ *  Copyright (C) 2009 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#ifndef _AR71XX_DEV_M25P80_H
+#define _AR71XX_DEV_M25P80_H
+
+#include <linux/spi/flash.h>
+
+void ar71xx_add_device_m25p80(struct flash_platform_data *pdata) __init;
+
+#endif /* _AR71XX_DEV_M25P80_H */
diff --git a/arch/mips/ar71xx/dev-pb42-pci.c b/arch/mips/ar71xx/dev-pb42-pci.c
new file mode 100644
index 0000000..0678567
--- /dev/null
+++ b/arch/mips/ar71xx/dev-pb42-pci.c
@@ -0,0 +1,40 @@
+/*
+ *  Atheros PB42 reference board PCI initialization
+ *
+ *  Copyright (C) 2008-2009 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  Parts of this file are based on Atheros' 2.6.15 BSP
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/pci.h>
+
+#include <asm/mach-ar71xx/ar71xx.h>
+#include <asm/mach-ar71xx/pci.h>
+
+#include "dev-pb42-pci.h"
+
+static struct ar71xx_pci_irq pb42_pci_irqs[] __initdata = {
+	{
+		.slot	= 0,
+		.pin	= 1,
+		.irq	= AR71XX_PCI_IRQ_DEV0,
+	}, {
+		.slot	= 1,
+		.pin	= 1,
+		.irq	= AR71XX_PCI_IRQ_DEV1,
+	}, {
+		.slot	= 2,
+		.pin	= 1,
+		.irq	= AR71XX_PCI_IRQ_DEV2,
+	}
+};
+
+void __init pb42_pci_init(void)
+{
+	ar71xx_pci_init(ARRAY_SIZE(pb42_pci_irqs), pb42_pci_irqs);
+}
diff --git a/arch/mips/ar71xx/dev-pb42-pci.h b/arch/mips/ar71xx/dev-pb42-pci.h
new file mode 100644
index 0000000..f9ef951
--- /dev/null
+++ b/arch/mips/ar71xx/dev-pb42-pci.h
@@ -0,0 +1,21 @@
+/*
+ *  Atheros PB42 reference board PCI initialization
+ *
+ *  Copyright (C) 2008-2009 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#ifndef _AR71XX_DEV_PB42_PCI_H
+#define _AR71XX_DEV_PB42_PCI_H
+
+#if defined(CONFIG_AR71XX_DEV_PB42_PCI)
+void pb42_pci_init(void) __init;
+#else
+static inline void pb42_pci_init(void) { }
+#endif
+
+#endif /* _AR71XX_DEV_PB42_PCI_H */
diff --git a/arch/mips/ar71xx/dev-pb9x-pci.c b/arch/mips/ar71xx/dev-pb9x-pci.c
new file mode 100644
index 0000000..762bd55
--- /dev/null
+++ b/arch/mips/ar71xx/dev-pb9x-pci.c
@@ -0,0 +1,33 @@
+/*
+ *  Atheros PB9x reference board PCI initialization
+ *
+ *  Copyright (C) 2010 Felix Fietkau <nbd@openwrt.org>
+ *  Copyright (C) 2008-2009 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  Parts of this file are based on Atheros' 2.6.15 BSP
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/pci.h>
+
+#include <asm/mach-ar71xx/ar71xx.h>
+#include <asm/mach-ar71xx/pci.h>
+
+#include "dev-pb9x-pci.h"
+
+static struct ar71xx_pci_irq pb9x_pci_irqs[] __initdata = {
+	{
+		.slot	= 0,
+		.pin	= 1,
+		.irq	= AR71XX_PCI_IRQ_DEV0,
+	}
+};
+
+void __init pb9x_pci_init(void)
+{
+	ar71xx_pci_init(ARRAY_SIZE(pb9x_pci_irqs), pb9x_pci_irqs);
+}
diff --git a/arch/mips/ar71xx/dev-pb9x-pci.h b/arch/mips/ar71xx/dev-pb9x-pci.h
new file mode 100644
index 0000000..be53f0a
--- /dev/null
+++ b/arch/mips/ar71xx/dev-pb9x-pci.h
@@ -0,0 +1,22 @@
+/*
+ *  Atheros PB9x reference board PCI initialization
+ *
+ *  Copyright (C) 2010 Felix Fietkau <nbd@openwrt.org>
+ *  Copyright (C) 2008-2009 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#ifndef _AR71XX_DEV_PB9X_PCI_H
+#define _AR71XX_DEV_PB9X_PCI_H
+
+#if defined(CONFIG_AR71XX_DEV_PB9X_PCI)
+void pb9x_pci_init(void) __init;
+#else
+static inline void pb9x_pci_init(void) { }
+#endif
+
+#endif /* _AR71XX_DEV_PB9X_PCI_H */
diff --git a/arch/mips/ar71xx/dev-usb.c b/arch/mips/ar71xx/dev-usb.c
new file mode 100644
index 0000000..fb006c7
--- /dev/null
+++ b/arch/mips/ar71xx/dev-usb.c
@@ -0,0 +1,181 @@
+/*
+ *  Atheros AR71xx USB host device support
+ *
+ *  Copyright (C) 2008-2009 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  Parts of this file are based on Atheros' 2.6.15 BSP
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/dma-mapping.h>
+#include <linux/platform_device.h>
+
+#include <asm/mach-ar71xx/ar71xx.h>
+#include <asm/mach-ar71xx/platform.h>
+
+#include "dev-usb.h"
+
+/*
+ * OHCI (USB full speed host controller)
+ */
+static struct resource ar71xx_ohci_resources[] = {
+	[0] = {
+		.start	= AR71XX_OHCI_BASE,
+		.end	= AR71XX_OHCI_BASE + AR71XX_OHCI_SIZE - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= AR71XX_MISC_IRQ_OHCI,
+		.end	= AR71XX_MISC_IRQ_OHCI,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct resource ar7240_ohci_resources[] = {
+	[0] = {
+		.start	= AR7240_OHCI_BASE,
+		.end	= AR7240_OHCI_BASE + AR7240_OHCI_SIZE - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= AR71XX_CPU_IRQ_USB,
+		.end	= AR71XX_CPU_IRQ_USB,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static u64 ar71xx_ohci_dmamask = DMA_BIT_MASK(32);
+static struct platform_device ar71xx_ohci_device = {
+	.name		= "ar71xx-ohci",
+	.id		= -1,
+	.resource	= ar71xx_ohci_resources,
+	.num_resources	= ARRAY_SIZE(ar71xx_ohci_resources),
+	.dev = {
+		.dma_mask		= &ar71xx_ohci_dmamask,
+		.coherent_dma_mask	= DMA_BIT_MASK(32),
+	},
+};
+
+/*
+ * EHCI (USB full speed host controller)
+ */
+static struct resource ar71xx_ehci_resources[] = {
+	[0] = {
+		.start	= AR71XX_EHCI_BASE,
+		.end	= AR71XX_EHCI_BASE + AR71XX_EHCI_SIZE - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= AR71XX_CPU_IRQ_USB,
+		.end	= AR71XX_CPU_IRQ_USB,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static u64 ar71xx_ehci_dmamask = DMA_BIT_MASK(32);
+static struct ar71xx_ehci_platform_data ar71xx_ehci_data;
+
+static struct platform_device ar71xx_ehci_device = {
+	.name		= "ar71xx-ehci",
+	.id		= -1,
+	.resource	= ar71xx_ehci_resources,
+	.num_resources	= ARRAY_SIZE(ar71xx_ehci_resources),
+	.dev = {
+		.dma_mask		= &ar71xx_ehci_dmamask,
+		.coherent_dma_mask	= DMA_BIT_MASK(32),
+		.platform_data		= &ar71xx_ehci_data,
+	},
+};
+
+#define AR71XX_USB_RESET_MASK \
+	(RESET_MODULE_USB_HOST | RESET_MODULE_USB_PHY \
+	| RESET_MODULE_USB_OHCI_DLL)
+
+#define AR7240_USB_RESET_MASK \
+	(RESET_MODULE_USB_HOST | RESET_MODULE_USB_OHCI_DLL_7240)
+
+static void __init ar71xx_usb_setup(void)
+{
+	ar71xx_device_stop(AR71XX_USB_RESET_MASK);
+	mdelay(1000);
+	ar71xx_device_start(AR71XX_USB_RESET_MASK);
+
+	/* Turning on the Buff and Desc swap bits */
+	ar71xx_usb_ctrl_wr(USB_CTRL_REG_CONFIG, 0xf0000);
+
+	/* WAR for HW bug. Here it adjusts the duration between two SOFS */
+	ar71xx_usb_ctrl_wr(USB_CTRL_REG_FLADJ, 0x20c00);
+
+	mdelay(900);
+
+	platform_device_register(&ar71xx_ohci_device);
+	platform_device_register(&ar71xx_ehci_device);
+}
+
+static void __init ar7240_usb_setup(void)
+{
+	ar71xx_device_stop(AR7240_USB_RESET_MASK);
+	mdelay(1000);
+	ar71xx_device_start(AR7240_USB_RESET_MASK);
+
+	/* WAR for HW bug. Here it adjusts the duration between two SOFS */
+	ar71xx_usb_ctrl_wr(USB_CTRL_REG_FLADJ, 0x3);
+
+	if (ar71xx_soc == AR71XX_SOC_AR7241 || ar71xx_soc == AR71XX_SOC_AR7242) {
+		ar71xx_ehci_data.is_ar91xx = 1;
+		ar71xx_ehci_device.resource = ar7240_ohci_resources;
+		ar71xx_ehci_device.num_resources = ARRAY_SIZE(ar7240_ohci_resources);
+		platform_device_register(&ar71xx_ehci_device);
+	} else {
+		ar71xx_ohci_device.resource = ar7240_ohci_resources;
+		ar71xx_ohci_device.num_resources = ARRAY_SIZE(ar7240_ohci_resources);
+		platform_device_register(&ar71xx_ohci_device);
+	}
+}
+
+static void __init ar91xx_usb_setup(void)
+{
+	ar71xx_device_stop(RESET_MODULE_USBSUS_OVERRIDE);
+	mdelay(10);
+
+	ar71xx_device_start(RESET_MODULE_USB_HOST);
+	mdelay(10);
+
+	ar71xx_device_start(RESET_MODULE_USB_PHY);
+	mdelay(10);
+
+	ar71xx_ehci_data.is_ar91xx = 1;
+	platform_device_register(&ar71xx_ehci_device);
+}
+
+void __init ar71xx_add_device_usb(void)
+{
+	switch (ar71xx_soc) {
+	case AR71XX_SOC_AR7240:
+	case AR71XX_SOC_AR7241:
+	case AR71XX_SOC_AR7242:
+		ar7240_usb_setup();
+		break;
+
+	case AR71XX_SOC_AR7130:
+	case AR71XX_SOC_AR7141:
+	case AR71XX_SOC_AR7161:
+		ar71xx_usb_setup();
+		break;
+
+	case AR71XX_SOC_AR9130:
+	case AR71XX_SOC_AR9132:
+		ar91xx_usb_setup();
+		break;
+
+	default:
+		BUG();
+	}
+}
diff --git a/arch/mips/ar71xx/dev-usb.h b/arch/mips/ar71xx/dev-usb.h
new file mode 100644
index 0000000..aa49f53
--- /dev/null
+++ b/arch/mips/ar71xx/dev-usb.h
@@ -0,0 +1,17 @@
+/*
+ *  Atheros AR71xx USB host device support
+ *
+ *  Copyright (C) 2008-2009 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#ifndef _AR71XX_DEV_USB_H
+#define _AR71XX_DEV_USB_H
+
+void ar71xx_add_device_usb(void) __init;
+
+#endif /* _AR71XX_DEV_USB_H */
diff --git a/arch/mips/ar71xx/devices.c b/arch/mips/ar71xx/devices.c
new file mode 100644
index 0000000..f809dea
--- /dev/null
+++ b/arch/mips/ar71xx/devices.c
@@ -0,0 +1,575 @@
+/*
+ *  Atheros AR71xx SoC platform devices
+ *
+ *  Copyright (C) 2008-2009 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  Parts of this file are based on Atheros' 2.6.15 BSP
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/etherdevice.h>
+#include <linux/platform_device.h>
+#include <linux/serial_8250.h>
+
+#include <asm/mach-ar71xx/ar71xx.h>
+
+#include "devices.h"
+
+static u8 ar71xx_mac_base[ETH_ALEN] __initdata;
+
+static struct resource ar71xx_uart_resources[] = {
+	{
+		.start	= AR71XX_UART_BASE,
+		.end	= AR71XX_UART_BASE + AR71XX_UART_SIZE - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+};
+
+#define AR71XX_UART_FLAGS (UPF_BOOT_AUTOCONF | UPF_SKIP_TEST | UPF_IOREMAP)
+static struct plat_serial8250_port ar71xx_uart_data[] = {
+	{
+		.mapbase	= AR71XX_UART_BASE,
+		.irq		= AR71XX_MISC_IRQ_UART,
+		.flags		= AR71XX_UART_FLAGS,
+		.iotype		= UPIO_MEM32,
+		.regshift	= 2,
+	}, {
+		/* terminating entry */
+	}
+};
+
+static struct platform_device ar71xx_uart_device = {
+	.name		= "serial8250",
+	.id		= PLAT8250_DEV_PLATFORM,
+	.resource	= ar71xx_uart_resources,
+	.num_resources	= ARRAY_SIZE(ar71xx_uart_resources),
+	.dev = {
+		.platform_data	= ar71xx_uart_data
+	},
+};
+
+void __init ar71xx_add_device_uart(void)
+{
+	ar71xx_uart_data[0].uartclk = ar71xx_ahb_freq;
+	platform_device_register(&ar71xx_uart_device);
+}
+
+static struct resource ar71xx_mdio_resources[] = {
+	{
+		.name	= "mdio_base",
+		.flags	= IORESOURCE_MEM,
+		.start	= AR71XX_GE0_BASE,
+		.end	= AR71XX_GE0_BASE + 0x200 - 1,
+	}
+};
+
+static struct ag71xx_mdio_platform_data ar71xx_mdio_data;
+
+struct platform_device ar71xx_mdio_device = {
+	.name		= "ag71xx-mdio",
+	.id		= -1,
+	.resource	= ar71xx_mdio_resources,
+	.num_resources	= ARRAY_SIZE(ar71xx_mdio_resources),
+	.dev = {
+		.platform_data = &ar71xx_mdio_data,
+	},
+};
+
+void __init ar71xx_add_device_mdio(u32 phy_mask)
+{
+	switch (ar71xx_soc) {
+	case AR71XX_SOC_AR7240:
+	case AR71XX_SOC_AR7241:
+	case AR71XX_SOC_AR7242:
+		ar71xx_mdio_data.is_ar7240 = 1;
+		break;
+	default:
+		break;
+	}
+
+	ar71xx_mdio_data.phy_mask = phy_mask;
+
+	platform_device_register(&ar71xx_mdio_device);
+}
+
+static void ar71xx_set_pll(u32 cfg_reg, u32 pll_reg, u32 pll_val, u32 shift)
+{
+	void __iomem *base;
+	u32 t;
+
+	base = ioremap_nocache(AR71XX_PLL_BASE, AR71XX_PLL_SIZE);
+
+	t = __raw_readl(base + cfg_reg);
+	t &= ~(3 << shift);
+	t |=  (2 << shift);
+	__raw_writel(t, base + cfg_reg);
+	udelay(100);
+
+	__raw_writel(pll_val, base + pll_reg);
+
+	t |= (3 << shift);
+	__raw_writel(t, base + cfg_reg);
+	udelay(100);
+
+	t &= ~(3 << shift);
+	__raw_writel(t, base + cfg_reg);
+	udelay(100);
+
+	printk(KERN_DEBUG "ar71xx: pll_reg %#x: %#x\n",
+		(unsigned int)(base + pll_reg), __raw_readl(base + pll_reg));
+
+	iounmap(base);
+}
+
+struct ar71xx_eth_pll_data ar71xx_eth0_pll_data;
+struct ar71xx_eth_pll_data ar71xx_eth1_pll_data;
+
+static u32 ar71xx_get_eth_pll(unsigned int mac, int speed)
+{
+	struct ar71xx_eth_pll_data *pll_data;
+	u32 pll_val;
+
+	switch (mac) {
+	case 0:
+		pll_data = &ar71xx_eth0_pll_data;
+		break;
+	case 1:
+		pll_data = &ar71xx_eth1_pll_data;
+		break;
+	default:
+		BUG();
+	}
+
+	switch (speed) {
+	case SPEED_10:
+		pll_val = pll_data->pll_10;
+		break;
+	case SPEED_100:
+		pll_val = pll_data->pll_100;
+		break;
+	case SPEED_1000:
+		pll_val = pll_data->pll_1000;
+		break;
+	default:
+		BUG();
+	}
+
+	return pll_val;
+}
+
+static void ar71xx_set_pll_ge0(int speed)
+{
+	u32 val = ar71xx_get_eth_pll(0, speed);
+
+	ar71xx_set_pll(AR71XX_PLL_REG_SEC_CONFIG, AR71XX_PLL_REG_ETH0_INT_CLOCK,
+			val, AR71XX_ETH0_PLL_SHIFT);
+}
+
+static void ar71xx_set_pll_ge1(int speed)
+{
+	u32 val = ar71xx_get_eth_pll(1, speed);
+
+	ar71xx_set_pll(AR71XX_PLL_REG_SEC_CONFIG, AR71XX_PLL_REG_ETH1_INT_CLOCK,
+			 val, AR71XX_ETH1_PLL_SHIFT);
+}
+
+static void ar724x_set_pll_ge0(int speed)
+{
+	/* TODO */
+}
+
+static void ar724x_set_pll_ge1(int speed)
+{
+	/* TODO */
+}
+
+static void ar91xx_set_pll_ge0(int speed)
+{
+	u32 val = ar71xx_get_eth_pll(0, speed);
+
+	ar71xx_set_pll(AR91XX_PLL_REG_ETH_CONFIG, AR91XX_PLL_REG_ETH0_INT_CLOCK,
+			 val, AR91XX_ETH0_PLL_SHIFT);
+}
+
+static void ar91xx_set_pll_ge1(int speed)
+{
+	u32 val = ar71xx_get_eth_pll(1, speed);
+
+	ar71xx_set_pll(AR91XX_PLL_REG_ETH_CONFIG, AR91XX_PLL_REG_ETH1_INT_CLOCK,
+			 val, AR91XX_ETH1_PLL_SHIFT);
+}
+
+static void ar71xx_ddr_flush_ge0(void)
+{
+	ar71xx_ddr_flush(AR71XX_DDR_REG_FLUSH_GE0);
+}
+
+static void ar71xx_ddr_flush_ge1(void)
+{
+	ar71xx_ddr_flush(AR71XX_DDR_REG_FLUSH_GE1);
+}
+
+static void ar724x_ddr_flush_ge0(void)
+{
+	ar71xx_ddr_flush(AR724X_DDR_REG_FLUSH_GE0);
+}
+
+static void ar724x_ddr_flush_ge1(void)
+{
+	ar71xx_ddr_flush(AR724X_DDR_REG_FLUSH_GE1);
+}
+
+static void ar91xx_ddr_flush_ge0(void)
+{
+	ar71xx_ddr_flush(AR91XX_DDR_REG_FLUSH_GE0);
+}
+
+static void ar91xx_ddr_flush_ge1(void)
+{
+	ar71xx_ddr_flush(AR91XX_DDR_REG_FLUSH_GE1);
+}
+
+static struct resource ar71xx_eth0_resources[] = {
+	{
+		.name	= "mac_base",
+		.flags	= IORESOURCE_MEM,
+		.start	= AR71XX_GE0_BASE,
+		.end	= AR71XX_GE0_BASE + 0x200 - 1,
+	}, {
+		.name	= "mii_ctrl",
+		.flags	= IORESOURCE_MEM,
+		.start	= AR71XX_MII_BASE + MII_REG_MII0_CTRL,
+		.end	= AR71XX_MII_BASE + MII_REG_MII0_CTRL + 3,
+	}, {
+		.name	= "mac_irq",
+		.flags	= IORESOURCE_IRQ,
+		.start	= AR71XX_CPU_IRQ_GE0,
+		.end	= AR71XX_CPU_IRQ_GE0,
+	},
+};
+
+struct ag71xx_platform_data ar71xx_eth0_data = {
+	.reset_bit	= RESET_MODULE_GE0_MAC,
+};
+
+struct platform_device ar71xx_eth0_device = {
+	.name		= "ag71xx",
+	.id		= 0,
+	.resource	= ar71xx_eth0_resources,
+	.num_resources	= ARRAY_SIZE(ar71xx_eth0_resources),
+	.dev = {
+		.platform_data = &ar71xx_eth0_data,
+	},
+};
+
+static struct resource ar71xx_eth1_resources[] = {
+	{
+		.name	= "mac_base",
+		.flags	= IORESOURCE_MEM,
+		.start	= AR71XX_GE1_BASE,
+		.end	= AR71XX_GE1_BASE + 0x200 - 1,
+	}, {
+		.name	= "mii_ctrl",
+		.flags	= IORESOURCE_MEM,
+		.start	= AR71XX_MII_BASE + MII_REG_MII1_CTRL,
+		.end	= AR71XX_MII_BASE + MII_REG_MII1_CTRL + 3,
+	}, {
+		.name	= "mac_irq",
+		.flags	= IORESOURCE_IRQ,
+		.start	= AR71XX_CPU_IRQ_GE1,
+		.end	= AR71XX_CPU_IRQ_GE1,
+	},
+};
+
+struct ag71xx_platform_data ar71xx_eth1_data = {
+	.reset_bit	= RESET_MODULE_GE1_MAC,
+};
+
+struct platform_device ar71xx_eth1_device = {
+	.name		= "ag71xx",
+	.id		= 1,
+	.resource	= ar71xx_eth1_resources,
+	.num_resources	= ARRAY_SIZE(ar71xx_eth1_resources),
+	.dev = {
+		.platform_data = &ar71xx_eth1_data,
+	},
+};
+
+#define AR71XX_PLL_VAL_1000	0x00110000
+#define AR71XX_PLL_VAL_100	0x00001099
+#define AR71XX_PLL_VAL_10	0x00991099
+
+#define AR724X_PLL_VAL_1000	0x00110000
+#define AR724X_PLL_VAL_100	0x00001099
+#define AR724X_PLL_VAL_10	0x00991099
+
+#define AR91XX_PLL_VAL_1000	0x1a000000
+#define AR91XX_PLL_VAL_100	0x13000a44
+#define AR91XX_PLL_VAL_10	0x00441099
+
+static void __init ar71xx_init_eth_pll_data(unsigned int id)
+{
+	struct ar71xx_eth_pll_data *pll_data;
+	u32 pll_10, pll_100, pll_1000;
+
+	switch (id) {
+	case 0:
+		pll_data = &ar71xx_eth0_pll_data;
+		break;
+	case 1:
+		pll_data = &ar71xx_eth1_pll_data;
+		break;
+	default:
+		BUG();
+	}
+
+	switch (ar71xx_soc) {
+	case AR71XX_SOC_AR7130:
+	case AR71XX_SOC_AR7141:
+	case AR71XX_SOC_AR7161:
+		pll_10 = AR71XX_PLL_VAL_10;
+		pll_100 = AR71XX_PLL_VAL_100;
+		pll_1000 = AR71XX_PLL_VAL_1000;
+		break;
+
+	case AR71XX_SOC_AR7240:
+	case AR71XX_SOC_AR7241:
+	case AR71XX_SOC_AR7242:
+		pll_10 = AR724X_PLL_VAL_10;
+		pll_100 = AR724X_PLL_VAL_100;
+		pll_1000 = AR724X_PLL_VAL_1000;
+		break;
+
+	case AR71XX_SOC_AR9130:
+	case AR71XX_SOC_AR9132:
+		pll_10 = AR91XX_PLL_VAL_10;
+		pll_100 = AR91XX_PLL_VAL_100;
+		pll_1000 = AR91XX_PLL_VAL_1000;
+		break;
+	default:
+		BUG();
+	}
+
+	if (!pll_data->pll_10)
+		pll_data->pll_10 = pll_10;
+
+	if (!pll_data->pll_100)
+		pll_data->pll_100 = pll_100;
+
+	if (!pll_data->pll_1000)
+		pll_data->pll_1000 = pll_1000;
+}
+
+static int ar71xx_eth_instance __initdata;
+void __init ar71xx_add_device_eth(unsigned int id)
+{
+	struct platform_device *pdev;
+	struct ag71xx_platform_data *pdata;
+
+	ar71xx_init_eth_pll_data(id);
+
+	switch (id) {
+	case 0:
+		switch (ar71xx_eth0_data.phy_if_mode) {
+		case PHY_INTERFACE_MODE_MII:
+			ar71xx_eth0_data.mii_if = MII0_CTRL_IF_MII;
+			break;
+		case PHY_INTERFACE_MODE_GMII:
+			ar71xx_eth0_data.mii_if = MII0_CTRL_IF_GMII;
+			break;
+		case PHY_INTERFACE_MODE_RGMII:
+			ar71xx_eth0_data.mii_if = MII0_CTRL_IF_RGMII;
+			break;
+		case PHY_INTERFACE_MODE_RMII:
+			ar71xx_eth0_data.mii_if = MII0_CTRL_IF_RMII;
+			break;
+		default:
+			printk(KERN_ERR "ar71xx: invalid PHY interface mode "
+					"for eth0\n");
+			return;
+		}
+		pdev = &ar71xx_eth0_device;
+		break;
+	case 1:
+		switch (ar71xx_eth1_data.phy_if_mode) {
+		case PHY_INTERFACE_MODE_RMII:
+			ar71xx_eth1_data.mii_if = MII1_CTRL_IF_RMII;
+			break;
+		case PHY_INTERFACE_MODE_RGMII:
+			ar71xx_eth1_data.mii_if = MII1_CTRL_IF_RGMII;
+			break;
+		default:
+			printk(KERN_ERR "ar71xx: invalid PHY interface mode "
+					"for eth1\n");
+			return;
+		}
+		pdev = &ar71xx_eth1_device;
+		break;
+	default:
+		printk(KERN_ERR "ar71xx: invalid ethernet id %d\n", id);
+		return;
+	}
+
+	pdata = pdev->dev.platform_data;
+
+	switch (ar71xx_soc) {
+	case AR71XX_SOC_AR7130:
+		pdata->ddr_flush = id ? ar71xx_ddr_flush_ge1
+				      : ar71xx_ddr_flush_ge0;
+		pdata->set_pll =  id ? ar71xx_set_pll_ge1
+				     : ar71xx_set_pll_ge0;
+		break;
+
+	case AR71XX_SOC_AR7141:
+	case AR71XX_SOC_AR7161:
+		pdata->ddr_flush = id ? ar71xx_ddr_flush_ge1
+				      : ar71xx_ddr_flush_ge0;
+		pdata->set_pll =  id ? ar71xx_set_pll_ge1
+				     : ar71xx_set_pll_ge0;
+		pdata->has_gbit = 1;
+		break;
+
+	case AR71XX_SOC_AR7241:
+	case AR71XX_SOC_AR7242:
+		ar71xx_eth0_data.reset_bit |= AR724X_RESET_GE0_MDIO;
+		ar71xx_eth1_data.reset_bit |= AR724X_RESET_GE1_MDIO;
+		/* fall through */
+	case AR71XX_SOC_AR7240:
+		pdata->ddr_flush = id ? ar724x_ddr_flush_ge1
+				      : ar724x_ddr_flush_ge0;
+		pdata->set_pll =  id ? ar724x_set_pll_ge1
+				     : ar724x_set_pll_ge0;
+		pdata->is_ar724x = 1;
+		break;
+
+	case AR71XX_SOC_AR9130:
+		pdata->ddr_flush = id ? ar91xx_ddr_flush_ge1
+				      : ar91xx_ddr_flush_ge0;
+		pdata->set_pll =  id ? ar91xx_set_pll_ge1
+				     : ar91xx_set_pll_ge0;
+		pdata->is_ar91xx = 1;
+		break;
+
+	case AR71XX_SOC_AR9132:
+		pdata->ddr_flush = id ? ar91xx_ddr_flush_ge1
+				      : ar91xx_ddr_flush_ge0;
+		pdata->set_pll =  id ? ar91xx_set_pll_ge1
+				      : ar91xx_set_pll_ge0;
+		pdata->is_ar91xx = 1;
+		pdata->has_gbit = 1;
+		break;
+
+	default:
+		BUG();
+	}
+
+	switch (pdata->phy_if_mode) {
+	case PHY_INTERFACE_MODE_GMII:
+	case PHY_INTERFACE_MODE_RGMII:
+		if (!pdata->has_gbit) {
+			printk(KERN_ERR "ar71xx: no gbit available on eth%d\n",
+					id);
+			return;
+		}
+		/* fallthrough */
+	default:
+		break;
+	}
+
+	if (is_valid_ether_addr(ar71xx_mac_base)) {
+		memcpy(pdata->mac_addr, ar71xx_mac_base, ETH_ALEN);
+		pdata->mac_addr[5] += ar71xx_eth_instance;
+	} else {
+		random_ether_addr(pdata->mac_addr);
+		printk(KERN_DEBUG
+			"ar71xx: using random MAC address for eth%d\n",
+			ar71xx_eth_instance);
+	}
+
+	if (pdata->mii_bus_dev == NULL)
+		pdata->mii_bus_dev = &ar71xx_mdio_device.dev;
+
+	/* Reset the device */
+	ar71xx_device_stop(pdata->reset_bit);
+	mdelay(100);
+
+	ar71xx_device_start(pdata->reset_bit);
+	mdelay(100);
+
+	platform_device_register(pdev);
+	ar71xx_eth_instance++;
+}
+
+static struct resource ar71xx_spi_resources[] = {
+	[0] = {
+		.start	= AR71XX_SPI_BASE,
+		.end	= AR71XX_SPI_BASE + AR71XX_SPI_SIZE - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+};
+
+static struct platform_device ar71xx_spi_device = {
+	.name		= "ar71xx-spi",
+	.id		= -1,
+	.resource	= ar71xx_spi_resources,
+	.num_resources	= ARRAY_SIZE(ar71xx_spi_resources),
+};
+
+void __init ar71xx_add_device_spi(struct ar71xx_spi_platform_data *pdata,
+				struct spi_board_info const *info,
+				unsigned n)
+{
+	spi_register_board_info(info, n);
+	ar71xx_spi_device.dev.platform_data = pdata;
+	platform_device_register(&ar71xx_spi_device);
+}
+
+void __init ar71xx_add_device_wdt(void)
+{
+	platform_device_register_simple("ar71xx-wdt", -1, NULL, 0);
+}
+
+void __init ar71xx_set_mac_base(unsigned char *mac)
+{
+	memcpy(ar71xx_mac_base, mac, ETH_ALEN);
+}
+
+void __init ar71xx_parse_mac_addr(char *mac_str)
+{
+	u8 tmp[ETH_ALEN];
+	int t;
+
+	t = sscanf(mac_str, "%02hhx:%02hhx:%02hhx:%02hhx:%02hhx:%02hhx",
+			&tmp[0], &tmp[1], &tmp[2], &tmp[3], &tmp[4], &tmp[5]);
+
+	if (t != ETH_ALEN)
+		t = sscanf(mac_str, "%02hhx.%02hhx.%02hhx.%02hhx.%02hhx.%02hhx",
+			&tmp[0], &tmp[1], &tmp[2], &tmp[3], &tmp[4], &tmp[5]);
+
+	if (t == ETH_ALEN)
+		ar71xx_set_mac_base(tmp);
+	else
+		printk(KERN_DEBUG "ar71xx: failed to parse mac address "
+				"\"%s\"\n", mac_str);
+}
+
+static int __init ar71xx_ethaddr_setup(char *str)
+{
+	ar71xx_parse_mac_addr(str);
+	return 1;
+}
+__setup("ethaddr=", ar71xx_ethaddr_setup);
+
+static int __init ar71xx_kmac_setup(char *str)
+{
+	ar71xx_parse_mac_addr(str);
+	return 1;
+}
+__setup("kmac=", ar71xx_kmac_setup);
diff --git a/arch/mips/ar71xx/devices.h b/arch/mips/ar71xx/devices.h
new file mode 100644
index 0000000..957675b
--- /dev/null
+++ b/arch/mips/ar71xx/devices.h
@@ -0,0 +1,48 @@
+/*
+ *  Atheros AR71xx SoC device definitions
+ *
+ *  Copyright (C) 2008-2009 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#ifndef __AR71XX_DEVICES_H
+#define __AR71XX_DEVICES_H
+
+#include <asm/mach-ar71xx/platform.h>
+
+struct platform_device;
+
+void ar71xx_add_device_spi(struct ar71xx_spi_platform_data *pdata,
+			   struct spi_board_info const *info,
+			   unsigned n) __init;
+
+void ar71xx_set_mac_base(unsigned char *mac) __init;
+void ar71xx_parse_mac_addr(char *mac_str) __init;
+
+struct ar71xx_eth_pll_data {
+	u32	pll_10;
+	u32	pll_100;
+	u32	pll_1000;
+};
+
+extern struct ar71xx_eth_pll_data ar71xx_eth0_pll_data;
+extern struct ar71xx_eth_pll_data ar71xx_eth1_pll_data;
+
+extern struct ag71xx_platform_data ar71xx_eth0_data;
+extern struct ag71xx_platform_data ar71xx_eth1_data;
+extern struct platform_device ar71xx_eth0_device;
+extern struct platform_device ar71xx_eth1_device;
+void ar71xx_add_device_eth(unsigned int id) __init;
+
+extern struct platform_device ar71xx_mdio_device;
+void ar71xx_add_device_mdio(u32 phy_mask) __init;
+
+void ar71xx_add_device_uart(void) __init;
+
+void ar71xx_add_device_wdt(void) __init;
+
+#endif /* __AR71XX_DEVICES_H */
diff --git a/arch/mips/ar71xx/early_printk.c b/arch/mips/ar71xx/early_printk.c
new file mode 100644
index 0000000..4661d97
--- /dev/null
+++ b/arch/mips/ar71xx/early_printk.c
@@ -0,0 +1,30 @@
+/*
+ *  Atheros AR71xx SoC early printk support
+ *
+ *  Copyright (C) 2008-2009 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/io.h>
+#include <linux/serial_reg.h>
+#include <asm/addrspace.h>
+
+#include <asm/mach-ar71xx/ar71xx.h>
+
+#define UART_READ(r) \
+	__raw_readl((void __iomem *)(KSEG1ADDR(AR71XX_UART_BASE) + 4 * (r)))
+
+#define UART_WRITE(r, v) \
+	__raw_writel((v), (void __iomem *)(KSEG1ADDR(AR71XX_UART_BASE) + 4*(r)))
+
+void prom_putchar(unsigned char ch)
+{
+	while (((UART_READ(UART_LSR)) & UART_LSR_THRE) == 0);
+	UART_WRITE(UART_TX, ch);
+	while (((UART_READ(UART_LSR)) & UART_LSR_THRE) == 0);
+}
+
diff --git a/arch/mips/ar71xx/gpio.c b/arch/mips/ar71xx/gpio.c
new file mode 100644
index 0000000..cdb614b
--- /dev/null
+++ b/arch/mips/ar71xx/gpio.c
@@ -0,0 +1,182 @@
+/*
+ *  Atheros AR71xx SoC GPIO API support
+ *
+ *  Copyright (C) 2008-2010 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/spinlock.h>
+#include <linux/io.h>
+#include <linux/ioport.h>
+#include <linux/gpio.h>
+
+#include <asm/mach-ar71xx/ar71xx.h>
+
+static DEFINE_SPINLOCK(ar71xx_gpio_lock);
+
+unsigned long ar71xx_gpio_count;
+EXPORT_SYMBOL(ar71xx_gpio_count);
+
+void __ar71xx_gpio_set_value(unsigned gpio, int value)
+{
+	void __iomem *base = ar71xx_gpio_base;
+
+	if (value)
+		__raw_writel(1 << gpio, base + GPIO_REG_SET);
+	else
+		__raw_writel(1 << gpio, base + GPIO_REG_CLEAR);
+}
+EXPORT_SYMBOL(__ar71xx_gpio_set_value);
+
+int __ar71xx_gpio_get_value(unsigned gpio)
+{
+	return (__raw_readl(ar71xx_gpio_base + GPIO_REG_IN) >> gpio) & 1;
+}
+EXPORT_SYMBOL(__ar71xx_gpio_get_value);
+
+static int ar71xx_gpio_get_value(struct gpio_chip *chip, unsigned offset)
+{
+	return __ar71xx_gpio_get_value(offset);
+}
+
+static void ar71xx_gpio_set_value(struct gpio_chip *chip,
+				  unsigned offset, int value)
+{
+	__ar71xx_gpio_set_value(offset, value);
+}
+
+static int ar71xx_gpio_direction_input(struct gpio_chip *chip,
+				       unsigned offset)
+{
+	void __iomem *base = ar71xx_gpio_base;
+	unsigned long flags;
+
+	spin_lock_irqsave(&ar71xx_gpio_lock, flags);
+
+	__raw_writel(__raw_readl(base + GPIO_REG_OE) & ~(1 << offset),
+		     base + GPIO_REG_OE);
+
+	spin_unlock_irqrestore(&ar71xx_gpio_lock, flags);
+
+	return 0;
+}
+
+static int ar71xx_gpio_direction_output(struct gpio_chip *chip,
+					unsigned offset, int value)
+{
+	void __iomem *base = ar71xx_gpio_base;
+	unsigned long flags;
+
+	spin_lock_irqsave(&ar71xx_gpio_lock, flags);
+
+	if (value)
+		__raw_writel(1 << offset, base + GPIO_REG_SET);
+	else
+		__raw_writel(1 << offset, base + GPIO_REG_CLEAR);
+
+	__raw_writel(__raw_readl(base + GPIO_REG_OE) | (1 << offset),
+		     base + GPIO_REG_OE);
+
+	spin_unlock_irqrestore(&ar71xx_gpio_lock, flags);
+
+	return 0;
+}
+
+static struct gpio_chip ar71xx_gpio_chip = {
+	.label			= "ar71xx",
+	.get			= ar71xx_gpio_get_value,
+	.set			= ar71xx_gpio_set_value,
+	.direction_input	= ar71xx_gpio_direction_input,
+	.direction_output	= ar71xx_gpio_direction_output,
+	.base			= 0,
+	.ngpio			= AR71XX_GPIO_COUNT,
+};
+
+void ar71xx_gpio_function_enable(u32 mask)
+{
+	void __iomem *base = ar71xx_gpio_base;
+	unsigned long flags;
+
+	spin_lock_irqsave(&ar71xx_gpio_lock, flags);
+
+	__raw_writel(__raw_readl(base + GPIO_REG_FUNC) | mask,
+		     base + GPIO_REG_FUNC);
+	/* flush write */
+	(void) __raw_readl(base + GPIO_REG_FUNC);
+
+	spin_unlock_irqrestore(&ar71xx_gpio_lock, flags);
+}
+
+void ar71xx_gpio_function_disable(u32 mask)
+{
+	void __iomem *base = ar71xx_gpio_base;
+	unsigned long flags;
+
+	spin_lock_irqsave(&ar71xx_gpio_lock, flags);
+
+	__raw_writel(__raw_readl(base + GPIO_REG_FUNC) & ~mask,
+		     base + GPIO_REG_FUNC);
+	/* flush write */
+	(void) __raw_readl(base + GPIO_REG_FUNC);
+
+	spin_unlock_irqrestore(&ar71xx_gpio_lock, flags);
+}
+
+void ar71xx_gpio_function_setup(u32 set, u32 clear)
+{
+	void __iomem *base = ar71xx_gpio_base;
+	unsigned long flags;
+
+	spin_lock_irqsave(&ar71xx_gpio_lock, flags);
+
+	__raw_writel((__raw_readl(base + GPIO_REG_FUNC) & ~clear) | set,
+		     base + GPIO_REG_FUNC);
+	/* flush write */
+	(void) __raw_readl(base + GPIO_REG_FUNC);
+
+	spin_unlock_irqrestore(&ar71xx_gpio_lock, flags);
+}
+EXPORT_SYMBOL(ar71xx_gpio_function_setup);
+
+void __init ar71xx_gpio_init(void)
+{
+	int err;
+
+	if (!request_mem_region(AR71XX_GPIO_BASE, AR71XX_GPIO_SIZE,
+				"AR71xx GPIO controller"))
+		panic("cannot allocate AR71xx GPIO registers page");
+
+	switch (ar71xx_soc) {
+	case AR71XX_SOC_AR7130:
+	case AR71XX_SOC_AR7141:
+	case AR71XX_SOC_AR7161:
+		ar71xx_gpio_chip.ngpio = AR71XX_GPIO_COUNT;
+		break;
+
+	case AR71XX_SOC_AR7240:
+	case AR71XX_SOC_AR7241:
+	case AR71XX_SOC_AR7242:
+		ar71xx_gpio_chip.ngpio = AR724X_GPIO_COUNT;
+		break;
+
+	case AR71XX_SOC_AR9130:
+	case AR71XX_SOC_AR9132:
+		ar71xx_gpio_chip.ngpio = AR91XX_GPIO_COUNT;
+		break;
+
+	default:
+		BUG();
+	}
+
+	err = gpiochip_add(&ar71xx_gpio_chip);
+	if (err)
+		panic("cannot add AR71xx GPIO chip, error=%d", err);
+}
diff --git a/arch/mips/ar71xx/irq.c b/arch/mips/ar71xx/irq.c
new file mode 100644
index 0000000..4e1da16
--- /dev/null
+++ b/arch/mips/ar71xx/irq.c
@@ -0,0 +1,295 @@
+/*
+ *  Atheros AR71xx SoC specific interrupt handling
+ *
+ *  Copyright (C) 2008-2010 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  Parts of this file are based on Atheros' 2.6.15 BSP
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+
+#include <asm/irq_cpu.h>
+#include <asm/mipsregs.h>
+
+#include <asm/mach-ar71xx/ar71xx.h>
+
+static int ip2_flush_reg;
+
+static void ar71xx_gpio_irq_dispatch(void)
+{
+	void __iomem *base = ar71xx_gpio_base;
+	u32 pending;
+
+	pending = __raw_readl(base + GPIO_REG_INT_PENDING) &
+		  __raw_readl(base + GPIO_REG_INT_ENABLE);
+
+	if (pending)
+		do_IRQ(AR71XX_GPIO_IRQ_BASE + fls(pending) - 1);
+	else
+		spurious_interrupt();
+}
+
+static void ar71xx_gpio_irq_unmask(unsigned int irq)
+{
+	void __iomem *base = ar71xx_gpio_base;
+	u32 t;
+
+	irq -= AR71XX_GPIO_IRQ_BASE;
+
+	t = __raw_readl(base + GPIO_REG_INT_ENABLE);
+	__raw_writel(t | (1 << irq), base + GPIO_REG_INT_ENABLE);
+
+	/* flush write */
+	(void) __raw_readl(base + GPIO_REG_INT_ENABLE);
+}
+
+static void ar71xx_gpio_irq_mask(unsigned int irq)
+{
+	void __iomem *base = ar71xx_gpio_base;
+	u32 t;
+
+	irq -= AR71XX_GPIO_IRQ_BASE;
+
+	t = __raw_readl(base + GPIO_REG_INT_ENABLE);
+	__raw_writel(t & ~(1 << irq), base + GPIO_REG_INT_ENABLE);
+
+	/* flush write */
+	(void) __raw_readl(base + GPIO_REG_INT_ENABLE);
+}
+
+#if 0
+static int ar71xx_gpio_irq_set_type(unsigned int irq, unsigned int flow_type)
+{
+	/* TODO: implement */
+	return 0;
+}
+#else
+#define ar71xx_gpio_irq_set_type	NULL
+#endif
+
+static struct irq_chip ar71xx_gpio_irq_chip = {
+	.name		= "AR71XX GPIO",
+	.unmask		= ar71xx_gpio_irq_unmask,
+	.mask		= ar71xx_gpio_irq_mask,
+	.mask_ack	= ar71xx_gpio_irq_mask,
+	.set_type	= ar71xx_gpio_irq_set_type,
+};
+
+static struct irqaction ar71xx_gpio_irqaction = {
+	.handler	= no_action,
+	.name		= "cascade [AR71XX GPIO]",
+};
+
+#define GPIO_IRQ_INIT_STATUS (IRQ_LEVEL | IRQ_TYPE_LEVEL_HIGH | IRQ_DISABLED)
+#define GPIO_INT_ALL	0xffff
+
+static void __init ar71xx_gpio_irq_init(void)
+{
+	void __iomem *base = ar71xx_gpio_base;
+	int i;
+
+	__raw_writel(0, base + GPIO_REG_INT_ENABLE);
+	__raw_writel(0, base + GPIO_REG_INT_PENDING);
+
+	/* setup type of all GPIO interrupts to level sensitive */
+	__raw_writel(GPIO_INT_ALL, base + GPIO_REG_INT_TYPE);
+
+	/* setup polarity of all GPIO interrupts to active high */
+	__raw_writel(GPIO_INT_ALL, base + GPIO_REG_INT_POLARITY);
+
+	for (i = AR71XX_GPIO_IRQ_BASE;
+	     i < AR71XX_GPIO_IRQ_BASE + AR71XX_GPIO_IRQ_COUNT; i++) {
+		irq_desc[i].status = GPIO_IRQ_INIT_STATUS;
+		set_irq_chip_and_handler(i, &ar71xx_gpio_irq_chip,
+					 handle_level_irq);
+	}
+
+	setup_irq(AR71XX_MISC_IRQ_GPIO, &ar71xx_gpio_irqaction);
+}
+
+static void ar71xx_misc_irq_dispatch(void)
+{
+	u32 pending;
+
+	pending = ar71xx_reset_rr(AR71XX_RESET_REG_MISC_INT_STATUS)
+	    & ar71xx_reset_rr(AR71XX_RESET_REG_MISC_INT_ENABLE);
+
+	if (pending & MISC_INT_UART)
+		do_IRQ(AR71XX_MISC_IRQ_UART);
+
+	else if (pending & MISC_INT_DMA)
+		do_IRQ(AR71XX_MISC_IRQ_DMA);
+
+	else if (pending & MISC_INT_PERFC)
+		do_IRQ(AR71XX_MISC_IRQ_PERFC);
+
+	else if (pending & MISC_INT_TIMER)
+		do_IRQ(AR71XX_MISC_IRQ_TIMER);
+
+	else if (pending & MISC_INT_OHCI)
+		do_IRQ(AR71XX_MISC_IRQ_OHCI);
+
+	else if (pending & MISC_INT_ERROR)
+		do_IRQ(AR71XX_MISC_IRQ_ERROR);
+
+	else if (pending & MISC_INT_GPIO)
+		ar71xx_gpio_irq_dispatch();
+
+	else if (pending & MISC_INT_WDOG)
+		do_IRQ(AR71XX_MISC_IRQ_WDOG);
+
+	else
+		spurious_interrupt();
+}
+
+static void ar71xx_misc_irq_unmask(unsigned int irq)
+{
+	void __iomem *base = ar71xx_reset_base;
+	u32 t;
+
+	irq -= AR71XX_MISC_IRQ_BASE;
+
+	t = __raw_readl(base + AR71XX_RESET_REG_MISC_INT_ENABLE);
+	__raw_writel(t | (1 << irq), base + AR71XX_RESET_REG_MISC_INT_ENABLE);
+
+	/* flush write */
+	(void) __raw_readl(base + AR71XX_RESET_REG_MISC_INT_ENABLE);
+}
+
+static void ar71xx_misc_irq_mask(unsigned int irq)
+{
+	void __iomem *base = ar71xx_reset_base;
+	u32 t;
+
+	irq -= AR71XX_MISC_IRQ_BASE;
+
+	t = __raw_readl(base + AR71XX_RESET_REG_MISC_INT_ENABLE);
+	__raw_writel(t & ~(1 << irq), base + AR71XX_RESET_REG_MISC_INT_ENABLE);
+
+	/* flush write */
+	(void) __raw_readl(base + AR71XX_RESET_REG_MISC_INT_ENABLE);
+}
+
+static void ar724x_misc_irq_ack(unsigned int irq)
+{
+	void __iomem *base = ar71xx_reset_base;
+	u32 t;
+
+	irq -= AR71XX_MISC_IRQ_BASE;
+
+	t = __raw_readl(base + AR71XX_RESET_REG_MISC_INT_STATUS);
+	__raw_writel(t & ~(1 << irq), base + AR71XX_RESET_REG_MISC_INT_STATUS);
+
+	/* flush write */
+	(void) __raw_readl(base + AR71XX_RESET_REG_MISC_INT_STATUS);
+}
+
+static struct irq_chip ar71xx_misc_irq_chip = {
+	.name		= "AR71XX MISC",
+	.unmask		= ar71xx_misc_irq_unmask,
+	.mask		= ar71xx_misc_irq_mask,
+};
+
+static struct irqaction ar71xx_misc_irqaction = {
+	.handler	= no_action,
+	.name		= "cascade [AR71XX MISC]",
+};
+
+static void __init ar71xx_misc_irq_init(void)
+{
+	void __iomem *base = ar71xx_reset_base;
+	int i;
+
+	__raw_writel(0, base + AR71XX_RESET_REG_MISC_INT_ENABLE);
+	__raw_writel(0, base + AR71XX_RESET_REG_MISC_INT_STATUS);
+
+	switch (ar71xx_soc) {
+	case AR71XX_SOC_AR7240:
+	case AR71XX_SOC_AR7241:
+	case AR71XX_SOC_AR7242:
+		ar71xx_misc_irq_chip.ack = ar724x_misc_irq_ack;
+		break;
+	default:
+		ar71xx_misc_irq_chip.mask_ack = ar71xx_misc_irq_mask;
+		break;
+	}
+
+	for (i = AR71XX_MISC_IRQ_BASE;
+	     i < AR71XX_MISC_IRQ_BASE + AR71XX_MISC_IRQ_COUNT; i++) {
+		irq_desc[i].status = IRQ_DISABLED;
+		set_irq_chip_and_handler(i, &ar71xx_misc_irq_chip,
+					 handle_level_irq);
+	}
+
+	setup_irq(AR71XX_CPU_IRQ_MISC, &ar71xx_misc_irqaction);
+}
+
+asmlinkage void plat_irq_dispatch(void)
+{
+	unsigned long pending;
+
+	pending = read_c0_status() & read_c0_cause() & ST0_IM;
+
+	if (pending & STATUSF_IP7)
+		do_IRQ(AR71XX_CPU_IRQ_TIMER);
+
+	else if (pending & STATUSF_IP2) {
+		/*
+		 * This IRQ is meant for a PCI device. Drivers for PCI devices
+		 * typically allocate coherent DMA memory for the descriptor
+		 * ring, however the DMA controller may still have some
+		 * unsynchronized data in the FIFO.
+		 * Issue a flush here to ensure that the driver sees the update.
+		 */
+		ar71xx_ddr_flush(ip2_flush_reg);
+		do_IRQ(AR71XX_CPU_IRQ_IP2);
+	}
+
+	else if (pending & STATUSF_IP4)
+		do_IRQ(AR71XX_CPU_IRQ_GE0);
+
+	else if (pending & STATUSF_IP5)
+		do_IRQ(AR71XX_CPU_IRQ_GE1);
+
+	else if (pending & STATUSF_IP3)
+		do_IRQ(AR71XX_CPU_IRQ_USB);
+
+	else if (pending & STATUSF_IP6)
+		ar71xx_misc_irq_dispatch();
+
+	else
+		spurious_interrupt();
+}
+
+void __init arch_init_irq(void)
+{
+	switch(ar71xx_soc) {
+	case AR71XX_SOC_AR7240:
+	case AR71XX_SOC_AR7241:
+	case AR71XX_SOC_AR7242:
+		ip2_flush_reg = AR724X_DDR_REG_FLUSH_PCIE;
+		break;
+	case AR71XX_SOC_AR9130:
+	case AR71XX_SOC_AR9132:
+		ip2_flush_reg = AR91XX_DDR_REG_FLUSH_WMAC;
+		break;
+	default:
+		ip2_flush_reg = AR71XX_DDR_REG_FLUSH_PCI;
+		break;
+	}
+	mips_cpu_irq_init();
+
+	ar71xx_misc_irq_init();
+
+	cp0_perfcount_irq = AR71XX_MISC_IRQ_PERFC;
+
+	ar71xx_gpio_irq_init();
+}
diff --git a/arch/mips/ar71xx/mach-ap81.c b/arch/mips/ar71xx/mach-ap81.c
new file mode 100644
index 0000000..cd865b0
--- /dev/null
+++ b/arch/mips/ar71xx/mach-ap81.c
@@ -0,0 +1,140 @@
+/*
+ *  Atheros AP81 board support
+ *
+ *  Copyright (C) 2009 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2009 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/mach-ar71xx/ar71xx.h>
+
+#include "machtype.h"
+#include "devices.h"
+#include "dev-m25p80.h"
+#include "dev-ar913x-wmac.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-usb.h"
+
+#define AP81_GPIO_LED_STATUS	1
+#define AP81_GPIO_LED_AOSS	3
+#define AP81_GPIO_LED_WLAN	6
+#define AP81_GPIO_LED_POWER	14
+
+#define AP81_GPIO_BTN_SW4	12
+#define AP81_GPIO_BTN_SW1	21
+
+#define AP81_BUTTONS_POLL_INTERVAL	20
+
+#ifdef CONFIG_MTD_PARTITIONS
+static struct mtd_partition ap81_partitions[] = {
+	{
+		.name		= "u-boot",
+		.offset		= 0,
+		.size		= 0x040000,
+		.mask_flags	= MTD_WRITEABLE,
+	} , {
+		.name		= "u-boot-env",
+		.offset		= 0x040000,
+		.size		= 0x010000,
+	} , {
+		.name		= "rootfs",
+		.offset		= 0x050000,
+		.size		= 0x500000,
+	} , {
+		.name		= "uImage",
+		.offset		= 0x550000,
+		.size		= 0x100000,
+	} , {
+		.name		= "ART",
+		.offset		= 0x650000,
+		.size		= 0x1b0000,
+		.mask_flags	= MTD_WRITEABLE,
+	}
+};
+#endif /* CONFIG_MTD_PARTITIONS */
+
+static struct flash_platform_data ap81_flash_data = {
+#ifdef CONFIG_MTD_PARTITIONS
+        .parts          = ap81_partitions,
+        .nr_parts       = ARRAY_SIZE(ap81_partitions),
+#endif
+};
+
+static struct gpio_led ap81_leds_gpio[] __initdata = {
+	{
+		.name		= "ap81:green:status",
+		.gpio		= AP81_GPIO_LED_STATUS,
+		.active_low	= 1,
+	}, {
+		.name		= "ap81:amber:aoss",
+		.gpio		= AP81_GPIO_LED_AOSS,
+		.active_low	= 1,
+	}, {
+		.name		= "ap81:green:wlan",
+		.gpio		= AP81_GPIO_LED_WLAN,
+		.active_low	= 1,
+	}, {
+		.name		= "ap81:green:power",
+		.gpio		= AP81_GPIO_LED_POWER,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_button ap81_gpio_buttons[] __initdata = {
+	{
+		.desc		= "sw1",
+		.type		= EV_KEY,
+		.code		= BTN_0,
+		.threshold	= 3,
+		.gpio		= AP81_GPIO_BTN_SW1,
+		.active_low	= 1,
+	} , {
+		.desc		= "sw4",
+		.type		= EV_KEY,
+		.code		= BTN_1,
+		.threshold	= 3,
+		.gpio		= AP81_GPIO_BTN_SW4,
+		.active_low	= 1,
+	}
+};
+
+static void __init ap81_setup(void)
+{
+	u8 *eeprom = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	ar71xx_set_mac_base(eeprom);
+	ar71xx_add_device_mdio(0x0);
+
+	ar71xx_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ar71xx_eth0_data.speed = SPEED_100;
+	ar71xx_eth0_data.duplex = DUPLEX_FULL;
+	ar71xx_eth0_data.has_ar8216 = 1;
+
+	ar71xx_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ar71xx_eth1_data.phy_mask = 0x10;
+
+	ar71xx_add_device_eth(0);
+	ar71xx_add_device_eth(1);
+
+	ar71xx_add_device_usb();
+
+	ar71xx_add_device_m25p80(&ap81_flash_data);
+
+	ar71xx_add_device_leds_gpio(-1, ARRAY_SIZE(ap81_leds_gpio),
+					ap81_leds_gpio);
+
+	ar71xx_add_device_gpio_buttons(-1, AP81_BUTTONS_POLL_INTERVAL,
+					ARRAY_SIZE(ap81_gpio_buttons),
+					ap81_gpio_buttons);
+
+	ar913x_add_device_wmac(eeprom, NULL);
+}
+
+MIPS_MACHINE(AR71XX_MACH_AP81, "AP81", "Atheros AP81", ap81_setup);
diff --git a/arch/mips/ar71xx/mach-ap83.c b/arch/mips/ar71xx/mach-ap83.c
new file mode 100644
index 0000000..9aa17dc
--- /dev/null
+++ b/arch/mips/ar71xx/mach-ap83.c
@@ -0,0 +1,266 @@
+/*
+ *  Atheros AP83 board support
+ *
+ *  Copyright (C) 2008-2009 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/spi_gpio.h>
+#include <linux/spi/vsc7385.h>
+
+#include <asm/mach-ar71xx/ar71xx.h>
+#include <asm/mach-ar71xx/ar91xx_flash.h>
+
+#include "machtype.h"
+#include "devices.h"
+#include "dev-ar913x-wmac.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-usb.h"
+
+#define AP83_GPIO_LED_WLAN	6
+#define AP83_GPIO_LED_POWER	14
+#define AP83_GPIO_LED_JUMPSTART	15
+#define AP83_GPIO_BTN_JUMPSTART	12
+#define AP83_GPIO_BTN_RESET	21
+
+#define AP83_050_GPIO_VSC7385_CS	1
+#define AP83_050_GPIO_VSC7385_MISO	3
+#define AP83_050_GPIO_VSC7385_MOSI	16
+#define AP83_050_GPIO_VSC7385_SCK	17
+
+#define AP83_BUTTONS_POLL_INTERVAL	20
+
+#ifdef CONFIG_MTD_PARTITIONS
+static struct mtd_partition ap83_flash_partitions[] = {
+	{
+		.name		= "u-boot",
+		.offset		= 0,
+		.size		= 0x040000,
+		.mask_flags	= MTD_WRITEABLE,
+	} , {
+		.name		= "u-boot-env",
+		.offset		= 0x040000,
+		.size		= 0x020000,
+		.mask_flags	= MTD_WRITEABLE,
+	} , {
+		.name		= "kernel",
+		.offset		= 0x060000,
+		.size		= 0x140000,
+	} , {
+		.name		= "rootfs",
+		.offset		= 0x1a0000,
+		.size		= 0x650000,
+	} , {
+		.name		= "art",
+		.offset		= 0x7f0000,
+		.size		= 0x010000,
+		.mask_flags	= MTD_WRITEABLE,
+	} , {
+		.name		= "firmware",
+		.offset		= 0x060000,
+		.size		= 0x790000,
+	}
+};
+#endif /* CONFIG_MTD_PARTITIONS */
+
+static struct ar91xx_flash_platform_data ap83_flash_data = {
+	.width		= 2,
+#ifdef CONFIG_MTD_PARTITIONS
+        .parts          = ap83_flash_partitions,
+        .nr_parts       = ARRAY_SIZE(ap83_flash_partitions),
+#endif
+};
+
+static struct resource ap83_flash_resources[] = {
+	[0] = {
+		.start	= AR71XX_SPI_BASE,
+		.end	= AR71XX_SPI_BASE + AR71XX_SPI_SIZE - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+};
+
+static struct platform_device ap83_flash_device = {
+	.name		= "ar91xx-flash",
+	.id		= -1,
+	.resource	= ap83_flash_resources,
+	.num_resources	= ARRAY_SIZE(ap83_flash_resources),
+	.dev		= {
+		.platform_data = &ap83_flash_data,
+	}
+};
+
+static struct gpio_led ap83_leds_gpio[] __initdata = {
+	{
+		.name		= "ap83:green:jumpstart",
+		.gpio		= AP83_GPIO_LED_JUMPSTART,
+		.active_low	= 0,
+	}, {
+		.name		= "ap83:green:power",
+		.gpio		= AP83_GPIO_LED_POWER,
+		.active_low	= 0,
+	}, {
+		.name		= "ap83:green:wlan",
+		.gpio		= AP83_GPIO_LED_WLAN,
+		.active_low	= 0,
+	},
+};
+
+static struct gpio_button ap83_gpio_buttons[] __initdata = {
+	{
+		.desc		= "soft_reset",
+		.type		= EV_KEY,
+		.code		= BTN_0,
+		.threshold	= 3,
+		.gpio		= AP83_GPIO_BTN_RESET,
+		.active_low	= 1,
+	} , {
+		.desc		= "jumpstart",
+		.type		= EV_KEY,
+		.code		= BTN_1,
+		.threshold	= 3,
+		.gpio		= AP83_GPIO_BTN_JUMPSTART,
+		.active_low	= 1,
+	}
+};
+
+static struct resource ap83_040_spi_resources[] = {
+	[0] = {
+		.start	= AR71XX_SPI_BASE,
+		.end	= AR71XX_SPI_BASE + AR71XX_SPI_SIZE - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+};
+
+static struct platform_device ap83_040_spi_device = {
+	.name		= "ap83-spi",
+	.id		= 0,
+	.resource	= ap83_040_spi_resources,
+	.num_resources	= ARRAY_SIZE(ap83_040_spi_resources),
+};
+
+static struct spi_gpio_platform_data ap83_050_spi_data = {
+	.miso	= AP83_050_GPIO_VSC7385_MISO,
+	.mosi	= AP83_050_GPIO_VSC7385_MOSI,
+	.sck	= AP83_050_GPIO_VSC7385_SCK,
+	.num_chipselect = 1,
+};
+
+static struct platform_device ap83_050_spi_device = {
+	.name		= "spi_gpio",
+	.id		= 0,
+	.dev		= {
+		.platform_data = &ap83_050_spi_data,
+	}
+};
+
+static void ap83_vsc7385_reset(void)
+{
+	ar71xx_device_stop(RESET_MODULE_GE1_PHY);
+	udelay(10);
+	ar71xx_device_start(RESET_MODULE_GE1_PHY);
+	mdelay(50);
+}
+
+static struct vsc7385_platform_data ap83_vsc7385_data = {
+	.reset		= ap83_vsc7385_reset,
+	.ucode_name	= "vsc7385_ucode_ap83.bin",
+	.mac_cfg = {
+		.tx_ipg		= 6,
+		.bit2		= 0,
+		.clk_sel	= 3,
+	},
+};
+
+static struct spi_board_info ap83_spi_info[] = {
+	{
+		.bus_num	= 0,
+		.chip_select	= 0,
+		.max_speed_hz	= 25000000,
+		.modalias	= "spi-vsc7385",
+		.platform_data	= &ap83_vsc7385_data,
+		.controller_data = (void *) AP83_050_GPIO_VSC7385_CS,
+	}
+};
+
+static void __init ap83_generic_setup(void)
+{
+	u8 *eeprom = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	ar71xx_set_mac_base(eeprom);
+
+	ar71xx_add_device_mdio(0xfffffffe);
+
+	ar71xx_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ar71xx_eth0_data.phy_mask = 0x1;
+
+	ar71xx_add_device_eth(0);
+
+	ar71xx_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ar71xx_eth1_data.speed = SPEED_1000;
+	ar71xx_eth1_data.duplex = DUPLEX_FULL;
+
+	ar71xx_eth1_pll_data.pll_1000 = 0x1f000000;
+
+	ar71xx_add_device_eth(1);
+
+	ar71xx_add_device_leds_gpio(-1, ARRAY_SIZE(ap83_leds_gpio),
+					ap83_leds_gpio);
+
+	ar71xx_add_device_gpio_buttons(-1, AP83_BUTTONS_POLL_INTERVAL,
+					ARRAY_SIZE(ap83_gpio_buttons),
+					ap83_gpio_buttons);
+
+	ar71xx_add_device_usb();
+
+	ar913x_add_device_wmac(eeprom, NULL);
+
+	platform_device_register(&ap83_flash_device);
+
+	spi_register_board_info(ap83_spi_info, ARRAY_SIZE(ap83_spi_info));
+}
+
+static void __init ap83_040_setup(void)
+{
+	ap83_flash_data.is_shared=1;
+	ap83_generic_setup();
+	platform_device_register(&ap83_040_spi_device);
+}
+
+static void __init ap83_050_setup(void)
+{
+	ap83_generic_setup();
+	platform_device_register(&ap83_050_spi_device);
+}
+
+static void __init ap83_setup(void)
+{
+	u8 *board_id = (u8 *) KSEG1ADDR(0x1fff1244);
+	unsigned int board_version;
+
+	board_version = (unsigned int)(board_id[0] - '0');
+	board_version += ((unsigned int)(board_id[1] - '0')) * 10;
+
+	switch (board_version) {
+	case 40:
+		ap83_040_setup();
+		break;
+	case 50:
+		ap83_050_setup();
+		break;
+	default:
+		printk(KERN_WARNING "AP83-%03u board is not yet supported\n",
+		       board_version);
+	}
+}
+
+MIPS_MACHINE(AR71XX_MACH_AP83, "AP83", "Atheros AP83", ap83_setup);
diff --git a/arch/mips/ar71xx/mach-aw-nr580.c b/arch/mips/ar71xx/mach-aw-nr580.c
new file mode 100644
index 0000000..b9b037a
--- /dev/null
+++ b/arch/mips/ar71xx/mach-aw-nr580.c
@@ -0,0 +1,101 @@
+/*
+ *  AzureWave AW-NR580 board support
+ *
+ *  Copyright (C) 2008-2009 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/mips_machine.h>
+#include <asm/mach-ar71xx/ar71xx.h>
+
+#include "machtype.h"
+#include "devices.h"
+#include "dev-m25p80.h"
+#include "dev-gpio-buttons.h"
+#include "dev-pb42-pci.h"
+#include "dev-leds-gpio.h"
+
+#define AW_NR580_GPIO_LED_READY_RED	0
+#define AW_NR580_GPIO_LED_WLAN		1
+#define AW_NR580_GPIO_LED_READY_GREEN	2
+#define AW_NR580_GPIO_LED_WPS_GREEN	4
+#define AW_NR580_GPIO_LED_WPS_AMBER	5
+
+#define AW_NR580_GPIO_BTN_WPS		3
+#define AW_NR580_GPIO_BTN_RESET		11
+
+#define AW_NR580_BUTTONS_POLL_INTERVAL	20
+
+static struct gpio_led aw_nr580_leds_gpio[] __initdata = {
+	{
+		.name		= "aw-nr580:red:ready",
+		.gpio		= AW_NR580_GPIO_LED_READY_RED,
+		.active_low	= 0,
+	}, {
+		.name		= "aw-nr580:green:ready",
+		.gpio		= AW_NR580_GPIO_LED_READY_GREEN,
+		.active_low	= 0,
+	}, {
+		.name		= "aw-nr580:green:wps",
+		.gpio		= AW_NR580_GPIO_LED_WPS_GREEN,
+		.active_low	= 0,
+	}, {
+		.name		= "aw-nr580:amber:wps",
+		.gpio		= AW_NR580_GPIO_LED_WPS_AMBER,
+		.active_low	= 0,
+	}, {
+		.name		= "aw-nr580:green:wlan",
+		.gpio		= AW_NR580_GPIO_LED_WLAN,
+		.active_low	= 0,
+	}
+};
+
+static struct gpio_button aw_nr580_gpio_buttons[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= BTN_0,
+		.threshold	= 3,
+		.gpio		= AW_NR580_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}, {
+		.desc		= "wps",
+		.type		= EV_KEY,
+		.code		= BTN_1,
+		.threshold	= 3,
+		.gpio		= AW_NR580_GPIO_BTN_WPS,
+		.active_low	= 1,
+	}
+};
+
+static void __init aw_nr580_setup(void)
+{
+	ar71xx_add_device_mdio(0x0);
+
+	ar71xx_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ar71xx_eth0_data.speed = SPEED_100;
+	ar71xx_eth0_data.duplex = DUPLEX_FULL;
+
+	ar71xx_add_device_eth(0);
+
+	pb42_pci_init();
+
+	ar71xx_add_device_m25p80(NULL);
+
+	ar71xx_add_device_leds_gpio(-1, ARRAY_SIZE(aw_nr580_leds_gpio),
+					aw_nr580_leds_gpio);
+
+	ar71xx_add_device_gpio_buttons(-1, AW_NR580_BUTTONS_POLL_INTERVAL,
+					ARRAY_SIZE(aw_nr580_gpio_buttons),
+					aw_nr580_gpio_buttons);
+}
+
+MIPS_MACHINE(AR71XX_MACH_AW_NR580, "AW-NR580", "AzureWave AW-NR580",
+	     aw_nr580_setup);
diff --git a/arch/mips/ar71xx/mach-dir-600-a1.c b/arch/mips/ar71xx/mach-dir-600-a1.c
new file mode 100644
index 0000000..7222405
--- /dev/null
+++ b/arch/mips/ar71xx/mach-dir-600-a1.c
@@ -0,0 +1,138 @@
+/*
+ *  D-Link DIR-600 rev. A1 board support
+ *
+ *  Copyright (C) 2010 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/mach-ar71xx/ar71xx.h>
+
+#include "machtype.h"
+#include "devices.h"
+#include "dev-m25p80.h"
+#include "dev-ap91-eth.h"
+#include "dev-ap91-pci.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "nvram.h"
+
+#define DIR_600_A1_GPIO_LED_WPS			0
+#define DIR_600_A1_GPIO_LED_POWER_AMBER		1
+#define DIR_600_A1_GPIO_LED_POWER_GREEN		6
+
+#define DIR_600_A1_GPIO_BTN_RESET		8
+#define DIR_600_A1_GPIO_BTN_WPS			12
+
+#define DIR_600_A1_BUTTONS_POLL_INTERVAL	20
+
+#define DIR_600_A1_NVRAM_ADDR	0x1f030000
+#define DIR_600_A1_NVRAM_SIZE	0x10000
+
+#ifdef CONFIG_MTD_PARTITIONS
+static struct mtd_partition dir_600_a1_partitions[] = {
+	{
+		.name		= "u-boot",
+		.offset		= 0,
+		.size		= 0x030000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "nvram",
+		.offset		= 0x030000,
+		.size		= 0x010000,
+	}, {
+		.name		= "kernel",
+		.offset		= 0x040000,
+		.size		= 0x0e0000,
+	}, {
+		.name		= "rootfs",
+		.offset		= 0x120000,
+		.size		= 0x2c0000,
+	}, {
+		.name		= "mac",
+		.offset		= 0x3e0000,
+		.size		= 0x010000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "art",
+		.offset		= 0x3f0000,
+		.size		= 0x010000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "firmware",
+		.offset		= 0x040000,
+		.size		= 0x3a0000,
+	}
+};
+#endif /* CONFIG_MTD_PARTITIONS */
+
+static struct flash_platform_data dir_600_a1_flash_data = {
+#ifdef CONFIG_MTD_PARTITIONS
+        .parts          = dir_600_a1_partitions,
+        .nr_parts       = ARRAY_SIZE(dir_600_a1_partitions),
+#endif
+};
+
+static struct gpio_led dir_600_a1_leds_gpio[] __initdata = {
+	{
+		.name		= "dir-600-a1:green:power",
+		.gpio		= DIR_600_A1_GPIO_LED_POWER_GREEN,
+	}, {
+		.name		= "dir-600-a1:amber:power",
+		.gpio		= DIR_600_A1_GPIO_LED_POWER_AMBER,
+	}, {
+		.name		= "dir-600-a1:blue:wps",
+		.gpio		= DIR_600_A1_GPIO_LED_WPS,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_button dir_600_a1_gpio_buttons[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= BTN_0,
+		.threshold	= 3,
+		.gpio		= DIR_600_A1_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}, {
+		.desc		= "wps",
+		.type		= EV_KEY,
+		.code		= BTN_1,
+		.threshold	= 3,
+		.gpio		= DIR_600_A1_GPIO_BTN_WPS,
+		.active_low	= 1,
+	}
+};
+
+static void __init dir_600_a1_setup(void)
+{
+	const char *nvram = (char *) KSEG1ADDR(DIR_600_A1_NVRAM_ADDR);
+	u8 *ee = (u8 *) KSEG1ADDR(0x1fff1000);
+	u8 mac_buff[6];
+	u8 *mac = NULL;
+
+	if (nvram_parse_mac_addr(nvram, DIR_600_A1_NVRAM_SIZE,
+			         "lan_mac=", mac_buff) == 0)
+		mac = mac_buff;
+
+	ar71xx_add_device_m25p80(&dir_600_a1_flash_data);
+
+	ar71xx_add_device_leds_gpio(-1, ARRAY_SIZE(dir_600_a1_leds_gpio),
+					dir_600_a1_leds_gpio);
+
+	ar71xx_add_device_gpio_buttons(-1, DIR_600_A1_BUTTONS_POLL_INTERVAL,
+					ARRAY_SIZE(dir_600_a1_gpio_buttons),
+					dir_600_a1_gpio_buttons);
+
+	ap91_eth_init(mac, NULL);
+	ap91_pci_init(ee, mac);
+}
+
+MIPS_MACHINE(AR71XX_MACH_DIR_600_A1, "DIR-600-A1", "D-Link DIR-600 rev. A1",
+	     dir_600_a1_setup);
diff --git a/arch/mips/ar71xx/mach-dir-615-c1.c b/arch/mips/ar71xx/mach-dir-615-c1.c
new file mode 100644
index 0000000..8433b0c
--- /dev/null
+++ b/arch/mips/ar71xx/mach-dir-615-c1.c
@@ -0,0 +1,173 @@
+/*
+ *  D-Link DIR-615 rev C1 board support
+ *
+ *  Copyright (C) 2008-2009 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/mach-ar71xx/ar71xx.h>
+
+#include "machtype.h"
+#include "devices.h"
+#include "dev-m25p80.h"
+#include "dev-ar913x-wmac.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "nvram.h"
+
+#define DIR_615C1_GPIO_LED_ORANGE_STATUS 1	/* ORANGE:STATUS:TRICOLOR */
+#define DIR_615C1_GPIO_LED_BLUE_WPS	3	/* BLUE:WPS */
+#define DIR_615C1_GPIO_LED_GREEN_WAN	4       /* GREEN:WAN:TRICOLOR */
+#define DIR_615C1_GPIO_LED_GREEN_WANCPU	5       /* GREEN:WAN:CPU:TRICOLOR */
+#define DIR_615C1_GPIO_LED_GREEN_WLAN	6	/* GREEN:WLAN */
+#define DIR_615C1_GPIO_LED_GREEN_STATUS	14	/* GREEN:STATUS:TRICOLOR */
+#define DIR_615C1_GPIO_LED_ORANGE_WAN	15	/* ORANGE:WAN:TRICOLOR */
+
+/* buttons may need refinement */
+
+#define DIR_615C1_GPIO_BTN_WPS		12
+#define DIR_615C1_GPIO_BTN_RESET	21
+
+#define DIR_615C1_BUTTONS_POLL_INTERVAL	20
+
+#define DIR_615C1_CONFIG_ADDR		0x1f020000
+#define DIR_615C1_CONFIG_SIZE		0x10000
+
+#ifdef CONFIG_MTD_PARTITIONS
+static struct mtd_partition dir_615c1_partitions[] = {
+	{
+		.name		= "u-boot",
+		.offset		= 0,
+		.size		= 0x020000,
+		.mask_flags	= MTD_WRITEABLE,
+	} , {
+		.name		= "config",
+		.offset		= 0x020000,
+		.size		= 0x010000,
+	} , {
+		.name		= "kernel",
+		.offset		= 0x030000,
+		.size		= 0x0d0000,
+	} , {
+		.name		= "rootfs",
+		.offset		= 0x100000,
+		.size		= 0x2f0000,
+	} , {
+		.name		= "art",
+		.offset		= 0x3f0000,
+		.size		= 0x010000,
+		.mask_flags	= MTD_WRITEABLE,
+	} , {
+		.name		= "firmware",
+		.offset		= 0x030000,
+		.size		= 0x3c0000,
+	}
+};
+#endif /* CONFIG_MTD_PARTITIONS */
+
+static struct flash_platform_data dir_615c1_flash_data = {
+#ifdef CONFIG_MTD_PARTITIONS
+        .parts          = dir_615c1_partitions,
+        .nr_parts       = ARRAY_SIZE(dir_615c1_partitions),
+#endif
+};
+
+static struct gpio_led dir_615c1_leds_gpio[] __initdata = {
+	{
+		.name		= "dir-615c1:orange:status",
+		.gpio		= DIR_615C1_GPIO_LED_ORANGE_STATUS,
+		.active_low	= 1,
+	}, {
+		.name		= "dir-615c1:blue:wps",
+		.gpio		= DIR_615C1_GPIO_LED_BLUE_WPS,
+		.active_low	= 1,
+	}, {
+		.name		= "dir-615c1:green:wan",
+		.gpio		= DIR_615C1_GPIO_LED_GREEN_WAN,
+		.active_low	= 1,
+	}, {
+		.name		= "dir-615c1:green:wancpu",
+		.gpio		= DIR_615C1_GPIO_LED_GREEN_WANCPU,
+		.active_low	= 1,
+        }, {
+		.name		= "dir-615c1:green:wlan",
+		.gpio		= DIR_615C1_GPIO_LED_GREEN_WLAN,
+		.active_low	= 1,
+        }, {
+		.name           = "dir-615c1:green:status",
+		.gpio           = DIR_615C1_GPIO_LED_GREEN_STATUS,
+		.active_low     = 1,
+	}, {
+		.name		= "dir-615c1:orange:wan",
+		.gpio		= DIR_615C1_GPIO_LED_ORANGE_WAN,
+		.active_low	= 1,
+	}
+
+};
+
+static struct gpio_button dir_615c1_gpio_buttons[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= BTN_0,
+		.threshold	= 3,
+		.gpio		= DIR_615C1_GPIO_BTN_RESET,
+	}, {
+		.desc		= "wps",
+		.type		= EV_KEY,
+		.code		= BTN_1,
+		.threshold	= 3,
+		.gpio		= DIR_615C1_GPIO_BTN_WPS,
+	}
+};
+
+#define DIR_615C1_LAN_PHYMASK	BIT(0)
+#define DIR_615C1_WAN_PHYMASK	BIT(4)
+#define DIR_615C1_MDIO_MASK	(~(DIR_615C1_LAN_PHYMASK | \
+				   DIR_615C1_WAN_PHYMASK))
+
+static void __init dir_615c1_setup(void)
+{
+	const char *config = (char *) KSEG1ADDR(DIR_615C1_CONFIG_ADDR);
+	u8 *eeprom = (u8 *) KSEG1ADDR(0x1fff1000);
+	u8 mac[6];
+	u8 *wlan_mac = NULL;
+
+	if (nvram_parse_mac_addr(config, DIR_615C1_CONFIG_SIZE,
+			         "lan_mac=", mac) == 0) {
+		ar71xx_set_mac_base(mac);
+		wlan_mac = mac;
+	}
+
+	ar71xx_add_device_mdio(DIR_615C1_MDIO_MASK);
+
+	ar71xx_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ar71xx_eth0_data.phy_mask = DIR_615C1_LAN_PHYMASK;
+
+	ar71xx_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ar71xx_eth1_data.phy_mask = DIR_615C1_WAN_PHYMASK;
+
+	ar71xx_add_device_eth(0);
+	ar71xx_add_device_eth(1);
+
+	ar71xx_add_device_m25p80(&dir_615c1_flash_data);
+
+	ar71xx_add_device_leds_gpio(-1, ARRAY_SIZE(dir_615c1_leds_gpio),
+					dir_615c1_leds_gpio);
+
+	ar71xx_add_device_gpio_buttons(-1, DIR_615C1_BUTTONS_POLL_INTERVAL,
+					ARRAY_SIZE(dir_615c1_gpio_buttons),
+					dir_615c1_gpio_buttons);
+
+	ar913x_add_device_wmac(eeprom, wlan_mac);
+}
+
+MIPS_MACHINE(AR71XX_MACH_DIR_615_C1, "DIR-615-C1", "D-Link DIR-615 rev. C1",
+	     dir_615c1_setup);
diff --git a/arch/mips/ar71xx/mach-dir-825-b1.c b/arch/mips/ar71xx/mach-dir-825-b1.c
new file mode 100644
index 0000000..d8b26ee
--- /dev/null
+++ b/arch/mips/ar71xx/mach-dir-825-b1.c
@@ -0,0 +1,192 @@
+/*
+ *  D-Link DIR-825 rev. B1 board support
+ *
+ *  Copyright (C) 2009 Lukas Kuna, Evkanet, s.r.o.
+ *
+ *  based on mach-wndr3700.c
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/platform_device.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <linux/delay.h>
+#include <linux/rtl8366s.h>
+
+#include <asm/mach-ar71xx/ar71xx.h>
+
+#include "machtype.h"
+#include "devices.h"
+#include "dev-m25p80.h"
+#include "dev-ap94-pci.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-usb.h"
+
+#define DIR825B1_GPIO_LED_BLUE_USB		0
+#define DIR825B1_GPIO_LED_ORANGE_POWER		1
+#define DIR825B1_GPIO_LED_BLUE_POWER		2
+#define DIR825B1_GPIO_LED_BLUE_POWERSAVE	4
+#define DIR825B1_GPIO_LED_ORANGE_PLANET		6
+#define DIR825B1_GPIO_LED_BLUE_PLANET		11
+
+#define DIR825B1_GPIO_BTN_RESET			3
+#define DIR825B1_GPIO_BTN_POWERSAVE		8
+
+#define DIR825B1_GPIO_RTL8366_SDA		5
+#define DIR825B1_GPIO_RTL8366_SCK		7
+
+#define DIR825B1_BUTTONS_POLL_INTERVAL		20
+
+#define DIR825B1_CAL_LOCATION_0			0x1f661000
+#define DIR825B1_CAL_LOCATION_1			0x1f665000
+
+#define DIR825B1_MAC_LOCATION_0			0x2ffa81b8
+#define DIR825B1_MAC_LOCATION_1			0x2ffa8370
+
+#ifdef CONFIG_MTD_PARTITIONS
+static struct mtd_partition dir825b1_partitions[] = {
+	{
+		.name		= "uboot",
+		.offset		= 0,
+		.size		= 0x040000,
+		.mask_flags	= MTD_WRITEABLE,
+	} , {
+		.name		= "config",
+		.offset		= 0x040000,
+		.size		= 0x010000,
+		.mask_flags	= MTD_WRITEABLE,
+	} , {
+		.name		= "firmware",
+		.offset		= 0x050000,
+		.size		= 0x610000,
+	} , {
+		.name		= "caldata",
+		.offset		= 0x660000,
+		.size		= 0x010000,
+		.mask_flags	= MTD_WRITEABLE,
+	} , {
+		.name		= "unknown",
+		.offset		= 0x670000,
+		.size		= 0x190000,
+		.mask_flags	= MTD_WRITEABLE,
+	}
+};
+#endif /* CONFIG_MTD_PARTITIONS */
+
+static struct flash_platform_data dir825b1_flash_data = {
+#ifdef CONFIG_MTD_PARTITIONS
+        .parts          = dir825b1_partitions,
+        .nr_parts       = ARRAY_SIZE(dir825b1_partitions),
+#endif
+};
+
+static struct gpio_led dir825b1_leds_gpio[] __initdata = {
+	{
+		.name		= "dir825b1:blue:usb",
+		.gpio		= DIR825B1_GPIO_LED_BLUE_USB,
+		.active_low	= 1,
+	}, {
+		.name		= "dir825b1:orange:power",
+		.gpio		= DIR825B1_GPIO_LED_ORANGE_POWER,
+		.active_low	= 1,
+	}, {
+		.name		= "dir825b1:blue:power",
+		.gpio		= DIR825B1_GPIO_LED_BLUE_POWER,
+		.active_low	= 1,
+	}, {
+		.name		= "dir825b1:blue:powersave",
+		.gpio		= DIR825B1_GPIO_LED_BLUE_POWERSAVE,
+		.active_low	= 1,
+	}, {
+		.name		= "dir825b1:orange:planet",
+		.gpio		= DIR825B1_GPIO_LED_ORANGE_PLANET,
+		.active_low	= 1,
+	}, {
+		.name		= "dir825b1:blue:planet",
+		.gpio		= DIR825B1_GPIO_LED_BLUE_PLANET,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_button dir825b1_gpio_buttons[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= BTN_0,
+		.threshold	= 3,
+		.gpio		= DIR825B1_GPIO_BTN_RESET,
+		.active_low	= 1,
+	} , {
+		.desc		= "powersave",
+		.type		= EV_KEY,
+		.code		= BTN_1,
+		.threshold	= 3,
+		.gpio		= DIR825B1_GPIO_BTN_POWERSAVE,
+		.active_low	= 1,
+	}
+};
+
+static struct rtl8366s_platform_data dir825b1_rtl8366s_data = {
+	.gpio_sda        = DIR825B1_GPIO_RTL8366_SDA,
+	.gpio_sck        = DIR825B1_GPIO_RTL8366_SCK,
+};
+
+static struct platform_device dir825b1_rtl8366s_device = {
+	.name		= RTL8366S_DRIVER_NAME,
+	.id		= -1,
+	.dev = {
+		.platform_data	= &dir825b1_rtl8366s_data,
+	}
+};
+
+static void __init dir825b1_setup(void)
+{
+        u8 mac[6], i;
+
+	memcpy(mac, (u8*)KSEG1ADDR(DIR825B1_MAC_LOCATION_1), 6);
+	for(i = 5; i >= 3; i--)
+		if(++mac[i] != 0x00) break;
+
+	ar71xx_set_mac_base(mac);
+
+	ar71xx_add_device_mdio(0x0);
+
+	ar71xx_eth0_data.mii_bus_dev = &dir825b1_rtl8366s_device.dev;
+	ar71xx_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ar71xx_eth0_data.speed = SPEED_1000;
+	ar71xx_eth0_data.duplex = DUPLEX_FULL;
+	ar71xx_eth0_pll_data.pll_1000 = 0x11110000;
+
+	ar71xx_eth1_data.mii_bus_dev = &dir825b1_rtl8366s_device.dev;
+	ar71xx_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ar71xx_eth1_data.phy_mask = 0x10;
+	ar71xx_eth1_pll_data.pll_1000 = 0x11110000;
+
+	ar71xx_add_device_eth(0);
+	ar71xx_add_device_eth(1);
+
+	ar71xx_add_device_m25p80(&dir825b1_flash_data);
+
+	ar71xx_add_device_leds_gpio(-1, ARRAY_SIZE(dir825b1_leds_gpio),
+					dir825b1_leds_gpio);
+
+	ar71xx_add_device_gpio_buttons(-1, DIR825B1_BUTTONS_POLL_INTERVAL,
+					ARRAY_SIZE(dir825b1_gpio_buttons),
+					dir825b1_gpio_buttons);
+
+	ar71xx_add_device_usb();
+
+	platform_device_register(&dir825b1_rtl8366s_device);
+
+	ap94_pci_init((u8 *) KSEG1ADDR(DIR825B1_CAL_LOCATION_0),
+		      (u8 *) KSEG1ADDR(DIR825B1_MAC_LOCATION_0),
+		      (u8 *) KSEG1ADDR(DIR825B1_CAL_LOCATION_1),
+		      (u8 *) KSEG1ADDR(DIR825B1_MAC_LOCATION_1));
+}
+
+MIPS_MACHINE(AR71XX_MACH_DIR_825_B1, "DIR-825-B1", "D-Link DIR-825 rev. B1",
+	     dir825b1_setup);
diff --git a/arch/mips/ar71xx/mach-mzk-w04nu.c b/arch/mips/ar71xx/mach-mzk-w04nu.c
new file mode 100644
index 0000000..63fbeb8
--- /dev/null
+++ b/arch/mips/ar71xx/mach-mzk-w04nu.c
@@ -0,0 +1,165 @@
+/*
+ *  Planex MZK-W04NU board support
+ *
+ *  Copyright (C) 2009 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/mach-ar71xx/ar71xx.h>
+
+#include "machtype.h"
+#include "devices.h"
+#include "dev-ar913x-wmac.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+
+#define MZK_W04NU_GPIO_LED_USB		0
+#define MZK_W04NU_GPIO_LED_STATUS	1
+#define MZK_W04NU_GPIO_LED_WPS		3
+#define MZK_W04NU_GPIO_LED_WLAN		6
+#define MZK_W04NU_GPIO_LED_AP		15
+#define MZK_W04NU_GPIO_LED_ROUTER	16
+
+#define MZK_W04NU_GPIO_BTN_APROUTER	5
+#define MZK_W04NU_GPIO_BTN_WPS		12
+#define MZK_W04NU_GPIO_BTN_RESET	21
+
+#define MZK_W04NU_BUTTONS_POLL_INTERVAL	20
+
+#ifdef CONFIG_MTD_PARTITIONS
+static struct mtd_partition mzk_w04nu_partitions[] = {
+	{
+		.name		= "u-boot",
+		.offset		= 0,
+		.size		= 0x040000,
+		.mask_flags	= MTD_WRITEABLE,
+	} , {
+		.name		= "u-boot-env",
+		.offset		= 0x040000,
+		.size		= 0x010000,
+	} , {
+		.name		= "kernel",
+		.offset		= 0x050000,
+		.size		= 0x160000,
+	} , {
+		.name		= "rootfs",
+		.offset		= 0x1b0000,
+		.size		= 0x630000,
+	} , {
+		.name		= "art",
+		.offset		= 0x7e0000,
+		.size		= 0x020000,
+		.mask_flags	= MTD_WRITEABLE,
+	} , {
+		.name		= "firmware",
+		.offset		= 0x050000,
+		.size		= 0x790000,
+	}
+};
+#endif /* CONFIG_MTD_PARTITIONS */
+
+static struct flash_platform_data mzk_w04nu_flash_data = {
+#ifdef CONFIG_MTD_PARTITIONS
+        .parts          = mzk_w04nu_partitions,
+        .nr_parts       = ARRAY_SIZE(mzk_w04nu_partitions),
+#endif
+};
+
+static struct gpio_led mzk_w04nu_leds_gpio[] __initdata = {
+	{
+		.name		= "mzk-w04nu:green:status",
+		.gpio		= MZK_W04NU_GPIO_LED_STATUS,
+		.active_low	= 1,
+	}, {
+		.name		= "mzk-w04nu:blue:wps",
+		.gpio		= MZK_W04NU_GPIO_LED_WPS,
+		.active_low	= 1,
+	}, {
+		.name		= "mzk-w04nu:green:wlan",
+		.gpio		= MZK_W04NU_GPIO_LED_WLAN,
+		.active_low	= 1,
+	}, {
+		.name		= "mzk-w04nu:green:usb",
+		.gpio		= MZK_W04NU_GPIO_LED_USB,
+		.active_low	= 1,
+	}, {
+		.name		= "mzk-w04nu:green:ap",
+		.gpio		= MZK_W04NU_GPIO_LED_AP,
+		.active_low	= 1,
+	}, {
+		.name		= "mzk-w04nu:green:router",
+		.gpio		= MZK_W04NU_GPIO_LED_ROUTER,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_button mzk_w04nu_gpio_buttons[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= BTN_0,
+		.threshold	= 3,
+		.gpio		= MZK_W04NU_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}, {
+		.desc		= "wps",
+		.type		= EV_KEY,
+		.code		= BTN_1,
+		.threshold	= 3,
+		.gpio		= MZK_W04NU_GPIO_BTN_WPS,
+		.active_low	= 1,
+	}, {
+		.desc		= "aprouter",
+		.type		= EV_KEY,
+		.code		= BTN_2,
+		.threshold	= 3,
+		.gpio		= MZK_W04NU_GPIO_BTN_APROUTER,
+		.active_low	= 0,
+	}
+};
+
+#define MZK_W04NU_WAN_PHYMASK	BIT(4)
+#define MZK_W04NU_MDIO_MASK	(~MZK_W04NU_WAN_PHYMASK)
+
+static void __init mzk_w04nu_setup(void)
+{
+	u8 *eeprom = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	ar71xx_set_mac_base(eeprom);
+
+	ar71xx_add_device_mdio(MZK_W04NU_MDIO_MASK);
+
+	ar71xx_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ar71xx_eth0_data.speed = SPEED_100;
+	ar71xx_eth0_data.duplex = DUPLEX_FULL;
+	ar71xx_eth0_data.has_ar8216 = 1;
+
+	ar71xx_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ar71xx_eth1_data.phy_mask = MZK_W04NU_WAN_PHYMASK;
+
+	ar71xx_add_device_eth(0);
+	ar71xx_add_device_eth(1);
+
+	ar71xx_add_device_m25p80(&mzk_w04nu_flash_data);
+
+	ar71xx_add_device_leds_gpio(-1, ARRAY_SIZE(mzk_w04nu_leds_gpio),
+					mzk_w04nu_leds_gpio);
+
+	ar71xx_add_device_gpio_buttons(-1, MZK_W04NU_BUTTONS_POLL_INTERVAL,
+					ARRAY_SIZE(mzk_w04nu_gpio_buttons),
+					mzk_w04nu_gpio_buttons);
+	ar71xx_add_device_usb();
+
+	ar913x_add_device_wmac(eeprom, NULL);
+}
+
+MIPS_MACHINE(AR71XX_MACH_MZK_W04NU, "MZK-W04NU", "Planex MZK-W04NU",
+	     mzk_w04nu_setup);
diff --git a/arch/mips/ar71xx/mach-mzk-w300nh.c b/arch/mips/ar71xx/mach-mzk-w300nh.c
new file mode 100644
index 0000000..f5862eb
--- /dev/null
+++ b/arch/mips/ar71xx/mach-mzk-w300nh.c
@@ -0,0 +1,158 @@
+/*
+ *  Planex MZK-W300NH board support
+ *
+ *  Copyright (C) 2008-2009 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/mach-ar71xx/ar71xx.h>
+
+#include "machtype.h"
+#include "devices.h"
+#include "dev-m25p80.h"
+#include "dev-ar913x-wmac.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+
+#define MZK_W300NH_GPIO_LED_STATUS	1
+#define MZK_W300NH_GPIO_LED_WPS		3
+#define MZK_W300NH_GPIO_LED_WLAN	6
+#define MZK_W300NH_GPIO_LED_AP		15
+#define MZK_W300NH_GPIO_LED_ROUTER	16
+
+#define MZK_W300NH_GPIO_BTN_APROUTER	5
+#define MZK_W300NH_GPIO_BTN_WPS		12
+#define MZK_W300NH_GPIO_BTN_RESET	21
+
+#define MZK_W04NU_BUTTONS_POLL_INTERVAL	20
+
+#ifdef CONFIG_MTD_PARTITIONS
+static struct mtd_partition mzk_w300nh_partitions[] = {
+	{
+		.name		= "u-boot",
+		.offset		= 0,
+		.size		= 0x040000,
+		.mask_flags	= MTD_WRITEABLE,
+	} , {
+		.name		= "u-boot-env",
+		.offset		= 0x040000,
+		.size		= 0x010000,
+	} , {
+		.name		= "kernel",
+		.offset		= 0x050000,
+		.size		= 0x160000,
+	} , {
+		.name		= "rootfs",
+		.offset		= 0x1b0000,
+		.size		= 0x630000,
+	} , {
+		.name		= "art",
+		.offset		= 0x7e0000,
+		.size		= 0x020000,
+		.mask_flags	= MTD_WRITEABLE,
+	} , {
+		.name		= "firmware",
+		.offset		= 0x050000,
+		.size		= 0x790000,
+	}
+};
+#endif /* CONFIG_MTD_PARTITIONS */
+
+static struct flash_platform_data mzk_w300nh_flash_data = {
+#ifdef CONFIG_MTD_PARTITIONS
+        .parts          = mzk_w300nh_partitions,
+        .nr_parts       = ARRAY_SIZE(mzk_w300nh_partitions),
+#endif
+};
+
+static struct gpio_led mzk_w300nh_leds_gpio[] __initdata = {
+	{
+		.name		= "mzk-w300nh:green:status",
+		.gpio		= MZK_W300NH_GPIO_LED_STATUS,
+		.active_low	= 1,
+	}, {
+		.name		= "mzk-w300nh:blue:wps",
+		.gpio		= MZK_W300NH_GPIO_LED_WPS,
+		.active_low	= 1,
+	}, {
+		.name		= "mzk-w300nh:green:wlan",
+		.gpio		= MZK_W300NH_GPIO_LED_WLAN,
+		.active_low	= 1,
+	}, {
+		.name		= "mzk-w300nh:green:ap",
+		.gpio		= MZK_W300NH_GPIO_LED_AP,
+		.active_low	= 1,
+	}, {
+		.name		= "mzk-w300nh:green:router",
+		.gpio		= MZK_W300NH_GPIO_LED_ROUTER,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_button mzk_w300nh_gpio_buttons[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= BTN_0,
+		.threshold	= 3,
+		.gpio		= MZK_W300NH_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}, {
+		.desc		= "wps",
+		.type		= EV_KEY,
+		.code		= BTN_1,
+		.threshold	= 3,
+		.gpio		= MZK_W300NH_GPIO_BTN_WPS,
+		.active_low	= 1,
+	}, {
+		.desc		= "aprouter",
+		.type		= EV_KEY,
+		.code		= BTN_2,
+		.threshold	= 3,
+		.gpio		= MZK_W300NH_GPIO_BTN_APROUTER,
+		.active_low	= 0,
+	}
+};
+
+#define MZK_W300NH_WAN_PHYMASK	BIT(4)
+#define MZK_W300NH_MDIO_MASK	(~MZK_W300NH_WAN_PHYMASK)
+
+static void __init mzk_w300nh_setup(void)
+{
+	u8 *eeprom = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	ar71xx_set_mac_base(eeprom);
+
+	ar71xx_add_device_mdio(MZK_W300NH_MDIO_MASK);
+
+	ar71xx_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ar71xx_eth0_data.speed = SPEED_100;
+	ar71xx_eth0_data.duplex = DUPLEX_FULL;
+	ar71xx_eth0_data.has_ar8216 = 1;
+
+	ar71xx_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ar71xx_eth1_data.phy_mask = MZK_W300NH_WAN_PHYMASK;
+
+	ar71xx_add_device_eth(0);
+	ar71xx_add_device_eth(1);
+
+	ar71xx_add_device_m25p80(&mzk_w300nh_flash_data);
+
+	ar71xx_add_device_leds_gpio(-1, ARRAY_SIZE(mzk_w300nh_leds_gpio),
+				    mzk_w300nh_leds_gpio);
+
+	ar71xx_add_device_gpio_buttons(-1, MZK_W04NU_BUTTONS_POLL_INTERVAL,
+				       ARRAY_SIZE(mzk_w300nh_gpio_buttons),
+				       mzk_w300nh_gpio_buttons);
+	ar913x_add_device_wmac(eeprom, NULL);
+}
+
+MIPS_MACHINE(AR71XX_MACH_MZK_W300NH, "MZK-W300NH", "Planex MZK-W300NH",
+	     mzk_w300nh_setup);
diff --git a/arch/mips/ar71xx/mach-pb42.c b/arch/mips/ar71xx/mach-pb42.c
new file mode 100644
index 0000000..576da4b
--- /dev/null
+++ b/arch/mips/ar71xx/mach-pb42.c
@@ -0,0 +1,71 @@
+/*
+ *  Atheros PB42 board support
+ *
+ *  Copyright (C) 2008-2009 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <asm/mach-ar71xx/ar71xx.h>
+
+#include "machtype.h"
+#include "devices.h"
+#include "dev-m25p80.h"
+#include "dev-gpio-buttons.h"
+#include "dev-pb42-pci.h"
+#include "dev-usb.h"
+
+#define PB42_BUTTONS_POLL_INTERVAL	20
+
+#define PB42_GPIO_BTN_SW4	8
+#define PB42_GPIO_BTN_SW5	3
+
+static struct gpio_button pb42_gpio_buttons[] __initdata = {
+	{
+		.desc		= "sw4",
+		.type		= EV_KEY,
+		.code		= BTN_0,
+		.threshold	= 3,
+		.gpio		= PB42_GPIO_BTN_SW4,
+		.active_low	= 1,
+	} , {
+		.desc		= "sw5",
+		.type		= EV_KEY,
+		.code		= BTN_1,
+		.threshold	= 3,
+		.gpio		= PB42_GPIO_BTN_SW5,
+		.active_low	= 1,
+	}
+};
+
+#define PB42_WAN_PHYMASK	BIT(20)
+#define PB42_LAN_PHYMASK	(BIT(16) | BIT(17) | BIT(18) | BIT(19))
+#define PB42_MDIO_PHYMASK	(PB42_LAN_PHYMASK | PB42_WAN_PHYMASK)
+
+static void __init pb42_init(void)
+{
+	ar71xx_add_device_m25p80(NULL);
+
+	ar71xx_add_device_mdio(~PB42_MDIO_PHYMASK);
+
+	ar71xx_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ar71xx_eth0_data.phy_mask = PB42_WAN_PHYMASK;
+
+	ar71xx_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ar71xx_eth1_data.speed = SPEED_100;
+	ar71xx_eth1_data.duplex = DUPLEX_FULL;
+
+	ar71xx_add_device_eth(0);
+	ar71xx_add_device_eth(1);
+
+	ar71xx_add_device_gpio_buttons(-1, PB42_BUTTONS_POLL_INTERVAL,
+				       ARRAY_SIZE(pb42_gpio_buttons),
+				       pb42_gpio_buttons);
+
+	pb42_pci_init();
+}
+
+MIPS_MACHINE(AR71XX_MACH_PB42, "PB42", "Atheros PB42", pb42_init);
diff --git a/arch/mips/ar71xx/mach-pb44.c b/arch/mips/ar71xx/mach-pb44.c
new file mode 100644
index 0000000..72718e7
--- /dev/null
+++ b/arch/mips/ar71xx/mach-pb44.c
@@ -0,0 +1,207 @@
+/*
+ *  Atheros PB44 board support
+ *
+ *  Copyright (C) 2009 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/init.h>
+#include <linux/bitops.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/flash.h>
+#include <linux/spi/vsc7385.h>
+#include <linux/i2c.h>
+#include <linux/i2c-gpio.h>
+#include <linux/i2c/pcf857x.h>
+
+#include <asm/mach-ar71xx/ar71xx.h>
+
+#include "machtype.h"
+#include "devices.h"
+#include "dev-pb42-pci.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-usb.h"
+
+#define PB44_PCF8757_VSC7395_CS	0
+#define PB44_PCF8757_STEREO_CS	1
+#define PB44_PCF8757_SLIC_CS0	2
+#define PB44_PCF8757_SLIC_TEST	3
+#define PB44_PCF8757_SLIC_INT0	4
+#define PB44_PCF8757_SLIC_INT1	5
+#define PB44_PCF8757_SW_RESET	6
+#define PB44_PCF8757_SW_JUMP	8
+#define PB44_PCF8757_LED_JUMP1	9
+#define PB44_PCF8757_LED_JUMP2	10
+#define PB44_PCF8757_TP24	11
+#define PB44_PCF8757_TP25	12
+#define PB44_PCF8757_TP26	13
+#define PB44_PCF8757_TP27	14
+#define PB44_PCF8757_TP28	15
+
+#define PB44_GPIO_I2C_SCL	0
+#define PB44_GPIO_I2C_SDA	1
+
+#define PB44_GPIO_EXP_BASE	16
+#define PB44_GPIO_VSC7395_CS	(PB44_GPIO_EXP_BASE + PB44_PCF8757_VSC7395_CS)
+#define PB44_GPIO_SW_RESET	(PB44_GPIO_EXP_BASE + PB44_PCF8757_SW_RESET)
+#define PB44_GPIO_SW_JUMP	(PB44_GPIO_EXP_BASE + PB44_PCF8757_SW_JUMP)
+#define PB44_GPIO_LED_JUMP1	(PB44_GPIO_EXP_BASE + PB44_PCF8757_LED_JUMP1)
+#define PB44_GPIO_LED_JUMP2	(PB44_GPIO_EXP_BASE + PB44_PCF8757_LED_JUMP2)
+
+static struct i2c_gpio_platform_data pb44_i2c_gpio_data = {
+	.sda_pin        = PB44_GPIO_I2C_SDA,
+	.scl_pin        = PB44_GPIO_I2C_SCL,
+};
+
+static struct platform_device pb44_i2c_gpio_device = {
+	.name		= "i2c-gpio",
+	.id		= 0,
+	.dev = {
+		.platform_data	= &pb44_i2c_gpio_data,
+	}
+};
+
+static struct pcf857x_platform_data pb44_pcf857x_data = {
+	.gpio_base	= PB44_GPIO_EXP_BASE,
+};
+
+static struct i2c_board_info pb44_i2c_board_info[] __initdata = {
+	{
+		I2C_BOARD_INFO("pcf8575", 0x20),
+		.platform_data  = &pb44_pcf857x_data,
+	},
+};
+
+static struct gpio_led pb44_leds_gpio[] __initdata = {
+	{
+		.name		= "pb44:amber:jump1",
+		.gpio		= PB44_GPIO_LED_JUMP1,
+		.active_low	= 1,
+	}, {
+		.name		= "pb44:green:jump2",
+		.gpio		= PB44_GPIO_LED_JUMP2,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_button pb44_gpio_buttons[] __initdata = {
+	{
+		.desc		= "soft_reset",
+		.type		= EV_KEY,
+		.code		= BTN_0,
+		.threshold	= 3,
+		.gpio		= PB44_GPIO_SW_RESET,
+		.active_low	= 1,
+	} , {
+		.desc		= "jumpstart",
+		.type		= EV_KEY,
+		.code		= BTN_1,
+		.threshold	= 3,
+		.gpio		= PB44_GPIO_SW_JUMP,
+		.active_low	= 1,
+	}
+};
+
+static void pb44_vsc7395_reset(void)
+{
+	ar71xx_device_stop(RESET_MODULE_GE1_PHY);
+	udelay(10);
+	ar71xx_device_start(RESET_MODULE_GE1_PHY);
+	mdelay(50);
+}
+
+static struct vsc7385_platform_data pb44_vsc7395_data = {
+	.reset		= pb44_vsc7395_reset,
+	.ucode_name	= "vsc7395_ucode_pb44.bin",
+	.mac_cfg = {
+		.tx_ipg		= 6,
+		.bit2		= 1,
+		.clk_sel	= 0,
+	},
+};
+
+static struct spi_board_info pb44_spi_info[] = {
+	{
+		.bus_num	= 0,
+		.chip_select	= 0,
+		.max_speed_hz	= 25000000,
+		.modalias	= "m25p80",
+	}, {
+		.bus_num	= 0,
+		.chip_select	= 1,
+		.max_speed_hz	= 25000000,
+		.modalias	= "spi-vsc7385",
+		.platform_data	= &pb44_vsc7395_data,
+		.controller_data = (void *) PB44_GPIO_VSC7395_CS,
+	},
+};
+
+static struct resource pb44_spi_resources[] = {
+	[0] = {
+		.start	= AR71XX_SPI_BASE,
+		.end	= AR71XX_SPI_BASE + AR71XX_SPI_SIZE - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+};
+
+static struct ar71xx_spi_platform_data pb44_spi_data = {
+	.bus_num		= 0,
+	.num_chipselect		= 2,
+};
+
+static struct platform_device pb44_spi_device = {
+	.name		= "pb44-spi",
+	.id		= -1,
+	.resource	= pb44_spi_resources,
+	.num_resources	= ARRAY_SIZE(pb44_spi_resources),
+	.dev = {
+		.platform_data = &pb44_spi_data,
+	},
+};
+
+#define PB44_WAN_PHYMASK	BIT(0)
+#define PB44_LAN_PHYMASK	0
+#define PB44_MDIO_PHYMASK	(PB44_LAN_PHYMASK | PB44_WAN_PHYMASK)
+
+static void __init pb44_init(void)
+{
+	ar71xx_add_device_mdio(~PB44_MDIO_PHYMASK);
+
+	ar71xx_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ar71xx_eth0_data.phy_mask = PB44_WAN_PHYMASK;
+
+	ar71xx_add_device_eth(0);
+
+	ar71xx_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ar71xx_eth1_data.speed = SPEED_1000;
+	ar71xx_eth1_data.duplex = DUPLEX_FULL;
+	ar71xx_eth1_pll_data.pll_1000 = 0x110000;
+
+	ar71xx_add_device_eth(1);
+
+	ar71xx_add_device_usb();
+
+	pb42_pci_init();
+
+	i2c_register_board_info(0, pb44_i2c_board_info,
+				ARRAY_SIZE(pb44_i2c_board_info));
+
+	platform_device_register(&pb44_i2c_gpio_device);
+
+	spi_register_board_info(pb44_spi_info, ARRAY_SIZE(pb44_spi_info));
+	platform_device_register(&pb44_spi_device);
+
+	ar71xx_add_device_leds_gpio(-1, ARRAY_SIZE(pb44_leds_gpio),
+				    pb44_leds_gpio);
+
+	ar71xx_add_device_gpio_buttons(-1, 20, ARRAY_SIZE(pb44_gpio_buttons),
+				       pb44_gpio_buttons);
+}
+
+MIPS_MACHINE(AR71XX_MACH_PB44, "PB44", "Atheros PB44", pb44_init);
diff --git a/arch/mips/ar71xx/mach-pb92.c b/arch/mips/ar71xx/mach-pb92.c
new file mode 100644
index 0000000..b422c3e
--- /dev/null
+++ b/arch/mips/ar71xx/mach-pb92.c
@@ -0,0 +1,109 @@
+/*
+ *  Atheros PB92 board support
+ *
+ *  Copyright (C) 2010 Felix Fietkau <nbd@openwrt.org>
+ *  Copyright (C) 2008-2009 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <asm/mach-ar71xx/ar71xx.h>
+
+#include "machtype.h"
+#include "devices.h"
+#include "dev-m25p80.h"
+#include "dev-gpio-buttons.h"
+#include "dev-pb9x-pci.h"
+#include "dev-usb.h"
+
+#ifdef CONFIG_MTD_PARTITIONS
+static struct mtd_partition pb92_partitions[] = {
+	{
+		.name		= "u-boot",
+		.offset		= 0,
+		.size		= 0x040000,
+		.mask_flags	= MTD_WRITEABLE,
+	} , {
+		.name		= "u-boot-env",
+		.offset		= 0x040000,
+		.size		= 0x010000,
+	} , {
+		.name		= "rootfs",
+		.offset		= 0x050000,
+		.size		= 0x2b0000,
+	} , {
+		.name		= "uImage",
+		.offset		= 0x300000,
+		.size		= 0x0e0000,
+	} , {
+		.name		= "ART",
+		.offset		= 0x3e0000,
+		.size		= 0x020000,
+		.mask_flags	= MTD_WRITEABLE,
+	}
+};
+#endif /* CONFIG_MTD_PARTITIONS */
+
+static struct flash_platform_data pb92_flash_data = {
+#ifdef CONFIG_MTD_PARTITIONS
+        .parts          = pb92_partitions,
+        .nr_parts       = ARRAY_SIZE(pb92_partitions),
+#endif
+};
+
+
+#define PB92_BUTTONS_POLL_INTERVAL	20
+
+#define PB92_GPIO_BTN_SW4	8
+#define PB92_GPIO_BTN_SW5	3
+
+static struct gpio_button pb92_gpio_buttons[] __initdata = {
+	{
+		.desc		= "sw4",
+		.type		= EV_KEY,
+		.code		= BTN_0,
+		.threshold	= 3,
+		.gpio		= PB92_GPIO_BTN_SW4,
+		.active_low	= 1,
+	} , {
+		.desc		= "sw5",
+		.type		= EV_KEY,
+		.code		= BTN_1,
+		.threshold	= 3,
+		.gpio		= PB92_GPIO_BTN_SW5,
+		.active_low	= 1,
+	}
+};
+
+static void __init pb92_init(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1fff0000);
+
+	ar71xx_set_mac_base(mac);
+	ar71xx_add_device_m25p80(&pb92_flash_data);
+
+	ar71xx_add_device_mdio(~0);
+	ar71xx_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ar71xx_eth0_data.speed = SPEED_100;
+	ar71xx_eth0_data.duplex = DUPLEX_FULL;
+
+	ar71xx_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ar71xx_eth1_data.speed = SPEED_1000;
+	ar71xx_eth1_data.duplex = DUPLEX_FULL;
+
+	ar71xx_add_device_eth(0);
+	ar71xx_add_device_eth(1);
+
+	ar71xx_add_device_gpio_buttons(-1, PB92_BUTTONS_POLL_INTERVAL,
+				       ARRAY_SIZE(pb92_gpio_buttons),
+				       pb92_gpio_buttons);
+
+	pb9x_pci_init();
+}
+
+MIPS_MACHINE(AR71XX_MACH_PB92, "PB92", "Atheros PB92", pb92_init);
diff --git a/arch/mips/ar71xx/mach-rb4xx.c b/arch/mips/ar71xx/mach-rb4xx.c
new file mode 100644
index 0000000..57c06d8
--- /dev/null
+++ b/arch/mips/ar71xx/mach-rb4xx.c
@@ -0,0 +1,290 @@
+/*
+ *  MikroTik RouterBOARD 4xx series support
+ *
+ *  Copyright (C) 2008 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/platform_device.h>
+#include <linux/irq.h>
+#include <linux/mmc/host.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/flash.h>
+#include <linux/spi/mmc_spi.h>
+
+#include <asm/mach-ar71xx/ar71xx.h>
+#include <asm/mach-ar71xx/pci.h>
+
+#include "machtype.h"
+#include "devices.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-usb.h"
+
+#define RB4XX_GPIO_USER_LED	4
+#define RB4XX_GPIO_RESET_SWITCH	7
+
+#define RB4XX_BUTTONS_POLL_INTERVAL	20
+
+static struct gpio_led rb4xx_leds_gpio[] __initdata = {
+	{
+		.name		= "rb4xx:yellow:user",
+		.gpio		= RB4XX_GPIO_USER_LED,
+		.active_low	= 0,
+	},
+};
+
+static struct gpio_button rb4xx_gpio_buttons[] __initdata = {
+	{
+		.desc		= "reset_switch",
+		.type		= EV_KEY,
+		.code		= BTN_0,
+		.threshold	= 3,
+		.gpio		= RB4XX_GPIO_RESET_SWITCH,
+		.active_low	= 1,
+	}
+};
+
+static struct platform_device rb4xx_nand_device = {
+	.name	= "rb4xx-nand",
+	.id	= -1,
+};
+
+static struct ar71xx_pci_irq rb4xx_pci_irqs[] __initdata = {
+	{
+		.slot	= 0,
+		.pin	= 1,
+		.irq	= AR71XX_PCI_IRQ_DEV2,
+	}, {
+		.slot	= 1,
+		.pin	= 1,
+		.irq	= AR71XX_PCI_IRQ_DEV0,
+	}, {
+		.slot	= 1,
+		.pin	= 2,
+		.irq	= AR71XX_PCI_IRQ_DEV1,
+	}, {
+		.slot	= 2,
+		.pin	= 1,
+		.irq	= AR71XX_PCI_IRQ_DEV1,
+	}, {
+		.slot	= 3,
+		.pin	= 1,
+		.irq	= AR71XX_PCI_IRQ_DEV2,
+	}
+};
+
+#if 0
+/*
+ * SPI device support is experimental
+ */
+static struct flash_platform_data rb4xx_flash_data = {
+	.type	= "pm25lv512",
+};
+
+static struct spi_board_info rb4xx_spi_info[] = {
+	{
+		.bus_num	= 0,
+		.chip_select	= 0,
+		.max_speed_hz	= 25000000,
+		.modalias	= "m25p80",
+		.platform_data	= &rb4xx_flash_data,
+	}
+};
+
+static struct mmc_spi_platform_data rb433_mmc_data = {
+	.ocr_mask	= MMC_VDD_32_33 | MMC_VDD_33_34,
+};
+
+static struct spi_board_info rb433_spi_info[] = {
+	{
+		.bus_num	= 0,
+		.chip_select	= 0,
+		.max_speed_hz	= 25000000,
+		.modalias	= "m25p80",
+		.platform_data	= &rb433_flash_data,
+	}, {
+		.bus_num	= 0,
+		.chip_select	= 2,
+		.max_speed_hz	= 25000000,
+		.modalias	= "mmc_spi",
+		.platform_data	= &rb433_mmc_data,
+	}
+};
+
+static u32 rb433_spi_get_ioc_base(u8 chip_select, int cs_high, int is_on)
+{
+	u32 ret;
+
+	if (is_on == AR71XX_SPI_CS_INACTIVE) {
+		ret = SPI_IOC_CS0 | SPI_IOC_CS1;
+	} else {
+		if (cs_high) {
+			ret = SPI_IOC_CS0 | SPI_IOC_CS1;
+		} else {
+			if ((chip_select ^ 2) == 0)
+				ret = SPI_IOC_CS1 ^ (SPI_IOC_CS0 | SPI_IOC_CS1);
+			else
+				ret = SPI_IOC_CS0 ^ (SPI_IOC_CS0 | SPI_IOC_CS1);
+		}
+	}
+
+	return ret;
+}
+
+struct ar71xx_spi_platform_data rb433_spi_data = {
+	.bus_num		= 0,
+	.num_chipselect		= 3,
+	.get_ioc_base		= rb433_spi_get_ioc_base,
+};
+
+static void rb4xx_add_device_spi(void)
+{
+	ar71xx_add_device_spi(NULL, rb4xx_spi_info, ARRAY_SIZE(rb4xx_spi_info));
+}
+
+static void rb433_add_device_spi(void)
+{
+	ar71xx_add_device_spi(&rb433_spi_data, rb433_spi_info,
+				ARRAY_SIZE(rb433_spi_info));
+}
+#else
+static inline void rb4xx_add_device_spi(void) {}
+static inline void rb433_add_device_spi(void) {}
+#endif
+
+static void __init rb4xx_generic_setup(void)
+{
+	ar71xx_gpio_function_enable(AR71XX_GPIO_FUNC_SPI_CS1_EN |
+				    AR71XX_GPIO_FUNC_SPI_CS2_EN);
+
+	ar71xx_add_device_leds_gpio(-1, ARRAY_SIZE(rb4xx_leds_gpio),
+					rb4xx_leds_gpio);
+
+	ar71xx_add_device_gpio_buttons(-1, RB4XX_BUTTONS_POLL_INTERVAL,
+					ARRAY_SIZE(rb4xx_gpio_buttons),
+					rb4xx_gpio_buttons);
+
+	platform_device_register(&rb4xx_nand_device);
+}
+
+static void __init rb411_setup(void)
+{
+	rb4xx_generic_setup();
+	rb4xx_add_device_spi();
+
+	ar71xx_add_device_mdio(0xfffffffc);
+
+	ar71xx_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ar71xx_eth0_data.phy_mask = 0x00000003;
+
+	ar71xx_add_device_eth(0);
+
+	ar71xx_pci_init(ARRAY_SIZE(rb4xx_pci_irqs), rb4xx_pci_irqs);
+}
+
+MIPS_MACHINE(AR71XX_MACH_RB_411, "411", "MikroTik RouterBOARD 411/A/AH",
+	     rb411_setup);
+
+static void __init rb411u_setup(void)
+{
+	rb411_setup();
+	ar71xx_add_device_usb();
+}
+
+MIPS_MACHINE(AR71XX_MACH_RB_411U, "411U", "MikroTik RouterBOARD 411U",
+	     rb411u_setup);
+
+static void __init rb433_setup(void)
+{
+	rb4xx_generic_setup();
+	rb433_add_device_spi();
+
+	ar71xx_add_device_mdio(0xffffffe9);
+
+	ar71xx_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ar71xx_eth0_data.speed = SPEED_100;
+	ar71xx_eth0_data.duplex = DUPLEX_FULL;
+
+	ar71xx_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ar71xx_eth1_data.phy_mask = 0x00000010;
+
+	ar71xx_add_device_eth(1);
+	ar71xx_add_device_eth(0);
+
+	ar71xx_pci_init(ARRAY_SIZE(rb4xx_pci_irqs), rb4xx_pci_irqs);
+}
+
+MIPS_MACHINE(AR71XX_MACH_RB_433, "433", "MikroTik RouterBOARD 433/AH",
+	     rb433_setup);
+
+static void __init rb433u_setup(void)
+{
+	rb433_setup();
+	ar71xx_add_device_usb();
+}
+
+MIPS_MACHINE(AR71XX_MACH_RB_433U, "433U", "MikroTik RouterBOARD 433UAH",
+	     rb433u_setup);
+
+static void __init rb450_generic_setup(int gige)
+{
+	rb4xx_generic_setup();
+	rb4xx_add_device_spi();
+
+	ar71xx_add_device_mdio(0xffffffe0);
+
+	ar71xx_eth0_data.phy_if_mode = (gige) ? PHY_INTERFACE_MODE_RGMII : PHY_INTERFACE_MODE_MII;
+	ar71xx_eth0_data.phy_mask = (gige) ? (1 << 0) : 0;
+	ar71xx_eth0_data.speed = (gige) ? SPEED_1000 : SPEED_100;
+	ar71xx_eth0_data.duplex = DUPLEX_FULL;
+
+	ar71xx_eth1_data.phy_if_mode = (gige) ? PHY_INTERFACE_MODE_RGMII : PHY_INTERFACE_MODE_RMII;
+	ar71xx_eth1_data.phy_mask = 0x00000010;
+
+	ar71xx_add_device_eth(1);
+	ar71xx_add_device_eth(0);
+}
+
+static void __init rb450_setup(void)
+{
+	rb450_generic_setup(0);
+}
+
+MIPS_MACHINE(AR71XX_MACH_RB_450, "450", "MikroTik RouterBOARD 450",
+	     rb450_setup);
+
+static void __init rb450g_setup(void)
+{
+	rb450_generic_setup(1);
+}
+
+MIPS_MACHINE(AR71XX_MACH_RB_450G, "450G", "MikroTik RouterBOARD 450G",
+	     rb450g_setup);
+
+static void __init rb493_setup(void)
+{
+	rb4xx_generic_setup();
+	rb4xx_add_device_spi();
+
+	ar71xx_add_device_mdio(0x3fffff00);
+
+	ar71xx_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ar71xx_eth0_data.speed = SPEED_100;
+	ar71xx_eth0_data.duplex = DUPLEX_FULL;
+
+	ar71xx_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ar71xx_eth1_data.phy_mask = 0x00000001;
+
+	ar71xx_add_device_eth(0);
+	ar71xx_add_device_eth(1);
+
+	ar71xx_pci_init(ARRAY_SIZE(rb4xx_pci_irqs), rb4xx_pci_irqs);
+}
+
+MIPS_MACHINE(AR71XX_MACH_RB_493, "493", "MikroTik RouterBOARD 493/AH",
+	     rb493_setup);
diff --git a/arch/mips/ar71xx/mach-rb750.c b/arch/mips/ar71xx/mach-rb750.c
new file mode 100644
index 0000000..3972f57
--- /dev/null
+++ b/arch/mips/ar71xx/mach-rb750.c
@@ -0,0 +1,133 @@
+/*
+ *  MikroTik RouterBOARD 750 support
+ *
+ *  Copyright (C) 2010 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/platform_device.h>
+#include <asm/mach-ar71xx/ar71xx.h>
+#include <asm/mach-ar71xx/mach-rb750.h>
+
+#include "machtype.h"
+#include "dev-ap91-eth.h"
+
+static struct rb750_led_data rb750_leds[] = {
+	{
+		.name		= "rb750:green:act",
+		.mask		= RB750_LED_ACT,
+		.active_low	= 1,
+	}, {
+		.name		= "rb750:green:port1",
+		.mask		= RB750_LED_PORT5,
+		.active_low	= 1,
+	}, {
+		.name		= "rb750:green:port2",
+		.mask		= RB750_LED_PORT4,
+		.active_low	= 1,
+	}, {
+		.name		= "rb750:green:port3",
+		.mask		= RB750_LED_PORT3,
+		.active_low	= 1,
+	}, {
+		.name		= "rb750:green:port4",
+		.mask		= RB750_LED_PORT2,
+		.active_low	= 1,
+	}, {
+		.name		= "rb750:green:port5",
+		.mask		= RB750_LED_PORT1,
+		.active_low	= 1,
+	}
+};
+
+static struct rb750_led_platform_data rb750_leds_data = {
+	.num_leds	= ARRAY_SIZE(rb750_leds),
+	.leds		= rb750_leds,
+};
+
+static struct platform_device rb750_leds_device = {
+	.name	= "leds-rb750",
+	.dev	= {
+		.platform_data = &rb750_leds_data,
+	}
+};
+
+static const char *rb750_port_names[AP91_ETH_NUM_PORT_NAMES] __initdata = {
+	"port5",
+	"port4",
+	"port3",
+	"port2",
+};
+
+static struct platform_device rb750_nand_device = {
+	.name	= "rb750-nand",
+	.id	= -1,
+};
+
+int rb750_latch_change(u32 mask_clr, u32 mask_set)
+{
+	static DEFINE_SPINLOCK(lock);
+	static u32 latch_set = RB750_LED_BITS | RB750_LVC573_LE;
+	static u32 latch_oe;
+	static u32 latch_clr;
+	unsigned long flags;
+	u32 t;
+	int ret = 0;
+
+	spin_lock_irqsave(&lock, flags);
+
+	if ((mask_clr & BIT(31)) != 0 &&
+	    (latch_set & RB750_LVC573_LE) == 0) {
+		goto unlock;
+	}
+
+	latch_set = (latch_set | mask_set) & ~mask_clr;
+	latch_clr = (latch_clr | mask_clr) & ~mask_set;
+
+	if (latch_oe == 0)
+		latch_oe = __raw_readl(ar71xx_gpio_base + GPIO_REG_OE);
+
+	if (likely(latch_set & RB750_LVC573_LE)) {
+		void __iomem *base = ar71xx_gpio_base;
+
+		t = __raw_readl(base + GPIO_REG_OE);
+		t |= mask_clr | latch_oe | mask_set;
+
+		__raw_writel(t, base + GPIO_REG_OE);
+		__raw_writel(latch_clr, base + GPIO_REG_CLEAR);
+		__raw_writel(latch_set, base + GPIO_REG_SET);
+	} else if (mask_clr & RB750_LVC573_LE) {
+		void __iomem *base = ar71xx_gpio_base;
+
+		latch_oe = __raw_readl(base + GPIO_REG_OE);
+		__raw_writel(RB750_LVC573_LE, base + GPIO_REG_CLEAR);
+		/* flush write */
+		__raw_readl(base + GPIO_REG_CLEAR);
+	}
+
+	ret = 1;
+
+ unlock:
+	spin_unlock_irqrestore(&lock, flags);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(rb750_latch_change);
+
+static void __init rb750_setup(void)
+{
+	ar71xx_gpio_function_disable(AR724X_GPIO_FUNC_ETH_SWITCH_LED0_EN |
+				     AR724X_GPIO_FUNC_ETH_SWITCH_LED1_EN |
+				     AR724X_GPIO_FUNC_ETH_SWITCH_LED2_EN |
+				     AR724X_GPIO_FUNC_ETH_SWITCH_LED3_EN |
+				     AR724X_GPIO_FUNC_ETH_SWITCH_LED4_EN);
+
+	ap91_eth_init(NULL, rb750_port_names);
+	platform_device_register(&rb750_leds_device);
+	platform_device_register(&rb750_nand_device);
+}
+
+MIPS_MACHINE(AR71XX_MACH_RB_750, "750i", "MikroTik RouterBOARD 750",
+	     rb750_setup);
diff --git a/arch/mips/ar71xx/mach-tew-632brp.c b/arch/mips/ar71xx/mach-tew-632brp.c
new file mode 100644
index 0000000..787f83e
--- /dev/null
+++ b/arch/mips/ar71xx/mach-tew-632brp.c
@@ -0,0 +1,149 @@
+/*
+ *  TrendNET TEW-632BRP board support
+ *
+ *  Copyright (C) 2008-2009 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/mach-ar71xx/ar71xx.h>
+
+#include "machtype.h"
+#include "devices.h"
+#include "dev-m25p80.h"
+#include "dev-ar913x-wmac.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "nvram.h"
+
+#define TEW_632BRP_GPIO_LED_STATUS	1
+#define TEW_632BRP_GPIO_LED_WPS		3
+#define TEW_632BRP_GPIO_LED_WLAN	6
+#define TEW_632BRP_GPIO_BTN_WPS		12
+#define TEW_632BRP_GPIO_BTN_RESET	21
+
+#define TEW_632BRP_BUTTONS_POLL_INTERVAL	20
+
+#define TEW_632BRP_CONFIG_ADDR	0x1f020000
+#define TEW_632BRP_CONFIG_SIZE	0x10000
+
+#ifdef CONFIG_MTD_PARTITIONS
+static struct mtd_partition tew_632brp_partitions[] = {
+	{
+		.name		= "u-boot",
+		.offset		= 0,
+		.size		= 0x020000,
+		.mask_flags	= MTD_WRITEABLE,
+	} , {
+		.name		= "config",
+		.offset		= 0x020000,
+		.size		= 0x010000,
+	} , {
+		.name		= "kernel",
+		.offset		= 0x030000,
+		.size		= 0x0d0000,
+	} , {
+		.name		= "rootfs",
+		.offset		= 0x100000,
+		.size		= 0x2f0000,
+	} , {
+		.name		= "art",
+		.offset		= 0x3f0000,
+		.size		= 0x010000,
+		.mask_flags	= MTD_WRITEABLE,
+	} , {
+		.name		= "firmware",
+		.offset		= 0x030000,
+		.size		= 0x3c0000,
+	}
+};
+#endif /* CONFIG_MTD_PARTITIONS */
+
+static struct flash_platform_data tew_632brp_flash_data = {
+#ifdef CONFIG_MTD_PARTITIONS
+        .parts          = tew_632brp_partitions,
+        .nr_parts       = ARRAY_SIZE(tew_632brp_partitions),
+#endif
+};
+
+static struct gpio_led tew_632brp_leds_gpio[] __initdata = {
+	{
+		.name		= "tew-632brp:green:status",
+		.gpio		= TEW_632BRP_GPIO_LED_STATUS,
+		.active_low	= 1,
+	}, {
+		.name		= "tew-632brp:blue:wps",
+		.gpio		= TEW_632BRP_GPIO_LED_WPS,
+		.active_low	= 1,
+	}, {
+		.name		= "tew-632brp:green:wlan",
+		.gpio		= TEW_632BRP_GPIO_LED_WLAN,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_button tew_632brp_gpio_buttons[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= BTN_0,
+		.threshold	= 3,
+		.gpio		= TEW_632BRP_GPIO_BTN_RESET,
+	}, {
+		.desc		= "wps",
+		.type		= EV_KEY,
+		.code		= BTN_1,
+		.threshold	= 3,
+		.gpio		= TEW_632BRP_GPIO_BTN_WPS,
+	}
+};
+
+#define TEW_632BRP_LAN_PHYMASK	BIT(0)
+#define TEW_632BRP_WAN_PHYMASK	BIT(4)
+#define TEW_632BRP_MDIO_MASK	(~(TEW_632BRP_LAN_PHYMASK | \
+				   TEW_632BRP_WAN_PHYMASK))
+
+static void __init tew_632brp_setup(void)
+{
+	const char *config = (char *) KSEG1ADDR(TEW_632BRP_CONFIG_ADDR);
+	u8 *eeprom = (u8 *) KSEG1ADDR(0x1fff1000);
+	u8 mac[6];
+	u8 *wlan_mac = NULL;
+
+	if (nvram_parse_mac_addr(config, TEW_632BRP_CONFIG_SIZE,
+			         "lan_mac=", mac) == 0) {
+		ar71xx_set_mac_base(mac);
+		wlan_mac = mac;
+	}
+
+	ar71xx_add_device_mdio(TEW_632BRP_MDIO_MASK);
+
+	ar71xx_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ar71xx_eth0_data.phy_mask = TEW_632BRP_LAN_PHYMASK;
+
+	ar71xx_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ar71xx_eth1_data.phy_mask = TEW_632BRP_WAN_PHYMASK;
+
+	ar71xx_add_device_eth(0);
+	ar71xx_add_device_eth(1);
+
+	ar71xx_add_device_m25p80(&tew_632brp_flash_data);
+
+	ar71xx_add_device_leds_gpio(-1, ARRAY_SIZE(tew_632brp_leds_gpio),
+					tew_632brp_leds_gpio);
+
+	ar71xx_add_device_gpio_buttons(-1, TEW_632BRP_BUTTONS_POLL_INTERVAL,
+					ARRAY_SIZE(tew_632brp_gpio_buttons),
+					tew_632brp_gpio_buttons);
+
+	ar913x_add_device_wmac(eeprom, wlan_mac);
+}
+
+MIPS_MACHINE(AR71XX_MACH_TEW_632BRP, "TEW-632BRP", "TRENDnet TEW-632BRP",
+	     tew_632brp_setup);
diff --git a/arch/mips/ar71xx/mach-tl-wr1043nd.c b/arch/mips/ar71xx/mach-tl-wr1043nd.c
new file mode 100644
index 0000000..3b7b764
--- /dev/null
+++ b/arch/mips/ar71xx/mach-tl-wr1043nd.c
@@ -0,0 +1,156 @@
+/*
+ *  TP-LINK TL-WR1043ND board support
+ *
+ *  Copyright (C) 2009 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <linux/platform_device.h>
+#include <linux/rtl8366rb.h>
+#include <asm/mach-ar71xx/ar71xx.h>
+
+#include "machtype.h"
+#include "devices.h"
+#include "dev-m25p80.h"
+#include "dev-ar913x-wmac.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-usb.h"
+
+#define TL_WR1043ND_GPIO_LED_USB        1
+#define TL_WR1043ND_GPIO_LED_SYSTEM     2
+#define TL_WR1043ND_GPIO_LED_QSS        5
+#define TL_WR1043ND_GPIO_LED_WLAN       9
+
+#define TL_WR1043ND_GPIO_BTN_RESET      3
+#define TL_WR1043ND_GPIO_BTN_QSS        7
+
+#define TL_WR1043ND_GPIO_RTL8366_SDA	18
+#define TL_WR1043ND_GPIO_RTL8366_SCK	19
+
+#define TL_WR1043ND_BUTTONS_POLL_INTERVAL     20
+
+#ifdef CONFIG_MTD_PARTITIONS
+static struct mtd_partition tl_wr1043nd_partitions[] = {
+	{
+		.name		= "u-boot",
+		.offset		= 0,
+		.size		= 0x020000,
+		.mask_flags	= MTD_WRITEABLE,
+	} , {
+		.name		= "kernel",
+		.offset		= 0x020000,
+		.size		= 0x140000,
+	} , {
+		.name		= "rootfs",
+		.offset		= 0x160000,
+		.size		= 0x690000,
+	} , {
+		.name		= "art",
+		.offset		= 0x7f0000,
+		.size		= 0x010000,
+		.mask_flags	= MTD_WRITEABLE,
+	} , {
+		.name		= "firmware",
+		.offset		= 0x020000,
+		.size		= 0x7d0000,
+	}
+};
+#endif /* CONFIG_MTD_PARTITIONS */
+
+static struct flash_platform_data tl_wr1043nd_flash_data = {
+#ifdef CONFIG_MTD_PARTITIONS
+	.parts		= tl_wr1043nd_partitions,
+	.nr_parts	= ARRAY_SIZE(tl_wr1043nd_partitions),
+#endif
+};
+
+static struct gpio_led tl_wr1043nd_leds_gpio[] __initdata = {
+	{
+		.name		= "tl-wr1043nd:green:usb",
+		.gpio		= TL_WR1043ND_GPIO_LED_USB,
+		.active_low	= 1,
+	}, {
+		.name		= "tl-wr1043nd:green:system",
+		.gpio		= TL_WR1043ND_GPIO_LED_SYSTEM,
+		.active_low	= 1,
+	}, {
+		.name		= "tl-wr1043nd:green:qss",
+		.gpio		= TL_WR1043ND_GPIO_LED_QSS,
+		.active_low	= 0,
+	}, {
+		.name		= "tl-wr1043nd:green:wlan",
+		.gpio		= TL_WR1043ND_GPIO_LED_WLAN,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_button tl_wr1043nd_gpio_buttons[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= BTN_0,
+		.threshold	= 3,
+		.gpio		= TL_WR1043ND_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}, {
+		.desc		= "qss",
+		.type		= EV_KEY,
+		.code		= BTN_1,
+		.threshold	= 3,
+		.gpio		= TL_WR1043ND_GPIO_BTN_QSS,
+		.active_low	= 1,
+	}
+};
+
+static struct rtl8366rb_platform_data tl_wr1043nd_rtl8366rb_data = {
+	.gpio_sda        = TL_WR1043ND_GPIO_RTL8366_SDA,
+	.gpio_sck        = TL_WR1043ND_GPIO_RTL8366_SCK,
+};
+
+static struct platform_device tl_wr1043nd_rtl8366rb_device = {
+	.name		= RTL8366RB_DRIVER_NAME,
+	.id		= -1,
+	.dev = {
+		.platform_data	= &tl_wr1043nd_rtl8366rb_data,
+	}
+};
+
+static void __init tl_wr1043nd_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f01fc00);
+	u8 *eeprom = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	ar71xx_set_mac_base(mac);
+
+	ar71xx_eth0_data.mii_bus_dev = &tl_wr1043nd_rtl8366rb_device.dev;
+	ar71xx_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ar71xx_eth0_data.speed = SPEED_1000;
+	ar71xx_eth0_data.duplex = DUPLEX_FULL;
+	ar71xx_eth0_pll_data.pll_1000 = 0x1a000000;
+
+	ar71xx_add_device_eth(0);
+
+	ar71xx_add_device_usb();
+
+	ar71xx_add_device_m25p80(&tl_wr1043nd_flash_data);
+
+	ar71xx_add_device_leds_gpio(-1, ARRAY_SIZE(tl_wr1043nd_leds_gpio),
+					tl_wr1043nd_leds_gpio);
+
+	platform_device_register(&tl_wr1043nd_rtl8366rb_device);
+
+	ar71xx_add_device_gpio_buttons(-1, TL_WR1043ND_BUTTONS_POLL_INTERVAL,
+					ARRAY_SIZE(tl_wr1043nd_gpio_buttons),
+					tl_wr1043nd_gpio_buttons);
+
+	ar913x_add_device_wmac(eeprom, mac);
+}
+
+MIPS_MACHINE(AR71XX_MACH_TL_WR1043ND, "TL-WR1043ND", "TP-LINK TL-WR1043ND",
+	     tl_wr1043nd_setup);
diff --git a/arch/mips/ar71xx/mach-tl-wr741nd.c b/arch/mips/ar71xx/mach-tl-wr741nd.c
new file mode 100644
index 0000000..5014ece
--- /dev/null
+++ b/arch/mips/ar71xx/mach-tl-wr741nd.c
@@ -0,0 +1,131 @@
+/*
+ *  TP-LINK TL-WR741ND board support
+ *
+ *  Copyright (C) 2009-2010 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/mach-ar71xx/ar71xx.h>
+
+#include "machtype.h"
+#include "devices.h"
+#include "dev-m25p80.h"
+#include "dev-ap91-eth.h"
+#include "dev-ap91-pci.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+
+#define TL_WR741ND_GPIO_LED_QSS		0
+#define TL_WR741ND_GPIO_LED_SYSTEM	1
+
+#define TL_WR741ND_GPIO_BTN_RESET	11
+#define TL_WR741ND_GPIO_BTN_QSS		12
+
+#define TL_WR741ND_BUTTONS_POLL_INTERVAL	20
+
+#ifdef CONFIG_MTD_PARTITIONS
+static struct mtd_partition tl_wr741nd_partitions[] = {
+	{
+		.name		= "u-boot",
+		.offset		= 0,
+		.size		= 0x020000,
+		.mask_flags	= MTD_WRITEABLE,
+	} , {
+		.name		= "kernel",
+		.offset		= 0x020000,
+		.size		= 0x140000,
+	} , {
+		.name		= "rootfs",
+		.offset		= 0x160000,
+		.size		= 0x290000,
+	} , {
+		.name		= "art",
+		.offset		= 0x3f0000,
+		.size		= 0x010000,
+		.mask_flags	= MTD_WRITEABLE,
+	} , {
+		.name		= "firmware",
+		.offset		= 0x020000,
+		.size		= 0x3d0000,
+	}
+};
+#endif /* CONFIG_MTD_PARTITIONS */
+
+static struct flash_platform_data tl_wr741nd_flash_data = {
+#ifdef CONFIG_MTD_PARTITIONS
+        .parts          = tl_wr741nd_partitions,
+        .nr_parts       = ARRAY_SIZE(tl_wr741nd_partitions),
+#endif
+};
+
+static struct gpio_led tl_wr741nd_leds_gpio[] __initdata = {
+	{
+		.name		= "tl-wr741nd:green:system",
+		.gpio		= TL_WR741ND_GPIO_LED_SYSTEM,
+		.active_low	= 1,
+	}, {
+		.name		= "tl-wr741nd:green:qss",
+		.gpio		= TL_WR741ND_GPIO_LED_QSS,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_button tl_wr741nd_gpio_buttons[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= BTN_0,
+		.threshold	= 3,
+		.gpio		= TL_WR741ND_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}, {
+		.desc		= "qss",
+		.type		= EV_KEY,
+		.code		= BTN_1,
+		.threshold	= 3,
+		.gpio		= TL_WR741ND_GPIO_BTN_QSS,
+		.active_low	= 1,
+	}
+};
+
+static void __init tl_wr741nd_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f01fc00);
+	u8 *ee = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	ar71xx_add_device_m25p80(&tl_wr741nd_flash_data);
+
+	ar71xx_add_device_leds_gpio(-1, ARRAY_SIZE(tl_wr741nd_leds_gpio),
+					tl_wr741nd_leds_gpio);
+
+	ar71xx_add_device_gpio_buttons(-1, TL_WR741ND_BUTTONS_POLL_INTERVAL,
+					ARRAY_SIZE(tl_wr741nd_gpio_buttons),
+					tl_wr741nd_gpio_buttons);
+
+	ar71xx_eth1_data.has_ar7240_switch = 1;
+	ar71xx_set_mac_base(mac);
+
+	/* WAN port */
+	ar71xx_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ar71xx_eth0_data.speed = SPEED_100;
+	ar71xx_eth0_data.duplex = DUPLEX_FULL;
+
+	/* LAN ports */
+	ar71xx_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ar71xx_eth1_data.speed = SPEED_1000;
+	ar71xx_eth1_data.duplex = DUPLEX_FULL;
+
+	ar71xx_add_device_mdio(0x0);
+	ar71xx_add_device_eth(1);
+	ar71xx_add_device_eth(0);
+
+	ap91_pci_init(ee, mac);
+}
+MIPS_MACHINE(AR71XX_MACH_TL_WR741ND, "TL-WR741ND", "TP-LINK TL-WR741ND",
+	     tl_wr741nd_setup);
diff --git a/arch/mips/ar71xx/mach-tl-wr841n.c b/arch/mips/ar71xx/mach-tl-wr841n.c
new file mode 100644
index 0000000..1b849e1
--- /dev/null
+++ b/arch/mips/ar71xx/mach-tl-wr841n.c
@@ -0,0 +1,143 @@
+/*
+ *  TP-LINK TL-WR841N board support
+ *
+ *  Copyright (C) 2009 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/mach-ar71xx/ar71xx.h>
+
+#include "machtype.h"
+#include "devices.h"
+#include "dev-dsa.h"
+#include "dev-m25p80.h"
+#include "dev-gpio-buttons.h"
+#include "dev-pb42-pci.h"
+#include "dev-leds-gpio.h"
+
+#define TL_WR841ND_V1_GPIO_LED_SYSTEM		2
+#define TL_WR841ND_V1_GPIO_LED_QSS_GREEN	4
+#define TL_WR841ND_V1_GPIO_LED_QSS_RED		5
+
+#define TL_WR841ND_V1_GPIO_BTN_RESET	3
+#define TL_WR841ND_V1_GPIO_BTN_QSS	7
+
+#define TL_WR841ND_V1_BUTTONS_POLL_INTERVAL	20
+
+#ifdef CONFIG_MTD_PARTITIONS
+static struct mtd_partition tl_wr841n_v1_partitions[] = {
+	{
+		.name		= "redboot",
+		.offset		= 0,
+		.size		= 0x020000,
+		.mask_flags	= MTD_WRITEABLE,
+	} , {
+		.name		= "kernel",
+		.offset		= 0x020000,
+		.size		= 0x140000,
+	} , {
+		.name		= "rootfs",
+		.offset		= 0x160000,
+		.size		= 0x280000,
+	} , {
+		.name		= "config",
+		.offset		= 0x3e0000,
+		.size		= 0x020000,
+		.mask_flags	= MTD_WRITEABLE,
+	} , {
+		.name		= "firmware",
+		.offset		= 0x020000,
+		.size		= 0x3c0000,
+	}
+};
+#endif /* CONFIG_MTD_PARTITIONS */
+
+static struct flash_platform_data tl_wr841n_v1_flash_data = {
+#ifdef CONFIG_MTD_PARTITIONS
+        .parts          = tl_wr841n_v1_partitions,
+        .nr_parts       = ARRAY_SIZE(tl_wr841n_v1_partitions),
+#endif
+};
+
+static struct gpio_led tl_wr841n_v1_leds_gpio[] __initdata = {
+	{
+		.name		= "tl-wr841n:green:system",
+		.gpio		= TL_WR841ND_V1_GPIO_LED_SYSTEM,
+		.active_low	= 1,
+	}, {
+		.name		= "tl-wr841n:red:qss",
+		.gpio		= TL_WR841ND_V1_GPIO_LED_QSS_RED,
+	}, {
+		.name		= "tl-wr841n:green:qss",
+		.gpio		= TL_WR841ND_V1_GPIO_LED_QSS_GREEN,
+	}
+};
+
+static struct gpio_button tl_wr841n_v1_gpio_buttons[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= BTN_0,
+		.threshold	= 3,
+		.gpio		= TL_WR841ND_V1_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}, {
+		.desc		= "qss",
+		.type		= EV_KEY,
+		.code		= BTN_1,
+		.threshold	= 3,
+		.gpio		= TL_WR841ND_V1_GPIO_BTN_QSS,
+		.active_low	= 1,
+	}
+};
+
+static struct dsa_chip_data tl_wr841n_v1_dsa_chip = {
+	.port_names[0]  = "wan",
+	.port_names[1]  = "lan1",
+	.port_names[2]  = "lan2",
+	.port_names[3]  = "lan3",
+	.port_names[4]  = "lan4",
+	.port_names[5]  = "cpu",
+};
+
+static struct dsa_platform_data tl_wr841n_v1_dsa_data = {
+	.nr_chips	= 1,
+	.chip		= &tl_wr841n_v1_dsa_chip,
+};
+
+static void __init tl_wr841n_v1_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f01fc00);
+
+	ar71xx_set_mac_base(mac);
+
+	ar71xx_add_device_mdio(0x0);
+
+	ar71xx_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ar71xx_eth0_data.speed = SPEED_100;
+	ar71xx_eth0_data.duplex = DUPLEX_FULL;
+
+	ar71xx_add_device_eth(0);
+
+	ar71xx_add_device_dsa(0, &tl_wr841n_v1_dsa_data);
+
+	ar71xx_add_device_m25p80(&tl_wr841n_v1_flash_data);
+
+	ar71xx_add_device_leds_gpio(-1, ARRAY_SIZE(tl_wr841n_v1_leds_gpio),
+					tl_wr841n_v1_leds_gpio);
+
+	ar71xx_add_device_gpio_buttons(-1, TL_WR841ND_V1_BUTTONS_POLL_INTERVAL,
+					ARRAY_SIZE(tl_wr841n_v1_gpio_buttons),
+					tl_wr841n_v1_gpio_buttons);
+
+	pb42_pci_init();
+}
+
+MIPS_MACHINE(AR71XX_MACH_TL_WR841N_V1, "TL-WR841N-v1.5", "TP-LINK TL-WR841N v1",
+	     tl_wr841n_v1_setup);
diff --git a/arch/mips/ar71xx/mach-tl-wr941nd.c b/arch/mips/ar71xx/mach-tl-wr941nd.c
new file mode 100644
index 0000000..0c64893
--- /dev/null
+++ b/arch/mips/ar71xx/mach-tl-wr941nd.c
@@ -0,0 +1,142 @@
+/*
+ *  TP-LINK TL-WR941ND board support
+ *
+ *  Copyright (C) 2009-2010 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/mach-ar71xx/ar71xx.h>
+
+#include "machtype.h"
+#include "devices.h"
+#include "dev-dsa.h"
+#include "dev-m25p80.h"
+#include "dev-ar913x-wmac.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+
+#define TL_WR941ND_GPIO_LED_SYSTEM	2
+#define TL_WR941ND_GPIO_LED_QSS_RED	4
+#define TL_WR941ND_GPIO_LED_QSS_GREEN	5
+
+#define TL_WR941ND_GPIO_BTN_RESET	3
+#define TL_WR941ND_GPIO_BTN_QSS		7
+
+#define TL_WR941ND_BUTTONS_POLL_INTERVAL	20
+
+#ifdef CONFIG_MTD_PARTITIONS
+static struct mtd_partition tl_wr941nd_partitions[] = {
+	{
+		.name		= "u-boot",
+		.offset		= 0,
+		.size		= 0x020000,
+		.mask_flags	= MTD_WRITEABLE,
+	} , {
+		.name		= "kernel",
+		.offset		= 0x020000,
+		.size		= 0x140000,
+	} , {
+		.name		= "rootfs",
+		.offset		= 0x160000,
+		.size		= 0x290000,
+	} , {
+		.name		= "art",
+		.offset		= 0x3f0000,
+		.size		= 0x010000,
+		.mask_flags	= MTD_WRITEABLE,
+	} , {
+		.name		= "firmware",
+		.offset		= 0x020000,
+		.size		= 0x3d0000,
+	}
+};
+#endif /* CONFIG_MTD_PARTITIONS */
+
+static struct flash_platform_data tl_wr941nd_flash_data = {
+#ifdef CONFIG_MTD_PARTITIONS
+        .parts          = tl_wr941nd_partitions,
+        .nr_parts       = ARRAY_SIZE(tl_wr941nd_partitions),
+#endif
+};
+
+static struct gpio_led tl_wr941nd_leds_gpio[] __initdata = {
+	{
+		.name		= "tl-wr941nd:green:system",
+		.gpio		= TL_WR941ND_GPIO_LED_SYSTEM,
+		.active_low	= 1,
+	}, {
+		.name		= "tl-wr941nd:red:qss",
+		.gpio		= TL_WR941ND_GPIO_LED_QSS_RED,
+	}, {
+		.name		= "tl-wr941nd:green:qss",
+		.gpio		= TL_WR941ND_GPIO_LED_QSS_GREEN,
+	}
+};
+
+static struct gpio_button tl_wr941nd_gpio_buttons[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= BTN_0,
+		.threshold	= 3,
+		.gpio		= TL_WR941ND_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}, {
+		.desc		= "qss",
+		.type		= EV_KEY,
+		.code		= BTN_1,
+		.threshold	= 3,
+		.gpio		= TL_WR941ND_GPIO_BTN_QSS,
+		.active_low	= 1,
+	}
+};
+
+static struct dsa_chip_data tl_wr941nd_dsa_chip = {
+	.port_names[0]  = "wan",
+	.port_names[1]  = "lan1",
+	.port_names[2]  = "lan2",
+	.port_names[3]  = "lan3",
+	.port_names[4]  = "lan4",
+	.port_names[5]  = "cpu",
+};
+
+static struct dsa_platform_data tl_wr941nd_dsa_data = {
+	.nr_chips	= 1,
+	.chip		= &tl_wr941nd_dsa_chip,
+};
+
+static void __init tl_wr941nd_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f01fc00);
+	u8 *eeprom = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	ar71xx_set_mac_base(mac);
+
+	ar71xx_add_device_mdio(0x0);
+
+	ar71xx_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ar71xx_eth0_data.speed = SPEED_100;
+	ar71xx_eth0_data.duplex = DUPLEX_FULL;
+
+	ar71xx_add_device_eth(0);
+	ar71xx_add_device_dsa(0, &tl_wr941nd_dsa_data);
+
+	ar71xx_add_device_m25p80(&tl_wr941nd_flash_data);
+
+	ar71xx_add_device_leds_gpio(-1, ARRAY_SIZE(tl_wr941nd_leds_gpio),
+					tl_wr941nd_leds_gpio);
+
+	ar71xx_add_device_gpio_buttons(-1, TL_WR941ND_BUTTONS_POLL_INTERVAL,
+					ARRAY_SIZE(tl_wr941nd_gpio_buttons),
+					tl_wr941nd_gpio_buttons);
+	ar913x_add_device_wmac(eeprom, mac);
+}
+
+MIPS_MACHINE(AR71XX_MACH_TL_WR941ND, "TL-WR941ND", "TP-LINK TL-WR941ND",
+	     tl_wr941nd_setup);
diff --git a/arch/mips/ar71xx/mach-ubnt.c b/arch/mips/ar71xx/mach-ubnt.c
new file mode 100644
index 0000000..04a08dc
--- /dev/null
+++ b/arch/mips/ar71xx/mach-ubnt.c
@@ -0,0 +1,281 @@
+/*
+ *  Ubiquiti RouterStation support
+ *
+ *  Copyright (C) 2008-2009 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *  Copyright (C) 2008 Ubiquiti <support@ubnt.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <asm/mach-ar71xx/ar71xx.h>
+
+#include "machtype.h"
+#include "devices.h"
+#include "dev-m25p80.h"
+#include "dev-ap91-pci.h"
+#include "dev-gpio-buttons.h"
+#include "dev-pb42-pci.h"
+#include "dev-leds-gpio.h"
+#include "dev-usb.h"
+
+#define UBNT_RS_GPIO_LED_RF	2
+#define UBNT_RS_GPIO_SW4	8
+
+#define UBNT_LS_SR71_GPIO_LED_D25	0
+#define UBNT_LS_SR71_GPIO_LED_D26	1
+#define UBNT_LS_SR71_GPIO_LED_D24	2
+#define UBNT_LS_SR71_GPIO_LED_D23	4
+#define UBNT_LS_SR71_GPIO_LED_D22	5
+#define UBNT_LS_SR71_GPIO_LED_D27	6
+#define UBNT_LS_SR71_GPIO_LED_D28	7
+
+#define UBNT_M_GPIO_LED_L1	0
+#define UBNT_M_GPIO_LED_L2	1
+#define UBNT_M_GPIO_LED_L3	11
+#define UBNT_M_GPIO_LED_L4	7
+#define UBNT_M_GPIO_BTN_RESET	12
+
+#define UBNT_BUTTONS_POLL_INTERVAL	20
+
+static struct gpio_led ubnt_rs_leds_gpio[] __initdata = {
+	{
+		.name		= "ubnt:green:rf",
+		.gpio		= UBNT_RS_GPIO_LED_RF,
+		.active_low	= 0,
+	}
+};
+
+static struct gpio_led ubnt_ls_sr71_leds_gpio[] __initdata = {
+	{
+		.name		= "ubnt:green:d22",
+		.gpio		= UBNT_LS_SR71_GPIO_LED_D22,
+		.active_low	= 0,
+	}, {
+		.name		= "ubnt:green:d23",
+		.gpio		= UBNT_LS_SR71_GPIO_LED_D23,
+		.active_low	= 0,
+	}, {
+		.name		= "ubnt:green:d24",
+		.gpio		= UBNT_LS_SR71_GPIO_LED_D24,
+		.active_low	= 0,
+	}, {
+		.name		= "ubnt:red:d25",
+		.gpio		= UBNT_LS_SR71_GPIO_LED_D25,
+		.active_low	= 0,
+	}, {
+		.name		= "ubnt:red:d26",
+		.gpio		= UBNT_LS_SR71_GPIO_LED_D26,
+		.active_low	= 0,
+	}, {
+		.name		= "ubnt:green:d27",
+		.gpio		= UBNT_LS_SR71_GPIO_LED_D27,
+		.active_low	= 0,
+	}, {
+		.name		= "ubnt:green:d28",
+		.gpio		= UBNT_LS_SR71_GPIO_LED_D28,
+		.active_low	= 0,
+	}
+};
+
+static struct gpio_led ubnt_m_leds_gpio[] __initdata = {
+	{
+		.name		= "ubnt:red:link1",
+		.gpio		= UBNT_M_GPIO_LED_L1,
+		.active_low	= 0,
+	}, {
+		.name		= "ubnt:orange:link2",
+		.gpio		= UBNT_M_GPIO_LED_L2,
+		.active_low	= 0,
+	}, {
+		.name		= "ubnt:green:link3",
+		.gpio		= UBNT_M_GPIO_LED_L3,
+		.active_low	= 0,
+	}, {
+		.name		= "ubnt:green:link4",
+		.gpio		= UBNT_M_GPIO_LED_L4,
+		.active_low	= 0,
+	}
+};
+
+static struct gpio_button ubnt_gpio_buttons[] __initdata = {
+	{
+		.desc		= "sw4",
+		.type		= EV_KEY,
+		.code		= BTN_0,
+		.threshold	= 3,
+		.gpio		= UBNT_RS_GPIO_SW4,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_button ubnt_m_gpio_buttons[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= BTN_0,
+		.threshold	= 3,
+		.gpio		= UBNT_M_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}
+};
+
+static void __init ubnt_generic_setup(void)
+{
+	ar71xx_add_device_m25p80(NULL);
+
+	ar71xx_add_device_gpio_buttons(-1, UBNT_BUTTONS_POLL_INTERVAL,
+					ARRAY_SIZE(ubnt_gpio_buttons),
+					ubnt_gpio_buttons);
+
+	pb42_pci_init();
+}
+
+#define UBNT_RS_WAN_PHYMASK	(1 << 20)
+#define UBNT_RS_LAN_PHYMASK	((1 << 16) | (1 << 17) | (1 << 18) | (1 << 19))
+
+static void __init ubnt_rs_setup(void)
+{
+	ubnt_generic_setup();
+
+	ar71xx_add_device_mdio(~(UBNT_RS_WAN_PHYMASK | UBNT_RS_LAN_PHYMASK));
+
+	ar71xx_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ar71xx_eth0_data.phy_mask = UBNT_RS_WAN_PHYMASK;
+
+	ar71xx_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ar71xx_eth1_data.speed = SPEED_100;
+	ar71xx_eth1_data.duplex = DUPLEX_FULL;
+
+	ar71xx_add_device_eth(0);
+	ar71xx_add_device_eth(1);
+
+	ar71xx_add_device_usb();
+
+	ar71xx_add_device_leds_gpio(-1, ARRAY_SIZE(ubnt_rs_leds_gpio),
+					ubnt_rs_leds_gpio);
+}
+
+MIPS_MACHINE(AR71XX_MACH_UBNT_RS, "UBNT-RS", "Ubiquiti RouterStation",
+	     ubnt_rs_setup);
+
+MIPS_MACHINE(AR71XX_MACH_UBNT_AR71XX, "Ubiquiti AR71xx-based board",
+	     "Ubiquiti RouterStation", ubnt_rs_setup);
+
+#define UBNT_RSPRO_WAN_PHYMASK	(1 << 4)
+#define UBNT_RSPRO_LAN_PHYMASK	((1 << 0) | (1 << 1) | (1 << 2) | (1 << 3))
+
+static void __init ubnt_rspro_setup(void)
+{
+	ubnt_generic_setup();
+
+	ar71xx_add_device_mdio(~(UBNT_RSPRO_WAN_PHYMASK | UBNT_RSPRO_LAN_PHYMASK));
+
+	ar71xx_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ar71xx_eth0_data.phy_mask = UBNT_RSPRO_WAN_PHYMASK;
+
+	ar71xx_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ar71xx_eth1_data.phy_mask = UBNT_RSPRO_LAN_PHYMASK;
+	ar71xx_eth1_data.speed = SPEED_1000;
+	ar71xx_eth1_data.duplex = DUPLEX_FULL;
+
+	ar71xx_add_device_eth(0);
+	ar71xx_add_device_eth(1);
+
+	ar71xx_add_device_usb();
+
+	ar71xx_add_device_leds_gpio(-1, ARRAY_SIZE(ubnt_rs_leds_gpio),
+					ubnt_rs_leds_gpio);
+}
+
+MIPS_MACHINE(AR71XX_MACH_UBNT_RSPRO, "UBNT-RSPRO", "Ubiquiti RouterStation Pro",
+	     ubnt_rspro_setup);
+
+static void __init ubnt_lsx_setup(void)
+{
+	ubnt_generic_setup();
+}
+
+MIPS_MACHINE(AR71XX_MACH_UBNT_LSX, "UBNT-LSX", "Ubiquiti LSX", ubnt_lsx_setup);
+
+#define UBNT_LSSR71_PHY_MASK	(1 << 1)
+
+static void __init ubnt_lssr71_setup(void)
+{
+	ubnt_generic_setup();
+
+	ar71xx_add_device_mdio(~UBNT_LSSR71_PHY_MASK);
+
+	ar71xx_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ar71xx_eth0_data.phy_mask = UBNT_LSSR71_PHY_MASK;
+
+	ar71xx_add_device_eth(0);
+
+	ar71xx_add_device_leds_gpio(-1, ARRAY_SIZE(ubnt_ls_sr71_leds_gpio),
+					ubnt_ls_sr71_leds_gpio);
+}
+
+MIPS_MACHINE(AR71XX_MACH_UBNT_LSSR71, "UBNT-LS-SR71", "Ubiquiti LS-SR71",
+	     ubnt_lssr71_setup);
+
+static void __init ubnt_m_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1fff0000);
+	u8 *ee = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	ar71xx_set_mac_base(mac);
+
+	ar71xx_add_device_m25p80(NULL);
+
+	ar71xx_add_device_mdio(~0);
+
+	ar71xx_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ar71xx_eth0_data.speed = SPEED_100;
+	ar71xx_eth0_data.duplex = DUPLEX_FULL;
+	ar71xx_eth0_data.fifo_cfg1 = 0x0010ffff;
+	ar71xx_eth0_data.fifo_cfg2 = 0x015500aa;
+	ar71xx_eth0_data.fifo_cfg3 = 0x01f00140;
+
+	ar71xx_add_device_eth(0);
+
+	ap91_pci_init(ee, NULL);
+
+	ar71xx_add_device_leds_gpio(-1, ARRAY_SIZE(ubnt_m_leds_gpio),
+					ubnt_m_leds_gpio);
+
+	ar71xx_add_device_gpio_buttons(-1, UBNT_BUTTONS_POLL_INTERVAL,
+					ARRAY_SIZE(ubnt_m_gpio_buttons),
+					ubnt_m_gpio_buttons);
+}
+
+static void __init ubnt_rocket_m_setup(void)
+{
+	ubnt_m_setup();
+	ar71xx_add_device_usb();
+}
+
+MIPS_MACHINE(AR71XX_MACH_UBNT_BULLET_M, "UBNT-BM", "Ubiquiti Bullet M",
+	     ubnt_m_setup);
+MIPS_MACHINE(AR71XX_MACH_UBNT_ROCKET_M, "UBNT-RM", "Ubiquiti Rocket M",
+	     ubnt_rocket_m_setup);
+
+/* TODO detect the second ethernet port and use one
+   init function for all Ubiquiti MIMO series products */
+static void __init ubnt_nano_m_setup(void)
+{
+	ubnt_m_setup();
+
+	ar71xx_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ar71xx_eth1_data.speed = SPEED_1000;
+	ar71xx_eth1_data.duplex = DUPLEX_FULL;
+	ar71xx_eth1_data.fifo_cfg1 = 0x0010ffff;
+	ar71xx_eth1_data.fifo_cfg2 = 0x015500aa;
+	ar71xx_eth1_data.fifo_cfg3 = 0x01f00140;
+
+	ar71xx_add_device_eth(1);
+}
+
+MIPS_MACHINE(AR71XX_MACH_UBNT_NANO_M, "UBNT-NM", "Ubiquiti Nanostation M",
+	     ubnt_nano_m_setup);
diff --git a/arch/mips/ar71xx/mach-wndr3700.c b/arch/mips/ar71xx/mach-wndr3700.c
new file mode 100644
index 0000000..62931e6
--- /dev/null
+++ b/arch/mips/ar71xx/mach-wndr3700.c
@@ -0,0 +1,209 @@
+/*
+ *  Netgear WNDR3700 board support
+ *
+ *  Copyright (C) 2009 Marco Porsch
+ *  Copyright (C) 2009-2010 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/platform_device.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <linux/delay.h>
+#include <linux/rtl8366s.h>
+
+#include <asm/mach-ar71xx/ar71xx.h>
+
+#include "machtype.h"
+#include "devices.h"
+#include "dev-m25p80.h"
+#include "dev-ap94-pci.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-usb.h"
+
+#define WNDR3700_GPIO_LED_WPS_ORANGE	0
+#define WNDR3700_GPIO_LED_POWER_ORANGE	1
+#define WNDR3700_GPIO_LED_POWER_GREEN	2
+#define WNDR3700_GPIO_LED_WPS_GREEN	4
+#define WNDR3700_GPIO_LED_WAN_GREEN	6
+
+#define WNDR3700_GPIO_BTN_WPS		3
+#define WNDR3700_GPIO_BTN_RESET		8
+#define WNDR3700_GPIO_BTN_WIFI		11
+
+#define WNDR3700_GPIO_RTL8366_SDA	5
+#define WNDR3700_GPIO_RTL8366_SCK	7
+
+#define WNDR3700_BUTTONS_POLL_INTERVAL    20
+
+#define WNDR3700_WMAC0_MAC_OFFSET	0
+#define WNDR3700_WMAC1_MAC_OFFSET	0xc
+#define WNDR3700_CALDATA0_OFFSET	0x1000
+#define WNDR3700_CALDATA1_OFFSET	0x5000
+
+#ifdef CONFIG_MTD_PARTITIONS
+static struct mtd_partition wndr3700_partitions[] = {
+	{
+		.name		= "uboot",
+		.offset		= 0,
+		.size		= 0x050000,
+		.mask_flags	= MTD_WRITEABLE,
+	} , {
+		.name		= "env",
+		.offset		= 0x050000,
+		.size		= 0x020000,
+		.mask_flags	= MTD_WRITEABLE,
+	} , {
+		.name		= "rootfs",
+		.offset		= 0x070000,
+		.size		= 0x720000,
+	} , {
+		.name		= "config",
+		.offset		= 0x790000,
+		.size		= 0x010000,
+		.mask_flags	= MTD_WRITEABLE,
+	} , {
+		.name		= "config_bak",
+		.offset		= 0x7a0000,
+		.size		= 0x010000,
+		.mask_flags	= MTD_WRITEABLE,
+	} , {
+		.name		= "pot",
+		.offset		= 0x7b0000,
+		.size		= 0x010000,
+		.mask_flags	= MTD_WRITEABLE,
+	} , {
+		.name		= "traffic_meter",
+		.offset		= 0x7c0000,
+		.size		= 0x010000,
+		.mask_flags	= MTD_WRITEABLE,
+	} , {
+		.name		= "language",
+		.offset		= 0x7d0000,
+		.size		= 0x020000,
+		.mask_flags	= MTD_WRITEABLE,
+	} , {
+		.name		= "caldata",
+		.offset		= 0x7f0000,
+		.size		= 0x010000,
+		.mask_flags	= MTD_WRITEABLE,
+	}
+};
+#endif /* CONFIG_MTD_PARTITIONS */
+
+static struct flash_platform_data wndr3700_flash_data = {
+#ifdef CONFIG_MTD_PARTITIONS
+        .parts          = wndr3700_partitions,
+        .nr_parts       = ARRAY_SIZE(wndr3700_partitions),
+#endif
+};
+
+static struct gpio_led wndr3700_leds_gpio[] __initdata = {
+	{
+		.name		= "wndr3700:green:power",
+		.gpio		= WNDR3700_GPIO_LED_POWER_GREEN,
+		.active_low	= 1,
+	}, {
+		.name		= "wndr3700:orange:power",
+		.gpio		= WNDR3700_GPIO_LED_POWER_ORANGE,
+		.active_low	= 1,
+	}, {
+		.name		= "wndr3700:green:wps",
+		.gpio		= WNDR3700_GPIO_LED_WPS_GREEN,
+		.active_low	= 1,
+	}, {
+		.name		= "wndr3700:orange:wps",
+		.gpio		= WNDR3700_GPIO_LED_WPS_ORANGE,
+		.active_low	= 1,
+	}, {
+		.name		= "wndr3700:green:wan",
+		.gpio		= WNDR3700_GPIO_LED_WAN_GREEN,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_button wndr3700_gpio_buttons[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= BTN_0,
+		.threshold	= 3,
+		.gpio		= WNDR3700_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}, {
+		.desc		= "wps",
+		.type		= EV_KEY,
+		.code		= BTN_1,
+		.threshold	= 3,
+		.gpio		= WNDR3700_GPIO_BTN_WPS,
+		.active_low	= 1,
+	} , {
+		.desc		= "wifi",
+		.type		= EV_KEY,
+		.code		= BTN_2,
+		.threshold	= 3,
+		.gpio		= WNDR3700_GPIO_BTN_WIFI,
+		.active_low	= 1,
+	}
+};
+
+static struct rtl8366s_platform_data wndr3700_rtl8366s_data = {
+	.gpio_sda        = WNDR3700_GPIO_RTL8366_SDA,
+	.gpio_sck        = WNDR3700_GPIO_RTL8366_SCK,
+};
+
+static struct platform_device wndr3700_rtl8366s_device = {
+	.name		= RTL8366S_DRIVER_NAME,
+	.id		= -1,
+	.dev = {
+		.platform_data	= &wndr3700_rtl8366s_data,
+	}
+};
+
+static void __init wndr3700_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+
+	ar71xx_set_mac_base(art);
+
+	ar71xx_eth0_pll_data.pll_1000 = 0x11110000;
+	ar71xx_eth0_data.mii_bus_dev = &wndr3700_rtl8366s_device.dev;
+	ar71xx_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ar71xx_eth0_data.speed = SPEED_1000;
+	ar71xx_eth0_data.duplex = DUPLEX_FULL;
+
+	ar71xx_eth1_pll_data.pll_1000 = 0x11110000;
+	ar71xx_eth1_data.mii_bus_dev = &wndr3700_rtl8366s_device.dev;
+	ar71xx_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ar71xx_eth1_data.phy_mask = 0x10;
+
+	ar71xx_add_device_eth(0);
+	ar71xx_add_device_eth(1);
+
+	ar71xx_add_device_usb();
+
+	ar71xx_add_device_m25p80(&wndr3700_flash_data);
+
+        ar71xx_add_device_leds_gpio(-1, ARRAY_SIZE(wndr3700_leds_gpio),
+				    wndr3700_leds_gpio);
+
+	ar71xx_add_device_gpio_buttons(-1, WNDR3700_BUTTONS_POLL_INTERVAL,
+				      ARRAY_SIZE(wndr3700_gpio_buttons),
+				      wndr3700_gpio_buttons);
+
+	platform_device_register(&wndr3700_rtl8366s_device);
+	platform_device_register_simple("wndr3700-led-usb", -1, NULL, 0);
+
+	ap94_pci_enable_quirk_wndr3700();
+	ap94_pci_init(art + WNDR3700_CALDATA0_OFFSET,
+		      art + WNDR3700_WMAC0_MAC_OFFSET,
+		      art + WNDR3700_CALDATA1_OFFSET,
+		      art + WNDR3700_WMAC1_MAC_OFFSET);
+}
+
+MIPS_MACHINE(AR71XX_MACH_WNDR3700, "WNDR3700", "NETGEAR WNDR3700",
+	     wndr3700_setup);
diff --git a/arch/mips/ar71xx/mach-wnr2000.c b/arch/mips/ar71xx/mach-wnr2000.c
new file mode 100644
index 0000000..73422d6
--- /dev/null
+++ b/arch/mips/ar71xx/mach-wnr2000.c
@@ -0,0 +1,148 @@
+/*
+ *  NETGEAR WNR2000 board support
+ *
+ *  Copyright (C) 2008-2009 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *  Copyright (C) 2008-2009 Andy Boyett <agb@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/mach-ar71xx/ar71xx.h>
+
+#include "machtype.h"
+#include "devices.h"
+#include "dev-m25p80.h"
+#include "dev-ar913x-wmac.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+
+#define WNR2000_GPIO_LED_PWR_GREEN	14
+#define WNR2000_GPIO_LED_PWR_AMBER	7
+#define WNR2000_GPIO_LED_WPS		4
+#define WNR2000_GPIO_LED_WLAN		6
+#define WNR2000_GPIO_BTN_RESET		21
+#define WNR2000_GPIO_BTN_WPS		8
+
+#define WNR2000_BUTTONS_POLL_INTERVAL	20
+
+#ifdef CONFIG_MTD_PARTITIONS
+static struct mtd_partition wnr2000_partitions[] = {
+	{
+		.name		= "u-boot",
+		.offset		= 0,
+		.size		= 0x040000,
+		.mask_flags	= MTD_WRITEABLE,
+	} , {
+		.name		= "u-boot-env",
+		.offset		= 0x040000,
+		.size		= 0x010000,
+	} , {
+		.name		= "rootfs",
+		.offset		= 0x050000,
+		.size		= 0x240000,
+	} , {
+		.name		= "user-config",
+		.offset		= 0x290000,
+		.size		= 0x010000,
+	} , {
+		.name		= "uImage",
+		.offset		= 0x2a0000,
+		.size		= 0x120000,
+	} , {
+		.name		= "language_table",
+		.offset		= 0x3c0000,
+		.size		= 0x020000,
+	} , {
+		.name		= "rootfs_checksum",
+		.offset		= 0x3e0000,
+		.size		= 0x010000,
+	} , {
+		.name		= "art",
+		.offset		= 0x3f0000,
+		.size		= 0x010000,
+		.mask_flags	= MTD_WRITEABLE,
+	}
+};
+#endif /* CONFIG_MTD_PARTITIONS */
+
+static struct flash_platform_data wnr2000_flash_data = {
+#ifdef CONFIG_MTD_PARTITIONS
+        .parts          = wnr2000_partitions,
+        .nr_parts       = ARRAY_SIZE(wnr2000_partitions),
+#endif
+};
+
+static struct gpio_led wnr2000_leds_gpio[] __initdata = {
+	{
+		.name		= "wnr2000:green:power",
+		.gpio		= WNR2000_GPIO_LED_PWR_GREEN,
+		.active_low	= 1,
+	}, {
+		.name		= "wnr2000:amber:power",
+		.gpio		= WNR2000_GPIO_LED_PWR_AMBER,
+		.active_low	= 1,
+	}, {
+		.name		= "wnr2000:green:wps",
+		.gpio		= WNR2000_GPIO_LED_WPS,
+		.active_low	= 1,
+	}, {
+		.name		= "wnr2000:blue:wlan",
+		.gpio		= WNR2000_GPIO_LED_WLAN,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_button wnr2000_gpio_buttons[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= BTN_0,
+		.threshold	= 3,
+		.gpio		= WNR2000_GPIO_BTN_RESET,
+	}, {
+		.desc		= "wps",
+		.type		= EV_KEY,
+		.code		= BTN_1,
+		.threshold	= 3,
+		.gpio		= WNR2000_GPIO_BTN_WPS,
+	}
+};
+
+static void __init wnr2000_setup(void)
+{
+	u8 *eeprom = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	ar71xx_set_mac_base(eeprom);
+	ar71xx_add_device_mdio(0x0);
+
+	ar71xx_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ar71xx_eth0_data.speed = SPEED_100;
+	ar71xx_eth0_data.duplex = DUPLEX_FULL;
+	ar71xx_eth0_data.has_ar8216 = 1;
+
+	ar71xx_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ar71xx_eth1_data.phy_mask = 0x10;
+
+	ar71xx_add_device_eth(0);
+	ar71xx_add_device_eth(1);
+
+	ar71xx_add_device_m25p80(&wnr2000_flash_data);
+
+	ar71xx_add_device_leds_gpio(-1, ARRAY_SIZE(wnr2000_leds_gpio),
+					wnr2000_leds_gpio);
+
+	ar71xx_add_device_gpio_buttons(-1, WNR2000_BUTTONS_POLL_INTERVAL,
+					ARRAY_SIZE(wnr2000_gpio_buttons),
+					wnr2000_gpio_buttons);
+
+
+	ar913x_add_device_wmac(eeprom, NULL);
+}
+
+MIPS_MACHINE(AR71XX_MACH_WNR2000, "WNR2000", "NETGEAR WNR2000", wnr2000_setup);
diff --git a/arch/mips/ar71xx/mach-wp543.c b/arch/mips/ar71xx/mach-wp543.c
new file mode 100644
index 0000000..2258584
--- /dev/null
+++ b/arch/mips/ar71xx/mach-wp543.c
@@ -0,0 +1,99 @@
+/*
+ *  Compex WP543/WPJ543 board support
+ *
+ *  Copyright (C) 2008-2009 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/mach-ar71xx/ar71xx.h>
+
+#include "machtype.h"
+#include "devices.h"
+#include "dev-m25p80.h"
+#include "dev-pb42-pci.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-usb.h"
+
+#define WP543_GPIO_SW6		2
+#define WP543_GPIO_LED_1	3
+#define WP543_GPIO_LED_2	4
+#define WP543_GPIO_LED_WLAN	5
+#define WP543_GPIO_LED_CONN	6
+#define WP543_GPIO_LED_DIAG	7
+#define WP543_GPIO_SW4		8
+
+#define WP543_BUTTONS_POLL_INTERVAL	20
+
+static struct gpio_led wp543_leds_gpio[] __initdata = {
+	{
+		.name		= "wp543:green:led1",
+		.gpio		= WP543_GPIO_LED_1,
+		.active_low	= 1,
+	}, {
+		.name		= "wp543:green:led2",
+		.gpio		= WP543_GPIO_LED_2,
+		.active_low	= 1,
+	}, {
+		.name		= "wp543:green:wlan",
+		.gpio		= WP543_GPIO_LED_WLAN,
+		.active_low	= 1,
+	}, {
+		.name		= "wp543:green:conn",
+		.gpio		= WP543_GPIO_LED_CONN,
+		.active_low	= 1,
+	}, {
+		.name		= "wp543:green:diag",
+		.gpio		= WP543_GPIO_LED_DIAG,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_button wp543_gpio_buttons[] __initdata = {
+	{
+		.desc		= "sw6",
+		.type		= EV_KEY,
+		.code		= BTN_0,
+		.threshold	= 3,
+		.gpio		= WP543_GPIO_SW6,
+	}, {
+		.desc		= "sw4",
+		.type		= EV_KEY,
+		.code		= BTN_1,
+		.threshold	= 3,
+		.gpio		= WP543_GPIO_SW4,
+	}
+};
+
+static void __init wp543_setup(void)
+{
+	ar71xx_add_device_m25p80(NULL);
+
+	ar71xx_add_device_mdio(0xfffffff7);
+
+	ar71xx_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ar71xx_eth0_data.phy_mask = 0x08;
+	ar71xx_eth0_data.reset_bit = RESET_MODULE_GE0_MAC |
+				     RESET_MODULE_GE0_PHY;
+	ar71xx_add_device_eth(0);
+
+	ar71xx_add_device_usb();
+
+	pb42_pci_init();
+
+	ar71xx_add_device_leds_gpio(-1, ARRAY_SIZE(wp543_leds_gpio),
+					wp543_leds_gpio);
+
+	ar71xx_add_device_gpio_buttons(-1, WP543_BUTTONS_POLL_INTERVAL,
+					ARRAY_SIZE(wp543_gpio_buttons),
+					wp543_gpio_buttons);
+}
+
+MIPS_MACHINE(AR71XX_MACH_WP543, "WP543", "Compex WP543", wp543_setup);
diff --git a/arch/mips/ar71xx/mach-wrt160nl.c b/arch/mips/ar71xx/mach-wrt160nl.c
new file mode 100644
index 0000000..7fb97d9
--- /dev/null
+++ b/arch/mips/ar71xx/mach-wrt160nl.c
@@ -0,0 +1,158 @@
+/*
+ *  Linksys WRT160NL board support
+ *
+ *  Copyright (C) 2009 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/mach-ar71xx/ar71xx.h>
+
+#include "machtype.h"
+#include "devices.h"
+#include "dev-m25p80.h"
+#include "dev-ar913x-wmac.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-usb.h"
+#include "nvram.h"
+
+#define WRT160NL_GPIO_LED_POWER		14
+#define WRT160NL_GPIO_LED_WPS_AMBER	9
+#define WRT160NL_GPIO_LED_WPS_BLUE	8
+#define WRT160NL_GPIO_LED_WLAN		6
+
+#define WRT160NL_GPIO_BTN_WPS		7
+#define WRT160NL_GPIO_BTN_RESET		21
+
+#define WRT160NL_BUTTONS_POLL_INTERVAL	20
+
+#define WRT160NL_NVRAM_ADDR	0x1f7e0000
+#define WRT160NL_NVRAM_SIZE	0x10000
+
+#ifdef CONFIG_MTD_PARTITIONS
+static struct mtd_partition wrt160nl_partitions[] = {
+	{
+		.name		= "u-boot",
+		.offset		= 0,
+		.size		= 0x040000,
+		.mask_flags	= MTD_WRITEABLE,
+	} , {
+		.name		= "kernel",
+		.offset		= 0x040000,
+		.size		= 0x0e0000,
+	} , {
+		.name		= "filesytem",
+		.offset		= 0x120000,
+		.size		= 0x6c0000,
+	} , {
+		.name		= "nvram",
+		.offset		= 0x7e0000,
+		.size		= 0x010000,
+		.mask_flags	= MTD_WRITEABLE,
+	} , {
+		.name		= "ART",
+		.offset		= 0x7f0000,
+		.size		= 0x010000,
+		.mask_flags	= MTD_WRITEABLE,
+	} , {
+		.name		= "firmware",
+		.offset		= 0x040000,
+		.size		= 0x7a0000,
+	}
+};
+#endif /* CONFIG_MTD_PARTITIONS */
+
+static struct flash_platform_data wrt160nl_flash_data = {
+#ifdef CONFIG_MTD_PARTITIONS
+        .parts          = wrt160nl_partitions,
+        .nr_parts       = ARRAY_SIZE(wrt160nl_partitions),
+#endif
+};
+
+static struct gpio_led wrt160nl_leds_gpio[] __initdata = {
+	{
+		.name		= "wrt160nl:blue:power",
+		.gpio		= WRT160NL_GPIO_LED_POWER,
+		.active_low	= 1,
+		.default_trigger = "default-on",
+	}, {
+		.name		= "wrt160nl:amber:wps",
+		.gpio		= WRT160NL_GPIO_LED_WPS_AMBER,
+		.active_low	= 1,
+	}, {
+		.name		= "wrt160nl:blue:wps",
+		.gpio		= WRT160NL_GPIO_LED_WPS_BLUE,
+		.active_low	= 1,
+	}, {
+		.name		= "wrt160nl:blue:wlan",
+		.gpio		= WRT160NL_GPIO_LED_WLAN,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_button wrt160nl_gpio_buttons[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= BTN_0,
+		.threshold	= 3,
+		.gpio		= WRT160NL_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}, {
+		.desc		= "wps",
+		.type		= EV_KEY,
+		.code		= BTN_1,
+		.threshold	= 3,
+		.gpio		= WRT160NL_GPIO_BTN_WPS,
+		.active_low	= 1,
+	}
+};
+
+static void __init wrt160nl_setup(void)
+{
+	const char *nvram = (char *) KSEG1ADDR(WRT160NL_NVRAM_ADDR);
+	u8 *eeprom = (u8 *) KSEG1ADDR(0x1fff1000);
+	u8 mac[6];
+
+	if (nvram_parse_mac_addr(nvram, WRT160NL_NVRAM_SIZE,
+			         "lan_hwaddr=", mac) == 0)
+		ar71xx_set_mac_base(mac);
+
+	ar71xx_add_device_mdio(0x0);
+
+	ar71xx_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ar71xx_eth0_data.phy_mask = 0x01;
+
+	ar71xx_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ar71xx_eth1_data.phy_mask = 0x10;
+
+	ar71xx_add_device_eth(0);
+	ar71xx_add_device_eth(1);
+
+	ar71xx_add_device_m25p80(&wrt160nl_flash_data);
+
+	ar71xx_add_device_usb();
+
+	if (nvram_parse_mac_addr(nvram, WRT160NL_NVRAM_SIZE,
+			         "wl0_hwaddr=", mac) == 0)
+		ar913x_add_device_wmac(eeprom, mac);
+	else
+		ar913x_add_device_wmac(eeprom, NULL);
+
+	ar71xx_add_device_leds_gpio(-1, ARRAY_SIZE(wrt160nl_leds_gpio),
+					wrt160nl_leds_gpio);
+
+	ar71xx_add_device_gpio_buttons(-1, WRT160NL_BUTTONS_POLL_INTERVAL,
+					ARRAY_SIZE(wrt160nl_gpio_buttons),
+					wrt160nl_gpio_buttons);
+
+}
+
+MIPS_MACHINE(AR71XX_MACH_WRT160NL, "WRT160NL", "Linksys WRT160NL",
+	     wrt160nl_setup);
diff --git a/arch/mips/ar71xx/mach-wrt400n.c b/arch/mips/ar71xx/mach-wrt400n.c
new file mode 100644
index 0000000..5ed0b60
--- /dev/null
+++ b/arch/mips/ar71xx/mach-wrt400n.c
@@ -0,0 +1,168 @@
+/*
+ *  Linksys WRT400N board support
+ *
+ *  Copyright (C) 2009-2010 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2009 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/mach-ar71xx/ar71xx.h>
+
+#include "machtype.h"
+#include "devices.h"
+#include "dev-ap94-pci.h"
+#include "dev-m25p80.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+
+#define WRT400N_GPIO_LED_ORANGE	5
+#define WRT400N_GPIO_LED_GREEN	4
+#define WRT400N_GPIO_LED_POWER	1
+#define WRT400N_GPIO_LED_WLAN	0
+
+#define WRT400N_GPIO_BTN_RESET	8
+#define WRT400N_GPIO_BTN_WLSEC	3
+
+#define WRT400N_BUTTONS_POLL_INTERVAL	20
+
+#define WRT400N_MAC_ADDR_OFFSET		0x120c
+#define WRT400N_CALDATA0_OFFSET		0x1000
+#define WRT400N_CALDATA1_OFFSET		0x5000
+
+#ifdef CONFIG_MTD_PARTITIONS
+static struct mtd_partition wrt400n_partitions[] = {
+	{
+		.name		= "uboot",
+		.offset		= 0,
+		.size		= 0x030000,
+		.mask_flags	= MTD_WRITEABLE,
+	} , {
+		.name		= "env",
+		.offset		= 0x030000,
+		.size		= 0x010000,
+		.mask_flags	= MTD_WRITEABLE,
+	} , {
+		.name		= "linux",
+		.offset		= 0x040000,
+		.size		= 0x140000,
+	} , {
+		.name		= "rootfs",
+		.offset		= 0x180000,
+		.size		= 0x630000,
+	} , {
+		.name		= "nvram",
+		.offset		= 0x7b0000,
+		.size		= 0x010000,
+		.mask_flags	= MTD_WRITEABLE,
+	} , {
+		.name		= "factory",
+		.offset		= 0x7c0000,
+		.size		= 0x010000,
+		.mask_flags	= MTD_WRITEABLE,
+	} , {
+		.name		= "language",
+		.offset		= 0x7d0000,
+		.size		= 0x020000,
+		.mask_flags	= MTD_WRITEABLE,
+	} , {
+		.name		= "caldata",
+		.offset		= 0x7f0000,
+		.size		= 0x010000,
+		.mask_flags	= MTD_WRITEABLE,
+	} , {
+		.name		= "firmware",
+		.offset		= 0x040000,
+		.size		= 0x770000,
+	}
+};
+#endif /* CONFIG_MTD_PARTITIONS */
+
+static struct flash_platform_data wrt400n_flash_data = {
+#ifdef CONFIG_MTD_PARTITIONS
+        .parts          = wrt400n_partitions,
+        .nr_parts       = ARRAY_SIZE(wrt400n_partitions),
+#endif
+};
+
+static struct gpio_led wrt400n_leds_gpio[] __initdata = {
+	{
+		.name		= "wrt400n:green:status",
+		.gpio		= WRT400N_GPIO_LED_GREEN,
+		.active_low	= 1,
+	}, {
+		.name		= "wrt400n:amber:aoss",
+		.gpio		= WRT400N_GPIO_LED_ORANGE,
+		.active_low	= 1,
+	}, {
+		.name		= "wrt400n:green:wlan",
+		.gpio		= WRT400N_GPIO_LED_WLAN,
+		.active_low	= 1,
+	}, {
+		.name		= "wrt400n:green:power",
+		.gpio		= WRT400N_GPIO_LED_POWER,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_button wrt400n_gpio_buttons[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= BTN_0,
+		.threshold	= 3,
+		.gpio		= WRT400N_GPIO_BTN_RESET,
+		.active_low	= 1,
+	} , {
+		.desc		= "wlsec",
+		.type		= EV_KEY,
+		.code		= BTN_1,
+		.threshold	= 3,
+		.gpio		= WRT400N_GPIO_BTN_WLSEC,
+		.active_low	= 1,
+	}
+};
+
+static void __init wrt400n_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+	u8 mac[6];
+	int i;
+
+	memcpy(mac, art + WRT400N_MAC_ADDR_OFFSET, 6);
+	for (i = 5; i >= 3; i--)
+		if (++mac[i] != 0x00) break;
+
+	ar71xx_set_mac_base(mac);
+
+	ar71xx_add_device_mdio(0x0);
+
+	ar71xx_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ar71xx_eth0_data.speed = SPEED_100;
+	ar71xx_eth0_data.duplex = DUPLEX_FULL;
+
+	ar71xx_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ar71xx_eth1_data.phy_mask = 0x10;
+
+	ar71xx_add_device_eth(0);
+	ar71xx_add_device_eth(1);
+
+	ar71xx_add_device_m25p80(&wrt400n_flash_data);
+
+	ar71xx_add_device_leds_gpio(-1, ARRAY_SIZE(wrt400n_leds_gpio),
+					wrt400n_leds_gpio);
+
+	ar71xx_add_device_gpio_buttons(-1, WRT400N_BUTTONS_POLL_INTERVAL,
+					ARRAY_SIZE(wrt400n_gpio_buttons),
+					wrt400n_gpio_buttons);
+
+	ap94_pci_init(art + WRT400N_CALDATA0_OFFSET, NULL,
+		      art + WRT400N_CALDATA1_OFFSET, NULL);
+}
+
+MIPS_MACHINE(AR71XX_MACH_WRT400N, "WRT400N", "Linksys WRT400N", wrt400n_setup);
diff --git a/arch/mips/ar71xx/mach-wzr-hp-g300nh.c b/arch/mips/ar71xx/mach-wzr-hp-g300nh.c
new file mode 100644
index 0000000..b52cc60
--- /dev/null
+++ b/arch/mips/ar71xx/mach-wzr-hp-g300nh.c
@@ -0,0 +1,265 @@
+/*
+ *  Buffalo WZR-HP-G300NH board support
+ *
+ *  Copyright (C) 2010 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/platform_device.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <linux/nxp_74hc153.h>
+#include <linux/rtl8366s.h>
+
+#include <asm/mips_machine.h>
+#include <asm/mach-ar71xx/ar71xx.h>
+#include <asm/mach-ar71xx/ar91xx_flash.h>
+
+#include "machtype.h"
+#include "devices.h"
+#include "dev-ar913x-wmac.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-usb.h"
+
+#define WZRHPG300NH_GPIO_LED_USB	0
+#define WZRHPG300NH_GPIO_LED_DIAG	1
+#define WZRHPG300NH_GPIO_LED_WIRELESS	6
+#define WZRHPG300NH_GPIO_LED_SECURITY	17
+#define WZRHPG300NH_GPIO_LED_ROUTER	18
+
+#define WZRHPG300NH_GPIO_RTL8366_SDA	19
+#define WZRHPG300NH_GPIO_RTL8366_SCK	20
+
+#define WZRHPG300NH_GPIO_74HC153_S0	9
+#define WZRHPG300NH_GPIO_74HC153_S1	11
+#define WZRHPG300NH_GPIO_74HC153_1Y	12
+#define WZRHPG300NH_GPIO_74HC153_2Y	14
+
+#define WZRHPG300NH_GPIO_EXP_BASE	32
+#define WZRHPG300NH_GPIO_BTN_AOSS	(WZRHPG300NH_GPIO_EXP_BASE + 0)
+#define WZRHPG300NH_GPIO_BTN_RESET	(WZRHPG300NH_GPIO_EXP_BASE + 1)
+#define WZRHPG300NH_GPIO_BTN_ROUTER_ON	(WZRHPG300NH_GPIO_EXP_BASE + 2)
+#define WZRHPG300NH_GPIO_BTN_QOS_ON	(WZRHPG300NH_GPIO_EXP_BASE + 3)
+#define WZRHPG300NH_GPIO_BTN_USB	(WZRHPG300NH_GPIO_EXP_BASE + 5)
+#define WZRHPG300NH_GPIO_BTN_ROUTER_AUTO (WZRHPG300NH_GPIO_EXP_BASE + 6)
+#define WZRHPG300NH_GPIO_BTN_QOS_OFF	(WZRHPG300NH_GPIO_EXP_BASE + 7)
+
+#define WZRHPG300NH_BUTTONS_POLL_INTERVAL	20
+
+#define WZRHPG300NH_MAC_OFFSET		0x20c
+
+#ifdef CONFIG_MTD_PARTITIONS
+static struct mtd_partition wzrhpg300nh_flash_partitions[] = {
+	{
+		.name		= "u-boot",
+		.offset		= 0,
+		.size		= 0x0040000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "u-boot-env",
+		.offset		= 0x0040000,
+		.size		= 0x0020000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "kernel",
+		.offset		= 0x0060000,
+		.size		= 0x0100000,
+	}, {
+		.name		= "rootfs",
+		.offset		= 0x0160000,
+		.size		= 0x1e60000,
+	}, {
+		.name		= "user_property",
+		.offset		= 0x1fc0000,
+		.size		= 0x0020000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "art",
+		.offset		= 0x1fe0000,
+		.size		= 0x0020000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "firmware",
+		.offset		= 0x0060000,
+		.size		= 0x1f60000,
+	}
+};
+#endif /* CONFIG_MTD_PARTITIONS */
+
+static struct ar91xx_flash_platform_data wzrhpg300nh_flash_data = {
+	.width		= 2,
+#ifdef CONFIG_MTD_PARTITIONS
+        .parts          = wzrhpg300nh_flash_partitions,
+        .nr_parts       = ARRAY_SIZE(wzrhpg300nh_flash_partitions),
+#endif
+};
+
+#define WZRHPG300NH_FLASH_BASE	0x1e000000
+#define WZRHPG300NH_FLASH_SIZE	(32 * 1024 * 1024)
+
+static struct resource wzrhpg300nh_flash_resources[] = {
+	[0] = {
+		.start	= WZRHPG300NH_FLASH_BASE,
+		.end	= WZRHPG300NH_FLASH_BASE + WZRHPG300NH_FLASH_SIZE - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+};
+
+static struct platform_device wzrhpg300nh_flash_device = {
+	.name		= "ar91xx-flash",
+	.id		= -1,
+	.resource	= wzrhpg300nh_flash_resources,
+	.num_resources	= ARRAY_SIZE(wzrhpg300nh_flash_resources),
+	.dev		= {
+		.platform_data = &wzrhpg300nh_flash_data,
+	}
+};
+
+static struct gpio_led wzrhpg300nh_leds_gpio[] __initdata = {
+	{
+		.name		= "wzr-hp-g300nh:orange:security",
+		.gpio		= WZRHPG300NH_GPIO_LED_SECURITY,
+		.active_low	= 1,
+	}, {
+		.name		= "wzr-hp-g300nh:green:wireless",
+		.gpio		= WZRHPG300NH_GPIO_LED_WIRELESS,
+		.active_low	= 1,
+	}, {
+		.name		= "wzr-hp-g300nh:green:router",
+		.gpio		= WZRHPG300NH_GPIO_LED_ROUTER,
+		.active_low	= 1,
+	}, {
+		.name		= "wzr-hp-g300nh:red:diag",
+		.gpio		= WZRHPG300NH_GPIO_LED_DIAG,
+		.active_low	= 1,
+	}, {
+		.name		= "wzr-hp-g300nh:blue:usb",
+		.gpio		= WZRHPG300NH_GPIO_LED_USB,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_button wzrhpg300nh_gpio_buttons[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= BTN_0,
+		.threshold	= 3,
+		.gpio		= WZRHPG300NH_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}, {
+		.desc		= "aoss",
+		.type		= EV_KEY,
+		.code		= BTN_1,
+		.threshold	= 3,
+		.gpio		= WZRHPG300NH_GPIO_BTN_AOSS,
+		.active_low	= 1,
+	}, {
+		.desc		= "usb",
+		.type		= EV_KEY,
+		.code		= BTN_2,
+		.threshold	= 3,
+		.gpio		= WZRHPG300NH_GPIO_BTN_USB,
+		.active_low	= 1,
+	}, {
+		.desc		= "qos_on",
+		.type		= EV_KEY,
+		.code		= BTN_3,
+		.threshold	= 3,
+		.gpio		= WZRHPG300NH_GPIO_BTN_QOS_ON,
+		.active_low	= 0,
+	}, {
+		.desc		= "qos_off",
+		.type		= EV_KEY,
+		.code		= BTN_4,
+		.threshold	= 3,
+		.gpio		= WZRHPG300NH_GPIO_BTN_QOS_OFF,
+		.active_low	= 0,
+	}, {
+		.desc		= "router_on",
+		.type		= EV_KEY,
+		.code		= BTN_5,
+		.threshold	= 3,
+		.gpio		= WZRHPG300NH_GPIO_BTN_ROUTER_ON,
+		.active_low	= 0,
+	}, {
+		.desc		= "router_auto",
+		.type		= EV_KEY,
+		.code		= BTN_6,
+		.threshold	= 3,
+		.gpio		= WZRHPG300NH_GPIO_BTN_ROUTER_AUTO,
+		.active_low	= 0,
+	}
+};
+
+static struct nxp_74hc153_platform_data wzrhpg300nh_74hc153_data = {
+	.gpio_base	= WZRHPG300NH_GPIO_EXP_BASE,
+	.gpio_pin_s0	= WZRHPG300NH_GPIO_74HC153_S0,
+	.gpio_pin_s1	= WZRHPG300NH_GPIO_74HC153_S1,
+	.gpio_pin_1y	= WZRHPG300NH_GPIO_74HC153_1Y,
+	.gpio_pin_2y	= WZRHPG300NH_GPIO_74HC153_2Y,
+};
+
+static struct platform_device wzrhpg300nh_74hc153_device = {
+	.name		= NXP_74HC153_DRIVER_NAME,
+	.id		= -1,
+	.dev = {
+		.platform_data	= &wzrhpg300nh_74hc153_data,
+	}
+};
+
+static struct rtl8366s_platform_data wzrhpg300nh_rtl8366s_data = {
+	.gpio_sda        = WZRHPG300NH_GPIO_RTL8366_SDA,
+	.gpio_sck        = WZRHPG300NH_GPIO_RTL8366_SCK,
+};
+
+static struct platform_device wzrhpg300nh_rtl8366s_device = {
+	.name		= RTL8366S_DRIVER_NAME,
+	.id		= -1,
+	.dev = {
+		.platform_data	= &wzrhpg300nh_rtl8366s_data,
+	}
+};
+
+static void __init wzrhpg300nh_setup(void)
+{
+	u8 *eeprom = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	ar71xx_set_mac_base(eeprom + WZRHPG300NH_MAC_OFFSET);
+
+	ar71xx_eth0_pll_data.pll_1000 = 0x1e000100;
+	ar71xx_eth0_data.mii_bus_dev = &wzrhpg300nh_rtl8366s_device.dev;
+	ar71xx_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ar71xx_eth0_data.speed = SPEED_1000;
+	ar71xx_eth0_data.duplex = DUPLEX_FULL;
+
+	ar71xx_eth1_pll_data.pll_1000 = 0x1e000100;
+	ar71xx_eth1_data.mii_bus_dev = &wzrhpg300nh_rtl8366s_device.dev;
+	ar71xx_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ar71xx_eth1_data.phy_mask = 0x10;
+
+	ar71xx_add_device_eth(0);
+	ar71xx_add_device_eth(1);
+
+	ar71xx_add_device_usb();
+	ar913x_add_device_wmac(eeprom, NULL);
+
+	platform_device_register(&wzrhpg300nh_74hc153_device);
+	platform_device_register(&wzrhpg300nh_flash_device);
+	platform_device_register(&wzrhpg300nh_rtl8366s_device);
+
+	ar71xx_add_device_leds_gpio(-1, ARRAY_SIZE(wzrhpg300nh_leds_gpio),
+				    wzrhpg300nh_leds_gpio);
+
+	ar71xx_add_device_gpio_buttons(-1, WZRHPG300NH_BUTTONS_POLL_INTERVAL,
+				       ARRAY_SIZE(wzrhpg300nh_gpio_buttons),
+				       wzrhpg300nh_gpio_buttons);
+
+}
+
+MIPS_MACHINE(AR71XX_MACH_WZR_HP_G300NH, "WZR-HP-G300NH",
+	     "Buffalo WZR-HP-G300NH", wzrhpg300nh_setup);
diff --git a/arch/mips/ar71xx/machtype.h b/arch/mips/ar71xx/machtype.h
new file mode 100644
index 0000000..a8679d9
--- /dev/null
+++ b/arch/mips/ar71xx/machtype.h
@@ -0,0 +1,59 @@
+/*
+ *  Atheros AR71xx machine type definitions
+ *
+ *  Copyright (C) 2008-2010 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#ifndef _AR71XX_MACHTYPE_H
+#define _AR71XX_MACHTYPE_H
+
+#include <asm/mips_machine.h>
+
+enum ar71xx_mach_type {
+	AR71XX_MACH_GENERIC = 0,
+	AR71XX_MACH_AP81,	/* Atheros AP81 */
+	AR71XX_MACH_AP83,	/* Atheros AP83 */
+	AR71XX_MACH_AW_NR580,	/* AzureWave AW-NR580 */
+	AR71XX_MACH_DIR_600_A1,	/* D-Link DIR-600 rev. A1 */
+	AR71XX_MACH_DIR_615_C1,	/* D-Link DIR-615 rev. C1 */
+	AR71XX_MACH_DIR_825_B1,	/* D-Link DIR-825 rev. B1 */
+	AR71XX_MACH_RB_411,	/* MikroTik RouterBOARD 411/411A/411AH */
+	AR71XX_MACH_RB_411U,	/* MikroTik RouterBOARD 411U */
+	AR71XX_MACH_RB_433,	/* MikroTik RouterBOARD 433/433AH */
+	AR71XX_MACH_RB_433U,	/* MikroTik RouterBOARD 433UAH */
+	AR71XX_MACH_RB_450,	/* MikroTik RouterBOARD 450 */
+	AR71XX_MACH_RB_450G,	/* MikroTik RouterBOARD 450G */
+	AR71XX_MACH_RB_493,	/* Mikrotik RouterBOARD 493/493AH */
+	AR71XX_MACH_RB_750,	/* MikroTik RouterBOARD 750 */
+	AR71XX_MACH_PB42,	/* Atheros PB42 */
+	AR71XX_MACH_PB44,	/* Atheros PB44 */
+	AR71XX_MACH_PB92,	/* Atheros PB92 */
+	AR71XX_MACH_MZK_W04NU,	/* Planex MZK-W04NU */
+	AR71XX_MACH_MZK_W300NH,	/* Planex MZK-W300NH */
+	AR71XX_MACH_TEW_632BRP,	/* TRENDnet TEW-632BRP */
+	AR71XX_MACH_TL_WR741ND,	/* TP-LINK TL-WR741ND */
+	AR71XX_MACH_TL_WR841N_V1, /* TP-LINK TL-WR841N v1 */
+	AR71XX_MACH_TL_WR941ND,	/* TP-LINK TL-WR941ND */
+	AR71XX_MACH_TL_WR1043ND, /* TP-LINK TL-WR1041ND */
+	AR71XX_MACH_UBNT_LSSR71, /* Ubiquiti LS-SR71 */
+	AR71XX_MACH_UBNT_LSX,	/* Ubiquiti LSX */
+	AR71XX_MACH_UBNT_RS,	/* Ubiquiti RouterStation */
+	AR71XX_MACH_UBNT_AR71XX, /* Ubiquiti AR71xx-based board */
+	AR71XX_MACH_UBNT_RSPRO,	/* Ubiquiti RouterStation Pro */
+	AR71XX_MACH_UBNT_BULLET_M, /* Ubiquiti Bullet M */
+	AR71XX_MACH_UBNT_ROCKET_M, /* Ubiquiti Rocket M */
+	AR71XX_MACH_UBNT_NANO_M, /* Ubiquiti NanoStation M */
+	AR71XX_MACH_WNDR3700,	/* NETGEAR WNDR3700 */
+	AR71XX_MACH_WNR2000,	/* NETGEAR WNR2000 */
+	AR71XX_MACH_WP543,	/* Compex WP543 */
+	AR71XX_MACH_WRT160NL,	/* Linksys WRT160NL */
+	AR71XX_MACH_WRT400N,	/* Linksys WRT400N */
+	AR71XX_MACH_WZR_HP_G300NH, /* Buffalo WZR-HP-G300NH */
+};
+
+#endif /* _AR71XX_MACHTYPE_H */
diff --git a/arch/mips/ar71xx/nvram.c b/arch/mips/ar71xx/nvram.c
new file mode 100644
index 0000000..e6d1f80
--- /dev/null
+++ b/arch/mips/ar71xx/nvram.c
@@ -0,0 +1,75 @@
+/*
+ *  Atheros AR71xx minimal nvram support
+ *
+ *  Copyright (C) 2009 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/kernel.h>
+#include <linux/vmalloc.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/string.h>
+
+#include "nvram.h"
+
+char *nvram_find_var(const char *name, const char *buf, unsigned buf_len)
+{
+	unsigned len = strlen(name);
+	char *cur, *last;
+
+	if (buf_len == 0 || len == 0)
+		return NULL;
+
+	if (buf_len < len)
+		return NULL;
+
+	if (len == 1)
+		return memchr(buf, (int) *name, buf_len);
+
+	last = (char *) buf + buf_len - len;
+	for (cur = (char *) buf; cur <= last; cur++)
+		if (cur[0] == name[0] && memcmp(cur, name, len) == 0)
+			return cur + len;
+
+	return NULL;
+}
+
+int nvram_parse_mac_addr(const char *nvram, unsigned nvram_len,
+			 const char *name, char *mac)
+{
+	char *buf;
+	char *mac_str;
+	int ret;
+	int t;
+
+	buf = vmalloc(nvram_len);
+	if (!buf)
+		return -ENOMEM;
+
+	memcpy(buf, nvram, nvram_len);
+	buf[nvram_len - 1] = '\0';
+
+	mac_str = nvram_find_var(name, buf, nvram_len);
+	if (!mac_str) {
+		ret = -EINVAL;
+		goto free;
+	}
+
+	t = sscanf(mac_str, "%02hhx:%02hhx:%02hhx:%02hhx:%02hhx:%02hhx",
+		   &mac[0], &mac[1], &mac[2], &mac[3], &mac[4], &mac[5]);
+
+	if (t != 6) {
+		ret = -EINVAL;
+		goto free;
+	}
+
+	ret = 0;
+
+ free:
+	vfree(buf);
+	return ret;
+}
diff --git a/arch/mips/ar71xx/nvram.h b/arch/mips/ar71xx/nvram.h
new file mode 100644
index 0000000..b025d3f
--- /dev/null
+++ b/arch/mips/ar71xx/nvram.h
@@ -0,0 +1,19 @@
+/*
+ *  Atheros AR71xx minimal nvram support
+ *
+ *  Copyright (C) 2009 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#ifndef _AR71XX_NVRAM_H
+#define _AR71XX_NVRAM_H
+
+char *nvram_find_var(const char *name, const char *buf,
+		     unsigned buf_len) __init;
+int nvram_parse_mac_addr(const char *nvram, unsigned nvram_len,
+			 const char *name, char *mac) __init;
+
+#endif /* _AR71XX_NVRAM_H */
diff --git a/arch/mips/ar71xx/pci.c b/arch/mips/ar71xx/pci.c
new file mode 100644
index 0000000..3e1e8db
--- /dev/null
+++ b/arch/mips/ar71xx/pci.c
@@ -0,0 +1,93 @@
+/*
+ *  Atheros AR71xx PCI setup code
+ *
+ *  Copyright (C) 2008-2009 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  Parts of this file are based on Atheros' 2.6.15 BSP
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/kernel.h>
+
+#include <asm/traps.h>
+
+#include <asm/mach-ar71xx/ar71xx.h>
+#include <asm/mach-ar71xx/pci.h>
+
+unsigned ar71xx_pci_nr_irqs __initdata;
+struct ar71xx_pci_irq *ar71xx_pci_irq_map __initdata;
+
+int (*ar71xx_pci_plat_dev_init)(struct pci_dev *dev);
+
+static int ar71xx_be_handler(struct pt_regs *regs, int is_fixup)
+{
+	int err = 0;
+
+	err = ar71xx_pci_be_handler(is_fixup);
+
+	return (is_fixup && !err) ? MIPS_BE_FIXUP : MIPS_BE_FATAL;
+}
+
+int pcibios_plat_dev_init(struct pci_dev *dev)
+{
+	if (ar71xx_pci_plat_dev_init)
+		return ar71xx_pci_plat_dev_init(dev);
+
+	return 0;
+}
+
+int __init pcibios_map_irq(const struct pci_dev *dev, uint8_t slot, uint8_t pin)
+{
+	int ret = 0;
+
+	switch (ar71xx_soc) {
+	case AR71XX_SOC_AR7130:
+	case AR71XX_SOC_AR7141:
+	case AR71XX_SOC_AR7161:
+		ret = ar71xx_pcibios_map_irq(dev, slot, pin);
+		break;
+
+	case AR71XX_SOC_AR7240:
+	case AR71XX_SOC_AR7241:
+	case AR71XX_SOC_AR7242:
+		ret = ar724x_pcibios_map_irq(dev, slot, pin);
+		break;
+
+	default:
+		break;
+	}
+
+	return ret;
+}
+
+int __init ar71xx_pci_init(unsigned nr_irqs, struct ar71xx_pci_irq *map)
+{
+	int ret = 0;
+
+	switch (ar71xx_soc) {
+	case AR71XX_SOC_AR7130:
+	case AR71XX_SOC_AR7141:
+	case AR71XX_SOC_AR7161:
+		board_be_handler = ar71xx_be_handler;
+		ret = ar71xx_pcibios_init();
+		break;
+
+	case AR71XX_SOC_AR7240:
+	case AR71XX_SOC_AR7241:
+	case AR71XX_SOC_AR7242:
+		ret = ar724x_pcibios_init();
+		break;
+
+	default:
+		return 0;
+	}
+
+	ar71xx_pci_nr_irqs = nr_irqs;
+	ar71xx_pci_irq_map = map;
+
+	return ret;
+}
diff --git a/arch/mips/ar71xx/prom.c b/arch/mips/ar71xx/prom.c
new file mode 100644
index 0000000..87d6da0
--- /dev/null
+++ b/arch/mips/ar71xx/prom.c
@@ -0,0 +1,166 @@
+/*
+ *  Atheros AR71xx SoC specific prom routines
+ *
+ *  Copyright (C) 2008-2009 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/string.h>
+
+#include <asm/bootinfo.h>
+#include <asm/addrspace.h>
+#include <asm/fw/myloader/myloader.h>
+
+#include <asm/mach-ar71xx/ar71xx.h>
+
+static inline int is_valid_ram_addr(void *addr)
+{
+	if (((u32) addr > KSEG0) &&
+	    ((u32) addr < (KSEG0 + AR71XX_MEM_SIZE_MAX)))
+		return 1;
+
+	if (((u32) addr > KSEG1) &&
+	    ((u32) addr < (KSEG1 + AR71XX_MEM_SIZE_MAX)))
+		return 1;
+
+	return 0;
+}
+
+static void __init ar71xx_prom_append_cmdline(const char *name,
+					      const char *value)
+{
+	char buf[COMMAND_LINE_SIZE];
+
+	snprintf(buf, sizeof(buf), " %s=%s", name, value);
+	strlcat(arcs_cmdline, buf, sizeof(arcs_cmdline));
+}
+
+static void __init ar71xx_prom_find_env(char **envp, const char *name)
+{
+	int len = strlen(name);
+	char **p;
+
+	if (!is_valid_ram_addr(envp))
+		return;
+
+	for (p = envp; is_valid_ram_addr(*p); p++) {
+		if (strncmp(name, *p, len) == 0 && (*p)[len] == '=') {
+			ar71xx_prom_append_cmdline(name, *p + len + 1);
+			break;
+		}
+
+		/* RedBoot env comes in pointer pairs - key, value */
+		if (strncmp(name, *p, len) == 0 && (*p)[len] == 0)
+			if (is_valid_ram_addr(*(++p))) {
+				ar71xx_prom_append_cmdline(name, *p);
+				break;
+			}
+	}
+}
+
+static int __init ar71xx_prom_init_myloader(void)
+{
+	struct myloader_info *mylo;
+	char mac_buf[32];
+	char *mac;
+
+	mylo = myloader_get_info();
+	if (!mylo)
+		return 0;
+
+	switch (mylo->did) {
+	case DEVID_COMPEX_WP543:
+		ar71xx_prom_append_cmdline("board", "WP543");
+		break;
+	default:
+		printk(KERN_WARNING "prom: unknown device id: %x\n",
+				mylo->did);
+		return 0;
+	}
+
+	mac = mylo->macs[0];
+	snprintf(mac_buf, sizeof(mac_buf), "%02x:%02x:%02x:%02x:%02x:%02x",
+		 mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);
+
+	ar71xx_prom_append_cmdline("ethaddr", mac_buf);
+
+	return 1;
+}
+
+#ifdef CONFIG_IMAGE_CMDLINE_HACK
+extern char __image_cmdline[];
+
+static int __init ar71xx_use__image_cmdline(void)
+{
+	char *p = __image_cmdline;
+	int replace = 0;
+
+	if (*p == '-') {
+		replace = 1;
+		p++;
+	}
+
+	if (*p == '\0')
+		return 0;
+
+	if (replace) {
+		strlcpy(arcs_cmdline, p, sizeof(arcs_cmdline));
+	} else {
+		strlcat(arcs_cmdline, " ", sizeof(arcs_cmdline));
+		strlcat(arcs_cmdline, p, sizeof(arcs_cmdline));
+	}
+
+	return 1;
+}
+#else
+static int inline ar71xx_use__image_cmdline(void) { return 0; }
+#endif
+
+static __init void ar71xx_prom_init_cmdline(int argc, char **argv)
+{
+	int i;
+
+	if (ar71xx_use__image_cmdline())
+		return;
+
+	if (!is_valid_ram_addr(argv))
+		return;
+
+	for (i = 0; i < argc; i++)
+		if (is_valid_ram_addr(argv[i])) {
+			strlcat(arcs_cmdline, " ", sizeof(arcs_cmdline));
+			strlcat(arcs_cmdline, argv[i], sizeof(arcs_cmdline));
+		}
+}
+
+void __init prom_init(void)
+{
+	char **envp;
+
+	printk(KERN_DEBUG "prom: fw_arg0=%08x, fw_arg1=%08x, "
+			"fw_arg2=%08x, fw_arg3=%08x\n",
+			(unsigned int)fw_arg0, (unsigned int)fw_arg1,
+			(unsigned int)fw_arg2, (unsigned int)fw_arg3);
+
+
+	if (ar71xx_prom_init_myloader())
+		return;
+
+	ar71xx_prom_init_cmdline(fw_arg0, (char **)fw_arg1);
+
+	envp = (char **)fw_arg2;
+	ar71xx_prom_find_env(envp, "board");
+	ar71xx_prom_find_env(envp, "ethaddr");
+}
+
+void __init prom_free_prom_memory(void)
+{
+	/* We do not have to prom memory to free */
+}
diff --git a/arch/mips/ar71xx/setup.c b/arch/mips/ar71xx/setup.c
new file mode 100644
index 0000000..d89505f
--- /dev/null
+++ b/arch/mips/ar71xx/setup.c
@@ -0,0 +1,310 @@
+/*
+ *  Atheros AR71xx SoC specific setup
+ *
+ *  Copyright (C) 2008-2009 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  Parts of this file are based on Atheros' 2.6.15 BSP
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/bootmem.h>
+
+#include <asm/bootinfo.h>
+#include <asm/time.h>		/* for mips_hpt_frequency */
+#include <asm/reboot.h>		/* for _machine_{restart,halt} */
+#include <asm/mips_machine.h>
+
+#include <asm/mach-ar71xx/ar71xx.h>
+
+#include "machtype.h"
+#include "devices.h"
+
+#define AR71XX_SYS_TYPE_LEN	64
+#define AR71XX_BASE_FREQ	40000000
+#define AR91XX_BASE_FREQ	5000000
+#define AR724X_BASE_FREQ	5000000
+
+u32 ar71xx_cpu_freq;
+EXPORT_SYMBOL_GPL(ar71xx_cpu_freq);
+
+u32 ar71xx_ahb_freq;
+EXPORT_SYMBOL_GPL(ar71xx_ahb_freq);
+
+u32 ar71xx_ddr_freq;
+EXPORT_SYMBOL_GPL(ar71xx_ddr_freq);
+
+enum ar71xx_soc_type ar71xx_soc;
+EXPORT_SYMBOL_GPL(ar71xx_soc);
+
+static char ar71xx_sys_type[AR71XX_SYS_TYPE_LEN];
+
+static void ar71xx_restart(char *command)
+{
+	ar71xx_device_stop(RESET_MODULE_FULL_CHIP);
+	for (;;)
+		if (cpu_wait)
+			cpu_wait();
+}
+
+static void ar71xx_halt(void)
+{
+	while (1)
+		cpu_wait();
+}
+
+static void __init ar71xx_detect_mem_size(void)
+{
+	unsigned long size;
+
+	for (size = AR71XX_MEM_SIZE_MIN; size < AR71XX_MEM_SIZE_MAX;
+	     size <<= 1 ) {
+		if (!memcmp(ar71xx_detect_mem_size,
+			    ar71xx_detect_mem_size + size, 1024))
+			break;
+	}
+
+	add_memory_region(0, size, BOOT_MEM_RAM);
+}
+
+static void __init ar71xx_detect_sys_type(void)
+{
+	char *chip = "????";
+	u32 id;
+	u32 major;
+	u32 minor;
+	u32 rev = 0;
+
+	id = ar71xx_reset_rr(AR71XX_RESET_REG_REV_ID);
+	major = id & REV_ID_MAJOR_MASK;
+
+	switch (major) {
+	case REV_ID_MAJOR_AR71XX:
+		minor = id & AR71XX_REV_ID_MINOR_MASK;
+		rev = id >> AR71XX_REV_ID_REVISION_SHIFT;
+		rev &= AR71XX_REV_ID_REVISION_MASK;
+		switch (minor) {
+		case AR71XX_REV_ID_MINOR_AR7130:
+			ar71xx_soc = AR71XX_SOC_AR7130;
+			chip = "7130";
+			break;
+
+		case AR71XX_REV_ID_MINOR_AR7141:
+			ar71xx_soc = AR71XX_SOC_AR7141;
+			chip = "7141";
+			break;
+
+		case AR71XX_REV_ID_MINOR_AR7161:
+			ar71xx_soc = AR71XX_SOC_AR7161;
+			chip = "7161";
+			break;
+		}
+		break;
+
+	case REV_ID_MAJOR_AR7240:
+		ar71xx_soc = AR71XX_SOC_AR7240;
+		chip = "7240";
+		rev = (id & AR724X_REV_ID_REVISION_MASK);
+		break;
+
+	case REV_ID_MAJOR_AR7241:
+		ar71xx_soc = AR71XX_SOC_AR7241;
+		chip = "7241";
+		rev = (id & AR724X_REV_ID_REVISION_MASK);
+		break;
+
+	case REV_ID_MAJOR_AR7242:
+		ar71xx_soc = AR71XX_SOC_AR7242;
+		chip = "7242";
+		rev = (id & AR724X_REV_ID_REVISION_MASK);
+		break;
+
+	case REV_ID_MAJOR_AR913X:
+		minor = id & AR91XX_REV_ID_MINOR_MASK;
+		rev = id >> AR91XX_REV_ID_REVISION_SHIFT;
+		rev &= AR91XX_REV_ID_REVISION_MASK;
+		switch (minor) {
+		case AR91XX_REV_ID_MINOR_AR9130:
+			ar71xx_soc = AR71XX_SOC_AR9130;
+			chip = "9130";
+			break;
+
+		case AR91XX_REV_ID_MINOR_AR9132:
+			ar71xx_soc = AR71XX_SOC_AR9132;
+			chip = "9132";
+			break;
+		}
+		break;
+
+	default:
+		panic("ar71xx: unknown chip id:0x%08x\n", id);
+	}
+
+	sprintf(ar71xx_sys_type, "Atheros AR%s rev %u", chip, rev);
+}
+
+static void __init ar91xx_detect_sys_frequency(void)
+{
+	u32 pll;
+	u32 freq;
+	u32 div;
+
+	pll = ar71xx_pll_rr(AR91XX_PLL_REG_CPU_CONFIG);
+
+	div = ((pll >> AR91XX_PLL_DIV_SHIFT) & AR91XX_PLL_DIV_MASK);
+	freq = div * AR91XX_BASE_FREQ;
+
+	ar71xx_cpu_freq = freq;
+
+	div = ((pll >> AR91XX_DDR_DIV_SHIFT) & AR91XX_DDR_DIV_MASK) + 1;
+	ar71xx_ddr_freq = freq / div;
+
+	div = (((pll >> AR91XX_AHB_DIV_SHIFT) & AR91XX_AHB_DIV_MASK) + 1) * 2;
+	ar71xx_ahb_freq = ar71xx_cpu_freq / div;
+}
+
+static void __init ar71xx_detect_sys_frequency(void)
+{
+	u32 pll;
+	u32 freq;
+	u32 div;
+
+	pll = ar71xx_pll_rr(AR71XX_PLL_REG_CPU_CONFIG);
+
+	div = ((pll >> AR71XX_PLL_DIV_SHIFT) & AR71XX_PLL_DIV_MASK) + 1;
+	freq = div * AR71XX_BASE_FREQ;
+
+	div = ((pll >> AR71XX_CPU_DIV_SHIFT) & AR71XX_CPU_DIV_MASK) + 1;
+	ar71xx_cpu_freq = freq / div;
+
+	div = ((pll >> AR71XX_DDR_DIV_SHIFT) & AR71XX_DDR_DIV_MASK) + 1;
+	ar71xx_ddr_freq = freq / div;
+
+	div = (((pll >> AR71XX_AHB_DIV_SHIFT) & AR71XX_AHB_DIV_MASK) + 1) * 2;
+	ar71xx_ahb_freq = ar71xx_cpu_freq / div;
+}
+
+static void __init ar724x_detect_sys_frequency(void)
+{
+	u32 pll;
+	u32 freq;
+	u32 div;
+
+	pll = ar71xx_pll_rr(AR724X_PLL_REG_CPU_CONFIG);
+
+	div = ((pll >> AR724X_PLL_DIV_SHIFT) & AR724X_PLL_DIV_MASK);
+	freq = div * AR724X_BASE_FREQ;
+
+	div = ((pll >> AR724X_PLL_REF_DIV_SHIFT) & AR724X_PLL_REF_DIV_MASK);
+	freq *= div;
+
+	ar71xx_cpu_freq = freq;
+
+	div = ((pll >> AR724X_DDR_DIV_SHIFT) & AR724X_DDR_DIV_MASK) + 1;
+	ar71xx_ddr_freq = freq / div;
+
+	div = (((pll >> AR724X_AHB_DIV_SHIFT) & AR724X_AHB_DIV_MASK) + 1) * 2;
+	ar71xx_ahb_freq = ar71xx_cpu_freq / div;
+}
+
+static void __init detect_sys_frequency(void)
+{
+	switch (ar71xx_soc) {
+	case AR71XX_SOC_AR7130:
+	case AR71XX_SOC_AR7141:
+	case AR71XX_SOC_AR7161:
+		ar71xx_detect_sys_frequency();
+		break;
+
+	case AR71XX_SOC_AR7240:
+	case AR71XX_SOC_AR7241:
+	case AR71XX_SOC_AR7242:
+		ar724x_detect_sys_frequency();
+		break;
+
+	case AR71XX_SOC_AR9130:
+	case AR71XX_SOC_AR9132:
+		ar91xx_detect_sys_frequency();
+		break;
+
+	default:
+		BUG();
+	}
+}
+
+const char *get_system_type(void)
+{
+	return ar71xx_sys_type;
+}
+
+unsigned int __cpuinit get_c0_compare_irq(void)
+{
+	return CP0_LEGACY_COMPARE_IRQ;
+}
+
+void __init plat_mem_setup(void)
+{
+	set_io_port_base(KSEG1);
+
+	ar71xx_ddr_base = ioremap_nocache(AR71XX_DDR_CTRL_BASE,
+						AR71XX_DDR_CTRL_SIZE);
+
+	ar71xx_pll_base = ioremap_nocache(AR71XX_PLL_BASE,
+						AR71XX_PLL_SIZE);
+
+	ar71xx_reset_base = ioremap_nocache(AR71XX_RESET_BASE,
+						AR71XX_RESET_SIZE);
+
+	ar71xx_gpio_base = ioremap_nocache(AR71XX_GPIO_BASE, AR71XX_GPIO_SIZE);
+
+	ar71xx_usb_ctrl_base = ioremap_nocache(AR71XX_USB_CTRL_BASE,
+						AR71XX_USB_CTRL_SIZE);
+
+	ar71xx_detect_mem_size();
+	ar71xx_detect_sys_type();
+	detect_sys_frequency();
+
+	printk(KERN_INFO
+		"%s, CPU:%u.%03u MHz, AHB:%u.%03u MHz, DDR:%u.%03u MHz\n",
+		ar71xx_sys_type,
+		ar71xx_cpu_freq / 1000000, (ar71xx_cpu_freq / 1000) % 1000,
+		ar71xx_ahb_freq / 1000000, (ar71xx_ahb_freq / 1000) % 1000,
+		ar71xx_ddr_freq / 1000000, (ar71xx_ddr_freq / 1000) % 1000);
+
+	_machine_restart = ar71xx_restart;
+	_machine_halt = ar71xx_halt;
+	pm_power_off = ar71xx_halt;
+}
+
+void __init plat_time_init(void)
+{
+	mips_hpt_frequency = ar71xx_cpu_freq / 2;
+}
+
+__setup("board=", mips_machtype_setup);
+
+static int __init ar71xx_machine_setup(void)
+{
+	ar71xx_gpio_init();
+
+	ar71xx_add_device_uart();
+	ar71xx_add_device_wdt();
+
+	mips_machine_setup();
+	return 0;
+}
+
+arch_initcall(ar71xx_machine_setup);
+
+static void __init ar71xx_generic_init(void)
+{
+	/* Nothing to do */
+}
+
+MIPS_MACHINE(AR71XX_MACH_GENERIC, "Generic", "Generic AR71xx board",
+	     ar71xx_generic_init);
-- 
1.7.4.1

