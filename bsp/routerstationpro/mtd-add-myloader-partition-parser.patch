From fc1d38e4ef23d06cfc119d13bbfba4829e64f228 Mon Sep 17 00:00:00 2001
From: Zumeng Chen <zumeng.chen@windriver.com>
Date: Sun, 9 Jan 2011 23:27:03 +0800
Subject: [PATCH 06/10] mtd: add myloader partition parser

Patches come from backfire_10.03
  backfire/target/linux/generic-2.6/files/drivers/mtd/myloader.c
  backfire/target/linux/generic-2.6/patches-2.6.32:
    081-mtd_myloader_partition_parser.patch
    082-mtd_info_move_forward_decl.patch

Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 drivers/mtd/Kconfig            |   16 ++++
 drivers/mtd/Makefile           |    1 +
 drivers/mtd/myloader.c         |  178 ++++++++++++++++++++++++++++++++++++++++
 include/linux/mtd/partitions.h |    5 +-
 4 files changed, 197 insertions(+), 3 deletions(-)
 create mode 100644 drivers/mtd/myloader.c

diff --git a/drivers/mtd/Kconfig b/drivers/mtd/Kconfig
index d3ce225..f42b676 100644
--- a/drivers/mtd/Kconfig
+++ b/drivers/mtd/Kconfig
@@ -181,6 +181,22 @@ config MTD_AR7_PARTS
 	---help---
 	  TI AR7 partitioning support
 
+config MTD_MYLOADER_PARTS
+	tristate "MyLoader partition parsing"
+	depends on MTD_PARTITIONS && (ADM5120 || ATHEROS_AR231X || ATHEROS_AR71XX)
+	---help---
+	  MyLoader is a bootloader which allows the user to define partitions
+	  in flash devices, by putting a table in the second erase block
+	  on the device, similar to a partition table. This table gives the
+	  offsets and lengths of the user defined partitions.
+
+	  If you need code which can detect and parse these tables, and
+	  register MTD 'partitions' corresponding to each image detected,
+	  enable this option.
+
+	  You will still need the parsing functions to be called by the driver
+	  for your particular device. It won't happen automatically.
+
 config MTD_WRT160NL_PARTS
 	tristate "Linksys WRT160NL partitioning support"
 	depends on MTD_PARTITIONS && AR71XX_MACH_WRT160NL
diff --git a/drivers/mtd/Makefile b/drivers/mtd/Makefile
index f605213..fc06c12 100644
--- a/drivers/mtd/Makefile
+++ b/drivers/mtd/Makefile
@@ -14,6 +14,7 @@ obj-$(CONFIG_MTD_AFS_PARTS)	+= afs.o
 obj-$(CONFIG_MTD_AR7_PARTS)	+= ar7part.o
 obj-$(CONFIG_MTD_WRT160NL_PARTS) += wrt160nl_part.o
 obj-$(CONFIG_MTD_OF_PARTS)      += ofpart.o
+obj-$(CONFIG_MTD_MYLOADER_PARTS) += myloader.o
 
 # 'Users' - code which presents functionality to userspace.
 obj-$(CONFIG_MTD_CHAR)		+= mtdchar.o
diff --git a/drivers/mtd/myloader.c b/drivers/mtd/myloader.c
new file mode 100644
index 0000000..51c0374
--- /dev/null
+++ b/drivers/mtd/myloader.c
@@ -0,0 +1,178 @@
+/*
+ *  Parse MyLoader-style flash partition tables and produce a Linux partition
+ *  array to match.
+ *
+ *  Copyright (C) 2007-2009 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This file was based on drivers/mtd/redboot.c
+ *  Author: Red Hat, Inc. - David Woodhouse <dwmw2@cambridge.redhat.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/vmalloc.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <linux/byteorder/generic.h>
+#include <linux/myloader.h>
+
+#define BLOCK_LEN_MIN		0x10000
+#define PART_NAME_LEN		32
+
+struct part_data {
+	struct mylo_partition_table	tab;
+	char names[MYLO_MAX_PARTITIONS][PART_NAME_LEN];
+};
+
+int myloader_parse_partitions(struct mtd_info *master,
+			struct mtd_partition **pparts,
+			unsigned long origin)
+{
+	struct part_data *buf;
+	struct mylo_partition_table *tab;
+	struct mylo_partition *part;
+	struct mtd_partition *mtd_parts;
+	struct mtd_partition *mtd_part;
+	int num_parts;
+	int ret, i;
+	size_t retlen;
+	char *names;
+	unsigned long offset;
+	unsigned long blocklen;
+
+	buf = vmalloc(sizeof(*buf));
+	if (!buf) {
+		return -ENOMEM;
+		goto out;
+	}
+	tab = &buf->tab;
+
+	blocklen = master->erasesize;
+	if (blocklen < BLOCK_LEN_MIN)
+		blocklen = BLOCK_LEN_MIN;
+
+	offset = blocklen;
+
+	/* Find the partition table */
+	for (i = 0; i < 4; i++, offset += blocklen) {
+		printk(KERN_DEBUG "%s: searching for MyLoader partition table"
+				" at offset 0x%lx\n", master->name, offset);
+
+		ret = master->read(master, offset, sizeof(*buf), &retlen,
+					(void *)buf);
+		if (ret)
+			goto out_free_buf;
+
+		if (retlen != sizeof(*buf)) {
+			ret = -EIO;
+			goto out_free_buf;
+		}
+
+		/* Check for Partition Table magic number */
+		if (tab->magic == le32_to_cpu(MYLO_MAGIC_PARTITIONS))
+			break;
+
+	}
+
+	if (tab->magic != le32_to_cpu(MYLO_MAGIC_PARTITIONS)) {
+		printk(KERN_DEBUG "%s: no MyLoader partition table found\n",
+			master->name);
+		ret = 0;
+		goto out_free_buf;
+	}
+
+	/* The MyLoader and the Partition Table is always present */
+	num_parts = 2;
+
+	/* Detect number of used partitions */
+	for (i = 0; i < MYLO_MAX_PARTITIONS; i++) {
+		part = &tab->partitions[i];
+
+		if (le16_to_cpu(part->type) == PARTITION_TYPE_FREE)
+			continue;
+
+		num_parts++;
+	}
+
+	mtd_parts = kzalloc((num_parts * sizeof(*mtd_part) +
+				num_parts * PART_NAME_LEN), GFP_KERNEL);
+
+	if (!mtd_parts) {
+		ret = -ENOMEM;
+		goto out_free_buf;
+	}
+
+	mtd_part = mtd_parts;
+	names = (char *)&mtd_parts[num_parts];
+
+	strncpy(names, "myloader", PART_NAME_LEN);
+	mtd_part->name = names;
+	mtd_part->offset = 0;
+	mtd_part->size = offset;
+	mtd_part->mask_flags = MTD_WRITEABLE;
+	mtd_part++;
+	names += PART_NAME_LEN;
+
+	strncpy(names, "partition_table", PART_NAME_LEN);
+	mtd_part->name = names;
+	mtd_part->offset = offset;
+	mtd_part->size = blocklen;
+	mtd_part->mask_flags = MTD_WRITEABLE;
+	mtd_part++;
+	names += PART_NAME_LEN;
+
+	for (i = 0; i < MYLO_MAX_PARTITIONS; i++) {
+		part = &tab->partitions[i];
+
+		if (le16_to_cpu(part->type) == PARTITION_TYPE_FREE)
+			continue;
+
+		if ((buf->names[i][0]) && (buf->names[i][0] != '\xff'))
+			strncpy(names, buf->names[i], PART_NAME_LEN);
+		else
+			snprintf(names, PART_NAME_LEN, "partition%d", i);
+
+		mtd_part->offset = le32_to_cpu(part->addr);
+		mtd_part->size = le32_to_cpu(part->size);
+		mtd_part->name = names;
+		mtd_part++;
+		names += PART_NAME_LEN;
+	}
+
+	*pparts = mtd_parts;
+	ret = num_parts;
+
+ out_free_buf:
+	vfree(buf);
+ out:
+	return ret;
+}
+
+static struct mtd_part_parser myloader_mtd_parser = {
+	.owner		= THIS_MODULE,
+	.parse_fn	= myloader_parse_partitions,
+	.name		= "MyLoader",
+};
+
+static int __init myloader_mtd_parser_init(void)
+{
+	return register_mtd_parser(&myloader_mtd_parser);
+}
+
+static void __exit myloader_mtd_parser_exit(void)
+{
+	deregister_mtd_parser(&myloader_mtd_parser);
+}
+
+module_init(myloader_mtd_parser_init);
+module_exit(myloader_mtd_parser_exit);
+
+MODULE_AUTHOR("Gabor Juhos <juhosg@openwrt.org>");
+MODULE_DESCRIPTION("Parsing code for MyLoader partition tables");
+MODULE_LICENSE("GPL v2");
diff --git a/include/linux/mtd/partitions.h b/include/linux/mtd/partitions.h
index b077940..9485171 100644
--- a/include/linux/mtd/partitions.h
+++ b/include/linux/mtd/partitions.h
@@ -34,6 +34,8 @@
  * erasesize aligned (e.g. use MTDPART_OFS_NEXTBLK).
  */
 
+struct mtd_info;
+
 struct mtd_partition {
 	char *name;			/* identifier string */
 	uint64_t size;			/* partition size */
@@ -47,9 +49,6 @@ struct mtd_partition {
 #define MTDPART_OFS_APPEND	(-1)
 #define MTDPART_SIZ_FULL	(0)
 
-
-struct mtd_info;
-
 int add_mtd_partitions(struct mtd_info *, const struct mtd_partition *, int);
 int del_mtd_partitions(struct mtd_info *);
 int refresh_mtd_partitions(struct mtd_info *);
-- 
1.7.0.4

