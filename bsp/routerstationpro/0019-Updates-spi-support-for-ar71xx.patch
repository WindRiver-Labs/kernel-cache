From 1f3b7db239e456a48340d2a948db328971cacab3 Mon Sep 17 00:00:00 2001
From: Zumeng Chen <zumeng.chen@windriver.com>
Date: Thu, 24 Nov 2011 14:51:22 +0800
Subject: [PATCH 19/41] Updates spi support for ar71xx

which from the following git repo.
  git://nbd.name/openwrt.git
  004-ar71xx_spi_controller.patch
  150-drivers-link-spi-before-mtd.patch
  152-rb4xx-spi-driver.patch
  151-spi-add-various-flags.patch
  153-spi-rb4xx-cpld-driver.patch
  201-ap83_spi_controller.patch
  202-spi_vsc7385_driver.patch
  203-pb44_spi_controller.patch

Integrated-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 drivers/Makefile             |    2 +-
 drivers/spi/Kconfig          |   14 +-
 drivers/spi/Makefile         |    3 +-
 drivers/spi/ap83_spi.c       |   21 +-
 drivers/spi/ar71xx_spi.c     |    6 +-
 drivers/spi/pb44_spi.c       |    6 +-
 drivers/spi/rb4xx_spi.c      |  474 ++++++++++++++++++++++++++++++++++++++++++
 drivers/spi/spi_rb4xx_cpld.c |  440 +++++++++++++++++++++++++++++++++++++++
 drivers/spi/spi_vsc7385.c    |   23 +-
 include/linux/spi/spi.h      |    3 +
 10 files changed, 960 insertions(+), 32 deletions(-)
 create mode 100644 drivers/spi/rb4xx_spi.c
 create mode 100644 drivers/spi/spi_rb4xx_cpld.c

diff --git a/drivers/Makefile b/drivers/Makefile
index 09f3232..c533733 100644
--- a/drivers/Makefile
+++ b/drivers/Makefile
@@ -49,8 +49,8 @@ obj-$(CONFIG_IDE)		+= ide/
 obj-$(CONFIG_SCSI)		+= scsi/
 obj-$(CONFIG_ATA)		+= ata/
 obj-$(CONFIG_TARGET_CORE)	+= target/
-obj-$(CONFIG_MTD)		+= mtd/
 obj-$(CONFIG_SPI)		+= spi/
+obj-$(CONFIG_MTD)		+= mtd/
 obj-y				+= net/
 obj-$(CONFIG_ATM)		+= atm/
 obj-$(CONFIG_FUSION)		+= message/
diff --git a/drivers/spi/Kconfig b/drivers/spi/Kconfig
index a9ca750..4280d98 100644
--- a/drivers/spi/Kconfig
+++ b/drivers/spi/Kconfig
@@ -333,6 +333,12 @@ config SPI_PXA2XX
 config SPI_PXA2XX_PCI
 	def_bool SPI_PXA2XX && X86_32 && PCI
 
+config SPI_RB4XX
+	tristate "Mikrotik RB4XX SPI master"
+	depends on SPI_MASTER && AR71XX_MACH_RB4XX
+	help
+	  SPI controller driver for the Mikrotik RB4xx series boards.
+
 config SPI_S3C24XX
 	tristate "Samsung S3C24XX series SPI"
 	depends on ARCH_S3C2410 && EXPERIMENTAL
@@ -489,10 +495,12 @@ config SPI_TLE62X0
 	  sysfs interface, with each line presented as a kind of GPIO
 	  exposing both switch control and diagnostic feedback.
 
-config SPI_VSC7385
-	tristate "Vitesse VSC7385 ethernet switch driver"
+config SPI_RB4XX_CPLD
+	tristate "MikroTik RB4XX CPLD driver"
+	depends on AR71XX_MACH_RB4XX
 	help
-	  SPI driver for the Vitesse VSC7385 ethernet switch.
+	  SPI driver for the Xilinx CPLD chip present on the
+	  MikroTik RB4xx boards.
 
 #
 # Add new SPI protocol masters in alphabetical order above this line
diff --git a/drivers/spi/Makefile b/drivers/spi/Makefile
index 998d844..29a5edf 100644
--- a/drivers/spi/Makefile
+++ b/drivers/spi/Makefile
@@ -58,6 +58,7 @@ obj-$(CONFIG_SPI_SH_SCI)		+= spi_sh_sci.o
 obj-$(CONFIG_SPI_SH_MSIOF)		+= spi_sh_msiof.o
 obj-$(CONFIG_SPI_STMP3XXX)		+= spi_stmp.o
 obj-$(CONFIG_SPI_NUC900)		+= spi_nuc900.o
+obj-$(CONFIG_SPI_RB4XX)			+= rb4xx_spi.o
 
 # special build for s3c24xx spi driver with fiq support
 spi_s3c24xx_hw-y			:= spi_s3c24xx.o
@@ -66,8 +67,8 @@ spi_s3c24xx_hw-$(CONFIG_SPI_S3C24XX_FIQ) += spi_s3c24xx_fiq.o
 # 	... add above this line ...
 
 # SPI protocol drivers (device/link on bus)
+obj-$(CONFIG_SPI_RB4XX_CPLD)	+= spi_rb4xx_cpld.o
 obj-$(CONFIG_SPI_SPIDEV)	+= spidev.o
-obj-$(CONFIG_SPI_VSC7385)	+= spi_vsc7385.o
 obj-$(CONFIG_SPI_TLE62X0)	+= tle62x0.o
 # 	... add above this line ...
 
diff --git a/drivers/spi/ap83_spi.c b/drivers/spi/ap83_spi.c
index c93070d..de8780d 100644
--- a/drivers/spi/ap83_spi.c
+++ b/drivers/spi/ap83_spi.c
@@ -37,8 +37,8 @@
 #define AP83_SPI_GPIO_MISO	3
 
 struct ap83_spi {
-	struct	spi_bitbang 	bitbang;
-	void __iomem 		*base;
+	struct	spi_bitbang	bitbang;
+	void __iomem		*base;
 	u32			addr;
 
 	struct platform_device	*pdev;
@@ -127,33 +127,34 @@ static void ap83_spi_chipselect(struct spi_device *spi, int on)
 
 #define EXPAND_BITBANG_TXRX
 #include <linux/spi/spi_bitbang.h>
+#include "spi_bitbang_txrx.h"
 
 static u32 ap83_spi_txrx_mode0(struct spi_device *spi,
 			       unsigned nsecs, u32 word, u8 bits)
 {
 	dev_dbg(&spi->dev, "TXRX0 word=%08x, bits=%u\n", word, bits);
-	return bitbang_txrx_be_cpha0(spi, nsecs, 0, word, bits);
+	return bitbang_txrx_be_cpha0(spi, nsecs, 0, 0, word, bits);
 }
 
 static u32 ap83_spi_txrx_mode1(struct spi_device *spi,
 			       unsigned nsecs, u32 word, u8 bits)
 {
 	dev_dbg(&spi->dev, "TXRX1 word=%08x, bits=%u\n", word, bits);
-	return bitbang_txrx_be_cpha1(spi, nsecs, 0, word, bits);
+	return bitbang_txrx_be_cpha1(spi, nsecs, 0, 0, word, bits);
 }
 
 static u32 ap83_spi_txrx_mode2(struct spi_device *spi,
 			       unsigned nsecs, u32 word, u8 bits)
 {
 	dev_dbg(&spi->dev, "TXRX2 word=%08x, bits=%u\n", word, bits);
-	return bitbang_txrx_be_cpha0(spi, nsecs, 1, word, bits);
+	return bitbang_txrx_be_cpha0(spi, nsecs, 1, 0, word, bits);
 }
 
 static u32 ap83_spi_txrx_mode3(struct spi_device *spi,
 			       unsigned nsecs, u32 word, u8 bits)
 {
 	dev_dbg(&spi->dev, "TXRX3 word=%08x, bits=%u\n", word, bits);
-	return bitbang_txrx_be_cpha1(spi, nsecs, 1, word, bits);
+	return bitbang_txrx_be_cpha1(spi, nsecs, 1, 0, word, bits);
 }
 
 static int ap83_spi_probe(struct platform_device *pdev)
@@ -229,15 +230,15 @@ static int ap83_spi_probe(struct platform_device *pdev)
 
 	return 0;
 
- err_unmap:
+err_unmap:
 	iounmap(sp->base);
- err_spi_put:
+err_spi_put:
 	platform_set_drvdata(pdev, NULL);
 	spi_master_put(sp->bitbang.master);
 
- err_free_cs:
+err_free_cs:
 	gpio_free(AP83_SPI_GPIO_CS);
- err_free_miso:
+err_free_miso:
 	gpio_free(AP83_SPI_GPIO_MISO);
 	return ret;
 }
diff --git a/drivers/spi/ar71xx_spi.c b/drivers/spi/ar71xx_spi.c
index ac60170..f548cde 100644
--- a/drivers/spi/ar71xx_spi.c
+++ b/drivers/spi/ar71xx_spi.c
@@ -31,11 +31,11 @@
 #undef PER_BIT_READ
 
 struct ar71xx_spi {
-	struct	spi_bitbang 	bitbang;
+	struct	spi_bitbang	bitbang;
 	u32			ioc_base;
 	u32			reg_ctrl;
 
-	void __iomem 		*base;
+	void __iomem		*base;
 
 	struct platform_device	*pdev;
 	u32			(*get_ioc_base)(u8 chip_select, int cs_high,
@@ -234,7 +234,7 @@ static int ar71xx_spi_probe(struct platform_device *pdev)
 		return 0;
 
 	iounmap(sp->base);
- err1:
+err1:
 	platform_set_drvdata(pdev, NULL);
 	spi_master_put(sp->bitbang.master);
 
diff --git a/drivers/spi/pb44_spi.c b/drivers/spi/pb44_spi.c
index 32e6ea6..ee52099 100644
--- a/drivers/spi/pb44_spi.c
+++ b/drivers/spi/pb44_spi.c
@@ -31,11 +31,11 @@
 #undef PER_BIT_READ
 
 struct ar71xx_spi {
-	struct	spi_bitbang 	bitbang;
+	struct	spi_bitbang	bitbang;
 	u32			ioc_base;
 	u32			reg_ctrl;
 
-	void __iomem 		*base;
+	void __iomem		*base;
 
 	struct platform_device	*pdev;
 };
@@ -252,7 +252,7 @@ static int pb44_spi_probe(struct platform_device *pdev)
 		return 0;
 
 	iounmap(sp->base);
- err1:
+err1:
 	platform_set_drvdata(pdev, NULL);
 	spi_master_put(sp->bitbang.master);
 
diff --git a/drivers/spi/rb4xx_spi.c b/drivers/spi/rb4xx_spi.c
new file mode 100644
index 0000000..f7f148a
--- /dev/null
+++ b/drivers/spi/rb4xx_spi.c
@@ -0,0 +1,474 @@
+/*
+ * SPI controller driver for the Mikrotik RB4xx boards
+ *
+ * Copyright (C) 2010 Gabor Juhos <juhosg@openwrt.org>
+ *
+ * This file was based on the patches for Linux 2.6.27.39 published by
+ * MikroTik for their RouterBoard 4xx series devices.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/spinlock.h>
+#include <linux/workqueue.h>
+#include <linux/platform_device.h>
+#include <linux/spi/spi.h>
+
+#include <asm/mach-ar71xx/ar71xx.h>
+
+#define DRV_NAME	"rb4xx-spi"
+#define DRV_DESC	"Mikrotik RB4xx SPI controller driver"
+#define DRV_VERSION	"0.1.0"
+
+#define SPI_CTRL_FASTEST	0x40
+#define SPI_FLASH_HZ		33333334
+#define SPI_CPLD_HZ		33333334
+
+#define CPLD_CMD_READ_FAST	0x0b
+
+#undef RB4XX_SPI_DEBUG
+
+struct rb4xx_spi {
+	void __iomem		*base;
+	struct spi_master	*master;
+
+	unsigned		spi_ctrl_flash;
+	unsigned		spi_ctrl_fread;
+
+	spinlock_t		lock;
+	struct list_head	queue;
+	int			busy:1;
+	int			cs_wait;
+};
+
+static unsigned spi_clk_low = SPI_IOC_CS1;
+
+#ifdef RB4XX_SPI_DEBUG
+static inline void do_spi_delay(void)
+{
+	ndelay(20000);
+}
+#else
+static inline void do_spi_delay(void) { }
+#endif
+
+static inline void do_spi_init(struct spi_device *spi)
+{
+	unsigned cs = SPI_IOC_CS0 | SPI_IOC_CS1;
+
+	if (!(spi->mode & SPI_CS_HIGH))
+		cs ^= (spi->chip_select == 2) ? SPI_IOC_CS1 : SPI_IOC_CS0;
+
+	spi_clk_low = cs;
+}
+
+static inline void do_spi_finish(void __iomem *base)
+{
+	do_spi_delay();
+	__raw_writel(SPI_IOC_CS0 | SPI_IOC_CS1, base + SPI_REG_IOC);
+}
+
+static inline void do_spi_clk(void __iomem *base, int bit)
+{
+	unsigned bval = spi_clk_low | ((bit & 1) ? SPI_IOC_DO : 0);
+
+	do_spi_delay();
+	__raw_writel(bval, base + SPI_REG_IOC);
+	do_spi_delay();
+	__raw_writel(bval | SPI_IOC_CLK, base + SPI_REG_IOC);
+}
+
+static void do_spi_byte(void __iomem *base, unsigned char byte)
+{
+	do_spi_clk(base, byte >> 7);
+	do_spi_clk(base, byte >> 6);
+	do_spi_clk(base, byte >> 5);
+	do_spi_clk(base, byte >> 4);
+	do_spi_clk(base, byte >> 3);
+	do_spi_clk(base, byte >> 2);
+	do_spi_clk(base, byte >> 1);
+	do_spi_clk(base, byte);
+
+	pr_debug("spi_byte sent 0x%02x got 0x%02x\n",
+	       (unsigned)byte,
+	       (unsigned char)__raw_readl(base + SPI_REG_RDS));
+}
+
+static inline void do_spi_clk_fast(void __iomem *base, unsigned bit1,
+				   unsigned bit2)
+{
+	unsigned bval = (spi_clk_low |
+			 ((bit1 & 1) ? SPI_IOC_DO : 0) |
+			 ((bit2 & 1) ? SPI_IOC_CS2 : 0));
+	do_spi_delay();
+	__raw_writel(bval, base + SPI_REG_IOC);
+	do_spi_delay();
+	__raw_writel(bval | SPI_IOC_CLK, base + SPI_REG_IOC);
+}
+
+static void do_spi_byte_fast(void __iomem *base, unsigned char byte)
+{
+	do_spi_clk_fast(base, byte >> 7, byte >> 6);
+	do_spi_clk_fast(base, byte >> 5, byte >> 4);
+	do_spi_clk_fast(base, byte >> 3, byte >> 2);
+	do_spi_clk_fast(base, byte >> 1, byte >> 0);
+
+	pr_debug("spi_byte_fast sent 0x%02x got 0x%02x\n",
+	       (unsigned)byte,
+	       (unsigned char) __raw_readl(base + SPI_REG_RDS));
+}
+
+static int rb4xx_spi_txrx(void __iomem *base, struct spi_transfer *t)
+{
+	const unsigned char *rxv_ptr = NULL;
+	const unsigned char *tx_ptr = t->tx_buf;
+	unsigned char *rx_ptr = t->rx_buf;
+	unsigned i;
+
+	pr_debug("spi_txrx len %u tx %u rx %u\n",
+	       t->len,
+	       (t->tx_buf ? 1 : 0),
+	       (t->rx_buf ? 1 : 0));
+
+	if (t->verify) {
+		rxv_ptr = tx_ptr;
+		tx_ptr = NULL;
+	}
+
+	for (i = 0; i < t->len; ++i) {
+		unsigned char sdata = tx_ptr ? tx_ptr[i] : 0;
+
+		if (t->fast_write)
+			do_spi_byte_fast(base, sdata);
+		else
+			do_spi_byte(base, sdata);
+
+		if (rx_ptr) {
+			rx_ptr[i] = __raw_readl(base + SPI_REG_RDS) & 0xff;
+		} else if (rxv_ptr) {
+			unsigned char c = __raw_readl(base + SPI_REG_RDS);
+			if (rxv_ptr[i] != c)
+				return i;
+		}
+	}
+
+	return i;
+}
+
+static int rb4xx_spi_read_fast(struct rb4xx_spi *rbspi,
+			       struct spi_message *m)
+{
+	struct spi_transfer *t;
+	const unsigned char *tx_ptr;
+	unsigned addr;
+	void __iomem *base = rbspi->base;
+
+	/* check for exactly two transfers */
+	if (list_empty(&m->transfers) ||
+	    list_is_last(m->transfers.next, &m->transfers) ||
+	    !list_is_last(m->transfers.next->next, &m->transfers)) {
+		return -1;
+	}
+
+	/* first transfer contains command and address  */
+	t = list_entry(m->transfers.next,
+		       struct spi_transfer, transfer_list);
+
+	if (t->len != 5 || t->tx_buf == NULL)
+		return -1;
+
+	tx_ptr = t->tx_buf;
+	if (tx_ptr[0] != CPLD_CMD_READ_FAST)
+		return -1;
+
+	addr = tx_ptr[1];
+	addr = tx_ptr[2] | (addr << 8);
+	addr = tx_ptr[3] | (addr << 8);
+	addr += (unsigned) base;
+
+	m->actual_length += t->len;
+
+	/* second transfer contains data itself */
+	t = list_entry(m->transfers.next->next,
+		       struct spi_transfer, transfer_list);
+
+	if (t->tx_buf && !t->verify)
+		return -1;
+
+	__raw_writel(SPI_FS_GPIO, base + SPI_REG_FS);
+	__raw_writel(rbspi->spi_ctrl_fread, base + SPI_REG_CTRL);
+	__raw_writel(0, base + SPI_REG_FS);
+
+	if (t->rx_buf) {
+		memcpy(t->rx_buf, (const void *)addr, t->len);
+	} else if (t->tx_buf) {
+		unsigned char buf[t->len];
+		memcpy(buf, (const void *)addr, t->len);
+		if (memcmp(t->tx_buf, buf, t->len) != 0)
+			m->status = -EMSGSIZE;
+	}
+	m->actual_length += t->len;
+
+	if (rbspi->spi_ctrl_flash != rbspi->spi_ctrl_fread) {
+		__raw_writel(SPI_FS_GPIO, base + SPI_REG_FS);
+		__raw_writel(rbspi->spi_ctrl_flash, base + SPI_REG_CTRL);
+		__raw_writel(0, base + SPI_REG_FS);
+	}
+
+	return 0;
+}
+
+static int rb4xx_spi_msg(struct rb4xx_spi *rbspi, struct spi_message *m)
+{
+	struct spi_transfer *t = NULL;
+	void __iomem *base = rbspi->base;
+
+	m->status = 0;
+	if (list_empty(&m->transfers))
+		return -1;
+
+	if (m->fast_read)
+		if (rb4xx_spi_read_fast(rbspi, m) == 0)
+			return -1;
+
+	__raw_writel(SPI_FS_GPIO, base + SPI_REG_FS);
+	__raw_writel(SPI_CTRL_FASTEST, base + SPI_REG_CTRL);
+	do_spi_init(m->spi);
+
+	list_for_each_entry(t, &m->transfers, transfer_list) {
+		int len;
+
+		len = rb4xx_spi_txrx(base, t);
+		if (len != t->len) {
+			m->status = -EMSGSIZE;
+			break;
+		}
+		m->actual_length += len;
+
+		if (t->cs_change) {
+			if (list_is_last(&t->transfer_list, &m->transfers)) {
+				/* wait for continuation */
+				return m->spi->chip_select;
+			}
+			do_spi_finish(base);
+			ndelay(100);
+		}
+	}
+
+	do_spi_finish(base);
+	__raw_writel(rbspi->spi_ctrl_flash, base + SPI_REG_CTRL);
+	__raw_writel(0, base + SPI_REG_FS);
+	return -1;
+}
+
+static void rb4xx_spi_process_queue_locked(struct rb4xx_spi *rbspi,
+					   unsigned long *flags)
+{
+	int cs = rbspi->cs_wait;
+
+	rbspi->busy = 1;
+	while (!list_empty(&rbspi->queue)) {
+		struct spi_message *m;
+
+		list_for_each_entry(m, &rbspi->queue, queue)
+			if (cs < 0 || cs == m->spi->chip_select)
+				break;
+
+		if (&m->queue == &rbspi->queue)
+			break;
+
+		list_del_init(&m->queue);
+		spin_unlock_irqrestore(&rbspi->lock, *flags);
+
+		cs = rb4xx_spi_msg(rbspi, m);
+		m->complete(m->context);
+
+		spin_lock_irqsave(&rbspi->lock, *flags);
+	}
+
+	rbspi->cs_wait = cs;
+	rbspi->busy = 0;
+
+	if (cs >= 0) {
+		/* TODO: add timer to unlock cs after 1s inactivity */
+	}
+}
+
+static int rb4xx_spi_transfer(struct spi_device *spi,
+			      struct spi_message *m)
+{
+	struct rb4xx_spi *rbspi = spi_master_get_devdata(spi->master);
+	unsigned long flags;
+
+	m->actual_length = 0;
+	m->status = -EINPROGRESS;
+
+	spin_lock_irqsave(&rbspi->lock, flags);
+	list_add_tail(&m->queue, &rbspi->queue);
+	if (rbspi->busy ||
+	    (rbspi->cs_wait >= 0 && rbspi->cs_wait != m->spi->chip_select)) {
+		/* job will be done later */
+		spin_unlock_irqrestore(&rbspi->lock, flags);
+		return 0;
+	}
+
+	/* process job in current context */
+	rb4xx_spi_process_queue_locked(rbspi, &flags);
+	spin_unlock_irqrestore(&rbspi->lock, flags);
+
+	return 0;
+}
+
+static int rb4xx_spi_setup(struct spi_device *spi)
+{
+	struct rb4xx_spi *rbspi = spi_master_get_devdata(spi->master);
+	unsigned long flags;
+
+	if (spi->mode & ~(SPI_CS_HIGH)) {
+		dev_err(&spi->dev, "mode %x not supported\n",
+			(unsigned) spi->mode);
+		return -EINVAL;
+	}
+
+	if (spi->bits_per_word != 8 && spi->bits_per_word != 0) {
+		dev_err(&spi->dev, "bits_per_word %u not supported\n",
+			(unsigned) spi->bits_per_word);
+		return -EINVAL;
+	}
+
+	spin_lock_irqsave(&rbspi->lock, flags);
+	if (rbspi->cs_wait == spi->chip_select && !rbspi->busy) {
+		rbspi->cs_wait = -1;
+		rb4xx_spi_process_queue_locked(rbspi, &flags);
+	}
+	spin_unlock_irqrestore(&rbspi->lock, flags);
+
+	return 0;
+}
+
+static unsigned get_spi_ctrl(unsigned hz_max, const char *name)
+{
+	unsigned div;
+
+	div = (ar71xx_ahb_freq - 1) / (2 * hz_max);
+
+	/*
+	 * CPU has a bug at (div == 0) - first bit read is random
+	 */
+	if (div == 0)
+		++div;
+
+	if (name) {
+		unsigned ahb_khz = (ar71xx_ahb_freq + 500) / 1000;
+		unsigned div_real = 2 * (div + 1);
+		pr_debug("rb4xx: %s SPI clock %u kHz (AHB %u kHz / %u)\n",
+		       name,
+		       ahb_khz / div_real,
+		       ahb_khz, div_real);
+	}
+
+	return SPI_CTRL_FASTEST + div;
+}
+
+static int rb4xx_spi_probe(struct platform_device *pdev)
+{
+	struct spi_master *master;
+	struct rb4xx_spi *rbspi;
+	struct resource *r;
+	int err = 0;
+
+	master = spi_alloc_master(&pdev->dev, sizeof(*rbspi));
+	if (master == NULL) {
+		dev_err(&pdev->dev, "no memory for spi_master\n");
+		err = -ENOMEM;
+		goto err_out;
+	}
+
+	master->bus_num = 0;
+	master->num_chipselect = 3;
+	master->setup = rb4xx_spi_setup;
+	master->transfer = rb4xx_spi_transfer;
+
+	rbspi = spi_master_get_devdata(master);
+	platform_set_drvdata(pdev, rbspi);
+
+	r = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (r == NULL) {
+		err = -ENOENT;
+		goto err_put_master;
+	}
+
+	rbspi->base = ioremap(r->start, r->end - r->start + 1);
+	if (!rbspi->base) {
+		err = -ENXIO;
+		goto err_put_master;
+	}
+
+	rbspi->master = master;
+	rbspi->spi_ctrl_flash = get_spi_ctrl(SPI_FLASH_HZ, "FLASH");
+	rbspi->spi_ctrl_fread = get_spi_ctrl(SPI_CPLD_HZ, "CPLD");
+	rbspi->cs_wait = -1;
+
+	spin_lock_init(&rbspi->lock);
+	INIT_LIST_HEAD(&rbspi->queue);
+
+	err = spi_register_master(master);
+	if (err) {
+		dev_err(&pdev->dev, "failed to register SPI master\n");
+		goto err_iounmap;
+	}
+
+	return 0;
+
+err_iounmap:
+	iounmap(rbspi->base);
+err_put_master:
+	platform_set_drvdata(pdev, NULL);
+	spi_master_put(master);
+err_out:
+	return err;
+}
+
+static int rb4xx_spi_remove(struct platform_device *pdev)
+{
+	struct rb4xx_spi *rbspi = platform_get_drvdata(pdev);
+
+	iounmap(rbspi->base);
+	platform_set_drvdata(pdev, NULL);
+	spi_master_put(rbspi->master);
+
+	return 0;
+}
+
+static struct platform_driver rb4xx_spi_drv = {
+	.probe		= rb4xx_spi_probe,
+	.remove		= rb4xx_spi_remove,
+	.driver		= {
+		.name	= DRV_NAME,
+		.owner	= THIS_MODULE,
+	},
+};
+
+static int __init rb4xx_spi_init(void)
+{
+	return platform_driver_register(&rb4xx_spi_drv);
+}
+subsys_initcall(rb4xx_spi_init);
+
+static void __exit rb4xx_spi_exit(void)
+{
+	platform_driver_unregister(&rb4xx_spi_drv);
+}
+
+module_exit(rb4xx_spi_exit);
+
+MODULE_DESCRIPTION(DRV_DESC);
+MODULE_VERSION(DRV_VERSION);
+MODULE_AUTHOR("Gabor Juhos <juhosg@openwrt.org>");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/spi/spi_rb4xx_cpld.c b/drivers/spi/spi_rb4xx_cpld.c
new file mode 100644
index 0000000..c0040a3
--- /dev/null
+++ b/drivers/spi/spi_rb4xx_cpld.c
@@ -0,0 +1,440 @@
+/*
+ * SPI driver for the CPLD chip on the Mikrotik RB4xx boards
+ *
+ * Copyright (C) 2010 Gabor Juhos <juhosg@openwrt.org>
+ *
+ * This file was based on the patches for Linux 2.6.27.39 published by
+ * MikroTik for their RouterBoard 4xx series devices.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation.
+ */
+
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/bitops.h>
+#include <linux/spi/spi.h>
+#include <linux/gpio.h>
+#include <linux/slab.h>
+
+#include <asm/mach-ar71xx/rb4xx_cpld.h>
+
+#define DRV_NAME	"spi-rb4xx-cpld"
+#define DRV_DESC	"RB4xx CPLD driver"
+#define DRV_VERSION	"0.1.0"
+
+#define CPLD_CMD_WRITE_NAND	0x08 /* send cmd, n x send data, send indle */
+#define CPLD_CMD_WRITE_CFG	0x09 /* send cmd, n x send cfg */
+#define CPLD_CMD_READ_NAND	0x0a /* send cmd, send idle, n x read data */
+#define CPLD_CMD_READ_FAST	0x0b /* send cmd, 4 x idle, n x read data */
+#define CPLD_CMD_LED5_ON	0x0c /* send cmd */
+#define CPLD_CMD_LED5_OFF	0x0d /* send cmd */
+
+struct rb4xx_cpld {
+	struct spi_device	*spi;
+	struct mutex		lock;
+	struct gpio_chip	chip;
+	unsigned int		config;
+};
+
+static struct rb4xx_cpld *rb4xx_cpld;
+
+static inline struct rb4xx_cpld *gpio_to_cpld(struct gpio_chip *chip)
+{
+	return container_of(chip, struct rb4xx_cpld, chip);
+}
+
+static int rb4xx_cpld_write_cmd(struct rb4xx_cpld *cpld, unsigned char cmd)
+{
+	struct spi_transfer t[1];
+	struct spi_message m;
+	unsigned char tx_buf[1];
+	int err;
+
+	spi_message_init(&m);
+	memset(&t, 0, sizeof(t));
+
+	t[0].tx_buf = tx_buf;
+	t[0].len = sizeof(tx_buf);
+	spi_message_add_tail(&t[0], &m);
+
+	tx_buf[0] = cmd;
+
+	err = spi_sync(cpld->spi, &m);
+	return err;
+}
+
+static int rb4xx_cpld_write_cfg(struct rb4xx_cpld *cpld, unsigned char config)
+{
+	struct spi_transfer t[1];
+	struct spi_message m;
+	unsigned char cmd[2];
+	int err;
+
+	spi_message_init(&m);
+	memset(&t, 0, sizeof(t));
+
+	t[0].tx_buf = cmd;
+	t[0].len = sizeof(cmd);
+	spi_message_add_tail(&t[0], &m);
+
+	cmd[0] = CPLD_CMD_WRITE_CFG;
+	cmd[1] = config;
+
+	err = spi_sync(cpld->spi, &m);
+	return err;
+}
+
+static int __rb4xx_cpld_change_cfg(struct rb4xx_cpld *cpld, unsigned mask,
+				   unsigned value)
+{
+	unsigned int config;
+	int err;
+
+	config = cpld->config & ~mask;
+	config |= value;
+
+	if ((cpld->config ^ config) & 0xff) {
+		err = rb4xx_cpld_write_cfg(cpld, config);
+		if (err)
+			return err;
+	}
+
+	if ((cpld->config ^ config) & CPLD_CFG_nLED5) {
+		err = rb4xx_cpld_write_cmd(cpld, (value) ? CPLD_CMD_LED5_ON :
+							   CPLD_CMD_LED5_OFF);
+		if (err)
+			return err;
+	}
+
+	cpld->config = config;
+	return 0;
+}
+
+int rb4xx_cpld_change_cfg(unsigned mask, unsigned value)
+{
+	int ret;
+
+	if (rb4xx_cpld == NULL)
+		return -ENODEV;
+
+	mutex_lock(&rb4xx_cpld->lock);
+	ret = __rb4xx_cpld_change_cfg(rb4xx_cpld, mask, value);
+	mutex_unlock(&rb4xx_cpld->lock);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(rb4xx_cpld_change_cfg);
+
+int rb4xx_cpld_read_from(unsigned addr, unsigned char *rx_buf,
+			 const unsigned char *verify_buf, unsigned count)
+{
+	const unsigned char cmd[5] = {
+		CPLD_CMD_READ_FAST,
+		(addr >> 16) & 0xff,
+		(addr >> 8) & 0xff,
+		 addr & 0xff,
+		 0
+	};
+	struct spi_transfer t[2] = {
+		{
+			.tx_buf = &cmd,
+			.len = 5,
+		},
+		{
+			.tx_buf = verify_buf,
+			.rx_buf = rx_buf,
+			.len = count,
+			.verify = (verify_buf != NULL),
+		},
+	};
+	struct spi_message m;
+
+	if (rb4xx_cpld == NULL)
+		return -ENODEV;
+
+	spi_message_init(&m);
+	m.fast_read = 1;
+	spi_message_add_tail(&t[0], &m);
+	spi_message_add_tail(&t[1], &m);
+	return spi_sync(rb4xx_cpld->spi, &m);
+}
+EXPORT_SYMBOL_GPL(rb4xx_cpld_read_from);
+
+#if 0
+int rb4xx_cpld_read(unsigned char *buf, unsigned char *verify_buf,
+		    unsigned count)
+{
+	struct spi_transfer t[2];
+	struct spi_message m;
+	unsigned char cmd[2];
+
+	if (rb4xx_cpld == NULL)
+		return -ENODEV;
+
+	spi_message_init(&m);
+	memset(&t, 0, sizeof(t));
+
+	/* send command */
+	t[0].tx_buf = cmd;
+	t[0].len = sizeof(cmd);
+	spi_message_add_tail(&t[0], &m);
+
+	cmd[0] = CPLD_CMD_READ_NAND;
+	cmd[1] = 0;
+
+	/* read data */
+	t[1].rx_buf = buf;
+	t[1].len = count;
+	spi_message_add_tail(&t[1], &m);
+
+	return spi_sync(rb4xx_cpld->spi, &m);
+}
+#else
+int rb4xx_cpld_read(unsigned char *rx_buf, const unsigned char *verify_buf,
+		    unsigned count)
+{
+	static const unsigned char cmd[2] = { CPLD_CMD_READ_NAND, 0 };
+	struct spi_transfer t[2] = {
+		{
+			.tx_buf = &cmd,
+			.len = 2,
+		}, {
+			.tx_buf = verify_buf,
+			.rx_buf = rx_buf,
+			.len = count,
+			.verify = (verify_buf != NULL),
+		},
+	};
+	struct spi_message m;
+
+	if (rb4xx_cpld == NULL)
+		return -ENODEV;
+
+	spi_message_init(&m);
+	spi_message_add_tail(&t[0], &m);
+	spi_message_add_tail(&t[1], &m);
+	return spi_sync(rb4xx_cpld->spi, &m);
+}
+#endif
+EXPORT_SYMBOL_GPL(rb4xx_cpld_read);
+
+int rb4xx_cpld_write(const unsigned char *buf, unsigned count)
+{
+#if 0
+	struct spi_transfer t[3];
+	struct spi_message m;
+	unsigned char cmd[1];
+
+	if (rb4xx_cpld == NULL)
+		return -ENODEV;
+
+	memset(&t, 0, sizeof(t));
+	spi_message_init(&m);
+
+	/* send command */
+	t[0].tx_buf = cmd;
+	t[0].len = sizeof(cmd);
+	spi_message_add_tail(&t[0], &m);
+
+	cmd[0] = CPLD_CMD_WRITE_NAND;
+
+	/* write data */
+	t[1].tx_buf = buf;
+	t[1].len = count;
+	spi_message_add_tail(&t[1], &m);
+
+	/* send idle */
+	t[2].len = 1;
+	spi_message_add_tail(&t[2], &m);
+
+	return spi_sync(rb4xx_cpld->spi, &m);
+#else
+	static const unsigned char cmd = CPLD_CMD_WRITE_NAND;
+	struct spi_transfer t[3] = {
+		{
+			.tx_buf = &cmd,
+			.len = 1,
+		}, {
+			.tx_buf = buf,
+			.len = count,
+			.fast_write = 1,
+		}, {
+			.len = 1,
+			.fast_write = 1,
+		},
+	};
+	struct spi_message m;
+
+	if (rb4xx_cpld == NULL)
+		return -ENODEV;
+
+	spi_message_init(&m);
+	spi_message_add_tail(&t[0], &m);
+	spi_message_add_tail(&t[1], &m);
+	spi_message_add_tail(&t[2], &m);
+	return spi_sync(rb4xx_cpld->spi, &m);
+#endif
+}
+EXPORT_SYMBOL_GPL(rb4xx_cpld_write);
+
+static int rb4xx_cpld_gpio_get(struct gpio_chip *chip, unsigned offset)
+{
+	struct rb4xx_cpld *cpld = gpio_to_cpld(chip);
+	int ret;
+
+	mutex_lock(&cpld->lock);
+	ret = (cpld->config >> offset) & 1;
+	mutex_unlock(&cpld->lock);
+
+	return ret;
+}
+
+static void rb4xx_cpld_gpio_set(struct gpio_chip *chip, unsigned offset,
+				int value)
+{
+	struct rb4xx_cpld *cpld = gpio_to_cpld(chip);
+
+	mutex_lock(&cpld->lock);
+	__rb4xx_cpld_change_cfg(cpld, (1 << offset), !!value << offset);
+	mutex_unlock(&cpld->lock);
+}
+
+static int rb4xx_cpld_gpio_direction_input(struct gpio_chip *chip,
+					   unsigned offset)
+{
+	return -EOPNOTSUPP;
+}
+
+static int rb4xx_cpld_gpio_direction_output(struct gpio_chip *chip,
+					    unsigned offset,
+					    int value)
+{
+	struct rb4xx_cpld *cpld = gpio_to_cpld(chip);
+	int ret;
+
+	mutex_lock(&cpld->lock);
+	ret = __rb4xx_cpld_change_cfg(cpld, (1 << offset), !!value << offset);
+	mutex_unlock(&cpld->lock);
+
+	return ret;
+}
+
+static int rb4xx_cpld_gpio_init(struct rb4xx_cpld *cpld, unsigned int base)
+{
+	int err;
+
+	/* init config */
+	cpld->config = CPLD_CFG_nLED1 | CPLD_CFG_nLED2 | CPLD_CFG_nLED3 |
+		       CPLD_CFG_nLED4 | CPLD_CFG_nCE;
+	rb4xx_cpld_write_cfg(cpld, cpld->config);
+
+	/* setup GPIO chip */
+	cpld->chip.label = DRV_NAME;
+
+	cpld->chip.get = rb4xx_cpld_gpio_get;
+	cpld->chip.set = rb4xx_cpld_gpio_set;
+	cpld->chip.direction_input = rb4xx_cpld_gpio_direction_input;
+	cpld->chip.direction_output = rb4xx_cpld_gpio_direction_output;
+
+	cpld->chip.base = base;
+	cpld->chip.ngpio = CPLD_NUM_GPIOS;
+	cpld->chip.can_sleep = 1;
+	cpld->chip.dev = &cpld->spi->dev;
+	cpld->chip.owner = THIS_MODULE;
+
+	err = gpiochip_add(&cpld->chip);
+	if (err)
+		dev_err(&cpld->spi->dev, "adding GPIO chip failed, err=%d\n",
+			err);
+
+	return err;
+}
+
+static int __devinit rb4xx_cpld_probe(struct spi_device *spi)
+{
+	struct rb4xx_cpld *cpld;
+	struct rb4xx_cpld_platform_data *pdata;
+	int err;
+
+	pdata = spi->dev.platform_data;
+	if (!pdata) {
+		dev_dbg(&spi->dev, "no platform data\n");
+		return -EINVAL;
+	}
+
+	cpld = kzalloc(sizeof(*cpld), GFP_KERNEL);
+	if (!cpld) {
+		dev_err(&spi->dev, "no memory for private data\n");
+		return -ENOMEM;
+	}
+
+	mutex_init(&cpld->lock);
+	cpld->spi = spi_dev_get(spi);
+	dev_set_drvdata(&spi->dev, cpld);
+
+	spi->mode = SPI_MODE_0;
+	spi->bits_per_word = 8;
+	err = spi_setup(spi);
+	if (err) {
+		dev_err(&spi->dev, "spi_setup failed, err=%d\n", err);
+		goto err_drvdata;
+	}
+
+	err = rb4xx_cpld_gpio_init(cpld, pdata->gpio_base);
+	if (err)
+		goto err_drvdata;
+
+	rb4xx_cpld = cpld;
+
+	return 0;
+
+err_drvdata:
+	dev_set_drvdata(&spi->dev, NULL);
+	kfree(cpld);
+
+	return err;
+}
+
+static int __devexit rb4xx_cpld_remove(struct spi_device *spi)
+{
+	struct rb4xx_cpld *cpld;
+
+	rb4xx_cpld = NULL;
+	cpld = dev_get_drvdata(&spi->dev);
+	dev_set_drvdata(&spi->dev, NULL);
+	kfree(cpld);
+
+	return 0;
+}
+
+static struct spi_driver rb4xx_cpld_driver = {
+	.driver = {
+		.name		= DRV_NAME,
+		.bus		= &spi_bus_type,
+		.owner		= THIS_MODULE,
+	},
+	.probe		= rb4xx_cpld_probe,
+	.remove		= __devexit_p(rb4xx_cpld_remove),
+};
+
+static int __init rb4xx_cpld_init(void)
+{
+	return spi_register_driver(&rb4xx_cpld_driver);
+}
+module_init(rb4xx_cpld_init);
+
+static void __exit rb4xx_cpld_exit(void)
+{
+	spi_unregister_driver(&rb4xx_cpld_driver);
+}
+module_exit(rb4xx_cpld_exit);
+
+MODULE_DESCRIPTION(DRV_DESC);
+MODULE_VERSION(DRV_VERSION);
+MODULE_AUTHOR("Gabor Juhos <juhosg@openwrt.org>");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/spi/spi_vsc7385.c b/drivers/spi/spi_vsc7385.c
index c16707e..9340df2 100644
--- a/drivers/spi/spi_vsc7385.c
+++ b/drivers/spi/spi_vsc7385.c
@@ -56,8 +56,8 @@
 #define VSC73XX_MAC_CFG_WEXC_DIS	(1 << 31)
 #define VSC73XX_MAC_CFG_PORT_RST	(1 << 29)
 #define VSC73XX_MAC_CFG_TX_EN		(1 << 28)
-#define VSC73XX_MAC_CFG_SEED_LOAD      	(1 << 27)
-#define VSC73XX_MAC_CFG_FDX	        (1 << 18)
+#define VSC73XX_MAC_CFG_SEED_LOAD	(1 << 27)
+#define VSC73XX_MAC_CFG_FDX		(1 << 18)
 #define VSC73XX_MAC_CFG_GIGE		(1 << 17)
 #define VSC73XX_MAC_CFG_RX_EN		(1 << 16)
 #define VSC73XX_MAC_CFG_VLAN_DBLAWR	(1 << 15)
@@ -398,7 +398,8 @@ static int vsc7385_upload_ucode(struct vsc7385 *vsc)
 		rc = vsc7385_read(vsc, VSC73XX_BLOCK_SYSTEM, 0,
 				  VSC73XX_ICPU_SRAM, &curVal);
 		if (rc) {
-			dev_err(&spi->dev, "could not read microcode %d\n",rc);
+			dev_err(&spi->dev, "could not read microcode %d\n",
+				rc);
 			goto out;
 		}
 
@@ -430,7 +431,7 @@ static int vsc7385_upload_ucode(struct vsc7385 *vsc)
 
 	rc = vsc7385_icpu_start(vsc);
 
- out:
+out:
 	release_firmware(firmware);
 	return rc;
 }
@@ -475,7 +476,7 @@ static int vsc7385_setup(struct vsc7385 *vsc)
 
 	return 0;
 
- err:
+err:
 	return err;
 }
 
@@ -520,7 +521,7 @@ static int vsc7385_detect(struct vsc7385 *vsc)
 
 	rev = (t >> VSC73XX_ICPU_CHIPID_REV_SHIFT) &
 	      VSC73XX_ICPU_CHIPID_REV_MASK;
-	dev_info(&spi->dev, "VSC%04X (rev. %d) switch found \n", id, rev);
+	dev_info(&spi->dev, "VSC%04X (rev. %d) switch found\n", id, rev);
 
 	return 0;
 }
@@ -536,13 +537,13 @@ static int __devinit vsc7385_probe(struct spi_device *spi)
 	pdata = spi->dev.platform_data;
 	if (!pdata) {
 		dev_err(&spi->dev, "no platform data specified\n");
-		return-ENODEV;
+		return -ENODEV;
 	}
 
 	vsc = kzalloc(sizeof(*vsc), GFP_KERNEL);
 	if (!vsc) {
 		dev_err(&spi->dev, "no memory for private data\n");
-		return-ENOMEM;
+		return -ENOMEM;
 	}
 
 	mutex_init(&vsc->lock);
@@ -554,13 +555,13 @@ static int __devinit vsc7385_probe(struct spi_device *spi)
 	spi->bits_per_word = 8;
 	err = spi_setup(spi);
 	if (err) {
-		dev_err(&spi->dev, "spi_setup failed, err=%d \n", err);
+		dev_err(&spi->dev, "spi_setup failed, err=%d\n", err);
 		goto err_drvdata;
 	}
 
 	err = vsc7385_detect(vsc);
 	if (err) {
-		dev_err(&spi->dev, "no chip found, err=%d \n", err);
+		dev_err(&spi->dev, "no chip found, err=%d\n", err);
 		goto err_drvdata;
 	}
 
@@ -574,7 +575,7 @@ static int __devinit vsc7385_probe(struct spi_device *spi)
 
 	return 0;
 
- err_drvdata:
+err_drvdata:
 	dev_set_drvdata(&spi->dev, NULL);
 	kfree(vsc);
 	return err;
diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index bb4f5fb..a097bdd 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -441,6 +441,8 @@ struct spi_transfer {
 	dma_addr_t	rx_dma;
 
 	unsigned	cs_change:1;
+	unsigned	verify:1;
+	unsigned	fast_write:1;
 	u8		bits_per_word;
 	u16		delay_usecs;
 	u32		speed_hz;
@@ -482,6 +484,7 @@ struct spi_message {
 	struct spi_device	*spi;
 
 	unsigned		is_dma_mapped:1;
+	unsigned		fast_read:1;
 
 	/* REVISIT:  we might want a flag affecting the behavior of the
 	 * last transfer ... allowing things like "read 16 bit length L"
-- 
1.7.4.1

