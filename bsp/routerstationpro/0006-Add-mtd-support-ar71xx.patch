From 2eb16e2b1d846ce3f2bccef2a0b5c5b2d4da96e9 Mon Sep 17 00:00:00 2001
From: Zumeng Chen <zumeng.chen@windriver.com>
Date: Wed, 29 Sep 2010 10:09:30 +0800
Subject: [PATCH 06/41] Add mtd support ar71xx

Which is downloaded from the following:
  https://dev.openwrt.org/browser/branches
  branches_backfire_target_linux_ar71xx_files-r23140.zip

Integrated-by: Zumeng Chen <zumeng.chen@windriver.com>
diff --git a/drivers/mtd/Kconfig b/drivers/mtd/Kconfig
index 318a869..80abcd6 100644
--- a/drivers/mtd/Kconfig
+++ b/drivers/mtd/Kconfig
@@ -140,6 +140,12 @@ config MTD_AR7_PARTS
 	---help---
 	  TI AR7 partitioning support
 
+config MTD_WRT160NL_PARTS
+	tristate "Linksys WRT160NL partitioning support"
+	depends on MTD_PARTITIONS && AR71XX_MACH_WRT160NL
+	---help---
+	   Linksys WRT160NL partitioning support
+
 comment "User Modules And Translation Layers"
 
 config MTD_CHAR
diff --git a/drivers/mtd/Makefile b/drivers/mtd/Makefile
index 9aaac3a..6c724d0 100644
--- a/drivers/mtd/Makefile
+++ b/drivers/mtd/Makefile
@@ -11,6 +11,7 @@ obj-$(CONFIG_MTD_REDBOOT_PARTS) += redboot.o
 obj-$(CONFIG_MTD_CMDLINE_PARTS) += cmdlinepart.o
 obj-$(CONFIG_MTD_AFS_PARTS)	+= afs.o
 obj-$(CONFIG_MTD_AR7_PARTS)	+= ar7part.o
+obj-$(CONFIG_MTD_WRT160NL_PARTS) += wrt160nl_part.o
 
 # 'Users' - code which presents functionality to userspace.
 obj-$(CONFIG_MTD_CHAR)		+= mtdchar.o
diff --git a/drivers/mtd/devices/m25p80.c b/drivers/mtd/devices/m25p80.c
index 884904d..7f0d3ca 100644
--- a/drivers/mtd/devices/m25p80.c
+++ b/drivers/mtd/devices/m25p80.c
@@ -899,6 +899,16 @@ static int __devinit m25p_probe(struct spi_device *spi)
 		write_sr(flash, 0);
 	}
 
+#ifdef CONFIG_MTD_WRT160NL_PARTS
+	if (nr_parts <= 0) {
+		static const char *part_probes[]
+			= { "wrt160nl", NULL, };
+
+		nr_parts = parse_mtd_partitions(&flash->mtd,
+						part_probes, &parts, 0);
+	}
+#endif
+
 	if (data && data->name)
 		flash->mtd.name = data->name;
 	else
diff --git a/drivers/mtd/maps/Kconfig b/drivers/mtd/maps/Kconfig
index 8e0c4bf..3c48ecf 100644
--- a/drivers/mtd/maps/Kconfig
+++ b/drivers/mtd/maps/Kconfig
@@ -257,6 +257,13 @@ config MTD_LANTIQ
 	help
 	  Support for NOR flash attached to the Lantiq SoC's External Bus Unit.
 
+config MTD_AR91XX_FLASH
+	tristate "Atheros AR91xx parallel flash support"
+	depends on ATHEROS_AR71XX
+	select MTD_COMPLEX_MAPPINGS
+	help
+	  Parallel flash driver for the Atheros AR91xx based boards.
+
 config MTD_DILNETPC
 	tristate "CFI Flash device mapped on DIL/Net PC"
 	depends on X86 && MTD_CFI_INTELEXT && BROKEN
diff --git a/drivers/mtd/maps/Makefile b/drivers/mtd/maps/Makefile
index 45dcb8b..a7d5c4f 100644
--- a/drivers/mtd/maps/Makefile
+++ b/drivers/mtd/maps/Makefile
@@ -38,6 +38,7 @@ obj-$(CONFIG_MTD_SCx200_DOCFLASH)+= scx200_docflash.o
 obj-$(CONFIG_MTD_DBOX2)		+= dbox2-flash.o
 obj-$(CONFIG_MTD_SOLUTIONENGINE)+= solutionengine.o
 obj-$(CONFIG_MTD_PCI)		+= pci.o
+obj-$(CONFIG_MTD_AR91XX_FLASH)	+= ar91xx_flash.o
 obj-$(CONFIG_MTD_AUTCPU12)	+= autcpu12-nvram.o
 obj-$(CONFIG_MTD_IMPA7)		+= impa7.o
 obj-$(CONFIG_MTD_FORTUNET)	+= fortunet.o
diff --git a/drivers/mtd/maps/ar91xx_flash.c b/drivers/mtd/maps/ar91xx_flash.c
new file mode 100644
index 0000000..1a55f4a
--- /dev/null
+++ b/drivers/mtd/maps/ar91xx_flash.c
@@ -0,0 +1,310 @@
+/*
+ * Parallel flash driver for the Atheros AR91xx SoC
+ *
+ * Copyright (C) 2009 Gabor Juhos <juhosg@openwrt.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+#include <linux/io.h>
+
+#include <asm/mach-ar71xx/ar71xx.h>
+#include <asm/mach-ar71xx/ar91xx_flash.h>
+
+#define DRV_NAME	"ar91xx-flash"
+
+struct ar91xx_flash_info {
+	struct mtd_info		*mtd;
+	struct map_info		map;
+#ifdef CONFIG_MTD_PARTITIONS
+	int			nr_parts;
+	struct mtd_partition	*parts;
+#endif
+};
+
+static map_word ar91xx_flash_read(struct map_info *map, unsigned long ofs)
+{
+	map_word val;
+
+	if (map_bankwidth_is_1(map))
+		val.x[0] = __raw_readb(map->virt + (ofs ^ 3));
+	else if (map_bankwidth_is_2(map))
+		val.x[0] = __raw_readw(map->virt + (ofs ^ 2));
+	else
+		val = map_word_ff(map);
+
+	return val;
+}
+
+static void ar91xx_flash_write(struct map_info *map, map_word d,
+			       unsigned long ofs)
+{
+	if (map_bankwidth_is_1(map))
+		__raw_writeb(d.x[0], map->virt + (ofs ^ 3));
+	else if (map_bankwidth_is_2(map))
+		__raw_writew(d.x[0], map->virt + (ofs ^ 2));
+
+	mb();
+}
+
+static map_word ar91xx_flash_read_lock(struct map_info *map, unsigned long ofs)
+{
+	map_word ret;
+
+	ar71xx_flash_acquire();
+	ret = ar91xx_flash_read(map, ofs);
+	ar71xx_flash_release();
+
+	return ret;
+}
+
+static void ar91xx_flash_write_lock(struct map_info *map, map_word d,
+			       unsigned long ofs)
+{
+	ar71xx_flash_acquire();
+	ar91xx_flash_write(map, d, ofs);
+	ar71xx_flash_release();
+}
+
+static void ar91xx_flash_copy_from_lock(struct map_info *map, void *to,
+					unsigned long from, ssize_t len)
+{
+	ar71xx_flash_acquire();
+	inline_map_copy_from(map, to, from, len);
+	ar71xx_flash_release();
+}
+
+static void ar91xx_flash_copy_to_lock(struct map_info *map, unsigned long to,
+				      const void *from, ssize_t len)
+{
+	ar71xx_flash_acquire();
+	inline_map_copy_to(map, to, from, len);
+	ar71xx_flash_release();
+}
+
+static int ar91xx_flash_remove(struct platform_device *pdev)
+{
+	struct ar91xx_flash_platform_data *pdata;
+	struct ar91xx_flash_info *info;
+
+	info = platform_get_drvdata(pdev);
+	if (info == NULL)
+		return 0;
+
+	platform_set_drvdata(pdev, NULL);
+
+	if (info->mtd == NULL)
+		return 0;
+
+	pdata = pdev->dev.platform_data;
+#ifdef CONFIG_MTD_PARTITIONS
+	if (info->nr_parts) {
+		del_mtd_partitions(info->mtd);
+		kfree(info->parts);
+	} else if (pdata->nr_parts) {
+		del_mtd_partitions(info->mtd);
+	} else {
+		del_mtd_device(info->mtd);
+	}
+#else
+	del_mtd_device(info->mtd);
+#endif
+	map_destroy(info->mtd);
+
+	return 0;
+}
+
+static const char *rom_probe_types[] = { "cfi_probe", "jedec_probe", NULL };
+#ifdef CONFIG_MTD_PARTITIONS
+static const char *part_probe_types[] = { "cmdlinepart", "RedBoot", NULL };
+#endif
+
+static int ar91xx_flash_probe(struct platform_device *pdev)
+{
+	struct ar91xx_flash_platform_data *pdata;
+	struct ar91xx_flash_info *info;
+	struct resource *res;
+	struct resource *region;
+	const char **probe_type;
+	int err = 0;
+
+	pdata = pdev->dev.platform_data;
+	if (pdata == NULL)
+		return -EINVAL;
+
+	info = devm_kzalloc(&pdev->dev, sizeof(struct ar91xx_flash_info),
+			    GFP_KERNEL);
+	if (info == NULL) {
+		err = -ENOMEM;
+		goto err_out;
+	}
+
+	platform_set_drvdata(pdev, info);
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (res == NULL) {
+		err = -ENOENT;
+		goto err_out;
+	}
+
+	dev_info(&pdev->dev, "%.8llx at %.8llx\n",
+		 (unsigned long long)(res->end - res->start + 1),
+		 (unsigned long long)res->start);
+
+	region = devm_request_mem_region(&pdev->dev,
+					 res->start, res->end - res->start + 1,
+					 dev_name(&pdev->dev));
+	if (region == NULL) {
+		dev_err(&pdev->dev, "could not reserve memory region\n");
+		err = -ENOMEM;
+		goto err_out;
+	}
+
+	info->map.name = dev_name(&pdev->dev);
+	info->map.phys = res->start;
+	info->map.size = res->end - res->start + 1;
+	info->map.bankwidth = pdata->width;
+
+	info->map.virt = devm_ioremap(&pdev->dev, info->map.phys,
+				      info->map.size);
+	if (info->map.virt == NULL) {
+		dev_err(&pdev->dev, "failed to ioremap flash region\n");
+		err = -EIO;
+		goto err_out;
+	}
+
+	simple_map_init(&info->map);
+	if (pdata->is_shared) {
+		info->map.read = ar91xx_flash_read_lock;
+		info->map.write = ar91xx_flash_write_lock;
+		info->map.copy_from = ar91xx_flash_copy_from_lock;
+		info->map.copy_to = ar91xx_flash_copy_to_lock;
+	} else {
+		info->map.read = ar91xx_flash_read;
+		info->map.write = ar91xx_flash_write;
+	}
+
+	probe_type = rom_probe_types;
+	for (; info->mtd == NULL && *probe_type != NULL; probe_type++)
+		info->mtd = do_map_probe(*probe_type, &info->map);
+
+	if (info->mtd == NULL) {
+		dev_err(&pdev->dev, "map_probe failed\n");
+		err = -ENXIO;
+		goto err_out;
+	}
+
+	info->mtd->owner = THIS_MODULE;
+
+#ifdef CONFIG_MTD_PARTITIONS
+	if (pdata->nr_parts) {
+		dev_info(&pdev->dev, "using static partition mapping\n");
+		add_mtd_partitions(info->mtd, pdata->parts, pdata->nr_parts);
+		return 0;
+	}
+
+	err = parse_mtd_partitions(info->mtd, part_probe_types,
+				   &info->parts, 0);
+	if (err > 0) {
+		add_mtd_partitions(info->mtd, info->parts, err);
+		return 0;
+	}
+#endif
+
+	add_mtd_device(info->mtd);
+	return 0;
+
+ err_out:
+	ar91xx_flash_remove(pdev);
+	return err;
+}
+
+#ifdef CONFIG_PM
+static int ar91xx_flash_suspend(struct platform_device *dev, pm_message_t state)
+{
+	struct ar91xx_flash_info *info = platform_get_drvdata(dev);
+	int ret = 0;
+
+	if (info->mtd->suspend)
+		ret = info->mtd->suspend(info->mtd);
+
+	if (ret)
+		goto fail;
+
+	return 0;
+
+ fail:
+	if (info->mtd->suspend) {
+		BUG_ON(!info->mtd->resume);
+		info->mtd->resume(info->mtd);
+	}
+
+	return ret;
+}
+
+static int ar91xx_flash_resume(struct platform_device *pdev)
+{
+	struct ar91xx_flash_info *info = platform_get_drvdata(pdev);
+
+	if (info->mtd->resume)
+		info->mtd->resume(info->mtd);
+
+	return 0;
+}
+
+static void ar91xx_flash_shutdown(struct platform_device *pdev)
+{
+	struct ar91xx_flash_info *info = platform_get_drvdata(pdev);
+
+	if (info->mtd->suspend && info->mtd->resume)
+		if (info->mtd->suspend(info->mtd) == 0)
+			info->mtd->resume(info->mtd);
+}
+#else
+#define ar91xx_flash_suspend	NULL
+#define ar91xx_flash_resume	NULL
+#define ar91xx_flash_shutdown	NULL
+#endif
+
+static struct platform_driver ar91xx_flash_driver = {
+	.probe		= ar91xx_flash_probe,
+	.remove		= ar91xx_flash_remove,
+	.suspend	= ar91xx_flash_suspend,
+	.resume		= ar91xx_flash_resume,
+	.shutdown	= ar91xx_flash_shutdown,
+	.driver		= {
+		.name	= DRV_NAME,
+		.owner	= THIS_MODULE,
+	},
+};
+
+static int __init ar91xx_flash_init(void)
+{
+	return platform_driver_register(&ar91xx_flash_driver);
+}
+
+static void __exit ar91xx_flash_exit(void)
+{
+	platform_driver_unregister(&ar91xx_flash_driver);
+}
+
+module_init(ar91xx_flash_init);
+module_exit(ar91xx_flash_exit);
+
+MODULE_LICENSE("GPL v2");
+MODULE_AUTHOR("Gabor Juhos <juhosg@openwrt.org>");
+MODULE_DESCRIPTION("Parallel flash driver for the Atheros AR91xx SoC");
+MODULE_ALIAS("platform:" DRV_NAME);
diff --git a/drivers/mtd/nand/Kconfig b/drivers/mtd/nand/Kconfig
index cce7b70..1ef190b 100644
--- a/drivers/mtd/nand/Kconfig
+++ b/drivers/mtd/nand/Kconfig
@@ -537,4 +537,12 @@ config MTD_NAND_FSMC
 	  Enables support for NAND Flash chips on the ST Microelectronics
 	  Flexible Static Memory Controller (FSMC)
 
+config MTD_NAND_RB4XX
+	tristate "NAND flash driver for RouterBoard 4xx series"
+	depends on MTD_NAND && AR71XX_MACH_RB4XX
+
+config MTD_NAND_RB750
+	tristate "NAND flash driver for the RouterBoard 750"
+	depends on MTD_NAND && AR71XX_MACH_RB750
+
 endif # MTD_NAND
diff --git a/drivers/mtd/nand/Makefile b/drivers/mtd/nand/Makefile
index 618f4ba..f078ea7 100644
--- a/drivers/mtd/nand/Makefile
+++ b/drivers/mtd/nand/Makefile
@@ -33,6 +33,8 @@ obj-$(CONFIG_MTD_NAND_CM_X270)		+= cmx270_nand.o
 obj-$(CONFIG_MTD_NAND_PXA3xx)		+= pxa3xx_nand.o
 obj-$(CONFIG_MTD_NAND_TMIO)		+= tmio_nand.o
 obj-$(CONFIG_MTD_NAND_PLATFORM)		+= plat_nand.o
+obj-$(CONFIG_MTD_NAND_RB4XX)		+= rb4xx_nand.o
+obj-$(CONFIG_MTD_NAND_RB750)		+= rb750_nand.o
 obj-$(CONFIG_MTD_ALAUDA)		+= alauda.o
 obj-$(CONFIG_MTD_NAND_PASEMI)		+= pasemi_nand.o
 obj-$(CONFIG_MTD_NAND_ORION)		+= orion_nand.o
diff --git a/drivers/mtd/nand/rb4xx_nand.c b/drivers/mtd/nand/rb4xx_nand.c
new file mode 100644
index 0000000..5087794
--- /dev/null
+++ b/drivers/mtd/nand/rb4xx_nand.c
@@ -0,0 +1,507 @@
+/*
+ *  NAND flash driver for the MikroTik RouterBoard 4xx series
+ *
+ *  Copyright (C) 2008 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  This file was based on the driver for Linux 2.6.22 published by
+ *  MikroTik for their RouterBoard 4xx series devices.
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/init.h>
+#include <linux/mtd/nand.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/io.h>
+#include <linux/gpio.h>
+
+#include <asm/mach-ar71xx/ar71xx.h>
+
+#define DRV_NAME        "rb4xx-nand"
+#define DRV_VERSION     "0.1.10"
+#define DRV_DESC        "NAND flash driver for RouterBoard 4xx series"
+
+#define USE_FAST_READ	1
+#define USE_FAST_WRITE	1
+#undef RB4XX_NAND_DEBUG
+
+#ifdef RB4XX_NAND_DEBUG
+#define DBG(fmt, arg...)	printk(KERN_DEBUG DRV_NAME ": " fmt, ## arg)
+#else
+#define DBG(fmt, arg...)	do {} while (0)
+#endif
+
+#define RB4XX_NAND_GPIO_RDY	5
+#define RB4XX_FLASH_HZ		33333334
+#define RB4XX_NAND_HZ		33333334
+
+#define SPI_CTRL_FASTEST	0x40
+#define SPI_CTRL_SAFE		0x43	/* 25 MHz for AHB 200 MHz */
+#define SBIT_IOC_BASE		SPI_IOC_CS1
+#define SBIT_IOC_DO_SHIFT	0
+#define SBIT_IOC_DO		(1u << SBIT_IOC_DO_SHIFT)
+#define SBIT_IOC_DO2_SHIFT	18
+#define SBIT_IOC_DO2		(1u << SBIT_IOC_DO2_SHIFT)
+
+#define CPLD_CMD_WRITE_MULT	0x08	/* send cmd, n x send data, read data */
+#define CPLD_CMD_WRITE_CFG	0x09	/* send cmd, n x send cfg */
+#define CPLD_CMD_READ_MULT	0x0a	/* send cmd, send idle, n x read data */
+#define CPLD_CMD_READ_FAST	0x0b	/* send cmd, 4 x idle, n x read data */
+
+#define CFG_BIT_nCE	0x80
+#define CFG_BIT_CLE	0x40
+#define CFG_BIT_ALE	0x20
+#define CFG_BIT_FAN	0x10
+#define CFG_BIT_nLED4	0x08
+#define CFG_BIT_nLED3	0x04
+#define CFG_BIT_nLED2	0x02
+#define CFG_BIT_nLED1	0x01
+
+#define CFG_BIT_nLEDS \
+	(CFG_BIT_nLED1 | CFG_BIT_nLED2 | CFG_BIT_nLED3 | CFG_BIT_nLED4)
+
+struct rb4xx_nand_info {
+	struct nand_chip	chip;
+	struct mtd_info		mtd;
+};
+
+/*
+ * We need to use the OLD Yaffs-1 OOB layout, otherwise the RB bootloader
+ * will not be able to find the kernel that we load.
+ */
+static struct nand_ecclayout rb4xx_nand_ecclayout = {
+	.eccbytes	= 6,
+	.eccpos		= { 8, 9, 10, 13, 14, 15 },
+	.oobavail	= 9,
+	.oobfree	= { { 0, 4 }, { 6, 2 }, { 11, 2 }, { 4, 1 } }
+};
+
+static struct mtd_partition rb4xx_nand_partitions[] = {
+	{
+		.name	= "booter",
+		.offset	= 0,
+		.size	= (256 * 1024),
+		.mask_flags = MTD_WRITEABLE,
+	},
+	{
+		.name	= "kernel",
+		.offset	= (256 * 1024),
+		.size	= (4 * 1024 * 1024) - (256 * 1024),
+	},
+	{
+		.name	= "rootfs",
+		.offset	= MTDPART_OFS_NXTBLK,
+		.size	= MTDPART_SIZ_FULL,
+	},
+};
+
+#if USE_FAST_READ
+#define SPI_NDATA_BASE	0x00800000
+static unsigned spi_ctrl_fread = SPI_CTRL_SAFE;
+static unsigned spi_ctrl_flash = SPI_CTRL_SAFE;
+extern unsigned mips_hpt_frequency;
+#endif
+
+static inline unsigned rb4xx_spi_rreg(unsigned r)
+{
+	return __raw_readl((void * __iomem)(KSEG1ADDR(AR71XX_SPI_BASE) + r));
+}
+
+static inline void rb4xx_spi_wreg(unsigned r, unsigned v)
+{
+	__raw_writel(v, (void * __iomem)(KSEG1ADDR(AR71XX_SPI_BASE) + r));
+}
+
+static inline void do_spi_clk(int bit)
+{
+	unsigned bval = SBIT_IOC_BASE | (bit & 1);
+
+	rb4xx_spi_wreg(SPI_REG_IOC, bval);
+	rb4xx_spi_wreg(SPI_REG_IOC, bval | SPI_IOC_CLK);
+}
+
+static void do_spi_byte(uint8_t byte)
+{
+	do_spi_clk(byte >> 7);
+	do_spi_clk(byte >> 6);
+	do_spi_clk(byte >> 5);
+	do_spi_clk(byte >> 4);
+	do_spi_clk(byte >> 3);
+	do_spi_clk(byte >> 2);
+	do_spi_clk(byte >> 1);
+	do_spi_clk(byte);
+
+	DBG("spi_byte sent 0x%02x got 0x%x\n",
+					byte, rb4xx_spi_rreg(SPI_REG_RDS));
+}
+
+#if USE_FAST_WRITE
+static inline void do_spi_clk_fast(int bit1, int bit2)
+{
+	unsigned bval = (SBIT_IOC_BASE |
+			((bit1 << SBIT_IOC_DO_SHIFT) & SBIT_IOC_DO) |
+			((bit2 << SBIT_IOC_DO2_SHIFT) & SBIT_IOC_DO2));
+
+	rb4xx_spi_wreg(SPI_REG_IOC, bval);
+	rb4xx_spi_wreg(SPI_REG_IOC, bval | SPI_IOC_CLK);
+}
+
+static inline void do_spi_byte_fast(uint8_t byte)
+{
+	do_spi_clk_fast(byte >> 7, byte >> 6);
+	do_spi_clk_fast(byte >> 5, byte >> 4);
+	do_spi_clk_fast(byte >> 3, byte >> 2);
+	do_spi_clk_fast(byte >> 1, byte >> 0);
+
+	DBG("spi_byte_fast sent 0x%02x got 0x%x\n",
+					byte, rb4xx_spi_rreg(SPI_REG_RDS));
+}
+#else
+static inline void do_spi_byte_fast(uint8_t byte)
+{
+	do_spi_byte(byte);
+}
+#endif /* USE_FAST_WRITE */
+
+static int do_spi_cmd(unsigned cmd, unsigned sendCnt, const uint8_t *sendData,
+		unsigned recvCnt, uint8_t *recvData,
+		const uint8_t *verifyData, int fastWrite)
+{
+	unsigned i;
+
+	DBG("SPI cmd 0x%x send %u recv %u\n", cmd, sendCnt, recvCnt);
+
+	rb4xx_spi_wreg(SPI_REG_FS, SPI_FS_GPIO);
+	rb4xx_spi_wreg(SPI_REG_CTRL, SPI_CTRL_FASTEST);
+
+	do_spi_byte(cmd);
+#if 0
+	if (cmd == CPLD_CMD_READ_FAST) {
+		do_spi_byte(0x80);
+		do_spi_byte(0);
+		do_spi_byte(0);
+	}
+#endif
+	for (i = 0; i < sendCnt; ++i) {
+		if (fastWrite)
+			do_spi_byte_fast(sendData[i]);
+		else
+			do_spi_byte(sendData[i]);
+	}
+
+	for (i = 0; i < recvCnt; ++i) {
+		if (fastWrite)
+			do_spi_byte_fast(0);
+		else
+			do_spi_byte(0);
+
+		if (recvData) {
+			recvData[i] = rb4xx_spi_rreg(SPI_REG_RDS) & 0xff;
+		} else if (verifyData) {
+			if (verifyData[i] != (rb4xx_spi_rreg(SPI_REG_RDS)
+							 & 0xff))
+				break;
+		}
+	}
+
+	rb4xx_spi_wreg(SPI_REG_IOC, SBIT_IOC_BASE | SPI_IOC_CS0);
+	rb4xx_spi_wreg(SPI_REG_CTRL, spi_ctrl_flash);
+	rb4xx_spi_wreg(SPI_REG_FS, 0);
+
+	return i == recvCnt;
+}
+
+static int got_write = 1;
+
+static void rb4xx_nand_write_data(const uint8_t *byte, unsigned cnt)
+{
+	do_spi_cmd(CPLD_CMD_WRITE_MULT, cnt, byte, 1, NULL, NULL, 1);
+	got_write = 1;
+}
+
+static void rb4xx_nand_write_byte(uint8_t byte)
+{
+	rb4xx_nand_write_data(&byte, 1);
+}
+
+#if USE_FAST_READ
+static uint8_t *rb4xx_nand_read_getaddr(unsigned cnt)
+{
+	static unsigned nboffset = 0x100000;
+	unsigned addr;
+
+	if (got_write) {
+		nboffset = (nboffset + 31) & ~31;
+		if (nboffset >= 0x100000)	/* 1MB */
+			nboffset = 0;
+
+		got_write = 0;
+		rb4xx_spi_wreg(SPI_REG_FS, SPI_FS_GPIO);
+		rb4xx_spi_wreg(SPI_REG_CTRL, spi_ctrl_fread);
+		rb4xx_spi_wreg(SPI_REG_FS, 0);
+	}
+
+	addr = KSEG1ADDR(AR71XX_SPI_BASE + SPI_NDATA_BASE) + nboffset;
+	DBG("rb4xx_nand_read_getaddr 0x%x cnt 0x%x\n", addr, cnt);
+
+	nboffset += cnt;
+	return (uint8_t *)addr;
+}
+
+static void rb4xx_nand_read_data(uint8_t *buf, unsigned cnt)
+{
+	unsigned size32 = cnt & ~31;
+	unsigned remain = cnt & 31;
+
+	if (size32) {
+		uint8_t *addr = rb4xx_nand_read_getaddr(size32);
+		memcpy(buf, (void *)addr, size32);
+	}
+
+	if (remain) {
+		do_spi_cmd(CPLD_CMD_READ_MULT, 1, buf, remain,
+			   buf + size32, NULL, 0);
+	}
+}
+
+static int rb4xx_nand_verify_data(const uint8_t *buf, unsigned cnt)
+{
+	unsigned size32 = cnt & ~31;
+	unsigned remain = cnt & 31;
+
+	if (size32) {
+		uint8_t *addr = rb4xx_nand_read_getaddr(size32);
+		if (memcmp(buf, (void *)addr, size32) != 0)
+			return 0;
+	}
+
+	if (remain) {
+		return do_spi_cmd(CPLD_CMD_READ_MULT, 1, buf, remain,
+				  NULL, buf + size32, 0);
+	}
+	return 1;
+}
+#else /* USE_FAST_READ */
+static void rb4xx_nand_read_data(uint8_t *buf, unsigned cnt)
+{
+	do_spi_cmd(CPLD_CMD_READ_MULT, 1, buf, cnt, buf, NULL, 0);
+}
+
+static int rb4xx_nand_verify_data(const uint8_t *buf, unsigned cnt)
+{
+	return do_spi_cmd(CPLD_CMD_READ_MULT, 1, buf, cnt, NULL, buf, 0);
+}
+#endif /* USE_FAST_READ */
+
+static void rb4xx_nand_write_cfg(uint8_t byte)
+{
+	do_spi_cmd(CPLD_CMD_WRITE_CFG, 1, &byte, 0, NULL, NULL, 0);
+	got_write = 1;
+}
+
+static int rb4xx_nand_dev_ready(struct mtd_info *mtd)
+{
+	return gpio_get_value(RB4XX_NAND_GPIO_RDY);
+}
+
+static void rb4xx_nand_cmd_ctrl(struct mtd_info *mtd, int cmd,
+				unsigned int ctrl)
+{
+	if (ctrl & NAND_CTRL_CHANGE) {
+		uint8_t cfg = CFG_BIT_nLEDS;
+
+		cfg |= (ctrl & NAND_CLE) ? CFG_BIT_CLE : 0;
+		cfg |= (ctrl & NAND_ALE) ? CFG_BIT_ALE : 0;
+		cfg |= (ctrl & NAND_NCE) ? 0 : CFG_BIT_nCE;
+
+		rb4xx_nand_write_cfg(cfg);
+	}
+
+	if (cmd != NAND_CMD_NONE)
+		rb4xx_nand_write_byte(cmd);
+}
+
+static uint8_t rb4xx_nand_read_byte(struct mtd_info *mtd)
+{
+	uint8_t byte = 0;
+
+	rb4xx_nand_read_data(&byte, 1);
+	return byte;
+}
+
+static void rb4xx_nand_write_buf(struct mtd_info *mtd, const uint8_t *buf,
+				int len)
+{
+	rb4xx_nand_write_data(buf, len);
+}
+
+static void rb4xx_nand_read_buf(struct mtd_info *mtd, uint8_t *buf,
+				int len)
+{
+	rb4xx_nand_read_data(buf, len);
+}
+
+static int rb4xx_nand_verify_buf(struct mtd_info *mtd, const uint8_t *buf,
+				int len)
+{
+	if (!rb4xx_nand_verify_data(buf, len))
+		return -EFAULT;
+
+	return 0;
+}
+
+static unsigned get_spi_ctrl(unsigned hz_max, const char *name)
+{
+	unsigned div;
+
+	div = (ar71xx_ahb_freq - 1) / (2 * hz_max);
+	/*
+	 * CPU has a bug at (div == 0) - first bit read is random
+	 */
+	if (div == 0)
+		++div;
+
+	if (name) {
+		unsigned ahb_khz = (ar71xx_ahb_freq + 500) / 1000;
+		unsigned div_real = 2 * (div + 1);
+		printk(KERN_INFO "%s SPI clock %u kHz (AHB %u kHz / %u)\n",
+		       name,
+		       ahb_khz / div_real,
+		       ahb_khz, div_real);
+	}
+
+	return SPI_CTRL_FASTEST + div;
+}
+
+static int __init rb4xx_nand_probe(struct platform_device *pdev)
+{
+	struct rb4xx_nand_info	*info;
+	int ret;
+
+	printk(KERN_INFO DRV_DESC " version " DRV_VERSION "\n");
+
+	ret = gpio_request(RB4XX_NAND_GPIO_RDY, "NAND RDY");
+	if (ret) {
+		printk(KERN_ERR "rb4xx-nand: gpio request failed\n");
+		return ret;
+	}
+
+	ret = gpio_direction_input(RB4XX_NAND_GPIO_RDY);
+	if (ret) {
+		printk(KERN_ERR "rb4xx-nand: unable to set input mode "
+					"on gpio%d\n", RB4XX_NAND_GPIO_RDY);
+		goto err_free_gpio;
+	}
+
+	info = kzalloc(sizeof(*info), GFP_KERNEL);
+	if (!info) {
+		printk(KERN_ERR "rb4xx-nand: no memory for private data\n");
+		ret = -ENOMEM;
+		goto err_free_gpio;
+	}
+
+#if USE_FAST_READ
+	spi_ctrl_fread = get_spi_ctrl(RB4XX_NAND_HZ, "NAND");
+#endif
+	spi_ctrl_flash = get_spi_ctrl(RB4XX_FLASH_HZ, "FLASH");
+
+	rb4xx_nand_write_cfg(CFG_BIT_nLEDS | CFG_BIT_nCE);
+
+	info->chip.priv	= &info;
+	info->mtd.priv	= &info->chip;
+	info->mtd.owner	= THIS_MODULE;
+
+	info->chip.cmd_ctrl	= rb4xx_nand_cmd_ctrl;
+	info->chip.dev_ready	= rb4xx_nand_dev_ready;
+	info->chip.read_byte	= rb4xx_nand_read_byte;
+	info->chip.write_buf	= rb4xx_nand_write_buf;
+	info->chip.read_buf	= rb4xx_nand_read_buf;
+	info->chip.verify_buf	= rb4xx_nand_verify_buf;
+
+	info->chip.chip_delay	= 25;
+	info->chip.ecc.mode	= NAND_ECC_SOFT;
+	info->chip.options	|= NAND_NO_AUTOINCR;
+
+	platform_set_drvdata(pdev, info);
+
+	ret = nand_scan_ident(&info->mtd, 1);
+	if (ret) {
+		ret = -ENXIO;
+		goto err_free_info;
+	}
+
+	if (info->mtd.writesize == 512)
+		info->chip.ecc.layout = &rb4xx_nand_ecclayout;
+
+	ret = nand_scan_tail(&info->mtd);
+	if (ret) {
+		return -ENXIO;
+		goto err_set_drvdata;
+	}
+
+#ifdef CONFIG_MTD_PARTITIONS
+	ret = add_mtd_partitions(&info->mtd, rb4xx_nand_partitions,
+				ARRAY_SIZE(rb4xx_nand_partitions));
+#else
+	ret = add_mtd_device(&info->mtd);
+#endif
+	if (ret)
+		goto err_release_nand;
+
+	return 0;
+
+err_release_nand:
+	nand_release(&info->mtd);
+err_set_drvdata:
+	platform_set_drvdata(pdev, NULL);
+err_free_info:
+	kfree(info);
+err_free_gpio:
+	gpio_free(RB4XX_NAND_GPIO_RDY);
+	return ret;
+}
+
+static int __devexit rb4xx_nand_remove(struct platform_device *pdev)
+{
+	struct rb4xx_nand_info *info = platform_get_drvdata(pdev);
+
+	nand_release(&info->mtd);
+	platform_set_drvdata(pdev, NULL);
+	kfree(info);
+
+	return 0;
+}
+
+static struct platform_driver rb4xx_nand_driver = {
+	.probe	= rb4xx_nand_probe,
+	.remove	= __devexit_p(rb4xx_nand_remove),
+	.driver	= {
+		.name	= DRV_NAME,
+		.owner	= THIS_MODULE,
+	},
+};
+
+static int __init rb4xx_nand_init(void)
+{
+	return platform_driver_register(&rb4xx_nand_driver);
+}
+
+static void __exit rb4xx_nand_exit(void)
+{
+	platform_driver_unregister(&rb4xx_nand_driver);
+}
+
+module_init(rb4xx_nand_init);
+module_exit(rb4xx_nand_exit);
+
+MODULE_DESCRIPTION(DRV_DESC);
+MODULE_VERSION(DRV_VERSION);
+MODULE_AUTHOR("Gabor Juhos <juhosg@openwrt.org>");
+MODULE_AUTHOR("Imre Kaloz <kaloz@openwrt.org>");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/mtd/nand/rb750_nand.c b/drivers/mtd/nand/rb750_nand.c
new file mode 100644
index 0000000..a80e5df
--- /dev/null
+++ b/drivers/mtd/nand/rb750_nand.c
@@ -0,0 +1,360 @@
+/*
+ *  NAND flash driver for the MikroTik RouterBOARD 750
+ *
+ *  Copyright (C) 2010 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/init.h>
+#include <linux/mtd/nand.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <linux/platform_device.h>
+#include <linux/io.h>
+
+#include <asm/mach-ar71xx/ar71xx.h>
+#include <asm/mach-ar71xx/mach-rb750.h>
+
+#define DRV_NAME	"rb750-nand"
+#define DRV_VERSION	"0.1.0"
+#define DRV_DESC	"NAND flash driver for the RouterBOARD 750"
+
+#define RB750_NAND_IO0		BIT(RB750_GPIO_NAND_IO0)
+#define RB750_NAND_ALE		BIT(RB750_GPIO_NAND_ALE)
+#define RB750_NAND_CLE		BIT(RB750_GPIO_NAND_CLE)
+#define RB750_NAND_NRE		BIT(RB750_GPIO_NAND_NRE)
+#define RB750_NAND_NWE		BIT(RB750_GPIO_NAND_NWE)
+#define RB750_NAND_RDY		BIT(RB750_GPIO_NAND_RDY)
+#define RB750_NAND_NCE		BIT(RB750_GPIO_NAND_NCE)
+
+#define RB750_NAND_DATA_SHIFT	1
+#define RB750_NAND_DATA_BITS	(0xff << RB750_NAND_DATA_SHIFT)
+#define RB750_NAND_INPUT_BITS	(RB750_NAND_DATA_BITS | RB750_NAND_RDY)
+#define RB750_NAND_OUTPUT_BITS	(RB750_NAND_ALE | RB750_NAND_CLE | \
+				 RB750_NAND_NRE | RB750_NAND_NWE | \
+				 RB750_NAND_NCE)
+
+struct rb750_nand_info {
+	struct nand_chip	chip;
+	struct mtd_info		mtd;
+};
+
+/*
+ * We need to use the OLD Yaffs-1 OOB layout, otherwise the RB bootloader
+ * will not be able to find the kernel that we load.
+ */
+static struct nand_ecclayout rb750_nand_ecclayout = {
+	.eccbytes	= 6,
+	.eccpos		= { 8, 9, 10, 13, 14, 15 },
+	.oobavail	= 9,
+	.oobfree	= { { 0, 4 }, { 6, 2 }, { 11, 2 }, { 4, 1 } }
+};
+
+static struct mtd_partition rb750_nand_partitions[] = {
+	{
+		.name	= "booter",
+		.offset	= 0,
+		.size	= (256 * 1024),
+		.mask_flags = MTD_WRITEABLE,
+	}, {
+		.name	= "kernel",
+		.offset	= (256 * 1024),
+		.size	= (4 * 1024 * 1024) - (256 * 1024),
+	}, {
+		.name	= "rootfs",
+		.offset	= MTDPART_OFS_NXTBLK,
+		.size	= MTDPART_SIZ_FULL,
+	},
+};
+
+static void rb750_nand_write(const u8 *buf, unsigned len)
+{
+	void __iomem *base = ar71xx_gpio_base;
+	u32 out;
+	unsigned i;
+
+	/* set data lines to output mode */
+	__raw_writel(__raw_readl(base + GPIO_REG_OE) | RB750_NAND_DATA_BITS,
+		     base + GPIO_REG_OE);
+
+	out = __raw_readl(base + GPIO_REG_OUT);
+	out &= ~(RB750_NAND_DATA_BITS | RB750_NAND_NWE);
+	for (i = 0; i != len; i++) {
+		u32 data;
+
+		data = buf[i];
+		data <<= RB750_NAND_DATA_SHIFT;
+		data |= out;
+		__raw_writel(data, base + GPIO_REG_OUT);
+
+		__raw_writel(data | RB750_NAND_NWE, base + GPIO_REG_OUT);
+		/* flush write */
+		__raw_readl(base + GPIO_REG_OUT);
+	}
+
+	/* set data lines to input mode */
+	__raw_writel(__raw_readl(base + GPIO_REG_OE) & ~RB750_NAND_DATA_BITS,
+		     base + GPIO_REG_OE);
+	/* flush write */
+	__raw_readl(base + GPIO_REG_OE);
+}
+
+static int rb750_nand_read_verify(u8 *read_buf, unsigned len,
+				  const u8 *verify_buf)
+{
+	void __iomem *base = ar71xx_gpio_base;
+	unsigned i;
+
+	for (i = 0; i < len; i++) {
+		u8 data;
+
+		/* activate RE line */
+		__raw_writel(RB750_NAND_NRE, base + GPIO_REG_CLEAR);
+		/* flush write */
+		__raw_readl(base + GPIO_REG_CLEAR);
+
+		/* read input lines */
+		data = __raw_readl(base + GPIO_REG_IN) >> RB750_NAND_DATA_SHIFT;
+
+		/* deactivate RE line */
+		__raw_writel(RB750_NAND_NRE, base + GPIO_REG_SET);
+
+		if (read_buf)
+			read_buf[i] = data;
+		else if (verify_buf && verify_buf[i] != data)
+			return -EFAULT;
+	}
+
+	return 0;
+}
+
+static void rb750_nand_select_chip(struct mtd_info *mtd, int chip)
+{
+	void __iomem *base = ar71xx_gpio_base;
+	u32 func;
+
+	func = __raw_readl(base + GPIO_REG_FUNC);
+	if (chip >= 0) {
+		/* disable latch */
+		rb750_latch_change(RB750_LVC573_LE, 0);
+
+		/* disable alternate functions */
+		ar71xx_gpio_function_setup(AR724X_GPIO_FUNC_JTAG_DISABLE,
+					   AR724X_GPIO_FUNC_SPI_EN);
+
+		/* set input mode for data lines */
+		__raw_writel(__raw_readl(base + GPIO_REG_OE) &
+			     ~RB750_NAND_INPUT_BITS,
+			     base + GPIO_REG_OE);
+
+		/* deactivate RE and WE lines */
+		__raw_writel(RB750_NAND_NRE | RB750_NAND_NWE,
+			     base + GPIO_REG_SET);
+		/* flush write */
+		(void) __raw_readl(base + GPIO_REG_SET);
+
+		/* activate CE line */
+		__raw_writel(RB750_NAND_NCE, base + GPIO_REG_CLEAR);
+	} else {
+		/* deactivate CE line */
+		__raw_writel(RB750_NAND_NCE, base + GPIO_REG_SET);
+		/* flush write */
+		(void) __raw_readl(base + GPIO_REG_SET);
+
+		__raw_writel(__raw_readl(base + GPIO_REG_OE) |
+			     RB750_NAND_IO0 | RB750_NAND_RDY,
+			     base + GPIO_REG_OE);
+
+		/* restore alternate functions */
+		ar71xx_gpio_function_setup(AR724X_GPIO_FUNC_SPI_EN,
+					   AR724X_GPIO_FUNC_JTAG_DISABLE);
+
+		/* enable latch */
+		rb750_latch_change(0, RB750_LVC573_LE);
+	}
+}
+
+static int rb750_nand_dev_ready(struct mtd_info *mtd)
+{
+	void __iomem *base = ar71xx_gpio_base;
+
+	return !!(__raw_readl(base + GPIO_REG_IN) & RB750_NAND_RDY);
+}
+
+static void rb750_nand_cmd_ctrl(struct mtd_info *mtd, int cmd,
+				unsigned int ctrl)
+{
+	if (ctrl & NAND_CTRL_CHANGE) {
+		void __iomem *base = ar71xx_gpio_base;
+		u32 t;
+
+		t = __raw_readl(base + GPIO_REG_OUT);
+
+		t &= ~(RB750_NAND_CLE | RB750_NAND_ALE);
+		t |= (ctrl & NAND_CLE) ? RB750_NAND_CLE : 0;
+		t |= (ctrl & NAND_ALE) ? RB750_NAND_ALE : 0;
+
+		__raw_writel(t, base + GPIO_REG_OUT);
+		/* flush write */
+		__raw_readl(base + GPIO_REG_OUT);
+	}
+
+	if (cmd != NAND_CMD_NONE) {
+		u8 t = cmd;
+		rb750_nand_write(&t, 1);
+	}
+}
+
+static u8 rb750_nand_read_byte(struct mtd_info *mtd)
+{
+	u8 data = 0;
+	rb750_nand_read_verify(&data, 1, NULL);
+	return data;
+}
+
+static void rb750_nand_read_buf(struct mtd_info *mtd, u8 *buf, int len)
+{
+	rb750_nand_read_verify(buf, len, NULL);
+}
+
+static void rb750_nand_write_buf(struct mtd_info *mtd, const u8 *buf, int len)
+{
+	rb750_nand_write(buf, len);
+}
+
+static int rb750_nand_verify_buf(struct mtd_info *mtd, const u8 *buf, int len)
+{
+	return rb750_nand_read_verify(NULL, len, buf);
+}
+
+static void __init rb750_nand_gpio_init(void)
+{
+	void __iomem *base = ar71xx_gpio_base;
+	u32 out;
+
+	out = __raw_readl(base + GPIO_REG_OUT);
+
+	/* setup output levels */
+	__raw_writel(RB750_NAND_NCE | RB750_NAND_NRE | RB750_NAND_NWE,
+		     base + GPIO_REG_SET);
+
+	__raw_writel(RB750_NAND_ALE | RB750_NAND_CLE,
+		     base + GPIO_REG_CLEAR);
+
+	/* setup input lines */
+	__raw_writel(__raw_readl(base + GPIO_REG_OE) & ~(RB750_NAND_INPUT_BITS),
+		     base + GPIO_REG_OE);
+
+	/* setup output lines */
+	__raw_writel(__raw_readl(base + GPIO_REG_OE) | RB750_NAND_OUTPUT_BITS,
+		     base + GPIO_REG_OE);
+
+	rb750_latch_change(~out & RB750_NAND_IO0, out & RB750_NAND_IO0);
+}
+
+static int __init rb750_nand_probe(struct platform_device *pdev)
+{
+	struct rb750_nand_info	*info;
+	int ret;
+
+	printk(KERN_INFO DRV_DESC " version " DRV_VERSION "\n");
+
+	rb750_nand_gpio_init();
+
+	info = kzalloc(sizeof(*info), GFP_KERNEL);
+	if (!info)
+		return -ENOMEM;
+
+	info->chip.priv	= &info;
+	info->mtd.priv	= &info->chip;
+	info->mtd.owner	= THIS_MODULE;
+
+	info->chip.select_chip	= rb750_nand_select_chip;
+	info->chip.cmd_ctrl	= rb750_nand_cmd_ctrl;
+	info->chip.dev_ready	= rb750_nand_dev_ready;
+	info->chip.read_byte	= rb750_nand_read_byte;
+	info->chip.write_buf	= rb750_nand_write_buf;
+	info->chip.read_buf	= rb750_nand_read_buf;
+	info->chip.verify_buf	= rb750_nand_verify_buf;
+
+	info->chip.chip_delay	= 25;
+	info->chip.ecc.mode	= NAND_ECC_SOFT;
+	info->chip.options	|= NAND_NO_AUTOINCR;
+
+	platform_set_drvdata(pdev, info);
+
+	ret = nand_scan_ident(&info->mtd, 1);
+	if (ret) {
+		ret = -ENXIO;
+		goto err_free_info;
+	}
+
+	if (info->mtd.writesize == 512)
+		info->chip.ecc.layout = &rb750_nand_ecclayout;
+
+	ret = nand_scan_tail(&info->mtd);
+	if (ret) {
+		return -ENXIO;
+		goto err_set_drvdata;
+	}
+
+#ifdef CONFIG_MTD_PARTITIONS
+	ret = add_mtd_partitions(&info->mtd, rb750_nand_partitions,
+				 ARRAY_SIZE(rb750_nand_partitions));
+#else
+	ret = add_mtd_device(&info->mtd);
+#endif
+	if (ret)
+		goto err_release_nand;
+
+	return 0;
+
+ err_release_nand:
+	nand_release(&info->mtd);
+ err_set_drvdata:
+	platform_set_drvdata(pdev, NULL);
+ err_free_info:
+	kfree(info);
+	return ret;
+}
+
+static int __devexit rb750_nand_remove(struct platform_device *pdev)
+{
+	struct rb750_nand_info *info = platform_get_drvdata(pdev);
+
+	nand_release(&info->mtd);
+	platform_set_drvdata(pdev, NULL);
+	kfree(info);
+
+	return 0;
+}
+
+static struct platform_driver rb750_nand_driver = {
+	.probe	= rb750_nand_probe,
+	.remove	= __devexit_p(rb750_nand_remove),
+	.driver	= {
+		.name	= DRV_NAME,
+		.owner	= THIS_MODULE,
+	},
+};
+
+static int __init rb750_nand_init(void)
+{
+	return platform_driver_register(&rb750_nand_driver);
+}
+
+static void __exit rb750_nand_exit(void)
+{
+	platform_driver_unregister(&rb750_nand_driver);
+}
+
+module_init(rb750_nand_init);
+module_exit(rb750_nand_exit);
+
+MODULE_DESCRIPTION(DRV_DESC);
+MODULE_VERSION(DRV_VERSION);
+MODULE_AUTHOR("Gabor Juhos <juhosg@openwrt.org>");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/mtd/wrt160nl_part.c b/drivers/mtd/wrt160nl_part.c
new file mode 100644
index 0000000..e42b3d4
--- /dev/null
+++ b/drivers/mtd/wrt160nl_part.c
@@ -0,0 +1,181 @@
+/*
+ * Copyright (C) 2009 Christian Daniel <cd@maintech.de>
+ * Copyright (C) 2009 Gabor Juhos <juhosg@openwrt.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ * TRX flash partition table.
+ * Based on ar7 map by Felix Fietkau <nbd@openwrt.org>
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+
+struct cybertan_header {
+	char	magic[4];
+	u8	res1[4];
+	char	fw_date[3];
+	char	fw_ver[3];
+	char	id[4];
+	char	hw_ver;
+	char	unused;
+	u8	flags[2];
+	u8	res2[10];
+};
+
+#define TRX_PARTS	6
+#define TRX_MAGIC	0x30524448
+#define TRX_MAX_OFFSET	3
+
+struct trx_header {
+	uint32_t magic;           /* "HDR0" */
+	uint32_t len;             /* Length of file including header */
+	uint32_t crc32;           /* 32-bit CRC from flag_version to end of file */
+	uint32_t flag_version;    /* 0:15 flags, 16:31 version */
+	uint32_t offsets[TRX_MAX_OFFSET]; /* Offsets of partitions from start of header */
+};
+
+#define IH_MAGIC	0x27051956	/* Image Magic Number */
+#define IH_NMLEN	32		/* Image Name Length */
+
+struct uimage_header {
+	uint32_t	ih_magic;	/* Image Header Magic Number */
+	uint32_t	ih_hcrc;	/* Image Header CRC Checksum */
+	uint32_t	ih_time;	/* Image Creation Timestamp */
+	uint32_t	ih_size;	/* Image Data Size */
+	uint32_t	ih_load;	/* DataÂ» Load  Address */
+	uint32_t	ih_ep;		/* Entry Point Address */
+	uint32_t	ih_dcrc;	/* Image Data CRC Checksum */
+	uint8_t		ih_os;		/* Operating System */
+	uint8_t		ih_arch;	/* CPU architecture */
+	uint8_t		ih_type;	/* Image Type */
+	uint8_t		ih_comp;	/* Compression Type */
+	uint8_t		ih_name[IH_NMLEN];	/* Image Name */
+};
+
+struct wrt160nl_header {
+	struct cybertan_header	cybertan;
+	struct trx_header	trx;
+	struct uimage_header	uimage;
+} __attribute__ ((packed));
+
+static struct mtd_partition trx_parts[TRX_PARTS];
+
+static int wrt160nl_parse_partitions(struct mtd_info *master,
+				     struct mtd_partition **pparts,
+				     unsigned long origin)
+{
+	struct wrt160nl_header *header;
+	struct trx_header *theader;
+	struct uimage_header *uheader;
+	size_t retlen;
+	unsigned int kernel_len;
+	int ret;
+
+	header = vmalloc(sizeof(*header));
+	if (!header) {
+		return -ENOMEM;
+		goto out;
+	}
+
+	ret = master->read(master, 4 * master->erasesize, sizeof(*header),
+			   &retlen, (void *) header);
+	if (ret)
+		goto free_hdr;
+
+	if (retlen != sizeof(*header)) {
+		ret = -EIO;
+		goto free_hdr;
+	}
+
+	if (strncmp(header->cybertan.magic, "NL16", 4) != 0) {
+		printk(KERN_NOTICE "%s: no WRT160NL signature found\n",
+			master->name);
+		goto free_hdr;
+	}
+
+	theader = &header->trx;
+	if (le32_to_cpu(theader->magic) != TRX_MAGIC) {
+		printk(KERN_NOTICE "%s: no TRX header found\n", master->name);
+		goto free_hdr;
+	}
+
+	uheader = &header->uimage;
+	if (uheader->ih_magic != IH_MAGIC) {
+		printk(KERN_NOTICE "%s: no uImage found\n", master->name);
+		goto free_hdr;
+	}
+
+	kernel_len = le32_to_cpu(theader->offsets[1]) + sizeof(struct cybertan_header);
+
+	trx_parts[0].name = "u-boot";
+	trx_parts[0].offset = 0;
+	trx_parts[0].size = 4 * master->erasesize;
+	trx_parts[0].mask_flags = MTD_WRITEABLE;
+
+	trx_parts[1].name = "kernel";
+	trx_parts[1].offset = trx_parts[0].offset + trx_parts[0].size;
+	trx_parts[1].size = kernel_len;
+	trx_parts[1].mask_flags = 0;
+
+	trx_parts[2].name = "rootfs";
+	trx_parts[2].offset = trx_parts[1].offset + trx_parts[1].size;
+	trx_parts[2].size = master->size - 6 * master->erasesize - trx_parts[1].size;
+	trx_parts[2].mask_flags = 0;
+
+	trx_parts[3].name = "nvram";
+	trx_parts[3].offset = master->size - 2 * master->erasesize;
+	trx_parts[3].size = master->erasesize;
+	trx_parts[3].mask_flags = MTD_WRITEABLE;
+
+	trx_parts[4].name = "art";
+	trx_parts[4].offset = master->size - master->erasesize;
+	trx_parts[4].size = master->erasesize;
+	trx_parts[4].mask_flags = MTD_WRITEABLE;
+
+	trx_parts[5].name = "firmware";
+	trx_parts[5].offset = 4 * master->erasesize;
+	trx_parts[5].size = master->size - 6 * master->erasesize;
+	trx_parts[5].mask_flags = 0;
+
+	*pparts = trx_parts;
+	ret = TRX_PARTS;
+
+ free_hdr:
+	vfree(header);
+ out:
+	return ret;
+}
+
+static struct mtd_part_parser wrt160nl_parser = {
+	.owner		= THIS_MODULE,
+	.parse_fn	= wrt160nl_parse_partitions,
+	.name		= "wrt160nl",
+};
+
+static int __init wrt160nl_parser_init(void)
+{
+	return register_mtd_parser(&wrt160nl_parser);
+}
+
+module_init(wrt160nl_parser_init);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Christian Daniel <cd@maintech.de>");
