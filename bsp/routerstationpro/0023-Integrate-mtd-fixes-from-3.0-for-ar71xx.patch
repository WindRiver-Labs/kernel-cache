From a014fd41e4b7a9c49dcc162bdaba2989ba90bd04 Mon Sep 17 00:00:00 2001
From: Zumeng Chen <zumeng.chen@windriver.com>
Date: Mon, 5 Dec 2011 11:03:37 +0800
Subject: [PATCH 23/41] Integrate mtd fixes from 3.0 for ar71xx

which from the following git repo.
  git://nbd.name/openwrt.git

   400-rootfs_split.patch
   401-partial_eraseblock_write.patch
   410-mtd_info_move_forward_decl.patch
   420-redboot_space.patch
   421-redboot_boardconfig.patch
   430-mtd_myloader_partition_parser.patch
   440-block2mtd_init.patch
   441-block2mtd_refresh.patch
   442-block2mtd_probe.patch
   450-mtd_plat_nand_chip_fixup.patch
   451-mtd_fix_nand_correct_data_return_code.patch
   460-cfi_cmdset_0002_no_erase_suspend.patch
   470-mtd_m25p80_add_pm25lv_flash_support.patch
   473-mtd_m25p80_add_w25q128.patch
   474-mtd_concat_sync_fix.patch
   475-mtd_cfi_cmdset_0002-add-buffer-write-cmd-timeout.patch

Integrated-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 drivers/mtd/Kconfig                 |   24 ++
 drivers/mtd/Makefile                |    1 +
 drivers/mtd/chips/cfi_cmdset_0002.c |   31 ++-
 drivers/mtd/chips/jedec_probe.c     |   13 +
 drivers/mtd/devices/block2mtd.c     |  216 ++++++++++++++-----
 drivers/mtd/devices/m25p80.c        |   42 +++-
 drivers/mtd/maps/ar91xx_flash.c     |    4 +-
 drivers/mtd/mtdchar.c               |    6 +
 drivers/mtd/mtdconcat.c             |    3 +-
 drivers/mtd/mtdpart.c               |  290 +++++++++++++++++++++++-
 drivers/mtd/myloader.c              |  178 +++++++++++++++
 drivers/mtd/nand/nand_ecc.c         |    3 +-
 drivers/mtd/nand/plat_nand.c        |   13 +-
 drivers/mtd/nand/rb4xx_nand.c       |  416 +++++++++-------------------------
 drivers/mtd/nand/rb750_nand.c       |   85 ++++----
 drivers/mtd/redboot.c               |   39 +++-
 drivers/mtd/wrt160nl_part.c         |   33 ++-
 fs/partitions/check.c               |    1 +
 include/linux/mtd/mtd.h             |    9 +
 include/linux/mtd/nand.h            |    1 +
 include/linux/mtd/partitions.h      |    4 +-
 include/mtd/mtd-abi.h               |    1 +
 22 files changed, 954 insertions(+), 459 deletions(-)
 create mode 100644 drivers/mtd/myloader.c

diff --git a/drivers/mtd/Kconfig b/drivers/mtd/Kconfig
index 6a87dc0..49686c3 100644
--- a/drivers/mtd/Kconfig
+++ b/drivers/mtd/Kconfig
@@ -33,6 +33,14 @@ config MTD_TESTS
 	  should normally be compiled as kernel modules. The modules perform
 	  various checks and verifications when loaded.
 
+config MTD_ROOTFS_ROOT_DEV
+	bool "Automatically set 'rootfs' partition to be root filesystem"
+	default y
+
+config MTD_ROOTFS_SPLIT
+	bool "Automatically split 'rootfs' partition for squashfs"
+	default y
+
 config MTD_REDBOOT_PARTS
 	tristate "RedBoot partition table parsing"
 	---help---
@@ -155,6 +163,22 @@ config MTD_WRT160NL_PARTS
 	---help---
 	   Linksys WRT160NL partitioning support
 
+config MTD_MYLOADER_PARTS
+	tristate "MyLoader partition parsing"
+	depends on ADM5120 || ATHEROS_AR231X || ATHEROS_AR71XX
+	---help---
+	  MyLoader is a bootloader which allows the user to define partitions
+	  in flash devices, by putting a table in the second erase block
+	  on the device, similar to a partition table. This table gives the
+	  offsets and lengths of the user defined partitions.
+
+	  If you need code which can detect and parse these tables, and
+	  register MTD 'partitions' corresponding to each image detected,
+	  enable this option.
+
+	  You will still need the parsing functions to be called by the driver
+	  for your particular device. It won't happen automatically.
+
 comment "User Modules And Translation Layers"
 
 config MTD_CHAR
diff --git a/drivers/mtd/Makefile b/drivers/mtd/Makefile
index bf22fda..a8ad2dd 100644
--- a/drivers/mtd/Makefile
+++ b/drivers/mtd/Makefile
@@ -12,6 +12,7 @@ obj-$(CONFIG_MTD_CMDLINE_PARTS) += cmdlinepart.o
 obj-$(CONFIG_MTD_AFS_PARTS)	+= afs.o
 obj-$(CONFIG_MTD_AR7_PARTS)	+= ar7part.o
 obj-$(CONFIG_MTD_WRT160NL_PARTS) += wrt160nl_part.o
+obj-$(CONFIG_MTD_MYLOADER_PARTS) += myloader.o
 
 # 'Users' - code which presents functionality to userspace.
 obj-$(CONFIG_MTD_CHAR)		+= mtdchar.o
diff --git a/drivers/mtd/chips/cfi_cmdset_0002.c b/drivers/mtd/chips/cfi_cmdset_0002.c
index 23175ed..103ce00 100644
--- a/drivers/mtd/chips/cfi_cmdset_0002.c
+++ b/drivers/mtd/chips/cfi_cmdset_0002.c
@@ -39,7 +39,11 @@
 #include <linux/mtd/xip.h>
 
 #define AMD_BOOTLOC_BUG
+#ifdef CONFIG_ATHEROS_AR71XX
+#define FORCE_WORD_WRITE 1 
+#else
 #define FORCE_WORD_WRITE 0
+#endif
 
 #define MAX_WORD_RETRIES 3
 
@@ -50,7 +54,9 @@
 
 static int cfi_amdstd_read (struct mtd_info *, loff_t, size_t, size_t *, u_char *);
 static int cfi_amdstd_write_words(struct mtd_info *, loff_t, size_t, size_t *, const u_char *);
+#if !FORCE_WORD_WRITE
 static int cfi_amdstd_write_buffers(struct mtd_info *, loff_t, size_t, size_t *, const u_char *);
+#endif
 static int cfi_amdstd_erase_chip(struct mtd_info *, struct erase_info *);
 static int cfi_amdstd_erase_varsize(struct mtd_info *, struct erase_info *);
 static void cfi_amdstd_sync (struct mtd_info *);
@@ -186,6 +192,7 @@ static void fixup_amd_bootblock(struct mtd_info *mtd)
 }
 #endif
 
+#if !FORCE_WORD_WRITE
 static void fixup_use_write_buffers(struct mtd_info *mtd)
 {
 	struct map_info *map = mtd->priv;
@@ -195,6 +202,7 @@ static void fixup_use_write_buffers(struct mtd_info *mtd)
 		mtd->write = cfi_amdstd_write_buffers;
 	}
 }
+#endif /* !FORCE_WORD_WRITE */
 
 /* Atmel chips don't use the same PRI format as AMD chips */
 static void fixup_convert_atmel_pri(struct mtd_info *mtd)
@@ -685,7 +693,7 @@ static int get_chip(struct map_info *map, struct flchip *chip, unsigned long adr
 		return 0;
 
 	case FL_ERASING:
-		if (!cfip || !(cfip->EraseSuspend & (0x1|0x2)) ||
+		if (1 /* no suspend */ || !cfip || !(cfip->EraseSuspend & (0x1|0x2)) ||
 		    !(mode == FL_READY || mode == FL_POINT ||
 		    (mode == FL_WRITING && (cfip->EraseSuspend & 0x2))))
 			goto sleep;
@@ -1217,8 +1225,8 @@ static int __xipram do_write_oneword(struct map_info *map, struct flchip *chip,
 			break;
 		}
 
-		if (chip_ready(map, adr))
-			break;
+		if (chip_good(map, adr, datum))
+			goto enable_xip;
 
 		/* Latency issues. Drop the lock, wait a while and retry */
 		UDELAY(map, chip, adr, 1);
@@ -1234,6 +1242,8 @@ static int __xipram do_write_oneword(struct map_info *map, struct flchip *chip,
 
 		ret = -EIO;
 	}
+
+ enable_xip:
 	xip_enable(map, chip, adr);
  op_done:
 	chip->state = FL_READY;
@@ -1375,6 +1385,7 @@ static int cfi_amdstd_write_words(struct mtd_info *mtd, loff_t to, size_t len,
 /*
  * FIXME: interleaved mode not tested, and probably not supported!
  */
+#if !FORCE_WORD_WRITE
 static int __xipram do_write_buffer(struct map_info *map, struct flchip *chip,
 				    unsigned long adr, const u_char *buf,
 				    int len)
@@ -1412,6 +1423,7 @@ static int __xipram do_write_buffer(struct map_info *map, struct flchip *chip,
 
 	/* Write Buffer Load */
 	map_write(map, CMD(0x25), cmd_adr);
+	(void) map_read(map, cmd_adr);
 
 	chip->state = FL_WRITING_TO_BUFFER;
 
@@ -1485,7 +1497,6 @@ static int __xipram do_write_buffer(struct map_info *map, struct flchip *chip,
 	return ret;
 }
 
-
 static int cfi_amdstd_write_buffers(struct mtd_info *mtd, loff_t to, size_t len,
 				    size_t *retlen, const u_char *buf)
 {
@@ -1564,7 +1575,7 @@ static int cfi_amdstd_write_buffers(struct mtd_info *mtd, loff_t to, size_t len,
 
 	return 0;
 }
-
+#endif /* !FORCE_WORD_WRITE */
 
 /*
  * Handle devices with one erase region, that only implement
@@ -1629,8 +1640,8 @@ static int __xipram do_erase_chip(struct map_info *map, struct flchip *chip)
 			chip->erase_suspended = 0;
 		}
 
-		if (chip_ready(map, adr))
-			break;
+		if (chip_good(map, adr, map_word_ff(map)))
+			goto op_done;
 
 		if (time_after(jiffies, timeo)) {
 			printk(KERN_WARNING "MTD %s(): software timeout\n",
@@ -1650,6 +1661,7 @@ static int __xipram do_erase_chip(struct map_info *map, struct flchip *chip)
 		ret = -EIO;
 	}
 
+ op_done:
 	chip->state = FL_READY;
 	xip_enable(map, chip, adr);
 	put_chip(map, chip, adr);
@@ -1717,9 +1729,9 @@ static int __xipram do_erase_oneblock(struct map_info *map, struct flchip *chip,
 			chip->erase_suspended = 0;
 		}
 
-		if (chip_ready(map, adr)) {
+		if (chip_good(map, adr, map_word_ff(map))) {
 			xip_enable(map, chip, adr);
-			break;
+			goto op_done;
 		}
 
 		if (time_after(jiffies, timeo)) {
@@ -1741,6 +1753,7 @@ static int __xipram do_erase_oneblock(struct map_info *map, struct flchip *chip,
 		ret = -EIO;
 	}
 
+ op_done:
 	chip->state = FL_READY;
 	put_chip(map, chip, adr);
 	mutex_unlock(&chip->mutex);
diff --git a/drivers/mtd/chips/jedec_probe.c b/drivers/mtd/chips/jedec_probe.c
index ea832ea..623b921 100644
--- a/drivers/mtd/chips/jedec_probe.c
+++ b/drivers/mtd/chips/jedec_probe.c
@@ -148,6 +148,7 @@
 #define SST39LF160	0x2782
 #define SST39VF1601	0x234b
 #define SST39VF3201	0x235b
+#define SST39VF6401B	0x236d
 #define SST39WF1601	0x274b
 #define SST39WF1602	0x274a
 #define SST39LF512	0x00D4
@@ -1568,6 +1569,18 @@ static const struct amd_flash_info jedec_table[] = {
 			ERASEINFO(0x10000,64),
 		}
 	}, {
+		.mfr_id         = CFI_MFR_SST,
+		.dev_id         = SST39VF6401B,
+		.name           = "SST 39VF6401B",
+		.devtypes       = CFI_DEVICETYPE_X16,
+		.uaddr          = MTD_UADDR_0xAAAA_0x5555,
+		.dev_size       = SIZE_8MiB,
+		.cmd_set        = P_ID_AMD_STD,
+		.nr_regions     = 1,
+		.regions        = {
+			ERASEINFO(0x10000,128)
+		}
+	}, {
 		.mfr_id		= CFI_MFR_ST,
 		.dev_id		= M29F800AB,
 		.name		= "ST M29F800AB",
diff --git a/drivers/mtd/devices/block2mtd.c b/drivers/mtd/devices/block2mtd.c
index b78f231..675aea4 100644
--- a/drivers/mtd/devices/block2mtd.c
+++ b/drivers/mtd/devices/block2mtd.c
@@ -14,6 +14,7 @@
 #include <linux/list.h>
 #include <linux/init.h>
 #include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
 #include <linux/buffer_head.h>
 #include <linux/mutex.h>
 #include <linux/mount.h>
@@ -29,6 +30,8 @@ struct block2mtd_dev {
 	struct block_device *blkdev;
 	struct mtd_info mtd;
 	struct mutex write_mutex;
+	rwlock_t bdev_mutex;
+	char devname[0];
 };
 
 
@@ -81,6 +84,12 @@ static int block2mtd_erase(struct mtd_info *mtd, struct erase_info *instr)
 	size_t len = instr->len;
 	int err;
 
+	read_lock(&dev->bdev_mutex);
+	if (!dev->blkdev) {
+		err = -EINVAL;
+		goto done;
+	}
+
 	instr->state = MTD_ERASING;
 	mutex_lock(&dev->write_mutex);
 	err = _block2mtd_erase(dev, from, len);
@@ -92,6 +101,10 @@ static int block2mtd_erase(struct mtd_info *mtd, struct erase_info *instr)
 		instr->state = MTD_ERASE_DONE;
 
 	mtd_erase_callback(instr);
+
+done:
+	read_unlock(&dev->bdev_mutex);
+
 	return err;
 }
 
@@ -103,10 +116,14 @@ static int block2mtd_read(struct mtd_info *mtd, loff_t from, size_t len,
 	struct page *page;
 	int index = from >> PAGE_SHIFT;
 	int offset = from & (PAGE_SIZE-1);
-	int cpylen;
+	int cpylen, err = 0;
+
+	read_lock(&dev->bdev_mutex);
+	if (!dev->blkdev || (from > mtd->size)) {
+		err = -EINVAL;
+		goto done;
+	}
 
-	if (from > mtd->size)
-		return -EINVAL;
 	if (from + len > mtd->size)
 		len = mtd->size - from;
 
@@ -121,10 +138,14 @@ static int block2mtd_read(struct mtd_info *mtd, loff_t from, size_t len,
 		len = len - cpylen;
 
 		page = page_read(dev->blkdev->bd_inode->i_mapping, index);
-		if (!page)
-			return -ENOMEM;
-		if (IS_ERR(page))
-			return PTR_ERR(page);
+		if (!page) {
+			err = -ENOMEM;
+			goto done;
+		}
+		if (IS_ERR(page)) {
+			err = PTR_ERR(page);
+			goto done;
+		}
 
 		memcpy(buf, page_address(page) + offset, cpylen);
 		page_cache_release(page);
@@ -135,7 +156,10 @@ static int block2mtd_read(struct mtd_info *mtd, loff_t from, size_t len,
 		offset = 0;
 		index++;
 	}
-	return 0;
+
+done:
+	read_unlock(&dev->bdev_mutex);
+	return err;
 }
 
 
@@ -187,12 +211,22 @@ static int block2mtd_write(struct mtd_info *mtd, loff_t to, size_t len,
 		size_t *retlen, const u_char *buf)
 {
 	struct block2mtd_dev *dev = mtd->priv;
-	int err;
+	int err = 0;
+
+	read_lock(&dev->bdev_mutex);
+	if (!dev->blkdev) {
+		err = -EINVAL;
+		goto done;
+	}
 
 	if (!len)
-		return 0;
-	if (to >= mtd->size)
-		return -ENOSPC;
+		goto done;
+
+	if (to >= mtd->size) {
+		err = -ENOSPC;
+		goto done;
+	}
+
 	if (to + len > mtd->size)
 		len = mtd->size - to;
 
@@ -201,6 +235,9 @@ static int block2mtd_write(struct mtd_info *mtd, loff_t to, size_t len,
 	mutex_unlock(&dev->write_mutex);
 	if (err > 0)
 		err = 0;
+
+done:
+	read_unlock(&dev->bdev_mutex);
 	return err;
 }
 
@@ -209,79 +246,142 @@ static int block2mtd_write(struct mtd_info *mtd, loff_t to, size_t len,
 static void block2mtd_sync(struct mtd_info *mtd)
 {
 	struct block2mtd_dev *dev = mtd->priv;
+	read_lock(&dev->bdev_mutex);
+	if (dev->blkdev)
 	sync_blockdev(dev->blkdev);
-	return;
-}
-
-
-static void block2mtd_free_device(struct block2mtd_dev *dev)
-{
-	if (!dev)
-		return;
-
-	kfree(dev->mtd.name);
-
-	if (dev->blkdev) {
-		invalidate_mapping_pages(dev->blkdev->bd_inode->i_mapping,
-					0, -1);
-		blkdev_put(dev->blkdev, FMODE_READ|FMODE_WRITE|FMODE_EXCL);
-	}
+	read_unlock(&dev->bdev_mutex);
 
-	kfree(dev);
+	return;
 }
 
 
-/* FIXME: ensure that mtd->size % erase_size == 0 */
-static struct block2mtd_dev *add_device(char *devname, int erase_size)
+static int _open_bdev(struct block2mtd_dev *dev)
 {
 	const fmode_t mode = FMODE_READ | FMODE_WRITE | FMODE_EXCL;
 	struct block_device *bdev;
-	struct block2mtd_dev *dev;
-	char *name;
-
-	if (!devname)
-		return NULL;
-
-	dev = kzalloc(sizeof(struct block2mtd_dev), GFP_KERNEL);
-	if (!dev)
-		return NULL;
 
 	/* Get a handle on the device */
-	bdev = blkdev_get_by_path(devname, mode, dev);
+	bdev = blkdev_get_by_path(dev->devname, mode, dev);
 #ifndef MODULE
 	if (IS_ERR(bdev)) {
+		dev_t devt;
 
 		/* We might not have rootfs mounted at this point. Try
 		   to resolve the device name by other means. */
 
-		dev_t devt = name_to_dev_t(devname);
+		wait_for_device_probe();
+		devt = name_to_dev_t(dev->devname);
 		if (devt)
 			bdev = blkdev_get_by_dev(devt, mode, dev);
 	}
 #endif
 
 	if (IS_ERR(bdev)) {
-		ERROR("error: cannot open device %s", devname);
-		goto devinit_err;
+		ERROR("error: cannot open device %s", dev->devname);
+		return 1;
 	}
 	dev->blkdev = bdev;
 
 	if (MAJOR(bdev->bd_dev) == MTD_BLOCK_MAJOR) {
 		ERROR("attempting to use an MTD device as a block device");
-		goto devinit_err;
+		return 1;
 	}
 
+	return 0;
+}
+
+static void _close_bdev(struct block2mtd_dev *dev)
+{
+	struct block_device *bdev;
+
+	if (!dev->blkdev)
+		return;
+
+	bdev = dev->blkdev;
+	invalidate_mapping_pages(dev->blkdev->bd_inode->i_mapping, 0, -1);
+	blkdev_put(dev->blkdev, FMODE_READ|FMODE_WRITE|FMODE_EXCL);
+	dev->blkdev = NULL;
+}
+
+static void block2mtd_free_device(struct block2mtd_dev *dev)
+{
+	if (!dev)
+		return;
+
+	kfree(dev->mtd.name);
+	_close_bdev(dev);
+	kfree(dev);
+}
+
+
+static int block2mtd_refresh(struct mtd_info *mtd)
+{
+	struct block2mtd_dev *dev = mtd->priv;
+	struct block_device *bdev;
+	dev_t devt;
+	int err = 0;
+
+	/* no other mtd function can run at this point */
+	write_lock(&dev->bdev_mutex);
+
+	/* get the device number for the whole disk */
+	devt = MKDEV(MAJOR(dev->blkdev->bd_dev), 0);
+
+	/* close the old block device */
+	_close_bdev(dev);
+
+	/* open the whole disk, issue a partition rescan, then */
+	bdev = blkdev_get_by_dev(devt, FMODE_WRITE | FMODE_READ, mtd);
+	if (!bdev || !bdev->bd_disk)
+		err = -EINVAL;
+#ifndef CONFIG_MTD_BLOCK2MTD_MODULE
+	else
+		err = rescan_partitions(bdev->bd_disk, bdev);
+#endif
+	if (bdev)
+		blkdev_put(bdev, FMODE_READ|FMODE_WRITE|FMODE_EXCL);
+
+	/* try to open the partition block device again */
+	_open_bdev(dev);
+	write_unlock(&dev->bdev_mutex);
+
+	return err;
+}
+
+/* FIXME: ensure that mtd->size % erase_size == 0 */
+static struct block2mtd_dev *add_device(char *devname, int erase_size, char *mtdname)
+{
+	struct block2mtd_dev *dev;
+	struct mtd_partition *part;
+	char *name;
+
+	if (!devname)
+		return NULL;
+
+	dev = kzalloc(sizeof(struct block2mtd_dev) + strlen(devname) + 1, GFP_KERNEL);
+	if (!dev)
+		return NULL;
+
+	strcpy(dev->devname, devname);
+
+	if (_open_bdev(dev))
+		goto devinit_err;
+
 	mutex_init(&dev->write_mutex);
+	rwlock_init(&dev->bdev_mutex);
 
 	/* Setup the MTD structure */
 	/* make the name contain the block device in */
-	name = kasprintf(GFP_KERNEL, "block2mtd: %s", devname);
+	if (!mtdname)
+		mtdname = devname;
+	name = kmalloc(strlen(mtdname) + 1, GFP_KERNEL);
 	if (!name)
 		goto devinit_err;
 
+	strcpy(name, mtdname);
 	dev->mtd.name = name;
 
-	dev->mtd.size = dev->blkdev->bd_inode->i_size & PAGE_MASK;
+	dev->mtd.size = dev->blkdev->bd_inode->i_size & PAGE_MASK & ~(erase_size - 1);
 	dev->mtd.erasesize = erase_size;
 	dev->mtd.writesize = 1;
 	dev->mtd.type = MTD_RAM;
@@ -293,15 +393,19 @@ static struct block2mtd_dev *add_device(char *devname, int erase_size)
 	dev->mtd.read = block2mtd_read;
 	dev->mtd.priv = dev;
 	dev->mtd.owner = THIS_MODULE;
+	dev->mtd.refresh_device = block2mtd_refresh;
 
-	if (mtd_device_register(&dev->mtd, NULL, 0)) {
+	part = kzalloc(sizeof(struct mtd_partition), GFP_KERNEL);
+	part->name = name;
+	part->offset = 0;
+	part->size = dev->mtd.size;
+	if (mtd_device_register(&dev->mtd, part, 1)) {
 		/* Device didn't get added, so free the entry */
 		goto devinit_err;
 	}
 	list_add(&dev->list, &blkmtd_device_list);
 	INFO("mtd%d: [%s] erase_size = %dKiB [%d]", dev->mtd.index,
-			dev->mtd.name + strlen("block2mtd: "),
-			dev->mtd.erasesize >> 10, dev->mtd.erasesize);
+			mtdname, dev->mtd.erasesize >> 10, dev->mtd.erasesize);
 	return dev;
 
 devinit_err:
@@ -374,9 +478,9 @@ static char block2mtd_paramline[80 + 12]; /* 80 for device, 12 for erase size */
 
 static int block2mtd_setup2(const char *val)
 {
-	char buf[80 + 12]; /* 80 for device, 12 for erase size */
+	char buf[80 + 12 + 80]; /* 80 for device, 12 for erase size, 80 for name */
 	char *str = buf;
-	char *token[2];
+	char *token[3];
 	char *name;
 	size_t erase_size = PAGE_SIZE;
 	int i, ret;
@@ -387,7 +491,7 @@ static int block2mtd_setup2(const char *val)
 	strcpy(str, val);
 	kill_final_newline(str);
 
-	for (i = 0; i < 2; i++)
+	for (i = 0; i < 3; i++)
 		token[i] = strsep(&str, ",");
 
 	if (str)
@@ -406,8 +510,10 @@ static int block2mtd_setup2(const char *val)
 			parse_err("illegal erase size");
 		}
 	}
+	if (token[2] && (strlen(token[2]) + 1 > 80))
+		parse_err("mtd device name too long");
 
-	add_device(name, erase_size);
+	add_device(name, erase_size, token[2]);
 
 	return 0;
 }
@@ -441,7 +547,7 @@ static int block2mtd_setup(const char *val, struct kernel_param *kp)
 
 
 module_param_call(block2mtd, block2mtd_setup, NULL, NULL, 0200);
-MODULE_PARM_DESC(block2mtd, "Device to use. \"block2mtd=<dev>[,<erasesize>]\"");
+MODULE_PARM_DESC(block2mtd, "Device to use. \"block2mtd=<dev>[,<erasesize>[,<name>]]\"");
 
 static int __init block2mtd_init(void)
 {
diff --git a/drivers/mtd/devices/m25p80.c b/drivers/mtd/devices/m25p80.c
index c83d4f8..2cc0671 100644
--- a/drivers/mtd/devices/m25p80.c
+++ b/drivers/mtd/devices/m25p80.c
@@ -44,6 +44,7 @@
 #define	OPCODE_BE_4K		0x20	/* Erase 4KiB block */
 #define	OPCODE_BE_32K		0x52	/* Erase 32KiB block */
 #define	OPCODE_CHIP_ERASE	0xc7	/* Erase whole flash chip */
+#define	OPCODE_BE_4K_PMC	0xd7	/* Erase 4KiB block on PMC chips*/
 #define	OPCODE_SE		0xd8	/* Sector erase (usually 64KiB) */
 #define	OPCODE_RDID		0x9f	/* Read JEDEC ID */
 
@@ -630,6 +631,7 @@ struct flash_info {
 	u16		flags;
 #define	SECT_4K		0x01		/* OPCODE_BE_4K works uniformly */
 #define	M25P_NO_ERASE	0x02		/* No erase command needed */
+#define	SECT_4K_PMC	0x04		/* OPCODE_BE_4K_PMC works uniformly */
 };
 
 #define INFO(_jedec_id, _ext_id, _sector_size, _n_sectors, _flags)	\
@@ -689,6 +691,10 @@ static const struct spi_device_id m25p_ids[] = {
 	{ "mx25l25635e", INFO(0xc22019, 0, 64 * 1024, 512, 0) },
 	{ "mx25l25655e", INFO(0xc22619, 0, 64 * 1024, 512, 0) },
 
+	/* PMC -- pm25x "blocks" are 32K, sectors are 4K */
+	{ "pm25lv512", INFO(0, 0, 32 * 1024, 2, SECT_4K_PMC) },
+	{ "pm25lv010", INFO(0, 0, 32 * 1024, 4, SECT_4K_PMC) },
+
 	/* Spansion -- single (large) sector size only, at least
 	 * for the chips listed here (without boot sectors).
 	 */
@@ -762,6 +768,7 @@ static const struct spi_device_id m25p_ids[] = {
 	{ "w25q32", INFO(0xef4016, 0, 64 * 1024,  64, SECT_4K) },
 	{ "w25x64", INFO(0xef3017, 0, 64 * 1024, 128, SECT_4K) },
 	{ "w25q64", INFO(0xef4017, 0, 64 * 1024, 128, SECT_4K) },
+	{ "w25q128", INFO(0xef4018, 0, 64 * 1024, 256, SECT_4K) },
 
 	/* Catalyst / On Semiconductor -- non-JEDEC */
 	{ "cat25c11", CAT25_INFO(  16, 8, 16, 1) },
@@ -920,6 +927,9 @@ static int __devinit m25p_probe(struct spi_device *spi)
 	if (info->flags & SECT_4K) {
 		flash->erase_opcode = OPCODE_BE_4K;
 		flash->mtd.erasesize = 4096;
+	} else if (info->flags & SECT_4K_PMC) {
+		flash->erase_opcode = OPCODE_BE_4K_PMC;
+		flash->mtd.erasesize = 4096;
 	} else {
 		flash->erase_opcode = OPCODE_SE;
 		flash->mtd.erasesize = info->sector_size;
@@ -976,14 +986,34 @@ static int __devinit m25p_probe(struct spi_device *spi)
 						part_probes, &parts, 0);
 	}
 
+#ifdef CONFIG_MTD_MYLOADER_PARTS
+		if (nr_parts <= 0) {
+			static const char *part_probes[]
+					= { "MyLoader", NULL, };
+
+			nr_parts = parse_mtd_partitions(&flash->mtd,
+					part_probes, &parts, 0);
+		}
+#endif
+
+#ifdef CONFIG_MTD_REDBOOT_PARTS
+		if (nr_parts <= 0) {
+			static const char *part_probes[]
+					= { "RedBoot", NULL, };
+
+			nr_parts = parse_mtd_partitions(&flash->mtd,
+					part_probes, &parts, 0);
+		}
+#endif
+
 #ifdef CONFIG_MTD_WRT160NL_PARTS
-	if (nr_parts <= 0) {
-		static const char *part_probes[]
-			= { "wrt160nl", NULL, };
+		if (nr_parts <= 0) {
+			static const char *part_probes[]
+					= { "wrt160nl", NULL, };
 
-		nr_parts = parse_mtd_partitions(&flash->mtd,
-						part_probes, &parts, 0);
-	}
+			nr_parts = parse_mtd_partitions(&flash->mtd,
+					part_probes, &parts, 0);
+		}
 #endif
 
 	if (nr_parts <= 0 && data && data->parts) {
diff --git a/drivers/mtd/maps/ar91xx_flash.c b/drivers/mtd/maps/ar91xx_flash.c
index 1a55f4a..51ba7f5 100644
--- a/drivers/mtd/maps/ar91xx_flash.c
+++ b/drivers/mtd/maps/ar91xx_flash.c
@@ -227,7 +227,7 @@ static int ar91xx_flash_probe(struct platform_device *pdev)
 	add_mtd_device(info->mtd);
 	return 0;
 
- err_out:
+err_out:
 	ar91xx_flash_remove(pdev);
 	return err;
 }
@@ -246,7 +246,7 @@ static int ar91xx_flash_suspend(struct platform_device *dev, pm_message_t state)
 
 	return 0;
 
- fail:
+fail:
 	if (info->mtd->suspend) {
 		BUG_ON(!info->mtd->resume);
 		info->mtd->resume(info->mtd);
diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index 9f8658e..f2d829d 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -949,6 +949,12 @@ static int mtd_ioctl(struct file *file, u_int cmd, u_long arg)
 		break;
 	}
 
+	case MTDREFRESH:
+	{
+		ret = mtd_device_refresh(mtd);
+		break;
+	}
+
 	default:
 		ret = -ENOTTY;
 	}
diff --git a/drivers/mtd/mtdconcat.c b/drivers/mtd/mtdconcat.c
index e601672..1574258 100644
--- a/drivers/mtd/mtdconcat.c
+++ b/drivers/mtd/mtdconcat.c
@@ -619,7 +619,8 @@ static void concat_sync(struct mtd_info *mtd)
 
 	for (i = 0; i < concat->num_subdev; i++) {
 		struct mtd_info *subdev = concat->subdev[i];
-		subdev->sync(subdev);
+		if (subdev->sync)
+			subdev->sync(subdev);
 	}
 }
 
diff --git a/drivers/mtd/mtdpart.c b/drivers/mtd/mtdpart.c
index 630be3e..99e629a 100644
--- a/drivers/mtd/mtdpart.c
+++ b/drivers/mtd/mtdpart.c
@@ -29,10 +29,14 @@
 #include <linux/kmod.h>
 #include <linux/mtd/mtd.h>
 #include <linux/mtd/partitions.h>
+#include <linux/root_dev.h>
+#include <linux/magic.h>
 #include <linux/err.h>
 
 #include "mtdcore.h"
 
+#define MTD_ERASE_PARTIAL	0x8000 /* partition only covers parts of an erase block */
+
 /* Our partition linked list */
 static LIST_HEAD(mtd_partitions);
 static DEFINE_MUTEX(mtd_partitions_mutex);
@@ -50,7 +54,7 @@ struct mtd_part {
  * the pointer to that structure with this macro.
  */
 #define PART(x)  ((struct mtd_part *)(x))
-
+#define IS_PART(mtd) (mtd->read == part_read)
 
 /*
  * MTD methods which simply translate the effective address and pass through
@@ -256,13 +260,60 @@ static int part_erase(struct mtd_info *mtd, struct erase_info *instr)
 		return -EROFS;
 	if (instr->addr >= mtd->size)
 		return -EINVAL;
+
+	instr->partial_start = false;
+	if (mtd->flags & MTD_ERASE_PARTIAL) {
+		size_t readlen = 0;
+		u64 mtd_ofs;
+
+		instr->erase_buf = kmalloc(part->master->erasesize, GFP_ATOMIC);
+		if (!instr->erase_buf)
+			return -ENOMEM;
+
+		mtd_ofs = part->offset + instr->addr;
+		instr->erase_buf_ofs = do_div(mtd_ofs, part->master->erasesize);
+
+		if (instr->erase_buf_ofs > 0) {
+			instr->addr -= instr->erase_buf_ofs;
+			ret = part->master->read(part->master,
+				instr->addr + part->offset,
+				part->master->erasesize,
+				&readlen, instr->erase_buf);
+
+			instr->partial_start = true;
+		} else {
+			mtd_ofs = part->offset + part->mtd.size;
+			instr->erase_buf_ofs = part->master->erasesize -
+				do_div(mtd_ofs, part->master->erasesize);
+
+			if (instr->erase_buf_ofs > 0) {
+				instr->len += instr->erase_buf_ofs;
+				ret = part->master->read(part->master,
+					part->offset + instr->addr +
+					instr->len - part->master->erasesize,
+					part->master->erasesize, &readlen,
+					instr->erase_buf);
+			} else {
+				ret = 0;
+			}
+		}
+		if (ret < 0) {
+			kfree(instr->erase_buf);
+			return ret;
+		}
+
+	}
+
 	instr->addr += part->offset;
 	ret = part->master->erase(part->master, instr);
 	if (ret) {
 		if (instr->fail_addr != MTD_FAIL_ADDR_UNKNOWN)
 			instr->fail_addr -= part->offset;
 		instr->addr -= part->offset;
+		if (mtd->flags & MTD_ERASE_PARTIAL)
+			kfree(instr->erase_buf);
 	}
+
 	return ret;
 }
 
@@ -270,7 +321,25 @@ void mtd_erase_callback(struct erase_info *instr)
 {
 	if (instr->mtd->erase == part_erase) {
 		struct mtd_part *part = PART(instr->mtd);
-
+		size_t wrlen = 0;
+
+		if (instr->mtd->flags & MTD_ERASE_PARTIAL) {
+			if (instr->partial_start) {
+				part->master->write(part->master,
+					instr->addr, instr->erase_buf_ofs,
+					&wrlen, instr->erase_buf);
+				instr->addr += instr->erase_buf_ofs;
+			} else {
+				instr->len -= instr->erase_buf_ofs;
+				part->master->write(part->master,
+					instr->addr + instr->len,
+					instr->erase_buf_ofs, &wrlen,
+					instr->erase_buf +
+					part->master->erasesize -
+					instr->erase_buf_ofs);
+			}
+			kfree(instr->erase_buf);
+		}
 		if (instr->fail_addr != MTD_FAIL_ADDR_UNKNOWN)
 			instr->fail_addr -= part->offset;
 		instr->addr -= part->offset;
@@ -528,18 +597,24 @@ static struct mtd_part *allocate_partition(struct mtd_info *master,
 	if ((slave->mtd.flags & MTD_WRITEABLE) &&
 	    mtd_mod_by_eb(slave->offset, &slave->mtd)) {
 		/* Doesn't start on a boundary of major erase size */
-		/* FIXME: Let it be writable if it is on a boundary of
-		 * _minor_ erase size though */
-		slave->mtd.flags &= ~MTD_WRITEABLE;
-		printk(KERN_WARNING"mtd: partition \"%s\" doesn't start on an erase block boundary -- force read-only\n",
-			part->name);
+		slave->mtd.flags |= MTD_ERASE_PARTIAL;
+		if (((u32) slave->mtd.size) > master->erasesize)
+			slave->mtd.flags &= ~MTD_WRITEABLE;
+		else
+			slave->mtd.erasesize = slave->mtd.size;
 	}
 	if ((slave->mtd.flags & MTD_WRITEABLE) &&
-	    mtd_mod_by_eb(slave->mtd.size, &slave->mtd)) {
-		slave->mtd.flags &= ~MTD_WRITEABLE;
-		printk(KERN_WARNING"mtd: partition \"%s\" doesn't end on an erase block -- force read-only\n",
-			part->name);
+	    mtd_mod_by_eb(slave->offset + slave->mtd.size, &slave->mtd)) {
+		slave->mtd.flags |= MTD_ERASE_PARTIAL;
+
+		if ((u32) slave->mtd.size > master->erasesize)
+			slave->mtd.flags &= ~MTD_WRITEABLE;
+		else
+			slave->mtd.erasesize = slave->mtd.size;
 	}
+	if ((slave->mtd.flags & (MTD_ERASE_PARTIAL|MTD_WRITEABLE)) == MTD_ERASE_PARTIAL)
+		printk(KERN_WARNING"mtd: partition \"%s\" must either start or end on erase block boundary or be smaller than an erase block -- forcing read-only\n",
+				part->name);
 
 	slave->mtd.ecclayout = master->ecclayout;
 	if (master->block_isbad) {
@@ -637,6 +712,155 @@ int mtd_del_partition(struct mtd_info *master, int partno)
 }
 EXPORT_SYMBOL_GPL(mtd_del_partition);
 
+#ifdef CONFIG_MTD_ROOTFS_SPLIT
+#define ROOTFS_SPLIT_NAME "rootfs_data"
+#define ROOTFS_REMOVED_NAME "<removed>"
+
+struct squashfs_super_block {
+	__le32 s_magic;
+	__le32 pad0[9];
+	__le64 bytes_used;
+};
+
+
+static int split_squashfs(struct mtd_info *master, int offset, int *split_offset)
+{
+	struct squashfs_super_block sb;
+	int len, ret;
+
+	ret = master->read(master, offset, sizeof(sb), &len, (void *) &sb);
+	if (ret || (len != sizeof(sb))) {
+		printk(KERN_ALERT "split_squashfs: error occured while reading "
+			"from \"%s\"\n", master->name);
+		return -EINVAL;
+	}
+
+	if (SQUASHFS_MAGIC != le32_to_cpu(sb.s_magic) ) {
+		printk(KERN_ALERT "split_squashfs: no squashfs found in \"%s\"\n",
+			master->name);
+		*split_offset = 0;
+		return 0;
+	}
+
+	if (le64_to_cpu((sb.bytes_used)) <= 0) {
+		printk(KERN_ALERT "split_squashfs: squashfs is empty in \"%s\"\n",
+			master->name);
+		*split_offset = 0;
+		return 0;
+	}
+
+	len = (u32) le64_to_cpu(sb.bytes_used);
+	len += (offset & 0x000fffff);
+	len +=  (master->erasesize - 1);
+	len &= ~(master->erasesize - 1);
+	len -= (offset & 0x000fffff);
+	*split_offset = offset + len;
+
+	return 0;
+}
+
+static int split_rootfs_data(struct mtd_info *master, struct mtd_info *rpart, const struct mtd_partition *part)
+{
+	struct mtd_partition *dpart;
+	struct mtd_part *slave = NULL;
+	struct mtd_part *spart;
+	int ret, split_offset = 0;
+
+	spart = PART(rpart);
+	ret = split_squashfs(master, spart->offset, &split_offset);
+	if (ret)
+		return ret;
+
+	if (split_offset <= 0)
+		return 0;
+
+	dpart = kmalloc(sizeof(*part)+sizeof(ROOTFS_SPLIT_NAME)+1, GFP_KERNEL);
+	if (dpart == NULL) {
+		printk(KERN_INFO "split_squashfs: no memory for partition \"%s\"\n",
+			ROOTFS_SPLIT_NAME);
+		return -ENOMEM;
+	}
+
+	memcpy(dpart, part, sizeof(*part));
+	dpart->name = (unsigned char *)&dpart[1];
+	strcpy(dpart->name, ROOTFS_SPLIT_NAME);
+
+	dpart->size = rpart->size - (split_offset - spart->offset);
+	dpart->offset = split_offset;
+
+	if (dpart == NULL)
+		return 1;
+
+	printk(KERN_INFO "mtd: partition \"%s\" created automatically, ofs=%llX, len=%llX \n",
+		ROOTFS_SPLIT_NAME, dpart->offset, dpart->size);
+
+	slave = allocate_partition(master, dpart, 0, split_offset);
+	if (IS_ERR(slave))
+		return PTR_ERR(slave);
+	mutex_lock(&mtd_partitions_mutex);
+	list_add(&slave->list, &mtd_partitions);
+	mutex_unlock(&mtd_partitions_mutex);
+
+	add_mtd_device(&slave->mtd);
+
+	rpart->split = &slave->mtd;
+
+	return 0;
+}
+
+static int refresh_rootfs_split(struct mtd_info *mtd)
+{
+	struct mtd_partition tpart;
+	struct mtd_part *part;
+	char *name;
+	//int index = 0;
+	int offset, size;
+	int ret;
+
+	part = PART(mtd);
+
+	/* check for the new squashfs offset first */
+	ret = split_squashfs(part->master, part->offset, &offset);
+	if (ret)
+		return ret;
+
+	if ((offset > 0) && !mtd->split) {
+		printk(KERN_INFO "%s: creating new split partition for \"%s\"\n", __func__, mtd->name);
+		/* if we don't have a rootfs split partition, create a new one */
+		tpart.name = (char *) mtd->name;
+		tpart.size = mtd->size;
+		tpart.offset = part->offset;
+
+		return split_rootfs_data(part->master, &part->mtd, &tpart);
+	} else if ((offset > 0) && mtd->split) {
+		/* update the offsets of the existing partition */
+		size = mtd->size + part->offset - offset;
+
+		part = PART(mtd->split);
+		part->offset = offset;
+		part->mtd.size = size;
+		printk(KERN_INFO "%s: %s partition \"" ROOTFS_SPLIT_NAME "\", offset: 0x%06x (0x%06x)\n",
+			__func__, (!strcmp(part->mtd.name, ROOTFS_SPLIT_NAME) ? "updating" : "creating"),
+			(u32) part->offset, (u32) part->mtd.size);
+		name = kmalloc(sizeof(ROOTFS_SPLIT_NAME) + 1, GFP_KERNEL);
+		strcpy(name, ROOTFS_SPLIT_NAME);
+		part->mtd.name = name;
+	} else if ((offset <= 0) && mtd->split) {
+		printk(KERN_INFO "%s: removing partition \"%s\"\n", __func__, mtd->split->name);
+
+		/* mark existing partition as removed */
+		part = PART(mtd->split);
+		name = kmalloc(sizeof(ROOTFS_SPLIT_NAME) + 1, GFP_KERNEL);
+		strcpy(name, ROOTFS_REMOVED_NAME);
+		part->mtd.name = name;
+		part->offset = 0;
+		part->mtd.size = 0;
+	}
+
+	return 0;
+}
+#endif /* CONFIG_MTD_ROOTFS_SPLIT */
+
 /*
  * This function, given a master MTD object and a partition table, creates
  * and registers slave MTD objects which are bound to the master according to
@@ -653,6 +877,9 @@ int add_mtd_partitions(struct mtd_info *master,
 	struct mtd_part *slave;
 	uint64_t cur_offset = 0;
 	int i;
+#ifdef CONFIG_MTD_ROOTFS_SPLIT
+	int ret;
+#endif
 
 	printk(KERN_NOTICE "Creating %d MTD partitions on \"%s\":\n", nbparts, master->name);
 
@@ -667,12 +894,53 @@ int add_mtd_partitions(struct mtd_info *master,
 
 		add_mtd_device(&slave->mtd);
 
+		if (!strcmp(parts[i].name, "rootfs")) {
+#ifdef CONFIG_MTD_ROOTFS_ROOT_DEV
+			if (ROOT_DEV == 0) {
+				printk(KERN_NOTICE "mtd: partition \"rootfs\" "
+					"set to be root filesystem\n");
+				ROOT_DEV = MKDEV(MTD_BLOCK_MAJOR, slave->mtd.index);
+			}
+#endif
+#ifdef CONFIG_MTD_ROOTFS_SPLIT
+			ret = split_rootfs_data(master, &slave->mtd, &parts[i]);
+			/* if (ret == 0)
+			 * 	j++; */
+#endif
+		}
+
 		cur_offset = slave->offset + slave->mtd.size;
 	}
 
 	return 0;
 }
 
+int mtd_device_refresh(struct mtd_info *mtd)
+{
+	int ret = 0;
+
+	if (IS_PART(mtd)) {
+		struct mtd_part *part;
+		struct mtd_info *master;
+
+		part = PART(mtd);
+		master = part->master;
+		if (master->refresh_device)
+			ret = master->refresh_device(master);
+	}
+
+	if (!ret && mtd->refresh_device)
+		ret = mtd->refresh_device(mtd);
+
+#ifdef CONFIG_MTD_ROOTFS_SPLIT
+	if (!ret && IS_PART(mtd) && !strcmp(mtd->name, "rootfs"))
+		refresh_rootfs_split(mtd);
+#endif
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(mtd_device_refresh);
+
 static DEFINE_SPINLOCK(part_parser_lock);
 static LIST_HEAD(part_parsers);
 
diff --git a/drivers/mtd/myloader.c b/drivers/mtd/myloader.c
new file mode 100644
index 0000000..51c0374
--- /dev/null
+++ b/drivers/mtd/myloader.c
@@ -0,0 +1,178 @@
+/*
+ *  Parse MyLoader-style flash partition tables and produce a Linux partition
+ *  array to match.
+ *
+ *  Copyright (C) 2007-2009 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This file was based on drivers/mtd/redboot.c
+ *  Author: Red Hat, Inc. - David Woodhouse <dwmw2@cambridge.redhat.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/vmalloc.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <linux/byteorder/generic.h>
+#include <linux/myloader.h>
+
+#define BLOCK_LEN_MIN		0x10000
+#define PART_NAME_LEN		32
+
+struct part_data {
+	struct mylo_partition_table	tab;
+	char names[MYLO_MAX_PARTITIONS][PART_NAME_LEN];
+};
+
+int myloader_parse_partitions(struct mtd_info *master,
+			struct mtd_partition **pparts,
+			unsigned long origin)
+{
+	struct part_data *buf;
+	struct mylo_partition_table *tab;
+	struct mylo_partition *part;
+	struct mtd_partition *mtd_parts;
+	struct mtd_partition *mtd_part;
+	int num_parts;
+	int ret, i;
+	size_t retlen;
+	char *names;
+	unsigned long offset;
+	unsigned long blocklen;
+
+	buf = vmalloc(sizeof(*buf));
+	if (!buf) {
+		return -ENOMEM;
+		goto out;
+	}
+	tab = &buf->tab;
+
+	blocklen = master->erasesize;
+	if (blocklen < BLOCK_LEN_MIN)
+		blocklen = BLOCK_LEN_MIN;
+
+	offset = blocklen;
+
+	/* Find the partition table */
+	for (i = 0; i < 4; i++, offset += blocklen) {
+		printk(KERN_DEBUG "%s: searching for MyLoader partition table"
+				" at offset 0x%lx\n", master->name, offset);
+
+		ret = master->read(master, offset, sizeof(*buf), &retlen,
+					(void *)buf);
+		if (ret)
+			goto out_free_buf;
+
+		if (retlen != sizeof(*buf)) {
+			ret = -EIO;
+			goto out_free_buf;
+		}
+
+		/* Check for Partition Table magic number */
+		if (tab->magic == le32_to_cpu(MYLO_MAGIC_PARTITIONS))
+			break;
+
+	}
+
+	if (tab->magic != le32_to_cpu(MYLO_MAGIC_PARTITIONS)) {
+		printk(KERN_DEBUG "%s: no MyLoader partition table found\n",
+			master->name);
+		ret = 0;
+		goto out_free_buf;
+	}
+
+	/* The MyLoader and the Partition Table is always present */
+	num_parts = 2;
+
+	/* Detect number of used partitions */
+	for (i = 0; i < MYLO_MAX_PARTITIONS; i++) {
+		part = &tab->partitions[i];
+
+		if (le16_to_cpu(part->type) == PARTITION_TYPE_FREE)
+			continue;
+
+		num_parts++;
+	}
+
+	mtd_parts = kzalloc((num_parts * sizeof(*mtd_part) +
+				num_parts * PART_NAME_LEN), GFP_KERNEL);
+
+	if (!mtd_parts) {
+		ret = -ENOMEM;
+		goto out_free_buf;
+	}
+
+	mtd_part = mtd_parts;
+	names = (char *)&mtd_parts[num_parts];
+
+	strncpy(names, "myloader", PART_NAME_LEN);
+	mtd_part->name = names;
+	mtd_part->offset = 0;
+	mtd_part->size = offset;
+	mtd_part->mask_flags = MTD_WRITEABLE;
+	mtd_part++;
+	names += PART_NAME_LEN;
+
+	strncpy(names, "partition_table", PART_NAME_LEN);
+	mtd_part->name = names;
+	mtd_part->offset = offset;
+	mtd_part->size = blocklen;
+	mtd_part->mask_flags = MTD_WRITEABLE;
+	mtd_part++;
+	names += PART_NAME_LEN;
+
+	for (i = 0; i < MYLO_MAX_PARTITIONS; i++) {
+		part = &tab->partitions[i];
+
+		if (le16_to_cpu(part->type) == PARTITION_TYPE_FREE)
+			continue;
+
+		if ((buf->names[i][0]) && (buf->names[i][0] != '\xff'))
+			strncpy(names, buf->names[i], PART_NAME_LEN);
+		else
+			snprintf(names, PART_NAME_LEN, "partition%d", i);
+
+		mtd_part->offset = le32_to_cpu(part->addr);
+		mtd_part->size = le32_to_cpu(part->size);
+		mtd_part->name = names;
+		mtd_part++;
+		names += PART_NAME_LEN;
+	}
+
+	*pparts = mtd_parts;
+	ret = num_parts;
+
+ out_free_buf:
+	vfree(buf);
+ out:
+	return ret;
+}
+
+static struct mtd_part_parser myloader_mtd_parser = {
+	.owner		= THIS_MODULE,
+	.parse_fn	= myloader_parse_partitions,
+	.name		= "MyLoader",
+};
+
+static int __init myloader_mtd_parser_init(void)
+{
+	return register_mtd_parser(&myloader_mtd_parser);
+}
+
+static void __exit myloader_mtd_parser_exit(void)
+{
+	deregister_mtd_parser(&myloader_mtd_parser);
+}
+
+module_init(myloader_mtd_parser_init);
+module_exit(myloader_mtd_parser_exit);
+
+MODULE_AUTHOR("Gabor Juhos <juhosg@openwrt.org>");
+MODULE_DESCRIPTION("Parsing code for MyLoader partition tables");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/mtd/nand/nand_ecc.c b/drivers/mtd/nand/nand_ecc.c
index 271b8e7..9e08a1c 100644
--- a/drivers/mtd/nand/nand_ecc.c
+++ b/drivers/mtd/nand/nand_ecc.c
@@ -507,8 +507,7 @@ int __nand_correct_data(unsigned char *buf,
 	if ((bitsperbyte[b0] + bitsperbyte[b1] + bitsperbyte[b2]) == 1)
 		return 1;	/* error in ecc data; no action needed */
 
-	printk(KERN_ERR "uncorrectable error : ");
-	return -1;
+	return -EBADMSG;
 }
 EXPORT_SYMBOL(__nand_correct_data);
 
diff --git a/drivers/mtd/nand/plat_nand.c b/drivers/mtd/nand/plat_nand.c
index 633c04b..d0b37b7 100644
--- a/drivers/mtd/nand/plat_nand.c
+++ b/drivers/mtd/nand/plat_nand.c
@@ -94,7 +94,18 @@ static int __devinit plat_nand_probe(struct platform_device *pdev)
 	}
 
 	/* Scan to find existence of the device */
-	if (nand_scan(&data->mtd, pdata->chip.nr_chips)) {
+	if (nand_scan_ident(&data->mtd, pdata->chip.nr_chips, NULL)) {
+		res = -ENXIO;
+		goto out;
+	}
+
+	if (pdata->chip.chip_fixup) {
+		res = pdata->chip.chip_fixup(&data->mtd);
+		if (res)
+			goto out;
+	}
+
+	if (nand_scan_tail(&data->mtd)) {
 		err = -ENXIO;
 		goto out;
 	}
diff --git a/drivers/mtd/nand/rb4xx_nand.c b/drivers/mtd/nand/rb4xx_nand.c
index 5087794..664f7df 100644
--- a/drivers/mtd/nand/rb4xx_nand.c
+++ b/drivers/mtd/nand/rb4xx_nand.c
@@ -1,7 +1,7 @@
 /*
  *  NAND flash driver for the MikroTik RouterBoard 4xx series
  *
- *  Copyright (C) 2008 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008-2011 Gabor Juhos <juhosg@openwrt.org>
  *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
  *
  *  This file was based on the driver for Linux 2.6.22 published by
@@ -20,51 +20,19 @@
 #include <linux/delay.h>
 #include <linux/io.h>
 #include <linux/gpio.h>
+#include <linux/slab.h>
 
 #include <asm/mach-ar71xx/ar71xx.h>
+#include <asm/mach-ar71xx/rb4xx_cpld.h>
 
 #define DRV_NAME        "rb4xx-nand"
-#define DRV_VERSION     "0.1.10"
+#define DRV_VERSION     "0.2.0"
 #define DRV_DESC        "NAND flash driver for RouterBoard 4xx series"
 
-#define USE_FAST_READ	1
-#define USE_FAST_WRITE	1
-#undef RB4XX_NAND_DEBUG
-
-#ifdef RB4XX_NAND_DEBUG
-#define DBG(fmt, arg...)	printk(KERN_DEBUG DRV_NAME ": " fmt, ## arg)
-#else
-#define DBG(fmt, arg...)	do {} while (0)
-#endif
-
-#define RB4XX_NAND_GPIO_RDY	5
-#define RB4XX_FLASH_HZ		33333334
-#define RB4XX_NAND_HZ		33333334
-
-#define SPI_CTRL_FASTEST	0x40
-#define SPI_CTRL_SAFE		0x43	/* 25 MHz for AHB 200 MHz */
-#define SBIT_IOC_BASE		SPI_IOC_CS1
-#define SBIT_IOC_DO_SHIFT	0
-#define SBIT_IOC_DO		(1u << SBIT_IOC_DO_SHIFT)
-#define SBIT_IOC_DO2_SHIFT	18
-#define SBIT_IOC_DO2		(1u << SBIT_IOC_DO2_SHIFT)
-
-#define CPLD_CMD_WRITE_MULT	0x08	/* send cmd, n x send data, read data */
-#define CPLD_CMD_WRITE_CFG	0x09	/* send cmd, n x send cfg */
-#define CPLD_CMD_READ_MULT	0x0a	/* send cmd, send idle, n x read data */
-#define CPLD_CMD_READ_FAST	0x0b	/* send cmd, 4 x idle, n x read data */
-
-#define CFG_BIT_nCE	0x80
-#define CFG_BIT_CLE	0x40
-#define CFG_BIT_ALE	0x20
-#define CFG_BIT_FAN	0x10
-#define CFG_BIT_nLED4	0x08
-#define CFG_BIT_nLED3	0x04
-#define CFG_BIT_nLED2	0x02
-#define CFG_BIT_nLED1	0x01
-
-#define CFG_BIT_nLEDS \
-	(CFG_BIT_nLED1 | CFG_BIT_nLED2 | CFG_BIT_nLED3 | CFG_BIT_nLED4)
+#define RB4XX_NAND_GPIO_READY	5
+#define RB4XX_NAND_GPIO_ALE	37
+#define RB4XX_NAND_GPIO_CLE	38
+#define RB4XX_NAND_GPIO_NCE	39
 
 struct rb4xx_nand_info {
 	struct nand_chip	chip;
@@ -92,7 +60,7 @@ static struct mtd_partition rb4xx_nand_partitions[] = {
 	{
 		.name	= "kernel",
 		.offset	= (256 * 1024),
-		.size	= (4 * 1024 * 1024) - (256 * 1024),
+		.size	= (6 * 1024 * 1024) - (256 * 1024),
 	},
 	{
 		.name	= "rootfs",
@@ -101,318 +69,141 @@ static struct mtd_partition rb4xx_nand_partitions[] = {
 	},
 };
 
-#if USE_FAST_READ
-#define SPI_NDATA_BASE	0x00800000
-static unsigned spi_ctrl_fread = SPI_CTRL_SAFE;
-static unsigned spi_ctrl_flash = SPI_CTRL_SAFE;
-extern unsigned mips_hpt_frequency;
-#endif
-
-static inline unsigned rb4xx_spi_rreg(unsigned r)
-{
-	return __raw_readl((void * __iomem)(KSEG1ADDR(AR71XX_SPI_BASE) + r));
-}
-
-static inline void rb4xx_spi_wreg(unsigned r, unsigned v)
-{
-	__raw_writel(v, (void * __iomem)(KSEG1ADDR(AR71XX_SPI_BASE) + r));
-}
-
-static inline void do_spi_clk(int bit)
-{
-	unsigned bval = SBIT_IOC_BASE | (bit & 1);
-
-	rb4xx_spi_wreg(SPI_REG_IOC, bval);
-	rb4xx_spi_wreg(SPI_REG_IOC, bval | SPI_IOC_CLK);
-}
-
-static void do_spi_byte(uint8_t byte)
+static int rb4xx_nand_dev_ready(struct mtd_info *mtd)
 {
-	do_spi_clk(byte >> 7);
-	do_spi_clk(byte >> 6);
-	do_spi_clk(byte >> 5);
-	do_spi_clk(byte >> 4);
-	do_spi_clk(byte >> 3);
-	do_spi_clk(byte >> 2);
-	do_spi_clk(byte >> 1);
-	do_spi_clk(byte);
-
-	DBG("spi_byte sent 0x%02x got 0x%x\n",
-					byte, rb4xx_spi_rreg(SPI_REG_RDS));
+	return gpio_get_value_cansleep(RB4XX_NAND_GPIO_READY);
 }
 
-#if USE_FAST_WRITE
-static inline void do_spi_clk_fast(int bit1, int bit2)
+static void rb4xx_nand_write_cmd(unsigned char cmd)
 {
-	unsigned bval = (SBIT_IOC_BASE |
-			((bit1 << SBIT_IOC_DO_SHIFT) & SBIT_IOC_DO) |
-			((bit2 << SBIT_IOC_DO2_SHIFT) & SBIT_IOC_DO2));
+	unsigned char data = cmd;
+	int err;
 
-	rb4xx_spi_wreg(SPI_REG_IOC, bval);
-	rb4xx_spi_wreg(SPI_REG_IOC, bval | SPI_IOC_CLK);
+	err = rb4xx_cpld_write(&data, 1);
+	if (err)
+		pr_err("rb4xx_nand: write cmd failed, err=%d\n", err);
 }
 
-static inline void do_spi_byte_fast(uint8_t byte)
+static void rb4xx_nand_cmd_ctrl(struct mtd_info *mtd, int cmd,
+				unsigned int ctrl)
 {
-	do_spi_clk_fast(byte >> 7, byte >> 6);
-	do_spi_clk_fast(byte >> 5, byte >> 4);
-	do_spi_clk_fast(byte >> 3, byte >> 2);
-	do_spi_clk_fast(byte >> 1, byte >> 0);
+	if (ctrl & NAND_CTRL_CHANGE) {
+		gpio_set_value_cansleep(RB4XX_NAND_GPIO_CLE,
+					(ctrl & NAND_CLE) ? 1 : 0);
+		gpio_set_value_cansleep(RB4XX_NAND_GPIO_ALE,
+					(ctrl & NAND_ALE) ? 1 : 0);
+		gpio_set_value_cansleep(RB4XX_NAND_GPIO_NCE,
+					(ctrl & NAND_NCE) ? 0 : 1);
+	}
 
-	DBG("spi_byte_fast sent 0x%02x got 0x%x\n",
-					byte, rb4xx_spi_rreg(SPI_REG_RDS));
-}
-#else
-static inline void do_spi_byte_fast(uint8_t byte)
-{
-	do_spi_byte(byte);
+	if (cmd != NAND_CMD_NONE)
+		rb4xx_nand_write_cmd(cmd);
 }
-#endif /* USE_FAST_WRITE */
 
-static int do_spi_cmd(unsigned cmd, unsigned sendCnt, const uint8_t *sendData,
-		unsigned recvCnt, uint8_t *recvData,
-		const uint8_t *verifyData, int fastWrite)
+static unsigned char rb4xx_nand_read_byte(struct mtd_info *mtd)
 {
-	unsigned i;
-
-	DBG("SPI cmd 0x%x send %u recv %u\n", cmd, sendCnt, recvCnt);
-
-	rb4xx_spi_wreg(SPI_REG_FS, SPI_FS_GPIO);
-	rb4xx_spi_wreg(SPI_REG_CTRL, SPI_CTRL_FASTEST);
+	unsigned char data = 0;
+	int err;
 
-	do_spi_byte(cmd);
-#if 0
-	if (cmd == CPLD_CMD_READ_FAST) {
-		do_spi_byte(0x80);
-		do_spi_byte(0);
-		do_spi_byte(0);
-	}
-#endif
-	for (i = 0; i < sendCnt; ++i) {
-		if (fastWrite)
-			do_spi_byte_fast(sendData[i]);
-		else
-			do_spi_byte(sendData[i]);
+	err = rb4xx_cpld_read(&data, NULL, 1);
+	if (err) {
+		pr_err("rb4xx_nand: read data failed, err=%d\n", err);
+		data = 0xff;
 	}
 
-	for (i = 0; i < recvCnt; ++i) {
-		if (fastWrite)
-			do_spi_byte_fast(0);
-		else
-			do_spi_byte(0);
-
-		if (recvData) {
-			recvData[i] = rb4xx_spi_rreg(SPI_REG_RDS) & 0xff;
-		} else if (verifyData) {
-			if (verifyData[i] != (rb4xx_spi_rreg(SPI_REG_RDS)
-							 & 0xff))
-				break;
-		}
-	}
-
-	rb4xx_spi_wreg(SPI_REG_IOC, SBIT_IOC_BASE | SPI_IOC_CS0);
-	rb4xx_spi_wreg(SPI_REG_CTRL, spi_ctrl_flash);
-	rb4xx_spi_wreg(SPI_REG_FS, 0);
-
-	return i == recvCnt;
+	return data;
 }
 
-static int got_write = 1;
-
-static void rb4xx_nand_write_data(const uint8_t *byte, unsigned cnt)
+static void rb4xx_nand_write_buf(struct mtd_info *mtd, const unsigned char *buf,
+				 int len)
 {
-	do_spi_cmd(CPLD_CMD_WRITE_MULT, cnt, byte, 1, NULL, NULL, 1);
-	got_write = 1;
-}
+	int err;
 
-static void rb4xx_nand_write_byte(uint8_t byte)
-{
-	rb4xx_nand_write_data(&byte, 1);
+	err = rb4xx_cpld_write(buf, len);
+	if (err)
+		pr_err("rb4xx_nand: write buf failed, err=%d\n", err);
 }
 
-#if USE_FAST_READ
-static uint8_t *rb4xx_nand_read_getaddr(unsigned cnt)
+static void rb4xx_nand_read_buf(struct mtd_info *mtd, unsigned char *buf,
+				int len)
 {
-	static unsigned nboffset = 0x100000;
-	unsigned addr;
-
-	if (got_write) {
-		nboffset = (nboffset + 31) & ~31;
-		if (nboffset >= 0x100000)	/* 1MB */
-			nboffset = 0;
-
-		got_write = 0;
-		rb4xx_spi_wreg(SPI_REG_FS, SPI_FS_GPIO);
-		rb4xx_spi_wreg(SPI_REG_CTRL, spi_ctrl_fread);
-		rb4xx_spi_wreg(SPI_REG_FS, 0);
-	}
+	int err;
 
-	addr = KSEG1ADDR(AR71XX_SPI_BASE + SPI_NDATA_BASE) + nboffset;
-	DBG("rb4xx_nand_read_getaddr 0x%x cnt 0x%x\n", addr, cnt);
-
-	nboffset += cnt;
-	return (uint8_t *)addr;
+	err = rb4xx_cpld_read(buf, NULL, len);
+	if (err)
+		pr_err("rb4xx_nand: read buf failed, err=%d\n", err);
 }
 
-static void rb4xx_nand_read_data(uint8_t *buf, unsigned cnt)
+static int __init rb4xx_nand_probe(struct platform_device *pdev)
 {
-	unsigned size32 = cnt & ~31;
-	unsigned remain = cnt & 31;
+	struct rb4xx_nand_info	*info;
+	int ret;
 
-	if (size32) {
-		uint8_t *addr = rb4xx_nand_read_getaddr(size32);
-		memcpy(buf, (void *)addr, size32);
-	}
+	printk(KERN_INFO DRV_DESC " version " DRV_VERSION "\n");
 
-	if (remain) {
-		do_spi_cmd(CPLD_CMD_READ_MULT, 1, buf, remain,
-			   buf + size32, NULL, 0);
+	ret = gpio_request(RB4XX_NAND_GPIO_READY, "NAND RDY");
+	if (ret) {
+		dev_err(&pdev->dev, "unable to request gpio %d\n",
+			RB4XX_NAND_GPIO_READY);
+		goto err;
 	}
-}
-
-static int rb4xx_nand_verify_data(const uint8_t *buf, unsigned cnt)
-{
-	unsigned size32 = cnt & ~31;
-	unsigned remain = cnt & 31;
 
-	if (size32) {
-		uint8_t *addr = rb4xx_nand_read_getaddr(size32);
-		if (memcmp(buf, (void *)addr, size32) != 0)
-			return 0;
+	ret = gpio_direction_input(RB4XX_NAND_GPIO_READY);
+	if (ret) {
+		dev_err(&pdev->dev, "unable to set input mode on gpio %d\n",
+			RB4XX_NAND_GPIO_READY);
+		goto err_free_gpio_ready;
 	}
 
-	if (remain) {
-		return do_spi_cmd(CPLD_CMD_READ_MULT, 1, buf, remain,
-				  NULL, buf + size32, 0);
+	ret = gpio_request(RB4XX_NAND_GPIO_ALE, "NAND ALE");
+	if (ret) {
+		dev_err(&pdev->dev, "unable to request gpio %d\n",
+			RB4XX_NAND_GPIO_ALE);
+		goto err_free_gpio_ready;
 	}
-	return 1;
-}
-#else /* USE_FAST_READ */
-static void rb4xx_nand_read_data(uint8_t *buf, unsigned cnt)
-{
-	do_spi_cmd(CPLD_CMD_READ_MULT, 1, buf, cnt, buf, NULL, 0);
-}
-
-static int rb4xx_nand_verify_data(const uint8_t *buf, unsigned cnt)
-{
-	return do_spi_cmd(CPLD_CMD_READ_MULT, 1, buf, cnt, NULL, buf, 0);
-}
-#endif /* USE_FAST_READ */
-
-static void rb4xx_nand_write_cfg(uint8_t byte)
-{
-	do_spi_cmd(CPLD_CMD_WRITE_CFG, 1, &byte, 0, NULL, NULL, 0);
-	got_write = 1;
-}
-
-static int rb4xx_nand_dev_ready(struct mtd_info *mtd)
-{
-	return gpio_get_value(RB4XX_NAND_GPIO_RDY);
-}
-
-static void rb4xx_nand_cmd_ctrl(struct mtd_info *mtd, int cmd,
-				unsigned int ctrl)
-{
-	if (ctrl & NAND_CTRL_CHANGE) {
-		uint8_t cfg = CFG_BIT_nLEDS;
 
-		cfg |= (ctrl & NAND_CLE) ? CFG_BIT_CLE : 0;
-		cfg |= (ctrl & NAND_ALE) ? CFG_BIT_ALE : 0;
-		cfg |= (ctrl & NAND_NCE) ? 0 : CFG_BIT_nCE;
-
-		rb4xx_nand_write_cfg(cfg);
+	ret = gpio_direction_output(RB4XX_NAND_GPIO_ALE, 0);
+	if (ret) {
+		dev_err(&pdev->dev, "unable to set output mode on gpio %d\n",
+			RB4XX_NAND_GPIO_ALE);
+		goto err_free_gpio_ale;
 	}
 
-	if (cmd != NAND_CMD_NONE)
-		rb4xx_nand_write_byte(cmd);
-}
-
-static uint8_t rb4xx_nand_read_byte(struct mtd_info *mtd)
-{
-	uint8_t byte = 0;
-
-	rb4xx_nand_read_data(&byte, 1);
-	return byte;
-}
-
-static void rb4xx_nand_write_buf(struct mtd_info *mtd, const uint8_t *buf,
-				int len)
-{
-	rb4xx_nand_write_data(buf, len);
-}
-
-static void rb4xx_nand_read_buf(struct mtd_info *mtd, uint8_t *buf,
-				int len)
-{
-	rb4xx_nand_read_data(buf, len);
-}
-
-static int rb4xx_nand_verify_buf(struct mtd_info *mtd, const uint8_t *buf,
-				int len)
-{
-	if (!rb4xx_nand_verify_data(buf, len))
-		return -EFAULT;
-
-	return 0;
-}
-
-static unsigned get_spi_ctrl(unsigned hz_max, const char *name)
-{
-	unsigned div;
-
-	div = (ar71xx_ahb_freq - 1) / (2 * hz_max);
-	/*
-	 * CPU has a bug at (div == 0) - first bit read is random
-	 */
-	if (div == 0)
-		++div;
-
-	if (name) {
-		unsigned ahb_khz = (ar71xx_ahb_freq + 500) / 1000;
-		unsigned div_real = 2 * (div + 1);
-		printk(KERN_INFO "%s SPI clock %u kHz (AHB %u kHz / %u)\n",
-		       name,
-		       ahb_khz / div_real,
-		       ahb_khz, div_real);
+	ret = gpio_request(RB4XX_NAND_GPIO_CLE, "NAND CLE");
+	if (ret) {
+		dev_err(&pdev->dev, "unable to request gpio %d\n",
+			RB4XX_NAND_GPIO_CLE);
+		goto err_free_gpio_ale;
 	}
 
-	return SPI_CTRL_FASTEST + div;
-}
-
-static int __init rb4xx_nand_probe(struct platform_device *pdev)
-{
-	struct rb4xx_nand_info	*info;
-	int ret;
-
-	printk(KERN_INFO DRV_DESC " version " DRV_VERSION "\n");
+	ret = gpio_direction_output(RB4XX_NAND_GPIO_CLE, 0);
+	if (ret) {
+		dev_err(&pdev->dev, "unable to set output mode on gpio %d\n",
+			RB4XX_NAND_GPIO_CLE);
+		goto err_free_gpio_cle;
+	}
 
-	ret = gpio_request(RB4XX_NAND_GPIO_RDY, "NAND RDY");
+	ret = gpio_request(RB4XX_NAND_GPIO_NCE, "NAND NCE");
 	if (ret) {
-		printk(KERN_ERR "rb4xx-nand: gpio request failed\n");
-		return ret;
+		dev_err(&pdev->dev, "unable to request gpio %d\n",
+			RB4XX_NAND_GPIO_NCE);
+		goto err_free_gpio_cle;
 	}
 
-	ret = gpio_direction_input(RB4XX_NAND_GPIO_RDY);
+	ret = gpio_direction_output(RB4XX_NAND_GPIO_NCE, 1);
 	if (ret) {
-		printk(KERN_ERR "rb4xx-nand: unable to set input mode "
-					"on gpio%d\n", RB4XX_NAND_GPIO_RDY);
-		goto err_free_gpio;
+		dev_err(&pdev->dev, "unable to set output mode on gpio %d\n",
+			RB4XX_NAND_GPIO_ALE);
+		goto err_free_gpio_nce;
 	}
 
 	info = kzalloc(sizeof(*info), GFP_KERNEL);
 	if (!info) {
-		printk(KERN_ERR "rb4xx-nand: no memory for private data\n");
+		dev_err(&pdev->dev, "rb4xx-nand: no memory for private data\n");
 		ret = -ENOMEM;
-		goto err_free_gpio;
+		goto err_free_gpio_nce;
 	}
 
-#if USE_FAST_READ
-	spi_ctrl_fread = get_spi_ctrl(RB4XX_NAND_HZ, "NAND");
-#endif
-	spi_ctrl_flash = get_spi_ctrl(RB4XX_FLASH_HZ, "FLASH");
-
-	rb4xx_nand_write_cfg(CFG_BIT_nLEDS | CFG_BIT_nCE);
-
 	info->chip.priv	= &info;
 	info->mtd.priv	= &info->chip;
 	info->mtd.owner	= THIS_MODULE;
@@ -422,7 +213,9 @@ static int __init rb4xx_nand_probe(struct platform_device *pdev)
 	info->chip.read_byte	= rb4xx_nand_read_byte;
 	info->chip.write_buf	= rb4xx_nand_write_buf;
 	info->chip.read_buf	= rb4xx_nand_read_buf;
+#if 0
 	info->chip.verify_buf	= rb4xx_nand_verify_buf;
+#endif
 
 	info->chip.chip_delay	= 25;
 	info->chip.ecc.mode	= NAND_ECC_SOFT;
@@ -430,7 +223,7 @@ static int __init rb4xx_nand_probe(struct platform_device *pdev)
 
 	platform_set_drvdata(pdev, info);
 
-	ret = nand_scan_ident(&info->mtd, 1);
+	ret = nand_scan_ident(&info->mtd, 1, NULL);
 	if (ret) {
 		ret = -ENXIO;
 		goto err_free_info;
@@ -462,8 +255,15 @@ err_set_drvdata:
 	platform_set_drvdata(pdev, NULL);
 err_free_info:
 	kfree(info);
-err_free_gpio:
-	gpio_free(RB4XX_NAND_GPIO_RDY);
+err_free_gpio_nce:
+	gpio_free(RB4XX_NAND_GPIO_NCE);
+err_free_gpio_cle:
+	gpio_free(RB4XX_NAND_GPIO_CLE);
+err_free_gpio_ale:
+	gpio_free(RB4XX_NAND_GPIO_ALE);
+err_free_gpio_ready:
+	gpio_free(RB4XX_NAND_GPIO_READY);
+err:
 	return ret;
 }
 
@@ -474,6 +274,10 @@ static int __devexit rb4xx_nand_remove(struct platform_device *pdev)
 	nand_release(&info->mtd);
 	platform_set_drvdata(pdev, NULL);
 	kfree(info);
+	gpio_free(RB4XX_NAND_GPIO_NCE);
+	gpio_free(RB4XX_NAND_GPIO_CLE);
+	gpio_free(RB4XX_NAND_GPIO_ALE);
+	gpio_free(RB4XX_NAND_GPIO_READY);
 
 	return 0;
 }
diff --git a/drivers/mtd/nand/rb750_nand.c b/drivers/mtd/nand/rb750_nand.c
index a80e5df..b6adb41 100644
--- a/drivers/mtd/nand/rb750_nand.c
+++ b/drivers/mtd/nand/rb750_nand.c
@@ -14,6 +14,7 @@
 #include <linux/mtd/partitions.h>
 #include <linux/platform_device.h>
 #include <linux/io.h>
+#include <linux/slab.h>
 
 #include <asm/mach-ar71xx/ar71xx.h>
 #include <asm/mach-ar71xx/mach-rb750.h>
@@ -74,13 +75,14 @@ static void rb750_nand_write(const u8 *buf, unsigned len)
 {
 	void __iomem *base = ar71xx_gpio_base;
 	u32 out;
+	u32 t;
 	unsigned i;
 
 	/* set data lines to output mode */
-	__raw_writel(__raw_readl(base + GPIO_REG_OE) | RB750_NAND_DATA_BITS,
-		     base + GPIO_REG_OE);
+	t = __raw_readl(base + AR71XX_GPIO_REG_OE);
+	__raw_writel(t | RB750_NAND_DATA_BITS, base + AR71XX_GPIO_REG_OE);
 
-	out = __raw_readl(base + GPIO_REG_OUT);
+	out = __raw_readl(base + AR71XX_GPIO_REG_OUT);
 	out &= ~(RB750_NAND_DATA_BITS | RB750_NAND_NWE);
 	for (i = 0; i != len; i++) {
 		u32 data;
@@ -88,18 +90,18 @@ static void rb750_nand_write(const u8 *buf, unsigned len)
 		data = buf[i];
 		data <<= RB750_NAND_DATA_SHIFT;
 		data |= out;
-		__raw_writel(data, base + GPIO_REG_OUT);
+		__raw_writel(data, base + AR71XX_GPIO_REG_OUT);
 
-		__raw_writel(data | RB750_NAND_NWE, base + GPIO_REG_OUT);
+		__raw_writel(data | RB750_NAND_NWE, base + AR71XX_GPIO_REG_OUT);
 		/* flush write */
-		__raw_readl(base + GPIO_REG_OUT);
+		__raw_readl(base + AR71XX_GPIO_REG_OUT);
 	}
 
 	/* set data lines to input mode */
-	__raw_writel(__raw_readl(base + GPIO_REG_OE) & ~RB750_NAND_DATA_BITS,
-		     base + GPIO_REG_OE);
+	t = __raw_readl(base + AR71XX_GPIO_REG_OE);
+	__raw_writel(t & ~RB750_NAND_DATA_BITS, base + AR71XX_GPIO_REG_OE);
 	/* flush write */
-	__raw_readl(base + GPIO_REG_OE);
+	__raw_readl(base + AR71XX_GPIO_REG_OE);
 }
 
 static int rb750_nand_read_verify(u8 *read_buf, unsigned len,
@@ -112,15 +114,16 @@ static int rb750_nand_read_verify(u8 *read_buf, unsigned len,
 		u8 data;
 
 		/* activate RE line */
-		__raw_writel(RB750_NAND_NRE, base + GPIO_REG_CLEAR);
+		__raw_writel(RB750_NAND_NRE, base + AR71XX_GPIO_REG_CLEAR);
 		/* flush write */
-		__raw_readl(base + GPIO_REG_CLEAR);
+		__raw_readl(base + AR71XX_GPIO_REG_CLEAR);
 
 		/* read input lines */
-		data = __raw_readl(base + GPIO_REG_IN) >> RB750_NAND_DATA_SHIFT;
+		data = __raw_readl(base + AR71XX_GPIO_REG_IN) >>
+		       RB750_NAND_DATA_SHIFT;
 
 		/* deactivate RE line */
-		__raw_writel(RB750_NAND_NRE, base + GPIO_REG_SET);
+		__raw_writel(RB750_NAND_NRE, base + AR71XX_GPIO_REG_SET);
 
 		if (read_buf)
 			read_buf[i] = data;
@@ -135,8 +138,9 @@ static void rb750_nand_select_chip(struct mtd_info *mtd, int chip)
 {
 	void __iomem *base = ar71xx_gpio_base;
 	u32 func;
+	u32 t;
 
-	func = __raw_readl(base + GPIO_REG_FUNC);
+	func = __raw_readl(base + AR71XX_GPIO_REG_FUNC);
 	if (chip >= 0) {
 		/* disable latch */
 		rb750_latch_change(RB750_LVC573_LE, 0);
@@ -146,27 +150,27 @@ static void rb750_nand_select_chip(struct mtd_info *mtd, int chip)
 					   AR724X_GPIO_FUNC_SPI_EN);
 
 		/* set input mode for data lines */
-		__raw_writel(__raw_readl(base + GPIO_REG_OE) &
-			     ~RB750_NAND_INPUT_BITS,
-			     base + GPIO_REG_OE);
+		t = __raw_readl(base + AR71XX_GPIO_REG_OE);
+		__raw_writel(t & ~RB750_NAND_INPUT_BITS,
+			     base + AR71XX_GPIO_REG_OE);
 
 		/* deactivate RE and WE lines */
 		__raw_writel(RB750_NAND_NRE | RB750_NAND_NWE,
-			     base + GPIO_REG_SET);
+			     base + AR71XX_GPIO_REG_SET);
 		/* flush write */
-		(void) __raw_readl(base + GPIO_REG_SET);
+		(void) __raw_readl(base + AR71XX_GPIO_REG_SET);
 
 		/* activate CE line */
-		__raw_writel(RB750_NAND_NCE, base + GPIO_REG_CLEAR);
+		__raw_writel(RB750_NAND_NCE, base + AR71XX_GPIO_REG_CLEAR);
 	} else {
 		/* deactivate CE line */
-		__raw_writel(RB750_NAND_NCE, base + GPIO_REG_SET);
+		__raw_writel(RB750_NAND_NCE, base + AR71XX_GPIO_REG_SET);
 		/* flush write */
-		(void) __raw_readl(base + GPIO_REG_SET);
+		(void) __raw_readl(base + AR71XX_GPIO_REG_SET);
 
-		__raw_writel(__raw_readl(base + GPIO_REG_OE) |
-			     RB750_NAND_IO0 | RB750_NAND_RDY,
-			     base + GPIO_REG_OE);
+		t = __raw_readl(base + AR71XX_GPIO_REG_OE);
+		__raw_writel(t | RB750_NAND_IO0 | RB750_NAND_RDY,
+			     base + AR71XX_GPIO_REG_OE);
 
 		/* restore alternate functions */
 		ar71xx_gpio_function_setup(AR724X_GPIO_FUNC_SPI_EN,
@@ -181,7 +185,7 @@ static int rb750_nand_dev_ready(struct mtd_info *mtd)
 {
 	void __iomem *base = ar71xx_gpio_base;
 
-	return !!(__raw_readl(base + GPIO_REG_IN) & RB750_NAND_RDY);
+	return !!(__raw_readl(base + AR71XX_GPIO_REG_IN) & RB750_NAND_RDY);
 }
 
 static void rb750_nand_cmd_ctrl(struct mtd_info *mtd, int cmd,
@@ -191,15 +195,15 @@ static void rb750_nand_cmd_ctrl(struct mtd_info *mtd, int cmd,
 		void __iomem *base = ar71xx_gpio_base;
 		u32 t;
 
-		t = __raw_readl(base + GPIO_REG_OUT);
+		t = __raw_readl(base + AR71XX_GPIO_REG_OUT);
 
 		t &= ~(RB750_NAND_CLE | RB750_NAND_ALE);
 		t |= (ctrl & NAND_CLE) ? RB750_NAND_CLE : 0;
 		t |= (ctrl & NAND_ALE) ? RB750_NAND_ALE : 0;
 
-		__raw_writel(t, base + GPIO_REG_OUT);
+		__raw_writel(t, base + AR71XX_GPIO_REG_OUT);
 		/* flush write */
-		__raw_readl(base + GPIO_REG_OUT);
+		__raw_readl(base + AR71XX_GPIO_REG_OUT);
 	}
 
 	if (cmd != NAND_CMD_NONE) {
@@ -234,23 +238,24 @@ static void __init rb750_nand_gpio_init(void)
 {
 	void __iomem *base = ar71xx_gpio_base;
 	u32 out;
+	u32 t;
 
-	out = __raw_readl(base + GPIO_REG_OUT);
+	out = __raw_readl(base + AR71XX_GPIO_REG_OUT);
 
 	/* setup output levels */
 	__raw_writel(RB750_NAND_NCE | RB750_NAND_NRE | RB750_NAND_NWE,
-		     base + GPIO_REG_SET);
+		     base + AR71XX_GPIO_REG_SET);
 
 	__raw_writel(RB750_NAND_ALE | RB750_NAND_CLE,
-		     base + GPIO_REG_CLEAR);
+		     base + AR71XX_GPIO_REG_CLEAR);
 
 	/* setup input lines */
-	__raw_writel(__raw_readl(base + GPIO_REG_OE) & ~(RB750_NAND_INPUT_BITS),
-		     base + GPIO_REG_OE);
+	t = __raw_readl(base + AR71XX_GPIO_REG_OE);
+	__raw_writel(t & ~(RB750_NAND_INPUT_BITS), base + AR71XX_GPIO_REG_OE);
 
 	/* setup output lines */
-	__raw_writel(__raw_readl(base + GPIO_REG_OE) | RB750_NAND_OUTPUT_BITS,
-		     base + GPIO_REG_OE);
+	t = __raw_readl(base + AR71XX_GPIO_REG_OE);
+	__raw_writel(t | RB750_NAND_OUTPUT_BITS, base + AR71XX_GPIO_REG_OE);
 
 	rb750_latch_change(~out & RB750_NAND_IO0, out & RB750_NAND_IO0);
 }
@@ -286,7 +291,7 @@ static int __init rb750_nand_probe(struct platform_device *pdev)
 
 	platform_set_drvdata(pdev, info);
 
-	ret = nand_scan_ident(&info->mtd, 1);
+	ret = nand_scan_ident(&info->mtd, 1, NULL);
 	if (ret) {
 		ret = -ENXIO;
 		goto err_free_info;
@@ -312,11 +317,11 @@ static int __init rb750_nand_probe(struct platform_device *pdev)
 
 	return 0;
 
- err_release_nand:
+err_release_nand:
 	nand_release(&info->mtd);
- err_set_drvdata:
+err_set_drvdata:
 	platform_set_drvdata(pdev, NULL);
- err_free_info:
+err_free_info:
 	kfree(info);
 	return ret;
 }
diff --git a/drivers/mtd/redboot.c b/drivers/mtd/redboot.c
index 4938bd0..9225201 100644
--- a/drivers/mtd/redboot.c
+++ b/drivers/mtd/redboot.c
@@ -75,31 +75,32 @@ static int parse_redboot_partitions(struct mtd_info *master,
 	static char nullstring[] = "unallocated";
 #endif
 
+	buf = vmalloc(master->erasesize);
+	if (!buf)
+		return -ENOMEM;
+
+ restart:
 	if ( directory < 0 ) {
 		offset = master->size + directory * master->erasesize;
-		while (master->block_isbad && 
+		while (master->block_isbad &&
 		       master->block_isbad(master, offset)) {
 			if (!offset) {
 			nogood:
 				printk(KERN_NOTICE "Failed to find a non-bad block to check for RedBoot partition table\n");
+				vfree(buf);
 				return -EIO;
 			}
 			offset -= master->erasesize;
 		}
 	} else {
 		offset = directory * master->erasesize;
-		while (master->block_isbad && 
+		while (master->block_isbad &&
 		       master->block_isbad(master, offset)) {
 			offset += master->erasesize;
 			if (offset == master->size)
 				goto nogood;
 		}
 	}
-	buf = vmalloc(master->erasesize);
-
-	if (!buf)
-		return -ENOMEM;
-
 	printk(KERN_NOTICE "Searching for RedBoot partition table in %s at offset 0x%lx\n",
 	       master->name, offset);
 
@@ -171,6 +172,11 @@ static int parse_redboot_partitions(struct mtd_info *master,
 	}
 	if (i == numslots) {
 		/* Didn't find it */
+		if (offset + master->erasesize < master->size) {
+			/* not at the end of the flash yet, maybe next block :) */
+			directory++;
+			goto restart;
+		}
 		printk(KERN_NOTICE "No RedBoot partition table detected in %s\n",
 		       master->name);
 		ret = 0;
@@ -267,14 +273,21 @@ static int parse_redboot_partitions(struct mtd_info *master,
 #endif
 		names += strlen(names)+1;
 
-#ifdef CONFIG_MTD_REDBOOT_PARTS_UNALLOCATED
 		if(fl->next && fl->img->flash_base + fl->img->size + master->erasesize <= fl->next->img->flash_base) {
-			i++;
-			parts[i].offset = parts[i-1].size + parts[i-1].offset;
-			parts[i].size = fl->next->img->flash_base - parts[i].offset;
-			parts[i].name = nullname;
-		}
+			if (!strcmp(parts[i].name, "rootfs")) {
+				parts[i].size = fl->next->img->flash_base;
+				parts[i].size &= ~(master->erasesize - 1);
+				parts[i].size -= parts[i].offset;
+#ifdef CONFIG_MTD_REDBOOT_PARTS_UNALLOCATED
+				nrparts--;
+			} else {
+				i++;
+				parts[i].offset = parts[i-1].size + parts[i-1].offset;
+				parts[i].size = fl->next->img->flash_base - parts[i].offset;
+				parts[i].name = nullname;
 #endif
+			}
+		}
 		tmp_fl = fl;
 		fl = fl->next;
 		kfree(tmp_fl);
diff --git a/drivers/mtd/wrt160nl_part.c b/drivers/mtd/wrt160nl_part.c
index e42b3d4..eabb47e 100644
--- a/drivers/mtd/wrt160nl_part.c
+++ b/drivers/mtd/wrt160nl_part.c
@@ -78,6 +78,10 @@ struct wrt160nl_header {
 
 static struct mtd_partition trx_parts[TRX_PARTS];
 
+#define WRT160NL_UBOOT_LEN	0x40000
+#define WRT160NL_ART_LEN	0x10000
+#define WRT160NL_NVRAM_LEN	0x10000
+
 static int wrt160nl_parse_partitions(struct mtd_info *master,
 				     struct mtd_partition **pparts,
 				     unsigned long origin)
@@ -87,6 +91,9 @@ static int wrt160nl_parse_partitions(struct mtd_info *master,
 	struct uimage_header *uheader;
 	size_t retlen;
 	unsigned int kernel_len;
+	unsigned int uboot_len = max(master->erasesize, WRT160NL_UBOOT_LEN);
+	unsigned int nvram_len = max(master->erasesize, WRT160NL_NVRAM_LEN);
+	unsigned int art_len = max(master->erasesize, WRT160NL_ART_LEN);
 	int ret;
 
 	header = vmalloc(sizeof(*header));
@@ -95,7 +102,7 @@ static int wrt160nl_parse_partitions(struct mtd_info *master,
 		goto out;
 	}
 
-	ret = master->read(master, 4 * master->erasesize, sizeof(*header),
+	ret = master->read(master, uboot_len, sizeof(*header),
 			   &retlen, (void *) header);
 	if (ret)
 		goto free_hdr;
@@ -123,11 +130,12 @@ static int wrt160nl_parse_partitions(struct mtd_info *master,
 		goto free_hdr;
 	}
 
-	kernel_len = le32_to_cpu(theader->offsets[1]) + sizeof(struct cybertan_header);
+	kernel_len = le32_to_cpu(theader->offsets[1]) +
+		sizeof(struct cybertan_header);
 
 	trx_parts[0].name = "u-boot";
 	trx_parts[0].offset = 0;
-	trx_parts[0].size = 4 * master->erasesize;
+	trx_parts[0].size = uboot_len;
 	trx_parts[0].mask_flags = MTD_WRITEABLE;
 
 	trx_parts[1].name = "kernel";
@@ -137,30 +145,31 @@ static int wrt160nl_parse_partitions(struct mtd_info *master,
 
 	trx_parts[2].name = "rootfs";
 	trx_parts[2].offset = trx_parts[1].offset + trx_parts[1].size;
-	trx_parts[2].size = master->size - 6 * master->erasesize - trx_parts[1].size;
+	trx_parts[2].size = master->size - uboot_len - nvram_len - art_len -
+		trx_parts[1].size;
 	trx_parts[2].mask_flags = 0;
 
 	trx_parts[3].name = "nvram";
-	trx_parts[3].offset = master->size - 2 * master->erasesize;
-	trx_parts[3].size = master->erasesize;
+	trx_parts[3].offset = master->size - nvram_len - art_len;
+	trx_parts[3].size = nvram_len;
 	trx_parts[3].mask_flags = MTD_WRITEABLE;
 
 	trx_parts[4].name = "art";
-	trx_parts[4].offset = master->size - master->erasesize;
-	trx_parts[4].size = master->erasesize;
+	trx_parts[4].offset = master->size - art_len;
+	trx_parts[4].size = art_len;
 	trx_parts[4].mask_flags = MTD_WRITEABLE;
 
 	trx_parts[5].name = "firmware";
-	trx_parts[5].offset = 4 * master->erasesize;
-	trx_parts[5].size = master->size - 6 * master->erasesize;
+	trx_parts[5].offset = uboot_len;
+	trx_parts[5].size = master->size - uboot_len - nvram_len - art_len;
 	trx_parts[5].mask_flags = 0;
 
 	*pparts = trx_parts;
 	ret = TRX_PARTS;
 
- free_hdr:
+free_hdr:
 	vfree(header);
- out:
+out:
 	return ret;
 }
 
diff --git a/fs/partitions/check.c b/fs/partitions/check.c
index d545e97..a601759 100644
--- a/fs/partitions/check.c
+++ b/fs/partitions/check.c
@@ -664,6 +664,7 @@ rescan:
 	kfree(state);
 	return 0;
 }
+EXPORT_SYMBOL(rescan_partitions);
 
 unsigned char *read_dev_sector(struct block_device *bdev, sector_t n, Sector *p)
 {
diff --git a/include/linux/mtd/mtd.h b/include/linux/mtd/mtd.h
index 2541fb8..f2e04ee 100644
--- a/include/linux/mtd/mtd.h
+++ b/include/linux/mtd/mtd.h
@@ -57,6 +57,10 @@ struct erase_info {
 	u_long priv;
 	u_char state;
 	struct erase_info *next;
+
+	u8 *erase_buf;
+	u32 erase_buf_ofs;
+	bool partial_start;
 };
 
 struct mtd_erase_region_info {
@@ -125,6 +129,7 @@ struct nand_ecclayout {
 	struct nand_oobfree oobfree[MTD_MAX_OOBFREE_ENTRIES_LARGE];
 };
 
+struct mtd_info;
 struct mtd_info {
 	u_char type;
 	uint32_t flags;
@@ -277,6 +282,9 @@ struct mtd_info {
 	struct device dev;
 	int usecount;
 
+	int (*refresh_device)(struct mtd_info *mtd);
+	struct mtd_info *split;
+
 	/* If the driver is something smart, like UBI, it may need to maintain
 	 * its own reference counting. The below functions are only for driver.
 	 * The driver may register its callbacks. These callbacks are not
@@ -327,6 +335,7 @@ struct mtd_partition;
 extern int mtd_device_register(struct mtd_info *master,
 			       const struct mtd_partition *parts,
 			       int nr_parts);
+extern int mtd_device_refresh(struct mtd_info *master);
 extern int mtd_device_unregister(struct mtd_info *master);
 extern struct mtd_info *get_mtd_device(struct mtd_info *mtd, int num);
 extern int __get_mtd_device(struct mtd_info *mtd);
diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index c2b9ac4..ba0384a 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -625,6 +625,7 @@ struct platform_nand_chip {
 	int chip_delay;
 	unsigned int options;
 	const char **part_probe_types;
+	int (*chip_fixup)(struct mtd_info *mtd);
 	void (*set_parts)(uint64_t size, struct platform_nand_chip *chip);
 	void *priv;
 };
diff --git a/include/linux/mtd/partitions.h b/include/linux/mtd/partitions.h
index 3a6f037..643b290 100644
--- a/include/linux/mtd/partitions.h
+++ b/include/linux/mtd/partitions.h
@@ -33,13 +33,16 @@
  * Note: writeable partitions require their size and offset be
  * erasesize aligned (e.g. use MTDPART_OFS_NEXTBLK).
  */
+struct mtd_info;
 
+struct mtd_partition;
 struct mtd_partition {
 	char *name;			/* identifier string */
 	uint64_t size;			/* partition size */
 	uint64_t offset;		/* offset within the master MTD space */
 	uint32_t mask_flags;		/* master MTD flags to mask out for this partition */
 	struct nand_ecclayout *ecclayout;	/* out of band layout for this partition (NAND only) */
+	int (*refresh_partition)(struct mtd_info *);
 };
 
 #define MTDPART_OFS_NXTBLK	(-2)
@@ -47,7 +50,6 @@ struct mtd_partition {
 #define MTDPART_SIZ_FULL	(0)
 
 
-struct mtd_info;
 
 /*
  * Functions dealing with the various ways of partitioning the space
diff --git a/include/mtd/mtd-abi.h b/include/mtd/mtd-abi.h
index 2f7d45b..278eafb 100644
--- a/include/mtd/mtd-abi.h
+++ b/include/mtd/mtd-abi.h
@@ -127,6 +127,7 @@ struct otp_info {
 #define MEMWRITEOOB64		_IOWR('M', 21, struct mtd_oob_buf64)
 #define MEMREADOOB64		_IOWR('M', 22, struct mtd_oob_buf64)
 #define MEMISLOCKED		_IOR('M', 23, struct erase_info_user)
+#define MTDREFRESH		_IO('M', 50)
 
 /*
  * Obsolete legacy interface. Keep it in order not to break userspace
-- 
1.7.4.1

