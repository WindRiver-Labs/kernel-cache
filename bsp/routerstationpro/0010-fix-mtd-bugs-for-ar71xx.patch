From 9503f8b0ac426cdc77a74b912b6f5fa41938e5c5 Mon Sep 17 00:00:00 2001
From: Zumeng Chen <zumeng.chen@windriver.com>
Date: Wed, 29 Sep 2010 10:29:31 +0800
Subject: [PATCH 10/41] fix mtd bugs for ar71xx

Which is downloaded from the following:
  https://dev.openwrt.org/browser/branches
  branches_backfire_target_linux_ar71xx_files-r23140.zip

Integrated-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 drivers/watchdog/Kconfig      |    7 +
 drivers/watchdog/Makefile     |    4 +
 drivers/watchdog/ar71xx_wdt.c |  270 +++++++++++++++++++++++++++++++++++++++++
 3 files changed, 281 insertions(+), 0 deletions(-)
 create mode 100644 drivers/watchdog/ar71xx_wdt.c

diff --git a/drivers/watchdog/Kconfig b/drivers/watchdog/Kconfig
index 21d816e..1d524e6 100644
--- a/drivers/watchdog/Kconfig
+++ b/drivers/watchdog/Kconfig
@@ -994,6 +994,13 @@ config LANTIQ_WDT
 	help
 	  Hardware driver for the Lantiq SoC Watchdog Timer.
 
+config AR71XX_WDT
+	tristate "Atheros AR71xx Watchdog Timer"
+	depends on ATHEROS_AR71XX
+	help
+	  Hardware driver for the built-in watchdog timer on the Atheros
+	  AR71xx SoCs.
+
 # PARISC Architecture
 
 # POWERPC Architecture
diff --git a/drivers/watchdog/Makefile b/drivers/watchdog/Makefile
index ed26f70..14f88f8 100644
--- a/drivers/watchdog/Makefile
+++ b/drivers/watchdog/Makefile
@@ -121,6 +121,7 @@ obj-$(CONFIG_PNX833X_WDT) += pnx833x_wdt.o
 obj-$(CONFIG_SIBYTE_WDOG) += sb_wdog.o
 obj-$(CONFIG_AR7_WDT) += ar7_wdt.o
 obj-$(CONFIG_TXX9_WDT) += txx9wdt.o
+
 obj-$(CONFIG_OCTEON_WDT) += octeon-wdt.o
 octeon-wdt-y := octeon-wdt-main.o octeon-wdt-nmi.o
 obj-$(CONFIG_LANTIQ_WDT) += lantiq_wdt.o
@@ -159,3 +160,6 @@ obj-$(CONFIG_WM831X_WATCHDOG) += wm831x_wdt.o
 obj-$(CONFIG_WM8350_WATCHDOG) += wm8350_wdt.o
 obj-$(CONFIG_MAX63XX_WATCHDOG) += max63xx_wdt.o
 obj-$(CONFIG_SOFT_WATCHDOG) += softdog.o
+
+obj-$(CONFIG_AR71XX_WDT) += ar71xx_wdt.o
+
diff --git a/drivers/watchdog/ar71xx_wdt.c b/drivers/watchdog/ar71xx_wdt.c
new file mode 100644
index 0000000..c1bf463
--- /dev/null
+++ b/drivers/watchdog/ar71xx_wdt.c
@@ -0,0 +1,270 @@
+/*
+ * Driver for the Atheros AR71xx SoC's built-in hardware watchdog timer.
+ *
+ * Copyright (C) 2008 Gabor Juhos <juhosg@openwrt.org>
+ * Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ * This driver was based on: drivers/watchdog/ixp4xx_wdt.c
+ *	Author: Deepak Saxena <dsaxena@plexity.net>
+ *	Copyright 2004 (c) MontaVista, Software, Inc.
+ *
+ * which again was based on sa1100 driver,
+ *	Copyright (C) 2000 Oleg Drokin <green@crimea.edu>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation.
+ *
+ */
+
+#include <linux/bitops.h>
+#include <linux/errno.h>
+#include <linux/fs.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/miscdevice.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/platform_device.h>
+#include <linux/types.h>
+#include <linux/watchdog.h>
+
+#include <asm/mach-ar71xx/ar71xx.h>
+
+#define DRV_NAME	"ar71xx-wdt"
+#define DRV_DESC	"Atheros AR71xx hardware watchdog driver"
+#define DRV_VERSION	"0.1.0"
+
+#define WDT_TIMEOUT	15	/* seconds */
+
+static int nowayout = WATCHDOG_NOWAYOUT;
+
+#ifdef CONFIG_WATCHDOG_NOWAYOUT
+module_param(nowayout, int, 0);
+MODULE_PARM_DESC(nowayout, "Watchdog cannot be stopped once started "
+			   "(default=" __MODULE_STRING(WATCHDOG_NOWAYOUT) ")");
+#endif
+
+static unsigned long wdt_flags;
+
+#define WDT_FLAGS_BUSY		0
+#define WDT_FLAGS_EXPECT_CLOSE	1
+
+static int wdt_timeout = WDT_TIMEOUT;
+static int boot_status;
+static int max_timeout;
+
+static void inline ar71xx_wdt_keepalive(void)
+{
+	ar71xx_reset_wr(AR71XX_RESET_REG_WDOG, ar71xx_ahb_freq * wdt_timeout);
+}
+
+static void inline ar71xx_wdt_enable(void)
+{
+	printk(KERN_DEBUG DRV_NAME ": enabling watchdog timer\n");
+	ar71xx_wdt_keepalive();
+	ar71xx_reset_wr(AR71XX_RESET_REG_WDOG_CTRL, WDOG_CTRL_ACTION_FCR);
+}
+
+static void inline ar71xx_wdt_disable(void)
+{
+	printk(KERN_DEBUG DRV_NAME ": disabling watchdog timer\n");
+	ar71xx_reset_wr(AR71XX_RESET_REG_WDOG_CTRL, WDOG_CTRL_ACTION_NONE);
+}
+
+static int ar71xx_wdt_set_timeout(int val)
+{
+	if (val < 1 || val > max_timeout)
+		return -EINVAL;
+
+	wdt_timeout = val;
+	ar71xx_wdt_keepalive();
+
+	printk(KERN_DEBUG DRV_NAME ": timeout=%d secs\n", wdt_timeout);
+
+	return 0;
+}
+
+static int ar71xx_wdt_open(struct inode *inode, struct file *file)
+{
+	if (test_and_set_bit(WDT_FLAGS_BUSY, &wdt_flags))
+		return -EBUSY;
+
+	clear_bit(WDT_FLAGS_EXPECT_CLOSE, &wdt_flags);
+
+	ar71xx_wdt_enable();
+
+	return nonseekable_open(inode, file);
+}
+
+static int ar71xx_wdt_release(struct inode *inode, struct file *file)
+{
+	if (test_bit(WDT_FLAGS_EXPECT_CLOSE, &wdt_flags)) {
+		ar71xx_wdt_disable();
+	} else {
+		printk(KERN_CRIT DRV_NAME ": device closed unexpectedly, "
+					"watchdog timer will not stop!\n");
+	}
+
+	clear_bit(WDT_FLAGS_BUSY, &wdt_flags);
+	clear_bit(WDT_FLAGS_EXPECT_CLOSE, &wdt_flags);
+
+	return 0;
+}
+
+static ssize_t ar71xx_wdt_write(struct file *file, const char *data,
+				size_t len, loff_t *ppos)
+{
+        if (len) {
+		if (!nowayout) {
+			size_t i;
+
+			clear_bit(WDT_FLAGS_EXPECT_CLOSE, &wdt_flags);
+
+			for (i = 0; i != len; i++) {
+				char c;
+
+				if (get_user(c, data + i))
+					return -EFAULT;
+
+				if (c == 'V')
+					set_bit(WDT_FLAGS_EXPECT_CLOSE,
+						&wdt_flags);
+			}
+		}
+
+		ar71xx_wdt_keepalive();
+	}
+
+	return len;
+}
+
+static struct watchdog_info ar71xx_wdt_info = {
+	.options		= WDIOF_SETTIMEOUT | WDIOF_KEEPALIVEPING |
+				  WDIOF_MAGICCLOSE | WDIOF_CARDRESET,
+	.firmware_version 	= 0,
+	.identity		= "AR71XX watchdog",
+};
+
+static int ar71xx_wdt_ioctl(struct inode *inode, struct file *file,
+			    unsigned int cmd, unsigned long arg)
+{
+	int t;
+	int ret;
+
+	switch (cmd) {
+	case WDIOC_GETSUPPORT:
+		ret = copy_to_user((struct watchdog_info *)arg,
+				   &ar71xx_wdt_info,
+				   sizeof(&ar71xx_wdt_info)) ? -EFAULT : 0;
+		break;
+
+	case WDIOC_GETSTATUS:
+		ret = put_user(0, (int *)arg) ? -EFAULT : 0;
+		break;
+
+	case WDIOC_GETBOOTSTATUS:
+		ret = put_user(boot_status, (int *)arg) ? -EFAULT : 0;
+		break;
+
+	case WDIOC_KEEPALIVE:
+		ar71xx_wdt_keepalive();
+		ret = 0;
+		break;
+
+	case WDIOC_SETTIMEOUT:
+		ret = get_user(t, (int *)arg) ? -EFAULT : 0;
+		if (ret)
+			break;
+
+		ret = ar71xx_wdt_set_timeout(t);
+		if (ret)
+			break;
+
+		/* fallthrough */
+	case WDIOC_GETTIMEOUT:
+		ret = put_user(wdt_timeout, (int *)arg) ? -EFAULT : 0;
+		break;
+
+	default:
+		ret = -ENOTTY;
+		break;
+	}
+
+	return ret;
+}
+
+static const struct file_operations ar71xx_wdt_fops = {
+	.owner		= THIS_MODULE,
+	.write		= ar71xx_wdt_write,
+	.ioctl		= ar71xx_wdt_ioctl,
+	.open		= ar71xx_wdt_open,
+	.release	= ar71xx_wdt_release,
+};
+
+static struct miscdevice ar71xx_wdt_miscdev = {
+	.minor = WATCHDOG_MINOR,
+	.name = "watchdog",
+	.fops = &ar71xx_wdt_fops,
+};
+
+static int __devinit ar71xx_wdt_probe(struct platform_device *pdev)
+{
+	int ret;
+
+	max_timeout = (0xfffffffful / ar71xx_ahb_freq);
+	wdt_timeout = (max_timeout < WDT_TIMEOUT) ? max_timeout : WDT_TIMEOUT;
+
+	boot_status =
+		(ar71xx_reset_rr(AR71XX_RESET_REG_WDOG_CTRL) & WDOG_CTRL_LAST_RESET) ?
+		WDIOF_CARDRESET : 0;
+
+	ret = misc_register(&ar71xx_wdt_miscdev);
+	if (ret)
+		goto err_out;
+
+	printk(KERN_INFO DRV_DESC " version " DRV_VERSION "\n");
+
+	printk(KERN_DEBUG DRV_NAME ": timeout=%d secs (max=%d)\n",
+					wdt_timeout, max_timeout);
+
+	return 0;
+
+err_out:
+	return ret;
+}
+
+static int __devexit ar71xx_wdt_remove(struct platform_device *pdev)
+{
+	misc_deregister(&ar71xx_wdt_miscdev);
+	return 0;
+}
+
+static struct platform_driver ar71xx_wdt_driver = {
+	.probe		= ar71xx_wdt_probe,
+	.remove		= __devexit_p(ar71xx_wdt_remove),
+	.driver		= {
+		.name	= DRV_NAME,
+		.owner	= THIS_MODULE,
+	},
+};
+
+static int __init ar71xx_wdt_init(void)
+{
+	return platform_driver_register(&ar71xx_wdt_driver);
+}
+module_init(ar71xx_wdt_init);
+
+static void __exit ar71xx_wdt_exit(void)
+{
+	platform_driver_unregister(&ar71xx_wdt_driver);
+}
+module_exit(ar71xx_wdt_exit);
+
+MODULE_DESCRIPTION(DRV_DESC);
+MODULE_VERSION(DRV_VERSION);
+MODULE_AUTHOR("Gabor Juhos <juhosg@openwrt.org");
+MODULE_AUTHOR("Imre Kaloz <kaloz@openwrt.org");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("platform:" DRV_NAME);
+MODULE_ALIAS_MISCDEV(WATCHDOG_MINOR);
-- 
1.7.4.1

