From 039e9a3aeba9cc55d233f553b23782abb404ab72 Mon Sep 17 00:00:00 2001
From: Zumeng Chen <zumeng.chen@windriver.com>
Date: Thu, 15 Dec 2011 17:12:01 +0800
Subject: [PATCH 37/41] Updates some devices fixes from 3.0

which from the following git repo.
  git://nbd.name/openwrt.git

810-pci_disable_common_quirks.patch
811-pci_disable_usb_common_quirks.patch
820-usb_add_usb_find_device_by_name.patch
830-ledtrig_morse.patch
831-ledtrig_netdev.patch
832-ledtrig_usbdev.patch
833-gpio_buttons.patch
835-gpiodev.patch
840-rtc7301.patch
850-glamo_headers.patch
860-01_hotpluggable_spi_gpio.patch
861-04_spi_gpio_implement_spi_delay.patch
862-gpio_spi_driver.patch
863-gpiommc.patch
864-gpiommc_configfs_locking.patch
870-hifn795x_byteswap.patch

Integrated-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 drivers/char/Kconfig              |    8 +
 drivers/char/Makefile             |    1 +
 drivers/char/gpio_dev.c           |  179 +++++++++++++++
 drivers/crypto/hifn_795x.c        |    4 +-
 drivers/input/misc/Kconfig        |   16 ++
 drivers/input/misc/Makefile       |    1 +
 drivers/input/misc/gpio_buttons.c |  232 +++++++++++++++++++
 drivers/leds/Kconfig              |   18 ++
 drivers/leds/Makefile             |    3 +
 drivers/leds/leds-wndr3700-usb.c  |   75 ++++++
 drivers/leds/ledtrig-morse.c      |  366 ++++++++++++++++++++++++++++++
 drivers/leds/ledtrig-netdev.c     |  451 +++++++++++++++++++++++++++++++++++++
 drivers/leds/ledtrig-usbdev.c     |  348 ++++++++++++++++++++++++++++
 drivers/net/phy/Kconfig           |    4 +
 drivers/pci/Kconfig               |    6 +
 drivers/pci/quirks.c              |    4 +
 drivers/rtc/Kconfig               |    9 +
 drivers/rtc/Makefile              |    1 +
 drivers/rtc/rtc-rtc7301.c         |  219 ++++++++++++++++++
 drivers/spi/spi_gpio.c            |   13 +-
 drivers/usb/core/usb.c            |   65 ++++++
 drivers/usb/host/pci-quirks.c     |    4 +
 include/linux/Kbuild              |    2 +
 include/linux/fb.h                |    1 +
 include/linux/usb.h               |    1 +
 25 files changed, 2023 insertions(+), 8 deletions(-)
 create mode 100644 drivers/char/gpio_dev.c
 create mode 100644 drivers/input/misc/gpio_buttons.c
 create mode 100644 drivers/leds/leds-wndr3700-usb.c
 create mode 100644 drivers/leds/ledtrig-morse.c
 create mode 100644 drivers/leds/ledtrig-netdev.c
 create mode 100644 drivers/leds/ledtrig-usbdev.c
 create mode 100644 drivers/rtc/rtc-rtc7301.c

diff --git a/drivers/char/Kconfig b/drivers/char/Kconfig
index 49502bc..047e613 100644
--- a/drivers/char/Kconfig
+++ b/drivers/char/Kconfig
@@ -511,6 +511,14 @@ config NSC_GPIO
 	  pc8736x_gpio drivers.  If those drivers are built as
 	  modules, this one will be too, named nsc_gpio
 
+config GPIO_DEVICE
+	tristate "GPIO device support"
+	depends on GENERIC_GPIO
+	help
+	  Say Y to enable Linux GPIO device support.  This allows control of
+	  GPIO pins using a character device
+
+
 config RAW_DRIVER
 	tristate "RAW driver (/dev/raw/rawN)"
 	depends on BLOCK
diff --git a/drivers/char/Makefile b/drivers/char/Makefile
index 7a00672..96979f1 100644
--- a/drivers/char/Makefile
+++ b/drivers/char/Makefile
@@ -47,6 +47,7 @@ obj-$(CONFIG_NWFLASH)		+= nwflash.o
 obj-$(CONFIG_SCx200_GPIO)	+= scx200_gpio.o
 obj-$(CONFIG_PC8736x_GPIO)	+= pc8736x_gpio.o
 obj-$(CONFIG_NSC_GPIO)		+= nsc_gpio.o
+obj-$(CONFIG_GPIO_DEVICE)	+= gpio_dev.o
 obj-$(CONFIG_GPIO_TB0219)	+= tb0219.o
 obj-$(CONFIG_TELCLOCK)		+= tlclk.o
 
diff --git a/drivers/char/gpio_dev.c b/drivers/char/gpio_dev.c
new file mode 100644
index 0000000..0f428bd
--- /dev/null
+++ b/drivers/char/gpio_dev.c
@@ -0,0 +1,179 @@
+/*
+ * character device wrapper for generic gpio layer
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA02111-1307USA
+ *
+ * Feedback, Bugs...  blogic@openwrt.org
+ *
+ * dpg 20100106
+ */
+
+#include <linux/module.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <asm/uaccess.h>
+#include <asm/io.h>
+#include <asm/gpio.h>
+#include <asm/atomic.h>
+#include <linux/init.h>
+#include <linux/genhd.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/gpio_dev.h>
+#include <linux/fs.h>
+
+#define DRVNAME		"gpiodev"
+#define DEVNAME		"gpio"
+
+static int dev_major;
+static struct class *gpiodev_class;
+
+
+/* third argument of user space ioctl ('arg' here) contains the <pin> */
+static int
+gpio_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+{
+	int retval = 0;
+
+	switch (cmd)
+	{
+	case GPIO_GET:
+		retval = gpio_get_value(arg);
+		break;
+	case GPIO_SET:
+		gpio_set_value(arg, 1);
+		break;
+	case GPIO_CLEAR:
+		gpio_set_value(arg, 0);
+		break;
+	case GPIO_DIR_IN:
+		retval = gpio_direction_input(arg);
+		break;
+	case GPIO_DIR_OUT:
+		retval = gpio_direction_output(arg, 0);
+		break;
+	case GPIO_DIR_HIGH:
+		retval = gpio_direction_output(arg, 1);
+		break;
+	case GPIO_REQUEST:
+		/* should be first ioctl operation on <pin> */
+		retval = gpio_request(arg, DRVNAME);
+		break;
+	case GPIO_FREE:
+		/* should be last ioctl operation on <pin> */
+		/* may be needed first if previous user missed this ioctl */
+		gpio_free(arg);
+		break;
+	case GPIO_CAN_SLEEP:
+		retval = gpio_cansleep(arg);
+		break;
+	default:
+		retval = -EINVAL;
+		/* = -ENOTTY; // correct return but ... */
+		break;
+	}
+	return retval;
+}
+
+/* Allow co-incident opens */
+static int
+gpio_open(struct inode *inode, struct file *file)
+{
+	int result = 0;
+	unsigned int dev_minor = MINOR(inode->i_rdev);
+
+	if (dev_minor != 0)
+	{
+		printk(KERN_ERR DRVNAME ": trying to access unknown minor device -> %d\n", dev_minor);
+		result = -ENODEV;
+		goto out;
+	}
+out:
+	return result;
+}
+
+static int
+gpio_close(struct inode * inode, struct file * file)
+{
+	/* could track all <pin>s requested by this fd and gpio_free()
+         * them here
+	 */
+	return 0;
+}
+
+struct file_operations gpio_fops = {
+	unlocked_ioctl:	gpio_ioctl,
+	open:		gpio_open,
+	release:	gpio_close
+};
+
+static int
+gpio_probe(struct platform_device *dev)
+{
+	int result = 0;
+
+	dev_major = register_chrdev(0, DEVNAME, &gpio_fops);
+	if (!dev_major)
+	{
+		printk(KERN_ERR DRVNAME ": Error whilst opening %s \n", DEVNAME);
+		result = -ENODEV;
+		goto out;
+	}
+	gpiodev_class = class_create(THIS_MODULE, DRVNAME);
+	device_create(gpiodev_class, NULL, MKDEV(dev_major, 0), dev, DEVNAME);
+	printk(KERN_INFO DRVNAME ": gpio device registered with major %d\n", dev_major);
+out:
+	return result;
+}
+
+static int
+gpio_remove(struct platform_device *dev)
+{
+	unregister_chrdev(dev_major, DEVNAME);
+	return 0;
+}
+
+static struct
+platform_driver gpio_driver = {
+	.probe = gpio_probe,
+	.remove = gpio_remove,
+	.driver = {
+		.name = "GPIODEV",
+		.owner = THIS_MODULE,
+	},
+};
+
+static int __init
+gpio_mod_init(void)
+{
+	int ret = platform_driver_register(&gpio_driver);
+	if (ret)
+		printk(KERN_INFO DRVNAME ": Error registering platfom driver!\n");
+
+	return ret;
+}
+
+static void __exit
+gpio_mod_exit(void)
+{
+	platform_driver_unregister(&gpio_driver);
+}
+
+module_init (gpio_mod_init);
+module_exit (gpio_mod_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("John Crispin / OpenWrt +");
+MODULE_DESCRIPTION("Character device for for generic gpio api");
diff --git a/drivers/crypto/hifn_795x.c b/drivers/crypto/hifn_795x.c
index a84250a..754055b 100644
--- a/drivers/crypto/hifn_795x.c
+++ b/drivers/crypto/hifn_795x.c
@@ -682,12 +682,12 @@ static inline u32 hifn_read_1(struct hifn_device *dev, u32 reg)
 
 static inline void hifn_write_0(struct hifn_device *dev, u32 reg, u32 val)
 {
-	writel((__force u32)cpu_to_le32(val), dev->bar[0] + reg);
+	writel(val, dev->bar[0] + reg);
 }
 
 static inline void hifn_write_1(struct hifn_device *dev, u32 reg, u32 val)
 {
-	writel((__force u32)cpu_to_le32(val), dev->bar[1] + reg);
+	writel(val, dev->bar[1] + reg);
 }
 
 static void hifn_wait_puc(struct hifn_device *dev)
diff --git a/drivers/input/misc/Kconfig b/drivers/input/misc/Kconfig
index 45dc6aa..6d17884 100644
--- a/drivers/input/misc/Kconfig
+++ b/drivers/input/misc/Kconfig
@@ -478,4 +478,20 @@ config INPUT_XEN_KBDDEV_FRONTEND
 	  To compile this driver as a module, choose M here: the
 	  module will be called xen-kbdfront.
 
+config INPUT_GPIO_BUTTONS
+	tristate "Polled GPIO buttons interface"
+	depends on GENERIC_GPIO
+	select INPUT_POLLDEV
+	help
+	  This driver implements support for buttons connected
+	  to GPIO pins of various CPUs (and some other chips).
+
+	  Say Y here if your device has buttons connected
+	  directly to such GPIO pins.  Your board-specific
+	  setup logic must also provide a platform device,
+	  with configuration data saying which GPIOs are used.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called gpio-buttons.
+
 endif
diff --git a/drivers/input/misc/Makefile b/drivers/input/misc/Makefile
index 38efb2c..a5c7220 100644
--- a/drivers/input/misc/Makefile
+++ b/drivers/input/misc/Makefile
@@ -45,4 +45,5 @@ obj-$(CONFIG_INPUT_WISTRON_BTNS)	+= wistron_btns.o
 obj-$(CONFIG_INPUT_WM831X_ON)		+= wm831x-on.o
 obj-$(CONFIG_INPUT_XEN_KBDDEV_FRONTEND)	+= xen-kbdfront.o
 obj-$(CONFIG_INPUT_YEALINK)		+= yealink.o
+obj-$(CONFIG_INPUT_GPIO_BUTTONS)	+= gpio_buttons.o
 
diff --git a/drivers/input/misc/gpio_buttons.c b/drivers/input/misc/gpio_buttons.c
new file mode 100644
index 0000000..51288a3
--- /dev/null
+++ b/drivers/input/misc/gpio_buttons.c
@@ -0,0 +1,232 @@
+/*
+ *  Driver for buttons on GPIO lines not capable of generating interrupts
+ *
+ *  Copyright (C) 2007-2010 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2010 Nuno Goncalves <nunojpg@gmail.com>
+ *
+ *  This file was based on: /drivers/input/misc/cobalt_btns.c
+ *	Copyright (C) 2007 Yoichi Yuasa <yoichi_yuasa@tripeaks.co.jp>
+ *
+ *  also was based on: /drivers/input/keyboard/gpio_keys.c
+ *	Copyright 2005 Phil Blundell
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/input.h>
+#include <linux/input-polldev.h>
+#include <linux/ioport.h>
+#include <linux/platform_device.h>
+#include <linux/gpio.h>
+#include <linux/gpio_buttons.h>
+
+#define DRV_NAME	"gpio-buttons"
+
+struct gpio_button_data {
+	int last_state;
+	int count;
+	int can_sleep;
+};
+
+struct gpio_buttons_dev {
+	struct input_polled_dev *poll_dev;
+	struct gpio_buttons_platform_data *pdata;
+	struct gpio_button_data *data;
+};
+
+static void gpio_buttons_check_state(struct input_dev *input,
+				      struct gpio_button *button,
+				      struct gpio_button_data *bdata)
+{
+	int state;
+
+	if (bdata->can_sleep)
+		state = !!gpio_get_value_cansleep(button->gpio);
+	else
+		state = !!gpio_get_value(button->gpio);
+
+	if (state != bdata->last_state) {
+		unsigned int type = button->type ?: EV_KEY;
+
+		input_event(input, type, button->code,
+			    !!(state ^ button->active_low));
+		input_sync(input);
+		bdata->count = 0;
+		bdata->last_state = state;
+	}
+}
+
+static void gpio_buttons_poll(struct input_polled_dev *dev)
+{
+	struct gpio_buttons_dev *bdev = dev->private;
+	struct gpio_buttons_platform_data *pdata = bdev->pdata;
+	struct input_dev *input = dev->input;
+	int i;
+
+	for (i = 0; i < bdev->pdata->nbuttons; i++) {
+		struct gpio_button *button = &pdata->buttons[i];
+		struct gpio_button_data *bdata = &bdev->data[i];
+
+		if (bdata->count < button->threshold)
+			bdata->count++;
+		else
+			gpio_buttons_check_state(input, button, bdata);
+
+	}
+}
+
+static int __devinit gpio_buttons_probe(struct platform_device *pdev)
+{
+	struct gpio_buttons_platform_data *pdata = pdev->dev.platform_data;
+	struct device *dev = &pdev->dev;
+	struct gpio_buttons_dev *bdev;
+	struct input_polled_dev *poll_dev;
+	struct input_dev *input;
+	int error;
+	int i;
+
+	if (!pdata)
+		return -ENXIO;
+
+	bdev = kzalloc(sizeof(struct gpio_buttons_dev) +
+		       pdata->nbuttons * sizeof(struct gpio_button_data),
+		       GFP_KERNEL);
+	if (!bdev) {
+		dev_err(dev, "no memory for private data\n");
+		return -ENOMEM;
+	}
+
+	bdev->data = (struct gpio_button_data *) &bdev[1];
+
+	poll_dev = input_allocate_polled_device();
+	if (!poll_dev) {
+		dev_err(dev, "no memory for polled device\n");
+		error = -ENOMEM;
+		goto err_free_bdev;
+	}
+
+	poll_dev->private = bdev;
+	poll_dev->poll = gpio_buttons_poll;
+	poll_dev->poll_interval = pdata->poll_interval;
+
+	input = poll_dev->input;
+
+	input->evbit[0] = BIT(EV_KEY);
+	input->name = pdev->name;
+	input->phys = "gpio-buttons/input0";
+	input->dev.parent = &pdev->dev;
+
+	input->id.bustype = BUS_HOST;
+	input->id.vendor = 0x0001;
+	input->id.product = 0x0001;
+	input->id.version = 0x0100;
+
+	for (i = 0; i < pdata->nbuttons; i++) {
+		struct gpio_button *button = &pdata->buttons[i];
+		unsigned int gpio = button->gpio;
+		unsigned int type = button->type ?: EV_KEY;
+
+		error = gpio_request(gpio,
+				     button->desc ? button->desc : DRV_NAME);
+		if (error) {
+			dev_err(dev, "unable to claim gpio %u, err=%d\n",
+				gpio, error);
+			goto err_free_gpio;
+		}
+
+		error = gpio_direction_input(gpio);
+		if (error) {
+			dev_err(dev,
+				"unable to set direction on gpio %u, err=%d\n",
+				gpio, error);
+			goto err_free_gpio;
+		}
+
+		bdev->data[i].can_sleep = gpio_cansleep(gpio);
+		bdev->data[i].last_state = -1;
+
+		input_set_capability(input, type, button->code);
+	}
+
+	bdev->poll_dev = poll_dev;
+	bdev->pdata = pdata;
+	platform_set_drvdata(pdev, bdev);
+
+	error = input_register_polled_device(poll_dev);
+	if (error) {
+		dev_err(dev, "unable to register polled device, err=%d\n",
+			error);
+		goto err_free_gpio;
+	}
+
+	/* report initial state of the buttons */
+	for (i = 0; i < pdata->nbuttons; i++)
+		gpio_buttons_check_state(input, &pdata->buttons[i],
+					 &bdev->data[i]);
+
+	return 0;
+
+err_free_gpio:
+	for (i = i - 1; i >= 0; i--)
+		gpio_free(pdata->buttons[i].gpio);
+
+	input_free_polled_device(poll_dev);
+
+err_free_bdev:
+	kfree(bdev);
+
+	platform_set_drvdata(pdev, NULL);
+	return error;
+}
+
+static int __devexit gpio_buttons_remove(struct platform_device *pdev)
+{
+	struct gpio_buttons_dev *bdev = platform_get_drvdata(pdev);
+	struct gpio_buttons_platform_data *pdata = bdev->pdata;
+	int i;
+
+	input_unregister_polled_device(bdev->poll_dev);
+
+	for (i = 0; i < pdata->nbuttons; i++)
+		gpio_free(pdata->buttons[i].gpio);
+
+	input_free_polled_device(bdev->poll_dev);
+
+	kfree(bdev);
+	platform_set_drvdata(pdev, NULL);
+
+	return 0;
+}
+
+static struct platform_driver gpio_buttons_driver = {
+	.probe	= gpio_buttons_probe,
+	.remove	= __devexit_p(gpio_buttons_remove),
+	.driver	= {
+		.name	= DRV_NAME,
+		.owner	= THIS_MODULE,
+	},
+};
+
+static int __init gpio_buttons_init(void)
+{
+	return platform_driver_register(&gpio_buttons_driver);
+}
+
+static void __exit gpio_buttons_exit(void)
+{
+	platform_driver_unregister(&gpio_buttons_driver);
+}
+
+module_init(gpio_buttons_init);
+module_exit(gpio_buttons_exit);
+
+MODULE_LICENSE("GPL v2");
+MODULE_AUTHOR("Gabor Juhos <juhosg@openwrt.org>");
+MODULE_DESCRIPTION("Polled GPIO Buttons driver");
diff --git a/drivers/leds/Kconfig b/drivers/leds/Kconfig
index 67ae231..2868147 100644
--- a/drivers/leds/Kconfig
+++ b/drivers/leds/Kconfig
@@ -481,4 +481,22 @@ config LEDS_TRIGGER_DEFAULT_ON
 comment "iptables trigger is under Netfilter config (LED target)"
 	depends on LEDS_TRIGGERS
 
+config LEDS_TRIGGER_MORSE
+	tristate "LED Morse Trigger"
+	depends on LEDS_TRIGGERS
+
+config LEDS_TRIGGER_NETDEV
+	tristate "LED Netdev Trigger"
+	depends on NET && LEDS_TRIGGERS
+	help
+	  This allows LEDs to be controlled by network device activity.
+	  If unsure, say Y.
+
+config LEDS_TRIGGER_USBDEV
+	tristate "LED USB device Trigger"
+	depends on USB && LEDS_TRIGGERS
+	help
+	  This allows LEDs to be controlled by the presence/activity of
+	  an USB device. If unsure, say N.
+
 endif # NEW_LEDS
diff --git a/drivers/leds/Makefile b/drivers/leds/Makefile
index af45c5d..2295f28 100644
--- a/drivers/leds/Makefile
+++ b/drivers/leds/Makefile
@@ -56,3 +56,6 @@ obj-$(CONFIG_LEDS_TRIGGER_HEARTBEAT)	+= ledtrig-heartbeat.o
 obj-$(CONFIG_LEDS_TRIGGER_BACKLIGHT)	+= ledtrig-backlight.o
 obj-$(CONFIG_LEDS_TRIGGER_GPIO)		+= ledtrig-gpio.o
 obj-$(CONFIG_LEDS_TRIGGER_DEFAULT_ON)	+= ledtrig-default-on.o
+obj-$(CONFIG_LEDS_TRIGGER_MORSE)	+= ledtrig-morse.o
+obj-$(CONFIG_LEDS_TRIGGER_NETDEV)	+= ledtrig-netdev.o
+obj-$(CONFIG_LEDS_TRIGGER_USBDEV)	+= ledtrig-usbdev.o
diff --git a/drivers/leds/leds-wndr3700-usb.c b/drivers/leds/leds-wndr3700-usb.c
new file mode 100644
index 0000000..9f17861
--- /dev/null
+++ b/drivers/leds/leds-wndr3700-usb.c
@@ -0,0 +1,75 @@
+/*
+ *  USB LED driver for the NETGEAR WNDR3700
+ *
+ *  Copyright (C) 2009 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/leds.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+
+#include <asm/mach-ar71xx/ar71xx.h>
+
+#define DRIVER_NAME	"wndr3700-led-usb"
+
+static void wndr3700_usb_led_set(struct led_classdev *cdev,
+				 enum led_brightness brightness)
+{
+	if (brightness)
+		ar71xx_device_start(RESET_MODULE_GE1_PHY);
+	else
+		ar71xx_device_stop(RESET_MODULE_GE1_PHY);
+}
+
+static enum led_brightness wndr3700_usb_led_get(struct led_classdev *cdev)
+{
+	return ar71xx_device_stopped(RESET_MODULE_GE1_PHY) ? LED_OFF : LED_FULL;
+}
+
+static struct led_classdev wndr3700_usb_led = {
+	.name = "wndr3700:green:usb",
+	.brightness_set = wndr3700_usb_led_set,
+	.brightness_get = wndr3700_usb_led_get,
+};
+
+static int __devinit wndr3700_usb_led_probe(struct platform_device *pdev)
+{
+	return led_classdev_register(&pdev->dev, &wndr3700_usb_led);
+}
+
+static int __devexit wndr3700_usb_led_remove(struct platform_device *pdev)
+{
+	led_classdev_unregister(&wndr3700_usb_led);
+	return 0;
+}
+
+static struct platform_driver wndr3700_usb_led_driver = {
+	.probe = wndr3700_usb_led_probe,
+	.remove = __devexit_p(wndr3700_usb_led_remove),
+	.driver = {
+		.name = DRIVER_NAME,
+		.owner = THIS_MODULE,
+	},
+};
+
+static int __init wndr3700_usb_led_init(void)
+{
+	return platform_driver_register(&wndr3700_usb_led_driver);
+}
+
+static void __exit wndr3700_usb_led_exit(void)
+{
+	platform_driver_unregister(&wndr3700_usb_led_driver);
+}
+
+module_init(wndr3700_usb_led_init);
+module_exit(wndr3700_usb_led_exit);
+
+MODULE_DESCRIPTION("USB LED driver for the NETGEAR WNDR3700");
+MODULE_AUTHOR("Gabor Juhos <juhosg@openwrt.org>");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("platform:" DRIVER_NAME);
diff --git a/drivers/leds/ledtrig-morse.c b/drivers/leds/ledtrig-morse.c
new file mode 100644
index 0000000..bc58afe
--- /dev/null
+++ b/drivers/leds/ledtrig-morse.c
@@ -0,0 +1,366 @@
+/*
+ *  LED Morse Trigger
+ *
+ *  Copyright (C) 2007 Gabor Juhos <juhosg at openwrt.org>
+ *
+ *  This file was based on: drivers/led/ledtrig-timer.c
+ *	Copyright 2005-2006 Openedhand Ltd.
+ *	Author: Richard Purdie <rpurdie@openedhand.com>
+ *
+ *  also based on the patch '[PATCH] 2.5.59 morse code panics' posted
+ *  in the LKML by Tomas Szepe at Thu, 30 Jan 2003
+ *	Copyright (C) 2002 Andrew Rodland <arodland@noln.com>
+ *	Copyright (C) 2003 Tomas Szepe <szepe@pinerecords.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/jiffies.h>
+#include <linux/init.h>
+#include <linux/list.h>
+#include <linux/spinlock.h>
+#include <linux/device.h>
+#include <linux/sysdev.h>
+#include <linux/timer.h>
+#include <linux/ctype.h>
+#include <linux/leds.h>
+#include <linux/slab.h>
+
+#include "leds.h"
+
+#define MORSE_DELAY_BASE	(HZ/2)
+
+#define MORSE_STATE_BLINK_START	0
+#define MORSE_STATE_BLINK_STOP	1
+
+#define MORSE_DIT_LEN	1
+#define MORSE_DAH_LEN	3
+#define MORSE_SPACE_LEN	7
+
+struct morse_trig_data {
+	unsigned long delay;
+	char *msg;
+
+	unsigned char morse;
+	unsigned char state;
+	char *msgpos;
+	struct timer_list timer;
+};
+
+const unsigned char morsetable[] = {
+	0122, 0, 0310, 0, 0, 0163,				/* "#$%&' */
+	055, 0155, 0, 0, 0163, 0141, 0152, 0051, 		/* ()*+,-./ */
+	077, 076, 074, 070, 060, 040, 041, 043, 047, 057,	/* 0-9 */
+	0107, 0125, 0, 0061, 0, 0114, 0, 			/* :;<=>?@ */
+	006, 021, 025, 011, 002, 024, 013, 020, 004,		/* A-I */
+	036, 015, 022, 007, 005, 017, 026, 033, 012,		/* J-R */
+	010, 003, 014, 030, 016, 031, 035, 023,			/* S-Z */
+	0, 0, 0, 0, 0154					/* [\]^_ */
+};
+
+static inline unsigned char tomorse(char c) {
+	if (c >= 'a' && c <= 'z')
+		c = c - 'a' + 'A';
+	if (c >= '"' && c <= '_') {
+		return morsetable[c - '"'];
+	} else
+		return 0;
+}
+
+static inline unsigned long dit_len(struct morse_trig_data *morse_data)
+{
+	return MORSE_DIT_LEN*morse_data->delay;
+}
+
+static inline unsigned long dah_len(struct morse_trig_data *morse_data)
+{
+	return MORSE_DAH_LEN*morse_data->delay;
+}
+
+static inline unsigned long space_len(struct morse_trig_data *morse_data)
+{
+	return MORSE_SPACE_LEN*morse_data->delay;
+}
+
+static void morse_timer_function(unsigned long data)
+{
+	struct led_classdev *led_cdev = (struct led_classdev *)data;
+	struct morse_trig_data *morse_data = led_cdev->trigger_data;
+	unsigned long brightness = LED_OFF;
+	unsigned long delay = 0;
+
+	if (!morse_data->msg)
+		goto set_led;
+
+	switch (morse_data->state) {
+	case MORSE_STATE_BLINK_START:
+		/* Starting a new blink.  We have a valid code in morse. */
+		delay = (morse_data->morse & 001) ? dah_len(morse_data):
+			dit_len(morse_data);
+		brightness = LED_FULL;
+		morse_data->state = MORSE_STATE_BLINK_STOP;
+		morse_data->morse >>= 1;
+		break;
+	case MORSE_STATE_BLINK_STOP:
+		/* Coming off of a blink. */
+		morse_data->state = MORSE_STATE_BLINK_START;
+
+		if (morse_data->morse > 1) {
+			/* Not done yet, just a one-dit pause. */
+			delay = dit_len(morse_data);
+			break;
+		}
+
+		/* Get a new char, figure out how much space. */
+		/* First time through */
+		if (!morse_data->msgpos)
+			morse_data->msgpos = (char *)morse_data->msg;
+
+		if (!*morse_data->msgpos) {
+			/* Repeating */
+			morse_data->msgpos = (char *)morse_data->msg;
+			delay = space_len(morse_data);
+		} else {
+			/* Inter-letter space */
+			delay = dah_len(morse_data);
+		}
+
+		if (!(morse_data->morse = tomorse(*morse_data->msgpos))) {
+			delay = space_len(morse_data);
+			/* And get us back here */
+			morse_data->state = MORSE_STATE_BLINK_STOP;
+		}
+		morse_data->msgpos++;
+		break;
+	}
+
+	mod_timer(&morse_data->timer, jiffies + msecs_to_jiffies(delay));
+
+set_led:
+	led_set_brightness(led_cdev, brightness);
+}
+
+static ssize_t _morse_delay_show(struct led_classdev *led_cdev, char *buf)
+{
+	struct morse_trig_data *morse_data = led_cdev->trigger_data;
+
+	sprintf(buf, "%lu\n", morse_data->delay);
+
+	return strlen(buf) + 1;
+}
+
+static ssize_t _morse_delay_store(struct led_classdev *led_cdev,
+		const char *buf, size_t size)
+{
+	struct morse_trig_data *morse_data = led_cdev->trigger_data;
+	char *after;
+	unsigned long state = simple_strtoul(buf, &after, 10);
+	size_t count = after - buf;
+	int ret = -EINVAL;
+
+	if (*after && isspace(*after))
+		count++;
+
+	if (count == size) {
+		morse_data->delay = state;
+		mod_timer(&morse_data->timer, jiffies + 1);
+		ret = count;
+	}
+
+	return ret;
+}
+
+static ssize_t _morse_msg_show(struct led_classdev *led_cdev, char *buf)
+{
+	struct morse_trig_data *morse_data = led_cdev->trigger_data;
+
+	if (!morse_data->msg)
+		sprintf(buf, "<none>\n");
+	else
+		sprintf(buf, "%s\n", morse_data->msg);
+
+	return strlen(buf) + 1;
+}
+
+static ssize_t _morse_msg_store(struct led_classdev *led_cdev,
+		const char *buf, size_t size)
+{
+	struct morse_trig_data *morse_data = led_cdev->trigger_data;
+	char *m;
+
+	m = kmalloc(size, GFP_KERNEL);
+	if (!m)
+		return -ENOMEM;
+
+	memcpy(m,buf,size);
+	m[size]='\0';
+
+	if (morse_data->msg)
+		kfree(morse_data->msg);
+
+	morse_data->msg = m;
+	morse_data->msgpos = NULL;
+	morse_data->state = MORSE_STATE_BLINK_STOP;
+
+	mod_timer(&morse_data->timer, jiffies + 1);
+
+	return size;
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,23)
+static ssize_t morse_delay_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct led_classdev *led_cdev = dev_get_drvdata(dev);
+
+	return _morse_delay_show(led_cdev, buf);
+}
+
+static ssize_t morse_delay_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	struct led_classdev *led_cdev = dev_get_drvdata(dev);
+
+	return _morse_delay_store(led_cdev, buf, size);
+}
+
+static ssize_t morse_msg_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct led_classdev *led_cdev = dev_get_drvdata(dev);
+
+	return _morse_msg_show(led_cdev, buf);
+}
+
+static ssize_t morse_msg_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	struct led_classdev *led_cdev = dev_get_drvdata(dev);
+
+	return _morse_msg_store(led_cdev, buf, size);
+}
+
+static DEVICE_ATTR(delay, 0644, morse_delay_show, morse_delay_store);
+static DEVICE_ATTR(message, 0644, morse_msg_show, morse_msg_store);
+
+#define led_device_create_file(leddev, attr) \
+	device_create_file(leddev->dev, &dev_attr_ ## attr)
+#define led_device_remove_file(leddev, attr) \
+	device_remove_file(leddev->dev, &dev_attr_ ## attr)
+
+#else
+static ssize_t morse_delay_show(struct class_device *dev, char *buf)
+{
+	struct led_classdev *led_cdev = class_get_devdata(dev);
+
+	return _morse_delay_show(led_cdev, buf);
+}
+
+static ssize_t morse_delay_store(struct class_device *dev, const char *buf,
+		size_t size)
+{
+	struct led_classdev *led_cdev = class_get_devdata(dev);
+
+	return _morse_delay_store(led_cdev, buf, size);
+}
+
+static ssize_t morse_msg_show(struct class_device *dev, char *buf)
+{
+	struct led_classdev *led_cdev = class_get_devdata(dev);
+
+	return _morse_msg_show(led_cdev, buf);
+}
+
+static ssize_t morse_msg_store(struct class_device *dev, const char *buf,
+				size_t size)
+{
+	struct led_classdev *led_cdev = class_get_devdata(dev);
+
+	return _morse_msg_store(led_cdev, buf, size);
+}
+
+static CLASS_DEVICE_ATTR(delay, 0644, morse_delay_show, morse_delay_store);
+static CLASS_DEVICE_ATTR(message, 0644, morse_msg_show, morse_msg_store);
+
+#define led_device_create_file(leddev, attr) \
+	class_device_create_file(leddev->class_dev, &class_device_attr_ ## attr)
+#define led_device_remove_file(leddev, attr) \
+	class_device_remove_file(leddev->class_dev, &class_device_attr_ ## attr)
+
+#endif
+
+static void morse_trig_activate(struct led_classdev *led_cdev)
+{
+	struct morse_trig_data *morse_data;
+	int rc;
+
+	morse_data = kzalloc(sizeof(*morse_data), GFP_KERNEL);
+	if (!morse_data)
+		return;
+
+	morse_data->delay = MORSE_DELAY_BASE;
+	init_timer(&morse_data->timer);
+	morse_data->timer.function = morse_timer_function;
+	morse_data->timer.data = (unsigned long)led_cdev;
+
+	rc = led_device_create_file(led_cdev, delay);
+	if (rc) goto err;
+
+	rc = led_device_create_file(led_cdev, message);
+	if (rc) goto err_delay;
+
+	led_cdev->trigger_data = morse_data;
+
+	return;
+
+err_delay:
+	led_device_remove_file(led_cdev, delay);
+err:
+	kfree(morse_data);
+}
+
+static void morse_trig_deactivate(struct led_classdev *led_cdev)
+{
+	struct morse_trig_data *morse_data = led_cdev->trigger_data;
+
+	if (!morse_data)
+		return;
+
+	led_device_remove_file(led_cdev, message);
+	led_device_remove_file(led_cdev, delay);
+
+	del_timer_sync(&morse_data->timer);
+	if (morse_data->msg)
+		kfree(morse_data->msg);
+
+	kfree(morse_data);
+}
+
+static struct led_trigger morse_led_trigger = {
+	.name		= "morse",
+	.activate	= morse_trig_activate,
+	.deactivate	= morse_trig_deactivate,
+};
+
+static int __init morse_trig_init(void)
+{
+	return led_trigger_register(&morse_led_trigger);
+}
+
+static void __exit morse_trig_exit(void)
+{
+	led_trigger_unregister(&morse_led_trigger);
+}
+
+module_init(morse_trig_init);
+module_exit(morse_trig_exit);
+
+MODULE_AUTHOR("Gabor Juhos <juhosg at openwrt.org>");
+MODULE_DESCRIPTION("Morse LED trigger");
+MODULE_LICENSE("GPL");
diff --git a/drivers/leds/ledtrig-netdev.c b/drivers/leds/ledtrig-netdev.c
new file mode 100644
index 0000000..6c56acb
--- /dev/null
+++ b/drivers/leds/ledtrig-netdev.c
@@ -0,0 +1,451 @@
+/*
+ * LED Kernel Netdev Trigger
+ *
+ * Toggles the LED to reflect the link and traffic state of a named net device
+ *
+ * Copyright 2007 Oliver Jowett <oliver@opencloud.com>
+ *
+ * Derived from ledtrig-timer.c which is:
+ *  Copyright 2005-2006 Openedhand Ltd.
+ *  Author: Richard Purdie <rpurdie@openedhand.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/jiffies.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/list.h>
+#include <linux/spinlock.h>
+#include <linux/device.h>
+#include <linux/sysdev.h>
+#include <linux/netdevice.h>
+#include <linux/timer.h>
+#include <linux/ctype.h>
+#include <linux/leds.h>
+#include <linux/version.h>
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,26)
+#include <net/net_namespace.h>
+#endif
+
+#include "leds.h"
+
+/*
+ * Configurable sysfs attributes:
+ *
+ * device_name - network device name to monitor
+ *
+ * interval - duration of LED blink, in milliseconds
+ *
+ * mode - either "none" (LED is off) or a space separated list of one or more of:
+ *   link: LED's normal state reflects whether the link is up (has carrier) or not
+ *   tx:   LED blinks on transmitted data
+ *   rx:   LED blinks on receive data
+ *
+ * Some suggestions:
+ *
+ *  Simple link status LED:
+ *  $ echo netdev >someled/trigger
+ *  $ echo eth0 >someled/device_name
+ *  $ echo link >someled/mode
+ *
+ *  Ethernet-style link/activity LED:
+ *  $ echo netdev >someled/trigger
+ *  $ echo eth0 >someled/device_name
+ *  $ echo "link tx rx" >someled/mode
+ *
+ *  Modem-style tx/rx LEDs:
+ *  $ echo netdev >led1/trigger
+ *  $ echo ppp0 >led1/device_name
+ *  $ echo tx >led1/mode
+ *  $ echo netdev >led2/trigger
+ *  $ echo ppp0 >led2/device_name
+ *  $ echo rx >led2/mode
+ *
+ */
+
+#define MODE_LINK 1
+#define MODE_TX   2
+#define MODE_RX   4
+
+struct led_netdev_data {
+	rwlock_t lock;
+
+	struct timer_list timer;
+	struct notifier_block notifier;
+
+	struct led_classdev *led_cdev;
+	struct net_device *net_dev;
+
+	char device_name[IFNAMSIZ];
+	unsigned interval;
+	unsigned mode;
+	unsigned link_up;
+	unsigned last_activity;
+};
+
+static void set_baseline_state(struct led_netdev_data *trigger_data)
+{
+	if ((trigger_data->mode & MODE_LINK) != 0 && trigger_data->link_up)
+		led_set_brightness(trigger_data->led_cdev, LED_FULL);
+	else
+		led_set_brightness(trigger_data->led_cdev, LED_OFF);
+
+	if ((trigger_data->mode & (MODE_TX | MODE_RX)) != 0 && trigger_data->link_up)
+		mod_timer(&trigger_data->timer, jiffies + trigger_data->interval);
+	else
+		del_timer(&trigger_data->timer);
+}
+
+static ssize_t led_device_name_show(struct device *dev,
+				    struct device_attribute *attr, char *buf)
+{
+	struct led_classdev *led_cdev = dev_get_drvdata(dev);
+	struct led_netdev_data *trigger_data = led_cdev->trigger_data;
+
+	read_lock(&trigger_data->lock);
+	sprintf(buf, "%s\n", trigger_data->device_name);
+	read_unlock(&trigger_data->lock);
+
+	return strlen(buf) + 1;
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,21)
+extern struct net init_net;
+#endif
+
+static ssize_t led_device_name_store(struct device *dev,
+				     struct device_attribute *attr, const char *buf, size_t size)
+{
+	struct led_classdev *led_cdev = dev_get_drvdata(dev);
+	struct led_netdev_data *trigger_data = led_cdev->trigger_data;
+
+	if (size < 0 || size >= IFNAMSIZ)
+		return -EINVAL;
+
+	write_lock(&trigger_data->lock);
+
+	strcpy(trigger_data->device_name, buf);
+	if (size > 0 && trigger_data->device_name[size-1] == '\n')
+		trigger_data->device_name[size-1] = 0;
+
+	if (trigger_data->device_name[0] != 0) {
+		/* check for existing device to update from */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,26)
+		trigger_data->net_dev = dev_get_by_name(&init_net, trigger_data->device_name);
+#else
+		trigger_data->net_dev = dev_get_by_name(trigger_data->device_name);
+#endif
+		if (trigger_data->net_dev != NULL)
+			trigger_data->link_up = (dev_get_flags(trigger_data->net_dev) & IFF_LOWER_UP) != 0;
+		set_baseline_state(trigger_data); /* updates LEDs, may start timers */
+	}
+
+	write_unlock(&trigger_data->lock);
+	return size;
+}
+
+static DEVICE_ATTR(device_name, 0644, led_device_name_show, led_device_name_store);
+
+static ssize_t led_mode_show(struct device *dev,
+			     struct device_attribute *attr, char *buf)
+{
+	struct led_classdev *led_cdev = dev_get_drvdata(dev);
+	struct led_netdev_data *trigger_data = led_cdev->trigger_data;
+
+	read_lock(&trigger_data->lock);
+
+	if (trigger_data->mode == 0) {
+		strcpy(buf, "none\n");
+	} else {
+		if (trigger_data->mode & MODE_LINK)
+			strcat(buf, "link ");
+		if (trigger_data->mode & MODE_TX)
+			strcat(buf, "tx ");
+		if (trigger_data->mode & MODE_RX)
+			strcat(buf, "rx ");
+		strcat(buf, "\n");
+	}
+
+	read_unlock(&trigger_data->lock);
+
+	return strlen(buf)+1;
+}
+
+static ssize_t led_mode_store(struct device *dev,
+			      struct device_attribute *attr, const char *buf, size_t size)
+{
+	struct led_classdev *led_cdev = dev_get_drvdata(dev);
+	struct led_netdev_data *trigger_data = led_cdev->trigger_data;
+	char copybuf[128];
+	int new_mode = -1;
+	char *p, *token;
+
+	/* take a copy since we don't want to trash the inbound buffer when using strsep */
+	strncpy(copybuf, buf, sizeof(copybuf));
+	copybuf[sizeof(copybuf) - 1] = 0;
+	p = copybuf;
+
+	while ((token = strsep(&p, " \t\n")) != NULL) {
+		if (!*token)
+			continue;
+
+		if (new_mode == -1)
+			new_mode = 0;
+
+		if (!strcmp(token, "none"))
+			new_mode = 0;
+		else if (!strcmp(token, "tx"))
+			new_mode |= MODE_TX;
+		else if (!strcmp(token, "rx"))
+			new_mode |= MODE_RX;
+		else if (!strcmp(token, "link"))
+			new_mode |= MODE_LINK;
+		else
+			return -EINVAL;
+	}
+
+	if (new_mode == -1)
+		return -EINVAL;
+
+	write_lock(&trigger_data->lock);
+	trigger_data->mode = new_mode;
+	set_baseline_state(trigger_data);
+	write_unlock(&trigger_data->lock);
+
+	return size;
+}
+
+static DEVICE_ATTR(mode, 0644, led_mode_show, led_mode_store);
+
+static ssize_t led_interval_show(struct device *dev,
+				 struct device_attribute *attr, char *buf)
+{
+	struct led_classdev *led_cdev = dev_get_drvdata(dev);
+	struct led_netdev_data *trigger_data = led_cdev->trigger_data;
+
+	read_lock(&trigger_data->lock);
+	sprintf(buf, "%u\n", jiffies_to_msecs(trigger_data->interval));
+	read_unlock(&trigger_data->lock);
+
+	return strlen(buf) + 1;
+}
+
+static ssize_t led_interval_store(struct device *dev,
+				  struct device_attribute *attr, const char *buf, size_t size)
+{
+	struct led_classdev *led_cdev = dev_get_drvdata(dev);
+	struct led_netdev_data *trigger_data = led_cdev->trigger_data;
+	int ret = -EINVAL;
+	char *after;
+	unsigned long value = simple_strtoul(buf, &after, 10);
+	size_t count = after - buf;
+
+	if (*after && isspace(*after))
+		count++;
+
+	/* impose some basic bounds on the timer interval */
+	if (count == size && value >= 5 && value <= 10000) {
+		write_lock(&trigger_data->lock);
+		trigger_data->interval = msecs_to_jiffies(value);
+		set_baseline_state(trigger_data); // resets timer
+		write_unlock(&trigger_data->lock);
+		ret = count;
+	}
+
+	return ret;
+}
+
+static DEVICE_ATTR(interval, 0644, led_interval_show, led_interval_store);
+
+static int netdev_trig_notify(struct notifier_block *nb,
+			      unsigned long evt,
+			      void *dv)
+{
+	struct net_device *dev = dv;
+	struct led_netdev_data *trigger_data = container_of(nb, struct led_netdev_data, notifier);
+
+	if (evt != NETDEV_UP && evt != NETDEV_DOWN && evt != NETDEV_CHANGE && evt != NETDEV_REGISTER && evt != NETDEV_UNREGISTER)
+		return NOTIFY_DONE;
+
+	write_lock(&trigger_data->lock);
+
+	if (strcmp(dev->name, trigger_data->device_name))
+		goto done;
+
+	if (evt == NETDEV_REGISTER) {
+		if (trigger_data->net_dev != NULL)
+			dev_put(trigger_data->net_dev);
+		dev_hold(dev);
+		trigger_data->net_dev = dev;
+		trigger_data->link_up = 0;
+		goto done;
+	}
+
+	if (evt == NETDEV_UNREGISTER && trigger_data->net_dev != NULL) {
+		dev_put(trigger_data->net_dev);
+		trigger_data->net_dev = NULL;
+		goto done;
+	}
+
+	/* UP / DOWN / CHANGE */
+
+	trigger_data->link_up = (evt != NETDEV_DOWN && netif_carrier_ok(dev));
+	set_baseline_state(trigger_data);
+
+done:
+	write_unlock(&trigger_data->lock);
+	return NOTIFY_DONE;
+}
+
+/* here's the real work! */
+static void netdev_trig_timer(unsigned long arg)
+{
+	struct led_netdev_data *trigger_data = (struct led_netdev_data *)arg;
+	const struct net_device_stats *dev_stats;
+	unsigned new_activity;
+
+	write_lock(&trigger_data->lock);
+
+	if (!trigger_data->link_up || !trigger_data->net_dev || (trigger_data->mode & (MODE_TX | MODE_RX)) == 0) {
+		/* we don't need to do timer work, just reflect link state. */
+		led_set_brightness(trigger_data->led_cdev, ((trigger_data->mode & MODE_LINK) != 0 && trigger_data->link_up) ? LED_FULL : LED_OFF);
+		goto no_restart;
+	}
+
+	dev_stats = dev_get_stats(trigger_data->net_dev);
+	new_activity =
+		((trigger_data->mode & MODE_TX) ? dev_stats->tx_packets : 0) +
+		((trigger_data->mode & MODE_RX) ? dev_stats->rx_packets : 0);
+
+	if (trigger_data->mode & MODE_LINK) {
+		/* base state is ON (link present) */
+		/* if there's no link, we don't get this far and the LED is off */
+
+		/* OFF -> ON always */
+		/* ON -> OFF on activity */
+		if (trigger_data->led_cdev->brightness == LED_OFF) {
+			led_set_brightness(trigger_data->led_cdev, LED_FULL);
+		} else if (trigger_data->last_activity != new_activity) {
+			led_set_brightness(trigger_data->led_cdev, LED_OFF);
+		}
+	} else {
+		/* base state is OFF */
+		/* ON -> OFF always */
+		/* OFF -> ON on activity */
+		if (trigger_data->led_cdev->brightness == LED_FULL) {
+			led_set_brightness(trigger_data->led_cdev, LED_OFF);
+		} else if (trigger_data->last_activity != new_activity) {
+			led_set_brightness(trigger_data->led_cdev, LED_FULL);
+		}
+	}
+
+	trigger_data->last_activity = new_activity;
+	mod_timer(&trigger_data->timer, jiffies + trigger_data->interval);
+
+no_restart:
+	write_unlock(&trigger_data->lock);
+}
+
+static void netdev_trig_activate(struct led_classdev *led_cdev)
+{
+	struct led_netdev_data *trigger_data;
+	int rc;
+
+	trigger_data = kzalloc(sizeof(struct led_netdev_data), GFP_KERNEL);
+	if (!trigger_data)
+		return;
+
+	rwlock_init(&trigger_data->lock);
+
+	trigger_data->notifier.notifier_call = netdev_trig_notify;
+	trigger_data->notifier.priority = 10;
+
+	setup_timer(&trigger_data->timer, netdev_trig_timer, (unsigned long) trigger_data);
+
+	trigger_data->led_cdev = led_cdev;
+	trigger_data->net_dev = NULL;
+	trigger_data->device_name[0] = 0;
+
+	trigger_data->mode = 0;
+	trigger_data->interval = msecs_to_jiffies(50);
+	trigger_data->link_up = 0;
+	trigger_data->last_activity = 0;
+
+	led_cdev->trigger_data = trigger_data;
+
+	rc = device_create_file(led_cdev->dev, &dev_attr_device_name);
+	if (rc)
+		goto err_out;
+	rc = device_create_file(led_cdev->dev, &dev_attr_mode);
+	if (rc)
+		goto err_out_device_name;
+	rc = device_create_file(led_cdev->dev, &dev_attr_interval);
+	if (rc)
+		goto err_out_mode;
+
+	register_netdevice_notifier(&trigger_data->notifier);
+	return;
+
+err_out_mode:
+	device_remove_file(led_cdev->dev, &dev_attr_mode);
+err_out_device_name:
+	device_remove_file(led_cdev->dev, &dev_attr_device_name);
+err_out:
+	led_cdev->trigger_data = NULL;
+	kfree(trigger_data);
+}
+
+static void netdev_trig_deactivate(struct led_classdev *led_cdev)
+{
+	struct led_netdev_data *trigger_data = led_cdev->trigger_data;
+
+	if (trigger_data) {
+		unregister_netdevice_notifier(&trigger_data->notifier);
+
+		device_remove_file(led_cdev->dev, &dev_attr_device_name);
+		device_remove_file(led_cdev->dev, &dev_attr_mode);
+		device_remove_file(led_cdev->dev, &dev_attr_interval);
+
+		write_lock(&trigger_data->lock);
+
+		if (trigger_data->net_dev) {
+			dev_put(trigger_data->net_dev);
+			trigger_data->net_dev = NULL;
+		}
+
+		write_unlock(&trigger_data->lock);
+
+		del_timer_sync(&trigger_data->timer);
+
+		kfree(trigger_data);
+	}
+}
+
+static struct led_trigger netdev_led_trigger = {
+	.name     = "netdev",
+	.activate = netdev_trig_activate,
+	.deactivate = netdev_trig_deactivate,
+};
+
+static int __init netdev_trig_init(void)
+{
+	return led_trigger_register(&netdev_led_trigger);
+}
+
+static void __exit netdev_trig_exit(void)
+{
+	led_trigger_unregister(&netdev_led_trigger);
+}
+
+module_init(netdev_trig_init);
+module_exit(netdev_trig_exit);
+
+MODULE_AUTHOR("Oliver Jowett <oliver@opencloud.com>");
+MODULE_DESCRIPTION("Netdev LED trigger");
+MODULE_LICENSE("GPL");
diff --git a/drivers/leds/ledtrig-usbdev.c b/drivers/leds/ledtrig-usbdev.c
new file mode 100644
index 0000000..70b0e39
--- /dev/null
+++ b/drivers/leds/ledtrig-usbdev.c
@@ -0,0 +1,348 @@
+/*
+ * LED USB device Trigger
+ *
+ * Toggles the LED to reflect the presence and activity of an USB device
+ * Copyright (C) Gabor Juhos <juhosg@openwrt.org>
+ *
+ * derived from ledtrig-netdev.c:
+ *	Copyright 2007 Oliver Jowett <oliver@opencloud.com>
+ *
+ * ledtrig-netdev.c derived from ledtrig-timer.c:
+ *	Copyright 2005-2006 Openedhand Ltd.
+ *	Author: Richard Purdie <rpurdie@openedhand.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/jiffies.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/list.h>
+#include <linux/spinlock.h>
+#include <linux/device.h>
+#include <linux/sysdev.h>
+#include <linux/timer.h>
+#include <linux/ctype.h>
+#include <linux/slab.h>
+#include <linux/leds.h>
+#include <linux/usb.h>
+
+#include "leds.h"
+
+#define DEV_BUS_ID_SIZE		32
+
+/*
+ * Configurable sysfs attributes:
+ *
+ * device_name - name of the USB device to monitor
+ * activity_interval - duration of LED blink, in milliseconds
+ */
+
+struct usbdev_trig_data {
+	rwlock_t lock;
+
+	struct timer_list timer;
+	struct notifier_block notifier;
+
+	struct led_classdev *led_cdev;
+	struct usb_device *usb_dev;
+
+	char device_name[DEV_BUS_ID_SIZE];
+	unsigned interval;
+	int last_urbnum;
+};
+
+static void usbdev_trig_update_state(struct usbdev_trig_data *td)
+{
+	if (td->usb_dev)
+		led_set_brightness(td->led_cdev, LED_FULL);
+	else
+		led_set_brightness(td->led_cdev, LED_OFF);
+
+	if (td->interval && td->usb_dev)
+		mod_timer(&td->timer, jiffies + td->interval);
+	else
+		del_timer(&td->timer);
+}
+
+static ssize_t usbdev_trig_name_show(struct device *dev,
+				     struct device_attribute *attr,
+				     char *buf)
+{
+	struct led_classdev *led_cdev = dev_get_drvdata(dev);
+	struct usbdev_trig_data *td = led_cdev->trigger_data;
+
+	read_lock(&td->lock);
+	sprintf(buf, "%s\n", td->device_name);
+	read_unlock(&td->lock);
+
+	return strlen(buf) + 1;
+}
+
+static ssize_t usbdev_trig_name_store(struct device *dev,
+				      struct device_attribute *attr,
+				      const char *buf,
+				      size_t size)
+{
+	struct led_classdev *led_cdev = dev_get_drvdata(dev);
+	struct usbdev_trig_data *td = led_cdev->trigger_data;
+
+	if (size < 0 || size >= DEV_BUS_ID_SIZE)
+		return -EINVAL;
+
+	write_lock(&td->lock);
+
+	strcpy(td->device_name, buf);
+	if (size > 0 && td->device_name[size - 1] == '\n')
+		td->device_name[size - 1] = 0;
+
+	if (td->device_name[0] != 0) {
+		struct usb_device *usb_dev;
+
+		/* check for existing device to update from */
+		usb_dev = usb_find_device_by_name(td->device_name);
+		if (usb_dev) {
+			if (td->usb_dev)
+				usb_put_dev(td->usb_dev);
+
+			td->usb_dev = usb_dev;
+			td->last_urbnum = atomic_read(&usb_dev->urbnum);
+		}
+
+		/* updates LEDs, may start timers */
+		usbdev_trig_update_state(td);
+	}
+
+	write_unlock(&td->lock);
+	return size;
+}
+
+static DEVICE_ATTR(device_name, 0644, usbdev_trig_name_show,
+		   usbdev_trig_name_store);
+
+static ssize_t usbdev_trig_interval_show(struct device *dev,
+				 	 struct device_attribute *attr,
+					 char *buf)
+{
+	struct led_classdev *led_cdev = dev_get_drvdata(dev);
+	struct usbdev_trig_data *td = led_cdev->trigger_data;
+
+	read_lock(&td->lock);
+	sprintf(buf, "%u\n", jiffies_to_msecs(td->interval));
+	read_unlock(&td->lock);
+
+	return strlen(buf) + 1;
+}
+
+static ssize_t usbdev_trig_interval_store(struct device *dev,
+					  struct device_attribute *attr,
+					  const char *buf,
+					  size_t size)
+{
+	struct led_classdev *led_cdev = dev_get_drvdata(dev);
+	struct usbdev_trig_data *td = led_cdev->trigger_data;
+	int ret = -EINVAL;
+	char *after;
+	unsigned long value = simple_strtoul(buf, &after, 10);
+	size_t count = after - buf;
+
+	if (*after && isspace(*after))
+		count++;
+
+	if (count == size && value <= 10000) {
+		write_lock(&td->lock);
+		td->interval = msecs_to_jiffies(value);
+		usbdev_trig_update_state(td); /* resets timer */
+		write_unlock(&td->lock);
+		ret = count;
+	}
+
+	return ret;
+}
+
+static DEVICE_ATTR(activity_interval, 0644, usbdev_trig_interval_show,
+		   usbdev_trig_interval_store);
+
+static int usbdev_trig_notify(struct notifier_block *nb,
+			      unsigned long evt,
+			      void *data)
+{
+	struct usb_device *usb_dev;
+	struct usbdev_trig_data *td;
+
+	if (evt != USB_DEVICE_ADD && evt != USB_DEVICE_REMOVE)
+		return NOTIFY_DONE;
+
+	usb_dev = data;
+	td = container_of(nb, struct usbdev_trig_data, notifier);
+
+	write_lock(&td->lock);
+
+	if (strcmp(dev_name(&usb_dev->dev), td->device_name))
+		goto done;
+
+	if (evt == USB_DEVICE_ADD) {
+		usb_get_dev(usb_dev);
+		if (td->usb_dev != NULL)
+			usb_put_dev(td->usb_dev);
+		td->usb_dev = usb_dev;
+		td->last_urbnum = atomic_read(&usb_dev->urbnum);
+	} else if (evt == USB_DEVICE_REMOVE) {
+		if (td->usb_dev != NULL) {
+			usb_put_dev(td->usb_dev);
+			td->usb_dev = NULL;
+		}
+	}
+
+	usbdev_trig_update_state(td);
+
+done:
+	write_unlock(&td->lock);
+	return NOTIFY_DONE;
+}
+
+/* here's the real work! */
+static void usbdev_trig_timer(unsigned long arg)
+{
+	struct usbdev_trig_data *td = (struct usbdev_trig_data *)arg;
+	int new_urbnum;
+
+	write_lock(&td->lock);
+
+	if (!td->usb_dev || td->interval == 0) {
+		/*
+		 * we don't need to do timer work, just reflect device presence
+		 */
+		if (td->usb_dev)
+			led_set_brightness(td->led_cdev, LED_FULL);
+		else
+			led_set_brightness(td->led_cdev, LED_OFF);
+
+		goto no_restart;
+	}
+
+	if (td->interval)
+		new_urbnum = atomic_read(&td->usb_dev->urbnum);
+	else
+		new_urbnum = 0;
+
+	if (td->usb_dev) {
+		/*
+		 * Base state is ON (device is present). If there's no device,
+		 * we don't get this far and the LED is off.
+		 * OFF -> ON always
+		 * ON -> OFF on activity
+		 */
+		if (td->led_cdev->brightness == LED_OFF)
+			led_set_brightness(td->led_cdev, LED_FULL);
+		else if (td->last_urbnum != new_urbnum)
+			led_set_brightness(td->led_cdev, LED_OFF);
+	} else {
+		/*
+		 * base state is OFF
+		 * ON -> OFF always
+		 * OFF -> ON on activity
+		 */
+		if (td->led_cdev->brightness == LED_FULL)
+			led_set_brightness(td->led_cdev, LED_OFF);
+		else if (td->last_urbnum != new_urbnum)
+			led_set_brightness(td->led_cdev, LED_FULL);
+	}
+
+	td->last_urbnum = new_urbnum;
+	mod_timer(&td->timer, jiffies + td->interval);
+
+no_restart:
+	write_unlock(&td->lock);
+}
+
+static void usbdev_trig_activate(struct led_classdev *led_cdev)
+{
+	struct usbdev_trig_data *td;
+	int rc;
+
+	td = kzalloc(sizeof(struct usbdev_trig_data), GFP_KERNEL);
+	if (!td)
+		return;
+
+	rwlock_init(&td->lock);
+
+	td->notifier.notifier_call = usbdev_trig_notify;
+	td->notifier.priority = 10;
+
+	setup_timer(&td->timer, usbdev_trig_timer, (unsigned long) td);
+
+	td->led_cdev = led_cdev;
+	td->interval = msecs_to_jiffies(50);
+
+	led_cdev->trigger_data = td;
+
+	rc = device_create_file(led_cdev->dev, &dev_attr_device_name);
+	if (rc)
+		goto err_out;
+
+	rc = device_create_file(led_cdev->dev, &dev_attr_activity_interval);
+	if (rc)
+		goto err_out_device_name;
+
+	usb_register_notify(&td->notifier);
+	return;
+
+err_out_device_name:
+	device_remove_file(led_cdev->dev, &dev_attr_device_name);
+err_out:
+	led_cdev->trigger_data = NULL;
+	kfree(td);
+}
+
+static void usbdev_trig_deactivate(struct led_classdev *led_cdev)
+{
+	struct usbdev_trig_data *td = led_cdev->trigger_data;
+
+	if (td) {
+		usb_unregister_notify(&td->notifier);
+
+		device_remove_file(led_cdev->dev, &dev_attr_device_name);
+		device_remove_file(led_cdev->dev, &dev_attr_activity_interval);
+
+		write_lock(&td->lock);
+
+		if (td->usb_dev) {
+			usb_put_dev(td->usb_dev);
+			td->usb_dev = NULL;
+		}
+
+		write_unlock(&td->lock);
+
+		del_timer_sync(&td->timer);
+
+		kfree(td);
+	}
+}
+
+static struct led_trigger usbdev_led_trigger = {
+	.name		= "usbdev",
+	.activate	= usbdev_trig_activate,
+	.deactivate	= usbdev_trig_deactivate,
+};
+
+static int __init usbdev_trig_init(void)
+{
+	return led_trigger_register(&usbdev_led_trigger);
+}
+
+static void __exit usbdev_trig_exit(void)
+{
+	led_trigger_unregister(&usbdev_led_trigger);
+}
+
+module_init(usbdev_trig_init);
+module_exit(usbdev_trig_exit);
+
+MODULE_AUTHOR("Gabor Juhos <juhosg@openwrt.org>");
+MODULE_DESCRIPTION("USB device LED trigger");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/net/phy/Kconfig b/drivers/net/phy/Kconfig
index 921c563..d022802 100644
--- a/drivers/net/phy/Kconfig
+++ b/drivers/net/phy/Kconfig
@@ -120,6 +120,10 @@ config RTL8306_PHY
 	tristate "Driver for Realtek RTL8306S switches"
 	select SWCONFIG
 
+config IP17XX_PHY
+	tristate "Driver for IC+ IP17xx switches"
+	select SWCONFIG
+
 config FIXED_PHY
 	bool "Driver for MDIO Bus/PHY emulation with fixed speed/link PHYs"
 	depends on PHYLIB=y
diff --git a/drivers/pci/Kconfig b/drivers/pci/Kconfig
index 0fa466a..34dafdc 100644
--- a/drivers/pci/Kconfig
+++ b/drivers/pci/Kconfig
@@ -62,6 +62,12 @@ config XEN_PCIDEV_FE_DEBUG
 
 	  When in doubt, say N.
 
+config PCI_DISABLE_COMMON_QUIRKS
+	bool "PCI disable common quirks"
+	depends on PCI
+	help
+	  If you don't know what to do here, say N.
+
 config HT_IRQ
 	bool "Interrupts on hypertransport devices"
 	default y
diff --git a/drivers/pci/quirks.c b/drivers/pci/quirks.c
index cec4629..622c21f 100644
--- a/drivers/pci/quirks.c
+++ b/drivers/pci/quirks.c
@@ -104,6 +104,7 @@ static void __devinit quirk_mmio_always_on(struct pci_dev *dev)
 }
 DECLARE_PCI_FIXUP_EARLY(PCI_ANY_ID, PCI_ANY_ID, quirk_mmio_always_on);
 
+#ifndef CONFIG_PCI_DISABLE_COMMON_QUIRKS
 /* The Mellanox Tavor device gives false positive parity errors
  * Mark this device with a broken_parity_status, to allow
  * PCI scanning code to "skip" this now blacklisted device.
@@ -1989,7 +1990,9 @@ static void __devinit fixup_rev1_53c810(struct pci_dev* dev)
 	}
 }
 DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_NCR, PCI_DEVICE_ID_NCR_53C810, fixup_rev1_53c810);
+#endif /* !CONFIG_PCI_DISABLE_COMMON_QUIRKS */
 
+#ifndef CONFIG_PCI_DISABLE_COMMON_QUIRKS
 /* Enable 1k I/O space granularity on the Intel P64H2 */
 static void __devinit quirk_p64h2_1k_io(struct pci_dev *dev)
 {
@@ -2665,6 +2668,7 @@ DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_ATI, 0x4375,
 			quirk_msi_intx_disable_bug);
 
 #endif /* CONFIG_PCI_MSI */
+#endif /* !CONFIG_PCI_DISABLE_COMMON_QUIRKS */
 
 /* Allow manual resource allocation for PCI hotplug bridges
  * via pci=hpmemsize=nnM and pci=hpiosize=nnM parameters. For
diff --git a/drivers/rtc/Kconfig b/drivers/rtc/Kconfig
index ce2aabf..4db24a7 100644
--- a/drivers/rtc/Kconfig
+++ b/drivers/rtc/Kconfig
@@ -719,6 +719,15 @@ config RTC_DRV_NUC900
 	  If you say yes here you get support for the RTC subsystem of the
 	  NUC910/NUC920 used in embedded systems.
 
+config RTC_DRV_RTC7301
+	tristate "Epson RTC-7301 SF/DG"
+	help
+	  If you say Y here you will get support for the
+	  Epson RTC-7301 SF/DG RTC chips.
+
+	  This driver can also be built as a module. If so, the module
+	  will be called rtc-7301.
+
 comment "on-CPU RTC drivers"
 
 config RTC_DRV_DAVINCI
diff --git a/drivers/rtc/Makefile b/drivers/rtc/Makefile
index 0ffefe8..8b202b3 100644
--- a/drivers/rtc/Makefile
+++ b/drivers/rtc/Makefile
@@ -85,6 +85,7 @@ obj-$(CONFIG_RTC_DRV_RP5C01)	+= rtc-rp5c01.o
 obj-$(CONFIG_RTC_DRV_RS5C313)	+= rtc-rs5c313.o
 obj-$(CONFIG_RTC_DRV_RS5C348)	+= rtc-rs5c348.o
 obj-$(CONFIG_RTC_DRV_RS5C372)	+= rtc-rs5c372.o
+obj-$(CONFIG_RTC_DRV_RTC7301)	+= rtc-rtc7301.o
 obj-$(CONFIG_RTC_DRV_RV3029C2)	+= rtc-rv3029c2.o
 obj-$(CONFIG_RTC_DRV_RX8025)	+= rtc-rx8025.o
 obj-$(CONFIG_RTC_DRV_RX8581)	+= rtc-rx8581.o
diff --git a/drivers/rtc/rtc-rtc7301.c b/drivers/rtc/rtc-rtc7301.c
new file mode 100644
index 0000000..c3d0256
--- /dev/null
+++ b/drivers/rtc/rtc-rtc7301.c
@@ -0,0 +1,219 @@
+/*
+ * Driver for Epson RTC-7301SF/DG
+ *
+ * Copyright (C) 2009 Jose Vasconcellos
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/rtc.h>
+#include <linux/platform_device.h>
+#include <linux/io.h>
+#include <linux/delay.h>
+#include <linux/bcd.h>
+
+#define RTC_NAME "rtc7301"
+#define RTC_VERSION "0.1"
+
+/* Epson RTC-7301 register addresses */
+#define RTC7301_SEC		0x00
+#define RTC7301_SEC10		0x01
+#define RTC7301_MIN		0x02
+#define RTC7301_MIN10		0x03
+#define RTC7301_HOUR		0x04
+#define RTC7301_HOUR10		0x05
+#define RTC7301_WEEKDAY		0x06
+#define RTC7301_DAY		0x07
+#define RTC7301_DAY10		0x08
+#define RTC7301_MON		0x09
+#define RTC7301_MON10		0x0A
+#define RTC7301_YEAR		0x0B
+#define RTC7301_YEAR10		0x0C
+#define RTC7301_YEAR100		0x0D
+#define RTC7301_YEAR1000	0x0E
+#define RTC7301_CTRLREG		0x0F
+
+static uint8_t __iomem *rtc7301_base;
+
+#define read_reg(offset) (readb(rtc7301_base + offset) & 0xf)
+#define write_reg(offset, data) writeb(data, rtc7301_base + (offset))
+
+#define rtc7301_isbusy() (read_reg(RTC7301_CTRLREG) & 1)
+
+static void rtc7301_init_settings(void)
+{
+	int i;
+
+	write_reg(RTC7301_CTRLREG, 2);
+	write_reg(RTC7301_YEAR1000, 2);
+	udelay(122);
+
+	/* bank 1 */
+	write_reg(RTC7301_CTRLREG, 6);
+	for (i=0; i<15; i++)
+		write_reg(i, 0);
+
+	/* bank 2 */
+	write_reg(RTC7301_CTRLREG, 14);
+	for (i=0; i<15; i++)
+		write_reg(i, 0);
+	write_reg(RTC7301_CTRLREG, 0);
+}
+
+static int rtc7301_get_datetime(struct device *dev, struct rtc_time *dt)
+{
+	int cnt;
+	uint8_t buf[16];
+
+	cnt = 0;
+	while (rtc7301_isbusy()) {
+		udelay(244);
+		if (cnt++ > 100) {
+			dev_err(dev, "%s: timeout error %x\n", __func__, rtc7301_base[RTC7301_CTRLREG]);
+			return -EIO;
+		}
+	}
+
+	for (cnt=0; cnt<16; cnt++)
+		buf[cnt] = read_reg(cnt);
+
+	if (buf[RTC7301_SEC10] & 8) {
+		dev_err(dev, "%s: RTC not set\n", __func__);
+		return -EINVAL;
+	}
+
+	memset(dt, 0, sizeof(*dt));
+
+	dt->tm_sec =  buf[RTC7301_SEC] + buf[RTC7301_SEC10]*10;
+	dt->tm_min =  buf[RTC7301_MIN] + buf[RTC7301_MIN10]*10;
+	dt->tm_hour = buf[RTC7301_HOUR] + buf[RTC7301_HOUR10]*10;
+
+	dt->tm_mday = buf[RTC7301_DAY] + buf[RTC7301_DAY10]*10;
+	dt->tm_mon =  buf[RTC7301_MON] + buf[RTC7301_MON10]*10 - 1;
+	dt->tm_year = buf[RTC7301_YEAR] + buf[RTC7301_YEAR10]*10 +
+		      buf[RTC7301_YEAR100]*100 +
+		      ((buf[RTC7301_YEAR1000] & 3)*1000) - 1900;
+
+	/* the rtc device may contain illegal values on power up
+	 * according to the data sheet. make sure they are valid.
+	 */
+
+	return rtc_valid_tm(dt);
+}
+
+static int rtc7301_set_datetime(struct device *dev, struct rtc_time *dt)
+{
+	int data;
+
+	data = dt->tm_year + 1900;
+	if (data >= 2100 || data < 1900)
+		return -EINVAL;
+
+	write_reg(RTC7301_CTRLREG, 2);
+       	udelay(122);
+
+	data = bin2bcd(dt->tm_sec);
+	write_reg(RTC7301_SEC, data);
+	write_reg(RTC7301_SEC10, (data >> 4));
+
+	data = bin2bcd(dt->tm_min);
+	write_reg(RTC7301_MIN, data );
+	write_reg(RTC7301_MIN10, (data >> 4));
+
+	data = bin2bcd(dt->tm_hour);
+	write_reg(RTC7301_HOUR, data);
+	write_reg(RTC7301_HOUR10, (data >> 4));
+
+	data = bin2bcd(dt->tm_mday);
+	write_reg(RTC7301_DAY, data);
+	write_reg(RTC7301_DAY10, (data>> 4));
+
+	data = bin2bcd(dt->tm_mon + 1);
+	write_reg(RTC7301_MON, data);
+	write_reg(RTC7301_MON10, (data >> 4));
+
+	data = bin2bcd(dt->tm_year % 100);
+	write_reg(RTC7301_YEAR, data);
+	write_reg(RTC7301_YEAR10, (data >> 4));
+	data = bin2bcd((1900 + dt->tm_year) / 100);
+	write_reg(RTC7301_YEAR100, data);
+
+	data = bin2bcd(dt->tm_wday);
+	write_reg(RTC7301_WEEKDAY, data);
+
+	write_reg(RTC7301_CTRLREG, 0);
+
+	return 0;
+}
+
+static const struct rtc_class_ops rtc7301_rtc_ops = {
+	.read_time	= rtc7301_get_datetime,
+	.set_time	= rtc7301_set_datetime,
+};
+
+static int __devinit rtc7301_probe(struct platform_device *pdev)
+{
+	struct rtc_device *rtc;
+	struct resource *res;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res)
+		return -ENOENT;
+
+	rtc7301_base = ioremap_nocache(res->start, 0x1000 /*res->end - res->start + 1*/);
+	if (!rtc7301_base)
+		return -EINVAL;
+
+	rtc = rtc_device_register(RTC_NAME, &pdev->dev,
+				&rtc7301_rtc_ops, THIS_MODULE);
+	if (IS_ERR(rtc)) {
+		iounmap(rtc7301_base);
+		return PTR_ERR(rtc);
+	}
+
+	platform_set_drvdata(pdev, rtc);
+
+	rtc7301_init_settings();
+	return 0;
+}
+
+static int __devexit rtc7301_remove(struct platform_device *pdev)
+{
+	struct rtc_device *rtc = platform_get_drvdata(pdev);
+
+	if (rtc)
+		rtc_device_unregister(rtc);
+	if (rtc7301_base)
+		iounmap(rtc7301_base);
+	return 0;
+}
+
+static struct platform_driver rtc7301_driver = {
+	.driver = {
+		.name	= RTC_NAME,
+		.owner	= THIS_MODULE,
+	},
+	.probe	= rtc7301_probe,
+	.remove = __devexit_p(rtc7301_remove),
+};
+
+static __init int rtc7301_init(void)
+{
+	return platform_driver_register(&rtc7301_driver);
+}
+module_init(rtc7301_init);
+
+static __exit void rtc7301_exit(void)
+{
+	platform_driver_unregister(&rtc7301_driver);
+}
+module_exit(rtc7301_exit);
+
+MODULE_DESCRIPTION("Epson 7301 RTC driver");
+MODULE_AUTHOR("Jose Vasconcellos <jvasco@verizon.net>");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:" RTC_NAME);
+MODULE_VERSION(RTC_VERSION);
diff --git a/drivers/spi/spi_gpio.c b/drivers/spi/spi_gpio.c
index 63e51b0..22d0b00 100644
--- a/drivers/spi/spi_gpio.c
+++ b/drivers/spi/spi_gpio.c
@@ -255,7 +255,7 @@ static void spi_gpio_cleanup(struct spi_device *spi)
 	spi_bitbang_cleanup(spi);
 }
 
-static int __init spi_gpio_alloc(unsigned pin, const char *label, bool is_in)
+static int __devinit spi_gpio_alloc(unsigned pin, const char *label, bool is_in)
 {
 	int value;
 
@@ -269,7 +269,7 @@ static int __init spi_gpio_alloc(unsigned pin, const char *label, bool is_in)
 	return value;
 }
 
-static int __init
+static int __devinit
 spi_gpio_request(struct spi_gpio_platform_data *pdata, const char *label,
 	u16 *res_flags)
 {
@@ -311,7 +311,7 @@ done:
 	return value;
 }
 
-static int __init spi_gpio_probe(struct platform_device *pdev)
+static int __devinit spi_gpio_probe(struct platform_device *pdev)
 {
 	int				status;
 	struct spi_master		*master;
@@ -379,7 +379,7 @@ gpio_free:
 	return status;
 }
 
-static int __exit spi_gpio_remove(struct platform_device *pdev)
+static int __devexit spi_gpio_remove(struct platform_device *pdev)
 {
 	struct spi_gpio			*spi_gpio;
 	struct spi_gpio_platform_data	*pdata;
@@ -408,12 +408,13 @@ MODULE_ALIAS("platform:" DRIVER_NAME);
 static struct platform_driver spi_gpio_driver = {
 	.driver.name	= DRIVER_NAME,
 	.driver.owner	= THIS_MODULE,
-	.remove		= __exit_p(spi_gpio_remove),
+	.probe		= spi_gpio_probe,
+	.remove		= __devexit_p(spi_gpio_remove),
 };
 
 static int __init spi_gpio_init(void)
 {
-	return platform_driver_probe(&spi_gpio_driver, spi_gpio_probe);
+	return platform_driver_register(&spi_gpio_driver);
 }
 module_init(spi_gpio_init);
 
diff --git a/drivers/usb/core/usb.c b/drivers/usb/core/usb.c
index 8706fc9..4540ce3 100644
--- a/drivers/usb/core/usb.c
+++ b/drivers/usb/core/usb.c
@@ -651,6 +651,71 @@ int __usb_get_extra_descriptor(char *buffer, unsigned size,
 }
 EXPORT_SYMBOL_GPL(__usb_get_extra_descriptor);
 
+static struct usb_device *match_device_name(struct usb_device *dev,
+					    const char *name)
+{
+	struct usb_device *ret_dev = NULL;
+	int child;
+
+	dev_dbg(&dev->dev, "check for name %s ...\n", name);
+
+	/* see if this device matches */
+	if (strcmp(dev_name(&dev->dev), name) == 0 ) {
+		dev_dbg(&dev->dev, "matched this device!\n");
+		ret_dev = usb_get_dev(dev);
+		goto exit;
+	}
+
+	/* look through all of the children of this device */
+	for (child = 0; child < dev->maxchild; ++child) {
+		if (dev->children[child]) {
+			usb_lock_device(dev->children[child]);
+			ret_dev = match_device_name(dev->children[child], name);
+			usb_unlock_device(dev->children[child]);
+			if (ret_dev)
+				goto exit;
+		}
+	}
+exit:
+	return ret_dev;
+}
+
+/**
+ * usb_find_device_by_name - find a specific usb device in the system
+ * @name: the name of the device to find
+ *
+ * Returns a pointer to a struct usb_device if such a specified usb
+ * device is present in the system currently.  The usage count of the
+ * device will be incremented if a device is found.  Make sure to call
+ * usb_put_dev() when the caller is finished with the device.
+ *
+ * If a device with the specified bus id is not found, NULL is returned.
+ */
+struct usb_device *usb_find_device_by_name(const char *name)
+{
+	struct list_head *buslist;
+	struct usb_bus *bus;
+	struct usb_device *dev = NULL;
+
+	mutex_lock(&usb_bus_list_lock);
+	for (buslist = usb_bus_list.next;
+	     buslist != &usb_bus_list;
+	     buslist = buslist->next) {
+		bus = container_of(buslist, struct usb_bus, bus_list);
+		if (!bus->root_hub)
+			continue;
+		usb_lock_device(bus->root_hub);
+		dev = match_device_name(bus->root_hub, name);
+		usb_unlock_device(bus->root_hub);
+		if (dev)
+			goto exit;
+	}
+exit:
+	mutex_unlock(&usb_bus_list_lock);
+	return dev;
+}
+EXPORT_SYMBOL_GPL(usb_find_device_by_name);
+
 /**
  * usb_alloc_coherent - allocate dma-consistent buffer for URB_NO_xxx_DMA_MAP
  * @dev: device the buffer will be used with
diff --git a/drivers/usb/host/pci-quirks.c b/drivers/usb/host/pci-quirks.c
index 40a4a4e..f4da719 100644
--- a/drivers/usb/host/pci-quirks.c
+++ b/drivers/usb/host/pci-quirks.c
@@ -439,6 +439,8 @@ reset_needed:
 }
 EXPORT_SYMBOL_GPL(uhci_check_and_reset_hc);
 
+#ifndef CONFIG_PCI_DISABLE_COMMON_QUIRKS
+
 static inline int io_type_enabled(struct pci_dev *pdev, unsigned int mask)
 {
 	u16 cmd;
@@ -892,3 +894,5 @@ static void __devinit quirk_usb_early_handoff(struct pci_dev *pdev)
 		quirk_usb_handoff_xhci(pdev);
 }
 DECLARE_PCI_FIXUP_FINAL(PCI_ANY_ID, PCI_ANY_ID, quirk_usb_early_handoff);
+
+#endif
diff --git a/include/linux/Kbuild b/include/linux/Kbuild
index 01f6362..7d3581c 100644
--- a/include/linux/Kbuild
+++ b/include/linux/Kbuild
@@ -143,6 +143,8 @@ header-y += generic_serial.h
 header-y += genetlink.h
 header-y += gfs2_ondisk.h
 header-y += gigaset_dev.h
+header-y += glamofb.h
+header-y += glamo-engine.h
 header-y += hdlc.h
 header-y += hdlcdrv.h
 header-y += hdreg.h
diff --git a/include/linux/fb.h b/include/linux/fb.h
index 6a82748..267291e 100644
--- a/include/linux/fb.h
+++ b/include/linux/fb.h
@@ -125,6 +125,7 @@
 #define FB_ACCEL_TRIDENT_BLADE3D 52	/* Trident Blade3D		*/
 #define FB_ACCEL_TRIDENT_BLADEXP 53	/* Trident BladeXP		*/
 #define FB_ACCEL_CIRRUS_ALPINE   53	/* Cirrus Logic 543x/544x/5480	*/
+#define FB_ACCEL_GLAMO		50	/* SMedia Glamo                 */
 #define FB_ACCEL_NEOMAGIC_NM2070 90	/* NeoMagic NM2070              */
 #define FB_ACCEL_NEOMAGIC_NM2090 91	/* NeoMagic NM2090              */
 #define FB_ACCEL_NEOMAGIC_NM2093 92	/* NeoMagic NM2093              */
diff --git a/include/linux/usb.h b/include/linux/usb.h
index 73c7df4..be3dfb9 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -513,6 +513,7 @@ extern int usb_lock_device_for_reset(struct usb_device *udev,
 extern int usb_reset_device(struct usb_device *dev);
 extern void usb_queue_reset_device(struct usb_interface *dev);
 
+extern struct usb_device *usb_find_device_by_name(const char *name);
 
 /* USB autosuspend and autoresume */
 #ifdef CONFIG_USB_SUSPEND
-- 
1.7.4.1

