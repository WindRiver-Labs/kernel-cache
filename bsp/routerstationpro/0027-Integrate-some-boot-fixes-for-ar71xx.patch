From 2e28b7f501c34477668ed726deba2b56287f7976 Mon Sep 17 00:00:00 2001
From: Zumeng Chen <zumeng.chen@windriver.com>
Date: Thu, 24 Nov 2011 16:05:55 +0800
Subject: [PATCH 27/41] Integrate some boot fixes for ar71xx

which from the following git repo.
  git://nbd.name/openwrt.git
  902-fix-occasional-kernel-hangs-during-boot.patch
  910-unaligned_access_hacks.patch
  920-mdio_bitbang_ignore_ta_value.patch

Integrated-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 arch/mips/include/asm/checksum.h               |   27 ++++++++++-------
 arch/mips/kernel/cevt-r4k.c                    |   38 ++++++++++++------------
 drivers/net/phy/mdio-bitbang.c                 |   11 +------
 include/linux/ip.h                             |    2 +-
 include/linux/ipv6.h                           |    2 +-
 include/linux/tcp.h                            |    2 +-
 include/linux/udp.h                            |    2 +-
 net/ipv4/netfilter/nf_conntrack_l3proto_ipv4.c |    5 ++-
 8 files changed, 43 insertions(+), 46 deletions(-)

diff --git a/arch/mips/include/asm/checksum.h b/arch/mips/include/asm/checksum.h
index f2f7c6c..9be4201 100644
--- a/arch/mips/include/asm/checksum.h
+++ b/arch/mips/include/asm/checksum.h
@@ -12,6 +12,7 @@
 #define _ASM_CHECKSUM_H
 
 #include <linux/in6.h>
+#include <linux/unaligned/packed_struct.h>
 
 #include <asm/uaccess.h>
 
@@ -104,26 +105,30 @@ static inline __sum16 ip_fast_csum(const void *iph, unsigned int ihl)
 	const unsigned int *stop = word + ihl;
 	unsigned int csum;
 	int carry;
+	unsigned int w;
 
-	csum = word[0];
-	csum += word[1];
-	carry = (csum < word[1]);
+	csum = __get_unaligned_cpu32(word++);
+
+	w = __get_unaligned_cpu32(word++);
+	csum += w;
+	carry = (csum < w);
 	csum += carry;
 
-	csum += word[2];
-	carry = (csum < word[2]);
+	w = __get_unaligned_cpu32(word++);
+	csum += w;
+	carry = (csum < w);
 	csum += carry;
 
-	csum += word[3];
-	carry = (csum < word[3]);
+	w = __get_unaligned_cpu32(word++);
+	csum += w;
+	carry = (csum < w);
 	csum += carry;
 
-	word += 4;
 	do {
-		csum += *word;
-		carry = (csum < *word);
+		w = __get_unaligned_cpu32(word++);
+		csum += w;
+		carry = (csum < w);
 		csum += carry;
-		word++;
 	} while (word != stop);
 
 	return csum_fold(csum);
diff --git a/arch/mips/kernel/cevt-r4k.c b/arch/mips/kernel/cevt-r4k.c
index 98c5a97..e2d8e19 100644
--- a/arch/mips/kernel/cevt-r4k.c
+++ b/arch/mips/kernel/cevt-r4k.c
@@ -103,19 +103,10 @@ static int c0_compare_int_pending(void)
 
 /*
  * Compare interrupt can be routed and latched outside the core,
- * so a single execution hazard barrier may not be enough to give
- * it time to clear as seen in the Cause register.  4 time the
- * pipeline depth seems reasonably conservative, and empirically
- * works better in configurations with high CPU/bus clock ratios.
+ * so wait up to worst case number of cycle counter ticks for timer interrupt
+ * changes to propagate to the cause register.
  */
-
-#define compare_change_hazard() \
-	do { \
-		irq_disable_hazard(); \
-		irq_disable_hazard(); \
-		irq_disable_hazard(); \
-		irq_disable_hazard(); \
-	} while (0)
+#define COMPARE_INT_SEEN_TICKS 50
 
 int c0_compare_int_usable(void)
 {
@@ -126,8 +117,12 @@ int c0_compare_int_usable(void)
 	 * IP7 already pending?  Try to clear it by acking the timer.
 	 */
 	if (c0_compare_int_pending()) {
-		write_c0_compare(read_c0_count());
-		compare_change_hazard();
+		cnt = read_c0_count();
+		write_c0_compare(cnt);
+		back_to_back_c0_hazard();
+		while (read_c0_count() < (cnt  + COMPARE_INT_SEEN_TICKS))
+			if (!c0_compare_int_pending())
+				break;
 		if (c0_compare_int_pending())
 			return 0;
 	}
@@ -136,7 +131,7 @@ int c0_compare_int_usable(void)
 		cnt = read_c0_count();
 		cnt += delta;
 		write_c0_compare(cnt);
-		compare_change_hazard();
+		back_to_back_c0_hazard();
 		if ((int)(read_c0_count() - cnt) < 0)
 		    break;
 		/* increase delta if the timer was already expired */
@@ -145,12 +140,17 @@ int c0_compare_int_usable(void)
 	while ((int)(read_c0_count() - cnt) <= 0)
 		;	/* Wait for expiry  */
 
-	compare_change_hazard();
+	while (read_c0_count() < (cnt + COMPARE_INT_SEEN_TICKS))
+		if (c0_compare_int_pending())
+			break;
 	if (!c0_compare_int_pending())
 		return 0;
-
-	write_c0_compare(read_c0_count());
-	compare_change_hazard();
+	cnt = read_c0_count();
+	write_c0_compare(cnt);
+	back_to_back_c0_hazard();
+	while (read_c0_count() < (cnt + COMPARE_INT_SEEN_TICKS))
+		if (!c0_compare_int_pending())
+			break;
 	if (c0_compare_int_pending())
 		return 0;
 
diff --git a/drivers/net/phy/mdio-bitbang.c b/drivers/net/phy/mdio-bitbang.c
index 6539189..467dd3c 100644
--- a/drivers/net/phy/mdio-bitbang.c
+++ b/drivers/net/phy/mdio-bitbang.c
@@ -165,16 +165,7 @@ static int mdiobb_read(struct mii_bus *bus, int phy, int reg)
 
 	ctrl->ops->set_mdio_dir(ctrl, 0);
 
-	/* check the turnaround bit: the PHY should be driving it to zero */
-	if (mdiobb_get_bit(ctrl) != 0) {
-		/* PHY didn't drive TA low -- flush any bits it
-		 * may be trying to send.
-		 */
-		for (i = 0; i < 32; i++)
-			mdiobb_get_bit(ctrl);
-
-		return 0xffff;
-	}
+	mdiobb_get_bit(ctrl);
 
 	ret = mdiobb_get_num(ctrl, 16);
 	mdiobb_get_bit(ctrl);
diff --git a/include/linux/ip.h b/include/linux/ip.h
index bd0a2a8..7a3f2d3 100644
--- a/include/linux/ip.h
+++ b/include/linux/ip.h
@@ -102,7 +102,7 @@ struct iphdr {
 	__be32	saddr;
 	__be32	daddr;
 	/*The options start here. */
-};
+} __packed;
 
 #ifdef __KERNEL__
 #include <linux/skbuff.h>
diff --git a/include/linux/ipv6.h b/include/linux/ipv6.h
index 0c99776..3d4407e 100644
--- a/include/linux/ipv6.h
+++ b/include/linux/ipv6.h
@@ -126,7 +126,7 @@ struct ipv6hdr {
 
 	struct	in6_addr	saddr;
 	struct	in6_addr	daddr;
-};
+} __packed;
 
 #ifdef __KERNEL__
 /*
diff --git a/include/linux/tcp.h b/include/linux/tcp.h
index e64f4c6..b561b41 100644
--- a/include/linux/tcp.h
+++ b/include/linux/tcp.h
@@ -54,7 +54,7 @@ struct tcphdr {
 	__be16	window;
 	__sum16	check;
 	__be16	urg_ptr;
-};
+} __packed;
 
 /*
  *	The union cast uses a gcc extension to avoid aliasing problems
diff --git a/include/linux/udp.h b/include/linux/udp.h
index 03f72a2..ea34ce7 100644
--- a/include/linux/udp.h
+++ b/include/linux/udp.h
@@ -24,7 +24,7 @@ struct udphdr {
 	__be16	dest;
 	__be16	len;
 	__sum16	check;
-};
+} __packed;
 
 /* UDP socket options */
 #define UDP_CORK	1	/* Never send partially complete segments */
diff --git a/net/ipv4/netfilter/nf_conntrack_l3proto_ipv4.c b/net/ipv4/netfilter/nf_conntrack_l3proto_ipv4.c
index de9da21..2704407 100644
--- a/net/ipv4/netfilter/nf_conntrack_l3proto_ipv4.c
+++ b/net/ipv4/netfilter/nf_conntrack_l3proto_ipv4.c
@@ -14,6 +14,7 @@
 #include <linux/skbuff.h>
 #include <linux/icmp.h>
 #include <linux/sysctl.h>
+#include <linux/unaligned/packed_struct.h>
 #include <net/route.h>
 #include <net/ip.h>
 
@@ -44,8 +45,8 @@ static bool ipv4_pkt_to_tuple(const struct sk_buff *skb, unsigned int nhoff,
 	if (ap == NULL)
 		return false;
 
-	tuple->src.u3.ip = ap[0];
-	tuple->dst.u3.ip = ap[1];
+	tuple->src.u3.ip = __get_unaligned_cpu32(ap++);
+	tuple->dst.u3.ip = __get_unaligned_cpu32(ap);
 
 	return true;
 }
-- 
1.7.4.1

