From 2e28b7f501c34477668ed726deba2b56287f7976 Mon Sep 17 00:00:00 2001
From: Zumeng Chen <zumeng.chen@windriver.com>
Date: Thu, 24 Nov 2011 16:05:55 +0800
Subject: [PATCH 27/41] Integrate some boot fixes for ar71xx

which from the following git repo.
  git://nbd.name/openwrt.git
  902-fix-occasional-kernel-hangs-during-boot.patch
  910-unaligned_access_hacks.patch
  920-mdio_bitbang_ignore_ta_value.patch

Integrated-by: Zumeng Chen <zumeng.chen@windriver.com>
diff --git a/arch/mips/include/asm/checksum.h b/arch/mips/include/asm/checksum.h
index f2f7c6c..9be4201 100644
--- a/arch/mips/include/asm/checksum.h
+++ b/arch/mips/include/asm/checksum.h
@@ -12,6 +12,7 @@
 #define _ASM_CHECKSUM_H
 
 #include <linux/in6.h>
+#include <linux/unaligned/packed_struct.h>
 
 #include <asm/uaccess.h>
 
@@ -104,26 +105,30 @@ static inline __sum16 ip_fast_csum(const void *iph, unsigned int ihl)
 	const unsigned int *stop = word + ihl;
 	unsigned int csum;
 	int carry;
+	unsigned int w;
 
-	csum = word[0];
-	csum += word[1];
-	carry = (csum < word[1]);
+	csum = __get_unaligned_cpu32(word++);
+
+	w = __get_unaligned_cpu32(word++);
+	csum += w;
+	carry = (csum < w);
 	csum += carry;
 
-	csum += word[2];
-	carry = (csum < word[2]);
+	w = __get_unaligned_cpu32(word++);
+	csum += w;
+	carry = (csum < w);
 	csum += carry;
 
-	csum += word[3];
-	carry = (csum < word[3]);
+	w = __get_unaligned_cpu32(word++);
+	csum += w;
+	carry = (csum < w);
 	csum += carry;
 
-	word += 4;
 	do {
-		csum += *word;
-		carry = (csum < *word);
+		w = __get_unaligned_cpu32(word++);
+		csum += w;
+		carry = (csum < w);
 		csum += carry;
-		word++;
 	} while (word != stop);
 
 	return csum_fold(csum);
diff --git a/drivers/net/phy/mdio-bitbang.c b/drivers/net/phy/mdio-bitbang.c
index 6539189..467dd3c 100644
--- a/drivers/net/phy/mdio-bitbang.c
+++ b/drivers/net/phy/mdio-bitbang.c
@@ -165,16 +165,7 @@ static int mdiobb_read(struct mii_bus *bus, int phy, int reg)
 
 	ctrl->ops->set_mdio_dir(ctrl, 0);
 
-	/* check the turnaround bit: the PHY should be driving it to zero */
-	if (mdiobb_get_bit(ctrl) != 0) {
-		/* PHY didn't drive TA low -- flush any bits it
-		 * may be trying to send.
-		 */
-		for (i = 0; i < 32; i++)
-			mdiobb_get_bit(ctrl);
-
-		return 0xffff;
-	}
+	mdiobb_get_bit(ctrl);
 
 	ret = mdiobb_get_num(ctrl, 16);
 	mdiobb_get_bit(ctrl);
diff --git a/include/linux/ip.h b/include/linux/ip.h
index bd0a2a8..7a3f2d3 100644
--- a/include/linux/ip.h
+++ b/include/linux/ip.h
@@ -102,7 +102,7 @@ struct iphdr {
 	__be32	saddr;
 	__be32	daddr;
 	/*The options start here. */
-};
+} __packed;
 
 #ifdef __KERNEL__
 #include <linux/skbuff.h>
diff --git a/include/linux/ipv6.h b/include/linux/ipv6.h
index 0c99776..3d4407e 100644
--- a/include/linux/ipv6.h
+++ b/include/linux/ipv6.h
@@ -126,7 +126,7 @@ struct ipv6hdr {
 
 	struct	in6_addr	saddr;
 	struct	in6_addr	daddr;
-};
+} __packed;
 
 #ifdef __KERNEL__
 /*
diff --git a/include/linux/tcp.h b/include/linux/tcp.h
index 7f59ee9..c4a84e7 100644
--- a/include/linux/tcp.h
+++ b/include/linux/tcp.h
@@ -54,7 +54,7 @@ struct tcphdr {
 	__be16	window;
 	__sum16	check;
 	__be16	urg_ptr;
-};
+} __packed;
 
 /*
  *	The union cast uses a gcc extension to avoid aliasing problems
diff --git a/include/linux/udp.h b/include/linux/udp.h
index 03f72a2..ea34ce7 100644
--- a/include/linux/udp.h
+++ b/include/linux/udp.h
@@ -24,7 +24,7 @@ struct udphdr {
 	__be16	dest;
 	__be16	len;
 	__sum16	check;
-};
+} __packed;
 
 /* UDP socket options */
 #define UDP_CORK	1	/* Never send partially complete segments */
diff --git a/net/ipv4/netfilter/nf_conntrack_l3proto_ipv4.c b/net/ipv4/netfilter/nf_conntrack_l3proto_ipv4.c
index de9da21..2704407 100644
--- a/net/ipv4/netfilter/nf_conntrack_l3proto_ipv4.c
+++ b/net/ipv4/netfilter/nf_conntrack_l3proto_ipv4.c
@@ -14,6 +14,7 @@
 #include <linux/skbuff.h>
 #include <linux/icmp.h>
 #include <linux/sysctl.h>
+#include <linux/unaligned/packed_struct.h>
 #include <net/route.h>
 #include <net/ip.h>
 
@@ -44,8 +45,8 @@ static bool ipv4_pkt_to_tuple(const struct sk_buff *skb, unsigned int nhoff,
 	if (ap == NULL)
 		return false;
 
-	tuple->src.u3.ip = ap[0];
-	tuple->dst.u3.ip = ap[1];
+	tuple->src.u3.ip = __get_unaligned_cpu32(ap++);
+	tuple->dst.u3.ip = __get_unaligned_cpu32(ap);
 
 	return true;
 }
