From ce54c46e86eae6810b0fb51a73de25b408a5ecdf Mon Sep 17 00:00:00 2001
From: Zumeng Chen <zumeng.chen@windriver.com>
Date: Wed, 29 Sep 2010 10:20:27 +0800
Subject: [PATCH 09/41] Add spi support for ar71xx

Which is downloaded from the following:
  https://dev.openwrt.org/browser/branches
  branches_backfire_target_linux_ar71xx_files-r23140.zip

Integrated-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 drivers/spi/Kconfig       |   28 ++
 drivers/spi/Makefile      |    4 +
 drivers/spi/ap83_spi.c    |  282 ++++++++++++++++++++
 drivers/spi/ar71xx_spi.c  |  283 +++++++++++++++++++++
 drivers/spi/pb44_spi.c    |  299 ++++++++++++++++++++++
 drivers/spi/spi_vsc7385.c |  620 +++++++++++++++++++++++++++++++++++++++++++++
 6 files changed, 1516 insertions(+), 0 deletions(-)
 create mode 100644 drivers/spi/ap83_spi.c
 create mode 100644 drivers/spi/ar71xx_spi.c
 create mode 100644 drivers/spi/pb44_spi.c
 create mode 100644 drivers/spi/spi_vsc7385.c

diff --git a/drivers/spi/Kconfig b/drivers/spi/Kconfig
index de35c3a..a9ca750 100644
--- a/drivers/spi/Kconfig
+++ b/drivers/spi/Kconfig
@@ -67,6 +67,29 @@ config SPI_ATH79
 	  This enables support for the SPI controller present on the
 	  Atheros AR71XX/AR724X/AR913X SoCs.
 
+config SPI_AP83
+	tristate "Atheros AP83 specific SPI Controller"
+	depends on SPI_MASTER && AR71XX_MACH_AP83
+	select SPI_BITBANG
+	help
+	  This is a specific SPI controller driver for the Atheros AP83
+	  reference board.
+
+config SPI_AR71XX
+	tristate "Atheros AR71xx SPI Controller"
+	depends on SPI_MASTER && ATHEROS_AR71XX
+	select SPI_BITBANG
+	help
+	  This is the SPI contoller driver for Atheros AR71xx.
+
+config SPI_PB44
+	tristate "Atheros PB44 board specific SPI controller"
+	depends on SPI_MASTER && AR71XX_MACH_PB44
+	select SPI_BITBANG
+	help
+	  This is a specific SPI controller driver for the Atheros PB44
+	  reference board.
+
 config SPI_ATMEL
 	tristate "Atmel SPI Controller"
 	depends on (ARCH_AT91 || AVR32)
@@ -466,6 +489,11 @@ config SPI_TLE62X0
 	  sysfs interface, with each line presented as a kind of GPIO
 	  exposing both switch control and diagnostic feedback.
 
+config SPI_VSC7385
+	tristate "Vitesse VSC7385 ethernet switch driver"
+	help
+	  SPI driver for the Vitesse VSC7385 ethernet switch.
+
 #
 # Add new SPI protocol masters in alphabetical order above this line
 #
diff --git a/drivers/spi/Makefile b/drivers/spi/Makefile
index 0f8c69b..998d844 100644
--- a/drivers/spi/Makefile
+++ b/drivers/spi/Makefile
@@ -10,6 +10,8 @@ obj-$(CONFIG_SPI_MASTER)		+= spi.o
 
 # SPI master controller drivers (bus)
 obj-$(CONFIG_SPI_ALTERA)		+= spi_altera.o
+obj-$(CONFIG_SPI_AP83)			+= ap83_spi.o
+obj-$(CONFIG_SPI_AR71XX)		+= ar71xx_spi.o
 obj-$(CONFIG_SPI_ATMEL)			+= atmel_spi.o
 obj-$(CONFIG_SPI_ATH79)			+= ath79_spi.o
 obj-$(CONFIG_SPI_BFIN)			+= spi_bfin5xx.o
@@ -27,6 +29,7 @@ obj-$(CONFIG_SPI_EP93XX)		+= ep93xx_spi.o
 obj-$(CONFIG_SPI_GPIO)			+= spi_gpio.o
 obj-$(CONFIG_SPI_IMX)			+= spi_imx.o
 obj-$(CONFIG_SPI_LM70_LLP)		+= spi_lm70llp.o
+obj-$(CONFIG_SPI_PB44)			+= pb44_spi.o
 obj-$(CONFIG_SPI_PXA2XX)		+= pxa2xx_spi.o
 obj-$(CONFIG_SPI_PXA2XX_PCI)		+= pxa2xx_spi_pci.o
 obj-$(CONFIG_SPI_OC_TINY)		+= spi_oc_tiny.o
@@ -64,6 +67,7 @@ spi_s3c24xx_hw-$(CONFIG_SPI_S3C24XX_FIQ) += spi_s3c24xx_fiq.o
 
 # SPI protocol drivers (device/link on bus)
 obj-$(CONFIG_SPI_SPIDEV)	+= spidev.o
+obj-$(CONFIG_SPI_VSC7385)	+= spi_vsc7385.o
 obj-$(CONFIG_SPI_TLE62X0)	+= tle62x0.o
 # 	... add above this line ...
 
diff --git a/drivers/spi/ap83_spi.c b/drivers/spi/ap83_spi.c
new file mode 100644
index 0000000..c93070d
--- /dev/null
+++ b/drivers/spi/ap83_spi.c
@@ -0,0 +1,282 @@
+/*
+ * Atheros AP83 board specific SPI Controller driver
+ *
+ * Copyright (C) 2009 Gabor Juhos <juhosg@openwrt.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/spinlock.h>
+#include <linux/workqueue.h>
+#include <linux/platform_device.h>
+#include <linux/io.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/spi_bitbang.h>
+#include <linux/bitops.h>
+#include <linux/gpio.h>
+
+#include <asm/mach-ar71xx/ar71xx.h>
+#include <asm/mach-ar71xx/platform.h>
+
+#define DRV_DESC	"Atheros AP83 board SPI Controller driver"
+#define DRV_VERSION	"0.1.0"
+#define DRV_NAME	"ap83-spi"
+
+#define AP83_SPI_CLK_HIGH	(1 << 23)
+#define AP83_SPI_CLK_LOW	0
+#define AP83_SPI_MOSI_HIGH	(1 << 22)
+#define AP83_SPI_MOSI_LOW	0
+
+#define AP83_SPI_GPIO_CS	1
+#define AP83_SPI_GPIO_MISO	3
+
+struct ap83_spi {
+	struct	spi_bitbang 	bitbang;
+	void __iomem 		*base;
+	u32			addr;
+
+	struct platform_device	*pdev;
+};
+
+static inline u32 ap83_spi_rr(struct ap83_spi *sp, u32 reg)
+{
+	return __raw_readl(sp->base + reg);
+}
+
+static inline struct ap83_spi *spidev_to_sp(struct spi_device *spi)
+{
+	return spi_master_get_devdata(spi->master);
+}
+
+static inline void setsck(struct spi_device *spi, int val)
+{
+	struct ap83_spi *sp = spidev_to_sp(spi);
+
+	if (val)
+		sp->addr |= AP83_SPI_CLK_HIGH;
+	else
+		sp->addr &= ~AP83_SPI_CLK_HIGH;
+
+	dev_dbg(&spi->dev, "addr=%08x,  SCK set to %s\n",
+		sp->addr, (val) ? "HIGH" : "LOW");
+
+	ap83_spi_rr(sp, sp->addr);
+}
+
+static inline void setmosi(struct spi_device *spi, int val)
+{
+	struct ap83_spi *sp = spidev_to_sp(spi);
+
+	if (val)
+		sp->addr |= AP83_SPI_MOSI_HIGH;
+	else
+		sp->addr &= ~AP83_SPI_MOSI_HIGH;
+
+	dev_dbg(&spi->dev, "addr=%08x, MOSI set to %s\n",
+		sp->addr, (val) ? "HIGH" : "LOW");
+
+	ap83_spi_rr(sp, sp->addr);
+}
+
+static inline u32 getmiso(struct spi_device *spi)
+{
+	u32 ret;
+
+	ret = gpio_get_value(AP83_SPI_GPIO_MISO) ? 1 : 0;
+	dev_dbg(&spi->dev, "get MISO: %d\n", ret);
+
+	return ret;
+}
+
+static inline void do_spidelay(struct spi_device *spi, unsigned nsecs)
+{
+	ndelay(nsecs);
+}
+
+static void ap83_spi_chipselect(struct spi_device *spi, int on)
+{
+	struct ap83_spi *sp = spidev_to_sp(spi);
+
+	dev_dbg(&spi->dev, "set CS to %d\n", (on) ? 0 : 1);
+
+	if (on) {
+		ar71xx_flash_acquire();
+
+		sp->addr = 0;
+		ap83_spi_rr(sp, sp->addr);
+
+		gpio_set_value(AP83_SPI_GPIO_CS, 0);
+	} else {
+		gpio_set_value(AP83_SPI_GPIO_CS, 1);
+		ar71xx_flash_release();
+	}
+}
+
+#define spidelay(nsecs)							\
+	do {								\
+		/* Steal the spi_device pointer from our caller.	\
+		 * The bitbang-API should probably get fixed here... */	\
+		do_spidelay(spi, nsecs);				\
+	} while (0)
+
+#define EXPAND_BITBANG_TXRX
+#include <linux/spi/spi_bitbang.h>
+
+static u32 ap83_spi_txrx_mode0(struct spi_device *spi,
+			       unsigned nsecs, u32 word, u8 bits)
+{
+	dev_dbg(&spi->dev, "TXRX0 word=%08x, bits=%u\n", word, bits);
+	return bitbang_txrx_be_cpha0(spi, nsecs, 0, word, bits);
+}
+
+static u32 ap83_spi_txrx_mode1(struct spi_device *spi,
+			       unsigned nsecs, u32 word, u8 bits)
+{
+	dev_dbg(&spi->dev, "TXRX1 word=%08x, bits=%u\n", word, bits);
+	return bitbang_txrx_be_cpha1(spi, nsecs, 0, word, bits);
+}
+
+static u32 ap83_spi_txrx_mode2(struct spi_device *spi,
+			       unsigned nsecs, u32 word, u8 bits)
+{
+	dev_dbg(&spi->dev, "TXRX2 word=%08x, bits=%u\n", word, bits);
+	return bitbang_txrx_be_cpha0(spi, nsecs, 1, word, bits);
+}
+
+static u32 ap83_spi_txrx_mode3(struct spi_device *spi,
+			       unsigned nsecs, u32 word, u8 bits)
+{
+	dev_dbg(&spi->dev, "TXRX3 word=%08x, bits=%u\n", word, bits);
+	return bitbang_txrx_be_cpha1(spi, nsecs, 1, word, bits);
+}
+
+static int ap83_spi_probe(struct platform_device *pdev)
+{
+	struct spi_master *master;
+	struct ap83_spi *sp;
+	struct ap83_spi_platform_data *pdata;
+	struct resource	*r;
+	int ret;
+
+	ret = gpio_request(AP83_SPI_GPIO_MISO, "spi-miso");
+	if (ret) {
+		dev_err(&pdev->dev, "gpio request failed for MISO\n");
+		return ret;
+	}
+
+	ret = gpio_request(AP83_SPI_GPIO_CS, "spi-cs");
+	if (ret) {
+		dev_err(&pdev->dev, "gpio request failed for CS\n");
+		goto err_free_miso;
+	}
+
+	ret = gpio_direction_input(AP83_SPI_GPIO_MISO);
+	if (ret) {
+		dev_err(&pdev->dev, "unable to set direction of MISO\n");
+		goto err_free_cs;
+	}
+
+	ret = gpio_direction_output(AP83_SPI_GPIO_CS, 0);
+	if (ret) {
+		dev_err(&pdev->dev, "unable to set direction of CS\n");
+		goto err_free_cs;
+	}
+
+	master = spi_alloc_master(&pdev->dev, sizeof(*sp));
+	if (master == NULL) {
+		dev_err(&pdev->dev, "failed to allocate spi master\n");
+		return -ENOMEM;
+	}
+
+	sp = spi_master_get_devdata(master);
+	platform_set_drvdata(pdev, sp);
+
+	pdata = pdev->dev.platform_data;
+
+	sp->bitbang.master = spi_master_get(master);
+	sp->bitbang.chipselect = ap83_spi_chipselect;
+	sp->bitbang.txrx_word[SPI_MODE_0] = ap83_spi_txrx_mode0;
+	sp->bitbang.txrx_word[SPI_MODE_1] = ap83_spi_txrx_mode1;
+	sp->bitbang.txrx_word[SPI_MODE_2] = ap83_spi_txrx_mode2;
+	sp->bitbang.txrx_word[SPI_MODE_3] = ap83_spi_txrx_mode3;
+
+	sp->bitbang.master->bus_num = pdev->id;
+	sp->bitbang.master->num_chipselect = 1;
+
+	r = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (r == NULL) {
+		ret = -ENOENT;
+		goto err_spi_put;
+	}
+
+	sp->base = ioremap_nocache(r->start, r->end - r->start + 1);
+	if (!sp->base) {
+		ret = -ENXIO;
+		goto err_spi_put;
+	}
+
+	ret = spi_bitbang_start(&sp->bitbang);
+	if (!ret)
+		goto err_unmap;
+
+	dev_info(&pdev->dev, "AP83 SPI adapter at %08x\n", r->start);
+
+	return 0;
+
+ err_unmap:
+	iounmap(sp->base);
+ err_spi_put:
+	platform_set_drvdata(pdev, NULL);
+	spi_master_put(sp->bitbang.master);
+
+ err_free_cs:
+	gpio_free(AP83_SPI_GPIO_CS);
+ err_free_miso:
+	gpio_free(AP83_SPI_GPIO_MISO);
+	return ret;
+}
+
+static int ap83_spi_remove(struct platform_device *pdev)
+{
+	struct ap83_spi *sp = platform_get_drvdata(pdev);
+
+	spi_bitbang_stop(&sp->bitbang);
+	iounmap(sp->base);
+	platform_set_drvdata(pdev, NULL);
+	spi_master_put(sp->bitbang.master);
+
+	return 0;
+}
+
+static struct platform_driver ap83_spi_drv = {
+	.probe		= ap83_spi_probe,
+	.remove		= ap83_spi_remove,
+	.driver		= {
+		.name	= DRV_NAME,
+		.owner	= THIS_MODULE,
+	},
+};
+
+static int __init ap83_spi_init(void)
+{
+	return platform_driver_register(&ap83_spi_drv);
+}
+module_init(ap83_spi_init);
+
+static void __exit ap83_spi_exit(void)
+{
+	platform_driver_unregister(&ap83_spi_drv);
+}
+module_exit(ap83_spi_exit);
+
+MODULE_ALIAS("platform:" DRV_NAME);
+MODULE_DESCRIPTION(DRV_DESC);
+MODULE_VERSION(DRV_VERSION);
+MODULE_AUTHOR("Gabor Juhos <juhosg@openwrt.org>");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/spi/ar71xx_spi.c b/drivers/spi/ar71xx_spi.c
new file mode 100644
index 0000000..ac60170
--- /dev/null
+++ b/drivers/spi/ar71xx_spi.c
@@ -0,0 +1,283 @@
+/*
+ * Atheros AR71xx SPI Controller driver
+ *
+ * Copyright (C) 2008-2009 Gabor Juhos <juhosg@openwrt.org>
+ * Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/spinlock.h>
+#include <linux/workqueue.h>
+#include <linux/platform_device.h>
+#include <linux/io.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/spi_bitbang.h>
+#include <linux/bitops.h>
+
+#include <asm/mach-ar71xx/ar71xx.h>
+#include <asm/mach-ar71xx/platform.h>
+
+#define DRV_DESC	"Atheros AR71xx SPI Controller driver"
+#define DRV_VERSION	"0.2.4"
+#define DRV_NAME	"ar71xx-spi"
+
+#undef PER_BIT_READ
+
+struct ar71xx_spi {
+	struct	spi_bitbang 	bitbang;
+	u32			ioc_base;
+	u32			reg_ctrl;
+
+	void __iomem 		*base;
+
+	struct platform_device	*pdev;
+	u32			(*get_ioc_base)(u8 chip_select, int cs_high,
+						int is_on);
+};
+
+static inline u32 ar71xx_spi_rr(struct ar71xx_spi *sp, unsigned reg)
+{
+	return __raw_readl(sp->base + reg);
+}
+
+static inline void ar71xx_spi_wr(struct ar71xx_spi *sp, unsigned reg, u32 val)
+{
+	__raw_writel(val, sp->base + reg);
+}
+
+static inline struct ar71xx_spi *spidev_to_sp(struct spi_device *spi)
+{
+	return spi_master_get_devdata(spi->master);
+}
+
+static u32 ar71xx_spi_get_ioc_base(u8 chip_select, int cs_high, int is_on)
+{
+	u32 ret;
+
+	if (is_on == AR71XX_SPI_CS_INACTIVE)
+		ret = SPI_IOC_CS_ALL;
+	else
+		ret = SPI_IOC_CS_ALL & ~SPI_IOC_CS(chip_select);
+
+	return ret;
+}
+
+static void ar71xx_spi_chipselect(struct spi_device *spi, int value)
+{
+	struct ar71xx_spi *sp = spidev_to_sp(spi);
+	void __iomem *base = sp->base;
+	u32 ioc_base;
+
+	switch (value) {
+	case BITBANG_CS_INACTIVE:
+		ioc_base = sp->get_ioc_base(spi->chip_select,
+					(spi->mode & SPI_CS_HIGH) != 0,
+					AR71XX_SPI_CS_INACTIVE);
+		__raw_writel(ioc_base, base + SPI_REG_IOC);
+		break;
+
+	case BITBANG_CS_ACTIVE:
+		ioc_base = sp->get_ioc_base(spi->chip_select,
+					(spi->mode & SPI_CS_HIGH) != 0,
+					AR71XX_SPI_CS_ACTIVE);
+
+		__raw_writel(ioc_base, base + SPI_REG_IOC);
+		sp->ioc_base = ioc_base;
+		break;
+	}
+}
+
+static void ar71xx_spi_setup_regs(struct spi_device *spi)
+{
+	struct ar71xx_spi *sp = spidev_to_sp(spi);
+
+	/* enable GPIO mode */
+	ar71xx_spi_wr(sp, SPI_REG_FS, SPI_FS_GPIO);
+
+	/* save CTRL register */
+	sp->reg_ctrl = ar71xx_spi_rr(sp, SPI_REG_CTRL);
+
+	/* TODO: setup speed? */
+	ar71xx_spi_wr(sp, SPI_REG_CTRL, 0x43);
+}
+
+static void ar71xx_spi_restore_regs(struct spi_device *spi)
+{
+	struct ar71xx_spi *sp = spidev_to_sp(spi);
+
+	/* restore CTRL register */
+	ar71xx_spi_wr(sp, SPI_REG_CTRL, sp->reg_ctrl);
+	/* disable GPIO mode */
+	ar71xx_spi_wr(sp, SPI_REG_FS, 0);
+}
+
+static int ar71xx_spi_setup(struct spi_device *spi)
+{
+	int status;
+
+	if (spi->bits_per_word > 32)
+		return -EINVAL;
+
+	if (!spi->controller_state)
+		ar71xx_spi_setup_regs(spi);
+
+	status = spi_bitbang_setup(spi);
+	if (status && !spi->controller_state)
+		ar71xx_spi_restore_regs(spi);
+
+	return status;
+}
+
+static void ar71xx_spi_cleanup(struct spi_device *spi)
+{
+	ar71xx_spi_restore_regs(spi);
+	spi_bitbang_cleanup(spi);
+}
+
+static u32 ar71xx_spi_txrx_mode0(struct spi_device *spi, unsigned nsecs,
+					u32 word, u8 bits)
+{
+	struct ar71xx_spi *sp = spidev_to_sp(spi);
+	void __iomem *base = sp->base;
+	u32 ioc = sp->ioc_base;
+	u32 ret;
+
+	/* clock starts at inactive polarity */
+	for (word <<= (32 - bits); likely(bits); bits--) {
+		u32 out;
+
+		if (word & (1 << 31))
+			out = ioc | SPI_IOC_DO;
+		else
+			out = ioc & ~SPI_IOC_DO;
+
+		/* setup MSB (to slave) on trailing edge */
+		__raw_writel(out, base + SPI_REG_IOC);
+
+		__raw_writel(out | SPI_IOC_CLK, base + SPI_REG_IOC);
+
+		word <<= 1;
+
+#ifdef PER_BIT_READ
+		/* sample MSB (from slave) on leading edge */
+		ret = __raw_readl(base + SPI_REG_RDS);
+		__raw_writel(out, base + SPI_REG_IOC);
+#endif
+
+	}
+
+#ifndef PER_BIT_READ
+	ret = __raw_readl(base + SPI_REG_RDS);
+#endif
+	return ret;
+}
+
+static int ar71xx_spi_probe(struct platform_device *pdev)
+{
+	struct spi_master *master;
+	struct ar71xx_spi *sp;
+	struct ar71xx_spi_platform_data *pdata;
+	struct resource	*r;
+	int ret;
+
+	master = spi_alloc_master(&pdev->dev, sizeof(*sp));
+	if (master == NULL) {
+		dev_err(&pdev->dev, "failed to allocate spi master\n");
+		return -ENOMEM;
+	}
+
+	sp = spi_master_get_devdata(master);
+	platform_set_drvdata(pdev, sp);
+
+	pdata = pdev->dev.platform_data;
+
+	master->setup = ar71xx_spi_setup;
+	master->cleanup = ar71xx_spi_cleanup;
+
+	sp->bitbang.master = spi_master_get(master);
+	sp->bitbang.chipselect = ar71xx_spi_chipselect;
+	sp->bitbang.txrx_word[SPI_MODE_0] = ar71xx_spi_txrx_mode0;
+	sp->bitbang.setup_transfer = spi_bitbang_setup_transfer;
+
+	sp->get_ioc_base = ar71xx_spi_get_ioc_base;
+	if (pdata) {
+		sp->bitbang.master->bus_num = pdata->bus_num;
+		sp->bitbang.master->num_chipselect = pdata->num_chipselect;
+		if (pdata->get_ioc_base)
+			sp->get_ioc_base = pdata->get_ioc_base;
+	} else {
+		sp->bitbang.master->bus_num = 0;
+		sp->bitbang.master->num_chipselect = 3;
+	}
+
+	r = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (r == NULL) {
+		ret = -ENOENT;
+		goto err1;
+	}
+
+	sp->base = ioremap_nocache(r->start, r->end - r->start + 1);
+	if (!sp->base) {
+		ret = -ENXIO;
+		goto err1;
+	}
+
+	ret = spi_bitbang_start(&sp->bitbang);
+	if (!ret)
+		return 0;
+
+	iounmap(sp->base);
+ err1:
+	platform_set_drvdata(pdev, NULL);
+	spi_master_put(sp->bitbang.master);
+
+	return ret;
+}
+
+static int ar71xx_spi_remove(struct platform_device *pdev)
+{
+	struct ar71xx_spi *sp = platform_get_drvdata(pdev);
+
+	spi_bitbang_stop(&sp->bitbang);
+	iounmap(sp->base);
+	platform_set_drvdata(pdev, NULL);
+	spi_master_put(sp->bitbang.master);
+
+	return 0;
+}
+
+static struct platform_driver ar71xx_spi_drv = {
+	.probe		= ar71xx_spi_probe,
+	.remove		= ar71xx_spi_remove,
+	.driver		= {
+		.name	= DRV_NAME,
+		.owner	= THIS_MODULE,
+	},
+};
+
+static int __init ar71xx_spi_init(void)
+{
+	printk(KERN_INFO DRV_DESC " version " DRV_VERSION "\n");
+	return platform_driver_register(&ar71xx_spi_drv);
+}
+module_init(ar71xx_spi_init);
+
+static void __exit ar71xx_spi_exit(void)
+{
+	platform_driver_unregister(&ar71xx_spi_drv);
+}
+module_exit(ar71xx_spi_exit);
+
+MODULE_ALIAS("platform:" DRV_NAME);
+MODULE_DESCRIPTION(DRV_DESC);
+MODULE_VERSION(DRV_VERSION);
+MODULE_AUTHOR("Gabor Juhos <juhosg@openwrt.org>");
+MODULE_AUTHOR("Imre Kaloz <kaloz@openwrt.org>");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/spi/pb44_spi.c b/drivers/spi/pb44_spi.c
new file mode 100644
index 0000000..32e6ea6
--- /dev/null
+++ b/drivers/spi/pb44_spi.c
@@ -0,0 +1,299 @@
+/*
+ * Atheros PB44 board SPI controller driver
+ *
+ * Copyright (C) 2009 Gabor Juhos <juhosg@openwrt.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/spinlock.h>
+#include <linux/workqueue.h>
+#include <linux/platform_device.h>
+#include <linux/io.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/spi_bitbang.h>
+#include <linux/bitops.h>
+#include <linux/gpio.h>
+
+#include <asm/mach-ar71xx/ar71xx.h>
+#include <asm/mach-ar71xx/platform.h>
+
+#define DRV_DESC	"Atheros PB44 SPI Controller driver"
+#define DRV_VERSION	"0.1.0"
+#define DRV_NAME	"pb44-spi"
+
+#undef PER_BIT_READ
+
+struct ar71xx_spi {
+	struct	spi_bitbang 	bitbang;
+	u32			ioc_base;
+	u32			reg_ctrl;
+
+	void __iomem 		*base;
+
+	struct platform_device	*pdev;
+};
+
+static inline u32 pb44_spi_rr(struct ar71xx_spi *sp, unsigned reg)
+{
+	return __raw_readl(sp->base + reg);
+}
+
+static inline void pb44_spi_wr(struct ar71xx_spi *sp, unsigned reg, u32 val)
+{
+	__raw_writel(val, sp->base + reg);
+}
+
+static inline struct ar71xx_spi *spidev_to_sp(struct spi_device *spi)
+{
+	return spi_master_get_devdata(spi->master);
+}
+
+static void pb44_spi_chipselect(struct spi_device *spi, int is_active)
+{
+	struct ar71xx_spi *sp = spidev_to_sp(spi);
+	int cs_high = (spi->mode & SPI_CS_HIGH) ? is_active : !is_active;
+
+	if (is_active) {
+		/* set initial clock polarity */
+		if (spi->mode & SPI_CPOL)
+			sp->ioc_base |= SPI_IOC_CLK;
+		else
+			sp->ioc_base &= ~SPI_IOC_CLK;
+
+		pb44_spi_wr(sp, SPI_REG_IOC, sp->ioc_base);
+	}
+
+	if (spi->chip_select) {
+		unsigned long gpio = (unsigned long) spi->controller_data;
+
+		/* SPI is normally active-low */
+		gpio_set_value(gpio, cs_high);
+	} else {
+		if (cs_high)
+			sp->ioc_base |= SPI_IOC_CS0;
+		else
+			sp->ioc_base &= ~SPI_IOC_CS0;
+
+		pb44_spi_wr(sp, SPI_REG_IOC, sp->ioc_base);
+	}
+
+}
+
+static int pb44_spi_setup_cs(struct spi_device *spi)
+{
+	struct ar71xx_spi *sp = spidev_to_sp(spi);
+
+	/* enable GPIO mode */
+	pb44_spi_wr(sp, SPI_REG_FS, SPI_FS_GPIO);
+
+	/* save CTRL register */
+	sp->reg_ctrl = pb44_spi_rr(sp, SPI_REG_CTRL);
+	sp->ioc_base = pb44_spi_rr(sp, SPI_REG_IOC);
+
+	/* TODO: setup speed? */
+	pb44_spi_wr(sp, SPI_REG_CTRL, 0x43);
+
+	if (spi->chip_select) {
+		unsigned long gpio = (unsigned long) spi->controller_data;
+		int status = 0;
+
+		status = gpio_request(gpio, dev_name(&spi->dev));
+		if (status)
+			return status;
+
+		status = gpio_direction_output(gpio, spi->mode & SPI_CS_HIGH);
+		if (status) {
+			gpio_free(gpio);
+			return status;
+		}
+	} else {
+		if (spi->mode & SPI_CS_HIGH)
+			sp->ioc_base |= SPI_IOC_CS0;
+		else
+			sp->ioc_base &= ~SPI_IOC_CS0;
+		pb44_spi_wr(sp, SPI_REG_IOC, sp->ioc_base);
+	}
+
+	return 0;
+}
+
+static void pb44_spi_cleanup_cs(struct spi_device *spi)
+{
+	struct ar71xx_spi *sp = spidev_to_sp(spi);
+
+	if (spi->chip_select) {
+		unsigned long gpio = (unsigned long) spi->controller_data;
+		gpio_free(gpio);
+	}
+
+	/* restore CTRL register */
+	pb44_spi_wr(sp, SPI_REG_CTRL, sp->reg_ctrl);
+	/* disable GPIO mode */
+	pb44_spi_wr(sp, SPI_REG_FS, 0);
+}
+
+static int pb44_spi_setup(struct spi_device *spi)
+{
+	int status = 0;
+
+	if (spi->bits_per_word > 32)
+		return -EINVAL;
+
+	if (!spi->controller_state) {
+		status = pb44_spi_setup_cs(spi);
+		if (status)
+			return status;
+	}
+
+	status = spi_bitbang_setup(spi);
+	if (status && !spi->controller_state)
+		pb44_spi_cleanup_cs(spi);
+
+	return status;
+}
+
+static void pb44_spi_cleanup(struct spi_device *spi)
+{
+	pb44_spi_cleanup_cs(spi);
+	spi_bitbang_cleanup(spi);
+}
+
+static u32 pb44_spi_txrx_mode0(struct spi_device *spi, unsigned nsecs,
+			       u32 word, u8 bits)
+{
+	struct ar71xx_spi *sp = spidev_to_sp(spi);
+	u32 ioc = sp->ioc_base;
+	u32 ret;
+
+	/* clock starts at inactive polarity */
+	for (word <<= (32 - bits); likely(bits); bits--) {
+		u32 out;
+
+		if (word & (1 << 31))
+			out = ioc | SPI_IOC_DO;
+		else
+			out = ioc & ~SPI_IOC_DO;
+
+		/* setup MSB (to slave) on trailing edge */
+		pb44_spi_wr(sp, SPI_REG_IOC, out);
+		pb44_spi_wr(sp, SPI_REG_IOC, out | SPI_IOC_CLK);
+
+		word <<= 1;
+
+#ifdef PER_BIT_READ
+		/* sample MSB (from slave) on leading edge */
+		ret = pb44_spi_rr(sp, SPI_REG_RDS);
+		pb44_spi_wr(sp, SPI_REG_IOC, out);
+#endif
+	}
+
+#ifndef PER_BIT_READ
+	ret = pb44_spi_rr(sp, SPI_REG_RDS);
+#endif
+	return ret;
+}
+
+static int pb44_spi_probe(struct platform_device *pdev)
+{
+	struct spi_master *master;
+	struct ar71xx_spi *sp;
+	struct ar71xx_spi_platform_data *pdata;
+	struct resource	*r;
+	int ret;
+
+	master = spi_alloc_master(&pdev->dev, sizeof(*sp));
+	if (master == NULL) {
+		dev_err(&pdev->dev, "failed to allocate spi master\n");
+		return -ENOMEM;
+	}
+
+	sp = spi_master_get_devdata(master);
+	platform_set_drvdata(pdev, sp);
+
+	pdata = pdev->dev.platform_data;
+
+	master->setup = pb44_spi_setup;
+	master->cleanup = pb44_spi_cleanup;
+	if (pdata) {
+		master->bus_num = pdata->bus_num;
+		master->num_chipselect = pdata->num_chipselect;
+	} else {
+		master->bus_num = 0;
+		master->num_chipselect = 1;
+	}
+
+	sp->bitbang.master = spi_master_get(master);
+	sp->bitbang.chipselect = pb44_spi_chipselect;
+	sp->bitbang.txrx_word[SPI_MODE_0] = pb44_spi_txrx_mode0;
+	sp->bitbang.setup_transfer = spi_bitbang_setup_transfer;
+	sp->bitbang.flags = SPI_CS_HIGH;
+
+	r = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (r == NULL) {
+		ret = -ENOENT;
+		goto err1;
+	}
+
+	sp->base = ioremap_nocache(r->start, r->end - r->start + 1);
+	if (!sp->base) {
+		ret = -ENXIO;
+		goto err1;
+	}
+
+	ret = spi_bitbang_start(&sp->bitbang);
+	if (!ret)
+		return 0;
+
+	iounmap(sp->base);
+ err1:
+	platform_set_drvdata(pdev, NULL);
+	spi_master_put(sp->bitbang.master);
+
+	return ret;
+}
+
+static int pb44_spi_remove(struct platform_device *pdev)
+{
+	struct ar71xx_spi *sp = platform_get_drvdata(pdev);
+
+	spi_bitbang_stop(&sp->bitbang);
+	iounmap(sp->base);
+	platform_set_drvdata(pdev, NULL);
+	spi_master_put(sp->bitbang.master);
+
+	return 0;
+}
+
+static struct platform_driver pb44_spi_drv = {
+	.probe		= pb44_spi_probe,
+	.remove		= pb44_spi_remove,
+	.driver		= {
+		.name	= DRV_NAME,
+		.owner	= THIS_MODULE,
+	},
+};
+
+static int __init pb44_spi_init(void)
+{
+	return platform_driver_register(&pb44_spi_drv);
+}
+module_init(pb44_spi_init);
+
+static void __exit pb44_spi_exit(void)
+{
+	platform_driver_unregister(&pb44_spi_drv);
+}
+module_exit(pb44_spi_exit);
+
+MODULE_ALIAS("platform:" DRV_NAME);
+MODULE_DESCRIPTION(DRV_DESC);
+MODULE_VERSION(DRV_VERSION);
+MODULE_AUTHOR("Gabor Juhos <juhosg@openwrt.org>");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/spi/spi_vsc7385.c b/drivers/spi/spi_vsc7385.c
new file mode 100644
index 0000000..c16707e
--- /dev/null
+++ b/drivers/spi/spi_vsc7385.c
@@ -0,0 +1,620 @@
+/*
+ * SPI driver for the Vitesse VSC7385 ethernet switch
+ *
+ * Copyright (C) 2009 Gabor Juhos <juhosg@openwrt.org>
+ *
+ * Parts of this file are based on Atheros' 2.6.15 BSP
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation.
+ */
+
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/bitops.h>
+#include <linux/firmware.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/vsc7385.h>
+
+#define DRV_NAME	"spi-vsc7385"
+#define DRV_DESC	"Vitesse VSC7385 Gbit ethernet switch driver"
+#define DRV_VERSION	"0.1.0"
+
+#define VSC73XX_BLOCK_MAC	0x1
+#define VSC73XX_BLOCK_2		0x2
+#define VSC73XX_BLOCK_MII	0x3
+#define VSC73XX_BLOCK_4		0x4
+#define VSC73XX_BLOCK_5		0x5
+#define VSC73XX_BLOCK_SYSTEM	0x7
+
+#define VSC73XX_SUBBLOCK_PORT_0		0
+#define VSC73XX_SUBBLOCK_PORT_1		1
+#define VSC73XX_SUBBLOCK_PORT_2		2
+#define VSC73XX_SUBBLOCK_PORT_3		3
+#define VSC73XX_SUBBLOCK_PORT_4		4
+#define VSC73XX_SUBBLOCK_PORT_MAC	6
+
+/* MAC Block registers */
+#define VSC73XX_MAC_CFG		0x0
+#define VSC73XX_ADVPORTM	0x19
+#define VSC73XX_RXOCT		0x50
+#define VSC73XX_TXOCT		0x51
+#define VSC73XX_C_RX0		0x52
+#define VSC73XX_C_RX1		0x53
+#define VSC73XX_C_RX2		0x54
+#define VSC73XX_C_TX0		0x55
+#define VSC73XX_C_TX1		0x56
+#define VSC73XX_C_TX2		0x57
+#define VSC73XX_C_CFG		0x58
+
+/* MAC_CFG register bits */
+#define VSC73XX_MAC_CFG_WEXC_DIS	(1 << 31)
+#define VSC73XX_MAC_CFG_PORT_RST	(1 << 29)
+#define VSC73XX_MAC_CFG_TX_EN		(1 << 28)
+#define VSC73XX_MAC_CFG_SEED_LOAD      	(1 << 27)
+#define VSC73XX_MAC_CFG_FDX	        (1 << 18)
+#define VSC73XX_MAC_CFG_GIGE		(1 << 17)
+#define VSC73XX_MAC_CFG_RX_EN		(1 << 16)
+#define VSC73XX_MAC_CFG_VLAN_DBLAWR	(1 << 15)
+#define VSC73XX_MAC_CFG_VLAN_AWR	(1 << 14)
+#define VSC73XX_MAC_CFG_100_BASE_T	(1 << 13)
+#define VSC73XX_MAC_CFG_TX_IPG(x)	(((x) & 0x1f) << 6)
+#define VSC73XX_MAC_CFG_MAC_RX_RST	(1 << 5)
+#define VSC73XX_MAC_CFG_MAC_TX_RST	(1 << 4)
+#define VSC73XX_MAC_CFG_BIT2		(1 << 2)
+#define VSC73XX_MAC_CFG_CLK_SEL(x)	((x) & 0x3)
+
+/* ADVPORTM register bits */
+#define VSC73XX_ADVPORTM_IFG_PPM	(1 << 7)
+#define VSC73XX_ADVPORTM_EXC_COL_CONT	(1 << 6)
+#define VSC73XX_ADVPORTM_EXT_PORT	(1 << 5)
+#define VSC73XX_ADVPORTM_INV_GTX	(1 << 4)
+#define VSC73XX_ADVPORTM_ENA_GTX	(1 << 3)
+#define VSC73XX_ADVPORTM_DDR_MODE	(1 << 2)
+#define VSC73XX_ADVPORTM_IO_LOOPBACK	(1 << 1)
+#define VSC73XX_ADVPORTM_HOST_LOOPBACK	(1 << 0)
+
+/* MII Block registers */
+#define VSC73XX_MII_STAT	0x0
+#define VSC73XX_MII_CMD		0x1
+#define VSC73XX_MII_DATA	0x2
+
+/* System Block registers */
+#define VSC73XX_ICPU_SIPAD		0x01
+#define VSC73XX_ICPU_CLOCK_DELAY	0x05
+#define VSC73XX_ICPU_CTRL		0x10
+#define VSC73XX_ICPU_ADDR		0x11
+#define VSC73XX_ICPU_SRAM		0x12
+#define VSC73XX_ICPU_MBOX_VAL		0x15
+#define VSC73XX_ICPU_MBOX_SET		0x16
+#define VSC73XX_ICPU_MBOX_CLR		0x17
+#define VSC73XX_ICPU_CHIPID		0x18
+#define VSC73XX_ICPU_GPIO		0x34
+
+#define VSC73XX_ICPU_CTRL_CLK_DIV	(1 << 8)
+#define VSC73XX_ICPU_CTRL_SRST_HOLD	(1 << 7)
+#define VSC73XX_ICPU_CTRL_BOOT_EN	(1 << 3)
+#define VSC73XX_ICPU_CTRL_EXT_ACC_EN	(1 << 2)
+#define VSC73XX_ICPU_CTRL_CLK_EN	(1 << 1)
+#define VSC73XX_ICPU_CTRL_SRST		(1 << 0)
+
+#define VSC73XX_ICPU_CHIPID_ID_SHIFT	12
+#define VSC73XX_ICPU_CHIPID_ID_MASK	0xffff
+#define VSC73XX_ICPU_CHIPID_REV_SHIFT	28
+#define VSC73XX_ICPU_CHIPID_REV_MASK	0xf
+#define VSC73XX_ICPU_CHIPID_ID_7385	0x7385
+#define VSC73XX_ICPU_CHIPID_ID_7395	0x7395
+
+#define VSC73XX_CMD_MODE_READ		0
+#define VSC73XX_CMD_MODE_WRITE		1
+#define VSC73XX_CMD_MODE_SHIFT		4
+#define VSC73XX_CMD_BLOCK_SHIFT		5
+#define VSC73XX_CMD_BLOCK_MASK		0x7
+#define VSC73XX_CMD_SUBBLOCK_MASK	0xf
+
+#define VSC7385_CLOCK_DELAY		((3 << 4) | 3)
+#define VSC7385_CLOCK_DELAY_MASK	((3 << 4) | 3)
+
+#define VSC73XX_ICPU_CTRL_STOP	(VSC73XX_ICPU_CTRL_SRST_HOLD | \
+				 VSC73XX_ICPU_CTRL_BOOT_EN | \
+				 VSC73XX_ICPU_CTRL_EXT_ACC_EN)
+
+#define VSC73XX_ICPU_CTRL_START	(VSC73XX_ICPU_CTRL_CLK_DIV | \
+				 VSC73XX_ICPU_CTRL_BOOT_EN | \
+				 VSC73XX_ICPU_CTRL_CLK_EN | \
+				 VSC73XX_ICPU_CTRL_SRST)
+
+#define VSC7385_ADVPORTM_MASK	(VSC73XX_ADVPORTM_IFG_PPM | \
+				 VSC73XX_ADVPORTM_EXC_COL_CONT | \
+				 VSC73XX_ADVPORTM_EXT_PORT | \
+				 VSC73XX_ADVPORTM_INV_GTX | \
+				 VSC73XX_ADVPORTM_ENA_GTX | \
+				 VSC73XX_ADVPORTM_DDR_MODE | \
+				 VSC73XX_ADVPORTM_IO_LOOPBACK | \
+				 VSC73XX_ADVPORTM_HOST_LOOPBACK)
+
+#define VSC7385_ADVPORTM_INIT	(VSC73XX_ADVPORTM_EXT_PORT | \
+				 VSC73XX_ADVPORTM_ENA_GTX | \
+				 VSC73XX_ADVPORTM_DDR_MODE)
+
+#define VSC7385_MAC_CFG_RESET	(VSC73XX_MAC_CFG_PORT_RST | \
+				 VSC73XX_MAC_CFG_MAC_RX_RST | \
+				 VSC73XX_MAC_CFG_MAC_TX_RST)
+
+#define VSC73XX_MAC_CFG_INIT	(VSC73XX_MAC_CFG_TX_EN | \
+				 VSC73XX_MAC_CFG_FDX | \
+				 VSC73XX_MAC_CFG_GIGE | \
+				 VSC73XX_MAC_CFG_RX_EN)
+
+#define VSC73XX_RESET_DELAY	100
+
+struct vsc7385 {
+	struct spi_device		*spi;
+	struct mutex			lock;
+	struct vsc7385_platform_data	*pdata;
+};
+
+static int vsc7385_is_addr_valid(u8 block, u8 subblock)
+{
+	switch (block) {
+	case VSC73XX_BLOCK_MAC:
+		switch (subblock) {
+		case 0 ... 4:
+		case 6:
+			return 1;
+		}
+		break;
+
+	case VSC73XX_BLOCK_2:
+	case VSC73XX_BLOCK_SYSTEM:
+		switch (subblock) {
+		case 0:
+			return 1;
+		}
+		break;
+
+	case VSC73XX_BLOCK_MII:
+	case VSC73XX_BLOCK_4:
+	case VSC73XX_BLOCK_5:
+		switch (subblock) {
+		case 0 ... 1:
+			return 1;
+		}
+		break;
+	}
+
+	return 0;
+}
+
+static inline u8 vsc7385_make_addr(u8 mode, u8 block, u8 subblock)
+{
+	u8 ret;
+
+	ret = (block & VSC73XX_CMD_BLOCK_MASK) << VSC73XX_CMD_BLOCK_SHIFT;
+	ret |= (mode & 1) << VSC73XX_CMD_MODE_SHIFT;
+	ret |= subblock & VSC73XX_CMD_SUBBLOCK_MASK;
+
+	return ret;
+}
+
+static int vsc7385_read(struct vsc7385 *vsc, u8 block, u8 subblock, u8 reg,
+			u32 *value)
+{
+	u8 cmd[4];
+	u8 buf[4];
+	struct spi_transfer t[2];
+	struct spi_message m;
+	int err;
+
+	if (!vsc7385_is_addr_valid(block, subblock))
+		return -EINVAL;
+
+	spi_message_init(&m);
+
+	memset(&t, 0, sizeof(t));
+
+	t[0].tx_buf = cmd;
+	t[0].len = sizeof(cmd);
+	spi_message_add_tail(&t[0], &m);
+
+	t[1].rx_buf = buf;
+	t[1].len = sizeof(buf);
+	spi_message_add_tail(&t[1], &m);
+
+	cmd[0] = vsc7385_make_addr(VSC73XX_CMD_MODE_READ, block, subblock);
+	cmd[1] = reg;
+	cmd[2] = 0;
+	cmd[3] = 0;
+
+	mutex_lock(&vsc->lock);
+	err = spi_sync(vsc->spi, &m);
+	mutex_unlock(&vsc->lock);
+
+	if (err)
+		return err;
+
+	*value = (((u32) buf[0]) << 24) | (((u32) buf[1]) << 16) |
+		 (((u32) buf[2]) << 8) | ((u32) buf[3]);
+
+	return 0;
+}
+
+
+static int vsc7385_write(struct vsc7385 *vsc, u8 block, u8 subblock, u8 reg,
+			 u32 value)
+{
+	u8 cmd[2];
+	u8 buf[4];
+	struct spi_transfer t[2];
+	struct spi_message m;
+	int err;
+
+	if (!vsc7385_is_addr_valid(block, subblock))
+		return -EINVAL;
+
+	spi_message_init(&m);
+
+	memset(&t, 0, sizeof(t));
+
+	t[0].tx_buf = cmd;
+	t[0].len = sizeof(cmd);
+	spi_message_add_tail(&t[0], &m);
+
+	t[1].tx_buf = buf;
+	t[1].len = sizeof(buf);
+	spi_message_add_tail(&t[1], &m);
+
+	cmd[0] = vsc7385_make_addr(VSC73XX_CMD_MODE_WRITE, block, subblock);
+	cmd[1] = reg;
+
+	buf[0] = (value >> 24) & 0xff;
+	buf[1] = (value >> 16) & 0xff;
+	buf[2] = (value >> 8) & 0xff;
+	buf[3] = value & 0xff;
+
+	mutex_lock(&vsc->lock);
+	err = spi_sync(vsc->spi, &m);
+	mutex_unlock(&vsc->lock);
+
+	return err;
+}
+
+static inline int vsc7385_write_verify(struct vsc7385 *vsc, u8 block,
+				       u8 subblock, u8 reg, u32 value,
+				       u32 read_mask, u32 read_val)
+{
+	struct spi_device *spi = vsc->spi;
+	u32 t;
+	int err;
+
+	err = vsc7385_write(vsc, block, subblock, reg, value);
+	if (err)
+		return err;
+
+	err = vsc7385_read(vsc, block, subblock, reg, &t);
+	if (err)
+		return err;
+
+	if ((t & read_mask) != read_val) {
+		dev_err(&spi->dev, "register write error\n");
+		return -EIO;
+	}
+
+	return 0;
+}
+
+static inline int vsc7385_set_clock_delay(struct vsc7385 *vsc, u32 val)
+{
+	return vsc7385_write(vsc, VSC73XX_BLOCK_SYSTEM, 0,
+			     VSC73XX_ICPU_CLOCK_DELAY, val);
+}
+
+static inline int vsc7385_get_clock_delay(struct vsc7385 *vsc, u32 *val)
+{
+	return vsc7385_read(vsc, VSC73XX_BLOCK_SYSTEM, 0,
+			    VSC73XX_ICPU_CLOCK_DELAY, val);
+}
+
+static inline int vsc7385_icpu_stop(struct vsc7385 *vsc)
+{
+	return vsc7385_write(vsc, VSC73XX_BLOCK_SYSTEM, 0, VSC73XX_ICPU_CTRL,
+			     VSC73XX_ICPU_CTRL_STOP);
+}
+
+static inline int vsc7385_icpu_start(struct vsc7385 *vsc)
+{
+	return vsc7385_write(vsc, VSC73XX_BLOCK_SYSTEM, 0, VSC73XX_ICPU_CTRL,
+			     VSC73XX_ICPU_CTRL_START);
+}
+
+static inline int vsc7385_icpu_reset(struct vsc7385 *vsc)
+{
+	int rc;
+
+	rc = vsc7385_write(vsc, VSC73XX_BLOCK_SYSTEM, 0, VSC73XX_ICPU_ADDR,
+			   0x0000);
+	if (rc)
+		dev_err(&vsc->spi->dev,
+			"could not reset microcode, err=%d\n", rc);
+
+	return rc;
+}
+
+static int vsc7385_upload_ucode(struct vsc7385 *vsc)
+{
+	struct spi_device *spi = vsc->spi;
+	const struct firmware *firmware;
+	char *ucode_name;
+	unsigned char *dp;
+	unsigned int curVal;
+	int i;
+	int diffs;
+	int rc;
+
+	ucode_name = (vsc->pdata->ucode_name) ? vsc->pdata->ucode_name
+					      : "vsc7385_ucode.bin";
+	rc = request_firmware(&firmware, ucode_name, &spi->dev);
+	if (rc) {
+		dev_err(&spi->dev, "request_firmware failed, err=%d\n",
+			rc);
+		return rc;
+	}
+
+	rc = vsc7385_icpu_stop(vsc);
+	if (rc)
+		goto out;
+
+	rc = vsc7385_icpu_reset(vsc);
+	if (rc)
+		goto out;
+
+	dev_info(&spi->dev, "uploading microcode...\n");
+
+	dp = (unsigned char *) firmware->data;
+	for (i = 0; i < firmware->size; i++) {
+		rc = vsc7385_write(vsc, VSC73XX_BLOCK_SYSTEM, 0,
+				   VSC73XX_ICPU_SRAM, *dp++);
+		if (rc) {
+			dev_err(&spi->dev, "could not load microcode, err=%d\n",
+				rc);
+			goto out;
+		}
+	}
+
+	rc = vsc7385_icpu_reset(vsc);
+	if (rc)
+		goto out;
+
+	dev_info(&spi->dev, "verifying microcode...\n");
+
+	dp = (unsigned char *) firmware->data;
+	diffs = 0;
+	for (i = 0; i < firmware->size; i++) {
+		rc = vsc7385_read(vsc, VSC73XX_BLOCK_SYSTEM, 0,
+				  VSC73XX_ICPU_SRAM, &curVal);
+		if (rc) {
+			dev_err(&spi->dev, "could not read microcode %d\n",rc);
+			goto out;
+		}
+
+		if (curVal > 0xff) {
+			dev_err(&spi->dev, "bad val read: %04x : %02x  %02x\n",
+				i, *dp, curVal);
+			rc = -EIO;
+			goto out;
+		}
+
+		if ((curVal & 0xff) != *dp) {
+			diffs++;
+			dev_err(&spi->dev, "verify error: %04x : %02x  %02x\n",
+				i, *dp, curVal);
+
+			if (diffs > 4)
+				break;
+			}
+		dp++;
+	}
+
+	if (diffs) {
+		dev_err(&spi->dev, "microcode verification failed\n");
+		rc = -EIO;
+		goto out;
+	}
+
+	dev_info(&spi->dev, "microcode uploaded\n");
+
+	rc = vsc7385_icpu_start(vsc);
+
+ out:
+	release_firmware(firmware);
+	return rc;
+}
+
+static int vsc7385_setup(struct vsc7385 *vsc)
+{
+	struct vsc7385_platform_data *pdata = vsc->pdata;
+	u32 t;
+	int err;
+
+	err = vsc7385_write_verify(vsc, VSC73XX_BLOCK_SYSTEM, 0,
+				   VSC73XX_ICPU_CLOCK_DELAY,
+				   VSC7385_CLOCK_DELAY,
+				   VSC7385_CLOCK_DELAY_MASK,
+				   VSC7385_CLOCK_DELAY);
+	if (err)
+		goto err;
+
+	err = vsc7385_write_verify(vsc, VSC73XX_BLOCK_MAC,
+				   VSC73XX_SUBBLOCK_PORT_MAC, VSC73XX_ADVPORTM,
+				   VSC7385_ADVPORTM_INIT,
+				   VSC7385_ADVPORTM_MASK,
+				   VSC7385_ADVPORTM_INIT);
+	if (err)
+		goto err;
+
+	err = vsc7385_write(vsc, VSC73XX_BLOCK_MAC, VSC73XX_SUBBLOCK_PORT_MAC,
+			    VSC73XX_MAC_CFG, VSC7385_MAC_CFG_RESET);
+	if (err)
+		goto err;
+
+	t = VSC73XX_MAC_CFG_INIT;
+	t |= VSC73XX_MAC_CFG_TX_IPG(pdata->mac_cfg.tx_ipg);
+	t |= VSC73XX_MAC_CFG_CLK_SEL(pdata->mac_cfg.clk_sel);
+	if (pdata->mac_cfg.bit2)
+		t |= VSC73XX_MAC_CFG_BIT2;
+
+	err = vsc7385_write(vsc, VSC73XX_BLOCK_MAC, VSC73XX_SUBBLOCK_PORT_MAC,
+			    VSC73XX_MAC_CFG, t);
+	if (err)
+		goto err;
+
+	return 0;
+
+ err:
+	return err;
+}
+
+static int vsc7385_detect(struct vsc7385 *vsc)
+{
+	struct spi_device *spi = vsc->spi;
+	u32 t;
+	u32 id;
+	u32 rev;
+	int err;
+
+	err = vsc7385_read(vsc, VSC73XX_BLOCK_SYSTEM, 0,
+				VSC73XX_ICPU_MBOX_VAL, &t);
+	if (err) {
+		dev_err(&spi->dev, "unable to read mailbox, err=%d\n", err);
+		return err;
+	}
+
+	if (t == 0xffffffff) {
+		dev_dbg(&spi->dev, "assert chip reset\n");
+		if (vsc->pdata->reset)
+			vsc->pdata->reset();
+
+	}
+
+	err = vsc7385_read(vsc, VSC73XX_BLOCK_SYSTEM, 0,
+				VSC73XX_ICPU_CHIPID, &t);
+	if (err) {
+		dev_err(&spi->dev, "unable to read chip id, err=%d\n", err);
+		return err;
+	}
+
+	id = (t >> VSC73XX_ICPU_CHIPID_ID_SHIFT) & VSC73XX_ICPU_CHIPID_ID_MASK;
+	switch (id) {
+	case VSC73XX_ICPU_CHIPID_ID_7385:
+	case VSC73XX_ICPU_CHIPID_ID_7395:
+		break;
+	default:
+		dev_err(&spi->dev, "unsupported chip, id=%04x\n", id);
+		return -ENODEV;
+	}
+
+	rev = (t >> VSC73XX_ICPU_CHIPID_REV_SHIFT) &
+	      VSC73XX_ICPU_CHIPID_REV_MASK;
+	dev_info(&spi->dev, "VSC%04X (rev. %d) switch found \n", id, rev);
+
+	return 0;
+}
+
+static int __devinit vsc7385_probe(struct spi_device *spi)
+{
+	struct vsc7385 *vsc;
+	struct vsc7385_platform_data *pdata;
+	int	err;
+
+	printk(KERN_INFO DRV_DESC " version " DRV_VERSION"\n");
+
+	pdata = spi->dev.platform_data;
+	if (!pdata) {
+		dev_err(&spi->dev, "no platform data specified\n");
+		return-ENODEV;
+	}
+
+	vsc = kzalloc(sizeof(*vsc), GFP_KERNEL);
+	if (!vsc) {
+		dev_err(&spi->dev, "no memory for private data\n");
+		return-ENOMEM;
+	}
+
+	mutex_init(&vsc->lock);
+	vsc->pdata = pdata;
+	vsc->spi = spi_dev_get(spi);
+	dev_set_drvdata(&spi->dev, vsc);
+
+	spi->mode = SPI_MODE_0;
+	spi->bits_per_word = 8;
+	err = spi_setup(spi);
+	if (err) {
+		dev_err(&spi->dev, "spi_setup failed, err=%d \n", err);
+		goto err_drvdata;
+	}
+
+	err = vsc7385_detect(vsc);
+	if (err) {
+		dev_err(&spi->dev, "no chip found, err=%d \n", err);
+		goto err_drvdata;
+	}
+
+	err = vsc7385_upload_ucode(vsc);
+	if (err)
+		goto err_drvdata;
+
+	err = vsc7385_setup(vsc);
+	if (err)
+		goto err_drvdata;
+
+	return 0;
+
+ err_drvdata:
+	dev_set_drvdata(&spi->dev, NULL);
+	kfree(vsc);
+	return err;
+}
+
+static int __devexit vsc7385_remove(struct spi_device *spi)
+{
+	struct vsc7385_data	*vsc;
+
+	vsc = dev_get_drvdata(&spi->dev);
+	dev_set_drvdata(&spi->dev, NULL);
+	kfree(vsc);
+
+	return 0;
+}
+
+static struct spi_driver vsc7385_driver = {
+	.driver = {
+		.name		= DRV_NAME,
+		.bus		= &spi_bus_type,
+		.owner		= THIS_MODULE,
+	},
+	.probe		= vsc7385_probe,
+	.remove		= __devexit_p(vsc7385_remove),
+};
+
+static int __init vsc7385_init(void)
+{
+	return spi_register_driver(&vsc7385_driver);
+}
+module_init(vsc7385_init);
+
+static void __exit vsc7385_exit(void)
+{
+	spi_unregister_driver(&vsc7385_driver);
+}
+module_exit(vsc7385_exit);
+
+MODULE_DESCRIPTION(DRV_DESC);
+MODULE_VERSION(DRV_VERSION);
+MODULE_AUTHOR("Gabor Juhos <juhosg@openwrt.org>");
+MODULE_LICENSE("GPL v2");
+
-- 
1.7.4.1

