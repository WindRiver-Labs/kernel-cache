From 9c38f3db05ddf76d646a2d85f2281b9ab727ed1d Mon Sep 17 00:00:00 2001
From: Zumeng Chen <zumeng.chen@windriver.com>
Date: Fri, 16 Dec 2011 12:05:02 +0800
Subject: [PATCH 41/41] routerstatiopro: import upstream fixes

Importing 3.0 kernel fixes from: git://nbd.name/openwrt.git

 910-kobject_uevent.patch
 911-kobject_add_broadcast_uevent.patch
 930-crashlog.patch
 950-vm_exports.patch
 960-decompress_unlzo_fix.patch

Integrated-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 arch/mips/Kconfig                   |    4 -
 include/linux/crashlog.h            |   12 +++
 include/linux/decompress/unlzo_mm.h |   10 ++
 include/linux/kobject.h             |   16 ++++
 include/linux/mm.h                  |    1 +
 init/Kconfig                        |    4 +
 kernel/Makefile                     |    1 +
 kernel/crashlog.c                   |  171 +++++++++++++++++++++++++++++++++++
 kernel/exit.c                       |    2 +
 kernel/module.c                     |    3 +
 kernel/sched.c                      |    1 +
 lib/decompress_unlzo.c              |    1 +
 lib/kobject_uevent.c                |   53 ++++++++++-
 mm/bootmem.c                        |    2 +
 mm/memory.c                         |    2 +
 mm/shmem.c                          |   17 +++-
 mm/vmalloc.c                        |    2 +
 17 files changed, 290 insertions(+), 12 deletions(-)
 create mode 100644 include/linux/crashlog.h
 create mode 100644 include/linux/decompress/unlzo_mm.h
 create mode 100644 kernel/crashlog.c

diff --git a/arch/mips/Kconfig b/arch/mips/Kconfig
index 93a7de2..8ea1b03 100644
--- a/arch/mips/Kconfig
+++ b/arch/mips/Kconfig
@@ -985,10 +985,6 @@ config MIPS_MACHINE
 config MIPS_MACHINE
 	def_bool n
 
-config IMAGE_CMDLINE_HACK
-	bool "OpenWrt specific image command line hack"
-	default n
-
 config NO_IOPORT
 	def_bool n
 
diff --git a/include/linux/crashlog.h b/include/linux/crashlog.h
new file mode 100644
index 0000000..11e98b3
--- /dev/null
+++ b/include/linux/crashlog.h
@@ -0,0 +1,12 @@
+#ifndef __CRASHLOG_H
+#define __CRASHLOG_H
+
+#ifdef CONFIG_CRASHLOG
+void __init crashlog_init_mem(struct bootmem_data *bdata);
+#else
+static inline void crashlog_init_mem(struct bootmem_data *bdata)
+{
+}
+#endif
+
+#endif
diff --git a/include/linux/decompress/unlzo_mm.h b/include/linux/decompress/unlzo_mm.h
new file mode 100644
index 0000000..08f9e70
--- /dev/null
+++ b/include/linux/decompress/unlzo_mm.h
@@ -0,0 +1,10 @@
+#ifndef UNLZO_MM_H
+#define UNLZO_MM_H
+
+#ifdef STATIC
+#define INIT
+#else
+#define INIT __init
+#endif
+
+#endif
diff --git a/include/linux/kobject.h b/include/linux/kobject.h
index 9229b64..ce0b1c6 100644
--- a/include/linux/kobject.h
+++ b/include/linux/kobject.h
@@ -31,6 +31,8 @@
 #define UEVENT_NUM_ENVP			32	/* number of env pointers */
 #define UEVENT_BUFFER_SIZE		2048	/* buffer for the variables */
 
+struct sk_buff;
+
 /* path to the userspace helper executed on an event */
 extern char uevent_helper[];
 
@@ -217,6 +219,10 @@ int add_uevent_var(struct kobj_uevent_env *env, const char *format, ...)
 
 int kobject_action_type(const char *buf, size_t count,
 			enum kobject_action *type);
+
+int broadcast_uevent(struct sk_buff *skb, __u32 pid, __u32 group,
+		     gfp_t allocation);
+
 #else
 static inline int kobject_uevent(struct kobject *kobj,
 				 enum kobject_action action)
@@ -233,6 +239,16 @@ int add_uevent_var(struct kobj_uevent_env *env, const char *format, ...)
 static inline int kobject_action_type(const char *buf, size_t count,
 				      enum kobject_action *type)
 { return -EINVAL; }
+
+void kfree_skb(struct sk_buff *);
+
+static inline int broadcast_uevent(struct sk_buff *skb, __u32 pid, __u32 group,
+				   gfp_t allocation)
+{
+	kfree_skb(skb);
+	return 0;
+}
+
 #endif
 
 #endif /* _KOBJECT_H_ */
diff --git a/include/linux/mm.h b/include/linux/mm.h
index 9ce5766..30dcd19 100644
--- a/include/linux/mm.h
+++ b/include/linux/mm.h
@@ -870,6 +870,7 @@ extern bool skip_free_areas_node(unsigned int flags, int nid);
 
 int shmem_lock(struct file *file, int lock, struct user_struct *user);
 struct file *shmem_file_setup(const char *name, loff_t size, unsigned long flags);
+void shmem_set_file(struct vm_area_struct *vma, struct file *file);
 int shmem_zero_setup(struct vm_area_struct *);
 
 extern int can_do_mlock(void);
diff --git a/init/Kconfig b/init/Kconfig
index 76f8df8..b56ab65 100644
--- a/init/Kconfig
+++ b/init/Kconfig
@@ -888,6 +888,10 @@ config RELAY
 
 	  If unsure, say N.
 
+config CRASHLOG
+	bool "Crash logging"
+	depends on !NO_BOOTMEM && !HAVE_MEMBLOCK
+
 config BLK_DEV_INITRD
 	bool "Initial RAM filesystem and RAM disk (initramfs/initrd) support"
 	depends on BROKEN || !FRV
diff --git a/kernel/Makefile b/kernel/Makefile
index a3b9eea..85482a4 100644
--- a/kernel/Makefile
+++ b/kernel/Makefile
@@ -113,6 +113,7 @@ obj-$(CONFIG_PERF_EVENTS) += events/
 obj-$(CONFIG_USER_RETURN_NOTIFIER) += user-return-notifier.o
 obj-$(CONFIG_PADATA) += padata.o
 obj-$(CONFIG_CRASH_DUMP) += crash_dump.o
+obj-$(CONFIG_CRASHLOG) += crashlog.o
 
 ifneq ($(CONFIG_SCHED_OMIT_FRAME_POINTER),y)
 # According to Alan Modra <alan@linuxcare.com.au>, the -fno-omit-frame-pointer is
diff --git a/kernel/crashlog.c b/kernel/crashlog.c
new file mode 100644
index 0000000..00ea545
--- /dev/null
+++ b/kernel/crashlog.c
@@ -0,0 +1,171 @@
+/*
+ * Crash information logger
+ * Copyright (C) 2010 Felix Fietkau <nbd@openwrt.org>
+ *
+ * Based on ramoops.c
+ *   Copyright (C) 2010 Marco Stornelli <marco.stornelli@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/bootmem.h>
+#include <linux/debugfs.h>
+#include <linux/crashlog.h>
+#include <linux/kmsg_dump.h>
+#include <linux/module.h>
+#include <linux/pfn.h>
+#include <asm/io.h>
+
+#define CRASHLOG_PAGES	4
+#define CRASHLOG_SIZE	(CRASHLOG_PAGES * PAGE_SIZE)
+#define CRASHLOG_MAGIC	0xa1eedead
+
+/*
+ * Start the log at 1M before the end of RAM, as some boot loaders like
+ * to use the end of the RAM for stack usage and other things
+ * If this fails, fall back to using the last part.
+ */
+#define CRASHLOG_OFFSET	(1024 * 1024)
+
+struct crashlog_data {
+	u32 magic;
+	u32 len;
+	u8 data[];
+};
+
+static struct debugfs_blob_wrapper crashlog_blob;
+static unsigned long crashlog_addr = 0;
+static struct crashlog_data *crashlog_buf;
+static struct kmsg_dumper dump;
+static bool first = true;
+
+extern struct list_head *crashlog_modules;
+
+void __init crashlog_init_mem(bootmem_data_t *bdata)
+{
+	unsigned long addr;
+
+	if (crashlog_addr)
+		return;
+
+	addr = PFN_PHYS(bdata->node_low_pfn) - CRASHLOG_OFFSET;
+	if (reserve_bootmem(addr, CRASHLOG_SIZE, BOOTMEM_EXCLUSIVE) < 0) {
+		printk("Crashlog failed to allocate RAM at address 0x%lx\n", addr);
+		bdata->node_low_pfn -= CRASHLOG_PAGES;
+		addr = PFN_PHYS(bdata->node_low_pfn);
+	}
+	crashlog_addr = addr;
+}
+
+static void __init crashlog_copy(void)
+{
+	if (crashlog_buf->magic != CRASHLOG_MAGIC)
+		return;
+
+	if (!crashlog_buf->len || crashlog_buf->len >
+	    CRASHLOG_SIZE - sizeof(*crashlog_buf))
+		return;
+
+	crashlog_blob.size = crashlog_buf->len;
+	crashlog_blob.data = kmemdup(crashlog_buf->data,
+		crashlog_buf->len, GFP_KERNEL);
+
+	debugfs_create_blob("crashlog", 0700, NULL, &crashlog_blob);
+}
+
+static int get_maxlen(void)
+{
+	return CRASHLOG_SIZE - sizeof(*crashlog_buf) - crashlog_buf->len;
+}
+
+static void crashlog_printf(const char *fmt, ...)
+{
+	va_list args;
+	int len = get_maxlen();
+
+	if (!len)
+		return;
+
+	va_start(args, fmt);
+	crashlog_buf->len += vsnprintf(
+		&crashlog_buf->data[crashlog_buf->len],
+		len, fmt, args);
+	va_end(args);
+}
+
+static void crashlog_do_dump(struct kmsg_dumper *dumper,
+		enum kmsg_dump_reason reason, const char *s1, unsigned long l1,
+		const char *s2, unsigned long l2)
+{
+	unsigned long s1_start, s2_start;
+	unsigned long l1_cpy, l2_cpy;
+	struct timeval tv;
+	struct module *m;
+	char *buf;
+	int len;
+
+	if (!first)
+		crashlog_printf("\n===================================\n");
+
+	do_gettimeofday(&tv);
+	crashlog_printf("Time: %lu.%lu\n",
+		(long)tv.tv_sec, (long)tv.tv_usec);
+
+	if (first) {
+		crashlog_printf("Modules:");
+		list_for_each_entry(m, crashlog_modules, list) {
+			crashlog_printf("\t%s@%p+%x", m->name,
+			m->module_core, m->core_size,
+			m->module_init, m->init_size);
+		}
+		crashlog_printf("\n");
+		first = false;
+	}
+
+	buf = (char *)&crashlog_buf->data[crashlog_buf->len];
+	len = get_maxlen();
+
+	l2_cpy = min(l2, (unsigned long)len);
+	l1_cpy = min(l1, (unsigned long)len - l2_cpy);
+
+	s2_start = l2 - l2_cpy;
+	s1_start = l1 - l1_cpy;
+
+	memcpy(buf, s1 + s1_start, l1_cpy);
+	memcpy(buf + l1_cpy, s2 + s2_start, l2_cpy);
+	crashlog_buf->len += l1_cpy + l2_cpy;
+}
+
+
+int __init crashlog_init_fs(void)
+{
+	if (!crashlog_addr)
+		return -ENOMEM;
+
+	crashlog_buf = ioremap(crashlog_addr, CRASHLOG_SIZE);
+
+	crashlog_copy();
+
+	crashlog_buf->magic = CRASHLOG_MAGIC;
+	crashlog_buf->len = 0;
+
+	dump.dump = crashlog_do_dump;
+	kmsg_dump_register(&dump);
+
+	return 0;
+}
+module_init(crashlog_init_fs);
diff --git a/kernel/exit.c b/kernel/exit.c
index 7f739f9..b53b67f 100644
--- a/kernel/exit.c
+++ b/kernel/exit.c
@@ -513,6 +513,7 @@ struct files_struct *get_files_struct(struct task_struct *task)
 
 	return files;
 }
+EXPORT_SYMBOL_GPL(get_files_struct);
 
 void put_files_struct(struct files_struct *files)
 {
@@ -534,6 +535,7 @@ void put_files_struct(struct files_struct *files)
 		rcu_read_unlock();
 	}
 }
+EXPORT_SYMBOL_GPL(put_files_struct);
 
 void reset_files_struct(struct files_struct *files)
 {
diff --git a/kernel/module.c b/kernel/module.c
index 795bdc7..9635d41 100644
--- a/kernel/module.c
+++ b/kernel/module.c
@@ -107,6 +107,9 @@ static LIST_HEAD(modules);
 #ifdef CONFIG_KGDB_KDB
 struct list_head *kdb_modules = &modules; /* kdb needs the list of modules */
 #endif /* CONFIG_KGDB_KDB */
+#ifdef CONFIG_CRASHLOG
+struct list_head *crashlog_modules = &modules;
+#endif
 
 
 /* Block module loading/unloading? */
diff --git a/kernel/sched.c b/kernel/sched.c
index 63aeba0..b94d7c3 100644
--- a/kernel/sched.c
+++ b/kernel/sched.c
@@ -5095,6 +5095,7 @@ int can_nice(const struct task_struct *p, const int nice)
 	return (nice_rlim <= task_rlimit(p, RLIMIT_NICE) ||
 		capable(CAP_SYS_NICE));
 }
+EXPORT_SYMBOL_GPL(can_nice);
 
 #ifdef __ARCH_WANT_SYS_NICE
 
diff --git a/lib/decompress_unlzo.c b/lib/decompress_unlzo.c
index 5a7a2ad..09c4d85 100644
--- a/lib/decompress_unlzo.c
+++ b/lib/decompress_unlzo.c
@@ -38,6 +38,7 @@
 
 #include <linux/types.h>
 #include <linux/lzo.h>
+#include <linux/decompress/unlzo_mm.h>
 #include <linux/decompress/mm.h>
 
 #include <linux/compiler.h>
diff --git a/lib/kobject_uevent.c b/lib/kobject_uevent.c
index ad72a03..f54da30 100644
--- a/lib/kobject_uevent.c
+++ b/lib/kobject_uevent.c
@@ -49,6 +49,18 @@ static const char *kobject_actions[] = {
 	[KOBJ_OFFLINE] =	"offline",
 };
 
+u64 uevent_next_seqnum(void)
+{
+	u64 seq;
+
+	spin_lock(&sequence_lock);
+	seq = ++uevent_seqnum;
+	spin_unlock(&sequence_lock);
+
+	return seq;
+}
+EXPORT_SYMBOL_GPL(uevent_next_seqnum);
+
 /**
  * kobject_action_type - translate action string to numeric type
  *
@@ -244,9 +256,7 @@ int kobject_uevent_env(struct kobject *kobj, enum kobject_action action,
 		kobj->state_remove_uevent_sent = 1;
 
 	/* we will send an event, so request a new sequence number */
-	spin_lock(&sequence_lock);
-	seq = ++uevent_seqnum;
-	spin_unlock(&sequence_lock);
+	seq = uevent_next_seqnum();
 	retval = add_uevent_var(env, "SEQNUM=%llu", (unsigned long long)seq);
 	if (retval)
 		goto exit;
@@ -367,6 +377,43 @@ int add_uevent_var(struct kobj_uevent_env *env, const char *format, ...)
 EXPORT_SYMBOL_GPL(add_uevent_var);
 
 #if defined(CONFIG_NET)
+int broadcast_uevent(struct sk_buff *skb, __u32 pid, __u32 group,
+		     gfp_t allocation)
+{
+	struct uevent_sock *ue_sk;
+	int err = 0;
+
+	/* send netlink message */
+	mutex_lock(&uevent_sock_mutex);
+	list_for_each_entry(ue_sk, &uevent_sock_list, list) {
+		struct sock *uevent_sock = ue_sk->sk;
+		struct sk_buff *skb2;
+
+		skb2 = skb_clone(skb, allocation);
+		if (!skb2)
+			break;
+
+		err = netlink_broadcast(uevent_sock, skb2, pid, group,
+					allocation);
+		if (err)
+			break;
+	}
+	mutex_unlock(&uevent_sock_mutex);
+
+	kfree_skb(skb);
+	return err;
+}
+#else
+int broadcast_uevent(struct sk_buff *skb, __u32 pid, __u32 group,
+		     gfp_t allocation)
+{
+	kfree_skb(skb);
+	return 0;
+}
+#endif
+EXPORT_SYMBOL_GPL(broadcast_uevent);
+
+#if defined(CONFIG_NET)
 static int uevent_net_init(struct net *net)
 {
 	struct uevent_sock *ue_sk;
diff --git a/mm/bootmem.c b/mm/bootmem.c
index 01d5a4b3..a59e42f 100644
--- a/mm/bootmem.c
+++ b/mm/bootmem.c
@@ -15,6 +15,7 @@
 #include <linux/module.h>
 #include <linux/kmemleak.h>
 #include <linux/range.h>
+#include <linux/crashlog.h>
 #include <linux/memblock.h>
 
 #include <asm/bug.h>
@@ -178,6 +179,7 @@ static unsigned long __init free_all_bootmem_core(bootmem_data_t *bdata)
 	if (!bdata->node_bootmem_map)
 		return 0;
 
+	crashlog_init_mem(bdata);
 	start = bdata->node_min_pfn;
 	end = bdata->node_low_pfn;
 
diff --git a/mm/memory.c b/mm/memory.c
index 52f6771..0dba0f4 100644
--- a/mm/memory.c
+++ b/mm/memory.c
@@ -1389,6 +1389,7 @@ unsigned long zap_page_range(struct vm_area_struct *vma, unsigned long address,
 	tlb_finish_mmu(&tlb, address, end);
 	return end;
 }
+EXPORT_SYMBOL_GPL(zap_page_range);
 
 /**
  * zap_vma_ptes - remove ptes mapping the vma
@@ -3064,6 +3065,7 @@ static inline int check_stack_guard_page(struct vm_area_struct *vma, unsigned lo
 	}
 	return 0;
 }
+EXPORT_SYMBOL_GPL(vmtruncate_range);
 
 /*
  * We enter with non-exclusive mmap_sem (to exclude vma changes,
diff --git a/mm/shmem.c b/mm/shmem.c
index fcedf54..92e5c15 100644
--- a/mm/shmem.c
+++ b/mm/shmem.c
@@ -2951,6 +2951,16 @@ out:
 
 /* common code */
 
+void shmem_set_file(struct vm_area_struct *vma, struct file *file)
+{
+	if (vma->vm_file)
+		fput(vma->vm_file);
+	vma->vm_file = file;
+	vma->vm_ops = &shmem_vm_ops;
+	vma->vm_flags |= VM_CAN_NONLINEAR;
+}
+EXPORT_SYMBOL_GPL(shmem_set_file);
+
 /**
  * shmem_file_setup - get an unlinked file living in tmpfs
  * @name: name for dentry (to be seen in /proc/<pid>/maps
@@ -3028,11 +3038,8 @@ int shmem_zero_setup(struct vm_area_struct *vma)
 	if (IS_ERR(file))
 		return PTR_ERR(file);
 
-	if (vma->vm_file)
-		fput(vma->vm_file);
-	vma->vm_file = file;
-	vma->vm_ops = &shmem_vm_ops;
-	vma->vm_flags |= VM_CAN_NONLINEAR;
+	shmem_set_file(vma, file);
+
 	return 0;
 }
 
diff --git a/mm/vmalloc.c b/mm/vmalloc.c
index 95c34be..ceccd35 100644
--- a/mm/vmalloc.c
+++ b/mm/vmalloc.c
@@ -1248,6 +1248,7 @@ void unmap_kernel_range(unsigned long addr, unsigned long size)
 	vunmap_page_range(addr, end);
 	flush_tlb_kernel_range(addr, end);
 }
+EXPORT_SYMBOL_GPL(unmap_kernel_range);
 
 int map_vm_area(struct vm_struct *area, pgprot_t prot, struct page ***pages)
 {
@@ -1385,6 +1386,7 @@ struct vm_struct *get_vm_area(unsigned long size, unsigned long flags)
 	return __get_vm_area_node(size, 1, flags, VMALLOC_START, VMALLOC_END,
 				-1, GFP_KERNEL, __builtin_return_address(0));
 }
+EXPORT_SYMBOL_GPL(get_vm_area);
 
 struct vm_struct *get_vm_area_caller(unsigned long size, unsigned long flags,
 				void *caller)
-- 
1.7.4.1

