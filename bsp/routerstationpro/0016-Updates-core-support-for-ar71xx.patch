From fc0458bfe3a96a3d983325b46dec276ff0f53c00 Mon Sep 17 00:00:00 2001
From: Zumeng Chen <zumeng.chen@windriver.com>
Date: Thu, 24 Nov 2011 14:39:14 +0800
Subject: [PATCH 16/41] Updates core support for ar71xx

which from the following git repo.
  git://nbd.name/openwrt.git

Integrated-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 arch/mips/ar71xx/Kconfig                           |  251 ++++++--
 arch/mips/ar71xx/Makefile                          |   22 +-
 arch/mips/ar71xx/ar71xx.c                          |  141 ++++-
 arch/mips/ar71xx/dev-ap91-eth.c                    |   70 --
 arch/mips/ar71xx/dev-ap91-eth.h                    |   23 -
 arch/mips/ar71xx/dev-ap91-pci.c                    |   69 +--
 arch/mips/ar71xx/dev-ap91-pci.h                    |    4 +
 arch/mips/ar71xx/dev-ap94-pci.c                    |  122 +---
 arch/mips/ar71xx/dev-ap94-pci.h                    |    7 +-
 arch/mips/ar71xx/dev-ar913x-wmac.c                 |   68 --
 arch/mips/ar71xx/dev-ar913x-wmac.h                 |   19 -
 arch/mips/ar71xx/dev-ar9xxx-wmac.c                 |  156 +++++
 arch/mips/ar71xx/dev-ar9xxx-wmac.h                 |   20 +
 arch/mips/ar71xx/dev-db120-pci.c                   |   59 ++
 arch/mips/ar71xx/dev-db120-pci.h                   |   23 +
 arch/mips/ar71xx/dev-dsa.c                         |   20 +-
 arch/mips/ar71xx/dev-dsa.h                         |    3 +-
 arch/mips/ar71xx/dev-gpio-buttons.c                |   16 +-
 arch/mips/ar71xx/dev-gpio-buttons.h                |   12 +-
 arch/mips/ar71xx/dev-usb.c                         |   89 +++-
 arch/mips/ar71xx/devices.c                         |  695 +++++++++++++++++---
 arch/mips/ar71xx/devices.h                         |    9 +-
 arch/mips/ar71xx/early_printk.c                    |   86 +++-
 arch/mips/ar71xx/gpio.c                            |  145 ++++-
 arch/mips/ar71xx/irq.c                             |  269 ++++++--
 arch/mips/ar71xx/mach-all0258n.c                   |  140 ++++
 arch/mips/ar71xx/mach-ap121.c                      |  237 +++++++
 arch/mips/ar71xx/mach-ap81.c                       |   38 +-
 arch/mips/ar71xx/mach-ap83.c                       |   47 +-
 arch/mips/ar71xx/mach-ap96.c                       |  180 +++++
 arch/mips/ar71xx/mach-aw-nr580.c                   |   21 +-
 arch/mips/ar71xx/mach-db120.c                      |  156 +++++
 arch/mips/ar71xx/mach-dir-600-a1.c                 |   41 +-
 arch/mips/ar71xx/mach-dir-615-c1.c                 |   58 +-
 arch/mips/ar71xx/mach-dir-825-b1.c                 |   99 ++--
 arch/mips/ar71xx/mach-eap7660d.c                   |  180 +++++
 arch/mips/ar71xx/mach-ja76pf.c                     |  102 +++
 arch/mips/ar71xx/mach-jwap003.c                    |   83 +++
 arch/mips/ar71xx/mach-mzk-w04nu.c                  |   57 +-
 arch/mips/ar71xx/mach-mzk-w300nh.c                 |   57 +-
 arch/mips/ar71xx/mach-nbg460n.c                    |  225 +++++++
 arch/mips/ar71xx/mach-om2p.c                       |  114 ++++
 arch/mips/ar71xx/mach-pb42.c                       |   21 +-
 arch/mips/ar71xx/mach-pb44.c                       |   26 +-
 arch/mips/ar71xx/mach-pb92.c                       |   44 +-
 arch/mips/ar71xx/mach-rb4xx.c                      |  278 ++++++---
 arch/mips/ar71xx/mach-rb750.c                      |   39 +-
 arch/mips/ar71xx/mach-tew-632brp.c                 |   50 +-
 arch/mips/ar71xx/mach-tl-mr3x20.c                  |  157 +++++
 arch/mips/ar71xx/mach-tl-wa901nd-v2.c              |  132 ++++
 arch/mips/ar71xx/mach-tl-wa901nd.c                 |  125 ++++
 arch/mips/ar71xx/mach-tl-wr1043nd.c                |   46 +-
 arch/mips/ar71xx/mach-tl-wr703n.c                  |  116 ++++
 arch/mips/ar71xx/mach-tl-wr741nd-v4.c              |  146 ++++
 arch/mips/ar71xx/mach-tl-wr741nd.c                 |   54 +-
 arch/mips/ar71xx/mach-tl-wr841n.c                  |   48 +-
 arch/mips/ar71xx/mach-tl-wr941nd.c                 |   55 +-
 arch/mips/ar71xx/mach-ubnt.c                       |  122 +++--
 arch/mips/ar71xx/mach-whr-hp-g300n.c               |  169 +++++
 arch/mips/ar71xx/mach-wndr3700.c                   |  151 ++++-
 arch/mips/ar71xx/mach-wnr2000.c                    |   46 +-
 arch/mips/ar71xx/mach-wp543.c                      |   18 +-
 arch/mips/ar71xx/mach-wrt160nl.c                   |   49 +-
 arch/mips/ar71xx/mach-wrt400n.c                    |   54 +-
 arch/mips/ar71xx/mach-wzr-hp-ag300h.c              |  231 +++++++
 arch/mips/ar71xx/mach-wzr-hp-g300nh.c              |   97 ++-
 arch/mips/ar71xx/mach-zcn-1523h.c                  |  208 ++++++
 arch/mips/ar71xx/machtype.h                        |   48 +-
 arch/mips/ar71xx/nvram.c                           |    2 +-
 arch/mips/ar71xx/pci-ath9k-fixup.c                 |  123 ++++
 arch/mips/ar71xx/pci-ath9k-fixup.h                 |    6 +
 arch/mips/ar71xx/pci.c                             |    9 +-
 arch/mips/ar71xx/prom.c                            |   49 +-
 arch/mips/ar71xx/setup.c                           |  196 +++++-
 arch/mips/include/asm/mach-ar71xx/ar71xx.h         |  410 +++++++++++-
 arch/mips/include/asm/mach-ar71xx/ar933x_uart.h    |   67 ++
 .../include/asm/mach-ar71xx/ar933x_uart_platform.h |   18 +
 arch/mips/include/asm/mach-ar71xx/irq.h            |    2 +-
 arch/mips/include/asm/mach-ar71xx/mangle-port.h    |    2 +-
 arch/mips/include/asm/mach-ar71xx/pci.h            |    9 +-
 arch/mips/include/asm/mach-ar71xx/platform.h       |    6 +-
 arch/mips/include/asm/mach-ar71xx/rb4xx_cpld.h     |   48 ++
 82 files changed, 6357 insertions(+), 1353 deletions(-)
 delete mode 100644 arch/mips/ar71xx/dev-ap91-eth.c
 delete mode 100644 arch/mips/ar71xx/dev-ap91-eth.h
 delete mode 100644 arch/mips/ar71xx/dev-ar913x-wmac.c
 delete mode 100644 arch/mips/ar71xx/dev-ar913x-wmac.h
 create mode 100644 arch/mips/ar71xx/dev-ar9xxx-wmac.c
 create mode 100644 arch/mips/ar71xx/dev-ar9xxx-wmac.h
 create mode 100644 arch/mips/ar71xx/dev-db120-pci.c
 create mode 100644 arch/mips/ar71xx/dev-db120-pci.h
 create mode 100644 arch/mips/ar71xx/mach-all0258n.c
 create mode 100644 arch/mips/ar71xx/mach-ap121.c
 create mode 100644 arch/mips/ar71xx/mach-ap96.c
 create mode 100644 arch/mips/ar71xx/mach-db120.c
 create mode 100644 arch/mips/ar71xx/mach-eap7660d.c
 create mode 100644 arch/mips/ar71xx/mach-ja76pf.c
 create mode 100644 arch/mips/ar71xx/mach-jwap003.c
 create mode 100644 arch/mips/ar71xx/mach-nbg460n.c
 create mode 100644 arch/mips/ar71xx/mach-om2p.c
 create mode 100644 arch/mips/ar71xx/mach-tl-mr3x20.c
 create mode 100644 arch/mips/ar71xx/mach-tl-wa901nd-v2.c
 create mode 100644 arch/mips/ar71xx/mach-tl-wa901nd.c
 create mode 100644 arch/mips/ar71xx/mach-tl-wr703n.c
 create mode 100644 arch/mips/ar71xx/mach-tl-wr741nd-v4.c
 create mode 100644 arch/mips/ar71xx/mach-whr-hp-g300n.c
 create mode 100644 arch/mips/ar71xx/mach-wzr-hp-ag300h.c
 create mode 100644 arch/mips/ar71xx/mach-zcn-1523h.c
 create mode 100644 arch/mips/ar71xx/pci-ath9k-fixup.c
 create mode 100644 arch/mips/ar71xx/pci-ath9k-fixup.h
 create mode 100644 arch/mips/include/asm/mach-ar71xx/ar933x_uart.h
 create mode 100644 arch/mips/include/asm/mach-ar71xx/ar933x_uart_platform.h
 create mode 100644 arch/mips/include/asm/mach-ar71xx/rb4xx_cpld.h

diff --git a/arch/mips/ar71xx/Kconfig b/arch/mips/ar71xx/Kconfig
index c471e3f..f80974b 100644
--- a/arch/mips/ar71xx/Kconfig
+++ b/arch/mips/ar71xx/Kconfig
@@ -1,235 +1,395 @@
 if ATHEROS_AR71XX
 
 menu "Atheros AR71xx machine selection"
+config AR71XX_MACH_ALL0258N
+	bool "Allnet ALL0258N support"
+	select SOC_AR724X
+	select AR71XX_DEV_M25P80
+	select AR71XX_DEV_AP91_PCI if PCI
+	select AR71XX_DEV_GPIO_BUTTONS
+	select AR71XX_DEV_LEDS_GPIO
 
 config AR71XX_MACH_AP81
 	bool "Atheros AP81 board support"
+	select SOC_AR913X
 	select AR71XX_DEV_M25P80
-	select AR71XX_DEV_AR913X_WMAC
+	select AR71XX_DEV_AR9XXX_WMAC
 	select AR71XX_DEV_GPIO_BUTTONS
 	select AR71XX_DEV_LEDS_GPIO
 	select AR71XX_DEV_USB
-	default n
 
 config AR71XX_MACH_AP83
 	bool "Atheros AP83 board support"
-	select AR71XX_DEV_AR913X_WMAC
+	select SOC_AR913X
+	select AR71XX_DEV_AR9XXX_WMAC
+	select AR71XX_DEV_GPIO_BUTTONS
+	select AR71XX_DEV_LEDS_GPIO
+	select AR71XX_DEV_USB
+
+config AR71XX_MACH_AP96
+	bool "Atheros AP96 board support"
+	select SOC_AR71XX
+	select AR71XX_DEV_M25P80
+	select AR71XX_DEV_AP94_PCI if PCI
+	select AR71XX_DEV_GPIO_BUTTONS
+	select AR71XX_DEV_LEDS_GPIO
+	select AR71XX_DEV_USB
+
+config AR71XX_MACH_AP121
+	bool "Atheros AP121 board support"
+	select AR71XX_DEV_M25P80
+	select AR71XX_DEV_GPIO_BUTTONS
+	select AR71XX_DEV_LEDS_GPIO
+	select AR71XX_DEV_USB
+	select AR71XX_DEV_AR9XXX_WMAC
+	select SOC_AR933X
+
+config AR71XX_MACH_DB120
+	bool "Atheros DB120 board support"
+	select SOC_AR934X
+	select AR71XX_DEV_AR9XXX_WMAC
+	select AR71XX_DEV_DB120_PCI if PCI
 	select AR71XX_DEV_GPIO_BUTTONS
 	select AR71XX_DEV_LEDS_GPIO
 	select AR71XX_DEV_USB
-	default n
 
 config AR71XX_MACH_DIR_600_A1
 	bool "D-Link DIR-600 rev. A1 support"
-	select AR71XX_DEV_AP91_ETH
+	select SOC_AR724X
 	select AR71XX_DEV_AP91_PCI if PCI
 	select AR71XX_DEV_M25P80
 	select AR71XX_DEV_GPIO_BUTTONS
 	select AR71XX_DEV_LEDS_GPIO
 	select AR71XX_NVRAM
-	default n
 
 config AR71XX_MACH_DIR_615_C1
 	bool "D-Link DIR-615 rev. C1 support"
+	select SOC_AR913X
 	select AR71XX_DEV_M25P80
-	select AR71XX_DEV_AR913X_WMAC
+	select AR71XX_DEV_AR9XXX_WMAC
 	select AR71XX_DEV_GPIO_BUTTONS
 	select AR71XX_DEV_LEDS_GPIO
 	select AR71XX_NVRAM
-	default n
 
 config AR71XX_MACH_DIR_825_B1
 	bool "D-Link DIR-825 rev. B1 board support"
+	select SOC_AR71XX
 	select AR71XX_DEV_M25P80
 	select AR71XX_DEV_AP94_PCI if PCI
 	select AR71XX_DEV_GPIO_BUTTONS
 	select AR71XX_DEV_LEDS_GPIO
 	select AR71XX_DEV_USB
-	default n
+
+config AR71XX_MACH_JA76PF
+	bool "jjPlus JA76PF board support"
+	select SOC_AR71XX
+	select AR71XX_DEV_M25P80
+	select AR71XX_DEV_GPIO_BUTTONS
+	select AR71XX_DEV_PB42_PCI if PCI
+	select AR71XX_DEV_LEDS_GPIO
+	select AR71XX_DEV_USB
+
+config AR71XX_MACH_JWAP003
+	bool "jjPlus JWAP003 board support"
+	select SOC_AR71XX
+	select AR71XX_DEV_M25P80
+	select AR71XX_DEV_GPIO_BUTTONS
+	select AR71XX_DEV_PB42_PCI if PCI
+	select AR71XX_DEV_USB
 
 config AR71XX_MACH_PB42
 	bool "Atheros PB42 board support"
+	select SOC_AR71XX
 	select AR71XX_DEV_M25P80
 	select AR71XX_DEV_GPIO_BUTTONS
 	select AR71XX_DEV_PB42_PCI if PCI
-	default n
 
 config AR71XX_MACH_PB44
 	bool "Atheros PB44 board support"
+	select SOC_AR71XX
 	select AR71XX_DEV_GPIO_BUTTONS
 	select AR71XX_DEV_PB42_PCI if PCI
 	select AR71XX_DEV_LEDS_GPIO
 	select AR71XX_DEV_USB
-	default n
 
 config AR71XX_MACH_PB92
 	bool "Atheros PB92 board support"
+	select SOC_AR724X
 	select AR71XX_DEV_GPIO_BUTTONS
 	select AR71XX_DEV_PB9X_PCI if PCI
 	select AR71XX_DEV_LEDS_GPIO
 	select AR71XX_DEV_USB
-	default n
 
 config AR71XX_MACH_AW_NR580
 	bool "AzureWave AW-NR580 board support"
+	select SOC_AR71XX
 	select AR71XX_DEV_M25P80
 	select AR71XX_DEV_GPIO_BUTTONS
 	select AR71XX_DEV_PB42_PCI if PCI
 	select AR71XX_DEV_LEDS_GPIO
-	default n
+
+config AR71XX_MACH_WZR_HP_AG300H
+	bool "Buffalo WZR-HP-AG300H board support"
+	select SOC_AR71XX
+	select AR71XX_DEV_M25P80
+	select AR71XX_DEV_GPIO_BUTTONS
+	select AR71XX_DEV_LEDS_GPIO
+	select AR71XX_DEV_USB
 
 config AR71XX_MACH_WZR_HP_G300NH
 	bool "Buffalo WZR-HP-G300NH board support"
-	select AR71XX_DEV_AR913X_WMAC
+	select SOC_AR913X
+	select AR71XX_DEV_AR9XXX_WMAC
 	select AR71XX_DEV_GPIO_BUTTONS
 	select AR71XX_DEV_LEDS_GPIO
 	select AR71XX_DEV_USB
-	default y
+	select RTL8366_SMI
+
+config AR71XX_MACH_WHR_HP_G300N
+	bool "Buffalo WHR-HP-G300N board support"
+	select SOC_AR724X
+	select AR71XX_DEV_M25P80
+	select AR71XX_DEV_AP91_PCI if PCI
+	select AR71XX_DEV_GPIO_BUTTONS
+	select AR71XX_DEV_LEDS_GPIO
 
 config AR71XX_MACH_WP543
 	bool "Compex WP543/WPJ543 board support"
+	select SOC_AR71XX
 	select MYLOADER
 	select AR71XX_DEV_M25P80
 	select AR71XX_DEV_GPIO_BUTTONS
 	select AR71XX_DEV_PB42_PCI if PCI
 	select AR71XX_DEV_LEDS_GPIO
 	select AR71XX_DEV_USB
-	default n
 
 config AR71XX_MACH_WRT160NL
 	bool "Linksys WRT160NL board support"
+	select SOC_AR913X
 	select AR71XX_DEV_M25P80
-	select AR71XX_DEV_AR913X_WMAC
+	select AR71XX_DEV_AR9XXX_WMAC
 	select AR71XX_DEV_GPIO_BUTTONS
 	select AR71XX_DEV_LEDS_GPIO
 	select AR71XX_DEV_USB
 	select AR71XX_NVRAM
-	default n
 
 config AR71XX_MACH_WRT400N
 	bool "Linksys WRT400N board support"
+	select SOC_AR71XX
 	select AR71XX_DEV_AP94_PCI if PCI
 	select AR71XX_DEV_M25P80
 	select AR71XX_DEV_GPIO_BUTTONS
 	select AR71XX_DEV_LEDS_GPIO
-	default n
 
 config AR71XX_MACH_RB4XX
 	bool "MikroTik RouterBOARD 4xx series support"
+	select SOC_AR71XX
 	select AR71XX_DEV_GPIO_BUTTONS
 	select AR71XX_DEV_LEDS_GPIO
 	select AR71XX_DEV_USB
-	default n
 
 config AR71XX_MACH_RB750
 	bool "MikroTik RouterBOARD 750 support"
-	select AR71XX_DEV_AP91_ETH
-	default n
+	select SOC_AR724X
 
 config AR71XX_MACH_WNDR3700
 	bool "NETGEAR WNDR3700 board support"
+	select SOC_AR71XX
 	select AR71XX_DEV_M25P80
 	select AR71XX_DEV_AP94_PCI if PCI
 	select AR71XX_DEV_GPIO_BUTTONS
 	select AR71XX_DEV_LEDS_GPIO
 	select AR71XX_DEV_USB
-	default n
 
 config AR71XX_MACH_WNR2000
 	bool "NETGEAR WNR2000 board support"
+	select SOC_AR913X
 	select AR71XX_DEV_M25P80
-	select AR71XX_DEV_AR913X_WMAC
+	select AR71XX_DEV_AR9XXX_WMAC
+	select AR71XX_DEV_GPIO_BUTTONS
+	select AR71XX_DEV_LEDS_GPIO
+
+config AR71XX_MACH_OM2P
+	bool "OpenMesh OM2P board support"
+	select SOC_AR724X
+	select AR71XX_DEV_M25P80
+	select AR71XX_DEV_AP91_PCI if PCI
 	select AR71XX_DEV_GPIO_BUTTONS
 	select AR71XX_DEV_LEDS_GPIO
-	default n
 
 config AR71XX_MACH_MZK_W04NU
 	bool "Planex MZK-W04NU board support"
+	select SOC_AR913X
 	select AR71XX_DEV_M25P80
-	select AR71XX_DEV_AR913X_WMAC
+	select AR71XX_DEV_AR9XXX_WMAC
 	select AR71XX_DEV_GPIO_BUTTONS
 	select AR71XX_DEV_LEDS_GPIO
 	select AR71XX_DEV_USB
-	default n
 
 config AR71XX_MACH_MZK_W300NH
 	bool "Planex MZK-W300NH board support"
+	select SOC_AR913X
 	select AR71XX_DEV_M25P80
-	select AR71XX_DEV_AR913X_WMAC
+	select AR71XX_DEV_AR9XXX_WMAC
 	select AR71XX_DEV_GPIO_BUTTONS
 	select AR71XX_DEV_LEDS_GPIO
-	default n
+
+config AR71XX_MACH_NBG460N
+	bool "Zyxel NBG460N/550N/550NH board support"
+	select SOC_AR913X
+	select AR71XX_DEV_M25P80
+	select AR71XX_DEV_AR9XXX_WMAC
+	select AR71XX_DEV_GPIO_BUTTONS
+	select AR71XX_DEV_LEDS_GPIO
+
+config AR71XX_MACH_TL_MR3X20
+	bool "TP-LINK TL-MR3220/3420 support"
+	select SOC_AR724X
+	select AR71XX_DEV_M25P80
+	select AR71XX_DEV_AP91_PCI if PCI
+	select AR71XX_DEV_GPIO_BUTTONS
+	select AR71XX_DEV_LEDS_GPIO
+	select AR71XX_DEV_USB
+
+config AR71XX_MACH_TL_WA901ND
+	bool "TP-LINK TL-WA901ND support"
+	select SOC_AR724X
+	select AR71XX_DEV_M25P80
+	select AR71XX_DEV_AP91_PCI if PCI
+	select AR71XX_DEV_GPIO_BUTTONS
+	select AR71XX_DEV_LEDS_GPIO
+
+config AR71XX_MACH_TL_WA901ND_V2
+	bool "TP-LINK TL-WA901ND v2 support"
+	select SOC_AR913X
+	select AR71XX_DEV_M25P80
+	select AR71XX_DEV_AR9XXX_WMAC
+	select AR71XX_DEV_GPIO_BUTTONS
+	select AR71XX_DEV_LEDS_GPIO
+
+config AR71XX_MACH_TL_WR703N
+	bool "TP-LINK TL-WR703N support"
+	select SOC_AR933X
+	select AR71XX_DEV_M25P80
+	select AR71XX_DEV_GPIO_BUTTONS
+	select AR71XX_DEV_LEDS_GPIO
+	select AR71XX_DEV_USB
+	select AR71XX_DEV_AR9XXX_WMAC
 
 config AR71XX_MACH_TL_WR741ND
 	bool "TP-LINK TL-WR741ND support"
+	select SOC_AR724X
 	select AR71XX_DEV_M25P80
 	select AR71XX_DEV_AP91_PCI if PCI
 	select AR71XX_DEV_GPIO_BUTTONS
 	select AR71XX_DEV_LEDS_GPIO
-	default n
+
+config AR71XX_MACH_TL_WR741ND_V4
+	bool "TP-LINK TL-WR741ND v4 support"
+	select SOC_AR933X
+	select AR71XX_DEV_M25P80
+	select AR71XX_DEV_GPIO_BUTTONS
+	select AR71XX_DEV_LEDS_GPIO
+	select AR71XX_DEV_AR9XXX_WMAC
 
 config AR71XX_MACH_TL_WR841N_V1
 	bool "TP-LINK TL-WR841N v1 support"
+	select SOC_AR71XX
 	select AR71XX_DEV_M25P80
 	select AR71XX_DEV_PB42_PCI if PCI
 	select AR71XX_DEV_DSA
 	select AR71XX_DEV_GPIO_BUTTONS
 	select AR71XX_DEV_LEDS_GPIO
-	default n
 
 config AR71XX_MACH_TL_WR941ND
 	bool "TP-LINK TL-WR941ND support"
+	select SOC_AR913X
 	select AR71XX_DEV_M25P80
-	select AR71XX_DEV_AR913X_WMAC
+	select AR71XX_DEV_AR9XXX_WMAC
 	select AR71XX_DEV_DSA
 	select AR71XX_DEV_GPIO_BUTTONS
 	select AR71XX_DEV_LEDS_GPIO
-	default n
 
 config AR71XX_MACH_TL_WR1043ND
 	bool "TP-LINK TL-WR1043ND support"
+	select SOC_AR913X
 	select AR71XX_DEV_M25P80
-	select AR71XX_DEV_AR913X_WMAC
+	select AR71XX_DEV_AR9XXX_WMAC
 	select AR71XX_DEV_GPIO_BUTTONS
 	select AR71XX_DEV_LEDS_GPIO
 	select AR71XX_DEV_USB
-	default n
 
 config AR71XX_MACH_TEW_632BRP
 	bool "TRENDnet TEW-632BRP support"
+	select SOC_AR913X
 	select AR71XX_DEV_M25P80
-	select AR71XX_DEV_AR913X_WMAC
+	select AR71XX_DEV_AR9XXX_WMAC
 	select AR71XX_DEV_GPIO_BUTTONS
 	select AR71XX_DEV_LEDS_GPIO
 	select AR71XX_NVRAM
-	default n
 
 config AR71XX_MACH_UBNT
 	bool "Ubiquiti AR71xx based boards support"
+	select SOC_AR71XX
+	select SOC_AR724X
 	select AR71XX_DEV_M25P80
 	select AR71XX_DEV_AP91_PCI if PCI
 	select AR71XX_DEV_GPIO_BUTTONS
 	select AR71XX_DEV_LEDS_GPIO
 	select AR71XX_DEV_PB42_PCI if PCI
 	select AR71XX_DEV_USB
-	default n
+
+config AR71XX_MACH_EAP7660D
+	bool "Senao EAP7660D support"
+	select SOC_AR71XX
+	select AR71XX_DEV_M25P80
+	select AR71XX_DEV_GPIO_BUTTONS
+	select AR71XX_DEV_LEDS_GPIO
+
+config AR71XX_MACH_ZCN_1523H
+	bool "Zcomax ZCN-1523H support"
+	select SOC_AR724X
+	select AR71XX_DEV_M25P80
+	select AR71XX_DEV_AP91_PCI if PCI
+	select AR71XX_DEV_GPIO_BUTTONS
+	select AR71XX_DEV_LEDS_GPIO
 
 endmenu
 
+config SOC_AR71XX
+	bool
+	select USB_ARCH_HAS_EHCI
+	select USB_ARCH_HAS_OHCI
+
+config SOC_AR724X
+	bool
+	select USB_ARCH_HAS_EHCI
+	select USB_ARCH_HAS_OHCI
+
+config SOC_AR913X
+	bool
+	select USB_ARCH_HAS_EHCI
+
+config SOC_AR934X
+	bool
+	select USB_ARCH_HAS_EHCI
+
 config AR71XX_DEV_M25P80
 	def_bool n
 
 config AR71XX_DEV_AP91_PCI
+	select AR71XX_PCI_ATH9K_FIXUP
 	def_bool n
 
-config AR71XX_DEV_AP91_ETH
-	select AR71XX_DEV_DSA
+config AR71XX_DEV_AP94_PCI
+	select AR71XX_PCI_ATH9K_FIXUP
 	def_bool n
 
-config AR71XX_DEV_AP94_PCI
+config AR71XX_DEV_AR9XXX_WMAC
 	def_bool n
 
-config AR71XX_DEV_AR913X_WMAC
+config AR71XX_DEV_DB120_PCI
+	select AR71XX_PCI_ATH9K_FIXUP
 	def_bool n
 
 config AR71XX_DEV_DSA
@@ -253,4 +413,11 @@ config AR71XX_DEV_USB
 config AR71XX_NVRAM
 	def_bool n
 
+config AR71XX_PCI_ATH9K_FIXUP
+	def_bool n
+
+config SOC_AR933X
+	bool
+	select USB_ARCH_HAS_EHCI
+
 endif
diff --git a/arch/mips/ar71xx/Makefile b/arch/mips/ar71xx/Makefile
index e24df57..d64a4ea 100644
--- a/arch/mips/ar71xx/Makefile
+++ b/arch/mips/ar71xx/Makefile
@@ -13,10 +13,10 @@ obj-y	:= prom.o irq.o setup.o devices.o gpio.o ar71xx.o
 obj-$(CONFIG_EARLY_PRINTK)		+= early_printk.o
 obj-$(CONFIG_PCI)			+= pci.o
 
-obj-$(CONFIG_AR71XX_DEV_AP91_ETH)	+= dev-ap91-eth.o
 obj-$(CONFIG_AR71XX_DEV_AP91_PCI)	+= dev-ap91-pci.o
 obj-$(CONFIG_AR71XX_DEV_AP94_PCI)	+= dev-ap94-pci.o
-obj-$(CONFIG_AR71XX_DEV_AR913X_WMAC)	+= dev-ar913x-wmac.o
+obj-$(CONFIG_AR71XX_DEV_AR9XXX_WMAC)	+= dev-ar9xxx-wmac.o
+obj-$(CONFIG_AR71XX_DEV_DB120_PCI)	+= dev-db120-pci.o
 obj-$(CONFIG_AR71XX_DEV_DSA)		+= dev-dsa.o
 obj-$(CONFIG_AR71XX_DEV_GPIO_BUTTONS)	+= dev-gpio-buttons.o
 obj-$(CONFIG_AR71XX_DEV_LEDS_GPIO)	+= dev-leds-gpio.o
@@ -26,29 +26,47 @@ obj-$(CONFIG_AR71XX_DEV_PB9X_PCI)	+= dev-pb9x-pci.o
 obj-$(CONFIG_AR71XX_DEV_USB)		+= dev-usb.o
 
 obj-$(CONFIG_AR71XX_NVRAM)		+= nvram.o
+obj-$(CONFIG_AR71XX_PCI_ATH9K_FIXUP)	+= pci-ath9k-fixup.o
 
+obj-$(CONFIG_AR71XX_MACH_ALL0258N)	+= mach-all0258n.o
+obj-$(CONFIG_AR71XX_MACH_AP121)		+= mach-ap121.o
 obj-$(CONFIG_AR71XX_MACH_AP81)		+= mach-ap81.o
 obj-$(CONFIG_AR71XX_MACH_AP83)		+= mach-ap83.o
+obj-$(CONFIG_AR71XX_MACH_AP96)		+= mach-ap96.o
 obj-$(CONFIG_AR71XX_MACH_AW_NR580)	+= mach-aw-nr580.o
+obj-$(CONFIG_AR71XX_MACH_DB120)		+= mach-db120.o
 obj-$(CONFIG_AR71XX_MACH_DIR_600_A1)	+= mach-dir-600-a1.o
 obj-$(CONFIG_AR71XX_MACH_DIR_615_C1)	+= mach-dir-615-c1.o
 obj-$(CONFIG_AR71XX_MACH_DIR_825_B1)	+= mach-dir-825-b1.o
+obj-$(CONFIG_AR71XX_MACH_EAP7660D)	+= mach-eap7660d.o
+obj-$(CONFIG_AR71XX_MACH_JA76PF)	+= mach-ja76pf.o
+obj-$(CONFIG_AR71XX_MACH_JWAP003)	+= mach-jwap003.o
 obj-$(CONFIG_AR71XX_MACH_MZK_W04NU)	+= mach-mzk-w04nu.o
 obj-$(CONFIG_AR71XX_MACH_MZK_W300NH)	+= mach-mzk-w300nh.o
+obj-$(CONFIG_AR71XX_MACH_NBG460N)	+= mach-nbg460n.o
+obj-$(CONFIG_AR71XX_MACH_OM2P)		+= mach-om2p.o
 obj-$(CONFIG_AR71XX_MACH_PB42)		+= mach-pb42.o
 obj-$(CONFIG_AR71XX_MACH_PB44)		+= mach-pb44.o
 obj-$(CONFIG_AR71XX_MACH_PB92)		+= mach-pb92.o
 obj-$(CONFIG_AR71XX_MACH_RB4XX)		+= mach-rb4xx.o
 obj-$(CONFIG_AR71XX_MACH_RB750)		+= mach-rb750.o
 obj-$(CONFIG_AR71XX_MACH_TEW_632BRP)	+= mach-tew-632brp.o
+obj-$(CONFIG_AR71XX_MACH_TL_MR3X20)	+= mach-tl-mr3x20.o
+obj-$(CONFIG_AR71XX_MACH_TL_WA901ND)	+= mach-tl-wa901nd.o
+obj-$(CONFIG_AR71XX_MACH_TL_WA901ND_V2)	+= mach-tl-wa901nd-v2.o
 obj-$(CONFIG_AR71XX_MACH_TL_WR741ND)	+= mach-tl-wr741nd.o
+obj-$(CONFIG_AR71XX_MACH_TL_WR741ND_V4)	+= mach-tl-wr741nd-v4.o
 obj-$(CONFIG_AR71XX_MACH_TL_WR841N_V1)	+= mach-tl-wr841n.o
 obj-$(CONFIG_AR71XX_MACH_TL_WR941ND)	+= mach-tl-wr941nd.o
 obj-$(CONFIG_AR71XX_MACH_TL_WR1043ND)	+= mach-tl-wr1043nd.o
+obj-$(CONFIG_AR71XX_MACH_TL_WR703N)	+= mach-tl-wr703n.o
 obj-$(CONFIG_AR71XX_MACH_UBNT)		+= mach-ubnt.o
+obj-$(CONFIG_AR71XX_MACH_WHR_HP_G300N)	+= mach-whr-hp-g300n.o
 obj-$(CONFIG_AR71XX_MACH_WNDR3700)	+= mach-wndr3700.o
 obj-$(CONFIG_AR71XX_MACH_WNR2000)	+= mach-wnr2000.o
 obj-$(CONFIG_AR71XX_MACH_WP543)		+= mach-wp543.o
 obj-$(CONFIG_AR71XX_MACH_WRT160NL)	+= mach-wrt160nl.o
 obj-$(CONFIG_AR71XX_MACH_WRT400N)	+= mach-wrt400n.o
 obj-$(CONFIG_AR71XX_MACH_WZR_HP_G300NH)	+= mach-wzr-hp-g300nh.o
+obj-$(CONFIG_AR71XX_MACH_WZR_HP_AG300H)	+= mach-wzr-hp-ag300h.o
+obj-$(CONFIG_AR71XX_MACH_ZCN_1523H)	+= mach-zcn-1523h.o
diff --git a/arch/mips/ar71xx/ar71xx.c b/arch/mips/ar71xx/ar71xx.c
index 5d05562..93cbe53 100644
--- a/arch/mips/ar71xx/ar71xx.c
+++ b/arch/mips/ar71xx/ar71xx.c
@@ -13,10 +13,12 @@
 #include <linux/module.h>
 #include <linux/types.h>
 #include <linux/mutex.h>
+#include <linux/spinlock.h>
 
 #include <asm/mach-ar71xx/ar71xx.h>
 
 static DEFINE_MUTEX(ar71xx_flash_mutex);
+static DEFINE_SPINLOCK(ar71xx_device_lock);
 
 void __iomem *ar71xx_ddr_base;
 EXPORT_SYMBOL_GPL(ar71xx_ddr_base);
@@ -43,30 +45,47 @@ void ar71xx_device_stop(u32 mask)
 	case AR71XX_SOC_AR7130:
 	case AR71XX_SOC_AR7141:
 	case AR71XX_SOC_AR7161:
-		local_irq_save(flags);
+		spin_lock_irqsave(&ar71xx_device_lock, flags);
 		t = ar71xx_reset_rr(AR71XX_RESET_REG_RESET_MODULE);
 		ar71xx_reset_wr(AR71XX_RESET_REG_RESET_MODULE, t | mask);
-		local_irq_restore(flags);
+		spin_unlock_irqrestore(&ar71xx_device_lock, flags);
 		break;
 
 	case AR71XX_SOC_AR7240:
 	case AR71XX_SOC_AR7241:
 	case AR71XX_SOC_AR7242:
 		mask_inv = mask & RESET_MODULE_USB_OHCI_DLL_7240;
-		local_irq_save(flags);
+		spin_lock_irqsave(&ar71xx_device_lock, flags);
 		t = ar71xx_reset_rr(AR724X_RESET_REG_RESET_MODULE);
 		t |= mask;
 		t &= ~mask_inv;
 		ar71xx_reset_wr(AR724X_RESET_REG_RESET_MODULE, t);
-		local_irq_restore(flags);
+		spin_unlock_irqrestore(&ar71xx_device_lock, flags);
 		break;
 
 	case AR71XX_SOC_AR9130:
 	case AR71XX_SOC_AR9132:
-		local_irq_save(flags);
+		spin_lock_irqsave(&ar71xx_device_lock, flags);
 		t = ar71xx_reset_rr(AR91XX_RESET_REG_RESET_MODULE);
 		ar71xx_reset_wr(AR91XX_RESET_REG_RESET_MODULE, t | mask);
-		local_irq_restore(flags);
+		spin_unlock_irqrestore(&ar71xx_device_lock, flags);
+		break;
+
+	case AR71XX_SOC_AR9330:
+	case AR71XX_SOC_AR9331:
+		spin_lock_irqsave(&ar71xx_device_lock, flags);
+		t = ar71xx_reset_rr(AR933X_RESET_REG_RESET_MODULE);
+		ar71xx_reset_wr(AR933X_RESET_REG_RESET_MODULE, t | mask);
+		spin_unlock_irqrestore(&ar71xx_device_lock, flags);
+		break;
+
+	case AR71XX_SOC_AR9341:
+	case AR71XX_SOC_AR9342:
+	case AR71XX_SOC_AR9344:
+		spin_lock_irqsave(&ar71xx_device_lock, flags);
+		t = ar71xx_reset_rr(AR934X_RESET_REG_RESET_MODULE);
+		ar71xx_reset_wr(AR934X_RESET_REG_RESET_MODULE, t | mask);
+		spin_unlock_irqrestore(&ar71xx_device_lock, flags);
 		break;
 
 	default:
@@ -85,30 +104,47 @@ void ar71xx_device_start(u32 mask)
 	case AR71XX_SOC_AR7130:
 	case AR71XX_SOC_AR7141:
 	case AR71XX_SOC_AR7161:
-		local_irq_save(flags);
+		spin_lock_irqsave(&ar71xx_device_lock, flags);
 		t = ar71xx_reset_rr(AR71XX_RESET_REG_RESET_MODULE);
 		ar71xx_reset_wr(AR71XX_RESET_REG_RESET_MODULE, t & ~mask);
-		local_irq_restore(flags);
+		spin_unlock_irqrestore(&ar71xx_device_lock, flags);
 		break;
 
 	case AR71XX_SOC_AR7240:
 	case AR71XX_SOC_AR7241:
 	case AR71XX_SOC_AR7242:
 		mask_inv = mask & RESET_MODULE_USB_OHCI_DLL_7240;
-		local_irq_save(flags);
+		spin_lock_irqsave(&ar71xx_device_lock, flags);
 		t = ar71xx_reset_rr(AR724X_RESET_REG_RESET_MODULE);
 		t &= ~mask;
 		t |= mask_inv;
 		ar71xx_reset_wr(AR724X_RESET_REG_RESET_MODULE, t);
-		local_irq_restore(flags);
+		spin_unlock_irqrestore(&ar71xx_device_lock, flags);
 		break;
 
 	case AR71XX_SOC_AR9130:
 	case AR71XX_SOC_AR9132:
-		local_irq_save(flags);
+		spin_lock_irqsave(&ar71xx_device_lock, flags);
 		t = ar71xx_reset_rr(AR91XX_RESET_REG_RESET_MODULE);
 		ar71xx_reset_wr(AR91XX_RESET_REG_RESET_MODULE, t & ~mask);
-		local_irq_restore(flags);
+		spin_unlock_irqrestore(&ar71xx_device_lock, flags);
+		break;
+
+	case AR71XX_SOC_AR9330:
+	case AR71XX_SOC_AR9331:
+		spin_lock_irqsave(&ar71xx_device_lock, flags);
+		t = ar71xx_reset_rr(AR933X_RESET_REG_RESET_MODULE);
+		ar71xx_reset_wr(AR933X_RESET_REG_RESET_MODULE, t & ~mask);
+		spin_unlock_irqrestore(&ar71xx_device_lock, flags);
+		break;
+
+	case AR71XX_SOC_AR9341:
+	case AR71XX_SOC_AR9342:
+	case AR71XX_SOC_AR9344:
+		spin_lock_irqsave(&ar71xx_device_lock, flags);
+		t = ar71xx_reset_rr(AR934X_RESET_REG_RESET_MODULE);
+		ar71xx_reset_wr(AR934X_RESET_REG_RESET_MODULE, t & ~mask);
+		spin_unlock_irqrestore(&ar71xx_device_lock, flags);
 		break;
 
 	default:
@@ -117,6 +153,54 @@ void ar71xx_device_start(u32 mask)
 }
 EXPORT_SYMBOL_GPL(ar71xx_device_start);
 
+void ar71xx_device_reset_rmw(u32 clear, u32 set)
+{
+	unsigned long flags;
+	unsigned int reg;
+	u32 t;
+
+	switch (ar71xx_soc) {
+	case AR71XX_SOC_AR7130:
+	case AR71XX_SOC_AR7141:
+	case AR71XX_SOC_AR7161:
+		reg = AR71XX_RESET_REG_RESET_MODULE;
+		break;
+
+	case AR71XX_SOC_AR7240:
+	case AR71XX_SOC_AR7241:
+	case AR71XX_SOC_AR7242:
+		reg = AR724X_RESET_REG_RESET_MODULE;
+		break;
+
+	case AR71XX_SOC_AR9130:
+	case AR71XX_SOC_AR9132:
+		reg = AR91XX_RESET_REG_RESET_MODULE;
+		break;
+
+	case AR71XX_SOC_AR9330:
+	case AR71XX_SOC_AR9331:
+		reg = AR933X_RESET_REG_RESET_MODULE;
+		break;
+
+	case AR71XX_SOC_AR9341:
+	case AR71XX_SOC_AR9342:
+	case AR71XX_SOC_AR9344:
+		reg = AR934X_RESET_REG_RESET_MODULE;
+		break;
+
+	default:
+		BUG();
+	}
+
+	spin_lock_irqsave(&ar71xx_device_lock, flags);
+	t = ar71xx_reset_rr(reg);
+	t &= ~clear;
+	t |= set;
+	ar71xx_reset_wr(reg, t);
+	spin_unlock_irqrestore(&ar71xx_device_lock, flags);
+}
+EXPORT_SYMBOL_GPL(ar71xx_device_reset_rmw);
+
 int ar71xx_device_stopped(u32 mask)
 {
 	unsigned long flags;
@@ -126,24 +210,39 @@ int ar71xx_device_stopped(u32 mask)
 	case AR71XX_SOC_AR7130:
 	case AR71XX_SOC_AR7141:
 	case AR71XX_SOC_AR7161:
-		local_irq_save(flags);
+		spin_lock_irqsave(&ar71xx_device_lock, flags);
 		t = ar71xx_reset_rr(AR71XX_RESET_REG_RESET_MODULE);
-		local_irq_restore(flags);
+		spin_unlock_irqrestore(&ar71xx_device_lock, flags);
 		break;
 
 	case AR71XX_SOC_AR7240:
 	case AR71XX_SOC_AR7241:
 	case AR71XX_SOC_AR7242:
-		local_irq_save(flags);
+		spin_lock_irqsave(&ar71xx_device_lock, flags);
 		t = ar71xx_reset_rr(AR724X_RESET_REG_RESET_MODULE);
-		local_irq_restore(flags);
+		spin_unlock_irqrestore(&ar71xx_device_lock, flags);
 		break;
 
 	case AR71XX_SOC_AR9130:
 	case AR71XX_SOC_AR9132:
-		local_irq_save(flags);
+		spin_lock_irqsave(&ar71xx_device_lock, flags);
 		t = ar71xx_reset_rr(AR91XX_RESET_REG_RESET_MODULE);
-		local_irq_restore(flags);
+		spin_unlock_irqrestore(&ar71xx_device_lock, flags);
+		break;
+
+	case AR71XX_SOC_AR9330:
+	case AR71XX_SOC_AR9331:
+		spin_lock_irqsave(&ar71xx_device_lock, flags);
+		t = ar71xx_reset_rr(AR933X_RESET_REG_RESET_MODULE);
+		spin_unlock_irqrestore(&ar71xx_device_lock, flags);
+		break;
+
+	case AR71XX_SOC_AR9341:
+	case AR71XX_SOC_AR9342:
+	case AR71XX_SOC_AR9344:
+		spin_lock_irqsave(&ar71xx_device_lock, flags);
+		t = ar71xx_reset_rr(AR934X_RESET_REG_RESET_MODULE);
+		spin_unlock_irqrestore(&ar71xx_device_lock, flags);
 		break;
 
 	default:
@@ -157,10 +256,12 @@ EXPORT_SYMBOL_GPL(ar71xx_device_stopped);
 void ar71xx_ddr_flush(u32 reg)
 {
 	ar71xx_ddr_wr(reg, 1);
-	while ((ar71xx_ddr_rr(reg) & 0x1));
+	while ((ar71xx_ddr_rr(reg) & 0x1))
+		;
 
 	ar71xx_ddr_wr(reg, 1);
-	while ((ar71xx_ddr_rr(reg) & 0x1));
+	while ((ar71xx_ddr_rr(reg) & 0x1))
+		;
 }
 EXPORT_SYMBOL_GPL(ar71xx_ddr_flush);
 
diff --git a/arch/mips/ar71xx/dev-ap91-eth.c b/arch/mips/ar71xx/dev-ap91-eth.c
deleted file mode 100644
index c48af45c..0000000
--- a/arch/mips/ar71xx/dev-ap91-eth.c
+++ /dev/null
@@ -1,70 +0,0 @@
-/*
- *  Atheros AP91 reference board ethernet initialization
- *
- *  Copyright (C) 2010 Gabor Juhos <juhosg@openwrt.org>
- *
- *  This program is free software; you can redistribute it and/or modify it
- *  under the terms of the GNU General Public License version 2 as published
- *  by the Free Software Foundation.
- */
-
-#include "devices.h"
-#include "dev-dsa.h"
-#include "dev-ap91-eth.h"
-
-static struct dsa_chip_data ap91_dsa_chip = {
-	.port_names[0]  = "cpu",
-	.port_names[1]  = "lan1",
-	.port_names[2]  = "lan2",
-	.port_names[3]  = "lan3",
-	.port_names[4]  = "lan4",
-};
-
-static struct dsa_platform_data ap91_dsa_data = {
-	.nr_chips	= 1,
-	.chip		= &ap91_dsa_chip,
-};
-
-static void ap91_eth_set_port_name(unsigned port, const char *name)
-{
-	if (port < 1 || port > 5)
-		return;
-
-	if (name)
-		ap91_dsa_chip.port_names[port] = (char *) name;
-}
-
-void __init ap91_eth_init(u8 *mac_addr, const char *port_names[])
-{
-	if (mac_addr)
-		ar71xx_set_mac_base(mac_addr);
-
-	if (port_names) {
-		int i;
-
-		for (i = 0; i < AP91_ETH_NUM_PORT_NAMES; i++)
-			ap91_eth_set_port_name(i + 1, port_names[i]);
-	}
-
-	/* WAN port */
-	ar71xx_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
-	ar71xx_eth0_data.speed = SPEED_100;
-	ar71xx_eth0_data.duplex = DUPLEX_FULL;
-	ar71xx_eth0_data.fifo_cfg1 = 0x0fff0000;
-	ar71xx_eth0_data.fifo_cfg2 = 0x00001fff;
-	ar71xx_eth0_data.fifo_cfg3 = 0x008001ff;
-
-	/* LAN ports */
-	ar71xx_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
-	ar71xx_eth1_data.speed = SPEED_1000;
-	ar71xx_eth1_data.duplex = DUPLEX_FULL;
-	ar71xx_eth1_data.fifo_cfg1 = 0x0fff0000;
-	ar71xx_eth1_data.fifo_cfg2 = 0x00001fff;
-	ar71xx_eth1_data.fifo_cfg3 = 0x008001ff;
-
-	ar71xx_add_device_mdio(0x0);
-	ar71xx_add_device_eth(1);
-	ar71xx_add_device_eth(0);
-
-	ar71xx_add_device_dsa(1, &ap91_dsa_data);
-}
diff --git a/arch/mips/ar71xx/dev-ap91-eth.h b/arch/mips/ar71xx/dev-ap91-eth.h
deleted file mode 100644
index d9cd214..0000000
--- a/arch/mips/ar71xx/dev-ap91-eth.h
+++ /dev/null
@@ -1,23 +0,0 @@
-/*
- *  Atheros AP91 reference board ethernet initialization
- *
- *  Copyright (C) 2010 Gabor Juhos <juhosg@openwrt.org>
- *
- *  This program is free software; you can redistribute it and/or modify it
- *  under the terms of the GNU General Public License version 2 as published
- *  by the Free Software Foundation.
- */
-
-#ifndef _AR71XX_DEV_AP91_ETH_H
-#define _AR71XX_DEV_AP91_ETH_H
-
-#define AP91_ETH_NUM_PORT_NAMES	4
-
-#if defined(CONFIG_AR71XX_DEV_AP91_ETH)
-void ap91_eth_init(u8 *mac_addr, const char *port_names[]) __init;
-#else
-static inline void ap91_eth_init(u8 *mac_addr) { }
-#endif
-
-#endif /* _AR71XX_DEV_AP91_ETH_H */
-
diff --git a/arch/mips/ar71xx/dev-ap91-pci.c b/arch/mips/ar71xx/dev-ap91-pci.c
index e81a01a..2b75f7b 100644
--- a/arch/mips/ar71xx/dev-ap91-pci.c
+++ b/arch/mips/ar71xx/dev-ap91-pci.c
@@ -16,10 +16,12 @@
 #include <asm/mach-ar71xx/pci.h>
 
 #include "dev-ap91-pci.h"
+#include "pci-ath9k-fixup.h"
 
-static struct ath9k_platform_data ap91_wmac_data;
+static struct ath9k_platform_data ap91_wmac_data = {
+	.led_pin = -1,
+};
 static char ap91_wmac_mac[6];
-static int ap91_pci_fixup_enabled;
 
 static struct ar71xx_pci_irq ap91_pci_irqs[] __initdata = {
 	{
@@ -31,7 +33,7 @@ static struct ar71xx_pci_irq ap91_pci_irqs[] __initdata = {
 
 static int ap91_pci_plat_dev_init(struct pci_dev *dev)
 {
-	switch(PCI_SLOT(dev->devfn)) {
+	switch (PCI_SLOT(dev->devfn)) {
 	case 0:
 		dev->dev.platform_data = &ap91_wmac_data;
 		break;
@@ -40,61 +42,16 @@ static int ap91_pci_plat_dev_init(struct pci_dev *dev)
 	return 0;
 }
 
-static void ap91_pci_fixup(struct pci_dev *dev)
+__init void ap91_pci_setup_wmac_led_pin(int pin)
 {
-	void __iomem *mem;
-	u16 *cal_data;
-	u16 cmd;
-	u32 val;
-
-	if (!ap91_pci_fixup_enabled)
-		return;
-
-	printk(KERN_INFO "PCI: fixup device %s\n", pci_name(dev));
-
-	cal_data = ap91_wmac_data.eeprom_data;
-	if (*cal_data != 0xa55a) {
-		printk(KERN_ERR "PCI: no calibration data found for %s\n",
-		       pci_name(dev));
-		return;
-	}
-
-	mem = ioremap(AR71XX_PCI_MEM_BASE, 0x10000);
-	if (!mem) {
-		printk(KERN_ERR "PCI: ioremap error for device %s\n",
-		       pci_name(dev));
-		return;
-	}
-
-	/* Setup the PCI device to allow access to the internal registers */
-	pci_write_config_dword(dev, PCI_BASE_ADDRESS_0, 0xffff);
-	pci_read_config_word(dev, PCI_COMMAND, &cmd);
-	cmd |= PCI_COMMAND_MASTER | PCI_COMMAND_MEMORY;
-	pci_write_config_word(dev, PCI_COMMAND, cmd);
-
-        /* set pointer to first reg address */
-	cal_data += 3;
-	while (*cal_data != 0xffff) {
-		u32 reg;
-		reg = *cal_data++;
-		val = *cal_data++;
-		val |= (*cal_data++) << 16;
-
-		__raw_writel(val, mem + reg);
-		udelay(100);
-	}
-
-	pci_read_config_dword(dev, PCI_VENDOR_ID, &val);
-	dev->vendor = val & 0xffff;
-	dev->device = (val >> 16) & 0xffff;
-
-	pci_read_config_dword(dev, PCI_CLASS_REVISION, &val);
-	dev->revision = val & 0xff;
-	dev->class = val >> 8; /* upper 3 bytes */
+	ap91_wmac_data.led_pin = pin;
+}
 
-	iounmap(mem);
+__init void ap91_pci_setup_wmac_gpio(u32 mask, u32 val)
+{
+	ap91_wmac_data.gpio_mask = mask;
+	ap91_wmac_data.gpio_val = val;
 }
-DECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_ATHEROS, PCI_ANY_ID, ap91_pci_fixup);
 
 void __init ap91_pci_init(u8 *cal_data, u8 *mac_addr)
 {
@@ -110,5 +67,5 @@ void __init ap91_pci_init(u8 *cal_data, u8 *mac_addr)
 	ar71xx_pci_plat_dev_init = ap91_pci_plat_dev_init;
 	ar71xx_pci_init(ARRAY_SIZE(ap91_pci_irqs), ap91_pci_irqs);
 
-	ap91_pci_fixup_enabled = 1;
+	pci_enable_ath9k_fixup(0, ap91_wmac_data.eeprom_data);
 }
diff --git a/arch/mips/ar71xx/dev-ap91-pci.h b/arch/mips/ar71xx/dev-ap91-pci.h
index d6f2e52..e471083 100644
--- a/arch/mips/ar71xx/dev-ap91-pci.h
+++ b/arch/mips/ar71xx/dev-ap91-pci.h
@@ -13,8 +13,12 @@
 
 #if defined(CONFIG_AR71XX_DEV_AP91_PCI)
 void ap91_pci_init(u8 *cal_data, u8 *mac_addr) __init;
+void ap91_pci_setup_wmac_led_pin(int pin) __init;
+void ap91_pci_setup_wmac_gpio(u32 mask, u32 val) __init;
 #else
 static inline void ap91_pci_init(u8 *cal_data, u8 *mac_addr) { }
+static inline void ap91_pci_setup_wmac_led_pin(int pin) { }
+static inline void ap91_pci_setup_wmac_gpio(u32 mask, u32 gpio) { }
 #endif
 
 #endif /* _AR71XX_DEV_AP91_PCI_H */
diff --git a/arch/mips/ar71xx/dev-ap94-pci.c b/arch/mips/ar71xx/dev-ap94-pci.c
index bfa668f..05b5be4 100644
--- a/arch/mips/ar71xx/dev-ap94-pci.c
+++ b/arch/mips/ar71xx/dev-ap94-pci.c
@@ -16,28 +16,32 @@
 #include <asm/mach-ar71xx/pci.h>
 
 #include "dev-ap94-pci.h"
+#include "pci-ath9k-fixup.h"
 
-static struct ath9k_platform_data ap94_wmac0_data;
-static struct ath9k_platform_data ap94_wmac1_data;
+static struct ath9k_platform_data ap94_wmac0_data = {
+	.led_pin = -1,
+};
+static struct ath9k_platform_data ap94_wmac1_data = {
+	.led_pin = -1,
+};
 static char ap94_wmac0_mac[6];
 static char ap94_wmac1_mac[6];
-static int ap94_pci_fixup_enabled;
 
 static struct ar71xx_pci_irq ap94_pci_irqs[] __initdata = {
-        {
-                .slot   = 0,
-                .pin    = 1,
-                .irq    = AR71XX_PCI_IRQ_DEV0,
-        }, {
-                .slot   = 1,
-                .pin    = 1,
-                .irq    = AR71XX_PCI_IRQ_DEV1,
-        }
+	{
+		.slot   = 0,
+		.pin    = 1,
+		.irq    = AR71XX_PCI_IRQ_DEV0,
+	}, {
+		.slot   = 1,
+		.pin    = 1,
+		.irq    = AR71XX_PCI_IRQ_DEV1,
+	}
 };
 
 static int ap94_pci_plat_dev_init(struct pci_dev *dev)
 {
-	switch(PCI_SLOT(dev->devfn)) {
+	switch (PCI_SLOT(dev->devfn)) {
 	case 17:
 		dev->dev.platform_data = &ap94_wmac0_data;
 		break;
@@ -50,85 +54,30 @@ static int ap94_pci_plat_dev_init(struct pci_dev *dev)
 	return 0;
 }
 
-static void ap94_pci_fixup(struct pci_dev *dev)
+__init void ap94_pci_setup_wmac_led_pin(unsigned wmac, int pin)
 {
-	void __iomem *mem;
-	u16 *cal_data;
-	u16 cmd;
-	u32 bar0;
-	u32 val;
-
-	if (!ap94_pci_fixup_enabled)
-		return;
-
-	switch (PCI_SLOT(dev->devfn)) {
-	case 17:
-		cal_data = ap94_wmac0_data.eeprom_data;
+	switch (wmac) {
+	case 0:
+		ap94_wmac0_data.led_pin = pin;
 		break;
-	case 18:
-		cal_data = ap94_wmac1_data.eeprom_data;
+	case 1:
+		ap94_wmac1_data.led_pin = pin;
 		break;
-	default:
-		return;
-	}
-
-	if (*cal_data != 0xa55a) {
-		printk(KERN_ERR "PCI: no calibration data found for %s\n",
-		       pci_name(dev));
-		return;
 	}
-
-	mem = ioremap(AR71XX_PCI_MEM_BASE, 0x10000);
-	if (!mem) {
-		printk(KERN_ERR "PCI: ioremap error for device %s\n",
-		       pci_name(dev));
-		return;
-	}
-
-	printk(KERN_INFO "PCI: fixup device %s\n", pci_name(dev));
-
-	pci_read_config_dword(dev, PCI_BASE_ADDRESS_0, &bar0);
-
-	/* Setup the PCI device to allow access to the internal registers */
-	pci_write_config_dword(dev, PCI_BASE_ADDRESS_0, AR71XX_PCI_MEM_BASE);
-	pci_read_config_word(dev, PCI_COMMAND, &cmd);
-	cmd |= PCI_COMMAND_MASTER | PCI_COMMAND_MEMORY;
-	pci_write_config_word(dev, PCI_COMMAND, cmd);
-
-	/* set pointer to first reg address */
-	cal_data += 3;
-	while (*cal_data != 0xffff) {
-		u32 reg;
-		reg = *cal_data++;
-		val = *cal_data++;
-		val |= (*cal_data++) << 16;
-
-		__raw_writel(val, mem + reg);
-		udelay(100);
-	}
-
-	pci_read_config_dword(dev, PCI_VENDOR_ID, &val);
-	dev->vendor = val & 0xffff;
-	dev->device = (val >> 16) & 0xffff;
-
-	pci_read_config_dword(dev, PCI_CLASS_REVISION, &val);
-	dev->revision = val & 0xff;
-	dev->class = val >> 8; /* upper 3 bytes */
-
-	pci_read_config_word(dev, PCI_COMMAND, &cmd);
-	cmd &= ~(PCI_COMMAND_MASTER | PCI_COMMAND_MEMORY);
-	pci_write_config_word(dev, PCI_COMMAND, cmd);
-
-	pci_write_config_dword(dev, PCI_BASE_ADDRESS_0, bar0);
-
-	iounmap(mem);
 }
-DECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_ATHEROS, PCI_ANY_ID, ap94_pci_fixup);
 
-void __init ap94_pci_enable_quirk_wndr3700(void)
+__init void ap94_pci_setup_wmac_gpio(unsigned wmac, u32 mask, u32 val)
 {
-	ap94_wmac0_data.quirk_wndr3700 = 1;
-	ap94_wmac1_data.quirk_wndr3700 = 1;
+	switch (wmac) {
+	case 0:
+		ap94_wmac0_data.gpio_mask = mask;
+		ap94_wmac0_data.gpio_val = val;
+		break;
+	case 1:
+		ap94_wmac1_data.gpio_mask = mask;
+		ap94_wmac1_data.gpio_val = val;
+		break;
+	}
 }
 
 void __init ap94_pci_init(u8 *cal_data0, u8 *mac_addr0,
@@ -155,5 +104,6 @@ void __init ap94_pci_init(u8 *cal_data0, u8 *mac_addr0,
 	ar71xx_pci_plat_dev_init = ap94_pci_plat_dev_init;
 	ar71xx_pci_init(ARRAY_SIZE(ap94_pci_irqs), ap94_pci_irqs);
 
-	ap94_pci_fixup_enabled = 1;
+	pci_enable_ath9k_fixup(17, ap94_wmac0_data.eeprom_data);
+	pci_enable_ath9k_fixup(18, ap94_wmac1_data.eeprom_data);
 }
diff --git a/arch/mips/ar71xx/dev-ap94-pci.h b/arch/mips/ar71xx/dev-ap94-pci.h
index e69ba55..4584528 100644
--- a/arch/mips/ar71xx/dev-ap94-pci.h
+++ b/arch/mips/ar71xx/dev-ap94-pci.h
@@ -15,13 +15,16 @@
 void ap94_pci_init(u8 *cal_data0, u8 *mac_addr0,
 		   u8 *cal_data1, u8 *mac_addr1) __init;
 
-void ap94_pci_enable_quirk_wndr3700(void) __init;
+void ap94_pci_setup_wmac_led_pin(unsigned wmac, int pin) __init;
+void ap94_pci_setup_wmac_gpio(unsigned wmac, u32 mask, u32 val) __init;
 
 #else
 static inline void ap94_pci_init(u8 *cal_data0, u8 *mac_addr0,
 				 u8 *cal_data1, u8 *mac_addr1) {}
 
-static inline void ap94_pci_enable_quirk_wndr3700(void) {}
+static inline void ap94_pci_setup_wmac_led_pin(unsigned wmac, int pin) {}
+static inline void ap94_pci_setup_wmac_gpio(unsigned wmac,
+					    u32 mask, u32 val) {}
 #endif
 
 #endif /* _AR71XX_DEV_AP94_PCI_H */
diff --git a/arch/mips/ar71xx/dev-ar913x-wmac.c b/arch/mips/ar71xx/dev-ar913x-wmac.c
deleted file mode 100644
index 024d290..0000000
--- a/arch/mips/ar71xx/dev-ar913x-wmac.c
+++ /dev/null
@@ -1,68 +0,0 @@
-/*
- *  Atheros AR913x SoC built-in WMAC device support
- *
- *  Copyright (C) 2008-2009 Gabor Juhos <juhosg@openwrt.org>
- *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
- *
- *  Parts of this file are based on Atheros' 2.6.15 BSP
- *
- *  This program is free software; you can redistribute it and/or modify it
- *  under the terms of the GNU General Public License version 2 as published
- *  by the Free Software Foundation.
- */
-
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/delay.h>
-#include <linux/etherdevice.h>
-#include <linux/platform_device.h>
-#include <linux/ath9k_platform.h>
-
-#include <asm/mach-ar71xx/ar71xx.h>
-
-#include "dev-ar913x-wmac.h"
-
-static struct ath9k_platform_data ar913x_wmac_data;
-static char ar913x_wmac_mac[6];
-
-static struct resource ar913x_wmac_resources[] = {
-	{
-		.start	= AR91XX_WMAC_BASE,
-		.end	= AR91XX_WMAC_BASE + AR91XX_WMAC_SIZE - 1,
-		.flags	= IORESOURCE_MEM,
-	}, {
-		.start	= AR71XX_CPU_IRQ_IP2,
-		.end	= AR71XX_CPU_IRQ_IP2,
-		.flags	= IORESOURCE_IRQ,
-	},
-};
-
-static struct platform_device ar913x_wmac_device = {
-	.name		= "ath9k",
-	.id		= -1,
-	.resource	= ar913x_wmac_resources,
-	.num_resources	= ARRAY_SIZE(ar913x_wmac_resources),
-	.dev = {
-		.platform_data = &ar913x_wmac_data,
-	},
-};
-
-void __init ar913x_add_device_wmac(u8 *cal_data, u8 *mac_addr)
-{
-	if (cal_data)
-		memcpy(ar913x_wmac_data.eeprom_data, cal_data,
-		       sizeof(ar913x_wmac_data.eeprom_data));
-
-	if (mac_addr) {
-		memcpy(ar913x_wmac_mac, mac_addr, sizeof(ar913x_wmac_mac));
-		ar913x_wmac_data.macaddr = ar913x_wmac_mac;
-	}
-
-	ar71xx_device_stop(RESET_MODULE_AMBA2WMAC);
-	mdelay(10);
-
-	ar71xx_device_start(RESET_MODULE_AMBA2WMAC);
-	mdelay(10);
-
-	platform_device_register(&ar913x_wmac_device);
-}
diff --git a/arch/mips/ar71xx/dev-ar913x-wmac.h b/arch/mips/ar71xx/dev-ar913x-wmac.h
deleted file mode 100644
index 72d8d72..0000000
--- a/arch/mips/ar71xx/dev-ar913x-wmac.h
+++ /dev/null
@@ -1,19 +0,0 @@
-/*
- *  Atheros AR913x SoC built-in WMAC device support
- *
- *  Copyright (C) 2008-2009 Gabor Juhos <juhosg@openwrt.org>
- *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
- *
- *  Parts of this file are based on Atheros' 2.6.15 BSP
- *
- *  This program is free software; you can redistribute it and/or modify it
- *  under the terms of the GNU General Public License version 2 as published
- *  by the Free Software Foundation.
- */
-
-#ifndef _AR71XX_DEV_AR913X_WMAC_H
-#define _AR71XX_DEV_AR913X_WMAC_H
-
-void ar913x_add_device_wmac(u8 *cal_data, u8 *mac_addr) __init;
-
-#endif /* _AR71XX_DEV_AR913X_WMAC_H */
diff --git a/arch/mips/ar71xx/dev-ar9xxx-wmac.c b/arch/mips/ar71xx/dev-ar9xxx-wmac.c
new file mode 100644
index 0000000..90db388
--- /dev/null
+++ b/arch/mips/ar71xx/dev-ar9xxx-wmac.c
@@ -0,0 +1,156 @@
+/*
+ *  Atheros AR9XXX SoCs built-in WMAC device support
+ *
+ *  Copyright (C) 2010-2011 Jaiganesh Narayanan <jnarayanan@atheros.com>
+ *  Copyright (C) 2008-2009 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  Parts of this file are based on Atheros 2.6.15/2.6.31 BSP
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/etherdevice.h>
+#include <linux/platform_device.h>
+#include <linux/ath9k_platform.h>
+
+#include <asm/mach-ar71xx/ar71xx.h>
+
+#include "dev-ar9xxx-wmac.h"
+
+#define MHZ_25	(25 * 1000 * 1000)
+
+static struct ath9k_platform_data ar9xxx_wmac_data = {
+	.led_pin = -1,
+};
+static char ar9xxx_wmac_mac[6];
+
+static struct resource ar9xxx_wmac_resources[] = {
+	{
+		/* .start and .end fields are filled dynamically */
+		.flags	= IORESOURCE_MEM,
+	}, {
+		.start	= AR71XX_CPU_IRQ_IP2,
+		.end	= AR71XX_CPU_IRQ_IP2,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device ar9xxx_wmac_device = {
+	.name		= "ath9k",
+	.id		= -1,
+	.resource	= ar9xxx_wmac_resources,
+	.num_resources	= ARRAY_SIZE(ar9xxx_wmac_resources),
+	.dev = {
+		.platform_data = &ar9xxx_wmac_data,
+	},
+};
+
+static void ar913x_wmac_init(void)
+{
+	ar71xx_device_stop(RESET_MODULE_AMBA2WMAC);
+	mdelay(10);
+
+	ar71xx_device_start(RESET_MODULE_AMBA2WMAC);
+	mdelay(10);
+
+	ar9xxx_wmac_resources[0].start = AR91XX_WMAC_BASE;
+	ar9xxx_wmac_resources[0].end = AR91XX_WMAC_BASE + AR91XX_WMAC_SIZE - 1;
+}
+
+static int ar933x_r1_get_wmac_revision(void)
+{
+	return ar71xx_soc_rev;
+}
+
+static int ar933x_wmac_reset(void)
+{
+	unsigned retries = 0;
+
+	ar71xx_device_stop(AR933X_RESET_WMAC);
+	ar71xx_device_start(AR933X_RESET_WMAC);
+
+	while (1) {
+		u32 bootstrap;
+
+		bootstrap = ar71xx_reset_rr(AR933X_RESET_REG_BOOTSTRAP);
+		if ((bootstrap & AR933X_BOOTSTRAP_EEPBUSY) == 0)
+			return 0;
+
+		if (retries > 20)
+			break;
+
+		udelay(10000);
+		retries++;
+	}
+
+	pr_err("ar93xx: WMAC reset timed out");
+	return -ETIMEDOUT;
+}
+
+static void ar933x_wmac_init(void)
+{
+	ar9xxx_wmac_device.name = "ar933x_wmac";
+	ar9xxx_wmac_resources[0].start = AR933X_WMAC_BASE;
+	ar9xxx_wmac_resources[0].end = AR933X_WMAC_BASE + AR933X_WMAC_SIZE - 1;
+	if (ar71xx_ref_freq == MHZ_25)
+		ar9xxx_wmac_data.is_clk_25mhz = true;
+
+	if (ar71xx_soc_rev == 1)
+		ar9xxx_wmac_data.get_mac_revision = ar933x_r1_get_wmac_revision;
+
+	ar9xxx_wmac_data.external_reset = ar933x_wmac_reset;
+
+	ar933x_wmac_reset();
+}
+
+static void ar934x_wmac_init(void)
+{
+	ar9xxx_wmac_device.name = "ar934x_wmac";
+	ar9xxx_wmac_resources[0].start = AR934X_WMAC_BASE;
+	ar9xxx_wmac_resources[0].end = AR934X_WMAC_BASE + AR934X_WMAC_SIZE - 1;
+	ar9xxx_wmac_resources[1].start = AR934X_IP2_IRQ_WMAC;
+	ar9xxx_wmac_resources[1].start = AR934X_IP2_IRQ_WMAC;
+	if (ar71xx_ref_freq == MHZ_25)
+		ar9xxx_wmac_data.is_clk_25mhz = true;
+}
+
+void __init ar9xxx_add_device_wmac(u8 *cal_data, u8 *mac_addr)
+{
+	switch (ar71xx_soc) {
+	case AR71XX_SOC_AR9130:
+	case AR71XX_SOC_AR9132:
+		ar913x_wmac_init();
+		break;
+
+	case AR71XX_SOC_AR9330:
+	case AR71XX_SOC_AR9331:
+		ar933x_wmac_init();
+		break;
+
+	case AR71XX_SOC_AR9341:
+	case AR71XX_SOC_AR9342:
+	case AR71XX_SOC_AR9344:
+		ar934x_wmac_init();
+		break;
+
+	default:
+		BUG();
+	}
+
+	if (cal_data)
+		memcpy(ar9xxx_wmac_data.eeprom_data, cal_data,
+		       sizeof(ar9xxx_wmac_data.eeprom_data));
+
+	if (mac_addr) {
+		memcpy(ar9xxx_wmac_mac, mac_addr, sizeof(ar9xxx_wmac_mac));
+		ar9xxx_wmac_data.macaddr = ar9xxx_wmac_mac;
+	}
+
+	platform_device_register(&ar9xxx_wmac_device);
+}
diff --git a/arch/mips/ar71xx/dev-ar9xxx-wmac.h b/arch/mips/ar71xx/dev-ar9xxx-wmac.h
new file mode 100644
index 0000000..4fa7ec2
--- /dev/null
+++ b/arch/mips/ar71xx/dev-ar9xxx-wmac.h
@@ -0,0 +1,20 @@
+/*
+ *  Atheros AR9XXX SoCs built-in WMAC device support
+ *
+ *  Copyright (C) 2010-2011 Jaiganesh Narayanan <jnarayanan@atheros.com>
+ *  Copyright (C) 2008-2009 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  Parts of this file are based on Atheros 2.6.15/2.6.31 BSP
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#ifndef _AR71XX_DEV_AR9XXX_WMAC_H
+#define _AR71XX_DEV_AR9XXX_WMAC_H
+
+void ar9xxx_add_device_wmac(u8 *cal_data, u8 *mac_addr) __init;
+
+#endif /* _AR71XX_DEV_AR9XXX_WMAC_H */
diff --git a/arch/mips/ar71xx/dev-db120-pci.c b/arch/mips/ar71xx/dev-db120-pci.c
new file mode 100644
index 0000000..6e6e583
--- /dev/null
+++ b/arch/mips/ar71xx/dev-db120-pci.c
@@ -0,0 +1,59 @@
+/*
+ *  Atheros db120 reference board PCI initialization
+ *
+ *  Copyright (C) 2010-2011 Jaiganesh Narayanan <jnarayanan@atheros.com>
+ *  Copyright (C) 2011 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  Parts of this file are based on Atheros linux 2.6.31 BSP
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/pci.h>
+#include <linux/ath9k_platform.h>
+
+#include <asm/mach-ar71xx/ar71xx.h>
+#include <asm/mach-ar71xx/pci.h>
+
+#include "dev-db120-pci.h"
+
+static struct ath9k_platform_data db120_wmac_data = {
+	.led_pin = -1,
+};
+static char db120_wmac_mac[6];
+
+static struct ar71xx_pci_irq db120_pci_irqs[] __initdata = {
+	{
+		.slot	= 0,
+		.pin	= 1,
+		.irq	= AR71XX_PCI_IRQ_DEV0,
+	}
+};
+
+static int db120_pci_plat_dev_init(struct pci_dev *dev)
+{
+	switch (PCI_SLOT(dev->devfn)) {
+	case 0:
+		dev->dev.platform_data = &db120_wmac_data;
+		break;
+	}
+
+	return 0;
+}
+
+void __init db120_pci_init(u8 *cal_data, u8 *mac_addr)
+{
+	if (cal_data)
+		memcpy(db120_wmac_data.eeprom_data, cal_data,
+		       sizeof(db120_wmac_data.eeprom_data));
+
+	if (mac_addr) {
+		memcpy(db120_wmac_mac, mac_addr, sizeof(db120_wmac_mac));
+		db120_wmac_data.macaddr = db120_wmac_mac;
+	}
+
+	ar71xx_pci_plat_dev_init = db120_pci_plat_dev_init;
+	ar71xx_pci_init(ARRAY_SIZE(db120_pci_irqs), db120_pci_irqs);
+}
diff --git a/arch/mips/ar71xx/dev-db120-pci.h b/arch/mips/ar71xx/dev-db120-pci.h
new file mode 100644
index 0000000..b96d989
--- /dev/null
+++ b/arch/mips/ar71xx/dev-db120-pci.h
@@ -0,0 +1,23 @@
+/*
+ *  Atheros DB120 reference board PCI initialization
+ *
+ *  Copyright (C) 2010-2011 Jaiganesh Narayanan <jnarayanan@atheros.com>
+ *  Copyright (C) 2011 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  Parts of this file are based on Atheros linux 2.6.31 BSP
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#ifndef _AR71XX_DEV_DB120_PCI_H
+#define _AR71XX_DEV_DB120_PCI_H
+
+#if defined(CONFIG_AR71XX_DEV_DB120_PCI)
+void db120_pci_init(u8 *cal_data, u8 *mac_addr);
+#else
+static inline void db120_pci_init(u8 *cal_data, u8 *mac_addr) { }
+#endif
+
+#endif /* _AR71XX_DEV_DB120_PCI_H */
diff --git a/arch/mips/ar71xx/dev-dsa.c b/arch/mips/ar71xx/dev-dsa.c
index c2877f2..8b8fcfa 100644
--- a/arch/mips/ar71xx/dev-dsa.c
+++ b/arch/mips/ar71xx/dev-dsa.c
@@ -22,27 +22,15 @@ static struct platform_device ar71xx_dsa_switch_device = {
 	.id		= 0,
 };
 
-void __init ar71xx_add_device_dsa(unsigned int id,
+void __init ar71xx_add_device_dsa(struct device *netdev,
+				  struct device *miidev,
 				  struct dsa_platform_data *d)
 {
 	int i;
 
-	switch (id) {
-	case 0:
-		d->netdev = &ar71xx_eth0_device.dev;
-		break;
-	case 1:
-		d->netdev = &ar71xx_eth1_device.dev;
-		break;
-	default:
-		printk(KERN_ERR
-			"ar71xx: invalid ethernet id %d for DSA switch\n",
-			id);
-		return;
-	}
-
+	d->netdev = netdev;
 	for (i = 0; i < d->nr_chips; i++)
-		d->chip[i].mii_bus = &ar71xx_mdio_device.dev;
+		d->chip[i].mii_bus = miidev;
 
 	ar71xx_dsa_switch_device.dev.platform_data = d;
 
diff --git a/arch/mips/ar71xx/dev-dsa.h b/arch/mips/ar71xx/dev-dsa.h
index 2b11882..25b9881 100644
--- a/arch/mips/ar71xx/dev-dsa.h
+++ b/arch/mips/ar71xx/dev-dsa.h
@@ -14,7 +14,8 @@
 
 #include <net/dsa.h>
 
-void ar71xx_add_device_dsa(unsigned int id,
+void ar71xx_add_device_dsa(struct device *netdev,
+			   struct device *miidev,
 			   struct dsa_platform_data *d) __init;
 
 #endif /* _AR71XX_DEV_DSA_H */
diff --git a/arch/mips/ar71xx/dev-gpio-buttons.c b/arch/mips/ar71xx/dev-gpio-buttons.c
index df7416d..c22e652 100644
--- a/arch/mips/ar71xx/dev-gpio-buttons.c
+++ b/arch/mips/ar71xx/dev-gpio-buttons.c
@@ -10,18 +10,19 @@
  */
 
 #include "linux/init.h"
+#include "linux/slab.h"
 #include <linux/platform_device.h>
 
 #include "dev-gpio-buttons.h"
 
-void __init ar71xx_add_device_gpio_buttons(int id,
-					   unsigned poll_interval,
-					   unsigned nbuttons,
-					   struct gpio_button *buttons)
+void __init ar71xx_register_gpio_keys_polled(int id,
+					     unsigned poll_interval,
+					     unsigned nbuttons,
+					     struct gpio_keys_button *buttons)
 {
 	struct platform_device *pdev;
-	struct gpio_buttons_platform_data pdata;
-	struct gpio_button *p;
+	struct gpio_keys_platform_data pdata;
+	struct gpio_keys_button *p;
 	int err;
 
 	p = kmalloc(nbuttons * sizeof(*p), GFP_KERNEL);
@@ -30,7 +31,7 @@ void __init ar71xx_add_device_gpio_buttons(int id,
 
 	memcpy(p, buttons, nbuttons * sizeof(*p));
 
-	pdev = platform_device_alloc("gpio-buttons", id);
+	pdev = platform_device_alloc("gpio-keys-polled", id);
 	if (!pdev)
 		goto err_free_buttons;
 
@@ -43,7 +44,6 @@ void __init ar71xx_add_device_gpio_buttons(int id,
 	if (err)
 		goto err_put_pdev;
 
-
 	err = platform_device_add(pdev);
 	if (err)
 		goto err_put_pdev;
diff --git a/arch/mips/ar71xx/dev-gpio-buttons.h b/arch/mips/ar71xx/dev-gpio-buttons.h
index 97e9fe5..5ed8634 100644
--- a/arch/mips/ar71xx/dev-gpio-buttons.h
+++ b/arch/mips/ar71xx/dev-gpio-buttons.h
@@ -13,13 +13,11 @@
 #define _AR71XX_DEV_GPIO_BUTTONS_H
 
 #include <linux/input.h>
-#include <linux/gpio_buttons.h>
+#include <linux/gpio_keys.h>
 
-#include <asm/mach-ar71xx/platform.h>
-
-void ar71xx_add_device_gpio_buttons(int id,
-				    unsigned poll_interval,
-				    unsigned nbuttons,
-				    struct gpio_button *buttons) __init;
+void ar71xx_register_gpio_keys_polled(int id,
+				      unsigned poll_interval,
+				      unsigned nbuttons,
+				      struct gpio_keys_button *buttons);
 
 #endif /* _AR71XX_DEV_GPIO_BUTTONS_H */
diff --git a/arch/mips/ar71xx/dev-usb.c b/arch/mips/ar71xx/dev-usb.c
index fb006c7..57c7ef2 100644
--- a/arch/mips/ar71xx/dev-usb.c
+++ b/arch/mips/ar71xx/dev-usb.c
@@ -64,7 +64,7 @@ static struct platform_device ar71xx_ohci_device = {
 };
 
 /*
- * EHCI (USB full speed host controller)
+ * EHCI (USB high/full speed host controller)
  */
 static struct resource ar71xx_ehci_resources[] = {
 	[0] = {
@@ -128,16 +128,26 @@ static void __init ar7240_usb_setup(void)
 	/* WAR for HW bug. Here it adjusts the duration between two SOFS */
 	ar71xx_usb_ctrl_wr(USB_CTRL_REG_FLADJ, 0x3);
 
-	if (ar71xx_soc == AR71XX_SOC_AR7241 || ar71xx_soc == AR71XX_SOC_AR7242) {
-		ar71xx_ehci_data.is_ar91xx = 1;
-		ar71xx_ehci_device.resource = ar7240_ohci_resources;
-		ar71xx_ehci_device.num_resources = ARRAY_SIZE(ar7240_ohci_resources);
-		platform_device_register(&ar71xx_ehci_device);
-	} else {
-		ar71xx_ohci_device.resource = ar7240_ohci_resources;
-		ar71xx_ohci_device.num_resources = ARRAY_SIZE(ar7240_ohci_resources);
-		platform_device_register(&ar71xx_ohci_device);
-	}
+	ar71xx_ohci_device.resource = ar7240_ohci_resources;
+	ar71xx_ohci_device.num_resources = ARRAY_SIZE(ar7240_ohci_resources);
+	platform_device_register(&ar71xx_ohci_device);
+}
+
+static void __init ar7241_usb_setup(void)
+{
+	ar71xx_device_start(AR724X_RESET_USBSUS_OVERRIDE);
+	mdelay(10);
+
+	ar71xx_device_start(AR724X_RESET_USB_HOST);
+	mdelay(10);
+
+	ar71xx_device_start(AR724X_RESET_USB_PHY);
+	mdelay(10);
+
+	ar71xx_ehci_data.is_ar91xx = 1;
+	ar71xx_ehci_device.resource = ar7240_ohci_resources;
+	ar71xx_ehci_device.num_resources = ARRAY_SIZE(ar7240_ohci_resources);
+	platform_device_register(&ar71xx_ehci_device);
 }
 
 static void __init ar91xx_usb_setup(void)
@@ -155,13 +165,57 @@ static void __init ar91xx_usb_setup(void)
 	platform_device_register(&ar71xx_ehci_device);
 }
 
+static void __init ar933x_usb_setup(void)
+{
+	ar71xx_device_reset_rmw(0, AR933X_RESET_USBSUS_OVERRIDE);
+	mdelay(10);
+
+	ar71xx_device_reset_rmw(AR933X_RESET_USB_HOST,
+				AR933X_RESET_USBSUS_OVERRIDE);
+	mdelay(10);
+
+	ar71xx_device_reset_rmw(AR933X_RESET_USB_PHY,
+				AR933X_RESET_USBSUS_OVERRIDE);
+	mdelay(10);
+
+	ar71xx_ehci_data.is_ar91xx = 1;
+	platform_device_register(&ar71xx_ehci_device);
+}
+
+static void __init ar934x_usb_setup(void)
+{
+	u32 bootstrap;
+
+	bootstrap = ar71xx_reset_rr(AR934X_RESET_REG_BOOTSTRAP);
+	if (bootstrap & AR934X_BOOTSTRAP_USB_MODE_DEVICE)
+		return;
+
+	ar71xx_device_stop(AR934X_RESET_USBSUS_OVERRIDE);
+	udelay(1000);
+
+	ar71xx_device_start(AR934X_RESET_USB_PHY);
+	udelay(1000);
+
+	ar71xx_device_start(AR934X_RESET_USB_PHY_ANALOG);
+	udelay(1000);
+
+	ar71xx_device_start(AR934X_RESET_USB_HOST);
+	udelay(1000);
+
+	ar71xx_ehci_data.is_ar91xx = 1;
+	platform_device_register(&ar71xx_ehci_device);
+}
+
 void __init ar71xx_add_device_usb(void)
 {
 	switch (ar71xx_soc) {
 	case AR71XX_SOC_AR7240:
+		ar7240_usb_setup();
+		break;
+
 	case AR71XX_SOC_AR7241:
 	case AR71XX_SOC_AR7242:
-		ar7240_usb_setup();
+		ar7241_usb_setup();
 		break;
 
 	case AR71XX_SOC_AR7130:
@@ -175,6 +229,17 @@ void __init ar71xx_add_device_usb(void)
 		ar91xx_usb_setup();
 		break;
 
+	case AR71XX_SOC_AR9330:
+	case AR71XX_SOC_AR9331:
+		ar933x_usb_setup();
+		break;
+
+	case AR71XX_SOC_AR9341:
+	case AR71XX_SOC_AR9342:
+	case AR71XX_SOC_AR9344:
+		ar934x_usb_setup();
+		break;
+
 	default:
 		BUG();
 	}
diff --git a/arch/mips/ar71xx/devices.c b/arch/mips/ar71xx/devices.c
index f809dea..16cb4f1c 100644
--- a/arch/mips/ar71xx/devices.c
+++ b/arch/mips/ar71xx/devices.c
@@ -1,10 +1,12 @@
 /*
  *  Atheros AR71xx SoC platform devices
  *
+ *  Copyright (C) 2010-2011 Jaiganesh Narayanan <jnarayanan@atheros.com>
  *  Copyright (C) 2008-2009 Gabor Juhos <juhosg@openwrt.org>
  *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
  *
- *  Parts of this file are based on Atheros' 2.6.15 BSP
+ *  Parts of this file are based on Atheros 2.6.15 BSP
+ *  Parts of this file are based on Atheros 2.6.31 BSP
  *
  *  This program is free software; you can redistribute it and/or modify it
  *  under the terms of the GNU General Public License version 2 as published
@@ -19,10 +21,11 @@
 #include <linux/serial_8250.h>
 
 #include <asm/mach-ar71xx/ar71xx.h>
+#include <asm/mach-ar71xx/ar933x_uart_platform.h>
 
 #include "devices.h"
 
-static u8 ar71xx_mac_base[ETH_ALEN] __initdata;
+unsigned char ar71xx_mac_base[ETH_ALEN] __initdata;
 
 static struct resource ar71xx_uart_resources[] = {
 	{
@@ -55,13 +58,68 @@ static struct platform_device ar71xx_uart_device = {
 	},
 };
 
+static struct resource ar933x_uart_resources[] = {
+	{
+		.start  = AR933X_UART_BASE,
+		.end    = AR933X_UART_BASE + AR71XX_UART_SIZE - 1,
+		.flags  = IORESOURCE_MEM,
+	},
+	{
+		.start  = AR71XX_MISC_IRQ_UART,
+		.end    = AR71XX_MISC_IRQ_UART,
+		.flags  = IORESOURCE_IRQ,
+	},
+};
+
+static struct ar933x_uart_platform_data ar933x_uart_data;
+static struct platform_device ar933x_uart_device = {
+	.name           = "ar933x-uart",
+	.id             = -1,
+	.resource       = ar933x_uart_resources,
+	.num_resources  = ARRAY_SIZE(ar933x_uart_resources),
+	.dev = {
+		.platform_data  = &ar933x_uart_data,
+	},
+};
+
 void __init ar71xx_add_device_uart(void)
 {
-	ar71xx_uart_data[0].uartclk = ar71xx_ahb_freq;
-	platform_device_register(&ar71xx_uart_device);
+	struct platform_device *pdev;
+
+	switch (ar71xx_soc) {
+	case AR71XX_SOC_AR7130:
+	case AR71XX_SOC_AR7141:
+	case AR71XX_SOC_AR7161:
+	case AR71XX_SOC_AR7240:
+	case AR71XX_SOC_AR7241:
+	case AR71XX_SOC_AR7242:
+	case AR71XX_SOC_AR9130:
+	case AR71XX_SOC_AR9132:
+		pdev = &ar71xx_uart_device;
+		ar71xx_uart_data[0].uartclk = ar71xx_ahb_freq;
+		break;
+
+	case AR71XX_SOC_AR9330:
+	case AR71XX_SOC_AR9331:
+		pdev = &ar933x_uart_device;
+		ar933x_uart_data.uartclk = ar71xx_ref_freq;
+		break;
+
+	case AR71XX_SOC_AR9341:
+	case AR71XX_SOC_AR9342:
+	case AR71XX_SOC_AR9344:
+		pdev = &ar71xx_uart_device;
+		ar71xx_uart_data[0].uartclk = ar71xx_ref_freq;
+		break;
+
+	default:
+		BUG();
+	}
+
+	platform_device_register(pdev);
 }
 
-static struct resource ar71xx_mdio_resources[] = {
+static struct resource ar71xx_mdio0_resources[] = {
 	{
 		.name	= "mdio_base",
 		.flags	= IORESOURCE_MEM,
@@ -70,34 +128,38 @@ static struct resource ar71xx_mdio_resources[] = {
 	}
 };
 
-static struct ag71xx_mdio_platform_data ar71xx_mdio_data;
+static struct ag71xx_mdio_platform_data ar71xx_mdio0_data;
 
-struct platform_device ar71xx_mdio_device = {
+struct platform_device ar71xx_mdio0_device = {
 	.name		= "ag71xx-mdio",
-	.id		= -1,
-	.resource	= ar71xx_mdio_resources,
-	.num_resources	= ARRAY_SIZE(ar71xx_mdio_resources),
+	.id		= 0,
+	.resource	= ar71xx_mdio0_resources,
+	.num_resources	= ARRAY_SIZE(ar71xx_mdio0_resources),
 	.dev = {
-		.platform_data = &ar71xx_mdio_data,
+		.platform_data = &ar71xx_mdio0_data,
 	},
 };
 
-void __init ar71xx_add_device_mdio(u32 phy_mask)
-{
-	switch (ar71xx_soc) {
-	case AR71XX_SOC_AR7240:
-	case AR71XX_SOC_AR7241:
-	case AR71XX_SOC_AR7242:
-		ar71xx_mdio_data.is_ar7240 = 1;
-		break;
-	default:
-		break;
+static struct resource ar71xx_mdio1_resources[] = {
+	{
+		.name	= "mdio_base",
+		.flags	= IORESOURCE_MEM,
+		.start	= AR71XX_GE1_BASE,
+		.end	= AR71XX_GE1_BASE + 0x200 - 1,
 	}
+};
 
-	ar71xx_mdio_data.phy_mask = phy_mask;
+static struct ag71xx_mdio_platform_data ar71xx_mdio1_data;
 
-	platform_device_register(&ar71xx_mdio_device);
-}
+struct platform_device ar71xx_mdio1_device = {
+	.name		= "ag71xx-mdio",
+	.id		= 1,
+	.resource	= ar71xx_mdio1_resources,
+	.num_resources	= ARRAY_SIZE(ar71xx_mdio1_resources),
+	.dev = {
+		.platform_data = &ar71xx_mdio1_data,
+	},
+};
 
 static void ar71xx_set_pll(u32 cfg_reg, u32 pll_reg, u32 pll_val, u32 shift)
 {
@@ -128,6 +190,125 @@ static void ar71xx_set_pll(u32 cfg_reg, u32 pll_reg, u32 pll_val, u32 shift)
 	iounmap(base);
 }
 
+static void __init ar71xx_mii_ctrl_set_if(unsigned int reg,
+					  unsigned int mii_if)
+{
+	void __iomem *base;
+	u32 t;
+
+	base = ioremap(AR71XX_MII_BASE, AR71XX_MII_SIZE);
+
+	t = __raw_readl(base + reg);
+	t &= ~(MII_CTRL_IF_MASK);
+	t |= (mii_if & MII_CTRL_IF_MASK);
+	__raw_writel(t, base + reg);
+
+	iounmap(base);
+}
+
+static void ar71xx_mii_ctrl_set_speed(unsigned int reg, unsigned int speed)
+{
+	void __iomem *base;
+	unsigned int mii_speed;
+	u32 t;
+
+	switch (speed) {
+	case SPEED_10:
+		mii_speed =  MII_CTRL_SPEED_10;
+		break;
+	case SPEED_100:
+		mii_speed =  MII_CTRL_SPEED_100;
+		break;
+	case SPEED_1000:
+		mii_speed =  MII_CTRL_SPEED_1000;
+		break;
+	default:
+		BUG();
+	}
+
+	base = ioremap(AR71XX_MII_BASE, AR71XX_MII_SIZE);
+
+	t = __raw_readl(base + reg);
+	t &= ~(MII_CTRL_SPEED_MASK << MII_CTRL_SPEED_SHIFT);
+	t |= mii_speed  << MII_CTRL_SPEED_SHIFT;
+	__raw_writel(t, base + reg);
+
+	iounmap(base);
+}
+
+void __init ar71xx_add_device_mdio(unsigned int id, u32 phy_mask)
+{
+	struct platform_device *mdio_dev;
+	struct ag71xx_mdio_platform_data *mdio_data;
+	unsigned int max_id;
+
+	if (ar71xx_soc == AR71XX_SOC_AR9341 ||
+	    ar71xx_soc == AR71XX_SOC_AR9342 ||
+	    ar71xx_soc == AR71XX_SOC_AR9344)
+		max_id = 1;
+	else
+		max_id = 0;
+
+	if (id > max_id) {
+		printk(KERN_ERR "ar71xx: invalid MDIO id %u\n", id);
+		return;
+	}
+
+	switch (ar71xx_soc) {
+	case AR71XX_SOC_AR7241:
+	case AR71XX_SOC_AR9330:
+	case AR71XX_SOC_AR9331:
+		mdio_dev = &ar71xx_mdio1_device;
+		mdio_data = &ar71xx_mdio1_data;
+		break;
+
+	case AR71XX_SOC_AR9341:
+	case AR71XX_SOC_AR9342:
+	case AR71XX_SOC_AR9344:
+		if (id == 0) {
+			mdio_dev = &ar71xx_mdio0_device;
+			mdio_data = &ar71xx_mdio0_data;
+		} else {
+			mdio_dev = &ar71xx_mdio1_device;
+			mdio_data = &ar71xx_mdio1_data;
+		}
+		break;
+
+	case AR71XX_SOC_AR7242:
+		ar71xx_set_pll(AR71XX_PLL_REG_SEC_CONFIG,
+			       AR7242_PLL_REG_ETH0_INT_CLOCK, 0x62000000,
+			       AR71XX_ETH0_PLL_SHIFT);
+		/* fall through */
+	default:
+		mdio_dev = &ar71xx_mdio0_device;
+		mdio_data = &ar71xx_mdio0_data;
+		break;
+	}
+
+	mdio_data->phy_mask = phy_mask;
+
+	switch (ar71xx_soc) {
+	case AR71XX_SOC_AR7240:
+	case AR71XX_SOC_AR7241:
+	case AR71XX_SOC_AR9330:
+	case AR71XX_SOC_AR9331:
+		mdio_data->is_ar7240 = 1;
+		break;
+
+	case AR71XX_SOC_AR9341:
+	case AR71XX_SOC_AR9342:
+	case AR71XX_SOC_AR9344:
+		if (id == 1)
+			mdio_data->is_ar7240 = 1;
+		break;
+
+	default:
+		break;
+	}
+
+	platform_device_register(mdio_dev);
+}
+
 struct ar71xx_eth_pll_data ar71xx_eth0_pll_data;
 struct ar71xx_eth_pll_data ar71xx_eth1_pll_data;
 
@@ -164,46 +345,80 @@ static u32 ar71xx_get_eth_pll(unsigned int mac, int speed)
 	return pll_val;
 }
 
-static void ar71xx_set_pll_ge0(int speed)
+static void ar71xx_set_speed_ge0(int speed)
 {
 	u32 val = ar71xx_get_eth_pll(0, speed);
 
 	ar71xx_set_pll(AR71XX_PLL_REG_SEC_CONFIG, AR71XX_PLL_REG_ETH0_INT_CLOCK,
 			val, AR71XX_ETH0_PLL_SHIFT);
+	ar71xx_mii_ctrl_set_speed(MII_REG_MII0_CTRL, speed);
 }
 
-static void ar71xx_set_pll_ge1(int speed)
+static void ar71xx_set_speed_ge1(int speed)
 {
 	u32 val = ar71xx_get_eth_pll(1, speed);
 
 	ar71xx_set_pll(AR71XX_PLL_REG_SEC_CONFIG, AR71XX_PLL_REG_ETH1_INT_CLOCK,
 			 val, AR71XX_ETH1_PLL_SHIFT);
+	ar71xx_mii_ctrl_set_speed(MII_REG_MII1_CTRL, speed);
 }
 
-static void ar724x_set_pll_ge0(int speed)
+static void ar724x_set_speed_ge0(int speed)
 {
 	/* TODO */
 }
 
-static void ar724x_set_pll_ge1(int speed)
+static void ar724x_set_speed_ge1(int speed)
 {
 	/* TODO */
 }
 
-static void ar91xx_set_pll_ge0(int speed)
+static void ar7242_set_speed_ge0(int speed)
+{
+	u32 val = ar71xx_get_eth_pll(0, speed);
+	void __iomem *base;
+
+	base = ioremap_nocache(AR71XX_PLL_BASE, AR71XX_PLL_SIZE);
+	__raw_writel(val, base + AR7242_PLL_REG_ETH0_INT_CLOCK);
+	iounmap(base);
+}
+
+static void ar91xx_set_speed_ge0(int speed)
 {
 	u32 val = ar71xx_get_eth_pll(0, speed);
 
 	ar71xx_set_pll(AR91XX_PLL_REG_ETH_CONFIG, AR91XX_PLL_REG_ETH0_INT_CLOCK,
 			 val, AR91XX_ETH0_PLL_SHIFT);
+	ar71xx_mii_ctrl_set_speed(MII_REG_MII0_CTRL, speed);
 }
 
-static void ar91xx_set_pll_ge1(int speed)
+static void ar91xx_set_speed_ge1(int speed)
 {
 	u32 val = ar71xx_get_eth_pll(1, speed);
 
 	ar71xx_set_pll(AR91XX_PLL_REG_ETH_CONFIG, AR91XX_PLL_REG_ETH1_INT_CLOCK,
 			 val, AR91XX_ETH1_PLL_SHIFT);
+	ar71xx_mii_ctrl_set_speed(MII_REG_MII1_CTRL, speed);
+}
+
+static void ar933x_set_speed_ge0(int speed)
+{
+	/* TODO */
+}
+
+static void ar933x_set_speed_ge1(int speed)
+{
+	/* TODO */
+}
+
+static void ar934x_set_speed_ge0(int speed)
+{
+	/* TODO */
+}
+
+static void ar934x_set_speed_ge1(int speed)
+{
+	/* TODO */
 }
 
 static void ar71xx_ddr_flush_ge0(void)
@@ -236,6 +451,26 @@ static void ar91xx_ddr_flush_ge1(void)
 	ar71xx_ddr_flush(AR91XX_DDR_REG_FLUSH_GE1);
 }
 
+static void ar933x_ddr_flush_ge0(void)
+{
+	ar71xx_ddr_flush(AR933X_DDR_REG_FLUSH_GE0);
+}
+
+static void ar933x_ddr_flush_ge1(void)
+{
+	ar71xx_ddr_flush(AR933X_DDR_REG_FLUSH_GE1);
+}
+
+static void ar934x_ddr_flush_ge0(void)
+{
+	ar71xx_ddr_flush(AR934X_DDR_REG_FLUSH_GE0);
+}
+
+static void ar934x_ddr_flush_ge1(void)
+{
+	ar71xx_ddr_flush(AR934X_DDR_REG_FLUSH_GE1);
+}
+
 static struct resource ar71xx_eth0_resources[] = {
 	{
 		.name	= "mac_base",
@@ -243,11 +478,6 @@ static struct resource ar71xx_eth0_resources[] = {
 		.start	= AR71XX_GE0_BASE,
 		.end	= AR71XX_GE0_BASE + 0x200 - 1,
 	}, {
-		.name	= "mii_ctrl",
-		.flags	= IORESOURCE_MEM,
-		.start	= AR71XX_MII_BASE + MII_REG_MII0_CTRL,
-		.end	= AR71XX_MII_BASE + MII_REG_MII0_CTRL + 3,
-	}, {
 		.name	= "mac_irq",
 		.flags	= IORESOURCE_IRQ,
 		.start	= AR71XX_CPU_IRQ_GE0,
@@ -276,11 +506,6 @@ static struct resource ar71xx_eth1_resources[] = {
 		.start	= AR71XX_GE1_BASE,
 		.end	= AR71XX_GE1_BASE + 0x200 - 1,
 	}, {
-		.name	= "mii_ctrl",
-		.flags	= IORESOURCE_MEM,
-		.start	= AR71XX_MII_BASE + MII_REG_MII1_CTRL,
-		.end	= AR71XX_MII_BASE + MII_REG_MII1_CTRL + 3,
-	}, {
 		.name	= "mac_irq",
 		.flags	= IORESOURCE_IRQ,
 		.start	= AR71XX_CPU_IRQ_GE1,
@@ -310,10 +535,22 @@ struct platform_device ar71xx_eth1_device = {
 #define AR724X_PLL_VAL_100	0x00001099
 #define AR724X_PLL_VAL_10	0x00991099
 
+#define AR7242_PLL_VAL_1000	0x16000000
+#define AR7242_PLL_VAL_100	0x00000101
+#define AR7242_PLL_VAL_10	0x00001616
+
 #define AR91XX_PLL_VAL_1000	0x1a000000
 #define AR91XX_PLL_VAL_100	0x13000a44
 #define AR91XX_PLL_VAL_10	0x00441099
 
+#define AR933X_PLL_VAL_1000	0x00110000
+#define AR933X_PLL_VAL_100	0x00001099
+#define AR933X_PLL_VAL_10	0x00991099
+
+#define AR934X_PLL_VAL_1000	0x00110000
+#define AR934X_PLL_VAL_100	0x00001099
+#define AR934X_PLL_VAL_10	0x00991099
+
 static void __init ar71xx_init_eth_pll_data(unsigned int id)
 {
 	struct ar71xx_eth_pll_data *pll_data;
@@ -341,18 +578,39 @@ static void __init ar71xx_init_eth_pll_data(unsigned int id)
 
 	case AR71XX_SOC_AR7240:
 	case AR71XX_SOC_AR7241:
-	case AR71XX_SOC_AR7242:
 		pll_10 = AR724X_PLL_VAL_10;
 		pll_100 = AR724X_PLL_VAL_100;
 		pll_1000 = AR724X_PLL_VAL_1000;
 		break;
 
+	case AR71XX_SOC_AR7242:
+		pll_10 = AR7242_PLL_VAL_10;
+		pll_100 = AR7242_PLL_VAL_100;
+		pll_1000 = AR7242_PLL_VAL_1000;
+		break;
+
 	case AR71XX_SOC_AR9130:
 	case AR71XX_SOC_AR9132:
 		pll_10 = AR91XX_PLL_VAL_10;
 		pll_100 = AR91XX_PLL_VAL_100;
 		pll_1000 = AR91XX_PLL_VAL_1000;
 		break;
+
+	case AR71XX_SOC_AR9330:
+	case AR71XX_SOC_AR9331:
+		pll_10 = AR933X_PLL_VAL_10;
+		pll_100 = AR933X_PLL_VAL_100;
+		pll_1000 = AR933X_PLL_VAL_1000;
+		break;
+
+	case AR71XX_SOC_AR9341:
+	case AR71XX_SOC_AR9342:
+	case AR71XX_SOC_AR9344:
+		pll_10 = AR934X_PLL_VAL_10;
+		pll_100 = AR934X_PLL_VAL_100;
+		pll_1000 = AR934X_PLL_VAL_1000;
+		break;
+
 	default:
 		BUG();
 	}
@@ -367,105 +625,304 @@ static void __init ar71xx_init_eth_pll_data(unsigned int id)
 		pll_data->pll_1000 = pll_1000;
 }
 
-static int ar71xx_eth_instance __initdata;
-void __init ar71xx_add_device_eth(unsigned int id)
+static int __init ar71xx_setup_phy_if_mode(unsigned int id,
+					   struct ag71xx_platform_data *pdata)
 {
-	struct platform_device *pdev;
-	struct ag71xx_platform_data *pdata;
-
-	ar71xx_init_eth_pll_data(id);
+	unsigned int mii_if;
 
 	switch (id) {
 	case 0:
-		switch (ar71xx_eth0_data.phy_if_mode) {
-		case PHY_INTERFACE_MODE_MII:
-			ar71xx_eth0_data.mii_if = MII0_CTRL_IF_MII;
+		switch (ar71xx_soc) {
+		case AR71XX_SOC_AR7130:
+		case AR71XX_SOC_AR7141:
+		case AR71XX_SOC_AR7161:
+		case AR71XX_SOC_AR9130:
+		case AR71XX_SOC_AR9132:
+			switch (pdata->phy_if_mode) {
+			case PHY_INTERFACE_MODE_MII:
+				mii_if = MII0_CTRL_IF_MII;
+				break;
+			case PHY_INTERFACE_MODE_GMII:
+				mii_if = MII0_CTRL_IF_GMII;
+				break;
+			case PHY_INTERFACE_MODE_RGMII:
+				mii_if = MII0_CTRL_IF_RGMII;
+				break;
+			case PHY_INTERFACE_MODE_RMII:
+				mii_if = MII0_CTRL_IF_RMII;
+				break;
+			default:
+				return -EINVAL;
+			}
+			ar71xx_mii_ctrl_set_if(MII_REG_MII0_CTRL, mii_if);
 			break;
-		case PHY_INTERFACE_MODE_GMII:
-			ar71xx_eth0_data.mii_if = MII0_CTRL_IF_GMII;
-			break;
-		case PHY_INTERFACE_MODE_RGMII:
-			ar71xx_eth0_data.mii_if = MII0_CTRL_IF_RGMII;
+
+		case AR71XX_SOC_AR7240:
+		case AR71XX_SOC_AR7241:
+		case AR71XX_SOC_AR9330:
+		case AR71XX_SOC_AR9331:
+			pdata->phy_if_mode = PHY_INTERFACE_MODE_MII;
 			break;
-		case PHY_INTERFACE_MODE_RMII:
-			ar71xx_eth0_data.mii_if = MII0_CTRL_IF_RMII;
+
+		case AR71XX_SOC_AR7242:
+			/* FIXME */
+
+		case AR71XX_SOC_AR9341:
+		case AR71XX_SOC_AR9342:
+		case AR71XX_SOC_AR9344:
+			switch (pdata->phy_if_mode) {
+			case PHY_INTERFACE_MODE_MII:
+			case PHY_INTERFACE_MODE_GMII:
+			case PHY_INTERFACE_MODE_RGMII:
+			case PHY_INTERFACE_MODE_RMII:
+				break;
+			default:
+				return -EINVAL;
+			}
 			break;
+
 		default:
-			printk(KERN_ERR "ar71xx: invalid PHY interface mode "
-					"for eth0\n");
-			return;
+			BUG();
 		}
-		pdev = &ar71xx_eth0_device;
 		break;
 	case 1:
-		switch (ar71xx_eth1_data.phy_if_mode) {
-		case PHY_INTERFACE_MODE_RMII:
-			ar71xx_eth1_data.mii_if = MII1_CTRL_IF_RMII;
+		switch (ar71xx_soc) {
+		case AR71XX_SOC_AR7130:
+		case AR71XX_SOC_AR7141:
+		case AR71XX_SOC_AR7161:
+		case AR71XX_SOC_AR9130:
+		case AR71XX_SOC_AR9132:
+			switch (pdata->phy_if_mode) {
+			case PHY_INTERFACE_MODE_RMII:
+				mii_if = MII1_CTRL_IF_RMII;
+				break;
+			case PHY_INTERFACE_MODE_RGMII:
+				mii_if = MII1_CTRL_IF_RGMII;
+				break;
+			default:
+				return -EINVAL;
+			}
+			ar71xx_mii_ctrl_set_if(MII_REG_MII1_CTRL, mii_if);
 			break;
-		case PHY_INTERFACE_MODE_RGMII:
-			ar71xx_eth1_data.mii_if = MII1_CTRL_IF_RGMII;
+
+		case AR71XX_SOC_AR7240:
+		case AR71XX_SOC_AR7241:
+		case AR71XX_SOC_AR9330:
+		case AR71XX_SOC_AR9331:
+			pdata->phy_if_mode = PHY_INTERFACE_MODE_GMII;
 			break;
+
+		case AR71XX_SOC_AR7242:
+			/* FIXME */
+
+		case AR71XX_SOC_AR9341:
+		case AR71XX_SOC_AR9342:
+		case AR71XX_SOC_AR9344:
+			switch (pdata->phy_if_mode) {
+			case PHY_INTERFACE_MODE_MII:
+			case PHY_INTERFACE_MODE_GMII:
+				break;
+			default:
+				return -EINVAL;
+			}
+			break;
+
 		default:
-			printk(KERN_ERR "ar71xx: invalid PHY interface mode "
-					"for eth1\n");
-			return;
+			BUG();
 		}
-		pdev = &ar71xx_eth1_device;
 		break;
-	default:
+	}
+
+	return 0;
+}
+
+static int ar71xx_eth_instance __initdata;
+void __init ar71xx_add_device_eth(unsigned int id)
+{
+	struct platform_device *pdev;
+	struct ag71xx_platform_data *pdata;
+	int err;
+
+	if (id > 1) {
 		printk(KERN_ERR "ar71xx: invalid ethernet id %d\n", id);
 		return;
 	}
 
+	ar71xx_init_eth_pll_data(id);
+
+	if (id == 0)
+		pdev = &ar71xx_eth0_device;
+	else
+		pdev = &ar71xx_eth1_device;
+
 	pdata = pdev->dev.platform_data;
 
+	err = ar71xx_setup_phy_if_mode(id, pdata);
+	if (err) {
+		printk(KERN_ERR
+		       "ar71xx: invalid PHY interface mode for GE%u\n", id);
+		return;
+	}
+
 	switch (ar71xx_soc) {
 	case AR71XX_SOC_AR7130:
-		pdata->ddr_flush = id ? ar71xx_ddr_flush_ge1
-				      : ar71xx_ddr_flush_ge0;
-		pdata->set_pll =  id ? ar71xx_set_pll_ge1
-				     : ar71xx_set_pll_ge0;
+		if (id == 0) {
+			pdata->ddr_flush = ar71xx_ddr_flush_ge0;
+			pdata->set_speed = ar71xx_set_speed_ge0;
+		} else {
+			pdata->ddr_flush = ar71xx_ddr_flush_ge1;
+			pdata->set_speed = ar71xx_set_speed_ge1;
+		}
 		break;
 
 	case AR71XX_SOC_AR7141:
 	case AR71XX_SOC_AR7161:
-		pdata->ddr_flush = id ? ar71xx_ddr_flush_ge1
-				      : ar71xx_ddr_flush_ge0;
-		pdata->set_pll =  id ? ar71xx_set_pll_ge1
-				     : ar71xx_set_pll_ge0;
+		if (id == 0) {
+			pdata->ddr_flush = ar71xx_ddr_flush_ge0;
+			pdata->set_speed = ar71xx_set_speed_ge0;
+		} else {
+			pdata->ddr_flush = ar71xx_ddr_flush_ge1;
+			pdata->set_speed = ar71xx_set_speed_ge1;
+		}
 		pdata->has_gbit = 1;
 		break;
 
-	case AR71XX_SOC_AR7241:
 	case AR71XX_SOC_AR7242:
-		ar71xx_eth0_data.reset_bit |= AR724X_RESET_GE0_MDIO;
-		ar71xx_eth1_data.reset_bit |= AR724X_RESET_GE1_MDIO;
+		if (id == 0) {
+			pdata->reset_bit |= AR724X_RESET_GE0_MDIO |
+					    RESET_MODULE_GE0_PHY;
+			pdata->ddr_flush = ar724x_ddr_flush_ge0;
+			pdata->set_speed = ar7242_set_speed_ge0;
+		} else {
+			pdata->reset_bit |= AR724X_RESET_GE1_MDIO |
+					    RESET_MODULE_GE1_PHY;
+			pdata->ddr_flush = ar724x_ddr_flush_ge1;
+			pdata->set_speed = ar724x_set_speed_ge1;
+		}
+		pdata->has_gbit = 1;
+		pdata->is_ar724x = 1;
+
+		if (!pdata->fifo_cfg1)
+			pdata->fifo_cfg1 = 0x0010ffff;
+		if (!pdata->fifo_cfg2)
+			pdata->fifo_cfg2 = 0x015500aa;
+		if (!pdata->fifo_cfg3)
+			pdata->fifo_cfg3 = 0x01f00140;
+		break;
+
+	case AR71XX_SOC_AR7241:
+		if (id == 0)
+			pdata->reset_bit |= AR724X_RESET_GE0_MDIO;
+		else
+			pdata->reset_bit |= AR724X_RESET_GE1_MDIO;
 		/* fall through */
 	case AR71XX_SOC_AR7240:
-		pdata->ddr_flush = id ? ar724x_ddr_flush_ge1
-				      : ar724x_ddr_flush_ge0;
-		pdata->set_pll =  id ? ar724x_set_pll_ge1
-				     : ar724x_set_pll_ge0;
+		if (id == 0) {
+			pdata->reset_bit |= RESET_MODULE_GE0_PHY;
+			pdata->ddr_flush = ar724x_ddr_flush_ge0;
+			pdata->set_speed = ar724x_set_speed_ge0;
+
+			pdata->phy_mask = BIT(4);
+		} else {
+			pdata->reset_bit |= RESET_MODULE_GE1_PHY;
+			pdata->ddr_flush = ar724x_ddr_flush_ge1;
+			pdata->set_speed = ar724x_set_speed_ge1;
+
+			pdata->speed = SPEED_1000;
+			pdata->duplex = DUPLEX_FULL;
+			pdata->has_ar7240_switch = 1;
+		}
+		pdata->has_gbit = 1;
 		pdata->is_ar724x = 1;
+		if (ar71xx_soc == AR71XX_SOC_AR7240)
+			pdata->is_ar7240 = 1;
+
+		if (!pdata->fifo_cfg1)
+			pdata->fifo_cfg1 = 0x0010ffff;
+		if (!pdata->fifo_cfg2)
+			pdata->fifo_cfg2 = 0x015500aa;
+		if (!pdata->fifo_cfg3)
+			pdata->fifo_cfg3 = 0x01f00140;
 		break;
 
 	case AR71XX_SOC_AR9130:
-		pdata->ddr_flush = id ? ar91xx_ddr_flush_ge1
-				      : ar91xx_ddr_flush_ge0;
-		pdata->set_pll =  id ? ar91xx_set_pll_ge1
-				     : ar91xx_set_pll_ge0;
+		if (id == 0) {
+			pdata->ddr_flush = ar91xx_ddr_flush_ge0;
+			pdata->set_speed = ar91xx_set_speed_ge0;
+		} else {
+			pdata->ddr_flush = ar91xx_ddr_flush_ge1;
+			pdata->set_speed = ar91xx_set_speed_ge1;
+		}
 		pdata->is_ar91xx = 1;
 		break;
 
 	case AR71XX_SOC_AR9132:
-		pdata->ddr_flush = id ? ar91xx_ddr_flush_ge1
-				      : ar91xx_ddr_flush_ge0;
-		pdata->set_pll =  id ? ar91xx_set_pll_ge1
-				      : ar91xx_set_pll_ge0;
+		if (id == 0) {
+			pdata->ddr_flush = ar91xx_ddr_flush_ge0;
+			pdata->set_speed = ar91xx_set_speed_ge0;
+		} else {
+			pdata->ddr_flush = ar91xx_ddr_flush_ge1;
+			pdata->set_speed = ar91xx_set_speed_ge1;
+		}
 		pdata->is_ar91xx = 1;
 		pdata->has_gbit = 1;
 		break;
 
+	case AR71XX_SOC_AR9330:
+	case AR71XX_SOC_AR9331:
+		if (id == 0) {
+			pdata->reset_bit = AR933X_RESET_GE0_MAC |
+					   AR933X_RESET_GE0_MDIO;
+			pdata->ddr_flush = ar933x_ddr_flush_ge0;
+			pdata->set_speed = ar933x_set_speed_ge0;
+		} else {
+			pdata->reset_bit = AR933X_RESET_GE1_MAC |
+					   AR933X_RESET_GE1_MDIO;
+			pdata->ddr_flush = ar933x_ddr_flush_ge1;
+			pdata->set_speed = ar933x_set_speed_ge1;
+
+			pdata->speed = SPEED_1000;
+			pdata->duplex = DUPLEX_FULL;
+			pdata->has_ar7240_switch = 1;
+		}
+
+		pdata->has_gbit = 1;
+		pdata->is_ar724x = 1;
+
+		if (!pdata->fifo_cfg1)
+			pdata->fifo_cfg1 = 0x0010ffff;
+		if (!pdata->fifo_cfg2)
+			pdata->fifo_cfg2 = 0x015500aa;
+		if (!pdata->fifo_cfg3)
+			pdata->fifo_cfg3 = 0x01f00140;
+		break;
+
+	case AR71XX_SOC_AR9341:
+	case AR71XX_SOC_AR9342:
+	case AR71XX_SOC_AR9344:
+		if (id == 0) {
+			pdata->reset_bit = AR934X_RESET_GE0_MAC |
+					   AR934X_RESET_GE0_MDIO;
+			pdata->ddr_flush =ar934x_ddr_flush_ge0;
+			pdata->set_speed = ar934x_set_speed_ge0;
+		} else {
+			pdata->reset_bit = AR934X_RESET_GE1_MAC |
+					   AR934X_RESET_GE1_MDIO;
+			pdata->ddr_flush = ar934x_ddr_flush_ge1;
+			pdata->set_speed = ar934x_set_speed_ge1;
+		}
+
+		pdata->has_gbit = 1;
+		pdata->is_ar724x = 1;
+
+		if (!pdata->fifo_cfg1)
+			pdata->fifo_cfg1 = 0x0010ffff;
+		if (!pdata->fifo_cfg2)
+			pdata->fifo_cfg2 = 0x015500aa;
+		if (!pdata->fifo_cfg3)
+			pdata->fifo_cfg3 = 0x01f00140;
+		break;
+
 	default:
 		BUG();
 	}
@@ -483,18 +940,35 @@ void __init ar71xx_add_device_eth(unsigned int id)
 		break;
 	}
 
-	if (is_valid_ether_addr(ar71xx_mac_base)) {
-		memcpy(pdata->mac_addr, ar71xx_mac_base, ETH_ALEN);
-		pdata->mac_addr[5] += ar71xx_eth_instance;
-	} else {
+	if (!is_valid_ether_addr(pdata->mac_addr)) {
 		random_ether_addr(pdata->mac_addr);
 		printk(KERN_DEBUG
 			"ar71xx: using random MAC address for eth%d\n",
 			ar71xx_eth_instance);
 	}
 
-	if (pdata->mii_bus_dev == NULL)
-		pdata->mii_bus_dev = &ar71xx_mdio_device.dev;
+	if (pdata->mii_bus_dev == NULL) {
+		switch (ar71xx_soc) {
+		case AR71XX_SOC_AR9341:
+		case AR71XX_SOC_AR9342:
+		case AR71XX_SOC_AR9344:
+			if (id == 0)
+				pdata->mii_bus_dev = &ar71xx_mdio0_device.dev;
+			else
+				pdata->mii_bus_dev = &ar71xx_mdio1_device.dev;
+			break;
+
+		case AR71XX_SOC_AR7241:
+		case AR71XX_SOC_AR9330:
+		case AR71XX_SOC_AR9331:
+			pdata->mii_bus_dev = &ar71xx_mdio1_device.dev;
+			break;
+
+		default:
+			pdata->mii_bus_dev = &ar71xx_mdio0_device.dev;
+			break;
+		}
+	}
 
 	/* Reset the device */
 	ar71xx_device_stop(pdata->reset_bit);
@@ -573,3 +1047,24 @@ static int __init ar71xx_kmac_setup(char *str)
 	return 1;
 }
 __setup("kmac=", ar71xx_kmac_setup);
+
+void __init ar71xx_init_mac(unsigned char *dst, const unsigned char *src,
+			    unsigned offset)
+{
+	u32 t;
+
+	if (!is_valid_ether_addr(src)) {
+		memset(dst, '\0', ETH_ALEN);
+		return;
+	}
+
+	t = (((u32) src[3]) << 16) + (((u32) src[4]) << 8) + ((u32) src[5]);
+	t += offset;
+
+	dst[0] = src[0];
+	dst[1] = src[1];
+	dst[2] = src[2];
+	dst[3] = (t >> 16) & 0xff;
+	dst[4] = (t >> 8) & 0xff;
+	dst[5] = t & 0xff;
+}
diff --git a/arch/mips/ar71xx/devices.h b/arch/mips/ar71xx/devices.h
index 957675b..2553d17 100644
--- a/arch/mips/ar71xx/devices.h
+++ b/arch/mips/ar71xx/devices.h
@@ -20,8 +20,10 @@ void ar71xx_add_device_spi(struct ar71xx_spi_platform_data *pdata,
 			   struct spi_board_info const *info,
 			   unsigned n) __init;
 
-void ar71xx_set_mac_base(unsigned char *mac) __init;
+extern unsigned char ar71xx_mac_base[] __initdata;
 void ar71xx_parse_mac_addr(char *mac_str) __init;
+void ar71xx_init_mac(unsigned char *dst, const unsigned char *src,
+		     unsigned offset) __init;
 
 struct ar71xx_eth_pll_data {
 	u32	pll_10;
@@ -38,8 +40,9 @@ extern struct platform_device ar71xx_eth0_device;
 extern struct platform_device ar71xx_eth1_device;
 void ar71xx_add_device_eth(unsigned int id) __init;
 
-extern struct platform_device ar71xx_mdio_device;
-void ar71xx_add_device_mdio(u32 phy_mask) __init;
+extern struct platform_device ar71xx_mdio0_device;
+extern struct platform_device ar71xx_mdio1_device;
+void ar71xx_add_device_mdio(unsigned int id, u32 phy_mask) __init;
 
 void ar71xx_add_device_uart(void) __init;
 
diff --git a/arch/mips/ar71xx/early_printk.c b/arch/mips/ar71xx/early_printk.c
index 4661d97..c85a04d 100644
--- a/arch/mips/ar71xx/early_printk.c
+++ b/arch/mips/ar71xx/early_printk.c
@@ -1,7 +1,7 @@
 /*
- *  Atheros AR71xx SoC early printk support
+ *  Atheros AR7xxx/AR9xxx SoC early printk support
  *
- *  Copyright (C) 2008-2009 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008-2011 Gabor Juhos <juhosg@openwrt.org>
  *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
  *
  *  This program is free software; you can redistribute it and/or modify it
@@ -9,22 +9,88 @@
  *  by the Free Software Foundation.
  */
 
+#include <linux/errno.h>
 #include <linux/io.h>
 #include <linux/serial_reg.h>
 #include <asm/addrspace.h>
 
 #include <asm/mach-ar71xx/ar71xx.h>
+#include <asm/mach-ar71xx/ar933x_uart.h>
 
-#define UART_READ(r) \
-	__raw_readl((void __iomem *)(KSEG1ADDR(AR71XX_UART_BASE) + 4 * (r)))
+static void (*_prom_putchar) (unsigned char);
 
-#define UART_WRITE(r, v) \
-	__raw_writel((v), (void __iomem *)(KSEG1ADDR(AR71XX_UART_BASE) + 4*(r)))
+static inline void prom_putchar_wait(void __iomem *reg, u32 mask, u32 val)
+{
+	u32 t;
 
-void prom_putchar(unsigned char ch)
+	do {
+		t = __raw_readl(reg);
+		if ((t & mask) == val)
+			break;
+	} while (1);
+}
+
+static void prom_putchar_ar71xx(unsigned char ch)
+{
+	void __iomem *base = (void __iomem *)(KSEG1ADDR(AR71XX_UART_BASE));
+
+	prom_putchar_wait(base + UART_LSR * 4, UART_LSR_THRE, UART_LSR_THRE);
+	__raw_writel(ch, base + UART_TX * 4);
+	prom_putchar_wait(base + UART_LSR * 4, UART_LSR_THRE, UART_LSR_THRE);
+}
+
+static void prom_putchar_ar933x(unsigned char ch)
+{
+	void __iomem *base = (void __iomem *)(KSEG1ADDR(AR933X_UART_BASE));
+
+	prom_putchar_wait(base + AR933X_UART_DATA_REG, AR933X_UART_DATA_TX_CSR,
+			  AR933X_UART_DATA_TX_CSR);
+	__raw_writel(AR933X_UART_DATA_TX_CSR | ch, base + AR933X_UART_DATA_REG);
+	prom_putchar_wait(base + AR933X_UART_DATA_REG, AR933X_UART_DATA_TX_CSR,
+			  AR933X_UART_DATA_TX_CSR);
+}
+
+static void prom_putchar_dummy(unsigned char ch)
 {
-	while (((UART_READ(UART_LSR)) & UART_LSR_THRE) == 0);
-	UART_WRITE(UART_TX, ch);
-	while (((UART_READ(UART_LSR)) & UART_LSR_THRE) == 0);
+	/* nothing to do */
 }
 
+static void prom_putchar_init(void)
+{
+	void __iomem *base;
+	u32 id;
+
+	base = (void __iomem *)(KSEG1ADDR(AR71XX_RESET_BASE));
+	id = __raw_readl(base + AR71XX_RESET_REG_REV_ID);
+	id &= REV_ID_MAJOR_MASK;
+
+	switch (id) {
+	case REV_ID_MAJOR_AR71XX:
+	case REV_ID_MAJOR_AR7240:
+	case REV_ID_MAJOR_AR7241:
+	case REV_ID_MAJOR_AR7242:
+	case REV_ID_MAJOR_AR913X:
+	case REV_ID_MAJOR_AR9341:
+	case REV_ID_MAJOR_AR9342:
+	case REV_ID_MAJOR_AR9344:
+		_prom_putchar = prom_putchar_ar71xx;
+		break;
+
+	case REV_ID_MAJOR_AR9330:
+	case REV_ID_MAJOR_AR9331:
+		_prom_putchar = prom_putchar_ar933x;
+		break;
+
+	default:
+		_prom_putchar = prom_putchar_dummy;
+		break;
+	}
+}
+
+void prom_putchar(unsigned char ch)
+{
+	if (!_prom_putchar)
+		prom_putchar_init();
+
+	_prom_putchar(ch);
+}
diff --git a/arch/mips/ar71xx/gpio.c b/arch/mips/ar71xx/gpio.c
index cdb614b..517a136 100644
--- a/arch/mips/ar71xx/gpio.c
+++ b/arch/mips/ar71xx/gpio.c
@@ -1,7 +1,7 @@
 /*
- *  Atheros AR71xx SoC GPIO API support
+ *  Atheros AR7XXX/AR9XXX SoC GPIO API support
  *
- *  Copyright (C) 2008-2010 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008-2011 Gabor Juhos <juhosg@openwrt.org>
  *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
  *
  *  This program is free software; you can redistribute it and/or modify it
@@ -30,15 +30,15 @@ void __ar71xx_gpio_set_value(unsigned gpio, int value)
 	void __iomem *base = ar71xx_gpio_base;
 
 	if (value)
-		__raw_writel(1 << gpio, base + GPIO_REG_SET);
+		__raw_writel(1 << gpio, base + AR71XX_GPIO_REG_SET);
 	else
-		__raw_writel(1 << gpio, base + GPIO_REG_CLEAR);
+		__raw_writel(1 << gpio, base + AR71XX_GPIO_REG_CLEAR);
 }
 EXPORT_SYMBOL(__ar71xx_gpio_set_value);
 
 int __ar71xx_gpio_get_value(unsigned gpio)
 {
-	return (__raw_readl(ar71xx_gpio_base + GPIO_REG_IN) >> gpio) & 1;
+	return (__raw_readl(ar71xx_gpio_base + AR71XX_GPIO_REG_IN) >> gpio) & 1;
 }
 EXPORT_SYMBOL(__ar71xx_gpio_get_value);
 
@@ -61,8 +61,8 @@ static int ar71xx_gpio_direction_input(struct gpio_chip *chip,
 
 	spin_lock_irqsave(&ar71xx_gpio_lock, flags);
 
-	__raw_writel(__raw_readl(base + GPIO_REG_OE) & ~(1 << offset),
-		     base + GPIO_REG_OE);
+	__raw_writel(__raw_readl(base + AR71XX_GPIO_REG_OE) & ~(1 << offset),
+		     base + AR71XX_GPIO_REG_OE);
 
 	spin_unlock_irqrestore(&ar71xx_gpio_lock, flags);
 
@@ -78,12 +78,49 @@ static int ar71xx_gpio_direction_output(struct gpio_chip *chip,
 	spin_lock_irqsave(&ar71xx_gpio_lock, flags);
 
 	if (value)
-		__raw_writel(1 << offset, base + GPIO_REG_SET);
+		__raw_writel(1 << offset, base + AR71XX_GPIO_REG_SET);
 	else
-		__raw_writel(1 << offset, base + GPIO_REG_CLEAR);
+		__raw_writel(1 << offset, base + AR71XX_GPIO_REG_CLEAR);
 
-	__raw_writel(__raw_readl(base + GPIO_REG_OE) | (1 << offset),
-		     base + GPIO_REG_OE);
+	__raw_writel(__raw_readl(base + AR71XX_GPIO_REG_OE) | (1 << offset),
+		     base + AR71XX_GPIO_REG_OE);
+
+	spin_unlock_irqrestore(&ar71xx_gpio_lock, flags);
+
+	return 0;
+}
+
+static int ar934x_gpio_direction_input(struct gpio_chip *chip,
+				       unsigned offset)
+{
+	void __iomem *base = ar71xx_gpio_base;
+	unsigned long flags;
+
+	spin_lock_irqsave(&ar71xx_gpio_lock, flags);
+
+	__raw_writel(__raw_readl(base + AR71XX_GPIO_REG_OE) | (1 << offset),
+		     base + AR71XX_GPIO_REG_OE);
+
+	spin_unlock_irqrestore(&ar71xx_gpio_lock, flags);
+
+	return 0;
+}
+
+static int ar934x_gpio_direction_output(struct gpio_chip *chip,
+					unsigned offset, int value)
+{
+	void __iomem *base = ar71xx_gpio_base;
+	unsigned long flags;
+
+	spin_lock_irqsave(&ar71xx_gpio_lock, flags);
+
+	if (value)
+		__raw_writel(1 << offset, base + AR71XX_GPIO_REG_SET);
+	else
+		__raw_writel(1 << offset, base + AR71XX_GPIO_REG_CLEAR);
+
+	__raw_writel(__raw_readl(base + AR71XX_GPIO_REG_OE) & ~(1 << offset),
+		     base + AR71XX_GPIO_REG_OE);
 
 	spin_unlock_irqrestore(&ar71xx_gpio_lock, flags);
 
@@ -104,13 +141,21 @@ void ar71xx_gpio_function_enable(u32 mask)
 {
 	void __iomem *base = ar71xx_gpio_base;
 	unsigned long flags;
+	unsigned int reg;
+
+	if (ar71xx_soc == AR71XX_SOC_AR9341 ||
+	    ar71xx_soc == AR71XX_SOC_AR9342 ||
+	    ar71xx_soc == AR71XX_SOC_AR9344) {
+		reg = AR934X_GPIO_REG_FUNC;
+	} else {
+		reg = AR71XX_GPIO_REG_FUNC;
+	}
 
 	spin_lock_irqsave(&ar71xx_gpio_lock, flags);
 
-	__raw_writel(__raw_readl(base + GPIO_REG_FUNC) | mask,
-		     base + GPIO_REG_FUNC);
+	__raw_writel(__raw_readl(base + reg) | mask, base + reg);
 	/* flush write */
-	(void) __raw_readl(base + GPIO_REG_FUNC);
+	(void) __raw_readl(base + reg);
 
 	spin_unlock_irqrestore(&ar71xx_gpio_lock, flags);
 }
@@ -119,13 +164,21 @@ void ar71xx_gpio_function_disable(u32 mask)
 {
 	void __iomem *base = ar71xx_gpio_base;
 	unsigned long flags;
+	unsigned int reg;
+
+	if (ar71xx_soc == AR71XX_SOC_AR9341 ||
+	    ar71xx_soc == AR71XX_SOC_AR9342 ||
+	    ar71xx_soc == AR71XX_SOC_AR9344) {
+		reg = AR934X_GPIO_REG_FUNC;
+	} else {
+		reg = AR71XX_GPIO_REG_FUNC;
+	}
 
 	spin_lock_irqsave(&ar71xx_gpio_lock, flags);
 
-	__raw_writel(__raw_readl(base + GPIO_REG_FUNC) & ~mask,
-		     base + GPIO_REG_FUNC);
+	__raw_writel(__raw_readl(base + reg) & ~mask, base + reg);
 	/* flush write */
-	(void) __raw_readl(base + GPIO_REG_FUNC);
+	(void) __raw_readl(base + reg);
 
 	spin_unlock_irqrestore(&ar71xx_gpio_lock, flags);
 }
@@ -134,18 +187,57 @@ void ar71xx_gpio_function_setup(u32 set, u32 clear)
 {
 	void __iomem *base = ar71xx_gpio_base;
 	unsigned long flags;
+	unsigned int reg;
+
+	if (ar71xx_soc == AR71XX_SOC_AR9341 ||
+	    ar71xx_soc == AR71XX_SOC_AR9342 ||
+	    ar71xx_soc == AR71XX_SOC_AR9344) {
+		reg = AR934X_GPIO_REG_FUNC;
+	} else {
+		reg = AR71XX_GPIO_REG_FUNC;
+	}
 
 	spin_lock_irqsave(&ar71xx_gpio_lock, flags);
 
-	__raw_writel((__raw_readl(base + GPIO_REG_FUNC) & ~clear) | set,
-		     base + GPIO_REG_FUNC);
+	__raw_writel((__raw_readl(base + reg) & ~clear) | set, base + reg);
 	/* flush write */
-	(void) __raw_readl(base + GPIO_REG_FUNC);
+	(void) __raw_readl(base + reg);
 
 	spin_unlock_irqrestore(&ar71xx_gpio_lock, flags);
 }
 EXPORT_SYMBOL(ar71xx_gpio_function_setup);
 
+void __init ar71xx_gpio_output_select(unsigned gpio, u8 val)
+{
+	void __iomem *base = ar71xx_gpio_base;
+	unsigned long flags;
+	unsigned int reg;
+	u32 t, s;
+
+	if (ar71xx_soc != AR71XX_SOC_AR9341 &&
+	    ar71xx_soc != AR71XX_SOC_AR9342 &&
+	    ar71xx_soc != AR71XX_SOC_AR9344)
+		return;
+
+	if (gpio >= AR934X_GPIO_COUNT)
+		return;
+
+	reg = AR934X_GPIO_REG_OUT_FUNC0 + 4 * (gpio / 4);
+	s = 8 * (gpio % 4);
+
+	spin_lock_irqsave(&ar71xx_gpio_lock, flags);
+
+	t = __raw_readl(base + reg);
+	t &= ~(0xff << s);
+	t |= val << s;
+	__raw_writel(t, base + reg);
+
+	/* flush write */
+	(void) __raw_readl(base + reg);
+
+	spin_unlock_irqrestore(&ar71xx_gpio_lock, flags);
+}
+
 void __init ar71xx_gpio_init(void)
 {
 	int err;
@@ -172,6 +264,19 @@ void __init ar71xx_gpio_init(void)
 		ar71xx_gpio_chip.ngpio = AR91XX_GPIO_COUNT;
 		break;
 
+	case AR71XX_SOC_AR9330:
+	case AR71XX_SOC_AR9331:
+		ar71xx_gpio_chip.ngpio = AR933X_GPIO_COUNT;
+		break;
+
+	case AR71XX_SOC_AR9341:
+	case AR71XX_SOC_AR9342:
+	case AR71XX_SOC_AR9344:
+		ar71xx_gpio_chip.ngpio = AR934X_GPIO_COUNT;
+		ar71xx_gpio_chip.direction_input = ar934x_gpio_direction_input;
+		ar71xx_gpio_chip.direction_output = ar934x_gpio_direction_output;
+		break;
+
 	default:
 		BUG();
 	}
diff --git a/arch/mips/ar71xx/irq.c b/arch/mips/ar71xx/irq.c
index 4e1da16..6d744da 100644
--- a/arch/mips/ar71xx/irq.c
+++ b/arch/mips/ar71xx/irq.c
@@ -1,10 +1,12 @@
 /*
  *  Atheros AR71xx SoC specific interrupt handling
  *
+ *  Copyright (C) 2010-2011 Jaiganesh Narayanan <jnarayanan@atheros.com>
  *  Copyright (C) 2008-2010 Gabor Juhos <juhosg@openwrt.org>
  *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
  *
- *  Parts of this file are based on Atheros' 2.6.15 BSP
+ *  Parts of this file are based on Atheros 2.6.15 BSP
+ *  Parts of this file are based on Atheros 2.6.31 BSP
  *
  *  This program is free software; you can redistribute it and/or modify it
  *  under the terms of the GNU General Public License version 2 as published
@@ -21,15 +23,13 @@
 
 #include <asm/mach-ar71xx/ar71xx.h>
 
-static int ip2_flush_reg;
-
 static void ar71xx_gpio_irq_dispatch(void)
 {
 	void __iomem *base = ar71xx_gpio_base;
 	u32 pending;
 
-	pending = __raw_readl(base + GPIO_REG_INT_PENDING) &
-		  __raw_readl(base + GPIO_REG_INT_ENABLE);
+	pending = __raw_readl(base + AR71XX_GPIO_REG_INT_PENDING) &
+		  __raw_readl(base + AR71XX_GPIO_REG_INT_ENABLE);
 
 	if (pending)
 		do_IRQ(AR71XX_GPIO_IRQ_BASE + fls(pending) - 1);
@@ -37,50 +37,37 @@ static void ar71xx_gpio_irq_dispatch(void)
 		spurious_interrupt();
 }
 
-static void ar71xx_gpio_irq_unmask(unsigned int irq)
+static void ar71xx_gpio_irq_unmask(struct irq_data *d)
 {
+	unsigned int irq = d->irq - AR71XX_GPIO_IRQ_BASE;
 	void __iomem *base = ar71xx_gpio_base;
 	u32 t;
 
-	irq -= AR71XX_GPIO_IRQ_BASE;
-
-	t = __raw_readl(base + GPIO_REG_INT_ENABLE);
-	__raw_writel(t | (1 << irq), base + GPIO_REG_INT_ENABLE);
+	t = __raw_readl(base + AR71XX_GPIO_REG_INT_ENABLE);
+	__raw_writel(t | (1 << irq), base + AR71XX_GPIO_REG_INT_ENABLE);
 
 	/* flush write */
-	(void) __raw_readl(base + GPIO_REG_INT_ENABLE);
+	(void) __raw_readl(base + AR71XX_GPIO_REG_INT_ENABLE);
 }
 
-static void ar71xx_gpio_irq_mask(unsigned int irq)
+static void ar71xx_gpio_irq_mask(struct irq_data *d)
 {
+	unsigned int irq = d->irq - AR71XX_GPIO_IRQ_BASE;
 	void __iomem *base = ar71xx_gpio_base;
 	u32 t;
 
-	irq -= AR71XX_GPIO_IRQ_BASE;
-
-	t = __raw_readl(base + GPIO_REG_INT_ENABLE);
-	__raw_writel(t & ~(1 << irq), base + GPIO_REG_INT_ENABLE);
+	t = __raw_readl(base + AR71XX_GPIO_REG_INT_ENABLE);
+	__raw_writel(t & ~(1 << irq), base + AR71XX_GPIO_REG_INT_ENABLE);
 
 	/* flush write */
-	(void) __raw_readl(base + GPIO_REG_INT_ENABLE);
-}
-
-#if 0
-static int ar71xx_gpio_irq_set_type(unsigned int irq, unsigned int flow_type)
-{
-	/* TODO: implement */
-	return 0;
+	(void) __raw_readl(base + AR71XX_GPIO_REG_INT_ENABLE);
 }
-#else
-#define ar71xx_gpio_irq_set_type	NULL
-#endif
 
 static struct irq_chip ar71xx_gpio_irq_chip = {
 	.name		= "AR71XX GPIO",
-	.unmask		= ar71xx_gpio_irq_unmask,
-	.mask		= ar71xx_gpio_irq_mask,
-	.mask_ack	= ar71xx_gpio_irq_mask,
-	.set_type	= ar71xx_gpio_irq_set_type,
+	.irq_unmask	= ar71xx_gpio_irq_unmask,
+	.irq_mask	= ar71xx_gpio_irq_mask,
+	.irq_mask_ack	= ar71xx_gpio_irq_mask,
 };
 
 static struct irqaction ar71xx_gpio_irqaction = {
@@ -88,7 +75,6 @@ static struct irqaction ar71xx_gpio_irqaction = {
 	.name		= "cascade [AR71XX GPIO]",
 };
 
-#define GPIO_IRQ_INIT_STATUS (IRQ_LEVEL | IRQ_TYPE_LEVEL_HIGH | IRQ_DISABLED)
 #define GPIO_INT_ALL	0xffff
 
 static void __init ar71xx_gpio_irq_init(void)
@@ -96,21 +82,19 @@ static void __init ar71xx_gpio_irq_init(void)
 	void __iomem *base = ar71xx_gpio_base;
 	int i;
 
-	__raw_writel(0, base + GPIO_REG_INT_ENABLE);
-	__raw_writel(0, base + GPIO_REG_INT_PENDING);
+	__raw_writel(0, base + AR71XX_GPIO_REG_INT_ENABLE);
+	__raw_writel(0, base + AR71XX_GPIO_REG_INT_PENDING);
 
 	/* setup type of all GPIO interrupts to level sensitive */
-	__raw_writel(GPIO_INT_ALL, base + GPIO_REG_INT_TYPE);
+	__raw_writel(GPIO_INT_ALL, base + AR71XX_GPIO_REG_INT_TYPE);
 
 	/* setup polarity of all GPIO interrupts to active high */
-	__raw_writel(GPIO_INT_ALL, base + GPIO_REG_INT_POLARITY);
+	__raw_writel(GPIO_INT_ALL, base + AR71XX_GPIO_REG_INT_POLARITY);
 
 	for (i = AR71XX_GPIO_IRQ_BASE;
-	     i < AR71XX_GPIO_IRQ_BASE + AR71XX_GPIO_IRQ_COUNT; i++) {
-		irq_desc[i].status = GPIO_IRQ_INIT_STATUS;
-		set_irq_chip_and_handler(i, &ar71xx_gpio_irq_chip,
+	     i < AR71XX_GPIO_IRQ_BASE + AR71XX_GPIO_IRQ_COUNT; i++)
+		irq_set_chip_and_handler(i, &ar71xx_gpio_irq_chip,
 					 handle_level_irq);
-	}
 
 	setup_irq(AR71XX_MISC_IRQ_GPIO, &ar71xx_gpio_irqaction);
 }
@@ -146,17 +130,31 @@ static void ar71xx_misc_irq_dispatch(void)
 	else if (pending & MISC_INT_WDOG)
 		do_IRQ(AR71XX_MISC_IRQ_WDOG);
 
+	else if (pending & MISC_INT_TIMER2)
+		do_IRQ(AR71XX_MISC_IRQ_TIMER2);
+
+	else if (pending & MISC_INT_TIMER3)
+		do_IRQ(AR71XX_MISC_IRQ_TIMER3);
+
+	else if (pending & MISC_INT_TIMER4)
+		do_IRQ(AR71XX_MISC_IRQ_TIMER4);
+
+	else if (pending & MISC_INT_DDR_PERF)
+		do_IRQ(AR71XX_MISC_IRQ_DDR_PERF);
+
+	else if (pending & MISC_INT_ENET_LINK)
+		do_IRQ(AR71XX_MISC_IRQ_ENET_LINK);
+
 	else
 		spurious_interrupt();
 }
 
-static void ar71xx_misc_irq_unmask(unsigned int irq)
+static void ar71xx_misc_irq_unmask(struct irq_data *d)
 {
+	unsigned int irq = d->irq - AR71XX_MISC_IRQ_BASE;
 	void __iomem *base = ar71xx_reset_base;
 	u32 t;
 
-	irq -= AR71XX_MISC_IRQ_BASE;
-
 	t = __raw_readl(base + AR71XX_RESET_REG_MISC_INT_ENABLE);
 	__raw_writel(t | (1 << irq), base + AR71XX_RESET_REG_MISC_INT_ENABLE);
 
@@ -164,13 +162,12 @@ static void ar71xx_misc_irq_unmask(unsigned int irq)
 	(void) __raw_readl(base + AR71XX_RESET_REG_MISC_INT_ENABLE);
 }
 
-static void ar71xx_misc_irq_mask(unsigned int irq)
+static void ar71xx_misc_irq_mask(struct irq_data *d)
 {
+	unsigned int irq = d->irq - AR71XX_MISC_IRQ_BASE;
 	void __iomem *base = ar71xx_reset_base;
 	u32 t;
 
-	irq -= AR71XX_MISC_IRQ_BASE;
-
 	t = __raw_readl(base + AR71XX_RESET_REG_MISC_INT_ENABLE);
 	__raw_writel(t & ~(1 << irq), base + AR71XX_RESET_REG_MISC_INT_ENABLE);
 
@@ -178,13 +175,12 @@ static void ar71xx_misc_irq_mask(unsigned int irq)
 	(void) __raw_readl(base + AR71XX_RESET_REG_MISC_INT_ENABLE);
 }
 
-static void ar724x_misc_irq_ack(unsigned int irq)
+static void ar724x_misc_irq_ack(struct irq_data *d)
 {
+	unsigned int irq = d->irq - AR71XX_MISC_IRQ_BASE;
 	void __iomem *base = ar71xx_reset_base;
 	u32 t;
 
-	irq -= AR71XX_MISC_IRQ_BASE;
-
 	t = __raw_readl(base + AR71XX_RESET_REG_MISC_INT_STATUS);
 	__raw_writel(t & ~(1 << irq), base + AR71XX_RESET_REG_MISC_INT_STATUS);
 
@@ -194,8 +190,8 @@ static void ar724x_misc_irq_ack(unsigned int irq)
 
 static struct irq_chip ar71xx_misc_irq_chip = {
 	.name		= "AR71XX MISC",
-	.unmask		= ar71xx_misc_irq_unmask,
-	.mask		= ar71xx_misc_irq_mask,
+	.irq_unmask	= ar71xx_misc_irq_unmask,
+	.irq_mask	= ar71xx_misc_irq_mask,
 };
 
 static struct irqaction ar71xx_misc_irqaction = {
@@ -215,23 +211,128 @@ static void __init ar71xx_misc_irq_init(void)
 	case AR71XX_SOC_AR7240:
 	case AR71XX_SOC_AR7241:
 	case AR71XX_SOC_AR7242:
-		ar71xx_misc_irq_chip.ack = ar724x_misc_irq_ack;
+	case AR71XX_SOC_AR9330:
+	case AR71XX_SOC_AR9331:
+	case AR71XX_SOC_AR9341:
+	case AR71XX_SOC_AR9342:
+	case AR71XX_SOC_AR9344:
+		ar71xx_misc_irq_chip.irq_ack = ar724x_misc_irq_ack;
 		break;
 	default:
-		ar71xx_misc_irq_chip.mask_ack = ar71xx_misc_irq_mask;
+		ar71xx_misc_irq_chip.irq_mask_ack = ar71xx_misc_irq_mask;
 		break;
 	}
 
 	for (i = AR71XX_MISC_IRQ_BASE;
-	     i < AR71XX_MISC_IRQ_BASE + AR71XX_MISC_IRQ_COUNT; i++) {
-		irq_desc[i].status = IRQ_DISABLED;
-		set_irq_chip_and_handler(i, &ar71xx_misc_irq_chip,
+	     i < AR71XX_MISC_IRQ_BASE + AR71XX_MISC_IRQ_COUNT; i++)
+		irq_set_chip_and_handler(i, &ar71xx_misc_irq_chip,
 					 handle_level_irq);
-	}
 
 	setup_irq(AR71XX_CPU_IRQ_MISC, &ar71xx_misc_irqaction);
 }
 
+static void ar934x_ip2_irq_dispatch(unsigned int irq, struct irq_desc *desc)
+{
+	u32 status;
+
+	disable_irq_nosync(irq);
+
+	status = ar71xx_reset_rr(AR934X_RESET_REG_PCIE_WMAC_INT_STATUS);
+
+	if (status & AR934X_PCIE_WMAC_INT_PCIE_ALL) {
+		ar71xx_ddr_flush(AR934X_DDR_REG_FLUSH_PCIE);
+		generic_handle_irq(AR934X_IP2_IRQ_PCIE);
+	} else if (status & AR934X_PCIE_WMAC_INT_WMAC_ALL) {
+		ar71xx_ddr_flush(AR934X_DDR_REG_FLUSH_WMAC);
+		generic_handle_irq(AR934X_IP2_IRQ_WMAC);
+	} else {
+		spurious_interrupt();
+	}
+
+	enable_irq(irq);
+}
+
+static void ar934x_ip2_irq_init(void)
+{
+	int i;
+
+	for (i = AR934X_IP2_IRQ_BASE;
+	     i < AR934X_IP2_IRQ_BASE + AR934X_IP2_IRQ_COUNT; i++)
+		irq_set_chip_and_handler(i, &dummy_irq_chip,
+					 handle_level_irq);
+
+	irq_set_chained_handler(AR71XX_CPU_IRQ_IP2, ar934x_ip2_irq_dispatch);
+}
+
+
+/*
+ * The IP2/IP3 lines are tied to a PCI/WMAC/USB device. Drivers for
+ * these devices typically allocate coherent DMA memory, however the
+ * DMA controller may still have some unsynchronized data in the FIFO.
+ * Issue a flush in the handlers to ensure that the driver sees
+ * the update.
+ */
+static void ar71xx_ip2_handler(void)
+{
+	ar71xx_ddr_flush(AR71XX_DDR_REG_FLUSH_PCI);
+	do_IRQ(AR71XX_CPU_IRQ_IP2);
+}
+
+static void ar724x_ip2_handler(void)
+{
+	ar71xx_ddr_flush(AR724X_DDR_REG_FLUSH_PCIE);
+	do_IRQ(AR71XX_CPU_IRQ_IP2);
+}
+
+static void ar913x_ip2_handler(void)
+{
+	ar71xx_ddr_flush(AR91XX_DDR_REG_FLUSH_WMAC);
+	do_IRQ(AR71XX_CPU_IRQ_IP2);
+}
+
+static void ar933x_ip2_handler(void)
+{
+	ar71xx_ddr_flush(AR933X_DDR_REG_FLUSH_WMAC);
+	do_IRQ(AR71XX_CPU_IRQ_IP2);
+}
+
+static void ar934x_ip2_handler(void)
+{
+	do_IRQ(AR71XX_CPU_IRQ_IP2);
+}
+
+static void ar71xx_ip3_handler(void)
+{
+	ar71xx_ddr_flush(AR71XX_DDR_REG_FLUSH_USB);
+	do_IRQ(AR71XX_CPU_IRQ_USB);
+}
+
+static void ar724x_ip3_handler(void)
+{
+	ar71xx_ddr_flush(AR724X_DDR_REG_FLUSH_USB);
+	do_IRQ(AR71XX_CPU_IRQ_USB);
+}
+
+static void ar913x_ip3_handler(void)
+{
+	ar71xx_ddr_flush(AR91XX_DDR_REG_FLUSH_USB);
+	do_IRQ(AR71XX_CPU_IRQ_USB);
+}
+
+static void ar933x_ip3_handler(void)
+{
+	ar71xx_ddr_flush(AR933X_DDR_REG_FLUSH_USB);
+	do_IRQ(AR71XX_CPU_IRQ_USB);
+}
+
+static void ar934x_ip3_handler(void)
+{
+	do_IRQ(AR71XX_CPU_IRQ_USB);
+}
+
+static void (*ip2_handler)(void);
+static void (*ip3_handler)(void);
+
 asmlinkage void plat_irq_dispatch(void)
 {
 	unsigned long pending;
@@ -241,17 +342,8 @@ asmlinkage void plat_irq_dispatch(void)
 	if (pending & STATUSF_IP7)
 		do_IRQ(AR71XX_CPU_IRQ_TIMER);
 
-	else if (pending & STATUSF_IP2) {
-		/*
-		 * This IRQ is meant for a PCI device. Drivers for PCI devices
-		 * typically allocate coherent DMA memory for the descriptor
-		 * ring, however the DMA controller may still have some
-		 * unsynchronized data in the FIFO.
-		 * Issue a flush here to ensure that the driver sees the update.
-		 */
-		ar71xx_ddr_flush(ip2_flush_reg);
-		do_IRQ(AR71XX_CPU_IRQ_IP2);
-	}
+	else if (pending & STATUSF_IP2)
+		ip2_handler();
 
 	else if (pending & STATUSF_IP4)
 		do_IRQ(AR71XX_CPU_IRQ_GE0);
@@ -260,7 +352,7 @@ asmlinkage void plat_irq_dispatch(void)
 		do_IRQ(AR71XX_CPU_IRQ_GE1);
 
 	else if (pending & STATUSF_IP3)
-		do_IRQ(AR71XX_CPU_IRQ_USB);
+		ip3_handler();
 
 	else if (pending & STATUSF_IP6)
 		ar71xx_misc_irq_dispatch();
@@ -271,24 +363,53 @@ asmlinkage void plat_irq_dispatch(void)
 
 void __init arch_init_irq(void)
 {
-	switch(ar71xx_soc) {
+	switch (ar71xx_soc) {
+	case AR71XX_SOC_AR7130:
+	case AR71XX_SOC_AR7141:
+	case AR71XX_SOC_AR7161:
+		ip2_handler = ar71xx_ip2_handler;
+		ip3_handler = ar71xx_ip3_handler;
+		break;
+
 	case AR71XX_SOC_AR7240:
 	case AR71XX_SOC_AR7241:
 	case AR71XX_SOC_AR7242:
-		ip2_flush_reg = AR724X_DDR_REG_FLUSH_PCIE;
+		ip2_handler = ar724x_ip2_handler;
+		ip3_handler = ar724x_ip3_handler;
 		break;
+
 	case AR71XX_SOC_AR9130:
 	case AR71XX_SOC_AR9132:
-		ip2_flush_reg = AR91XX_DDR_REG_FLUSH_WMAC;
+		ip2_handler = ar913x_ip2_handler;
+		ip3_handler = ar913x_ip3_handler;
 		break;
-	default:
-		ip2_flush_reg = AR71XX_DDR_REG_FLUSH_PCI;
+
+	case AR71XX_SOC_AR9330:
+	case AR71XX_SOC_AR9331:
+		ip2_handler = ar933x_ip2_handler;
+		ip3_handler = ar933x_ip3_handler;
+		break;
+
+	case AR71XX_SOC_AR9341:
+	case AR71XX_SOC_AR9342:
+	case AR71XX_SOC_AR9344:
+		ip2_handler = ar934x_ip2_handler;
+		ip3_handler = ar934x_ip3_handler;
 		break;
+
+	default:
+		BUG();
 	}
+
 	mips_cpu_irq_init();
 
 	ar71xx_misc_irq_init();
 
+	if (ar71xx_soc == AR71XX_SOC_AR9341 ||
+	    ar71xx_soc == AR71XX_SOC_AR9342 ||
+	    ar71xx_soc == AR71XX_SOC_AR9344)
+		ar934x_ip2_irq_init();
+
 	cp0_perfcount_irq = AR71XX_MISC_IRQ_PERFC;
 
 	ar71xx_gpio_irq_init();
diff --git a/arch/mips/ar71xx/mach-all0258n.c b/arch/mips/ar71xx/mach-all0258n.c
new file mode 100644
index 0000000..18d0a93
--- /dev/null
+++ b/arch/mips/ar71xx/mach-all0258n.c
@@ -0,0 +1,140 @@
+/*
+ *  Allnet ALL0258N support
+ *
+ *  Copyright (C) 2011 Daniel Golle <dgolle@allnet.de>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <linux/platform_device.h>
+#include <asm/mach-ar71xx/ar71xx.h>
+
+#include "machtype.h"
+#include "devices.h"
+#include "dev-m25p80.h"
+#include "dev-ap91-pci.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+
+/* found via /sys/gpio/... try and error */
+#define ALL0258N_GPIO_BTN_RESET		1
+#define ALL0258N_GPIO_LED_RSSIHIGH	13
+#define ALL0258N_GPIO_LED_RSSIMEDIUM	15
+#define ALL0258N_GPIO_LED_RSSILOW	14
+
+/* defaults taken from others machs */
+#define ALL0258N_KEYS_POLL_INTERVAL	20	/* msecs */
+#define ALL0258N_KEYS_DEBOUNCE_INTERVAL (3 * ALL0258N_KEYS_POLL_INTERVAL)
+
+/* showed up in the original firmware's bootlog */
+#define ALL0258N_SEC_PHYMASK BIT(3)
+
+/*
+ * from U-Boot bootargs of original firmware:
+ * mtdparts=ar7240-nor0:256k(u-boot),64k(u-boot-env),320k(custom),1024k(kernel),4928k(rootfs),1536k(failsafe),64k(ART)
+ * we use a more OpenWrt-friendly layout now:
+ * mtdparts=ar7240-nor0:256k(u-boot),64k(u-boot-env),896k(kernel),5376k(rootfs),1536k(failsafe),64k(ART)
+ */
+#ifdef CONFIG_MTD_PARTITIONS
+static struct mtd_partition all0258n_partitions[] = {
+	{
+		.name		= "u-boot",
+		.offset		= 0,
+		.size		= 0x040000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "u-boot-env",
+		.offset		= 0x040000,
+		.size		= 0x010000,
+	}, {
+		.name		= "kernel",
+		.offset		= 0x050000,
+		.size		= 0x0E0000,
+	}, {
+		.name		= "rootfs",
+		.offset		= 0x130000,
+		.size		= 0x540000,
+	}, {
+		.name		= "failsafe",
+		.offset		= 0x670000,
+		.size		= 0x180000,
+	}, {
+		.name		= "firmware",
+		.offset		= 0x050000,
+		.size		= 0x620000,
+	}, {
+		.name		= "art",
+		.offset		= 0x7F0000,
+		.size		= 0x010000,
+		.mask_flags	= MTD_WRITEABLE,
+	}
+};
+#endif /* CONFIG_MTD_PARTITIONS */
+
+static struct flash_platform_data all0258n_flash_data = {
+#ifdef CONFIG_MTD_PARTITIONS
+	.parts		= all0258n_partitions,
+	.nr_parts	= ARRAY_SIZE(all0258n_partitions),
+#endif
+};
+
+static struct gpio_led all0258n_leds_gpio[] __initdata = {
+	{
+		.name		= "all0258n:green:rssihigh",
+		.gpio		= ALL0258N_GPIO_LED_RSSIHIGH,
+		.active_low	= 1,
+	}, {
+		.name		= "all0258n:yellow:rssimedium",
+		.gpio		= ALL0258N_GPIO_LED_RSSIMEDIUM,
+		.active_low	= 1,
+	}, {
+		.name		= "all0258n:red:rssilow",
+		.gpio		= ALL0258N_GPIO_LED_RSSILOW,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button all0258n_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = ALL0258N_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= ALL0258N_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}
+};
+
+static void __init all0258n_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f7f0000);
+	u8 *ee =  (u8 *) KSEG1ADDR(0x1f7f1000);
+
+	ar71xx_add_device_m25p80(&all0258n_flash_data);
+
+	ar71xx_add_device_leds_gpio(-1, ARRAY_SIZE(all0258n_leds_gpio),
+					all0258n_leds_gpio);
+
+	ar71xx_register_gpio_keys_polled(-1, ALL0258N_KEYS_POLL_INTERVAL,
+					 ARRAY_SIZE(all0258n_gpio_keys),
+					 all0258n_gpio_keys);
+
+	ar71xx_init_mac(ar71xx_eth0_data.mac_addr, mac, 0);
+	ar71xx_init_mac(ar71xx_eth1_data.mac_addr, mac, 0);
+
+	ar71xx_eth1_data.phy_mask = ALL0258N_SEC_PHYMASK;
+
+	ar71xx_add_device_mdio(0, 0x0);
+
+	ar71xx_add_device_eth(0);
+	ar71xx_add_device_eth(1);
+
+	ap91_pci_init(ee, mac);
+}
+
+MIPS_MACHINE(AR71XX_MACH_ALL0258N, "ALL0258N", "Allnet ALL0258N",
+	     all0258n_setup);
diff --git a/arch/mips/ar71xx/mach-ap121.c b/arch/mips/ar71xx/mach-ap121.c
new file mode 100644
index 0000000..d14996f
--- /dev/null
+++ b/arch/mips/ar71xx/mach-ap121.c
@@ -0,0 +1,237 @@
+/*
+ *  Atheros AP121 board support
+ *
+ *  Copyright (C) 2011 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <linux/spi/flash.h>
+
+#include "machtype.h"
+#include "devices.h"
+#include "dev-ar9xxx-wmac.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+
+#define AP121_GPIO_LED_WLAN		0
+#define AP121_GPIO_LED_USB		1
+
+#define AP121_GPIO_BTN_JUMPSTART	11
+#define AP121_GPIO_BTN_RESET		12
+
+#define AP121_KEYS_POLL_INTERVAL	20	/* msecs */
+#define AP121_KEYS_DEBOUNCE_INTERVAL	(3 * AP121_KEYS_POLL_INTERVAL)
+
+#define AP121_MAC0_OFFSET	0x0000
+#define AP121_MAC1_OFFSET	0x0006
+#define AP121_CALDATA_OFFSET	0x1000
+#define AP121_WMAC_MAC_OFFSET	0x1002
+
+#define AP121_MINI_GPIO_LED_WLAN	0
+#define AP121_MINI_GPIO_BTN_JUMPSTART	12
+#define AP121_MINI_GPIO_BTN_RESET	11
+
+#ifdef CONFIG_MTD_PARTITIONS
+static struct mtd_partition ap121_parts[] = {
+	{
+		.name		= "u-boot",
+		.offset		= 0,
+		.size		= 0x010000,
+		.mask_flags	= MTD_WRITEABLE,
+	},
+	{
+		.name		= "rootfs",
+		.offset		= 0x010000,
+		.size		= 0x130000,
+	},
+	{
+		.name		= "uImage",
+		.offset		= 0x140000,
+		.size		= 0x0a0000,
+	},
+	{
+		.name		= "NVRAM",
+		.offset		= 0x1e0000,
+		.size		= 0x010000,
+	},
+	{
+		.name		= "ART",
+		.offset		= 0x1f0000,
+		.size		= 0x010000,
+		.mask_flags	= MTD_WRITEABLE,
+	},
+};
+#define ap121_nr_parts		ARRAY_SIZE(ap121_parts)
+
+static struct mtd_partition ap121_mini_parts[] = {
+	{
+		.name		= "u-boot",
+		.offset		= 0,
+		.size		= 0x040000,
+		.mask_flags	= MTD_WRITEABLE,
+	},
+	{
+		.name		= "u-boot-env",
+		.offset		= 0x040000,
+		.size		= 0x010000,
+		.mask_flags	= MTD_WRITEABLE,
+	},
+	{
+		.name		= "rootfs",
+		.offset		= 0x050000,
+		.size		= 0x2b0000,
+	},
+	{
+		.name		= "uImage",
+		.offset		= 0x300000,
+		.size		= 0x0e0000,
+	},
+	{
+		.name		= "NVRAM",
+		.offset		= 0x3e0000,
+		.size		= 0x010000,
+	},
+	{
+		.name		= "ART",
+		.offset		= 0x3f0000,
+		.size		= 0x010000,
+		.mask_flags	= MTD_WRITEABLE,
+	},
+};
+
+#define ap121_mini_nr_parts	ARRAY_SIZE(ap121_parts)
+
+#else
+#define ap121_parts		NULL
+#define ap121_nr_parts		0
+#define ap121_mini_parts	NULL
+#define ap121_mini_nr_parts	0
+#endif /* CONFIG_MTD_PARTITIONS */
+
+static struct flash_platform_data ap121_flash_data = {
+	.parts		= ap121_parts,
+	.nr_parts	= ap121_nr_parts,
+};
+
+static struct gpio_led ap121_leds_gpio[] __initdata = {
+	{
+		.name		= "ap121:green:usb",
+		.gpio		= AP121_GPIO_LED_USB,
+		.active_low	= 0,
+	},
+	{
+		.name		= "ap121:green:wlan",
+		.gpio		= AP121_GPIO_LED_WLAN,
+		.active_low	= 0,
+	},
+};
+
+static struct gpio_keys_button ap121_gpio_keys[] __initdata = {
+	{
+		.desc		= "jumpstart button",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = AP121_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= AP121_GPIO_BTN_JUMPSTART,
+		.active_low	= 1,
+	},
+	{
+		.desc		= "reset button",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = AP121_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= AP121_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_led ap121_mini_leds_gpio[] __initdata = {
+	{
+		.name		= "ap121:green:wlan",
+		.gpio		= AP121_MINI_GPIO_LED_WLAN,
+		.active_low	= 0,
+	},
+};
+
+static struct gpio_keys_button ap121_mini_gpio_keys[] __initdata = {
+	{
+		.desc		= "jumpstart button",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = AP121_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= AP121_MINI_GPIO_BTN_JUMPSTART,
+		.active_low	= 1,
+	},
+	{
+		.desc		= "reset button",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = AP121_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= AP121_MINI_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}
+};
+
+static void __init ap121_common_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+
+	ar71xx_add_device_m25p80(&ap121_flash_data);
+
+	ar71xx_init_mac(ar71xx_eth0_data.mac_addr, art + AP121_MAC0_OFFSET, 0);
+	ar71xx_init_mac(ar71xx_eth1_data.mac_addr, art + AP121_MAC1_OFFSET, 0);
+
+	ar71xx_add_device_mdio(0, 0x0);
+
+	/* LAN ports */
+	ar71xx_add_device_eth(1);
+
+	/* WAN port */
+	ar71xx_add_device_eth(0);
+
+	ar9xxx_add_device_wmac(art + AP121_CALDATA_OFFSET,
+			       art + AP121_WMAC_MAC_OFFSET);
+}
+
+static void __init ap121_setup(void)
+{
+	ap121_flash_data.parts = ap121_parts;
+	ap121_flash_data.nr_parts = ap121_nr_parts;
+
+	ap121_common_setup();
+
+	ar71xx_add_device_leds_gpio(-1, ARRAY_SIZE(ap121_leds_gpio),
+					ap121_leds_gpio);
+	ar71xx_register_gpio_keys_polled(-1, AP121_KEYS_POLL_INTERVAL,
+					 ARRAY_SIZE(ap121_gpio_keys),
+					 ap121_gpio_keys);
+
+	ar71xx_add_device_usb();
+}
+
+static void __init ap121_mini_setup(void)
+{
+	ap121_flash_data.parts = ap121_mini_parts;
+	ap121_flash_data.nr_parts = ap121_mini_nr_parts;
+
+	ar71xx_add_device_leds_gpio(-1, ARRAY_SIZE(ap121_mini_leds_gpio),
+					ap121_mini_leds_gpio);
+	ar71xx_register_gpio_keys_polled(-1, AP121_KEYS_POLL_INTERVAL,
+					 ARRAY_SIZE(ap121_mini_gpio_keys),
+					 ap121_mini_gpio_keys);
+
+	ap121_common_setup();
+}
+
+MIPS_MACHINE(AR71XX_MACH_AP121, "AP121", "Atheros AP121",
+	     ap121_setup);
+
+MIPS_MACHINE(AR71XX_MACH_AP121_MINI, "AP121-MINI", "Atheros AP121-MINI",
+	     ap121_mini_setup);
diff --git a/arch/mips/ar71xx/mach-ap81.c b/arch/mips/ar71xx/mach-ap81.c
index cd865b0..802dbec 100644
--- a/arch/mips/ar71xx/mach-ap81.c
+++ b/arch/mips/ar71xx/mach-ap81.c
@@ -17,7 +17,7 @@
 #include "machtype.h"
 #include "devices.h"
 #include "dev-m25p80.h"
-#include "dev-ar913x-wmac.h"
+#include "dev-ar9xxx-wmac.h"
 #include "dev-gpio-buttons.h"
 #include "dev-leds-gpio.h"
 #include "dev-usb.h"
@@ -30,7 +30,8 @@
 #define AP81_GPIO_BTN_SW4	12
 #define AP81_GPIO_BTN_SW1	21
 
-#define AP81_BUTTONS_POLL_INTERVAL	20
+#define AP81_KEYS_POLL_INTERVAL		20 /* msecs */
+#define AP81_KEYS_DEBOUNCE_INTERVAL	(3 * AP81_KEYS_POLL_INTERVAL)
 
 #ifdef CONFIG_MTD_PARTITIONS
 static struct mtd_partition ap81_partitions[] = {
@@ -39,19 +40,19 @@ static struct mtd_partition ap81_partitions[] = {
 		.offset		= 0,
 		.size		= 0x040000,
 		.mask_flags	= MTD_WRITEABLE,
-	} , {
+	}, {
 		.name		= "u-boot-env",
 		.offset		= 0x040000,
 		.size		= 0x010000,
-	} , {
+	}, {
 		.name		= "rootfs",
 		.offset		= 0x050000,
 		.size		= 0x500000,
-	} , {
+	}, {
 		.name		= "uImage",
 		.offset		= 0x550000,
 		.size		= 0x100000,
-	} , {
+	}, {
 		.name		= "ART",
 		.offset		= 0x650000,
 		.size		= 0x1b0000,
@@ -62,8 +63,8 @@ static struct mtd_partition ap81_partitions[] = {
 
 static struct flash_platform_data ap81_flash_data = {
 #ifdef CONFIG_MTD_PARTITIONS
-        .parts          = ap81_partitions,
-        .nr_parts       = ARRAY_SIZE(ap81_partitions),
+	.parts		= ap81_partitions,
+	.nr_parts	= ARRAY_SIZE(ap81_partitions),
 #endif
 };
 
@@ -87,19 +88,19 @@ static struct gpio_led ap81_leds_gpio[] __initdata = {
 	}
 };
 
-static struct gpio_button ap81_gpio_buttons[] __initdata = {
+static struct gpio_keys_button ap81_gpio_keys[] __initdata = {
 	{
 		.desc		= "sw1",
 		.type		= EV_KEY,
 		.code		= BTN_0,
-		.threshold	= 3,
+		.debounce_interval = AP81_KEYS_DEBOUNCE_INTERVAL,
 		.gpio		= AP81_GPIO_BTN_SW1,
 		.active_low	= 1,
-	} , {
+	}, {
 		.desc		= "sw4",
 		.type		= EV_KEY,
 		.code		= BTN_1,
-		.threshold	= 3,
+		.debounce_interval = AP81_KEYS_DEBOUNCE_INTERVAL,
 		.gpio		= AP81_GPIO_BTN_SW4,
 		.active_low	= 1,
 	}
@@ -109,14 +110,15 @@ static void __init ap81_setup(void)
 {
 	u8 *eeprom = (u8 *) KSEG1ADDR(0x1fff1000);
 
-	ar71xx_set_mac_base(eeprom);
-	ar71xx_add_device_mdio(0x0);
+	ar71xx_add_device_mdio(0, 0x0);
 
+	ar71xx_init_mac(ar71xx_eth0_data.mac_addr, eeprom, 0);
 	ar71xx_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
 	ar71xx_eth0_data.speed = SPEED_100;
 	ar71xx_eth0_data.duplex = DUPLEX_FULL;
 	ar71xx_eth0_data.has_ar8216 = 1;
 
+	ar71xx_init_mac(ar71xx_eth1_data.mac_addr, eeprom, 1);
 	ar71xx_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
 	ar71xx_eth1_data.phy_mask = 0x10;
 
@@ -130,11 +132,11 @@ static void __init ap81_setup(void)
 	ar71xx_add_device_leds_gpio(-1, ARRAY_SIZE(ap81_leds_gpio),
 					ap81_leds_gpio);
 
-	ar71xx_add_device_gpio_buttons(-1, AP81_BUTTONS_POLL_INTERVAL,
-					ARRAY_SIZE(ap81_gpio_buttons),
-					ap81_gpio_buttons);
+	ar71xx_register_gpio_keys_polled(-1, AP81_KEYS_POLL_INTERVAL,
+					 ARRAY_SIZE(ap81_gpio_keys),
+					 ap81_gpio_keys);
 
-	ar913x_add_device_wmac(eeprom, NULL);
+	ar9xxx_add_device_wmac(eeprom, NULL);
 }
 
 MIPS_MACHINE(AR71XX_MACH_AP81, "AP81", "Atheros AP81", ap81_setup);
diff --git a/arch/mips/ar71xx/mach-ap83.c b/arch/mips/ar71xx/mach-ap83.c
index 9aa17dc..2eab994 100644
--- a/arch/mips/ar71xx/mach-ap83.c
+++ b/arch/mips/ar71xx/mach-ap83.c
@@ -22,7 +22,7 @@
 
 #include "machtype.h"
 #include "devices.h"
-#include "dev-ar913x-wmac.h"
+#include "dev-ar9xxx-wmac.h"
 #include "dev-gpio-buttons.h"
 #include "dev-leds-gpio.h"
 #include "dev-usb.h"
@@ -38,7 +38,8 @@
 #define AP83_050_GPIO_VSC7385_MOSI	16
 #define AP83_050_GPIO_VSC7385_SCK	17
 
-#define AP83_BUTTONS_POLL_INTERVAL	20
+#define AP83_KEYS_POLL_INTERVAL		20	/* msecs */
+#define AP83_KEYS_DEBOUNCE_INTERVAL	(3 * AP83_KEYS_POLL_INTERVAL)
 
 #ifdef CONFIG_MTD_PARTITIONS
 static struct mtd_partition ap83_flash_partitions[] = {
@@ -47,25 +48,25 @@ static struct mtd_partition ap83_flash_partitions[] = {
 		.offset		= 0,
 		.size		= 0x040000,
 		.mask_flags	= MTD_WRITEABLE,
-	} , {
+	}, {
 		.name		= "u-boot-env",
 		.offset		= 0x040000,
 		.size		= 0x020000,
 		.mask_flags	= MTD_WRITEABLE,
-	} , {
+	}, {
 		.name		= "kernel",
 		.offset		= 0x060000,
 		.size		= 0x140000,
-	} , {
+	}, {
 		.name		= "rootfs",
 		.offset		= 0x1a0000,
 		.size		= 0x650000,
-	} , {
+	}, {
 		.name		= "art",
 		.offset		= 0x7f0000,
 		.size		= 0x010000,
 		.mask_flags	= MTD_WRITEABLE,
-	} , {
+	}, {
 		.name		= "firmware",
 		.offset		= 0x060000,
 		.size		= 0x790000,
@@ -76,8 +77,8 @@ static struct mtd_partition ap83_flash_partitions[] = {
 static struct ar91xx_flash_platform_data ap83_flash_data = {
 	.width		= 2,
 #ifdef CONFIG_MTD_PARTITIONS
-        .parts          = ap83_flash_partitions,
-        .nr_parts       = ARRAY_SIZE(ap83_flash_partitions),
+	.parts		= ap83_flash_partitions,
+	.nr_parts	= ARRAY_SIZE(ap83_flash_partitions),
 #endif
 };
 
@@ -115,19 +116,19 @@ static struct gpio_led ap83_leds_gpio[] __initdata = {
 	},
 };
 
-static struct gpio_button ap83_gpio_buttons[] __initdata = {
+static struct gpio_keys_button ap83_gpio_keys[] __initdata = {
 	{
 		.desc		= "soft_reset",
 		.type		= EV_KEY,
-		.code		= BTN_0,
-		.threshold	= 3,
+		.code		= KEY_RESTART,
+		.debounce_interval = AP83_KEYS_DEBOUNCE_INTERVAL,
 		.gpio		= AP83_GPIO_BTN_RESET,
 		.active_low	= 1,
-	} , {
+	}, {
 		.desc		= "jumpstart",
 		.type		= EV_KEY,
-		.code		= BTN_1,
-		.threshold	= 3,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = AP83_KEYS_DEBOUNCE_INTERVAL,
 		.gpio		= AP83_GPIO_BTN_JUMPSTART,
 		.active_low	= 1,
 	}
@@ -196,15 +197,15 @@ static void __init ap83_generic_setup(void)
 {
 	u8 *eeprom = (u8 *) KSEG1ADDR(0x1fff1000);
 
-	ar71xx_set_mac_base(eeprom);
-
-	ar71xx_add_device_mdio(0xfffffffe);
+	ar71xx_add_device_mdio(0, 0xfffffffe);
 
+	ar71xx_init_mac(ar71xx_eth0_data.mac_addr, eeprom, 0);
 	ar71xx_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
 	ar71xx_eth0_data.phy_mask = 0x1;
 
 	ar71xx_add_device_eth(0);
 
+	ar71xx_init_mac(ar71xx_eth1_data.mac_addr, eeprom, 1);
 	ar71xx_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
 	ar71xx_eth1_data.speed = SPEED_1000;
 	ar71xx_eth1_data.duplex = DUPLEX_FULL;
@@ -216,13 +217,13 @@ static void __init ap83_generic_setup(void)
 	ar71xx_add_device_leds_gpio(-1, ARRAY_SIZE(ap83_leds_gpio),
 					ap83_leds_gpio);
 
-	ar71xx_add_device_gpio_buttons(-1, AP83_BUTTONS_POLL_INTERVAL,
-					ARRAY_SIZE(ap83_gpio_buttons),
-					ap83_gpio_buttons);
+	ar71xx_register_gpio_keys_polled(-1, AP83_KEYS_POLL_INTERVAL,
+					 ARRAY_SIZE(ap83_gpio_keys),
+					 ap83_gpio_keys);
 
 	ar71xx_add_device_usb();
 
-	ar913x_add_device_wmac(eeprom, NULL);
+	ar9xxx_add_device_wmac(eeprom, NULL);
 
 	platform_device_register(&ap83_flash_device);
 
@@ -231,7 +232,7 @@ static void __init ap83_generic_setup(void)
 
 static void __init ap83_040_setup(void)
 {
-	ap83_flash_data.is_shared=1;
+	ap83_flash_data.is_shared = 1;
 	ap83_generic_setup();
 	platform_device_register(&ap83_040_spi_device);
 }
diff --git a/arch/mips/ar71xx/mach-ap96.c b/arch/mips/ar71xx/mach-ap96.c
new file mode 100644
index 0000000..5882af2
--- /dev/null
+++ b/arch/mips/ar71xx/mach-ap96.c
@@ -0,0 +1,180 @@
+/*
+ *  Atheros AP96 board support
+ *
+ *  Copyright (C) 2009 Marco Porsch
+ *  Copyright (C) 2009-2010 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2010 Atheros Communications
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/platform_device.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <linux/delay.h>
+
+#include <asm/mach-ar71xx/ar71xx.h>
+
+#include "machtype.h"
+#include "devices.h"
+#include "dev-m25p80.h"
+#include "dev-ap94-pci.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-usb.h"
+
+#define AP96_GPIO_LED_12_GREEN		0
+#define AP96_GPIO_LED_3_GREEN		1
+#define AP96_GPIO_LED_2_GREEN		2
+#define AP96_GPIO_LED_WPS_GREEN		4
+#define AP96_GPIO_LED_5_GREEN		5
+#define AP96_GPIO_LED_4_ORANGE		6
+
+/* Reset button - next to the power connector */
+#define AP96_GPIO_BTN_RESET		3
+/* WPS button - next to a led on right */
+#define AP96_GPIO_BTN_WPS		8
+
+#define AP96_KEYS_POLL_INTERVAL		20	/* msecs */
+#define AP96_KEYS_DEBOUNCE_INTERVAL	(3 * AP96_KEYS_POLL_INTERVAL)
+
+#define AP96_WMAC0_MAC_OFFSET		0x120c
+#define AP96_WMAC1_MAC_OFFSET		0x520c
+#define AP96_CALDATA0_OFFSET		0x1000
+#define AP96_CALDATA1_OFFSET		0x5000
+
+#ifdef CONFIG_MTD_PARTITIONS
+static struct mtd_partition ap96_partitions[] = {
+	{
+		.name		= "uboot",
+		.offset		= 0,
+		.size		= 0x030000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "env",
+		.offset		= 0x030000,
+		.size		= 0x010000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "rootfs",
+		.offset		= 0x040000,
+		.size		= 0x600000,
+	}, {
+		.name		= "uImage",
+		.offset		= 0x640000,
+		.size		= 0x1b0000,
+	}, {
+		.name		= "caldata",
+		.offset		= 0x7f0000,
+		.size		= 0x010000,
+		.mask_flags	= MTD_WRITEABLE,
+	}
+};
+#endif /* CONFIG_MTD_PARTITIONS */
+
+static struct flash_platform_data ap96_flash_data = {
+#ifdef CONFIG_MTD_PARTITIONS
+	.parts		= ap96_partitions,
+	.nr_parts	= ARRAY_SIZE(ap96_partitions),
+#endif
+};
+
+/*
+ * AP96 has 12 unlabeled leds in the front; these are numbered from 1 to 12
+ * below (from left to right on the board). Led 1 seems to be on whenever the
+ * board is powered. Led 11 shows LAN link activity actity. Led 3 is orange;
+ * others are green.
+ *
+ * In addition, there is one led next to a button on the right side for WPS.
+ */
+static struct gpio_led ap96_leds_gpio[] __initdata = {
+	{
+		.name		= "ap96:green:led2",
+		.gpio		= AP96_GPIO_LED_2_GREEN,
+		.active_low	= 1,
+	}, {
+		.name		= "ap96:green:led3",
+		.gpio		= AP96_GPIO_LED_3_GREEN,
+		.active_low	= 1,
+	}, {
+		.name		= "ap96:orange:led4",
+		.gpio		= AP96_GPIO_LED_4_ORANGE,
+		.active_low	= 1,
+	}, {
+		.name		= "ap96:green:led5",
+		.gpio		= AP96_GPIO_LED_5_GREEN,
+		.active_low	= 1,
+	}, {
+		.name		= "ap96:green:led12",
+		.gpio		= AP96_GPIO_LED_12_GREEN,
+		.active_low	= 1,
+	}, { /* next to a button on right */
+		.name		= "ap96:green:wps",
+		.gpio		= AP96_GPIO_LED_WPS_GREEN,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button ap96_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = AP96_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= AP96_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}, {
+		.desc		= "wps",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = AP96_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= AP96_GPIO_BTN_WPS,
+		.active_low	= 1,
+	}
+};
+
+#define AP96_WAN_PHYMASK 0x10
+#define AP96_LAN_PHYMASK 0x0f
+
+static void __init ap96_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+
+	ar71xx_add_device_mdio(0, ~(AP96_WAN_PHYMASK | AP96_LAN_PHYMASK));
+
+	ar71xx_init_mac(ar71xx_eth0_data.mac_addr, art, 0);
+	ar71xx_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ar71xx_eth0_data.phy_mask = AP96_LAN_PHYMASK;
+	ar71xx_eth0_data.speed = SPEED_1000;
+	ar71xx_eth0_data.duplex = DUPLEX_FULL;
+
+	ar71xx_add_device_eth(0);
+
+	ar71xx_init_mac(ar71xx_eth1_data.mac_addr, art, 1);
+	ar71xx_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ar71xx_eth1_data.phy_mask = AP96_WAN_PHYMASK;
+
+	ar71xx_eth1_pll_data.pll_1000 = 0x1f000000;
+
+	ar71xx_add_device_eth(1);
+
+	ar71xx_add_device_usb();
+
+	ar71xx_add_device_m25p80(&ap96_flash_data);
+
+	ar71xx_add_device_leds_gpio(-1, ARRAY_SIZE(ap96_leds_gpio),
+					ap96_leds_gpio);
+
+	ar71xx_register_gpio_keys_polled(-1, AP96_KEYS_POLL_INTERVAL,
+					 ARRAY_SIZE(ap96_gpio_keys),
+					 ap96_gpio_keys);
+
+	ap94_pci_init(art + AP96_CALDATA0_OFFSET,
+		      art + AP96_WMAC0_MAC_OFFSET,
+		      art + AP96_CALDATA1_OFFSET,
+		      art + AP96_WMAC1_MAC_OFFSET);
+}
+
+MIPS_MACHINE(AR71XX_MACH_AP96, "AP96", "Atheros AP96", ap96_setup);
diff --git a/arch/mips/ar71xx/mach-aw-nr580.c b/arch/mips/ar71xx/mach-aw-nr580.c
index b9b037a..e99536c 100644
--- a/arch/mips/ar71xx/mach-aw-nr580.c
+++ b/arch/mips/ar71xx/mach-aw-nr580.c
@@ -31,7 +31,8 @@
 #define AW_NR580_GPIO_BTN_WPS		3
 #define AW_NR580_GPIO_BTN_RESET		11
 
-#define AW_NR580_BUTTONS_POLL_INTERVAL	20
+#define AW_NR580_KEYS_POLL_INTERVAL	20	/* msecs */
+#define AW_NR580_KEYS_DEBOUNCE_INTERVAL	(3 * AW_NR580_KEYS_POLL_INTERVAL)
 
 static struct gpio_led aw_nr580_leds_gpio[] __initdata = {
 	{
@@ -57,19 +58,19 @@ static struct gpio_led aw_nr580_leds_gpio[] __initdata = {
 	}
 };
 
-static struct gpio_button aw_nr580_gpio_buttons[] __initdata = {
+static struct gpio_keys_button aw_nr580_gpio_keys[] __initdata = {
 	{
 		.desc		= "reset",
 		.type		= EV_KEY,
-		.code		= BTN_0,
-		.threshold	= 3,
+		.code		= KEY_RESTART,
+		.debounce_interval = AW_NR580_KEYS_DEBOUNCE_INTERVAL,
 		.gpio		= AW_NR580_GPIO_BTN_RESET,
 		.active_low	= 1,
 	}, {
 		.desc		= "wps",
 		.type		= EV_KEY,
-		.code		= BTN_1,
-		.threshold	= 3,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = AW_NR580_KEYS_DEBOUNCE_INTERVAL,
 		.gpio		= AW_NR580_GPIO_BTN_WPS,
 		.active_low	= 1,
 	}
@@ -77,7 +78,7 @@ static struct gpio_button aw_nr580_gpio_buttons[] __initdata = {
 
 static void __init aw_nr580_setup(void)
 {
-	ar71xx_add_device_mdio(0x0);
+	ar71xx_add_device_mdio(0, 0x0);
 
 	ar71xx_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
 	ar71xx_eth0_data.speed = SPEED_100;
@@ -92,9 +93,9 @@ static void __init aw_nr580_setup(void)
 	ar71xx_add_device_leds_gpio(-1, ARRAY_SIZE(aw_nr580_leds_gpio),
 					aw_nr580_leds_gpio);
 
-	ar71xx_add_device_gpio_buttons(-1, AW_NR580_BUTTONS_POLL_INTERVAL,
-					ARRAY_SIZE(aw_nr580_gpio_buttons),
-					aw_nr580_gpio_buttons);
+	ar71xx_register_gpio_keys_polled(-1, AW_NR580_KEYS_POLL_INTERVAL,
+					 ARRAY_SIZE(aw_nr580_gpio_keys),
+					 aw_nr580_gpio_keys);
 }
 
 MIPS_MACHINE(AR71XX_MACH_AW_NR580, "AW-NR580", "AzureWave AW-NR580",
diff --git a/arch/mips/ar71xx/mach-db120.c b/arch/mips/ar71xx/mach-db120.c
new file mode 100644
index 0000000..b997f3c
--- /dev/null
+++ b/arch/mips/ar71xx/mach-db120.c
@@ -0,0 +1,156 @@
+/*
+ *  Atheros DB120 board (WASP SoC) support
+ *
+ *  Copyright (C) 2010-2011 Jaiganesh Narayanan <jnarayanan@atheros.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/mach-ar71xx/ar71xx.h>
+
+#include "machtype.h"
+#include "devices.h"
+#include "dev-m25p80.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-usb.h"
+#include "dev-ar9xxx-wmac.h"
+#include "dev-db120-pci.h"
+
+#define DB120_GPIO_LED_USB	11
+#define DB120_GPIO_LED_WLAN_5G	12
+#define DB120_GPIO_LED_WLAN_2G	13
+#define DB120_GPIO_LED_STATUS	14
+#define DB120_GPIO_LED_WPS	15
+
+#define DB120_GPIO_BTN_WPS	16
+
+#define DB120_MAC0_OFFSET	0
+#define DB120_MAC1_OFFSET	6
+#define DB120_WMAC_CALDATA_OFFSET 0x1000
+#define DB120_PCIE_CALDATA_OFFSET 0x5000
+
+#define DB120_KEYS_POLL_INTERVAL	20	/* msecs */
+#define DB120_KEYS_DEBOUNCE_INTERVAL	(3 * DB120_KEYS_POLL_INTERVAL)
+
+#ifdef CONFIG_MTD_PARTITIONS
+static struct mtd_partition db120_partitions[] = {
+	{
+		.name		= "u-boot",
+		.offset		= 0,
+		.size		= 0x040000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "u-boot-env",
+		.offset		= 0x040000,
+		.size		= 0x010000,
+	}, {
+		.name		= "rootfs",
+		.offset		= 0x050000,
+		.size		= 0x630000,
+	}, {
+		.name		= "uImage",
+		.offset		= 0x680000,
+		.size		= 0x160000,
+	}, {
+		.name		= "NVRAM",
+		.offset		= 0x7E0000,
+		.size		= 0x010000,
+	}, {
+		.name		= "ART",
+		.offset		= 0x7F0000,
+		.size		= 0x010000,
+		.mask_flags	= MTD_WRITEABLE,
+	}
+};
+#endif /* CONFIG_MTD_PARTITIONS */
+
+static struct flash_platform_data db120_flash_data = {
+#ifdef CONFIG_MTD_PARTITIONS
+	.parts		= db120_partitions,
+	.nr_parts	= ARRAY_SIZE(db120_partitions),
+#endif
+};
+
+static struct gpio_led db120_leds_gpio[] __initdata = {
+	{
+		.name		= "db120:green:status",
+		.gpio		= DB120_GPIO_LED_STATUS,
+		.active_low	= 1,
+	}, {
+		.name		= "db120:green:wps",
+		.gpio		= DB120_GPIO_LED_WPS,
+		.active_low	= 1,
+	}, {
+		.name		= "db120:green:wlan-5g",
+		.gpio		= DB120_GPIO_LED_WLAN_5G,
+		.active_low	= 1,
+	}, {
+		.name		= "db120:green:wlan-2g",
+		.gpio		= DB120_GPIO_LED_WLAN_2G,
+		.active_low	= 1,
+	}, {
+		.name		= "db120:green:usb",
+		.gpio		= DB120_GPIO_LED_USB,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button db120_gpio_keys[] __initdata = {
+	{
+		.desc		= "WPS button",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = DB120_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= DB120_GPIO_BTN_WPS,
+		.active_low	= 1,
+	}
+};
+
+static void __init db120_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+
+	ar71xx_gpio_output_select(DB120_GPIO_LED_USB, AR934X_GPIO_OUT_GPIO);
+
+	ar71xx_add_device_usb();
+
+	ar71xx_add_device_m25p80(&db120_flash_data);
+
+	ar71xx_add_device_leds_gpio(-1, ARRAY_SIZE(db120_leds_gpio),
+					db120_leds_gpio);
+
+	ar71xx_register_gpio_keys_polled(-1, DB120_KEYS_POLL_INTERVAL,
+					 ARRAY_SIZE(db120_gpio_keys),
+					 db120_gpio_keys);
+
+	ar71xx_add_device_mdio(0, 0x0);
+	ar71xx_add_device_mdio(1, 0x0);
+
+	/* GMAC0 is connected to an AR8327 switch */
+	ar71xx_init_mac(ar71xx_eth0_data.mac_addr, art + DB120_MAC0_OFFSET, 0);
+	ar71xx_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ar71xx_eth0_data.speed = SPEED_1000;
+	ar71xx_eth0_data.duplex = DUPLEX_FULL;
+
+	ar71xx_add_device_eth(0);
+
+	/* GMAC1 is connected to the internal switch */
+	ar71xx_init_mac(ar71xx_eth1_data.mac_addr, art + DB120_MAC1_OFFSET, 0);
+	ar71xx_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_GMII;
+	ar71xx_eth1_data.speed = SPEED_100;
+	ar71xx_eth1_data.duplex = DUPLEX_FULL;
+
+	ar71xx_add_device_eth(1);
+
+	ar9xxx_add_device_wmac(art + DB120_WMAC_CALDATA_OFFSET, NULL);
+
+	db120_pci_init(art + DB120_PCIE_CALDATA_OFFSET, NULL);
+}
+
+MIPS_MACHINE(AR71XX_MACH_DB120, "DB120", "Atheros DB120", db120_setup);
diff --git a/arch/mips/ar71xx/mach-dir-600-a1.c b/arch/mips/ar71xx/mach-dir-600-a1.c
index 7222405..ba833e8 100644
--- a/arch/mips/ar71xx/mach-dir-600-a1.c
+++ b/arch/mips/ar71xx/mach-dir-600-a1.c
@@ -16,7 +16,6 @@
 #include "machtype.h"
 #include "devices.h"
 #include "dev-m25p80.h"
-#include "dev-ap91-eth.h"
 #include "dev-ap91-pci.h"
 #include "dev-gpio-buttons.h"
 #include "dev-leds-gpio.h"
@@ -29,7 +28,8 @@
 #define DIR_600_A1_GPIO_BTN_RESET		8
 #define DIR_600_A1_GPIO_BTN_WPS			12
 
-#define DIR_600_A1_BUTTONS_POLL_INTERVAL	20
+#define DIR_600_A1_KEYS_POLL_INTERVAL	20	/* msecs */
+#define DIR_600_A1_KEYS_DEBOUNCE_INTERVAL (3 * DIR_600_A1_KEYS_POLL_INTERVAL)
 
 #define DIR_600_A1_NVRAM_ADDR	0x1f030000
 #define DIR_600_A1_NVRAM_SIZE	0x10000
@@ -73,8 +73,8 @@ static struct mtd_partition dir_600_a1_partitions[] = {
 
 static struct flash_platform_data dir_600_a1_flash_data = {
 #ifdef CONFIG_MTD_PARTITIONS
-        .parts          = dir_600_a1_partitions,
-        .nr_parts       = ARRAY_SIZE(dir_600_a1_partitions),
+	.parts		= dir_600_a1_partitions,
+	.nr_parts	= ARRAY_SIZE(dir_600_a1_partitions),
 #endif
 };
 
@@ -92,19 +92,19 @@ static struct gpio_led dir_600_a1_leds_gpio[] __initdata = {
 	}
 };
 
-static struct gpio_button dir_600_a1_gpio_buttons[] __initdata = {
+static struct gpio_keys_button dir_600_a1_gpio_keys[] __initdata = {
 	{
 		.desc		= "reset",
 		.type		= EV_KEY,
-		.code		= BTN_0,
-		.threshold	= 3,
+		.code		= KEY_RESTART,
+		.debounce_interval = DIR_600_A1_KEYS_DEBOUNCE_INTERVAL,
 		.gpio		= DIR_600_A1_GPIO_BTN_RESET,
 		.active_low	= 1,
 	}, {
 		.desc		= "wps",
 		.type		= EV_KEY,
-		.code		= BTN_1,
-		.threshold	= 3,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = DIR_600_A1_KEYS_DEBOUNCE_INTERVAL,
 		.gpio		= DIR_600_A1_GPIO_BTN_WPS,
 		.active_low	= 1,
 	}
@@ -118,19 +118,32 @@ static void __init dir_600_a1_setup(void)
 	u8 *mac = NULL;
 
 	if (nvram_parse_mac_addr(nvram, DIR_600_A1_NVRAM_SIZE,
-			         "lan_mac=", mac_buff) == 0)
+				"lan_mac=", mac_buff) == 0) {
+		ar71xx_init_mac(ar71xx_eth0_data.mac_addr, mac_buff, 0);
+		ar71xx_init_mac(ar71xx_eth1_data.mac_addr, mac_buff, 1);
 		mac = mac_buff;
+	}
 
 	ar71xx_add_device_m25p80(&dir_600_a1_flash_data);
 
 	ar71xx_add_device_leds_gpio(-1, ARRAY_SIZE(dir_600_a1_leds_gpio),
 					dir_600_a1_leds_gpio);
 
-	ar71xx_add_device_gpio_buttons(-1, DIR_600_A1_BUTTONS_POLL_INTERVAL,
-					ARRAY_SIZE(dir_600_a1_gpio_buttons),
-					dir_600_a1_gpio_buttons);
+	ar71xx_register_gpio_keys_polled(-1, DIR_600_A1_KEYS_POLL_INTERVAL,
+					 ARRAY_SIZE(dir_600_a1_gpio_keys),
+					 dir_600_a1_gpio_keys);
+
+	ar71xx_init_mac(ar71xx_eth0_data.mac_addr, mac, 0);
+	ar71xx_init_mac(ar71xx_eth1_data.mac_addr, mac, 1);
+
+	ar71xx_add_device_mdio(0, 0x0);
+
+	/* LAN ports */
+	ar71xx_add_device_eth(1);
+
+	/* WAN port */
+	ar71xx_add_device_eth(0);
 
-	ap91_eth_init(mac, NULL);
 	ap91_pci_init(ee, mac);
 }
 
diff --git a/arch/mips/ar71xx/mach-dir-615-c1.c b/arch/mips/ar71xx/mach-dir-615-c1.c
index 8433b0c..fcadc6f 100644
--- a/arch/mips/ar71xx/mach-dir-615-c1.c
+++ b/arch/mips/ar71xx/mach-dir-615-c1.c
@@ -17,7 +17,7 @@
 #include "machtype.h"
 #include "devices.h"
 #include "dev-m25p80.h"
-#include "dev-ar913x-wmac.h"
+#include "dev-ar9xxx-wmac.h"
 #include "dev-gpio-buttons.h"
 #include "dev-leds-gpio.h"
 #include "nvram.h"
@@ -35,7 +35,8 @@
 #define DIR_615C1_GPIO_BTN_WPS		12
 #define DIR_615C1_GPIO_BTN_RESET	21
 
-#define DIR_615C1_BUTTONS_POLL_INTERVAL	20
+#define DIR_615C1_KEYS_POLL_INTERVAL	20	/* msecs */
+#define DIR_615C1_KEYS_DEBOUNCE_INTERVAL (3 * DIR_615C1_KEYS_POLL_INTERVAL)
 
 #define DIR_615C1_CONFIG_ADDR		0x1f020000
 #define DIR_615C1_CONFIG_SIZE		0x10000
@@ -47,24 +48,24 @@ static struct mtd_partition dir_615c1_partitions[] = {
 		.offset		= 0,
 		.size		= 0x020000,
 		.mask_flags	= MTD_WRITEABLE,
-	} , {
+	}, {
 		.name		= "config",
 		.offset		= 0x020000,
 		.size		= 0x010000,
-	} , {
+	}, {
 		.name		= "kernel",
 		.offset		= 0x030000,
-		.size		= 0x0d0000,
-	} , {
+		.size		= 0x0e0000,
+	}, {
 		.name		= "rootfs",
-		.offset		= 0x100000,
-		.size		= 0x2f0000,
-	} , {
+		.offset		= 0x110000,
+		.size		= 0x2e0000,
+	}, {
 		.name		= "art",
 		.offset		= 0x3f0000,
 		.size		= 0x010000,
 		.mask_flags	= MTD_WRITEABLE,
-	} , {
+	}, {
 		.name		= "firmware",
 		.offset		= 0x030000,
 		.size		= 0x3c0000,
@@ -74,8 +75,8 @@ static struct mtd_partition dir_615c1_partitions[] = {
 
 static struct flash_platform_data dir_615c1_flash_data = {
 #ifdef CONFIG_MTD_PARTITIONS
-        .parts          = dir_615c1_partitions,
-        .nr_parts       = ARRAY_SIZE(dir_615c1_partitions),
+	.parts		= dir_615c1_partitions,
+	.nr_parts	= ARRAY_SIZE(dir_615c1_partitions),
 #endif
 };
 
@@ -96,13 +97,13 @@ static struct gpio_led dir_615c1_leds_gpio[] __initdata = {
 		.name		= "dir-615c1:green:wancpu",
 		.gpio		= DIR_615C1_GPIO_LED_GREEN_WANCPU,
 		.active_low	= 1,
-        }, {
+	}, {
 		.name		= "dir-615c1:green:wlan",
 		.gpio		= DIR_615C1_GPIO_LED_GREEN_WLAN,
 		.active_low	= 1,
-        }, {
-		.name           = "dir-615c1:green:status",
-		.gpio           = DIR_615C1_GPIO_LED_GREEN_STATUS,
+	}, {
+		.name		= "dir-615c1:green:status",
+		.gpio		= DIR_615C1_GPIO_LED_GREEN_STATUS,
 		.active_low     = 1,
 	}, {
 		.name		= "dir-615c1:orange:wan",
@@ -112,18 +113,18 @@ static struct gpio_led dir_615c1_leds_gpio[] __initdata = {
 
 };
 
-static struct gpio_button dir_615c1_gpio_buttons[] __initdata = {
+static struct gpio_keys_button dir_615c1_gpio_keys[] __initdata = {
 	{
 		.desc		= "reset",
 		.type		= EV_KEY,
-		.code		= BTN_0,
-		.threshold	= 3,
+		.code		= KEY_RESTART,
+		.debounce_interval = DIR_615C1_KEYS_DEBOUNCE_INTERVAL,
 		.gpio		= DIR_615C1_GPIO_BTN_RESET,
 	}, {
 		.desc		= "wps",
 		.type		= EV_KEY,
-		.code		= BTN_1,
-		.threshold	= 3,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = DIR_615C1_KEYS_DEBOUNCE_INTERVAL,
 		.gpio		= DIR_615C1_GPIO_BTN_WPS,
 	}
 };
@@ -141,12 +142,13 @@ static void __init dir_615c1_setup(void)
 	u8 *wlan_mac = NULL;
 
 	if (nvram_parse_mac_addr(config, DIR_615C1_CONFIG_SIZE,
-			         "lan_mac=", mac) == 0) {
-		ar71xx_set_mac_base(mac);
+					"lan_mac=", mac) == 0) {
+		ar71xx_init_mac(ar71xx_eth0_data.mac_addr, mac, 0);
+		ar71xx_init_mac(ar71xx_eth1_data.mac_addr, mac, 1);
 		wlan_mac = mac;
 	}
 
-	ar71xx_add_device_mdio(DIR_615C1_MDIO_MASK);
+	ar71xx_add_device_mdio(0, DIR_615C1_MDIO_MASK);
 
 	ar71xx_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
 	ar71xx_eth0_data.phy_mask = DIR_615C1_LAN_PHYMASK;
@@ -162,11 +164,11 @@ static void __init dir_615c1_setup(void)
 	ar71xx_add_device_leds_gpio(-1, ARRAY_SIZE(dir_615c1_leds_gpio),
 					dir_615c1_leds_gpio);
 
-	ar71xx_add_device_gpio_buttons(-1, DIR_615C1_BUTTONS_POLL_INTERVAL,
-					ARRAY_SIZE(dir_615c1_gpio_buttons),
-					dir_615c1_gpio_buttons);
+	ar71xx_register_gpio_keys_polled(-1, DIR_615C1_KEYS_POLL_INTERVAL,
+					 ARRAY_SIZE(dir_615c1_gpio_keys),
+					 dir_615c1_gpio_keys);
 
-	ar913x_add_device_wmac(eeprom, wlan_mac);
+	ar9xxx_add_device_wmac(eeprom, wlan_mac);
 }
 
 MIPS_MACHINE(AR71XX_MACH_DIR_615_C1, "DIR-615-C1", "D-Link DIR-615 rev. C1",
diff --git a/arch/mips/ar71xx/mach-dir-825-b1.c b/arch/mips/ar71xx/mach-dir-825-b1.c
index d8b26ee..fe672ff 100644
--- a/arch/mips/ar71xx/mach-dir-825-b1.c
+++ b/arch/mips/ar71xx/mach-dir-825-b1.c
@@ -1,7 +1,7 @@
 /*
  *  D-Link DIR-825 rev. B1 board support
  *
- *  Copyright (C) 2009 Lukas Kuna, Evkanet, s.r.o.
+ *  Copyright (C) 2009-2011 Lukas Kuna, Evkanet, s.r.o.
  *
  *  based on mach-wndr3700.c
  *
@@ -14,7 +14,7 @@
 #include <linux/mtd/mtd.h>
 #include <linux/mtd/partitions.h>
 #include <linux/delay.h>
-#include <linux/rtl8366s.h>
+#include <linux/rtl8366.h>
 
 #include <asm/mach-ar71xx/ar71xx.h>
 
@@ -29,23 +29,24 @@
 #define DIR825B1_GPIO_LED_BLUE_USB		0
 #define DIR825B1_GPIO_LED_ORANGE_POWER		1
 #define DIR825B1_GPIO_LED_BLUE_POWER		2
-#define DIR825B1_GPIO_LED_BLUE_POWERSAVE	4
+#define DIR825B1_GPIO_LED_BLUE_WPS		4
 #define DIR825B1_GPIO_LED_ORANGE_PLANET		6
 #define DIR825B1_GPIO_LED_BLUE_PLANET		11
 
 #define DIR825B1_GPIO_BTN_RESET			3
-#define DIR825B1_GPIO_BTN_POWERSAVE		8
+#define DIR825B1_GPIO_BTN_WPS			8
 
 #define DIR825B1_GPIO_RTL8366_SDA		5
 #define DIR825B1_GPIO_RTL8366_SCK		7
 
-#define DIR825B1_BUTTONS_POLL_INTERVAL		20
+#define DIR825B1_KEYS_POLL_INTERVAL		20	/* msecs */
+#define DIR825B1_KEYS_DEBOUNCE_INTERVAL		(3 * DIR825B1_KEYS_POLL_INTERVAL)
 
 #define DIR825B1_CAL_LOCATION_0			0x1f661000
 #define DIR825B1_CAL_LOCATION_1			0x1f665000
 
-#define DIR825B1_MAC_LOCATION_0			0x2ffa81b8
-#define DIR825B1_MAC_LOCATION_1			0x2ffa8370
+#define DIR825B1_MAC_LOCATION_0			0x1f66ffa0
+#define DIR825B1_MAC_LOCATION_1			0x1f66ffb4
 
 #ifdef CONFIG_MTD_PARTITIONS
 static struct mtd_partition dir825b1_partitions[] = {
@@ -54,21 +55,21 @@ static struct mtd_partition dir825b1_partitions[] = {
 		.offset		= 0,
 		.size		= 0x040000,
 		.mask_flags	= MTD_WRITEABLE,
-	} , {
+	}, {
 		.name		= "config",
 		.offset		= 0x040000,
 		.size		= 0x010000,
 		.mask_flags	= MTD_WRITEABLE,
-	} , {
+	}, {
 		.name		= "firmware",
 		.offset		= 0x050000,
 		.size		= 0x610000,
-	} , {
+	}, {
 		.name		= "caldata",
 		.offset		= 0x660000,
 		.size		= 0x010000,
 		.mask_flags	= MTD_WRITEABLE,
-	} , {
+	}, {
 		.name		= "unknown",
 		.offset		= 0x670000,
 		.size		= 0x190000,
@@ -79,8 +80,8 @@ static struct mtd_partition dir825b1_partitions[] = {
 
 static struct flash_platform_data dir825b1_flash_data = {
 #ifdef CONFIG_MTD_PARTITIONS
-        .parts          = dir825b1_partitions,
-        .nr_parts       = ARRAY_SIZE(dir825b1_partitions),
+	.parts          = dir825b1_partitions,
+	.nr_parts       = ARRAY_SIZE(dir825b1_partitions),
 #endif
 };
 
@@ -98,8 +99,8 @@ static struct gpio_led dir825b1_leds_gpio[] __initdata = {
 		.gpio		= DIR825B1_GPIO_LED_BLUE_POWER,
 		.active_low	= 1,
 	}, {
-		.name		= "dir825b1:blue:powersave",
-		.gpio		= DIR825B1_GPIO_LED_BLUE_POWERSAVE,
+		.name		= "dir825b1:blue:wps",
+		.gpio		= DIR825B1_GPIO_LED_BLUE_WPS,
 		.active_low	= 1,
 	}, {
 		.name		= "dir825b1:orange:planet",
@@ -112,27 +113,33 @@ static struct gpio_led dir825b1_leds_gpio[] __initdata = {
 	}
 };
 
-static struct gpio_button dir825b1_gpio_buttons[] __initdata = {
+static struct gpio_keys_button dir825b1_gpio_keys[] __initdata = {
 	{
 		.desc		= "reset",
 		.type		= EV_KEY,
-		.code		= BTN_0,
-		.threshold	= 3,
+		.code		= KEY_RESTART,
+		.debounce_interval = DIR825B1_KEYS_DEBOUNCE_INTERVAL,
 		.gpio		= DIR825B1_GPIO_BTN_RESET,
 		.active_low	= 1,
-	} , {
-		.desc		= "powersave",
+	}, {
+		.desc		= "wps",
 		.type		= EV_KEY,
-		.code		= BTN_1,
-		.threshold	= 3,
-		.gpio		= DIR825B1_GPIO_BTN_POWERSAVE,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = DIR825B1_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= DIR825B1_GPIO_BTN_WPS,
 		.active_low	= 1,
 	}
 };
 
-static struct rtl8366s_platform_data dir825b1_rtl8366s_data = {
-	.gpio_sda        = DIR825B1_GPIO_RTL8366_SDA,
-	.gpio_sck        = DIR825B1_GPIO_RTL8366_SCK,
+static struct rtl8366_initval dir825b1_rtl8366s_initvals[] = {
+	{ .reg = 0x06, .val = 0x0108 },
+};
+
+static struct rtl8366_platform_data dir825b1_rtl8366s_data = {
+	.gpio_sda	= DIR825B1_GPIO_RTL8366_SDA,
+	.gpio_sck	= DIR825B1_GPIO_RTL8366_SCK,
+	.num_initvals	= ARRAY_SIZE(dir825b1_rtl8366s_initvals),
+	.initvals	= dir825b1_rtl8366s_initvals,
 };
 
 static struct platform_device dir825b1_rtl8366s_device = {
@@ -143,24 +150,35 @@ static struct platform_device dir825b1_rtl8366s_device = {
 	}
 };
 
-static void __init dir825b1_setup(void)
+static void dir825b1_read_ascii_mac(u8 *dest, unsigned int src_addr)
 {
-        u8 mac[6], i;
+	int ret;
+	u8 *src = (u8 *)KSEG1ADDR(src_addr);
 
-	memcpy(mac, (u8*)KSEG1ADDR(DIR825B1_MAC_LOCATION_1), 6);
-	for(i = 5; i >= 3; i--)
-		if(++mac[i] != 0x00) break;
+	ret = sscanf(src, "%02hhx:%02hhx:%02hhx:%02hhx:%02hhx:%02hhx",
+		     &dest[0], &dest[1], &dest[2],
+		     &dest[3], &dest[4], &dest[5]);
 
-	ar71xx_set_mac_base(mac);
+	if (ret != ETH_ALEN) memset(dest, 0, ETH_ALEN);
+}
 
-	ar71xx_add_device_mdio(0x0);
+static void __init dir825b1_setup(void)
+{
+	u8 mac1[ETH_ALEN], mac2[ETH_ALEN];
 
+	dir825b1_read_ascii_mac(mac1, DIR825B1_MAC_LOCATION_0);
+	dir825b1_read_ascii_mac(mac2, DIR825B1_MAC_LOCATION_1);
+
+	ar71xx_add_device_mdio(0, 0x0);
+
+	ar71xx_init_mac(ar71xx_eth0_data.mac_addr, mac1, 2);
 	ar71xx_eth0_data.mii_bus_dev = &dir825b1_rtl8366s_device.dev;
 	ar71xx_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
 	ar71xx_eth0_data.speed = SPEED_1000;
 	ar71xx_eth0_data.duplex = DUPLEX_FULL;
 	ar71xx_eth0_pll_data.pll_1000 = 0x11110000;
 
+	ar71xx_init_mac(ar71xx_eth1_data.mac_addr, mac1, 3);
 	ar71xx_eth1_data.mii_bus_dev = &dir825b1_rtl8366s_device.dev;
 	ar71xx_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
 	ar71xx_eth1_data.phy_mask = 0x10;
@@ -174,18 +192,19 @@ static void __init dir825b1_setup(void)
 	ar71xx_add_device_leds_gpio(-1, ARRAY_SIZE(dir825b1_leds_gpio),
 					dir825b1_leds_gpio);
 
-	ar71xx_add_device_gpio_buttons(-1, DIR825B1_BUTTONS_POLL_INTERVAL,
-					ARRAY_SIZE(dir825b1_gpio_buttons),
-					dir825b1_gpio_buttons);
+	ar71xx_register_gpio_keys_polled(-1, DIR825B1_KEYS_POLL_INTERVAL,
+					 ARRAY_SIZE(dir825b1_gpio_keys),
+					 dir825b1_gpio_keys);
 
 	ar71xx_add_device_usb();
 
 	platform_device_register(&dir825b1_rtl8366s_device);
 
-	ap94_pci_init((u8 *) KSEG1ADDR(DIR825B1_CAL_LOCATION_0),
-		      (u8 *) KSEG1ADDR(DIR825B1_MAC_LOCATION_0),
-		      (u8 *) KSEG1ADDR(DIR825B1_CAL_LOCATION_1),
-		      (u8 *) KSEG1ADDR(DIR825B1_MAC_LOCATION_1));
+	ap94_pci_setup_wmac_led_pin(0, 5);
+	ap94_pci_setup_wmac_led_pin(1, 5);
+
+	ap94_pci_init((u8 *) KSEG1ADDR(DIR825B1_CAL_LOCATION_0), mac1,
+		      (u8 *) KSEG1ADDR(DIR825B1_CAL_LOCATION_1), mac2);
 }
 
 MIPS_MACHINE(AR71XX_MACH_DIR_825_B1, "DIR-825-B1", "D-Link DIR-825 rev. B1",
diff --git a/arch/mips/ar71xx/mach-eap7660d.c b/arch/mips/ar71xx/mach-eap7660d.c
new file mode 100644
index 0000000..230bf78
--- /dev/null
+++ b/arch/mips/ar71xx/mach-eap7660d.c
@@ -0,0 +1,180 @@
+/*
+ *  Senao EAP7660D board support
+ *
+ *  Copyright (C) 2010 Daniel Golle <daniel.golle@gmail.com>
+ *  Copyright (C) 2008 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/pci.h>
+#include <linux/ath5k_platform.h>
+#include <linux/delay.h>
+#include <asm/mach-ar71xx/ar71xx.h>
+#include <asm/mach-ar71xx/pci.h>
+
+#include "machtype.h"
+#include "devices.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+
+#define EAP7660D_KEYS_POLL_INTERVAL	20	/* msecs */
+#define EAP7660D_KEYS_DEBOUNCE_INTERVAL	(3 * EAP7660D_KEYS_POLL_INTERVAL)
+
+#define EAP7660D_GPIO_DS4		7
+#define EAP7660D_GPIO_DS5		2
+#define EAP7660D_GPIO_DS7		0
+#define EAP7660D_GPIO_DS8		4
+#define EAP7660D_GPIO_SW1		3
+#define EAP7660D_GPIO_SW3		8
+#define EAP7660D_PHYMASK		BIT(20)
+#define EAP7660D_BOARDCONFIG		0x1F7F0000
+#define EAP7660D_GBIC_MAC_OFFSET	0x1000
+#define EAP7660D_WMAC0_MAC_OFFSET	0x1010
+#define EAP7660D_WMAC1_MAC_OFFSET	0x1016
+#define EAP7660D_WMAC0_CALDATA_OFFSET	0x2000
+#define EAP7660D_WMAC1_CALDATA_OFFSET	0x3000
+
+static struct ath5k_platform_data eap7660d_wmac0_data;
+static struct ath5k_platform_data eap7660d_wmac1_data;
+static char eap7660d_wmac0_mac[6];
+static char eap7660d_wmac1_mac[6];
+static u16 eap7660d_wmac0_eeprom[ATH5K_PLAT_EEP_MAX_WORDS];
+static u16 eap7660d_wmac1_eeprom[ATH5K_PLAT_EEP_MAX_WORDS];
+
+#ifdef CONFIG_PCI
+static struct ar71xx_pci_irq eap7660d_pci_irqs[] __initdata = {
+	{
+		.slot   = 0,
+		.pin    = 1,
+		.irq    = AR71XX_PCI_IRQ_DEV0,
+	}, {
+		.slot   = 1,
+		.pin    = 1,
+		.irq    = AR71XX_PCI_IRQ_DEV1,
+	}
+};
+
+static int eap7660d_pci_plat_dev_init(struct pci_dev *dev)
+{
+	switch (PCI_SLOT(dev->devfn)) {
+	case 17:
+		dev->dev.platform_data = &eap7660d_wmac0_data;
+		break;
+
+	case 18:
+		dev->dev.platform_data = &eap7660d_wmac1_data;
+		break;
+	}
+
+	return 0;
+}
+
+void __init eap7660d_pci_init(u8 *cal_data0, u8 *mac_addr0,
+			      u8 *cal_data1, u8 *mac_addr1)
+{
+	if (cal_data0 && *cal_data0 == 0xa55a) {
+		memcpy(eap7660d_wmac0_eeprom, cal_data0,
+			ATH5K_PLAT_EEP_MAX_WORDS);
+		eap7660d_wmac0_data.eeprom_data = eap7660d_wmac0_eeprom;
+	}
+
+	if (cal_data1 && *cal_data1 == 0xa55a) {
+		memcpy(eap7660d_wmac1_eeprom, cal_data1,
+			ATH5K_PLAT_EEP_MAX_WORDS);
+		eap7660d_wmac1_data.eeprom_data = eap7660d_wmac1_eeprom;
+	}
+
+	if (mac_addr0) {
+		memcpy(eap7660d_wmac0_mac, mac_addr0,
+			sizeof(eap7660d_wmac0_mac));
+		eap7660d_wmac0_data.macaddr = eap7660d_wmac0_mac;
+	}
+
+	if (mac_addr1) {
+		memcpy(eap7660d_wmac1_mac, mac_addr1,
+			sizeof(eap7660d_wmac1_mac));
+		eap7660d_wmac1_data.macaddr = eap7660d_wmac1_mac;
+	}
+
+	ar71xx_pci_plat_dev_init = eap7660d_pci_plat_dev_init;
+	ar71xx_pci_init(ARRAY_SIZE(eap7660d_pci_irqs), eap7660d_pci_irqs);
+}
+#else
+static inline void eap7660d_pci_init(u8 *cal_data0, u8 *mac_addr0,
+				     u8 *cal_data1, u8 *mac_addr1)
+{
+}
+#endif /* CONFIG_PCI */
+
+static struct gpio_led eap7660d_leds_gpio[] __initdata = {
+	{
+		.name		= "eap7660d:green:ds8",
+		.gpio		= EAP7660D_GPIO_DS8,
+		.active_low	= 0,
+	},
+	{
+		.name		= "eap7660d:green:ds5",
+		.gpio		= EAP7660D_GPIO_DS5,
+		.active_low	= 0,
+	},
+	{
+		.name		= "eap7660d:green:ds7",
+		.gpio		= EAP7660D_GPIO_DS7,
+		.active_low	= 0,
+	},
+	{
+		.name		= "eap7660d:green:ds4",
+		.gpio		= EAP7660D_GPIO_DS4,
+		.active_low	= 0,
+	}
+};
+
+static struct gpio_keys_button eap7660d_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = EAP7660D_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= EAP7660D_GPIO_SW1,
+		.active_low	= 1,
+	},
+	{
+		.desc		= "wps",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = EAP7660D_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= EAP7660D_GPIO_SW3,
+		.active_low	= 1,
+	}
+};
+
+static void __init eap7660d_setup(void)
+{
+	u8 *boardconfig = (u8 *) KSEG1ADDR(EAP7660D_BOARDCONFIG);
+
+	ar71xx_add_device_mdio(0, ~EAP7660D_PHYMASK);
+
+	ar71xx_init_mac(ar71xx_eth0_data.mac_addr,
+			boardconfig + EAP7660D_GBIC_MAC_OFFSET, 0);
+	ar71xx_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ar71xx_eth0_data.phy_mask = EAP7660D_PHYMASK;
+	ar71xx_add_device_eth(0);
+	ar71xx_add_device_m25p80(NULL);
+	ar71xx_add_device_leds_gpio(-1, ARRAY_SIZE(eap7660d_leds_gpio),
+					eap7660d_leds_gpio);
+	ar71xx_register_gpio_keys_polled(-1, EAP7660D_KEYS_POLL_INTERVAL,
+					 ARRAY_SIZE(eap7660d_gpio_keys),
+					 eap7660d_gpio_keys);
+	eap7660d_pci_init(boardconfig + EAP7660D_WMAC0_CALDATA_OFFSET,
+			boardconfig + EAP7660D_WMAC0_MAC_OFFSET,
+			boardconfig + EAP7660D_WMAC1_CALDATA_OFFSET,
+			boardconfig + EAP7660D_WMAC1_MAC_OFFSET);
+};
+
+MIPS_MACHINE(AR71XX_MACH_EAP7660D, "EAP7660D", "Senao EAP7660D",
+	     eap7660d_setup);
diff --git a/arch/mips/ar71xx/mach-ja76pf.c b/arch/mips/ar71xx/mach-ja76pf.c
new file mode 100644
index 0000000..0e21fdb
--- /dev/null
+++ b/arch/mips/ar71xx/mach-ja76pf.c
@@ -0,0 +1,102 @@
+/*
+ *  jjPlus JA76PF board support
+ */
+
+#include <asm/mach-ar71xx/ar71xx.h>
+#include <linux/platform_device.h>
+#include <linux/i2c.h>
+#include <linux/i2c-gpio.h>
+
+#include "machtype.h"
+#include "devices.h"
+#include "dev-m25p80.h"
+#include "dev-gpio-buttons.h"
+#include "dev-pb42-pci.h"
+#include "dev-usb.h"
+#include "dev-leds-gpio.h"
+
+#define JA76PF_KEYS_POLL_INTERVAL	20	/* msecs */
+#define JA76PF_KEYS_DEBOUNCE_INTERVAL	(3 * JA76PF_KEYS_POLL_INTERVAL)
+
+#define JA76PF_GPIO_I2C_SCL		0
+#define JA76PF_GPIO_I2C_SDA		1
+#define JA76PF_GPIO_LED_1		5
+#define JA76PF_GPIO_LED_2		4
+#define JA76PF_GPIO_LED_3		3
+#define JA76PF_GPIO_BTN_RESET		11
+
+static struct gpio_led ja76pf_leds_gpio[] __initdata = {
+	{
+		.name		= "ja76pf:green:led1",
+		.gpio		= JA76PF_GPIO_LED_1,
+		.active_low	= 1,
+	}, {
+		.name		= "ja76pf:green:led2",
+		.gpio		= JA76PF_GPIO_LED_2,
+		.active_low	= 1,
+	}, {
+		.name		= "ja76pf:green:led3",
+		.gpio		= JA76PF_GPIO_LED_3,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button ja76pf_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = JA76PF_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= JA76PF_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}
+};
+
+static struct i2c_gpio_platform_data ja76pf_i2c_gpio_data = {
+	.sda_pin	= JA76PF_GPIO_I2C_SDA,
+	.scl_pin	= JA76PF_GPIO_I2C_SCL,
+};
+
+static struct platform_device ja76pf_i2c_gpio_device = {
+	.name		= "i2c-gpio",
+	.id		= 0,
+	.dev = {
+		.platform_data  = &ja76pf_i2c_gpio_data,
+	}
+};
+
+#define JA76PF_WAN_PHYMASK	(1 << 4)
+#define JA76PF_LAN_PHYMASK	((1 << 0) | (1 << 1) | (1 << 2) | (1 < 3))
+#define JA76PF_MDIO_PHYMASK	(JA76PF_LAN_PHYMASK | JA76PF_WAN_PHYMASK)
+
+static void __init ja76pf_init(void)
+{
+	ar71xx_add_device_m25p80(NULL);
+
+	ar71xx_add_device_mdio(0, ~JA76PF_MDIO_PHYMASK);
+
+	ar71xx_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ar71xx_eth0_data.phy_mask = JA76PF_LAN_PHYMASK;
+
+	ar71xx_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ar71xx_eth1_data.phy_mask = JA76PF_WAN_PHYMASK;
+	ar71xx_eth1_data.speed = SPEED_1000;
+	ar71xx_eth1_data.duplex = DUPLEX_FULL;
+
+	ar71xx_add_device_eth(0);
+	ar71xx_add_device_eth(1);
+
+	platform_device_register(&ja76pf_i2c_gpio_device);
+
+	ar71xx_add_device_leds_gpio(-1, ARRAY_SIZE(ja76pf_leds_gpio),
+					ja76pf_leds_gpio);
+
+	ar71xx_register_gpio_keys_polled(-1, JA76PF_KEYS_POLL_INTERVAL,
+					 ARRAY_SIZE(ja76pf_gpio_keys),
+					 ja76pf_gpio_keys);
+
+	ar71xx_add_device_usb();
+	pb42_pci_init();
+}
+
+MIPS_MACHINE(AR71XX_MACH_JA76PF, "JA76PF", "jjPlus JA76PF", ja76pf_init);
diff --git a/arch/mips/ar71xx/mach-jwap003.c b/arch/mips/ar71xx/mach-jwap003.c
new file mode 100644
index 0000000..d642031
--- /dev/null
+++ b/arch/mips/ar71xx/mach-jwap003.c
@@ -0,0 +1,83 @@
+/*
+ *  jjPlus JWAP003 board support
+ *
+ */
+
+#include <asm/mach-ar71xx/ar71xx.h>
+#include <linux/i2c.h>
+#include <linux/i2c-gpio.h>
+#include <linux/platform_device.h>
+
+#include "machtype.h"
+#include "devices.h"
+#include "dev-m25p80.h"
+#include "dev-gpio-buttons.h"
+#include "dev-pb42-pci.h"
+#include "dev-usb.h"
+
+#define JWAP003_KEYS_POLL_INTERVAL	20	/* msecs */
+#define JWAP003_KEYS_DEBOUNCE_INTERVAL	(3 * JWAP003_KEYS_POLL_INTERVAL)
+
+#define JWAP003_GPIO_WPS	11
+#define JWAP003_GPIO_I2C_SCL	0
+#define JWAP003_GPIO_I2C_SDA	1
+
+static struct gpio_keys_button jwap003_gpio_keys[] __initdata = {
+	{
+		.desc		= "wps",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = JWAP003_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= JWAP003_GPIO_WPS,
+		.active_low	= 1,
+	}
+};
+
+static struct i2c_gpio_platform_data jwap003_i2c_gpio_data = {
+	.sda_pin	= JWAP003_GPIO_I2C_SDA,
+	.scl_pin	= JWAP003_GPIO_I2C_SCL,
+};
+
+static struct platform_device jwap003_i2c_gpio_device = {
+	.name		= "i2c-gpio",
+	.id		= 0,
+	.dev = {
+		.platform_data  = &jwap003_i2c_gpio_data,
+	}
+};
+
+#define JWAP003_WAN_PHYMASK	BIT(0)
+#define JWAP003_LAN_PHYMASK	BIT(4)
+
+static void __init jwap003_init(void)
+{
+	ar71xx_add_device_m25p80(NULL);
+
+	ar71xx_add_device_mdio(0, 0x0);
+
+	ar71xx_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ar71xx_eth0_data.phy_mask = JWAP003_WAN_PHYMASK;
+	ar71xx_eth0_data.speed = SPEED_100;
+	ar71xx_eth0_data.duplex = DUPLEX_FULL;
+	ar71xx_eth0_data.has_ar8216 = 1;
+
+	ar71xx_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ar71xx_eth1_data.phy_mask = JWAP003_LAN_PHYMASK;
+	ar71xx_eth1_data.speed = SPEED_100;
+	ar71xx_eth1_data.duplex = DUPLEX_FULL;
+
+	ar71xx_add_device_eth(0);
+	ar71xx_add_device_eth(1);
+
+	platform_device_register(&jwap003_i2c_gpio_device);
+
+	ar71xx_add_device_usb();
+
+	ar71xx_register_gpio_keys_polled(-1, JWAP003_KEYS_POLL_INTERVAL,
+					 ARRAY_SIZE(jwap003_gpio_keys),
+					 jwap003_gpio_keys);
+
+	pb42_pci_init();
+}
+
+MIPS_MACHINE(AR71XX_MACH_JWAP003, "JWAP003", "jjPlus JWAP003", jwap003_init);
diff --git a/arch/mips/ar71xx/mach-mzk-w04nu.c b/arch/mips/ar71xx/mach-mzk-w04nu.c
index 63fbeb8..dbb408c 100644
--- a/arch/mips/ar71xx/mach-mzk-w04nu.c
+++ b/arch/mips/ar71xx/mach-mzk-w04nu.c
@@ -15,7 +15,7 @@
 
 #include "machtype.h"
 #include "devices.h"
-#include "dev-ar913x-wmac.h"
+#include "dev-ar9xxx-wmac.h"
 #include "dev-gpio-buttons.h"
 #include "dev-leds-gpio.h"
 #include "dev-m25p80.h"
@@ -32,7 +32,8 @@
 #define MZK_W04NU_GPIO_BTN_WPS		12
 #define MZK_W04NU_GPIO_BTN_RESET	21
 
-#define MZK_W04NU_BUTTONS_POLL_INTERVAL	20
+#define MZK_W04NU_KEYS_POLL_INTERVAL	20	/* msecs */
+#define MZK_W04NU_KEYS_DEBOUNCE_INTERVAL (3 * MZK_W04NU_KEYS_POLL_INTERVAL)
 
 #ifdef CONFIG_MTD_PARTITIONS
 static struct mtd_partition mzk_w04nu_partitions[] = {
@@ -41,24 +42,24 @@ static struct mtd_partition mzk_w04nu_partitions[] = {
 		.offset		= 0,
 		.size		= 0x040000,
 		.mask_flags	= MTD_WRITEABLE,
-	} , {
+	}, {
 		.name		= "u-boot-env",
 		.offset		= 0x040000,
 		.size		= 0x010000,
-	} , {
+	}, {
 		.name		= "kernel",
 		.offset		= 0x050000,
 		.size		= 0x160000,
-	} , {
+	}, {
 		.name		= "rootfs",
 		.offset		= 0x1b0000,
 		.size		= 0x630000,
-	} , {
+	}, {
 		.name		= "art",
 		.offset		= 0x7e0000,
 		.size		= 0x020000,
 		.mask_flags	= MTD_WRITEABLE,
-	} , {
+	}, {
 		.name		= "firmware",
 		.offset		= 0x050000,
 		.size		= 0x790000,
@@ -68,59 +69,59 @@ static struct mtd_partition mzk_w04nu_partitions[] = {
 
 static struct flash_platform_data mzk_w04nu_flash_data = {
 #ifdef CONFIG_MTD_PARTITIONS
-        .parts          = mzk_w04nu_partitions,
-        .nr_parts       = ARRAY_SIZE(mzk_w04nu_partitions),
+	.parts          = mzk_w04nu_partitions,
+	.nr_parts       = ARRAY_SIZE(mzk_w04nu_partitions),
 #endif
 };
 
 static struct gpio_led mzk_w04nu_leds_gpio[] __initdata = {
 	{
-		.name		= "mzk-w04nu:green:status",
+		.name		= "planex:green:status",
 		.gpio		= MZK_W04NU_GPIO_LED_STATUS,
 		.active_low	= 1,
 	}, {
-		.name		= "mzk-w04nu:blue:wps",
+		.name		= "planex:blue:wps",
 		.gpio		= MZK_W04NU_GPIO_LED_WPS,
 		.active_low	= 1,
 	}, {
-		.name		= "mzk-w04nu:green:wlan",
+		.name		= "planex:green:wlan",
 		.gpio		= MZK_W04NU_GPIO_LED_WLAN,
 		.active_low	= 1,
 	}, {
-		.name		= "mzk-w04nu:green:usb",
+		.name		= "planex:green:usb",
 		.gpio		= MZK_W04NU_GPIO_LED_USB,
 		.active_low	= 1,
 	}, {
-		.name		= "mzk-w04nu:green:ap",
+		.name		= "planex:green:ap",
 		.gpio		= MZK_W04NU_GPIO_LED_AP,
 		.active_low	= 1,
 	}, {
-		.name		= "mzk-w04nu:green:router",
+		.name		= "planex:green:router",
 		.gpio		= MZK_W04NU_GPIO_LED_ROUTER,
 		.active_low	= 1,
 	}
 };
 
-static struct gpio_button mzk_w04nu_gpio_buttons[] __initdata = {
+static struct gpio_keys_button mzk_w04nu_gpio_keys[] __initdata = {
 	{
 		.desc		= "reset",
 		.type		= EV_KEY,
-		.code		= BTN_0,
-		.threshold	= 3,
+		.code		= KEY_RESTART,
+		.debounce_interval = MZK_W04NU_KEYS_DEBOUNCE_INTERVAL,
 		.gpio		= MZK_W04NU_GPIO_BTN_RESET,
 		.active_low	= 1,
 	}, {
 		.desc		= "wps",
 		.type		= EV_KEY,
-		.code		= BTN_1,
-		.threshold	= 3,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = MZK_W04NU_KEYS_DEBOUNCE_INTERVAL,
 		.gpio		= MZK_W04NU_GPIO_BTN_WPS,
 		.active_low	= 1,
 	}, {
 		.desc		= "aprouter",
 		.type		= EV_KEY,
 		.code		= BTN_2,
-		.threshold	= 3,
+		.debounce_interval = MZK_W04NU_KEYS_DEBOUNCE_INTERVAL,
 		.gpio		= MZK_W04NU_GPIO_BTN_APROUTER,
 		.active_low	= 0,
 	}
@@ -133,15 +134,15 @@ static void __init mzk_w04nu_setup(void)
 {
 	u8 *eeprom = (u8 *) KSEG1ADDR(0x1fff1000);
 
-	ar71xx_set_mac_base(eeprom);
-
-	ar71xx_add_device_mdio(MZK_W04NU_MDIO_MASK);
+	ar71xx_add_device_mdio(0, MZK_W04NU_MDIO_MASK);
 
+	ar71xx_init_mac(ar71xx_eth0_data.mac_addr, eeprom, 0);
 	ar71xx_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
 	ar71xx_eth0_data.speed = SPEED_100;
 	ar71xx_eth0_data.duplex = DUPLEX_FULL;
 	ar71xx_eth0_data.has_ar8216 = 1;
 
+	ar71xx_init_mac(ar71xx_eth1_data.mac_addr, eeprom, 1);
 	ar71xx_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
 	ar71xx_eth1_data.phy_mask = MZK_W04NU_WAN_PHYMASK;
 
@@ -153,12 +154,12 @@ static void __init mzk_w04nu_setup(void)
 	ar71xx_add_device_leds_gpio(-1, ARRAY_SIZE(mzk_w04nu_leds_gpio),
 					mzk_w04nu_leds_gpio);
 
-	ar71xx_add_device_gpio_buttons(-1, MZK_W04NU_BUTTONS_POLL_INTERVAL,
-					ARRAY_SIZE(mzk_w04nu_gpio_buttons),
-					mzk_w04nu_gpio_buttons);
+	ar71xx_register_gpio_keys_polled(-1, MZK_W04NU_KEYS_POLL_INTERVAL,
+					 ARRAY_SIZE(mzk_w04nu_gpio_keys),
+					 mzk_w04nu_gpio_keys);
 	ar71xx_add_device_usb();
 
-	ar913x_add_device_wmac(eeprom, NULL);
+	ar9xxx_add_device_wmac(eeprom, NULL);
 }
 
 MIPS_MACHINE(AR71XX_MACH_MZK_W04NU, "MZK-W04NU", "Planex MZK-W04NU",
diff --git a/arch/mips/ar71xx/mach-mzk-w300nh.c b/arch/mips/ar71xx/mach-mzk-w300nh.c
index f5862eb..98b3f00 100644
--- a/arch/mips/ar71xx/mach-mzk-w300nh.c
+++ b/arch/mips/ar71xx/mach-mzk-w300nh.c
@@ -17,7 +17,7 @@
 #include "machtype.h"
 #include "devices.h"
 #include "dev-m25p80.h"
-#include "dev-ar913x-wmac.h"
+#include "dev-ar9xxx-wmac.h"
 #include "dev-gpio-buttons.h"
 #include "dev-leds-gpio.h"
 
@@ -31,7 +31,8 @@
 #define MZK_W300NH_GPIO_BTN_WPS		12
 #define MZK_W300NH_GPIO_BTN_RESET	21
 
-#define MZK_W04NU_BUTTONS_POLL_INTERVAL	20
+#define MZK_W300NH_KEYS_POLL_INTERVAL	20	/* msecs */
+#define MZK_W300NH_KEYS_DEBOUNCE_INTERVAL (3 * MZK_W300NH_KEYS_POLL_INTERVAL)
 
 #ifdef CONFIG_MTD_PARTITIONS
 static struct mtd_partition mzk_w300nh_partitions[] = {
@@ -40,24 +41,24 @@ static struct mtd_partition mzk_w300nh_partitions[] = {
 		.offset		= 0,
 		.size		= 0x040000,
 		.mask_flags	= MTD_WRITEABLE,
-	} , {
+	}, {
 		.name		= "u-boot-env",
 		.offset		= 0x040000,
 		.size		= 0x010000,
-	} , {
+	}, {
 		.name		= "kernel",
 		.offset		= 0x050000,
 		.size		= 0x160000,
-	} , {
+	}, {
 		.name		= "rootfs",
 		.offset		= 0x1b0000,
 		.size		= 0x630000,
-	} , {
+	}, {
 		.name		= "art",
 		.offset		= 0x7e0000,
 		.size		= 0x020000,
 		.mask_flags	= MTD_WRITEABLE,
-	} , {
+	}, {
 		.name		= "firmware",
 		.offset		= 0x050000,
 		.size		= 0x790000,
@@ -67,55 +68,55 @@ static struct mtd_partition mzk_w300nh_partitions[] = {
 
 static struct flash_platform_data mzk_w300nh_flash_data = {
 #ifdef CONFIG_MTD_PARTITIONS
-        .parts          = mzk_w300nh_partitions,
-        .nr_parts       = ARRAY_SIZE(mzk_w300nh_partitions),
+	.parts		= mzk_w300nh_partitions,
+	.nr_parts	= ARRAY_SIZE(mzk_w300nh_partitions),
 #endif
 };
 
 static struct gpio_led mzk_w300nh_leds_gpio[] __initdata = {
 	{
-		.name		= "mzk-w300nh:green:status",
+		.name		= "planex:green:status",
 		.gpio		= MZK_W300NH_GPIO_LED_STATUS,
 		.active_low	= 1,
 	}, {
-		.name		= "mzk-w300nh:blue:wps",
+		.name		= "planex:blue:wps",
 		.gpio		= MZK_W300NH_GPIO_LED_WPS,
 		.active_low	= 1,
 	}, {
-		.name		= "mzk-w300nh:green:wlan",
+		.name		= "planex:green:wlan",
 		.gpio		= MZK_W300NH_GPIO_LED_WLAN,
 		.active_low	= 1,
 	}, {
-		.name		= "mzk-w300nh:green:ap",
+		.name		= "planex:green:ap",
 		.gpio		= MZK_W300NH_GPIO_LED_AP,
 		.active_low	= 1,
 	}, {
-		.name		= "mzk-w300nh:green:router",
+		.name		= "planex:green:router",
 		.gpio		= MZK_W300NH_GPIO_LED_ROUTER,
 		.active_low	= 1,
 	}
 };
 
-static struct gpio_button mzk_w300nh_gpio_buttons[] __initdata = {
+static struct gpio_keys_button mzk_w300nh_gpio_keys[] __initdata = {
 	{
 		.desc		= "reset",
 		.type		= EV_KEY,
-		.code		= BTN_0,
-		.threshold	= 3,
+		.code		= KEY_RESTART,
+		.debounce_interval = MZK_W300NH_KEYS_DEBOUNCE_INTERVAL,
 		.gpio		= MZK_W300NH_GPIO_BTN_RESET,
 		.active_low	= 1,
 	}, {
 		.desc		= "wps",
 		.type		= EV_KEY,
-		.code		= BTN_1,
-		.threshold	= 3,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = MZK_W300NH_KEYS_DEBOUNCE_INTERVAL,
 		.gpio		= MZK_W300NH_GPIO_BTN_WPS,
 		.active_low	= 1,
 	}, {
 		.desc		= "aprouter",
 		.type		= EV_KEY,
 		.code		= BTN_2,
-		.threshold	= 3,
+		.debounce_interval = MZK_W300NH_KEYS_DEBOUNCE_INTERVAL,
 		.gpio		= MZK_W300NH_GPIO_BTN_APROUTER,
 		.active_low	= 0,
 	}
@@ -128,15 +129,15 @@ static void __init mzk_w300nh_setup(void)
 {
 	u8 *eeprom = (u8 *) KSEG1ADDR(0x1fff1000);
 
-	ar71xx_set_mac_base(eeprom);
-
-	ar71xx_add_device_mdio(MZK_W300NH_MDIO_MASK);
+	ar71xx_add_device_mdio(0, MZK_W300NH_MDIO_MASK);
 
+	ar71xx_init_mac(ar71xx_eth0_data.mac_addr, eeprom, 0);
 	ar71xx_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
 	ar71xx_eth0_data.speed = SPEED_100;
 	ar71xx_eth0_data.duplex = DUPLEX_FULL;
 	ar71xx_eth0_data.has_ar8216 = 1;
 
+	ar71xx_init_mac(ar71xx_eth1_data.mac_addr, eeprom, 1);
 	ar71xx_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
 	ar71xx_eth1_data.phy_mask = MZK_W300NH_WAN_PHYMASK;
 
@@ -146,12 +147,12 @@ static void __init mzk_w300nh_setup(void)
 	ar71xx_add_device_m25p80(&mzk_w300nh_flash_data);
 
 	ar71xx_add_device_leds_gpio(-1, ARRAY_SIZE(mzk_w300nh_leds_gpio),
-				    mzk_w300nh_leds_gpio);
+					mzk_w300nh_leds_gpio);
 
-	ar71xx_add_device_gpio_buttons(-1, MZK_W04NU_BUTTONS_POLL_INTERVAL,
-				       ARRAY_SIZE(mzk_w300nh_gpio_buttons),
-				       mzk_w300nh_gpio_buttons);
-	ar913x_add_device_wmac(eeprom, NULL);
+	ar71xx_register_gpio_keys_polled(-1, MZK_W300NH_KEYS_POLL_INTERVAL,
+					 ARRAY_SIZE(mzk_w300nh_gpio_keys),
+					 mzk_w300nh_gpio_keys);
+	ar9xxx_add_device_wmac(eeprom, NULL);
 }
 
 MIPS_MACHINE(AR71XX_MACH_MZK_W300NH, "MZK-W300NH", "Planex MZK-W300NH",
diff --git a/arch/mips/ar71xx/mach-nbg460n.c b/arch/mips/ar71xx/mach-nbg460n.c
new file mode 100644
index 0000000..e1d9592
--- /dev/null
+++ b/arch/mips/ar71xx/mach-nbg460n.c
@@ -0,0 +1,225 @@
+/*
+ *  Zyxel NBG 460N/550N/550NH board support
+ *
+ *  Copyright (C) 2010 Michael Kurz <michi.kurz@googlemail.com>
+ *
+ *  based on mach-tl-wr1043nd.c
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/platform_device.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <linux/delay.h>
+#include <linux/rtl8366.h>
+
+#include <linux/i2c.h>
+#include <linux/i2c-algo-bit.h>
+#include <linux/i2c-gpio.h>
+
+#include <asm/mach-ar71xx/ar71xx.h>
+
+#include "machtype.h"
+#include "devices.h"
+#include "dev-m25p80.h"
+#include "dev-ar9xxx-wmac.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+
+/* LEDs */
+#define NBG460N_GPIO_LED_WPS		3
+#define NBG460N_GPIO_LED_WAN		6
+#define NBG460N_GPIO_LED_POWER		14
+#define NBG460N_GPIO_LED_WLAN		15
+
+/* Buttons */
+#define NBG460N_GPIO_BTN_WPS		12
+#define NBG460N_GPIO_BTN_RESET		21
+
+#define NBG460N_KEYS_POLL_INTERVAL	20	/* msecs */
+#define NBG460N_KEYS_DEBOUNCE_INTERVAL	(3 * NBG460N_KEYS_POLL_INTERVAL)
+
+/* RTC chip PCF8563 I2C interface */
+#define NBG460N_GPIO_PCF8563_SDA	8
+#define NBG460N_GPIO_PCF8563_SCK	7
+
+/* Switch configuration I2C interface */
+#define NBG460N_GPIO_RTL8366_SDA	16
+#define NBG460N_GPIO_RTL8366_SCK	18
+
+#ifdef CONFIG_MTD_PARTITIONS
+static struct mtd_partition nbg460n_partitions[] = {
+	{
+		.name		= "Bootbase",
+		.offset		= 0,
+		.size		= 0x010000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "U-Boot Config",
+		.offset		= 0x010000,
+		.size		= 0x030000,
+	}, {
+		.name		= "U-Boot",
+		.offset		= 0x040000,
+		.size		= 0x030000,
+	}, {
+		.name		= "linux",
+		.offset		= 0x070000,
+		.size		= 0x0e0000,
+	}, {
+		.name		= "rootfs",
+		.offset		= 0x150000,
+		.size		= 0x2a0000,
+	}, {
+		.name		= "CalibData",
+		.offset		= 0x3f0000,
+		.size		= 0x010000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "firmware",
+		.offset		= 0x070000,
+		.size		= 0x380000,
+	}
+};
+#endif /* CONFIG_MTD_PARTITIONS */
+
+static struct flash_platform_data nbg460n_flash_data = {
+#ifdef CONFIG_MTD_PARTITIONS
+	.parts		= nbg460n_partitions,
+	.nr_parts       = ARRAY_SIZE(nbg460n_partitions),
+#endif
+};
+
+static struct gpio_led nbg460n_leds_gpio[] __initdata = {
+	{
+		.name		= "nbg460n:green:power",
+		.gpio		= NBG460N_GPIO_LED_POWER,
+		.active_low	= 0,
+		.default_trigger = "default-on",
+	}, {
+		.name		= "nbg460n:green:wps",
+		.gpio		= NBG460N_GPIO_LED_WPS,
+		.active_low	= 0,
+	}, {
+		.name		= "nbg460n:green:wlan",
+		.gpio		= NBG460N_GPIO_LED_WLAN,
+		.active_low	= 0,
+	}, {
+		/* Not really for controlling the LED,
+		   when set low the LED blinks uncontrollable  */
+		.name		= "nbg460n:green:wan",
+		.gpio		= NBG460N_GPIO_LED_WAN,
+		.active_low	= 0,
+	}
+};
+
+static struct gpio_keys_button nbg460n_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = NBG460N_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= NBG460N_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}, {
+		.desc		= "wps",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = NBG460N_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= NBG460N_GPIO_BTN_WPS,
+		.active_low	= 1,
+	}
+};
+
+static struct i2c_gpio_platform_data nbg460n_i2c_device_platdata = {
+	.sda_pin	= NBG460N_GPIO_PCF8563_SDA,
+	.scl_pin	= NBG460N_GPIO_PCF8563_SCK,
+	.udelay		= 10,
+};
+
+static struct platform_device nbg460n_i2c_device = {
+	.name		= "i2c-gpio",
+	.id		= -1,
+	.num_resources	= 0,
+	.resource	= NULL,
+	.dev		= {
+		.platform_data	= &nbg460n_i2c_device_platdata,
+	},
+};
+
+static struct i2c_board_info nbg460n_i2c_devs[] __initdata = {
+	{
+		I2C_BOARD_INFO("pcf8563", 0x51),
+	},
+};
+
+static void __devinit nbg460n_i2c_init(void)
+{
+	/* The gpio interface */
+	platform_device_register(&nbg460n_i2c_device);
+	/* I2C devices */
+	i2c_register_board_info(0, nbg460n_i2c_devs,
+				ARRAY_SIZE(nbg460n_i2c_devs));
+}
+
+
+static struct rtl8366_platform_data nbg460n_rtl8366s_data = {
+	.gpio_sda	= NBG460N_GPIO_RTL8366_SDA,
+	.gpio_sck	= NBG460N_GPIO_RTL8366_SCK,
+};
+
+static struct platform_device nbg460n_rtl8366s_device = {
+	.name		= RTL8366S_DRIVER_NAME,
+	.id		= -1,
+	.dev = {
+		.platform_data	= &nbg460n_rtl8366s_data,
+	}
+};
+
+static void __init nbg460n_setup(void)
+{
+	/* end of bootloader sector contains mac address */
+	u8 *mac = (u8 *) KSEG1ADDR(0x1fc0fff8);
+	/* last sector contains wlan calib data */
+	u8 *eeprom = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	/* LAN Port */
+	ar71xx_init_mac(ar71xx_eth0_data.mac_addr, mac, 0);
+	ar71xx_eth0_data.mii_bus_dev = &nbg460n_rtl8366s_device.dev;
+	ar71xx_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ar71xx_eth0_data.speed = SPEED_1000;
+	ar71xx_eth0_data.duplex = DUPLEX_FULL;
+
+	/* WAN Port */
+	ar71xx_init_mac(ar71xx_eth1_data.mac_addr, mac, 1);
+	ar71xx_eth1_data.mii_bus_dev = &nbg460n_rtl8366s_device.dev;
+	ar71xx_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ar71xx_eth1_data.phy_mask = 0x10;
+
+	ar71xx_add_device_eth(0);
+	ar71xx_add_device_eth(1);
+
+	/* register the switch phy */
+	platform_device_register(&nbg460n_rtl8366s_device);
+
+	/* register flash */
+	ar71xx_add_device_m25p80(&nbg460n_flash_data);
+
+	ar9xxx_add_device_wmac(eeprom, mac);
+
+	/* register RTC chip */
+	nbg460n_i2c_init();
+
+	ar71xx_add_device_leds_gpio(-1, ARRAY_SIZE(nbg460n_leds_gpio),
+					nbg460n_leds_gpio);
+
+	ar71xx_register_gpio_keys_polled(-1, NBG460N_KEYS_POLL_INTERVAL,
+					 ARRAY_SIZE(nbg460n_gpio_keys),
+					 nbg460n_gpio_keys);
+}
+
+MIPS_MACHINE(AR71XX_MACH_NBG460N, "NBG460N", "Zyxel NBG460N/550N/550NH",
+	     nbg460n_setup);
diff --git a/arch/mips/ar71xx/mach-om2p.c b/arch/mips/ar71xx/mach-om2p.c
new file mode 100644
index 0000000..e43ad74
--- /dev/null
+++ b/arch/mips/ar71xx/mach-om2p.c
@@ -0,0 +1,114 @@
+/*
+ *  OpenMesh OM2P support
+ *
+ *  Copyright (C) 2011 Marek Lindner <marek@open-mesh.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <linux/platform_device.h>
+
+#include <asm/mach-ar71xx/ar71xx.h>
+#include <asm/mach-ar71xx/gpio.h>
+
+#include "machtype.h"
+#include "devices.h"
+#include "dev-ap91-pci.h"
+#include "dev-m25p80.h"
+#include "dev-leds-gpio.h"
+#include "dev-gpio-buttons.h"
+
+#define OM2P_GPIO_LED_POWER	0
+#define OM2P_GPIO_LED_GREEN	13
+#define OM2P_GPIO_LED_RED	14
+#define OM2P_GPIO_LED_YELLOW	15
+#define OM2P_GPIO_LED_LAN	16
+#define OM2P_GPIO_LED_WAN	17
+#define OM2P_GPIO_BTN_RESET	11
+
+#define OM2P_KEYS_POLL_INTERVAL		20	/* msecs */
+#define OM2P_KEYS_DEBOUNCE_INTERVAL	(3 * OM2P_KEYS_POLL_INTERVAL)
+
+#define OM2P_WAN_PHYMASK	BIT(4)
+
+static struct flash_platform_data om2p_flash_data = {
+	.type = "s25sl12800",
+	.name = "ar7240-nor0",
+};
+
+static struct gpio_led om2p_leds_gpio[] __initdata = {
+	{
+		.name		= "om2p:blue:power",
+		.gpio		= OM2P_GPIO_LED_POWER,
+		.active_low	= 1,
+	}, {
+		.name		= "om2p:red:wifi",
+		.gpio		= OM2P_GPIO_LED_RED,
+		.active_low	= 1,
+	}, {
+		.name		= "om2p:yellow:wifi",
+		.gpio		= OM2P_GPIO_LED_YELLOW,
+		.active_low	= 1,
+	}, {
+		.name		= "om2p:green:wifi",
+		.gpio		= OM2P_GPIO_LED_GREEN,
+		.active_low	= 1,
+	}, {
+		.name		= "om2p:blue:lan",
+		.gpio		= OM2P_GPIO_LED_LAN,
+		.active_low	= 1,
+	}, {
+		.name		= "om2p:blue:wan",
+		.gpio		= OM2P_GPIO_LED_WAN,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button om2p_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = OM2P_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= OM2P_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}
+};
+
+static void __init om2p_setup(void)
+{
+	u8 *mac1 = (u8 *)KSEG1ADDR(0x1ffc0000);
+	u8 *mac2 = (u8 *)KSEG1ADDR(0x1ffc0000 + ETH_ALEN);
+	u8 *ee = (u8 *)KSEG1ADDR(0x1ffc1000);
+
+	ar71xx_gpio_function_disable(AR724X_GPIO_FUNC_ETH_SWITCH_LED0_EN |
+				     AR724X_GPIO_FUNC_ETH_SWITCH_LED1_EN |
+				     AR724X_GPIO_FUNC_ETH_SWITCH_LED2_EN |
+				     AR724X_GPIO_FUNC_ETH_SWITCH_LED3_EN |
+				     AR724X_GPIO_FUNC_ETH_SWITCH_LED4_EN);
+
+	ar71xx_add_device_m25p80(&om2p_flash_data);
+
+	ar71xx_add_device_mdio(0, ~OM2P_WAN_PHYMASK);
+
+	ar71xx_init_mac(ar71xx_eth0_data.mac_addr, mac1, 0);
+	ar71xx_init_mac(ar71xx_eth1_data.mac_addr, mac2, 0);
+
+	ar71xx_add_device_eth(0);
+	ar71xx_add_device_eth(1);
+
+	ap91_pci_init(ee, NULL);
+
+	ar71xx_add_device_leds_gpio(-1, ARRAY_SIZE(om2p_leds_gpio),
+					om2p_leds_gpio);
+
+	ar71xx_register_gpio_keys_polled(-1, OM2P_KEYS_POLL_INTERVAL,
+					 ARRAY_SIZE(om2p_gpio_keys),
+					 om2p_gpio_keys);
+}
+
+MIPS_MACHINE(AR71XX_MACH_OM2P, "OM2P", "OpenMesh OM2P", om2p_setup);
diff --git a/arch/mips/ar71xx/mach-pb42.c b/arch/mips/ar71xx/mach-pb42.c
index 576da4b..b385854 100644
--- a/arch/mips/ar71xx/mach-pb42.c
+++ b/arch/mips/ar71xx/mach-pb42.c
@@ -18,24 +18,25 @@
 #include "dev-pb42-pci.h"
 #include "dev-usb.h"
 
-#define PB42_BUTTONS_POLL_INTERVAL	20
+#define PB42_KEYS_POLL_INTERVAL		20	/* msecs */
+#define PB42_KEYS_DEBOUNCE_INTERVAL	(3 * PB42_KEYS_POLL_INTERVAL)
 
 #define PB42_GPIO_BTN_SW4	8
 #define PB42_GPIO_BTN_SW5	3
 
-static struct gpio_button pb42_gpio_buttons[] __initdata = {
+static struct gpio_keys_button pb42_gpio_keys[] __initdata = {
 	{
 		.desc		= "sw4",
 		.type		= EV_KEY,
 		.code		= BTN_0,
-		.threshold	= 3,
+		.debounce_interval = PB42_KEYS_DEBOUNCE_INTERVAL,
 		.gpio		= PB42_GPIO_BTN_SW4,
 		.active_low	= 1,
-	} , {
+	}, {
 		.desc		= "sw5",
 		.type		= EV_KEY,
 		.code		= BTN_1,
-		.threshold	= 3,
+		.debounce_interval = PB42_KEYS_DEBOUNCE_INTERVAL,
 		.gpio		= PB42_GPIO_BTN_SW5,
 		.active_low	= 1,
 	}
@@ -49,11 +50,13 @@ static void __init pb42_init(void)
 {
 	ar71xx_add_device_m25p80(NULL);
 
-	ar71xx_add_device_mdio(~PB42_MDIO_PHYMASK);
+	ar71xx_add_device_mdio(0, ~PB42_MDIO_PHYMASK);
 
+	ar71xx_init_mac(ar71xx_eth0_data.mac_addr, ar71xx_mac_base, 0);
 	ar71xx_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
 	ar71xx_eth0_data.phy_mask = PB42_WAN_PHYMASK;
 
+	ar71xx_init_mac(ar71xx_eth1_data.mac_addr, ar71xx_mac_base, 1);
 	ar71xx_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
 	ar71xx_eth1_data.speed = SPEED_100;
 	ar71xx_eth1_data.duplex = DUPLEX_FULL;
@@ -61,9 +64,9 @@ static void __init pb42_init(void)
 	ar71xx_add_device_eth(0);
 	ar71xx_add_device_eth(1);
 
-	ar71xx_add_device_gpio_buttons(-1, PB42_BUTTONS_POLL_INTERVAL,
-				       ARRAY_SIZE(pb42_gpio_buttons),
-				       pb42_gpio_buttons);
+	ar71xx_register_gpio_keys_polled(-1, PB42_KEYS_POLL_INTERVAL,
+					 ARRAY_SIZE(pb42_gpio_keys),
+					 pb42_gpio_keys);
 
 	pb42_pci_init();
 }
diff --git a/arch/mips/ar71xx/mach-pb44.c b/arch/mips/ar71xx/mach-pb44.c
index 72718e7..a66be18 100644
--- a/arch/mips/ar71xx/mach-pb44.c
+++ b/arch/mips/ar71xx/mach-pb44.c
@@ -54,6 +54,9 @@
 #define PB44_GPIO_LED_JUMP1	(PB44_GPIO_EXP_BASE + PB44_PCF8757_LED_JUMP1)
 #define PB44_GPIO_LED_JUMP2	(PB44_GPIO_EXP_BASE + PB44_PCF8757_LED_JUMP2)
 
+#define PB44_KEYS_POLL_INTERVAL		20	/* msecs */
+#define PB44_KEYS_DEBOUNCE_INTERVAL	(3 * PB44_KEYS_POLL_INTERVAL)
+
 static struct i2c_gpio_platform_data pb44_i2c_gpio_data = {
 	.sda_pin        = PB44_GPIO_I2C_SDA,
 	.scl_pin        = PB44_GPIO_I2C_SCL,
@@ -90,19 +93,19 @@ static struct gpio_led pb44_leds_gpio[] __initdata = {
 	},
 };
 
-static struct gpio_button pb44_gpio_buttons[] __initdata = {
+static struct gpio_keys_button pb44_gpio_keys[] __initdata = {
 	{
 		.desc		= "soft_reset",
 		.type		= EV_KEY,
-		.code		= BTN_0,
-		.threshold	= 3,
+		.code		= KEY_RESTART,
+		.debounce_interval = PB44_KEYS_DEBOUNCE_INTERVAL,
 		.gpio		= PB44_GPIO_SW_RESET,
 		.active_low	= 1,
-	} , {
+	}, {
 		.desc		= "jumpstart",
 		.type		= EV_KEY,
-		.code		= BTN_1,
-		.threshold	= 3,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = PB44_KEYS_DEBOUNCE_INTERVAL,
 		.gpio		= PB44_GPIO_SW_JUMP,
 		.active_low	= 1,
 	}
@@ -171,13 +174,15 @@ static struct platform_device pb44_spi_device = {
 
 static void __init pb44_init(void)
 {
-	ar71xx_add_device_mdio(~PB44_MDIO_PHYMASK);
+	ar71xx_add_device_mdio(0, ~PB44_MDIO_PHYMASK);
 
+	ar71xx_init_mac(ar71xx_eth0_data.mac_addr, ar71xx_mac_base, 0);
 	ar71xx_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
 	ar71xx_eth0_data.phy_mask = PB44_WAN_PHYMASK;
 
 	ar71xx_add_device_eth(0);
 
+	ar71xx_init_mac(ar71xx_eth1_data.mac_addr, ar71xx_mac_base, 1);
 	ar71xx_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
 	ar71xx_eth1_data.speed = SPEED_1000;
 	ar71xx_eth1_data.duplex = DUPLEX_FULL;
@@ -198,10 +203,11 @@ static void __init pb44_init(void)
 	platform_device_register(&pb44_spi_device);
 
 	ar71xx_add_device_leds_gpio(-1, ARRAY_SIZE(pb44_leds_gpio),
-				    pb44_leds_gpio);
+					pb44_leds_gpio);
 
-	ar71xx_add_device_gpio_buttons(-1, 20, ARRAY_SIZE(pb44_gpio_buttons),
-				       pb44_gpio_buttons);
+	ar71xx_register_gpio_keys_polled(-1, PB44_KEYS_POLL_INTERVAL,
+					 ARRAY_SIZE(pb44_gpio_keys),
+					 pb44_gpio_keys);
 }
 
 MIPS_MACHINE(AR71XX_MACH_PB44, "PB44", "Atheros PB44", pb44_init);
diff --git a/arch/mips/ar71xx/mach-pb92.c b/arch/mips/ar71xx/mach-pb92.c
index b422c3e..4c5d3ab 100644
--- a/arch/mips/ar71xx/mach-pb92.c
+++ b/arch/mips/ar71xx/mach-pb92.c
@@ -28,19 +28,19 @@ static struct mtd_partition pb92_partitions[] = {
 		.offset		= 0,
 		.size		= 0x040000,
 		.mask_flags	= MTD_WRITEABLE,
-	} , {
+	}, {
 		.name		= "u-boot-env",
 		.offset		= 0x040000,
 		.size		= 0x010000,
-	} , {
+	}, {
 		.name		= "rootfs",
 		.offset		= 0x050000,
 		.size		= 0x2b0000,
-	} , {
+	}, {
 		.name		= "uImage",
 		.offset		= 0x300000,
 		.size		= 0x0e0000,
-	} , {
+	}, {
 		.name		= "ART",
 		.offset		= 0x3e0000,
 		.size		= 0x020000,
@@ -51,30 +51,30 @@ static struct mtd_partition pb92_partitions[] = {
 
 static struct flash_platform_data pb92_flash_data = {
 #ifdef CONFIG_MTD_PARTITIONS
-        .parts          = pb92_partitions,
-        .nr_parts       = ARRAY_SIZE(pb92_partitions),
+	.parts		= pb92_partitions,
+	.nr_parts	= ARRAY_SIZE(pb92_partitions),
 #endif
 };
 
-
-#define PB92_BUTTONS_POLL_INTERVAL	20
+#define PB92_KEYS_POLL_INTERVAL		20	/* msecs */
+#define PB92_KEYS_DEBOUNCE_INTERVAL	(3 * PB92_KEYS_POLL_INTERVAL)
 
 #define PB92_GPIO_BTN_SW4	8
 #define PB92_GPIO_BTN_SW5	3
 
-static struct gpio_button pb92_gpio_buttons[] __initdata = {
+static struct gpio_keys_button pb92_gpio_keys[] __initdata = {
 	{
 		.desc		= "sw4",
 		.type		= EV_KEY,
 		.code		= BTN_0,
-		.threshold	= 3,
+		.debounce_interval = PB92_KEYS_DEBOUNCE_INTERVAL,
 		.gpio		= PB92_GPIO_BTN_SW4,
 		.active_low	= 1,
-	} , {
+	}, {
 		.desc		= "sw5",
 		.type		= EV_KEY,
 		.code		= BTN_1,
-		.threshold	= 3,
+		.debounce_interval = PB92_KEYS_DEBOUNCE_INTERVAL,
 		.gpio		= PB92_GPIO_BTN_SW5,
 		.active_low	= 1,
 	}
@@ -84,24 +84,20 @@ static void __init pb92_init(void)
 {
 	u8 *mac = (u8 *) KSEG1ADDR(0x1fff0000);
 
-	ar71xx_set_mac_base(mac);
 	ar71xx_add_device_m25p80(&pb92_flash_data);
 
-	ar71xx_add_device_mdio(~0);
-	ar71xx_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
-	ar71xx_eth0_data.speed = SPEED_100;
+	ar71xx_add_device_mdio(0, ~BIT(0));
+	ar71xx_init_mac(ar71xx_eth0_data.mac_addr, mac, 0);
+	ar71xx_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ar71xx_eth0_data.speed = SPEED_1000;
 	ar71xx_eth0_data.duplex = DUPLEX_FULL;
-
-	ar71xx_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
-	ar71xx_eth1_data.speed = SPEED_1000;
-	ar71xx_eth1_data.duplex = DUPLEX_FULL;
+	ar71xx_eth0_data.phy_mask = BIT(0);
 
 	ar71xx_add_device_eth(0);
-	ar71xx_add_device_eth(1);
 
-	ar71xx_add_device_gpio_buttons(-1, PB92_BUTTONS_POLL_INTERVAL,
-				       ARRAY_SIZE(pb92_gpio_buttons),
-				       pb92_gpio_buttons);
+	ar71xx_register_gpio_keys_polled(-1, PB92_KEYS_POLL_INTERVAL,
+					 ARRAY_SIZE(pb92_gpio_keys),
+					 pb92_gpio_keys);
 
 	pb9x_pci_init();
 }
diff --git a/arch/mips/ar71xx/mach-rb4xx.c b/arch/mips/ar71xx/mach-rb4xx.c
index 57c06d8..1b9f96b 100644
--- a/arch/mips/ar71xx/mach-rb4xx.c
+++ b/arch/mips/ar71xx/mach-rb4xx.c
@@ -1,7 +1,7 @@
 /*
  *  MikroTik RouterBOARD 4xx series support
  *
- *  Copyright (C) 2008 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008-2010 Gabor Juhos <juhosg@openwrt.org>
  *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
  *
  *  This program is free software; you can redistribute it and/or modify it
@@ -11,13 +11,17 @@
 
 #include <linux/platform_device.h>
 #include <linux/irq.h>
+#include <linux/mdio-gpio.h>
 #include <linux/mmc/host.h>
 #include <linux/spi/spi.h>
 #include <linux/spi/flash.h>
 #include <linux/spi/mmc_spi.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
 
 #include <asm/mach-ar71xx/ar71xx.h>
 #include <asm/mach-ar71xx/pci.h>
+#include <asm/mach-ar71xx/rb4xx_cpld.h>
 
 #include "machtype.h"
 #include "devices.h"
@@ -28,22 +32,50 @@
 #define RB4XX_GPIO_USER_LED	4
 #define RB4XX_GPIO_RESET_SWITCH	7
 
-#define RB4XX_BUTTONS_POLL_INTERVAL	20
+#define RB4XX_GPIO_CPLD_BASE	32
+#define RB4XX_GPIO_CPLD_LED1	(RB4XX_GPIO_CPLD_BASE + CPLD_GPIO_nLED1)
+#define RB4XX_GPIO_CPLD_LED2	(RB4XX_GPIO_CPLD_BASE + CPLD_GPIO_nLED2)
+#define RB4XX_GPIO_CPLD_LED3	(RB4XX_GPIO_CPLD_BASE + CPLD_GPIO_nLED3)
+#define RB4XX_GPIO_CPLD_LED4	(RB4XX_GPIO_CPLD_BASE + CPLD_GPIO_nLED4)
+#define RB4XX_GPIO_CPLD_LED5	(RB4XX_GPIO_CPLD_BASE + CPLD_GPIO_nLED5)
+
+#define RB4XX_KEYS_POLL_INTERVAL	20	/* msecs */
+#define RB4XX_KEYS_DEBOUNCE_INTERVAL	(3 * RB4XX_KEYS_POLL_INTERVAL)
 
 static struct gpio_led rb4xx_leds_gpio[] __initdata = {
 	{
 		.name		= "rb4xx:yellow:user",
 		.gpio		= RB4XX_GPIO_USER_LED,
 		.active_low	= 0,
+	}, {
+		.name		= "rb4xx:green:led1",
+		.gpio		= RB4XX_GPIO_CPLD_LED1,
+		.active_low	= 1,
+	}, {
+		.name		= "rb4xx:green:led2",
+		.gpio		= RB4XX_GPIO_CPLD_LED2,
+		.active_low	= 1,
+	}, {
+		.name		= "rb4xx:green:led3",
+		.gpio		= RB4XX_GPIO_CPLD_LED3,
+		.active_low	= 1,
+	}, {
+		.name		= "rb4xx:green:led4",
+		.gpio		= RB4XX_GPIO_CPLD_LED4,
+		.active_low	= 1,
+	}, {
+		.name		= "rb4xx:green:led5",
+		.gpio		= RB4XX_GPIO_CPLD_LED5,
+		.active_low	= 0,
 	},
 };
 
-static struct gpio_button rb4xx_gpio_buttons[] __initdata = {
+static struct gpio_keys_button rb4xx_gpio_keys[] __initdata = {
 	{
 		.desc		= "reset_switch",
 		.type		= EV_KEY,
-		.code		= BTN_0,
-		.threshold	= 3,
+		.code		= KEY_RESTART,
+		.debounce_interval = RB4XX_KEYS_DEBOUNCE_INTERVAL,
 		.gpio		= RB4XX_GPIO_RESET_SWITCH,
 		.active_low	= 1,
 	}
@@ -78,107 +110,117 @@ static struct ar71xx_pci_irq rb4xx_pci_irqs[] __initdata = {
 	}
 };
 
-#if 0
-/*
- * SPI device support is experimental
- */
+#ifdef CONFIG_MTD_PARTITIONS
+static struct mtd_partition rb4xx_partitions[] = {
+	{
+		.name		= "routerboot",
+		.offset		= 0,
+		.size		= 0x0b000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "hard_config",
+		.offset		= 0x0b000,
+		.size		= 0x01000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "bios",
+		.offset		= 0x0d000,
+		.size		= 0x02000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "soft_config",
+		.offset		= 0x0f000,
+		.size		= 0x01000,
+	}
+};
+#define rb4xx_num_partitions	ARRAY_SIZE(rb4xx_partitions)
+#else /* CONFIG_MTD_PARTITIONS */
+#define rb4xx_partitions	NULL
+#define rb4xx_num_partitions	0
+#endif /* CONFIG_MTD_PARTITIONS */
+
 static struct flash_platform_data rb4xx_flash_data = {
-	.type	= "pm25lv512",
+	.type		= "pm25lv512",
+	.parts		= rb4xx_partitions,
+	.nr_parts	= rb4xx_num_partitions,
 };
 
-static struct spi_board_info rb4xx_spi_info[] = {
-	{
-		.bus_num	= 0,
-		.chip_select	= 0,
-		.max_speed_hz	= 25000000,
-		.modalias	= "m25p80",
-		.platform_data	= &rb4xx_flash_data,
-	}
+static struct rb4xx_cpld_platform_data rb4xx_cpld_data = {
+	.gpio_base	= RB4XX_GPIO_CPLD_BASE,
 };
 
-static struct mmc_spi_platform_data rb433_mmc_data = {
+static struct mmc_spi_platform_data rb4xx_mmc_data = {
 	.ocr_mask	= MMC_VDD_32_33 | MMC_VDD_33_34,
 };
 
-static struct spi_board_info rb433_spi_info[] = {
+static struct spi_board_info rb4xx_spi_info[] = {
 	{
 		.bus_num	= 0,
 		.chip_select	= 0,
 		.max_speed_hz	= 25000000,
 		.modalias	= "m25p80",
-		.platform_data	= &rb433_flash_data,
+		.platform_data	= &rb4xx_flash_data,
 	}, {
 		.bus_num	= 0,
-		.chip_select	= 2,
+		.chip_select	= 1,
 		.max_speed_hz	= 25000000,
-		.modalias	= "mmc_spi",
-		.platform_data	= &rb433_mmc_data,
+		.modalias	= "spi-rb4xx-cpld",
+		.platform_data	= &rb4xx_cpld_data,
 	}
 };
 
-static u32 rb433_spi_get_ioc_base(u8 chip_select, int cs_high, int is_on)
-{
-	u32 ret;
-
-	if (is_on == AR71XX_SPI_CS_INACTIVE) {
-		ret = SPI_IOC_CS0 | SPI_IOC_CS1;
-	} else {
-		if (cs_high) {
-			ret = SPI_IOC_CS0 | SPI_IOC_CS1;
-		} else {
-			if ((chip_select ^ 2) == 0)
-				ret = SPI_IOC_CS1 ^ (SPI_IOC_CS0 | SPI_IOC_CS1);
-			else
-				ret = SPI_IOC_CS0 ^ (SPI_IOC_CS0 | SPI_IOC_CS1);
-		}
+static struct spi_board_info rb4xx_microsd_info[] = {
+	{
+		.bus_num	= 0,
+		.chip_select	= 2,
+		.max_speed_hz	= 25000000,
+		.modalias	= "mmc_spi",
+		.platform_data	= &rb4xx_mmc_data,
 	}
+};
 
-	return ret;
-}
 
-struct ar71xx_spi_platform_data rb433_spi_data = {
-	.bus_num		= 0,
-	.num_chipselect		= 3,
-	.get_ioc_base		= rb433_spi_get_ioc_base,
+static struct resource rb4xx_spi_resources[] = {
+	{
+		.start	= AR71XX_SPI_BASE,
+		.end	= AR71XX_SPI_BASE + AR71XX_SPI_SIZE - 1,
+		.flags	= IORESOURCE_MEM,
+	},
 };
 
-static void rb4xx_add_device_spi(void)
-{
-	ar71xx_add_device_spi(NULL, rb4xx_spi_info, ARRAY_SIZE(rb4xx_spi_info));
-}
-
-static void rb433_add_device_spi(void)
-{
-	ar71xx_add_device_spi(&rb433_spi_data, rb433_spi_info,
-				ARRAY_SIZE(rb433_spi_info));
-}
-#else
-static inline void rb4xx_add_device_spi(void) {}
-static inline void rb433_add_device_spi(void) {}
-#endif
+static struct platform_device rb4xx_spi_device = {
+	.name		= "rb4xx-spi",
+	.id		= -1,
+	.resource	= rb4xx_spi_resources,
+	.num_resources	= ARRAY_SIZE(rb4xx_spi_resources),
+};
 
 static void __init rb4xx_generic_setup(void)
 {
 	ar71xx_gpio_function_enable(AR71XX_GPIO_FUNC_SPI_CS1_EN |
-				    AR71XX_GPIO_FUNC_SPI_CS2_EN);
+					AR71XX_GPIO_FUNC_SPI_CS2_EN);
 
 	ar71xx_add_device_leds_gpio(-1, ARRAY_SIZE(rb4xx_leds_gpio),
 					rb4xx_leds_gpio);
 
-	ar71xx_add_device_gpio_buttons(-1, RB4XX_BUTTONS_POLL_INTERVAL,
-					ARRAY_SIZE(rb4xx_gpio_buttons),
-					rb4xx_gpio_buttons);
+	ar71xx_register_gpio_keys_polled(-1, RB4XX_KEYS_POLL_INTERVAL,
+					 ARRAY_SIZE(rb4xx_gpio_keys),
+					 rb4xx_gpio_keys);
 
+	spi_register_board_info(rb4xx_spi_info, ARRAY_SIZE(rb4xx_spi_info));
+	platform_device_register(&rb4xx_spi_device);
 	platform_device_register(&rb4xx_nand_device);
 }
 
 static void __init rb411_setup(void)
 {
 	rb4xx_generic_setup();
-	rb4xx_add_device_spi();
+	spi_register_board_info(rb4xx_microsd_info,
+				ARRAY_SIZE(rb4xx_microsd_info));
 
-	ar71xx_add_device_mdio(0xfffffffc);
+	ar71xx_add_device_mdio(0, 0xfffffffc);
 
+	ar71xx_init_mac(ar71xx_eth0_data.mac_addr, ar71xx_mac_base, 0);
 	ar71xx_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
 	ar71xx_eth0_data.phy_mask = 0x00000003;
 
@@ -199,19 +241,25 @@ static void __init rb411u_setup(void)
 MIPS_MACHINE(AR71XX_MACH_RB_411U, "411U", "MikroTik RouterBOARD 411U",
 	     rb411u_setup);
 
+#define RB433_LAN_PHYMASK	BIT(0)
+#define RB433_WAN_PHYMASK	BIT(4)
+#define RB433_MDIO_PHYMASK	(RB433_LAN_PHYMASK | RB433_WAN_PHYMASK)
+
 static void __init rb433_setup(void)
 {
 	rb4xx_generic_setup();
-	rb433_add_device_spi();
+	spi_register_board_info(rb4xx_microsd_info,
+				ARRAY_SIZE(rb4xx_microsd_info));
 
-	ar71xx_add_device_mdio(0xffffffe9);
+	ar71xx_add_device_mdio(0, ~RB433_MDIO_PHYMASK);
 
+	ar71xx_init_mac(ar71xx_eth0_data.mac_addr, ar71xx_mac_base, 1);
 	ar71xx_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
-	ar71xx_eth0_data.speed = SPEED_100;
-	ar71xx_eth0_data.duplex = DUPLEX_FULL;
+	ar71xx_eth0_data.phy_mask = RB433_LAN_PHYMASK;
 
+	ar71xx_init_mac(ar71xx_eth1_data.mac_addr, ar71xx_mac_base, 0);
 	ar71xx_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
-	ar71xx_eth1_data.phy_mask = 0x00000010;
+	ar71xx_eth1_data.phy_mask = RB433_WAN_PHYMASK;
 
 	ar71xx_add_device_eth(1);
 	ar71xx_add_device_eth(0);
@@ -231,20 +279,24 @@ static void __init rb433u_setup(void)
 MIPS_MACHINE(AR71XX_MACH_RB_433U, "433U", "MikroTik RouterBOARD 433UAH",
 	     rb433u_setup);
 
+#define RB450_LAN_PHYMASK	BIT(0)
+#define RB450_WAN_PHYMASK	BIT(4)
+#define RB450_MDIO_PHYMASK	(RB450_LAN_PHYMASK | RB450_WAN_PHYMASK)
+
 static void __init rb450_generic_setup(int gige)
 {
 	rb4xx_generic_setup();
-	rb4xx_add_device_spi();
-
-	ar71xx_add_device_mdio(0xffffffe0);
+	ar71xx_add_device_mdio(0, ~RB450_MDIO_PHYMASK);
 
-	ar71xx_eth0_data.phy_if_mode = (gige) ? PHY_INTERFACE_MODE_RGMII : PHY_INTERFACE_MODE_MII;
-	ar71xx_eth0_data.phy_mask = (gige) ? (1 << 0) : 0;
-	ar71xx_eth0_data.speed = (gige) ? SPEED_1000 : SPEED_100;
-	ar71xx_eth0_data.duplex = DUPLEX_FULL;
+	ar71xx_init_mac(ar71xx_eth0_data.mac_addr, ar71xx_mac_base, 1);
+	ar71xx_eth0_data.phy_if_mode = (gige) ?
+		PHY_INTERFACE_MODE_RGMII : PHY_INTERFACE_MODE_MII;
+	ar71xx_eth0_data.phy_mask = RB450_LAN_PHYMASK;
 
-	ar71xx_eth1_data.phy_if_mode = (gige) ? PHY_INTERFACE_MODE_RGMII : PHY_INTERFACE_MODE_RMII;
-	ar71xx_eth1_data.phy_mask = 0x00000010;
+	ar71xx_init_mac(ar71xx_eth1_data.mac_addr, ar71xx_mac_base, 0);
+	ar71xx_eth1_data.phy_if_mode = (gige) ?
+		PHY_INTERFACE_MODE_RGMII : PHY_INTERFACE_MODE_RMII;
+	ar71xx_eth1_data.phy_mask = RB450_WAN_PHYMASK;
 
 	ar71xx_add_device_eth(1);
 	ar71xx_add_device_eth(0);
@@ -261,6 +313,8 @@ MIPS_MACHINE(AR71XX_MACH_RB_450, "450", "MikroTik RouterBOARD 450",
 static void __init rb450g_setup(void)
 {
 	rb450_generic_setup(1);
+	spi_register_board_info(rb4xx_microsd_info,
+				ARRAY_SIZE(rb4xx_microsd_info));
 }
 
 MIPS_MACHINE(AR71XX_MACH_RB_450G, "450G", "MikroTik RouterBOARD 450G",
@@ -269,14 +323,15 @@ MIPS_MACHINE(AR71XX_MACH_RB_450G, "450G", "MikroTik RouterBOARD 450G",
 static void __init rb493_setup(void)
 {
 	rb4xx_generic_setup();
-	rb4xx_add_device_spi();
 
-	ar71xx_add_device_mdio(0x3fffff00);
+	ar71xx_add_device_mdio(0, 0x3fffff00);
 
+	ar71xx_init_mac(ar71xx_eth0_data.mac_addr, ar71xx_mac_base, 0);
 	ar71xx_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
 	ar71xx_eth0_data.speed = SPEED_100;
 	ar71xx_eth0_data.duplex = DUPLEX_FULL;
 
+	ar71xx_init_mac(ar71xx_eth1_data.mac_addr, ar71xx_mac_base, 1);
 	ar71xx_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
 	ar71xx_eth1_data.phy_mask = 0x00000001;
 
@@ -288,3 +343,64 @@ static void __init rb493_setup(void)
 
 MIPS_MACHINE(AR71XX_MACH_RB_493, "493", "MikroTik RouterBOARD 493/AH",
 	     rb493_setup);
+
+#define RB493G_GPIO_MDIO_MDC		7
+#define RB493G_GPIO_MDIO_DATA		8
+
+#define RB493G_MDIO_PHYMASK		BIT(0)
+
+static struct mdio_gpio_platform_data rb493g_mdio_data = {
+	.mdc		= RB493G_GPIO_MDIO_MDC,
+	.mdio		= RB493G_GPIO_MDIO_DATA,
+
+	.phy_mask	= ~RB493G_MDIO_PHYMASK,
+};
+
+static struct platform_device rb493g_mdio_device = {
+	.name 		= "mdio-gpio",
+	.id 		= -1,
+	.dev 		= {
+		.platform_data	= &rb493g_mdio_data,
+	},
+};
+
+static void __init rb493g_setup(void)
+{
+	ar71xx_gpio_function_enable(AR71XX_GPIO_FUNC_SPI_CS1_EN |
+				    AR71XX_GPIO_FUNC_SPI_CS2_EN);
+
+	ar71xx_add_device_leds_gpio(-1, ARRAY_SIZE(rb4xx_leds_gpio),
+				    rb4xx_leds_gpio);
+
+	spi_register_board_info(rb4xx_spi_info, ARRAY_SIZE(rb4xx_spi_info));
+	platform_device_register(&rb4xx_spi_device);
+	platform_device_register(&rb4xx_nand_device);
+
+	ar71xx_add_device_mdio(0, ~RB493G_MDIO_PHYMASK);
+
+	ar71xx_init_mac(ar71xx_eth0_data.mac_addr, ar71xx_mac_base, 0);
+	ar71xx_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ar71xx_eth0_data.phy_mask = RB493G_MDIO_PHYMASK;
+	ar71xx_eth0_data.speed = SPEED_1000;
+	ar71xx_eth0_data.duplex = DUPLEX_FULL;
+
+	ar71xx_init_mac(ar71xx_eth1_data.mac_addr, ar71xx_mac_base, 1);
+	ar71xx_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ar71xx_eth1_data.mii_bus_dev = &rb493g_mdio_device.dev;
+	ar71xx_eth1_data.phy_mask = RB493G_MDIO_PHYMASK;
+	ar71xx_eth1_data.speed = SPEED_1000;
+	ar71xx_eth1_data.duplex = DUPLEX_FULL;
+
+
+	platform_device_register(&rb493g_mdio_device);
+
+	ar71xx_add_device_eth(1);
+	ar71xx_add_device_eth(0);
+
+	ar71xx_add_device_usb();
+
+	ar71xx_pci_init(ARRAY_SIZE(rb4xx_pci_irqs), rb4xx_pci_irqs);
+}
+
+MIPS_MACHINE(AR71XX_MACH_RB_493G, "493G", "MikroTik RouterBOARD 493G",
+	     rb493g_setup);
diff --git a/arch/mips/ar71xx/mach-rb750.c b/arch/mips/ar71xx/mach-rb750.c
index 3972f57..9b63dc3 100644
--- a/arch/mips/ar71xx/mach-rb750.c
+++ b/arch/mips/ar71xx/mach-rb750.c
@@ -13,7 +13,7 @@
 #include <asm/mach-ar71xx/mach-rb750.h>
 
 #include "machtype.h"
-#include "dev-ap91-eth.h"
+#include "devices.h"
 
 static struct rb750_led_data rb750_leds[] = {
 	{
@@ -55,13 +55,6 @@ static struct platform_device rb750_leds_device = {
 	}
 };
 
-static const char *rb750_port_names[AP91_ETH_NUM_PORT_NAMES] __initdata = {
-	"port5",
-	"port4",
-	"port3",
-	"port2",
-};
-
 static struct platform_device rb750_nand_device = {
 	.name	= "rb750-nand",
 	.id	= -1,
@@ -88,29 +81,29 @@ int rb750_latch_change(u32 mask_clr, u32 mask_set)
 	latch_clr = (latch_clr | mask_clr) & ~mask_set;
 
 	if (latch_oe == 0)
-		latch_oe = __raw_readl(ar71xx_gpio_base + GPIO_REG_OE);
+		latch_oe = __raw_readl(ar71xx_gpio_base + AR71XX_GPIO_REG_OE);
 
 	if (likely(latch_set & RB750_LVC573_LE)) {
 		void __iomem *base = ar71xx_gpio_base;
 
-		t = __raw_readl(base + GPIO_REG_OE);
+		t = __raw_readl(base + AR71XX_GPIO_REG_OE);
 		t |= mask_clr | latch_oe | mask_set;
 
-		__raw_writel(t, base + GPIO_REG_OE);
-		__raw_writel(latch_clr, base + GPIO_REG_CLEAR);
-		__raw_writel(latch_set, base + GPIO_REG_SET);
+		__raw_writel(t, base + AR71XX_GPIO_REG_OE);
+		__raw_writel(latch_clr, base + AR71XX_GPIO_REG_CLEAR);
+		__raw_writel(latch_set, base + AR71XX_GPIO_REG_SET);
 	} else if (mask_clr & RB750_LVC573_LE) {
 		void __iomem *base = ar71xx_gpio_base;
 
-		latch_oe = __raw_readl(base + GPIO_REG_OE);
-		__raw_writel(RB750_LVC573_LE, base + GPIO_REG_CLEAR);
+		latch_oe = __raw_readl(base + AR71XX_GPIO_REG_OE);
+		__raw_writel(RB750_LVC573_LE, base + AR71XX_GPIO_REG_CLEAR);
 		/* flush write */
-		__raw_readl(base + GPIO_REG_CLEAR);
+		__raw_readl(base + AR71XX_GPIO_REG_CLEAR);
 	}
 
 	ret = 1;
 
- unlock:
+unlock:
 	spin_unlock_irqrestore(&lock, flags);
 	return ret;
 }
@@ -124,7 +117,17 @@ static void __init rb750_setup(void)
 				     AR724X_GPIO_FUNC_ETH_SWITCH_LED3_EN |
 				     AR724X_GPIO_FUNC_ETH_SWITCH_LED4_EN);
 
-	ap91_eth_init(NULL, rb750_port_names);
+	ar71xx_init_mac(ar71xx_eth0_data.mac_addr, ar71xx_mac_base, 0);
+	ar71xx_init_mac(ar71xx_eth1_data.mac_addr, ar71xx_mac_base, 1);
+
+	ar71xx_add_device_mdio(0, 0x0);
+
+	/* LAN ports */
+	ar71xx_add_device_eth(1);
+
+	/* WAN port */
+	ar71xx_add_device_eth(0);
+
 	platform_device_register(&rb750_leds_device);
 	platform_device_register(&rb750_nand_device);
 }
diff --git a/arch/mips/ar71xx/mach-tew-632brp.c b/arch/mips/ar71xx/mach-tew-632brp.c
index 787f83e..b7f9cb6 100644
--- a/arch/mips/ar71xx/mach-tew-632brp.c
+++ b/arch/mips/ar71xx/mach-tew-632brp.c
@@ -17,7 +17,7 @@
 #include "machtype.h"
 #include "devices.h"
 #include "dev-m25p80.h"
-#include "dev-ar913x-wmac.h"
+#include "dev-ar9xxx-wmac.h"
 #include "dev-gpio-buttons.h"
 #include "dev-leds-gpio.h"
 #include "nvram.h"
@@ -28,7 +28,8 @@
 #define TEW_632BRP_GPIO_BTN_WPS		12
 #define TEW_632BRP_GPIO_BTN_RESET	21
 
-#define TEW_632BRP_BUTTONS_POLL_INTERVAL	20
+#define TEW_632BRP_KEYS_POLL_INTERVAL	20	/* msecs */
+#define TEW_632BRP_KEYS_DEBOUNCE_INTERVAL (3 * TEW_632BRP_KEYS_POLL_INTERVAL)
 
 #define TEW_632BRP_CONFIG_ADDR	0x1f020000
 #define TEW_632BRP_CONFIG_SIZE	0x10000
@@ -40,24 +41,24 @@ static struct mtd_partition tew_632brp_partitions[] = {
 		.offset		= 0,
 		.size		= 0x020000,
 		.mask_flags	= MTD_WRITEABLE,
-	} , {
+	}, {
 		.name		= "config",
 		.offset		= 0x020000,
 		.size		= 0x010000,
-	} , {
+	}, {
 		.name		= "kernel",
 		.offset		= 0x030000,
-		.size		= 0x0d0000,
-	} , {
+		.size		= 0x0e0000,
+	}, {
 		.name		= "rootfs",
-		.offset		= 0x100000,
-		.size		= 0x2f0000,
-	} , {
+		.offset		= 0x110000,
+		.size		= 0x2e0000,
+	}, {
 		.name		= "art",
 		.offset		= 0x3f0000,
 		.size		= 0x010000,
 		.mask_flags	= MTD_WRITEABLE,
-	} , {
+	}, {
 		.name		= "firmware",
 		.offset		= 0x030000,
 		.size		= 0x3c0000,
@@ -67,8 +68,8 @@ static struct mtd_partition tew_632brp_partitions[] = {
 
 static struct flash_platform_data tew_632brp_flash_data = {
 #ifdef CONFIG_MTD_PARTITIONS
-        .parts          = tew_632brp_partitions,
-        .nr_parts       = ARRAY_SIZE(tew_632brp_partitions),
+	.parts		= tew_632brp_partitions,
+	.nr_parts	= ARRAY_SIZE(tew_632brp_partitions),
 #endif
 };
 
@@ -88,18 +89,18 @@ static struct gpio_led tew_632brp_leds_gpio[] __initdata = {
 	}
 };
 
-static struct gpio_button tew_632brp_gpio_buttons[] __initdata = {
+static struct gpio_keys_button tew_632brp_gpio_keys[] __initdata = {
 	{
 		.desc		= "reset",
 		.type		= EV_KEY,
-		.code		= BTN_0,
-		.threshold	= 3,
+		.code		= KEY_RESTART,
+		.debounce_interval = TEW_632BRP_KEYS_DEBOUNCE_INTERVAL,
 		.gpio		= TEW_632BRP_GPIO_BTN_RESET,
 	}, {
 		.desc		= "wps",
 		.type		= EV_KEY,
-		.code		= BTN_1,
-		.threshold	= 3,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = TEW_632BRP_KEYS_DEBOUNCE_INTERVAL,
 		.gpio		= TEW_632BRP_GPIO_BTN_WPS,
 	}
 };
@@ -117,12 +118,13 @@ static void __init tew_632brp_setup(void)
 	u8 *wlan_mac = NULL;
 
 	if (nvram_parse_mac_addr(config, TEW_632BRP_CONFIG_SIZE,
-			         "lan_mac=", mac) == 0) {
-		ar71xx_set_mac_base(mac);
+				"lan_mac=", mac) == 0) {
+		ar71xx_init_mac(ar71xx_eth0_data.mac_addr, mac, 0);
+		ar71xx_init_mac(ar71xx_eth1_data.mac_addr, mac, 1);
 		wlan_mac = mac;
 	}
 
-	ar71xx_add_device_mdio(TEW_632BRP_MDIO_MASK);
+	ar71xx_add_device_mdio(0, TEW_632BRP_MDIO_MASK);
 
 	ar71xx_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
 	ar71xx_eth0_data.phy_mask = TEW_632BRP_LAN_PHYMASK;
@@ -138,11 +140,11 @@ static void __init tew_632brp_setup(void)
 	ar71xx_add_device_leds_gpio(-1, ARRAY_SIZE(tew_632brp_leds_gpio),
 					tew_632brp_leds_gpio);
 
-	ar71xx_add_device_gpio_buttons(-1, TEW_632BRP_BUTTONS_POLL_INTERVAL,
-					ARRAY_SIZE(tew_632brp_gpio_buttons),
-					tew_632brp_gpio_buttons);
+	ar71xx_register_gpio_keys_polled(-1, TEW_632BRP_KEYS_POLL_INTERVAL,
+					 ARRAY_SIZE(tew_632brp_gpio_keys),
+					 tew_632brp_gpio_keys);
 
-	ar913x_add_device_wmac(eeprom, wlan_mac);
+	ar9xxx_add_device_wmac(eeprom, wlan_mac);
 }
 
 MIPS_MACHINE(AR71XX_MACH_TEW_632BRP, "TEW-632BRP", "TRENDnet TEW-632BRP",
diff --git a/arch/mips/ar71xx/mach-tl-mr3x20.c b/arch/mips/ar71xx/mach-tl-mr3x20.c
new file mode 100644
index 0000000..ee1a4b6
--- /dev/null
+++ b/arch/mips/ar71xx/mach-tl-mr3x20.c
@@ -0,0 +1,157 @@
+/*
+ *  TP-LINK TL-MR3220/3420 board support
+ *
+ *  Copyright (C) 2010 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/gpio.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/mach-ar71xx/ar71xx.h>
+
+#include "machtype.h"
+#include "devices.h"
+#include "dev-m25p80.h"
+#include "dev-ap91-pci.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-usb.h"
+
+#define TL_MR3X20_GPIO_LED_QSS		0
+#define TL_MR3X20_GPIO_LED_SYSTEM	1
+#define TL_MR3X20_GPIO_LED_3G		8
+
+#define TL_MR3X20_GPIO_BTN_RESET	11
+#define TL_MR3X20_GPIO_BTN_QSS		12
+
+#define TL_MR3X20_GPIO_USB_POWER	6
+
+#define TL_MR3X20_KEYS_POLL_INTERVAL	20	/* msecs */
+#define TL_MR3X20_KEYS_DEBOUNCE_INTERVAL (3 * TL_MR3X20_KEYS_POLL_INTERVAL)
+
+#ifdef CONFIG_MTD_PARTITIONS
+static struct mtd_partition tl_mr3x20_partitions[] = {
+	{
+		.name		= "u-boot",
+		.offset		= 0,
+		.size		= 0x020000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "kernel",
+		.offset		= 0x020000,
+		.size		= 0x140000,
+	}, {
+		.name		= "rootfs",
+		.offset		= 0x160000,
+		.size		= 0x290000,
+	}, {
+		.name		= "art",
+		.offset		= 0x3f0000,
+		.size		= 0x010000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "firmware",
+		.offset		= 0x020000,
+		.size		= 0x3d0000,
+	}
+};
+#define tl_mr3x20_num_partitions	ARRAY_SIZE(tl_mr3x20_partitions)
+#else
+#define tl_mr3x20_partitions		NULL
+#define tl_mr3x20_num_partitions	0
+#endif /* CONFIG_MTD_PARTITIONS */
+
+static struct flash_platform_data tl_mr3x20_flash_data = {
+	.parts		= tl_mr3x20_partitions,
+	.nr_parts	= tl_mr3x20_num_partitions,
+};
+
+static struct gpio_led tl_mr3x20_leds_gpio[] __initdata = {
+	{
+		.name		= "tp-link:green:system",
+		.gpio		= TL_MR3X20_GPIO_LED_SYSTEM,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:qss",
+		.gpio		= TL_MR3X20_GPIO_LED_QSS,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:3g",
+		.gpio		= TL_MR3X20_GPIO_LED_3G,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button tl_mr3x20_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = TL_MR3X20_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_MR3X20_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}, {
+		.desc		= "qss",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = TL_MR3X20_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_MR3X20_GPIO_BTN_QSS,
+		.active_low	= 1,
+	}
+};
+
+static void __init tl_mr3x20_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f01fc00);
+	u8 *ee = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	/* enable power for the USB port */
+	gpio_request(TL_MR3X20_GPIO_USB_POWER, "USB power");
+	gpio_direction_output(TL_MR3X20_GPIO_USB_POWER, 1);
+
+	ar71xx_add_device_m25p80(&tl_mr3x20_flash_data);
+
+	ar71xx_add_device_leds_gpio(-1, ARRAY_SIZE(tl_mr3x20_leds_gpio),
+					tl_mr3x20_leds_gpio);
+
+	ar71xx_register_gpio_keys_polled(-1, TL_MR3X20_KEYS_POLL_INTERVAL,
+					 ARRAY_SIZE(tl_mr3x20_gpio_keys),
+					 tl_mr3x20_gpio_keys);
+
+	ar71xx_init_mac(ar71xx_eth0_data.mac_addr, mac, 0);
+	ar71xx_init_mac(ar71xx_eth1_data.mac_addr, mac, 1);
+
+	ar71xx_add_device_mdio(0, 0x0);
+
+	/* LAN ports */
+	ar71xx_add_device_eth(1);
+	/* WAN port */
+	ar71xx_add_device_eth(0);
+
+	ar71xx_add_device_usb();
+
+	ap91_pci_init(ee, mac);
+}
+
+static void __init tl_mr3220_setup(void)
+{
+	tl_mr3x20_setup();
+	ap91_pci_setup_wmac_led_pin(1);
+}
+
+MIPS_MACHINE(AR71XX_MACH_TL_MR3220, "TL-MR3220", "TP-LINK TL-MR3220",
+	     tl_mr3220_setup);
+
+static void __init tl_mr3420_setup(void)
+{
+	tl_mr3x20_setup();
+	ap91_pci_setup_wmac_led_pin(0);
+}
+
+MIPS_MACHINE(AR71XX_MACH_TL_MR3420, "TL-MR3420", "TP-LINK TL-MR3420",
+	     tl_mr3420_setup);
diff --git a/arch/mips/ar71xx/mach-tl-wa901nd-v2.c b/arch/mips/ar71xx/mach-tl-wa901nd-v2.c
new file mode 100644
index 0000000..ab5d187
--- /dev/null
+++ b/arch/mips/ar71xx/mach-tl-wa901nd-v2.c
@@ -0,0 +1,132 @@
+/*
+ *  TP-LINK TL-WA901ND v2 board support
+ *
+ *  Copyright (C) 2009-2010 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2010 Pieter Hollants <pieter@hollants.com>
+ *  Copyright (C) 2011 Jonathan Bennett <jbscience87@gmail.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/mach-ar71xx/ar71xx.h>
+
+#include "machtype.h"
+#include "devices.h"
+#include "dev-m25p80.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-ar9xxx-wmac.h"
+
+#define TL_WA901ND_V2_GPIO_LED_QSS		4
+#define TL_WA901ND_V2_GPIO_LED_SYSTEM		2
+#define TL_WA901ND_V2_GPIO_LED_WLAN		9
+
+
+#define TL_WA901ND_V2_GPIO_BTN_RESET		3
+#define TL_WA901ND_V2_GPIO_BTN_QSS		7
+
+#define TL_WA901ND_V2_KEYS_POLL_INTERVAL	20	/* msecs */
+#define TL_WA901ND_V2_KEYS_DEBOUNCE_INTERVAL	\
+					(3 * TL_WA901ND_V2_KEYS_POLL_INTERVAL)
+#ifdef CONFIG_MTD_PARTITIONS
+static struct mtd_partition tl_wa901nd_v2_partitions[] = {
+	{
+		.name		= "u-boot",
+		.offset		= 0,
+		.size		= 0x020000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "kernel",
+		.offset		= 0x020000,
+		.size		= 0x140000,
+	}, {
+		.name		= "rootfs",
+		.offset		= 0x160000,
+		.size		= 0x290000,
+	}, {
+		.name		= "art",
+		.offset		= 0x3f0000,
+		.size		= 0x010000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "firmware",
+		.offset		= 0x020000,
+		.size		= 0x3d0000,
+	}
+};
+#endif /* CONFIG_MTD_PARTITIONS */
+
+static struct flash_platform_data tl_wa901nd_v2_flash_data = {
+#ifdef CONFIG_MTD_PARTITIONS
+	.parts		= tl_wa901nd_v2_partitions,
+	.nr_parts	= ARRAY_SIZE(tl_wa901nd_v2_partitions),
+#endif
+};
+
+static struct gpio_led tl_wa901nd_v2_leds_gpio[] __initdata = {
+	{
+		.name		= "tp-link:green:system",
+		.gpio		= TL_WA901ND_V2_GPIO_LED_SYSTEM,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:qss",
+		.gpio		= TL_WA901ND_V2_GPIO_LED_QSS,
+	}, {
+		.name		= "tp-link:green:wlan",
+		.gpio		= TL_WA901ND_V2_GPIO_LED_WLAN,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button tl_wa901nd_v2_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = TL_WA901ND_V2_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_WA901ND_V2_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}, {
+		.desc		= "qss",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = TL_WA901ND_V2_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_WA901ND_V2_GPIO_BTN_QSS,
+		.active_low	= 1,
+	}
+};
+
+static void __init tl_wa901nd_v2_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f01fc00);
+	u8 *eeprom  = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	ar71xx_init_mac(ar71xx_eth0_data.mac_addr, mac, 0);
+
+	ar71xx_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ar71xx_eth0_data.phy_mask = 0x00001000;
+	ar71xx_add_device_mdio(0, 0x0);
+
+	ar71xx_eth0_data.reset_bit = RESET_MODULE_GE0_MAC |
+				     RESET_MODULE_GE0_PHY;
+	ar71xx_add_device_eth(0);
+
+	ar71xx_add_device_m25p80(&tl_wa901nd_v2_flash_data);
+
+	ar71xx_add_device_leds_gpio(-1, ARRAY_SIZE(tl_wa901nd_v2_leds_gpio),
+					tl_wa901nd_v2_leds_gpio);
+
+	ar71xx_register_gpio_keys_polled(-1, TL_WA901ND_V2_KEYS_POLL_INTERVAL,
+					 ARRAY_SIZE(tl_wa901nd_v2_gpio_keys),
+					 tl_wa901nd_v2_gpio_keys);
+
+        ar9xxx_add_device_wmac(eeprom, mac);
+}
+
+MIPS_MACHINE(AR71XX_MACH_TL_WA901ND_V2, "TL-WA901ND-v2",
+	     "TP-LINK TL-WA901ND v2", tl_wa901nd_v2_setup);
diff --git a/arch/mips/ar71xx/mach-tl-wa901nd.c b/arch/mips/ar71xx/mach-tl-wa901nd.c
new file mode 100644
index 0000000..ebe7ab5
--- /dev/null
+++ b/arch/mips/ar71xx/mach-tl-wa901nd.c
@@ -0,0 +1,125 @@
+/*
+ *  TP-LINK TL-WA901ND board support
+ *
+ *  Copyright (C) 2009-2010 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2010 Pieter Hollants <pieter@hollants.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/mach-ar71xx/ar71xx.h>
+
+#include "machtype.h"
+#include "devices.h"
+#include "dev-m25p80.h"
+#include "dev-ap91-pci.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+
+#define TL_WA901ND_GPIO_LED_QSS		0
+#define TL_WA901ND_GPIO_LED_SYSTEM	1
+
+#define TL_WA901ND_GPIO_BTN_RESET	11
+#define TL_WA901ND_GPIO_BTN_QSS		12
+
+#define TL_WA901ND_KEYS_POLL_INTERVAL	20	/* msecs */
+#define TL_WA901ND_KEYS_DEBOUNCE_INTERVAL (3 * TL_WA901ND_KEYS_POLL_INTERVAL)
+
+#ifdef CONFIG_MTD_PARTITIONS
+static struct mtd_partition tl_wa901nd_partitions[] = {
+	{
+		.name		= "u-boot",
+		.offset		= 0,
+		.size		= 0x020000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "kernel",
+		.offset		= 0x020000,
+		.size		= 0x140000,
+	}, {
+		.name		= "rootfs",
+		.offset		= 0x160000,
+		.size		= 0x290000,
+	}, {
+		.name		= "art",
+		.offset		= 0x3f0000,
+		.size		= 0x010000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "firmware",
+		.offset		= 0x020000,
+		.size		= 0x3d0000,
+	}
+};
+#endif /* CONFIG_MTD_PARTITIONS */
+
+static struct flash_platform_data tl_wa901nd_flash_data = {
+#ifdef CONFIG_MTD_PARTITIONS
+	.parts		= tl_wa901nd_partitions,
+	.nr_parts	= ARRAY_SIZE(tl_wa901nd_partitions),
+#endif
+};
+
+static struct gpio_led tl_wa901nd_leds_gpio[] __initdata = {
+	{
+		.name		= "tp-link:green:system",
+		.gpio		= TL_WA901ND_GPIO_LED_SYSTEM,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:qss",
+		.gpio		= TL_WA901ND_GPIO_LED_QSS,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button tl_wa901nd_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= BTN_0,
+		.debounce_interval = TL_WA901ND_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_WA901ND_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}, {
+		.desc		= "qss",
+		.type		= EV_KEY,
+		.code		= BTN_1,
+		.debounce_interval = TL_WA901ND_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_WA901ND_GPIO_BTN_QSS,
+		.active_low	= 1,
+	}
+};
+
+static void __init tl_wa901nd_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f01fc00);
+	u8 *ee  = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	/*
+	 * ar71xx_eth0 would be the WAN port, but is not connected on
+	 * the TL-WA901ND. ar71xx_eth1 connects to the internal switch chip,
+	 * however we have a single LAN port only.
+	 */
+	ar71xx_init_mac(ar71xx_eth1_data.mac_addr, mac, 0);
+	ar71xx_add_device_mdio(0, 0x0);
+	ar71xx_add_device_eth(1);
+
+	ar71xx_add_device_m25p80(&tl_wa901nd_flash_data);
+
+	ar71xx_add_device_leds_gpio(-1, ARRAY_SIZE(tl_wa901nd_leds_gpio),
+					tl_wa901nd_leds_gpio);
+
+	ar71xx_register_gpio_keys_polled(-1, TL_WA901ND_KEYS_POLL_INTERVAL,
+					 ARRAY_SIZE(tl_wa901nd_gpio_keys),
+					 tl_wa901nd_gpio_keys);
+
+	ap91_pci_init(ee, mac);
+}
+
+MIPS_MACHINE(AR71XX_MACH_TL_WA901ND, "TL-WA901ND", "TP-LINK TL-WA901ND",
+	     tl_wa901nd_setup);
diff --git a/arch/mips/ar71xx/mach-tl-wr1043nd.c b/arch/mips/ar71xx/mach-tl-wr1043nd.c
index 3b7b764..91aee70 100644
--- a/arch/mips/ar71xx/mach-tl-wr1043nd.c
+++ b/arch/mips/ar71xx/mach-tl-wr1043nd.c
@@ -11,13 +11,13 @@
 #include <linux/mtd/mtd.h>
 #include <linux/mtd/partitions.h>
 #include <linux/platform_device.h>
-#include <linux/rtl8366rb.h>
+#include <linux/rtl8366.h>
 #include <asm/mach-ar71xx/ar71xx.h>
 
 #include "machtype.h"
 #include "devices.h"
 #include "dev-m25p80.h"
-#include "dev-ar913x-wmac.h"
+#include "dev-ar9xxx-wmac.h"
 #include "dev-gpio-buttons.h"
 #include "dev-leds-gpio.h"
 #include "dev-usb.h"
@@ -33,7 +33,8 @@
 #define TL_WR1043ND_GPIO_RTL8366_SDA	18
 #define TL_WR1043ND_GPIO_RTL8366_SCK	19
 
-#define TL_WR1043ND_BUTTONS_POLL_INTERVAL     20
+#define TL_WR1043ND_KEYS_POLL_INTERVAL	20	/* msecs */
+#define TL_WR1043ND_KEYS_DEBOUNCE_INTERVAL (3 * TL_WR1043ND_KEYS_POLL_INTERVAL)
 
 #ifdef CONFIG_MTD_PARTITIONS
 static struct mtd_partition tl_wr1043nd_partitions[] = {
@@ -42,20 +43,20 @@ static struct mtd_partition tl_wr1043nd_partitions[] = {
 		.offset		= 0,
 		.size		= 0x020000,
 		.mask_flags	= MTD_WRITEABLE,
-	} , {
+	}, {
 		.name		= "kernel",
 		.offset		= 0x020000,
 		.size		= 0x140000,
-	} , {
+	}, {
 		.name		= "rootfs",
 		.offset		= 0x160000,
 		.size		= 0x690000,
-	} , {
+	}, {
 		.name		= "art",
 		.offset		= 0x7f0000,
 		.size		= 0x010000,
 		.mask_flags	= MTD_WRITEABLE,
-	} , {
+	}, {
 		.name		= "firmware",
 		.offset		= 0x020000,
 		.size		= 0x7d0000,
@@ -72,43 +73,43 @@ static struct flash_platform_data tl_wr1043nd_flash_data = {
 
 static struct gpio_led tl_wr1043nd_leds_gpio[] __initdata = {
 	{
-		.name		= "tl-wr1043nd:green:usb",
+		.name		= "tp-link:green:usb",
 		.gpio		= TL_WR1043ND_GPIO_LED_USB,
 		.active_low	= 1,
 	}, {
-		.name		= "tl-wr1043nd:green:system",
+		.name		= "tp-link:green:system",
 		.gpio		= TL_WR1043ND_GPIO_LED_SYSTEM,
 		.active_low	= 1,
 	}, {
-		.name		= "tl-wr1043nd:green:qss",
+		.name		= "tp-link:green:qss",
 		.gpio		= TL_WR1043ND_GPIO_LED_QSS,
 		.active_low	= 0,
 	}, {
-		.name		= "tl-wr1043nd:green:wlan",
+		.name		= "tp-link:green:wlan",
 		.gpio		= TL_WR1043ND_GPIO_LED_WLAN,
 		.active_low	= 1,
 	}
 };
 
-static struct gpio_button tl_wr1043nd_gpio_buttons[] __initdata = {
+static struct gpio_keys_button tl_wr1043nd_gpio_keys[] __initdata = {
 	{
 		.desc		= "reset",
 		.type		= EV_KEY,
-		.code		= BTN_0,
-		.threshold	= 3,
+		.code		= KEY_RESTART,
+		.debounce_interval = TL_WR1043ND_KEYS_DEBOUNCE_INTERVAL,
 		.gpio		= TL_WR1043ND_GPIO_BTN_RESET,
 		.active_low	= 1,
 	}, {
 		.desc		= "qss",
 		.type		= EV_KEY,
-		.code		= BTN_1,
-		.threshold	= 3,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = TL_WR1043ND_KEYS_DEBOUNCE_INTERVAL,
 		.gpio		= TL_WR1043ND_GPIO_BTN_QSS,
 		.active_low	= 1,
 	}
 };
 
-static struct rtl8366rb_platform_data tl_wr1043nd_rtl8366rb_data = {
+static struct rtl8366_platform_data tl_wr1043nd_rtl8366rb_data = {
 	.gpio_sda        = TL_WR1043ND_GPIO_RTL8366_SDA,
 	.gpio_sck        = TL_WR1043ND_GPIO_RTL8366_SCK,
 };
@@ -126,8 +127,7 @@ static void __init tl_wr1043nd_setup(void)
 	u8 *mac = (u8 *) KSEG1ADDR(0x1f01fc00);
 	u8 *eeprom = (u8 *) KSEG1ADDR(0x1fff1000);
 
-	ar71xx_set_mac_base(mac);
-
+	ar71xx_init_mac(ar71xx_eth0_data.mac_addr, mac, 0);
 	ar71xx_eth0_data.mii_bus_dev = &tl_wr1043nd_rtl8366rb_device.dev;
 	ar71xx_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
 	ar71xx_eth0_data.speed = SPEED_1000;
@@ -145,11 +145,11 @@ static void __init tl_wr1043nd_setup(void)
 
 	platform_device_register(&tl_wr1043nd_rtl8366rb_device);
 
-	ar71xx_add_device_gpio_buttons(-1, TL_WR1043ND_BUTTONS_POLL_INTERVAL,
-					ARRAY_SIZE(tl_wr1043nd_gpio_buttons),
-					tl_wr1043nd_gpio_buttons);
+	ar71xx_register_gpio_keys_polled(-1, TL_WR1043ND_KEYS_POLL_INTERVAL,
+					 ARRAY_SIZE(tl_wr1043nd_gpio_keys),
+					 tl_wr1043nd_gpio_keys);
 
-	ar913x_add_device_wmac(eeprom, mac);
+	ar9xxx_add_device_wmac(eeprom, mac);
 }
 
 MIPS_MACHINE(AR71XX_MACH_TL_WR1043ND, "TL-WR1043ND", "TP-LINK TL-WR1043ND",
diff --git a/arch/mips/ar71xx/mach-tl-wr703n.c b/arch/mips/ar71xx/mach-tl-wr703n.c
new file mode 100644
index 0000000..6ddd33b
--- /dev/null
+++ b/arch/mips/ar71xx/mach-tl-wr703n.c
@@ -0,0 +1,116 @@
+/*
+ *  TP-LINK TL-WR703N board support
+ *
+ *  Copyright (C) 2011 dongyuqi <729650915@qq.com>
+ *  Copyright (C) 2011 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <linux/spi/flash.h>
+#include <linux/gpio.h>
+
+#include <asm/mach-ar71xx/ar71xx.h>
+
+#include "machtype.h"
+#include "devices.h"
+#include "dev-ar9xxx-wmac.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+
+#define TL_WR703N_GPIO_LED_SYSTEM	27
+#define TL_WR703N_GPIO_BTN_RESET	11
+
+#define TL_WR703N_GPIO_USB_POWER	8
+
+#define TL_WR703N_KEYS_POLL_INTERVAL	20	/* msecs */
+#define TL_WR703N_KEYS_DEBOUNCE_INTERVAL	(3 * TL_WR703N_KEYS_POLL_INTERVAL)
+
+#ifdef CONFIG_MTD_PARTITIONS
+static struct mtd_partition tl_wr703n_parts[] = {
+	{
+		.name		= "u-boot",
+		.offset		= 0,
+		.size		= 0x020000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "kernel",
+		.offset		= 0x020000,
+		.size		= 0x100000,
+	}, {
+		.name		= "rootfs",
+		.offset		= 0x120000,
+		.size		= 0x2d0000,
+	}, {
+		.name		= "art",
+		.offset		= 0x3f0000,
+		.size		= 0x010000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "firmware",
+		.offset		= 0x020000,
+		.size		= 0x3d0000,
+	}
+};
+#define tl_wr703n_nr_parts	ARRAY_SIZE(tl_wr703n_parts)
+#else
+#define tl_wr703n_parts		NULL
+#define tl_wr703n_nr_parts	0
+#endif /* CONFIG_MTD_PARTITIONS */
+
+static struct flash_platform_data tl_wr703n_flash_data = {
+	.parts		= tl_wr703n_parts,
+	.nr_parts	= tl_wr703n_nr_parts,
+};
+
+static struct gpio_led tl_wr703n_leds_gpio[] __initdata = {
+	{
+		.name		= "tp-link:blue:system",
+		.gpio		= TL_WR703N_GPIO_LED_SYSTEM,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button tl_wr703n_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = TL_WR703N_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_WR703N_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}
+};
+
+static void __init tl_wr703n_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f01fc00);
+	u8 *ee = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	ar71xx_add_device_m25p80(&tl_wr703n_flash_data);
+	ar71xx_add_device_leds_gpio(-1, ARRAY_SIZE(tl_wr703n_leds_gpio),
+					tl_wr703n_leds_gpio);
+	ar71xx_register_gpio_keys_polled(-1, TL_WR703N_KEYS_POLL_INTERVAL,
+					 ARRAY_SIZE(tl_wr703n_gpio_keys),
+					 tl_wr703n_gpio_keys);
+
+	gpio_request(TL_WR703N_GPIO_USB_POWER, "USB power");
+	gpio_direction_output(TL_WR703N_GPIO_USB_POWER, 1);
+	ar71xx_add_device_usb();
+
+	ar71xx_init_mac(ar71xx_eth0_data.mac_addr, mac, 0);
+
+	ar71xx_add_device_mdio(0, 0x0);
+	ar71xx_add_device_eth(0);
+
+	ar9xxx_add_device_wmac(ee, mac);
+}
+
+MIPS_MACHINE(AR71XX_MACH_TL_WR703N, "TL-WR703N", "TP-LINK TL-WR703N v1",
+	     tl_wr703n_setup);
diff --git a/arch/mips/ar71xx/mach-tl-wr741nd-v4.c b/arch/mips/ar71xx/mach-tl-wr741nd-v4.c
new file mode 100644
index 0000000..0760008
--- /dev/null
+++ b/arch/mips/ar71xx/mach-tl-wr741nd-v4.c
@@ -0,0 +1,146 @@
+/*
+ *  TP-LINK TL-WR741ND v4 board support
+ *
+ *  Copyright (C) 2011 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <linux/spi/flash.h>
+#include <linux/gpio.h>
+
+#include <asm/mach-ar71xx/ar71xx.h>
+
+#include "machtype.h"
+#include "devices.h"
+#include "dev-ar9xxx-wmac.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+
+#define TL_WR741NDV4_GPIO_BTN_RESET	11
+#define TL_WR741NDV4_GPIO_BTN_WPS	26
+
+#define TL_WR741NDV4_GPIO_LED_WLAN	0
+#define TL_WR741NDV4_GPIO_LED_QSS	1
+#define TL_WR741NDV4_GPIO_LED_SYSTEM	27
+
+#define TL_WR741NDV4_KEYS_POLL_INTERVAL	20	/* msecs */
+#define TL_WR741NDV4_KEYS_DEBOUNCE_INTERVAL (3 * TL_WR741NDV4_KEYS_POLL_INTERVAL)
+
+#ifdef CONFIG_MTD_PARTITIONS
+static struct mtd_partition tl_wr741ndv4_parts[] = {
+	{
+		.name		= "u-boot",
+		.offset		= 0,
+		.size		= 0x020000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "kernel",
+		.offset		= 0x020000,
+		.size		= 0x100000,
+	}, {
+		.name		= "rootfs",
+		.offset		= 0x120000,
+		.size		= 0x2d0000,
+	}, {
+		.name		= "art",
+		.offset		= 0x3f0000,
+		.size		= 0x010000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "firmware",
+		.offset		= 0x020000,
+		.size		= 0x3d0000,
+	}
+};
+#define tl_wr741ndv4_nr_parts	ARRAY_SIZE(tl_wr741ndv4_parts)
+#else
+#define tl_wr741ndv4_parts	NULL
+#define tl_wr741ndv4_nr_parts	0
+#endif /* CONFIG_MTD_PARTITIONS */
+
+static struct flash_platform_data tl_wr741ndv4_flash_data = {
+	.parts		= tl_wr741ndv4_parts,
+	.nr_parts	= tl_wr741ndv4_nr_parts,
+};
+
+static struct gpio_led tl_wr741ndv4_leds_gpio[] __initdata = {
+	{
+		.name		= "tp-link:green:system",
+		.gpio		= TL_WR741NDV4_GPIO_LED_SYSTEM,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:qss",
+		.gpio		= TL_WR741NDV4_GPIO_LED_QSS,
+		.active_low	= 0,
+	}, {
+		.name		= "tp-link:green:wlan",
+		.gpio		= TL_WR741NDV4_GPIO_LED_WLAN,
+		.active_low	= 0,
+	},
+};
+
+static struct gpio_keys_button tl_wr741ndv4_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = TL_WR741NDV4_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_WR741NDV4_GPIO_BTN_RESET,
+		.active_low	= 1,
+	} , {
+		.desc		= "WPS",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = TL_WR741NDV4_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_WR741NDV4_GPIO_BTN_WPS,
+		.active_low	= 1,
+	}
+};
+
+static void __init tl_wr741ndv4_gmac_setup(void)
+{
+	void __iomem *base;
+	u32 t;
+
+	base = ioremap(AR933X_GMAC_BASE, AR933X_GMAC_SIZE);
+
+	t = __raw_readl(base + AR933X_GMAC_REG_ETH_CFG);
+	t |= (AR933X_ETH_CFG_SW_PHY_SWAP | AR933X_ETH_CFG_SW_PHY_ADDR_SWAP);
+	__raw_writel(t, base + AR933X_GMAC_REG_ETH_CFG);
+
+	iounmap(base);
+}
+
+static void __init tl_wr741ndv4_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f01fc00);
+	u8 *ee = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	tl_wr741ndv4_gmac_setup();
+
+	ar71xx_add_device_leds_gpio(-1, ARRAY_SIZE(tl_wr741ndv4_leds_gpio),
+					tl_wr741ndv4_leds_gpio);
+
+	ar71xx_register_gpio_keys_polled(1, TL_WR741NDV4_KEYS_POLL_INTERVAL,
+					 ARRAY_SIZE(tl_wr741ndv4_gpio_keys),
+					 tl_wr741ndv4_gpio_keys);
+
+	ar71xx_add_device_m25p80(&tl_wr741ndv4_flash_data);
+	ar71xx_init_mac(ar71xx_eth0_data.mac_addr, mac, 0);
+	ar71xx_init_mac(ar71xx_eth1_data.mac_addr, mac, 1);
+
+	ar71xx_add_device_mdio(0, 0x0);
+	ar71xx_add_device_eth(1);
+	ar71xx_add_device_eth(0);
+
+	ar9xxx_add_device_wmac(ee, mac);
+}
+
+MIPS_MACHINE(AR71XX_MACH_TL_WR741ND_V4, "TL-WR741ND-v4",
+	     "TP-LINK TL-WR741ND v4", tl_wr741ndv4_setup);
diff --git a/arch/mips/ar71xx/mach-tl-wr741nd.c b/arch/mips/ar71xx/mach-tl-wr741nd.c
index 5014ece..60e6d24 100644
--- a/arch/mips/ar71xx/mach-tl-wr741nd.c
+++ b/arch/mips/ar71xx/mach-tl-wr741nd.c
@@ -16,7 +16,6 @@
 #include "machtype.h"
 #include "devices.h"
 #include "dev-m25p80.h"
-#include "dev-ap91-eth.h"
 #include "dev-ap91-pci.h"
 #include "dev-gpio-buttons.h"
 #include "dev-leds-gpio.h"
@@ -27,7 +26,8 @@
 #define TL_WR741ND_GPIO_BTN_RESET	11
 #define TL_WR741ND_GPIO_BTN_QSS		12
 
-#define TL_WR741ND_BUTTONS_POLL_INTERVAL	20
+#define TL_WR741ND_KEYS_POLL_INTERVAL	20	/* msecs */
+#define TL_WR741ND_KEYS_DEBOUNCE_INTERVAL (3 * TL_WR741ND_KEYS_POLL_INTERVAL)
 
 #ifdef CONFIG_MTD_PARTITIONS
 static struct mtd_partition tl_wr741nd_partitions[] = {
@@ -36,20 +36,20 @@ static struct mtd_partition tl_wr741nd_partitions[] = {
 		.offset		= 0,
 		.size		= 0x020000,
 		.mask_flags	= MTD_WRITEABLE,
-	} , {
+	}, {
 		.name		= "kernel",
 		.offset		= 0x020000,
 		.size		= 0x140000,
-	} , {
+	}, {
 		.name		= "rootfs",
 		.offset		= 0x160000,
 		.size		= 0x290000,
-	} , {
+	}, {
 		.name		= "art",
 		.offset		= 0x3f0000,
 		.size		= 0x010000,
 		.mask_flags	= MTD_WRITEABLE,
-	} , {
+	}, {
 		.name		= "firmware",
 		.offset		= 0x020000,
 		.size		= 0x3d0000,
@@ -59,36 +59,36 @@ static struct mtd_partition tl_wr741nd_partitions[] = {
 
 static struct flash_platform_data tl_wr741nd_flash_data = {
 #ifdef CONFIG_MTD_PARTITIONS
-        .parts          = tl_wr741nd_partitions,
-        .nr_parts       = ARRAY_SIZE(tl_wr741nd_partitions),
+	.parts		= tl_wr741nd_partitions,
+	.nr_parts	= ARRAY_SIZE(tl_wr741nd_partitions),
 #endif
 };
 
 static struct gpio_led tl_wr741nd_leds_gpio[] __initdata = {
 	{
-		.name		= "tl-wr741nd:green:system",
+		.name		= "tp-link:green:system",
 		.gpio		= TL_WR741ND_GPIO_LED_SYSTEM,
 		.active_low	= 1,
 	}, {
-		.name		= "tl-wr741nd:green:qss",
+		.name		= "tp-link:green:qss",
 		.gpio		= TL_WR741ND_GPIO_LED_QSS,
 		.active_low	= 1,
 	}
 };
 
-static struct gpio_button tl_wr741nd_gpio_buttons[] __initdata = {
+static struct gpio_keys_button tl_wr741nd_gpio_keys[] __initdata = {
 	{
 		.desc		= "reset",
 		.type		= EV_KEY,
-		.code		= BTN_0,
-		.threshold	= 3,
+		.code		= KEY_RESTART,
+		.debounce_interval = TL_WR741ND_KEYS_DEBOUNCE_INTERVAL,
 		.gpio		= TL_WR741ND_GPIO_BTN_RESET,
 		.active_low	= 1,
 	}, {
 		.desc		= "qss",
 		.type		= EV_KEY,
-		.code		= BTN_1,
-		.threshold	= 3,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = TL_WR741ND_KEYS_DEBOUNCE_INTERVAL,
 		.gpio		= TL_WR741ND_GPIO_BTN_QSS,
 		.active_low	= 1,
 	}
@@ -104,27 +104,23 @@ static void __init tl_wr741nd_setup(void)
 	ar71xx_add_device_leds_gpio(-1, ARRAY_SIZE(tl_wr741nd_leds_gpio),
 					tl_wr741nd_leds_gpio);
 
-	ar71xx_add_device_gpio_buttons(-1, TL_WR741ND_BUTTONS_POLL_INTERVAL,
-					ARRAY_SIZE(tl_wr741nd_gpio_buttons),
-					tl_wr741nd_gpio_buttons);
+	ar71xx_register_gpio_keys_polled(-1, TL_WR741ND_KEYS_POLL_INTERVAL,
+					 ARRAY_SIZE(tl_wr741nd_gpio_keys),
+					 tl_wr741nd_gpio_keys);
 
-	ar71xx_eth1_data.has_ar7240_switch = 1;
-	ar71xx_set_mac_base(mac);
+	ar71xx_init_mac(ar71xx_eth0_data.mac_addr, mac, 0);
+	ar71xx_init_mac(ar71xx_eth1_data.mac_addr, mac, 1);
 
-	/* WAN port */
-	ar71xx_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
-	ar71xx_eth0_data.speed = SPEED_100;
-	ar71xx_eth0_data.duplex = DUPLEX_FULL;
+	ar71xx_add_device_mdio(0, 0x0);
 
 	/* LAN ports */
-	ar71xx_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
-	ar71xx_eth1_data.speed = SPEED_1000;
-	ar71xx_eth1_data.duplex = DUPLEX_FULL;
-
-	ar71xx_add_device_mdio(0x0);
 	ar71xx_add_device_eth(1);
+
+	/* WAN port */
 	ar71xx_add_device_eth(0);
 
+	ap91_pci_setup_wmac_led_pin(1);
+
 	ap91_pci_init(ee, mac);
 }
 MIPS_MACHINE(AR71XX_MACH_TL_WR741ND, "TL-WR741ND", "TP-LINK TL-WR741ND",
diff --git a/arch/mips/ar71xx/mach-tl-wr841n.c b/arch/mips/ar71xx/mach-tl-wr841n.c
index 1b849e1..3871b7e 100644
--- a/arch/mips/ar71xx/mach-tl-wr841n.c
+++ b/arch/mips/ar71xx/mach-tl-wr841n.c
@@ -10,6 +10,7 @@
 
 #include <linux/mtd/mtd.h>
 #include <linux/mtd/partitions.h>
+#include <linux/platform_device.h>
 
 #include <asm/mach-ar71xx/ar71xx.h>
 
@@ -28,7 +29,9 @@
 #define TL_WR841ND_V1_GPIO_BTN_RESET	3
 #define TL_WR841ND_V1_GPIO_BTN_QSS	7
 
-#define TL_WR841ND_V1_BUTTONS_POLL_INTERVAL	20
+#define TL_WR841ND_V1_KEYS_POLL_INTERVAL	20	/* msecs */
+#define TL_WR841ND_V1_KEYS_DEBOUNCE_INTERVAL \
+				(3 * TL_WR841ND_V1_KEYS_POLL_INTERVAL)
 
 #ifdef CONFIG_MTD_PARTITIONS
 static struct mtd_partition tl_wr841n_v1_partitions[] = {
@@ -37,20 +40,20 @@ static struct mtd_partition tl_wr841n_v1_partitions[] = {
 		.offset		= 0,
 		.size		= 0x020000,
 		.mask_flags	= MTD_WRITEABLE,
-	} , {
+	}, {
 		.name		= "kernel",
 		.offset		= 0x020000,
 		.size		= 0x140000,
-	} , {
+	}, {
 		.name		= "rootfs",
 		.offset		= 0x160000,
 		.size		= 0x280000,
-	} , {
+	}, {
 		.name		= "config",
 		.offset		= 0x3e0000,
 		.size		= 0x020000,
 		.mask_flags	= MTD_WRITEABLE,
-	} , {
+	}, {
 		.name		= "firmware",
 		.offset		= 0x020000,
 		.size		= 0x3c0000,
@@ -60,38 +63,38 @@ static struct mtd_partition tl_wr841n_v1_partitions[] = {
 
 static struct flash_platform_data tl_wr841n_v1_flash_data = {
 #ifdef CONFIG_MTD_PARTITIONS
-        .parts          = tl_wr841n_v1_partitions,
-        .nr_parts       = ARRAY_SIZE(tl_wr841n_v1_partitions),
+	.parts		= tl_wr841n_v1_partitions,
+	.nr_parts	= ARRAY_SIZE(tl_wr841n_v1_partitions),
 #endif
 };
 
 static struct gpio_led tl_wr841n_v1_leds_gpio[] __initdata = {
 	{
-		.name		= "tl-wr841n:green:system",
+		.name		= "tp-link:green:system",
 		.gpio		= TL_WR841ND_V1_GPIO_LED_SYSTEM,
 		.active_low	= 1,
 	}, {
-		.name		= "tl-wr841n:red:qss",
+		.name		= "tp-link:red:qss",
 		.gpio		= TL_WR841ND_V1_GPIO_LED_QSS_RED,
 	}, {
-		.name		= "tl-wr841n:green:qss",
+		.name		= "tp-link:green:qss",
 		.gpio		= TL_WR841ND_V1_GPIO_LED_QSS_GREEN,
 	}
 };
 
-static struct gpio_button tl_wr841n_v1_gpio_buttons[] __initdata = {
+static struct gpio_keys_button tl_wr841n_v1_gpio_keys[] __initdata = {
 	{
 		.desc		= "reset",
 		.type		= EV_KEY,
-		.code		= BTN_0,
-		.threshold	= 3,
+		.code		= KEY_RESTART,
+		.debounce_interval = TL_WR841ND_V1_KEYS_DEBOUNCE_INTERVAL,
 		.gpio		= TL_WR841ND_V1_GPIO_BTN_RESET,
 		.active_low	= 1,
 	}, {
 		.desc		= "qss",
 		.type		= EV_KEY,
-		.code		= BTN_1,
-		.threshold	= 3,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = TL_WR841ND_V1_KEYS_DEBOUNCE_INTERVAL,
 		.gpio		= TL_WR841ND_V1_GPIO_BTN_QSS,
 		.active_low	= 1,
 	}
@@ -115,26 +118,25 @@ static void __init tl_wr841n_v1_setup(void)
 {
 	u8 *mac = (u8 *) KSEG1ADDR(0x1f01fc00);
 
-	ar71xx_set_mac_base(mac);
-
-	ar71xx_add_device_mdio(0x0);
+	ar71xx_add_device_mdio(0, 0x0);
 
+	ar71xx_init_mac(ar71xx_eth0_data.mac_addr, mac, 0);
 	ar71xx_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
 	ar71xx_eth0_data.speed = SPEED_100;
 	ar71xx_eth0_data.duplex = DUPLEX_FULL;
 
 	ar71xx_add_device_eth(0);
-
-	ar71xx_add_device_dsa(0, &tl_wr841n_v1_dsa_data);
+	ar71xx_add_device_dsa(&ar71xx_eth0_device.dev, &ar71xx_mdio0_device.dev,
+			      &tl_wr841n_v1_dsa_data);
 
 	ar71xx_add_device_m25p80(&tl_wr841n_v1_flash_data);
 
 	ar71xx_add_device_leds_gpio(-1, ARRAY_SIZE(tl_wr841n_v1_leds_gpio),
 					tl_wr841n_v1_leds_gpio);
 
-	ar71xx_add_device_gpio_buttons(-1, TL_WR841ND_V1_BUTTONS_POLL_INTERVAL,
-					ARRAY_SIZE(tl_wr841n_v1_gpio_buttons),
-					tl_wr841n_v1_gpio_buttons);
+	ar71xx_register_gpio_keys_polled(-1, TL_WR841ND_V1_KEYS_POLL_INTERVAL,
+					 ARRAY_SIZE(tl_wr841n_v1_gpio_keys),
+					 tl_wr841n_v1_gpio_keys);
 
 	pb42_pci_init();
 }
diff --git a/arch/mips/ar71xx/mach-tl-wr941nd.c b/arch/mips/ar71xx/mach-tl-wr941nd.c
index 0c64893..f8e605d 100644
--- a/arch/mips/ar71xx/mach-tl-wr941nd.c
+++ b/arch/mips/ar71xx/mach-tl-wr941nd.c
@@ -10,6 +10,7 @@
 
 #include <linux/mtd/mtd.h>
 #include <linux/mtd/partitions.h>
+#include <linux/platform_device.h>
 
 #include <asm/mach-ar71xx/ar71xx.h>
 
@@ -17,18 +18,20 @@
 #include "devices.h"
 #include "dev-dsa.h"
 #include "dev-m25p80.h"
-#include "dev-ar913x-wmac.h"
+#include "dev-ar9xxx-wmac.h"
 #include "dev-gpio-buttons.h"
 #include "dev-leds-gpio.h"
 
 #define TL_WR941ND_GPIO_LED_SYSTEM	2
 #define TL_WR941ND_GPIO_LED_QSS_RED	4
 #define TL_WR941ND_GPIO_LED_QSS_GREEN	5
+#define TL_WR941ND_GPIO_LED_WLAN	9
 
 #define TL_WR941ND_GPIO_BTN_RESET	3
 #define TL_WR941ND_GPIO_BTN_QSS		7
 
-#define TL_WR941ND_BUTTONS_POLL_INTERVAL	20
+#define TL_WR941ND_KEYS_POLL_INTERVAL	20	/* msecs */
+#define TL_WR941ND_KEYS_DEBOUNCE_INTERVAL (3 * TL_WR941ND_KEYS_POLL_INTERVAL)
 
 #ifdef CONFIG_MTD_PARTITIONS
 static struct mtd_partition tl_wr941nd_partitions[] = {
@@ -37,20 +40,20 @@ static struct mtd_partition tl_wr941nd_partitions[] = {
 		.offset		= 0,
 		.size		= 0x020000,
 		.mask_flags	= MTD_WRITEABLE,
-	} , {
+	}, {
 		.name		= "kernel",
 		.offset		= 0x020000,
 		.size		= 0x140000,
-	} , {
+	}, {
 		.name		= "rootfs",
 		.offset		= 0x160000,
 		.size		= 0x290000,
-	} , {
+	}, {
 		.name		= "art",
 		.offset		= 0x3f0000,
 		.size		= 0x010000,
 		.mask_flags	= MTD_WRITEABLE,
-	} , {
+	}, {
 		.name		= "firmware",
 		.offset		= 0x020000,
 		.size		= 0x3d0000,
@@ -60,38 +63,42 @@ static struct mtd_partition tl_wr941nd_partitions[] = {
 
 static struct flash_platform_data tl_wr941nd_flash_data = {
 #ifdef CONFIG_MTD_PARTITIONS
-        .parts          = tl_wr941nd_partitions,
-        .nr_parts       = ARRAY_SIZE(tl_wr941nd_partitions),
+	.parts		= tl_wr941nd_partitions,
+	.nr_parts	= ARRAY_SIZE(tl_wr941nd_partitions),
 #endif
 };
 
 static struct gpio_led tl_wr941nd_leds_gpio[] __initdata = {
 	{
-		.name		= "tl-wr941nd:green:system",
+		.name		= "tp-link:green:system",
 		.gpio		= TL_WR941ND_GPIO_LED_SYSTEM,
 		.active_low	= 1,
 	}, {
-		.name		= "tl-wr941nd:red:qss",
+		.name		= "tp-link:red:qss",
 		.gpio		= TL_WR941ND_GPIO_LED_QSS_RED,
 	}, {
-		.name		= "tl-wr941nd:green:qss",
+		.name		= "tp-link:green:qss",
 		.gpio		= TL_WR941ND_GPIO_LED_QSS_GREEN,
+	}, {
+		.name		= "tp-link:green:wlan",
+		.gpio		= TL_WR941ND_GPIO_LED_WLAN,
+		.active_low	= 1,
 	}
 };
 
-static struct gpio_button tl_wr941nd_gpio_buttons[] __initdata = {
+static struct gpio_keys_button tl_wr941nd_gpio_keys[] __initdata = {
 	{
 		.desc		= "reset",
 		.type		= EV_KEY,
-		.code		= BTN_0,
-		.threshold	= 3,
+		.code		= KEY_RESTART,
+		.debounce_interval = TL_WR941ND_KEYS_DEBOUNCE_INTERVAL,
 		.gpio		= TL_WR941ND_GPIO_BTN_RESET,
 		.active_low	= 1,
 	}, {
 		.desc		= "qss",
 		.type		= EV_KEY,
-		.code		= BTN_1,
-		.threshold	= 3,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = TL_WR941ND_KEYS_DEBOUNCE_INTERVAL,
 		.gpio		= TL_WR941ND_GPIO_BTN_QSS,
 		.active_low	= 1,
 	}
@@ -116,26 +123,26 @@ static void __init tl_wr941nd_setup(void)
 	u8 *mac = (u8 *) KSEG1ADDR(0x1f01fc00);
 	u8 *eeprom = (u8 *) KSEG1ADDR(0x1fff1000);
 
-	ar71xx_set_mac_base(mac);
-
-	ar71xx_add_device_mdio(0x0);
+	ar71xx_add_device_mdio(0, 0x0);
 
+	ar71xx_init_mac(ar71xx_eth0_data.mac_addr, mac, 0);
 	ar71xx_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
 	ar71xx_eth0_data.speed = SPEED_100;
 	ar71xx_eth0_data.duplex = DUPLEX_FULL;
 
 	ar71xx_add_device_eth(0);
-	ar71xx_add_device_dsa(0, &tl_wr941nd_dsa_data);
+	ar71xx_add_device_dsa(&ar71xx_eth0_device.dev, &ar71xx_mdio0_device.dev,
+			      &tl_wr941nd_dsa_data);
 
 	ar71xx_add_device_m25p80(&tl_wr941nd_flash_data);
 
 	ar71xx_add_device_leds_gpio(-1, ARRAY_SIZE(tl_wr941nd_leds_gpio),
 					tl_wr941nd_leds_gpio);
 
-	ar71xx_add_device_gpio_buttons(-1, TL_WR941ND_BUTTONS_POLL_INTERVAL,
-					ARRAY_SIZE(tl_wr941nd_gpio_buttons),
-					tl_wr941nd_gpio_buttons);
-	ar913x_add_device_wmac(eeprom, mac);
+	ar71xx_register_gpio_keys_polled(-1, TL_WR941ND_KEYS_POLL_INTERVAL,
+					 ARRAY_SIZE(tl_wr941nd_gpio_keys),
+					 tl_wr941nd_gpio_keys);
+	ar9xxx_add_device_wmac(eeprom, mac);
 }
 
 MIPS_MACHINE(AR71XX_MACH_TL_WR941ND, "TL-WR941ND", "TP-LINK TL-WR941ND",
diff --git a/arch/mips/ar71xx/mach-ubnt.c b/arch/mips/ar71xx/mach-ubnt.c
index 04a08dc..06ce212 100644
--- a/arch/mips/ar71xx/mach-ubnt.c
+++ b/arch/mips/ar71xx/mach-ubnt.c
@@ -38,7 +38,8 @@
 #define UBNT_M_GPIO_LED_L4	7
 #define UBNT_M_GPIO_BTN_RESET	12
 
-#define UBNT_BUTTONS_POLL_INTERVAL	20
+#define UBNT_KEYS_POLL_INTERVAL		20	/* msecs */
+#define UBNT_KEYS_DEBOUNCE_INTERVAL	(3 * UBNT_KEYS_POLL_INTERVAL)
 
 static struct gpio_led ubnt_rs_leds_gpio[] __initdata = {
 	{
@@ -100,23 +101,23 @@ static struct gpio_led ubnt_m_leds_gpio[] __initdata = {
 	}
 };
 
-static struct gpio_button ubnt_gpio_buttons[] __initdata = {
+static struct gpio_keys_button ubnt_gpio_keys[] __initdata = {
 	{
 		.desc		= "sw4",
 		.type		= EV_KEY,
-		.code		= BTN_0,
-		.threshold	= 3,
+		.code		= KEY_RESTART,
+		.debounce_interval = UBNT_KEYS_DEBOUNCE_INTERVAL,
 		.gpio		= UBNT_RS_GPIO_SW4,
 		.active_low	= 1,
 	}
 };
 
-static struct gpio_button ubnt_m_gpio_buttons[] __initdata = {
+static struct gpio_keys_button ubnt_m_gpio_keys[] __initdata = {
 	{
 		.desc		= "reset",
 		.type		= EV_KEY,
-		.code		= BTN_0,
-		.threshold	= 3,
+		.code		= KEY_RESTART,
+		.debounce_interval = UBNT_KEYS_DEBOUNCE_INTERVAL,
 		.gpio		= UBNT_M_GPIO_BTN_RESET,
 		.active_low	= 1,
 	}
@@ -126,25 +127,38 @@ static void __init ubnt_generic_setup(void)
 {
 	ar71xx_add_device_m25p80(NULL);
 
-	ar71xx_add_device_gpio_buttons(-1, UBNT_BUTTONS_POLL_INTERVAL,
-					ARRAY_SIZE(ubnt_gpio_buttons),
-					ubnt_gpio_buttons);
+	ar71xx_register_gpio_keys_polled(-1, UBNT_KEYS_POLL_INTERVAL,
+					 ARRAY_SIZE(ubnt_gpio_keys),
+					 ubnt_gpio_keys);
 
 	pb42_pci_init();
 }
 
-#define UBNT_RS_WAN_PHYMASK	(1 << 20)
-#define UBNT_RS_LAN_PHYMASK	((1 << 16) | (1 << 17) | (1 << 18) | (1 << 19))
+/*
+ * There is Secondary MAC address duplicate problem with some UBNT HW batches.
+ * Do not increase Secondary MAC address by 1 but do workaround
+ * with 'Locally Administrated' bit.
+ */
+static void __init ubnt_init_secondary_mac(unsigned char *mac_base)
+{
+	ar71xx_init_mac(ar71xx_eth1_data.mac_addr, mac_base, 0);
+	ar71xx_eth1_data.mac_addr[0] |= 0x02;
+}
+
+#define UBNT_RS_WAN_PHYMASK	BIT(20)
+#define UBNT_RS_LAN_PHYMASK	(BIT(16) | BIT(17) | BIT(18) | BIT(19))
 
 static void __init ubnt_rs_setup(void)
 {
 	ubnt_generic_setup();
 
-	ar71xx_add_device_mdio(~(UBNT_RS_WAN_PHYMASK | UBNT_RS_LAN_PHYMASK));
+	ar71xx_add_device_mdio(0, ~(UBNT_RS_WAN_PHYMASK | UBNT_RS_LAN_PHYMASK));
 
+	ar71xx_init_mac(ar71xx_eth0_data.mac_addr, ar71xx_mac_base, 0);
 	ar71xx_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
 	ar71xx_eth0_data.phy_mask = UBNT_RS_WAN_PHYMASK;
 
+	ubnt_init_secondary_mac(ar71xx_mac_base);
 	ar71xx_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
 	ar71xx_eth1_data.speed = SPEED_100;
 	ar71xx_eth1_data.duplex = DUPLEX_FULL;
@@ -161,21 +175,21 @@ static void __init ubnt_rs_setup(void)
 MIPS_MACHINE(AR71XX_MACH_UBNT_RS, "UBNT-RS", "Ubiquiti RouterStation",
 	     ubnt_rs_setup);
 
-MIPS_MACHINE(AR71XX_MACH_UBNT_AR71XX, "Ubiquiti AR71xx-based board",
-	     "Ubiquiti RouterStation", ubnt_rs_setup);
-
-#define UBNT_RSPRO_WAN_PHYMASK	(1 << 4)
-#define UBNT_RSPRO_LAN_PHYMASK	((1 << 0) | (1 << 1) | (1 << 2) | (1 << 3))
+#define UBNT_RSPRO_WAN_PHYMASK	BIT(4)
+#define UBNT_RSPRO_LAN_PHYMASK	(BIT(0) | BIT(1) | BIT(2) | BIT(3))
 
 static void __init ubnt_rspro_setup(void)
 {
 	ubnt_generic_setup();
 
-	ar71xx_add_device_mdio(~(UBNT_RSPRO_WAN_PHYMASK | UBNT_RSPRO_LAN_PHYMASK));
+	ar71xx_add_device_mdio(0, ~(UBNT_RSPRO_WAN_PHYMASK |
+				 UBNT_RSPRO_LAN_PHYMASK));
 
+	ar71xx_init_mac(ar71xx_eth0_data.mac_addr, ar71xx_mac_base, 0);
 	ar71xx_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
 	ar71xx_eth0_data.phy_mask = UBNT_RSPRO_WAN_PHYMASK;
 
+	ubnt_init_secondary_mac(ar71xx_mac_base);
 	ar71xx_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
 	ar71xx_eth1_data.phy_mask = UBNT_RSPRO_LAN_PHYMASK;
 	ar71xx_eth1_data.speed = SPEED_1000;
@@ -200,14 +214,15 @@ static void __init ubnt_lsx_setup(void)
 
 MIPS_MACHINE(AR71XX_MACH_UBNT_LSX, "UBNT-LSX", "Ubiquiti LSX", ubnt_lsx_setup);
 
-#define UBNT_LSSR71_PHY_MASK	(1 << 1)
+#define UBNT_LSSR71_PHY_MASK	BIT(1)
 
 static void __init ubnt_lssr71_setup(void)
 {
 	ubnt_generic_setup();
 
-	ar71xx_add_device_mdio(~UBNT_LSSR71_PHY_MASK);
+	ar71xx_add_device_mdio(0, ~UBNT_LSSR71_PHY_MASK);
 
+	ar71xx_init_mac(ar71xx_eth0_data.mac_addr, ar71xx_mac_base, 0);
 	ar71xx_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
 	ar71xx_eth0_data.phy_mask = UBNT_LSSR71_PHY_MASK;
 
@@ -220,24 +235,20 @@ static void __init ubnt_lssr71_setup(void)
 MIPS_MACHINE(AR71XX_MACH_UBNT_LSSR71, "UBNT-LS-SR71", "Ubiquiti LS-SR71",
 	     ubnt_lssr71_setup);
 
+#define UBNT_M_WAN_PHYMASK	BIT(4)
+
 static void __init ubnt_m_setup(void)
 {
-	u8 *mac = (u8 *) KSEG1ADDR(0x1fff0000);
+	u8 *mac1 = (u8 *) KSEG1ADDR(0x1fff0000);
+	u8 *mac2 = (u8 *) KSEG1ADDR(0x1fff0000 + ETH_ALEN);
 	u8 *ee = (u8 *) KSEG1ADDR(0x1fff1000);
 
-	ar71xx_set_mac_base(mac);
-
 	ar71xx_add_device_m25p80(NULL);
 
-	ar71xx_add_device_mdio(~0);
-
-	ar71xx_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
-	ar71xx_eth0_data.speed = SPEED_100;
-	ar71xx_eth0_data.duplex = DUPLEX_FULL;
-	ar71xx_eth0_data.fifo_cfg1 = 0x0010ffff;
-	ar71xx_eth0_data.fifo_cfg2 = 0x015500aa;
-	ar71xx_eth0_data.fifo_cfg3 = 0x01f00140;
+	ar71xx_add_device_mdio(0, ~UBNT_M_WAN_PHYMASK);
 
+	ar71xx_init_mac(ar71xx_eth0_data.mac_addr, mac1, 0);
+	ar71xx_init_mac(ar71xx_eth1_data.mac_addr, mac2, 0);
 	ar71xx_add_device_eth(0);
 
 	ap91_pci_init(ee, NULL);
@@ -245,9 +256,9 @@ static void __init ubnt_m_setup(void)
 	ar71xx_add_device_leds_gpio(-1, ARRAY_SIZE(ubnt_m_leds_gpio),
 					ubnt_m_leds_gpio);
 
-	ar71xx_add_device_gpio_buttons(-1, UBNT_BUTTONS_POLL_INTERVAL,
-					ARRAY_SIZE(ubnt_m_gpio_buttons),
-					ubnt_m_gpio_buttons);
+	ar71xx_register_gpio_keys_polled(-1, UBNT_KEYS_POLL_INTERVAL,
+					 ARRAY_SIZE(ubnt_m_gpio_keys),
+					 ubnt_m_gpio_keys);
 }
 
 static void __init ubnt_rocket_m_setup(void)
@@ -266,16 +277,41 @@ MIPS_MACHINE(AR71XX_MACH_UBNT_ROCKET_M, "UBNT-RM", "Ubiquiti Rocket M",
 static void __init ubnt_nano_m_setup(void)
 {
 	ubnt_m_setup();
-
-	ar71xx_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
-	ar71xx_eth1_data.speed = SPEED_1000;
-	ar71xx_eth1_data.duplex = DUPLEX_FULL;
-	ar71xx_eth1_data.fifo_cfg1 = 0x0010ffff;
-	ar71xx_eth1_data.fifo_cfg2 = 0x015500aa;
-	ar71xx_eth1_data.fifo_cfg3 = 0x01f00140;
-
 	ar71xx_add_device_eth(1);
 }
 
 MIPS_MACHINE(AR71XX_MACH_UBNT_NANO_M, "UBNT-NM", "Ubiquiti Nanostation M",
 	     ubnt_nano_m_setup);
+
+static struct gpio_led ubnt_unifi_leds_gpio[] __initdata = {
+	{
+		.name		= "ubnt:orange:dome",
+		.gpio		= 1,
+		.active_low	= 0,
+	}, {
+		.name		= "ubnt:green:dome",
+		.gpio		= 0,
+		.active_low	= 0,
+	}
+};
+
+static void __init ubnt_unifi_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1fff0000);
+	u8 *ee = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	ar71xx_add_device_m25p80(NULL);
+
+	ar71xx_add_device_mdio(0, ~UBNT_M_WAN_PHYMASK);
+
+	ar71xx_init_mac(ar71xx_eth0_data.mac_addr, mac, 0);
+	ar71xx_add_device_eth(0);
+
+	ap91_pci_init(ee, NULL);
+
+	ar71xx_add_device_leds_gpio(-1, ARRAY_SIZE(ubnt_unifi_leds_gpio),
+					ubnt_unifi_leds_gpio);
+}
+
+MIPS_MACHINE(AR71XX_MACH_UBNT_UNIFI, "UBNT-XM", "Ubiquiti UniFi",
+	     ubnt_unifi_setup);
diff --git a/arch/mips/ar71xx/mach-whr-hp-g300n.c b/arch/mips/ar71xx/mach-whr-hp-g300n.c
new file mode 100644
index 0000000..ccc3650
--- /dev/null
+++ b/arch/mips/ar71xx/mach-whr-hp-g300n.c
@@ -0,0 +1,169 @@
+/*
+ *  Buffalo WHR-HP-G300N board support
+ *
+ *  based on ...
+ *
+ *  TP-LINK TL-WR741ND board support
+ *
+ *  Copyright (C) 2009-2010 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/mach-ar71xx/ar71xx.h>
+
+#include "machtype.h"
+#include "devices.h"
+#include "dev-m25p80.h"
+#include "dev-ap91-pci.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+
+#define	WHRHPG300N_GPIO_LED_SECURITY		0
+#define	WHRHPG300N_GPIO_LED_DIAG		1
+#define	WHRHPG300N_GPIO_LED_ROUTER		6
+
+#define	WHRHPG300N_GPIO_BTN_ROUTER_ON		7
+#define	WHRHPG300N_GPIO_BTN_ROUTER_AUTO		8
+#define	WHRHPG300N_GPIO_BTN_RESET		11
+#define	WHRHPG300N_GPIO_BTN_AOSS		12
+
+#define	WHRHPG300N_KEYS_POLL_INTERVAL	20	/* msecs */
+#define WHRHPG300N_KEYS_DEBOUNCE_INTERVAL (3 * WHRHPG300N_KEYS_POLL_INTERVAL)
+
+#define WHRHPG300N_MAC_OFFSET		0x20c
+
+#ifdef CONFIG_MTD_PARTITIONS
+static struct mtd_partition whrhpg300n_partitions[] = {
+	{
+		.name		= "u-boot",
+		.offset		= 0,
+		.size		= 0x03e000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "u-boot-env",
+		.offset		= 0x03e000,
+		.size		= 0x002000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "kernel",
+		.offset		= 0x040000,
+		.size		= 0x0e0000,
+	}, {
+		.name		= "rootfs",
+		.offset		= 0x120000,
+		.size		= 0x2c0000,
+	}, {
+		.name		= "user_property",
+		.offset		= 0x3e0000,
+		.size		= 0x010000,
+	}, {
+		.name		= "ART",
+		.offset		= 0x3f0000,
+		.size		= 0x010000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "firmware",
+		.offset		= 0x040000,
+		.size		= 0x3a0000,
+	}
+};
+#endif /* CONFIG_MTD_PARTITIONS */
+
+static struct flash_platform_data whrhpg300n_flash_data = {
+#ifdef CONFIG_MTD_PARTITIONS
+	.parts		= whrhpg300n_partitions,
+	.nr_parts	= ARRAY_SIZE(whrhpg300n_partitions),
+#endif
+};
+
+static struct gpio_led whrhpg300n_leds_gpio[] __initdata = {
+	{
+		.name		= "buffalo:orange:security",
+		.gpio		= WHRHPG300N_GPIO_LED_SECURITY,
+		.active_low	= 1,
+	}, {
+		.name		= "buffalo:red:diag",
+		.gpio		= WHRHPG300N_GPIO_LED_DIAG,
+		.active_low	= 1,
+	}, {
+		.name		= "buffalo:green:router",
+		.gpio		= WHRHPG300N_GPIO_LED_ROUTER,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button whrhpg300n_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = WHRHPG300N_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= WHRHPG300N_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}, {
+		.desc		= "aoss/wps",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.gpio		= WHRHPG300N_GPIO_BTN_AOSS,
+		.debounce_interval = WHRHPG300N_KEYS_DEBOUNCE_INTERVAL,
+		.active_low	= 1,
+	}, {
+		.desc		= "router_on",
+		.type		= EV_KEY,
+		.code		= BTN_2,
+		.gpio		= WHRHPG300N_GPIO_BTN_ROUTER_ON,
+		.debounce_interval = WHRHPG300N_KEYS_DEBOUNCE_INTERVAL,
+		.active_low	= 1,
+	}, {
+		.desc		= "router_auto",
+		.type		= EV_KEY,
+		.code		= BTN_3,
+		.gpio		= WHRHPG300N_GPIO_BTN_ROUTER_AUTO,
+		.debounce_interval = WHRHPG300N_KEYS_DEBOUNCE_INTERVAL,
+		.active_low	= 1,
+	}
+};
+
+static void __init whrhpg300n_setup(void)
+{
+	u8 *ee = (u8 *) KSEG1ADDR(0x1fff1000);
+	u8 *mac = (u8 *) KSEG1ADDR(ee + WHRHPG300N_MAC_OFFSET);
+
+	ar71xx_add_device_m25p80(&whrhpg300n_flash_data);
+
+	ar71xx_add_device_leds_gpio(-1, ARRAY_SIZE(whrhpg300n_leds_gpio),
+					whrhpg300n_leds_gpio);
+
+	ar71xx_register_gpio_keys_polled(-1, WHRHPG300N_KEYS_POLL_INTERVAL,
+					 ARRAY_SIZE(whrhpg300n_gpio_keys),
+					 whrhpg300n_gpio_keys);
+
+	ar71xx_init_mac(ar71xx_eth0_data.mac_addr, mac, 0);
+	ar71xx_init_mac(ar71xx_eth1_data.mac_addr, mac, 1);
+
+	ar71xx_add_device_mdio(0, 0x0);
+
+	/* LAN ports */
+	ar71xx_add_device_eth(1);
+	/* WAN port */
+	ar71xx_add_device_eth(0);
+
+	ap91_pci_setup_wmac_led_pin(1);
+
+	ap91_pci_init(ee, mac);
+}
+
+MIPS_MACHINE(AR71XX_MACH_WHR_HP_G300N, "WHR-HP-G300N", "Buffalo WHR-HP-G300N",
+	     whrhpg300n_setup);
+
+MIPS_MACHINE(AR71XX_MACH_WHR_G301N, "WHR-G301N", "Buffalo WHR-G301N",
+	     whrhpg300n_setup);
+
+MIPS_MACHINE(AR71XX_MACH_WHR_HP_GN, "WHR-HP-GN", "Buffalo WHR-HP-GN",
+	     whrhpg300n_setup);
diff --git a/arch/mips/ar71xx/mach-wndr3700.c b/arch/mips/ar71xx/mach-wndr3700.c
index 62931e6..0df9c7f 100644
--- a/arch/mips/ar71xx/mach-wndr3700.c
+++ b/arch/mips/ar71xx/mach-wndr3700.c
@@ -13,7 +13,7 @@
 #include <linux/mtd/mtd.h>
 #include <linux/mtd/partitions.h>
 #include <linux/delay.h>
-#include <linux/rtl8366s.h>
+#include <linux/rtl8366.h>
 
 #include <asm/mach-ar71xx/ar71xx.h>
 
@@ -38,7 +38,11 @@
 #define WNDR3700_GPIO_RTL8366_SDA	5
 #define WNDR3700_GPIO_RTL8366_SCK	7
 
-#define WNDR3700_BUTTONS_POLL_INTERVAL    20
+#define WNDR3700_KEYS_POLL_INTERVAL	20	/* msecs */
+#define WNDR3700_KEYS_DEBOUNCE_INTERVAL (3 * WNDR3700_KEYS_POLL_INTERVAL)
+
+#define WNDR3700_ETH0_MAC_OFFSET	0
+#define WNDR3700_ETH1_MAC_OFFSET	0x6
 
 #define WNDR3700_WMAC0_MAC_OFFSET	0
 #define WNDR3700_WMAC1_MAC_OFFSET	0xc
@@ -52,55 +56,105 @@ static struct mtd_partition wndr3700_partitions[] = {
 		.offset		= 0,
 		.size		= 0x050000,
 		.mask_flags	= MTD_WRITEABLE,
-	} , {
+	}, {
 		.name		= "env",
 		.offset		= 0x050000,
 		.size		= 0x020000,
 		.mask_flags	= MTD_WRITEABLE,
-	} , {
+	}, {
 		.name		= "rootfs",
 		.offset		= 0x070000,
 		.size		= 0x720000,
-	} , {
+	}, {
 		.name		= "config",
 		.offset		= 0x790000,
 		.size		= 0x010000,
 		.mask_flags	= MTD_WRITEABLE,
-	} , {
+	}, {
 		.name		= "config_bak",
 		.offset		= 0x7a0000,
 		.size		= 0x010000,
 		.mask_flags	= MTD_WRITEABLE,
-	} , {
+	}, {
 		.name		= "pot",
 		.offset		= 0x7b0000,
 		.size		= 0x010000,
 		.mask_flags	= MTD_WRITEABLE,
-	} , {
+	}, {
 		.name		= "traffic_meter",
 		.offset		= 0x7c0000,
 		.size		= 0x010000,
 		.mask_flags	= MTD_WRITEABLE,
-	} , {
+	}, {
 		.name		= "language",
 		.offset		= 0x7d0000,
 		.size		= 0x020000,
 		.mask_flags	= MTD_WRITEABLE,
-	} , {
+	}, {
 		.name		= "caldata",
 		.offset		= 0x7f0000,
 		.size		= 0x010000,
 		.mask_flags	= MTD_WRITEABLE,
 	}
 };
-#endif /* CONFIG_MTD_PARTITIONS */
 
-static struct flash_platform_data wndr3700_flash_data = {
-#ifdef CONFIG_MTD_PARTITIONS
-        .parts          = wndr3700_partitions,
-        .nr_parts       = ARRAY_SIZE(wndr3700_partitions),
-#endif
+static struct mtd_partition wndr3700v2_partitions[] = {
+	{
+		.name		= "uboot",
+		.offset		= 0,
+		.size		= 0x050000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "env",
+		.offset		= 0x050000,
+		.size		= 0x020000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "rootfs",
+		.offset		= 0x070000,
+		.size		= 0xe40000,
+	}, {
+		.name		= "config",
+		.offset		= 0xeb0000,
+		.size		= 0x010000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "config_bak",
+		.offset		= 0xec0000,
+		.size		= 0x010000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "pot",
+		.offset		= 0xed0000,
+		.size		= 0x010000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "traffic_meter",
+		.offset		= 0xee0000,
+		.size		= 0x010000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "language",
+		.offset		= 0xef0000,
+		.size		= 0x100000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "caldata",
+		.offset		= 0xff0000,
+		.size		= 0x010000,
+		.mask_flags	= MTD_WRITEABLE,
+	}
 };
+#define wndr3700_num_partitions		ARRAY_SIZE(wndr3700_partitions)
+#define wndr3700v2_num_partitions	ARRAY_SIZE(wndr3700v2_partitions)
+#else
+#define wndr3700_partitions		NULL
+#define wndr3700_num_partitions		0
+#define wndr3700v2_partitions		NULL
+#define wndr3700v2_num_partitions	0
+#endif /* CONFIG_MTD_PARTITIONS */
+
+static struct flash_platform_data wndr3700_flash_data;
 
 static struct gpio_led wndr3700_leds_gpio[] __initdata = {
 	{
@@ -126,34 +180,34 @@ static struct gpio_led wndr3700_leds_gpio[] __initdata = {
 	}
 };
 
-static struct gpio_button wndr3700_gpio_buttons[] __initdata = {
+static struct gpio_keys_button wndr3700_gpio_keys[] __initdata = {
 	{
 		.desc		= "reset",
 		.type		= EV_KEY,
-		.code		= BTN_0,
-		.threshold	= 3,
+		.code		= KEY_RESTART,
+		.debounce_interval = WNDR3700_KEYS_DEBOUNCE_INTERVAL,
 		.gpio		= WNDR3700_GPIO_BTN_RESET,
 		.active_low	= 1,
 	}, {
 		.desc		= "wps",
 		.type		= EV_KEY,
-		.code		= BTN_1,
-		.threshold	= 3,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = WNDR3700_KEYS_DEBOUNCE_INTERVAL,
 		.gpio		= WNDR3700_GPIO_BTN_WPS,
 		.active_low	= 1,
-	} , {
+	}, {
 		.desc		= "wifi",
 		.type		= EV_KEY,
 		.code		= BTN_2,
-		.threshold	= 3,
+		.debounce_interval = WNDR3700_KEYS_DEBOUNCE_INTERVAL,
 		.gpio		= WNDR3700_GPIO_BTN_WIFI,
 		.active_low	= 1,
 	}
 };
 
-static struct rtl8366s_platform_data wndr3700_rtl8366s_data = {
-	.gpio_sda        = WNDR3700_GPIO_RTL8366_SDA,
-	.gpio_sck        = WNDR3700_GPIO_RTL8366_SCK,
+static struct rtl8366_platform_data wndr3700_rtl8366s_data = {
+	.gpio_sda	= WNDR3700_GPIO_RTL8366_SDA,
+	.gpio_sck	= WNDR3700_GPIO_RTL8366_SCK,
 };
 
 static struct platform_device wndr3700_rtl8366s_device = {
@@ -164,18 +218,20 @@ static struct platform_device wndr3700_rtl8366s_device = {
 	}
 };
 
-static void __init wndr3700_setup(void)
+static void __init wndr3700_common_setup(void)
 {
 	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
 
-	ar71xx_set_mac_base(art);
-
+	ar71xx_init_mac(ar71xx_eth0_data.mac_addr,
+			art + WNDR3700_ETH0_MAC_OFFSET, 0);
 	ar71xx_eth0_pll_data.pll_1000 = 0x11110000;
 	ar71xx_eth0_data.mii_bus_dev = &wndr3700_rtl8366s_device.dev;
 	ar71xx_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
 	ar71xx_eth0_data.speed = SPEED_1000;
 	ar71xx_eth0_data.duplex = DUPLEX_FULL;
 
+	ar71xx_init_mac(ar71xx_eth1_data.mac_addr,
+			art + WNDR3700_ETH1_MAC_OFFSET, 0);
 	ar71xx_eth1_pll_data.pll_1000 = 0x11110000;
 	ar71xx_eth1_data.mii_bus_dev = &wndr3700_rtl8366s_device.dev;
 	ar71xx_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
@@ -188,22 +244,47 @@ static void __init wndr3700_setup(void)
 
 	ar71xx_add_device_m25p80(&wndr3700_flash_data);
 
-        ar71xx_add_device_leds_gpio(-1, ARRAY_SIZE(wndr3700_leds_gpio),
-				    wndr3700_leds_gpio);
+	ar71xx_add_device_leds_gpio(-1, ARRAY_SIZE(wndr3700_leds_gpio),
+					wndr3700_leds_gpio);
 
-	ar71xx_add_device_gpio_buttons(-1, WNDR3700_BUTTONS_POLL_INTERVAL,
-				      ARRAY_SIZE(wndr3700_gpio_buttons),
-				      wndr3700_gpio_buttons);
+	ar71xx_register_gpio_keys_polled(-1, WNDR3700_KEYS_POLL_INTERVAL,
+					 ARRAY_SIZE(wndr3700_gpio_keys),
+					 wndr3700_gpio_keys);
 
 	platform_device_register(&wndr3700_rtl8366s_device);
 	platform_device_register_simple("wndr3700-led-usb", -1, NULL, 0);
 
-	ap94_pci_enable_quirk_wndr3700();
+	ap94_pci_setup_wmac_led_pin(0, 5);
+	ap94_pci_setup_wmac_led_pin(1, 5);
+
+	/* 2.4 GHz uses the first fixed antenna group (1, 0, 1, 0) */
+	ap94_pci_setup_wmac_gpio(0, (0xf << 6), (0xa << 6));
+
+	/* 5 GHz uses the second fixed antenna group (0, 1, 1, 0) */
+	ap94_pci_setup_wmac_gpio(1, (0xf << 6), (0x6 << 6));
+
 	ap94_pci_init(art + WNDR3700_CALDATA0_OFFSET,
 		      art + WNDR3700_WMAC0_MAC_OFFSET,
 		      art + WNDR3700_CALDATA1_OFFSET,
 		      art + WNDR3700_WMAC1_MAC_OFFSET);
 }
 
+static void __init wndr3700_setup(void)
+{
+	wndr3700_flash_data.parts = wndr3700_partitions,
+	wndr3700_flash_data.nr_parts = wndr3700_num_partitions,
+	wndr3700_common_setup();
+}
+
 MIPS_MACHINE(AR71XX_MACH_WNDR3700, "WNDR3700", "NETGEAR WNDR3700",
 	     wndr3700_setup);
+
+static void __init wndr3700v2_setup(void)
+{
+	wndr3700_flash_data.parts = wndr3700v2_partitions,
+	wndr3700_flash_data.nr_parts = wndr3700v2_num_partitions,
+	wndr3700_common_setup();
+}
+
+MIPS_MACHINE(AR71XX_MACH_WNDR3700V2, "WNDR3700v2", "NETGEAR WNDR3700v2",
+	     wndr3700v2_setup);
diff --git a/arch/mips/ar71xx/mach-wnr2000.c b/arch/mips/ar71xx/mach-wnr2000.c
index 73422d6..37477eb 100644
--- a/arch/mips/ar71xx/mach-wnr2000.c
+++ b/arch/mips/ar71xx/mach-wnr2000.c
@@ -18,7 +18,7 @@
 #include "machtype.h"
 #include "devices.h"
 #include "dev-m25p80.h"
-#include "dev-ar913x-wmac.h"
+#include "dev-ar9xxx-wmac.h"
 #include "dev-gpio-buttons.h"
 #include "dev-leds-gpio.h"
 
@@ -29,7 +29,8 @@
 #define WNR2000_GPIO_BTN_RESET		21
 #define WNR2000_GPIO_BTN_WPS		8
 
-#define WNR2000_BUTTONS_POLL_INTERVAL	20
+#define WNR2000_KEYS_POLL_INTERVAL	20	/* msecs */
+#define WNR2000_KEYS_DEBOUNCE_INTERVAL	(3 * WNR2000_KEYS_POLL_INTERVAL)
 
 #ifdef CONFIG_MTD_PARTITIONS
 static struct mtd_partition wnr2000_partitions[] = {
@@ -38,31 +39,31 @@ static struct mtd_partition wnr2000_partitions[] = {
 		.offset		= 0,
 		.size		= 0x040000,
 		.mask_flags	= MTD_WRITEABLE,
-	} , {
+	}, {
 		.name		= "u-boot-env",
 		.offset		= 0x040000,
 		.size		= 0x010000,
-	} , {
+	}, {
 		.name		= "rootfs",
 		.offset		= 0x050000,
 		.size		= 0x240000,
-	} , {
+	}, {
 		.name		= "user-config",
 		.offset		= 0x290000,
 		.size		= 0x010000,
-	} , {
+	}, {
 		.name		= "uImage",
 		.offset		= 0x2a0000,
 		.size		= 0x120000,
-	} , {
+	}, {
 		.name		= "language_table",
 		.offset		= 0x3c0000,
 		.size		= 0x020000,
-	} , {
+	}, {
 		.name		= "rootfs_checksum",
 		.offset		= 0x3e0000,
 		.size		= 0x010000,
-	} , {
+	}, {
 		.name		= "art",
 		.offset		= 0x3f0000,
 		.size		= 0x010000,
@@ -73,8 +74,8 @@ static struct mtd_partition wnr2000_partitions[] = {
 
 static struct flash_platform_data wnr2000_flash_data = {
 #ifdef CONFIG_MTD_PARTITIONS
-        .parts          = wnr2000_partitions,
-        .nr_parts       = ARRAY_SIZE(wnr2000_partitions),
+	.parts		= wnr2000_partitions,
+	.nr_parts	= ARRAY_SIZE(wnr2000_partitions),
 #endif
 };
 
@@ -98,18 +99,18 @@ static struct gpio_led wnr2000_leds_gpio[] __initdata = {
 	}
 };
 
-static struct gpio_button wnr2000_gpio_buttons[] __initdata = {
+static struct gpio_keys_button wnr2000_gpio_keys[] __initdata = {
 	{
 		.desc		= "reset",
 		.type		= EV_KEY,
-		.code		= BTN_0,
-		.threshold	= 3,
+		.code		= KEY_RESTART,
+		.debounce_interval = WNR2000_KEYS_DEBOUNCE_INTERVAL,
 		.gpio		= WNR2000_GPIO_BTN_RESET,
 	}, {
 		.desc		= "wps",
 		.type		= EV_KEY,
-		.code		= BTN_1,
-		.threshold	= 3,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = WNR2000_KEYS_DEBOUNCE_INTERVAL,
 		.gpio		= WNR2000_GPIO_BTN_WPS,
 	}
 };
@@ -118,14 +119,15 @@ static void __init wnr2000_setup(void)
 {
 	u8 *eeprom = (u8 *) KSEG1ADDR(0x1fff1000);
 
-	ar71xx_set_mac_base(eeprom);
-	ar71xx_add_device_mdio(0x0);
+	ar71xx_add_device_mdio(0, 0x0);
 
+	ar71xx_init_mac(ar71xx_eth0_data.mac_addr, eeprom, 0);
 	ar71xx_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
 	ar71xx_eth0_data.speed = SPEED_100;
 	ar71xx_eth0_data.duplex = DUPLEX_FULL;
 	ar71xx_eth0_data.has_ar8216 = 1;
 
+	ar71xx_init_mac(ar71xx_eth1_data.mac_addr, eeprom, 1);
 	ar71xx_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
 	ar71xx_eth1_data.phy_mask = 0x10;
 
@@ -137,12 +139,12 @@ static void __init wnr2000_setup(void)
 	ar71xx_add_device_leds_gpio(-1, ARRAY_SIZE(wnr2000_leds_gpio),
 					wnr2000_leds_gpio);
 
-	ar71xx_add_device_gpio_buttons(-1, WNR2000_BUTTONS_POLL_INTERVAL,
-					ARRAY_SIZE(wnr2000_gpio_buttons),
-					wnr2000_gpio_buttons);
+	ar71xx_register_gpio_keys_polled(-1, WNR2000_KEYS_POLL_INTERVAL,
+					 ARRAY_SIZE(wnr2000_gpio_keys),
+					 wnr2000_gpio_keys);
 
 
-	ar913x_add_device_wmac(eeprom, NULL);
+	ar9xxx_add_device_wmac(eeprom, NULL);
 }
 
 MIPS_MACHINE(AR71XX_MACH_WNR2000, "WNR2000", "NETGEAR WNR2000", wnr2000_setup);
diff --git a/arch/mips/ar71xx/mach-wp543.c b/arch/mips/ar71xx/mach-wp543.c
index 2258584..6a6ec1c 100644
--- a/arch/mips/ar71xx/mach-wp543.c
+++ b/arch/mips/ar71xx/mach-wp543.c
@@ -30,7 +30,8 @@
 #define WP543_GPIO_LED_DIAG	7
 #define WP543_GPIO_SW4		8
 
-#define WP543_BUTTONS_POLL_INTERVAL	20
+#define WP543_KEYS_POLL_INTERVAL	20	/* msecs */
+#define WP543_KEYS_DEBOUNCE_INTERVAL	(3 * WP543_KEYS_POLL_INTERVAL)
 
 static struct gpio_led wp543_leds_gpio[] __initdata = {
 	{
@@ -56,18 +57,18 @@ static struct gpio_led wp543_leds_gpio[] __initdata = {
 	}
 };
 
-static struct gpio_button wp543_gpio_buttons[] __initdata = {
+static struct gpio_keys_button wp543_gpio_keys[] __initdata = {
 	{
 		.desc		= "sw6",
 		.type		= EV_KEY,
 		.code		= BTN_0,
-		.threshold	= 3,
+		.debounce_interval = WP543_KEYS_DEBOUNCE_INTERVAL,
 		.gpio		= WP543_GPIO_SW6,
 	}, {
 		.desc		= "sw4",
 		.type		= EV_KEY,
 		.code		= BTN_1,
-		.threshold	= 3,
+		.debounce_interval = WP543_KEYS_DEBOUNCE_INTERVAL,
 		.gpio		= WP543_GPIO_SW4,
 	}
 };
@@ -76,8 +77,9 @@ static void __init wp543_setup(void)
 {
 	ar71xx_add_device_m25p80(NULL);
 
-	ar71xx_add_device_mdio(0xfffffff7);
+	ar71xx_add_device_mdio(0, 0xfffffff7);
 
+	ar71xx_init_mac(ar71xx_eth0_data.mac_addr, ar71xx_mac_base, 0);
 	ar71xx_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
 	ar71xx_eth0_data.phy_mask = 0x08;
 	ar71xx_eth0_data.reset_bit = RESET_MODULE_GE0_MAC |
@@ -91,9 +93,9 @@ static void __init wp543_setup(void)
 	ar71xx_add_device_leds_gpio(-1, ARRAY_SIZE(wp543_leds_gpio),
 					wp543_leds_gpio);
 
-	ar71xx_add_device_gpio_buttons(-1, WP543_BUTTONS_POLL_INTERVAL,
-					ARRAY_SIZE(wp543_gpio_buttons),
-					wp543_gpio_buttons);
+	ar71xx_register_gpio_keys_polled(-1, WP543_KEYS_POLL_INTERVAL,
+					 ARRAY_SIZE(wp543_gpio_keys),
+					 wp543_gpio_keys);
 }
 
 MIPS_MACHINE(AR71XX_MACH_WP543, "WP543", "Compex WP543", wp543_setup);
diff --git a/arch/mips/ar71xx/mach-wrt160nl.c b/arch/mips/ar71xx/mach-wrt160nl.c
index 7fb97d9..674550e 100644
--- a/arch/mips/ar71xx/mach-wrt160nl.c
+++ b/arch/mips/ar71xx/mach-wrt160nl.c
@@ -16,7 +16,7 @@
 #include "machtype.h"
 #include "devices.h"
 #include "dev-m25p80.h"
-#include "dev-ar913x-wmac.h"
+#include "dev-ar9xxx-wmac.h"
 #include "dev-gpio-buttons.h"
 #include "dev-leds-gpio.h"
 #include "dev-usb.h"
@@ -30,7 +30,8 @@
 #define WRT160NL_GPIO_BTN_WPS		7
 #define WRT160NL_GPIO_BTN_RESET		21
 
-#define WRT160NL_BUTTONS_POLL_INTERVAL	20
+#define WRT160NL_KEYS_POLL_INTERVAL	20	/* msecs */
+#define WRT160NL_KEYS_DEBOUNCE_INTERVAL	(3 * WRT160NL_KEYS_POLL_INTERVAL)
 
 #define WRT160NL_NVRAM_ADDR	0x1f7e0000
 #define WRT160NL_NVRAM_SIZE	0x10000
@@ -42,25 +43,25 @@ static struct mtd_partition wrt160nl_partitions[] = {
 		.offset		= 0,
 		.size		= 0x040000,
 		.mask_flags	= MTD_WRITEABLE,
-	} , {
+	}, {
 		.name		= "kernel",
 		.offset		= 0x040000,
 		.size		= 0x0e0000,
-	} , {
+	}, {
 		.name		= "filesytem",
 		.offset		= 0x120000,
 		.size		= 0x6c0000,
-	} , {
+	}, {
 		.name		= "nvram",
 		.offset		= 0x7e0000,
 		.size		= 0x010000,
 		.mask_flags	= MTD_WRITEABLE,
-	} , {
+	}, {
 		.name		= "ART",
 		.offset		= 0x7f0000,
 		.size		= 0x010000,
 		.mask_flags	= MTD_WRITEABLE,
-	} , {
+	}, {
 		.name		= "firmware",
 		.offset		= 0x040000,
 		.size		= 0x7a0000,
@@ -70,8 +71,8 @@ static struct mtd_partition wrt160nl_partitions[] = {
 
 static struct flash_platform_data wrt160nl_flash_data = {
 #ifdef CONFIG_MTD_PARTITIONS
-        .parts          = wrt160nl_partitions,
-        .nr_parts       = ARRAY_SIZE(wrt160nl_partitions),
+	.parts		= wrt160nl_partitions,
+	.nr_parts	= ARRAY_SIZE(wrt160nl_partitions),
 #endif
 };
 
@@ -96,19 +97,19 @@ static struct gpio_led wrt160nl_leds_gpio[] __initdata = {
 	}
 };
 
-static struct gpio_button wrt160nl_gpio_buttons[] __initdata = {
+static struct gpio_keys_button wrt160nl_gpio_keys[] __initdata = {
 	{
 		.desc		= "reset",
 		.type		= EV_KEY,
-		.code		= BTN_0,
-		.threshold	= 3,
+		.code		= KEY_RESTART,
+		.debounce_interval = WRT160NL_KEYS_DEBOUNCE_INTERVAL,
 		.gpio		= WRT160NL_GPIO_BTN_RESET,
 		.active_low	= 1,
 	}, {
 		.desc		= "wps",
 		.type		= EV_KEY,
-		.code		= BTN_1,
-		.threshold	= 3,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = WRT160NL_KEYS_DEBOUNCE_INTERVAL,
 		.gpio		= WRT160NL_GPIO_BTN_WPS,
 		.active_low	= 1,
 	}
@@ -121,10 +122,12 @@ static void __init wrt160nl_setup(void)
 	u8 mac[6];
 
 	if (nvram_parse_mac_addr(nvram, WRT160NL_NVRAM_SIZE,
-			         "lan_hwaddr=", mac) == 0)
-		ar71xx_set_mac_base(mac);
+				 "lan_hwaddr=", mac) == 0) {
+		ar71xx_init_mac(ar71xx_eth0_data.mac_addr, mac, 0);
+		ar71xx_init_mac(ar71xx_eth1_data.mac_addr, mac, 1);
+	}
 
-	ar71xx_add_device_mdio(0x0);
+	ar71xx_add_device_mdio(0, 0x0);
 
 	ar71xx_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
 	ar71xx_eth0_data.phy_mask = 0x01;
@@ -140,17 +143,17 @@ static void __init wrt160nl_setup(void)
 	ar71xx_add_device_usb();
 
 	if (nvram_parse_mac_addr(nvram, WRT160NL_NVRAM_SIZE,
-			         "wl0_hwaddr=", mac) == 0)
-		ar913x_add_device_wmac(eeprom, mac);
+				 "wl0_hwaddr=", mac) == 0)
+		ar9xxx_add_device_wmac(eeprom, mac);
 	else
-		ar913x_add_device_wmac(eeprom, NULL);
+		ar9xxx_add_device_wmac(eeprom, NULL);
 
 	ar71xx_add_device_leds_gpio(-1, ARRAY_SIZE(wrt160nl_leds_gpio),
 					wrt160nl_leds_gpio);
 
-	ar71xx_add_device_gpio_buttons(-1, WRT160NL_BUTTONS_POLL_INTERVAL,
-					ARRAY_SIZE(wrt160nl_gpio_buttons),
-					wrt160nl_gpio_buttons);
+	ar71xx_register_gpio_keys_polled(-1, WRT160NL_KEYS_POLL_INTERVAL,
+					 ARRAY_SIZE(wrt160nl_gpio_keys),
+					 wrt160nl_gpio_keys);
 
 }
 
diff --git a/arch/mips/ar71xx/mach-wrt400n.c b/arch/mips/ar71xx/mach-wrt400n.c
index 5ed0b60..8bd82b9 100644
--- a/arch/mips/ar71xx/mach-wrt400n.c
+++ b/arch/mips/ar71xx/mach-wrt400n.c
@@ -29,7 +29,8 @@
 #define WRT400N_GPIO_BTN_RESET	8
 #define WRT400N_GPIO_BTN_WLSEC	3
 
-#define WRT400N_BUTTONS_POLL_INTERVAL	20
+#define WRT400N_KEYS_POLL_INTERVAL	20	/* msecs */
+#define WRT400N_KEYS_DEBOUNE_INTERVAL	(3 * WRT400N_KEYS_POLL_INTERVAL)
 
 #define WRT400N_MAC_ADDR_OFFSET		0x120c
 #define WRT400N_CALDATA0_OFFSET		0x1000
@@ -42,40 +43,40 @@ static struct mtd_partition wrt400n_partitions[] = {
 		.offset		= 0,
 		.size		= 0x030000,
 		.mask_flags	= MTD_WRITEABLE,
-	} , {
+	}, {
 		.name		= "env",
 		.offset		= 0x030000,
 		.size		= 0x010000,
 		.mask_flags	= MTD_WRITEABLE,
-	} , {
+	}, {
 		.name		= "linux",
 		.offset		= 0x040000,
 		.size		= 0x140000,
-	} , {
+	}, {
 		.name		= "rootfs",
 		.offset		= 0x180000,
 		.size		= 0x630000,
-	} , {
+	}, {
 		.name		= "nvram",
 		.offset		= 0x7b0000,
 		.size		= 0x010000,
 		.mask_flags	= MTD_WRITEABLE,
-	} , {
+	}, {
 		.name		= "factory",
 		.offset		= 0x7c0000,
 		.size		= 0x010000,
 		.mask_flags	= MTD_WRITEABLE,
-	} , {
+	}, {
 		.name		= "language",
 		.offset		= 0x7d0000,
 		.size		= 0x020000,
 		.mask_flags	= MTD_WRITEABLE,
-	} , {
+	}, {
 		.name		= "caldata",
 		.offset		= 0x7f0000,
 		.size		= 0x010000,
 		.mask_flags	= MTD_WRITEABLE,
-	} , {
+	}, {
 		.name		= "firmware",
 		.offset		= 0x040000,
 		.size		= 0x770000,
@@ -85,8 +86,8 @@ static struct mtd_partition wrt400n_partitions[] = {
 
 static struct flash_platform_data wrt400n_flash_data = {
 #ifdef CONFIG_MTD_PARTITIONS
-        .parts          = wrt400n_partitions,
-        .nr_parts       = ARRAY_SIZE(wrt400n_partitions),
+	.parts		= wrt400n_partitions,
+	.nr_parts	= ARRAY_SIZE(wrt400n_partitions),
 #endif
 };
 
@@ -110,19 +111,19 @@ static struct gpio_led wrt400n_leds_gpio[] __initdata = {
 	}
 };
 
-static struct gpio_button wrt400n_gpio_buttons[] __initdata = {
+static struct gpio_keys_button wrt400n_gpio_keys[] __initdata = {
 	{
 		.desc		= "reset",
 		.type		= EV_KEY,
-		.code		= BTN_0,
-		.threshold	= 3,
+		.code		= KEY_RESTART,
+		.debounce_interval = WRT400N_KEYS_DEBOUNE_INTERVAL,
 		.gpio		= WRT400N_GPIO_BTN_RESET,
 		.active_low	= 1,
-	} , {
+	}, {
 		.desc		= "wlsec",
 		.type		= EV_KEY,
-		.code		= BTN_1,
-		.threshold	= 3,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = WRT400N_KEYS_DEBOUNE_INTERVAL,
 		.gpio		= WRT400N_GPIO_BTN_WLSEC,
 		.active_low	= 1,
 	}
@@ -131,21 +132,16 @@ static struct gpio_button wrt400n_gpio_buttons[] __initdata = {
 static void __init wrt400n_setup(void)
 {
 	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
-	u8 mac[6];
-	int i;
-
-	memcpy(mac, art + WRT400N_MAC_ADDR_OFFSET, 6);
-	for (i = 5; i >= 3; i--)
-		if (++mac[i] != 0x00) break;
-
-	ar71xx_set_mac_base(mac);
+	u8 *mac = art + WRT400N_MAC_ADDR_OFFSET;
 
-	ar71xx_add_device_mdio(0x0);
+	ar71xx_add_device_mdio(0, 0x0);
 
+	ar71xx_init_mac(ar71xx_eth0_data.mac_addr, mac, 1);
 	ar71xx_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
 	ar71xx_eth0_data.speed = SPEED_100;
 	ar71xx_eth0_data.duplex = DUPLEX_FULL;
 
+	ar71xx_init_mac(ar71xx_eth1_data.mac_addr, mac, 2);
 	ar71xx_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
 	ar71xx_eth1_data.phy_mask = 0x10;
 
@@ -157,9 +153,9 @@ static void __init wrt400n_setup(void)
 	ar71xx_add_device_leds_gpio(-1, ARRAY_SIZE(wrt400n_leds_gpio),
 					wrt400n_leds_gpio);
 
-	ar71xx_add_device_gpio_buttons(-1, WRT400N_BUTTONS_POLL_INTERVAL,
-					ARRAY_SIZE(wrt400n_gpio_buttons),
-					wrt400n_gpio_buttons);
+	ar71xx_register_gpio_keys_polled(-1, WRT400N_KEYS_POLL_INTERVAL,
+					 ARRAY_SIZE(wrt400n_gpio_keys),
+					 wrt400n_gpio_keys);
 
 	ap94_pci_init(art + WRT400N_CALDATA0_OFFSET, NULL,
 		      art + WRT400N_CALDATA1_OFFSET, NULL);
diff --git a/arch/mips/ar71xx/mach-wzr-hp-ag300h.c b/arch/mips/ar71xx/mach-wzr-hp-ag300h.c
new file mode 100644
index 0000000..c85657d
--- /dev/null
+++ b/arch/mips/ar71xx/mach-wzr-hp-ag300h.c
@@ -0,0 +1,231 @@
+/*
+ *  Buffalo WZR-HP-AG300H board support
+ *
+ *  Copyright (C) 2011 Felix Fietkau <nbd@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/platform_device.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <linux/mtd/concat.h>
+
+#include <asm/mips_machine.h>
+#include <asm/mach-ar71xx/ar71xx.h>
+#include <asm/mach-ar71xx/gpio.h>
+
+#include "machtype.h"
+#include "devices.h"
+#include "dev-ap94-pci.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+
+#define WZRHPAG300H_MAC_OFFSET		0x20c
+#define WZRHPAG300H_KEYS_POLL_INTERVAL     20      /* msecs */
+#define WZRHPAG300H_KEYS_DEBOUNCE_INTERVAL (3 * WZRHPAG300H_KEYS_POLL_INTERVAL)
+
+#ifdef CONFIG_MTD_PARTITIONS
+static struct mtd_partition wzrhpag300h_flash_partitions[] = {
+	{
+		.name		= "u-boot",
+		.offset		= 0,
+		.size		= 0x0040000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "u-boot-env",
+		.offset		= 0x0040000,
+		.size		= 0x0010000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "art",
+		.offset		= 0x0050000,
+		.size		= 0x0010000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "kernel",
+		.offset		= 0x0060000,
+		.size		= 0x0100000,
+	}, {
+		.name		= "rootfs",
+		.offset		= 0x0160000,
+		.size		= 0x1e90000,
+	}, {
+		.name		= "user_property",
+		.offset		= 0x1ff0000,
+		.size		= 0x0010000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "firmware",
+		.offset		= 0x0060000,
+		.size		= 0x1f90000,
+	}
+};
+
+#endif /* CONFIG_MTD_PARTITIONS */
+
+static struct mtd_info *concat_devs[2] = { NULL, NULL };
+static struct work_struct mtd_concat_work;
+
+static void mtd_concat_add_work(struct work_struct *work)
+{
+	struct mtd_info *mtd;
+
+	mtd = mtd_concat_create(concat_devs, ARRAY_SIZE(concat_devs), "flash");
+
+#ifdef CONFIG_MTD_PARTITIONS
+	add_mtd_partitions(mtd, wzrhpag300h_flash_partitions,
+			   ARRAY_SIZE(wzrhpag300h_flash_partitions));
+#else
+	add_mtd_device(mtd);
+#endif
+}
+
+static void mtd_concat_add(struct mtd_info *mtd)
+{
+	static bool registered = false;
+
+	if (registered)
+		return;
+
+	if (!strcmp(mtd->name, "spi0.0"))
+		concat_devs[0] = mtd;
+	else if (!strcmp(mtd->name, "spi0.1"))
+		concat_devs[1] = mtd;
+	else
+		return;
+
+	if (!concat_devs[0] || !concat_devs[1])
+		return;
+
+	registered = true;
+	INIT_WORK(&mtd_concat_work, mtd_concat_add_work);
+	schedule_work(&mtd_concat_work);
+}
+
+static void mtd_concat_remove(struct mtd_info *mtd)
+{
+}
+
+static void add_mtd_concat_notifier(void)
+{
+	static struct mtd_notifier not = {
+		.add = mtd_concat_add,
+		.remove = mtd_concat_remove,
+	};
+
+	register_mtd_user(&not);
+}
+
+static struct gpio_led wzrhpag300h_leds_gpio[] __initdata = {
+	{
+		.name		= "buffalo:red:diag",
+		.gpio		= 1,
+		.active_low	= 1,
+	},
+};
+
+
+static struct gpio_keys_button wzrhpag300h_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = WZRHPAG300H_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= 11,
+		.active_low	= 1,
+	}, {
+		.desc		= "usb",
+		.type		= EV_KEY,
+		.code		= BTN_2,
+		.debounce_interval = WZRHPAG300H_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= 3,
+		.active_low	= 1,
+	}, {
+		.desc		= "aoss",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = WZRHPAG300H_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= 5,
+		.active_low	= 1,
+	}, {
+		.desc		= "router_auto",
+		.type		= EV_KEY,
+		.code		= BTN_6,
+		.debounce_interval = WZRHPAG300H_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= 6,
+		.active_low	= 1,
+	}, {
+		.desc		= "router_off",
+		.type		= EV_KEY,
+		.code		= BTN_5,
+		.debounce_interval = WZRHPAG300H_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= 7,
+		.active_low	= 1,
+	}
+};
+
+static struct spi_board_info ar71xx_spi_info[] = {
+	{
+		.bus_num	= 0,
+		.chip_select	= 0,
+		.max_speed_hz   = 25000000,
+		.modalias   = "m25p80",
+	},
+	{
+		.bus_num	= 0,
+		.chip_select	= 1,
+		.max_speed_hz   = 25000000,
+		.modalias   = "m25p80",
+	}
+};
+
+static void __init wzrhpag300h_setup(void)
+{
+	u8 *eeprom1 = (u8 *) KSEG1ADDR(0x1f051000);
+	u8 *eeprom2 = (u8 *) KSEG1ADDR(0x1f055000);
+	u8 *mac1 = eeprom1 + WZRHPAG300H_MAC_OFFSET;
+	u8 *mac2 = eeprom2 + WZRHPAG300H_MAC_OFFSET;
+
+	ar71xx_init_mac(ar71xx_eth0_data.mac_addr, mac1, 0);
+	ar71xx_init_mac(ar71xx_eth1_data.mac_addr, mac2, 1);
+
+	ar71xx_add_device_mdio(0, ~(BIT(0) | BIT(4)));
+
+	ar71xx_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ar71xx_eth0_data.speed = SPEED_1000;
+	ar71xx_eth0_data.duplex = DUPLEX_FULL;
+	ar71xx_eth0_data.phy_mask = BIT(0);
+
+	ar71xx_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ar71xx_eth1_data.phy_mask = BIT(4);
+
+	ar71xx_add_device_eth(0);
+	ar71xx_add_device_eth(1);
+
+	ar71xx_add_device_usb();
+	gpio_request(2, "usb");
+	gpio_direction_output(2, 1);
+
+	ar71xx_add_device_leds_gpio(-1, ARRAY_SIZE(wzrhpag300h_leds_gpio),
+					wzrhpag300h_leds_gpio);
+
+	ar71xx_register_gpio_keys_polled(-1, WZRHPAG300H_KEYS_POLL_INTERVAL,
+					 ARRAY_SIZE(wzrhpag300h_gpio_keys),
+					 wzrhpag300h_gpio_keys);
+
+	ar71xx_add_device_spi(NULL, ar71xx_spi_info,
+			      ARRAY_SIZE(ar71xx_spi_info));
+
+	add_mtd_concat_notifier();
+
+	ap94_pci_init(eeprom1, mac1, eeprom2, mac2);
+}
+
+MIPS_MACHINE(AR71XX_MACH_WZR_HP_AG300H, "WZR-HP-AG300H",
+	     "Buffalo WZR-HP-AG300H", wzrhpag300h_setup);
+
diff --git a/arch/mips/ar71xx/mach-wzr-hp-g300nh.c b/arch/mips/ar71xx/mach-wzr-hp-g300nh.c
index b52cc60..2eb742e 100644
--- a/arch/mips/ar71xx/mach-wzr-hp-g300nh.c
+++ b/arch/mips/ar71xx/mach-wzr-hp-g300nh.c
@@ -12,7 +12,7 @@
 #include <linux/mtd/mtd.h>
 #include <linux/mtd/partitions.h>
 #include <linux/nxp_74hc153.h>
-#include <linux/rtl8366s.h>
+#include <linux/rtl8366.h>
 
 #include <asm/mips_machine.h>
 #include <asm/mach-ar71xx/ar71xx.h>
@@ -20,7 +20,7 @@
 
 #include "machtype.h"
 #include "devices.h"
-#include "dev-ar913x-wmac.h"
+#include "dev-ar9xxx-wmac.h"
 #include "dev-gpio-buttons.h"
 #include "dev-leds-gpio.h"
 #include "dev-usb.h"
@@ -48,7 +48,8 @@
 #define WZRHPG300NH_GPIO_BTN_ROUTER_AUTO (WZRHPG300NH_GPIO_EXP_BASE + 6)
 #define WZRHPG300NH_GPIO_BTN_QOS_OFF	(WZRHPG300NH_GPIO_EXP_BASE + 7)
 
-#define WZRHPG300NH_BUTTONS_POLL_INTERVAL	20
+#define WZRHPG300NH_KEYS_POLL_INTERVAL	20	/* msecs */
+#define WZRHPG300NH_KEYS_DEBOUNCE_INTERVAL (3 * WZRHPG300NH_KEYS_POLL_INTERVAL)
 
 #define WZRHPG300NH_MAC_OFFSET		0x20c
 
@@ -93,8 +94,8 @@ static struct mtd_partition wzrhpg300nh_flash_partitions[] = {
 static struct ar91xx_flash_platform_data wzrhpg300nh_flash_data = {
 	.width		= 2,
 #ifdef CONFIG_MTD_PARTITIONS
-        .parts          = wzrhpg300nh_flash_partitions,
-        .nr_parts       = ARRAY_SIZE(wzrhpg300nh_flash_partitions),
+	.parts		= wzrhpg300nh_flash_partitions,
+	.nr_parts	= ARRAY_SIZE(wzrhpg300nh_flash_partitions),
 #endif
 };
 
@@ -121,76 +122,76 @@ static struct platform_device wzrhpg300nh_flash_device = {
 
 static struct gpio_led wzrhpg300nh_leds_gpio[] __initdata = {
 	{
-		.name		= "wzr-hp-g300nh:orange:security",
+		.name		= "buffalo:orange:security",
 		.gpio		= WZRHPG300NH_GPIO_LED_SECURITY,
 		.active_low	= 1,
 	}, {
-		.name		= "wzr-hp-g300nh:green:wireless",
+		.name		= "buffalo:green:wireless",
 		.gpio		= WZRHPG300NH_GPIO_LED_WIRELESS,
 		.active_low	= 1,
 	}, {
-		.name		= "wzr-hp-g300nh:green:router",
+		.name		= "buffalo:green:router",
 		.gpio		= WZRHPG300NH_GPIO_LED_ROUTER,
 		.active_low	= 1,
 	}, {
-		.name		= "wzr-hp-g300nh:red:diag",
+		.name		= "buffalo:red:diag",
 		.gpio		= WZRHPG300NH_GPIO_LED_DIAG,
 		.active_low	= 1,
 	}, {
-		.name		= "wzr-hp-g300nh:blue:usb",
+		.name		= "buffalo:blue:usb",
 		.gpio		= WZRHPG300NH_GPIO_LED_USB,
 		.active_low	= 1,
 	}
 };
 
-static struct gpio_button wzrhpg300nh_gpio_buttons[] __initdata = {
+static struct gpio_keys_button wzrhpg300nh_gpio_keys[] __initdata = {
 	{
 		.desc		= "reset",
 		.type		= EV_KEY,
-		.code		= BTN_0,
-		.threshold	= 3,
+		.code		= KEY_RESTART,
+		.debounce_interval = WZRHPG300NH_KEYS_DEBOUNCE_INTERVAL,
 		.gpio		= WZRHPG300NH_GPIO_BTN_RESET,
 		.active_low	= 1,
 	}, {
 		.desc		= "aoss",
 		.type		= EV_KEY,
-		.code		= BTN_1,
-		.threshold	= 3,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = WZRHPG300NH_KEYS_DEBOUNCE_INTERVAL,
 		.gpio		= WZRHPG300NH_GPIO_BTN_AOSS,
 		.active_low	= 1,
 	}, {
 		.desc		= "usb",
 		.type		= EV_KEY,
 		.code		= BTN_2,
-		.threshold	= 3,
+		.debounce_interval = WZRHPG300NH_KEYS_DEBOUNCE_INTERVAL,
 		.gpio		= WZRHPG300NH_GPIO_BTN_USB,
 		.active_low	= 1,
 	}, {
 		.desc		= "qos_on",
 		.type		= EV_KEY,
 		.code		= BTN_3,
-		.threshold	= 3,
+		.debounce_interval = WZRHPG300NH_KEYS_DEBOUNCE_INTERVAL,
 		.gpio		= WZRHPG300NH_GPIO_BTN_QOS_ON,
 		.active_low	= 0,
 	}, {
 		.desc		= "qos_off",
 		.type		= EV_KEY,
 		.code		= BTN_4,
-		.threshold	= 3,
+		.debounce_interval = WZRHPG300NH_KEYS_DEBOUNCE_INTERVAL,
 		.gpio		= WZRHPG300NH_GPIO_BTN_QOS_OFF,
 		.active_low	= 0,
 	}, {
 		.desc		= "router_on",
 		.type		= EV_KEY,
 		.code		= BTN_5,
-		.threshold	= 3,
+		.debounce_interval = WZRHPG300NH_KEYS_DEBOUNCE_INTERVAL,
 		.gpio		= WZRHPG300NH_GPIO_BTN_ROUTER_ON,
 		.active_low	= 0,
 	}, {
 		.desc		= "router_auto",
 		.type		= EV_KEY,
 		.code		= BTN_6,
-		.threshold	= 3,
+		.debounce_interval = WZRHPG300NH_KEYS_DEBOUNCE_INTERVAL,
 		.gpio		= WZRHPG300NH_GPIO_BTN_ROUTER_AUTO,
 		.active_low	= 0,
 	}
@@ -212,33 +213,55 @@ static struct platform_device wzrhpg300nh_74hc153_device = {
 	}
 };
 
-static struct rtl8366s_platform_data wzrhpg300nh_rtl8366s_data = {
-	.gpio_sda        = WZRHPG300NH_GPIO_RTL8366_SDA,
-	.gpio_sck        = WZRHPG300NH_GPIO_RTL8366_SCK,
+static struct rtl8366_platform_data wzrhpg300nh_rtl8366_data = {
+	.gpio_sda	= WZRHPG300NH_GPIO_RTL8366_SDA,
+	.gpio_sck	= WZRHPG300NH_GPIO_RTL8366_SCK,
 };
 
 static struct platform_device wzrhpg300nh_rtl8366s_device = {
 	.name		= RTL8366S_DRIVER_NAME,
 	.id		= -1,
 	.dev = {
-		.platform_data	= &wzrhpg300nh_rtl8366s_data,
+		.platform_data	= &wzrhpg300nh_rtl8366_data,
+	}
+};
+
+static struct platform_device wzrhpg300nh_rtl8366rb_device = {
+	.name           = RTL8366RB_DRIVER_NAME,
+	.id             = -1,
+	.dev = {
+		.platform_data  = &wzrhpg300nh_rtl8366_data,
 	}
 };
 
 static void __init wzrhpg300nh_setup(void)
 {
 	u8 *eeprom = (u8 *) KSEG1ADDR(0x1fff1000);
+	u8 *mac = eeprom + WZRHPG300NH_MAC_OFFSET;
+	bool hasrtl8366rb = false;
 
-	ar71xx_set_mac_base(eeprom + WZRHPG300NH_MAC_OFFSET);
+	ar71xx_init_mac(ar71xx_eth0_data.mac_addr, mac, 0);
+	ar71xx_init_mac(ar71xx_eth1_data.mac_addr, mac, 1);
+
+	if (rtl8366_smi_detect(&wzrhpg300nh_rtl8366_data) == RTL8366_TYPE_RB)
+		hasrtl8366rb = true;
+
+	if (hasrtl8366rb) {
+		ar71xx_eth0_pll_data.pll_1000 = 0x1f000000;
+		ar71xx_eth0_data.mii_bus_dev = &wzrhpg300nh_rtl8366rb_device.dev;
+		ar71xx_eth1_pll_data.pll_1000 = 0x100;
+		ar71xx_eth1_data.mii_bus_dev = &wzrhpg300nh_rtl8366rb_device.dev;
+	} else {
+		ar71xx_eth0_pll_data.pll_1000 = 0x1e000100;
+		ar71xx_eth0_data.mii_bus_dev = &wzrhpg300nh_rtl8366s_device.dev;
+		ar71xx_eth1_pll_data.pll_1000 = 0x1e000100;
+		ar71xx_eth1_data.mii_bus_dev = &wzrhpg300nh_rtl8366s_device.dev;
+	}
 
-	ar71xx_eth0_pll_data.pll_1000 = 0x1e000100;
-	ar71xx_eth0_data.mii_bus_dev = &wzrhpg300nh_rtl8366s_device.dev;
 	ar71xx_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
 	ar71xx_eth0_data.speed = SPEED_1000;
 	ar71xx_eth0_data.duplex = DUPLEX_FULL;
 
-	ar71xx_eth1_pll_data.pll_1000 = 0x1e000100;
-	ar71xx_eth1_data.mii_bus_dev = &wzrhpg300nh_rtl8366s_device.dev;
 	ar71xx_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
 	ar71xx_eth1_data.phy_mask = 0x10;
 
@@ -246,18 +269,22 @@ static void __init wzrhpg300nh_setup(void)
 	ar71xx_add_device_eth(1);
 
 	ar71xx_add_device_usb();
-	ar913x_add_device_wmac(eeprom, NULL);
+	ar9xxx_add_device_wmac(eeprom, NULL);
 
 	platform_device_register(&wzrhpg300nh_74hc153_device);
 	platform_device_register(&wzrhpg300nh_flash_device);
-	platform_device_register(&wzrhpg300nh_rtl8366s_device);
+
+	if (hasrtl8366rb)
+		platform_device_register(&wzrhpg300nh_rtl8366rb_device);
+	else
+		platform_device_register(&wzrhpg300nh_rtl8366s_device);
 
 	ar71xx_add_device_leds_gpio(-1, ARRAY_SIZE(wzrhpg300nh_leds_gpio),
-				    wzrhpg300nh_leds_gpio);
+					wzrhpg300nh_leds_gpio);
 
-	ar71xx_add_device_gpio_buttons(-1, WZRHPG300NH_BUTTONS_POLL_INTERVAL,
-				       ARRAY_SIZE(wzrhpg300nh_gpio_buttons),
-				       wzrhpg300nh_gpio_buttons);
+	ar71xx_register_gpio_keys_polled(-1, WZRHPG300NH_KEYS_POLL_INTERVAL,
+					 ARRAY_SIZE(wzrhpg300nh_gpio_keys),
+					 wzrhpg300nh_gpio_keys);
 
 }
 
diff --git a/arch/mips/ar71xx/mach-zcn-1523h.c b/arch/mips/ar71xx/mach-zcn-1523h.c
new file mode 100644
index 0000000..7828b37
--- /dev/null
+++ b/arch/mips/ar71xx/mach-zcn-1523h.c
@@ -0,0 +1,208 @@
+/*
+ *  Zcomax ZCN-1523H-2-8/5-16 board support
+ *
+ *  Copyright (C) 2010 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/mach-ar71xx/ar71xx.h>
+
+#include "machtype.h"
+#include "devices.h"
+#include "dev-m25p80.h"
+#include "dev-ap91-pci.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+
+#define ZCN_1523H_GPIO_BTN_RESET	0
+#define ZCN_1523H_GPIO_LED_INIT		11
+#define ZCN_1523H_GPIO_LED_LAN1		17
+
+#define ZCN_1523H_2_GPIO_LED_WEAK	13
+#define ZCN_1523H_2_GPIO_LED_MEDIUM	14
+#define ZCN_1523H_2_GPIO_LED_STRONG	15
+
+#define ZCN_1523H_5_GPIO_LED_UNKNOWN	1
+#define ZCN_1523H_5_GPIO_LED_LAN2	13
+#define ZCN_1523H_5_GPIO_LED_WEAK	14
+#define ZCN_1523H_5_GPIO_LED_MEDIUM	15
+#define ZCN_1523H_5_GPIO_LED_STRONG	16
+
+#define ZCN_1523H_KEYS_POLL_INTERVAL	20	/* msecs */
+#define ZCN_1523H_KEYS_DEBOUNCE_INTERVAL (3 * ZCN_1523H_KEYS_POLL_INTERVAL)
+
+#ifdef CONFIG_MTD_PARTITIONS
+static struct mtd_partition zcn_1523h_partitions[] = {
+	{
+		.name		= "u-boot",
+		.offset		= 0,
+		.size		= 0x040000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "u-boot-env",
+		.offset		= 0x040000,
+		.size		= 0x010000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "rootfs",
+		.offset		= 0x050000,
+		.size		= 0x610000,
+	}, {
+		.name		= "kernel",
+		.offset		= 0x660000,
+		.size		= 0x170000,
+	}, {
+		.name		= "configure",
+		.offset		= 0x7d0000,
+		.size		= 0x010000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "mfg",
+		.offset		= 0x7e0000,
+		.size		= 0x010000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "eeprom",
+		.offset		= 0x7f0000,
+		.size		= 0x010000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "firmware",
+		.offset		= 0x050000,
+		.size		= 0x780000,
+	}
+};
+#endif /* CONFIG_MTD_PARTITIONS */
+
+static struct flash_platform_data zcn_1523h_flash_data = {
+#ifdef CONFIG_MTD_PARTITIONS
+	.parts		= zcn_1523h_partitions,
+	.nr_parts	= ARRAY_SIZE(zcn_1523h_partitions),
+#endif
+};
+
+static struct gpio_keys_button zcn_1523h_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = ZCN_1523H_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= ZCN_1523H_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_led zcn_1523h_leds_gpio[] __initdata = {
+	{
+		.name		= "zcn-1523h:amber:init",
+		.gpio		= ZCN_1523H_GPIO_LED_INIT,
+		.active_low	= 1,
+	}, {
+		.name		= "zcn-1523h:green:lan1",
+		.gpio		= ZCN_1523H_GPIO_LED_LAN1,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_led zcn_1523h_2_leds_gpio[] __initdata = {
+	{
+		.name		= "zcn-1523h:red:weak",
+		.gpio		= ZCN_1523H_2_GPIO_LED_WEAK,
+		.active_low	= 1,
+	}, {
+		.name		= "zcn-1523h:amber:medium",
+		.gpio		= ZCN_1523H_2_GPIO_LED_MEDIUM,
+		.active_low	= 1,
+	}, {
+		.name		= "zcn-1523h:green:strong",
+		.gpio		= ZCN_1523H_2_GPIO_LED_STRONG,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_led zcn_1523h_5_leds_gpio[] __initdata = {
+	{
+		.name		= "zcn-1523h:red:weak",
+		.gpio		= ZCN_1523H_5_GPIO_LED_WEAK,
+		.active_low	= 1,
+	}, {
+		.name		= "zcn-1523h:amber:medium",
+		.gpio		= ZCN_1523H_5_GPIO_LED_MEDIUM,
+		.active_low	= 1,
+	}, {
+		.name		= "zcn-1523h:green:strong",
+		.gpio		= ZCN_1523H_5_GPIO_LED_STRONG,
+		.active_low	= 1,
+	}, {
+		.name		= "zcn-1523h:green:lan2",
+		.gpio		= ZCN_1523H_5_GPIO_LED_LAN2,
+		.active_low	= 1,
+	}, {
+		.name		= "zcn-1523h:amber:unknown",
+		.gpio		= ZCN_1523H_5_GPIO_LED_UNKNOWN,
+	}
+};
+
+static void __init zcn_1523h_generic_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f7e0004);
+	u8 *ee = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	ar71xx_gpio_function_disable(AR724X_GPIO_FUNC_ETH_SWITCH_LED0_EN |
+				     AR724X_GPIO_FUNC_ETH_SWITCH_LED1_EN |
+				     AR724X_GPIO_FUNC_ETH_SWITCH_LED2_EN |
+				     AR724X_GPIO_FUNC_ETH_SWITCH_LED3_EN |
+				     AR724X_GPIO_FUNC_ETH_SWITCH_LED4_EN);
+
+	ar71xx_add_device_m25p80(&zcn_1523h_flash_data);
+
+	ar71xx_add_device_leds_gpio(0, ARRAY_SIZE(zcn_1523h_leds_gpio),
+					zcn_1523h_leds_gpio);
+
+	ar71xx_register_gpio_keys_polled(-1, ZCN_1523H_KEYS_POLL_INTERVAL,
+					 ARRAY_SIZE(zcn_1523h_gpio_keys),
+					 zcn_1523h_gpio_keys);
+
+	ap91_pci_init(ee, mac);
+
+	ar71xx_init_mac(ar71xx_eth0_data.mac_addr, mac, 0);
+	ar71xx_init_mac(ar71xx_eth1_data.mac_addr, mac, 1);
+
+	ar71xx_add_device_mdio(0, 0x0);
+
+	/* LAN1 port */
+	ar71xx_add_device_eth(0);
+}
+
+static void __init zcn_1523h_2_setup(void)
+{
+	zcn_1523h_generic_setup();
+	ap91_pci_setup_wmac_gpio(BIT(9), 0);
+
+	ar71xx_add_device_leds_gpio(1, ARRAY_SIZE(zcn_1523h_2_leds_gpio),
+					zcn_1523h_2_leds_gpio);
+}
+
+MIPS_MACHINE(AR71XX_MACH_ZCN_1523H_2, "ZCN-1523H-2", "Zcomax ZCN-1523H-2",
+	     zcn_1523h_2_setup);
+
+static void __init zcn_1523h_5_setup(void)
+{
+	zcn_1523h_generic_setup();
+	ap91_pci_setup_wmac_gpio(BIT(8), 0);
+
+	ar71xx_add_device_leds_gpio(1, ARRAY_SIZE(zcn_1523h_5_leds_gpio),
+					zcn_1523h_5_leds_gpio);
+
+	/* LAN2 port */
+	ar71xx_add_device_eth(1);
+}
+
+MIPS_MACHINE(AR71XX_MACH_ZCN_1523H_5, "ZCN-1523H-5", "Zcomax ZCN-1523H-5",
+	     zcn_1523h_5_setup);
diff --git a/arch/mips/ar71xx/machtype.h b/arch/mips/ar71xx/machtype.h
index a8679d9..78d8bdd 100644
--- a/arch/mips/ar71xx/machtype.h
+++ b/arch/mips/ar71xx/machtype.h
@@ -16,44 +16,68 @@
 
 enum ar71xx_mach_type {
 	AR71XX_MACH_GENERIC = 0,
+	AR71XX_MACH_ALL0258N,	/* Allnet ALL0258N */
+	AR71XX_MACH_AP121,	/* Atheros AP121 */
+	AR71XX_MACH_AP121_MINI,	/* Atheros AP121-MINI */
 	AR71XX_MACH_AP81,	/* Atheros AP81 */
 	AR71XX_MACH_AP83,	/* Atheros AP83 */
+	AR71XX_MACH_AP96,	/* Atheros AP96 */
 	AR71XX_MACH_AW_NR580,	/* AzureWave AW-NR580 */
+	AR71XX_MACH_DB120,      /* Atheros DB120 (AR934x based) */
 	AR71XX_MACH_DIR_600_A1,	/* D-Link DIR-600 rev. A1 */
 	AR71XX_MACH_DIR_615_C1,	/* D-Link DIR-615 rev. C1 */
 	AR71XX_MACH_DIR_825_B1,	/* D-Link DIR-825 rev. B1 */
+	AR71XX_MACH_EAP7660D,	/* Senao EAP7660D */
+	AR71XX_MACH_JA76PF,	/* jjPlus JA76PF */
+	AR71XX_MACH_JWAP003,	/* jjPlus JWAP003 */
+	AR71XX_MACH_MZK_W04NU,	/* Planex MZK-W04NU */
+	AR71XX_MACH_MZK_W300NH,	/* Planex MZK-W300NH */
+	AR71XX_MACH_NBG460N,	/* Zyxel NBG460N/550N/550NH */
+	AR71XX_MACH_OM2P,       /* OpenMesh OM2P */
+	AR71XX_MACH_PB42,	/* Atheros PB42 */
+	AR71XX_MACH_PB44,	/* Atheros PB44 */
+	AR71XX_MACH_PB92,	/* Atheros PB92 */
 	AR71XX_MACH_RB_411,	/* MikroTik RouterBOARD 411/411A/411AH */
 	AR71XX_MACH_RB_411U,	/* MikroTik RouterBOARD 411U */
 	AR71XX_MACH_RB_433,	/* MikroTik RouterBOARD 433/433AH */
 	AR71XX_MACH_RB_433U,	/* MikroTik RouterBOARD 433UAH */
-	AR71XX_MACH_RB_450,	/* MikroTik RouterBOARD 450 */
 	AR71XX_MACH_RB_450G,	/* MikroTik RouterBOARD 450G */
+	AR71XX_MACH_RB_450,	/* MikroTik RouterBOARD 450 */
 	AR71XX_MACH_RB_493,	/* Mikrotik RouterBOARD 493/493AH */
+	AR71XX_MACH_RB_493G,	/* Mikrotik RouterBOARD 493G */
 	AR71XX_MACH_RB_750,	/* MikroTik RouterBOARD 750 */
-	AR71XX_MACH_PB42,	/* Atheros PB42 */
-	AR71XX_MACH_PB44,	/* Atheros PB44 */
-	AR71XX_MACH_PB92,	/* Atheros PB92 */
-	AR71XX_MACH_MZK_W04NU,	/* Planex MZK-W04NU */
-	AR71XX_MACH_MZK_W300NH,	/* Planex MZK-W300NH */
 	AR71XX_MACH_TEW_632BRP,	/* TRENDnet TEW-632BRP */
+	AR71XX_MACH_TL_MR3220,	/* TP-LINK TL-MR3220 */
+	AR71XX_MACH_TL_MR3420,	/* TP-LINK TL-MR3420 */
+	AR71XX_MACH_TL_WA901ND,	/* TP-LINK TL-WA901ND */
+	AR71XX_MACH_TL_WA901ND_V2, /* TP-LINK TL-WA901ND v2 */
+	AR71XX_MACH_TL_WR1043ND, /* TP-LINK TL-WR1041ND */
+	AR71XX_MACH_TL_WR703N,	/* TP-LINK TL-WR703N */
 	AR71XX_MACH_TL_WR741ND,	/* TP-LINK TL-WR741ND */
+	AR71XX_MACH_TL_WR741ND_V4, /* TP-LINK TL-WR741ND  v4*/
 	AR71XX_MACH_TL_WR841N_V1, /* TP-LINK TL-WR841N v1 */
 	AR71XX_MACH_TL_WR941ND,	/* TP-LINK TL-WR941ND */
-	AR71XX_MACH_TL_WR1043ND, /* TP-LINK TL-WR1041ND */
+	AR71XX_MACH_UBNT_BULLET_M, /* Ubiquiti Bullet M */
 	AR71XX_MACH_UBNT_LSSR71, /* Ubiquiti LS-SR71 */
 	AR71XX_MACH_UBNT_LSX,	/* Ubiquiti LSX */
-	AR71XX_MACH_UBNT_RS,	/* Ubiquiti RouterStation */
-	AR71XX_MACH_UBNT_AR71XX, /* Ubiquiti AR71xx-based board */
-	AR71XX_MACH_UBNT_RSPRO,	/* Ubiquiti RouterStation Pro */
-	AR71XX_MACH_UBNT_BULLET_M, /* Ubiquiti Bullet M */
-	AR71XX_MACH_UBNT_ROCKET_M, /* Ubiquiti Rocket M */
 	AR71XX_MACH_UBNT_NANO_M, /* Ubiquiti NanoStation M */
+	AR71XX_MACH_UBNT_ROCKET_M, /* Ubiquiti Rocket M */
+	AR71XX_MACH_UBNT_RSPRO,	/* Ubiquiti RouterStation Pro */
+	AR71XX_MACH_UBNT_RS,	/* Ubiquiti RouterStation */
+	AR71XX_MACH_UBNT_UNIFI, /* Unifi */
+	AR71XX_MACH_WHR_G301N,	/* Buffalo WHR-G301N */
+	AR71XX_MACH_WHR_HP_G300N, /* Buffalo WHR-HP-G300N */
+	AR71XX_MACH_WHR_HP_GN,	/* Buffalo WHR-HP-GN */
 	AR71XX_MACH_WNDR3700,	/* NETGEAR WNDR3700 */
+	AR71XX_MACH_WNDR3700V2,	/* NETGEAR WNDR3700v2 */
 	AR71XX_MACH_WNR2000,	/* NETGEAR WNR2000 */
 	AR71XX_MACH_WP543,	/* Compex WP543 */
 	AR71XX_MACH_WRT160NL,	/* Linksys WRT160NL */
 	AR71XX_MACH_WRT400N,	/* Linksys WRT400N */
+	AR71XX_MACH_WZR_HP_AG300H, /* Buffalo WZR-HP-AG300H */
 	AR71XX_MACH_WZR_HP_G300NH, /* Buffalo WZR-HP-G300NH */
+	AR71XX_MACH_ZCN_1523H_2, /* Zcomax ZCN-1523H-2-xx */
+	AR71XX_MACH_ZCN_1523H_5, /* Zcomax ZCN-1523H-5-xx */
 };
 
 #endif /* _AR71XX_MACHTYPE_H */
diff --git a/arch/mips/ar71xx/nvram.c b/arch/mips/ar71xx/nvram.c
index e6d1f80..dfab246 100644
--- a/arch/mips/ar71xx/nvram.c
+++ b/arch/mips/ar71xx/nvram.c
@@ -69,7 +69,7 @@ int nvram_parse_mac_addr(const char *nvram, unsigned nvram_len,
 
 	ret = 0;
 
- free:
+free:
 	vfree(buf);
 	return ret;
 }
diff --git a/arch/mips/ar71xx/pci-ath9k-fixup.c b/arch/mips/ar71xx/pci-ath9k-fixup.c
new file mode 100644
index 0000000..21f5a68
--- /dev/null
+++ b/arch/mips/ar71xx/pci-ath9k-fixup.c
@@ -0,0 +1,123 @@
+/*
+ *  Atheros AP94 reference board PCI initialization
+ *
+ *  Copyright (C) 2009-2010 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/pci.h>
+#include <linux/delay.h>
+
+#include <asm/mach-ar71xx/ar71xx.h>
+#include <asm/mach-ar71xx/pci.h>
+
+struct ath9k_fixup {
+	u16		*cal_data;
+	unsigned	slot;
+};
+
+static int ath9k_num_fixups;
+static struct ath9k_fixup ath9k_fixups[2];
+
+static void ath9k_pci_fixup(struct pci_dev *dev)
+{
+	void __iomem *mem;
+	u16 *cal_data = NULL;
+	u16 cmd;
+	u32 bar0;
+	u32 val;
+	unsigned i;
+
+	for (i = 0; i < ath9k_num_fixups; i++) {
+		if (ath9k_fixups[i].cal_data == NULL)
+			continue;
+
+		if (ath9k_fixups[i].slot != PCI_SLOT(dev->devfn))
+			continue;
+
+		cal_data = ath9k_fixups[i].cal_data;
+		break;
+	}
+
+	if (cal_data == NULL)
+		return;
+
+	if (*cal_data != 0xa55a) {
+		pr_err("pci %s: invalid calibration data\n", pci_name(dev));
+		return;
+	}
+
+	pr_info("pci %s: fixup device configuration\n", pci_name(dev));
+
+	mem = ioremap(AR71XX_PCI_MEM_BASE, 0x10000);
+	if (!mem) {
+		pr_err("pci %s: ioremap error\n", pci_name(dev));
+		return;
+	}
+
+	pci_read_config_dword(dev, PCI_BASE_ADDRESS_0, &bar0);
+
+	switch (ar71xx_soc) {
+	case AR71XX_SOC_AR7161:
+		pci_write_config_dword(dev, PCI_BASE_ADDRESS_0,
+				       AR71XX_PCI_MEM_BASE);
+		break;
+	case AR71XX_SOC_AR7240:
+		pci_write_config_dword(dev, PCI_BASE_ADDRESS_0, 0xffff);
+		break;
+
+	case AR71XX_SOC_AR7241:
+	case AR71XX_SOC_AR7242:
+		pci_write_config_dword(dev, PCI_BASE_ADDRESS_0, 0x1000ffff);
+		break;
+
+	default:
+		BUG();
+	}
+
+	pci_read_config_word(dev, PCI_COMMAND, &cmd);
+	cmd |= PCI_COMMAND_MASTER | PCI_COMMAND_MEMORY;
+	pci_write_config_word(dev, PCI_COMMAND, cmd);
+
+	/* set pointer to first reg address */
+	cal_data += 3;
+	while (*cal_data != 0xffff) {
+		u32 reg;
+		reg = *cal_data++;
+		val = *cal_data++;
+		val |= (*cal_data++) << 16;
+
+		__raw_writel(val, mem + reg);
+		udelay(100);
+	}
+
+	pci_read_config_dword(dev, PCI_VENDOR_ID, &val);
+	dev->vendor = val & 0xffff;
+	dev->device = (val >> 16) & 0xffff;
+
+	pci_read_config_dword(dev, PCI_CLASS_REVISION, &val);
+	dev->revision = val & 0xff;
+	dev->class = val >> 8; /* upper 3 bytes */
+
+	pci_read_config_word(dev, PCI_COMMAND, &cmd);
+	cmd &= ~(PCI_COMMAND_MASTER | PCI_COMMAND_MEMORY);
+	pci_write_config_word(dev, PCI_COMMAND, cmd);
+
+	pci_write_config_dword(dev, PCI_BASE_ADDRESS_0, bar0);
+
+	iounmap(mem);
+}
+DECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_ATHEROS, PCI_ANY_ID, ath9k_pci_fixup);
+
+void __init pci_enable_ath9k_fixup(unsigned slot, u16 *cal_data)
+{
+	if (ath9k_num_fixups >= ARRAY_SIZE(ath9k_fixups))
+		return;
+
+	ath9k_fixups[ath9k_num_fixups].slot = slot;
+	ath9k_fixups[ath9k_num_fixups].cal_data = cal_data;
+	ath9k_num_fixups++;
+}
diff --git a/arch/mips/ar71xx/pci-ath9k-fixup.h b/arch/mips/ar71xx/pci-ath9k-fixup.h
new file mode 100644
index 0000000..5794941
--- /dev/null
+++ b/arch/mips/ar71xx/pci-ath9k-fixup.h
@@ -0,0 +1,6 @@
+#ifndef _PCI_ATH9K_FIXUP
+#define _PCI_ATH9K_FIXUP
+
+void pci_enable_ath9k_fixup(unsigned slot, u16 *cal_data) __init;
+
+#endif /* _PCI_ATH9K_FIXUP */
diff --git a/arch/mips/ar71xx/pci.c b/arch/mips/ar71xx/pci.c
index 3e1e8db..8850c0b 100644
--- a/arch/mips/ar71xx/pci.c
+++ b/arch/mips/ar71xx/pci.c
@@ -54,6 +54,8 @@ int __init pcibios_map_irq(const struct pci_dev *dev, uint8_t slot, uint8_t pin)
 	case AR71XX_SOC_AR7240:
 	case AR71XX_SOC_AR7241:
 	case AR71XX_SOC_AR7242:
+	case AR71XX_SOC_AR9342:
+	case AR71XX_SOC_AR9344:
 		ret = ar724x_pcibios_map_irq(dev, slot, pin);
 		break;
 
@@ -79,7 +81,12 @@ int __init ar71xx_pci_init(unsigned nr_irqs, struct ar71xx_pci_irq *map)
 	case AR71XX_SOC_AR7240:
 	case AR71XX_SOC_AR7241:
 	case AR71XX_SOC_AR7242:
-		ret = ar724x_pcibios_init();
+		ret = ar724x_pcibios_init(AR71XX_CPU_IRQ_IP2);
+		break;
+
+	case AR71XX_SOC_AR9342:
+	case AR71XX_SOC_AR9344:
+		ret = ar724x_pcibios_init(AR934X_IP2_IRQ_PCIE);
 		break;
 
 	default:
diff --git a/arch/mips/ar71xx/prom.c b/arch/mips/ar71xx/prom.c
index 87d6da0..293f9b2 100644
--- a/arch/mips/ar71xx/prom.c
+++ b/arch/mips/ar71xx/prom.c
@@ -1,7 +1,7 @@
 /*
  *  Atheros AR71xx SoC specific prom routines
  *
- *  Copyright (C) 2008-2009 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008-2010 Gabor Juhos <juhosg@openwrt.org>
  *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
  *
  *  This program is free software; you can redistribute it and/or modify it
@@ -33,36 +33,40 @@ static inline int is_valid_ram_addr(void *addr)
 	return 0;
 }
 
+static char ar71xx_cmdline_buf[COMMAND_LINE_SIZE] __initdata;
 static void __init ar71xx_prom_append_cmdline(const char *name,
 					      const char *value)
 {
-	char buf[COMMAND_LINE_SIZE];
-
-	snprintf(buf, sizeof(buf), " %s=%s", name, value);
-	strlcat(arcs_cmdline, buf, sizeof(arcs_cmdline));
+	snprintf(ar71xx_cmdline_buf, sizeof(ar71xx_cmdline_buf),
+		 " %s=%s", name, value);
+	strlcat(arcs_cmdline, ar71xx_cmdline_buf, sizeof(arcs_cmdline));
 }
 
-static void __init ar71xx_prom_find_env(char **envp, const char *name)
+static const char * __init ar71xx_prom_find_env(char **envp, const char *name)
 {
-	int len = strlen(name);
+	const char *ret = NULL;
+	int len;
 	char **p;
 
 	if (!is_valid_ram_addr(envp))
-		return;
+		return NULL;
 
+	len = strlen(name);
 	for (p = envp; is_valid_ram_addr(*p); p++) {
 		if (strncmp(name, *p, len) == 0 && (*p)[len] == '=') {
-			ar71xx_prom_append_cmdline(name, *p + len + 1);
+			ret = *p + len + 1;
 			break;
 		}
 
 		/* RedBoot env comes in pointer pairs - key, value */
 		if (strncmp(name, *p, len) == 0 && (*p)[len] == 0)
 			if (is_valid_ram_addr(*(++p))) {
-				ar71xx_prom_append_cmdline(name, *p);
+				ret = *p;
 				break;
 			}
 	}
+
+	return ret;
 }
 
 static int __init ar71xx_prom_init_myloader(void)
@@ -120,7 +124,7 @@ static int __init ar71xx_use__image_cmdline(void)
 	return 1;
 }
 #else
-static int inline ar71xx_use__image_cmdline(void) { return 0; }
+static inline int ar71xx_use__image_cmdline(void) { return 0; }
 #endif
 
 static __init void ar71xx_prom_init_cmdline(int argc, char **argv)
@@ -142,6 +146,7 @@ static __init void ar71xx_prom_init_cmdline(int argc, char **argv)
 
 void __init prom_init(void)
 {
+	const char *env;
 	char **envp;
 
 	printk(KERN_DEBUG "prom: fw_arg0=%08x, fw_arg1=%08x, "
@@ -156,8 +161,26 @@ void __init prom_init(void)
 	ar71xx_prom_init_cmdline(fw_arg0, (char **)fw_arg1);
 
 	envp = (char **)fw_arg2;
-	ar71xx_prom_find_env(envp, "board");
-	ar71xx_prom_find_env(envp, "ethaddr");
+	if (!strstr(arcs_cmdline, "ethaddr=")) {
+		env = ar71xx_prom_find_env(envp, "ethaddr");
+		if (env)
+			ar71xx_prom_append_cmdline("ethaddr", env);
+	}
+
+	if (!strstr(arcs_cmdline, "board=")) {
+		env = ar71xx_prom_find_env(envp, "board");
+		if (env) {
+			/* Workaround for buggy bootloaders */
+			if (strcmp(env, "RouterStation") == 0 ||
+			    strcmp(env, "Ubiquiti AR71xx-based board") == 0)
+				env = "UBNT-RS";
+
+			if (strcmp(env, "RouterStation PRO") == 0)
+				env = "UBNT-RSPRO";
+
+			ar71xx_prom_append_cmdline("board", env);
+		}
+	}
 }
 
 void __init prom_free_prom_memory(void)
diff --git a/arch/mips/ar71xx/setup.c b/arch/mips/ar71xx/setup.c
index d89505f..c85b02c 100644
--- a/arch/mips/ar71xx/setup.c
+++ b/arch/mips/ar71xx/setup.c
@@ -1,10 +1,12 @@
 /*
  *  Atheros AR71xx SoC specific setup
  *
+ *  Copyright (C) 2010-2011 Jaiganesh Narayanan <jnarayanan@atheros.com>
  *  Copyright (C) 2008-2009 Gabor Juhos <juhosg@openwrt.org>
  *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
  *
- *  Parts of this file are based on Atheros' 2.6.15 BSP
+ *  Parts of this file are based on Atheros 2.6.15 BSP
+ *  Parts of this file are based on Atheros 2.6.31 BSP
  *
  *  This program is free software; you can redistribute it and/or modify it
  *  under the terms of the GNU General Public License version 2 as published
@@ -26,9 +28,6 @@
 #include "devices.h"
 
 #define AR71XX_SYS_TYPE_LEN	64
-#define AR71XX_BASE_FREQ	40000000
-#define AR91XX_BASE_FREQ	5000000
-#define AR724X_BASE_FREQ	5000000
 
 u32 ar71xx_cpu_freq;
 EXPORT_SYMBOL_GPL(ar71xx_cpu_freq);
@@ -39,9 +38,15 @@ EXPORT_SYMBOL_GPL(ar71xx_ahb_freq);
 u32 ar71xx_ddr_freq;
 EXPORT_SYMBOL_GPL(ar71xx_ddr_freq);
 
+u32 ar71xx_ref_freq;
+EXPORT_SYMBOL_GPL(ar71xx_ref_freq);
+
 enum ar71xx_soc_type ar71xx_soc;
 EXPORT_SYMBOL_GPL(ar71xx_soc);
 
+u32 ar71xx_soc_rev;
+EXPORT_SYMBOL_GPL(ar71xx_soc_rev);
+
 static char ar71xx_sys_type[AR71XX_SYS_TYPE_LEN];
 
 static void ar71xx_restart(char *command)
@@ -63,7 +68,7 @@ static void __init ar71xx_detect_mem_size(void)
 	unsigned long size;
 
 	for (size = AR71XX_MEM_SIZE_MIN; size < AR71XX_MEM_SIZE_MAX;
-	     size <<= 1 ) {
+	     size <<= 1) {
 		if (!memcmp(ar71xx_detect_mem_size,
 			    ar71xx_detect_mem_size + size, 1024))
 			break;
@@ -109,19 +114,19 @@ static void __init ar71xx_detect_sys_type(void)
 	case REV_ID_MAJOR_AR7240:
 		ar71xx_soc = AR71XX_SOC_AR7240;
 		chip = "7240";
-		rev = (id & AR724X_REV_ID_REVISION_MASK);
+		rev = id & AR724X_REV_ID_REVISION_MASK;
 		break;
 
 	case REV_ID_MAJOR_AR7241:
 		ar71xx_soc = AR71XX_SOC_AR7241;
 		chip = "7241";
-		rev = (id & AR724X_REV_ID_REVISION_MASK);
+		rev = id & AR724X_REV_ID_REVISION_MASK;
 		break;
 
 	case REV_ID_MAJOR_AR7242:
 		ar71xx_soc = AR71XX_SOC_AR7242;
 		chip = "7242";
-		rev = (id & AR724X_REV_ID_REVISION_MASK);
+		rev = id & AR724X_REV_ID_REVISION_MASK;
 		break;
 
 	case REV_ID_MAJOR_AR913X:
@@ -141,11 +146,106 @@ static void __init ar71xx_detect_sys_type(void)
 		}
 		break;
 
+	case REV_ID_MAJOR_AR9330:
+		ar71xx_soc = AR71XX_SOC_AR9330;
+		chip = "9330";
+		rev = id & AR933X_REV_ID_REVISION_MASK;
+		break;
+
+	case REV_ID_MAJOR_AR9331:
+		ar71xx_soc = AR71XX_SOC_AR9331;
+		chip = "9331";
+		rev = id & AR933X_REV_ID_REVISION_MASK;
+		break;
+
+	case REV_ID_MAJOR_AR9342:
+		ar71xx_soc = AR71XX_SOC_AR9342;
+		chip = "9342";
+		rev = id & AR934X_REV_ID_REVISION_MASK;
+		break;
+
+	case REV_ID_MAJOR_AR9344:
+		ar71xx_soc = AR71XX_SOC_AR9344;
+		chip = "9344";
+		rev = id & AR934X_REV_ID_REVISION_MASK;
+		break;
+
 	default:
 		panic("ar71xx: unknown chip id:0x%08x\n", id);
 	}
 
+	ar71xx_soc_rev = rev;
+
 	sprintf(ar71xx_sys_type, "Atheros AR%s rev %u", chip, rev);
+	pr_info("SoC: %s\n", ar71xx_sys_type);
+}
+
+static void __init ar934x_detect_sys_frequency(void)
+{
+	u32 pll, out_div, ref_div, nint, frac, clk_ctrl, postdiv;
+	u32 cpu_pll, ddr_pll;
+	u32 bootstrap;
+
+	bootstrap = ar71xx_reset_rr(AR934X_RESET_REG_BOOTSTRAP);
+	if (bootstrap &	AR934X_BOOTSTRAP_REF_CLK_40)
+		ar71xx_ref_freq = 40 * 1000 * 1000;
+	else
+		ar71xx_ref_freq = 25 * 1000 * 1000;
+
+	pll = ar71xx_pll_rr(AR934X_PLL_REG_CPU_CONFIG);
+	out_div	= AR934X_CPU_PLL_CFG_OUTDIV_GET(pll);
+	ref_div	= AR934X_CPU_PLL_CFG_REFDIV_GET(pll);
+	nint	= AR934X_CPU_PLL_CFG_NINT_GET(pll);
+	frac	= AR934X_CPU_PLL_CFG_NFRAC_GET(pll);
+
+	cpu_pll = nint * ar71xx_ref_freq / ref_div;
+	cpu_pll += frac * ar71xx_ref_freq / (ref_div * (2 << 6));
+	cpu_pll /= (1 << out_div);
+
+	pll = ar71xx_pll_rr(AR934X_PLL_REG_DDR_CONFIG);
+	out_div	= AR934X_DDR_PLL_CFG_OUTDIV_GET(pll);
+	ref_div	= AR934X_DDR_PLL_CFG_REFDIV_GET(pll);
+	nint	= AR934X_DDR_PLL_CFG_NINT_GET(pll);
+	frac	= AR934X_DDR_PLL_CFG_NFRAC_GET(pll);
+
+	ddr_pll = nint * ar71xx_ref_freq / ref_div;
+	ddr_pll += frac * ar71xx_ref_freq / (ref_div * (2 << 10));
+	ddr_pll /= (1 << out_div);
+
+	clk_ctrl = ar71xx_pll_rr(AR934X_PLL_REG_DDR_CTRL_CLOCK);
+
+	if (clk_ctrl & AR934X_CPU_DDR_CLK_CTRL_CPU_PLL_BYPASS) {
+		ar71xx_cpu_freq = ar71xx_ref_freq;
+	} else {
+		postdiv = AR934X_CPU_DDR_CLK_CTRL_CPU_POST_DIV_GET(clk_ctrl);
+
+		if (clk_ctrl & AR934X_CPU_DDR_CLK_CTRL_CPUCLK_FROM_CPUPLL)
+			ar71xx_cpu_freq = cpu_pll / (postdiv + 1);
+		else
+			ar71xx_cpu_freq = ddr_pll / (postdiv + 1);
+	}
+
+	if (clk_ctrl & AR934X_CPU_DDR_CLK_CTRL_DDR_PLL_BYPASS) {
+		ar71xx_ddr_freq = ar71xx_ref_freq;
+	} else {
+		postdiv = AR934X_CPU_DDR_CLK_CTRL_DDR_POST_DIV_GET(clk_ctrl);
+
+		if (clk_ctrl & AR934X_CPU_DDR_CLK_CTRL_DDRCLK_FROM_DDRPLL)
+			ar71xx_ddr_freq = ddr_pll / (postdiv + 1);
+		else
+			ar71xx_ddr_freq = cpu_pll / (postdiv + 1);
+	}
+
+	if (clk_ctrl & AR934X_CPU_DDR_CLK_CTRL_AHB_PLL_BYPASS) {
+		ar71xx_ahb_freq = ar71xx_ref_freq;
+	} else {
+		postdiv = AR934X_CPU_DDR_CLK_CTRL_AHB_POST_DIV_GET(clk_ctrl);
+
+		if (clk_ctrl & AR934X_CPU_DDR_CLK_CTRL_AHBCLK_FROM_DDRPLL)
+			ar71xx_ahb_freq = ddr_pll / (postdiv + 1);
+		else
+			ar71xx_ahb_freq = cpu_pll / (postdiv + 1);
+	}
 }
 
 static void __init ar91xx_detect_sys_frequency(void)
@@ -154,10 +254,12 @@ static void __init ar91xx_detect_sys_frequency(void)
 	u32 freq;
 	u32 div;
 
+	ar71xx_ref_freq = 5 * 1000 * 1000;
+
 	pll = ar71xx_pll_rr(AR91XX_PLL_REG_CPU_CONFIG);
 
 	div = ((pll >> AR91XX_PLL_DIV_SHIFT) & AR91XX_PLL_DIV_MASK);
-	freq = div * AR91XX_BASE_FREQ;
+	freq = div * ar71xx_ref_freq;
 
 	ar71xx_cpu_freq = freq;
 
@@ -174,10 +276,12 @@ static void __init ar71xx_detect_sys_frequency(void)
 	u32 freq;
 	u32 div;
 
+	ar71xx_ref_freq = 40 * 1000 * 1000;
+
 	pll = ar71xx_pll_rr(AR71XX_PLL_REG_CPU_CONFIG);
 
 	div = ((pll >> AR71XX_PLL_DIV_SHIFT) & AR71XX_PLL_DIV_MASK) + 1;
-	freq = div * AR71XX_BASE_FREQ;
+	freq = div * ar71xx_ref_freq;
 
 	div = ((pll >> AR71XX_CPU_DIV_SHIFT) & AR71XX_CPU_DIV_MASK) + 1;
 	ar71xx_cpu_freq = freq / div;
@@ -195,10 +299,12 @@ static void __init ar724x_detect_sys_frequency(void)
 	u32 freq;
 	u32 div;
 
+	ar71xx_ref_freq = 5 * 1000 * 1000;
+
 	pll = ar71xx_pll_rr(AR724X_PLL_REG_CPU_CONFIG);
 
 	div = ((pll >> AR724X_PLL_DIV_SHIFT) & AR724X_PLL_DIV_MASK);
-	freq = div * AR724X_BASE_FREQ;
+	freq = div * ar71xx_ref_freq;
 
 	div = ((pll >> AR724X_PLL_REF_DIV_SHIFT) & AR724X_PLL_REF_DIV_MASK);
 	freq *= div;
@@ -212,6 +318,56 @@ static void __init ar724x_detect_sys_frequency(void)
 	ar71xx_ahb_freq = ar71xx_cpu_freq / div;
 }
 
+static void __init ar933x_detect_sys_frequency(void)
+{
+	u32 clock_ctrl;
+	u32 cpu_config;
+	u32 freq;
+	u32 t;
+
+	t = ar71xx_reset_rr(AR933X_RESET_REG_BOOTSTRAP);
+	if (t & AR933X_BOOTSTRAP_REF_CLK_40)
+		ar71xx_ref_freq = (40 * 1000 * 1000);
+	else
+		ar71xx_ref_freq = (25 * 1000 * 1000);
+
+	clock_ctrl = ar71xx_pll_rr(AR933X_PLL_CLOCK_CTRL_REG);
+	if (clock_ctrl & AR933X_PLL_CLOCK_CTRL_BYPASS) {
+		ar71xx_cpu_freq = ar71xx_ref_freq;
+		ar71xx_ahb_freq = ar71xx_ref_freq;
+		ar71xx_ddr_freq = ar71xx_ref_freq;
+	} else {
+		cpu_config = ar71xx_pll_rr(AR933X_PLL_CPU_CONFIG_REG);
+
+		t = (cpu_config >> AR933X_PLL_CPU_CONFIG_REFDIV_SHIFT) &
+		    AR933X_PLL_CPU_CONFIG_REFDIV_MASK;
+		freq = ar71xx_ref_freq / t;
+
+		t = (cpu_config >> AR933X_PLL_CPU_CONFIG_NINT_SHIFT) &
+		    AR933X_PLL_CPU_CONFIG_NINT_MASK;
+		freq *= t;
+
+		t = (cpu_config >> AR933X_PLL_CPU_CONFIG_OUTDIV_SHIFT) &
+		    AR933X_PLL_CPU_CONFIG_OUTDIV_MASK;
+		if (t == 0)
+			t = 1;
+
+		freq >>= t;
+
+		t = ((clock_ctrl >> AR933X_PLL_CLOCK_CTRL_CPU_DIV_SHIFT) &
+		     AR933X_PLL_CLOCK_CTRL_CPU_DIV_MASK) + 1;
+		ar71xx_cpu_freq = freq / t;
+
+		t = ((clock_ctrl >> AR933X_PLL_CLOCK_CTRL_DDR_DIV_SHIFT) &
+		      AR933X_PLL_CLOCK_CTRL_DDR_DIV_MASK) + 1;
+		ar71xx_ddr_freq = freq / t;
+
+		t = ((clock_ctrl >> AR933X_PLL_CLOCK_CTRL_AHB_DIV_SHIFT) &
+		     AR933X_PLL_CLOCK_CTRL_AHB_DIV_MASK) + 1;
+		ar71xx_ahb_freq = freq / t;
+	}
+}
+
 static void __init detect_sys_frequency(void)
 {
 	switch (ar71xx_soc) {
@@ -232,6 +388,16 @@ static void __init detect_sys_frequency(void)
 		ar91xx_detect_sys_frequency();
 		break;
 
+	case AR71XX_SOC_AR9330:
+	case AR71XX_SOC_AR9331:
+		ar933x_detect_sys_frequency();
+		break;
+
+	case AR71XX_SOC_AR9341:
+	case AR71XX_SOC_AR9342:
+	case AR71XX_SOC_AR9344:
+		ar934x_detect_sys_frequency();
+		break;
 	default:
 		BUG();
 	}
@@ -269,12 +435,12 @@ void __init plat_mem_setup(void)
 	ar71xx_detect_sys_type();
 	detect_sys_frequency();
 
-	printk(KERN_INFO
-		"%s, CPU:%u.%03u MHz, AHB:%u.%03u MHz, DDR:%u.%03u MHz\n",
-		ar71xx_sys_type,
+	pr_info("Clocks: CPU:%u.%03uMHz, DDR:%u.%03uMHz, AHB:%u.%03uMHz, "
+		"Ref:%u.%03uMHz",
 		ar71xx_cpu_freq / 1000000, (ar71xx_cpu_freq / 1000) % 1000,
+		ar71xx_ddr_freq / 1000000, (ar71xx_ddr_freq / 1000) % 1000,
 		ar71xx_ahb_freq / 1000000, (ar71xx_ahb_freq / 1000) % 1000,
-		ar71xx_ddr_freq / 1000000, (ar71xx_ddr_freq / 1000) % 1000);
+		ar71xx_ref_freq / 1000000, (ar71xx_ref_freq / 1000) % 1000);
 
 	_machine_restart = ar71xx_restart;
 	_machine_halt = ar71xx_halt;
diff --git a/arch/mips/include/asm/mach-ar71xx/ar71xx.h b/arch/mips/include/asm/mach-ar71xx/ar71xx.h
index c6a5a40..d9c5e87f 100644
--- a/arch/mips/include/asm/mach-ar71xx/ar71xx.h
+++ b/arch/mips/include/asm/mach-ar71xx/ar71xx.h
@@ -1,10 +1,12 @@
 /*
  *  Atheros AR71xx SoC specific definitions
  *
+ *  Copyright (C) 2010-2011 Jaiganesh Narayanan <jnarayanan@atheros.com>
  *  Copyright (C) 2008-2009 Gabor Juhos <juhosg@openwrt.org>
  *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
  *
- *  Parts of this file are based on Atheros' 2.6.15 BSP
+ *  Parts of this file are based on Atheros 2.6.15 BSP
+ *  Parts of this file are based on Atheros 2.6.31 BSP
  *
  *  This program is free software; you can redistribute it and/or modify it
  *  under the terms of the GNU General Public License version 2 as published
@@ -68,16 +70,28 @@
 #define AR91XX_WMAC_BASE	(AR71XX_APB_BASE + 0x000C0000)
 #define AR91XX_WMAC_SIZE	0x30000
 
+#define AR933X_UART_BASE	(AR71XX_APB_BASE + 0x00020000)
+#define AR933X_UART_SIZE	0x14
+#define AR933X_GMAC_BASE	(AR71XX_APB_BASE + 0x00070000)
+#define AR933X_GMAC_SIZE	0x04
+#define AR933X_WMAC_BASE	(AR71XX_APB_BASE + 0x00100000)
+#define AR933X_WMAC_SIZE	0x20000
+
+#define AR934X_WMAC_BASE	(AR71XX_APB_BASE + 0x00100000)
+#define AR934X_WMAC_SIZE	0x20000
+
 #define AR71XX_MEM_SIZE_MIN	0x0200000
 #define AR71XX_MEM_SIZE_MAX	0x10000000
 
 #define AR71XX_CPU_IRQ_BASE	0
 #define AR71XX_MISC_IRQ_BASE	8
-#define AR71XX_MISC_IRQ_COUNT	8
-#define AR71XX_GPIO_IRQ_BASE	16
+#define AR71XX_MISC_IRQ_COUNT	32
+#define AR71XX_GPIO_IRQ_BASE	40
 #define AR71XX_GPIO_IRQ_COUNT	32
-#define AR71XX_PCI_IRQ_BASE     48
-#define AR71XX_PCI_IRQ_COUNT	8
+#define AR71XX_PCI_IRQ_BASE	72
+#define AR71XX_PCI_IRQ_COUNT	6
+#define AR934X_IP2_IRQ_BASE	78
+#define AR934X_IP2_IRQ_COUNT	2
 
 #define AR71XX_CPU_IRQ_IP2	(AR71XX_CPU_IRQ_BASE + 2)
 #define AR71XX_CPU_IRQ_USB	(AR71XX_CPU_IRQ_BASE + 3)
@@ -94,6 +108,11 @@
 #define AR71XX_MISC_IRQ_PERFC	(AR71XX_MISC_IRQ_BASE + 5)
 #define AR71XX_MISC_IRQ_OHCI	(AR71XX_MISC_IRQ_BASE + 6)
 #define AR71XX_MISC_IRQ_DMA	(AR71XX_MISC_IRQ_BASE + 7)
+#define AR71XX_MISC_IRQ_TIMER2	(AR71XX_MISC_IRQ_BASE + 8)
+#define AR71XX_MISC_IRQ_TIMER3	(AR71XX_MISC_IRQ_BASE + 9)
+#define AR71XX_MISC_IRQ_TIMER4	(AR71XX_MISC_IRQ_BASE + 10)
+#define AR71XX_MISC_IRQ_DDR_PERF	(AR71XX_MISC_IRQ_BASE + 11)
+#define AR71XX_MISC_IRQ_ENET_LINK	(AR71XX_MISC_IRQ_BASE + 12)
 
 #define AR71XX_GPIO_IRQ(_x)	(AR71XX_GPIO_IRQ_BASE + (_x))
 
@@ -102,9 +121,13 @@
 #define AR71XX_PCI_IRQ_DEV2	(AR71XX_PCI_IRQ_BASE + 2)
 #define AR71XX_PCI_IRQ_CORE	(AR71XX_PCI_IRQ_BASE + 4)
 
+#define AR934X_IP2_IRQ_WMAC	(AR934X_IP2_IRQ_BASE + 0)
+#define AR934X_IP2_IRQ_PCIE	(AR934X_IP2_IRQ_BASE + 1)
+
 extern u32 ar71xx_ahb_freq;
 extern u32 ar71xx_cpu_freq;
 extern u32 ar71xx_ddr_freq;
+extern u32 ar71xx_ref_freq;
 
 enum ar71xx_soc_type {
 	AR71XX_SOC_UNKNOWN,
@@ -115,8 +138,14 @@ enum ar71xx_soc_type {
 	AR71XX_SOC_AR7241,
 	AR71XX_SOC_AR7242,
 	AR71XX_SOC_AR9130,
-	AR71XX_SOC_AR9132
+	AR71XX_SOC_AR9132,
+	AR71XX_SOC_AR9330,
+	AR71XX_SOC_AR9331,
+	AR71XX_SOC_AR9341,
+	AR71XX_SOC_AR9342,
+	AR71XX_SOC_AR9344,
 };
+extern u32 ar71xx_soc_rev;
 
 extern enum ar71xx_soc_type ar71xx_soc;
 
@@ -152,6 +181,8 @@ extern enum ar71xx_soc_type ar71xx_soc;
 #define AR724X_DDR_DIV_SHIFT		22
 #define AR724X_DDR_DIV_MASK		0x3
 
+#define AR7242_PLL_REG_ETH0_INT_CLOCK	0x2c
+
 #define AR91XX_PLL_REG_CPU_CONFIG	0x00
 #define AR91XX_PLL_REG_ETH_CONFIG	0x04
 #define AR91XX_PLL_REG_ETH0_INT_CLOCK	0x14
@@ -167,6 +198,193 @@ extern enum ar71xx_soc_type ar71xx_soc;
 #define AR91XX_ETH0_PLL_SHIFT		20
 #define AR91XX_ETH1_PLL_SHIFT		22
 
+#define AR933X_PLL_CPU_CONFIG_REG	0x00
+#define AR933X_PLL_CLOCK_CTRL_REG	0x08
+
+#define AR933X_PLL_CPU_CONFIG_NINT_SHIFT	10
+#define AR933X_PLL_CPU_CONFIG_NINT_MASK		0x3f
+#define AR933X_PLL_CPU_CONFIG_REFDIV_SHIFT	16
+#define AR933X_PLL_CPU_CONFIG_REFDIV_MASK	0x1f
+#define AR933X_PLL_CPU_CONFIG_OUTDIV_SHIFT	23
+#define AR933X_PLL_CPU_CONFIG_OUTDIV_MASK	0x7
+
+#define AR933X_PLL_CLOCK_CTRL_BYPASS		BIT(2)
+#define AR933X_PLL_CLOCK_CTRL_CPU_DIV_SHIFT	5
+#define AR933X_PLL_CLOCK_CTRL_CPU_DIV_MASK	0x3
+#define AR933X_PLL_CLOCK_CTRL_DDR_DIV_SHIFT	10
+#define AR933X_PLL_CLOCK_CTRL_DDR_DIV_MASK	0x3
+#define AR933X_PLL_CLOCK_CTRL_AHB_DIV_SHIFT	15
+#define AR933X_PLL_CLOCK_CTRL_AHB_DIV_MASK	0x7
+
+#define AR934X_PLL_REG_CPU_CONFIG	0x00
+#define AR934X_PLL_REG_DDR_CONFIG	0x04
+#define AR934X_PLL_REG_DDR_CTRL_CLOCK	0x8
+
+#define AR934X_CPU_PLL_CFG_OUTDIV_MSB	21
+#define AR934X_CPU_PLL_CFG_OUTDIV_LSB	19
+#define AR934X_CPU_PLL_CFG_OUTDIV_MASK	0x00380000
+
+#define AR934X_CPU_PLL_CFG_OUTDIV_GET(x)		\
+	(((x) & AR934X_CPU_PLL_CFG_OUTDIV_MASK) >>	\
+	AR934X_CPU_PLL_CFG_OUTDIV_LSB)
+
+#define AR934X_DDR_PLL_CFG_OUTDIV_MSB	25
+#define AR934X_DDR_PLL_CFG_OUTDIV_LSB	23
+#define AR934X_DDR_PLL_CFG_OUTDIV_MASK	0x03800000
+
+#define AR934X_DDR_PLL_CFG_OUTDIV_GET(x) 		\
+	(((x) & AR934X_DDR_PLL_CFG_OUTDIV_MASK) >> 	\
+	AR934X_DDR_PLL_CFG_OUTDIV_LSB)
+
+#define AR934X_DDR_PLL_CFG_OUTDIV_SET(x) 		\
+	(((x) << AR934X_DDR_PLL_CFG_OUTDIV_LSB) & 	\
+	AR934X_DDR_PLL_CFG_OUTDIV_MASK)
+
+#define AR934X_CPU_PLL_CFG_REFDIV_MSB	16
+#define AR934X_CPU_PLL_CFG_REFDIV_LSB	12
+#define AR934X_CPU_PLL_CFG_REFDIV_MASK	0x0001f000
+
+#define AR934X_CPU_PLL_CFG_REFDIV_GET(x) 		\
+	(((x) & AR934X_CPU_PLL_CFG_REFDIV_MASK) >> 	\
+	AR934X_CPU_PLL_CFG_REFDIV_LSB)
+
+#define AR934X_CPU_PLL_CFG_REFDIV_SET(x) 		\
+	(((x) << AR934X_CPU_PLL_CFG_REFDIV_LSB) & 	\
+	AR934X_CPU_PLL_CFG_REFDIV_MASK)
+
+#define AR934X_CPU_PLL_CFG_REFDIV_RESET	2
+
+#define AR934X_CPU_PLL_CFG_NINT_MSB	11
+#define AR934X_CPU_PLL_CFG_NINT_LSB	6
+#define AR934X_CPU_PLL_CFG_NINT_MASK	0x00000fc0
+
+#define AR934X_CPU_PLL_CFG_NINT_GET(x)			\
+	(((x) & AR934X_CPU_PLL_CFG_NINT_MASK) >> 	\
+	AR934X_CPU_PLL_CFG_NINT_LSB)
+
+#define AR934X_CPU_PLL_CFG_NINT_SET(x)			\
+	(((x) << AR934X_CPU_PLL_CFG_NINT_LSB) & 	\
+	AR934X_CPU_PLL_CFG_NINT_MASK)
+
+#define AR934X_CPU_PLL_CFG_NINT_RESET	20
+
+#define AR934X_CPU_PLL_CFG_NFRAC_MSB	5
+#define AR934X_CPU_PLL_CFG_NFRAC_LSB	0
+#define AR934X_CPU_PLL_CFG_NFRAC_MASK	0x0000003f
+
+#define AR934X_CPU_PLL_CFG_NFRAC_GET(x)		\
+	(((x) & AR934X_CPU_PLL_CFG_NFRAC_MASK) >> 	\
+	AR934X_CPU_PLL_CFG_NFRAC_LSB)
+
+#define AR934X_CPU_PLL_CFG_NFRAC_SET(x)		\
+	(((x) << AR934X_CPU_PLL_CFG_NFRAC_LSB) & 	\
+	AR934X_CPU_PLL_CFG_NFRAC_MASK)
+
+#define AR934X_DDR_PLL_CFG_REFDIV_MSB	20
+#define AR934X_DDR_PLL_CFG_REFDIV_LSB	16
+#define AR934X_DDR_PLL_CFG_REFDIV_MASK	0x001f0000
+
+#define AR934X_DDR_PLL_CFG_REFDIV_GET(x) 		\
+	(((x) & AR934X_DDR_PLL_CFG_REFDIV_MASK) >> 	\
+	AR934X_DDR_PLL_CFG_REFDIV_LSB)
+
+#define AR934X_DDR_PLL_CFG_REFDIV_SET(x) 		\
+	(((x) << AR934X_DDR_PLL_CFG_REFDIV_LSB) &	\
+	AR934X_DDR_PLL_CFG_REFDIV_MASK)
+
+#define AR934X_DDR_PLL_CFG_REFDIV_RESET	2
+
+#define AR934X_DDR_PLL_CFG_NINT_MSB	15
+#define AR934X_DDR_PLL_CFG_NINT_LSB	10
+#define AR934X_DDR_PLL_CFG_NINT_MASK	0x0000fc00
+
+#define AR934X_DDR_PLL_CFG_NINT_GET(x)			\
+	(((x) & AR934X_DDR_PLL_CFG_NINT_MASK) >> 	\
+	AR934X_DDR_PLL_CFG_NINT_LSB)
+
+#define AR934X_DDR_PLL_CFG_NINT_SET(x)			\
+	(((x) << AR934X_DDR_PLL_CFG_NINT_LSB) &		\
+	AR934X_DDR_PLL_CFG_NINT_MASK)
+
+#define AR934X_DDR_PLL_CFG_NINT_RESET	20
+
+#define AR934X_DDR_PLL_CFG_NFRAC_MSB	9
+#define AR934X_DDR_PLL_CFG_NFRAC_LSB	0
+#define AR934X_DDR_PLL_CFG_NFRAC_MASK	0x000003ff
+
+#define AR934X_DDR_PLL_CFG_NFRAC_GET(x)		\
+	(((x) & AR934X_DDR_PLL_CFG_NFRAC_MASK) >> 	\
+	AR934X_DDR_PLL_CFG_NFRAC_LSB)
+
+#define AR934X_DDR_PLL_CFG_NFRAC_SET(x)		\
+	(((x) << AR934X_DDR_PLL_CFG_NFRAC_LSB) & 	\
+	AR934X_DDR_PLL_CFG_NFRAC_MASK)
+
+#define AR934X_DDR_PLL_CFG_NFRAC_RESET	512
+
+#define AR934X_CPU_DDR_CLK_CTRL_AHB_POST_DIV_MSB	19
+#define AR934X_CPU_DDR_CLK_CTRL_AHB_POST_DIV_LSB	15
+#define AR934X_CPU_DDR_CLK_CTRL_AHB_POST_DIV_MASK	0x000f8000
+
+#define AR934X_CPU_DDR_CLK_CTRL_AHB_POST_DIV_GET(x)		\
+	(((x) & AR934X_CPU_DDR_CLK_CTRL_AHB_POST_DIV_MASK) >>	\
+	AR934X_CPU_DDR_CLK_CTRL_AHB_POST_DIV_LSB)
+
+#define AR934X_CPU_DDR_CLK_CTRL_AHB_POST_DIV_SET(x)		\
+	(((x) << AR934X_CPU_DDR_CLK_CTRL_AHB_POST_DIV_LSB) & 	\
+	AR934X_CPU_DDR_CLK_CTRL_AHB_POST_DIV_MASK)
+
+#define AR934X_CPU_DDR_CLK_CTRL_AHB_POST_DIV_RESET		0
+
+#define AR934X_CPU_DDR_CLK_CTRL_DDR_POST_DIV_MSB	14
+#define AR934X_CPU_DDR_CLK_CTRL_DDR_POST_DIV_LSB	10
+#define AR934X_CPU_DDR_CLK_CTRL_DDR_POST_DIV_MASK	0x00007c00
+
+#define AR934X_CPU_DDR_CLK_CTRL_DDR_POST_DIV_GET(x)		\
+	(((x) & AR934X_CPU_DDR_CLK_CTRL_DDR_POST_DIV_MASK) >> 	\
+	AR934X_CPU_DDR_CLK_CTRL_DDR_POST_DIV_LSB)
+
+#define AR934X_CPU_DDR_CLK_CTRL_DDR_POST_DIV_SET(x)		\
+	(((x) << AR934X_CPU_DDR_CLK_CTRL_DDR_POST_DIV_LSB) & 	\
+	AR934X_CPU_DDR_CLK_CTRL_DDR_POST_DIV_MASK)
+
+#define AR934X_CPU_DDR_CLK_CTRL_DDR_POST_DIV_RESET 	0
+
+#define AR934X_CPU_DDR_CLK_CTRL_CPU_POST_DIV_MSB	9
+#define AR934X_CPU_DDR_CLK_CTRL_CPU_POST_DIV_LSB	5
+#define AR934X_CPU_DDR_CLK_CTRL_CPU_POST_DIV_MASK	0x000003e0
+
+#define AR934X_CPU_DDR_CLK_CTRL_CPU_POST_DIV_GET(x)		\
+	(((x) & AR934X_CPU_DDR_CLK_CTRL_CPU_POST_DIV_MASK) >> 	\
+	AR934X_CPU_DDR_CLK_CTRL_CPU_POST_DIV_LSB)
+
+#define AR934X_CPU_DDR_CLK_CTRL_CPU_POST_DIV_SET(x)		\
+	(((x) << AR934X_CPU_DDR_CLK_CTRL_CPU_POST_DIV_LSB) & 	\
+	AR934X_CPU_DDR_CLK_CTRL_CPU_POST_DIV_MASK)
+
+#define AR934X_CPU_DDR_CLK_CTRL_CPU_POST_DIV_RESET	0
+
+#define AR934X_CPU_DDR_CLK_CTRL_AHBCLK_FROM_DDRPLL_MSB	24
+#define AR934X_CPU_DDR_CLK_CTRL_AHBCLK_FROM_DDRPLL_LSB	24
+#define AR934X_CPU_DDR_CLK_CTRL_AHBCLK_FROM_DDRPLL_MASK	0x01000000
+
+#define AR934X_CPU_DDR_CLK_CTRL_AHBCLK_FROM_DDRPLL_GET(x) 	\
+	(((x) & AR934X_CPU_DDR_CLK_CTRL_AHBCLK_FROM_DDRPLL_MASK) >> \
+	AR934X_CPU_DDR_CLK_CTRL_AHBCLK_FROM_DDRPLL_LSB)
+
+#define AR934X_CPU_DDR_CLK_CTRL_AHBCLK_FROM_DDRPLL_SET(x) 	\
+	(((x) << AR934X_CPU_DDR_CLK_CTRL_AHBCLK_FROM_DDRPLL_LSB) & \
+	AR934X_CPU_DDR_CLK_CTRL_AHBCLK_FROM_DDRPLL_MASK)
+
+#define AR934X_CPU_DDR_CLK_CTRL_AHBCLK_FROM_DDRPLL_RESET	1
+
+#define AR934X_CPU_DDR_CLK_CTRL_CPU_PLL_BYPASS		BIT(2)
+#define AR934X_CPU_DDR_CLK_CTRL_DDR_PLL_BYPASS		BIT(3)
+#define AR934X_CPU_DDR_CLK_CTRL_AHB_PLL_BYPASS		BIT(4)
+#define AR934X_CPU_DDR_CLK_CTRL_CPUCLK_FROM_CPUPLL	BIT(20)
+#define AR934X_CPU_DDR_CLK_CTRL_DDRCLK_FROM_DDRPLL	BIT(21)
+#define AR934X_CPU_DDR_CLK_CTRL_AHBCLK_FROM_DDRPLL	BIT(24)
+
 extern void __iomem *ar71xx_pll_base;
 
 static inline void ar71xx_pll_wr(unsigned reg, u32 val)
@@ -200,17 +418,25 @@ static inline u32 ar71xx_usb_ctrl_rr(unsigned reg)
 /*
  * GPIO block
  */
-#define GPIO_REG_OE		0x00
-#define GPIO_REG_IN		0x04
-#define GPIO_REG_OUT		0x08
-#define GPIO_REG_SET		0x0c
-#define GPIO_REG_CLEAR		0x10
-#define GPIO_REG_INT_MODE	0x14
-#define GPIO_REG_INT_TYPE	0x18
-#define GPIO_REG_INT_POLARITY	0x1c
-#define GPIO_REG_INT_PENDING	0x20
-#define GPIO_REG_INT_ENABLE	0x24
-#define GPIO_REG_FUNC		0x28
+#define AR71XX_GPIO_REG_OE		0x00
+#define AR71XX_GPIO_REG_IN		0x04
+#define AR71XX_GPIO_REG_OUT		0x08
+#define AR71XX_GPIO_REG_SET		0x0c
+#define AR71XX_GPIO_REG_CLEAR		0x10
+#define AR71XX_GPIO_REG_INT_MODE	0x14
+#define AR71XX_GPIO_REG_INT_TYPE	0x18
+#define AR71XX_GPIO_REG_INT_POLARITY	0x1c
+#define AR71XX_GPIO_REG_INT_PENDING	0x20
+#define AR71XX_GPIO_REG_INT_ENABLE	0x24
+#define AR71XX_GPIO_REG_FUNC		0x28
+
+#define AR934X_GPIO_REG_OUT_FUNC0	0x2c
+#define AR934X_GPIO_REG_OUT_FUNC1	0x30
+#define AR934X_GPIO_REG_OUT_FUNC2	0x34
+#define AR934X_GPIO_REG_OUT_FUNC3	0x38
+#define AR934X_GPIO_REG_OUT_FUNC4	0x3c
+#define AR934X_GPIO_REG_OUT_FUNC5	0x40
+#define AR934X_GPIO_REG_FUNC		0x6c
 
 #define AR71XX_GPIO_FUNC_STEREO_EN	BIT(17)
 #define AR71XX_GPIO_FUNC_SLIC_EN	BIT(16)
@@ -255,6 +481,16 @@ static inline u32 ar71xx_usb_ctrl_rr(unsigned reg)
 
 #define AR91XX_GPIO_COUNT	22
 
+#define AR933X_GPIO_COUNT	30
+
+#define AR934X_GPIO_FUNC_SPI_CS_1_EN	BIT(14)
+#define AR934X_GPIO_FUNC_SPI_CS_0_EN	BIT(13)
+
+#define AR934X_GPIO_COUNT		23
+#define AR934X_GPIO_FUNC_DDR_DQOE_EN	BIT(17)
+
+#define AR934X_GPIO_OUT_GPIO		0x00
+
 extern void __iomem *ar71xx_gpio_base;
 
 static inline void ar71xx_gpio_wr(unsigned reg, u32 value)
@@ -271,6 +507,7 @@ void ar71xx_gpio_init(void) __init;
 void ar71xx_gpio_function_enable(u32 mask);
 void ar71xx_gpio_function_disable(u32 mask);
 void ar71xx_gpio_function_setup(u32 set, u32 clear);
+void ar71xx_gpio_output_select(unsigned gpio, u8 val);
 
 /*
  * DDR_CTRL block
@@ -298,6 +535,18 @@ void ar71xx_gpio_function_setup(u32 set, u32 clear);
 #define AR91XX_DDR_REG_FLUSH_USB	0x84
 #define AR91XX_DDR_REG_FLUSH_WMAC	0x88
 
+#define AR933X_DDR_REG_FLUSH_GE0	0x7c
+#define AR933X_DDR_REG_FLUSH_GE1	0x80
+#define AR933X_DDR_REG_FLUSH_USB	0x84
+#define AR933X_DDR_REG_FLUSH_WMAC	0x88
+
+#define AR934X_DDR_REG_FLUSH_GE0	0x9c
+#define AR934X_DDR_REG_FLUSH_GE1	0xa0
+#define AR934X_DDR_REG_FLUSH_USB	0xa4
+#define AR934X_DDR_REG_FLUSH_PCIE	0xa8
+#define AR934X_DDR_REG_FLUSH_WMAC	0xac
+
+
 #define PCI_WIN0_OFFS	0x10000000
 #define PCI_WIN1_OFFS	0x11000000
 #define PCI_WIN2_OFFS	0x12000000
@@ -385,6 +634,49 @@ void ar71xx_ddr_flush(u32 reg);
 
 #define AR724X_RESET_REG_RESET_MODULE		0x1c
 
+#define AR933X_RESET_REG_RESET_MODULE		0x1c
+#define AR933X_RESET_REG_BOOTSTRAP		0xac
+#define AR933X_BOOTSTRAP_EEPBUSY		BIT(4)
+#define AR933X_BOOTSTRAP_REF_CLK_40		BIT(0)
+
+#define AR934X_RESET_REG_RESET_MODULE		0x1c
+
+#define AR934X_RESET_REG_PCIE_WMAC_INT_STATUS	0xac
+#define AR934X_PCIE_WMAC_INT_WMAC_MISC		BIT(0)
+#define AR934X_PCIE_WMAC_INT_WMAC_TX		BIT(1)
+#define AR934X_PCIE_WMAC_INT_WMAC_RXLP		BIT(2)
+#define AR934X_PCIE_WMAC_INT_WMAC_RXHP		BIT(3)
+#define AR934X_PCIE_WMAC_INT_PCIE_RC		BIT(4)
+#define AR934X_PCIE_WMAC_INT_PCIE_RC0		BIT(5)
+#define AR934X_PCIE_WMAC_INT_PCIE_RC1		BIT(6)
+#define AR934X_PCIE_WMAC_INT_PCIE_RC2		BIT(7)
+#define AR934X_PCIE_WMAC_INT_PCIE_RC3		BIT(8)
+#define AR934X_PCIE_WMAC_INT_WMAC_ALL \
+	(AR934X_PCIE_WMAC_INT_WMAC_MISC | AR934X_PCIE_WMAC_INT_WMAC_TX | \
+	 AR934X_PCIE_WMAC_INT_WMAC_RXLP | AR934X_PCIE_WMAC_INT_WMAC_RXHP)
+
+#define AR934X_PCIE_WMAC_INT_PCIE_ALL \
+	(AR934X_PCIE_WMAC_INT_PCIE_RC | AR934X_PCIE_WMAC_INT_PCIE_RC0 | \
+	 AR934X_PCIE_WMAC_INT_PCIE_RC1 | AR934X_PCIE_WMAC_INT_PCIE_RC2 | \
+	 AR934X_PCIE_WMAC_INT_PCIE_RC3)
+
+#define AR934X_RESET_REG_BOOTSTRAP		0xb0
+#define AR934X_BOOTSTRAP_SW_OPTION8		BIT(23)
+#define AR934X_BOOTSTRAP_SW_OPTION7		BIT(22)
+#define AR934X_BOOTSTRAP_SW_OPTION6		BIT(21)
+#define AR934X_BOOTSTRAP_SW_OPTION5		BIT(20)
+#define AR934X_BOOTSTRAP_SW_OPTION4		BIT(19)
+#define AR934X_BOOTSTRAP_SW_OPTION3		BIT(18)
+#define AR934X_BOOTSTRAP_SW_OPTION2		BIT(17)
+#define AR934X_BOOTSTRAP_SW_OPTION1		BIT(16)
+#define AR934X_BOOTSTRAP_USB_MODE_DEVICE	BIT(7)
+#define AR934X_BOOTSTRAP_PCIE_RC		BIT(6)
+#define AR934X_BOOTSTRAP_EJTAG_MODE		BIT(5)
+#define AR934X_BOOTSTRAP_REF_CLK_40		BIT(4)
+#define AR934X_BOOTSTRAP_BOOT_FROM_SPI		BIT(2)
+#define AR934X_BOOTSTRAP_SDRAM_DISABLED		BIT(1)
+#define AR934X_BOOTSTRAP_DDR1			BIT(0)
+
 #define WDOG_CTRL_LAST_RESET		BIT(31)
 #define WDOG_CTRL_ACTION_MASK		3
 #define WDOG_CTRL_ACTION_NONE		0	/* no action */
@@ -392,6 +684,11 @@ void ar71xx_ddr_flush(u32 reg);
 #define WDOG_CTRL_ACTION_NMI		2	/* NMI */
 #define WDOG_CTRL_ACTION_FCR		3	/* full chip reset */
 
+#define MISC_INT_ENET_LINK		BIT(12)
+#define MISC_INT_DDR_PERF		BIT(11)
+#define MISC_INT_TIMER4		BIT(10)
+#define MISC_INT_TIMER3		BIT(9)
+#define MISC_INT_TIMER2		BIT(8)
 #define MISC_INT_DMA			BIT(7)
 #define MISC_INT_OHCI			BIT(6)
 #define MISC_INT_PERFC			BIT(5)
@@ -432,6 +729,51 @@ void ar71xx_ddr_flush(u32 reg);
 #define AR724X_RESET_PCIE_PHY_SERIAL	BIT(10)
 #define AR724X_RESET_PCIE_PHY		BIT(7)
 #define AR724X_RESET_PCIE		BIT(6)
+#define AR724X_RESET_USB_HOST		BIT(5)
+#define AR724X_RESET_USB_PHY		BIT(4)
+#define AR724X_RESET_USBSUS_OVERRIDE	BIT(3)
+
+#define AR933X_RESET_WMAC		BIT(11)
+#define AR933X_RESET_GE1_MDIO		BIT(23)
+#define AR933X_RESET_GE0_MDIO		BIT(22)
+#define AR933X_RESET_GE1_MAC		BIT(13)
+#define AR933X_RESET_GE0_MAC		BIT(9)
+#define AR933X_RESET_USB_HOST		BIT(5)
+#define AR933X_RESET_USB_PHY		BIT(4)
+#define AR933X_RESET_USBSUS_OVERRIDE	BIT(3)
+
+#define AR934X_RESET_HOST		BIT(31)
+#define AR934X_RESET_SLIC		BIT(30)
+#define AR934X_RESET_HDMA		BIT(29)
+#define AR934X_RESET_EXTERNAL		BIT(28)
+#define AR934X_RESET_RTC		BIT(27)
+#define AR934X_RESET_PCIE_EP_INT	BIT(26)
+#define AR934X_RESET_CHKSUM_ACC		BIT(25)
+#define AR934X_RESET_FULL_CHIP		BIT(24)
+#define AR934X_RESET_GE1_MDIO		BIT(23)
+#define AR934X_RESET_GE0_MDIO		BIT(22)
+#define AR934X_RESET_CPU_NMI		BIT(21)
+#define AR934X_RESET_CPU_COLD		BIT(20)
+#define AR934X_RESET_HOST_RESET_INT	BIT(19)
+#define AR934X_RESET_PCIE_EP		BIT(18)
+#define AR934X_RESET_UART1		BIT(17)
+#define AR934X_RESET_DDR		BIT(16)
+#define AR934X_RESET_USB_PHY_PLL_PWD_EXT BIT(15)
+#define AR934X_RESET_NANDF		BIT(14)
+#define AR934X_RESET_GE1_MAC		BIT(13)
+#define AR934X_RESET_ETH_SWITCH_ANALOG	BIT(12)
+#define AR934X_RESET_USB_PHY_ANALOG	BIT(11)
+#define AR934X_RESET_HOST_DMA_INT	BIT(10)
+#define AR934X_RESET_GE0_MAC		BIT(9)
+#define AR934X_RESET_ETH_SIWTCH		BIT(8)
+#define AR934X_RESET_PCIE_PHY		BIT(7)
+#define AR934X_RESET_PCIE		BIT(6)
+#define AR934X_RESET_USB_HOST		BIT(5)
+#define AR934X_RESET_USB_PHY		BIT(4)
+#define AR934X_RESET_USBSUS_OVERRIDE	BIT(3)
+#define AR934X_RESET_LUT		BIT(2)
+#define AR934X_RESET_MBOX		BIT(1)
+#define AR934X_RESET_I2S		BIT(0)
 
 #define REV_ID_MAJOR_MASK	0xfff0
 #define REV_ID_MAJOR_AR71XX	0x00a0
@@ -439,6 +781,11 @@ void ar71xx_ddr_flush(u32 reg);
 #define REV_ID_MAJOR_AR7240	0x00c0
 #define REV_ID_MAJOR_AR7241	0x0100
 #define REV_ID_MAJOR_AR7242	0x1100
+#define REV_ID_MAJOR_AR9330	0x0110
+#define REV_ID_MAJOR_AR9331	0x1110
+#define REV_ID_MAJOR_AR9341	0x0120
+#define REV_ID_MAJOR_AR9342	0x1120
+#define REV_ID_MAJOR_AR9344	0x2120
 
 #define AR71XX_REV_ID_MINOR_MASK	0x3
 #define AR71XX_REV_ID_MINOR_AR7130	0x0
@@ -455,6 +802,10 @@ void ar71xx_ddr_flush(u32 reg);
 
 #define AR724X_REV_ID_REVISION_MASK	0x3
 
+#define AR933X_REV_ID_REVISION_MASK	0xf
+
+#define AR934X_REV_ID_REVISION_MASK	0xf
+
 extern void __iomem *ar71xx_reset_base;
 
 static inline void ar71xx_reset_wr(unsigned reg, u32 val)
@@ -469,6 +820,7 @@ static inline u32 ar71xx_reset_rr(unsigned reg)
 
 void ar71xx_device_stop(u32 mask);
 void ar71xx_device_start(u32 mask);
+void ar71xx_device_reset_rmw(u32 clear, u32 set);
 int ar71xx_device_stopped(u32 mask);
 
 /*
@@ -501,6 +853,13 @@ void ar71xx_flash_release(void);
 #define MII_REG_MII0_CTRL	0x00
 #define MII_REG_MII1_CTRL	0x04
 
+#define MII_CTRL_IF_MASK	3
+#define MII_CTRL_SPEED_SHIFT	4
+#define MII_CTRL_SPEED_MASK	3
+#define MII_CTRL_SPEED_10	0
+#define MII_CTRL_SPEED_100	1
+#define MII_CTRL_SPEED_1000	2
+
 #define MII0_CTRL_IF_GMII	0
 #define MII0_CTRL_IF_MII	1
 #define MII0_CTRL_IF_RGMII	2
@@ -509,6 +868,23 @@ void ar71xx_flash_release(void);
 #define MII1_CTRL_IF_RGMII	0
 #define MII1_CTRL_IF_RMII	1
 
+/*
+ * AR933X GMAC
+ */
+#define AR933X_GMAC_REG_ETH_CFG		0x00
+
+#define AR933X_ETH_CFG_RGMII_GE0	BIT(0)
+#define AR933X_ETH_CFG_MII_GE0		BIT(1)
+#define AR933X_ETH_CFG_GMII_GE0		BIT(2)
+#define AR933X_ETH_CFG_MII_GE0_MASTER	BIT(3)
+#define AR933X_ETH_CFG_MII_GE0_SLAVE	BIT(4)
+#define AR933X_ETH_CFG_MII_GE0_ERR_EN	BIT(5)
+#define AR933X_ETH_CFG_SW_PHY_SWAP	BIT(7)
+#define AR933X_ETH_CFG_SW_PHY_ADDR_SWAP	BIT(8)
+#define AR933X_ETH_CFG_RMII_GE0		BIT(9)
+#define AR933X_ETH_CFG_RMII_GE0_SPD_10	0
+#define AR933X_ETH_CFG_RMII_GE0_SPD_100	BIT(10)
+
 #endif /* __ASSEMBLER__ */
 
 #endif /* __ASM_MACH_AR71XX_H */
diff --git a/arch/mips/include/asm/mach-ar71xx/ar933x_uart.h b/arch/mips/include/asm/mach-ar71xx/ar933x_uart.h
new file mode 100644
index 0000000..5273055
--- /dev/null
+++ b/arch/mips/include/asm/mach-ar71xx/ar933x_uart.h
@@ -0,0 +1,67 @@
+/*
+ *  Atheros AR933X UART defines
+ *
+ *  Copyright (C) 2011 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#ifndef __AR933X_UART_H
+#define __AR933X_UART_H
+
+#define AR933X_UART_REGS_SIZE		20
+#define AR933X_UART_FIFO_SIZE		16
+
+#define AR933X_UART_DATA_REG		0x00
+#define AR933X_UART_CS_REG		0x04
+#define AR933X_UART_CLOCK_REG		0x08
+#define AR933X_UART_INT_REG		0x0c
+#define AR933X_UART_INT_EN_REG		0x10
+
+#define AR933X_UART_DATA_TX_RX_MASK	0xff
+#define AR933X_UART_DATA_RX_CSR		BIT(8)
+#define AR933X_UART_DATA_TX_CSR		BIT(9)
+
+#define AR933X_UART_CS_PARITY_S		0
+#define AR933X_UART_CS_PARITY_M		0x3
+#define   AR933X_UART_CS_PARITY_NONE	0
+#define   AR933X_UART_CS_PARITY_ODD	1
+#define   AR933X_UART_CS_PARITY_EVEN	2
+#define AR933X_UART_CS_IF_MODE_S	2
+#define AR933X_UART_CS_IF_MODE_M	0x3
+#define   AR933X_UART_CS_IF_MODE_NONE	0
+#define   AR933X_UART_CS_IF_MODE_DTE	1
+#define   AR933X_UART_CS_IF_MODE_DCE	2
+#define AR933X_UART_CS_FLOW_CTRL_S	4
+#define AR933X_UART_CS_FLOW_CTRL_M	0x3
+#define AR933X_UART_CS_DMA_EN		BIT(6)
+#define AR933X_UART_CS_TX_READY_ORIDE	BIT(7)
+#define AR933X_UART_CS_RX_READY_ORIDE	BIT(8)
+#define AR933X_UART_CS_TX_READY		BIT(9)
+#define AR933X_UART_CS_RX_BREAK		BIT(10)
+#define AR933X_UART_CS_TX_BREAK		BIT(11)
+#define AR933X_UART_CS_HOST_INT		BIT(12)
+#define AR933X_UART_CS_HOST_INT_EN	BIT(13)
+#define AR933X_UART_CS_TX_BUSY		BIT(14)
+#define AR933X_UART_CS_RX_BUSY		BIT(15)
+
+#define AR933X_UART_CLOCK_STEP_M	0xffff
+#define AR933X_UART_CLOCK_SCALE_M	0xfff
+#define AR933X_UART_CLOCK_SCALE_S	16
+#define AR933X_UART_CLOCK_STEP_M	0xffff
+
+#define AR933X_UART_INT_RX_VALID	BIT(0)
+#define AR933X_UART_INT_TX_READY	BIT(1)
+#define AR933X_UART_INT_RX_FRAMING_ERR	BIT(2)
+#define AR933X_UART_INT_RX_OFLOW_ERR	BIT(3)
+#define AR933X_UART_INT_TX_OFLOW_ERR	BIT(4)
+#define AR933X_UART_INT_RX_PARITY_ERR	BIT(5)
+#define AR933X_UART_INT_RX_BREAK_ON	BIT(6)
+#define AR933X_UART_INT_RX_BREAK_OFF	BIT(7)
+#define AR933X_UART_INT_RX_FULL		BIT(8)
+#define AR933X_UART_INT_TX_EMPTY	BIT(9)
+#define AR933X_UART_INT_ALLINTS		0x3ff
+
+#endif /* __AR933X_UART_H */
diff --git a/arch/mips/include/asm/mach-ar71xx/ar933x_uart_platform.h b/arch/mips/include/asm/mach-ar71xx/ar933x_uart_platform.h
new file mode 100644
index 0000000..6cb30f2
--- /dev/null
+++ b/arch/mips/include/asm/mach-ar71xx/ar933x_uart_platform.h
@@ -0,0 +1,18 @@
+/*
+ *  Platform data definition for Atheros AR933X UART
+ *
+ *  Copyright (C) 2011 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#ifndef _AR933X_UART_PLATFORM_H
+#define _AR933X_UART_PLATFORM_H
+
+struct ar933x_uart_platform_data {
+	unsigned	uartclk;
+};
+
+#endif /* _AR933X_UART_PLATFORM_H */
diff --git a/arch/mips/include/asm/mach-ar71xx/irq.h b/arch/mips/include/asm/mach-ar71xx/irq.h
index 2197a10..c61d9c7 100644
--- a/arch/mips/include/asm/mach-ar71xx/irq.h
+++ b/arch/mips/include/asm/mach-ar71xx/irq.h
@@ -10,7 +10,7 @@
 #define __ASM_MACH_AR71XX_IRQ_H
 
 #define MIPS_CPU_IRQ_BASE	0
-#define NR_IRQS			56
+#define NR_IRQS			80
 
 #include_next <irq.h>
 
diff --git a/arch/mips/include/asm/mach-ar71xx/mangle-port.h b/arch/mips/include/asm/mach-ar71xx/mangle-port.h
index 126d5b3..ba41b38 100644
--- a/arch/mips/include/asm/mach-ar71xx/mangle-port.h
+++ b/arch/mips/include/asm/mach-ar71xx/mangle-port.h
@@ -3,7 +3,7 @@
  *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
  *
  *  This file was derived from: inlude/asm-mips/mach-generic/mangle-port.h
- * 	Copyright (C) 2003, 2004 Ralf Baechle
+ *      Copyright (C) 2003, 2004 Ralf Baechle
  *
  *  This program is free software; you can redistribute it and/or modify it
  *  under the terms of the GNU General Public License version 2 as published
diff --git a/arch/mips/include/asm/mach-ar71xx/pci.h b/arch/mips/include/asm/mach-ar71xx/pci.h
index c5352ce..2704349 100644
--- a/arch/mips/include/asm/mach-ar71xx/pci.h
+++ b/arch/mips/include/asm/mach-ar71xx/pci.h
@@ -20,6 +20,7 @@ struct ar71xx_pci_irq {
 	u8	pin;
 };
 
+#ifdef CONFIG_PCI
 extern int (*ar71xx_pci_plat_dev_init)(struct pci_dev *dev);
 extern unsigned ar71xx_pci_nr_irqs __initdata;
 extern struct ar71xx_pci_irq *ar71xx_pci_irq_map __initdata;
@@ -32,8 +33,14 @@ int ar71xx_pci_be_handler(int is_fixup);
 
 int ar724x_pcibios_map_irq(const struct pci_dev *dev,
 			   uint8_t slot, uint8_t pin) __init;
-int ar724x_pcibios_init(void) __init;
+int ar724x_pcibios_init(int irq) __init;
 
 int ar71xx_pci_init(unsigned nr_irqs, struct ar71xx_pci_irq *map) __init;
+#else
+static inline int ar71xx_pci_init(unsigned nr_irqs, struct ar71xx_pci_irq *map)
+{
+	return 0;
+}
+#endif
 
 #endif /* __ASM_MACH_AR71XX_PCI_H */
diff --git a/arch/mips/include/asm/mach-ar71xx/platform.h b/arch/mips/include/asm/mach-ar71xx/platform.h
index cf198d2..c60641b 100644
--- a/arch/mips/include/asm/mach-ar71xx/platform.h
+++ b/arch/mips/include/asm/mach-ar71xx/platform.h
@@ -23,18 +23,18 @@ struct ag71xx_platform_data {
 	int		speed;
 	int		duplex;
 	u32		reset_bit;
-	u32		mii_if;
 	u8		mac_addr[ETH_ALEN];
 	struct device	*mii_bus_dev;
 
 	u8		has_gbit:1;
 	u8		is_ar91xx:1;
+	u8		is_ar7240:1;
 	u8		is_ar724x:1;
 	u8		has_ar8216:1;
 	u8		has_ar7240_switch:1;
 
-	void		(* ddr_flush)(void);
-	void		(* set_pll)(int speed);
+	void		(*ddr_flush)(void);
+	void		(*set_speed)(int speed);
 
 	u32		fifo_cfg1;
 	u32		fifo_cfg2;
diff --git a/arch/mips/include/asm/mach-ar71xx/rb4xx_cpld.h b/arch/mips/include/asm/mach-ar71xx/rb4xx_cpld.h
new file mode 100644
index 0000000..5b17e94
--- /dev/null
+++ b/arch/mips/include/asm/mach-ar71xx/rb4xx_cpld.h
@@ -0,0 +1,48 @@
+/*
+ * SPI driver definitions for the CPLD chip on the Mikrotik RB4xx boards
+ *
+ * Copyright (C) 2010 Gabor Juhos <juhosg@openwrt.org>
+ *
+ * This file was based on the patches for Linux 2.6.27.39 published by
+ * MikroTik for their RouterBoard 4xx series devices.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation.
+ */
+
+#define CPLD_GPIO_nLED1		0
+#define CPLD_GPIO_nLED2		1
+#define CPLD_GPIO_nLED3		2
+#define CPLD_GPIO_nLED4		3
+#define CPLD_GPIO_FAN		4
+#define CPLD_GPIO_ALE		5
+#define CPLD_GPIO_CLE		6
+#define CPLD_GPIO_nCE		7
+#define CPLD_GPIO_nLED5		8
+
+#define CPLD_NUM_GPIOS		9
+
+#define CPLD_CFG_nLED1		BIT(CPLD_GPIO_nLED1)
+#define CPLD_CFG_nLED2		BIT(CPLD_GPIO_nLED2)
+#define CPLD_CFG_nLED3		BIT(CPLD_GPIO_nLED3)
+#define CPLD_CFG_nLED4		BIT(CPLD_GPIO_nLED4)
+#define CPLD_CFG_FAN		BIT(CPLD_GPIO_FAN)
+#define CPLD_CFG_ALE		BIT(CPLD_GPIO_ALE)
+#define CPLD_CFG_CLE		BIT(CPLD_GPIO_CLE)
+#define CPLD_CFG_nCE		BIT(CPLD_GPIO_nCE)
+#define CPLD_CFG_nLED5		BIT(CPLD_GPIO_nLED5)
+
+struct rb4xx_cpld_platform_data {
+	unsigned	gpio_base;
+};
+
+extern int rb4xx_cpld_change_cfg(unsigned mask, unsigned value);
+extern int rb4xx_cpld_read(unsigned char *rx_buf,
+			   const unsigned char *verify_buf,
+			   unsigned cnt);
+extern int rb4xx_cpld_read_from(unsigned addr,
+				unsigned char *rx_buf,
+				const unsigned char *verify_buf,
+				unsigned cnt);
+extern int rb4xx_cpld_write(const unsigned char *buf, unsigned count);
-- 
1.7.4.1

