From f9731b9d473a8c3c3d4676312f8491a9a6eadd82 Mon Sep 17 00:00:00 2001
From: Zumeng Chen <zumeng.chen@windriver.com>
Date: Wed, 29 Sep 2010 10:05:21 +0800
Subject: [PATCH 04/16] Add pci supoprt for ar7xxx

Which is downloaded from the following:
  https://dev.openwrt.org/browser/branches
  branches_backfire_target_linux_ar71xx_files-r23140.zip

Integrated-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 arch/mips/pci/Makefile     |    1 +
 arch/mips/pci/pci-ar71xx.c |  409 ++++++++++++++++++++++++++++++++++++++++++++
 arch/mips/pci/pci-ar724x.c |  395 ++++++++++++++++++++++++++++++++++++++++++
 3 files changed, 805 insertions(+), 0 deletions(-)
 create mode 100644 arch/mips/pci/pci-ar71xx.c
 create mode 100644 arch/mips/pci/pci-ar724x.c

diff --git a/arch/mips/pci/Makefile b/arch/mips/pci/Makefile
index c9209ca..b2f15e2 100644
--- a/arch/mips/pci/Makefile
+++ b/arch/mips/pci/Makefile
@@ -18,6 +18,7 @@ obj-$(CONFIG_PCI_TX4927)	+= ops-tx4927.o
 obj-$(CONFIG_BCM47XX)		+= pci-bcm47xx.o
 obj-$(CONFIG_BCM63XX)		+= pci-bcm63xx.o fixup-bcm63xx.o \
 					ops-bcm63xx.o
+obj-$(CONFIG_ATHEROS_AR71XX)	+= pci-ar71xx.o pci-ar724x.o
 
 #
 # These are still pretty much in the old state, watch, go blind.
diff --git a/arch/mips/pci/pci-ar71xx.c b/arch/mips/pci/pci-ar71xx.c
new file mode 100644
index 0000000..7d0eee9
--- /dev/null
+++ b/arch/mips/pci/pci-ar71xx.c
@@ -0,0 +1,409 @@
+/*
+ *  Atheros AR71xx PCI host controller driver
+ *
+ *  Copyright (C) 2008-2010 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  Parts of this file are based on Atheros' 2.6.15 BSP
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/resource.h>
+#include <linux/types.h>
+#include <linux/delay.h>
+#include <linux/bitops.h>
+#include <linux/pci.h>
+#include <linux/pci_regs.h>
+#include <linux/interrupt.h>
+
+#include <asm/mach-ar71xx/ar71xx.h>
+#include <asm/mach-ar71xx/pci.h>
+
+#undef DEBUG
+#ifdef DEBUG
+#define DBG(fmt, args...)	printk(KERN_DEBUG fmt, ## args)
+#else
+#define DBG(fmt, args...)
+#endif
+
+#define AR71XX_PCI_DELAY	100 /* msecs */
+
+#if 0
+#define PCI_IDSEL_BASE	PCI_IDSEL_ADL_START
+#else
+#define PCI_IDSEL_BASE	0
+#endif
+
+static void __iomem *ar71xx_pcicfg_base;
+static DEFINE_SPINLOCK(ar71xx_pci_lock);
+static int ar71xx_pci_fixup_enable;
+
+static inline void ar71xx_pci_delay(void)
+{
+	mdelay(AR71XX_PCI_DELAY);
+}
+
+/* Byte lane enable bits */
+static u8 ble_table[4][4] = {
+	{0x0, 0xf, 0xf, 0xf},
+	{0xe, 0xd, 0xb, 0x7},
+	{0xc, 0xf, 0x3, 0xf},
+	{0xf, 0xf, 0xf, 0xf},
+};
+
+static inline u32 ar71xx_pci_get_ble(int where, int size, int local)
+{
+	u32 t;
+
+	t = ble_table[size & 3][where & 3];
+	BUG_ON(t == 0xf);
+	t <<= (local) ? 20 : 4;
+	return t;
+}
+
+static inline u32 ar71xx_pci_bus_addr(struct pci_bus *bus, unsigned int devfn,
+					int where)
+{
+	u32 ret;
+
+	if (!bus->number) {
+		/* type 0 */
+		ret = (1 << (PCI_IDSEL_BASE + PCI_SLOT(devfn)))
+		    | (PCI_FUNC(devfn) << 8) | (where & ~3);
+	} else {
+		/* type 1 */
+		ret = (bus->number << 16) | (PCI_SLOT(devfn) << 11)
+		    | (PCI_FUNC(devfn) << 8) | (where & ~3) | 1;
+	}
+
+	return ret;
+}
+
+int ar71xx_pci_be_handler(int is_fixup)
+{
+	void __iomem *base = ar71xx_pcicfg_base;
+	u32 pci_err;
+	u32 ahb_err;
+
+	pci_err = __raw_readl(base + PCI_REG_PCI_ERR) & 3;
+	if (pci_err) {
+		if (!is_fixup)
+			printk(KERN_ALERT "PCI error %d at PCI addr 0x%x\n",
+				pci_err,
+				__raw_readl(base + PCI_REG_PCI_ERR_ADDR));
+
+		__raw_writel(pci_err, base + PCI_REG_PCI_ERR);
+	}
+
+	ahb_err = __raw_readl(base + PCI_REG_AHB_ERR) & 1;
+	if (ahb_err) {
+		if (!is_fixup)
+			printk(KERN_ALERT "AHB error at AHB address 0x%x\n",
+				__raw_readl(base + PCI_REG_AHB_ERR_ADDR));
+
+		__raw_writel(ahb_err, base + PCI_REG_AHB_ERR);
+	}
+
+	return ((ahb_err | pci_err) ? 1 : 0);
+}
+
+static inline int ar71xx_pci_set_cfgaddr(struct pci_bus *bus,
+			unsigned int devfn, int where, int size, u32 cmd)
+{
+	void __iomem *base = ar71xx_pcicfg_base;
+	u32 addr;
+
+	addr = ar71xx_pci_bus_addr(bus, devfn, where);
+
+	DBG("PCI: set cfgaddr: %02x:%02x.%01x/%02x:%01d, addr=%08x\n",
+		bus->number, PCI_SLOT(devfn), PCI_FUNC(devfn),
+		where, size, addr);
+
+	__raw_writel(addr, base + PCI_REG_CFG_AD);
+	__raw_writel(cmd | ar71xx_pci_get_ble(where, size, 0),
+		     base + PCI_REG_CFG_CBE);
+
+	return ar71xx_pci_be_handler(1);
+}
+
+static int ar71xx_pci_read_config(struct pci_bus *bus, unsigned int devfn,
+				  int where, int size, u32 *value)
+{
+	void __iomem *base = ar71xx_pcicfg_base;
+	static u32 mask[8] = {0, 0xff, 0xffff, 0, 0xffffffff, 0, 0, 0};
+	unsigned long flags;
+	u32 data;
+	int ret;
+
+	ret = PCIBIOS_SUCCESSFUL;
+
+	DBG("PCI: read config: %02x:%02x.%01x/%02x:%01d\n", bus->number,
+			PCI_SLOT(devfn), PCI_FUNC(devfn), where, size);
+
+	spin_lock_irqsave(&ar71xx_pci_lock, flags);
+
+	if (bus->number == 0 && devfn == 0) {
+		u32 t;
+
+		t = PCI_CRP_CMD_READ | (where & ~3);
+
+		__raw_writel(t, base + PCI_REG_CRP_AD_CBE);
+		data = __raw_readl(base + PCI_REG_CRP_RDDATA);
+
+		DBG("PCI: rd local cfg, ad_cbe:%08x, data:%08x\n", t, data);
+
+	} else {
+		int err;
+
+		err = ar71xx_pci_set_cfgaddr(bus, devfn, where, size,
+						PCI_CFG_CMD_READ);
+
+		if (err == 0) {
+			data = __raw_readl(base + PCI_REG_CFG_RDDATA);
+		} else {
+			ret = PCIBIOS_DEVICE_NOT_FOUND;
+			data = ~0;
+		}
+	}
+
+	spin_unlock_irqrestore(&ar71xx_pci_lock, flags);
+
+	DBG("PCI: read config: data=%08x raw=%08x\n",
+		(data >> (8 * (where & 3))) & mask[size & 7], data);
+
+	*value = (data >> (8 * (where & 3))) & mask[size & 7];
+
+	return ret;
+}
+
+static int ar71xx_pci_write_config(struct pci_bus *bus, unsigned int devfn,
+				   int where, int size, u32 value)
+{
+	void __iomem *base = ar71xx_pcicfg_base;
+	unsigned long flags;
+	int ret;
+
+	DBG("PCI: write config: %02x:%02x.%01x/%02x:%01d value=%08x\n",
+		bus->number, PCI_SLOT(devfn), PCI_FUNC(devfn),
+		where, size, value);
+
+	value = value << (8 * (where & 3));
+	ret = PCIBIOS_SUCCESSFUL;
+
+	spin_lock_irqsave(&ar71xx_pci_lock, flags);
+	if (bus->number == 0 && devfn == 0) {
+		u32 t;
+
+		t = PCI_CRP_CMD_WRITE | (where & ~3);
+		t |= ar71xx_pci_get_ble(where, size, 1);
+
+		DBG("PCI: wr local cfg, ad_cbe:%08x, value:%08x\n", t, value);
+
+		__raw_writel(t, base + PCI_REG_CRP_AD_CBE);
+		__raw_writel(value, base + PCI_REG_CRP_WRDATA);
+	} else {
+		int err;
+
+		err = ar71xx_pci_set_cfgaddr(bus, devfn, where, size,
+						PCI_CFG_CMD_WRITE);
+
+		if (err == 0)
+			__raw_writel(value, base + PCI_REG_CFG_WRDATA);
+		else
+			ret = PCIBIOS_DEVICE_NOT_FOUND;
+	}
+	spin_unlock_irqrestore(&ar71xx_pci_lock, flags);
+
+	return ret;
+}
+
+static void ar71xx_pci_fixup(struct pci_dev *dev)
+{
+	u32 t;
+
+	if (!ar71xx_pci_fixup_enable)
+		return;
+
+	if (dev->bus->number != 0 || dev->devfn != 0)
+		return;
+
+	DBG("PCI: fixup host controller %s (%04x:%04x)\n", pci_name(dev),
+		dev->vendor, dev->device);
+
+	/* setup COMMAND register */
+	t = PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER | PCI_COMMAND_INVALIDATE
+	  | PCI_COMMAND_PARITY | PCI_COMMAND_SERR | PCI_COMMAND_FAST_BACK;
+
+	pci_write_config_word(dev, PCI_COMMAND, t);
+}
+DECLARE_PCI_FIXUP_EARLY(PCI_ANY_ID, PCI_ANY_ID, ar71xx_pci_fixup);
+
+int __init ar71xx_pcibios_map_irq(const struct pci_dev *dev, uint8_t slot,
+				  uint8_t pin)
+{
+	int irq = -1;
+	int i;
+
+	slot -= PCI_IDSEL_ADL_START - PCI_IDSEL_BASE;
+
+	for (i = 0; i < ar71xx_pci_nr_irqs; i++) {
+		struct ar71xx_pci_irq *entry;
+
+		entry = &ar71xx_pci_irq_map[i];
+		if (entry->slot == slot && entry->pin == pin) {
+			irq = entry->irq;
+			break;
+		}
+	}
+
+	if (irq < 0) {
+		printk(KERN_ALERT "PCI: no irq found for pin%u@%s\n",
+				pin, pci_name((struct pci_dev *)dev));
+	} else {
+		printk(KERN_INFO "PCI: mapping irq %d to pin%u@%s\n",
+				irq, pin, pci_name((struct pci_dev *)dev));
+	}
+
+	return irq;
+}
+
+static struct pci_ops ar71xx_pci_ops = {
+	.read	= ar71xx_pci_read_config,
+	.write	= ar71xx_pci_write_config,
+};
+
+static struct resource ar71xx_pci_io_resource = {
+	.name		= "PCI IO space",
+	.start		= 0,
+	.end		= 0,
+	.flags		= IORESOURCE_IO,
+};
+
+static struct resource ar71xx_pci_mem_resource = {
+	.name		= "PCI memory space",
+	.start		= AR71XX_PCI_MEM_BASE,
+	.end		= AR71XX_PCI_MEM_BASE + AR71XX_PCI_MEM_SIZE - 1,
+	.flags		= IORESOURCE_MEM
+};
+
+static struct pci_controller ar71xx_pci_controller = {
+	.pci_ops	= &ar71xx_pci_ops,
+	.mem_resource	= &ar71xx_pci_mem_resource,
+	.io_resource	= &ar71xx_pci_io_resource,
+};
+
+static void ar71xx_pci_irq_handler(unsigned int irq, struct irq_desc *desc)
+{
+	void __iomem *base = ar71xx_reset_base;
+	u32 pending;
+
+	pending = __raw_readl(base + AR71XX_RESET_REG_PCI_INT_STATUS) &
+		  __raw_readl(base + AR71XX_RESET_REG_PCI_INT_ENABLE);
+
+	if (pending & PCI_INT_DEV0)
+		generic_handle_irq(AR71XX_PCI_IRQ_DEV0);
+
+	else if (pending & PCI_INT_DEV1)
+		generic_handle_irq(AR71XX_PCI_IRQ_DEV1);
+
+	else if (pending & PCI_INT_DEV2)
+		generic_handle_irq(AR71XX_PCI_IRQ_DEV2);
+
+	else if (pending & PCI_INT_CORE)
+		generic_handle_irq(AR71XX_PCI_IRQ_CORE);
+
+	else
+		spurious_interrupt();
+}
+
+static void ar71xx_pci_irq_unmask(unsigned int irq)
+{
+	void __iomem *base = ar71xx_reset_base;
+	u32 t;
+
+	irq -= AR71XX_PCI_IRQ_BASE;
+
+	t = __raw_readl(base + AR71XX_RESET_REG_PCI_INT_ENABLE);
+	__raw_writel(t | (1 << irq), base + AR71XX_RESET_REG_PCI_INT_ENABLE);
+
+	/* flush write */
+	(void) __raw_readl(base + AR71XX_RESET_REG_PCI_INT_ENABLE);
+}
+
+static void ar71xx_pci_irq_mask(unsigned int irq)
+{
+	void __iomem *base = ar71xx_reset_base;
+	u32 t;
+
+	irq -= AR71XX_PCI_IRQ_BASE;
+
+	t = __raw_readl(base + AR71XX_RESET_REG_PCI_INT_ENABLE);
+	__raw_writel(t & ~(1 << irq), base + AR71XX_RESET_REG_PCI_INT_ENABLE);
+
+	/* flush write */
+	(void) __raw_readl(base + AR71XX_RESET_REG_PCI_INT_ENABLE);
+}
+
+static struct irq_chip ar71xx_pci_irq_chip = {
+	.name		= "AR71XX PCI ",
+	.mask		= ar71xx_pci_irq_mask,
+	.unmask		= ar71xx_pci_irq_unmask,
+	.mask_ack	= ar71xx_pci_irq_mask,
+};
+
+static void __init ar71xx_pci_irq_init(void)
+{
+	void __iomem *base = ar71xx_reset_base;
+	int i;
+
+	__raw_writel(0, base + AR71XX_RESET_REG_PCI_INT_ENABLE);
+	__raw_writel(0, base + AR71XX_RESET_REG_PCI_INT_STATUS);
+
+	for (i = AR71XX_PCI_IRQ_BASE;
+	     i < AR71XX_PCI_IRQ_BASE + AR71XX_PCI_IRQ_COUNT; i++) {
+		irq_desc[i].status = IRQ_DISABLED;
+		set_irq_chip_and_handler(i, &ar71xx_pci_irq_chip,
+					 handle_level_irq);
+	}
+
+	set_irq_chained_handler(AR71XX_CPU_IRQ_IP2, ar71xx_pci_irq_handler);
+}
+
+int __init ar71xx_pcibios_init(void)
+{
+	void __iomem *ddr_base = ar71xx_ddr_base;
+
+	ar71xx_device_stop(RESET_MODULE_PCI_BUS | RESET_MODULE_PCI_CORE);
+	ar71xx_pci_delay();
+
+	ar71xx_device_start(RESET_MODULE_PCI_BUS | RESET_MODULE_PCI_CORE);
+	ar71xx_pci_delay();
+
+	ar71xx_pcicfg_base = ioremap_nocache(AR71XX_PCI_CFG_BASE,
+						AR71XX_PCI_CFG_SIZE);
+	if (ar71xx_pcicfg_base == NULL)
+		return -ENOMEM;
+
+	__raw_writel(PCI_WIN0_OFFS, ddr_base + AR71XX_DDR_REG_PCI_WIN0);
+	__raw_writel(PCI_WIN1_OFFS, ddr_base + AR71XX_DDR_REG_PCI_WIN1);
+	__raw_writel(PCI_WIN2_OFFS, ddr_base + AR71XX_DDR_REG_PCI_WIN2);
+	__raw_writel(PCI_WIN3_OFFS, ddr_base + AR71XX_DDR_REG_PCI_WIN3);
+	__raw_writel(PCI_WIN4_OFFS, ddr_base + AR71XX_DDR_REG_PCI_WIN4);
+	__raw_writel(PCI_WIN5_OFFS, ddr_base + AR71XX_DDR_REG_PCI_WIN5);
+	__raw_writel(PCI_WIN6_OFFS, ddr_base + AR71XX_DDR_REG_PCI_WIN6);
+	__raw_writel(PCI_WIN7_OFFS, ddr_base + AR71XX_DDR_REG_PCI_WIN7);
+
+	ar71xx_pci_delay();
+
+	/* clear bus errors */
+	(void)ar71xx_pci_be_handler(1);
+
+	ar71xx_pci_fixup_enable = 1;
+	ar71xx_pci_irq_init();
+	register_pci_controller(&ar71xx_pci_controller);
+
+	return 0;
+}
diff --git a/arch/mips/pci/pci-ar724x.c b/arch/mips/pci/pci-ar724x.c
new file mode 100644
index 0000000..b639806
--- /dev/null
+++ b/arch/mips/pci/pci-ar724x.c
@@ -0,0 +1,395 @@
+/*
+ *  Atheros AR724x PCI host controller driver
+ *
+ *  Copyright (C) 2009-2010 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  Parts of this file are based on Atheros' 2.6.15 BSP
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/resource.h>
+#include <linux/types.h>
+#include <linux/delay.h>
+#include <linux/bitops.h>
+#include <linux/pci.h>
+#include <linux/pci_regs.h>
+#include <linux/interrupt.h>
+
+#include <asm/mach-ar71xx/ar71xx.h>
+#include <asm/mach-ar71xx/pci.h>
+
+#undef DEBUG
+#ifdef DEBUG
+#define DBG(fmt, args...)	printk(KERN_INFO fmt, ## args)
+#else
+#define DBG(fmt, args...)
+#endif
+
+static void __iomem *ar724x_pci_localcfg_base;
+static void __iomem *ar724x_pci_devcfg_base;
+static void __iomem *ar724x_pci_ctrl_base;
+static int ar724x_pci_fixup_enable;
+
+static DEFINE_SPINLOCK(ar724x_pci_lock);
+
+static void ar724x_pci_read(void __iomem *base, int where, int size, u32 *value)
+{
+	unsigned long flags;
+	u32 data;
+
+	spin_lock_irqsave(&ar724x_pci_lock, flags);
+	data = __raw_readl(base + (where & ~3));
+
+	switch (size) {
+	case 1:
+		if (where & 1)
+			data >>= 8;
+		if (where & 2)
+			data >>= 16;
+		data &= 0xFF;
+		break;
+	case 2:
+		if (where & 2)
+			data >>= 16;
+		data &= 0xFFFF;
+		break;
+	}
+
+	*value = data;
+	spin_unlock_irqrestore(&ar724x_pci_lock, flags);
+}
+
+static void ar724x_pci_write(void __iomem *base, int where, int size, u32 value)
+{
+	unsigned long flags;
+	u32 data;
+	int s;
+
+	spin_lock_irqsave(&ar724x_pci_lock, flags);
+	data = __raw_readl(base + (where & ~3));
+
+	switch (size) {
+	case 1:
+		s = ((where & 3) << 3);
+		data &= ~(0xFF << s);
+		data |= ((value & 0xFF) << s);
+		break;
+	case 2:
+		s = ((where & 2) << 3);
+		data &= ~(0xFFFF << s);
+		data |= ((value & 0xFFFF) << s);
+		break;
+	case 4:
+		data = value;
+		break;
+	}
+
+	__raw_writel(data, base + (where & ~3));
+	/* flush write */
+	(void)__raw_readl(base + (where & ~3));
+	spin_unlock_irqrestore(&ar724x_pci_lock, flags);
+}
+
+static int ar724x_pci_read_config(struct pci_bus *bus, unsigned int devfn,
+				  int where, int size, u32 *value)
+{
+
+	if (bus->number != 0 || devfn != 0)
+		return PCIBIOS_DEVICE_NOT_FOUND;
+
+	ar724x_pci_read(ar724x_pci_devcfg_base, where, size, value);
+
+	DBG("PCI: read config: %02x:%02x.%01x/%02x:%01d, value=%08x\n",
+			bus->number, PCI_SLOT(devfn), PCI_FUNC(devfn),
+			where, size, *value);
+
+	/*
+	 * WAR for BAR issue - We are unable to access the PCI device space
+	 * if we set the BAR with proper base address
+	 */
+	if ((where == 0x10) && (size == 4)) {
+		if (ar71xx_soc == AR71XX_SOC_AR7240)
+			ar724x_pci_write(ar724x_pci_devcfg_base, where, size, 0xffff);
+		else
+			ar724x_pci_write(ar724x_pci_devcfg_base, where, size, 0x1000ffff);
+	}
+
+	return PCIBIOS_SUCCESSFUL;
+}
+
+static int ar724x_pci_write_config(struct pci_bus *bus, unsigned int devfn,
+				   int where, int size, u32 value)
+{
+	if (bus->number != 0 || devfn != 0)
+		return PCIBIOS_DEVICE_NOT_FOUND;
+
+	DBG("PCI: write config: %02x:%02x.%01x/%02x:%01d, value=%08x\n",
+		bus->number, PCI_SLOT(devfn), PCI_FUNC(devfn),
+		where, size, value);
+
+	ar724x_pci_write(ar724x_pci_devcfg_base, where, size, value);
+
+	return PCIBIOS_SUCCESSFUL;
+}
+
+static void ar724x_pci_fixup(struct pci_dev *dev)
+{
+	u16 cmd;
+
+	if (!ar724x_pci_fixup_enable)
+		return;
+
+	if (dev->bus->number != 0 || dev->devfn != 0)
+		return;
+
+	/* setup COMMAND register */
+	pci_read_config_word(dev, PCI_COMMAND, &cmd);
+	cmd |= PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER |
+	       PCI_COMMAND_INVALIDATE | PCI_COMMAND_PARITY | PCI_COMMAND_SERR |
+	       PCI_COMMAND_FAST_BACK;
+
+	pci_write_config_word(dev, PCI_COMMAND, cmd);
+}
+DECLARE_PCI_FIXUP_EARLY(PCI_ANY_ID, PCI_ANY_ID, ar724x_pci_fixup);
+
+int __init ar724x_pcibios_map_irq(const struct pci_dev *dev, uint8_t slot,
+				  uint8_t pin)
+{
+	int irq = -1;
+	int i;
+
+	for (i = 0; i < ar71xx_pci_nr_irqs; i++) {
+		struct ar71xx_pci_irq *entry;
+		entry = &ar71xx_pci_irq_map[i];
+
+		if (entry->slot == slot && entry->pin == pin) {
+			irq = entry->irq;
+			break;
+		}
+	}
+
+	if (irq < 0)
+		printk(KERN_ALERT "PCI: no irq found for pin%u@%s\n",
+				pin, pci_name((struct pci_dev *)dev));
+	else
+		printk(KERN_INFO "PCI: mapping irq %d to pin%u@%s\n",
+				irq, pin, pci_name((struct pci_dev *)dev));
+
+	return irq;
+}
+
+static struct pci_ops ar724x_pci_ops = {
+	.read	= ar724x_pci_read_config,
+	.write	= ar724x_pci_write_config,
+};
+
+static struct resource ar724x_pci_io_resource = {
+	.name		= "PCI IO space",
+	.start		= 0,
+	.end		= 0,
+	.flags		= IORESOURCE_IO,
+};
+
+static struct resource ar724x_pci_mem_resource = {
+	.name		= "PCI memory space",
+	.start		= AR71XX_PCI_MEM_BASE,
+	.end		= AR71XX_PCI_MEM_BASE + AR71XX_PCI_MEM_SIZE - 1,
+	.flags		= IORESOURCE_MEM
+};
+
+static struct pci_controller ar724x_pci_controller = {
+	.pci_ops	= &ar724x_pci_ops,
+	.mem_resource	= &ar724x_pci_mem_resource,
+	.io_resource	= &ar724x_pci_io_resource,
+};
+
+static void __init ar724x_pci_reset(void)
+{
+	ar71xx_device_stop(AR724X_RESET_PCIE);
+	ar71xx_device_stop(AR724X_RESET_PCIE_PHY);
+	ar71xx_device_stop(AR724X_RESET_PCIE_PHY_SERIAL);
+	udelay(100);
+
+	ar71xx_device_start(AR724X_RESET_PCIE_PHY_SERIAL);
+	udelay(100);
+	ar71xx_device_start(AR724X_RESET_PCIE_PHY);
+	ar71xx_device_start(AR724X_RESET_PCIE);
+}
+
+static int __init ar724x_pci_setup(void)
+{
+	void __iomem *base = ar724x_pci_ctrl_base;
+	u32 t;
+
+	/* setup COMMAND register */
+	t = PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER | PCI_COMMAND_INVALIDATE |
+	    PCI_COMMAND_PARITY|PCI_COMMAND_SERR|PCI_COMMAND_FAST_BACK;
+
+	ar724x_pci_write(ar724x_pci_localcfg_base, PCI_COMMAND, 4, t);
+	ar724x_pci_write(ar724x_pci_localcfg_base, 0x20, 4, 0x1ff01000);
+	ar724x_pci_write(ar724x_pci_localcfg_base, 0x24, 4, 0x1ff01000);
+
+	t = __raw_readl(base + AR724X_PCI_REG_RESET);
+	if (t != 0x7) {
+		udelay(100000);
+		__raw_writel(0, base + AR724X_PCI_REG_RESET);
+		udelay(100);
+		__raw_writel(4, base + AR724X_PCI_REG_RESET);
+		udelay(100000);
+	}
+
+	if (ar71xx_soc == AR71XX_SOC_AR7240)
+		t = AR724X_PCI_APP_LTSSM_ENABLE;
+	else
+		t = 0x1ffc1;
+	__raw_writel(t, base + AR724X_PCI_REG_APP);
+	/* flush write */
+	(void) __raw_readl(base + AR724X_PCI_REG_APP);
+	udelay(1000);
+
+	t = __raw_readl(base + AR724X_PCI_REG_RESET);
+	if ((t & AR724X_PCI_RESET_LINK_UP) == 0x0) {
+		printk(KERN_WARNING "PCI: no PCIe module found\n");
+		return -ENODEV;
+	}
+
+	if (ar71xx_soc == AR71XX_SOC_AR7241 || ar71xx_soc == AR71XX_SOC_AR7242) {
+		t = __raw_readl(base + AR724X_PCI_REG_APP);
+		t |= BIT(16);
+		__raw_writel(t, base + AR724X_PCI_REG_APP);
+	}
+
+	return 0;
+}
+
+static void ar724x_pci_irq_handler(unsigned int irq, struct irq_desc *desc)
+{
+	void __iomem *base = ar724x_pci_ctrl_base;
+	u32 pending;
+
+	pending = __raw_readl(base + AR724X_PCI_REG_INT_STATUS) &
+		  __raw_readl(base + AR724X_PCI_REG_INT_MASK);
+
+	if (pending & AR724X_PCI_INT_DEV0)
+		generic_handle_irq(AR71XX_PCI_IRQ_DEV0);
+
+	else
+		spurious_interrupt();
+}
+
+static void ar724x_pci_irq_unmask(unsigned int irq)
+{
+	void __iomem *base = ar724x_pci_ctrl_base;
+	u32 t;
+
+	switch (irq) {
+	case AR71XX_PCI_IRQ_DEV0:
+		irq -= AR71XX_PCI_IRQ_BASE;
+
+		t = __raw_readl(base + AR724X_PCI_REG_INT_MASK);
+		__raw_writel(t | AR724X_PCI_INT_DEV0,
+			     base + AR724X_PCI_REG_INT_MASK);
+		/* flush write */
+		(void) __raw_readl(base + AR724X_PCI_REG_INT_MASK);
+	}
+}
+
+static void ar724x_pci_irq_mask(unsigned int irq)
+{
+	void __iomem *base = ar724x_pci_ctrl_base;
+	u32 t;
+
+	switch (irq) {
+	case AR71XX_PCI_IRQ_DEV0:
+		irq -= AR71XX_PCI_IRQ_BASE;
+
+		t = __raw_readl(base + AR724X_PCI_REG_INT_MASK);
+		__raw_writel(t & ~AR724X_PCI_INT_DEV0,
+			     base + AR724X_PCI_REG_INT_MASK);
+
+		/* flush write */
+		(void) __raw_readl(base + AR724X_PCI_REG_INT_MASK);
+
+		t = __raw_readl(base + AR724X_PCI_REG_INT_STATUS);
+		__raw_writel(t | AR724X_PCI_INT_DEV0,
+			     base + AR724X_PCI_REG_INT_STATUS);
+
+		/* flush write */
+		(void) __raw_readl(base + AR724X_PCI_REG_INT_STATUS);
+	}
+}
+
+static struct irq_chip ar724x_pci_irq_chip = {
+	.name		= "AR724X PCI ",
+	.mask		= ar724x_pci_irq_mask,
+	.unmask		= ar724x_pci_irq_unmask,
+	.mask_ack	= ar724x_pci_irq_mask,
+};
+
+static void __init ar724x_pci_irq_init(void)
+{
+	void __iomem *base = ar724x_pci_ctrl_base;
+	u32 t;
+	int i;
+
+	t = ar71xx_reset_rr(AR724X_RESET_REG_RESET_MODULE);
+	if (t & (AR724X_RESET_PCIE | AR724X_RESET_PCIE_PHY |
+		 AR724X_RESET_PCIE_PHY_SERIAL)) {
+		return;
+	}
+
+	__raw_writel(0, base + AR724X_PCI_REG_INT_MASK);
+	__raw_writel(0, base + AR724X_PCI_REG_INT_STATUS);
+
+	for (i = AR71XX_PCI_IRQ_BASE;
+	     i < AR71XX_PCI_IRQ_BASE + AR71XX_PCI_IRQ_COUNT; i++) {
+		irq_desc[i].status = IRQ_DISABLED;
+		set_irq_chip_and_handler(i, &ar724x_pci_irq_chip,
+					 handle_level_irq);
+	}
+
+	set_irq_chained_handler(AR71XX_CPU_IRQ_IP2, ar724x_pci_irq_handler);
+}
+
+int __init ar724x_pcibios_init(void)
+{
+	int ret = -ENOMEM;
+
+	ar724x_pci_localcfg_base = ioremap_nocache(AR724X_PCI_CRP_BASE,
+						   AR724X_PCI_CRP_SIZE);
+	if (ar724x_pci_localcfg_base == NULL)
+		goto err;
+
+	ar724x_pci_devcfg_base = ioremap_nocache(AR724X_PCI_CFG_BASE,
+						 AR724X_PCI_CFG_SIZE);
+	if (ar724x_pci_devcfg_base == NULL)
+		goto err_unmap_localcfg;
+
+	ar724x_pci_ctrl_base = ioremap_nocache(AR724X_PCI_CTRL_BASE,
+					       AR724X_PCI_CTRL_SIZE);
+	if (ar724x_pci_ctrl_base == NULL)
+		goto err_unmap_devcfg;
+
+	ar724x_pci_reset();
+	ret = ar724x_pci_setup();
+	if (ret)
+		goto err_unmap_ctrl;
+
+	ar724x_pci_fixup_enable = 1;
+	ar724x_pci_irq_init();
+	register_pci_controller(&ar724x_pci_controller);
+
+	return 0;
+
+ err_unmap_ctrl:
+	iounmap(ar724x_pci_ctrl_base);
+  err_unmap_devcfg:
+	iounmap(ar724x_pci_devcfg_base);
+ err_unmap_localcfg:
+	iounmap(ar724x_pci_localcfg_base);
+ err:
+	return ret;
+}
-- 
1.7.0.4

