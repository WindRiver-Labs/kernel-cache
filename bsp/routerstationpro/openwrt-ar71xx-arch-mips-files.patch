From 6892990ad9c3811210e69c2e485307661fa705d7 Mon Sep 17 00:00:00 2001
From: Paul Gortmaker <paul.gortmaker@windriver.com>
Date: Tue, 17 Jul 2012 11:33:59 -0400
Subject: [PATCH 05/76] openwrt ar71xx arch/mips files

Import of the openwrt arch/mips files from trunk, as of this commit:

 ----------
commit c1d79f64eed0a7ac36b5b9bca52275b397bec424
Author: nbd <nbd@3c298f89-4303-0410-b956-a3cf2f4a3e73>
Date:   Mon Jul 16 16:26:51 2012 +0000

    uboot-ar71xx: fix compile on recent mac os x versions

    git-svn-id: svn://svn.openwrt.org/openwrt/trunk@32750 3c298f89-4303-0410-b956-a3cf2f4a3e73
 ----------

Due to the nature of how the openwrt source is managed, new
files are found separate from the commits which actually
make use of them, so that unused stuff could not easily
be left behind, but it is what it is.

Path to files in the repo is: target/linux/generic/files
Repo is: git://nbd.name/openwrt.git

Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
---
 arch/mips/ath79/dev-ap9x-pci.c                     |  153 +++
 arch/mips/ath79/dev-ap9x-pci.h                     |   45 +
 arch/mips/ath79/dev-dsa.c                          |   36 +
 arch/mips/ath79/dev-dsa.h                          |   21 +
 arch/mips/ath79/dev-eth.c                          |  990 ++++++++++++++++++++
 arch/mips/ath79/dev-eth.h                          |   48 +
 arch/mips/ath79/dev-m25p80.c                       |  117 +++
 arch/mips/ath79/dev-m25p80.h                       |   17 +
 arch/mips/ath79/mach-alfa-ap96.c                   |  154 +++
 arch/mips/ath79/mach-alfa-nx.c                     |  113 +++
 arch/mips/ath79/mach-all0258n.c                    |   88 ++
 arch/mips/ath79/mach-ap113.c                       |   84 ++
 arch/mips/ath79/mach-ap83.c                        |  275 ++++++
 arch/mips/ath79/mach-ap96.c                        |  142 +++
 arch/mips/ath79/mach-aw-nr580.c                    |  107 +++
 arch/mips/ath79/mach-dir-600-a1.c                  |  151 +++
 arch/mips/ath79/mach-dir-615-c1.c                  |  133 +++
 arch/mips/ath79/mach-dir-825-b1.c                  |  173 ++++
 arch/mips/ath79/mach-eap7660d.c                    |  178 ++++
 arch/mips/ath79/mach-ew-dorin.c                    |  108 +++
 arch/mips/ath79/mach-hornet-ub.c                   |  136 +++
 arch/mips/ath79/mach-ja76pf.c                      |  190 ++++
 arch/mips/ath79/mach-jwap003.c                     |   95 ++
 arch/mips/ath79/mach-mzk-w04nu.c                   |  124 +++
 arch/mips/ath79/mach-mzk-w300nh.c                  |  115 +++
 arch/mips/ath79/mach-nbg460n.c                     |  220 +++++
 arch/mips/ath79/mach-om2p.c                        |  176 ++++
 arch/mips/ath79/mach-pb42.c                        |   83 ++
 arch/mips/ath79/mach-pb92.c                        |   70 ++
 arch/mips/ath79/mach-rb4xx.c                       |  405 ++++++++
 arch/mips/ath79/mach-rb750.c                       |  356 +++++++
 arch/mips/ath79/mach-rw2458n.c                     |  100 ++
 arch/mips/ath79/mach-tew-632brp.c                  |  109 +++
 arch/mips/ath79/mach-tew-673gru.c                  |  182 ++++
 arch/mips/ath79/mach-tl-mr11u.c                    |  110 +++
 arch/mips/ath79/mach-tl-mr3020.c                   |  125 +++
 arch/mips/ath79/mach-tl-mr3x20.c                   |  146 +++
 arch/mips/ath79/mach-tl-wa901nd-v2.c               |  104 ++
 arch/mips/ath79/mach-tl-wa901nd.c                  |  109 +++
 arch/mips/ath79/mach-tl-wdr4300.c                  |  203 ++++
 arch/mips/ath79/mach-tl-wr1041n-v2.c               |  154 +++
 arch/mips/ath79/mach-tl-wr1043nd.c                 |  128 +++
 arch/mips/ath79/mach-tl-wr2543n.c                  |  132 +++
 arch/mips/ath79/mach-tl-wr703n.c                   |   85 ++
 arch/mips/ath79/mach-tl-wr741nd-v4.c               |  135 +++
 arch/mips/ath79/mach-tl-wr741nd.c                  |  130 +++
 arch/mips/ath79/mach-tl-wr841n.c                   |  140 +++
 arch/mips/ath79/mach-tl-wr941nd.c                  |  121 +++
 arch/mips/ath79/mach-ubnt.c                        |  205 ++++
 arch/mips/ath79/mach-whr-hp-g300n.c                |  155 +++
 arch/mips/ath79/mach-wndr3700.c                    |  172 ++++
 arch/mips/ath79/mach-wnr2000.c                     |  145 +++
 arch/mips/ath79/mach-wp543.c                       |  107 +++
 arch/mips/ath79/mach-wpe72.c                       |   96 ++
 arch/mips/ath79/mach-wrt160nl.c                    |  126 +++
 arch/mips/ath79/mach-wrt400n.c                     |  161 ++++
 arch/mips/ath79/mach-wzr-hp-ag300h.c               |  156 +++
 arch/mips/ath79/mach-wzr-hp-g300nh.c               |  287 ++++++
 arch/mips/ath79/mach-wzr-hp-g300nh2.c              |  177 ++++
 arch/mips/ath79/mach-wzr-hp-g450h.c                |  169 ++++
 arch/mips/ath79/mach-zcn-1523h.c                   |  157 ++++
 arch/mips/ath79/nvram.c                            |   75 ++
 arch/mips/ath79/nvram.h                            |   19 +
 arch/mips/ath79/pci-ath9k-fixup.c                  |  123 +++
 arch/mips/ath79/pci-ath9k-fixup.h                  |    6 +
 arch/mips/include/asm/fw/myloader/myloader.h       |   34 +
 arch/mips/include/asm/mach-ath79/ag71xx_platform.h |   58 ++
 arch/mips/include/asm/mach-ath79/mach-rb750.h      |   84 ++
 arch/mips/include/asm/mach-ath79/rb4xx_cpld.h      |   48 +
 69 files changed, 9876 insertions(+)
 create mode 100644 arch/mips/ath79/dev-ap9x-pci.c
 create mode 100644 arch/mips/ath79/dev-ap9x-pci.h
 create mode 100644 arch/mips/ath79/dev-dsa.c
 create mode 100644 arch/mips/ath79/dev-dsa.h
 create mode 100644 arch/mips/ath79/dev-eth.c
 create mode 100644 arch/mips/ath79/dev-eth.h
 create mode 100644 arch/mips/ath79/dev-m25p80.c
 create mode 100644 arch/mips/ath79/dev-m25p80.h
 create mode 100644 arch/mips/ath79/mach-alfa-ap96.c
 create mode 100644 arch/mips/ath79/mach-alfa-nx.c
 create mode 100644 arch/mips/ath79/mach-all0258n.c
 create mode 100644 arch/mips/ath79/mach-ap113.c
 create mode 100644 arch/mips/ath79/mach-ap83.c
 create mode 100644 arch/mips/ath79/mach-ap96.c
 create mode 100644 arch/mips/ath79/mach-aw-nr580.c
 create mode 100644 arch/mips/ath79/mach-dir-600-a1.c
 create mode 100644 arch/mips/ath79/mach-dir-615-c1.c
 create mode 100644 arch/mips/ath79/mach-dir-825-b1.c
 create mode 100644 arch/mips/ath79/mach-eap7660d.c
 create mode 100644 arch/mips/ath79/mach-ew-dorin.c
 create mode 100644 arch/mips/ath79/mach-hornet-ub.c
 create mode 100644 arch/mips/ath79/mach-ja76pf.c
 create mode 100644 arch/mips/ath79/mach-jwap003.c
 create mode 100644 arch/mips/ath79/mach-mzk-w04nu.c
 create mode 100644 arch/mips/ath79/mach-mzk-w300nh.c
 create mode 100644 arch/mips/ath79/mach-nbg460n.c
 create mode 100644 arch/mips/ath79/mach-om2p.c
 create mode 100644 arch/mips/ath79/mach-pb42.c
 create mode 100644 arch/mips/ath79/mach-pb92.c
 create mode 100644 arch/mips/ath79/mach-rb4xx.c
 create mode 100644 arch/mips/ath79/mach-rb750.c
 create mode 100644 arch/mips/ath79/mach-rw2458n.c
 create mode 100644 arch/mips/ath79/mach-tew-632brp.c
 create mode 100644 arch/mips/ath79/mach-tew-673gru.c
 create mode 100644 arch/mips/ath79/mach-tl-mr11u.c
 create mode 100644 arch/mips/ath79/mach-tl-mr3020.c
 create mode 100644 arch/mips/ath79/mach-tl-mr3x20.c
 create mode 100644 arch/mips/ath79/mach-tl-wa901nd-v2.c
 create mode 100644 arch/mips/ath79/mach-tl-wa901nd.c
 create mode 100644 arch/mips/ath79/mach-tl-wdr4300.c
 create mode 100644 arch/mips/ath79/mach-tl-wr1041n-v2.c
 create mode 100644 arch/mips/ath79/mach-tl-wr1043nd.c
 create mode 100644 arch/mips/ath79/mach-tl-wr2543n.c
 create mode 100644 arch/mips/ath79/mach-tl-wr703n.c
 create mode 100644 arch/mips/ath79/mach-tl-wr741nd-v4.c
 create mode 100644 arch/mips/ath79/mach-tl-wr741nd.c
 create mode 100644 arch/mips/ath79/mach-tl-wr841n.c
 create mode 100644 arch/mips/ath79/mach-tl-wr941nd.c
 create mode 100644 arch/mips/ath79/mach-ubnt.c
 create mode 100644 arch/mips/ath79/mach-whr-hp-g300n.c
 create mode 100644 arch/mips/ath79/mach-wndr3700.c
 create mode 100644 arch/mips/ath79/mach-wnr2000.c
 create mode 100644 arch/mips/ath79/mach-wp543.c
 create mode 100644 arch/mips/ath79/mach-wpe72.c
 create mode 100644 arch/mips/ath79/mach-wrt160nl.c
 create mode 100644 arch/mips/ath79/mach-wrt400n.c
 create mode 100644 arch/mips/ath79/mach-wzr-hp-ag300h.c
 create mode 100644 arch/mips/ath79/mach-wzr-hp-g300nh.c
 create mode 100644 arch/mips/ath79/mach-wzr-hp-g300nh2.c
 create mode 100644 arch/mips/ath79/mach-wzr-hp-g450h.c
 create mode 100644 arch/mips/ath79/mach-zcn-1523h.c
 create mode 100644 arch/mips/ath79/nvram.c
 create mode 100644 arch/mips/ath79/nvram.h
 create mode 100644 arch/mips/ath79/pci-ath9k-fixup.c
 create mode 100644 arch/mips/ath79/pci-ath9k-fixup.h
 create mode 100644 arch/mips/include/asm/fw/myloader/myloader.h
 create mode 100644 arch/mips/include/asm/mach-ath79/ag71xx_platform.h
 create mode 100644 arch/mips/include/asm/mach-ath79/mach-rb750.h
 create mode 100644 arch/mips/include/asm/mach-ath79/rb4xx_cpld.h

diff --git a/arch/mips/ath79/dev-ap9x-pci.c b/arch/mips/ath79/dev-ap9x-pci.c
new file mode 100644
index 0000000..c08e438
--- /dev/null
+++ b/arch/mips/ath79/dev-ap9x-pci.c
@@ -0,0 +1,153 @@
+/*
+ *  Atheros AP9X reference board PCI initialization
+ *
+ *  Copyright (C) 2009-2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/pci.h>
+#include <linux/ath9k_platform.h>
+#include <linux/delay.h>
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-ap9x-pci.h"
+#include "pci-ath9k-fixup.h"
+#include "pci.h"
+
+static struct ath9k_platform_data ap9x_wmac0_data = {
+	.led_pin = -1,
+};
+static struct ath9k_platform_data ap9x_wmac1_data = {
+	.led_pin = -1,
+};
+static char ap9x_wmac0_mac[6];
+static char ap9x_wmac1_mac[6];
+
+__init void ap9x_pci_setup_wmac_led_pin(unsigned wmac, int pin)
+{
+	switch (wmac) {
+	case 0:
+		ap9x_wmac0_data.led_pin = pin;
+		break;
+	case 1:
+		ap9x_wmac1_data.led_pin = pin;
+		break;
+	}
+}
+
+__init struct ath9k_platform_data *ap9x_pci_get_wmac_data(unsigned wmac)
+{
+	switch (wmac) {
+	case 0:
+		return &ap9x_wmac0_data;
+
+	case 1:
+		return &ap9x_wmac1_data;
+	}
+
+	return NULL;
+}
+
+__init void ap9x_pci_setup_wmac_gpio(unsigned wmac, u32 mask, u32 val)
+{
+	switch (wmac) {
+	case 0:
+		ap9x_wmac0_data.gpio_mask = mask;
+		ap9x_wmac0_data.gpio_val = val;
+		break;
+	case 1:
+		ap9x_wmac1_data.gpio_mask = mask;
+		ap9x_wmac1_data.gpio_val = val;
+		break;
+	}
+}
+
+__init void ap9x_pci_setup_wmac_leds(unsigned wmac, struct gpio_led *leds,
+				     int num_leds)
+{
+	switch (wmac) {
+	case 0:
+		ap9x_wmac0_data.leds = leds;
+		ap9x_wmac0_data.num_leds = num_leds;
+		break;
+	case 1:
+		ap9x_wmac1_data.leds = leds;
+		ap9x_wmac1_data.num_leds = num_leds;
+		break;
+	}
+}
+
+static int ap91_pci_plat_dev_init(struct pci_dev *dev)
+{
+	switch (PCI_SLOT(dev->devfn)) {
+	case 0:
+		dev->dev.platform_data = &ap9x_wmac0_data;
+		break;
+	}
+
+	return 0;
+}
+
+__init void ap91_pci_init(u8 *cal_data, u8 *mac_addr)
+{
+	if (cal_data)
+		memcpy(ap9x_wmac0_data.eeprom_data, cal_data,
+		       sizeof(ap9x_wmac0_data.eeprom_data));
+
+	if (mac_addr) {
+		memcpy(ap9x_wmac0_mac, mac_addr, sizeof(ap9x_wmac0_mac));
+		ap9x_wmac0_data.macaddr = ap9x_wmac0_mac;
+	}
+
+	ath79_pci_set_plat_dev_init(ap91_pci_plat_dev_init);
+	ath79_register_pci();
+
+	pci_enable_ath9k_fixup(0, ap9x_wmac0_data.eeprom_data);
+}
+
+static int ap94_pci_plat_dev_init(struct pci_dev *dev)
+{
+	switch (PCI_SLOT(dev->devfn)) {
+	case 17:
+		dev->dev.platform_data = &ap9x_wmac0_data;
+		break;
+
+	case 18:
+		dev->dev.platform_data = &ap9x_wmac1_data;
+		break;
+	}
+
+	return 0;
+}
+
+__init void ap94_pci_init(u8 *cal_data0, u8 *mac_addr0,
+			  u8 *cal_data1, u8 *mac_addr1)
+{
+	if (cal_data0)
+		memcpy(ap9x_wmac0_data.eeprom_data, cal_data0,
+		       sizeof(ap9x_wmac0_data.eeprom_data));
+
+	if (cal_data1)
+		memcpy(ap9x_wmac1_data.eeprom_data, cal_data1,
+		       sizeof(ap9x_wmac1_data.eeprom_data));
+
+	if (mac_addr0) {
+		memcpy(ap9x_wmac0_mac, mac_addr0, sizeof(ap9x_wmac0_mac));
+		ap9x_wmac0_data.macaddr = ap9x_wmac0_mac;
+	}
+
+	if (mac_addr1) {
+		memcpy(ap9x_wmac1_mac, mac_addr1, sizeof(ap9x_wmac1_mac));
+		ap9x_wmac1_data.macaddr = ap9x_wmac1_mac;
+	}
+
+	ath79_pci_set_plat_dev_init(ap94_pci_plat_dev_init);
+	ath79_register_pci();
+
+	pci_enable_ath9k_fixup(17, ap9x_wmac0_data.eeprom_data);
+	pci_enable_ath9k_fixup(18, ap9x_wmac1_data.eeprom_data);
+}
diff --git a/arch/mips/ath79/dev-ap9x-pci.h b/arch/mips/ath79/dev-ap9x-pci.h
new file mode 100644
index 0000000..3e60b52
--- /dev/null
+++ b/arch/mips/ath79/dev-ap9x-pci.h
@@ -0,0 +1,45 @@
+/*
+ *  Atheros AP9X reference board PCI initialization
+ *
+ *  Copyright (C) 2009-2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#ifndef _ATH79_DEV_AP9X_PCI_H
+#define _ATH79_DEV_AP9X_PCI_H
+
+struct gpio_led;
+struct ath9k_platform_data;
+
+#if defined(CONFIG_ATH79_DEV_AP9X_PCI)
+void ap9x_pci_setup_wmac_led_pin(unsigned wmac, int pin);
+void ap9x_pci_setup_wmac_gpio(unsigned wmac, u32 mask, u32 val);
+void ap9x_pci_setup_wmac_leds(unsigned wmac, struct gpio_led *leds,
+			      int num_leds);
+struct ath9k_platform_data *ap9x_pci_get_wmac_data(unsigned wmac);
+
+void ap91_pci_init(u8 *cal_data, u8 *mac_addr);
+void ap94_pci_init(u8 *cal_data0, u8 *mac_addr0,
+		   u8 *cal_data1, u8 *mac_addr1);
+
+#else
+static inline void ap9x_pci_setup_wmac_led_pin(unsigned wmac, int pin) {}
+static inline void ap9x_pci_setup_wmac_gpio(unsigned wmac,
+					    u32 mask, u32 val) {}
+static inline void ap9x_pci_setup_wmac_leds(unsigned wmac,
+					    struct gpio_led *leds,
+					    int num_leds) {}
+static inline struct ath9k_platform_data *ap9x_pci_get_wmac_data(unsigned wmac)
+{
+	return NULL;
+}
+
+static inline void ap91_pci_init(u8 *cal_data, u8 *mac_addr) {}
+static inline void ap94_pci_init(u8 *cal_data0, u8 *mac_addr0,
+				 u8 *cal_data1, u8 *mac_addr1) {}
+#endif
+
+#endif /* _ATH79_DEV_AP9X_PCI_H */
diff --git a/arch/mips/ath79/dev-dsa.c b/arch/mips/ath79/dev-dsa.c
new file mode 100644
index 0000000..1764147
--- /dev/null
+++ b/arch/mips/ath79/dev-dsa.c
@@ -0,0 +1,36 @@
+/*
+ *  Atheros AR71xx DSA switch device support
+ *
+ *  Copyright (C) 2008-2012 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/init.h>
+#include <linux/platform_device.h>
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-dsa.h"
+
+static struct platform_device ar71xx_dsa_switch_device = {
+	.name		= "dsa",
+	.id		= 0,
+};
+
+void __init ath79_register_dsa(struct device *netdev,
+			       struct device *miidev,
+			       struct dsa_platform_data *d)
+{
+	int i;
+
+	d->netdev = netdev;
+	for (i = 0; i < d->nr_chips; i++)
+		d->chip[i].mii_bus = miidev;
+
+	ar71xx_dsa_switch_device.dev.platform_data = d;
+	platform_device_register(&ar71xx_dsa_switch_device);
+}
diff --git a/arch/mips/ath79/dev-dsa.h b/arch/mips/ath79/dev-dsa.h
new file mode 100644
index 0000000..3730202e
--- /dev/null
+++ b/arch/mips/ath79/dev-dsa.h
@@ -0,0 +1,21 @@
+/*
+ *  Atheros AR71xx DSA switch device support
+ *
+ *  Copyright (C) 2008-2009 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#ifndef _ATH79_DEV_DSA_H
+#define _ATH79_DEV_DSA_H
+
+#include <net/dsa.h>
+
+void ath79_register_dsa(struct device *netdev,
+			struct device *miidev,
+			struct dsa_platform_data *d);
+
+#endif /* _ATH79_DEV_DSA_H */
diff --git a/arch/mips/ath79/dev-eth.c b/arch/mips/ath79/dev-eth.c
new file mode 100644
index 0000000..e6a5076
--- /dev/null
+++ b/arch/mips/ath79/dev-eth.c
@@ -0,0 +1,990 @@
+/*
+ *  Atheros AR71xx SoC platform devices
+ *
+ *  Copyright (C) 2010-2011 Jaiganesh Narayanan <jnarayanan@atheros.com>
+ *  Copyright (C) 2008-2012 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  Parts of this file are based on Atheros 2.6.15 BSP
+ *  Parts of this file are based on Atheros 2.6.31 BSP
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/etherdevice.h>
+#include <linux/platform_device.h>
+#include <linux/serial_8250.h>
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+#include <asm/mach-ath79/irq.h>
+
+#include "common.h"
+#include "dev-eth.h"
+
+unsigned char ath79_mac_base[ETH_ALEN] __initdata;
+
+static struct resource ath79_mdio0_resources[] = {
+	{
+		.name	= "mdio_base",
+		.flags	= IORESOURCE_MEM,
+		.start	= AR71XX_GE0_BASE,
+		.end	= AR71XX_GE0_BASE + 0x200 - 1,
+	}
+};
+
+static struct ag71xx_mdio_platform_data ath79_mdio0_data;
+
+struct platform_device ath79_mdio0_device = {
+	.name		= "ag71xx-mdio",
+	.id		= 0,
+	.resource	= ath79_mdio0_resources,
+	.num_resources	= ARRAY_SIZE(ath79_mdio0_resources),
+	.dev = {
+		.platform_data = &ath79_mdio0_data,
+	},
+};
+
+static struct resource ath79_mdio1_resources[] = {
+	{
+		.name	= "mdio_base",
+		.flags	= IORESOURCE_MEM,
+		.start	= AR71XX_GE1_BASE,
+		.end	= AR71XX_GE1_BASE + 0x200 - 1,
+	}
+};
+
+static struct ag71xx_mdio_platform_data ath79_mdio1_data;
+
+struct platform_device ath79_mdio1_device = {
+	.name		= "ag71xx-mdio",
+	.id		= 1,
+	.resource	= ath79_mdio1_resources,
+	.num_resources	= ARRAY_SIZE(ath79_mdio1_resources),
+	.dev = {
+		.platform_data = &ath79_mdio1_data,
+	},
+};
+
+static void ath79_set_pll(u32 cfg_reg, u32 pll_reg, u32 pll_val, u32 shift)
+{
+	void __iomem *base;
+	u32 t;
+
+	base = ioremap_nocache(AR71XX_PLL_BASE, AR71XX_PLL_SIZE);
+
+	t = __raw_readl(base + cfg_reg);
+	t &= ~(3 << shift);
+	t |=  (2 << shift);
+	__raw_writel(t, base + cfg_reg);
+	udelay(100);
+
+	__raw_writel(pll_val, base + pll_reg);
+
+	t |= (3 << shift);
+	__raw_writel(t, base + cfg_reg);
+	udelay(100);
+
+	t &= ~(3 << shift);
+	__raw_writel(t, base + cfg_reg);
+	udelay(100);
+
+	printk(KERN_DEBUG "ar71xx: pll_reg %#x: %#x\n",
+		(unsigned int)(base + pll_reg), __raw_readl(base + pll_reg));
+
+	iounmap(base);
+}
+
+static void __init ath79_mii_ctrl_set_if(unsigned int reg,
+					  unsigned int mii_if)
+{
+	void __iomem *base;
+	u32 t;
+
+	base = ioremap(AR71XX_MII_BASE, AR71XX_MII_SIZE);
+
+	t = __raw_readl(base + reg);
+	t &= ~(AR71XX_MII_CTRL_IF_MASK);
+	t |= (mii_if & AR71XX_MII_CTRL_IF_MASK);
+	__raw_writel(t, base + reg);
+
+	iounmap(base);
+}
+
+static void ath79_mii_ctrl_set_speed(unsigned int reg, unsigned int speed)
+{
+	void __iomem *base;
+	unsigned int mii_speed;
+	u32 t;
+
+	switch (speed) {
+	case SPEED_10:
+		mii_speed =  AR71XX_MII_CTRL_SPEED_10;
+		break;
+	case SPEED_100:
+		mii_speed =  AR71XX_MII_CTRL_SPEED_100;
+		break;
+	case SPEED_1000:
+		mii_speed =  AR71XX_MII_CTRL_SPEED_1000;
+		break;
+	default:
+		BUG();
+	}
+
+	base = ioremap(AR71XX_MII_BASE, AR71XX_MII_SIZE);
+
+	t = __raw_readl(base + reg);
+	t &= ~(AR71XX_MII_CTRL_SPEED_MASK << AR71XX_MII_CTRL_SPEED_SHIFT);
+	t |= mii_speed  << AR71XX_MII_CTRL_SPEED_SHIFT;
+	__raw_writel(t, base + reg);
+
+	iounmap(base);
+}
+
+void __init ath79_register_mdio(unsigned int id, u32 phy_mask)
+{
+	struct platform_device *mdio_dev;
+	struct ag71xx_mdio_platform_data *mdio_data;
+	unsigned int max_id;
+
+	if (ath79_soc == ATH79_SOC_AR9341 ||
+	    ath79_soc == ATH79_SOC_AR9342 ||
+	    ath79_soc == ATH79_SOC_AR9344 ||
+	    ath79_soc == ATH79_SOC_QCA9558)
+		max_id = 1;
+	else
+		max_id = 0;
+
+	if (id > max_id) {
+		printk(KERN_ERR "ar71xx: invalid MDIO id %u\n", id);
+		return;
+	}
+
+	switch (ath79_soc) {
+	case ATH79_SOC_AR7241:
+	case ATH79_SOC_AR9330:
+	case ATH79_SOC_AR9331:
+		mdio_dev = &ath79_mdio1_device;
+		mdio_data = &ath79_mdio1_data;
+		break;
+
+	case ATH79_SOC_AR9341:
+	case ATH79_SOC_AR9342:
+	case ATH79_SOC_AR9344:
+	case ATH79_SOC_QCA9558:
+		if (id == 0) {
+			mdio_dev = &ath79_mdio0_device;
+			mdio_data = &ath79_mdio0_data;
+		} else {
+			mdio_dev = &ath79_mdio1_device;
+			mdio_data = &ath79_mdio1_data;
+		}
+		break;
+
+	case ATH79_SOC_AR7242:
+		ath79_set_pll(AR71XX_PLL_REG_SEC_CONFIG,
+			       AR7242_PLL_REG_ETH0_INT_CLOCK, 0x62000000,
+			       AR71XX_ETH0_PLL_SHIFT);
+		/* fall through */
+	default:
+		mdio_dev = &ath79_mdio0_device;
+		mdio_data = &ath79_mdio0_data;
+		break;
+	}
+
+	mdio_data->phy_mask = phy_mask;
+
+	switch (ath79_soc) {
+	case ATH79_SOC_AR7240:
+		mdio_data->is_ar7240 = 1;
+		/* fall through */
+	case ATH79_SOC_AR7241:
+		mdio_data->builtin_switch = 1;
+		break;
+
+	case ATH79_SOC_AR9330:
+		mdio_data->is_ar9330 = 1;
+		/* fall through */
+	case ATH79_SOC_AR9331:
+		mdio_data->builtin_switch = 1;
+		break;
+
+	case ATH79_SOC_AR9341:
+	case ATH79_SOC_AR9342:
+	case ATH79_SOC_AR9344:
+	case ATH79_SOC_QCA9558:
+		if (id == 1)
+			mdio_data->builtin_switch = 1;
+		mdio_data->is_ar934x = 1;
+		break;
+
+	default:
+		break;
+	}
+
+	platform_device_register(mdio_dev);
+}
+
+struct ath79_eth_pll_data ath79_eth0_pll_data;
+struct ath79_eth_pll_data ath79_eth1_pll_data;
+
+static u32 ath79_get_eth_pll(unsigned int mac, int speed)
+{
+	struct ath79_eth_pll_data *pll_data;
+	u32 pll_val;
+
+	switch (mac) {
+	case 0:
+		pll_data = &ath79_eth0_pll_data;
+		break;
+	case 1:
+		pll_data = &ath79_eth1_pll_data;
+		break;
+	default:
+		BUG();
+	}
+
+	switch (speed) {
+	case SPEED_10:
+		pll_val = pll_data->pll_10;
+		break;
+	case SPEED_100:
+		pll_val = pll_data->pll_100;
+		break;
+	case SPEED_1000:
+		pll_val = pll_data->pll_1000;
+		break;
+	default:
+		BUG();
+	}
+
+	return pll_val;
+}
+
+static void ath79_set_speed_ge0(int speed)
+{
+	u32 val = ath79_get_eth_pll(0, speed);
+
+	ath79_set_pll(AR71XX_PLL_REG_SEC_CONFIG, AR71XX_PLL_REG_ETH0_INT_CLOCK,
+			val, AR71XX_ETH0_PLL_SHIFT);
+	ath79_mii_ctrl_set_speed(AR71XX_MII_REG_MII0_CTRL, speed);
+}
+
+static void ath79_set_speed_ge1(int speed)
+{
+	u32 val = ath79_get_eth_pll(1, speed);
+
+	ath79_set_pll(AR71XX_PLL_REG_SEC_CONFIG, AR71XX_PLL_REG_ETH1_INT_CLOCK,
+			 val, AR71XX_ETH1_PLL_SHIFT);
+	ath79_mii_ctrl_set_speed(AR71XX_MII_REG_MII1_CTRL, speed);
+}
+
+static void ar7242_set_speed_ge0(int speed)
+{
+	u32 val = ath79_get_eth_pll(0, speed);
+	void __iomem *base;
+
+	base = ioremap_nocache(AR71XX_PLL_BASE, AR71XX_PLL_SIZE);
+	__raw_writel(val, base + AR7242_PLL_REG_ETH0_INT_CLOCK);
+	iounmap(base);
+}
+
+static void ar91xx_set_speed_ge0(int speed)
+{
+	u32 val = ath79_get_eth_pll(0, speed);
+
+	ath79_set_pll(AR913X_PLL_REG_ETH_CONFIG, AR913X_PLL_REG_ETH0_INT_CLOCK,
+			 val, AR913X_ETH0_PLL_SHIFT);
+	ath79_mii_ctrl_set_speed(AR71XX_MII_REG_MII0_CTRL, speed);
+}
+
+static void ar91xx_set_speed_ge1(int speed)
+{
+	u32 val = ath79_get_eth_pll(1, speed);
+
+	ath79_set_pll(AR913X_PLL_REG_ETH_CONFIG, AR913X_PLL_REG_ETH1_INT_CLOCK,
+			 val, AR913X_ETH1_PLL_SHIFT);
+	ath79_mii_ctrl_set_speed(AR71XX_MII_REG_MII1_CTRL, speed);
+}
+
+static void ar934x_set_speed_ge0(int speed)
+{
+	void __iomem *base;
+	u32 val = ath79_get_eth_pll(0, speed);
+
+	base = ioremap_nocache(AR71XX_PLL_BASE, AR71XX_PLL_SIZE);
+	__raw_writel(val, base + AR934X_PLL_ETH_XMII_CONTROL_REG);
+	iounmap(base);
+}
+
+static void ath79_set_speed_dummy(int speed)
+{
+}
+
+static void ath79_ddr_no_flush(void)
+{
+}
+
+static void ath79_ddr_flush_ge0(void)
+{
+	ath79_ddr_wb_flush(AR71XX_DDR_REG_FLUSH_GE0);
+}
+
+static void ath79_ddr_flush_ge1(void)
+{
+	ath79_ddr_wb_flush(AR71XX_DDR_REG_FLUSH_GE1);
+}
+
+static void ar724x_ddr_flush_ge0(void)
+{
+	ath79_ddr_wb_flush(AR724X_DDR_REG_FLUSH_GE0);
+}
+
+static void ar724x_ddr_flush_ge1(void)
+{
+	ath79_ddr_wb_flush(AR724X_DDR_REG_FLUSH_GE1);
+}
+
+static void ar91xx_ddr_flush_ge0(void)
+{
+	ath79_ddr_wb_flush(AR913X_DDR_REG_FLUSH_GE0);
+}
+
+static void ar91xx_ddr_flush_ge1(void)
+{
+	ath79_ddr_wb_flush(AR913X_DDR_REG_FLUSH_GE1);
+}
+
+static void ar933x_ddr_flush_ge0(void)
+{
+	ath79_ddr_wb_flush(AR933X_DDR_REG_FLUSH_GE0);
+}
+
+static void ar933x_ddr_flush_ge1(void)
+{
+	ath79_ddr_wb_flush(AR933X_DDR_REG_FLUSH_GE1);
+}
+
+static struct resource ath79_eth0_resources[] = {
+	{
+		.name	= "mac_base",
+		.flags	= IORESOURCE_MEM,
+		.start	= AR71XX_GE0_BASE,
+		.end	= AR71XX_GE0_BASE + 0x200 - 1,
+	}, {
+		.name	= "mac_irq",
+		.flags	= IORESOURCE_IRQ,
+		.start	= ATH79_CPU_IRQ_GE0,
+		.end	= ATH79_CPU_IRQ_GE0,
+	},
+};
+
+struct ag71xx_platform_data ath79_eth0_data = {
+	.reset_bit	= AR71XX_RESET_GE0_MAC,
+};
+
+struct platform_device ath79_eth0_device = {
+	.name		= "ag71xx",
+	.id		= 0,
+	.resource	= ath79_eth0_resources,
+	.num_resources	= ARRAY_SIZE(ath79_eth0_resources),
+	.dev = {
+		.platform_data = &ath79_eth0_data,
+	},
+};
+
+static struct resource ath79_eth1_resources[] = {
+	{
+		.name	= "mac_base",
+		.flags	= IORESOURCE_MEM,
+		.start	= AR71XX_GE1_BASE,
+		.end	= AR71XX_GE1_BASE + 0x200 - 1,
+	}, {
+		.name	= "mac_irq",
+		.flags	= IORESOURCE_IRQ,
+		.start	= ATH79_CPU_IRQ_GE1,
+		.end	= ATH79_CPU_IRQ_GE1,
+	},
+};
+
+struct ag71xx_platform_data ath79_eth1_data = {
+	.reset_bit	= AR71XX_RESET_GE1_MAC,
+};
+
+struct platform_device ath79_eth1_device = {
+	.name		= "ag71xx",
+	.id		= 1,
+	.resource	= ath79_eth1_resources,
+	.num_resources	= ARRAY_SIZE(ath79_eth1_resources),
+	.dev = {
+		.platform_data = &ath79_eth1_data,
+	},
+};
+
+struct ag71xx_switch_platform_data ath79_switch_data;
+
+#define AR71XX_PLL_VAL_1000	0x00110000
+#define AR71XX_PLL_VAL_100	0x00001099
+#define AR71XX_PLL_VAL_10	0x00991099
+
+#define AR724X_PLL_VAL_1000	0x00110000
+#define AR724X_PLL_VAL_100	0x00001099
+#define AR724X_PLL_VAL_10	0x00991099
+
+#define AR7242_PLL_VAL_1000	0x16000000
+#define AR7242_PLL_VAL_100	0x00000101
+#define AR7242_PLL_VAL_10	0x00001616
+
+#define AR913X_PLL_VAL_1000	0x1a000000
+#define AR913X_PLL_VAL_100	0x13000a44
+#define AR913X_PLL_VAL_10	0x00441099
+
+#define AR933X_PLL_VAL_1000	0x00110000
+#define AR933X_PLL_VAL_100	0x00001099
+#define AR933X_PLL_VAL_10	0x00991099
+
+#define AR934X_PLL_VAL_1000	0x16000000
+#define AR934X_PLL_VAL_100	0x00000101
+#define AR934X_PLL_VAL_10	0x00001616
+
+static void __init ath79_init_eth_pll_data(unsigned int id)
+{
+	struct ath79_eth_pll_data *pll_data;
+	u32 pll_10, pll_100, pll_1000;
+
+	switch (id) {
+	case 0:
+		pll_data = &ath79_eth0_pll_data;
+		break;
+	case 1:
+		pll_data = &ath79_eth1_pll_data;
+		break;
+	default:
+		BUG();
+	}
+
+	switch (ath79_soc) {
+	case ATH79_SOC_AR7130:
+	case ATH79_SOC_AR7141:
+	case ATH79_SOC_AR7161:
+		pll_10 = AR71XX_PLL_VAL_10;
+		pll_100 = AR71XX_PLL_VAL_100;
+		pll_1000 = AR71XX_PLL_VAL_1000;
+		break;
+
+	case ATH79_SOC_AR7240:
+	case ATH79_SOC_AR7241:
+		pll_10 = AR724X_PLL_VAL_10;
+		pll_100 = AR724X_PLL_VAL_100;
+		pll_1000 = AR724X_PLL_VAL_1000;
+		break;
+
+	case ATH79_SOC_AR7242:
+		pll_10 = AR7242_PLL_VAL_10;
+		pll_100 = AR7242_PLL_VAL_100;
+		pll_1000 = AR7242_PLL_VAL_1000;
+		break;
+
+	case ATH79_SOC_AR9130:
+	case ATH79_SOC_AR9132:
+		pll_10 = AR913X_PLL_VAL_10;
+		pll_100 = AR913X_PLL_VAL_100;
+		pll_1000 = AR913X_PLL_VAL_1000;
+		break;
+
+	case ATH79_SOC_AR9330:
+	case ATH79_SOC_AR9331:
+		pll_10 = AR933X_PLL_VAL_10;
+		pll_100 = AR933X_PLL_VAL_100;
+		pll_1000 = AR933X_PLL_VAL_1000;
+		break;
+
+	case ATH79_SOC_AR9341:
+	case ATH79_SOC_AR9342:
+	case ATH79_SOC_AR9344:
+	case ATH79_SOC_QCA9558:
+		pll_10 = AR934X_PLL_VAL_10;
+		pll_100 = AR934X_PLL_VAL_100;
+		pll_1000 = AR934X_PLL_VAL_1000;
+		break;
+
+	default:
+		BUG();
+	}
+
+	if (!pll_data->pll_10)
+		pll_data->pll_10 = pll_10;
+
+	if (!pll_data->pll_100)
+		pll_data->pll_100 = pll_100;
+
+	if (!pll_data->pll_1000)
+		pll_data->pll_1000 = pll_1000;
+}
+
+static int __init ath79_setup_phy_if_mode(unsigned int id,
+					   struct ag71xx_platform_data *pdata)
+{
+	unsigned int mii_if;
+
+	switch (id) {
+	case 0:
+		switch (ath79_soc) {
+		case ATH79_SOC_AR7130:
+		case ATH79_SOC_AR7141:
+		case ATH79_SOC_AR7161:
+		case ATH79_SOC_AR9130:
+		case ATH79_SOC_AR9132:
+			switch (pdata->phy_if_mode) {
+			case PHY_INTERFACE_MODE_MII:
+				mii_if = AR71XX_MII0_CTRL_IF_MII;
+				break;
+			case PHY_INTERFACE_MODE_GMII:
+				mii_if = AR71XX_MII0_CTRL_IF_GMII;
+				break;
+			case PHY_INTERFACE_MODE_RGMII:
+				mii_if = AR71XX_MII0_CTRL_IF_RGMII;
+				break;
+			case PHY_INTERFACE_MODE_RMII:
+				mii_if = AR71XX_MII0_CTRL_IF_RMII;
+				break;
+			default:
+				return -EINVAL;
+			}
+			ath79_mii_ctrl_set_if(AR71XX_MII_REG_MII0_CTRL, mii_if);
+			break;
+
+		case ATH79_SOC_AR7240:
+		case ATH79_SOC_AR7241:
+		case ATH79_SOC_AR9330:
+		case ATH79_SOC_AR9331:
+			pdata->phy_if_mode = PHY_INTERFACE_MODE_MII;
+			break;
+
+		case ATH79_SOC_AR7242:
+			/* FIXME */
+
+		case ATH79_SOC_AR9341:
+		case ATH79_SOC_AR9342:
+		case ATH79_SOC_AR9344:
+		case ATH79_SOC_QCA9558:
+			switch (pdata->phy_if_mode) {
+			case PHY_INTERFACE_MODE_MII:
+			case PHY_INTERFACE_MODE_GMII:
+			case PHY_INTERFACE_MODE_RGMII:
+			case PHY_INTERFACE_MODE_RMII:
+				break;
+			default:
+				return -EINVAL;
+			}
+			break;
+
+		default:
+			BUG();
+		}
+		break;
+	case 1:
+		switch (ath79_soc) {
+		case ATH79_SOC_AR7130:
+		case ATH79_SOC_AR7141:
+		case ATH79_SOC_AR7161:
+		case ATH79_SOC_AR9130:
+		case ATH79_SOC_AR9132:
+			switch (pdata->phy_if_mode) {
+			case PHY_INTERFACE_MODE_RMII:
+				mii_if = AR71XX_MII1_CTRL_IF_RMII;
+				break;
+			case PHY_INTERFACE_MODE_RGMII:
+				mii_if = AR71XX_MII1_CTRL_IF_RGMII;
+				break;
+			default:
+				return -EINVAL;
+			}
+			ath79_mii_ctrl_set_if(AR71XX_MII_REG_MII1_CTRL, mii_if);
+			break;
+
+		case ATH79_SOC_AR7240:
+		case ATH79_SOC_AR7241:
+		case ATH79_SOC_AR9330:
+		case ATH79_SOC_AR9331:
+			pdata->phy_if_mode = PHY_INTERFACE_MODE_GMII;
+			break;
+
+		case ATH79_SOC_AR7242:
+			/* FIXME */
+
+		case ATH79_SOC_AR9341:
+		case ATH79_SOC_AR9342:
+		case ATH79_SOC_AR9344:
+		case ATH79_SOC_QCA9558:
+			switch (pdata->phy_if_mode) {
+			case PHY_INTERFACE_MODE_MII:
+			case PHY_INTERFACE_MODE_GMII:
+				break;
+			default:
+				return -EINVAL;
+			}
+			break;
+
+		default:
+			BUG();
+		}
+		break;
+	}
+
+	return 0;
+}
+
+void __init ath79_setup_ar933x_phy4_switch(bool mac, bool mdio)
+{
+	void __iomem *base;
+	u32 t;
+
+	base = ioremap(AR933X_GMAC_BASE, AR933X_GMAC_SIZE);
+
+	t = __raw_readl(base + AR933X_GMAC_REG_ETH_CFG);
+	t &= ~(AR933X_ETH_CFG_SW_PHY_SWAP | AR933X_ETH_CFG_SW_PHY_ADDR_SWAP);
+	if (mac)
+		t |= AR933X_ETH_CFG_SW_PHY_SWAP;
+	if (mdio)
+		t |= AR933X_ETH_CFG_SW_PHY_ADDR_SWAP;
+	__raw_writel(t, base + AR933X_GMAC_REG_ETH_CFG);
+
+	iounmap(base);
+}
+
+static int ath79_eth_instance __initdata;
+void __init ath79_register_eth(unsigned int id)
+{
+	struct platform_device *pdev;
+	struct ag71xx_platform_data *pdata;
+	int err;
+
+	if (id > 1) {
+		printk(KERN_ERR "ar71xx: invalid ethernet id %d\n", id);
+		return;
+	}
+
+	ath79_init_eth_pll_data(id);
+
+	if (id == 0)
+		pdev = &ath79_eth0_device;
+	else
+		pdev = &ath79_eth1_device;
+
+	pdata = pdev->dev.platform_data;
+
+	err = ath79_setup_phy_if_mode(id, pdata);
+	if (err) {
+		printk(KERN_ERR
+		       "ar71xx: invalid PHY interface mode for GE%u\n", id);
+		return;
+	}
+
+	switch (ath79_soc) {
+	case ATH79_SOC_AR7130:
+		if (id == 0) {
+			pdata->ddr_flush = ath79_ddr_flush_ge0;
+			pdata->set_speed = ath79_set_speed_ge0;
+		} else {
+			pdata->ddr_flush = ath79_ddr_flush_ge1;
+			pdata->set_speed = ath79_set_speed_ge1;
+		}
+		break;
+
+	case ATH79_SOC_AR7141:
+	case ATH79_SOC_AR7161:
+		if (id == 0) {
+			pdata->ddr_flush = ath79_ddr_flush_ge0;
+			pdata->set_speed = ath79_set_speed_ge0;
+		} else {
+			pdata->ddr_flush = ath79_ddr_flush_ge1;
+			pdata->set_speed = ath79_set_speed_ge1;
+		}
+		pdata->has_gbit = 1;
+		break;
+
+	case ATH79_SOC_AR7242:
+		if (id == 0) {
+			pdata->reset_bit |= AR724X_RESET_GE0_MDIO |
+					    AR71XX_RESET_GE0_PHY;
+			pdata->ddr_flush = ar724x_ddr_flush_ge0;
+			pdata->set_speed = ar7242_set_speed_ge0;
+		} else {
+			pdata->reset_bit |= AR724X_RESET_GE1_MDIO |
+					    AR71XX_RESET_GE1_PHY;
+			pdata->ddr_flush = ar724x_ddr_flush_ge1;
+			pdata->set_speed = ath79_set_speed_dummy;
+		}
+		pdata->has_gbit = 1;
+		pdata->is_ar724x = 1;
+
+		if (!pdata->fifo_cfg1)
+			pdata->fifo_cfg1 = 0x0010ffff;
+		if (!pdata->fifo_cfg2)
+			pdata->fifo_cfg2 = 0x015500aa;
+		if (!pdata->fifo_cfg3)
+			pdata->fifo_cfg3 = 0x01f00140;
+		break;
+
+	case ATH79_SOC_AR7241:
+		if (id == 0)
+			pdata->reset_bit |= AR724X_RESET_GE0_MDIO;
+		else
+			pdata->reset_bit |= AR724X_RESET_GE1_MDIO;
+		/* fall through */
+	case ATH79_SOC_AR7240:
+		if (id == 0) {
+			pdata->reset_bit |= AR71XX_RESET_GE0_PHY;
+			pdata->ddr_flush = ar724x_ddr_flush_ge0;
+			pdata->set_speed = ath79_set_speed_dummy;
+
+			pdata->phy_mask = BIT(4);
+		} else {
+			pdata->reset_bit |= AR71XX_RESET_GE1_PHY;
+			pdata->ddr_flush = ar724x_ddr_flush_ge1;
+			pdata->set_speed = ath79_set_speed_dummy;
+
+			pdata->speed = SPEED_1000;
+			pdata->duplex = DUPLEX_FULL;
+			pdata->switch_data = &ath79_switch_data;
+
+			ath79_switch_data.phy_poll_mask |= BIT(4);
+		}
+		pdata->has_gbit = 1;
+		pdata->is_ar724x = 1;
+		if (ath79_soc == ATH79_SOC_AR7240)
+			pdata->is_ar7240 = 1;
+
+		if (!pdata->fifo_cfg1)
+			pdata->fifo_cfg1 = 0x0010ffff;
+		if (!pdata->fifo_cfg2)
+			pdata->fifo_cfg2 = 0x015500aa;
+		if (!pdata->fifo_cfg3)
+			pdata->fifo_cfg3 = 0x01f00140;
+		break;
+
+	case ATH79_SOC_AR9130:
+		if (id == 0) {
+			pdata->ddr_flush = ar91xx_ddr_flush_ge0;
+			pdata->set_speed = ar91xx_set_speed_ge0;
+		} else {
+			pdata->ddr_flush = ar91xx_ddr_flush_ge1;
+			pdata->set_speed = ar91xx_set_speed_ge1;
+		}
+		pdata->is_ar91xx = 1;
+		break;
+
+	case ATH79_SOC_AR9132:
+		if (id == 0) {
+			pdata->ddr_flush = ar91xx_ddr_flush_ge0;
+			pdata->set_speed = ar91xx_set_speed_ge0;
+		} else {
+			pdata->ddr_flush = ar91xx_ddr_flush_ge1;
+			pdata->set_speed = ar91xx_set_speed_ge1;
+		}
+		pdata->is_ar91xx = 1;
+		pdata->has_gbit = 1;
+		break;
+
+	case ATH79_SOC_AR9330:
+	case ATH79_SOC_AR9331:
+		if (id == 0) {
+			pdata->reset_bit = AR933X_RESET_GE0_MAC |
+					   AR933X_RESET_GE0_MDIO;
+			pdata->ddr_flush = ar933x_ddr_flush_ge0;
+			pdata->set_speed = ath79_set_speed_dummy;
+
+			pdata->phy_mask = BIT(4);
+		} else {
+			pdata->reset_bit = AR933X_RESET_GE1_MAC |
+					   AR933X_RESET_GE1_MDIO;
+			pdata->ddr_flush = ar933x_ddr_flush_ge1;
+			pdata->set_speed = ath79_set_speed_dummy;
+
+			pdata->speed = SPEED_1000;
+			pdata->duplex = DUPLEX_FULL;
+			pdata->switch_data = &ath79_switch_data;
+
+			ath79_switch_data.phy_poll_mask |= BIT(4);
+		}
+
+		pdata->has_gbit = 1;
+		pdata->is_ar724x = 1;
+
+		if (!pdata->fifo_cfg1)
+			pdata->fifo_cfg1 = 0x0010ffff;
+		if (!pdata->fifo_cfg2)
+			pdata->fifo_cfg2 = 0x015500aa;
+		if (!pdata->fifo_cfg3)
+			pdata->fifo_cfg3 = 0x01f00140;
+		break;
+
+	case ATH79_SOC_AR9341:
+	case ATH79_SOC_AR9342:
+	case ATH79_SOC_AR9344:
+	case ATH79_SOC_QCA9558:
+		if (id == 0) {
+			pdata->reset_bit = AR934X_RESET_GE0_MAC |
+					   AR934X_RESET_GE0_MDIO;
+			pdata->set_speed = ar934x_set_speed_ge0;
+		} else {
+			pdata->reset_bit = AR934X_RESET_GE1_MAC |
+					   AR934X_RESET_GE1_MDIO;
+			pdata->set_speed = ath79_set_speed_dummy;
+
+			pdata->switch_data = &ath79_switch_data;
+
+			/* reset the built-in switch */
+			ath79_device_reset_set(AR934X_RESET_ETH_SWITCH);
+			ath79_device_reset_clear(AR934X_RESET_ETH_SWITCH);
+		}
+
+		pdata->ddr_flush = ath79_ddr_no_flush;
+		pdata->has_gbit = 1;
+		pdata->is_ar724x = 1;
+
+		if (!pdata->fifo_cfg1)
+			pdata->fifo_cfg1 = 0x0010ffff;
+		if (!pdata->fifo_cfg2)
+			pdata->fifo_cfg2 = 0x015500aa;
+		if (!pdata->fifo_cfg3)
+			pdata->fifo_cfg3 = 0x01f00140;
+		break;
+
+	default:
+		BUG();
+	}
+
+	switch (pdata->phy_if_mode) {
+	case PHY_INTERFACE_MODE_GMII:
+	case PHY_INTERFACE_MODE_RGMII:
+		if (!pdata->has_gbit) {
+			printk(KERN_ERR "ar71xx: no gbit available on eth%d\n",
+					id);
+			return;
+		}
+		/* fallthrough */
+	default:
+		break;
+	}
+
+	if (!is_valid_ether_addr(pdata->mac_addr)) {
+		random_ether_addr(pdata->mac_addr);
+		printk(KERN_DEBUG
+			"ar71xx: using random MAC address for eth%d\n",
+			ath79_eth_instance);
+	}
+
+	if (pdata->mii_bus_dev == NULL) {
+		switch (ath79_soc) {
+		case ATH79_SOC_AR9341:
+		case ATH79_SOC_AR9342:
+		case ATH79_SOC_AR9344:
+		case ATH79_SOC_QCA9558:
+			if (id == 0)
+				pdata->mii_bus_dev = &ath79_mdio0_device.dev;
+			else
+				pdata->mii_bus_dev = &ath79_mdio1_device.dev;
+			break;
+
+		case ATH79_SOC_AR7241:
+		case ATH79_SOC_AR9330:
+		case ATH79_SOC_AR9331:
+			pdata->mii_bus_dev = &ath79_mdio1_device.dev;
+			break;
+
+		default:
+			pdata->mii_bus_dev = &ath79_mdio0_device.dev;
+			break;
+		}
+	}
+
+	/* Reset the device */
+	ath79_device_reset_set(pdata->reset_bit);
+	mdelay(100);
+
+	ath79_device_reset_clear(pdata->reset_bit);
+	mdelay(100);
+
+	platform_device_register(pdev);
+	ath79_eth_instance++;
+}
+
+void __init ath79_set_mac_base(unsigned char *mac)
+{
+	memcpy(ath79_mac_base, mac, ETH_ALEN);
+}
+
+void __init ath79_parse_mac_addr(char *mac_str)
+{
+	u8 tmp[ETH_ALEN];
+	int t;
+
+	t = sscanf(mac_str, "%02hhx:%02hhx:%02hhx:%02hhx:%02hhx:%02hhx",
+			&tmp[0], &tmp[1], &tmp[2], &tmp[3], &tmp[4], &tmp[5]);
+
+	if (t != ETH_ALEN)
+		t = sscanf(mac_str, "%02hhx.%02hhx.%02hhx.%02hhx.%02hhx.%02hhx",
+			&tmp[0], &tmp[1], &tmp[2], &tmp[3], &tmp[4], &tmp[5]);
+
+	if (t == ETH_ALEN)
+		ath79_set_mac_base(tmp);
+	else
+		printk(KERN_DEBUG "ar71xx: failed to parse mac address "
+				"\"%s\"\n", mac_str);
+}
+
+static int __init ath79_ethaddr_setup(char *str)
+{
+	ath79_parse_mac_addr(str);
+	return 1;
+}
+__setup("ethaddr=", ath79_ethaddr_setup);
+
+static int __init ath79_kmac_setup(char *str)
+{
+	ath79_parse_mac_addr(str);
+	return 1;
+}
+__setup("kmac=", ath79_kmac_setup);
+
+void __init ath79_init_mac(unsigned char *dst, const unsigned char *src,
+			    int offset)
+{
+	int t;
+
+	if (!is_valid_ether_addr(src)) {
+		memset(dst, '\0', ETH_ALEN);
+		return;
+	}
+
+	t = (((u32) src[3]) << 16) + (((u32) src[4]) << 8) + ((u32) src[5]);
+	t += offset;
+
+	dst[0] = src[0];
+	dst[1] = src[1];
+	dst[2] = src[2];
+	dst[3] = (t >> 16) & 0xff;
+	dst[4] = (t >> 8) & 0xff;
+	dst[5] = t & 0xff;
+}
+
+void __init ath79_init_local_mac(unsigned char *dst, const unsigned char *src)
+{
+	int i;
+
+	if (!is_valid_ether_addr(src)) {
+		memset(dst, '\0', ETH_ALEN);
+		return;
+	}
+
+	for (i = 0; i < ETH_ALEN; i++)
+		dst[i] = src[i];
+	dst[0] |= 0x02;
+}
diff --git a/arch/mips/ath79/dev-eth.h b/arch/mips/ath79/dev-eth.h
new file mode 100644
index 0000000..d4f27d9
--- /dev/null
+++ b/arch/mips/ath79/dev-eth.h
@@ -0,0 +1,48 @@
+/*
+ *  Atheros AR71xx SoC device definitions
+ *
+ *  Copyright (C) 2008-2012 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#ifndef _ATH79_DEV_ETH_H
+#define _ATH79_DEV_ETH_H
+
+#include <asm/mach-ath79/ag71xx_platform.h>
+
+struct platform_device;
+
+extern unsigned char ath79_mac_base[] __initdata;
+void ath79_parse_mac_addr(char *mac_str);
+void ath79_init_mac(unsigned char *dst, const unsigned char *src,
+		    int offset);
+void ath79_init_local_mac(unsigned char *dst, const unsigned char *src);
+
+struct ath79_eth_pll_data {
+	u32	pll_10;
+	u32	pll_100;
+	u32	pll_1000;
+};
+
+extern struct ath79_eth_pll_data ath79_eth0_pll_data;
+extern struct ath79_eth_pll_data ath79_eth1_pll_data;
+
+extern struct ag71xx_platform_data ath79_eth0_data;
+extern struct ag71xx_platform_data ath79_eth1_data;
+extern struct platform_device ath79_eth0_device;
+extern struct platform_device ath79_eth1_device;
+void ath79_register_eth(unsigned int id);
+
+extern struct ag71xx_switch_platform_data ath79_switch_data;
+
+extern struct platform_device ath79_mdio0_device;
+extern struct platform_device ath79_mdio1_device;
+void ath79_register_mdio(unsigned int id, u32 phy_mask);
+
+void ath79_setup_ar933x_phy4_switch(bool mac, bool mdio);
+
+#endif /* _ATH79_DEV_ETH_H */
diff --git a/arch/mips/ath79/dev-m25p80.c b/arch/mips/ath79/dev-m25p80.c
new file mode 100644
index 0000000..66115b1
--- /dev/null
+++ b/arch/mips/ath79/dev-m25p80.c
@@ -0,0 +1,117 @@
+/*
+ *  Copyright (C) 2009-2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/init.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/flash.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <linux/mtd/concat.h>
+
+#include "dev-spi.h"
+#include "dev-m25p80.h"
+
+static struct ath79_spi_controller_data ath79_spi0_cdata =
+{
+	.cs_type = ATH79_SPI_CS_TYPE_INTERNAL,
+	.cs_line = 0,
+};
+
+static struct ath79_spi_controller_data ath79_spi1_cdata =
+{
+	.cs_type = ATH79_SPI_CS_TYPE_INTERNAL,
+	.cs_line = 1,
+};
+
+static struct spi_board_info ath79_spi_info[] = {
+	{
+		.bus_num	= 0,
+		.chip_select	= 0,
+		.max_speed_hz	= 25000000,
+		.modalias	= "m25p80",
+		.controller_data = &ath79_spi0_cdata,
+	},
+	{
+		.bus_num	= 0,
+		.chip_select	= 1,
+		.max_speed_hz   = 25000000,
+		.modalias	= "m25p80",
+		.controller_data = &ath79_spi1_cdata,
+	}
+};
+
+static struct ath79_spi_platform_data ath79_spi_data;
+
+void __init ath79_register_m25p80(struct flash_platform_data *pdata)
+{
+	ath79_spi_data.bus_num = 0;
+	ath79_spi_data.num_chipselect = 1;
+	ath79_spi0_cdata.is_flash = true;
+	ath79_spi_info[0].platform_data = pdata;
+	ath79_register_spi(&ath79_spi_data, ath79_spi_info, 1);
+}
+
+static struct flash_platform_data *multi_pdata;
+
+static struct mtd_info *concat_devs[2] = { NULL, NULL };
+static struct work_struct mtd_concat_work;
+
+static void mtd_concat_add_work(struct work_struct *work)
+{
+	struct mtd_info *mtd;
+
+	mtd = mtd_concat_create(concat_devs, ARRAY_SIZE(concat_devs), "flash");
+
+	mtd_device_register(mtd, multi_pdata->parts, multi_pdata->nr_parts);
+}
+
+static void mtd_concat_add(struct mtd_info *mtd)
+{
+	static bool registered = false;
+
+	if (registered)
+		return;
+
+	if (!strcmp(mtd->name, "spi0.0"))
+		concat_devs[0] = mtd;
+	else if (!strcmp(mtd->name, "spi0.1"))
+		concat_devs[1] = mtd;
+	else
+		return;
+
+	if (!concat_devs[0] || !concat_devs[1])
+		return;
+
+	registered = true;
+	INIT_WORK(&mtd_concat_work, mtd_concat_add_work);
+	schedule_work(&mtd_concat_work);
+}
+
+static void mtd_concat_remove(struct mtd_info *mtd)
+{
+}
+
+static void add_mtd_concat_notifier(void)
+{
+	static struct mtd_notifier not = {
+		.add = mtd_concat_add,
+		.remove = mtd_concat_remove,
+	};
+
+	register_mtd_user(&not);
+}
+
+
+void __init ath79_register_m25p80_multi(struct flash_platform_data *pdata)
+{
+	multi_pdata = pdata;
+	add_mtd_concat_notifier();
+	ath79_spi_data.bus_num = 0;
+	ath79_spi_data.num_chipselect = 2;
+	ath79_register_spi(&ath79_spi_data, ath79_spi_info, 2);
+}
diff --git a/arch/mips/ath79/dev-m25p80.h b/arch/mips/ath79/dev-m25p80.h
new file mode 100644
index 0000000..637b41a
--- /dev/null
+++ b/arch/mips/ath79/dev-m25p80.h
@@ -0,0 +1,17 @@
+/*
+ *  Copyright (C) 2009-2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#ifndef _ATH79_DEV_M25P80_H
+#define _ATH79_DEV_M25P80_H
+
+#include <linux/spi/flash.h>
+
+void ath79_register_m25p80(struct flash_platform_data *pdata) __init;
+void ath79_register_m25p80_multi(struct flash_platform_data *pdata) __init;
+
+#endif /* _ATH79_DEV_M25P80_H */
diff --git a/arch/mips/ath79/mach-alfa-ap96.c b/arch/mips/ath79/mach-alfa-ap96.c
new file mode 100644
index 0000000..15abb08
--- /dev/null
+++ b/arch/mips/ath79/mach-alfa-ap96.c
@@ -0,0 +1,154 @@
+/*
+ *  ALFA Network AP96 board support
+ *
+ *  Copyright (C) 2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/init.h>
+#include <linux/bitops.h>
+#include <linux/gpio.h>
+#include <linux/platform_device.h>
+#include <linux/mmc/host.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/mmc_spi.h>
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-spi.h"
+#include "dev-usb.h"
+#include "machtypes.h"
+#include "pci.h"
+
+#define ALFA_AP96_GPIO_PCIE_RESET	2
+#define ALFA_AP96_GPIO_SIM_DETECT	3
+#define ALFA_AP96_GPIO_MICROSD_CD	4
+#define ALFA_AP96_GPIO_PCIE_W_DISABLE	5
+
+#define ALFA_AP96_GPIO_BUTTON_RESET	11
+
+#define ALFA_AP96_KEYS_POLL_INTERVAL		20	/* msecs */
+#define ALFA_AP96_KEYS_DEBOUNCE_INTERVAL	(3 * ALFA_AP96_KEYS_POLL_INTERVAL)
+
+static struct gpio_keys_button alfa_ap96_gpio_keys[] __initdata = {
+	{
+		.desc		= "Reset button",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = ALFA_AP96_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= ALFA_AP96_GPIO_BUTTON_RESET,
+		.active_low	= 1,
+	}
+};
+
+static int alfa_ap96_mmc_get_cd(struct device *dev)
+{
+        return !gpio_get_value(ALFA_AP96_GPIO_MICROSD_CD);
+}
+
+static struct mmc_spi_platform_data alfa_ap96_mmc_data = {
+	.get_cd		= alfa_ap96_mmc_get_cd,
+	.caps		= MMC_CAP_NEEDS_POLL,
+	.ocr_mask	= MMC_VDD_32_33 | MMC_VDD_33_34,
+};
+
+static struct ath79_spi_controller_data ap96_spi0_cdata = {
+	.cs_type = ATH79_SPI_CS_TYPE_INTERNAL,
+	.cs_line = 0,
+	.is_flash = true,
+};
+
+static struct ath79_spi_controller_data ap96_spi1_cdata = {
+	.cs_type = ATH79_SPI_CS_TYPE_INTERNAL,
+	.cs_line = 1,
+};
+
+static struct ath79_spi_controller_data ap96_spi2_cdata = {
+	.cs_type = ATH79_SPI_CS_TYPE_INTERNAL,
+	.cs_line = 2,
+};
+
+static struct spi_board_info alfa_ap96_spi_info[] = {
+	{
+		.bus_num	= 0,
+		.chip_select	= 0,
+		.max_speed_hz	= 25000000,
+		.modalias	= "m25p80",
+		.controller_data = &ap96_spi0_cdata
+	}, {
+		.bus_num	= 0,
+		.chip_select	= 1,
+		.max_speed_hz	= 25000000,
+		.modalias	= "mmc_spi",
+		.platform_data	= &alfa_ap96_mmc_data,
+		.controller_data = &ap96_spi1_cdata
+	}, {
+		.bus_num	= 0,
+		.chip_select	= 2,
+		.max_speed_hz	= 6250000,
+		.modalias	= "rtc-pcf2123",
+		.controller_data = &ap96_spi2_cdata
+	},
+};
+
+static struct ath79_spi_platform_data alfa_ap96_spi_data = {
+	.bus_num		= 0,
+	.num_chipselect		= 3,
+};
+
+static void __init alfa_ap96_gpio_setup(void)
+{
+	ath79_gpio_function_enable(AR71XX_GPIO_FUNC_SPI_CS1_EN |
+				   AR71XX_GPIO_FUNC_SPI_CS2_EN);
+
+	gpio_request(ALFA_AP96_GPIO_MICROSD_CD, "microSD CD");
+	gpio_direction_input(ALFA_AP96_GPIO_MICROSD_CD);
+	gpio_request(ALFA_AP96_GPIO_PCIE_RESET, "PCIe reset");
+	gpio_direction_output(ALFA_AP96_GPIO_PCIE_RESET, 1);
+	gpio_request(ALFA_AP96_GPIO_PCIE_W_DISABLE, "PCIe write disable");
+	gpio_direction_output(ALFA_AP96_GPIO_PCIE_W_DISABLE, 1);
+}
+
+#define ALFA_AP96_WAN_PHYMASK	BIT(4)
+#define ALFA_AP96_LAN_PHYMASK	BIT(5)
+#define ALFA_AP96_MDIO_PHYMASK	(ALFA_AP96_LAN_PHYMASK | ALFA_AP96_WAN_PHYMASK)
+
+static void __init alfa_ap96_init(void)
+{
+	alfa_ap96_gpio_setup();
+
+	ath79_register_mdio(0, ~ALFA_AP96_MDIO_PHYMASK);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, ath79_mac_base, 0);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.phy_mask = ALFA_AP96_WAN_PHYMASK;
+	ath79_eth1_pll_data.pll_1000 = 0x110000;
+
+	ath79_register_eth(0);
+
+	ath79_init_mac(ath79_eth1_data.mac_addr, ath79_mac_base, 1);
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth1_data.phy_mask = ALFA_AP96_LAN_PHYMASK;
+	ath79_eth1_pll_data.pll_1000 = 0x110000;
+
+	ath79_register_eth(1);
+
+	ath79_register_pci();
+	ath79_register_spi(&alfa_ap96_spi_data, alfa_ap96_spi_info,
+			   ARRAY_SIZE(alfa_ap96_spi_info));
+
+	ath79_register_gpio_keys_polled(-1, ALFA_AP96_KEYS_POLL_INTERVAL,
+					 ARRAY_SIZE(alfa_ap96_gpio_keys),
+					 alfa_ap96_gpio_keys);
+	ath79_register_usb();
+}
+
+MIPS_MACHINE(ATH79_MACH_ALFA_AP96, "ALFA-AP96", "ALFA Network AP96",
+	     alfa_ap96_init);
diff --git a/arch/mips/ath79/mach-alfa-nx.c b/arch/mips/ath79/mach-alfa-nx.c
new file mode 100644
index 0000000..a515f4f
--- /dev/null
+++ b/arch/mips/ath79/mach-alfa-nx.c
@@ -0,0 +1,113 @@
+/*
+ *  ALFA Network N2/N5 board support
+ *
+ *  Copyright (C) 2011-2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+#include <asm/mach-ath79/ath79.h>
+
+#include "common.h"
+#include "dev-eth.h"
+#include "dev-ap9x-pci.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "machtypes.h"
+
+#define ALFA_NX_GPIO_LED_2		17
+#define ALFA_NX_GPIO_LED_3		16
+#define ALFA_NX_GPIO_LED_5		12
+#define ALFA_NX_GPIO_LED_6		8
+#define ALFA_NX_GPIO_LED_7		6
+#define ALFA_NX_GPIO_LED_8		7
+
+#define ALFA_NX_GPIO_BTN_RESET		11
+
+#define ALFA_NX_KEYS_POLL_INTERVAL	20	/* msecs */
+#define ALFA_NX_KEYS_DEBOUNCE_INTERVAL (3 * ALFA_NX_KEYS_POLL_INTERVAL)
+
+#define ALFA_NX_MAC0_OFFSET		0
+#define ALFA_NX_MAC1_OFFSET		6
+#define ALFA_NX_CALDATA_OFFSET		0x1000
+
+static struct gpio_keys_button alfa_nx_gpio_keys[] __initdata = {
+	{
+		.desc		= "Reset button",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = ALFA_NX_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= ALFA_NX_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_led alfa_nx_leds_gpio[] __initdata = {
+	{
+		.name		= "alfa:green:led_2",
+		.gpio		= ALFA_NX_GPIO_LED_2,
+		.active_low	= 1,
+	}, {
+		.name		= "alfa:green:led_3",
+		.gpio		= ALFA_NX_GPIO_LED_3,
+		.active_low	= 1,
+	}, {
+		.name		= "alfa:red:led_5",
+		.gpio		= ALFA_NX_GPIO_LED_5,
+		.active_low	= 1,
+	}, {
+		.name		= "alfa:amber:led_6",
+		.gpio		= ALFA_NX_GPIO_LED_6,
+		.active_low	= 1,
+	}, {
+		.name		= "alfa:green:led_7",
+		.gpio		= ALFA_NX_GPIO_LED_7,
+		.active_low	= 1,
+	}, {
+		.name		= "alfa:green:led_8",
+		.gpio		= ALFA_NX_GPIO_LED_8,
+		.active_low	= 1,
+	}
+};
+
+static void __init alfa_nx_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+
+	ath79_gpio_function_setup(AR724X_GPIO_FUNC_JTAG_DISABLE,
+				  AR724X_GPIO_FUNC_ETH_SWITCH_LED0_EN |
+				  AR724X_GPIO_FUNC_ETH_SWITCH_LED1_EN |
+				  AR724X_GPIO_FUNC_ETH_SWITCH_LED2_EN |
+				  AR724X_GPIO_FUNC_ETH_SWITCH_LED3_EN |
+				  AR724X_GPIO_FUNC_ETH_SWITCH_LED4_EN);
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_leds_gpio(0, ARRAY_SIZE(alfa_nx_leds_gpio),
+				 alfa_nx_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, ALFA_NX_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(alfa_nx_gpio_keys),
+					alfa_nx_gpio_keys);
+
+	ath79_register_mdio(0, 0x0);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr,
+		       art + ALFA_NX_MAC0_OFFSET, 0);
+	ath79_init_mac(ath79_eth1_data.mac_addr,
+		       art + ALFA_NX_MAC1_OFFSET, 0);
+
+	/* WAN port */
+	ath79_register_eth(0);
+	/* LAN port */
+	ath79_register_eth(1);
+
+	ap91_pci_init(art + ALFA_NX_CALDATA_OFFSET, NULL);
+}
+
+MIPS_MACHINE(ATH79_MACH_ALFA_NX, "ALFA-NX", "ALFA Network N2/N5",
+	     alfa_nx_setup);
diff --git a/arch/mips/ath79/mach-all0258n.c b/arch/mips/ath79/mach-all0258n.c
new file mode 100644
index 0000000..2495bcb
--- /dev/null
+++ b/arch/mips/ath79/mach-all0258n.c
@@ -0,0 +1,88 @@
+/*
+ *  Allnet ALL0258N support
+ *
+ *  Copyright (C) 2011 Daniel Golle <dgolle@allnet.de>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-eth.h"
+#include "dev-ap9x-pci.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "machtypes.h"
+
+/* found via /sys/gpio/... try and error */
+#define ALL0258N_GPIO_BTN_RESET		1
+#define ALL0258N_GPIO_LED_RSSIHIGH	13
+#define ALL0258N_GPIO_LED_RSSIMEDIUM	15
+#define ALL0258N_GPIO_LED_RSSILOW	14
+
+/* defaults taken from others machs */
+#define ALL0258N_KEYS_POLL_INTERVAL	20	/* msecs */
+#define ALL0258N_KEYS_DEBOUNCE_INTERVAL (3 * ALL0258N_KEYS_POLL_INTERVAL)
+
+/* showed up in the original firmware's bootlog */
+#define ALL0258N_SEC_PHYMASK BIT(3)
+
+static struct gpio_led all0258n_leds_gpio[] __initdata = {
+	{
+		.name		= "all0258n:green:rssihigh",
+		.gpio		= ALL0258N_GPIO_LED_RSSIHIGH,
+		.active_low	= 1,
+	}, {
+		.name		= "all0258n:yellow:rssimedium",
+		.gpio		= ALL0258N_GPIO_LED_RSSIMEDIUM,
+		.active_low	= 1,
+	}, {
+		.name		= "all0258n:red:rssilow",
+		.gpio		= ALL0258N_GPIO_LED_RSSILOW,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button all0258n_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = ALL0258N_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= ALL0258N_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}
+};
+
+static void __init all0258n_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f7f0000);
+	u8 *ee =  (u8 *) KSEG1ADDR(0x1f7f1000);
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(all0258n_leds_gpio),
+				 all0258n_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, ALL0258N_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(all0258n_gpio_keys),
+					all0258n_gpio_keys);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 0);
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac, 0);
+
+	ath79_eth1_data.phy_mask = ALL0258N_SEC_PHYMASK;
+
+	ath79_register_mdio(0, 0x0);
+
+	ath79_register_eth(0);
+	ath79_register_eth(1);
+
+	ap91_pci_init(ee, mac);
+}
+
+MIPS_MACHINE(ATH79_MACH_ALL0258N, "ALL0258N", "Allnet ALL0258N",
+	     all0258n_setup);
diff --git a/arch/mips/ath79/mach-ap113.c b/arch/mips/ath79/mach-ap113.c
new file mode 100644
index 0000000..9b38faa
--- /dev/null
+++ b/arch/mips/ath79/mach-ap113.c
@@ -0,0 +1,84 @@
+/*
+ *  Atheros AP113 board support
+ *
+ *  Copyright (C) 2011 Florian Fainelli <florian@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "pci.h"
+#include "dev-usb.h"
+#include "machtypes.h"
+
+#define AP113_GPIO_LED_USB		0
+#define AP113_GPIO_LED_STATUS		1
+#define AP113_GPIO_LED_ST		11
+
+#define AP113_GPIO_BTN_JUMPSTART	12
+
+#define AP113_KEYS_POLL_INTERVAL	20	/* msecs */
+#define AP113_KEYS_DEBOUNCE_INTERVAL	(3 * AP113_KEYS_POLL_INTERVAL)
+
+static struct gpio_led ap113_leds_gpio[] __initdata = {
+	{
+		.name		= "ap113:green:usb",
+		.gpio		= AP113_GPIO_LED_USB,
+		.active_low	= 1,
+	},
+	{
+		.name		= "ap113:green:status",
+		.gpio		= AP113_GPIO_LED_STATUS,
+		.active_low	= 1,
+	},
+	{
+		.name		= "ap113:green:st",
+		.gpio		= AP113_GPIO_LED_ST,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button ap113_gpio_keys[] __initdata = {
+	{
+		.desc		= "jumpstart button",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = AP113_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= AP113_GPIO_BTN_JUMPSTART,
+		.active_low	= 1,
+	},
+};
+
+static void __init ap113_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1fff0000);
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_mdio(0, ~BIT(0));
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 0);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.speed = SPEED_1000;
+	ath79_eth0_data.duplex = DUPLEX_FULL;
+	ath79_eth0_data.phy_mask = BIT(0);
+
+	ath79_register_eth(0);
+
+	ath79_register_gpio_keys_polled(-1, AP113_KEYS_POLL_INTERVAL,
+					 ARRAY_SIZE(ap113_gpio_keys),
+					 ap113_gpio_keys);
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(ap113_leds_gpio),
+					ap113_leds_gpio);
+
+	ath79_register_pci();
+
+	ath79_register_usb();
+}
+
+MIPS_MACHINE(ATH79_MACH_AP113, "AP113", "Atheros AP113",
+	     ap113_setup);
diff --git a/arch/mips/ath79/mach-ap83.c b/arch/mips/ath79/mach-ap83.c
new file mode 100644
index 0000000..8519a9d
--- /dev/null
+++ b/arch/mips/ath79/mach-ap83.c
@@ -0,0 +1,275 @@
+/*
+ *  Atheros AP83 board support
+ *
+ *  Copyright (C) 2008-2012 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <linux/mtd/physmap.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/spi_gpio.h>
+#include <linux/spi/vsc7385.h>
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define AP83_GPIO_LED_WLAN	6
+#define AP83_GPIO_LED_POWER	14
+#define AP83_GPIO_LED_JUMPSTART	15
+#define AP83_GPIO_BTN_JUMPSTART	12
+#define AP83_GPIO_BTN_RESET	21
+
+#define AP83_050_GPIO_VSC7385_CS	1
+#define AP83_050_GPIO_VSC7385_MISO	3
+#define AP83_050_GPIO_VSC7385_MOSI	16
+#define AP83_050_GPIO_VSC7385_SCK	17
+
+#define AP83_KEYS_POLL_INTERVAL		20	/* msecs */
+#define AP83_KEYS_DEBOUNCE_INTERVAL	(3 * AP83_KEYS_POLL_INTERVAL)
+
+static struct mtd_partition ap83_flash_partitions[] = {
+	{
+		.name		= "u-boot",
+		.offset		= 0,
+		.size		= 0x040000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "u-boot-env",
+		.offset		= 0x040000,
+		.size		= 0x020000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "kernel",
+		.offset		= 0x060000,
+		.size		= 0x140000,
+	}, {
+		.name		= "rootfs",
+		.offset		= 0x1a0000,
+		.size		= 0x650000,
+	}, {
+		.name		= "art",
+		.offset		= 0x7f0000,
+		.size		= 0x010000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "firmware",
+		.offset		= 0x060000,
+		.size		= 0x790000,
+	}
+};
+
+static struct physmap_flash_data ap83_flash_data = {
+	.width		= 2,
+	.parts		= ap83_flash_partitions,
+	.nr_parts	= ARRAY_SIZE(ap83_flash_partitions),
+};
+
+static struct resource ap83_flash_resources[] = {
+	[0] = {
+		.start	= AR71XX_SPI_BASE,
+		.end	= AR71XX_SPI_BASE + AR71XX_SPI_SIZE - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+};
+
+static struct platform_device ap83_flash_device = {
+	.name		= "ar91xx-flash",
+	.id		= -1,
+	.resource	= ap83_flash_resources,
+	.num_resources	= ARRAY_SIZE(ap83_flash_resources),
+	.dev		= {
+		.platform_data = &ap83_flash_data,
+	}
+};
+
+static struct gpio_led ap83_leds_gpio[] __initdata = {
+	{
+		.name		= "ap83:green:jumpstart",
+		.gpio		= AP83_GPIO_LED_JUMPSTART,
+		.active_low	= 0,
+	}, {
+		.name		= "ap83:green:power",
+		.gpio		= AP83_GPIO_LED_POWER,
+		.active_low	= 0,
+	}, {
+		.name		= "ap83:green:wlan",
+		.gpio		= AP83_GPIO_LED_WLAN,
+		.active_low	= 0,
+	},
+};
+
+static struct gpio_keys_button ap83_gpio_keys[] __initdata = {
+	{
+		.desc		= "soft_reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = AP83_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= AP83_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}, {
+		.desc		= "jumpstart",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = AP83_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= AP83_GPIO_BTN_JUMPSTART,
+		.active_low	= 1,
+	}
+};
+
+static struct resource ap83_040_spi_resources[] = {
+	[0] = {
+		.start	= AR71XX_SPI_BASE,
+		.end	= AR71XX_SPI_BASE + AR71XX_SPI_SIZE - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+};
+
+static struct platform_device ap83_040_spi_device = {
+	.name		= "ap83-spi",
+	.id		= 0,
+	.resource	= ap83_040_spi_resources,
+	.num_resources	= ARRAY_SIZE(ap83_040_spi_resources),
+};
+
+static struct spi_gpio_platform_data ap83_050_spi_data = {
+	.miso	= AP83_050_GPIO_VSC7385_MISO,
+	.mosi	= AP83_050_GPIO_VSC7385_MOSI,
+	.sck	= AP83_050_GPIO_VSC7385_SCK,
+	.num_chipselect = 1,
+};
+
+static struct platform_device ap83_050_spi_device = {
+	.name		= "spi_gpio",
+	.id		= 0,
+	.dev		= {
+		.platform_data = &ap83_050_spi_data,
+	}
+};
+
+static void ap83_vsc7385_reset(void)
+{
+	ath79_device_reset_set(AR71XX_RESET_GE1_PHY);
+	udelay(10);
+	ath79_device_reset_clear(AR71XX_RESET_GE1_PHY);
+	mdelay(50);
+}
+
+static struct vsc7385_platform_data ap83_vsc7385_data = {
+	.reset		= ap83_vsc7385_reset,
+	.ucode_name	= "vsc7385_ucode_ap83.bin",
+	.mac_cfg = {
+		.tx_ipg		= 6,
+		.bit2		= 0,
+		.clk_sel	= 3,
+	},
+};
+
+static struct spi_board_info ap83_spi_info[] = {
+	{
+		.bus_num	= 0,
+		.chip_select	= 0,
+		.max_speed_hz	= 25000000,
+		.modalias	= "spi-vsc7385",
+		.platform_data	= &ap83_vsc7385_data,
+		.controller_data = (void *) AP83_050_GPIO_VSC7385_CS,
+	}
+};
+
+static void __init ap83_generic_setup(void)
+{
+	u8 *eeprom = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	ath79_register_mdio(0, 0xfffffffe);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, eeprom, 0);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.phy_mask = 0x1;
+
+	ath79_register_eth(0);
+
+	ath79_init_mac(ath79_eth1_data.mac_addr, eeprom, 1);
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth1_data.speed = SPEED_1000;
+	ath79_eth1_data.duplex = DUPLEX_FULL;
+
+	ath79_eth1_pll_data.pll_1000 = 0x1f000000;
+
+	ath79_register_eth(1);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(ap83_leds_gpio),
+					ap83_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, AP83_KEYS_POLL_INTERVAL,
+					 ARRAY_SIZE(ap83_gpio_keys),
+					 ap83_gpio_keys);
+
+	ath79_register_usb();
+
+	ath79_register_wmac(eeprom, NULL);
+
+	platform_device_register(&ap83_flash_device);
+
+	spi_register_board_info(ap83_spi_info, ARRAY_SIZE(ap83_spi_info));
+}
+
+static void ap83_040_flash_lock(struct platform_device *pdev)
+{
+	ath79_flash_acquire();
+}
+
+static void ap83_040_flash_unlock(struct platform_device *pdev)
+{
+	ath79_flash_release();
+}
+
+static void __init ap83_040_setup(void)
+{
+	ap83_flash_data.lock = ap83_040_flash_lock;
+	ap83_flash_data.unlock = ap83_040_flash_unlock;
+	ap83_generic_setup();
+	platform_device_register(&ap83_040_spi_device);
+}
+
+static void __init ap83_050_setup(void)
+{
+	ap83_generic_setup();
+	platform_device_register(&ap83_050_spi_device);
+}
+
+static void __init ap83_setup(void)
+{
+	u8 *board_id = (u8 *) KSEG1ADDR(0x1fff1244);
+	unsigned int board_version;
+
+	board_version = (unsigned int)(board_id[0] - '0');
+	board_version += ((unsigned int)(board_id[1] - '0')) * 10;
+
+	switch (board_version) {
+	case 40:
+		ap83_040_setup();
+		break;
+	case 50:
+		ap83_050_setup();
+		break;
+	default:
+		printk(KERN_WARNING "AP83-%03u board is not yet supported\n",
+		       board_version);
+	}
+}
+
+MIPS_MACHINE(ATH79_MACH_AP83, "AP83", "Atheros AP83", ap83_setup);
diff --git a/arch/mips/ath79/mach-ap96.c b/arch/mips/ath79/mach-ap96.c
new file mode 100644
index 0000000..35120d3
--- /dev/null
+++ b/arch/mips/ath79/mach-ap96.c
@@ -0,0 +1,142 @@
+/*
+ *  Atheros AP96 board support
+ *
+ *  Copyright (C) 2009 Marco Porsch
+ *  Copyright (C) 2009-2012 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2010 Atheros Communications
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-ap9x-pci.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "machtypes.h"
+
+#define AP96_GPIO_LED_12_GREEN		0
+#define AP96_GPIO_LED_3_GREEN		1
+#define AP96_GPIO_LED_2_GREEN		2
+#define AP96_GPIO_LED_WPS_GREEN		4
+#define AP96_GPIO_LED_5_GREEN		5
+#define AP96_GPIO_LED_4_ORANGE		6
+
+/* Reset button - next to the power connector */
+#define AP96_GPIO_BTN_RESET		3
+/* WPS button - next to a led on right */
+#define AP96_GPIO_BTN_WPS		8
+
+#define AP96_KEYS_POLL_INTERVAL		20	/* msecs */
+#define AP96_KEYS_DEBOUNCE_INTERVAL	(3 * AP96_KEYS_POLL_INTERVAL)
+
+#define AP96_WMAC0_MAC_OFFSET		0x120c
+#define AP96_WMAC1_MAC_OFFSET		0x520c
+#define AP96_CALDATA0_OFFSET		0x1000
+#define AP96_CALDATA1_OFFSET		0x5000
+
+/*
+ * AP96 has 12 unlabeled leds in the front; these are numbered from 1 to 12
+ * below (from left to right on the board). Led 1 seems to be on whenever the
+ * board is powered. Led 11 shows LAN link activity actity. Led 3 is orange;
+ * others are green.
+ *
+ * In addition, there is one led next to a button on the right side for WPS.
+ */
+static struct gpio_led ap96_leds_gpio[] __initdata = {
+	{
+		.name		= "ap96:green:led2",
+		.gpio		= AP96_GPIO_LED_2_GREEN,
+		.active_low	= 1,
+	}, {
+		.name		= "ap96:green:led3",
+		.gpio		= AP96_GPIO_LED_3_GREEN,
+		.active_low	= 1,
+	}, {
+		.name		= "ap96:orange:led4",
+		.gpio		= AP96_GPIO_LED_4_ORANGE,
+		.active_low	= 1,
+	}, {
+		.name		= "ap96:green:led5",
+		.gpio		= AP96_GPIO_LED_5_GREEN,
+		.active_low	= 1,
+	}, {
+		.name		= "ap96:green:led12",
+		.gpio		= AP96_GPIO_LED_12_GREEN,
+		.active_low	= 1,
+	}, { /* next to a button on right */
+		.name		= "ap96:green:wps",
+		.gpio		= AP96_GPIO_LED_WPS_GREEN,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button ap96_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = AP96_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= AP96_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}, {
+		.desc		= "wps",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = AP96_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= AP96_GPIO_BTN_WPS,
+		.active_low	= 1,
+	}
+};
+
+#define AP96_WAN_PHYMASK 0x10
+#define AP96_LAN_PHYMASK 0x0f
+
+static void __init ap96_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+
+	ath79_register_mdio(0, ~(AP96_WAN_PHYMASK | AP96_LAN_PHYMASK));
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, art, 0);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.phy_mask = AP96_LAN_PHYMASK;
+	ath79_eth0_data.speed = SPEED_1000;
+	ath79_eth0_data.duplex = DUPLEX_FULL;
+
+	ath79_register_eth(0);
+
+	ath79_init_mac(ath79_eth1_data.mac_addr, art, 1);
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth1_data.phy_mask = AP96_WAN_PHYMASK;
+
+	ath79_eth1_pll_data.pll_1000 = 0x1f000000;
+
+	ath79_register_eth(1);
+
+	ath79_register_usb();
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(ap96_leds_gpio),
+					ap96_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, AP96_KEYS_POLL_INTERVAL,
+					 ARRAY_SIZE(ap96_gpio_keys),
+					 ap96_gpio_keys);
+
+	ap94_pci_init(art + AP96_CALDATA0_OFFSET,
+		      art + AP96_WMAC0_MAC_OFFSET,
+		      art + AP96_CALDATA1_OFFSET,
+		      art + AP96_WMAC1_MAC_OFFSET);
+}
+
+MIPS_MACHINE(ATH79_MACH_AP96, "AP96", "Atheros AP96", ap96_setup);
diff --git a/arch/mips/ath79/mach-aw-nr580.c b/arch/mips/ath79/mach-aw-nr580.c
new file mode 100644
index 0000000..281129b
--- /dev/null
+++ b/arch/mips/ath79/mach-aw-nr580.c
@@ -0,0 +1,107 @@
+/*
+ *  AzureWave AW-NR580 board support
+ *
+ *  Copyright (C) 2008-2012 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-eth.h"
+#include "dev-m25p80.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "machtypes.h"
+#include "pci.h"
+
+#define AW_NR580_GPIO_LED_READY_RED	0
+#define AW_NR580_GPIO_LED_WLAN		1
+#define AW_NR580_GPIO_LED_READY_GREEN	2
+#define AW_NR580_GPIO_LED_WPS_GREEN	4
+#define AW_NR580_GPIO_LED_WPS_AMBER	5
+
+#define AW_NR580_GPIO_BTN_WPS		3
+#define AW_NR580_GPIO_BTN_RESET		11
+
+#define AW_NR580_KEYS_POLL_INTERVAL	20	/* msecs */
+#define AW_NR580_KEYS_DEBOUNCE_INTERVAL	(3 * AW_NR580_KEYS_POLL_INTERVAL)
+
+static struct gpio_led aw_nr580_leds_gpio[] __initdata = {
+	{
+		.name		= "aw-nr580:red:ready",
+		.gpio		= AW_NR580_GPIO_LED_READY_RED,
+		.active_low	= 0,
+	}, {
+		.name		= "aw-nr580:green:ready",
+		.gpio		= AW_NR580_GPIO_LED_READY_GREEN,
+		.active_low	= 0,
+	}, {
+		.name		= "aw-nr580:green:wps",
+		.gpio		= AW_NR580_GPIO_LED_WPS_GREEN,
+		.active_low	= 0,
+	}, {
+		.name		= "aw-nr580:amber:wps",
+		.gpio		= AW_NR580_GPIO_LED_WPS_AMBER,
+		.active_low	= 0,
+	}, {
+		.name		= "aw-nr580:green:wlan",
+		.gpio		= AW_NR580_GPIO_LED_WLAN,
+		.active_low	= 0,
+	}
+};
+
+static struct gpio_keys_button aw_nr580_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = AW_NR580_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= AW_NR580_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}, {
+		.desc		= "wps",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = AW_NR580_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= AW_NR580_GPIO_BTN_WPS,
+		.active_low	= 1,
+	}
+};
+
+static const char *aw_nr580_part_probes[] = {
+	"RedBoot",
+	NULL,
+};
+
+static struct flash_platform_data aw_nr580_flash_data = {
+	.part_probes	= aw_nr580_part_probes,
+};
+
+static void __init aw_nr580_setup(void)
+{
+	ath79_register_mdio(0, 0x0);
+
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ath79_eth0_data.speed = SPEED_100;
+	ath79_eth0_data.duplex = DUPLEX_FULL;
+
+	ath79_register_eth(0);
+
+	ath79_register_pci();
+
+	ath79_register_m25p80(&aw_nr580_flash_data);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(aw_nr580_leds_gpio),
+				 aw_nr580_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, AW_NR580_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(aw_nr580_gpio_keys),
+					aw_nr580_gpio_keys);
+}
+
+MIPS_MACHINE(ATH79_MACH_AW_NR580, "AW-NR580", "AzureWave AW-NR580",
+	     aw_nr580_setup);
diff --git a/arch/mips/ath79/mach-dir-600-a1.c b/arch/mips/ath79/mach-dir-600-a1.c
new file mode 100644
index 0000000..c0fa900
--- /dev/null
+++ b/arch/mips/ath79/mach-dir-600-a1.c
@@ -0,0 +1,151 @@
+/*
+ *  D-Link DIR-600 rev. A1 board support
+ *
+ *  Copyright (C) 2010-2012 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2012 Vadim Girlin <vadimgirlin@gmail.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-ap9x-pci.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "machtypes.h"
+#include "nvram.h"
+
+#define DIR_600_A1_GPIO_LED_WPS			0
+#define DIR_600_A1_GPIO_LED_POWER_AMBER		1
+#define DIR_600_A1_GPIO_LED_POWER_GREEN		6
+#define DIR_600_A1_GPIO_LED_LAN1		13
+#define DIR_600_A1_GPIO_LED_LAN2		14
+#define DIR_600_A1_GPIO_LED_LAN3		15
+#define DIR_600_A1_GPIO_LED_LAN4		16
+#define DIR_600_A1_GPIO_LED_WAN_AMBER		7
+#define DIR_600_A1_GPIO_LED_WAN_GREEN		17
+
+#define DIR_600_A1_GPIO_BTN_RESET		8
+#define DIR_600_A1_GPIO_BTN_WPS			12
+
+#define DIR_600_A1_KEYS_POLL_INTERVAL		20	/* msecs */
+#define DIR_600_A1_KEYS_DEBOUNCE_INTERVAL (3 * DIR_600_A1_KEYS_POLL_INTERVAL)
+
+#define DIR_600_A1_NVRAM_ADDR	0x1f030000
+#define DIR_600_A1_NVRAM_SIZE	0x10000
+
+static struct gpio_led dir_600_a1_leds_gpio[] __initdata = {
+	{
+		.name		= "d-link:green:power",
+		.gpio		= DIR_600_A1_GPIO_LED_POWER_GREEN,
+	}, {
+		.name		= "d-link:amber:power",
+		.gpio		= DIR_600_A1_GPIO_LED_POWER_AMBER,
+	}, {
+		.name		= "d-link:amber:wan",
+		.gpio		= DIR_600_A1_GPIO_LED_WAN_AMBER,
+	}, {
+		.name		= "d-link:green:wan",
+		.gpio		= DIR_600_A1_GPIO_LED_WAN_GREEN,
+		.active_low	= 1,
+	}, {
+		.name		= "d-link:green:lan1",
+		.gpio		= DIR_600_A1_GPIO_LED_LAN1,
+		.active_low	= 1,
+	}, {
+		.name		= "d-link:green:lan2",
+		.gpio		= DIR_600_A1_GPIO_LED_LAN2,
+		.active_low	= 1,
+	}, {
+		.name		= "d-link:green:lan3",
+		.gpio		= DIR_600_A1_GPIO_LED_LAN3,
+		.active_low	= 1,
+	}, {
+		.name		= "d-link:green:lan4",
+		.gpio		= DIR_600_A1_GPIO_LED_LAN4,
+		.active_low	= 1,
+	}, {
+		.name		= "d-link:blue:wps",
+		.gpio		= DIR_600_A1_GPIO_LED_WPS,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button dir_600_a1_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = DIR_600_A1_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= DIR_600_A1_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}, {
+		.desc		= "wps",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = DIR_600_A1_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= DIR_600_A1_GPIO_BTN_WPS,
+		.active_low	= 1,
+	}
+};
+
+static void __init dir_600_a1_setup(void)
+{
+	const char *nvram = (char *) KSEG1ADDR(DIR_600_A1_NVRAM_ADDR);
+	u8 *ee = (u8 *) KSEG1ADDR(0x1fff1000);
+	u8 mac_buff[6];
+	u8 *mac = NULL;
+
+	if (ath79_nvram_parse_mac_addr(nvram, DIR_600_A1_NVRAM_SIZE,
+				       "lan_mac=", mac_buff) == 0) {
+		ath79_init_mac(ath79_eth0_data.mac_addr, mac_buff, 0);
+		ath79_init_mac(ath79_eth1_data.mac_addr, mac_buff, 1);
+		mac = mac_buff;
+	}
+
+	ath79_register_m25p80(NULL);
+
+	ath79_gpio_function_disable(AR724X_GPIO_FUNC_ETH_SWITCH_LED0_EN |
+				    AR724X_GPIO_FUNC_ETH_SWITCH_LED1_EN |
+				    AR724X_GPIO_FUNC_ETH_SWITCH_LED2_EN |
+				    AR724X_GPIO_FUNC_ETH_SWITCH_LED3_EN |
+				    AR724X_GPIO_FUNC_ETH_SWITCH_LED4_EN);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(dir_600_a1_leds_gpio),
+				 dir_600_a1_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, DIR_600_A1_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(dir_600_a1_gpio_keys),
+					dir_600_a1_gpio_keys);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 0);
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac, 1);
+
+	ath79_register_mdio(0, 0x0);
+
+	/* LAN ports */
+	ath79_register_eth(1);
+
+	/* WAN port */
+	ath79_register_eth(0);
+
+	ap91_pci_init(ee, mac);
+}
+
+MIPS_MACHINE(ATH79_MACH_DIR_600_A1, "DIR-600-A1", "D-Link DIR-600 rev. A1",
+	     dir_600_a1_setup);
+
+static void __init dir_615_e4_setup(void)
+{
+	dir_600_a1_setup();
+	ap9x_pci_setup_wmac_led_pin(0, 1);
+}
+
+MIPS_MACHINE(ATH79_MACH_DIR_615_E4, "DIR-615-E4", "D-Link DIR-615 rev. E4",
+	     dir_615_e4_setup);
diff --git a/arch/mips/ath79/mach-dir-615-c1.c b/arch/mips/ath79/mach-dir-615-c1.c
new file mode 100644
index 0000000..425be30
--- /dev/null
+++ b/arch/mips/ath79/mach-dir-615-c1.c
@@ -0,0 +1,133 @@
+/*
+ *  D-Link DIR-615 rev C1 board support
+ *
+ *  Copyright (C) 2008-2012 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+#include "nvram.h"
+
+#define DIR_615C1_GPIO_LED_ORANGE_STATUS 1	/* ORANGE:STATUS:TRICOLOR */
+#define DIR_615C1_GPIO_LED_BLUE_WPS	3	/* BLUE:WPS */
+#define DIR_615C1_GPIO_LED_GREEN_WAN	4       /* GREEN:WAN:TRICOLOR */
+#define DIR_615C1_GPIO_LED_GREEN_WANCPU	5       /* GREEN:WAN:CPU:TRICOLOR */
+#define DIR_615C1_GPIO_LED_GREEN_WLAN	6	/* GREEN:WLAN */
+#define DIR_615C1_GPIO_LED_GREEN_STATUS	14	/* GREEN:STATUS:TRICOLOR */
+#define DIR_615C1_GPIO_LED_ORANGE_WAN	15	/* ORANGE:WAN:TRICOLOR */
+
+/* buttons may need refinement */
+
+#define DIR_615C1_GPIO_BTN_WPS		12
+#define DIR_615C1_GPIO_BTN_RESET	21
+
+#define DIR_615C1_KEYS_POLL_INTERVAL	20	/* msecs */
+#define DIR_615C1_KEYS_DEBOUNCE_INTERVAL (3 * DIR_615C1_KEYS_POLL_INTERVAL)
+
+#define DIR_615C1_CONFIG_ADDR		0x1f020000
+#define DIR_615C1_CONFIG_SIZE		0x10000
+
+static struct gpio_led dir_615c1_leds_gpio[] __initdata = {
+	{
+		.name		= "d-link:orange:status",
+		.gpio		= DIR_615C1_GPIO_LED_ORANGE_STATUS,
+		.active_low	= 1,
+	}, {
+		.name		= "d-link:blue:wps",
+		.gpio		= DIR_615C1_GPIO_LED_BLUE_WPS,
+		.active_low	= 1,
+	}, {
+		.name		= "d-link:green:wan",
+		.gpio		= DIR_615C1_GPIO_LED_GREEN_WAN,
+		.active_low	= 1,
+	}, {
+		.name		= "d-link:green:wancpu",
+		.gpio		= DIR_615C1_GPIO_LED_GREEN_WANCPU,
+		.active_low	= 1,
+	}, {
+		.name		= "d-link:green:wlan",
+		.gpio		= DIR_615C1_GPIO_LED_GREEN_WLAN,
+		.active_low	= 1,
+	}, {
+		.name		= "d-link:green:status",
+		.gpio		= DIR_615C1_GPIO_LED_GREEN_STATUS,
+		.active_low     = 1,
+	}, {
+		.name		= "d-link:orange:wan",
+		.gpio		= DIR_615C1_GPIO_LED_ORANGE_WAN,
+		.active_low	= 1,
+	}
+
+};
+
+static struct gpio_keys_button dir_615c1_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = DIR_615C1_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= DIR_615C1_GPIO_BTN_RESET,
+	}, {
+		.desc		= "wps",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = DIR_615C1_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= DIR_615C1_GPIO_BTN_WPS,
+	}
+};
+
+#define DIR_615C1_LAN_PHYMASK	BIT(0)
+#define DIR_615C1_WAN_PHYMASK	BIT(4)
+#define DIR_615C1_MDIO_MASK	(~(DIR_615C1_LAN_PHYMASK | \
+				   DIR_615C1_WAN_PHYMASK))
+
+static void __init dir_615c1_setup(void)
+{
+	const char *config = (char *) KSEG1ADDR(DIR_615C1_CONFIG_ADDR);
+	u8 *eeprom = (u8 *) KSEG1ADDR(0x1fff1000);
+	u8 mac[6];
+	u8 *wlan_mac = NULL;
+
+	if (ath79_nvram_parse_mac_addr(config, DIR_615C1_CONFIG_SIZE,
+				       "lan_mac=", mac) == 0) {
+		ath79_init_mac(ath79_eth0_data.mac_addr, mac, 0);
+		ath79_init_mac(ath79_eth1_data.mac_addr, mac, 1);
+		wlan_mac = mac;
+	}
+
+	ath79_register_mdio(0, DIR_615C1_MDIO_MASK);
+
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ath79_eth0_data.phy_mask = DIR_615C1_LAN_PHYMASK;
+
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ath79_eth1_data.phy_mask = DIR_615C1_WAN_PHYMASK;
+
+	ath79_register_eth(0);
+	ath79_register_eth(1);
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(dir_615c1_leds_gpio),
+				 dir_615c1_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, DIR_615C1_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(dir_615c1_gpio_keys),
+					dir_615c1_gpio_keys);
+
+	ath79_register_wmac(eeprom, wlan_mac);
+}
+
+MIPS_MACHINE(ATH79_MACH_DIR_615_C1, "DIR-615-C1", "D-Link DIR-615 rev. C1",
+	     dir_615c1_setup);
diff --git a/arch/mips/ath79/mach-dir-825-b1.c b/arch/mips/ath79/mach-dir-825-b1.c
new file mode 100644
index 0000000..1b4b490
--- /dev/null
+++ b/arch/mips/ath79/mach-dir-825-b1.c
@@ -0,0 +1,173 @@
+/*
+ *  D-Link DIR-825 rev. B1 board support
+ *
+ *  Copyright (C) 2009-2011 Lukas Kuna, Evkanet, s.r.o.
+ *
+ *  based on mach-wndr3700.c
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/rtl8366.h>
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-eth.h"
+#include "dev-ap9x-pci.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "machtypes.h"
+
+#define DIR825B1_GPIO_LED_BLUE_USB		0
+#define DIR825B1_GPIO_LED_ORANGE_POWER		1
+#define DIR825B1_GPIO_LED_BLUE_POWER		2
+#define DIR825B1_GPIO_LED_BLUE_WPS		4
+#define DIR825B1_GPIO_LED_ORANGE_PLANET		6
+#define DIR825B1_GPIO_LED_BLUE_PLANET		11
+
+#define DIR825B1_GPIO_BTN_RESET			3
+#define DIR825B1_GPIO_BTN_WPS			8
+
+#define DIR825B1_GPIO_RTL8366_SDA		5
+#define DIR825B1_GPIO_RTL8366_SCK		7
+
+#define DIR825B1_KEYS_POLL_INTERVAL		20	/* msecs */
+#define DIR825B1_KEYS_DEBOUNCE_INTERVAL		(3 * DIR825B1_KEYS_POLL_INTERVAL)
+
+#define DIR825B1_CAL_LOCATION_0			0x1f661000
+#define DIR825B1_CAL_LOCATION_1			0x1f665000
+
+#define DIR825B1_MAC_LOCATION_0			0x1f66ffa0
+#define DIR825B1_MAC_LOCATION_1			0x1f66ffb4
+
+static struct gpio_led dir825b1_leds_gpio[] __initdata = {
+	{
+		.name		= "d-link:blue:usb",
+		.gpio		= DIR825B1_GPIO_LED_BLUE_USB,
+		.active_low	= 1,
+	}, {
+		.name		= "d-link:orange:power",
+		.gpio		= DIR825B1_GPIO_LED_ORANGE_POWER,
+		.active_low	= 1,
+	}, {
+		.name		= "d-link:blue:power",
+		.gpio		= DIR825B1_GPIO_LED_BLUE_POWER,
+		.active_low	= 1,
+	}, {
+		.name		= "d-link:blue:wps",
+		.gpio		= DIR825B1_GPIO_LED_BLUE_WPS,
+		.active_low	= 1,
+	}, {
+		.name		= "d-link:orange:planet",
+		.gpio		= DIR825B1_GPIO_LED_ORANGE_PLANET,
+		.active_low	= 1,
+	}, {
+		.name		= "d-link:blue:planet",
+		.gpio		= DIR825B1_GPIO_LED_BLUE_PLANET,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button dir825b1_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = DIR825B1_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= DIR825B1_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}, {
+		.desc		= "wps",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = DIR825B1_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= DIR825B1_GPIO_BTN_WPS,
+		.active_low	= 1,
+	}
+};
+
+static struct rtl8366_initval dir825b1_rtl8366s_initvals[] = {
+	{ .reg = 0x06, .val = 0x0108 },
+};
+
+static struct rtl8366_platform_data dir825b1_rtl8366s_data = {
+	.gpio_sda	= DIR825B1_GPIO_RTL8366_SDA,
+	.gpio_sck	= DIR825B1_GPIO_RTL8366_SCK,
+	.num_initvals	= ARRAY_SIZE(dir825b1_rtl8366s_initvals),
+	.initvals	= dir825b1_rtl8366s_initvals,
+};
+
+static struct platform_device dir825b1_rtl8366s_device = {
+	.name		= RTL8366S_DRIVER_NAME,
+	.id		= -1,
+	.dev = {
+		.platform_data	= &dir825b1_rtl8366s_data,
+	}
+};
+
+static void dir825b1_read_ascii_mac(u8 *dest, unsigned int src_addr)
+{
+	int ret;
+	u8 *src = (u8 *)KSEG1ADDR(src_addr);
+
+	ret = sscanf(src, "%02hhx:%02hhx:%02hhx:%02hhx:%02hhx:%02hhx",
+		     &dest[0], &dest[1], &dest[2],
+		     &dest[3], &dest[4], &dest[5]);
+
+	if (ret != ETH_ALEN)
+		memset(dest, 0, ETH_ALEN);
+}
+
+static void __init dir825b1_setup(void)
+{
+	u8 mac1[ETH_ALEN], mac2[ETH_ALEN];
+
+	dir825b1_read_ascii_mac(mac1, DIR825B1_MAC_LOCATION_0);
+	dir825b1_read_ascii_mac(mac2, DIR825B1_MAC_LOCATION_1);
+
+	ath79_register_mdio(0, 0x0);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac1, 2);
+	ath79_eth0_data.mii_bus_dev = &dir825b1_rtl8366s_device.dev;
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.speed = SPEED_1000;
+	ath79_eth0_data.duplex = DUPLEX_FULL;
+	ath79_eth0_pll_data.pll_1000 = 0x11110000;
+
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac1, 3);
+	ath79_eth1_data.mii_bus_dev = &dir825b1_rtl8366s_device.dev;
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth1_data.phy_mask = 0x10;
+	ath79_eth1_pll_data.pll_1000 = 0x11110000;
+
+	ath79_register_eth(0);
+	ath79_register_eth(1);
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(dir825b1_leds_gpio),
+				 dir825b1_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, DIR825B1_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(dir825b1_gpio_keys),
+					dir825b1_gpio_keys);
+
+	ath79_register_usb();
+
+	platform_device_register(&dir825b1_rtl8366s_device);
+
+	ap9x_pci_setup_wmac_led_pin(0, 5);
+	ap9x_pci_setup_wmac_led_pin(1, 5);
+
+	ap94_pci_init((u8 *) KSEG1ADDR(DIR825B1_CAL_LOCATION_0), mac1,
+		      (u8 *) KSEG1ADDR(DIR825B1_CAL_LOCATION_1), mac2);
+}
+
+MIPS_MACHINE(ATH79_MACH_DIR_825_B1, "DIR-825-B1", "D-Link DIR-825 rev. B1",
+	     dir825b1_setup);
diff --git a/arch/mips/ath79/mach-eap7660d.c b/arch/mips/ath79/mach-eap7660d.c
new file mode 100644
index 0000000..d58eee2
--- /dev/null
+++ b/arch/mips/ath79/mach-eap7660d.c
@@ -0,0 +1,178 @@
+/*
+ *  Senao EAP7660D board support
+ *
+ *  Copyright (C) 2010 Daniel Golle <daniel.golle@gmail.com>
+ *  Copyright (C) 2008 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/pci.h>
+#include <linux/ath5k_platform.h>
+#include <linux/delay.h>
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "machtypes.h"
+#include "pci.h"
+
+#define EAP7660D_KEYS_POLL_INTERVAL	20	/* msecs */
+#define EAP7660D_KEYS_DEBOUNCE_INTERVAL	(3 * EAP7660D_KEYS_POLL_INTERVAL)
+
+#define EAP7660D_GPIO_DS4		7
+#define EAP7660D_GPIO_DS5		2
+#define EAP7660D_GPIO_DS7		0
+#define EAP7660D_GPIO_DS8		4
+#define EAP7660D_GPIO_SW1		3
+#define EAP7660D_GPIO_SW3		8
+#define EAP7660D_PHYMASK		BIT(20)
+#define EAP7660D_BOARDCONFIG		0x1F7F0000
+#define EAP7660D_GBIC_MAC_OFFSET	0x1000
+#define EAP7660D_WMAC0_MAC_OFFSET	0x1010
+#define EAP7660D_WMAC1_MAC_OFFSET	0x1016
+#define EAP7660D_WMAC0_CALDATA_OFFSET	0x2000
+#define EAP7660D_WMAC1_CALDATA_OFFSET	0x3000
+
+#ifdef CONFIG_PCI
+static struct ath5k_platform_data eap7660d_wmac0_data;
+static struct ath5k_platform_data eap7660d_wmac1_data;
+static char eap7660d_wmac0_mac[6];
+static char eap7660d_wmac1_mac[6];
+static u16 eap7660d_wmac0_eeprom[ATH5K_PLAT_EEP_MAX_WORDS];
+static u16 eap7660d_wmac1_eeprom[ATH5K_PLAT_EEP_MAX_WORDS];
+
+static int eap7660d_pci_plat_dev_init(struct pci_dev *dev)
+{
+	switch (PCI_SLOT(dev->devfn)) {
+	case 17:
+		dev->dev.platform_data = &eap7660d_wmac0_data;
+		break;
+
+	case 18:
+		dev->dev.platform_data = &eap7660d_wmac1_data;
+		break;
+	}
+
+	return 0;
+}
+
+void __init eap7660d_pci_init(u8 *cal_data0, u8 *mac_addr0,
+			      u8 *cal_data1, u8 *mac_addr1)
+{
+	if (cal_data0 && *cal_data0 == 0xa55a) {
+		memcpy(eap7660d_wmac0_eeprom, cal_data0,
+			ATH5K_PLAT_EEP_MAX_WORDS);
+		eap7660d_wmac0_data.eeprom_data = eap7660d_wmac0_eeprom;
+	}
+
+	if (cal_data1 && *cal_data1 == 0xa55a) {
+		memcpy(eap7660d_wmac1_eeprom, cal_data1,
+			ATH5K_PLAT_EEP_MAX_WORDS);
+		eap7660d_wmac1_data.eeprom_data = eap7660d_wmac1_eeprom;
+	}
+
+	if (mac_addr0) {
+		memcpy(eap7660d_wmac0_mac, mac_addr0,
+			sizeof(eap7660d_wmac0_mac));
+		eap7660d_wmac0_data.macaddr = eap7660d_wmac0_mac;
+	}
+
+	if (mac_addr1) {
+		memcpy(eap7660d_wmac1_mac, mac_addr1,
+			sizeof(eap7660d_wmac1_mac));
+		eap7660d_wmac1_data.macaddr = eap7660d_wmac1_mac;
+	}
+
+	ath79_pci_set_plat_dev_init(eap7660d_pci_plat_dev_init);
+	ath79_register_pci();
+}
+#else
+static inline void eap7660d_pci_init(u8 *cal_data0, u8 *mac_addr0,
+				     u8 *cal_data1, u8 *mac_addr1)
+{
+}
+#endif /* CONFIG_PCI */
+
+static struct gpio_led eap7660d_leds_gpio[] __initdata = {
+	{
+		.name		= "eap7660d:green:ds8",
+		.gpio		= EAP7660D_GPIO_DS8,
+		.active_low	= 0,
+	},
+	{
+		.name		= "eap7660d:green:ds5",
+		.gpio		= EAP7660D_GPIO_DS5,
+		.active_low	= 0,
+	},
+	{
+		.name		= "eap7660d:green:ds7",
+		.gpio		= EAP7660D_GPIO_DS7,
+		.active_low	= 0,
+	},
+	{
+		.name		= "eap7660d:green:ds4",
+		.gpio		= EAP7660D_GPIO_DS4,
+		.active_low	= 0,
+	}
+};
+
+static struct gpio_keys_button eap7660d_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = EAP7660D_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= EAP7660D_GPIO_SW1,
+		.active_low	= 1,
+	},
+	{
+		.desc		= "wps",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = EAP7660D_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= EAP7660D_GPIO_SW3,
+		.active_low	= 1,
+	}
+};
+
+static const char *eap7660d_part_probes[] = {
+	"RedBoot",
+	NULL,
+};
+
+static struct flash_platform_data eap7660d_flash_data = {
+	.part_probes	= eap7660d_part_probes,
+};
+
+static void __init eap7660d_setup(void)
+{
+	u8 *boardconfig = (u8 *) KSEG1ADDR(EAP7660D_BOARDCONFIG);
+
+	ath79_register_mdio(0, ~EAP7660D_PHYMASK);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr,
+			boardconfig + EAP7660D_GBIC_MAC_OFFSET, 0);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.phy_mask = EAP7660D_PHYMASK;
+	ath79_register_eth(0);
+	ath79_register_m25p80(&eap7660d_flash_data);
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(eap7660d_leds_gpio),
+					eap7660d_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, EAP7660D_KEYS_POLL_INTERVAL,
+					 ARRAY_SIZE(eap7660d_gpio_keys),
+					 eap7660d_gpio_keys);
+	eap7660d_pci_init(boardconfig + EAP7660D_WMAC0_CALDATA_OFFSET,
+			  boardconfig + EAP7660D_WMAC0_MAC_OFFSET,
+			  boardconfig + EAP7660D_WMAC1_CALDATA_OFFSET,
+			  boardconfig + EAP7660D_WMAC1_MAC_OFFSET);
+};
+
+MIPS_MACHINE(ATH79_MACH_EAP7660D, "EAP7660D", "Senao EAP7660D",
+	     eap7660d_setup);
diff --git a/arch/mips/ath79/mach-ew-dorin.c b/arch/mips/ath79/mach-ew-dorin.c
new file mode 100644
index 0000000..dc052c4
--- /dev/null
+++ b/arch/mips/ath79/mach-ew-dorin.c
@@ -0,0 +1,108 @@
+/*
+ *  EW Dorin board support
+ *  (based on Atheros Ref. Design AP121)
+ *  Copyright (C) 2011-2012 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2012 Embedded Wireless GmbH    www.80211.de
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-spi.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define DORIN_KEYS_POLL_INTERVAL	20	/* msecs */
+#define DORIN_KEYS_DEBOUNCE_INTERVAL	(3 * DORIN_KEYS_POLL_INTERVAL)
+
+#define DORIN_CALDATA_OFFSET		0x1000
+#define DORIN_WMAC_MAC_OFFSET		0x1002
+
+#define DORIN_GPIO_LED_21		21
+#define DORIN_GPIO_LED_22		22
+
+#define DORIN_GPIO_BTN_JUMPSTART	11
+#define DORIN_GPIO_BTN_RESET		6
+
+static struct gpio_led dorin_leds_gpio[] __initdata = {
+	{
+		.name		= "dorin:green:led21",
+		.gpio		= DORIN_GPIO_LED_21,
+		.active_low	= 1,
+	},
+	{
+		.name		= "dorin:green:led22",
+		.gpio		= DORIN_GPIO_LED_22,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button dorin_gpio_keys[] __initdata = {
+	{
+		.desc		= "jumpstart button",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = DORIN_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= DORIN_GPIO_BTN_JUMPSTART,
+		.active_low	= 1,
+	},
+	{
+		.desc		= "reset button",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = DORIN_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= DORIN_GPIO_BTN_RESET,
+		.active_low	= 0,
+	}
+};
+
+static void __init ew_dorin_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+	static u8 mac[6];
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_usb();
+
+	if (ar93xx_wmac_read_mac_address(mac)) {
+		ath79_register_wmac(NULL, NULL);
+	} else {
+		ath79_register_wmac(art + DORIN_CALDATA_OFFSET,
+				    art + DORIN_WMAC_MAC_OFFSET);
+		memcpy(mac, art + DORIN_WMAC_MAC_OFFSET, sizeof(mac));
+	}
+
+	mac[3] |= 0x40;
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac, 0);
+
+	mac[3] &= 0x3F;
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 0);
+	ath79_setup_ar933x_phy4_switch(true, true);
+
+	ath79_register_mdio(0, 0x0);
+
+	/* LAN ports */
+	ath79_register_eth(1);
+
+	/* WAN port */
+	ath79_register_eth(0);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(dorin_leds_gpio),
+				 dorin_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, DORIN_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(dorin_gpio_keys),
+					dorin_gpio_keys);
+}
+
+MIPS_MACHINE(ATH79_MACH_EW_DORIN, "EW-DORIN", "EmbWir-Dorin",
+	     ew_dorin_setup);
diff --git a/arch/mips/ath79/mach-hornet-ub.c b/arch/mips/ath79/mach-hornet-ub.c
new file mode 100644
index 0000000..f8870e7
--- /dev/null
+++ b/arch/mips/ath79/mach-hornet-ub.c
@@ -0,0 +1,136 @@
+/*
+ *  ALFA NETWORKS Hornet-UB board support
+ *
+ *  Copyright (C) 2011-2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/gpio.h>
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define HORNET_UB_GPIO_LED_WLAN		0
+#define HORNET_UB_GPIO_LED_USB		1
+#define HORNET_UB_GPIO_LED_LAN		13
+#define HORNET_UB_GPIO_LED_WAN		17
+#define HORNET_UB_GPIO_LED_WPS		27
+
+#define HORNET_UB_GPIO_BTN_RESET	11
+#define HORNET_UB_GPIO_BTN_WPS		12
+
+#define HORNET_UB_GPIO_USB_POWER	26
+
+#define HORNET_UB_KEYS_POLL_INTERVAL	20	/* msecs */
+#define HORNET_UB_KEYS_DEBOUNCE_INTERVAL	(3 * HORNET_UB_KEYS_POLL_INTERVAL)
+
+#define HORNET_UB_MAC0_OFFSET		0x0000
+#define HORNET_UB_MAC1_OFFSET		0x0006
+#define HORNET_UB_CALDATA_OFFSET	0x1000
+
+static struct gpio_led hornet_ub_leds_gpio[] __initdata = {
+	{
+		.name		= "alfa:blue:lan",
+		.gpio		= HORNET_UB_GPIO_LED_LAN,
+		.active_low	= 0,
+	},
+	{
+		.name		= "alfa:blue:usb",
+		.gpio		= HORNET_UB_GPIO_LED_USB,
+		.active_low	= 0,
+	},
+	{
+		.name		= "alfa:blue:wan",
+		.gpio		= HORNET_UB_GPIO_LED_WAN,
+		.active_low	= 1,
+	},
+	{
+		.name		= "alfa:blue:wlan",
+		.gpio		= HORNET_UB_GPIO_LED_WLAN,
+		.active_low	= 0,
+	},
+	{
+		.name		= "alfa:blue:wps",
+		.gpio		= HORNET_UB_GPIO_LED_WPS,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button hornet_ub_gpio_keys[] __initdata = {
+	{
+		.desc		= "WPS button",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = HORNET_UB_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= HORNET_UB_GPIO_BTN_WPS,
+		.active_low	= 1,
+	},
+	{
+		.desc		= "Reset button",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = HORNET_UB_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= HORNET_UB_GPIO_BTN_RESET,
+		.active_low	= 0,
+	}
+};
+
+static void __init hornet_ub_gpio_setup(void)
+{
+	u32 t;
+
+	ath79_gpio_function_disable(AR933X_GPIO_FUNC_ETH_SWITCH_LED0_EN |
+				     AR933X_GPIO_FUNC_ETH_SWITCH_LED1_EN |
+				     AR933X_GPIO_FUNC_ETH_SWITCH_LED2_EN |
+				     AR933X_GPIO_FUNC_ETH_SWITCH_LED3_EN |
+				     AR933X_GPIO_FUNC_ETH_SWITCH_LED4_EN);
+
+	t = ath79_reset_rr(AR933X_RESET_REG_BOOTSTRAP);
+	t |= AR933X_BOOTSTRAP_MDIO_GPIO_EN;
+	ath79_reset_wr(AR933X_RESET_REG_BOOTSTRAP, t);
+
+	ath79_set_usb_power_gpio(HORNET_UB_GPIO_USB_POWER, GPIOF_OUT_INIT_HIGH,
+				"USB power");
+}
+
+static void __init hornet_ub_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+
+	hornet_ub_gpio_setup();
+
+	ath79_register_m25p80(NULL);
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(hornet_ub_leds_gpio),
+					hornet_ub_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, HORNET_UB_KEYS_POLL_INTERVAL,
+					 ARRAY_SIZE(hornet_ub_gpio_keys),
+					 hornet_ub_gpio_keys);
+
+	ath79_init_mac(ath79_eth1_data.mac_addr,
+			art + HORNET_UB_MAC0_OFFSET, 0);
+	ath79_init_mac(ath79_eth0_data.mac_addr,
+			art + HORNET_UB_MAC1_OFFSET, 0);
+
+	ath79_register_mdio(0, 0x0);
+
+	ath79_register_eth(1);
+	ath79_register_eth(0);
+
+	ath79_register_wmac(art + HORNET_UB_CALDATA_OFFSET, NULL);
+	ath79_register_usb();
+}
+
+MIPS_MACHINE(ATH79_MACH_HORNET_UB, "HORNET-UB", "ALFA NETWORKS Hornet-UB",
+	     hornet_ub_setup);
diff --git a/arch/mips/ath79/mach-ja76pf.c b/arch/mips/ath79/mach-ja76pf.c
new file mode 100644
index 0000000..d1fe0f8
--- /dev/null
+++ b/arch/mips/ath79/mach-ja76pf.c
@@ -0,0 +1,190 @@
+/*
+ *  jjPlus JA76PF board support
+ */
+
+#include <linux/i2c.h>
+#include <linux/i2c-gpio.h>
+#include <linux/platform_device.h>
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "machtypes.h"
+#include "pci.h"
+
+#define JA76PF_KEYS_POLL_INTERVAL	20	/* msecs */
+#define JA76PF_KEYS_DEBOUNCE_INTERVAL	(3 * JA76PF_KEYS_POLL_INTERVAL)
+
+#define JA76PF_GPIO_I2C_SCL		0
+#define JA76PF_GPIO_I2C_SDA		1
+#define JA76PF_GPIO_LED_1		5
+#define JA76PF_GPIO_LED_2		4
+#define JA76PF_GPIO_LED_3		3
+#define JA76PF_GPIO_BTN_RESET		11
+
+static struct gpio_led ja76pf_leds_gpio[] __initdata = {
+	{
+		.name		= "jjplus:green:led1",
+		.gpio		= JA76PF_GPIO_LED_1,
+		.active_low	= 1,
+	}, {
+		.name		= "jjplus:green:led2",
+		.gpio		= JA76PF_GPIO_LED_2,
+		.active_low	= 1,
+	}, {
+		.name		= "jjplus:green:led3",
+		.gpio		= JA76PF_GPIO_LED_3,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button ja76pf_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = JA76PF_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= JA76PF_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}
+};
+
+static struct i2c_gpio_platform_data ja76pf_i2c_gpio_data = {
+	.sda_pin	= JA76PF_GPIO_I2C_SDA,
+	.scl_pin	= JA76PF_GPIO_I2C_SCL,
+};
+
+static struct platform_device ja76pf_i2c_gpio_device = {
+	.name		= "i2c-gpio",
+	.id		= 0,
+	.dev = {
+		.platform_data  = &ja76pf_i2c_gpio_data,
+	}
+};
+
+static const char *ja76pf_part_probes[] = {
+	"RedBoot",
+	NULL,
+};
+
+static struct flash_platform_data ja76pf_flash_data = {
+	.part_probes	= ja76pf_part_probes,
+};
+
+#define JA76PF_WAN_PHYMASK	(1 << 4)
+#define JA76PF_LAN_PHYMASK	((1 << 0) | (1 << 1) | (1 << 2) | (1 < 3))
+#define JA76PF_MDIO_PHYMASK	(JA76PF_LAN_PHYMASK | JA76PF_WAN_PHYMASK)
+
+static void __init ja76pf_init(void)
+{
+	ath79_register_m25p80(&ja76pf_flash_data);
+
+	ath79_register_mdio(0, ~JA76PF_MDIO_PHYMASK);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, ath79_mac_base, 0);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.phy_mask = JA76PF_LAN_PHYMASK;
+
+	ath79_init_mac(ath79_eth1_data.mac_addr, ath79_mac_base, 1);
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth1_data.phy_mask = JA76PF_WAN_PHYMASK;
+	ath79_eth1_data.speed = SPEED_1000;
+	ath79_eth1_data.duplex = DUPLEX_FULL;
+
+	ath79_register_eth(0);
+	ath79_register_eth(1);
+
+	platform_device_register(&ja76pf_i2c_gpio_device);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(ja76pf_leds_gpio),
+					ja76pf_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, JA76PF_KEYS_POLL_INTERVAL,
+					 ARRAY_SIZE(ja76pf_gpio_keys),
+					 ja76pf_gpio_keys);
+
+	ath79_register_usb();
+	ath79_register_pci();
+}
+
+MIPS_MACHINE(ATH79_MACH_JA76PF, "JA76PF", "jjPlus JA76PF", ja76pf_init);
+
+#define JA76PF2_GPIO_LED_D2		5
+#define JA76PF2_GPIO_LED_D3		4
+#define JA76PF2_GPIO_LED_D4		3
+#define JA76PF2_GPIO_BTN_RESET		7
+#define JA76PF2_GPIO_BTN_WPS		8
+
+static struct gpio_led ja76pf2_leds_gpio[] __initdata = {
+	{
+		.name		= "jjplus:green:led1",
+		.gpio		= JA76PF2_GPIO_LED_D2,
+		.active_low	= 1,
+	}, {
+		.name		= "jjplus:green:led2",
+		.gpio		= JA76PF2_GPIO_LED_D3,
+		.active_low	= 0,
+	}, {
+		.name		= "jjplus:green:led3",
+		.gpio		= JA76PF2_GPIO_LED_D4,
+		.active_low	= 0,
+	}
+};
+
+static struct gpio_keys_button ja76pf2_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = JA76PF_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= JA76PF2_GPIO_BTN_RESET,
+		.active_low	= 1,
+	},
+	{
+		.desc		= "wps",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = JA76PF_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= JA76PF2_GPIO_BTN_WPS,
+		.active_low	= 1,
+	},
+};
+
+#define JA76PF2_LAN_PHYMASK	BIT(0)
+#define JA76PF2_WAN_PHYMASK	BIT(4)
+#define JA76PF2_MDIO_PHYMASK	(JA76PF2_LAN_PHYMASK | JA76PF2_WAN_PHYMASK)
+
+static void __init ja76pf2_init(void)
+{
+	ath79_register_m25p80(&ja76pf_flash_data);
+
+	ath79_register_mdio(0, ~JA76PF2_MDIO_PHYMASK);
+
+	/* MAC0 is connected to the CPU port of the AR8316 switch */
+	ath79_init_mac(ath79_eth0_data.mac_addr, ath79_mac_base, 0);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.phy_mask = BIT(0);
+
+	/* MAC1 is connected to the PHY4 of the AR8316 switch */
+	ath79_init_mac(ath79_eth1_data.mac_addr, ath79_mac_base, 1);
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth1_data.phy_mask = BIT(4);
+
+	ath79_register_eth(0);
+	ath79_register_eth(1);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(ja76pf2_leds_gpio),
+				 ja76pf2_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, JA76PF_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(ja76pf2_gpio_keys),
+					ja76pf2_gpio_keys);
+
+	ath79_register_pci();
+}
+
+MIPS_MACHINE(ATH79_MACH_JA76PF2, "JA76PF2", "jjPlus JA76PF2", ja76pf2_init);
diff --git a/arch/mips/ath79/mach-jwap003.c b/arch/mips/ath79/mach-jwap003.c
new file mode 100644
index 0000000..a3c93cc
--- /dev/null
+++ b/arch/mips/ath79/mach-jwap003.c
@@ -0,0 +1,95 @@
+/*
+ *  jjPlus JWAP003 board support
+ *
+ */
+
+#include <linux/i2c.h>
+#include <linux/i2c-gpio.h>
+#include <linux/platform_device.h>
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-eth.h"
+#include "dev-m25p80.h"
+#include "dev-gpio-buttons.h"
+#include "dev-usb.h"
+#include "machtypes.h"
+#include "pci.h"
+
+#define JWAP003_KEYS_POLL_INTERVAL	20	/* msecs */
+#define JWAP003_KEYS_DEBOUNCE_INTERVAL	(3 * JWAP003_KEYS_POLL_INTERVAL)
+
+#define JWAP003_GPIO_WPS	11
+#define JWAP003_GPIO_I2C_SCL	0
+#define JWAP003_GPIO_I2C_SDA	1
+
+static struct gpio_keys_button jwap003_gpio_keys[] __initdata = {
+	{
+		.desc		= "wps",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = JWAP003_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= JWAP003_GPIO_WPS,
+		.active_low	= 1,
+	}
+};
+
+static struct i2c_gpio_platform_data jwap003_i2c_gpio_data = {
+	.sda_pin	= JWAP003_GPIO_I2C_SDA,
+	.scl_pin	= JWAP003_GPIO_I2C_SCL,
+};
+
+static struct platform_device jwap003_i2c_gpio_device = {
+	.name		= "i2c-gpio",
+	.id		= 0,
+	.dev = {
+		.platform_data  = &jwap003_i2c_gpio_data,
+	}
+};
+
+static const char *jwap003_part_probes[] = {
+	"RedBoot",
+	NULL,
+};
+
+static struct flash_platform_data jwap003_flash_data = {
+	.part_probes	= jwap003_part_probes,
+};
+
+#define JWAP003_WAN_PHYMASK	BIT(0)
+#define JWAP003_LAN_PHYMASK	BIT(4)
+
+static void __init jwap003_init(void)
+{
+	ath79_register_m25p80(&jwap003_flash_data);
+
+	ath79_register_mdio(0, 0x0);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, ath79_mac_base, 0);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ath79_eth0_data.phy_mask = JWAP003_WAN_PHYMASK;
+	ath79_eth0_data.speed = SPEED_100;
+	ath79_eth0_data.duplex = DUPLEX_FULL;
+	ath79_eth0_data.has_ar8216 = 1;
+
+	ath79_init_mac(ath79_eth1_data.mac_addr, ath79_mac_base, 1);
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ath79_eth1_data.phy_mask = JWAP003_LAN_PHYMASK;
+	ath79_eth1_data.speed = SPEED_100;
+	ath79_eth1_data.duplex = DUPLEX_FULL;
+
+	ath79_register_eth(0);
+	ath79_register_eth(1);
+
+	platform_device_register(&jwap003_i2c_gpio_device);
+
+	ath79_register_usb();
+
+	ath79_register_gpio_keys_polled(-1, JWAP003_KEYS_POLL_INTERVAL,
+					 ARRAY_SIZE(jwap003_gpio_keys),
+					 jwap003_gpio_keys);
+
+	ath79_register_pci();
+}
+
+MIPS_MACHINE(ATH79_MACH_JWAP003, "JWAP003", "jjPlus JWAP003", jwap003_init);
diff --git a/arch/mips/ath79/mach-mzk-w04nu.c b/arch/mips/ath79/mach-mzk-w04nu.c
new file mode 100644
index 0000000..c2460ce
--- /dev/null
+++ b/arch/mips/ath79/mach-mzk-w04nu.c
@@ -0,0 +1,124 @@
+/*
+ *  Planex MZK-W04NU board support
+ *
+ *  Copyright (C) 2009-2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define MZK_W04NU_GPIO_LED_USB		0
+#define MZK_W04NU_GPIO_LED_STATUS	1
+#define MZK_W04NU_GPIO_LED_WPS		3
+#define MZK_W04NU_GPIO_LED_WLAN		6
+#define MZK_W04NU_GPIO_LED_AP		15
+#define MZK_W04NU_GPIO_LED_ROUTER	16
+
+#define MZK_W04NU_GPIO_BTN_APROUTER	5
+#define MZK_W04NU_GPIO_BTN_WPS		12
+#define MZK_W04NU_GPIO_BTN_RESET	21
+
+#define MZK_W04NU_KEYS_POLL_INTERVAL	20	/* msecs */
+#define MZK_W04NU_KEYS_DEBOUNCE_INTERVAL (3 * MZK_W04NU_KEYS_POLL_INTERVAL)
+
+static struct gpio_led mzk_w04nu_leds_gpio[] __initdata = {
+	{
+		.name		= "planex:green:status",
+		.gpio		= MZK_W04NU_GPIO_LED_STATUS,
+		.active_low	= 1,
+	}, {
+		.name		= "planex:blue:wps",
+		.gpio		= MZK_W04NU_GPIO_LED_WPS,
+		.active_low	= 1,
+	}, {
+		.name		= "planex:green:wlan",
+		.gpio		= MZK_W04NU_GPIO_LED_WLAN,
+		.active_low	= 1,
+	}, {
+		.name		= "planex:green:usb",
+		.gpio		= MZK_W04NU_GPIO_LED_USB,
+		.active_low	= 1,
+	}, {
+		.name		= "planex:green:ap",
+		.gpio		= MZK_W04NU_GPIO_LED_AP,
+		.active_low	= 1,
+	}, {
+		.name		= "planex:green:router",
+		.gpio		= MZK_W04NU_GPIO_LED_ROUTER,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button mzk_w04nu_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = MZK_W04NU_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= MZK_W04NU_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}, {
+		.desc		= "wps",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = MZK_W04NU_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= MZK_W04NU_GPIO_BTN_WPS,
+		.active_low	= 1,
+	}, {
+		.desc		= "aprouter",
+		.type		= EV_KEY,
+		.code		= BTN_2,
+		.debounce_interval = MZK_W04NU_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= MZK_W04NU_GPIO_BTN_APROUTER,
+		.active_low	= 0,
+	}
+};
+
+#define MZK_W04NU_WAN_PHYMASK	BIT(4)
+#define MZK_W04NU_MDIO_MASK	(~MZK_W04NU_WAN_PHYMASK)
+
+static void __init mzk_w04nu_setup(void)
+{
+	u8 *eeprom = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	ath79_register_mdio(0, MZK_W04NU_MDIO_MASK);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, eeprom, 0);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ath79_eth0_data.speed = SPEED_100;
+	ath79_eth0_data.duplex = DUPLEX_FULL;
+	ath79_eth0_data.has_ar8216 = 1;
+
+	ath79_init_mac(ath79_eth1_data.mac_addr, eeprom, 1);
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ath79_eth1_data.phy_mask = MZK_W04NU_WAN_PHYMASK;
+
+	ath79_register_eth(0);
+	ath79_register_eth(1);
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(mzk_w04nu_leds_gpio),
+				 mzk_w04nu_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, MZK_W04NU_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(mzk_w04nu_gpio_keys),
+					mzk_w04nu_gpio_keys);
+	ath79_register_usb();
+
+	ath79_register_wmac(eeprom, NULL);
+}
+
+MIPS_MACHINE(ATH79_MACH_MZK_W04NU, "MZK-W04NU", "Planex MZK-W04NU",
+	     mzk_w04nu_setup);
diff --git a/arch/mips/ath79/mach-mzk-w300nh.c b/arch/mips/ath79/mach-mzk-w300nh.c
new file mode 100644
index 0000000..8c40365
--- /dev/null
+++ b/arch/mips/ath79/mach-mzk-w300nh.c
@@ -0,0 +1,115 @@
+/*
+ *  Planex MZK-W300NH board support
+ *
+ *  Copyright (C) 2008-2012 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define MZK_W300NH_GPIO_LED_STATUS	1
+#define MZK_W300NH_GPIO_LED_WPS		3
+#define MZK_W300NH_GPIO_LED_WLAN	6
+#define MZK_W300NH_GPIO_LED_AP_GREEN	15
+#define MZK_W300NH_GPIO_LED_AP_AMBER	16
+
+#define MZK_W300NH_GPIO_BTN_APROUTER	5
+#define MZK_W300NH_GPIO_BTN_WPS		12
+#define MZK_W300NH_GPIO_BTN_RESET	21
+
+#define MZK_W300NH_KEYS_POLL_INTERVAL	20	/* msecs */
+#define MZK_W300NH_KEYS_DEBOUNCE_INTERVAL (3 * MZK_W300NH_KEYS_POLL_INTERVAL)
+
+static struct gpio_led mzk_w300nh_leds_gpio[] __initdata = {
+	{
+		.name		= "planex:green:status",
+		.gpio		= MZK_W300NH_GPIO_LED_STATUS,
+		.active_low	= 1,
+	}, {
+		.name		= "planex:blue:wps",
+		.gpio		= MZK_W300NH_GPIO_LED_WPS,
+		.active_low	= 1,
+	}, {
+		.name		= "planex:green:wlan",
+		.gpio		= MZK_W300NH_GPIO_LED_WLAN,
+		.active_low	= 1,
+	}, {
+		.name		= "planex:green:aprouter",
+		.gpio		= MZK_W300NH_GPIO_LED_AP_GREEN,
+	}, {
+		.name		= "planex:amber:aprouter",
+		.gpio		= MZK_W300NH_GPIO_LED_AP_AMBER,
+	}
+};
+
+static struct gpio_keys_button mzk_w300nh_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = MZK_W300NH_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= MZK_W300NH_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}, {
+		.desc		= "wps",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = MZK_W300NH_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= MZK_W300NH_GPIO_BTN_WPS,
+		.active_low	= 1,
+	}, {
+		.desc		= "aprouter",
+		.type		= EV_KEY,
+		.code		= BTN_2,
+		.debounce_interval = MZK_W300NH_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= MZK_W300NH_GPIO_BTN_APROUTER,
+		.active_low	= 0,
+	}
+};
+
+#define MZK_W300NH_WAN_PHYMASK	BIT(4)
+#define MZK_W300NH_MDIO_MASK	(~MZK_W300NH_WAN_PHYMASK)
+
+static void __init mzk_w300nh_setup(void)
+{
+	u8 *eeprom = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	ath79_register_mdio(0, MZK_W300NH_MDIO_MASK);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, eeprom, 0);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ath79_eth0_data.speed = SPEED_100;
+	ath79_eth0_data.duplex = DUPLEX_FULL;
+	ath79_eth0_data.has_ar8216 = 1;
+
+	ath79_init_mac(ath79_eth1_data.mac_addr, eeprom, 1);
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ath79_eth1_data.phy_mask = MZK_W300NH_WAN_PHYMASK;
+
+	ath79_register_eth(0);
+	ath79_register_eth(1);
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(mzk_w300nh_leds_gpio),
+				 mzk_w300nh_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, MZK_W300NH_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(mzk_w300nh_gpio_keys),
+					mzk_w300nh_gpio_keys);
+	ath79_register_wmac(eeprom, NULL);
+}
+
+MIPS_MACHINE(ATH79_MACH_MZK_W300NH, "MZK-W300NH", "Planex MZK-W300NH",
+	     mzk_w300nh_setup);
diff --git a/arch/mips/ath79/mach-nbg460n.c b/arch/mips/ath79/mach-nbg460n.c
new file mode 100644
index 0000000..8aa7331
--- /dev/null
+++ b/arch/mips/ath79/mach-nbg460n.c
@@ -0,0 +1,220 @@
+/*
+ *  Zyxel NBG 460N/550N/550NH board support
+ *
+ *  Copyright (C) 2010 Michael Kurz <michi.kurz@googlemail.com>
+ *
+ *  based on mach-tl-wr1043nd.c
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/i2c-algo-bit.h>
+#include <linux/i2c-gpio.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <linux/platform_device.h>
+#include <linux/rtl8366.h>
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+/* LEDs */
+#define NBG460N_GPIO_LED_WPS		3
+#define NBG460N_GPIO_LED_WAN		6
+#define NBG460N_GPIO_LED_POWER		14
+#define NBG460N_GPIO_LED_WLAN		15
+
+/* Buttons */
+#define NBG460N_GPIO_BTN_WPS		12
+#define NBG460N_GPIO_BTN_RESET		21
+
+#define NBG460N_KEYS_POLL_INTERVAL	20	/* msecs */
+#define NBG460N_KEYS_DEBOUNCE_INTERVAL	(3 * NBG460N_KEYS_POLL_INTERVAL)
+
+/* RTC chip PCF8563 I2C interface */
+#define NBG460N_GPIO_PCF8563_SDA	8
+#define NBG460N_GPIO_PCF8563_SCK	7
+
+/* Switch configuration I2C interface */
+#define NBG460N_GPIO_RTL8366_SDA	16
+#define NBG460N_GPIO_RTL8366_SCK	18
+
+static struct mtd_partition nbg460n_partitions[] = {
+	{
+		.name		= "Bootbase",
+		.offset		= 0,
+		.size		= 0x010000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "U-Boot Config",
+		.offset		= 0x010000,
+		.size		= 0x030000,
+	}, {
+		.name		= "U-Boot",
+		.offset		= 0x040000,
+		.size		= 0x030000,
+	}, {
+		.name		= "linux",
+		.offset		= 0x070000,
+		.size		= 0x0e0000,
+	}, {
+		.name		= "rootfs",
+		.offset		= 0x150000,
+		.size		= 0x2a0000,
+	}, {
+		.name		= "CalibData",
+		.offset		= 0x3f0000,
+		.size		= 0x010000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "firmware",
+		.offset		= 0x070000,
+		.size		= 0x380000,
+	}
+};
+
+static struct flash_platform_data nbg460n_flash_data = {
+	.parts		= nbg460n_partitions,
+	.nr_parts       = ARRAY_SIZE(nbg460n_partitions),
+};
+
+static struct gpio_led nbg460n_leds_gpio[] __initdata = {
+	{
+		.name		= "nbg460n:green:power",
+		.gpio		= NBG460N_GPIO_LED_POWER,
+		.active_low	= 0,
+		.default_trigger = "default-on",
+	}, {
+		.name		= "nbg460n:green:wps",
+		.gpio		= NBG460N_GPIO_LED_WPS,
+		.active_low	= 0,
+	}, {
+		.name		= "nbg460n:green:wlan",
+		.gpio		= NBG460N_GPIO_LED_WLAN,
+		.active_low	= 0,
+	}, {
+		/* Not really for controlling the LED,
+		   when set low the LED blinks uncontrollable  */
+		.name		= "nbg460n:green:wan",
+		.gpio		= NBG460N_GPIO_LED_WAN,
+		.active_low	= 0,
+	}
+};
+
+static struct gpio_keys_button nbg460n_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = NBG460N_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= NBG460N_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}, {
+		.desc		= "wps",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = NBG460N_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= NBG460N_GPIO_BTN_WPS,
+		.active_low	= 1,
+	}
+};
+
+static struct i2c_gpio_platform_data nbg460n_i2c_device_platdata = {
+	.sda_pin	= NBG460N_GPIO_PCF8563_SDA,
+	.scl_pin	= NBG460N_GPIO_PCF8563_SCK,
+	.udelay		= 10,
+};
+
+static struct platform_device nbg460n_i2c_device = {
+	.name		= "i2c-gpio",
+	.id		= -1,
+	.num_resources	= 0,
+	.resource	= NULL,
+	.dev		= {
+		.platform_data	= &nbg460n_i2c_device_platdata,
+	},
+};
+
+static struct i2c_board_info nbg460n_i2c_devs[] __initdata = {
+	{
+		I2C_BOARD_INFO("pcf8563", 0x51),
+	},
+};
+
+static void __devinit nbg460n_i2c_init(void)
+{
+	/* The gpio interface */
+	platform_device_register(&nbg460n_i2c_device);
+	/* I2C devices */
+	i2c_register_board_info(0, nbg460n_i2c_devs,
+				ARRAY_SIZE(nbg460n_i2c_devs));
+}
+
+
+static struct rtl8366_platform_data nbg460n_rtl8366s_data = {
+	.gpio_sda	= NBG460N_GPIO_RTL8366_SDA,
+	.gpio_sck	= NBG460N_GPIO_RTL8366_SCK,
+};
+
+static struct platform_device nbg460n_rtl8366s_device = {
+	.name		= RTL8366S_DRIVER_NAME,
+	.id		= -1,
+	.dev = {
+		.platform_data	= &nbg460n_rtl8366s_data,
+	}
+};
+
+static void __init nbg460n_setup(void)
+{
+	/* end of bootloader sector contains mac address */
+	u8 *mac = (u8 *) KSEG1ADDR(0x1fc0fff8);
+	/* last sector contains wlan calib data */
+	u8 *eeprom = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	/* LAN Port */
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 0);
+	ath79_eth0_data.mii_bus_dev = &nbg460n_rtl8366s_device.dev;
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.speed = SPEED_1000;
+	ath79_eth0_data.duplex = DUPLEX_FULL;
+
+	/* WAN Port */
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac, 1);
+	ath79_eth1_data.mii_bus_dev = &nbg460n_rtl8366s_device.dev;
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth1_data.phy_mask = 0x10;
+
+	ath79_register_eth(0);
+	ath79_register_eth(1);
+
+	/* register the switch phy */
+	platform_device_register(&nbg460n_rtl8366s_device);
+
+	/* register flash */
+	ath79_register_m25p80(&nbg460n_flash_data);
+
+	ath79_register_wmac(eeprom, mac);
+
+	/* register RTC chip */
+	nbg460n_i2c_init();
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(nbg460n_leds_gpio),
+				 nbg460n_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, NBG460N_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(nbg460n_gpio_keys),
+					nbg460n_gpio_keys);
+}
+
+MIPS_MACHINE(ATH79_MACH_NBG460N, "NBG460N", "Zyxel NBG460N/550N/550NH",
+	     nbg460n_setup);
diff --git a/arch/mips/ath79/mach-om2p.c b/arch/mips/ath79/mach-om2p.c
new file mode 100644
index 0000000..faeb49a
--- /dev/null
+++ b/arch/mips/ath79/mach-om2p.c
@@ -0,0 +1,176 @@
+/*
+ *  OpenMesh OM2P support
+ *
+ *  Copyright (C) 2011 Marek Lindner <marek@open-mesh.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/gpio.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <linux/platform_device.h>
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+#include <asm/mach-ath79/ath79.h>
+
+#include "common.h"
+#include "dev-ap9x-pci.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define OM2P_GPIO_LED_POWER	0
+#define OM2P_GPIO_LED_GREEN	13
+#define OM2P_GPIO_LED_RED	14
+#define OM2P_GPIO_LED_YELLOW	15
+#define OM2P_GPIO_LED_LAN	16
+#define OM2P_GPIO_LED_WAN	17
+#define OM2P_GPIO_BTN_RESET	11
+
+#define OM2P_KEYS_POLL_INTERVAL		20	/* msecs */
+#define OM2P_KEYS_DEBOUNCE_INTERVAL	(3 * OM2P_KEYS_POLL_INTERVAL)
+
+#define OM2P_WAN_PHYMASK	BIT(4)
+
+#define OM2P_LC_GPIO_LED_POWER	1
+#define OM2P_LC_GPIO_LED_GREEN	15
+#define OM2P_LC_GPIO_LED_RED	16
+#define OM2P_LC_GPIO_LED_YELLOW	0
+#define OM2P_LC_GPIO_LED_LAN	13
+#define OM2P_LC_GPIO_LED_WAN	17
+#define OM2P_LC_GPIO_BTN_RESET	12
+
+static struct flash_platform_data om2p_flash_data = {
+	.type = "s25sl12800",
+	.name = "ar7240-nor0",
+};
+
+static struct gpio_led om2p_leds_gpio[] __initdata = {
+	{
+		.name		= "om2p:blue:power",
+		.gpio		= OM2P_GPIO_LED_POWER,
+		.active_low	= 1,
+	}, {
+		.name		= "om2p:red:wifi",
+		.gpio		= OM2P_GPIO_LED_RED,
+		.active_low	= 1,
+	}, {
+		.name		= "om2p:yellow:wifi",
+		.gpio		= OM2P_GPIO_LED_YELLOW,
+		.active_low	= 1,
+	}, {
+		.name		= "om2p:green:wifi",
+		.gpio		= OM2P_GPIO_LED_GREEN,
+		.active_low	= 1,
+	}, {
+		.name		= "om2p:blue:lan",
+		.gpio		= OM2P_GPIO_LED_LAN,
+		.active_low	= 1,
+	}, {
+		.name		= "om2p:blue:wan",
+		.gpio		= OM2P_GPIO_LED_WAN,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button om2p_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = OM2P_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= OM2P_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}
+};
+
+static void __init om2p_setup(void)
+{
+	u8 *mac1 = (u8 *)KSEG1ADDR(0x1ffc0000);
+	u8 *mac2 = (u8 *)KSEG1ADDR(0x1ffc0000 + ETH_ALEN);
+	u8 *ee = (u8 *)KSEG1ADDR(0x1ffc1000);
+
+	ath79_gpio_function_disable(AR724X_GPIO_FUNC_ETH_SWITCH_LED0_EN |
+				    AR724X_GPIO_FUNC_ETH_SWITCH_LED1_EN |
+				    AR724X_GPIO_FUNC_ETH_SWITCH_LED2_EN |
+				    AR724X_GPIO_FUNC_ETH_SWITCH_LED3_EN |
+				    AR724X_GPIO_FUNC_ETH_SWITCH_LED4_EN);
+
+	ath79_register_m25p80(&om2p_flash_data);
+
+	ath79_register_mdio(0, ~OM2P_WAN_PHYMASK);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac1, 0);
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac2, 0);
+
+	ath79_register_eth(0);
+	ath79_register_eth(1);
+
+	ap91_pci_init(ee, NULL);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(om2p_leds_gpio),
+				 om2p_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, OM2P_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(om2p_gpio_keys),
+					om2p_gpio_keys);
+}
+
+MIPS_MACHINE(ATH79_MACH_OM2P, "OM2P", "OpenMesh OM2P", om2p_setup);
+
+
+static struct flash_platform_data om2p_lc_flash_data = {
+	.type = "s25sl12800",
+};
+
+static void __init om2p_lc_setup(void)
+{
+	u8 *mac1 = (u8 *)KSEG1ADDR(0x1ffc0000);
+	u8 *mac2 = (u8 *)KSEG1ADDR(0x1ffc0000 + ETH_ALEN);
+	u8 *art = (u8 *)KSEG1ADDR(0x1ffc1000);
+	u32 t;
+
+	ath79_gpio_function_disable(AR933X_GPIO_FUNC_ETH_SWITCH_LED0_EN |
+				    AR933X_GPIO_FUNC_ETH_SWITCH_LED1_EN |
+				    AR933X_GPIO_FUNC_ETH_SWITCH_LED2_EN |
+				    AR933X_GPIO_FUNC_ETH_SWITCH_LED3_EN |
+				    AR933X_GPIO_FUNC_ETH_SWITCH_LED4_EN);
+
+	t = ath79_reset_rr(AR933X_RESET_REG_BOOTSTRAP);
+	t |= AR933X_BOOTSTRAP_MDIO_GPIO_EN;
+	ath79_reset_wr(AR933X_RESET_REG_BOOTSTRAP, t);
+
+	ath79_register_m25p80(&om2p_lc_flash_data);
+
+	om2p_leds_gpio[0].gpio = OM2P_LC_GPIO_LED_POWER;
+	om2p_leds_gpio[1].gpio = OM2P_LC_GPIO_LED_RED;
+	om2p_leds_gpio[2].gpio = OM2P_LC_GPIO_LED_YELLOW;
+	om2p_leds_gpio[3].gpio = OM2P_LC_GPIO_LED_GREEN;
+	om2p_leds_gpio[4].gpio = OM2P_LC_GPIO_LED_LAN;
+	om2p_leds_gpio[5].gpio = OM2P_LC_GPIO_LED_WAN;
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(om2p_leds_gpio),
+				 om2p_leds_gpio);
+
+	om2p_gpio_keys[0].gpio = OM2P_LC_GPIO_BTN_RESET;
+	ath79_register_gpio_keys_polled(-1, OM2P_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(om2p_gpio_keys),
+					om2p_gpio_keys);
+
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac1, 0);
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac2, 0);
+
+	ath79_register_mdio(0, 0x0);
+
+	ath79_register_eth(0);
+	ath79_register_eth(1);
+
+	ath79_register_wmac(art, NULL);
+}
+
+MIPS_MACHINE(ATH79_MACH_OM2P_LC, "OM2P-LC", "OpenMesh OM2P LC", om2p_lc_setup);
diff --git a/arch/mips/ath79/mach-pb42.c b/arch/mips/ath79/mach-pb42.c
new file mode 100644
index 0000000..3a350e9
--- /dev/null
+++ b/arch/mips/ath79/mach-pb42.c
@@ -0,0 +1,83 @@
+/*
+ *  Atheros PB42 board support
+ *
+ *  Copyright (C) 2008-2012 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "machtypes.h"
+#include "pci.h"
+
+#define PB42_KEYS_POLL_INTERVAL		20	/* msecs */
+#define PB42_KEYS_DEBOUNCE_INTERVAL	(3 * PB42_KEYS_POLL_INTERVAL)
+
+#define PB42_GPIO_BTN_SW4	8
+#define PB42_GPIO_BTN_SW5	3
+
+static struct gpio_keys_button pb42_gpio_keys[] __initdata = {
+	{
+		.desc		= "sw4",
+		.type		= EV_KEY,
+		.code		= BTN_0,
+		.debounce_interval = PB42_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= PB42_GPIO_BTN_SW4,
+		.active_low	= 1,
+	}, {
+		.desc		= "sw5",
+		.type		= EV_KEY,
+		.code		= BTN_1,
+		.debounce_interval = PB42_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= PB42_GPIO_BTN_SW5,
+		.active_low	= 1,
+	}
+};
+
+static const char *pb42_part_probes[] = {
+	"RedBoot",
+	NULL,
+};
+
+static struct flash_platform_data pb42_flash_data = {
+	.part_probes	= pb42_part_probes,
+};
+
+#define PB42_WAN_PHYMASK	BIT(20)
+#define PB42_LAN_PHYMASK	(BIT(16) | BIT(17) | BIT(18) | BIT(19))
+#define PB42_MDIO_PHYMASK	(PB42_LAN_PHYMASK | PB42_WAN_PHYMASK)
+
+static void __init pb42_init(void)
+{
+	ath79_register_m25p80(&pb42_flash_data);
+
+	ath79_register_mdio(0, ~PB42_MDIO_PHYMASK);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, ath79_mac_base, 0);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ath79_eth0_data.phy_mask = PB42_WAN_PHYMASK;
+
+	ath79_init_mac(ath79_eth1_data.mac_addr, ath79_mac_base, 1);
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ath79_eth1_data.speed = SPEED_100;
+	ath79_eth1_data.duplex = DUPLEX_FULL;
+
+	ath79_register_eth(0);
+	ath79_register_eth(1);
+
+	ath79_register_gpio_keys_polled(-1, PB42_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(pb42_gpio_keys),
+					pb42_gpio_keys);
+
+	ath79_register_pci();
+}
+
+MIPS_MACHINE(ATH79_MACH_PB42, "PB42", "Atheros PB42", pb42_init);
diff --git a/arch/mips/ath79/mach-pb92.c b/arch/mips/ath79/mach-pb92.c
new file mode 100644
index 0000000..76715a5
--- /dev/null
+++ b/arch/mips/ath79/mach-pb92.c
@@ -0,0 +1,70 @@
+/*
+ *  Atheros PB92 board support
+ *
+ *  Copyright (C) 2010 Felix Fietkau <nbd@openwrt.org>
+ *  Copyright (C) 2008-2009 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "machtypes.h"
+#include "pci.h"
+
+#define PB92_KEYS_POLL_INTERVAL		20	/* msecs */
+#define PB92_KEYS_DEBOUNCE_INTERVAL	(3 * PB92_KEYS_POLL_INTERVAL)
+
+#define PB92_GPIO_BTN_SW4	8
+#define PB92_GPIO_BTN_SW5	3
+
+static struct gpio_keys_button pb92_gpio_keys[] __initdata = {
+	{
+		.desc		= "sw4",
+		.type		= EV_KEY,
+		.code		= BTN_0,
+		.debounce_interval = PB92_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= PB92_GPIO_BTN_SW4,
+		.active_low	= 1,
+	}, {
+		.desc		= "sw5",
+		.type		= EV_KEY,
+		.code		= BTN_1,
+		.debounce_interval = PB92_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= PB92_GPIO_BTN_SW5,
+		.active_low	= 1,
+	}
+};
+
+static void __init pb92_init(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1fff0000);
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_mdio(0, ~BIT(0));
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 0);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.speed = SPEED_1000;
+	ath79_eth0_data.duplex = DUPLEX_FULL;
+	ath79_eth0_data.phy_mask = BIT(0);
+
+	ath79_register_eth(0);
+
+	ath79_register_gpio_keys_polled(-1, PB92_KEYS_POLL_INTERVAL,
+					 ARRAY_SIZE(pb92_gpio_keys),
+					 pb92_gpio_keys);
+
+	ath79_register_usb();
+
+	ath79_register_pci();
+}
+
+MIPS_MACHINE(ATH79_MACH_PB92, "PB92", "Atheros PB92", pb92_init);
diff --git a/arch/mips/ath79/mach-rb4xx.c b/arch/mips/ath79/mach-rb4xx.c
new file mode 100644
index 0000000..1604a5c
--- /dev/null
+++ b/arch/mips/ath79/mach-rb4xx.c
@@ -0,0 +1,405 @@
+/*
+ *  MikroTik RouterBOARD 4xx series support
+ *
+ *  Copyright (C) 2008-2012 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/platform_device.h>
+#include <linux/irq.h>
+#include <linux/mdio-gpio.h>
+#include <linux/mmc/host.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/flash.h>
+#include <linux/spi/mmc_spi.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/rb4xx_cpld.h>
+
+#include "common.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-usb.h"
+#include "machtypes.h"
+#include "pci.h"
+
+#define RB4XX_GPIO_USER_LED	4
+#define RB4XX_GPIO_RESET_SWITCH	7
+
+#define RB4XX_GPIO_CPLD_BASE	32
+#define RB4XX_GPIO_CPLD_LED1	(RB4XX_GPIO_CPLD_BASE + CPLD_GPIO_nLED1)
+#define RB4XX_GPIO_CPLD_LED2	(RB4XX_GPIO_CPLD_BASE + CPLD_GPIO_nLED2)
+#define RB4XX_GPIO_CPLD_LED3	(RB4XX_GPIO_CPLD_BASE + CPLD_GPIO_nLED3)
+#define RB4XX_GPIO_CPLD_LED4	(RB4XX_GPIO_CPLD_BASE + CPLD_GPIO_nLED4)
+#define RB4XX_GPIO_CPLD_LED5	(RB4XX_GPIO_CPLD_BASE + CPLD_GPIO_nLED5)
+
+#define RB4XX_KEYS_POLL_INTERVAL	20	/* msecs */
+#define RB4XX_KEYS_DEBOUNCE_INTERVAL	(3 * RB4XX_KEYS_POLL_INTERVAL)
+
+static struct gpio_led rb4xx_leds_gpio[] __initdata = {
+	{
+		.name		= "rb4xx:yellow:user",
+		.gpio		= RB4XX_GPIO_USER_LED,
+		.active_low	= 0,
+	}, {
+		.name		= "rb4xx:green:led1",
+		.gpio		= RB4XX_GPIO_CPLD_LED1,
+		.active_low	= 1,
+	}, {
+		.name		= "rb4xx:green:led2",
+		.gpio		= RB4XX_GPIO_CPLD_LED2,
+		.active_low	= 1,
+	}, {
+		.name		= "rb4xx:green:led3",
+		.gpio		= RB4XX_GPIO_CPLD_LED3,
+		.active_low	= 1,
+	}, {
+		.name		= "rb4xx:green:led4",
+		.gpio		= RB4XX_GPIO_CPLD_LED4,
+		.active_low	= 1,
+	}, {
+		.name		= "rb4xx:green:led5",
+		.gpio		= RB4XX_GPIO_CPLD_LED5,
+		.active_low	= 0,
+	},
+};
+
+static struct gpio_keys_button rb4xx_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset_switch",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = RB4XX_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= RB4XX_GPIO_RESET_SWITCH,
+		.active_low	= 1,
+	}
+};
+
+static struct platform_device rb4xx_nand_device = {
+	.name	= "rb4xx-nand",
+	.id	= -1,
+};
+
+static struct ath79_pci_irq rb4xx_pci_irqs[] __initdata = {
+	{
+		.slot	= 17,
+		.pin	= 1,
+		.irq	= ATH79_PCI_IRQ(2),
+	}, {
+		.slot	= 18,
+		.pin	= 1,
+		.irq	= ATH79_PCI_IRQ(0),
+	}, {
+		.slot	= 18,
+		.pin	= 2,
+		.irq	= ATH79_PCI_IRQ(1),
+	}, {
+		.slot	= 19,
+		.pin	= 1,
+		.irq	= ATH79_PCI_IRQ(1),
+	}, {
+		.slot	= 19,
+		.pin	= 1,
+		.irq	= ATH79_PCI_IRQ(2),
+	}
+};
+
+static struct mtd_partition rb4xx_partitions[] = {
+	{
+		.name		= "routerboot",
+		.offset		= 0,
+		.size		= 0x0b000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "hard_config",
+		.offset		= 0x0b000,
+		.size		= 0x01000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "bios",
+		.offset		= 0x0d000,
+		.size		= 0x02000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "soft_config",
+		.offset		= 0x0f000,
+		.size		= 0x01000,
+	}
+};
+
+static struct flash_platform_data rb4xx_flash_data = {
+	.type		= "pm25lv512",
+	.parts		= rb4xx_partitions,
+	.nr_parts	= ARRAY_SIZE(rb4xx_partitions),
+};
+
+static struct rb4xx_cpld_platform_data rb4xx_cpld_data = {
+	.gpio_base	= RB4XX_GPIO_CPLD_BASE,
+};
+
+static struct mmc_spi_platform_data rb4xx_mmc_data = {
+	.ocr_mask	= MMC_VDD_32_33 | MMC_VDD_33_34,
+};
+
+static struct spi_board_info rb4xx_spi_info[] = {
+	{
+		.bus_num	= 0,
+		.chip_select	= 0,
+		.max_speed_hz	= 25000000,
+		.modalias	= "m25p80",
+		.platform_data	= &rb4xx_flash_data,
+	}, {
+		.bus_num	= 0,
+		.chip_select	= 1,
+		.max_speed_hz	= 25000000,
+		.modalias	= "spi-rb4xx-cpld",
+		.platform_data	= &rb4xx_cpld_data,
+	}
+};
+
+static struct spi_board_info rb4xx_microsd_info[] = {
+	{
+		.bus_num	= 0,
+		.chip_select	= 2,
+		.max_speed_hz	= 25000000,
+		.modalias	= "mmc_spi",
+		.platform_data	= &rb4xx_mmc_data,
+	}
+};
+
+
+static struct resource rb4xx_spi_resources[] = {
+	{
+		.start	= AR71XX_SPI_BASE,
+		.end	= AR71XX_SPI_BASE + AR71XX_SPI_SIZE - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+};
+
+static struct platform_device rb4xx_spi_device = {
+	.name		= "rb4xx-spi",
+	.id		= -1,
+	.resource	= rb4xx_spi_resources,
+	.num_resources	= ARRAY_SIZE(rb4xx_spi_resources),
+};
+
+static void __init rb4xx_generic_setup(void)
+{
+	ath79_gpio_function_enable(AR71XX_GPIO_FUNC_SPI_CS1_EN |
+				   AR71XX_GPIO_FUNC_SPI_CS2_EN);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(rb4xx_leds_gpio),
+					rb4xx_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, RB4XX_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(rb4xx_gpio_keys),
+					rb4xx_gpio_keys);
+
+	spi_register_board_info(rb4xx_spi_info, ARRAY_SIZE(rb4xx_spi_info));
+	platform_device_register(&rb4xx_spi_device);
+	platform_device_register(&rb4xx_nand_device);
+}
+
+static void __init rb411_setup(void)
+{
+	rb4xx_generic_setup();
+	spi_register_board_info(rb4xx_microsd_info,
+				ARRAY_SIZE(rb4xx_microsd_info));
+
+	ath79_register_mdio(0, 0xfffffffc);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, ath79_mac_base, 0);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ath79_eth0_data.phy_mask = 0x00000003;
+
+	ath79_register_eth(0);
+
+	ath79_pci_set_irq_map(ARRAY_SIZE(rb4xx_pci_irqs), rb4xx_pci_irqs);
+	ath79_register_pci();
+}
+
+MIPS_MACHINE(ATH79_MACH_RB_411, "411", "MikroTik RouterBOARD 411/A/AH",
+	     rb411_setup);
+
+static void __init rb411u_setup(void)
+{
+	rb411_setup();
+	ath79_register_usb();
+}
+
+MIPS_MACHINE(ATH79_MACH_RB_411U, "411U", "MikroTik RouterBOARD 411U",
+	     rb411u_setup);
+
+#define RB433_LAN_PHYMASK	BIT(0)
+#define RB433_WAN_PHYMASK	BIT(4)
+#define RB433_MDIO_PHYMASK	(RB433_LAN_PHYMASK | RB433_WAN_PHYMASK)
+
+static void __init rb433_setup(void)
+{
+	rb4xx_generic_setup();
+	spi_register_board_info(rb4xx_microsd_info,
+				ARRAY_SIZE(rb4xx_microsd_info));
+
+	ath79_register_mdio(0, ~RB433_MDIO_PHYMASK);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, ath79_mac_base, 1);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ath79_eth0_data.phy_mask = RB433_LAN_PHYMASK;
+
+	ath79_init_mac(ath79_eth1_data.mac_addr, ath79_mac_base, 0);
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ath79_eth1_data.phy_mask = RB433_WAN_PHYMASK;
+
+	ath79_register_eth(1);
+	ath79_register_eth(0);
+
+	ath79_pci_set_irq_map(ARRAY_SIZE(rb4xx_pci_irqs), rb4xx_pci_irqs);
+	ath79_register_pci();
+}
+
+MIPS_MACHINE(ATH79_MACH_RB_433, "433", "MikroTik RouterBOARD 433/AH",
+	     rb433_setup);
+
+static void __init rb433u_setup(void)
+{
+	rb433_setup();
+	ath79_register_usb();
+}
+
+MIPS_MACHINE(ATH79_MACH_RB_433U, "433U", "MikroTik RouterBOARD 433UAH",
+	     rb433u_setup);
+
+#define RB450_LAN_PHYMASK	BIT(0)
+#define RB450_WAN_PHYMASK	BIT(4)
+#define RB450_MDIO_PHYMASK	(RB450_LAN_PHYMASK | RB450_WAN_PHYMASK)
+
+static void __init rb450_generic_setup(int gige)
+{
+	rb4xx_generic_setup();
+	ath79_register_mdio(0, ~RB450_MDIO_PHYMASK);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, ath79_mac_base, 1);
+	ath79_eth0_data.phy_if_mode = (gige) ?
+		PHY_INTERFACE_MODE_RGMII : PHY_INTERFACE_MODE_MII;
+	ath79_eth0_data.phy_mask = RB450_LAN_PHYMASK;
+
+	ath79_init_mac(ath79_eth1_data.mac_addr, ath79_mac_base, 0);
+	ath79_eth1_data.phy_if_mode = (gige) ?
+		PHY_INTERFACE_MODE_RGMII : PHY_INTERFACE_MODE_RMII;
+	ath79_eth1_data.phy_mask = RB450_WAN_PHYMASK;
+
+	ath79_register_eth(1);
+	ath79_register_eth(0);
+}
+
+static void __init rb450_setup(void)
+{
+	rb450_generic_setup(0);
+}
+
+MIPS_MACHINE(ATH79_MACH_RB_450, "450", "MikroTik RouterBOARD 450",
+	     rb450_setup);
+
+static void __init rb450g_setup(void)
+{
+	rb450_generic_setup(1);
+	spi_register_board_info(rb4xx_microsd_info,
+				ARRAY_SIZE(rb4xx_microsd_info));
+}
+
+MIPS_MACHINE(ATH79_MACH_RB_450G, "450G", "MikroTik RouterBOARD 450G",
+	     rb450g_setup);
+
+static void __init rb493_setup(void)
+{
+	rb4xx_generic_setup();
+
+	ath79_register_mdio(0, 0x3fffff00);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, ath79_mac_base, 0);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ath79_eth0_data.speed = SPEED_100;
+	ath79_eth0_data.duplex = DUPLEX_FULL;
+
+	ath79_init_mac(ath79_eth1_data.mac_addr, ath79_mac_base, 1);
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ath79_eth1_data.phy_mask = 0x00000001;
+
+	ath79_register_eth(0);
+	ath79_register_eth(1);
+
+	ath79_pci_set_irq_map(ARRAY_SIZE(rb4xx_pci_irqs), rb4xx_pci_irqs);
+	ath79_register_pci();
+}
+
+MIPS_MACHINE(ATH79_MACH_RB_493, "493", "MikroTik RouterBOARD 493/AH",
+	     rb493_setup);
+
+#define RB493G_GPIO_MDIO_MDC		7
+#define RB493G_GPIO_MDIO_DATA		8
+
+#define RB493G_MDIO_PHYMASK		BIT(0)
+
+static struct mdio_gpio_platform_data rb493g_mdio_data = {
+	.mdc		= RB493G_GPIO_MDIO_MDC,
+	.mdio		= RB493G_GPIO_MDIO_DATA,
+
+	.phy_mask	= ~RB493G_MDIO_PHYMASK,
+};
+
+static struct platform_device rb493g_mdio_device = {
+	.name 		= "mdio-gpio",
+	.id 		= -1,
+	.dev 		= {
+		.platform_data	= &rb493g_mdio_data,
+	},
+};
+
+static void __init rb493g_setup(void)
+{
+	ath79_gpio_function_enable(AR71XX_GPIO_FUNC_SPI_CS1_EN |
+				    AR71XX_GPIO_FUNC_SPI_CS2_EN);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(rb4xx_leds_gpio),
+				    rb4xx_leds_gpio);
+
+	spi_register_board_info(rb4xx_spi_info, ARRAY_SIZE(rb4xx_spi_info));
+	platform_device_register(&rb4xx_spi_device);
+	platform_device_register(&rb4xx_nand_device);
+
+	ath79_register_mdio(0, ~RB493G_MDIO_PHYMASK);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, ath79_mac_base, 0);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.phy_mask = RB493G_MDIO_PHYMASK;
+	ath79_eth0_data.speed = SPEED_1000;
+	ath79_eth0_data.duplex = DUPLEX_FULL;
+
+	ath79_init_mac(ath79_eth1_data.mac_addr, ath79_mac_base, 1);
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth1_data.mii_bus_dev = &rb493g_mdio_device.dev;
+	ath79_eth1_data.phy_mask = RB493G_MDIO_PHYMASK;
+	ath79_eth1_data.speed = SPEED_1000;
+	ath79_eth1_data.duplex = DUPLEX_FULL;
+
+	platform_device_register(&rb493g_mdio_device);
+
+	ath79_register_eth(1);
+	ath79_register_eth(0);
+
+	ath79_register_usb();
+
+	ath79_pci_set_irq_map(ARRAY_SIZE(rb4xx_pci_irqs), rb4xx_pci_irqs);
+	ath79_register_pci();
+}
+
+MIPS_MACHINE(ATH79_MACH_RB_493G, "493G", "MikroTik RouterBOARD 493G",
+	     rb493g_setup);
diff --git a/arch/mips/ath79/mach-rb750.c b/arch/mips/ath79/mach-rb750.c
new file mode 100644
index 0000000..b180621
--- /dev/null
+++ b/arch/mips/ath79/mach-rb750.c
@@ -0,0 +1,356 @@
+/*
+ *  MikroTik RouterBOARD 750/750GL support
+ *
+ *  Copyright (C) 2010-2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/export.h>
+#include <linux/pci.h>
+#include <linux/ath9k_platform.h>
+#include <linux/platform_device.h>
+#include <linux/phy.h>
+#include <linux/ar8216_platform.h>
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/irq.h>
+#include <asm/mach-ath79/mach-rb750.h>
+
+#include "common.h"
+#include "dev-ap9x-pci.h"
+#include "dev-usb.h"
+#include "dev-eth.h"
+#include "machtypes.h"
+
+static struct rb750_led_data rb750_leds[] = {
+	{
+		.name		= "rb750:green:act",
+		.mask		= RB750_LED_ACT,
+		.active_low	= 1,
+	}, {
+		.name		= "rb750:green:port1",
+		.mask		= RB750_LED_PORT5,
+		.active_low	= 1,
+	}, {
+		.name		= "rb750:green:port2",
+		.mask		= RB750_LED_PORT4,
+		.active_low	= 1,
+	}, {
+		.name		= "rb750:green:port3",
+		.mask		= RB750_LED_PORT3,
+		.active_low	= 1,
+	}, {
+		.name		= "rb750:green:port4",
+		.mask		= RB750_LED_PORT2,
+		.active_low	= 1,
+	}, {
+		.name		= "rb750:green:port5",
+		.mask		= RB750_LED_PORT1,
+		.active_low	= 1,
+	}
+};
+
+static struct rb750_led_data rb750gr3_leds[] = {
+	{
+		.name		= "rb750:green:act",
+		.mask		= RB7XX_LED_ACT,
+		.active_low	= 1,
+	},
+};
+
+static struct rb750_led_platform_data rb750_leds_data;
+static struct platform_device rb750_leds_device = {
+	.name	= "leds-rb750",
+	.dev	= {
+		.platform_data = &rb750_leds_data,
+	}
+};
+
+static struct rb7xx_nand_platform_data rb750_nand_data;
+static struct platform_device rb750_nand_device = {
+	.name	= "rb750-nand",
+	.id	= -1,
+	.dev	= {
+		.platform_data = &rb750_nand_data,
+	}
+};
+
+static void rb750_latch_change(u32 mask_clr, u32 mask_set)
+{
+	static DEFINE_SPINLOCK(lock);
+	static u32 latch_set = RB750_LED_BITS | RB750_LVC573_LE;
+	static u32 latch_oe;
+	static u32 latch_clr;
+	unsigned long flags;
+	u32 t;
+
+	spin_lock_irqsave(&lock, flags);
+
+	if ((mask_clr & BIT(31)) != 0 &&
+	    (latch_set & RB750_LVC573_LE) == 0) {
+		goto unlock;
+	}
+
+	latch_set = (latch_set | mask_set) & ~mask_clr;
+	latch_clr = (latch_clr | mask_clr) & ~mask_set;
+
+	if (latch_oe == 0)
+		latch_oe = __raw_readl(ath79_gpio_base + AR71XX_GPIO_REG_OE);
+
+	if (likely(latch_set & RB750_LVC573_LE)) {
+		void __iomem *base = ath79_gpio_base;
+
+		t = __raw_readl(base + AR71XX_GPIO_REG_OE);
+		t |= mask_clr | latch_oe | mask_set;
+
+		__raw_writel(t, base + AR71XX_GPIO_REG_OE);
+		__raw_writel(latch_clr, base + AR71XX_GPIO_REG_CLEAR);
+		__raw_writel(latch_set, base + AR71XX_GPIO_REG_SET);
+	} else if (mask_clr & RB750_LVC573_LE) {
+		void __iomem *base = ath79_gpio_base;
+
+		latch_oe = __raw_readl(base + AR71XX_GPIO_REG_OE);
+		__raw_writel(RB750_LVC573_LE, base + AR71XX_GPIO_REG_CLEAR);
+		/* flush write */
+		__raw_readl(base + AR71XX_GPIO_REG_CLEAR);
+	}
+
+unlock:
+	spin_unlock_irqrestore(&lock, flags);
+}
+
+static void rb750_nand_enable_pins(void)
+{
+	rb750_latch_change(RB750_LVC573_LE, 0);
+	ath79_gpio_function_setup(AR724X_GPIO_FUNC_JTAG_DISABLE,
+				  AR724X_GPIO_FUNC_SPI_EN);
+}
+
+static void rb750_nand_disable_pins(void)
+{
+	ath79_gpio_function_setup(AR724X_GPIO_FUNC_SPI_EN,
+				  AR724X_GPIO_FUNC_JTAG_DISABLE);
+	rb750_latch_change(0, RB750_LVC573_LE);
+}
+
+static void __init rb750_setup(void)
+{
+	ath79_gpio_function_disable(AR724X_GPIO_FUNC_ETH_SWITCH_LED0_EN |
+				     AR724X_GPIO_FUNC_ETH_SWITCH_LED1_EN |
+				     AR724X_GPIO_FUNC_ETH_SWITCH_LED2_EN |
+				     AR724X_GPIO_FUNC_ETH_SWITCH_LED3_EN |
+				     AR724X_GPIO_FUNC_ETH_SWITCH_LED4_EN);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, ath79_mac_base, 0);
+	ath79_init_mac(ath79_eth1_data.mac_addr, ath79_mac_base, 1);
+
+	ath79_register_mdio(0, 0x0);
+
+	/* LAN ports */
+	ath79_register_eth(1);
+
+	/* WAN port */
+	ath79_register_eth(0);
+
+	rb750_leds_data.num_leds = ARRAY_SIZE(rb750_leds);
+	rb750_leds_data.leds = rb750_leds;
+	rb750_leds_data.latch_change = rb750_latch_change;
+	platform_device_register(&rb750_leds_device);
+
+	rb750_nand_data.nce_line = RB750_NAND_NCE;
+	rb750_nand_data.enable_pins = rb750_nand_enable_pins;
+	rb750_nand_data.disable_pins = rb750_nand_disable_pins;
+	rb750_nand_data.latch_change = rb750_latch_change;
+	platform_device_register(&rb750_nand_device);
+}
+
+MIPS_MACHINE(ATH79_MACH_RB_750, "750i", "MikroTik RouterBOARD 750",
+	     rb750_setup);
+
+static struct ar8327_pad_cfg rb750gr3_ar8327_pad0_cfg = {
+	.mode = AR8327_PAD_MAC_RGMII,
+	.txclk_delay_en = true,
+	.rxclk_delay_en = true,
+	.txclk_delay_sel = AR8327_CLK_DELAY_SEL1,
+	.rxclk_delay_sel = AR8327_CLK_DELAY_SEL2,
+};
+
+static struct ar8327_platform_data rb750gr3_ar8327_data = {
+	.pad0_cfg = &rb750gr3_ar8327_pad0_cfg,
+	.cpuport_cfg = {
+		.force_link = 1,
+		.speed = AR8327_PORT_SPEED_100,
+		.duplex = 1,
+		.txpause = 1,
+		.rxpause = 1,
+	}
+};
+
+static struct mdio_board_info rb750g3_mdio_info[] = {
+	{
+		.bus_id = "ag71xx-mdio.0",
+		.phy_addr = 0,
+		.platform_data = &rb750gr3_ar8327_data,
+	},
+};
+
+static void rb750gr3_nand_enable_pins(void)
+{
+	ath79_gpio_function_setup(AR724X_GPIO_FUNC_JTAG_DISABLE,
+				  AR724X_GPIO_FUNC_SPI_EN |
+				  AR724X_GPIO_FUNC_SPI_CS_EN2);
+}
+
+static void rb750gr3_nand_disable_pins(void)
+{
+	ath79_gpio_function_setup(AR724X_GPIO_FUNC_SPI_EN |
+				  AR724X_GPIO_FUNC_SPI_CS_EN2,
+				  AR724X_GPIO_FUNC_JTAG_DISABLE);
+}
+
+static void rb750gr3_latch_change(u32 mask_clr, u32 mask_set)
+{
+	static DEFINE_SPINLOCK(lock);
+	static u32 latch_set = RB7XX_LED_ACT;
+	static u32 latch_clr;
+	void __iomem *base = ath79_gpio_base;
+	unsigned long flags;
+	u32 t;
+
+	spin_lock_irqsave(&lock, flags);
+
+	latch_set = (latch_set | mask_set) & ~mask_clr;
+	latch_clr = (latch_clr | mask_clr) & ~mask_set;
+
+	mask_set = latch_set & (RB7XX_USB_POWERON | RB7XX_MONITOR);
+	mask_clr = latch_clr & (RB7XX_USB_POWERON | RB7XX_MONITOR);
+
+	if ((latch_set ^ RB7XX_LED_ACT) & RB7XX_LED_ACT) {
+		/* enable output mode */
+		t = __raw_readl(base + AR71XX_GPIO_REG_OE);
+		t |= RB7XX_LED_ACT;
+		__raw_writel(t, base + AR71XX_GPIO_REG_OE);
+
+		mask_clr |= RB7XX_LED_ACT;
+	} else {
+		/* disable output mode */
+		t = __raw_readl(base + AR71XX_GPIO_REG_OE);
+		t &= ~RB7XX_LED_ACT;
+		__raw_writel(t, base + AR71XX_GPIO_REG_OE);
+	}
+
+	__raw_writel(mask_set, base + AR71XX_GPIO_REG_SET);
+	__raw_writel(mask_clr, base + AR71XX_GPIO_REG_CLEAR);
+
+	spin_unlock_irqrestore(&lock, flags);
+}
+
+static void __init rb750gr3_setup(void)
+{
+	ath79_register_mdio(0, 0x0);
+	mdiobus_register_board_info(rb750g3_mdio_info,
+				    ARRAY_SIZE(rb750g3_mdio_info));
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, ath79_mac_base, 0);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.phy_mask = BIT(0);
+
+	ath79_register_eth(0);
+
+	rb750_leds_data.num_leds = ARRAY_SIZE(rb750gr3_leds);
+	rb750_leds_data.leds = rb750gr3_leds;
+	rb750_leds_data.latch_change = rb750gr3_latch_change;
+	platform_device_register(&rb750_leds_device);
+
+	rb750_nand_data.nce_line = RB7XX_NAND_NCE;
+	rb750_nand_data.enable_pins = rb750gr3_nand_enable_pins;
+	rb750_nand_data.disable_pins = rb750gr3_nand_disable_pins;
+	rb750_nand_data.latch_change = rb750gr3_latch_change;
+	platform_device_register(&rb750_nand_device);
+}
+
+MIPS_MACHINE(ATH79_MACH_RB_750G_R3, "750Gr3", "MikroTik RouterBOARD 750GL",
+	     rb750gr3_setup);
+
+static int decode_rle(char *output, int len, char *in)
+{
+	char *ptr = output;
+	char *end = output + len;
+
+	if (!output || !in)
+		return -EINVAL;
+
+	while (*in) {
+		if (*in < 0) {
+			int i = -*in++;
+			while (i-- > 0) {
+				if (ptr >= end)
+					return -EINVAL;
+				*ptr++ = *in++;
+			}
+		} else if (*in > 0) {
+			int i = *in++;
+			while (i-- > 0) {
+				if (ptr >= end)
+					return -EINVAL;
+				*ptr++ = *in;
+			}
+			in++;
+		}
+	}
+
+	return ptr - output;
+}
+
+#define RB751_HARDCONFIG 0x1f00b000
+#define RB751_MAC_ADDRESS_OFFSET 0xE80
+#define RB751_CALDATA_OFFSET 0x27C
+
+static void __init rb751_wlan_setup(void)
+{
+	u8 *hardconfig = (u8 *) KSEG1ADDR(RB751_HARDCONFIG);
+	struct ath9k_platform_data *wmac_data;
+	int dec_size;
+
+	wmac_data = ap9x_pci_get_wmac_data(0);
+	if (!wmac_data) {
+		pr_err("rb75x: unable to get address of wlan data\n");
+		return;
+	}
+
+	ap9x_pci_setup_wmac_led_pin(0, 9);
+
+	dec_size = decode_rle((char *) wmac_data->eeprom_data,
+			      sizeof(wmac_data->eeprom_data),
+			      hardconfig + RB751_CALDATA_OFFSET);
+	if (dec_size != sizeof(wmac_data->eeprom_data)) {
+		pr_err("rb75x: unable to decode wlan eeprom data\n");
+		return;
+	}
+
+	ap91_pci_init(NULL, hardconfig + RB751_MAC_ADDRESS_OFFSET);
+}
+
+static void __init rb751_setup(void)
+{
+	rb750_setup();
+	ath79_register_usb();
+	rb751_wlan_setup();
+}
+
+MIPS_MACHINE(ATH79_MACH_RB_751, "751", "MikroTik RouterBOARD 751",
+	     rb751_setup);
+
+static void __init rb751g_setup(void)
+{
+	rb750gr3_setup();
+	ath79_register_usb();
+	rb751_wlan_setup();
+}
+
+MIPS_MACHINE(ATH79_MACH_RB_751G, "751g", "MikroTik RouterBOARD 751G",
+	     rb751g_setup);
diff --git a/arch/mips/ath79/mach-rw2458n.c b/arch/mips/ath79/mach-rw2458n.c
new file mode 100644
index 0000000..28d9de4
--- /dev/null
+++ b/arch/mips/ath79/mach-rw2458n.c
@@ -0,0 +1,100 @@
+/*
+ *  Redwave RW2458N support
+ *
+ *  Copyright (C) 2011-2012 Cezary Jackiewicz <cezary@eko.one.pl>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-eth.h"
+#include "dev-ap9x-pci.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "machtypes.h"
+
+#define RW2458N_GPIO_LED_D3	1
+#define RW2458N_GPIO_LED_D4	0
+#define RW2458N_GPIO_LED_D5	11
+#define RW2458N_GPIO_LED_D6	7
+#define RW2458N_GPIO_BTN_RESET	12
+
+#define RW2458N_KEYS_POLL_INTERVAL	20	/* msecs */
+#define RW2458N_KEYS_DEBOUNCE_INTERVAL	(3 * RW2458N_KEYS_POLL_INTERVAL)
+
+static struct gpio_keys_button rw2458n_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = RW2458N_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= RW2458N_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}
+};
+
+#define RW2458N_WAN_PHYMASK	BIT(4)
+
+static struct gpio_led rw2458n_leds_gpio[] __initdata = {
+	{
+		.name		= "rw2458n:green:d3",
+		.gpio		= RW2458N_GPIO_LED_D3,
+		.active_low	= 1,
+	}, {
+		.name		= "rw2458n:green:d4",
+		.gpio		= RW2458N_GPIO_LED_D4,
+		.active_low	= 1,
+	}, {
+		.name		= "rw2458n:green:d5",
+		.gpio		= RW2458N_GPIO_LED_D5,
+		.active_low	= 1,
+	}, {
+		.name		= "rw2458n:green:d6",
+		.gpio		= RW2458N_GPIO_LED_D6,
+		.active_low	= 1,
+	}
+};
+
+static const char *rw2458n_part_probes[] = {
+        "RedBoot",
+        NULL,
+};
+
+static struct flash_platform_data rw2458n_flash_data = {
+        .part_probes    = rw2458n_part_probes,
+};
+
+static void __init rw2458n_setup(void)
+{
+	u8 *mac1 = (u8 *) KSEG1ADDR(0x1fff0000);
+	u8 *mac2 = (u8 *) KSEG1ADDR(0x1fff0000 + ETH_ALEN);
+	u8 *ee = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	ath79_register_m25p80(&rw2458n_flash_data);
+
+	ath79_register_mdio(0, ~RW2458N_WAN_PHYMASK);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac1, 0);
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac2, 0);
+
+	ath79_register_eth(0);
+	ath79_register_eth(1);
+
+	ap91_pci_init(ee, NULL);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(rw2458n_leds_gpio),
+				 rw2458n_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, RW2458N_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(rw2458n_gpio_keys),
+					rw2458n_gpio_keys);
+	ath79_register_usb();
+}
+
+MIPS_MACHINE(ATH79_MACH_RW2458N, "RW2458N", "Redwave RW2458N",
+	    rw2458n_setup);
diff --git a/arch/mips/ath79/mach-tew-632brp.c b/arch/mips/ath79/mach-tew-632brp.c
new file mode 100644
index 0000000..b76d4a7
--- /dev/null
+++ b/arch/mips/ath79/mach-tew-632brp.c
@@ -0,0 +1,109 @@
+/*
+ *  TrendNET TEW-632BRP board support
+ *
+ *  Copyright (C) 2008-2012 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+#include "nvram.h"
+
+#define TEW_632BRP_GPIO_LED_STATUS	1
+#define TEW_632BRP_GPIO_LED_WPS		3
+#define TEW_632BRP_GPIO_LED_WLAN	6
+#define TEW_632BRP_GPIO_BTN_WPS		12
+#define TEW_632BRP_GPIO_BTN_RESET	21
+
+#define TEW_632BRP_KEYS_POLL_INTERVAL	20	/* msecs */
+#define TEW_632BRP_KEYS_DEBOUNCE_INTERVAL (3 * TEW_632BRP_KEYS_POLL_INTERVAL)
+
+#define TEW_632BRP_CONFIG_ADDR	0x1f020000
+#define TEW_632BRP_CONFIG_SIZE	0x10000
+
+static struct gpio_led tew_632brp_leds_gpio[] __initdata = {
+	{
+		.name		= "tew-632brp:green:status",
+		.gpio		= TEW_632BRP_GPIO_LED_STATUS,
+		.active_low	= 1,
+	}, {
+		.name		= "tew-632brp:blue:wps",
+		.gpio		= TEW_632BRP_GPIO_LED_WPS,
+		.active_low	= 1,
+	}, {
+		.name		= "tew-632brp:green:wlan",
+		.gpio		= TEW_632BRP_GPIO_LED_WLAN,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button tew_632brp_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = TEW_632BRP_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TEW_632BRP_GPIO_BTN_RESET,
+	}, {
+		.desc		= "wps",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = TEW_632BRP_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TEW_632BRP_GPIO_BTN_WPS,
+	}
+};
+
+#define TEW_632BRP_LAN_PHYMASK	BIT(0)
+#define TEW_632BRP_WAN_PHYMASK	BIT(4)
+#define TEW_632BRP_MDIO_MASK	(~(TEW_632BRP_LAN_PHYMASK | \
+				   TEW_632BRP_WAN_PHYMASK))
+
+static void __init tew_632brp_setup(void)
+{
+	const char *config = (char *) KSEG1ADDR(TEW_632BRP_CONFIG_ADDR);
+	u8 *eeprom = (u8 *) KSEG1ADDR(0x1fff1000);
+	u8 mac[6];
+	u8 *wlan_mac = NULL;
+
+	if (ath79_nvram_parse_mac_addr(config, TEW_632BRP_CONFIG_SIZE,
+				       "lan_mac=", mac) == 0) {
+		ath79_init_mac(ath79_eth0_data.mac_addr, mac, 0);
+		ath79_init_mac(ath79_eth1_data.mac_addr, mac, 1);
+		wlan_mac = mac;
+	}
+
+	ath79_register_mdio(0, TEW_632BRP_MDIO_MASK);
+
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ath79_eth0_data.phy_mask = TEW_632BRP_LAN_PHYMASK;
+
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ath79_eth1_data.phy_mask = TEW_632BRP_WAN_PHYMASK;
+
+	ath79_register_eth(0);
+	ath79_register_eth(1);
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(tew_632brp_leds_gpio),
+				 tew_632brp_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, TEW_632BRP_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(tew_632brp_gpio_keys),
+					tew_632brp_gpio_keys);
+
+	ath79_register_wmac(eeprom, wlan_mac);
+}
+
+MIPS_MACHINE(ATH79_MACH_TEW_632BRP, "TEW-632BRP", "TRENDnet TEW-632BRP",
+	     tew_632brp_setup);
diff --git a/arch/mips/ath79/mach-tew-673gru.c b/arch/mips/ath79/mach-tew-673gru.c
new file mode 100644
index 0000000..8fe8259
--- /dev/null
+++ b/arch/mips/ath79/mach-tew-673gru.c
@@ -0,0 +1,182 @@
+/*
+ *  TRENDnet TEW-673GRU board support
+ *
+ *  Copyright (C) 2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/rtl8366.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/spi_gpio.h>
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-ap9x-pci.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "machtypes.h"
+
+#define TEW673GRU_GPIO_LCD_SCK		0
+#define TEW673GRU_GPIO_LCD_MOSI		1
+#define TEW673GRU_GPIO_LCD_MISO		2
+#define TEW673GRU_GPIO_LCD_CS		6
+
+#define TEW673GRU_GPIO_LED_WPS		9
+
+#define TEW673GRU_GPIO_BTN_RESET	3
+#define TEW673GRU_GPIO_BTN_WPS		8
+
+#define TEW673GRU_GPIO_RTL8366_SDA	5
+#define TEW673GRU_GPIO_RTL8366_SCK	7
+
+#define TEW673GRU_KEYS_POLL_INTERVAL	20 /* msecs */
+#define TEW673GRU_KEYS_DEBOUNCE_INTERVAL (3 * TEW673GRU_KEYS_POLL_INTERVAL)
+
+#define TEW673GRU_CAL_LOCATION_0	0x1f661000
+#define TEW673GRU_CAL_LOCATION_1	0x1f665000
+
+#define TEW673GRU_MAC_LOCATION_0	0x1f66ffa0
+#define TEW673GRU_MAC_LOCATION_1	0x1f66ffb4
+
+static struct gpio_led tew673gru_leds_gpio[] __initdata = {
+	{
+		.name		= "trendnet:blue:wps",
+		.gpio		= TEW673GRU_GPIO_LED_WPS,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button tew673gru_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = TEW673GRU_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TEW673GRU_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}, {
+		.desc		= "wps",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = TEW673GRU_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TEW673GRU_GPIO_BTN_WPS,
+		.active_low	= 1,
+	}
+};
+
+static struct rtl8366_initval tew673gru_rtl8366s_initvals[] = {
+	{ .reg = 0x06, .val = 0x0108 },
+};
+
+static struct rtl8366_platform_data tew673gru_rtl8366s_data = {
+	.gpio_sda	= TEW673GRU_GPIO_RTL8366_SDA,
+	.gpio_sck	= TEW673GRU_GPIO_RTL8366_SCK,
+	.num_initvals	= ARRAY_SIZE(tew673gru_rtl8366s_initvals),
+	.initvals	= tew673gru_rtl8366s_initvals,
+};
+
+static struct platform_device tew673gru_rtl8366s_device = {
+	.name		= RTL8366S_DRIVER_NAME,
+	.id		= -1,
+	.dev = {
+		.platform_data	= &tew673gru_rtl8366s_data,
+	}
+};
+
+static struct spi_board_info tew673gru_spi_info[] = {
+	{
+		.bus_num	= 1,
+		.chip_select	= 0,
+		.max_speed_hz	= 400000,
+		.modalias	= "spidev",
+		.mode		= SPI_MODE_2,
+		.controller_data = (void *) TEW673GRU_GPIO_LCD_CS,
+	},
+};
+
+static struct spi_gpio_platform_data tew673gru_spi_data = {
+	.sck		= TEW673GRU_GPIO_LCD_SCK,
+	.miso		= TEW673GRU_GPIO_LCD_MISO,
+	.mosi		= TEW673GRU_GPIO_LCD_MOSI,
+	.num_chipselect = 1,
+};
+
+static struct platform_device tew673gru_spi_device = {
+	.name		= "spi_gpio",
+	.id		= 1,
+	.dev = {
+		.platform_data = &tew673gru_spi_data,
+	},
+};
+
+static void tew673gru_read_ascii_mac(u8 *dest, unsigned int src_addr)
+{
+	int ret;
+	u8 *src = (u8 *)KSEG1ADDR(src_addr);
+
+	ret = sscanf(src, "%02hhx:%02hhx:%02hhx:%02hhx:%02hhx:%02hhx",
+		     &dest[0], &dest[1], &dest[2],
+		     &dest[3], &dest[4], &dest[5]);
+
+	if (ret != ETH_ALEN) memset(dest, 0, ETH_ALEN);
+}
+
+static void __init tew673gru_setup(void)
+{
+	u8 mac1[ETH_ALEN], mac2[ETH_ALEN];
+
+	tew673gru_read_ascii_mac(mac1, TEW673GRU_MAC_LOCATION_0);
+	tew673gru_read_ascii_mac(mac2, TEW673GRU_MAC_LOCATION_1);
+
+	ath79_register_mdio(0, 0x0);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac1, 2);
+	ath79_eth0_data.mii_bus_dev = &tew673gru_rtl8366s_device.dev;
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.speed = SPEED_1000;
+	ath79_eth0_data.duplex = DUPLEX_FULL;
+	ath79_eth0_pll_data.pll_1000 = 0x11110000;
+
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac1, 3);
+	ath79_eth1_data.mii_bus_dev = &tew673gru_rtl8366s_device.dev;
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth1_data.phy_mask = 0x10;
+	ath79_eth1_pll_data.pll_1000 = 0x11110000;
+
+	ath79_register_eth(0);
+	ath79_register_eth(1);
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(tew673gru_leds_gpio),
+				 tew673gru_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, TEW673GRU_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(tew673gru_gpio_keys),
+					tew673gru_gpio_keys);
+
+	ath79_register_usb();
+
+	platform_device_register(&tew673gru_rtl8366s_device);
+
+	ap9x_pci_setup_wmac_led_pin(0, 5);
+	ap9x_pci_setup_wmac_led_pin(1, 5);
+
+	ap94_pci_init((u8 *) KSEG1ADDR(TEW673GRU_CAL_LOCATION_0), mac1,
+		      (u8 *) KSEG1ADDR(TEW673GRU_CAL_LOCATION_1), mac2);
+
+	spi_register_board_info(tew673gru_spi_info,
+				ARRAY_SIZE(tew673gru_spi_info));
+	platform_device_register(&tew673gru_spi_device);
+}
+
+MIPS_MACHINE(ATH79_MACH_TEW_673GRU, "TEW-673GRU", "TRENDnet TEW-673GRU",
+	     tew673gru_setup);
diff --git a/arch/mips/ath79/mach-tl-mr11u.c b/arch/mips/ath79/mach-tl-mr11u.c
new file mode 100644
index 0000000..87facff
--- /dev/null
+++ b/arch/mips/ath79/mach-tl-mr11u.c
@@ -0,0 +1,110 @@
+/*
+ *  TP-LINK TL-MR11U board support
+ *
+ *  Copyright (C) 2011 dongyuqi <729650915@qq.com>
+ *  Copyright (C) 2011-2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/gpio.h>
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define TL_MR11U_GPIO_LED_3G		27
+#define TL_MR11U_GPIO_LED_WLAN		26
+#define TL_MR11U_GPIO_LED_LAN		17
+
+#define TL_MR11U_GPIO_BTN_WPS		20
+#define TL_MR11U_GPIO_BTN_RESET		11
+
+#define TL_MR11U_GPIO_USB_POWER		8
+
+#define TL_MR11U_KEYS_POLL_INTERVAL	20	/* msecs */
+#define TL_MR11U_KEYS_DEBOUNCE_INTERVAL	(3 * TL_MR11U_KEYS_POLL_INTERVAL)
+
+static const char *tl_mr11u_part_probes[] = {
+	"tp-link",
+	NULL,
+};
+
+static struct flash_platform_data tl_mr11u_flash_data = {
+	.part_probes	= tl_mr11u_part_probes,
+};
+
+static struct gpio_led tl_mr11u_leds_gpio[] __initdata = {
+	{
+		.name		= "tp-link:green:3g",
+		.gpio		= TL_MR11U_GPIO_LED_3G,
+		.active_low	= 1,
+	},
+	{
+		.name		= "tp-link:green:wlan",
+		.gpio		= TL_MR11U_GPIO_LED_WLAN,
+		.active_low	= 1,
+	},
+	{
+		.name		= "tp-link:green:lan",
+		.gpio		= TL_MR11U_GPIO_LED_LAN,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button tl_mr11u_gpio_keys[] __initdata = {
+	{
+		.desc		= "wps",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = TL_MR11U_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_MR11U_GPIO_BTN_WPS,
+		.active_low	= 0,
+	},
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = TL_MR11U_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_MR11U_GPIO_BTN_RESET,
+		.active_low	= 0,
+	}
+};
+
+static void __init tl_mr11u_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f01fc00);
+	u8 *ee = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	ath79_setup_ar933x_phy4_switch(false, true);
+
+	ath79_register_m25p80(&tl_mr11u_flash_data);
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(tl_mr11u_leds_gpio),
+				 tl_mr11u_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, TL_MR11U_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(tl_mr11u_gpio_keys),
+					tl_mr11u_gpio_keys);
+
+	ath79_set_usb_power_gpio(TL_MR11U_GPIO_USB_POWER, GPIOF_OUT_INIT_HIGH,
+				"USB power");
+	ath79_register_usb();
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 0);
+
+	ath79_register_mdio(0, 0x0);
+	ath79_register_eth(0);
+	ath79_eth0_data.phy_mask = BIT(0);
+
+	ath79_register_wmac(ee, mac);
+}
+
+MIPS_MACHINE(ATH79_MACH_TL_MR11U, "TL-MR11U", "TP-LINK TL-MR11U",
+	     tl_mr11u_setup);
diff --git a/arch/mips/ath79/mach-tl-mr3020.c b/arch/mips/ath79/mach-tl-mr3020.c
new file mode 100644
index 0000000..8f37d7a
--- /dev/null
+++ b/arch/mips/ath79/mach-tl-mr3020.c
@@ -0,0 +1,125 @@
+/*
+ *  TP-LINK TL-MR3020 board support
+ *
+ *  Copyright (C) 2011 dongyuqi <729650915@qq.com>
+ *  Copyright (C) 2011-2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/gpio.h>
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define TL_MR3020_GPIO_LED_3G		27
+#define TL_MR3020_GPIO_LED_WLAN		0
+#define TL_MR3020_GPIO_LED_LAN		17
+#define TL_MR3020_GPIO_LED_WPS		26
+
+#define TL_MR3020_GPIO_BTN_WPS		11
+#define TL_MR3020_GPIO_BTN_SW1		18
+#define TL_MR3020_GPIO_BTN_SW2		20
+
+#define TL_MR3020_GPIO_USB_POWER	8
+
+#define TL_MR3020_KEYS_POLL_INTERVAL	20	/* msecs */
+#define TL_MR3020_KEYS_DEBOUNCE_INTERVAL	(3 * TL_MR3020_KEYS_POLL_INTERVAL)
+
+static const char *tl_mr3020_part_probes[] = {
+	"tp-link",
+	NULL,
+};
+
+static struct flash_platform_data tl_mr3020_flash_data = {
+	.part_probes	= tl_mr3020_part_probes,
+};
+
+static struct gpio_led tl_mr3020_leds_gpio[] __initdata = {
+	{
+		.name		= "tp-link:green:3g",
+		.gpio		= TL_MR3020_GPIO_LED_3G,
+		.active_low	= 1,
+	},
+	{
+		.name		= "tp-link:green:wlan",
+		.gpio		= TL_MR3020_GPIO_LED_WLAN,
+		.active_low	= 0,
+	},
+	{
+		.name		= "tp-link:green:lan",
+		.gpio		= TL_MR3020_GPIO_LED_LAN,
+		.active_low	= 1,
+	},
+	{
+		.name		= "tp-link:green:wps",
+		.gpio		= TL_MR3020_GPIO_LED_WPS,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button tl_mr3020_gpio_keys[] __initdata = {
+	{
+		.desc		= "wps",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = TL_MR3020_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_MR3020_GPIO_BTN_WPS,
+		.active_low	= 0,
+	},
+	{
+		.desc		= "sw1",
+		.type		= EV_KEY,
+		.code		= BTN_0,
+		.debounce_interval = TL_MR3020_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_MR3020_GPIO_BTN_SW1,
+		.active_low	= 0,
+	},
+	{
+		.desc		= "sw2",
+		.type		= EV_KEY,
+		.code		= BTN_1,
+		.debounce_interval = TL_MR3020_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_MR3020_GPIO_BTN_SW2,
+		.active_low	= 0,
+	}
+};
+
+static void __init tl_mr3020_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f01fc00);
+	u8 *ee = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	ath79_setup_ar933x_phy4_switch(false, true);
+
+	ath79_register_m25p80(&tl_mr3020_flash_data);
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(tl_mr3020_leds_gpio),
+				 tl_mr3020_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, TL_MR3020_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(tl_mr3020_gpio_keys),
+					tl_mr3020_gpio_keys);
+
+	ath79_set_usb_power_gpio(TL_MR3020_GPIO_USB_POWER, GPIOF_OUT_INIT_HIGH,
+				"USB power");
+	ath79_register_usb();
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 0);
+
+	ath79_register_mdio(0, 0x0);
+	ath79_register_eth(0);
+	ath79_eth0_data.phy_mask = BIT(0);
+	ath79_register_wmac(ee, mac);
+}
+
+MIPS_MACHINE(ATH79_MACH_TL_MR3020, "TL-MR3020", "TP-LINK TL-MR3020",
+	     tl_mr3020_setup);
diff --git a/arch/mips/ath79/mach-tl-mr3x20.c b/arch/mips/ath79/mach-tl-mr3x20.c
new file mode 100644
index 0000000..b35f09f
--- /dev/null
+++ b/arch/mips/ath79/mach-tl-mr3x20.c
@@ -0,0 +1,146 @@
+/*
+ *  TP-LINK TL-MR3220/3420 board support
+ *
+ *  Copyright (C) 2010-2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/gpio.h>
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-eth.h"
+#include "dev-ap9x-pci.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "machtypes.h"
+
+#define TL_MR3X20_GPIO_LED_QSS		0
+#define TL_MR3X20_GPIO_LED_SYSTEM	1
+#define TL_MR3X20_GPIO_LED_3G		8
+
+#define TL_MR3X20_GPIO_BTN_RESET	11
+#define TL_MR3X20_GPIO_BTN_QSS		12
+
+#define TL_MR3X20_GPIO_USB_POWER	6
+
+#define TL_MR3X20_KEYS_POLL_INTERVAL	20	/* msecs */
+#define TL_MR3X20_KEYS_DEBOUNCE_INTERVAL (3 * TL_MR3X20_KEYS_POLL_INTERVAL)
+
+static const char *tl_mr3x20_part_probes[] = {
+	"tp-link",
+	NULL,
+};
+
+static struct flash_platform_data tl_mr3x20_flash_data = {
+	.part_probes	= tl_mr3x20_part_probes,
+};
+
+static struct gpio_led tl_mr3x20_leds_gpio[] __initdata = {
+	{
+		.name		= "tp-link:green:system",
+		.gpio		= TL_MR3X20_GPIO_LED_SYSTEM,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:qss",
+		.gpio		= TL_MR3X20_GPIO_LED_QSS,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:3g",
+		.gpio		= TL_MR3X20_GPIO_LED_3G,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button tl_mr3x20_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = TL_MR3X20_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_MR3X20_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}, {
+		.desc		= "qss",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = TL_MR3X20_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_MR3X20_GPIO_BTN_QSS,
+		.active_low	= 1,
+	}
+};
+
+static void __init tl_ap99_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f01fc00);
+	u8 *ee = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	ath79_register_m25p80(&tl_mr3x20_flash_data);
+
+	ath79_register_gpio_keys_polled(-1, TL_MR3X20_KEYS_POLL_INTERVAL,
+					 ARRAY_SIZE(tl_mr3x20_gpio_keys),
+					 tl_mr3x20_gpio_keys);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 1);
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac, -1);
+
+	ath79_register_mdio(0, 0x0);
+
+	/* LAN ports */
+	ath79_register_eth(1);
+	/* WAN port */
+	ath79_register_eth(0);
+
+	ap91_pci_init(ee, mac);
+}
+
+static void __init tl_mr3x20_usb_setup(void)
+{
+	/* enable power for the USB port */
+	ath79_set_usb_power_gpio(TL_MR3X20_GPIO_USB_POWER, GPIOF_OUT_INIT_HIGH,
+				"USB power");
+	ath79_register_usb();
+}
+
+static void __init tl_mr3220_setup(void)
+{
+	tl_ap99_setup();
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(tl_mr3x20_leds_gpio),
+				 tl_mr3x20_leds_gpio);
+	ap9x_pci_setup_wmac_led_pin(0, 1);
+	tl_mr3x20_usb_setup();
+}
+
+MIPS_MACHINE(ATH79_MACH_TL_MR3220, "TL-MR3220", "TP-LINK TL-MR3220",
+	     tl_mr3220_setup);
+
+static void __init tl_mr3420_setup(void)
+{
+	tl_ap99_setup();
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(tl_mr3x20_leds_gpio),
+				 tl_mr3x20_leds_gpio);
+	ap9x_pci_setup_wmac_led_pin(0, 0);
+	tl_mr3x20_usb_setup();
+}
+
+MIPS_MACHINE(ATH79_MACH_TL_MR3420, "TL-MR3420", "TP-LINK TL-MR3420",
+	     tl_mr3420_setup);
+
+static void __init tl_wr841n_v7_setup(void)
+{
+	tl_ap99_setup();
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(tl_mr3x20_leds_gpio) - 1,
+				 tl_mr3x20_leds_gpio);
+	ap9x_pci_setup_wmac_led_pin(0, 0);
+}
+
+MIPS_MACHINE(ATH79_MACH_TL_WR841N_V7, "TL-WR841N-v7",
+	     "TP-LINK TL-WR841N/ND v7", tl_wr841n_v7_setup);
diff --git a/arch/mips/ath79/mach-tl-wa901nd-v2.c b/arch/mips/ath79/mach-tl-wa901nd-v2.c
new file mode 100644
index 0000000..b4fb2a9
--- /dev/null
+++ b/arch/mips/ath79/mach-tl-wa901nd-v2.c
@@ -0,0 +1,104 @@
+/*
+ *  TP-LINK TL-WA901N/ND v2 board support
+ *
+ *  Copyright (C) 2009-2012 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2010 Pieter Hollants <pieter@hollants.com>
+ *  Copyright (C) 2011 Jonathan Bennett <jbscience87@gmail.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "dev-eth.h"
+#include "dev-m25p80.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define TL_WA901ND_V2_GPIO_LED_QSS		4
+#define TL_WA901ND_V2_GPIO_LED_SYSTEM		2
+#define TL_WA901ND_V2_GPIO_LED_WLAN		9
+
+#define TL_WA901ND_V2_GPIO_BTN_RESET		3
+#define TL_WA901ND_V2_GPIO_BTN_QSS		7
+
+#define TL_WA901ND_V2_KEYS_POLL_INTERVAL	20	/* msecs */
+#define TL_WA901ND_V2_KEYS_DEBOUNCE_INTERVAL	\
+					(3 * TL_WA901ND_V2_KEYS_POLL_INTERVAL)
+
+static const char *tl_wa901nd_v2_part_probes[] = {
+	"tp-link",
+	NULL,
+};
+
+static struct flash_platform_data tl_wa901nd_v2_flash_data = {
+	.part_probes	= tl_wa901nd_v2_part_probes,
+};
+
+static struct gpio_led tl_wa901nd_v2_leds_gpio[] __initdata = {
+	{
+		.name		= "tp-link:green:system",
+		.gpio		= TL_WA901ND_V2_GPIO_LED_SYSTEM,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:qss",
+		.gpio		= TL_WA901ND_V2_GPIO_LED_QSS,
+	}, {
+		.name		= "tp-link:green:wlan",
+		.gpio		= TL_WA901ND_V2_GPIO_LED_WLAN,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button tl_wa901nd_v2_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = TL_WA901ND_V2_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_WA901ND_V2_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}, {
+		.desc		= "qss",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = TL_WA901ND_V2_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_WA901ND_V2_GPIO_BTN_QSS,
+		.active_low	= 1,
+	}
+};
+
+static void __init tl_wa901nd_v2_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f01fc00);
+	u8 *eeprom  = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 0);
+
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ath79_eth0_data.phy_mask = 0x00001000;
+	ath79_register_mdio(0, 0x0);
+
+	ath79_eth0_data.reset_bit = AR71XX_RESET_GE0_MAC |
+				    AR71XX_RESET_GE0_PHY;
+	ath79_register_eth(0);
+
+	ath79_register_m25p80(&tl_wa901nd_v2_flash_data);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(tl_wa901nd_v2_leds_gpio),
+				 tl_wa901nd_v2_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, TL_WA901ND_V2_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(tl_wa901nd_v2_gpio_keys),
+					tl_wa901nd_v2_gpio_keys);
+
+	ath79_register_wmac(eeprom, mac);
+}
+
+MIPS_MACHINE(ATH79_MACH_TL_WA901ND_V2, "TL-WA901ND-v2",
+	     "TP-LINK TL-WA901ND v2", tl_wa901nd_v2_setup);
diff --git a/arch/mips/ath79/mach-tl-wa901nd.c b/arch/mips/ath79/mach-tl-wa901nd.c
new file mode 100644
index 0000000..2f4e0c0
--- /dev/null
+++ b/arch/mips/ath79/mach-tl-wa901nd.c
@@ -0,0 +1,109 @@
+/*
+ *  TP-LINK TL-WA901N/ND v1 board support
+ *
+ *  Copyright (C) 2009-2012 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2010 Pieter Hollants <pieter@hollants.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+#include <asm/mach-ath79/ath79.h>
+
+#include "common.h"
+#include "dev-ap9x-pci.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "machtypes.h"
+
+#define TL_WA901ND_GPIO_LED_QSS		0
+#define TL_WA901ND_GPIO_LED_SYSTEM	1
+#define TL_WA901ND_GPIO_LED_LAN		13
+
+#define TL_WA901ND_GPIO_BTN_RESET	11
+#define TL_WA901ND_GPIO_BTN_QSS		12
+
+#define TL_WA901ND_KEYS_POLL_INTERVAL	20	/* msecs */
+#define TL_WA901ND_KEYS_DEBOUNCE_INTERVAL (3 * TL_WA901ND_KEYS_POLL_INTERVAL)
+
+static const char *tl_wa901nd_part_probes[] = {
+	"tp-link",
+	NULL,
+};
+
+static struct flash_platform_data tl_wa901nd_flash_data = {
+	.part_probes	= tl_wa901nd_part_probes,
+};
+
+static struct gpio_led tl_wa901nd_leds_gpio[] __initdata = {
+	{
+		.name		= "tp-link:green:lan",
+		.gpio		= TL_WA901ND_GPIO_LED_LAN,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:system",
+		.gpio		= TL_WA901ND_GPIO_LED_SYSTEM,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:qss",
+		.gpio		= TL_WA901ND_GPIO_LED_QSS,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button tl_wa901nd_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= BTN_0,
+		.debounce_interval = TL_WA901ND_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_WA901ND_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}, {
+		.desc		= "qss",
+		.type		= EV_KEY,
+		.code		= BTN_1,
+		.debounce_interval = TL_WA901ND_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_WA901ND_GPIO_BTN_QSS,
+		.active_low	= 1,
+	}
+};
+
+static void __init tl_wa901nd_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f01fc00);
+	u8 *ee  = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	ath79_gpio_function_disable(AR724X_GPIO_FUNC_ETH_SWITCH_LED0_EN |
+				    AR724X_GPIO_FUNC_ETH_SWITCH_LED1_EN |
+				    AR724X_GPIO_FUNC_ETH_SWITCH_LED2_EN |
+				    AR724X_GPIO_FUNC_ETH_SWITCH_LED3_EN |
+				    AR724X_GPIO_FUNC_ETH_SWITCH_LED4_EN);
+
+	/*
+	 * ath79_eth0 would be the WAN port, but is not connected on
+	 * the TL-WA901ND. ath79_eth1 connects to the internal switch chip,
+	 * however we have a single LAN port only.
+	 */
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac, 0);
+	ath79_register_mdio(0, 0x0);
+	ath79_register_eth(1);
+
+	ath79_register_m25p80(&tl_wa901nd_flash_data);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(tl_wa901nd_leds_gpio),
+				 tl_wa901nd_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, TL_WA901ND_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(tl_wa901nd_gpio_keys),
+					tl_wa901nd_gpio_keys);
+
+	ap91_pci_init(ee, mac);
+}
+
+MIPS_MACHINE(ATH79_MACH_TL_WA901ND, "TL-WA901ND", "TP-LINK TL-WA901ND",
+	     tl_wa901nd_setup);
diff --git a/arch/mips/ath79/mach-tl-wdr4300.c b/arch/mips/ath79/mach-tl-wdr4300.c
new file mode 100644
index 0000000..6b3b1fe
--- /dev/null
+++ b/arch/mips/ath79/mach-tl-wdr4300.c
@@ -0,0 +1,203 @@
+/*
+ *  TP-LINK TL-WDR4300 board support
+ *
+ *  Copyright (C) 2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/pci.h>
+#include <linux/phy.h>
+#include <linux/gpio.h>
+#include <linux/platform_device.h>
+#include <linux/ath9k_platform.h>
+#include <linux/ar8216_platform.h>
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-ap9x-pci.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-spi.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define WDR4300_GPIO_LED_USB1		11
+#define WDR4300_GPIO_LED_USB2		12
+#define WDR4300_GPIO_LED_WLAN2G		13
+#define WDR4300_GPIO_LED_SYSTEM		14
+#define WDR4300_GPIO_LED_QSS		15
+
+#define WDR4300_GPIO_BTN_WPS		16
+#define WDR4300_GPIO_BTN_RFKILL		17
+
+#define WDR4300_GPIO_USB1_POWER		22
+#define WDR4300_GPIO_USB2_POWER		21
+
+#define WDR4300_KEYS_POLL_INTERVAL	20	/* msecs */
+#define WDR4300_KEYS_DEBOUNCE_INTERVAL	(3 * WDR4300_KEYS_POLL_INTERVAL)
+
+#define WDR4300_MAC0_OFFSET		0
+#define WDR4300_MAC1_OFFSET		6
+#define WDR4300_WMAC_CALDATA_OFFSET	0x1000
+#define WDR4300_PCIE_CALDATA_OFFSET	0x5000
+
+static const char *wdr4300_part_probes[] = {
+	"tp-link",
+	NULL,
+};
+
+static struct flash_platform_data wdr4300_flash_data = {
+	.part_probes	= wdr4300_part_probes,
+};
+
+static struct gpio_led wdr4300_leds_gpio[] __initdata = {
+	{
+		.name		= "tp-link:blue:qss",
+		.gpio		= WDR4300_GPIO_LED_QSS,
+		.active_low	= 1,
+	},
+	{
+		.name		= "tp-link:blue:system",
+		.gpio		= WDR4300_GPIO_LED_SYSTEM,
+		.active_low	= 1,
+	},
+	{
+		.name		= "tp-link:green:usb1",
+		.gpio		= WDR4300_GPIO_LED_USB1,
+		.active_low	= 1,
+	},
+	{
+		.name		= "tp-link:green:usb2",
+		.gpio		= WDR4300_GPIO_LED_USB2,
+		.active_low	= 1,
+	},
+	{
+		.name		= "tp-link:blue:wlan2g",
+		.gpio		= WDR4300_GPIO_LED_WLAN2G,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button wdr4300_gpio_keys[] __initdata = {
+	{
+		.desc		= "QSS button",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = WDR4300_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= WDR4300_GPIO_BTN_WPS,
+		.active_low	= 1,
+	},
+	{
+		.desc		= "RFKILL switch",
+		.type		= EV_SW,
+		.code		= KEY_RFKILL,
+		.debounce_interval = WDR4300_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= WDR4300_GPIO_BTN_RFKILL,
+	},
+};
+
+static struct ar8327_pad_cfg wdr4300_ar8327_pad0_cfg = {
+	.mode = AR8327_PAD_MAC_RGMII,
+	.txclk_delay_en = true,
+	.rxclk_delay_en = true,
+	.txclk_delay_sel = AR8327_CLK_DELAY_SEL1,
+	.rxclk_delay_sel = AR8327_CLK_DELAY_SEL2,
+};
+
+static struct ar8327_led_cfg wdr4300_ar8327_led_cfg = {
+	.led_ctrl0 = 0xc737c737,
+	.led_ctrl1 = 0x00000000,
+	.led_ctrl2 = 0x00000000,
+	.led_ctrl3 = 0x0030c300,
+	.open_drain = false,
+};
+
+static struct ar8327_platform_data wdr4300_ar8327_data = {
+	.pad0_cfg = &wdr4300_ar8327_pad0_cfg,
+	.cpuport_cfg = {
+		.force_link = 1,
+		.speed = AR8327_PORT_SPEED_1000,
+		.duplex = 1,
+		.txpause = 1,
+		.rxpause = 1,
+	},
+	.led_cfg = &wdr4300_ar8327_led_cfg,
+};
+
+static struct mdio_board_info wdr4300_mdio0_info[] = {
+	{
+		.bus_id = "ag71xx-mdio.0",
+		.phy_addr = 0,
+		.platform_data = &wdr4300_ar8327_data,
+	},
+};
+
+static void __init wdr4300_gmac_setup(void)
+{
+	void __iomem *base;
+	u32 t;
+
+	base = ioremap(AR934X_GMAC_BASE, AR934X_GMAC_SIZE);
+
+	t = __raw_readl(base + AR934X_GMAC_REG_ETH_CFG);
+	t &= ~(AR934X_ETH_CFG_RGMII_GMAC0 | AR934X_ETH_CFG_MII_GMAC0 |
+	       AR934X_ETH_CFG_GMII_GMAC0 | AR934X_ETH_CFG_SW_ONLY_MODE);
+	t |= AR934X_ETH_CFG_RGMII_GMAC0;
+
+	__raw_writel(t, base + AR934X_GMAC_REG_ETH_CFG);
+
+	iounmap(base);
+}
+
+static void __init wdr4300_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f01fc00);
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+	u8 tmpmac[ETH_ALEN];
+
+	ath79_register_m25p80(&wdr4300_flash_data);
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(wdr4300_leds_gpio),
+				 wdr4300_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, WDR4300_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(wdr4300_gpio_keys),
+					wdr4300_gpio_keys);
+
+	ath79_init_mac(tmpmac, mac, -1);
+	ath79_register_wmac(art + WDR4300_WMAC_CALDATA_OFFSET, tmpmac);
+
+	ath79_init_mac(tmpmac, mac, 0);
+	ap9x_pci_setup_wmac_led_pin(0, 0);
+	ap91_pci_init(art + WDR4300_PCIE_CALDATA_OFFSET, tmpmac);
+
+	wdr4300_gmac_setup();
+
+	mdiobus_register_board_info(wdr4300_mdio0_info,
+				    ARRAY_SIZE(wdr4300_mdio0_info));
+
+	ath79_register_mdio(0, 0x0);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, -2);
+
+	/* GMAC0 is connected to an AR8327N switch */
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.phy_mask = BIT(0);
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio0_device.dev;
+	ath79_eth0_pll_data.pll_1000 = 0x06000000;
+	ath79_register_eth(0);
+
+	ath79_set_usb_power_gpio(WDR4300_GPIO_USB1_POWER, GPIOF_OUT_INIT_HIGH,
+				"USB1 power");
+	ath79_set_usb_power_gpio(WDR4300_GPIO_USB2_POWER, GPIOF_OUT_INIT_HIGH,
+				"USB2 power");
+	ath79_register_usb();
+}
+
+MIPS_MACHINE(ATH79_MACH_TL_WDR4300, "TL-WDR4300", "TP-LINK TL-WDR4300",
+	     wdr4300_setup);
diff --git a/arch/mips/ath79/mach-tl-wr1041n-v2.c b/arch/mips/ath79/mach-tl-wr1041n-v2.c
new file mode 100644
index 0000000..ed5b2b0
--- /dev/null
+++ b/arch/mips/ath79/mach-tl-wr1041n-v2.c
@@ -0,0 +1,154 @@
+/*
+ *  TP-LINK TL-WR1041 v2 board support
+ *
+ *  Copyright (C) 2010-2012 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2011-2012 Anan Huang <axishero@foxmail.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/pci.h>
+#include <linux/phy.h>
+#include <linux/platform_device.h>
+#include <linux/ath9k_platform.h>
+#include <linux/ar8216_platform.h>
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-ap9x-pci.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-spi.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define TL_WR1041NV2_GPIO_BTN_RESET	14
+#define TL_WR1041NV2_GPIO_LED_WPS	13
+#define TL_WR1041NV2_GPIO_LED_WLAN	11
+
+#define TL_WR1041NV2_GPIO_LED_SYSTEM	12
+
+#define TL_WR1041NV2_KEYS_POLL_INTERVAL		20	/* msecs */
+#define TL_WR1041NV2_KEYS_DEBOUNCE_INTERVAL	(3 * TL_WR1041NV2_KEYS_POLL_INTERVAL)
+
+#define TL_WR1041NV2_PCIE_CALDATA_OFFSET	0x5000
+
+static const char *tl_wr1041nv2_part_probes[] = {
+	"tp-link",
+	NULL,
+};
+
+static struct flash_platform_data tl_wr1041nv2_flash_data = {
+	.part_probes	= tl_wr1041nv2_part_probes,
+};
+
+static struct gpio_led tl_wr1041nv2_leds_gpio[] __initdata = {
+	{
+		.name		= "tp-link:green:system",
+		.gpio		= TL_WR1041NV2_GPIO_LED_SYSTEM,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:wps",
+		.gpio		= TL_WR1041NV2_GPIO_LED_WPS,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:wlan",
+		.gpio		= TL_WR1041NV2_GPIO_LED_WLAN,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button tl_wr1041nv2_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = TL_WR1041NV2_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_WR1041NV2_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}
+};
+
+static struct ar8327_pad_cfg db120_ar8327_pad0_cfg = {
+	.mode = AR8327_PAD_MAC_RGMII,
+	.txclk_delay_en = true,
+	.rxclk_delay_en = true,
+	.txclk_delay_sel = AR8327_CLK_DELAY_SEL1,
+	.rxclk_delay_sel = AR8327_CLK_DELAY_SEL2,
+};
+
+static struct ar8327_platform_data db120_ar8327_data = {
+	.pad0_cfg = &db120_ar8327_pad0_cfg,
+	.cpuport_cfg = {
+		.force_link = 1,
+		.speed = AR8327_PORT_SPEED_1000,
+		.duplex = 1,
+		.txpause = 1,
+		.rxpause = 1,
+	}
+};
+
+static struct mdio_board_info db120_mdio0_info[] = {
+	{
+		.bus_id = "ag71xx-mdio.0",
+		.phy_addr = 0,
+		.platform_data = &db120_ar8327_data,
+	},
+};
+
+static void __init db120_gmac_setup(void)
+{
+	void __iomem *base;
+	u32 t;
+
+	base = ioremap(AR934X_GMAC_BASE, AR934X_GMAC_SIZE);
+
+	t = __raw_readl(base + AR934X_GMAC_REG_ETH_CFG);
+	t &= ~(AR934X_ETH_CFG_RGMII_GMAC0 | AR934X_ETH_CFG_MII_GMAC0 |
+	       AR934X_ETH_CFG_GMII_GMAC0 | AR934X_ETH_CFG_SW_ONLY_MODE);
+	t |= AR934X_ETH_CFG_RGMII_GMAC0 | AR934X_ETH_CFG_SW_ONLY_MODE;
+
+	__raw_writel(t, base + AR934X_GMAC_REG_ETH_CFG);
+
+	iounmap(base);
+}
+
+static void __init tl_wr1041nv2_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f01fc00);
+	u8 *ee = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	ath79_register_m25p80(&tl_wr1041nv2_flash_data);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(tl_wr1041nv2_leds_gpio),
+				 tl_wr1041nv2_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, TL_WR1041NV2_KEYS_POLL_INTERVAL,
+					 ARRAY_SIZE(tl_wr1041nv2_gpio_keys),
+					 tl_wr1041nv2_gpio_keys);
+	ath79_register_wmac(ee, mac);
+
+	db120_gmac_setup();
+
+	ath79_register_mdio(1, 0x0);
+	ath79_register_mdio(0, 0x0);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 1);
+
+	mdiobus_register_board_info(db120_mdio0_info,
+				    ARRAY_SIZE(db120_mdio0_info));
+
+	/* GMAC0 is connected to an AR8327 switch */
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.phy_mask = BIT(0);
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio0_device.dev;
+	ath79_eth0_pll_data.pll_1000 = 0x06000000;
+	ath79_register_eth(0);
+}
+
+MIPS_MACHINE(ATH79_MACH_TL_WR1041N_V2, "TL-WR1041N-v2",
+	     "TP-LINK TL-WR1041N v2", tl_wr1041nv2_setup);
diff --git a/arch/mips/ath79/mach-tl-wr1043nd.c b/arch/mips/ath79/mach-tl-wr1043nd.c
new file mode 100644
index 0000000..e789b40
--- /dev/null
+++ b/arch/mips/ath79/mach-tl-wr1043nd.c
@@ -0,0 +1,128 @@
+/*
+ *  TP-LINK TL-WR1043N/ND board support
+ *
+ *  Copyright (C) 2009-2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/platform_device.h>
+#include <linux/rtl8366.h>
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-eth.h"
+#include "dev-m25p80.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define TL_WR1043ND_GPIO_LED_USB        1
+#define TL_WR1043ND_GPIO_LED_SYSTEM     2
+#define TL_WR1043ND_GPIO_LED_QSS        5
+#define TL_WR1043ND_GPIO_LED_WLAN       9
+
+#define TL_WR1043ND_GPIO_BTN_RESET      3
+#define TL_WR1043ND_GPIO_BTN_QSS        7
+
+#define TL_WR1043ND_GPIO_RTL8366_SDA	18
+#define TL_WR1043ND_GPIO_RTL8366_SCK	19
+
+#define TL_WR1043ND_KEYS_POLL_INTERVAL	20	/* msecs */
+#define TL_WR1043ND_KEYS_DEBOUNCE_INTERVAL (3 * TL_WR1043ND_KEYS_POLL_INTERVAL)
+
+static const char *tl_wr1043nd_part_probes[] = {
+	"tp-link",
+	NULL,
+};
+
+static struct flash_platform_data tl_wr1043nd_flash_data = {
+	.part_probes	= tl_wr1043nd_part_probes,
+};
+
+static struct gpio_led tl_wr1043nd_leds_gpio[] __initdata = {
+	{
+		.name		= "tp-link:green:usb",
+		.gpio		= TL_WR1043ND_GPIO_LED_USB,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:system",
+		.gpio		= TL_WR1043ND_GPIO_LED_SYSTEM,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:qss",
+		.gpio		= TL_WR1043ND_GPIO_LED_QSS,
+		.active_low	= 0,
+	}, {
+		.name		= "tp-link:green:wlan",
+		.gpio		= TL_WR1043ND_GPIO_LED_WLAN,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button tl_wr1043nd_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = TL_WR1043ND_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_WR1043ND_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}, {
+		.desc		= "qss",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = TL_WR1043ND_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_WR1043ND_GPIO_BTN_QSS,
+		.active_low	= 1,
+	}
+};
+
+static struct rtl8366_platform_data tl_wr1043nd_rtl8366rb_data = {
+	.gpio_sda        = TL_WR1043ND_GPIO_RTL8366_SDA,
+	.gpio_sck        = TL_WR1043ND_GPIO_RTL8366_SCK,
+};
+
+static struct platform_device tl_wr1043nd_rtl8366rb_device = {
+	.name		= RTL8366RB_DRIVER_NAME,
+	.id		= -1,
+	.dev = {
+		.platform_data	= &tl_wr1043nd_rtl8366rb_data,
+	}
+};
+
+static void __init tl_wr1043nd_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f01fc00);
+	u8 *eeprom = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 0);
+	ath79_eth0_data.mii_bus_dev = &tl_wr1043nd_rtl8366rb_device.dev;
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.speed = SPEED_1000;
+	ath79_eth0_data.duplex = DUPLEX_FULL;
+	ath79_eth0_pll_data.pll_1000 = 0x1a000000;
+
+	ath79_register_eth(0);
+
+	ath79_register_usb();
+
+	ath79_register_m25p80(&tl_wr1043nd_flash_data);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(tl_wr1043nd_leds_gpio),
+				 tl_wr1043nd_leds_gpio);
+
+	platform_device_register(&tl_wr1043nd_rtl8366rb_device);
+
+	ath79_register_gpio_keys_polled(-1, TL_WR1043ND_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(tl_wr1043nd_gpio_keys),
+					tl_wr1043nd_gpio_keys);
+
+	ath79_register_wmac(eeprom, mac);
+}
+
+MIPS_MACHINE(ATH79_MACH_TL_WR1043ND, "TL-WR1043ND", "TP-LINK TL-WR1043ND",
+	     tl_wr1043nd_setup);
diff --git a/arch/mips/ath79/mach-tl-wr2543n.c b/arch/mips/ath79/mach-tl-wr2543n.c
new file mode 100644
index 0000000..c650e5a
--- /dev/null
+++ b/arch/mips/ath79/mach-tl-wr2543n.c
@@ -0,0 +1,132 @@
+/*
+ *  TP-LINK TL-WR2543N/ND board support
+ *
+ *  Copyright (C) 2011-2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/platform_device.h>
+#include <linux/rtl8367.h>
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-eth.h"
+#include "dev-ap9x-pci.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "machtypes.h"
+
+#define TL_WR2543N_GPIO_LED_WPS        0
+#define TL_WR2543N_GPIO_LED_USB        8
+
+#define TL_WR2543N_GPIO_BTN_RESET      11
+#define TL_WR2543N_GPIO_BTN_WPS        12
+
+#define TL_WR2543N_GPIO_RTL8367_SDA	1
+#define TL_WR2543N_GPIO_RTL8367_SCK	6
+
+#define TL_WR2543N_KEYS_POLL_INTERVAL	20	/* msecs */
+#define TL_WR2543N_KEYS_DEBOUNCE_INTERVAL (3 * TL_WR2543N_KEYS_POLL_INTERVAL)
+
+static const char *tl_wr2543n_part_probes[] = {
+	"tp-link",
+	NULL,
+};
+
+static struct flash_platform_data tl_wr2543n_flash_data = {
+	.part_probes	= tl_wr2543n_part_probes,
+};
+
+static struct gpio_led tl_wr2543n_leds_gpio[] __initdata = {
+	{
+		.name		= "tp-link:green:usb",
+		.gpio		= TL_WR2543N_GPIO_LED_USB,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:wps",
+		.gpio		= TL_WR2543N_GPIO_LED_WPS,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button tl_wr2543n_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = TL_WR2543N_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_WR2543N_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}, {
+		.desc		= "wps",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = TL_WR2543N_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_WR2543N_GPIO_BTN_WPS,
+		.active_low	= 1,
+	}
+};
+
+static struct rtl8367_extif_config tl_wr2543n_rtl8367_extif0_cfg = {
+	.mode = RTL8367_EXTIF_MODE_RGMII,
+	.txdelay = 1,
+	.rxdelay = 0,
+	.ability = {
+		.force_mode = 1,
+		.txpause = 1,
+		.rxpause = 1,
+		.link = 1,
+		.duplex = 1,
+		.speed = RTL8367_PORT_SPEED_1000,
+	},
+};
+
+static struct rtl8367_platform_data tl_wr2543n_rtl8367_data = {
+	.gpio_sda	= TL_WR2543N_GPIO_RTL8367_SDA,
+	.gpio_sck	= TL_WR2543N_GPIO_RTL8367_SCK,
+	.extif0_cfg	= &tl_wr2543n_rtl8367_extif0_cfg,
+};
+
+static struct platform_device tl_wr2543n_rtl8367_device = {
+	.name		= RTL8367_DRIVER_NAME,
+	.id		= -1,
+	.dev = {
+		.platform_data	= &tl_wr2543n_rtl8367_data,
+	}
+};
+
+static void __init tl_wr2543n_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f01fc00);
+	u8 *eeprom = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	ath79_register_m25p80(&tl_wr2543n_flash_data);
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(tl_wr2543n_leds_gpio),
+				 tl_wr2543n_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, TL_WR2543N_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(tl_wr2543n_gpio_keys),
+					tl_wr2543n_gpio_keys);
+	ath79_register_usb();
+
+	ap9x_pci_setup_wmac_led_pin(0, 0);
+	ap91_pci_init(eeprom, mac);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, -1);
+	ath79_eth0_data.mii_bus_dev = &tl_wr2543n_rtl8367_device.dev;
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.speed = SPEED_1000;
+	ath79_eth0_data.duplex = DUPLEX_FULL;
+	ath79_eth0_pll_data.pll_1000 = 0x1a000000;
+
+	ath79_register_eth(0);
+
+	platform_device_register(&tl_wr2543n_rtl8367_device);
+}
+
+MIPS_MACHINE(ATH79_MACH_TL_WR2543N, "TL-WR2543N", "TP-LINK TL-WR2543N/ND",
+	     tl_wr2543n_setup);
diff --git a/arch/mips/ath79/mach-tl-wr703n.c b/arch/mips/ath79/mach-tl-wr703n.c
new file mode 100644
index 0000000..f60f962
--- /dev/null
+++ b/arch/mips/ath79/mach-tl-wr703n.c
@@ -0,0 +1,85 @@
+/*
+ *  TP-LINK TL-WR703N board support
+ *
+ *  Copyright (C) 2011 dongyuqi <729650915@qq.com>
+ *  Copyright (C) 2011-2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/gpio.h>
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define TL_WR703N_GPIO_LED_SYSTEM	27
+#define TL_WR703N_GPIO_BTN_RESET	11
+
+#define TL_WR703N_GPIO_USB_POWER	8
+
+#define TL_WR703N_KEYS_POLL_INTERVAL	20	/* msecs */
+#define TL_WR703N_KEYS_DEBOUNCE_INTERVAL	(3 * TL_WR703N_KEYS_POLL_INTERVAL)
+
+static const char *tl_wr703n_part_probes[] = {
+	"tp-link",
+	NULL,
+};
+
+static struct flash_platform_data tl_wr703n_flash_data = {
+	.part_probes	= tl_wr703n_part_probes,
+};
+
+static struct gpio_led tl_wr703n_leds_gpio[] __initdata = {
+	{
+		.name		= "tp-link:blue:system",
+		.gpio		= TL_WR703N_GPIO_LED_SYSTEM,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button tl_wr703n_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = TL_WR703N_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_WR703N_GPIO_BTN_RESET,
+		.active_low	= 0,
+	}
+};
+
+static void __init tl_wr703n_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f01fc00);
+	u8 *ee = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	ath79_register_m25p80(&tl_wr703n_flash_data);
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(tl_wr703n_leds_gpio),
+				 tl_wr703n_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, TL_WR703N_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(tl_wr703n_gpio_keys),
+					tl_wr703n_gpio_keys);
+
+	ath79_set_usb_power_gpio(TL_WR703N_GPIO_USB_POWER, GPIOF_OUT_INIT_HIGH,
+				"USB power");
+	ath79_register_usb();
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 0);
+
+	ath79_register_mdio(0, 0x0);
+	ath79_register_eth(0);
+
+	ath79_register_wmac(ee, mac);
+}
+
+MIPS_MACHINE(ATH79_MACH_TL_WR703N, "TL-WR703N", "TP-LINK TL-WR703N v1",
+	     tl_wr703n_setup);
diff --git a/arch/mips/ath79/mach-tl-wr741nd-v4.c b/arch/mips/ath79/mach-tl-wr741nd-v4.c
new file mode 100644
index 0000000..0d75891
--- /dev/null
+++ b/arch/mips/ath79/mach-tl-wr741nd-v4.c
@@ -0,0 +1,135 @@
+/*
+ *  TP-LINK TL-WR741ND v4 board support
+ *
+ *  Copyright (C) 2011-2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/gpio.h>
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define TL_WR741NDV4_GPIO_BTN_RESET	11
+#define TL_WR741NDV4_GPIO_BTN_WPS	26
+
+#define TL_WR741NDV4_GPIO_LED_WLAN	0
+#define TL_WR741NDV4_GPIO_LED_QSS	1
+#define TL_WR741NDV4_GPIO_LED_WAN	13
+#define TL_WR741NDV4_GPIO_LED_LAN1	14
+#define TL_WR741NDV4_GPIO_LED_LAN2	15
+#define TL_WR741NDV4_GPIO_LED_LAN3	16
+#define TL_WR741NDV4_GPIO_LED_LAN4	17
+
+#define TL_WR741NDV4_GPIO_LED_SYSTEM	27
+
+#define TL_WR741NDV4_KEYS_POLL_INTERVAL	20	/* msecs */
+#define TL_WR741NDV4_KEYS_DEBOUNCE_INTERVAL (3 * TL_WR741NDV4_KEYS_POLL_INTERVAL)
+
+static const char *tl_wr741ndv4_part_probes[] = {
+	"tp-link",
+	NULL,
+};
+
+static struct flash_platform_data tl_wr741ndv4_flash_data = {
+	.part_probes	= tl_wr741ndv4_part_probes,
+};
+
+static struct gpio_led tl_wr741ndv4_leds_gpio[] __initdata = {
+	{
+		.name		= "tp-link:green:lan1",
+		.gpio		= TL_WR741NDV4_GPIO_LED_LAN1,
+		.active_low	= 0,
+	}, {
+		.name		= "tp-link:green:lan2",
+		.gpio		= TL_WR741NDV4_GPIO_LED_LAN2,
+		.active_low	= 0,
+	}, {
+		.name		= "tp-link:green:lan3",
+		.gpio		= TL_WR741NDV4_GPIO_LED_LAN3,
+		.active_low	= 0,
+	}, {
+		.name		= "tp-link:green:lan4",
+		.gpio		= TL_WR741NDV4_GPIO_LED_LAN4,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:qss",
+		.gpio		= TL_WR741NDV4_GPIO_LED_QSS,
+		.active_low	= 0,
+	}, {
+		.name		= "tp-link:green:system",
+		.gpio		= TL_WR741NDV4_GPIO_LED_SYSTEM,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:wan",
+		.gpio		= TL_WR741NDV4_GPIO_LED_WAN,
+		.active_low	= 0,
+	}, {
+		.name		= "tp-link:green:wlan",
+		.gpio		= TL_WR741NDV4_GPIO_LED_WLAN,
+		.active_low	= 0,
+	},
+};
+
+static struct gpio_keys_button tl_wr741ndv4_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = TL_WR741NDV4_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_WR741NDV4_GPIO_BTN_RESET,
+		.active_low	= 0,
+	}, {
+		.desc		= "WPS",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = TL_WR741NDV4_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_WR741NDV4_GPIO_BTN_WPS,
+		.active_low	= 0,
+	}
+};
+
+static void __init tl_wr741ndv4_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f01fc00);
+	u8 *ee = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	ath79_setup_ar933x_phy4_switch(true, true);
+
+	ath79_gpio_function_disable(AR933X_GPIO_FUNC_ETH_SWITCH_LED0_EN |
+				    AR933X_GPIO_FUNC_ETH_SWITCH_LED1_EN |
+				    AR933X_GPIO_FUNC_ETH_SWITCH_LED2_EN |
+				    AR933X_GPIO_FUNC_ETH_SWITCH_LED3_EN |
+				    AR933X_GPIO_FUNC_ETH_SWITCH_LED4_EN);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(tl_wr741ndv4_leds_gpio),
+				 tl_wr741ndv4_leds_gpio);
+
+	ath79_register_gpio_keys_polled(1, TL_WR741NDV4_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(tl_wr741ndv4_gpio_keys),
+					tl_wr741ndv4_gpio_keys);
+
+	ath79_register_m25p80(&tl_wr741ndv4_flash_data);
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 1);
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac, -1);
+
+	ath79_register_mdio(0, 0x0);
+	ath79_register_eth(1);
+	ath79_register_eth(0);
+
+	ath79_register_wmac(ee, mac);
+}
+
+MIPS_MACHINE(ATH79_MACH_TL_WR741ND_V4, "TL-WR741ND-v4",
+	     "TP-LINK TL-WR741ND v4", tl_wr741ndv4_setup);
diff --git a/arch/mips/ath79/mach-tl-wr741nd.c b/arch/mips/ath79/mach-tl-wr741nd.c
new file mode 100644
index 0000000..5931654
--- /dev/null
+++ b/arch/mips/ath79/mach-tl-wr741nd.c
@@ -0,0 +1,130 @@
+/*
+ *  TP-LINK TL-WR741ND board support
+ *
+ *  Copyright (C) 2009-2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-ap9x-pci.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "machtypes.h"
+
+#define TL_WR741ND_GPIO_LED_QSS		0
+#define TL_WR741ND_GPIO_LED_SYSTEM	1
+#define TL_WR741ND_GPIO_LED_LAN1	13
+#define TL_WR741ND_GPIO_LED_LAN2	14
+#define TL_WR741ND_GPIO_LED_LAN3	15
+#define TL_WR741ND_GPIO_LED_LAN4	16
+#define TL_WR741ND_GPIO_LED_WAN		17
+
+#define TL_WR741ND_GPIO_BTN_RESET	11
+#define TL_WR741ND_GPIO_BTN_QSS		12
+
+#define TL_WR741ND_KEYS_POLL_INTERVAL	20	/* msecs */
+#define TL_WR741ND_KEYS_DEBOUNCE_INTERVAL (3 * TL_WR741ND_KEYS_POLL_INTERVAL)
+
+static const char *tl_wr741nd_part_probes[] = {
+	"tp-link",
+	NULL,
+};
+
+static struct flash_platform_data tl_wr741nd_flash_data = {
+	.part_probes	= tl_wr741nd_part_probes,
+};
+
+static struct gpio_led tl_wr741nd_leds_gpio[] __initdata = {
+	{
+		.name		= "tp-link:green:lan1",
+		.gpio		= TL_WR741ND_GPIO_LED_LAN1,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:lan2",
+		.gpio		= TL_WR741ND_GPIO_LED_LAN2,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:lan3",
+		.gpio		= TL_WR741ND_GPIO_LED_LAN3,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:lan4",
+		.gpio		= TL_WR741ND_GPIO_LED_LAN4,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:qss",
+		.gpio		= TL_WR741ND_GPIO_LED_QSS,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:system",
+		.gpio		= TL_WR741ND_GPIO_LED_SYSTEM,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:wan",
+		.gpio		= TL_WR741ND_GPIO_LED_WAN,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button tl_wr741nd_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = TL_WR741ND_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_WR741ND_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}, {
+		.desc		= "qss",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = TL_WR741ND_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_WR741ND_GPIO_BTN_QSS,
+		.active_low	= 1,
+	}
+};
+
+static void __init tl_wr741nd_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f01fc00);
+	u8 *ee = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	ath79_register_m25p80(&tl_wr741nd_flash_data);
+
+	ath79_gpio_function_disable(AR724X_GPIO_FUNC_ETH_SWITCH_LED0_EN |
+				    AR724X_GPIO_FUNC_ETH_SWITCH_LED1_EN |
+				    AR724X_GPIO_FUNC_ETH_SWITCH_LED2_EN |
+				    AR724X_GPIO_FUNC_ETH_SWITCH_LED3_EN |
+				    AR724X_GPIO_FUNC_ETH_SWITCH_LED4_EN);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(tl_wr741nd_leds_gpio),
+				 tl_wr741nd_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, TL_WR741ND_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(tl_wr741nd_gpio_keys),
+					tl_wr741nd_gpio_keys);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 1);
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac, -1);
+
+	ath79_register_mdio(0, 0x0);
+
+	/* LAN ports */
+	ath79_register_eth(1);
+
+	/* WAN port */
+	ath79_register_eth(0);
+
+	ap9x_pci_setup_wmac_led_pin(0, 1);
+	ap91_pci_init(ee, mac);
+}
+MIPS_MACHINE(ATH79_MACH_TL_WR741ND, "TL-WR741ND", "TP-LINK TL-WR741ND",
+	     tl_wr741nd_setup);
diff --git a/arch/mips/ath79/mach-tl-wr841n.c b/arch/mips/ath79/mach-tl-wr841n.c
new file mode 100644
index 0000000..11f853f
--- /dev/null
+++ b/arch/mips/ath79/mach-tl-wr841n.c
@@ -0,0 +1,140 @@
+/*
+ *  TP-LINK TL-WR841N/ND v1 board support
+ *
+ *  Copyright (C) 2009-2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <linux/platform_device.h>
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-dsa.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "machtypes.h"
+#include "pci.h"
+
+#define TL_WR841ND_V1_GPIO_LED_SYSTEM		2
+#define TL_WR841ND_V1_GPIO_LED_QSS_GREEN	4
+#define TL_WR841ND_V1_GPIO_LED_QSS_RED		5
+
+#define TL_WR841ND_V1_GPIO_BTN_RESET		3
+#define TL_WR841ND_V1_GPIO_BTN_QSS		7
+
+#define TL_WR841ND_V1_KEYS_POLL_INTERVAL	20	/* msecs */
+#define TL_WR841ND_V1_KEYS_DEBOUNCE_INTERVAL \
+				(3 * TL_WR841ND_V1_KEYS_POLL_INTERVAL)
+
+static struct mtd_partition tl_wr841n_v1_partitions[] = {
+	{
+		.name		= "redboot",
+		.offset		= 0,
+		.size		= 0x020000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "kernel",
+		.offset		= 0x020000,
+		.size		= 0x140000,
+	}, {
+		.name		= "rootfs",
+		.offset		= 0x160000,
+		.size		= 0x280000,
+	}, {
+		.name		= "config",
+		.offset		= 0x3e0000,
+		.size		= 0x020000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "firmware",
+		.offset		= 0x020000,
+		.size		= 0x3c0000,
+	}
+};
+
+static struct flash_platform_data tl_wr841n_v1_flash_data = {
+	.parts		= tl_wr841n_v1_partitions,
+	.nr_parts	= ARRAY_SIZE(tl_wr841n_v1_partitions),
+};
+
+static struct gpio_led tl_wr841n_v1_leds_gpio[] __initdata = {
+	{
+		.name		= "tp-link:green:system",
+		.gpio		= TL_WR841ND_V1_GPIO_LED_SYSTEM,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:red:qss",
+		.gpio		= TL_WR841ND_V1_GPIO_LED_QSS_RED,
+	}, {
+		.name		= "tp-link:green:qss",
+		.gpio		= TL_WR841ND_V1_GPIO_LED_QSS_GREEN,
+	}
+};
+
+static struct gpio_keys_button tl_wr841n_v1_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = TL_WR841ND_V1_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_WR841ND_V1_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}, {
+		.desc		= "qss",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = TL_WR841ND_V1_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_WR841ND_V1_GPIO_BTN_QSS,
+		.active_low	= 1,
+	}
+};
+
+static struct dsa_chip_data tl_wr841n_v1_dsa_chip = {
+	.port_names[0]  = "wan",
+	.port_names[1]  = "lan1",
+	.port_names[2]  = "lan2",
+	.port_names[3]  = "lan3",
+	.port_names[4]  = "lan4",
+	.port_names[5]  = "cpu",
+};
+
+static struct dsa_platform_data tl_wr841n_v1_dsa_data = {
+	.nr_chips	= 1,
+	.chip		= &tl_wr841n_v1_dsa_chip,
+};
+
+static void __init tl_wr841n_v1_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f01fc00);
+
+	ath79_register_mdio(0, 0x0);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 0);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ath79_eth0_data.speed = SPEED_100;
+	ath79_eth0_data.duplex = DUPLEX_FULL;
+
+	ath79_register_eth(0);
+	ath79_register_dsa(&ath79_eth0_device.dev, &ath79_mdio0_device.dev,
+			   &tl_wr841n_v1_dsa_data);
+
+	ath79_register_m25p80(&tl_wr841n_v1_flash_data);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(tl_wr841n_v1_leds_gpio),
+				 tl_wr841n_v1_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, TL_WR841ND_V1_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(tl_wr841n_v1_gpio_keys),
+					tl_wr841n_v1_gpio_keys);
+	ath79_register_pci();
+}
+
+MIPS_MACHINE(ATH79_MACH_TL_WR841N_V1, "TL-WR841N-v1.5", "TP-LINK TL-WR841N v1",
+	     tl_wr841n_v1_setup);
diff --git a/arch/mips/ath79/mach-tl-wr941nd.c b/arch/mips/ath79/mach-tl-wr941nd.c
new file mode 100644
index 0000000..1ddeec7
--- /dev/null
+++ b/arch/mips/ath79/mach-tl-wr941nd.c
@@ -0,0 +1,121 @@
+/*
+ *  TP-LINK TL-WR941ND board support
+ *
+ *  Copyright (C) 2009-2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/platform_device.h>
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-dsa.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define TL_WR941ND_GPIO_LED_SYSTEM	2
+#define TL_WR941ND_GPIO_LED_QSS_RED	4
+#define TL_WR941ND_GPIO_LED_QSS_GREEN	5
+#define TL_WR941ND_GPIO_LED_WLAN	9
+
+#define TL_WR941ND_GPIO_BTN_RESET	3
+#define TL_WR941ND_GPIO_BTN_QSS		7
+
+#define TL_WR941ND_KEYS_POLL_INTERVAL	20	/* msecs */
+#define TL_WR941ND_KEYS_DEBOUNCE_INTERVAL (3 * TL_WR941ND_KEYS_POLL_INTERVAL)
+
+static const char *tl_wr941nd_part_probes[] = {
+	"tp-link",
+	NULL,
+};
+
+static struct flash_platform_data tl_wr941nd_flash_data = {
+	.part_probes	= tl_wr941nd_part_probes,
+};
+
+static struct gpio_led tl_wr941nd_leds_gpio[] __initdata = {
+	{
+		.name		= "tp-link:green:system",
+		.gpio		= TL_WR941ND_GPIO_LED_SYSTEM,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:red:qss",
+		.gpio		= TL_WR941ND_GPIO_LED_QSS_RED,
+	}, {
+		.name		= "tp-link:green:qss",
+		.gpio		= TL_WR941ND_GPIO_LED_QSS_GREEN,
+	}, {
+		.name		= "tp-link:green:wlan",
+		.gpio		= TL_WR941ND_GPIO_LED_WLAN,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button tl_wr941nd_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = TL_WR941ND_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_WR941ND_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}, {
+		.desc		= "qss",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = TL_WR941ND_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_WR941ND_GPIO_BTN_QSS,
+		.active_low	= 1,
+	}
+};
+
+static struct dsa_chip_data tl_wr941nd_dsa_chip = {
+	.port_names[0]  = "wan",
+	.port_names[1]  = "lan1",
+	.port_names[2]  = "lan2",
+	.port_names[3]  = "lan3",
+	.port_names[4]  = "lan4",
+	.port_names[5]  = "cpu",
+};
+
+static struct dsa_platform_data tl_wr941nd_dsa_data = {
+	.nr_chips	= 1,
+	.chip		= &tl_wr941nd_dsa_chip,
+};
+
+static void __init tl_wr941nd_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f01fc00);
+	u8 *eeprom = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	ath79_register_mdio(0, 0x0);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 0);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ath79_eth0_data.speed = SPEED_100;
+	ath79_eth0_data.duplex = DUPLEX_FULL;
+
+	ath79_register_eth(0);
+	ath79_register_dsa(&ath79_eth0_device.dev, &ath79_mdio0_device.dev,
+			   &tl_wr941nd_dsa_data);
+
+	ath79_register_m25p80(&tl_wr941nd_flash_data);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(tl_wr941nd_leds_gpio),
+				 tl_wr941nd_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, TL_WR941ND_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(tl_wr941nd_gpio_keys),
+					tl_wr941nd_gpio_keys);
+	ath79_register_wmac(eeprom, mac);
+}
+
+MIPS_MACHINE(ATH79_MACH_TL_WR941ND, "TL-WR941ND", "TP-LINK TL-WR941ND",
+	     tl_wr941nd_setup);
diff --git a/arch/mips/ath79/mach-ubnt.c b/arch/mips/ath79/mach-ubnt.c
new file mode 100644
index 0000000..e49ac23
--- /dev/null
+++ b/arch/mips/ath79/mach-ubnt.c
@@ -0,0 +1,205 @@
+/*
+ *  Ubiquiti RouterStation support
+ *
+ *  Copyright (C) 2008-2012 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *  Copyright (C) 2008 Ubiquiti <support@ubnt.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "machtypes.h"
+#include "pci.h"
+
+#define UBNT_RS_GPIO_LED_RF	2
+#define UBNT_RS_GPIO_SW4	8
+
+#define UBNT_LS_SR71_GPIO_LED_D25	0
+#define UBNT_LS_SR71_GPIO_LED_D26	1
+#define UBNT_LS_SR71_GPIO_LED_D24	2
+#define UBNT_LS_SR71_GPIO_LED_D23	4
+#define UBNT_LS_SR71_GPIO_LED_D22	5
+#define UBNT_LS_SR71_GPIO_LED_D27	6
+#define UBNT_LS_SR71_GPIO_LED_D28	7
+
+#define UBNT_KEYS_POLL_INTERVAL		20	/* msecs */
+#define UBNT_KEYS_DEBOUNCE_INTERVAL	(3 * UBNT_KEYS_POLL_INTERVAL)
+
+static struct gpio_led ubnt_rs_leds_gpio[] __initdata = {
+	{
+		.name		= "ubnt:green:rf",
+		.gpio		= UBNT_RS_GPIO_LED_RF,
+		.active_low	= 0,
+	}
+};
+
+static struct gpio_led ubnt_ls_sr71_leds_gpio[] __initdata = {
+	{
+		.name		= "ubnt:green:d22",
+		.gpio		= UBNT_LS_SR71_GPIO_LED_D22,
+		.active_low	= 0,
+	}, {
+		.name		= "ubnt:green:d23",
+		.gpio		= UBNT_LS_SR71_GPIO_LED_D23,
+		.active_low	= 0,
+	}, {
+		.name		= "ubnt:green:d24",
+		.gpio		= UBNT_LS_SR71_GPIO_LED_D24,
+		.active_low	= 0,
+	}, {
+		.name		= "ubnt:red:d25",
+		.gpio		= UBNT_LS_SR71_GPIO_LED_D25,
+		.active_low	= 0,
+	}, {
+		.name		= "ubnt:red:d26",
+		.gpio		= UBNT_LS_SR71_GPIO_LED_D26,
+		.active_low	= 0,
+	}, {
+		.name		= "ubnt:green:d27",
+		.gpio		= UBNT_LS_SR71_GPIO_LED_D27,
+		.active_low	= 0,
+	}, {
+		.name		= "ubnt:green:d28",
+		.gpio		= UBNT_LS_SR71_GPIO_LED_D28,
+		.active_low	= 0,
+	}
+};
+
+static struct gpio_keys_button ubnt_gpio_keys[] __initdata = {
+	{
+		.desc		= "sw4",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = UBNT_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= UBNT_RS_GPIO_SW4,
+		.active_low	= 1,
+	}
+};
+
+static const char *ubnt_part_probes[] = {
+	"RedBoot",
+	NULL,
+};
+
+static struct flash_platform_data ubnt_flash_data = {
+	.part_probes	= ubnt_part_probes,
+};
+
+static void __init ubnt_generic_setup(void)
+{
+	ath79_register_m25p80(&ubnt_flash_data);
+
+	ath79_register_gpio_keys_polled(-1, UBNT_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(ubnt_gpio_keys),
+					ubnt_gpio_keys);
+	ath79_register_pci();
+}
+
+#define UBNT_RS_WAN_PHYMASK	BIT(20)
+#define UBNT_RS_LAN_PHYMASK	(BIT(16) | BIT(17) | BIT(18) | BIT(19))
+
+static void __init ubnt_rs_setup(void)
+{
+	ubnt_generic_setup();
+
+	ath79_register_mdio(0, ~(UBNT_RS_WAN_PHYMASK | UBNT_RS_LAN_PHYMASK));
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, ath79_mac_base, 0);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ath79_eth0_data.phy_mask = UBNT_RS_WAN_PHYMASK;
+
+	/*
+	 * There is Secondary MAC address duplicate problem with some
+	 * UBNT HW batches.  Do not increase Secondary MAC address by 1
+	 * but do workaround with 'Locally Administrated' bit.
+	 */
+	ath79_init_local_mac(ath79_eth1_data.mac_addr, ath79_mac_base);
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ath79_eth1_data.speed = SPEED_100;
+	ath79_eth1_data.duplex = DUPLEX_FULL;
+
+	ath79_register_eth(0);
+	ath79_register_eth(1);
+
+	ath79_register_usb();
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(ubnt_rs_leds_gpio),
+				 ubnt_rs_leds_gpio);
+}
+
+MIPS_MACHINE(ATH79_MACH_UBNT_RS, "UBNT-RS", "Ubiquiti RouterStation",
+	     ubnt_rs_setup);
+
+#define UBNT_RSPRO_WAN_PHYMASK	BIT(4)
+#define UBNT_RSPRO_LAN_PHYMASK	(BIT(0) | BIT(1) | BIT(2) | BIT(3))
+
+static void __init ubnt_rspro_setup(void)
+{
+	ubnt_generic_setup();
+
+	ath79_register_mdio(0, ~(UBNT_RSPRO_WAN_PHYMASK |
+				 UBNT_RSPRO_LAN_PHYMASK));
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, ath79_mac_base, 0);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.phy_mask = UBNT_RSPRO_WAN_PHYMASK;
+
+	/*
+	 * There is Secondary MAC address duplicate problem with some
+	 * UBNT HW batches.  Do not increase Secondary MAC address by 1
+	 * but do workaround with 'Locally Administrated' bit.
+	 */
+	ath79_init_local_mac(ath79_eth1_data.mac_addr, ath79_mac_base);
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth1_data.phy_mask = UBNT_RSPRO_LAN_PHYMASK;
+	ath79_eth1_data.speed = SPEED_1000;
+	ath79_eth1_data.duplex = DUPLEX_FULL;
+
+	ath79_register_eth(0);
+	ath79_register_eth(1);
+
+	ath79_register_usb();
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(ubnt_rs_leds_gpio),
+				 ubnt_rs_leds_gpio);
+}
+
+MIPS_MACHINE(ATH79_MACH_UBNT_RSPRO, "UBNT-RSPRO", "Ubiquiti RouterStation Pro",
+	     ubnt_rspro_setup);
+
+static void __init ubnt_lsx_setup(void)
+{
+	ubnt_generic_setup();
+}
+
+MIPS_MACHINE(ATH79_MACH_UBNT_LSX, "UBNT-LSX", "Ubiquiti LSX", ubnt_lsx_setup);
+
+#define UBNT_LSSR71_PHY_MASK	BIT(1)
+
+static void __init ubnt_lssr71_setup(void)
+{
+	ubnt_generic_setup();
+
+	ath79_register_mdio(0, ~UBNT_LSSR71_PHY_MASK);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, ath79_mac_base, 0);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ath79_eth0_data.phy_mask = UBNT_LSSR71_PHY_MASK;
+
+	ath79_register_eth(0);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(ubnt_ls_sr71_leds_gpio),
+				 ubnt_ls_sr71_leds_gpio);
+}
+
+MIPS_MACHINE(ATH79_MACH_UBNT_LSSR71, "UBNT-LS-SR71", "Ubiquiti LS-SR71",
+	     ubnt_lssr71_setup);
diff --git a/arch/mips/ath79/mach-whr-hp-g300n.c b/arch/mips/ath79/mach-whr-hp-g300n.c
new file mode 100644
index 0000000..48f49ad
--- /dev/null
+++ b/arch/mips/ath79/mach-whr-hp-g300n.c
@@ -0,0 +1,155 @@
+/*
+ *  Buffalo WHR-HP-G300N board support
+ *
+ *  based on ...
+ *
+ *  TP-LINK TL-WR741ND board support
+ *
+ *  Copyright (C) 2009-2010 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-ap9x-pci.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "machtypes.h"
+
+#define WHRHPG300N_GPIO_LED_SECURITY		0
+#define WHRHPG300N_GPIO_LED_DIAG		1
+#define WHRHPG300N_GPIO_LED_ROUTER		6
+
+#define WHRHPG300N_GPIO_BTN_ROUTER_ON		7
+#define WHRHPG300N_GPIO_BTN_ROUTER_AUTO		8
+#define WHRHPG300N_GPIO_BTN_RESET		11
+#define WHRHPG300N_GPIO_BTN_AOSS		12
+#define WHRHPG300N_GPIO_LED_LAN1		13
+#define WHRHPG300N_GPIO_LED_LAN2		14
+#define WHRHPG300N_GPIO_LED_LAN3		15
+#define WHRHPG300N_GPIO_LED_LAN4		16
+#define WHRHPG300N_GPIO_LED_WAN			17
+
+#define	WHRHPG300N_KEYS_POLL_INTERVAL	20	/* msecs */
+#define WHRHPG300N_KEYS_DEBOUNCE_INTERVAL (3 * WHRHPG300N_KEYS_POLL_INTERVAL)
+
+#define WHRHPG300N_MAC_OFFSET		0x20c
+
+static struct gpio_led whrhpg300n_leds_gpio[] __initdata = {
+	{
+		.name		= "buffalo:orange:security",
+		.gpio		= WHRHPG300N_GPIO_LED_SECURITY,
+		.active_low	= 1,
+	}, {
+		.name		= "buffalo:red:diag",
+		.gpio		= WHRHPG300N_GPIO_LED_DIAG,
+		.active_low	= 1,
+	}, {
+		.name		= "buffalo:green:router",
+		.gpio		= WHRHPG300N_GPIO_LED_ROUTER,
+		.active_low	= 1,
+	}, {
+		.name		= "buffalo:green:wan",
+		.gpio		= WHRHPG300N_GPIO_LED_WAN,
+		.active_low	= 1,
+	}, {
+		.name		= "buffalo:green:lan1",
+		.gpio		= WHRHPG300N_GPIO_LED_LAN1,
+		.active_low	= 1,
+	}, {
+		.name		= "buffalo:green:lan2",
+		.gpio		= WHRHPG300N_GPIO_LED_LAN2,
+		.active_low	= 1,
+	}, {
+		.name		= "buffalo:green:lan3",
+		.gpio		= WHRHPG300N_GPIO_LED_LAN3,
+		.active_low	= 1,
+	}, {
+		.name		= "buffalo:green:lan4",
+		.gpio		= WHRHPG300N_GPIO_LED_LAN4,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button whrhpg300n_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = WHRHPG300N_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= WHRHPG300N_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}, {
+		.desc		= "aoss/wps",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.gpio		= WHRHPG300N_GPIO_BTN_AOSS,
+		.debounce_interval = WHRHPG300N_KEYS_DEBOUNCE_INTERVAL,
+		.active_low	= 1,
+	}, {
+		.desc		= "router_on",
+		.type		= EV_KEY,
+		.code		= BTN_2,
+		.gpio		= WHRHPG300N_GPIO_BTN_ROUTER_ON,
+		.debounce_interval = WHRHPG300N_KEYS_DEBOUNCE_INTERVAL,
+		.active_low	= 1,
+	}, {
+		.desc		= "router_auto",
+		.type		= EV_KEY,
+		.code		= BTN_3,
+		.gpio		= WHRHPG300N_GPIO_BTN_ROUTER_AUTO,
+		.debounce_interval = WHRHPG300N_KEYS_DEBOUNCE_INTERVAL,
+		.active_low	= 1,
+	}
+};
+
+static void __init whrhpg300n_setup(void)
+{
+	u8 *ee = (u8 *) KSEG1ADDR(0x1fff1000);
+	u8 *mac = (u8 *) KSEG1ADDR(ee + WHRHPG300N_MAC_OFFSET);
+
+	ath79_register_m25p80(NULL);
+
+	ath79_gpio_function_disable(AR724X_GPIO_FUNC_ETH_SWITCH_LED0_EN |
+				    AR724X_GPIO_FUNC_ETH_SWITCH_LED1_EN |
+				    AR724X_GPIO_FUNC_ETH_SWITCH_LED2_EN |
+				    AR724X_GPIO_FUNC_ETH_SWITCH_LED3_EN |
+				    AR724X_GPIO_FUNC_ETH_SWITCH_LED4_EN);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(whrhpg300n_leds_gpio),
+				 whrhpg300n_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, WHRHPG300N_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(whrhpg300n_gpio_keys),
+					whrhpg300n_gpio_keys);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 0);
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac, 1);
+
+	ath79_register_mdio(0, 0x0);
+
+	/* LAN ports */
+	ath79_register_eth(1);
+	/* WAN port */
+	ath79_register_eth(0);
+
+	ap9x_pci_setup_wmac_led_pin(0, 1);
+
+	ap91_pci_init(ee, mac);
+}
+
+MIPS_MACHINE(ATH79_MACH_WHR_HP_G300N, "WHR-HP-G300N", "Buffalo WHR-HP-G300N",
+	     whrhpg300n_setup);
+
+MIPS_MACHINE(ATH79_MACH_WHR_G301N, "WHR-G301N", "Buffalo WHR-G301N",
+	     whrhpg300n_setup);
+
+MIPS_MACHINE(ATH79_MACH_WHR_HP_GN, "WHR-HP-GN", "Buffalo WHR-HP-GN",
+	     whrhpg300n_setup);
diff --git a/arch/mips/ath79/mach-wndr3700.c b/arch/mips/ath79/mach-wndr3700.c
new file mode 100644
index 0000000..fccf1c6
--- /dev/null
+++ b/arch/mips/ath79/mach-wndr3700.c
@@ -0,0 +1,172 @@
+/*
+ *  Netgear WNDR3700 board support
+ *
+ *  Copyright (C) 2009 Marco Porsch
+ *  Copyright (C) 2009-2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/platform_device.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <linux/delay.h>
+#include <linux/rtl8366.h>
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-ap9x-pci.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "machtypes.h"
+
+#define WNDR3700_GPIO_LED_WPS_ORANGE	0
+#define WNDR3700_GPIO_LED_POWER_ORANGE	1
+#define WNDR3700_GPIO_LED_POWER_GREEN	2
+#define WNDR3700_GPIO_LED_WPS_GREEN	4
+#define WNDR3700_GPIO_LED_WAN_GREEN	6
+
+#define WNDR3700_GPIO_BTN_WPS		3
+#define WNDR3700_GPIO_BTN_RESET		8
+#define WNDR3700_GPIO_BTN_WIFI		11
+
+#define WNDR3700_GPIO_RTL8366_SDA	5
+#define WNDR3700_GPIO_RTL8366_SCK	7
+
+#define WNDR3700_KEYS_POLL_INTERVAL	20	/* msecs */
+#define WNDR3700_KEYS_DEBOUNCE_INTERVAL (3 * WNDR3700_KEYS_POLL_INTERVAL)
+
+#define WNDR3700_ETH0_MAC_OFFSET	0
+#define WNDR3700_ETH1_MAC_OFFSET	0x6
+
+#define WNDR3700_WMAC0_MAC_OFFSET	0
+#define WNDR3700_WMAC1_MAC_OFFSET	0xc
+#define WNDR3700_CALDATA0_OFFSET	0x1000
+#define WNDR3700_CALDATA1_OFFSET	0x5000
+
+static struct gpio_led wndr3700_leds_gpio[] __initdata = {
+	{
+		.name		= "wndr3700:green:power",
+		.gpio		= WNDR3700_GPIO_LED_POWER_GREEN,
+		.active_low	= 1,
+	}, {
+		.name		= "wndr3700:orange:power",
+		.gpio		= WNDR3700_GPIO_LED_POWER_ORANGE,
+		.active_low	= 1,
+	}, {
+		.name		= "wndr3700:green:wps",
+		.gpio		= WNDR3700_GPIO_LED_WPS_GREEN,
+		.active_low	= 1,
+	}, {
+		.name		= "wndr3700:orange:wps",
+		.gpio		= WNDR3700_GPIO_LED_WPS_ORANGE,
+		.active_low	= 1,
+	}, {
+		.name		= "wndr3700:green:wan",
+		.gpio		= WNDR3700_GPIO_LED_WAN_GREEN,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button wndr3700_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = WNDR3700_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= WNDR3700_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}, {
+		.desc		= "wps",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = WNDR3700_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= WNDR3700_GPIO_BTN_WPS,
+		.active_low	= 1,
+	}, {
+		.desc		= "wifi",
+		.type		= EV_KEY,
+		.code		= BTN_2,
+		.debounce_interval = WNDR3700_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= WNDR3700_GPIO_BTN_WIFI,
+		.active_low	= 1,
+	}
+};
+
+static struct rtl8366_platform_data wndr3700_rtl8366s_data = {
+	.gpio_sda	= WNDR3700_GPIO_RTL8366_SDA,
+	.gpio_sck	= WNDR3700_GPIO_RTL8366_SCK,
+};
+
+static struct platform_device wndr3700_rtl8366s_device = {
+	.name		= RTL8366S_DRIVER_NAME,
+	.id		= -1,
+	.dev = {
+		.platform_data	= &wndr3700_rtl8366s_data,
+	}
+};
+
+static void __init wndr3700_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+
+	/*
+	 * The eth0 and wmac0 interfaces share the same MAC address which
+	 * can lead to problems if operated unbridged. Set the locally
+	 * administered bit on the eth0 MAC to make it unique.
+	 */
+	ath79_init_local_mac(ath79_eth0_data.mac_addr,
+			     art + WNDR3700_ETH0_MAC_OFFSET);
+	ath79_eth0_pll_data.pll_1000 = 0x11110000;
+	ath79_eth0_data.mii_bus_dev = &wndr3700_rtl8366s_device.dev;
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.speed = SPEED_1000;
+	ath79_eth0_data.duplex = DUPLEX_FULL;
+
+	ath79_init_mac(ath79_eth1_data.mac_addr,
+			art + WNDR3700_ETH1_MAC_OFFSET, 0);
+	ath79_eth1_pll_data.pll_1000 = 0x11110000;
+	ath79_eth1_data.mii_bus_dev = &wndr3700_rtl8366s_device.dev;
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth1_data.phy_mask = 0x10;
+
+	ath79_register_eth(0);
+	ath79_register_eth(1);
+
+	ath79_register_usb();
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(wndr3700_leds_gpio),
+				 wndr3700_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, WNDR3700_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(wndr3700_gpio_keys),
+					wndr3700_gpio_keys);
+
+	platform_device_register(&wndr3700_rtl8366s_device);
+	platform_device_register_simple("wndr3700-led-usb", -1, NULL, 0);
+
+	ap9x_pci_setup_wmac_led_pin(0, 5);
+	ap9x_pci_setup_wmac_led_pin(1, 5);
+
+	/* 2.4 GHz uses the first fixed antenna group (1, 0, 1, 0) */
+	ap9x_pci_setup_wmac_gpio(0, (0xf << 6), (0xa << 6));
+
+	/* 5 GHz uses the second fixed antenna group (0, 1, 1, 0) */
+	ap9x_pci_setup_wmac_gpio(1, (0xf << 6), (0x6 << 6));
+
+	ap94_pci_init(art + WNDR3700_CALDATA0_OFFSET,
+		      art + WNDR3700_WMAC0_MAC_OFFSET,
+		      art + WNDR3700_CALDATA1_OFFSET,
+		      art + WNDR3700_WMAC1_MAC_OFFSET);
+}
+
+MIPS_MACHINE(ATH79_MACH_WNDR3700, "WNDR3700",
+	     "NETGEAR WNDR3700/WNDR3800/WNDRMAC",
+	     wndr3700_setup);
diff --git a/arch/mips/ath79/mach-wnr2000.c b/arch/mips/ath79/mach-wnr2000.c
new file mode 100644
index 0000000..bd86db3
--- /dev/null
+++ b/arch/mips/ath79/mach-wnr2000.c
@@ -0,0 +1,145 @@
+/*
+ *  NETGEAR WNR2000 board support
+ *
+ *  Copyright (C) 2008-2009 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *  Copyright (C) 2008-2009 Andy Boyett <agb@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define WNR2000_GPIO_LED_PWR_GREEN	14
+#define WNR2000_GPIO_LED_PWR_AMBER	7
+#define WNR2000_GPIO_LED_WPS		4
+#define WNR2000_GPIO_LED_WLAN		6
+#define WNR2000_GPIO_BTN_RESET		21
+#define WNR2000_GPIO_BTN_WPS		8
+
+#define WNR2000_KEYS_POLL_INTERVAL	20	/* msecs */
+#define WNR2000_KEYS_DEBOUNCE_INTERVAL	(3 * WNR2000_KEYS_POLL_INTERVAL)
+
+static struct mtd_partition wnr2000_partitions[] = {
+	{
+		.name		= "u-boot",
+		.offset		= 0,
+		.size		= 0x040000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "u-boot-env",
+		.offset		= 0x040000,
+		.size		= 0x010000,
+	}, {
+		.name		= "rootfs",
+		.offset		= 0x050000,
+		.size		= 0x240000,
+	}, {
+		.name		= "user-config",
+		.offset		= 0x290000,
+		.size		= 0x010000,
+	}, {
+		.name		= "uImage",
+		.offset		= 0x2a0000,
+		.size		= 0x120000,
+	}, {
+		.name		= "language_table",
+		.offset		= 0x3c0000,
+		.size		= 0x020000,
+	}, {
+		.name		= "rootfs_checksum",
+		.offset		= 0x3e0000,
+		.size		= 0x010000,
+	}, {
+		.name		= "art",
+		.offset		= 0x3f0000,
+		.size		= 0x010000,
+		.mask_flags	= MTD_WRITEABLE,
+	}
+};
+
+static struct flash_platform_data wnr2000_flash_data = {
+	.parts		= wnr2000_partitions,
+	.nr_parts	= ARRAY_SIZE(wnr2000_partitions),
+};
+
+static struct gpio_led wnr2000_leds_gpio[] __initdata = {
+	{
+		.name		= "wnr2000:green:power",
+		.gpio		= WNR2000_GPIO_LED_PWR_GREEN,
+		.active_low	= 1,
+	}, {
+		.name		= "wnr2000:amber:power",
+		.gpio		= WNR2000_GPIO_LED_PWR_AMBER,
+		.active_low	= 1,
+	}, {
+		.name		= "wnr2000:green:wps",
+		.gpio		= WNR2000_GPIO_LED_WPS,
+		.active_low	= 1,
+	}, {
+		.name		= "wnr2000:blue:wlan",
+		.gpio		= WNR2000_GPIO_LED_WLAN,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button wnr2000_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = WNR2000_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= WNR2000_GPIO_BTN_RESET,
+	}, {
+		.desc		= "wps",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = WNR2000_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= WNR2000_GPIO_BTN_WPS,
+	}
+};
+
+static void __init wnr2000_setup(void)
+{
+	u8 *eeprom = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	ath79_register_mdio(0, 0x0);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, eeprom, 0);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ath79_eth0_data.speed = SPEED_100;
+	ath79_eth0_data.duplex = DUPLEX_FULL;
+	ath79_eth0_data.has_ar8216 = 1;
+
+	ath79_init_mac(ath79_eth1_data.mac_addr, eeprom, 1);
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ath79_eth1_data.phy_mask = 0x10;
+
+	ath79_register_eth(0);
+	ath79_register_eth(1);
+
+	ath79_register_m25p80(&wnr2000_flash_data);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(wnr2000_leds_gpio),
+				 wnr2000_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, WNR2000_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(wnr2000_gpio_keys),
+					wnr2000_gpio_keys);
+
+	ath79_register_wmac(eeprom, NULL);
+}
+
+MIPS_MACHINE(ATH79_MACH_WNR2000, "WNR2000", "NETGEAR WNR2000", wnr2000_setup);
diff --git a/arch/mips/ath79/mach-wp543.c b/arch/mips/ath79/mach-wp543.c
new file mode 100644
index 0000000..148cd7c
--- /dev/null
+++ b/arch/mips/ath79/mach-wp543.c
@@ -0,0 +1,107 @@
+/*
+ *  Compex WP543/WPJ543 board support
+ *
+ *  Copyright (C) 2008-2012 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "machtypes.h"
+#include "pci.h"
+
+#define WP543_GPIO_SW6		2
+#define WP543_GPIO_LED_1	3
+#define WP543_GPIO_LED_2	4
+#define WP543_GPIO_LED_WLAN	5
+#define WP543_GPIO_LED_CONN	6
+#define WP543_GPIO_LED_DIAG	7
+#define WP543_GPIO_SW4		8
+
+#define WP543_KEYS_POLL_INTERVAL	20	/* msecs */
+#define WP543_KEYS_DEBOUNCE_INTERVAL	(3 * WP543_KEYS_POLL_INTERVAL)
+
+static struct gpio_led wp543_leds_gpio[] __initdata = {
+	{
+		.name		= "wp543:green:led1",
+		.gpio		= WP543_GPIO_LED_1,
+		.active_low	= 1,
+	}, {
+		.name		= "wp543:green:led2",
+		.gpio		= WP543_GPIO_LED_2,
+		.active_low	= 1,
+	}, {
+		.name		= "wp543:green:wlan",
+		.gpio		= WP543_GPIO_LED_WLAN,
+		.active_low	= 1,
+	}, {
+		.name		= "wp543:green:conn",
+		.gpio		= WP543_GPIO_LED_CONN,
+		.active_low	= 1,
+	}, {
+		.name		= "wp543:green:diag",
+		.gpio		= WP543_GPIO_LED_DIAG,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button wp543_gpio_keys[] __initdata = {
+	{
+		.desc		= "sw6",
+		.type		= EV_KEY,
+		.code		= BTN_0,
+		.debounce_interval = WP543_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= WP543_GPIO_SW6,
+	}, {
+		.desc		= "sw4",
+		.type		= EV_KEY,
+		.code		= BTN_1,
+		.debounce_interval = WP543_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= WP543_GPIO_SW4,
+	}
+};
+
+static const char *wp543_part_probes[] = {
+	"MyLoader",
+	NULL,
+};
+
+static struct flash_platform_data wp543_flash_data = {
+	.part_probes	= wp543_part_probes,
+};
+
+static void __init wp543_setup(void)
+{
+	ath79_register_m25p80(&wp543_flash_data);
+
+	ath79_register_mdio(0, 0xfffffff0);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, ath79_mac_base, 0);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ath79_eth0_data.phy_mask = 0x0f;
+	ath79_eth0_data.reset_bit = AR71XX_RESET_GE0_MAC |
+				    AR71XX_RESET_GE0_PHY;
+	ath79_register_eth(0);
+
+	ath79_register_usb();
+	ath79_register_pci();
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(wp543_leds_gpio),
+					wp543_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, WP543_KEYS_POLL_INTERVAL,
+					 ARRAY_SIZE(wp543_gpio_keys),
+					 wp543_gpio_keys);
+}
+
+MIPS_MACHINE(ATH79_MACH_WP543, "WP543", "Compex WP543", wp543_setup);
diff --git a/arch/mips/ath79/mach-wpe72.c b/arch/mips/ath79/mach-wpe72.c
new file mode 100644
index 0000000..114d623
--- /dev/null
+++ b/arch/mips/ath79/mach-wpe72.c
@@ -0,0 +1,96 @@
+/*
+ *  Compex WPE72 board support
+ *
+ *  Copyright (C) 2012 Johnathan Boyce<jon.boyce@globalreach.eu.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include<asm/mach-ath79/ath79.h>
+
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "machtypes.h"
+#include "pci.h"
+
+#define WPE72_GPIO_RESET	12
+#define WPE72_GPIO_LED_DIAG	13
+#define WPE72_GPIO_LED_1	14
+#define WPE72_GPIO_LED_2	15
+#define WPE72_GPIO_LED_3	16
+#define WPE72_GPIO_LED_4	17
+
+#define WPE72_KEYS_POLL_INTERVAL	20	/* msecs */
+#define WPE72_KEYS_DEBOUNCE_INTERVAL	(3 * WPE72_KEYS_POLL_INTERVAL)
+
+static struct gpio_led wpe72_leds_gpio[] __initdata = {
+	{
+		.name		= "wpe72:green:led1",
+		.gpio		= WPE72_GPIO_LED_1,
+		.active_low	= 1,
+	}, {
+		.name		= "wpe72:green:led2",
+		.gpio		= WPE72_GPIO_LED_2,
+		.active_low	= 1,
+	}, {
+		.name		= "wpe72:green:led3",
+		.gpio		= WPE72_GPIO_LED_3,
+		.active_low	= 1,
+	}, {
+		.name		= "wpe72:green:led4",
+		.gpio		= WPE72_GPIO_LED_4,
+		.active_low	= 1,
+	}, {
+		.name		= "wpe72:green:diag",
+		.gpio		= WPE72_GPIO_LED_DIAG,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button wpe72_gpio_keys[] __initdata = {
+	{
+		.desc           = "reset",
+		.type           = EV_KEY,
+		.code           = KEY_RESTART,
+		.debounce_interval = WPE72_KEYS_DEBOUNCE_INTERVAL,
+		.gpio           = WPE72_GPIO_RESET,
+	}
+};
+
+static const char *wpe72_part_probes[] = {
+	"MyLoader",
+	NULL,
+};
+
+static struct flash_platform_data wpe72_flash_data = {
+	.part_probes	= wpe72_part_probes,
+};
+
+static void __init wpe72_setup(void)
+{
+	ath79_register_m25p80(&wpe72_flash_data);
+	ath79_register_mdio(0, 0x0);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, ath79_mac_base, 0);
+	ath79_init_mac(ath79_eth1_data.mac_addr, ath79_mac_base, 1);
+
+	ath79_register_eth(0);
+	ath79_register_eth(1);
+
+	ath79_register_usb();
+	ath79_register_pci();
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(wpe72_leds_gpio),
+				 wpe72_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, WPE72_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(wpe72_gpio_keys),
+					wpe72_gpio_keys);
+}
+
+MIPS_MACHINE(ATH79_MACH_WPE72, "WPE72", "Compex WPE72", wpe72_setup);
diff --git a/arch/mips/ath79/mach-wrt160nl.c b/arch/mips/ath79/mach-wrt160nl.c
new file mode 100644
index 0000000..21aefe0
--- /dev/null
+++ b/arch/mips/ath79/mach-wrt160nl.c
@@ -0,0 +1,126 @@
+/*
+ *  Linksys WRT160NL board support
+ *
+ *  Copyright (C) 2009-2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "nvram.h"
+#include "machtypes.h"
+
+#define WRT160NL_GPIO_LED_POWER		14
+#define WRT160NL_GPIO_LED_WPS_AMBER	9
+#define WRT160NL_GPIO_LED_WPS_BLUE	8
+#define WRT160NL_GPIO_LED_WLAN		6
+
+#define WRT160NL_GPIO_BTN_WPS		7
+#define WRT160NL_GPIO_BTN_RESET		21
+
+#define WRT160NL_KEYS_POLL_INTERVAL	20	/* msecs */
+#define WRT160NL_KEYS_DEBOUNCE_INTERVAL	(3 * WRT160NL_KEYS_POLL_INTERVAL)
+
+#define WRT160NL_NVRAM_ADDR	0x1f7e0000
+#define WRT160NL_NVRAM_SIZE	0x10000
+
+static const char *wrt160nl_part_probes[] = {
+	"wrt160nl",
+	NULL,
+};
+
+static struct flash_platform_data wrt160nl_flash_data = {
+	.part_probes	= wrt160nl_part_probes,
+};
+
+static struct gpio_led wrt160nl_leds_gpio[] __initdata = {
+	{
+		.name		= "wrt160nl:blue:power",
+		.gpio		= WRT160NL_GPIO_LED_POWER,
+		.active_low	= 1,
+		.default_trigger = "default-on",
+	}, {
+		.name		= "wrt160nl:amber:wps",
+		.gpio		= WRT160NL_GPIO_LED_WPS_AMBER,
+		.active_low	= 1,
+	}, {
+		.name		= "wrt160nl:blue:wps",
+		.gpio		= WRT160NL_GPIO_LED_WPS_BLUE,
+		.active_low	= 1,
+	}, {
+		.name		= "wrt160nl:blue:wlan",
+		.gpio		= WRT160NL_GPIO_LED_WLAN,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button wrt160nl_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = WRT160NL_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= WRT160NL_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}, {
+		.desc		= "wps",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = WRT160NL_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= WRT160NL_GPIO_BTN_WPS,
+		.active_low	= 1,
+	}
+};
+
+static void __init wrt160nl_setup(void)
+{
+	const char *nvram = (char *) KSEG1ADDR(WRT160NL_NVRAM_ADDR);
+	u8 *eeprom = (u8 *) KSEG1ADDR(0x1fff1000);
+	u8 mac[6];
+
+	if (ath79_nvram_parse_mac_addr(nvram, WRT160NL_NVRAM_SIZE,
+				       "lan_hwaddr=", mac) == 0) {
+		ath79_init_mac(ath79_eth0_data.mac_addr, mac, 0);
+		ath79_init_mac(ath79_eth1_data.mac_addr, mac, 1);
+	}
+
+	ath79_register_mdio(0, 0x0);
+
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ath79_eth0_data.phy_mask = 0x01;
+
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ath79_eth1_data.phy_mask = 0x10;
+
+	ath79_register_eth(0);
+	ath79_register_eth(1);
+
+	ath79_register_m25p80(&wrt160nl_flash_data);
+
+	ath79_register_usb();
+
+	if (ath79_nvram_parse_mac_addr(nvram, WRT160NL_NVRAM_SIZE,
+				       "wl0_hwaddr=", mac) == 0)
+		ath79_register_wmac(eeprom, mac);
+	else
+		ath79_register_wmac(eeprom, NULL);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(wrt160nl_leds_gpio),
+				 wrt160nl_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, WRT160NL_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(wrt160nl_gpio_keys),
+					wrt160nl_gpio_keys);
+}
+
+MIPS_MACHINE(ATH79_MACH_WRT160NL, "WRT160NL", "Linksys WRT160NL",
+	     wrt160nl_setup);
diff --git a/arch/mips/ath79/mach-wrt400n.c b/arch/mips/ath79/mach-wrt400n.c
new file mode 100644
index 0000000..6c4c1cb
--- /dev/null
+++ b/arch/mips/ath79/mach-wrt400n.c
@@ -0,0 +1,161 @@
+/*
+ *  Linksys WRT400N board support
+ *
+ *  Copyright (C) 2009-2012 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2009 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-ap9x-pci.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "machtypes.h"
+
+#define WRT400N_GPIO_LED_POWER		1
+#define WRT400N_GPIO_LED_WPS_BLUE	4
+#define WRT400N_GPIO_LED_WPS_AMBER	5
+#define WRT400N_GPIO_LED_WLAN		6
+
+#define WRT400N_GPIO_BTN_RESET		8
+#define WRT400N_GPIO_BTN_WLSEC		3
+
+#define WRT400N_KEYS_POLL_INTERVAL	20	/* msecs */
+#define WRT400N_KEYS_DEBOUNE_INTERVAL	(3 * WRT400N_KEYS_POLL_INTERVAL)
+
+#define WRT400N_MAC_ADDR_OFFSET		0x120c
+#define WRT400N_CALDATA0_OFFSET		0x1000
+#define WRT400N_CALDATA1_OFFSET		0x5000
+
+static struct mtd_partition wrt400n_partitions[] = {
+	{
+		.name		= "uboot",
+		.offset		= 0,
+		.size		= 0x030000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "env",
+		.offset		= 0x030000,
+		.size		= 0x010000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "linux",
+		.offset		= 0x040000,
+		.size		= 0x140000,
+	}, {
+		.name		= "rootfs",
+		.offset		= 0x180000,
+		.size		= 0x630000,
+	}, {
+		.name		= "nvram",
+		.offset		= 0x7b0000,
+		.size		= 0x010000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "factory",
+		.offset		= 0x7c0000,
+		.size		= 0x010000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "language",
+		.offset		= 0x7d0000,
+		.size		= 0x020000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "caldata",
+		.offset		= 0x7f0000,
+		.size		= 0x010000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "firmware",
+		.offset		= 0x040000,
+		.size		= 0x770000,
+	}
+};
+
+static struct flash_platform_data wrt400n_flash_data = {
+	.parts		= wrt400n_partitions,
+	.nr_parts	= ARRAY_SIZE(wrt400n_partitions),
+};
+
+static struct gpio_led wrt400n_leds_gpio[] __initdata = {
+	{
+		.name		= "wrt400n:blue:wps",
+		.gpio		= WRT400N_GPIO_LED_WPS_BLUE,
+		.active_low	= 1,
+	}, {
+		.name		= "wrt400n:amber:wps",
+		.gpio		= WRT400N_GPIO_LED_WPS_AMBER,
+		.active_low	= 1,
+	}, {
+		.name		= "wrt400n:blue:wlan",
+		.gpio		= WRT400N_GPIO_LED_WLAN,
+		.active_low	= 1,
+	}, {
+		.name		= "wrt400n:blue:power",
+		.gpio		= WRT400N_GPIO_LED_POWER,
+		.active_low	= 0,
+		.default_trigger = "default-on",
+	}
+};
+
+static struct gpio_keys_button wrt400n_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = WRT400N_KEYS_DEBOUNE_INTERVAL,
+		.gpio		= WRT400N_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}, {
+		.desc		= "wlsec",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = WRT400N_KEYS_DEBOUNE_INTERVAL,
+		.gpio		= WRT400N_GPIO_BTN_WLSEC,
+		.active_low	= 1,
+	}
+};
+
+static void __init wrt400n_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+	u8 *mac = art + WRT400N_MAC_ADDR_OFFSET;
+
+	ath79_register_mdio(0, 0x0);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 1);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ath79_eth0_data.speed = SPEED_100;
+	ath79_eth0_data.duplex = DUPLEX_FULL;
+
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac, 2);
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ath79_eth1_data.phy_mask = 0x10;
+
+	ath79_register_eth(0);
+	ath79_register_eth(1);
+
+	ath79_register_m25p80(&wrt400n_flash_data);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(wrt400n_leds_gpio),
+				 wrt400n_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, WRT400N_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(wrt400n_gpio_keys),
+					wrt400n_gpio_keys);
+
+	ap94_pci_init(art + WRT400N_CALDATA0_OFFSET, NULL,
+		      art + WRT400N_CALDATA1_OFFSET, NULL);
+}
+
+MIPS_MACHINE(ATH79_MACH_WRT400N, "WRT400N", "Linksys WRT400N", wrt400n_setup);
diff --git a/arch/mips/ath79/mach-wzr-hp-ag300h.c b/arch/mips/ath79/mach-wzr-hp-ag300h.c
new file mode 100644
index 0000000..66e933f
--- /dev/null
+++ b/arch/mips/ath79/mach-wzr-hp-ag300h.c
@@ -0,0 +1,156 @@
+/*
+ *  Buffalo WZR-HP-AG300H board support
+ *
+ *  Copyright (C) 2011 Felix Fietkau <nbd@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/gpio.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-eth.h"
+#include "dev-ap9x-pci.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "machtypes.h"
+
+#define WZRHPAG300H_MAC_OFFSET		0x20c
+#define WZRHPAG300H_KEYS_POLL_INTERVAL	20      /* msecs */
+#define WZRHPAG300H_KEYS_DEBOUNCE_INTERVAL (3 * WZRHPAG300H_KEYS_POLL_INTERVAL)
+
+static struct mtd_partition wzrhpag300h_flash_partitions[] = {
+	{
+		.name		= "u-boot",
+		.offset		= 0,
+		.size		= 0x0040000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "u-boot-env",
+		.offset		= 0x0040000,
+		.size		= 0x0010000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "art",
+		.offset		= 0x0050000,
+		.size		= 0x0010000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "kernel",
+		.offset		= 0x0060000,
+		.size		= 0x0100000,
+	}, {
+		.name		= "rootfs",
+		.offset		= 0x0160000,
+		.size		= 0x1e90000,
+	}, {
+		.name		= "user_property",
+		.offset		= 0x1ff0000,
+		.size		= 0x0010000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "firmware",
+		.offset		= 0x0060000,
+		.size		= 0x1f90000,
+	}
+};
+
+static struct flash_platform_data wzrhpag300h_flash_data = {
+	.parts      = wzrhpag300h_flash_partitions,
+	.nr_parts   = ARRAY_SIZE(wzrhpag300h_flash_partitions),
+};
+
+static struct gpio_led wzrhpag300h_leds_gpio[] __initdata = {
+	{
+		.name		= "buffalo:red:diag",
+		.gpio		= 1,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button wzrhpag300h_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = WZRHPAG300H_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= 11,
+		.active_low	= 1,
+	}, {
+		.desc		= "usb",
+		.type		= EV_KEY,
+		.code		= BTN_2,
+		.debounce_interval = WZRHPAG300H_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= 3,
+		.active_low	= 1,
+	}, {
+		.desc		= "aoss",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = WZRHPAG300H_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= 5,
+		.active_low	= 1,
+	}, {
+		.desc		= "router_auto",
+		.type		= EV_KEY,
+		.code		= BTN_6,
+		.debounce_interval = WZRHPAG300H_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= 6,
+		.active_low	= 1,
+	}, {
+		.desc		= "router_off",
+		.type		= EV_KEY,
+		.code		= BTN_5,
+		.debounce_interval = WZRHPAG300H_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= 7,
+		.active_low	= 1,
+	}
+};
+
+static void __init wzrhpag300h_setup(void)
+{
+	u8 *eeprom1 = (u8 *) KSEG1ADDR(0x1f051000);
+	u8 *eeprom2 = (u8 *) KSEG1ADDR(0x1f055000);
+	u8 *mac1 = eeprom1 + WZRHPAG300H_MAC_OFFSET;
+	u8 *mac2 = eeprom2 + WZRHPAG300H_MAC_OFFSET;
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac1, 0);
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac2, 1);
+
+	ath79_register_mdio(0, ~(BIT(0) | BIT(4)));
+
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.speed = SPEED_1000;
+	ath79_eth0_data.duplex = DUPLEX_FULL;
+	ath79_eth0_data.phy_mask = BIT(0);
+
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth1_data.phy_mask = BIT(4);
+
+	ath79_register_eth(0);
+	ath79_register_eth(1);
+
+	ath79_set_usb_power_gpio(2, GPIOF_OUT_INIT_HIGH, "USB power");
+	ath79_register_usb();
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(wzrhpag300h_leds_gpio),
+					wzrhpag300h_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, WZRHPAG300H_KEYS_POLL_INTERVAL,
+					 ARRAY_SIZE(wzrhpag300h_gpio_keys),
+					 wzrhpag300h_gpio_keys);
+
+	ath79_register_m25p80_multi(&wzrhpag300h_flash_data);
+
+	ap94_pci_init(eeprom1, mac1, eeprom2, mac2);
+}
+
+MIPS_MACHINE(ATH79_MACH_WZR_HP_AG300H, "WZR-HP-AG300H",
+	     "Buffalo WZR-HP-AG300H", wzrhpag300h_setup);
diff --git a/arch/mips/ath79/mach-wzr-hp-g300nh.c b/arch/mips/ath79/mach-wzr-hp-g300nh.c
new file mode 100644
index 0000000..94f352a
--- /dev/null
+++ b/arch/mips/ath79/mach-wzr-hp-g300nh.c
@@ -0,0 +1,287 @@
+/*
+ *  Buffalo WZR-HP-G300NH board support
+ *
+ *  Copyright (C) 2010-2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/platform_device.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <linux/mtd/physmap.h>
+#include <linux/nxp_74hc153.h>
+#include <linux/rtl8366.h>
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define WZRHPG300NH_GPIO_LED_USB	0
+#define WZRHPG300NH_GPIO_LED_DIAG	1
+#define WZRHPG300NH_GPIO_LED_WIRELESS	6
+#define WZRHPG300NH_GPIO_LED_SECURITY	17
+#define WZRHPG300NH_GPIO_LED_ROUTER	18
+
+#define WZRHPG300NH_GPIO_RTL8366_SDA	19
+#define WZRHPG300NH_GPIO_RTL8366_SCK	20
+
+#define WZRHPG300NH_GPIO_74HC153_S0	9
+#define WZRHPG300NH_GPIO_74HC153_S1	11
+#define WZRHPG300NH_GPIO_74HC153_1Y	12
+#define WZRHPG300NH_GPIO_74HC153_2Y	14
+
+#define WZRHPG300NH_GPIO_EXP_BASE	32
+#define WZRHPG300NH_GPIO_BTN_AOSS	(WZRHPG300NH_GPIO_EXP_BASE + 0)
+#define WZRHPG300NH_GPIO_BTN_RESET	(WZRHPG300NH_GPIO_EXP_BASE + 1)
+#define WZRHPG300NH_GPIO_BTN_ROUTER_ON	(WZRHPG300NH_GPIO_EXP_BASE + 2)
+#define WZRHPG300NH_GPIO_BTN_QOS_ON	(WZRHPG300NH_GPIO_EXP_BASE + 3)
+#define WZRHPG300NH_GPIO_BTN_USB	(WZRHPG300NH_GPIO_EXP_BASE + 5)
+#define WZRHPG300NH_GPIO_BTN_ROUTER_AUTO (WZRHPG300NH_GPIO_EXP_BASE + 6)
+#define WZRHPG300NH_GPIO_BTN_QOS_OFF	(WZRHPG300NH_GPIO_EXP_BASE + 7)
+
+#define WZRHPG300NH_KEYS_POLL_INTERVAL	20	/* msecs */
+#define WZRHPG300NH_KEYS_DEBOUNCE_INTERVAL (3 * WZRHPG300NH_KEYS_POLL_INTERVAL)
+
+#define WZRHPG300NH_MAC_OFFSET		0x20c
+
+static struct mtd_partition wzrhpg300nh_flash_partitions[] = {
+	{
+		.name		= "u-boot",
+		.offset		= 0,
+		.size		= 0x0040000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "u-boot-env",
+		.offset		= 0x0040000,
+		.size		= 0x0020000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "kernel",
+		.offset		= 0x0060000,
+		.size		= 0x0100000,
+	}, {
+		.name		= "rootfs",
+		.offset		= 0x0160000,
+		.size		= 0x1e60000,
+	}, {
+		.name		= "user_property",
+		.offset		= 0x1fc0000,
+		.size		= 0x0020000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "art",
+		.offset		= 0x1fe0000,
+		.size		= 0x0020000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "firmware",
+		.offset		= 0x0060000,
+		.size		= 0x1f60000,
+	}
+};
+
+static struct physmap_flash_data wzrhpg300nh_flash_data = {
+	.width		= 2,
+	.parts		= wzrhpg300nh_flash_partitions,
+	.nr_parts	= ARRAY_SIZE(wzrhpg300nh_flash_partitions),
+};
+
+#define WZRHPG300NH_FLASH_BASE	0x1e000000
+#define WZRHPG300NH_FLASH_SIZE	(32 * 1024 * 1024)
+
+static struct resource wzrhpg300nh_flash_resources[] = {
+	[0] = {
+		.start	= WZRHPG300NH_FLASH_BASE,
+		.end	= WZRHPG300NH_FLASH_BASE + WZRHPG300NH_FLASH_SIZE - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+};
+
+static struct platform_device wzrhpg300nh_flash_device = {
+	.name		= "physmap-flash",
+	.id		= -1,
+	.resource	= wzrhpg300nh_flash_resources,
+	.num_resources	= ARRAY_SIZE(wzrhpg300nh_flash_resources),
+	.dev		= {
+		.platform_data = &wzrhpg300nh_flash_data,
+	}
+};
+
+static struct gpio_led wzrhpg300nh_leds_gpio[] __initdata = {
+	{
+		.name		= "buffalo:orange:security",
+		.gpio		= WZRHPG300NH_GPIO_LED_SECURITY,
+		.active_low	= 1,
+	}, {
+		.name		= "buffalo:green:wireless",
+		.gpio		= WZRHPG300NH_GPIO_LED_WIRELESS,
+		.active_low	= 1,
+	}, {
+		.name		= "buffalo:green:router",
+		.gpio		= WZRHPG300NH_GPIO_LED_ROUTER,
+		.active_low	= 1,
+	}, {
+		.name		= "buffalo:red:diag",
+		.gpio		= WZRHPG300NH_GPIO_LED_DIAG,
+		.active_low	= 1,
+	}, {
+		.name		= "buffalo:blue:usb",
+		.gpio		= WZRHPG300NH_GPIO_LED_USB,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button wzrhpg300nh_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = WZRHPG300NH_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= WZRHPG300NH_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}, {
+		.desc		= "aoss",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = WZRHPG300NH_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= WZRHPG300NH_GPIO_BTN_AOSS,
+		.active_low	= 1,
+	}, {
+		.desc		= "usb",
+		.type		= EV_KEY,
+		.code		= BTN_2,
+		.debounce_interval = WZRHPG300NH_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= WZRHPG300NH_GPIO_BTN_USB,
+		.active_low	= 1,
+	}, {
+		.desc		= "qos_on",
+		.type		= EV_KEY,
+		.code		= BTN_3,
+		.debounce_interval = WZRHPG300NH_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= WZRHPG300NH_GPIO_BTN_QOS_ON,
+		.active_low	= 0,
+	}, {
+		.desc		= "qos_off",
+		.type		= EV_KEY,
+		.code		= BTN_4,
+		.debounce_interval = WZRHPG300NH_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= WZRHPG300NH_GPIO_BTN_QOS_OFF,
+		.active_low	= 0,
+	}, {
+		.desc		= "router_on",
+		.type		= EV_KEY,
+		.code		= BTN_5,
+		.debounce_interval = WZRHPG300NH_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= WZRHPG300NH_GPIO_BTN_ROUTER_ON,
+		.active_low	= 0,
+	}, {
+		.desc		= "router_auto",
+		.type		= EV_KEY,
+		.code		= BTN_6,
+		.debounce_interval = WZRHPG300NH_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= WZRHPG300NH_GPIO_BTN_ROUTER_AUTO,
+		.active_low	= 0,
+	}
+};
+
+static struct nxp_74hc153_platform_data wzrhpg300nh_74hc153_data = {
+	.gpio_base	= WZRHPG300NH_GPIO_EXP_BASE,
+	.gpio_pin_s0	= WZRHPG300NH_GPIO_74HC153_S0,
+	.gpio_pin_s1	= WZRHPG300NH_GPIO_74HC153_S1,
+	.gpio_pin_1y	= WZRHPG300NH_GPIO_74HC153_1Y,
+	.gpio_pin_2y	= WZRHPG300NH_GPIO_74HC153_2Y,
+};
+
+static struct platform_device wzrhpg300nh_74hc153_device = {
+	.name		= NXP_74HC153_DRIVER_NAME,
+	.id		= -1,
+	.dev = {
+		.platform_data	= &wzrhpg300nh_74hc153_data,
+	}
+};
+
+static struct rtl8366_platform_data wzrhpg300nh_rtl8366_data = {
+	.gpio_sda	= WZRHPG300NH_GPIO_RTL8366_SDA,
+	.gpio_sck	= WZRHPG300NH_GPIO_RTL8366_SCK,
+};
+
+static struct platform_device wzrhpg300nh_rtl8366s_device = {
+	.name		= RTL8366S_DRIVER_NAME,
+	.id		= -1,
+	.dev = {
+		.platform_data	= &wzrhpg300nh_rtl8366_data,
+	}
+};
+
+static struct platform_device wzrhpg300nh_rtl8366rb_device = {
+	.name           = RTL8366RB_DRIVER_NAME,
+	.id             = -1,
+	.dev = {
+		.platform_data  = &wzrhpg300nh_rtl8366_data,
+	}
+};
+
+static void __init wzrhpg300nh_setup(void)
+{
+	u8 *eeprom = (u8 *) KSEG1ADDR(0x1fff1000);
+	u8 *mac = eeprom + WZRHPG300NH_MAC_OFFSET;
+	bool hasrtl8366rb = false;
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 0);
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac, 1);
+
+	if (rtl8366_smi_detect(&wzrhpg300nh_rtl8366_data) == RTL8366_TYPE_RB)
+		hasrtl8366rb = true;
+
+	if (hasrtl8366rb) {
+		ath79_eth0_pll_data.pll_1000 = 0x1f000000;
+		ath79_eth0_data.mii_bus_dev = &wzrhpg300nh_rtl8366rb_device.dev;
+		ath79_eth1_pll_data.pll_1000 = 0x100;
+		ath79_eth1_data.mii_bus_dev = &wzrhpg300nh_rtl8366rb_device.dev;
+	} else {
+		ath79_eth0_pll_data.pll_1000 = 0x1e000100;
+		ath79_eth0_data.mii_bus_dev = &wzrhpg300nh_rtl8366s_device.dev;
+		ath79_eth1_pll_data.pll_1000 = 0x1e000100;
+		ath79_eth1_data.mii_bus_dev = &wzrhpg300nh_rtl8366s_device.dev;
+	}
+
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.speed = SPEED_1000;
+	ath79_eth0_data.duplex = DUPLEX_FULL;
+
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth1_data.phy_mask = 0x10;
+
+	ath79_register_eth(0);
+	ath79_register_eth(1);
+
+	ath79_register_usb();
+	ath79_register_wmac(eeprom, NULL);
+
+	platform_device_register(&wzrhpg300nh_74hc153_device);
+	platform_device_register(&wzrhpg300nh_flash_device);
+
+	if (hasrtl8366rb)
+		platform_device_register(&wzrhpg300nh_rtl8366rb_device);
+	else
+		platform_device_register(&wzrhpg300nh_rtl8366s_device);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(wzrhpg300nh_leds_gpio),
+					wzrhpg300nh_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, WZRHPG300NH_KEYS_POLL_INTERVAL,
+					 ARRAY_SIZE(wzrhpg300nh_gpio_keys),
+					 wzrhpg300nh_gpio_keys);
+
+}
+
+MIPS_MACHINE(ATH79_MACH_WZR_HP_G300NH, "WZR-HP-G300NH",
+	     "Buffalo WZR-HP-G300NH", wzrhpg300nh_setup);
diff --git a/arch/mips/ath79/mach-wzr-hp-g300nh2.c b/arch/mips/ath79/mach-wzr-hp-g300nh2.c
new file mode 100644
index 0000000..6c850ce
--- /dev/null
+++ b/arch/mips/ath79/mach-wzr-hp-g300nh2.c
@@ -0,0 +1,177 @@
+/*
+ *  Buffalo WZR-HP-G300NH2 board support
+ *
+ *  Copyright (C) 2011 Felix Fietkau <nbd@openwrt.org>
+ *  Copyright (C) 2011 Mark Deneen <mdeneen@gmail.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/gpio.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-ap9x-pci.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "machtypes.h"
+
+#define WZRHPG300NH2_MAC_OFFSET		0x20c
+#define WZRHPG300NH2_KEYS_POLL_INTERVAL     20      /* msecs */
+#define WZRHPG300NH2_KEYS_DEBOUNCE_INTERVAL (3 * WZRHPG300NH2_KEYS_POLL_INTERVAL)
+
+static struct mtd_partition wzrhpg300nh2_flash_partitions[] = {
+	{
+		.name		= "u-boot",
+		.offset		= 0,
+		.size		= 0x0040000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "u-boot-env",
+		.offset		= 0x0040000,
+		.size		= 0x0010000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "art",
+		.offset		= 0x0050000,
+		.size		= 0x0010000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "kernel",
+		.offset		= 0x0060000,
+		.size		= 0x0100000,
+	}, {
+		.name		= "rootfs",
+		.offset		= 0x0160000,
+		.size		= 0x1e90000,
+	}, {
+		.name		= "user_property",
+		.offset		= 0x1ff0000,
+		.size		= 0x0010000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "firmware",
+		.offset		= 0x0060000,
+		.size		= 0x1f90000,
+	}
+};
+
+static struct flash_platform_data wzrhpg300nh2_flash_data = {
+	.parts          = wzrhpg300nh2_flash_partitions,
+	.nr_parts       = ARRAY_SIZE(wzrhpg300nh2_flash_partitions),
+};
+
+static struct gpio_led wzrhpg300nh2_leds_gpio[] __initdata = {
+	{
+		.name		= "buffalo:red:diag",
+		.gpio		= 16,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_led wzrhpg300nh2_wmac_leds_gpio[] = {
+	{
+		.name           = "buffalo:blue:usb",
+		.gpio           = 4,
+		.active_low     = 1,
+	},
+	{
+		.name           = "buffalo:orange:security",
+		.gpio           = 6,
+		.active_low     = 1,
+	},
+	{
+		.name           = "buffalo:green:router",
+		.gpio           = 7,
+		.active_low     = 1,
+	},
+	{
+		.name           = "buffalo:blue:movie_engine_on",
+		.gpio           = 8,
+		.active_low     = 1,
+	},
+	{
+		.name           = "buffalo:blue:movie_engine_off",
+		.gpio           = 9,
+		.active_low     = 1,
+	},
+};
+
+/* The AOSS button is wmac gpio 12 */
+static struct gpio_keys_button wzrhpg300nh2_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = WZRHPG300NH2_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= 1,
+		.active_low	= 1,
+	}, {
+		.desc		= "usb",
+		.type		= EV_KEY,
+		.code		= BTN_2,
+		.debounce_interval = WZRHPG300NH2_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= 7,
+		.active_low	= 1,
+	}, {
+		.desc		= "qos",
+		.type		= EV_KEY,
+		.code		= BTN_3,
+		.debounce_interval = WZRHPG300NH2_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= 11,
+		.active_low	= 0,
+	}, {
+		.desc		= "router_on",
+		.type		= EV_KEY,
+		.code		= BTN_5,
+		.debounce_interval = WZRHPG300NH2_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= 8,
+		.active_low	= 0,
+	},
+};
+
+static void __init wzrhpg300nh2_setup(void)
+{
+
+	u8 *eeprom = (u8 *)   KSEG1ADDR(0x1f051000);
+	u8 *mac0   = eeprom + WZRHPG300NH2_MAC_OFFSET;
+	/* There is an eth1 but it is not connected to the switch */
+
+	ath79_register_m25p80_multi(&wzrhpg300nh2_flash_data);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac0, 0);
+	ath79_register_mdio(0, ~(BIT(0)));
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac0, 0);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.speed = SPEED_1000;
+	ath79_eth0_data.duplex = DUPLEX_FULL;
+	ath79_eth0_data.phy_mask = BIT(0);
+
+	ath79_register_eth(0);
+
+	/* gpio13 is usb power.  Turn it on. */
+	ath79_set_usb_power_gpio(13, GPIOF_OUT_INIT_HIGH, "USB power");
+	ath79_register_usb();
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(wzrhpg300nh2_leds_gpio),
+				 wzrhpg300nh2_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, WZRHPG300NH2_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(wzrhpg300nh2_gpio_keys),
+					wzrhpg300nh2_gpio_keys);
+	ap9x_pci_setup_wmac_led_pin(0, 5);
+	ap9x_pci_setup_wmac_leds(0, wzrhpg300nh2_wmac_leds_gpio,
+				ARRAY_SIZE(wzrhpg300nh2_wmac_leds_gpio));
+
+	ap91_pci_init(eeprom, mac0);
+}
+
+MIPS_MACHINE(ATH79_MACH_WZR_HP_G300NH2, "WZR-HP-G300NH2",
+	     "Buffalo WZR-HP-G300NH2", wzrhpg300nh2_setup);
diff --git a/arch/mips/ath79/mach-wzr-hp-g450h.c b/arch/mips/ath79/mach-wzr-hp-g450h.c
new file mode 100644
index 0000000..b5292db
--- /dev/null
+++ b/arch/mips/ath79/mach-wzr-hp-g450h.c
@@ -0,0 +1,169 @@
+/*
+ *  Buffalo WZR-HP-G450G board support
+ *
+ *  Copyright (C) 2011 Felix Fietkau <nbd@openwrt.org>
+ *  Copyright (C) 2008-2012 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/gpio.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-eth.h"
+#include "dev-m25p80.h"
+#include "dev-ap9x-pci.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-usb.h"
+#include "machtypes.h"
+
+#define WZRHPG450H_KEYS_POLL_INTERVAL     20      /* msecs */
+#define WZRHPG450H_KEYS_DEBOUNCE_INTERVAL (3 * WZRHPG450H_KEYS_POLL_INTERVAL)
+
+static struct mtd_partition wzrhpg450h_partitions[] = {
+	{
+		.name		= "u-boot",
+		.offset		= 0,
+		.size		= 0x0040000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "u-boot-env",
+		.offset		= 0x0040000,
+		.size		= 0x0010000,
+	}, {
+		.name		= "ART",
+		.offset		= 0x0050000,
+		.size		= 0x0010000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "uImage",
+		.offset		= 0x0060000,
+		.size		= 0x0100000,
+	}, {
+		.name		= "rootfs",
+		.offset		= 0x0160000,
+		.size		= 0x1e80000,
+	}, {
+		.name		= "user_property",
+		.offset		= 0x1fe0000,
+		.size		= 0x0020000,
+	}, {
+		.name		= "firmware",
+		.offset		= 0x0060000,
+		.size		= 0x1f80000,
+	}
+};
+
+static struct flash_platform_data wzrhpg450h_flash_data = {
+	.parts		= wzrhpg450h_partitions,
+	.nr_parts	= ARRAY_SIZE(wzrhpg450h_partitions),
+};
+
+static struct gpio_led wzrhpg450h_leds_gpio[] __initdata = {
+	{
+		.name		= "buffalo:red:diag",
+		.gpio		= 14,
+		.active_low	= 1,
+	},
+	{
+		.name		= "buffalo:orange:security",
+		.gpio		= 13,
+		.active_low	= 1,
+	},
+};
+
+
+static struct gpio_led wzrhpg450h_wmac_leds_gpio[] = {
+	{
+		.name		= "buffalo:blue:movie_engine",
+		.gpio		= 13,
+		.active_low	= 1,
+	},
+	{
+		.name		= "buffalo:green:router",
+		.gpio		= 14,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button wzrhpg450h_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = WZRHPG450H_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= 6,
+		.active_low	= 1,
+	}, {
+		.desc		= "usb",
+		.type		= EV_KEY,
+		.code		= BTN_2,
+		.debounce_interval = WZRHPG450H_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= 1,
+		.active_low	= 1,
+	}, {
+		.desc		= "aoss",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = WZRHPG450H_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= 8,
+		.active_low	= 1,
+	}, {
+		.desc		= "movie_engine",
+		.type		= EV_KEY,
+		.code		= BTN_6,
+		.debounce_interval = WZRHPG450H_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= 7,
+		.active_low	= 0,
+	}, {
+		.desc		= "router_off",
+		.type		= EV_KEY,
+		.code		= BTN_5,
+		.debounce_interval = WZRHPG450H_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= 12,
+		.active_low	= 0,
+	}
+};
+
+
+static void __init wzrhpg450h_init(void)
+{
+	u8 *ee = (u8 *) KSEG1ADDR(0x1f051000);
+	u8 *mac = (u8 *) ee + 2;
+
+	ath79_register_m25p80_multi(&wzrhpg450h_flash_data);
+
+	ath79_register_mdio(0, ~BIT(0));
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 0);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.speed = SPEED_1000;
+	ath79_eth0_data.duplex = DUPLEX_FULL;
+	ath79_eth0_data.phy_mask = BIT(0);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(wzrhpg450h_leds_gpio),
+				 wzrhpg450h_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, WZRHPG450H_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(wzrhpg450h_gpio_keys),
+					wzrhpg450h_gpio_keys);
+
+	ath79_register_eth(0);
+
+	ath79_set_usb_power_gpio(16, GPIOF_OUT_INIT_HIGH, "USB power");
+	ath79_register_usb();
+
+	ap91_pci_init(ee, NULL);
+	ap9x_pci_setup_wmac_led_pin(0, 15);
+	ap9x_pci_setup_wmac_leds(0, wzrhpg450h_wmac_leds_gpio,
+				 ARRAY_SIZE(wzrhpg450h_wmac_leds_gpio));
+}
+
+MIPS_MACHINE(ATH79_MACH_WZR_HP_G450H, "WZR-HP-G450H", "Buffalo WZR-HP-G450H",
+	     wzrhpg450h_init);
diff --git a/arch/mips/ath79/mach-zcn-1523h.c b/arch/mips/ath79/mach-zcn-1523h.c
new file mode 100644
index 0000000..3a6fe21
--- /dev/null
+++ b/arch/mips/ath79/mach-zcn-1523h.c
@@ -0,0 +1,157 @@
+/*
+ *  Zcomax ZCN-1523H-2-8/5-16 board support
+ *
+ *  Copyright (C) 2010-2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-eth.h"
+#include "dev-m25p80.h"
+#include "dev-ap9x-pci.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "machtypes.h"
+
+#define ZCN_1523H_GPIO_BTN_RESET	0
+#define ZCN_1523H_GPIO_LED_INIT		11
+#define ZCN_1523H_GPIO_LED_LAN1		17
+
+#define ZCN_1523H_2_GPIO_LED_WEAK	13
+#define ZCN_1523H_2_GPIO_LED_MEDIUM	14
+#define ZCN_1523H_2_GPIO_LED_STRONG	15
+
+#define ZCN_1523H_5_GPIO_LED_UNKNOWN	1
+#define ZCN_1523H_5_GPIO_LED_LAN2	13
+#define ZCN_1523H_5_GPIO_LED_WEAK	14
+#define ZCN_1523H_5_GPIO_LED_MEDIUM	15
+#define ZCN_1523H_5_GPIO_LED_STRONG	16
+
+#define ZCN_1523H_KEYS_POLL_INTERVAL	20	/* msecs */
+#define ZCN_1523H_KEYS_DEBOUNCE_INTERVAL (3 * ZCN_1523H_KEYS_POLL_INTERVAL)
+
+static struct gpio_keys_button zcn_1523h_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = ZCN_1523H_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= ZCN_1523H_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_led zcn_1523h_leds_gpio[] __initdata = {
+	{
+		.name		= "zcn-1523h:amber:init",
+		.gpio		= ZCN_1523H_GPIO_LED_INIT,
+		.active_low	= 1,
+	}, {
+		.name		= "zcn-1523h:green:lan1",
+		.gpio		= ZCN_1523H_GPIO_LED_LAN1,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_led zcn_1523h_2_leds_gpio[] __initdata = {
+	{
+		.name		= "zcn-1523h:red:weak",
+		.gpio		= ZCN_1523H_2_GPIO_LED_WEAK,
+		.active_low	= 1,
+	}, {
+		.name		= "zcn-1523h:amber:medium",
+		.gpio		= ZCN_1523H_2_GPIO_LED_MEDIUM,
+		.active_low	= 1,
+	}, {
+		.name		= "zcn-1523h:green:strong",
+		.gpio		= ZCN_1523H_2_GPIO_LED_STRONG,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_led zcn_1523h_5_leds_gpio[] __initdata = {
+	{
+		.name		= "zcn-1523h:red:weak",
+		.gpio		= ZCN_1523H_5_GPIO_LED_WEAK,
+		.active_low	= 1,
+	}, {
+		.name		= "zcn-1523h:amber:medium",
+		.gpio		= ZCN_1523H_5_GPIO_LED_MEDIUM,
+		.active_low	= 1,
+	}, {
+		.name		= "zcn-1523h:green:strong",
+		.gpio		= ZCN_1523H_5_GPIO_LED_STRONG,
+		.active_low	= 1,
+	}, {
+		.name		= "zcn-1523h:green:lan2",
+		.gpio		= ZCN_1523H_5_GPIO_LED_LAN2,
+		.active_low	= 1,
+	}, {
+		.name		= "zcn-1523h:amber:unknown",
+		.gpio		= ZCN_1523H_5_GPIO_LED_UNKNOWN,
+	}
+};
+
+static void __init zcn_1523h_generic_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f7e0004);
+	u8 *ee = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	ath79_gpio_function_disable(AR724X_GPIO_FUNC_ETH_SWITCH_LED0_EN |
+				    AR724X_GPIO_FUNC_ETH_SWITCH_LED1_EN |
+				    AR724X_GPIO_FUNC_ETH_SWITCH_LED2_EN |
+				    AR724X_GPIO_FUNC_ETH_SWITCH_LED3_EN |
+				    AR724X_GPIO_FUNC_ETH_SWITCH_LED4_EN);
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_leds_gpio(0, ARRAY_SIZE(zcn_1523h_leds_gpio),
+					zcn_1523h_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, ZCN_1523H_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(zcn_1523h_gpio_keys),
+					zcn_1523h_gpio_keys);
+
+	ap91_pci_init(ee, mac);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 0);
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac, 1);
+
+	ath79_register_mdio(0, 0x0);
+
+	/* LAN1 port */
+	ath79_register_eth(0);
+}
+
+static void __init zcn_1523h_2_setup(void)
+{
+	zcn_1523h_generic_setup();
+	ap9x_pci_setup_wmac_gpio(0, BIT(9), 0);
+
+	ath79_register_leds_gpio(1, ARRAY_SIZE(zcn_1523h_2_leds_gpio),
+				 zcn_1523h_2_leds_gpio);
+}
+
+MIPS_MACHINE(ATH79_MACH_ZCN_1523H_2, "ZCN-1523H-2", "Zcomax ZCN-1523H-2",
+	     zcn_1523h_2_setup);
+
+static void __init zcn_1523h_5_setup(void)
+{
+	zcn_1523h_generic_setup();
+	ap9x_pci_setup_wmac_gpio(0, BIT(8), 0);
+
+	ath79_register_leds_gpio(1, ARRAY_SIZE(zcn_1523h_5_leds_gpio),
+				 zcn_1523h_5_leds_gpio);
+
+	/* LAN2 port */
+	ath79_register_eth(1);
+}
+
+MIPS_MACHINE(ATH79_MACH_ZCN_1523H_5, "ZCN-1523H-5", "Zcomax ZCN-1523H-5",
+	     zcn_1523h_5_setup);
diff --git a/arch/mips/ath79/nvram.c b/arch/mips/ath79/nvram.c
new file mode 100644
index 0000000..43911b8
--- /dev/null
+++ b/arch/mips/ath79/nvram.c
@@ -0,0 +1,75 @@
+/*
+ *  Atheros AR71xx minimal nvram support
+ *
+ *  Copyright (C) 2009 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/kernel.h>
+#include <linux/vmalloc.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/string.h>
+
+#include "nvram.h"
+
+char *ath79_nvram_find_var(const char *name, const char *buf, unsigned buf_len)
+{
+	unsigned len = strlen(name);
+	char *cur, *last;
+
+	if (buf_len == 0 || len == 0)
+		return NULL;
+
+	if (buf_len < len)
+		return NULL;
+
+	if (len == 1)
+		return memchr(buf, (int) *name, buf_len);
+
+	last = (char *) buf + buf_len - len;
+	for (cur = (char *) buf; cur <= last; cur++)
+		if (cur[0] == name[0] && memcmp(cur, name, len) == 0)
+			return cur + len;
+
+	return NULL;
+}
+
+int ath79_nvram_parse_mac_addr(const char *nvram, unsigned nvram_len,
+			       const char *name, char *mac)
+{
+	char *buf;
+	char *mac_str;
+	int ret;
+	int t;
+
+	buf = vmalloc(nvram_len);
+	if (!buf)
+		return -ENOMEM;
+
+	memcpy(buf, nvram, nvram_len);
+	buf[nvram_len - 1] = '\0';
+
+	mac_str = ath79_nvram_find_var(name, buf, nvram_len);
+	if (!mac_str) {
+		ret = -EINVAL;
+		goto free;
+	}
+
+	t = sscanf(mac_str, "%02hhx:%02hhx:%02hhx:%02hhx:%02hhx:%02hhx",
+		   &mac[0], &mac[1], &mac[2], &mac[3], &mac[4], &mac[5]);
+
+	if (t != 6) {
+		ret = -EINVAL;
+		goto free;
+	}
+
+	ret = 0;
+
+free:
+	vfree(buf);
+	return ret;
+}
diff --git a/arch/mips/ath79/nvram.h b/arch/mips/ath79/nvram.h
new file mode 100644
index 0000000..75151d4
--- /dev/null
+++ b/arch/mips/ath79/nvram.h
@@ -0,0 +1,19 @@
+/*
+ *  Atheros AR71xx minimal nvram support
+ *
+ *  Copyright (C) 2009 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#ifndef _ATH79_NVRAM_H
+#define _ATH79_NVRAM_H
+
+char *ath79_nvram_find_var(const char *name, const char *buf,
+			   unsigned buf_len);
+int ath79_nvram_parse_mac_addr(const char *nvram, unsigned nvram_len,
+			       const char *name, char *mac);
+
+#endif /* _ATH79_NVRAM_H */
diff --git a/arch/mips/ath79/pci-ath9k-fixup.c b/arch/mips/ath79/pci-ath9k-fixup.c
new file mode 100644
index 0000000..fcca1d2
--- /dev/null
+++ b/arch/mips/ath79/pci-ath9k-fixup.c
@@ -0,0 +1,123 @@
+/*
+ *  Atheros AP94 reference board PCI initialization
+ *
+ *  Copyright (C) 2009-2010 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/pci.h>
+#include <linux/delay.h>
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+#include <asm/mach-ath79/ath79.h>
+
+struct ath9k_fixup {
+	u16		*cal_data;
+	unsigned	slot;
+};
+
+static int ath9k_num_fixups;
+static struct ath9k_fixup ath9k_fixups[2];
+
+static void ath9k_pci_fixup(struct pci_dev *dev)
+{
+	void __iomem *mem;
+	u16 *cal_data = NULL;
+	u16 cmd;
+	u32 bar0;
+	u32 val;
+	unsigned i;
+
+	for (i = 0; i < ath9k_num_fixups; i++) {
+		if (ath9k_fixups[i].cal_data == NULL)
+			continue;
+
+		if (ath9k_fixups[i].slot != PCI_SLOT(dev->devfn))
+			continue;
+
+		cal_data = ath9k_fixups[i].cal_data;
+		break;
+	}
+
+	if (cal_data == NULL)
+		return;
+
+	if (*cal_data != 0xa55a) {
+		pr_err("pci %s: invalid calibration data\n", pci_name(dev));
+		return;
+	}
+
+	pr_info("pci %s: fixup device configuration\n", pci_name(dev));
+
+	mem = ioremap(AR71XX_PCI_MEM_BASE, 0x10000);
+	if (!mem) {
+		pr_err("pci %s: ioremap error\n", pci_name(dev));
+		return;
+	}
+
+	pci_read_config_dword(dev, PCI_BASE_ADDRESS_0, &bar0);
+
+	switch (ath79_soc) {
+	case ATH79_SOC_AR7161:
+		pci_write_config_dword(dev, PCI_BASE_ADDRESS_0,
+				       AR71XX_PCI_MEM_BASE);
+		break;
+	case ATH79_SOC_AR7240:
+		pci_write_config_dword(dev, PCI_BASE_ADDRESS_0, 0xffff);
+		break;
+
+	case ATH79_SOC_AR7241:
+	case ATH79_SOC_AR7242:
+		pci_write_config_dword(dev, PCI_BASE_ADDRESS_0, 0x1000ffff);
+		break;
+
+	default:
+		BUG();
+	}
+
+	pci_read_config_word(dev, PCI_COMMAND, &cmd);
+	cmd |= PCI_COMMAND_MASTER | PCI_COMMAND_MEMORY;
+	pci_write_config_word(dev, PCI_COMMAND, cmd);
+
+	/* set pointer to first reg address */
+	cal_data += 3;
+	while (*cal_data != 0xffff) {
+		u32 reg;
+		reg = *cal_data++;
+		val = *cal_data++;
+		val |= (*cal_data++) << 16;
+
+		__raw_writel(val, mem + reg);
+		udelay(100);
+	}
+
+	pci_read_config_dword(dev, PCI_VENDOR_ID, &val);
+	dev->vendor = val & 0xffff;
+	dev->device = (val >> 16) & 0xffff;
+
+	pci_read_config_dword(dev, PCI_CLASS_REVISION, &val);
+	dev->revision = val & 0xff;
+	dev->class = val >> 8; /* upper 3 bytes */
+
+	pci_read_config_word(dev, PCI_COMMAND, &cmd);
+	cmd &= ~(PCI_COMMAND_MASTER | PCI_COMMAND_MEMORY);
+	pci_write_config_word(dev, PCI_COMMAND, cmd);
+
+	pci_write_config_dword(dev, PCI_BASE_ADDRESS_0, bar0);
+
+	iounmap(mem);
+}
+DECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_ATHEROS, PCI_ANY_ID, ath9k_pci_fixup);
+
+void __init pci_enable_ath9k_fixup(unsigned slot, u16 *cal_data)
+{
+	if (ath9k_num_fixups >= ARRAY_SIZE(ath9k_fixups))
+		return;
+
+	ath9k_fixups[ath9k_num_fixups].slot = slot;
+	ath9k_fixups[ath9k_num_fixups].cal_data = cal_data;
+	ath9k_num_fixups++;
+}
diff --git a/arch/mips/ath79/pci-ath9k-fixup.h b/arch/mips/ath79/pci-ath9k-fixup.h
new file mode 100644
index 0000000..5794941
--- /dev/null
+++ b/arch/mips/ath79/pci-ath9k-fixup.h
@@ -0,0 +1,6 @@
+#ifndef _PCI_ATH9K_FIXUP
+#define _PCI_ATH9K_FIXUP
+
+void pci_enable_ath9k_fixup(unsigned slot, u16 *cal_data) __init;
+
+#endif /* _PCI_ATH9K_FIXUP */
diff --git a/arch/mips/include/asm/fw/myloader/myloader.h b/arch/mips/include/asm/fw/myloader/myloader.h
new file mode 100644
index 0000000..8a99d56
--- /dev/null
+++ b/arch/mips/include/asm/fw/myloader/myloader.h
@@ -0,0 +1,34 @@
+/*
+ *  Compex's MyLoader specific definitions
+ *
+ *  Copyright (C) 2006-2008 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ *
+ */
+
+#ifndef _ASM_MIPS_FW_MYLOADER_H
+#define _ASM_MIPS_FW_MYLOADER_H
+
+#include <linux/myloader.h>
+
+struct myloader_info {
+	uint32_t	vid;
+	uint32_t	did;
+	uint32_t	svid;
+	uint32_t	sdid;
+	uint8_t		macs[MYLO_ETHADDR_COUNT][6];
+};
+
+#ifdef CONFIG_MYLOADER
+extern struct myloader_info *myloader_get_info(void) __init;
+#else
+static inline struct myloader_info *myloader_get_info(void)
+{
+	return NULL;
+}
+#endif /* CONFIG_MYLOADER */
+
+#endif /* _ASM_MIPS_FW_MYLOADER_H */
diff --git a/arch/mips/include/asm/mach-ath79/ag71xx_platform.h b/arch/mips/include/asm/mach-ath79/ag71xx_platform.h
new file mode 100644
index 0000000..e2f6f9b
--- /dev/null
+++ b/arch/mips/include/asm/mach-ath79/ag71xx_platform.h
@@ -0,0 +1,58 @@
+/*
+ *  Atheros AR71xx SoC specific platform data definitions
+ *
+ *  Copyright (C) 2008-2012 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#ifndef __ASM_MACH_ATH79_PLATFORM_H
+#define __ASM_MACH_ATH79_PLATFORM_H
+
+#include <linux/if_ether.h>
+#include <linux/skbuff.h>
+#include <linux/phy.h>
+#include <linux/spi/spi.h>
+
+struct ag71xx_switch_platform_data {
+	u8		phy4_mii_en:1;
+	u8		phy_poll_mask;
+};
+
+struct ag71xx_platform_data {
+	phy_interface_t	phy_if_mode;
+	u32		phy_mask;
+	int		speed;
+	int		duplex;
+	u32		reset_bit;
+	u8		mac_addr[ETH_ALEN];
+	struct device	*mii_bus_dev;
+
+	u8		has_gbit:1;
+	u8		is_ar91xx:1;
+	u8		is_ar7240:1;
+	u8		is_ar724x:1;
+	u8		has_ar8216:1;
+
+	struct ag71xx_switch_platform_data *switch_data;
+
+	void		(*ddr_flush)(void);
+	void		(*set_speed)(int speed);
+
+	u32		fifo_cfg1;
+	u32		fifo_cfg2;
+	u32		fifo_cfg3;
+};
+
+struct ag71xx_mdio_platform_data {
+	u32		phy_mask;
+	u8		builtin_switch:1;
+	u8		is_ar7240:1;
+	u8		is_ar9330:1;
+	u8		is_ar934x:1;
+};
+
+#endif /* __ASM_MACH_ATH79_PLATFORM_H */
diff --git a/arch/mips/include/asm/mach-ath79/mach-rb750.h b/arch/mips/include/asm/mach-ath79/mach-rb750.h
new file mode 100644
index 0000000..50d5a20
--- /dev/null
+++ b/arch/mips/include/asm/mach-ath79/mach-rb750.h
@@ -0,0 +1,84 @@
+/*
+ *  MikroTik RouterBOARD 750 definitions
+ *
+ *  Copyright (C) 2010-2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+#ifndef _MACH_RB750_H
+#define _MACH_RB750_H
+
+#include <linux/bitops.h>
+
+#define RB750_GPIO_LVC573_LE	0	/* Latch enable on LVC573 */
+#define RB750_GPIO_NAND_IO0	1	/* NAND I/O 0 */
+#define RB750_GPIO_NAND_IO1	2	/* NAND I/O 1 */
+#define RB750_GPIO_NAND_IO2	3	/* NAND I/O 2 */
+#define RB750_GPIO_NAND_IO3	4	/* NAND I/O 3 */
+#define RB750_GPIO_NAND_IO4	5	/* NAND I/O 4 */
+#define RB750_GPIO_NAND_IO5	6	/* NAND I/O 5 */
+#define RB750_GPIO_NAND_IO6	7	/* NAND I/O 6 */
+#define RB750_GPIO_NAND_IO7	8	/* NAND I/O 7 */
+#define RB750_GPIO_NAND_NCE	11	/* NAND Chip Enable (active low) */
+#define RB750_GPIO_NAND_RDY	12	/* NAND Ready */
+#define RB750_GPIO_NAND_CLE	14	/* NAND Command Latch Enable */
+#define RB750_GPIO_NAND_ALE	15	/* NAND Address Latch Enable */
+#define RB750_GPIO_NAND_NRE	16	/* NAND Read Enable (active low) */
+#define RB750_GPIO_NAND_NWE	17	/* NAND Write Enable (active low) */
+
+#define RB750_GPIO_BTN_RESET	1
+#define RB750_GPIO_SPI_CS0	2
+#define RB750_GPIO_LED_ACT	12
+#define RB750_GPIO_LED_PORT1	13
+#define RB750_GPIO_LED_PORT2	14
+#define RB750_GPIO_LED_PORT3	15
+#define RB750_GPIO_LED_PORT4	16
+#define RB750_GPIO_LED_PORT5	17
+
+#define RB750_LED_ACT		BIT(RB750_GPIO_LED_ACT)
+#define RB750_LED_PORT1		BIT(RB750_GPIO_LED_PORT1)
+#define RB750_LED_PORT2		BIT(RB750_GPIO_LED_PORT2)
+#define RB750_LED_PORT3		BIT(RB750_GPIO_LED_PORT3)
+#define RB750_LED_PORT4		BIT(RB750_GPIO_LED_PORT4)
+#define RB750_LED_PORT5		BIT(RB750_GPIO_LED_PORT5)
+#define RB750_NAND_NCE		BIT(RB750_GPIO_NAND_NCE)
+
+#define RB750_LVC573_LE		BIT(RB750_GPIO_LVC573_LE)
+
+#define RB750_LED_BITS	(RB750_LED_PORT1 | RB750_LED_PORT2 | RB750_LED_PORT3 | \
+			 RB750_LED_PORT4 | RB750_LED_PORT5 | RB750_LED_ACT)
+
+#define RB7XX_GPIO_NAND_NCE	0
+#define RB7XX_GPIO_MON		9
+#define RB7XX_GPIO_LED_ACT	11
+#define RB7XX_GPIO_USB_POWERON	13
+
+#define RB7XX_NAND_NCE		BIT(RB7XX_GPIO_NAND_NCE)
+#define RB7XX_LED_ACT		BIT(RB7XX_GPIO_LED_ACT)
+#define RB7XX_MONITOR		BIT(RB7XX_GPIO_MON)
+#define RB7XX_USB_POWERON	BIT(RB7XX_GPIO_USB_POWERON)
+
+struct rb750_led_data {
+	char	*name;
+	char	*default_trigger;
+	u32	mask;
+	int	active_low;
+};
+
+struct rb750_led_platform_data {
+	int			num_leds;
+	struct rb750_led_data	*leds;
+	void			(*latch_change)(u32 clear, u32 set);
+};
+
+struct rb7xx_nand_platform_data {
+	u32 nce_line;
+
+	void (*enable_pins)(void);
+	void (*disable_pins)(void);
+	void (*latch_change)(u32, u32);
+};
+
+#endif /* _MACH_RB750_H */
\ No newline at end of file
diff --git a/arch/mips/include/asm/mach-ath79/rb4xx_cpld.h b/arch/mips/include/asm/mach-ath79/rb4xx_cpld.h
new file mode 100644
index 0000000..5b17e94
--- /dev/null
+++ b/arch/mips/include/asm/mach-ath79/rb4xx_cpld.h
@@ -0,0 +1,48 @@
+/*
+ * SPI driver definitions for the CPLD chip on the Mikrotik RB4xx boards
+ *
+ * Copyright (C) 2010 Gabor Juhos <juhosg@openwrt.org>
+ *
+ * This file was based on the patches for Linux 2.6.27.39 published by
+ * MikroTik for their RouterBoard 4xx series devices.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation.
+ */
+
+#define CPLD_GPIO_nLED1		0
+#define CPLD_GPIO_nLED2		1
+#define CPLD_GPIO_nLED3		2
+#define CPLD_GPIO_nLED4		3
+#define CPLD_GPIO_FAN		4
+#define CPLD_GPIO_ALE		5
+#define CPLD_GPIO_CLE		6
+#define CPLD_GPIO_nCE		7
+#define CPLD_GPIO_nLED5		8
+
+#define CPLD_NUM_GPIOS		9
+
+#define CPLD_CFG_nLED1		BIT(CPLD_GPIO_nLED1)
+#define CPLD_CFG_nLED2		BIT(CPLD_GPIO_nLED2)
+#define CPLD_CFG_nLED3		BIT(CPLD_GPIO_nLED3)
+#define CPLD_CFG_nLED4		BIT(CPLD_GPIO_nLED4)
+#define CPLD_CFG_FAN		BIT(CPLD_GPIO_FAN)
+#define CPLD_CFG_ALE		BIT(CPLD_GPIO_ALE)
+#define CPLD_CFG_CLE		BIT(CPLD_GPIO_CLE)
+#define CPLD_CFG_nCE		BIT(CPLD_GPIO_nCE)
+#define CPLD_CFG_nLED5		BIT(CPLD_GPIO_nLED5)
+
+struct rb4xx_cpld_platform_data {
+	unsigned	gpio_base;
+};
+
+extern int rb4xx_cpld_change_cfg(unsigned mask, unsigned value);
+extern int rb4xx_cpld_read(unsigned char *rx_buf,
+			   const unsigned char *verify_buf,
+			   unsigned cnt);
+extern int rb4xx_cpld_read_from(unsigned addr,
+				unsigned char *rx_buf,
+				const unsigned char *verify_buf,
+				unsigned cnt);
+extern int rb4xx_cpld_write(const unsigned char *buf, unsigned count);
-- 
1.7.10.4

