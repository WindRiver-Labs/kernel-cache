From f7106cfb118fe1faa3937a0014228622b1dabe59 Mon Sep 17 00:00:00 2001
From: Weiwei Wang <weiwei.wang@windriver.com>
Date: Fri, 12 Sep 2008 15:12:51 +0800
Subject: [PATCH] Add clock API support for broadcom1x80

Clock API is needed in our product, so support it.

Signed-off-by: Weiwei Wang <weiwei.wang@windriver.com>
---
 arch/mips/kernel/cevt-bcm1480.c |   56 +++++++++++++++++++++++++++++++++++++++
 1 files changed, 56 insertions(+), 0 deletions(-)

diff --git a/arch/mips/kernel/cevt-bcm1480.c b/arch/mips/kernel/cevt-bcm1480.c
index 0a57f86..568676e 100644
--- a/arch/mips/kernel/cevt-bcm1480.c
+++ b/arch/mips/kernel/cevt-bcm1480.c
@@ -34,6 +34,42 @@
 #define IMR_IP3_VAL	K_BCM1480_INT_MAP_I1
 #define IMR_IP4_VAL	K_BCM1480_INT_MAP_I2
 
+#ifdef CONFIG_HWTIMER_HOOKS
+#include <linux/hwtimer.h>
+
+int sb1480_timer_get_freq(void)
+{
+	return HZ;
+}
+
+static struct hwtimer_data sb1480_timer_data = {
+	.name = "SB1480 timer",
+	.desc = "SB1480 Kernel jiffy timer",
+	.def_freq = HZ,
+	.min_freq = HZ,
+	.max_freq = HZ
+};
+
+static DECLARE_HWTIMER_LOCK(sb1480_timer_lock);
+
+static struct hwtimer sb1480_timer = {
+	.data = &sb1480_timer_data,
+	.set_freq = NULL,
+	.get_freq = sb1480_timer_get_freq,
+	.start = NULL,
+	.stop = NULL,
+	.lock = &sb1480_timer_lock,
+	.hook = NULL,
+	.hook_data = NULL
+};
+
+/* the hwtimer callbacks are meant to be triggered once per tick, and in a
+   round-robin fashion across the active cpus.  We accomplish this by keeping
+   a per-cpu count of how many ticks are left until the given cpu should
+   activate the hwtimer callback. */
+static atomic_t hwtimer_cpu_trigger[NR_CPUS];
+#endif /* CONFIG_HWTIMER_HOOKS */
+
 /*
  * The general purpose timer ticks at 1MHz independent if
  * the rest of the system
@@ -100,6 +136,17 @@ static irqreturn_t sibyte_counter_handler(int irq, void *dev_id)
 
 	cd->event_handler(cd);
 
+#ifdef CONFIG_HWTIMER_HOOKS
+	if (atomic_dec_and_test(&hwtimer_cpu_trigger[smp_processor_id()])) {
+		atomic_set(&hwtimer_cpu_trigger[smp_processor_id()],
+			   num_online_cpus());
+		spin_lock(sb1480_timer.lock);
+		if (sb1480_timer.hook != NULL)
+			(sb1480_timer.hook)(sb1480_timer.hook_data);
+		spin_unlock(sb1480_timer.lock);
+	}
+#endif /* CONFIG_HWTIMER_HOOKS */
+
 	return IRQ_HANDLED;
 }
 
@@ -117,6 +164,15 @@ void __cpuinit sb1480_clockevent_init(void)
 
 	BUG_ON(cpu > 3);	/* Only have 4 general purpose timers */
 
+#ifdef CONFIG_HWTIMER_HOOKS
+	if (smp_processor_id() == 0) {
+		unsigned int i;
+		for_each_possible_cpu(i)
+			atomic_set(&hwtimer_cpu_trigger[i], i + 1);
+		register_hwtimer(&sb1480_timer);
+	}
+#endif /* CONFIG_HWTIMER_HOOKS */
+
 	sprintf(name, "bcm1480-counter-%d", cpu);
 	cd->name		= name;
 	cd->features		= CLOCK_EVT_FEAT_PERIODIC |
-- 
1.5.5.1

