From 1327749c13fc249df2368541f4e8979d3c5bc591 Mon Sep 17 00:00:00 2001
From: Kazuya Tsukamoto <kazuya.tsukamoto@necel.com>
Date: Mon, 9 Nov 2009 12:11:39 +0900
Subject: [PATCH 16/29] nec_em1: introduce pwm driver

By default the PWM device is not connected to other devices. To
use this driver, [lease connect a device with PWM.
(The function can be called because it includes it in the compilation. )

Signed-off-by: Kazuya Tsukamoto <kazuya.tsukamoto@necel.com>
---
 arch/arm/mach-mp200/include/mach/pwm.h |   84 +++
 drivers/char/mp200_pwm.c               |  948 ++++++++++++++++++++++++++++++++
 drivers/char/mp200_pwm.h               |  173 ++++++
 3 files changed, 1205 insertions(+), 0 deletions(-)
 create mode 100644 arch/arm/mach-mp200/include/mach/pwm.h
 create mode 100644 drivers/char/mp200_pwm.c
 create mode 100644 drivers/char/mp200_pwm.h

diff --git a/arch/arm/mach-mp200/include/mach/pwm.h b/arch/arm/mach-mp200/include/mach/pwm.h
new file mode 100644
index 0000000..7a71298
--- /dev/null
+++ b/arch/arm/mach-mp200/include/mach/pwm.h
@@ -0,0 +1,84 @@
+/*
+ *  File Name	    : include/asm-arm/arch-mp200/pwm.h
+ *  Function	    : pwm
+ *  Release Version : Ver 1.00
+ *  Release Date    : 2009/04/15
+ *
+ *  Copyright (C) NEC Electronics Corporation 2009
+ *
+ *
+ *  This program is free software;you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published
+ *  by Free Softwere Foundation; either version 2 of License,
+ *  or (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY;
+ *  without even the implied warrnty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.
+ *  See the GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public
+ *  License along with this program;
+ *  If not, write to the Free Software Foundation, Inc., 59 Temple
+ *  Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef __ASM_ARM_ARCH_MP200_PWM_H
+#define __ASM_ARM_ARCH_MP200_PWM_H
+
+#define MP200_PWM_CH0		0
+#define MP200_PWM_CH1		1
+
+#define MP200_PWM_COMPARE0	0
+#define MP200_PWM_COMPARE1	1
+#define MP200_PWM_COMPARE2	2
+
+#define PWM_BIT_CMP2		0x04
+#define PWM_BIT_CMP1		0x02
+#define PWM_BIT_CMP0		0x01
+
+#define PWM_CODE_MODE_OR	0		/* CMP0-CMP 2 OR output */
+#define PWM_CODE_MODE_AND	1		/* CMP0-CMP 2 AND output */
+#define PWM_CODE_MODE_XOR	2		/* CMP0-CMP 2 XOR output */
+
+typedef void (*pwm_callback_t) (void *data, int intsts, int intrawsts);
+
+struct mp200_pwm_cb_info_t {
+	pwm_callback_t cb_count;
+	void *cb_count_data;
+	pwm_callback_t cb_loop;
+	void *cb_loop_data;
+};
+
+struct mp200_pwm_cmpcnt_t {
+	unsigned char cmp;
+	unsigned int delay;
+	unsigned int lead_edge;
+	unsigned int trail_edge;
+	unsigned int total_cycle;
+	unsigned int loop_count;
+	struct mp200_pwm_cb_info_t *cb_info;
+};
+
+struct mp200_pwm_ch_config_t {
+	unsigned char use_cmp;		/* cmp enable status */
+	unsigned char mode;
+	unsigned char inverse;
+	unsigned char interrupt_count;
+	unsigned char interrupt_loop;
+};
+
+extern int mp200_pwm_start(unsigned char channel);
+extern int mp200_pwm_stop(unsigned char channel);
+extern int mp200_pwm_set_channel_config(unsigned char channel,
+				struct mp200_pwm_ch_config_t *ch_config);
+extern int mp200_pwm_get_channel_config(unsigned char channel,
+				struct mp200_pwm_ch_config_t *ch_config);
+extern int mp200_pwm_set_compare_counter(unsigned char channel,
+				struct mp200_pwm_cmpcnt_t *pwm_cmpcnt);
+extern int mp200_pwm_get_compare_counter(unsigned char channel,
+				struct mp200_pwm_cmpcnt_t *pwm_cmpcnt);
+
+#endif	/* end of __ASM_ARM_ARCH_MP200_PWM_H */
+
diff --git a/drivers/char/mp200_pwm.c b/drivers/char/mp200_pwm.c
new file mode 100644
index 0000000..fdedbdd
--- /dev/null
+++ b/drivers/char/mp200_pwm.c
@@ -0,0 +1,948 @@
+/*
+ *  File Name       : linux/drivers/char/mp200_pwm.c
+ *  Function	    : Pulse Width Moduration(pwm).
+ *  Release Version : Ver 1.01
+ *  Release Date    : 2009/02/04
+ *
+ *  Copyright (C) NEC Electronics Corporation 2009
+ *
+ *
+ *  This program is free software;you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  Free Softwere Foundation; either version 2 of License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY;
+ *  without even the implied warrnty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.
+ *  See the GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program;
+ *  If not, write to the Free Software Foundation, Inc., 59 Temple
+ *  Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+/* XXX */
+/* #define MP200_PWM_DEBUG 1 */
+/* --------------------------------------------------------------------- */
+
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/spinlock.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+
+#include <mach/pmu.h>
+#include <mach/smu.h>
+#include <mach/irqs.h>
+#include <mach/pwm.h>
+
+#include "mp200_pwm.h"
+
+#if	defined(MP200_PWM_DEBUG)
+#define FNC_ENTRY \
+	if (debug == 1 || debug >= 9) {	\
+		printk(KERN_DEBUG "entry:%s\n", __func__); \
+	}
+#define FNC_EXIT \
+	if (debug == 1 || debug >= 9) {	\
+		printk(KERN_DEBUG "exit:%s:%d\n", __func__ , __LINE__); \
+	}
+#define d0b(fmt, args...)	\
+		printk(KERN_DEBUG "%s:%d: " fmt , __func__ , __LINE__ , \
+		       ## args);
+static int debug;
+#else
+#define FNC_ENTRY
+#define FNC_EXIT
+#define d0b(fmt, args...)
+#endif
+
+#if	defined(MP200_PWM_DEBUG)
+#define DEBUG_PRINT(FMT, ARGS...) \
+		printk(KERN_INFO "%s(): " FMT, __func__ , ##ARGS)
+#else
+#define DEBUG_PRINT(FMT, ARGS...)
+#endif
+
+static DEFINE_SPINLOCK(spin_lock);
+
+#if	defined(MP200_PWM_DEBUG)
+int pwm_init_flag = 1;
+EXPORT_SYMBOL(pwm_init_flag);
+#else
+static int pwm_init_flag = 1;
+#endif
+
+/* ------------------------------------------------------------------
+   register address, state, callback default define
+   ------------------------------------------------------------------ */
+static struct mp200_pwm_cb_info_t
+g_pwm_cb_info[PWM_MAX_CHANNEL_NUM][PWM_MAX_COUNTER_NUM];
+
+static struct pwm_info_t g_pwm_info[PWM_MAX_CHANNEL_NUM] = {
+	{
+		PWM_STATE_STOP,
+		PWM_CH0_CTRL,
+		PWM_CH0_MODE,
+	},
+	{
+		PWM_STATE_STOP,
+		PWM_CH1_CTRL,
+		PWM_CH1_MODE,
+	},
+};
+
+
+static struct mp200_pwm_cmpcnt_t
+g_pwm_cmpcnt[PWM_MAX_CHANNEL_NUM][PWM_MAX_COUNTER_NUM] = {
+	{
+		{
+			MP200_PWM_COMPARE0,
+			PWM_CH0_DELAY0,
+			PWM_CH0_LEDGE0,
+			PWM_CH0_TEDGE0,
+			PWM_CH0_TOTAL0,
+			PWM_CH0_LOOP0,
+			NULL,
+		},
+		{
+			MP200_PWM_COMPARE1,
+			PWM_CH0_DELAY1,
+			PWM_CH0_LEDGE1,
+			PWM_CH0_TEDGE1,
+			PWM_CH0_TOTAL1,
+			PWM_CH0_LOOP1,
+			NULL,
+		},
+		{
+			MP200_PWM_COMPARE2,
+			PWM_CH0_DELAY2,
+			PWM_CH0_LEDGE2,
+			PWM_CH0_TEDGE2,
+			PWM_CH0_TOTAL2,
+			PWM_CH0_LOOP2,
+			NULL,
+		},
+	},
+	{
+		{
+			MP200_PWM_COMPARE0,
+			PWM_CH1_DELAY0,
+			PWM_CH1_LEDGE0,
+			PWM_CH1_TEDGE0,
+			PWM_CH1_TOTAL0,
+			PWM_CH1_LOOP0,
+			NULL,
+		},
+		{
+			MP200_PWM_COMPARE1,
+			PWM_CH1_DELAY1,
+			PWM_CH1_LEDGE1,
+			PWM_CH1_TEDGE1,
+			PWM_CH1_TOTAL1,
+			PWM_CH1_LOOP1,
+			NULL,
+		},
+		{
+			MP200_PWM_COMPARE2,
+			PWM_CH1_DELAY2,
+			PWM_CH1_LEDGE2,
+			PWM_CH1_TEDGE2,
+			PWM_CH1_TOTAL2,
+			PWM_CH1_LOOP2,
+			NULL,
+		},
+	},
+};
+
+/* ------------------------------------------------------------------
+   smu control.
+   ------------------------------------------------------------------ */
+static inline void pwm_pwclk_start(int ch)
+{
+	if (ch == MP200_PWM_CH0)
+		mp200_pmu_open_clockgate(MP200_CLOCKGATE_PWM_PWCLK0);
+	else if (ch == MP200_PWM_CH1)
+		mp200_pmu_open_clockgate(MP200_CLOCKGATE_PWM_PWCLK1);
+}
+
+static inline void pwm_pwclk_stop(int ch)
+{
+	if (ch == MP200_PWM_CH0)
+		mp200_pmu_close_clockgate(MP200_CLOCKGATE_PWM_PWCLK0);
+	else if (ch == MP200_PWM_CH1)
+		mp200_pmu_close_clockgate(MP200_CLOCKGATE_PWM_PWCLK1);
+}
+
+static inline void pwm_clock_start(void)
+{
+	mp200_pmu_open_clockgate(MP200_CLOCKGATE_PWM_PWCLK1);
+	mp200_pmu_open_clockgate(MP200_CLOCKGATE_PWM_PWCLK0);
+	mp200_pmu_open_clockgate(MP200_CLOCKGATE_PWM_PCLK);
+}
+
+static inline void pwm_clock_stop(void)
+{
+	mp200_pmu_close_clockgate(MP200_CLOCKGATE_PWM_PWCLK1);
+	mp200_pmu_close_clockgate(MP200_CLOCKGATE_PWM_PWCLK0);
+	mp200_pmu_close_clockgate(MP200_CLOCKGATE_PWM_PCLK);
+}
+
+static inline void pwm_dev_unreset(void)
+{
+	mp200_pmu_unreset_device(MP200_RESETDEVICE_PWM);
+}
+
+/* ------------------------------------------------------------------
+   channel number check.
+   ------------------------------------------------------------------ */
+static inline int
+check_validity_channel(unsigned char channel)
+{
+	FNC_ENTRY
+	if ((channel == MP200_PWM_CH0) || (channel == MP200_PWM_CH1)) {
+		FNC_EXIT
+		return 0;
+	}
+	DEBUG_PRINT("channnel parameter error.\n");
+	FNC_EXIT
+	return 1;
+}
+
+
+/* ------------------------------------------------------------------
+   compare_counter number check.
+   ------------------------------------------------------------------ */
+static inline int
+check_validity_compare_counter(unsigned char cmp_counter)
+{
+	FNC_ENTRY
+	if (cmp_counter > MP200_PWM_COMPARE2) {
+		FNC_EXIT
+		return 1;
+	}
+	FNC_EXIT
+	return 0;
+}
+
+/* --------------------------------------------------------------
+   function : pwm_irq_handerl
+   argument :
+   return   : none
+   comment  : dev_id ... is compare_registers address.
+   -------------------------------------------------------------- */
+static irqreturn_t
+pwm_irq_handler(int irq, void *dev_id)
+{
+	struct mp200_pwm_cb_info_t *info;
+	unsigned int intsts, rawsts, sts, raw;
+	unsigned int shift;
+	unsigned int ch, cmp;
+	FNC_ENTRY
+
+	/* save interrupt status */
+	intsts = inl(PWM_INTSTATUS);
+	rawsts = inl(PWM_INTRAWSTATUS);
+	/* clear interrupt status */
+	outl(intsts, PWM_INTFFCLR);
+
+	for (ch = 0; ch < PWM_MAX_CHANNEL_NUM; ch++) {
+		if ((intsts & (PWM_MASK_ENDSET_SETBIT << (ch << 3))) == 0)
+			continue;
+
+		for (cmp = 0; cmp < PWM_MAX_COUNTER_NUM; cmp++) {
+			if ((intsts & (0x3 << ((cmp << 1) + (ch << 3)))) == 0)
+				continue;
+
+			info = g_pwm_cmpcnt[ch][cmp].cb_info;
+			if (NULL == info)
+				continue;
+
+			shift = ((cmp << 1) + (ch << 3));
+			sts = (intsts >> shift) & 0x3;
+			raw = (rawsts >> shift) & 0x3;
+			/* check interrupt */
+			if (sts & 0x1) {
+				if (info->cb_count) {
+					info->cb_count(
+						info->cb_count_data, sts, raw);
+				}
+			}
+			if (sts & 0x2) {
+				if (info->cb_loop) {
+					info->cb_loop(
+						info->cb_loop_data, sts, raw);
+				}
+			}
+		}
+	}
+
+	FNC_EXIT
+	return IRQ_HANDLED;
+}
+
+/* --------------------------------------------------------------
+   function : mp200_pwm_start
+   argument : channel  . channel number
+   -------------------------------------------------------------- */
+int mp200_pwm_start(unsigned char channel)
+{
+	struct pwm_info_t *pwm_info_p;
+	int err;
+	unsigned int reg_value;
+	unsigned long lock_flags;
+	FNC_ENTRY
+
+	if (pwm_init_flag) {
+		DEBUG_PRINT("pwm initialize error\n");
+		FNC_EXIT
+		return -EPERM;
+	}
+
+	/* check parameter */
+	err = check_validity_channel(channel);
+	if (err != 0) {
+		FNC_EXIT
+		return -ENODEV;
+	}
+	DEBUG_PRINT("channle ok (ch%d)\n", channel);
+
+	pwm_info_p = &g_pwm_info[channel];
+
+	spin_lock_irqsave(&spin_lock, lock_flags);
+
+	/* check state */
+	if (PWM_STATE_STOP != pwm_info_p->state) {
+		DEBUG_PRINT("device active now. ---> end for unlock.\n");
+		spin_unlock_irqrestore(&spin_lock, lock_flags);
+		FNC_EXIT return(-EBUSY);
+	}
+	DEBUG_PRINT("state ok (0x%08X)\n", pwm_info_p->state);
+
+	/* regist irq_handler */
+	/* 5,dev_id  field : use for regs */
+
+	/* read use ch(read mode reg) */
+	reg_value = inl(pwm_info_p->channel_mode);
+
+	if (!(reg_value &
+		(PWM_CMP_EN0_BIT | PWM_CMP_EN1_BIT | PWM_CMP_EN2_BIT))) {
+		/* counter all not use */
+		DEBUG_PRINT("compare counter no setting.\n");
+		spin_unlock_irqrestore(&spin_lock, lock_flags);
+		FNC_EXIT
+		return -EINVAL;
+	}
+
+	pwm_pwclk_start(channel);
+	if (PWM_STATE_STOP == g_pwm_info[(channel + 1) & 0x01].state) {
+		DEBUG_PRINT("device all stop in now. ---> enable irq.\n");
+		enable_irq(INT_PWM);
+	}
+	/* start countup */
+	outl(PWM_START_BIT_ON, pwm_info_p->channel_control);
+	DEBUG_PRINT("PWM Start.(CONTROL[0x%08X])\n",
+			pwm_info_p->channel_control);
+
+	/* change state */
+	pwm_info_p->state = PWM_STATE_START;
+
+	spin_unlock_irqrestore(&spin_lock, lock_flags);
+
+	FNC_EXIT
+	return 0;
+}
+EXPORT_SYMBOL(mp200_pwm_start);
+
+/* --------------------------------------------------------------
+   function : mp200_pwm_stop
+   explain  : stop pwm
+   argument : channel        : channel number
+   return   : BIOS_OK        : success
+	      BIOS_ERR_PARAM : parameter error
+   -------------------------------------------------------------- */
+int mp200_pwm_stop(unsigned char channel)
+{
+	int err;
+	unsigned long lock_flags;
+	FNC_ENTRY
+
+	if (pwm_init_flag) {
+		DEBUG_PRINT("pwm initialize error\n");
+		FNC_EXIT
+		return -EPERM;
+	}
+
+	/* check parameter */
+	err = check_validity_channel(channel);
+	if (err != 0) {
+		FNC_EXIT
+		return -ENODEV;
+	}
+
+	spin_lock_irqsave(&spin_lock, lock_flags);
+
+	/* check state */
+	if (PWM_STATE_STOP == g_pwm_info[channel].state) {
+		DEBUG_PRINT("device active now. ---> end for unlock.\n");
+		spin_unlock_irqrestore(&spin_lock, lock_flags);
+		FNC_EXIT
+		return 0;
+	}
+
+	/* stop countup */
+	outl(PWM_START_BIT_OFF, g_pwm_info[channel].channel_control);
+	DEBUG_PRINT("PWM Stop.(CONTROL[0x%08X])\n",
+			g_pwm_info[channel].channel_control);
+
+	/* change state */
+	g_pwm_info[channel].state = PWM_STATE_STOP;
+	if (PWM_STATE_STOP == g_pwm_info[(channel + 1) & 0x01].state) {
+		DEBUG_PRINT("device all stop in now. ---> disable irq..\n");
+		disable_irq(INT_PWM);
+	}
+	pwm_pwclk_stop(channel);
+
+	spin_unlock_irqrestore(&spin_lock, lock_flags);
+
+	FNC_EXIT
+	return 0;
+}
+EXPORT_SYMBOL(mp200_pwm_stop);
+
+/* --------------------------------------------------------------
+   function : mp200_pwm_set_channel_config
+   explain  : set pwm workings
+   argument : channel   : channel number
+	      ch_config : PWM configuration structure pointer
+   return   : BIOS_OK         : success
+	      BIOS_ERR_PARAM  : parameter error
+	      BIOS_ERR_CONFIG : illegal configuration structure member
+	      BIOS_ERR_STATE  : During counting
+   -------------------------------------------------------------- */
+int mp200_pwm_set_channel_config(unsigned char channel,
+		struct mp200_pwm_ch_config_t *ch_config)
+{
+	int err;
+	unsigned int mode_value;
+	unsigned int set_value;
+	unsigned int value;
+	unsigned int reg_int_sft;
+	struct pwm_info_t *pwm_info_p;
+	unsigned long lock_flags;
+	FNC_ENTRY
+
+	if (pwm_init_flag) {
+		DEBUG_PRINT("pwm initialize error\n");
+		FNC_EXIT
+		return -EPERM;
+	}
+
+	/* check parameter */
+	err = check_validity_channel(channel);
+	if (err != 0) {
+		FNC_EXIT
+		return -ENODEV;
+	}
+	if (NULL == ch_config) {
+		FNC_EXIT
+		return -EINVAL;
+	}
+
+	pwm_info_p = &g_pwm_info[channel];
+
+	spin_lock_irqsave(&spin_lock, lock_flags);
+
+	/* check state */
+	if (PWM_STATE_STOP != pwm_info_p->state) {
+		DEBUG_PRINT("device active now. ---> end for unlock.\n");
+		spin_unlock_irqrestore(&spin_lock, lock_flags);
+		FNC_EXIT return(-EBUSY);
+	}
+
+	/* check config argument value  */
+	if ((~PWM_MASK_CODE_COUNTER & ch_config->use_cmp)
+	      || (PWM_CODE_MODE_XOR < ch_config->mode)	/* max is MODE_XOR */
+	      || (~PWM_MASK_CODE_INVERSE & ch_config->inverse)
+	      || (~PWM_MASK_CODE_INTCOUNT & ch_config->interrupt_count)
+	      || (~PWM_MASK_CODE_INTLOOP & ch_config->interrupt_loop)) {
+		DEBUG_PRINT("argument invalid. end for unlock.\n");
+		spin_unlock_irqrestore(&spin_lock, lock_flags);
+		FNC_EXIT
+		return -EINVAL;
+	}
+
+	/* set use counters */
+	reg_int_sft = channel << 3;
+
+
+	/* read mode reg */
+	mode_value = inl(pwm_info_p->channel_mode) &
+			~PWM_MASK_MODE_SETBIT;
+
+	/* set mode */
+	mode_value |= ch_config->mode << PWM_MODE_SFT;
+
+	/* set use_cmp */
+	value = ch_config->use_cmp;
+	mode_value |= ((value & PWM_BIT_CMP2) << PWM_CMP_EN2_POS)
+		| ((value & PWM_BIT_CMP1) << PWM_CMP_EN1_POS)
+		| ((value & PWM_BIT_CMP0) << PWM_CMP_EN0_POS);
+
+	/* set inverse */
+	value = ch_config->inverse;
+	mode_value |= ((value & PWM_BIT_CMP2) << PWM_CMP_INV2_POS)
+		| ((value & PWM_BIT_CMP1) << PWM_CMP_INV1_POS)
+		| ((value & PWM_BIT_CMP0) << PWM_CMP_INV0_POS);
+	/* set mode reg */
+	outl(mode_value, pwm_info_p->channel_mode);
+
+	/* set interrupt count */
+	value = ch_config->interrupt_count;
+	set_value = ((value & PWM_BIT_CMP2) << PWM_CMP2_CENDSET_POS)
+		| ((value & PWM_BIT_CMP1) << PWM_CMP1_CENDSET_POS)
+		| ((value & PWM_BIT_CMP0) << PWM_CMP0_CENDSET_POS);
+
+	/* interrupt_loop */
+	value = ch_config->interrupt_loop;
+	set_value |= ((value & PWM_BIT_CMP2) << PWM_CMP2_LENDSET_POS)
+		| ((value & PWM_BIT_CMP1) << PWM_CMP1_LENDSET_POS)
+		| ((value & PWM_BIT_CMP0) << PWM_CMP0_LENDSET_POS);
+
+	/* set int disable reg */
+	outl((PWM_MASK_ENDSET_SETBIT << reg_int_sft), PWM_INTENCLR);
+
+	/* set int enable reg */
+	outl((set_value << reg_int_sft), PWM_INTENSET);
+
+	spin_unlock_irqrestore(&spin_lock, lock_flags);
+
+	FNC_EXIT
+	return 0;
+}
+EXPORT_SYMBOL(mp200_pwm_set_channel_config);
+
+/* --------------------------------------------------------------
+   function : mp200_pwm_get_channel_config;
+	    : get channnel status
+   argument : channel   ... ch number
+	      ch_config ... PWM configuration structure pointer
+   return   :
+   -------------------------------------------------------------- */
+int mp200_pwm_get_channel_config(unsigned char channel,
+		struct mp200_pwm_ch_config_t *ch_config)
+{
+	int err;
+	unsigned int reg_value;
+	FNC_ENTRY
+
+	if (pwm_init_flag) {
+		DEBUG_PRINT("pwm initialize error\n");
+		FNC_EXIT
+		return -EPERM;
+	}
+
+	/* check parameter */
+	err = check_validity_channel(channel);
+	if (err != 0) {
+		FNC_EXIT
+		return -ENODEV;
+	}
+	if ((NULL == ch_config)) {
+		FNC_EXIT
+		return -EINVAL;
+	}
+
+	/* read mode reg */
+	reg_value = inl(g_pwm_info[channel].channel_mode);
+
+	/* mode */
+	ch_config->mode = (reg_value & PWM_MASK_MODE) >> PWM_MODE_SFT;
+
+	/* use_cmp */
+	ch_config->use_cmp = ((reg_value & PWM_CMP_EN0_BIT) >> PWM_CMP_EN0_POS)
+		| ((reg_value & PWM_CMP_EN1_BIT) >> PWM_CMP_EN1_POS)
+		| ((reg_value & PWM_CMP_EN2_BIT) >> PWM_CMP_EN2_POS);
+
+	/* inverse */
+	ch_config->inverse =
+		((reg_value & PWM_CMP_INV0_BIT) >> PWM_CMP_INV0_POS)
+		| ((reg_value & PWM_CMP_INV1_BIT) >> PWM_CMP_INV1_POS)
+		| ((reg_value & PWM_CMP_INV2_BIT) >> PWM_CMP_INV2_POS);
+
+
+	/* read int enable reg */
+
+	reg_value = inl(PWM_INTENSET) >> (channel << 3);
+
+	/* int_count */
+	ch_config->interrupt_count =
+		((reg_value & PWM_CMP0_CENDSET_BIT) >> PWM_CMP0_CENDSET_POS)
+		| ((reg_value & PWM_CMP1_CENDSET_BIT) >> PWM_CMP1_CENDSET_POS)
+		| ((reg_value & PWM_CMP2_CENDSET_BIT) >> PWM_CMP2_CENDSET_POS);
+
+	/* interrupt_loop */
+	ch_config->interrupt_loop =
+		((reg_value & PWM_CMP0_LENDSET_BIT) >> PWM_CMP0_LENDSET_POS)
+		| ((reg_value & PWM_CMP1_LENDSET_BIT) >> PWM_CMP1_LENDSET_POS)
+		| ((reg_value & PWM_CMP2_LENDSET_BIT) >> PWM_CMP2_LENDSET_POS);
+
+	FNC_EXIT
+	return 0;
+}
+EXPORT_SYMBOL(mp200_pwm_get_channel_config);
+
+/* --------------------------------------------------------------
+   function : pwm_set_compare_config
+	      regist irq_handler, and compare counter parameters.
+   argument : channel
+	      <pwm_cmpcnt_state> : setting parameters.
+		.cmp
+		.delay
+		.lead_edge
+		.trail_edge
+		.total_cycel
+		.loop_count
+		.cb_info
+   return :
+   -------------------------------------------------------------- */
+int mp200_pwm_set_compare_counter(unsigned char channel,
+		struct mp200_pwm_cmpcnt_t *src_cmpcnt)
+{
+	unsigned int value;
+	int err;
+	unsigned char cmp;
+	struct mp200_pwm_cmpcnt_t *dst_cmpcnt;
+	struct mp200_pwm_cb_info_t *src_cb_info;
+	struct mp200_pwm_cb_info_t *dst_cb_info;
+	struct pwm_info_t *pwm_info_p;
+	unsigned long lock_flags;
+	FNC_ENTRY
+
+	if (pwm_init_flag) {
+		DEBUG_PRINT("pwm initialize error\n");
+		FNC_EXIT
+		return -EPERM;
+	}
+
+	err = check_validity_channel(channel);
+	if (err != 0) {
+		FNC_EXIT
+		return -ENODEV;
+	}
+	/* check parameter */
+	if (NULL == src_cmpcnt) {
+		FNC_EXIT
+		return -EINVAL;
+	}
+	err = check_validity_compare_counter(src_cmpcnt->cmp);
+	if (err != 0) {
+		DEBUG_PRINT("compare counter illegal(cmp=0x%04X)\n",
+				src_cmpcnt->cmp);
+		FNC_EXIT
+		return -ENODEV;
+	}
+
+	cmp = src_cmpcnt->cmp;
+	pwm_info_p = &g_pwm_info[channel];
+
+	spin_lock_irqsave(&spin_lock, lock_flags);
+
+	/* check state */
+	if (PWM_STATE_STOP != pwm_info_p->state) {
+		DEBUG_PRINT("device active now. ---> end for unlock.\n");
+		spin_unlock_irqrestore(&spin_lock, lock_flags);
+		FNC_EXIT return(-EBUSY);
+	}
+	dst_cmpcnt = &g_pwm_cmpcnt[channel][cmp];
+
+	/* check config (lead_edge < trail_edge <= total_cycle) */
+	if ((src_cmpcnt->lead_edge >= src_cmpcnt->trail_edge)
+	    || (src_cmpcnt->trail_edge > src_cmpcnt->total_cycle)) {
+		DEBUG_PRINT("(lead_edge < trail_edge <="
+				"total_cycle) error. ---> end for unlock.\n");
+		spin_unlock_irqrestore(&spin_lock, lock_flags);
+		FNC_EXIT
+		return -EINVAL;
+	}
+
+	/* read mode reg */
+	value = inl(pwm_info_p->channel_mode);
+	/* set reg */
+	outl(src_cmpcnt->delay, dst_cmpcnt->delay);
+	outl(src_cmpcnt->lead_edge, dst_cmpcnt->lead_edge);
+	outl(src_cmpcnt->trail_edge, dst_cmpcnt->trail_edge);
+	outl(src_cmpcnt->total_cycle, dst_cmpcnt->total_cycle);
+	if (src_cmpcnt->loop_count) {
+		outl(src_cmpcnt->loop_count, dst_cmpcnt->loop_count);
+		value |= PWM_CMP_ATST0_BIT << (cmp<<2); /* fixed loop */
+	} else {
+		value &= ~(PWM_CMP_ATST0_BIT << (cmp<<2)); /* infinity loop */
+	}
+	/* set mode reg */
+	outl(value, pwm_info_p->channel_mode);
+
+	/* save callback function & data */
+	if (src_cmpcnt->cb_info == NULL) {
+		DEBUG_PRINT("callback not use!!! ---> cb_info NULL set\n");
+		dst_cmpcnt->cb_info = NULL;
+	} else {
+		d0b("\n");
+		src_cb_info = src_cmpcnt->cb_info;
+
+		if ((src_cb_info->cb_count != NULL)
+		    || (src_cb_info->cb_loop != NULL)) {
+
+			d0b("\n");
+			/* set callback */
+			dst_cmpcnt->cb_info = &g_pwm_cb_info[channel][cmp];
+			dst_cb_info = dst_cmpcnt->cb_info;
+			src_cb_info = src_cmpcnt->cb_info;
+
+			if (src_cb_info->cb_count != NULL) {
+				d0b("\n");
+				dst_cb_info->cb_count = src_cb_info->cb_count;
+				dst_cb_info->cb_count_data
+				    = src_cb_info->cb_count_data;
+			} else {
+				d0b("\n");
+				dst_cb_info->cb_count = NULL;
+				dst_cb_info->cb_count_data = NULL;
+			}
+			if (src_cb_info->cb_loop != NULL) {
+				d0b("\n");
+				dst_cb_info->cb_loop = src_cb_info->cb_loop;
+				dst_cb_info->cb_loop_data
+				    = src_cb_info->cb_loop_data;
+			} else {
+				d0b("\n");
+				dst_cb_info->cb_loop = NULL;
+				dst_cb_info->cb_loop_data = NULL;
+			}
+		} else {
+			DEBUG_PRINT("ccounter/loop callback nothing!!!"
+					" ---> cb_info NULL set\n");
+			dst_cmpcnt->cb_info = NULL;
+		}
+	}
+	spin_unlock_irqrestore(&spin_lock, lock_flags);
+
+	FNC_EXIT
+	return 0;
+}
+EXPORT_SYMBOL(mp200_pwm_set_compare_counter);
+
+
+/* --------------------------------------------------------------
+   function : mp200_pwm_get_compare_counter
+   explain  : get pwm compare counter workings stat
+   argument : channel   : channel number
+	      ch_config : PWM compare counter configuration structure pointer
+   return   : BIOS_OK         : success
+	      BIOS_ERR_PARAM  : parameter error
+   -------------------------------------------------------------- */
+int mp200_pwm_get_compare_counter(unsigned char channel,
+		struct mp200_pwm_cmpcnt_t *pwm_cmpcnt)
+{
+	int err;
+	struct mp200_pwm_cb_info_t *info;
+	unsigned int mode_value;
+	struct pwm_info_t *pwm_info_p;
+	struct mp200_pwm_cmpcnt_t *cmpcnt_reg_p;
+	unsigned char cmp;
+	FNC_ENTRY
+
+	if (pwm_init_flag) {
+		DEBUG_PRINT("pwm initialize error\n");
+		FNC_EXIT
+		return -EPERM;
+	}
+
+	/* check parameter */
+	err = check_validity_channel(channel);
+	if (err != 0) {
+		FNC_EXIT
+		return -ENODEV;
+	}
+	if (pwm_cmpcnt == NULL) {
+		DEBUG_PRINT("pwm_cmcnt is NULL!\n");
+		FNC_EXIT
+		return -EINVAL;
+	}
+	cmp = pwm_cmpcnt->cmp;
+
+	err = check_validity_compare_counter(cmp);
+	if (err != 0) {
+		DEBUG_PRINT("compare counter illegal(cmp=0x%04X)\n", cmp);
+		FNC_EXIT
+		return -ENODEV;
+	}
+
+	pwm_info_p = &g_pwm_info[channel];
+	cmpcnt_reg_p = &g_pwm_cmpcnt[channel][cmp];
+
+	/* read reg */
+	pwm_cmpcnt->delay       = inl(cmpcnt_reg_p->delay);
+	pwm_cmpcnt->total_cycle = inl(cmpcnt_reg_p->total_cycle);
+	pwm_cmpcnt->lead_edge   = inl(cmpcnt_reg_p->lead_edge);
+	pwm_cmpcnt->trail_edge  = inl(cmpcnt_reg_p->trail_edge);
+	/* read mode reg */
+	mode_value = inl(pwm_info_p->channel_mode);
+	if (mode_value &  (PWM_CMP_ATST0_BIT << (cmp<<2)))
+		pwm_cmpcnt->loop_count	= inl(cmpcnt_reg_p->loop_count);
+	else
+		pwm_cmpcnt->loop_count	= 0;
+
+	/* load callback function & data */
+	if (NULL != pwm_cmpcnt->cb_info) {
+		DEBUG_PRINT("cb_info is not NULL.\n");
+
+		if (NULL == cmpcnt_reg_p->cb_info) {
+			pwm_cmpcnt->cb_info->cb_count = NULL;
+			pwm_cmpcnt->cb_info->cb_count_data = NULL;
+			pwm_cmpcnt->cb_info->cb_loop = NULL;
+			pwm_cmpcnt->cb_info->cb_loop_data = NULL;
+		} else {
+		/* regist irq_interrupt() */
+			info = cmpcnt_reg_p->cb_info;
+			if (NULL == info->cb_count) {
+				pwm_cmpcnt->cb_info->cb_count = NULL;
+				pwm_cmpcnt->cb_info->cb_count_data = NULL;
+			} else {
+				pwm_cmpcnt->cb_info->cb_count = info->cb_count;
+				if (NULL == info->cb_count_data)
+					pwm_cmpcnt->cb_info->cb_count_data
+						= NULL;
+				else
+					pwm_cmpcnt->cb_info->cb_count_data
+						= info->cb_count_data;
+			}
+			if (NULL == info->cb_loop) {
+				pwm_cmpcnt->cb_info->cb_loop = NULL;
+				pwm_cmpcnt->cb_info->cb_loop_data = NULL;
+			} else {
+				pwm_cmpcnt->cb_info->cb_loop = info->cb_loop;
+				if (NULL == info->cb_loop_data)
+					pwm_cmpcnt->cb_info->cb_loop_data
+						= NULL;
+				else
+					pwm_cmpcnt->cb_info->cb_loop_data
+						= info->cb_loop_data;
+			}
+		}
+	}
+#if	defined(MP200_PWM_DEBUG)
+	else
+		DEBUG_PRINT("cb_info is NULL!!\n");
+#endif
+
+	FNC_EXIT
+	return 0;
+}
+EXPORT_SYMBOL(mp200_pwm_get_compare_counter);
+
+
+/*
+ * init
+ */
+static int __init pwm_init(void)
+{
+	int ret = 0;
+	int i, j;
+
+	FNC_ENTRY
+	/* pwc start */
+
+	printk(KERN_INFO "Starting %s.\n", PWM_NAME);
+
+	/* stop clock */
+	pwm_clock_stop();
+
+#if 0
+	spin_lock_irq(&spin_lock);
+	/* pin select change to pwm */
+	outl(inl(CHG_PINSEL_G80) | PWM_PINSEL_MASK,
+			CHG_PINSEL_G80); /* BIT[31:28]: 0x5,PWM: */
+	spin_unlock_irq(&spin_lock);
+#endif
+
+	for (i = 0; i < PWM_MAX_CHANNEL_NUM; i++) {
+		for (j = 0; j < PWM_MAX_COUNTER_NUM; j++) {
+			g_pwm_cb_info[i][j].cb_count = NULL;
+			g_pwm_cb_info[i][j].cb_count_data = NULL;
+			g_pwm_cb_info[i][j].cb_loop = NULL;
+			g_pwm_cb_info[i][j].cb_loop_data = NULL;
+		}
+	}
+
+	outl(PWM_INIT_CLOCK, SMU_DIVPWMPWCLK);
+
+	/* supply clock */
+	pwm_clock_start();
+	/* unreset PWM */
+	pwm_dev_unreset();
+
+	/* stop pwclk[0-1] */
+	pwm_pwclk_stop(MP200_PWM_CH0);
+	pwm_pwclk_stop(MP200_PWM_CH1);
+
+	/* regist irq handler */
+	ret = request_irq(INT_PWM, pwm_irq_handler, IRQF_DISABLED, PWM_NAME, 0);
+	if (ret != 0) {
+		printk(KERN_INFO
+			"%s(): unable to request IRQ %d for PWM channel \n",
+			__func__, INT_PWM);
+		/* stop clock */
+		pwm_clock_stop();
+		FNC_EXIT return(ret);
+	}
+
+	disable_irq(INT_PWM);
+
+	pwm_init_flag = 0;
+
+	FNC_EXIT
+	return 0;
+}
+
+/*
+ * exit
+ */
+static void __exit pwm_exit(void)
+{
+	FNC_ENTRY
+
+	pwm_init_flag = 1;
+
+	free_irq(INT_PWM, 0);
+
+	/* stop clock */
+	pwm_clock_stop();
+
+	FNC_EXIT return;
+}
+
+
+#ifdef MODULE
+module_init(pwm_init);
+module_exit(pwm_exit);
+#else
+device_initcall(pwm_init);
+__exitcall(pwm_exit);
+#endif
+
+
+#ifdef MODULE
+#ifdef MP200_DEBUG
+module_param(debug,  int, 0644);
+#endif
+MODULE_AUTHOR("2008 NEC ELECTRONICS CORPORATION");
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("'PWM' pulse width moduration device driver.");
+MODULE_SUPPORTED_DEVICE("");
+#endif
diff --git a/drivers/char/mp200_pwm.h b/drivers/char/mp200_pwm.h
new file mode 100644
index 0000000..3ac02f6
--- /dev/null
+++ b/drivers/char/mp200_pwm.h
@@ -0,0 +1,173 @@
+/*
+ *  File Name       : drivers/char/mp200_pwm.h
+ *  Function        : SPI interface
+ *  Release Version : Ver 0.10
+ *  Release Date    : 2006/03/20
+ *
+ *  Copyright (C) NEC Electronics Corporation 2006
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#ifndef __DRIVERS_CHAR_MP200_PWM_H
+#define __DRIVERS_CHAR_MP200_PWM_H
+
+#include <mach/pmu.h>
+
+#define PWM_MAX_CHANNEL_NUM	2
+#define PWM_MAX_COUNTER_NUM	3
+
+#define PWM_DIVPWMPWCLK     SMU_DIV8
+#define PWM_INIT_CLOCK      (PWM_DIVPWMPWCLK | (PWM_DIVPWMPWCLK << 16))
+
+/* device name */
+#define PWM_NAME		"pwm"
+
+#define PWM_CODE_COUNTER0	0x01
+#define PWM_CODE_COUNTER1	0x02
+#define PWM_CODE_COUNTER2	0x04
+#define PWM_MASK_CODE_COUNTER	0x07
+#define PWM_MASK_CODE_INVERSE	0x07
+#define PWM_MASK_CODE_INTCOUNT	0x07
+#define PWM_MASK_CODE_INTLOOP	0x07
+
+#define PWM_STATE_STOP		1
+#define PWM_STATE_START		2
+
+#define PWM_PINSEL_MASK		0x50000000	/* set 0x5 is PWM */
+
+#define	PWM_START_BIT_ON	0x00000001	/* count start */
+#define	PWM_START_BIT_OFF	0x00000000	/* count stop */
+
+#define PWM_MASK_MODE		0x00030000
+#define PWM_MODE_SFT		16
+
+#define PWM_CMP_ATST2_BIT	0x00000200
+#define PWM_CMP_ATST1_BIT	0x00000020
+#define PWM_CMP_ATST0_BIT	0x00000002
+#define PWM_CMP_ATST2_SFT	9
+#define PWM_CMP_ATST1_SFT	5
+#define PWM_CMP_ATST0_SFT	1
+
+#define PWM_CMP_EN2_BIT		0x00000100
+#define PWM_CMP_EN1_BIT		0x00000010
+#define PWM_CMP_EN0_BIT		0x00000001
+#define PWM_CMP_EN2_SFT		8
+#define PWM_CMP_EN1_SFT		4
+#define PWM_CMP_EN0_SFT		0
+#define PWM_CMP_EN2_POS		(PWM_CMP_EN2_SFT-2)
+#define PWM_CMP_EN1_POS		(PWM_CMP_EN1_SFT-1)
+#define PWM_CMP_EN0_POS		(PWM_CMP_EN0_SFT-0)
+
+#define PWM_CMP_INV2_BIT	0x00000400
+#define PWM_CMP_INV1_BIT	0x00000040
+#define PWM_CMP_INV0_BIT	0x00000004
+#define PWM_CMP_INV2_SFT	10
+#define PWM_CMP_INV1_SFT	6
+#define PWM_CMP_INV0_SFT	2
+#define PWM_CMP_INV2_POS	(PWM_CMP_INV2_SFT-2)
+#define PWM_CMP_INV1_POS	(PWM_CMP_INV1_SFT-1)
+#define PWM_CMP_INV0_POS	(PWM_CMP_INV0_SFT-0)
+
+#define PWM_MASK_MODE_SETBIT \
+	(PWM_MASK_MODE | PWM_CMP_EN2_BIT | PWM_CMP_EN1_BIT | \
+	 PWM_CMP_EN0_BIT | PWM_CMP_INV2_BIT | PWM_CMP_INV1_BIT | \
+	 PWM_CMP_INV0_BIT)
+
+
+#define PWM_CMP2_CENDSET_BIT	0x00000010
+#define PWM_CMP1_CENDSET_BIT	0x00000004
+#define PWM_CMP0_CENDSET_BIT	0x00000001
+#define PWM_CMP2_CENDSET_SFT	4
+#define PWM_CMP1_CENDSET_SFT	2
+#define PWM_CMP0_CENDSET_SFT	0
+#define PWM_CMP2_CENDSET_POS	(PWM_CMP2_CENDSET_SFT-2)
+#define PWM_CMP1_CENDSET_POS	(PWM_CMP1_CENDSET_SFT-1)
+#define PWM_CMP0_CENDSET_POS	(PWM_CMP0_CENDSET_SFT-0)
+
+#define PWM_CMP2_LENDSET_BIT	0x00000020
+#define PWM_CMP1_LENDSET_BIT	0x00000008
+#define PWM_CMP0_LENDSET_BIT	0x00000002
+#define PWM_CMP2_LENDSET_SFT	5
+#define PWM_CMP1_LENDSET_SFT	3
+#define PWM_CMP0_LENDSET_SFT	1
+#define PWM_CMP2_LENDSET_POS	(PWM_CMP2_LENDSET_SFT-2)
+#define PWM_CMP1_LENDSET_POS	(PWM_CMP1_LENDSET_SFT-1)
+#define PWM_CMP0_LENDSET_POS	(PWM_CMP0_LENDSET_SFT-0)
+
+
+#define PWM_MASK_ENDSET_SETBIT \
+	(PWM_CMP2_CENDSET_BIT | PWM_CMP1_CENDSET_BIT | \
+	 PWM_CMP0_CENDSET_BIT | PWM_CMP2_LENDSET_BIT | \
+	 PWM_CMP1_LENDSET_BIT | PWM_CMP0_LENDSET_BIT)
+
+
+/* -------- */
+
+#define PWM_CH0_CTRL			(IO_ADDRESS(MP200_PWM_BASE) + 0x0000)
+#define PWM_CH0_MODE			(IO_ADDRESS(MP200_PWM_BASE) + 0x0004)
+#define PWM_CH0_DELAY0			(IO_ADDRESS(MP200_PWM_BASE) + 0x0010)
+#define PWM_CH0_LEDGE0			(IO_ADDRESS(MP200_PWM_BASE) + 0x0014)
+#define PWM_CH0_TEDGE0			(IO_ADDRESS(MP200_PWM_BASE) + 0x0018)
+#define PWM_CH0_TOTAL0			(IO_ADDRESS(MP200_PWM_BASE) + 0x001C)
+#define PWM_CH0_LOOP0			(IO_ADDRESS(MP200_PWM_BASE) + 0x0020)
+#define PWM_CH0_DELAY1			(IO_ADDRESS(MP200_PWM_BASE) + 0x0040)
+#define PWM_CH0_LEDGE1			(IO_ADDRESS(MP200_PWM_BASE) + 0x0044)
+#define PWM_CH0_TEDGE1			(IO_ADDRESS(MP200_PWM_BASE) + 0x0048)
+#define PWM_CH0_TOTAL1			(IO_ADDRESS(MP200_PWM_BASE) + 0x004C)
+#define PWM_CH0_LOOP1			(IO_ADDRESS(MP200_PWM_BASE) + 0x0050)
+#define PWM_CH0_DELAY2			(IO_ADDRESS(MP200_PWM_BASE) + 0x0080)
+#define PWM_CH0_LEDGE2			(IO_ADDRESS(MP200_PWM_BASE) + 0x0084)
+#define PWM_CH0_TEDGE2			(IO_ADDRESS(MP200_PWM_BASE) + 0x0088)
+#define PWM_CH0_TOTAL2			(IO_ADDRESS(MP200_PWM_BASE) + 0x008C)
+#define PWM_CH0_LOOP2			(IO_ADDRESS(MP200_PWM_BASE) + 0x0090)
+
+#define PWM_CH1_CTRL			(IO_ADDRESS(MP200_PWM_BASE) + 0x0100)
+#define PWM_CH1_MODE			(IO_ADDRESS(MP200_PWM_BASE) + 0x0104)
+#define PWM_CH1_DELAY0			(IO_ADDRESS(MP200_PWM_BASE) + 0x0110)
+#define PWM_CH1_LEDGE0			(IO_ADDRESS(MP200_PWM_BASE) + 0x0114)
+#define PWM_CH1_TEDGE0			(IO_ADDRESS(MP200_PWM_BASE) + 0x0118)
+#define PWM_CH1_TOTAL0			(IO_ADDRESS(MP200_PWM_BASE) + 0x011C)
+#define PWM_CH1_LOOP0			(IO_ADDRESS(MP200_PWM_BASE) + 0x0120)
+#define PWM_CH1_DELAY1			(IO_ADDRESS(MP200_PWM_BASE) + 0x0140)
+#define PWM_CH1_LEDGE1			(IO_ADDRESS(MP200_PWM_BASE) + 0x0144)
+#define PWM_CH1_TEDGE1			(IO_ADDRESS(MP200_PWM_BASE) + 0x0148)
+#define PWM_CH1_TOTAL1			(IO_ADDRESS(MP200_PWM_BASE) + 0x014C)
+#define PWM_CH1_LOOP1			(IO_ADDRESS(MP200_PWM_BASE) + 0x0150)
+#define PWM_CH1_DELAY2			(IO_ADDRESS(MP200_PWM_BASE) + 0x0180)
+#define PWM_CH1_LEDGE2			(IO_ADDRESS(MP200_PWM_BASE) + 0x0184)
+#define PWM_CH1_TEDGE2			(IO_ADDRESS(MP200_PWM_BASE) + 0x0188)
+#define PWM_CH1_TOTAL2			(IO_ADDRESS(MP200_PWM_BASE) + 0x018C)
+#define PWM_CH1_LOOP2			(IO_ADDRESS(MP200_PWM_BASE) + 0x0190)
+
+/* ---------------
+   PWM Interrupt
+   --------------- */
+#define PWM_INTSTATUS			(IO_ADDRESS(MP200_PWM_BASE) + 0x0400)
+#define PWM_INTRAWSTATUS		(IO_ADDRESS(MP200_PWM_BASE) + 0x0404)
+#define PWM_INTENSET			(IO_ADDRESS(MP200_PWM_BASE) + 0x0408)
+#define PWM_INTENCLR			(IO_ADDRESS(MP200_PWM_BASE) + 0x040C)
+#define PWM_INTFFCLR			(IO_ADDRESS(MP200_PWM_BASE) + 0x0410)
+/* -------- */
+
+struct pwm_info_t {
+	unsigned int state;
+	unsigned int channel_control;
+	unsigned int channel_mode;
+};
+
+#endif
+
-- 
1.6.5.2

