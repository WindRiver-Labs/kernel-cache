From b7f2f8a129f9b60bd4dd6e53ebf66be02373e9c8 Mon Sep 17 00:00:00 2001
From: Kazuya Tsukamoto <kazuya.tsukamoto@necel.com>
Date: Mon, 9 Nov 2009 12:08:22 +0900
Subject: [PATCH 14/29] nec_em1: introduce PowerIC(DA9052) support

Allow access PowerIC(DA9052) on the EMMA Mobile 1 board.

Note: the PowerIC has registers up to 142, but this driver can only
access up to 127. This is fine because user access is not required
in most scenarios.

Signed-off-by: Kazuya Tsukamoto <kazuya.tsukamoto@necel.com>
---
 arch/arm/mach-mp200/include/mach/pwc.h |  357 +++++++++
 drivers/char/mp200_pwc.c               | 1308 ++++++++++++++++++++++++++++++++
 2 files changed, 1665 insertions(+), 0 deletions(-)
 create mode 100644 arch/arm/mach-mp200/include/mach/pwc.h
 create mode 100644 drivers/char/mp200_pwc.c

diff --git a/arch/arm/mach-mp200/include/mach/pwc.h b/arch/arm/mach-mp200/include/mach/pwc.h
new file mode 100644
index 0000000..92e0e1a
--- /dev/null
+++ b/arch/arm/mach-mp200/include/mach/pwc.h
@@ -0,0 +1,357 @@
+/*
+ *  File Name       : linux/include/asm-arm/arch-mp200/pwc.h
+ *  Function        : pwc
+ *  Release Version : Ver 1.00
+ *  Release Date    : 2007/06/25
+ *
+ *  Copyright (C) NEC Electronics Corporation 2007
+ *
+ *
+ *  This program is free software;you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License as published by Free
+ *  Softwere Foundation; either version 2 of License,
+ *  or (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY;
+ *  without even the implied warrnty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.
+ *  See the GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public
+ *  License along with this program;
+ *  If not, write to the Free Software Foundation, Inc., 59 Temple
+ *  Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+#ifndef _ASM_ARCH_PWC_H_
+#define _ASM_ARCH_PWC_H_
+
+/* Power register */
+#ifdef CONFIG_MP200_EM1_DKIT
+
+/* System control and event registers */
+#define DA9052_PAGECON0_REG		(0) /* read/write */
+#define DA9052_STATUSA_REG		(1) /* read */
+#define DA9052_STATUSB_REG		(2) /* read */
+#define DA9052_STATUSC_REG		(3) /* read */
+#define DA9052_STATUSD_REG		(4) /* read */
+#define DA9052_EVENTA_REG		(5) /* read */
+#define DA9052_EVENTB_REG		(6) /* read */
+#define DA9052_EVENTC_REG		(7) /* read */
+#define DA9052_EVENTD_REG		(8) /* read */
+#define DA9052_FAULTLOG_REG		(9) /* read */
+#define DA9052_IRQMASKA_REG		(10) /* read/write */
+#define DA9052_IRQMASKB_REG		(11) /* read/write */
+#define DA9052_IRQMASKC_REG		(12) /* read/write */
+#define DA9052_IRQMASKD_REG		(13) /* read/write */
+#define DA9052_CONTROLA_REG		(14) /* read/write */
+#define DA9052_CONTROLB_REG		(15) /* read/write */
+#define DA9052_CONTROLC_REG		(16) /* read/write */
+#define DA9052_CONTROLD_REG		(17) /* read/write */
+#define DA9052_PDDIS_REG		(18) /* read/write */
+#define DA9052_INTERFACE_REG	(19) /* read */
+#define DA9052_RESET_REG		(20) /* read/write */
+
+/* GPIO control registers */
+#define DA9052_GPIO0001_REG		(21) /* read/write */
+#define DA9052_GPIO0203_REG		(22) /* read/write */
+#define DA9052_GPIO0405_REG		(23) /* read/write */
+#define DA9052_GPIO0607_REG		(24) /* read/write */
+#define DA9052_GPIO0809_REG		(25) /* read/write */
+#define DA9052_GPIO1011_REG		(26) /* read/write */
+#define DA9052_GPIO1213_REG		(27) /* read/write */
+#define DA9052_GPIO1415_REG		(28) /* read/write bit3 read only */
+
+/* Power sequencer control registers */
+#define DA9052_ID01_REG			(29) /* read/write */
+#define DA9052_ID23_REG			(30) /* read/write */
+#define DA9052_ID45_REG			(31) /* read/write */
+#define DA9052_ID67_REG			(32) /* read/write */
+#define DA9052_ID89_REG			(33) /* read/write */
+#define DA9052_ID1011_REG		(34) /* read/write */
+#define DA9052_ID1213_REG		(35) /* read/write */
+#define DA9052_ID1415_REG		(36) /* read/write */
+#define DA9052_ID1617_REG		(37) /* read/write */
+#define DA9052_ID1819_REG		(38) /* read/write */
+#define DA9052_ID2021_REG		(39) /* read/write */
+#define DA9052_SEQSTATUS_REG	(40) /* read/write */
+#define DA9052_SEQA_REG			(41) /* read/write */
+#define DA9052_SEQB_REG			(42) /* read/write */
+#define DA9052_SEQTIMER_REG		(43) /* read/write */
+
+/* Power supply control registers */
+#define DA9052_BUCKA_REG		(44) /* read/write */
+#define DA9052_BUCKB_REG		(45) /* read/write */
+#define DA9052_BUCKCORE_REG		(46) /* read/write */
+#define DA9052_BUCKPRO_REG		(47) /* read/write */
+#define DA9052_BUCKMEM_REG		(48) /* read/write */
+#define DA9052_BUCKPERI_REG		(49) /* read/write bit6 read only*/
+#define DA9052_LDO1_REG			(50) /* read/write bit5 read only*/
+#define DA9052_LDO2_REG			(51) /* read/write */
+#define DA9052_LDO3_REG			(52) /* read/write */
+#define DA9052_LDO4_REG			(53) /* read/write */
+#define DA9052_LDO5_REG			(54) /* read/write */
+#define DA9052_LDO6_REG			(55) /* read/write */
+#define DA9052_LFO7_REG			(56) /* read/write */
+#define DA9052_LDO8_REG			(57) /* read/write */
+#define DA9052_LDO9_REG			(58) /* read/write */
+#define DA9052_LDO10_REG		(59) /* read/write */
+#define DA9052_SUPPLY_REG		(60) /* read/write */
+#define DA9052_PULLDOWN_REG		(61) /* read/write */
+
+/* Charging control registers */
+#define DA9052_CHGBUCK_REG		(62) /* read/write */
+#define DA9052_WAITCONT_REG		(63) /* read/write */
+#define DA9052_ISET_REG			(64) /* read/write */
+#define DA9052_BATCHG_REG		(65) /* read/write */
+#define DA9052_CHGCONT_REG		(66) /* read/write */
+#define DA9052_INPUTCONT_REG	(67) /* read */
+#define DA9052_CHGTIME_REG		(68) /* read/write */
+
+/* Backup battery charging control registers */
+#define DA9052_BBATCONT_REG		(69) /* read/write */
+
+/* Boost and LED driver control registers */
+#define DA9052_BOOST_REG		(70) /* read/write bit7 read only*/
+#define DA9052_LEDCONT_REG		(71) /* read/write bit7 read only*/
+#define DA9052_LEDMIN123_REG	(72) /* read/write */
+#define DA9052_LED1CONF_REG		(73) /* read/write */
+#define DA9052_LED2CONF_REG		(74) /* read/write */
+#define DA9052_LED3CONF_REG		(75) /* read/write */
+#define DA9052_LED1CONT_REG		(76) /* read/write */
+#define DA9052_LED2CONT_REG		(77) /* read/write */
+#define DA9052_LED3CONT_REG		(78) /* read/write */
+#define DA9052_LED4CONT_REG		(79) /* read/write */
+#define DA9052_LED5CONT_REG		(80) /* read/write */
+
+/* GP-ADC control registers */
+#define DA9052_ADCMAN_REG		(81) /* read/write bit7-5 read only*/
+#define DA9052_ADCCONT_REG		(82) /* read/write */
+#define DA9052_ADCRESL_REG		(83) /* read */
+#define DA9052_ADCRESH_REG		(84) /* read */
+#define DA9052_VDDRES_REG		(85) /* read */
+#define DA9052_VDDMON_REG		(86) /* read/write */
+#define DA9052_ICHGAV_REG		(87) /* read */
+#define DA9052_ICHGTHD_REG		(88) /* read/write */
+#define DA9052_ICHGEND_REG		(89) /* read/write */
+#define DA9052_TBATRES_REG		(90) /* read */
+#define DA9052_TBATHIGHP_REG		(91) /* read/write */
+#define DA9052_TBATHIGHIN_REG		(92) /* read/write */
+#define DA9052_TBATLOW_REG		(93) /* read/write */
+#define DA9052_TOFFSET_REG		(94) /* read/write */
+#define DA9052_ADCIN4RES_REG		(95) /* read */
+#define DA9052_AUTO4HIGH_REG		(96) /* read/write */
+#define DA9052_AUTO4LOW_REG		(97) /* read/write */
+#define DA9052_ADCIN5RES_REG		(98) /* read */
+#define DA9052_AUTO5HIGH_REG		(99) /* read/write */
+#define DA9052_AUTO5LOW_REG		(100) /* read/write */
+#define DA9052_ADCIN6RES_REG		(101) /* read */
+#define DA9052_AUTO6HIGH_REG		(102) /* read/write */
+#define DA9052_AUTO6LOW_REG		(103) /* read/write */
+#define DA9052_TJUNCRES_REG		(104) /* read */
+
+/* TSI control registers */
+#define DA9052_TSICONTA_REG		(105) /* read/write */
+#define DA9052_TSICONTB_REG		(106) /* read/write */
+#define DA9052_TSIXMSB_REG		(107) /* read */
+#define DA9052_TSIYMSB_REG		(108) /* read */
+#define DA9052_TSILSB_REG		(109) /* read */
+#define DA9052_TSIZMSB_REG		(110) /* read */
+
+/* RTC calendar and alarm */
+#define DA9052_COUNTS_REG		(111) /* read/write bit7 read only*/
+#define DA9052_COUNTMI_REG		(112) /* read/write bit7-6 read only*/
+#define DA9052_COUNTH_REG		(113) /* read/write bit7-5 read only*/
+#define DA9052_COUNTD_REG		(114) /* read/write bit7-5 read only*/
+#define DA9052_COUNTMO_REG		(115) /* read/write bit7-4 read only*/
+#define DA9052_COUNTY_REG		(116) /* read/write */
+#define DA9052_ALARMMI_REG		(117) /* read/write */
+#define DA9052_ALARMH_REG		(118) /* read/write bit7-5 read only */
+#define DA9052_ALARMD_REG		(119) /* read/write bit7-5 read only */
+#define DA9052_ALARMMO_REG		(120) /* read/write bit7-4 read only */
+#define DA9052_ALARMY_REG		(121) /* read/write */
+#define DA9052_SECONDA_REG		(122) /* read */
+#define DA9052_SECONDB_REG		(123) /* read */
+#define DA9052_SECONDC_REG		(124) /* read */
+#define DA9052_SECONDD_REG		(125) /* read */
+
+#if 0
+/* Customer OTP */
+#define DA9052_PAGECON128_REG		(128) /* read/write */
+#define DA9052_CHIPID_REG		(129) /* read */
+#define DA9052_CONFIGID_REG		(130) /* read */
+#define DA9052_OTPCONT_REG		(131) /* read/write bit5-4 read only */
+#define DA9052_OSCTRIM_REG		(132) /* read/write */
+#define DA9052_GPID0_REG		(133) /* read/write */
+#define DA9052_GPID1_REG		(134) /* read/write */
+#define DA9052_GPID2_REG		(135) /* read/write */
+#define DA9052_GPID3_REG		(136) /* read/write */
+#define DA9052_GPID4_REG		(137) /* read/write */
+#define DA9052_GPID5_REG		(138) /* read/write */
+#define DA9052_GPID6_REG		(139) /* read/write */
+#define DA9052_GPID7_REG		(140) /* read/write */
+#define DA9052_GPID8_REG		(141) /* read/write */
+#define DA9052_GPID9_REG		(142) /* read/write */
+
+#define DA9052_PAGE1_REG_START	(DA9052_CHIPID_REG)
+#define DA9052_PAGE1_REG_END	(DA9052_GPID9_REG)
+#endif
+
+#define DA9052_PAGE0_REG_START	(DA9052_STATUSA_REG)
+#define DA9052_PAGE0_REG_END	(DA9052_SECONDD_REG)
+
+#define PWC_MAX			125
+
+
+#else /* CONFIG_MP200_EM1_DKIT */
+
+#define PWC_REGA		0x0002	/* write */
+#define PWC_PSCNT1		0x0004	/* write */
+#define PWC_PSCNT2		0x0006	/* write */
+#define PWC_MODESET1	0x0008	/* write */
+#define PWC_VOUTSET1	0x000A	/* write */
+#define PWC_VOUTSET2	0x000C	/* write */
+#define PWC_VOUTSET3	0x000E	/* write */
+
+/* GPIO register */
+#define PWC_IOSEL1		0x0010	/* write */
+#define PWC_IOSEL2		0x0012	/* write */
+#define PWC_IOOUT1		0x0014	/* write */
+#define PWC_IOIN1		0x0015	/* read  */
+#define PWC_IOOUT2		0x0016	/* write */
+#define PWC_IOIN2		0x0017	/* read  */
+#define PWC_GPPUPD1		0x0018	/* write */
+#define PWC_GPPUPD2		0x001A	/* write */
+#define PWC_GPPUPD3		0x001C	/* write */
+#define PWC_GPPUPD4		0x001E	/* write */
+
+/* INTC register */
+#define PWC_FMASK1		0x0020	/* write */
+#define PWC_FACTOR1		0x0021	/* read  */
+#define PWC_FMASK2		0x0022	/* write */
+#define PWC_FACTOR2		0x0023	/* read  */
+#define PWC_FMASK3		0x0024	/* write */
+#define PWC_FACTOR3		0x0025	/* read  */
+#define PWC_STATE1		0x0026	/* write */
+#define PWC_STATE2		0x0028	/* write */
+#define PWC_STATE3		0x002A	/* write */
+#define PWC_CLRFACT1	0x002C	/* write */
+#define PWC_CLRFACT2	0x002E	/* write */
+#define PWC_CLRFACT3	0x0030	/* write */
+#define PWC_DETMOD1L	0x0032	/* write */
+#define PWC_DETMOD1H	0x0034	/* write */
+#define PWC_DETMOD2L	0x0036	/* write */
+#define PWC_DETMOD2H	0x0038	/* write */
+#define PWC_DETMOD3L	0x003A	/* write */
+#define PWC_DETMOD3H	0x003C	/* write */
+#define PWC_BMASK1		0x003E	/* write */
+#define PWC_BMASK2		0x0040	/* write */
+#define PWC_BMASK3		0x0042	/* write */
+#define PWC_REGPWONMSK	0x004C	/* write */
+#define PWC_WRSTFCT		0x006D	/* read  */
+#define PWC_WRSTCL		0x006E	/* write */
+#define PWC_WRSTMSK		0x0092	/* write */
+#define PWC_WAKECONT	0x0094	/* write */
+
+/* Power switch register */
+#define PWC_PSW_STATE	0x0065	/* read  */
+
+/* ADC register */
+#define PWC_ADDATA1		0x004D	/* read  */
+#define PWC_ADMODE		0x004E	/* write */
+#define PWC_ADDATA2		0x004F	/* read  */
+#define PWC_VCCVBATSW	0x0050	/* write */
+#define PWC_ADDATA3		0x0051	/* read  */
+#define PWC_VCCADPSW	0x0052	/* write */
+#define PWC_VCCVBUSSW	0x0052	/* write */
+#define PWC_ADDATA4		0x0053	/* read  */
+#define PWC_ADDATA5		0x0055	/* read  */
+#define PWC_ADDATA6		0x0057	/* read  */
+#define PWC_ADDATA7		0x0059	/* read  */
+#define PWC_ADDATA8		0x005B	/* read  */
+
+/* Charge register */
+#define PWC_CHGCNTR1	0x005C	/* write */
+#define PWC_CHGIRR		0x005D	/* read  */
+#define PWC_CHGIRCL		0x005E	/* write */
+#define PWC_CHGSTATE	0x005F	/* read  */
+#define PWC_TIMCNTR		0x0060	/* write */
+#define PWC_CVSETR		0x0062	/* write */
+#define PWC_CHGCNTR2	0x0064	/* write */
+
+/* Reset register */
+#define PWC_SFTRST		0x0066	/* write */
+#define PWC_RDET_EN		0x0068	/* write */
+#define PWC_PWRSWCONT	0x006A	/* write */
+#define PWC_DETIOCONT	0x006C	/* write */
+
+/* LSI discrimination register */
+#define PWC_LSIVER		0x006F	/* read  */
+
+/* RTC register */
+#define PWC_SEC			0x0070	/* write */
+#define PWC_SEC_RD		0x0071	/* read  */
+#define PWC_MIN			0x0072	/* write */
+#define PWC_MIN_RD		0x0073	/* read  */
+#define PWC_HOUR		0x0074	/* write */
+#define PWC_HOUR_RD		0x0075	/* read  */
+#define PWC_WEEK		0x0076	/* write */
+#define PWC_WEEK_RD		0x0077	/* read  */
+#define PWC_DAY			0x0078	/* write */
+#define PWC_DAY_RD		0x0079	/* read  */
+#define PWC_MONTH		0x007A	/* write */
+#define PWC_MONTH_RD	0x007B	/* read  */
+#define PWC_YEAR		0x007C	/* write */
+#define PWC_YEAR_RD		0x007D	/* read  */
+#define PWC_TRIM		0x007E	/* write */
+#define PWC_TRIM_RD		0x007F	/* read  */
+#define PWC_ALM_WM		0x0080	/* write */
+#define PWC_ALM_WM_RD	0x0081	/* read  */
+#define PWC_ALM_WH		0x0082	/* write */
+#define PWC_ALM_WH_RD	0x0083	/* read  */
+#define PWC_ALM_WW		0x0084	/* write */
+#define PWC_ALM_WW_RD	0x0085	/* read  */
+#define PWC_ALM_DM		0x0086	/* write */
+#define PWC_ALM_DM_RD	0x0087	/* read  */
+#define PWC_ALM_DH		0x0088	/* write */
+#define PWC_ALM_DH_RD	0x0089	/* read  */
+#define PWC_RTC1		0x008A	/* write */
+#define PWC_RTC1_RD		0x008B	/* read  */
+#define PWC_RTC2		0x008C	/* write */
+#define PWC_RTC2_RD		0x008D	/* read  */
+
+/* USB register */
+#define PWC_USBCONT		0x0090	/* write */
+
+#define PWC_MAX			0x0095
+
+#endif /* CONFIG_MP200_EM1_DKIT */
+
+/* GPIO port */
+#define PWC_INT_B0		0x00
+#define PWC_INT_B1		0x01
+#define PWC_INT_B2		0x02
+#define PWC_INT_B3		0x03
+#define PWC_INT_B4		0x04
+#define PWC_INT_B5		0x05
+#define PWC_INT_B6		0x06
+#define PWC_INT_B7		0x07
+#define PWC_INT_MAX		0x07
+
+
+/* GPIO Output/Input select */
+#define PWC_GPIO_OUTPUT	0
+#define PWC_GPIO_INPUT	1
+
+extern int  pwc_reg_read(unsigned char addr, unsigned char *data);
+extern int  pwc_reg_write(unsigned char addr, unsigned char data);
+extern int  pwc_read(unsigned short offset, unsigned int *data);
+extern int  pwc_write(unsigned short offset,
+			unsigned int data, unsigned int mask);
+extern int  pwc_set_direction(unsigned gpio, int is_input);
+extern int  pwc_get_value(unsigned int gpio);
+extern void pwc_set_value(unsigned int gpio, int value);
+extern int  pwc_get_output_value(unsigned int gpio);
+
+#endif /* _ASM_ARCH_PWC_H_ */
diff --git a/drivers/char/mp200_pwc.c b/drivers/char/mp200_pwc.c
new file mode 100644
index 0000000..6e4babe
--- /dev/null
+++ b/drivers/char/mp200_pwc.c
@@ -0,0 +1,1308 @@
+/*
+ *  File Name       : linux/arch/arm/mach-mp200/pwc.c
+ *  Function        : pwc
+ *  Release Version : Ver 1.03
+ *  Release Date    : 2009/02/04
+ *
+ *  Copyright (C) NEC Electronics Corporation 2009
+ *
+ *
+ *  This program is free software;you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  Free Softwere Foundation; either version 2 of License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY;
+ *  without even the implied warrnty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.
+ *  See the GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program;
+ *  If not, write to the Free Software Foundation, Inc., 59 Temple
+ *  Place - Suite 330, Boston,
+ *  MA 02111-1307, USA.
+ *
+ */
+
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/delay.h>
+
+#include <linux/gpio.h>
+#include <asm/mach/irq.h>
+#include <mach/pwc.h>
+#include <mach/spi.h>
+
+/* #define PWC_DEBUG */
+#ifdef PWC_DEBUG
+#define DPRINT(FMT, ARGS...) \
+	printk(KERN_INFO "%s(): " FMT, __func__, ##ARGS)
+#else
+#define DPRINT(FMT, ARGS...)
+#endif
+
+static DEFINE_SPINLOCK(pwc_spinlock);
+static DEFINE_SPINLOCK(pwc_write_spinlock);
+
+static SPI_CONFIG device0_config_read = {
+	.dev	= SPI_DEV_SP0,
+	.cs_sel	= SPI_CS_SEL_CS0,
+	.m_s	= SPI_M_S_MASTER,
+	.dma	= SPI_DMA_OFF,
+	.pol	= SPI_CSW_8CLK | SPI_CK_DLY_ON |
+			SPI_CK_POL_POS | SPI_CS_POL_POS,
+	.tiecs	= SPI_TIECS_NORMAL,
+	.nbw	= SPI_NB_8BIT,
+	.nbr	= SPI_NB_8BIT,
+	.sclk	= SPI_SCLK_12MHZ,
+};
+
+static SPI_CONFIG device0_config_write = {
+	.dev	= SPI_DEV_SP0,
+	.cs_sel	= SPI_CS_SEL_CS0,
+	.m_s	= SPI_M_S_MASTER,
+	.dma	= SPI_DMA_OFF,
+	.pol	= SPI_CSW_8CLK | SPI_CK_DLY_ON |
+			SPI_CK_POL_POS | SPI_CS_POL_POS,
+	.tiecs	= SPI_TIECS_NORMAL,
+	.nbw	= SPI_NB_16BIT,
+	.nbr	= 0,
+	.sclk	= SPI_SCLK_12MHZ,
+};
+
+#define PWC_REG_RESERVED          0x00
+#define PWC_REG_WRITEONLY         0x01
+#define PWC_REG_READONLY          0x02
+#define PWC_REG_WRITENOMODIFY     0x04
+
+#ifdef CONFIG_MP200_EM1_DKIT
+
+#define PWC_REG_READWRITE         (PWC_REG_WRITEONLY | PWC_REG_READONLY)
+#define PWC_REG_READWRITENOMODIFY (PWC_REG_READWRITE | PWC_REG_WRITENOMODIFY)
+
+/* GPIO port */
+#define PWC_GPI_INTERNAL   0x00
+#define PWC_GPI_INPORT     0x01
+#define PWC_GPO_OPEN_DRAIN 0x02
+#define PWC_GPO_PUSH_PULL  0x03
+
+#define REG_PAGE1_BASE 0
+#define REG_PAGE2_BASE 128
+#if 0
+#define REG_MAX        142
+#else
+#define REG_MAX        REG_PAGE2_BASE
+#endif
+
+static const char pwc_rw_table[] = {
+	PWC_REG_READONLY,		/* R0 PAGE_CON */
+					/* PAGE_CON is r/w, bat disable write */
+	PWC_REG_READONLY,		/* R1 STATUS_A */
+	PWC_REG_READONLY,		/* R2 STATUS_B */
+	PWC_REG_READONLY,		/* R3 STATUS_C */
+	PWC_REG_READONLY,		/* R4 STATUS_D */
+	PWC_REG_READWRITENOMODIFY,	/* R5 EVENT_A */
+	PWC_REG_READWRITENOMODIFY,	/* R6 EVENT_B */
+	PWC_REG_READWRITENOMODIFY,	/* R7 EVENT_C */
+	PWC_REG_READWRITENOMODIFY,	/* R8 EVENT_D */
+	PWC_REG_READWRITENOMODIFY,	/* R9 FAULT_LOG */
+	PWC_REG_READWRITE,		/* R10 IRQ_MASK_A */
+	PWC_REG_READWRITE,		/* R11 IRQ_MASK_B */
+	PWC_REG_READWRITE,		/* R12 IRQ_MASK_C */
+	PWC_REG_READWRITE,		/* R13 IRQ_MASK_D */
+	PWC_REG_READWRITE,		/* R14 CONTROL_A */
+	PWC_REG_READWRITE,		/* R15 CONTROL_B */
+	PWC_REG_READWRITE,		/* R16 CONTROL_C */
+	PWC_REG_READWRITE,		/* R17 CONTROL_D */
+	PWC_REG_READWRITE,		/* R18 PD_DIS */
+	PWC_REG_READWRITE,		/* R19 INTERFACE */  /* ? */
+	PWC_REG_READWRITE,		/* R20 RESET */
+	PWC_REG_READWRITE,		/* R21 GPIO_0-1 */
+	PWC_REG_READWRITE,		/* R22 GPIO_2-3 */
+	PWC_REG_READWRITE,		/* R23 GPIO_4-5 */
+	PWC_REG_READWRITE,		/* R24 GPIO_6-7 */
+	PWC_REG_READWRITE,		/* R25 GPIO_8-9 */
+	PWC_REG_READWRITE,		/* R26 GPIO_10-11 */
+	PWC_REG_READWRITE,		/* R27 GPIO_12-13 */
+	PWC_REG_READWRITE,		/* R28 GPIO_14-15 */
+				/* GPIO_14-15 bit3 read only */
+	PWC_REG_READWRITE,		/* R29 ID_0_1 */
+	PWC_REG_READWRITE,		/* R30 ID_2_3 */
+	PWC_REG_READWRITE,		/* R31 ID_4_5 */
+	PWC_REG_READWRITE,		/* R32 ID_6_7 */
+	PWC_REG_READWRITE,		/* R34 ID_10_ */
+	PWC_REG_READWRITE,		/* R34 ID_10_11 */
+	PWC_REG_READWRITE,		/* R35 ID_12_13 */
+	PWC_REG_READWRITE,		/* R36 ID_14_15 */
+	PWC_REG_READWRITE,		/* R37 ID_16_17 */
+	PWC_REG_READWRITE,		/* R38 ID_18_19 */
+	PWC_REG_READWRITE,		/* R39 ID_20_21 */
+	PWC_REG_READWRITE,		/* R40 SEQ_STATUS */
+	PWC_REG_READWRITE,		/* R41 SEQ_A */
+	PWC_REG_READWRITE,		/* R42 SEQ_B */
+	PWC_REG_READWRITE,		/* R43 SEQ_TIMER */
+	PWC_REG_READWRITE,		/* R44 BUCK_A */
+	PWC_REG_READWRITE,		/* R45 BUCK_B */
+	PWC_REG_READWRITE,		/* R46 BUCKCORE */
+	PWC_REG_READWRITE,		/* R47 BUCKPRO */
+	PWC_REG_READWRITE,		/* R48 BUCKMEM */
+	PWC_REG_READWRITE,		/* R49 BUCKPERI */
+				/* BUCKPERI bit6(BPERI_EN) read only*/
+	PWC_REG_READWRITE,		/* R50 LDO1 */
+				/* BUCKPERI bit5 read only*/
+	PWC_REG_READWRITE,		/* R51 LDO2 */
+	PWC_REG_READWRITE,		/* R52 LDO3 */
+	PWC_REG_READWRITE,		/* R53 LDO4 */
+	PWC_REG_READWRITE,		/* R54 LDO5 */
+	PWC_REG_READWRITE,		/* R55 LDO6 */
+	PWC_REG_READWRITE,		/* R56 LDO7 */
+	PWC_REG_READWRITE,		/* R57 LDO8 */
+	PWC_REG_READWRITE,		/* R58 LDO9 */
+	PWC_REG_READWRITE,		/* R59 LDO10 */
+	PWC_REG_READWRITE,		/* R60 SUPPLY */
+	PWC_REG_READWRITE,		/* R61 PULLDOWN */
+	PWC_REG_READWRITE,		/* R62 CHG_BUCK */
+	PWC_REG_READWRITE,		/* R63 WAIT_CONT */
+	PWC_REG_READWRITE,		/* R64 ISET */
+	PWC_REG_READWRITE,		/* R65 BAT_CHG */
+	PWC_REG_READWRITE,		/* R66 CHG_CONT */
+	PWC_REG_READWRITE,		/* R67 INPUT_CONT */
+	PWC_REG_READONLY,		/* R68 CHG_TIME */
+	PWC_REG_READWRITE,		/* R69 BBAT_CONT */
+	PWC_REG_READWRITE,		/* R70 BOOST */
+				/* BOOST bit7(E_B_FAULT) read only*/
+	PWC_REG_READWRITE,		/* R71 LED_CONT */
+				/* LED_CONT bit7 read only*/
+	PWC_REG_READWRITE,		/* R72 LEDMIN */
+	PWC_REG_READWRITE,		/* R73 LED1_CONF */
+	PWC_REG_READWRITE,		/* R74 LED2_CONF */
+	PWC_REG_READWRITE,		/* R75 LED3_CONF */
+	PWC_REG_READWRITE,		/* R76 LED1_CONT */
+	PWC_REG_READWRITE,		/* R77 LED2_CONT */
+	PWC_REG_READWRITE,		/* R78 LED3_CONT */
+	PWC_REG_READWRITE,		/* R79 LED4_CONT */
+	PWC_REG_READWRITE,		/* R80 LED5_CONT */
+	PWC_REG_READWRITE,		/* R81 ADC_MAN */
+				/* ADC_MAN bit7-5 read only */
+	PWC_REG_READWRITE,		/* R82 ADC_CONT */
+	PWC_REG_READONLY,		/* R83 ADC_RES_L */
+	PWC_REG_READONLY,		/* R84 ADC_RES_H */
+	PWC_REG_READONLY,		/* R85 VDD_RES */
+	PWC_REG_READWRITE,		/* R86 VDD_MON */
+	PWC_REG_READONLY,		/* R87 ICHG_AV */
+	PWC_REG_READWRITE,		/* R88 ICHG_THD */
+	PWC_REG_READWRITE,		/* R89 ICHG_END */
+	PWC_REG_READONLY,		/* R90 TBAT_RES */
+	PWC_REG_READWRITE,		/* R91 TBAT_HIGHP */
+	PWC_REG_READWRITE,		/* R92 TBAT_HIGHN */
+	PWC_REG_READWRITE,		/* R93 TBAT_LOW */
+	PWC_REG_READWRITE,		/* R94 T_OFFSET */
+	PWC_REG_READONLY,		/* R95 ADCIN4_RES */
+	PWC_REG_READWRITE,		/* R96 AUTO4_HIGH */
+	PWC_REG_READWRITE,		/* R97 AUTO4_LOW */
+	PWC_REG_READONLY,		/* R98 ADCIN5_RES */
+	PWC_REG_READWRITE,		/* R99 AUTO5_HIGH */
+	PWC_REG_READWRITE,		/* R100 AUTO5_LOW */
+	PWC_REG_READONLY,		/* R101 ADCIN6_RES */
+	PWC_REG_READWRITE,		/* R102 AUTO6_HIGH */
+	PWC_REG_READWRITE,		/* R103 AUTO6_LOW */
+	PWC_REG_READONLY,		/* R104 TJUNC_RES */
+	PWC_REG_READWRITE,		/* R105 TSI_CONT_A */
+	PWC_REG_READWRITE,		/* R106 TSI_CONT_B */
+	PWC_REG_READONLY,		/* R107 TSI_X_MSB */
+	PWC_REG_READONLY,		/* R108 TSI_Y_MSB */
+	PWC_REG_READONLY,		/* R109 TSI_LSB */
+	PWC_REG_READONLY,		/* R110 TSI_Z_MSB */
+	PWC_REG_READWRITE,		/* R111 COUNT_S */
+				/* bit7 read only*/
+	PWC_REG_READWRITE,		/* R112 COUNT_MI */
+				/* COUNT_MI bit7-6 read only*/
+	PWC_REG_READWRITE,		/* R113 COUNT_H */
+				/* COUNT_H bit7-5 read only*/
+	PWC_REG_READWRITE,		/* R114 COUNT_D */
+				/* COUNT_D bit7-5 read only*/
+	PWC_REG_READWRITE,		/* R115 COUNT_MO */
+				/* COUNT_MO bit7-4 read only*/
+	PWC_REG_READWRITE,		/* R116 COUNT_Y */
+	PWC_REG_READWRITE,		/* R117 ALARM_MI */
+	PWC_REG_READWRITE,		/* R118 ALARM_H */
+				/* ALARM_H bit7-5 read only */
+	PWC_REG_READWRITE,		/* R119 ALARM_D */
+				/* ALARM_D bit7-5 read only */
+	PWC_REG_READWRITE,		/* R120 ALARM_MO */
+				/* ALARM_MO bit7-4 read only */
+	PWC_REG_READWRITE,		/* R121 ALARM_Y */
+	PWC_REG_READONLY,		/* R122 SECOND_A */
+	PWC_REG_READONLY,		/* R123 SECOND_B */
+	PWC_REG_READONLY,		/* R124 SECOND_C */
+	PWC_REG_READONLY,		/* R125 SECOND_D */
+	PWC_REG_RESERVED,		/*   */
+	PWC_REG_RESERVED,		/*   */
+	PWC_REG_READWRITE,		/* R128 PAGE_CON */
+	PWC_REG_READONLY,		/* R129 CHIP_ID */
+	PWC_REG_READONLY,		/* R130 CONFIG_ID */
+	PWC_REG_READWRITE,		/* R131 OTP_CONT */
+		/* OTP_CONT bit5-4(bit5 OTP_GP_LOCK) read only */
+	PWC_REG_READWRITE,		/* R132 OSC_TRIM */
+	PWC_REG_READWRITE,		/* R133 GP_ID_0 */
+	PWC_REG_READWRITE,		/* R134 GP_ID_1 */
+	PWC_REG_READWRITE,		/* R135 GP_ID_2 */
+	PWC_REG_READWRITE,		/* R136 GP_ID_3 */
+	PWC_REG_READWRITE,		/* R137 GP_ID_4 */
+	PWC_REG_READWRITE,		/* R138 GP_ID_5 */
+	PWC_REG_READWRITE,		/* R139 GP_ID_6 */
+	PWC_REG_READWRITE,		/* R140 GP_ID_7 */
+	PWC_REG_READWRITE,		/* R141 GP_ID_8 */
+	PWC_REG_READWRITE,		/* R142 GP_ID_9 */
+};
+
+static const unsigned short pwc_gpio_reg[] = {
+	DA9052_GPIO0001_REG, DA9052_GPIO0203_REG,
+	DA9052_GPIO0405_REG, DA9052_GPIO0607_REG,
+	DA9052_GPIO0809_REG, DA9052_GPIO1011_REG,
+	DA9052_GPIO1213_REG, DA9052_GPIO1415_REG
+};
+
+#else /* CONFIG_MP200_EM1_DKIT */
+
+#define PWC_GIO_OUTPORT1	0xB0
+#define PWC_GIO_OUTPORT2	0x03
+#define MASK_PWC_IOSEL1		0xFF
+#define MASK_PWC_IOSEL2		0xFF
+#define PWC_TIMCNTR_INIT_VAL (0x01 << 1)
+
+/* PWC register infomation */
+struct pwc_reginfo {
+  unsigned char data;
+  unsigned char flag;
+} pwc_reginfo;
+
+#define REG_MAX		0xA0
+
+struct pwc_reginfo cs_table[REG_MAX] =
+{
+    { 0x00, PWC_REG_RESERVED },/* 00 h */
+    { 0x00, PWC_REG_RESERVED },/* 01 h */
+    { 0x03, PWC_REG_WRITEONLY},/* 02 h */
+    { 0x00, PWC_REG_RESERVED },/* 03 h */
+    { 0x00, PWC_REG_WRITEONLY},/* 04 h */
+    { 0x00, PWC_REG_RESERVED },/* 05 h */
+    { 0x02, PWC_REG_WRITEONLY},/* 06 h */
+		/* 06h change by bootloader. default 0x00 */
+    { 0x00, PWC_REG_RESERVED },/* 07 h */
+    { 0x00, PWC_REG_WRITEONLY},/* 08 h */
+    { 0x00, PWC_REG_RESERVED },/* 09 h */
+    { 0xAC, PWC_REG_WRITEONLY},/* 0A h */
+    { 0x00, PWC_REG_RESERVED },/* 0B h */
+    { 0xA0, PWC_REG_WRITEONLY},/* 0C h */
+    { 0x00, PWC_REG_RESERVED },/* 0D h */
+    { 0x00, PWC_REG_WRITEONLY},/* 0E h */
+    { 0x00, PWC_REG_RESERVED },/* 0F h */
+    { 0x80, PWC_REG_WRITEONLY},/* 10 h */
+		/* 10h change by bootloader. default 0x00 */
+    { 0x00, PWC_REG_RESERVED },/* 11 h */
+    { 0x00, PWC_REG_WRITEONLY},/* 12 h */
+    { 0x00, PWC_REG_RESERVED },/* 13 h */
+    { 0x00, PWC_REG_WRITEONLY},/* 14 h */
+    { 0x00, PWC_REG_READONLY },/* 15 h */
+    { 0x00, PWC_REG_WRITEONLY},/* 16 h */
+    { 0x00, PWC_REG_READONLY },/* 17 h */
+    { 0x00, PWC_REG_WRITEONLY},/* 18 h */
+    { 0x00, PWC_REG_RESERVED },/* 19 h */
+    { 0x00, PWC_REG_WRITEONLY},/* 1A h */
+    { 0x00, PWC_REG_RESERVED },/* 1B h */
+    { 0x55, PWC_REG_WRITEONLY},/* 1C h */
+    { 0x00, PWC_REG_RESERVED },/* 1D h */
+    { 0x55, PWC_REG_WRITEONLY},/* 1E h */
+    { 0x00, PWC_REG_RESERVED },/* 1F h */
+    { 0x00, PWC_REG_WRITEONLY},/* 20 h */
+    { 0x00, PWC_REG_READONLY },/* 21 h */
+    { 0x00, PWC_REG_WRITEONLY},/* 22 h */
+    { 0x00, PWC_REG_READONLY },/* 23 h */
+    { 0x00, PWC_REG_WRITEONLY},/* 24 h */
+    { 0x00, PWC_REG_READONLY },/* 25 h */
+    { 0x00, PWC_REG_WRITEONLY},/* 26 h */
+    { 0x00, PWC_REG_RESERVED },/* 27 h */
+    { 0x00, PWC_REG_WRITEONLY},/* 28 h */
+    { 0x00, PWC_REG_RESERVED },/* 29 h */
+    { 0x00, PWC_REG_WRITEONLY},/* 2A h */
+    { 0x00, PWC_REG_RESERVED },/* 2B h */
+    { 0x00, PWC_REG_WRITENOMODIFY },/* 2C h */
+    { 0x00, PWC_REG_RESERVED },/* 2D h */
+    { 0x00, PWC_REG_WRITENOMODIFY },/* 2E h */
+    { 0x00, PWC_REG_RESERVED },/* 2F h */
+    { 0x00, PWC_REG_WRITENOMODIFY },/* 30 h */
+    { 0x00, PWC_REG_RESERVED },/* 31 h */
+    { 0x00, PWC_REG_WRITEONLY},/* 32 h */
+    { 0x00, PWC_REG_RESERVED },/* 33 h */
+    { 0x00, PWC_REG_WRITEONLY},/* 34 h */
+    { 0x00, PWC_REG_RESERVED },/* 35 h */
+    { 0x00, PWC_REG_WRITEONLY},/* 36 h */
+    { 0x00, PWC_REG_RESERVED },/* 37 h */
+    { 0x00, PWC_REG_WRITEONLY},/* 38 h */
+    { 0x00, PWC_REG_RESERVED },/* 39 h */
+    { 0x00, PWC_REG_WRITEONLY},/* 3A h */
+    { 0x00, PWC_REG_RESERVED },/* 3B h */
+    { 0x00, PWC_REG_WRITEONLY},/* 3C h */
+    { 0x00, PWC_REG_RESERVED },/* 3D h */
+    { 0x00, PWC_REG_WRITEONLY},/* 3E h */
+    { 0x00, PWC_REG_RESERVED },/* 3F h */
+    { 0x00, PWC_REG_WRITEONLY},/* 40 h */
+    { 0x00, PWC_REG_RESERVED },/* 41 h */
+    { 0x00, PWC_REG_WRITEONLY},/* 42 h */
+    { 0x00, PWC_REG_RESERVED },/* 43 h */
+    { 0x00, PWC_REG_RESERVED },/* 44 h */
+    { 0x00, PWC_REG_RESERVED },/* 45 h */
+    { 0x00, PWC_REG_RESERVED },/* 46 h */
+    { 0x00, PWC_REG_RESERVED },/* 47 h */
+    { 0x00, PWC_REG_RESERVED },/* 48 h */
+    { 0x00, PWC_REG_RESERVED },/* 49 h */
+    { 0x00, PWC_REG_RESERVED },/* 4A h */
+    { 0x00, PWC_REG_RESERVED },/* 4B h */
+    { 0x00, PWC_REG_WRITEONLY},/* 4C h */
+    { 0x00, PWC_REG_READONLY },/* 4D h */
+    { 0x00, PWC_REG_WRITEONLY},/* 4E h */
+    { 0x00, PWC_REG_READONLY },/* 4F h */
+    { 0x00, PWC_REG_WRITEONLY},/* 50 h */
+    { 0x00, PWC_REG_READONLY },/* 51 h */
+    { 0x00, PWC_REG_WRITEONLY},/* 52 h */
+    { 0x00, PWC_REG_READONLY },/* 53 h */
+    { 0x00, PWC_REG_RESERVED },/* 54 h */
+    { 0x00, PWC_REG_READONLY },/* 55 h */
+    { 0x00, PWC_REG_RESERVED },/* 56 h */
+    { 0x00, PWC_REG_READONLY },/* 57 h */
+    { 0x00, PWC_REG_RESERVED },/* 58 h */
+    { 0x00, PWC_REG_READONLY },/* 59 h */
+    { 0x00, PWC_REG_RESERVED },/* 5A h */
+    { 0x00, PWC_REG_READONLY },/* 5B h */
+    { 0x03, PWC_REG_WRITEONLY},/* 5C h */
+    { 0x00, PWC_REG_READONLY },/* 5D h */
+    { 0x00, PWC_REG_WRITENOMODIFY },/* 5E h */
+    { 0x00, PWC_REG_READONLY },/* 5F h */
+    { 0x02, PWC_REG_WRITEONLY},/* 60 h */
+    { 0x00, PWC_REG_RESERVED },/* 61 h */
+    { 0x00, PWC_REG_WRITEONLY},/* 62 h */
+    { 0x00, PWC_REG_RESERVED },/* 63 h */
+    { 0x00, PWC_REG_WRITEONLY},/* 64 h */
+    { 0x00, PWC_REG_READONLY },/* 65 h */
+    { 0x00, PWC_REG_WRITENOMODIFY },/* 66 h */
+    { 0x00, PWC_REG_RESERVED },/* 67 h */
+    { 0x00, PWC_REG_WRITEONLY},/* 68 h */
+    { 0x00, PWC_REG_RESERVED },/* 69 h */
+    { 0x00, PWC_REG_WRITEONLY},/* 6A h */
+    { 0x00, PWC_REG_RESERVED },/* 6B h */
+    { 0x00, PWC_REG_WRITEONLY},/* 6C h */
+    { 0x00, PWC_REG_READONLY },/* 6D h */
+    { 0x00, PWC_REG_WRITENOMODIFY },/* 6E h */
+    { 0x06, PWC_REG_READONLY },/* 6F h */
+    { 0x00, PWC_REG_WRITENOMODIFY},/* 70 h */
+    { 0x00, PWC_REG_READONLY },/* 71 h */
+    { 0x00, PWC_REG_WRITENOMODIFY},/* 72 h */
+    { 0x00, PWC_REG_READONLY },/* 73 h */
+    { 0x00, PWC_REG_WRITENOMODIFY},/* 74 h */
+    { 0x00, PWC_REG_READONLY },/* 75 h */
+    { 0x00, PWC_REG_WRITENOMODIFY},/* 76 h */
+    { 0x00, PWC_REG_READONLY },/* 77 h */
+    { 0x00, PWC_REG_WRITENOMODIFY},/* 78 h */
+    { 0x00, PWC_REG_READONLY },/* 79 h */
+    { 0x00, PWC_REG_WRITENOMODIFY},/* 7A h */
+    { 0x00, PWC_REG_READONLY },/* 7B h */
+    { 0x00, PWC_REG_WRITENOMODIFY},/* 7C h */
+    { 0x00, PWC_REG_READONLY },/* 7D h */
+    { 0x00, PWC_REG_WRITENOMODIFY},/* 7E h */
+    { 0x00, PWC_REG_READONLY },/* 7F h */
+    { 0x00, PWC_REG_WRITENOMODIFY},/* 80 h */
+    { 0x00, PWC_REG_READONLY },/* 81 h */
+    { 0x00, PWC_REG_WRITENOMODIFY},/* 82 h */
+    { 0x00, PWC_REG_READONLY },/* 83 h */
+    { 0x00, PWC_REG_WRITENOMODIFY},/* 84 h */
+    { 0x00, PWC_REG_READONLY },/* 85 h */
+    { 0x00, PWC_REG_WRITENOMODIFY},/* 86 h */
+    { 0x00, PWC_REG_READONLY },/* 87 h */
+    { 0x00, PWC_REG_WRITENOMODIFY},/* 88 h */
+    { 0x00, PWC_REG_READONLY },/* 89 h */
+    { 0x00, PWC_REG_WRITEONLY},/* 8A h */
+    { 0x00, PWC_REG_READONLY },/* 8B h */
+    { 0x00, PWC_REG_WRITEONLY},/* 8C h */
+    { 0x00, PWC_REG_READONLY },/* 8D h */
+    { 0x00, PWC_REG_RESERVED },/* 8E h */
+    { 0x00, PWC_REG_RESERVED },/* 8F h */
+    { 0x07, PWC_REG_WRITEONLY},/* 90 h */
+    { 0x00, PWC_REG_RESERVED },/* 91 h */
+    { 0x00, PWC_REG_WRITEONLY},/* 92 h */
+    { 0x00, PWC_REG_RESERVED },/* 93 h */
+    { 0x00, PWC_REG_WRITENOMODIFY},/* 94 h */
+    { 0x00, PWC_REG_RESERVED },/* 95 h */
+    { 0x00, PWC_REG_RESERVED },/* 96 h */
+    { 0x00, PWC_REG_RESERVED },/* 97 h */
+    { 0x00, PWC_REG_RESERVED },/* 98 h */
+    { 0x00, PWC_REG_RESERVED },/* 99 h */
+    { 0x00, PWC_REG_RESERVED },/* 9A h */
+    { 0x00, PWC_REG_RESERVED },/* 9B h */
+    { 0x00, PWC_REG_RESERVED },/* 9C h */
+    { 0x00, PWC_REG_RESERVED },/* 9D h */
+    { 0x00, PWC_REG_RESERVED },/* 9E h */
+    { 0x00, PWC_REG_RESERVED },/* 9F h */
+};
+#endif /* CONFIG_MP200_EM1_DKIT */
+
+/* PWC access functions */
+int pwc_reg_read(unsigned char addr, unsigned char *data)
+{
+	int ret = 0;
+
+	if (addr >= REG_MAX)
+		return -EINVAL;
+
+#ifdef CONFIG_MP200_EM1_DKIT
+
+	if (pwc_rw_table[addr] & PWC_REG_READONLY) {
+		addr = (addr << 1) | 0x1;
+		ret = spi_cmd_read(&device0_config_read, &addr, data, 0);
+		if (ret < 0) {
+			printk(KERN_INFO
+				"pwc_reg_read(): spi_read error(addr=0x%02x)\n",
+				addr >> 1);
+			return ret;
+		}
+	} else {
+		return -EINVAL;
+	}
+
+#else /* CONFIG_MP200_EM1_DKIT */
+	if (cs_table[addr].flag & PWC_REG_READONLY) {
+		ret = spi_cmd_read(&device0_config_read, &addr, data, 0);
+		if (ret < 0) {
+			printk(KERN_INFO "pwc_reg_read(): spi_read error\n");
+			return ret;
+		}
+	} else {
+		*data = cs_table[addr].data;
+	}
+
+#endif /* CONFIG_MP200_EM1_DKIT */
+
+	return 0;
+}
+EXPORT_SYMBOL(pwc_reg_read);
+
+int pwc_reg_write(unsigned char addr, unsigned char data)
+{
+	int ret = 0;
+	char buf[2];
+
+	if (addr >= REG_MAX)
+		return -EINVAL;
+
+#ifdef CONFIG_MP200_EM1_DKIT
+	if (pwc_rw_table[addr] & PWC_REG_WRITEONLY) {
+		addr = (addr << 1) & 0xFE;
+#else /* CONFIG_MP200_EM1_DKIT */
+	if (cs_table[addr].flag & (PWC_REG_WRITEONLY | PWC_REG_WRITENOMODIFY)) {
+#endif /* CONFIG_MP200_EM1_DKIT */
+		buf[0] = (char)data;
+		buf[1] = (char)addr;
+		ret = spi_write(&device0_config_write, buf, 0, 2, 0);
+		if (ret < 0) {
+			printk(KERN_INFO "pwc_reg_write(): spi_write error\n");
+			return ret;
+		}
+#ifdef CONFIG_MP200_EM1_DKIT
+#else /* CONFIG_MP200_EM1_DKIT */
+		cs_table[addr].data = data;
+#endif /* CONFIG_MP200_EM1_DKIT */
+	} else {
+		printk(KERN_INFO
+			"pwc_reg_write(): Read Only error(addr = 0x%02x)\n",
+			addr);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(pwc_reg_write);
+
+int pwc_read(unsigned short offset, unsigned int *data)
+{
+	*data = 0;
+	return pwc_reg_read(offset, (unsigned char *)data);
+}
+EXPORT_SYMBOL(pwc_read);
+
+int pwc_write(unsigned short offset, unsigned int data, unsigned int mask)
+{
+	int ret = 0;
+	unsigned long flags;
+	unsigned char tmp_data;
+
+	spin_lock_irqsave(&pwc_write_spinlock, flags);
+	ret = pwc_reg_read(offset, &tmp_data);
+	if (ret != 0) {
+		spin_unlock_irqrestore(&pwc_spinlock, flags);
+		return ret;
+	}
+#ifdef CONFIG_MP200_EM1_DKIT
+	if (pwc_rw_table[offset] & PWC_REG_WRITENOMODIFY)
+		tmp_data = data & mask;
+	else if (pwc_rw_table[offset] & PWC_REG_WRITEONLY)
+		tmp_data = (tmp_data & (~mask)) | (data & mask);
+#else /* CONFIG_MP200_EM1_DKIT */
+	if (cs_table[offset].flag & PWC_REG_WRITEONLY) {
+		if (offset == PWC_TIMCNTR)
+			tmp_data |= PWC_TIMCNTR_INIT_VAL;
+
+		tmp_data = (tmp_data & (~mask)) | (data & mask);
+	} else if (cs_table[offset].flag & PWC_REG_WRITENOMODIFY) {
+		tmp_data = data & mask;
+	}
+#endif /* CONFIG_MP200_EM1_DKIT */
+	ret = pwc_reg_write(offset, tmp_data);
+	spin_unlock_irqrestore(&pwc_write_spinlock, flags);
+
+	return ret;
+}
+EXPORT_SYMBOL(pwc_write);
+
+
+int pwc_set_direction(unsigned gpio, int is_input)
+{
+	unsigned int mask;
+	unsigned char addr;
+#ifdef CONFIG_MP200_EM1_DKIT
+	unsigned char data;
+#else
+	int ret = -EINVAL;
+#endif
+
+#ifdef CONFIG_MP200_EM1_DKIT
+
+	/* When set outport, set "Open drain". */
+	switch (gpio) {
+	case GPIO_EXT1_P0:
+	case GPIO_EXT1_P1:
+	case GPIO_EXT1_P2:
+	case GPIO_EXT1_P8:
+	case GPIO_EXT1_P9:
+	case GPIO_EXT1_P10:
+	case GPIO_EXT1_P12:
+	case GPIO_EXT1_P14:
+	case GPIO_EXT1_P15:
+		data = (is_input ? PWC_GPI_INPORT : PWC_GPO_OPEN_DRAIN);
+	break;
+
+	case GPIO_EXT1_P3:
+	case GPIO_EXT1_P4:
+	case GPIO_EXT1_P5:
+	case GPIO_EXT1_P6:
+	case GPIO_EXT1_P7:
+	case GPIO_EXT1_P11:
+	case GPIO_EXT1_P13:
+		data = (is_input ? PWC_GPI_INTERNAL : PWC_GPO_OPEN_DRAIN);
+	break;
+	default:
+		return -EINVAL;
+	}
+	addr = pwc_gpio_reg[(gpio - GPIO_EXT1_BASE) / 2];
+	if ((gpio - GPIO_EXT1_BASE) & 0x01) {
+		mask = 0x03 << 4;
+		data = data << 4;
+	} else {
+		mask = 0x03;
+	}
+
+	return pwc_write(addr, data, mask);
+
+#else /* CONFIG_MP200_EM1_DKIT */
+	if ((GPIO_EXT1_BASE <= gpio) && (gpio <= GPIO_EXT1_LAST)) {
+		if (gpio <= GPIO_EXT1_P7) {
+			mask = 1U << (gpio - GPIO_EXT1_P0);
+			addr = PWC_IOSEL1;
+		} else {
+			mask = 1U << (gpio - GPIO_EXT1_P8);
+			addr = PWC_IOSEL2;
+		}
+
+		if (is_input) {	/* input */
+			ret = pwc_write(addr, 0, mask);
+		} else {	/* output */
+			ret = pwc_write(addr, mask, mask);
+		}
+	}
+	return ret;
+#endif /* CONFIG_MP200_EM1_DKIT */
+}
+EXPORT_SYMBOL(pwc_set_direction);
+
+int pwc_get_value(unsigned int gpio)
+{
+	int ret = -EINVAL;
+#ifdef CONFIG_MP200_EM1_DKIT
+#else /* CONFIG_MP200_EM1_DKIT */
+	unsigned char direction, in_addr, out_addr, sel_addr;
+#endif /* CONFIG_MP200_EM1_DKIT */
+	unsigned char data = 0, mask = 0, addr;
+
+	if ((GPIO_EXT1_BASE <= gpio) && (gpio <= GPIO_EXT1_LAST)) {
+#ifdef CONFIG_MP200_EM1_DKIT
+		if (gpio <= GPIO_EXT1_P7) {
+			mask = 1U << (gpio - GPIO_EXT1_P0);
+			addr = DA9052_EVENTC_REG;
+		} else {
+			mask = 1U << (gpio - GPIO_EXT1_P8);
+			addr = DA9052_EVENTD_REG;
+		}
+#else /* CONFIG_MP200_EM1_DKIT */
+		if (gpio <= GPIO_EXT1_P7) {
+			mask = 1U << (gpio - GPIO_EXT1_P0);
+			sel_addr = PWC_IOSEL1;
+			in_addr  = PWC_IOIN1;
+			out_addr = PWC_IOOUT1;
+		} else {
+			mask = 1U << (gpio - GPIO_EXT1_P8);
+			sel_addr = PWC_IOSEL2;
+			in_addr  = PWC_IOIN2;
+			out_addr = PWC_IOOUT2;
+		}
+
+		if (pwc_reg_read(sel_addr, &direction))
+			return ret;
+
+		if (direction & mask)
+			addr = out_addr;
+		else
+			addr = in_addr;
+
+#endif /* CONFIG_MP200_EM1_DKIT */
+		ret = pwc_reg_read(addr, &data);
+	}
+
+	return ret ? ret : ((data & mask) ? 1 : 0);
+}
+EXPORT_SYMBOL(pwc_get_value);
+
+void pwc_set_value(unsigned int gpio, int value)
+{
+	unsigned int mask;
+#ifdef CONFIG_MP200_EM1_DKIT
+	unsigned char addr;
+#else /* CONFIG_MP200_EM1_DKIT */
+	unsigned char direction;
+	unsigned char sel_addr, out_addr;
+#endif /* CONFIG_MP200_EM1_DKIT */
+
+	if ((GPIO_EXT1_BASE <= gpio) && (gpio <= GPIO_EXT1_LAST)) {
+#ifdef CONFIG_MP200_EM1_DKIT
+		addr = pwc_gpio_reg[(gpio - GPIO_EXT1_BASE) / 2];
+
+		if ((gpio - GPIO_EXT1_BASE) & 0x01)
+			mask = 0x80;
+		else
+			mask = 0x08;
+
+		if (value)
+			pwc_write(addr, mask, mask);
+		else
+			pwc_write(addr, 0, mask);
+
+#else /* CONFIG_MP200_EM1_DKIT */
+		if (gpio <= GPIO_EXT1_P7) {
+			mask = 1U << (gpio - GPIO_EXT1_P0);
+			sel_addr = PWC_IOSEL1;
+			out_addr = PWC_IOOUT1;
+		} else {
+			mask = 1U << (gpio - GPIO_EXT1_P8);
+			sel_addr = PWC_IOSEL2;
+			out_addr = PWC_IOOUT2;
+		}
+
+		if (pwc_reg_read(sel_addr, &direction))
+			return;
+
+		if (~direction & mask)
+			return;
+
+		if (value)
+			pwc_write(out_addr, mask, mask);
+		else
+			pwc_write(out_addr, 0, mask);
+
+#endif /* CONFIG_MP200_EM1_DKIT */
+	}
+}
+EXPORT_SYMBOL(pwc_set_value);
+
+
+/* PWC interrupt functions */
+static void mp200_pwc_mask_irq(unsigned int irq)
+{
+	unsigned int port = 0;
+
+	if ((irq < INT_PWC_BASE) || (INT_PWC_LAST < irq))
+		return;
+
+#ifdef CONFIG_MP200_EM1_DKIT
+	if (irq < INT_PWC_MASK2_BASE) {
+		port = irq - INT_PWC_MASK1_BASE;
+		DPRINT("MASK A port = %d\n", port);
+		pwc_write(DA9052_IRQMASKA_REG, (1 << port), (1 << port));
+	} else if (irq < INT_PWC_MASK3_BASE) {
+		port = irq - INT_PWC_MASK2_BASE;
+		DPRINT("MASK B port = %d\n", port);
+		pwc_write(DA9052_IRQMASKB_REG, (1 << port), (1 << port));
+	} else if (irq < INT_PWC_MASK4_BASE) {
+		port = irq - INT_PWC_MASK3_BASE;
+		DPRINT("MASK C port = %d\n", port);
+		pwc_write(DA9052_IRQMASKC_REG, (1 << port), (1 << port));
+	} else {
+		port = irq - INT_PWC_MASK4_BASE;
+		DPRINT("MASK D port = %d\n", port);
+		pwc_write(DA9052_IRQMASKD_REG, (1 << port), (1 << port));
+	}
+
+#else /* CONFIG_MP200_EM1_DKIT */
+	if (irq < INT_PWC_MASK2_BASE) {
+		port = irq - INT_PWC_MASK1_BASE;
+		DPRINT("MASK1 port = %d\n", port);
+		/* mask FMASK1/BMASK1 */
+		pwc_write(PWC_BMASK1, 0, (1 << port));
+		pwc_write(PWC_FMASK1, 0, (1 << port));
+	} else if (irq < INT_PWC_MASK3_BASE) {
+		port = irq - INT_PWC_MASK2_BASE;
+		DPRINT("MASK2 port = %d\n", port);
+		/* mask FMASK2/BMASK2 */
+		pwc_write(PWC_BMASK2, 0, (1 << port));
+		pwc_write(PWC_FMASK2, 0, (1 << port));
+	} else {
+		port = irq - INT_PWC_MASK3_BASE;
+		DPRINT("MASK3 port = %d\n", port);
+		/* mask FMASK3/BMASK3 */
+		pwc_write(PWC_BMASK3, 0, (1 << port));
+		pwc_write(PWC_FMASK3, 0, (1 << port));
+	}
+#endif /* CONFIG_MP200_EM1_DKIT */
+}
+
+static void mp200_pwc_unmask_irq(unsigned int irq)
+{
+	unsigned int port = 0;
+
+	if ((irq < INT_PWC_BASE) || (INT_PWC_LAST < irq))
+		return;
+
+#ifdef CONFIG_MP200_EM1_DKIT
+	if (irq < INT_PWC_MASK2_BASE) {
+		port = irq - INT_PWC_MASK1_BASE;
+		DPRINT("UNMASK A port = %d\n", port);
+		pwc_write(DA9052_IRQMASKA_REG, 0 , (1 << port));
+	} else if (irq < INT_PWC_MASK3_BASE) {
+		port = irq - INT_PWC_MASK2_BASE;
+		DPRINT("UNMASK B port = %d\n", port);
+		pwc_write(DA9052_IRQMASKB_REG, 0 , (1 << port));
+	} else if (irq < INT_PWC_MASK4_BASE) {
+		port = irq - INT_PWC_MASK3_BASE;
+		DPRINT("UNMASK C port = %d\n", port);
+		pwc_write(DA9052_IRQMASKC_REG, 0 , (1 << port));
+	} else {
+		port = irq - INT_PWC_MASK4_BASE;
+		DPRINT("UNMASK D port = %d\n", port);
+		pwc_write(DA9052_IRQMASKD_REG, 0 , (1 << port));
+	}
+#else /* CONFIG_MP200_EM1_DKIT */
+	if (irq < INT_PWC_MASK2_BASE) {
+		port = irq - INT_PWC_MASK1_BASE;
+		DPRINT("MASK1 port = %d\n", port);
+		/* unmask FMASK1/BMASK1 */
+		pwc_write(PWC_FMASK1, (1 << port), (1 << port));
+		pwc_write(PWC_BMASK1, (1 << port), (1 << port));
+	} else if (irq < INT_PWC_MASK3_BASE) {
+		port = irq - INT_PWC_MASK2_BASE;
+		DPRINT("MASK2 port = %d\n", port);
+		/* unmask FMASK2/BMASK2 */
+		pwc_write(PWC_FMASK2, (1 << port), (1 << port));
+		pwc_write(PWC_BMASK2, (1 << port), (1 << port));
+	} else {
+		port = irq - INT_PWC_MASK3_BASE;
+		DPRINT("MASK3 port = %d\n", port);
+		/* unmask FMASK3/BMASK3 */
+		pwc_write(PWC_FMASK3, (1 << port), (1 << port));
+		pwc_write(PWC_BMASK3, (1 << port), (1 << port));
+	}
+#endif /* CONFIG_MP200_EM1_DKIT */
+}
+
+static void mp200_pwc_ack_irq(unsigned int irq)
+{
+	unsigned int port = 0;
+
+#ifdef CONFIG_MP200_EM1_DKIT
+	if (irq < INT_PWC_MASK2_BASE) {
+		port = irq - INT_PWC_MASK1_BASE;
+		DPRINT("EVENT A clear port = %d\n", port);
+		pwc_write(DA9052_EVENTA_REG, (1 << port), (1 << port));
+	} else if (irq < INT_PWC_MASK3_BASE) {
+		port = irq - INT_PWC_MASK2_BASE;
+		DPRINT("EVENT B clear port = %d\n", port);
+		pwc_write(DA9052_EVENTB_REG, (1 << port), (1 << port));
+	} else if (irq < INT_PWC_MASK4_BASE) {
+		port = irq - INT_PWC_MASK3_BASE;
+		pwc_write(DA9052_EVENTC_REG, (1 << port), (1 << port));
+		DPRINT("EVENT C clear port = %d\n", port);
+	} else {
+		port = irq - INT_PWC_MASK4_BASE;
+		DPRINT("EVENT D clear port = %d\n", port);
+		pwc_write(DA9052_EVENTD_REG, (1 << port), (1 << port));
+	}
+#else /* CONFIG_MP200_EM1_DKIT */
+	/* PWC clear before interrupt handling */
+	if (irq < INT_PWC_MASK2_BASE) {
+		port = irq - INT_PWC_MASK1_BASE;
+		pwc_write(PWC_CLRFACT1, (1 << port), (1 << port));
+	} else if (irq < INT_PWC_MASK3_BASE) {
+		port = irq - INT_PWC_MASK2_BASE;
+		pwc_write(PWC_CLRFACT2, (1 << port), (1 << port));
+	} else {
+		port = irq - INT_PWC_MASK3_BASE;
+		pwc_write(PWC_CLRFACT3, (1 << port), (1 << port));
+	}
+#endif /* CONFIG_MP200_EM1_DKIT */
+}
+static void mp200_pwc_ack_unmask_irq(unsigned int irq)
+{
+	mp200_pwc_ack_irq(irq);
+	mp200_pwc_unmask_irq(irq);
+}
+
+static void mp200_pwc_irq_handler(unsigned int irq, struct irq_desc *desc)
+{
+	int i;
+	unsigned int pwc_factor1_stat = 0;
+	unsigned int pwc_factor2_stat = 0;
+	unsigned int pwc_factor3_stat = 0;
+#ifdef CONFIG_MP200_EM1_DKIT
+	unsigned int pwc_factor4_stat = 0;
+	unsigned int pwc_factor1_mask = 0;
+	unsigned int pwc_factor2_mask = 0;
+	unsigned int pwc_factor3_mask = 0;
+	unsigned int pwc_factor4_mask = 0;
+#endif /* CONFIG_MP200_EM1_DKIT */
+	unsigned int pwc_irq;
+	struct irq_desc *d;
+
+	DPRINT("entry\n");
+
+	if (irq != INT_GPIO_INTOUT)
+		return;
+
+	desc->chip->ack(irq);
+
+#ifdef CONFIG_MP200_EM1_DKIT
+	pwc_read(DA9052_EVENTA_REG, &pwc_factor1_stat);
+	pwc_read(DA9052_EVENTB_REG, &pwc_factor2_stat);
+	pwc_read(DA9052_EVENTC_REG, &pwc_factor3_stat);
+	pwc_read(DA9052_EVENTD_REG, &pwc_factor4_stat);
+	pwc_read(DA9052_IRQMASKA_REG, &pwc_factor1_mask);
+	pwc_read(DA9052_IRQMASKB_REG, &pwc_factor2_mask);
+	pwc_read(DA9052_IRQMASKC_REG, &pwc_factor3_mask);
+	pwc_read(DA9052_IRQMASKD_REG, &pwc_factor4_mask);
+
+	pwc_factor1_stat &= ~pwc_factor1_mask;
+	pwc_factor2_stat &= ~pwc_factor2_mask;
+	pwc_factor3_stat &= ~pwc_factor3_mask;
+	pwc_factor4_stat &= ~pwc_factor4_mask;
+
+	if (pwc_factor1_stat != 0) {
+		DPRINT("DA9052_EVENTA_REG = 0x%02x\n", pwc_factor1_stat);
+		/* IO interrupt */
+		for (i = PWC_INT_B0; i <= PWC_INT_MAX; i++) {
+			if ((pwc_factor1_stat & (1 << i)) != 0) {
+				pwc_irq = INT_PWC_MASK1_BASE + i;
+				d = irq_desc + pwc_irq;
+				d->handle_irq(pwc_irq, d);
+			}
+		}
+	}
+	if (pwc_factor2_stat != 0) {
+		DPRINT("DA9052_EVENTB_REG = 0x%02x\n", pwc_factor2_stat);
+		/* IO interrupt */
+		for (i = PWC_INT_B0; i <= PWC_INT_MAX; i++) {
+			if ((pwc_factor2_stat & (1 << i)) != 0) {
+				pwc_irq = INT_PWC_MASK2_BASE + i;
+				d = irq_desc + pwc_irq;
+				d->handle_irq(pwc_irq, d);
+			}
+		}
+	}
+	if (pwc_factor3_stat != 0) {
+		DPRINT("DA9052_EVENTC_REG = 0x%02x\n", pwc_factor3_stat);
+		/* IO interrupt */
+		for (i = PWC_INT_B0; i <= PWC_INT_MAX; i++) {
+			if ((pwc_factor3_stat & (1 << i)) != 0) {
+				pwc_irq = INT_PWC_MASK3_BASE + i;
+				d = irq_desc + pwc_irq;
+				d->handle_irq(pwc_irq, d);
+			}
+		}
+	}
+	if (pwc_factor4_stat != 0) {
+		DPRINT("DA9052_EVENTD_REG = 0x%02x\n", pwc_factor4_stat);
+		/* IO interrupt */
+		for (i = PWC_INT_B0; i <= PWC_INT_MAX; i++) {
+			if ((pwc_factor4_stat & (1 << i)) != 0) {
+				pwc_irq = INT_PWC_MASK4_BASE + i;
+				d = irq_desc + pwc_irq;
+				d->handle_irq(pwc_irq, d);
+			}
+		}
+	}
+
+#else /* CONFIG_MP200_EM1_DKIT */
+	pwc_read(PWC_FACTOR1, &pwc_factor1_stat);
+	pwc_read(PWC_FACTOR2, &pwc_factor2_stat);
+	pwc_read(PWC_FACTOR3, &pwc_factor3_stat);
+
+	if (pwc_factor1_stat != 0) {
+		DPRINT("PWC_FACTOR1 = 0x%02x\n", pwc_factor1_stat);
+		/* IO interrupt */
+		for (i = PWC_INT_B0; i <= PWC_INT_MAX; i++) {
+			if ((pwc_factor1_stat & (1 << i)) != 0) {
+				pwc_irq = INT_PWC_MASK1_BASE + i;
+				d = irq_desc + pwc_irq;
+				d->handle_irq(pwc_irq, d);
+			}
+		}
+	}
+	if (pwc_factor2_stat != 0) {
+		DPRINT("PWC_FACTOR2 = 0x%02x\n", pwc_factor2_stat);
+		/* IO interrupt */
+		for (i = PWC_INT_B0; i <= PWC_INT_MAX; i++) {
+			if ((pwc_factor2_stat & (1 << i)) != 0) {
+				pwc_irq = INT_PWC_MASK2_BASE + i;
+				d = irq_desc + pwc_irq;
+				d->handle_irq(pwc_irq, d);
+			}
+		}
+	}
+	if (pwc_factor3_stat != 0) {
+		DPRINT("PWC_FACTOR3 = 0x%02x\n", pwc_factor3_stat);
+		/* IO interrupt */
+		for (i = PWC_INT_B0; i <= PWC_INT_MAX; i++) {
+			if ((pwc_factor3_stat & (1 << i)) != 0) {
+				pwc_irq = INT_PWC_MASK3_BASE + i;
+				d = irq_desc + pwc_irq;
+				d->handle_irq(pwc_irq, d);
+			}
+		}
+	}
+#endif /* CONFIG_MP200_EM1_DKIT */
+
+	desc->chip->unmask(irq);
+	DPRINT("exit\n");
+}
+
+
+static int mp200_pwc_set_irq_type(unsigned int irq, unsigned int type);
+
+#ifdef CONFIG_MP200_EM1_DKIT
+#else /* CONFIG_MP200_EM1_DKIT */
+static struct irq_chip mp200_pwc_chip_ack = {
+	.name    = "PWC",
+	.ack = mp200_pwc_ack_irq,
+	.mask = mp200_pwc_mask_irq,
+	.unmask = mp200_pwc_unmask_irq,
+	.disable = mp200_pwc_mask_irq,
+	.set_type = mp200_pwc_set_irq_type,
+};
+#endif /* CONFIG_MP200_EM1_DKIT */
+static struct irq_chip mp200_pwc_chip = {
+	.name    = "PWC",
+	.ack = mp200_pwc_mask_irq,
+	.mask = mp200_pwc_mask_irq,
+	.unmask = mp200_pwc_ack_unmask_irq,
+	.disable = mp200_pwc_mask_irq,
+	.set_type = mp200_pwc_set_irq_type,
+};
+
+
+/* called from set_irq_type() */
+static int mp200_pwc_set_irq_type(unsigned int irq, unsigned int type)
+{
+	unsigned int port;
+	unsigned int mode = 0;
+	unsigned long flags;
+#ifdef CONFIG_MP200_EM1_DKIT
+	unsigned int mode_mask = 0x04;
+	unsigned int pwc_mask;
+	unsigned short pwc_mode_reg;
+	unsigned short pwc_mask_reg;
+	unsigned short pwc_clear_reg;
+#else /* CONFIG_MP200_EM1_DKIT */
+	unsigned int pwc_bmask;
+	unsigned int pwc_fmask;
+	unsigned int shift;
+#endif /* CONFIG_MP200_EM1_DKIT */
+
+#ifdef CONFIG_MP200_EM1_DKIT
+
+	if ((irq < INT_PWC_BASE) || (INT_PWC_LAST < irq))
+		return -EINVAL;
+	else if (irq < INT_PWC_MASK3_BASE)
+		return 0;
+
+	switch (type) {
+	case IRQ_TYPE_LEVEL_HIGH:
+		mode = 0x04;
+		break;
+	case IRQ_TYPE_LEVEL_LOW:
+		mode = 0x00;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	set_irq_chip(irq, &mp200_pwc_chip);
+	set_irq_handler(irq, handle_level_irq);
+
+	spin_lock_irqsave(&pwc_spinlock, flags);
+
+	pwc_mode_reg = pwc_gpio_reg[(irq - INT_PWC_MASK3_BASE) / 2];
+	if ((irq - INT_PWC_MASK3_BASE) & 0x01) {
+		mode = mode << 4;
+		mode_mask = mode_mask << 4;
+	}
+	if (irq < INT_PWC_MASK4_BASE) {
+		port = 1 << (irq - INT_PWC_MASK3_BASE);
+		pwc_mask_reg = DA9052_IRQMASKC_REG;
+		pwc_clear_reg = DA9052_EVENTC_REG;
+	} else {
+		port = 1 << (irq - INT_PWC_MASK4_BASE);
+		pwc_mask_reg = DA9052_IRQMASKD_REG;
+		pwc_clear_reg = DA9052_EVENTD_REG;
+	}
+	DPRINT("mode reg 0x%02x, mask reg 0x%02x, clear reg 0x%02x, port %d\n",
+			pwc_mode_reg, pwc_mask_reg, pwc_clear_reg,
+			irq - INT_PWC_MASK1_BASE);
+	DPRINT("mode 0x%02x, mode mask reg 0x%02x, \n",
+			mode, mode_mask);
+
+	/* IRQMASKA enable -> disable */
+	pwc_read(pwc_mask_reg, &pwc_mask);
+	if ((pwc_mask & port) == 0)
+		pwc_write(pwc_mask_reg, port, port);
+
+	/* set int type */
+	pwc_write(pwc_mode_reg, mode, mode_mask);
+
+	udelay(60);
+	pwc_write(pwc_clear_reg, port, port);
+
+	/* Restore if changed */
+	if ((pwc_mask & port) == 0)
+		pwc_write(pwc_mask_reg, 0, port);
+
+#else /* CONFIG_MP200_EM1_DKIT */
+
+	if ((irq < INT_PWC_BASE) || (INT_PWC_LAST < irq))
+		return -EINVAL;
+
+	if (irq == INT_PWC_IO01) {
+		switch (type) {
+		case IRQ_TYPE_LEVEL_HIGH:
+			mode = 0x00;
+			break;
+		case IRQ_TYPE_EDGE_BOTH:
+			mode = 0x01;
+			break;
+		default:
+			return -EINVAL;
+		}
+	} else {
+		switch (type) {
+		case IRQ_TYPE_LEVEL_HIGH:
+			mode = 0x00;
+			break;
+		case IRQ_TYPE_EDGE_RISING:
+			mode = 0x01;
+			break;
+		case IRQ_TYPE_EDGE_FALLING:
+			mode = 0x02;
+			break;
+		default:
+			return -EINVAL;
+		}
+	}
+
+	if ((mode == 0x01) || (mode == 0x02)) {
+		set_irq_chip(irq, &mp200_pwc_chip_ack);
+		set_irq_handler(irq, handle_edge_irq);
+	} else {
+		set_irq_chip(irq, &mp200_pwc_chip);
+		set_irq_handler(irq, handle_level_irq);
+	}
+
+	spin_lock_irqsave(&pwc_spinlock, flags);
+
+	if (irq < INT_PWC_MASK2_BASE) {
+		port = irq - INT_PWC_MASK1_BASE;
+		shift = (port & 0x03) << 1;
+
+		/* BMASK1/FMASK1 enable -> disable */
+		pwc_read(PWC_BMASK1, &pwc_bmask);
+		if ((pwc_bmask & (1 << port)) != 0)
+			pwc_write(PWC_BMASK1, 0, (1 << port));
+
+		pwc_read(PWC_FMASK1, &pwc_fmask);
+		if ((pwc_fmask & (1 << port)) != 0)
+			pwc_write(PWC_FMASK1, 0, (1 << port));
+
+		/* set DETMOD1 */
+		if (port < 4) {
+			pwc_write(PWC_DETMOD1L, (mode << shift),
+				  (0x03 << shift));
+		} else {
+			pwc_write(PWC_DETMOD1H, (mode << shift),
+				  (0x03 << shift));
+		}
+		udelay(60);
+		pwc_write(PWC_CLRFACT1, (1 << port), (1 << port));
+
+		/* Restore if changed */
+		if ((pwc_bmask & (1 << port)) != 0)
+			pwc_write(PWC_BMASK1, (1 << port), (1 << port));
+
+		if ((pwc_fmask & (1 << port)) != 0)
+			pwc_write(PWC_FMASK1, (1 << port), (1 << port));
+
+	} else if (irq < INT_PWC_MASK3_BASE) {
+		port = irq - INT_PWC_MASK2_BASE;
+		shift = (port & 0x03) << 1;
+
+		/* BMASK2/FMASK2 enable -> disable */
+		pwc_read(PWC_BMASK2, &pwc_bmask);
+		if ((pwc_bmask & (1 << port)) != 0)
+			pwc_write(PWC_BMASK2, 0, (1 << port));
+
+		pwc_read(PWC_FMASK2, &pwc_fmask);
+		if ((pwc_fmask & (1 << port)) != 0)
+			pwc_write(PWC_FMASK2, 0, (1 << port));
+
+		/* set DETMOD2 */
+		if (port < 4) {
+			pwc_write(PWC_DETMOD2L, (mode << shift),
+				  (0x03 << shift));
+		} else {
+			pwc_write(PWC_DETMOD2H, (mode << shift),
+				  (0x03 << shift));
+		}
+		udelay(60);
+		pwc_write(PWC_CLRFACT2, (1 << port), (1 << port));
+
+		/* Restore if changed */
+		if ((pwc_bmask & (1 << port)) != 0)
+			pwc_write(PWC_BMASK2, (1 << port), (1 << port));
+
+		if ((pwc_fmask & (1 << port)) != 0)
+			pwc_write(PWC_FMASK2, (1 << port), (1 << port));
+
+	} else {
+		port = irq - INT_PWC_MASK3_BASE;
+		shift = (port & 0x03) << 1;
+
+		/* BMASK3/FMASK3 enable -> disable */
+		pwc_read(PWC_BMASK3, &pwc_bmask);
+		if ((pwc_bmask & (1 << port)) != 0)
+			pwc_write(PWC_BMASK3, 0, (1 << port));
+
+		pwc_read(PWC_FMASK3, &pwc_fmask);
+		if ((pwc_fmask & (1 << port)) != 0)
+			pwc_write(PWC_FMASK3, 0, (1 << port));
+
+		/* set DETMOD3 */
+		if (port < 4) {
+			pwc_write(PWC_DETMOD3L, (mode << shift),
+				  (0x03 << shift));
+		} else {
+			pwc_write(PWC_DETMOD3H, (mode << shift),
+				  (0x03 << shift));
+		}
+		udelay(60);
+		pwc_write(PWC_CLRFACT3, (1 << port), (1 << port));
+
+		/* Restore if changed */
+		if ((pwc_bmask & (1 << port)) != 0)
+			pwc_write(PWC_BMASK3, (1 << port), (1 << port));
+
+		if ((pwc_fmask & (1 << port)) != 0)
+			pwc_write(PWC_FMASK3, (1 << port), (1 << port));
+	}
+#endif /* CONFIG_MP200_EM1_DKIT */
+
+	spin_unlock_irqrestore(&pwc_spinlock, flags);
+
+	return 0;
+}
+
+
+static int __init mp200_pwc_init(void)
+{
+	int i;
+
+	/* setup default PWC Interrupt modes */
+	for (i = INT_PWC_BASE; i <= INT_PWC_LAST; i++) {
+		set_irq_chip(i, &mp200_pwc_chip);
+		set_irq_handler(i, handle_level_irq);
+		set_irq_flags(i, IRQF_VALID);
+	}
+
+#ifdef CONFIG_MP200_EM1_DKIT
+
+	/* Initialize PWC registers */
+	/* GPIO1 set inport */
+	pwc_write(DA9052_GPIO0001_REG, PWC_GPI_INPORT << 4, 0x30);
+
+	/* GPIO12 set inport */
+	pwc_write(DA9052_GPIO1213_REG, PWC_GPI_INPORT, 0x03);
+
+	/* GPIO14/15 set Open drain */
+	pwc_write(DA9052_GPIO1415_REG,
+		PWC_GPO_OPEN_DRAIN | (PWC_GPO_OPEN_DRAIN << 4) | 0x88,
+		0xBB);
+
+	pwc_reg_write(DA9052_LDO5_REG, 0x66); /* LCD power ON */
+
+
+	/* All Mask */
+	pwc_reg_write(DA9052_IRQMASKA_REG, 0xff);
+	pwc_reg_write(DA9052_IRQMASKB_REG, 0xff);
+	pwc_reg_write(DA9052_IRQMASKC_REG, 0xff);
+	pwc_reg_write(DA9052_IRQMASKD_REG, 0xff);
+
+	/* All Clear */
+	pwc_reg_write(DA9052_EVENTA_REG, 0xff);
+	pwc_reg_write(DA9052_EVENTB_REG, 0xff);
+	pwc_reg_write(DA9052_EVENTC_REG, 0xff);
+	pwc_reg_write(DA9052_EVENTD_REG, 0xff);
+
+	/* Initialize PWC INT */
+	set_irq_type(INT_GPIO_INTOUT, IRQ_TYPE_LEVEL_LOW);
+	set_irq_chained_handler(INT_GPIO_INTOUT, mp200_pwc_irq_handler);
+
+#else /* CONFIG_MP200_EM1_DKIT */
+
+	/* Initialize PWC registers */
+	pwc_write(PWC_IOSEL1, PWC_GIO_OUTPORT1, MASK_PWC_IOSEL1);
+	pwc_write(PWC_IOSEL2, PWC_GIO_OUTPORT2, MASK_PWC_IOSEL2);
+
+	/* Initialize PWC INT */
+	set_irq_type(INT_GPIO_INTOUT, IRQ_TYPE_LEVEL_HIGH);
+	set_irq_chained_handler(INT_GPIO_INTOUT, mp200_pwc_irq_handler);
+
+#endif /* CONFIG_MP200_EM1_DKIT */
+
+	return 0;
+}
+
+module_init(mp200_pwc_init);
+
-- 
1.6.5.2

