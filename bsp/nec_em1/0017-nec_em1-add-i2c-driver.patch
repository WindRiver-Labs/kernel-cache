From 73a680986d51f81fadab687d40043d8b1bb96b9f Mon Sep 17 00:00:00 2001
From: Kazuya Tsukamoto <kazuya.tsukamoto@necel.com>
Date: Mon, 9 Nov 2009 12:15:44 +0900
Subject: [PATCH 17/29] nec_em1: add i2c driver

I2C is used in EMMA Mobile Develpment Kit Board for
AK4648, ADV7179, MAX7324.

Device  | Write Address  | Read Address
AK4648  |          0x13  |         0x12
ADV7179 |          0x56  |         0x57
MAX7234 |          0xBA  |         0xDB

Signed-off-by: Kazuya Tsukamoto <kazuya.tsukamoto@necel.com>
---
 drivers/i2c/busses/Kconfig     |   28 ++
 drivers/i2c/busses/Makefile    |    1 +
 drivers/i2c/busses/i2c-mp200.c |  927 ++++++++++++++++++++++++++++++++++++++++
 drivers/i2c/busses/i2c-mp200.h |  126 ++++++
 include/linux/i2c-id.h         |    9 +-
 5 files changed, 1089 insertions(+), 2 deletions(-)
 create mode 100644 drivers/i2c/busses/i2c-mp200.c
 create mode 100644 drivers/i2c/busses/i2c-mp200.h

diff --git a/drivers/i2c/busses/Kconfig b/drivers/i2c/busses/Kconfig
index eb94378..4cb2a65 100644
--- a/drivers/i2c/busses/Kconfig
+++ b/drivers/i2c/busses/Kconfig
@@ -504,6 +504,34 @@ config I2C_VERSATILE
 	  This driver can also be built as a module.  If so, the module
 	  will be called i2c-versatile.
 
+config I2C_MP200
+	tristate "mp200 I2C adapter"
+	depends on I2C && ARCH_MP200
+	select I2C_MP200_ENABLE_CH1
+	help
+	  If you say yes to this option, support will be included for the
+	  I2C interface on the NEC Electronics EM1 of processors.
+
+config I2C_MP200_ENABLE_CH1
+	bool "enable CH1" 
+	depends on I2C && ARCH_MP200 && I2C_MP200 
+
+config I2C_MP200_ENABLE_CH2
+	bool "enable CH2"
+	depends on I2C && ARCH_MP200 && I2C_MP200
+
+config I2C_MP200_SMC
+	int "Speed mode control(0:standard mode/1:fast mode)"
+	range 0 1
+	default "1"
+	depends on I2C && ARCH_MP200 && I2C_MP200
+
+config I2C_MP200_DFC
+	int "Digital filter control(0:OFF/1:ON)"
+	range 0 1
+	default "0"
+	depends on I2C && ARCH_MP200 && I2C_MP200 && I2C_MP200_SMC=1
+
 comment "External I2C/SMBus adapter drivers"
 
 config I2C_PARPORT
diff --git a/drivers/i2c/busses/Makefile b/drivers/i2c/busses/Makefile
index d4dc22d..a1bbb2b 100644
--- a/drivers/i2c/busses/Makefile
+++ b/drivers/i2c/busses/Makefile
@@ -46,6 +46,7 @@ obj-$(CONFIG_I2C_SH7760)	+= i2c-sh7760.o
 obj-$(CONFIG_I2C_SH_MOBILE)	+= i2c-sh_mobile.o
 obj-$(CONFIG_I2C_SIMTEC)	+= i2c-simtec.o
 obj-$(CONFIG_I2C_VERSATILE)	+= i2c-versatile.o
+obj-$(CONFIG_I2C_MP200)		+= i2c-mp200.o
 
 # External I2C/SMBus adapter drivers
 obj-$(CONFIG_I2C_PARPORT)	+= i2c-parport.o
diff --git a/drivers/i2c/busses/i2c-mp200.c b/drivers/i2c/busses/i2c-mp200.c
new file mode 100644
index 0000000..9865085
--- /dev/null
+++ b/drivers/i2c/busses/i2c-mp200.c
@@ -0,0 +1,927 @@
+/*
+ *  File Name	    : linux/drivers/i2c/busses/i2c-mp200.c
+ *  Function	    : i2c
+ *  Release Version : Ver 1.26
+ *  Release Date    : 2009/11/06
+ *
+ *  Copyright (C) NEC Electronics Corporation 2007, 2008, 2009
+ *
+ *
+ *  This program is free software;you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by Free
+ * Softwere Foundation; either version 2 of License, or (at your option) any
+ * later version.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY;
+ *  without even the implied warrnty of MERCHANTABILITY or FITNESS FOR A
+ * PARTICULAR PURPOSE.
+ *  See the GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ * with this program;
+ *  If not, write to the Free Software Foundation, Inc., 59 Temple Place -
+ * Suite 330, Boston,
+ *  MA 02111-1307, USA.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/ioport.h>
+#include <linux/version.h>
+#include <linux/i2c.h>
+#include <linux/io.h>
+#include <asm/irq.h>
+#include <linux/uaccess.h>
+#include <linux/errno.h>
+#include <linux/sched.h>
+
+#include <linux/device.h>
+#include <linux/moduleparam.h>
+#include <linux/interrupt.h>
+#include <linux/ioctl.h>
+#include <linux/platform_device.h>
+
+#include <mach/pmu.h>
+#include <mach/smu.h>
+
+#include "i2c-mp200.h"
+
+/* #define I2C_DEBUG 1 */
+
+#ifdef I2C_DEBUG
+#define DBG(level, format, arg...) printk(level format, ## arg)
+#else
+#define DBG(level, format, arg...) do { } while (0)
+#endif
+
+static int i2c_pending[I2C_NR];
+static spinlock_t i2c_lock;
+static spinlock_t i2c_irq_lock;
+
+static int irq = 1;	/* polling mode flag(default=1 is interrupt mode) */
+
+static int mp200_i2c_xfer(struct i2c_adapter *, struct i2c_msg[], int);
+static int mp200_i2c_xbytes(struct i2c_adapter *, struct i2c_msg *, int);
+static int mp200_i2c_suspend(struct platform_device *dev, pm_message_t state);
+static int mp200_i2c_resume(struct platform_device *dev);
+
+
+struct mp200_i2c_device_ {
+	struct i2c_adapter	adap;
+	wait_queue_head_t	i2c_wait;
+	char			*membase;
+	int			irq;
+	unsigned int		ch;
+	int			rstdev;
+	int			clkdev;
+	int			sclkdev;
+	int			mst;
+};
+#define mp200_i2c_device	struct mp200_i2c_device_
+
+
+#ifndef CONFIG_I2C_MP200_DFC
+#define CONFIG_I2C_MP200_DFC I2C_DFC_OFF
+#endif
+
+
+static i2c_ctrl_t mp200_i2c_ctrl = {
+	.smc = CONFIG_I2C_MP200_SMC,	/* mode */
+	.dfc = CONFIG_I2C_MP200_DFC,	/* digital filter */
+};
+
+static u32 mp200_i2c_func(struct i2c_adapter *adap)
+{
+	return I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;
+}
+
+
+static struct i2c_algorithm mp200_i2c_algo = {
+	.master_xfer = mp200_i2c_xfer,
+	.smbus_xfer = NULL,
+	.functionality = mp200_i2c_func,
+};
+
+static mp200_i2c_device mp200_i2c_devs[I2C_NR] = {
+	[0] = {
+		.adap = {
+			.owner = THIS_MODULE,
+			.name = "mp200 I2C1 adapter",
+			.id = I2C_HW_MP200,
+			.algo = &mp200_i2c_algo,
+			.algo_data = &mp200_i2c_ctrl,
+			.client_register = NULL,
+			.client_unregister = NULL,
+			.timeout = 100,		/* 1sec */
+			.retries = 3,		/* 3times */
+		},
+		.membase = (void *)I2C_ADDR,
+		.irq	= INT_IIC,
+		.ch	= MP200_I2C_CH1,
+		.rstdev = MP200_RESETDEVICE_IIC,
+		.clkdev = MP200_CLOCKGATE_IIC_CLK,
+		.sclkdev = MP200_CLOCKGATE_IIC_SCLK,
+		.mst    = MP200_I2C_INTC_MST,
+	},
+#ifdef CONFIG_I2C_MP200_ENABLE_CH2
+	[1] = {
+		.adap = {
+			.owner = THIS_MODULE,
+			.name = "mp200 I2C2 adapter",
+			.id = I2C_HW_MP200,
+			.algo = &mp200_i2c_algo,
+			.algo_data = &mp200_i2c_ctrl,
+			.client_register = NULL,
+			.client_unregister = NULL,
+			.timeout = 100,		/* 1sec */
+			.retries = 3,		/* 3times */
+		},
+		.membase = (void *)I2C2_ADDR,
+		.irq	= INT_IIC2,
+		.ch	= MP200_I2C_CH2,
+		.rstdev = MP200_RESETDEVICE_IIC2,
+		.clkdev = MP200_CLOCKGATE_IIC2_CLK,
+		.sclkdev = MP200_CLOCKGATE_IIC2_SCLK,
+		.mst    = MP200_I2C2_INTC_MST,
+	},
+#endif
+};
+
+static void mp200_i2c_enable_clock(mp200_i2c_device *i2c_dev)
+{
+	mp200_pmu_open_clockgate(i2c_dev->sclkdev);
+	mp200_pmu_open_clockgate(i2c_dev->clkdev);
+}
+
+static void mp200_i2c_disable_clock(mp200_i2c_device *i2c_dev)
+{
+	mp200_pmu_close_clockgate(i2c_dev->clkdev);
+	mp200_pmu_close_clockgate(i2c_dev->sclkdev);
+}
+
+static int mp200_i2c_get_clock_status(struct platform_device *dev)
+{
+	mp200_i2c_device *i2c_dev = platform_get_drvdata(dev);
+
+	if (mp200_pmu_get_clockgate(i2c_dev->sclkdev) ||
+		mp200_pmu_get_clockgate(i2c_dev->clkdev)) {
+		return 1;
+	}
+
+	return 0;
+}
+
+static void mp200_i2c_setup_mode(struct i2c_adapter *adap)
+{
+	u16 bit = 0x0;
+	i2c_ctrl_t *ctrl = (i2c_ctrl_t *) adap->algo_data;
+	mp200_i2c_device *i2c_dev;
+
+	i2c_dev = (mp200_i2c_device *)(i2c_get_adapdata(adap));
+
+	DBG(KERN_INFO, "%s(): IICCL0: %04x (reg:0x%08x)\n",
+		__func__,
+		inw(i2c_dev->membase + I2C_OFS_IICCL0),
+		(unsigned int)i2c_dev->membase+I2C_OFS_IICCL0);
+
+	/* mode */
+	if (ctrl->smc == I2C_SMC_HIGH_SPEED) {
+		/* High-speed mode */
+		bit |= I2C_BIT_SMC0;
+	}
+
+	/* digital filter */
+	if (ctrl->dfc == I2C_DFC_ON) {
+		/* digital filter ON */
+		bit |= I2C_BIT_DFC0;
+	}
+
+	outw(bit, i2c_dev->membase + I2C_OFS_IICCL0);
+
+	DBG(KERN_INFO, "%s(): IICCL0: %04x (reg:0x%08x)\n",
+		__func__,
+		inw(i2c_dev->membase + I2C_OFS_IICCL0),
+		(unsigned int)i2c_dev->membase + I2C_OFS_IICCL0);
+}
+
+static int mp200_i2c_wait_sp(mp200_i2c_device *i2c_dev)
+{
+	int timeout = 200;
+
+	/* Stop condition */
+	spin_lock(&i2c_lock);
+	outw((inw(i2c_dev->membase + I2C_OFS_IICC0) | I2C_BIT_SPT0),
+		i2c_dev->membase + I2C_OFS_IICC0);
+	spin_unlock(&i2c_lock);
+
+	while ((inw(i2c_dev->membase + I2C_OFS_IICSE0) & I2C_BIT_SPD0) == 0) {
+		if (0 == timeout--) {
+			DBG(KERN_INFO,
+				"%s(): could not detect stop condition\n",
+				__func__);
+			return -EBUSY;
+		}
+		udelay(1);
+	}
+	DBG(KERN_INFO, "%s(): stop:: con: %04x, stat: %04x\n",
+		__func__,
+		inw(i2c_dev->membase + I2C_OFS_IICC0),
+		inw(i2c_dev->membase + I2C_OFS_IICSE0));
+
+	return 0;
+}
+
+static void mp200_i2c_reset(struct i2c_adapter *adap)
+{
+	mp200_i2c_device *i2c_dev;
+
+	i2c_dev = (mp200_i2c_device *)(i2c_get_adapdata(adap));
+	/* I2C disable */
+	if (inw(i2c_dev->membase + I2C_OFS_IICC0) & I2C_BIT_IICE0) {
+#if 1
+		if ((inw(i2c_dev->membase + I2C_OFS_IICCL0)
+				& (I2C_BIT_CLD0 | I2C_BIT_DAD0))
+				!= (I2C_BIT_CLD0 | I2C_BIT_DAD0)) {
+
+			mp200_i2c_wait_sp(i2c_dev);
+			/* what about case error returned. */
+		}
+#endif
+		spin_lock(&i2c_lock);
+		outw(0, i2c_dev->membase + I2C_OFS_IICC0);
+		spin_unlock(&i2c_lock);
+	}
+	/* transfer mode set */
+	mp200_i2c_setup_mode(adap);
+
+	/* Refuse transaction */
+	/* Can write STCEN at not trns other i2c.*/
+	outw((I2C_BIT_STCEN | I2C_BIT_IICRSV),
+		i2c_dev->membase + I2C_OFS_IICF0);
+
+	/* I2C enable, 9bit interrupt mode */
+	spin_lock(&i2c_lock);
+	outw((I2C_BIT_IICE0 | I2C_BIT_WTIM0), i2c_dev->membase + I2C_OFS_IICC0);
+	spin_unlock(&i2c_lock);
+
+	DBG(KERN_INFO, "%s()_: con: %04x, stat: %04x (reg:0x%08x,0x%08X)\n",
+		__func__,
+		inw(i2c_dev->membase + I2C_OFS_IICC0),
+		inw(i2c_dev->membase + I2C_OFS_IICSE0),
+		(unsigned int)i2c_dev->membase + I2C_OFS_IICC0,
+		(unsigned int)i2c_dev->membase + I2C_OFS_IICSE0);
+}
+
+/*
+ * Wait until I2C bus is free
+ */
+static int mp200_i2c_wait_for_bb(struct i2c_adapter *adap)
+{
+	mp200_i2c_device *i2c_dev;
+	int status;
+	int timeout = adap->timeout;
+
+	i2c_dev = (mp200_i2c_device *)(i2c_get_adapdata(adap));
+
+	/* wait until I2C bus free */
+	while ((inw(i2c_dev->membase + I2C_OFS_IICF0) & I2C_BIT_IICBSY)
+			&& timeout--) {
+		schedule_timeout_uninterruptible(1);
+	}
+
+	status = (timeout <= 0);		/* set 0 or 1 */
+	if (status)
+		DBG(KERN_INFO, "%s(): Timeout, I2C bus is busy\n", __func__);
+
+	return status;
+}
+
+/*
+ * Wait until INT_I2C handler will be interrupted
+ */
+static int mp200_i2c_wait_for_pin(struct i2c_adapter *adap, u16 *status)
+{
+	mp200_i2c_device *i2c_dev;
+	int retries = adap->retries;
+	unsigned long timeout;
+	int pending = 0;
+	sigset_t oldset;
+	sigset_t newset;
+
+	DECLARE_WAITQUEUE(wait, current);
+
+	i2c_dev = (mp200_i2c_device *)(i2c_get_adapdata(adap));
+
+	if (irq) {
+		add_wait_queue(&i2c_dev->i2c_wait, &wait);
+		spin_lock_irq(&current->sighand->siglock);
+		oldset = current->blocked;
+		newset = current->blocked;
+		spin_unlock_irq(&current->sighand->siglock);
+		sigaddset(&newset, SIGINT);
+		sigaddset(&newset, SIGKILL);
+		sigprocmask(SIG_BLOCK, &newset, NULL);
+	}
+
+	do {
+		/* interrupt mode */
+		if (irq) {
+			timeout = adap->timeout;
+			current->state = TASK_UNINTERRUPTIBLE;
+
+			spin_lock_irq(&i2c_irq_lock);
+			pending = i2c_pending[i2c_dev->ch];
+			i2c_pending[i2c_dev->ch] = 0;
+			spin_unlock_irq(&i2c_irq_lock);
+
+			*status = inw(i2c_dev->membase + I2C_OFS_IICSE0);
+			DBG(KERN_INFO,
+			 "%s(): con: %04x, stat: %04x (reg:0x%08x,0x%08x)\n",
+			 __func__,
+			 inw(i2c_dev->membase + I2C_OFS_IICC0),
+			 *status,
+			 (unsigned int)i2c_dev->membase + I2C_OFS_IICC0,
+			 (unsigned int)i2c_dev->membase + I2C_OFS_IICC0);
+
+			if (pending)
+				break;
+
+			schedule_timeout(timeout);
+		}
+		/* polling mode */
+		else {
+			timeout = adap->timeout * 10000;
+			do {
+				udelay(10);
+
+				/* Check INT_I2C/INT_I2C2 bit */
+				if (i2c_dev->mst
+					& inl(MP200_I2C_INTC_IT0_RAW)) {
+
+					outl(i2c_dev->mst,
+						MP200_I2C_INTC_IT0_IIR);
+					pending = 1;
+					break;
+				}
+			} while (--timeout);
+
+			*status = inw(i2c_dev->membase + I2C_OFS_IICSE0);
+			DBG(KERN_INFO, "%s(): con: %04x, stat: %04x\n",
+				__func__,
+				inw(i2c_dev->membase + I2C_OFS_IICC0), *status);
+
+			if (pending)
+				break;
+
+		}
+
+	} while ((*status & I2C_BIT_MSTS0) && retries--);
+
+	/* interrupt mode */
+	if (irq) {
+		sigprocmask(SIG_SETMASK, &oldset, NULL);
+		current->state = TASK_RUNNING;
+		remove_wait_queue(&i2c_dev->i2c_wait, &wait);
+	}
+
+	/* retry counter is expired */
+	if (retries <= 0)
+		DBG(KERN_INFO, "%s(): Timeout\n", __func__);
+
+
+	return (retries <= 0) ? -1 : 0;
+}
+
+/*
+ * master_xfer Interface
+ */
+static int mp200_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs,
+	int num)
+{
+	int i;
+	int status = 0;
+	mp200_i2c_device *i2c_dev;
+
+	DBG(KERN_INFO, "%s(): msgs: %d\n", __func__, num);
+
+	i2c_dev = (mp200_i2c_device *)(i2c_get_adapdata(adap));
+
+	/* Check invalid param in i2c_msg */
+	if (msgs == NULL)
+		return -EINVAL;
+
+	for (i = 0; i < num; i++) {
+		if (msgs[i].buf == NULL)
+			return -EINVAL;
+
+	}
+
+	/* I2C macro Enable */
+	mp200_i2c_enable_clock(i2c_dev);
+	/* I2C transfer mode set */
+	mp200_i2c_reset(adap);
+
+	status = mp200_i2c_wait_for_bb(adap);
+	if (status) {
+		DBG(KERN_INFO, "%s(): %s: bus busy\n", __func__, adap->name);
+
+		if (!(inw(i2c_dev->membase + I2C_OFS_IICSE0)
+				& I2C_BIT_MSTS0)) {
+			/* Slave mode -> Error */
+			mp200_i2c_disable_clock(i2c_dev);
+			return -EBUSY;
+		}
+		DBG(KERN_INFO,
+			"%s(): %s is already active. Stop Condition...\n",
+			__func__, adap->name);
+		/* Stop condition */
+		spin_lock(&i2c_lock);
+		outw((inw(i2c_dev->membase + I2C_OFS_IICC0) | I2C_BIT_SPT0),
+			i2c_dev->membase + I2C_OFS_IICC0);
+		spin_unlock(&i2c_lock);
+
+		status = mp200_i2c_wait_for_bb(adap);
+		if (status) {
+			DBG(KERN_INFO,
+				"%s(): %s is already active. Reset...\n",
+				__func__, adap->name);
+			/* I2C Reset */
+			mp200_i2c_reset(adap);
+
+			if (mp200_i2c_wait_for_bb(adap)) {
+				DBG(KERN_INFO,
+				"%s(): %s is already active. Reset failed...\n",
+				__func__, adap->name);
+
+				mp200_i2c_disable_clock(i2c_dev);
+				return -EREMOTEIO;
+			}
+		}
+	}
+
+	for (i = 0; i < num; i++) {
+		DBG(KERN_INFO,
+			"%s(): msg: %d, addr: 0x%04x, len: %d, flags: 0x%x\n",
+			__func__, i, msgs[i].addr, msgs[i].len, msgs[i].flags);
+
+		/* Transfer msgs[] */
+		status = mp200_i2c_xbytes(adap, &msgs[i], (i == (num - 1)));
+
+		DBG(KERN_INFO, "%s(): status : %d\n", __func__, status);
+		if (status < 0) {
+			/* transfer error */
+			break;
+		}
+	}
+
+	/* I2C transfer completed */
+	if (status >= 0) {
+		/* the number of i2c_msg transfered */
+		status = i;
+	}
+
+	DBG(KERN_INFO, "%s(): status : %d\n", __func__, status);
+
+	/* I2C macro Disable */
+	mp200_i2c_disable_clock(i2c_dev);
+	/* if after stop clock then register all zero. */
+
+	return status;
+}
+
+/*
+ * master_xfer transaction(Low level)
+ */
+static int mp200_i2c_xbytes(struct i2c_adapter *adap, struct i2c_msg *msg,
+	int stop)
+{
+	u16 status;
+	u8 data = 0;
+	int count = 0;
+	int timeout;
+	mp200_i2c_device *i2c_dev = (mp200_i2c_device *)i2c_get_adapdata(adap);
+
+	DBG(KERN_INFO, "%s(): addr: 0x%04x, len: %d, flags: 0x%x, stop: %d\n",
+		__func__, msg->addr, msg->len, msg->flags, stop);
+
+	/* interrupt mode */
+	if (irq) {
+		spin_lock_irq(&i2c_irq_lock);
+		i2c_pending[i2c_dev->ch] = 0;
+		spin_unlock_irq(&i2c_irq_lock);
+	}
+
+	/* Start condition */
+	spin_lock(&i2c_lock);
+	outw((inw(i2c_dev->membase + I2C_OFS_IICC0) & ~I2C_BIT_ACKE0)
+		| I2C_BIT_WTIM0, i2c_dev->membase + I2C_OFS_IICC0);
+	outw((inw(i2c_dev->membase + I2C_OFS_IICC0) | I2C_BIT_STT0),
+		i2c_dev->membase + I2C_OFS_IICC0);
+	spin_unlock(&i2c_lock);
+
+	/* wait for completion of Start condition */
+	timeout = 10;
+	do {
+		udelay(MP200_I2C_WAIT); /* 1us wait */
+		DBG(KERN_INFO, "%s(): con: %04x, flg: %04x\n", __func__,
+			inw(i2c_dev->membase + I2C_OFS_IICC0),
+			inw(i2c_dev->membase + I2C_OFS_IICF0));
+		if (((inw(i2c_dev->membase + I2C_OFS_IICF0)
+			& I2C_BIT_STCF) == 0)
+			&& (inw(i2c_dev->membase + I2C_OFS_IICSE0)
+			& I2C_BIT_MSTS0)) {
+			break;
+		}
+		if (--timeout == 0)
+			return -EBUSY;
+
+	} while (1);
+	DBG(KERN_INFO, "%s(): addr: %04x, flags: %04x\n", __func__, msg->addr,
+		msg->flags);
+	DBG(KERN_INFO, "%s(): addrdir: %04x\n", __func__,
+		(msg->addr << I2C_DIR_SHIFT)
+		| ((msg->flags & I2C_M_RD) ? 1 : 0));
+
+	/* Send slave address and R/W type */
+	outw((msg->addr << I2C_DIR_SHIFT)
+		| ((msg->flags & I2C_M_RD) ? 1 : 0),
+		i2c_dev->membase + I2C_OFS_IIC0);
+
+	/* Wait for transaction */
+	if (mp200_i2c_wait_for_pin(adap, &status)) {
+		mp200_i2c_reset(adap);
+		return -EREMOTEIO;
+	}
+
+	/* Arbitration */
+	if (status & I2C_BIT_ALD0) {
+		mp200_i2c_reset(adap);
+		return -EREMOTEIO;
+	}
+	/* Extension mode or Slave mode */
+	else if (status & (I2C_BIT_EXC0 | I2C_BIT_COI0)
+			|| !(status & I2C_BIT_MSTS0)) {
+		mp200_i2c_reset(adap);
+		return -EREMOTEIO;
+	}
+	/* Read transaction */
+	else if (!(status & I2C_BIT_TRC0)) {
+		/* msg->flags is Write type */
+		if (!(msg->flags & I2C_M_RD)) {
+			DBG(KERN_INFO, "%s(): %s r/w hardware fault.\n",
+				__func__, adap->name);
+			mp200_i2c_reset(adap);
+			return -EREMOTEIO;
+		}
+
+		/* Recieved No ACK (result of setting slave address and R/W) */
+		if (!(status & I2C_BIT_ACKD0)) {
+			DBG(KERN_INFO, "%s(): %s recieved No ACK.\n",
+				__func__, adap->name);
+			/* Stop condition */
+			mp200_i2c_wait_sp(i2c_dev);
+			return -EREMOTEIO;
+		}
+
+		/* 8bit interrupt mode */
+		spin_lock(&i2c_lock);
+		outw((inw(i2c_dev->membase + I2C_OFS_IICC0) & ~I2C_BIT_WTIM0)
+			| I2C_BIT_ACKE0, i2c_dev->membase + I2C_OFS_IICC0);
+		outw((inw(i2c_dev->membase + I2C_OFS_IICC0) & ~I2C_BIT_WTIM0)
+			| I2C_BIT_WREL0, i2c_dev->membase + I2C_OFS_IICC0);
+		spin_unlock(&i2c_lock);
+
+		/* Wait for transaction */
+		if (mp200_i2c_wait_for_pin(adap, &status)) {
+			mp200_i2c_reset(adap);
+			return -EREMOTEIO;
+		}
+	}
+
+	do {
+		/* Arbitration */
+		if (status & I2C_BIT_ALD0) {
+			mp200_i2c_reset(adap);
+			return -EREMOTEIO;
+		}
+		/* Extension mode or Slave mode */
+		else if (status & (I2C_BIT_EXC0 | I2C_BIT_COI0)
+				|| !(status & I2C_BIT_MSTS0)) {
+			mp200_i2c_reset(adap);
+			return -EREMOTEIO;
+		}
+		/* Read transaction */
+		else if (!(status & I2C_BIT_TRC0)) {
+			/* msg->flags is Write type */
+			if (!(msg->flags & I2C_M_RD)) {
+				DBG(KERN_INFO, "%s(): %s r/w hardware fault.\n",
+					__func__, adap->name);
+				mp200_i2c_reset(adap);
+				return -EREMOTEIO;
+			}
+
+			/* Read transaction is completed without any errors */
+			if (count == msg->len)
+				break;
+
+			/* read data */
+			data = inw(i2c_dev->membase + I2C_OFS_IIC0);
+			DBG(KERN_INFO, "%s(): read: data: %04x\n", __func__,
+				data);
+			if (count < msg->len) {
+				msg->buf[count++] = data;
+			} else if (msg->len != 0) {
+				/* recieve error */
+				DBG(KERN_INFO, "%s(): %s rcv count mismatch.\n",
+					__func__, adap->name);
+				break;
+			}
+
+			if (count < msg->len) {
+				spin_lock(&i2c_lock);
+				outw((inw(i2c_dev->membase + I2C_OFS_IICC0)
+					| I2C_BIT_WREL0),
+					i2c_dev->membase + I2C_OFS_IICC0);
+				spin_unlock(&i2c_lock);
+			} else {
+				spin_lock(&i2c_lock);
+				outw((inw(i2c_dev->membase + I2C_OFS_IICC0)
+					& ~I2C_BIT_ACKE0) | I2C_BIT_WTIM0,
+					i2c_dev->membase + I2C_OFS_IICC0);
+				outw(inw(i2c_dev->membase + I2C_OFS_IICC0)
+					| I2C_BIT_WREL0,
+					i2c_dev->membase + I2C_OFS_IICC0);
+				spin_unlock(&i2c_lock);
+			}
+
+		/* Write transaction */
+		} else if (status & I2C_BIT_TRC0) {
+			/* msg->flags is Read type */
+			if ((msg->flags & I2C_M_RD)) {
+				DBG(KERN_INFO, "%s(): %s r/w hardware fault.\n",
+					__func__, adap->name);
+				mp200_i2c_reset(adap);
+				return -EREMOTEIO;
+			}
+
+			/* Recieved No ACK (result of setting slave address
+			 * and R/W)
+			 */
+			if (!(status & I2C_BIT_ACKD0)) {
+				DBG(KERN_INFO, "%s(): %s recieved No ACK.\n",
+					__func__, adap->name);
+				/* Stop condition */
+				mp200_i2c_wait_sp(i2c_dev);
+				return -EREMOTEIO;
+			}
+
+			if (count < msg->len) {
+				data = msg->buf[count++];
+			} else if (count == msg->len) {
+				/* send transaction is completed without any
+				 * errors
+				 */
+				break;
+			} else if (msg->len != 0) {
+				/* send error */
+				DBG(KERN_INFO, "%s(): %s xmt count mismatch.\n",
+					__func__, adap->name);
+				break;
+			}
+
+			/* write data */
+			DBG(KERN_INFO, "%s(): write: data: %04x\n", __func__,
+				data);
+			outw(data, i2c_dev->membase + I2C_OFS_IIC0);
+
+		/* not reached ? */
+		} else {
+			DBG(KERN_INFO, "%s(): con: %04x, stat: %04x\n",
+				__func__, inw(i2c_dev->membase + I2C_OFS_IICC0),
+				inw(i2c_dev->membase + I2C_OFS_IICSE0));
+		}
+
+		/* Wait for R/W transaction */
+		if (mp200_i2c_wait_for_pin(adap, &status)) {
+			mp200_i2c_reset(adap);
+			return -EREMOTEIO;
+		}
+	} while (count <= msg->len);
+
+	DBG(KERN_INFO, "%s(): count: %d, len: %d, stop %d\n", __func__, count,
+		msg->len, stop);
+
+	/* Stop condition */
+	if ((count >= msg->len) && stop) {
+		spin_lock(&i2c_lock);
+		outw((inw(i2c_dev->membase + I2C_OFS_IICC0) | I2C_BIT_SPT0),
+			i2c_dev->membase + I2C_OFS_IICC0);
+		spin_unlock(&i2c_lock);
+		timeout = 200;
+		while ((inw(i2c_dev->membase + I2C_OFS_IICSE0)
+				& I2C_BIT_SPD0) == 0) {
+			if (0 == timeout--) {
+				DBG(KERN_INFO,
+				"%s(): could not detect stop condition\n",
+				__func__);
+				return -EBUSY;
+			}
+			udelay(1);
+		}
+		DBG(KERN_INFO, "%s(): stop:: con: %04x, stat: %04x\n",
+			__func__, inw(i2c_dev->membase + I2C_OFS_IICC0),
+			inw(i2c_dev->membase + I2C_OFS_IICSE0));
+	}
+
+	return (count > 0) ? (msg->len ? count : 0) : count;
+}
+
+static int mp200_i2c_add_bus(struct i2c_adapter *adap)
+{
+	mp200_i2c_device *i2c_dev =
+		(mp200_i2c_device *)(i2c_get_adapdata(adap));
+
+	DBG(KERN_INFO, "%s(): hw routines for %s registered.\n", __func__,
+		adap->name);
+
+	i2c_add_numbered_adapter(adap);
+
+	mp200_i2c_enable_clock(i2c_dev);
+	mp200_pmu_unreset_device(i2c_dev->rstdev);
+	mp200_i2c_reset(adap);
+	mp200_i2c_disable_clock(i2c_dev);
+
+	return 0;
+}
+
+static int mp200_i2c_del_bus(struct i2c_adapter *adap)
+{
+	int res;
+
+	res = i2c_del_adapter(adap);
+	if (res < 0)
+		return res;
+
+	DBG(KERN_INFO, "%s(): adapter unregistered: %s\n", __func__,
+		adap->name);
+
+	return 0;
+}
+
+
+static irqreturn_t mp200_i2c_handler(int this_irq, void *dev_id,
+	struct pt_regs *regs)
+{
+	mp200_i2c_device *i2c_dev = dev_id;
+
+	spin_lock(&i2c_irq_lock);
+	i2c_pending[i2c_dev->ch] = 1;
+	spin_unlock(&i2c_irq_lock);
+
+	DBG(KERN_INFO, "%s(): in interrupt handler\n", __func__);
+
+	wake_up(&i2c_dev->i2c_wait);
+
+	return IRQ_HANDLED;
+}
+
+
+static int mp200_i2c_hw_resrc_init(struct platform_device *dev)
+{
+	mp200_i2c_device *i2c_dev = platform_get_drvdata(dev);
+	DBG(KERN_INFO, "%s(): resrc Initializing.\n", __func__);
+
+	if (i2c_dev->ch == MP200_I2C_CH1) {
+		outl((inl(SMU_DIVIICSCLK) & 0x00ff0000) | I2C_DIVIIC_VAL1,
+			SMU_DIVIICSCLK);
+		if (irq) {
+			if (request_irq(i2c_dev->irq, (void *)mp200_i2c_handler,
+					0, "mp200_i2c",
+					&mp200_i2c_devs[0]) < 0) {
+				return -ENODEV;
+			}
+		}
+	}
+#ifdef CONFIG_I2C_MP200_ENABLE_CH2
+	else
+	if (i2c_dev->ch == MP200_I2C_CH2) {
+		outl((inl(SMU_DIVIICSCLK) & 0x000000ff)
+			| I2C_DIVIIC_VAL2, SMU_DIVIICSCLK);
+		if (irq) {
+			if (request_irq(i2c_dev->irq, (void *)mp200_i2c_handler,
+					0, "mp200_i2c",
+					&mp200_i2c_devs[1]) < 0) {
+				return -ENODEV;
+			}
+		}
+	}
+#endif
+
+	return 0;
+}
+
+static void mp200_i2c_release(struct platform_device *dev)
+{
+	mp200_i2c_device *i2c_dev = platform_get_drvdata(dev);
+
+	if (irq)
+		free_irq(i2c_dev->irq, &mp200_i2c_devs[i2c_dev->ch]);
+
+}
+
+
+static int mp200_i2c_suspend(struct platform_device *dev, pm_message_t state)
+{
+	switch (state.event) {
+	case DEV_SUSPEND_IDLE_1:
+	case PM_EVENT_SUSPEND:
+		if (mp200_i2c_get_clock_status(dev))
+			return -EBUSY;
+		break;
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+static int mp200_i2c_resume(struct platform_device *dev)
+{
+	return 0;
+}
+
+
+/*
+ * this function is called when this module is loaded.
+ */
+static int mp200_i2c_probe(struct platform_device *dev)
+{
+	DBG(KERN_INFO, "Starting mp200_i2c.\n");
+
+	if (dev->id > I2C_NR)
+		return -ENODEV;
+
+	platform_set_drvdata(dev, &mp200_i2c_devs[dev->id]);
+	i2c_set_adapdata(&mp200_i2c_devs[dev->id].adap,
+				&mp200_i2c_devs[dev->id]);
+
+	if (mp200_i2c_hw_resrc_init(dev) < 0)
+		return -ENODEV;
+
+	init_waitqueue_head(&mp200_i2c_devs[dev->id].i2c_wait);
+
+	mp200_i2c_devs[dev->id].adap.nr = dev->id;
+	if (mp200_i2c_add_bus(&mp200_i2c_devs[dev->id].adap) < 0)
+		return -ENODEV;
+
+	return 0;
+}
+
+static int mp200_i2c_remove(struct platform_device *dev)
+{
+	mp200_i2c_device *i2c_dev = platform_get_drvdata(dev);
+
+	DBG(KERN_INFO, "%s(): ch=%d.\n", __func__, i2c_dev->ch);
+
+	mp200_i2c_del_bus(&mp200_i2c_devs[i2c_dev->ch].adap);
+	mp200_i2c_release(dev);
+
+	return 0;
+}
+
+static struct platform_driver mp200_i2c_driver = {
+	.probe = mp200_i2c_probe,
+	.remove = mp200_i2c_remove,
+	.suspend = mp200_i2c_suspend,
+	.resume = mp200_i2c_resume,
+	.driver = {
+		.name = "i2c",
+		.owner = THIS_MODULE
+	}
+};
+
+
+static int __init mp200_i2c_init(void)
+{
+	spin_lock_init(&i2c_lock);
+	spin_lock_init(&i2c_irq_lock);
+
+	return platform_driver_register(&mp200_i2c_driver);
+}
+
+static void __exit mp200_i2c_exit(void)
+{
+	platform_driver_unregister(&mp200_i2c_driver);
+}
+
+module_param(irq, int, 0);
+
+MODULE_LICENSE("GPL");
+
+module_init(mp200_i2c_init);
+module_exit(mp200_i2c_exit);
diff --git a/drivers/i2c/busses/i2c-mp200.h b/drivers/i2c/busses/i2c-mp200.h
new file mode 100644
index 0000000..e5676e8
--- /dev/null
+++ b/drivers/i2c/busses/i2c-mp200.h
@@ -0,0 +1,126 @@
+/*
+ *  File Name       : linux/drivers/i2c/busses/i2c-mp200.h
+ *  Function        : i2c
+ *  Release Version : Ver 1.26
+ *  Release Date    : 2009/11/06
+ *
+ *  Copyright (C) NEC Electronics Corporation 2007,2008,2009
+ *
+ *  This program is free software;you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License as published by Free
+ *  Softwere Foundation; either version 2 of License, or (at your option) any
+ *  later version.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY;
+ *  without even the implied warrnty of MERCHANTABILITY or FITNESS FOR A
+ *  PARTICULAR PURPOSE.
+ *  See the GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program;
+ *  If not, write to the Free Software Foundation, Inc., 59 Temple Place -
+ *  Suite 330, Boston,
+ *  MA 02111-1307, USA.
+ *
+ */
+
+#ifndef __DRIVERS_I2C_BUSSES_I2C_MP200_H
+#define __DRIVERS_I2C_BUSSES_I2C_MP200_H
+
+/* INTC Reg Start */
+#define MP200_I2C_INTC_IT0_RAW	(IO_ADDRESS(MP200_INTC_BASE) + \
+	MP200_INTC_IT0_RAW1)
+#define MP200_I2C_INTC_IT0_IIR	(IO_ADDRESS(MP200_INTC_BASE) + \
+	MP200_INTC_IT0_IIR)
+
+/* INTC Reg End */
+#define MP200_I2C_INTC_MST	(1 << (33 - 32))
+#define MP200_I2C2_INTC_MST	(1 << (39 - 32))
+
+#define I2C_ADDR		IO_ADDRESS(MP200_IIC_BASE)
+#define I2C2_ADDR		IO_ADDRESS(MP200_IIC2_BASE)
+
+#define I2C_OFS_IIC0		0x00	/* IIC0 shift */
+#define I2C_OFS_IICC0		0x08	/* IIC0 control */
+#define I2C_OFS_SVA0		0x0c	/* slave address */
+#define I2C_OFS_IICCL0		0x10	/* IIC0 clock select */
+#define I2C_OFS_IICSE0		0x1c	/* For emulation */
+#define I2C_OFS_IICF0		0x28	/* IIC flag */
+
+
+/* I2C IICC0 Masks (Even address) */
+#define I2C_BIT_IICE0		0x0080
+#define I2C_BIT_LREL0		0x0040
+#define I2C_BIT_WREL0		0x0020
+#define I2C_BIT_SPIE0		0x0010
+#define I2C_BIT_WTIM0		0x0008
+#define I2C_BIT_ACKE0		0x0004
+#define I2C_BIT_STT0		0x0002
+#define I2C_BIT_SPT0		0x0001
+
+/* I2C IICCL0 Masks (Even address) */
+#define I2C_BIT_CLD0		0x0020
+#define I2C_BIT_DAD0		0x0010
+#define I2C_BIT_SMC0		0x0008
+#define I2C_BIT_DFC0		0x0004
+#define I2C_BIT_CLO1		0x0002
+#define I2C_BIT_CLO0		0x0001
+
+/* I2C IICSE0 Masks (Odd address) */
+#define I2C_BIT_MSTS0		0x8000
+#define I2C_BIT_ALD0		0x4000
+#define I2C_BIT_EXC0		0x2000
+#define I2C_BIT_COI0		0x1000
+#define I2C_BIT_TRC0		0x0800
+#define I2C_BIT_ACKD0		0x0400
+#define I2C_BIT_STD0		0x0200
+#define I2C_BIT_SPD0		0x0100
+
+/* I2C IICF0 Masks (Even address) */
+#define I2C_BIT_STCF		0x0080
+#define I2C_BIT_IICBSY		0x0040
+#define I2C_BIT_STCEN		0x0002
+#define I2C_BIT_IICRSV		0x0001
+
+/* For setting of sending and receiving */
+#define I2C_DIR_SHIFT		1
+#define I2C_DIR_R		0x01
+#define I2C_DIR_W		0x00
+
+struct i2c_ctrl {
+	unsigned char smc;	/* mode */
+	unsigned char dfc;	/* digital filter */
+};
+#define i2c_ctrl_t	struct i2c_ctrl
+
+/* mode */
+#define I2C_SMC_NORMAL_SPEED	0	/* nomal mode(maximum transfer rate
+					   70kbit/s)(default) */
+#define I2C_SMC_HIGH_SPEED	1	/* high-speed mode(maximum transfer
+					   rate 250kbit/s) */
+
+/* digital filter */
+#define I2C_DFC_OFF		0	/* digital filter OFF (default) */
+#define I2C_DFC_ON		1	/* digital filter ON */
+
+/* mp200 wait */
+#define MP200_I2C_WAIT		1	/* wait 1us after STT0 */
+
+/* IIC_SCLK ( HIGHSPEED : 4.19MHz-8.38MHz */
+#define I2C_DIVIIC_VAL1 0x00000072	/* (229.376MHz or 237.568MHz)/32/24 */
+#define I2C_DIVIIC_VAL2 0x00720000	/* (229.376MHz or 237.568MHz)/32/24 */
+
+
+#define MP200_I2C_CH1	0
+#define MP200_I2C_CH2	1
+
+
+#ifdef CONFIG_I2C_MP200_ENABLE_CH2
+#define I2C_NR	2
+#else
+#define I2C_NR	1
+#endif
+
+
+#endif				/* __DRIVERS_I2C_BUSSES_I2C_MP200_H */
diff --git a/include/linux/i2c-id.h b/include/linux/i2c-id.h
index 3ae0f76..d817d66 100644
--- a/include/linux/i2c-id.h
+++ b/include/linux/i2c-id.h
@@ -119,9 +119,11 @@
 #define I2C_HW_B_SAVAGE		0x01001d /* savage framebuffer driver */
 #define I2C_HW_B_RADEON		0x01001e /* radeon framebuffer driver */
 #define I2C_HW_B_EM28XX		0x01001f /* em28xx video capture cards */
-#define I2C_HW_B_CX2341X	0x010020 /* Conexant CX2341X MPEG encoder cards */
+#define I2C_HW_B_CX2341X	0x010020 /* Conexant CX2341X MPEG encoder
+					    cards */
 #define I2C_HW_B_INTELFB	0x010021 /* intel framebuffer driver */
-#define I2C_HW_B_CX23885	0x010022 /* conexant 23885 based tv cards (bus1) */
+#define I2C_HW_B_CX23885	0x010022 /* conexant 23885 based tv cards
+					    (bus1) */
 #define I2C_HW_B_AU0828		0x010023 /* auvitek au0828 usb bridge */
 
 /* --- PCF 8584 based algorithms					*/
@@ -176,4 +178,7 @@
 #define I2C_HW_SAA7146		0x060000 /* SAA7146 video decoder bus */
 #define I2C_HW_SAA7134		0x090000 /* SAA7134 video decoder bus */
 
+/* --- MP200 i2c adapter */
+#define I2C_HW_MP200		0x200000
+
 #endif /* LINUX_I2C_ID_H */
-- 
1.6.5.2

