From c3be85ab63e2a2efc39d394664bd6fdf52fbaa07 Mon Sep 17 00:00:00 2001
From: Kazuya Tsukamoto <kazuya.tsukamoto@necel.com>
Date: Mon, 9 Nov 2009 12:03:17 +0900
Subject: [PATCH 11/29] nec_em1: add interdsp driver

This is a driver with communicates with DSP.

Other than DSP communication, driver perform DSP power ON/OFF
and PCM0/1,DVC,Timer3  start/stop.
Note: DSP firmware is necessary for some interdsp ioctl.
(INTERDSP_READ, INTERDSP_WRITE etc...)

Signed-off-by: Kazuya Tsukamoto <kazuya.tsukamoto@necel.com>
---
 arch/arm/mach-mp200/include/mach/inter_dsp_ioctl.h |  306 +
 arch/arm/mach-mp200/inter_dsp.c                    | 6573 ++++++++++++++++++++
 arch/arm/mach-mp200/inter_dsp.h                    |  271 +
 3 files changed, 7150 insertions(+), 0 deletions(-)
 create mode 100644 arch/arm/mach-mp200/include/mach/inter_dsp_ioctl.h
 create mode 100644 arch/arm/mach-mp200/inter_dsp.c
 create mode 100644 arch/arm/mach-mp200/inter_dsp.h

diff --git a/arch/arm/mach-mp200/include/mach/inter_dsp_ioctl.h b/arch/arm/mach-mp200/include/mach/inter_dsp_ioctl.h
new file mode 100644
index 0000000..9cd4203
--- /dev/null
+++ b/arch/arm/mach-mp200/include/mach/inter_dsp_ioctl.h
@@ -0,0 +1,306 @@
+/* -*- mode: c; c-basic-offset: 8; comment-column: 32; -*- */
+
+/*
+ * InterDSP Driver
+ *
+ * Copyright (C) NEC Electronics Corporation 2004-2009
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ */
+
+#ifndef INTER_DSP_IOCTL_H
+#define INTER_DSP_IOCTL_H
+
+#ifdef __KERNEL__
+#include <linux/types.h>
+#include <linux/ioctl.h>
+#else
+#include <inttypes.h>
+#include <sys/types.h>
+#include <sys/ioctl.h>
+#endif
+
+/*
+ * IOCTL struct
+ */
+
+struct interdsp_chinfo {
+	uint32_t header_offset;
+	uint32_t buffer_offset;
+	uint32_t buffer_blknum;
+	uint32_t buffer_blksize;
+};
+
+/* INTERDSP_READ/INTERDSP_WRITE */
+
+/* struct dsp_cmd_rw flags */
+#define INTERDSP_WRITEBUF_OK	0x0001
+#define INTERDSP_SENDHDR_OK	0x0002
+
+struct dsp_cmd_rw {
+	uint32_t fdata[2];
+	uint8_t *bdata;
+	size_t bsize;
+	size_t offset;
+	int intq_num;
+	uint32_t flags;
+};
+
+/* ch info */
+struct dsp_cmd_ch {
+	uint32_t dsparm;
+	uint32_t chnum;
+	struct interdsp_chinfo chinfo;
+};
+
+/* TaskID Channel */
+struct dsp_cmd_task_ch {
+	uint32_t taskid;
+	int32_t chnum;
+};
+
+/* Interval Get/Set */
+struct dsp_cmd_ch_interval {
+	int32_t chnum;
+	int32_t intq_num;
+	int32_t interval;
+	int32_t repeat;
+	int32_t missfire;
+};
+
+struct dsp_cmd_ch_status_v0 {
+	uint32_t armchmask;	/* Ch. No. Mask (1<<0,1<<1,1<<2) */
+	uint32_t dspchmask;	/* Ch. No. Mask (1<<0,1<<1,1<<2) */
+};
+
+/* Channel Status 2 */
+struct dsp_cmd_ch_status {
+	uint32_t armchmask;	/* Ch. No. Mask (1<<0,1<<1,1<<2) */
+	uint32_t dspchmask;	/* Ch. No. Mask (1<<0,1<<1,1<<2) */
+
+	unsigned long armch_blockbitmap[3];
+};
+
+
+/*
+ * Program DownLoad
+ */
+/* control flags */
+#define INTERDSP_DL_PROG	0x01
+				     /* 0x02 unused (INTERDSP_DL_POWER) */
+#define INTERDSP_DL_RESET	0x04
+#define INTERDSP_DL_CLOCK	0x08
+#define INTERDSP_DL_CLKCTRL	0x10
+
+/*
+ * Download `offset' examples
+ *
+ *   memtype  target-addr     offset
+ *   0        0xb0001234  =>  0x00001234    [target - 0xb0000000]
+ *   1        0xb0108000  =>  0x00008000    [target - 0xb0100000]
+ *   2        0xa0000100  =>  0x00000100    [target - 0xa0000000]
+ *   3        0x33a04000  =>  0x03a04000    [target - 0x30000000]
+ */
+
+/* DSP Control */
+struct dsp_cmd_download {
+	uint32_t control;	/* control flags */
+
+	/* INTERDSP_DL_PROG */
+	void *data;		/* Program/Data Address */
+	uint32_t memtype;	/* 0:InstSRAM  1:DataSRAM  2:ExtSRAM 3:SDRAM */
+	uint32_t offset;	/* Write Offset in SRAM/SDRAM */
+	uint32_t size;		/* Copy Size */
+
+	/* INTERDSP_DL_RESET */
+	uint32_t reset;		/* 0:clear 1:set 2:(first set, last clear) */
+
+	uint32_t power;		/* unused (backward compatibility) */
+
+	/* INTERDSP_DL_CLOCK */
+	uint32_t clock;		/* 1:start, 0:stop */
+
+	/* INTERDSP_DL_CLKCTRL */
+	uint32_t clkctrl;	/* 1:on, 0:off (auto clock control) */
+};
+
+/*
+ * Errot Bit Number (INTERDSP_GET_ERROR)
+ */
+
+#define INTERDSP_ERROR_ARMCH_ACK_TIMEOUT(CH)	(CH)
+
+#define INTERDSP_ERROR_WRAPPER_NR		8
+
+/*
+ * DCV
+ */
+
+struct dcv_reg {
+	uint16_t bank_no;
+	union {
+		struct {
+			unsigned bank_offset:12; /* DCV_BANKn_OFFSET */
+			unsigned bank_set:4; /* DCV_BANKn_SET */
+		} bank_reg;
+		uint16_t bank_addr;
+	} bank_val;
+};
+
+struct dsp_cmd_dcv_set {
+	unsigned int count;	/* set/get number */
+	struct dcv_reg *dcv_regs; /* pointer to `struct dcv_reg' */
+};
+
+/* ADD-S 20070521 [DSP DIVPMxSCLK] */
+/*
+ * SMU_DIVPMxSCLK
+ */
+
+/* reg_num */
+#define DSPDEV_DIVPM0SCLK	(0)
+#define DSPDEV_DIVPM1SCLK	(1)
+
+/* reg_val macros */
+#define DSPDEV_DIVPMxSCLK_MLD_NFSIN(N)	(((N)&0xfU)<<12)
+#define DSPDEV_DIVPMxSCLK_SEL_PLL2	(0U<<8)
+#define DSPDEV_DIVPMxSCLK_SEL_PLL3	(1U<<8)
+#define DSPDEV_DIVPMxSCLK_SEL_PLLB	(2U<<8)
+#define DSPDEV_DIVPMxSCLK_SEL_PLL26MHz	(3U<<8)
+#define DSPDEV_DIVPMxSCLK_SEL_MLD_NFSIN	(4U<<8)
+#define DSPDEV_DIVPMxSCLK_DIV1(N)	(((N)&0xfU)<<4)
+#define DSPDEV_DIVPMxSCLK_DIV0(N)	(((N)&0x7U)<<0)
+
+struct dsp_cmd_divpmxsclk {
+	unsigned int reg_num;	/* one of DSPDEV_DIVPM[01]SCLK */
+	unsigned int reg_val;	/* DIVPM[01]SCLK values */
+};
+/* ADD-E 20070521 [DSP DIVPMxSCLK] */
+
+/*
+ *	ioctl command
+ */
+
+#define INTERDSP_READ			_IOR('D', 0x01, struct dsp_cmd_rw)
+#define INTERDSP_WRITE			_IOW('D', 0x02, struct dsp_cmd_rw)
+
+#define INTERDSP_WRITEBUF		_IOWR('D', 0x08, struct dsp_cmd_rw)
+#define INTERDSP_SENDHDR		_IOWR('D', 0x09, struct dsp_cmd_rw)
+
+#define INTERDSP_GET_CHINFO	_IOR('D', 0x10, struct dsp_cmd_ch)
+#define INTERDSP_SET_CHINFO	_IOW('D', 0x11, struct dsp_cmd_ch)
+#define INTERDSP_GET_TASKCH	_IOR('D', 0x12, struct dsp_cmd_task_ch)
+#define INTERDSP_SET_TASKCH	_IOWR('D', 0x13, struct dsp_cmd_task_ch)
+#define INTERDSP_SHMEM_INIT	_IO('D', 0x18)
+
+#define INTERDSP_CHECKCH	_IOWR('D', 0x22, struct dsp_cmd_ch_status)
+#define INTERDSP_WAITCH		_IOWR('D', 0x23, struct dsp_cmd_ch_status)
+
+#define INTERDSP_DOWNLOAD	_IOWR('D', 0x30, struct dsp_cmd_download)
+
+#define INTERDSP_GET_ERROR	_IOR('D', 0x40, unsigned long)
+
+#define INTERDSP_SET_DCV_REGS	_IOW('D', 0x50, struct dsp_cmd_dcv_set)
+#define INTERDSP_GET_DCV_REGS	_IOW('D', 0x51, struct dsp_cmd_dcv_set)
+
+
+/* Start/Stop Peripherals */
+#define DSPDEV_START_PERIPHERALS	_IOW('P', 1, unsigned)
+#define DSPDEV_STOP_PERIPHERALS		_IOW('P', 2, unsigned)
+
+#define DSPDEV_PERIP_PM0		(1U<<0)
+#define DSPDEV_PERIP_PM1		(1U<<1)
+#define DSPDEV_PERIP_TI3		(1U<<4)
+#define DSPDEV_PERIP_DCV		(1U<<8)
+
+#define DSPDEV_PERIP_PM0_STOP_SCLK	(1U<<16)
+#define DSPDEV_PERIP_PM1_STOP_SCLK	(1U<<17)
+
+
+/* Set Timer clock */
+#define DSPDEV_TIN_SEL			_IO('P', 3)
+
+#define DSPDEV_TIN_TI3_BIT		(1U<<8)
+#define DSPDEV_TIN_TI3_VAL		(1U<<0)
+#define DSPDEV_TIN_TI3_0		DSPDEV_TIN_TI3_BIT
+#define DSPDEV_TIN_TI3_1		(DSPDEV_TIN_TI3_BIT|DSPDEV_TIN_TI3_VAL)
+
+
+/* Set DMA INT_SEL DSP */
+#define DSPDEV_DMA_INT_SEL		_IO('P', 7)
+
+#define DSPDEV_DMA_INT_SEL_PCH_SHIFT	16
+#define DSPDEV_DMA_INT_SEL_M2M		(1U << DSPDEV_DMA_INT_SEL_PCH_SHIFT)
+#define DSPDEV_DMA_INT_SEL_P2M		(2U << DSPDEV_DMA_INT_SEL_PCH_SHIFT)
+#define DSPDEV_DMA_INT_SEL_M2P		(3U << DSPDEV_DMA_INT_SEL_PCH_SHIFT)
+#define DSPDEV_DMA_INT_SEL_PCH_MASK	(3U << DSPDEV_DMA_INT_SEL_PCH_SHIFT)
+
+#define DSPDEV_DMA_INT_SEL_LCH0		(1U<<0)
+#define DSPDEV_DMA_INT_SEL_LCH1		(1U<<1)
+#define DSPDEV_DMA_INT_SEL_LCH2		(1U<<2)
+#define DSPDEV_DMA_INT_SEL_LCH3		(1U<<3)
+#define DSPDEV_DMA_INT_SEL_LCH4		(1U<<4)
+#define DSPDEV_DMA_INT_SEL_LCH5		(1U<<5)
+#define DSPDEV_DMA_INT_SEL_LCH6		(1U<<6)
+#define DSPDEV_DMA_INT_SEL_LCH7		(1U<<7)
+#define DSPDEV_DMA_INT_SEL_LCH8		(1U<<8)
+#define DSPDEV_DMA_INT_SEL_LCH9		(1U<<9)
+#define DSPDEV_DMA_INT_SEL_LCH10	(1U<<10)
+#define DSPDEV_DMA_INT_SEL_LCH11	(1U<<11)
+#define DSPDEV_DMA_INT_SEL_LCH12	(1U<<12)
+#define DSPDEV_DMA_INT_SEL_LCH13	(1U<<13)
+#define DSPDEV_DMA_INT_SEL_LCH14	(1U<<14)
+#define DSPDEV_DMA_INT_SEL_LCH_MASK	0x7fff
+
+
+
+/* Set DMA INT_SEL CPU */
+#define CPUDEV_DMA_INT_SEL		_IO('P', 8)
+
+#define CPUDEV_DMA_INT_SEL_PCH_SHIFT	16
+#define CPUDEV_DMA_INT_SEL_M2M		(1U << CPUDEV_DMA_INT_SEL_PCH_SHIFT)
+#define CPUDEV_DMA_INT_SEL_P2M		(2U << CPUDEV_DMA_INT_SEL_PCH_SHIFT)
+#define CPUDEV_DMA_INT_SEL_M2P		(3U << CPUDEV_DMA_INT_SEL_PCH_SHIFT)
+#define CPUDEV_DMA_INT_SEL_PCH_MASK	(3U << CPUDEV_DMA_INT_SEL_PCH_SHIFT)
+
+#define CPUDEV_DMA_INT_SEL_LCH0		(1U<<0)
+#define CPUDEV_DMA_INT_SEL_LCH1		(1U<<1)
+#define CPUDEV_DMA_INT_SEL_LCH2		(1U<<2)
+#define CPUDEV_DMA_INT_SEL_LCH3		(1U<<3)
+#define CPUDEV_DMA_INT_SEL_LCH4		(1U<<4)
+#define CPUDEV_DMA_INT_SEL_LCH5		(1U<<5)
+#define CPUDEV_DMA_INT_SEL_LCH6		(1U<<6)
+#define CPUDEV_DMA_INT_SEL_LCH7		(1U<<7)
+#define CPUDEV_DMA_INT_SEL_LCH8		(1U<<8)
+#define CPUDEV_DMA_INT_SEL_LCH9		(1U<<9)
+#define CPUDEV_DMA_INT_SEL_LCH10	(1U<<10)
+#define CPUDEV_DMA_INT_SEL_LCH11	(1U<<11)
+#define CPUDEV_DMA_INT_SEL_LCH12	(1U<<12)
+#define CPUDEV_DMA_INT_SEL_LCH13	(1U<<13)
+#define CPUDEV_DMA_INT_SEL_LCH14	(1U<<14)
+#define CPUDEV_DMA_INT_SEL_LCH_MASK	0x7fff
+
+
+/* ADD-S 20070521 [DSP DIVPMxSCLK] */
+/* SMU_DIVPMxSCLK accessor */
+#define DSPDEV_SET_DIVPMxSCLK		_IOW('P', 9, struct dsp_cmd_divpmxsclk)
+/* ADD-E 20070521 [DSP DIVPMxSCLK] */
+
+
+#define DSPDEV_SRAMCTRL	_IOW('P', 10, unsigned)
+
+
+#endif /* INTER_DSP_IOCTL_H */
diff --git a/arch/arm/mach-mp200/inter_dsp.c b/arch/arm/mach-mp200/inter_dsp.c
new file mode 100644
index 0000000..499e0f3
--- /dev/null
+++ b/arch/arm/mach-mp200/inter_dsp.c
@@ -0,0 +1,6573 @@
+/* -*- mode: c; c-basic-offset: 8; comment-column: 32; -*- */
+
+/*
+ * linux/arch/arm/mach-mp200/interdsp.c
+ */
+
+/*
+ * InterDSP Driver
+ *
+ * Copyright (C) NEC Electronics Corporation 2009
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/poll.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/fs.h>
+#include <linux/stringify.h>
+#include <linux/version.h>
+#include <linux/device.h>
+#include <linux/proc_fs.h>
+#include <linux/cdev.h>
+#include <linux/dma-mapping.h>
+#include <linux/io.h>
+#include <linux/uaccess.h>
+#include <asm/cacheflush.h>
+
+#include <mach/hardware.h>
+#include <mach/dma.h>
+#include <mach/pmu.h>
+#include <mach/smu.h>
+#include <mach/em1_mem.h>
+#include <mach/inter_dsp_ioctl.h>
+
+#include "inter_dsp.h"
+
+/*#define MP200_DSP_DEBUG 1*/
+
+#undef FORCE_INIT
+#define FORCE_INIT	1
+#define DSP_MINOR_MAX	32
+#undef USE_DCV
+#define USE_DCV	1
+
+#define INTERDSP_DRIVER_VERSION	"0.13 (2006/03/23)"
+#ifndef USE_DCV
+#define USE_DCV		1	/* DCV Support auto enable */
+#endif /* USE_DCV */
+
+#ifndef FORCE_INIT
+#define FORCE_INIT	0	/* disable */
+#endif
+
+#ifndef FORCE_DMA_DOWNLOAD
+#define FORCE_DMA_DOWNLOAD	0	/* disable */
+#endif
+
+#define USE_DIRECT_SMU_ACCESS	0	/* enable */
+
+#ifndef PMx_STOP_SELECTABLE
+#define PMx_STOP_SELECTABLE	0 /* PMx Stop SCLK (when stop PMx) */
+#endif
+
+#define mp200_pe_number	0
+#define INTERDSP_DRIVER_USE	driver_use_count
+#define INTERDSP_DRIVER_OPEN	do { driver_use_count = 1; } while (0)
+#define INTERDSP_DRIVER_CLOSE	do { driver_use_count = 0; } while (0)
+
+/* #define USE_DSP_ICE	0 */
+#define USE_DSP_ICE	1
+
+#ifndef WAIT_DSP_PWR_STATUS
+#define WAIT_DSP_PWR_STATUS		100 /* 100us, (nothing if 0) */
+#endif
+
+#ifndef DEFAULT_DSP_PWR_WAIT_PARM
+#define DEFAULT_DSP_PWR_WAIT_PARM	0xAU
+#endif
+
+/*********************************************************************
+ * debug macro
+ *********************************************************************/
+
+#define DPRINT_PREFIX
+#define DEBUG_PRINT(FMT, ARGS...) \
+do {\
+	char const *x___fn = __func__;\
+	printk(KERN_INFO DPRINT_PREFIX "%s:%d: " FMT, \
+		x___fn, __LINE__, ##ARGS); \
+} while (0)
+
+#define TRACE_PRINT(FMT, ARGS...) \
+do {\
+	printk(KERN_INFO "interdsp: " FMT, ##ARGS);\
+} while (0)
+
+#ifdef MP200_DSP_DEBUG
+#define DBG_INLINE
+#define DPRINT	DEBUG_PRINT
+#define DBG_MEMSET(S, C, N)	({ \
+	void *xxx__s = (S); \
+	int xxx__c = (C); \
+	size_t xxx__n = (N); \
+	DPRINT("memset(0x%08lx, %d, %u)\n", \
+	       (unsigned long)xxx__s, xxx__c, xxx__n); \
+	memset(xxx__s, xxx__c, xxx__n); \
+})
+#define DBG_MEMCPY(D, S, N)	({ \
+	void *xxx__d = (D); \
+	void const *xxx__s = (S); \
+	size_t xxx__n = (N); \
+	DPRINT("memcpy(0x%08lx, 0x%08lx, %u)\n", \
+	       (unsigned long)xxx__d, (unsigned long)xxx__s, xxx__n); \
+	memcpy(xxx__d, xxx__s, xxx__n); \
+})
+#define SQNUM(sq)	((sq) ? (sq) - arm_send_entry : -1)
+#else
+#define DBG_INLINE	inline
+#define DPRINT(fmt, args...)
+#define DBG_MEMSET	memset
+#define DBG_MEMCPY	memcpy
+#endif
+
+/***********************************************************************
+ * ARM-DSP communication driver configuration macro
+ **********************************************************************/
+
+#ifndef INTERDSP_ACK_TIMEOUT
+#define INTERDSP_ACK_TIMEOUT	1000	/* 1 sec */
+#endif
+
+/* shard memory address */
+#ifndef SHARED_MEM_ADDRESS
+#define SHARED_MEM_ADDRESS 0x33f00000	/* (shard buffer address */
+#endif
+
+/* shard memory size */
+#ifndef SHARED_MEM_SIZE
+/* #define SHARED_MEM_SIZE 0x00400000 *//* 4Mbyte */
+/* #define SHARED_MEM_SIZE 0x00200000 *//* 2Mbyte */
+/* #define SHARED_MEM_SIZE 0x00100000 *//* 1Mbyte */
+#define SHARED_MEM_SIZE 0x00080000	/* 512Kbyte */
+/* #define SHARED_MEM_SIZE 0x00040000 *//* 256Kbyte */
+/* #define SHARED_MEM_SIZE 0x00020000 *//* 128Kbyte */
+/* #define SHARED_MEM_SIZE 0x00010000 *//* 64Kbyte */
+#endif
+
+/*  send queue length */
+#ifndef INTERDSP_SQ_LEN
+#define INTERDSP_SQ_LEN	8	/* Send Queue  length */
+#endif /* INTERDSP_SQ_LEN */
+
+/* PE address offset */
+#ifndef INTERDSP_PE_INDEX_OFFSET
+#define INTERDSP_PE_INDEX_OFFSET	(0x100)	/* 256byte */
+#endif /* INTERDSP_PE_INDEX_OFFSET */
+
+/* shard memory buffer block area offset */
+#ifndef INTERDSP_BLOCK_OFFSET
+#define INTERDSP_BLOCK_OFFSET		(INTERDSP_PE_INDEX_OFFSET<<4) /* 4K */
+#endif /* INTERDSP_BLOCK_OFFSET */
+
+/* download DMA  buffer size */
+#ifndef INTERDSP_DMA_SIZE
+#define INTERDSP_DMA_SIZE	(PAGE_SIZE*4)
+#endif /* INTERDSP_DMA_SIZE */
+
+/*  character device */
+#define DSPDEV_NAME	"InterDSP"
+#ifndef DSPDEV_MAJOR
+#define DSPDEV_MAJOR	101	/* XXX */
+#endif /* DSPDEV_MAJOR */
+#define NEED_SHMEM_INIT(X)	(force_init != 0)
+
+#define DSPDEV_ARMCH0_MINOR	0
+#define DSPDEV_ARMCH1_MINOR	1
+#define DSPDEV_ARMCH2_MINOR	2
+#define DSPDEV_DSPCH0_MINOR	4
+#define DSPDEV_DSPCH1_MINOR	5
+#define DSPDEV_DSPCH2_MINOR	6
+#define DSPDEV_CONTROL_MINOR	8
+
+/* response/request entry number */
+#ifndef RESREQ_PEND_SIZE
+#define RESREQ_PEND_SIZE	32
+#endif
+
+/* minor device */
+#ifndef INTERDSP_MINOR_SIZE
+#define INTERDSP_MINOR_SIZE	32
+#endif
+
+/***********************************************************************
+ * peripheral register address
+ **********************************************************************/
+
+/* INTC  register address */
+#define MP200_VA_INTC	IO_ADDRESS(MP200_INTC_BASE)
+#define IT3_IPI0_MON	(MP200_VA_INTC + MP200_INTC_ID_IPI0_MON)
+#define IT3_IPI0_CLR	(MP200_VA_INTC + MP200_INTC_ID_IPI0_CLR)
+#define IT0_IPI3_SET	(MP200_VA_INTC + MP200_INTC_IT0_IPID_SET)
+#define IT3_IDS0		(MP200_VA_INTC + MP200_INTC_ID_IDS0)
+#define IT3_IDS1		(MP200_VA_INTC + MP200_INTC_ID_IDS1)
+#define IT3_IDS2		(MP200_VA_INTC + MP200_INTC_ID_IDS2)
+#define IT0_IPI3_CLR	(MP200_VA_INTC + MP200_INTC_IT0_IPID_CLR)
+#define IT3_IIR			(MP200_VA_INTC + MP200_INTC_ID_IIR)
+#define IT3_CLR			(MP200_VA_INTC + MP200_INTC_ID_CLR)
+
+
+/* SMU  register address */
+#define RESETCTRL0		SMU_RESETCTRL0
+#define RESETREQ0		SMU_RESETREQ0
+#define RESETREQ0ENA		SMU_RESETREQ0ENA
+
+/* SMU_AUTO_FRQ_MASK0 DSP bit */
+#define DSP_REQ_MASK		(1U<<1)
+
+/* SMU_POWERSW_STATUS bits */
+#define ADSP_SWCNT_STATUS	(1U<<1)
+
+/* SMU_POWERSW_ENA */
+#define ADSP_POWERSW_ENA	(1U<<2)
+
+/* SMU_POWERSW_ACTRL_EN bits */
+#define ADSPSW_ACTRL_EN		(1U<<0)
+#define DSP_PWR_CNT_EN		(1U<<2)
+
+/* SMU_ADSPSW_ACTRL bits */
+#define ADSPSW_ACTRL		(1U<<0)
+#define DSP_PWR_WAIT_PARAM_SHIFT	8
+#define DSP_PWR_WAIT_PARAM_MASK	(0x003fff00U)
+
+/* SMU DSP reset bit */
+/* SMU_RESETREQ0 */
+#define DSP_IRES_CLR		(1U<<0)
+#define DSP_IRES_SET		(0)
+#define DSP_ARES_CLR		(1U<<3)
+#define DSP_ARES_SET		(0)
+#define DSP_ARES_ENA		DSP_ARES_CLR
+#define DSP_SRES_CLR		(1U<<4)
+#define DSP_SRES_SET		(0)
+#define DSP_SRES_ENA		DSP_SRES_CLR
+#define DCV_RST				(1U<<5)
+#define DCV_RST_ENA			DCV_RST
+
+/* SMU_AHBCLKCTRL0 DSPLP  bit */
+#define DSPLP			(1U<<1)
+
+/* SMU_GCLKCTRL0 DSP bit */
+#define DSP_CLK_GCK			(1U<<0)
+#define DSP_CLKENA_GCK		(1U<<25)
+#define DSP_CLK_MASK		DSP_CLK_GCK
+#define DSP_CLKENA_MASK		DSP_CLKENA_GCK
+#define DSP_CLK_GCK_SET		DSP_CLK_MASK
+#define DSP_CLKENA_GCK_SET	DSP_CLKENA_GCK
+#define DSP_CLK_GCK_CLR		(0)
+#define DSP_CLKENA_GCK_CLR	(0)
+
+/* SMU_GCLKCTRL0ENA DSP bit */
+#define DSP_CLK_GCK_ENA		(1U<<0)
+#define DSP_CLKENA_GCK_ENA	(1U<<25)
+#define DSP_CLK_MASK_ENA	DSP_CLK_GCK_ENA
+#define DSP_CLKENA_MASK_ENA	DSP_CLKENA_GCK_ENA
+
+/* SMU_AUTO_FRQ_CHANGE DSP bit */
+#define DSP_REQ_MASK		(1U<<1)
+
+/* SMU_AHBCLKCTRL1 SRCLP  bit */
+#define SRCLP			(1U<<5)
+
+#if USE_DCV
+/* DCV Support */
+#ifndef MP200_DCV_BASE
+
+#define MP200_DCV_BASE	0x400f0000U
+
+#define DCV_NEED_MAP	1
+#define MP200_VA_DCV	0
+#else	/* MP200_DCV_BASE */
+/*#define DCV_NEED_MAP  0*/
+/*#define DCV_NEED_MAP	1*//* by m-uno at 2005/11/2 */
+#define DCV_NEED_MAP	0
+#define MP200_VA_DCV	IO_ADDRESS(MP200_DCV_BASE)
+#endif /* MP200_DCV_BASE */
+
+#define DCV_BANKn_OFFSET(V, N)	((unsigned long)(V)+((N)<<2))
+#define DCV_BANKn_SET(V, N)	((unsigned long)(V)+0x40+((N)<<2))
+
+#ifndef DCV_TEST_MODE
+#define DCV_TEST_MODE	0
+#endif /* DCV_TEST_MODE */
+
+#ifndef DCV_PROC_FS
+#define DCV_PROC_FS	0
+#endif /* DCV_PROC_FS */
+#endif /* USE_DCV */
+
+/* Timer3 timer register */
+#define TIMER_TI3_SET	(IO_ADDRESS(MP200_TIMER3_BASE) + 0x0008)
+
+/***********************************************************************
+ *  driver macro,structure/union declaration
+ **********************************************************************/
+
+#define PE_NUM	3
+
+#define CH_NUM		INTERDSP_CH_NUM
+#define BUF_BLOCK_MAX	8
+
+#define CH_INVALID	INTERDSP_CH_INVALID
+
+#define TASKID2INDEX(ID)	((unsigned)(ID))
+#undef MASTER_TASKID
+
+#define SEND_INT(CH)	(1<<(CH))
+#define ACK_INT(CH)	(1<<((CH)+CH_NUM))
+#define CH_INT_BITSHIFT	1
+
+#define ELEMENT_SIZE(X)	(sizeof(X) / sizeof(X)[0])
+
+/*  send queue entry */
+struct arm_queue_ent {
+	struct list_head list;
+	union interdsp_spa_header header;
+	int ch;
+	int num;
+	void *buf;
+	struct semaphore *blocksem;
+	int nolock;
+	int locked;
+	atomic_t ack;
+	atomic_t discard;
+	atomic_t active;
+	atomic_t sync;
+	atomic_t valid;
+	atomic_t timeout;
+	struct timer_list timeout_timer;
+	wait_queue_head_t ack_waitq;
+	void (*ack_callback) (int ch,
+			      union interdsp_spa_header, int, unsigned long);
+	unsigned long cb_data;
+};
+
+/*  header buffer area [ARM=0, DSP=1] */
+typedef union interdsp_spa_header hdr_queue_area[2][CH_NUM];
+
+/* shard memory PE information area */
+struct dsp_peinfo {
+	struct interdsp_chinfo arm_chinfo[CH_NUM];
+	struct interdsp_chinfo dsp_chinfo[CH_NUM];
+	uint32_t task_chtbl[0];	/* zero length array */
+	/* ... */
+	/* hdr_queue queue; */
+};
+
+/* itnerdsp_chinfo calculating macro */
+#define BLOCK_BYTES(CHINFO) \
+	((CHINFO)->buffer_blksize * sizeof(uint32_t))
+#define CHINFO_BLOCK_BYTES(CHINFO) \
+	(BLOCK_BYTES(CHINFO) * (CHINFO)->buffer_blknum)
+#define CHINFO_BLOCK_ADDR(CHINFO) \
+	BUFADDR(shared_base, (CHINFO)->buffer_offset)
+
+/* task_chtbl[] max index */
+#define TASK_INFO_MAX	\
+	((INTERDSP_PE_INDEX_OFFSET \
+	- (size_t)(((struct dsp_peinfo *)0)->task_chtbl) \
+	- sizeof(hdr_queue_area)) \
+	/ sizeof((struct dsp_peinfo *)0)->task_chtbl[0])
+
+/* make `struct dsp_peinfo' pointer for PE#N, N=0,1,2 */
+#define PEINFO_ADDR(PENUM)	\
+	((struct dsp_peinfo *)(((char *)shared_base) \
+			 + INTERDSP_PE_INDEX_OFFSET*(PENUM)))
+
+/* PE header area */
+#define PE_HEADER_AREA(PENUM)	\
+	((hdr_queue_area *)((char *)PEINFO_ADDR(PENUM) \
+		      + (INTERDSP_PE_INDEX_OFFSET - sizeof(hdr_queue_area))))
+
+/*  header area decision routine */
+#define PE_HEADER_AREA_RANGE(PENUM,ADDR) \
+	(((char *)PE_HEADER_AREA(PENUM)) <= (char *)(ADDR) \
+	&& (char *)(ADDR) < ((char *)PE_HEADER_AREA(PENUM) \
+			+ sizeof(hdr_queue_area)))
+
+/*  address<-> offset conversion macro */
+#define BUFADDR(BASE, OFFSET)	((void *)(((char *)(BASE)) + OFFSET))
+#define BUFOFF(BASE, ADDR)	((char *)(ADDR) - (char *)(BASE))
+
+/* shard memory address<-> offset conversion macro */
+#define SHARED_BUFADDR(OFFSET)	BUFADDR(shared_base, OFFSET)
+#define SHARED_BUFOFF(ADDR)	BUFOFF(shared_base, ADDR)
+
+/* shard memory driver control area */
+struct dsp_driver_manager {
+#define DRIVER_MAGIC	0xb5cc7a92	/* XXX */
+	uint32_t magic;		/* MAGIC */
+	uint32_t mutex;		/* lock */
+	uint32_t block_factor;
+	uint32_t nblocks;
+};
+
+/* shard memory driver control area address */
+#define DRIVER_MNG_ADDR	\
+((struct dsp_driver_manager *)((char *)shared_base \
+			       + INTERDSP_PE_INDEX_OFFSET*(PE_NUM)))
+
+/* Memory Allocation Table(MAT)  address */
+#define MAT_ADDR \
+((uint8_t *)((char *)shared_base \
+	     + INTERDSP_PE_INDEX_OFFSET * (PE_NUM + 1)))
+
+#define MAT_MIN_BFSHIFT	5	/* 2^5 = 32byte */
+#define MAT_MAX_BFSHIFT	16	/* 2^16 = 64Kbyte */
+
+/* MAT max value */
+#define MAT_MAX	\
+(INTERDSP_BLOCK_OFFSET - ((char *)MAT_ADDR - (char *)shared_base))
+
+/*  MAT to address conversion */
+#define MAT2ADDR(BLK) \
+((void *)((char *)shared_base + INTERDSP_BLOCK_OFFSET + (BLK) * block_factor))
+
+/* address to MAT  conversion */
+#define ADDR2MAT(ADDR) \
+(((char *)(ADDR) - (char *)shared_base - INTERDSP_BLOCK_OFFSET) / block_factor)
+
+/*  buffer block decision processing */
+#define BLOCK_BUFFER_RANGE(ADDR) \
+	((char *)MAT2ADDR(0) <= (char *)(ADDR) \
+	&& (char *)(ADDR) < (char *)MAT2ADDR(mat_blocks))
+
+/* Value of Memory Allocation Table */
+#define MAT_FREE	0x00U
+#define MAT_USED	0x01U
+#define MAT_RESERVED	0x02U
+#define MAT_INVALID	0xffU
+
+/*  channel data */
+struct dsp_ch_data {
+	int ind;		/* ARM:0 DSP:1 */
+	int ch;			/* channel */
+	int opend;		/* open indicate */
+};
+
+/* ioctl extension */
+struct ioctl_chain {
+	struct list_head list;
+	int (*ioctl) (struct inode *, struct file *,
+		      unsigned int, unsigned long, int *);
+};
+
+/* Res/Req snatch chain */
+struct req_chain {
+	struct list_head list;
+	int (*handler) (int, union interdsp_spa_header *, void *, size_t);
+};
+
+/* release inform chain */
+struct notify_chain {
+	struct list_head list;
+	void (*notify) (struct inode *, struct file *file);
+};
+
+struct interdsp_pending_resreq {
+	struct list_head list;
+	uint32_t fdata[2];	/*  header */
+	void *kdata;		/* kernel data area */
+	size_t len;		/* kdata  size */
+	void (*callback) (unsigned long cb_data);
+	unsigned long cb_data;
+};
+
+/* minor device table entry */
+struct minor_device_ent {
+	int minor;
+	int sticky;
+	struct file_operations *fops;
+	struct device *cls_dev;
+};
+
+
+#ifdef CONFIG_PM
+/* Suspend/Resume command format */
+#define SUSPEND_REQ_INFO	0x00000100
+#define SUSPEND_REQ_LEN		0x00000001
+#define SUSPEND_REQ_DATA	0x00001111
+#define SUSPEND_RES_INFO	0x00004100
+#define SUSPEND_RES_LEN		0x00000001
+#define SUSPEND_RES_DATA	0x00002222
+#define RESUME_RES_INFO		0x00008100
+#define RESUME_RES_LEN		0x00000001
+#define RESUME_RES_DATA		0x00004444
+#endif
+
+/***********************************************************************
+ *  static function prototype
+ **********************************************************************/
+static void clear_ackq_entry(void);
+#ifdef CONFIG_PM
+static int interdsp_suspend(struct platform_device *dev, pm_message_t state);
+static int interdsp_resume(struct platform_device *dev);
+#endif
+
+/***********************************************************************
+ *  driver data
+ **********************************************************************/
+
+/*  channel file discrimination */
+static struct dsp_ch_data any_ch_private = {
+	.ind = 1,
+	.ch = CH_INVALID,
+	.opend = 0,
+};
+
+static struct dsp_ch_data dsp_ch0_private = {
+	.ind = 1,
+	.ch = 0,
+	.opend = 0,
+};
+
+static struct dsp_ch_data dsp_ch1_private = {
+	.ind = 1,
+	.ch = 1,
+	.opend = 0,
+};
+
+static struct dsp_ch_data dsp_ch2_private = {
+	.ind = 1,
+	.ch = 2,
+	.opend = 0,
+};
+
+static struct dsp_ch_data arm_ch0_private = {
+	.ind = 0,
+	.ch = CH_INVALID,
+	.opend = 0,
+};
+
+static struct dsp_ch_data arm_ch1_private = {
+	.ind = 0,
+	.ch = CH_INVALID,
+	.opend = 0,
+};
+
+static struct dsp_ch_data arm_ch2_private = {
+	.ind = 1,
+	.ch = CH_INVALID,
+	.opend = 0,
+};
+
+static struct dsp_ch_data *dsp_ch_privates[] = {
+	&any_ch_private,
+	&dsp_ch0_private,
+	&dsp_ch1_private,
+	&dsp_ch2_private,
+	&arm_ch0_private,
+	&arm_ch1_private,
+	&arm_ch2_private,
+};
+
+/* fasync  method */
+static struct fasync_struct *interdsp_fasync_queue;
+static struct fasync_struct *dsp_ch_fasync_queue[CH_NUM] = { 0, };
+
+/* shard memory top */
+static unsigned long shared_mem_address = SHARED_MEM_ADDRESS;
+static unsigned long shared_mem_size = SHARED_MEM_SIZE;
+static struct dsp_peinfo *shared_base;
+
+/* PE  information address cash */
+static struct dsp_peinfo *my_peinfo;
+static union {
+	struct dsp_peinfo peinfo;
+	char unused[INTERDSP_PE_INDEX_OFFSET];
+} cache_info;
+
+/*  driver control area address */
+static struct dsp_driver_manager *drv_mngaddr;
+
+/*  memory control table */
+static uint8_t *mem_alloc_table;
+
+static uint32_t block_factor;	/* 2^(n) */
+static uint32_t mat_blocks;
+
+/*  send queue entry */
+static struct arm_queue_ent arm_send_entry[INTERDSP_SQ_LEN * CH_NUM];
+
+/* unsuse send entry list */
+static struct list_head free_sq = LIST_HEAD_INIT(free_sq);
+
+/*  send entry list lock variable */
+static DEFINE_SPINLOCK(free_sq_lock);
+
+/* ACK timeout */
+static unsigned long ack_timeout = INTERDSP_ACK_TIMEOUT;
+
+/* ACK  processing entry list */
+static struct list_head free_ackq = LIST_HEAD_INIT(free_ackq);
+
+/* ACK  processing entry list lock variable */
+static DEFINE_SPINLOCK(free_ackq_lock);
+
+/*  channel send queue */
+static struct list_head arm_ch_sq[CH_NUM];
+
+/*  channel send queue lock variable */
+static spinlock_t arm_ch_sq_lock[CH_NUM];
+static DEFINE_SPINLOCK(arm_ch_sq_lock_unlock);
+
+/*  channel send queue exclusive control semaphore  (default INTERDSP_SQ_LEN) */
+static struct semaphore arm_ch_sqsem[CH_NUM];
+
+/*  channel send queue counter */
+static atomic_t arm_ch_sqcnt[CH_NUM];
+
+/*  channel block semaphore  */
+static struct semaphore arm_ch_block[CH_NUM][BUF_BLOCK_MAX];
+
+/*  channel block lock stat bit map */
+static unsigned long arm_ch_block_lock_bitmap[CH_NUM];
+
+/* select */
+static wait_queue_head_t arm_ch_waitq[CH_NUM];
+
+static unsigned long arm_ch_error;
+static unsigned long dsp_ch_error;
+
+/*  header area address */
+static union interdsp_spa_header *arm_header[CH_NUM];
+static union interdsp_spa_header *dsp_header[CH_NUM];
+
+/* ARM channel data buffer address,  size */
+static int arm_bufnum[CH_NUM];
+static size_t arm_bufsiz[CH_NUM];
+static void *arm_buffer[CH_NUM][BUF_BLOCK_MAX];
+
+/* DSP channel data buffer address,  size */
+static int dsp_bufnum[CH_NUM];
+static void *dsp_buffer[CH_NUM][BUF_BLOCK_MAX];
+static size_t dsp_bufsiz[CH_NUM];
+
+/*  send queue control tasklet define  */
+static void dsp_ack_handler_core(int ch, int success);
+static void dsp_ack_do_tasklet(unsigned long ch);
+static DECLARE_TASKLET_DISABLED(arm_ch0_tasklet, dsp_ack_do_tasklet, 0);
+static DECLARE_TASKLET_DISABLED(arm_ch1_tasklet, dsp_ack_do_tasklet, 1);
+static DECLARE_TASKLET_DISABLED(arm_ch2_tasklet, dsp_ack_do_tasklet, 2);
+
+/*  tasklet array */
+static typeof(arm_ch0_tasklet) *arm_ch_tasklet[] = {
+	&arm_ch0_tasklet, &arm_ch1_tasklet, &arm_ch2_tasklet,
+};
+
+/* receiv header counter */
+static int dsp_ch_recv[CH_NUM] = { 0, };
+
+/* receiv wait queue */
+static wait_queue_head_t dsp_ch_waitq[CH_NUM];
+
+/* receiv tasklet define  */
+static void dsp_req_handler(unsigned long ch);
+static DECLARE_TASKLET(dsp_ch0_tasklet, dsp_req_handler, 0);
+static DECLARE_TASKLET(dsp_ch1_tasklet, dsp_req_handler, 1);
+static DECLARE_TASKLET(dsp_ch2_tasklet, dsp_req_handler, 2);
+
+/* receiv tasklet array */
+static typeof(arm_ch0_tasklet) *dsp_ch_tasklet[] = {
+	&dsp_ch0_tasklet, &dsp_ch1_tasklet, &dsp_ch2_tasklet,
+};
+
+/* "control" flag */
+static atomic_t dsp_rcv_xcount;
+
+/* INTC interrupt control register */
+static unsigned int ipi_mon;
+static unsigned int ipi_clr;
+static unsigned int ipi_set;
+
+/* ioctl chain */
+static DEFINE_SPINLOCK(pre_ioctl_lock);
+static struct list_head pre_ioctl_chain = LIST_HEAD_INIT(pre_ioctl_chain);
+static DEFINE_SPINLOCK(post_ioctl_lock);
+static struct list_head post_ioctl_chain = LIST_HEAD_INIT(post_ioctl_chain);
+
+/* res/req  snatch chain */
+static DEFINE_SPINLOCK(req_chain_lock);
+static struct list_head req_chain = LIST_HEAD_INIT(req_chain);
+
+/* wrapper release inform */
+static DEFINE_SPINLOCK(release_chain_lock);
+static struct list_head release_chain = LIST_HEAD_INIT(release_chain);
+
+static int force_dma_download = FORCE_DMA_DOWNLOAD;
+static int dma_status;
+static DECLARE_WAIT_QUEUE_HEAD(dma_waitq);
+static DEFINE_SPINLOCK(dma_status_lock);
+
+/* SDRAM Download range */
+static struct {
+	unsigned long start;	/* begin */
+	unsigned long end;	/* end + 1 */
+	int valid;
+} sdram_dl_range[] = {
+	/* invalid ranges start here */
+	{~0UL, ~0UL, 0, },	/* interdsp shared memory */
+
+	/* valid ranges start here */
+	{DOWNLOAD_RANGE_START, DOWNLOAD_RANGE_END + 1, 1, },
+};
+
+static int force_init = FORCE_INIT;
+
+static int dspdev_major = DSPDEV_MAJOR;
+static struct cdev dspdev_cdev;
+
+/* statistics */
+static unsigned long send_cmd_count[CH_NUM] = { 0, };
+static unsigned long recv_ack_count[CH_NUM] = { 0, };
+static unsigned long recv_resreq_count[CH_NUM] = { 0, };
+static unsigned long send_ack_count[CH_NUM] = { 0, };
+#if DCV_PROC_FS != 0
+static struct proc_dir_entry *driver_statistics_dir;
+#endif /* DCV_PROC_FS */
+
+static struct interdsp_pending_resreq resreq_pend_ent[RESREQ_PEND_SIZE];
+static struct list_head resreq_pending = LIST_HEAD_INIT(resreq_pending);
+static struct list_head resreq_freelist = LIST_HEAD_INIT(resreq_freelist);
+static DEFINE_SPINLOCK(resreq_pending_lock);
+static DEFINE_SPINLOCK(resreq_freelist_lock);
+static DECLARE_WAIT_QUEUE_HEAD(resreq_pending_waitq);
+static DECLARE_WAIT_QUEUE_HEAD(resreq_freelist_waitq);
+
+/* minor device file_operations */
+static struct minor_device_ent minor_device_table[INTERDSP_MINOR_SIZE];
+static DEFINE_SPINLOCK(minor_device_table_lock);
+
+#if USE_DCV
+#if DCV_TEST_MODE
+static uint32_t dcv_pa[2 * 16];
+#endif
+/* DCV  address */
+static unsigned long dcv_va = MP200_VA_DCV;
+#endif
+
+static int driver_use_count;
+
+#ifdef CONFIG_PM
+/* DCV register take shelter */
+static struct dcv_reg dcv_reg_state[16];
+/* DCV register take shelter flag */
+static int dcv_store;
+/* DSP Suspend flag */
+static int dsp_suspend;
+/* DSP Suspend  response  inform */
+static int volatile suspend_response;
+/* DSP Resume  response  inform */
+static int volatile resume_response;
+#endif
+
+static int dsp_reset_status = DSP_IRES_SET;
+
+
+
+/* dmac ch table */
+static int dma_m2m_lch_list[] = {
+	MP200_DMAC_M2M_DSP_LCH0,
+	MP200_DMAC_M2M_DSP_LCH1,
+	MP200_DMAC_M2M_DSP_LCH2,
+	MP200_DMAC_M2M_DSP_LCH3
+};
+static int dma_p2m_lch_list[] = {
+	MP200_DMAC_P2M_DSP_LCH0,
+	MP200_DMAC_P2M_DSP_LCH1,
+	MP200_DMAC_P2M_DSP_LCH2,
+	MP200_DMAC_P2M_DSP_LCH3,
+	MP200_DMAC_P2M_DSP_LCH4,
+	MP200_DMAC_P2M_DSP_LCH5,
+	-1,			/* MP200_DMAC_P2M_DSP_LCH6 */
+	MP200_DMAC_P2M_DSP_LCH7,
+	-1,			/* MP200_DMAC_P2M_DSP_LCH8 */
+	MP200_DMAC_P2M_DSP_LCH9,
+	MP200_DMAC_P2M_DSP_LCH10,
+	MP200_DMAC_P2M_DSP_LCH11,
+	MP200_DMAC_P2M_DSP_LCH12,
+	MP200_DMAC_P2M_DSP_LCH13,
+	MP200_DMAC_P2M_DSP_LCH14
+};
+static int dma_m2p_lch_list[] = {
+	MP200_DMAC_M2P_DSP_LCH0,
+	MP200_DMAC_M2P_DSP_LCH1,
+	MP200_DMAC_M2P_DSP_LCH2,
+	MP200_DMAC_M2P_DSP_LCH3,
+	MP200_DMAC_M2P_DSP_LCH4,
+	MP200_DMAC_M2P_DSP_LCH5,
+	-1,			/* MP200_DMAC_M2P_DSP_LCH6 */
+	MP200_DMAC_M2P_DSP_LCH7,
+	-1,			/* MP200_DMAC_M2P_DSP_LCH8 */
+	MP200_DMAC_M2P_DSP_LCH9,
+	MP200_DMAC_M2P_DSP_LCH10,
+	MP200_DMAC_M2P_DSP_LCH11,
+	MP200_DMAC_M2P_DSP_LCH12,
+	MP200_DMAC_M2P_DSP_LCH13,
+	MP200_DMAC_M2P_DSP_LCH14
+};
+
+
+/* dmac ch table (cpu) */
+static int dma_cpu_m2m_lch_list[] = {
+	MP200_DMAC_M2M_ACPU_LCH0,
+	MP200_DMAC_M2M_ACPU_LCH1,
+	MP200_DMAC_M2M_ACPU_LCH2,
+	MP200_DMAC_M2M_ACPU_LCH3
+};
+static int dma_cpu_p2m_lch_list[] = {
+	MP200_DMAC_P2M_ACPU_LCH0,
+	MP200_DMAC_P2M_ACPU_LCH1,
+	MP200_DMAC_P2M_ACPU_LCH2,
+	MP200_DMAC_P2M_ACPU_LCH3,
+	MP200_DMAC_P2M_ACPU_LCH4,
+	MP200_DMAC_P2M_ACPU_LCH5,
+	-1,			/* MP200_DMAC_P2M_ACPU_LCH6 */
+	MP200_DMAC_P2M_ACPU_LCH7,
+	-1,			/* MP200_DMAC_P2M_ACPU_LCH8 */
+	MP200_DMAC_P2M_ACPU_LCH9,
+	MP200_DMAC_P2M_ACPU_LCH10,
+	MP200_DMAC_P2M_ACPU_LCH11,
+	MP200_DMAC_P2M_ACPU_LCH12,
+	MP200_DMAC_P2M_ACPU_LCH13,
+	MP200_DMAC_P2M_ACPU_LCH14
+};
+static int dma_cpu_m2p_lch_list[] = {
+	MP200_DMAC_M2P_ACPU_LCH0,
+	MP200_DMAC_M2P_ACPU_LCH1,
+	MP200_DMAC_M2P_ACPU_LCH2,
+	MP200_DMAC_M2P_ACPU_LCH3,
+	MP200_DMAC_M2P_ACPU_LCH4,
+	MP200_DMAC_M2P_ACPU_LCH5,
+	-1,			/* MP200_DMAC_M2P_ACPU_LCH6 */
+	MP200_DMAC_M2P_ACPU_LCH7,
+	-1,			/* MP200_DMAC_M2P_ACPU_LCH8 */
+	MP200_DMAC_M2P_ACPU_LCH9,
+	MP200_DMAC_M2P_ACPU_LCH10,
+	MP200_DMAC_M2P_ACPU_LCH11,
+	MP200_DMAC_M2P_ACPU_LCH12,
+	MP200_DMAC_M2P_ACPU_LCH13,
+	MP200_DMAC_M2P_ACPU_LCH14
+};
+
+
+/***********************************************************************
+ *  file operation
+ **********************************************************************/
+
+/*  prototype */
+static int interdsp_open(struct inode *inode, struct file *file);
+
+static int arm_ch0_open(struct inode *inode, struct file *file);
+static int arm_ch1_open(struct inode *inode, struct file *file);
+static int arm_ch2_open(struct inode *inode, struct file *file);
+
+static unsigned int arm_ch0_poll(struct file *file, poll_table *wait);
+static unsigned int arm_ch1_poll(struct file *file, poll_table *wait);
+static unsigned int arm_ch2_poll(struct file *file, poll_table *wait);
+
+static int arm_ch0_fsync(struct file *file, struct dentry *dentry,
+			 int datasync);
+static int arm_ch1_fsync(struct file *file, struct dentry *dentry,
+			 int datasync);
+static int arm_ch2_fsync(struct file *file, struct dentry *dentry,
+			 int datasync);
+
+static int dsp_ch0_open(struct inode *inode, struct file *file);
+static int dsp_ch1_open(struct inode *inode, struct file *file);
+static int dsp_ch2_open(struct inode *inode, struct file *file);
+
+static int dsp_ch0_release(struct inode *inode, struct file *file);
+static int dsp_ch1_release(struct inode *inode, struct file *file);
+static int dsp_ch2_release(struct inode *inode, struct file *file);
+
+static unsigned int dsp_ch0_poll(struct file *file, poll_table *wait);
+static unsigned int dsp_ch1_poll(struct file *file, poll_table *wait);
+static unsigned int dsp_ch2_poll(struct file *file, poll_table *wait);
+
+static int dsp_ch0_fasync(int fd, struct file *file, int mode);
+static int dsp_ch1_fasync(int fd, struct file *file, int mode);
+static int dsp_ch2_fasync(int fd, struct file *file, int mode);
+static int dspdev_open(struct inode *inode, struct file *file);
+static struct file_operations dspdev_fops = {
+open:dspdev_open,
+};
+
+/*  operationstructure */
+static struct file_operations control_fops = {
+	.poll = interdsp_poll,
+	.ioctl = interdsp_ioctl,
+	.open = interdsp_open,
+	.release = interdsp_release,
+	.fsync = interdsp_fsync,
+	.fasync = interdsp_fasync,
+	.mmap = interdsp_mmap,
+};
+
+static struct file_operations arm_ch0_fops = {
+	.poll = arm_ch0_poll,
+	.ioctl = interdsp_ioctl,
+	.open = arm_ch0_open,
+	.release = interdsp_release,
+	.fsync = arm_ch0_fsync,
+	.mmap = interdsp_mmap,
+};
+
+static struct file_operations arm_ch1_fops = {
+	.poll = arm_ch1_poll,
+	.ioctl = interdsp_ioctl,
+	.open = arm_ch1_open,
+	.release = interdsp_release,
+	.fsync = arm_ch1_fsync,
+	.mmap = interdsp_mmap,
+};
+
+static struct file_operations arm_ch2_fops = {
+	.poll = arm_ch2_poll,
+	.ioctl = interdsp_ioctl,
+	.open = arm_ch2_open,
+	.release = interdsp_release,
+	.fsync = arm_ch2_fsync,
+	.mmap = interdsp_mmap,
+};
+
+static struct file_operations dsp_ch0_fops = {
+	.poll = dsp_ch0_poll,
+	.ioctl = interdsp_ioctl,
+	.open = dsp_ch0_open,
+	.release = dsp_ch0_release,
+	.fasync = dsp_ch0_fasync,
+	.mmap = interdsp_mmap,
+};
+
+static struct file_operations dsp_ch1_fops = {
+	.poll = dsp_ch1_poll,
+	.ioctl = interdsp_ioctl,
+	.open = dsp_ch1_open,
+	.release = dsp_ch1_release,
+	.fasync = dsp_ch1_fasync,
+	.mmap = interdsp_mmap,
+};
+
+static struct file_operations dsp_ch2_fops = {
+	.poll = dsp_ch2_poll,
+	.ioctl = interdsp_ioctl,
+	.open = dsp_ch2_open,
+	.release = dsp_ch2_release,
+	.fasync = dsp_ch2_fasync,
+	.mmap = interdsp_mmap,
+};
+
+/*  file name file operation array */
+static struct {
+	char *name;
+	struct file_operations *fops;
+	int minor;
+} const dsp_procfs[] = {
+	{"control", &control_fops, DSPDEV_CONTROL_MINOR},
+	{"armch0", &arm_ch0_fops, DSPDEV_ARMCH0_MINOR},
+	{"armch1", &arm_ch1_fops, DSPDEV_ARMCH1_MINOR},
+	{"armch2", &arm_ch2_fops, DSPDEV_ARMCH2_MINOR},
+	{"dspch0", &dsp_ch0_fops, DSPDEV_DSPCH0_MINOR},
+	{"dspch1", &dsp_ch1_fops, DSPDEV_DSPCH1_MINOR},
+	{"dspch2", &dsp_ch2_fops, DSPDEV_DSPCH2_MINOR},
+};
+
+
+
+static int __init interdsp_probe(struct platform_device *dev);
+static struct class *interdsp_class;
+static struct platform_driver interdsp_driver = {
+	.probe = interdsp_probe,
+/*	.remove = interdsp_remove, */
+#ifdef CONFIG_PM
+	.suspend = interdsp_suspend,
+	.resume = interdsp_resume,
+#endif
+	.driver = {
+		.name  = "mp200_dsp",
+		.owner = THIS_MODULE,
+	},
+};
+static struct device *interdsp_device;
+
+/***********************************************************************
+ * PE  exclusive spin lock
+ **********************************************************************/
+
+/*  driver lock */
+static DBG_INLINE void global_spin_lock(void)
+{
+	DPRINT("Enter\n");
+
+	while (xchg(&drv_mngaddr->mutex, 1) != 0)
+		;	/* EMPTY */
+
+	DPRINT("Exit\n");
+}
+
+/*  driver unlock */
+static DBG_INLINE void global_spin_unlock(void)
+{
+	DPRINT("Enter\n");
+
+	xchg(&drv_mngaddr->mutex, 0);
+
+	DPRINT("Exit\n");
+}
+
+/***********************************************************************
+ *  memory allocater
+ **********************************************************************/
+
+/*  size(byte)to block number conversion */
+static DBG_INLINE int size_to_mat_blocks(size_t size)
+{
+	int ret;
+
+	DPRINT("Enter [size=%u]\n", size);
+
+	ret = (size + block_factor - 1) / block_factor;
+
+	DPRINT("Exit [%d]\n", ret);
+
+	return ret;
+}
+
+/* MAT number to block address conversion */
+static DBG_INLINE void *get_block_addr(int mat)
+{
+	void *addr;
+
+	DPRINT("Enter [mat=%d]\n", mat);
+
+	addr = MAT2ADDR(mat);
+
+	DPRINT("Exit [addr=0x%08lx]\n", (unsigned long)addr);
+
+	return addr;
+}
+
+/*  block address to MAT number conversion */
+static DBG_INLINE int get_block_mat(void *addr)
+{
+	int ret;
+
+	DPRINT("Enter [addr=0x%08lx]\n", (unsigned long)addr);
+
+	ret = ADDR2MAT(addr);
+
+	DPRINT("Exit\n");
+
+	return ret;
+}
+
+/*  area reservation to MAT */
+static int reserve_mat(uint32_t offset, int nblocks)
+{
+	int beg, end;
+	int err = 0;
+	int i;
+	uint8_t *mp;
+	uint8_t m;
+
+	DPRINT("Enter [offset=%d,nblocks=%d]\n", offset, nblocks);
+
+	beg = get_block_mat(SHARED_BUFADDR(offset));
+	if (mat_blocks < beg) {
+		err = -ENOMEM;
+		goto end;
+	}
+
+	end = beg + nblocks;
+	if (mat_blocks < end) {
+		err = -ENOMEM;
+		goto end;
+	}
+
+	mp = &mem_alloc_table[beg];
+
+	DPRINT("[beg=%d,end=%d]\n", beg, end);
+
+	global_spin_lock();
+
+	for (i = beg; i < end; i++) {
+		m = *mp++;
+		if (m == MAT_FREE || m == MAT_RESERVED)
+			continue;
+
+		DPRINT("Could not reserve: mat[%d]=%02x\n", i, m);
+
+		err = -ENOMEM;
+		goto end;
+	}
+
+	/* MAT set */
+	DBG_MEMSET(&mem_alloc_table[beg], MAT_RESERVED, nblocks);
+
+end:
+	global_spin_unlock();
+
+	DPRINT("Exit [%d]\n", err);
+
+	return err;
+}
+
+static int get_mat(int nblocks)
+{
+	int beg = -1;
+	int i, n = 0;
+	uint8_t *mp = mem_alloc_table;
+	int found = 0;
+
+	DPRINT("Enter [nblocks=%d]\n", nblocks);
+
+	if (nblocks <= 0 || mat_blocks <= nblocks) {
+		beg = -ENOMEM;
+		goto end;
+	}
+
+	global_spin_lock();
+
+	for (i = 0; i < mat_blocks; i++) {
+		int m = *mp++;
+		if (m == MAT_FREE) {
+			if (beg == -1) {
+				beg = i;
+				n = nblocks;
+			}
+			if (--n == 0) {
+				DBG_MEMSET(&mem_alloc_table[beg],
+				       MAT_USED, nblocks);
+				found = 1;
+				break;
+			}
+		} else
+			beg = -1;
+	}
+
+	global_spin_unlock();
+
+	if (found == 0)
+		beg = -ENOMEM;
+
+end:
+	DPRINT("Exit [%d]\n", beg);
+
+	return beg;
+}
+
+/* free MAT */
+static DBG_INLINE void put_mat(int beg, int nblocks)
+{
+	uint8_t *mp;
+	int i;
+
+	DPRINT("Enter [beg=%d,nblocks=%d]\n", beg, nblocks);
+
+	mp = &mem_alloc_table[beg];
+
+	global_spin_lock();
+
+	for (i = 0; i < nblocks && i < mat_blocks; i++) {
+		uint8_t *xp = mp++;
+		if (*xp == MAT_USED) {
+			*xp = MAT_FREE;
+			continue;
+		}
+		DPRINT("Could not free: mat[%d]=%02x\n", i, *xp);
+	}
+
+	global_spin_unlock();
+
+	DPRINT("Exit\n");
+}
+
+/***********************************************************************
+ *  channel information
+ **********************************************************************/
+
+/* free CHINFO */
+static void free_chinfo(int ind, int ch)
+{
+	void *addr;
+	struct interdsp_chinfo *cache;
+	int beg;
+	size_t size;
+	size_t nblocks;
+
+	DPRINT("Enter [%s ch=%d]\n", ind ? "DSP" : "ARM", ch);
+
+	if (ind == 0)
+		cache = &cache_info.peinfo.arm_chinfo[ch];
+	else
+		cache = &cache_info.peinfo.dsp_chinfo[ch];
+
+	if (cache->buffer_offset != 0
+	    && cache->buffer_blksize != 0 && cache->buffer_blknum != 0) {
+		addr = CHINFO_BLOCK_ADDR(cache);
+		beg = get_block_mat(addr);
+		size = CHINFO_BLOCK_BYTES(cache);
+		nblocks = size_to_mat_blocks(size);
+		put_mat(beg, nblocks);
+	}
+
+	DPRINT("Exit\n");
+}
+
+/*  new channel */
+static int new_chinfo(int ind, int ch, struct interdsp_chinfo *chinfo)
+{
+	int err = 0;
+	void *addr;
+	int beg;
+	size_t size;
+	size_t nblocks;
+	hdr_queue_area *quehdr = PE_HEADER_AREA(mp200_pe_number);
+	union interdsp_spa_header *hdrbuf = &(*quehdr)[ind][ch];
+
+	DPRINT("Enter [%s ch=%d,chinfo=0x%08lx]\n",
+	       ind ? "DSP" : "ARM", ch, (unsigned long)chinfo);
+
+	size = CHINFO_BLOCK_BYTES(chinfo);
+	nblocks = size_to_mat_blocks(size);
+	chinfo->header_offset = SHARED_BUFOFF(hdrbuf);
+	if (chinfo->buffer_offset == ~(uint32_t) 0) {
+		beg = get_mat(nblocks);
+		if (beg < 0) {
+			err = beg;
+			goto error_exit;
+		}
+		addr = get_block_addr(beg);
+		chinfo->buffer_offset = SHARED_BUFOFF(addr);
+	} else {
+		err = reserve_mat(chinfo->buffer_offset, nblocks);
+		if (err)
+			goto error_exit;
+	}
+
+error_exit:
+
+	DPRINT("Exit [%d]\n", err);
+
+	return err;
+}
+
+/***********************************************************************
+ * Task  information
+ **********************************************************************/
+
+/*  get channel from task */
+int interdsp_get_taskid_channel(uint32_t taskid)
+{
+	uint32_t ch;
+	int err = -EINVAL;
+
+	DPRINT("Enter [taskid=%d]\n", taskid);
+
+#ifdef MASTER_TASKID
+	if (taskid == MASTER_TASKID) {
+		err = 0;
+		goto end;
+	}
+#endif
+
+	if (TASKID2INDEX(taskid) < TASK_INFO_MAX) {
+		ch = cache_info.peinfo.task_chtbl[TASKID2INDEX(taskid)];
+		if (ch == ~(uint32_t) 0)
+			err = CH_INVALID;	/* invalid */
+		else if (ch < CH_NUM)
+			err = ch;
+	}
+
+end:__attribute__ ((unused))
+
+	    DPRINT("Exit [%d]\n", err);
+
+	return err;
+}
+EXPORT_SYMBOL(interdsp_get_taskid_channel);
+
+int interdsp_set_taskid_channel(uint32_t taskid, uint32_t ch)
+{
+	int err = -EINVAL;
+
+	DPRINT("Enter [taskid=%u,ch=0x%08x]\n", taskid, ch);
+
+	/* invalid */
+	if (ch == CH_INVALID)
+		ch = ~(uint32_t) 0;
+
+	if (TASKID2INDEX(taskid) < TASK_INFO_MAX) {
+		cache_info.peinfo.task_chtbl[TASKID2INDEX(taskid)] = ch;
+		my_peinfo->task_chtbl[TASKID2INDEX(taskid)] = ch;
+		err = 0;
+	}
+
+	DPRINT("Exit\n");
+
+	return err;
+}
+EXPORT_SYMBOL(interdsp_set_taskid_channel);
+
+/***********************************************************************
+ *  send buffer block control
+ **********************************************************************/
+
+/*  buffer block lock */
+static DBG_INLINE int arm_lock_buffer(int ch, int num, int nonblock)
+{
+	int err = 0;
+
+	DPRINT("Enter [ch=%d,num=%d]\n", ch, num);
+
+	if (nonblock) {
+		if (down_trylock(&arm_ch_block[ch][num])) {
+			err = -EAGAIN;
+			goto end;
+		}
+	} else {
+		if (down_interruptible(&arm_ch_block[ch][num])) {
+			err = -ERESTARTSYS;
+			goto end;
+		}
+	}
+	set_bit(num, &arm_ch_block_lock_bitmap[ch]);
+
+end:
+	DPRINT("Exit [%d]\n", err);
+
+	return err;
+}
+
+/*  buffer block unlock */
+static DBG_INLINE void arm_unlock_buffer(int ch, int num)
+{
+	DPRINT("Enter [ch=%d,num=%d]\n", ch, num);
+
+	up(&arm_ch_block[ch][num]);
+	clear_bit(num, &arm_ch_block_lock_bitmap[ch]);
+
+	DPRINT("Exit\n");
+}
+
+/*  buffer block write from user */
+int interdsp_arm_write_buffer(int ch, int num, size_t offset,
+			      const void *ubuf, size_t sz)
+{
+	int err = 0;
+
+	DPRINT("Enter [ch=%d,num=%d,offset=%d,ubuf=%08lx,sz=%u]\n",
+	       ch, num, offset, (unsigned long)ubuf, sz);
+
+	if (sz
+	    && (num < 0
+		|| arm_bufnum[ch] <= num
+		|| arm_bufsiz[ch] < offset + sz
+		|| copy_from_user(BUFADDR(arm_buffer[ch][num], offset),
+				  ubuf, sz)))
+		err = -EFAULT;
+
+#ifdef MP200_DSP_DEBUG
+	else
+		DPRINT("Write to: 0x%08lx\n",
+		       (unsigned long)BUFADDR(arm_buffer[ch][num], offset));
+#endif
+
+	DPRINT("Exit [%d]\n", err);
+
+	return err;
+}
+EXPORT_SYMBOL(interdsp_arm_write_buffer);
+
+/*  buffer block write from kernel */
+int interdsp_arm_write_buffer_internal(int ch, int num, size_t offset,
+				       const void *kbuf, size_t sz)
+{
+	int err = 0;
+
+	DPRINT("Enter [ch=%d,num=%d,offset=%d,kbuf=%08lx,sz=%u]\n",
+	       ch, num, offset, (unsigned long)kbuf, sz);
+
+	if (num < 0 || arm_bufnum[ch] <= num || arm_bufsiz[ch] < offset + sz)
+		err = -EFAULT;
+	else {
+		void *addr = BUFADDR(arm_buffer[ch][num], offset);
+		if (sz) {
+			DBG_MEMCPY(addr, kbuf, sz);
+			dmac_flush_range(addr, (kbuf + sz));
+		}
+		DPRINT("Write to: 0x%08lx\n", (unsigned long)addr);
+	}
+
+	DPRINT("Exit [%d]\n", err);
+
+	return err;
+}
+EXPORT_SYMBOL(interdsp_arm_write_buffer_internal);
+
+/*  buffer block read to kernel */
+int interdsp_arm_read_buffer_internal(int ch, int num, size_t offset,
+				      void *kbuf, size_t sz)
+{
+	int err = 0;
+
+	DPRINT("Enter [ch=%d,num=%d,offset=%d,kbuf=%08lx,sz=%u]\n",
+	       ch, num, offset, (unsigned long)kbuf, sz);
+
+	if (num < 0 || arm_bufnum[ch] <= num || arm_bufsiz[ch] < offset + sz)
+		err = -EFAULT;
+	else {
+		void *addr = BUFADDR(arm_buffer[ch][num], offset);
+		if (sz)
+			DBG_MEMCPY(kbuf, addr, sz);
+
+		DPRINT("Read from: 0x%08lx\n", (unsigned long)addr);
+	}
+
+	DPRINT("Exit [%d]\n", err);
+
+	return err;
+}
+EXPORT_SYMBOL(interdsp_arm_read_buffer_internal);
+
+/*  buffer block read to user */
+int interdsp_dsp_read_buffer(int ch, int num, size_t offset,
+			     void *ubuf, size_t sz)
+{
+	int err = 0;
+
+	DPRINT("Enter [ch=%d,num=%d,offset=%d,ubuf=0x%08lx,sz=%u]\n",
+	       ch, num, offset, (unsigned long)ubuf, sz);
+
+	if (sz
+	    && (num < 0
+		|| dsp_bufnum[ch] <= num
+		|| dsp_bufsiz[ch] < offset + sz
+		|| copy_to_user(ubuf,
+				BUFADDR(dsp_buffer[ch][num], offset), sz)))
+		err = -EFAULT;
+#ifdef MP200_DSP_DEBUG
+	else {
+		DPRINT("Read from: 0x%08lx\n",
+		       (unsigned long)BUFADDR(dsp_buffer[ch][num], offset));
+	}
+#endif
+
+	DPRINT("Exit [%d]\n", err);
+
+	return err;
+}
+EXPORT_SYMBOL(interdsp_dsp_read_buffer);
+
+/*  buffer block read to kernel */
+int interdsp_dsp_read_buffer_internal(int ch, int num, size_t offset,
+				      void *kbuf, size_t sz)
+{
+	int err = 0;
+
+	DPRINT("Enter [ch=%d,num=%d,offset=%d,kbuf=0x%08lx,sz=%u]\n",
+	       ch, num, offset, (unsigned long)kbuf, sz);
+
+	if (num < 0 || dsp_bufnum[ch] <= num || dsp_bufsiz[ch] < offset + sz)
+		err = -EFAULT;
+	else {
+		void *addr = BUFADDR(dsp_buffer[ch][num], offset);
+		if (sz)
+			DBG_MEMCPY(kbuf, addr, sz);
+
+		DPRINT("Read from: 0x%08lx\n", (unsigned long)addr);
+	}
+
+	DPRINT("Exit [%d]\n", err);
+
+	return err;
+}
+
+/***********************************************************************
+ *  send queue control
+ **********************************************************************/
+
+/*  send queue entry initialize function */
+static void init_sq_entry(struct arm_queue_ent *sq)
+{
+	sq->header.header[0] = 0;
+	sq->header.header[1] = 0;
+	sq->ch = 0;
+	sq->num = 0;
+	sq->buf = 0;
+	sq->blocksem = 0;
+	sq->nolock = 0;
+	sq->locked = 0;
+	atomic_set(&sq->ack, 0);
+	atomic_set(&sq->discard, 1);
+	atomic_set(&sq->active, 0);
+	atomic_set(&sq->sync, 0);
+	atomic_set(&sq->valid, 0);
+	atomic_set(&sq->timeout, 0);
+	init_timer(&sq->timeout_timer);
+	init_waitqueue_head(&sq->ack_waitq);
+}
+
+/*  channel send queue semaphore  down */
+int interdsp_prepare_send_sq_entry(struct arm_queue_ent *sq, int nonblock)
+{
+	int err = 0;
+
+	DPRINT("[sq=0x%08lx:%d," "nonblock=%d]\n",
+	       (unsigned long)sq, SQNUM(sq), nonblock);
+
+	if (sq->nolock == 0) {
+		err = interdsp_lock_block_sq_entry(sq, nonblock);
+		if (err)
+			goto end;
+	}
+
+	if (nonblock) {
+		if (down_trylock(&arm_ch_sqsem[sq->ch]))
+			err = -EAGAIN;
+	} else {
+		if (down_interruptible(&arm_ch_sqsem[sq->ch]))
+			err = -ERESTARTSYS;
+	}
+	if (err == 0)
+		atomic_dec(&arm_ch_sqcnt[sq->ch]);
+
+	if (err && sq->nolock == 0)
+		interdsp_unlock_block_sq_entry(sq);
+
+end:
+	DPRINT("Exit [%d]\n", err);
+
+	return err;
+}
+EXPORT_SYMBOL(interdsp_prepare_send_sq_entry);
+
+/*  send queue entry block lock */
+int interdsp_lock_block_sq_entry(struct arm_queue_ent *sq, int nonblock)
+{
+	int err = 0;
+
+	DPRINT("Enter [sq=0x%08lx:%d,nonblock=%d]\n",
+	       (unsigned long)sq, SQNUM(sq), nonblock);
+
+	if (sq->nolock == 0 && sq->locked == 0) {
+		if (nonblock) {
+			if (down_trylock(sq->blocksem)) {
+				err = -EAGAIN;
+				goto end;
+			}
+		} else {
+			if (down_interruptible(sq->blocksem)) {
+				err = -ERESTARTSYS;
+				goto end;
+			}
+		}
+		sq->locked = 1;
+		set_bit(sq->num, &arm_ch_block_lock_bitmap[sq->ch]);
+	}
+
+end:
+	DPRINT("Exit [%d]\n", err);
+	return err;
+}
+EXPORT_SYMBOL(interdsp_lock_block_sq_entry);
+
+/*  send queue entry block unlock */
+void interdsp_unlock_block_sq_entry(struct arm_queue_ent *sq)
+{
+	DPRINT("Enter [sq=0x%08lx:%d]\n", (unsigned long)sq, SQNUM(sq));
+
+	if (sq->locked) {
+		up(sq->blocksem);
+		clear_bit(sq->num, &arm_ch_block_lock_bitmap[sq->ch]);
+		sq->locked = 0;
+	}
+
+	DPRINT("Exit\n");
+}
+EXPORT_SYMBOL(interdsp_unlock_block_sq_entry);
+
+/* get unuse send queue entry */
+static struct arm_queue_ent *get_free_sq_entry(void)
+{
+	unsigned long flags;
+	struct arm_queue_ent *sq;
+
+	DPRINT("Enter\n");
+
+	clear_ackq_entry();
+
+	spin_lock_irqsave(&free_sq_lock, flags);
+
+	if (list_empty(&free_sq)) {
+		printk(KERN_ERR "DSP sendqueue full!!\n");
+		sq = 0;
+		goto error;
+	}
+
+	sq = list_entry(free_sq.next, struct arm_queue_ent, list);
+	if (sq)
+		list_del(&sq->list);
+
+error:
+	spin_unlock_irqrestore(&free_sq_lock, flags);
+
+	DPRINT("Exit [0x%08lx:%d]\n", (unsigned long)sq, SQNUM(sq));
+
+	return sq;
+}
+
+/*  can't send send queue entry entry disposed .pair prepare */
+void interdsp_put_sq_entry(struct arm_queue_ent *sq)
+{
+	DPRINT("Enter [sq=0x%08lx:%d]\n", (unsigned long)sq, SQNUM(sq));
+
+	up(&arm_ch_sqsem[sq->ch]);
+	atomic_inc(&arm_ch_sqcnt[sq->ch]);
+	interdsp_unlock_block_sq_entry(sq);
+	interdsp_free_sq_entry(sq);
+
+	DPRINT("Exit\n");
+}
+EXPORT_SYMBOL(interdsp_put_sq_entry);
+
+/*  send unuse send queue entry list */
+void interdsp_free_sq_entry(struct arm_queue_ent *sq)
+{
+	unsigned long flags;
+
+	DPRINT("Enter [sq=0x%08lx:%d]\n", (unsigned long)sq, SQNUM(sq));
+
+	atomic_set(&sq->valid, 0);
+
+	spin_lock_irqsave(&free_sq_lock, flags);
+	list_add_tail(&sq->list, &free_sq);
+	spin_unlock_irqrestore(&free_sq_lock, flags);
+
+	DPRINT("Exit\n");
+}
+EXPORT_SYMBOL(interdsp_free_sq_entry);
+
+/*  send entry ACK already receiv list */
+static void put_free_ackq_entry(struct arm_queue_ent *sq)
+{
+	unsigned long flags;
+
+	DPRINT("Enter [sq=0x%08lx:%d]\n", (unsigned long)sq, SQNUM(sq));
+
+	spin_lock_irqsave(&free_ackq_lock, flags);
+	list_add_tail(&sq->list, &free_ackq);
+	spin_unlock_irqrestore(&free_ackq_lock, flags);
+
+	DPRINT("Exit\n");
+}
+
+/* ACK already receiv entry disposed */
+static void remove_free_ackq_entry(struct arm_queue_ent *sq)
+{
+	unsigned long flags;
+
+	DPRINT("Enter [sq=0x%08lx:%d]\n", (unsigned long)sq, SQNUM(sq));
+
+	spin_lock_irqsave(&free_ackq_lock, flags);
+	list_del(&sq->list);
+	spin_unlock_irqrestore(&free_ackq_lock, flags);
+
+	interdsp_free_sq_entry(sq);
+
+	DPRINT("Exit\n");
+}
+
+/* all ACK already receiv entry disposed */
+static void clear_ackq_entry(void)
+{
+	unsigned long flags;
+	struct arm_queue_ent *sq;
+
+	DPRINT("Enter\n");
+
+	do {
+		spin_lock_irqsave(&free_ackq_lock, flags);
+
+		if (list_empty(&free_ackq)) {
+			spin_unlock_irqrestore(&free_ackq_lock, flags);
+			break;
+		}
+
+		sq = list_entry(free_ackq.next, struct arm_queue_ent, list);
+		list_del(&sq->list);
+		spin_unlock_irqrestore(&free_ackq_lock, flags);
+
+		DPRINT("Clear ACK [sq=0x%08lx:%d]\n",
+		       (unsigned long)sq, SQNUM(sq));
+
+		interdsp_free_sq_entry(sq);
+	} while (1);
+
+	DPRINT("Exit\n");
+}
+
+/*  get send queue top(now ACTIVE) */
+static struct arm_queue_ent *get_sendq_top(int ch)
+{
+	struct arm_queue_ent *sq;
+	unsigned long flags;
+
+	DPRINT("Enter [ch=%d]\n", ch);
+
+	spin_lock_irqsave(&arm_ch_sq_lock[ch], flags);
+	if (list_empty(&arm_ch_sq[ch])) {
+		sq = 0;
+		goto empty;
+	}
+
+	sq = list_entry(arm_ch_sq[ch].next, struct arm_queue_ent, list);
+
+	list_del(&sq->list);
+
+	up(&arm_ch_sqsem[ch]);
+	atomic_inc(&arm_ch_sqcnt[ch]);
+
+	DPRINT("Remove SendQueue ARM CH%d [sq=0x%08lx:%d], Rest Queue=%d\n",
+	       ch, (unsigned long)sq, SQNUM(sq),
+	       atomic_read(&arm_ch_sqcnt[ch]));
+
+#ifdef MP200_DSP_DEBUG
+	{
+		struct list_head *pos;
+		int i = 0;
+		list_for_each(pos, &arm_ch_waitq[ch].task_list) {
+			wait_queue_t *wq;
+			wq = list_entry(pos, wait_queue_t, task_list);
+			DPRINT("Wait[%d]=0x%08lx[0x%08lx]\n",
+				i, (unsigned long)wq,
+				(unsigned long)wq->private);
+		}
+	}
+#endif
+
+	wake_up_interruptible(&arm_ch_waitq[ch]);	/* for select */
+
+empty:
+	spin_unlock_irqrestore(&arm_ch_sq_lock[ch], flags);
+
+	DPRINT("Exit [sq=0x%08lx:%d]\n", (unsigned long)sq, SQNUM(sq));
+
+	return sq;
+}
+
+/* ACK timeout processing function */
+static void dsp_ack_timeout(unsigned long data)
+{
+	struct arm_queue_ent *sq = (struct arm_queue_ent *)data;
+	int ch = sq->ch;
+
+	DPRINT("Enter\n");
+
+	/* ACK Timeout */
+	atomic_set(&sq->timeout, 1);
+
+	dsp_ack_handler_core(ch, 0);	/* ACK Fail */
+
+	DPRINT("Exit\n");
+}
+
+/*  call send send queue top tasklet too */
+static void dsp_queue_send(int ch)
+{
+	struct arm_queue_ent *sq;
+	unsigned long flags;
+
+	DPRINT("Enter [ch=%d]\n", ch);
+
+	spin_lock_irqsave(&arm_ch_sq_lock[ch], flags);
+
+	if (list_empty(&arm_ch_sq[ch])) {
+		DPRINT("SendQueue Empty\n");
+		goto empty;
+	}
+
+	sq = list_entry(arm_ch_sq[ch].next, struct arm_queue_ent, list);
+
+	if (atomic_read(&sq->active) == 0) {
+		atomic_set(&sq->active, 1);
+
+		DPRINT("Send Header [sq=0x%08lx:%d]/Wait ACK\n",
+		       (unsigned long)sq, SQNUM(sq));
+
+		*arm_header[ch] = sq->header;
+
+		DPRINT("WriteHeader: ARM CH%d[0x%08lx]: 0x%08x 0x%08x\n",
+		       ch, (unsigned long)arm_header[ch],
+		       sq->header.header[0], sq->header.header[1]);
+
+		init_timer(&sq->timeout_timer);
+		sq->timeout_timer.function = dsp_ack_timeout;
+		sq->timeout_timer.data = (unsigned long)sq;
+		mod_timer(&sq->timeout_timer,
+			  jiffies + (ack_timeout * HZ + 999) / 1000);
+
+		__raw_writel(SEND_INT(ch), ipi_set);
+		send_cmd_count[ch]++;
+	}
+#ifdef MP200_DSP_DEBUG
+	else {
+		DPRINT("INFO: Header Already Active [sq=0x%08lx:%d]\n",
+		       (unsigned long)sq, SQNUM(sq));
+	}
+#endif
+
+empty:
+	spin_unlock_irqrestore(&arm_ch_sq_lock[ch], flags);
+
+	DPRINT("Exit\n");
+}
+
+/*  into send queue tall. not wait */
+static DBG_INLINE void put_sendq_tail_core(int ch, struct arm_queue_ent *sq)
+{
+	unsigned long flags;
+
+	DPRINT("Enter [ch=%d,sq=0x%08lx:%d]\n",
+	       ch, (unsigned long)sq, SQNUM(sq));
+
+	atomic_set(&sq->valid, 1);
+
+	spin_lock_irqsave(&arm_ch_sq_lock[ch], flags);
+	list_add_tail(&sq->list, &arm_ch_sq[ch]);
+	spin_unlock_irqrestore(&arm_ch_sq_lock[ch], flags);
+
+	dsp_queue_send(ch);
+
+	DPRINT("Exit\n");
+}
+
+/*  send command send queue. not use handler */
+static int put_sendq_tail(int ch, struct arm_queue_ent *sq, int nonblock)
+{
+	int err = 0;
+
+	DPRINT("Enter [ch=%d, sq=0x%08lx:%d, nonblock=%d]\n",
+	       ch, (unsigned long)sq, SQNUM(sq), nonblock);
+
+	if (nonblock) {
+		if (down_trylock(&arm_ch_sqsem[ch])) {
+			err = -EAGAIN;
+			goto end;
+		}
+	} else {
+		if (down_interruptible(&arm_ch_sqsem[ch])) {
+			err = -ERESTARTSYS;
+			goto end;
+		}
+	}
+	atomic_dec(&arm_ch_sqcnt[ch]);
+
+	put_sendq_tail_core(ch, sq);
+
+	DPRINT("Add SendQueue ARM CH%d [sq=0x%08lx:%d], Rest Queue=%d\n",
+	       ch, (unsigned long)sq, SQNUM(sq),
+	       atomic_read(&arm_ch_sqcnt[ch]));
+
+end:
+	DPRINT("Exit [%d]\n", err);
+
+	return err;
+}
+
+/***********************************************************************
+ * ACK  processing
+ **********************************************************************/
+
+/* ACK  receiv/Timeout  processing core */
+static void dsp_ack_handler_core(int ch, int success)
+{
+	struct arm_queue_ent *sq;
+
+	DPRINT("Enter [ch=%d,%s]\n", ch, success ? "ACK" : "ACK Timeout");
+
+	sq = get_sendq_top(ch);
+	if (sq == 0) {
+		DPRINT("Null ACK/Timeout handled\n");
+		goto end;
+	}
+
+	if (sq->ack_callback)
+		(*sq->ack_callback) (ch, sq->header, success, sq->cb_data);
+
+	if (success) {
+		del_timer_sync(&sq->timeout_timer);
+
+		atomic_inc(&sq->ack);
+	} else {
+		set_bit(INTERDSP_ERROR_ARMCH_ACK_TIMEOUT(ch), &arm_ch_error);
+	}
+
+	if (sq->blocksem) {
+		up(sq->blocksem);
+		clear_bit(sq->num, &arm_ch_block_lock_bitmap[sq->ch]);
+		sq->blocksem = 0;
+		DPRINT("Unlock block\n");
+	}
+
+	if (atomic_read(&sq->active) == 0)
+		printk(KERN_ERR "%s: Queue TOP inactive\n", __func__);
+
+	if (atomic_read(&sq->sync)) {
+		wake_up_interruptible(&sq->ack_waitq);
+		DPRINT("Wakeup SyncTask\n");
+	}
+
+	DPRINT("[sq=0x%08lx:%d]\n", (unsigned long)sq, SQNUM(sq));
+
+	if (atomic_read(&sq->discard))
+		interdsp_free_sq_entry(sq);
+	else
+		put_free_ackq_entry(sq);
+
+end:
+	dsp_queue_send(ch);
+
+	DPRINT("Exit\n");
+}
+
+/* ACK  processing tasklet core */
+static void dsp_ack_do_tasklet(unsigned long ch)
+{
+	DPRINT("Enter [ch=%lu]\n", ch);
+
+	tasklet_disable(arm_ch_tasklet[ch]);
+
+	dsp_ack_handler_core((int)ch, 1);
+
+	DPRINT("Exit\n");
+}
+
+/*********************************************************************
+ * IOCTL
+ *********************************************************************/
+
+static DBG_INLINE int test_and_clear_data(int volatile *ptr)
+{
+	unsigned long flag;
+	int v;
+
+	local_irq_save(flag);
+	v = *ptr;
+	*ptr = 0;
+	local_irq_restore(flag);
+
+	return v;
+}
+
+static DBG_INLINE int round_robin_channel(int *rr)
+{
+	int i;
+	int ch;
+	int ret = CH_INVALID;
+
+	DPRINT("Enter [*rr=%d]\n", *rr);
+
+	for (i = 0; i < CH_NUM; i++) {
+		ch = (*rr)++;
+		if (*rr == CH_NUM)
+			*rr = 0;
+		if (test_and_clear_data(&dsp_ch_recv[ch])) {
+			ret = ch;
+			break;
+		}
+	}
+
+	DPRINT("Exit [ret=%d,*rr=%d]\n", ret, *rr);
+
+	return ret;
+}
+
+/* ACK */
+void interdsp_send_ack(int ch)
+{
+	DPRINT("Enter [ch=%d]\n", ch);
+
+	__raw_writel(ACK_INT(ch), ipi_set);
+	send_ack_count[ch]++;
+
+	DPRINT("Exit\n");
+}
+EXPORT_SYMBOL(interdsp_send_ack);
+
+struct interdsp_pending_resreq *interdsp_push_resreq(uint32_t fdata[2],
+						     void *kdata, size_t len,
+						     void (*cb) (unsigned long
+								 cbdata),
+						     unsigned long cbdata,
+						     int nonblock, int wake)
+{
+	struct interdsp_pending_resreq *rq = 0;
+	unsigned long flags;
+	DECLARE_WAITQUEUE(rq_wait, current);
+
+	DPRINT("Enter\n");
+
+	if (nonblock == 0)
+		add_wait_queue(&resreq_freelist_waitq, &rq_wait);
+
+	do {
+		if (nonblock == 0)
+			set_current_state(TASK_INTERRUPTIBLE);
+
+		spin_lock_irqsave(&resreq_freelist_lock, flags);
+		if (!list_empty(&resreq_freelist)) {
+			rq = list_entry(resreq_freelist.next,
+					struct interdsp_pending_resreq, list);
+			list_del(&rq->list);
+		}
+		spin_unlock_irqrestore(&resreq_freelist_lock, flags);
+
+		if (rq) {
+			rq->fdata[0] = fdata[0];
+			rq->fdata[1] = fdata[1];
+			rq->kdata = kdata;
+			rq->len = len;
+			rq->callback = cb;
+			rq->cb_data = cbdata;
+
+			spin_lock_irqsave(&resreq_pending_lock, flags);
+			list_add_tail(&rq->list, &resreq_pending);
+			spin_unlock_irqrestore(&resreq_pending_lock, flags);
+
+			if (wake)
+				wake_up_interruptible(&resreq_pending_waitq);
+
+			break;
+		}
+
+		if (nonblock)
+			break;
+
+		if (signal_pending(current))
+			break;
+
+		schedule();
+	} while (1);
+
+	if (nonblock == 0) {
+		remove_wait_queue(&resreq_freelist_waitq, &rq_wait);
+		set_current_state(TASK_RUNNING);
+	}
+
+	DPRINT("Exit [rq=%p]\n", rq);
+
+	return rq;
+}
+EXPORT_SYMBOL(interdsp_push_resreq);
+
+void interdsp_pop_resreq(struct interdsp_pending_resreq *resreq)
+{
+	unsigned long flags;
+
+	DPRINT("Enter [resreq=%p]\n", resreq);
+
+	spin_lock_irqsave(&resreq_pending_lock, flags);
+	list_del(&resreq->list);
+	spin_unlock_irqrestore(&resreq_pending_lock, flags);
+
+	spin_lock_irqsave(&resreq_freelist_lock, flags);
+	list_add_tail(&resreq->list, &resreq_freelist);
+	spin_unlock_irqrestore(&resreq_freelist_lock, flags);
+
+	DPRINT("Exit\n");
+}
+EXPORT_SYMBOL(interdsp_pop_resreq);
+
+int interdsp_read(int file_ch, int nonblock,
+		  struct dsp_cmd_rw *rwcmd,
+		  int (*read_callback) (int, int, size_t, void *buf, size_t))
+{
+	static int rr_ch;
+	int err = 0;
+	int i;
+	int ch;
+	int num;
+	size_t size;
+	wait_queue_t dsp_w[CH_NUM];
+	union interdsp_spa_header cmdhdr;	/* SPA-SPX Command Headder */
+	unsigned long flags;
+	struct interdsp_pending_resreq *rq;
+	DECLARE_WAITQUEUE(rq_wait, current);
+
+	DPRINT("Enter [file_ch=%d,nonblock=%d]\n", file_ch, nonblock);
+
+	for (i = 0; i < CH_NUM; i++) {
+		init_waitqueue_entry(&dsp_w[i], current);
+		add_wait_queue(&dsp_ch_waitq[i], &dsp_w[i]);
+	}
+
+	add_wait_queue(&resreq_pending_waitq, &rq_wait);
+
+	do {
+		ch = CH_INVALID;
+		set_current_state(TASK_INTERRUPTIBLE);
+
+		rq = 0;
+		spin_lock_irqsave(&resreq_pending_lock, flags);
+		if (!list_empty(&resreq_pending)) {
+			rq = list_entry(resreq_pending.next,
+					struct interdsp_pending_resreq, list);
+			list_del(&rq->list);
+		}
+		spin_unlock_irqrestore(&resreq_pending_lock, flags);
+		if (rq) {
+			DPRINT("Found Pushd Res/Req\n");
+			break;
+		}
+
+		if (file_ch == CH_INVALID)
+			ch = round_robin_channel(&rr_ch);
+		else if (test_and_clear_data(&dsp_ch_recv[file_ch]))
+			ch = file_ch;
+
+		if (ch != CH_INVALID)
+			break;
+
+		if (signal_pending(current)) {
+			err = -ERESTARTSYS;
+			break;
+		}
+
+		if (nonblock) {
+			err = -EAGAIN;
+			break;
+		}
+
+		schedule();
+	} while (1);
+
+	for (i = 0; i < CH_NUM; i++)
+		remove_wait_queue(&dsp_ch_waitq[i], &dsp_w[i]);
+	remove_wait_queue(&resreq_pending_waitq, &rq_wait);
+	set_current_state(TASK_RUNNING);
+
+	if (err)
+		goto end;
+
+	if (rq) {
+		cmdhdr.header[0] = rwcmd->fdata[0] = rq->fdata[0];
+		cmdhdr.header[1] = rwcmd->fdata[1] = rq->fdata[1];
+
+		if (rwcmd->bsize > rq->len)
+			rwcmd->bsize = rq->len;
+		if (copy_to_user(rwcmd->bdata, rq->kdata, rwcmd->bsize))
+			err = -EFAULT;
+
+		rq->callback(rq->cb_data);
+
+		spin_lock_irqsave(&resreq_freelist_lock, flags);
+		list_add_tail(&rq->list, &resreq_freelist);
+		spin_unlock_irqrestore(&resreq_freelist_lock, flags);
+
+		wake_up_interruptible(&resreq_freelist_waitq);
+
+		goto end;
+	}
+
+	cmdhdr = *dsp_header[ch];
+	rwcmd->fdata[0] = cmdhdr.header[0];
+	rwcmd->fdata[1] = cmdhdr.header[1];
+
+#ifdef MP200_DSP_DEBUG
+	DPRINT("ReadHeader: DSP CH%d[0x%08lx]: 0x%08x 0x%08x\n",
+	       ch, (unsigned long)dsp_header[ch],
+	       cmdhdr.header[0], cmdhdr.header[1]);
+	if (cmdhdr.spa_res.rrf) {
+		DPRINT("Req:RRF=%d,TASKID=%d,CODE=%d,"
+		       "LEN=%d,BLOCK=%d\n",
+		       cmdhdr.spa_req.rrf, cmdhdr.spa_req.taskid,
+		       cmdhdr.spa_req.code, cmdhdr.spa_req.length,
+		       cmdhdr.spa_req.block_num);
+	} else {
+		DPRINT("Res:"
+		       "RRF=%d,EOR=%d,TaskID=%d,ISSUE=%d,"
+		       "ERROR=%d,CODE=%d,LEN=%d,BLOCK=%d\n",
+		       cmdhdr.spa_res.rrf, cmdhdr.spa_res.eor,
+		       cmdhdr.spa_res.taskid, cmdhdr.spa_res.issue,
+		       cmdhdr.spa_res.error, cmdhdr.spa_res.code,
+		       cmdhdr.spa_res.length, cmdhdr.spa_res.block_num);
+	}
+#endif
+
+	size = cmdhdr.spa_res.length * sizeof(uint32_t);
+
+	num = cmdhdr.spa_res.block_num;
+
+	if (rwcmd->bsize > size)
+		rwcmd->bsize = size;
+	if (read_callback)
+		err = (*read_callback) (ch, num, 0,
+					rwcmd->bdata, rwcmd->bsize);
+	__raw_writel(ACK_INT(ch), ipi_set);
+	send_ack_count[ch]++;	DPRINT("send CH%d ACK\n", ch);
+
+end:
+	DPRINT("Exit [%d]\n", err);
+
+	return err;
+}
+EXPORT_SYMBOL(interdsp_read);
+
+int interdsp_writebuf(int ch, int num, int nonblock,
+		      struct dsp_cmd_rw *rwcmd, size_t size)
+{
+	int err = 0;
+
+	DPRINT("Enter [ch=%d,num=%d,nonblock=%d,size=%d]\n",
+	       ch, num, nonblock, size);
+
+	if (size) {
+		err = arm_lock_buffer(ch, num, nonblock);
+		if (err)
+			goto end;
+		err = interdsp_arm_write_buffer(ch, num, rwcmd->offset,
+						rwcmd->bdata, size);
+		arm_unlock_buffer(ch, num);
+	}
+
+end:
+	DPRINT("Exit [%d]\n", err);
+
+	return err;
+}
+EXPORT_SYMBOL(interdsp_writebuf);
+
+int interdsp_wait_ack(int ch, struct arm_queue_ent *sq)
+{
+	int err = 0;
+	DECLARE_WAITQUEUE(wait, current);
+
+	DPRINT("Enter [ch=%d,sq=0x%08lx:%d]\n",
+	       ch, (unsigned long)sq, SQNUM(sq));
+
+	add_wait_queue(&sq->ack_waitq, &wait);
+	do {
+		set_current_state(TASK_INTERRUPTIBLE);
+
+		if (atomic_read(&sq->ack))
+			break;
+
+		if (atomic_read(&sq->timeout)) {
+			err = -ETIME;
+			break;
+		}
+
+		if (signal_pending(current)) {
+			err = -ERESTARTSYS;
+			atomic_set(&sq->discard, 1);
+			break;
+		}
+
+		schedule();
+	} while (1);
+
+	remove_wait_queue(&sq->ack_waitq, &wait);
+	set_current_state(TASK_RUNNING);
+
+	remove_free_ackq_entry(sq);
+
+	DPRINT("Exit [%d]\n", err);
+
+	return err;
+}
+EXPORT_SYMBOL(interdsp_wait_ack);
+
+int interdsp_new_sq_entry(struct arm_queue_ent **sqp,
+			  int ch, int num, int ack_sync,
+			  struct dsp_cmd_rw *rwcmd,
+			  void (*ack_callback) (int ch,
+						union interdsp_spa_header,
+						int, unsigned long),
+			  unsigned long cb_data)
+{
+	int err = 0;
+	struct arm_queue_ent *sq = 0;
+
+	DPRINT("Enter [ch=%d,num=%d,ack_sync=%d]\n", ch, num, ack_sync);
+
+	sq = get_free_sq_entry();
+	if (sq == 0) {
+		err = -ENOMEM;
+		goto error_exit;
+	}
+
+	sq->header.header[0] = rwcmd->fdata[0];
+	sq->header.header[1] = rwcmd->fdata[1];
+	sq->ch = ch;
+	sq->num = num;
+	sq->header.spa_ccf.block_num = num;
+	sq->buf = arm_buffer[ch][num];
+	sq->blocksem = &arm_ch_block[ch][num];
+	sq->nolock = 0;
+	sq->locked = 0;
+	atomic_set(&sq->ack, 0);
+	atomic_set(&sq->active, 0);
+	init_waitqueue_head(&sq->ack_waitq);
+	if (ack_sync) {
+		atomic_set(&sq->sync, 1);
+		atomic_set(&sq->discard, 0);
+	} else {
+		atomic_set(&sq->sync, 0);
+		atomic_set(&sq->discard, 1);
+	}
+	atomic_set(&sq->timeout, 0);
+	sq->ack_callback = ack_callback;
+	sq->cb_data = cb_data;
+
+error_exit:
+
+	if (err == 0)
+		*sqp = sq;
+	else if (sq) {
+		interdsp_free_sq_entry(sq);
+		sq = 0;
+	}
+
+	DPRINT("Exit [%d, sq=0x%08lx:%d]\n",
+	       err, (unsigned long)sq, SQNUM(sq));
+
+	return err;
+}
+EXPORT_SYMBOL(interdsp_new_sq_entry);
+
+void interdsp_send_sq_entry(struct arm_queue_ent *sq)
+{
+	DPRINT("Enter [sq=0x%08lx:%d" "]\n",
+	       (unsigned long)sq, SQNUM(sq));
+
+	put_sendq_tail_core(sq->ch, sq);
+
+	DPRINT("Exit\n");
+}
+EXPORT_SYMBOL(interdsp_send_sq_entry);
+
+union interdsp_spa_header interdsp_get_hdr_sq_entry(struct arm_queue_ent *sq)
+{
+	DPRINT("Enter [sq=0x%08lx:%d]\n", (unsigned long)sq, SQNUM(sq));
+	DPRINT("Exit\n");
+
+	return sq->header;
+}
+EXPORT_SYMBOL(interdsp_get_hdr_sq_entry);
+
+int interdsp_rewrite_sq_entry(struct arm_queue_ent *sq,
+			      union interdsp_spa_header hdr,
+			      void *buf, size_t size)
+{
+	int err = 0;
+
+	DPRINT("Enter [sq=0x%08lx:%d]\n", (unsigned long)sq, SQNUM(sq));
+
+	if (size && buf) {
+		if (sq->blocksem && arm_bufsiz[sq->ch] >= size) {
+			DBG_MEMCPY(arm_buffer[sq->ch][sq->num], buf, size);
+			sq->header = hdr;
+		} else {
+			err = -EFAULT;
+		}
+	}
+
+	DPRINT("Exit [%d]\n", err);
+
+	return err;
+}
+EXPORT_SYMBOL(interdsp_rewrite_sq_entry);
+
+int interdsp_sendhdr(int ch, int num, int nonblock, int ack_sync,
+		     struct dsp_cmd_rw *rwcmd)
+{
+	int err = 0;
+	struct arm_queue_ent *sq = 0;
+
+	DPRINT("Enter [ch=%d,num=%d,nonblock=%d,ack_sync=%d]\n",
+	       ch, num, nonblock, ack_sync);
+
+	err = interdsp_new_sq_entry(&sq, ch, num, ack_sync, rwcmd, 0, 0);
+	if (err)
+		goto error_exit;
+
+	if (sq->header.spa_tcf.buffer == 0x3)	/* TCF && READ */
+		sq->nolock = 1;
+	else {
+		err = interdsp_lock_block_sq_entry(sq, nonblock);
+		if (err)
+			goto error_exit;
+	}
+
+	/*  entry queue send */
+	err = put_sendq_tail(ch, sq, nonblock);
+	if (err) {
+		if (sq->nolock == 0)
+			interdsp_unlock_block_sq_entry(sq);
+		goto error_exit;
+	}
+
+	rwcmd->flags |= INTERDSP_SENDHDR_OK;
+
+	if (ack_sync)
+		err = interdsp_wait_ack(ch, sq);
+
+error_exit:
+
+	if (err != 0 && sq != 0)
+		interdsp_free_sq_entry(sq);
+
+	DPRINT("Exit [%d]\n", err);
+
+	return err;
+}
+EXPORT_SYMBOL(interdsp_sendhdr);
+
+int interdsp_set_chinfo(int ind, int ch, struct interdsp_chinfo *chinfo)
+{
+	int err = 0;
+	void *addr;
+	int i;
+	struct interdsp_chinfo zero_chinfo;
+
+	DPRINT("Enter [%s ch=%d,chinfo=0x%08lx]\n",
+	       ind ? "DSP" : "ARM", ch, (unsigned long)chinfo);
+
+#ifdef STRICT_CH_CHECK
+	if (ind == 0) {
+		if (!list_empty(&arm_ch_sq[ch])) {
+			DPRINT("ARM CH%d Active!!\n", ch);
+			err = -EINVAL;
+			goto error_exit;
+		}
+	} else {
+		if (dsp_ch_recv[ch]) {
+			DPRINT("DSP CH%d Active!!\n", ch);
+			err = -EINVAL;
+			goto error_exit;
+		}
+	}
+#endif
+
+	if (chinfo->header_offset == 0
+	    && chinfo->buffer_offset == 0
+	    && chinfo->buffer_blknum == 0 && chinfo->buffer_blksize == 0) {
+		free_chinfo(ind, ch);
+	} else {
+		free_chinfo(ind, ch);
+
+		err = new_chinfo(ind, ch, chinfo);
+		if (err) {
+			DBG_MEMSET(&zero_chinfo, 0, sizeof zero_chinfo);
+			chinfo = &zero_chinfo;
+		}
+	}
+
+	if (ind == 0) {
+		/* ARM */
+		cache_info.peinfo.arm_chinfo[ch] = *chinfo;
+		my_peinfo->arm_chinfo[ch] = *chinfo;
+
+		arm_bufnum[ch] = chinfo->buffer_blknum;
+		arm_bufsiz[ch] = BLOCK_BYTES(chinfo);
+		if (chinfo->buffer_offset == 0)
+			DBG_MEMSET(arm_buffer[ch], 0, sizeof arm_buffer[ch]);
+		else {
+			addr = CHINFO_BLOCK_ADDR(chinfo);
+
+			for (i = 0; i < chinfo->buffer_blknum; i++) {
+				arm_buffer[ch][i] = addr;
+				addr = BUFADDR(addr, BLOCK_BYTES(chinfo));
+			}
+		}
+	} else {
+		/* DSP */
+		cache_info.peinfo.dsp_chinfo[ch] = *chinfo;
+		my_peinfo->dsp_chinfo[ch] = *chinfo;
+
+		dsp_bufnum[ch] = chinfo->buffer_blknum;
+		dsp_bufsiz[ch] = BLOCK_BYTES(chinfo);
+		if (chinfo->buffer_offset == 0)
+			DBG_MEMSET(dsp_buffer[ch], 0, sizeof dsp_buffer[ch]);
+		else {
+			addr = CHINFO_BLOCK_ADDR(chinfo);
+			for (i = 0; i < chinfo->buffer_blknum; i++) {
+				dsp_buffer[ch][i] = addr;
+				addr = BUFADDR(addr, BLOCK_BYTES(chinfo));
+			}
+		}
+	}
+
+#ifdef STRICT_CH_CHECK
+error_exit:
+#endif
+	DPRINT("Exit [%d]\n", err);
+
+	return err;
+}
+EXPORT_SYMBOL(interdsp_set_chinfo);
+
+int interdsp_get_chinfo(int ind, int ch, struct interdsp_chinfo *chinfo)
+{
+	DPRINT("Enter [%s ch=%d,chinfo=0x%08lx]\n",
+	       ind ? "DSP" : "ARM", ch, (unsigned long)chinfo);
+
+	if (ind == 0)
+		*chinfo = cache_info.peinfo.arm_chinfo[ch];
+	else
+		*chinfo = cache_info.peinfo.dsp_chinfo[ch];
+
+	DPRINT("Exit [0]\n");
+
+	return 0;
+}
+EXPORT_SYMBOL(interdsp_get_chinfo);
+
+int interdsp_checkch(struct dsp_cmd_ch_status *cmd)
+{
+	int ch;
+	uint32_t mask;
+
+	cmd->armchmask &= ((1U << CH_NUM) - 1);
+	cmd->dspchmask &= ((1U << CH_NUM) - 1);
+
+	DPRINT("Enter [cmd=0x%08lx:ARM=0x%1x,DSP=0x%1x]\n",
+	       (unsigned long)cmd, cmd->armchmask, cmd->dspchmask);
+
+	mask = 1;
+	for (ch = 0; ch < CH_NUM; ch++) {
+		if (cmd->armchmask & mask) {
+			if (atomic_read(&arm_ch_sqcnt[ch]) == 0)
+				cmd->armchmask &= ~mask;
+		}
+		if (cmd->dspchmask & mask) {
+			if (dsp_ch_recv[ch] == 0)
+				cmd->dspchmask &= ~mask;
+		}
+		mask <<= 1;
+	}
+
+	cmd->armch_blockbitmap[0] = arm_ch_block_lock_bitmap[0];
+	cmd->armch_blockbitmap[1] = arm_ch_block_lock_bitmap[1];
+	cmd->armch_blockbitmap[2] = arm_ch_block_lock_bitmap[2];
+
+	DPRINT("Exit [ARM=0x%1x,DSP=0x%1x]\n", cmd->armchmask, cmd->dspchmask);
+
+	return 0;
+}
+EXPORT_SYMBOL(interdsp_checkch);
+
+int interdsp_waitch(struct dsp_cmd_ch_status *cmd)
+{
+	int err = 0;
+	int ch;
+	uint32_t mask;
+	uint32_t arm_mask;
+	uint32_t dsp_mask;
+	wait_queue_t arm_wait[CH_NUM];
+	wait_queue_t dsp_wait[CH_NUM];
+
+	cmd->armchmask &= ((1U << CH_NUM) - 1);
+	cmd->dspchmask &= ((1U << CH_NUM) - 1);
+
+	DPRINT("Enter [cmd=0x%08lx:ARM=0x%1x,DSP=0x%1x]\n",
+	       (unsigned long)cmd, cmd->armchmask, cmd->dspchmask);
+
+	mask = (1U << CH_NUM) - 1;
+	if ((cmd->armchmask & mask) == 0 && (cmd->dspchmask & mask) == 0) {
+		cmd->armchmask = 0;
+		cmd->dspchmask = 0;
+		DPRINT("Exit [0] -- null\n");
+		return 0;
+	}
+
+	mask = 1;
+	for (ch = 0; ch < CH_NUM; ch++) {
+		if (cmd->armchmask & mask) {
+			init_waitqueue_entry(&arm_wait[ch], current);
+			add_wait_queue(&arm_ch_waitq[ch], &arm_wait[ch]);
+			DPRINT("Add waitqueue entry ARM CH%d\n", ch);
+		}
+		if (cmd->dspchmask & mask) {
+			init_waitqueue_entry(&dsp_wait[ch], current);
+			add_wait_queue(&dsp_ch_waitq[ch], &dsp_wait[ch]);
+			DPRINT("Add waitqueue entry DSP CH%d\n", ch);
+		}
+		mask <<= 1;
+	}
+
+#ifdef MP200_DSP_DEBUG
+	for (ch = 0; ch < CH_NUM; ch++) {
+		struct list_head *pos;
+		int i = 0;
+		list_for_each(pos, &arm_ch_waitq[ch].task_list) {
+			wait_queue_t *wq;
+			wq = list_entry(pos, wait_queue_t, task_list);
+			DPRINT("ARM CH%d Wait[%d]=0x%08lx[0x%08lx]\n",
+				   ch, i, (unsigned long)wq,
+				   (unsigned long)wq->private);
+			i++;
+		}
+	}
+	for (ch = 0; ch < CH_NUM; ch++) {
+		struct list_head *pos;
+		int i = 0;
+		list_for_each(pos, &dsp_ch_waitq[ch].task_list) {
+			wait_queue_t *wq;
+			wq = list_entry(pos, wait_queue_t, task_list);
+			DPRINT("ARM CH%d Wait[%d]=0x%08lx[0x%08lx]\n",
+				   ch, i, (unsigned long)wq,
+				   (unsigned long)wq->private);
+			i++;
+		}
+	}
+#endif
+
+	do {
+		set_current_state(TASK_INTERRUPTIBLE);
+
+		arm_mask = cmd->armchmask;
+		dsp_mask = cmd->dspchmask;
+		mask = 1;
+		for (ch = 0; ch < CH_NUM; ch++) {
+			if (arm_mask & mask) {
+				if (atomic_read(&arm_ch_sqcnt[ch]) == 0)
+					arm_mask &= ~mask;
+			}
+			if (dsp_mask & mask) {
+				if (dsp_ch_recv[ch] == 0)
+					dsp_mask &= ~mask;
+			}
+			mask <<= 1;
+		}
+
+		if (arm_mask != 0 || dsp_mask != 0)
+			break;
+
+		if (signal_pending(current)) {
+			err = -ERESTARTSYS;
+			break;
+		}
+
+		schedule();
+	} while (1);
+
+	mask = 1;
+	for (ch = 0; ch < CH_NUM; ch++) {
+		if (cmd->armchmask & mask) {
+			remove_wait_queue(&arm_ch_waitq[ch], &arm_wait[ch]);
+			DPRINT("Remove waitqueue entry ARM CH%d\n", ch);
+		}
+		if (cmd->dspchmask & mask) {
+			remove_wait_queue(&dsp_ch_waitq[ch], &dsp_wait[ch]);
+			DPRINT("Remove waitqueue entry DSP CH%d\n", ch);
+		}
+		mask <<= 1;
+	}
+
+	cmd->armchmask = arm_mask;
+	cmd->dspchmask = dsp_mask;
+
+	set_current_state(TASK_RUNNING);
+
+	DPRINT("Exit [ARM=0x%1x,DSP=0x%1x]\n", cmd->armchmask, cmd->dspchmask);
+
+	return err;
+}
+EXPORT_SYMBOL(interdsp_waitch);
+
+#if USE_DCV != 0 && DCV_NEED_MAP != 0
+/* DCV control */
+static int dcv_remap(void)
+{
+	if (dcv_va == 0) {
+#if DCV_TEST_MODE
+		memset(dcv_pa, 0, sizeof dcv_pa);
+		dcv_va = (unsigned long)dcv_pa;
+		*(uint32_t *) (DCV_BANKn_OFFSET(dcv_va, 0)) = 0x200;
+		*(uint32_t *) (DCV_BANKn_OFFSET(dcv_va, 4)) = 0x100;
+		*(uint32_t *) (DCV_BANKn_OFFSET(dcv_va, 8)) = 0x240;
+		*(uint32_t *) (DCV_BANKn_SET(dcv_va, 0)) = 0x3;
+		*(uint32_t *) (DCV_BANKn_SET(dcv_va, 4)) = 0x3;
+		*(uint32_t *) (DCV_BANKn_SET(dcv_va, 8)) = 0x3;
+		*(uint32_t *) (DCV_BANKn_SET(dcv_va, 12)) = 0x4;
+		*(uint32_t *) (DCV_BANKn_SET(dcv_va, 13)) = 0xc;
+		*(uint32_t *) (DCV_BANKn_SET(dcv_va, 14)) = 0xa;
+#else
+		void *v = ioremap_nocache(MP200_DCV_BASE, PAGE_SIZE);
+		if (v == 0) {
+			printk(KERN_INFO "DCV map failed\n");
+			return -ENOMEM;
+		}
+		dcv_va = (unsigned long)v;
+#endif
+	}
+	return 0;
+}
+
+static void dcv_unmap(void)
+{
+#if DCV_TEST_MODE
+	dcv_va = 0;
+#else
+	if (dcv_va) {
+		iounmap((void *)dcv_va);
+		dcv_va = 0;
+	}
+#endif
+}
+#endif /* USE_DCV != 0 && DCV_NEED_MAP != 0 */
+
+#if USE_DCV
+static inline void dcv_set_bank_offset(int n, unsigned int off)
+{
+	__raw_writel(off, DCV_BANKn_OFFSET(dcv_va, n));
+}
+
+static inline void dcv_set_bank_set(int n, unsigned int set)
+{
+	__raw_writel(set, DCV_BANKn_SET(dcv_va, n));
+}
+
+static inline int dcv_set_bank_info(struct dcv_reg *dr)
+{
+	unsigned int bno = dr->bank_no;
+
+	if (bno >= 16)
+		return -EINVAL;
+
+	dcv_set_bank_offset(bno, dr->bank_val.bank_reg.bank_offset);
+	dcv_set_bank_set(bno, dr->bank_val.bank_reg.bank_set);
+
+	return 0;
+}
+
+static inline unsigned int dcv_get_bank_offset(int n)
+{
+	return __raw_readl(DCV_BANKn_OFFSET(dcv_va, n)) & 0x00000fffU;
+}
+
+static inline unsigned int dcv_get_bank_set(int n)
+{
+	return __raw_readl(DCV_BANKn_SET(dcv_va, n)) & 0x0000000fU;
+}
+
+static inline int dcv_get_bank_info(struct dcv_reg *dr)
+{
+	unsigned int bno = dr->bank_no;
+
+	if (bno >= 16)
+		return -EINVAL;
+
+	dr->bank_val.bank_reg.bank_offset = dcv_get_bank_offset(bno);
+	dr->bank_val.bank_reg.bank_set = dcv_get_bank_set(bno);
+
+	return 0;
+}
+#endif
+
+/* DMA Callback */
+static void dma_callback(void *data, int intsts, int intrawsts)
+{
+	DPRINT("Enter [intsts=0x%08x, intrawsts=0x%08x]\n", intsts, intrawsts);
+
+	if (intsts & (MP200_DMAC_INT_ERROR_WR | MP200_DMAC_INT_ERROR_RD)) {
+		DPRINT("DMA Error st=0x%08x, raw=0x%08x\n", intsts, intrawsts);
+		dma_status = -1;
+		wake_up_interruptible(&dma_waitq);
+	} else if (intsts & (MP200_DMAC_INT_LENG_WR|MP200_DMAC_INT_LENG_RD)) {
+		DPRINT("Success\n");
+		dma_status = 1;
+		wake_up_interruptible(&dma_waitq);
+	}
+
+	DPRINT("Exit dma_status=%d\n", dma_status);
+}
+
+static int execute_dma(int chid,
+		       dma_regs_t *dregs,
+		       unsigned long saddr, unsigned long daddr, size_t size)
+{
+	int err = 0;
+	int sig = 0;
+	DECLARE_WAITQUEUE(wait, current);
+
+	DPRINT("Enter [0x%08lx->0x%08lx:%uBytes]\n", saddr, daddr, size);
+
+	dregs->aoff = 0;
+	dregs->boff = 0;
+	dregs->leng = size;
+
+	if (size > (64 * 1024) - 2)
+		dregs->size = 32 * 1024;
+	else
+		dregs->size = size;
+	dregs->mode = 0;	/* no mode */
+
+	/* start DMA */
+	dma_status = 0;
+	err = mp200_start_dma(chid, saddr, 0, daddr,
+			      (MP200_DMAC_INT_ERROR_EN
+			       | MP200_DMAC_INT_LENG_EN));
+	if (err) {
+		printk(KERN_ERR "interdsp: Couldn't start DMA\n");
+		err = -ENXIO;
+		goto end;
+	}
+
+	/* sleep to DMA */
+	add_wait_queue(&dma_waitq, &wait);
+	do {
+		int x;
+
+		set_current_state(TASK_INTERRUPTIBLE);
+
+		spin_lock_irq(&dma_status_lock);
+		x = dma_status;
+		dma_status = 0;
+		spin_unlock_irq(&dma_status_lock);
+
+		if (x < 0) {
+			err = -ENXIO;
+			break;
+		} else if (x > 0)
+			break;
+
+		if (sig == 0 && signal_pending(current))
+			sig = 1;
+
+		schedule();
+	} while (1);
+	remove_wait_queue(&dma_waitq, &wait);
+	set_current_state(TASK_RUNNING);
+
+	if (err == 0 && sig != 0)
+		err = -ERESTARTSYS;
+
+end:
+
+	DPRINT("Exit [err=%d]\n", err);
+
+	return err;
+}
+
+static int dma_download(unsigned long paddr, void *data, size_t size)
+{
+	static int dch[] = {
+		MP200_DMAC_ARM_LCH1, MP200_DMAC_ARM_LCH2,
+	};
+	int err;
+	int chid = -1;
+	int i;
+	unsigned char *vbuf = 0;	/* DMA Buffer (Virtual Address) */
+	unsigned char *wptr;	/* CPU Write Pointer */
+	dma_addr_t dma_addr;
+	size_t buf_size = 0;
+	dma_regs_t *dregs;
+	size_t dsize;		/* DMA data size */
+	size_t wsize;		/* wraitable buffer size */
+
+	DPRINT("Enter [paddr=0x%08lx, data=0x%p, size=%u\n",
+	       paddr, data, size);
+
+	/* search free DMA Channel */
+	for (i = 0; i < ARRAY_SIZE(dch); i++) {
+		err = mp200_request_dma(dch[i], "interdsp", dma_callback,
+					(void *)dch[i], &dregs);
+		if (err == 0) {
+			chid = dch[i];
+			break;
+		}
+	}
+
+	if (chid == -1) {
+		printk(KERN_ERR "interdsp: Could't get DMA Channel\n");
+		err = -ENXIO;
+		goto end;
+	}
+
+	/* allocation DMA Buffer */
+	buf_size = size;
+	if (paddr & 1)
+		buf_size++;
+	if (buf_size & 1)
+		buf_size++;
+	if (buf_size > INTERDSP_DMA_SIZE)
+		buf_size = INTERDSP_DMA_SIZE;
+	vbuf = dma_alloc_coherent(0, buf_size,
+				  &dma_addr, GFP_KERNEL | GFP_DMA);
+	if (vbuf == 0) {
+		printk(KERN_ERR "interdsp: Could't allocate DMA Buffer\n");
+		err = -ENOMEM;
+		goto end;
+	}
+
+	DPRINT("DMA Buffer: 0x%p[0x%08lx],%uBytes\n",
+	       vbuf, (unsigned long)dma_addr, buf_size);
+
+	dmac_inv_range(vbuf, (vbuf + buf_size));
+
+	wptr = vbuf;
+	dsize = size;
+	wsize = buf_size;
+	if (paddr & 1) {
+		paddr--;	/* back */
+		err = execute_dma(chid, dregs, paddr, dma_addr, 2);
+		if (err)
+			goto end;
+		wptr++;
+		dsize++;
+		wsize--;
+	}
+
+	while (dsize) {
+		size_t s = buf_size;
+		size_t len;
+
+		if (s >= dsize) {
+			if (dsize & 1) {
+				err = execute_dma(chid, dregs,
+						  paddr + dsize - 1,
+						  dma_addr + dsize - 1, 2);
+				if (err)
+					goto end;
+				dsize++;
+			}
+			s = dsize;
+		}
+
+		len = size > wsize ? wsize : size;
+
+		/* setup DMA Buffer */
+		DPRINT("DMA Setup: 0x%p->0x%p[%ubyte]\n", data, wptr, len);
+		if (copy_from_user(wptr, data, len)) {
+			DPRINT("Error: Copy fail [-EFALUT]\n");
+			err = -EFAULT;
+			goto end;
+		}
+		dmac_flush_range(wptr, (wptr + len));
+
+		err = execute_dma(chid, dregs, dma_addr, paddr, s);
+		if (err)
+			goto end;
+
+		data += len;
+		size -= len;
+
+		dsize -= s;
+		paddr += s;
+
+		wptr = vbuf;
+		wsize = buf_size;
+	}
+
+end:
+	if (chid != -1)
+		mp200_free_dma(chid);
+	if (vbuf)
+		dma_free_coherent(0, buf_size, vbuf, dma_addr);
+
+	DPRINT("Exit [err=%d]\n", err);
+
+	return err;
+}
+
+static inline int
+in_dl_range(unsigned long x, unsigned long y, typeof(sdram_dl_range) range)
+{
+	if (range->valid) {
+		if (range->start <= x && x < range->end
+		    && range->start < y && y <= range->end)
+			return 1;	/* valid */
+	} else {
+		if ((range->start <= x && x < range->end)
+		    || (range->start < y && y <= range->end))
+			return -1;	/* invalid */
+	}
+	return 0;		/* unknown */
+}
+
+static int cpu_download(void *sram, void *udata, size_t size, int k6)
+{
+	int err = 0;
+	unsigned long vbeg, vend;
+
+	DPRINT("Enter [sram=0x%p,udata=0x%p,size=%u]\n", sram, udata, size);
+
+	vbeg = (unsigned long)sram;
+	vend = vbeg + size;
+
+	if (k6 == 0
+	    || (((unsigned long)sram & 3) == 0
+		&& ((unsigned long)udata & 3) == 0 && (size & 3) == 0)) {
+		DPRINT("Using copy_from_user(0x%p,0x%p,%u)\n",
+		       sram, udata, size);
+		err = copy_from_user(sram, udata, size);
+		if (err)
+			goto end;
+	} else {
+		unsigned char *saddr = udata;
+		unsigned short *daddr = sram;
+		union {
+			unsigned short us;
+			unsigned char uc[2];
+		} d;
+
+		if ((unsigned long)daddr & 1) {
+			DPRINT("Pre: daddr=0x%p\n", daddr);
+
+			/* 2byte align */
+			daddr = (unsigned short *)
+				((unsigned long)daddr & ~1UL);
+			d.us = *daddr;
+			DPRINT("    Old: 0x%p:0x%04x\n", daddr, d.us);
+			err = get_user(d.uc[1], saddr);
+			if (err)
+				goto end;
+			DPRINT("    New: 0x%p:0x%04x\n", daddr, d.us);
+			*daddr++ = d.us;
+			saddr++;
+			size--;
+		}
+
+		while (size > 1) {
+			unsigned short mbuf[256 / sizeof(unsigned short)];
+			size_t s = sizeof mbuf;
+			unsigned short *x;
+
+			/* 2byte unit */
+			if (s > (size & ~1UL))
+				s = (size & ~1UL);
+
+			DPRINT("Copying: saddr=0x%p,daddr=0x%p,size=%u\n",
+			       saddr, daddr, s);
+
+			err = copy_from_user(mbuf, saddr, s);
+			if (err)
+				goto end;
+
+			saddr += s;
+			size -= s;
+			x = mbuf;
+			while (s) {
+				*daddr++ = *x++;
+				s -= 2;
+			}
+		}
+
+		if (size) {
+			DPRINT("Rest: daddr=0x%p\n", daddr);
+			d.us = *daddr;
+			DPRINT("    Old: 0x%p:0x%04x\n", daddr, d.us);
+			err = get_user(d.uc[0], saddr);
+			if (err)
+				goto end;
+			*daddr = d.us;
+			DPRINT("    New: 0x%p:0x%04x\n", daddr, d.us);
+		}
+	}
+
+end:
+
+	DPRINT("Exit [err=%d]\n", err);
+
+	return err;
+}
+
+
+/* DSP  control (ARES) */
+static inline void dsp_ares_core(int set)
+{
+	if (set) {
+		__raw_writel(DSP_ARES_ENA, RESETREQ0ENA);
+		__raw_writel(DSP_ARES_SET, RESETREQ0);
+	} else {
+		__raw_writel(DSP_ARES_ENA, RESETREQ0ENA);
+		__raw_writel(DSP_ARES_CLR, RESETREQ0);
+	}
+}
+
+/* DSP  control (ARES) */
+static inline void dsp_ares(int set)
+{
+#if USE_DIRECT_SMU_ACCESS
+	unsigned long flags;
+
+	local_irq_save(flag);
+	dsp_ares_core(set);
+	local_irq_restore(flag);
+#else  /* !USE_DIRECT_SMU_ACCESS */
+	if (set)
+		mp200_pmu_reset_device(MP200_RESETDEVICE_ADSP_A);
+	else
+		mp200_pmu_unreset_device(MP200_RESETDEVICE_ADSP_A);
+#endif	/* USE_DIRECT_SMU_ACCESS */
+}
+
+
+/* DSP  control (SRES) */
+static inline void dsp_sres_core(int set)
+{
+	if (set) {
+		__raw_writel(DSP_SRES_ENA, RESETREQ0ENA);
+		__raw_writel(DSP_SRES_SET, RESETREQ0);
+	} else {
+		__raw_writel(DSP_SRES_ENA, RESETREQ0ENA);
+		__raw_writel(DSP_SRES_CLR, RESETREQ0);
+	}
+}
+
+/* DSP  control (SRES) */
+static inline void dsp_sres(int set)
+{
+#if USE_DIRECT_SMU_ACCESS
+	unsigned long flags;
+
+	local_irq_save(flag);
+	dsp_sres_core(set);
+	local_irq_restore(flag);
+#else  /* !USE_DIRECT_SMU_ACCESS */
+	if (set)
+		mp200_pmu_reset_device(MP200_RESETDEVICE_ADSP_S);
+	else
+		mp200_pmu_unreset_device(MP200_RESETDEVICE_ADSP_S);
+#endif	/* USE_DIRECT_SMU_ACCESS */
+}
+
+
+/* DSP  control (IRES) */
+static inline void dsp_ires_core(int set)
+{
+	if (set)
+		__raw_writel(DSP_IRES_SET, RESETCTRL0);
+	else
+		__raw_writel(DSP_IRES_CLR, RESETCTRL0);
+}
+
+/* DSP  control (IRES)  */
+static inline void dsp_ires(int set)
+{
+#if 1
+	/* USE_DIRECT_SMU_ACCESS */
+	unsigned long flag;
+
+	local_irq_save(flag);
+	dsp_ires_core(set);
+	local_irq_restore(flag);
+#else
+	/* no PMU function */
+#endif
+	dsp_reset_status = set ? DSP_IRES_SET : DSP_IRES_CLR;
+}
+
+
+/* DSP  control (clock) */
+static inline void dsp_clock_gate_core(int set)
+{
+	unsigned int  read_val;
+
+	if (set) {
+		read_val = __raw_readl(SMU_GCLKCTRL0ENA);
+		__raw_writel(DSP_CLK_MASK_ENA, SMU_GCLKCTRL0ENA);
+		__raw_writel(DSP_CLK_GCK_SET, SMU_GCLKCTRL0);
+		__raw_writel(read_val, SMU_GCLKCTRL0ENA);
+	} else {
+		read_val = __raw_readl(SMU_GCLKCTRL0ENA);
+		__raw_writel(DSP_CLK_MASK_ENA, SMU_GCLKCTRL0ENA);
+		__raw_writel(DSP_CLK_GCK_CLR, SMU_GCLKCTRL0);
+		__raw_writel(read_val, SMU_GCLKCTRL0ENA);
+	}
+}
+
+
+/* DSP  control (clock) */
+static inline void dsp_clock_gate(int set)
+{
+#if USE_DIRECT_SMU_ACCESS
+	unsigned int flag;
+
+	local_irq_save(flag);
+	dsp_clock_gate_core(set);
+	local_irq_restore(flag);
+#else  /* !USE_DIRECT_SMU_ACCESS */
+
+	if (set) {
+		/* DSP_ACLK_GCK -> DSP_CLK_GCK */
+		mp200_pmu_open_clockgate(MP200_CLOCKGATE_DSP_ACLK);
+		mp200_pmu_open_clockgate(MP200_CLOCKGATE_DSP_CLK);
+	} else {
+		mp200_pmu_close_clockgate(MP200_CLOCKGATE_DSP_CLK);
+		mp200_pmu_close_clockgate(MP200_CLOCKGATE_DSP_ACLK);
+	}
+#endif	/* USE_DIRECT_SMU_ACCESS */
+}
+
+static inline int dsp_clock_gate_status(void)
+{
+#if USE_DIRECT_SMU_ACCESS
+	return ((__raw_readl(SMU_GCLKCTRL0)
+		 & DSP_CLK_MASK) == DSP_CLK_GCK_SET) ? 1 : 0;
+#else  /* !USE_DIRECT_SMU_ACCESS */
+	return (mp200_pmu_get_clockgate(MP200_CLOCKGATE_DSP_CLK)
+		&& mp200_pmu_get_clockgate(MP200_CLOCKGATE_DSP_ACLK))
+		? 1 : 0;
+#endif	/* USE_DIRECT_SMU_ACCESS */
+}
+
+/* DSP  control (Auto Clock) */
+static inline void dsp_auto_clock_core(int set)
+{
+	unsigned int val;
+
+	val = __raw_readl(SMU_AHBCLKCTRL0);
+	if (set)
+		val |= DSPLP;
+	else
+		val &= ~DSPLP;
+
+	__raw_writel(val, SMU_AHBCLKCTRL0);
+}
+
+
+static inline void dsp_auto_clock(int set)
+{
+#if 1
+/* #if USE_DIRECT_SMU_ACCESS */
+	unsigned long flag;
+
+	local_irq_save(flag);
+	dsp_auto_clock_core(set);
+	local_irq_restore(flag);
+#else  /* !USE_DIRECT_SMU_ACCESS */
+	if (set)
+		mp200_pmu_clkctrl_on(MP200_CLKCTRL_ADSP);
+	else
+		mp200_pmu_clkctrl_off(MP200_CLKCTRL_ADSP);
+
+#endif	/* USE_DIRECT_SMU_ACCESS */
+}
+
+
+static inline int dsp_auto_clock_status(void)
+{
+#if USE_DIRECT_SMU_ACCESS
+	return (__raw_readl(SMU_AHBCLKCTRL0) & DSPLP) ? 1 : 0;
+#else  /* !USE_DIRECT_SMU_ACCESS */
+	return mp200_pmu_get_clkctrl_status(MP200_CLKCTRL_ADSP);
+#endif	/* USE_DIRECT_SMU_ACCESS */
+}
+
+static inline void dsp_auto_frq_change(int valid)
+{
+#if 0				/* not support */
+#if USE_DIRECT_SMU_ACCESS
+	local_irq_save(flag);
+	dsp_auto_frq_change_core(valid);
+	local_irq_restore(flag);
+#else  /* !USE_DIRECT_SMU_ACCESS */
+	if (valid)
+		(void)mp200_pmu_frqctrl_on(MP200_FRQCTRL_DSP);
+	else
+		(void)mp200_pmu_frqctrl_off(MP200_FRQCTRL_DSP);
+#endif	/* USE_DIRECT_SMU_ACCESS */
+#endif
+}
+
+
+
+static void dsp_start_periperals(unsigned mask)
+{
+#if USE_DIRECT_SMU_ACCESS
+	unsigned int rset_mask0, rset_value0; /* RESTREQ0 */
+	unsigned int rset_mask1, rset_value1; /* RESTREQ1 */
+	unsigned int clk_mask1, clk_value1; /* GCLKCTRL1 */
+	unsigned int clk_mask2, clk_value2; /* GCLKCTRL2 */
+	unsigned int clk_mask3, clk_value3; /* GCLKCTRL3 */
+	unsigned int flag;
+
+	rset_mask0 = 0;
+	rset_value0 = 0;
+	rset_mask1 = 0;
+	rset_value1 = 0;
+	clk_mask1 = 0;
+	clk_value1 = 0;
+	clk_mask2 = 0;
+	clk_value2 = 0;
+	clk_mask3 = 0;
+	clk_value3 = 0;
+
+	if (mask & DSPDEV_PERIP_PM0) {
+		rset_mask1 |= PM0_RST_ENA;
+		RST_CLR(rset_value1, PM0_RST);
+	}
+	if (mask & DSPDEV_PERIP_PM1) {
+		rset_mask1 |= PM1_RST_ENA;
+		RST_CLR(rset_value1, PM1_RST);
+	}
+
+	if (mask & (DSPDEV_PERIP_PM0|DSPDEV_PERIP_PM1)) {
+		/* PCLK On, SCLK On (for RESET) */
+		clk_mask2 |= (PM0_PCLK_GCK_ENA
+			      |PM0_SCLK_GCK_ENA
+			      |PM1_SCLK_GCK_ENA);
+		GCK_SET(clk_value2, (PM0_PCLK_GCK
+				      |PM0_SCLK_GCK
+				      |PM1_SCLK_GCK));
+	}
+
+	if (mask & DSPDEV_PERIP_TI3) {
+		rset_mask1 |= TI3_RST_ENA;
+		RST_CLR(rset_value1, TI3_RST);
+		clk_mask3 |= TI3_TIN_GCLK_ENA;
+		GCK_SET(clk_value3, TI3_TIN_GCLK);
+	}
+
+	if (mask & DSPDEV_PERIP_DCV) {
+		rset_mask0 |= DCV_RST_ENA;
+		RST_CLR(rset_value0, DCV_RST);
+		clk_mask1 |= (DCV_CLK_GCK_ENA|DCV_PCLK_GCK_ENA);
+		GCK_SET(clk_value1, (DCV_CLK_GCK|DCV_PCLK_GCK));
+	}
+
+	DUMP_SMU_REGS(mask, "First");
+
+	local_irq_save(flag);
+
+	/*  clock */
+	if (clk_mask1) {
+		__raw_writel(clk_mask1, SMU_GCLKCTRL1ENA);
+		__raw_writel(clk_value1, SMU_GCLKCTRL1);
+		__raw_writel(0, SMU_GCLKCTRL1ENA);
+	}
+	if (clk_mask2) {
+		__raw_writel(clk_mask2, SMU_GCLKCTRL2ENA);
+		__raw_writel(clk_value2, SMU_GCLKCTRL2);
+		__raw_writel(0, SMU_GCLKCTRL2ENA);
+	}
+	if (clk_mask3) {
+		__raw_writel(clk_mask3, SMU_GCLKCTRL3ENA);
+		__raw_writel(clk_value3, SMU_GCLKCTRL3);
+		__raw_writel(0, SMU_GCLKCTRL3ENA);
+	}
+
+	DUMP_SMU_REGS(mask, "C On");
+
+	if (mask & DSPDEV_PERIP_DCV) {
+		__raw_writel(__raw_readl(SMU_APBCLKCTRL0) & ~DCVPCLKP,
+			      SMU_APBCLKCTRL0);
+	}
+
+	__raw_writel(rset_mask0, SMU_RESETREQ0ENA);
+	__raw_writel(rset_value0, SMU_RESETREQ0);
+	__raw_writel(0, SMU_RESETREQ0ENA);
+	__raw_writel(rset_mask1, SMU_RESETREQ1ENA);
+	__raw_writel(rset_value1, SMU_RESETREQ1);
+	__raw_writel(0, SMU_RESETREQ1ENA);
+
+	DUMP_SMU_REGS(mask, "RESET");
+
+	/* PMx SCLK Stop */
+	if (mask & (DSPDEV_PERIP_PM0|DSPDEV_PERIP_PM1)) {
+		clk_mask2 = 0;
+		if (mask & DSPDEV_PERIP_PM0_STOP_SCLK)
+			clk_mask2 |= PM0_SCLK_GCK_ENA;
+		if (mask & DSPDEV_PERIP_PM1_STOP_SCLK)
+			clk_mask2 |= PM1_SCLK_GCK_ENA;
+		__raw_writel(clk_mask2, SMU_GCLKCTRL2ENA);
+		__raw_writel(GCK_CLR_VAL(PM0_SCLK_GCK
+					   |PM1_SCLK_GCK),
+			      SMU_GCLKCTRL2);
+		__raw_writel(0, SMU_GCLKCTRL2ENA);
+	}
+
+	DUMP_SMU_REGS(mask, "C Off");
+
+	if (mask & DSPDEV_PERIP_DCV) {
+		__raw_writel(__raw_readl(SMU_APBCLKCTRL0) | DCVPCLKP,
+			      SMU_APBCLKCTRL0);
+	}
+
+	local_irq_restore(flag);
+
+#else  /* !USE_DIRECT_SMU_ACCESS */
+	DPRINT("Enter: mask=0x%08x\n", mask);
+	if (mask & (DSPDEV_PERIP_PM0|DSPDEV_PERIP_PM1)) {
+		mp200_pmu_open_clockgate(MP200_CLOCKGATE_PM0_PCLK);
+		mp200_pmu_open_clockgate(MP200_CLOCKGATE_PM0_SCLK);
+		mp200_pmu_open_clockgate(MP200_CLOCKGATE_PM1_SCLK);
+	}
+	if (mask & DSPDEV_PERIP_PM0)
+		mp200_pmu_unreset_device(MP200_RESETDEVICE_PM0);
+	if (mask & DSPDEV_PERIP_PM1)
+		mp200_pmu_unreset_device(MP200_RESETDEVICE_PM1);
+
+	if (mask & DSPDEV_PERIP_TI3) {
+		mp200_pmu_open_clockgate(MP200_CLOCKGATE_TI3_TIN);
+		mp200_pmu_unreset_device(MP200_RESETDEVICE_TI3);
+	}
+	if (mask & DSPDEV_PERIP_DCV) {
+		mp200_pmu_open_clockgate(MP200_CLOCKGATE_DCV_CLK);
+		mp200_pmu_open_clockgate(MP200_CLOCKGATE_DCV_PCLK);
+		mp200_pmu_clkctrl_off(MP200_CLKCTRL_DCVPCLK);
+		mp200_pmu_unreset_device(MP200_RESETDEVICE_DCV);
+		mp200_pmu_clkctrl_on(MP200_CLKCTRL_DCVPCLK);
+	}
+
+	if (mask & (DSPDEV_PERIP_PM0|DSPDEV_PERIP_PM1)) {
+		if (mask & DSPDEV_PERIP_PM0_STOP_SCLK)
+			mp200_pmu_close_clockgate(MP200_CLOCKGATE_PM0_SCLK);
+		if (mask & DSPDEV_PERIP_PM1_STOP_SCLK)
+			mp200_pmu_close_clockgate(MP200_CLOCKGATE_PM1_SCLK);
+	}
+
+	DPRINT("Exit\n");
+#endif	/* USE_DIRECT_SMU_ACCESS */
+}
+
+
+static void dsp_stop_periperals(unsigned mask)
+{
+#if USE_DIRECT_SMU_ACCESS || PMx_STOP_SELECTABLE
+	unsigned int rst;
+#endif
+#if USE_DIRECT_SMU_ACCESS
+	unsigned int rset_mask0, rset_value0;
+	unsigned int rset_mask1, rset_value1;
+	unsigned int clk_mask1, clk_value1;
+	unsigned int clk_mask2, clk_value2;
+	unsigned int clk_mask3, clk_value3;
+	unsigned int tmp_clk_mask2, tmp_clk_value2;
+	unsigned int flag;
+	rset_mask0 = 0;
+	rset_value0 = 0;
+	rset_mask1 = 0;
+	rset_value1 = 0;
+	clk_mask1 = 0;
+	clk_value1 = 0;
+	clk_mask2 = 0;
+	clk_value2 = 0;
+	clk_mask3 = 0;
+	clk_value3 = 0;
+	tmp_clk_mask2 = 0;
+	tmp_clk_value2 = 0;
+
+	rst = __raw_readl(SMU_RESETREQ1);
+	rst &= (PM0_RST|PM1_RST);
+
+	if (mask & DSPDEV_PERIP_PM0) {
+		rset_mask1 |= PM0_RST_ENA;
+		RST_SET(rset_value1, PM0_RST);
+		RST_SET(rst, PM0_RST);
+	}
+	if (mask & DSPDEV_PERIP_PM1) {
+		rset_mask1 |= PM1_RST_ENA;
+		RST_SET(rset_value1, PM1_RST);
+		RST_SET(rst, PM1_RST);
+	}
+
+	if (mask & (DSPDEV_PERIP_PM0|DSPDEV_PERIP_PM1)) {
+#if PMx_STOP_SELECTABLE
+		/* selected PCLK Off */
+		if (((rset_mask1 & (PM0_RST_ENA|PM1_RST_ENA))
+		     ==  (PM0_RST_ENA|PM1_RST_ENA))
+		    || !PM0_PCLK_NEED(rst)) {
+			clk_mask2 |= PM0_PCLK_GCK_ENA;
+			GCK_CLR(clk_value2, PM0_PCLK_GCK);
+		}
+#else
+		/* PCLK Off */
+		clk_mask2 |=  PM0_PCLK_GCK_ENA;
+#endif /* PMx_STOP_SELECTABLE */
+		/* SCLK Off */
+		clk_mask2 |=  (PM0_SCLK_GCK_ENA
+			       |PM1_SCLK_GCK_ENA);
+		GCK_CLR(clk_value2,
+			 PM0_PCLK_GCK|PM0_SCLK_GCK|PM1_SCLK_GCK);
+
+		tmp_clk_mask2 = (PM0_PCLK_GCK_ENA
+				 |PM0_SCLK_GCK_ENA
+				 |PM1_SCLK_GCK_ENA);
+		GCK_SET(tmp_clk_value2, (PM0_PCLK_GCK
+					  |PM0_SCLK_GCK
+					  |PM1_SCLK_GCK));
+	}
+
+	if (mask & DSPDEV_PERIP_TI3) {
+		rset_mask1 |= TI3_RST_ENA;
+		RST_SET(rset_value1, TI3_RST);
+		clk_mask3 |= TI3_TIN_GCLK_ENA;
+		GCK_CLR(clk_value3, TI3_TIN_GCLK);
+	}
+	if (mask & DSPDEV_PERIP_DCV) {
+		rset_mask0 |= DCV_RST_ENA;
+		RST_SET(rset_value0, DCV_RST);
+		clk_mask1 |= (DCV_CLK_GCK_ENA|DCV_PCLK_GCK_ENA);
+		GCK_CLR(clk_value1, (DCV_CLK_GCK|DCV_PCLK_GCK));
+	}
+
+	DUMP_SMU_REGS(mask, "First");
+
+	local_irq_save(flag);
+
+	/* PMx SCLK On (for RESET) */
+	if (tmp_clk_mask2) {
+		__raw_writel(tmp_clk_mask2, SMU_GCLKCTRL2ENA);
+		__raw_writel(tmp_clk_value2, SMU_GCLKCTRL2);
+		__raw_writel(0, SMU_GCLKCTRL2ENA);
+	}
+
+	DUMP_SMU_REGS(mask, "C On");
+
+	if (mask & DSPDEV_PERIP_DCV) {
+		__raw_writel(__raw_readl(SMU_APBCLKCTRL0) & ~DCVPCLKP,
+			      SMU_APBCLKCTRL0);
+	}
+
+	/* reset */
+	__raw_writel(rset_mask0, SMU_RESETREQ0ENA);
+	__raw_writel(rset_value0, SMU_RESETREQ0);
+	__raw_writel(0, SMU_RESETREQ0ENA);
+	__raw_writel(rset_mask1, SMU_RESETREQ1ENA);
+	__raw_writel(rset_value1, SMU_RESETREQ1);
+	__raw_writel(0, SMU_RESETREQ1ENA);
+
+	DUMP_SMU_REGS(mask, "RESET");
+
+	/* PCLK&SCLK set */
+	if (clk_mask1) {
+		__raw_writel(clk_mask1, SMU_GCLKCTRL1ENA);
+		__raw_writel(clk_value1, SMU_GCLKCTRL1);
+		__raw_writel(0, SMU_GCLKCTRL1ENA);
+	}
+	if (clk_mask2) {
+		__raw_writel(clk_mask2, SMU_GCLKCTRL2ENA);
+		__raw_writel(clk_value2, SMU_GCLKCTRL2);
+		__raw_writel(0, SMU_GCLKCTRL2ENA);
+	}
+	if (clk_mask3) {
+		__raw_writel(clk_mask3, SMU_GCLKCTRL3ENA);
+		__raw_writel(clk_value3, SMU_GCLKCTRL3);
+		__raw_writel(0, SMU_GCLKCTRL3ENA);
+	}
+
+	if (mask & DSPDEV_PERIP_DCV) {
+		__raw_writel(__raw_readl(SMU_APBCLKCTRL0) | DCVPCLKP,
+			      SMU_APBCLKCTRL0);
+	}
+
+	local_irq_restore(flag);
+
+	DUMP_SMU_REGS(mask, "C Off");
+#else  /* !USE_DIRECT_SMU_ACCESS */
+
+	DPRINT("Enter: mask=0x%08x\n", mask);
+
+#if PMx_STOP_SELECTABLE
+	if (mask & DSPDEV_PERIP_PM0) {
+		mp200_pmu_open_clockgate(MP200_CLOCKGATE_PM0_SCLK);
+		mp200_pmu_reset_device(MP200_RESETDEVICE_PM0);
+	}
+	if (mask & DSPDEV_PERIP_PM1) {
+		mp200_pmu_open_clockgate(MP200_CLOCKGATE_PM1_SCLK);
+		mp200_pmu_reset_device(MP200_RESETDEVICE_PM1);
+	}
+#else  /* !PMx_STOP_SELECTABLE */
+	if (mask & (DSPDEV_PERIP_PM0|DSPDEV_PERIP_PM1)) {
+		mp200_pmu_open_clockgate(MP200_CLOCKGATE_PM0_SCLK);
+		mp200_pmu_open_clockgate(MP200_CLOCKGATE_PM1_SCLK);
+		mp200_pmu_reset_device(MP200_RESETDEVICE_PM0);
+		mp200_pmu_reset_device(MP200_RESETDEVICE_PM1);
+	}
+#endif	/* PMx_STOP_SELECTABLE */
+
+	if (mask & DSPDEV_PERIP_TI3)
+		mp200_pmu_reset_device(MP200_RESETDEVICE_TI3);
+
+	if (mask & DSPDEV_PERIP_DCV) {
+		mp200_pmu_clkctrl_off(MP200_CLKCTRL_DCVPCLK);
+		mp200_pmu_reset_device(MP200_RESETDEVICE_DCV);
+	}
+
+#if PMx_STOP_SELECTABLE
+	if (mask & DSPDEV_PERIP_PM0)
+		mp200_pmu_close_clockgate(MP200_CLOCKGATE_PM0_SCLK);
+	if (mask & DSPDEV_PERIP_PM1)
+		mp200_pmu_close_clockgate(MP200_CLOCKGATE_PM1_SCLK);
+
+	rst = __raw_readl(SMU_RESETREQ1);
+	rst &= (PM0_RST|PM1_RST);
+
+	if ((mask & (DSPDEV_PERIP_PM0|DSPDEV_PERIP_PM1))
+	    == (DSPDEV_PERIP_PM0|DSPDEV_PERIP_PM1)
+	    || !PM0_PCLK_NEED(rst))
+		mp200_pmu_close_clockgate(MP200_CLOCKGATE_PM0_PCLK);
+#else
+	if (mask & (DSPDEV_PERIP_PM0|DSPDEV_PERIP_PM1)) {
+		mp200_pmu_close_clockgate(MP200_CLOCKGATE_PM0_SCLK);
+		mp200_pmu_close_clockgate(MP200_CLOCKGATE_PM1_SCLK);
+		mp200_pmu_close_clockgate(MP200_CLOCKGATE_PM0_PCLK);
+	}
+#endif /* PMx_STOP_SELECTABLE */
+
+	if (mask & DSPDEV_PERIP_TI3)
+		mp200_pmu_close_clockgate(MP200_CLOCKGATE_TI3_TIN);
+
+	if (mask & DSPDEV_PERIP_DCV) {
+		mp200_pmu_close_clockgate(MP200_CLOCKGATE_DCV_PCLK);
+		mp200_pmu_close_clockgate(MP200_CLOCKGATE_DCV_CLK);
+		mp200_pmu_clkctrl_on(MP200_CLKCTRL_DCVPCLK);
+	}
+	DPRINT("Exit\n");
+#endif	/* USE_DIRECT_SMU_ACCESS */
+}
+
+
+static void dsp_set_tinsel(unsigned mask)
+{
+	unsigned long flags;
+	unsigned int tin_val;
+
+	DPRINT("Enter: mask=0x%08x\n", mask);
+
+	/* Direct SMU register access, because SDK has no pmu_* functions */
+	if (mask & DSPDEV_TIN_TI3_BIT) {
+		local_irq_save(flags);
+
+		if (mask & DSPDEV_TIN_TI3_BIT) {
+			tin_val = __raw_readl(SMU_TI3TIN_SEL);
+			tin_val &= ~MASK_TINTIN_SEL;
+			if (mask & DSPDEV_TIN_TI3_VAL)
+				tin_val |= (1U << 0);
+			__raw_writel(tin_val, SMU_TI3TIN_SEL);
+		}
+		local_irq_restore(flags);
+	}
+
+	DPRINT("Exit\n");
+}
+
+
+static int dsp_set_dma_intsel(unsigned mask)
+{
+	int i;
+	int *lch_list;
+	int size = 0;
+
+#if 0
+	unsigned long int_sel;
+	unsigned long flags;
+	unsigned long val;
+
+	if ((mask & DSPDEV_DMA_INT_SEL_PCH_MASK)
+	    == DSPDEV_DMA_INT_SEL_M2M) {
+		lch_list = &dma_m2m_lch_list[0];
+		size = ARRAY_SIZE(dma_m2m_lch_list);
+		int_sel = IO_ADDRESS(MP200_DMAC_BASE) + 0x0800;
+	} else if ((mask & DSPDEV_DMA_INT_SEL_PCH_MASK)
+		 == DSPDEV_DMA_INT_SEL_M2P) {
+		lch_list = &dma_m2p_lch_list[0];
+		size = ARRAY_SIZE(dma_m2p_lch_list);
+		int_sel = IO_ADDRESS(MP200_DMAC_BASE) + 0x4800;
+	} else if ((mask & DSPDEV_DMA_INT_SEL_PCH_MASK)
+		 == DSPDEV_DMA_INT_SEL_P2M) {
+		lch_list = &dma_p2m_lch_list[0];
+		size = ARRAY_SIZE(dma_p2m_lch_list);
+		int_sel = IO_ADDRESS(MP200_DMAC_BASE) + 0x6800;
+	} else
+		return -EINVAL;
+
+	for (i = 0; i < size; i++) {
+		if ((mask & (1U << i)) != 0 && lch_list[i] != -1) {
+			local_irq_save(flags);
+			val = __raw_readl(int_sel);
+			val &= ~(3U << (i * 2));
+			val |= (3U << (i * 2));
+			__raw_writel(val, int_sel);
+			local_irq_restore(flags);
+		}
+	}
+#else
+	if ((mask & DSPDEV_DMA_INT_SEL_PCH_MASK)
+	    == DSPDEV_DMA_INT_SEL_M2M) {
+		lch_list = &dma_m2m_lch_list[0];
+		size = ARRAY_SIZE(dma_m2m_lch_list);
+	} else if ((mask & DSPDEV_DMA_INT_SEL_PCH_MASK)
+		 == DSPDEV_DMA_INT_SEL_P2M) {
+		lch_list = &dma_p2m_lch_list[0];
+		size = ARRAY_SIZE(dma_p2m_lch_list);
+	} else if ((mask & DSPDEV_DMA_INT_SEL_PCH_MASK)
+		 == DSPDEV_DMA_INT_SEL_M2P) {
+		lch_list = &dma_m2p_lch_list[0];
+		size = ARRAY_SIZE(dma_m2p_lch_list);
+	} else {
+		return -EINVAL;
+	}
+
+	for (i = 0; i < size; i++) {
+		if (mask & (1U << i)) {
+			if (mp200_request_dma(lch_list[i],
+						NULL, NULL, NULL, NULL))
+				return -EFAULT;
+			mp200_free_dma(lch_list[i]);
+		}
+	}
+#endif
+	return 0;
+}
+
+
+static int cpu_set_dma_intsel(unsigned mask)
+{
+	int i;
+	int *lch_list;
+	int size = 0;
+
+	if ((mask & CPUDEV_DMA_INT_SEL_PCH_MASK)
+	    == CPUDEV_DMA_INT_SEL_M2M) {
+		lch_list = &dma_cpu_m2m_lch_list[0];
+		size = ARRAY_SIZE(dma_cpu_m2m_lch_list);
+	} else if ((mask & CPUDEV_DMA_INT_SEL_PCH_MASK)
+		 == CPUDEV_DMA_INT_SEL_P2M) {
+		lch_list = &dma_cpu_p2m_lch_list[0];
+		size = ARRAY_SIZE(dma_cpu_p2m_lch_list);
+	} else if ((mask & CPUDEV_DMA_INT_SEL_PCH_MASK)
+		 == CPUDEV_DMA_INT_SEL_M2P) {
+		lch_list = &dma_cpu_m2p_lch_list[0];
+		size = ARRAY_SIZE(dma_cpu_m2p_lch_list);
+	} else {
+		return -EINVAL;
+	}
+
+	for (i = 0; i < size; i++) {
+		if (mask & (1U << i)) {
+			if (mp200_request_dma(lch_list[i],
+						NULL, NULL, NULL, NULL))
+				return -EFAULT;
+			mp200_free_dma(lch_list[i]);
+		}
+	}
+
+	return 0;
+}
+
+
+static inline void sram_auto_clock(int set)
+{
+#if 1
+/* #if USE_DIRECT_SMU_ACCESS */
+	unsigned long flag;
+	unsigned int val;
+
+	local_irq_save(flag);
+
+	val = __raw_readl(SMU_AHBCLKCTRL1);
+	if (set)
+		val |= SRCLP;
+	else
+		val &= ~SRCLP;
+
+	__raw_writel(val, SMU_AHBCLKCTRL1);
+
+	local_irq_restore(flag);
+#else  /* !USE_DIRECT_SMU_ACCESS */
+	if (set)
+		mp200_pmu_clkctrl_on(MP200_CLKCTRL_SRC);
+	else
+		mp200_pmu_clkctrl_off(MP200_CLKCTRL_SRC);
+
+#endif	/* USE_DIRECT_SMU_ACCESS */
+}
+
+static int dsp_set_sram_control(int srcclkctrl)
+{
+	sram_auto_clock(srcclkctrl);
+
+	return 0;
+}
+
+static inline void dsp_power_control(int on)
+{
+	unsigned int val;
+
+	val = __raw_readl(SMU_POWERSW_ACTRL_EN);
+	val &= ~DSP_PWR_CNT_EN;
+	__raw_writel(val, SMU_POWERSW_ACTRL_EN);
+	val &= ~ADSPSW_ACTRL_EN;
+	__raw_writel(val, SMU_POWERSW_ACTRL_EN);
+
+	if (on) {
+		/* power up */
+		__raw_writel(((DEFAULT_DSP_PWR_WAIT_PARM
+			       << DSP_PWR_WAIT_PARAM_SHIFT)
+			      | ADSPSW_ACTRL),
+			     SMU_ADSPSW_ACTRL);
+	} else {
+		/* power down */
+		__raw_writel((DEFAULT_DSP_PWR_WAIT_PARM
+			      << DSP_PWR_WAIT_PARAM_SHIFT),
+			     SMU_ADSPSW_ACTRL);
+	}
+
+	val = __raw_readl(SMU_POWERSW_ACTRL_EN);
+	val |= ADSPSW_ACTRL_EN;
+	__raw_writel(val, SMU_POWERSW_ACTRL_EN);
+	val |= DSP_PWR_CNT_EN;
+	__raw_writel(val, SMU_POWERSW_ACTRL_EN);
+
+	if (on) {
+		/* wait power up */
+		while (!(__raw_readl(SMU_POWERSW_STATUS) & ADSP_SWCNT_STATUS))
+			udelay(1);
+	} else {
+		/* wait power down */
+		while (__raw_readl(SMU_POWERSW_STATUS) & ADSP_SWCNT_STATUS)
+			udelay(1);
+	}
+}
+
+int interdsp_download(struct dsp_cmd_download *dl)
+{
+	int err = 0;
+	int hres = -1;
+	unsigned char *sram = 0;
+	int do_dma = force_dma_download;
+	int k6 = 0;
+	int save_auto_clock;
+	int save_gate_clock;
+	int gate_clock = -1;
+	int auto_clock = -1;
+
+#define RESET_PREPARE()	\
+do {\
+	if (gate_clock != 1 && save_gate_clock == 0) { \
+		dsp_clock_gate(1); \
+		gate_clock = 1; \
+	} \
+	if (auto_clock != 0 && save_auto_clock != 0) { \
+		dsp_auto_clock(0); \
+		auto_clock = 0; \
+	} \
+} while (0)
+
+	DPRINT("Enter\n");
+
+#if 0
+	if (dl->control & INTERDSP_DL_RESET) {
+		if (dl->reset == 0 || dl->reset == 2)
+			dsp_auto_frq_change(1);
+	}
+#endif
+
+	if ((dl->control & INTERDSP_DL_CLOCK) && dl->clock != 0) {
+		save_gate_clock = 1;
+		gate_clock = 1;
+		dsp_clock_gate(1);
+	} else {
+		save_gate_clock = dsp_clock_gate_status();
+	}
+
+	if ((dl->control & INTERDSP_DL_CLKCTRL) && dl->clkctrl == 0) {
+		save_auto_clock = 0;
+		auto_clock = 0;
+		dsp_auto_clock(0);
+	} else {
+		save_auto_clock = dsp_auto_clock_status();
+	}
+
+	if ((dl->control & INTERDSP_DL_RESET)
+	    && (dl->reset == 1 || dl->reset == 2)) {
+		if (dl->reset == 1) {
+			/* INTC Mask All */
+			__raw_writel(~(uint32_t)0, IT3_IDS0);
+			__raw_writel(~(uint32_t)0, IT3_IDS1);
+			__raw_writel(~(uint32_t)0, IT3_IDS2);
+			/* Clear All Interrupt Status */
+			__raw_writel(~(uint32_t)0, IT3_IIR);
+			/* Clear All IPI Request */
+			__raw_writel(0x3fU, IT0_IPI3_CLR);
+			__raw_writel(0x3fU, IT3_IPI0_CLR);
+			/* Clear INT_DSP */
+			__raw_writel(1, IT3_CLR);
+
+			udelay(200);
+
+			if (auto_clock != 0 && save_auto_clock != 0) {
+				dsp_auto_clock(0);
+				auto_clock = 0;
+			}
+
+			dsp_power_control(0);
+		}
+
+		RESET_PREPARE();
+
+		DPRINT("DSP_IRES: Set\n");
+		dsp_ires(1);
+
+		/* SRESET SET */
+		DPRINT("DSP_SRES: Set\n");
+		dsp_sres(1);
+
+		/* ARESET SET */
+		DPRINT("DSP_ARES: Set\n");
+		dsp_ares(1);
+
+		hres = 1;
+	}
+
+	if ((dl->control & INTERDSP_DL_PROG) != 0 && dl->size > 0) {
+		int do_hres_clear = 0;
+		unsigned long paddr;
+		size_t size;
+		unsigned long offset = dl->offset;
+
+		if (dl->data == 0) {
+			DPRINT("Error: null data\n");
+			err = -EFAULT;
+			goto end;
+		}
+
+		switch (dl->memtype) {
+#if 0
+		case 0:	/* InstSRAM */
+			paddr = MP200_DSPINST_BASE;
+			size = MP200_DSPINST_SIZE;
+			do_hres_clear = 1;
+			if (mp200_pe_number)
+				do_dma = 1;
+			k6 = 1;
+			DPRINT("Download to SRAM(Inst)\n");
+			break;
+		case 1:	/* DataSRAM */
+			paddr = MP200_DSPMEM_BASE;
+			size = MP200_DSPMEM_SIZE;
+			do_hres_clear = 1;
+			if (mp200_pe_number)
+				do_dma = 1;
+			k6 = 1;
+			DPRINT("Download to SRAM(Data)\n");
+			break;
+#endif /* #if 0 */
+		case 2:	/* SRAM */
+			paddr = MP200_SSRAM_BASE;
+			size = MP200_SSRAM_SIZE;
+			DPRINT("Download to SRAM(BANK10)\n");
+			break;
+		case 3:	/* SDRAM */
+			paddr = MP200_SDRAM_BASE;
+			size = MP200_SDRAM_SIZE;
+			DPRINT("Download to SDRAM(BANK3)\n");
+			break;
+		default:
+			err = -EINVAL;
+			goto end;
+		}
+
+		if (dl->memtype == 3) {
+			int i;
+			int v = 0;
+			int r;
+			unsigned long s = MP200_SDRAM_BASE + offset;
+			unsigned long e = s + dl->size;
+
+			for (i = 0; i < ELEMENT_SIZE(sdram_dl_range); i++) {
+				r = in_dl_range(s, e, &sdram_dl_range[i]);
+				if (r == 1) {
+					v = 1;
+				} else if (r == -1) {
+					v = -1;
+					break;
+				}
+			}
+
+			if (v != 1) {
+				DPRINT("Error: Invalid SDRAM Address"
+				       "[0x%08lx-0x%08lx]\n", s, e);
+				err = -EFAULT;
+				goto end;
+			}
+
+			/* reconfigure paddr, size */
+			paddr = s & PAGE_MASK;
+			offset = s - paddr;
+			size = PAGE_ALIGN(e) - paddr;
+		} else if (offset + dl->size > size) {
+			DPRINT("Error: off(%lu)+sz(%u) > SRAM(%u)\n",
+			       offset, dl->size, size);
+			err = -EFAULT;
+			goto end;
+		}
+
+		if (do_dma) {
+			;	/* EMPTY */
+		} else {
+			/*  map */
+			sram = ioremap(paddr, size);
+			if (sram == 0) {
+				err = -ENOMEM;
+				goto end;
+			}
+		}
+
+		if (do_hres_clear) {
+			/* reset control processing */
+			RESET_PREPARE();
+
+			/* SRESET Clear */
+			DPRINT("DSP_ARES: Clear\n");
+			dsp_ares(0);
+			DPRINT("DSP_SRES: Clear\n");
+			dsp_sres(0);
+			hres = 0;
+		}
+
+		if (do_dma) {
+			err = dma_download(paddr + offset, dl->data, dl->size);
+			if (err)
+				goto end;
+		} else {
+			err = cpu_download(sram + offset, dl->data,
+					   dl->size, k6);
+			if (err) {
+				DPRINT("Error: Copy fail [-%d]\n", err);
+				goto end;
+			}
+		}
+
+		DPRINT("Copy 0x%08lx->0x%08lx[%u]\n",
+		       (unsigned long)dl->data, paddr + offset, dl->size);
+	}
+
+	if (dl->control & INTERDSP_DL_RESET) {
+		if (dl->reset == 0 || dl->reset == 2) {
+
+			RESET_PREPARE();
+
+			if (dl->reset == 0)
+				dsp_power_control(1);
+
+			if (hres != 0) {
+				/* SRESET */
+				DPRINT("DSP_ARES: Clear\n");
+				dsp_ares(0);
+				DPRINT("DSP_SRES: Clear\n");
+				dsp_sres(0);
+			}
+
+			/* IRESET */
+			dsp_ires(0);
+			DPRINT("DSP_IRES: Clear\n");
+		}
+	}
+
+	if (((dl->control & INTERDSP_DL_CLOCK) && dl->clock == 0)
+	    || (gate_clock == 1 && save_gate_clock == 0)) {
+		dsp_clock_gate(0);
+	}
+
+	if (((dl->control & INTERDSP_DL_CLKCTRL) && dl->clkctrl != 0)
+	    || (auto_clock == 0 && save_auto_clock == 1)) {
+		dsp_auto_clock(1);
+	}
+
+#if 0
+	if (dl->control & INTERDSP_DL_RESET) {
+		if (dl->reset == 1 || dl->reset == 2)
+			dsp_auto_frq_change(0);
+	}
+#endif
+
+end:
+	if (sram)
+		iounmap(sram);
+
+	DPRINT("Exit [%d]\n", err);
+
+	return err;
+}
+EXPORT_SYMBOL(interdsp_download);
+
+int interdsp_shmem_init(void)
+{
+	int error = 0;
+	uint32_t size;
+	int i;
+
+	DPRINT("Enter\n");
+
+	drv_mngaddr->mutex = 1;	/* lock */
+
+	DBG_MEMSET(shared_base, 0, INTERDSP_PE_INDEX_OFFSET * PE_NUM);
+
+	block_factor = 0;
+	size = shared_mem_size - INTERDSP_BLOCK_OFFSET;
+	for (i = MAT_MIN_BFSHIFT; i <= MAT_MAX_BFSHIFT; i++) {
+		uint32_t f;
+		f = 1U << i;
+		if ((size + f - 1) / f < MAT_MAX) {
+			block_factor = f;
+			break;
+		}
+	}
+	if (block_factor == 0) {
+		error = -ENOMEM;
+		goto error_exit;
+	}
+
+	mat_blocks = (size + block_factor - 1) / block_factor;
+
+	DPRINT("mat_blocks=%d, block_factor=%d\n", mat_blocks, block_factor);
+
+	drv_mngaddr->magic = DRIVER_MAGIC;
+	drv_mngaddr->block_factor = block_factor;
+	drv_mngaddr->nblocks = mat_blocks;
+
+	DBG_MEMSET(mem_alloc_table, MAT_FREE, mat_blocks);
+	DBG_MEMSET(mem_alloc_table + mat_blocks,
+	       MAT_INVALID, MAT_MAX - mat_blocks);
+
+	DPRINT("MAT Setup End\n");
+
+	DBG_MEMSET(&cache_info, 0, INTERDSP_PE_INDEX_OFFSET);
+
+	/* unlock */
+	drv_mngaddr->mutex = 0;
+
+error_exit:
+
+	DPRINT("Exit [error=%d]\n", error);
+
+	return error;
+}
+
+int interdsp_ioctl(struct inode *inode, struct file *file,
+		   unsigned int cmd, unsigned long arg)
+{
+	int err = 0;
+	int i;
+	int nb = 0;		/* non blocking */
+	int wa = 0;		/* wait ACK */
+	int ch;			/* channel number */
+	int num;		/* block number */
+	int taskid;		/* SubTask ID */
+	size_t size;		/* data size (byte) */
+	int file_ch;		/* file channel */
+	struct list_head *pos;
+	union interdsp_spa_header cmdhdr;	/* SPA-SPX Command Headder */
+	struct dsp_cmd_rw rwcmd, *urwcmd;	/* ioctl cmds  */
+	struct dsp_cmd_ch chcmd, *uchcmd;
+	struct dsp_cmd_task_ch taskcmd, *utaskcmd;
+	struct dsp_cmd_ch_status statuscmd, *ustatuscmd;
+	struct dsp_cmd_download dlcmd, *udlcmd;
+#if USE_DCV
+	struct dsp_cmd_dcv_set dcv_set, *udcv_set;
+	struct dcv_reg dcv_tmp[16];	/* 16 banks */
+	int count;
+#endif
+	unsigned long flags = 0;
+	int errnr;
+	int do_copy;
+	struct dsp_cmd_divpmxsclk divpmx, *udivpmx;
+
+#ifdef MP200_DSP_DEBUG
+	switch (cmd) {
+	case INTERDSP_READ:
+		DPRINT("Enter cmd=INTERDSP_READ\n");
+		break;
+	case INTERDSP_WRITE:
+		DPRINT("Enter cmd=INTERDSP_WRITE\n");
+		break;
+	case INTERDSP_WRITEBUF:
+		DPRINT("Enter cmd=INTERDSP_WRITEBUF\n");
+		break;
+	case INTERDSP_SENDHDR:
+		DPRINT("Enter cmd=INTERDSP_SENDHDR\n");
+		break;
+	case INTERDSP_GET_CHINFO:
+		DPRINT("Enter cmd=INTERDSP_GET_CHINFO\n");
+		break;
+	case INTERDSP_SET_CHINFO:
+		DPRINT("Enter cmd=INTERDSP_SET_CHINFO\n");
+		break;
+	case INTERDSP_GET_TASKCH:
+		DPRINT("Enter cmd=INTERDSP_GET_TASKCH\n");
+		break;
+	case INTERDSP_SET_TASKCH:
+		DPRINT("Enter cmd=INTERDSP_SET_TASKCH\n");
+		break;
+	case INTERDSP_SHMEM_INIT:
+		DPRINT("Enter cmd=INTERDSP_SHMEM_INIT\n");
+		break;
+	case INTERDSP_CHECKCH:
+		DPRINT("Enter cmd=INTERDSP_CHECKCH\n");
+		break;
+	case INTERDSP_WAITCH:
+		DPRINT("Enter cmd=INTERDSP_WAITCH\n");
+		break;
+	case INTERDSP_DOWNLOAD:
+		DPRINT("Enter cmd=INTERDSP_DOWNLOAD\n");
+		break;
+	case INTERDSP_GET_ERROR:
+		DPRINT("Enter cmd=INTERDSP_GET_ERROR\n");
+		break;
+#if USE_DCV
+	case INTERDSP_SET_DCV_REGS:
+		DPRINT("Enter cmd=INTERDSP_SET_DCV_REGS\n");
+		break;
+	case INTERDSP_GET_DCV_REGS:
+		DPRINT("Enter cmd=INTERDSP_GET_DCV_REGS\n");
+		break;
+#endif
+	case DSPDEV_START_PERIPHERALS:
+		DPRINT("Enter cmd=DSPDEV_START_PERIPHERALS\n");
+		break;
+	case DSPDEV_STOP_PERIPHERALS:
+		DPRINT("Enter cmd=DSPDEV_STOP_PERIPHERALS\n");
+		break;
+	case DSPDEV_TIN_SEL:
+		DPRINT("Enter cmd=DSPDEV_TIN_SEL\n");
+		break;
+	case DSPDEV_DMA_INT_SEL:
+		DPRINT("Enter cmd=DSPDEV_DMA_INT_SEL\n");
+		break;
+	case CPUDEV_DMA_INT_SEL:
+		DPRINT("Enter cmd=CPUDEV_DMA_INT_SEL\n");
+		break;
+
+	case DSPDEV_SET_DIVPMxSCLK:
+		DPRINT("Enter cmd=DSPDEV_SET_DIVPMxSCLK\n");
+		break;
+
+	case DSPDEV_SRAMCTRL:
+		DPRINT("Enter cmd=DSPDEV_SRAMCTRL\n");
+		break;
+
+	default:
+		DPRINT("Enter Auxiliary cmd=<%u>\n", cmd);
+		break;
+	}
+#endif
+
+	spin_lock(&pre_ioctl_lock);
+	list_for_each(pos, &pre_ioctl_chain) {
+		struct ioctl_chain *chain;
+		chain = list_entry(pos, struct ioctl_chain, list);
+		if (chain->ioctl) {
+			int handled = 0;
+			err = chain->ioctl(inode, file, cmd, arg, &handled);
+			if (handled) {
+				spin_unlock(&pre_ioctl_lock);
+				goto do_post_ioctl;
+			}
+		}
+	}
+	spin_unlock(&pre_ioctl_lock);
+
+	/*  errorreset */
+	err = 0;
+
+	if (file->private_data)
+		file_ch = ((struct dsp_ch_data *)file->private_data)->ch;
+	else
+		file_ch = CH_INVALID;	/* ANY */
+
+	if ((_IOC_DIR(cmd) & _IOC_READ)
+	    && arg != 0
+	    && !access_ok(VERIFY_WRITE, (void *)arg, _IOC_SIZE(cmd))) {
+		DPRINT("EFAULT\n");
+		err = -EFAULT;
+		goto error_exit;
+	}
+
+	if (file->f_flags & O_SYNC)
+		wa = 1;
+	if (file->f_flags & (O_NONBLOCK | O_NDELAY))
+		nb = 1;
+
+	switch (cmd) {
+	case INTERDSP_READ:
+		urwcmd = (struct dsp_cmd_rw *)arg;
+		if (copy_from_user(&rwcmd, urwcmd, sizeof *urwcmd)) {
+			DPRINT("EFAULT\n");
+			err = -EFAULT;
+			break;
+		}
+
+		err = interdsp_read(file_ch, nb, &rwcmd,
+				    interdsp_dsp_read_buffer);
+		if (err)
+			break;
+
+		if (copy_to_user(urwcmd, &rwcmd, sizeof *urwcmd)) {
+			DPRINT("EFAULT\n");
+			err = -EFAULT;
+		}
+
+		break;
+
+	case INTERDSP_WRITE:
+	case INTERDSP_WRITEBUF:
+	case INTERDSP_SENDHDR:
+		urwcmd = (struct dsp_cmd_rw *)arg;
+		if (copy_from_user(&rwcmd, urwcmd, sizeof *urwcmd)) {
+			DPRINT("EFAULT\n");
+			err = -EFAULT;
+			break;
+		}
+
+		cmdhdr.header[0] = rwcmd.fdata[0];
+		cmdhdr.header[1] = rwcmd.fdata[1];
+
+		taskid = cmdhdr.spa_tcf.taskid;
+		ch = interdsp_get_taskid_channel(taskid);
+		if (ch < 0 || ch == CH_INVALID) {	/* error or invalid */
+			DPRINT("Channel Invalid\n");
+			err = -EINVAL;
+			break;
+		}
+
+		num = cmdhdr.spa_tcf.block_num;
+
+		do_copy = 1;
+
+		if (cmdhdr.spa_tcf.buffer & 0x2) {
+			/* TCF */
+			if (cmdhdr.spa_tcf.buffer & 1) {
+				/* DSP->CPU */
+				do_copy = 0;
+				size = 0;
+			} else {
+				/* CPU->DSP */
+				size = cmdhdr.spa_tcf.length;
+			}
+		} else
+			size = cmdhdr.spa_ccf.length;	/* CCF */
+
+		size *= sizeof(uint32_t);
+
+		rwcmd.flags = 0;
+
+		if (do_copy
+		    && (cmd == INTERDSP_WRITE
+			|| cmd == INTERDSP_WRITEBUF)) {
+			err = interdsp_writebuf(ch, num, nb, &rwcmd, size);
+			if (err)
+				break;
+			rwcmd.flags |= INTERDSP_WRITEBUF_OK;
+		}
+
+		if (cmd == INTERDSP_WRITE
+		    || cmd == INTERDSP_SENDHDR) {
+			err = interdsp_sendhdr(ch, num, nb, wa, &rwcmd);
+			if (err)
+				goto write_error_return;
+		}
+
+write_error_return:
+		if (put_user(rwcmd.flags, &urwcmd->flags)) {
+			DPRINT("EFAULT\n");
+			err = -EFAULT;
+		}
+
+		break;
+
+	case INTERDSP_SET_CHINFO:
+	case INTERDSP_GET_CHINFO:
+		uchcmd = (struct dsp_cmd_ch *)arg;
+		if (copy_from_user(&chcmd, uchcmd, sizeof *uchcmd)) {
+			DPRINT("EFAULT\n");
+			err = -EFAULT;
+			break;
+		}
+
+		i = chcmd.dsparm ? 1 : 0;
+		ch = chcmd.chnum;
+
+		if (ch < 0 || CH_NUM <= ch) {
+			DPRINT("Channel Invalid\n");
+			err = -EINVAL;
+			break;
+		}
+
+		if (cmd == INTERDSP_SET_CHINFO)
+			err = interdsp_set_chinfo(i, ch, &chcmd.chinfo);
+		else
+			err = interdsp_get_chinfo(i, ch, &chcmd.chinfo);
+		if (err)
+			break;
+
+		if (copy_to_user(&uchcmd->chinfo, &chcmd.chinfo,
+				 sizeof uchcmd->chinfo)) {
+			DPRINT("EFAULT\n");
+			err = -EFAULT;
+		}
+
+		break;
+
+	case INTERDSP_SET_TASKCH:	/* TASK  information set */
+		utaskcmd = (struct dsp_cmd_task_ch *)arg;
+		if (copy_from_user(&taskcmd, utaskcmd, sizeof *utaskcmd)) {
+			DPRINT("EFAULT\n");
+			err = -EFAULT;
+			break;
+		}
+
+		ch = taskcmd.chnum;
+		if (ch == -1 || (0 <= ch && ch < CH_NUM)) {
+			if (ch == -1)
+				ch = CH_INVALID;	/* invalid */
+			err = interdsp_set_taskid_channel(taskcmd.taskid, ch);
+		} else {
+			DPRINT("Channel Invalid\n");
+			err = -EINVAL;
+		}
+
+		break;
+
+	case INTERDSP_GET_TASKCH:
+		utaskcmd = (struct dsp_cmd_task_ch *)arg;
+		if (copy_from_user(&taskcmd, utaskcmd, sizeof *utaskcmd)) {
+			DPRINT("EFAULT\n");
+			err = -EFAULT;
+			break;
+		}
+
+		err = interdsp_get_taskid_channel(taskcmd.taskid);
+		if (err < 0)
+			break;
+
+		/* invalid channel? */
+		if (err == CH_INVALID)
+			ch = -1;
+		else
+			ch = err;
+
+		err = 0;	/* clear error */
+
+		if (put_user(ch, &utaskcmd->chnum)) {
+			DPRINT("EFAULT\n");
+			err = -EFAULT;
+		}
+
+		break;
+
+	case INTERDSP_CHECKCH:
+	case INTERDSP_WAITCH:
+		ustatuscmd = (struct dsp_cmd_ch_status *)arg;
+		if (copy_from_user(&statuscmd, ustatuscmd,
+					sizeof *ustatuscmd)) {
+			DPRINT("EFAULT\n");
+			err = -EFAULT;
+			break;
+		}
+
+		if (cmd == INTERDSP_CHECKCH)
+			err = interdsp_checkch(&statuscmd);
+		else
+			err = interdsp_waitch(&statuscmd);
+
+		if (copy_to_user(ustatuscmd, &statuscmd, sizeof *ustatuscmd)) {
+			DPRINT("EFAULT\n");
+			err = -EFAULT;
+		}
+
+		break;
+
+	case INTERDSP_SHMEM_INIT:
+		err = interdsp_shmem_init();
+		break;
+
+	case INTERDSP_DOWNLOAD:
+		udlcmd = (struct dsp_cmd_download *)arg;
+		if (copy_from_user(&dlcmd, udlcmd, sizeof *udlcmd)) {
+			DPRINT("EFAULT\n");
+			err = -EFAULT;
+			break;
+		}
+
+		err = interdsp_download(&dlcmd);
+
+		break;
+
+	case INTERDSP_GET_ERROR:
+		flags = 0;
+		for (ch = 0; ch < CH_NUM; ch++) {
+			errnr = INTERDSP_ERROR_ARMCH_ACK_TIMEOUT(ch);
+			if (test_and_clear_bit(errnr, &arm_ch_error))
+				flags |= (1UL << errnr);
+		}
+		if (put_user(flags, (unsigned long *)arg))
+			DPRINT("EFAULT\n");
+		err = -EFAULT;
+		break;
+
+#if USE_DCV
+	case INTERDSP_SET_DCV_REGS:
+	case INTERDSP_GET_DCV_REGS:
+		udcv_set = (struct dsp_cmd_dcv_set *)arg;
+		if (copy_from_user(&dcv_set, udcv_set, sizeof dcv_set)) {
+			DPRINT("EFAULT\n");
+			err = -EFAULT;
+			break;
+		}
+
+		count = dcv_set.count;
+
+		if (count > 16) {
+			DPRINT("dcv_set.count(%u)>16\n", count);
+			err = -EINVAL;
+			break;
+		}
+
+		if (count == 0) {
+			/* err = -EINVAL; */
+			break;
+		}
+
+		if (copy_from_user(dcv_tmp, dcv_set.dcv_regs,
+				   sizeof dcv_tmp[0] * count)) {
+			DPRINT("EFAULT\n");
+			err = -EFAULT;
+			break;
+		}
+
+#if DCV_NEED_MAP
+		err = dcv_remap();
+#endif
+		if (err)
+			break;
+
+		if (cmd == INTERDSP_SET_DCV_REGS) {
+			for (i = 0; i < count; i++)
+				dcv_set_bank_info(&dcv_tmp[i]);
+		} else {
+			if (count == 16) {
+				for (i = 0; i < 16; i++)
+					dcv_tmp[i].bank_no = i;
+			}
+
+			for (i = 0; i < count; i++)
+				dcv_get_bank_info(&dcv_tmp[i]);
+
+			if (copy_to_user(dcv_set.dcv_regs, dcv_tmp,
+					 sizeof dcv_tmp[0] * count)) {
+				DPRINT("EFAULT\n");
+				err = -EFAULT;
+				break;
+			}
+		}
+
+		break;
+#endif
+
+	case DSPDEV_START_PERIPHERALS:
+		dsp_start_periperals(arg);
+		break;
+
+	case DSPDEV_STOP_PERIPHERALS:
+		dsp_stop_periperals(arg);
+		break;
+
+	case DSPDEV_TIN_SEL:
+		dsp_set_tinsel(arg);
+		break;
+
+	case DSPDEV_DMA_INT_SEL:
+		err = dsp_set_dma_intsel(arg);
+		break;
+
+	case CPUDEV_DMA_INT_SEL:
+		err = cpu_set_dma_intsel(arg);
+		break;
+
+	case DSPDEV_SET_DIVPMxSCLK:
+		udivpmx = (struct dsp_cmd_divpmxsclk *)arg;
+		if (copy_from_user(&divpmx, udivpmx, sizeof divpmx)) {
+			DPRINT("EFAULT\n");
+			err = -EFAULT;
+			break;
+		}
+		switch (divpmx.reg_num) {
+		case DSPDEV_DIVPM0SCLK:
+			__raw_writel(divpmx.reg_val, SMU_DIVPM0SCLK);
+			break;
+		case DSPDEV_DIVPM1SCLK:
+			__raw_writel(divpmx.reg_val, SMU_DIVPM1SCLK);
+			break;
+		default:
+			err = -EINVAL;
+			break;
+		}
+		break;
+
+	case DSPDEV_SRAMCTRL:
+		err = dsp_set_sram_control(arg);
+		break;
+
+	default:
+		err = -EINVAL;
+		break;
+	}
+
+do_post_ioctl:
+
+	if (err == 0) {
+		spin_lock(&post_ioctl_lock);
+		list_for_each(pos, &post_ioctl_chain) {
+			struct ioctl_chain *chain;
+			chain = list_entry(pos, struct ioctl_chain, list);
+			if (chain->ioctl)
+				(void)chain->ioctl(inode, file, cmd, arg, 0);
+		}
+		spin_unlock(&post_ioctl_lock);
+	}
+
+error_exit:
+	DPRINT("Exit [%d]\n", err);
+
+	return err;
+}
+EXPORT_SYMBOL(interdsp_ioctl);
+
+/***********************************************************************
+ * Open  file operation
+ **********************************************************************/
+
+int interdsp_open_core(struct inode *inode, struct file *file)
+{
+	int ch;
+
+	DPRINT("Enter [MOD_IN_USE=%d]\n", INTERDSP_DRIVER_USE);
+
+	if (!INTERDSP_DRIVER_USE) {
+		for (ch = 0; ch < CH_NUM; ch++)
+			dsp_ch_recv[ch] = 0;
+		DBG_MEMSET(&cache_info, 0, sizeof cache_info);
+		DBG_MEMCPY(&cache_info, my_peinfo, INTERDSP_PE_INDEX_OFFSET);
+	}
+
+	INTERDSP_DRIVER_OPEN;
+
+	DPRINT("Exit\n");
+
+	return 0;
+}
+EXPORT_SYMBOL(interdsp_open_core);
+
+/* control open  function */
+static int interdsp_open(struct inode *inode, struct file *file)
+{
+	int err;
+
+	DPRINT("Enter\n");
+
+	file->private_data = (void *)&any_ch_private;
+	err = interdsp_open_core(inode, file);
+
+	any_ch_private.opend = 1;
+
+	DPRINT("Exit [%d]\n", err);
+
+	return err;
+}
+
+/* armch0 open  function */
+static int arm_ch0_open(struct inode *inode, struct file *file)
+{
+	int err;
+
+	DPRINT("Enter\n");
+
+	file->private_data = (void *)&arm_ch0_private;
+	err = interdsp_open_core(inode, file);
+
+	arm_ch0_private.opend = 1;
+
+	DPRINT("Exit [%d]\n", err);
+
+	return err;
+}
+
+/* armch1 open  function */
+static int arm_ch1_open(struct inode *inode, struct file *file)
+{
+	int err;
+
+	DPRINT("Enter\n");
+
+	file->private_data = (void *)&arm_ch1_private;
+	err = interdsp_open_core(inode, file);
+
+	arm_ch1_private.opend = 1;
+
+	DPRINT("Exit [%d]\n", err);
+
+	return err;
+}
+
+/* armch2 open  function */
+static int arm_ch2_open(struct inode *inode, struct file *file)
+{
+	int err;
+
+	DPRINT("Enter\n");
+
+	file->private_data = (void *)&arm_ch2_private;
+	err = interdsp_open_core(inode, file);
+
+	arm_ch2_private.opend = 1;
+
+	DPRINT("Exit [%d]\n", err);
+
+	return err;
+}
+
+/* dspch0 open  function */
+static int dsp_ch0_open(struct inode *inode, struct file *file)
+{
+	int err;
+
+	DPRINT("Enter\n");
+
+	file->private_data = (void *)&dsp_ch0_private;
+	err = interdsp_open_core(inode, file);
+
+	dsp_ch0_private.opend = 1;
+
+	DPRINT("Exit [%d]\n", err);
+
+	return err;
+}
+
+/* dspch1 open  function */
+static int dsp_ch1_open(struct inode *inode, struct file *file)
+{
+	int err;
+
+	DPRINT("Enter\n");
+
+	file->private_data = (void *)&dsp_ch1_private;
+	err = interdsp_open_core(inode, file);
+
+	dsp_ch1_private.opend = 1;
+
+	DPRINT("Exit [%d]\n", err);
+
+	return err;
+}
+
+/* dspch2 open  function */
+static int dsp_ch2_open(struct inode *inode, struct file *file)
+{
+	int err;
+
+	DPRINT("Enter\n");
+
+	file->private_data = (void *)&dsp_ch2_private;
+	err = interdsp_open_core(inode, file);
+
+	dsp_ch2_private.opend = 1;
+
+	DPRINT("Exit [%d]\n", err);
+
+	return err;
+}
+
+/***********************************************************************
+ * Relese  file operation
+ **********************************************************************/
+
+/* release  core */
+int interdsp_release_core(struct inode *inode, struct file *file)
+{
+	int ch;
+	int i, n;
+	struct list_head *pos;
+	struct arm_queue_ent *sq;
+	struct notify_chain *rc;
+	unsigned long flags;
+	struct interdsp_pending_resreq *rq;
+
+	DPRINT("Enter\n");
+
+	n = 0;
+	for (i = 0; i < ARRAY_SIZE(dsp_ch_privates); i++) {
+		if (dsp_ch_privates[i]->opend)
+			n++;
+	}
+
+	if (n == 0)
+		INTERDSP_DRIVER_CLOSE;
+
+	if (!INTERDSP_DRIVER_USE) {
+		local_irq_save(flags);
+
+		/*  driver initialize inform */
+		spin_lock(&release_chain_lock);
+		list_for_each(pos, &release_chain) {
+			rc = list_entry(pos, struct notify_chain, list);
+			(*rc->notify) (inode, file);
+		}
+		spin_unlock(&release_chain_lock);
+
+		for (ch = 0; ch < CH_NUM; ch++) {
+			sq = get_sendq_top(ch);
+			if (sq != 0 && atomic_read(&sq->active))
+				del_timer_sync(&sq->timeout_timer);
+
+			/*  send queue initialize */
+			INIT_LIST_HEAD(&arm_ch_sq[ch]);
+			arm_ch_sq_lock[ch] = arm_ch_sq_lock_unlock;
+			sema_init(&arm_ch_sqsem[ch], INTERDSP_SQ_LEN);
+			atomic_set(&arm_ch_sqcnt[ch], INTERDSP_SQ_LEN);
+
+			for (i = 0; i < BUF_BLOCK_MAX; i++)
+				sema_init(&arm_ch_block[ch][i], 1);
+			arm_ch_block_lock_bitmap[ch] = 0;
+
+			init_waitqueue_head(&arm_ch_waitq[ch]);
+			init_waitqueue_head(&dsp_ch_waitq[ch]);
+			dsp_ch_recv[ch] = 0;
+		}
+
+		/*  error initialize */
+		arm_ch_error = 0;
+		dsp_ch_error = 0;
+
+		/*  send queue entry initialize */
+		INIT_LIST_HEAD(&free_sq);
+		for (i = 0; i < INTERDSP_SQ_LEN * CH_NUM; i++) {
+			init_sq_entry(&arm_send_entry[i]);
+			list_add_tail(&arm_send_entry[i].list, &free_sq);
+		}
+
+		list_for_each(pos, &resreq_pending) {
+			rq = list_entry(pos, struct interdsp_pending_resreq,
+					list);
+			(*rq->callback) (rq->cb_data);
+		}
+
+		INIT_LIST_HEAD(&resreq_pending);
+		INIT_LIST_HEAD(&resreq_freelist);
+		for (i = 0; i < RESREQ_PEND_SIZE; i++) {
+			list_add_tail(&resreq_pend_ent[i].list,
+				      &resreq_freelist);
+		}
+		resreq_freelist_lock = arm_ch_sq_lock_unlock;
+		resreq_pending_lock = arm_ch_sq_lock_unlock;
+
+		local_irq_restore(flags);
+	}
+
+	DPRINT("Exit [MOD_IN_COUNT=%d]\n", INTERDSP_DRIVER_USE);
+
+	return 0;
+}
+EXPORT_SYMBOL(interdsp_release_core);
+
+#define TI3_OP (IO_ADDRESS(MP200_TIMER3_BASE) + 0x00)
+
+int interdsp_release(struct inode *inode, struct file *file)
+{
+	int err;
+	struct dsp_ch_data *p = (struct dsp_ch_data *)file->private_data;
+
+	DPRINT("Enter\n");
+
+	p->opend = 0;
+
+	if (interdsp_fasync_queue)
+		interdsp_fasync(-1, file, 0);
+	err = interdsp_release_core(inode, file);
+
+	dsp_clock_gate(0);
+
+	__raw_writel(__raw_readl(TI3_OP) & ~0x3 , TI3_OP);
+
+	DPRINT("Exit [%d]\n", err);
+
+	return err;
+}
+EXPORT_SYMBOL(interdsp_release);
+
+int interdsp_dsp_release_core(int ch, struct inode *inode, struct file *file)
+{
+	int err = 0;
+	struct dsp_ch_data *p = (struct dsp_ch_data *)file->private_data;
+
+	DPRINT("Enter [ch=%d]\n", ch);
+
+	p->opend = 0;
+
+	if (dsp_ch_fasync_queue[ch])
+		(void)fasync_helper(-1, file, 0, &dsp_ch_fasync_queue[ch]);
+	err = interdsp_release_core(inode, file);
+
+	DPRINT("Exit [%d]\n", err);
+	return err;
+}
+EXPORT_SYMBOL(interdsp_dsp_release_core);
+
+
+static int dsp_ch0_release(struct inode *inode, struct file *file)
+{
+	int err;
+
+	DPRINT("Enter\n");
+
+	err = interdsp_dsp_release_core(0, inode, file);
+
+	DPRINT("Exit [%d]\n", err);
+
+	return err;
+}
+
+static int dsp_ch1_release(struct inode *inode, struct file *file)
+{
+	int err;
+
+	DPRINT("Enter\n");
+
+	err = interdsp_dsp_release_core(1, inode, file);
+
+	DPRINT("Exit [%d]\n", err);
+
+	return err;
+}
+
+static int dsp_ch2_release(struct inode *inode, struct file *file)
+{
+	int err;
+
+	DPRINT("Enter\n");
+
+	err = interdsp_dsp_release_core(2, inode, file);
+
+	DPRINT("Exit [%d]\n", err);
+
+	return err;
+}
+
+/***********************************************************************
+ * Poll  file operation
+ **********************************************************************/
+
+unsigned int interdsp_poll(struct file *file, poll_table *wait)
+{
+	int ch;
+	int state = 0;
+	unsigned long flags;
+
+	DPRINT("Enter\n");
+
+	for (ch = 0; ch < CH_NUM; ch++) {
+		poll_wait(file, &arm_ch_waitq[ch], wait);
+		poll_wait(file, &dsp_ch_waitq[ch], wait);
+		poll_wait(file, &resreq_pending_waitq, wait);
+		if (atomic_read(&arm_ch_sqcnt[ch]))
+			state |= POLLOUT | POLLWRNORM;
+		if (dsp_ch_recv[ch])
+			state |= POLLIN | POLLRDNORM;
+		spin_lock_irqsave(&resreq_pending_lock, flags);
+		if (!list_empty(&resreq_pending))
+			state |= POLLIN | POLLRDNORM;
+		spin_unlock_irqrestore(&resreq_pending_lock, flags);
+	}
+
+	if (arm_ch_error)
+		state |= POLLERR;
+	if (dsp_ch_error)
+		state |= POLLERR;
+
+	DPRINT("Exit [%d]\n", state);
+
+	return state;
+}
+EXPORT_SYMBOL(interdsp_poll);
+
+unsigned int interdsp_arm_poll_core(int ch,
+				    struct file *file, poll_table *wait)
+{
+	int ret = 0;
+
+	DPRINT("Enter\n");
+
+	poll_wait(file, &arm_ch_waitq[ch], wait);
+
+	if (atomic_read(&arm_ch_sqcnt[ch]))
+		ret |= POLLOUT | POLLWRNORM;
+
+	if (test_bit(INTERDSP_ERROR_ARMCH_ACK_TIMEOUT(ch), &arm_ch_error))
+		ret |= POLLERR;
+
+	DPRINT("Exit [%d]\n", ret);
+
+	return ret;
+}
+EXPORT_SYMBOL(interdsp_arm_poll_core);
+
+static unsigned int arm_ch0_poll(struct file *file, poll_table *wait)
+{
+	int err;
+
+	DPRINT("Enter\n");
+
+	err = interdsp_arm_poll_core(0, file, wait);
+
+	DPRINT("Exit [%d]\n", err);
+
+	return err;
+}
+
+static unsigned int arm_ch1_poll(struct file *file, poll_table *wait)
+{
+	int err;
+
+	DPRINT("Enter\n");
+
+	err = interdsp_arm_poll_core(1, file, wait);
+
+	DPRINT("Exit [%d]\n", err);
+
+	return err;
+}
+
+static unsigned int arm_ch2_poll(struct file *file, poll_table *wait)
+{
+	int err;
+
+	DPRINT("Enter\n");
+
+	err = interdsp_arm_poll_core(2, file, wait);
+
+	DPRINT("Exit [%d]\n", err);
+
+	return err;
+}
+
+unsigned int interdsp_dsp_poll_core(int ch,
+				    struct file *file, poll_table *wait)
+{
+	int ret = 0;
+	unsigned long flags;
+
+	DPRINT("Enter [ch=%d]\n", ch);
+
+	poll_wait(file, &dsp_ch_waitq[ch], wait);
+	poll_wait(file, &resreq_pending_waitq, wait);
+
+	if (dsp_ch_recv[ch])
+		ret |= POLLIN | POLLRDNORM;
+
+	spin_lock_irqsave(&resreq_pending_lock, flags);
+	if (!list_empty(&resreq_pending))
+		ret |= POLLIN | POLLRDNORM;
+	spin_unlock_irqrestore(&resreq_pending_lock, flags);
+
+	DPRINT("Exit [%d]\n", ret);
+
+	return ret;
+}
+EXPORT_SYMBOL(interdsp_dsp_poll_core);
+
+static unsigned int dsp_ch0_poll(struct file *file, poll_table *wait)
+{
+	int err;
+
+	DPRINT("Enter\n");
+
+	err = interdsp_dsp_poll_core(0, file, wait);
+
+	DPRINT("Exit [%d]\n", err);
+
+	return err;
+}
+
+static unsigned int dsp_ch1_poll(struct file *file, poll_table *wait)
+{
+	int err;
+
+	DPRINT("Enter\n");
+
+	err = interdsp_dsp_poll_core(1, file, wait);
+
+	DPRINT("Exit [%d]\n", err);
+
+	return err;
+}
+
+static unsigned int dsp_ch2_poll(struct file *file, poll_table *wait)
+{
+	int err;
+
+	DPRINT("Enter\n");
+
+	err = interdsp_dsp_poll_core(2, file, wait);
+
+	DPRINT("Exit [%d]\n", err);
+
+	return err;
+}
+
+/***********************************************************************
+ * Fsync  file operation
+ **********************************************************************/
+
+int interdsp_fsync(struct file *file, struct dentry *dentry, int datasync)
+{
+	int err = 0;
+	int ch;
+	wait_queue_t arm_wait[CH_NUM];
+	int active = 0;
+
+	DPRINT("Enter\n");
+
+	for (ch = 0; ch < CH_NUM; ch++) {
+		init_waitqueue_entry(&arm_wait[ch], current);
+		add_wait_queue(&arm_ch_waitq[ch], &arm_wait[ch]);
+	}
+
+	do {
+		set_current_state(TASK_INTERRUPTIBLE);
+
+		for (ch = 0; ch < CH_NUM; ch++) {
+			if (atomic_read(&arm_ch_sqcnt[ch])
+			    == INTERDSP_SQ_LEN) {
+				active = 1;
+				break;
+			}
+		}
+
+		if (active)
+			break;
+
+		if (signal_pending(current)) {
+			err = -ERESTARTSYS;
+			break;
+		}
+
+		schedule();
+	} while (1);
+
+	for (ch = 0; ch < CH_NUM; ch++)
+		remove_wait_queue(&arm_ch_waitq[ch], &arm_wait[ch]);
+
+	set_current_state(TASK_RUNNING);
+
+	DPRINT("Exit [%d]\n", err);
+
+	return err;
+}
+EXPORT_SYMBOL(interdsp_fsync);
+
+int interdsp_arm_fsync_core(int ch,
+			    struct file *file, struct dentry *dentry,
+			    int datasync)
+{
+	int err = 0;
+	DECLARE_WAITQUEUE(wait, current);
+
+	DPRINT("Enter [ch=%d]\n", ch);
+
+	add_wait_queue(&arm_ch_waitq[ch], &wait);
+	do {
+		set_current_state(TASK_INTERRUPTIBLE);
+
+		if (atomic_read(&arm_ch_sqcnt[ch]) == INTERDSP_SQ_LEN)
+			break;
+
+		if (signal_pending(current)) {
+			err = -ERESTARTSYS;
+			break;
+		}
+
+		schedule();
+	} while (1);
+	remove_wait_queue(&arm_ch_waitq[ch], &wait);
+
+	set_current_state(TASK_RUNNING);
+
+	DPRINT("Exit [%d]\n", err);
+
+	return err;
+}
+EXPORT_SYMBOL(interdsp_arm_fsync_core);
+
+static int arm_ch0_fsync(struct file *file,
+			 struct dentry *dentry, int datasync)
+{
+	int err;
+
+	DPRINT("Enter\n");
+
+	err = interdsp_arm_fsync_core(0, file, dentry, datasync);
+
+	DPRINT("Exit [%d]\n", err);
+
+	return err;
+}
+
+static int arm_ch1_fsync(struct file *file,
+			 struct dentry *dentry, int datasync)
+{
+	int err;
+
+	DPRINT("Enter\n");
+
+	err = interdsp_arm_fsync_core(1, file, dentry, datasync);
+
+	DPRINT("Exit [%d]\n", err);
+
+	return err;
+}
+
+static int arm_ch2_fsync(struct file *file,
+			 struct dentry *dentry, int datasync)
+{
+	int err;
+
+	DPRINT("Enter\n");
+
+	err = interdsp_arm_fsync_core(2, file, dentry, datasync);
+
+	DPRINT("Exit [%d]\n", err);
+
+	return err;
+}
+
+/***********************************************************************
+ * Fasync  file operation (asynchronous inform)
+ **********************************************************************/
+
+int interdsp_fasync(int fd, struct file *file, int mode)
+{
+	int err;
+
+	DPRINT("Enter\n");
+
+	err = fasync_helper(fd, file, mode, &interdsp_fasync_queue);
+
+	DPRINT("Exit [%d]\n", err);
+
+	return err;
+}
+EXPORT_SYMBOL(interdsp_fasync);
+
+int interdsp_dsp_fasync_core(int ch, int fd, struct file *file, int mode)
+{
+	int err;
+
+	DPRINT("Enter\n");
+
+	err = fasync_helper(fd, file, mode, &dsp_ch_fasync_queue[ch]);
+
+	DPRINT("Exit [%d]\n", err);
+
+	return err;
+}
+EXPORT_SYMBOL(interdsp_dsp_fasync_core);
+
+static int dsp_ch0_fasync(int fd, struct file *file, int mode)
+{
+	int err;
+
+	DPRINT("Enter\n");
+
+	err = interdsp_dsp_fasync_core(0, fd, file, mode);
+
+	DPRINT("Exit [%d]\n", err);
+
+	return err;
+}
+
+static int dsp_ch1_fasync(int fd, struct file *file, int mode)
+{
+	int err;
+
+	DPRINT("Enter\n");
+
+	err = interdsp_dsp_fasync_core(1, fd, file, mode);
+
+	DPRINT("Exit [%d]\n", err);
+
+	return err;
+}
+
+static int dsp_ch2_fasync(int fd, struct file *file, int mode)
+{
+	int err;
+
+	DPRINT("Enter\n");
+
+	err = interdsp_dsp_fasync_core(2, fd, file, mode);
+
+	DPRINT("Exit [%d]\n", err);
+
+	return err;
+}
+
+/***********************************************************************
+ *  character device
+ **********************************************************************/
+
+static int dspdev_open(struct inode *inode, struct file *file)
+{
+	int minor = MINOR(inode->i_rdev);
+	int err = -ENODEV;
+	int i;
+
+	DPRINT("Enter\n");
+
+	switch (minor) {
+	case DSPDEV_CONTROL_MINOR:
+		DPRINT("minor=DSPDEV_CONTROL_MINOR\n");
+		file->f_op = &control_fops;
+		break;
+	case DSPDEV_ARMCH0_MINOR:
+		DPRINT("minor=DSPDEV_ARMCH0_MINOR\n");
+		file->f_op = &arm_ch0_fops;
+		break;
+	case DSPDEV_ARMCH1_MINOR:
+		DPRINT("minor=DSPDEV_ARMCH1_MINOR\n");
+		file->f_op = &arm_ch1_fops;
+		break;
+	case DSPDEV_ARMCH2_MINOR:
+		DPRINT("minor=DSPDEV_ARMCH2_MINOR\n");
+		file->f_op = &arm_ch2_fops;
+		break;
+	case DSPDEV_DSPCH0_MINOR:
+		DPRINT("minor=DSPDEV_DSPCH0_MINOR\n");
+		file->f_op = &dsp_ch0_fops;
+		break;
+	case DSPDEV_DSPCH1_MINOR:
+		DPRINT("minor=DSPDEV_DSPCH1_MINOR\n");
+		file->f_op = &dsp_ch1_fops;
+		break;
+	case DSPDEV_DSPCH2_MINOR:
+		DPRINT("minor=DSPDEV_DSPCH2_MINOR\n");
+		file->f_op = &dsp_ch2_fops;
+		break;
+	default:
+		for (i = 0; i < INTERDSP_MINOR_SIZE; i++) {
+			if (minor_device_table[i].minor == minor) {
+				file->f_op = minor_device_table[i].fops;
+				goto try_open;
+			}
+		}
+
+		printk(KERN_INFO "interdsp: unknown minor device(%d)\n",
+		       minor);
+		goto end;
+	}
+
+try_open:
+	err = (*file->f_op->open) (inode, file);
+
+end:
+	DPRINT("Exit [err=%d]\n", err);
+
+	return err;
+}
+
+/* add minor device
+   NO PROCFS SUPPORT --- XXX */
+int interdsp_add_minor_device(int minor, char *name,
+			      struct file_operations *fops)
+{
+	int err = 0;
+	int i, n;
+	struct device *cd;
+
+	DPRINT("Enter [minor=%d,name=%s,fops=%p]\n", minor, name, fops);
+
+	spin_lock(&minor_device_table_lock);
+	if (minor == -1) {
+		for (n = 0; n < 255; n++) {
+			for (i = 0; i < INTERDSP_MINOR_SIZE; i++) {
+				if (n == minor_device_table[i].minor)
+					goto minor_used;
+			}
+			minor = n;
+			break;
+minor_used:;
+				/* continue searching minor number */
+		}
+
+		/* no free slot */
+		if (minor == -1) {
+			spin_unlock(&minor_device_table_lock);
+			err = -EBUSY;
+			goto end;
+		}
+	} else {
+		for (i = 0; i < INTERDSP_MINOR_SIZE; i++) {
+			if (minor == minor_device_table[i].minor) {
+				spin_unlock(&minor_device_table_lock);
+				err = -ENXIO;
+				goto end;
+			}
+		}
+	}
+	spin_unlock(&minor_device_table_lock);
+
+	cd = device_create(interdsp_class, interdsp_device,
+				 MKDEV(dspdev_major, minor),
+				 NULL,
+				 "%s", name);
+
+	err = IS_ERR(cd);
+	if (err == 0) {
+		spin_lock(&minor_device_table_lock);
+		for (i = 0; i < INTERDSP_MINOR_SIZE; i++) {
+			if (minor_device_table[i].minor == -1) {
+				minor_device_table[i].minor = minor;
+				minor_device_table[i].sticky = 0;
+				minor_device_table[i].fops = fops;
+				minor_device_table[i].cls_dev = cd;
+				DPRINT("minor=%d:minor_device_table[%d]\n",
+					minor, i);
+				err = minor;
+				break;
+			}
+		}
+		spin_unlock(&minor_device_table_lock);
+	}
+end:
+	DPRINT("Exit [err=%d]\n", err);
+	return err;
+}
+EXPORT_SYMBOL(interdsp_add_minor_device);
+
+/* remove minor device
+   NO PROCFS SUPPORT --- XXX */
+int interdsp_remove_minor_device(int minor, struct file_operations *fops)
+{
+	int err = 0;
+	int i;
+	int found = 0;
+	struct device *cd = 0;
+
+	DPRINT("Enter [minor=%d,fops=%p]\n", minor, fops);
+
+	spin_lock(&minor_device_table_lock);
+	for (i = 0; i < INTERDSP_MINOR_SIZE; i++) {
+		if (minor_device_table[i].minor == minor
+		    && minor_device_table[i].fops == fops
+		    && minor_device_table[i].sticky == 0) {
+			minor_device_table[i].minor = -1;
+			minor_device_table[i].fops = 0;
+			cd = minor_device_table[i].cls_dev;
+			minor_device_table[i].cls_dev = 0;
+			found = 1;
+			break;
+		}
+	}
+	spin_unlock(&minor_device_table_lock);
+
+	if (found)
+		device_destroy(interdsp_class, MKDEV(dspdev_major, minor));
+	else
+		err = -ENODEV;
+
+	DPRINT("Exit [err=%d]\n", err);
+	return err;
+}
+EXPORT_SYMBOL(interdsp_remove_minor_device);
+
+
+
+/***********************************************************************
+ * mmap file operation
+ **********************************************************************/
+
+#define INTERDSP_MMAP_START		INTERDSP_DL_TOP_ADDR
+#define INTERDSP_MMAP_END		INTERDSP_DL_BOTTOM_ADDR
+#define INTERDSP_MMAP_AREA_SIZE	((INTERDSP_MMAP_END+1)-INTERDSP_MMAP_START)
+
+int interdsp_mmap(struct file *info, struct vm_area_struct *vma)
+{
+	unsigned long start;
+	unsigned long off;
+	u32 len;
+
+	if (vma->vm_pgoff > (~0UL >> PAGE_SHIFT))
+		return -EINVAL;
+
+	off = vma->vm_pgoff << PAGE_SHIFT;
+	if (off < INTERDSP_MMAP_AREA_SIZE) {
+		start = (unsigned long)INTERDSP_MMAP_START;
+		len = PAGE_ALIGN((start & ~PAGE_MASK) +
+				INTERDSP_MMAP_AREA_SIZE);
+	} else {
+		return -EINVAL;
+	}
+
+	start &= PAGE_MASK;
+	if ((vma->vm_end - vma->vm_start + off) > len)
+		return -EINVAL;
+
+	off += start;
+	vma->vm_pgoff = off >> PAGE_SHIFT;
+
+	/* Accessing memory will be done non-cached. */
+	vma->vm_page_prot =
+		__pgprot(pgprot_val(vma->vm_page_prot) | L_PTE_BUFFERABLE);
+	vma->vm_page_prot =
+		__pgprot(pgprot_val(vma->vm_page_prot) & ~L_PTE_CACHEABLE);
+
+	/* To stop the swapper from even considering these pages */
+	vma->vm_flags |= (VM_IO | VM_RESERVED);
+
+	if (remap_pfn_range(vma, vma->vm_start, vma->vm_pgoff,
+			vma->vm_end - vma->vm_start, vma->vm_page_prot))
+		return -EAGAIN;
+
+	return 0;
+}
+EXPORT_SYMBOL(interdsp_mmap);
+
+
+
+/***********************************************************************
+ * from DSP interrupt handler
+ **********************************************************************/
+
+/* Res/Req  tasklet */
+static void dsp_req_handler(unsigned long ch)
+{
+	struct list_head *pos;
+	union interdsp_spa_header *hdr;
+	int num;
+	void *buf;
+	size_t size;
+	int status;
+
+	DPRINT("Enter [ch=%lu]\n", ch);
+
+	spin_lock(&req_chain_lock);
+	list_for_each(pos, &req_chain) {
+		struct req_chain *chain;
+		chain = list_entry(pos, struct req_chain, list);
+		if (chain->handler) {
+			hdr = dsp_header[ch];
+			num = hdr->spa_res.block_num;
+			buf = dsp_buffer[ch][num];
+			size = hdr->spa_res.length * sizeof(uint32_t);
+
+			status = (*chain->handler) (ch, hdr, buf, size);
+
+			if (status == 0) {
+				spin_unlock(&req_chain_lock);
+				DPRINT("[CH=%ld] snatch success\n", ch);
+				goto end;
+			}
+		}
+	}
+	spin_unlock(&req_chain_lock);
+
+	DPRINT("[CH=%ld] wakeup task\n", ch);
+
+	dsp_ch_recv[ch] = 1;
+
+	wake_up_interruptible(&dsp_ch_waitq[ch]);
+
+	if (dsp_ch_fasync_queue[ch])
+		kill_fasync(&dsp_ch_fasync_queue[ch], SIGIO, POLL_IN);
+
+	if (atomic_dec_and_test(&dsp_rcv_xcount)) {
+		if (interdsp_fasync_queue != 0)
+			kill_fasync(&interdsp_fasync_queue, SIGIO, POLL_IN);
+	}
+
+end:
+
+	DPRINT("Exit\n");
+}
+
+static irqreturn_t interdsp_interrupt(int irq, void *dev_id)
+{
+	int ch;
+	unsigned int ack;
+	unsigned int res;
+	unsigned int mon;
+	int run = 0;
+
+	DPRINT("Enter\n");
+
+	atomic_set(&dsp_rcv_xcount, 1);
+
+	ack = ACK_INT(0);
+	res = SEND_INT(0);
+
+	mon = __raw_readl(ipi_mon);
+
+	for (ch = 0; ch < CH_NUM; ch++) {
+		if (mon & ack) {
+
+			run = 0;
+			spin_lock(&arm_ch_sq_lock[ch]);
+			if (!list_empty(&arm_ch_sq[ch])) {
+				struct arm_queue_ent *sq;
+				sq = list_entry(arm_ch_sq[ch].next,
+						struct arm_queue_ent, list);
+				if (atomic_read(&sq->active))
+					run = 1;
+			}
+			spin_unlock(&arm_ch_sq_lock[ch]);
+			if (run) {
+				tasklet_enable(arm_ch_tasklet[ch]);
+				tasklet_schedule(arm_ch_tasklet[ch]);
+				DPRINT("DSP CH%d ACK scheduled\n", ch);
+			}
+#ifdef MP200_DSP_DEBUG
+			else
+				DPRINT("DSP CH%d ACK Ignore\n", ch);
+#endif
+			recv_ack_count[ch]++;
+		}
+		if (mon & res) {
+
+			if (INTERDSP_DRIVER_USE) {
+				DPRINT("DSP CH%d handled Res/Req\n", ch);
+				tasklet_schedule(dsp_ch_tasklet[ch]);
+			} else {
+				__raw_writel(ack, ipi_set);
+				send_ack_count[ch]++;
+
+				DPRINT("DSP CH%d ignore Res/Req\n", ch);
+			}
+			recv_resreq_count[ch]++;
+		}
+		ack <<= CH_INT_BITSHIFT;
+		res <<= CH_INT_BITSHIFT;
+	}
+
+	__raw_writel(mon, ipi_clr);
+
+	return IRQ_HANDLED;
+
+	DPRINT("Exit\n");
+}
+
+/***********************************************************************
+ * IOCTL  extension
+ **********************************************************************/
+
+int interdsp_push_ioctl(int (*ioctl_func) (struct inode *, struct file *,
+					   unsigned int, unsigned long,
+					   int *), int post)
+{
+	struct ioctl_chain *chain;
+	int err = 0;
+
+	DPRINT("Enter: ioctl=%p,post=%d\n", ioctl_func, post);
+
+	chain = kmalloc(sizeof *chain, GFP_KERNEL);
+	if (chain) {
+		chain->ioctl = ioctl_func;
+		if (post) {
+			spin_lock(&post_ioctl_lock);
+			list_add(&chain->list, &post_ioctl_chain);
+			spin_unlock(&post_ioctl_lock);
+		} else {
+			spin_lock(&pre_ioctl_lock);
+			list_add(&chain->list, &pre_ioctl_chain);
+			spin_unlock(&pre_ioctl_lock);
+		}
+	} else
+		err = -ENOMEM;
+
+	DPRINT("Exit [%d]\n", err);
+
+	return err;
+}
+EXPORT_SYMBOL(interdsp_push_ioctl);
+
+void interdsp_remove_ioctl(int (*ioctl_func) (struct inode *, struct file *,
+					      unsigned int, unsigned long,
+					      int *), int post)
+{
+	struct ioctl_chain *chain;
+	struct list_head *pos;
+
+	DPRINT("Enter: ioctl=%p\n", ioctl_func);
+
+	if (post) {
+		spin_lock(&post_ioctl_lock);
+		list_for_each(pos, &post_ioctl_chain) {
+			chain = list_entry(pos, struct ioctl_chain, list);
+			if (chain->ioctl == ioctl_func) {
+				list_del(&chain->list);
+				spin_unlock(&post_ioctl_lock);
+				kfree(chain);
+				goto end;
+			}
+		}
+		spin_unlock(&post_ioctl_lock);
+	} else {
+		spin_lock(&pre_ioctl_lock);
+		list_for_each(pos, &pre_ioctl_chain) {
+			chain = list_entry(pos, struct ioctl_chain, list);
+			if (chain->ioctl == ioctl_func) {
+				list_del(&chain->list);
+				spin_unlock(&pre_ioctl_lock);
+				kfree(chain);
+				goto end;
+			}
+		}
+		spin_unlock(&pre_ioctl_lock);
+	}
+
+	chain = 0;
+end:
+	DPRINT("Exit: %s\n", chain ? "Free" : "Not found");
+}
+EXPORT_SYMBOL(interdsp_remove_ioctl);
+
+static void remove_all_ioctl_chain(void)
+{
+	struct ioctl_chain *chain;
+	struct list_head *pos, *n;
+
+	DPRINT("Enter\n");
+
+	spin_lock(&pre_ioctl_lock);
+	list_for_each_safe(pos, n, &pre_ioctl_chain) {
+		chain = list_entry(pos, struct ioctl_chain, list);
+		list_del(&chain->list);
+		kfree(chain);
+	}
+	spin_unlock(&pre_ioctl_lock);
+
+	spin_lock(&post_ioctl_lock);
+	list_for_each_safe(pos, n, &post_ioctl_chain) {
+		chain = list_entry(pos, struct ioctl_chain, list);
+		list_del(&chain->list);
+		kfree(chain);
+	}
+	spin_unlock(&post_ioctl_lock);
+
+	DPRINT("Exit\n");
+}
+
+/***********************************************************************
+ * Res/Req  snatch
+ **********************************************************************/
+
+int interdsp_push_req_handler(int (*handler) (int,
+					      union interdsp_spa_header *,
+					      void *, size_t))
+{
+	struct req_chain *chain;
+	int err = 0;
+
+	DPRINT("Enter: handler=%p\n", handler);
+
+	chain = kmalloc(sizeof *chain, GFP_KERNEL);
+	if (chain) {
+		chain->handler = handler;
+		spin_lock(&req_chain_lock);
+		list_add(&chain->list, &req_chain);
+		spin_unlock(&req_chain_lock);
+	} else
+		err = -ENOMEM;
+
+	DPRINT("Exit [%d]\n", err);
+
+	return err;
+}
+EXPORT_SYMBOL(interdsp_push_req_handler);
+
+void interdsp_remove_req_handler(int (*handler) (int,
+						 union interdsp_spa_header *,
+						 void *, size_t))
+{
+	struct req_chain *chain;
+	struct list_head *pos;
+
+	DPRINT("Enter: handler=%p\n", handler);
+
+	chain = 0;
+	spin_lock(&req_chain_lock);
+	list_for_each(pos, &req_chain) {
+		chain = list_entry(pos, struct req_chain, list);
+		if (chain->handler == handler) {
+			list_del(&chain->list);
+			spin_unlock(&req_chain_lock);
+			kfree(chain);
+			goto end;
+		}
+	}
+	spin_unlock(&req_chain_lock);
+	chain = 0;
+
+end:
+	DPRINT("Exit: %s\n", chain ? "Free" : "Not found");
+}
+EXPORT_SYMBOL(interdsp_remove_req_handler);
+
+static void remove_all_req_chain(void)
+{
+	struct req_chain *chain;
+	struct list_head *pos, *n;
+
+	spin_lock(&req_chain_lock);
+	list_for_each_safe(pos, n, &req_chain) {
+		chain = list_entry(pos, struct req_chain, list);
+		list_del(&chain->list);
+		kfree(chain);
+	}
+	spin_unlock(&req_chain_lock);
+}
+
+/***********************************************************************
+ * release  inform
+ **********************************************************************/
+
+int interdsp_push_release_notify(void (*notify) (struct inode *,
+						 struct file *))
+{
+	struct notify_chain *chain;
+	int err = 0;
+
+	DPRINT("Enter: notify=%p\n", notify);
+
+	chain = kmalloc(sizeof *chain, GFP_KERNEL);
+	if (chain) {
+		chain->notify = notify;
+		spin_lock(&release_chain_lock);
+		list_add(&chain->list, &release_chain);
+		spin_unlock(&release_chain_lock);
+	} else
+		err = -ENOMEM;
+
+	DPRINT("Exit [%d]\n", err);
+
+	return err;
+}
+EXPORT_SYMBOL(interdsp_push_release_notify);
+
+void interdsp_remove_release_notify(void (*notify) (struct inode *,
+						    struct file *))
+{
+	struct notify_chain *chain;
+	struct list_head *pos;
+
+	DPRINT("Enter: notify=%p\n", notify);
+
+	chain = 0;
+	spin_lock(&release_chain_lock);
+	list_for_each(pos, &release_chain) {
+		chain = list_entry(pos, struct notify_chain, list);
+		if (chain->notify == notify) {
+			list_del(&chain->list);
+			spin_unlock(&release_chain_lock);
+			kfree(chain);
+			goto end;
+		}
+	}
+	spin_unlock(&release_chain_lock);
+	chain = 0;
+
+end:
+	DPRINT("Exit: %s\n", chain ? "Free" : "Not found");
+}
+EXPORT_SYMBOL(interdsp_remove_release_notify);
+
+/***********************************************************************
+ *  error bit set, clear, test and reset processing function
+ **********************************************************************/
+
+void interdsp_set_armch_errorbit(int bitnr)
+{
+	set_bit(bitnr, &arm_ch_error);
+}
+EXPORT_SYMBOL(interdsp_set_armch_errorbit);
+
+void interdsp_clear_armch_errorbit(int bitnr)
+{
+	clear_bit(bitnr, &arm_ch_error);
+}
+EXPORT_SYMBOL(interdsp_clear_armch_errorbit);
+
+int interdsp_test_and_clear_armch_errorbit(int bitnr)
+{
+	return test_and_clear_bit(bitnr, &arm_ch_error);
+}
+EXPORT_SYMBOL(interdsp_test_and_clear_armch_errorbit);
+
+void interdsp_set_dspch_errorbit(int bitnr)
+{
+	set_bit(bitnr, &dsp_ch_error);
+}
+EXPORT_SYMBOL(interdsp_set_dspch_errorbit);
+
+void interdsp_clear_dspch_errorbit(int bitnr)
+{
+	clear_bit(bitnr, &dsp_ch_error);
+}
+EXPORT_SYMBOL(interdsp_clear_dspch_errorbit);
+
+int interdsp_test_and_clear_dspch_errorbit(int bitnr)
+{
+	return test_and_clear_bit(bitnr, &dsp_ch_error);
+}
+EXPORT_SYMBOL(interdsp_test_and_clear_dspch_errorbit);
+
+/***********************************************************************
+ * AC1/Mobilinux DPM
+ **********************************************************************/
+#ifdef CONFIG_PM
+
+static int interdsp_suspend_handler(int ch,
+			union interdsp_spa_header *hdr, void *buf, size_t size)
+{
+	DPRINT("Enter [ch=%d]\n", ch);
+
+	if (hdr->header[0] == SUSPEND_RES_INFO
+	      && hdr->header[1] == SUSPEND_RES_LEN) {
+		if (*(uint32_t *)buf == SUSPEND_RES_DATA) {
+			suspend_response = 1;
+
+			interdsp_remove_req_handler(interdsp_suspend_handler);
+		}
+	}
+
+	interdsp_send_ack(ch);
+
+	DPRINT("Exit\n");
+
+	return 0;
+}
+
+static int interdsp_resume_handler(int ch,
+			union interdsp_spa_header *hdr, void *buf, size_t size)
+{
+	DPRINT("Enter [ch=%d]\n", ch);
+
+	if (hdr->header[0] == RESUME_RES_INFO
+	      && hdr->header[1] == RESUME_RES_LEN) {
+		if (*(uint32_t *)buf == RESUME_RES_DATA) {
+			resume_response = 1;
+
+			interdsp_remove_req_handler(interdsp_resume_handler);
+		}
+	}
+
+	interdsp_send_ack(ch);
+
+	DPRINT("Exit\n");
+
+	return 0;
+}
+
+static int interdsp_suspend(struct platform_device *dev, pm_message_t state)
+{
+	int err = 0;
+	int i;
+	int n;
+#if 0
+	struct arm_queue_ent *sq = 0;
+	struct dsp_cmd_rw rwcmd;
+	union interdsp_spa_header cmdhdr;
+	int taskid;
+	int ch;
+	int num;
+	int bsize;
+	uint32_t spa_data = SUSPEND_REQ_DATA;
+	unsigned long flags;
+#endif
+	DPRINT("Enter [state=%d]\n", state.event);
+
+	switch (state.event) {
+	case PM_EVENT_SUSPEND:
+	case DEV_SUSPEND_IDLE_1:
+		n = 0;
+		for (i = 0; i < ARRAY_SIZE(dsp_ch_privates); i++) {
+			if (dsp_ch_privates[i]->opend) {
+				n = 1;
+				break;
+			}
+		}
+		if (n) {
+			if (__raw_readl(RESETCTRL0) & DSP_IRES_CLR) {
+			#if 1
+				err = -EBUSY;
+				goto error_exit;
+			#else
+				cmdhdr.header[0] = SUSPEND_REQ_INFO;
+				cmdhdr.header[1] = SUSPEND_REQ_LEN;
+
+				taskid = cmdhdr.spa_ccf.taskid;
+
+				ch = interdsp_get_taskid_channel(taskid);
+				if (ch < 0 || ch == CH_INVALID)
+					ch = 0;
+
+				local_save_flags(flags);
+				local_irq_enable();
+				do {
+					if (atomic_read(&arm_ch_sqcnt[ch])
+						== INTERDSP_SQ_LEN)
+						break;
+				} while (1);
+				local_irq_restore(flags);
+
+				num = cmdhdr.spa_ccf.block_num;
+				rwcmd.fdata[0] = cmdhdr.header[0];
+				rwcmd.fdata[1] = cmdhdr.header[1];
+				bsize = cmdhdr.spa_ccf.length *
+						sizeof(uint32_t);
+
+				err = interdsp_new_sq_entry(&sq, ch, num,
+						0, &rwcmd, 0, 0);
+				if (err)
+					goto error_exit;
+
+				err = interdsp_prepare_send_sq_entry(sq, 1);
+				if (err) {
+					interdsp_free_sq_entry(sq);
+					goto error_exit;
+				}
+
+				err = interdsp_arm_write_buffer_internal(
+					ch, num, 0, &spa_data, bsize);
+				if (err) {
+					interdsp_put_sq_entry(sq);
+					goto error_exit;
+				}
+
+				err = interdsp_push_req_handler(
+						interdsp_suspend_handler);
+				if (err) {
+					interdsp_put_sq_entry(sq);
+					goto error_exit;
+				}
+
+				interdsp_send_sq_entry(sq);
+
+				local_save_flags(flags);
+				local_irq_enable();
+				do {
+					if (suspend_response) {
+						suspend_response = 0;
+						break;
+					}
+				} while (1);
+				local_irq_restore(flags);
+
+				udelay(1);
+
+				dsp_ires(1);
+				dsp_sres(1);
+				dsp_ares(1);
+
+				dsp_suspend = 1;
+			#endif
+			}
+		}
+
+		for (i = 0; i < 16; i++) {
+			dcv_reg_state[i].bank_no = i;
+			dcv_get_bank_info(&dcv_reg_state[i]);
+		}
+		dcv_store = 1;
+
+		break;
+
+	default:
+		break;
+	}
+
+error_exit:
+
+	DPRINT("Exit [err=%d]\n", err);
+
+	return err;
+}
+
+static int interdsp_resume(struct platform_device *dev)
+{
+	int err = 0;
+	int i;
+	unsigned long flags;
+
+	DPRINT("Enter\n");
+
+	if (dcv_store == 1) {
+		for (i = 0; i < 16; i++)
+			dcv_set_bank_info(&dcv_reg_state[i]);
+
+		dcv_store = 0;
+	}
+
+	if (dsp_suspend) {
+		err = interdsp_push_req_handler(interdsp_resume_handler);
+		if (err)
+			goto error_exit;
+
+		dsp_clock_gate(1);
+
+		dsp_ares(0);
+		dsp_sres(0);
+		dsp_ires(0);
+
+		local_save_flags(flags);
+		local_irq_enable();
+		do {
+			if (resume_response) {
+				resume_response = 0;
+				break;
+			}
+		} while (1);
+		local_irq_restore(flags);
+
+		dsp_suspend = 0;
+	}
+
+error_exit:
+
+	DPRINT("Exit [err=%d]\n", err);
+
+	return err;
+}
+
+#endif	/* CONFIG_PM */
+
+
+#if DCV_PROC_FS == 1
+static int driver_dcv_read_proc(char *page,
+				char **start, off_t offset, int count,
+				int *eof, void *data)
+{
+	int i, len = 0;
+
+	for (i = 0; i < 16; i++)
+		len += sprintf(page + len, "%04X BANK%d_OFFSET%s = 0x%03x\n",
+			       i << 2,
+			       i,
+			       i > 9 ? "" : " ",
+			       *(uint32_t *) (DCV_BANKn_OFFSET(dcv_va, i)));
+	for (i = 0; i < 16; i++)
+		len += sprintf(page + len, "%04X BANK%d_SET%s    = 0x%x\n",
+			       (i + 16) << 2,
+			       i,
+			       i > 9 ? "" : " ",
+			       *(uint32_t *) (DCV_BANKn_SET(dcv_va, i)));
+
+	*eof = 1;
+
+	return len;
+}
+#endif
+
+/***********************************************************************
+ *  initialize
+ **********************************************************************/
+
+static int __init interdsp_probe(struct platform_device *dev)
+{
+	interdsp_device = &dev->dev;
+
+	return 0;
+}
+
+static int __init interdsp_init(void)
+{
+	int ch;
+	int i;
+	int error = 0;
+	hdr_queue_area *quehdr;
+#if DCV_PROC_FS
+	struct proc_dir_entry *dcv_ent = 0;
+#endif
+	dev_t devno;
+	int cdev_state = 0;
+	unsigned long flags;
+	unsigned int val;
+
+	DPRINT("Enter\n");
+
+	for (i = 0; i < INTERDSP_MINOR_SIZE; i++) {
+		minor_device_table[i].minor = -1;
+		minor_device_table[i].fops = 0;
+		minor_device_table[i].sticky = 0;
+		minor_device_table[i].cls_dev = 0;
+	}
+
+	if (dspdev_major == 0) {
+		error = alloc_chrdev_region(&devno,
+					    0, DSP_MINOR_MAX,
+					    "mp200_dsp");
+	} else {
+		devno = MKDEV(dspdev_major, 0);
+		error = register_chrdev_region(devno, DSP_MINOR_MAX,
+					       "mp200_dsp");
+	}
+	if (error) {
+		printk(KERN_ERR
+		       "interdsp: Can't allocate chrdev=%d, "
+		       "error=%d\n", dspdev_major, error);
+		goto error_exit;
+	}
+	if (dspdev_major == 0)
+		dspdev_major = MAJOR(devno);
+
+	cdev_init(&dspdev_cdev, &dspdev_fops);
+	error = cdev_add(&dspdev_cdev, devno, DSP_MINOR_MAX);
+	if (error)
+		goto unregist_chrdev;
+
+	cdev_state = 1;
+
+	interdsp_class = class_create(THIS_MODULE, "mp200_dsp");
+	if (IS_ERR(interdsp_class)) {
+		printk(KERN_ERR "Error creating dsp class.\n");
+		interdsp_class = 0;
+		goto unregist_chrdev;
+	}
+
+	cdev_state = 2;
+
+	platform_driver_register(&interdsp_driver);
+
+	cdev_state = 3;
+
+	for (i = 0; i < ARRAY_SIZE(dsp_procfs); i++) {
+		int devno = MKDEV(dspdev_major, dsp_procfs[i].minor);
+		struct device *cd;
+		cd = device_create(interdsp_class, interdsp_device,
+				devno, NULL, "%s", dsp_procfs[i].name);
+
+		error = IS_ERR(cd);
+		if (error) {
+			goto unregist_chrdev;
+		} else {
+			minor_device_table[i].cls_dev = cd;
+			minor_device_table[i].minor = dsp_procfs[i].minor;
+			minor_device_table[i].fops = dsp_procfs[i].fops;
+			minor_device_table[i].sticky = 1;
+		}
+	}
+
+	ipi_mon = IT3_IPI0_MON;
+	ipi_clr = IT3_IPI0_CLR;
+	ipi_set = IT0_IPI3_SET;
+
+#if DCV_PROC_FS
+#if USE_DCV != 0 && DCV_NEED_MAP != 0
+	(void)dcv_remap();
+#endif
+
+	dcv_ent = create_proc_read_entry("dcv", 0, driver_statistics_dir,
+					 driver_dcv_read_proc, 0);
+	if (dcv_ent == 0) {
+		error = -ENOENT;
+		goto remove_dsp_proc_entry;
+	}
+#endif
+
+	/*  send queue initialize */
+	INIT_LIST_HEAD(&free_sq);
+	for (i = 0; i < INTERDSP_SQ_LEN * CH_NUM; i++) {
+		init_sq_entry(&arm_send_entry[i]);
+		list_add_tail(&arm_send_entry[i].list, &free_sq);
+	}
+
+	for (i = 0; i < RESREQ_PEND_SIZE; i++)
+		list_add_tail(&resreq_pend_ent[i].list, &resreq_freelist);
+
+	/* shard memory initialize */
+	shared_base = ioremap_nocache(shared_mem_address, shared_mem_size);
+	if (shared_base == 0) {
+		error = -ENOMEM;
+		goto remove_dsp_proc_entry;
+	}
+
+	quehdr = PE_HEADER_AREA(mp200_pe_number);
+	my_peinfo = PEINFO_ADDR(mp200_pe_number);
+	drv_mngaddr = DRIVER_MNG_ADDR;
+	mem_alloc_table = MAT_ADDR;
+
+	DPRINT("quehdr = 0x%08lx\n", (unsigned long)quehdr);
+	DPRINT("shared_base = 0x%08lx\n", (unsigned long)shared_base);
+	DPRINT("my_peinfo = 0x%08lx\n", (unsigned long)my_peinfo);
+	DPRINT("drv_mngaddr = 0x%08lx\n", (unsigned long)drv_mngaddr);
+	DPRINT("mem_alloc_table = 0x%08lx\n", (unsigned long)mem_alloc_table);
+
+	/* PE  information initialize */
+	DBG_MEMSET(my_peinfo, 0, INTERDSP_PE_INDEX_OFFSET);
+	DBG_MEMSET(&cache_info, 0, INTERDSP_PE_INDEX_OFFSET);
+
+	/*  error initialize */
+	arm_ch_error = 0;
+	dsp_ch_error = 0;
+
+
+	/*  channel initialize */
+	for (ch = 0; ch < CH_NUM; ch++) {
+		int blk;
+		INIT_LIST_HEAD(&arm_ch_sq[ch]);
+		arm_ch_sq_lock[ch] = arm_ch_sq_lock_unlock;
+		sema_init(&arm_ch_sqsem[ch], INTERDSP_SQ_LEN);
+		for (blk = 0; blk < BUF_BLOCK_MAX; blk++)
+			sema_init(&arm_ch_block[ch][blk], 1);
+
+		arm_ch_block_lock_bitmap[ch] = 0;
+		init_waitqueue_head(&arm_ch_waitq[ch]);
+		init_waitqueue_head(&dsp_ch_waitq[ch]);
+		dsp_ch_recv[ch] = 0;
+
+		arm_header[ch] = &(*quehdr)[0][ch];
+		dsp_header[ch] = &(*quehdr)[1][ch];
+	}
+
+	DPRINT("Channel Setup End\n");
+
+	error = request_irq(INT_DSP,
+			    interdsp_interrupt, IRQF_DISABLED,
+			    "interdsp", (void *)0);
+	if (error) {
+		DPRINT("Error: request_irq() = %d\n", error);
+		goto unmap_io;
+	}
+
+	DPRINT("IRQ Setup End\n");
+
+	/* This is unsafe. */
+	if (NEED_SHMEM_INIT()
+	    || xchg(&drv_mngaddr->magic, DRIVER_MAGIC) != DRIVER_MAGIC) {
+		error = interdsp_shmem_init();
+		if (error)
+			goto deep_error_exit;
+	} else {
+		global_spin_lock();
+
+		block_factor = drv_mngaddr->block_factor;
+		mat_blocks = drv_mngaddr->nblocks;
+
+		global_spin_unlock();
+	}
+
+	sdram_dl_range[0].start = shared_mem_address;
+	sdram_dl_range[0].end = shared_mem_address + shared_mem_size;
+	sdram_dl_range[0].valid = 0;	/* invalid */
+
+	/*
+	 * DSP Power off
+	 */
+
+	local_irq_save(flags);
+#if 1
+	/* TI3 setup */
+	val = __raw_readl(SMU_TI3TIN_SEL);
+	if (val == 0) {
+		/* TW3/TI3 is RTC */
+		__raw_writel(0x00010001, SMU_TI3TIN_SEL);
+	}
+
+	__raw_writel(0x00000003, TIMER_TI3_SET);
+
+#endif
+
+	val = __raw_readl(SMU_POWERSW_ACTRL_EN);
+	val &= ~DSP_PWR_CNT_EN;
+	__raw_writel(val, SMU_POWERSW_ACTRL_EN);
+	val &= ~ADSPSW_ACTRL_EN;
+	__raw_writel(val, SMU_POWERSW_ACTRL_EN);
+
+	__raw_writel(DEFAULT_DSP_PWR_WAIT_PARM << DSP_PWR_WAIT_PARAM_SHIFT,
+		     SMU_ADSPSW_ACTRL);
+
+	__raw_writel(__raw_readl(SMU_POWERSW_ENA)|ADSP_POWERSW_ENA,
+		     SMU_POWERSW_ENA);
+
+	val = __raw_readl(SMU_POWERSW_ACTRL_EN);
+	val |= ADSPSW_ACTRL_EN;
+	__raw_writel(val, SMU_POWERSW_ACTRL_EN);
+	val |= DSP_PWR_CNT_EN;
+	__raw_writel(val, SMU_POWERSW_ACTRL_EN);
+
+	local_irq_restore(flags);
+
+	udelay(WAIT_DSP_PWR_STATUS);
+
+	DPRINT("EXIT: Success\n");
+
+	return 0;
+
+deep_error_exit:
+	free_irq(INT_DSP, (void *)0);
+
+unmap_io:
+	iounmap(shared_base);
+
+remove_dsp_proc_entry:
+
+unregist_chrdev:__attribute__ ((unused))
+
+
+	if (cdev_state >= 3) {
+		for (i = 0; i < ARRAY_SIZE(dsp_procfs); i++) {
+			if (minor_device_table[i].cls_dev)
+				device_destroy(interdsp_class,
+					MKDEV(dspdev_major,
+					dsp_procfs[i].minor));
+		}
+	}
+	if (cdev_state >= 2)
+		platform_driver_unregister(&interdsp_driver);
+
+	if (interdsp_class) {
+		class_destroy(interdsp_class);
+		interdsp_class = 0;
+	}
+	if (cdev_state >= 1)
+		cdev_del(&dspdev_cdev);
+
+	unregister_chrdev_region(MKDEV(dspdev_major, 0), DSP_MINOR_MAX);
+
+error_exit:
+	if (error)
+		DPRINT("EXIT: Error = %d\n", error);
+
+	DPRINT("Exit\n");
+
+	return error;
+}
+
+/***********************************************************************
+ * exit processing
+ **********************************************************************/
+
+static void __exit interdsp_exit(void)
+{
+	int i;
+	int ch;
+	struct arm_queue_ent *sq;
+
+	DPRINT("Enter\n");
+
+	free_irq(INT_DSP, (void *)0);
+
+#if DCV_PROC_FS
+	if (driver_statistics_dir)
+		remove_proc_entry("dcv", driver_statistics_dir);
+#endif
+
+	for (i = 0; i < INTERDSP_MINOR_SIZE; i++) {
+		if (minor_device_table[i].minor != -1
+		    && minor_device_table[i].fops != 0
+		    && minor_device_table[i].sticky == 0
+		    && minor_device_table[i].cls_dev != 0
+			) {
+			device_destroy(interdsp_class, MKDEV(dspdev_major,
+					dsp_procfs[i].minor));
+			minor_device_table[i].minor = -1;
+			minor_device_table[i].fops = 0;
+		}
+	}
+
+	for (i = 0; i < ARRAY_SIZE(dsp_procfs); i++) {
+		device_destroy(interdsp_class, MKDEV(dspdev_major,
+				dsp_procfs[i].minor));
+		minor_device_table[i].cls_dev = 0;
+
+	}
+
+	platform_driver_unregister(&interdsp_driver);
+
+	class_destroy(interdsp_class);
+
+	cdev_del(&dspdev_cdev);
+
+	unregister_chrdev_region(MKDEV(dspdev_major, 0), DSP_MINOR_MAX);
+
+
+	/*  tasklet stop */
+	for (ch = 0; ch < CH_NUM; ch++)
+		tasklet_disable(arm_ch_tasklet[ch]);
+
+	for (ch = 0; ch < CH_NUM; ch++) {
+		sq = get_sendq_top(ch);
+		if (sq == 0)
+			continue;
+		if (atomic_read(&sq->active))
+			del_timer_sync(&sq->timeout_timer);
+	}
+
+	remove_all_ioctl_chain();
+
+	remove_all_req_chain();
+
+	for (ch = 0; ch < CH_NUM; ch++) {
+		free_chinfo(0, ch);	/* ARM */
+		free_chinfo(1, ch);	/* DSP */
+	}
+
+	DBG_MEMSET(my_peinfo, 0, INTERDSP_PE_INDEX_OFFSET);
+
+	/* unmap */
+	iounmap(shared_base);
+
+#if USE_DCV != 0 && DCV_NEED_MAP != 0
+	dcv_unmap();
+#endif
+
+	DPRINT("Exit\n");
+}
+
+/***********************************************************************
+ * modeule set
+ **********************************************************************/
+module_init(interdsp_init);
+module_exit(interdsp_exit);
+
+/* shard memory base address(physical address) */
+MODULE_PARM_DESC(shared_mem_address, "shared memory base address"
+		 " [default " __stringify(SHARED_MEM_ADDRESS) "]");
+module_param(shared_mem_address, ulong, 0444);
+
+/* shard memory size */
+MODULE_PARM_DESC(shared_mem_size, "shared memory size[Byte]"
+		 " [default " __stringify(SHARED_MEM_SIZE) "]");
+module_param(shared_mem_size, ulong, 0444);
+
+/* ACK timeout set(milli sec) */
+module_param(ack_timeout, ulong, 0444);
+MODULE_PARM_DESC(ack_timeout, "ACK Timeout[ms]"
+		 " [default " __stringify(INTERDSP_ACK_TIMEOUT) "ms]");
+
+module_param(force_init, uint, 0444);
+MODULE_PARM_DESC(force_init, "Force initialize"
+		 " [default " __stringify(FORCE_INIT) "]");
+
+MODULE_PARM_DESC(force_dma_download, "Force use DMA Download"
+		 " [default " __stringify(FORCE_DMA_DOWNLOAD) "]");
+module_param(force_dma_download, uint, 0444);
+MODULE_PARM_DESC(dspdev_major, "InterDSP driver major number"
+		 " [default " __stringify(DSPDEV_MAJOR) "]");
+module_param(dspdev_major, uint, 0444);
+
+
+
+MODULE_DESCRIPTION("MP200 SPXK6 DSP Driver");
+MODULE_LICENSE("GPL");
diff --git a/arch/arm/mach-mp200/inter_dsp.h b/arch/arm/mach-mp200/inter_dsp.h
new file mode 100644
index 0000000..26eb075
--- /dev/null
+++ b/arch/arm/mach-mp200/inter_dsp.h
@@ -0,0 +1,271 @@
+/* -*- mode: c; c-basic-offset: 8; comment-column: 40; -*- */
+
+/*
+ * InterDSP Driver
+ *
+ * Copyright (C) NEC Electronics Corporation 2004,2005,2006
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ */
+
+#ifndef INTER_DSP_H
+#define INTER_DSP_H
+
+#include <mach/inter_dsp_ioctl.h>
+
+#define INTERDSP_CH_NUM		3	/* Channel num */
+
+/* Channel invalid mark.
+   (INTERDSP_CH_INVALID > INTERDSP_CH_NUM) && (INTERDSP_CH_INVALID > 0) */
+#define INTERDSP_CH_INVALID	(INTERDSP_CH_NUM+1)
+
+/* SPA/SPX command format */
+union interdsp_spa_header {
+	uint32_t header[2];	/* Accessor */
+
+	/* Control Command Format */
+	struct {
+		unsigned issue:8;
+		unsigned taskid:4;
+		unsigned reserve1:2;
+		unsigned buffer:2; /* 00 */
+		unsigned reserve2:13;
+		unsigned buffer_no:3;	/* 000 */
+		unsigned length:16;
+		unsigned block_num:16;
+	} spa_ccf;
+
+	/* Transfer Command Format */
+	struct {
+		unsigned issue:8;
+		unsigned taskid:4;
+		unsigned reserve1:2;
+		unsigned buffer:2; /* 1x */
+		unsigned reserve2:13;
+		unsigned buffer_no:3;
+		unsigned length:16;
+		unsigned block_num:16;
+	} spa_tcf;
+
+	/* Response Format */
+	struct {
+		unsigned issue:8;
+		unsigned taskid:4;
+		unsigned reserve1:2;
+		unsigned eor:1;
+		unsigned rrf:1;	/* 0 */
+		unsigned code:15;
+		unsigned error:1;
+		unsigned length:16;
+		unsigned block_num:16;
+	} spa_res;
+
+	/* Request Format */
+	struct {
+		unsigned reserve:8;
+		unsigned taskid:4;
+		unsigned reserve1:3;
+		unsigned rrf:1;	/* 1 */
+		unsigned code:16;
+		unsigned length:16;
+		unsigned block_num:16;
+	} spa_req;
+
+	/* SPA Command Format */
+	struct {
+		unsigned issue:8;
+		unsigned taskid:4; /* 0 */
+		unsigned reserve1:4;
+		unsigned code:8;
+		unsigned reserve2:8;
+		unsigned length:16;
+		unsigned block_num:16;
+	} spa_cmd;
+};
+
+/* tag */
+struct arm_queue_ent;
+struct list_head;
+struct interdsp_pending_resreq;
+struct file_operations;
+
+int interdsp_read(int file_ch, int nonblock, struct dsp_cmd_rw *rwcmd,
+		   int (*read_callback)(int, int, size_t, void *buf, size_t));
+
+int interdsp_writebuf(int ch, int num, int nonblock,
+		       struct dsp_cmd_rw *rwcmd, size_t size);
+
+int interdsp_wait_ack(int ch, struct arm_queue_ent *sq);
+
+int interdsp_sendhdr(int ch, int num, int nonblock, int ack_sync,
+		      struct dsp_cmd_rw *rwcmd);
+
+int interdsp_get_taskid_channel(uint32_t taskid);
+int interdsp_set_taskid_channel(uint32_t taskid, uint32_t ch);
+
+int interdsp_get_chinfo(int ind, int ch, struct interdsp_chinfo *chinfo);
+int interdsp_set_chinfo(int ind, int ch, struct interdsp_chinfo *chinfo);
+
+int interdsp_checkch(struct dsp_cmd_ch_status *cmd);
+int interdsp_waitch(struct dsp_cmd_ch_status *cmd);
+
+int interdsp_download(struct dsp_cmd_download *dl);
+
+void interdsp_send_ack(int ch);
+
+/*
+ * ARM channel buffer
+ */
+
+int interdsp_arm_write_buffer(int ch, int num, size_t offset,
+			       const void *ubuf, size_t sz);
+int interdsp_arm_write_buffer_internal(int ch, int num, size_t offset,
+					const void *kbuf, size_t sz);
+int interdsp_arm_read_buffer_internal(int ch, int num, size_t offset,
+				       void *kbuf, size_t sz);
+
+/*
+ * DSP channel buffer
+ */
+int interdsp_dsp_read_buffer(int ch, int num, size_t offset,
+			      void *ubuf, size_t sz);
+
+int interdsp_dsp_read_buffer_internal(int ch, int num, size_t offset,
+				       void *kbuf, size_t sz);
+
+/*
+ * fs operations
+ */
+
+int interdsp_ioctl(struct inode *inode, struct file *file,
+		    unsigned int cmd, unsigned long arg);
+
+int interdsp_open_core(struct inode *inode, struct file *file);
+
+int interdsp_release(struct inode *inode, struct file *file);
+
+int interdsp_release_core(struct inode *inode, struct file *file);
+
+int interdsp_dsp_release_core(int ch, struct inode *inode, struct file *file);
+
+unsigned int interdsp_poll(struct file *file, poll_table *wait);
+unsigned int interdsp_arm_poll_core(int ch,
+				     struct file *file, poll_table *wait);
+unsigned int interdsp_dsp_poll_core(int ch,
+				     struct file *file, poll_table *wait);
+
+int interdsp_fsync(struct file *file, struct dentry *dentry, int datasync);
+int interdsp_arm_fsync_core(int ch, struct file *file, struct dentry *dentry,
+			     int datasync);
+
+int interdsp_fasync(int fd, struct file *file, int mode);
+int interdsp_dsp_fasync_core(int ch, int fd, struct file *file, int mode);
+
+int interdsp_mmap(struct file *info, struct vm_area_struct *vma);
+/*
+ * extend ioctl
+ */
+
+int interdsp_push_ioctl(int (*) (struct inode *, struct file *,
+				  unsigned int, unsigned long, int *),
+			 int post);
+void interdsp_remove_ioctl(int (*) (struct inode *, struct file *,
+				     unsigned int, unsigned long, int *),
+			    int post);
+
+
+/*
+ * set/clear error bit
+ */
+void interdsp_set_armch_errorbit(int bitnr);
+void interdsp_clear_armch_errorbit(int bitnr);
+int interdsp_test_and_clear_armch_errorbit(int bitnr);
+void interdsp_set_dspch_errorbit(int bitnr);
+void interdsp_clear_dspch_errorbit(int bitnr);
+int interdsp_test_and_clear_dspch_errorbit(int bitnr);
+
+/*
+ * entry of send queue
+ */
+
+/* block lock/unlock */
+int interdsp_lock_block_sq_entry(struct arm_queue_ent *sq, int nonblock);
+void interdsp_unlock_block_sq_entry(struct arm_queue_ent *sq);
+
+/* free/new/send */
+void interdsp_free_sq_entry(struct arm_queue_ent *sq);
+int interdsp_new_sq_entry(struct arm_queue_ent **sqp,
+			   int ch, int num, int ack_sync,
+			   struct dsp_cmd_rw *rwcmd,
+			   void (*ack_callback) (int ch,
+						 union interdsp_spa_header,
+						 int, unsigned long),
+			   unsigned long cb_data);
+
+/* prepare send/discard */
+int interdsp_prepare_send_sq_entry(struct arm_queue_ent *sq, int nonblock);
+void interdsp_put_sq_entry(struct arm_queue_ent *sq);
+
+/* send */
+void interdsp_send_sq_entry(struct arm_queue_ent *sq);
+
+/* get command header */
+union interdsp_spa_header interdsp_get_hdr_sq_entry(struct arm_queue_ent *sq);
+int interdsp_rewrite_sq_entry(struct arm_queue_ent *sq,
+			       union interdsp_spa_header,
+			       void *buf, size_t size);
+
+/*
+ * snatch res/req
+ */
+
+int interdsp_push_req_handler(int (*handler) (int,
+					       union interdsp_spa_header *,
+					       void *, size_t));
+void interdsp_remove_req_handler(int (*handler) (int,
+						  union interdsp_spa_header *,
+						  void *, size_t));
+
+/*
+ * release notify
+ */
+int interdsp_push_release_notify(void (*notify) (struct inode *,
+						  struct file *));
+void interdsp_remove_release_notify(void (*notify) (struct inode *,
+						     struct file *));
+
+/*
+ * insert/delete DSP Response/Request
+ */
+struct interdsp_pending_resreq *
+interdsp_push_resreq(uint32_t fdata[2], void *kdata, size_t len,
+		      void (*cb) (unsigned long cbdata),
+		      unsigned long cbdata, int nonblock, int wake);
+void interdsp_pop_resreq(struct interdsp_pending_resreq *resreq);
+
+/*
+ * add/remove minor device
+ */
+int interdsp_add_minor_device(int minor,
+			       char *name, struct file_operations *fops);
+int interdsp_remove_minor_device(int minor, struct file_operations *fops);
+
+/*
+ * force initializing shared memory
+ */
+int interdsp_shmem_init(void);
+
+#endif /* INTER_DSP_H */
-- 
1.6.5.2

