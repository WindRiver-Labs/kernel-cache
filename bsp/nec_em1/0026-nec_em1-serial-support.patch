From b3a5c7a6c2de1d86a361d30056ce585ebc45c053 Mon Sep 17 00:00:00 2001
From: Kazuya Tsukamoto <kazuya.tsukamoto@necel.com>
Date: Mon, 9 Nov 2009 15:09:26 +0900
Subject: [PATCH 26/29] nec_em1: serial support

serial : change transmission processing sequence.

The transmission processing sequence when suspending is changed.
The transmission request accepted after the suspension is processed
is reserved once, and after the resume is processed, executed.

Signed-off-by: Kazuya Tsukamoto <kazuya.tsukamoto@necel.com>
---
 drivers/serial/8250.c      |  158 ++++++++++++++++++++++++++++++++++++++------
 include/linux/serial_reg.h |   24 +++++++
 2 files changed, 161 insertions(+), 21 deletions(-)

diff --git a/drivers/serial/8250.c b/drivers/serial/8250.c
index 537a245..89c0494 100644
--- a/drivers/serial/8250.c
+++ b/drivers/serial/8250.c
@@ -38,9 +38,12 @@
 #include <linux/serial_8250.h>
 #include <linux/nmi.h>
 #include <linux/mutex.h>
+#include <linux/io.h>
 
-#include <asm/io.h>
 #include <asm/irq.h>
+#ifdef CONFIG_ARCH_MP200
+#include <mach/pm.h>
+#endif
 
 #include "8250.h"
 
@@ -90,7 +93,6 @@ static unsigned int nr_uarts = CONFIG_SERIAL_8250_RUNTIME_UARTS;
  */
 #define CONFIG_HUB6 1
 
-#include <asm/serial.h>
 /*
  * SERIAL_PORT_DFNS tells us about built-in ports that have no
  * standard enumeration mechanism.   Platforms that can find all
@@ -113,6 +115,11 @@ static unsigned long probe_rsa[PORT_RSA_MAX];
 static unsigned int probe_rsa_count;
 #endif /* CONFIG_SERIAL_8250_RSA  */
 
+#ifdef CONFIG_ARCH_MP200
+static int serial8250_start_tx_sus_count;
+#endif
+
+
 struct uart_8250_port {
 	struct uart_port	port;
 	struct timer_list	timer;		/* "no irq" timer */
@@ -266,7 +273,7 @@ static const struct serial8250_config uart_config[] = {
 	},
 };
 
-#if defined (CONFIG_SERIAL_8250_AU1X00)
+#if defined(CONFIG_SERIAL_8250_AU1X00)
 
 /* Au1x00 UART hardware has a weird register layout */
 static const u8 au_io_in_map[] = {
@@ -432,6 +439,7 @@ serial_out(struct uart_8250_port *up, int offset, int value)
 	}
 }
 
+#ifndef CONFIG_ARCH_MP200
 static void
 serial_out_sync(struct uart_8250_port *up, int offset, int value)
 {
@@ -449,6 +457,7 @@ serial_out_sync(struct uart_8250_port *up, int offset, int value)
 		serial_out(up, offset, value);
 	}
 }
+#endif
 
 /*
  * We used to support using pause I/O for certain machines.  We
@@ -934,7 +943,11 @@ static void autoconfig_16550a(struct uart_8250_port *up)
 
 	DEBUG_AUTOCONF("iir1=%d iir2=%d ", status1, status2);
 
+#ifdef CONFIG_ARCH_MP200
+	if (status1 == 7 && status2 == 7) {
+#else
 	if (status1 == 6 && status2 == 7) {
+#endif
 		up->port.type = PORT_16750;
 		up->capabilities |= UART_CAP_AFE | UART_CAP_SLEEP;
 		return;
@@ -1472,7 +1485,10 @@ static irqreturn_t serial8250_interrupt(int irq, void *dev_id)
 {
 	struct irq_info *i = dev_id;
 	struct list_head *l, *end = NULL;
-	int pass_counter = 0, handled = 0;
+#ifndef CONFIG_PREEMPT_RT
+	int pass_counter = 0;
+#endif
+	int handled = 0;
 
 	DEBUG_INTR("serial8250_interrupt(%d)...", irq);
 
@@ -1510,12 +1526,18 @@ static irqreturn_t serial8250_interrupt(int irq, void *dev_id)
 
 		l = l->next;
 
+		/*
+		 * On preempt-rt we can be preempted and run in our
+		 * own thread.
+		 */
+#ifndef CONFIG_PREEMPT_RT
 		if (l == i->head && pass_counter++ > PASS_LIMIT) {
 			/* If we hit this, we're dead. */
 			printk(KERN_ERR "serial8250: too much work for "
 				"irq%d\n", irq);
 			break;
 		}
+#endif
 	} while (l != end);
 
 	spin_unlock(&i->lock);
@@ -1613,6 +1635,7 @@ static void serial8250_timeout(unsigned long data)
 	mod_timer(&up->timer, jiffies + poll_timeout(up->port.timeout));
 }
 
+#ifndef CONFIG_ARCH_MP200
 static void serial8250_backup_timeout(unsigned long data)
 {
 	struct uart_8250_port *up = (struct uart_8250_port *)data;
@@ -1657,6 +1680,7 @@ static void serial8250_backup_timeout(unsigned long data)
 	mod_timer(&up->timer,
 		jiffies + poll_timeout(up->port.timeout) + HZ / 5);
 }
+#endif
 
 static unsigned int serial8250_tx_empty(struct uart_port *port)
 {
@@ -1819,7 +1843,9 @@ static int serial8250_startup(struct uart_port *port)
 {
 	struct uart_8250_port *up = (struct uart_8250_port *)port;
 	unsigned long flags;
+#ifndef CONFIG_ARCH_MP200
 	unsigned char lsr, iir;
+#endif
 	int retval;
 
 	up->capabilities = uart_config[up->port.type].flags;
@@ -1889,6 +1915,7 @@ static int serial8250_startup(struct uart_port *port)
 		serial_outp(up, UART_LCR, 0);
 	}
 
+#ifndef CONFIG_ARCH_MP200
 	if (is_real_interrupt(up->port.irq)) {
 		unsigned char iir1;
 		/*
@@ -1937,6 +1964,7 @@ static int serial8250_startup(struct uart_port *port)
 		mod_timer(&up->timer, jiffies +
 			  poll_timeout(up->port.timeout) + HZ / 5);
 	}
+#endif
 
 	/*
 	 * If the "interrupt" for this port doesn't correspond with any
@@ -1984,6 +2012,7 @@ static int serial8250_startup(struct uart_port *port)
 	if (up->port.flags & UPF_NO_TXEN_TEST)
 		goto dont_test_tx_en;
 
+#ifndef CONFIG_ARCH_MP200
 	/*
 	 * Do a quick test to see if we receive an
 	 * interrupt when we enable the TX irq.
@@ -2002,6 +2031,7 @@ static int serial8250_startup(struct uart_port *port)
 	} else {
 		up->bugs &= ~UART_BUG_TXEN;
 	}
+#endif
 
 dont_test_tx_en:
 	spin_unlock_irqrestore(&up->port.lock, flags);
@@ -2156,7 +2186,12 @@ serial8250_set_termios(struct uart_port *port, struct ktermios *termios,
 
 	if (up->capabilities & UART_CAP_FIFO && up->port.fifosize > 1) {
 		if (baud < 2400)
+#ifdef CONFIG_ARCH_MP200
+			fcr = UART_FCR_ENABLE_FIFO | UART_FCR_TRIGGER_1
+							| UART_FCR7_64BYTE;
+#else
 			fcr = UART_FCR_ENABLE_FIFO | UART_FCR_TRIGGER_1;
+#endif
 		else
 			fcr = uart_config[up->port.type].fcr;
 	}
@@ -2286,8 +2321,8 @@ serial8250_set_termios(struct uart_port *port, struct ktermios *termios,
 			serial_outp(up, UART_LCR, 0xbf);	/* Access EFR */
 			serial_outp(up, UART_EFR, 0);
 			serial_outp(up, UART_LCR, cval);	/* Access FCR */
-        } else
-		serial_outp(up, UART_FCR, fcr);		/* set fcr */
+		} else
+			serial_outp(up, UART_FCR, fcr);		/* set fcr */
 	}
 	serial8250_set_mctrl(&up->port, up->port.mctrl);
 	spin_unlock_irqrestore(&up->port.lock, flags);
@@ -2316,6 +2351,9 @@ static unsigned int serial8250_port_size(struct uart_8250_port *pt)
 	if (is_omap_port(pt))
 		return 0x16 << pt->port.regshift;
 #endif
+#ifdef CONFIG_ARCH_MP200
+	return 11 << pt->port.regshift;
+#endif
 	return 8 << pt->port.regshift;
 }
 
@@ -2606,14 +2644,10 @@ serial8250_console_write(struct console *co, const char *s, unsigned int count)
 
 	touch_nmi_watchdog();
 
-	local_irq_save(flags);
-	if (up->port.sysrq) {
-		/* serial8250_handle_port() already took the lock */
-		locked = 0;
-	} else if (oops_in_progress) {
-		locked = spin_trylock(&up->port.lock);
-	} else
-		spin_lock(&up->port.lock);
+	if (up->port.sysrq || oops_in_progress)
+		locked = spin_trylock_irqsave(&up->port.lock, flags);
+	else
+		spin_lock_irqsave(&up->port.lock, flags);
 
 	/*
 	 *	First save the IER then disable the interrupts
@@ -2645,8 +2679,7 @@ serial8250_console_write(struct console *co, const char *s, unsigned int count)
 		check_modem_status(up);
 
 	if (locked)
-		spin_unlock(&up->port.lock);
-	local_irq_restore(flags);
+		spin_unlock_irqrestore(&up->port.lock, flags);
 }
 
 static int __init serial8250_console_setup(struct console *co, char *options)
@@ -2716,9 +2749,6 @@ int serial8250_find_port(struct uart_port *p)
 }
 EXPORT_SYMBOL_GPL(serial8250_find_port);
 
-#define SERIAL8250_CONSOLE	&serial8250_console
-#else
-#define SERIAL8250_CONSOLE	NULL
 #endif
 
 static struct uart_driver serial8250_reg = {
@@ -2728,7 +2758,11 @@ static struct uart_driver serial8250_reg = {
 	.major			= TTY_MAJOR,
 	.minor			= 64,
 	.nr			= UART_NR,
-	.cons			= SERIAL8250_CONSOLE,
+#ifdef CONFIG_SERIAL_8250_CONSOLE
+	.cons			= &serial8250_console,
+#else
+	.cons			= NULL,
+#endif
 };
 
 /*
@@ -2839,15 +2873,80 @@ static int __devexit serial8250_remove(struct platform_device *dev)
 	return 0;
 }
 
+#ifdef CONFIG_ARCH_MP200
+static int suspend_event;
+
+enum {
+	Ulcr = 0, Uier, Ufcr, Umcr, Uscr, Udll, Udlm, Umax
+};
+static u8	Uregs[UART_NR][Umax];
+
+static void dpm_save_uart_state(struct uart_8250_port *up, int port)
+{
+	Uregs[port][Ulcr] = serial_inp(up, UART_LCR);
+	serial_outp(up, UART_LCR, Uregs[port][Ulcr] & ~UART_LCR_DLAB);
+	Uregs[port][Uier] = serial_inp(up, UART_IER);
+	Uregs[port][Ufcr] = serial_inp(up, UART_FCR);
+	Uregs[port][Umcr] = serial_inp(up, UART_MCR);
+	Uregs[port][Uscr] = serial_inp(up, UART_SCR);
+	serial_outp(up, UART_LCR, Uregs[port][Ulcr] | UART_LCR_DLAB);
+	Uregs[port][Udll] = serial_inp(up, UART_DLL);
+	Uregs[port][Udlm] = serial_inp(up, UART_DLM);
+	serial_outp(up, UART_LCR, Uregs[port][Ulcr]);
+}
+
+static void dpm_restore_uart_state(struct uart_8250_port *up, int port)
+{
+	serial_outp(up, UART_LCR, Uregs[port][Ulcr] & ~UART_LCR_DLAB);
+	serial_outp(up, UART_IER, Uregs[port][Uier]);
+	serial_outp(up, UART_FCR, Uregs[port][Ufcr]);
+	serial_outp(up, UART_LCR, Uregs[port][Ulcr] | UART_LCR_DLAB);
+	serial_outp(up, UART_DLL, Uregs[port][Udll]);
+	serial_outp(up, UART_DLM, Uregs[port][Udlm]);
+	serial_outp(up, UART_LCR, Uregs[port][Ulcr]);
+	serial_outp(up, UART_MCR, Uregs[port][Umcr]);
+	serial_outp(up, UART_SCR, Uregs[port][Uscr]);
+}
+#endif
+
+#ifdef CONFIG_ARCH_MP200
+static void serial8250_start_tx_sus(struct uart_port *port)
+{
+	serial8250_start_tx_sus_count++;
+}
+#endif
+
 static int serial8250_suspend(struct platform_device *dev, pm_message_t state)
 {
 	int i;
+#ifdef CONFIG_ARCH_MP200
+	suspend_event = state.event;
+#endif
 
 	for (i = 0; i < UART_NR; i++) {
 		struct uart_8250_port *up = &serial8250_ports[i];
 
+#ifdef CONFIG_ARCH_MP200
+		if (up->port.type != PORT_UNKNOWN
+				 && up->port.dev == &dev->dev) {
+			if (suspend_event == DEV_SUSPEND_IDLE_1) {
+				if (!serial8250_tx_empty(&up->port))
+					return -1;
+
+				continue;
+			}
+			if (mp200_sleep_while_idle) {
+				dpm_save_uart_state(up, i);
+				continue;
+			}
+			serial8250_start_tx_sus_count	= 0;
+			serial8250_pops.start_tx = serial8250_start_tx_sus;
+			uart_suspend_port(&serial8250_reg, &up->port);
+		}
+#else
 		if (up->port.type != PORT_UNKNOWN && up->port.dev == &dev->dev)
 			uart_suspend_port(&serial8250_reg, &up->port);
+#endif
 	}
 
 	return 0;
@@ -2860,8 +2959,24 @@ static int serial8250_resume(struct platform_device *dev)
 	for (i = 0; i < UART_NR; i++) {
 		struct uart_8250_port *up = &serial8250_ports[i];
 
-		if (up->port.type != PORT_UNKNOWN && up->port.dev == &dev->dev)
+#ifdef CONFIG_ARCH_MP200
+		if (suspend_event == DEV_SUSPEND_IDLE_1)
+			return 0;
+
+		if (mp200_sleep_while_idle) {
+			dpm_restore_uart_state(up, i);
+			continue;
+		}
+#endif
+		if (up->port.type != PORT_UNKNOWN
+				 && up->port.dev == &dev->dev) {
 			serial8250_resume_port(i);
+#ifdef CONFIG_ARCH_MP200
+			serial8250_pops.start_tx	= serial8250_start_tx;
+			if (serial8250_start_tx_sus_count > 1)
+				serial8250_start_tx(&up->port);
+#endif
+		}
 	}
 
 	return 0;
@@ -3058,6 +3173,7 @@ static int __init serial8250_init(void)
 
 	serial8250_register_ports(&serial8250_reg, &serial8250_isa_devs->dev);
 
+	serial8250_start_tx_sus_count = 0;
 	ret = platform_driver_register(&serial8250_isa_driver);
 	if (ret == 0)
 		goto out;
diff --git a/include/linux/serial_reg.h b/include/linux/serial_reg.h
index 1ea6436..3bccadb 100644
--- a/include/linux/serial_reg.h
+++ b/include/linux/serial_reg.h
@@ -325,5 +325,29 @@
 #define UART_OMAP_SYSC		0x15	/* System configuration register */
 #define UART_OMAP_SYSS		0x16	/* System status register */
 
+#ifdef CONFIG_ARCH_MP200
+#undef UART_IER
+#undef UART_IIR
+#undef UART_FCR
+#undef UART_LCR
+#undef UART_MCR
+#undef UART_LSR
+#undef UART_MSR
+#undef UART_SCR
+#undef UART_DLL
+#undef UART_DLM
+
+#define UART_IER        (1)
+#define UART_IIR        (2)
+#define UART_FCR        (3)
+#define UART_LCR        (4)
+#define UART_MCR        (5)
+#define UART_LSR        (6)
+#define UART_MSR        (7)
+#define UART_SCR        (8)
+#define UART_DLL        (9)
+#define UART_DLM        (10)
+#endif
+
 #endif /* _LINUX_SERIAL_REG_H */
 
-- 
1.6.5.2

