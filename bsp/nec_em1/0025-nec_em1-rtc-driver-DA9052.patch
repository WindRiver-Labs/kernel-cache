From ba721a9e6cf088b1012c1d9b5c299fe9f247caf0 Mon Sep 17 00:00:00 2001
From: Kazuya Tsukamoto <kazuya.tsukamoto@necel.com>
Date: Mon, 9 Nov 2009 15:08:24 +0900
Subject: [PATCH 25/29] nec_em1: rtc driver (DA9052)

rtc : support for Dialog DA9052.

Notes:

 - In the time setting (year), the range from 2000 to 2060 can be
   specified.
 - After 0.5 seconds pass from the time setting, reading becomes
   possible at time.

Signed-off-by: Kazuya Tsukamoto <kazuya.tsukamoto@necel.com>
---
 drivers/rtc/Kconfig     |    4 +
 drivers/rtc/Makefile    |    1 +
 drivers/rtc/class.c     |   56 +++--
 drivers/rtc/rtc-core.h  |    4 +
 drivers/rtc/rtc-dev.c   |    2 +
 drivers/rtc/rtc-mp200.c |  641 +++++++++++++++++++++++++++++++++++++++++++++++
 6 files changed, 685 insertions(+), 23 deletions(-)
 create mode 100644 drivers/rtc/rtc-mp200.c

diff --git a/drivers/rtc/Kconfig b/drivers/rtc/Kconfig
index bcc0d96..6c547d3 100644
--- a/drivers/rtc/Kconfig
+++ b/drivers/rtc/Kconfig
@@ -433,6 +433,10 @@ config RTC_DRV_V3020
 	  This driver can also be built as a module. If so, the module
 	  will be called rtc-v3020.
 
+config RTC_DRV_MP200
+	tristate "MP200 series RTC"
+	depends on RTC_CLASS && ARCH_MP200
+
 comment "on-CPU RTC drivers"
 
 config RTC_DRV_OMAP
diff --git a/drivers/rtc/Makefile b/drivers/rtc/Makefile
index 3ef1dfc..7cb57d8 100644
--- a/drivers/rtc/Makefile
+++ b/drivers/rtc/Makefile
@@ -60,3 +60,4 @@ obj-$(CONFIG_RTC_DRV_TWL4030)	+= rtc-twl4030.o
 obj-$(CONFIG_RTC_DRV_V3020)	+= rtc-v3020.o
 obj-$(CONFIG_RTC_DRV_VR41XX)	+= rtc-vr41xx.o
 obj-$(CONFIG_RTC_DRV_X1205)	+= rtc-x1205.o
+obj-$(CONFIG_RTC_DRV_MP200)	+= rtc-mp200.o
diff --git a/drivers/rtc/class.c b/drivers/rtc/class.c
index 4dfdf01..90439ef 100644
--- a/drivers/rtc/class.c
+++ b/drivers/rtc/class.c
@@ -53,14 +53,19 @@ static int rtc_suspend(struct device *dev, pm_message_t mesg)
 				BUS_ID_SIZE) != 0)
 		return 0;
 
-	rtc_read_time(rtc, &tm);
-	rtc_tm_to_time(&tm, &oldtime);
+#ifdef CONFIG_ARCH_MP200
+	if (!mp200_sleep_while_idle) {
+#endif
+		rtc_read_time(rtc, &tm);
+		rtc_tm_to_time(&tm, &oldtime);
 
-	/* RTC precision is 1 second; adjust delta for avg 1/2 sec err */
-	set_normalized_timespec(&delta,
+		/* RTC precision is 1 second; adjust delta for avg 1/2sec err */
+		set_normalized_timespec(&delta,
 				ts.tv_sec - oldtime,
 				ts.tv_nsec - (NSEC_PER_SEC >> 1));
-
+#ifdef CONFIG_ARCH_MP200
+	}
+#endif
 	return 0;
 }
 
@@ -75,26 +80,31 @@ static int rtc_resume(struct device *dev)
 				CONFIG_RTC_HCTOSYS_DEVICE,
 				BUS_ID_SIZE) != 0)
 		return 0;
-
-	rtc_read_time(rtc, &tm);
-	if (rtc_valid_tm(&tm) != 0) {
-		pr_debug("%s:  bogus resume time\n", rtc->dev.bus_id);
-		return 0;
-	}
-	rtc_tm_to_time(&tm, &newtime);
-	if (newtime <= oldtime) {
-		if (newtime < oldtime)
-			pr_debug("%s:  time travel!\n", rtc->dev.bus_id);
-		return 0;
-	}
-
-	/* restore wall clock using delta against this RTC;
-	 * adjust again for avg 1/2 second RTC sampling error
-	 */
-	set_normalized_timespec(&time,
+#ifdef CONFIG_ARCH_MP200
+	if (!mp200_sleep_while_idle) {
+#endif
+		rtc_read_time(rtc, &tm);
+		if (rtc_valid_tm(&tm) != 0) {
+			pr_debug("%s:  bogus resume time\n", rtc->dev.bus_id);
+			return 0;
+		}
+		rtc_tm_to_time(&tm, &newtime);
+		if (newtime <= oldtime) {
+			if (newtime < oldtime)
+				pr_debug("%s: time travel!\n", rtc->dev.bus_id);
+			return 0;
+		}
+
+		/* restore wall clock using delta against this RTC;
+		 * adjust again for avg 1/2 second RTC sampling error
+		 */
+		set_normalized_timespec(&time,
 				newtime + delta.tv_sec,
 				(NSEC_PER_SEC >> 1) + delta.tv_nsec);
-	do_settimeofday(&time);
+		do_settimeofday(&time);
+#ifdef CONFIG_ARCH_MP200
+	}
+#endif
 
 	return 0;
 }
diff --git a/drivers/rtc/rtc-core.h b/drivers/rtc/rtc-core.h
index 5f9df74..3395488 100644
--- a/drivers/rtc/rtc-core.h
+++ b/drivers/rtc/rtc-core.h
@@ -68,3 +68,7 @@ static inline void rtc_sysfs_del_device(struct rtc_device *rtc)
 }
 
 #endif
+
+#ifdef CONFIG_ARCH_MP200
+extern int mp200_sleep_while_idle;
+#endif
diff --git a/drivers/rtc/rtc-dev.c b/drivers/rtc/rtc-dev.c
index 52e2743..e2ed8a4 100644
--- a/drivers/rtc/rtc-dev.c
+++ b/drivers/rtc/rtc-dev.c
@@ -472,6 +472,8 @@ void rtc_dev_prepare(struct rtc_device *rtc)
 
 	rtc->dev.devt = MKDEV(MAJOR(rtc_devt), rtc->id);
 
+	spin_lock_init(&rtc->irq_lock);
+	init_waitqueue_head(&rtc->irq_queue);
 #ifdef CONFIG_RTC_INTF_DEV_UIE_EMUL
 	INIT_WORK(&rtc->uie_task, rtc_uie_task);
 	setup_timer(&rtc->uie_timer, rtc_uie_timer, (unsigned long)rtc);
diff --git a/drivers/rtc/rtc-mp200.c b/drivers/rtc/rtc-mp200.c
new file mode 100644
index 0000000..9b8c3fd
--- /dev/null
+++ b/drivers/rtc/rtc-mp200.c
@@ -0,0 +1,641 @@
+/*
+ *  File Name       : drivers/rtc/rtc-mp200.c
+ *  Function        : MP200 Real Time Clock interface
+ *  Release Version : Ver 1.02
+ *  Release Date    : 2009/02/19
+ *
+ *  Copyright (C) NEC Electronics Corporation 2009
+ *
+ *
+ *  This program is free software;you can redistribute it and/or modify itunder
+ *  the terms of the GNU General Public License as published by Free Softwere
+ *  Foundation;either version 2 of License, or (at your option) any later
+ *  version.
+ *
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warrnty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; If not, write to the Free Software Foundation, Inc., 59
+ *  Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/rtc.h>
+#include <linux/bcd.h>
+#include <linux/log2.h>
+#include <linux/delay.h>
+#include <linux/uaccess.h>
+
+#include <mach/pwc.h>
+
+static DEFINE_SPINLOCK(mp200_rtc_lock);
+
+#ifdef	CONFIG_MP200_EM1_DKIT
+/* #define RTC_TRIM		DA9052_OSCTRIM_REG */	/* not support */
+/* #define RTC_TRIM_RD		DA9052_OSCTRIM_REG */	/* not support */
+#define RTC_SEC				DA9052_COUNTS_REG
+#define RTC_SEC_RD			DA9052_COUNTS_REG
+#define RTC_MIN				DA9052_COUNTMI_REG
+#define RTC_MIN_RD			DA9052_COUNTMI_REG
+#define RTC_HOUR			DA9052_COUNTH_REG
+#define RTC_HOUR_RD			DA9052_COUNTH_REG
+#define RTC_WEEK			0
+#define RTC_WEEK_RD			0
+#define RTC_DAY				DA9052_COUNTD_REG
+#define RTC_DAY_RD			DA9052_COUNTD_REG
+#define RTC_MONTH			DA9052_COUNTMO_REG
+#define RTC_MONTH_RD		DA9052_COUNTMO_REG
+#define RTC_YEAR			DA9052_COUNTY_REG	/* 2000-2063 */
+#define RTC_YEAR_RD			DA9052_COUNTY_REG
+#define RTC_ALM_MIN			DA9052_ALARMMI_REG
+#define RTC_ALM_MIN_RD		DA9052_ALARMMI_REG
+#define RTC_ALM_HOUR		DA9052_ALARMH_REG
+#define RTC_ALM_HOUR_RD		DA9052_ALARMH_REG
+#define RTC_ALM_WEEK		0
+#define RTC_ALM_WEEK_RD		0
+#define RTC_ALM_DAY			DA9052_ALARMD_REG
+#define RTC_ALM_DAY_RD		DA9052_ALARMD_REG
+#define RTC_ALM_MONTH		DA9052_ALARMMO_REG
+#define RTC_ALM_MONTH_RD	DA9052_ALARMMO_REG
+#define RTC_ALM_YEAR		DA9052_ALARMY_REG
+#define RTC_ALM_YEAR_RD		DA9052_ALARMY_REG
+
+#define RTC_ALARM_TYPE_ALM	0x40
+#define RTC_TICK_TYPE_MIN	0x80
+#define RTC_ALARMY_ALARM_ON	0x40
+#define RTC_ALARMY_TICK_ON	0x80
+#else
+#define RTC_TRIM			PWC_TRIM
+#define RTC_TRIM_RD			PWC_TRIM_RD
+#define RTC_SEC				PWC_SEC
+#define RTC_SEC_RD			PWC_SEC_RD
+#define RTC_MIN				PWC_MIN
+#define RTC_MIN_RD			PWC_MIN_RD
+#define RTC_HOUR			PWC_HOUR
+#define RTC_HOUR_RD			PWC_HOUR_RD
+#define RTC_WEEK			PWC_WEEK
+#define RTC_WEEK_RD			PWC_WEEK_RD
+#define RTC_DAY				PWC_DAY
+#define RTC_DAY_RD			PWC_DAY_RD
+#define RTC_MONTH			PWC_MONTH
+#define RTC_MONTH_RD			PWC_MONTH_RD
+#define RTC_YEAR			PWC_YEAR		/* 1900-2099 */
+#define RTC_YEAR_RD			PWC_YEAR_RD
+#define RTC_ALM_MIN			PWC_ALM_WM
+#define RTC_ALM_MIN_RD		PWC_ALM_WM_RD
+#define RTC_ALM_HOUR		PWC_ALM_WH
+#define RTC_ALM_HOUR_RD		PWC_ALM_WH_RD
+#define RTC_ALM_WEEK		PWC_ALM_WW
+#define RTC_ALM_WEEK_RD		PWC_ALM_WW_RD
+#define RTC_ALM_DAY			0
+#define RTC_ALM_DAY_RD		0
+#define RTC_ALM_MONTH		0
+#define RTC_ALM_MONTH_RD	0
+#define RTC_ALM_YEAR		0
+#define RTC_ALM_YEAR_RD		0
+
+/* RTC1 register bit define */
+#define RTC1_WALE     0x80
+#define RTC1_DALE     0x40
+#define RTC1_CT_SEC   0x04
+#define RTC1_CT_MIN   0x05
+#define RTC1_CT_HOUR  0x06
+#define RTC1_CT_MONTH 0x07
+#define RTC1_CT_MASK  0x07
+
+/* RTC2 register bit define */
+#define RTC2_1224     0x20
+#define RTC2_ADJ_XSTP 0x40
+#define RTC2_CTFG     0x04
+#define RTC2_WAFG     0x02
+#define RTC2_DAFG     0x01
+#endif
+
+/* RTC register access macros: */
+#define RTC_READ(addr, val) pwc_read((addr), &(val));
+#define RTC_WRITE(val, addr) pwc_reg_write((addr), (val)&0xff);
+
+static unsigned long epoch = 1900;	/* year corresponding to 0x00 */
+
+static const unsigned char days_in_mo[] =
+    { 0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };
+
+static int rtc_irq;
+static int p_freq = 60;
+#ifdef	CONFIG_MP200_EM1_DKIT
+static int write_jiff;
+#endif
+
+int get_rtc_time(struct rtc_time *rtc_tm)
+{
+	unsigned long flags;
+
+#ifdef	CONFIG_MP200_EM1_DKIT
+	if (write_jiff) {
+		if ((jiffies - write_jiff) < HZ/2) {
+			set_current_state(TASK_UNINTERRUPTIBLE);
+			schedule_timeout(HZ - (jiffies - write_jiff));
+		}
+		write_jiff = 0;
+	}
+#endif
+
+	spin_lock_irqsave(&mp200_rtc_lock, flags);
+	RTC_READ(RTC_SEC_RD, rtc_tm->tm_sec);
+	RTC_READ(RTC_MIN_RD, rtc_tm->tm_min);
+	RTC_READ(RTC_HOUR_RD, rtc_tm->tm_hour);
+#ifndef	CONFIG_MP200_EM1_DKIT
+	RTC_READ(RTC_WEEK_RD, rtc_tm->tm_wday);
+#endif
+	RTC_READ(RTC_DAY_RD, rtc_tm->tm_mday);
+	RTC_READ(RTC_MONTH_RD, rtc_tm->tm_mon);
+	RTC_READ(RTC_YEAR_RD, rtc_tm->tm_year);
+	spin_unlock_irqrestore(&mp200_rtc_lock, flags);
+
+#ifdef	CONFIG_MP200_EM1_DKIT
+	rtc_tm->tm_sec &= 0x3f;	/* Mask of bit0-bit5 */
+#else
+	rtc_tm->tm_mon &= 0x1f;	/* Mask of D7(19/20) */
+
+	rtc_tm->tm_sec = BCD2BIN(rtc_tm->tm_sec);
+	rtc_tm->tm_min = BCD2BIN(rtc_tm->tm_min);
+	rtc_tm->tm_hour = BCD2BIN(rtc_tm->tm_hour);
+	rtc_tm->tm_mday = BCD2BIN(rtc_tm->tm_mday);
+	rtc_tm->tm_mon = BCD2BIN(rtc_tm->tm_mon);
+	rtc_tm->tm_year = BCD2BIN(rtc_tm->tm_year);
+#endif
+
+	if ((rtc_tm->tm_year + (epoch - 1900)) <= 69)
+		rtc_tm->tm_year += 100;
+	rtc_tm->tm_mon--;
+
+	return 0;
+}
+
+static int mp200_read_time(struct device *dev, struct rtc_time *rtc_tm)
+{
+	return get_rtc_time(rtc_tm);
+}
+
+static int mp200_set_time(struct device *dev, struct rtc_time *rtc_tm)
+{
+	unsigned char mon, day, hrs, min, sec, leap_yr;
+#ifndef	CONFIG_MP200_EM1_DKIT
+	unsigned char wday;
+#endif
+	unsigned int yrs;
+	unsigned long flags;
+
+	yrs = rtc_tm->tm_year + 1900;
+	mon = rtc_tm->tm_mon + 1;	/* tm_mon starts at zero */
+	day = rtc_tm->tm_mday;
+	hrs = rtc_tm->tm_hour;
+	min = rtc_tm->tm_min;
+	sec = rtc_tm->tm_sec;
+
+#ifdef	CONFIG_MP200_EM1_DKIT
+	if ((yrs < 2000) || (yrs > 2063))
+		return -EINVAL;
+#else
+	if (yrs < 1970)
+		return -EINVAL;
+
+	/* setting day of week */
+	if (mon < 3)
+		wday =
+		    ((yrs - 1) + (yrs - 1) / 4 - (yrs - 1) / 100 +
+		     (yrs - 1) / 400 + (13 * (mon + 12) + 8) / 5 + day) % 7;
+	else
+		wday =
+		    (yrs + yrs / 4 - yrs / 100 + yrs / 400 +
+		     (13 * mon + 8) / 5 + day) % 7;
+
+	if (wday >= 7)
+		return -EINVAL;
+#endif
+	if ((mon > 12) || (day == 0))
+		return -EINVAL;
+
+	leap_yr = ((!(yrs % 4) && (yrs % 100)) || !(yrs % 400));
+	if (day > (days_in_mo[mon] + ((mon == 2) && leap_yr)))
+		return -EINVAL;
+	if ((hrs >= 24) || (min >= 60) || (sec >= 60))
+		return -EINVAL;
+#ifdef	CONFIG_MP200_EM1_DKIT
+	yrs -= 2000;
+#else
+	if ((yrs - epoch) > 255)
+		return -EINVAL;
+	if (yrs > 169)
+		return -EINVAL;
+	if (yrs >= 100)
+		yrs -= 100;
+
+	sec = BIN2BCD(sec);
+	min = BIN2BCD(min);
+	hrs = BIN2BCD(hrs);
+	day = BIN2BCD(day);
+	mon = BIN2BCD(mon);
+	yrs = BIN2BCD(yrs);
+#endif
+
+	spin_lock_irqsave(&mp200_rtc_lock, flags);
+	RTC_WRITE(mon,  RTC_MONTH);
+	RTC_WRITE(day,  RTC_DAY);
+#ifndef	CONFIG_MP200_EM1_DKIT
+	RTC_WRITE(wday, RTC_WEEK);
+#endif
+	RTC_WRITE(hrs,  RTC_HOUR);
+	RTC_WRITE(min,  RTC_MIN);
+	RTC_WRITE(sec,  RTC_SEC);
+	RTC_WRITE(yrs,  RTC_YEAR);
+	spin_unlock_irqrestore(&mp200_rtc_lock, flags);
+#ifdef	CONFIG_MP200_EM1_DKIT
+	write_jiff = jiffies;
+#endif
+
+	return 0;
+}
+
+static inline void mp200_rtc_setaie(unsigned int enable)
+{
+#ifdef	CONFIG_MP200_EM1_DKIT
+	unsigned int rtc_val;
+
+	RTC_READ(RTC_ALM_YEAR_RD, rtc_val);
+	if (enable)
+		rtc_val |= RTC_ALARMY_ALARM_ON;
+	else
+		rtc_val &= ~RTC_ALARMY_ALARM_ON;
+	RTC_WRITE(rtc_val, RTC_ALM_YEAR);
+#else
+	unsigned int rtc1_val, rtc2_val;
+
+	RTC_READ(PWC_RTC1_RD, rtc1_val);
+	RTC_READ(PWC_RTC2_RD, rtc2_val);
+	rtc1_val &= ~RTC1_WALE;
+	rtc2_val &= ~RTC2_WAFG;
+	if (enable)
+		rtc1_val |= RTC1_WALE;
+	RTC_WRITE(rtc2_val, PWC_RTC2);
+	RTC_WRITE(rtc1_val, PWC_RTC1);
+#endif
+}
+
+static inline void mp200_rtc_setpie(unsigned int enable)
+{
+	unsigned int rtc1_val, rtc2_val;
+
+	disable_irq(rtc_irq);
+
+#ifdef	CONFIG_MP200_EM1_DKIT
+	RTC_READ(RTC_ALM_MIN_RD,  rtc1_val);
+	RTC_READ(RTC_ALM_YEAR_RD, rtc2_val);
+	if (enable) {
+		rtc2_val |= RTC_ALARMY_TICK_ON;
+		if (p_freq == 60) {
+			/* one minute */
+			rtc1_val |= RTC_TICK_TYPE_MIN;
+		} else {
+			/* one second */
+			rtc1_val &= ~RTC_TICK_TYPE_MIN;
+		}
+	} else {
+		rtc2_val &= ~RTC_ALARMY_TICK_ON;
+	}
+	RTC_WRITE(rtc1_val, RTC_ALM_MIN);
+	RTC_WRITE(rtc2_val, RTC_ALM_YEAR);
+#else
+	RTC_READ(PWC_RTC1_RD, rtc1_val);
+	RTC_READ(PWC_RTC2_RD, rtc2_val);
+	rtc1_val &= ~RTC1_CT_MASK;
+	rtc2_val &= ~RTC2_CTFG;
+
+	RTC_WRITE(rtc1_val, PWC_RTC1);
+
+	if (enable) {
+		switch (p_freq) {
+		case 1:
+			rtc1_val |= RTC1_CT_SEC;
+			break;
+		case 60:
+			rtc1_val |= RTC1_CT_MIN;
+			break;
+		case 60*60:
+			rtc1_val |= RTC1_CT_HOUR;
+			break;
+		case 60*60*24*30:
+			rtc1_val |= RTC1_CT_MONTH;
+			break;
+		}
+	}
+
+	RTC_WRITE(rtc1_val, PWC_RTC1);
+	RTC_WRITE(rtc2_val, PWC_RTC2);
+#endif
+
+	udelay(61);
+	enable_irq(rtc_irq);
+}
+
+static inline int mp200_rtc_setfreq(int freq)
+{
+	switch (freq) {
+	case 1:
+	case 60:
+#ifndef	CONFIG_MP200_EM1_DKIT
+	case 60*60:
+	case 60*60*24*30:
+#endif
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	p_freq = freq;
+
+	return 0;
+}
+
+static int mp200_rtc_getalarm(struct device *dev, struct rtc_wkalrm *alrm)
+{
+	struct rtc_time *alm_tm = &alrm->time;
+	unsigned long flags;
+
+	spin_lock_irqsave(&mp200_rtc_lock, flags);
+	RTC_READ(RTC_ALM_MIN_RD,  alm_tm->tm_min);
+	RTC_READ(RTC_ALM_HOUR_RD, alm_tm->tm_hour);
+#ifdef	CONFIG_MP200_EM1_DKIT
+	RTC_READ(RTC_ALM_DAY_RD,   alm_tm->tm_mday);
+	RTC_READ(RTC_ALM_MONTH_RD, alm_tm->tm_mon);
+	RTC_READ(RTC_ALM_YEAR_RD,  alm_tm->tm_year);
+#else
+	RTC_READ(RTC_ALM_WEEK_RD, alm_tm->tm_wday);
+#endif
+	spin_unlock_irqrestore(&mp200_rtc_lock, flags);
+
+#ifdef	CONFIG_MP200_EM1_DKIT
+	alm_tm->tm_min  &= 0x3f;		/* Mask of bit0-bit5 */
+	alm_tm->tm_year &= 0x3f;		/* Mask of bit0-bit5 */
+	alm_tm->tm_mon--;
+	alm_tm->tm_year += 100;
+#else
+	alm_tm->tm_min  = BCD2BIN(alm_tm->tm_min);
+	alm_tm->tm_hour = BCD2BIN(alm_tm->tm_hour);
+	alm_tm->tm_wday &= 0x7F;
+	if (alm_tm->tm_wday) {
+		if (alm_tm->tm_wday == 0x7F)
+			alm_tm->tm_wday = -1;
+		else
+			alm_tm->tm_wday = ilog2(alm_tm->tm_wday);
+	}
+#endif
+
+	return 0;
+}
+
+static int mp200_rtc_setalarm(struct device *dev, struct rtc_wkalrm *alrm)
+{
+	struct rtc_time *alm_tm = &alrm->time;
+#ifdef	CONFIG_MP200_EM1_DKIT
+	unsigned int hrs, min, day, mon, yrs, leap_yr;
+#else
+	unsigned int hrs, min, wday;
+#endif
+	unsigned long flags;
+
+	hrs = alm_tm->tm_hour;
+	min = alm_tm->tm_min;
+#ifdef	CONFIG_MP200_EM1_DKIT
+	yrs = alm_tm->tm_year + 1900;
+	mon  = alm_tm->tm_mon + 1;
+	day  = alm_tm->tm_mday;
+
+	if ((yrs < 2000) || (yrs > 2063))
+		return -EINVAL;
+#else
+	if (alm_tm->tm_wday == -1)
+		wday = 0x7f;	/* All */
+	else {
+		if (alm_tm->tm_wday > 6)
+			return -EINVAL;
+		wday = 1 << alm_tm->tm_wday;
+	}
+#endif
+
+	if (hrs >= 24)
+		return -EINVAL;
+	if (min >= 60)
+		return -EINVAL;
+#ifdef	CONFIG_MP200_EM1_DKIT
+	leap_yr = ((!(yrs % 4) && (yrs % 100)) || !(yrs % 400));
+	if (day > (days_in_mo[mon] + ((mon == 2) && leap_yr)))
+		return -EINVAL;
+	if (mon >= 60)
+		return -EINVAL;
+	yrs -= 2000;
+#else
+	min = BIN2BCD(min);
+	hrs = BIN2BCD(hrs);
+#endif
+
+	spin_lock_irqsave(&mp200_rtc_lock, flags);
+	RTC_WRITE(hrs,  RTC_ALM_HOUR);
+#ifdef	CONFIG_MP200_EM1_DKIT
+	pwc_write(RTC_ALM_MIN, min, 0x3f);
+	RTC_WRITE(day,  RTC_ALM_DAY);
+	RTC_WRITE(mon,  RTC_ALM_MONTH);
+	pwc_write(RTC_ALM_YEAR, yrs, 0x3f);
+#else
+	RTC_WRITE(min,  RTC_ALM_MIN);
+	RTC_WRITE(wday, RTC_ALM_WEEK);
+#endif
+	spin_unlock_irqrestore(&mp200_rtc_lock, flags);
+
+	if (alrm->enabled)
+		mp200_rtc_setaie(1);
+	else
+		mp200_rtc_setaie(0);
+
+	return 0;
+}
+
+static irqreturn_t mp200_rtc_interrupt(int irq, void *dev_id)
+{
+	struct rtc_device *rtc = dev_id;
+	unsigned long events = RTC_IRQF;
+	unsigned int int_val;
+
+#ifdef	CONFIG_MP200_EM1_DKIT
+	RTC_READ(RTC_ALM_MIN_RD,  int_val);
+
+	if (int_val & RTC_ALARM_TYPE_ALM) {
+		/* caused by timer alarm */
+		events |= RTC_AF;
+		RTC_READ(RTC_ALM_YEAR_RD,  int_val);
+		if (int_val & RTC_ALARMY_TICK_ON)
+			events |= RTC_PF;
+	} else {
+		/* caused by TICK */
+		events |= RTC_PF;
+	}
+#else
+	RTC_READ(PWC_RTC2_RD, int_val);
+
+	if (!(int_val & (RTC2_CTFG | RTC2_WAFG)))
+		return IRQ_NONE;
+
+	if (int_val & RTC2_CTFG) {
+		int_val &= ~RTC2_CTFG;
+		events |= RTC_PF;
+	}
+	if (int_val & RTC2_WAFG) {
+		int_val &= ~RTC2_WAFG;
+		events |= RTC_AF;
+	}
+
+	RTC_WRITE(int_val, PWC_RTC2);
+#endif
+
+	rtc_update_irq(rtc, 1, events);
+
+	return IRQ_HANDLED;
+}
+
+
+static int
+mp200_rtc_ioctl(struct device *dev, unsigned int cmd, unsigned long arg)
+{
+	switch (cmd) {
+	case RTC_AIE_ON:
+	case RTC_AIE_OFF:
+		mp200_rtc_setaie((cmd == RTC_AIE_ON) ? 1 : 0);
+		break;
+
+	case RTC_PIE_ON:
+	case RTC_PIE_OFF:
+		mp200_rtc_setpie((cmd == RTC_PIE_ON) ? 1 : 0);
+		break;
+
+	case RTC_IRQP_SET:
+		return mp200_rtc_setfreq(arg);
+
+	case RTC_IRQP_READ:
+		return  put_user(p_freq, (unsigned long __user *)arg);
+
+	default:
+		return -ENOIOCTLCMD;
+	}
+
+	return 0;
+}
+
+
+static int mp200_rtc_open(struct device *dev)
+{
+	return 0;
+}
+
+static void mp200_rtc_release(struct device *dev)
+{
+	mp200_rtc_setpie(0);
+}
+
+static struct rtc_class_ops mp200_rtcops = {
+	.open       = mp200_rtc_open,
+	.release    = mp200_rtc_release,
+	.ioctl      = mp200_rtc_ioctl,
+	.read_time  = mp200_read_time,
+	.set_time   = mp200_set_time,
+	.read_alarm = mp200_rtc_getalarm,
+	.set_alarm  = mp200_rtc_setalarm,
+};
+
+static int mp200_rtc_probe(struct platform_device *pdev)
+{
+	struct rtc_device	*rtc;
+	int ret;
+
+	printk(KERN_INFO "Starting rtc.\n");
+
+	rtc_irq = platform_get_irq(pdev, 0);
+	if (rtc_irq < 0)
+		return -ENODEV;
+
+	rtc = rtc_device_register(pdev->name, &pdev->dev,
+			&mp200_rtcops, THIS_MODULE);
+	if (IS_ERR(rtc)) {
+		pr_debug("%s: can't register RTC device, err %ld\n",
+			pdev->name, PTR_ERR(rtc));
+		return -EIO;
+	}
+	platform_set_drvdata(pdev, rtc);
+
+#ifndef	CONFIG_MP200_EM1_DKIT
+	RTC_WRITE(0x00, RTC_TRIM);
+	RTC_WRITE(0x00, PWC_RTC1);
+	RTC_WRITE(RTC2_1224, PWC_RTC2);
+
+	set_irq_type(rtc_irq, IRQ_TYPE_EDGE_RISING);
+#endif
+	ret = request_irq(rtc_irq, mp200_rtc_interrupt, IRQF_DISABLED,
+			"rtc", rtc);
+	if (ret < 0) {
+		printk(KERN_ERR "rtc: request_irq error! (%d)\n", rtc_irq);
+		goto err_irq;
+	}
+
+	return 0;
+
+err_irq:
+	rtc_device_unregister(rtc);
+	return ret;
+}
+
+static int mp200_rtc_remove(struct platform_device *pdev)
+{
+	struct rtc_device	*rtc = platform_get_drvdata(pdev);
+
+	rtc_device_unregister(rtc);
+
+	free_irq(rtc_irq, rtc);
+
+	return 0;
+}
+
+static struct platform_driver mp200_rtcdrv = {
+	.probe		= mp200_rtc_probe,
+	.remove		= mp200_rtc_remove,
+	.driver		= {
+		.name	= "mp200-rtc",
+		.owner	= THIS_MODULE,
+	},
+};
+
+static int __init rtc_init(void)
+{
+	rtc_irq = 0;
+#ifdef	CONFIG_MP200_EM1_DKIT
+	write_jiff = 0;
+#endif
+	return platform_driver_register(&mp200_rtcdrv);
+}
+module_init(rtc_init);
+
+static void __exit rtc_exit(void)
+{
+	platform_driver_unregister(&mp200_rtcdrv);
+}
+module_exit(rtc_exit);
+
+MODULE_DESCRIPTION("MP200 series RTC Driver");
+MODULE_LICENSE("GPL");
-- 
1.6.5.2

