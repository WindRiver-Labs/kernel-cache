From 0457257e0de98bac3fb27567bbcd57412b95584a Mon Sep 17 00:00:00 2001
From: Kazuya Tsukamoto <kazuya.tsukamoto@necel.com>
Date: Mon, 9 Nov 2009 12:05:46 +0900
Subject: [PATCH 12/29] nec_em1: avc support

This driver control H264 HW-IP on EM1 and links it into
the kbuild infrastructure via the drivers Makefile.

Signed-off-by: Kazuya Tsukamoto <kazuya.tsukamoto@necel.com>
---
 arch/arm/mach-mp200/include/mach/avc_common_info.h | 1205 ++++++
 drivers/Makefile                                   |    2 +
 drivers/avc/Kconfig                                |   14 +
 drivers/avc/Makefile                               |   13 +
 drivers/avc/avc_control.c                          | 4046 ++++++++++++++++++++
 drivers/avc/avc_debug.c                            |  103 +
 drivers/avc/avc_debug.h                            |   18 +
 drivers/avc/avc_info.h                             |   36 +
 drivers/avc/avc_interface.c                        | 1152 ++++++
 drivers/avc/avc_lib.h                              |   48 +
 drivers/avc/avc_regs.h                             |  263 ++
 drivers/avc/avc_version.c                          |   47 +
 12 files changed, 6947 insertions(+), 0 deletions(-)
 create mode 100644 arch/arm/mach-mp200/include/mach/avc_common_info.h
 create mode 100644 drivers/avc/Kconfig
 create mode 100644 drivers/avc/Makefile
 create mode 100644 drivers/avc/avc_control.c
 create mode 100644 drivers/avc/avc_debug.c
 create mode 100644 drivers/avc/avc_debug.h
 create mode 100644 drivers/avc/avc_info.h
 create mode 100644 drivers/avc/avc_interface.c
 create mode 100644 drivers/avc/avc_lib.h
 create mode 100644 drivers/avc/avc_regs.h
 create mode 100644 drivers/avc/avc_version.c

diff --git a/arch/arm/mach-mp200/include/mach/avc_common_info.h b/arch/arm/mach-mp200/include/mach/avc_common_info.h
new file mode 100644
index 0000000..841c4ca
--- /dev/null
+++ b/arch/arm/mach-mp200/include/mach/avc_common_info.h
@@ -0,0 +1,1205 @@
+#ifndef __avc_common_info_h__
+#define __avc_common_info_h__
+
+#include <linux/ioctl.h>
+#define AVC_IOCTL_MAGIC 'H'
+#define AVC_IOCQBUFSIZE      _IO(AVC_IOCTL_MAGIC, 0)
+#define AVC_IOCSREGCMD      _IOW(AVC_IOCTL_MAGIC, 1, int)
+#define AVC_IOCSREGISTER    _IOW(AVC_IOCTL_MAGIC, 2, int)
+#define AVC_IOCGREGISTER   _IOWR(AVC_IOCTL_MAGIC, 3, int)
+#define AVC_IOCGVERSION     _IOR(AVC_IOCTL_MAGIC, 4, int)
+#define AVC_IOCSDEBUGLEVEL  _IOW(AVC_IOCTL_MAGIC, 99, int)
+
+/* enc_still_image_value; //NORMAL 0000h , FINE 0222h, finest 0224h*/
+#define     AVC_ENCPARAM_STILL_IMAGE_MODE_NORMAL       0x0000
+#define     AVC_ENCPARAM_STILL_IMAGE_MODE_FINE         0x0222
+#define     AVC_ENCPARAM_STILL_IMAGE_MODE_FINEST       0x0224
+
+/* enc_flat_image_value; // NORMAL 0000h , FINE 0F22h, finest 0f44h*/
+#define     AVC_ENCPARAM_FLAT_IMAGE_MODE_NORMAL        0x0000
+#define     AVC_ENCPARAM_FLAT_IMAGE_MODE_FINE          0x0F22
+#define     AVC_ENCPARAM_FLAT_IMAGE_MODE_FINEST        0x0F44
+
+#define     AVC_INT_ENC_END_EN           0x0080
+#define     AVC_INT_DEC_END_EN           0x0040
+#define     AVC_INT_DEC_ERR_EN           0x0020
+#define     AVC_INT_ENC_PIC_END_EN       0x0010
+#define     AVC_INT_DEC_PIC_END_EN       0x0008
+#define     AVC_INT_HEAD_DEC_END_EN      0x0004
+#define     AVC_INT_REF_PIC_MANUAL_EN    0x0002
+
+/* err_nal_en */
+
+#define     AVC_ERR_NAL_END             0x0008
+#define     AVC_ERR_FORBIDDEN_ZERO_BIT  0x0004
+#define     AVC_ERR_REF_IDC             0x0002
+#define     AVC_ERR_NAL_UNIT_TYPE       0x0001
+
+/* err_sps_en */
+
+#define     AVC_HRD_ERROR                              0x2000
+#define     AVC_VUI_ERROR                              0x1000
+#define     AVC_SPS_OTHER_ERROR                        0x0800
+#define     AVC_ERR_DIRECT_8X8_INFERENCE_FLAG          0x0400
+#define     AVC_ERR_MB_ADAPTIVE_FRAME_FIELD_FLAG       0x0200
+#define     AVC_ERR_PROFILE                            0x0100
+#define     AVC_ERR_LEVEL_IDC                          0x0080
+#define     AVC_ERR_SEQ_PARAMETER_SET_ID               0x0040
+#define     AVC_ERR_LOG2_MAX_FRAME_NUM_MINUS4          0x0020
+#define     AVC_ERR_PIC_ORDER_CNT_TYPE                 0x0010
+#define     AVC_ERR_LOG2_MAX_PIC_ORDER_CNT_LSB_MINUS4  0x0008
+#define     AVC_ERR_NUM_REF_FRAMES                     0x0004
+#define     AVC_ERR_PIC_WIDTH_IN_MBS_MINUS1            0x0002
+#define     AVC_ERR_PIC_HEIGHT_IN_MAP_UNITS_MINUS1     0x0001
+
+/* err_pps_en */
+
+#define     AVC_ERR_PPS_PPS_ID             0x0200
+#define     AVC_ERR_PPS_SPS_ID             0x0100
+#define     AVC_ERR_PPS_ENTROPY_FLAG       0x0080
+#define     AVC_ERR_PPS_NUM_SLICE          0x0040
+#define     AVC_ERR_PPS_NUM_REF_IDX        0x0020
+#define     AVC_ERR_PPS_WEIGHTED_FLAG      0x0010
+#define     AVC_ERR_PPS_WEIGHTED_IDC       0x0008
+#define     AVC_ERR_PPS_PIC_INIT_Q         0x0004
+#define     AVC_ERR_PPS_CQP_IDX_OFS        0x0002
+#define     AVC_ERR_PPS_REDUNDANT_FLAG     0x0001
+
+/* err_sh_en */
+
+#define     AVC_ERR_SH_END                 0x0200
+#define     AVC_ERR_SH_SLICE_TYPE          0x0100
+#define     AVC_ERR_SH_PPS_ID              0x0080
+#define     AVC_ERR_SH_IDR_PIC_ID          0x0040
+#define     AVC_ERR_SH_NUM_REF_IDX_L0      0x0020
+#define     AVC_ERR_SH_DIS_DBF_IDC         0x0010
+#define     AVC_ERR_SH_SLC_A_C0_OFS        0x0008
+#define     AVC_ERR_SH_SLC_BETA_OFS        0x0004
+#define     AVC_ERR_SH_ROPN_IDC            0x0002
+#define     AVC_ERR_SH_MMCO                0x0001
+
+
+/* err_sd_en */
+
+#define     AVC_ERR_1ST_MB_IN_SLICE       0x0800
+#define     AVC_ERR_SD_END                0x0400
+#define     AVC_ERR_SD_MB_TYPE            0x0200
+#define     AVC_ERR_SD_CBP                0x0100
+#define     AVC_ERR_SD_MBP_REF_IDX        0x0080
+#define     AVC_ERR_SD_MBP_ICPM           0x0040
+#define     AVC_ERR_SD_SMB_REF_IDX        0x0020
+#define     AVC_ERR_ZSL_LT_RUN            0x0010
+#define     AVC_ERR_CV_COEFT              0x0008
+#define     AVC_ERR_CV_LV_PREFIX          0x0004
+#define     AVC_ERR_CV_TZEROS             0x0002
+#define     AVC_ERR_CV_RUN_BEFORE         0x0001
+
+/* header_end_en */
+
+
+#define     AVC_SPS_END                   0x0100
+#define     AVC_PPS_END                   0x0080
+#define     AVC_SEI_END                   0x0040
+#define     AVC_AUD_END                   0x0020
+#define     AVC_EOSEQ_END                 0x0010
+#define     AVC_SH_END                    0x0008
+#define     AVC_END_OF_STREAM_END         0x0004
+#define     AVC_FILLER_DATA_END           0x0002
+
+/* ref_hw_ctrl */
+
+#define     AVC_REF_HW_CTRL_HW            0x0001
+#define     AVC_REF_HW_CTRL_SW            0x0000
+
+/* dec_error_conceal */
+
+#define     AVC_DEC_ERROR_CONCEAL_ON      0x0001
+#define     AVC_DEC_ERROR_CONCEAL_OFF     0x0000
+
+/* SEI payloadType */
+
+#define     AVC_SEI_RAW_OUTPUT21          0x00200000
+#define     AVC_SEI_RAW_OUTPUT20          0x00100000
+#define     AVC_SEI_RAW_OUTPUT19          0x00080000
+#define     AVC_SEI_RAW_OUTPUT18          0x00040000
+#define     AVC_SEI_RAW_OUTPUT17          0x00020000
+#define     AVC_SEI_RAW_OUTPUT16          0x00010000
+#define     AVC_SEI_RAW_OUTPUT15          0x00008000
+#define     AVC_SEI_RAW_OUTPUT14          0x00004000
+#define     AVC_SEI_RAW_OUTPUT13          0x00002000
+#define     AVC_SEI_RAW_OUTPUT12          0x00001000
+#define     AVC_SEI_RAW_OUTPUT11          0x00000800
+#define     AVC_SEI_RAW_OUTPUT10          0x00000400
+#define     AVC_SEI_RAW_OUTPUT9           0x00000200
+#define     AVC_SEI_RAW_OUTPUT8           0x00000100
+#define     AVC_SEI_RAW_OUTPUT7           0x00000080
+#define     AVC_SEI_RAW_OUTPUT6           0x00000040
+#define     AVC_SEI_RAW_OUTPUT5           0x00000020
+#define     AVC_SEI_RAW_OUTPUT4           0x00000010
+#define     AVC_SEI_RAW_OUTPUT3           0x00000008
+#define     AVC_SEI_RAW_OUTPUT2           0x00000004
+#define     AVC_SEI_RAW_OUTPUT1           0x00000002
+#define     AVC_SEI_RAW_OUTPUT0           0x00000001
+
+#define     AVC_PLANAR_SEL_PLANAR         0x00000000
+#define     AVC_PLANAR_SEL_SEMI_PLANAR    0x00000001
+
+#define AVC_BYTELANE_Y               8
+#define AVC_BYTELANE_C               0
+
+#define AVC_BYTELANE(HH, HL, LH, LL, YC)     \
+	((((HH) << 6) | ((HL) << 4) | ((LH) << 2) | (LL)) << (YC))
+
+#define AVC_BYTELANE_Y0123    AVC_BYTELANE(0, 1, 2, 3, AVC_BYTELANE_Y)
+#define AVC_BYTELANE_Y0132    AVC_BYTELANE(0, 1, 3, 2, AVC_BYTELANE_Y)
+#define AVC_BYTELANE_Y0213    AVC_BYTELANE(0, 2, 1, 3, AVC_BYTELANE_Y)
+#define AVC_BYTELANE_Y0231    AVC_BYTELANE(0, 2, 3, 1, AVC_BYTELANE_Y)
+#define AVC_BYTELANE_Y0312    AVC_BYTELANE(0, 3, 1, 2, AVC_BYTELANE_Y)
+#define AVC_BYTELANE_Y0321    AVC_BYTELANE(0, 3, 2, 1, AVC_BYTELANE_Y)
+#define AVC_BYTELANE_Y1023    AVC_BYTELANE(1, 0, 2, 3, AVC_BYTELANE_Y)
+#define AVC_BYTELANE_Y1032    AVC_BYTELANE(1, 0, 3, 2, AVC_BYTELANE_Y)
+#define AVC_BYTELANE_Y1203    AVC_BYTELANE(1, 2, 0, 3, AVC_BYTELANE_Y)
+#define AVC_BYTELANE_Y1230    AVC_BYTELANE(1, 2, 3, 0, AVC_BYTELANE_Y)
+#define AVC_BYTELANE_Y1302    AVC_BYTELANE(1, 3, 0, 2, AVC_BYTELANE_Y)
+#define AVC_BYTELANE_Y1320    AVC_BYTELANE(1, 3, 2, 0, AVC_BYTELANE_Y)
+#define AVC_BYTELANE_Y2013    AVC_BYTELANE(2, 0, 1, 3, AVC_BYTELANE_Y)
+#define AVC_BYTELANE_Y2031    AVC_BYTELANE(2, 0, 3, 1, AVC_BYTELANE_Y)
+#define AVC_BYTELANE_Y2103    AVC_BYTELANE(2, 1, 0, 3, AVC_BYTELANE_Y)
+#define AVC_BYTELANE_Y2130    AVC_BYTELANE(2, 1, 3, 0, AVC_BYTELANE_Y)
+#define AVC_BYTELANE_Y2301    AVC_BYTELANE(2, 3, 0, 1, AVC_BYTELANE_Y)
+#define AVC_BYTELANE_Y2310    AVC_BYTELANE(2, 3, 1, 0, AVC_BYTELANE_Y)
+#define AVC_BYTELANE_Y3012    AVC_BYTELANE(3, 0, 1, 2, AVC_BYTELANE_Y)
+#define AVC_BYTELANE_Y3021    AVC_BYTELANE(3, 0, 2, 1, AVC_BYTELANE_Y)
+#define AVC_BYTELANE_Y3102    AVC_BYTELANE(3, 1, 0, 2, AVC_BYTELANE_Y)
+#define AVC_BYTELANE_Y3120    AVC_BYTELANE(3, 1, 2, 0, AVC_BYTELANE_Y)
+#define AVC_BYTELANE_Y3201    AVC_BYTELANE(3, 2, 0, 1, AVC_BYTELANE_Y)
+#define AVC_BYTELANE_Y3210    AVC_BYTELANE(3, 2, 1, 0, AVC_BYTELANE_Y)
+
+
+#define AVC_BYTELANE_C0123    AVC_BYTELANE(0, 1, 2, 3, AVC_BYTELANE_C)
+#define AVC_BYTELANE_C0132    AVC_BYTELANE(0, 1, 3, 2, AVC_BYTELANE_C)
+#define AVC_BYTELANE_C0213    AVC_BYTELANE(0, 2, 1, 3, AVC_BYTELANE_C)
+#define AVC_BYTELANE_C0231    AVC_BYTELANE(0, 2, 3, 1, AVC_BYTELANE_C)
+#define AVC_BYTELANE_C0312    AVC_BYTELANE(0, 3, 1, 2, AVC_BYTELANE_C)
+#define AVC_BYTELANE_C0321    AVC_BYTELANE(0, 3, 2, 1, AVC_BYTELANE_C)
+#define AVC_BYTELANE_C1023    AVC_BYTELANE(1, 0, 2, 3, AVC_BYTELANE_C)
+#define AVC_BYTELANE_C1032    AVC_BYTELANE(1, 0, 3, 2, AVC_BYTELANE_C)
+#define AVC_BYTELANE_C1203    AVC_BYTELANE(1, 2, 0, 3, AVC_BYTELANE_C)
+#define AVC_BYTELANE_C1230    AVC_BYTELANE(1, 2, 3, 0, AVC_BYTELANE_C)
+#define AVC_BYTELANE_C1302    AVC_BYTELANE(1, 3, 0, 2, AVC_BYTELANE_C)
+#define AVC_BYTELANE_C1320    AVC_BYTELANE(1, 3, 2, 0, AVC_BYTELANE_C)
+#define AVC_BYTELANE_C2013    AVC_BYTELANE(2, 0, 1, 3, AVC_BYTELANE_C)
+#define AVC_BYTELANE_C2031    AVC_BYTELANE(2, 0, 3, 1, AVC_BYTELANE_C)
+#define AVC_BYTELANE_C2103    AVC_BYTELANE(2, 1, 0, 3, AVC_BYTELANE_C)
+#define AVC_BYTELANE_C2130    AVC_BYTELANE(2, 1, 3, 0, AVC_BYTELANE_C)
+#define AVC_BYTELANE_C2301    AVC_BYTELANE(2, 3, 0, 1, AVC_BYTELANE_C)
+#define AVC_BYTELANE_C2310    AVC_BYTELANE(2, 3, 1, 0, AVC_BYTELANE_C)
+#define AVC_BYTELANE_C3012    AVC_BYTELANE(3, 0, 1, 2, AVC_BYTELANE_C)
+#define AVC_BYTELANE_C3021    AVC_BYTELANE(3, 0, 2, 1, AVC_BYTELANE_C)
+#define AVC_BYTELANE_C3102    AVC_BYTELANE(3, 1, 0, 2, AVC_BYTELANE_C)
+#define AVC_BYTELANE_C3120    AVC_BYTELANE(3, 1, 2, 0, AVC_BYTELANE_C)
+#define AVC_BYTELANE_C3201    AVC_BYTELANE(3, 2, 0, 1, AVC_BYTELANE_C)
+#define AVC_BYTELANE_C3210    AVC_BYTELANE(3, 2, 1, 0, AVC_BYTELANE_C)
+
+
+struct avc_mem_num_ref_idx_set_t {
+	unsigned short set_ref_idx0;
+	unsigned short set_ref_idx1;
+	unsigned short set_ref_idx2;
+	unsigned short set_ref_idx3;
+	unsigned short set_ref_idx4;
+	unsigned short set_ref_idx5;
+	unsigned short set_ref_idx6;
+	unsigned short set_ref_idx7;
+	unsigned short set_ref_idx8;
+	unsigned short set_ref_idx9;
+	unsigned short set_ref_idx10;
+	unsigned short set_ref_idx11;
+	unsigned short set_ref_idx12;
+	unsigned short set_ref_idx13;
+	unsigned short set_ref_idx14;
+	unsigned short set_ref_idx15;
+};
+
+
+struct avc_user_set_parameter_t {
+	unsigned short set_int_en;
+	unsigned short set_err_nal_en;
+	unsigned short set_err_sps_en;
+	unsigned short set_err_pps_en;
+	unsigned short set_err_sh_en;
+	unsigned short set_err_sd_en;
+	unsigned short set_header_end_en;
+	unsigned short set_ref_hw_ctrl;
+	unsigned short set_dec_error_conceal;
+	unsigned short set_mem_num_wr;
+	struct avc_mem_num_ref_idx_set_t mem_num_ref_idx;
+	unsigned int set_sei_raw_output;
+	unsigned int set_planar_sel;
+	unsigned int set_bytelane;
+};
+
+/*
+ * Command for AVC_IOCSREGCMD
+ */
+
+enum avc_command_type_t {
+	avc_command_encode_start,
+	avc_command_encode_reactivate,
+	avc_command_decode_start,
+	avc_command_decode_reactivate,
+	avc_command_stream_change,
+	avc_command_reset
+};
+
+struct avc_command_t {
+	unsigned short command;
+	unsigned short last_frame;
+};
+
+/*
+ * Register access for AVC_IOCSREGISTER/AVC_IOCGREGISTER
+ */
+
+struct avc_register_access_t {
+	unsigned int address;
+	unsigned int value;
+};
+
+/*
+ * Driver version for AVC_IOCGVERSION
+ */
+
+struct avc_driver_version_t {
+	int major;
+	int minor;
+	int local;
+};
+
+/*
+ * Interruption information
+ */
+
+enum action_state_t {
+	action_state_standby,
+	action_state_compressing,
+	action_state_decompressing,
+	action_state_reserved
+};
+
+enum pic_type_t {
+	pic_type_I_slice,
+	pic_type_P_slice,
+	pic_type_reserved1,
+	pic_type_reserved2
+};
+
+struct avc_interrupt_t {
+	union {
+		unsigned int l;
+		struct {
+			unsigned int reserved:2; /* [1:0] */
+			unsigned int int_head_dec_end:1; /* [2] */
+			unsigned int int_dec_pic_end:1;
+			unsigned int int_enc_pic_end:1;
+			unsigned int int_dec_err:1;
+			unsigned int int_dec_end:1;
+			unsigned int int_enc_end:1; /* [7] */
+		} b;
+	} interrupt;
+
+	unsigned int int_buf_full; /* stream buffer full */
+
+	union {
+		unsigned int l;
+		struct {
+			unsigned int reserved:1; /* [0] */
+			unsigned int FD:1; /* [1] filler data */
+			unsigned int EO:1; /* [2] end of stream */
+			unsigned int SH:1;
+			unsigned int EOSEQ:1;
+			unsigned int AUD:1;
+			unsigned int SEI:1;
+			unsigned int PPS:1;
+			unsigned int SPS:1; /* [8] */
+		} b;
+	} decode_header;
+
+	unsigned int payload_type;
+
+	struct {
+		union {
+			unsigned int l;
+			struct {
+				unsigned int err_nal_unit_type:1; /* [0] */
+				unsigned int err_ref_idc:1;
+				unsigned int err_forbidden_zero_bit:1;
+				unsigned int err_nal_end:1; /* [3] */
+			} b;
+		} err_nal;
+
+		union {
+			unsigned int l;
+			struct {
+				unsigned int
+				err_pic_height_in_map_units_minus1 : 1;
+				/* [0] */
+				unsigned int err_pic_width_in_mbs_minus1:1;
+				unsigned int err_num_ref_frames:1;
+				unsigned int
+				err_log2_max_pic_order_cnt_lsb_minus4 : 1;
+				unsigned int err_pic_order_cnt_type:1;
+				unsigned int err_log2_max_frame_num_minus4:1;
+				unsigned int err_seq_parameter_set_id:1;
+				unsigned int err_level_idc:1;
+				unsigned int err_profile:1;
+				unsigned int
+				err_mb_adaptive_frame_field_flag : 1;
+				unsigned int err_direct_8x8_inference_flag:1;
+				unsigned int SPS_other_error:1;
+				unsigned int VUI_error:1;
+				unsigned int HRD_error:1; /* [13] */
+			} b;
+		} err_sps;
+
+		union {
+			unsigned int l;
+			struct {
+				unsigned int err_pps_redundant_flag:1; /* [0] */
+				unsigned int err_pps_cqp_idx_ofs:1;
+				unsigned int err_pps_pic_init_q:1;
+				unsigned int err_pps_weighted_idc:1;
+				unsigned int err_pps_weighted_flag:1;
+				unsigned int err_pps_num_ref_idx:1;
+				unsigned int err_pps_num_slice:1;
+				unsigned int err_pps_entropy_flag:1;
+				unsigned int err_pps_sps_id:1;
+				unsigned int err_pps_pps_id:1; /* [9] */
+			} b;
+		} err_pps;
+
+		union {
+			unsigned int l;
+			struct {
+				unsigned int err_sh_mmco:1; /* [0] */
+				unsigned int err_sh_ropn_idc:1;
+				unsigned int err_sh_slc_beta_ofs:1;
+				unsigned int err_sh_slc_a_c0_ofs:1;
+				unsigned int err_sh_dis_dbf_idc:1;
+				unsigned int err_sh_num_ref_idx_l0:1;
+				unsigned int err_sh_idr_pic_id:1;
+				unsigned int err_sh_pps_id:1;
+				unsigned int err_sh_slice_type:1;
+				unsigned int err_sh_end:1; /* [9] */
+			} b;
+		} err_sh;
+
+		union {
+			unsigned int l;
+			struct {
+				unsigned int err_cv_run_before:1; /* [0] */
+				unsigned int err_cv_tzeros:1;
+				unsigned int err_cv_lv_prefix:1;
+				unsigned int err_cv_coeft:1;
+				unsigned int err_zsl_lt_run:1;
+				unsigned int err_sd_smb_ref_idx:1;
+				unsigned int err_sd_mbp_icpm:1;
+				unsigned int err_sd_mbp_ref_idx:1;
+				unsigned int err_sd_cbp:1;
+				unsigned int err_sd_mb_type:1;
+				unsigned int err_sd_end:1;
+				unsigned int err_1st_mb_in_slice:1; /* [11] */
+			} b;
+		} err_sd;
+
+		unsigned int macro_block_number; /* [10:0] */
+	} decode_error;
+
+	struct {
+		unsigned short action_state;
+		unsigned short pic_type; /* [1:0] */
+	} status;
+};
+
+
+/*
+ * AUD (Access Unit Delimiter)
+ */
+
+struct aud_parameters_t {
+	unsigned short primary_pic_type;
+	unsigned short:16;    /* alignment */
+};
+
+
+/*
+ * HRD (Hypothetical Reference Decoder)
+ */
+
+#define max_cpb_cnt 32
+
+struct hrd_parameters_t {
+	unsigned short cpb_cnt_minus1; /* [4:0] */
+
+	unsigned short bit_rate_scale;
+	unsigned short cpb_size_scale; /* [3:0] */
+
+	unsigned short padding1;
+
+	unsigned int bit_rate_value_minus1[max_cpb_cnt];
+	unsigned int cpb_size_value_minus1[max_cpb_cnt];
+	unsigned short cbr_flag[max_cpb_cnt]; /* [0] */
+
+	unsigned short initial_cpb_removal_delay_length_minus1; /* [4:0] */
+
+	unsigned short cpb_removal_delay_length_minus1;
+	unsigned short dpb_output_delay_length_minus1;
+	unsigned short time_offset_length; /* [4:0] */
+};
+
+/*
+ * VUI (Video Usability Information)
+ */
+
+#define Extended_SAR 255
+
+struct vui_parameters_t {
+	unsigned short aspect_ratio_info_present_flag; /* [0] */
+	unsigned short aspect_ratio_idc; /* [7:0] */
+	unsigned short sar_width; /* [15:0] */
+	unsigned short sar_height; /* [15:0] */
+	unsigned short overscan_info_present_flag; /* [0] */
+	unsigned short overscan_appropriate_flag; /* [0] */
+	unsigned short video_signal_type_present_flag; /* [0] */
+
+	unsigned short video_format;
+	unsigned short video_full_range_flag;
+	unsigned short colour_description_present_flag;
+
+	unsigned short colour_primaries; /* [7:0] */
+	unsigned short transfer_characteristics;
+	unsigned short matrix_coefficients; /* [7:0] */
+	unsigned short chroma_loc_info_present_flag; /* [0] */
+	unsigned short chroma_sample_loc_type_top_field; /* [2:0] */
+	unsigned short chroma_sample_loc_type_bottom_field; /* [2:0] */
+	unsigned short timing_info_present_flag; /* [0] */
+	unsigned short padding1;
+
+	unsigned int num_units_in_tick;
+	unsigned int time_scale;
+
+	unsigned short fixed_frame_rate_flag; /* [0] */
+
+	unsigned short nal_hrd_parameters_present_flag; /* [0] */
+	struct hrd_parameters_t nal_hrd_parameters;
+
+	unsigned short padding2;
+
+	unsigned short vcl_hrd_parameters_present_flag; /* [0] */
+	struct hrd_parameters_t vcl_hrd_parameters;
+
+	unsigned short low_delay_hrd_flag; /* [0] */
+
+	unsigned short pic_struct_present_flag;
+	unsigned short bitstream_restriction_flag; /* [0] */
+
+	unsigned short motion_vectors_over_pic_boundaries_flag; /* [0] */
+	unsigned short max_bytes_per_pic_denom; /* [4:0] */
+	unsigned short max_bits_per_mb_denom; /* [4:0] */
+	unsigned short log2_max_mv_length_horizontal; /* [4:0] */
+	unsigned short log2_max_mv_length_vertical; /* [4:0] */
+	unsigned short num_reorder_frames; /* [4:0] */
+	unsigned short max_dec_frame_buffering; /* [4:0] */
+};
+
+/*
+ * SPS (Sequence Parameter Set)
+ */
+
+#define max_num_ref_frames_in_pic_order_nct_cycle 256
+
+struct seq_parameter_set_rbsp_t {
+	unsigned short profile_idc; /* [7:0] */
+
+	unsigned short constraint_set0_flag;
+	unsigned short constraint_set1_flag;
+	unsigned short constraint_set2_flag;
+	unsigned short level_idc;
+
+	unsigned short seq_parameter_set_id; /* [4:0] */
+	unsigned short log2_max_frame_num_minus4; /* [3:0] */
+	unsigned short pic_order_cnt_type; /* [1:0] */
+	unsigned short log2_max_pic_order_cnt_lsb_minus4; /* [3:0] */
+	unsigned short delta_pic_order_always_zero_flag; /* [0] */
+
+	unsigned int offset_for_non_ref_pic;
+	unsigned int offset_for_top_to_bottom_field;
+
+	unsigned short num_ref_frames_in_pic_order_nct_cycle; /* [7:0] */
+	unsigned short padding1;
+
+	unsigned int
+	offset_for_ref_frame[max_num_ref_frames_in_pic_order_nct_cycle];
+
+	unsigned short num_ref_frames; /* [15:0]->[4:0] */
+	unsigned short gaps_in_frame_num_value_allowed_flag; /* [0] */
+	unsigned short pic_width_in_mbs_minus1; /* [5:0] */
+	unsigned short pic_height_in_maps_units_minus1; /* [5:0] */
+	unsigned short frame_mbs_only_flag; /* [0] */
+	unsigned short mb_adaptive_frame_field_flag; /* [0] */
+
+	unsigned short direct_8x8_inference_flag;
+	unsigned short frame_cropping_flag;
+
+	unsigned short frame_crop_left_offset;  /* [9:0] */
+	unsigned short frame_crop_right_offset; /* [9:0] */
+	unsigned short frame_crop_top_offset;   /* [9:0] */
+	unsigned short frame_crop_bottom_offset; /* [9:0] */
+	unsigned short vui_parameters_present_flag; /* [0] */
+	unsigned short padding2;
+
+	struct vui_parameters_t vui_parameters;
+};
+
+
+/*
+ * PPS (Picture Parameter Set)
+ */
+
+#define max_num_slice_groups 8
+#define max_pic_size_in_map_units 2048
+
+struct pic_parameter_set_rbsp_t {
+	unsigned short pic_parameter_set_id; /* [7:0] */
+	unsigned short seq_parameter_set_id; /* [4:0] */
+
+	unsigned short entropy_coding_mode_flag;
+	unsigned short pic_order_present_flag;
+
+	unsigned short num_slice_groups_minus1; /* [2:0] */
+	unsigned short slice_group_map_type; /* [2:0] */
+
+	unsigned short run_length_minus1[max_num_slice_groups]; /* [10:0] */
+	unsigned short top_left[max_num_slice_groups];       /* [10:0] */
+	unsigned short bottom_right[max_num_slice_groups];   /* [10:0] */
+	unsigned short slice_group_change_direction_flag; /* [0] */
+	unsigned short slice_group_change_rate_minus1; /* [10:0] */
+	unsigned short pic_size_in_map_units_minus1; /* [10:0] */
+
+	unsigned char slice_group_id[max_pic_size_in_map_units]; /* [2:0] */
+
+	unsigned short num_ref_idx_l0_active_minus1; /* [4:0] */
+	unsigned short num_ref_idx_l1_active_minus1; /* [4:0] */
+
+	unsigned short weighted_pred_flag; /* [2] */
+	unsigned short weighted_bipred_idc; /* [1:0] */
+
+	unsigned short pic_init_qp_minus26; /* [15:0] */
+	unsigned short pic_init_qs_minus26; /* [15:0] */
+	unsigned short chroma_qp_index_offset; /* [15:0] */
+	unsigned short deblocking_filter_control_present_flag; /* [2] */
+	unsigned short constrained_intra_flag; /* [1] */
+	unsigned short redundant_pic_cnt_present_flag; /* [0] */
+
+	unsigned short:16;    /* padding */
+};
+
+
+/*
+ * SH (Slice Header)
+ */
+
+#define max_reordering_of_pic 16
+
+struct ref_pic_list_reordering_t {
+	unsigned short sh_slice_type;
+
+	unsigned short ref_pic_list_reordering_flag_l0; /* [0] */
+
+	struct {
+		unsigned short reordering_of_pic_nums_idc;
+
+		unsigned short:16; /* padding */
+
+		union {
+			unsigned short abs_diff_pic_num_minus1;
+			unsigned short long_term_pic_num; /* [4:0] */
+			unsigned int:32; /* alignment */
+		} u;
+	} rop[max_reordering_of_pic + 1];
+};
+
+#define max_memory_management_control_operation 6
+
+struct dec_ref_pic_marking_t {
+	unsigned short nal_unit_type;
+
+	unsigned short no_output_of_prior_pics_flag;
+	unsigned short long_term_reference_flag;
+	unsigned short adaptive_ref_pic_marking_mode_flag;
+
+	struct {
+		unsigned short memory_management_control_operation; /* [2:0] */
+
+		unsigned short difference_of_pic_nums_minus1; /* [15:0] */
+		unsigned short long_term_pic_num; /* [15:0] */
+		unsigned short long_term_frame_idx; /* [6:0] */
+		unsigned short max_long_term_frame_idx_plus1; /* [15:0] */
+
+		unsigned short:16; /* padding */
+	} mmco[max_memory_management_control_operation + 1];
+};
+
+#define is_slice_type_P(_x)  ((_x) == 0 || (_x) == 5)
+#define is_slice_type_B(_x)  ((_x) == 1 || (_x) == 6)
+#define is_slice_type_I(_x)  ((_x) == 2 || (_x) == 7)
+#define is_slice_type_SP(_x) ((_x) == 3 || (_x) == 8)
+#define is_slice_type_SI(_x) ((_x) == 4 || (_x) == 9)
+
+struct slice_header_t {
+	unsigned short nal_ref_idc;
+	unsigned short nal_unit_type;
+	unsigned short sps_pic_order_cnt_type;
+	unsigned short sps_delta_pic_order_always_zero_flag;
+	unsigned short sps_frame_mbs_only_flag;
+	unsigned short pps_pic_order_present_flag;
+	unsigned short pps_deblocking_filter_control_present_flag;
+
+	unsigned short slice_type; /* [3:0] */
+	unsigned short pic_parameter_set_id; /* [7:0] */
+	unsigned short frame_num; /* [15:0] */
+	unsigned short field_pic_flag; /* [0] */
+	unsigned short bottom_field_flag; /* [0] */
+	unsigned short idr_pic_id;    /* [15:0] */
+	unsigned short pic_order_cnt_lsb; /* [15:0] */
+
+	unsigned int delta_pic_order_cnt_bottom;
+	unsigned int delta_pic_order_cnt[2];
+
+	unsigned short num_ref_idx_active_override_flag; /* [0] */
+	unsigned short num_ref_idx_l0_active_minus1; /* [4:0] */
+
+	struct ref_pic_list_reordering_t ref_pic_list_reordering;
+	struct dec_ref_pic_marking_t dec_ref_pic_marking;
+
+	unsigned short slice_qp_delta; /* [15:0] */
+	unsigned short slice_qs_delta; /* [15:0] */
+	unsigned short disable_deblocking_filter_idc; /* [1:0] */
+	unsigned short slice_alpha_c0_offset_div2; /* [15:0] */
+	unsigned short slice_beta_offset_div2; /* [15:0] */
+
+	unsigned short:16;    /* padding */
+};
+
+
+/*
+ * SEI (Supplemental Enhancement Information)
+ */
+
+enum sei_payloadtype_t {
+	buffering_period = 0,
+	pic_timing,
+	pan_scan_rect,
+	filler_payload,
+	user_data_registered_itu_t_t35,
+	user_data_unregistered,
+	recovery_point,
+	dec_ref_pic_marking_repetition,
+	spare_pic,
+	scene_info,
+	sub_seq_info, /* 10 */
+	sub_seq_layer_characteristics,
+	sub_seq_characteristics,
+	full_frame_freeze,
+	full_frame_freeze_release, /* 14 not supported */
+	full_frame_snapshot,
+	progressive_refinement_segment_start,
+	progressive_refinement_segment_end,
+	motion_constrained_slice_group_set,
+	film_grain_characteristics,
+	deblocking_filter_display_preference, /* 20 */
+	stereo_video_info
+};
+
+struct sei_decode_flags_t {
+	unsigned short NalHrdBpPresentFlag;
+	unsigned short VclHrdBpPresentFlag;
+	unsigned short CpbDpbDelaysPresentFlag;
+
+	unsigned short:16;    /* padding */
+};
+
+/* SEI 0: buffering_period */
+
+struct buffering_period_t {
+	unsigned short NalHrdBpPresentFlag;
+	unsigned short VclHrdBpPresentFlag;
+	unsigned short nal_hrd_cpb_cnt_minus1;
+	unsigned short vcl_hrd_cpb_cnt_minus1;
+
+	unsigned short seq_parameter_set_id; /* [4:0] */
+	unsigned short padding1;
+
+	unsigned int nal_initial_cpb_removal_delay[max_cpb_cnt];
+	unsigned int nal_initial_cpb_removal_delay_offset[max_cpb_cnt];
+	unsigned int vcl_initial_cpb_removal_delay[max_cpb_cnt];
+	unsigned int vcl_initial_cpb_removal_delay_offset[max_cpb_cnt];
+};
+
+/* SEI 1: pic_timing */
+
+#define NumClockTS 3
+
+struct pic_timing_t {
+	unsigned short CpbDpbDelaysPresentFlag;
+	unsigned short vui_pic_struct_present_flag;
+
+	unsigned int cpb_removal_delay;
+	unsigned int dpb_output_delay;
+
+	unsigned short pic_struct; /* [3:0] */
+	unsigned short padding1;
+
+	struct {
+		unsigned short clock_timestamp_flag; /* [NumClockTS-1:0] */
+
+		unsigned short ct_type;
+		unsigned short nuit_field_based_flag;
+		unsigned short counting_type; /* [4:0] */
+
+		unsigned short full_timestamp_flag;
+		unsigned short discontinuity_flag;
+		unsigned short cnt_dropped_flag;
+		unsigned short n_frames;
+
+		unsigned short seconds_value;
+		unsigned short minutes_value;
+		unsigned short hours_value;
+
+		unsigned short seconds_flag;
+		unsigned short minutes_flag;
+		unsigned short hours_flag;
+
+		unsigned int time_offset;
+	} ct[NumClockTS];
+
+};
+
+/* SEI 2: pan_scan_rect */
+
+#define max_pan_scan_cnt 4
+
+struct pan_scan_rect_t {
+	unsigned int pan_scan_rect_id;
+	unsigned short pan_scan_rect_cancel_flag; /* [0] */
+	unsigned short pan_scan_cnt_minus1; /* [1:0] */
+
+	struct {
+		unsigned int left_offset;
+		unsigned int right_offset;
+		unsigned int top_offset;
+		unsigned int bottom_offset;
+	} psr[max_pan_scan_cnt];
+
+	unsigned short pan_scan_rect_repetition_period; /* [14:0] */
+};
+
+/* SEI 3: filler_payload */
+
+struct filler_payload_t {
+	unsigned int payloadSize;
+};
+
+/* SEI 4: user_data_registered_itu_t_t35 */
+
+struct user_data_registered_itu_t_t35_t {
+	unsigned short itu_t_t35_country_code;
+	unsigned short itu_t_t35_payload_byte; /* [7:0] */
+	unsigned short itu_t_t35_country_code_extension_byte; /* [7:0] */
+
+	/* itu_t_t35_payload_byte[]; */
+
+	unsigned short:16;    /* padding */
+};
+
+/* SEI 5: user_data_unregistered */
+
+struct user_data_unregistered_t {
+	unsigned short uuid_iso_iec_11578[8]; /* [127:0] */
+
+	/* user_data_payload_byte[]; */
+};
+
+/* SEI 6: recovery_point */
+
+struct recovery_point_t {
+	unsigned short recovery_frame_cnt; /* [15:0] */
+	unsigned short exact_match_flag;
+	unsigned short broken_link_flag;
+	unsigned short changing_slice_group_idc; /* [1:0] */
+};
+
+/* SEI 7: dec_ref_pic_marking_repetition */
+
+struct dec_ref_pic_marking_repetition_t {
+	unsigned short sps_frame_mbs_only_flag;
+	unsigned short padding1;
+
+	unsigned short original_idr_flag; /* [0] */
+	unsigned short original_frame_num; /* [15:0] */
+	unsigned short original_field_pic_flag; /* [0] */
+	unsigned short original_bottom_field_flag; /* [0] */
+
+	struct dec_ref_pic_marking_t dec_ref_pic_marking;
+};
+
+/* SEI 8: spare_pic */
+
+#define max_num_spare_pics 16
+
+struct spare_pic_t {
+	unsigned short pps_pic_size_in_map_units; /* [10:0] */
+	unsigned short padding1;
+
+	unsigned short target_frame_num; /* [15:0] */
+	unsigned short spare_field_flag; /* [0] */
+	unsigned short target_bottom_field_flag; /* [0] */
+	unsigned short num_spare_pics_minus1; /* [3:0] */
+
+	struct {
+		unsigned short delta_spare_frame_num; /* [15:0] */
+		unsigned short spare_bottom_field_flag; /* [0] */
+		unsigned short spare_area_idc; /* [1:0] */
+
+		unsigned short:16; /* padding */
+
+		union {
+			unsigned short
+			spare_unit_flag[max_pic_size_in_map_units]; /* [0] */
+			unsigned short
+			zero_run_length[max_pic_size_in_map_units]; /* [10:0] */
+			unsigned int:32; /* alignment */
+		} u;
+	} spare_pics[max_num_spare_pics];
+};
+
+/* SEI 9: scene_info */
+
+struct scene_info_t {
+	unsigned short scene_info_present_flag; /* [0] */
+	unsigned short padding1;
+	unsigned int scene_id;
+	unsigned short scene_transition_type; /* [2:0] */
+	unsigned int second_scene_id;
+};
+
+/* SEI 10: sub_seq_info */
+
+struct sub_seq_info_t {
+	unsigned short sub_seq_layer_num; /* [7:0] */
+	unsigned short sub_seq_id; /* [15:0] */
+	unsigned short first_ref_pic_flag;
+	unsigned short leading_non_ref_pic_flag;
+	unsigned short last_pic_flag;
+	unsigned short sub_seq_frame_num_flag;
+	unsigned short sub_seq_frame_num;
+
+	unsigned short:16;    /* padding */
+};
+
+/* SEI 11: sub_seq_layer_characteristics */
+
+struct sub_seq_layer_characteristics_t {
+	unsigned short num_sub_seq_layers_minus1; /* [7:0] */
+	unsigned short accurate_statistics_flag; /* [0] */
+	unsigned short average_bit_rate; /* [15:0] */
+	unsigned short average_frame_rate; /* [15:0] */
+};
+
+/* SEI 12: sub_seq_characteristics */
+
+struct sub_seq_characteristics_t {
+	unsigned short sub_seq_layer_num; /* [7:0] */
+	unsigned short sub_seq_id; /* [15:0] */
+	unsigned short duration_flag; /* [0] */
+	unsigned short padding1;
+	unsigned int sub_seq_duration;
+	unsigned short average_rate_flag;
+	unsigned short accurate_statistics_flag;
+	unsigned short average_bit_rate; /* [15:0] */
+	unsigned short average_frame_rate; /* [15:0] */
+	unsigned short num_referenced_subseqs; /* [7:0] */
+	unsigned short ref_sub_seq_layer_num; /* [7:0] */
+	unsigned short ref_sub_seq_id; /* [15:0] */
+	unsigned short ref_sub_seq_direction; /* [0] */
+};
+
+/* SEI 13: full_frame_freeze */
+
+struct full_frame_freeze_t {
+	unsigned short full_frame_freeze_repetition_period; /* [14:0] */
+	unsigned short:16;    /* padding */
+};
+
+/* SEI 14: full_frame_freeze_release */
+
+/* SEI 15: full_frame_snapshot */
+
+struct full_frame_snapshot_t {
+	unsigned int snapshot_id;
+	unsigned short:16;    /* padding */
+};
+
+/* SEI 16: progressive_refinement_segment_start */
+
+struct progressive_refinement_segment_start_t {
+	unsigned int progressive_refinement_id;
+	unsigned short num_refinement_steps_minus1; /* [15:0] */
+	unsigned short:16;    /* padding */
+};
+
+/* SEI 17: progressive_refinement_segment_end */
+
+struct progressive_refinement_segment_end_t {
+	unsigned int progressive_refinement_id;
+};
+
+/* SEI 18: motion_constrained_slice_group_set */
+
+#define max_num_slice_groups_in_set 8
+
+struct motion_constrained_slice_group_set_t {
+	unsigned short num_slice_groups_in_set_minus1; /* [2:0] */
+	unsigned short slice_group_id[max_num_slice_groups_in_set]; /* [2:0] */
+	unsigned short exact_sample_value_match_flag;
+	unsigned short pan_scan_rect_flag;
+	unsigned short padding1;
+	unsigned int pan_scan_rect_id;
+};
+
+/* SEI 19: film_grain_characteristics */
+
+#define max_num_intensity_intervals 256
+#define max_num_model_values 8
+
+struct film_grain_characteristics_t {
+	unsigned short film_grain_characteristics_cancel_flag; /* [0] */
+
+	unsigned short model_id;
+	unsigned short separate_colour_description_present_flag; /* [0] */
+
+	unsigned short film_grain_bit_depth_luma_minus8;
+	unsigned short film_grain_bit_depth_chroma_minus8;
+	unsigned short film_grain_full_range_flag;
+	unsigned short film_grain_colour_primaries; /* [7:0] */
+
+	unsigned short film_grain_transfer_characteristics;
+	unsigned short film_grain_matrix_coefficients; /* [7:0] */
+
+	unsigned short blending_mode_id;
+	unsigned short log2_scale_factor;
+	unsigned short comp_model_present_flag[3]; /* [2:0] */
+
+	unsigned short num_intensity_intervals_minus1[3];
+	unsigned short num_model_values_minus1[3];
+
+	unsigned char intensity_interval_lower_bound[3][256];
+	unsigned char intensity_interval_upper_bound[3][256];
+
+	unsigned short comp_model_value[3][256][8]; /* [15:0] */
+
+	unsigned short film_grain_characteristics_repetition_period;
+	/* [14:0] */
+
+	unsigned short:16;    /* padding */
+};
+
+/* SEI 20: deblocking_filter_display_preference */
+
+struct deblocking_filter_display_preference_t {
+	unsigned short deblocking_display_preference_cancel_flag; /* [0] */
+	unsigned short display_prior_to_deblocking_preferred_flag;
+	unsigned short dec_frame_buffering_constraint_flag; /* [0] */
+	unsigned short deblocking_display_preference_repetition_period;
+	/* [14:0] */
+};
+
+/* SEI 21: stereo_video_info */
+
+struct stereo_video_info_t {
+	unsigned short field_views_flag; /* [0] */
+	unsigned short top_field_is_left_view_flag; /* [0] */
+	unsigned short current_frame_is_left_view_flag;
+	unsigned short next_frame_is_second_view_flag; /* [0] */
+	unsigned short left_view_self_contained_flag;
+	unsigned short right_view_self_contained_flag; /* [0] */
+};
+
+
+/*
+ * Encode information
+ */
+
+struct encode_info_t {
+	unsigned short enc_cvbr;
+	unsigned short enc_width; /* 80..720 16x */
+	unsigned short enc_height; /* 80..576 16x */
+	unsigned short enc_rc_rate; /* 16..8000 kbps */
+	unsigned short enc_rc_frame_rate; /* 1..62 */
+	unsigned short enc_ifrm_rate; /* 1..1023 */
+	unsigned short sps_rate; /* 0..1023 */
+	unsigned short pps_rate; /* 0..1023 */
+	unsigned short enc_cpb_size;
+	unsigned short enc_max_rate;
+	unsigned short slice_mb_num;
+	unsigned short enc_image_value; /* Maximum QP */
+	unsigned short enc_skip_off;
+	unsigned short enc_initial_image_value; /* Initial QP */
+	unsigned short enc_islice_image_mode; /* Decrement Q for IDR */
+	unsigned short enc_still_image_value;
+	unsigned short enc_flat_image_value;
+	unsigned short enc_min_qp_i; /* Minimum QP for I-pic */
+	unsigned short enc_min_qp_p; /* Minimum QP for P-pic */
+
+	unsigned short idr_in;
+	unsigned short skip_in;
+
+	/* SPS */
+	unsigned short frm_crop_flag;
+	unsigned short frm_crop_rect_lft_oft;
+	unsigned short frm_crop_rect_rgt_oft;
+	unsigned short frm_crop_rect_top_oft;
+	unsigned short frm_crop_rect_btm_oft;
+	unsigned short enc_vui_present_flag;
+	unsigned short level_idc;
+
+	/* PPS */
+	unsigned short const_intra_pred_flg;
+	unsigned short chroma_qp_idx_oft;
+
+	/* SH */
+	unsigned short dis_deblk_filter_idc_i;
+	unsigned short slice_alpha_oft_div2_i;
+	unsigned short slice_beta_oft_div2_i;
+	unsigned short dis_deblk_filter_idc_p;
+	unsigned short slice_alpha_oft_div2_p;
+	unsigned short slice_beta_oft_div2_p;
+
+	/* SEI */
+	unsigned short enc_buffering_period_en;
+	unsigned short enc_pic_timing_en;
+	unsigned short enc_pan_scan_rect_en;
+	unsigned short enc_sei_filler_en;
+
+	unsigned short enc_aud_on; /* Access unit delimiter */
+	unsigned short enc_fil_on; /* Filler data */
+};
+
+
+/*
+ * Decode information
+ */
+
+struct decode_info_t {
+	unsigned short dec_width;
+	unsigned short dec_height;
+	unsigned short frm_crop_flag;
+	unsigned short frm_crop_rect_lft_oft;
+	unsigned short frm_crop_rect_rgt_oft;
+	unsigned short frm_crop_rect_top_oft;
+	unsigned short frm_crop_rect_btm_oft;
+	unsigned short nal_ref_idc;
+	unsigned short nal_unit_type;
+
+	unsigned short:16;    /* padding */
+};
+
+struct avc_buffer_address_t {
+	unsigned int raster0_Y;
+	unsigned int raster0_U;
+	unsigned int raster0_V;
+	unsigned int raster1_Y;
+	unsigned int raster1_U;
+	unsigned int raster1_V;
+	unsigned int raster_select; /* 0:raster0 1:raster1 */
+
+	unsigned int stream0_base; /* physical address */
+	unsigned int stream0_size;
+	unsigned int stream1_base; /* physical address */
+	unsigned int stream1_size;
+	unsigned int stream_select; /* 0:stream0 1:stream1 */
+
+	unsigned int stream_buf_adr; /* [r] physical address */
+	unsigned int enc_bit_cnt; /* [r] encoded bit quantity */
+	unsigned int change_endian; /* 1(default)/0 */
+};
+
+struct avc_work_address_t {
+	unsigned int work_yuv01;
+	unsigned int work_yuv02;
+	unsigned int work_yuv03;
+	unsigned int work_yuv04;
+	unsigned int work_yuv05;
+	unsigned int work_yuv06;
+	unsigned int work_yuv07;
+	unsigned int work_yuv08;
+	unsigned int work_yuv09;
+	unsigned int work_yuv10;
+	unsigned int work_yuv11;
+	unsigned int work_yuv12;
+	unsigned int work_yuv13;
+	unsigned int work_yuv14;
+	unsigned int work_yuv15;
+	unsigned int work_yuv16;
+	unsigned int work_yuv17;
+	unsigned int work_yuv18;
+	unsigned int max_work_num;
+};
+
+struct avc_common_info_t {
+	struct avc_buffer_address_t avc_buffer_address;
+	struct avc_work_address_t avc_work_address;
+
+	struct avc_user_set_parameter_t avc_user_set_parameter;
+
+	struct encode_info_t encode_info;
+	struct decode_info_t decode_info;
+
+	struct aud_parameters_t aud_parameters;
+	struct seq_parameter_set_rbsp_t seq_parameter_set_rbsp;
+	struct pic_parameter_set_rbsp_t pic_parameter_set_rbsp;
+	struct slice_header_t slice_header;
+
+	/*
+	 * SEI
+	 */
+	struct sei_decode_flags_t sei_decode_flags;
+
+	struct buffering_period_t buffering_period; /* 0 */
+	struct pic_timing_t pic_timing;
+	struct pan_scan_rect_t pan_scan_rect;
+	struct filler_payload_t filler_payload;
+	struct user_data_registered_itu_t_t35_t user_data_registered_itu_t_t35;
+	struct user_data_unregistered_t user_data_unregistered;
+	struct recovery_point_t recovery_point;
+	struct dec_ref_pic_marking_repetition_t dec_ref_pic_marking_repetition;
+	struct spare_pic_t spare_pic;
+	struct scene_info_t scene_info;
+	struct sub_seq_info_t sub_seq_info; /* 10 */
+	struct sub_seq_layer_characteristics_t sub_seq_layer_characteristics;
+	struct sub_seq_characteristics_t sub_seq_characteristics;
+	struct full_frame_freeze_t full_frame_freeze; /* 13 */
+	struct full_frame_snapshot_t full_frame_snapshot; /* 15 */
+	struct progressive_refinement_segment_start_t
+	progressive_refinement_segment_start;
+	struct progressive_refinement_segment_end_t
+	progressive_refinement_segment_end;
+	struct motion_constrained_slice_group_set_t
+	motion_constrained_slice_group_set;
+	struct film_grain_characteristics_t film_grain_characteristics;
+	struct deblocking_filter_display_preference_t
+	deblocking_filter_display_preference; /* 20 */
+	struct stereo_video_info_t stereo_video_info;
+};
+
+#endif /* __avc_common_info_h__ */
diff --git a/drivers/Makefile b/drivers/Makefile
index 39cfe40..6632fb0 100644
--- a/drivers/Makefile
+++ b/drivers/Makefile
@@ -103,3 +103,5 @@ obj-$(CONFIG_OF)		+= of/
 obj-$(CONFIG_SSB)		+= ssb/
 obj-$(CONFIG_VIRTIO)		+= virtio/
 obj-$(CONFIG_REGULATOR)		+= regulator/
+obj-$(CONFIG_MP200_IPU)		+= ipu/
+obj-$(CONFIG_MP200_AVC)		+= avc/
diff --git a/drivers/avc/Kconfig b/drivers/avc/Kconfig
new file mode 100644
index 0000000..eda05e9
--- /dev/null
+++ b/drivers/avc/Kconfig
@@ -0,0 +1,14 @@
+#
+# IPU dricer configuration
+#
+
+menu "MP200 AVC support"
+        depends on ARCH_MP200
+
+config MP200_AVC
+	tristate "MP200 AVC support"
+	default m
+	help
+          This is the AVC device driver for EM1 boards.
+
+endmenu
diff --git a/drivers/avc/Makefile b/drivers/avc/Makefile
new file mode 100644
index 0000000..ac40056
--- /dev/null
+++ b/drivers/avc/Makefile
@@ -0,0 +1,13 @@
+
+#
+# Makefile for AVC driver
+#
+
+AVC_SRCS = avc_interface.c avc_control.c \
+           avc_version.c avc_debug.c
+
+AVC_OBJS = $(AVC_SRCS:.c=.o)
+
+obj-$(CONFIG_MP200_AVC) := mp200_avc.o
+mp200_avc-y := $(AVC_OBJS)
+
diff --git a/drivers/avc/avc_control.c b/drivers/avc/avc_control.c
new file mode 100644
index 0000000..15093ec
--- /dev/null
+++ b/drivers/avc/avc_control.c
@@ -0,0 +1,4046 @@
+/*!
+ * @file
+ * @brief functions to control HW-IP
+ * @author NIS
+ * @date 2007/9/14
+ */
+
+#include <linux/string.h> /* memset */
+#include <linux/stddef.h> /* NULL,offsetof */
+#include <linux/delay.h> /* udelay */
+#include <asm/cacheflush.h>
+
+#include "avc_lib.h"
+#include "avc_info.h"
+
+#define MAX_WORK_NUM_BIT 0x001F
+#define MEM_NUM_WR_BIT   0x1F00
+
+/* read decoded parameters --------------------------------------------------*/
+
+static int get_header_size(void)
+{
+	return readw(&avc_info->regs->head_PRreg14);
+}
+
+#define TRY_GET_HEADER_DATA int _exception = 0
+/* <->CATCH_GET_HEADER_DATA: */
+
+
+static unsigned short _get_header_data(int *hsize, int *ex)
+{
+	if (*hsize > 0) {
+		*hsize -= 1;
+		return readw(&avc_info->regs->head_PRreg15);
+	}
+
+	*ex = 1;
+	return 0;
+}
+
+static unsigned int _get_header_data32(int *hsize, int *ex)
+{
+	unsigned int ret;
+
+	if (*hsize >= 2) {
+		*hsize -= 2;
+		ret  = readw(&avc_info->regs->head_PRreg15) << 16;
+		ret |= readw(&avc_info->regs->head_PRreg15);
+		return ret;
+	}
+
+	*hsize = 0;
+	*ex = 1;
+	return 0;
+}
+
+#define debug_level_check (debug_level < 2)
+
+#define _param_log(_st, _name) \
+	debug2_np(" " # _name " 0x%X %u", _st->_name, _st->_name)
+
+#define _param_array_log(_st, _name, _i) \
+	debug2_np(" " # _name "[%d] 0x%X %u", \
+		  _i, _st->_name[_i], _st->_name[_i])
+
+/*
+ * HRD (Hypothetical Reference Decoder)
+ */
+
+#define hrd_log(_name) _param_log(hrd, _name)
+#define hrd_array_log(_name, _i) _param_array_log(hrd, _name, _i)
+
+void show_hrd(struct hrd_parameters_t *hrd)
+{
+	int i;
+	if (debug_level_check)
+		return;
+	debug2("HRD (Hypothetical Reference Decoder)");
+	hrd_log(cpb_cnt_minus1);
+	hrd_log(bit_rate_scale);
+	hrd_log(cpb_size_scale);
+	for (i = 0; i < hrd->cpb_cnt_minus1 && i < max_cpb_cnt; i++) {
+		hrd_array_log(bit_rate_value_minus1, i);
+		hrd_array_log(cpb_size_value_minus1, i);
+		hrd_array_log(cbr_flag, i);
+	}
+	hrd_log(initial_cpb_removal_delay_length_minus1);
+	hrd_log(cpb_removal_delay_length_minus1);
+	hrd_log(dpb_output_delay_length_minus1);
+	hrd_log(time_offset_length);
+}
+
+void read_hrd(struct hrd_parameters_t *hrd, int *hsize)
+{
+	int i;
+	unsigned short v;
+	TRY_GET_HEADER_DATA;
+
+	hrd->cpb_cnt_minus1 = _get_header_data(hsize, &_exception);
+	if (_exception)
+		goto CATCH_GET_HEADER_DATA;
+	if (hrd->cpb_cnt_minus1 >= max_cpb_cnt) {
+		/* it cannot be */
+		debug0("error cpb_cnt_minus1 %u >= max_cpb_cnt %u",
+		       hrd->cpb_cnt_minus1, max_cpb_cnt);
+		return;
+	}
+
+	v = _get_header_data(hsize, &_exception);
+	if (_exception)
+		goto CATCH_GET_HEADER_DATA;
+	hrd->bit_rate_scale = bits(v, 7, 4);
+	hrd->cpb_size_scale = bits(v, 3, 0);
+
+	for (i = 0; i <= hrd->cpb_cnt_minus1; i++) {
+		hrd->bit_rate_value_minus1[i] =
+			_get_header_data32(hsize, &_exception);
+		if (_exception)
+			goto CATCH_GET_HEADER_DATA;
+		hrd->cpb_size_value_minus1[i] =
+			_get_header_data32(hsize, &_exception);
+		if (_exception)
+			goto CATCH_GET_HEADER_DATA;
+		hrd->cbr_flag[i] = _get_header_data(hsize, &_exception);
+		if (_exception)
+			goto CATCH_GET_HEADER_DATA;
+	}
+
+	hrd->initial_cpb_removal_delay_length_minus1 =
+		_get_header_data(hsize, &_exception);
+	if (_exception)
+		goto CATCH_GET_HEADER_DATA;
+	v = _get_header_data(hsize, &_exception);
+	if (_exception)
+		goto CATCH_GET_HEADER_DATA;
+	hrd->cpb_removal_delay_length_minus1 = bits(v, 14, 10);
+	hrd->dpb_output_delay_length_minus1  = bits(v, 9, 5);
+	hrd->time_offset_length = bits(v, 4, 0);
+
+	return;
+
+CATCH_GET_HEADER_DATA:
+	debug1("get_header_data error");
+}
+
+/*
+ * VUI (Video Usability Information)
+ */
+
+#define vui_log(_name) _param_log(vui, _name)
+
+void show_vui(struct vui_parameters_t *vui)
+{
+	if (debug_level_check)
+		return;
+	debug2("VUI (Video Usability Information)");
+	vui_log(aspect_ratio_info_present_flag);
+	vui_log(aspect_ratio_idc);
+	vui_log(sar_width);
+	vui_log(sar_height);
+	vui_log(overscan_info_present_flag);
+	vui_log(overscan_appropriate_flag);
+	vui_log(video_signal_type_present_flag);
+	vui_log(video_format);
+	vui_log(video_full_range_flag);
+	vui_log(colour_description_present_flag);
+	vui_log(colour_primaries);
+	vui_log(transfer_characteristics);
+	vui_log(matrix_coefficients);
+	vui_log(chroma_loc_info_present_flag);
+	vui_log(chroma_sample_loc_type_top_field);
+	vui_log(chroma_sample_loc_type_bottom_field);
+	vui_log(timing_info_present_flag);
+	vui_log(num_units_in_tick);
+	vui_log(time_scale);
+	vui_log(fixed_frame_rate_flag);
+	vui_log(low_delay_hrd_flag);
+	vui_log(pic_struct_present_flag);
+	vui_log(bitstream_restriction_flag);
+	vui_log(motion_vectors_over_pic_boundaries_flag);
+	vui_log(max_bytes_per_pic_denom);
+	vui_log(max_bits_per_mb_denom);
+	vui_log(log2_max_mv_length_horizontal);
+	vui_log(log2_max_mv_length_vertical);
+	vui_log(num_reorder_frames);
+	vui_log(max_dec_frame_buffering);
+
+	vui_log(nal_hrd_parameters_present_flag);
+	vui_log(vcl_hrd_parameters_present_flag);
+
+	if (vui->nal_hrd_parameters_present_flag) {
+		debug2("HRD NAL");
+		show_hrd(&vui->nal_hrd_parameters);
+	}
+	if (vui->vcl_hrd_parameters_present_flag) {
+		debug2("HRD VCL");
+		show_hrd(&vui->vcl_hrd_parameters);
+	}
+}
+
+void read_vui(struct vui_parameters_t *vui, int *hsize)
+{
+	unsigned short v;
+	TRY_GET_HEADER_DATA;
+
+	vui->aspect_ratio_info_present_flag =
+		_get_header_data(hsize, &_exception);
+	if (_exception)
+		goto CATCH_GET_HEADER_DATA;
+	if (vui->aspect_ratio_info_present_flag) {
+		vui->aspect_ratio_idc =
+			_get_header_data(hsize, &_exception);
+		if (_exception)
+			goto CATCH_GET_HEADER_DATA;
+		if (vui->aspect_ratio_idc == Extended_SAR) {
+			vui->sar_width  =
+				_get_header_data(hsize, &_exception);
+			if (_exception)
+				goto CATCH_GET_HEADER_DATA;
+			vui->sar_height =
+				_get_header_data(hsize, &_exception);
+			if (_exception)
+				goto CATCH_GET_HEADER_DATA;
+		}
+	}
+
+	vui->overscan_info_present_flag =
+		_get_header_data(hsize, &_exception);
+	if (_exception)
+		goto CATCH_GET_HEADER_DATA;
+	if (vui->overscan_info_present_flag) {
+		vui->overscan_appropriate_flag =
+			_get_header_data(hsize, &_exception);
+	if (_exception)
+		goto CATCH_GET_HEADER_DATA;
+	}
+
+	vui->video_signal_type_present_flag =
+		_get_header_data(hsize, &_exception);
+	if (_exception)
+		goto CATCH_GET_HEADER_DATA;
+	if (vui->video_signal_type_present_flag) {
+		v = _get_header_data(hsize, &_exception);
+		if (_exception)
+			goto CATCH_GET_HEADER_DATA;
+		vui->video_format = bits(v, 4, 2);
+		vui->video_full_range_flag = bits(v, 1, 1);
+		vui->colour_description_present_flag = bits(v, 0, 0);
+		if (vui->colour_description_present_flag) {
+			vui->colour_primaries =
+				_get_header_data(hsize, &_exception);
+			if (_exception)
+				goto CATCH_GET_HEADER_DATA;
+			v = _get_header_data(hsize, &_exception);
+			if (_exception)
+				goto CATCH_GET_HEADER_DATA;
+			vui->transfer_characteristics = bits(v, 15, 8);
+			vui->matrix_coefficients      = bits(v, 7, 0);
+		}
+	}
+
+	vui->chroma_loc_info_present_flag =
+		_get_header_data(hsize, &_exception);
+	if (_exception)
+		goto CATCH_GET_HEADER_DATA;
+	if (vui->chroma_loc_info_present_flag) {
+		vui->chroma_sample_loc_type_top_field =
+			_get_header_data(hsize, &_exception);
+		if (_exception)
+			goto CATCH_GET_HEADER_DATA;
+		vui->chroma_sample_loc_type_bottom_field =
+			_get_header_data(hsize, &_exception);
+		if (_exception)
+			goto CATCH_GET_HEADER_DATA;
+	}
+
+	vui->timing_info_present_flag =
+		_get_header_data(hsize, &_exception);
+	if (_exception)
+		goto CATCH_GET_HEADER_DATA;
+	if (vui->timing_info_present_flag) {
+		vui->num_units_in_tick =
+			_get_header_data32(hsize, &_exception);
+		if (_exception)
+			goto CATCH_GET_HEADER_DATA;
+		vui->time_scale        =
+			_get_header_data32(hsize, &_exception);
+		if (_exception)
+			goto CATCH_GET_HEADER_DATA;
+		vui->fixed_frame_rate_flag =
+			_get_header_data(hsize, &_exception);
+		if (_exception)
+			goto CATCH_GET_HEADER_DATA;
+	}
+
+	vui->nal_hrd_parameters_present_flag =
+		_get_header_data(hsize, &_exception);
+	if (_exception)
+		goto CATCH_GET_HEADER_DATA;
+	if (vui->nal_hrd_parameters_present_flag)
+		read_hrd(&vui->nal_hrd_parameters, hsize);
+
+	vui->vcl_hrd_parameters_present_flag =
+		_get_header_data(hsize, &_exception);
+	if (_exception)
+		goto CATCH_GET_HEADER_DATA;
+	if (vui->vcl_hrd_parameters_present_flag)
+		read_hrd(&vui->vcl_hrd_parameters, hsize);
+
+	if (vui->nal_hrd_parameters_present_flag ||
+	    vui->vcl_hrd_parameters_present_flag) {
+		vui->low_delay_hrd_flag =
+			_get_header_data(hsize, &_exception);
+		if (_exception)
+			goto CATCH_GET_HEADER_DATA;
+	}
+
+	v = _get_header_data(hsize, &_exception);
+	if (_exception)
+		goto CATCH_GET_HEADER_DATA;
+	vui->pic_struct_present_flag    = bits(v, 1, 1);
+	vui->bitstream_restriction_flag = bits(v, 0, 0);
+
+	if (vui->bitstream_restriction_flag) {
+		vui->motion_vectors_over_pic_boundaries_flag =
+			_get_header_data(hsize, &_exception);
+		if (_exception)
+			goto CATCH_GET_HEADER_DATA;
+		vui->max_bytes_per_pic_denom =
+			_get_header_data(hsize, &_exception);
+		if (_exception)
+			goto CATCH_GET_HEADER_DATA;
+		vui->max_bits_per_mb_denom =
+			_get_header_data(hsize, &_exception);
+		if (_exception)
+			goto CATCH_GET_HEADER_DATA;
+		vui->log2_max_mv_length_horizontal =
+			_get_header_data(hsize, &_exception);
+		if (_exception)
+			goto CATCH_GET_HEADER_DATA;
+		vui->log2_max_mv_length_vertical =
+			_get_header_data(hsize, &_exception);
+		if (_exception)
+			goto CATCH_GET_HEADER_DATA;
+		vui->num_reorder_frames =
+			_get_header_data(hsize, &_exception);
+		if (_exception)
+			goto CATCH_GET_HEADER_DATA;
+		vui->max_dec_frame_buffering =
+			_get_header_data(hsize, &_exception);
+		if (_exception)
+			goto CATCH_GET_HEADER_DATA;
+	}
+
+	return;
+
+CATCH_GET_HEADER_DATA:
+	debug1("get_header_data error");
+}
+
+/*
+ * SPS (Sequence Parameter Set)
+ */
+
+#define sps_log(_name) _param_log(sps, _name)
+#define sps_array_log(_name, _i) _param_array_log(sps, _name, _i)
+
+void show_sps(struct seq_parameter_set_rbsp_t *sps)
+{
+	int i;
+	int max;
+
+	if (debug_level_check)
+		return;
+	debug2("SPS (Sequence Parameter Set)");
+	sps_log(profile_idc);
+	switch (sps->profile_idc) {
+	case 66:
+		debug2_np("  Baseline profile");
+		break;
+	case 77:
+		debug2_np("  Main profile");
+		break;
+	case 88:
+		debug2_np("  Extended profile");
+		break;
+	default:
+		debug2_np("  error!!");
+		break;
+	}
+	sps_log(constraint_set0_flag);
+	sps_log(constraint_set1_flag);
+	sps_log(constraint_set2_flag);
+	/* sps_log(reserved_zero_5bits); */
+	sps_log(level_idc);
+	sps_log(seq_parameter_set_id);
+	sps_log(log2_max_frame_num_minus4);
+	sps_log(pic_order_cnt_type);
+	sps_log(log2_max_pic_order_cnt_lsb_minus4);
+	sps_log(delta_pic_order_always_zero_flag);
+	sps_log(offset_for_non_ref_pic);
+	sps_log(offset_for_top_to_bottom_field);
+	sps_log(num_ref_frames_in_pic_order_nct_cycle);
+
+	max = sps->num_ref_frames_in_pic_order_nct_cycle;
+	if (max > max_num_ref_frames_in_pic_order_nct_cycle)
+		max = max_num_ref_frames_in_pic_order_nct_cycle;
+	for (i = 0; i < max; i++)
+		sps_array_log(offset_for_ref_frame, i);
+
+	sps_log(num_ref_frames);
+	sps_log(gaps_in_frame_num_value_allowed_flag);
+	sps_log(pic_width_in_mbs_minus1);
+	sps_log(pic_height_in_maps_units_minus1);
+	sps_log(frame_mbs_only_flag);
+	sps_log(mb_adaptive_frame_field_flag);
+	sps_log(direct_8x8_inference_flag);
+	sps_log(frame_cropping_flag);
+	sps_log(frame_crop_left_offset);
+	sps_log(frame_crop_right_offset);
+	sps_log(frame_crop_top_offset);
+	sps_log(frame_crop_bottom_offset);
+	sps_log(vui_parameters_present_flag);
+	if (sps->vui_parameters_present_flag)
+		show_vui(&sps->vui_parameters);
+}
+
+void read_sps(struct seq_parameter_set_rbsp_t *sps, int *hsize)
+{
+	int i;
+	unsigned short v;
+	TRY_GET_HEADER_DATA;
+
+	memset(sps, 0, sizeof(*sps));
+
+	sps->profile_idc = _get_header_data(hsize, &_exception);
+	if (_exception)
+		goto CATCH_GET_HEADER_DATA;
+
+	v = _get_header_data(hsize, &_exception);
+	if (_exception)
+		goto CATCH_GET_HEADER_DATA;
+	sps->constraint_set0_flag = bits(v, 15, 15);
+	sps->constraint_set1_flag = bits(v, 14, 14);
+	sps->constraint_set2_flag = bits(v, 13, 13);
+	sps->level_idc = bits(v, 7, 0);
+
+	sps->seq_parameter_set_id = _get_header_data(hsize, &_exception);
+	if (_exception)
+		goto CATCH_GET_HEADER_DATA;
+	sps->log2_max_frame_num_minus4 = _get_header_data(hsize, &_exception);
+	if (_exception)
+		goto CATCH_GET_HEADER_DATA;
+	sps->pic_order_cnt_type = _get_header_data(hsize, &_exception);
+	if (_exception)
+		goto CATCH_GET_HEADER_DATA;
+
+	if (sps->pic_order_cnt_type == 0) {
+		sps->log2_max_pic_order_cnt_lsb_minus4 =
+			_get_header_data(hsize, &_exception);
+		if (_exception)
+			goto CATCH_GET_HEADER_DATA;
+	} else if (sps->pic_order_cnt_type == 1) {
+		sps->delta_pic_order_always_zero_flag =
+			_get_header_data(hsize, &_exception);
+		if (_exception)
+			goto CATCH_GET_HEADER_DATA;
+		sps->offset_for_non_ref_pic =
+			_get_header_data32(hsize, &_exception);
+		if (_exception)
+			goto CATCH_GET_HEADER_DATA;
+		sps->offset_for_top_to_bottom_field =
+			_get_header_data32(hsize, &_exception);
+		if (_exception)
+			goto CATCH_GET_HEADER_DATA;
+		sps->num_ref_frames_in_pic_order_nct_cycle =
+			_get_header_data(hsize, &_exception);
+		if (_exception)
+			goto CATCH_GET_HEADER_DATA;
+		if (sps->num_ref_frames_in_pic_order_nct_cycle >=
+		    max_num_ref_frames_in_pic_order_nct_cycle) {
+			/* it cannot be */
+			debug0("error  num_ref_frames_in_pic_order_nct_cycle"
+			       " %u >= max %u",
+			       sps->num_ref_frames_in_pic_order_nct_cycle,
+			       max_num_ref_frames_in_pic_order_nct_cycle);
+			return;
+		}
+
+		for (i = 0; i < sps->num_ref_frames_in_pic_order_nct_cycle;
+		     i++){
+			sps->offset_for_ref_frame[i] =
+				_get_header_data32(hsize, &_exception);
+			if (_exception)
+				goto CATCH_GET_HEADER_DATA;
+		}
+	}
+
+	sps->num_ref_frames = _get_header_data(hsize, &_exception);
+	if (_exception)
+		goto CATCH_GET_HEADER_DATA;
+	sps->gaps_in_frame_num_value_allowed_flag =
+		_get_header_data(hsize, &_exception);
+	if (_exception)
+		goto CATCH_GET_HEADER_DATA;
+	sps->pic_width_in_mbs_minus1 =
+		_get_header_data(hsize, &_exception);
+	if (_exception)
+		goto CATCH_GET_HEADER_DATA;
+	sps->pic_height_in_maps_units_minus1 =
+		_get_header_data(hsize, &_exception);
+	if (_exception)
+		goto CATCH_GET_HEADER_DATA;
+	sps->frame_mbs_only_flag = _get_header_data(hsize, &_exception);
+	if (_exception)
+		goto CATCH_GET_HEADER_DATA;
+
+	if (!sps->frame_mbs_only_flag) {
+		sps->mb_adaptive_frame_field_flag =
+			_get_header_data(hsize, &_exception);
+		if (_exception)
+			goto CATCH_GET_HEADER_DATA;
+	}
+	v = _get_header_data(hsize, &_exception);
+	if (_exception)
+		goto CATCH_GET_HEADER_DATA;
+	sps->direct_8x8_inference_flag = bits(v, 1, 1);
+	sps->frame_cropping_flag = bits(v, 0, 0);
+
+	if (sps->frame_cropping_flag) {
+		sps->frame_crop_left_offset  =
+			_get_header_data(hsize, &_exception);
+		if (_exception)
+			goto CATCH_GET_HEADER_DATA;
+		sps->frame_crop_right_offset =
+			_get_header_data(hsize, &_exception);
+		if (_exception)
+			goto CATCH_GET_HEADER_DATA;
+		sps->frame_crop_top_offset   =
+			_get_header_data(hsize, &_exception);
+		if (_exception)
+			goto CATCH_GET_HEADER_DATA;
+		sps->frame_crop_bottom_offset =
+			_get_header_data(hsize, &_exception);
+		if (_exception)
+			goto CATCH_GET_HEADER_DATA;
+	}
+
+	sps->vui_parameters_present_flag =
+		_get_header_data(hsize, &_exception);
+	if (_exception)
+		goto CATCH_GET_HEADER_DATA;
+	if (sps->vui_parameters_present_flag)
+		read_vui(&sps->vui_parameters, hsize);
+
+	return;
+
+CATCH_GET_HEADER_DATA:
+	debug1("get_header_data error");
+}
+
+/*
+ * PPS (Picture Parameter Set)
+ */
+
+#define pps_log(_name) _param_log(pps, _name)
+#define pps_array_log(_name, _i) _param_array_log(pps, _name, _i)
+
+void show_pps(struct pic_parameter_set_rbsp_t *pps)
+{
+	int i;
+	int max;
+
+	if (debug_level_check)
+		return;
+	debug2("PPS (Picture Parameter Set)");
+	pps_log(pic_parameter_set_id);
+	pps_log(seq_parameter_set_id);
+	pps_log(entropy_coding_mode_flag);
+	pps_log(pic_order_present_flag);
+	pps_log(num_slice_groups_minus1);
+	pps_log(slice_group_map_type);
+
+	max = minimum(pps->slice_group_map_type, max_num_slice_groups - 1);
+	for (i = 0; i <= max; i++)
+		pps_array_log(run_length_minus1, i);
+
+	max = minimum(pps->slice_group_map_type, max_num_slice_groups);
+	for (i = 0; i < max; i++) {
+		pps_array_log(top_left, i);
+		pps_array_log(bottom_right, i);
+	}
+
+	pps_log(slice_group_change_direction_flag);
+	pps_log(slice_group_change_rate_minus1);
+	pps_log(pic_size_in_map_units_minus1);
+
+	max = minimum(pps->pic_size_in_map_units_minus1,
+		      max_pic_size_in_map_units - 1);
+	for (i = 0; i <= pps->pic_size_in_map_units_minus1; i++)
+		pps_array_log(slice_group_id, i);
+
+	pps_log(num_ref_idx_l0_active_minus1);
+	pps_log(num_ref_idx_l1_active_minus1);
+
+	pps_log(weighted_pred_flag);
+	pps_log(weighted_bipred_idc);
+
+	pps_log(pic_init_qp_minus26);
+	pps_log(pic_init_qs_minus26);
+	pps_log(chroma_qp_index_offset);
+	pps_log(deblocking_filter_control_present_flag);
+	pps_log(constrained_intra_flag);
+	pps_log(redundant_pic_cnt_present_flag);
+}
+
+void read_pps(struct pic_parameter_set_rbsp_t *pps, int *hsize)
+{
+	int i;
+	unsigned short v;
+	TRY_GET_HEADER_DATA;
+
+	memset(pps, 0, sizeof(*pps));
+
+	pps->pic_parameter_set_id =
+		_get_header_data(hsize, &_exception);
+	if (_exception)
+		goto CATCH_GET_HEADER_DATA;
+	pps->seq_parameter_set_id =
+		_get_header_data(hsize, &_exception);
+	if (_exception)
+		goto CATCH_GET_HEADER_DATA;
+
+	v = _get_header_data(hsize, &_exception);
+	if (_exception)
+		goto CATCH_GET_HEADER_DATA;
+	pps->entropy_coding_mode_flag = bits(v, 1, 1);
+	pps->pic_order_present_flag   = bits(v, 0, 0);
+
+	pps->num_slice_groups_minus1 = _get_header_data(hsize, &_exception);
+	if (_exception)
+		goto CATCH_GET_HEADER_DATA;
+	if (pps->num_slice_groups_minus1 >= max_num_slice_groups) {
+		/* it cannot be */
+		debug0("error num_slice_groups_minus1 %u "
+		       ">= max_num_slice_groups %u",
+		       pps->num_slice_groups_minus1, max_num_slice_groups);
+		return;
+	}
+
+	if (pps->num_slice_groups_minus1 > 0) {
+		pps->slice_group_map_type =
+			_get_header_data(hsize, &_exception);
+		if (_exception)
+			goto CATCH_GET_HEADER_DATA;
+		if (pps->slice_group_map_type == 0) {
+			for (i = 0; i <= pps->num_slice_groups_minus1; i++) {
+				pps->run_length_minus1[i] =
+					_get_header_data(hsize, &_exception);
+				if (_exception)
+					goto CATCH_GET_HEADER_DATA;
+			}
+		} else if (pps->slice_group_map_type == 2) {
+			for (i = 0; i < pps->num_slice_groups_minus1; i++) {
+				pps->top_left[i]     =
+					_get_header_data(hsize, &_exception);
+				if (_exception)
+					goto CATCH_GET_HEADER_DATA;
+				pps->bottom_right[i] =
+					_get_header_data(hsize, &_exception);
+				if (_exception)
+					goto CATCH_GET_HEADER_DATA;
+			}
+		} else if (pps->slice_group_map_type == 3 ||
+			   pps->slice_group_map_type == 4 ||
+			   pps->slice_group_map_type == 5) {
+			pps->slice_group_change_direction_flag =
+				_get_header_data(hsize, &_exception);
+			if (_exception)
+				goto CATCH_GET_HEADER_DATA;
+			pps->slice_group_change_rate_minus1 =
+				_get_header_data(hsize, &_exception);
+			if (_exception)
+				goto CATCH_GET_HEADER_DATA;
+		} else if (pps->slice_group_map_type == 6) {
+			pps->pic_size_in_map_units_minus1 =
+				_get_header_data(hsize, &_exception);
+			if (_exception)
+				goto CATCH_GET_HEADER_DATA;
+			if (pps->pic_size_in_map_units_minus1
+			    >= max_pic_size_in_map_units) {
+				/* it cannot be */
+				debug0("error pic_size_in_map_units_minus1"
+				       " %u >= "
+				       "max_pic_size_in_map_units %u",
+				       pps->pic_size_in_map_units_minus1,
+				       max_pic_size_in_map_units);
+				return;
+			}
+			for (i = 0; i <= pps->pic_size_in_map_units_minus1;
+			     i++){
+				pps->slice_group_id[i] =
+					_get_header_data(hsize, &_exception);
+				if (_exception)
+					goto CATCH_GET_HEADER_DATA;
+			}
+		}
+	}
+
+	pps->num_ref_idx_l0_active_minus1 =
+		_get_header_data(hsize, &_exception);
+	if (_exception)
+		goto CATCH_GET_HEADER_DATA;
+	pps->num_ref_idx_l1_active_minus1 =
+		_get_header_data(hsize, &_exception);
+	if (_exception)
+		goto CATCH_GET_HEADER_DATA;
+
+	v = _get_header_data(hsize, &_exception);
+	if (_exception)
+		goto CATCH_GET_HEADER_DATA;
+	pps->weighted_pred_flag  = bits(v, 2, 2);
+	pps->weighted_bipred_idc = bits(v, 1, 0);
+
+	pps->pic_init_qp_minus26 = _get_header_data(hsize, &_exception);
+	if (_exception)
+		goto CATCH_GET_HEADER_DATA;
+	pps->pic_init_qs_minus26 = _get_header_data(hsize, &_exception);
+	if (_exception)
+		goto CATCH_GET_HEADER_DATA;
+	pps->chroma_qp_index_offset = _get_header_data(hsize, &_exception);
+	if (_exception)
+		goto CATCH_GET_HEADER_DATA;
+
+	v = _get_header_data(hsize, &_exception);
+	if (_exception)
+		goto CATCH_GET_HEADER_DATA;
+	pps->deblocking_filter_control_present_flag = bits(v, 2, 2);
+	pps->constrained_intra_flag = bits(v, 1, 1);
+	pps->redundant_pic_cnt_present_flag = bits(v, 0, 0);
+
+	return;
+
+CATCH_GET_HEADER_DATA:
+	debug1("get_header_data error");
+}
+
+/*
+ * SH (Slice Header)
+ */
+
+/* ref_pic_list_reordering */
+
+#define rplr_log(_name) _param_log(rplr, _name)
+#define rplr_rop_log(_name, _i)	\
+	debug2_np(" rop[%d]." # _name " 0x%X %u", \
+		  _i, rplr->rop[_i]._name, rplr->rop[_i]._name)
+
+void show_ref_pic_list_reordering(struct ref_pic_list_reordering_t *rplr)
+{
+	int i;
+	if (debug_level_check)
+		return;
+	debug2("ref_pic_list_reordering");
+	rplr_log(sh_slice_type);
+	rplr_log(ref_pic_list_reordering_flag_l0);
+
+	if (rplr->ref_pic_list_reordering_flag_l0) {
+		for (i = 0; i <= max_reordering_of_pic; i++) {
+			unsigned short idc =
+				rplr->rop[i].reordering_of_pic_nums_idc;
+			rplr_rop_log(reordering_of_pic_nums_idc, i);
+			if (idc == 0 || idc == 1)
+				rplr_rop_log(u.abs_diff_pic_num_minus1, i);
+			else if (idc == 2)
+				rplr_rop_log(u.long_term_pic_num, i);
+			else
+				break;
+		}
+	}
+}
+
+void read_ref_pic_list_reordering(struct ref_pic_list_reordering_t *rplr,
+				  int *hsize,
+				  unsigned short slice_type,
+				  unsigned short num_ref_idx_l0_active)
+{
+	unsigned short idc;
+	int i;
+	TRY_GET_HEADER_DATA;
+
+	if (num_ref_idx_l0_active > max_reordering_of_pic) {
+		debug0("error num_ref_idx_l0_active %u "
+		       "> max_reordering_of_pic %u",
+		       num_ref_idx_l0_active, max_reordering_of_pic);
+		return;
+	}
+
+	rplr->sh_slice_type = slice_type;
+
+	if (!is_slice_type_I(slice_type) && !is_slice_type_SI(slice_type)) {
+		rplr->ref_pic_list_reordering_flag_l0 =
+			_get_header_data(hsize, &_exception);
+		if (_exception)
+			goto CATCH_GET_HEADER_DATA;
+		if (rplr->ref_pic_list_reordering_flag_l0) {
+			for (i = 0; i <= num_ref_idx_l0_active; i++) {
+				idc = _get_header_data(hsize, &_exception);
+				if (_exception)
+					goto CATCH_GET_HEADER_DATA;
+				rplr->rop[i].reordering_of_pic_nums_idc = idc;
+				if (idc == 0 || idc == 1) {
+					rplr->rop[i].u.abs_diff_pic_num_minus1 =
+						_get_header_data(
+							hsize, &_exception);
+					if (_exception)
+						goto CATCH_GET_HEADER_DATA;
+				} else if (idc == 2) {
+					rplr->rop[i].u.long_term_pic_num =
+						_get_header_data(
+							hsize, &_exception);
+					if (_exception)
+						goto CATCH_GET_HEADER_DATA;
+				} else {
+					break; /* if idc == 3 then end loop */
+				}
+			}
+			if (i > num_ref_idx_l0_active) {
+				debug0("error over num_ref_idx_l0_active %u",
+				       num_ref_idx_l0_active);
+				return;
+			}
+		}
+	}
+
+	return;
+
+CATCH_GET_HEADER_DATA:
+	debug1("get_header_data error");
+}
+
+/* dec_ref_pic_marking */
+
+#define drpm_log(_name) _param_log(drpm, _name)
+
+#define drpm_mmco_log(_name, _i) \
+	debug2_np(" mmco[%d]." # _name " 0x%X %u", \
+		  _i, drpm->mmco[_i]._name, drpm->mmco[_i]._name)
+
+void show_dec_ref_pic_marking(struct dec_ref_pic_marking_t *drpm)
+{
+	int i;
+	if (debug_level_check)
+		return;
+	debug2("dec_ref_pic_marking");
+	drpm_log(nal_unit_type);
+	drpm_log(no_output_of_prior_pics_flag);
+	drpm_log(long_term_reference_flag);
+	drpm_log(adaptive_ref_pic_marking_mode_flag);
+
+	if (drpm->adaptive_ref_pic_marking_mode_flag) {
+		for (i = 0; i <= max_memory_management_control_operation; i++) {
+			drpm_mmco_log(memory_management_control_operation, i);
+			drpm_mmco_log(difference_of_pic_nums_minus1, i);
+			drpm_mmco_log(long_term_pic_num, i);
+			drpm_mmco_log(long_term_frame_idx, i);
+			drpm_mmco_log(max_long_term_frame_idx_plus1, i);
+			if (drpm->mmco[i].memory_management_control_operation
+			    == 0)
+				break;
+		}
+	}
+}
+
+void read_dec_ref_pic_marking(struct dec_ref_pic_marking_t *dec_ref,
+			      int *hsize)
+{
+	struct avc_regs_t *regs = avc_info->regs;
+	unsigned short v;
+	unsigned short op;
+	int i;
+	TRY_GET_HEADER_DATA;
+
+	v = readw(&regs->dec_PARreg8);
+	dec_ref->nal_unit_type = bits(v, 4, 0);
+
+	if (dec_ref->nal_unit_type == 5) {
+		v = _get_header_data(hsize, &_exception);
+		if (_exception)
+			goto CATCH_GET_HEADER_DATA;
+		dec_ref->no_output_of_prior_pics_flag = bits(v, 1, 1);
+		dec_ref->long_term_reference_flag     = bits(v, 0, 0);
+	} else {
+		dec_ref->adaptive_ref_pic_marking_mode_flag =
+			_get_header_data(hsize, &_exception);
+		if (_exception)
+			goto CATCH_GET_HEADER_DATA;
+		if (dec_ref->adaptive_ref_pic_marking_mode_flag) {
+			for (i = 0;
+			     i <= max_memory_management_control_operation;
+			     i++) {
+				op = _get_header_data(hsize, &_exception);
+				if (_exception)
+					goto CATCH_GET_HEADER_DATA;
+				dec_ref->mmco[i].
+					memory_management_control_operation =
+					op;
+				if (op == 1 || op == 3) {
+					dec_ref->mmco[i]
+						.difference_of_pic_nums_minus1 =
+						_get_header_data(
+							hsize, &_exception);
+					if (_exception)
+						goto CATCH_GET_HEADER_DATA;
+				}
+				if (op == 2) {
+					dec_ref->mmco[i].long_term_pic_num =
+						_get_header_data(
+							hsize, &_exception);
+					if (_exception)
+						goto CATCH_GET_HEADER_DATA;
+				}
+				if (op == 3 || op == 6) {
+					dec_ref->mmco[i].long_term_frame_idx =
+						_get_header_data(
+							hsize, &_exception);
+					if (_exception)
+						goto CATCH_GET_HEADER_DATA;
+				}
+				if (op == 4) {
+					dec_ref->mmco[i].
+						max_long_term_frame_idx_plus1 =
+						_get_header_data(
+							hsize, &_exception);
+					if (_exception)
+						goto CATCH_GET_HEADER_DATA;
+				}
+				if (op == 0)
+					break;
+			}
+			if (i > max_memory_management_control_operation) {
+				debug0("error over "
+				       "max_memory_management_control_operation"
+				       " %u",
+				       max_memory_management_control_operation);
+				return;
+			}
+		}
+	}
+
+	return;
+
+CATCH_GET_HEADER_DATA:
+	debug1("get_header_data error");
+}
+
+#define sh_log(_name) _param_log(sh, _name)
+
+void show_sh(struct slice_header_t *sh)
+{
+	if (debug_level_check)
+		return;
+	debug2("SH (Slice Header)");
+
+	sh_log(nal_ref_idc);
+	sh_log(nal_unit_type);
+	sh_log(sps_pic_order_cnt_type);
+	sh_log(sps_delta_pic_order_always_zero_flag);
+	sh_log(sps_frame_mbs_only_flag);
+	sh_log(pps_pic_order_present_flag);
+	sh_log(pps_deblocking_filter_control_present_flag);
+
+	sh_log(slice_type);
+	sh_log(pic_parameter_set_id);
+	sh_log(frame_num);
+	sh_log(field_pic_flag);
+	sh_log(bottom_field_flag);
+	sh_log(idr_pic_id);
+	sh_log(pic_order_cnt_lsb);
+
+	sh_log(delta_pic_order_cnt_bottom);
+	sh_log(delta_pic_order_cnt[0]);
+	sh_log(delta_pic_order_cnt[1]);
+
+	sh_log(num_ref_idx_active_override_flag);
+	sh_log(num_ref_idx_l0_active_minus1);
+
+	sh_log(slice_qp_delta);
+	sh_log(slice_qs_delta);
+	sh_log(disable_deblocking_filter_idc);
+	sh_log(slice_alpha_c0_offset_div2);
+	sh_log(slice_beta_offset_div2);
+
+	show_ref_pic_list_reordering(&sh->ref_pic_list_reordering);
+	show_dec_ref_pic_marking(&sh->dec_ref_pic_marking);
+}
+
+void read_sh(struct slice_header_t *sh, int *hsize)
+{
+	struct avc_regs_t *regs = avc_info->regs;
+	struct seq_parameter_set_rbsp_t *sps = &avc_info->last_sps;
+	struct pic_parameter_set_rbsp_t *pps = &avc_info->last_pps;
+	unsigned short num_ref_idx_l0_active_minus1;
+	unsigned short v;
+	TRY_GET_HEADER_DATA;
+
+	memset(sh, 0, sizeof(*sh));
+
+	v = readw(&regs->dec_PARreg8);
+	sh->nal_ref_idc   = bits(v, 6, 5);
+	sh->nal_unit_type = bits(v, 4, 0);
+	sh->sps_pic_order_cnt_type = sps->pic_order_cnt_type;
+	sh->sps_delta_pic_order_always_zero_flag =
+		sps->delta_pic_order_always_zero_flag;
+	sh->sps_frame_mbs_only_flag = sps->frame_mbs_only_flag;
+	sh->pps_pic_order_present_flag = pps->pic_order_present_flag;
+	sh->pps_deblocking_filter_control_present_flag =
+		pps->deblocking_filter_control_present_flag;
+
+	v = _get_header_data(hsize, &_exception);
+	if (_exception)
+		goto CATCH_GET_HEADER_DATA; /* dummy */
+	sh->slice_type = _get_header_data(hsize, &_exception);
+	if (_exception)
+		goto CATCH_GET_HEADER_DATA;
+	sh->pic_parameter_set_id = _get_header_data(hsize, &_exception);
+	if (_exception)
+		goto CATCH_GET_HEADER_DATA;
+	sh->frame_num = _get_header_data(hsize, &_exception);
+	if (_exception)
+		goto CATCH_GET_HEADER_DATA;
+	if (!sh->sps_frame_mbs_only_flag) {
+		sh->field_pic_flag = _get_header_data(hsize, &_exception);
+		if (_exception)
+			goto CATCH_GET_HEADER_DATA;
+		if (sh->field_pic_flag) {
+			sh->bottom_field_flag =
+				_get_header_data(hsize, &_exception);
+			if (_exception)
+				goto CATCH_GET_HEADER_DATA;
+		}
+	}
+
+	if (sh->nal_unit_type == 5) {
+		sh->idr_pic_id = _get_header_data(hsize, &_exception);
+		if (_exception)
+			goto CATCH_GET_HEADER_DATA;
+	}
+
+	if (sh->sps_pic_order_cnt_type == 0) {
+		sh->pic_order_cnt_lsb = _get_header_data(hsize, &_exception);
+		if (_exception)
+			goto CATCH_GET_HEADER_DATA;
+		if (sh->pps_pic_order_present_flag && !sh->field_pic_flag) {
+			sh->delta_pic_order_cnt_bottom =
+				_get_header_data32(hsize, &_exception);
+			if (_exception)
+				goto CATCH_GET_HEADER_DATA;
+		}
+	}
+
+	if (sh->sps_pic_order_cnt_type == 1 &&
+	    !sh->sps_delta_pic_order_always_zero_flag) {
+		sh->delta_pic_order_cnt[0] =
+			_get_header_data32(hsize, &_exception);
+		if (_exception)
+			goto CATCH_GET_HEADER_DATA;
+		if (sh->pps_pic_order_present_flag && !sh->field_pic_flag) {
+			sh->delta_pic_order_cnt[1] =
+				_get_header_data32(hsize, &_exception);
+			if (_exception)
+				goto CATCH_GET_HEADER_DATA;
+		}
+	}
+
+	num_ref_idx_l0_active_minus1 = pps->num_ref_idx_l0_active_minus1;
+	if (is_slice_type_P(sh->slice_type) ||
+	    is_slice_type_SP(sh->slice_type) ||
+	    is_slice_type_B(sh->slice_type)
+	    ) {
+		sh->num_ref_idx_active_override_flag =
+			_get_header_data(hsize, &_exception);
+		if (_exception)
+			goto CATCH_GET_HEADER_DATA;
+		if (sh->num_ref_idx_active_override_flag) {
+			sh->num_ref_idx_l0_active_minus1 =
+				_get_header_data(hsize, &_exception);
+			if (_exception)
+				goto CATCH_GET_HEADER_DATA;
+			num_ref_idx_l0_active_minus1 =
+				sh->num_ref_idx_l0_active_minus1;
+		}
+	}
+
+	read_ref_pic_list_reordering(&sh->ref_pic_list_reordering, hsize,
+				     sh->slice_type,
+				     num_ref_idx_l0_active_minus1 + 1);
+
+	if (sh->nal_ref_idc != 0)
+		read_dec_ref_pic_marking(&sh->dec_ref_pic_marking, hsize);
+
+	sh->slice_qp_delta = _get_header_data(hsize, &_exception);
+	if (_exception)
+		goto CATCH_GET_HEADER_DATA;
+	if (is_slice_type_SP(sh->slice_type) ||
+	    is_slice_type_SI(sh->slice_type)) {
+		sh->slice_qs_delta = _get_header_data(hsize, &_exception);
+		if (_exception)
+			goto CATCH_GET_HEADER_DATA;
+	}
+
+	if (sh->pps_deblocking_filter_control_present_flag) {
+		sh->disable_deblocking_filter_idc =
+			_get_header_data(hsize, &_exception);
+		if (_exception)
+			goto CATCH_GET_HEADER_DATA;
+		if (sh->disable_deblocking_filter_idc != 1) {
+			sh->slice_alpha_c0_offset_div2 =
+				_get_header_data(hsize, &_exception);
+			if (_exception)
+				goto CATCH_GET_HEADER_DATA;
+			sh->slice_beta_offset_div2 =
+				_get_header_data(hsize, &_exception);
+			if (_exception)
+				goto CATCH_GET_HEADER_DATA;
+		}
+	}
+
+	return;
+
+CATCH_GET_HEADER_DATA:
+	debug1("get_header_data error");
+}
+
+/*
+ * AUD (Access Unit Delimiter)
+ */
+
+void show_aud(struct aud_parameters_t *aud)
+{
+	if (debug_level_check)
+		return;
+	debug2("AUD (Access Unit Delimiter)");
+	debug2(" primary_pic_type %u", aud->primary_pic_type);
+	switch (aud->primary_pic_type) {
+	case 0:
+		debug2("  I");
+		break;
+	case 1:
+		debug2("  I,P");
+		break;
+	case 2:
+		debug2("  I,B,P");
+		break;
+	case 3:
+		debug2("  SI");
+		break;
+	case 4:
+		debug2("  SI,SP");
+		break;
+	case 5:
+		debug2("  I,SI");
+		break;
+	case 6:
+		debug2("  I,SI,P,SP");
+		break;
+	case 7:
+		debug2("  I,SI,P,SP,B");
+		break;
+	default:
+		debug2("  error");
+		break;
+	}
+}
+
+/*
+ * SEI 0: buffering_period
+ */
+
+#define sei_log(_name) _param_log(sei, _name)
+#define sei_array_log(_name, _i) _param_array_log(sei, _name, _i)
+#define sei_st_array_log(_st, _name, _i) \
+	debug2_np("  " # _name " 0x%X %u", \
+		  sei->_st[_i]._name, sei->_st[_i]._name)
+
+void show_buffering_period(void *vp)
+{
+	struct buffering_period_t *sei = (struct buffering_period_t *)vp;
+	int i;
+
+	debug2("SEI 0: buffering_period");
+	sei_log(NalHrdBpPresentFlag);
+	sei_log(VclHrdBpPresentFlag);
+	sei_log(nal_hrd_cpb_cnt_minus1);
+	sei_log(vcl_hrd_cpb_cnt_minus1);
+	sei_log(seq_parameter_set_id);
+
+	if (sei->NalHrdBpPresentFlag) {
+		for (i = 0;
+		     i <= sei->nal_hrd_cpb_cnt_minus1 && i < max_cpb_cnt;
+		     i++) {
+			sei_array_log(nal_initial_cpb_removal_delay, i);
+			sei_array_log(nal_initial_cpb_removal_delay_offset, i);
+		}
+	}
+
+	if (sei->VclHrdBpPresentFlag) {
+		for (i = 0;
+		     i <= sei->vcl_hrd_cpb_cnt_minus1 && i < max_cpb_cnt; i++) {
+			sei_array_log(vcl_initial_cpb_removal_delay, i);
+			sei_array_log(vcl_initial_cpb_removal_delay_offset, i);
+		}
+	}
+}
+
+void read_buffering_period(void *vp, int *hsize)
+{
+	struct avc_regs_t *regs = avc_info->regs;
+	struct seq_parameter_set_rbsp_t *sps = &avc_info->last_sps;
+	struct buffering_period_t *sei = (struct buffering_period_t *)vp;
+	int i;
+	unsigned short v;
+	unsigned short nal_hrd_cpb_cnt_minus1;
+	unsigned short vcl_hrd_cpb_cnt_minus1;
+	TRY_GET_HEADER_DATA;
+
+	memset(sei, 0, sizeof(*sei));
+
+	v = readw(&regs->head_PRreg18);
+	sei->NalHrdBpPresentFlag = bits(v, 3, 3);
+	sei->VclHrdBpPresentFlag = bits(v, 2, 2);
+
+	sei->seq_parameter_set_id =
+		_get_header_data(hsize, &_exception);
+	if (_exception)
+		goto CATCH_GET_HEADER_DATA;
+
+	if (sei->NalHrdBpPresentFlag) {
+		nal_hrd_cpb_cnt_minus1 =
+			sps->vui_parameters.nal_hrd_parameters.cpb_cnt_minus1;
+		if (nal_hrd_cpb_cnt_minus1 >= max_cpb_cnt) {
+			/* it cannot be */
+			debug0("error nal_hrd_cpb_cnt_minus1 "
+			       "%u >= max_cpb_cnt %u",
+			       nal_hrd_cpb_cnt_minus1, max_cpb_cnt);
+			return;
+		}
+		sei->nal_hrd_cpb_cnt_minus1 = nal_hrd_cpb_cnt_minus1;
+
+		for (i = 0; i <= sei->nal_hrd_cpb_cnt_minus1; i++) {
+			sei->nal_initial_cpb_removal_delay[i] =
+				_get_header_data32(hsize, &_exception);
+			if (_exception)
+				goto CATCH_GET_HEADER_DATA;
+			sei->nal_initial_cpb_removal_delay_offset[i] =
+				_get_header_data32(hsize, &_exception);
+			if (_exception)
+				goto CATCH_GET_HEADER_DATA;
+		}
+	}
+
+	if (sei->VclHrdBpPresentFlag) {
+		vcl_hrd_cpb_cnt_minus1 =
+			sps->vui_parameters.vcl_hrd_parameters.cpb_cnt_minus1;
+		if (vcl_hrd_cpb_cnt_minus1 >= max_cpb_cnt) {
+			/* it cannot be */
+			debug0("error vcl_hrd_cpb_cnt_minus1 "
+			       "%u >= max_cpb_cnt %u",
+			       vcl_hrd_cpb_cnt_minus1, max_cpb_cnt);
+			return;
+		}
+		sei->vcl_hrd_cpb_cnt_minus1 = vcl_hrd_cpb_cnt_minus1;
+
+		for (i = 0; i <= sei->vcl_hrd_cpb_cnt_minus1; i++) {
+			sei->vcl_initial_cpb_removal_delay[i] =
+				_get_header_data32(hsize, &_exception);
+			if (_exception)
+				goto CATCH_GET_HEADER_DATA;
+			sei->vcl_initial_cpb_removal_delay_offset[i] =
+				_get_header_data32(hsize, &_exception);
+			if (_exception)
+				goto CATCH_GET_HEADER_DATA;
+		}
+	}
+
+	return;
+
+CATCH_GET_HEADER_DATA:
+	debug1("get_header_data error");
+}
+
+/*
+ * SEI 1: pic_timing
+ */
+
+void show_pic_timing(void *vp)
+{
+	struct pic_timing_t *sei = (struct pic_timing_t *)vp;
+	int i;
+
+	if (debug_level_check)
+		return;
+	debug2("SEI 1: pic_timing");
+	sei_log(CpbDpbDelaysPresentFlag);
+	sei_log(vui_pic_struct_present_flag);
+	sei_log(cpb_removal_delay);
+	sei_log(dpb_output_delay);
+	sei_log(pic_struct);
+
+	for (i = 0; i < NumClockTS; i++) {
+		debug2_np(" ct[%d]", i);
+		sei_st_array_log(ct, clock_timestamp_flag, i);
+		if (sei->ct[i].clock_timestamp_flag == 0)
+			continue;
+		sei_st_array_log(ct, ct_type, i);
+		sei_st_array_log(ct, nuit_field_based_flag, i);
+		sei_st_array_log(ct, counting_type, i);
+		sei_st_array_log(ct, full_timestamp_flag, i);
+		sei_st_array_log(ct, discontinuity_flag, i);
+		sei_st_array_log(ct, cnt_dropped_flag, i);
+		sei_st_array_log(ct, n_frames, i);
+		sei_st_array_log(ct, seconds_value, i);
+		sei_st_array_log(ct, minutes_value, i);
+		sei_st_array_log(ct, hours_value, i);
+		sei_st_array_log(ct, seconds_flag, i);
+		sei_st_array_log(ct, minutes_flag, i);
+		sei_st_array_log(ct, hours_flag, i);
+		sei_st_array_log(ct, time_offset, i);
+	}
+}
+
+void read_pic_timing(void *vp, int *hsize)
+{
+	struct avc_regs_t *regs = avc_info->regs;
+	struct seq_parameter_set_rbsp_t *sps = &avc_info->last_sps;
+	struct pic_timing_t *sei = (struct pic_timing_t *)vp;
+	unsigned short time_offset_length = 0;
+	unsigned short numclock = 0;
+	int i;
+	unsigned short v;
+	TRY_GET_HEADER_DATA;
+
+	memset(sei, 0, sizeof(*sei));
+
+	v = readw(&regs->head_PRreg18);
+	sei->CpbDpbDelaysPresentFlag = bits(v, 1, 1);
+	sei->vui_pic_struct_present_flag =
+		sps->vui_parameters.pic_struct_present_flag;
+
+	if (sei->CpbDpbDelaysPresentFlag) {
+		sei->cpb_removal_delay =
+			_get_header_data32(hsize, &_exception);
+		if (_exception)
+			goto CATCH_GET_HEADER_DATA;
+		sei->dpb_output_delay  =
+			_get_header_data32(hsize, &_exception);
+		if (_exception)
+			goto CATCH_GET_HEADER_DATA;
+	}
+
+	if (sei->vui_pic_struct_present_flag) {
+
+		struct vui_parameters_t *vui = &sps->vui_parameters;
+		time_offset_length =
+			vui->nal_hrd_parameters.time_offset_length;
+		if (time_offset_length == 0)
+			time_offset_length =
+				vui->vcl_hrd_parameters.time_offset_length;
+
+		sei->pic_struct = _get_header_data(hsize, &_exception);
+		if (_exception)
+			goto CATCH_GET_HEADER_DATA;
+		switch (sei->pic_struct) {
+		case 0:
+		case 1:
+		case 2:
+			numclock = 1;
+			break;
+		case 3:
+		case 4:
+		case 7:
+			numclock = 2;
+			break;
+		case 5:
+		case 6:
+		case 8:
+			numclock = 3;
+			break;
+		default:
+			break;
+		}
+
+		for (i = 0; i < numclock; i++) {
+			sei->ct[i].clock_timestamp_flag =
+				_get_header_data(hsize, &_exception);
+			if (_exception)
+				goto CATCH_GET_HEADER_DATA;
+			if (sei->ct[i].clock_timestamp_flag) {
+				v = _get_header_data(hsize, &_exception);
+				if (_exception)
+					goto CATCH_GET_HEADER_DATA;
+				sei->ct[i].ct_type               =
+					bits(v, 7, 6);
+				sei->ct[i].nuit_field_based_flag =
+					bits(v, 5, 5);
+				sei->ct[i].counting_type         =
+					bits(v, 4, 0);
+				v = _get_header_data(hsize, &_exception);
+				if (_exception)
+					goto CATCH_GET_HEADER_DATA;
+				sei->ct[i].full_timestamp_flag =
+					bits(v, 10, 10);
+				sei->ct[i].discontinuity_flag  = bits(v, 9, 9);
+				sei->ct[i].cnt_dropped_flag    = bits(v, 8, 8);
+				sei->ct[i].n_frames            = bits(v, 7, 0);
+				if (sei->ct[i].full_timestamp_flag) {
+					sei->ct[i].seconds_value =
+						_get_header_data(
+							hsize, &_exception);
+					if (_exception)
+						goto CATCH_GET_HEADER_DATA;
+					v = _get_header_data(
+						hsize, &_exception);
+					if (_exception)
+						goto CATCH_GET_HEADER_DATA;
+					sei->ct[i].minutes_value =
+						bits(v, 13, 8);
+					sei->ct[i].hours_value   =
+						bits(v, 5, 0);
+				} else {
+					sei->ct[i].seconds_flag =
+						_get_header_data(
+							hsize, &_exception);
+					if (_exception)
+						goto CATCH_GET_HEADER_DATA;
+					if (sei->ct[i].seconds_flag) {
+						v = _get_header_data(
+							hsize, &_exception);
+						if (_exception)
+							goto CH;
+						sei->ct[i].seconds_value =
+							bits(v, 6, 1);
+						sei->ct[i].minutes_flag  =
+							bits(v, 0, 0);
+						if (sei->ct[i].minutes_flag) {
+							v = _get_header_data(
+								hsize,
+								&_exception);
+							if (_exception)
+								goto CH;
+							sei->ct[i].minutes_value
+								= bits(v, 6, 1);
+							sei->ct[i].hours_flag
+								= bits(v, 0, 0);
+							if (sei->ct[i]
+							    .hours_flag){
+								sei->ct[i].hours_value = _get_header_data(hsize, &_exception);
+								if (_exception)
+									goto CH;
+							}
+						}
+					}
+				}
+				if (time_offset_length > 0) {
+					sei->ct[i].time_offset =
+						_get_header_data32(
+							hsize, &_exception);
+					if (_exception)
+						goto CATCH_GET_HEADER_DATA;
+				}
+			}
+		}
+	}
+
+	return;
+
+CATCH_GET_HEADER_DATA:
+CH:
+	debug1("get_header_data error");
+}
+
+/*
+ * SEI 2: pan_scan_rect
+ */
+
+void show_pan_scan_rect(void *vp)
+{
+	struct pan_scan_rect_t *sei = (struct pan_scan_rect_t *)vp;
+	int i;
+
+	if (debug_level_check)
+		return;
+	debug2("SEI 2: pan_scan_rect");
+	sei_log(pan_scan_rect_id);
+	sei_log(pan_scan_rect_cancel_flag);
+	sei_log(pan_scan_cnt_minus1);
+
+	if (!sei->pan_scan_rect_cancel_flag) {
+		for (i = 0;
+		     i <= sei->pan_scan_cnt_minus1 && i < max_pan_scan_cnt;
+		     i++) {
+			debug2_np(" psr[%d]", i);
+			sei_st_array_log(psr, left_offset, i);
+			sei_st_array_log(psr, right_offset, i);
+			sei_st_array_log(psr, top_offset, i);
+			sei_st_array_log(psr, bottom_offset, i);
+		}
+	}
+
+	sei_log(pan_scan_rect_repetition_period);
+}
+
+void read_pan_scan_rect(void *vp, int *hsize)
+{
+	struct pan_scan_rect_t *sei = (struct pan_scan_rect_t *)vp;
+	int i;
+	TRY_GET_HEADER_DATA;
+
+	memset(sei, 0, sizeof(*sei));
+
+	sei->pan_scan_rect_id = _get_header_data32(hsize, &_exception);
+	if (_exception)
+		goto CATCH_GET_HEADER_DATA;
+	sei->pan_scan_rect_cancel_flag =
+		_get_header_data(hsize, &_exception);
+	if (_exception)
+		goto CATCH_GET_HEADER_DATA;
+
+	if (!sei->pan_scan_rect_cancel_flag) {
+		sei->pan_scan_cnt_minus1 =
+			_get_header_data(hsize, &_exception);
+		if (_exception)
+			goto CATCH_GET_HEADER_DATA;
+		if (sei->pan_scan_cnt_minus1 >= max_pan_scan_cnt) {
+			/* it cannot be */
+			debug0("error pan_scan_cnt_minus1 "
+			       "%u >= max_pan_scan_cnt %u",
+			       sei->pan_scan_cnt_minus1, max_pan_scan_cnt);
+			return;
+		}
+		for (i = 0; i <= sei->pan_scan_cnt_minus1; i++) {
+			sei->psr[i].left_offset   =
+				_get_header_data32(hsize, &_exception);
+			if (_exception)
+				goto CATCH_GET_HEADER_DATA;
+			sei->psr[i].right_offset  =
+				_get_header_data32(hsize, &_exception);
+			if (_exception)
+				goto CATCH_GET_HEADER_DATA;
+			sei->psr[i].top_offset    =
+				_get_header_data32(hsize, &_exception);
+			if (_exception)
+				goto CATCH_GET_HEADER_DATA;
+			sei->psr[i].bottom_offset =
+				_get_header_data32(hsize, &_exception);
+			if (_exception)
+				goto CATCH_GET_HEADER_DATA;
+		}
+		sei->pan_scan_rect_repetition_period =
+			_get_header_data(hsize, &_exception);
+		if (_exception)
+			goto CATCH_GET_HEADER_DATA;
+	}
+
+	return;
+
+CATCH_GET_HEADER_DATA:
+	debug1("get_header_data error");
+}
+
+/*
+ * SEI 3: filler_payload
+ */
+
+void show_filler_payload(void *vp)
+{
+	struct filler_payload_t *sei = (struct filler_payload_t *)vp;
+
+	if (debug_level_check)
+		return;
+	debug2("SEI 3: filler_payload");
+	sei_log(payloadSize);
+}
+
+void read_filler_payload(void *vp, int *hsize)
+{
+	struct avc_regs_t *regs = avc_info->regs;
+	struct filler_payload_t *sei = (struct filler_payload_t *)vp;
+
+	memset(sei, 0, sizeof(*sei));
+
+	sei->payloadSize = readw(&regs->head_PRreg17);
+}
+
+/*
+ * SEI 4: user_data_registered_itu_t_t35
+ */
+
+void show_user_data_registered_itu_t_t35(void *vp)
+{
+	struct user_data_registered_itu_t_t35_t *sei =
+		(struct user_data_registered_itu_t_t35_t *)vp;
+
+	if (debug_level_check)
+		return;
+	debug2("SEI 4: user_data_registered_itu_t_t35");
+	sei_log(itu_t_t35_country_code);
+	sei_log(itu_t_t35_payload_byte);
+	sei_log(itu_t_t35_country_code_extension_byte);
+}
+
+void read_user_data_registered_itu_t_t35(void *vp, int *hsize)
+{
+	struct user_data_registered_itu_t_t35_t *sei =
+		(struct user_data_registered_itu_t_t35_t *)vp;
+	unsigned short v;
+	TRY_GET_HEADER_DATA;
+
+	memset(sei, 0, sizeof(*sei));
+
+	v = _get_header_data(hsize, &_exception);
+	if (_exception)
+		goto CATCH_GET_HEADER_DATA;
+	sei->itu_t_t35_country_code = bits(v, 15, 8);
+	if (sei->itu_t_t35_country_code != 0xFF)
+		sei->itu_t_t35_payload_byte = bits(v, 7, 0);
+	else
+		sei->itu_t_t35_country_code_extension_byte = bits(v, 7, 0);
+
+	return;
+
+CATCH_GET_HEADER_DATA:
+	debug1("get_header_data error");
+}
+
+/*
+ * SEI 5: user_data_unregistered
+ */
+
+void show_user_data_unregistered(void *vp)
+{
+	struct user_data_unregistered_t *sei =
+		(struct user_data_unregistered_t *)vp;
+	int i;
+
+	if (debug_level_check)
+		return;
+	debug2("SEI 5: user_data_unregistered");
+	for (i = 0; i < 8; i++)
+		sei_array_log(uuid_iso_iec_11578, i);
+}
+
+void read_user_data_unregistered(void *vp, int *hsize)
+{
+	struct user_data_unregistered_t *sei =
+		(struct user_data_unregistered_t *)vp;
+	int i;
+	TRY_GET_HEADER_DATA;
+
+	memset(sei, 0, sizeof(*sei));
+
+	for (i = 7; i >= 0; i--) {
+		sei->uuid_iso_iec_11578[i] =
+			_get_header_data(hsize, &_exception);
+		if (_exception)
+			goto CATCH_GET_HEADER_DATA;
+	}
+	return;
+
+CATCH_GET_HEADER_DATA:
+	debug1("get_header_data error");
+}
+
+/*
+ * SEI 6: recovery_point
+ */
+
+void show_recovery_point(void *vp)
+{
+	struct recovery_point_t *sei =
+		(struct recovery_point_t *)vp;
+
+	if (debug_level_check)
+		return;
+	debug2("SEI 6: recovery_point");
+	sei_log(recovery_frame_cnt);
+	sei_log(exact_match_flag);
+	sei_log(broken_link_flag);
+	sei_log(changing_slice_group_idc);
+}
+
+void read_recovery_point(void *vp, int *hsize)
+{
+	struct recovery_point_t *sei =
+		(struct recovery_point_t *)vp;
+	unsigned short v;
+	TRY_GET_HEADER_DATA;
+
+	memset(sei, 0, sizeof(*sei));
+
+	sei->recovery_frame_cnt = _get_header_data(hsize, &_exception);
+	if (_exception)
+		goto CATCH_GET_HEADER_DATA;
+	v = _get_header_data(hsize, &_exception);
+	if (_exception)
+		goto CATCH_GET_HEADER_DATA;
+	sei->exact_match_flag = bits(v, 3, 3);
+	sei->broken_link_flag = bits(v, 2, 2);
+	sei->changing_slice_group_idc = bits(v, 1, 0);
+
+	return;
+
+CATCH_GET_HEADER_DATA:
+	debug1("get_header_data error");
+}
+
+/*
+ * SEI 7: dec_ref_pic_marking_repetition
+ */
+
+void show_dec_ref_pic_marking_repetition(void *vp)
+{
+	struct dec_ref_pic_marking_repetition_t *sei =
+		(struct dec_ref_pic_marking_repetition_t *)vp;
+
+	if (debug_level_check)
+		return;
+	debug2("SEI 7: dec_ref_pic_marking_repetition");
+	sei_log(sps_frame_mbs_only_flag);
+	sei_log(original_idr_flag);
+	sei_log(original_frame_num);
+	sei_log(original_field_pic_flag);
+	sei_log(original_bottom_field_flag);
+
+	show_dec_ref_pic_marking(&sei->dec_ref_pic_marking);
+}
+
+void read_dec_ref_pic_marking_repetition(void *vp, int *hsize)
+{
+	struct avc_regs_t *regs = avc_info->regs;
+	struct dec_ref_pic_marking_repetition_t *sei =
+		(struct dec_ref_pic_marking_repetition_t *)vp;
+	/* struct avc_last_sps_t *sps = &avc_info->last_sps; */
+	unsigned short v;
+	TRY_GET_HEADER_DATA;
+
+	memset(sei, 0, sizeof(*sei));
+
+	v = readw(&regs->dec_PARreg8);
+	sei->sps_frame_mbs_only_flag = bits(v, 15, 15);
+	/* sei->sps_frame_mbs_only_flag = sps->frame_mbs_only_flag; */
+
+	sei->original_idr_flag = _get_header_data(hsize, &_exception);
+	if (_exception)
+		goto CATCH_GET_HEADER_DATA;
+	sei->original_frame_num = _get_header_data(hsize, &_exception);
+	if (_exception)
+		goto CATCH_GET_HEADER_DATA;
+	if (!sei->sps_frame_mbs_only_flag) {
+		sei->original_field_pic_flag =
+			_get_header_data(hsize, &_exception);
+		if (_exception)
+			goto CATCH_GET_HEADER_DATA;
+		if (sei->original_field_pic_flag) {
+			sei->original_bottom_field_flag =
+				_get_header_data(hsize, &_exception);
+			if (_exception)
+				goto CATCH_GET_HEADER_DATA;
+		}
+	}
+	read_dec_ref_pic_marking(&sei->dec_ref_pic_marking, hsize);
+
+	return;
+
+CATCH_GET_HEADER_DATA:
+	debug1("get_header_data error");
+}
+
+/*
+ * SEI 8: spare_pic
+ */
+
+#define sp_u_log(_name, _i, _j)	\
+	debug2_np("  " # _name "[%d] 0x%X %u", \
+		  _j, sei->spare_pics[_i].u._name[_j], \
+		  sei->spare_pics[_i].u._name[_j])
+
+void show_spare_pic(void *vp)
+{
+	struct spare_pic_t *sei = (struct spare_pic_t *)vp;
+	int i, j;
+	int max1, max2;
+
+	if (debug_level_check)
+		return;
+	debug2("SEI 8: spare_pic");
+	sei_log(pps_pic_size_in_map_units);
+	sei_log(target_frame_num);
+	sei_log(spare_field_flag);
+	sei_log(target_bottom_field_flag);
+	sei_log(num_spare_pics_minus1);
+
+	max1 = minimum(sei->num_spare_pics_minus1 + 1, max_num_spare_pics);
+	for (i = 0; i < max1; i++) {
+		debug2_np(" spare_pics[%d]", i);
+		sei_st_array_log(spare_pics, delta_spare_frame_num, i);
+		sei_st_array_log(spare_pics, spare_bottom_field_flag, i);
+		sei_st_array_log(spare_pics, spare_area_idc, i);
+		max2 = minimum(sei->pps_pic_size_in_map_units,
+			       max_pic_size_in_map_units);
+		if (sei->spare_pics[i].spare_area_idc == 1) {
+			for (j = 0; j < max2; j++)
+				sp_u_log(spare_unit_flag, i, j);
+		} else if (sei->spare_pics[i].spare_area_idc == 2) {
+			unsigned short mapUnitCnt = 0;
+			for (j = 0; mapUnitCnt < max2; j++) {
+				sp_u_log(zero_run_length, i, j);
+				mapUnitCnt +=
+					sei->spare_pics[i].u.zero_run_length[j]
+					+ 1;
+			}
+		}
+	}
+}
+
+void read_spare_pic(void *vp, int *hsize)
+{
+	struct spare_pic_t *sei = (struct spare_pic_t *)vp;
+	struct pic_parameter_set_rbsp_t *pps = &avc_info->last_pps;
+	int i, j;
+	TRY_GET_HEADER_DATA;
+
+	memset(sei, 0, sizeof(*sei));
+
+	sei->pps_pic_size_in_map_units = pps->pic_size_in_map_units_minus1 + 1;
+
+	if (sei->pps_pic_size_in_map_units > max_pic_size_in_map_units) {
+		/* it cannot be */
+		debug0("error pps_pic_size_in_map_units %u >"
+		       "max_pic_size_in_map_units %u",
+		       sei->pps_pic_size_in_map_units,
+		       max_pic_size_in_map_units);
+		return;
+	}
+
+	sei->target_frame_num = _get_header_data(hsize, &_exception);
+	if (_exception)
+		goto CATCH_GET_HEADER_DATA;
+	sei->spare_field_flag = _get_header_data(hsize, &_exception);
+	if (_exception)
+		goto CATCH_GET_HEADER_DATA;
+	if (sei->spare_field_flag) {
+		sei->target_bottom_field_flag =
+			_get_header_data(hsize, &_exception);
+		if (_exception)
+			goto CATCH_GET_HEADER_DATA;
+	}
+
+	sei->num_spare_pics_minus1 = _get_header_data(hsize, &_exception);
+	if (_exception)
+		goto CATCH_GET_HEADER_DATA;
+
+	if (sei->num_spare_pics_minus1 + 1 >= max_num_spare_pics) {
+		/* it cannot be */
+		debug0("error num_spare_pics_minus1+1 %u "
+		       ">= max_num_spare_pics %u",
+		       sei->num_spare_pics_minus1, max_num_spare_pics);
+		return;
+	}
+
+	for (i = 0; i < sei->num_spare_pics_minus1 + 1; i++) {
+		sei->spare_pics[i].delta_spare_frame_num =
+			_get_header_data(hsize, &_exception);
+		if (_exception)
+			goto CATCH_GET_HEADER_DATA;
+		if (sei->spare_field_flag) {
+			sei->spare_pics[i].spare_bottom_field_flag =
+				_get_header_data(hsize, &_exception);
+			if (_exception)
+				goto CATCH_GET_HEADER_DATA;
+		}
+		sei->spare_pics[i].spare_area_idc =
+			_get_header_data(hsize, &_exception);
+		if (_exception)
+			goto CATCH_GET_HEADER_DATA;
+		if (sei->spare_pics[i].spare_area_idc == 1) {
+			for (j = 0; j < sei->pps_pic_size_in_map_units; j++) {
+				sei->spare_pics[i].u.spare_unit_flag[j] =
+					_get_header_data(hsize, &_exception);
+				if (_exception)
+					goto CATCH_GET_HEADER_DATA;
+			}
+		} else if (sei->spare_pics[i].spare_area_idc == 2) {
+			unsigned short mapUnitCnt = 0;
+			for (j = 0;
+			     mapUnitCnt < sei->pps_pic_size_in_map_units; j++) {
+				sei->spare_pics[i].u.zero_run_length[j] =
+					_get_header_data(hsize, &_exception);
+				if (_exception)
+					goto CATCH_GET_HEADER_DATA;
+				mapUnitCnt +=
+					sei->spare_pics[i].u.zero_run_length[j]
+					+ 1;
+			}
+		}
+	}
+
+	return;
+
+CATCH_GET_HEADER_DATA:
+	debug1("get_header_data error");
+}
+
+/*
+ * SEI 9: scene_info
+ */
+
+void show_scene_info(void *vp)
+{
+	struct scene_info_t *sei = (struct scene_info_t *)vp;
+
+	if (debug_level_check)
+		return;
+	debug2("SEI 9: scene_info");
+	sei_log(scene_info_present_flag);
+	sei_log(scene_id);
+	sei_log(scene_transition_type);
+	sei_log(second_scene_id);
+}
+
+void read_scene_info(void *vp, int *hsize)
+{
+	struct scene_info_t *sei = (struct scene_info_t *)vp;
+	TRY_GET_HEADER_DATA;
+
+	memset(sei, 0, sizeof(*sei));
+
+	sei->scene_info_present_flag = _get_header_data(hsize, &_exception);
+	if (_exception)
+		goto CATCH_GET_HEADER_DATA;
+	if (sei->scene_info_present_flag) {
+		sei->scene_id = _get_header_data32(hsize, &_exception);
+		if (_exception)
+			goto CATCH_GET_HEADER_DATA;
+		sei->scene_transition_type =
+			_get_header_data(hsize, &_exception);
+		if (_exception)
+			goto CATCH_GET_HEADER_DATA;
+		if (sei->scene_transition_type > 3) {
+			sei->second_scene_id =
+				_get_header_data32(hsize, &_exception);
+			if (_exception)
+				goto CATCH_GET_HEADER_DATA;
+		}
+	}
+
+	return;
+
+CATCH_GET_HEADER_DATA:
+	debug1("get_header_data error");
+}
+
+/*
+ * SEI 10: sub_seq_info
+ */
+
+void show_sub_seq_info(void *vp)
+{
+	struct sub_seq_info_t *sei = (struct sub_seq_info_t *)vp;
+
+	if (debug_level_check)
+		return;
+	debug2("SEI 10: sub_seq_info");
+	sei_log(sub_seq_layer_num);
+	sei_log(sub_seq_id);
+	sei_log(first_ref_pic_flag);
+	sei_log(leading_non_ref_pic_flag);
+	sei_log(last_pic_flag);
+	sei_log(sub_seq_frame_num_flag);
+	sei_log(sub_seq_frame_num);
+}
+
+void read_sub_seq_info(void *vp, int *hsize)
+{
+	struct sub_seq_info_t *sei = (struct sub_seq_info_t *)vp;
+	unsigned short v;
+	TRY_GET_HEADER_DATA;
+
+	memset(sei, 0, sizeof(*sei));
+
+	sei->sub_seq_layer_num = _get_header_data(hsize, &_exception);
+	if (_exception)
+		goto CATCH_GET_HEADER_DATA;
+	sei->sub_seq_id = _get_header_data(hsize, &_exception);
+	if (_exception)
+		goto CATCH_GET_HEADER_DATA;
+	v = _get_header_data(hsize, &_exception);
+	if (_exception)
+		goto CATCH_GET_HEADER_DATA;
+	sei->first_ref_pic_flag = bits(v, 3, 3);
+	sei->leading_non_ref_pic_flag = bits(v, 2, 2);
+	sei->last_pic_flag = bits(v, 1, 1);
+	sei->sub_seq_frame_num_flag = bits(v, 0, 0);
+	if (sei->sub_seq_frame_num_flag) {
+		sei->sub_seq_frame_num = _get_header_data(hsize, &_exception);
+		if (_exception)
+			goto CATCH_GET_HEADER_DATA;
+	}
+	return;
+
+CATCH_GET_HEADER_DATA:
+	debug1("get_header_data error");
+}
+
+/*
+ * SEI 11: sub_seq_layer_characteristics
+ */
+
+void show_sub_seq_layer_characteristics(void *vp)
+{
+	struct sub_seq_layer_characteristics_t *sei =
+		(struct sub_seq_layer_characteristics_t *)vp;
+
+	if (debug_level_check)
+		return;
+	debug2("SEI 11: sub_seq_layer_characteristics");
+	sei_log(num_sub_seq_layers_minus1);
+	sei_log(accurate_statistics_flag);
+	sei_log(average_bit_rate);
+	sei_log(average_frame_rate);
+}
+
+void read_sub_seq_layer_characteristics(void *vp, int *hsize)
+{
+	struct sub_seq_layer_characteristics_t *sei =
+		(struct sub_seq_layer_characteristics_t *)vp;
+	int i;
+	TRY_GET_HEADER_DATA;
+
+	memset(sei, 0, sizeof(*sei));
+
+	sei->num_sub_seq_layers_minus1 = _get_header_data(hsize, &_exception);
+	if (_exception)
+		goto CATCH_GET_HEADER_DATA;
+	for (i = 0; i <= sei->num_sub_seq_layers_minus1; i++) {
+		sei->accurate_statistics_flag =
+			_get_header_data(hsize, &_exception);
+		if (_exception)
+			goto CATCH_GET_HEADER_DATA;
+		sei->average_bit_rate = _get_header_data(hsize, &_exception);
+		if (_exception)
+			goto CATCH_GET_HEADER_DATA;
+		sei->average_frame_rate =
+			_get_header_data(hsize, &_exception);
+		if (_exception)
+			goto CATCH_GET_HEADER_DATA;
+	}
+
+	return;
+
+CATCH_GET_HEADER_DATA:
+	debug1("get_header_data error");
+}
+
+
+/*
+ * SEI 12: sub_seq_characteristics
+ */
+
+void show_sub_seq_characteristics(void *vp)
+{
+	struct sub_seq_characteristics_t *sei =
+		(struct sub_seq_characteristics_t *)vp;
+
+	if (debug_level_check)
+		return;
+	debug2("SEI 12: sub_seq_characteristics");
+	sei_log(sub_seq_layer_num);
+	sei_log(sub_seq_id);
+	sei_log(duration_flag);
+	sei_log(sub_seq_duration);
+	sei_log(average_rate_flag);
+	sei_log(accurate_statistics_flag);
+	sei_log(average_bit_rate);
+	sei_log(average_frame_rate);
+	sei_log(num_referenced_subseqs);
+	sei_log(ref_sub_seq_layer_num);
+	sei_log(ref_sub_seq_id);
+	sei_log(ref_sub_seq_direction);
+}
+
+void read_sub_seq_characteristics(void *vp, int *hsize)
+{
+	struct sub_seq_characteristics_t *sei =
+		(struct sub_seq_characteristics_t *)vp;
+	unsigned short v;
+	int i;
+	TRY_GET_HEADER_DATA;
+
+	memset(sei, 0, sizeof(*sei));
+
+	sei->sub_seq_layer_num = _get_header_data(hsize, &_exception);
+	if (_exception)
+		goto CATCH_GET_HEADER_DATA;
+	sei->sub_seq_id = _get_header_data(hsize, &_exception);
+	if (_exception)
+		goto CATCH_GET_HEADER_DATA;
+	sei->duration_flag = _get_header_data(hsize, &_exception);
+	if (_exception)
+		goto CATCH_GET_HEADER_DATA;
+	if (sei->duration_flag) {
+		sei->sub_seq_duration =
+			_get_header_data32(hsize, &_exception);
+		if (_exception)
+			goto CATCH_GET_HEADER_DATA;
+	}
+
+	v = _get_header_data(hsize, &_exception);
+	if (_exception)
+		goto CATCH_GET_HEADER_DATA;
+	sei->average_rate_flag = bits(v, 0, 0);
+	if (sei->average_rate_flag) {
+		sei->accurate_statistics_flag = bits(v, 1, 1);
+		sei->average_bit_rate =
+			_get_header_data(hsize, &_exception);
+		if (_exception)
+			goto CATCH_GET_HEADER_DATA;
+		sei->average_frame_rate =
+			_get_header_data(hsize, &_exception);
+		if (_exception)
+			goto CATCH_GET_HEADER_DATA;
+	}
+
+	sei->num_referenced_subseqs =
+		_get_header_data(hsize, &_exception);
+	if (_exception)
+		goto CATCH_GET_HEADER_DATA;
+	for (i = 0; i < sei->num_referenced_subseqs; i++) {
+		sei->ref_sub_seq_layer_num =
+			_get_header_data(hsize, &_exception);
+		if (_exception)
+			goto CATCH_GET_HEADER_DATA;
+		sei->ref_sub_seq_id = _get_header_data(hsize, &_exception);
+		if (_exception)
+			goto CATCH_GET_HEADER_DATA;
+		sei->ref_sub_seq_direction =
+			_get_header_data(hsize, &_exception);
+		if (_exception)
+			goto CATCH_GET_HEADER_DATA;
+	}
+
+	return;
+
+CATCH_GET_HEADER_DATA:
+	debug1("get_header_data error");
+}
+
+/*
+ * SEI 13: full_frame_freeze
+ */
+
+void show_full_frame_freeze(void *vp)
+{
+	struct full_frame_freeze_t *sei = (struct full_frame_freeze_t *)vp;
+
+	if (debug_level_check)
+		return;
+	debug2("SEI 13: full_frame_freeze");
+	sei_log(full_frame_freeze_repetition_period);
+}
+
+void read_full_frame_freeze(void *vp, int *hsize)
+{
+	struct full_frame_freeze_t *sei = (struct full_frame_freeze_t *)vp;
+	TRY_GET_HEADER_DATA;
+
+	memset(sei, 0, sizeof(*sei));
+
+	sei->full_frame_freeze_repetition_period =
+		_get_header_data(hsize, &_exception);
+	if (_exception)
+		goto CATCH_GET_HEADER_DATA;
+
+	return;
+
+CATCH_GET_HEADER_DATA:
+	debug1("get_header_data error");
+}
+
+/*
+ * SEI 15: full_frame_snapshot
+ */
+
+void show_full_frame_snapshot(void *vp)
+{
+	struct full_frame_snapshot_t *sei = (struct full_frame_snapshot_t *)vp;
+
+	if (debug_level_check)
+		return;
+	debug2("SEI 15: full_frame_snapshot");
+	sei_log(snapshot_id);
+}
+
+void read_full_frame_snapshot(void *vp, int *hsize)
+{
+	struct full_frame_snapshot_t *sei = (struct full_frame_snapshot_t *)vp;
+	TRY_GET_HEADER_DATA;
+
+	memset(sei, 0, sizeof(*sei));
+
+	sei->snapshot_id = _get_header_data32(hsize, &_exception);
+	if (_exception)
+		goto CATCH_GET_HEADER_DATA;
+
+	return;
+
+CATCH_GET_HEADER_DATA:
+	debug1("get_header_data error");
+}
+
+/*
+ * SEI 16: progressive_refinement_segment_start
+ */
+
+void show_progressive_refinement_segment_start(void *vp)
+{
+	struct progressive_refinement_segment_start_t *sei =
+		(struct progressive_refinement_segment_start_t *)vp;
+
+	if (debug_level_check)
+		return;
+	debug2("SEI 16: progressive_refinement_segment_start");
+	sei_log(progressive_refinement_id);
+	sei_log(num_refinement_steps_minus1);
+}
+
+void read_progressive_refinement_segment_start(void *vp, int *hsize)
+{
+	struct progressive_refinement_segment_start_t *sei =
+		(struct progressive_refinement_segment_start_t *)vp;
+	TRY_GET_HEADER_DATA;
+
+	memset(sei, 0, sizeof(*sei));
+
+	sei->progressive_refinement_id =
+		_get_header_data32(hsize, &_exception);
+	if (_exception)
+		goto CATCH_GET_HEADER_DATA;
+	sei->num_refinement_steps_minus1 =
+		_get_header_data(hsize, &_exception);
+	if (_exception)
+		goto CATCH_GET_HEADER_DATA;
+
+	return;
+
+CATCH_GET_HEADER_DATA:
+	debug1("get_header_data error");
+}
+
+/*
+ * SEI 17: progressive_refinement_segment_end
+ */
+
+void show_progressive_refinement_segment_end(void *vp)
+{
+	struct progressive_refinement_segment_end_t *sei =
+		(struct progressive_refinement_segment_end_t *)vp;
+
+	if (debug_level_check)
+		return;
+	debug2("SEI 17: progressive_refinement_segment_end");
+	sei_log(progressive_refinement_id);
+}
+
+void read_progressive_refinement_segment_end(void *vp, int *hsize)
+{
+	struct progressive_refinement_segment_end_t *sei =
+		(struct progressive_refinement_segment_end_t *)vp;
+	TRY_GET_HEADER_DATA;
+
+	memset(sei, 0, sizeof(*sei));
+
+	sei->progressive_refinement_id =
+		_get_header_data32(hsize, &_exception);
+	if (_exception)
+		goto CATCH_GET_HEADER_DATA;
+
+	return;
+
+CATCH_GET_HEADER_DATA:
+	debug1("get_header_data error");
+}
+
+/*
+ * SEI 18: motion_constrained_slice_group_set
+ */
+
+void show_motion_constrained_slice_group_set(void *vp)
+{
+	struct motion_constrained_slice_group_set_t *sei =
+		(struct motion_constrained_slice_group_set_t *)vp;
+	int i;
+	int max;
+
+	if (debug_level_check)
+		return;
+	debug2("SEI 18: motion_constrained_slice_group_set");
+	sei_log(num_slice_groups_in_set_minus1);
+	max = minimum(sei->num_slice_groups_in_set_minus1,
+		      max_num_slice_groups_in_set - 1);
+	for (i = 0; i <= max; i++)
+		sei_array_log(slice_group_id, i);
+	sei_log(exact_sample_value_match_flag);
+	sei_log(pan_scan_rect_flag);
+	sei_log(pan_scan_rect_id);
+}
+
+void read_motion_constrained_slice_group_set(void *vp, int *hsize)
+{
+	struct motion_constrained_slice_group_set_t *sei =
+		(struct motion_constrained_slice_group_set_t *)vp;
+	unsigned short v;
+	int i;
+	TRY_GET_HEADER_DATA;
+
+	memset(sei, 0, sizeof(*sei));
+
+	sei->num_slice_groups_in_set_minus1 =
+		_get_header_data(hsize, &_exception);
+	if (_exception)
+		goto CATCH_GET_HEADER_DATA;
+	if (sei->num_slice_groups_in_set_minus1 >=
+	    max_num_slice_groups_in_set) {
+		/* it cannot be */
+		debug0("error num_slice_groups_in_set_minus1 %u >= "
+		       "max_num_slice_groups_in_set %u",
+		       sei->num_slice_groups_in_set_minus1,
+		       max_num_slice_groups_in_set);
+		return;
+	}
+
+	for (i = 0; i <= sei->num_slice_groups_in_set_minus1; i++) {
+		sei->slice_group_id[i] = _get_header_data(hsize, &_exception);
+		if (_exception)
+			goto CATCH_GET_HEADER_DATA;
+	}
+	v = _get_header_data(hsize, &_exception);
+	if (_exception)
+		goto CATCH_GET_HEADER_DATA;
+	sei->exact_sample_value_match_flag = bits(v, 1, 1);
+	sei->pan_scan_rect_flag = bits(v, 0, 0);
+	if (sei->pan_scan_rect_flag) {
+		sei->pan_scan_rect_id =
+			_get_header_data32(hsize, &_exception);
+		if (_exception)
+			goto CATCH_GET_HEADER_DATA;
+	}
+	return;
+
+CATCH_GET_HEADER_DATA:
+	debug1("get_header_data error");
+}
+
+/*
+ * SEI 19: film_grain_characteristics
+ */
+
+#define sei_array2_log(_name, _i, _j) \
+	debug2_np(" " # _name "[%d][%d] 0x%X %u", \
+		  _i, _j, sei->_name[_i][_j], sei->_name[_i][_j])
+
+#define sei_array3_log(_name, _i, _j, _k) \
+	debug2_np(" " # _name "[%d][%d][%d] 0x%X %u", \
+		  _i, _j, _k, sei->_name[_i][_j][_k], sei->_name[_i][_j][_k])
+
+void show_film_grain_characteristics(void *vp)
+{
+	struct film_grain_characteristics_t *sei =
+		(struct film_grain_characteristics_t *)vp;
+	int c, i, j;
+	int max1, max2;
+
+	if (debug_level_check)
+		return;
+	debug2("SEI 19: film_grain_characteristics");
+	sei_log(film_grain_characteristics_cancel_flag);
+	sei_log(model_id);
+	sei_log(separate_colour_description_present_flag);
+	sei_log(film_grain_bit_depth_luma_minus8);
+	sei_log(film_grain_bit_depth_chroma_minus8);
+	sei_log(film_grain_full_range_flag);
+	sei_log(film_grain_colour_primaries);
+	sei_log(film_grain_transfer_characteristics);
+	sei_log(film_grain_matrix_coefficients);
+	sei_log(blending_mode_id);
+	sei_log(log2_scale_factor);
+	for (c = 0; c < 3; c++) {
+		sei_array_log(comp_model_present_flag, c);
+		if (sei->comp_model_present_flag[c]) {
+			sei_array_log(num_intensity_intervals_minus1, c);
+			sei_array_log(num_model_values_minus1, c);
+			max1 = minimum(sei->num_intensity_intervals_minus1[c],
+				       max_num_intensity_intervals - 1);
+			max2 = minimum(sei->num_model_values_minus1[c],
+				       max_num_model_values - 1);
+			for (i = 0; i <= max1; i++) {
+				sei_array2_log(intensity_interval_lower_bound,
+					       c, i);
+				sei_array2_log(intensity_interval_upper_bound,
+					       c, i);
+				for (j = 0; j <= max2; j++)
+					sei_array3_log(comp_model_value,
+						       c, i, j);
+			}
+		}
+	}
+	sei_log(film_grain_characteristics_repetition_period);
+}
+
+void read_film_grain_characteristics(void *vp, int *hsize)
+{
+	struct film_grain_characteristics_t *sei =
+		(struct film_grain_characteristics_t *)vp;
+	unsigned short v;
+	int c, i, j;
+	TRY_GET_HEADER_DATA;
+
+	memset(sei, 0, sizeof(*sei));
+
+	sei->film_grain_characteristics_cancel_flag =
+		_get_header_data(hsize, &_exception);
+	if (_exception)
+		goto CATCH_GET_HEADER_DATA;
+	if (!sei->film_grain_characteristics_cancel_flag) {
+		v = _get_header_data(hsize, &_exception);
+		if (_exception)
+			goto CATCH_GET_HEADER_DATA;
+		sei->model_id = bits(v, 2, 1);
+		sei->separate_colour_description_present_flag = bits(v, 0, 0);
+		if (sei->separate_colour_description_present_flag) {
+			v = _get_header_data(hsize, &_exception);
+			if (_exception)
+				goto CATCH_GET_HEADER_DATA;
+			sei->film_grain_bit_depth_luma_minus8   =
+				bits(v, 14, 12);
+			sei->film_grain_bit_depth_chroma_minus8 =
+				bits(v, 11, 9);
+			sei->film_grain_full_range_flag  = bits(v, 8, 8);
+			sei->film_grain_colour_primaries = bits(v, 7, 0);
+			v = _get_header_data(hsize, &_exception);
+			if (_exception)
+				goto CATCH_GET_HEADER_DATA;
+			sei->film_grain_transfer_characteristics =
+				bits(v, 15, 8);
+			sei->film_grain_matrix_coefficients = bits(v, 7, 0);
+		}
+		v = _get_header_data(hsize, &_exception);
+		if (_exception)
+			goto CATCH_GET_HEADER_DATA;
+		sei->blending_mode_id  = bits(v, 8, 7);
+		sei->log2_scale_factor = bits(v, 6, 3);
+		for (c = 0; c < 3; c++)
+			sei->comp_model_present_flag[c] = bits(v, c, c);
+
+		for (c = 0; c < 3; c++) {
+			if (sei->comp_model_present_flag[c]) {
+				v = _get_header_data(hsize, &_exception);
+				if (_exception)
+					goto CATCH_GET_HEADER_DATA;
+				sei->num_intensity_intervals_minus1[c] =
+					bits(v, 10, 3);
+				sei->num_model_values_minus1[c] =
+					bits(v, 2, 0);
+
+				if (sei->num_intensity_intervals_minus1[c] >=
+				    max_num_intensity_intervals) {
+					/* it cannot be */
+					debug0("error "
+					"num_intensity_intervals_minus1"
+					"[%d] %u >= "
+					"max_num_intensity_intervals %u",
+					c,
+					sei->num_intensity_intervals_minus1[c],
+					max_num_intensity_intervals);
+					return;
+				}
+				if (sei->num_model_values_minus1[c] >=
+				    max_num_model_values) {
+					/* it cannot be */
+					debug0("error num_model_values_minus1"
+					       "[%d] %u >= "
+					       "max_num_model_values %u",
+					       c,
+					       sei->num_model_values_minus1[c],
+					       max_num_model_values);
+					return;
+				}
+
+				for (i = 0;
+				     i <= sei->num_intensity_intervals_minus1
+					     [c]; i++) {
+					v = _get_header_data(
+						hsize, &_exception);
+					if (_exception)
+						goto CATCH_GET_HEADER_DATA;
+					sei->intensity_interval_lower_bound
+						[c][i] = bits(v, 15, 8);
+					sei->intensity_interval_upper_bound
+						[c][i] = bits(v, 7, 0);
+					for (j = 0;
+					     j <= sei->num_model_values_minus1
+						     [c]; j++) {
+						sei->comp_model_value[c][i][j] =
+							_get_header_data(
+								hsize,
+								&_exception);
+						if (_exception)
+							goto CATCH_GET_HEADER;
+					}
+				}
+			}
+		}
+		sei->film_grain_characteristics_repetition_period =
+			_get_header_data(hsize, &_exception);
+		if (_exception)
+			goto CATCH_GET_HEADER_DATA;
+	}
+
+	return;
+
+CATCH_GET_HEADER_DATA:
+CATCH_GET_HEADER:
+	debug1("get_header_data error");
+}
+
+/*
+ * SEI 20: deblocking_filter_display_preference
+ */
+
+void show_deblocking_filter_display_preference(void *vp)
+{
+	struct deblocking_filter_display_preference_t *sei =
+		(struct deblocking_filter_display_preference_t *)vp;
+
+	if (debug_level_check)
+		return;
+	debug2("SEI 20: deblocking_filter_display_preference");
+	sei_log(deblocking_display_preference_cancel_flag);
+	sei_log(display_prior_to_deblocking_preferred_flag);
+	sei_log(dec_frame_buffering_constraint_flag);
+	sei_log(deblocking_display_preference_repetition_period);
+}
+
+void read_deblocking_filter_display_preference(void *vp, int *hsize)
+{
+	struct deblocking_filter_display_preference_t *sei =
+		(struct deblocking_filter_display_preference_t *)vp;
+	unsigned short v;
+	TRY_GET_HEADER_DATA;
+
+	memset(sei, 0, sizeof(*sei));
+
+	sei->deblocking_display_preference_cancel_flag =
+		_get_header_data(hsize, &_exception);
+	if (_exception)
+		goto CATCH_GET_HEADER_DATA;
+	if (!sei->deblocking_display_preference_cancel_flag) {
+		v = _get_header_data(hsize, &_exception);
+		if (_exception)
+			goto CATCH_GET_HEADER_DATA;
+		sei->display_prior_to_deblocking_preferred_flag = bits(v, 1, 1);
+		sei->dec_frame_buffering_constraint_flag = bits(v, 0, 0);
+		sei->deblocking_display_preference_repetition_period =
+			_get_header_data(hsize, &_exception);
+		if (_exception)
+			goto CATCH_GET_HEADER_DATA;
+	}
+
+	return;
+
+CATCH_GET_HEADER_DATA:
+	debug1("get_header_data error");
+}
+
+/*
+ * SEI 21: stereo_video_info
+ */
+
+void show_stereo_video_info(void *vp)
+{
+	struct stereo_video_info_t *sei = (struct stereo_video_info_t *)vp;
+
+	if (debug_level_check)
+		return;
+	debug2("SEI 21: stereo_video_info");
+	sei_log(field_views_flag);
+	sei_log(top_field_is_left_view_flag);
+	sei_log(current_frame_is_left_view_flag);
+	sei_log(next_frame_is_second_view_flag);
+	sei_log(left_view_self_contained_flag);
+	sei_log(right_view_self_contained_flag);
+}
+
+void read_stereo_video_info(void *vp, int *hsize)
+{
+	struct stereo_video_info_t *sei = (struct stereo_video_info_t *)vp;
+	unsigned short v;
+	TRY_GET_HEADER_DATA;
+
+	memset(sei, 0, sizeof(*sei));
+
+	sei->field_views_flag = _get_header_data(hsize, &_exception);
+	if (_exception)
+		goto CATCH_GET_HEADER_DATA;
+	if (sei->field_views_flag) {
+		sei->top_field_is_left_view_flag =
+			_get_header_data(hsize, &_exception);
+		if (_exception)
+			goto CATCH_GET_HEADER_DATA;
+	} else {
+		v = _get_header_data(hsize, &_exception);
+		if (_exception)
+			goto CATCH_GET_HEADER_DATA;
+		sei->current_frame_is_left_view_flag = bits(v, 1, 1);
+		sei->next_frame_is_second_view_flag  = bits(v, 0, 0);
+	}
+	v = _get_header_data(hsize, &_exception);
+	if (_exception)
+		goto CATCH_GET_HEADER_DATA;
+	sei->left_view_self_contained_flag  = bits(v, 1, 1);
+	sei->right_view_self_contained_flag = bits(v, 0, 0);
+
+	return;
+
+CATCH_GET_HEADER_DATA:
+	debug1("get_header_data error");
+}
+
+
+/*
+ * SEI (Supplemental Enhancement Information)
+ */
+
+#define SEI_ENTRY(_name) \
+	{ # _name, offsetof(struct avc_common_info_t, _name), \
+	  read_ ## _name, show_ ## _name }
+
+struct read_sei_table_t {
+	char *name;
+	int offset;
+	void (*read_func)(void *vp, int *hsize);
+	void (*show_func)(void *vp);
+};
+
+static struct read_sei_table_t read_sei_table[] = {
+	SEI_ENTRY(buffering_period),
+	SEI_ENTRY(pic_timing),
+	SEI_ENTRY(pan_scan_rect),
+	SEI_ENTRY(filler_payload),
+	SEI_ENTRY(user_data_registered_itu_t_t35),
+	SEI_ENTRY(user_data_unregistered),
+	SEI_ENTRY(recovery_point),
+	SEI_ENTRY(dec_ref_pic_marking_repetition),
+	SEI_ENTRY(spare_pic),
+	SEI_ENTRY(scene_info),
+	SEI_ENTRY(sub_seq_info),
+	SEI_ENTRY(sub_seq_layer_characteristics),
+	SEI_ENTRY(sub_seq_characteristics),
+	SEI_ENTRY(full_frame_freeze),
+	SEI_ENTRY(full_frame_freeze), /* SEI 14: dummy */
+	SEI_ENTRY(full_frame_snapshot),
+	SEI_ENTRY(progressive_refinement_segment_start),
+	SEI_ENTRY(progressive_refinement_segment_end),
+	SEI_ENTRY(motion_constrained_slice_group_set),
+	SEI_ENTRY(film_grain_characteristics),
+	SEI_ENTRY(deblocking_filter_display_preference),
+	SEI_ENTRY(stereo_video_info),
+};
+
+static struct read_sei_table_t *get_sei_entry(int payloadtype, char **fieldp)
+{
+	struct read_sei_table_t *entry;
+
+	if (payloadtype < 0 ||
+	    payloadtype > stereo_video_info ||
+	    payloadtype == 14) {
+		return NULL;
+	}
+
+	entry = &read_sei_table[payloadtype];
+	*fieldp = (char *)avc_info->common_info + entry->offset;
+	return entry;
+}
+
+void read_sei(int payloadtype, int *hsize)
+{
+	struct read_sei_table_t *entry;
+	char *fieldp;
+
+	entry = get_sei_entry(payloadtype, &fieldp);
+	if (entry == NULL) {
+		debug1("unsupported payloadtype %d", payloadtype);
+		return;
+	}
+
+	debug2("type %d, %s, offset %d",
+			payloadtype, entry->name, entry->offset);
+	entry->read_func(fieldp, hsize);
+}
+
+void show_sei(int payloadtype)
+{
+	struct read_sei_table_t *entry;
+	char *fieldp;
+
+	entry = get_sei_entry(payloadtype, &fieldp);
+	if (entry)
+		entry->show_func(fieldp);
+}
+
+void read_status_reg(struct avc_interrupt_t *interrupt)
+{
+	struct avc_regs_t *regs = avc_info->regs;
+	unsigned short action_state;
+	unsigned short pic_type;
+	unsigned short v;
+
+	v = readw(&regs->STATreg);
+	debug2("STATreg 0x%04X", v);
+
+	/* action_state */
+	action_state = bits(v, 3, 2);
+	interrupt->status.action_state = action_state;
+	switch (action_state) {
+	case 0:
+		debug2(" action_state: standby");
+		break;
+	case 1:
+		debug2(" action_state: coding");
+		break;
+	case 2:
+		debug2(" action_state: decoding");
+		break;
+	default:
+		debug2(" action_state: reserved");
+		break;
+	}
+
+	/* pic_type */
+	pic_type = bits(v, 1, 0);
+	interrupt->status.pic_type = pic_type;
+	switch (pic_type) {
+	case 0:
+		debug2(" pic_type: I-slice");
+		break;
+	case 1:
+		debug2(" pic_type: P-slice");
+		break;
+	default:
+		debug2(" pic_type: reserved");
+		break;
+	}
+}
+
+void read_dec_parreg(struct decode_info_t *decode_info)
+{
+	struct avc_regs_t *regs = avc_info->regs;
+	unsigned short v;
+
+	decode_info->dec_width = readw(&regs->dec_PARreg1);
+	decode_info->dec_height = readw(&regs->dec_PARreg2);
+
+	v = readw(&regs->dec_PARreg4);
+	decode_info->frm_crop_flag = bits(v, 15, 15);
+	decode_info->frm_crop_rect_lft_oft = bits(v, 10, 0);
+	decode_info->frm_crop_rect_rgt_oft = readw(&regs->dec_PARreg5);
+	decode_info->frm_crop_rect_top_oft = readw(&regs->dec_PARreg6);
+	decode_info->frm_crop_rect_btm_oft = readw(&regs->dec_PARreg7);
+
+	debug2("dec_width  %u", decode_info->dec_width);
+	debug2("dec_height %u", decode_info->dec_height);
+	debug2("frm_crop_flag  %u", decode_info->frm_crop_flag);
+	debug2("frm_crop_lft_oft,rgt,top,btm %u, %u, %u, %u",
+	       decode_info->frm_crop_rect_lft_oft,
+	       decode_info->frm_crop_rect_rgt_oft,
+	       decode_info->frm_crop_rect_top_oft,
+	       decode_info->frm_crop_rect_btm_oft
+	       );
+}
+
+void set_sei_decode_flags(void)
+{
+	struct avc_regs_t *regs = avc_info->regs;
+	struct sei_decode_flags_t *sei_decode_flags =
+		&avc_info->common_info->sei_decode_flags;
+	unsigned short v = 0;
+
+#if 0
+	struct vui_parameters_t *vui;
+
+	vui = &avc_info->last_sps.vui_parameters;
+
+	if (vui->nal_hrd_parameters_present_flag == 0 &&
+	    sei_decode_flags->NalHrdBpPresentFlag) {
+		v = wbits(1, 3, 3);
+	}
+
+	if (vui->vcl_hrd_parameters_present_flag == 0 &&
+	    sei_decode_flags->VclHrdBpPresentFlag) {
+		v |= wbits(1, 2, 2);
+	}
+
+	if (vui->nal_hrd_parameters_present_flag == 0 &&
+	    sei_decode_flags->CpbDpbDelaysPresentFlag) {
+		v |= wbits(1, 1, 1);
+	}
+#endif
+
+	v  = wbits(sei_decode_flags->NalHrdBpPresentFlag, 3, 3);
+	v |= wbits(sei_decode_flags->VclHrdBpPresentFlag, 2, 2);
+	v |= wbits(sei_decode_flags->CpbDpbDelaysPresentFlag, 1, 1);
+	avc_writew(v, &regs->head_PRreg18);
+}
+
+void decode_header(struct avc_interrupt_t *interrupt)
+{
+	struct avc_regs_t *regs = avc_info->regs;
+	unsigned short header_end_flag;
+	int hsize;
+
+	header_end_flag = readw(&regs->head_PRreg12);
+	interrupt->decode_header.l |= header_end_flag;
+	debug2("header_end_flag 0x%04X", header_end_flag);
+
+	hsize = get_header_size();
+	debug2("header_size %d", hsize);
+
+	if (header_end_flag & (1 << 8)) { /* SPS */
+		struct seq_parameter_set_rbsp_t *sps =
+			&avc_info->common_info->seq_parameter_set_rbsp;
+		debug2("SPS (Sequence Parameter Set)");
+		read_sps(sps, &hsize);
+		show_sps(sps);
+		avc_info->last_sps = *sps;
+		read_dec_parreg(&avc_info->common_info->decode_info);
+	}
+
+	if (header_end_flag & (1 << 7)) { /* PPS */
+		struct pic_parameter_set_rbsp_t *pps =
+			&avc_info->common_info->pic_parameter_set_rbsp;
+		debug2("PPS (Picture Parameter Set)");
+		read_pps(pps, &hsize);
+		show_pps(pps);
+		avc_info->last_pps = *pps;
+	}
+
+	if (header_end_flag & (1 << 6)) { /* SEI */
+		unsigned short payload_type = readw(&regs->head_PRreg16);
+		debug2("SEI (Supplemental Enhancement Information)");
+		read_sei(payload_type, &hsize);
+		show_sei(payload_type);
+		interrupt->payload_type = payload_type;
+	}
+
+	if (header_end_flag & (1 << 5)) { /* AUD */
+		struct aud_parameters_t *aud =
+			&avc_info->common_info->aud_parameters;
+		debug2("AUD (Access Unit Delimiter)");
+		aud->primary_pic_type = readw(&regs->head_PRreg29) & 0x7;
+		show_aud(aud);
+	}
+
+	if (header_end_flag & (1 << 4)) { /* EOSEQ */
+		debug2("End of sequence (EOSEQ)");
+	}
+
+	if (header_end_flag & (1 << 3)) { /* SH */
+		struct slice_header_t *sh =
+			&avc_info->common_info->slice_header;
+		debug2("SH (Slice Header)");
+		read_sh(sh, &hsize);
+		show_sh(sh);
+	}
+
+	if (header_end_flag & (1 << 2)) { /* EOS */
+		debug2("End of stream (EOS)");
+	}
+
+	if (header_end_flag & (1 << 1)) { /* FD */
+		debug2("Filler data (FD)");
+	}
+
+	if (hsize > 0)
+		debug2("header_size %d remains !!", hsize);
+}
+
+void decode_error(struct avc_interrupt_t *interrupt)
+{
+	struct avc_regs_t *regs = avc_info->regs;
+	unsigned short reg;
+
+	debug2("!!");
+
+	/* NAL error */
+	reg = readw(&regs->head_PRreg1);
+	interrupt->decode_error.err_nal.l |= reg;
+	if (reg) {
+		debug2("NAL error: head_PRreg1 0x%04X", reg);
+		if (reg & (1 << 3))
+			debug2(" err_nal_end");
+		if (reg & (1 << 2))
+			debug2(" err_forbidden_zero_bit");
+		if (reg & (1 << 1))
+			debug2(" err_ref_idc");
+		if (reg & (1 << 0))
+			debug2(" err_nal_unit_type");
+	}
+
+	/* SPS error */
+	reg = readw(&regs->head_PRreg2);
+	interrupt->decode_error.err_sps.l = reg;
+	if (reg) {
+		debug2("SPS error: head_PRreg2 0x%04X", reg);
+		if (reg & (1 << 13))
+			debug2(" HRD error");
+		if (reg & (1 << 12))
+			debug2(" VUI error");
+		if (reg & (1 << 11))
+			debug2(" SPS other error");
+		if (reg & (1 << 10))
+			debug2(" err_direct_8x8_inference_flag");
+		if (reg & (1 << 9))
+			debug2(" err_mb_adaptive_frame_field_flag");
+		if (reg & (1 << 8))
+			debug2(" err_profile");
+		if (reg & (1 << 7))
+			debug2(" err_level_idc");
+		if (reg & (1 << 6))
+			debug2(" err_seq_parameter_set_id");
+		if (reg & (1 << 5))
+			debug2(" err_log2_max_frame_num_minus4");
+		if (reg & (1 << 4))
+			debug2(" err_pic_order_cnt_type");
+		if (reg & (1 << 3))
+			debug2(" err_log2_max_pic_order_cnt_lsb_minus4");
+		if (reg & (1 << 2))
+			debug2(" err_num_ref_frames");
+		if (reg & (1 << 1))
+			debug2(" err_pic_width_in_mbs_minus1");
+		if (reg & (1 << 0))
+			debug2(" err_pic_height_in_map_units_minus1");
+	}
+
+	/* PPS error */
+	reg = readw(&regs->head_PRreg3);
+	interrupt->decode_error.err_pps.l = reg;
+	if (reg) {
+		debug2("PPS error: head_PRreg3 0x%04X", reg);
+		if (reg & (1 << 9))
+			debug2(" err_pps_pps_id");
+		if (reg & (1 << 8))
+			debug2(" err_pps_sps_id");
+		if (reg & (1 << 7))
+			debug2(" err_pps_entropy_flag");
+		if (reg & (1 << 6))
+			debug2(" err_pps_num_slice");
+		if (reg & (1 << 5))
+			debug2(" err_pps_num_ref_idx");
+		if (reg & (1 << 4))
+			debug2(" err_pps_weighted_flag");
+		if (reg & (1 << 3))
+			debug2(" err_pps_weighted_idc");
+		if (reg & (1 << 2))
+			debug2(" err_pps_pic_init_q");
+		if (reg & (1 << 1))
+			debug2(" err_pps_cqp_idx_ofs");
+		if (reg & (1 << 0))
+			debug2(" err_pps_redundant_flag");
+	}
+
+	/* SH error */
+	reg = readw(&regs->head_PRreg4);
+	interrupt->decode_error.err_sh.l = reg;
+	if (reg) {
+		debug2("SH error: head_PRreg4 0x%04X", reg);
+		if (reg & (1 << 9))
+			debug2(" err_sh_end");
+		if (reg & (1 << 8))
+			debug2(" err_sh_slice_type");
+		if (reg & (1 << 7))
+			debug2(" err_sh_pps_id");
+		if (reg & (1 << 6))
+			debug2(" err_sh_idr_pic_id");
+		if (reg & (1 << 5))
+			debug2(" err_sh_num_ref_idx_l0");
+		if (reg & (1 << 4))
+			debug2(" err_sh_dis_dbf_idc");
+		if (reg & (1 << 3))
+			debug2(" err_sh_slc_a_c0_ofs");
+		if (reg & (1 << 2))
+			debug2(" err_sh_slc_beta_ofs");
+		if (reg & (1 << 1))
+			debug2(" err_sh_ropn_idc");
+		if (reg & (1 << 0))
+			debug2(" err_sh_mmco");
+	}
+
+	/* SD error */
+	reg = readw(&regs->head_PRreg5);
+	interrupt->decode_error.err_sd.l = reg;
+	if (reg) {
+		debug2("SD error: head_PRreg5 0x%04X", reg);
+		if (reg & (1 << 11))
+			debug2(" err_1st_mb_in_slice");
+		if (reg & (1 << 10))
+			debug2(" err_sd_end");
+		if (reg & (1 << 9))
+			debug2(" err_sd_mb_type");
+		if (reg & (1 << 8))
+			debug2(" err_sd_cbp");
+		if (reg & (1 << 7))
+			debug2(" err_sd_mbp_ref_idx");
+		if (reg & (1 << 6))
+			debug2(" err_sd_mbp_icpm");
+		if (reg & (1 << 5))
+			debug2(" err_sd_smb_ref_idx");
+		if (reg & (1 << 4))
+			debug2(" err_zsl_lt_run");
+		if (reg & (1 << 3))
+			debug2(" err_cv_coeft");
+		if (reg & (1 << 2))
+			debug2(" err_cv_lv_prefix");
+		if (reg & (1 << 1))
+			debug2(" err_cv_tzeros");
+		if (reg & (1 << 0))
+			debug2(" err_cv_run_before");
+	}
+
+	/* macro block number */
+	reg = readw(&regs->head_PRreg6);
+	interrupt->decode_error.macro_block_number = reg;
+	debug2("macro block number: head_PRreg6 0x%04X", reg);
+}
+
+/* set_mem_plane */
+
+void set_mem_plane(struct avc_user_set_parameter_t *usp)
+{
+	struct avc_regs_t *regs = avc_info->regs;
+	unsigned short max_work_num;
+
+	max_work_num = readw(&regs->head_PRreg19);
+	avc_writew((max_work_num & MAX_WORK_NUM_BIT)
+		   | ((usp->set_mem_num_wr << 8) & MEM_NUM_WR_BIT),
+		   &regs->head_PRreg19);
+
+	avc_writew((usp->mem_num_ref_idx.set_ref_idx0 << 8)
+		   | (usp->mem_num_ref_idx.set_ref_idx1),
+		   &regs->head_PRreg20);
+
+	avc_writew((usp->mem_num_ref_idx.set_ref_idx2 << 8)
+		   | (usp->mem_num_ref_idx.set_ref_idx3),
+		   &regs->head_PRreg21);
+
+	avc_writew((usp->mem_num_ref_idx.set_ref_idx4 << 8)
+		   | (usp->mem_num_ref_idx.set_ref_idx5),
+		   &regs->head_PRreg22);
+
+	avc_writew((usp->mem_num_ref_idx.set_ref_idx6 << 8)
+		   | (usp->mem_num_ref_idx.set_ref_idx7),
+		   &regs->head_PRreg23);
+
+	avc_writew((usp->mem_num_ref_idx.set_ref_idx8 << 8)
+		   | (usp->mem_num_ref_idx.set_ref_idx9),
+		   &regs->head_PRreg24);
+
+	avc_writew((usp->mem_num_ref_idx.set_ref_idx10 << 8)
+		   | (usp->mem_num_ref_idx.set_ref_idx11),
+		   &regs->head_PRreg25);
+
+	avc_writew((usp->mem_num_ref_idx.set_ref_idx12 << 8)
+		   | (usp->mem_num_ref_idx.set_ref_idx13),
+		   &regs->head_PRreg26);
+
+	avc_writew((usp->mem_num_ref_idx.set_ref_idx14 << 8)
+		   | (usp->mem_num_ref_idx.set_ref_idx15),
+		   &regs->head_PRreg27);
+}
+
+/* command and interruption -------------------------------------------------*/
+
+/*!
+ * Set HW-IP work address
+ * @param[in] *wa struct avc_work_address_t
+ * @return void
+ */
+void set_work_address(struct avc_work_address_t *wa)
+{
+	struct avc_regs_t *regs = avc_info->regs;
+
+	avc_writel(wa->work_yuv01, &regs->bar1);
+	avc_writel(wa->work_yuv02, &regs->bar2);
+	avc_writel(wa->work_yuv03, &regs->bar3);
+	avc_writel(wa->work_yuv04, &regs->bar4);
+	avc_writel(wa->work_yuv05, &regs->bar5);
+	avc_writel(wa->work_yuv06, &regs->bar6);
+	avc_writel(wa->work_yuv07, &regs->bar7);
+	avc_writel(wa->work_yuv08, &regs->bar8);
+	avc_writel(wa->work_yuv09, &regs->bar9);
+	avc_writel(wa->work_yuv10, &regs->bar10);
+	avc_writel(wa->work_yuv11, &regs->bar11);
+	avc_writel(wa->work_yuv12, &regs->bar12);
+	avc_writel(wa->work_yuv13, &regs->bar13);
+	avc_writel(wa->work_yuv14, &regs->bar14);
+	avc_writel(wa->work_yuv15, &regs->bar15);
+	avc_writel(wa->work_yuv16, &regs->bar16);
+	avc_writel(wa->work_yuv17, &regs->bar17);
+	avc_writel(wa->work_yuv18, &regs->bar18);
+	avc_writew(wa->max_work_num, &regs->head_PRreg19);
+}
+
+/*!
+ * Set stream address
+ * @param[in] *ba struct avc_buffer_address_t
+ * @return void
+ */
+void set_stream_address(struct avc_buffer_address_t *ba)
+{
+	struct avc_regs_t *regs = avc_info->regs;
+	unsigned short sel;
+
+	/* set stream0 to BAR19 */
+	avc_writel(ba->stream0_base, &regs->bar19);
+	avc_writel(ba->stream0_size, &regs->buf_size_reg19);
+
+	/* set stream1 to BAR20 */
+	avc_writel(ba->stream1_base, &regs->bar20);
+	avc_writel(ba->stream1_size, &regs->buf_size_reg20);
+
+	/* stream bar19/bar20 */
+	sel = (ba->stream_select) ? 1 : 0;
+	avc_writel((0x2 | sel), &regs->stream_buf_sel);
+}
+
+/*!
+ * Set raster address
+ * @param[in] *ba struct avc_buffer_address_t
+ * @return void
+ */
+void set_raster_address(struct avc_buffer_address_t *ba)
+{
+	struct avc_regs_t *regs = avc_info->regs;
+
+	/* set raster0 to raster YUV #21 */
+	avc_writel(ba->raster0_Y, &regs->bar21y);
+	avc_writel(ba->raster0_U, &regs->bar21u);
+	avc_writel(ba->raster0_V, &regs->bar21v);
+
+	/* set raster1 to raster YUV #22 */
+	avc_writel(ba->raster1_Y, &regs->bar22y);
+	avc_writel(ba->raster1_U, &regs->bar22u);
+	avc_writel(ba->raster1_V, &regs->bar22v);
+
+	/* raster_work bar21/bar22 */
+	avc_writel((ba->raster_select) ? 1 : 0, &regs->raster1);
+}
+
+/*!
+ * Set interruption registers
+ * @return void
+ */
+void set_interruption(struct avc_user_set_parameter_t *usp)
+{
+	struct avc_regs_t *regs = avc_info->regs;
+	unsigned short v;
+
+	/* clear */
+	v = readw(&regs->head_PRreg1); /* err_nal */
+	v = readw(&regs->head_PRreg2); /* err_sps */
+	v = readw(&regs->head_PRreg3); /* err_pps */
+	v = readw(&regs->head_PRreg4); /* err_sh */
+	v = readw(&regs->head_PRreg5); /* err_sd */
+	v = readw(&regs->head_PRreg12); /* header_end */
+
+	/* enable int */
+	avc_writew(usp->set_int_en, &regs->INT3reg);
+
+	/* header_end_en all */
+	avc_writew(usp->set_header_end_en, &regs->head_PRreg13);
+
+	/* header error enable all */
+	avc_writew(usp->set_err_nal_en, &regs->head_PRreg7); /* err_nal */
+	avc_writew(usp->set_err_sps_en, &regs->head_PRreg8); /* err_sps */
+	avc_writew(usp->set_err_pps_en, &regs->head_PRreg9); /* err_pps */
+	avc_writew(usp->set_err_sh_en, &regs->head_PRreg10); /* err_sh */
+	avc_writew(usp->set_err_sd_en, &regs->head_PRreg11); /* err_sd */
+
+	/* int_buf_clr */
+	avc_writel(1, &regs->BINT5);
+
+	/* int_buf_en : stream buffer full */
+	avc_writel(1, &regs->BINT3);
+}
+
+/*!
+ * Reset HW-IP
+ * @return void
+ */
+void avc_hw_reset(void)
+{
+	struct avc_regs_t *regs = avc_info->regs;
+	unsigned short command = (1 << 11); /* software_reset */
+	avc_writew(command, &regs->CMDreg);
+	udelay(10); /* >100cycle=1.2us */
+}
+
+/*!
+ * Set command
+ * @param[in] command
+ * @return void
+ */
+void avc_hw_command(unsigned short command)
+{
+	struct avc_regs_t *regs = avc_info->regs;
+
+	outer_flush_all();
+
+	avc_writew(command, &regs->CMDreg);
+}
+
+static int reverse_stream(void *virt, unsigned int length);
+
+/*!
+ * Stream change command
+ * @return void
+ */
+void stream_change(void)
+{
+	struct avc_buffer_address_t *ba =
+		&avc_info->common_info->avc_buffer_address;
+	debug1("");
+
+/*    set_stream_address(ba); */
+
+	if (avc_info->state == state_decoding ||
+	    avc_info->state == state_decode_suspended) {
+		reverse_stream(avc_info->streambuf_virt,
+				avc_info->streambuf_size);
+	}
+
+	set_stream_address(ba);
+}
+
+static unsigned int byte_order(unsigned int x)
+{
+	unsigned int y =
+		((x & 0x000000FF) << 24) |
+		((x & 0x0000FF00) <<  8) |
+		((x & 0x00FF0000) >>  8) |
+		((x & 0xFF000000) >> 24);
+	return y;
+}
+
+int reverse_stream(void *virt, unsigned int length)
+{
+	unsigned int *va = (unsigned int *)virt;
+	int i;
+
+	if (avc_info->common_info->avc_buffer_address.change_endian == 0)
+		return 0;
+	if (length == 0)
+		return 0;
+#if 0
+	va = (unsigned int *)ioremap((unsigned long)pa, length);
+	if (va == NULL) {
+		debug0("ioremap failed !! pa 0x%08X, length %d", pa, length);
+		return -1;
+	}
+#endif
+	length /= sizeof(int);
+	for (i = 0; i < length; i++) {
+		unsigned int *p = (unsigned int *)(va + i);
+		unsigned int v = byte_order(*p);
+		*p = v;
+	}
+#if 0
+	iounmap(va);
+#endif
+	return 0;
+}
+
+/*!
+ * Decode start command
+ * @param[in] last_frame last frame or not
+ * @return void
+ */
+void decode_start(int last_frame)
+{
+	struct avc_regs_t *regs = avc_info->regs;
+	struct avc_work_address_t *wa =
+		&avc_info->common_info->avc_work_address;
+	struct avc_buffer_address_t *ba =
+		&avc_info->common_info->avc_buffer_address;
+	unsigned short command;
+	struct avc_user_set_parameter_t *usp =
+		&avc_info->common_info->avc_user_set_parameter;
+
+	debug1("");
+
+	avc_hw_reset();
+
+	set_interruption(usp);
+	set_work_address(wa);
+	set_raster_address(ba);
+	reverse_stream(avc_info->streambuf_virt, avc_info->streambuf_size);
+	set_stream_address(ba);
+
+	/* ref_hw_ctrl, dec_error_conceal */
+	avc_writew((usp->set_ref_hw_ctrl << 2) |
+		   (usp->set_dec_error_conceal << 0),
+		   &regs->dec_PARreg3);
+
+	/* mem num */
+	set_mem_plane(usp);
+
+	/* flags for SEI */
+	set_sei_decode_flags();
+
+	/* sei_raw_output : SEI payload type 0-21 */
+	avc_writew((usp->set_sei_raw_output & 0xFFFF),
+		   &regs->head_PRreg31);
+	avc_writew((usp->set_sei_raw_output >> 16) & 0x003F,
+		   &regs->head_PRreg32);
+
+	/* set planar sel */
+	avc_writel(usp->set_planar_sel, &regs->raster2);
+
+	/* set bytelane*/
+	avc_writel(usp->set_bytelane, &regs->raster3);
+
+	/* command */
+	command = (1 << 14); /* sys_dec_start */
+	if (last_frame)
+		command |= (1 << 12);   /* sys_dec_stop */
+	avc_hw_command(command);
+}
+
+/*!
+ * Decode reactivate command
+ * @param[in] last_frame last frame or not
+ * @return void
+ */
+void decode_reactivate(int last_frame)
+{
+	unsigned short command;
+	struct avc_user_set_parameter_t *usp =
+		&avc_info->common_info->avc_user_set_parameter;
+	debug1("");
+
+	set_raster_address(&avc_info->common_info->avc_buffer_address);
+	set_sei_decode_flags();
+
+	set_mem_plane(usp);
+
+	command = (1 << 8); /* dec_reactivate */
+	if (last_frame)
+		command |= (1 << 12);   /* sys_dec_stop */
+	avc_hw_command(command);
+}
+
+#define ENCPARAM_ENTRY(_name, _min, _max, _def)	\
+	{# _name, offsetof(struct encode_info_t, _name), _min, _max, _def}
+
+struct encode_params_t {
+	const char *name;
+	int offset;
+	unsigned short min;
+	unsigned short max;
+	unsigned short def;
+};
+
+static struct encode_params_t encode_params[] = {
+	ENCPARAM_ENTRY(enc_width, 80, 720, 720),
+	ENCPARAM_ENTRY(enc_height, 80, 576, 480),
+	ENCPARAM_ENTRY(enc_rc_rate, 16, 8000, 2000),
+	ENCPARAM_ENTRY(enc_rc_frame_rate, 1, 62, 30),
+	ENCPARAM_ENTRY(enc_ifrm_rate, 1, 1023, 15),
+	ENCPARAM_ENTRY(sps_rate, 0, 1023, 0),
+	ENCPARAM_ENTRY(pps_rate, 0, 1023, 0),
+	ENCPARAM_ENTRY(enc_max_rate, 0, 12000, 3000),
+};
+
+/*!
+ * Check encode parameters
+ * @param[in] *encode_info struct encode_info_t
+ * @retval  0 OK
+ * @retval -1 NG
+ */
+int encode_info_check(struct encode_info_t *encode_info)
+{
+	struct encode_params_t *param;
+	int i;
+
+	for (i = 0, param = encode_params;
+	     i < sizeof(encode_params) / sizeof(struct encode_params_t);
+	     i++, param++) {
+		char *fieldp = (char *)encode_info + param->offset;
+		unsigned short value = *(unsigned short *)fieldp;
+		debug2("%d, name %s, offset %d, min %u, max %u, value %u",
+		       i, param->name, param->offset, param->min, param->max,
+		       value);
+
+		if (value < param->min || value > param->max) {
+			debug1("error %s %u", param->name, value);
+			return -1;
+		}
+	}
+
+	return 0;
+}
+
+#define write_uint_ereg(_v, _r1, _r2) \
+	do { \
+		avc_writew(_v     & 0xFFFF, &regs->enc_PARreg ## _r1); \
+		avc_writew((_v >> 16) & 0xFFFF, &regs->enc_PARreg ## _r2); \
+	} while (0)
+
+/*!
+ * Set encode parameters
+ * @param[in] *ei struct encode_info_t
+ * @return void
+ */
+static void set_encode_param(struct encode_info_t *ei)
+{
+	struct avc_regs_t *regs = avc_info->regs;
+	unsigned short v;
+
+	v  = wbits(ei->enc_cvbr, 14, 14);
+	v |= wbits(ei->enc_width, 10, 0);
+	avc_writew(v, &regs->enc_PARreg1);
+	avc_writew(ei->enc_height, &regs->enc_PARreg2);
+	avc_writew(ei->enc_rc_rate, &regs->enc_PARreg3);
+	v  = wbits(ei->enc_rc_frame_rate, 15, 10);
+	v |= wbits(ei->enc_ifrm_rate, 9, 0);
+	avc_writew(v, &regs->enc_PARreg4);
+	avc_writew(ei->sps_rate, &regs->enc_PARreg5);
+	avc_writew(ei->pps_rate, &regs->enc_PARreg6);
+
+	if (ei->frm_crop_flag) {
+		v  = wbits(1, 15, 15);
+		v |= wbits(ei->frm_crop_rect_lft_oft, 9, 0);
+		avc_writew(v, &regs->enc_PARreg7);
+		avc_writew(ei->frm_crop_rect_rgt_oft, &regs->enc_PARreg8);
+		avc_writew(ei->frm_crop_rect_top_oft, &regs->enc_PARreg9);
+		avc_writew(ei->frm_crop_rect_btm_oft, &regs->enc_PARreg10);
+	} else {
+		avc_writew(0, &regs->enc_PARreg7);
+	}
+
+	v  = wbits(ei->const_intra_pred_flg, 15, 15);
+	v |= wbits(ei->chroma_qp_idx_oft, 4, 0);
+	avc_writew(v, &regs->enc_PARreg11);
+
+	v  = wbits(ei->dis_deblk_filter_idc_i, 9, 8);
+	v |= wbits(ei->slice_alpha_oft_div2_i, 7, 4);
+	v |= wbits(ei->slice_beta_oft_div2_i, 3, 0);
+	avc_writew(v, &regs->enc_PARreg12);
+
+	v  = wbits(ei->dis_deblk_filter_idc_p, 9, 8);
+	v |= wbits(ei->slice_alpha_oft_div2_p, 7, 4);
+	v |= wbits(ei->slice_beta_oft_div2_p, 3, 0);
+	avc_writew(v, &regs->enc_PARreg13);
+
+	v = ei->enc_cpb_size;
+	if ((v == 0) || (v > 511))
+		v = 0x70; /* Set default value */
+	avc_writew(v, &regs->enc_PARreg14);
+
+	/* enc_max_rate: enc_rc_rate * 1.5 recommended [16..12000] */
+	v = ei->enc_max_rate;
+	if (v == 0)
+		v = ei->enc_rc_rate * 3 / 2;
+	else if (v < ei->enc_rc_rate)
+		v = ei->enc_rc_rate;
+	avc_writew(v, &regs->enc_PARreg15);
+
+	/* enc_PARreg16: Maximum QP */
+	v = ei->enc_image_value;
+	if ((v < 1) || (v > 0x33))
+		v = 0x33; /* Set default value (MaxQP = 51) */
+	avc_writew(v, &regs->enc_PARreg16);
+
+	avc_writew(ei->enc_skip_off, &regs->enc_PARreg17);
+
+	avc_writew(ei->level_idc, &regs->enc_PARreg19);
+
+	/* enc_PARreg22: Initial QP */
+	v = ei->enc_initial_image_value;
+	if ((v < 0x10) || (v > 0x30))
+		v = 0x19; /* Set default value (InitQP = 25) */
+	avc_writew(v, &regs->enc_PARreg22);
+
+	/* enc_PARreg23: Decrement Q for IDR */
+	v = ei->enc_islice_image_mode;
+	if (v > 0x08)
+		v = 0x08; /* Set default value (DecQ = 8) */
+	avc_writew(v, &regs->enc_PARreg23);
+
+	/*
+	   enc_RCreg54 (2E0h: test register): Minimum QP
+	   [15:12] reserved
+	   [11: 6] Minimum QP for I-pic (default:1)
+	   [ 5: 0] Minimum QP for P-pic (default:1)
+	 */
+	{
+		unsigned long enc_RCreg54_addr;
+		unsigned short max_qp;
+		unsigned short min_qp_i;
+		unsigned short min_qp_p;
+
+		/* enc_RCreg54 offset addr = 0x02E0 */
+		enc_RCreg54_addr = (unsigned long)regs + 0x02E0;
+
+		max_qp = readw(&regs->enc_PARreg16);
+
+		min_qp_i = ei->enc_min_qp_i;
+		if ((min_qp_i < 1) || (min_qp_i > max_qp))
+			min_qp_i = 1;
+
+		min_qp_p = ei->enc_min_qp_p;
+		if ((min_qp_p < 1) || (min_qp_p > max_qp))
+			min_qp_p = 1;
+
+		v = (min_qp_i << 6) | min_qp_p;
+		avc_writew(v, enc_RCreg54_addr);
+	}
+
+	if (ei->enc_still_image_value == AVC_ENCPARAM_STILL_IMAGE_MODE_FINE) {
+		avc_writew(AVC_ENCPARAM_STILL_IMAGE_MODE_FINE,
+				&regs->enc_PARreg25);
+		avc_writew(0x07d0, &regs->enc_PARreg26);
+	} else if (ei->enc_still_image_value ==
+		   AVC_ENCPARAM_STILL_IMAGE_MODE_FINEST)   {
+		avc_writew(AVC_ENCPARAM_STILL_IMAGE_MODE_FINEST,
+				&regs->enc_PARreg25);
+		avc_writew(0x07d0, &regs->enc_PARreg26);
+	} else{
+		avc_writew(0x0000, &regs->enc_PARreg25);
+		avc_writew(0x0000, &regs->enc_PARreg26);
+	}
+
+	if (ei->enc_flat_image_value == AVC_ENCPARAM_FLAT_IMAGE_MODE_FINE)
+		avc_writew(AVC_ENCPARAM_FLAT_IMAGE_MODE_FINE,
+				&regs->enc_PARreg27);
+	else if (ei->enc_flat_image_value ==
+		 AVC_ENCPARAM_FLAT_IMAGE_MODE_FINEST)
+		avc_writew(AVC_ENCPARAM_FLAT_IMAGE_MODE_FINEST,
+				&regs->enc_PARreg27);
+	else
+		avc_writew(AVC_ENCPARAM_FLAT_IMAGE_MODE_NORMAL,
+				&regs->enc_PARreg27);
+
+	/* slice_mb_num */
+	v = ei->slice_mb_num;
+	if (v > 0) {
+		unsigned short max_v;
+
+		/* Saturate slice_mb_num to max MB num */
+		max_v = ei->enc_width * ei->enc_height / 256;
+		if (v > max_v)
+			v = max_v;
+
+		/* Enable multi slice */
+		v |= (1 << 15);
+	}
+	avc_writew(v, &regs->enc_PARreg28);
+
+	avc_writew(ei->idr_in, &regs->enc_PARreg31);
+
+	avc_writew(ei->skip_in, &regs->enc_PARreg32);
+
+	if (ei->enc_vui_present_flag) {
+		struct vui_parameters_t *vui =
+		&avc_info->common_info->seq_parameter_set_rbsp.vui_parameters;
+		struct hrd_parameters_t *nal_hrd = &vui->nal_hrd_parameters;
+		struct hrd_parameters_t *vcl_hrd = &vui->vcl_hrd_parameters;
+
+		/* VUI 33-46 */
+		avc_writew(1, &regs->enc_PARreg33); /* enc_vui_present_flag */
+		v  = wbits(vui->aspect_ratio_info_present_flag, 8, 8);
+		v |= wbits(vui->aspect_ratio_idc, 7, 0);
+		avc_writew(v, &regs->enc_PARreg34);
+		avc_writew(vui->sar_width,  &regs->enc_PARreg35);
+		avc_writew(vui->sar_height, &regs->enc_PARreg36);
+		v  = wbits(vui->overscan_info_present_flag, 15, 15);
+		v |= wbits(vui->overscan_appropriate_flag, 14, 14);
+		v |= wbits(vui->video_signal_type_present_flag, 13, 13);
+		v |= wbits(vui->video_format, 12, 10);
+		v |= wbits(vui->video_full_range_flag, 9, 9);
+		v |= wbits(vui->colour_description_present_flag, 8, 8);
+		v |= wbits(vui->colour_primaries, 7, 0);
+		avc_writew(v, &regs->enc_PARreg37);
+		v  = wbits(vui->transfer_characteristics, 15, 8);
+		v |= wbits(vui->matrix_coefficients, 7, 0);
+		avc_writew(v, &regs->enc_PARreg38);
+		v  = wbits(vui->chroma_loc_info_present_flag, 8, 8);
+		v |= wbits(vui->chroma_sample_loc_type_top_field, 7, 5);
+		v |= wbits(vui->chroma_sample_loc_type_bottom_field, 4, 2);
+		v |= wbits(vui->timing_info_present_flag, 1, 1);
+		v |= wbits(vui->fixed_frame_rate_flag, 0, 0);
+		avc_writew(v, &regs->enc_PARreg39);
+		write_uint_ereg(vui->num_units_in_tick, 40, 41);
+		write_uint_ereg(vui->time_scale, 42, 43);
+		v  = wbits(vui->nal_hrd_parameters_present_flag, 15, 15);
+		v |= wbits(vui->vcl_hrd_parameters_present_flag, 14, 14);
+		v |= wbits(vui->low_delay_hrd_flag, 13, 13);
+		v |= wbits(vui->pic_struct_present_flag, 12, 12);
+		v |= wbits(vui->bitstream_restriction_flag, 11, 11);
+		v |= wbits(vui->motion_vectors_over_pic_boundaries_flag,
+				10, 10);
+		v |= wbits(vui->max_bytes_per_pic_denom, 9, 5);
+		v |= wbits(vui->max_bits_per_mb_denom, 4, 0);
+		avc_writew(v, &regs->enc_PARreg44);
+		v  = wbits(vui->log2_max_mv_length_horizontal, 14, 10);
+		v |= wbits(vui->log2_max_mv_length_vertical, 9, 5);
+		v |= wbits(vui->num_reorder_frames, 4, 0);
+		avc_writew(v, &regs->enc_PARreg45);
+		v  = wbits(vui->max_dec_frame_buffering, 4, 0);
+		avc_writew(v, &regs->enc_PARreg46);
+
+		/* HRD(NAL) 47-51 */
+		v  = wbits(nal_hrd->cbr_flag[0], 13, 13);
+		v |= wbits(nal_hrd->cpb_cnt_minus1 & 0x1, 12, 8); /* 00-01h */
+		v |= wbits(nal_hrd->bit_rate_scale, 7, 4);
+		v |= wbits(nal_hrd->cpb_size_scale, 3, 0);
+		avc_writew(v, &regs->enc_PARreg47);
+		write_uint_ereg(nal_hrd->bit_rate_value_minus1[0], 48, 49);
+		write_uint_ereg(nal_hrd->cpb_size_value_minus1[0], 50, 51);
+
+		/* HRD(VCL) 52-56 */
+		v  = wbits(vcl_hrd->cbr_flag[0], 13, 13);
+		v |= wbits(vcl_hrd->cpb_cnt_minus1 & 0x1, 12, 8); /* 00-01h */
+		v |= wbits(vcl_hrd->bit_rate_scale, 7, 4);
+		v |= wbits(vcl_hrd->cpb_size_scale, 3, 0);
+		avc_writew(v, &regs->enc_PARreg52);
+		write_uint_ereg(vcl_hrd->bit_rate_value_minus1[0], 53, 54);
+		write_uint_ereg(vcl_hrd->cpb_size_value_minus1[0], 55, 56);
+
+		/* HRD 57-58 */
+		v  = wbits(vcl_hrd->initial_cpb_removal_delay_length_minus1,
+				9, 5);
+		v |= wbits(vcl_hrd->cpb_removal_delay_length_minus1, 4, 0);
+		avc_writew(v, &regs->enc_PARreg57);
+		v  = wbits(vcl_hrd->dpb_output_delay_length_minus1, 9, 5);
+		v |= wbits(vcl_hrd->time_offset_length, 4, 0);
+		avc_writew(v, &regs->enc_PARreg58);
+	} else {
+		avc_writew(0, &regs->enc_PARreg33); /* enc_vui_present_flag */
+	}
+
+	/* SEI enable 59 */
+	v  = wbits(ei->enc_buffering_period_en, 3, 3);
+	v |= wbits(ei->enc_pic_timing_en, 2, 2);
+	v |= wbits(ei->enc_pan_scan_rect_en, 1, 1);
+	v |= wbits(ei->enc_sei_filler_en, 0, 0);
+	avc_writew(v, &regs->enc_PARreg59);
+
+	/* SEI 0: buffering_period 60-67 */
+	if (ei->enc_buffering_period_en) {
+		struct buffering_period_t *sei =
+			&avc_info->common_info->buffering_period;
+		write_uint_ereg(sei->nal_initial_cpb_removal_delay[0], 60, 61);
+		write_uint_ereg(sei->nal_initial_cpb_removal_delay_offset[0],
+				62, 63);
+		write_uint_ereg(sei->vcl_initial_cpb_removal_delay[0], 64, 65);
+		write_uint_ereg(sei->vcl_initial_cpb_removal_delay_offset[0],
+				66, 67);
+	}
+
+	/* SEI 1: pic_timing 68-77 */
+	if (ei->enc_pic_timing_en) {
+		struct pic_timing_t *sei =
+			&avc_info->common_info->pic_timing;
+		write_uint_ereg(sei->cpb_removal_delay, 68, 69);
+		write_uint_ereg(sei->dpb_output_delay, 70, 71);
+		v  = wbits(sei->pic_struct, 15, 12);
+		v |= wbits(sei->ct[0].clock_timestamp_flag, 11, 9);
+		v |= wbits(sei->ct[0].ct_type, 8, 7);
+		v |= wbits(sei->ct[0].nuit_field_based_flag, 6, 6);
+		v |= wbits(sei->ct[0].counting_type, 5, 1);
+		v |= wbits(sei->ct[0].full_timestamp_flag, 0, 0);
+		avc_writew(v, &regs->enc_PARreg72);
+		v  = wbits(sei->ct[0].discontinuity_flag, 9, 9);
+		v |= wbits(sei->ct[0].cnt_dropped_flag, 8, 8);
+		v |= wbits(sei->ct[0].n_frames, 7, 0);
+		avc_writew(v, &regs->enc_PARreg73);
+		v  = wbits(sei->ct[0].seconds_value, 11, 6);
+		v |= wbits(sei->ct[0].minutes_value, 5, 0);
+		avc_writew(v, &regs->enc_PARreg74);
+		v  = wbits(sei->ct[0].hours_value, 7, 3);
+		v |= wbits(sei->ct[0].seconds_flag, 2, 2);
+		v |= wbits(sei->ct[0].minutes_flag, 1, 1);
+		v |= wbits(sei->ct[0].hours_flag, 0, 0);
+		avc_writew(v, &regs->enc_PARreg75);
+		write_uint_ereg(sei->ct[0].time_offset, 76, 77);
+	}
+
+	/* SEI 2: pan_scan_rect 78-105 */
+	if (ei->enc_pan_scan_rect_en) {
+		struct pan_scan_rect_t *sei =
+			&avc_info->common_info->pan_scan_rect;
+		write_uint_ereg(sei->pan_scan_rect_id, 78, 79);
+		v  = wbits(sei->pan_scan_rect_cancel_flag, 2, 2);
+		v |= wbits(sei->pan_scan_cnt_minus1, 1, 0);
+		avc_writew(v, &regs->enc_PARreg80);
+		write_uint_ereg(sei->psr[0].left_offset, 81, 82);
+		write_uint_ereg(sei->psr[1].left_offset, 83, 84);
+		write_uint_ereg(sei->psr[2].left_offset, 85, 86);
+		write_uint_ereg(sei->psr[0].right_offset, 87, 88);
+		write_uint_ereg(sei->psr[1].right_offset, 89, 90);
+		write_uint_ereg(sei->psr[2].right_offset, 91, 92);
+		write_uint_ereg(sei->psr[0].top_offset, 93, 94);
+		write_uint_ereg(sei->psr[1].top_offset, 95, 96);
+		write_uint_ereg(sei->psr[2].top_offset, 97, 98);
+		write_uint_ereg(sei->psr[0].bottom_offset, 99, 100);
+		write_uint_ereg(sei->psr[1].bottom_offset, 101, 102);
+		write_uint_ereg(sei->psr[2].bottom_offset, 103, 104);
+		avc_writew(sei->pan_scan_rect_repetition_period,
+				&regs->enc_PARreg105);
+	}
+
+	/* SEI 3: filler 106-107 */
+	/* enc_sei_filler_en/enc_fil_on */
+	{
+		struct filler_payload_t *sei =
+			&avc_info->common_info->filler_payload;
+		write_uint_ereg(sei->payloadSize, 106, 107);
+	}
+
+	/* AUD,FD insertion 108 */
+	v  = wbits(ei->enc_aud_on, 1, 1);
+	v |= wbits(ei->enc_fil_on, 0, 0);
+	avc_writew(v, &regs->enc_PARreg108);
+}
+
+/*!
+ * Encode start command
+ * @param[in] last_frame last frame or not
+ * @return void
+ */
+void encode_start(int last_frame)
+{
+	struct avc_regs_t *regs = avc_info->regs;
+	struct avc_work_address_t *wa =
+		&avc_info->common_info->avc_work_address;
+	struct avc_buffer_address_t *ba =
+		&avc_info->common_info->avc_buffer_address;
+	struct encode_info_t *ei = &avc_info->common_info->encode_info;
+	unsigned short command;
+	struct avc_user_set_parameter_t *usp =
+		&avc_info->common_info->avc_user_set_parameter;
+	debug1("");
+
+	avc_hw_reset();
+
+	set_interruption(usp);
+	set_work_address(wa);
+	set_raster_address(ba);
+	set_stream_address(ba);
+	set_encode_param(ei);
+
+	/* set planar sel */
+	avc_writel(usp->set_planar_sel, &regs->raster2);
+
+	/* set bytelane*/
+	avc_writel(usp->set_bytelane, &regs->raster3);
+
+	/* command */
+	command = (1 << 15); /* sys_enc_start */
+	if (last_frame)
+		command |= (1 << 13);   /* sys_enc_end */
+	avc_hw_command(command);
+}
+
+/*!
+ * Encode reactivate command
+ * @param[in] last_frame last frame or not
+ * @return void
+ */
+void encode_reactivate(int last_frame)
+{
+	struct avc_buffer_address_t *ba =
+		&avc_info->common_info->avc_buffer_address;
+	struct encode_info_t *ei = &avc_info->common_info->encode_info;
+	unsigned short command;
+	debug1("");
+
+	set_raster_address(ba);
+	set_encode_param(ei);
+
+	/* command */
+	command = (1 << 15); /* sys_enc_start */
+	if (last_frame)
+		command |= (1 << 13);   /* sys_enc_end */
+	avc_hw_command(command);
+}
+
+static const char *avc_command_string[] = {
+	"avc_command_encode_start",
+	"avc_command_encode_reactivate",
+	"avc_command_decode_start",
+	"avc_command_decode_reactivate",
+	"avc_command_stream_change",
+	"avc_command_reset",
+};
+
+static const char *avc_state_string[] = {
+	"state_initial",
+	"state_idle",
+	"state_encoding",
+	"state_encode_suspended",
+	"state_decoding",
+	"state_decode_suspended",
+};
+
+void *avc_ioremap(unsigned long offset, size_t size)
+{
+	void *ret;
+
+	if (size == 0)
+		return NULL;
+
+	ret = ioremap(offset, size);
+	if (ret == NULL)
+		debug0("ioremap failed !! offset 0x%08X, size %d",
+				offset, size);
+
+	return ret;
+}
+
+void avc_iounmap(void *addr)
+{
+	iounmap(addr);
+}
+
+/*!
+ * User command handler
+ * @param[in] command
+ * @param[in] last_frame last frame or not
+ * @retval  0 OK
+ * @retval -1 NG
+ */
+int command_start(unsigned short command, unsigned short last_frame)
+{
+	enum avc_state_t state = avc_info->state;
+	debug2("command %u %s, last_frame %u",
+	       command, (command <= avc_command_reset) ?
+	       avc_command_string[command] : "undefined !!", last_frame);
+	debug2("state %d %s", state, (state <= avc_command_reset) ?
+	       avc_state_string[state] : "undefined !!");
+
+	/* ioremap stream buffer */
+	if (avc_info->common_info->avc_buffer_address.change_endian &&
+	    (command == avc_command_encode_start ||
+	     command == avc_command_decode_start ||
+	     command == avc_command_stream_change)
+	    ) {
+		struct avc_buffer_address_t *ba =
+			&avc_info->common_info->avc_buffer_address;
+		void *virt;
+		unsigned int phys;
+		unsigned int len;
+		if (avc_info->streambuf_virt) {
+			avc_iounmap(avc_info->streambuf_virt);
+			avc_info->streambuf_virt = NULL;
+		}
+		if (ba->stream_select == 0) {
+			phys = ba->stream0_base;
+			len  = ba->stream0_size;
+		} else {
+			phys = ba->stream1_base;
+			len  = ba->stream1_size;
+		}
+		virt = avc_ioremap((unsigned long)phys, len);
+		if (virt == NULL) {
+			debug0("avc_ioremap failed !!: phys 0x%08X, len %d",
+					phys, len);
+			return -1;
+		}
+		avc_info->streambuf_virt = virt;
+		avc_info->streambuf_size = len;
+	}
+
+	if (command == avc_command_encode_start) {
+		struct encode_info_t *ei = &avc_info->common_info->encode_info;
+		if (state != state_idle) {
+			debug1("encode_start: %u != state_idle", state);
+			return -1;
+		}
+		if (encode_info_check(ei) < 0) {
+			debug1("encode_info_check failed");
+			return -1;
+		}
+		avc_info->state = state_encoding;
+		avc_info->encbuf_order_changed = 0;
+		encode_start(last_frame);
+	} else if (command == avc_command_encode_reactivate)   {
+		struct encode_info_t *ei = &avc_info->common_info->encode_info;
+		if (state != state_encode_suspended) {
+			debug1("encode_reactivate: "
+					"%u != state_encode_suspended", state);
+			return -1;
+		}
+		if (encode_info_check(ei) < 0) {
+			debug1("encode_info_check failed");
+			return -1;
+		}
+		avc_info->state = state_encoding;
+		encode_reactivate(last_frame);
+	} else if (command == avc_command_decode_start)   {
+		if (state != state_idle) {
+			debug1("decode_start: %u != state_idle", state);
+			return -1;
+		}
+		avc_info->state = state_decoding;
+		decode_start(last_frame);
+	} else if (command == avc_command_decode_reactivate)   {
+		if (state != state_decode_suspended) {
+			debug1("decode_reactivate: "
+					"%u != state_decode_suspended", state);
+			return -1;
+		}
+		avc_info->state = state_decoding;
+		decode_reactivate(last_frame);
+	} else if (command == avc_command_stream_change)   {
+		avc_info->encbuf_order_changed = 0;
+		stream_change();
+	} else if (command == avc_command_reset)   {
+		avc_info->state = state_idle;
+		avc_hw_reset();
+		if (avc_info->streambuf_virt) {
+			avc_iounmap(avc_info->streambuf_virt);
+			avc_info->streambuf_virt = NULL;
+		}
+	} else {
+		return -1;
+	}
+
+	return 0;
+}
+
+/*!
+ * Interruption handler
+ * @param[in] factor interruption factor
+ * @param[in] int_a  int_buf_full
+ * @retval 0
+ */
+int avc_interruption_handler(unsigned int factor, unsigned int int_a)
+{
+	struct avc_regs_t *regs = avc_info->regs;
+	struct avc_buffer_address_t *ba =
+		&avc_info->common_info->avc_buffer_address;
+	struct decode_info_t *di = &avc_info->common_info->decode_info;
+	unsigned int stream_buf_adr;
+	unsigned short v;
+
+	debug2("factor 0x%04X", factor);
+	if (int_a)
+		debug2(" int_buf_full");
+	if (factor & (1 << 7))
+		debug2(" int_enc_end");
+	if (factor & (1 << 6))
+		debug2(" int_dec_end");
+	if (factor & (1 << 5))
+		debug2(" int_dec_err");
+	if (factor & (1 << 4))
+		debug2(" int_enc_pic_end");
+	if (factor & (1 << 3))
+		debug2(" int_dec_pic_end");
+	if (factor & (1 << 2))
+		debug2(" int_head_dec_end");
+	if (factor & (1 << 1))
+		debug2(" int_ref_pic_manual");
+
+	if (factor & (1 << 5)) { /* int_dec_err */
+		decode_error(&avc_info->interrupt);
+	}
+
+	if (factor & (1 << 3)) { /* int_dec_pic_end */
+		avc_info->state = state_decode_suspended;
+		read_dec_parreg(di);
+	}
+
+	if (factor & (1 << 4)) { /* int_enc_pic_end */
+		unsigned int bit_cnt;
+		avc_info->state = state_encode_suspended;
+		/* enc_bit_count */
+		bit_cnt  = readw(&regs->enc_INFOreg3) << 16;
+		bit_cnt |= readw(&regs->enc_INFOreg4);
+		ba->enc_bit_cnt = bit_cnt;
+		debug2("enc_bit_cnt 0x%X %u", bit_cnt, bit_cnt);
+	}
+
+	if (factor & (1 << 2)) { /* int_head_dec_end */
+		avc_info->state = state_decode_suspended;
+		decode_header(&avc_info->interrupt);
+	}
+
+	if (factor & (1 << 6)) { /* int_dec_end */
+		avc_info->state = state_idle;
+	}
+
+	if (factor & (1 << 7)) { /* int_enc_end */
+		avc_info->state = state_idle;
+	}
+
+	/* read action_state and pic_type */
+	read_status_reg(&avc_info->interrupt);
+
+	/* read stream_buf_adr */
+	stream_buf_adr = readl(&regs->stream_buf_adr);
+	ba->stream_buf_adr = stream_buf_adr;
+	debug2("stream_buf_adr 0x%08X %u", stream_buf_adr, stream_buf_adr);
+
+	/* read nal_unit_type */
+	v = readw(&regs->dec_PARreg8);
+	di->nal_ref_idc   = bits(v, 6, 5);
+	di->nal_unit_type = bits(v, 4, 0);
+	debug2("nal_ref_idc   %u", di->nal_ref_idc);
+	debug2("nal_unit_type %u", di->nal_unit_type);
+
+	/* change byte order in encoded stream buffer */
+	if (avc_info->state == state_encoding ||
+	    avc_info->state == state_encode_suspended ||
+	    (factor & (1 << 7))) { /* int_enc_end */
+		unsigned int base;
+		base = (ba->stream_select == 0) ?
+			ba->stream0_base : ba->stream1_base;
+		reverse_stream((char *)avc_info->streambuf_virt +
+			       avc_info->encbuf_order_changed,
+			       stream_buf_adr - avc_info->encbuf_order_changed);
+		avc_info->encbuf_order_changed = stream_buf_adr;
+	}
+
+	return 0;
+}
diff --git a/drivers/avc/avc_debug.c b/drivers/avc/avc_debug.c
new file mode 100644
index 0000000..323c256
--- /dev/null
+++ b/drivers/avc/avc_debug.c
@@ -0,0 +1,103 @@
+#include <linux/kernel.h> /* printk */
+#include <stdarg.h>
+
+/* debug functions --------------------------------------------------------- */
+
+int debug_level;
+static const char debug_prefix[] = "";
+#define debug_printf printk
+/* #define debug_printf __debug_printf */
+
+static int debug_nowstring(char *buf, int len)
+{
+#if 1
+	buf[0] = '\0';
+	return 0;
+#else
+	struct timeval now;
+	do_gettimeofday(&now);
+	return snprintf(buf, len, "%03ld.%06ld: ",
+			now.tv_sec % 1000, now.tv_usec);
+#endif
+}
+
+#if 0
+#define DEBUG_MAX_LENGTH 128
+#define DEBUG_MAX_LINE   100
+static char debug_logs[DEBUG_MAX_LINE][DEBUG_MAX_LENGTH];
+static int debug_logs_index;
+
+void debug_out(void)
+{
+	int i;
+	for (i = 0; i < debug_logs_index; i++)
+		printk(KERN_DEBUG "%s", debug_logs[i]);
+	debug_logs_index = 0;
+}
+
+void __debug_printf(const char *format, ...)
+{
+	va_list args;
+	if (debug_logs_index >= DEBUG_MAX_LINE)
+		return;
+	va_start(args, format);
+	vsnprintf(debug_logs[debug_logs_index++], DEBUG_MAX_LENGTH,
+			format, args);
+	va_end(args);
+	if (in_interrupt() == 0 && debug_logs_index > 50)
+		debug_out();
+}
+#endif
+
+void __debug_np(int level, const char *format, ...)
+{
+	char sbuf[128];
+	va_list args;
+	if (debug_level < level)
+		return;
+
+	va_start(args, format);
+	vsnprintf(sbuf, sizeof(sbuf), format, args);
+	va_end(args);
+
+	debug_printf("%s%s\n", debug_prefix, sbuf);
+}
+
+void __debug(int level, const char *function, const char *format, ...)
+{
+	char sbuf[128];
+	char times[20];
+	va_list args;
+	if (debug_level < level)
+		return;
+
+	va_start(args, format);
+	vsnprintf(sbuf, sizeof(sbuf), format, args);
+	va_end(args);
+
+	debug_nowstring(times, sizeof(times));
+	debug_printf("%s%s%-16s: %s\n", debug_prefix, times, function, sbuf);
+}
+
+void __dump(int level, const char *function, void *ptr, int len)
+{
+	unsigned char *p = (unsigned char *)ptr;
+	char sbuf[128];
+	int i;
+	if (debug_level < level)
+		return;
+
+	__debug(level, function, "length=%d", len);
+	if (len > 32)
+		len = 32;
+
+	for (i = 0; i < len;) {
+		int nl = 16;
+		char *sbufp;
+
+		sbufp = sbuf + sprintf(sbuf, " %04X: ", (unsigned int)(i));
+		for (; i < len && nl > 0; i++, nl--)
+			sbufp += sprintf(sbufp, "%02X ", p[i]);
+		debug_printf("%s\n", sbuf);
+	}
+}
diff --git a/drivers/avc/avc_debug.h b/drivers/avc/avc_debug.h
new file mode 100644
index 0000000..aba6a9f
--- /dev/null
+++ b/drivers/avc/avc_debug.h
@@ -0,0 +1,18 @@
+#ifndef __avc_debug_h__
+#define __avc_debug_h__
+
+/* debug functions ----------------------------------------------------------*/
+
+extern int debug_level;
+
+#define debug2_np(...) __debug_np(2, __VA_ARGS__)
+#define debug0(...) __debug(0, __func__, __VA_ARGS__)
+#define debug1(...) __debug(1, __func__, __VA_ARGS__)
+#define debug2(...) __debug(2, __func__, __VA_ARGS__)
+#define dump1(...)   __dump(1, __func__, __VA_ARGS__)
+#define dump2(...)   __dump(2, __func__, __VA_ARGS__)
+extern void __debug_np(int level, const char *format, ...);
+extern void __debug(int level, const char *function, const char *format, ...);
+extern void __dump(int level, const char *function, void *ptr, int len);
+
+#endif /* __avc_debug_h__ */
diff --git a/drivers/avc/avc_info.h b/drivers/avc/avc_info.h
new file mode 100644
index 0000000..fe2d52a
--- /dev/null
+++ b/drivers/avc/avc_info.h
@@ -0,0 +1,36 @@
+#ifndef __avc_info_h__
+#define __avc_info_h__
+
+#include <mach/avc_common_info.h>
+#include "avc_regs.h"
+
+enum avc_state_t {
+	state_initial,
+	state_idle,
+	state_encoding,
+	state_encode_suspended,
+	state_decoding,
+	state_decode_suspended,
+};
+
+struct avc_info_t {
+	enum avc_state_t state;
+	struct avc_regs_t *regs;
+	struct avc_interrupt_t interrupt;
+	unsigned int int_a;
+	unsigned int int_c;
+	struct avc_common_info_t *common_info;
+#if 1
+	dma_addr_t pa_common_info;
+#endif
+	struct seq_parameter_set_rbsp_t last_sps; /* for SH,SEI */
+	struct pic_parameter_set_rbsp_t last_pps; /* for SH,SEI */
+	unsigned int encbuf_order_changed;
+	void *streambuf_virt;    /* for reverse */
+	unsigned int streambuf_size; /* for reverse */
+	struct avc_driver_version_t version;
+};
+
+extern struct avc_info_t *avc_info;
+
+#endif /* __avc_info_h__ */
diff --git a/drivers/avc/avc_interface.c b/drivers/avc/avc_interface.c
new file mode 100644
index 0000000..81c0789
--- /dev/null
+++ b/drivers/avc/avc_interface.c
@@ -0,0 +1,1152 @@
+/*!
+ * @file
+ * @brief define file operation and interruption interface for Linux 2.4
+ * @author NIS
+ * @date 2007/9/10
+ */
+
+#include <linux/init.h> /* __init */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/mm.h>      /* remap_page_range */
+/* #include <linux/wrapper.h> // mem_map_reserve */
+#include <linux/slab.h> /* kmalloc */
+#include <linux/poll.h> /* POLLIN */
+#include <linux/interrupt.h> /* tasklet */
+#include <linux/dma-mapping.h>
+#include <linux/platform_device.h>
+#include <linux/cdev.h>
+#include <linux/delay.h>
+#include <linux/io.h>  /* ioremap */
+#include <asm/irq.h> /* request_irq */
+#include <mach/hardware.h> /* AVC base address */
+/* #include <mach/pm.h>  // mp200_pmu_frqctrl_on */
+#include <mach/pmu.h> /* clock */
+/* #include <mach/stm_n.h> // power management */
+
+#include "avc_info.h"
+#include "avc_lib.h"
+#include "avc_debug.h"
+
+#if 1
+static struct avc_info_t s_avc_info = {
+	.regs = (struct avc_regs_t *)IO_ADDRESS(MP200_AVC_BASE),
+};
+#endif
+
+#define AVC_MODNAME     "mp200_avc"
+#define AVC_DEVNAME     "avc"
+
+static char *devname = AVC_DEVNAME; /* !< default device file name */
+static int devmajor = 125;    /* !< default device major number */
+#if 1
+struct avc_info_t *avc_info = &s_avc_info; /* !< this driver information */
+#else
+struct avc_info_t *avc_info; /* !< this driver information */
+#endif
+
+static void avc_tasklet_handler(unsigned long value);
+static DECLARE_TASKLET(avc_tasklet, avc_tasklet_handler, 0);
+static DECLARE_MUTEX(avc_mutex);
+static DECLARE_WAIT_QUEUE_HEAD(readq);
+static DEFINE_SPINLOCK(avc_lock);
+
+static void initialize_common_info(struct avc_common_info_t *common_info);
+
+#if 1
+#ifdef CONFIG_PM
+static int avc_pf_suspend(struct platform_device *dev, pm_message_t state);
+static int avc_pf_resume(struct platform_device *dev);
+#endif
+static int avc_pf_probe(struct platform_device *dev);
+static int avc_pf_remove(struct platform_device *dev);
+
+static void avc_pf_release(struct device *dev);
+
+static struct class *avc_class;
+static struct device *avc_class_device;
+
+static struct platform_device avc_pf_device = {
+	.name = AVC_MODNAME,
+	.id = -1,
+	.dev = {
+		.release = avc_pf_release,
+	},
+};
+
+static struct platform_driver avc_pf_driver = {
+	.probe = avc_pf_probe,
+	.remove = avc_pf_remove,
+#ifdef CONFIG_PM
+	.suspend = avc_pf_suspend,
+	.resume = avc_pf_resume,
+#endif
+	.driver = {
+		.name  = AVC_MODNAME,
+		.owner = THIS_MODULE,
+	},
+};
+#endif
+
+static int avc_open_state;
+
+/* file operations ----------------------------------------------------------*/
+
+/*!
+ * read file operation
+ * @param[in] filp
+ * @param[out] buf to copy struct avc_interrupt_t
+ * @param[in] count buf size
+ * @param[in] offp
+ * @retval size size of struct avc_interrupt_t
+ * @retval -EINVAL count error
+ */
+static ssize_t avc_read(struct file *filp, char *buf,
+			size_t count, loff_t *offp)
+{
+	int minor = MINOR(filp->f_dentry->d_inode->i_rdev);
+	unsigned long flags;
+	struct avc_interrupt_t tmp_int;
+	int ret;
+	debug1("minor %d, count %d", minor, count);
+
+	if (count < sizeof(avc_info->interrupt)) {
+		debug1("count < sizeof(avc_info->interrupt)");
+		return -EINVAL;
+	}
+
+	if (down_interruptible(&avc_mutex)) {
+		debug0("down_interruptible failed");
+		return -ERESTARTSYS;
+	}
+
+	if (wait_event_interruptible(readq,
+				((avc_info->interrupt.interrupt.l  != 0) ||
+				 (avc_info->interrupt.int_buf_full != 0)))) {
+		debug0("wait_event_interruptible failed");
+		ret = -ERESTARTSYS;
+		goto up_exit;
+	}
+
+	spin_lock_irqsave(&avc_lock, flags);
+	tmp_int = avc_info->interrupt;
+	memset(&avc_info->interrupt, 0, sizeof(avc_info->interrupt));
+	spin_unlock_irqrestore(&avc_lock, flags);
+
+	if (copy_to_user(buf, &tmp_int, sizeof(tmp_int))) {
+		debug0("copy_to_user failed");
+		ret = -EFAULT;
+		goto up_exit;
+	}
+
+	ret = sizeof(avc_info->interrupt);
+
+up_exit:
+	up(&avc_mutex);
+	return ret;
+}
+
+/*!
+ * select file operation
+ * @param[in] filp
+ * @param[in] wait
+ * @retval mask POLLIN | POLLRDNORM
+ */
+static unsigned int avc_poll(struct file *filp,
+			     struct poll_table_struct *wait)
+{
+	unsigned int mask = 0;
+	debug2("minor %d", MINOR(filp->f_dentry->d_inode->i_rdev));
+
+	poll_wait(filp, &readq, wait);
+	if (avc_info->interrupt.interrupt.l ||
+			avc_info->interrupt.int_buf_full) {
+		mask |= POLLIN | POLLRDNORM;
+	}
+
+	debug2("mask 0x%X", mask);
+	return mask;
+}
+
+/*!
+ * ioctl file operation
+ * @param[in] inode
+ * @param[in] filp
+ * @param[in] cmd AVC_IOCQBUFSIZE or AVC_IOCSREGCMD
+ * @param[in] arg struct avc_command_t with AVC_IOCSREGCMD
+ * @retval size for AVC_IOCQBUFSIZE
+ * @retval 0 command successful
+ * @retval -EINVAL command error
+ */
+static int avc_ioctl(struct inode *inode, struct file *filp,
+		     unsigned int cmd, unsigned long arg)
+{
+	struct avc_command_t avc_command;
+	struct avc_register_access_t ra;
+	unsigned long flags;
+	int ret = 0;
+
+	switch (cmd) {
+
+	case AVC_IOCQBUFSIZE:
+		ret = PAGE_ALIGN(sizeof(struct avc_common_info_t));
+		debug1("AVC_IOCQBUFSIZE %d", ret);
+		break;
+
+	case AVC_IOCSREGCMD:
+		debug1("AVC_IOCSREGCMD 0x%08lX", arg);
+		if (arg == 0) {
+			ret = -EINVAL;
+			break;
+		}
+		if (copy_from_user(&avc_command, (void *)arg,
+				   sizeof(avc_command))) {
+			debug0("copy_from_user failed");
+			ret = -EFAULT;
+			break;
+		}
+		spin_lock_irqsave(&avc_lock, flags);
+		if (command_start(avc_command.command,
+				  avc_command.last_frame) < 0) {
+			debug1("command_start failed");
+			ret = -EINVAL;
+		}
+		spin_unlock_irqrestore(&avc_lock, flags);
+		break;
+
+	case AVC_IOCSREGISTER:
+	case AVC_IOCGREGISTER:
+		debug1("AVC_IOCxREGISTER");
+		if (arg == 0) {
+			ret = -EINVAL;
+			break;
+		}
+		if (copy_from_user(&ra, (void *)arg, sizeof(ra))) {
+			debug0("copy_from_user failed");
+			ret = -EFAULT;
+			break;
+		}
+		{
+			char *addr = (char *)avc_info->regs + ra.address;
+			if (ra.address >= sizeof(struct avc_regs_t)) {
+				ret = -EINVAL;
+				break;
+			}
+			spin_lock_irqsave(&avc_lock, flags);
+			if (ra.address >= offsetof(struct avc_regs_t, bar1)) {
+				/* 32bit access */
+				if (cmd == AVC_IOCSREGISTER)
+					avc_writel(ra.value, addr);
+				else
+					ra.value = readl(addr);
+			} else {
+				/* 16bit access */
+				if (cmd == AVC_IOCSREGISTER)
+					avc_writew((unsigned short)ra.value,
+						   addr);
+				else
+					ra.value = (unsigned int)readw(addr);
+			}
+			spin_unlock_irqrestore(&avc_lock, flags);
+			if (cmd == AVC_IOCGREGISTER &&
+			    copy_to_user((void *)arg, &ra, sizeof(ra))) {
+				debug0("copy_to_user failed");
+				ret = -EFAULT;
+				break;
+			}
+			debug1(" address 0x%X", ra.address);
+			debug1(" value   0x%X", ra.value);
+		}
+		break;
+
+	case AVC_IOCGVERSION:
+		debug1("AVC_IOCGVERSION");
+		debug1(" v%d.%d.%d", avc_info->version.major,
+		       avc_info->version.minor, avc_info->version.local);
+		if (arg == 0) {
+			ret = -EINVAL;
+			break;
+		}
+		if (copy_to_user((void *)arg, &avc_info->version,
+				 sizeof(avc_info->version))) {
+			debug0("copy_to_user failed");
+			ret = -EFAULT;
+			break;
+		}
+		break;
+
+	case AVC_IOCSDEBUGLEVEL:
+		debug1("AVC_IOCSDEBUGLEVEL %lu", arg);
+		debug_level = (int)arg;
+		break;
+
+	default:
+		debug1("unknown cmd 0x%08X, arg 0x%08lX", cmd, arg);
+		ret = -EINVAL; /* ENOTTY */
+		break;
+	}
+
+	debug1("ret %d", ret);
+	return ret;
+}
+
+#if 0
+/*!
+ * allocate memory from free pages
+ * @param[in] size
+ * @retval va allocated kernel virtual address
+ */
+static void *alloc_from_free_pages(size_t size)
+{
+	int aligned_size = PAGE_ALIGN(size); /* Align size to next page
+						boundary */
+	unsigned long va; /* kernel virtual address */
+	unsigned long pa; /* page address */
+
+	debug1("size %d, aligned_size %d, order %d, PAGE_SIZE %d",
+	       size, aligned_size, get_order(aligned_size), PAGE_SIZE);
+
+	/* Attempt to allocate contiguous memory */
+	va = __get_free_pages(GFP_KERNEL, get_order(aligned_size));
+	if (va == 0) {
+		debug0("__get_free_pages() failed");
+		return NULL;
+	}
+
+	debug1("allocated to 0x%08lX", va);
+
+	/* set PG_reserved bit for mmap */
+	for (pa = va; pa < (va + aligned_size); pa += PAGE_SIZE)
+		mem_map_reserve(virt_to_page(pa));
+
+	return (void *)va;
+}
+
+/*!
+ * free memory allocated by alloc_from_free_pages
+ * @param[in] ptr address given by alloc_from_free_pages
+ * @param[in] size the same value at alloc_from_free_pages
+ * @return
+ */
+static void free_to_free_pages(void *ptr, size_t size)
+{
+	int aligned_size = PAGE_ALIGN(size);
+	unsigned long va = (unsigned long)ptr;
+	unsigned long pa;
+
+	debug1("ptr 0x%08lX, size %d, aligned_size %d, order %d",
+	       va, size, aligned_size, get_order(aligned_size));
+
+	/* unset PG_reserved bit */
+	for (pa = va; pa < (va + aligned_size); pa += PAGE_SIZE)
+		mem_map_unreserve(virt_to_page(pa));
+
+	free_pages(va, get_order(aligned_size));
+}
+#endif
+
+/*!
+ * mmap file operation
+ * @param[in] filp
+ * @param[in] vma
+ * @retval 0 successful
+ * @retval -EINVAL size error
+ */
+static int avc_mmap(struct file *filp, struct vm_area_struct *vma)
+{
+	unsigned long size = vma->vm_end - vma->vm_start;
+	unsigned long info_size = PAGE_ALIGN(sizeof(struct avc_common_info_t));
+#if 1
+	unsigned long info_pa = (unsigned long)avc_info->pa_common_info;
+#else
+	unsigned long info_pa = __pa(avc_info->common_info);
+#endif
+
+	debug1("vm_start 0x%08lX", vma->vm_start);
+	debug1("vm_end   0x%08lX", vma->vm_end);
+	debug1("size     %lu", size);
+	debug1("vm_pgoff 0x%08lX", vma->vm_pgoff);
+	debug1("vm_page_prot 0x%08lX", pgprot_val(vma->vm_page_prot));
+
+	if (size > info_size) {
+		debug1("error request size %lu > allocated size %lu",
+		       size, info_size);
+		return -EINVAL;
+	}
+
+#if 1
+	vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
+	if (remap_pfn_range(vma, vma->vm_start, info_pa >> PAGE_SHIFT, size,
+			     vma->vm_page_prot)) {
+		debug1("remap_pfn_range failed");
+		return -EAGAIN;
+	}
+#else
+	if (remap_page_range(vma->vm_start, info_pa, size, vma->vm_page_prot)) {
+		debug1("remap_page_range failed");
+		return -EAGAIN;
+	}
+#endif
+
+	initialize_common_info(avc_info->common_info);
+	debug1("mapped to 0x%08lX", info_pa);
+	return 0;
+}
+
+static void print_clock_status(void)
+{
+	debug2("MP200_CLOCKGATE_AVC_HSCLK %d",
+	       mp200_pmu_get_clockgate(MP200_CLOCKGATE_AVC_HSCLK));
+	debug2("MP200_CLOCKGATE_AVC_HMCLK %d",
+	       mp200_pmu_get_clockgate(MP200_CLOCKGATE_AVC_HMCLK));
+	debug2("MP200_CLOCKGATE_AVC_CLKM %d",
+	       mp200_pmu_get_clockgate(MP200_CLOCKGATE_AVC_CLKM));
+	debug2("MP200_CLOCKGATE_AVC_CLKE %d",
+	       mp200_pmu_get_clockgate(MP200_CLOCKGATE_AVC_CLKE));
+	debug2("MP200_CLOCKGATE_AVC_CLKD %d",
+	       mp200_pmu_get_clockgate(MP200_CLOCKGATE_AVC_CLKD));
+	debug2("MP200_CLOCKGATE_AVC_CLKC %d",
+	       mp200_pmu_get_clockgate(MP200_CLOCKGATE_AVC_CLKC));
+	debug2("MP200_RESETDEVICE_AVC %d",
+	       mp200_pmu_get_reset_status(MP200_RESETDEVICE_AVC));
+}
+
+/*!
+ * stop AVC module clock supply
+ * @param void
+ * @return void
+ */
+static void avc_clock_off(void)
+{
+	/* disable automatic clock supply control */
+	mp200_pmu_clkctrl_off(MP200_CLKCTRL_AVCHSCK);
+	mp200_pmu_clkctrl_off(MP200_CLKCTRL_AVCHMCK);
+	mp200_pmu_clkctrl_off(MP200_CLKCTRL_AVCCKM);
+	mp200_pmu_clkctrl_off(MP200_CLKCTRL_AVCCKE);
+	mp200_pmu_clkctrl_off(MP200_CLKCTRL_AVCCKD);
+	mp200_pmu_clkctrl_off(MP200_CLKCTRL_AVCCKC);
+
+	/* reset */
+	mp200_pmu_reset_device(MP200_RESETDEVICE_AVC);
+
+	/* close all clock gate for AVC */
+	mp200_pmu_close_clockgate(MP200_CLOCKGATE_AVC_HSCLK);
+	mp200_pmu_close_clockgate(MP200_CLOCKGATE_AVC_HMCLK);
+	mp200_pmu_close_clockgate(MP200_CLOCKGATE_AVC_CLKM);
+	mp200_pmu_close_clockgate(MP200_CLOCKGATE_AVC_CLKE);
+	mp200_pmu_close_clockgate(MP200_CLOCKGATE_AVC_CLKD);
+	mp200_pmu_close_clockgate(MP200_CLOCKGATE_AVC_CLKC);
+
+	print_clock_status();
+}
+
+#define SMU_L3_POWERSW_BUZ      (IO_ADDRESS(MP200_SMU_BASE) + 0x50C)
+#define SMU_LOG3SW_ACTRLEN      (IO_ADDRESS(MP200_SMU_BASE) + 0x510)
+#define SMU_LOG3SW_ACTRL        (IO_ADDRESS(MP200_SMU_BASE) + 0x514)
+
+/*!
+ * start AVC module clock supply
+ * @param void
+ * @return void
+ */
+static void avc_clock_on(void)
+{
+	/* disable automatic clock supply control (for reset). */
+	mp200_pmu_clkctrl_off(MP200_CLKCTRL_AVCHSCK);
+	mp200_pmu_clkctrl_off(MP200_CLKCTRL_AVCHMCK);
+	mp200_pmu_clkctrl_off(MP200_CLKCTRL_AVCCKM);
+	mp200_pmu_clkctrl_off(MP200_CLKCTRL_AVCCKE);
+	mp200_pmu_clkctrl_off(MP200_CLKCTRL_AVCCKD);
+	mp200_pmu_clkctrl_off(MP200_CLKCTRL_AVCCKC);
+
+	/* open all clock gate for AVC */
+	mp200_pmu_open_clockgate(MP200_CLOCKGATE_AVC_HSCLK);
+	mp200_pmu_open_clockgate(MP200_CLOCKGATE_AVC_HMCLK);
+	mp200_pmu_open_clockgate(MP200_CLOCKGATE_AVC_CLKM);
+	mp200_pmu_open_clockgate(MP200_CLOCKGATE_AVC_CLKE);
+	mp200_pmu_open_clockgate(MP200_CLOCKGATE_AVC_CLKD);
+	mp200_pmu_open_clockgate(MP200_CLOCKGATE_AVC_CLKC);
+
+	udelay(1);
+
+	avc_writel(0x00010100, SMU_L3_POWERSW_BUZ);
+
+	/* release reset */
+	mp200_pmu_unreset_device(MP200_RESETDEVICE_AVC);
+
+	/* mp200_pmu_unreset_device() waits apropriate period.
+	   Now, we can enable automatic clock control. */
+	mp200_pmu_clkctrl_on(MP200_CLKCTRL_AVCHSCK);
+	mp200_pmu_clkctrl_on(MP200_CLKCTRL_AVCHMCK);
+	mp200_pmu_clkctrl_on(MP200_CLKCTRL_AVCCKM);
+	mp200_pmu_clkctrl_on(MP200_CLKCTRL_AVCCKE);
+	mp200_pmu_clkctrl_on(MP200_CLKCTRL_AVCCKD);
+	mp200_pmu_clkctrl_on(MP200_CLKCTRL_AVCCKC);
+
+	print_clock_status();
+}
+
+
+static void print_smu_reg(void)
+{
+	debug2("SMU_L3_POWERSW_BUZ 0x%X", readl(SMU_L3_POWERSW_BUZ));
+	debug2("SMU_LOG3SW_ACTRLEN 0x%X", readl(SMU_LOG3SW_ACTRLEN));
+	debug2("SMU_LOG3SW_ACTRL   0x%X", readl(SMU_LOG3SW_ACTRL));
+}
+
+/*!
+ * start AVC module power supply
+ * @param void
+ * @retval 0 successful
+ * @retval -1 failed
+ */
+static int avc_power_on(void)
+{
+	unsigned long reg;
+	int i;
+
+	avc_writel(0x0000007F, SMU_L3_POWERSW_BUZ);
+	avc_writel(0x0000003F, SMU_L3_POWERSW_BUZ);
+	avc_writel(0x0000001F, SMU_L3_POWERSW_BUZ);
+	avc_writel(0x0000000F, SMU_L3_POWERSW_BUZ);
+	avc_writel(0x00000007, SMU_L3_POWERSW_BUZ);
+	avc_writel(0x00000003, SMU_L3_POWERSW_BUZ);
+	avc_writel(0x00000001, SMU_L3_POWERSW_BUZ);
+	avc_writel(0x00000000, SMU_L3_POWERSW_BUZ);
+
+	return 0;
+#if 0
+
+	print_smu_reg();
+	/* avc_writel((1<<16)|(1<<8), SMU_L3_POWERSW_BUZ); */
+	reg = readl(SMU_LOG3SW_ACTRLEN);
+	reg &= 0xFFFF;
+	reg |= (0x53 << 16);
+	avc_writel(reg, SMU_LOG3SW_ACTRLEN); /* LOG3_PWRSW_WAIT_PARAM[29:16] */
+	avc_writel(1, SMU_LOG3SW_ACTRL); /* start on-sequence */
+
+#endif
+
+	/* watch status */
+	for (i = 0; i < 100; i++) {
+		udelay(10);
+		reg = readl(SMU_LOG3SW_ACTRL);
+		if (reg & (1 << 16)) { /* L3_PWRSW_STATUS */
+			debug2("delay %d usec", i * 10);
+			print_smu_reg();
+			return 0;
+		}
+	}
+
+	print_smu_reg();
+	return -1;
+
+
+}
+
+/*!
+ * stop AVC module power supply
+ * @param void
+ * @retval 0 successful
+ * @retval -1 failed
+ */
+static int avc_power_off(void)
+{
+	unsigned long reg;
+	int i;
+
+	avc_writel(0x00000100, SMU_LOG3SW_ACTRLEN);
+
+	avc_writel(0x00000000, SMU_L3_POWERSW_BUZ);
+	avc_writel(0x00000001, SMU_L3_POWERSW_BUZ);
+	avc_writel(0x00000003, SMU_L3_POWERSW_BUZ);
+	avc_writel(0x00000007, SMU_L3_POWERSW_BUZ);
+	avc_writel(0x0000000F, SMU_L3_POWERSW_BUZ);
+	avc_writel(0x0000001F, SMU_L3_POWERSW_BUZ);
+	avc_writel(0x0000003F, SMU_L3_POWERSW_BUZ);
+	avc_writel(0x0000007F, SMU_L3_POWERSW_BUZ);
+	avc_writel(0x000000FF, SMU_L3_POWERSW_BUZ);
+
+	udelay(2);
+
+	return 0;
+
+#if 0
+	print_smu_reg();
+	avc_writel(0, SMU_LOG3SW_ACTRL); /* start off-sequence */
+#endif
+	/* watch status */
+	for (i = 0; i < 100; i++) {
+		udelay(10);
+		reg = readl(SMU_LOG3SW_ACTRL);
+		if ((reg & (1 << 16)) == 0) { /* SMU_LOG3SW_ACTRL */
+			debug2("delay %d usec", i * 10);
+			print_smu_reg();
+			return 0;
+		}
+	}
+
+	print_smu_reg();
+	return -1;
+}
+
+/*!
+ * open file operation
+ * @param[in] inode
+ * @param[in] filp
+ * @retval 0 successful
+ * @retval -EBUSY double request
+ * @retval -FAULT power setting failure etc
+ */
+static int avc_open(struct inode *inode, struct file *filp)
+{
+/*  int minor = MINOR(inode->i_rdev); */
+/*  int ret; */
+/*  debug1("minor %d, usecount %d",minor,GET_USE_COUNT(THIS_MODULE)); */
+
+	if (avc_info->state != state_initial) {
+		debug1("already opened");
+		return -EBUSY;
+	}
+
+#if 0
+	/* energy-saving off */
+	status_ctrl_func(DRV_AVC, STAT_ON);
+
+	/* not to change frequency automatically */
+	ret = mp200_pmu_frqctrl_on(MP200_FRQCTRL_AVC);
+	if (ret) {
+		debug0("mp200_pmu_frqctrl_on failed %d", ret);
+		status_ctrl_func(DRV_AVC, STAT_OFF);
+		return -EFAULT;
+	}
+#endif
+
+	/* power on */
+	if (avc_power_on() < 0) {
+		debug0("avc_power_on failed");
+#if 0
+		ret = mp200_pmu_frqctrl_off(MP200_FRQCTRL_AVC);
+		if (ret)
+			debug0("mp200_pmu_frqctrl_off failed %d", ret);
+		status_ctrl_func(DRV_AVC, STAT_OFF);
+#endif
+		return -EFAULT;
+	}
+
+	avc_clock_on();
+
+	avc_info->state = state_idle;
+
+	avc_open_state = 1;
+
+/*  MOD_INC_USE_COUNT; */
+
+	return 0;
+}
+
+/*!
+ * close file operation
+ * @param[in] inode
+ * @param[in] filp
+ * @retval 0 successful
+ */
+static int avc_release(struct inode *inode, struct file *filp)
+{
+	int minor = MINOR(inode->i_rdev);
+/*  int ret; */
+	debug1("minor %d", minor);
+
+	command_start(avc_command_reset, 0);
+	avc_info->state = state_initial;
+
+	avc_clock_off();
+	if (avc_power_off() < 0)
+		debug0("avc_power_off failed");
+#if 0
+	ret = mp200_pmu_frqctrl_off(MP200_FRQCTRL_AVC);
+	if (ret)
+		debug0("mp200_pmu_frqctrl_off failed %d", ret);
+	status_ctrl_func(DRV_AVC, STAT_OFF);
+#endif
+
+	avc_open_state = 0;
+
+/*  MOD_DEC_USE_COUNT; */
+
+	return 0;
+}
+
+/* ! file operations for this driver */
+static const struct file_operations avc_fops = {
+	.owner      = THIS_MODULE,
+	.llseek     = no_llseek,
+	.open       = avc_open,
+	.release    = avc_release,
+	.read       = avc_read,
+	.poll       = avc_poll,
+	.ioctl      = avc_ioctl,
+	.mmap       = avc_mmap,
+};
+
+
+/* interruption -------------------------------------------------------------*/
+
+/*!
+ * AVC interruption handler about stream buffer full
+ * @param irq
+ * @param dev_id
+ * @param regs
+ */
+static irqreturn_t avc_interrupt_a(int irq, void *dev_id)
+{
+	struct avc_regs_t *avc_regs;
+	unsigned short factor;
+
+#if 0
+	if (!avc_info) {
+		debug1("not initialized yet");
+		return IRQ_NONE;
+	}
+#endif
+
+	avc_regs = avc_info->regs;
+	factor = readw(&avc_regs->BINT1);
+	if (factor) {
+		avc_writew(factor, &avc_regs->BINT5); /* clear interruption */
+#if 1
+		if (avc_info->common_info) {
+			avc_info->int_a = 1;
+			tasklet_schedule(&avc_tasklet);
+		}
+#else
+		avc_info->int_a = 1;
+		tasklet_schedule(&avc_tasklet);
+#endif
+		return IRQ_HANDLED;
+	}
+	return IRQ_NONE;
+}
+
+/*!
+ * AVC interruption handler
+ * @param irq
+ * @param dev_id
+ * @param regs
+ */
+static irqreturn_t avc_interrupt_c(int irq, void *dev_id)
+{
+	struct avc_regs_t *avc_regs;
+	unsigned short factor;
+
+	if (!avc_info) {
+		debug1("not initialized yet");
+		return IRQ_NONE;
+	}
+
+	avc_regs = avc_info->regs;
+	factor = readw(&avc_regs->INT1reg);
+	if (factor) {
+		avc_writew(factor, &avc_regs->INT5reg); /* clear interruption */
+		avc_info->int_c |= factor;
+		tasklet_schedule(&avc_tasklet);
+		return IRQ_HANDLED;
+	}
+	return IRQ_NONE;
+}
+
+/*!
+ * tasklet for interruption
+ * @param[in] value unused
+ * @return void
+ */
+void avc_tasklet_handler(unsigned long value)
+{
+	unsigned long flags;
+	unsigned int int_a, int_c;
+
+	while (1) {
+		spin_lock_irqsave(&avc_lock, flags);
+		int_c = avc_info->int_c;
+		int_a = avc_info->int_a;
+		avc_info->int_c = 0;
+		avc_info->int_a = 0;
+		spin_unlock_irqrestore(&avc_lock, flags);
+
+		if (int_c == 0 && int_a == 0)
+			break;
+		avc_interruption_handler(int_c, int_a);
+		avc_info->interrupt.interrupt.l  |= int_c;
+		avc_info->interrupt.int_buf_full |= int_a;
+	}
+
+	wake_up_interruptible(&readq);
+}
+
+
+/* module functions ---------------------------------------------------------*/
+
+static void initialize_common_info(struct avc_common_info_t *common_info)
+{
+	struct encode_info_t *ei = &common_info->encode_info;
+	struct avc_user_set_parameter_t *usp =
+		&common_info->avc_user_set_parameter;
+
+	memset(common_info, 0, sizeof(*common_info));
+
+	common_info->avc_buffer_address.change_endian = 1;
+	ei->enc_image_value = 0x33;
+	ei->enc_initial_image_value = 0x19;
+	ei->enc_islice_image_mode = 0x08;
+	ei->enc_min_qp_i = 1;
+	ei->enc_min_qp_p = 1;
+	ei->enc_cvbr = 1;
+	ei->enc_skip_off = 0;
+	ei->idr_in = 0;
+	ei->skip_in = 0;
+
+	usp->set_int_en = AVC_INT_ENC_END_EN | AVC_INT_DEC_END_EN
+		| AVC_INT_DEC_ERR_EN | AVC_INT_ENC_PIC_END_EN
+		| AVC_INT_DEC_PIC_END_EN | AVC_INT_HEAD_DEC_END_EN;
+
+	usp->set_err_nal_en = AVC_ERR_NAL_END | AVC_ERR_FORBIDDEN_ZERO_BIT
+		| AVC_ERR_REF_IDC | AVC_ERR_NAL_UNIT_TYPE;
+
+	usp->set_err_sps_en = AVC_HRD_ERROR | AVC_VUI_ERROR
+		| AVC_SPS_OTHER_ERROR | AVC_ERR_DIRECT_8X8_INFERENCE_FLAG
+		| AVC_ERR_MB_ADAPTIVE_FRAME_FIELD_FLAG | AVC_ERR_PROFILE
+		| AVC_ERR_LEVEL_IDC | AVC_ERR_SEQ_PARAMETER_SET_ID
+		| AVC_ERR_LOG2_MAX_FRAME_NUM_MINUS4 | AVC_ERR_PIC_ORDER_CNT_TYPE
+		| AVC_ERR_LOG2_MAX_PIC_ORDER_CNT_LSB_MINUS4
+		| AVC_ERR_NUM_REF_FRAMES | AVC_ERR_PIC_WIDTH_IN_MBS_MINUS1
+		| AVC_ERR_PIC_HEIGHT_IN_MAP_UNITS_MINUS1;
+
+	usp->set_err_pps_en = AVC_ERR_PPS_PPS_ID | AVC_ERR_PPS_SPS_ID
+		| AVC_ERR_PPS_ENTROPY_FLAG | AVC_ERR_PPS_NUM_SLICE
+		| AVC_ERR_PPS_NUM_REF_IDX | AVC_ERR_PPS_WEIGHTED_FLAG
+		| AVC_ERR_PPS_WEIGHTED_IDC | AVC_ERR_PPS_PIC_INIT_Q
+		| AVC_ERR_PPS_CQP_IDX_OFS | AVC_ERR_PPS_REDUNDANT_FLAG;
+
+	usp->set_err_sh_en = AVC_ERR_SH_END | AVC_ERR_SH_SLICE_TYPE
+		| AVC_ERR_SH_PPS_ID | AVC_ERR_SH_IDR_PIC_ID
+		| AVC_ERR_SH_NUM_REF_IDX_L0 | AVC_ERR_SH_DIS_DBF_IDC
+		| AVC_ERR_SH_SLC_A_C0_OFS | AVC_ERR_SH_SLC_BETA_OFS
+		| AVC_ERR_SH_ROPN_IDC | AVC_ERR_SH_MMCO;
+
+	usp->set_err_sd_en = AVC_ERR_1ST_MB_IN_SLICE | AVC_ERR_SD_END
+		| AVC_ERR_SD_MB_TYPE | AVC_ERR_SD_CBP
+		| AVC_ERR_SD_MBP_REF_IDX | AVC_ERR_SD_MBP_ICPM
+		| AVC_ERR_SD_SMB_REF_IDX | AVC_ERR_ZSL_LT_RUN
+		| AVC_ERR_CV_COEFT | AVC_ERR_CV_LV_PREFIX
+		| AVC_ERR_CV_TZEROS | AVC_ERR_CV_RUN_BEFORE;
+
+	usp->set_header_end_en = AVC_SPS_END | AVC_PPS_END
+		| AVC_SEI_END | AVC_AUD_END | AVC_EOSEQ_END
+		| AVC_SH_END | AVC_END_OF_STREAM_END
+		| AVC_FILLER_DATA_END;
+
+	usp->set_ref_hw_ctrl = AVC_REF_HW_CTRL_HW;
+
+	usp->set_dec_error_conceal = AVC_DEC_ERROR_CONCEAL_ON;
+
+	usp->set_sei_raw_output = 0;
+
+	usp->set_mem_num_wr = 0;
+
+	usp->mem_num_ref_idx.set_ref_idx0 = 0;
+	usp->mem_num_ref_idx.set_ref_idx1 = 0;
+	usp->mem_num_ref_idx.set_ref_idx2 = 0;
+	usp->mem_num_ref_idx.set_ref_idx3 = 0;
+	usp->mem_num_ref_idx.set_ref_idx4 = 0;
+	usp->mem_num_ref_idx.set_ref_idx5 = 0;
+	usp->mem_num_ref_idx.set_ref_idx6 = 0;
+	usp->mem_num_ref_idx.set_ref_idx7 = 0;
+	usp->mem_num_ref_idx.set_ref_idx8 = 0;
+	usp->mem_num_ref_idx.set_ref_idx9 = 0;
+	usp->mem_num_ref_idx.set_ref_idx10 = 0;
+	usp->mem_num_ref_idx.set_ref_idx11 = 0;
+	usp->mem_num_ref_idx.set_ref_idx12 = 0;
+	usp->mem_num_ref_idx.set_ref_idx13 = 0;
+	usp->mem_num_ref_idx.set_ref_idx14 = 0;
+	usp->mem_num_ref_idx.set_ref_idx15 = 0;
+
+	usp->set_planar_sel = AVC_PLANAR_SEL_PLANAR;
+
+	usp->set_bytelane = AVC_BYTELANE_Y3210 | AVC_BYTELANE_C3210;
+
+}
+
+#ifdef CONFIG_PM
+static int avc_pf_suspend(struct platform_device *dev, pm_message_t state)
+{
+	if (avc_open_state) {
+		if (state.event == DEV_SUSPEND_IDLE_1) { /* PCM direct */
+			return -EBUSY;
+		} else{ /* state.event == PM_EVENT_SUSPEND */
+			avc_clock_off();
+			avc_power_off();
+		}
+	}
+	return 0;
+}
+
+static int avc_pf_resume(struct platform_device *dev)
+{
+	if (avc_open_state) {
+		avc_power_on();
+		avc_clock_on();
+	}
+	return 0;
+}
+#endif
+
+static int avc_pf_probe(struct platform_device *dev)
+{
+	struct avc_common_info_t *common_info;
+	dma_addr_t paddr;
+	int ret;
+
+	common_info = dma_alloc_coherent(0, sizeof *common_info,
+					 &paddr, GFP_KERNEL | GFP_DMA);
+	if (common_info) {
+		initialize_common_info(common_info);
+		avc_info->common_info = common_info;
+		avc_info->pa_common_info = paddr;
+	} else {
+		debug0("dma_alloc_coherent avc_common_info failed");
+		ret = -ENOMEM;
+		goto error_return;
+	}
+
+	/* request_irq returns ENOMEM/EINVAL */
+	ret = request_irq(INT_AVC_A, avc_interrupt_a,
+			  IRQF_SHARED, AVC_MODNAME, avc_info);
+	if (ret < 0) {
+		debug0("request_irq(%d) failed %d", INT_AVC_A, ret);
+		goto free_common_info;
+	}
+
+	ret = request_irq(INT_AVC_C, avc_interrupt_c,
+			  IRQF_SHARED, AVC_MODNAME, avc_info);
+	if (ret < 0) {
+		debug0("request_irq(%d) failed %d", INT_AVC_C, ret);
+		goto free_irq_inta;
+	}
+
+	/* register chrdev */
+	debug1("register_chrdev %d, %s", devmajor, AVC_MODNAME);
+	ret = register_chrdev(devmajor, AVC_MODNAME, &avc_fops);
+	if (ret < 0) {
+		debug0("register_chrdev %d, %s failed %d",
+				devmajor, AVC_MODNAME, ret);
+		ret = -EFAULT;
+		goto free_irq_intc;
+	}
+
+	avc_class = class_create(THIS_MODULE, AVC_MODNAME);
+	if (IS_ERR(avc_class)) {
+		debug0("class_create failed %d", ret);
+		ret = PTR_ERR(avc_class);
+		goto free_chrdev;
+	}
+
+	avc_class_device = device_create(avc_class, &dev->dev,
+					 MKDEV(devmajor, 0),  NULL,
+					 "%s", AVC_DEVNAME);
+	if (IS_ERR(avc_class_device)) {
+		debug0("class_device_create failed %s %d", AVC_DEVNAME, ret);
+		class_destroy(avc_class);
+		ret = PTR_ERR(avc_class_device);
+		goto free_chrdev;
+	}
+
+	/* driver version information */
+	avc_create_proc();
+
+	avc_info->state = state_initial;
+	memcpy(&avc_info->version, &avc_driver_version,
+			sizeof(avc_info->version));
+
+	avc_open_state = 0;
+	debug1("success");
+	return 0;
+
+free_chrdev:
+	unregister_chrdev(devmajor, AVC_MODNAME);
+
+free_irq_intc:
+	free_irq(INT_AVC_C, avc_info);
+
+free_irq_inta:
+	free_irq(INT_AVC_A, avc_info);
+
+free_common_info:
+	dma_free_coherent(0, sizeof *common_info, common_info, paddr);
+
+error_return:
+	return ret;
+}
+
+static int avc_pf_remove(struct platform_device *dev)
+{
+	device_destroy(avc_class, MKDEV(devmajor, 0));
+	class_destroy(avc_class);
+	avc_remove_proc();
+	debug1("unregister_chrdev %d, %s", devmajor, AVC_MODNAME);
+	unregister_chrdev(devmajor, AVC_MODNAME);
+	free_irq(INT_AVC_C, avc_info);
+	free_irq(INT_AVC_A, avc_info);
+	dma_free_coherent(0, sizeof *avc_info->common_info,
+			  avc_info->common_info, avc_info->pa_common_info);
+	return 0;
+}
+
+static void avc_pf_release(struct device *dev)
+{
+	/* none */
+}
+
+#if 1
+/*!
+ * initialize for insmod
+ * @param void
+ * @return void
+ */
+static int __init avc_init(void)
+{
+	int ret;
+
+	ret = platform_device_register(&avc_pf_device);
+	if (ret)
+		return ret;
+	return platform_driver_register(&avc_pf_driver);
+}
+
+/*!
+ * finalize for rmmod
+ * @param void
+ * @return void
+ */
+static void __exit avc_exit(void)
+{
+	(void)platform_driver_unregister(&avc_pf_driver);
+	(void)platform_device_unregister(&avc_pf_device);
+}
+#else
+/*!
+ * initialize for insmod
+ * @param void
+ * @return void
+ */
+static int __init avc_init(void)
+{
+	struct avc_regs_t *regs;
+	struct avc_info_t *info;
+	struct avc_common_info_t *common_info;
+	int ret;
+
+	/* allocate avc_info */
+	info = kmalloc(sizeof(*info), GFP_KERNEL);
+	if (info) {
+		memset(info, 0, sizeof(*info));
+	} else {
+		debug0("kmalloc avc_info_t failed");
+		ret = -ENOMEM;
+		goto error_return;
+	}
+
+	/* allocate common_info */
+	common_info = alloc_from_free_pages(sizeof(*common_info));
+	if (common_info) {
+		initialize_common_info(common_info);
+	} else {
+		debug0("kmalloc avc_common_info failed");
+		ret = -ENOMEM;
+		goto free_info;
+	}
+
+	/* base address */
+	regs = (struct avc_regs_t *)IO_ADDRESS(MP200_AVC_BASE);
+
+	/* request_irq returns ENOMEM/EINVAL */
+	ret = request_irq(INT_AVC_A, avc_interrupt_a,
+			  SA_SHARED, devname, info);
+	if (ret < 0) {
+		debug0("request_irq(%d) failed %d", INT_AVC_A, ret);
+		goto free_common_info;
+	}
+
+	ret = request_irq(INT_AVC_C, avc_interrupt_c,
+			  SA_SHARED, devname, info);
+	if (ret < 0) {
+		debug0("request_irq(%d) failed %d", INT_AVC_C, ret);
+		goto free_irq_inta;
+	}
+
+	/* register chrdev */
+	debug1("register_chrdev %d, %s", devmajor, devname);
+	ret = register_chrdev(devmajor, devname, &avc_fops);
+	if (ret < 0) {
+		debug0("register_chrdev %d, %s failed %d",
+				devmajor, devname, ret);
+		ret = -EFAULT;
+		goto free_irq_intc;
+	}
+
+	/* driver version information */
+	avc_create_proc();
+
+	info->common_info = common_info;
+	info->regs = regs;
+	avc_info = info;
+	avc_info->state = state_initial;
+	memcpy(&avc_info->version, &avc_driver_version,
+			sizeof(avc_info->version));
+
+	return 0;
+
+free_irq_intc:
+	free_irq(INT_AVC_C, info);
+
+free_irq_inta:
+	free_irq(INT_AVC_A, info);
+
+free_common_info:
+	free_to_free_pages(common_info, sizeof(*common_info));
+
+free_info:
+	kfree(info);
+	avc_info = NULL;
+
+error_return:
+	return ret;
+}
+
+/*!
+ * finalize for rmmod
+ * @param void
+ * @return void
+ */
+static void __exit avc_exit(void)
+{
+	struct avc_common_info_t *common_info = avc_info->common_info;
+
+	debug1("unregister_chrdev %d, %s", devmajor, devname);
+	avc_remove_proc();
+	unregister_chrdev(devmajor, devname);
+	free_irq(INT_AVC_C, avc_info);
+	free_irq(INT_AVC_A, avc_info);
+	free_to_free_pages(common_info, sizeof(*common_info));
+	kfree(avc_info);
+	avc_info = NULL;
+}
+#endif
+
+module_init(avc_init);
+module_exit(avc_exit);
+module_param(devname, charp, 0444);
+module_param(devmajor, int, 0444);
+module_param(debug_level, int, 0444);
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("H.264/AVC Driver for EM1");
+MODULE_AUTHOR("NIS");
diff --git a/drivers/avc/avc_lib.h b/drivers/avc/avc_lib.h
new file mode 100644
index 0000000..2a90caa
--- /dev/null
+++ b/drivers/avc/avc_lib.h
@@ -0,0 +1,48 @@
+#ifndef __avc_lib_h__
+#define __avc_lib_h__
+
+#include <linux/io.h>  /* readw, writew */
+#include "avc_debug.h"
+
+extern int command_start(unsigned short command, unsigned short last_frame);
+extern int avc_interruption_handler(unsigned int factor, unsigned int int_a);
+extern int avc_create_proc(void);
+extern int avc_remove_proc(void);
+extern struct avc_driver_version_t avc_driver_version;
+
+#define  bits(_v, _m, _l) ((_v >> _l) & ((1 << (_m - _l + 1)) - 1))
+#define wbits(_v, _m, _l) ((_v & ((1 << (_m - _l + 1)) - 1)) << _l)
+
+#define maximum(_x, _y) ((_x > _y) ? _x : _y)
+#define minimum(_x, _y) ((_x < _y) ? _x : _y)
+
+
+#ifdef __KERNEL__
+
+#define avc_writew(_v, _a) \
+do { \
+		debug2("writew: %s %p = 0x%X %u", # _a, _a, _v, _v); \
+		writew(_v, _a);	\
+} while (0)
+
+#define avc_writel(_v, _a) \
+do { \
+		debug2("writel: %s %p = 0x%X %u", # _a, _a, _v, _v); \
+		writel(_v, _a);	\
+} while (0)
+
+#else /* __KERNEL__ */
+
+#define writew(v, a) (*(volatile unsigned short *)(a) = (unsigned short)(v))
+#define writel(v, a) (*(volatile unsigned int *)(a) = (unsigned int)(v))
+#define readw(a) (*(volatile unsigned short *)(a))
+#define readl(a) (*(volatile unsigned int *)(a))
+#define avc_writew(_v, _a) \
+	debug2("writew: %s %p = 0x%X %u", # _a, _a, _v, _v);
+#define avc_writel(_v, _a) \
+	debug2("writel: %s %p = 0x%X %u", # _a, _a, _v, _v);
+
+#endif /* __KERNEL__ */
+
+
+#endif /* __avc_lib_h__ */
diff --git a/drivers/avc/avc_regs.h b/drivers/avc/avc_regs.h
new file mode 100644
index 0000000..56476f9
--- /dev/null
+++ b/drivers/avc/avc_regs.h
@@ -0,0 +1,263 @@
+#ifndef __avc_regs_h__
+#define __avc_regs_h__
+
+struct avc_regs_t {
+	/* [15:0] */
+
+	unsigned int CMDreg; /* 000h */
+
+	char pad1[0x020 - 0x000 - 4];
+
+	unsigned int STATreg; /* 020h */
+	unsigned int INT1reg;
+	unsigned int INT2reg;
+	unsigned int INT3reg;
+	unsigned int INT4reg;
+	unsigned int INT5reg; /* 034h */
+
+	char pad2[0x100 - 0x034 - 4];
+
+	unsigned int dec_PARreg1; /* 100h */
+	unsigned int dec_PARreg2;
+	unsigned int dec_PARreg3;
+	unsigned int dec_PARreg4;
+	unsigned int dec_PARreg5;
+	unsigned int dec_PARreg6;
+	unsigned int dec_PARreg7;
+	unsigned int dec_PARreg8;
+	unsigned int dec_PARreg9; /* 120h */
+
+	char pad3[0x200 - 0x120 - 4];
+
+	unsigned int enc_PARreg1; /* 200h */
+	unsigned int enc_PARreg2;
+	unsigned int enc_PARreg3;
+	unsigned int enc_PARreg4;
+	unsigned int enc_PARreg5;
+	unsigned int enc_PARreg6;
+	unsigned int enc_PARreg7;
+	unsigned int enc_PARreg8;
+	unsigned int enc_PARreg9;
+	unsigned int enc_PARreg10;
+	unsigned int enc_PARreg11;
+	unsigned int enc_PARreg12;
+	unsigned int enc_PARreg13;
+	unsigned int enc_PARreg14;
+	unsigned int enc_PARreg15;
+	unsigned int enc_PARreg16;
+	unsigned int enc_PARreg17;
+	unsigned int enc_PARreg18;
+	unsigned int enc_PARreg19; /* 248h */
+
+	char pad4[0x250 - 0x248 - 4];
+
+	unsigned int enc_INFOreg1; /* 250h */
+	unsigned int enc_INFOreg2; /* 254h */
+
+	char pad5[0x25C - 0x254 - 4];
+
+	unsigned int enc_PARreg22; /* 25Ch */
+
+	char pad6[0x298 - 0x25C - 4];
+
+	unsigned int enc_INFOreg3; /* 298h */
+	unsigned int enc_INFOreg4; /* 29Ch */
+
+	char pad7[0x2B4 - 0x29C - 4];
+
+	unsigned int enc_PARreg23; /* 2B4h */
+
+	char pad8[0x2BC - 0x2B4 - 4];
+
+	unsigned int enc_PARreg21; /* 2BCh */
+
+	char pad_2C0[0x2C4 - 0x2C0];
+
+	unsigned int enc_PARreg20; /* 2C4h */
+
+	char pad9[0x2CC - 0x2C4 - 4];
+
+	unsigned int enc_PARreg24; /* 2CCh */
+
+	char pad10[0x2DC - 0x2CC - 4];
+
+	unsigned int enc_PARreg25; /* 2DCh */
+
+	char pad11[0x2E8 - 0x2DC - 4];
+
+	unsigned int enc_PARreg26; /* 2E8h */
+
+	char pad12[0x2F0 - 0x2E8 - 4];
+
+	unsigned int enc_PARreg27; /* 2F0h */
+
+	char pad13[0x300 - 0x2F0 - 4];
+
+	unsigned int head_PRreg1; /* 300h */
+	unsigned int head_PRreg2;
+	unsigned int head_PRreg3;
+	unsigned int head_PRreg4;
+	unsigned int head_PRreg5;
+	unsigned int head_PRreg6;
+	unsigned int head_PRreg7;
+	unsigned int head_PRreg8;
+	unsigned int head_PRreg9;
+	unsigned int head_PRreg10;
+	unsigned int head_PRreg11;
+	unsigned int head_PRreg12;
+	unsigned int head_PRreg13;
+	unsigned int head_PRreg14;
+	unsigned int head_PRreg15;
+	unsigned int head_PRreg16;
+	unsigned int head_PRreg17;
+	unsigned int head_PRreg18;
+	unsigned int head_PRreg19;
+	unsigned int head_PRreg20;
+	unsigned int head_PRreg21;
+	unsigned int head_PRreg22;
+	unsigned int head_PRreg23;
+	unsigned int head_PRreg24;
+	unsigned int head_PRreg25;
+	unsigned int head_PRreg26;
+	unsigned int head_PRreg27;
+	unsigned int head_PRreg28;
+	unsigned int head_PRreg29;
+	unsigned int head_PRreg30;
+	unsigned int head_PRreg31;
+	unsigned int head_PRreg32; /* 37Ch */
+
+	unsigned int enc_PARreg28; /* 380h */
+	unsigned int enc_PARreg29;
+	unsigned int enc_PARreg30;
+	unsigned int enc_PARreg31;
+	unsigned int enc_PARreg32;
+	unsigned int enc_PARreg33;
+	unsigned int enc_PARreg34;
+	unsigned int enc_PARreg35;
+	unsigned int enc_PARreg36;
+	unsigned int enc_PARreg37;
+	unsigned int enc_PARreg38;
+	unsigned int enc_PARreg39;
+	unsigned int enc_PARreg40;
+	unsigned int enc_PARreg41;
+	unsigned int enc_PARreg42;
+	unsigned int enc_PARreg43;
+	unsigned int enc_PARreg44;
+	unsigned int enc_PARreg45;
+	unsigned int enc_PARreg46;
+	unsigned int enc_PARreg47;
+	unsigned int enc_PARreg48;
+	unsigned int enc_PARreg49;
+	unsigned int enc_PARreg50;
+	unsigned int enc_PARreg51;
+	unsigned int enc_PARreg52;
+	unsigned int enc_PARreg53;
+	unsigned int enc_PARreg54;
+	unsigned int enc_PARreg55;
+	unsigned int enc_PARreg56;
+	unsigned int enc_PARreg57;
+	unsigned int enc_PARreg58;
+	unsigned int enc_PARreg59;
+	unsigned int enc_PARreg60;
+	unsigned int enc_PARreg61;
+	unsigned int enc_PARreg62;
+	unsigned int enc_PARreg63;
+	unsigned int enc_PARreg64;
+	unsigned int enc_PARreg65;
+	unsigned int enc_PARreg66;
+	unsigned int enc_PARreg67;
+	unsigned int enc_PARreg68;
+	unsigned int enc_PARreg69;
+	unsigned int enc_PARreg70;
+	unsigned int enc_PARreg71;
+	unsigned int enc_PARreg72;
+	unsigned int enc_PARreg73;
+	unsigned int enc_PARreg74;
+	unsigned int enc_PARreg75;
+	unsigned int enc_PARreg76;
+	unsigned int enc_PARreg77;
+	unsigned int enc_PARreg78;
+	unsigned int enc_PARreg79;
+	unsigned int enc_PARreg80;
+	unsigned int enc_PARreg81;
+	unsigned int enc_PARreg82;
+	unsigned int enc_PARreg83;
+	unsigned int enc_PARreg84;
+	unsigned int enc_PARreg85;
+	unsigned int enc_PARreg86;
+	unsigned int enc_PARreg87;
+	unsigned int enc_PARreg88;
+	unsigned int enc_PARreg89;
+	unsigned int enc_PARreg90;
+	unsigned int enc_PARreg91;
+	unsigned int enc_PARreg92;
+	unsigned int enc_PARreg93;
+	unsigned int enc_PARreg94;
+	unsigned int enc_PARreg95;
+	unsigned int enc_PARreg96;
+	unsigned int enc_PARreg97;
+	unsigned int enc_PARreg98;
+	unsigned int enc_PARreg99;
+	unsigned int enc_PARreg100;
+	unsigned int enc_PARreg101;
+	unsigned int enc_PARreg102;
+	unsigned int enc_PARreg103;
+	unsigned int enc_PARreg104;
+	unsigned int enc_PARreg105;
+	unsigned int enc_PARreg106;
+	unsigned int enc_PARreg107;
+	unsigned int enc_PARreg108;
+	unsigned int enc_PARreg109; /* 4C4h */
+
+	char pad14[0x500 - 0x4C4 - 4];
+
+	/* [31:0] */
+
+	unsigned int bar1; /* 500h */
+	unsigned int bar2;
+	unsigned int bar3;
+	unsigned int bar4;
+	unsigned int bar5;
+	unsigned int bar6;
+	unsigned int bar7;
+	unsigned int bar8;
+	unsigned int bar9;
+	unsigned int bar10;
+	unsigned int bar11;
+	unsigned int bar12;
+	unsigned int bar13;
+	unsigned int bar14;
+	unsigned int bar15;
+	unsigned int bar16;
+	unsigned int bar17;
+	unsigned int bar18;
+	unsigned int bar19;
+	unsigned int buf_size_reg19;
+	unsigned int bar20;
+	unsigned int buf_size_reg20;
+	unsigned int stream_buf_sel;
+	unsigned int codec_mem_ctl;
+	unsigned int stream_buf_adr; /* 560h */
+
+	char pad15[0x1C];
+
+	unsigned int bar21y; /* 580h */
+	unsigned int bar21u;
+	unsigned int bar21v;
+	unsigned int bar22y;
+	unsigned int bar22u;
+	unsigned int bar22v;
+	unsigned int raster1;
+	unsigned int raster2;
+	unsigned int raster3; /* 5A0h */
+
+	char pad16[0xC];
+
+	unsigned int BINT1; /* 5B0h */
+	unsigned int BINT2;
+	unsigned int BINT3;
+	unsigned int BINT4;
+	unsigned int BINT5;
+};
+
+#endif /* __avc_regs_h__ */
diff --git a/drivers/avc/avc_version.c b/drivers/avc/avc_version.c
new file mode 100644
index 0000000..4dae860
--- /dev/null
+++ b/drivers/avc/avc_version.c
@@ -0,0 +1,47 @@
+
+#include <linux/proc_fs.h>
+#include <linux/stat.h>
+#include <mach/avc_common_info.h>
+#include "avc_debug.h"
+
+
+const char *AVC_VERSION = "H.264/AVC Driver for EM1 v0.0.1 2008/6/5";
+const struct avc_driver_version_t avc_driver_version = {0, 0, 1};
+
+#define AVC_PROC_NAME "driver/avc"
+/* #define AVC_PROC_ENABLE */
+
+#ifdef AVC_PROC_ENABLE
+static int avc_proc_read(char *page, char **start, off_t offset, int count,
+		int *eof, void *data)
+{
+	int len = 0;
+	len += snprintf(page, count, "%s\n", AVC_VERSION);
+	*eof = 1;
+	return len;
+}
+#endif
+
+int avc_create_proc(void)
+{
+#ifdef AVC_PROC_ENABLE
+	struct proc_dir_entry *entry;
+
+	entry = create_proc_entry(AVC_PROC_NAME, S_IFREG | S_IRUGO, NULL);
+	if (entry == NULL) {
+		debug0("create_proc_entry failed %s", AVC_PROC_NAME);
+		return -1;
+	}
+
+	entry->read_proc = avc_proc_read;
+#endif
+	return 0;
+}
+
+int avc_remove_proc(void)
+{
+#ifdef AVC_PROC_ENABLE
+	remove_proc_entry(AVC_PROC_NAME, NULL);
+#endif
+	return 0;
+}
-- 
1.6.5.2

