From 6eaf936f16ed0e1eb7b8905eed8df9d101d48fa9 Mon Sep 17 00:00:00 2001
From: Kazuya Tsukamoto <kazuya.tsukamoto@necel.com>
Date: Mon, 9 Nov 2009 12:06:54 +0900
Subject: [PATCH 13/29] nec_ema: add DTV I/F support
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

This is a driver to access DTV I/F on the EMMA Mobile 1 board.

There is H/W error in DTV I/F. Please do DTV I/F in H/W reset
at the following condition.
ã€€RAWSTATUS DTVSTOPbit==1 and DMAREQ == 1, after DMASTOP.
At this time, because the accumulated receive data is annulled,
 the variable is initialized at the same time.
(These processing is enclosed with #ifdef DTV_ERRAT. )
Please invalidate #ifdef DTV_ERRAT when DTV I/F is corrected
in the future.

Signed-off-by: Kazuya Tsukamoto <kazuya.tsukamoto@necel.com>
---
 arch/arm/mach-mp200/include/mach/dtv_ioctl.h |   55 +
 drivers/char/mp200_dtv.c                     | 1362 ++++++++++++++++++++++++++
 drivers/char/mp200_dtv.h                     |  151 +++
 3 files changed, 1568 insertions(+), 0 deletions(-)
 create mode 100644 arch/arm/mach-mp200/include/mach/dtv_ioctl.h
 create mode 100644 drivers/char/mp200_dtv.c
 create mode 100644 drivers/char/mp200_dtv.h

diff --git a/arch/arm/mach-mp200/include/mach/dtv_ioctl.h b/arch/arm/mach-mp200/include/mach/dtv_ioctl.h
new file mode 100644
index 0000000..0c1d63b
--- /dev/null
+++ b/arch/arm/mach-mp200/include/mach/dtv_ioctl.h
@@ -0,0 +1,55 @@
+
+#ifndef INCLUDE_DRIVER_DTV_H
+#define INCLUDE_DRIVER_DTV_H
+
+
+#define DTVIOCSIUNIT  _IOW('D', 0x01, int)
+#define DTVIOCGIUNIT  _IOR('D', 0x02, int*)
+
+#if 0  /* EM1 DTV supports only serial transmission.  */
+/* DTVIOCSINPUT/DTVIOCGINPUT */
+#define DTVIOCSINPUT  _IOW('D', 0x03, int)
+#define DTVIOCGINPUT  _IOR('D', 0x04, int*)
+#define DTV_INPUT_PARALLEL 0x0 /* default */
+#define DTV_INPUT_SERIAL   0x1
+#endif
+
+/* DTVIOCSPKTSZ/DTVIOCGPKTSZ */
+#define DTVIOCSPKTSZ  _IOW('D', 0x05, int)
+#define DTVIOCGPKTSZ  _IOR('D', 0x06, int*)
+#define DTV_PKTSZ_188      0x0 /* default */
+#define DTV_PKTSZ_204      0x1
+
+
+/* DTVIOCSPKTFMT/DTVIOCGPKTFMT */
+#define DTVIOCSPKTFMT _IOW('D', 0x07, int)
+#define DTVIOCGPKTFMT _IOR('D', 0x08, int*)
+#define DTV_PKTFMT_BIG     0x0
+#define DTV_PKTFMT_LITTLE  0x1 /* default */
+
+
+#define DTVIOCSSTART  _IO('D', 0x10)
+#define DTVIOCSSTOP   _IO('D', 0x11)
+#define DTVIOCSRESET  _IO('D', 0x12)
+#define DTVIOCGCOND   _IOR('D', 0x20, int*)
+
+
+/* select DTV module */
+#define DTVIOCSMODULE _IOW('D', 0x09, int)
+#define DTVIOCGMODULE _IOR('D', 0x0a, int*)
+
+#define DTV_MODULE_DTV1 0	/* use DTV1 */
+#define DTV_MODULE_DTV2 1	/* use DTV2 */
+
+
+/* set signal polarity */
+#define DTVIOCSVLDPOL   _IOW('D', 0x0b, int)
+#define DTVIOCGVLDPOL   _IOR('D', 0x0c, int*)
+#define DTVIOCSPSYNCPOL _IOW('D', 0x0d, int)
+#define DTVIOCGPSYNCPOL _IOR('D', 0x0e, int*)
+
+#define DTV_POL_NORMAL 0	/* signal normal */
+#define DTV_POL_REVERS 1	/* signal reversal */
+
+
+#endif	/* INCLUDE_DRIVER_DTV_H */
diff --git a/drivers/char/mp200_dtv.c b/drivers/char/mp200_dtv.c
new file mode 100644
index 0000000..0ec12ef
--- /dev/null
+++ b/drivers/char/mp200_dtv.c
@@ -0,0 +1,1362 @@
+/*
+ *  File Name       : mp200_dtv.c
+ *  Function        : DTV I/F Driver
+ *  Release Version : Ver 1.02
+ *  Release Date    : 2009/03/10
+ *
+ *  Copyright (C) NEC Electronics Corporation 2009
+ *
+ *
+ *  This program is free software;you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  Free Softwere Foundation; either version 2 of License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY;
+ *  without even the implied warrnty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.
+ *  See the GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program;
+ *  If not, write to the Free Software Foundation, Inc., 59 Temple
+ *  Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/poll.h>
+#include <linux/fs.h>
+#include <linux/vmalloc.h>
+#include <linux/slab.h>
+#include <linux/ctype.h>
+#include <linux/pagemap.h>
+#include <linux/delay.h>
+#ifdef CONFIG_PROC_FS
+#include <linux/proc_fs.h>
+#endif
+#include <linux/interrupt.h>
+#include <linux/dma-mapping.h>
+#include <linux/moduleparam.h>
+#include <linux/cdev.h>
+#include <linux/platform_device.h>
+#include <linux/io.h>
+#include <linux/uaccess.h>
+
+#include <asm/irq.h>
+
+
+#include <mach/pmu.h>
+#include "mp200_dtv.h"
+
+#define DTV_ERRAT
+/* #define DBG_REG_DUMP */
+/* #define DTV_DEBUG 1 */
+
+#ifdef DTV_DEBUG
+static int debug;
+module_param(debug, int, 400);
+#define DEB0(fmt, args...) \
+	printk(KERN_DEBUG "%s:%d: " fmt , __func__ , __LINE__ , ## args);
+#define DEB1(fmt, args...) \
+	if (debug == 1 || debug >= 9) {	\
+		printk(KERN_DEBUG "%s:%d: " fmt , \
+				__func__ , __LINE__ , ## args); \
+	}
+#define DEB2(fmt, args...) \
+	if (debug == 2 || debug >= 9) {	\
+		printk(KERN_DEBUG "%s:%d: " fmt , \
+				__func__ , __LINE__ , ## args); \
+	}
+#define DEB3(fmt, args...) \
+	if (debug == 3 || debug >= 9) {	\
+		printk(KERN_DEBUG "%s:%d: " fmt , \
+				__func__ , __LINE__ , ## args); \
+	}
+#define DEB8(fmt, args...)	\
+	if (debug == 8 || debug >= 9) { \
+		printk(KERN_DEBUG fmt , ## args); \
+	}
+#else
+#define DEB0(fmt, args...)
+#define DEB1(fmt, args...)
+#define DEB2(fmt, args...)
+#define DEB3(fmt, args...)
+#define DEB8(fmt, args...)
+#define FNC_ENTRY
+#endif
+#define err(format, arg...) printk(KERN_ERR format , ## arg)
+
+#define DTV_MODULE_NAME  "DTV Driver"
+#define DTV_NAME         "mp200_dtv"
+#define DTV_MAJOR        248 /* 240-254 LOCAL/EXPERIMENTAL USE */
+#ifndef CONFIG_MP200_DTV_BUFFERSIZE
+#define CONFIG_MP200_DTV_BUFFERSIZE 8192
+#endif
+
+static unsigned int buffsiz = CONFIG_MP200_DTV_BUFFERSIZE; /* default:8K */
+static char *dtv_vaddr;      /* VA */
+static dma_addr_t dtv_paddr; /* PA */
+static int dtv_opened; /* open flag */
+
+static DECLARE_MUTEX(dtv_open_sem);
+
+static struct dtv_state dtv_state_data = {
+	usr_head:0,
+	dma_head : 0,
+	use_clstrs : 0,
+	errsts : 0,
+
+	active : ACT_STOP,
+	req : 0,
+	set_flg : 0,
+
+	iunit : DEFAULT_IUNIT,
+	pktsiz : DEFAULT_PKTSIZ,
+	nb_clstrs : 0,
+	blank : 0,
+	dtv_switch : DTV_MODULE_DTV2,
+
+	lock : __SPIN_LOCK_UNLOCKED(dtv_state_data.lock),
+	dcnt : { dmacnt:DMACNT_DEFAULT},
+	siginv : {signalinvert:0},
+	mt : { 0, 0, 0, 0, 0 },
+};
+
+static inline void dtv_sft_reset(void)
+{
+	REG_DTV_MODULECONT = 0;
+	udelay(4);
+	REG_DTV_MODULECONT = MODULECONT_HW_RSTZ;
+}
+
+static inline void start_dmareq(struct dtv_state *s)
+{
+	unsigned long flags;
+
+	dtv_sft_reset();
+
+	spin_lock_irqsave(&s->lock, flags);
+	REG_DTV_DMAREQ = DMAREQ_DTV;
+	s->req = 1;
+	spin_unlock_irqrestore(&s->lock, flags);
+}
+
+
+static inline void stop_dmareq(struct dtv_state *s)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&s->lock, flags);
+	if (s->req) {
+		REG_DTV_DMASTOP = DMAREQ_DTV;
+		s->req = 0;
+	}
+	spin_unlock_irqrestore(&s->lock, flags);
+}
+
+static inline int is_dmastop(void)
+{
+	return !(REG_DTV_DMAREQ & DMAREQ_DTV);
+}
+
+static inline unsigned int get_nbclstrs(struct dtv_state *s)
+{
+	return ((buffsiz / (s->iunit * (s->pktsiz + s->blank)))
+			/ NBCLSTRS_UNIT) * NBCLSTRS_UNIT;
+}
+
+static void dtv_clockctrl_open(void)
+{
+	DEB3("\n");
+	mp200_pmu_clkctrl_off(MP200_CLKCTRL_DTVPCLK);
+	mp200_pmu_clkctrl_off(MP200_CLKCTRL_DTV);
+	mp200_pmu_open_clockgate(MP200_CLOCKGATE_DTV_PCLK);
+	mp200_pmu_open_clockgate(MP200_CLOCKGATE_DTV_CLK);
+	mp200_pmu_unreset_device(MP200_RESETDEVICE_DTV);
+	mp200_pmu_clkctrl_on(MP200_CLKCTRL_DTVPCLK);
+	mp200_pmu_clkctrl_on(MP200_CLKCTRL_DTV);
+}
+
+static void dtv_clockctrl_close(void)
+{
+	DEB3("\n");
+
+	mp200_pmu_clkctrl_off(MP200_CLKCTRL_DTV);
+	mp200_pmu_reset_device(MP200_RESETDEVICE_DTV);
+	mp200_pmu_clkctrl_on(MP200_CLKCTRL_DTV);
+	mp200_pmu_clkctrl_on(MP200_CLKCTRL_DTVPCLK);
+	mp200_pmu_close_clockgate(MP200_CLOCKGATE_DTV_CLK);
+	mp200_pmu_close_clockgate(MP200_CLOCKGATE_DTV_PCLK);
+}
+
+static void dtv_mcr_reset(void)
+{
+	DEB3("\n");
+	mp200_pmu_clkctrl_off(MP200_CLKCTRL_DTV);
+	mp200_pmu_clkctrl_off(MP200_CLKCTRL_DTVPCLK);
+	mp200_pmu_reset_device(MP200_RESETDEVICE_DTV);
+	mp200_pmu_unreset_device(MP200_RESETDEVICE_DTV);
+	mp200_pmu_clkctrl_on(MP200_CLKCTRL_DTVPCLK);
+	mp200_pmu_clkctrl_on(MP200_CLKCTRL_DTV);
+}
+
+static void dtv_buf_init(struct dtv_state *s)
+{
+	DEB3("\n");
+	s->usr_head = s->dma_head = s->use_clstrs = s->errsts = 0;
+}
+
+static void dtv_regs_set(struct dtv_state *s)
+{
+	DEB3("\n");
+
+	REG_DTV_DMACNT = s->dcnt.dmacnt;
+
+	REG_DTV_BUFSIZE = ((s->iunit * s->pktsiz * s->nb_clstrs)
+					/ (s->pktsiz + s->blank));
+
+	REG_DTV_START = dtv_paddr;
+
+	REG_DTV_BLANK = s->blank;
+
+	REG_DTV_INTCONT = s->iunit-1;
+
+	REG_DTV_ENSET = DTV_INT_ALL;
+}
+
+
+static void dtv_state_set_default(struct dtv_state *s)
+{
+	DEB3("\n");
+
+	/* buffer organization */
+	s->iunit     = DEFAULT_IUNIT;
+	s->pktsiz    = DEFAULT_PKTSIZ;
+	s->nb_clstrs = get_nbclstrs(s);
+
+	s->dcnt.dmacnt = DMACNT_DEFAULT;
+
+	s->siginv.signalinvert = 0;
+
+	s->dtv_switch = DTV_MODULE_DTV2;
+
+	dtv_buf_init(s);
+	s->active = ACT_STOP;
+	s->req = 0;
+	s->set_flg = 0;
+}
+
+static int dtv_state_init(struct dtv_state *s)
+{
+	DEB3("\n");
+
+	/* variable for kernel function */
+/*	s->lock = SPIN_LOCK_UNLOCKED; */
+	init_waitqueue_head(&s->wq);
+	init_MUTEX(&s->sem);
+
+	dtv_state_set_default(s);
+
+	return 0;
+}
+
+
+static int dtv_reset(struct dtv_state *s)
+{
+	DEB3("\n");
+
+	s->set_flg |= SETFLG_RST;
+	dtv_sft_reset();
+	dtv_mcr_reset();	/* macro reset */
+	dtv_buf_init(s);	/* init buffer status */
+	/* init dma status */
+	s->active = ACT_STOP;
+	DEB2("DMA status changed to 0x%x\n", ACT_STOP);
+
+	return 0;
+}
+
+static void dtv_set_pinmode(void)
+{
+	unsigned long flags;
+	unsigned int val = 0;
+
+	DEB3("\n");
+
+#define CHG_PINSEL_DTV (IO_ADDRESS(MP200_CHG_BASE) + 0x0284)
+#define CHG_PULL0 (IO_ADDRESS(MP200_CHG_BASE) + 0x0380)
+
+	local_irq_save(flags);
+
+	__raw_writel(0, CHG_PINSEL_DTV);
+
+	val = __raw_readl(CHG_PULL0);
+	__raw_writel(val | (0x5 << 12) | (0x5 << 8), CHG_PULL0);
+
+	local_irq_restore(flags);
+}
+
+static void dtv_unset_pinmode(void)
+{
+	DEB3("\n");
+}
+
+static int dtv_hw_init(void)
+{
+	DEB3("\n");
+
+	/* set connection mode */
+	dtv_set_pinmode();
+
+	return 0;
+}
+
+static void dtv_hw_exit(void)
+{
+	DEB3("\n");
+
+	/* release connection mode */
+	dtv_unset_pinmode();
+}
+
+
+static int dtv_wait_for_stop(void)
+{
+	unsigned int to = loops_per_jiffy/2; /* over 5ms */
+
+	DEB3("\n");
+
+	do {
+		if (is_dmastop())
+			break;
+		if (--to == 0) {
+			DEB2("Timeout!\n");
+			return -ETIME;
+		}
+	} while (1);
+
+	return 0;
+}
+
+
+
+static void dtv_active_update(struct dtv_state *s)
+{
+	DEB3("\n");
+
+	down(&s->sem);
+
+	switch (s->active) {
+	case ACT_STOP_REQ:
+		if (dtv_wait_for_stop() == 0) {
+			s->active = ACT_STOP;
+			DEB2("DMA status changed to 0x%x\n", ACT_STOP);
+		} else {
+			spin_lock_irq(&s->lock);
+			s->errsts |= ERRSTS_TIMEOUT;
+			spin_unlock_irq(&s->lock);
+		}
+		/* through */
+	case ACT_STOP:
+	case ACT_ACTIVE:
+		if (s->errsts) {
+			s->active = ACT_STOP_ERR;
+			DEB2("DMA status changed to 0x%x\n", ACT_STOP_ERR);
+		}
+		break;
+	case ACT_STOP_ERR:
+		break;
+	}
+	up(&s->sem);
+}
+
+static void dtv_dma_start(struct dtv_state *s)
+{
+	DEB3("\n");
+
+	s->set_flg &= ~(SETFLG_STOP|SETFLG_RST);
+	dtv_buf_init(s);
+	s->nb_clstrs = get_nbclstrs(s);
+	dtv_regs_set(s);
+	s->active = ACT_ACTIVE;
+	DEB2("DMA status changed to 0x%x\n", ACT_ACTIVE);
+	start_dmareq(s);
+}
+
+
+static void dtv_dma_stop(struct dtv_state *s)
+{
+	DEB3("\n");
+
+	s->set_flg |= SETFLG_STOP;
+	stop_dmareq(s); /* stop */
+	s->active = ACT_STOP_REQ;
+	DEB2("DMA status changed to 0x%x\n", ACT_STOP_REQ);
+
+	REG_DTV_ENCLR = DTV_INT_ALL;
+	REG_DTV_FFCLR = DTV_INT_ALL;
+}
+
+
+static int dtv_dma_chk_start(struct dtv_state *s)
+{
+	int ret = 0;
+	DEB3("\n");
+	DEB2("DMA status: 0x%x \n", s->active);
+
+	switch (s->active) {
+	case ACT_STOP:
+		dtv_dma_start(s);
+		break;
+	case ACT_ACTIVE:
+		break;
+	case ACT_STOP_REQ:
+	case ACT_STOP_ERR:
+		ret = -EACCES;
+		break;
+	}
+	return ret;
+}
+
+static int dtv_dma_chk_stop(struct dtv_state *s)
+{
+	int ret = 0;
+	DEB3("\n");
+	DEB2("DMA status: 0x%x \n", s->active);
+
+	switch (s->active) {
+	case ACT_ACTIVE:
+		dtv_dma_stop(s);
+
+#ifdef DTV_ERRAT
+		if ((REG_DTV_RAWSTATUS & 0x08) &&
+			(REG_DTV_DMAREQ & DMAREQ_DTV)) {
+			dtv_sft_reset();
+			dtv_buf_init(s);	/* init buffer status */
+		}
+#endif
+
+		break;
+	case ACT_STOP:
+	case ACT_STOP_REQ:
+		/* noting */
+		break;
+	case ACT_STOP_ERR:
+		ret = -EACCES;
+	}
+	return ret;
+}
+
+static void dtv_err_interrupt(struct dtv_state *s, int flag)
+{
+	DEB3("\n");
+
+	stop_dmareq(s);
+
+#ifdef DTV_ERRAT
+	if ((REG_DTV_RAWSTATUS & 0x08) && (REG_DTV_DMAREQ & DMAREQ_DTV)) {
+		dtv_sft_reset();
+		dtv_buf_init(s);	/* init buffer status */
+	}
+#endif
+
+	s->errsts |= flag; /* set error flag */
+	DEB2("errsts=0x%x \n", s->errsts);
+
+	switch (flag) {
+	case ERRSTS_DTVOR:
+		s->mt.dtvor_cnt++;
+		break;
+	case ERRSTS_DMAERR:
+		DEB2("DTV_ERRORADR=0x%x \n", REG_DTV_ERRORADR);
+		s->mt.dmaerr_addr = (REG_DTV_ERRORADR & ERRORADR_MASK);
+		REG_DTV_ERRORADR &= ~ERRORADR_LOCK;
+		s->mt.dmaerr_cnt++;
+		break;
+	case ERRSTS_BUFOR:
+		s->mt.bufor_cnt++;
+		break;
+	case ERRSTS_DTVSYNC:
+		s->mt.dtvsync_cnt++;
+		break;
+	case ERRSTS_DTVSP:
+		s->mt.dtvsp_cnt++;
+		break;
+	case ERRSTS_DTVLP:
+		s->mt.dtvlp_cnt++;
+		break;
+	}
+}
+
+static irqreturn_t dtv_callback(int irq, void *dev_id)
+{
+	struct dtv_state *s = (struct dtv_state *)dev_id;
+
+	unsigned int sts = REG_DTV_STATUS;
+	DEB3("\n");
+
+	if ((sts & DTV_INT_ALL) == 0)
+		return IRQ_HANDLED;
+
+	s->mt.intcnt++;
+	REG_DTV_FFCLR = sts;
+	DEB2("sts=0x%x, DTV_STATUS=0x%x \n", sts, REG_DTV_STATUS);
+
+	if (is_dmastop()) {
+		DEB2("ignore interrupt after DMA STOP \n");
+		return IRQ_HANDLED;
+	}
+
+	if (sts & DTV_INT_DMA) {
+		unsigned int cnt;
+		unsigned int clst;
+		unsigned int h_clst;
+		unsigned int cur = REG_DTV_CURRENT;
+
+		DEB2("DTV_CURRENT=0x%x \n", cur);
+		clst = (cur + 1) / s->iunit;
+		h_clst = s->dma_head;
+		if (clst > h_clst) {
+			cnt = clst - h_clst;
+		} else if (clst < h_clst) {
+			cnt = (s->nb_clstrs - h_clst) + clst;
+		} else {
+			DEB0("DMA Buffer Overrun error\n");
+			dtv_err_interrupt(s, ERRSTS_BUFOR);
+			goto out;
+		}
+		DEB2("Reception Clustor Number=%d, Current position=%d,"
+				" History position=%d\n", cnt, clst, h_clst);
+		while (cnt--) {
+			if (++s->dma_head >= s->nb_clstrs)
+				s->dma_head = 0;
+
+			if (++s->use_clstrs >= s->nb_clstrs) {
+				DEB2("DMA Buffer Overrun error\n");
+				dtv_err_interrupt(s, ERRSTS_BUFOR);
+				goto out;
+			}
+		}
+		DEB2("Reception Complete. use_clstrs=%d, dma_head=%d\n",
+				s->dma_head, s->use_clstrs);
+	} else if (sts & DTV_INT_OVERRUN) {
+		DEB0("DTV Overrun error\n");
+		dtv_err_interrupt(s, ERRSTS_DTVOR);
+	} else if (sts & DTV_INT_DMAERR) {
+		DEB0("DMA error\n");
+		dtv_err_interrupt(s, ERRSTS_DMAERR);
+	} else if (sts & DTV_INT_SYNCBYTE) {
+		DEB0("DTV Invalid SyncByte error\n");
+		dtv_err_interrupt(s, ERRSTS_DTVSYNC);
+	} else if (sts & DTV_INT_SHORTPACKET) {
+		DEB0("DTV Short Packet error\n");
+		dtv_err_interrupt(s, ERRSTS_DTVSP);
+	} else if (sts & DTV_INT_LONGPACKET) {
+		DEB0("DTV Long Packet error\n");
+		dtv_err_interrupt(s, ERRSTS_DTVLP);
+	}
+
+
+out:
+	wake_up_interruptible(&s->wq);
+	DEB2("wake-up\n");
+	return IRQ_HANDLED;
+}
+
+/* open */
+static int dtv_open(struct inode *inode, struct file *file)
+{
+	int ret = 0;
+	struct dtv_state *s = &dtv_state_data;
+	DEB3("\n");
+
+	down(&dtv_open_sem);
+
+	if (dtv_opened != 0) { /* multiple open */
+		ret = -EBUSY;
+		goto out;
+	}
+	dtv_hw_init();
+	dtv_clockctrl_open();
+	dtv_state_init(s);
+	dtv_sft_reset();
+
+	REG_DTV_SWITCH = s->dtv_switch;
+
+	REG_DTV_ENCLR = DTV_INT_ALL;
+	REG_DTV_FFCLR = DTV_INT_ALL;
+
+	/* dma memory allocate */
+	dtv_vaddr = dma_alloc_coherent(NULL, buffsiz, &dtv_paddr, GFP_KERNEL);
+	if (dtv_vaddr == 0) { /* error */
+		err(" dma_alloc_coherent. Couldn't get memory \n");
+		ret = -1;
+		goto out;
+	}
+	DEB2("dma_alloc_coherent() complete. size:0x%x\n", buffsiz);
+
+	/* regist irq */
+	ret = request_irq(INT_DTV, dtv_callback, IRQF_DISABLED,
+					DTV_NAME, (void *)s);
+	if (ret < 0) { /* error */
+		err("request_irq. Couldn't regist irq=%d, ret=%d\n",
+				INT_DTV, ret);
+		ret = -EBUSY;
+		dma_free_coherent(NULL, buffsiz, dtv_vaddr, dtv_paddr);
+		goto out;
+	}
+
+	file->private_data = s;
+
+	dtv_opened = 1;
+
+out:
+	up(&dtv_open_sem);
+	return ret;
+}
+
+/* release */
+static int dtv_close(struct inode *inode, struct file *file)
+{
+	struct dtv_state *s = file->private_data;
+	int ret = 0;
+	DEB3("\n");
+
+	dtv_active_update(s); /* update */
+
+	down(&dtv_open_sem);
+
+	dtv_dma_chk_stop(s);
+
+	/* dtv hardware reset */
+	dtv_reset(s);
+
+	free_irq(INT_DTV, (void *)s);
+
+	dma_free_coherent(NULL, buffsiz, dtv_vaddr, dtv_paddr);
+	DEB2("dma_free_coherent() complete. size:0x%x\n", buffsiz);
+
+	/* clock close */
+	dtv_clockctrl_close();
+	/* hardware exit */
+	dtv_hw_exit();
+
+	up(&dtv_open_sem);
+
+	dtv_opened = 0;
+
+	return ret;
+}
+
+/* read */
+static ssize_t dtv_read(struct file *file, char *buf,
+			size_t count, loff_t *ppos)
+{
+	struct dtv_state *s = file->private_data;
+	DECLARE_WAITQUEUE(wait, current);
+	ssize_t ret = 0;
+
+	unsigned int clstrsiz, errsts;
+	char *addr;
+	DEB3("\n");
+
+	clstrsiz = s->iunit * s->pktsiz;
+	if (count == 0) {
+		return 0;
+	} else if (count % clstrsiz) {
+		err("count=%d is not a Clustor unit \n", count);
+		return -EINVAL;
+	}
+
+	dtv_active_update(s);
+
+	/* access restriction */
+	if (s->active == ACT_STOP_REQ) {
+		DEB0("DMA status = 0x%x\n", ACT_STOP_REQ);
+		return -ETIME;
+	} else if (s->active == ACT_STOP_ERR) {
+		DEB0("DMA status = 0x%x\n", ACT_STOP_ERR);
+		return -EACCES;
+	}
+
+	down(&s->sem);
+	if ((s->set_flg & SETFLG_STOP) == 0) {
+		ret = dtv_dma_chk_start(s);
+		if (ret < 0) {
+			up(&s->sem);
+			return ret;
+		}
+	}
+	up(&s->sem);
+
+	add_wait_queue(&s->wq, &wait);
+
+	do {
+		set_current_state(TASK_INTERRUPTIBLE);
+		spin_lock_irq(&s->lock);
+		errsts = s->errsts;
+		s->errsts = 0;
+		spin_unlock_irq(&s->lock);
+		if (errsts) {
+			DEB2("Error status =0x%x\n", errsts);
+			s->active = ACT_STOP_ERR;
+			DEB2("DMA status changed to 0x%x\n", ACT_STOP_ERR);
+			ret = -EIO;
+			break;
+		}
+
+		down(&s->sem);
+
+		if (s->set_flg & SETFLG_RST) {
+			DEB0("can't read in a reset state\n");
+			ret = -EACCES;
+		} else {
+			while (s->use_clstrs && (count-ret)) {
+				addr = dtv_vaddr +
+					(s->iunit * s->pktsiz * s->usr_head);
+				if (copy_to_user(buf + ret, addr, clstrsiz)
+					== 0) {
+					err("failed to copy to user\n");
+					ret = -EFAULT;
+					break;
+				}
+				spin_lock_irq(&s->lock);
+				s->use_clstrs--;
+				spin_unlock_irq(&s->lock);
+				if (++s->usr_head >= s->nb_clstrs)
+					s->usr_head = 0;
+
+				DEB2("use_clstrs=0x%x, usr_head=0x%x\n",
+					s->use_clstrs, s->usr_head);
+				ret += clstrsiz;
+			}
+		}
+		up(&s->sem);
+
+		if (ret != 0)
+			break;
+
+		if (file->f_flags & (O_NONBLOCK|O_NDELAY)) {
+			ret = -EAGAIN;
+			break;
+		}
+
+		if (signal_pending(current)) {
+			ret = -ERESTARTSYS;
+			break;
+		}
+		schedule();
+	} while (1);
+	remove_wait_queue(&s->wq, &wait);
+	set_current_state(TASK_RUNNING);
+
+	return ret;
+}
+
+/* poll */
+static unsigned int dtv_poll(struct file *file, poll_table *wait)
+{
+	struct dtv_state *s = file->private_data;
+
+	DEB3("\n");
+
+	dtv_active_update(s); /* update */
+
+	poll_wait(file, &s->wq, wait);
+	if (s->errsts) {
+		DEB2("Error status =0x%x\n", s->errsts);
+		return POLLERR;
+	}
+	if (s->use_clstrs) {
+		DEB2("Received data. use_clstrs =0x%x\n", s->use_clstrs);
+		return POLLIN|POLLRDNORM;
+	}
+
+	return 0;
+}
+
+
+/* ioctl */
+static int dtv_ioctl(struct inode *inode, struct file *file,
+		unsigned int cmd, unsigned long arg)
+{
+	struct dtv_state *s = file->private_data;
+	int ret = 0, data = 0;
+	DEB3("\n");
+
+	dtv_active_update(s); /* update */
+
+	down(&s->sem);
+	/* access restriction */
+	switch (cmd) {
+	case DTVIOCSIUNIT:
+	case DTVIOCSPKTSZ:
+	case DTVIOCSPKTFMT:
+	case DTVIOCSMODULE:
+	case DTVIOCSVLDPOL:
+	case DTVIOCSPSYNCPOL:
+		if (s->use_clstrs || (s->active != ACT_STOP)) {
+			DEB2("use_clstrs=%d, active=%d \n",
+					s->use_clstrs, s->active);
+			ret = -EACCES;
+			goto out;
+		}
+		data = arg;
+		break;
+	case DTVIOCSSTART:
+		if ((s->use_clstrs || (s->active != ACT_STOP))
+			&& ((s->set_flg & SETFLG_STOP) == 0)) {
+			DEB2("use_clstrs=%d, active=%d set_flg=0x%x\n",
+			s->use_clstrs, s->active, s->set_flg);
+			ret = -EACCES;
+			goto out;
+		}
+		break;
+	default:
+		break;
+	}
+
+	switch (cmd) {
+	case DTVIOCSIUNIT:
+	{
+		DEB2("DTVIOCSIUNIT is called \n");
+		/* 1 - (buffsiz / s->pktsiz * NBCLSTRS_MIN) */
+		if (data <= 0
+			|| ((data * s->pktsiz * NBCLSTRS_MIN) > buffsiz)) {
+			DEB0("Invalid arg=%d \n", data);
+			ret = -EINVAL;
+			break;
+		}
+		s->iunit = data;
+		s->nb_clstrs = get_nbclstrs(s);
+		break;
+	}
+	case DTVIOCGIUNIT:
+	{
+		DEB2("DTVIOCGIUNIT is called \n");
+		ret = put_user(s->iunit, (int *)(arg));
+		break;
+	}
+
+
+	case DTVIOCSMODULE:
+	{
+		DEB2("DTVIOCSMODULE is called \n");
+
+		/* 0 (DTV1) or 1 (DTV2) */
+		if ((data != DTV_MODULE_DTV1)
+			&& (data != DTV_MODULE_DTV2)) {
+			DEB0("Invalid arg=%d \n", data);
+			ret = -EINVAL;
+			break;
+		}
+
+		if (s->dtv_switch == data)
+			break;
+
+		if ((s->set_flg & SETFLG_STOP) == 0)
+			dtv_dma_stop(s);
+
+		dtv_reset(s);
+		dtv_state_set_default(s);
+		s->dtv_switch  = data;
+		REG_DTV_SWITCH = s->dtv_switch;
+		REG_DTV_DMACNT = s->dcnt.dmacnt;
+		REG_DTV_ENCLR = DTV_INT_ALL;
+		REG_DTV_FFCLR = DTV_INT_ALL;
+
+		break;
+	}
+
+	case DTVIOCGMODULE:
+	{
+		DEB2("DTVIOCGMODULE is called \n");
+		ret = put_user(s->dtv_switch, (int *)(arg));
+		break;
+	}
+
+	case DTVIOCSVLDPOL:
+	{
+		DEB2("DTVIOCSVLD is called \n");
+
+		/* 0 (NORMAL) or 1 (REVERS) */
+		if ((data != DTV_POL_NORMAL)
+			&& (data != DTV_POL_REVERS)) {
+			DEB0("Invalid arg=%d \n", data);
+			ret = -EINVAL;
+			break;
+		}
+
+		if (s->dtv_switch == DTV_MODULE_DTV1) {
+			DEB0("Invalid arg=%d \n", data);
+			ret = -EINVAL;
+			break;
+		}
+
+		s->siginv.reg.vld = data;
+		REG_DTV_SIGNALINVERT = s->siginv.signalinvert;
+		break;
+	}
+
+	case DTVIOCGVLDPOL:
+	{
+		DEB2("DTVIOCGVLD is called \n");
+
+		if (s->dtv_switch == DTV_MODULE_DTV1) {
+			DEB0("Invalid arg=%d \n", data);
+			ret = -EINVAL;
+			break;
+		}
+
+		ret = put_user(s->siginv.reg.vld, (int *)(arg));
+		break;
+	}
+
+	case DTVIOCSPSYNCPOL:
+	{
+		DEB2("DTVIOCSPSYNC is called \n");
+		/* 0 (NORMAL) or 1 (REVERS) */
+		if ((data != DTV_POL_NORMAL)
+			&& (data != DTV_POL_REVERS)) {
+			DEB0("Invalid arg=%d \n", data);
+			ret = -EINVAL;
+			break;
+		}
+
+		if (s->dtv_switch == DTV_MODULE_DTV1) {
+			DEB0("Invalid arg=%d \n", data);
+			ret = -EINVAL;
+			break;
+		}
+
+		s->siginv.reg.psync = data;
+		REG_DTV_SIGNALINVERT = s->siginv.signalinvert;
+		break;
+	}
+
+	case DTVIOCGPSYNCPOL:
+	{
+		DEB2("DTVIOCGPSYNC is called \n");
+
+		if (s->dtv_switch == DTV_MODULE_DTV1) {
+			DEB0("Invalid arg=%d \n", data);
+			ret = -EINVAL;
+			break;
+		}
+
+		ret = put_user(s->siginv.reg.psync, (int *)(arg));
+		break;
+	}
+
+#if 0 /* EM1 DTV supports only serial transmission.  */
+	case DTVIOCSINPUT:
+	{
+		DEB2("DTVIOCSINPUT is called \n");
+		/* 0 (parallel) or 1 (serial) */
+		if ((data != DTV_INPUT_PARALLEL)
+			&& (data != DTV_INPUT_SERIAL)) {
+			DEB0("Invalid arg=%d \n", data);
+			ret = -EINVAL;
+			break;
+		}
+		if ((mode == DTV_CNCTMODE_SP2)
+			&& (data == DTV_INPUT_PARALLEL)) {
+			DEB0("Not support a parallel mode\n");
+			ret = -EINVAL;
+			break;
+		}
+		s->dcnt.reg.sp = data;
+		REG_DTV_DMACNT = s->dcnt.dmacnt;
+		break;
+	}
+	case DTVIOCGINPUT:
+	{
+		DEB2("DTVIOCGINPUT is called \n");
+		ret = put_user(s->dcnt.reg.sp, (int *)(arg));
+		break;
+	}
+#endif
+
+	case DTVIOCSPKTSZ:
+	{
+		unsigned int size;
+		DEB2("DTVIOCSPKTSZ is called \n");
+		/* 0 (188byte) or 1 (204byte) */
+		if ((data != DTV_PKTSZ_188) && (data != DTV_PKTSZ_204)) {
+			DEB0("Invalid arg=%d \n", data);
+			ret = -EINVAL;
+			break;
+		}
+		size = (data == DTV_PKTSZ_188) ?
+				PKT_WITHOUT_PARITY : PKT_WITH_PARITY;
+		if ((s->iunit * size * NBCLSTRS_MIN) > buffsiz) {
+			DEB0("Over a limit\n");
+			ret = -EINVAL;
+			break;
+		}
+		s->pktsiz = size;
+		s->nb_clstrs = get_nbclstrs(s);
+		s->dcnt.reg.mode = data;
+		REG_DTV_DMACNT = s->dcnt.dmacnt;
+		break;
+	}
+	case DTVIOCGPKTSZ:
+	{
+		DEB2("DTVIOCGPKTSZ is called \n");
+		ret = put_user(s->dcnt.reg.mode, (int *)(arg));
+		break;
+	}
+	case DTVIOCSPKTFMT:
+	{
+		DEB2("DTVIOCSPKTFMT is called \n");
+		/* 0 (big endian) or 1 (little endian) */
+		if ((data != DTV_PKTFMT_LITTLE) && (data != DTV_PKTFMT_BIG)) {
+			DEB0("Invalid arg=%d \n", data);
+			ret = -EINVAL;
+			break;
+		}
+		s->dcnt.reg.endian = data;
+		REG_DTV_DMACNT = s->dcnt.dmacnt;
+		break;
+	}
+	case DTVIOCGPKTFMT:
+	{
+		DEB2("DTVIOCGPKTFMT is called \n");
+		ret = put_user(s->dcnt.reg.endian, (int *)(arg));
+		break;
+	}
+	case DTVIOCSSTART:
+	{
+		DEB2("DTVIOCSSTART is called \n");
+		ret = dtv_dma_chk_start(s);
+		break;
+	}
+	case DTVIOCSSTOP:
+	{
+		DEB2("DTVIOCSSTOP is called \n");
+		ret = dtv_dma_chk_stop(s);
+		break;
+	}
+	case DTVIOCSRESET:
+	{
+		DEB2("DTVIOCSRESET is called \n");
+		if ((s->set_flg & SETFLG_STOP) == 0)
+			dtv_dma_stop(s);
+		ret = dtv_reset(s);
+		break;
+	}
+	case DTVIOCGCOND:
+	{
+		DEB2("DTVIOCGCOND is called \n");
+		ret = put_user(s->active, (int *)(arg));
+		break;
+	}
+	default:
+		DEB2("command=0x%x is not found \n", cmd);
+		ret = -EINVAL;
+	}
+
+out:
+	up(&s->sem);
+	return ret;
+}
+
+static int mp200_dtv_suspend(struct platform_device *dev, pm_message_t state)
+{
+	DEB3("\n");
+	switch (state.event) {
+	case PM_EVENT_SUSPEND:
+		if (dtv_opened != 0) {
+			DEB2("can't suspend \n");
+			return -EBUSY;
+		}
+		break;
+	}
+
+	return 0;
+
+}
+static int mp200_dtv_resume(struct platform_device *dev)
+{
+	DEB3("\n");
+
+	return 0;
+}
+
+
+static struct cdev dtv_cdev;
+static struct device *mp200_dtv_device;
+static struct platform_device *mp200_dtv_platform_device;
+static int mp200_dtv_probe(struct platform_device *dev);
+static int mp200_dtv_remove(struct platform_device *dev);
+
+static struct class *dtv_class;
+static struct device *dtv_class_dev;
+static struct platform_driver mp200_dtv_driver = {
+	.probe    = mp200_dtv_probe,
+	.remove   = mp200_dtv_remove,
+	.suspend  = mp200_dtv_suspend,
+	.resume   = mp200_dtv_resume,
+	.driver = {
+		.name  = DTV_NAME,
+		.owner = THIS_MODULE,
+	},
+};
+
+
+static struct file_operations dtv_fops = {
+	.owner    = THIS_MODULE,
+	.read     = dtv_read,
+	.ioctl    = dtv_ioctl,
+	.poll     = dtv_poll,
+	.open     = dtv_open,
+	.release  = dtv_close,
+};
+
+#ifdef CONFIG_PROC_FS
+static int dtv_read_proc(char *buf, char **start,
+				off_t offset, int count, int *eof, void *data)
+{
+	int len = 0;
+	struct dtv_state *s = &dtv_state_data;
+
+	if (offset > 0) {
+		len = 0;
+		return 0;
+	}
+
+	len += sprintf(buf + 0, "[DTV Device Driver DUMP]\n");
+	/* parameters */
+	len += sprintf(buf+len, "-------- Parameter -------- \n");
+	len += sprintf(buf+len, "* Buffer size       : 0x%x \n", buffsiz);
+	len += sprintf(buf+len, "* Clustor number    : %d \n", s->nb_clstrs);
+	len += sprintf(buf+len, "* Packet size       : %d \n", s->pktsiz);
+	len += sprintf(buf+len, "* Packet Unit number: %d \n", s->iunit);
+	len += sprintf(buf+len, "* Packet format     : %d (%s) \n",
+		s->dcnt.reg.endian,
+		((s->dcnt.reg.endian) ? "little" : "big"));
+	len += sprintf(buf+len, "* Input port        : %d (%s) \n",
+		s->dcnt.reg.sp,
+		((s->dcnt.reg.sp) ? "Serial" : "Parallel"));
+
+	/* status */
+	len += sprintf(buf+len, "-------- Running State -------- \n");
+	len += sprintf(buf+len, "* Interrupt counter     : %d \n",
+					s->mt.intcnt);
+	len += sprintf(buf+len, "* Clustor counter in use: %d \n",
+					s->use_clstrs);
+	len += sprintf(buf+len, "* DMA Status            : 0x%x \n",
+					s->active);
+	len += sprintf(buf+len, "* Set Flags             : 0x%x \n",
+					s->set_flg);
+
+	/* error status */
+	len += sprintf(buf+len, "-------- Error State -------- \n");
+	len += sprintf(buf+len, "* DMA Error counter           : %d \n",
+					s->mt.dmaerr_cnt);
+	if (s->mt.dmaerr_cnt)
+		len += sprintf(buf+len,
+			"* Last Error address          : 0x%x \n",
+			s->mt.dmaerr_addr);
+	len += sprintf(buf+len, "* DTV Overrun Error counter   : %d \n",
+					s->mt.dtvor_cnt);
+	len += sprintf(buf+len, "* Buffer Overrun Error counter: %d \n",
+					s->mt.bufor_cnt);
+	len += sprintf(buf+len, "* Invalid SyncByte Error counter: %d \n",
+					s->mt.dtvsync_cnt);
+	len += sprintf(buf+len, "* Short Packet Error counter: %d \n",
+					s->mt.dtvsp_cnt);
+	len += sprintf(buf+len, "* Long Packet Error counter: %d \n",
+					s->mt.dtvlp_cnt);
+
+	*eof = 1;
+	return len;
+}
+
+#ifdef DBG_REG_DUMP
+static int dtv_dbg_read_proc(char *buf, char **start,
+				off_t offset, int count, int *eof, void *data)
+{
+	int len = 0;
+
+	if (offset > 0) {
+		len = 0;
+		return 0;
+	}
+
+	len += sprintf(buf + 0, "[DTV Debug info]\n");
+
+	/* resisters */
+	len += sprintf(buf+len,
+		"-------- DTV I/F Registers -------- \n");
+	len += sprintf(buf+len,
+		"DT_STATUS     : 0x%08x \n", REG_DTV_STATUS);
+	len += sprintf(buf+len,
+		"DT_RAWSTATUS  : 0x%08x \n", REG_DTV_RAWSTATUS);
+	len += sprintf(buf+len,
+		"DT_ENSET      : 0x%08x \n", REG_DTV_ENSET);
+	len += sprintf(buf+len,
+		"DT_ERRORADR   : 0x%08x \n", REG_DTV_ERRORADR);
+	len += sprintf(buf+len,
+		"DT_INTCONT    : 0x%08x \n", REG_DTV_INTCONT);
+	len += sprintf(buf+len,
+		"DT_DMACNT     : 0x%08x \n", REG_DTV_DMACNT);
+	len += sprintf(buf+len,
+		"DT_DMAREQ     : 0x%08x \n", REG_DTV_DMAREQ);
+	len += sprintf(buf+len,
+		"DT_START      : 0x%08x \n", REG_DTV_START);
+	len += sprintf(buf+len,
+		"DT_BUFSIZE    : 0x%08x \n", REG_DTV_BUFSIZE);
+	len += sprintf(buf+len,
+		"DT_BLANK      : 0x%08x \n", REG_DTV_BLANK);
+	len += sprintf(buf+len,
+		"DT_CURRENT    : 0x%08x \n", REG_DTV_CURRENT);
+	len += sprintf(buf+len,
+		"DT_MODULECONT : 0x%08x \n", REG_DTV_MODULECONT);
+
+	len += sprintf(buf+len,
+		"-------- Buffer infomations -------- \n");
+	len += sprintf(buf+len,
+		"* Buffer size            : 0x%x \n", buffsiz);
+	len += sprintf(buf+len,
+		"* Buffer Virtual address : 0x%x \n",
+					(unsigned int)dtv_vaddr);
+	len += sprintf(buf+len,
+		"* Buffer Physical address: 0x%x \n", dtv_paddr);
+
+	len += sprintf(buf+len, "-------- SMU Register -------- \n");
+	len += sprintf(buf+len, "SMU_RESETREQ0  : 0x%08x \n",
+					inl(SMU_RESETREQ0));
+	len += sprintf(buf+len, "SMU_AHBCLKCTRL0: 0x%08x \n",
+					inl(SMU_AHBCLKCTRL0));
+	len += sprintf(buf+len, "SMU_APBCLKCTRL0 : 0x%08x \n",
+					inl(SMU_APBCLKCTRL0));
+	len += sprintf(buf+len, "SMU_GCLKCTRL2  : 0x%08x \n",
+					inl(SMU_GCLKCTRL2));
+
+	len += sprintf(buf+len, "-------- CHG Register -------- \n");
+	len += sprintf(buf+len, "CHG_PINSEL_DTV  : 0x%08x \n",
+					inl(CHG_PINSEL_DTV));
+	len += sprintf(buf+len, "CHG_PULL0: 0x%08x \n",
+					inl(CHG_PULL0));
+
+	*eof = 1;
+	return len;
+}
+#endif /* DBG_REG_DUMP */
+
+#endif
+
+static int mp200_dtv_probe(struct platform_device *dev)
+{
+	mp200_dtv_platform_device = dev;
+	return 0;
+}
+
+static int mp200_dtv_remove(struct platform_device *dev)
+{
+	return 0;
+}
+
+
+/* init */
+static int __init dtv_init(void)
+{
+	int error;
+
+	printk(KERN_INFO "Starting %s.\n", DTV_MODULE_NAME);
+
+
+	if (buffsiz < (1 * PKT_WITHOUT_PARITY * NBCLSTRS_MIN)) {
+		err("dtv: invalid parameter of a buffer size.[buffsiz=0x%x]\n",
+			buffsiz);
+		return -EINVAL;
+	}
+
+	error = register_chrdev_region(MKDEV(DTV_MAJOR, 0), 1, "dtv");
+	if (error) {
+		err("dtv: unable to register_chrdev_region");
+		return -EIO;
+	}
+
+	cdev_init(&dtv_cdev, &dtv_fops);
+	dtv_cdev.owner = THIS_MODULE;
+	kobject_set_name(&dtv_cdev.kobj, "dtv");
+	error = cdev_add(&dtv_cdev, MKDEV(DTV_MAJOR, 0), 1);
+	if (error) {
+		err("dtv: unable to add char device");
+		goto unregist_chrdev;
+	}
+
+	dtv_class = class_create(THIS_MODULE, "dtv");
+	if (IS_ERR(dtv_class)) {
+		err("dtv: Error creating dtv class.\n");
+		dtv_class = 0;
+		goto error_cdev_del;
+	}
+
+	platform_driver_register(&mp200_dtv_driver);
+
+	dtv_class_dev = device_create_drvdata(dtv_class, mp200_dtv_device,
+					MKDEV(DTV_MAJOR, 0), NULL, "%s", "dtv");
+
+	if (IS_ERR(dtv_class_dev)) {
+		printk(KERN_ERR "Error creating dtv device class.\n");
+		goto error_class_destroy;
+	}
+
+#ifdef CONFIG_PROC_FS
+	/* create proc entry */
+	create_proc_read_entry("driver/dtv", 0, 0, dtv_read_proc, 0);
+#ifdef DBG_REG_DUMP
+	create_proc_read_entry("driver/dtv_dbg", 0, 0, dtv_dbg_read_proc, 0);
+#endif /* DBG_REG_DUMP */
+#endif
+
+	return 0;
+
+error_class_destroy:
+	platform_driver_unregister(&mp200_dtv_driver);
+	class_destroy(dtv_class);
+	dtv_class = 0;
+error_cdev_del:
+	cdev_del(&dtv_cdev);
+unregist_chrdev:
+	unregister_chrdev_region(MKDEV(DTV_MAJOR, 0), 1);
+
+	return -EIO;
+}
+
+/* exit */
+static void __exit dtv_exit(void)
+{
+	DEB3("\n");
+
+#ifdef CONFIG_PROC_FS
+	remove_proc_entry("driver/dtv", 0);
+#ifdef DBG_REG_DUMP
+	remove_proc_entry("driver/dtv_dbg", 0);
+#endif /* DBG_REG_DUMP */
+#endif
+	device_destroy(dtv_class, MKDEV(DTV_MAJOR, 0));
+	platform_driver_unregister(&mp200_dtv_driver);
+	class_destroy(dtv_class);
+	dtv_class = 0;
+	cdev_del(&dtv_cdev);
+	unregister_chrdev_region(MKDEV(DTV_MAJOR, 0), 1);
+}
+
+module_init(dtv_init);
+module_exit(dtv_exit);
+
+/* module parameter */
+module_param(buffsiz, uint, 0400); /* buffer size */
+
+MODULE_AUTHOR("NIS");
+MODULE_DESCRIPTION(DTV_MODULE_NAME);
+MODULE_LICENSE("GPL");
+
+
diff --git a/drivers/char/mp200_dtv.h b/drivers/char/mp200_dtv.h
new file mode 100644
index 0000000..d8f684c
--- /dev/null
+++ b/drivers/char/mp200_dtv.h
@@ -0,0 +1,151 @@
+
+
+#ifndef MP200_DTV_H
+#define MP200_DTV_H
+
+#include <mach/pmu.h>
+#include <mach/smu.h>
+#include <mach/dtv_ioctl.h>
+
+
+
+/* DTV_DMACONT */
+#define DMACNT_BUS_SERIAL         0x00000004 /* serial bus */
+#define DMACNT_BUS_PARALLEL       0x00000000 /* parallel bus */
+#define DMACNT_PKT_WITH_PARITY    0x00000002 /* 204bytes */
+#define DMACNT_PKT_WITHOUT_PARITY 0x00000000 /* 188bytes(default) */
+#define DMACNT_ENDIAN_LITTLE      0x00000001 /* little endian(default) */
+#define DMACNT_ENDIAN_BIG         0x00000000 /* big endian */
+#define DMACNT_DEFAULT (DMACNT_BUS_SERIAL | \
+		DMACNT_PKT_WITHOUT_PARITY | DMACNT_ENDIAN_LITTLE)
+/* DTV_DMAREQ / DTV_DMASTOP */
+#define DMAREQ_DTV               0x00000001
+/* DTV_MODCONT */
+#define MODULECONT_HW_RSTZ       0x00000001
+/* DTV_STATUS / DTV_RAWSTATUS / DTV_ENSET / DTV_ENCLR / DTV_FFCLR */
+
+
+#define DTV_INT_LONGPACKET       0x00000040
+#define DTV_INT_SHORTPACKET      0x00000020
+#define DTV_INT_SYNCBYTE         0x00000010
+#define DTV_INT_OVERRUN          0x00000004
+#define DTV_INT_DMA              0x00000002
+#define DTV_INT_DMAERR           0x00000001
+#define DTV_INT_ALL (DTV_INT_OVERRUN|DTV_INT_DMA|DTV_INT_DMAERR| \
+		DTV_INT_LONGPACKET|DTV_INT_SHORTPACKET|DTV_INT_SYNCBYTE)
+/* DTV_ERRORADR */
+#define ERRORADR_LOCK            0x00000001
+#define ERRORADR_MASK            0xFFFFFFFC
+/* .pktsiz */
+#define PKT_WITH_PARITY          204
+#define PKT_WITHOUT_PARITY       188
+/* .active */
+#define ACT_STOP        0x00 /* stop complete */
+#define ACT_ACTIVE      0x01 /* running */
+#define ACT_STOP_REQ    0x02 /* during a stop request */
+#define ACT_STOP_ERR    0x03 /* error stop */
+/* .errsts */
+#define ERRSTS_DTVOR    0x01 /* DTV FIFO Overrun */
+#define ERRSTS_DMAERR   0x02 /* DMA Error */
+#define ERRSTS_BUFOR    0x04 /* DMA Buffer Overrun */
+#define ERRSTS_TIMEOUT  0x08 /* DMA Stop Timeout */
+#define ERRSTS_DTVSYNC  0x10
+#define ERRSTS_DTVSP    0x20
+#define ERRSTS_DTVLP    0x40
+
+/* .iunit */
+#define DEFAULT_IUNIT     8
+#define DEFAULT_PKTSIZ    PKT_WITHOUT_PARITY /* 188byte */
+/* .nb_clstrs */
+#define NBCLSTRS_UNIT     4 /* Cluster Unit */
+#define NBCLSTRS_MIN      4 /* Minimum Number of cluster */
+/* usr flag */
+#define SETFLG_STOP 0x01
+#define SETFLG_RST  0x02
+
+/* DTV Registers */
+#define DTV_ADDR	IO_ADDRESS(MP200_DTV_BASE)
+#define DTV_REG(OFF) \
+	(*(unsigned int volatile*)((unsigned char *)(DTV_ADDR) + OFF))
+
+#define REG_DTV_STATUS			DTV_REG(0x0000)
+#define REG_DTV_RAWSTATUS		DTV_REG(0x0004)
+#define REG_DTV_ENSET			DTV_REG(0x0008)
+#define REG_DTV_ENCLR			DTV_REG(0x000C)
+#define REG_DTV_FFCLR			DTV_REG(0x0010)
+#define REG_DTV_ERRORADR		DTV_REG(0x0014)
+#define REG_DTV_DMACNT			DTV_REG(0x0020)
+#define REG_DTV_DMAREQ			DTV_REG(0x0024)
+#define REG_DTV_DMASTOP			DTV_REG(0x0028)
+#define REG_DTV_START			DTV_REG(0x002C)
+#define REG_DTV_BUFSIZE			DTV_REG(0x0030)
+#define REG_DTV_BLANK			DTV_REG(0x0034)
+#define REG_DTV_CURRENT			DTV_REG(0x0038)
+#define REG_DTV_INTCONT			DTV_REG(0x003C)
+#define REG_DTV_MODULECONT		DTV_REG(0x0040)
+#define REG_DTV_SIGNALINVERT	DTV_REG(0x0044)
+#define REG_DTV_MONITOR			DTV_REG(0x0048)
+#define REG_DTV_SWITCH			DTV_REG(0x0200)
+
+
+union dtv_dmacnt {
+	u_int dmacnt;
+	struct {
+		u_char endian : 1; /* bit 0 */
+		u_char mode : 1;   /* bit 1 */
+		u_char sp : 1;     /* bit 2 */
+		u_int:29;       /* bit 31-4 */
+	} reg;
+};
+
+union dtv_signalinvert {
+	u_int signalinvert;
+	struct {
+		u_char vld : 1;   /* bit 0 */
+		u_char psync : 1; /* bit 1 */
+		u_int:30;      /* bit 31-2 */
+	} reg;
+};
+
+
+/* monitor */
+struct dtv_monitor {
+	u_int intcnt;      /* interrupt count */
+	u_int dmaerr_addr; /* dma error address */
+	u_int dmaerr_cnt;  /* dma error count */
+	u_int dtvor_cnt;   /* dtv fifo overrun count */
+	u_int bufor_cnt;   /* buffer overrun count */
+	u_int dtvsync_cnt; /* invalid SyncByte count */
+	u_int dtvsp_cnt;   /* short packet count */
+	u_int dtvlp_cnt;   /* long packet count */
+};
+
+
+
+struct dtv_state {
+	u_int usr_head;                 /* user index */
+	u_int dma_head;                 /* dma index */
+	u_int use_clstrs;               /* used cluster number */
+	u_int errsts;                   /* error status */
+	int active;                     /* dma status */
+
+	int req;                        /* dma request flag */
+	u_int set_flg;                  /* user flag */
+
+	int iunit;                      /* input unit size */
+	u_int pktsiz;                   /* packet size */
+	u_int nb_clstrs;                /* cluster number */
+	u_int blank;                    /* blank size */
+	u_int dtv_switch;               /* module switch */
+
+	spinlock_t lock;                /* lock */
+	wait_queue_head_t wq;           /* wait queue */
+	struct semaphore sem;           /* semaphore */
+
+	union dtv_dmacnt dcnt;          /* cont register info */
+	union dtv_signalinvert siginv;  /* signal polarity info */
+	struct dtv_monitor mt;          /* monitor info */
+};
+
+
+#endif	/* MP200_DTV_H */
-- 
1.6.5.2

