From 761b58f40db4be885703201348d5d746f6ca1c24 Mon Sep 17 00:00:00 2001
From: Kazuya Tsukamoto <kazuya.tsukamoto@necel.com>
Date: Mon, 9 Nov 2009 15:15:12 +0900
Subject: [PATCH 28/29] nec_em1: add pcm driver

Add an ALSA based PCM driver and control audio codec (AK4648).

Signed-off-by: Kazuya Tsukamoto <kazuya.tsukamoto@necel.com>
---
 include/sound/mp200_pcm_ioctl.h |   81 ++
 sound/arm/Kconfig               |    8 +
 sound/arm/Makefile              |    3 +
 sound/arm/mp200-mixer.c         | 1574 +++++++++++++++++++++++++++++++++++++
 sound/arm/mp200-mixer.h         |  205 +++++
 sound/arm/mp200-pcm.c           | 1623 +++++++++++++++++++++++++++++++++++++++
 sound/arm/mp200-pcm.h           |  107 +++
 7 files changed, 3601 insertions(+), 0 deletions(-)
 create mode 100644 include/sound/mp200_pcm_ioctl.h
 create mode 100644 sound/arm/mp200-mixer.c
 create mode 100644 sound/arm/mp200-mixer.h
 create mode 100644 sound/arm/mp200-pcm.c
 create mode 100644 sound/arm/mp200-pcm.h

diff --git a/include/sound/mp200_pcm_ioctl.h b/include/sound/mp200_pcm_ioctl.h
new file mode 100644
index 0000000..10177a8
--- /dev/null
+++ b/include/sound/mp200_pcm_ioctl.h
@@ -0,0 +1,81 @@
+/*
+ *  File Name	    : include/sound/mp200_pcm_ioctl.h
+ *  Function	    : audio interface for the MP200
+ *  Release Version : Ver 1.01
+ *  Release Date    : 2009/11/06
+ *
+ *  Copyright (C) NEC Electronics Corporation 2007,2008,2009
+ *
+ *
+ * This program is free software;you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by Free Softwere
+ * Foundation; either version 2 of License, or (at your option) any later
+ * version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warrnty of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
+ * details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; If not, write to the Free Software Foundation, Inc., 59 Temple
+ * Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#ifndef __SOUND_MP200_PCM_IOCTL_H
+#define __SOUND_MP200_PCM_IOCTL_H
+
+#include <linux/ioctl.h>
+
+/* mode_sel : Operation mode */
+#define PCM_MODE_0              0       /* mode 0 */
+#define PCM_MODE_1              1       /* mode 1 */
+#define PCM_MODE_2              2       /* mode 2 (I2S Format) */
+#define PCM_MODE_3              3       /* mode 3 (MSB First)  */
+#define PCM_MODE_4              4       /* mode 4 (LSB First)  */
+#define PCM_MODE_5              5       /* mode 5 (Multi Channel Mode) */
+#define PCM_MODE_6              6       /* mode 6 (Multi Channel Mode) */
+
+/* m_s : Master/Slave */
+#define PCM_MASTER_MODE         0       /* Master */
+#define PCM_SLAVE_MODE          1       /* Slave  */
+
+/* tx_tim : Transmission timing */
+#define PCM_TX_30_WORD          0       /* 30word */
+#define PCM_TX_16_WORD          1       /* 16word */
+#define PCM_TX_08_WORD          2       /*  8word */
+#define PCM_TX_04_WORD          3       /*  4word */
+
+/* rx_pd : Data padding (RX) */
+/* tx_pd : Data padding (TX) */
+#define PCM_PADDING_OFF         0       /* Data padding non */
+#define PCM_PADDING_ON          1       /* Data padding */
+
+
+struct pcm_ctrl {
+	struct func_sel {
+		unsigned char mode_sel; /* Operation mode */
+		unsigned char m_s;      /* Master/Slave */
+		unsigned char tx_tim;   /* Transmission timing */
+	} func;
+	struct cycle {
+		unsigned char cyc_val;  /* Frame length */
+		unsigned char sib;      /* Data bit length (PMx_SI) */
+		unsigned char rx_pd;    /* Data padding (RX) */
+		unsigned char sob;      /* Data bit length (PMx_SO) */
+		unsigned char tx_pd;    /* Data padding (TX) */
+	} cyc;
+	struct cycle2 {
+		unsigned char cyc_val2; /* Frame length */
+		unsigned char sib2;     /* Data bit length (PMx_SI) */
+		unsigned char sob2;     /* Data bit length (PMx_SO) */
+	} cyc2;
+};
+#define pcm_ctrl_t	struct pcm_ctrl
+
+#define SNDRV_MP200_IOCTL_PCM_SET_CTRL  _IOW('H', 0x11, pcm_ctrl_t)
+#define SNDRV_MP200_IOCTL_PCM_GET_CTRL  _IOR('H', 0x12, pcm_ctrl_t)
+
+#endif  /* __SOUND_MP200_PCM_IOCTL_H */
+
diff --git a/sound/arm/Kconfig b/sound/arm/Kconfig
index 06a24df..9748f2f 100644
--- a/sound/arm/Kconfig
+++ b/sound/arm/Kconfig
@@ -11,6 +11,14 @@ menuconfig SND_ARM
 
 if SND_ARM
 
+config SND_MP200
+	tristate "mp200 audio driver"
+	depends on ARCH_MP200 && SND
+	select SND_PCM
+	select SND_HWDEP
+	help
+	  Say Y here if you have a audio & voice on mp200 chip.
+
 config SND_SA11XX_UDA1341
 	tristate "SA11xx UDA1341TS driver (iPaq H3600)"
 	depends on ARCH_SA1100 && L3
diff --git a/sound/arm/Makefile b/sound/arm/Makefile
index bd12f53..6842c26 100644
--- a/sound/arm/Makefile
+++ b/sound/arm/Makefile
@@ -2,6 +2,9 @@
 # Makefile for ALSA
 #
 
+obj-$(CONFIG_SND_MP200) += snd-mp200.o
+snd-mp200-objs := mp200-mixer.o mp200-pcm.o
+
 obj-$(CONFIG_SND_SA11XX_UDA1341) += snd-sa11xx-uda1341.o 
 snd-sa11xx-uda1341-objs		:= sa11xx-uda1341.o
 
diff --git a/sound/arm/mp200-mixer.c b/sound/arm/mp200-mixer.c
new file mode 100644
index 0000000..12703d7
--- /dev/null
+++ b/sound/arm/mp200-mixer.c
@@ -0,0 +1,1574 @@
+/*
+ * linux/sound/mp200-mixer.c -- sound codec support for mp200 chip.
+ *
+ * Created:	Oct 09, 2006
+ *
+ */
+#include <linux/errno.h>
+#include <linux/i2c.h>
+#include <linux/gpio.h>
+#include <linux/io.h>
+#include <mach/pwc.h>
+#include <mach/smu.h>
+#include <sound/core.h>
+#include <sound/control.h>
+#include <sound/pcm.h>
+#include <sound/initval.h>
+
+#ifdef CONFIG_PM
+#include <linux/pm.h>
+#endif
+
+#include "mp200-mixer.h"
+#include "mp200-pcm.h"
+
+/* static initial value */
+#define ID_VALUE		NULL
+#define I2C_CODEC_CLIENT_VALUE	NULL;
+
+#include <linux/delay.h>
+
+#define CODEC_WRITE(a, d, m)    i2c_codec_write(a, d, m)
+
+#define TYPE_VOL        0x01
+#define TYPE_SW         0x02
+#define TYPE_BL         0x04
+
+#define IDX(a)  (a & 0xffff)
+
+/* VOL(integer) */
+enum {
+	MIXER_VOL_PLAYBACK = TYPE_VOL << 16 | 0x0000,
+	MIXER_VOL_CAPTURE,
+
+	MIXER_INT_NUM = IDX(MIXER_VOL_CAPTURE) + 1,
+};
+
+/* SW (enum) */
+enum {
+	MIXER_SW_CAPTURE_SOURCE = TYPE_SW << 16 | 0x0000,
+	MIXER_SW_CAPTURE_CHANNEL_MODE,
+	MIXER_SW_SAMPLING_RATE,
+	MIXER_SW_PLAYBACK,
+
+	MIXER_ENUM_NUM = IDX(MIXER_SW_PLAYBACK) + 1,
+};
+
+/* SW (boolean) */
+enum {
+	MIXER_SW_CODEC_POWER_BL = TYPE_BL << 16 | 0x0000,
+
+	MIXER_BL_NUM = IDX(MIXER_SW_CODEC_POWER_BL) + 1,
+};
+
+static const char *in_sw_control_texts[] = {
+	"MIC", "Line"
+};
+
+static const char *pmad_sw_control_texts[] = {
+	"Stereo", "Mono Lch", "Mono Rch", "MIX"
+};
+
+static const char *fs_sw_control_texts[] = {
+	"7.35kHz", "8kHz", "11.025kHz", "12kHz", "14.7kHz", "16kHz",
+	"22.05kHz", "24kHz", "29.4kHz", "32kHz", "44.1kHz", "48kHz"
+};
+
+static const char *out_sw_control_texts[] = {
+	"Line", "Headphone"
+};
+
+struct integer_info {
+	unsigned int count;     /* count of values */
+	long val_int_min;       /* R: minimum value */
+	long val_int_max;       /* R: maximum value */
+	long val_int_step;      /* R: step (0 variable) */
+	int value[2];
+};
+
+struct enum_info {
+	char **texts;
+	unsigned int items;
+	int value;
+};
+
+struct boolean_info {
+	int value;
+};
+
+struct mp200_codec_mixer {
+	struct snd_card *card;
+	spinlock_t mixer_lock;
+	struct integer_info *vol_info;
+	struct enum_info *enum_info;
+	struct boolean_info *bl_info;
+	int power_on;
+	struct mutex power_mutex;
+};
+
+static struct integer_info volume_info[MIXER_INT_NUM] = {
+	{ /* MIXER_VOL_PLAYBACK */
+		.count = 2,
+		.val_int_min = 0,
+		.val_int_max = 100,
+		.val_int_step = 1,
+	},
+	{ /* MIXER_VOL_CAPTURE */
+		.count = 2,
+		.val_int_min = 0,
+		.val_int_max = 100,
+		.val_int_step = 1,
+	},
+};
+
+#define NUM_OF(v) (sizeof(v) / sizeof(v[0]))
+static struct enum_info enum_info[MIXER_ENUM_NUM] = {
+	{ /* MIXER_SW_CAPTURE_SOURCE */
+		.texts = (char **)in_sw_control_texts,
+		.items = NUM_OF(in_sw_control_texts),
+	},
+	{ /* MIXER_SW_CAPTURE_CHANNEL_MODE */
+		.texts = (char **)pmad_sw_control_texts,
+		.items = NUM_OF(pmad_sw_control_texts),
+	},
+	{ /* MIXER_SW_SAMPLING_RATE */
+		.texts = (char **)fs_sw_control_texts,
+		.items = NUM_OF(fs_sw_control_texts),
+	},
+	{ /* MIXER_SW_PLAYBACK */
+		.texts = (char **)out_sw_control_texts,
+		.items = NUM_OF(out_sw_control_texts),
+	},
+};
+
+static struct boolean_info boolean_info[MIXER_BL_NUM];
+
+static struct mp200_codec_mixer codec_mixer = {
+	.vol_info = &volume_info[0],
+	.enum_info = &enum_info[0],
+	.bl_info = &boolean_info[0],
+	.power_on = 0, /* off */
+};
+
+static pcm_ctrl_t pcm_sett = {
+#ifdef MP200_PCM_USE_PDMA
+	.func = {
+		.mode_sel       = PCM_MODE_3,
+		.m_s            = PCM_SLAVE_MODE,
+		.tx_tim         = PCM_TX_04_WORD,
+		},
+	.cyc = {
+		.cyc_val        = 0x1f,
+		.sib            = 0x1f,
+		.rx_pd          = PCM_PADDING_ON,
+		.sob            = 0x1f,
+		.tx_pd          = PCM_PADDING_ON,
+		},
+	.cyc2 = {
+		.cyc_val2       = 0x1f,
+		.sib2           = 0x1f,
+		.sob2           = 0x1f,
+		},
+#else
+	.func = {
+		.mode_sel       = PCM_MODE_3,
+		.m_s            = PCM_SLAVE_MODE,
+		.tx_tim         = PCM_TX_04_WORD,
+		},
+	.cyc = {
+		.cyc_val        = 0x0f,
+		.sib            = 0x0f,
+		.rx_pd          = PCM_PADDING_ON,
+		.sob            = 0x0f,
+		.tx_pd          = PCM_PADDING_ON,
+		},
+	.cyc2 = {
+		.cyc_val2       = 0x0f,
+		.sib2           = 0x0f,
+		.sob2           = 0x0f,
+		},
+#endif
+};
+
+/* Local prototypes */
+static unsigned char i2c_codec_reg[AK4648REG_MAX];
+static int codec_i2c_probe(struct i2c_client *client,
+ const struct i2c_device_id *id);
+static int codec_i2c_remove(struct i2c_client *client);
+
+static struct i2c_device_id codec_i2c_idtable[] = {
+	{ "ak4648", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, codec_i2c_idtable);
+
+static struct i2c_driver i2c_codec_driver = {
+	.driver.name    = "i2c for codec",
+	.id             = I2C_DRIVERID_I2CDEV, /* Fake ID */
+	.id_table       = codec_i2c_idtable,
+	.probe          = codec_i2c_probe,
+	.remove         = codec_i2c_remove,
+};
+static struct i2c_client *i2c_codec_client = I2C_CODEC_CLIENT_VALUE;
+
+
+/*
+ * i2c functions
+ */
+static int codec_i2c_probe(struct i2c_client *client,
+ const struct i2c_device_id *id)
+{
+	i2c_codec_client = client;
+	return 0;
+}
+
+static int codec_i2c_remove(struct i2c_client *client)
+{
+	i2c_codec_client = NULL;
+	return 0;
+}
+
+static int i2c_codec_cleanup(void)
+{
+	i2c_del_driver(&i2c_codec_driver);
+	return 0;
+}
+
+static int i2c_codec_inserted(void)
+{
+	return i2c_add_driver(&i2c_codec_driver);
+}
+
+static int i2c_codec_init(void)
+{
+	int res = 0;
+	unsigned char reg = 0;
+
+	res = i2c_codec_inserted();
+	if (res == 0) {
+		if (i2c_codec_client == NULL) {
+			i2c_codec_cleanup();
+			printk(KERN_ERR "codec_i2c_found_proc() not called!\n");
+			return -EIO;
+		}
+		res = i2c_master_send(i2c_codec_client, &reg, 1);
+		if (res > 0) {
+			res =
+				i2c_master_recv(i2c_codec_client, i2c_codec_reg,
+						AK4648REG_MAX);
+			if (res > 0)
+				res = 0;
+
+		}
+		if (res != 0) {
+			i2c_codec_cleanup();
+			printk(KERN_ERR "send or recv failed!\n");
+		}
+	} else {
+		printk(KERN_ERR "i2c codec inserted failed!\n");
+	}
+
+	return res;
+}
+
+static int i2c_codec_write(unsigned char reg, unsigned char data,
+			   unsigned char mask)
+{
+	int res = 0;
+	unsigned char buf[2];
+
+	if ((AK4648REG_MAX <= reg) || ((data & ~(mask)) != 0))
+		return -EINVAL;
+
+	data = (i2c_codec_reg[reg] & ~(mask)) | (data & mask);
+
+	i2c_codec_reg[reg] = data;
+
+	buf[0] = reg;
+	buf[1] = data;
+
+	res = i2c_master_send(i2c_codec_client, buf, 2);
+	if (res > 0)
+		res = 0;
+	else
+		printk(KERN_ERR "i2c codec write failed!\n");
+
+	return res;
+}
+
+
+static int codec_init(void)
+{
+	struct mp200_codec_mixer *codec = &codec_mixer;
+	int i, j;
+
+	/* volume(integer) */
+	for (i = 0; i < MIXER_INT_NUM; i++) {
+		for (j = 0; j < (codec->vol_info[IDX(i)].count); j++) {
+			/* 80 */
+			codec->vol_info[IDX(i)].value[j] = 80;
+		}
+	}
+
+	/* switch control(enum) */
+	/* MIC */
+	codec->enum_info[IDX(MIXER_SW_CAPTURE_SOURCE)].value = 0;
+	/* Stereo */
+	codec->enum_info[IDX(MIXER_SW_CAPTURE_CHANNEL_MODE)].value = 0;
+	/* 8kHz */
+	codec->enum_info[IDX(MIXER_SW_SAMPLING_RATE)].value = 1;
+	/* Line */
+	codec->enum_info[IDX(MIXER_SW_PLAYBACK)].value = 0;
+
+	/* switch control(boolean) */
+	/* "OFF" */
+	codec->bl_info[IDX(MIXER_SW_CODEC_POWER_BL)].value = 0;
+
+	return 0;
+}
+
+static int codec_power_on(void)
+{
+	struct mp200_codec_mixer *codec = &codec_mixer;
+	int res = 0;
+	int power_value = 0;
+
+	power_value = codec->bl_info[IDX(MIXER_SW_CODEC_POWER_BL)].value;
+	codec_init();
+	codec->bl_info[IDX(MIXER_SW_CODEC_POWER_BL)].value = power_value;
+
+	mutex_lock(&codec->power_mutex);
+	if (codec->power_on) {
+		mutex_unlock(&codec->power_mutex);
+		return 0;
+	}
+
+	/* CHG_PINSEL_REFCLK0 : REFCLKO(D1-0) */
+	outl(0x0, CHG_PINSEL_REFCLK0);
+	/* CHG_CTRL_OSC : OSC_EN(D0) */
+	outl(0x1, CHG_CTRL_OSC);
+#ifndef CONFIG_MP200_EM1_DKIT
+#if 0
+	/* 5T735:VGP5SET(3.1V) VOUTSET3 D4 */
+	pwc_write(PWC_VOUTSET3, 0x10, 0x10);
+	/* 5T735:PSCNTGP5("REGGP5" -> "ON") PSCNT2 D3 */
+	pwc_write(PWC_PSCNT2, 0x08, 0x08);
+	udelay(500);
+#endif
+	/* codec CSN/CAD0 pin "L" */
+	/* SNDCDA CODEC I2C addr 5T735:GPIO8 IOOUT2 D0 */
+	gpio_set_value(GPIO_SNDCDA, 0);
+	/* codec PDN pin "L" -> "H" */
+	gpio_set_value(GPIO_SNDCDA, 1);
+#endif
+	/* SNDPDN CODEC Reset 5T735:GPIO9 IOOUT2 D1 */
+	gpio_set_value(GPIO_SNDPDN, 1);
+	/* PDN pin "L" needs 150ns */
+
+	res = i2c_codec_init();
+	if (res != 0)
+		goto err1;
+
+	/* Clock Set Up Sequence */
+	/* M_S */
+	res = CODEC_WRITE(AK4648REG_POWER_MANAGEMENT_2,
+			       AK4648BIT_M_S, AK4648BIT_M_S);
+	if (res < 0)
+		goto err1;
+	/* PLL BCKO DIF */
+#ifdef MP200_PCM_USE_PDMA
+ #if 1  /* PLL mode 11.2896MHz */
+	res = CODEC_WRITE(AK4648REG_MODE_CONTROL_1,
+	 (AK4648BIT_PLL2 | AK4648BIT_DIF1 | AK4648BIT_BCKO),
+	 (AK4648BIT_PLL_MASK | AK4648BIT_BCKO | AK4648BIT_DIF_MASK));
+ #else  /* PLL mode 12MHz */
+	res = CODEC_WRITE(AK4648REG_MODE_CONTROL_1,
+	 (AK4648BIT_PLL2 | AK4648BIT_PLL1 | AK4648BIT_DIF1 | AK4648BIT_BCKO),
+	 (AK4648BIT_PLL_MASK | AK4648BIT_BCKO |
+	  AK4648BIT_DIF_MASK));
+ #endif
+#else
+ #if 1  /* PLL mode 11.2896MHz */
+	res = CODEC_WRITE(AK4648REG_MODE_CONTROL_1,
+			(AK4648BIT_PLL2 | AK4648BIT_DIF1),
+			(AK4648BIT_PLL_MASK | AK4648BIT_DIF_MASK));
+ #else  /* PLL mode 12MHz */
+	res = CODEC_WRITE(AK4648REG_MODE_CONTROL_1,
+	 (AK4648BIT_PLL2 | AK4648BIT_PLL1 | AK4648BIT_DIF1 | AK4648BIT_BCKO),
+	 (AK4648BIT_PLL_MASK | AK4648BIT_BCKO | AK4648BIT_DIF_MASK));
+ #endif
+#endif
+	if (res < 0)
+		goto err1;
+	/* FS */
+	res = CODEC_WRITE(AK4648REG_MODE_CONTROL_2,
+			       AK4648BIT_FS_8KHZ, AK4648BIT_FS_MASK);
+	if (res < 0)
+		goto err1;
+	/* PMVCM */
+	res = CODEC_WRITE(AK4648REG_POWER_MANAGEMENT_1,
+			       AK4648BIT_PMVCM, AK4648BIT_PMVCM);
+	if (res < 0)
+		goto err1;
+	/* PMPLL */
+	res = CODEC_WRITE(AK4648REG_POWER_MANAGEMENT_2,
+			       AK4648BIT_PMPLL, AK4648BIT_PMPLL);
+	if (res < 0)
+		goto err1;
+	schedule_timeout_uninterruptible(AK4648_WAIT_PLL_LOCK);
+
+	/* Stereo Lineout Sequence */
+	/* DACL */
+	res = CODEC_WRITE(AK4648REG_SIGNAL_SELECT_1,
+			       AK4648BIT_DACL, AK4648BIT_DACL);
+	if (res < 0)
+		goto err1;
+	/* IVL */
+	res = CODEC_WRITE(AK4648REG_LCH_INPUT_VOLUME_CONTROL,
+			       0x91, AK4648_INPUT_VOL_MAX);
+	if (res < 0)
+		goto err1;
+	/* IVR */
+	res = CODEC_WRITE(AK4648REG_RCH_INPUT_VOLUME_CONTROL,
+			       0x91, AK4648_INPUT_VOL_MAX);
+	if (res < 0)
+		goto err1;
+	/* DVL */
+	res = CODEC_WRITE(AK4648REG_LCH_DIGITAL_VOLUME_CONTROL,
+			       ((AK4648_OUTPUT_VOL_MAX * (100 - 80)) / 100),
+			       AK4648_OUTPUT_VOL_MAX);
+	if (res < 0)
+		goto err1;
+	/* DVR */
+	res = CODEC_WRITE(AK4648REG_RCH_DIGITAL_VOLUME_CONTROL,
+			       ((AK4648_OUTPUT_VOL_MAX * (100 - 80)) / 100),
+			       AK4648_OUTPUT_VOL_MAX);
+	if (res < 0)
+		goto err1;
+	/* DVOLC */
+	res = CODEC_WRITE(AK4648REG_MODE_CONTROL_3,
+			       0x00, AK4648BIT_DVOLC);
+	if (res < 0)
+		goto err1;
+	/* LOPS */
+	res = CODEC_WRITE(AK4648REG_SIGNAL_SELECT_2,
+			       AK4648BIT_LOPS, AK4648BIT_LOPS);
+	if (res < 0)
+		goto err1;
+	/* PMLO PMDAC */
+	res = CODEC_WRITE(AK4648REG_POWER_MANAGEMENT_1,
+			       (AK4648BIT_PMLO | AK4648BIT_PMDAC),
+			       (AK4648BIT_PMLO | AK4648BIT_PMDAC));
+	if (res < 0)
+		goto err1;
+	schedule_timeout_uninterruptible(AK4648_WAIT_LO_LOCK);
+	/* LOPS */
+	res = CODEC_WRITE(AK4648REG_SIGNAL_SELECT_2,
+			       0x00, AK4648BIT_LOPS);
+	if (res < 0)
+		goto err1;
+
+	/* Mic Input Recording Sequence */
+	/* PMMP MGAIN0 */
+	res = CODEC_WRITE(AK4648REG_SIGNAL_SELECT_1, AK4648BIT_PMMP,
+			       (AK4648BIT_PMMP | AK4648BIT_MGAIN0));
+	if (res < 0)
+		goto err1;
+	/* IN */
+	res = CODEC_WRITE(AK4648REG_POWER_MANAGEMENT_3,
+			       0x00, AK4648BIT_IN_MASK);
+	if (res < 0)
+		goto err1;
+	/* INL */
+	res = CODEC_WRITE(AK4648REG_LCH_INPUT_VOLUME_CONTROL,
+			       ((AK4648_INPUT_VOL_MAX * 80) / 100),
+			       AK4648_INPUT_VOL_MAX);
+	if (res < 0)
+		goto err1;
+	/* INR */
+	res = CODEC_WRITE(AK4648REG_RCH_INPUT_VOLUME_CONTROL,
+			       ((AK4648_INPUT_VOL_MAX * 80) / 100),
+			       AK4648_INPUT_VOL_MAX);
+	if (res < 0)
+		goto err1;
+	/* IVOLC */
+	res = CODEC_WRITE(AK4648REG_MODE_CONTROL_4,
+			       0x00, AK4648BIT_IVOLC);
+	if (res < 0)
+		goto err1;
+	/* ZTM WTM */
+	res = CODEC_WRITE(AK4648REG_TIMER_SELECT,
+			       (AK4648BIT_ZTM1 | AK4648BIT_WTM1),
+			       (AK4648BIT_ZTM_MASK | AK4648BIT_WTM_MASK));
+	if (res < 0)
+		goto err1;
+	/* REF */
+	res = CODEC_WRITE(AK4648REG_ALC_MODE_CONTROL_2,
+			       ((AK4648_INPUT_VOL_MAX * 80) / 100),
+			       AK4648_INPUT_VOL_MAX);
+	if (res < 0)
+		goto err1;
+	/* RGAIN1 LMTH1 */
+	res = CODEC_WRITE(AK4648REG_ALC_MODE_CONTROL_3, 0x00,
+			       (AK4648BIT_RGAIN1 | AK4648BIT_LMTH1));
+	if (res < 0)
+		goto err1;
+	/* ALC ZELMN RGAIN0 LMTH0 */
+	res = CODEC_WRITE(AK4648REG_ALC_MODE_CONTROL_1,
+			       (AK4648BIT_ALC | AK4648BIT_LMTH0),
+			       (AK4648BIT_ALC | AK4648BIT_ZELMN |
+				AK4648BIT_LMAT_MASK |
+				AK4648BIT_RGAIN0 | AK4648BIT_LMTH0));
+	if (res < 0)
+		goto err1;
+	/* PMADL */
+	res = CODEC_WRITE(AK4648REG_POWER_MANAGEMENT_1,
+			       AK4648BIT_PMADL, AK4648BIT_PMADL);
+	if (res < 0)
+		goto err1;
+	/* PMADR */
+	res = CODEC_WRITE(AK4648REG_POWER_MANAGEMENT_3,
+			       AK4648BIT_PMADR, AK4648BIT_PMADR);
+	if (res < 0)
+		goto err1;
+	/* MIX */
+	res = CODEC_WRITE(AK4648REG_MODE_CONTROL_5,
+			       0x00, AK4648BIT_MIX);
+	if (res < 0)
+		goto err1;
+
+	codec->power_on++;
+	mutex_unlock(&codec->power_mutex);
+
+	return res;
+
+err1:
+	/* codec PDN pin "H" -> "L" */
+	/* SNDPDN CODEC Reset 5T735:GPIO9 IOOUT2 D1 */
+	gpio_set_value(GPIO_SNDPDN, 0);
+#ifndef CONFIG_MP200_EM1_DKIT
+	gpio_set_value(GPIO_SNDCDA, 0);
+#endif
+	/* PDN pin "L" needs 150ns */
+	udelay(1);
+#if 0
+	/* 5T735:PSCNTGP5("REGGP5" -> "OFF") PSCNT2 D3 */
+	pwc_write(PWC_PSCNT2, 0x00, 0x08);
+	/* 5T735:VGP5SET(2.85V) VOUTSET3 D4 */
+	pwc_write(PWC_VOUTSET3, 0x00, 0x10);
+	udelay(500);
+#endif
+	/* CHG_CTRL_OSC : OSC_EN(D0) */
+	outl(0x0, CHG_CTRL_OSC);
+
+	mutex_unlock(&codec->power_mutex);
+
+	return res;
+}
+
+static int codec_power_off(void)
+{
+	struct mp200_codec_mixer *codec = &codec_mixer;
+	int res = 0;
+
+	mutex_lock(&codec->power_mutex);
+	if (codec->power_on == 0) {
+		mutex_unlock(&codec->power_mutex);
+		return 0;
+	}
+
+	/* Mic Input Recording Sequence */
+	/* PMADR */
+	res = CODEC_WRITE(AK4648REG_POWER_MANAGEMENT_3,
+			       0x00, AK4648BIT_PMADR);
+	if (res < 0)
+		goto out;
+	/* PMADL */
+	res = CODEC_WRITE(AK4648REG_POWER_MANAGEMENT_1,
+			       0x00, AK4648BIT_PMADL);
+	if (res < 0)
+		goto out;
+	/* PMMP */
+	res = CODEC_WRITE(AK4648REG_SIGNAL_SELECT_1, 0x00, AK4648BIT_PMMP);
+	if (res < 0)
+		goto out;
+
+	/* Headphone Sequence */
+	/* HPMTN */
+	res = CODEC_WRITE(AK4648REG_POWER_MANAGEMENT_2,
+			       0x00, AK4648BIT_HPMTN);
+	if (res < 0)
+		goto out;
+	schedule_timeout_uninterruptible(AK4648_WAIT_HPMTN_DIS_LOCK);
+	/* PMHPL PMHPR */
+	res = CODEC_WRITE(AK4648REG_POWER_MANAGEMENT_2, 0x00,
+			       (AK4648BIT_PMHPL | AK4648BIT_PMHPR));
+	if (res < 0)
+		goto out;
+	/* PMDAC */
+	res = CODEC_WRITE(AK4648REG_POWER_MANAGEMENT_1,
+			       0x00, AK4648BIT_PMDAC);
+	if (res < 0)
+		goto out;
+	/* DACH */
+	res = CODEC_WRITE(AK4648REG_MODE_CONTROL_4,
+			       0x00, AK4648BIT_DACH);
+	if (res < 0)
+		goto out;
+
+	/* Stereo Lineout Sequence */
+	/* LOPS */
+	res = CODEC_WRITE(AK4648REG_SIGNAL_SELECT_2,
+			       AK4648BIT_LOPS, AK4648BIT_LOPS);
+	if (res < 0)
+		goto out;
+	/* PMLO PMDAC */
+	res = CODEC_WRITE(AK4648REG_POWER_MANAGEMENT_1,
+			       0x00, (AK4648BIT_PMLO | AK4648BIT_PMDAC));
+	if (res < 0)
+		goto out;
+	schedule_timeout_uninterruptible(AK4648_WAIT_LO_LOCK);
+	/* DACL */
+	res = CODEC_WRITE(AK4648REG_SIGNAL_SELECT_1,
+			       0x00, AK4648BIT_DACL);
+	if (res < 0)
+		goto out;
+	/* LOPS */
+	res = CODEC_WRITE(AK4648REG_SIGNAL_SELECT_2,
+			       0x00, AK4648BIT_LOPS);
+	if (res < 0)
+		goto out;
+
+	/* Stop of Clock Sequence */
+	/* PMPLL */
+	res = CODEC_WRITE(AK4648REG_POWER_MANAGEMENT_2,
+			       0x00, AK4648BIT_PMPLL);
+	if (res < 0)
+		goto out;
+	schedule_timeout_uninterruptible(AK4648_WAIT_PLL_LOCK);
+	res = CODEC_WRITE(AK4648REG_POWER_MANAGEMENT_1,
+			       0x00, AK4648BIT_PMVCM);
+	if (res < 0)
+		goto out;
+
+
+	i2c_codec_cleanup();
+	/* codec PDN pin "H" -> "L" */
+	/* SNDPDN CODEC_Reset 5T735:GPIO9 IOOUT2 D1 */
+	gpio_set_value(GPIO_SNDPDN, 0);
+#ifndef CONFIG_MP200_EM1_DKIT
+	gpio_set_value(GPIO_SNDCDA, 0);
+#endif
+	/* PDN pin "L" needs 150ns */
+	udelay(1);
+#if 0
+	/* 5T735:PSCNTGP5("REGGP5" -> "OFF") PSCNT2 D3 */
+	pwc_write(PWC_PSCNT2, 0x00, 0x08);
+	/* 5T735:VGP5SET(2.85V) VOUTSET3 D4 */
+	pwc_write(PWC_VOUTSET3, 0x00, 0x10);
+	udelay(500);
+#endif
+	/* CHG_CTRL_OSC : OSC_EN(D0) */
+	outl(0x0, CHG_CTRL_OSC);
+
+	codec->power_on--;
+out:
+	mutex_unlock(&codec->power_mutex);
+
+	return res;
+}
+
+static inline int mp200_codec_playback_volume(int *val)
+{
+	unsigned char reg;
+	int res = 0;
+
+	if (*(val) > 100)
+		*(val) = 100;
+
+	if (*(val + 1) > 100)
+		*(val + 1) = 100;
+
+	reg = (AK4648_OUTPUT_VOL_MAX * (100 - *(val))) / 100;
+
+	/* DVL */
+	res = CODEC_WRITE(AK4648REG_LCH_DIGITAL_VOLUME_CONTROL,
+			       reg, 0xff);
+	if (res < 0)
+		return res;
+
+	reg = (AK4648_OUTPUT_VOL_MAX * (100 - *(val + 1))) / 100;
+
+	/* DVR */
+	res = CODEC_WRITE(AK4648REG_RCH_DIGITAL_VOLUME_CONTROL,
+			       reg, 0xff);
+	if (res < 0)
+		return res;
+
+	return 0;
+}
+
+static inline int mp200_codec_capture_volume(int *val)
+{
+	unsigned char reg1, reg2;
+	int res = 0;
+
+	if (*(val) > 100)
+		*(val) = 100;
+
+	if (*(val + 1) > 100)
+		*(val + 1) = 100;
+
+	reg1 = (AK4648_INPUT_VOL_MAX * *(val)) / 100;
+
+	reg2 = (AK4648_INPUT_VOL_MAX * *(val + 1)) / 100;
+
+	/* IVL */
+	res = CODEC_WRITE(AK4648REG_LCH_INPUT_VOLUME_CONTROL,
+			       reg1, 0xff);
+	if (res < 0)
+		return res;
+
+	/* IVR */
+	res = CODEC_WRITE(AK4648REG_RCH_INPUT_VOLUME_CONTROL,
+			       reg2, 0xff);
+	if (res < 0)
+		return res;
+
+	res = CODEC_WRITE(AK4648REG_ALC_MODE_CONTROL_1,
+			       0x00, AK4648BIT_ALC);
+	if (res < 0)
+		return res;
+
+	res = CODEC_WRITE(AK4648REG_ALC_MODE_CONTROL_2, reg1, 0xff);
+	if (res < 0)
+		return res;
+
+	schedule_timeout_uninterruptible(AK4648_WAIT_ALC_LOCK);
+
+	res = CODEC_WRITE(AK4648REG_ALC_MODE_CONTROL_1,
+			       AK4648BIT_ALC, AK4648BIT_ALC);
+	if (res < 0)
+		return res;
+
+	return 0;
+}
+
+static int mp200_codec_capture_source_sw(int *val)
+{
+	unsigned char inx = 0;
+	unsigned char pmmp = 0;
+	int res = 0;
+
+	switch (val[0]) {
+	case 0: /* MIC */
+		inx = 0x00;
+		pmmp = AK4648BIT_PMMP;
+		break;
+	case 1: /* Line */
+		inx = AK4648BIT_INL0 | AK4648BIT_INR0;
+		pmmp = AK4648BIT_PMMP;
+		break;
+	}
+
+	/* INL INR */
+	res = CODEC_WRITE(AK4648REG_POWER_MANAGEMENT_3,
+			       inx, AK4648BIT_IN_MASK);
+	if (res < 0)
+		return res;
+
+	/* PMMP */
+	res = CODEC_WRITE(AK4648REG_SIGNAL_SELECT_1,
+			       pmmp, AK4648BIT_PMMP);
+	if (res < 0)
+		return res;
+
+	return 0;
+}
+
+static int mp200_codec_capture_channel_mode_sw(int *val)
+{
+	unsigned char pmadl = 0;
+	unsigned char pmadr = 0;
+	unsigned char mix = 0;
+	int res = 0;
+
+	switch (val[0]) {
+	case 0: /* Stereo */
+		pmadl = AK4648BIT_PMADL;
+		pmadr = AK4648BIT_PMADR;
+		mix = 0x00;
+		break;
+	case 1: /* Mono Lch */
+		pmadl = AK4648BIT_PMADL;
+		pmadr = 0x00;
+		mix = 0x00;
+		break;
+	case 2: /* Mono Rch */
+		pmadl = 0x00;
+		pmadr = AK4648BIT_PMADR;
+		mix = 0x00;
+		break;
+	case 3: /* MIX */
+		pmadl = AK4648BIT_PMADL;
+		pmadr = AK4648BIT_PMADR;
+		mix = AK4648BIT_MIX;
+		break;
+	}
+
+	/* PMADL */
+	res = CODEC_WRITE(AK4648REG_POWER_MANAGEMENT_1,
+			       pmadl, AK4648BIT_PMADL);
+	if (res < 0)
+		return res;
+	/* PMADR */
+	res = CODEC_WRITE(AK4648REG_POWER_MANAGEMENT_3,
+			       pmadr, AK4648BIT_PMADR);
+	if (res < 0)
+		return res;
+	/* MIX */
+	res = CODEC_WRITE(AK4648REG_MODE_CONTROL_5,
+			       mix, AK4648BIT_MIX);
+	if (res < 0)
+		return res;
+
+	return 0;
+}
+
+static int mp200_codec_sampling_rate_sw(long val)
+{
+	unsigned char fs = 0;
+	int res = 0;
+	struct enum_info *info = &enum_info[IDX(MIXER_SW_SAMPLING_RATE)];
+
+	if (val < 8000) {
+		/* 7.35kHz */
+		fs = AK4648BIT_FS_7_35KHZ;
+		info->value = 0;
+	} else if (val < 11025) {
+		/* 8kHz */
+		fs = AK4648BIT_FS_8KHZ;
+		info->value = 1;
+	} else if (val < 12000) {
+		/* 11.025kHz */
+		fs = AK4648BIT_FS_11_025KHZ;
+		info->value = 2;
+	} else if (val < 14700) {
+		/* 12kHz */
+		fs = AK4648BIT_FS_12KHZ;
+		info->value = 3;
+	} else if (val < 16000) {
+		/* 14.7kHz */
+		fs = AK4648BIT_FS_14_7KHZ;
+		info->value = 4;
+	} else if (val < 22050) {
+		/* 16kHz */
+		fs = AK4648BIT_FS_16KHZ;
+		info->value = 5;
+	} else if (val < 24000) {
+		/* 22.05kHz */
+		fs = AK4648BIT_FS_22_05KHZ;
+		info->value = 6;
+	} else if (val < 29400) {
+		/* 24kHz */
+		fs = AK4648BIT_FS_24KHZ;
+		info->value = 7;
+	} else if (val < 32000) {
+		/* 29.4kHz */
+		fs = AK4648BIT_FS_29_4KHZ;
+		info->value = 8;
+	} else if (val < 44100) {
+		/* 32kHz */
+		fs = AK4648BIT_FS_32KHZ;
+		info->value = 9;
+	} else if (val < 48000) {
+		/* 44.1kHz */
+		fs = AK4648BIT_FS_44_1KHZ;
+		info->value = 10;
+	} else {
+		/* 48kHz */
+		fs = AK4648BIT_FS_48KHZ;
+		info->value = 11;
+	}
+
+	/* FS */
+	res = CODEC_WRITE(AK4648REG_MODE_CONTROL_2, fs, AK4648BIT_FS_MASK);
+
+	return res;
+}
+
+static int mp200_codec_playback_sw(int *val)
+{
+	int res = 0;
+
+	switch (val[0]) {
+	case 0: /* Line */
+		/* Headphone power off */
+		/* HPMTN */
+		res = CODEC_WRITE(AK4648REG_POWER_MANAGEMENT_2,
+				       0x00, AK4648BIT_HPMTN);
+		if (res < 0)
+			return res;
+		schedule_timeout_uninterruptible(AK4648_WAIT_HPMTN_DIS_LOCK);
+		/* PMHPL PMHPR */
+		res = CODEC_WRITE(AK4648REG_POWER_MANAGEMENT_2, 0x00,
+				       (AK4648BIT_PMHPL | AK4648BIT_PMHPR));
+		if (res < 0)
+			return res;
+		/* PMDAC */
+		res = CODEC_WRITE(AK4648REG_POWER_MANAGEMENT_1,
+				       0x00, AK4648BIT_PMDAC);
+		if (res < 0)
+			return res;
+		/* DACH */
+		res = CODEC_WRITE(AK4648REG_MODE_CONTROL_4,
+				       0x00, AK4648BIT_DACH);
+		if (res < 0)
+			return res;
+
+		/* Stereo Lineout power on */
+		/* DACL */
+		res = CODEC_WRITE(AK4648REG_SIGNAL_SELECT_1,
+				       AK4648BIT_DACL, AK4648BIT_DACL);
+		if (res < 0)
+			return res;
+		/* LOPS */
+		res = CODEC_WRITE(AK4648REG_SIGNAL_SELECT_2,
+				       AK4648BIT_LOPS, AK4648BIT_LOPS);
+		if (res < 0)
+			return res;
+		/* PMLO PMDAC */
+		res = CODEC_WRITE(AK4648REG_POWER_MANAGEMENT_1,
+				       (AK4648BIT_PMLO | AK4648BIT_PMDAC),
+				       (AK4648BIT_PMLO | AK4648BIT_PMDAC));
+		if (res < 0)
+			return res;
+		schedule_timeout_uninterruptible(AK4648_WAIT_LO_LOCK);
+		/* LOPS */
+		res = CODEC_WRITE(AK4648REG_SIGNAL_SELECT_2,
+				       0x00, AK4648BIT_LOPS);
+		if (res < 0)
+			return res;
+		break;
+
+	case 1: /* Headphone */
+		/* Stereo Lineout power off */
+		/* LOPS */
+		res = CODEC_WRITE(AK4648REG_SIGNAL_SELECT_2,
+				       AK4648BIT_LOPS, AK4648BIT_LOPS);
+		if (res < 0)
+			return res;
+		/* PMLO PMDAC */
+		res = CODEC_WRITE(AK4648REG_POWER_MANAGEMENT_1,
+				0x00, (AK4648BIT_PMLO | AK4648BIT_PMDAC));
+		if (res < 0)
+			return res;
+		schedule_timeout_uninterruptible(AK4648_WAIT_LO_LOCK);
+		/* LOPS */
+		res = CODEC_WRITE(AK4648REG_SIGNAL_SELECT_2,
+				       0x00, AK4648BIT_LOPS);
+		if (res < 0)
+			return res;
+
+		/* Headphone power on */
+		/* DACH */
+		res = CODEC_WRITE(AK4648REG_MODE_CONTROL_4,
+				       AK4648BIT_DACH, AK4648BIT_DACH);
+		if (res < 0)
+			return res;
+		/* HPG vol -> 0dB(defult) */
+
+		/* PMDAC */
+		res = CODEC_WRITE(AK4648REG_POWER_MANAGEMENT_1,
+				       AK4648BIT_PMDAC, AK4648BIT_PMDAC);
+		if (res < 0)
+			return res;
+		/* PMHPL PMHPR */
+		res = CODEC_WRITE(AK4648REG_POWER_MANAGEMENT_2,
+				       (AK4648BIT_PMHPL | AK4648BIT_PMHPR),
+				       (AK4648BIT_PMHPL | AK4648BIT_PMHPR));
+		if (res < 0)
+			return res;
+		/* HPMTN */
+		res = CODEC_WRITE(AK4648REG_POWER_MANAGEMENT_2,
+				       AK4648BIT_HPMTN, AK4648BIT_HPMTN);
+		if (res < 0)
+			return res;
+		schedule_timeout_uninterruptible(AK4648_WAIT_HPMTN_EN_LOCK);
+		break;
+	}
+
+	return 0;
+}
+
+static int mp200_codec_mixer_write(int addr, struct mp200_codec_mixer *codec)
+{
+	int res = 0;
+
+	switch (addr) {
+	case MIXER_VOL_PLAYBACK:
+		res = mp200_codec_playback_volume(
+			&codec->vol_info[IDX(addr)].value[0]);
+		break;
+	case MIXER_VOL_CAPTURE:
+		res = mp200_codec_capture_volume(
+			&codec->vol_info[IDX(addr)].value[0]);
+		break;
+	case MIXER_SW_CAPTURE_SOURCE:
+		res = mp200_codec_capture_source_sw(
+			&codec->enum_info[IDX(addr)].value);
+		break;
+	case MIXER_SW_CAPTURE_CHANNEL_MODE:
+		res = mp200_codec_capture_channel_mode_sw(
+			&codec->enum_info[IDX(addr)].value);
+		break;
+	case MIXER_SW_SAMPLING_RATE:
+	{
+		long val = 0;
+
+		switch (codec->enum_info[IDX(addr)].value) {
+		case 0:
+			val = 7350;
+			break;
+		case 1:
+			val = 8000;
+			break;
+		case 2:
+			val = 11025;
+			break;
+		case 3:
+			val = 12000;
+			break;
+		case 4:
+			val = 14700;
+			break;
+		case 5:
+			val = 16000;
+			break;
+		case 6:
+			val = 22050;
+			break;
+		case 7:
+			val = 24000;
+			break;
+		case 8:
+			val = 29400;
+			break;
+		case 9:
+			val = 32000;
+			break;
+		case 10:
+			val = 44100;
+			break;
+		case 11:
+			val = 48000;
+			break;
+		}
+
+		res = mp200_codec_sampling_rate_sw(val);
+
+		break;
+	}
+	case MIXER_SW_PLAYBACK:
+		res = mp200_codec_playback_sw(
+			&codec->enum_info[IDX(addr)].value);
+		break;
+	case MIXER_SW_CODEC_POWER_BL:
+		if (codec->bl_info[IDX(addr)].value)
+			res = codec_power_on();
+		else
+			res = codec_power_off();
+
+		break;
+	}
+
+	return res;
+}
+
+#define MP200_CODEC_INTEGER(xname, xindex, addr) \
+	{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, .index = xindex, \
+	  .info = mp200_codec_integer_info, .get = mp200_codec_integer_get, \
+	  .put = mp200_codec_integer_put, .private_value = addr }
+
+static int mp200_codec_integer_info(struct snd_kcontrol *kcontrol,
+ struct snd_ctl_elem_info *uinfo)
+{
+	struct mp200_codec_mixer *codec = snd_kcontrol_chip(kcontrol);
+	int addr = kcontrol->private_value;
+
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = codec->vol_info[IDX(addr)].count;
+	uinfo->value.integer.min  = codec->vol_info[IDX(addr)].val_int_min;
+	uinfo->value.integer.max  = codec->vol_info[IDX(addr)].val_int_max;
+	uinfo->value.integer.step = codec->vol_info[IDX(addr)].val_int_step;
+
+	return 0;
+}
+
+static int mp200_codec_integer_get(struct snd_kcontrol *kcontrol,
+ struct snd_ctl_elem_value *ucontrol)
+{
+	struct mp200_codec_mixer *codec = snd_kcontrol_chip(kcontrol);
+	unsigned long flags;
+	int addr = kcontrol->private_value;
+	int cnt = codec->vol_info[IDX(addr)].count;
+	int i;
+
+	spin_lock_irqsave(&codec->mixer_lock, flags);
+	for (i = 0; i < cnt; i++) {
+		ucontrol->value.integer.value[i]  =
+			codec->vol_info[IDX(addr)].value[i];
+	}
+	spin_unlock_irqrestore(&codec->mixer_lock, flags);
+
+	return 0;
+}
+
+static int mp200_codec_integer_put(struct snd_kcontrol *kcontrol,
+ struct snd_ctl_elem_value *ucontrol)
+{
+	struct mp200_codec_mixer *codec = snd_kcontrol_chip(kcontrol);
+	unsigned long flags;
+	int addr = kcontrol->private_value;
+	int min  = codec->vol_info[IDX(addr)].val_int_min;
+	int max  = codec->vol_info[IDX(addr)].val_int_max;
+	int step = codec->vol_info[IDX(addr)].val_int_step;
+	int i, change = 0;
+	int cnt = codec->vol_info[IDX(addr)].count;
+	int volume[2];
+	int res = 0;
+
+	if (codec->power_on == 0)
+		return -EINVAL;
+
+	for (i = 0; i < cnt; i++) {
+		volume[i] = (ucontrol->value.integer.value[i] / step) * step;
+		if (volume[i] < min)
+			volume[i] = min;
+		if (volume[i] > max)
+			volume[i] = max;
+	}
+
+	spin_lock_irqsave(&codec->mixer_lock, flags);
+	for (i = 0; i < cnt; i++) {
+		change |= (codec->vol_info[IDX(addr)].value[i] != volume[i]);
+		codec->vol_info[IDX(addr)].value[i] = volume[i];
+	}
+	spin_unlock_irqrestore(&codec->mixer_lock, flags);
+
+	if (change) {
+		res = mp200_codec_mixer_write(addr, codec);
+		if (res < 0)
+			return res;
+
+	}
+
+	return change;
+}
+
+#define MP200_CODEC_ENUM(xname, xindex, addr) \
+	{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, .index = xindex, \
+	  .info = mp200_codec_enum_info, .get = mp200_codec_enum_get, \
+	  .put = mp200_codec_enum_put, .private_value = addr }
+
+static int mp200_codec_enum_info(struct snd_kcontrol *kcontrol,
+ struct snd_ctl_elem_info *uinfo)
+{
+	struct mp200_codec_mixer *codec = snd_kcontrol_chip(kcontrol);
+	int addr = kcontrol->private_value;
+	int items = codec->enum_info[IDX(addr)].items;
+
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
+	uinfo->count = 1;
+	uinfo->value.enumerated.items = items;
+	if (uinfo->value.enumerated.item > (items - 1))
+		uinfo->value.enumerated.item = (items - 1);
+	strcpy(uinfo->value.enumerated.name,
+	       codec->enum_info[IDX(addr)].texts[uinfo->value.enumerated.item]);
+
+	return 0;
+}
+
+static int mp200_codec_enum_get(struct snd_kcontrol *kcontrol,
+ struct snd_ctl_elem_value *ucontrol)
+{
+	struct mp200_codec_mixer *codec = snd_kcontrol_chip(kcontrol);
+	unsigned long flags;
+	int addr = kcontrol->private_value;
+
+	spin_lock_irqsave(&codec->mixer_lock, flags);
+	ucontrol->value.enumerated.item[0] = codec->enum_info[IDX(addr)].value;
+	spin_unlock_irqrestore(&codec->mixer_lock, flags);
+
+	return 0;
+}
+
+static int mp200_codec_enum_put(struct snd_kcontrol *kcontrol,
+ struct snd_ctl_elem_value *ucontrol)
+{
+	struct mp200_codec_mixer *codec = snd_kcontrol_chip(kcontrol);
+	unsigned long flags;
+	int change, val;
+	int addr = kcontrol->private_value;
+	int items = codec->enum_info[IDX(addr)].items;
+	int res = 0;
+
+	if (codec->power_on == 0)
+		return -EINVAL;
+
+	if (ucontrol->value.enumerated.item[0] > (items - 1))
+		return -EINVAL;
+	val = ucontrol->value.enumerated.item[0];
+
+	spin_lock_irqsave(&codec->mixer_lock, flags);
+	change = (codec->enum_info[IDX(addr)].value != val);
+	codec->enum_info[IDX(addr)].value = val;
+	spin_unlock_irqrestore(&codec->mixer_lock, flags);
+
+	if (change) {
+		res = mp200_codec_mixer_write(addr, codec);
+		if (res < 0)
+			return res;
+
+	}
+
+	return change;
+}
+
+#define MP200_CODEC_BOOLEAN(xname, xindex, addr) \
+	{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, .index = xindex, \
+	  .info = mp200_codec_boolean_info, .get = mp200_codec_boolean_get, \
+	  .put = mp200_codec_boolean_put, .private_value = addr }
+
+static int mp200_codec_boolean_info(struct snd_kcontrol *kcontrol,
+ struct snd_ctl_elem_info *uinfo)
+{
+
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 1;
+
+	return 0;
+}
+
+static int mp200_codec_boolean_get(struct snd_kcontrol *kcontrol,
+ struct snd_ctl_elem_value *ucontrol)
+{
+	struct mp200_codec_mixer *codec = snd_kcontrol_chip(kcontrol);
+	unsigned long flags;
+	int addr = kcontrol->private_value;
+
+	spin_lock_irqsave(&codec->mixer_lock, flags);
+	ucontrol->value.integer.value[0] = codec->bl_info[IDX(addr)].value;
+	spin_unlock_irqrestore(&codec->mixer_lock, flags);
+
+	return 0;
+}
+
+static int mp200_codec_boolean_put(struct snd_kcontrol *kcontrol,
+ struct snd_ctl_elem_value *ucontrol)
+{
+	struct mp200_codec_mixer *codec = snd_kcontrol_chip(kcontrol);
+	unsigned long flags;
+	int change, addr = kcontrol->private_value;
+	int val;
+	int res = 0;
+
+	if ((codec->power_on == 0) && (addr != MIXER_SW_CODEC_POWER_BL))
+		return -EINVAL;
+
+	val = ucontrol->value.integer.value[0] & 1;
+	spin_lock_irqsave(&codec->mixer_lock, flags);
+	change = (codec->bl_info[IDX(addr)].value != val);
+	codec->bl_info[IDX(addr)].value = val;
+	spin_unlock_irqrestore(&codec->mixer_lock, flags);
+
+	if (change) {
+		res = mp200_codec_mixer_write(addr, codec);
+		if (res < 0)
+			return res;
+
+	}
+
+	return change;
+}
+
+static struct snd_kcontrol_new mp200_codec_controls[] = {
+	MP200_CODEC_INTEGER(
+		"Playback Volume", 0, MIXER_VOL_PLAYBACK),
+	MP200_CODEC_INTEGER(
+		"Capture Volume", 0, MIXER_VOL_CAPTURE),
+	MP200_CODEC_ENUM(
+		"Capture Source Switch", 0, MIXER_SW_CAPTURE_SOURCE),
+	MP200_CODEC_ENUM(
+		"Capture Channel Mode Switch",
+		0, MIXER_SW_CAPTURE_CHANNEL_MODE),
+	MP200_CODEC_ENUM(
+		"Sampling Rate Switch", 0, MIXER_SW_SAMPLING_RATE),
+	MP200_CODEC_ENUM(
+		"Playback Switch", 0, MIXER_SW_PLAYBACK),
+	MP200_CODEC_BOOLEAN(
+		"CODEC Power Switch", 0, MIXER_SW_CODEC_POWER_BL),
+};
+
+static int __init mp200_codec_mixer_new(struct snd_card *card)
+{
+	unsigned int idx;
+	int err;
+
+	snd_assert(card != NULL, return -EINVAL);
+	spin_lock_init(&codec_mixer.mixer_lock);
+	mutex_init(&codec_mixer.power_mutex);
+	strcpy(card->mixername, "mp200 mixer");
+
+	codec_mixer.card = card;
+
+	for (idx = 0; idx < ARRAY_SIZE(mp200_codec_controls); idx++) {
+		err = snd_ctl_add(card,
+			snd_ctl_new1(&mp200_codec_controls[idx], &codec_mixer));
+		if (err < 0)
+			return err;
+
+	}
+
+	return 0;
+}
+
+
+static struct snd_pcm *mp200_codec;
+
+static unsigned int rates[] = {
+	7350, 8000, 11025, 12000, 14700, 16000,
+	22050, 24000, 29400, 32000, 44100, 48000,
+};
+
+static struct snd_pcm_hw_constraint_list hw_constraints_rates = {
+	.count  = ARRAY_SIZE(rates),
+	.list   = rates,
+	.mask   = 0,
+};
+
+static int mp200_codec_startup(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct mp200_codec_mixer *codec = &codec_mixer;
+	int err;
+
+	if (codec->power_on == 0)
+		return -EINVAL;
+
+#ifdef MP200_PCM_USE_PDMA
+	runtime->hw.formats = SNDRV_PCM_FMTBIT_S32_LE;
+#else
+	runtime->hw.formats = SNDRV_PCM_FMTBIT_S16_LE;
+#endif
+
+
+	runtime->hw.rates = (SNDRV_PCM_RATE_8000 |
+			     SNDRV_PCM_RATE_11025 |
+			     SNDRV_PCM_RATE_16000 |
+			     SNDRV_PCM_RATE_22050 |
+			     SNDRV_PCM_RATE_32000 |
+			     SNDRV_PCM_RATE_44100 |
+			     SNDRV_PCM_RATE_48000 |
+			     SNDRV_PCM_RATE_KNOT);
+	runtime->hw.rate_min = 8000;
+	runtime->hw.rate_max = 48000;
+	runtime->hw.channels_min = 2;
+	runtime->hw.channels_max = 2;
+
+	err = snd_pcm_hw_constraint_integer(runtime,
+					    SNDRV_PCM_HW_PARAM_PERIODS);
+	if (err < 0)
+		return err;
+
+	err = snd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,
+					&hw_constraints_rates);
+	if (err < 0)
+		return err;
+
+	return 0;
+}
+
+static void mp200_codec_shutdown(struct snd_pcm_substream *substream)
+{
+	return;
+}
+
+static int mp200_codec_prepare(struct snd_pcm_substream *substream)
+{
+	int ret = 0;
+	struct snd_pcm_runtime *runtime = substream->runtime;
+
+	ret = mp200_codec_sampling_rate_sw(runtime->rate);
+
+	return ret;
+}
+
+static struct audio_stream mp200_codec_out = {
+	.id                     = "voice out dma m2p lch9",
+	.dma_ch                 = MP200_DMAC_M2P_LCH9,
+};
+
+static struct audio_stream mp200_codec_in = {
+	.id                     = "voice in dma m2p lch9",
+	.dma_ch                 = MP200_DMAC_P2M_LCH9,
+};
+
+static struct mp200_pcm_client mp200_codec_client = {
+	.pcm_ch                 = MP200_PCM_CH0,
+	.startup                = mp200_codec_startup,
+	.shutdown               = mp200_codec_shutdown,
+	.prepare                = mp200_codec_prepare,
+};
+
+
+/* codec sound card */
+
+struct snd_card *mp200_codec_card;
+
+static char *id = ID_VALUE; /* ID for this card */
+module_param(id, charp, 0444);
+
+#ifdef CONFIG_PM
+static int mp200_codec_suspend(struct platform_device *dev, pm_message_t state)
+{
+	struct snd_card *card = platform_get_drvdata(dev);
+	int ret = 0;
+
+	switch (state.event) {
+	case DEV_SUSPEND_IDLE_1:
+	case PM_EVENT_SUSPEND:
+		break;
+	default:
+		break;
+	}
+
+	if (card)
+		ret = mp200_pcm_suspend(dev, state);
+
+	return ret;
+}
+
+static int mp200_codec_resume(struct platform_device *dev)
+{
+	struct snd_card *card = platform_get_drvdata(dev);
+	int ret = 0;
+
+	if (card)
+		ret = mp200_pcm_resume(dev);
+
+	return ret;
+}
+#else
+#define mp200_codec_suspend     NULL
+#define mp200_codec_resume      NULL
+#endif
+
+static int mp200_codec_probe(struct platform_device *devptr)
+{
+	struct snd_card *card = NULL;
+	int ret;
+
+	codec_init();
+
+	card = snd_card_new(SNDRV_DEFAULT_IDX1, id, THIS_MODULE, 0);
+	if (card == NULL)
+		return -ENOMEM;
+
+	snd_card_set_dev(card, &devptr->dev);
+
+	mp200_codec_card = card;
+
+	mp200_codec_client.s[SNDRV_PCM_STREAM_PLAYBACK] = &mp200_codec_out;
+	mp200_codec_client.s[SNDRV_PCM_STREAM_CAPTURE] = &mp200_codec_in;
+	mp200_codec_client.sett = &pcm_sett;
+
+	ret = mp200_pcm_new(card, &mp200_codec_client, &mp200_codec);
+	if (ret)
+		goto err;
+
+	ret = mp200_pcm_set_ctrl(mp200_codec_client.pcm_regs, &pcm_sett);
+	if (ret)
+		goto err;
+
+	ret = mp200_codec_mixer_new(card);
+	if (ret)
+		goto err;
+
+	snprintf(card->shortname, sizeof(card->shortname),
+		 "%s", "mp200-codec");
+	snprintf(card->longname, sizeof(card->longname),
+		 "%s (%s)", "sound codec", card->mixername);
+
+	ret = snd_card_register(card);
+	if (ret == 0) {
+		printk(KERN_INFO "Starting sound codec.\n");
+		platform_set_drvdata(devptr, card);
+		return 0;
+	}
+
+err:
+	if (card)
+		snd_card_free(card);
+
+	return ret;
+}
+
+static int mp200_codec_remove(struct platform_device *devptr)
+{
+	mp200_pcm_free(&mp200_codec_client);
+	snd_card_free(platform_get_drvdata(devptr));
+	platform_set_drvdata(devptr, NULL);
+	return 0;
+}
+
+#define MP200_PCM_DRIVER        "mp200 pcm"
+
+static struct platform_device *device;
+static struct platform_driver mp200_codec_driver = {
+	.probe          = mp200_codec_probe,
+	.remove         = __devexit_p(mp200_codec_remove),
+#ifdef CONFIG_PM
+	.suspend        = mp200_codec_suspend,
+	.resume         = mp200_codec_resume,
+#endif
+	.driver         = {
+		.name   = MP200_PCM_DRIVER,
+	},
+};
+
+static int __init mp200_codec_init(void)
+{
+	int err;
+
+	err = platform_driver_register(&mp200_codec_driver);
+	if (err < 0)
+		return err;
+	device = platform_device_register_simple(MP200_PCM_DRIVER, -1, NULL, 0);
+	if (!IS_ERR(device)) {
+		if (platform_get_drvdata(device))
+			return 0;
+		platform_device_unregister(device);
+		err = -ENODEV;
+	} else
+		err = PTR_ERR(device);
+	platform_driver_unregister(&mp200_codec_driver);
+	return err;
+}
+
+static void __exit mp200_codec_exit(void)
+{
+	platform_device_unregister(device);
+	platform_driver_unregister(&mp200_codec_driver);
+
+}
+
+
+module_init(mp200_codec_init);
+module_exit(mp200_codec_exit);
+
+MODULE_DESCRIPTION("sound codec driver for mp200 chip");
+MODULE_LICENSE("GPL");
+
diff --git a/sound/arm/mp200-mixer.h b/sound/arm/mp200-mixer.h
new file mode 100644
index 0000000..b4d5d6f
--- /dev/null
+++ b/sound/arm/mp200-mixer.h
@@ -0,0 +1,205 @@
+/*
+ *  File Name       : linux/sound/arm/mp200-mixer.h
+ *  Function        : Glue audio driver for the MP200 & AK4648 CODEC
+ *  Created         : 2008/07/02
+ *  Updated         : 2009/11/06
+ *
+ *  Copyright (C) NEC Electronics Corporation 2008,2009
+ *
+ * This program is free software;you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by Free Softwere
+ * Foundation; either version 2 of License, or (at your option) any later
+ * version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warrnty of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
+ * details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; If not, write to the Free Software Foundation, Inc., 59 Temple
+ * Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#ifndef __MP200_MIXER_H
+#define __MP200_MIXER_H
+
+#define AK4648REG_POWER_MANAGEMENT_1            0x00
+#define AK4648REG_POWER_MANAGEMENT_2            0x01
+#define AK4648REG_SIGNAL_SELECT_1               0x02
+#define AK4648REG_SIGNAL_SELECT_2               0x03
+#define AK4648REG_MODE_CONTROL_1                0x04
+#define AK4648REG_MODE_CONTROL_2                0x05
+#define AK4648REG_TIMER_SELECT                  0x06
+#define AK4648REG_ALC_MODE_CONTROL_1            0x07
+#define AK4648REG_ALC_MODE_CONTROL_2            0x08
+#define AK4648REG_LCH_INPUT_VOLUME_CONTROL      0x09
+#define AK4648REG_LCH_DIGITAL_VOLUME_CONTROL    0x0a
+#define AK4648REG_ALC_MODE_CONTROL_3            0x0b
+#define AK4648REG_RCH_INPUT_VOLUME_CONTROL      0x0c
+#define AK4648REG_RCH_DIGITAL_VOLUME_CONTROL    0x0d
+#define AK4648REG_MODE_CONTROL_3                0x0e
+#define AK4648REG_MODE_CONTROL_4                0x0f
+#define AK4648REG_POWER_MANAGEMENT_3            0x10
+#define AK4648REG_DIGITAL_FILTER_SELECT         0x11
+#define AK4648REG_FIL3_CO_EFFICIENT_0           0x12
+#define AK4648REG_FIL3_CO_EFFICIENT_1           0x13
+#define AK4648REG_FIL3_CO_EFFICIENT_2           0x14
+#define AK4648REG_FIL3_CO_EFFICIENT_3           0x15
+#define AK4648REG_EQ_CO_EFFICIENT_0             0x16
+#define AK4648REG_EQ_CO_EFFICIENT_1             0x17
+#define AK4648REG_EQ_CO_EFFICIENT_2             0x18
+#define AK4648REG_EQ_CO_EFFICIENT_3             0x19
+#define AK4648REG_EQ_CO_EFFICIENT_4             0x1a
+#define AK4648REG_EQ_CO_EFFICIENT_5             0x1b
+#define AK4648REG_FIL1_CO_EFFICIENT_0           0x1c
+#define AK4648REG_FIL1_CO_EFFICIENT_1           0x1d
+#define AK4648REG_FIL1_CO_EFFICIENT_2           0x1e
+#define AK4648REG_FIL1_CO_EFFICIENT_3           0x1f
+#define AK4648REG_POWER_MANAGEMENT_4            0x20
+#define AK4648REG_MODE_CONTROL_5                0x21
+#define AK4648REG_LINEOUT_MIXING_SELECT         0x22
+#define AK4648REG_HP_MIXING_SELECT              0x23
+#define AK4648REG_SPK_MIXING_SELECT             0x24
+#define AK4648REG_EQ_CONTROL_250HZ_100HZ        0x25
+#define AK4648REG_EQ_CONTROL_3_5KHZ_1KHZ        0x26
+#define AK4648REG_EQ_CONTROL_10KHZ              0x27
+#define AK4648REG_MAX                           0x28
+
+#define AK4648BIT_PMSPR         0x80
+#define AK4648BIT_PMVCM         0x40
+#define AK4648BIT_PMMIN         0x20
+#define AK4648BIT_PMSPL         0x10
+#define AK4648BIT_PMLO          0x08
+#define AK4648BIT_PMDAC         0x04
+#define AK4648BIT_PMADL         0x01
+
+#define AK4648BIT_HPZ           0x80
+#define AK4648BIT_HPMTN         0x40
+#define AK4648BIT_PMHPL         0x20
+#define AK4648BIT_PMHPR         0x10
+#define AK4648BIT_M_S           0x08
+#define AK4648BIT_PMHPC         0x04
+#define AK4648BIT_MCKO          0x02
+#define AK4648BIT_PMPLL         0x01
+
+#define AK4648BIT_SPPSN         0x80
+#define AK4648BIT_MINS          0x40
+#define AK4648BIT_DACS          0x20
+#define AK4648BIT_DACL          0x10
+#define AK4648BIT_PMMP          0x04
+#define AK4648BIT_MGAIN0        0x01
+
+#define AK4648BIT_LOVL          0x80
+#define AK4648BIT_LOPS          0x40
+#define AK4648BIT_MGAIN1        0x20
+#define AK4648BIT_SPKG1         0x10
+#define AK4648BIT_SPKG0         0x08
+#define AK4648BIT_MINL          0x04
+#define AK4648BIT_SPKG2         0x02
+#define AK4648BIT_SPKG_MASK     0x1a
+
+#define AK4648BIT_PLL3          0x80
+#define AK4648BIT_PLL2          0x40
+#define AK4648BIT_PLL1          0x20
+#define AK4648BIT_PLL0          0x10
+#define AK4648BIT_PLL_MASK      0xF0
+#define AK4648BIT_BCKO          0x08
+#define AK4648BIT_DIF1          0x02
+#define AK4648BIT_DIF0          0x01
+#define AK4648BIT_DIF_MASK      0x03
+
+#define AK4648BIT_PS1           0x80
+#define AK4648BIT_PS0           0x40
+#define AK4648BIT_PS_MASK       0xC0
+#define AK4648BIT_MSBS          0x10
+#define AK4648BIT_BCKP          0x08
+
+#define AK4648BIT_DVTM          0x80
+#define AK4648BIT_WTM2          0x40
+#define AK4648BIT_ZTM1          0x20
+#define AK4648BIT_ZTM0          0x10
+#define AK4648BIT_ZTM_MASK      0x30
+#define AK4648BIT_WTM1          0x08
+#define AK4648BIT_WTM0          0x04
+#define AK4648BIT_WTM_MASK      0x4C
+#define AK4648BIT_RFST1         0x02
+#define AK4648BIT_RFST0         0x01
+#define AK4648BIT_RFST_MASK     0x03
+
+#define AK4648BIT_ALC           0x20
+#define AK4648BIT_ZELMN         0x10
+#define AK4648BIT_LMAT1         0x08
+#define AK4648BIT_LMAT0         0x04
+#define AK4648BIT_LMAT_MASK     0x0C
+#define AK4648BIT_RGAIN0        0x02
+#define AK4648BIT_LMTH0         0x01
+
+#define AK4648BIT_RGAIN1        0x80
+#define AK4648BIT_LMTH1         0x40
+#define AK4648BIT_VBAT          0x02
+
+#define AK4648BIT_LOOP          0x40
+#define AK4648BIT_SMUTE         0x20
+#define AK4648BIT_DVOLC         0x10
+#define AK4648BIT_FBEQ          0x04
+#define AK4648BIT_DEM1          0x02
+#define AK4648BIT_DEM0          0x01
+#define AK4648BIT_DEM_MASK      0x03
+
+#define AK4648BIT_IVOLC         0x08
+#define AK4648BIT_HPM           0x04
+#define AK4648BIT_MINH          0x02
+#define AK4648BIT_DACH          0x01
+
+#define AK4648BIT_INR1          0x80
+#define AK4648BIT_INL1          0x40
+#define AK4648BIT_MDIF2         0x10
+#define AK4648BIT_MDIF1         0x08
+#define AK4648BIT_MDIF_MASK     0x18
+#define AK4648BIT_INR0          0x04
+#define AK4648BIT_INL0          0x02
+#define AK4648BIT_IN_MASK       0xc6
+#define AK4648BIT_PMADR         0x01
+
+#define AK4648BIT_GN1           0x80
+#define AK4648BIT_GN0           0x40
+#define AK4648BIT_GN_MASK       0xC0
+#define AK4648BIT_FIL1          0x10
+#define AK4648BIT_EQ            0x08
+#define AK4648BIT_FIL3          0x04
+
+#define AK4648BIT_SPKMN         0x40
+#define AK4648BIT_MICR3         0x20
+#define AK4648BIT_MICL3         0x10
+#define AK4648BIT_L4DIF         0x08
+#define AK4648BIT_MIX           0x04
+#define AK4648BIT_AIN3          0x02
+#define AK4648BIT_LODIF         0x01
+
+/* PLL2 bit = "1" : MCKI input */
+#define AK4648BIT_FS_8KHZ       0x00
+#define AK4648BIT_FS_12KHZ      0x01
+#define AK4648BIT_FS_16KHZ      0x02
+#define AK4648BIT_FS_24KHZ      0x03
+#define AK4648BIT_FS_7_35KHZ    0x04
+#define AK4648BIT_FS_11_025KHZ  0x05
+#define AK4648BIT_FS_14_7KHZ    0x06
+#define AK4648BIT_FS_22_05KHZ   0x07
+#define AK4648BIT_FS_32KHZ      0x22
+#define AK4648BIT_FS_48KHZ      0x23
+#define AK4648BIT_FS_29_4KHZ    0x26
+#define AK4648BIT_FS_44_1KHZ    0x27
+#define AK4648BIT_FS_MASK       0x27
+
+#define AK4648_INPUT_VOL_MAX    241
+#define AK4648_OUTPUT_VOL_MAX   255
+
+#define AK4648_WAIT_PLL_LOCK            (4 * HZ / 100)  /* 40ms */
+#define AK4648_WAIT_LO_LOCK             (30 * HZ / 100) /* 300ms */
+#define AK4648_WAIT_ALC_LOCK            (7 * HZ / 100)  /* 70ms */
+#define AK4648_WAIT_HPMTN_EN_LOCK       (21 * HZ / 100) /* 210ms */
+#define AK4648_WAIT_HPMTN_DIS_LOCK      (26 * HZ / 100) /* 260ms */
+
+#endif                          /* __MP200_MIXER_H */
diff --git a/sound/arm/mp200-pcm.c b/sound/arm/mp200-pcm.c
new file mode 100644
index 0000000..3f32fc4
--- /dev/null
+++ b/sound/arm/mp200-pcm.c
@@ -0,0 +1,1623 @@
+/*
+ * linux/sound/arm/mp200-pcm.c -- ALSA PCM interface for mp200 chip
+ *
+ * Created:	Aug 20, 2009
+ * update :     Nov 06, 2009
+ *
+ */
+
+#include <linux/errno.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/uaccess.h>
+#include <linux/io.h>
+#include <asm/dma.h>
+#include <mach/pwc.h>
+#include <mach/pmu.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/initval.h>
+#include <sound/hwdep.h>
+
+#include <mach/pm.h>
+
+#include <linux/irq.h>
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <asm/irq.h>
+#include <mach/gpio.h>
+
+#include "mp200-pcm.h"
+/* #define MP200_PCM_PACK_PELIOD */
+
+#ifdef MP200_PCM_MMAP_ENABLE
+#include <linux/dma-mapping.h>
+#endif
+
+#define PCM0_TX(s)	(s->dma_ch == MP200_DMAC_M2P_LCH9)
+
+#ifdef MP200_PCM_USE_PDMA
+
+#include <mach/pcm_irq.h>
+
+#define IS_PCM0(p)      (p.irq     == INT_PCM0)
+
+#define SRAM_BASE               MP200_SSRAM_BASE
+#define SRAM_SIZE               MP200_SSRAM_SIZE /* 128k */
+
+/****  Prototype definition  ****/
+#define PDMA_BASE       IO_ADDRESS(MP200_PDMA_BASE)
+
+#define PDMA_DMA_SEL            (PDMA_BASE + 0x00)
+#define PDMA_CONT                       (PDMA_BASE + 0x04)
+#define PDMA_STATUS                     (PDMA_BASE + 0x08)
+#define PDMA_RCV_CANCEL         (PDMA_BASE + 0x0C)
+#define PDMA_END                        (PDMA_BASE + 0x10)
+#define PDMA_RSV_ADD            (PDMA_BASE + 0x20)
+#define PDMA_RSV_LENG           (PDMA_BASE + 0x24)
+#define PDMA_RUN_ADD            (PDMA_BASE + 0x28)
+#define PDMA_RUN_LENG           (PDMA_BASE + 0x2C)
+#define PDMA_INT_STATUS         (PDMA_BASE + 0x30)
+#define PDMA_INT_RAW_STATUS     (PDMA_BASE + 0x34)
+#define PDMA_INT_ENABLE         (PDMA_BASE + 0x38)
+#define PDMA_INT_ENABLE_CL      (PDMA_BASE + 0x3C)
+#define PDMA_INT_REQ_CL         (PDMA_BASE + 0x40)
+#define PDMA_RUN_ADP            (PDMA_BASE + 0x50)
+#define PDMA_ERR                        (PDMA_BASE + 0x54)
+#define PDMA_TMP                        (PDMA_BASE + 0x58)
+
+#endif
+
+/* static init value */
+#define ALSA_PDMA_CALLBACK_VALUE	NULL
+#define ALSA_PDMA_DATA_VALUE		NULL
+#define PDMA_INIT_VALUE			0
+#define PDMA_IN_USE_VALUE		0
+#define POWER_FLAG_VALUE		0
+
+/* Type definitions */
+
+/* PMx_TXRX_EN Masks */
+#define PCM_TX_EN               0x01
+#define PCM_RX_EN               0x02
+
+static int power_flag = POWER_FLAG_VALUE;
+
+/*
+ * Data for managing PCM channels
+ */
+
+
+struct mp200_pcm {
+	char *name;             /* irq name. */
+	u_int base;             /* base address */
+	u_int clock_s;          /* SCLK */
+	u_int clock_p;          /* PCLK */
+	u_int clkctl;           /* CLKCTRL */
+	u_int reset;            /* reset */
+#ifdef MP200_PCM_INTERRUPT_ENABLE
+	u_int irq;              /* irq */
+	struct snd_pcm *pcm;            /* arg */
+#endif
+	u_int8_t in_use;        /* PCM in use flag. */
+};
+
+static struct mp200_pcm pcm_ch[MP200_PCM_MAX_CHANNELS] = {
+	{
+		.name = "mp200-pcm0",
+		.base = MP200_PCM0_BASE,
+		.clock_s = MP200_CLOCKGATE_PM0_SCLK,
+		.clock_p = MP200_CLOCKGATE_PM0_CLK,
+		.clkctl = MP200_CLKCTRL_PM0PCLK,
+		.reset = MP200_RESETDEVICE_PM0,
+#ifdef MP200_PCM_INTERRUPT_ENABLE
+		.irq = INT_PCM0,
+#endif
+		.in_use = 0,
+	},
+	{
+		.name = "mp200-pcm1",
+		.base = MP200_PCM1_BASE,
+		.clock_s = MP200_CLOCKGATE_PM1_SCLK,
+		.clock_p = MP200_CLOCKGATE_PM1_CLK,
+		.clkctl = MP200_CLKCTRL_PM1PCLK,
+		.reset = MP200_RESETDEVICE_PM1,
+#ifdef MP200_PCM_INTERRUPT_ENABLE
+		.irq = INT_PCM1,
+#endif
+		.in_use = 0,
+	},
+};
+
+/*
+ * prototypes
+ */
+static int mp200_pcm_hwdep_open(struct snd_hwdep *hw, struct file *file);
+static int mp200_pcm_hwdep_ioctl(struct snd_hwdep *hw, struct file *file,
+				 unsigned int cmd, unsigned long arg);
+static int mp200_pcm_hwdep_release(struct snd_hwdep *hw, struct file *file);
+
+static snd_pcm_uframes_t output_ptr;
+
+/* PDMA Source */
+#ifdef MP200_PCM_USE_PDMA
+
+static pcm_callback_t alsa_pdma_callback = ALSA_PDMA_CALLBACK_VALUE;
+static void *alsa_pdma_data = ALSA_PDMA_DATA_VALUE;
+static int pdma_init = PDMA_INIT_VALUE;
+static int pdma_in_use = PDMA_IN_USE_VALUE;
+
+static void mp200_stop_pdma(void)
+{
+	writel(1, PDMA_END);
+	mp200_pm_pdma_suspend_disable();
+	pdma_init = 0;
+}
+
+static irqreturn_t pdma_callback(int irq, void *data)
+{
+	writel(1, PDMA_INT_REQ_CL);
+	return alsa_pdma_callback(irq, alsa_pdma_data);
+}
+
+static void mp200_pdma_deinit(void)
+{
+	mp200_pmu_reset_device(MP200_RESETDEVICE_PDMA);
+
+	mp200_pmu_close_clockgate(MP200_CLOCKGATE_PDMA_PCLK);
+	mp200_pmu_close_clockgate(MP200_CLOCKGATE_PDMA_HCLK);
+	mp200_pmu_close_clockgate(MP200_CLOCKGATE_PDMA_ACLK);
+}
+
+static void mp200_pdma_init(void)
+{
+	mp200_pmu_open_clockgate(MP200_CLOCKGATE_PDMA_PCLK);
+	mp200_pmu_open_clockgate(MP200_CLOCKGATE_PDMA_HCLK);
+	mp200_pmu_open_clockgate(MP200_CLOCKGATE_PDMA_ACLK);
+
+	mp200_pmu_unreset_device(MP200_RESETDEVICE_PDMA);
+
+	mp200_pmu_clkctrl_on(MP200_CLKCTRL_PDMAPCLK);
+	mp200_pmu_clkctrl_on(MP200_CLKCTRL_PDMAHCK);
+	mp200_pmu_clkctrl_on(MP200_CLKCTRL_PDMAACK);
+}
+
+static int mp200_request_pdma(const char *device_id, pcm_callback_t callback,
+ void *data)
+{
+	int err;
+
+	if (pdma_in_use == 1)
+		return -EBUSY;
+
+	mp200_pmu_clkctrl_off(MP200_CLKCTRL_SRC);
+	err = mp200_pdma_request_irq(pdma_callback, IRQF_DISABLED, device_id,
+	 data, MP200_PCMMODE_ALSA);
+	if (err != 0) {
+		printk(KERN_INFO
+		 "%s(): unable to request IRQ %d for DMA channel (%s)\n",
+		 __func__, INT_PDMA, device_id);
+		return err;
+	}
+
+	alsa_pdma_callback = callback;
+	alsa_pdma_data = data;
+
+	pdma_in_use = 1;
+
+	writel(1, PDMA_DMA_SEL);
+	writel(1, PDMA_INT_ENABLE);
+	pdma_init = 1;
+
+	return 0;
+}
+
+/*
+ * Release DMA channel
+ */
+static void mp200_free_pdma(void)
+{
+	mp200_stop_pdma();
+	mp200_pmu_clkctrl_on(MP200_CLKCTRL_SRC);
+
+	mp200_pdma_free_irq(alsa_pdma_data, MP200_PCMMODE_ALSA);
+
+	pdma_in_use = 0;
+	alsa_pdma_callback = NULL;
+	alsa_pdma_data = NULL;
+}
+
+
+/*
+ * Setup and enable DMA.
+ */
+static int mp200_start_pdma(dma_addr_t src_ptr, u_int size)
+{
+	if (pdma_init == 0) {
+		writel(1, PDMA_DMA_SEL);
+		writel(1, PDMA_INT_ENABLE);
+	}
+
+	mp200_pm_pdma_suspend_enable();
+
+	writel(src_ptr, PDMA_RSV_ADD);
+	writel(size / 4, PDMA_RSV_LENG);
+
+	writel(1, PDMA_CONT);
+
+	return 0;
+}
+
+/*
+ * Acquire DMA channel status.
+ */
+static int mp200_pdma_status(void)
+{
+	unsigned int status;
+
+	status = readl(PDMA_STATUS);
+
+	switch (status) {
+	case 1:
+	case 2:
+		return 1;
+	default:
+		return 0;
+	}
+}
+
+/*
+ * Acquire DMA channel status (register writable flag).
+ */
+static int mp200_pdma_writable_flag(void)
+{
+	unsigned int status;
+
+	status = readl(PDMA_STATUS);
+
+	switch (status) {
+	case 2:
+		return 1;
+	default:
+		return 0;
+	}
+}
+
+static void mp200_clear_pdma(void)
+{
+	mp200_stop_pdma();
+}
+
+dma_addr_t mp200_get_pdma_pos(void)
+{
+	unsigned int pos;
+	unsigned int addr;
+	unsigned int leng;
+	unsigned int state;
+
+	state = readl(PDMA_STATUS);
+	pos = readl(PDMA_RUN_ADP);
+	addr = readl(PDMA_RUN_ADD);
+	leng = readl(PDMA_RUN_LENG) * 4;
+
+	if ((addr <= pos) && (pos < (addr+leng)))
+		;
+	else
+		pos = addr;
+
+	return pos;
+}
+
+static irqreturn_t audio_pdma_callback(int irq, void *data);
+
+#endif
+
+/* DMA staff */
+
+static int audio_dma_request(struct audio_stream *s,
+ void (*callback)(void *, int, int))
+{
+	int ret;
+
+	output_ptr = 0;
+
+#ifdef MP200_PCM_USE_PDMA
+	if (PCM0_TX(s))
+		ret = mp200_request_pdma(s->id, audio_pdma_callback, s);
+	else {
+		ret = mp200_request_dma(s->dma_ch, s->id,
+		 (dma_callback_t)callback, s, &s->dma_regs);
+	}
+#else
+	ret = mp200_request_dma(s->dma_ch, s->id, (dma_callback_t)callback, s,
+	 &s->dma_regs);
+#endif
+	if (ret < 0)
+		printk(KERN_ERR "unable to grab audio dma 0x%x\n", s->dma_ch);
+
+	return ret;
+}
+
+static void audio_dma_free(struct audio_stream *s)
+{
+#ifdef MP200_PCM_USE_PDMA
+	if (PCM0_TX(s))
+		mp200_free_pdma();
+	else
+		mp200_free_dma(s->dma_ch);
+#else
+	mp200_free_dma(s->dma_ch);
+#endif
+	s->dma_regs = 0;
+	return;
+}
+
+static u_int audio_get_dma_pos(struct audio_stream *s)
+{
+	struct snd_pcm_substream *substream = s->stream;
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	unsigned int offset;
+	unsigned int pos;
+	unsigned long flags;
+	dma_addr_t addr;
+
+	spin_lock_irqsave(&s->dma_lock, flags);
+#ifdef MP200_PCM_USE_PDMA
+	if (PCM0_TX(s)) {
+		addr = mp200_get_pdma_pos();
+		if (addr == 0) {
+			/* already stopped. */
+			addr = runtime->dma_addr;
+		}
+	} else {
+		addr = mp200_get_dma_pos(s->dma_ch);
+	}
+#else
+	addr = mp200_get_dma_pos(s->dma_ch);
+#endif
+	offset = addr - runtime->dma_addr;
+	spin_unlock_irqrestore(&s->dma_lock, flags);
+
+	pos = bytes_to_frames(runtime, offset);
+	if (pos >= runtime->buffer_size)
+		pos = 0;
+
+#ifdef MP200_PCM_USE_PDMA
+	if (runtime->status->state == SNDRV_PCM_STATE_DRAINING) {
+		/* special fake code, for stop. */
+		/* warning : if returned pos that it is buffer_size,
+		   not stopped. */
+		pos = frames_to_bytes(runtime,
+		 runtime->control->appl_ptr - runtime->hw_ptr_base);
+	}
+#endif
+	return pos;
+}
+
+/*
+ * this stops the dma and clears the dma ptrs
+ */
+static void audio_stop_dma(struct audio_stream *s)
+{
+	unsigned long flags;
+
+	*s->txrx_dis = s->txrx_id;
+	spin_lock_irqsave(&s->dma_lock, flags);
+	s->active = 0;
+	s->period = 0;
+	output_ptr = 0;
+	/* this stops the dma channel and clears the buffer ptrs */
+#ifdef MP200_PCM_USE_PDMA
+	if (PCM0_TX(s))
+		mp200_clear_pdma();
+	else
+		mp200_clear_dma(s->dma_ch);
+#else
+	mp200_clear_dma(s->dma_ch);
+#endif
+	spin_unlock_irqrestore(&s->dma_lock, flags);
+
+	return;
+}
+
+
+#define ERRMSG_CANNOT_QUEUE "audio_process_dma: cannot queue DMA buffer (%i)\n"
+static void audio_process_dma(struct audio_stream *s)
+{
+	struct snd_pcm_substream *substream = s->stream;
+	struct snd_pcm_runtime *runtime;
+	unsigned int dma_size;
+	unsigned int offset;
+	unsigned int kick = 0;
+	int ret;
+#ifdef MP200_PCM_USE_PDMA
+	unsigned int writable_flag = 0;
+#endif
+
+#if 0
+	/* we are requested to process synchronization DMA transfer */
+	if (s->tx_spin) {
+		snd_assert(s->stream_id == SNDRV_PCM_STREAM_PLAYBACK, return);
+		/* fill the xmit dma buffers and return */
+		while (1) {
+			ret = mp200_start_dma(s->dma_ch, FORCE_CLOCK_ADDR,
+			 FORCE_CLOCK_SIZE, 0, 0);
+			if (ret)
+				return;
+		}
+		return;
+	}
+#endif
+
+#ifdef MP200_PCM_USE_PDMA
+	if (PCM0_TX(s))
+		kick = mp200_pdma_status();
+	else
+		kick = mp200_dma_status(s->dma_ch);
+#else
+	kick = mp200_dma_status(s->dma_ch);
+#endif
+	s->add_period = 0;
+	/* must be set here - only valid for running streams,
+	   not for forced_clock dma fills  */
+	runtime = substream->runtime;
+	while (s->active && s->periods < runtime->periods) {
+		if (!PCM0_TX(s)) {
+			dma_size = frames_to_bytes(runtime,
+			 runtime->period_size);
+			s->add_period = 1;
+		} else {
+			if ((output_ptr != 0)
+			 && (output_ptr >= runtime->control->appl_ptr)) {
+				/* new data not yet transfered from user area.
+				   or data finished. */
+				return;
+			}
+			dma_size = runtime->control->appl_ptr - output_ptr;
+
+#ifdef MP200_PCM_PACK_PELIOD
+#ifdef MP200_PCM_USE_PDMA
+			if ((kick == 1) &&
+				((runtime->status->state
+				  == SNDRV_PCM_STATE_PREPARED)
+				 || (runtime->status->state
+				  == SNDRV_PCM_STATE_RUNNING))) {
+				if (dma_size < runtime->buffer_size/2) {
+					/* pdma if stop then not break? */
+					break;
+				}
+			}
+#endif
+			if (dma_size >= (runtime->buffer_size/2)) {
+				s->add_period =
+				 (runtime->buffer_size/2)/runtime->period_size;
+				if (s->add_period == 0)
+					s->add_period = 1;
+
+				dma_size = runtime->period_size * s->add_period;
+			} else {
+				s->add_period = (dma_size
+				 + (runtime->period_size-1))
+				 /runtime->period_size;
+				if (s->add_period == 0)
+					s->add_period = 1;
+
+			}
+#else
+			if (dma_size > runtime->period_size)
+				dma_size = runtime->period_size;
+			s->add_period = 1;
+#endif
+			dma_size = frames_to_bytes(runtime, dma_size);
+		}
+
+		if (s->old_offset) {
+			/* a little trick, we need resume from old position */
+			offset = frames_to_bytes(runtime, s->old_offset - 1);
+			s->old_offset = 0;
+			s->periods = 0;
+			s->period = offset / dma_size;
+			offset %= dma_size;
+			dma_size = dma_size - offset;
+			if (!dma_size)
+				continue;               /* special case */
+		} else {
+			offset = frames_to_bytes(
+			 runtime, runtime->period_size) * s->period;
+			/* snd_assert(dma_size <= DMA_BUF_SIZE, ); */
+		}
+
+
+
+#ifdef MP200_PCM_USE_PDMA
+		if (PCM0_TX(s))
+			writable_flag = mp200_pdma_writable_flag();
+		else
+			writable_flag = mp200_dma_writable_flag(s->dma_ch);
+
+		if (0 == writable_flag) {
+#else
+		if (0 == mp200_dma_writable_flag(s->dma_ch)) {
+#endif
+			dma_addr_t dma_ptr;
+			dma_addr_t dst_ptr;
+			if (s->txrx_id == PCM_TX_EN) {
+				dma_ptr = runtime->dma_addr + offset;
+				dst_ptr = s->phys_xq;
+#ifdef MP200_PCM_USE_PDMA
+				if (!PCM0_TX(s)) {
+					s->dma_regs->aoff = 0;
+					s->dma_regs->asize = dma_size;
+					s->dma_regs->leng = dma_size;
+					s->dma_regs->mode =
+					 (MP200_DMAC_AMODE_BIT32
+					  | MP200_DMAC_ENDI_R1032
+					  | MP200_DMAC_ENDI_W3210);
+				}
+#else
+				s->dma_regs->aoff = 0;
+				s->dma_regs->asize = dma_size;
+				s->dma_regs->leng = dma_size;
+				s->dma_regs->mode = (MP200_DMAC_AMODE_BIT32
+						     | MP200_DMAC_ENDI_R1032
+						     | MP200_DMAC_ENDI_W3210);
+#endif
+			} else {
+				dma_ptr = s->phys_xq;
+				dst_ptr = runtime->dma_addr + offset;
+				s->dma_regs->boff = 0;
+				s->dma_regs->bsize = dma_size;
+				s->dma_regs->leng = dma_size;
+#ifdef MP200_PCM_USE_PDMA
+				s->dma_regs->mode = (MP200_DMAC_AMODE_BIT32
+						     | MP200_DMAC_ENDI_R3210
+						     | MP200_DMAC_ENDI_W3210);
+#else
+				s->dma_regs->mode = (MP200_DMAC_AMODE_BIT32
+						     | MP200_DMAC_ENDI_R3210
+						     | MP200_DMAC_ENDI_W1032);
+#endif
+			}
+
+#ifdef MP200_PCM_USE_PDMA
+			if (PCM0_TX(s)) {
+				ret = mp200_start_pdma(dma_ptr, dma_size);
+			} else {
+				ret = mp200_start_dma(s->dma_ch,
+						      dma_ptr,
+						      0,
+						      dst_ptr,
+						      MP200_DMAC_INT_LENG_EN);
+			}
+#else
+			ret = mp200_start_dma(s->dma_ch,
+					      dma_ptr,
+					      0,
+					      dst_ptr,
+					      MP200_DMAC_INT_LENG_EN);
+#endif
+			if (ret) {
+				s->add_period = 0;
+				printk(KERN_ERR ERRMSG_CANNOT_QUEUE, ret);
+				return;
+			}
+			output_ptr += bytes_to_frames(runtime, dma_size);
+			if (0 == kick) {
+				*s->txrx_en = s->txrx_id;
+				udelay(50);     /* LRCLK1 22u: x2+a = 50 */
+				kick = 1;
+			}
+
+		} else {
+			s->add_period = 0;
+			break;
+		}
+
+		s->period += s->add_period;
+		s->period %= runtime->periods;
+		s->periods += s->add_period;
+	}
+
+	return;
+}
+
+static void audio_dma_callback(void *data, int intsts, int intrawsts)
+{
+	struct audio_stream *s = data;
+
+	/*
+	 * If we are getting a callback for an active stream then we inform
+	 * the PCM middle layer we've finished a period
+	 */
+	if (s->active)
+		snd_pcm_period_elapsed(s->stream);
+
+	spin_lock(&s->dma_lock);
+	if (!s->tx_spin && s->periods > 0)
+		s->periods -= s->add_period;
+	audio_process_dma(s);
+	spin_unlock(&s->dma_lock);
+
+	return;
+}
+
+#ifdef MP200_PCM_USE_PDMA
+static irqreturn_t audio_pdma_callback(int irq, void *data)
+{
+	struct audio_stream *s = data;
+	struct snd_pcm_substream *substream = s->stream;
+	struct snd_pcm_runtime *runtime = substream->runtime;
+
+	/*
+	 * If we are getting a callback for an active stream then we inform
+	 * the PCM middle layer we've finished a period
+	 */
+	if (s->active)
+		snd_pcm_period_elapsed(s->stream);
+
+	spin_lock(&s->dma_lock);
+	if (output_ptr != runtime->control->appl_ptr) {
+		if (!s->tx_spin && s->periods > 0)
+			s->periods -= s->add_period;
+		audio_process_dma(s);
+	}
+	spin_unlock(&s->dma_lock);
+
+	return IRQ_HANDLED;
+}
+#endif
+
+/* PCM setting */
+
+/* HW params & free */
+
+static const struct snd_pcm_hardware mp200_pcm_hardware = {
+	.info                   = (SNDRV_PCM_INFO_INTERLEAVED |
+				   SNDRV_PCM_INFO_BLOCK_TRANSFER |
+				   SNDRV_PCM_INFO_MMAP |
+				   SNDRV_PCM_INFO_MMAP_VALID |
+				   SNDRV_PCM_INFO_PAUSE |
+				   SNDRV_PCM_INFO_RESUME),
+
+#if defined(MP200_PCM_USE_PDMA)
+	.formats = SNDRV_PCM_FMTBIT_S32_LE,
+#else
+	.formats = SNDRV_PCM_FMTBIT_S16_LE,
+#endif
+
+
+#ifdef MP200_PCM_USE_PDMA
+	.buffer_bytes_max       = 128 * 1024,
+	.period_bytes_min       = 64,
+	.period_bytes_max       = 0x10000,
+	.periods_min            = 2,
+	.periods_max            = 32,
+#else
+	.buffer_bytes_max       = 0xFFFE * 16,
+	.period_bytes_min       = 64,
+	.period_bytes_max       = 0xFFFE,
+	.periods_min            = 2,
+	.periods_max            = 16,
+#endif
+	.fifo_size              = 32,
+};
+
+#ifdef MP200_PCM_INTERRUPT_ENABLE
+
+#include <linux/interrupt.h>
+
+/* PMx_INT Masks */
+#define PCM_INT_TX_FRE          0x01
+#define PCM_INT_TX_URE          0x02
+#define PCM_INT_TX_ORE          0x04
+#define PCM_INT_TX_WEN          0x08
+#define PCM_INT_RX_FRE          0x10
+#define PCM_INT_RX_URE          0x20
+#define PCM_INT_RX_ORE          0x40
+#define PCM_INT_RX_REN          0x80
+#define PCM_INT_TX_STP          (1 << 8)
+#define PCM_INT_RX_STP          (1 << 12)
+
+static void mp200_pcm_kick(unsigned long inData)
+{
+	struct audio_stream *s = (struct audio_stream *)inData;
+	struct mp200_pcm_client *chip = snd_pcm_substream_chip(s->stream);
+	int wait, mode, val, status;
+
+	mode = *s->func_sel &  (MP200_PCM_FUNC_MODE0 |
+				MP200_PCM_FUNC_MODE1 |
+				MP200_PCM_FUNC_MODE2 |
+				MP200_PCM_FUNC_MODE3 |
+				MP200_PCM_FUNC_MODE4 |
+				MP200_PCM_FUNC_MODE5 |
+				MP200_PCM_FUNC_MODE6);
+
+	switch (mode) {
+	case MP200_PCM_FUNC_MODE5:
+	case MP200_PCM_FUNC_MODE6:
+		val = (((chip->pcm_regs->cycle & 0xff) *
+			(((chip->pcm_regs->cycle >> 8) & 0x1f) + 1)) +
+		       ((chip->pcm_regs->cycle2 & 0xff) *
+			(((chip->pcm_regs->cycle >> 8) & 0x1f) + 1)));
+		break;
+	/* mode0-4 */
+	default:
+		val = (chip->pcm_regs->cycle & 0xff) + 1;
+		break;
+	}
+
+	wait = (((1000000 / s->stream->runtime->rate) * val) +
+		((1000000 % s->stream->runtime->rate) ? 1 : 0));
+
+	udelay(wait);
+
+#ifdef MP200_PCM_USE_PDMA
+	if (PCM0_TX(s)) {
+		if (s->stream->runtime->status->state
+		 == SNDRV_PCM_STATE_RUNNING) {
+			status = 1;
+		} else
+			status = 0;
+
+	} else {
+		status = mp200_dma_status(s->dma_ch);
+	}
+#else
+	status = mp200_dma_status(s->dma_ch);
+#endif
+	if (1 == status) {
+		*s->txrx_en = s->txrx_id;
+	} else {
+		unsigned long flags;
+
+		local_irq_save(flags);
+		audio_stop_dma(s);
+		audio_process_dma(s);
+		local_irq_restore(flags);
+	}
+
+	return;
+}
+
+DECLARE_TASKLET(mp200_pcm_tx_tasklet, mp200_pcm_kick, 0);
+DECLARE_TASKLET(mp200_pcm_rx_tasklet, mp200_pcm_kick, 0);
+
+static irqreturn_t audio_pcm_callback(int irq, void *dev_id)
+{
+	struct snd_pcm *pcm = (struct snd_pcm *) dev_id;
+	struct mp200_pcm_client *chip = pcm->private_data;
+	static irqreturn_t ret = IRQ_NONE;
+
+	if (chip->pcm_regs->status & ~(PCM_INT_TX_FRE | PCM_INT_TX_URE |
+				       PCM_INT_TX_ORE | PCM_INT_RX_FRE |
+				       PCM_INT_RX_URE | PCM_INT_RX_ORE)) {
+
+		chip->pcm_regs->clear = chip->pcm_regs->status;
+		chip->pcm_regs->txrx_dis = PCM_TX_EN | PCM_RX_EN;
+
+		printk(KERN_INFO "%s(): unable to pcm status 0x%08x\n",
+		       __func__, chip->pcm_regs->status);
+		return ret;
+	}
+
+	if (chip->pcm_regs->status & (PCM_INT_TX_FRE | PCM_INT_TX_URE
+	 | PCM_INT_TX_ORE)) {
+
+		chip->pcm_regs->clear = PCM_INT_TX_FRE | PCM_INT_TX_URE |
+					PCM_INT_TX_STP;
+		chip->pcm_regs->txrx_dis = PCM_TX_EN;
+
+		if (chip->s[SNDRV_PCM_STREAM_PLAYBACK]) {
+			struct audio_stream *s;
+
+			s = chip->s[SNDRV_PCM_STREAM_PLAYBACK];
+			if (s->active) {
+				mp200_pcm_tx_tasklet.data = (unsigned long)s;
+				tasklet_schedule(&mp200_pcm_tx_tasklet);
+			}
+			ret = IRQ_HANDLED;
+		} else {
+			printk(KERN_INFO "%s(): unable to pcm tx status 0x%08x\n",
+			       __func__, chip->pcm_regs->status);
+			return ret;
+		}
+	}
+	if (chip->pcm_regs->status & (PCM_INT_RX_FRE | PCM_INT_RX_URE
+	 | PCM_INT_RX_ORE)) {
+
+		chip->pcm_regs->clear = PCM_INT_RX_FRE | PCM_INT_RX_STP;
+		chip->pcm_regs->txrx_dis = PCM_RX_EN;
+
+		if (chip->s[SNDRV_PCM_STREAM_CAPTURE]) {
+			struct audio_stream *s;
+
+			s = chip->s[SNDRV_PCM_STREAM_CAPTURE];
+			if (s->active) {
+				mp200_pcm_rx_tasklet.data = (unsigned long)s;
+				tasklet_schedule(&mp200_pcm_rx_tasklet);
+			}
+			ret = IRQ_HANDLED;
+		} else {
+			printk(KERN_INFO "%s(): unable to pcm rx status 0x%08x\n",
+			       __func__, chip->pcm_regs->status);
+			return ret;
+		}
+	}
+
+	return ret;
+}
+#endif
+
+static int mp200_pcm_hw_params(struct snd_pcm_substream *substream,
+			       struct snd_pcm_hw_params *hw_params)
+{
+#ifdef MP200_PCM_USE_PDMA
+	int ret = 0;
+
+	struct mp200_pcm_client *chip = snd_pcm_substream_chip(substream);
+	if (PCM0_TX(chip->s[substream->pstr->stream])) {
+		struct snd_pcm_runtime *runtime = substream->runtime;
+
+		snd_pcm_set_runtime_buffer(substream, &substream->dma_buffer);
+		runtime->dma_bytes = params_buffer_bytes(hw_params);
+	} else {
+		ret = snd_pcm_lib_malloc_pages(substream,
+					       params_buffer_bytes(hw_params));
+	}
+	return ret;
+#else
+	int ret;
+	ret = snd_pcm_lib_malloc_pages(substream,
+	 params_buffer_bytes(hw_params));
+	return ret;
+#endif
+}
+
+static int mp200_pcm_hw_free(struct snd_pcm_substream *substream)
+{
+#ifdef MP200_PCM_USE_PDMA
+	int ret = 0;
+
+	struct mp200_pcm_client *chip = snd_pcm_substream_chip(substream);
+	if (PCM0_TX(chip->s[substream->pstr->stream]))
+		snd_pcm_set_runtime_buffer(substream, NULL);
+	else
+		ret = snd_pcm_lib_free_pages(substream);
+	return ret;
+#else
+	int ret;
+	ret = snd_pcm_lib_free_pages(substream);
+	return ret;
+#endif
+}
+
+/* trigger & timer */
+
+static int mp200_pcm_trigger(struct snd_pcm_substream *substream, int cmd)
+{
+	struct mp200_pcm_client *chip = snd_pcm_substream_chip(substream);
+	int stream_id = substream->pstr->stream;
+	struct audio_stream *s = chip->s[stream_id];
+	int err = 0;
+
+	/* note local interrupts are already disabled in the midlevel code */
+	spin_lock(&s->dma_lock);
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+		/* requested stream startup */
+		s->active = 1;
+		audio_process_dma(s);
+		break;
+	case SNDRV_PCM_TRIGGER_STOP:
+		/* requested stream shutdown */
+		audio_stop_dma(s);
+		break;
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+		s->active = 0;
+
+#ifdef MP200_PCM_USE_PDMA
+		if (PCM0_TX(s))
+			mp200_stop_pdma();
+		else
+			mp200_stop_dma(s->dma_ch);
+#else
+		mp200_stop_dma(s->dma_ch);
+#endif
+		s->old_offset = audio_get_dma_pos(s) + 1;
+		s->periods = 0;
+		break;
+	case SNDRV_PCM_TRIGGER_RESUME:
+		s->active = 1;
+		s->tx_spin = 0;
+		audio_process_dma(s);
+		break;
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+#ifdef MP200_PCM_USE_PDMA
+		if (PCM0_TX(s))
+			mp200_stop_pdma();
+		else
+			mp200_stop_dma(s->dma_ch);
+#else
+		mp200_stop_dma(s->dma_ch);
+#endif
+		s->active = 0;
+		break;
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		s->active = 1;
+		if (s->old_offset) {
+			s->tx_spin = 0;
+			audio_process_dma(s);
+			break;
+		}
+		break;
+	default:
+		err = -EINVAL;
+		break;
+	}
+	spin_unlock(&s->dma_lock);
+	return err;
+}
+
+static int mp200_pcm_prepare(struct snd_pcm_substream *substream)
+{
+	struct mp200_pcm_client *chip = snd_pcm_substream_chip(substream);
+	struct audio_stream *s = chip->s[substream->pstr->stream];
+
+	s->period = 0;
+	s->periods = 0;
+
+	/* set requested samplerate */
+	return chip->prepare(substream);
+}
+
+static snd_pcm_uframes_t mp200_pcm_pointer(struct snd_pcm_substream *substream)
+{
+	struct mp200_pcm_client *chip = snd_pcm_substream_chip(substream);
+	struct audio_stream *s = chip->s[substream->pstr->stream];
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	snd_pcm_uframes_t ret;
+
+	spin_lock(&s->dma_lock);
+	if (output_ptr != runtime->control->appl_ptr) {
+		if (!s->tx_spin && s->periods > 0)
+			s->periods -= s->add_period;
+		audio_process_dma(s);
+	}
+	spin_unlock(&s->dma_lock);
+
+	ret = audio_get_dma_pos(chip->s[substream->pstr->stream]);
+	return ret;
+}
+
+#ifdef MP200_PCM_MMAP_ENABLE
+static int mp200_pcm_mmap(struct snd_pcm_substream *substream,
+ struct vm_area_struct *vma)
+{
+	int ret;
+	struct snd_pcm_runtime *runtime = substream->runtime;
+
+#ifdef MP200_PCM_USE_PDMA
+	struct mp200_pcm_client *chip = snd_pcm_substream_chip(substream);
+
+	if (PCM0_TX(chip->s[substream->pstr->stream])) {
+		unsigned long user_size;
+		user_size = (vma->vm_end - vma->vm_start) >> PAGE_SHIFT;
+
+		vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
+		ret = remap_pfn_range(vma, vma->vm_start,
+		 (runtime->dma_addr >> PAGE_SHIFT) + vma->vm_pgoff,
+		 runtime->dma_bytes, vma->vm_page_prot);
+	} else {
+		ret = dma_mmap_writecombine(substream->pcm->card->dev, vma,
+					    runtime->dma_area,
+					    runtime->dma_addr,
+					    runtime->dma_bytes);
+	}
+#else
+	ret = dma_mmap_writecombine(substream->pcm->card->dev, vma,
+				    runtime->dma_area,
+				    runtime->dma_addr,
+				    runtime->dma_bytes);
+#endif
+
+	return ret;
+}
+#endif
+
+static int mp200_pcm_open(struct snd_pcm_substream *substream)
+{
+	struct mp200_pcm_client *chip = snd_pcm_substream_chip(substream);
+	int ret;
+	unsigned long flags;
+
+#ifdef MP200_PCM_USE_PDMA
+	if (IS_PCM0(pcm_ch[chip->pcm_ch])) {
+		ret  = mp200_pcm0_request_irq(audio_pcm_callback, IRQF_DISABLED,
+		 pcm_ch[chip->pcm_ch].name, (void *)pcm_ch[chip->pcm_ch].pcm,
+		 MP200_PCMMODE_ALSA);
+
+		if (ret != 0) {
+			printk(KERN_INFO "error request_irq = %d\n", ret);
+			return ret;
+		}
+		disable_irq(pcm_ch[chip->pcm_ch].irq);
+
+		if (PCM0_TX(chip->s[substream->pstr->stream])) {
+			mp200_pdma_deinit();
+			mp200_pdma_init();
+		} else {
+			writel(0, PDMA_DMA_SEL);
+		}
+	}
+#endif
+
+	chip->s[substream->pstr->stream]->stream = substream;
+
+	substream->runtime->hw = mp200_pcm_hardware;
+
+	local_irq_save(flags);
+	power_flag++;
+	local_irq_restore(flags);
+
+	ret = chip->startup(substream);
+	if (ret < 0)
+		goto err1;
+
+	ret = audio_dma_request(chip->s[substream->pstr->stream],
+				audio_dma_callback);
+	if (ret < 0)
+		goto err2;
+
+#ifdef MP200_PCM_INTERRUPT_ENABLE
+	if (chip->s[substream->pstr->stream]->txrx_id == PCM_TX_EN) {
+		chip->pcm_regs->enset = PCM_INT_TX_FRE | PCM_INT_TX_URE
+		 | PCM_INT_TX_ORE;
+	} else {
+		chip->pcm_regs->enset = PCM_INT_RX_FRE | PCM_INT_RX_URE
+		 | PCM_INT_RX_ORE;
+	}
+	enable_irq(pcm_ch[chip->pcm_ch].irq);
+#endif
+
+	return ret;
+err2:
+	chip->shutdown(substream);
+err1:
+	local_irq_save(flags);
+	power_flag--;
+	local_irq_restore(flags);
+
+	chip->s[substream->pstr->stream]->stream = NULL;
+#ifdef MP200_PCM_USE_PDMA
+	if (IS_PCM0(pcm_ch[chip->pcm_ch])) {
+		mp200_pcm0_free_irq((void *)pcm_ch[chip->pcm_ch].pcm,
+				    MP200_PCMMODE_ALSA);
+	}
+#endif
+	return ret;
+}
+
+static int mp200_pcm_close(struct snd_pcm_substream *substream)
+{
+	struct mp200_pcm_client *chip = snd_pcm_substream_chip(substream);
+	unsigned long flags;
+
+	audio_dma_free(chip->s[substream->pstr->stream]);
+
+#ifdef MP200_PCM_INTERRUPT_ENABLE
+	disable_irq(pcm_ch[chip->pcm_ch].irq);
+#ifdef MP200_PCM_USE_PDMA
+	if (IS_PCM0(pcm_ch[chip->pcm_ch])) {
+		mp200_pdma_deinit();
+		mp200_pdma_init();
+		mp200_pcm0_free_irq((void *)pcm_ch[chip->pcm_ch].pcm,
+				    MP200_PCMMODE_ALSA);
+	}
+#endif
+	if (chip->s[substream->pstr->stream]->txrx_id == PCM_TX_EN) {
+		chip->pcm_regs->enclr = PCM_INT_TX_FRE | PCM_INT_TX_URE |
+					PCM_INT_TX_ORE | PCM_INT_TX_WEN |
+					PCM_INT_TX_STP;
+		chip->pcm_regs->clear = PCM_INT_TX_FRE | PCM_INT_TX_URE |
+					PCM_INT_TX_STP;
+	} else {
+		chip->pcm_regs->enclr = PCM_INT_RX_FRE | PCM_INT_RX_URE |
+					PCM_INT_RX_ORE | PCM_INT_RX_REN |
+					PCM_INT_RX_STP;
+		chip->pcm_regs->clear = PCM_INT_RX_FRE | PCM_INT_RX_STP;
+	}
+#endif
+
+	chip->shutdown(substream);
+
+	local_irq_save(flags);
+	power_flag--;
+	local_irq_restore(flags);
+
+	chip->s[substream->pstr->stream]->stream = NULL;
+
+	return 0;
+}
+
+static struct snd_pcm_ops mp200_pcm_ops = {
+	.open           = mp200_pcm_open,
+	.close          = mp200_pcm_close,
+	.ioctl          = snd_pcm_lib_ioctl,
+	.hw_params      = mp200_pcm_hw_params,
+	.hw_free        = mp200_pcm_hw_free,
+	.prepare        = mp200_pcm_prepare,
+	.trigger        = mp200_pcm_trigger,
+	.pointer        = mp200_pcm_pointer,
+#ifdef MP200_PCM_MMAP_ENABLE
+	.mmap           = mp200_pcm_mmap,
+#endif
+};
+
+#ifdef CONFIG_PM
+int mp200_pcm_suspend(struct platform_device *dev, pm_message_t state)
+{
+	switch (state.event) {
+	case DEV_SUSPEND_IDLE_1:
+	case PM_EVENT_SUSPEND:
+		if (power_flag != 0) {
+#ifdef MP200_PCM_USE_PDMA
+			if ((pdma_in_use) && (power_flag == 1))
+				break;
+#endif
+			printk(KERN_INFO "pcm busy\n");
+			return -EBUSY;
+		}
+		break;
+	default:
+		break;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(mp200_pcm_suspend);
+
+int mp200_pcm_resume(struct platform_device *dev)
+{
+	return 0;
+}
+EXPORT_SYMBOL(mp200_pcm_resume);
+
+#endif
+
+int mp200_pcm_free(struct mp200_pcm_client *client)
+{
+	int i;
+
+	if (pcm_ch[client->pcm_ch].in_use) {
+#ifdef MP200_PCM_INTERRUPT_ENABLE
+#ifdef MP200_PCM_USE_PDMA
+		if (!IS_PCM0(pcm_ch[client->pcm_ch])) {
+			free_irq(pcm_ch[client->pcm_ch].irq,
+				 (void *)pcm_ch[client->pcm_ch].pcm);
+		}
+#else
+		free_irq(pcm_ch[client->pcm_ch].irq,
+			 (void *)pcm_ch[client->pcm_ch].pcm);
+#endif
+#endif
+		mp200_pmu_clkctrl_off(pcm_ch[client->pcm_ch].clkctl);
+		mp200_pmu_reset_device(pcm_ch[client->pcm_ch].reset);
+		mp200_pmu_close_clockgate(pcm_ch[client->pcm_ch].clock_s);
+		mp200_pmu_close_clockgate(pcm_ch[client->pcm_ch].clock_p);
+		pcm_ch[client->pcm_ch].in_use = 0;
+	}
+
+	for (i = 0; i < MP200_PCM_MAX_CHANNELS; i++) {
+		if (pcm_ch[i].in_use)
+			break;
+	}
+
+	if (i == MP200_PCM_MAX_CHANNELS)
+		mp200_pmu_close_clockgate(MP200_CLOCKGATE_PM0_PCLK);
+
+	return 0;
+}
+EXPORT_SYMBOL(mp200_pcm_free);
+
+
+#ifdef MP200_PCM_USE_PDMA
+static int mp200_pcm_preallocate_dma_buffer(struct snd_pcm *pcm, int stream,
+					    unsigned long addr, size_t size)
+{
+	struct snd_pcm_substream *substream = pcm->streams[stream].substream;
+	struct snd_dma_buffer *buf = &substream->dma_buffer;
+	buf->dev.type = SNDRV_DMA_TYPE_DEV;
+	buf->dev.dev = pcm->card->dev;
+	buf->private_data = NULL;
+
+	buf->addr = addr;
+	buf->area = ioremap_nocache(buf->addr, size);
+	if (!buf->area)
+		return -ENOMEM;
+	buf->bytes = size;
+
+	return 0;
+}
+#endif
+
+int mp200_pcm_new(struct snd_card *card, struct mp200_pcm_client *client,
+ struct snd_pcm **rpcm)
+{
+	struct snd_hwdep *hw;
+	struct snd_pcm *pcm;
+	int play = client->s[SNDRV_PCM_STREAM_PLAYBACK] ? 1 : 0;
+	int capt = client->s[SNDRV_PCM_STREAM_CAPTURE] ? 1 : 0;
+	int ret = -EBUSY;
+
+	if (pcm_ch[client->pcm_ch].in_use)
+		goto out;
+
+	ret = snd_hwdep_new(card, pcm_ch[client->pcm_ch].name, client->pcm_ch,
+	 &hw);
+
+	if (ret)
+		goto out;
+
+	hw->private_data = client;
+
+	hw->ops.open = mp200_pcm_hwdep_open;
+	hw->ops.ioctl = mp200_pcm_hwdep_ioctl;
+	hw->ops.release = mp200_pcm_hwdep_release;
+
+	ret = snd_pcm_new(card, pcm_ch[client->pcm_ch].name, client->pcm_ch,
+	 play, capt, &pcm);
+
+	if (ret)
+		goto out;
+
+#ifdef MP200_PCM_USE_PDMA
+	if (!IS_PCM0(pcm_ch[client->pcm_ch])) {
+		snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,
+		 NULL, 128 * 1024, 128 * 1024);
+	}
+#else
+	snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,
+					      /* snd_pcm_dma_flags(0)*/ NULL,
+					      128 * 1024, 128 * 1024);
+#endif
+	pcm->private_data = client;
+
+	client->pcm_regs = (struct pcm_regs *)IO_ADDRESS(
+	 pcm_ch[client->pcm_ch].base);
+
+	if (play) {
+		int stream = SNDRV_PCM_STREAM_PLAYBACK;
+		struct snd_pcm_substream *substream;
+		struct audio_stream *s = client->s[stream];
+
+		snd_pcm_set_ops(pcm, stream, &mp200_pcm_ops);
+		substream = pcm->streams[stream].substream;
+#ifdef MP200_PCM_USE_PDMA
+		if (IS_PCM0(pcm_ch[client->pcm_ch])) {
+			/* BANK 10 -- SRAM */
+			ret = mp200_pcm_preallocate_dma_buffer(pcm, stream,
+			 SRAM_BASE, SRAM_SIZE);
+			if (ret)
+				goto out;
+		}
+#endif
+		strncpy(substream->name, client->s[stream]->id,
+		 sizeof(substream->name));
+		s->phys_xq = (dma_addr_t)&(
+		 (struct pcm_regs *)pcm_ch[client->pcm_ch].base)->txq;
+		s->txrx_id = PCM_TX_EN;
+		s->txrx_en = &client->pcm_regs->txrx_en;
+		s->txrx_dis = &client->pcm_regs->txrx_dis;
+#ifdef MP200_PCM_INTERRUPT_ENABLE
+		s->func_sel = &client->pcm_regs->func_sel;
+#endif
+		spin_lock_init(&s->dma_lock);
+	}
+	if (capt) {
+		int stream = SNDRV_PCM_STREAM_CAPTURE;
+		struct snd_pcm_substream *substream;
+		struct audio_stream *s = client->s[stream];
+
+		snd_pcm_set_ops(pcm, stream, &mp200_pcm_ops);
+		substream = pcm->streams[stream].substream;
+#ifdef MP200_PCM_USE_PDMA
+		if (IS_PCM0(pcm_ch[client->pcm_ch])) {
+			ret = snd_pcm_lib_preallocate_pages(substream,
+			 SNDRV_DMA_TYPE_DEV, NULL, 64 * 1024, 64 * 1024);
+			if (ret)
+				goto out;
+		}
+#endif
+		strncpy(substream->name, client->s[stream]->id,
+		 sizeof(substream->name));
+		s->phys_xq = (dma_addr_t)&(
+		 (struct pcm_regs *)pcm_ch[client->pcm_ch].base)->rxq;
+		s->txrx_id = PCM_RX_EN;
+		s->txrx_en = &client->pcm_regs->txrx_en;
+		s->txrx_dis = &client->pcm_regs->txrx_dis;
+#ifdef MP200_PCM_INTERRUPT_ENABLE
+		s->func_sel = &client->pcm_regs->func_sel;
+#endif
+		spin_lock_init(&s->dma_lock);
+	}
+
+	if (rpcm)
+		*rpcm = pcm;
+
+	mp200_pmu_open_clockgate(MP200_CLOCKGATE_PM0_PCLK);
+	mp200_pmu_open_clockgate(pcm_ch[client->pcm_ch].clock_p);
+	mp200_pmu_open_clockgate(pcm_ch[client->pcm_ch].clock_s);
+	mp200_pmu_clkctrl_off(pcm_ch[client->pcm_ch].clkctl);
+	mp200_pmu_unreset_device(pcm_ch[client->pcm_ch].reset);
+	mp200_pmu_clkctrl_on(pcm_ch[client->pcm_ch].clkctl);
+	mp200_pmu_close_clockgate(pcm_ch[client->pcm_ch].clock_s);
+#ifdef MP200_PCM_INTERRUPT_ENABLE
+	client->pcm_regs->enclr = PCM_INT_TX_FRE | PCM_INT_TX_URE |
+				  PCM_INT_TX_ORE | PCM_INT_TX_WEN |
+				  PCM_INT_RX_FRE | PCM_INT_RX_URE |
+				  PCM_INT_RX_ORE | PCM_INT_RX_REN |
+				  PCM_INT_TX_STP | PCM_INT_RX_STP;
+	client->pcm_regs->clear = PCM_INT_TX_FRE | PCM_INT_TX_URE |
+				  PCM_INT_RX_FRE |
+				  PCM_INT_TX_STP | PCM_INT_RX_STP;
+	client->pcm_regs->txrx_dis = PCM_TX_EN | PCM_RX_EN;
+
+#ifdef MP200_PCM_USE_PDMA
+	if (!IS_PCM0(pcm_ch[client->pcm_ch])) {
+		ret = request_irq(pcm_ch[client->pcm_ch].irq,
+				  audio_pcm_callback, IRQF_DISABLED,
+				  pcm_ch[client->pcm_ch].name, (void *)pcm);
+
+		disable_irq(pcm_ch[client->pcm_ch].irq);
+	}
+#else
+	ret = request_irq(pcm_ch[client->pcm_ch].irq,
+			  audio_pcm_callback, IRQF_DISABLED,
+			  pcm_ch[client->pcm_ch].name, (void *)pcm);
+
+	disable_irq(pcm_ch[client->pcm_ch].irq);
+#endif
+	pcm_ch[client->pcm_ch].pcm = pcm;
+#endif
+
+	if (0 == ret)
+		pcm_ch[client->pcm_ch].in_use = 1;
+out:
+	return ret;
+}
+EXPORT_SYMBOL(mp200_pcm_new);
+
+
+static int mp200_pcm_hwdep_open(struct snd_hwdep *hw, struct file *file)
+{
+	return 0;
+}
+
+static int mp200_pcm_hwdep_ioctl(struct snd_hwdep *hw, struct file *file,
+				 unsigned int cmd, unsigned long arg)
+{
+	struct mp200_pcm_client *chip = hw->private_data;
+	pcm_ctrl_t sett;
+	int ret = 0;
+
+	/* dispatch based on command */
+	switch (cmd) {
+	case SNDRV_MP200_IOCTL_PCM_SET_CTRL:
+		if (copy_from_user(&sett, (pcm_ctrl_t *) arg, sizeof(sett))
+		 != 0)
+			return -EFAULT;
+
+		ret = mp200_pcm_set_ctrl(chip->pcm_regs, &sett);
+
+		if (ret < 0)
+			return ret;
+
+		*chip->sett = sett;
+
+		return ret;
+
+	case SNDRV_MP200_IOCTL_PCM_GET_CTRL:
+		sett = *chip->sett;
+		return copy_to_user((void *)arg, &sett, sizeof(sett));
+
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int mp200_pcm_hwdep_release(struct snd_hwdep *hw, struct file *file)
+{
+	return 0;
+}
+
+int mp200_pcm_set_ctrl(struct pcm_regs *regs, pcm_ctrl_t *s)
+{
+	pcm_ctrl_t *sett = s;
+	unsigned int func_val = 0;
+	unsigned int cycle_val = 0;
+	unsigned int cycle2_val = 0;
+
+	if (sett == NULL)
+		return -EINVAL;
+
+	/* mode_sel : Operation mode */
+	switch (sett->func.mode_sel) {
+	case PCM_MODE_0:        /* mode 0 */
+		func_val |= MP200_PCM_FUNC_MODE0;
+		break;
+	case PCM_MODE_1:        /* mode 1 */
+		func_val |= MP200_PCM_FUNC_MODE1;
+		break;
+	case PCM_MODE_2:        /* mode 2 (I2S Format) */
+		func_val |= MP200_PCM_FUNC_MODE2;
+		break;
+	case PCM_MODE_3:        /* mode 3 (MSB First)  */
+		func_val |= MP200_PCM_FUNC_MODE3;
+		break;
+	case PCM_MODE_4:        /* mode 4 (LSB First)  */
+		func_val = MP200_PCM_FUNC_MODE4;
+		break;
+	case PCM_MODE_5:        /* mode 5 (Multi Channel Mode) */
+		func_val |= MP200_PCM_FUNC_MODE5;
+		break;
+	case PCM_MODE_6:        /* mode 6 (Multi Channel Mode) */
+		func_val |= MP200_PCM_FUNC_MODE6;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	/* m_s : Master/Slave */
+	switch (sett->func.m_s) {
+	case PCM_MASTER_MODE:   /* Master */
+		func_val |= MP200_PCM_FUNC_MASTER;
+		break;
+	case PCM_SLAVE_MODE:    /* Slave  */
+		func_val |= MP200_PCM_FUNC_SLAVE;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	/* tx_tim : Transmission timing */
+	switch (sett->func.tx_tim) {
+	case PCM_TX_30_WORD:    /* 30word */
+		func_val |= MP200_PCM_FUNC_30WORD;
+		break;
+	case PCM_TX_16_WORD:    /* 16word */
+		func_val |= MP200_PCM_FUNC_16WORD;
+		break;
+	case PCM_TX_08_WORD:    /*  8word */
+		func_val |= MP200_PCM_FUNC_08WORD;
+		break;
+	case PCM_TX_04_WORD:    /*  4word */
+		func_val |= MP200_PCM_FUNC_04WORD;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	switch (sett->func.mode_sel) {
+	case PCM_MODE_0:        /* mode 0 */
+	case PCM_MODE_1:        /* mode 1 */
+	case PCM_MODE_2:        /* mode 2 (I2S Format) */
+	case PCM_MODE_3:        /* mode 3 (MSB First)  */
+	case PCM_MODE_4:        /* mode 4 (LSB First)  */
+		/* cyc_val : Frame length */
+		if ((0x3f < sett->cyc.cyc_val) || (sett->cyc.cyc_val < 0x07))
+			return -EINVAL;
+
+		if ((sett->cyc.cyc_val < sett->cyc.sib)
+		    || (sett->cyc.cyc_val < sett->cyc.sob)) {
+			return -EINVAL;
+		}
+		cycle_val |= sett->cyc.cyc_val;
+
+		/* sib : Data bit length (PMx_SI) */
+		if ((0x1f < sett->cyc.sib) || (sett->cyc.sib < 0x07))
+			return -EINVAL;
+
+		cycle_val |= sett->cyc.sib << 8;
+
+		/* rx_pd : Data padding (RX) */
+		if ((sett->cyc.rx_pd != PCM_PADDING_OFF)
+		    && (sett->cyc.rx_pd != PCM_PADDING_ON)) {
+			return -EINVAL;
+		}
+		if (sett->cyc.rx_pd == PCM_PADDING_ON)
+			cycle_val |= sett->cyc.rx_pd << 15;
+
+		/* sob : Data bit length (PMx_SO) */
+		if ((0x1f < sett->cyc.sob) || (sett->cyc.sob < 0x07))
+			return -EINVAL;
+
+		cycle_val |= sett->cyc.sob << 16;
+
+		/* tx_pd : Data padding (TX) */
+		if ((sett->cyc.tx_pd != PCM_PADDING_OFF)
+		    && (sett->cyc.tx_pd != PCM_PADDING_ON)) {
+			return -EINVAL;
+		}
+		if (sett->cyc.tx_pd == PCM_PADDING_ON)
+			cycle_val |= sett->cyc.tx_pd << 23;
+
+		break;
+	case PCM_MODE_5:        /* mode 5 (Multi Channel Mode) */
+	case PCM_MODE_6:        /* mode 6 (Multi Channel Mode) */
+		/* cyc_val : Frame length */
+		if (0x80 < sett->cyc.cyc_val)
+			return -EINVAL;
+
+		if ((sett->cyc.cyc_val == 0) && (sett->cyc2.cyc_val2 == 0))
+			return -EINVAL;
+
+		cycle_val |= sett->cyc.cyc_val;
+
+		/* sib : Data bit length (PMx_SI) */
+		if ((0x1f < sett->cyc.sib) || (sett->cyc.sib < 0x07))
+			return -EINVAL;
+
+		cycle_val |= sett->cyc.sib << 8;
+
+		/* rx_pd : Data padding (RX) */
+		if (sett->cyc.rx_pd != PCM_PADDING_OFF)
+			return -EINVAL;
+
+		/* sob : Data bit length (PMx_SO) */
+		if ((0x1f < sett->cyc.sob) || (sett->cyc.sob < 0x07))
+			return -EINVAL;
+
+		cycle_val |= sett->cyc.sob << 16;
+
+		/* tx_pd : Data padding (TX) */
+		if (sett->cyc.tx_pd != PCM_PADDING_OFF)
+			return -EINVAL;
+
+		/* cyc_val2 : Frame length */
+		if (0x80 < sett->cyc2.cyc_val2)
+			return -EINVAL;
+
+		cycle2_val |= sett->cyc2.cyc_val2;
+
+		/* sib2 : Data bit length (PMx_SI) */
+		if ((0x1f < sett->cyc2.sib2) || (sett->cyc2.sib2 < 0x07))
+			return -EINVAL;
+
+		cycle2_val |= sett->cyc2.sib2 << 8;
+
+		/* sob2 : Data bit length (PMx_SO) */
+		if ((0x1f < sett->cyc2.sob2) || (sett->cyc2.sob2 < 0x07))
+			return -EINVAL;
+
+		cycle2_val |= sett->cyc2.sob2 << 16;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	if (regs != NULL) {
+		/* set PMx_FUNC_SEL */
+		regs->func_sel = func_val;
+
+		/* set PMx_CYCLE1 */
+		regs->cycle = cycle_val;
+
+		if ((sett->func.mode_sel == PCM_MODE_5)
+		    || (sett->func.mode_sel == PCM_MODE_6)) {
+			/* set PMx_CYCLE2 */
+			regs->cycle2 = cycle2_val;
+		}
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(mp200_pcm_set_ctrl);
+
+
+MODULE_DESCRIPTION("mp200 PCM DMA module");
+MODULE_LICENSE("GPL");
+
diff --git a/sound/arm/mp200-pcm.h b/sound/arm/mp200-pcm.h
new file mode 100644
index 0000000..9870470
--- /dev/null
+++ b/sound/arm/mp200-pcm.h
@@ -0,0 +1,107 @@
+/*
+ * linux/sound/arm/mp200-pcm.h -- ALSA PCM interface for MP200 chip
+ *
+ * Created: Jun 08, 2009
+ * update : Nov 06, 2009
+ */
+
+#include <mach/dma.h>
+#include <linux/platform_device.h>
+
+#include <sound/mp200_pcm_ioctl.h>
+
+#define MP200_PCM_INTERRUPT_ENABLE 1
+#define MP200_PCM_MMAP_ENABLE 1
+#define MP200_PCM_USE_PDMA 1
+
+#ifndef MP200_PCM_USE_PDMA
+#undef  MP200_DAC_HANGUP_PDMA
+#endif
+
+#define MP200_PCM_CH0           0x00
+#define MP200_PCM_CH1           0x01
+#define MP200_PCM_MAX_CHANNELS  2
+
+/* func_sel set */
+#define MP200_PCM_FUNC_30WORD           0x00000000
+#define MP200_PCM_FUNC_16WORD           0x00000020
+#define MP200_PCM_FUNC_08WORD           0x00000040
+#define MP200_PCM_FUNC_04WORD           0x00000060
+#define MP200_PCM_FUNC_MASTER           0x00000008
+#define MP200_PCM_FUNC_SLAVE            0x00000010
+#define MP200_PCM_FUNC_MODE0            0x00000000
+#define MP200_PCM_FUNC_MODE1            0x00000001
+#define MP200_PCM_FUNC_MODE2            0x00000002
+#define MP200_PCM_FUNC_MODE3            0x00000003
+#define MP200_PCM_FUNC_MODE4            0x00000004
+#define MP200_PCM_FUNC_MODE5            0x00000005
+#define MP200_PCM_FUNC_MODE6            0x00000006
+
+/* cycle set */
+#define MP200_PCM_CYCLE_SHT_TX_PD       23
+#define MP200_PCM_CYCLE_SHT_SOB         16
+#define MP200_PCM_CYCLE_SHT_RX_PD       15
+#define MP200_PCM_CYCLE_SHT_SIB         8
+#define MP200_PCM_CYCLE_SHT_CYC         0
+
+#define reg_volatile volatile
+
+struct pcm_regs {
+	reg_volatile u32 func_sel;  /* +0x00 (r/w) */
+	reg_volatile u32 txrx_en;   /* +0x04 (r/w) */
+	reg_volatile u32 txrx_dis;  /* +0x08 (w) */
+	reg_volatile u32 cycle;     /* +0x0c (r/w) */
+	reg_volatile u32 raw;       /* +0x10 (r) */
+	reg_volatile u32 status;    /* +0x14 (r) */
+	reg_volatile u32 enset;     /* +0x18 (r/w) */
+	reg_volatile u32 enclr;     /* +0x1c (w) */
+	reg_volatile u32 clear;     /* +0x20 (w) */
+	reg_volatile u32 txq;       /* +0x24 (r/w) */
+	reg_volatile u32 rxq;       /* +0x28 (r) */
+	reg_volatile u32 fifo_p;    /* +0x2c (r) */
+	reg_volatile u32 cycle2;    /* +0x30 (r/w) */
+};
+
+struct audio_stream {
+	char *id;               /* identification string */
+	int dma_ch;
+	dma_regs_t *dma_regs;   /* points to our DMA registers */
+	dma_addr_t phys_xq;     /* PCM Data buffer address */
+	u32 txrx_id;            /* stream id and PCM enable bit */
+	reg_volatile u32 *txrx_en;  /* PCM enable register */
+	reg_volatile u32 *txrx_dis; /* PCM disable register */
+#ifdef MP200_PCM_INTERRUPT_ENABLE
+	reg_volatile u32 *func_sel; /* PCM func register */
+#endif
+	int active:1;           /* we are using this stream for transfer now */
+	int period;             /* current transfer period */
+	int periods;            /* current count of periods registerd in the
+				   DMA engine */
+	int add_period;         /* add transfer period */
+	int tx_spin;            /* are we recoding - flag used to do
+				   DMA trans. for sync */
+	unsigned int old_offset;
+	spinlock_t dma_lock;    /* for locking in DMA operations
+				   (see dma-sa1100.c in the kernel) */
+
+	struct snd_pcm_substream *stream;
+};
+
+struct mp200_pcm_client {
+	struct audio_stream *s[2];
+	int pcm_ch;
+	struct pcm_regs *pcm_regs;      /* points to our PCM registers */
+	pcm_ctrl_t *sett;
+	int (*startup)(struct snd_pcm_substream *);
+	void (*shutdown)(struct snd_pcm_substream *);
+	int (*prepare)(struct snd_pcm_substream *);
+};
+
+extern int mp200_pcm_new(struct snd_card *, struct mp200_pcm_client *,
+ struct snd_pcm **);
+extern int mp200_pcm_free(struct mp200_pcm_client *);
+extern int mp200_pcm_set_ctrl(struct pcm_regs *, pcm_ctrl_t *);
+#ifdef CONFIG_PM
+extern int mp200_pcm_suspend(struct platform_device *, pm_message_t);
+extern int mp200_pcm_resume(struct platform_device *);
+#endif
-- 
1.6.5.2

