From b69d99a159627f43ab048dd37cdb9078ed2adb6c Mon Sep 17 00:00:00 2001
From: Kazuya Tsukamoto <kazuya.tsukamoto@necel.com>
Date: Mon, 9 Nov 2009 11:28:39 +0900
Subject: [PATCH 06/29] nec_em1: add gpio driver

Allowo access to the GPIO on the EMMA Mobile 1 board.

The registration of interrupt does only 0 and 2 because there is GPIO that
doesn't connect device though there is GPIO interrupt from 0 to 7
(in mp200_gio_init function).

Please do not forget to make the invalidated interrupt effective when the
device ties to GPIO.  The setting to the register is effective from the beginning.

GPIO Interfaces(gpio_direction_input, etc...) is accessed to PowerIC-GPIO and
MAX7324 besides GPIO.

Signed-off-by: Kazuya Tsukamoto <kazuya.tsukamoto@necel.com>
---
 arch/arm/mach-mp200/gpio.c              |  405 ++++++++++++++++++++
 arch/arm/mach-mp200/include/mach/gpio.h |  611 +++++++++++++++++++++++++++++++
 2 files changed, 1016 insertions(+), 0 deletions(-)
 create mode 100644 arch/arm/mach-mp200/gpio.c
 create mode 100644 arch/arm/mach-mp200/include/mach/gpio.h

diff --git a/arch/arm/mach-mp200/gpio.c b/arch/arm/mach-mp200/gpio.c
new file mode 100644
index 0000000..00db4fe
--- /dev/null
+++ b/arch/arm/mach-mp200/gpio.c
@@ -0,0 +1,405 @@
+/*
+ *  File Name       : linux/arch/arm/mach-mp200/gpio.c
+ *  Function        : gpio
+ *  Release Version : Ver 1.01
+ *  Release Date    : 2009/02/04
+ *
+ *  Copyright (C) NEC Electronics Corporation 2009
+ *
+ *
+ *  This program is free software;you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License as published by Free
+ *  Softwere Foundation; either version 2 of License, or (at your option)
+ *  any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY;
+ *  without even the implied warrnty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.
+ *  See the GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program;
+ *  If not, write to the Free Software Foundation, Inc., 59 Temple
+ *  Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/gpio.h>
+
+#include <asm/mach/irq.h>
+
+/*#define GPIO_DEBUG 1*/
+#ifdef GPIO_DEBUG
+#define DPRINT(FMT, ARGS...) printk(KERN_INFO "%s(): " FMT, __func__, ##ARGS)
+#else
+#define DPRINT(FMT, ARGS...)
+#endif
+
+#define PIN_MASK(X)	(1U << ((X) & 0x1f))	/* IIA/IEN/IDS/PLS/... */
+#define PIN_INDEX(X)	((X) >> 5)
+
+static DEFINE_SPINLOCK(mp200_gio_lock);
+
+static void mp200_gio_irq_ack(unsigned int irq);
+static void mp200_gio_irq_mask(unsigned int irq);
+static void mp200_gio_irq_unmask(unsigned int irq);
+static int mp200_gio_set_irq_type(unsigned int irq, unsigned int type);
+
+static struct irq_chip mp200_gio_chip_ack = {
+	.name     = "GIO-edge",
+	.ack      = mp200_gio_irq_ack,
+	.mask     = mp200_gio_irq_mask,
+	.unmask   = mp200_gio_irq_unmask,
+	.set_type = mp200_gio_set_irq_type,
+	.disable  = mp200_gio_irq_mask,
+};
+
+static struct irq_chip mp200_gio_chip = {
+	.name     = "GIO-level",
+	.ack      = mp200_gio_irq_mask,
+	.mask     = mp200_gio_irq_mask,
+	.unmask   = mp200_gio_irq_unmask,
+	.set_type = mp200_gio_set_irq_type,
+	.disable  = mp200_gio_irq_mask,
+};
+
+static uint32_t accept_bits[4] = { 0, 0, 0, 0};
+
+static int idt_table[] =
+	{
+	  VA_GIO + GP_IDT0L,   VA_GIO + GP_IDT1L,
+	  VA_GIO + GP_IDT2L,   VA_GIO + GP_IDT3L,
+	  VA_GIO + GP_IDT0H,   VA_GIO + GP_IDT1H,
+	  VA_GIO + GP_IDT2H,   VA_GIO + GP_IDT3H,
+	  VA_GIO + GP_IDT0HH,  VA_GIO + GP_IDT1HH,
+	  VA_GIO + GP_IDT2HH,  VA_GIO + GP_IDT3HH,
+	  VA_GIO + GP_IDT0HHH, VA_GIO + GP_IDT1HHH,
+	  VA_GIO + GP_IDT2HHH, VA_GIO + GP_IDT3HHH,
+	};
+
+
+/* called from set_irq_type() */
+static int mp200_gio_set_irq_type(unsigned int irq, unsigned int type)
+{
+	unsigned int pin = irq - INT_GPIO_BASE;
+	unsigned int mode = 0;
+	unsigned long flag;
+	unsigned int oiia;
+	unsigned int x;
+	unsigned int mask;
+	unsigned int idtshift;
+	unsigned int idt, iia, iir;
+
+	DPRINT("Enter\n");
+
+	if ((irq < INT_GPIO_BASE) || (INT_GPIO_LAST < irq))
+		return -EINVAL;
+
+	switch (type & IRQ_TYPE_SENSE_MASK) {
+	case IRQ_TYPE_EDGE_RISING:
+		mode |= 0x00;
+		set_irq_chip(irq, &mp200_gio_chip_ack);
+		set_irq_handler(irq, handle_edge_irq);
+		break;
+	case IRQ_TYPE_EDGE_FALLING:
+		mode |= 0x01;
+		set_irq_chip(irq, &mp200_gio_chip_ack);
+		set_irq_handler(irq, handle_edge_irq);
+		break;
+	case IRQ_TYPE_LEVEL_HIGH:
+		mode |= 0x02;
+		set_irq_chip(irq, &mp200_gio_chip);
+		set_irq_handler(irq, handle_level_irq);
+		break;
+	case IRQ_TYPE_LEVEL_LOW:
+		mode |= 0x03;
+		set_irq_chip(irq, &mp200_gio_chip);
+		set_irq_handler(irq, handle_level_irq);
+		break;
+	case IRQ_TYPE_EDGE_BOTH:
+		mode |= 0x04;
+		set_irq_chip(irq, &mp200_gio_chip_ack);
+		set_irq_handler(irq, handle_edge_irq);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	mask = PIN_MASK(pin);
+	idtshift = (pin & 0x7) << 2;	/* IDT shift bit */
+
+	spin_lock_irqsave(&mp200_gio_lock, flag);
+
+	idt = idt_table[pin / 8];
+	if (pin < 32) {
+		iia = VA_GIO + GP_IIAL;
+		iir = VA_GIO + GP_IIRL;
+	} else if (pin < 64) {
+		iia = VA_GIO + GP_IIAH;
+		iir = VA_GIO + GP_IIRH;
+	} else if (pin < 96) {
+		iia = VA_GIO + GP_IIAHH;
+		iir = VA_GIO + GP_IIRHH;
+	} else {
+		iia = VA_GIO + GP_IIAHHH;
+		iir = VA_GIO + GP_IIRHHH;
+	}
+
+	/* IIA enable -> disable */
+	oiia = __raw_readl(iia);
+	if ((oiia & mask) != 0)
+		__raw_writel((oiia & ~(mask)), iia);
+
+	/* set IDT */
+	x = __raw_readl(idt);
+	if ((x & (0xfU << idtshift)) != (mode << idtshift)) {
+		x &= ~(0xfU << idtshift);
+		x |= (mode << idtshift);
+		__raw_writel(x, idt);
+	}
+	DPRINT("PIN %d Set IDT, addr=0x%08x, data=0x%08x\n",
+					pin, idt, __raw_readl(idt));
+
+	/* Interrupt clear */
+	__raw_writel(mask, iir);
+
+	/* Restore if changed */
+	if ((oiia & mask) != 0)
+		__raw_writel(oiia, iia);
+
+	spin_unlock_irqrestore(&mp200_gio_lock, flag);
+
+	DPRINT("Exit\n");
+
+	return 0;
+}
+
+static void mp200_gio_irq_handler(unsigned int irq, struct irq_desc *desc)
+{
+	struct irq_desc *d;
+	uint32_t ist, gio_irq;
+
+	DPRINT("Enter\n");
+
+	if ((irq != INT_GIO0) && (irq != INT_GIO1) &&
+		 (irq != INT_GIO2) && (irq != INT_GIO3) &&
+		 (irq != INT_GIO4) && (irq != INT_GIO5) &&
+		 (irq != INT_GIO6) && (irq != INT_GIO7)) {
+		return;
+	}
+
+	desc->chip->mask(irq);
+
+	do {
+		if (irq == INT_GIO0) {
+			gio_irq = INT_GPIO_0;
+			ist = __raw_readl(VA_GIO + GP_MSTL) & 0xffffU;
+		} else if (irq == INT_GIO1) {
+			gio_irq = INT_GPIO_16;
+			ist = __raw_readl(VA_GIO + GP_MSTL) >> 16;
+		} else if (irq == INT_GIO2) {
+			gio_irq = INT_GPIO_32;
+			ist = __raw_readl(VA_GIO + GP_MSTH) & 0xffffU;
+		} else if (irq == INT_GIO3) {
+			gio_irq = INT_GPIO_48;
+			ist = __raw_readl(VA_GIO + GP_MSTH) >> 16;
+		} else if (irq == INT_GIO4) {
+			gio_irq = INT_GPIO_64;
+			ist = __raw_readl(VA_GIO + GP_MSTHH) & 0xffffU;
+		} else if (irq == INT_GIO5) {
+			gio_irq = INT_GPIO_80;
+			ist = __raw_readl(VA_GIO + GP_MSTHH) >> 16;
+		} else if (irq == INT_GIO6) {
+			gio_irq = INT_GPIO_96;
+			ist = __raw_readl(VA_GIO + GP_MSTHHH) & 0xffffU;
+		} else {
+			gio_irq = INT_GPIO_112;
+			ist = __raw_readl(VA_GIO + GP_MSTHHH) >> 16;
+		}
+
+		if (ist == 0)
+			break;
+
+		while (ist) {
+			if ((ist & 1) != 0) {
+				DPRINT("PIN %d interrupt handler\n",
+						gio_irq - INT_GPIO_0);
+				d = irq_desc + gio_irq;
+				d->handle_irq(gio_irq, d);
+			}
+			ist >>= 1;
+			gio_irq++;
+		}
+	} while (1);
+
+	desc->chip->unmask(irq);
+
+	DPRINT("Exit\n");
+}
+
+static void mp200_gio_irq_ack(unsigned int irq)
+{
+	unsigned int pin = irq - INT_GPIO_BASE;
+	unsigned int mask = PIN_MASK(pin);
+
+	DPRINT("Enter\n");
+
+	if ((irq < INT_GPIO_BASE) || (INT_GPIO_LAST < irq))
+		return;
+
+	if (pin < 32)
+		__raw_writel(mask, (VA_GIO + GP_IIRL));
+	else if (pin < 64)
+		__raw_writel(mask, (VA_GIO + GP_IIRH));
+	else if (pin < 96)
+		__raw_writel(mask, (VA_GIO + GP_IIRHH));
+	else
+		__raw_writel(mask, (VA_GIO + GP_IIRHHH));
+
+#ifdef GPIO_DEBUG
+	{
+		int iir_table[] = {
+			VA_GIO + GP_IIRL,  VA_GIO + GP_IIRH,
+			VA_GIO + GP_IIRHH, VA_GIO + GP_IIRHHH
+		};
+
+		DPRINT("PIN %d clear interrupt, addr=0x%08x, mask=0x%08x\n",
+					pin, iir_table[pin/32], mask);
+	}
+#endif
+
+	DPRINT("Exit\n");
+}
+
+static void mp200_gio_irq_mask(unsigned int irq)
+{
+	unsigned int pin = irq - INT_GPIO_BASE;
+	unsigned int mask = PIN_MASK(pin);
+
+	DPRINT("Enter\n");
+
+	if ((irq < INT_GPIO_BASE) || (INT_GPIO_LAST < irq))
+		return;
+
+	/* disable */
+	if (pin < 32)
+		__raw_writel(mask, (VA_GIO + GP_IDSL));
+	else if (pin < 64)
+		__raw_writel(mask, (VA_GIO + GP_IDSH));
+	else if (pin < 96)
+		__raw_writel(mask, (VA_GIO + GP_IDSHH));
+	else
+		__raw_writel(mask, (VA_GIO + GP_IDSHHH));
+
+#ifdef GPIO_DEBUG
+	{
+		int ids_table[] = {
+			VA_GIO + GP_IDSL,  VA_GIO + GP_IDSH,
+			VA_GIO + GP_IDSHH, VA_GIO + GP_IDSHHH
+		};
+
+		DPRINT("PIN %d irq mask, addr=0x%08x, mask=0x%08x\n",
+					pin, ids_table[pin/32], mask);
+	}
+#endif
+
+	DPRINT("Exit\n");
+}
+
+static void mp200_gio_irq_unmask(unsigned int irq)
+{
+	unsigned int iia;
+	unsigned int pin = irq - INT_GPIO_BASE;
+	unsigned int mask = PIN_MASK(pin);
+	unsigned long flag;
+	unsigned int iia_addr, ien_addr;
+	uint32_t *accept;
+
+	DPRINT("Enter\n");
+
+	if ((irq < INT_GPIO_BASE) || (INT_GPIO_LAST < irq))
+		return;
+
+	/* IRQ enable */
+	if (pin < 32) {
+		accept = (accept_bits + 0);
+		iia_addr = VA_GIO + GP_IIAL;
+		ien_addr = VA_GIO + GP_IENL;
+	} else if (pin < 64) {
+		accept = (accept_bits + 1);
+		iia_addr = VA_GIO + GP_IIAH;
+		ien_addr = VA_GIO + GP_IENH;
+	} else if (pin < 96) {
+		accept = (accept_bits + 2);
+		iia_addr = VA_GIO + GP_IIAHH;
+		ien_addr = VA_GIO + GP_IENHH;
+	} else {
+		accept = (accept_bits + 3);
+		iia_addr = VA_GIO + GP_IIAHHH;
+		ien_addr = VA_GIO + GP_IENHHH;
+	}
+
+	spin_lock_irqsave(&mp200_gio_lock, flag);
+	if ((*accept & mask) == 0) {
+		iia = __raw_readl(iia_addr);
+		__raw_writel((iia | mask), iia_addr);
+		*accept |= mask;
+	}
+	spin_unlock_irqrestore(&mp200_gio_lock, flag);
+
+	__raw_writel(mask, ien_addr);
+
+	DPRINT("PIN %d irq unmask, addr=0x%08x, mask=0x%08x\n",
+				pin, ien_addr, mask);
+
+	DPRINT("Exit\n");
+}
+
+static int __init mp200_gio_init(void)
+{
+	int i, gpio_num = 0, level_irq, idt_val[16], idt;
+
+	DPRINT("Enter\n");
+
+	for (i = 0; i < 16; i++)
+		idt_val[i] = __raw_readl(idt_table[i]);
+
+	/* setup default GIO Interrupt modes */
+	for (i = INT_GPIO_BASE; i <= INT_GPIO_LAST; i++, gpio_num++) {
+		level_irq = 0;
+		idt = idt_val[gpio_num / 8];
+		if (idt & (2 << (4 * (gpio_num & 0x7))))
+			level_irq = 1;
+
+		if (level_irq) {
+			set_irq_chip(i, &mp200_gio_chip);
+			set_irq_handler(i, handle_level_irq);
+		} else {
+			set_irq_chip(i, &mp200_gio_chip_ack);
+			set_irq_handler(i, handle_edge_irq);
+		}
+		set_irq_flags(i, IRQF_VALID);
+	}
+
+	set_irq_chained_handler(INT_GIO0, mp200_gio_irq_handler);
+	set_irq_chained_handler(INT_GIO2, mp200_gio_irq_handler);
+	/* No interrupts cascade-connected */
+#if 0
+	set_irq_chained_handler(INT_GIO1, mp200_gio_irq_handler);
+	set_irq_chained_handler(INT_GIO3, mp200_gio_irq_handler);
+	set_irq_chained_handler(INT_GIO4, mp200_gio_irq_handler);
+	set_irq_chained_handler(INT_GIO5, mp200_gio_irq_handler);
+	set_irq_chained_handler(INT_GIO6, mp200_gio_irq_handler);
+	set_irq_chained_handler(INT_GIO7, mp200_gio_irq_handler);
+#endif
+
+	DPRINT("Exit\n");
+
+	return 0;
+}
+
+arch_initcall(mp200_gio_init);
diff --git a/arch/arm/mach-mp200/include/mach/gpio.h b/arch/arm/mach-mp200/include/mach/gpio.h
new file mode 100644
index 0000000..e0b3c98
--- /dev/null
+++ b/arch/arm/mach-mp200/include/mach/gpio.h
@@ -0,0 +1,611 @@
+/*
+ *  File Name       : linux/include/asm-arm/arch-mp200/gpio.h
+ *  Function        : gpio
+ *  Release Version : Ver 1.03
+ *  Release Date    : 2009/06/11
+ *
+ *  Copyright (C) NEC Electronics Corporation 2009
+ *
+ *
+ *  This program is free software;you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  Free Softwere Foundation; either version 2 of License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY;
+ *  without even the implied warrnty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.
+ *  See the GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program;
+ *  If not, write to the Free Software Foundation, Inc., 59 Temple
+ *  Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+#ifndef __ASM_ARM_ARCH_MP200_GPIO_H
+#define __ASM_ARM_ARCH_MP200_GPIO_H
+
+#include <linux/io.h>
+#include <linux/errno.h>
+#include <mach/hardware.h>
+#include <mach/pwc.h>
+#include <mach/irqs.h>
+#ifdef CONFIG_MP200_EM1_DKIT
+#include <mach/extio.h>
+#endif
+
+/* GPIO port */
+
+/* GIO Registers */
+#define VA_GIO	IO_ADDRESS(MP200_GPIO_BASE)
+
+/* GPIO 0-31 */
+#define GP_E1L		0x0000 /* set output */
+#define GP_E0L		0x0004 /* set input */
+#define GP_EML		0x0004 /* in/out setting monitor */
+#define GP_OLL		0x0008 /* data output( 0-15) */
+#define GP_OHL		0x000C /* data output(16-31) */
+#define GP_IL		0x0010 /* data intput */
+#define GP_IIAL		0x0014 /* enable interrupt */
+#define GP_IENL		0x0018 /* interrupt unmask */
+#define GP_IDSL		0x001C /* interrupt mask */
+#define GP_IIML		0x001C /* interrupt mask status */
+#define GP_RAWL		0x0020 /* interrupt raw status */
+#define GP_MSTL		0x0024 /* interrupt masked status */
+#define GP_IIRL		0x0028 /* interrupt status reset */
+#define GP_GSWL		0x003C /* set INT_FIQ */
+#define GP_IDT0L	0x0100 /* interrupt detect control ( 0- 7) */
+#define GP_IDT1L	0x0104 /* interrupt detect control ( 8-15) */
+#define GP_IDT2L	0x0108 /* interrupt detect control (16-23) */
+#define GP_IDT3L	0x010C /* interrupt detect control (24- 31) */
+#define GP_RAWBLL	0x0110 /* interrupt raw status(double-edge) ( 0-15)*/
+#define GP_RAWBHL	0x0114 /* interrupt raw status(double-edge) (16-31)*/
+#define GP_IRBLL	0x0118 /* interrupt status reset(double-edge) ( 0- 15)*/
+#define GP_IRBHL	0x011C /* interrupt status reset(double-edge) (16- 31)*/
+
+/* GPIO 32-63 */
+#define GP_E1H		0x0040 /* set output */
+#define GP_E0H		0x0044 /* set input */
+#define GP_EMH		0x0044 /* in/out setting monitor */
+#define GP_OLH		0x0048 /* data output(32-47) */
+#define GP_OHH		0x004C /* data output(48-63) */
+#define GP_IH		0x0050 /* data intput */
+#define GP_IIAH		0x0054 /* enable interrupt */
+#define GP_IENH		0x0058 /* interrupt unmask */
+#define GP_IDSH		0x005C /* interrupt mask */
+#define GP_IIMH		0x005C /* interrupt mask status */
+#define GP_RAWH		0x0060 /* interrupt raw status */
+#define GP_MSTH		0x0064 /* interrupt masked status */
+#define GP_IIRH		0x0068 /* interrupt status reset */
+#define GP_GSWH		0x007C /* set INT_FIQ */
+#define GP_IDT0H	0x0140 /* interrupt detect control ( 0- 7) */
+#define GP_IDT1H	0x0144 /* interrupt detect control ( 8-15) */
+#define GP_IDT2H	0x0148 /* interrupt detect control (16-23) */
+#define GP_IDT3H	0x014C /* interrupt detect control (24- 31) */
+#define GP_RAWBLH	0x0150 /* interrupt raw status(double-edge) ( 0-15)*/
+#define GP_RAWBHH	0x0154 /* interrupt raw status(double-edge) (16-31)*/
+#define GP_IRBLH	0x0158 /* interrupt status reset(double-edge) ( 0- 15)*/
+#define GP_IRBHH	0x015C /* interrupt status reset(double-edge) (16- 31)*/
+
+/* GPIO 95-64 */
+#define GP_E1HH		0x0080 /* set output */
+#define GP_E0HH		0x0084 /* set input */
+#define GP_EMHH		0x0084 /* in/out setting monitor */
+#define GP_OLHH		0x0088 /* data output(79-64) */
+#define GP_OHHH		0x008C /* data output(95-80) */
+#define GP_IHH		0x0090 /* data intput */
+#define GP_IIAHH	0x0094 /* enable interrupt */
+#define GP_IENHH	0x0098 /* interrupt unmask */
+#define GP_IDSHH	0x009C /* interrupt mask */
+#define GP_IIMHH	0x009C /* interrupt mask status */
+#define GP_RAWHH	0x00A0 /* interrupt raw status */
+#define GP_MSTHH	0x00A4 /* interrupt masked status */
+#define GP_IIRHH	0x00A8 /* interrupt status reset */
+#define GP_GSWHH	0x00BC /* set INT_FIQ */
+#define GP_IDT0HH	0x0180 /* interrupt detect control (71-64) */
+#define GP_IDT1HH	0x0184 /* interrupt detect control (79-72) */
+#define GP_IDT2HH	0x0188 /* interrupt detect control (87-80) */
+#define GP_IDT3HH	0x018C /* interrupt detect control (95-88) */
+#define GP_RAWBLHH	0x0190 /* interrupt raw status(double-edge) (71-64)*/
+#define GP_RAWBHHH	0x0194 /* interrupt raw status(double-edge) (79-72)*/
+#define GP_IRBLHH	0x0198 /* interrupt status reset(double-edge) (87-80)*/
+#define GP_IRBHHH	0x019C /* interrupt status reset(double-edge) (95-88)*/
+
+/* GPIO 127-96 */
+#define GP_E1HHH	0x0200 /*set output */
+#define GP_E0HHH	0x0204 /*set input */
+#define GP_EMHHH	0x0204 /*in/out setting monitor */
+#define GP_OLHHH	0x0208 /*data output(111- 96) */
+#define GP_OHHHH	0x020C /*data output(127-112) */
+#define GP_IHHH		0x0210 /*data intput */
+#define GP_IIAHHH	0x0214 /*enable interrupt */
+#define GP_IENHHH	0x0218 /*interrupt unmask */
+#define GP_IDSHHH	0x021C /*interrupt mask */
+#define GP_IIMHHH	0x021C /*interrupt mask status */
+#define GP_RAWHHH	0x0220 /*interrupt raw status */
+#define GP_MSTHHH	0x0224 /*interrupt masked status */
+#define GP_IIRHHH	0x0228 /*interrupt status reset */
+#define GP_GSWHHH	0x023C /*set INT_FIQ */
+#define GP_IDT0HHH	0x0300 /*interrupt detect control (103- 96) */
+#define GP_IDT1HHH	0x0304 /*interrupt detect control (111-104) */
+#define GP_IDT2HHH	0x0308 /*interrupt detect control (119-112) */
+#define GP_IDT3HHH	0x030C /*interrupt detect control (127-120) */
+#define GP_RAWBLHHH	0x0310 /*interrupt raw status(double-edge) (103- 96)*/
+#define GP_RAWBHHHH	0x0314 /*interrupt raw status(double-edge) (111-104)*/
+#define GP_IRBLHHH	0x0318 /*interrupt status reset(double-edge) (119-113)*/
+#define GP_IRBHHHH	0x031C /*interrupt status reset(double-edge) (127-120)*/
+
+
+/* GPIO number */
+#define GPIO_P0		0
+#define GPIO_P1		1
+#define GPIO_P2		2
+#define GPIO_P3		3
+#define GPIO_P4		4
+#define GPIO_P5		5
+#define GPIO_P6		6
+#define GPIO_P7		7
+#define GPIO_P8		8
+#define GPIO_P9		9
+#define GPIO_P10	10
+#define GPIO_P11	11
+#define GPIO_P12	12
+#define GPIO_P13	13
+#define GPIO_P14	14
+#define GPIO_P15	15
+#define GPIO_P16	16
+#define GPIO_P17	17
+#define GPIO_P18	18
+#define GPIO_P19	19
+#define GPIO_P20	20
+#define GPIO_P21	21
+#define GPIO_P22	22
+#define GPIO_P23	23
+#define GPIO_P24	24
+#define GPIO_P25	25
+#define GPIO_P26	26
+#define GPIO_P27	27
+#define GPIO_P28	28
+#define GPIO_P29	29
+#define GPIO_P30	30
+#define GPIO_P31	31
+#define GPIO_P32	32
+#define GPIO_P33	33
+#define GPIO_P34	34
+#define GPIO_P35	35
+#define GPIO_P36	36
+#define GPIO_P37	37
+#define GPIO_P38	38
+#define GPIO_P39	39
+#define GPIO_P40	40
+#define GPIO_P41	41
+#define GPIO_P42	42
+#define GPIO_P43	43
+#define GPIO_P44	44
+#define GPIO_P45	45
+#define GPIO_P46	46
+#define GPIO_P47	47
+#define GPIO_P48	48
+#define GPIO_P49	49
+#define GPIO_P50	50
+#define GPIO_P51	51
+#define GPIO_P52	52
+#define GPIO_P53	53
+#define GPIO_P54	54
+#define GPIO_P55	55
+#define GPIO_P56	56
+#define GPIO_P57	57
+#define GPIO_P58	58
+#define GPIO_P59	59
+#define GPIO_P60	60
+#define GPIO_P61	61
+#define GPIO_P62	62
+#define GPIO_P63	63
+#define GPIO_P64	64
+#define GPIO_P65	65
+#define GPIO_P66	66
+#define GPIO_P67	67
+#define GPIO_P68	68
+#define GPIO_P69	69
+#define GPIO_P70	70
+#define GPIO_P71	71
+#define GPIO_P72	72
+#define GPIO_P73	73
+#define GPIO_P74	74
+#define GPIO_P75	75
+#define GPIO_P76	76
+#define GPIO_P77	77
+#define GPIO_P78	78
+#define GPIO_P79	79
+#define GPIO_P80	80
+#define GPIO_P81	81
+#define GPIO_P82	82
+#define GPIO_P83	83
+#define GPIO_P84	84
+#define GPIO_P85	85
+#define GPIO_P86	86
+#define GPIO_P87	87
+#define GPIO_P88	88
+#define GPIO_P89	89
+#define GPIO_P90	90
+#define GPIO_P91	91
+#define GPIO_P92	92
+#define GPIO_P93	93
+#define GPIO_P94	94
+#define GPIO_P95	95
+#define GPIO_P96	96
+#define GPIO_P97	97
+#define GPIO_P98	98
+#define GPIO_P99	99
+#define GPIO_P100	100
+#define GPIO_P101	101
+#define GPIO_P102	102
+#define GPIO_P103	103
+#define GPIO_P104	104
+#define GPIO_P105	105
+#define GPIO_P106	106
+#define GPIO_P107	107
+#define GPIO_P108	108
+#define GPIO_P109	109
+#define GPIO_P110	110
+#define GPIO_P111	111
+#define GPIO_P112	112
+#define GPIO_P113	113
+#define GPIO_P114	114
+#define GPIO_P115	115
+#define GPIO_P116	116
+#define GPIO_P117	117
+#define GPIO_P118	118
+#define GPIO_P119	119
+#define GPIO_P120	120
+#define GPIO_P121	121
+#define GPIO_P122	122
+#define GPIO_P123	123
+#define GPIO_P124	124
+#define GPIO_P125	125
+#define GPIO_P126	126
+#define GPIO_P127	127
+
+#define GPIO_GPIO_LAST   GPIO_P127
+
+#define GPIO_EXT1_BASE	(GPIO_GPIO_LAST + 1)
+#define GPIO_EXT1_P0	(GPIO_EXT1_BASE + 0)
+#define GPIO_EXT1_P1	(GPIO_EXT1_BASE + 1)
+#define GPIO_EXT1_P2	(GPIO_EXT1_BASE + 2)
+#define GPIO_EXT1_P3	(GPIO_EXT1_BASE + 3)
+#define GPIO_EXT1_P4	(GPIO_EXT1_BASE + 4)
+#define GPIO_EXT1_P5	(GPIO_EXT1_BASE + 5)
+#define GPIO_EXT1_P6	(GPIO_EXT1_BASE + 6)
+#define GPIO_EXT1_P7	(GPIO_EXT1_BASE + 7)
+#define GPIO_EXT1_P8	(GPIO_EXT1_BASE + 8)
+#define GPIO_EXT1_P9	(GPIO_EXT1_BASE + 9)
+#define GPIO_EXT1_P10	(GPIO_EXT1_BASE + 10)
+#define GPIO_EXT1_P11	(GPIO_EXT1_BASE + 11)
+#define GPIO_EXT1_P12	(GPIO_EXT1_BASE + 12)
+#define GPIO_EXT1_P13	(GPIO_EXT1_BASE + 13)
+#define GPIO_EXT1_P14	(GPIO_EXT1_BASE + 14)
+#define GPIO_EXT1_P15	(GPIO_EXT1_BASE + 15)
+#define GPIO_EXT1_LAST	GPIO_EXT1_P15
+
+#define GPIO_EXT2_BASE	(GPIO_EXT1_LAST + 1)
+#define GPIO_EXT2_P0	(GPIO_EXT2_BASE + 0)
+#define GPIO_EXT2_P1	(GPIO_EXT2_BASE + 1)
+#define GPIO_EXT2_P2	(GPIO_EXT2_BASE + 2)
+#define GPIO_EXT2_P3	(GPIO_EXT2_BASE + 3)
+#define GPIO_EXT2_P4	(GPIO_EXT2_BASE + 4)
+#define GPIO_EXT2_P5	(GPIO_EXT2_BASE + 5)
+#define GPIO_EXT2_P6	(GPIO_EXT2_BASE + 6)
+#define GPIO_EXT2_P7	(GPIO_EXT2_BASE + 7)
+#define GPIO_EXT2_P8	(GPIO_EXT2_BASE + 8)
+#define GPIO_EXT2_P9	(GPIO_EXT2_BASE + 9)
+#define GPIO_EXT2_P10	(GPIO_EXT2_BASE + 10)
+#define GPIO_EXT2_P11	(GPIO_EXT2_BASE + 11)
+#define GPIO_EXT2_P12	(GPIO_EXT2_BASE + 12)
+#define GPIO_EXT2_P13	(GPIO_EXT2_BASE + 13)
+#define GPIO_EXT2_P14	(GPIO_EXT2_BASE + 14)
+#define GPIO_EXT2_P15	(GPIO_EXT2_BASE + 15)
+#define GPIO_EXT2_LAST	GPIO_EXT2_P15
+
+#ifdef CONFIG_MP200_EM1_DKIT
+#define GPIO_LAST	GPIO_EXT2_LAST
+#else
+#define GPIO_LAST	GPIO_EXT1_LAST
+#endif
+
+/* board specific */
+#define GPIO_INTOUT				GPIO_P0
+#ifdef CONFIG_MP200_EM1_DKIT		/* use EM1 Design KIT Board */
+#define GPIO_SD1CD				GPIO_P2		/* in  */
+#define GPIO_SD0CD				GPIO_P3		/* in  */
+#define GPIO_CAM_STANDBY		GPIO_P4		/* out */
+#define GPIO_CAM_SCLK			GPIO_P5		/* out */
+#define GPIO_NAND_WP			GPIO_P6		/* out */
+#define GPIO_NTSC_RESET			GPIO_P8		/* out */
+#define GPIO_SNDPDN				GPIO_P9	/* out */
+#define GPIO_WIFI5				GPIO_P10	/* in  */
+#define GPIO_WIFI2				GPIO_P11	/* out */
+#define GPIO_PSW1				GPIO_P36	/* in  */
+#define GPIO_WIFI4				GPIO_P37	/* out */
+#define GPIO_ETH				GPIO_P41	/* in  */
+#define GPIO_ETH_RST			GPIO_P44	/* out */
+#define GPIO_LCD_RST			GPIO_P46	/* out */
+#define GPIO_USB_CSN			GPIO_P47	/* out */
+#define GPIO_CAM_RST			GPIO_P49	/* out */
+#define GPIO_PSW2				GPIO_P71	/* in  */
+#define GPIO_WIFI3				GPIO_P94	/* out */
+#define GPIO_WIFI1				GPIO_P95	/* out */
+
+/* PWC */
+#define GPIO_PAD				GPIO_EXT1_P0	/* out */
+#define	GPIO_USB_MODE			GPIO_EXT1_P1	/* in  */
+#define GPIO_USB_WAKEUP			GPIO_EXT1_P2	/* in  */
+#define GPIO_LCD_CN444YD		GPIO_EXT1_P3	/* in  */
+#define GPIO_LCD_CN446YU		GPIO_EXT1_P4	/* in  */
+#define GPIO_LCD_CN443XL		GPIO_EXT1_P5	/* in  */
+#define GPIO_LCD_CN445XR		GPIO_EXT1_P6	/* in  */
+#define GPIO_DA9052_VLDO9		GPIO_EXT1_P7	/* in  */
+#define GPIO_KEY_DATA0			GPIO_EXT1_P8	/* in  */
+#define GPIO_KEY_DATA1			GPIO_EXT1_P9	/* in  */
+#define GPIO_KEY_DATA2			GPIO_EXT1_P10	/* in  */
+#define GPIO_USB_CONNECTOR		GPIO_EXT1_P11	/* in  */
+#define GPIO_KEY_DATA3			GPIO_EXT1_P12	/* in  */
+#define GPIO_CN9_1PIN			GPIO_EXT1_P13	/* in  */
+#define GPIO_PWC_LED1			GPIO_EXT1_P14	/* out */
+#define	GPIO_PWC_LED2			GPIO_EXT1_P15	/* out */
+
+#define GPIO_KEY_OUT0			GPIO_EXT2_P8	/* out */
+#define GPIO_KEY_OUT1			GPIO_EXT2_P9	/* out */
+#define GPIO_KEY_OUT2			GPIO_EXT2_P10	/* out */
+#define GPIO_KEY_OUT3			GPIO_EXT2_P11	/* out */
+#define GPIO_LED1				GPIO_EXT2_P12	/* out */
+#define GPIO_LED2				GPIO_EXT2_P13	/* out */
+#define GPIO_LED3				GPIO_EXT2_P14	/* out */
+#define GPIO_LED4				GPIO_EXT2_P15	/* out */
+
+#else
+
+#define GPIO_USBWAK				GPIO_P1
+#define GPIO_LCD_PD				GPIO_P2
+#define GPIO_LCD_RST			GPIO_P3
+#define GPIO_ETH				GPIO_P4
+#define GPIO_USB_RESET			GPIO_P6
+#define GPIO_USB_INT			GPIO_P7
+#define GPIO_VPEN				GPIO_P9
+#define GPIO_TP_INT				GPIO_P10
+#define GPIO_USB_CSN			GPIO_P44
+
+/* PWC */
+#define GPIO_KEY_DATA0	GPIO_EXT1_P0	/* I */
+#define	GPIO_KEY_DATA1	GPIO_EXT1_P1	/* I */
+#define GPIO_KEY_DATA2	GPIO_EXT1_P2	/* I */
+#define GPIO_KEY_DATA3	GPIO_EXT1_P3	/* I */
+#define GPIO_KEY_SCAN_2	GPIO_EXT1_P4	/* I */
+#define GPIO_KEY_SCAN_1	GPIO_EXT1_P5	/* I */
+#define GPIO_LANRST		GPIO_EXT1_P7	/* I */
+#define GPIO_SNDCDA		GPIO_EXT1_P8	/* I */
+#define GPIO_SNDPDN		GPIO_EXT1_P9	/* I */
+#define GPIO_NTSC_RESET	GPIO_EXT1_P10	/* I */
+#define GPIO_SDCDZ	GPIO_EXT1_P14	/* I */
+#define	GPIO_SDWP	GPIO_EXT1_P15	/* I */
+#endif
+
+static inline int __gpio_set_direction(unsigned gpio, int is_input)
+{
+	unsigned int reg;
+
+	if (gpio < 32)
+		reg = is_input ? (VA_GIO + GP_E0L)   : (VA_GIO + GP_E1L);
+	else if (gpio < 64)
+		reg = is_input ? (VA_GIO + GP_E0H)   : (VA_GIO + GP_E1H);
+	else if (gpio < 96)
+		reg = is_input ? (VA_GIO + GP_E0HH)  : (VA_GIO + GP_E1HH);
+	else
+		reg = is_input ? (VA_GIO + GP_E0HHH) : (VA_GIO + GP_E1HHH);
+
+	__raw_writel(1U << (gpio & 0x1f), reg);
+
+	return 0;
+}
+
+static inline int __gpio_get_direction(unsigned gpio)
+{
+	unsigned int val;
+
+	if (gpio < 32)
+		val = __raw_readl(VA_GIO + GP_EML);
+	else if (gpio < 64)
+		val = __raw_readl(VA_GIO + GP_EMH);
+	else if (gpio < 96)
+		val = __raw_readl(VA_GIO + GP_EMHH);
+	else
+		val = __raw_readl(VA_GIO + GP_EMHHH);
+
+	return (val & (1U << (gpio & 0x1f))) ? 1 : 0;
+}
+
+static inline void __gpio_set_value(unsigned gpio, int val)
+{
+	unsigned int goe, gos;
+
+	goe = (0x10000U << (gpio & 0xf));
+	gos = val ? (1U << (gpio & 0xf)) : 0;
+
+	if (gpio < 16)
+		__raw_writel((goe | gos), (VA_GIO + GP_OLL));
+	else if (gpio < 32)
+		__raw_writel((goe | gos), (VA_GIO + GP_OHL));
+	else if (gpio < 48)
+		__raw_writel((goe | gos), (VA_GIO + GP_OLH));
+	else if (gpio < 64)
+		__raw_writel((goe | gos), (VA_GIO + GP_OHH));
+	else if (gpio < 80)
+		__raw_writel((goe | gos), (VA_GIO + GP_OLHH));
+	else if (gpio < 96)
+		__raw_writel((goe | gos), (VA_GIO + GP_OHHH));
+	else if (gpio < 112)
+		__raw_writel((goe | gos), (VA_GIO + GP_OLHHH));
+	else
+		__raw_writel((goe | gos), (VA_GIO + GP_OHHHH));
+}
+
+static inline int __gpio_get_value(unsigned gpio)
+{
+	unsigned int val;
+
+	if (__gpio_get_direction(gpio)) {
+		if (gpio < 16)
+			val = __raw_readl(VA_GIO + GP_OLL);
+		else if (gpio < 32)
+			val = __raw_readl(VA_GIO + GP_OHL);
+		else if (gpio < 48)
+			val = __raw_readl(VA_GIO + GP_OLH);
+		else if (gpio < 64)
+			val = __raw_readl(VA_GIO + GP_OHH);
+		else if (gpio < 80)
+			val = __raw_readl(VA_GIO + GP_OLHH);
+		else if (gpio < 96)
+			val = __raw_readl(VA_GIO + GP_OHHH);
+		else if (gpio < 112)
+			val = __raw_readl(VA_GIO + GP_OLHHH);
+		else
+			val = __raw_readl(VA_GIO + GP_OHHHH);
+
+		return (val & (1U << (gpio & 0xf))) ? 1 : 0;
+	} else {
+		if (gpio < 32)
+			val = __raw_readl(VA_GIO + GP_IL);
+		else if (gpio < 64)
+			val = __raw_readl(VA_GIO + GP_IH);
+		else if (gpio < 96)
+			val = __raw_readl(VA_GIO + GP_IHH);
+		else
+			val = __raw_readl(VA_GIO + GP_IHHH);
+
+		return (val & (1U << (gpio & 0x1f))) ? 1 : 0;
+	}
+}
+
+static inline int gpio_direction_input(unsigned gpio)
+{
+	if (gpio <= GPIO_GPIO_LAST)
+		return __gpio_set_direction(gpio, 1);
+	else if (gpio <= GPIO_EXT1_LAST)
+		return pwc_set_direction(gpio, 1);
+#ifdef CONFIG_MP200_EM1_DKIT
+	else if (gpio <= GPIO_EXT2_LAST)
+		return extio_set_direction(gpio, 1);
+#endif
+	else
+		return -EINVAL;
+}
+
+static inline int gpio_direction_output(unsigned gpio, int value)
+{
+	int ret = -EINVAL;
+
+	if (gpio <= GPIO_GPIO_LAST) {
+		ret = __gpio_set_direction(gpio, 0);
+		if (!ret)
+			__gpio_set_value(gpio, value);
+	} else if (gpio <= GPIO_EXT1_LAST) {
+		ret = pwc_set_direction(gpio, 0);
+		if (!ret)
+			pwc_set_value(gpio, value);
+#ifdef CONFIG_MP200_EM1_DKIT
+	} else if (gpio <= GPIO_EXT2_LAST) {
+		ret = extio_set_direction(gpio, 0);
+		if (!ret)
+			extio_set_value(gpio, value);
+#endif
+	}
+
+	return ret;
+}
+
+static inline int gpio_get_value(unsigned gpio)
+{
+	if (gpio <= GPIO_GPIO_LAST)
+		return __gpio_get_value(gpio);
+	else if (gpio <= GPIO_EXT1_LAST)
+		return pwc_get_value(gpio);
+#ifdef CONFIG_MP200_EM1_DKIT
+	else if (gpio <= GPIO_EXT2_LAST)
+		return extio_get_value(gpio);
+#endif
+	else
+		return -EINVAL;
+}
+
+static inline void gpio_set_value(unsigned gpio, int value)
+{
+	if (gpio <= GPIO_GPIO_LAST)
+		__gpio_set_value(gpio, value);
+	else if (gpio <= GPIO_EXT1_LAST)
+		pwc_set_value(gpio, value);
+#ifdef CONFIG_MP200_EM1_DKIT
+	else if (gpio <= GPIO_EXT2_LAST)
+		extio_set_value(gpio, value);
+#endif
+}
+
+static inline int gpio_is_valid(int number)
+{
+	return number >= 0 && number <= GPIO_LAST;
+}
+
+static inline int gpio_cansleep(unsigned gpio)
+{
+	if (gpio <= GPIO_GPIO_LAST)
+		return 0;
+	else if (gpio <= GPIO_EXT1_LAST)
+		return 0;
+#ifdef CONFIG_MP200_EM1_DKIT
+	else if (gpio <= GPIO_EXT2_LAST)
+		return 1;
+#endif
+	return 0;
+}
+
+static inline int gpio_get_value_cansleep(unsigned gpio)
+{
+	might_sleep();
+	return gpio_get_value(gpio);
+}
+
+static inline void gpio_set_value_cansleep(unsigned gpio, int value)
+{
+	might_sleep();
+	gpio_set_value(gpio, value);
+}
+
+static inline int gpio_to_irq(unsigned gpio)
+{
+	if (gpio <= GPIO_LAST)
+		return gpio + INT_GPIO_BASE;
+	else
+		return -EINVAL;
+}
+
+static inline int irq_to_gpio(unsigned irq)
+{
+	if ((irq >= INT_GPIO_BASE) && (irq <= INT_PWC_LAST))
+		return irq - INT_GPIO_BASE;
+	else
+		return -EINVAL;
+}
+
+static inline int gpio_request(unsigned gpio, const char *label)
+{
+	if (gpio <= GPIO_LAST)
+		return 0;
+	else
+		return -EINVAL;
+}
+
+static inline void gpio_free(unsigned gpio)
+{
+}
+
+#endif	/* __ASM_ARM_ARCH_MP200_GPIO_H */
-- 
1.6.5.2

