From 4c8ccf3bb4b63432372cab088e1b8ac69c4b6fbc Mon Sep 17 00:00:00 2001
From: Kazuya Tsukamoto <kazuya.tsukamoto@necel.com>
Date: Mon, 9 Nov 2009 11:31:14 +0900
Subject: [PATCH 07/29] pm: nec em1 pm driver

Add em1 specific pm driver code, and modify the generic pm
infrastructure to allow for EM1 specific processing.

The processing that changes to sleep mode while the idle state is
added. DEV_SUSPEND_IDLE_1 uses to each driver the sleep mode
transition while the idle state it to tell it.

Signed-off-by: Kazuya Tsukamoto <kazuya.tsukamoto@necel.com>
---
 arch/arm/mach-mp200/include/mach/pm.h  |   56 ++
 arch/arm/mach-mp200/include/mach/pmu.h |  334 +++++++
 arch/arm/mach-mp200/include/mach/smu.h |  422 +++++++++
 arch/arm/mach-mp200/pm.c               |  702 +++++++++++++++
 arch/arm/mach-mp200/pm_pmu.c           | 1526 ++++++++++++++++++++++++++++++++
 arch/arm/mach-mp200/pm_pmu.h           |  596 +++++++++++++
 arch/arm/mach-mp200/pmu.c              |  646 ++++++++++++++
 drivers/base/platform.c                |   17 +
 drivers/base/power/main.c              |   59 ++
 include/linux/device.h                 |    2 +
 include/linux/pm.h                     |    4 +
 11 files changed, 4364 insertions(+), 0 deletions(-)
 create mode 100644 arch/arm/mach-mp200/include/mach/pm.h
 create mode 100644 arch/arm/mach-mp200/include/mach/pmu.h
 create mode 100644 arch/arm/mach-mp200/include/mach/smu.h
 create mode 100644 arch/arm/mach-mp200/pm.c
 create mode 100644 arch/arm/mach-mp200/pm_pmu.c
 create mode 100644 arch/arm/mach-mp200/pm_pmu.h
 create mode 100644 arch/arm/mach-mp200/pmu.c

diff --git a/arch/arm/mach-mp200/include/mach/pm.h b/arch/arm/mach-mp200/include/mach/pm.h
new file mode 100644
index 0000000..9a32763
--- /dev/null
+++ b/arch/arm/mach-mp200/include/mach/pm.h
@@ -0,0 +1,56 @@
+/*
+ *  File Name	    : linux/include/asm-arm/arch-mp200/pm.h
+ *  Function	    : Power Management
+ *  Release Version : Ver 1.00
+ *  Release Date    : 2008/01/21
+ *
+ *  Copyright (C) NEC Electronics Corporation 2008
+ *
+ *
+ *  This program is free software;you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License as published by Free
+ *  Softwere Foundation; either version 2 of License, or (at your option) any
+ *  later version.
+ *
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warrnty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; If not, write to the Free Software Foundation, Inc., 59
+ *  Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+#ifndef __ASM_ARM_ARCH_MP200_PM_H
+#define __ASM_ARM_ARCH_MP200_PM_H
+
+#include <linux/interrupt.h>
+
+#define PM_SLEEP_MODE_S1		1
+#define PM_SLEEP_MODE_S2		2
+#define PM_SLEEP_MODE_S3		3
+
+#define NORMAL_A	1
+#define NORMAL_B	2
+#define NORMAL_C	3
+#define NORMAL_D	4
+
+#define NORMAL_B_DIV	3
+
+extern int mp200_sleep_while_idle;
+extern int mp200_pm_sleep(unsigned int mode);
+extern void pm_change_normalA(void);
+extern void pm_change_normalB(void);
+
+#ifdef CONFIG_PM
+extern void mp200_pm_pdma_suspend_enable(void);
+extern void mp200_pm_pdma_suspend_disable(void);
+extern unsigned int mp200_pm_pdma_suspend_status(void);
+#else
+#define mp200_pm_pdma_suspend_enable()
+#define mp200_pm_pdma_suspend_disable()
+#define mp200_pm_pdma_suspend_status() 0
+#endif
+
+#endif /* __ASM_ARM_ARCH_MP200_PM_H */
diff --git a/arch/arm/mach-mp200/include/mach/pmu.h b/arch/arm/mach-mp200/include/mach/pmu.h
new file mode 100644
index 0000000..f4198eb
--- /dev/null
+++ b/arch/arm/mach-mp200/include/mach/pmu.h
@@ -0,0 +1,334 @@
+/*
+ *  File Name	    : linux/include/asm-arm/arch-mp200/pmu.h
+ *  Function	    : pmu
+ *  Release Version : Ver 1.01
+ *  Release Date    : 2008/08/27
+ *
+ *  Copyright (C) NEC Electronics Corporation 2008
+ *
+ *
+ *  This program is free software;you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License as published by Free
+ *  Softwere Foundation; either version 2 of License, or (at your option) any
+ *  later version.
+ *
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warrnty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; If not, write to the Free Software Foundation, Inc., 59
+ *  Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#ifndef __ASM_ARM_ARCH_MP200_PMU_H
+#define __ASM_ARM_ARCH_MP200_PMU_H
+
+#define SMU_GCLKCTRL0_GROUP		(0 << 16)
+#define SMU_GCLKCTRL1_GROUP		(1 << 16)
+#define SMU_GCLKCTRL2_GROUP		(2 << 16)
+#define SMU_GCLKCTRL3_GROUP		(3 << 16)
+#define SMU_GCLKCTRL4_GROUP		(4 << 16)
+
+#define SMU_RESETREQ0_GROUP		(5 << 16)
+#define SMU_RESETREQ1_GROUP		(6 << 16)
+#define SMU_RESETREQ2_GROUP		(7 << 16)
+#define SMU_RESETREQ3_GROUP		(8 << 16)
+
+
+#define SMU_AHBCLKCTRL0_GROUP	(16 << 16)
+#define SMU_AHBCLKCTRL1_GROUP	(17 << 16)
+#define SMU_APBCLKCTRL0_GROUP	(18 << 16)
+#define SMU_APBCLKCTRL1_GROUP	(19 << 16)
+#define SMU_CLKCTRL_GROUP		(20 << 16)
+#define SMU_APBCLKCTRL2_GROUP	(21 << 16)
+
+#define SMU_REG_GROUP_MASK		0xffff0000
+#define SMU_REG_BIT_MASK		0x0000ffff
+#define SMU_REG_MAX_BIT_LEN		32
+
+
+#define MP200_CLOCKGATE_DMA_TCLK		(SMU_GCLKCTRL0_GROUP | 30)
+#define MP200_CLOCKGATE_DMA_PCH3_CLK	(SMU_GCLKCTRL0_GROUP | 29)
+#define MP200_CLOCKGATE_DMA_PCH2_CLK	(SMU_GCLKCTRL0_GROUP | 28)
+#define MP200_CLOCKGATE_DMA_PCH0_CLK	(SMU_GCLKCTRL0_GROUP | 26)
+#define MP200_CLOCKGATE_DMA_PCLK		(SMU_GCLKCTRL0_GROUP | 25)
+#define MP200_CLOCKGATE_CAM_SCLK		(SMU_GCLKCTRL0_GROUP | 22)
+#define MP200_CLOCKGATE_CAM_PCLK		(SMU_GCLKCTRL0_GROUP | 21)
+#define MP200_CLOCKGATE_CAM_CLK			(SMU_GCLKCTRL0_GROUP | 20)
+#define MP200_CLOCKGATE_IMC_PCLK		(SMU_GCLKCTRL0_GROUP | 19)
+#define MP200_CLOCKGATE_IMC_CLK			(SMU_GCLKCTRL0_GROUP | 18)
+#define MP200_CLOCKGATE_IPUAHB_CLK		(SMU_GCLKCTRL0_GROUP | 17)
+#define MP200_CLOCKGATE_IPUDMA_PCLK		(SMU_GCLKCTRL0_GROUP | 16)
+#define MP200_CLOCKGATE_IPUDMA_CLK		(SMU_GCLKCTRL0_GROUP | 15)
+#define MP200_CLOCKGATE_ROT_PCLK		(SMU_GCLKCTRL0_GROUP | 14)
+#define MP200_CLOCKGATE_ROT_CLK 		(SMU_GCLKCTRL0_GROUP | 13)
+#define MP200_CLOCKGATE_IMG_PCLK		(SMU_GCLKCTRL0_GROUP | 12)
+#define MP200_CLOCKGATE_IMG_2_CLK		(SMU_GCLKCTRL0_GROUP | 11)
+#define MP200_CLOCKGATE_IMG_1_CLK		(SMU_GCLKCTRL0_GROUP | 10)
+#define MP200_CLOCKGATE_PDMA_PCLK		(SMU_GCLKCTRL0_GROUP | 7)
+#define MP200_CLOCKGATE_PDMA_HCLK		(SMU_GCLKCTRL0_GROUP | 6)
+#define MP200_CLOCKGATE_PDMA_ACLK		(SMU_GCLKCTRL0_GROUP | 5)
+#define MP200_CLOCKGATE_DSP_ACLK		(SMU_GCLKCTRL0_GROUP | 1)
+#define MP200_CLOCKGATE_DSP_CLK 		(SMU_GCLKCTRL0_GROUP | 0)
+
+/* */
+#define MP200_CLOCKGATE_AVC_HSCLK		(SMU_GCLKCTRL1_GROUP | 31)
+#define MP200_CLOCKGATE_AVC_HMCLK		(SMU_GCLKCTRL1_GROUP | 30)
+#define MP200_CLOCKGATE_AVC_CLKM		(SMU_GCLKCTRL1_GROUP | 29)
+#define MP200_CLOCKGATE_AVC_CLKE		(SMU_GCLKCTRL1_GROUP | 28)
+#define MP200_CLOCKGATE_AVC_CLKD		(SMU_GCLKCTRL1_GROUP | 27)
+#define MP200_CLOCKGATE_AVC_CLKC		(SMU_GCLKCTRL1_GROUP | 26)
+#define MP200_CLOCKGATE_DCV_PCLK 		(SMU_GCLKCTRL1_GROUP | 25)
+#define MP200_CLOCKGATE_DCV_CLK 		(SMU_GCLKCTRL1_GROUP | 24)
+#define MP200_CLOCKGATE_AB1_CLK 		(SMU_GCLKCTRL1_GROUP | 23)
+#define MP200_CLOCKGATE_PB0_CLK 		(SMU_GCLKCTRL1_GROUP | 22)
+#define MP200_CLOCKGATE_AXL1_PMON_CLK	(SMU_GCLKCTRL1_GROUP | 21)
+#define MP200_CLOCKGATE_MHXB_CLK		(SMU_GCLKCTRL1_GROUP | 20)
+#define MP200_CLOCKGATE_DHXB_CLK		(SMU_GCLKCTRL1_GROUP | 19)
+#define MP200_CLOCKGATE_SWL1_CLK		(SMU_GCLKCTRL1_GROUP | 18)
+#define MP200_CLOCKGATE_AXL1_PCLK		(SMU_GCLKCTRL1_GROUP | 17)
+#define MP200_CLOCKGATE_AXL1_CLK		(SMU_GCLKCTRL1_GROUP | 16)
+#define MP200_CLOCKGATE_CHG_PCLK		(SMU_GCLKCTRL1_GROUP | 15)
+#define MP200_CLOCKGATE_AINT_PCLK		(SMU_GCLKCTRL1_GROUP | 14)
+
+#define MP200_CLOCKGATE_LCD_CCLK		(SMU_GCLKCTRL1_GROUP | 12)
+#define MP200_CLOCKGATE_LCD_LCLK		(SMU_GCLKCTRL1_GROUP | 11)
+#define MP200_CLOCKGATE_LCD_PCLK		(SMU_GCLKCTRL1_GROUP | 10)
+#define MP200_CLOCKGATE_LCD_CLK 		(SMU_GCLKCTRL1_GROUP | 9)
+#define MP200_CLOCKGATE_SRC_CLK 		(SMU_GCLKCTRL1_GROUP | 8)
+#define MP200_CLOCKGATE_MEMC_RCLK 		(SMU_GCLKCTRL1_GROUP | 7)
+#define MP200_CLOCKGATE_MEMC_PCLK 		(SMU_GCLKCTRL1_GROUP | 6)
+#define MP200_CLOCKGATE_MEMC_CLK270 	(SMU_GCLKCTRL1_GROUP | 5)
+#define MP200_CLOCKGATE_MEMC_CLK		(SMU_GCLKCTRL1_GROUP | 4)
+#define MP200_CLOCKGATE_SWL0_CLK		(SMU_GCLKCTRL1_GROUP | 2)
+#define MP200_CLOCKGATE_AXL0_PCLK		(SMU_GCLKCTRL1_GROUP | 1)
+#define MP200_CLOCKGATE_AXL0_CLK		(SMU_GCLKCTRL1_GROUP | 0)
+
+/* */
+#define MP200_CLOCKGATE_SHXB_HCLK 		(SMU_GCLKCTRL2_GROUP | 30)
+#define MP200_CLOCKGATE_SHXB_CLK 		(SMU_GCLKCTRL2_GROUP | 29)
+#define MP200_CLOCKGATE_DTV_PCLK		(SMU_GCLKCTRL2_GROUP | 26)
+#define MP200_CLOCKGATE_DTV_CLK 		(SMU_GCLKCTRL2_GROUP | 25)
+#define MP200_CLOCKGATE_NTS_PCLK		(SMU_GCLKCTRL2_GROUP | 24)
+#define MP200_CLOCKGATE_NTS_CLK			(SMU_GCLKCTRL2_GROUP | 23)
+#define MP200_CLOCKGATE_NAND_PCLK		(SMU_GCLKCTRL2_GROUP | 22)
+#define MP200_CLOCKGATE_NAND_HCLK		(SMU_GCLKCTRL2_GROUP | 21)
+#define MP200_CLOCKGATE_REFCLK			(SMU_GCLKCTRL2_GROUP | 20)
+#define MP200_CLOCKGATE_PM1_SCLK		(SMU_GCLKCTRL2_GROUP | 14)
+#define MP200_CLOCKGATE_PM0_SCLK		(SMU_GCLKCTRL2_GROUP | 13)
+#define MP200_CLOCKGATE_PM0_PCLK		(SMU_GCLKCTRL2_GROUP | 12)
+#define MP200_CLOCKGATE_USB_CLK 		(SMU_GCLKCTRL2_GROUP | 11)
+#define MP200_CLOCKGATE_U72_SCLK		(SMU_GCLKCTRL2_GROUP | 8)
+#define MP200_CLOCKGATE_U71_SCLK		(SMU_GCLKCTRL2_GROUP | 7)
+#define MP200_CLOCKGATE_U70_SCLK		(SMU_GCLKCTRL2_GROUP | 6)
+#define MP200_CLOCKGATE_U70_CLK 		(SMU_GCLKCTRL2_GROUP | 5)
+#define MP200_CLOCKGATE_IIC_SCLK		(SMU_GCLKCTRL2_GROUP | 4)
+#define MP200_CLOCKGATE_IIC_CLK 		(SMU_GCLKCTRL2_GROUP | 3)
+#define MP200_CLOCKGATE_IIC2_SCLK		(SMU_GCLKCTRL2_GROUP | 2)
+#define MP200_CLOCKGATE_IIC2_CLK		(SMU_GCLKCTRL2_GROUP | 1)
+
+/* */
+#define MP200_CLOCKGATE_FLASHCLK 		(SMU_GCLKCTRL3_GROUP | 31)
+#define MP200_CLOCKGATE_PWM_PWCLK1		(SMU_GCLKCTRL3_GROUP | 29)
+#define MP200_CLOCKGATE_PWM_PWCLK0		(SMU_GCLKCTRL3_GROUP | 28)
+#define MP200_CLOCKGATE_PWM_PCLK		(SMU_GCLKCTRL3_GROUP | 27)
+#define MP200_CLOCKGATE_SP2_SCLK		(SMU_GCLKCTRL3_GROUP | 26)
+#define MP200_CLOCKGATE_SP2_PCLK		(SMU_GCLKCTRL3_GROUP | 25)
+#define MP200_CLOCKGATE_SP1_SCLK		(SMU_GCLKCTRL3_GROUP | 24)
+#define MP200_CLOCKGATE_SP1_PCLK		(SMU_GCLKCTRL3_GROUP | 23)
+#define MP200_CLOCKGATE_SP0_SCLK		(SMU_GCLKCTRL3_GROUP | 22)
+#define MP200_CLOCKGATE_SP0_PCLK		(SMU_GCLKCTRL3_GROUP | 21)
+#define MP200_CLOCKGATE_MWI_SCLK		(SMU_GCLKCTRL3_GROUP | 20)
+#define MP200_CLOCKGATE_MWI_PCLK		(SMU_GCLKCTRL3_GROUP | 19)
+#define MP200_CLOCKGATE_ATIM_PCLK		(SMU_GCLKCTRL3_GROUP | 14)
+#define MP200_CLOCKGATE_TW3_TIN 		(SMU_GCLKCTRL3_GROUP | 13)
+#define MP200_CLOCKGATE_TW2_TIN 		(SMU_GCLKCTRL3_GROUP | 12)
+#define MP200_CLOCKGATE_TW1_TIN 		(SMU_GCLKCTRL3_GROUP | 11)
+#define MP200_CLOCKGATE_TW0_TIN 		(SMU_GCLKCTRL3_GROUP | 10)
+#define MP200_CLOCKGATE_TG5_TIN 		(SMU_GCLKCTRL3_GROUP | 9)
+#define MP200_CLOCKGATE_TG4_TIN 		(SMU_GCLKCTRL3_GROUP | 8)
+#define MP200_CLOCKGATE_TG3_TIN 		(SMU_GCLKCTRL3_GROUP | 7)
+#define MP200_CLOCKGATE_TG2_TIN 		(SMU_GCLKCTRL3_GROUP | 6)
+#define MP200_CLOCKGATE_TG1_TIN 		(SMU_GCLKCTRL3_GROUP | 5)
+#define MP200_CLOCKGATE_TG0_TIN 		(SMU_GCLKCTRL3_GROUP | 4)
+#define MP200_CLOCKGATE_TI3_TIN 		(SMU_GCLKCTRL3_GROUP | 3)
+#define MP200_CLOCKGATE_TI2_TIN 		(SMU_GCLKCTRL3_GROUP | 2)
+#define MP200_CLOCKGATE_TI1_TIN 		(SMU_GCLKCTRL3_GROUP | 1)
+#define MP200_CLOCKGATE_TI0_TIN 		(SMU_GCLKCTRL3_GROUP | 0)
+
+#define MP200_CLOCKGATE_PM1_CLK			(SMU_GCLKCTRL4_GROUP | 9)
+#define MP200_CLOCKGATE_PM0_CLK			(SMU_GCLKCTRL4_GROUP | 8)
+#define MP200_CLOCKGATE_SDIC_CLK		(SMU_GCLKCTRL4_GROUP | 7)
+#define MP200_CLOCKGATE_SDIB_CLK		(SMU_GCLKCTRL4_GROUP | 6)
+#define MP200_CLOCKGATE_SDIA_CLK		(SMU_GCLKCTRL4_GROUP | 5)
+#define MP200_CLOCKGATE_DMA2_CLK		(SMU_GCLKCTRL4_GROUP | 4)
+
+
+#define MP200_RESETDEVICE_MEMC			(SMU_RESETREQ0_GROUP | 31)
+#define MP200_RESETDEVICE_U72			(SMU_RESETREQ0_GROUP | 29)
+#define MP200_RESETDEVICE_U71			(SMU_RESETREQ0_GROUP | 28)
+#define MP200_RESETDEVICE_U70			(SMU_RESETREQ0_GROUP | 27)
+#define MP200_RESETDEVICE_GIO			(SMU_RESETREQ0_GROUP | 26)
+#define MP200_RESETDEVICE_AINT			(SMU_RESETREQ0_GROUP | 25)
+#define MP200_RESETDEVICE_SRC			(SMU_RESETREQ0_GROUP | 24)
+#define MP200_RESETDEVICE_PB1			(SMU_RESETREQ0_GROUP | 23)
+#define MP200_RESETDEVICE_PB0			(SMU_RESETREQ0_GROUP | 22)
+#define MP200_RESETDEVICE_AB1			(SMU_RESETREQ0_GROUP | 21)
+#define MP200_RESETDEVICE_AB0			(SMU_RESETREQ0_GROUP | 20)
+#define MP200_RESETDEVICE_NTS			(SMU_RESETREQ0_GROUP | 19)
+#define MP200_RESETDEVICE_DTV			(SMU_RESETREQ0_GROUP | 18)
+#define MP200_RESETDEVICE_IMC			(SMU_RESETREQ0_GROUP | 17)
+#define MP200_RESETDEVICE_AVC			(SMU_RESETREQ0_GROUP | 15)
+#define MP200_RESETDEVICE_DMA			(SMU_RESETREQ0_GROUP | 14)
+#define MP200_RESETDEVICE_LCD			(SMU_RESETREQ0_GROUP | 13)
+#define MP200_RESETDEVICE_CAM			(SMU_RESETREQ0_GROUP | 12)
+#define MP200_RESETDEVICE_IPUAHB		(SMU_RESETREQ0_GROUP | 11)
+#define MP200_RESETDEVICE_IPUDMA		(SMU_RESETREQ0_GROUP | 10)
+#define MP200_RESETDEVICE_IPUROT		(SMU_RESETREQ0_GROUP | 9)
+#define MP200_RESETDEVICE_IPUIMG		(SMU_RESETREQ0_GROUP | 8)
+#define MP200_RESETDEVICE_DCV			(SMU_RESETREQ0_GROUP | 5)
+#define MP200_RESETDEVICE_ADSP_S		(SMU_RESETREQ0_GROUP | 4)
+#define MP200_RESETDEVICE_ADSP_A		(SMU_RESETREQ0_GROUP | 3)
+#define MP200_RESETDEVICE_ACPU_AT		(SMU_RESETREQ0_GROUP | 2)
+#define MP200_RESETDEVICE_ACPU_PO		(SMU_RESETREQ0_GROUP | 1)
+#define MP200_RESETDEVICE_ACPU			(SMU_RESETREQ0_GROUP | 0)
+
+#define MP200_RESETDEVICE_USB			(SMU_RESETREQ1_GROUP | 28)
+#define MP200_RESETDEVICE_NAND			(SMU_RESETREQ1_GROUP | 27)
+#define MP200_RESETDEVICE_IIC			(SMU_RESETREQ1_GROUP | 26)
+#define MP200_RESETDEVICE_IIC2			(SMU_RESETREQ1_GROUP | 25)
+#define MP200_RESETDEVICE_SP2			(SMU_RESETREQ1_GROUP | 24)
+#define MP200_RESETDEVICE_SP1			(SMU_RESETREQ1_GROUP | 23)
+#define MP200_RESETDEVICE_SP0			(SMU_RESETREQ1_GROUP | 22)
+#define MP200_RESETDEVICE_MWI			(SMU_RESETREQ1_GROUP | 21)
+#define MP200_RESETDEVICE_PDMA			(SMU_RESETREQ1_GROUP | 19)
+#define MP200_RESETDEVICE_PM1			(SMU_RESETREQ1_GROUP | 17)
+#define MP200_RESETDEVICE_PM0			(SMU_RESETREQ1_GROUP | 16)
+#define MP200_RESETDEVICE_TG5			(SMU_RESETREQ1_GROUP | 13)
+#define MP200_RESETDEVICE_TG4			(SMU_RESETREQ1_GROUP | 12)
+#define MP200_RESETDEVICE_TG3			(SMU_RESETREQ1_GROUP | 11)
+#define MP200_RESETDEVICE_TG2			(SMU_RESETREQ1_GROUP | 10)
+#define MP200_RESETDEVICE_TG1			(SMU_RESETREQ1_GROUP | 9)
+#define MP200_RESETDEVICE_TG0			(SMU_RESETREQ1_GROUP | 8)
+#define MP200_RESETDEVICE_TW3			(SMU_RESETREQ1_GROUP | 7)
+#define MP200_RESETDEVICE_TW2			(SMU_RESETREQ1_GROUP | 6)
+#define MP200_RESETDEVICE_TW1			(SMU_RESETREQ1_GROUP | 5)
+#define MP200_RESETDEVICE_TW0			(SMU_RESETREQ1_GROUP | 4)
+#define MP200_RESETDEVICE_TI3			(SMU_RESETREQ1_GROUP | 3)
+#define MP200_RESETDEVICE_TI2			(SMU_RESETREQ1_GROUP | 2)
+#define MP200_RESETDEVICE_TI1			(SMU_RESETREQ1_GROUP | 1)
+#define MP200_RESETDEVICE_TI0			(SMU_RESETREQ1_GROUP | 0)
+
+#define MP200_RESETDEVICE_PMU			(SMU_RESETREQ2_GROUP | 12)
+#define MP200_RESETDEVICE_CHG			(SMU_RESETREQ2_GROUP | 10)
+#define MP200_RESETDEVICE_PWM			(SMU_RESETREQ2_GROUP | 9)
+#define MP200_RESETDEVICE_SHXB			(SMU_RESETREQ2_GROUP | 6)
+#define MP200_RESETDEVICE_DXHB			(SMU_RESETREQ2_GROUP | 5)
+#define MP200_RESETDEVICE_MHXB			(SMU_RESETREQ2_GROUP | 4)
+#define MP200_RESETDEVICE_SWL1			(SMU_RESETREQ2_GROUP | 3)
+#define MP200_RESETDEVICE_SWL0			(SMU_RESETREQ2_GROUP | 2)
+#define MP200_RESETDEVICE_AXL1			(SMU_RESETREQ2_GROUP | 1)
+#define MP200_RESETDEVICE_AXL0			(SMU_RESETREQ2_GROUP | 0)
+
+#define MP200_RESETDEVICE_SDIC			(SMU_RESETREQ3_GROUP | 4)
+#define MP200_RESETDEVICE_SDIB			(SMU_RESETREQ3_GROUP | 3)
+#define MP200_RESETDEVICE_SDIA			(SMU_RESETREQ3_GROUP | 2)
+#define MP200_RESETDEVICE_DMA2			(SMU_RESETREQ3_GROUP | 1)
+
+#define MP200_CLKCTRL_AVCHSCK			(SMU_AHBCLKCTRL0_GROUP | 31)
+#define MP200_CLKCTRL_AVCHMCK			(SMU_AHBCLKCTRL0_GROUP | 30)
+#define MP200_CLKCTRL_AVCCKM			(SMU_AHBCLKCTRL0_GROUP | 29)
+#define MP200_CLKCTRL_AVCCKE			(SMU_AHBCLKCTRL0_GROUP | 28)
+#define MP200_CLKCTRL_AVCCKD			(SMU_AHBCLKCTRL0_GROUP | 27)
+#define MP200_CLKCTRL_AVCCKC			(SMU_AHBCLKCTRL0_GROUP | 26)
+#define MP200_CLKCTRL_NTS			(SMU_AHBCLKCTRL0_GROUP | 24)
+#define MP200_CLKCTRL_NAND			(SMU_AHBCLKCTRL0_GROUP | 23)
+#define MP200_CLKCTRL_IMC			(SMU_AHBCLKCTRL0_GROUP | 22)
+#define MP200_CLKCTRL_DTV			(SMU_AHBCLKCTRL0_GROUP | 19)
+#define MP200_CLKCTRL_DMAPCH3			(SMU_AHBCLKCTRL0_GROUP | 18)
+#define MP200_CLKCTRL_DMAPCH2			(SMU_AHBCLKCTRL0_GROUP | 17)
+#define MP200_CLKCTRL_DMAPCH0			(SMU_AHBCLKCTRL0_GROUP | 15)
+#define MP200_CLKCTRL_LCDCCK			(SMU_AHBCLKCTRL0_GROUP | 14)
+#define MP200_CLKCTRL_LCD			(SMU_AHBCLKCTRL0_GROUP | 13)
+#define MP200_CLKCTRL_CAM			(SMU_AHBCLKCTRL0_GROUP | 12)
+#define MP200_CLKCTRL_IPUAHB			(SMU_AHBCLKCTRL0_GROUP | 11)
+#define MP200_CLKCTRL_IPUDMA			(SMU_AHBCLKCTRL0_GROUP | 10)
+#define MP200_CLKCTRL_IPUROT			(SMU_AHBCLKCTRL0_GROUP | 9)
+#define MP200_CLKCTRL_IPUIMG2			(SMU_AHBCLKCTRL0_GROUP | 8)
+#define MP200_CLKCTRL_IPUIMG1			(SMU_AHBCLKCTRL0_GROUP | 7)
+#define MP200_CLKCTRL_PDMAACK			(SMU_AHBCLKCTRL0_GROUP | 6)
+#define MP200_CLKCTRL_PDMAHCK			(SMU_AHBCLKCTRL0_GROUP | 5)
+#define MP200_CLKCTRL_DMA2			(SMU_AHBCLKCTRL0_GROUP | 4)
+#define MP200_CLKCTRL_ADSP			(SMU_AHBCLKCTRL0_GROUP | 1)
+#define MP200_CLKCTRL_ACPU			(SMU_AHBCLKCTRL0_GROUP | 0)
+
+#define MP200_CLKCTRL_AXL1HCLK			(SMU_AHBCLKCTRL1_GROUP | 15)
+#define MP200_CLKCTRL_SHXBHCLK			(SMU_AHBCLKCTRL1_GROUP | 13)
+#define MP200_CLKCTRL_SHXB			(SMU_AHBCLKCTRL1_GROUP | 12)
+#define MP200_CLKCTRL_MHXB			(SMU_AHBCLKCTRL1_GROUP | 11)
+#define MP200_CLKCTRL_DHXB			(SMU_AHBCLKCTRL1_GROUP | 10)
+#define MP200_CLKCTRL_AXL1			(SMU_AHBCLKCTRL1_GROUP | 9)
+#define MP200_CLKCTRL_AXL0			(SMU_AHBCLKCTRL1_GROUP | 8)
+#define MP200_CLKCTRL_SWL1			(SMU_AHBCLKCTRL1_GROUP | 7)
+#define MP200_CLKCTRL_SWL0			(SMU_AHBCLKCTRL1_GROUP | 6)
+#define MP200_CLKCTRL_SRC			(SMU_AHBCLKCTRL1_GROUP | 5)
+#define MP200_CLKCTRL_MEMC			(SMU_AHBCLKCTRL1_GROUP | 4)
+#define MP200_CLKCTRL_PB1			(SMU_AHBCLKCTRL1_GROUP | 3)
+#define MP200_CLKCTRL_PB0			(SMU_AHBCLKCTRL1_GROUP | 2)
+#define MP200_CLKCTRL_AB1			(SMU_AHBCLKCTRL1_GROUP | 1)
+#define MP200_CLKCTRL_AB0			(SMU_AHBCLKCTRL1_GROUP | 0)
+
+#define MP200_CLKCTRL_IPUDMACLK			(SMU_APBCLKCTRL0_GROUP | 16)
+#define MP200_CLKCTRL_IMCPCLK			(SMU_APBCLKCTRL0_GROUP | 15)
+#define MP200_CLKCTRL_NANDPCLK			(SMU_APBCLKCTRL0_GROUP | 14)
+#define MP200_CLKCTRL_NTSPCLK			(SMU_APBCLKCTRL0_GROUP | 12)
+#define MP200_CLKCTRL_AXIPCLK			(SMU_APBCLKCTRL0_GROUP | 8)
+#define MP200_CLKCTRL_SP2PCLK			(SMU_APBCLKCTRL0_GROUP | 7)
+#define MP200_CLKCTRL_PWMPCLK			(SMU_APBCLKCTRL0_GROUP | 6)
+#define MP200_CLKCTRL_DTVPCLK			(SMU_APBCLKCTRL0_GROUP | 5)
+#define MP200_CLKCTRL_DMAPCLK			(SMU_APBCLKCTRL0_GROUP | 4)
+#define MP200_CLKCTRL_CAMPCLK			(SMU_APBCLKCTRL0_GROUP | 3)
+#define MP200_CLKCTRL_IPUROTPCLK		(SMU_APBCLKCTRL0_GROUP | 2)
+#define MP200_CLKCTRL_IPUIMGPCLK		(SMU_APBCLKCTRL0_GROUP | 1)
+#define MP200_CLKCTRL_LCDPCLK			(SMU_APBCLKCTRL0_GROUP | 0)
+
+#define MP200_CLKCTRL_AXL0PCLK			(SMU_APBCLKCTRL1_GROUP | 15)
+#define MP200_CLKCTRL_CHGPCLK			(SMU_APBCLKCTRL1_GROUP | 13)
+#define MP200_CLKCTRL_DCVPCLK			(SMU_APBCLKCTRL1_GROUP | 11)
+#define MP200_CLKCTRL_PDMAPCLK			(SMU_APBCLKCTRL1_GROUP | 10)
+#define MP200_CLKCTRL_GIOPCLK			(SMU_APBCLKCTRL1_GROUP | 9)
+#define MP200_CLKCTRL_SP1PCLK			(SMU_APBCLKCTRL1_GROUP | 8)
+#define MP200_CLKCTRL_SP0PCLK			(SMU_APBCLKCTRL1_GROUP | 7)
+#define MP200_CLKCTRL_PMUPCLK			(SMU_APBCLKCTRL1_GROUP | 6)
+#define MP200_CLKCTRL_SMUPCLK			(SMU_APBCLKCTRL1_GROUP | 5)
+#define MP200_CLKCTRL_MWIPCLK			(SMU_APBCLKCTRL1_GROUP | 4)
+#define MP200_CLKCTRL_TIMPCLK			(SMU_APBCLKCTRL1_GROUP | 3)
+#define MP200_CLKCTRL_INTPCLK			(SMU_APBCLKCTRL1_GROUP | 2)
+#define MP200_CLKCTRL_MEMCPCLK			(SMU_APBCLKCTRL1_GROUP | 1)
+
+#define MP200_CLKCTRL_PM1PCLK			(SMU_APBCLKCTRL2_GROUP | 3)
+#define MP200_CLKCTRL_PM0PCLK			(SMU_APBCLKCTRL2_GROUP | 2)
+
+#define MP200_CLKCTRL_FLASH_CLK			(SMU_CLKCTRL_GROUP | 5)
+#define MP200_CLKCTRL_SP2SCLK			(SMU_CLKCTRL_GROUP | 4)
+#define MP200_CLKCTRL_SP1SCLK			(SMU_CLKCTRL_GROUP | 3)
+#define MP200_CLKCTRL_SP0SCLK			(SMU_CLKCTRL_GROUP | 2)
+#define MP200_CLKCTRL_MWISCLK			(SMU_CLKCTRL_GROUP | 1)
+#define MP200_CLKCTRL_MEMCCLK270		(SMU_CLKCTRL_GROUP | 0)
+
+extern int mp200_pmu_open_clockgate(unsigned int clkbit);
+extern int mp200_pmu_close_clockgate(unsigned int clkbit);
+extern int mp200_pmu_get_clockgate(unsigned int clkbit);
+
+extern int mp200_pmu_reset_device(unsigned int rstdevl);
+extern int mp200_pmu_unreset_device(unsigned int rstdevl);
+extern int mp200_pmu_get_reset_status(unsigned int rstdevl);
+
+extern int mp200_pmu_clkctrl_on(unsigned int dev);
+extern int mp200_pmu_clkctrl_off(unsigned int dev);
+extern int mp200_pmu_get_clkctrl_status(unsigned int dev);
+
+#endif	/* __ASM_ARM_ARCH_MP200_PMU_H */
diff --git a/arch/arm/mach-mp200/include/mach/smu.h b/arch/arm/mach-mp200/include/mach/smu.h
new file mode 100644
index 0000000..0c81ad5
--- /dev/null
+++ b/arch/arm/mach-mp200/include/mach/smu.h
@@ -0,0 +1,422 @@
+/*
+ *  File Name	    : include/asm-arm/arch-mp200/smu.h
+ *  Function	    : smu
+ *  Release Version : Ver 1.02
+ *  Release Date    : 2008/09/22
+ *
+ *  Copyright (C) NEC Electronics Corporation 2006, 2007, 2008
+ *
+ *
+ *  This program is free software;you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License as published by Free
+ *  Softwere Foundation; either version 2 of License, or (at your option) any
+ *  later version.
+ *
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warrnty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; If not, write to the Free Software Foundation, Inc., 59
+ *  Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#ifndef __ARCH_ARM_MACH_MP200_SMU_H
+#define __ARCH_ARM_MACH_MP200_SMU_H
+
+#include <mach/hardware.h>
+
+/* AB0 */
+
+#define AB0_FLASHCOMSET			(IO_ADDRESS(MP200_AB0_BASE) + 0x000)
+#define AB0_FLASHCOMLATCH		(IO_ADDRESS(MP200_AB0_BASE) + 0x004)
+#define AB0_FLASHCOMADD0		(IO_ADDRESS(MP200_AB0_BASE) + 0x010)
+#define AB0_FLASHCOMDATA0		(IO_ADDRESS(MP200_AB0_BASE) + 0x014)
+#define AB0_FLASHCOMADD1		(IO_ADDRESS(MP200_AB0_BASE) + 0x018)
+#define AB0_FLASHCOMDATA1		(IO_ADDRESS(MP200_AB0_BASE) + 0x01C)
+
+#define AB0_FLASHCLKCTRL		(IO_ADDRESS(MP200_AB0_BASE) + 0x080)
+#define AB0_FLA_RCLK_DLY		(IO_ADDRESS(MP200_AB0_BASE) + 0x084)
+
+#define AB0_CS0BASEADD			(IO_ADDRESS(MP200_AB0_BASE) + 0x100)
+#define AB0_CS0BITCOMP			(IO_ADDRESS(MP200_AB0_BASE) + 0x104)
+#define AB0_CS1BASEADD			(IO_ADDRESS(MP200_AB0_BASE) + 0x110)
+#define AB0_CS1BITCOMP			(IO_ADDRESS(MP200_AB0_BASE) + 0x114)
+#define AB0_CS2BASEADD			(IO_ADDRESS(MP200_AB0_BASE) + 0x120)
+#define AB0_CS2BITCOMP			(IO_ADDRESS(MP200_AB0_BASE) + 0x124)
+#define AB0_CS3BASEADD			(IO_ADDRESS(MP200_AB0_BASE) + 0x130)
+#define AB0_CS3BITCOMP			(IO_ADDRESS(MP200_AB0_BASE) + 0x134)
+#define AB0_CS4BASEADD			(IO_ADDRESS(MP200_AB0_BASE) + 0x140)
+#define AB0_CS4BITCOMP			(IO_ADDRESS(MP200_AB0_BASE) + 0x144)
+#define AB0_CS5BASEADD			(IO_ADDRESS(MP200_AB0_BASE) + 0x150)
+#define AB0_CS5BITCOMP			(IO_ADDRESS(MP200_AB0_BASE) + 0x154)
+
+#define AB0_CS0WAITCTRL			(IO_ADDRESS(MP200_AB0_BASE) + 0x200)
+#define AB0_CS0WAITCTRL_W		(IO_ADDRESS(MP200_AB0_BASE) + 0x204)
+#define AB0_CS0READCTRL			(IO_ADDRESS(MP200_AB0_BASE) + 0x208)
+#define AB0_CS0WAIT_MASK		(IO_ADDRESS(MP200_AB0_BASE) + 0x20C)
+#define AB0_CS0CONTROL			(IO_ADDRESS(MP200_AB0_BASE) + 0x210)
+
+#define AB0_CS0FLASHRCR			(IO_ADDRESS(MP200_AB0_BASE) + 0x214)
+#define AB0_CS0FLASHWCR			(IO_ADDRESS(MP200_AB0_BASE) + 0x218)
+
+#define AB0_CS1WAITCTRL			(IO_ADDRESS(MP200_AB0_BASE) + 0x220)
+#define AB0_CS1WAITCTRL_W		(IO_ADDRESS(MP200_AB0_BASE) + 0x224)
+#define AB0_CS1READCTRL			(IO_ADDRESS(MP200_AB0_BASE) + 0x228)
+#define AB0_CS1WAIT_MASK		(IO_ADDRESS(MP200_AB0_BASE) + 0x22C)
+#define AB0_CS1CONTROL			(IO_ADDRESS(MP200_AB0_BASE) + 0x230)
+
+#define AB0_CS1FLASHRCR			(IO_ADDRESS(MP200_AB0_BASE) + 0x234)
+#define AB0_CS1FLASHWCR			(IO_ADDRESS(MP200_AB0_BASE) + 0x238)
+
+#define AB0_CS2WAITCTRL			(IO_ADDRESS(MP200_AB0_BASE) + 0x240)
+#define AB0_CS2WAITCTRL_W		(IO_ADDRESS(MP200_AB0_BASE) + 0x244)
+#define AB0_CS2READCTRL			(IO_ADDRESS(MP200_AB0_BASE) + 0x248)
+#define AB0_CS2WAIT_MASK		(IO_ADDRESS(MP200_AB0_BASE) + 0x24C)
+#define AB0_CS2CONTROL			(IO_ADDRESS(MP200_AB0_BASE) + 0x250)
+
+#define AB0_CS2FLASHRCR			(IO_ADDRESS(MP200_AB0_BASE) + 0x254)
+#define AB0_CS2FLASHWCR			(IO_ADDRESS(MP200_AB0_BASE) + 0x258)
+
+#define AB0_CS3WAITCTRL			(IO_ADDRESS(MP200_AB0_BASE) + 0x260)
+#define AB0_CS3WAITCTRL_W		(IO_ADDRESS(MP200_AB0_BASE) + 0x264)
+#define AB0_CS3READCTRL			(IO_ADDRESS(MP200_AB0_BASE) + 0x268)
+#define AB0_CS3WAIT_MASK		(IO_ADDRESS(MP200_AB0_BASE) + 0x26C)
+#define AB0_CS3CONTROL			(IO_ADDRESS(MP200_AB0_BASE) + 0x270)
+
+#define AB0_CS3FLASHRCR			(IO_ADDRESS(MP200_AB0_BASE) + 0x274)
+#define AB0_CS3FLASHWCR			(IO_ADDRESS(MP200_AB0_BASE) + 0x278)
+
+#define AB0_CS4WAITCTRL			(IO_ADDRESS(MP200_AB0_BASE) + 0x280)
+#define AB0_CS4WAITCTRL_W		(IO_ADDRESS(MP200_AB0_BASE) + 0x284)
+#define AB0_CS4READCTRL			(IO_ADDRESS(MP200_AB0_BASE) + 0x288)
+#define AB0_CS4WAIT_MASK		(IO_ADDRESS(MP200_AB0_BASE) + 0x28C)
+#define AB0_CS4CONTROL			(IO_ADDRESS(MP200_AB0_BASE) + 0x290)
+
+#define AB0_CS4FLASHRCR			(IO_ADDRESS(MP200_AB0_BASE) + 0x294)
+#define AB0_CS4FLASHWCR			(IO_ADDRESS(MP200_AB0_BASE) + 0x298)
+
+#define AB0_CS5WAITCTRL			(IO_ADDRESS(MP200_AB0_BASE) + 0x2A0)
+#define AB0_CS5WAITCTRL_W		(IO_ADDRESS(MP200_AB0_BASE) + 0x2A4)
+#define AB0_CS5READCTRL			(IO_ADDRESS(MP200_AB0_BASE) + 0x2A8)
+#define AB0_CS5WAIT_MASK		(IO_ADDRESS(MP200_AB0_BASE) + 0x2AC)
+#define AB0_CS5CONTROL			(IO_ADDRESS(MP200_AB0_BASE) + 0x2B0)
+
+#define AB0_CS5FLASHRCR			(IO_ADDRESS(MP200_AB0_BASE) + 0x2B4)
+#define AB0_CS5FLASHWCR			(IO_ADDRESS(MP200_AB0_BASE) + 0x2B8)
+
+
+#define AB0_CS0WAITCTRL2		(IO_ADDRESS(MP200_AB0_BASE) + 0x300)
+#define AB0_CS0WAITCTRL_W2		(IO_ADDRESS(MP200_AB0_BASE) + 0x304)
+#define AB0_CS0READCTRL2		(IO_ADDRESS(MP200_AB0_BASE) + 0x308)
+#define AB0_CS0WAIT_MASK2		(IO_ADDRESS(MP200_AB0_BASE) + 0x30C)
+#define AB0_CS0CONTROL2			(IO_ADDRESS(MP200_AB0_BASE) + 0x310)
+
+#define AB0_CS0FLASHRCR2		(IO_ADDRESS(MP200_AB0_BASE) + 0x314)
+#define AB0_CS0FLASHWCR2		(IO_ADDRESS(MP200_AB0_BASE) + 0x318)
+
+#define AB0_CS1WAITCTRL2		(IO_ADDRESS(MP200_AB0_BASE) + 0x320)
+#define AB0_CS1WAITCTRL_W2		(IO_ADDRESS(MP200_AB0_BASE) + 0x324)
+#define AB0_CS1READCTRL2		(IO_ADDRESS(MP200_AB0_BASE) + 0x328)
+#define AB0_CS1WAIT_MASK2		(IO_ADDRESS(MP200_AB0_BASE) + 0x32C)
+#define AB0_CS1CONTROL2			(IO_ADDRESS(MP200_AB0_BASE) + 0x330)
+
+#define AB0_CS1FLASHRCR2		(IO_ADDRESS(MP200_AB0_BASE) + 0x334)
+#define AB0_CS1FLASHWCR2		(IO_ADDRESS(MP200_AB0_BASE) + 0x338)
+
+#define AB0_CS2WAITCTRL2		(IO_ADDRESS(MP200_AB0_BASE) + 0x340)
+#define AB0_CS2WAITCTRL_W2		(IO_ADDRESS(MP200_AB0_BASE) + 0x344)
+#define AB0_CS2READCTRL2		(IO_ADDRESS(MP200_AB0_BASE) + 0x348)
+#define AB0_CS2WAIT_MASK2		(IO_ADDRESS(MP200_AB0_BASE) + 0x34C)
+#define AB0_CS2CONTROL2			(IO_ADDRESS(MP200_AB0_BASE) + 0x350)
+
+#define AB0_CS2FLASHRCR2		(IO_ADDRESS(MP200_AB0_BASE) + 0x354)
+#define AB0_CS2FLASHWCR2		(IO_ADDRESS(MP200_AB0_BASE) + 0x358)
+
+#define AB0_CS3WAITCTRL2		(IO_ADDRESS(MP200_AB0_BASE) + 0x360)
+#define AB0_CS3WAITCTRL_W2		(IO_ADDRESS(MP200_AB0_BASE) + 0x364)
+#define AB0_CS3READCTRL2		(IO_ADDRESS(MP200_AB0_BASE) + 0x368)
+#define AB0_CS3WAIT_MASK2		(IO_ADDRESS(MP200_AB0_BASE) + 0x36C)
+#define AB0_CS3CONTROL2			(IO_ADDRESS(MP200_AB0_BASE) + 0x370)
+
+#define AB0_CS3FLASHRCR2		(IO_ADDRESS(MP200_AB0_BASE) + 0x374)
+#define AB0_CS3FLASHWCR2		(IO_ADDRESS(MP200_AB0_BASE) + 0x378)
+
+#define AB0_CS4WAITCTRL2		(IO_ADDRESS(MP200_AB0_BASE) + 0x380)
+#define AB0_CS4WAITCTRL_W2		(IO_ADDRESS(MP200_AB0_BASE) + 0x384)
+#define AB0_CS4READCTRL2		(IO_ADDRESS(MP200_AB0_BASE) + 0x388)
+#define AB0_CS4WAIT_MASK2		(IO_ADDRESS(MP200_AB0_BASE) + 0x38C)
+#define AB0_CS4CONTROL2			(IO_ADDRESS(MP200_AB0_BASE) + 0x390)
+
+#define AB0_CS4FLASHRCR2		(IO_ADDRESS(MP200_AB0_BASE) + 0x394)
+#define AB0_CS4FLASHWCR2		(IO_ADDRESS(MP200_AB0_BASE) + 0x398)
+
+#define AB0_CS5WAITCTRL2		(IO_ADDRESS(MP200_AB0_BASE) + 0x3A0)
+#define AB0_CS5WAITCTRL_W2		(IO_ADDRESS(MP200_AB0_BASE) + 0x3A4)
+#define AB0_CS5READCTRL2		(IO_ADDRESS(MP200_AB0_BASE) + 0x3A8)
+#define AB0_CS5WAIT_MASK2		(IO_ADDRESS(MP200_AB0_BASE) + 0x3AC)
+#define AB0_CS5CONTROL2			(IO_ADDRESS(MP200_AB0_BASE) + 0x3B0)
+
+#define AB0_CS5FLASHRCR2		(IO_ADDRESS(MP200_AB0_BASE) + 0x3B4)
+#define AB0_CS5FLASHWCR2		(IO_ADDRESS(MP200_AB0_BASE) + 0x3B8)
+
+
+
+
+/* S0 */
+#define SMU_RESETCTRL0		(IO_ADDRESS(MP200_SMU_BASE) + 0x0000)
+#define SMU_RESETREQ0		(IO_ADDRESS(MP200_SMU_BASE) + 0x0004)
+#define SMU_RESETREQ0ENA	(IO_ADDRESS(MP200_SMU_BASE) + 0x0008)
+#define SMU_RESETREQ1		(IO_ADDRESS(MP200_SMU_BASE) + 0x000c)
+#define SMU_RESETREQ1ENA	(IO_ADDRESS(MP200_SMU_BASE) + 0x0010)
+ /* reserved:0x0014 */
+#define SMU_RESETREQ2		(IO_ADDRESS(MP200_SMU_BASE) + 0x0018)
+#define SMU_RESETREQ2ENA	(IO_ADDRESS(MP200_SMU_BASE) + 0x001c)
+#define SMU_WDT_INT_RESET	(IO_ADDRESS(MP200_SMU_BASE) + 0x0020)
+#define SMU_RESET_PCLK_COUNT	(IO_ADDRESS(MP200_SMU_BASE) + 0x0024)
+ /* reserved:0x0028-0x0078 */
+#define SMU_AUTO_MODE_EN	(IO_ADDRESS(MP200_SMU_BASE) + 0x007C)
+#define SMU_CLK_MODE_SEL	(IO_ADDRESS(MP200_SMU_BASE) + 0x0080)
+#define SMU_PLL1CTRL0		(IO_ADDRESS(MP200_SMU_BASE) + 0x0084)
+#define SMU_PLL1CTRL1		(IO_ADDRESS(MP200_SMU_BASE) + 0x0088)
+#define SMU_PLL2CTRL0		(IO_ADDRESS(MP200_SMU_BASE) + 0x008c)
+#define SMU_PLL2CTRL1		(IO_ADDRESS(MP200_SMU_BASE) + 0x0090)
+#define SMU_PLL3CTRL0		(IO_ADDRESS(MP200_SMU_BASE) + 0x0094)
+#define SMU_PLL3CTRL1		(IO_ADDRESS(MP200_SMU_BASE) + 0x0098)
+#define SMU_PLLLOCKTIME		(IO_ADDRESS(MP200_SMU_BASE) + 0x009c)
+ /* reserved:0x00a0 */
+#define SMU_AUTO_PLL_STANDBY (IO_ADDRESS(MP200_SMU_BASE) + 0x00a8)
+ /* reserved:0x00ac-0x00b0 */
+#define SMU_PLLVDDWAIT		(IO_ADDRESS(MP200_SMU_BASE) + 0x00b4)
+ /* reserved:0x00b8-00c0 */
+#define SMU_CLKSTOPSIG_ST	(IO_ADDRESS(MP200_SMU_BASE) + 0x00c4)
+#define SMU_CLK32_STATUS	(IO_ADDRESS(MP200_SMU_BASE) + 0x00c8)
+#define SMU_POWER_RECORD	(IO_ADDRESS(MP200_SMU_BASE) + 0x00cc)
+#define SMU_INT_STATUS		(IO_ADDRESS(MP200_SMU_BASE) + 0x00d0)
+#define SMU_INT_RAW_STATUS	(IO_ADDRESS(MP200_SMU_BASE) + 0x00d4)
+#define SMU_INT_ENSET		(IO_ADDRESS(MP200_SMU_BASE) + 0x00d8)
+#define SMU_INT_ENCLR		(IO_ADDRESS(MP200_SMU_BASE) + 0x00dc)
+#define SMU_INT_ENMON		(IO_ADDRESS(MP200_SMU_BASE) + 0x00e0)
+#define SMU_INT_CLEAR		(IO_ADDRESS(MP200_SMU_BASE) + 0x00e4)
+#define SMU_NORMALA_DIV		(IO_ADDRESS(MP200_SMU_BASE) + 0x00f0)
+#define SMU_NORMALB_DIV		(IO_ADDRESS(MP200_SMU_BASE) + 0x00f4)
+#define SMU_NORMALC_DIV		(IO_ADDRESS(MP200_SMU_BASE) + 0x00f8)
+#define SMU_NORMALD_DIV		(IO_ADDRESS(MP200_SMU_BASE) + 0x00fc)
+#define SMU_ECONOMY_DIV		(IO_ADDRESS(MP200_SMU_BASE) + 0x0100)
+#define SMU_STANDBY_DIV		(IO_ADDRESS(MP200_SMU_BASE) + 0x0104)
+#define SMU_POWERON_DIV		(IO_ADDRESS(MP200_SMU_BASE) + 0x0108)
+ /* reserved: 0x0110 */
+#define SMU_DIVMSPSCLK		(IO_ADDRESS(MP200_SMU_BASE) + 0x0114)
+#define SMU_DIVSP0SCLK		(IO_ADDRESS(MP200_SMU_BASE) + 0x0118)
+#define SMU_DIVSP1SCLK		(IO_ADDRESS(MP200_SMU_BASE) + 0x011c)
+#define SMU_DIVSP2SCLK		(IO_ADDRESS(MP200_SMU_BASE) + 0x0120)
+ /* reserved: 0x0124 */
+#define SMU_DIVMEMCRCLK		(IO_ADDRESS(MP200_SMU_BASE) + 0x0128)
+#define SMU_DIVCAMSCLK		(IO_ADDRESS(MP200_SMU_BASE) + 0x012C)
+#define SMU_DIVLCDLCLK		(IO_ADDRESS(MP200_SMU_BASE) + 0x0130)
+#define SMU_DIVIICSCLK		(IO_ADDRESS(MP200_SMU_BASE) + 0x0134)
+#define SMU_TI0TIN_SEL		(IO_ADDRESS(MP200_SMU_BASE) + 0x0138)
+#define SMU_TI1TIN_SEL		(IO_ADDRESS(MP200_SMU_BASE) + 0x013c)
+#define SMU_TI2TIN_SEL		(IO_ADDRESS(MP200_SMU_BASE) + 0x0140)
+#define SMU_TI3TIN_SEL		(IO_ADDRESS(MP200_SMU_BASE) + 0x0144)
+#define SMU_TGNTIN_SEL		(IO_ADDRESS(MP200_SMU_BASE) + 0x0148)
+#define SMU_DIVTIMTIN		(IO_ADDRESS(MP200_SMU_BASE) + 0x014c)
+#define SMU_DIVMWISCLK		(IO_ADDRESS(MP200_SMU_BASE) + 0x0150)
+#define SMU_DIVDMATCLK		(IO_ADDRESS(MP200_SMU_BASE) + 0x0154)
+#define SMU_DIVU70SCLK		(IO_ADDRESS(MP200_SMU_BASE) + 0x0158)
+#define SMU_DIVU71SCLK		(IO_ADDRESS(MP200_SMU_BASE) + 0x015c)
+#define SMU_DIVU72SCLK		(IO_ADDRESS(MP200_SMU_BASE) + 0x0160)
+ /* reserved: 0x0164-0x0168 */
+#define SMU_DIVPM0SCLK		(IO_ADDRESS(MP200_SMU_BASE) + 0x016c)
+#define SMU_DIVPM1SCLK		(IO_ADDRESS(MP200_SMU_BASE) + 0x0170)
+
+ /* reserved: 0x0174 */
+#define SMU_DIVREFCLK			(IO_ADDRESS(MP200_SMU_BASE) + 0x0178)
+ /* reserved: 0x017c-0x180 */
+#define SMU_DIVPWMPWCLK	(IO_ADDRESS(MP200_SMU_BASE) + 0x0184)
+ /* reserved: 0x0188-0x194 */
+#define SMU_AHBCLKCTRL0 	(IO_ADDRESS(MP200_SMU_BASE) + 0x01a0)
+#define SMU_AHBCLKCTRL1 	(IO_ADDRESS(MP200_SMU_BASE) + 0x01a4)
+#define SMU_APBCLKCTRL0		(IO_ADDRESS(MP200_SMU_BASE) + 0x01a8)
+#define SMU_APBCLKCTRL1		(IO_ADDRESS(MP200_SMU_BASE) + 0x01ac)
+#define SMU_CLKCTRL			(IO_ADDRESS(MP200_SMU_BASE) + 0x01b0)
+#define SMU_GCLKCTRL0		(IO_ADDRESS(MP200_SMU_BASE) + 0x01b4)
+#define SMU_GCLKCTRL0ENA	(IO_ADDRESS(MP200_SMU_BASE) + 0x01b8)
+#define SMU_GCLKCTRL1		(IO_ADDRESS(MP200_SMU_BASE) + 0x01bc)
+#define SMU_GCLKCTRL1ENA	(IO_ADDRESS(MP200_SMU_BASE) + 0x01c0)
+#define SMU_GCLKCTRL2		(IO_ADDRESS(MP200_SMU_BASE) + 0x01c4)
+#define SMU_GCLKCTRL2ENA	(IO_ADDRESS(MP200_SMU_BASE) + 0x01c8)
+#define SMU_GCLKCTRL3		(IO_ADDRESS(MP200_SMU_BASE) + 0x01cc)
+#define SMU_GCLKCTRL3ENA	(IO_ADDRESS(MP200_SMU_BASE) + 0x01d0)
+/* reserved: 0x01d4-0x01d8 */
+#define SMU_AUTO_FRQ_CHANGE	(IO_ADDRESS(MP200_SMU_BASE) + 0x01dc)
+#define SMU_AUTO_FRQ_MASK0	(IO_ADDRESS(MP200_SMU_BASE) + 0x01e0)
+#define SMU_AUTO_FRQ_MASK1	(IO_ADDRESS(MP200_SMU_BASE) + 0x01e4)
+#define SMU_DFS_HALFMODE	(IO_ADDRESS(MP200_SMU_BASE) + 0x01e8)
+#define SMU_FLA_CLK_DLY		(IO_ADDRESS(MP200_SMU_BASE) + 0x01f0)
+/* reserved: 0x01f4-0x01f8 */
+#define SMU_MEMCCLK270_SEL	(IO_ADDRESS(MP200_SMU_BASE) + 0x01fc)
+/* reserved: 0x0200-0x0204 */
+#define SMU_BGCTRL			(IO_ADDRESS(MP200_SMU_BASE) + 0x0208)
+/* reserved: 0x020c-21c */
+#define SMU_QR_ENA			(IO_ADDRESS(MP200_SMU_BASE) + 0x0220)
+#define SMU_QR_CLKDIV		(IO_ADDRESS(MP200_SMU_BASE) + 0x0224)
+/* reserved: 0x0228-0x0234 */
+#define SMU_FAKE_MODE		(IO_ADDRESS(MP200_SMU_BASE) + 0x0238)
+#define SMU_POWERSW_STATUS	(IO_ADDRESS(MP200_SMU_BASE) + 0x023c)
+#define SMU_POWERSW_ENA		(IO_ADDRESS(MP200_SMU_BASE) + 0x0240)
+#define SMU_L1_POWERSW		(IO_ADDRESS(MP200_SMU_BASE) + 0x0244)
+#define SMU_ACPU_POWERSW	(IO_ADDRESS(MP200_SMU_BASE) + 0x0248)
+#define SMU_ADSP_POWERSW	(IO_ADDRESS(MP200_SMU_BASE) + 0x024c)
+/* reserved: 0x0250 */
+#define SMU_ADSP_BUB		(IO_ADDRESS(MP200_SMU_BASE) + 0x0254)
+#define SMU_ACPU_BUB		(IO_ADDRESS(MP200_SMU_BASE) + 0x0258)
+#define SMU_POWERSW_ACTRL_EN (IO_ADDRESS(MP200_SMU_BASE) + 0x025c)
+#define SMU_LOG1SW_ACTRL	(IO_ADDRESS(MP200_SMU_BASE) + 0x0260)
+#define SMU_ADSPSW_ACTRL	(IO_ADDRESS(MP200_SMU_BASE) + 0x0264)
+#define SMU_L1_BUZ			(IO_ADDRESS(MP200_SMU_BASE) + 0x0268)
+#define SMU_L1_BUZ2			(IO_ADDRESS(MP200_SMU_BASE) + 0x026c)
+#define SMU_ACPUBUFTYPE		(IO_ADDRESS(MP200_SMU_BASE) + 0x0288)
+#define SMU_ADSPBUFTYPE		(IO_ADDRESS(MP200_SMU_BASE) + 0x028c)
+#define SMU_HXBBUFTYPE		(IO_ADDRESS(MP200_SMU_BASE) + 0x0290)
+
+#define SMU_ACPU_INIT		(IO_ADDRESS(MP200_SMU_BASE) + 0x0360)
+#define SMU_MSP_SYSC_OPT0	(IO_ADDRESS(MP200_SMU_BASE) + 0x0368)
+#define SMU_AB1_U70WAITCTRL	(IO_ADDRESS(MP200_SMU_BASE) + 0x03c0)
+#define SMU_AB1_U71WAITCTRL	(IO_ADDRESS(MP200_SMU_BASE) + 0x03c4)
+#define SMU_AB1_U72WAITCTRL	(IO_ADDRESS(MP200_SMU_BASE) + 0x03c8)
+#define SMU_AB1_IIC2WAITCTRL	(IO_ADDRESS(MP200_SMU_BASE) + 0x03cc)
+#define SMU_AB1_IICWAITCTRL	(IO_ADDRESS(MP200_SMU_BASE) + 0x03d0)
+#define SMU_AB1_U70READCTRL	(IO_ADDRESS(MP200_SMU_BASE) + 0x03d4)
+#define SMU_AB1_U71READCTRL	(IO_ADDRESS(MP200_SMU_BASE) + 0x03d8)
+#define SMU_AB1_U72READCTRL	(IO_ADDRESS(MP200_SMU_BASE) + 0x03dc)
+#define SMU_AB1_IIC2READCTRL	(IO_ADDRESS(MP200_SMU_BASE) + 0x03e0)
+#define SMU_AB1_IICREADCTRL	(IO_ADDRESS(MP200_SMU_BASE) + 0x03e4)
+#define SMU_AB1_SDIBWAITCTRL	(IO_ADDRESS(MP200_SMU_BASE) + 0x03e8)
+#define SMU_AB1_SDIBREADCTRL	(IO_ADDRESS(MP200_SMU_BASE) + 0x03ec)
+#define SMU_AB1_SDICWAITCTRL	(IO_ADDRESS(MP200_SMU_BASE) + 0x03f0)
+#define SMU_AB1_SDICREADCTRL	(IO_ADDRESS(MP200_SMU_BASE) + 0x03f4)
+#define SMU_FLASHCLK_CTRL		(IO_ADDRESS(MP200_SMU_BASE) + 0x0494)
+#define SMU_L2_POWERSW_BUZ	(IO_ADDRESS(MP200_SMU_BASE) + 0x0500)
+#define SMU_LOG2SW_ACTRLEN	(IO_ADDRESS(MP200_SMU_BASE) + 0x0504)
+#define SMU_LOG2SW_ACTRL	(IO_ADDRESS(MP200_SMU_BASE) + 0x0508)
+#define SMU_L3_POWERSW_BUZ	(IO_ADDRESS(MP200_SMU_BASE) + 0x050c)
+#define SMU_LOG3SW_ACTRLEN	(IO_ADDRESS(MP200_SMU_BASE) + 0x0510)
+#define SMU_LOG3SW_ACTRL	(IO_ADDRESS(MP200_SMU_BASE) + 0x0514)
+
+#define SMU_PLL_STATUS		(IO_ADDRESS(MP200_SMU_BASE) + 0x0520)
+#define SMU_IO_L0_LM_BUZ	(IO_ADDRESS(MP200_SMU_BASE) + 0x0814)
+#define SMU_RESETREQ3		(IO_ADDRESS(MP200_SMU_BASE) + 0x083c)
+#define SMU_RESETREQ3ENA	(IO_ADDRESS(MP200_SMU_BASE) + 0x0840)
+#define SMU_APBCLKCTRL2		(IO_ADDRESS(MP200_SMU_BASE) + 0x0848)
+#define SMU_GCLKCTRL4		(IO_ADDRESS(MP200_SMU_BASE) + 0x084c)
+#define SMU_GCLKCTRL4ENA	(IO_ADDRESS(MP200_SMU_BASE) + 0x0850)
+#define SMU_AUTO_FRQ_MASK3	(IO_ADDRESS(MP200_SMU_BASE) + 0x0860)
+#define SMU_DFS_FIFOMODE	(IO_ADDRESS(MP200_SMU_BASE) + 0x0864)
+#define SMU_DFS_FIFO_REQMASK	(IO_ADDRESS(MP200_SMU_BASE) + 0x0868)
+#define SMU_LCD_FIFOTHRESHOLD	(IO_ADDRESS(MP200_SMU_BASE) + 0x086c)
+
+#define SMU_DTV_SAFE_RESET	(IO_ADDRESS(MP200_SMU_BASE) + 0x0880)
+#define SMU_USB_SAFE_RESET	(IO_ADDRESS(MP200_SMU_BASE) + 0x0884)
+#define SMU_CLKCTRL1		(IO_ADDRESS(MP200_SMU_BASE) + 0x088c)
+#define SMU_AB1_SDIAWAITCTRL		(IO_ADDRESS(MP200_SMU_BASE) + 0x0890)
+#define SMU_AB1_SDIAREADCTRL		(IO_ADDRESS(MP200_SMU_BASE) + 0x0894)
+#define SMU_MEMC_HAND_SHAKE_FAKE	(IO_ADDRESS(MP200_SMU_BASE) + 0x08a0)
+
+/* DIV register PLL select value */
+#define SMU_PLLSEL_PLL2	(0 << 8)
+#define SMU_PLLSEL_PLL3	(1 << 8)
+#define SMU_PLLSEL_MASK	(1 << 8)
+
+/* DIV register div value */
+#define SMU_DIV1	0x00
+#define SMU_DIV2	0x10
+#define SMU_DIV4	0x30
+#define SMU_DIV6	0x50
+#define SMU_DIV8	0x70
+#define SMU_DIV10	0x90
+#define SMU_DIV12	0xb0
+#define SMU_DIV14	0xd0
+#define SMU_DIV16	0xf0
+#define SMU_DIV20	0x91
+#define SMU_DIV24	0xb1
+#define SMU_DIV28	0xd1
+#define SMU_DIV32	0xf1
+#define SMU_DIV40	0x92
+#define SMU_DIV48	0xb2
+#define SMU_DIV56	0xd2
+#define SMU_DIV64	0xf2
+#define SMU_DIV80	0x93
+#define SMU_DIV96	0xb3
+#define SMU_DIV112	0xd3
+#define SMU_DIV128	0xf3
+#define SMU_DIV160	0x94
+#define SMU_DIV192	0xb4
+#define SMU_DIV224	0xd4
+#define SMU_DIV256	0xf4
+#define SMU_DIV_MASK	0xf7
+
+/* TIN register PLL select value */
+#define TINTIN_SEL_PLL3		0x00000000	/* TIxTIN */
+#define TINTIN_SEL_32768	0x00000001
+#define TINTIN_SEL_32K		0x00000002
+#define MASK_TINTIN_SEL		0x00000003
+#define	TWNTIN_SEL_PLL3		0x00000000	/* TWxTIN */
+#define	TWNTIN_SEL_32768	0x00010000
+#define	TWNTIN_SEL_32K		0x00020000
+#define	MASK_TWNTIN_SEL		0x00030000
+#define TGNTIN_SEL_PLL3		0x00000000
+#define TGNTIN_SEL_32768	0x00111111
+#define TGNTIN_SEL_32K		0x00222222
+
+/*
+ * CHG registers
+ */
+#define CHG_BOOT_MODE		(IO_ADDRESS(MP200_CHG_BASE) + 0x0000)
+#define CHG_L1_HOLD			(IO_ADDRESS(MP200_CHG_BASE) + 0x0004)
+#define CHG_LSI_REVISION	(IO_ADDRESS(MP200_CHG_BASE) + 0x0010)
+#define CHG_CTRL_SDINT		(IO_ADDRESS(MP200_CHG_BASE) + 0x0104)
+#define CHG_CTRL_AB0_BOOT	(IO_ADDRESS(MP200_CHG_BASE) + 0x0108)
+#define CHG_CTRL_OSC		(IO_ADDRESS(MP200_CHG_BASE) + 0x0110)
+#define CHG_PINSEL_G00		(IO_ADDRESS(MP200_CHG_BASE) + 0x0200)
+#define CHG_PINSEL_G16		(IO_ADDRESS(MP200_CHG_BASE) + 0x0204)
+#define CHG_PINSEL_G32		(IO_ADDRESS(MP200_CHG_BASE) + 0x0208)
+#define CHG_PINSEL_G48		(IO_ADDRESS(MP200_CHG_BASE) + 0x020C)
+#define CHG_PINSEL_G64		(IO_ADDRESS(MP200_CHG_BASE) + 0x0210)
+#define CHG_PINSEL_G80		(IO_ADDRESS(MP200_CHG_BASE) + 0x0214)
+#define CHG_PINSEL_G96		(IO_ADDRESS(MP200_CHG_BASE) + 0x0218)
+#define CHG_PINSEL_G112		(IO_ADDRESS(MP200_CHG_BASE) + 0x021C)
+#define CHG_PINSEL_SP0		(IO_ADDRESS(MP200_CHG_BASE) + 0x0280)
+#define CHG_PINSEL_DTV		(IO_ADDRESS(MP200_CHG_BASE) + 0x0284)
+#define CHG_PINSEL_SD0		(IO_ADDRESS(MP200_CHG_BASE) + 0x0288)
+#define CHG_PINSEL_SD1		(IO_ADDRESS(MP200_CHG_BASE) + 0x028C)
+#define CHG_PINSEL_IIC2		(IO_ADDRESS(MP200_CHG_BASE) + 0x0290)
+#define CHG_PINSEL_REFCLK0	(IO_ADDRESS(MP200_CHG_BASE) + 0x0294)
+#define CHG_PULL_G00		(IO_ADDRESS(MP200_CHG_BASE) + 0x0300)
+#define CHG_PULL_G08		(IO_ADDRESS(MP200_CHG_BASE) + 0x0304)
+#define CHG_PULL_G16		(IO_ADDRESS(MP200_CHG_BASE) + 0x0308)
+#define CHG_PULL_G24		(IO_ADDRESS(MP200_CHG_BASE) + 0x030C)
+#define CHG_PULL_G32		(IO_ADDRESS(MP200_CHG_BASE) + 0x0310)
+#define CHG_PULL_G40		(IO_ADDRESS(MP200_CHG_BASE) + 0x0314)
+#define CHG_PULL_G48		(IO_ADDRESS(MP200_CHG_BASE) + 0x0318)
+#define CHG_PULL_G56		(IO_ADDRESS(MP200_CHG_BASE) + 0x031C)
+#define CHG_PULL_G64		(IO_ADDRESS(MP200_CHG_BASE) + 0x0320)
+#define CHG_PULL_G72		(IO_ADDRESS(MP200_CHG_BASE) + 0x0324)
+#define CHG_PULL_G80		(IO_ADDRESS(MP200_CHG_BASE) + 0x0328)
+#define CHG_PULL_G88		(IO_ADDRESS(MP200_CHG_BASE) + 0x032C)
+#define CHG_PULL_G96		(IO_ADDRESS(MP200_CHG_BASE) + 0x0330)
+#define CHG_PULL_G104		(IO_ADDRESS(MP200_CHG_BASE) + 0x0334)
+#define CHG_PULL_G112		(IO_ADDRESS(MP200_CHG_BASE) + 0x0338)
+#define CHG_PULL_G120		(IO_ADDRESS(MP200_CHG_BASE) + 0x033C)
+#define CHG_PULL0			(IO_ADDRESS(MP200_CHG_BASE) + 0x0380)
+#define CHG_PULL1			(IO_ADDRESS(MP200_CHG_BASE) + 0x0384)
+#define CHG_PULL2			(IO_ADDRESS(MP200_CHG_BASE) + 0x0388)
+#define CHG_PULL3			(IO_ADDRESS(MP200_CHG_BASE) + 0x038C)
+#define CHG_DRIVE0			(IO_ADDRESS(MP200_CHG_BASE) + 0x0400)
+#define CHG_DRIVE1			(IO_ADDRESS(MP200_CHG_BASE) + 0x0404)
+#define CHG_DRIVE2			(IO_ADDRESS(MP200_CHG_BASE) + 0x0408)
+
+
+#endif	/* ARCH_ARM_MACH_MP200_SMU_H */
diff --git a/arch/arm/mach-mp200/pm.c b/arch/arm/mach-mp200/pm.c
new file mode 100644
index 0000000..9edb453
--- /dev/null
+++ b/arch/arm/mach-mp200/pm.c
@@ -0,0 +1,702 @@
+/*
+ * linux/arch/arm/mach-mp200/pm.c
+ *
+ * M2 Power Management Routines
+ *
+ * Copyright (C) 2006 Nokia Corporation
+ * Tony Lindgren <tony@atomide.com>
+ *
+ * Copyright (C) 2005 Texas Instruments, Inc.
+ * Richard Woodruff <r-woodruff2@ti.com>
+ *
+ * Copyright (C) 2007 NEC Electronics Corporation
+ *
+ * Based on pm.c for omap2
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/pm.h>
+#include <linux/interrupt.h>
+#ifdef CONFIG_PROC_FS
+#include <linux/proc_fs.h>
+#endif
+#include <linux/io.h>
+#include <linux/uaccess.h>
+#include <asm/irq.h>
+#include <asm/mach/time.h>
+#include <mach/system.h>
+#include <mach/smu.h>
+#include <mach/gpio.h>
+
+#include <linux/irq.h>
+
+int mp200_sleep_while_idle;
+EXPORT_SYMBOL(mp200_sleep_while_idle);
+
+/* refered by mp200_target() */
+void mp200_change_normalx(unsigned int normal_div)
+{
+	ulong auto_frq_change;
+
+	if ((inl(SMU_CLK_MODE_SEL) & 0x00000F00) == (normal_div << 8))
+		return;
+
+	/* auto freq change off */
+	auto_frq_change = inl(SMU_AUTO_FRQ_CHANGE);
+	outl((auto_frq_change & ~0x1), SMU_AUTO_FRQ_CHANGE);
+
+	outl(normal_div, SMU_CLK_MODE_SEL);
+	while ((inl(SMU_CLK_MODE_SEL) & 0x00000F00) != (normal_div << 8))
+		;
+
+	/* restore auto freq change */
+	outl(auto_frq_change, SMU_AUTO_FRQ_CHANGE);
+}
+
+#ifdef CONFIG_PM
+
+#ifndef CONFIG_MP200_QR
+#error CONFIG_MP200_QR not defined
+#endif
+
+/* for get_next_timer_interrupt */
+#if 0
+#if !defined(CONFIG_NO_IDLE_HZ) && !defined(CONFIG_NO_HZ)
+#error CONFIG_NO_IDLE_HZ or CONFIG_NO_HZ not defined
+#endif
+#endif
+
+#include <linux/cpu.h>
+#include <linux/swap.h>
+#include <linux/vmstat.h>
+#include <linux/suspend.h>
+#include <linux/device.h>
+#include <mach/pm.h>
+#include <mach/pmu.h>
+#include <mach/dma.h>
+#include "pm_pmu.h"
+
+
+static int acpu_div;
+static int pm_acpu_div;
+static unsigned long pm_loops_per_jiffy;
+static int sleep_while_idle_enable;
+static unsigned int sleep_while_idle_count;
+static unsigned int pm_idle_count;
+static unsigned int skip_ktimer_idle_count;
+static int pdma_enable;
+static unsigned int suspend_enable;
+
+static int mp200_can_sleep(void);
+static int mp200_enter_state(suspend_state_t state);
+static int mp200_suspend_prepare(suspend_state_t state);
+static int mp200_suspend_enter(suspend_state_t state);
+static void mp200_suspend_finish(suspend_state_t state);
+static int mp200_pm_enter(suspend_state_t state);
+static int mp200_pm_valid(suspend_state_t state);
+static void mp200_pm_finish(void);
+static void variable_init(void);
+
+/* This is just an arbitrary number */
+#define FREE_PAGE_NUMBER (100)
+/* #define PM_DEBUG_STATUS */
+
+void mp200_pm_power_off(void)
+{
+	unsigned long irq_flags;
+
+	/* int mask */
+	local_irq_save(irq_flags);
+
+	/* poweroff setting function*/
+	mp200_pm_do_poweroff();
+
+	printk(KERN_INFO "%s(): AFTER PMU POWER OFF.\n", __func__);
+	/* int unmask */
+	local_irq_restore(irq_flags);	  /* not call */
+}
+
+
+void mp200_pm_idle(void)
+{
+	int suspend_req = 0;
+
+	local_irq_disable();
+	local_fiq_disable();
+	if (need_resched()) {
+		local_fiq_enable();
+		local_irq_enable();
+		return;
+	}
+
+	pm_idle_count++;
+
+	/* for PCM Direct */
+	if (suspend_enable && pdma_enable) {
+		if (!(inl(SMU_POWERSW_STATUS) & 0x00000002))
+			suspend_req = 1;
+	}
+	if (suspend_req) {
+		mp200_sleep_while_idle = 1;
+		if (mp200_can_sleep()) {
+			mp200_enter_state(PM_SUSPEND_STANDBY);	/* L1 OFF */
+			mp200_sleep_while_idle = 0;
+			sleep_while_idle_count++;
+			local_fiq_enable();
+			local_irq_enable();
+			return;
+		}
+		mp200_sleep_while_idle = 0;
+	} else if (sleep_while_idle_enable) {
+		mp200_sleep_while_idle = 1;
+		if (mp200_can_sleep()) {
+			mp200_enter_state(PM_SUSPEND_STANDBY);
+			mp200_sleep_while_idle = 0;
+			sleep_while_idle_count++;
+			local_fiq_enable();
+			local_irq_enable();
+			return;
+		}
+		mp200_sleep_while_idle = 0;
+	}
+
+	/* QR */
+	outl(0x00530103, SMU_QR_ENA);
+	arch_idle();
+	local_fiq_enable();
+	local_irq_enable();
+}
+
+#define GCLKCTRL4_CHECK_BIT	 (\
+	(1 << (MP200_CLOCKGATE_SDIA_CLK & SMU_REG_BIT_MASK)) | \
+	(1 << (MP200_CLOCKGATE_SDIB_CLK & SMU_REG_BIT_MASK)) | \
+	(1 << (MP200_CLOCKGATE_SDIC_CLK & SMU_REG_BIT_MASK)) \
+)
+
+#define GCLKCTRL2_CHECK_BIT	 (\
+	(1 << (MP200_CLOCKGATE_USB_CLK & SMU_REG_BIT_MASK)) \
+)
+
+#define LCD_BASE             IO_ADDRESS(MP200_LCD_BASE)
+#define LCD_LCDOUT           (LCD_BASE + 0x10)
+
+
+static int check_transfer_state(void)
+{
+	if (inl(LCD_LCDOUT))
+		return 1;
+	if (inl(SMU_GCLKCTRL4) & GCLKCTRL4_CHECK_BIT)
+		return 1;
+	if (inl(SMU_GCLKCTRL2) & GCLKCTRL2_CHECK_BIT)
+		return 1;
+	if (mp200_dma_busy())
+		return 1;
+
+	return 0;
+}
+
+
+#define MP200_SLEEP_THRESHOLD 1
+
+static int mp200_can_sleep(void)
+{
+	struct pm_message message = { .event = DEV_SUSPEND_IDLE_1, };
+#if 0
+	unsigned long last_jiffies, delta_jiffies;
+#endif
+	int ret = 0;
+
+	if (!mutex_trylock(&pm_mutex))
+		return 0;
+#if 0
+	/* check kernel timer */
+	last_jiffies = jiffies;
+	delta_jiffies = get_next_timer_interrupt(last_jiffies) - last_jiffies;
+	if (delta_jiffies <= MP200_SLEEP_THRESHOLD) {
+		skip_ktimer_idle_count++;
+		goto Unlock;
+	}
+#endif
+	if (check_transfer_state())
+		goto Unlock;
+
+	if (!device_suspend(message))
+		ret = 1;
+
+	device_resume(PMSG_RESUME); /* restore dpm_list */
+
+ Unlock:
+	mutex_unlock(&pm_mutex);
+	return ret;
+}
+
+static int mp200_enter_state(suspend_state_t state)
+{
+	int error;
+
+	if (!mutex_trylock(&pm_mutex))
+		return -EBUSY;
+
+	error = mp200_suspend_prepare(state);
+	if (error)
+		goto Unlock;
+
+	error = mp200_suspend_enter(state);
+
+	mp200_suspend_finish(state);
+ Unlock:
+	mutex_unlock(&pm_mutex);
+	return error;
+}
+
+static int mp200_suspend_prepare(suspend_state_t state)
+{
+	int error;
+	unsigned int free_pages;
+
+	free_pages = global_page_state(NR_FREE_PAGES);
+	if ((free_pages) < FREE_PAGE_NUMBER) {
+		pr_debug("PM: free some memory\n");
+		shrink_all_memory(FREE_PAGE_NUMBER - free_pages);
+		if (nr_free_pages() < FREE_PAGE_NUMBER) {
+			error = -ENOMEM;
+			printk(KERN_ERR "PM: No enough memory\n");
+			goto Thaw;
+		}
+	}
+
+	if (mp200_pm_valid(state) != 1) {
+		error = -EINVAL;
+		goto Thaw;
+	}
+
+	error = device_suspend(PMSG_SUSPEND);
+	if (error)
+		goto Resume_devices;
+
+	error = disable_nonboot_cpus();
+	if (!error)
+		return 0;
+
+	enable_nonboot_cpus();
+ Resume_devices:
+	mp200_pm_finish();
+	device_resume(PMSG_RESUME);
+ Thaw:
+	return error;
+}
+
+static int mp200_suspend_enter(suspend_state_t state)
+{
+	int error = 0;
+
+	error = device_power_down(PMSG_SUSPEND);
+	if (error) {
+		printk(KERN_ERR "Some devices failed to power down\n");
+		goto Done;
+	}
+
+	error = mp200_pm_enter(state);
+	device_power_up(PMSG_RESUME);
+ Done:
+	return error;
+}
+
+static void mp200_suspend_finish(suspend_state_t state)
+{
+	enable_nonboot_cpus();
+	mp200_pm_finish();
+	device_resume(PMSG_RESUME);
+}
+
+static ssize_t sleep_while_idle_show(struct kobject *kobj,
+			struct kobj_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d %u %u %u\n",
+		sleep_while_idle_enable,
+		sleep_while_idle_count,
+		skip_ktimer_idle_count,
+		pm_idle_count
+		);
+}
+
+static ssize_t sleep_while_idle_store(struct kobject *kobj,
+		struct kobj_attribute *attr, const char *buf, size_t n)
+{
+	int value;
+	if (sscanf(buf, "%d", &value) != 1 ||
+	    (value != 0 && value != 1)) {
+		printk(KERN_ERR "idle_sleep_store: Invalid value\n");
+		return -EINVAL;
+	}
+	sleep_while_idle_enable = value;
+	return n;
+}
+
+static struct kobj_attribute sleep_while_idle_attr =
+	__ATTR(sleep_while_idle, 0644, sleep_while_idle_show,
+						sleep_while_idle_store);
+
+static ssize_t pdma_enable_show(struct kobject *kobj,
+			struct kobj_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", pdma_enable);
+}
+
+static ssize_t pdma_enable_store(struct kobject *kobj,
+		struct kobj_attribute *attr, const char *buf, size_t n)
+{
+	int value;
+	if (sscanf(buf, "%d", &value) != 1 ||
+	    (value != 0 && value != 1)) {
+		printk(KERN_ERR "pdma_enable_store: Invalid value\n");
+		return -EINVAL;
+	}
+	pdma_enable = value;
+	return n;
+}
+
+static struct kobj_attribute pdma_enable_attr =
+	__ATTR(pdma_enable, 0644, pdma_enable_show, pdma_enable_store);
+
+/* div_id=0...NORMALA / 1...NORMALB  / 2...NORMALC */
+static int pm_get_acpu_div(int div_id)
+{
+	ulong div;
+
+	switch (div_id) {
+	case 0:
+		div = (inl(SMU_NORMALA_DIV) & 0x7); break;
+	case 1:
+		div = (inl(SMU_NORMALB_DIV) & 0x7); break;
+	default:
+		div = (inl(SMU_NORMALC_DIV) & 0x7); break;
+	}
+
+	switch (div) {
+	case 0:
+	case 1:
+	case 2:
+	case 3:
+		div += 1; break;
+	case 4:
+		div = 6;  break;
+	case 5:
+		div = 8;  break;
+	default:
+		div = 2; break;
+	}
+
+	return div;
+}
+
+void pm_change_normalA(void)
+{
+	mp200_change_normalx(NORMAL_A);
+
+	loops_per_jiffy = pm_loops_per_jiffy;
+}
+
+void pm_change_normalB(void)
+{
+	mp200_change_normalx(NORMAL_B);
+
+	pm_acpu_div = pm_get_acpu_div(1);
+	loops_per_jiffy = pm_loops_per_jiffy/(pm_acpu_div/acpu_div);
+}
+
+static void mp200_pm_suspend(suspend_state_t state)
+{
+	unsigned int sleep_mode;
+
+	switch (state) {
+	case PM_SUSPEND_STANDBY:
+		sleep_mode = MP200_PMU_CLK_SLEEP;
+		break;
+	case PM_SUSPEND_MEM:
+	default:
+		sleep_mode = MP200_PMU_CLK_POWERDOWN;
+		break;
+	}
+
+	mp200_pmu_sleep(sleep_mode);
+
+}
+
+static int mp200_pm_valid(suspend_state_t state)
+{
+	switch (state) {
+	case PM_SUSPEND_STANDBY:
+	case PM_SUSPEND_MEM:
+		return 1;
+
+	default:
+		return 0;
+	}
+}
+
+static int mp200_pm_enter(suspend_state_t state)
+{
+	switch (state) {
+	case PM_SUSPEND_STANDBY:
+	case PM_SUSPEND_MEM:
+		mp200_pm_suspend(state);
+		break;
+
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static void mp200_pm_finish(void)
+{
+}
+
+static struct platform_suspend_ops mp200_pm_ops = {
+	.valid = mp200_pm_valid,
+	.enter = mp200_pm_enter,
+	.finish = mp200_pm_finish,
+};
+
+
+int mp200_pm_sleep(unsigned int mode)
+{
+	suspend_state_t state;
+	int ret;
+
+	switch (mode) {
+	case PM_SLEEP_MODE_S1:
+	case PM_SLEEP_MODE_S2:
+		state = PM_SUSPEND_STANDBY;
+		break;
+	case PM_SLEEP_MODE_S3:
+		state = PM_SUSPEND_MEM;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	ret = pm_suspend(state);
+
+	return ret;
+}
+
+void mp200_pm_pdma_suspend_enable(void)
+{
+	suspend_enable = 1;
+}
+EXPORT_SYMBOL(mp200_pm_pdma_suspend_enable);
+
+void mp200_pm_pdma_suspend_disable(void)
+{
+	suspend_enable = 0;
+}
+EXPORT_SYMBOL(mp200_pm_pdma_suspend_disable);
+
+unsigned int mp200_pm_pdma_suspend_status(void)
+{
+	return suspend_enable;
+}
+EXPORT_SYMBOL(mp200_pm_pdma_suspend_status);
+
+
+static void variable_init(void)
+{
+	/* initialize static variable */
+	mp200_sleep_while_idle = 0;
+	acpu_div = 0;
+	pm_acpu_div = 0;
+	pm_loops_per_jiffy = 0;
+	sleep_while_idle_enable = 0;
+	sleep_while_idle_count = 0;
+	pm_idle_count = 0;
+	skip_ktimer_idle_count = 0;
+	pdma_enable = 1;
+	suspend_enable = 0;
+}
+
+#ifdef CONFIG_PROC_FS
+
+/*
+ * Writing to /proc/pm puts the CPU in sleep mode
+ */
+static ssize_t mp200_pm_write_proc(struct file *file, const char *buffer,
+				   size_t count, loff_t *ppos)
+{
+	char *buf;
+	char *tok;
+	char *s;
+	char *str;
+	char *whitespace = " \t\r\n";
+	int ret = 0;
+
+	if (current->uid != 0)
+		return -EPERM;
+	if (count == 0)
+		return 0;
+
+	buf = kmalloc(count + 1, GFP_KERNEL);
+	if (buf == NULL) {
+		ret = -ENOMEM;
+		goto exit_2;
+	}
+	if (copy_from_user(buf, buffer, count) != 0) {
+		ret = -EFAULT;
+		goto exit_1;
+	}
+	buf[count] = '\0';
+	s = buf + strspn(buf, whitespace);
+	tok = strsep(&s, whitespace);
+
+	str = "M500";
+	if (strnicmp(tok, str, strlen(str) + 1) == 0) {
+		printk(KERN_INFO "500MHz...\n");
+		pm_change_normalA();
+		goto exit_1;
+	}
+	str = "M166";
+	if (strnicmp(tok, str, strlen(str) + 1) == 0) {
+		printk(KERN_INFO "166MHz...\n");
+		pm_change_normalB();
+		goto exit_1;
+	}
+	str = "S1";
+	if (strnicmp(tok, str, strlen(str) + 1) == 0) {
+		mp200_pm_sleep(PM_SLEEP_MODE_S1);
+		goto exit_1;
+	}
+	str = "S2";
+	if (strnicmp(tok, str, strlen(str) + 1) == 0) {
+		mp200_pm_sleep(PM_SLEEP_MODE_S2);
+		goto exit_1;
+	}
+	str = "S3";
+	if (strnicmp(tok, str, strlen(str) + 1) == 0) {
+		mp200_pm_sleep(PM_SLEEP_MODE_S3);
+		goto exit_1;
+	}
+	str = "PD";
+	if (strnicmp(tok, str, strlen(str) + 1) == 0) {
+		mp200_pm_power_off();
+		goto exit_1;
+	}
+	ret = -EINVAL;
+
+exit_1:
+	kfree(buf);
+exit_2:
+
+	if (ret == 0)
+		return count;
+
+	return ret;
+}
+
+static int mp200_pm_read_proc(char *page, char **start, off_t off, int count,
+			      int *eof, void *data)
+{
+#ifdef PM_DEBUG_REG
+	printk(KERNEL_DEBUG "** SMU registers dump ** \n");
+	printk(KERNEL_DEBUG "SMU_AUTO_FRQ_CHANGE = 0x%08x \n",
+					inl(SMU_AUTO_FRQ_CHANGE));
+	printk(KERNEL_DEBUG "SMU_CLK_MODE_SEL    = 0x%08x \n",
+					inl(SMU_CLK_MODE_SEL));
+	printk(KERNEL_DEBUG "SMU_NORMALA_DIV     = 0x%08x \n",
+					inl(SMU_NORMALA_DIV));
+	printk(KERNEL_DEBUG "SMU_NORMALB_DIV     = 0x%08x \n",
+					inl(SMU_NORMALB_DIV));
+	printk(KERNEL_DEBUG "\n");
+	printk(KERNEL_DEBUG "loops_per_jiffy     = 0x%08x \n",
+				       (unsigned int)loops_per_jiffy);
+#endif				/* PM_DEBUG_REG */
+
+	return 0;
+}
+
+#endif				/* CONFIG_PROC_FS */
+
+int __init mp200_pm_init(void)
+{
+	int ret;
+
+	printk(KERN_INFO "Power Management for MP200.\n");
+
+	/* initialize static variable */
+	variable_init();
+
+	pm_idle = mp200_pm_idle;
+	suspend_set_ops(&mp200_pm_ops);
+	pm_loops_per_jiffy = loops_per_jiffy;
+	acpu_div = pm_get_acpu_div(0);
+
+	ret = sysfs_create_file(power_kobj, &sleep_while_idle_attr.attr);
+	if (ret)
+		printk(KERN_ERR "subsys_create_file failed: %d\n", ret);
+
+	ret = sysfs_create_file(power_kobj, &pdma_enable_attr.attr);
+	if (ret)
+		printk(KERN_ERR
+			"subsys_create_file failed : pdma_enable : %d\n", ret);
+
+#ifdef CONFIG_PROC_FS
+	{
+		struct proc_dir_entry *entry;
+		entry = create_proc_read_entry("pm", S_IWUSR | S_IRUGO, NULL,
+					       mp200_pm_read_proc, 0);
+		if (entry == NULL)
+			return -ENOENT;
+		entry->write_proc = (write_proc_t *) mp200_pm_write_proc;
+	}
+#endif
+
+	pm_power_off = mp200_pm_power_off;
+
+	return 0;
+}
+EXPORT_SYMBOL(mp200_pm_sleep);
+
+#else /* CONFIG_PM */
+
+void mp200_pm_idle(void)
+{
+	local_irq_disable();
+	local_fiq_disable();
+	if (need_resched()) {
+		local_fiq_enable();
+		local_irq_enable();
+		return;
+	}
+
+#ifdef CONFIG_MP200_QR
+	outl(0x00530103, SMU_QR_ENA);
+#else
+	outl(0x00530100, SMU_QR_ENA);
+#endif
+	arch_idle();
+	local_fiq_enable();
+	local_irq_enable();
+}
+
+int __init mp200_pm_init(void)
+{
+	printk(KEN_INFO "Power Management for MP200.\n");
+
+	/* initialize static variable */
+	variable_init();
+
+	pm_idle = mp200_pm_idle;
+
+	return 0;
+}
+
+#endif /* CONFIG_PM */
+
+device_initcall(mp200_pm_init);
diff --git a/arch/arm/mach-mp200/pm_pmu.c b/arch/arm/mach-mp200/pm_pmu.c
new file mode 100644
index 0000000..02bf662
--- /dev/null
+++ b/arch/arm/mach-mp200/pm_pmu.c
@@ -0,0 +1,1526 @@
+
+/*
+ *  File Name	    : linux/arch/arm/mach-mp200/pmu.c
+ *  Function	    : pmu
+ *  Release Version : Ver 1.21
+ *  Release Date    : 2009/08/18
+ *
+ *  Copyright (C) NEC Electronics Corporation 2009
+ *
+ *
+ *  This program is free software;you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License as published by Free
+ *  Softwere Foundation; either version 2 of License, or (at your option) any
+ *  later version.
+ *
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warrnty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; If not, write to the Free Software Foundation, Inc., 59
+ *  Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#ifndef CONFIG_MP200_QR
+#error CONFIG_MP200_QR not defined
+#endif
+
+char const pmu_version[] =
+		"PMU sequencer ver1.21 and Compiled "__DATE__" "__TIME__"";
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/mm.h>
+#include <linux/pm.h>
+#include <linux/delay.h>
+#include <linux/io.h>
+#include <linux/jiffies.h>
+
+#include <asm/irq.h>
+#include <mach/pmu.h>
+#include <mach/pwc.h>
+#include <mach/smu.h>
+#include <mach/pcm_irq.h>
+#include <mach/pm.h>
+#include <mach/timer.h>
+#include <asm/cacheflush.h>
+
+#include "pm_pmu.h"
+#include "time.h"
+
+#include <mach/spi.h>
+
+/* flag for debug */
+/* #define IDLE_DEBUG_LOG */
+/* #define IDLE_DEBUG_TW1_WAKEUP */
+/* #define L2_DISABLE */
+/* #define L1_AUTO_ENABLE */
+/* #define USB_SUSPEND_ENA */
+#ifdef	CONFIG_MP200_EM1_DKIT
+#define DEBUG_LED
+#endif
+
+#ifdef IDLE_DEBUG_LOG
+#define DPRINTK(format, args...) printk(KERN_INFO "PMU_DEBUG: " format, ##args)
+#else
+#define DPRINTK(format, args...)
+#endif
+
+#ifdef IDLE_DEBUG_TW1_WAKEUP
+static void tw1_test_wakeup(void)
+{
+	disable_irq(INT_WDT1);
+
+	outl(0x00000800,	SMU_GCLKCTRL3ENA);
+	outl(0x00000800,	SMU_GCLKCTRL3);
+	outl(0x00000000,	SMU_GCLKCTRL3ENA);
+
+	outl(0x00000020,  SMU_RESETREQ1ENA);
+	outl(0x00000020,  SMU_RESETREQ1);
+	outl(0x00000000,  SMU_RESETREQ1ENA);
+
+	/* WDT1:11.4688MHz (=PLL3(229.376MHz)/20) */
+	outl(0x0000ffff, IO_ADDRESS(MP200_WDT1_BASE) + 0x8);   /* 5sec */
+	outl(7, IO_ADDRESS(MP200_WDT1_BASE));	/* set TO_EN/TSTART/TM_EN */
+
+	enable_irq(INT_WDT1);
+	return;
+
+}
+#endif
+
+static struct register_state_t reg_state;
+
+static unsigned int wdt_op_reg;
+
+static void (*restore_state_async_bus)(void);
+
+static struct async_bus_state async_bus_state_cs0;
+static struct async_bus_state async_bus_state_cs1;
+static struct async_bus_state async_bus_state_cs2;
+static struct async_bus_state async_bus_state_cs3;
+
+#define WDT_OP IO_ADDRESS(MP200_WDT0_BASE)
+
+static inline int pwr_reg_write(u_char addr, u_char data)
+{
+	return pwc_write(addr, data, 0xff);
+}
+
+static inline int pwr_reg_read(u_char addr, u_char *data)
+{
+	unsigned int d;
+	int ret;
+	ret = pwc_read(addr, &d);
+	*data = (u_char)d;
+	return ret;
+}
+
+#define PDM_INT_ENA			0x00082000 /* PDMA_INT | PM0_INT */
+#define	TIMER2_BASE			IO_ADDRESS(MP200_TIMER2_BASE)
+#define	TIMER2_OP			(TIMER2_BASE + 0x0000)
+#define	TIMER2_SET			(TIMER2_BASE + 0x0008)
+#define TIMER2_RCR			(TIMER2_BASE + 0x000c)
+#define	TIMER2_INT_220MS	((TIMER_CLOCK_TICK_RATE_PLL3 * 22) / 100)
+
+/*
+ * INTC mask and unmask
+ *
+ */
+int pmu_intc_mask(int mask)
+{
+	struct intc_state *state = &reg_state.intc;
+
+	switch (mask) {
+	case PMU_INTC_MASK_SAVE_AND_MASK:
+		DPRINTK("mask = PMU_INTC_MASK_SAVE_AND_MASK\n");
+		state->it0_ien0 = inl(INTC_IT0_IMN0);
+		state->it0_ien1 = inl(INTC_IT0_IMN1);
+		state->it0_ien2 = inl(INTC_IT0_IMN2);
+
+		outl(MASK_INTC_ALL, INTC_IT0_IDS0);
+		outl(MASK_INTC_ALL, INTC_IT0_IDS1);
+		outl(MASK_INTC_ALL, INTC_IT0_IDS2);
+
+		if (mp200_sleep_while_idle) {
+			outl((RESUME_INTC_1 | TI2_INT), INTC_IT0_IEN1);
+			outl(PDM_INT_ENA, INTC_IT0_IEN0);
+		} else {
+#ifndef IDLE_DEBUG_TW1_WAKEUP
+			outl(RESUME_INTC_1, INTC_IT0_IEN1);
+#else
+			outl((RESUME_INTC_1 | TW1_INT), INTC_IT0_IEN1);
+#endif
+		}
+
+		outl(SEC_ERR_INT, INTC_IT0_IEN2);
+
+		DPRINTK("Save:IT0_IMN0 = 0x%08x, Set:IT0_IDS0 = 0x%08x \n",
+			state->it0_ien0, MASK_INTC_ALL);
+		DPRINTK("Save:IT0_IMN1 = 0x%08x, Set:IT0_IDS1 = 0x%08x \n",
+			state->it0_ien1, MASK_INTC_ALL);
+		DPRINTK("Save:IT0_IMN2 = 0x%08x, Set:IT0_IDS2 = 0x%08x \n",
+			state->it0_ien2, MASK_INTC_ALL);
+		DPRINTK("unmask:IT0_IEN0 = 0x%08x\n", inl(INTC_IT0_IEN0));
+		DPRINTK("Unmask:IT0_IEN1 = 0x%08x\n", RESUME_INTC_1);
+		DPRINTK("Unmask:IT0_IEN2 = 0x%08x\n", RESUME_INTC_2);
+		break;
+	case PMU_INTC_MASK_RESTORE:
+		outl(MASK_INTC_ALL, INTC_IT0_IDS0);
+		outl(MASK_INTC_ALL, INTC_IT0_IDS1);
+		outl(MASK_INTC_ALL, INTC_IT0_IDS2);
+		outl(state->it0_ien0, INTC_IT0_IEN0);
+		outl(state->it0_ien1, INTC_IT0_IEN1);
+		outl(state->it0_ien2, INTC_IT0_IEN2);
+		DPRINTK("Restore:IT0_IMN0 = 0x%08x\n", inl(INTC_IT0_IMN0));
+		DPRINTK("Restore:IT0_IMN1 = 0x%08x\n", inl(INTC_IT0_IMN1));
+		DPRINTK("Restore:IT0_IMN2 = 0x%08x\n", inl(INTC_IT0_IMN2));
+		break;
+	case PMU_INTC_ALLMASK:
+		outl(MASK_INTC_ALL, INTC_IT0_IDS0);
+		outl(MASK_INTC_ALL, INTC_IT0_IDS1);
+		outl(MASK_INTC_ALL, INTC_IT0_IDS2);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+/*
+ * GPIO mask and unmask
+ *
+ */
+static int pmu_gpio_mask(int flag)
+{
+	struct gpio_state *gpio = &reg_state.gpio;
+	struct pwc_state *pwc = &reg_state.pwc;
+
+	/* GPIO/PowerIC_GPIO Interrupt Enable/Disable */
+	switch (flag) {
+	case MP200_PMU_CLK_FULLSPEED:
+	{
+		outl(MASK_GPIO_ALL, GPIO_GP_IDSL);
+		outl(MASK_GPIO_ALL, GPIO_GP_IDSH);
+		outl(MASK_GPIO_ALL, GPIO_GP_IDSHH);
+		outl(MASK_GPIO_ALL, GPIO_GP_IDSHHH);
+
+		outl(gpio->ien0, GPIO_GP_IENL);
+		outl(gpio->ien1, GPIO_GP_IENH);
+		outl(gpio->ien2, GPIO_GP_IENHH);
+		outl(gpio->ien3, GPIO_GP_IENHHH);
+
+#ifdef	CONFIG_MP200_EM1_DKIT
+		pwc_reg_write(DA9052_IRQMASKD_REG, pwc->fmask1);
+#else
+		pwc_write(PWC_FMASK1, pwc->fmask1, MASK_GPIO_KEYSCAN);
+		pwc_write(PWC_CLRFACT1, MASK_GPIO_KEYDATA, MASK_GPIO_KEYDATA);
+		pwc_write(PWC_BMASK1, pwc->bmask1, MASK_GPIO_KEYSCAN);
+		pwc_write(PWC_IOOUT1, pwc->ioout1, MASK_GPIO_KEYSCAN);
+		pwc_write(PWC_FMASK2, pwc->fmask2, PWC_SD_DETECT);
+		pwc_write(PWC_BMASK2, pwc->bmask2, PWC_SD_DETECT);
+#ifdef USB_SUSPEND_ENA
+		pwc_write(PWC_DETMOD3H, pwc->detmod3, MASK_DETMODE3H_USBWKM);
+		pwc_write(PWC_FMASK3, pwc->fmask3, MASK_USBWAKINT);
+		pwc_write(PWC_BMASK3, pwc->bmask3, MASK_USBWAKINT);
+#endif
+#endif
+		DPRINTK("GPIO_GP_IIML = 0x%08x\n", inl(GPIO_GP_IIML));
+		DPRINTK("GPIO_GP_IIMH = 0x%08x\n", inl(GPIO_GP_IIMH));
+		DPRINTK("GPIO_GP_IIMHH = 0x%08x\n", inl(GPIO_GP_IIMHH));
+		DPRINTK("GPIO_GP_IIMHHH = 0x%08x\n", inl(GPIO_GP_IIMHHH));
+		break;
+	}
+	case MP200_PMU_CLK_SLEEP:
+	case MP200_PMU_CLK_POWERDOWN:
+	{
+		DPRINTK("Sleep or PowerDown\n");
+		gpio->ien0 = inl(GPIO_GP_IIML);
+		gpio->ien1 = inl(GPIO_GP_IIMH);
+		gpio->ien2 = inl(GPIO_GP_IIMHH);
+		gpio->ien3 = inl(GPIO_GP_IIMHHH);
+
+		outl(MASK_GPIO_ALL, GPIO_GP_IDSL);
+		outl(MASK_GPIO_ALL, GPIO_GP_IDSH);
+		outl(MASK_GPIO_ALL, GPIO_GP_IDSHH);
+		outl(MASK_GPIO_ALL, GPIO_GP_IDSHHH);
+
+		outl(GPIO_INT_PWRIC, GPIO_GP_IENL);
+#ifdef	CONFIG_MP200_EM1_DKIT
+		pwr_reg_read(DA9052_IRQMASKD_REG, &pwc->fmask1);
+
+		pwc_reg_write(DA9052_IRQMASKD_REG, ((UNMASK_PWC_ALL &
+				PWC_KEY_INT) | (pwc->fmask1 & ~PWC_KEY_INT)));
+#else
+		pwr_reg_read(PWC_FMASK1, &pwc->fmask1);
+		pwr_reg_read(PWC_BMASK1, &pwc->bmask1);
+		pwr_reg_read(PWC_IOOUT1, &pwc->ioout1);
+
+		pwr_reg_read(PWC_FMASK2, &pwc->fmask2);
+		pwr_reg_read(PWC_BMASK2, &pwc->bmask2);
+
+#ifdef USB_SUSPEND_ENA
+		pwr_reg_read(PWC_FMASK3, &pwc->fmask3);
+		pwr_reg_read(PWC_BMASK3, &pwc->bmask3);
+		pwr_reg_read(PWC_DETMOD3H, &pwc->detmod3);
+#endif
+
+		if (flag == MP200_PMU_CLK_POWERDOWN)
+			pwc_write(PWC_WAKECONT, WAKECONT_WAKEWAIT_DISABLE,
+						MASK_WAKECONT_WAKEWAIT);
+
+		pwc_write(PWC_STATE1, MASK_GPIO_KEYDATA, MASK_GPIO_KEYDATA);
+
+		pwc_write(PWC_FMASK1, MASK_GPIO_KEYDATA, MASK_GPIO_KEYDATA);
+		pwc_write(PWC_CLRFACT1, MASK_GPIO_KEYDATA, MASK_GPIO_KEYDATA);
+		pwc_write(PWC_BMASK1, MASK_GPIO_KEYDATA, MASK_GPIO_KEYDATA);
+		pwc_write(PWC_IOOUT1, MASK_GPIO_RESUME_KEY, MASK_GPIO_KEYSCAN);
+		pwc_write(PWC_FMASK2, DETECT_OFF, PWC_SD_DETECT);
+		pwc_write(PWC_BMASK2, DETECT_OFF, PWC_SD_DETECT);
+#endif
+		DPRINTK("fmask1 = 0x%08x\n", pwc->fmask1);
+		DPRINTK("clrfact1 = 0x%08x\n", pwc->clrfact1);
+		DPRINTK("bmask1 = 0x%08x\n", pwc->bmask1);
+		DPRINTK("ioout1 = 0x%08x\n", pwc->ioout1);
+
+#ifdef USB_SUSPEND_ENA
+		pwc_write(PWC_FMASK3, MASK_USBWAKINT, MASK_USBWAKINT);
+		pwc_write(PWC_DETMOD3H, DETMODE3H_USBWKM_RISE,
+						MASK_DETMODE3H_USBWKM);
+		pwc_write(PWC_CLRFACT3, MASK_USBWAKINT, MASK_USBWAKINT);
+		pwc_write(PWC_BMASK3, MASK_USBWAKINT, MASK_USBWAKINT);
+#endif
+		DPRINTK("save_state ien0 = 0x%08x\n", gpio->ien0);
+		DPRINTK("save_state ien1 = 0x%08x\n", gpio->ien1);
+		DPRINTK("save_state ien2 = 0x%08x\n", gpio->ien2);
+		DPRINTK("save_state ien3 = 0x%08x\n", gpio->ien3);
+		break;
+	}
+	case MP200_PMU_CLK_POWEROFF:
+	{
+		outl(MASK_GPIO_ALL, GPIO_GP_IDSL);
+		outl(MASK_GPIO_ALL, GPIO_GP_IDSH);
+		outl(MASK_GPIO_ALL, GPIO_GP_IDSHH);
+		outl(MASK_GPIO_ALL, GPIO_GP_IDSHHH);
+#ifdef	CONFIG_MP200_EM1_DKIT
+		pwc_write(DA9052_IRQMASKA_REG, MASK_PWC_ALL, MASK_PWC_ALL);
+		pwc_write(DA9052_IRQMASKB_REG, MASK_PWC_ALL, MASK_PWC_ALL);
+		pwc_write(DA9052_IRQMASKC_REG, MASK_PWC_ALL, MASK_PWC_ALL);
+		pwc_write(DA9052_IRQMASKD_REG, UNMASK_KEY_IN2, MASK_PWC_ALL);
+#endif
+		break;
+	}
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+/*
+ * REGGP3(for eMMC/SD) power control
+ *
+ */
+static int pmu_emmc_pw_ctrl(int power)
+{
+	struct chg_state *state = &reg_state.chg;
+
+	switch (power) {
+	case PMU_EMMC_POWER_OFF:
+		DPRINTK("power = PMU_EMMC_POWER_OFF\n");
+		state->pinsel_g80  = inl(CHG_PINSEL_G80);
+		state->pinsel_g112 = inl(CHG_PINSEL_G112);
+		outl((state->pinsel_g80 & ~CHG_PIN_G80_SD0SD2),
+							CHG_PINSEL_G80);
+		outl(CHG_PIN_G112_GIO, CHG_PINSEL_G112);
+		DPRINTK("Save:CHG_PINSEL_G80  = 0x%08x -> 0x%08x\n",
+				state->pinsel_g80, inl(CHG_PINSEL_G80));
+		DPRINTK("Save:CHG_PINSEL_G112 = 0x%08x -> 0x%08x\n",
+				state->pinsel_g112, inl(CHG_PINSEL_G112));
+#ifdef	CONFIG_MP200_EM1_DKIT
+#else
+		pwc_write(PWC_PSCNT2, PWC_POWER_OFF, PWC_REGGP3);
+#endif
+		break;
+	case PMU_EMMC_POWER_ON:
+		DPRINTK("power = PMU_EMMC_POWER_ON\n");
+#ifdef	CONFIG_MP200_EM1_DKIT
+#else
+		pwc_write(PWC_PSCNT2, PWC_POWER_ON, PWC_REGGP3);
+#endif
+		outl(state->pinsel_g80,  CHG_PINSEL_G80);
+		outl(state->pinsel_g112, CHG_PINSEL_G112);
+		DPRINTK("Restore:CHG_PINSEL_G80  = 0x%08x\n",
+						inl(CHG_PINSEL_G80));
+		DPRINTK("Restore:CHG_PINSEL_G112 = 0x%08x\n",
+						inl(CHG_PINSEL_G112));
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+/*
+ * Set PMU Command Sequence
+ *
+ */
+static void pmu_set_command_sequence(unsigned int sleep_flag)
+{
+	unsigned tmp_pc;
+	unsigned int *pmu_cmd_adr;
+
+	pmu_cmd_adr = PMU_PC_TO_VIRADDR(PMU_PC_MAIN);
+
+	/******************************************************************/
+	/********** PowerOffSequence (Sleep/DeepSleep/PowerOff) ***********/
+	/******************************************************************/
+	/* M-1 */
+	PCMD_REG_WRITE(ASMU_MACRO, SMU_CMD_POWERSW_ENA, 0x000fff05);
+	/* M-2 */
+	PCMD_RWM(ASMU_MACRO, SMU_CMD_QR_ENA, 0x00000002, 0x00000002);
+	PCMD_QR_WAIT(PMU_QR_WAIT_BACKUP);
+	/* M-3 */
+	PCMD_INT_MASK(PMU_INT_MASK);
+	/* M-5 */
+	PCMD_REG_WRITE(CHG_MACRO, CHG_CMD_CHG_L1_HOLD, 0x00000001);
+	PCMD_REG_WRITE(CHG_MACRO, CHG_CMD_CHG_L1_HOLD, 0x00000003);
+
+	/* M-6 */
+	if ((sleep_flag & MP200_PMU_CLK_MASK) != MP200_PMU_CLK_POWEROFF) {
+		tmp_pc = PMU_VIRADDR_TO_PC((unsigned int)pmu_cmd_adr);
+		PCMD_REG_READ(MEMC_MACRO, MEMC_CMD_DDR_STATE8, PMU_REGB);
+		PCMD_AND(0x0000000f, PMU_REGB);
+		PCMD_CMP2(0x00000003, PMU_REGB);
+		PCMD_BRANCH(tmp_pc, PMU_BNE);
+	} else {
+		PCMD_SUBROUTINE_START(PMU_PC_MEMC_DEEP_POWERDOWN);
+	}
+
+	PCMD_REG_WRITE(ASMU_MACRO, SMU_CMD_IO_L0_LM_BUZ, 0x00000000);
+	PCMD_SUBROUTINE_START(PMU_PC_MEMC1);
+	PCMD_SUBROUTINE_START(PMU_PC_L1POWEROFF);
+	PCMD_SUBROUTINE_START(PMU_PC_L2POWEROFF);
+
+	/* M-7 */
+	PCMD_REG_WRITE(ASMU_MACRO, SMU_CMD_MEMC_HAND_SHAKE_FAKE, 0x00000001);
+	PCMD_REG_WRITE(ASMU_MACRO, SMU_CMD_RESETREQ2ENA, 0x0000000a);
+	PCMD_REG_WRITE(ASMU_MACRO, SMU_CMD_RESETREQ2, 0x00000000);
+	PCMD_NOP();
+	PCMD_NOP();
+	PCMD_NOP();
+	PCMD_REG_WRITE(ASMU_MACRO, SMU_CMD_RESETREQ2ENA, 0x00000000);
+	PCMD_NOP();
+
+	/* M-8 */
+	PCMD_REG_WRITE(ASMU_MACRO, SMU_CMD_CLK_MODE_SEL, 0x00000005);
+	PCMD_NOP();
+	PCMD_SMU_READY_WAIT(PMU_HIGH_LEVEL);
+
+	/* M-9 */
+	tmp_pc = PMU_VIRADDR_TO_PC((unsigned int)pmu_cmd_adr);
+	PCMD_REG_READ(ASMU_MACRO, SMU_CMD_CLK_MODE_SEL, PMU_REGB);
+	PCMD_AND(0x00000f00, PMU_REGB);
+	PCMD_CMP2(0x00000500, PMU_REGB);
+	PCMD_BRANCH(tmp_pc, PMU_BNE);
+	/* M-10 */
+	PCMD_REG_WRITE(ASMU_MACRO, SMU_CMD_CLK_MODE_SEL, 0x00000006);
+	PCMD_NOP();
+	PCMD_SMU_READY_WAIT(PMU_HIGH_LEVEL);
+	/* M-11 */
+	tmp_pc = PMU_VIRADDR_TO_PC((unsigned int)pmu_cmd_adr);
+	PCMD_REG_READ(ASMU_MACRO, SMU_CMD_CLK_MODE_SEL, PMU_REGB);
+	PCMD_AND(0x00000f00, PMU_REGB);
+	PCMD_CMP2(0x00000600, PMU_REGB);
+	PCMD_BRANCH(tmp_pc, PMU_BNE);
+	/* M-12 */
+	if ((sleep_flag & MP200_PMU_CLK_MASK) == MP200_PMU_CLK_POWERDOWN)
+		PCMD_AJUMP(PMU_PC_POWERDOWN)
+	else if ((sleep_flag & MP200_PMU_CLK_MASK) == MP200_PMU_CLK_POWEROFF)
+		PCMD_AJUMP(PMU_PC_POWEROFF)
+	else
+		PCMD_AJUMP(PMU_PC_SLEEP)
+
+	pmu_cmd_adr = PMU_PC_TO_VIRADDR(PMU_PC_SLEEP);
+	/***************************/
+	/********** Sleep **********/
+	/***************************/
+	if ((sleep_flag & MP200_PMU_CLK_MASK) == MP200_PMU_CLK_SLEEP) {
+		/* SLP-1 */
+		PCMD_WDT_STOP();
+		/* SLP-2 */
+		PCMD_REG_WRITE(ASMU_MACRO, SMU_CMD_CLK_MODE_SEL, 0x00000007);
+		PCMD_NOP();
+		PCMD_SMU_READY_WAIT(PMU_HIGH_LEVEL);
+		/* SLP-3 */
+		PCMD_REG_WRITE(ASMU_MACRO, SMU_CMD_PLL1CTRL1, 0x000000ff);
+		/* SLP-4 */
+		PCMD_CYCLE_WAIT(0x1b0, PMU_WAIT_INT_CONTINUE);
+		/* SLP-5 Wait INTC */
+		PCMD_TRIG_WAIT(1, PMU_TRIG_INT);
+		/* SLP-6 */
+		PCMD_WDT_RESTART();
+		/* SLP-7 */
+		PCMD_REG_WRITE(ASMU_MACRO, SMU_CMD_CLK_MODE_SEL, 0x00000000);
+		PCMD_NOP();
+		PCMD_SMU_READY_WAIT(PMU_HIGH_LEVEL);
+		/* SLP-8 */
+		PCMD_REG_WRITE(ASMU_MACRO, SMU_CMD_PLL1CTRL1, 0x00000000);
+		/* SLP-9 */
+		PCMD_AJUMP(PMU_PC_POWER_ON_SEQUENCE);
+	}
+
+	pmu_cmd_adr = PMU_PC_TO_VIRADDR(PMU_PC_POWERDOWN);
+	/***************************/
+	/******** PowerDown ********/
+	/***************************/
+	if ((sleep_flag & MP200_PMU_CLK_MASK) == MP200_PMU_CLK_POWERDOWN) {
+		/* PWRDWN-1 */
+		PCMD_SUBROUTINE_START(PMU_PC_SPI_ENABLE);
+#ifdef	CONFIG_MP200_EM1_DKIT
+#ifdef	DEBUG_LED
+		/* LED1 ON (R28 <- 0xa2) */
+		PCMD_REG_WRITE(SPI0_MACRO, SPI_CMD_SPx_TX_DATA, 0x000038a2);
+		PCMD_SP0_WRITE(SPI_CMD_SPx_CONTROL, 0x00000009);
+		PCMD_REG_WRITE(SPI0_MACRO, SPI_CMD_SPx_FFCLR, 0x000000ff);
+#endif
+		/* PWRDWN-D9052-1 (R29 <- 0xb0) */
+		PCMD_REG_WRITE(SPI0_MACRO, SPI_CMD_SPx_TX_DATA, 0x00003ab0);
+		PCMD_SP0_WRITE(SPI_CMD_SPx_CONTROL, 0x00000009);
+		PCMD_REG_WRITE(SPI0_MACRO, SPI_CMD_SPx_FFCLR, 0x000000ff);
+		/* PWRDWN-D9052-2 (R47 <- 0xca) */
+		PCMD_REG_WRITE(SPI0_MACRO, SPI_CMD_SPx_TX_DATA, 0x00005eca);
+		PCMD_SP0_WRITE(SPI_CMD_SPx_CONTROL, 0x00000009);
+		PCMD_REG_WRITE(SPI0_MACRO, SPI_CMD_SPx_FFCLR, 0x000000ff);
+		/* PWRDWN-D9052-3 (R44 <- 0x88) */
+		PCMD_REG_WRITE(SPI0_MACRO, SPI_CMD_SPx_TX_DATA, 0x00005888);
+		PCMD_SP0_WRITE(SPI_CMD_SPx_CONTROL, 0x00000009);
+		PCMD_REG_WRITE(SPI0_MACRO, SPI_CMD_SPx_FFCLR, 0x000000ff);
+		/* PWRDWN-D9052-4 (R45 <- 0x88) */
+		PCMD_REG_WRITE(SPI0_MACRO, SPI_CMD_SPx_TX_DATA, 0x00005a88);
+		PCMD_SP0_WRITE(SPI_CMD_SPx_CONTROL, 0x00000009);
+		PCMD_REG_WRITE(SPI0_MACRO, SPI_CMD_SPx_FFCLR, 0x000000ff);
+		/* PWRDWN-D9052-5 (R18 <- 0x02) */
+		PCMD_REG_WRITE(SPI0_MACRO, SPI_CMD_SPx_TX_DATA, 0x00002402);
+		PCMD_SP0_WRITE(SPI_CMD_SPx_CONTROL, 0x00000009);
+		PCMD_REG_WRITE(SPI0_MACRO, SPI_CMD_SPx_FFCLR, 0x000000ff);
+		/* PWRDWN-D9052-6 (R43 <- 0xc5) */
+		PCMD_REG_WRITE(SPI0_MACRO, SPI_CMD_SPx_TX_DATA, 0x000056c5);
+		PCMD_SP0_WRITE(SPI_CMD_SPx_CONTROL, 0x00000009);
+		PCMD_REG_WRITE(SPI0_MACRO, SPI_CMD_SPx_FFCLR, 0x000000ff);
+		/* PWRDWN-D9052-7 (R15 <- 0x6c) */
+		PCMD_REG_WRITE(SPI0_MACRO, SPI_CMD_SPx_TX_DATA, 0x00001e6c);
+		PCMD_SP0_WRITE(SPI_CMD_SPx_CONTROL, 0x00000009);
+		PCMD_REG_WRITE(SPI0_MACRO, SPI_CMD_SPx_FFCLR, 0x000000ff);
+#else
+		/* PWRDWN-2 */
+		PCMD_REG_WRITE(SPI0_MACRO, SPI_CMD_SPx_TX_DATA, 0x00006e03);
+		PCMD_SP0_WRITE(SPI_CMD_SPx_CONTROL, 0x00000009);
+		PCMD_REG_WRITE(SPI0_MACRO, SPI_CMD_SPx_FFCLR, 0x000000ff);
+		/* PWRDWN-3 */
+		PCMD_REG_WRITE(SPI0_MACRO, SPI_CMD_SPx_TX_DATA, 0x00009202);
+		PCMD_SP0_WRITE(SPI_CMD_SPx_CONTROL, 0x00000009);
+		PCMD_REG_WRITE(SPI0_MACRO, SPI_CMD_SPx_FFCLR, 0x000000ff);
+		/* PWRDWN-4 */
+		PCMD_REG_WRITE(SPI0_MACRO, SPI_CMD_SPx_TX_DATA, 0x00000aa3);
+		PCMD_SP0_WRITE(SPI_CMD_SPx_CONTROL, 0x00000009);
+		PCMD_REG_WRITE(SPI0_MACRO, SPI_CMD_SPx_FFCLR, 0x000000ff);
+		/* PWRDWN-5 */
+		PCMD_REG_WRITE(SPI0_MACRO, SPI_CMD_SPx_TX_DATA, 0x0000021d);
+		PCMD_SP0_WRITE(SPI_CMD_SPx_CONTROL, 0x00000009);
+		PCMD_REG_WRITE(SPI0_MACRO, SPI_CMD_SPx_FFCLR, 0x000000ff);
+#endif
+		/* PWRDWN-6 */
+		PCMD_SUBROUTINE_START(PMU_PC_SPI_DISABLE);
+		/* PWRDWN-7 */
+		PCMD_REG_WRITE(ASMU_MACRO, SMU_CMD_AUTO_MODE_EN, 0x00020100);
+		PCMD_NOP();
+		PCMD_NOP();
+		PCMD_NOP();
+		/* PWRDWN-8 */
+		PCMD_WDT_STOP();
+#ifdef	DEBUG_LED
+		PCMD_SUBROUTINE_START(PMU_PC_SPI_ENABLE);
+		/* LED2 ON (R28 <- 0x22) */
+		PCMD_REG_WRITE(SPI0_MACRO, SPI_CMD_SPx_TX_DATA, 0x00003822);
+		PCMD_SP0_WRITE(SPI_CMD_SPx_CONTROL, 0x00000009);
+		PCMD_REG_WRITE(SPI0_MACRO, SPI_CMD_SPx_FFCLR, 0x000000ff);
+		PCMD_SUBROUTINE_START(PMU_PC_SPI_DISABLE);
+#endif
+		/* PWRDWN-9 */
+		PCMD_REG_WRITE(ASMU_MACRO, SMU_CMD_CLK_MODE_SEL, 0x00000008);
+		PCMD_NOP();
+		PCMD_SMU_READY_WAIT(PMU_HIGH_LEVEL);
+		/* PWRDWN-10 */
+		PCMD_REG_WRITE(ASMU_MACRO, SMU_CMD_PLL3CTRL1, 0x000000ff);
+		/* PWRDWN-11 */
+		PCMD_REG_WRITE(ASMU_MACRO, SMU_CMD_PLL1CTRL1, 0x000000ff);
+		/* PWRDWN-12 */
+		PCMD_TRIG_WAIT(1, PMU_TRIG_INT);
+		/* PWRDWN-13 */
+		PCMD_WDT_RESTART();
+		/* PWRDWN-14 */
+		PCMD_NOP();
+		PCMD_SMU_READY_WAIT(PMU_HIGH_LEVEL);
+		/* PWRDWN-15 */
+		PCMD_REG_WRITE(ASMU_MACRO, SMU_CMD_AUTO_MODE_EN, 0x00000000);
+#ifdef	CONFIG_MP200_EM1_DKIT
+#else
+		/* PWRDWN-16 */
+		PCMD_SUBROUTINE_START(PMU_PC_SPI_ENABLE);
+		PCMD_REG_WRITE(SPI0_MACRO, SPI_CMD_SPx_TX_DATA, 0x00009200);
+		PCMD_SP0_WRITE(SPI_CMD_SPx_CONTROL, 0x00000009);
+		PCMD_REG_WRITE(SPI0_MACRO, SPI_CMD_SPx_FFCLR, 0x000000ff);
+		PCMD_SUBROUTINE_START(PMU_PC_SPI_DISABLE);
+#endif
+		/* PWRDWN-17 */
+		PCMD_AJUMP(PMU_PC_POWER_ON_SEQUENCE);
+	}
+
+	pmu_cmd_adr = PMU_PC_TO_VIRADDR(PMU_PC_POWEROFF);
+	/***************************/
+	/******** POWEROFF *********/
+	/***************************/
+	if ((sleep_flag & MP200_PMU_CLK_MASK) == MP200_PMU_CLK_POWEROFF) {
+		/* PWOFF-1 */
+		PCMD_SUBROUTINE_START(PMU_PC_SPI_ENABLE);
+#ifdef	CONFIG_MP200_EM1_DKIT
+#ifdef	DEBUG_LED
+		/* LED1 ON (R28 <- 0xa2) */
+		PCMD_REG_WRITE(SPI0_MACRO, SPI_CMD_SPx_TX_DATA, 0x000038a2);
+		PCMD_SP0_WRITE(SPI_CMD_SPx_CONTROL, 0x00000009);
+		PCMD_REG_WRITE(SPI0_MACRO, SPI_CMD_SPx_FFCLR, 0x000000ff);
+#endif
+		/* PWOFF-D9052-1 (R44 <- 0x88) */
+		PCMD_REG_WRITE(SPI0_MACRO, SPI_CMD_SPx_TX_DATA, 0x00005888);
+		PCMD_SP0_WRITE(SPI_CMD_SPx_CONTROL, 0x00000009);
+		PCMD_REG_WRITE(SPI0_MACRO, SPI_CMD_SPx_FFCLR, 0x000000ff);
+		/* PWOFF-D9052-2 (R45 <- 0x88) */
+		PCMD_REG_WRITE(SPI0_MACRO, SPI_CMD_SPx_TX_DATA, 0x00005a88);
+		PCMD_SP0_WRITE(SPI_CMD_SPx_CONTROL, 0x00000009);
+		PCMD_REG_WRITE(SPI0_MACRO, SPI_CMD_SPx_FFCLR, 0x000000ff);
+		/* PWOFF-D9052-3 (R43 <- 0xc5) */
+		PCMD_REG_WRITE(SPI0_MACRO, SPI_CMD_SPx_TX_DATA, 0x000056c5);
+		PCMD_SP0_WRITE(SPI_CMD_SPx_CONTROL, 0x00000009);
+		PCMD_REG_WRITE(SPI0_MACRO, SPI_CMD_SPx_FFCLR, 0x000000ff);
+		/* PWOFF-D9052-4 (R15 <- 0x6c) */
+		PCMD_REG_WRITE(SPI0_MACRO, SPI_CMD_SPx_TX_DATA, 0x00001e6c);
+		PCMD_SP0_WRITE(SPI_CMD_SPx_CONTROL, 0x00000009);
+		PCMD_REG_WRITE(SPI0_MACRO, SPI_CMD_SPx_FFCLR, 0x000000ff);
+#ifdef	DEBUG_LED
+		/* LED1 ON (R28 <- 0x22) */
+		PCMD_REG_WRITE(SPI0_MACRO, SPI_CMD_SPx_TX_DATA, 0x00003822);
+		PCMD_SP0_WRITE(SPI_CMD_SPx_CONTROL, 0x00000009);
+		PCMD_REG_WRITE(SPI0_MACRO, SPI_CMD_SPx_FFCLR, 0x000000ff);
+#endif
+#else
+		PCMD_REG_WRITE(SPI0_MACRO, SPI_CMD_SPx_TX_DATA, 0x0000021c);
+		PCMD_SP0_WRITE(SPI_CMD_SPx_CONTROL, 0x00000009);
+		PCMD_REG_WRITE(SPI0_MACRO, SPI_CMD_SPx_FFCLR, 0x000000ff);
+#endif
+		PCMD_SUBROUTINE_START(PMU_PC_SPI_DISABLE);
+		/* PWOFF-2 */
+		PCMD_INTWAIT();
+	}
+
+	pmu_cmd_adr = PMU_PC_TO_VIRADDR(PMU_PC_POWER_ON_SEQUENCE);
+	/***************************/
+	/**** Power On Sequence ****/
+	/***************************/
+	/* PWRON-1 */
+	PCMD_REG_WRITE(ASMU_MACRO, SMU_CMD_CLK_MODE_SEL, 0x00000005);
+	PCMD_NOP();
+	PCMD_SMU_READY_WAIT(PMU_HIGH_LEVEL);
+	/* PWRON-2 */
+	PCMD_NOP();
+	PCMD_NOP();
+	PCMD_NOP();
+
+	/* PWRON-3*/
+	PCMD_SUBROUTINE_START(PMU_PC_L2POWERON);
+	PCMD_SUBROUTINE_START(PMU_PC_L1POWERON);
+
+	/* PWRON-4 */
+	PCMD_REG_WRITE(ASMU_MACRO, SMU_CMD_RESETREQ0ENA, 0xbffeef3f);
+	PCMD_REG_WRITE(ASMU_MACRO, SMU_CMD_RESETREQ1ENA, 0x7feb3fff);
+	PCMD_REG_WRITE(ASMU_MACRO, SMU_CMD_RESETREQ2ENA, 0x0000167f);
+	PCMD_REG_WRITE(ASMU_MACRO, SMU_CMD_RESETREQ3ENA, 0x0000001c);
+
+	/* PWRON-5 */
+	PCMD_REG_WRITE(ASMU_MACRO, SMU_CMD_MEMC_HAND_SHAKE_FAKE, 0x00000000);
+	PCMD_REG_WRITE(CHG_MACRO, CHG_CMD_CHG_L1_HOLD, 0x00000001);
+	PCMD_CYCLE_WAIT(0x2b0, PMU_WAIT_INT_CONTINUE);
+	PCMD_NOP();
+	PCMD_NOP();
+	PCMD_NOP();
+
+	/* PWRON-6 */
+	tmp_pc = PMU_VIRADDR_TO_PC((unsigned int)pmu_cmd_adr);
+	PCMD_REG_READ(ASMU_MACRO, SMU_CMD_POWERSW_STATUS, PMU_REGA);
+	PCMD_AND(0x00000001, PMU_REGA);
+	PCMD_CMP2(0x00000001, PMU_REGA);
+	PCMD_BRANCH(tmp_pc, PMU_BNE);
+	/* PWRON-7 */
+	PCMD_REG_WRITE(ASMU_MACRO, SMU_CMD_GCLKCTRL0ENA, 0x760ffce3);
+	PCMD_REG_WRITE(ASMU_MACRO, SMU_CMD_GCLKCTRL0, 0x760ffce3);
+	PCMD_REG_WRITE(ASMU_MACRO, SMU_CMD_GCLKCTRL0ENA, 0x00000000);
+	PCMD_REG_WRITE(ASMU_MACRO, SMU_CMD_GCLKCTRL1ENA, 0xffffdff7);
+	PCMD_REG_WRITE(ASMU_MACRO, SMU_CMD_GCLKCTRL1, 0xffffdff7);
+	PCMD_REG_WRITE(ASMU_MACRO, SMU_CMD_GCLKCTRL1ENA, 0x00000000);
+	PCMD_REG_WRITE(ASMU_MACRO, SMU_CMD_GCLKCTRL2ENA, 0x67ff79fe);
+	PCMD_REG_WRITE(ASMU_MACRO, SMU_CMD_GCLKCTRL2, 0x67ff79fe);
+	PCMD_REG_WRITE(ASMU_MACRO, SMU_CMD_GCLKCTRL2ENA, 0x00000000);
+	PCMD_REG_WRITE(ASMU_MACRO, SMU_CMD_GCLKCTRL3ENA, 0xfff87fff);
+	PCMD_REG_WRITE(ASMU_MACRO, SMU_CMD_GCLKCTRL3, 0xfff87fff);
+	PCMD_REG_WRITE(ASMU_MACRO, SMU_CMD_GCLKCTRL3ENA, 0x00000000);
+	PCMD_REG_WRITE(ASMU_MACRO, SMU_CMD_GCLKCTRL4ENA, 0x000003e0);
+	PCMD_REG_WRITE(ASMU_MACRO, SMU_CMD_GCLKCTRL4, 0x000003e0);
+	PCMD_REG_WRITE(ASMU_MACRO, SMU_CMD_GCLKCTRL4ENA, 0x00000000);
+	/* PWRON-8 */
+	PCMD_REG_WRITE(ASMU_MACRO, SMU_CMD_RESETREQ0, reg_state.smu.resetreq0);
+	PCMD_REG_WRITE(ASMU_MACRO, SMU_CMD_RESETREQ1, reg_state.smu.resetreq1);
+	PCMD_REG_WRITE(ASMU_MACRO, SMU_CMD_RESETREQ2, reg_state.smu.resetreq2);
+	PCMD_REG_WRITE(ASMU_MACRO, SMU_CMD_RESETREQ3, reg_state.smu.resetreq3);
+	PCMD_REG_WRITE(ASMU_MACRO, SMU_CMD_RESETREQ0ENA, 0x00000000);
+	PCMD_REG_WRITE(ASMU_MACRO, SMU_CMD_RESETREQ1ENA, 0x00000000);
+	PCMD_REG_WRITE(ASMU_MACRO, SMU_CMD_RESETREQ2ENA, 0x00000000);
+	PCMD_REG_WRITE(ASMU_MACRO, SMU_CMD_RESETREQ3ENA, 0x00000000);
+	/* PWRON-9 */
+	PCMD_SUBROUTINE_START(PMU_PC_MEMC2);
+	PCMD_REG_WRITE(MEMC_MACRO, MEMC_CMD_DDR_CONFIGC2, 0x0000009b);
+	PCMD_NOP();
+	PCMD_NOP();
+	PCMD_NOP();
+	PCMD_REG_WRITE(ASMU_MACRO, SMU_CMD_IO_L0_LM_BUZ, 0x00000101);
+	/* PWRON-11 */
+	PCMD_REG_WRITE(ASMU_MACRO, SMU_CMD_CLK_MODE_SEL, 0x00000001);
+	PCMD_NOP();
+	if ((sleep_flag & MP200_PMU_CLK_MASK) == MP200_PMU_CLK_POWERDOWN)
+		PCMD_SMU_READY_WAIT(PMU_HIGH_LEVEL)
+	else
+		PCMD_NOP()
+
+	/* PWRON-12 */
+	PCMD_AJUMP(PMU_PC_POWER_ON_PC);
+
+	pmu_cmd_adr = PMU_PC_TO_VIRADDR(PMU_PC_POWER_ON_PC);
+	/***************************/
+	/******* Power On PC *******/
+	/***************************/
+	/* PWRON_PC-1 */
+	PCMD_REG_READ(ASMU_MACRO, SMU_CMD_QR_ENA, PMU_REGA);
+	PCMD_AND(0x00000100, PMU_REGA);
+	PCMD_CMP2(0x00000100, PMU_REGA);
+	tmp_pc = PMU_VIRADDR_TO_PC((unsigned int)pmu_cmd_adr);
+	PCMD_BRANCH((tmp_pc + 0x10), PMU_BNE);
+	PCMD_RWM(ASMU_MACRO, SMU_CMD_QR_ENA, 0x00000002, 0x00000002);
+	/* PWRON_PC-2 */
+	PCMD_ARMINT_MASK(PMU_INT_UNMASK);
+	/* PWRON_PC-3 */
+	PCMD_QR_WAIT(PMU_QR_WAIT_RESTORE);
+	/* PWRON_PC-4 */
+	PCMD_RWM(ASMU_MACRO, SMU_CMD_QR_ENA, 0x00000100, 0x00000100);
+
+	PCMD_PMU_END();
+
+	pmu_cmd_adr = PMU_PC_TO_VIRADDR(PMU_PC_SPI_ENABLE);
+	/***************************/
+	/******** SPI Enable *******/
+	/***************************/
+	/* SPIEN-1 */
+	PCMD_REG_WRITE(ASMU_MACRO, SMU_CMD_GCLKCTRL3ENA, 0x00600000);
+	PCMD_REG_WRITE(ASMU_MACRO, SMU_CMD_GCLKCTRL3, 0x00600000);
+	PCMD_REG_WRITE(ASMU_MACRO, SMU_CMD_GCLKCTRL3ENA, 0x00000000);
+	PCMD_REG_WRITE(SPI0_MACRO, SPI_CMD_SPx_FFCLR, 0x000000ff);
+	PCMD_REG_WRITE(SPI0_MACRO, SPI_CMD_SPx_ENSET, 0x000000ff);
+	PCMD_REG_WRITE(SPI0_MACRO, SPI_CMD_SPx_MODE, 0x00000f00);
+	PCMD_REG_WRITE(SPI0_MACRO, SPI_CMD_SPx_POL, SPI_POL_SP0_CS0);
+	PCMD_REG_WRITE(ASMU_MACRO, SMU_CMD_DIVSP0SCLK, 0x00000190);
+	PCMD_RFS();
+
+	pmu_cmd_adr = PMU_PC_TO_VIRADDR(PMU_PC_SPI_DISABLE);
+	/***************************/
+	/******** SPI Disable ******/
+	/***************************/
+	/* SPIDIS-1 */
+	PCMD_REG_WRITE(ASMU_MACRO, SMU_CMD_GCLKCTRL3ENA, 0x00600000);
+	PCMD_REG_WRITE(ASMU_MACRO, SMU_CMD_GCLKCTRL3, 0x00000000);
+	PCMD_REG_WRITE(ASMU_MACRO, SMU_CMD_GCLKCTRL3ENA, 0x00000000);
+	PCMD_RFS();
+
+	pmu_cmd_adr = PMU_PC_TO_VIRADDR(PMU_PC_L2POWEROFF);
+	/******************************/
+	/******** L2OFF_Sequence ******/
+	/******************************/
+#ifndef L2_DISABLE
+	/* L2OFF-1 */
+	PCMD_REG_WRITE(ASMU_MACRO, SMU_CMD_LOG2SW_ACTRLEN, 0x00000100);
+	PCMD_REG_WRITE(ASMU_MACRO, SMU_CMD_L2_POWERSW, 0x00000000);
+	PCMD_REG_WRITE(ASMU_MACRO, SMU_CMD_L2_POWERSW, 0x000000FF);
+#endif
+	PCMD_RFS();
+
+	pmu_cmd_adr = PMU_PC_TO_VIRADDR(PMU_PC_L2POWERON);
+	/******************************/
+	/******** L2ON_Sequence *******/
+	/******************************/
+#ifndef L2_DISABLE
+	/* L2ON-1 */
+	PCMD_REG_WRITE(ASMU_MACRO, SMU_CMD_L2_POWERSW, 0x0000007F);
+	PCMD_CYCLE_WAIT(0x0010, PMU_WAIT_INT_CONTINUE);
+	PCMD_REG_WRITE(ASMU_MACRO, SMU_CMD_L2_POWERSW, 0x0000003F);
+	PCMD_CYCLE_WAIT(0x0010, PMU_WAIT_INT_CONTINUE);
+	PCMD_REG_WRITE(ASMU_MACRO, SMU_CMD_L2_POWERSW, 0x0000001F);
+	PCMD_CYCLE_WAIT(0x0010, PMU_WAIT_INT_CONTINUE);
+	PCMD_REG_WRITE(ASMU_MACRO, SMU_CMD_L2_POWERSW, 0x0000000F);
+	PCMD_CYCLE_WAIT(0x0010, PMU_WAIT_INT_CONTINUE);
+	PCMD_REG_WRITE(ASMU_MACRO, SMU_CMD_L2_POWERSW, 0x00000007);
+	PCMD_CYCLE_WAIT(0x0010, PMU_WAIT_INT_CONTINUE);
+	PCMD_REG_WRITE(ASMU_MACRO, SMU_CMD_L2_POWERSW, 0x00000003);
+	PCMD_CYCLE_WAIT(0x0010, PMU_WAIT_INT_CONTINUE);
+	PCMD_REG_WRITE(ASMU_MACRO, SMU_CMD_L2_POWERSW, 0x00000001);
+	PCMD_CYCLE_WAIT(0x0010, PMU_WAIT_INT_CONTINUE);
+	PCMD_REG_WRITE(ASMU_MACRO, SMU_CMD_L2_POWERSW, 0x00000000);
+	PCMD_CYCLE_WAIT(0x0010, PMU_WAIT_INT_CONTINUE);
+	PCMD_REG_WRITE(ASMU_MACRO, SMU_CMD_L2_POWERSW, 0x00010100);
+	PCMD_REG_WRITE(ASMU_MACRO, SMU_CMD_LOG2SW_ACTRLEN, 0x00000000);
+#endif
+	PCMD_RFS();
+
+	pmu_cmd_adr = PMU_PC_TO_VIRADDR(PMU_PC_MEMC1);
+	/*******************************/
+	/******** MEMC1_Sequence *******/
+	/*******************************/
+	/* MEMC1_SEQ1 */
+	PCMD_REG_READ(MEMC_MACRO, MEMC_CMD_CACHE_MODE, PMU_REGB);
+	PCMD_REG_WRITE2(PMU_MACRO, (PMU_PC_USE_MEMC + 0x0000), PMU_REGB);
+	PCMD_REG_READ(MEMC_MACRO, MEMC_CMD_DEGFUN, PMU_REGB);
+	PCMD_REG_WRITE2(PMU_MACRO, (PMU_PC_USE_MEMC + 0x0004), PMU_REGB);
+	PCMD_REG_READ(MEMC_MACRO, MEMC_CMD_REQSCH, PMU_REGB);
+	PCMD_REG_WRITE2(PMU_MACRO, (PMU_PC_USE_MEMC + 0x000c), PMU_REGB);
+	PCMD_REG_READ(MEMC_MACRO, MEMC_CMD_DDR_CONFIGF, PMU_REGB);
+	PCMD_REG_WRITE2(PMU_MACRO, (PMU_PC_USE_MEMC + 0x0010), PMU_REGB);
+	PCMD_REG_READ(MEMC_MACRO, MEMC_CMD_DDR_CONFIGA1, PMU_REGB);
+	PCMD_REG_WRITE2(PMU_MACRO, (PMU_PC_USE_MEMC + 0x0014), PMU_REGB);
+	PCMD_REG_READ(MEMC_MACRO, MEMC_CMD_DDR_CONFIGA2, PMU_REGB);
+	PCMD_REG_WRITE2(PMU_MACRO, (PMU_PC_USE_MEMC + 0x0018), PMU_REGB);
+	PCMD_REG_READ(MEMC_MACRO, MEMC_CMD_DDR_CONFIGR1, PMU_REGB);
+	PCMD_REG_WRITE2(PMU_MACRO, (PMU_PC_USE_MEMC + 0x001c), PMU_REGB);
+	PCMD_REG_READ(MEMC_MACRO, MEMC_CMD_DDR_CONFIGR2, PMU_REGB);
+	PCMD_REG_WRITE2(PMU_MACRO, (PMU_PC_USE_MEMC + 0x0020), PMU_REGB);
+	PCMD_REG_READ(MEMC_MACRO, MEMC_CMD_DDR_CONFIGR3, PMU_REGB);
+	PCMD_REG_WRITE2(PMU_MACRO, (PMU_PC_USE_MEMC + 0x0024), PMU_REGB);
+	PCMD_REG_READ(MEMC_MACRO, MEMC_CMD_DDR_CONFIGT1, PMU_REGB);
+	PCMD_REG_WRITE2(PMU_MACRO, (PMU_PC_USE_MEMC + 0x0028), PMU_REGB);
+	PCMD_REG_READ(MEMC_MACRO, MEMC_CMD_DDR_CONFIGT2, PMU_REGB);
+	PCMD_REG_WRITE2(PMU_MACRO, (PMU_PC_USE_MEMC + 0x002c), PMU_REGB);
+	PCMD_REG_READ(MEMC_MACRO, MEMC_CMD_DDR_CONFIGC1, PMU_REGB);
+	PCMD_REG_WRITE2(PMU_MACRO, (PMU_PC_USE_MEMC + 0x0030), PMU_REGB);
+	PCMD_RFS();
+
+	pmu_cmd_adr = PMU_PC_TO_VIRADDR(PMU_PC_MEMC2);
+	/*******************************/
+	/******** MEMC2_Sequence *******/
+	/*******************************/
+	/* MEMC2_SEQ1 */
+	PCMD_REG_READ(PMU_MACRO, (PMU_PC_USE_MEMC + 0x0000), PMU_REGB);
+	PCMD_REG_WRITE2(MEMC_MACRO, MEMC_CMD_CACHE_MODE, PMU_REGB);
+	PCMD_REG_READ(PMU_MACRO, (PMU_PC_USE_MEMC + 0x0004), PMU_REGB);
+	PCMD_REG_WRITE2(MEMC_MACRO, MEMC_CMD_DEGFUN, PMU_REGB);
+	PCMD_REG_READ(PMU_MACRO, (PMU_PC_USE_MEMC + 0x000c), PMU_REGB);
+	PCMD_REG_WRITE2(MEMC_MACRO, MEMC_CMD_REQSCH, PMU_REGB);
+	PCMD_REG_READ(PMU_MACRO, (PMU_PC_USE_MEMC + 0x0010), PMU_REGB);
+	PCMD_REG_WRITE2(MEMC_MACRO, MEMC_CMD_DDR_CONFIGF, PMU_REGB);
+	PCMD_REG_READ(PMU_MACRO, (PMU_PC_USE_MEMC + 0x0014), PMU_REGB);
+	PCMD_REG_WRITE2(MEMC_MACRO, MEMC_CMD_DDR_CONFIGA1, PMU_REGB);
+	PCMD_REG_READ(PMU_MACRO, (PMU_PC_USE_MEMC + 0x0018), PMU_REGB);
+	PCMD_REG_WRITE2(MEMC_MACRO, MEMC_CMD_DDR_CONFIGA2, PMU_REGB);
+	PCMD_REG_READ(PMU_MACRO, (PMU_PC_USE_MEMC + 0x001c), PMU_REGB);
+	PCMD_REG_WRITE2(MEMC_MACRO, MEMC_CMD_DDR_CONFIGR1, PMU_REGB);
+	PCMD_REG_READ(PMU_MACRO, (PMU_PC_USE_MEMC + 0x0020), PMU_REGB);
+	PCMD_REG_WRITE2(MEMC_MACRO, MEMC_CMD_DDR_CONFIGR2, PMU_REGB);
+	PCMD_REG_READ(PMU_MACRO, (PMU_PC_USE_MEMC + 0x0024), PMU_REGB);
+	PCMD_REG_WRITE2(MEMC_MACRO, MEMC_CMD_DDR_CONFIGR3, PMU_REGB);
+	PCMD_REG_READ(PMU_MACRO, (PMU_PC_USE_MEMC + 0x0028), PMU_REGB);
+	PCMD_REG_WRITE2(MEMC_MACRO, MEMC_CMD_DDR_CONFIGT1, PMU_REGB);
+	PCMD_REG_READ(PMU_MACRO, (PMU_PC_USE_MEMC + 0x002c), PMU_REGB);
+	PCMD_REG_WRITE2(MEMC_MACRO, MEMC_CMD_DDR_CONFIGT2, PMU_REGB);
+	PCMD_REG_READ(PMU_MACRO, (PMU_PC_USE_MEMC + 0x0030), PMU_REGB);
+	PCMD_REG_WRITE2(MEMC_MACRO, MEMC_CMD_DDR_CONFIGC1, PMU_REGB);
+	PCMD_RFS();
+
+	pmu_cmd_adr = PMU_PC_TO_VIRADDR(PMU_PC_L1POWEROFF);
+	/***********************************/
+	/******** PMU_PC_L1POWEROFF ********/
+	/***********************************/
+	/* L1OFF-1 */
+#ifdef L1_AUTO_ENABLE
+	PCMD_RWM(ASMU_MACRO, SMU_CMD_POWERSW_ACTRL_EN, 0x00000002, 0x00000002);
+	PCMD_REG_WRITE(ASMU_MACRO, SMU_CMD_LOG1SW_ACTRL, 0x00000000);
+#else
+	PCMD_REG_WRITE(ASMU_MACRO, SMU_CMD_L1_BUZ, 0x00000000);
+	PCMD_REG_WRITE(ASMU_MACRO, SMU_CMD_L1_BUZ2, 0x00000000);
+	PCMD_REG_WRITE(ASMU_MACRO, SMU_CMD_L1_POWERSW, 0x00000F0F);
+#endif
+	PCMD_RFS();
+
+	pmu_cmd_adr = PMU_PC_TO_VIRADDR(PMU_PC_L1POWERON);
+	/***********************************/
+	/******** PMU_PC_L1POWERON *********/
+	/***********************************/
+	/* L1ON-1 */
+#ifdef L1_AUTO_ENABLE
+	PCMD_REG_WRITE(ASMU_MACRO, SMU_CMD_LOG1SW_ACTRL, 0x00005301);
+	PCMD_RWM(ASMU_MACRO, SMU_CMD_POWERSW_ACTRL_EN, 0x00000000, 0x00000002);
+#else
+	PCMD_REG_WRITE(ASMU_MACRO, SMU_CMD_L1_POWERSW, 0x00000F07);
+	PCMD_CYCLE_WAIT(0x0050, PMU_WAIT_INT_CONTINUE);
+	PCMD_REG_WRITE(ASMU_MACRO, SMU_CMD_L1_POWERSW, 0x00000F03);
+	PCMD_CYCLE_WAIT(0x0050, PMU_WAIT_INT_CONTINUE);
+	PCMD_REG_WRITE(ASMU_MACRO, SMU_CMD_L1_POWERSW, 0x00000F01);
+	PCMD_CYCLE_WAIT(0x0050, PMU_WAIT_INT_CONTINUE);
+	PCMD_REG_WRITE(ASMU_MACRO, SMU_CMD_L1_POWERSW, 0x00000F00);
+	PCMD_CYCLE_WAIT(0x0050, PMU_WAIT_INT_CONTINUE);
+	PCMD_REG_WRITE(ASMU_MACRO, SMU_CMD_L1_POWERSW, 0x00000700);
+	PCMD_CYCLE_WAIT(0x0050, PMU_WAIT_INT_CONTINUE);
+	PCMD_REG_WRITE(ASMU_MACRO, SMU_CMD_L1_POWERSW, 0x00000300);
+	PCMD_CYCLE_WAIT(0x0050, PMU_WAIT_INT_CONTINUE);
+	PCMD_REG_WRITE(ASMU_MACRO, SMU_CMD_L1_POWERSW, 0x00000100);
+	PCMD_CYCLE_WAIT(0x0050, PMU_WAIT_INT_CONTINUE);
+	PCMD_REG_WRITE(ASMU_MACRO, SMU_CMD_L1_POWERSW, 0x00000000);
+	PCMD_CYCLE_WAIT(0x0050, PMU_WAIT_INT_CONTINUE);
+	PCMD_REG_WRITE(ASMU_MACRO, SMU_CMD_ASMU_BGCTRL, 0x01000000);
+	PCMD_REG_WRITE(ASMU_MACRO, SMU_CMD_L1_BUZ, 0x00001111);
+	PCMD_REG_WRITE(ASMU_MACRO, SMU_CMD_L1_BUZ2, 0x00000011);
+	PCMD_REG_WRITE(ASMU_MACRO, SMU_CMD_ASMU_BGCTRL, 0x00000000);
+#endif
+	PCMD_RFS();
+
+	pmu_cmd_adr = PMU_PC_TO_VIRADDR(PMU_PC_MEMC_DEEP_POWERDOWN);
+	/**************************************/
+	/********* MEMC_DEEP_POWERDOWN ********/
+	/**************************************/
+	if ((sleep_flag & MP200_PMU_CLK_MASK) == MP200_PMU_CLK_POWEROFF) {
+		/* MEMC DPD-0 auto power down:disable*/
+		PCMD_RWM(MEMC_MACRO, MEMC_CMD_DDR_CONFIGR3, 0x0000, 0x0101);
+		PCMD_NOP();
+		PCMD_NOP();
+		PCMD_NOP();
+
+		/* MEMC_DPD-1 Auto-SREF,Auto-CBR:disable*/
+		PCMD_RWM(MEMC_MACRO, MEMC_CMD_DDR_CONFIGR2, 0x0000, 0x0303);
+		PCMD_NOP();
+		PCMD_NOP();
+		PCMD_NOP();
+
+		/*CMD CLEAR*/
+		/* ready */
+		tmp_pc = PMU_VIRADDR_TO_PC((unsigned int)pmu_cmd_adr);
+		PCMD_REG_READ(MEMC_MACRO, MEMC_CMD_DDR_CONFIGC2, PMU_REGB);
+		PCMD_AND(0x00000300, PMU_REGB);
+		PCMD_CMP2(0x00000300, PMU_REGB);
+		PCMD_BRANCH(tmp_pc, PMU_BNE);
+		/* write */
+		PCMD_REG_WRITE(MEMC_MACRO, MEMC_CMD_DDR_CONFIGC2, 0x000000c0);
+		PCMD_NOP();
+		PCMD_NOP();
+		PCMD_NOP();
+		/* read */
+		tmp_pc = PMU_VIRADDR_TO_PC((unsigned int)pmu_cmd_adr);
+		PCMD_REG_READ(MEMC_MACRO, MEMC_CMD_DDR_CONFIGC2, PMU_REGB);
+		PCMD_AND(0x0000000f, PMU_REGB);
+		PCMD_CMP2(0x00000000, PMU_REGB);
+		PCMD_BRANCH(tmp_pc, PMU_BNE);
+
+
+		/* MEMC_DPD-2 all bank precharge*/
+		PCMD_RWM(MEMC_MACRO, MEMC_CMD_DDR_CONFIGC1, 0x0400, 0x0400);
+		/* ready */
+		tmp_pc = PMU_VIRADDR_TO_PC((unsigned int)pmu_cmd_adr);
+		PCMD_REG_READ(MEMC_MACRO, MEMC_CMD_DDR_CONFIGC2, PMU_REGB);
+		PCMD_AND(0x00000300, PMU_REGB);
+		PCMD_CMP2(0x00000300, PMU_REGB);
+		PCMD_BRANCH(tmp_pc, PMU_BNE);
+		/* write */
+		tmp_pc = PMU_VIRADDR_TO_PC((unsigned int)pmu_cmd_adr);
+		PCMD_REG_WRITE(MEMC_MACRO, MEMC_CMD_DDR_CONFIGC2, 0x00000099);
+		PCMD_NOP();
+		PCMD_NOP();
+		PCMD_NOP();
+		/* read */
+		PCMD_REG_READ(MEMC_MACRO, MEMC_CMD_DDR_CONFIGC2, PMU_REGB);
+		PCMD_AND(0x0000000f, PMU_REGB);
+		PCMD_CMP2(0x00000009, PMU_REGB);
+		PCMD_BRANCH(tmp_pc, PMU_BNE);
+
+		/*CMD CLEAR*/
+		/* ready */
+		tmp_pc = PMU_VIRADDR_TO_PC((unsigned int)pmu_cmd_adr);
+		PCMD_REG_READ(MEMC_MACRO, MEMC_CMD_DDR_CONFIGC2, PMU_REGB);
+		PCMD_AND(0x00000300, PMU_REGB);
+		PCMD_CMP2(0x00000300, PMU_REGB);
+		PCMD_BRANCH(tmp_pc, PMU_BNE);
+		/* write */
+		PCMD_REG_WRITE(MEMC_MACRO, MEMC_CMD_DDR_CONFIGC2, 0x000000c0);
+		PCMD_NOP();
+		PCMD_NOP();
+		PCMD_NOP();
+		/* read */
+		tmp_pc = PMU_VIRADDR_TO_PC((unsigned int)pmu_cmd_adr);
+		PCMD_REG_READ(MEMC_MACRO, MEMC_CMD_DDR_CONFIGC2, PMU_REGB);
+		PCMD_AND(0x0000000f, PMU_REGB);
+		PCMD_CMP2(0x00000000, PMU_REGB);
+		PCMD_BRANCH(tmp_pc, PMU_BNE);
+
+		/* MEMC_DPD-3 CKE*/
+		tmp_pc = PMU_VIRADDR_TO_PC((unsigned int)pmu_cmd_adr);
+		/* ready */
+		PCMD_REG_READ(MEMC_MACRO, MEMC_CMD_DDR_CONFIGC2, PMU_REGB);
+		PCMD_AND(0x00000300, PMU_REGB);
+		PCMD_CMP2(0x00000300, PMU_REGB);
+		PCMD_BRANCH(tmp_pc, PMU_BNE);
+		/* write */
+		tmp_pc = PMU_VIRADDR_TO_PC((unsigned int)pmu_cmd_adr);
+		PCMD_REG_WRITE(MEMC_MACRO, MEMC_CMD_DDR_CONFIGC2, 0x0000009d);
+		PCMD_NOP();
+		PCMD_NOP();
+		PCMD_NOP();
+		/* read */
+		PCMD_REG_READ(MEMC_MACRO, MEMC_CMD_DDR_CONFIGC2, PMU_REGB);
+		PCMD_AND(0x0000000f, PMU_REGB);
+		PCMD_CMP2(0x0000000d, PMU_REGB);
+		PCMD_BRANCH(tmp_pc, PMU_BNE);
+
+		/*CMD CLEAR*/
+		/* ready */
+		tmp_pc = PMU_VIRADDR_TO_PC((unsigned int)pmu_cmd_adr);
+		PCMD_REG_READ(MEMC_MACRO, MEMC_CMD_DDR_CONFIGC2, PMU_REGB);
+		PCMD_AND(0x00000300, PMU_REGB);
+		PCMD_CMP2(0x00000300, PMU_REGB);
+		PCMD_BRANCH(tmp_pc, PMU_BNE);
+		/* write */
+		PCMD_REG_WRITE(MEMC_MACRO, MEMC_CMD_DDR_CONFIGC2, 0x000000c0);
+		PCMD_NOP();
+		PCMD_NOP();
+		PCMD_NOP();
+		/* read */
+		tmp_pc = PMU_VIRADDR_TO_PC((unsigned int)pmu_cmd_adr);
+		PCMD_REG_READ(MEMC_MACRO, MEMC_CMD_DDR_CONFIGC2, PMU_REGB);
+		PCMD_AND(0x0000000f, PMU_REGB);
+		PCMD_CMP2(0x00000000, PMU_REGB);
+		PCMD_BRANCH(tmp_pc, PMU_BNE);
+
+		/* MEMC_DPD-5 Deep Power Down */
+		tmp_pc = PMU_VIRADDR_TO_PC((unsigned int)pmu_cmd_adr);
+		/* ready */
+		PCMD_REG_READ(MEMC_MACRO, MEMC_CMD_DDR_CONFIGC2, PMU_REGB);
+		PCMD_AND(0x00000300, PMU_REGB);
+		PCMD_CMP2(0x00000300, PMU_REGB);
+		PCMD_BRANCH(tmp_pc, PMU_BNE);
+		/* write */
+		PCMD_REG_WRITE(MEMC_MACRO, MEMC_CMD_DDR_CONFIGC2, 0x0000009c);
+		PCMD_NOP();
+		PCMD_NOP();
+		PCMD_NOP();
+		/* read */
+		tmp_pc = PMU_VIRADDR_TO_PC((unsigned int)pmu_cmd_adr);
+		PCMD_REG_READ(MEMC_MACRO, MEMC_CMD_DDR_CONFIGC2, PMU_REGB);
+		PCMD_AND(0x0000000f, PMU_REGB);
+		PCMD_CMP2(0x0000000c, PMU_REGB);
+		PCMD_BRANCH(tmp_pc, PMU_BNE);
+		/* check state */
+		tmp_pc = PMU_VIRADDR_TO_PC((unsigned int)pmu_cmd_adr);
+		PCMD_REG_READ(MEMC_MACRO, MEMC_CMD_DDR_STATE8, PMU_REGB);
+		PCMD_AND(0x0000000f, PMU_REGB);
+		PCMD_CMP2(0x00000007, PMU_REGB);
+		PCMD_BRANCH(tmp_pc, PMU_BNE);
+
+		/*CMD CLEAR*/
+		/* ready */
+		tmp_pc = PMU_VIRADDR_TO_PC((unsigned int)pmu_cmd_adr);
+		PCMD_REG_READ(MEMC_MACRO, MEMC_CMD_DDR_CONFIGC2, PMU_REGB);
+		PCMD_AND(0x00000300, PMU_REGB);
+		PCMD_CMP2(0x00000300, PMU_REGB);
+		PCMD_BRANCH(tmp_pc, PMU_BNE);
+		/* write */
+		PCMD_REG_WRITE(MEMC_MACRO, MEMC_CMD_DDR_CONFIGC2, 0x000000c0);
+		PCMD_NOP();
+		PCMD_NOP();
+		PCMD_NOP();
+		/* read */
+		tmp_pc = PMU_VIRADDR_TO_PC((unsigned int)pmu_cmd_adr);
+		PCMD_REG_READ(MEMC_MACRO, MEMC_CMD_DDR_CONFIGC2, PMU_REGB);
+		PCMD_AND(0x0000000f, PMU_REGB);
+		PCMD_CMP2(0x00000000, PMU_REGB);
+		PCMD_BRANCH(tmp_pc, PMU_BNE);
+
+		PCMD_RFS();
+	}
+
+	return;
+}
+
+/*
+ * pmu_set_regs(unsigned int sleep_flag)
+ *
+ */
+static void pmu_set_regs(unsigned int sleep_flag)
+{
+	unsigned int regval;
+
+	/* pmu command sequence set */
+	pmu_set_command_sequence(sleep_flag);
+
+	/* pmu_pc and pmu_wdt set */
+	outl(PMU_PC_MAIN, PMU_PC);
+
+	/* This doesn't use */
+	outl(PMU_PC_POWER_ON_SEQUENCE, PMU_POWER_ON_PC);
+
+	outl(PMU_WDT_ENABLE, PMU_WDT_COUNT_EN);
+	outl(PMU_WDT_MAX_COUNT, PMU_WDT_COUNT_LMT);
+
+	/* pmu start */
+	outl(PMU_START_SET, PMU_START);
+	do {
+		regval = inl(PMU_START);
+	} while ((regval & PMU_START_SET) != PMU_START_SET);
+
+	DPRINTK("PMU_PC           =0x%08x \n", inl(PMU_PC));
+	DPRINTK("PMU_POWER_ON_PC  =0x%08x \n", inl(PMU_POWER_ON_PC));
+	DPRINTK("PMU_WDT_COUNT_EN =0x%08x \n", inl(PMU_WDT_COUNT_EN));
+	DPRINTK("PMU_WDT_COUNT_LMT=0x%08x \n", inl(PMU_WDT_COUNT_LMT));
+	DPRINTK("PMU_START        =0x%08x \n", inl(PMU_START));
+}
+
+static void pmu_save_state(void)
+{
+	/* SMU state save */
+	reg_state.smu.resetreq0   = inl(SMU_RESETREQ0);
+	reg_state.smu.resetreq1   = inl(SMU_RESETREQ1);
+	reg_state.smu.resetreq2   = inl(SMU_RESETREQ2);
+	reg_state.smu.resetreq3   = inl(SMU_RESETREQ3);
+	reg_state.smu.clkctrl	   = inl(SMU_CLKCTRL);
+	reg_state.smu.clkctrl1	   = inl(SMU_CLKCTRL1);
+	reg_state.smu.gclkctrl0	   = inl(SMU_GCLKCTRL0);
+	reg_state.smu.gclkctrl1	   = inl(SMU_GCLKCTRL1);
+	reg_state.smu.gclkctrl2	   = inl(SMU_GCLKCTRL2);
+	reg_state.smu.gclkctrl3	   = inl(SMU_GCLKCTRL3);
+	reg_state.smu.gclkctrl4	   = inl(SMU_GCLKCTRL4);
+	reg_state.smu.auto_frq_change = inl(SMU_AUTO_FRQ_CHANGE);
+	reg_state.memc.configr2	   = inl(MEMC_DDR_CONFIGR2);
+
+	DPRINTK("SMU_AHBCLKCTRL0   =0x%08x\n", inl(SMU_AHBCLKCTRL0));
+	DPRINTK("SMU_AHBCLKCTRL1   =0x%08x\n", inl(SMU_AHBCLKCTRL1));
+	DPRINTK("SMU_APBCLKCTRL0   =0x%08x\n", inl(SMU_APBCLKCTRL0));
+	DPRINTK("SMU_APBCLKCTRL1   =0x%08x\n", inl(SMU_APBCLKCTRL1));
+	DPRINTK("SMU_RESETREQ0   =0x%08x\n", reg_state.smu.resetreq0);
+	DPRINTK("SMU_RESETREQ1   =0x%08x\n", reg_state.smu.resetreq1);
+	DPRINTK("SMU_RESETREQ2   =0x%08x\n", reg_state.smu.resetreq2);
+	DPRINTK("SMU_RESETREQ3   =0x%08x\n", reg_state.smu.resetreq3);
+	DPRINTK("SMU_CLKCTRL         =0x%08x\n", reg_state.smu.clkctrl);
+	DPRINTK("SMU_CLKCTRL1        =0x%08x\n", reg_state.smu.clkctrl1);
+	DPRINTK("SMU_GCLKCTRL0       =0x%08x\n", reg_state.smu.gclkctrl0);
+	DPRINTK("SMU_GCLKCTRL1       =0x%08x\n", reg_state.smu.gclkctrl1);
+	DPRINTK("SMU_GCLKCTRL2       =0x%08x\n", reg_state.smu.gclkctrl2);
+	DPRINTK("SMU_GCLKCTRL3       =0x%08x\n", reg_state.smu.gclkctrl3);
+	DPRINTK("SMU_GCLKCTRL4       =0x%08x\n", reg_state.smu.gclkctrl4);
+	DPRINTK("SMU_AUTO_FRQ_CHANGE =0x%08x\n",
+					reg_state.smu.auto_frq_change);
+	DPRINTK("MEMC_DDR_CONFIGR2 = 0x%08x\n", inl(MEMC_DDR_CONFIGR2));
+}
+
+static void pmu_restore_state(void)
+{
+	outl(reg_state.memc.configr2,		 MEMC_DDR_CONFIGR2);
+	outl(reg_state.smu.auto_frq_change,	 SMU_AUTO_FRQ_CHANGE);
+	outl(reg_state.smu.clkctrl,		 SMU_CLKCTRL);
+	outl(reg_state.smu.clkctrl1,		 SMU_CLKCTRL1);
+	outl(SMU_ENA_ALL,			 SMU_GCLKCTRL0ENA);
+	outl(reg_state.smu.gclkctrl0,		 SMU_GCLKCTRL0);
+	outl(SMU_ENA_CLEAR,			 SMU_GCLKCTRL0ENA);
+	outl(SMU_ENA_ALL,			 SMU_GCLKCTRL1ENA);
+	outl(reg_state.smu.gclkctrl1,		 SMU_GCLKCTRL1);
+	outl(SMU_ENA_CLEAR,			 SMU_GCLKCTRL1ENA);
+	outl(SMU_ENA_ALL,			 SMU_GCLKCTRL2ENA);
+	outl(reg_state.smu.gclkctrl2,		 SMU_GCLKCTRL2);
+	outl(SMU_ENA_CLEAR,			 SMU_GCLKCTRL2ENA);
+	outl(SMU_ENA_ALL,			 SMU_GCLKCTRL3ENA);
+	outl(reg_state.smu.gclkctrl3,		 SMU_GCLKCTRL3);
+	outl(SMU_ENA_CLEAR,			 SMU_GCLKCTRL3ENA);
+	outl(SMU_ENA_ALL,			 SMU_GCLKCTRL4ENA);
+	outl(reg_state.smu.gclkctrl4,		 SMU_GCLKCTRL4);
+	outl(SMU_ENA_CLEAR,			 SMU_GCLKCTRL4ENA);
+
+	DPRINTK("MEMC_DDR_CONFIGR2 = 0x%08x\n", inl(MEMC_DDR_CONFIGR2));
+	DPRINTK("SMU_AHBCLKCTRL0   =0x%08x\n", inl(SMU_AHBCLKCTRL0));
+	DPRINTK("SMU_AHBCLKCTRL1   =0x%08x\n", inl(SMU_AHBCLKCTRL1));
+	DPRINTK("SMU_APBCLKCTRL0   =0x%08x\n", inl(SMU_APBCLKCTRL0));
+	DPRINTK("SMU_APBCLKCTRL1   =0x%08x\n", inl(SMU_APBCLKCTRL1));
+	DPRINTK("SMU_RESETREQ0   =0x%08x\n", inl(SMU_RESETREQ0));
+	DPRINTK("SMU_RESETREQ1   =0x%08x\n", inl(SMU_RESETREQ1));
+	DPRINTK("SMU_RESETREQ2   =0x%08x\n", inl(SMU_RESETREQ2));
+	DPRINTK("SMU_RESETREQ3   =0x%08x\n", inl(SMU_RESETREQ3));
+	DPRINTK("SMU_CLKCTRL         =0x%08x\n", inl(SMU_CLKCTRL));
+	DPRINTK("SMU_CLKCTRL1         =0x%08x\n", inl(SMU_CLKCTRL1));
+	DPRINTK("SMU_GCLKCTRL0       =0x%08x\n", inl(SMU_GCLKCTRL0));
+	DPRINTK("SMU_GCLKCTRL1       =0x%08x\n", inl(SMU_GCLKCTRL1));
+	DPRINTK("SMU_GCLKCTRL2       =0x%08x\n", inl(SMU_GCLKCTRL2));
+	DPRINTK("SMU_GCLKCTRL3       =0x%08x\n", inl(SMU_GCLKCTRL3));
+	DPRINTK("SMU_GCLKCTRL4       =0x%08x\n", inl(SMU_GCLKCTRL4));
+	DPRINTK("SMU_AUTO_FRQ_CHANGE =0x%08x\n", inl(SMU_AUTO_FRQ_CHANGE));
+}
+
+/*
+ * Wait for Interrupt
+ *
+ */
+void mp200_cpu_do_idle(unsigned int pmu_boot)
+{
+	unsigned long val;
+
+	outl(0x00530101, SMU_QR_ENA); /* PMU BOOT */
+
+	val = (inl(SMU_POWERSW_ENA) & ~0x000fff00);
+	val |= 0x000fff00;
+	outl(val, SMU_POWERSW_ENA);
+
+	DPRINTK("SMU_QR_ENA =0x%08x\n", inl(SMU_QR_ENA));
+	/* WFI */
+	cpu_do_idle();
+
+	/* Clear PMU boot bit */
+	if (inl(PMU_START))
+		outl(0x00000000, PMU_START);
+
+	return;
+}
+
+/*
+ * Restore Async Bus Register.
+ * This function is copied onto RAM.
+ */
+static void restore_state_async_bus_func(void)
+{
+	outl(async_bus_state_cs0.base_addr, AB0_CS0BASEADD);
+	outl(async_bus_state_cs0.bitcomp, AB0_CS0BITCOMP);
+	outl(async_bus_state_cs0.waitctrl, AB0_CS0WAITCTRL);
+	outl(async_bus_state_cs0.waitctrl_w, AB0_CS0WAITCTRL_W);
+	outl(async_bus_state_cs0.readctrl, AB0_CS0READCTRL);
+	outl(async_bus_state_cs0.control, AB0_CS0CONTROL);
+
+	outl(async_bus_state_cs1.base_addr, AB0_CS1BASEADD);
+	outl(async_bus_state_cs1.bitcomp, AB0_CS1BITCOMP);
+	outl(async_bus_state_cs1.waitctrl, AB0_CS1WAITCTRL);
+	outl(async_bus_state_cs1.waitctrl_w, AB0_CS1WAITCTRL_W);
+	outl(async_bus_state_cs1.readctrl, AB0_CS1READCTRL);
+	outl(async_bus_state_cs1.control, AB0_CS1CONTROL);
+
+	outl(async_bus_state_cs2.base_addr, AB0_CS2BASEADD);
+	outl(async_bus_state_cs2.bitcomp, AB0_CS2BITCOMP);
+	outl(async_bus_state_cs2.waitctrl, AB0_CS2WAITCTRL);
+	outl(async_bus_state_cs2.waitctrl_w, AB0_CS2WAITCTRL_W);
+	outl(async_bus_state_cs2.readctrl, AB0_CS2READCTRL);
+	outl(async_bus_state_cs2.control, AB0_CS2CONTROL);
+
+	outl(async_bus_state_cs3.base_addr, AB0_CS3BASEADD);
+	outl(async_bus_state_cs3.bitcomp, AB0_CS3BITCOMP);
+	outl(async_bus_state_cs3.waitctrl, AB0_CS3WAITCTRL);
+	outl(async_bus_state_cs3.waitctrl_w, AB0_CS3WAITCTRL_W);
+	outl(async_bus_state_cs3.readctrl, AB0_CS3READCTRL);
+	outl(async_bus_state_cs3.control, AB0_CS3CONTROL);
+
+	outl(0x00000009, AB0_FLASHCOMSET);
+}
+
+/* Dummy function */
+static void restore_state_async_bus_after_func(void){};
+
+/*
+ * Save Async Bus Register.
+ *
+ */
+static void save_state_async_bus(void)
+{
+	async_bus_state_cs0.base_addr = inl(AB0_CS0BASEADD);
+	async_bus_state_cs0.bitcomp = inl(AB0_CS0BITCOMP);
+	async_bus_state_cs0.waitctrl = inl(AB0_CS0WAITCTRL);
+	async_bus_state_cs0.waitctrl_w = inl(AB0_CS0WAITCTRL_W);
+	async_bus_state_cs0.readctrl = inl(AB0_CS0READCTRL);
+	async_bus_state_cs0.control = inl(AB0_CS0CONTROL);
+
+	async_bus_state_cs1.base_addr = inl(AB0_CS1BASEADD);
+	async_bus_state_cs1.bitcomp = inl(AB0_CS1BITCOMP);
+	async_bus_state_cs1.waitctrl = inl(AB0_CS1WAITCTRL);
+	async_bus_state_cs1.waitctrl_w = inl(AB0_CS1WAITCTRL_W);
+	async_bus_state_cs1.readctrl = inl(AB0_CS1READCTRL);
+	async_bus_state_cs1.control = inl(AB0_CS1CONTROL);
+
+	async_bus_state_cs2.base_addr = inl(AB0_CS2BASEADD);
+	async_bus_state_cs2.bitcomp = inl(AB0_CS2BITCOMP);
+	async_bus_state_cs2.waitctrl = inl(AB0_CS2WAITCTRL);
+	async_bus_state_cs2.waitctrl_w = inl(AB0_CS2WAITCTRL_W);
+	async_bus_state_cs2.readctrl = inl(AB0_CS2READCTRL);
+	async_bus_state_cs2.control = inl(AB0_CS2CONTROL);
+
+	async_bus_state_cs3.base_addr = inl(AB0_CS3BASEADD);
+	async_bus_state_cs3.bitcomp = inl(AB0_CS3BITCOMP);
+	async_bus_state_cs3.waitctrl = inl(AB0_CS3WAITCTRL);
+	async_bus_state_cs3.waitctrl_w = inl(AB0_CS3WAITCTRL_W);
+	async_bus_state_cs3.readctrl = inl(AB0_CS3READCTRL);
+	async_bus_state_cs3.control = inl(AB0_CS3CONTROL);
+}
+
+static int tm2_int_ct;
+
+/*
+ * pmu_do_suspend()
+ *
+ */
+static void pmu_do_suspend(unsigned int sleep_flag)
+{
+	/* INTC Disable */
+	pmu_intc_mask(PMU_INTC_MASK_SAVE_AND_MASK);
+
+	if (!mp200_sleep_while_idle) {
+		timer_set_clock(TIMER_SUSPEND);
+		/* Disable GPIO Interrupt & Set PWC Resume Interrupt */
+		pmu_gpio_mask(sleep_flag & MP200_PMU_CLK_MASK);
+		/* eMMC/SD power off */
+		pmu_emmc_pw_ctrl(PMU_EMMC_POWER_OFF);
+	} else {
+		timer_set_clock(TIMER_SUSPEND_PDMA);
+		mp200_pmu_open_clockgate(MP200_CLOCKGATE_TI2_TIN);
+		tm2_int_ct = 0;
+		writel(0x0, TIMER2_RCR);
+		writel(0x7, TIMER2_OP);
+	}
+
+	/* save registers */
+	pmu_save_state();
+
+	/* NORMALA mode */
+	pm_change_normalA();
+
+	/* PMU registers setting and boot */
+	pmu_set_regs(sleep_flag);
+
+	/* WDT stop */
+	wdt_op_reg = inl(WDT_OP);
+	if (wdt_op_reg & 0x1) { /* TM_EN */
+		DPRINTK("disable WDT\n");
+		mp200_wdt_disable();
+	}
+
+	/* Auto Frq Change Disable */
+	outl(inl(SMU_AUTO_FRQ_CHANGE) & ~0x00000001, SMU_AUTO_FRQ_CHANGE);
+
+	/* SPI SCLK Clock Ctrl Off */
+	outl(inl(SMU_CLKCTRL) & ~(SMU_CLKCTRL_SP0SCLKLP | SMU_CLKCTRL_SP1SCLKLP
+					| SMU_CLKCTRL_SP2SCLKLP), SMU_CLKCTRL);
+
+	DPRINTK("SMU_CLKCTRL         =0x%08x\n", inl(SMU_CLKCTRL));
+	DPRINTK("SMU_AUTO_FRQ_CHANGE =0x%08x\n", inl(SMU_AUTO_FRQ_CHANGE));
+
+#ifdef IDLE_DEBUG_TW1_WAKEUP
+	tw1_test_wakeup();
+#endif
+
+	/* Auto Self Reflesh enable by PM */
+	outl((inl(MEMC_DDR_CONFIGR2) & ~0x000000FC) | 0x0000001E,
+							MEMC_DDR_CONFIGR2);
+
+	/* QR Boot & WFI */
+	mp200_cpu_do_idle(MP200_PMU_BOOT);
+
+	return;
+}
+
+/*
+ * pmu_do_resume()
+ *
+ */
+static void pmu_do_resume(void)
+{
+	DPRINTK("resume start... \n");
+
+	restore_state_async_bus();
+
+	/* restore registers */
+	pmu_restore_state();
+
+	if (!mp200_sleep_while_idle) {
+		/* eMMC/SD power on */
+		pmu_emmc_pw_ctrl(PMU_EMMC_POWER_ON);
+		/* Restore GPIO/PWC Interrupt */
+		pmu_gpio_mask(MP200_PMU_CLK_FULLSPEED);
+	}
+
+	/* INTC restore */
+	pmu_intc_mask(PMU_INTC_MASK_RESTORE);
+
+	timer_set_clock_parm(TIMER_FULLSPEED);
+	if (mp200_sleep_while_idle) {
+		timer_set_clock(TIMER_RESUME);
+	} else {
+		unsigned int tim;
+		uint64_t nsecs;
+
+		tim = readl(TIMER2_RCR);
+		writel(0x0, TIMER2_OP);
+		mp200_pmu_close_clockgate(MP200_CLOCKGATE_TI2_TIN);
+		if (readl(INTC_IT0_RAW1) & TI2_INT)
+			tim += TIMER2_INT_220MS;
+		nsecs = (uint64_t) tim * 1000000000ULL;
+
+		do_div(nsecs, TIMER_CLOCK_TICK_RATE_PLL3);
+		if (((uint64_t)xtime.tv_nsec + (uint64_t)nsecs)
+							>= 1000000000ULL) {
+			xtime.tv_sec++;
+			xtime.tv_nsec =
+				nsecs - (1000000000ULL - xtime.tv_nsec);
+		} else {
+			xtime.tv_nsec += nsecs;
+		}
+		nsecs *= HZ;
+		do_div(nsecs, (1000 * USEC_PER_SEC));
+		jiffies_64 += nsecs;
+		timer_set_clock(TIMER_RESUME_PDMA);
+	}
+
+	/* WDT start */
+	if (wdt_op_reg & 0x1)
+		mp200_wdt_enable();
+}
+
+static irqreturn_t mp200_tm_interrupt(int irq, void *dev_id)
+{
+	tm2_int_ct++;
+
+	mp200_pm_pdma_suspend_disable();
+
+	DPRINTK("** TI2_INTERRUPT %d **\n", tm2_int_ct);
+
+	return IRQ_HANDLED;
+}
+
+/*
+ * mp200_pmu_sleep(unsigned int flag)
+ */
+int mp200_pmu_sleep(unsigned int sleep_flag)
+{
+#ifdef	DEBUG_LED
+	unsigned int data;
+#endif
+
+	DPRINTK("mp200_pmu_sleep.. sleep_flag=0x%x \n", sleep_flag);
+
+#ifdef	DEBUG_LED
+	pwc_read(DA9052_GPIO1415_REG, &data);
+#endif
+
+	/* suspend */
+	pmu_do_suspend(sleep_flag);
+	pmu_do_resume();
+
+#ifdef	DEBUG_LED
+	pwc_write(DA9052_GPIO1415_REG, data, 0xFF);
+#endif
+
+	return 0;
+}
+
+int mp200_pm_do_poweroff(void)
+{
+	unsigned int regval;
+
+	/* setting pmu registers for poweroff */
+	pmu_set_regs(MP200_PMU_CLK_POWEROFF);
+
+	/* GPIO Disable */
+	pmu_gpio_mask(MP200_PMU_CLK_POWEROFF);
+
+	/* INTC Disable */
+	pmu_intc_mask(PMU_INTC_ALLMASK);
+
+	/* start PMU */
+	outl(PMU_START_SET, PMU_START);
+
+	/* wait for pmu_start */
+	do {
+		regval = inl(PMU_START);
+	} while (regval != PMU_START_SET);
+
+	/* QR Boot & WFI */
+	mp200_cpu_do_idle(MP200_PMU_BOOT);
+
+	return 0;
+}
+
+/*
+ * init
+ *
+ */
+int __init mp200_pmu_init(void)
+{
+	void *saddr;
+	void *daddr;
+	size_t len;
+	unsigned int start;
+	unsigned int end;
+	int ret, port;
+
+	wdt_op_reg = 0;
+
+	saddr = (void *) restore_state_async_bus_func;
+
+	start = (unsigned int)restore_state_async_bus_func;
+	end = (unsigned int)restore_state_async_bus_after_func;
+
+	len = end - start;
+
+	DPRINTK("len = %d\n", len);
+
+	daddr = kmalloc(len, GFP_KERNEL);
+	if (daddr == NULL)
+		return -ENOMEM;
+
+	memcpy(daddr, saddr, len);
+
+	restore_state_async_bus = (void (*))daddr;
+
+	save_state_async_bus();
+
+	flush_cache_all();
+
+	printk(KERN_INFO "Starting pmu. \n");
+
+	mp200_pmu_open_clockgate(MP200_CLOCKGATE_TI2_TIN);
+	__raw_writel((TIMER2_INT_220MS - 1), TIMER2_SET);
+	mp200_pmu_close_clockgate(MP200_CLOCKGATE_TI2_TIN);
+
+	tm2_int_ct = 0;
+	ret = request_irq(INT_TIMER2, &mp200_tm_interrupt,
+						0, "TI2_interrupt", NULL);
+	if (ret != 0) {
+		printk(KERN_ERR "error request_irq = %d\n", ret);
+		return ret;
+	}
+
+	/* P88-P91:SD0_DATA1-3/SD0_CKI */
+	for (port = GPIO_P88; port <= GPIO_P91; port++)
+		gpio_direction_output(port, GPIO_OUTPUT_LOW);
+	/* P93:SD2_CKI */
+	gpio_direction_output(GPIO_P93, GPIO_OUTPUT_LOW);
+	/* P112-P117:SD2_CKO/SD2_CMD/SD2_DATA0-3 */
+	for (port = GPIO_P112; port <= GPIO_P117; port++)
+		gpio_direction_output(port, GPIO_OUTPUT_LOW);
+
+	return 0;
+}
+
+device_initcall(mp200_pmu_init);
diff --git a/arch/arm/mach-mp200/pm_pmu.h b/arch/arm/mach-mp200/pm_pmu.h
new file mode 100644
index 0000000..c62a17d
--- /dev/null
+++ b/arch/arm/mach-mp200/pm_pmu.h
@@ -0,0 +1,596 @@
+/*
+ *  File Name	    : linux/arch/arm/mach-mp200/pmu.h
+ *  Function	    : pmu
+ *  Release Version : Ver 0.10
+ *  Release Date    : 2006/12/13
+ *
+ *  Copyright (C) NEC Electronics Corporation 2006
+ *
+ *
+ *  This program is free software;you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License as published by Free
+ *  Softwere Foundation; either version 2 of License, or (at your option) any
+ *  later version.
+ *
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warrnty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; If not, write to the Free Software Foundation, Inc., 59
+ *  Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#ifndef __ARCH_ARM_MACH_MP200_PM_PMU_H
+#define __ARCH_ARM_MACH_MP200_PM_PMU_H
+
+#include <mach/smu.h>
+#include <mach/gpio.h>
+/*
+ * Interrupt mask and unmask
+ *
+ */
+
+/* INTC registers */
+#define INTC_IT0_IEN0		   (VA_INTC + MP200_INTC_IT0_IEN0)
+#define INTC_IT0_IEN1		   (VA_INTC + MP200_INTC_IT0_IEN1)
+#define INTC_IT0_IEN2		   (VA_INTC + MP200_INTC_IT0_IEN2)
+#define INTC_IT0_IDS0		   (VA_INTC + MP200_INTC_IT0_IDS0)
+#define INTC_IT0_IDS1		   (VA_INTC + MP200_INTC_IT0_IDS1)
+#define INTC_IT0_IDS2		   (VA_INTC + MP200_INTC_IT0_IDS2)
+#define INTC_IT0_IMN0		   (VA_INTC + MP200_INTC_IT0_IMN0)
+#define INTC_IT0_IMN1		   (VA_INTC + MP200_INTC_IT0_IMN1)
+#define INTC_IT0_IMN2		   (VA_INTC + MP200_INTC_IT0_IMN2)
+#define INTC_IT0_RAW0		   (VA_INTC + MP200_INTC_IT0_RAW0)
+#define INTC_IT0_RAW1		   (VA_INTC + MP200_INTC_IT0_RAW1)
+#define INTC_IT0_RAW2		   (VA_INTC + MP200_INTC_IT0_RAW2)
+#define INTC_IT0_MST0		   (VA_INTC + MP200_INTC_IT0_MST0)
+#define INTC_IT0_MST1		   (VA_INTC + MP200_INTC_IT0_MST1)
+#define INTC_IT0_MST2		   (VA_INTC + MP200_INTC_IT0_MST2)
+
+/* INTC parameters */
+#define MASK_INTC_ALL		   0xffffffff
+#define U70_INT			   (1 << (9 - 0))
+#define PM0_INT			   (1 << (13 - 0))
+#define PDMA_INT		   (1 << (19 - 0))
+#define GIO7_INT		   (1 << (26 - 0))
+#define GIO6_INT		   (1 << (27 - 0))
+#define TG0_INT 		   (1 << (34 - 32))
+#define TG1_INT 		   (1 << (35 - 32))
+#define USB_SUSPEND_WAKEUP_INT	   (1 << (43 - 32))
+#define TG3_INT 		   (1 << (44 - 32))
+#define GIO0_INT		   (1 << (50 - 32))
+#define GIO1_INT		   (1 << (51 - 32))
+#define GIO2_INT		   (1 << (52 - 32))
+#define GIO3_INT		   (1 << (53 - 32))
+#define TI0_INT 		   (1 << (54 - 32))
+#define TI1_INT 		   (1 << (55 - 32))
+#define TI2_INT 		   (1 << (56 - 32))
+#define TW1_INT 		   (1 << (59 - 32))
+#define PMU_INT 		   (1 << (65 - 64))
+#define STI_INT 		   (1 << (71 - 64))
+#define AXL1_ERR_INT		   (1 << (88 - 64))
+#define MEMC_ERR_INT		   (1 << (89 - 64))
+#define AB0_ERR_INT		   (1 << (90 - 64))
+#define PB1_ERR_INT		   (1 << (91 - 64))
+#define SRC_ERR_INT		   (1 << (92 - 64))
+#define AXL0_ERR_INT		   (1 << (93 - 64))
+#define GIO4_INT		   (1 << (79 - 64))
+#define GIO5_INT		   (1 << (80 - 64))
+
+#define SEC_ERR_INT		   (PMU_INT | AXL1_ERR_INT | MEMC_ERR_INT | \
+				    AB0_ERR_INT | PB1_ERR_INT | \
+				    SRC_ERR_INT | AXL0_ERR_INT)
+
+#define RESUME_INTC_1		   GIO0_INT
+
+#define RESUME_INTC_2		   (STI_INT | SEC_ERR_INT)
+
+/* GPIO registers */
+/* GPIO 0-31 */
+#define GPIO_GP_IENL		   (IO_ADDRESS(MP200_GPIO_BASE) + GP_IENL)
+#define GPIO_GP_RAWL		   (IO_ADDRESS(MP200_GPIO_BASE) + GP_RAWL)
+#define GPIO_GP_IDSL		   (IO_ADDRESS(MP200_GPIO_BASE) + GP_IDSL)
+#define GPIO_GP_IIML		   (IO_ADDRESS(MP200_GPIO_BASE) + GP_IIML)
+#define GPIO_GP_MSTL		   (IO_ADDRESS(MP200_GPIO_BASE) + GP_MSTL)
+/* GPIO 32-63 */
+#define GPIO_GP_IENH		   (IO_ADDRESS(MP200_GPIO_BASE) + GP_IENH)
+#define GPIO_GP_RAWH		   (IO_ADDRESS(MP200_GPIO_BASE) + GP_RAWH)
+#define GPIO_GP_IDSH		   (IO_ADDRESS(MP200_GPIO_BASE) + GP_IDSH)
+#define GPIO_GP_IIMH		   (IO_ADDRESS(MP200_GPIO_BASE) + GP_IIMH)
+#define GPIO_GP_MSTH		   (IO_ADDRESS(MP200_GPIO_BASE) + GP_MSTH)
+/* GPIO 64-95 */
+#define GPIO_GP_IENHH		   (IO_ADDRESS(MP200_GPIO_BASE) + GP_IENHH)
+#define GPIO_GP_RAWHH		   (IO_ADDRESS(MP200_GPIO_BASE) + GP_RAWHH)
+#define GPIO_GP_IDSHH		   (IO_ADDRESS(MP200_GPIO_BASE) + GP_IDSHH)
+#define GPIO_GP_IIMHH		   (IO_ADDRESS(MP200_GPIO_BASE) + GP_IIMHH)
+#define GPIO_GP_MSTHH		   (IO_ADDRESS(MP200_GPIO_BASE) + GP_MSTHH)
+/* GPIO 96-127 */
+#define GPIO_GP_IENHHH		   (IO_ADDRESS(MP200_GPIO_BASE) + GP_IENHHH)
+#define GPIO_GP_RAWHHH		   (IO_ADDRESS(MP200_GPIO_BASE) + GP_RAWHHH)
+#define GPIO_GP_IDSHHH		   (IO_ADDRESS(MP200_GPIO_BASE) + GP_IDSHHH)
+#define GPIO_GP_IIMHHH		   (IO_ADDRESS(MP200_GPIO_BASE) + GP_IIMHHH)
+#define GPIO_GP_MSTHHH		   (IO_ADDRESS(MP200_GPIO_BASE) + GP_MSTHHH)
+
+/* GPIO parameters */
+#define MASK_GPIO_ALL		   0xFFFFFFFF
+#define GPIO_INT_PWRIC		   (1 << 0)  /* P00 */
+
+/* PowerIC GPIO parameters */
+#define PWC_KEYDATA_0	0x01
+#define PWC_KEYDATA_1	0x02
+#define PWC_KEYDATA_2	0x04
+#define PWC_KEYDATA_3	0x08
+#define PWC_KEYSCAN_1	0x20
+#define PWC_KEYSCAN_2	0x10
+
+#define MASK_GPIO_KEYSCAN		(PWC_KEYSCAN_1 | PWC_KEYSCAN_2)
+
+#define MASK_GPIO_KEYDATA		(PWC_KEYDATA_0 | PWC_KEYDATA_1 \
+					 | PWC_KEYDATA_2 | PWC_KEYDATA_3)
+
+#define MASK_GPIO_RESUME_KEY		(PWC_KEYSCAN_1 | PWC_KEYSCAN_2)
+#define MASK_USBWAKINT				0x10
+#define MASK_DETMODE3H_USBWKM		0x03
+#define DETMODE3H_USBWKM_RISE		0x01
+
+#ifdef	CONFIG_MP200_EM1_DKIT
+#define MASK_PWC_ALL			0xFF
+#define UNMASK_PWC_ALL			0x00
+#define PWC_KEY_INT				0x0F
+#define UNMASK_KEY_IN2			0xFB
+#endif
+
+/* MEMC registers*/
+#define MEMC_DDR_CONFIGR2	(IO_ADDRESS(MP200_MEMC_BASE) + 0x2018)
+#define MEMC_DDR_CONFIGR3	(IO_ADDRESS(MP200_MEMC_BASE) + 0x201c)
+
+/* WAKECONT */
+#define WAKECONT_WAKEWAIT_DISABLE	0x01
+#define MASK_WAKECONT_WAKEWAIT		0x01
+
+#define GPIO_INT_MA7DIRQB	   (1 << 2)  /* P02 */
+#define GPIO_INT_ACCELINT	   (1 << 3)  /* P03 */
+#define GPIO_INT_FINGINT	   (1 << 4)  /* P04 */
+#define GPIO_INT_SCROLLINT	   (1 << 5)  /* P05 */
+#define GPIO_INT_CHGINT 	   (1 << 8)  /* P08 */
+#define GPIO_INT_KEYINT 	   (1 << 9)  /* P09 */
+#define GPIO_INT_DTVINT 	   (1 << 12) /* P12 */
+#define GPIO_INT_DDRTEMP1	   (1 << 21) /* P21 */
+#define GPIO_INT_SIDE_CLR	   (1 << 24) /* P24 */
+#define GPIO_INT_SIDE_SET	   (1 << 25) /* P25 */
+#define GPIO_INT_ADINT		   (1 << 26) /* P26 */
+#define GPIO_INT_LUPINUS	   (1 << 31) /* P31 */
+
+#define GPIO_INT_SPINTB 	   (1 << 15) /* P47 */
+#define GPIO_INT_C_RXEND	   (1 << 17) /* P49 */
+#define GPIO_INT_A_WAKEUP	   (1 << 20) /* P52 */
+#define GPIO_INT_FRINT		   (1 << 22) /* P54 */
+#define GPIO_INT_C_RSTOB	   (1 << 23) /* P55 */
+#define GPIO_INT_MUSICCCINT	   (1 << 24) /* P56 */
+#define GPIO_INT_WLANINT	   (1 << 25) /* P57 */
+#define GPIO_INT_ETHERINT	   (1 << 31) /* P63 */
+
+/* eMMC/SD power control */
+#define PWC_REGGP3             0x02
+#define PWC_POWER_OFF	       0x00
+#define PWC_POWER_ON           0x02
+
+#define CHG_PIN_G80_SD0SD2     0x0FFF0000
+#define CHG_PIN_G112_GIO       0x00000000
+
+#define GPIO_OUTPUT_LOW        0
+
+#define PWC_SD_DETECT          0x40
+#define DETECT_OFF	           0x00
+
+/*
+ * Registers sotore and restore
+ *
+ */
+#define SMU_ENA_ALL		    0xFFFFFFFF
+#define SMU_ENA_CLEAR		    0x00000000
+
+/*
+ * PMU boot setting
+ *
+ */
+
+/* PMU registers */
+#define PMU_PC			    (IO_ADDRESS(MP200_PMU_BASE) + 0x0004)
+#define PMU_START		    (IO_ADDRESS(MP200_PMU_BASE) + 0x0008)
+#define PMU_POWER_ON_PC 	    (IO_ADDRESS(MP200_PMU_BASE) + 0x0030)
+#define PMU_WDT_COUNT_EN	    (IO_ADDRESS(MP200_PMU_BASE) + 0x0060)
+#define PMU_WDT_COUNT_LMT	    (IO_ADDRESS(MP200_PMU_BASE) + 0x0064)
+#define PMU_CMD_BUF_RAM 	    (IO_ADDRESS(MP200_PMU_BASE) + 0x1000)
+#define PMU_CMD_BUF_FF		    (IO_ADDRESS(MP200_PMU_BASE) + 0x2000)
+
+/* PMU, ASMU parameters */
+#define PMU_WDT_ENABLE		    0x00000001
+#define PMU_WDT_DISABLE 	    0x00000000
+#define PMU_WDT_MAX_COUNT	    0x0003FFFF
+#define PMU_START_SET		    0x00000001
+#define PMU_CMD_BUF_RAM_BOOT	    0x504D5520
+#define PMU_CMD_BUF_RAM_STOP	    0x00000000
+
+#define SMU_CLKCTRL_SP0SCLKLP	    0x00000004 /* CLKCTRL: bit 2 */
+#define SMU_CLKCTRL_SP1SCLKLP	    0x00000008 /* CLKCTRL: bit 3 */
+#define SMU_CLKCTRL_SP2SCLKLP	    0x00000010 /* CLKCTRL: bit 4 */
+
+#define SMU_QR_ENA_PMU_BOOT	    0x00530101
+#define SMU_QR_ENA_PMU_NOTBOOT	    0x00530103
+
+/*
+ * Flags
+ *
+ */
+#define MP200_PMU_CLK_MASK	    0x000f0000
+#define MP200_PMU_CLK_FULLSPEED     0x00010000
+#define MP200_PMU_CLK_POWERDOWN     0x00020000
+#define MP200_PMU_CLK_SLEEP	    0x00040000
+#define MP200_PMU_CLK_POWEROFF	    0x00080000
+
+#define MP200_PMU_BOOT		    0
+#define MP200_PMU_NOTBOOT	    1
+
+#define PMU_INTC_MASK_SAVE_AND_MASK 1
+#define PMU_INTC_MASK_RESTORE	    2
+#define PMU_INTC_ALLMASK			3
+
+#define PM_SLEEP_MODE_NONE		0
+
+#define PMU_EMMC_POWER_OFF			0
+#define PMU_EMMC_POWER_ON			1
+
+/*
+ * Structures
+ *
+ */
+
+/* PWC*/
+struct pwc_state {
+	unsigned char ioout1;
+	unsigned char fmask1;
+	unsigned char bmask1;
+	unsigned char fmask2;
+	unsigned char bmask2;
+	unsigned char fmask3;
+	unsigned char clrfact1;
+	unsigned char bmask3;
+	unsigned char detmod3;
+};
+/* ASMU */
+struct smu_state {
+  unsigned int resetreq0;	    /* C011_0004H */
+  unsigned int resetreq1;	    /* C011_000CH */
+  unsigned int resetreq2;	    /* C011_0018H */
+  unsigned int resetreq3;	    /* C011_083CH */
+  unsigned int clkctrl; 	    /* C011_01B0H */
+  unsigned int clkctrl1; 	    /* C011_088CH */
+  unsigned int gclkctrl0;	    /* C011_01B4H */
+  unsigned int gclkctrl1;	    /* C011_01BCH */
+  unsigned int gclkctrl2;	    /* C011_01C4H */
+  unsigned int gclkctrl3;	    /* C011_01CCH */
+  unsigned int gclkctrl4;	    /* C011_084CH */
+  unsigned int auto_frq_change;     /* C011_01DCH */
+};
+/* AINT */
+struct intc_state {
+  unsigned int it0_ien0;	    /* C002_0000H */
+  unsigned int it0_ien1;	    /* C002_0004H */
+  unsigned int it0_ien2;	    /* C002_0100H */
+};
+/* GPIO */
+struct gpio_state {
+  unsigned int ien0;		    /* GPIO_GP_IDSL */
+  unsigned int ien1;		    /* GPIO_GP_IDSH */
+  unsigned int ien2;		    /* GPIO_GP_IDSHH */
+  unsigned int ien3;		    /* GPIO_GP_IDSHHH */
+};
+struct memc_state{
+  unsigned int configr2;
+};
+/* CHG */
+struct chg_state {
+  unsigned int pinsel_g80;	    /* C014_0214H */
+  unsigned int pinsel_g112;	    /* C014_021CH */
+};
+struct register_state_t{
+  struct pwc_state   pwc;
+  struct smu_state   smu;
+  struct intc_state  intc;
+  struct gpio_state  gpio;
+  struct memc_state  memc;
+  struct chg_state   chg;
+};
+
+/* Async Bus */
+struct async_bus_state {
+	unsigned int base_addr;
+	unsigned int bitcomp;
+	unsigned int waitctrl;
+	unsigned int waitctrl_w;
+	unsigned int readctrl;
+	unsigned int control;
+};
+
+/*
+ * Functions
+ *
+ */
+extern void mp200_cpu_do_idle(unsigned int pmu_boot);
+extern int mp200_pmu_sleep(unsigned int sleep_flag);
+extern int mp200_pm_do_poweroff(void);
+
+/*
+ * PMU Command Sequence
+ *
+ */
+#define PMU_BASE		    IO_ADDRESS(0xc0100000)
+#define PMU_VIRADDR_TO_PC(addr)     (addr - PMU_BASE)
+#define PMU_PC_TO_VIRADDR(pc)	    (unsigned int *)(pc + PMU_BASE)
+
+/* for Command Sequence SMU Register Adr */
+#define SMU_CMD_POWERSW_ENA		0x0240
+#define SMU_CMD_QR_ENA			0x0220
+#define SMU_CMD_RESETREQ0		0x0004
+#define SMU_CMD_POWERSW_ACTRL_EN	0x025c
+#define SMU_CMD_L1_POWERSW	0x0244
+#define SMU_CMD_L2_POWERSW	0x0500
+#define SMU_CMD_LOG2SW_ACTRLEN	0x0504
+#define SMU_CMD_RESETREQ2ENA	0x001c
+#define SMU_CMD_RESETREQ2		0x0018
+#define SMU_CMD_LOG1SW_ACTRL	0x0260
+#define SMU_CMD_CLK_MODE_SEL	0x0080
+#define SMU_CMD_AUTO_MODE_EN	0x007c
+#define SMU_CMD_ASMU_BGCTRL		0x0208
+#define SMU_CMD_RESETREQ0ENA	0x0008
+#define SMU_CMD_RESETREQ1ENA	0x0010
+#define SMU_CMD_POWERSW_STATUS	0x023c
+#define SMU_CMD_L1_BUZ		0x0268
+#define SMU_CMD_L1_BUZ2		0x026c
+#define SMU_CMD_GCLKCTRL0ENA	0x01b8
+#define SMU_CMD_GCLKCTRL0		0x01b4
+#define SMU_CMD_GCLKCTRL1ENA	0x01c0
+#define SMU_CMD_GCLKCTRL1		0x01bc
+#define SMU_CMD_GCLKCTRL2ENA	0x01c8
+#define SMU_CMD_GCLKCTRL2		0x01c4
+#define SMU_CMD_GCLKCTRL3ENA	0x01d0
+#define SMU_CMD_GCLKCTRL3		0x01cc
+#define SMU_CMD_GCLKCTRL4ENA	0x0850
+#define SMU_CMD_GCLKCTRL4	0x084c
+#define SMU_CMD_RESETREQ3		0x083c
+#define SMU_CMD_RESETREQ3ENA		0x0840
+#define SMU_CMD_RESETREQ1		0x000c
+#define SMU_CMD_PLL1CTRL1		0x0088
+#define SMU_CMD_PLL3CTRL1		0x0098
+#define SMU_CMD_DIVSP0SCLK		0x0118
+#define SMU_CMD_IO_L0_LM_BUZ	0x0814
+#define SMU_CMD_MEMC_HAND_SHAKE_FAKE	0x08a0
+#define SMU_CMD_AHBCLKCTRL0		0x01a0
+#define SMU_CMD_AHBCLKCTRL1		0x01a4
+#define SMU_CMD_APBCLKCTRL0		0x01a8
+#define SMU_CMD_APBCLKCTRL1		0x01ac
+
+/* for Command Sequence CHG Resister Adr */
+#define CHG_CMD_CHG_L1_HOLD	0x0004
+
+/* for Command Sequence MEMC Register Adr */
+#define MEMC_CMD_DDR_STATE8	0x202c
+#define MEMC_CMD_CACHE_MODE	0x0000
+#define MEMC_CMD_DEGFUN		0x0008
+#define MEMC_CMD_REQSCH		0x1000
+#define MEMC_CMD_DDR_CONFIGF	0x2000
+#define MEMC_CMD_DDR_CONFIGA1	0x2004
+#define MEMC_CMD_DDR_CONFIGA2	0x2008
+#define MEMC_CMD_DDR_CONFIGR1	0x2014
+#define MEMC_CMD_DDR_CONFIGR2	0x2018
+#define MEMC_CMD_DDR_CONFIGR3	0x201c
+#define MEMC_CMD_DDR_CONFIGT1	0x2020
+#define MEMC_CMD_DDR_CONFIGT2	0x2024
+#define MEMC_CMD_DDR_CONFIGC1	0x200c
+#define MEMC_CMD_DDR_CONFIGC2	0x2010
+
+/* for Command Sequence SPI Register Adr */
+#define SPI_CMD_SPx_TX_DATA		0x0010
+#define SPI_CMD_SPx_CONTROL		0x0008
+#define SPI_CMD_SPx_FFCLR		0x0028
+#define SPI_CMD_SPx_ENSET		0x0020
+#define SPI_CMD_SPx_MODE		0x0000
+#define SPI_CMD_SPx_POL 		0x0004
+
+/* PMU PC */
+#define PMU_PC_MAIN		    0x1000
+#define PMU_PC_MEMC_DEEP_POWERDOWN  0x1100
+#define PMU_PC_SLEEP		    0x1280
+#define PMU_PC_POWERDOWN	    0x1300
+#define PMU_PC_POWEROFF 	    0x1480
+#define PMU_PC_SPI_ENABLE	    0x1580
+#define PMU_PC_SPI_DISABLE	    0x15d0
+#define PMU_PC_POWER_ON_SEQUENCE    0x1600
+#define PMU_PC_POWER_ON_PC	    0x1780
+#define PMU_PC_L2POWEROFF	    0x1800
+#define PMU_PC_L2POWERON	    0x1880
+#define PMU_PC_MEMC1		    0x1900
+#define PMU_PC_MEMC2		    0x1a00
+#define PMU_PC_L1POWEROFF	    0x1b00
+#define PMU_PC_L1POWERON	    0x1b80
+
+#define PMU_PC_USE_MEMC		    0x1f00
+
+/* APB Macro Parameter */
+#define ATIM_MACRO		    (0x00 << 16)
+#define AINT_MACRO		    (0x01 << 16)
+#define LCD_MACRO		    (0x02 << 16)
+#define GPIO_MACRO		    (0x03 << 16)
+#define SI1_MACRO		    (0x04 << 16)
+#define MEMC_MACRO		    (0x05 << 16)
+#define PWM_MACRO		    (0x06 << 16)
+
+#define PMU_MACRO		    (0x09 << 16)
+#define ASMU_MACRO		    (0x0A << 16)
+#define SPI0_MACRO		    (0x0B << 16)
+#define SPI1_MACRO		    (0x0C << 16)
+#define CHG_MACRO		    (0x0D << 16)
+#define SI0_MACRO		    (0x0E << 16)
+#define AXL0_MACRO		    (0x0F << 16)
+#define ASMU_S2_MACRO		    (0x11 << 16)
+#define AINT_S2_MACRO		    (0x12 << 16)
+#define MEMC_S2_MACRO		    (0x13 << 16)
+
+/* Command Parameter */
+#define CMD_REG_WRITE		    (0x00 << 25)
+#define CMD_SP0_WRITE		    (0x01 << 25)
+#define CMD_REG_READ		    (0x02 << 25)
+#define CMD_RWM 		    (0x03 << 25)
+#define CMD_MOVE		    (0x04 << 25)
+#define CMD_AND 		    (0x05 << 25)
+#define CMD_EXOR		    (0x06 << 25)
+#define CMD_CMP1		    (0x07 << 25)
+#define CMD_CMP2		    (0x08 << 25)
+#define CMD_REG_WRITE2		    (0x09 << 25)
+#define CMD_BRANCH		    (0x10 << 25)
+#define CMD_JUMP		    (0x11 << 25)
+#define CMD_AJUMP		    (0x12 << 25)
+#define CMD_SUBROUTINE_START	    (0x13 << 25)
+#define CMD_RFS 		    (0x14 << 25)
+#define CMD_TIMERWAIT		    (0x20 << 25)
+#define CMD_INTWAIT		    (0x21 << 25)
+#define CMD_CCPU_STAT_WAIT	    (0x22 << 25)
+#define CMD_SMU_READY_WAIT	    (0x23 << 25)
+#define CMD_TRIG_WAIT		    (0x24 << 25)
+#define CMD_QR_WAIT		    (0x25 << 25)
+#define CMD_CYCLE_WAIT		    (0x26 << 25)
+#define CMD_LCD_MODE_WAIT	    (0x27 << 25)
+#define CMD_INT_MASK		    (0x30 << 25)
+#define CMD_ARMINT_MASK 	    (0x31 << 25)
+#define CMD_WDT_CLEAR		    (0x32 << 25)
+#define CMD_WDT_STOP		    (0x33 << 25)
+#define CMD_WDT_RESTART 	    (0x34 << 25)
+#define CMD_PMU_END		    (0x35 << 25)
+#define CMD_NOP 		    (0x36 << 25)
+
+/* Other Parameters */
+#define PMU_REGA		    (0 << 24)
+#define PMU_REGB		    (1 << 24)
+#define PMU_BEQ 		    (0 << 24)
+#define PMU_BNE 		    (1 << 24)
+#define PMU_WAIT_INT_END	    (0 << 24)
+#define PMU_WAIT_INT_CONTINUE	    (1 << 24)
+#define PMU_LOW_LEVEL		    (0 << 24)
+#define PMU_HIGH_LEVEL		    (1 << 24)
+#define PMU_TRIG_TIMER		    (1 << 19)
+#define PMU_TRIG_CCPU_ACCESS_LOW    (1 << 20)
+#define PMU_TRIG_CCPU_ACCESS_HIGH   (1 << 21)
+#define PMU_TRIG_CCPU_LOWPWR_LOW    (1 << 22)
+#define PMU_TRIG_CCPU_LOWPWR_HIGH   (1 << 23)
+#define PMU_TRIG_INT		    (1 << 24)
+#define PMU_QR_WAIT_BACKUP	    (0 << 24)
+#define PMU_QR_WAIT_RESTORE	    (1 << 24)
+#define PMU_INT_UNMASK		    (0 << 24)
+#define PMU_INT_MASK		    (1 << 24)
+
+/* Commands */
+#define PCMD_REG_WRITE(macro, addr, data) {			\
+    outl((CMD_REG_WRITE | macro | addr), pmu_cmd_adr++);        \
+    outl(data, pmu_cmd_adr++);				        \
+}
+#define PCMD_SP0_WRITE(addr, data) {				\
+    outl((CMD_SP0_WRITE | addr), pmu_cmd_adr++);	        \
+    outl(data, pmu_cmd_adr++);				        \
+}
+#define PCMD_REG_READ(macro, addr, aorb) {			\
+    outl((CMD_REG_READ | aorb | macro | addr), pmu_cmd_adr++);  \
+}
+#define PCMD_RWM(macro, addr, data, data_en) {			\
+    outl((CMD_RWM | macro | addr), pmu_cmd_adr++);	        \
+    outl(data, pmu_cmd_adr++);				        \
+    outl(data_en, pmu_cmd_adr++);			        \
+}
+#define PCMD_MOVE(data, aorb) {					\
+    outl((CMD_MOVE | aorb), pmu_cmd_adr++);		        \
+    outl(data, pmu_cmd_adr++);				        \
+}
+#define PCMD_AND(data, aorb) {					\
+    outl((CMD_AND | aorb), pmu_cmd_adr++);		        \
+    outl(data, pmu_cmd_adr++);				        \
+}
+#define PCMD_EXOR(data, aorb) { 				\
+    outl((CMD_EXOR | aorb), pmu_cmd_adr++);		        \
+    outl(data, pmu_cmd_adr++);				        \
+}
+#define PCMD_CMP1() {						\
+    outl(CMD_CMP1, pmu_cmd_adr++);			        \
+}
+#define PCMD_CMP2(data, aorb) { 				\
+    outl((CMD_CMP2 | aorb), pmu_cmd_adr++);		        \
+    outl(data, pmu_cmd_adr++);				        \
+}
+#define PCMD_REG_WRITE2(macro, addr, aorb) {			\
+    outl((CMD_REG_WRITE2 | aorb | macro | addr), pmu_cmd_adr++);\
+}
+#define PCMD_BRANCH(jump, op) { 				\
+    outl((CMD_BRANCH | op | jump), pmu_cmd_adr++);	        \
+}
+#define PCMD_JUMP(jump) {					\
+    outl((CMD_JUMP | jump), pmu_cmd_adr++);		        \
+}
+#define PCMD_AJUMP(jump) {					\
+    outl((CMD_AJUMP | jump), pmu_cmd_adr++);		        \
+}
+#define PCMD_SUBROUTINE_START(jump) {				\
+    outl((CMD_SUBROUTINE_START | jump), pmu_cmd_adr++);         \
+}
+#define PCMD_RFS() {						\
+    outl(CMD_RFS, pmu_cmd_adr++);			        \
+}
+#define PCMD_TIMERWAIT(count, int) {				\
+    outl((CMD_TIMERWAIT | int | count), pmu_cmd_adr++);         \
+}
+#define PCMD_INTWAIT() {					\
+    outl(CMD_INTWAIT, pmu_cmd_adr++);			        \
+}
+#define PCMD_CCPU_STAT_WAIT(level) {				\
+    outl((CMD_CCPU_STAT_WAIT | level), pmu_cmd_adr++);	        \
+}
+#define PCMD_SMU_READY_WAIT(level) {				\
+    outl((CMD_SMU_READY_WAIT | level), pmu_cmd_adr++);	        \
+}
+#define PCMD_TRIG_WAIT(count, trig) {				\
+    outl((CMD_TRIG_WAIT | trig | count), pmu_cmd_adr++);        \
+}
+#define PCMD_QR_WAIT(borr) {					\
+    outl((CMD_QR_WAIT | borr), pmu_cmd_adr++);		        \
+}
+#define PCMD_CYCLE_WAIT(count, int) {				\
+    outl((CMD_CYCLE_WAIT | int | count), pmu_cmd_adr++);        \
+}
+#define PCMD_LCD_MODE_WAIT() {					\
+    outl(CMD_LCD_MODE_WAIT, pmu_cmd_adr++);		        \
+}
+#define PCMD_INT_MASK(mask) {					\
+    outl((CMD_INT_MASK | mask), pmu_cmd_adr++); 	        \
+}
+#define PCMD_ARMINT_MASK(mask) {				\
+    outl((CMD_ARMINT_MASK | mask), pmu_cmd_adr++);	        \
+}
+#define PCMD_WDT_CLEAR() {					\
+    outl(CMD_WDT_CLEAR, pmu_cmd_adr++); 		        \
+}
+#define PCMD_WDT_STOP() { 					\
+    outl(CMD_WDT_STOP, pmu_cmd_adr++);			        \
+}
+#define PCMD_WDT_RESTART() {					\
+    outl(CMD_WDT_RESTART, pmu_cmd_adr++);		        \
+}
+#define PCMD_PMU_END() {					\
+    outl(CMD_PMU_END, pmu_cmd_adr++);			        \
+}
+#define PCMD_NOP() {						\
+    outl(CMD_NOP, pmu_cmd_adr++);			        \
+}
+
+
+#endif /* __ARCH_ARM_MACH_MP200_PM_PMU_H */
diff --git a/arch/arm/mach-mp200/pmu.c b/arch/arm/mach-mp200/pmu.c
new file mode 100644
index 0000000..ae5ddc5
--- /dev/null
+++ b/arch/arm/mach-mp200/pmu.c
@@ -0,0 +1,646 @@
+/*
+ *  File Name	    : linux/arch/arm/mach-mp200/pmu.c
+ *  Function	    : pmu
+ *  Release Version : Ver 1.02
+ *  Release Date    : 2009/02/24
+ *
+ *  Copyright (C) NEC Electronics Corporation 2009
+ *
+ *
+ *  This program is free software;you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License as published by Free
+ *  Softwere Foundation; either version 2 of License, or (at your option) any
+ *  later version.
+ *
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warrnty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; If not, write to the Free Software Foundation, Inc., 59
+ *  Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/mm.h>
+#include <linux/delay.h>
+#include <linux/io.h>
+
+#include <mach/smu.h>
+#include <mach/pmu.h>
+
+static DEFINE_SPINLOCK(lock_clockgate);
+static DEFINE_SPINLOCK(lock_reset0);
+static DEFINE_SPINLOCK(lock_reset1);
+static DEFINE_SPINLOCK(lock_reset2);
+static DEFINE_SPINLOCK(lock_reset3);
+static DEFINE_SPINLOCK(lock_clkctrl);
+
+
+#define MLD_RESET_MASK	(1 << (MP200_RESETDEVICE_MLD & SMU_REG_BIT_MASK))
+#define MLD_RCLK_MASK	(1 << (MP200_CLOCKGATE_MLD_RCLK & SMU_REG_BIT_MASK))
+
+
+static inline void pmu_parent_clock(unsigned int clkbit, int enable)
+{
+
+	switch (clkbit) {
+	default:
+		break;
+	}
+}
+
+
+int mp200_pmu_open_clockgate(unsigned int clkbit)
+{
+	unsigned long cpu_flags;
+	unsigned int mask;
+	int bit;
+	int ret = 0, delay_usec = 0;
+
+	bit = clkbit & SMU_REG_BIT_MASK;
+	if (bit >= SMU_REG_MAX_BIT_LEN)
+		return -EINVAL;
+	mask = 1 << bit;
+
+	pmu_parent_clock(clkbit, 1);
+
+	spin_lock_irqsave(&lock_clockgate, cpu_flags);
+
+	switch (clkbit & SMU_REG_GROUP_MASK) {
+	case SMU_GCLKCTRL0_GROUP:
+		outl(mask, SMU_GCLKCTRL0ENA);
+		outl(mask, SMU_GCLKCTRL0);
+		outl(0, SMU_GCLKCTRL0ENA);
+		break;
+	case SMU_GCLKCTRL1_GROUP:
+		outl(mask, SMU_GCLKCTRL1ENA);
+		outl(mask, SMU_GCLKCTRL1);
+		outl(0, SMU_GCLKCTRL1ENA);
+		break;
+	case SMU_GCLKCTRL2_GROUP:
+		outl(mask, SMU_GCLKCTRL2ENA);
+		outl(mask, SMU_GCLKCTRL2);
+		outl(0, SMU_GCLKCTRL2ENA);
+		break;
+	case SMU_GCLKCTRL3_GROUP:
+		outl(mask, SMU_GCLKCTRL3ENA);
+		outl(mask, SMU_GCLKCTRL3);
+		outl(0, SMU_GCLKCTRL3ENA);
+		break;
+	case SMU_GCLKCTRL4_GROUP:
+		outl(mask, SMU_GCLKCTRL4ENA);
+		outl(mask, SMU_GCLKCTRL4);
+		outl(0, SMU_GCLKCTRL4ENA);
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	spin_unlock_irqrestore(&lock_clockgate, cpu_flags);
+
+	if (delay_usec != 0)
+		udelay(delay_usec);
+
+	return ret;
+}
+EXPORT_SYMBOL(mp200_pmu_open_clockgate);
+
+int mp200_pmu_close_clockgate(unsigned int clkbit)
+{
+	unsigned long cpu_flags;
+	unsigned int mask;
+	int bit;
+	int ret = 0;
+	int close_skip = 0;
+
+	bit = clkbit & SMU_REG_BIT_MASK;
+	if (bit >= SMU_REG_MAX_BIT_LEN)
+		return -EINVAL;
+	mask = 1 << bit;
+
+	spin_lock_irqsave(&lock_clockgate, cpu_flags);
+
+	switch (clkbit) {
+	case MP200_CLOCKGATE_U70_CLK:
+		if (mp200_pmu_get_clockgate(MP200_CLOCKGATE_U70_SCLK) ||
+		    mp200_pmu_get_clockgate(MP200_CLOCKGATE_U71_SCLK) ||
+		    mp200_pmu_get_clockgate(MP200_CLOCKGATE_U72_SCLK)) {
+			close_skip = 1;
+		}
+		break;
+	case MP200_CLOCKGATE_ATIM_PCLK:
+		if (mp200_pmu_get_clockgate(MP200_CLOCKGATE_TI0_TIN) ||
+		    mp200_pmu_get_clockgate(MP200_CLOCKGATE_TI1_TIN) ||
+		    mp200_pmu_get_clockgate(MP200_CLOCKGATE_TI2_TIN) ||
+		    mp200_pmu_get_clockgate(MP200_CLOCKGATE_TI3_TIN) ||
+		    mp200_pmu_get_clockgate(MP200_CLOCKGATE_TW0_TIN) ||
+		    mp200_pmu_get_clockgate(MP200_CLOCKGATE_TW1_TIN) ||
+		    mp200_pmu_get_clockgate(MP200_CLOCKGATE_TW2_TIN) ||
+		    mp200_pmu_get_clockgate(MP200_CLOCKGATE_TW3_TIN) ||
+		    mp200_pmu_get_clockgate(MP200_CLOCKGATE_TG0_TIN) ||
+		    mp200_pmu_get_clockgate(MP200_CLOCKGATE_TG1_TIN) ||
+		    mp200_pmu_get_clockgate(MP200_CLOCKGATE_TG2_TIN) ||
+		    mp200_pmu_get_clockgate(MP200_CLOCKGATE_TG3_TIN) ||
+		    mp200_pmu_get_clockgate(MP200_CLOCKGATE_TG4_TIN) ||
+		    mp200_pmu_get_clockgate(MP200_CLOCKGATE_TG5_TIN)) {
+			close_skip = 1;
+		}
+		break;
+	case MP200_CLOCKGATE_PM0_PCLK:
+		if (mp200_pmu_get_clockgate(MP200_CLOCKGATE_PM0_SCLK) ||
+		    mp200_pmu_get_clockgate(MP200_CLOCKGATE_PM1_SCLK)) {
+			close_skip = 1;
+		}
+		break;
+	default:
+		break;
+	}
+
+	if (close_skip == 0) {
+		switch (clkbit & SMU_REG_GROUP_MASK) {
+		case SMU_GCLKCTRL0_GROUP:
+			outl(mask, SMU_GCLKCTRL0ENA);
+			outl(0, SMU_GCLKCTRL0);
+			outl(0, SMU_GCLKCTRL0ENA);
+			break;
+		case SMU_GCLKCTRL1_GROUP:
+			outl(mask, SMU_GCLKCTRL1ENA);
+			outl(0, SMU_GCLKCTRL1);
+			outl(0, SMU_GCLKCTRL1ENA);
+			break;
+		case SMU_GCLKCTRL2_GROUP:
+			outl(mask, SMU_GCLKCTRL2ENA);
+			outl(0, SMU_GCLKCTRL2);
+			outl(0, SMU_GCLKCTRL2ENA);
+			break;
+		case SMU_GCLKCTRL3_GROUP:
+			outl(mask, SMU_GCLKCTRL3ENA);
+			outl(0, SMU_GCLKCTRL3);
+			outl(0, SMU_GCLKCTRL3ENA);
+			break;
+		case SMU_GCLKCTRL4_GROUP:
+			outl(mask, SMU_GCLKCTRL4ENA);
+			outl(0, SMU_GCLKCTRL4);
+			outl(0, SMU_GCLKCTRL4ENA);
+			break;
+		default:
+			ret = -EINVAL;
+			break;
+		}
+	}
+
+	spin_unlock_irqrestore(&lock_clockgate, cpu_flags);
+
+	pmu_parent_clock(clkbit, 0);
+
+	return ret;
+}
+EXPORT_SYMBOL(mp200_pmu_close_clockgate);
+
+int mp200_pmu_get_clockgate(unsigned int clkbit)
+{
+	unsigned int regval;
+	unsigned int mask;
+	int bit;
+	int ret;
+
+	bit = clkbit & SMU_REG_BIT_MASK;
+	if (bit >= SMU_REG_MAX_BIT_LEN)
+		return -EINVAL;
+	mask = 1 << bit;
+
+	switch (clkbit & SMU_REG_GROUP_MASK) {
+	case SMU_GCLKCTRL0_GROUP:
+		regval = inl(SMU_GCLKCTRL0);
+		ret = (regval & mask) ? 1 : 0;
+		break;
+	case SMU_GCLKCTRL1_GROUP:
+		regval = inl(SMU_GCLKCTRL1);
+		ret = (regval & mask) ? 1 : 0;
+		break;
+	case SMU_GCLKCTRL2_GROUP:
+		regval = inl(SMU_GCLKCTRL2);
+		ret = (regval & mask) ? 1 : 0;
+		break;
+	case SMU_GCLKCTRL3_GROUP:
+		regval = inl(SMU_GCLKCTRL3);
+		ret = (regval & mask) ? 1 : 0;
+		break;
+	case SMU_GCLKCTRL4_GROUP:
+		regval = inl(SMU_GCLKCTRL4);
+		ret = (regval & mask) ? 1 : 0;
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	return ret;
+}
+EXPORT_SYMBOL(mp200_pmu_get_clockgate);
+
+#define RST_WAIT_MAX_CLKCTRL	3
+static inline void clkctrl_off_wait(unsigned int clkctrl[],
+			unsigned int clkctrl_num, unsigned int delay_num)
+{
+	int i;
+	unsigned int val[RST_WAIT_MAX_CLKCTRL];
+
+	for (i = 0; i < clkctrl_num; i++) {
+		val[i] = mp200_pmu_get_clkctrl_status(clkctrl[i]);
+		if (val[i] == 1)
+			mp200_pmu_clkctrl_off(clkctrl[i]);
+	}
+
+	udelay(delay_num);
+
+	for (i = 0; i < clkctrl_num; i++) {
+		if (val[i] == 1)
+			mp200_pmu_clkctrl_on(clkctrl[i]);
+	}
+}
+
+static inline void pmu_reset_wait(unsigned int rstdev)
+{
+	unsigned int clkctrl[RST_WAIT_MAX_CLKCTRL];
+
+	switch (rstdev) {
+	case MP200_RESETDEVICE_SP2:
+		clkctrl[0] = MP200_CLKCTRL_SP2PCLK;
+		clkctrl[1] = MP200_CLKCTRL_SP2SCLK;
+		clkctrl_off_wait(clkctrl, 2, 100);
+		break;
+	case MP200_RESETDEVICE_SP1:
+		clkctrl[0] = MP200_CLKCTRL_SP1PCLK;
+		clkctrl[1] = MP200_CLKCTRL_SP1SCLK;
+		clkctrl_off_wait(clkctrl, 2, 100);
+		break;
+	case MP200_RESETDEVICE_SP0:
+		clkctrl[0] = MP200_CLKCTRL_SP0PCLK;
+		clkctrl[1] = MP200_CLKCTRL_SP0SCLK;
+		clkctrl_off_wait(clkctrl, 2, 100);
+		break;
+	case MP200_RESETDEVICE_TG5:
+	case MP200_RESETDEVICE_TG4:
+	case MP200_RESETDEVICE_TG3:
+	case MP200_RESETDEVICE_TG2:
+	case MP200_RESETDEVICE_TG1:
+	case MP200_RESETDEVICE_TG0:
+	case MP200_RESETDEVICE_TW3:
+	case MP200_RESETDEVICE_TW2:
+	case MP200_RESETDEVICE_TW1:
+	case MP200_RESETDEVICE_TW0:
+	case MP200_RESETDEVICE_TI3:
+	case MP200_RESETDEVICE_TI2:
+	case MP200_RESETDEVICE_TI1:
+	case MP200_RESETDEVICE_TI0:
+		clkctrl[0] = MP200_CLKCTRL_TIMPCLK;
+		clkctrl_off_wait(clkctrl, 1, 100);
+		break;
+	case MP200_RESETDEVICE_IIC:
+	case MP200_RESETDEVICE_IIC2:
+	case MP200_RESETDEVICE_MWI:
+	case MP200_RESETDEVICE_NAND:
+	case MP200_RESETDEVICE_PM1:
+	case MP200_RESETDEVICE_PM0:
+	case MP200_RESETDEVICE_U72:
+	case MP200_RESETDEVICE_U71:
+	case MP200_RESETDEVICE_U70:
+		udelay(100);
+		break;
+	case MP200_RESETDEVICE_LCD:
+		clkctrl[0] = MP200_CLKCTRL_LCDPCLK;
+		clkctrl[1] = MP200_CLKCTRL_LCD;
+		clkctrl[2] = MP200_CLKCTRL_LCDCCK;
+		clkctrl_off_wait(clkctrl, 3, 1);
+		break;
+	default:
+		break;
+	}
+}
+
+int mp200_pmu_reset_device(unsigned int rstdev)
+{
+	unsigned long cpu_flags;
+	unsigned int mask;
+	int bit;
+	int ret = 0;
+
+	bit = rstdev & SMU_REG_BIT_MASK;
+	if (bit >= SMU_REG_MAX_BIT_LEN)
+		return -EINVAL;
+	mask = 1 << bit;
+
+	switch (rstdev & SMU_REG_GROUP_MASK) {
+	case SMU_RESETREQ0_GROUP:
+		spin_lock_irqsave(&lock_reset0, cpu_flags);
+		outl(mask, SMU_RESETREQ0ENA);
+		if (bit < 8)
+			outb(0, SMU_RESETREQ0);
+		else if (bit < 16)
+			outb(0, SMU_RESETREQ0 + 1);
+		else if (bit < 24)
+			outb(0, SMU_RESETREQ0 + 2);
+		else
+			outb(0, SMU_RESETREQ0 + 3);
+
+		outl(0, SMU_RESETREQ0ENA);
+		spin_unlock_irqrestore(&lock_reset0, cpu_flags);
+		break;
+	case SMU_RESETREQ1_GROUP:
+		spin_lock_irqsave(&lock_reset1, cpu_flags);
+		outl(mask, SMU_RESETREQ1ENA);
+		outl(0, SMU_RESETREQ1);
+		outl(0, SMU_RESETREQ1ENA);
+		spin_unlock_irqrestore(&lock_reset1, cpu_flags);
+		break;
+	case SMU_RESETREQ2_GROUP:
+		spin_lock_irqsave(&lock_reset2, cpu_flags);
+		outl(mask, SMU_RESETREQ2ENA);
+		outl(0, SMU_RESETREQ2);
+		outl(0, SMU_RESETREQ2ENA);
+		spin_unlock_irqrestore(&lock_reset2, cpu_flags);
+		break;
+	case SMU_RESETREQ3_GROUP:
+		spin_lock_irqsave(&lock_reset3, cpu_flags);
+		outl(mask, SMU_RESETREQ3ENA);
+		outl(0, SMU_RESETREQ3);
+		outl(0, SMU_RESETREQ3ENA);
+		spin_unlock_irqrestore(&lock_reset3, cpu_flags);
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	pmu_reset_wait(rstdev);
+
+	return ret;
+}
+EXPORT_SYMBOL(mp200_pmu_reset_device);
+
+int mp200_pmu_unreset_device(unsigned int rstdev)
+{
+	unsigned long cpu_flags;
+	unsigned int mask;
+	int bit;
+	int ret = 0;
+
+	bit = rstdev & SMU_REG_BIT_MASK;
+	if (bit >= SMU_REG_MAX_BIT_LEN)
+		return -EINVAL;
+	mask = 1 << bit;
+
+
+	switch (rstdev & SMU_REG_GROUP_MASK) {
+	case SMU_RESETREQ0_GROUP:
+		spin_lock_irqsave(&lock_reset0, cpu_flags);
+		outl(mask, SMU_RESETREQ0ENA);
+		if (bit < 8)
+			outb(mask, SMU_RESETREQ0);
+		else if (bit < 16)
+			outb(mask >>  8, SMU_RESETREQ0 + 1);
+		else if (bit < 24)
+			outb(mask >> 16, SMU_RESETREQ0 + 2);
+		else
+			outb(mask >> 24, SMU_RESETREQ0 + 3);
+
+		outl(0, SMU_RESETREQ0ENA);
+		spin_unlock_irqrestore(&lock_reset0, cpu_flags);
+		break;
+	case SMU_RESETREQ1_GROUP:
+		spin_lock_irqsave(&lock_reset1, cpu_flags);
+		outl(mask, SMU_RESETREQ1ENA);
+		outl(mask, SMU_RESETREQ1);
+		outl(0, SMU_RESETREQ1ENA);
+		spin_unlock_irqrestore(&lock_reset1, cpu_flags);
+		break;
+	case SMU_RESETREQ2_GROUP:
+		spin_lock_irqsave(&lock_reset2, cpu_flags);
+		outl(mask, SMU_RESETREQ2ENA);
+		outl(mask, SMU_RESETREQ2);
+		outl(0, SMU_RESETREQ2ENA);
+		spin_unlock_irqrestore(&lock_reset2, cpu_flags);
+		break;
+	case SMU_RESETREQ3_GROUP:
+		spin_lock_irqsave(&lock_reset3, cpu_flags);
+		outl(mask, SMU_RESETREQ3ENA);
+		outl(mask, SMU_RESETREQ3);
+		outl(0, SMU_RESETREQ3ENA);
+		spin_unlock_irqrestore(&lock_reset3, cpu_flags);
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	pmu_reset_wait(rstdev);
+
+	return ret;
+}
+EXPORT_SYMBOL(mp200_pmu_unreset_device);
+
+int mp200_pmu_get_reset_status(unsigned int rstdev)
+{
+	unsigned int regval;
+	unsigned int mask;
+	int bit;
+	int ret;
+
+	bit = rstdev & SMU_REG_BIT_MASK;
+	if (bit >= SMU_REG_MAX_BIT_LEN)
+		return -EINVAL;
+	mask = 1 << bit;
+
+	switch (rstdev & SMU_REG_GROUP_MASK) {
+	case SMU_RESETREQ0_GROUP:
+		regval = inl(SMU_RESETREQ0);
+		ret = (regval & mask) ? 1 : 0;
+		break;
+	case SMU_RESETREQ1_GROUP:
+		regval = inl(SMU_RESETREQ1);
+		ret = (regval & mask) ? 1 : 0;
+		break;
+	case SMU_RESETREQ2_GROUP:
+		regval = inl(SMU_RESETREQ2);
+		ret = (regval & mask) ? 1 : 0;
+		break;
+	case SMU_RESETREQ3_GROUP:
+		regval = inl(SMU_RESETREQ3);
+		ret = (regval & mask) ? 1 : 0;
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	return ret;
+}
+EXPORT_SYMBOL(mp200_pmu_get_reset_status);
+
+int mp200_pmu_clkctrl_on(unsigned int dev)
+{
+	unsigned long cpu_flags;
+	unsigned int regval;
+	unsigned int mask;
+	int bit;
+	int ret = 0;
+
+	bit = dev & SMU_REG_BIT_MASK;
+	if (bit >= SMU_REG_MAX_BIT_LEN)
+		return -EINVAL;
+	mask = 1 << bit;
+
+	spin_lock_irqsave(&lock_clkctrl, cpu_flags);
+
+	switch (dev & SMU_REG_GROUP_MASK) {
+	case SMU_AHBCLKCTRL0_GROUP:
+		regval = inl(SMU_AHBCLKCTRL0);
+		regval |= mask;
+		outl(regval, SMU_AHBCLKCTRL0);
+		break;
+	case SMU_AHBCLKCTRL1_GROUP:
+		regval = inl(SMU_AHBCLKCTRL1);
+		regval |= mask;
+		outl(regval, SMU_AHBCLKCTRL1);
+		break;
+	case SMU_APBCLKCTRL0_GROUP:
+		regval = inl(SMU_APBCLKCTRL0);
+		regval |= mask;
+		outl(regval, SMU_APBCLKCTRL0);
+		break;
+	case SMU_APBCLKCTRL1_GROUP:
+		regval = inl(SMU_APBCLKCTRL1);
+		regval |= mask;
+		outl(regval, SMU_APBCLKCTRL1);
+		break;
+	case SMU_CLKCTRL_GROUP:
+		regval = inl(SMU_CLKCTRL);
+		regval |= mask;
+		outl(regval, SMU_CLKCTRL);
+		break;
+	case SMU_APBCLKCTRL2_GROUP:
+		regval = inl(SMU_APBCLKCTRL2);
+		regval |= mask;
+		outl(regval, SMU_APBCLKCTRL2);
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	spin_unlock_irqrestore(&lock_clkctrl, cpu_flags);
+
+	return ret;
+}
+EXPORT_SYMBOL(mp200_pmu_clkctrl_on);
+
+int mp200_pmu_clkctrl_off(unsigned int dev)
+{
+	unsigned long cpu_flags;
+	unsigned int regval;
+	unsigned int mask;
+	int bit;
+	int ret = 0;
+
+	bit = dev & SMU_REG_BIT_MASK;
+	if (bit >= SMU_REG_MAX_BIT_LEN)
+		return -EINVAL;
+	mask = 1 << bit;
+
+	spin_lock_irqsave(&lock_clkctrl, cpu_flags);
+
+	switch (dev & SMU_REG_GROUP_MASK) {
+	case SMU_AHBCLKCTRL0_GROUP:
+		regval = inl(SMU_AHBCLKCTRL0);
+		regval &= ~mask;
+		outl(regval, SMU_AHBCLKCTRL0);
+		break;
+	case SMU_AHBCLKCTRL1_GROUP:
+		regval = inl(SMU_AHBCLKCTRL1);
+		regval &= ~mask;
+		outl(regval, SMU_AHBCLKCTRL1);
+		break;
+	case SMU_APBCLKCTRL0_GROUP:
+		regval = inl(SMU_APBCLKCTRL0);
+		regval &= ~mask;
+		outl(regval, SMU_APBCLKCTRL0);
+		break;
+	case SMU_APBCLKCTRL1_GROUP:
+		regval = inl(SMU_APBCLKCTRL1);
+		regval &= ~mask;
+		outl(regval, SMU_APBCLKCTRL1);
+		break;
+	case SMU_CLKCTRL_GROUP:
+		regval = inl(SMU_CLKCTRL);
+		regval &= ~mask;
+		outl(regval, SMU_CLKCTRL);
+		break;
+	case SMU_APBCLKCTRL2_GROUP:
+		regval = inl(SMU_APBCLKCTRL2);
+		regval &= ~mask;
+		outl(regval, SMU_APBCLKCTRL2);
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	spin_unlock_irqrestore(&lock_clkctrl, cpu_flags);
+
+	return ret;
+}
+EXPORT_SYMBOL(mp200_pmu_clkctrl_off);
+
+int mp200_pmu_get_clkctrl_status(unsigned int dev)
+{
+	unsigned int regval;
+	unsigned int mask;
+	int bit;
+	int ret;
+
+	bit = dev & SMU_REG_BIT_MASK;
+	if (bit >= SMU_REG_MAX_BIT_LEN)
+		return -EINVAL;
+	mask = 1 << bit;
+
+	switch (dev & SMU_REG_GROUP_MASK) {
+	case SMU_AHBCLKCTRL0_GROUP:
+		regval = inl(SMU_AHBCLKCTRL0);
+		ret = (regval & mask) ? 1 : 0;
+		break;
+	case SMU_AHBCLKCTRL1_GROUP:
+		regval = inl(SMU_AHBCLKCTRL1);
+		ret = (regval & mask) ? 1 : 0;
+		break;
+	case SMU_APBCLKCTRL0_GROUP:
+		regval = inl(SMU_APBCLKCTRL0);
+		ret = (regval & mask) ? 1 : 0;
+		break;
+	case SMU_APBCLKCTRL1_GROUP:
+		regval = inl(SMU_APBCLKCTRL1);
+		ret = (regval & mask) ? 1 : 0;
+		break;
+	case SMU_CLKCTRL_GROUP:
+		regval = inl(SMU_CLKCTRL);
+		ret = (regval & mask) ? 1 : 0;
+		break;
+	case SMU_APBCLKCTRL2_GROUP:
+		regval = inl(SMU_APBCLKCTRL2);
+		ret = (regval & mask) ? 1 : 0;
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	return ret;
+}
+EXPORT_SYMBOL(mp200_pmu_get_clkctrl_status);
+
diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index 3f94039..dc51fc0 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -631,6 +631,22 @@ static void platform_pm_complete(struct device *dev)
 
 #ifdef CONFIG_SUSPEND
 
+#ifdef CONFIG_ARCH_MP200
+static int platform_pm_suspend(struct device *dev, pm_message_t state)
+{
+	struct device_driver *drv = dev->driver;
+	int ret = 0;
+
+	if (drv && drv->pm) {
+		if (drv->pm->suspend)
+			ret = drv->pm->suspend(dev, state);
+	} else {
+		ret = platform_legacy_suspend(dev, state);
+	}
+
+	return ret;
+}
+#else
 static int platform_pm_suspend(struct device *dev)
 {
 	struct device_driver *drv = dev->driver;
@@ -645,6 +661,7 @@ static int platform_pm_suspend(struct device *dev)
 
 	return ret;
 }
+#endif
 
 static int platform_pm_suspend_noirq(struct device *dev)
 {
diff --git a/drivers/base/power/main.c b/drivers/base/power/main.c
index 273a944..b7222c1 100644
--- a/drivers/base/power/main.c
+++ b/drivers/base/power/main.c
@@ -24,6 +24,10 @@
 #include <linux/resume-trace.h>
 #include <linux/rwsem.h>
 
+#ifdef CONFIG_ARCH_MP200
+#include <mach/pm.h>
+#endif
+
 #include "../base.h"
 #include "power.h"
 
@@ -118,9 +122,19 @@ static int pm_op(struct device *dev, struct pm_ops *ops, pm_message_t state)
 
 	switch (state.event) {
 #ifdef CONFIG_SUSPEND
+#ifdef CONFIG_ARCH_MP200
+	case DEV_SUSPEND_IDLE_1:
+		if (ops->suspend)
+			error = ops->suspend(dev, state);
+		break;
+	case PM_EVENT_SUSPEND:
+		if (ops->suspend) {
+			error = ops->suspend(dev, state);
+#else
 	case PM_EVENT_SUSPEND:
 		if (ops->suspend) {
 			error = ops->suspend(dev);
+#endif
 			suspend_report_result(ops->suspend, error);
 		}
 		break;
@@ -181,6 +195,12 @@ static int pm_noirq_op(struct device *dev, struct pm_ext_ops *ops,
 
 	switch (state.event) {
 #ifdef CONFIG_SUSPEND
+#ifdef CONFIG_ARCH_MP200
+	case DEV_SUSPEND_IDLE_1:
+		if (ops->suspend_noirq)
+			error = ops->suspend_noirq(dev);
+		break;
+#endif
 	case PM_EVENT_SUSPEND:
 		if (ops->suspend_noirq) {
 			error = ops->suspend_noirq(dev);
@@ -231,6 +251,10 @@ static int pm_noirq_op(struct device *dev, struct pm_ext_ops *ops,
 static char *pm_verb(int event)
 {
 	switch (event) {
+#ifdef CONFIG_ARCH_MP200
+	case DEV_SUSPEND_IDLE_1:
+		return "idle suspend";
+#endif
 	case PM_EVENT_SUSPEND:
 		return "suspend";
 	case PM_EVENT_RESUME:
@@ -262,8 +286,18 @@ static void pm_dev_dbg(struct device *dev, pm_message_t state, char *info)
 static void pm_dev_err(struct device *dev, pm_message_t state, char *info,
 			int error)
 {
+#ifdef CONFIG_ARCH_MP200
+	if (mp200_sleep_while_idle) {
+		printk(KERN_DEBUG "PM: Device %s failed to %s%s: error %d\n",
+		kobject_name(&dev->kobj), pm_verb(state.event), info, error);
+	} else {
+		printk(KERN_ERR "PM: Device %s failed to %s%s: error %d\n",
+		kobject_name(&dev->kobj), pm_verb(state.event), info, error);
+	}
+#else
 	printk(KERN_ERR "PM: Device %s failed to %s%s: error %d\n",
 		kobject_name(&dev->kobj), pm_verb(state.event), info, error);
+#endif
 }
 
 /*------------------------- Resume routines -------------------------*/
@@ -742,9 +776,23 @@ static int dpm_prepare(pm_message_t state)
 				put_device(dev);
 				continue;
 			}
+#ifdef CONFIG_ARCH_MP200
+			if (mp200_sleep_while_idle) {
+				printk(KERN_DEBUG
+					"PM: Failed to prepare device %s "
+					"for power transition: error %d\n",
+					kobject_name(&dev->kobj), error);
+			} else {
+				printk(KERN_ERR
+					"PM: Failed to prepare device %s "
+					"for power transition: error %d\n",
+					kobject_name(&dev->kobj), error);
+			}
+#else
 			printk(KERN_ERR "PM: Failed to prepare device %s "
 				"for power transition: error %d\n",
 				kobject_name(&dev->kobj), error);
+#endif
 			put_device(dev);
 			break;
 		}
@@ -772,6 +820,7 @@ int device_suspend(pm_message_t state)
 	error = dpm_prepare(state);
 	if (!error)
 		error = dpm_suspend(state);
+
 	return error;
 }
 EXPORT_SYMBOL_GPL(device_suspend);
@@ -779,9 +828,19 @@ EXPORT_SYMBOL_GPL(device_suspend);
 void __suspend_report_result(const char *function, void *fn, int ret)
 {
 	if (ret) {
+#ifdef CONFIG_ARCH_MP200
+		if (mp200_sleep_while_idle) {
+			printk(KERN_DEBUG "%s(): %d\n", function, ret);
+		} else {
+			printk(KERN_ERR "%s(): ", function);
+			print_fn_descriptor_symbol("%s returns ", fn);
+			printk("%d\n", ret);
+		}
+#else
 		printk(KERN_ERR "%s(): ", function);
 		print_fn_descriptor_symbol("%s returns ", fn);
 		printk("%d\n", ret);
+#endif
 	}
 }
 EXPORT_SYMBOL_GPL(__suspend_report_result);
diff --git a/include/linux/device.h b/include/linux/device.h
index be80aaa..4fa4433 100644
--- a/include/linux/device.h
+++ b/include/linux/device.h
@@ -25,6 +25,8 @@
 #include <asm/atomic.h>
 #include <asm/device.h>
 
+#define DEV_SUSPEND_IDLE_1 0x1000
+
 #define BUS_ID_SIZE		20
 
 struct device;
diff --git a/include/linux/pm.h b/include/linux/pm.h
index 4dcce54..8b51c79 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -145,7 +145,11 @@ typedef struct pm_message {
 struct pm_ops {
 	int (*prepare)(struct device *dev);
 	void (*complete)(struct device *dev);
+#ifdef CONFIG_ARCH_MP200
+	int (*suspend)(struct device *dev, pm_message_t state);
+#else
 	int (*suspend)(struct device *dev);
+#endif
 	int (*resume)(struct device *dev);
 	int (*freeze)(struct device *dev);
 	int (*thaw)(struct device *dev);
-- 
1.6.5.2

