From 9aba33d496a57b54a3c18dfea01efb8e1f27ed19 Mon Sep 17 00:00:00 2001
From: Kazuya Tsukamoto <kazuya.tsukamoto@necel.com>
Date: Mon, 9 Nov 2009 10:37:57 +0900
Subject: [PATCH 01/29] nec_em1: mach definition

Introduce the necel em1 machine type (mach-mp200).

Note: There is an issue with arch/arm/mach-mp200/mp200_board.c, since it
references the tsc2007 touch panel, but the tsc2007 driver is not in
this BSP.

Therefore, if you invalidate #ifdef CONFIG_MP200_EM1_DKIT and compile it,
please delete a description of tsc2007, or substitute a driver.

Signed-off-by: Kazuya Tsukamoto <kazuya.tsukamoto@necel.com>
---
 arch/arm/mach-mp200/Kconfig                      |   46 ++
 arch/arm/mach-mp200/Makefile                     |   14 +
 arch/arm/mach-mp200/Makefile.boot                |    3 +
 arch/arm/mach-mp200/clock.c                      |  231 ++++++++++
 arch/arm/mach-mp200/clock.h                      |  483 +++++++++++++++++++++
 arch/arm/mach-mp200/extio.c                      |  239 +++++++++++
 arch/arm/mach-mp200/generic.c                    |  288 +++++++++++++
 arch/arm/mach-mp200/generic.h                    |   32 ++
 arch/arm/mach-mp200/include/mach/em1_mem.h       |  143 +++++++
 arch/arm/mach-mp200/include/mach/em1_mem_qvga.h  |  145 +++++++
 arch/arm/mach-mp200/include/mach/em1_mem_wqvga.h |  150 +++++++
 arch/arm/mach-mp200/include/mach/entry-macro.S   |   77 ++++
 arch/arm/mach-mp200/include/mach/extio.h         |   42 ++
 arch/arm/mach-mp200/include/mach/hardware.h      |  428 +++++++++++++++++++
 arch/arm/mach-mp200/include/mach/io.h            |   53 +++
 arch/arm/mach-mp200/include/mach/irqs.h          |  492 ++++++++++++++++++++++
 arch/arm/mach-mp200/include/mach/memory.h        |   38 ++
 arch/arm/mach-mp200/include/mach/mp200_board.h   |   56 +++
 arch/arm/mach-mp200/include/mach/param.h         |   26 ++
 arch/arm/mach-mp200/include/mach/system.h        |   56 +++
 arch/arm/mach-mp200/include/mach/uncompress.h    |   52 +++
 arch/arm/mach-mp200/include/mach/vmalloc.h       |   32 ++
 arch/arm/mach-mp200/irq.c                        |  121 ++++++
 arch/arm/mach-mp200/irq.h                        |   31 ++
 arch/arm/mach-mp200/light.c                      |  129 ++++++
 arch/arm/mach-mp200/mp200_board.c                |  345 +++++++++++++++
 arch/arm/tools/mach-types                        |    2 +-
 drivers/leds/leds-gpio.c                         |    2 +
 28 files changed, 3755 insertions(+), 1 deletions(-)
 create mode 100644 arch/arm/mach-mp200/Kconfig
 create mode 100644 arch/arm/mach-mp200/Makefile
 create mode 100644 arch/arm/mach-mp200/Makefile.boot
 create mode 100644 arch/arm/mach-mp200/clock.c
 create mode 100644 arch/arm/mach-mp200/clock.h
 create mode 100644 arch/arm/mach-mp200/extio.c
 create mode 100644 arch/arm/mach-mp200/generic.c
 create mode 100644 arch/arm/mach-mp200/generic.h
 create mode 100644 arch/arm/mach-mp200/include/mach/em1_mem.h
 create mode 100644 arch/arm/mach-mp200/include/mach/em1_mem_qvga.h
 create mode 100644 arch/arm/mach-mp200/include/mach/em1_mem_wqvga.h
 create mode 100644 arch/arm/mach-mp200/include/mach/entry-macro.S
 create mode 100644 arch/arm/mach-mp200/include/mach/extio.h
 create mode 100644 arch/arm/mach-mp200/include/mach/hardware.h
 create mode 100644 arch/arm/mach-mp200/include/mach/io.h
 create mode 100644 arch/arm/mach-mp200/include/mach/irqs.h
 create mode 100644 arch/arm/mach-mp200/include/mach/memory.h
 create mode 100644 arch/arm/mach-mp200/include/mach/mp200_board.h
 create mode 100644 arch/arm/mach-mp200/include/mach/param.h
 create mode 100644 arch/arm/mach-mp200/include/mach/system.h
 create mode 100644 arch/arm/mach-mp200/include/mach/uncompress.h
 create mode 100644 arch/arm/mach-mp200/include/mach/vmalloc.h
 create mode 100644 arch/arm/mach-mp200/irq.c
 create mode 100644 arch/arm/mach-mp200/irq.h
 create mode 100644 arch/arm/mach-mp200/light.c
 create mode 100644 arch/arm/mach-mp200/mp200_board.c

diff --git a/arch/arm/mach-mp200/Kconfig b/arch/arm/mach-mp200/Kconfig
new file mode 100644
index 0000000..0c42083
--- /dev/null
+++ b/arch/arm/mach-mp200/Kconfig
@@ -0,0 +1,46 @@
+if ARCH_MP200
+
+menu "mp200 series EM1 Implementations"
+
+config MACH_MP200
+	bool
+	default y
+
+config MP200_EM1_DKIT
+	bool "Use EM1 Design Board"
+	default y
+	select NEW_LEDS
+	select LEDS_CLASS
+	select LEDS_GPIO
+	select INPUT_KEYBOARD
+	select KEYBOARD_MAX7324
+
+config MP200_L220
+	bool "ARM L2 cache Enable"
+	default y
+	select CACHE_L2X0
+
+config MP200_L220_WT
+	bool "ARM L2 cache WriteThrough"
+	depends on MP200_L220
+	default n
+
+config MP200_QR
+	bool "Enable Quick Recovery"
+	default y
+
+choice
+        prompt "Target board System clock(PLL3)"
+        default PLL3_230MHZ
+
+config PLL3_230MHZ
+        bool "230MHZ"
+
+config PLL3_238MHZ
+        bool "238MHZ"
+
+endchoice
+
+endmenu
+
+endif
diff --git a/arch/arm/mach-mp200/Makefile b/arch/arm/mach-mp200/Makefile
new file mode 100644
index 0000000..13fb73a
--- /dev/null
+++ b/arch/arm/mach-mp200/Makefile
@@ -0,0 +1,14 @@
+#
+# Makefile for the linux kernel.
+#
+
+# Common support
+obj-y	:= clock.o generic.o irq.o time.o dma.o
+obj-y	+= gpio.o pmu.o pm.o uwire.o pcm_irq.o
+obj-m	:= inter_dsp.o mp200_pdma.o
+
+# Specific board support
+obj-y	+= mp200_board.o
+
+obj-$(CONFIG_PM)				+= pm_pmu.o
+obj-$(CONFIG_MP200_EM1_DKIT)	+= extio.o light.o
diff --git a/arch/arm/mach-mp200/Makefile.boot b/arch/arm/mach-mp200/Makefile.boot
new file mode 100644
index 0000000..03c0aec
--- /dev/null
+++ b/arch/arm/mach-mp200/Makefile.boot
@@ -0,0 +1,3 @@
+   zreladdr-y		:= 0x30008000
+params_phys-y		:= 0x30000100
+initrd_phys-y		:= 0x36000000
diff --git a/arch/arm/mach-mp200/clock.c b/arch/arm/mach-mp200/clock.c
new file mode 100644
index 0000000..64025f7
--- /dev/null
+++ b/arch/arm/mach-mp200/clock.c
@@ -0,0 +1,231 @@
+/*
+ *  linux/arch/arm/mach-mp200/clock.c
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/list.h>
+#include <linux/errno.h>
+#include <linux/err.h>
+#include <linux/string.h>
+#include <linux/clk.h>
+#include <linux/mutex.h>
+#include <linux/io.h>
+
+#include <mach/pmu.h>
+
+#include "clock.h"
+
+static LIST_HEAD(clocks);
+static DEFINE_MUTEX(clocks_mutex);
+
+struct clk *clk_get(struct device *dev, const char *id)
+{
+	struct clk *p, *clk = ERR_PTR(-ENOENT);
+
+	mutex_lock(&clocks_mutex);
+	list_for_each_entry(p, &clocks, node) {
+		if (strcmp(id, p->name) == 0 && try_module_get(p->owner)) {
+			clk = p;
+			break;
+		}
+	}
+	mutex_unlock(&clocks_mutex);
+
+	return clk;
+}
+EXPORT_SYMBOL(clk_get);
+
+void clk_put(struct clk *clk)
+{
+	if (!clk)
+		return;
+	module_put(clk->owner);
+}
+EXPORT_SYMBOL(clk_put);
+
+int clk_enable(struct clk *clk)
+{
+	if (!clk)
+		return -EINVAL;
+
+	mp200_pmu_open_clockgate(clk->clk_bit);
+	if (clk->clkctrl_bit)
+		mp200_pmu_clkctrl_on(clk->clkctrl_bit);
+
+	return 0;
+}
+EXPORT_SYMBOL(clk_enable);
+
+void clk_disable(struct clk *clk)
+{
+	if (!clk)
+		return;
+
+	if (clk->clkctrl_bit)
+		mp200_pmu_clkctrl_off(clk->clkctrl_bit);
+	mp200_pmu_close_clockgate(clk->clk_bit);
+}
+EXPORT_SYMBOL(clk_disable);
+
+unsigned long clk_get_rate(struct clk *clk)
+{
+	if (!clk)
+		return -EINVAL;
+
+	if (clk->div_reg)
+		return inl(clk->div_reg);
+	else
+		return -EINVAL;
+}
+EXPORT_SYMBOL(clk_get_rate);
+
+int clk_set_rate(struct clk *clk, unsigned long rate)
+{
+	if (!clk)
+		return -EINVAL;
+
+	if (clk->div_reg) {
+		outl(rate, clk->div_reg);
+		return 0;
+	} else {
+		return -EINVAL;
+	}
+}
+EXPORT_SYMBOL(clk_set_rate);
+
+int clk_register(struct clk *clk)
+{
+	if (!clk)
+		return -EINVAL;
+
+	mutex_lock(&clocks_mutex);
+	list_add(&clk->node, &clocks);
+	mutex_unlock(&clocks_mutex);
+	return 0;
+}
+EXPORT_SYMBOL(clk_register);
+
+void clk_unregister(struct clk *clk)
+{
+	if (!clk)
+		return;
+
+	mutex_lock(&clocks_mutex);
+	list_del(&clk->node);
+	mutex_unlock(&clocks_mutex);
+}
+EXPORT_SYMBOL(clk_unregister);
+
+int __init clk_init(void)
+{
+	clk_register(&clk_dma_tclk);
+	clk_register(&clk_dma_pch3);
+	clk_register(&clk_dma_pch2);
+	clk_register(&clk_dma_pch0);
+	clk_register(&clk_dma_pclk);
+
+	clk_register(&clk_imc_pclk);
+	clk_register(&clk_imc);
+
+	clk_register(&clk_ipu_ahb);
+	clk_register(&clk_ipu_dma_pclk);
+	clk_register(&clk_ipu_dma);
+	clk_register(&clk_rot_pclk);
+	clk_register(&clk_rot);
+	clk_register(&clk_img_pclk);
+	clk_register(&clk_img_2);
+	clk_register(&clk_img_1);
+
+	clk_register(&clk_pdma_pclk);
+	clk_register(&clk_pdma_hclk);
+	clk_register(&clk_pdma_aclk);
+
+	clk_register(&clk_dsp_aclk);
+	clk_register(&clk_dsp);
+
+	clk_register(&clk_avc_hsclk);
+	clk_register(&clk_avc_hmclk);
+	clk_register(&clk_avc_clkm);
+	clk_register(&clk_avc_clke);
+	clk_register(&clk_avc_clkd);
+	clk_register(&clk_avc_clkc);
+
+	clk_register(&clk_dcv_pclk);
+	clk_register(&clk_dcv);
+
+	clk_register(&clk_lcd_cclk);
+	clk_register(&clk_lcd_lclk);
+	clk_register(&clk_lcd_pclk);
+	clk_register(&clk_lcd);
+
+	clk_register(&clk_dtv_pclk);
+	clk_register(&clk_dtv);
+
+	clk_register(&clk_nts_pclk);
+	clk_register(&clk_nts);
+
+	clk_register(&clk_nand_pclk);
+	clk_register(&clk_nand_hclk);
+
+	clk_register(&clk_cam_sclk);
+	clk_register(&clk_cam_pclk);
+	clk_register(&clk_cam_clk);
+
+	clk_register(&clk_pcm1_sclk);
+	clk_register(&clk_pcm0_sclk);
+	clk_register(&clk_pcm_pclk);
+	clk_register(&clk_pcm0_clk);
+	clk_register(&clk_pcm1_clk);
+
+	clk_register(&clk_usb);
+	clk_register(&clk_sdia);
+	clk_register(&clk_sdib);
+	clk_register(&clk_sdic);
+
+	clk_register(&clk_uart2);
+	clk_register(&clk_uart1);
+	clk_register(&clk_uart0);
+	clk_register(&clk_uart);
+
+	clk_register(&clk_i2c_sclk);
+	clk_register(&clk_i2c2_sclk);
+	clk_register(&clk_i2c);
+	clk_register(&clk_i2c2);
+
+	clk_register(&clk_pwm_pwclk1);
+	clk_register(&clk_pwm_pwclk0);
+	clk_register(&clk_pwm_pclk);
+
+	clk_register(&clk_spi2_sclk);
+	clk_register(&clk_spi2_pclk);
+	clk_register(&clk_spi1_sclk);
+	clk_register(&clk_spi1_pclk);
+	clk_register(&clk_spi0_sclk);
+	clk_register(&clk_spi0_pclk);
+
+	clk_register(&clk_mwi_sclk);
+	clk_register(&clk_mwi_pclk);
+
+	clk_register(&clk_tim);
+	clk_register(&clk_tw3);
+	clk_register(&clk_tw2);
+	clk_register(&clk_tw1);
+	clk_register(&clk_tw0);
+	clk_register(&clk_tg5);
+	clk_register(&clk_tg4);
+	clk_register(&clk_tg3);
+	clk_register(&clk_tg2);
+	clk_register(&clk_tg1);
+	clk_register(&clk_tg0);
+	clk_register(&clk_timer3);
+	clk_register(&clk_timer2);
+	clk_register(&clk_timer1);
+	clk_register(&clk_timer0);
+
+	return 0;
+}
diff --git a/arch/arm/mach-mp200/clock.h b/arch/arm/mach-mp200/clock.h
new file mode 100644
index 0000000..c2fbe84
--- /dev/null
+++ b/arch/arm/mach-mp200/clock.h
@@ -0,0 +1,483 @@
+/*
+ *  linux/arch/arm/mach-mp200/clock.h
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __ARCH_ARM_MACH_MP200_CLOCK_H
+#define __ARCH_ARM_MACH_MP200_CLOCK_H
+
+#include <mach/smu.h>
+
+struct module;
+
+struct clk {
+	struct list_head  node;
+	struct module    *owner;
+	const char       *name;
+	__u32             clk_bit;
+	__u32             clkctrl_bit;
+	__u32             div_reg;
+};
+
+/* DMA */
+static struct clk clk_dma_tclk = {
+	.name        = "dma_tclk",
+	.clk_bit     = MP200_CLOCKGATE_DMA_TCLK,
+	.div_reg     = SMU_DIVDMATCLK,
+};
+static struct clk clk_dma_pch3 = {
+	.name        = "dma_pch3",
+	.clk_bit     = MP200_CLOCKGATE_DMA_PCH3_CLK,
+	.clkctrl_bit = MP200_CLKCTRL_DMAPCH3,
+};
+static struct clk clk_dma_pch2 = {
+	.name        = "dma_pch2",
+	.clk_bit     = MP200_CLOCKGATE_DMA_PCH2_CLK,
+	.clkctrl_bit = MP200_CLKCTRL_DMAPCH2,
+};
+static struct clk clk_dma_pch0 = {
+	.name        = "dma_pch0",
+	.clk_bit     = MP200_CLOCKGATE_DMA_PCH0_CLK,
+	.clkctrl_bit = MP200_CLKCTRL_DMAPCH0,
+};
+static struct clk clk_dma_pclk = {
+	.name        = "dma_pclk",
+	.clk_bit     = MP200_CLOCKGATE_DMA_PCLK,
+	.clkctrl_bit = MP200_CLKCTRL_DMAPCLK,
+};
+
+/* IMC */
+static struct clk clk_imc_pclk = {
+	.name        = "imc_pclk",
+	.clk_bit     = MP200_CLOCKGATE_IMC_PCLK,
+	.clkctrl_bit = MP200_CLKCTRL_IMCPCLK,
+};
+static struct clk clk_imc = {
+	.name        = "imc",
+	.clk_bit     = MP200_CLOCKGATE_IMC_CLK,
+	.clkctrl_bit = MP200_CLKCTRL_IMC,
+};
+
+/* IPU */
+static struct clk clk_ipu_ahb = {
+	.name        = "ipu_ahb",
+	.clk_bit     = MP200_CLOCKGATE_IPUAHB_CLK,
+	.clkctrl_bit = MP200_CLKCTRL_IPUAHB,
+};
+static struct clk clk_ipu_dma_pclk = {
+	.name        = "ipu_dma_pclk",
+	.clk_bit     = MP200_CLOCKGATE_IPUDMA_PCLK,
+	.clkctrl_bit = MP200_CLKCTRL_IPUDMA,
+};
+static struct clk clk_ipu_dma = {
+	.name        = "ipu_dma",
+	.clk_bit     = MP200_CLOCKGATE_IPUDMA_CLK,
+	.clkctrl_bit = MP200_CLKCTRL_IPUDMACLK,
+};
+static struct clk clk_rot_pclk = {
+	.name        = "rot_pclk",
+	.clk_bit     = MP200_CLOCKGATE_ROT_PCLK,
+	.clkctrl_bit = MP200_CLKCTRL_IPUROTPCLK,
+};
+static struct clk clk_rot = {
+	.name        = "rot",
+	.clk_bit     = MP200_CLOCKGATE_ROT_CLK,
+	.clkctrl_bit = MP200_CLKCTRL_IPUROT,
+};
+static struct clk clk_img_pclk = {
+	.name        = "ipu_img_pclk",
+	.clk_bit     = MP200_CLOCKGATE_IMG_PCLK,
+	.clkctrl_bit = MP200_CLKCTRL_IPUIMGPCLK,
+};
+static struct clk clk_img_2 = {
+	.name        = "img_2",
+	.clk_bit     = MP200_CLOCKGATE_IMG_2_CLK,
+	.clkctrl_bit = MP200_CLKCTRL_IPUIMG2,
+};
+static struct clk clk_img_1 = {
+	.name        = "img_1",
+	.clk_bit     = MP200_CLOCKGATE_IMG_1_CLK,
+	.clkctrl_bit = MP200_CLKCTRL_IPUIMG1,
+};
+
+static struct clk clk_pdma_pclk = {
+	.name        = "pdma_pclk",
+	.clk_bit     = MP200_CLOCKGATE_PDMA_PCLK,
+	.clkctrl_bit = MP200_CLKCTRL_PDMAPCLK,
+};
+static struct clk clk_pdma_hclk = {
+	.name        = "pdma_hclk",
+	.clk_bit     = MP200_CLOCKGATE_PDMA_HCLK,
+	.clkctrl_bit = MP200_CLKCTRL_PDMAHCK,
+};
+static struct clk clk_pdma_aclk = {
+	.name        = "pdma_aclk",
+	.clk_bit     = MP200_CLOCKGATE_PDMA_ACLK,
+	.clkctrl_bit = MP200_CLKCTRL_PDMAACK,
+};
+
+
+/* DSP */
+static struct clk clk_dsp_aclk = {
+	.name        = "dsp_aclk",
+	.clk_bit     = MP200_CLOCKGATE_DSP_ACLK,
+};
+static struct clk clk_dsp = {
+	.name        = "dsp",
+	.clk_bit     = MP200_CLOCKGATE_DSP_CLK,
+	.clkctrl_bit = MP200_CLKCTRL_ADSP,
+};
+
+/* AVC */
+static struct clk clk_avc_hsclk = {
+	.name        = "avc_hsclk",
+	.clk_bit     = MP200_CLOCKGATE_AVC_HSCLK,
+	.clkctrl_bit = MP200_CLKCTRL_AVCHSCK,
+};
+static struct clk clk_avc_hmclk = {
+	.name        = "avc_hmclk",
+	.clk_bit     = MP200_CLOCKGATE_AVC_HMCLK,
+	.clkctrl_bit = MP200_CLKCTRL_AVCHMCK,
+};
+static struct clk clk_avc_clkm = {
+	.name        = "avc_clkm",
+	.clk_bit     = MP200_CLOCKGATE_AVC_CLKM,
+	.clkctrl_bit = MP200_CLKCTRL_AVCCKM,
+};
+static struct clk clk_avc_clke = {
+	.name        = "avc_clke",
+	.clk_bit     = MP200_CLOCKGATE_AVC_CLKE,
+	.clkctrl_bit = MP200_CLKCTRL_AVCCKE,
+};
+static struct clk clk_avc_clkd = {
+	.name        = "avc_clkd",
+	.clk_bit     = MP200_CLOCKGATE_AVC_CLKD,
+	.clkctrl_bit = MP200_CLKCTRL_AVCCKD,
+};
+static struct clk clk_avc_clkc = {
+	.name        = "avc_clkc",
+	.clk_bit     = MP200_CLOCKGATE_AVC_CLKC,
+	.clkctrl_bit = MP200_CLKCTRL_AVCCKC,
+};
+
+/* DCV */
+static struct clk clk_dcv_pclk = {
+	.name        = "dcv_pclk",
+	.clk_bit     = MP200_CLOCKGATE_DCV_PCLK,
+	.clkctrl_bit = MP200_CLKCTRL_DCVPCLK,
+};
+static struct clk clk_dcv = {
+	.name        = "dcv",
+	.clk_bit     = MP200_CLOCKGATE_DCV_CLK,
+};
+
+/* LCD */
+static struct clk clk_lcd_cclk = {
+	.name        = "lcd_cclk",
+	.clk_bit     = MP200_CLOCKGATE_LCD_CCLK,
+	.clkctrl_bit = MP200_CLKCTRL_LCDCCK,
+};
+static struct clk clk_lcd_lclk = {
+	.name        = "lcd_lclk",
+	.clk_bit     = MP200_CLOCKGATE_LCD_LCLK,
+	.div_reg     = SMU_DIVLCDLCLK,
+};
+static struct clk clk_lcd_pclk = {
+	.name        = "lcd_pclk",
+	.clk_bit     = MP200_CLOCKGATE_LCD_PCLK,
+	.clkctrl_bit = MP200_CLKCTRL_LCDPCLK,
+};
+static struct clk clk_lcd = {
+	.name        = "lcd",
+	.clk_bit     = MP200_CLOCKGATE_LCD_CLK,
+	.clkctrl_bit = MP200_CLKCTRL_LCD,
+};
+
+
+/* DTV */
+static struct clk clk_dtv_pclk = {
+	.name        = "dtv_pclk",
+	.clk_bit     = MP200_CLOCKGATE_DTV_PCLK,
+	.clkctrl_bit = MP200_CLKCTRL_DTVPCLK,
+};
+static struct clk clk_dtv = {
+	.name        = "dtv",
+	.clk_bit     = MP200_CLOCKGATE_DTV_CLK,
+	.clkctrl_bit = MP200_CLKCTRL_DTV,
+};
+
+/* NTS */
+static struct clk clk_nts_pclk = {
+	.name        = "nts",
+	.clk_bit     = MP200_CLOCKGATE_NTS_PCLK,
+	.clkctrl_bit = MP200_CLKCTRL_NTSPCLK,
+};
+static struct clk clk_nts = {
+	.name        = "nts",
+	.clk_bit     = MP200_CLOCKGATE_NTS_CLK,
+	.clkctrl_bit = MP200_CLKCTRL_NTS,
+};
+
+/* NAND */
+static struct clk clk_nand_pclk = {
+	.name        = "nand_pclk",
+	.clk_bit     = MP200_CLOCKGATE_NAND_PCLK,
+	.clkctrl_bit = MP200_CLKCTRL_NANDPCLK,
+};
+static struct clk clk_nand_hclk = {
+	.name        = "nand_hclk",
+	.clk_bit     = MP200_CLOCKGATE_NAND_HCLK,
+	.clkctrl_bit = MP200_CLKCTRL_NAND,
+};
+
+/* CAM */
+static struct clk clk_cam_sclk  = {
+	.name        = "cam_sclk",
+	.clk_bit     = MP200_CLOCKGATE_CAM_SCLK,
+};
+static struct clk clk_cam_pclk  = {
+	.name        = "cam_pclk",
+	.clk_bit     = MP200_CLOCKGATE_CAM_PCLK,
+	.clkctrl_bit = MP200_CLKCTRL_CAMPCLK,
+};
+static struct clk clk_cam_clk  = {
+	.name        = "cam_clk",
+	.clk_bit     = MP200_CLOCKGATE_CAM_CLK,
+	.clkctrl_bit = MP200_CLKCTRL_CAM,
+};
+
+/* PCM */
+static struct clk clk_pcm1_sclk = {
+	.name        = "pcm1_sclk",
+	.clk_bit     = MP200_CLOCKGATE_PM1_SCLK,
+	.div_reg     = SMU_DIVPM1SCLK,
+};
+static struct clk clk_pcm0_sclk = {
+	.name        = "pcm0_sclk",
+	.clk_bit     = MP200_CLOCKGATE_PM0_SCLK,
+	.div_reg     = SMU_DIVPM0SCLK,
+};
+static struct clk clk_pcm_pclk = {
+	.name        = "pcm",
+	.clk_bit     = MP200_CLOCKGATE_PM0_PCLK,
+};
+
+static struct clk clk_pcm0_clk = {
+	.name        = "pcm0_clk",
+	.clk_bit     = MP200_CLOCKGATE_PM0_CLK,
+	.clkctrl_bit = MP200_CLKCTRL_PM0PCLK,
+};
+static struct clk clk_pcm1_clk = {
+	.name        = "pcm1_clk",
+	.clk_bit     = MP200_CLOCKGATE_PM1_CLK,
+	.clkctrl_bit = MP200_CLKCTRL_PM1PCLK,
+};
+
+
+
+/* USB */
+static struct clk clk_usb = {
+	.name        = "usb",
+	.clk_bit     = MP200_CLOCKGATE_USB_CLK,
+};
+
+/* SDM */
+static struct clk clk_sdia = {
+	.name        = "sdia",
+	.clk_bit     = MP200_CLOCKGATE_SDIA_CLK,
+};
+static struct clk clk_sdib = {
+	.name        = "sdib",
+	.clk_bit     = MP200_CLOCKGATE_SDIB_CLK,
+};
+static struct clk clk_sdic = {
+	.name        = "sdic",
+	.clk_bit     = MP200_CLOCKGATE_SDIC_CLK,
+};
+
+/* UART */
+static struct clk clk_uart2 = {
+	.name        = "uart2",
+	.clk_bit     = MP200_CLOCKGATE_U72_SCLK,
+	.div_reg     = SMU_DIVU72SCLK,
+};
+static struct clk clk_uart1 = {
+	.name        = "uart1",
+	.clk_bit     = MP200_CLOCKGATE_U71_SCLK,
+	.div_reg     = SMU_DIVU71SCLK,
+};
+static struct clk clk_uart0 = {
+	.name        = "uart0",
+	.clk_bit     = MP200_CLOCKGATE_U70_SCLK,
+	.div_reg     = SMU_DIVU70SCLK,
+};
+static struct clk clk_uart = {
+	.name        = "uart",
+	.clk_bit     = MP200_CLOCKGATE_U70_CLK,
+};
+
+/* I2C */
+static struct clk clk_i2c_sclk = {
+	.name        = "i2c_sclk",
+	.clk_bit     = MP200_CLOCKGATE_IIC_SCLK,
+	.div_reg     = SMU_DIVIICSCLK,
+};
+static struct clk clk_i2c = {
+	.name        = "i2c",
+	.clk_bit     = MP200_CLOCKGATE_IIC_CLK,
+};
+static struct clk clk_i2c2_sclk = {
+	.name        = "i2c2_sclk",
+	.clk_bit     = MP200_CLOCKGATE_IIC2_SCLK,
+	.div_reg     = SMU_DIVIICSCLK,
+};
+static struct clk clk_i2c2 = {
+	.name        = "i2c2",
+	.clk_bit     = MP200_CLOCKGATE_IIC2_CLK,
+};
+
+/* PWM */
+static struct clk clk_pwm_pwclk1 = {
+	.name        = "pwm_pwclk1",
+	.clk_bit     = MP200_CLOCKGATE_PWM_PWCLK1,
+};
+static struct clk clk_pwm_pwclk0 = {
+	.name        = "pwm_pwclk0",
+	.clk_bit     = MP200_CLOCKGATE_PWM_PWCLK0,
+};
+static struct clk clk_pwm_pclk = {
+	.name        = "pwm_pclk",
+	.clk_bit     = MP200_CLOCKGATE_PWM_PCLK,
+	.clkctrl_bit = MP200_CLKCTRL_PWMPCLK,
+};
+
+/* SPI */
+static struct clk clk_spi2_sclk = {
+	.name        = "spi2_sclk",
+	.clk_bit     = MP200_CLOCKGATE_SP2_SCLK,
+	.clkctrl_bit = MP200_CLKCTRL_SP2SCLK,
+	.div_reg     = SMU_DIVSP2SCLK,
+};
+static struct clk clk_spi2_pclk = {
+	.name        = "spi2_pclk",
+	.clk_bit     = MP200_CLOCKGATE_SP2_PCLK,
+	.clkctrl_bit = MP200_CLKCTRL_SP2PCLK,
+};
+static struct clk clk_spi1_sclk = {
+	.name        = "spi1_sclk",
+	.clk_bit     = MP200_CLOCKGATE_SP1_SCLK,
+	.clkctrl_bit = MP200_CLKCTRL_SP1SCLK,
+	.div_reg     = SMU_DIVSP1SCLK,
+};
+static struct clk clk_spi1_pclk = {
+	.name        = "spi1_pclk",
+	.clk_bit     = MP200_CLOCKGATE_SP1_PCLK,
+	.clkctrl_bit = MP200_CLKCTRL_SP1PCLK,
+};
+static struct clk clk_spi0_sclk = {
+	.name        = "spi0_sclk",
+	.clk_bit     = MP200_CLOCKGATE_SP0_SCLK,
+	.clkctrl_bit = MP200_CLKCTRL_SP0SCLK,
+	.div_reg     = SMU_DIVSP0SCLK,
+};
+static struct clk clk_spi0_pclk = {
+	.name        = "spi0_pclk",
+	.clk_bit     = MP200_CLOCKGATE_SP0_PCLK,
+	.clkctrl_bit = MP200_CLKCTRL_SP0PCLK,
+};
+
+/* MWI(uWire) */
+static struct clk clk_mwi_sclk = {
+	.name        = "mwi_sclk",
+	.clk_bit     = MP200_CLOCKGATE_MWI_SCLK,
+	.div_reg     = SMU_DIVMWISCLK,
+};
+static struct clk clk_mwi_pclk = {
+	.name        = "mwi_pclk",
+	.clk_bit     = MP200_CLOCKGATE_MWI_PCLK,
+	.clkctrl_bit = MP200_CLKCTRL_MWIPCLK,
+};
+
+/* TIMER */
+static struct clk clk_tim = {
+	.name        = "tim",
+	.clk_bit     = MP200_CLOCKGATE_ATIM_PCLK,
+	.clkctrl_bit = MP200_CLKCTRL_TIMPCLK,
+	.div_reg     = SMU_DIVTIMTIN,
+};
+static struct clk clk_tw3 = {
+	.name        = "WDT3",
+	.clk_bit     = MP200_CLOCKGATE_TW3_TIN,
+	.div_reg     = SMU_TI3TIN_SEL,
+};
+static struct clk clk_tw2 = {
+	.name        = "WDT2",
+	.clk_bit     = MP200_CLOCKGATE_TW2_TIN,
+	.div_reg     = SMU_TI2TIN_SEL,
+};
+static struct clk clk_tw1 = {
+	.name        = "WDT1",
+	.clk_bit     = MP200_CLOCKGATE_TW1_TIN,
+	.div_reg     = SMU_TI1TIN_SEL,
+};
+static struct clk clk_tw0 = {
+	.name        = "WDT0",
+	.clk_bit     = MP200_CLOCKGATE_TW0_TIN,
+	.div_reg     = SMU_TI0TIN_SEL,
+};
+static struct clk clk_tg5 = {
+	.name        = "GPT5",
+	.clk_bit     = MP200_CLOCKGATE_TG5_TIN,
+	.div_reg     = SMU_TGNTIN_SEL,
+};
+static struct clk clk_tg4 = {
+	.name        = "GPT4",
+	.clk_bit     = MP200_CLOCKGATE_TG4_TIN,
+	.div_reg     = SMU_TGNTIN_SEL,
+};
+static struct clk clk_tg3 = {
+	.name        = "GPT3",
+	.clk_bit     = MP200_CLOCKGATE_TG3_TIN,
+	.div_reg     = SMU_TGNTIN_SEL,
+};
+static struct clk clk_tg2 = {
+	.name        = "GPT2",
+	.clk_bit     = MP200_CLOCKGATE_TG2_TIN,
+	.div_reg     = SMU_TGNTIN_SEL,
+};
+static struct clk clk_tg1 = {
+	.name        = "GPT1",
+	.clk_bit     = MP200_CLOCKGATE_TG1_TIN,
+	.div_reg     = SMU_TGNTIN_SEL,
+};
+static struct clk clk_tg0 = {
+	.name        = "GPT0",
+	.clk_bit     = MP200_CLOCKGATE_TG0_TIN,
+	.div_reg     = SMU_TGNTIN_SEL,
+};
+static struct clk clk_timer3 = {
+	.name        = "timer3",
+	.clk_bit     = MP200_CLOCKGATE_TI3_TIN,
+	.div_reg     = SMU_TI3TIN_SEL,
+};
+static struct clk clk_timer2 = {
+	.name        = "timer2",
+	.clk_bit     = MP200_CLOCKGATE_TI2_TIN,
+	.div_reg     = SMU_TI2TIN_SEL,
+};
+static struct clk clk_timer1 = {
+	.name        = "timer1",
+	.clk_bit     = MP200_CLOCKGATE_TI1_TIN,
+	.div_reg     = SMU_TI1TIN_SEL,
+};
+static struct clk clk_timer0 = {
+	.name        = "timer0",
+	.clk_bit     = MP200_CLOCKGATE_TI0_TIN,
+	.div_reg     = SMU_TI0TIN_SEL,
+};
+
+
+#endif /* __ARCH_ARM_MACH_MP200_CLOCK_H */
diff --git a/arch/arm/mach-mp200/extio.c b/arch/arm/mach-mp200/extio.c
new file mode 100644
index 0000000..d3a9a1b
--- /dev/null
+++ b/arch/arm/mach-mp200/extio.c
@@ -0,0 +1,239 @@
+/*
+ *  File Name       : linux/arch/arm/mach-mp200/extio.c
+ *  Function        : External GPIO
+ *  Release Version : Ver 1.00
+ *  Release Date    : 2009/06/11
+ *
+ *  Copyright (C) NEC Electronics Corporation 2009
+ *
+ *
+ *  This program is free software;you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License as published by Free
+ *  Softwere Foundation; either version 2 of License, or (at your option) any
+ *  later version.
+ *
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warrnty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; If not, write to the Free Software Foundation, Inc., 59
+ *  Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/i2c.h>
+
+#include <linux/gpio.h>
+#include <mach/extio.h>
+
+#define EXTIO_OUT_INITDATA	0xff
+
+static struct mutex	extio_lock;
+
+int mp200_extio_initialized;
+
+static struct i2c_client *mp200_extio_client_in;
+static struct i2c_client *mp200_extio_client_out;
+static unsigned char extio_out_data;
+
+
+int extio_reg_read(int addr, unsigned char *data)
+{
+	int ret;
+
+	if (mp200_extio_initialized == 0)
+		return -EBUSY;
+
+	if (addr == EXTIO_OUT) {
+		mutex_lock(&extio_lock);
+		ret = extio_out_data;
+		mutex_unlock(&extio_lock);
+	} else {
+		ret = i2c_smbus_read_byte(mp200_extio_client_in);
+		if (ret < 0) {
+			printk(KERN_ERR "%s: failed reading\n", __func__);
+			return ret;
+		}
+	}
+	*data = (unsigned char)ret;
+	return 0;
+}
+EXPORT_SYMBOL(extio_reg_read);
+
+int extio_reg_write(int addr, unsigned char data)
+{
+	int ret;
+
+	if (mp200_extio_initialized == 0)
+		return -EBUSY;
+
+	if (addr == EXTIO_OUT) {
+		mutex_lock(&extio_lock);
+		ret = i2c_smbus_write_byte(mp200_extio_client_out, data);
+		if (ret < 0) {
+			printk(KERN_ERR "%s: failed writing\n", __func__);
+			mutex_unlock(&extio_lock);
+			return ret;
+		} else {
+			extio_out_data = data;
+		}
+		mutex_unlock(&extio_lock);
+	} else {
+		return -EINVAL;
+	}
+	return 0;
+}
+EXPORT_SYMBOL(extio_reg_write);
+
+int extio_read(int addr, unsigned char *data)
+{
+	return extio_reg_read(addr, data);
+}
+
+int extio_write(int addr, unsigned char data, unsigned char mask)
+{
+	int ret;
+	unsigned char tmp_data;
+
+	if (mp200_extio_initialized == 0)
+		return -EBUSY;
+
+	if (addr == EXTIO_OUT) {
+		mutex_lock(&extio_lock);
+		tmp_data = extio_out_data;
+		tmp_data = (tmp_data & (~mask)) | (data & mask);
+		ret = i2c_smbus_write_byte(mp200_extio_client_out, tmp_data);
+		if (ret < 0) {
+			printk(KERN_ERR "%s: failed writing\n", __func__);
+			mutex_unlock(&extio_lock);
+			return ret;
+		} else {
+			extio_out_data = tmp_data;
+		}
+		mutex_unlock(&extio_lock);
+	} else {
+		return -EINVAL;
+	}
+	return 0;
+}
+
+int extio_set_direction(unsigned gpio, int is_input)
+{
+	if (is_input) {
+		if (gpio >= GPIO_EXT2_P0 && gpio <= GPIO_EXT2_P7)
+			return 0;
+	} else {
+		if (gpio >= GPIO_EXT2_P8 && gpio <= GPIO_EXT2_P15)
+			return 0;
+	}
+	return -EINVAL;
+}
+EXPORT_SYMBOL(extio_set_direction);
+
+int extio_get_value(unsigned int gpio)
+{
+	unsigned char val;
+	unsigned int off;
+	int ret = 0;
+
+	if (mp200_extio_initialized == 0)
+		return -EBUSY;
+
+	if (gpio >= GPIO_EXT2_P0 && gpio <= GPIO_EXT2_P7) {
+		off = gpio - GPIO_EXT2_P0;
+		ret = extio_reg_read(EXTIO_IN, &val);
+	} else if (gpio >= GPIO_EXT2_P8 && gpio <= GPIO_EXT2_P15) {
+		off = gpio - GPIO_EXT2_P8;
+		val = extio_out_data;
+	} else {
+		return -EINVAL;
+	}
+
+	return ret ? ret : (val & (1u << off));
+}
+EXPORT_SYMBOL(extio_get_value);
+
+void extio_set_value(unsigned int gpio, int value)
+{
+	unsigned int off;
+	unsigned char val, mask;
+	int ret = 0;
+
+	if (mp200_extio_initialized == 0)
+		return;
+
+	if (gpio >= GPIO_EXT2_P8 && gpio <= GPIO_EXT2_P15) {
+		mutex_lock(&extio_lock);
+		off = gpio - GPIO_EXT2_P8;
+		mask = 1u << (off & 0x7);
+		val = extio_out_data;
+		val = (value) ? val | mask : val & ~mask;
+		ret = i2c_smbus_write_byte(mp200_extio_client_out, val);
+		if (ret == 0)
+			extio_out_data = val;
+		mutex_unlock(&extio_lock);
+	}
+}
+EXPORT_SYMBOL(extio_set_value);
+
+static int
+mp200_extio_probe(struct i2c_client *client, const struct i2c_device_id *id)
+{
+	if ((client->addr & 0x70) == 0x60) {
+		if (!i2c_check_functionality(client->adapter,
+					     I2C_FUNC_SMBUS_READ_BYTE_DATA)) {
+			return -EIO;
+		}
+		mp200_extio_client_in = client;
+	} else {
+		if (!i2c_check_functionality(client->adapter,
+					     I2C_FUNC_SMBUS_WRITE_BYTE_DATA)) {
+			return -EIO;
+		}
+		mp200_extio_client_out = client;
+		extio_out_data = EXTIO_OUT_INITDATA;
+		i2c_smbus_write_byte(mp200_extio_client_out, extio_out_data);
+	}
+
+	if (mp200_extio_client_in != NULL && mp200_extio_client_out != NULL) {
+		mp200_extio_initialized = 1;
+		mutex_init(&extio_lock);
+	}
+
+	return 0;
+}
+
+static int mp200_extio_remove(struct i2c_client *client)
+{
+	mp200_extio_initialized = 0;
+	return 0;
+}
+
+static struct i2c_device_id mp200_extio_idtable[] = {
+	{ "max7324_w", 0 },
+	{ "max7324_r", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, mp200_extio_idtable);
+
+static struct i2c_driver mp200_extio_driver = {
+	.driver = {
+		.name	= "mp200-extio",
+		.owner	= THIS_MODULE,
+	},
+	.id_table	= mp200_extio_idtable,
+	.probe		= mp200_extio_probe,
+	.remove		= __devexit_p(mp200_extio_remove),
+};
+
+static int __init mp200_extio_init(void)
+{
+	return i2c_add_driver(&mp200_extio_driver);
+}
+
+device_initcall(mp200_extio_init);
diff --git a/arch/arm/mach-mp200/generic.c b/arch/arm/mach-mp200/generic.c
new file mode 100644
index 0000000..3a02e12
--- /dev/null
+++ b/arch/arm/mach-mp200/generic.c
@@ -0,0 +1,288 @@
+/*
+ *  File Name       : linux/arch/arm/mach-mp200/generic.c
+ *  Function        : generic
+ *  Release Version : Ver 1.30
+ *  Release Date    : 2009/03/18
+ *
+ *  Copyright (C) NEC Electronics Corporation 2005-2009
+ *
+ *
+ *  This program is free software;you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License as published by Free
+ *  Softwere Foundation; either version 2 of License, or (at your option) any
+ *  later version.
+ *
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warrnty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; If not, write to the Free Software Foundation, Inc., 59
+ *  Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#include <linux/sched.h>
+#include <linux/mm.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/serial_8250.h>
+#include <linux/serial_reg.h>
+
+#include <linux/io.h>
+#include <asm/pgtable.h>
+#include <asm/page.h>
+#include <asm/mach/map.h>
+
+#include <mach/hardware.h>
+
+#include <mach/pmu.h>
+#include <mach/smu.h>
+
+#include "generic.h"
+
+/*
+ * Common MP200 I/O Mapping
+ *
+ * Logical      Physical
+ * e4000000	40000000	APB0
+ * e5000000	50000000	ASYNC1
+ * e6000000	60000000	AHB Slave
+ * e8000000	80000000	Local
+ * ec000000	c0000000	APB1
+ */
+
+static struct map_desc standard_io_desc[] __initdata = {
+	/* BANK 2 */
+	MP200_MAP_DESC(MP200_AB0_BASE, MP200_AB0_SIZE),
+
+	/* BANK 4 */
+	MP200_MAP_DESC(MP200_ROTATOR_BASE,   MP200_ROTATOR_SIZE),
+	MP200_MAP_DESC(MP200_DMAC_BASE,      MP200_DMAC_SIZE),
+	MP200_MAP_DESC(MP200_IMAGEPROC_BASE, MP200_IMAGEPROC_SIZE),
+	MP200_MAP_DESC(MP200_CAMERA_BASE,    MP200_CAMERA_SIZE),
+	MP200_MAP_DESC(MP200_PCM0_BASE,      MP200_PCM0_SIZE),
+	MP200_MAP_DESC(MP200_PCM1_BASE,      MP200_PCM1_SIZE),
+	MP200_MAP_DESC(MP200_PWM_BASE,       MP200_PWM_SIZE),
+	MP200_MAP_DESC(MP200_SP2_BASE,       MP200_SP2_SIZE),
+	MP200_MAP_DESC(MP200_DTV_BASE,       MP200_DTV_SIZE),
+	MP200_MAP_DESC(MP200_DBG_BASE,       MP200_DBG_SIZE),
+	MP200_MAP_DESC(MP200_NTSC_BASE,      MP200_NTSC_SIZE),
+	MP200_MAP_DESC(MP200_NAND_BASE,      MP200_NAND_SIZE),
+	MP200_MAP_DESC(MP200_IPUDMA_BASE,    MP200_IPUDMA_SIZE),
+	MP200_MAP_DESC(MP200_IMC_BASE,       MP200_IMC_SIZE),
+	MP200_MAP_DESC(MP200_LCD_BASE,       MP200_LCD_SIZE),
+
+	/* BANK5 */
+	MP200_MAP_DESC(MP200_UART0_BASE,  MP200_UART0_SIZE),
+	MP200_MAP_DESC(MP200_UART1_BASE,  MP200_UART1_SIZE),
+	MP200_MAP_DESC(MP200_UART2_BASE,  MP200_UART2_SIZE),
+	MP200_MAP_DESC(MP200_IIC2_BASE,   MP200_IIC2_SIZE),
+	MP200_MAP_DESC(MP200_IIC_BASE,    MP200_IIC_SIZE),
+	MP200_MAP_DESC(MP200_SDIA_BASE,   MP200_SDIA_SIZE),
+	MP200_MAP_DESC(MP200_SDIB_BASE,   MP200_SDIB_SIZE),
+	MP200_MAP_DESC(MP200_SDIC_BASE,   MP200_SDIC_SIZE),
+
+	/* BANK 6 */
+	MP200_MAP_DESC(MP200_USB_BASE, MP200_USB_SIZE),
+	MP200_MAP_DESC(MP200_AVC_BASE, MP200_AVC_SIZE),
+	MP200_MAP_DESC(MP200_MSP_BASE, MP200_MSP_SIZE),
+	MP200_MAP_DESC(MP200_MMM_BASE, MP200_MMM_SIZE),
+
+	/* BANK 8 */
+	MP200_MAP_DESC(MP200_L220_BASE, MP200_L220_SIZE),
+
+	/* BANK 10 */
+	MP200_MAP_DESC(MP200_SSRAM_BASE, MP200_SSRAM_SIZE),
+
+	/* BANK 12 */
+	MP200_MAP_DESC(MP200_TIMER_BASE,   MP200_TIMER_SIZE),
+	MP200_MAP_DESC(MP200_PCM0_BASE,    MP200_PCM0_SIZE),
+	MP200_MAP_DESC(MP200_INTC_BASE,    MP200_INTC_SIZE),
+	MP200_MAP_DESC(MP200_GPIO_BASE,    MP200_GPIO_SIZE),
+	MP200_MAP_DESC(MP200_PDMA_BASE,    MP200_PDMA_SIZE),
+	MP200_MAP_DESC(MP200_MEMC_BASE,    MP200_MEMC_SIZE),
+	MP200_MAP_DESC(MP200_DCV_BASE,       MP200_DCV_SIZE),
+
+	MP200_MAP_DESC(MP200_PMU_BASE,     MP200_PMU_SIZE),
+	MP200_MAP_DESC(MP200_SMU_BASE,     MP200_SMU_SIZE),
+	MP200_MAP_DESC(MP200_SP0_BASE,     MP200_SP0_SIZE),
+	MP200_MAP_DESC(MP200_SP1_BASE,     MP200_SP1_SIZE),
+	MP200_MAP_DESC(MP200_CHG_BASE,     MP200_CHG_SIZE),
+	MP200_MAP_DESC(MP200_MWI_BASE,     MP200_MWI_SIZE),
+	MP200_MAP_DESC(MP200_SMU_S2_BASE,  MP200_SMU_S2_SIZE),
+	MP200_MAP_DESC(MP200_INTC_S2_BASE, MP200_INTC_S2_SIZE),
+};
+
+static struct plat_serial8250_port serial_platform_data[] = {
+	{
+	 .membase = (char *)IO_ADDRESS(MP200_UART0_BASE),
+	 .mapbase = (unsigned long)MP200_UART0_BASE,
+	 .irq = INT_UART0,
+	 .flags = UPF_BOOT_AUTOCONF,
+	 .iotype = UPIO_MEM,
+	 .regshift = 2,
+	 .uartclk = MP200_BASE_BAUD,
+	 },
+	{
+	 .membase = (char *)IO_ADDRESS(MP200_UART1_BASE),
+	 .mapbase = (unsigned long)MP200_UART1_BASE,
+	 .irq = INT_UART1,
+	 .flags = UPF_BOOT_AUTOCONF,
+	 .iotype = UPIO_MEM,
+	 .regshift = 2,
+	 .uartclk = MP200_BASE_BAUD,
+	 },
+	{
+	 .membase = (char *)IO_ADDRESS(MP200_UART2_BASE),
+	 .mapbase = (unsigned long)MP200_UART2_BASE,
+	 .irq = INT_UART2,
+	 .flags = UPF_BOOT_AUTOCONF,
+	 .iotype = UPIO_MEM,
+	 .regshift = 2,
+	 .uartclk = MP200_BASE_BAUD,
+	 },
+	{
+	 /* terminate */
+	 },
+};
+
+static struct platform_device dma_device = {
+	.name = "dma",
+	.id = -1,
+};
+
+static struct platform_device spi0_device = {
+	.name = "spi0",
+	.id = 0,
+};
+
+static struct platform_device spi1_device = {
+	.name = "spi",
+	.id = 1,
+};
+
+static struct platform_device spi2_device = {
+	.name = "spi",
+	.id = 2,
+};
+
+
+#ifdef CONFIG_I2C_MP200_ENABLE_CH2
+static struct platform_device i2c1_device = {
+	.name = "i2c",
+	.id = 0,
+};
+
+static struct platform_device i2c2_device = {
+	.name = "i2c",
+	.id = 1,
+};
+#else
+static struct platform_device i2c_device = {
+	.name = "i2c",
+	.id = 0,
+};
+#endif
+
+static struct platform_device serial8250_device = {
+	.name = "serial8250",
+	.id = 0,
+	.dev = {
+		.platform_data = serial_platform_data,
+		},
+};
+
+static struct platform_device pcm_device = {
+	.name = "pcm",
+	.id = -1,
+};
+
+static struct platform_device mp200_fb_device = {
+	.name = "mp200_fb",
+	.id = -1,
+};
+
+static struct platform_device mp200_image_device = {
+	.name = "mp200_image",
+	.id = -1,
+};
+
+static struct platform_device mp200_dsp_device = {
+	.name = "mp200_dsp",
+	.id = -1,
+};
+
+static struct platform_device mp200_udc_device = {
+	.name = "mp200_udc",
+	.id = -1,
+};
+
+static struct platform_device mp200_ehci_device = {
+	.name = "mp200-ehci-driver",
+	.id = -1,
+};
+
+static struct platform_device mp200_mmc_device = {
+	.name = "mp200_mmc",
+	.id = -1,
+};
+
+static struct platform_device mp200_mmc_sd_device = {
+	.name = "mp200_mmc_sd",
+	.id = -1,
+};
+
+static struct platform_device *platform_devs[] __initdata = {
+	&dma_device,
+	&spi0_device,
+	&spi1_device,
+	&spi2_device,
+#ifdef CONFIG_I2C_MP200_ENABLE_CH2
+	&i2c1_device,
+	&i2c2_device,
+#else
+	&i2c_device,
+#endif
+	&serial8250_device,
+	&pcm_device,
+	&mp200_fb_device,
+	&mp200_image_device,
+	&mp200_dsp_device,
+	&mp200_udc_device,
+	&mp200_ehci_device,
+	&mp200_mmc_device,
+	&mp200_mmc_sd_device,
+};
+
+void __init mp200_map_io(void)
+{
+	iotable_init(standard_io_desc, ARRAY_SIZE(standard_io_desc));
+}
+
+void __init mp200_serial_init(int *ports)
+{
+	int i;
+
+	mp200_pmu_open_clockgate(MP200_CLOCKGATE_U70_CLK);
+	for (i = 0; i < 3; i++) {
+		if (ports[i] == 0) {
+			serial_platform_data[i].flags = 0;
+			continue;
+		}
+		/* Set U7x DIV clock */
+		outl(SMU_DIV4, SMU_DIVU70SCLK + i*4);
+		/* Unreset U7x */
+		mp200_pmu_open_clockgate(MP200_CLOCKGATE_U70_SCLK + i);
+		mp200_pmu_unreset_device(MP200_RESETDEVICE_U70 + i);
+	}
+}
+
+static int __init mp200_init(void)
+{
+	return platform_add_devices(platform_devs, ARRAY_SIZE(platform_devs));
+}
+
+arch_initcall(mp200_init);
diff --git a/arch/arm/mach-mp200/generic.h b/arch/arm/mach-mp200/generic.h
new file mode 100644
index 0000000..6ec828e
--- /dev/null
+++ b/arch/arm/mach-mp200/generic.h
@@ -0,0 +1,32 @@
+/*
+ *  File Name       : linux/arch/arm/mach-mp200/generic.h
+ *  Function        : generic
+ *  Release Version : Ver 1.00
+ *  Release Date    : 2006/07/11
+ *
+ *  Copyright (C) NEC Electronics Corporation 2005-2006
+ *
+ *
+ *  This program is free software;you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License as published by Free
+ *  Softwere Foundation; either version 2 of License, or (at your option) any
+ *  later version.
+ *
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warrnty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; If not, write to the Free Software Foundation, Inc., 59
+ *  Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#ifndef __ARCH_ARM_MACH_MP200_GENERIC_H
+#define __ARCH_ARM_MACH_MP200_GENERIC_H
+
+extern void __init mp200_map_io(void);
+extern void __init mp200_serial_init(int ports[]);
+
+#endif				/* __ARCH_ARM_MACH_MP200_GENERIC_H */
diff --git a/arch/arm/mach-mp200/include/mach/em1_mem.h b/arch/arm/mach-mp200/include/mach/em1_mem.h
new file mode 100644
index 0000000..d3301da
--- /dev/null
+++ b/arch/arm/mach-mp200/include/mach/em1_mem.h
@@ -0,0 +1,143 @@
+/*
+ *  File Name	    : linux/include/asm-arm/arch-mp200/em1_mem.h
+ *  Function	    : memory map difinition
+ *  Release Version : Ver 1.20
+ *  Release Date    : 2009/10/09
+ *
+ *  Copyright (C) NEC Electronics Corporation 2005-2009
+ *
+ *
+ *  This program is free software;you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License as published by Free
+ *  Softwere Foundation; either version 2 of License, or (at your option) any
+ *  later version.
+ *
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warrnty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; If not, write to the Free Software Foundation, Inc., 59
+ *  Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#ifndef __EM1_MEM_H
+#define __EM1_MEM_H
+
+#define NUM_BUF_V4L2 			3 /* set 2 or 3 */
+
+/******* SDRAM ********/
+#define INTERDSP_SHARED_ADDR	0x33FE0000 /* CPU<->DSP command buffer */
+#define INTERDSP_SHARED_SIZE	0x00020000 /*   128KB */
+
+#define INTERDSP_DL_TOP_ADDR	0x32E7F000 /* DSP-FW downlaod range (top) */
+#define INTERDSP_DL_BOTTOM_ADDR	0x33FDFFFF /*                       (end) */
+
+#ifdef CONFIG_FB_MP200
+#if (NUM_BUF_V4L2 == 3)
+#define FB_FRAME_BUFFER_ADDR	0x325C6000 /* frame buffer , fb driver work */
+#else /* (NUM_BUF_V4L2 == 2) */
+#define FB_FRAME_BUFFER_ADDR	0x326DF000 /* frame buffer , fb driver work */
+#endif
+#define FB_FRAME_BUFFER_SIZE	0x0056D000 /*   5556Kbyte  */
+#endif	/* CONFIG_FB_MP200 */
+#ifdef CONFIG_VIDEO_MP200		/* V4L2 driver */
+#if (NUM_BUF_V4L2 == 3)
+#define ROT_SHARED_ADDR		0x32B33000	/* buffer for IPU-ROT */
+#else /* (NUM_BUF_V4L2 == 2) */
+#define ROT_SHARED_ADDR		0x32C4C000	/* buffer for IPU-ROT */
+#endif
+#define ROT_SHARED_SIZE		(0x0008CA00 * NUM_BUF_V4L2)
+/* for YUV420 800x480 (562.5KB)*NUM_BUF_V4L2 */
+#define IMG_SHARED_ADDR		(ROT_SHARED_ADDR + ROT_SHARED_SIZE)
+/* buffer for IPU-IMG                */
+#define IMG_SHARED_SIZE		(0x0008CA00 * NUM_BUF_V4L2)
+/* for YUV420 800x480 (562.5KB)*NUM_BUF_V4L2 */
+#endif
+
+
+/* SDRAM difinition for OMF/kenrel drivers  */
+
+#define SHARED_MEM_ADDRESS 	INTERDSP_SHARED_ADDR
+/* CPU<->DSP command buffer start address*/
+#define SHARED_MEM_SIZE 	INTERDSP_SHARED_SIZE
+#define DOWNLOAD_RANGE_START 	INTERDSP_DL_TOP_ADDR
+#define DOWNLOAD_RANGE_END 	INTERDSP_DL_BOTTOM_ADDR
+
+#define FRONT_WIDTH		800	/* for FrameBuf (LCDC) Width  */
+#define FRONT_HEIGHT		480	/* for FrameBuf (LCDC) Height */
+#define FRONT_WIDTH_V		800	/* for DispBuf  (2D)   Width  */
+#define FRONT_HEIGHT_V		480	/* for DispBuf  (2D)   Height */
+#define BYTES_PER_PIXEL		2	/* for DispBuf  (2D)   - 16bpp */
+#ifdef CONFIG_MP200_LCD_RGB666
+#define LCD_DISPLAY_RGB666      1
+#define BITS_PER_PIXEL          18      /* for FrameBuf (LCDC RGB666) - 18bpp */
+#else
+#define LCD_DISPLAY_RGB666      0
+#define BITS_PER_PIXEL          16      /* for FrameBuf (LCDC RGB565) - 16bpp */
+#endif
+
+/* NTS display size */
+#ifdef CONFIG_MP200_NTS
+#define NTSC_WIDTH		720
+#define NTSC_HEIGHT		486
+#define PAL_WIDTH		720
+#define PAL_HEIGHT		576
+#define NTS_WIDTH	(NTSC_WIDTH  > PAL_WIDTH  ? NTSC_WIDTH  : PAL_WIDTH)
+#define NTS_HEIGHT	(NTSC_HEIGHT > PAL_HEIGHT ? NTSC_HEIGHT : PAL_HEIGHT)
+#define NTS_WIDTH_V	(NTSC_WIDTH  > PAL_WIDTH  ? NTSC_WIDTH  : PAL_WIDTH)
+#define NTS_HEIGHT_V	(NTSC_HEIGHT > PAL_HEIGHT ? NTSC_HEIGHT : PAL_HEIGHT)
+#endif /* CONFIG_MP200_NTS */
+
+#ifdef CONFIG_FB_MP200
+#define SMEM_START		FB_FRAME_BUFFER_ADDR
+/* frame buffer, X/fb driver common, etc */
+#define SMEM_LENGTH		FB_FRAME_BUFFER_SIZE
+#endif
+#ifdef CONFIG_VIDEO_MP200	/* V4L2 driver */
+#define ROT_SMEM_START		ROT_SHARED_ADDR
+/* for rotate image (common with DSP) */
+#define ROT_SMEM_LENGTH		ROT_SHARED_SIZE
+/* YUV420 WVGA (800 * 480 * 1.5) */
+#define IMG_SMEM_START		IMG_SHARED_ADDR
+/* for resize image (common with DSP) */
+#define IMG_SMEM_LENGTH		IMG_SHARED_SIZE
+/* YUV420 WVGA (800 * 480 * 1.5) */
+#endif
+
+#ifdef CONFIG_FB_MP200
+#define DISPBUF_A_OFFSET	0x00000000
+/* 0x00000000 - 0x000BB7FF (0xBB800) */
+#define DISPBUF_B_OFFSET	0x000BC000
+/* 0x000BC000 - 0x001777FF (0xBB800) */
+#define DISPBUF_LENGTH	(FRONT_WIDTH_V * FRONT_HEIGHT_V * BYTES_PER_PIXEL)
+
+#ifdef CONFIG_MP200_NTS
+#define NTSCFRAME_A_OFFSET	0x00178000
+/* 0x00178000 - 0x002427FF (0xCA800) */
+#define NTSCFRAME_B_OFFSET	0x00242800
+/* 0x00242800 - 0x0030CFFF (0xCA800) */
+#define NTSCFRAME_LENGTH	(NTS_WIDTH * NTS_HEIGHT * 2)
+/* YUV422 PAL (720 * 576 * 2) */
+
+#ifdef CONFIG_FB_MP200_NTS
+#define NTSCBUF_A_OFFSET	0x0030D000
+/* 0x0030D000 - 0x003D77FF (0xCA800) */
+#define NTSCBUF_B_OFFSET	0x003D8000
+/* 0x003D8000 - 0x004A27FF (0xCA800) */
+#define NTSCBUF_LENGTH		(NTS_WIDTH * NTS_HEIGHT * 2)
+/* RGB565 (720 * 576 * 2) */
+
+#define NTSCWORK_OFFSET		0x004A2800
+/* 0x004A2800 - 0x0056CFFF (0xCA800) */
+#define NTSCWORK_LENGTH		(NTS_WIDTH * NTS_HEIGHT * 2)
+/* RGB565 PAL (720 * 576 * 2) */
+#endif /* CONFIG_FB_MP200_NTS */
+#endif /* CONFIG_MP200_NTS */
+#endif /* CONFIG_FB_MP200 */
+
+#endif /* __EM1_MEM_H */
+
+
diff --git a/arch/arm/mach-mp200/include/mach/em1_mem_qvga.h b/arch/arm/mach-mp200/include/mach/em1_mem_qvga.h
new file mode 100644
index 0000000..7645042
--- /dev/null
+++ b/arch/arm/mach-mp200/include/mach/em1_mem_qvga.h
@@ -0,0 +1,145 @@
+/*
+ *  File Name	    : linux/include/asm-arm/arch-mp200/em1_mem_qvga.h
+ *  Function	    : memory map difinition
+ *  Release Version : Ver 1.20
+ *  Release Date    : 2009/10/09
+ *
+ *  Copyright (C) NEC Electronics Corporation 2005-2009
+ *
+ *
+ *  This program is free software;you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License as published by Free
+ *  Softwere Foundation; either version 2 of License, or (at your option) any
+ *  later version.
+ *
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warrnty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; If not, write to the Free Software Foundation, Inc., 59
+ *  Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#ifndef __EM1_MEM_H
+#define __EM1_MEM_H
+
+#define NUM_BUF_V4L2 			3 /* set 2 or 3 */
+
+/******* SDRAM ********/
+#define INTERDSP_SHARED_ADDR	0x33FE0000 /* CPU<->DSP command buffer */
+#define INTERDSP_SHARED_SIZE	0x00020000 /*   128KB */
+
+#define INTERDSP_DL_TOP_ADDR	0x32E7F000 /* DSP-FW downlaod range (top) */
+#define INTERDSP_DL_BOTTOM_ADDR	0x33FDFFFF /*                       (end) */
+
+#ifdef CONFIG_FB_MP200
+#if (NUM_BUF_V4L2 == 3)
+#define FB_FRAME_BUFFER_ADDR	0x3286D000 /* frame buffer, fb driver work */
+#else /* (NUM_BUF_V4L2 == 2) */
+#define FB_FRAME_BUFFER_ADDR	0x32908000 /* frame buffer, fb driver work */
+#endif
+#define FB_FRAME_BUFFER_SIZE	0x00441000 /* 4356Kbyte */
+#endif	/* CONFIG_FB_MP200 */
+#ifdef CONFIG_VIDEO_MP200		/* V4L2 driver */
+#if (NUM_BUF_V4L2 == 3)
+#define ROT_SHARED_ADDR		0x32CAE000 /* buffer for IPU-ROT */
+#else /* (NUM_BUF_V4L2 == 2) */
+#define ROT_SHARED_ADDR		0x32D49000 /* buffer for IPU-ROT */
+#endif
+#define ROT_SHARED_SIZE		(0x0007E900 * NUM_BUF_V4L2)
+/* YUV420 720x480 (506.25KB)*NUM_BUF_V4L2 */
+#define IMG_SHARED_ADDR		(ROT_SHARED_ADDR + ROT_SHARED_SIZE)
+/* buffer for IPU-IMG */
+#define IMG_SHARED_SIZE		(0x0001C200 * NUM_BUF_V4L2)
+/* for YUV420 240x320 (112.5KB)*NUM_BUF_V4L2  */
+#endif
+
+
+/* SDRAM difinition for OMF/kenrel drivers  */
+
+#define SHARED_MEM_ADDRESS 	INTERDSP_SHARED_ADDR
+/* CPU<->DSP command buffer start address*/
+#define SHARED_MEM_SIZE 	INTERDSP_SHARED_SIZE
+#define DOWNLOAD_RANGE_START 	INTERDSP_DL_TOP_ADDR
+#define DOWNLOAD_RANGE_END 	INTERDSP_DL_BOTTOM_ADDR
+
+#define FRONT_WIDTH		240	/* for FrameBuf (LCDC) Width  */
+#define FRONT_HEIGHT		320	/* for FrameBuf (LCDC) Height */
+#define FRONT_WIDTH_V		240	/* for DispBuf  (2D)   Width  */
+#define FRONT_HEIGHT_V		320	/* for DispBuf  (2D)   Height */
+#define BYTES_PER_PIXEL		2	/* for DispBuf  (2D)   - 16bpp */
+#ifdef CONFIG_MP200_LCD_RGB666
+#define LCD_DISPLAY_RGB666      1
+#define BITS_PER_PIXEL          18
+/* for FrameBuf (LCDC RGB666) - 18bpp */
+#else
+#define LCD_DISPLAY_RGB666      0
+#define BITS_PER_PIXEL          16
+/* for FrameBuf (LCDC RGB565) - 16bpp */
+#endif
+
+/* NTS display size */
+#ifdef CONFIG_MP200_NTS
+#define NTSC_WIDTH		720
+#define NTSC_HEIGHT		486
+#define PAL_WIDTH		720
+#define PAL_HEIGHT		576
+#define NTS_WIDTH	(NTSC_WIDTH  > PAL_WIDTH  ? NTSC_WIDTH  : PAL_WIDTH)
+#define NTS_HEIGHT	(NTSC_HEIGHT > PAL_HEIGHT ? NTSC_HEIGHT : PAL_HEIGHT)
+#define NTS_WIDTH_V	(NTSC_WIDTH  > PAL_WIDTH  ? NTSC_WIDTH  : PAL_WIDTH)
+#define NTS_HEIGHT_V	(NTSC_HEIGHT > PAL_HEIGHT ? NTSC_HEIGHT : PAL_HEIGHT)
+#endif /* CONFIG_MP200_NTS */
+
+#ifdef CONFIG_FB_MP200
+#define SMEM_START		FB_FRAME_BUFFER_ADDR
+	/* frame buffer, X/fb driver common, etc */
+#define SMEM_LENGTH		FB_FRAME_BUFFER_SIZE
+#endif
+#ifdef CONFIG_VIDEO_MP200	/* V4L2 driver */
+#define ROT_SMEM_START		ROT_SHARED_ADDR
+/* for rotate image (common with DSP) */
+#define ROT_SMEM_LENGTH		ROT_SHARED_SIZE
+/* YUV420 WVGA (800 * 480 * 1.5) */
+#define IMG_SMEM_START		IMG_SHARED_ADDR
+/* for resize image (common with DSP) */
+#define IMG_SMEM_LENGTH		IMG_SHARED_SIZE
+/* YUV420 WVGA (800 * 480 * 1.5) */
+#endif
+
+#ifdef CONFIG_FB_MP200
+#define DISPBUF_A_OFFSET	0x00000000
+/* 0x00000000 - 0x000257FF (0x25800) */
+#define DISPBUF_B_OFFSET	0x00026000
+/* 0x00026000 - 0x0004B7FF (0x25800) */
+#define DISPBUF_LENGTH	(FRONT_WIDTH_V * FRONT_HEIGHT_V * BYTES_PER_PIXEL)
+
+#ifdef CONFIG_MP200_NTS
+#define NTSCFRAME_A_OFFSET	0x0004C000
+/* 0x0004C000 - 0x001167FF (0xCA800) */
+#define NTSCFRAME_B_OFFSET	0x00116800
+/* 0x00116800 - 0x001E0FFF (0xCA800) */
+#define NTSCFRAME_LENGTH	(NTS_WIDTH * NTS_HEIGHT * 2)
+/* YUV422 PAL (720 * 576 * 2) */
+
+#ifdef CONFIG_FB_MP200_NTS
+#define NTSCBUF_A_OFFSET	0x001E1000
+/* 0x001E1000 + 0x002AB7FF (0xCA800) */
+#define NTSCBUF_B_OFFSET	0x002AC000
+/* 0x002AC000 + 0x003767FF (0xCA800) */
+#define NTSCBUF_LENGTH		(NTS_WIDTH * NTS_HEIGHT * 2)
+/* RGB565 (720 * 576 * 2) */
+
+#define NTSCWORK_OFFSET		0x00376800
+/* 0x00376800 - 0x00440FFF (0xCA800) */
+#define NTSCWORK_LENGTH		(NTS_WIDTH * NTS_HEIGHT * 2)
+/* RGB565 PAL (720 * 576 * 2) */
+#endif /* CONFIG_FB_MP200_NTS */
+#endif /* CONFIG_MP200_NTS */
+#endif /* CONFIG_FB_MP200 */
+
+#endif /* __EM1_MEM_H */
+
+
diff --git a/arch/arm/mach-mp200/include/mach/em1_mem_wqvga.h b/arch/arm/mach-mp200/include/mach/em1_mem_wqvga.h
new file mode 100644
index 0000000..b68a7cc
--- /dev/null
+++ b/arch/arm/mach-mp200/include/mach/em1_mem_wqvga.h
@@ -0,0 +1,150 @@
+/*
+ *  File Name	    : linux/include/asm-arm/arch-mp200/em1_mem_wqvga.h
+ *  Function	    : memory map difinition
+ *  Release Version : Ver 1.21
+ *  Release Date    : 2009/10/28
+ *
+ *  Copyright (C) NEC Electronics Corporation 2005-2009
+ *
+ *
+ *  This program is free software;you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License as published by Free
+ *  Softwere Foundation; either version 2 of License, or (at your option) any
+ *  later version.
+ *
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warrnty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; If not, write to the Free Software Foundation, Inc., 59
+ *  Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#ifndef __EM1_MEM_H
+#define __EM1_MEM_H
+
+#define NUM_BUF_V4L2 			3 /* set 2 or 3 */
+
+/******* SDRAM ********/
+#define INTERDSP_SHARED_ADDR		0x33FE0000
+/* CPU<->DSP command buffer */
+#define INTERDSP_SHARED_SIZE		0x00020000 /*   128KB */
+
+#define INTERDSP_DL_TOP_ADDR		0x32E7F000
+/* DSP-FW downlaod range (top) */
+#define INTERDSP_DL_BOTTOM_ADDR		0x33FDFFFF
+/*                       (end) */
+
+#ifdef CONFIG_FB_MP200
+#if (NUM_BUF_V4L2 == 3)
+#define FB_FRAME_BUFFER_ADDR	0x32846000 /* frame buffer , fb driver work */
+#else /* (NUM_BUF_V4L2 == 2) */
+#define FB_FRAME_BUFFER_ADDR	0x328E8000 /* frame buffer , fb driver work */
+#endif
+#define FB_FRAME_BUFFER_SIZE	0x00453000 /*   4428Kbyte  */
+#endif	/* CONFIG_FB_MP200 */
+#ifdef CONFIG_VIDEO_MP200		/* V4L2 driver */
+#if (NUM_BUF_V4L2 == 3)
+#define ROT_SHARED_ADDR			0x32C99000
+/* buffer for IPU-ROT */
+#else /* (NUM_BUF_V4L2 == 2) */
+#define ROT_SHARED_ADDR			0x32D3B000
+/* buffer for IPU-ROT */
+#endif
+#define ROT_SHARED_SIZE			(0x0007E900 * NUM_BUF_V4L2)
+/*   for YUV420 720x480 (506.25KB)*NUM_BUF_V4L2  */
+#define IMG_SHARED_ADDR			(ROT_SHARED_ADDR + ROT_SHARED_SIZE)
+/* buffer for IPU-IMG                    */
+#define IMG_SHARED_SIZE			(0x00023280 * NUM_BUF_V4L2)
+/*   for YUV420 240x400 (140.625KB)*NUM_BUF_V4L2 */
+#endif
+
+
+/* SDRAM difinition for OMF/kenrel drivers  */
+
+#define SHARED_MEM_ADDRESS 	INTERDSP_SHARED_ADDR
+/* CPU<->DSP command buffer start address*/
+#define SHARED_MEM_SIZE 	INTERDSP_SHARED_SIZE
+#define DOWNLOAD_RANGE_START 	INTERDSP_DL_TOP_ADDR
+#define DOWNLOAD_RANGE_END 	INTERDSP_DL_BOTTOM_ADDR
+
+#define FRONT_WIDTH		240	/* for FrameBuf (LCDC) Width  */
+#define FRONT_HEIGHT		400	/* for FrameBuf (LCDC) Height */
+#define FRONT_WIDTH_V		240	/* for DispBuf  (2D)   Width  */
+#define FRONT_HEIGHT_V		400	/* for DispBuf  (2D)   Height */
+#define BYTES_PER_PIXEL		2	/* for DispBuf  (2D)   - 16bpp */
+#ifdef CONFIG_MP200_LCD_RGB666
+#define LCD_DISPLAY_RGB666      1
+#define BITS_PER_PIXEL          18
+/* for FrameBuf (LCDC RGB666) - 18bpp */
+#else
+#define LCD_DISPLAY_RGB666      0
+#define BITS_PER_PIXEL          16
+/* for FrameBuf (LCDC RGB565) - 16bpp */
+#endif
+
+/* NTS display size */
+#ifdef CONFIG_MP200_NTS
+#define NTSC_WIDTH		720
+#define NTSC_HEIGHT		486
+#define PAL_WIDTH		720
+#define PAL_HEIGHT		576
+#define NTS_WIDTH	(NTSC_WIDTH  > PAL_WIDTH  ? NTSC_WIDTH  : PAL_WIDTH)
+#define NTS_HEIGHT	(NTSC_HEIGHT > PAL_HEIGHT ? NTSC_HEIGHT : PAL_HEIGHT)
+#define NTS_WIDTH_V	(NTSC_WIDTH  > PAL_WIDTH  ? NTSC_WIDTH  : PAL_WIDTH)
+#define NTS_HEIGHT_V	(NTSC_HEIGHT > PAL_HEIGHT ? NTSC_HEIGHT : PAL_HEIGHT)
+#endif /* CONFIG_MP200_NTS */
+
+#ifdef CONFIG_FB_MP200
+#define SMEM_START		FB_FRAME_BUFFER_ADDR
+/* frame buffer, X/fb driver common, etc */
+#define SMEM_LENGTH		FB_FRAME_BUFFER_SIZE
+#endif
+#ifdef CONFIG_VIDEO_MP200	/* V4L2 driver */
+#define ROT_SMEM_START		ROT_SHARED_ADDR
+		/* for rotate image (common with DSP) */
+#define ROT_SMEM_LENGTH		ROT_SHARED_SIZE
+		/* YUV420 WVGA (800 * 480 * 1.5) */
+#define IMG_SMEM_START		IMG_SHARED_ADDR
+		/* for resize image (common with DSP) */
+#define IMG_SMEM_LENGTH		IMG_SHARED_SIZE
+		/* YUV420 WVGA (800 * 480 * 1.5) */
+#endif
+
+#ifdef CONFIG_FB_MP200
+#define DISPBUF_A_OFFSET	0x00000000
+	/* 0x00000000 - 0x0002EDFF (0x2EE00) */
+#define DISPBUF_B_OFFSET	0x0002F000
+	/* 0x0002F000 - 0x0005DDFF (0x2EE00) */
+#define DISPBUF_LENGTH	(FRONT_WIDTH_V * FRONT_HEIGHT_V * BYTES_PER_PIXEL)
+
+#ifdef CONFIG_MP200_NTS
+#define NTSCFRAME_A_OFFSET	0x0005E000
+	/* 0x0005E000 - 0x001287FF (0xCA800) */
+#define NTSCFRAME_B_OFFSET	0x00128800
+	/* 0x00128800 - 0x001F2FFF (0xCA800) */
+#define NTSCFRAME_LENGTH	(NTS_WIDTH * NTS_HEIGHT * 2)
+ /* YUV422 PAL (720 * 576 * 2) */
+
+#ifdef CONFIG_FB_MP200_NTS
+#define NTSCBUF_A_OFFSET	0x001F3000
+/* 0x001F3000 + 0x002BD7FF (0xCA800) */
+#define NTSCBUF_B_OFFSET	0x002BE000
+/* 0x002BE000 + 0x003887FF (0xCA800) */
+#define NTSCBUF_LENGTH		(NTS_WIDTH * NTS_HEIGHT * 2)
+/* RGB565 (720 * 576 * 2) */
+
+#define NTSCWORK_OFFSET		0x00388800
+	/* 0x00388800 - 0x004CFFFF (0xCA800) */
+#define NTSCWORK_LENGTH		(NTS_WIDTH * NTS_HEIGHT * 2)
+/* RGB565 PAL (720 * 576 * 2) */
+#endif /* CONFIG_FB_MP200_NTS */
+#endif /* CONFIG_MP200_NTS */
+#endif /* CONFIG_FB_MP200 */
+
+#endif /* __EM1_MEM_H */
+
+
diff --git a/arch/arm/mach-mp200/include/mach/entry-macro.S b/arch/arm/mach-mp200/include/mach/entry-macro.S
new file mode 100644
index 0000000..5292c5d
--- /dev/null
+++ b/arch/arm/mach-mp200/include/mach/entry-macro.S
@@ -0,0 +1,77 @@
+/*
+ *  File Name       : linux/include/asm-arm/arch-mp200/entry-macro.S
+ *  Function        : entry-macro.S
+ *  Release Version : Ver 1.00
+ *  Release Date    : 2006/02/22
+ *
+ *  Copyright (C) NEC Electronics Corporation 2006
+ *
+ *
+ *  This program is free software;you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License as published by Free
+ *  Softwere Foundation; either version 2 of License, or (at your option) any
+ *  later version.
+ *
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warrnty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; If not, write to the Free Software Foundation, Inc., 59
+ *  Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+#include <mach/hardware.h>
+#include <mach/irqs.h>
+
+		.macro	disable_fiq
+		.endm
+
+		.macro  get_irqnr_preamble, base, tmp
+		.endm
+
+		.macro  arch_ret_to_user, tmp1, tmp2
+		.endm
+
+		.macro	get_irqnr_and_base, irqnr, irqstat, base, tmp
+		ldr	\base, =IO_ADDRESS(MP200_INTC_BASE)
+
+		mov	\tmp, #1
+
+		ldr	\irqstat, [\base, #MP200_INTC_ITy_MST0_OFFSET]
+		mov	\irqnr, #0
+1001:
+		tst	\irqstat, \tmp, lsl \irqnr
+		bne	1002f
+		add	\irqnr, \irqnr, #1
+		cmp	\irqnr, #32
+		bcc	1001b
+
+		ldr	\irqstat, [\base, #MP200_INTC_ITy_MST1_OFFSET]
+		mov	\irqnr, #0
+1003:
+		tst	\irqstat, \tmp, lsl \irqnr
+		bne	1004f
+		add	\irqnr, \irqnr, #1
+		cmp	\irqnr, #32
+		bcc	1003b
+
+		ldr	\irqstat, [\base, #MP200_INTC_ITy_MST2_OFFSET]
+		mov	\irqnr, #0
+1005:
+		tst	\irqstat, \tmp, lsl \irqnr
+		bne	1006f
+		add	\irqnr, \irqnr, #1
+		cmp	\irqnr, #32
+		bcc	1005b
+
+		mov	\tmp, #0		@ there is no interrupt...
+1004:
+		add	\irqnr, \irqnr, #32
+		b 1002f
+1006:
+		add	\irqnr, \irqnr, #64
+1002:
+		cmp	\tmp, #0
+		.endm
diff --git a/arch/arm/mach-mp200/include/mach/extio.h b/arch/arm/mach-mp200/include/mach/extio.h
new file mode 100644
index 0000000..1da0cde
--- /dev/null
+++ b/arch/arm/mach-mp200/include/mach/extio.h
@@ -0,0 +1,42 @@
+/*
+ *  File Name       : linux/include/asm-arm/arch-mp200/extio.h
+ *  Function        : External GPIO
+ *  Release Version : Ver 1.00
+ *  Release Date    : 2009/06/11
+ *
+ *  Copyright (C) NEC Electronics Corporation 2009
+ *
+ *
+ *  This program is free software;you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License as published by Free
+ *  Softwere Foundation; either version 2 of License, or (at your option) any
+ *  later version.
+ *
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warrnty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; If not, write to the Free Software Foundation, Inc., 59
+ *  Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+#ifndef _ASM_ARCH_EXTIO_H_
+#define _ASM_ARCH_EXTIO_H_
+
+/* GPIO Output/Input select */
+#define EXTIO_IN	0
+#define EXTIO_OUT	1
+
+extern int mp200_extio_initialized;
+
+extern int extio_reg_read(int addr, unsigned char *data);
+extern int extio_reg_write(int addr, unsigned char data);
+extern int extio_read(int addr, unsigned char *data);
+extern int extio_write(int addr, unsigned char data, unsigned char mask);
+extern int extio_set_direction(unsigned gpio, int is_input);
+extern int extio_get_value(unsigned int gpio);
+extern void extio_set_value(unsigned int gpio, int value);
+
+#endif /* _ASM_ARCH_EXTIO_H_ */
diff --git a/arch/arm/mach-mp200/include/mach/hardware.h b/arch/arm/mach-mp200/include/mach/hardware.h
new file mode 100644
index 0000000..310b5d4
--- /dev/null
+++ b/arch/arm/mach-mp200/include/mach/hardware.h
@@ -0,0 +1,428 @@
+/*
+ *  File Name       : linux/include/asm-arm/arch-mp200/hardware.h
+ *  Function        : hardware
+ *  Release Version : Ver 1.04
+ *  Release Date    : 2009/03/03
+ *
+ *  Copyright (C) NEC Electronics Corporation 2005-2009
+ *
+ *
+ *  This program is free software;you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License as published by Free
+ *  Softwere Foundation; either version 2 of License, or (at your option) any
+ *  later version.
+ *
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warrnty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; If not, write to the Free Software Foundation, Inc., 59
+ *  Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#ifndef __ASM_ARM_ARCH_MP200_HARDWARE_H
+#define __ASM_ARM_ARCH_MP200_HARDWARE_H
+
+#include <asm/sizes.h>
+#include <mach/io.h>
+
+#define VA_PEID			IO_ADDRESS(MP200_PEID_BASE)
+#define VA_INTC			IO_ADDRESS(MP200_INTC_BASE)
+
+/* ************************************************************************
+ *   MP200 address map
+ * ***********************************************************************/
+
+/*
+ *  MP200 memory map
+ */
+
+/* BANK 0/1/2 -- AB0 [NOR FLASH/External Device] */
+#define MP200_BANK2_BASE	0x20000000
+#define MP200_AB0_OFFSET	0x0fff0000
+#define MP200_AB0_SIZE		SZ_64K
+
+#define MP200_AB0_BASE		(MP200_BANK2_BASE+MP200_AB0_OFFSET)
+
+/* BANK 3 -- DRAM(FIFO0) [SDRAM] */
+#define MP200_BANK3_BASE	0x30000000
+#define MP200_SDRAM_OFFSET	(0x00000000)
+#define MP200_SDRAM_SIZE	SZ_64M
+
+#define MP200_SDRAM_BASE	(MP200_BANK3_BASE+MP200_SDRAM_OFFSET)
+
+/* BANK 4 -- APB0 [Peripherals] */
+#define MP200_BANK4_BASE	0x40000000
+
+#define MP200_ROTATOR_OFFSET	0x00080000
+#define MP200_ROTATOR_SIZE	SZ_64K
+#define MP200_DMAC_OFFSET	0x00090000
+#define MP200_DMAC_SIZE		SZ_64K
+#define MP200_IMAGEPROC_OFFSET	0x000a0000
+#define MP200_IMAGEPROC_SIZE	SZ_64K
+#define MP200_CAMERA_OFFSET	0x000b0000
+#define MP200_CAMERA_SIZE	SZ_64K
+#define MP200_PCM1_OFFSET	0x000d0000
+#define MP200_PCM1_SIZE		SZ_64K
+#define MP200_PWM_OFFSET	0x00100000
+#define MP200_PWM_SIZE		SZ_64K
+#define MP200_SP2_OFFSET	0x00130000
+#define MP200_SP2_SIZE		SZ_64K
+#define MP200_DTV_OFFSET	0x00150000
+#define MP200_DTV_SIZE		SZ_64K
+#define MP200_DBG_OFFSET	0x00190000
+#define MP200_DBG_SIZE		SZ_64K
+#define MP200_NTSC_OFFSET	0x00210000
+#define MP200_NTSC_SIZE		SZ_64K
+#define MP200_NAND_OFFSET	0x00220000
+#define MP200_NAND_SIZE		SZ_64K
+#define MP200_IPUDMA_OFFSET	0x00250000
+#define MP200_IPUDMA_SIZE	SZ_64K
+#define MP200_IMC_OFFSET	0x00260000
+#define MP200_IMC_SIZE		SZ_64K
+#define MP200_LCD_OFFSET	0x00270000
+#define MP200_LCD_SIZE		SZ_64K
+
+
+/* BANK 5 -- ASYNC1 [Peripherals] */
+#define MP200_BANK5_BASE	0x50000000
+
+#define MP200_UART0_OFFSET	0x00000000
+#define MP200_UART0_SIZE	SZ_64K
+#define MP200_UART1_OFFSET	0x00010000
+#define MP200_UART1_SIZE	SZ_64K
+#define MP200_UART2_OFFSET	0x00020000
+#define MP200_UART2_SIZE	SZ_64K
+#define MP200_IIC2_OFFSET	0x00030000
+#define MP200_IIC2_SIZE		SZ_64K
+#define MP200_IIC_OFFSET	0x00040000
+#define MP200_IIC_SIZE		SZ_64K
+#define MP200_SDIA_OFFSET	0x00050000
+#define MP200_SDIA_SIZE		SZ_64K
+#define MP200_SDIB_OFFSET	0x00060000
+#define MP200_SDIB_SIZE		SZ_64K
+#define MP200_SDIC_OFFSET	0x00090000
+#define MP200_SDIC_SIZE		SZ_64K
+
+
+/* BANK 6 -- AHB Slave */
+#define MP200_BANK6_BASE	0x60000000
+
+#define MP200_USB_OFFSET	0x00000000
+#define MP200_USB_SIZE		SZ_64K
+#define MP200_AVC_OFFSET	0x00020000
+#define MP200_AVC_SIZE		SZ_64K
+#define MP200_MSP_OFFSET	0x00030000
+#define MP200_MSP_SIZE		SZ_64K
+#define MP200_MMM_OFFSET	0x00040000
+#define MP200_MMM_SIZE		SZ_64K
+
+
+/* BANK 7 -- Reserved */
+#define MP200_BANK7_BASE	0x70000000
+
+/* BANK 8 -- Local */
+#define MP200_BANK8_BASE	0x80000000
+
+#define MP200_L220_OFFSET	0x00010000
+#define MP200_L220_SIZE		SZ_64K
+
+/* BANK 9 -- Reserved */
+#define MP200_BANK9_BASE	0x90000000
+
+/* BANK 10 -- SRAM */
+#define MP200_BANK10_BASE	0xa0000000
+
+#define MP200_SSRAM_OFFSET	0x00000000
+#define MP200_SSRAM_SIZE	SZ_128K
+#define MP200_SSRAM_BASE	(MP200_BANK10_BASE+MP200_SSRAM_OFFSET)
+
+/* BANK 11 -- Reserved */
+#define MP200_BANK11_BASE	0xb0000000
+
+/* BANK 12 -- APB1 */
+#define MP200_BANK12_BASE	0xc0000000
+
+#define MP200_TIMER_OFFSET	0x00000000
+#define MP200_TIMER_SIZE	SZ_64K
+#define MP200_TIMER0_OFFSET	0x00000000
+#define MP200_TIMER1_OFFSET	0x00000100
+#define MP200_TIMER2_OFFSET	0x00000200
+#define MP200_TIMER3_OFFSET	0x00000300
+#define MP200_WDT0_OFFSET	0x00001000
+#define MP200_WDT1_OFFSET	0x00001100
+#define MP200_WDT2_OFFSET	0x00001200
+#define MP200_WDT3_OFFSET	0x00001300
+#define MP200_TG0_OFFSET	0x00002000
+#define MP200_TG1_OFFSET	0x00002100
+#define MP200_TG2_OFFSET	0x00002200
+#define MP200_TG3_OFFSET	0x00002300
+#define MP200_TG4_OFFSET	0x00002400
+#define MP200_TG5_OFFSET	0x00002500
+#define MP200_PCM0_OFFSET	0x00010000
+#define MP200_PCM0_SIZE		SZ_64K
+#define MP200_INTC_OFFSET	0x00020000
+#define MP200_INTC_SIZE		SZ_64K
+#define MP200_GPIO_OFFSET	0x00050000
+#define MP200_GPIO_SIZE		SZ_64K
+#define MP200_PDMA_OFFSET	0x00080000
+#define MP200_PDMA_SIZE		SZ_64K
+#define MP200_MEMC_OFFSET	0x000a0000
+#define MP200_MEMC_SIZE		SZ_64K
+#define MP200_DCV_OFFSET	0x000d0000
+#define MP200_DCV_SIZE		SZ_64K
+#define MP200_PMU_OFFSET	0x00100000
+#define MP200_PMU_SIZE		SZ_64K
+#define MP200_SMU_OFFSET	0x00110000
+#define MP200_SMU_SIZE		SZ_64K
+#define MP200_SP0_OFFSET	0x00120000
+#define MP200_SP0_SIZE		SZ_64K
+#define MP200_SP1_OFFSET	0x00130000
+#define MP200_SP1_SIZE		SZ_64K
+#define MP200_CHG_OFFSET	0x00140000
+#define MP200_CHG_SIZE		SZ_64K
+#define MP200_MWI_OFFSET	0x00160000
+#define MP200_MWI_SIZE		SZ_64K
+
+
+#define MP200_SMU_S2_OFFSET	0x0c000000
+#define MP200_SMU_S2_SIZE	SZ_64K
+#define MP200_INTC_S2_OFFSET	0x0c010000
+#define MP200_INTC_S2_SIZE	SZ_64K
+
+/* BANK 13 -- Reserved */
+#define MP200_BANK13_BASE	0xd0000000
+
+/* BANK 14 -- Reserved */
+#define MP200_BANK14_BASE	0xe0000000
+
+/* BANK 15 -- PE0 ROM */
+#define MP200_BANK15_BASE	0xf0000000
+
+#define MP200_BOOTROM_OFFSET	0x00000000
+#define MP200_BOOTROM_SIZE	SZ_128K
+#define MP200_BOOTROM_BASE	(MP200_BANK15_BASE+MP200_BOOTROM_OFFSET)
+
+/*
+ * Peripherals
+ */
+#define MP200_ROTATOR_BASE	(MP200_BANK4_BASE+MP200_ROTATOR_OFFSET)
+#define MP200_DMAC_BASE		(MP200_BANK4_BASE+MP200_DMAC_OFFSET)
+#define MP200_IMAGEPROC_BASE	(MP200_BANK4_BASE+MP200_IMAGEPROC_OFFSET)
+#define MP200_CAMERA_BASE	(MP200_BANK4_BASE+MP200_CAMERA_OFFSET)
+#define MP200_PCM1_BASE		(MP200_BANK4_BASE+MP200_PCM1_OFFSET)
+#define MP200_PWM_BASE		(MP200_BANK4_BASE+MP200_PWM_OFFSET)
+#define MP200_SP2_BASE		(MP200_BANK4_BASE+MP200_SP2_OFFSET)
+#define MP200_DTV_BASE		(MP200_BANK4_BASE+MP200_DTV_OFFSET)
+#define MP200_DBG_BASE		(MP200_BANK4_BASE+MP200_DBG_OFFSET)
+#define MP200_NTSC_BASE		(MP200_BANK4_BASE+MP200_NTSC_OFFSET)
+#define MP200_NAND_BASE		(MP200_BANK4_BASE+MP200_NAND_OFFSET)
+#define MP200_IPUDMA_BASE	(MP200_BANK4_BASE+MP200_IPUDMA_OFFSET)
+#define MP200_IMC_BASE		(MP200_BANK4_BASE+MP200_IMC_OFFSET)
+#define MP200_LCD_BASE		(MP200_BANK4_BASE+MP200_LCD_OFFSET)
+
+#define MP200_UART0_BASE	(MP200_BANK5_BASE+MP200_UART0_OFFSET)
+#define MP200_UART1_BASE	(MP200_BANK5_BASE+MP200_UART1_OFFSET)
+#define MP200_UART2_BASE	(MP200_BANK5_BASE+MP200_UART2_OFFSET)
+#define MP200_IIC2_BASE		(MP200_BANK5_BASE+MP200_IIC2_OFFSET)
+#define MP200_IIC_BASE		(MP200_BANK5_BASE+MP200_IIC_OFFSET)
+#define MP200_SDIA_BASE		(MP200_BANK5_BASE+MP200_SDIA_OFFSET)
+#define MP200_SDIB_BASE		(MP200_BANK5_BASE+MP200_SDIB_OFFSET)
+#define MP200_SDIC_BASE		(MP200_BANK5_BASE+MP200_SDIC_OFFSET)
+
+#define MP200_USB_BASE		(MP200_BANK6_BASE+MP200_USB_OFFSET)
+#define MP200_AVC_BASE		(MP200_BANK6_BASE+MP200_AVC_OFFSET)
+#define MP200_MSP_BASE		(MP200_BANK6_BASE+MP200_MSP_OFFSET)
+#define MP200_MMM_BASE		(MP200_BANK6_BASE+MP200_MMM_OFFSET)
+
+#define MP200_L220_BASE		(MP200_BANK8_BASE+MP200_L220_OFFSET)
+
+#define MP200_TIMER_BASE	(MP200_BANK12_BASE+MP200_TIMER_OFFSET)
+#define MP200_TIMER0_BASE	(MP200_BANK12_BASE+MP200_TIMER0_OFFSET)
+#define MP200_TIMER1_BASE	(MP200_BANK12_BASE+MP200_TIMER1_OFFSET)
+#define MP200_TIMER2_BASE	(MP200_BANK12_BASE+MP200_TIMER2_OFFSET)
+#define MP200_TIMER3_BASE	(MP200_BANK12_BASE+MP200_TIMER3_OFFSET)
+#define MP200_WDT0_BASE		(MP200_BANK12_BASE+MP200_WDT0_OFFSET)
+#define MP200_WDT1_BASE		(MP200_BANK12_BASE+MP200_WDT1_OFFSET)
+#define MP200_WDT2_BASE		(MP200_BANK12_BASE+MP200_WDT2_OFFSET)
+#define MP200_WDT3_BASE		(MP200_BANK12_BASE+MP200_WDT3_OFFSET)
+#define MP200_TG0_BASE		(MP200_BANK12_BASE+MP200_TG0_OFFSET)
+#define MP200_TG1_BASE		(MP200_BANK12_BASE+MP200_TG1_OFFSET)
+#define MP200_TG2_BASE		(MP200_BANK12_BASE+MP200_TG2_OFFSET)
+#define MP200_TG3_BASE		(MP200_BANK12_BASE+MP200_TG3_OFFSET)
+#define MP200_TG4_BASE		(MP200_BANK12_BASE+MP200_TG4_OFFSET)
+#define MP200_TG5_BASE		(MP200_BANK12_BASE+MP200_TG5_OFFSET)
+#define MP200_PCM0_BASE		(MP200_BANK12_BASE+MP200_PCM0_OFFSET)
+#define MP200_INTC_BASE		(MP200_BANK12_BASE+MP200_INTC_OFFSET)
+#define MP200_GPIO_BASE		(MP200_BANK12_BASE+MP200_GPIO_OFFSET)
+#define MP200_PDMA_BASE		(MP200_BANK12_BASE+MP200_PDMA_OFFSET)
+#define MP200_MEMC_BASE		(MP200_BANK12_BASE+MP200_MEMC_OFFSET)
+#define MP200_DCV_BASE		(MP200_BANK12_BASE+MP200_DCV_OFFSET)
+#define MP200_PMU_BASE		(MP200_BANK12_BASE+MP200_PMU_OFFSET)
+#define MP200_SMU_BASE		(MP200_BANK12_BASE+MP200_SMU_OFFSET)
+#define MP200_SP0_BASE		(MP200_BANK12_BASE+MP200_SP0_OFFSET)
+#define MP200_SP1_BASE		(MP200_BANK12_BASE+MP200_SP1_OFFSET)
+#define MP200_CHG_BASE		(MP200_BANK12_BASE+MP200_CHG_OFFSET)
+#define MP200_MWI_BASE		(MP200_BANK12_BASE+MP200_MWI_OFFSET)
+
+#define MP200_SMU_S2_BASE	(MP200_BANK12_BASE+MP200_SMU_S2_OFFSET)
+#define MP200_INTC_S2_BASE	(MP200_BANK12_BASE+MP200_INTC_S2_OFFSET)
+
+/*
+ *  MP200 Interrupt Controller
+ */
+/* INTC internal offset for ACPU, CCPU, DSP. */
+#define MP200_INTC_ACPU_OFFSET		0x00000000
+#define MP200_INTC_ADSP_OFFSET		0x0000c000
+
+#define MP200_INTC_ACPU_BASE	(MP200_INTC_BASE+MP200_INTC_ACPU_OFFSET)
+#define MP200_INTC_ADSP_BASE	(MP200_INTC_BASE+MP200_INTC_ADSP_OFFSET)
+
+/*
+ * operational register offset
+ */
+/* interrupt enable */
+#define	MP200_INTC_ITy_IEN0_OFFSET	0x00000000
+#define	MP200_INTC_ITy_IEN1_OFFSET	0x00000004
+#define	MP200_INTC_ITy_IEN2_OFFSET	0x00000100
+/* interrupt enable monitor */
+#define	MP200_INTC_ITy_IMN0_OFFSET	0x00000000
+#define	MP200_INTC_ITy_IMN1_OFFSET	0x00000004
+#define	MP200_INTC_ITy_IMN2_OFFSET	0x00000100
+/* interrupt disable */
+#define	MP200_INTC_ITy_IDS0_OFFSET	0x00000008
+#define	MP200_INTC_ITy_IDS1_OFFSET	0x0000000c
+#define	MP200_INTC_ITy_IDS2_OFFSET	0x00000104
+/* interrupt raw status */
+#define	MP200_INTC_ITy_RAW0_OFFSET	0x00000010
+#define	MP200_INTC_ITy_RAW1_OFFSET	0x00000014
+#define	MP200_INTC_ITy_RAW2_OFFSET	0x00000108
+/* interrupt maskable status */
+#define	MP200_INTC_ITy_MST0_OFFSET	0x00000018
+#define	MP200_INTC_ITy_MST1_OFFSET	0x0000001c
+#define	MP200_INTC_ITy_MST2_OFFSET	0x0000010c
+/* interrupt cause clear */
+#define	MP200_INTC_ITy_IIR_OFFSET	0x00000024
+
+/* inter processor communication - set */
+#define MP200_INTC_ITy_IPI0_SET_OFFSET  0x00000030
+#define	MP200_INTC_ITy_IPI3_SET_OFFSET	0x0000003c
+/* inter processor communication - monitor */
+#define MP200_INTC_ITy_IPI0_MON_OFFSET  0x00000030
+#define	MP200_INTC_ITy_IPI3_MON_OFFSET	0x0000003c
+/* inter processor communication - clear */
+#define MP200_INTC_IT0_IPIz_CLR_OFFSET  0x00000050
+#define	MP200_INTC_IT3_IPIz_CLR_OFFSET	0x0000005c
+
+/* FIQ interrupt enable */
+#define	MP200_INTC_ITy_FIE_OFFSET	0x00000080
+/* FIQ interrupt monitor */
+#define	MP200_INTC_ITy_FIM_OFFSET	0x00000080
+/* FIQ interrupt disable */
+#define	MP200_INTC_ITy_FID_OFFSET	0x00000084
+/* interrupt vector base */
+#define	MP200_INTC_ID_VBS_OFFSET	0x00000090
+/* interrupt output clear */
+#define	MP200_INTC_ID_CLR_OFFSET	0x00000094
+
+/* eg, unsigned long va = IO_ADDRESS (MP200_INTC_BASE) + MP200_INTC_IT0_xxx;*/
+/*
+ * register map for ACPU
+ */
+#define MP200_INTC_IT0_IEN0 (MP200_INTC_ACPU_OFFSET+MP200_INTC_ITy_IEN0_OFFSET)
+#define MP200_INTC_IT0_IEN1 (MP200_INTC_ACPU_OFFSET+MP200_INTC_ITy_IEN1_OFFSET)
+#define MP200_INTC_IT0_IEN2 (MP200_INTC_ACPU_OFFSET+MP200_INTC_ITy_IEN2_OFFSET)
+#define MP200_INTC_IT0_IMN0 (MP200_INTC_ACPU_OFFSET+MP200_INTC_ITy_IMN0_OFFSET)
+#define MP200_INTC_IT0_IMN1 (MP200_INTC_ACPU_OFFSET+MP200_INTC_ITy_IMN1_OFFSET)
+#define MP200_INTC_IT0_IMN2 (MP200_INTC_ACPU_OFFSET+MP200_INTC_ITy_IMN2_OFFSET)
+#define MP200_INTC_IT0_IDS0 (MP200_INTC_ACPU_OFFSET+MP200_INTC_ITy_IDS0_OFFSET)
+#define MP200_INTC_IT0_IDS1 (MP200_INTC_ACPU_OFFSET+MP200_INTC_ITy_IDS1_OFFSET)
+#define MP200_INTC_IT0_IDS2 (MP200_INTC_ACPU_OFFSET+MP200_INTC_ITy_IDS2_OFFSET)
+#define MP200_INTC_IT0_RAW0 (MP200_INTC_ACPU_OFFSET+MP200_INTC_ITy_RAW0_OFFSET)
+#define MP200_INTC_IT0_RAW1 (MP200_INTC_ACPU_OFFSET+MP200_INTC_ITy_RAW1_OFFSET)
+#define MP200_INTC_IT0_RAW2 (MP200_INTC_ACPU_OFFSET+MP200_INTC_ITy_RAW2_OFFSET)
+#define MP200_INTC_IT0_MST0 (MP200_INTC_ACPU_OFFSET+MP200_INTC_ITy_MST0_OFFSET)
+#define MP200_INTC_IT0_MST1 (MP200_INTC_ACPU_OFFSET+MP200_INTC_ITy_MST1_OFFSET)
+#define MP200_INTC_IT0_MST2 (MP200_INTC_ACPU_OFFSET+MP200_INTC_ITy_MST2_OFFSET)
+#define MP200_INTC_IT0_IIR  (MP200_INTC_ACPU_OFFSET+MP200_INTC_ITy_IIR_OFFSET)
+#define MP200_INTC_IT0_IPID_SET (MP200_INTC_ACPU_OFFSET+ \
+				 MP200_INTC_ITy_IPI3_SET_OFFSET)
+#define MP200_INTC_IT0_IPID_MON (MP200_INTC_ACPU_OFFSET+ \
+				 MP200_INTC_ITy_IPI3_MON_OFFSET)
+#define MP200_INTC_IT0_IPID_CLR (MP200_INTC_ADSP_OFFSET+ \
+				 MP200_INTC_IT0_IPIz_CLR_OFFSET)
+#define MP200_INTC_IT0_FIE  (MP200_INTC_ACPU_OFFSET+MP200_INTC_ITy_FIE_OFFSET)
+#define MP200_INTC_IT0_FIM  (MP200_INTC_ACPU_OFFSET+MP200_INTC_ITy_FIM_OFFSET)
+#define MP200_INTC_IT0_FID  (MP200_INTC_ACPU_OFFSET+MP200_INTC_ITy_FID_OFFSET)
+
+
+/*
+ * register map for ADSP
+ */
+#define MP200_INTC_ID_IEN0  (MP200_INTC_ADSP_OFFSET+MP200_INTC_ITy_IEN0_OFFSET)
+#define MP200_INTC_ID_IEN1  (MP200_INTC_ADSP_OFFSET+MP200_INTC_ITy_IEN1_OFFSET)
+#define MP200_INTC_ID_IEN2  (MP200_INTC_ADSP_OFFSET+MP200_INTC_ITy_IEN2_OFFSET)
+#define MP200_INTC_ID_IMN0  (MP200_INTC_ADSP_OFFSET+MP200_INTC_ITy_IMN0_OFFSET)
+#define MP200_INTC_ID_IMN1  (MP200_INTC_ADSP_OFFSET+MP200_INTC_ITy_IMN1_OFFSET)
+#define MP200_INTC_ID_IMN2  (MP200_INTC_ADSP_OFFSET+MP200_INTC_ITy_IMN2_OFFSET)
+#define MP200_INTC_ID_IDS0  (MP200_INTC_ADSP_OFFSET+MP200_INTC_ITy_IDS0_OFFSET)
+#define MP200_INTC_ID_IDS1  (MP200_INTC_ADSP_OFFSET+MP200_INTC_ITy_IDS1_OFFSET)
+#define MP200_INTC_ID_IDS2  (MP200_INTC_ADSP_OFFSET+MP200_INTC_ITy_IDS2_OFFSET)
+#define MP200_INTC_ID_RAW0  (MP200_INTC_ADSP_OFFSET+MP200_INTC_ITy_RAW0_OFFSET)
+#define MP200_INTC_ID_RAW1  (MP200_INTC_ADSP_OFFSET+MP200_INTC_ITy_RAW1_OFFSET)
+#define MP200_INTC_ID_RAW2  (MP200_INTC_ADSP_OFFSET+MP200_INTC_ITy_RAW2_OFFSET)
+#define MP200_INTC_ID_MST0  (MP200_INTC_ADSP_OFFSET+MP200_INTC_ITy_MST0_OFFSET)
+#define MP200_INTC_ID_MST1  (MP200_INTC_ADSP_OFFSET+MP200_INTC_ITy_MST1_OFFSET)
+#define MP200_INTC_ID_MST2  (MP200_INTC_ADSP_OFFSET+MP200_INTC_ITy_MST2_OFFSET)
+#define MP200_INTC_ID_IIR   (MP200_INTC_ADSP_OFFSET+MP200_INTC_ITy_IIR_OFFSET)
+#define MP200_INTC_ID_IPI0_SET  (MP200_INTC_ADSP_OFFSET+ \
+				 MP200_INTC_ITy_IPI0_SET_OFFSET)
+#define MP200_INTC_ID_IPI0_MON  (MP200_INTC_ADSP_OFFSET+ \
+				 MP200_INTC_ITy_IPI0_MON_OFFSET)
+#define MP200_INTC_ID_IPI0_CLR  (MP200_INTC_ACPU_OFFSET+ \
+				 MP200_INTC_IT3_IPIz_CLR_OFFSET)
+#define MP200_INTC_ID_VBS   (MP200_INTC_ADSP_OFFSET+MP200_INTC_ID_VBS_OFFSET)
+#define MP200_INTC_ID_CLR   (MP200_INTC_ADSP_OFFSET+MP200_INTC_ID_CLR_OFFSET)
+
+
+/*
+ *  These are useconds NOT ticks.
+ *
+ */
+#define mSEC_1			1000
+#define mSEC_5			(mSEC_1 * 5)
+#define mSEC_10			(mSEC_1 * 10)
+#define mSEC_25			(mSEC_1 * 25)
+#define SEC_1			(mSEC_1 * 1000)
+
+/*
+ * serial base baud
+ */
+#ifdef CONFIG_PLL3_238MHZ
+/* PLL3 238MHZ */
+#define MP200_BASE_BAUD (237567000 / 4)
+#else
+/* PLL3 230MHZ */
+#define MP200_BASE_BAUD (229376000 / 4)
+#endif
+
+/*
+ * Include platform-specific definition
+ */
+#include <mach/mp200_board.h>
+
+/*
+ * MAP DESC
+ */
+#define MP200_MAP_DESC(base, size)		\
+	{					\
+		.virtual = IO_ADDRESS(base),	\
+		.pfn = __phys_to_pfn(base),	\
+		.length = size,			\
+		.type = MT_DEVICE		\
+	}
+
+#endif				/* __ASM_ARM_ARCH_MP200_HARDWARE_H */
diff --git a/arch/arm/mach-mp200/include/mach/io.h b/arch/arm/mach-mp200/include/mach/io.h
new file mode 100644
index 0000000..db63174
--- /dev/null
+++ b/arch/arm/mach-mp200/include/mach/io.h
@@ -0,0 +1,53 @@
+/*
+ *  File Name       : linux/include/asm-arm/arch-mp200/io.h
+ *  Function        : io
+ *  Release Version : Ver 1.01
+ *  Release Date    : 2006/02/22
+ *
+ *  Copyright (C) NEC Electronics Corporation 2005-2006
+ *
+ *
+ *  This program is free software;you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License as published by Free
+ *  Softwere Foundation; either version 2 of License, or (at your option) any
+ *  later version.
+ *
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warrnty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; If not, write to the Free Software Foundation, Inc., 59
+ *  Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#ifndef __ASM_ARM_ARCH_MP200_IO_H
+#define __ASM_ARM_ARCH_MP200_IO_H
+
+#define IO_SPACE_LIMIT 0xffffffff
+
+/*
+ * We don't actually have real ISA nor PCI buses, but there is so many
+ * drivers out there that might just work if we fake them...
+ */
+#define __io(a)			((void __iomem *)(PCIO_BASE + (a)))
+#define __mem_pci(a)		(a)
+#define __mem_isa(a)		(a)
+
+/*
+ * ----------------------------------------------------------------------------
+ * I/O mapping
+ * ----------------------------------------------------------------------------
+ */
+#define IO_BASE			0xe0000000	/* VA of IO */
+#define IO_SIZE			0x10000000	/* How much? */
+
+/* macro to get IO address while running in virtual address */
+#define IO_ADDRESS(x)	((((x) & 0xfc000000)>>4) | ((x) & 0x003fffff) | IO_BASE)
+
+#define PCIO_BASE		0
+#define PCIMEM_BASE		0
+
+#endif				/* __ASM_ARM_ARCH_MP200_IO_H */
diff --git a/arch/arm/mach-mp200/include/mach/irqs.h b/arch/arm/mach-mp200/include/mach/irqs.h
new file mode 100644
index 0000000..d3a94cd
--- /dev/null
+++ b/arch/arm/mach-mp200/include/mach/irqs.h
@@ -0,0 +1,492 @@
+/*
+ *  File Name       : linux/include/asm-arm/arch-mp200/irqs.h
+ *  Function        : irq
+ *  Release Version : Ver 1.00
+ *  Release Date    : 2008/07/16
+ *
+ *  Copyright (C) NEC Electronics Corporation 2005-2008
+ *
+ *
+ *  This program is free software;you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License as published by Free
+ *  Softwere Foundation; either version 2 of License, or (at your option) any
+ *  later version.
+ *
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warrnty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; If not, write to the Free Software Foundation, Inc., 59
+ *  Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#ifndef __ASM_ARM_ARCH_MP200_IRQS_H
+#define __ASM_ARM_ARCH_MP200_IRQS_H
+
+/*
+ * Interrupt numbers
+ */
+#define INT_IRQ_0		0
+#define INT_IRQ_1		1
+#define INT_IRQ_2		2
+#define INT_IRQ_3		3
+#define INT_IRQ_4		4
+#define INT_IRQ_5		5
+#define INT_IRQ_6		6
+#define INT_IRQ_7		7
+#define INT_IRQ_8		8
+#define INT_IRQ_9		9
+#define INT_IRQ_10		10
+#define INT_IRQ_11		11
+#define INT_IRQ_12		12
+#define INT_IRQ_13		13
+#define INT_IRQ_14		14
+#define INT_IRQ_15		15
+#define INT_IRQ_16		16
+#define INT_IRQ_17		17
+#define INT_IRQ_18		18
+#define INT_IRQ_19		19
+#define INT_IRQ_20		20
+#define INT_IRQ_21		21
+#define INT_IRQ_22		22
+#define INT_IRQ_23		23
+#define INT_IRQ_24		24
+#define INT_IRQ_25		25
+#define INT_IRQ_26		26
+#define INT_IRQ_27		27
+#define INT_IRQ_28		28
+#define INT_IRQ_29		29
+#define INT_IRQ_30		30
+#define INT_IRQ_31		31
+#define INT_IRQ_32		32
+#define INT_IRQ_33		33
+#define INT_IRQ_34		34
+#define INT_IRQ_35		35
+#define INT_IRQ_36		36
+#define INT_IRQ_37		37
+#define INT_IRQ_38		38
+#define INT_IRQ_39		39
+#define INT_IRQ_40		40
+#define INT_IRQ_41		41
+#define INT_IRQ_42		42
+#define INT_IRQ_43		43
+#define INT_IRQ_44		44
+#define INT_IRQ_45		45
+#define INT_IRQ_46		46
+#define INT_IRQ_47		47
+#define INT_IRQ_48		48
+#define INT_IRQ_49		49
+#define INT_IRQ_50		50
+#define INT_IRQ_51		51
+#define INT_IRQ_52		52
+#define INT_IRQ_53		53
+#define INT_IRQ_54		54
+#define INT_IRQ_55		55
+#define INT_IRQ_56		56
+#define INT_IRQ_57		57
+#define INT_IRQ_58		58
+#define INT_IRQ_59		59
+#define INT_IRQ_60		60
+#define INT_IRQ_61		61
+#define INT_IRQ_62		62
+#define INT_IRQ_63		63
+#define INT_IRQ_64		64
+#define INT_IRQ_65		65
+#define INT_IRQ_66		66
+#define INT_IRQ_67		67
+#define INT_IRQ_68		68
+#define INT_IRQ_69		69
+#define INT_IRQ_70		70
+#define INT_IRQ_71		71
+#define INT_IRQ_72		72
+#define INT_IRQ_73		73
+#define INT_IRQ_74		74
+#define INT_IRQ_75		75
+#define INT_IRQ_76		76
+#define INT_IRQ_77		77
+#define INT_IRQ_78		78
+#define INT_IRQ_79		79
+#define INT_IRQ_80		80
+#define INT_IRQ_81		81
+#define INT_IRQ_82		82
+#define INT_IRQ_83		83
+#define INT_IRQ_84		84
+#define INT_IRQ_85		85
+#define INT_IRQ_86		86
+#define INT_IRQ_87		87
+#define INT_IRQ_88		88
+#define INT_IRQ_89		89
+#define INT_IRQ_90		90
+#define INT_IRQ_91		91
+#define INT_IRQ_92		92
+#define INT_IRQ_93		93
+#define INT_IRQ_94		94
+#define INT_IRQ_95		95
+
+#define INT_LAST		INT_IRQ_95
+
+#define INT_ACPU		INT_IRQ_0
+#define INT_DSP			INT_IRQ_3
+#define INT_SDIASD		INT_IRQ_5
+#define INT_SDIACC		INT_IRQ_6
+#define INT_SDIBSD		INT_IRQ_7
+#define INT_SDIBCC		INT_IRQ_8
+#define INT_UART0		INT_IRQ_9
+#define INT_UART1		INT_IRQ_10
+#define INT_UART2		INT_IRQ_11
+#define INT_PCM0		INT_IRQ_13
+#define INT_PCM1		INT_IRQ_14
+#define INT_SMU			INT_IRQ_17
+#define INT_MWI			INT_IRQ_18
+#define INT_PDMA		INT_IRQ_19
+#define INT_LCD			INT_IRQ_20
+#define INT_CAM			INT_IRQ_21
+#define INT_IMG			INT_IRQ_22
+#define INT_ROT			INT_IRQ_23
+#define INT_SP0			INT_IRQ_24
+#define INT_SP1			INT_IRQ_25
+#define INT_GIO6		INT_IRQ_26
+#define INT_GIO7		INT_IRQ_27
+#define INT_NTSC		INT_IRQ_28
+#define INT_SDIC_SD		INT_IRQ_29
+#define INT_SDIC_CC		INT_IRQ_30
+#define INT_IIC			INT_IRQ_33
+#define INT_TG0			INT_IRQ_34
+#define INT_TG1			INT_IRQ_35
+#define INT_TG2			INT_IRQ_36
+#define INT_DMAPE0		INT_IRQ_37
+#define INT_IIC2		INT_IRQ_39
+#define INT_DMADSP		INT_IRQ_40
+#define INT_USB			INT_IRQ_41
+#define INT_SP2			INT_IRQ_42
+#define INT_USBWAK		INT_IRQ_43
+#define INT_TG3			INT_IRQ_44
+#define INT_TG4			INT_IRQ_45
+#define INT_TG5			INT_IRQ_46
+#define INT_NAND		INT_IRQ_47
+#define INT_DTV			INT_IRQ_48
+#define INT_GIO0		INT_IRQ_50
+#define INT_GIO1		INT_IRQ_51
+#define INT_GIO2		INT_IRQ_52
+#define INT_GIO3		INT_IRQ_53
+#define INT_TIMER0		INT_IRQ_54
+#define INT_TIMER1		INT_IRQ_55
+#define INT_TIMER2		INT_IRQ_56
+#define INT_TIMER3		INT_IRQ_57
+#define INT_WDT0		INT_IRQ_58
+#define INT_WDT1		INT_IRQ_59
+#define INT_WDT2		INT_IRQ_60
+#define INT_WDT3		INT_IRQ_61
+#define INT_PMU_ACPU	INT_IRQ_65
+#define INT_AVC_A		INT_IRQ_66
+#define INT_AVC_C		INT_IRQ_67
+#define INT_PWM			INT_IRQ_69
+#define INT_IMC			INT_IRQ_70
+#define INT_IPU_DMA		INT_IRQ_72
+#define INT_ACPU_PMU	INT_IRQ_74
+#define INT_ACPU_L2		INT_IRQ_75
+#define INT_DCV			INT_IRQ_76
+#define INT_MSP			INT_IRQ_77
+#define INT_MMM			INT_IRQ_78
+#define INT_GIO4		INT_IRQ_79
+#define INT_GIO5		INT_IRQ_80
+#define INT_SSD0		INT_IRQ_81
+#define INT_SSD1		INT_IRQ_82
+#define INT_SSD2		INT_IRQ_83
+#define INT_SSD3		INT_IRQ_84
+
+#define INT_AAXI_INT_A	INT_IRQ_88
+#define INT_MEMC_ERR	INT_IRQ_89
+#define INT_AB0_ERR		INT_IRQ_90
+#define INT_PB1_ERR		INT_IRQ_91
+#define INT_SRC_ERR		INT_IRQ_92
+#define INT_AXL0_ERR	INT_IRQ_93
+
+
+/*
+ * IRQ Numbers for interrupts muxed through GPIO
+ */
+#define INT_GPIO_BASE	(INT_LAST + 1)
+#define INT_GPIO_0		(INT_GPIO_BASE + 0)
+#define INT_GPIO_1		(INT_GPIO_BASE + 1)
+#define INT_GPIO_2		(INT_GPIO_BASE + 2)
+#define INT_GPIO_3		(INT_GPIO_BASE + 3)
+#define INT_GPIO_4		(INT_GPIO_BASE + 4)
+#define INT_GPIO_5		(INT_GPIO_BASE + 5)
+#define INT_GPIO_6		(INT_GPIO_BASE + 6)
+#define INT_GPIO_7		(INT_GPIO_BASE + 7)
+#define INT_GPIO_8		(INT_GPIO_BASE + 8)
+#define INT_GPIO_9		(INT_GPIO_BASE + 9)
+#define INT_GPIO_10		(INT_GPIO_BASE + 10)
+#define INT_GPIO_11		(INT_GPIO_BASE + 11)
+#define INT_GPIO_12		(INT_GPIO_BASE + 12)
+#define INT_GPIO_13		(INT_GPIO_BASE + 13)
+#define INT_GPIO_14		(INT_GPIO_BASE + 14)
+#define INT_GPIO_15		(INT_GPIO_BASE + 15)
+#define INT_GPIO_16		(INT_GPIO_BASE + 16)
+#define INT_GPIO_17		(INT_GPIO_BASE + 17)
+#define INT_GPIO_18		(INT_GPIO_BASE + 18)
+#define INT_GPIO_19		(INT_GPIO_BASE + 19)
+#define INT_GPIO_20		(INT_GPIO_BASE + 20)
+#define INT_GPIO_21		(INT_GPIO_BASE + 21)
+#define INT_GPIO_22		(INT_GPIO_BASE + 22)
+#define INT_GPIO_23		(INT_GPIO_BASE + 23)
+#define INT_GPIO_24		(INT_GPIO_BASE + 24)
+#define INT_GPIO_25		(INT_GPIO_BASE + 25)
+#define INT_GPIO_26		(INT_GPIO_BASE + 26)
+#define INT_GPIO_27		(INT_GPIO_BASE + 27)
+#define INT_GPIO_28		(INT_GPIO_BASE + 28)
+#define INT_GPIO_29		(INT_GPIO_BASE + 29)
+#define INT_GPIO_30		(INT_GPIO_BASE + 30)
+#define INT_GPIO_31		(INT_GPIO_BASE + 31)
+#define INT_GPIO_32		(INT_GPIO_BASE + 32)
+#define INT_GPIO_33		(INT_GPIO_BASE + 33)
+#define INT_GPIO_34		(INT_GPIO_BASE + 34)
+#define INT_GPIO_35		(INT_GPIO_BASE + 35)
+#define INT_GPIO_36		(INT_GPIO_BASE + 36)
+#define INT_GPIO_37		(INT_GPIO_BASE + 37)
+#define INT_GPIO_38		(INT_GPIO_BASE + 38)
+#define INT_GPIO_39		(INT_GPIO_BASE + 39)
+#define INT_GPIO_40		(INT_GPIO_BASE + 40)
+#define INT_GPIO_41		(INT_GPIO_BASE + 41)
+#define INT_GPIO_42		(INT_GPIO_BASE + 42)
+#define INT_GPIO_43		(INT_GPIO_BASE + 43)
+#define INT_GPIO_44		(INT_GPIO_BASE + 44)
+#define INT_GPIO_45		(INT_GPIO_BASE + 45)
+#define INT_GPIO_46		(INT_GPIO_BASE + 46)
+#define INT_GPIO_47		(INT_GPIO_BASE + 47)
+#define INT_GPIO_48		(INT_GPIO_BASE + 48)
+#define INT_GPIO_49		(INT_GPIO_BASE + 49)
+#define INT_GPIO_50		(INT_GPIO_BASE + 50)
+#define INT_GPIO_51		(INT_GPIO_BASE + 51)
+#define INT_GPIO_52		(INT_GPIO_BASE + 52)
+#define INT_GPIO_53		(INT_GPIO_BASE + 53)
+#define INT_GPIO_54		(INT_GPIO_BASE + 54)
+#define INT_GPIO_55		(INT_GPIO_BASE + 55)
+#define INT_GPIO_56		(INT_GPIO_BASE + 56)
+#define INT_GPIO_57		(INT_GPIO_BASE + 57)
+#define INT_GPIO_58		(INT_GPIO_BASE + 58)
+#define INT_GPIO_59		(INT_GPIO_BASE + 59)
+#define INT_GPIO_60		(INT_GPIO_BASE + 60)
+#define INT_GPIO_61		(INT_GPIO_BASE + 61)
+#define INT_GPIO_62		(INT_GPIO_BASE + 62)
+#define INT_GPIO_63		(INT_GPIO_BASE + 63)
+#define INT_GPIO_64		(INT_GPIO_BASE + 64)
+#define INT_GPIO_65		(INT_GPIO_BASE + 65)
+#define INT_GPIO_66		(INT_GPIO_BASE + 66)
+#define INT_GPIO_67		(INT_GPIO_BASE + 67)
+#define INT_GPIO_68		(INT_GPIO_BASE + 68)
+#define INT_GPIO_69		(INT_GPIO_BASE + 69)
+#define INT_GPIO_70		(INT_GPIO_BASE + 70)
+#define INT_GPIO_71		(INT_GPIO_BASE + 71)
+#define INT_GPIO_72		(INT_GPIO_BASE + 72)
+#define INT_GPIO_73		(INT_GPIO_BASE + 73)
+#define INT_GPIO_74		(INT_GPIO_BASE + 74)
+#define INT_GPIO_75		(INT_GPIO_BASE + 75)
+#define INT_GPIO_76		(INT_GPIO_BASE + 76)
+#define INT_GPIO_77		(INT_GPIO_BASE + 77)
+#define INT_GPIO_78		(INT_GPIO_BASE + 78)
+#define INT_GPIO_79		(INT_GPIO_BASE + 79)
+#define INT_GPIO_80		(INT_GPIO_BASE + 80)
+#define INT_GPIO_81		(INT_GPIO_BASE + 81)
+#define INT_GPIO_82		(INT_GPIO_BASE + 82)
+#define INT_GPIO_83		(INT_GPIO_BASE + 83)
+#define INT_GPIO_84		(INT_GPIO_BASE + 84)
+#define INT_GPIO_85		(INT_GPIO_BASE + 85)
+#define INT_GPIO_86		(INT_GPIO_BASE + 86)
+#define INT_GPIO_87		(INT_GPIO_BASE + 87)
+#define INT_GPIO_88		(INT_GPIO_BASE + 88)
+#define INT_GPIO_89		(INT_GPIO_BASE + 89)
+#define INT_GPIO_90		(INT_GPIO_BASE + 90)
+#define INT_GPIO_91		(INT_GPIO_BASE + 91)
+#define INT_GPIO_92		(INT_GPIO_BASE + 92)
+#define INT_GPIO_93		(INT_GPIO_BASE + 93)
+#define INT_GPIO_94		(INT_GPIO_BASE + 94)
+#define INT_GPIO_95		(INT_GPIO_BASE + 95)
+#define INT_GPIO_96		(INT_GPIO_BASE + 96)
+#define INT_GPIO_97		(INT_GPIO_BASE + 97)
+#define INT_GPIO_98		(INT_GPIO_BASE + 98)
+#define INT_GPIO_99		(INT_GPIO_BASE + 99)
+#define INT_GPIO_100	(INT_GPIO_BASE + 100)
+#define INT_GPIO_101	(INT_GPIO_BASE + 101)
+#define INT_GPIO_102	(INT_GPIO_BASE + 102)
+#define INT_GPIO_103	(INT_GPIO_BASE + 103)
+#define INT_GPIO_104	(INT_GPIO_BASE + 104)
+#define INT_GPIO_105	(INT_GPIO_BASE + 105)
+#define INT_GPIO_106	(INT_GPIO_BASE + 106)
+#define INT_GPIO_107	(INT_GPIO_BASE + 107)
+#define INT_GPIO_108	(INT_GPIO_BASE + 108)
+#define INT_GPIO_109	(INT_GPIO_BASE + 109)
+#define INT_GPIO_110	(INT_GPIO_BASE + 110)
+#define INT_GPIO_111	(INT_GPIO_BASE + 111)
+#define INT_GPIO_112	(INT_GPIO_BASE + 112)
+#define INT_GPIO_113	(INT_GPIO_BASE + 113)
+#define INT_GPIO_114	(INT_GPIO_BASE + 114)
+#define INT_GPIO_115	(INT_GPIO_BASE + 115)
+#define INT_GPIO_116	(INT_GPIO_BASE + 116)
+#define INT_GPIO_117	(INT_GPIO_BASE + 117)
+#define INT_GPIO_118	(INT_GPIO_BASE + 118)
+#define INT_GPIO_119	(INT_GPIO_BASE + 119)
+#define INT_GPIO_120	(INT_GPIO_BASE + 120)
+#define INT_GPIO_121	(INT_GPIO_BASE + 121)
+#define INT_GPIO_122	(INT_GPIO_BASE + 122)
+#define INT_GPIO_123	(INT_GPIO_BASE + 123)
+#define INT_GPIO_124	(INT_GPIO_BASE + 124)
+#define INT_GPIO_125	(INT_GPIO_BASE + 125)
+#define INT_GPIO_126	(INT_GPIO_BASE + 126)
+#define INT_GPIO_127	(INT_GPIO_BASE + 127)
+
+#define INT_GPIO_LAST	INT_GPIO_127
+
+#define INT_GPIO_INTOUT		INT_GPIO_0
+#ifdef	CONFIG_MP200_EM1_DKIT
+#define INT_GPIO_SD0CD_INT	INT_GPIO_3
+#define INT_GPIO_WIFI_INT	INT_GPIO_10
+#define INT_GPIO_PSW1_INT	INT_GPIO_36
+#define INT_GPIO_ETHER_INT	INT_GPIO_41
+#define INT_GPIO_PSW2_INT	INT_GPIO_71
+#else
+#define INT_GPIO_ETHER_INT	INT_GPIO_4
+#define INT_GPIO_USB_INT	INT_GPIO_7
+#define INT_GPIO_TS_INT		INT_GPIO_10
+#endif
+
+/* 5T735 IRQ */
+#define INT_PWC_BASE		(INT_GPIO_LAST + 1)
+#ifdef	CONFIG_MP200_EM1_DKIT
+#define INT_PWC_MASK1_BASE	INT_PWC_BASE
+#define INT_PWC_E_DCIN_DET	(INT_PWC_MASK1_BASE + 0)
+#define INT_PWC_E_VBUS_DET	(INT_PWC_MASK1_BASE + 1)
+#define INT_PWC_E_DCIN_REM	(INT_PWC_MASK1_BASE + 2)
+#define INT_PWC_E_VBUS_REM	(INT_PWC_MASK1_BASE + 3)
+#define INT_PWC_E_VDD_LOW	(INT_PWC_MASK1_BASE + 4)
+#define INT_PWC_E_ALARM		(INT_PWC_MASK1_BASE + 5)
+#define INT_PWC_E_SEQ_RDY	(INT_PWC_MASK1_BASE + 6)
+#define INT_PWC_E_COMP_1V2	(INT_PWC_MASK1_BASE + 7)
+
+#define INT_PWC_MASK1_LAST	INT_PWC_E_COMP_1V2
+
+#define INT_PWC_MASK2_BASE	(INT_PWC_MASK1_LAST + 1)
+#define INT_PWC_E_NONKEY	(INT_PWC_MASK2_BASE + 0)
+#define INT_PWC_E_ID_FLOAT	(INT_PWC_MASK2_BASE + 1)
+#define INT_PWC_E_ID_GND	(INT_PWC_MASK2_BASE + 2)
+#define INT_PWC_E_CHG_END	(INT_PWC_MASK2_BASE + 3)
+#define INT_PWC_E_TBAT		(INT_PWC_MASK2_BASE + 4)
+#define INT_PWC_E_ADC_EOM	(INT_PWC_MASK2_BASE + 5)
+#define INT_PWC_E_PEN_DOWN	(INT_PWC_MASK2_BASE + 6)
+#define INT_PWC_E_TSI_READY	(INT_PWC_MASK2_BASE + 7)
+
+#define INT_PWC_MASK2_LAST	INT_PWC_E_TSI_READY
+
+#define INT_PWC_MASK3_BASE	(INT_PWC_MASK2_LAST + 1)
+#define INT_PWC_IO00		(INT_PWC_MASK3_BASE + 0)
+#define INT_PWC_IO01		(INT_PWC_MASK3_BASE + 1)
+#define INT_PWC_IO02		(INT_PWC_MASK3_BASE + 2)
+#define INT_PWC_IO03		(INT_PWC_MASK3_BASE + 3)
+#define INT_PWC_IO04		(INT_PWC_MASK3_BASE + 4)
+#define INT_PWC_IO05		(INT_PWC_MASK3_BASE + 5)
+#define INT_PWC_IO06		(INT_PWC_MASK3_BASE + 6)
+#define INT_PWC_IO07		(INT_PWC_MASK3_BASE + 7)
+
+#define INT_PWC_MASK3_LAST	INT_PWC_IO07
+
+#define INT_PWC_MASK4_BASE	(INT_PWC_MASK3_LAST + 1)
+#define INT_PWC_IO08		(INT_PWC_MASK4_BASE + 0)
+#define INT_PWC_IO09		(INT_PWC_MASK4_BASE + 1)
+#define INT_PWC_IO10		(INT_PWC_MASK4_BASE + 2)
+#define INT_PWC_IO11		(INT_PWC_MASK4_BASE + 3)
+#define INT_PWC_IO12		(INT_PWC_MASK4_BASE + 4)
+#define INT_PWC_IO13		(INT_PWC_MASK4_BASE + 5)
+#define INT_PWC_IO14		(INT_PWC_MASK4_BASE + 6)
+#define INT_PWC_IO15		(INT_PWC_MASK4_BASE + 7)
+
+#define INT_PWC_MASK4_LAST	INT_PWC_IO15
+
+
+#define INT_PWC_LAST		INT_PWC_MASK4_LAST
+
+#define INT_PWC_GPIO_KEY_DATA0	INT_PWC_IO08
+#define INT_PWC_GPIO_KEY_DATA1	INT_PWC_IO09
+#define INT_PWC_GPIO_KEY_DATA2	INT_PWC_IO10
+#define INT_PWC_GPIO_KEY_DATA3	INT_PWC_IO12
+
+/* an interim definition */
+#define INT_PWC_RTCINT		INT_PWC_E_ALARM
+#define INT_PWC_USBWAKINT	INT_PWC_IO02
+
+#else /* CONFIG_MP200_EM1_DKIT */
+
+#define INT_PWC_MASK1_BASE	INT_PWC_BASE
+#define INT_PWC_IO00		(INT_PWC_MASK1_BASE + 0)
+#define INT_PWC_IO01		(INT_PWC_MASK1_BASE + 1)
+#define INT_PWC_IO02		(INT_PWC_MASK1_BASE + 2)
+#define INT_PWC_IO03		(INT_PWC_MASK1_BASE + 3)
+#define INT_PWC_IO04		(INT_PWC_MASK1_BASE + 4)
+#define INT_PWC_IO05		(INT_PWC_MASK1_BASE + 5)
+#define INT_PWC_IO06		(INT_PWC_MASK1_BASE + 6)
+#define INT_PWC_IO07		(INT_PWC_MASK1_BASE + 7)
+
+#define INT_PWC_MASK1_LAST	INT_PWC_IO07
+
+#define INT_PWC_MASK2_BASE	(INT_PWC_MASK1_LAST + 1)
+#define INT_PWC_IO08		(INT_PWC_MASK2_BASE + 0)
+#define INT_PWC_IO09		(INT_PWC_MASK2_BASE + 1)
+#define INT_PWC_IO10		(INT_PWC_MASK2_BASE + 2)
+#define INT_PWC_IO11		(INT_PWC_MASK2_BASE + 3)
+#define INT_PWC_IO12		(INT_PWC_MASK2_BASE + 4)
+#define INT_PWC_IO13		(INT_PWC_MASK2_BASE + 5)
+#define INT_PWC_IO14		(INT_PWC_MASK2_BASE + 6)
+#define INT_PWC_IO15		(INT_PWC_MASK2_BASE + 7)
+
+#define INT_PWC_MASK2_LAST	INT_PWC_IO15
+
+#define INT_PWC_MASK3_BASE	(INT_PWC_MASK2_LAST + 1)
+#define INT_PWC_ADINT		(INT_PWC_MASK3_BASE + 0)
+#define INT_PWC_RTCINT		(INT_PWC_MASK3_BASE + 1)
+#define INT_PWC_CHGINT		(INT_PWC_MASK3_BASE + 2)
+#define INT_PWC_PWOFINT		(INT_PWC_MASK3_BASE + 3)
+#define INT_PWC_PWUPINT		(INT_PWC_MASK3_BASE + 4)
+#define INT_PWC_USBWAKINT	(INT_PWC_MASK3_BASE + 4)
+#define INT_PWC_DETBATINT	(INT_PWC_MASK3_BASE + 5)
+#define INT_PWC_DETADPINT	(INT_PWC_MASK3_BASE + 6)
+#define INT_PWC_DETUSBINT	(INT_PWC_MASK3_BASE + 7)
+
+#define INT_PWC_MASK3_LAST	INT_PWC_DETUSBINT
+
+#define INT_PWC_LAST		INT_PWC_MASK3_LAST
+
+
+#define INT_PWC_GPIO_KEY_DATA0	INT_PWC_IO00
+#define INT_PWC_GPIO_KEY_DATA1	INT_PWC_IO01
+#define INT_PWC_GPIO_KEY_DATA2	INT_PWC_IO02
+#define INT_PWC_GPIO_KEY_DATA3	INT_PWC_IO03
+
+#endif /* CONFIG_MP200_EM1_DKIT */
+
+
+#define MAXIRQNUM		INT_PWC_LAST
+#define MAXFIQNUM		MAXIRQNUM
+#define MAXSWINUM		MAXIRQNUM
+
+#define NR_IRQS			(MAXIRQNUM + 1)
+
+/*
+ * Interrupt detection
+ */
+#define __IRQT_ASYNC		(1 << 31)
+
+#ifndef __ASSEMBLY__
+extern void mp200_init_irq(void);
+#endif
+
+#include <mach/hardware.h>
+
+/*
+ * Define the timer interrupt for PREEMPT_RT case
+ */
+#define ARCH_TIMER_IRQ		INT_STI
+
+#endif				/* __ASM_ARM_ARCH_MP200_IRQS_H */
diff --git a/arch/arm/mach-mp200/include/mach/memory.h b/arch/arm/mach-mp200/include/mach/memory.h
new file mode 100644
index 0000000..d536b2b
--- /dev/null
+++ b/arch/arm/mach-mp200/include/mach/memory.h
@@ -0,0 +1,38 @@
+/*
+ *  File Name       : linux/include/asm-arm/arch-mp200/memory.h
+ *  Function        : memory
+ *  Release Version : Ver 1.03
+ *  Release Date    : 2009/01/27
+ *
+ *  Copyright (C) NEC Electronics Corporation 2005-2008
+ *
+ *
+ *  This program is free software;you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License as published by Free
+ *  Softwere Foundation; either version 2 of License, or (at your option) any
+ *  later version.
+ *
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warrnty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; If not, write to the Free Software Foundation, Inc., 59
+ *  Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#ifndef __ASM_ARCH_MEMORY_H
+#define __ASM_ARCH_MEMORY_H
+/*
+ * Physical DRAM offset.
+ */
+#define PHYS_OFFSET	UL(0x30000000)
+
+#define __virt_to_bus(x) __virt_to_phys(x)
+#define __bus_to_virt(x) __phys_to_virt(x)
+
+#define NODE_MEM_SIZE_BITS	25
+
+#endif				/* __ASM_ARCH_MEMORY_H */
diff --git a/arch/arm/mach-mp200/include/mach/mp200_board.h b/arch/arm/mach-mp200/include/mach/mp200_board.h
new file mode 100644
index 0000000..91a92a1
--- /dev/null
+++ b/arch/arm/mach-mp200/include/mach/mp200_board.h
@@ -0,0 +1,56 @@
+/*
+ *  File Name       : linux/include/asm-arm/arch-mp200/mp200_board.h
+ *  Function        : mp200_board
+ *  Release Version : Ver 1.01
+ *  Release Date    : 2006/02/22
+ *
+ *  Copyright (C) NEC Electronics Corporation 2005-2006
+ *
+ *
+ *  This program is free software;you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License as published by Free
+ *  Softwere Foundation; either version 2 of License, or (at your option) any
+ *  later version.
+ *
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warrnty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; If not, write to the Free Software Foundation, Inc., 59
+ *  Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#ifndef __ASM_ARCH_MP200_BOARD_H
+#define __ASM_ARCH_MP200_BOARD_H
+
+/* BANK 0 -- ASYNC0 1/3 [NOR FLASH] */
+#define MP200_BANK0_BASE	0x00000000
+
+#define MP200_FLASH_BASE	MP200_BANK0_BASE
+#define MP200_FLASH_SIZE	(SZ_64M * 2)
+
+/* BANK 1 -- ASYNC0 2/3 [NAND FLASH] */
+#define MP200_BANK1_BASE	0x10000000
+
+#define MP200_NAND_DATA_BASE	(MP200_BANK1_BASE + 0x00000000)
+#define MP200_NAND_COMMAND_BASE	(MP200_BANK1_BASE + 0x00020000)
+#define MP200_NAND_ADDRESS_BASE	(MP200_BANK1_BASE + 0x00040000)
+
+/* BANK 2 -- ASYNC0 3/3 */
+#define MP200_BANK2_BASE	0x20000000
+
+#define MP200_LOGPSRAM_OFFSET	0x0c000000
+#define MP200_LOGPSRAM_SIZE	SZ_16M
+#define MP200_ETHER_OFFSET	0x00000000
+#define MP200_ETHER_SIZE	SZ_4K
+
+
+#define MP200_LOGPSRAM_BASE	(MP200_BANK2_BASE+MP200_LOGPSRAM_OFFSET)
+#define MP200_ETHER_BASE	(MP200_BANK2_BASE+MP200_ETHER_OFFSET)
+
+#define MP200_LOGPSRAM_VIRT	0xd1000000
+
+#endif				/* __ASM_ARCH_MP200_BOARD_H */
diff --git a/arch/arm/mach-mp200/include/mach/param.h b/arch/arm/mach-mp200/include/mach/param.h
new file mode 100644
index 0000000..dfd083e
--- /dev/null
+++ b/arch/arm/mach-mp200/include/mach/param.h
@@ -0,0 +1,26 @@
+/*
+ *  File Name       : linux/include/asm-arm/arch-mp200/param.h
+ *  Function        : param
+ *  Release Version : Ver 1.00
+ *  Release Date    : 2005/05/16
+ *
+ *  Copyright (C) NEC Electronics Corporation 2005
+ *
+ *
+ *  This program is free software;you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License as published by Free
+ *  Softwere Foundation; either version 2 of License, or (at your option) any
+ *  later version.
+ *
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warrnty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; If not, write to the Free Software Foundation, Inc., 59
+ *  Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#define HZ 100
diff --git a/arch/arm/mach-mp200/include/mach/system.h b/arch/arm/mach-mp200/include/mach/system.h
new file mode 100644
index 0000000..8564728
--- /dev/null
+++ b/arch/arm/mach-mp200/include/mach/system.h
@@ -0,0 +1,56 @@
+/*
+ *  File Name       : linux/include/asm-arm/arch-mp200/system.h
+ *  Function        : system
+ *  Release Version : Ver 1.00
+ *  Release Date    : 2005/05/16
+ *
+ *  Copyright (C) NEC Electronics Corporation 2005
+ *
+ *
+ *  This program is free software;you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License as published by Free
+ *  Softwere Foundation; either version 2 of License, or (at your option) any
+ *  later version.
+ *
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warrnty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; If not, write to the Free Software Foundation, Inc., 59
+ *  Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#ifndef __ASM_ARCH_MP200_SYSTEM_H
+#define __ASM_ARCH_MP200_SYSTEM_H
+
+#include <linux/io.h>
+#include <asm/proc-fns.h>
+#include <mach/pwc.h>
+
+static DEFINE_SPINLOCK(idle_spinlock);
+
+static void arch_idle(void)
+{
+	unsigned long flags;
+
+	/*
+	 * This should do all the clock switching
+	 * and wait for interrupt tricks
+	 */
+	spin_lock_irqsave(&idle_spinlock, flags);
+	cpu_do_idle();
+	spin_unlock_irqrestore(&idle_spinlock, flags);
+}
+
+static inline void arch_reset(char mode)
+{
+#ifdef	CONFIG_MP200_EM1_DKIT
+#else
+	pwc_write(PWC_SFTRST, 0xff, 0xff);
+#endif
+}
+
+#endif	/* __ASM_ARCH_MP200_SYSTEM_H */
diff --git a/arch/arm/mach-mp200/include/mach/uncompress.h b/arch/arm/mach-mp200/include/mach/uncompress.h
new file mode 100644
index 0000000..1d062f0
--- /dev/null
+++ b/arch/arm/mach-mp200/include/mach/uncompress.h
@@ -0,0 +1,52 @@
+/*
+ * File Name	    : linux/include/asm-arm/arch-mp200/uncompress.h
+ *  Function	    : Serial port stubs for kernel decompress status messages
+ *  Release Version : Ver 1.00
+ *  Release Date    : 2006/02/20
+ *
+ *  Copyright (C) NEC Electronics Corporation 2006
+ *
+ *
+ *  This program is free software;you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License as published by Free
+ *  Softwere Foundation; either version 2 of License, or (at your option) any
+ *  later version.
+ *
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warrnty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; If not, write to the Free Software Foundation, Inc., 59
+ *  Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#include <linux/types.h>
+#include <linux/serial_reg.h>
+#include <mach/hardware.h>
+
+static void putc(int c)
+{
+	volatile u8 *uart = 0;
+
+	uart = (volatile u8 *)(MP200_UART0_BASE);
+
+	/*
+	 * Now, xmit each character
+	 */
+	while (!(uart[UART_LSR] & UART_LSR_THRE))
+		barrier();
+	uart[UART_TX] = c;
+}
+
+static inline void flush(void)
+{
+}
+
+/*
+ * nothing to do
+ */
+#define arch_decomp_setup()
+#define arch_decomp_wdog()
diff --git a/arch/arm/mach-mp200/include/mach/vmalloc.h b/arch/arm/mach-mp200/include/mach/vmalloc.h
new file mode 100644
index 0000000..bd88d79
--- /dev/null
+++ b/arch/arm/mach-mp200/include/mach/vmalloc.h
@@ -0,0 +1,32 @@
+/*
+ *  File Name       : linux/include/asm-arm/arch-mp200/vmalloc.h
+ *  Function        : vmalloc
+ *  Release Version : Ver 1.00
+ *  Release Date    : 2005/05/16
+ *
+ *  Copyright (C) NEC Electronics Corporation 2005
+ *
+ *
+ *  This program is free software;you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License as published by Free
+ *  Softwere Foundation; either version 2 of License, or (at your option) any
+ *  later version.
+ *
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warrnty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; If not, write to the Free Software Foundation, Inc., 59
+ *  Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#ifndef __ASM_ARCH_MP200_VMALLOC_H
+#define __ASM_ARCH_MP200_VMALLOC_H
+
+#define VMALLOC_VMADDR(x) ((unsigned long)(x))
+#define VMALLOC_END       (PAGE_OFFSET + 0x20000000)
+
+#endif	/*  __ASM_ARCH_MP200_VMALLOC_H */
diff --git a/arch/arm/mach-mp200/irq.c b/arch/arm/mach-mp200/irq.c
new file mode 100644
index 0000000..db437bb
--- /dev/null
+++ b/arch/arm/mach-mp200/irq.c
@@ -0,0 +1,121 @@
+/*
+ *  File Name	    : linux/arch/arm/mach-mp200/irq.c
+ *  Function	    : irq
+ *  Release Version : Ver 1.00
+ *  Release Date    : 2008/07/16
+ *
+ *  Copyright (C) NEC Electronics Corporation 2005-2006
+ *
+ *
+ *  This program is free software;you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License as published by Free
+ *  Softwere Foundation; either version 2 of License, or (at your option) any
+ *  later version.
+ *
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warrnty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; If not, write to the Free Software Foundation, Inc., 59
+ *  Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#include <linux/interrupt.h>
+
+#include <linux/io.h>
+#include <asm/mach/irq.h>
+
+#include "irq.h"
+
+static void mp200_mask_irq(unsigned int irq)
+{
+	unsigned long ids;
+	unsigned long mask = 0;
+
+	ids = VA_INTC + MP200_INTC_IT0_IDS0;
+
+	if (irq < 32) {
+		mask = 1 << irq;
+	} else  if (irq < 64) {
+		ids += 4;
+		mask = 1 << (irq - 32);
+	} else {
+		ids += (MP200_INTC_IT0_IDS2 - MP200_INTC_IT0_IDS0);
+		mask = 1 << (irq - 64);
+	}
+
+	__raw_writel(mask, ids);	/* disable */
+}
+
+static void mp200_unmask_irq(unsigned int irq)
+{
+	unsigned long ien;
+	unsigned long mask = 0;
+
+	ien = VA_INTC + MP200_INTC_IT0_IEN0;
+
+	if (irq < 32) {
+		mask = 1 << irq;
+	} else if (irq < 64) {
+		ien += 4;
+		mask = 1 << (irq - 32);
+	} else {
+		ien += (MP200_INTC_IT0_IEN2 - MP200_INTC_IT0_IEN0);
+		mask = 1 << (irq - 64);
+	}
+
+	__raw_writel(mask, ien);	/* enable */
+}
+
+static void mp200_ack_irq(unsigned int irq)
+{
+	__raw_writel((1 << (irq - 32)), (VA_INTC + MP200_INTC_IT0_IIR));
+}
+
+static struct irq_chip mp200_irq_chip_ack = {
+	.name    = "INTC-edge",
+	.ack     = mp200_ack_irq,
+	.mask    = mp200_mask_irq,
+	.unmask  = mp200_unmask_irq,
+	.disable = mp200_mask_irq,
+};
+
+static struct irq_chip mp200_irq_chip = {
+	.name    = "INTC-level",
+	.ack     = mp200_mask_irq,
+	.mask    = mp200_mask_irq,
+	.unmask  = mp200_unmask_irq,
+	.disable = mp200_mask_irq,
+};
+
+
+
+void __init mp200_init_irq(void)
+{
+	unsigned int i;
+
+	clk_init();
+
+	/* Disable all interrupts */
+	__raw_writel(~0U, VA_INTC + MP200_INTC_IT0_IDS0);
+	__raw_writel(~0U, VA_INTC + MP200_INTC_IT0_IDS1);
+	__raw_writel(~0U, VA_INTC + MP200_INTC_IT0_IDS2);
+	__raw_writel(1, VA_INTC + MP200_INTC_IT0_FID);
+
+	for (i = 0; i <= INT_LAST; i++) {
+		if ((i == INT_IIC) || (i == INT_IIC2) || (i == INT_USBWAK)
+		    || (INT_TIMER0 <= i && i <= INT_WDT3)
+		    || (INT_TG0 <= i && i <= INT_TG2)
+		    || (INT_TG3 <= i && i <= INT_TG5)) {
+			set_irq_chip(i, &mp200_irq_chip_ack);
+			set_irq_handler(i, handle_edge_irq);
+		} else {
+			set_irq_chip(i, &mp200_irq_chip);
+			set_irq_handler(i, handle_level_irq);
+		}
+		set_irq_flags(i, IRQF_VALID);
+	}
+}
diff --git a/arch/arm/mach-mp200/irq.h b/arch/arm/mach-mp200/irq.h
new file mode 100644
index 0000000..a38d0f8
--- /dev/null
+++ b/arch/arm/mach-mp200/irq.h
@@ -0,0 +1,31 @@
+/*
+ *  File Name       : linux/arch/arm/mach-mp200/irq.h
+ *  Function        : irq
+ *  Release Version : Ver 1.00
+ *  Release Date    : 2009/11/6
+ *
+ *  Copyright (C) NEC Electronics Corporation 2005-2006
+ *
+ *
+ *  This program is free software;you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License as published by Free
+ *  Softwere Foundation; either version 2 of License, or (at your option) any
+ *  later version.
+ *
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warrnty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; If not, write to the Free Software Foundation, Inc., 59
+ *  Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#ifndef __ARCH_ARM_MACH_MP200_IRQ_H
+#define __ARCH_ARM_MACH_MP200_IRQ_H
+
+extern int clk_init(void);
+
+#endif /* __ARCH_ARM_MACH_MP200_IRQ_H */
diff --git a/arch/arm/mach-mp200/light.c b/arch/arm/mach-mp200/light.c
new file mode 100644
index 0000000..17da6b2
--- /dev/null
+++ b/arch/arm/mach-mp200/light.c
@@ -0,0 +1,129 @@
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/leds.h>
+#include <linux/i2c.h>
+
+#include <linux/gpio.h>
+#include <mach/pwc.h>
+
+#define DEFAULT_BACKLIGHT_BRIGHTNESS 255
+#define HW_MAX_BRIGHTNESS 95
+#define HW_MIN_BRIGHTNESS 16
+
+/*******************************/
+/* LCD BackLight */
+static void
+mp200_brightness_set(struct led_classdev *led_cdev, enum led_brightness value)
+{
+	int hw_val = (value * HW_MAX_BRIGHTNESS) / 255;
+
+	if (hw_val < HW_MIN_BRIGHTNESS)
+		hw_val = HW_MIN_BRIGHTNESS;
+	if (hw_val > HW_MAX_BRIGHTNESS)
+		hw_val = HW_MAX_BRIGHTNESS;
+	pwc_reg_write(DA9052_LED1CONT_REG, hw_val);
+	pwc_reg_write(DA9052_LED2CONT_REG, hw_val);
+}
+
+static struct led_classdev mp200_backlight_led = {
+	.name = "lcd-backlight",
+	.brightness = DEFAULT_BACKLIGHT_BRIGHTNESS,
+	.brightness_set = mp200_brightness_set,
+};
+
+
+/*******************************/
+/* LED */
+
+static struct gpio_led mp200_led_list[] = {
+	{
+		.name = "led1",
+		.gpio = GPIO_LED1,
+		.active_low = 1,
+	},
+	{
+		.name = "led2",
+		.gpio = GPIO_LED2,
+		.active_low = 1,
+	},
+	{
+		.name = "led3",
+		.gpio = GPIO_LED3,
+		.active_low = 1,
+	},
+	{
+		.name = "led4",
+		.gpio = GPIO_LED4,
+		.active_low = 1,
+	},
+	{
+		.name = "led5",
+		.gpio = GPIO_PWC_LED1,
+		.active_low = 1,
+	},
+	{
+		.name = "led6",
+		.gpio = GPIO_PWC_LED2,
+		.active_low = 1,
+	},
+};
+static struct gpio_led_platform_data mp200_leds_data = {
+	.num_leds	= ARRAY_SIZE(mp200_led_list),
+	.leds		= mp200_led_list,
+};
+static struct platform_device mp200_leds = {
+	.name		= "leds-gpio",
+	.id		= -1,
+	.dev		= {
+		.platform_data	= &mp200_leds_data,
+	},
+};
+
+/*******************************/
+static int mp200_light_probe(struct platform_device *pdev)
+{
+	/* Init LCD Backlight */
+	pwc_reg_write(DA9052_LED1CONF_REG, 0xEA);  /* LCD panel max electric
+						      current 15mA, set
+						      14.986mA */
+	pwc_reg_write(DA9052_LED1CONT_REG, 0xDF);
+	pwc_reg_write(DA9052_LED2CONF_REG, 0xEA);  /* LCD panel max electric
+						      current 15mA, set
+						      14.986mA */
+	pwc_reg_write(DA9052_LED2CONT_REG, 0xDF);
+	led_classdev_register(&pdev->dev, &mp200_backlight_led);
+
+	/* Init LED */
+	platform_device_register(&mp200_leds);
+
+	return 0;
+}
+
+static int mp200_light_remove(struct platform_device *pdev)
+{
+	led_classdev_unregister(&mp200_backlight_led);
+
+	platform_device_unregister(&mp200_leds);
+
+	return 0;
+}
+
+static struct platform_driver mp200_light_driver = {
+	.probe		= mp200_light_probe,
+	.remove		= mp200_light_remove,
+	.driver		= {
+		.name		= "mp200-light",
+		.owner		= THIS_MODULE,
+	},
+};
+
+static int __init mp200_light_init(void)
+{
+	return platform_driver_register(&mp200_light_driver);
+}
+
+late_initcall(mp200_light_init);
+
diff --git a/arch/arm/mach-mp200/mp200_board.c b/arch/arm/mach-mp200/mp200_board.c
new file mode 100644
index 0000000..855e25a
--- /dev/null
+++ b/arch/arm/mach-mp200/mp200_board.c
@@ -0,0 +1,345 @@
+/*
+ *  File Name       : linux/arch/arm/mach-mp200/mp200_board.c
+ *  Function        : mp200_board
+ *  Release Version : Ver 1.02
+ *  Release Date    : 2009/06/19
+ *
+ *  Copyright (C) NEC Electronics Corporation 2005-2009
+ *
+ *
+ *  This program is free software;you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License as published by Free
+ *  Softwere Foundation; either version 2 of License, or (at your option) any
+ *  later version.
+ *
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warrnty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; If not, write to the Free Software Foundation, Inc., 59
+ *  Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#include <linux/device.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/types.h>
+#include <linux/mtd/nand.h>
+#include <linux/mtd/partitions.h>
+#include <linux/platform_device.h>
+#include <linux/mm.h>
+#include <linux/i2c.h>
+#include <linux/irq.h>
+
+#include <mach/hardware.h>
+#include <linux/io.h>
+#include <asm/setup.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <asm/mach/map.h>
+#include <asm/mach/flash.h>
+#include <asm/hardware/cache-l2x0.h>
+
+#include <mach/smu.h>
+#include <linux/gpio.h>
+
+#include "generic.h"
+#include "time.h"
+
+static int __initdata mp200_serial_ports[] = { 1, 0, 0, 0 };
+
+#if defined(CONFIG_SMSC911X)
+#include <linux/smsc911x.h>
+static struct resource smsc911x_resources[] = {
+	[0] = {
+		.start		= MP200_ETHER_BASE,
+		.end		= MP200_ETHER_BASE + SZ_64K - 1,
+		.flags		= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start		= INT_GPIO_ETHER_INT,
+		.end		= INT_GPIO_ETHER_INT,
+		.flags		= IORESOURCE_IRQ,
+	},
+};
+static struct smsc911x_platform_config smsc911x_platdata = {
+	.flags		= SMSC911X_USE_32BIT,
+	.irq_type	= SMSC911X_IRQ_TYPE_PUSH_PULL,
+	.irq_polarity = SMSC911X_IRQ_POLARITY_ACTIVE_HIGH,
+};
+static struct platform_device smc91x_device = {
+	.name	= "smsc911x",
+	.id		= 0,
+	.dev  = {
+		.platform_data = &smsc911x_platdata,
+		},
+	.num_resources	= ARRAY_SIZE(smsc911x_resources),
+	.resource	= smsc911x_resources,
+};
+#else	/* defined(CONFIG_SMC91X) */
+static struct resource smc91x_resources[] = {
+	[0] = {
+	       .start = MP200_ETHER_BASE+0x300,
+	       .end = MP200_ETHER_BASE + 0x400,
+	       .flags = IORESOURCE_MEM,
+	       },
+	[1] = {
+	       .start = INT_GPIO_ETHER_INT,
+	       .end = INT_GPIO_ETHER_INT,
+	       .flags = IORESOURCE_IRQ,
+	       },
+};
+static struct platform_device smc91x_device = {
+	.name = "smc91x",
+	.id = -1,
+	.num_resources = ARRAY_SIZE(smc91x_resources),
+	.resource = smc91x_resources,
+};
+#endif
+
+static struct resource mp200_rtc_resources[] = {
+	{
+		.start = INT_PWC_RTCINT,
+		.end   = INT_PWC_RTCINT,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+static struct platform_device mp200_rtc_device = {
+	.name = "mp200-rtc",
+	.id = -1,
+	.num_resources = ARRAY_SIZE(mp200_rtc_resources),
+	.resource = mp200_rtc_resources,
+};
+
+static struct mtd_partition mp200_flash0_partitions[] = {
+	{
+	 .name   = "boot",
+	 .offset = 0,
+	 .size   = 0x00080000,
+	 .mask_flags = MTD_WRITEABLE,	/* force read-only */
+	},
+	{
+	 .name   = "kernel",
+	 .offset = MTDPART_OFS_APPEND,
+	 .size   = 0x00380000,
+	 .mask_flags = MTD_WRITEABLE,	/* force read-only */
+	},
+	{
+	 .name   = "root",
+	 .offset = MTDPART_OFS_APPEND,
+	 .size   = 0x01C00000,
+	 .mask_flags = MTD_WRITEABLE,	/* force read-only */
+	},
+};
+static struct flash_platform_data mp200_flash0_data = {
+	.map_name = "cfi_probe",
+	.width    = 2,
+	.parts    = mp200_flash0_partitions,
+	.nr_parts = ARRAY_SIZE(mp200_flash0_partitions),
+};
+static struct resource mp200_flash0_resource = {
+	.start = MP200_FLASH_BASE,
+	.end   = MP200_FLASH_BASE + SZ_128M - 1,
+	.flags = IORESOURCE_MEM,
+};
+static struct platform_device mp200_flash0_device = {
+	.name = "mp200_flash",
+	.id   = 0,
+	.dev  = {
+		.platform_data = &mp200_flash0_data,
+		},
+	.num_resources = 1,
+	.resource = &mp200_flash0_resource,
+};
+
+#if 0
+static struct mtd_partition mp200_nand_partition[] = {
+	{
+	 .name   = "nand device",
+	 .offset = 0,
+	 .size   = SZ_128M
+	 },
+};
+static struct platform_nand_chip mp200_nand_data = {
+	.nr_chips      = 1,
+	.chip_delay    = 15,
+	.options       = NAND_BUSWIDTH_16,
+	.partitions    = mp200_nand_partition,
+	.nr_partitions = ARRAY_SIZE(mp200_nand_partition),
+};
+static struct resource mp200_nand_resource[] = {
+	{
+		.start = MP200_NAND_DATA_BASE,
+		.end   = MP200_NAND_DATA_BASE + 4 - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	{
+		.start = MP200_NAND_COMMAND_BASE,
+		.end   = MP200_NAND_COMMAND_BASE + 4 - 1 ,
+		.flags = IORESOURCE_MEM,
+	},
+	{
+		.start = MP200_NAND_ADDRESS_BASE,
+		.end   = MP200_NAND_ADDRESS_BASE + 4 - 1,
+		.flags = IORESOURCE_MEM,
+	},
+};
+static struct platform_device mp200_nand_device = {
+	.name = "mp200_nand",
+	.id   = -1,
+	.dev  = {
+		.platform_data = &mp200_nand_data,
+		},
+	.num_resources = ARRAY_SIZE(mp200_nand_resource),
+	.resource = mp200_nand_resource,
+};
+#endif
+
+#ifdef CONFIG_MP200_EM1_DKIT
+static struct platform_device da9052_ts_device = {
+	.name = "da9052-ts",
+	.id = -1,
+};
+
+static struct platform_device mp200_light_device = {
+	.name	= "mp200-light",
+	.id		= -1,
+};
+#endif
+
+static struct platform_device *devs[] __initdata = {
+	&smc91x_device,
+	&mp200_rtc_device,
+	&mp200_flash0_device,
+#if 0
+	&mp200_nand_device,
+#endif
+#ifdef CONFIG_MP200_EM1_DKIT
+	&da9052_ts_device,
+	&mp200_light_device,
+#endif
+};
+
+#ifndef CONFIG_MP200_EM1_DKIT
+#include <linux/i2c/tsc2007.h>
+static int mp200_get_pendown_state(void)
+{
+	return gpio_get_value(GPIO_TP_INT) ? 0 : 1;
+}
+
+static int mp200_init_platform_hw(void)
+{
+	gpio_direction_input(GPIO_TP_INT);
+	set_irq_type(GPIO_TP_INT + INT_GPIO_BASE, IRQ_TYPE_EDGE_FALLING);
+	return 0;
+}
+
+static struct tsc2007_platform_data mp200_touch_data = {
+	.model			= 2007,
+	.x_plate_ohms	= 685,
+	.get_pendown_state = mp200_get_pendown_state,
+	.init_platform_hw = mp200_init_platform_hw,
+};
+#endif
+
+static struct i2c_board_info mp200_i2c_devices[] = {
+#ifdef CONFIG_MP200_EM1_DKIT
+	{
+		I2C_BOARD_INFO("ak4648", 0x13),
+	},
+	{
+		I2C_BOARD_INFO("adv7179", 0x2B),
+	},
+	{
+		I2C_BOARD_INFO("max7324_w", 0x5D),
+	},
+	{
+		I2C_BOARD_INFO("max7324_r", 0x6D),
+	},
+#else
+	{
+		I2C_BOARD_INFO("ak4648", 0x12),
+	},
+	{
+		I2C_BOARD_INFO("adv7179", 0x2B),
+	},
+	{
+		I2C_BOARD_INFO("tsc2007", 0x48),
+		.platform_data = &mp200_touch_data,
+		.irq = GPIO_TP_INT + INT_GPIO_BASE,
+	},
+#endif
+};
+
+static void __init mp200_board_map_io(void)
+{
+	mp200_map_io();
+}
+
+static void __init mp200_board_init(void)
+{
+
+#ifdef CONFIG_MP200_L220
+	unsigned int l2_pte, l2_page;
+	unsigned long l2_addr = IO_ADDRESS(MP200_L220_BASE);
+	pgd_t *pgd;
+	pmd_t *pmd;
+#endif
+	void *em1_bdinfo;
+
+	mp200_serial_init(mp200_serial_ports);
+
+#ifdef CONFIG_MP200_QR
+	outl(0x00020402, SMU_QR_CLKDIV);
+	outl(0x00530103, SMU_QR_ENA);
+#endif
+
+#ifdef CONFIG_MP200_L220
+	pgd = pgd_offset_k(l2_addr);
+	pmd = pmd_offset(pgd, l2_addr);
+	l2_pte = (unsigned int)pte_offset_kernel(pmd, l2_addr);
+	l2_pte -= 2048;
+	l2_page = inl(l2_pte);
+	l2_page &= ~0x0c;
+	l2_page |= 0x80;
+	outl(l2_page, l2_pte);
+	/* flush pte */
+	__asm__ __volatile__("mcr p15, 0, %0, c7, c14, 1" : : "r"(l2_pte));
+	/* Inv D TLB */
+	__asm__ __volatile__("mcr p15, 0, %0, c8, c6, 1" : : "r"(l2_pte));
+	l2_pte = 0;
+	/* Sync */
+	__asm__ __volatile__("mcr p15, 0, %0, c7, c10, 4" : : "r"(l2_pte));
+
+#ifdef CONFIG_MP200_L220_WT
+	/* Force L2 write through */
+	outl(0x2, l2_addr + 0xf40);
+#endif
+
+	/* 1MB (128KB/way), 8-way associativity, evmon/parity/share enabled
+	 * Bits:  .... ...0 0111 1001 0000 .... .... .... */
+/*	l2x0_init((void __iomem *)l2_addr, 0x0003092d, 0xfe000000); */
+	l2x0_init((void __iomem *)l2_addr, 0x00020000, 0xfe000000);
+#endif
+
+	platform_add_devices(devs, ARRAY_SIZE(devs));
+	i2c_register_board_info(0, mp200_i2c_devices,
+			ARRAY_SIZE(mp200_i2c_devices));
+
+	em1_bdinfo = ioremap(MP200_SSRAM_BASE + 0x1fffc, 4);
+	system_rev = ioread32(em1_bdinfo);
+	iounmap(em1_bdinfo);
+
+}
+
+MACHINE_START(MP200, "MP200")
+	.phys_io      = MP200_BANK5_BASE,
+	.boot_params  = PHYS_OFFSET+0x100,
+	.map_io       = mp200_board_map_io,
+	.init_irq     = mp200_init_irq,
+	.init_machine = mp200_board_init,
+	.timer        = &mp200_timer,
+MACHINE_END
diff --git a/arch/arm/tools/mach-types b/arch/arm/tools/mach-types
index 56281c0..cef25fd 100644
--- a/arch/arm/tools/mach-types
+++ b/arch/arm/tools/mach-types
@@ -1330,7 +1330,7 @@ at91sam9rlek		MACH_AT91SAM9RLEK	AT91SAM9RLEK		1326
 comtech_router		MACH_COMTECH_ROUTER	COMTECH_ROUTER		1327
 sbc2410x		MACH_SBC2410X		SBC2410X		1328
 at4x0bd			MACH_AT4X0BD		AT4X0BD			1329
-cbifr			MACH_CBIFR		CBIFR			1330
+mp200			MACH_MP200		MP200			1330
 arcom_quantum		MACH_ARCOM_QUANTUM	ARCOM_QUANTUM		1331
 matrix520		MACH_MATRIX520		MATRIX520		1332
 matrix510		MACH_MATRIX510		MATRIX510		1333
diff --git a/drivers/leds/leds-gpio.c b/drivers/leds/leds-gpio.c
index b13bd29..266828a 100644
--- a/drivers/leds/leds-gpio.c
+++ b/drivers/leds/leds-gpio.c
@@ -190,8 +190,10 @@ static int gpio_led_resume(struct platform_device *pdev)
 static struct platform_driver gpio_led_driver = {
 	.probe		= gpio_led_probe,
 	.remove		= __devexit_p(gpio_led_remove),
+#ifndef CONFIG_ARCH_MP200
 	.suspend	= gpio_led_suspend,
 	.resume		= gpio_led_resume,
+#endif
 	.driver		= {
 		.name	= "leds-gpio",
 		.owner	= THIS_MODULE,
-- 
1.6.5.2

