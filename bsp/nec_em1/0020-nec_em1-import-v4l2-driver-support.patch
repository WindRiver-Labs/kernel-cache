From 192112d8e19f47351831366093b5669483fb9e7f Mon Sep 17 00:00:00 2001
From: Kazuya Tsukamoto <kazuya.tsukamoto@necel.com>
Date: Mon, 9 Nov 2009 13:42:43 +0900
Subject: [PATCH 20/29] nec_em1: import v4l2 driver support

This is a source code for v4l2 API.

This driver uses v4l2 API, but not all functions are supported based
on the specifications of the chip. For example,
API(VIDIOC_G_EFFECT, VIDIOC_S_EFFECT) or original return value.
This will be updated in the future.

Signed-off-by: Kazuya Tsukamoto <kazuya.tsukamoto@necel.com>
---
 drivers/media/video/Kconfig                  |    2 +
 drivers/media/video/Makefile                 |    2 +
 drivers/media/video/mp200/Kconfig            |    7 +
 drivers/media/video/mp200/Makefile           |    7 +
 drivers/media/video/mp200/mp200_v4l2_core.c  | 4359 ++++++++++++++++++++++++++
 drivers/media/video/mp200/mp200_v4l2_core.h  |  322 ++
 drivers/media/video/mp200/mp200_v4l2_ipu.h   |  100 +
 drivers/media/video/mp200/mp200_v4l2_time.h  |   63 +
 drivers/media/video/videobuf-core.c          |  372 +++-
 include/linux/videodev2.h                    |   71 +
 include/media/videobuf-core.h                |   67 +
 11 files changed, 5353 insertions(+), 19 deletions(-)
 create mode 100644 drivers/media/video/mp200/Kconfig
 create mode 100644 drivers/media/video/mp200/Makefile
 create mode 100644 drivers/media/video/mp200/mp200_v4l2_core.c
 create mode 100644 drivers/media/video/mp200/mp200_v4l2_core.h
 create mode 100644 drivers/media/video/mp200/mp200_v4l2_debug.h
 create mode 100644 drivers/media/video/mp200/mp200_v4l2_ipu.h
 create mode 100644 drivers/media/video/mp200/mp200_v4l2_perf.h
 create mode 100644 drivers/media/video/mp200/mp200_v4l2_time.h

diff --git a/drivers/media/video/Kconfig b/drivers/media/video/Kconfig
index f914577..14c7559 100644
--- a/drivers/media/video/Kconfig
+++ b/drivers/media/video/Kconfig
@@ -993,4 +993,6 @@ config VIDEO_SH_MOBILE_CEU
 	---help---
 	  This is a v4l2 driver for the SuperH Mobile CEU Interface
 
+source "drivers/media/video/mp200/Kconfig"
+
 endif # VIDEO_CAPTURE_DRIVERS
diff --git a/drivers/media/video/Makefile b/drivers/media/video/Makefile
index 3e580e8..62d6e4d 100644
--- a/drivers/media/video/Makefile
+++ b/drivers/media/video/Makefile
@@ -145,6 +145,8 @@ obj-$(CONFIG_SOC_CAMERA_PLATFORM)	+= soc_camera_platform.o
 
 obj-$(CONFIG_VIDEO_AU0828) += au0828/
 
+obj-$(CONFIG_VIDEO_MP200) += mp200/ videobuf-core.o
+
 obj-$(CONFIG_USB_VIDEO_CLASS)	+= uvc/
 
 EXTRA_CFLAGS += -Idrivers/media/dvb/dvb-core
diff --git a/drivers/media/video/mp200/Kconfig b/drivers/media/video/mp200/Kconfig
new file mode 100644
index 0000000..118c76c
--- /dev/null
+++ b/drivers/media/video/mp200/Kconfig
@@ -0,0 +1,7 @@
+
+config VIDEO_MP200
+	bool "MP200 Video for Linux2 driver"
+	depends on VIDEO_DEV && ARCH_MP200 && MP200_IPU
+	default y
+	select VIDEO_BUF
+
diff --git a/drivers/media/video/mp200/Makefile b/drivers/media/video/mp200/Makefile
new file mode 100644
index 0000000..9e34e32
--- /dev/null
+++ b/drivers/media/video/mp200/Makefile
@@ -0,0 +1,7 @@
+# Makefile for mp200_v4l2 driver for MP201
+
+mp200_v4l2-objs :=  mp200_v4l2_core.o
+
+obj-y += mp200_v4l2.o
+
+EXTRA_CFLAGS = -I$(src)/..
diff --git a/drivers/media/video/mp200/mp200_v4l2_core.c b/drivers/media/video/mp200/mp200_v4l2_core.c
new file mode 100644
index 0000000..bad65be
--- /dev/null
+++ b/drivers/media/video/mp200/mp200_v4l2_core.c
@@ -0,0 +1,4359 @@
+/*
+ * File Name	   : drivers/media/video/mp200/mp200_v4l2_core.c
+ * Function	   : Video for Linux driver for EM1 driver core
+ * Release Version :
+ * Release Date	   : 2009.10.21
+ *
+ * Copyright (C) NEC Electronics Corporation 2009
+ *
+ *
+ * This program is free software;you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by Free Softwere
+ * Foundation; either version 2 of License, or (at your option) any later
+ * version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warrnty of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
+ * details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; If not, write to the Free Software Foundation, Inc., 59 Temple
+ * Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/version.h>
+#include <linux/init.h>
+#include <linux/fs.h>
+#include <linux/vmalloc.h>
+#include <linux/slab.h>
+#include <linux/proc_fs.h>
+#include <linux/ctype.h>
+#include <linux/pagemap.h>
+#include <linux/mm.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/workqueue.h>
+#include <linux/kthread.h>
+#include <linux/fb.h>
+#include <linux/io.h>
+#include <linux/platform_device.h>
+
+#include <asm/processor.h>
+#include <asm/irq.h>
+
+#include <media/v4l2-common.h>
+
+#include <mach/ipu.h>
+#include <mach/rot.h>
+#include <mach/img.h>
+#include <mach/em1_mem.h>
+#include <media/v4l2-ioctl.h>
+#if defined(CONFIG_PM) || defined(CONFIG_DPM)
+#include <linux/freezer.h>
+#include <mach/pm.h>
+#endif /* CONFIG_PM || CONFIG_DPM */
+#include "../drivers/video/mp200/mp200_common.h"
+#include "../drivers/video/mp200/nts/mp200_nts.h"
+#include "../drivers/video/mp200/mp200_lcd.h"
+
+
+#define _V4L2_RT_THREAD 1 /* 1:enable  0:disable */
+#if _V4L2_RT_THREAD
+#include <linux/sched.h>
+#endif
+#include "mp200_v4l2_core.h"
+
+
+/*===============================================================*/
+/* v4l2 local configuration					 */
+/*===============================================================*/
+/* input yuv422planer	 */
+#define VF_YUV422PL  0 /* 0: disable  1: enable */ /***** ROT not support *****/
+/* input yuv422interleave */
+#define VF_YUV422PX  0 /* 0: disable  1: enable */ /***** not care *****/
+/* resize scaling check */
+#define RESIZE_CHECK 0 /* 0: disable  1: enable */ /***** not care *****/
+
+
+/*===============================================================*/
+/* debug parameters						 */
+/*===============================================================*/
+
+
+#define printk_err(fmt, arg...) \
+	do { \
+		printk(KERN_ERR DEV_NAME ": %s: " fmt, __func__, ## arg); \
+	} while (0)
+
+#define printk_wrn(fmt, arg...) \
+	do { \
+		printk(KERN_WARNING DEV_NAME ": %s: " fmt, __func__, ## arg); \
+	} while (0)
+
+#define printk_info(fmt, arg...) \
+	do { \
+		printk(KERN_INFO DEV_NAME ": " fmt, ## arg);	\
+	} while (0)
+
+#define printk_dbg(level, fmt, arg...) \
+	do { \
+		if (level > 0) \
+			printk(KERN_INFO DEV_NAME ": %s: " fmt, \
+				__func__, ## arg); \
+	} while (0)
+
+
+
+/*===============================================================*/
+/* kernel thread function					 */
+/*===============================================================*/
+static int   mp200_v4l2_thread_startup(struct mp200_v4l2_device *dev);
+static void  mp200_v4l2_thread_cleanup(struct mp200_v4l2_device *dev);
+static void  mp200_v4l2_thread_init(struct mp200_v4l2_device *dev);
+static void  mp200_v4l2_thread_main(struct mp200_v4l2_device *dev,
+				    struct th_object *th_obj);
+static inline int   mp200_v4l2_thread_rot(void *dev);
+static inline int   mp200_v4l2_thread_img(void *dev);
+static inline int   mp200_v4l2_thread_tmr(void *dev);
+static inline int   mp200_v4l2_thread_lcd(void *dev);
+
+static void *mp200_v4l2_reschedule(struct mp200_v4l2_device *dev,
+				   struct th_object *th_obj);
+static int   mp200_v4l2_next_proccess(struct mp200_v4l2_device *dev,
+				      struct videobuf_buffer *vb,
+				      enum buffer_select buf_sel,
+				      enum call_func_num call_func);
+static int   mp200_v4l2_chk_ipuimg(struct mp200_v4l2_device *dev,
+				   struct videobuf_buffer *vb);
+
+
+/*===============================================================*/
+/* kernel timer function					 */
+/*===============================================================*/
+static inline long  mp200_v4l2_tmr_cmpare_time(struct timeval *start,
+					       struct timeval *end);
+static inline long  mp200_v4l2_tmr_calc_waittime(struct mp200_v4l2_device *dev,
+						 struct videobuf_buffer *vb);
+static inline void  mp200_v4l2_tmr_chk_waittime(struct mp200_v4l2_device *dev,
+						struct videobuf_buffer *vb);
+static inline long
+	mp200_v4l2_tmr_calc_adjusttime(struct mp200_v4l2_device *dev);
+static inline void  mp200_v4l2_tmr_init(struct mp200_v4l2_device *dev);
+static	      int   mp200_v4l2_tmr_request(struct mp200_v4l2_device *dev,
+					   struct videobuf_buffer *vb,
+					   int dummy);
+static inline void  mp200_v4l2_tmr_callback_top(unsigned long data);
+#if ENABLE_DELAY
+static	      void  mp200_v4l2_tmr_callback_bottom_do(struct work_struct *num);
+#else
+static inline void
+	mp200_v4l2_tmr_callback_bottom_do(struct mp200_v4l2_device *dev);
+#endif
+
+
+/*===============================================================*/
+/* IPU proccessing function prottyped				 */
+/*===============================================================*/
+static void  mp200_v4l2_ipu_callback_main(struct mp200_v4l2_device *dev,
+					  struct th_object *th_obj,
+					  enum call_func_num call_func,
+					  int flag);
+static int   mp200_v4l2_ipu_request_main(struct mp200_v4l2_device *dev,
+					 struct videobuf_buffer *vb,
+					 struct th_object *th_obj,
+					 enum call_func_num call_func);
+/* ------------------ ROT request ops -------------------------------------- */
+static inline void  mp200_v4l2_rot_callback(unsigned long sequence, int flag);
+static inline int   mp200_v4l2_rot_request(struct mp200_v4l2_device *dev,
+					   struct videobuf_buffer *vb,
+					   int dummy);
+static	      int   mp200_v4l2_rot_make_req(struct mp200_v4l2_device *dev,
+					    struct videobuf_buffer *vb,
+					    int index,
+					    enum buffer_select buf_sel);
+/* ------------------ IMG request ops -------------------------------------- */
+static inline void  mp200_v4l2_img_callback(unsigned long sequence, int flag);
+static inline int   mp200_v4l2_img_request(struct mp200_v4l2_device *dev,
+					   struct videobuf_buffer *vb,
+					   int dummy);
+static	      int   mp200_v4l2_img_make_req(struct mp200_v4l2_device *dev,
+					    struct videobuf_buffer *vb,
+					    int index,
+					    enum buffer_select buf_sel);
+
+
+/*===============================================================*/
+/* LCD proccessing function prottyped				 */
+/*===============================================================*/
+static inline void *mp200_v4l2_lcd_set_outfunc(int output);
+static int mp200_v4l2_lcd_request(struct mp200_v4l2_device *dev,
+				  struct videobuf_buffer *vb,
+				  int call_flg);
+static	      void  mp200_v4l2_lcd_stop_do(struct work_struct *num);
+
+
+/*===============================================================*/
+/* videobuf queue operate function prottyped			 */
+/*===============================================================*/
+static inline void mp200_v4l2_core_vbq_release(struct videobuf_queue *q,
+					       struct videobuf_buffer *vb);
+static inline void mp200_v4l2_core_vbq_dqueue(struct videobuf_queue *q,
+					      struct videobuf_buffer *vb);
+static int mp200_v4l2_core_vbq_cancel(struct videobuf_queue *q,
+				      struct videobuf_buffer *vb);
+static void  mp200_v4l2_core_vbq_complete(void *arg1,
+					  void *arg,
+					  int err_flg);
+static inline void
+	mp200_v4l2_core_vbq_complete_skipped(struct list_head *vbq_stream);
+static void  mp200_v4l2_core_vbq_queue(struct videobuf_queue *q,
+				       struct videobuf_buffer *vb);
+static int mp200_v4l2_core_vbq_prepare(struct videobuf_queue *q,
+				       struct videobuf_buffer *vb,
+				       enum v4l2_field field);
+static int mp200_v4l2_core_vbq_sizecheck_pix(struct videobuf_buffer *vb);
+static int mp200_v4l2_core_vbq_sizecheck_crop(struct videobuf_buffer *vb);
+static int mp200_v4l2_core_vbq_sizecheck(struct videobuf_queue *q,
+					 struct videobuf_buffer *vb);
+static int mp200_v4l2_core_vbq_setup(struct videobuf_queue *q,
+				      unsigned int *cnt,
+				      unsigned int *size);
+
+
+/*===============================================================*/
+/* IPU workbuffer						 */
+/*===============================================================*/
+static inline void  mp200_v4l2_core_wkb_init(struct mp200_v4l2_device *dev);
+static int mp200_v4l2_core_wkb_active(struct mp200_v4l2_device *dev,
+				       unsigned int cmd,
+				       void *arg);
+static int mp200_v4l2_core_wkb_chkbuf(struct v4l2_workbuffer *wbuf);
+static int mp200_v4l2_core_wkb_chksize(struct mp200_v4l2_device *dev,
+				       struct videobuf_buffer *vb);
+
+
+/*===============================================================*/
+/* systemcall function prottyped				 */
+/*===============================================================*/
+static inline int mp200_v4l2_ioc_g_output(struct mp200_v4l2_fh *fh,
+					   unsigned int *output);
+static int mp200_v4l2_ioc_s_output(struct mp200_v4l2_fh *fh,
+				   unsigned int *output);
+static int mp200_v4l2_ioc_g_fmt(struct mp200_v4l2_device *dev,
+				struct v4l2_format *fmt);
+static int mp200_v4l2_ioc_s_fmt(struct mp200_v4l2_device *dev,
+				struct v4l2_format *fmt);
+static int mp200_v4l2_ioc_g_crop(struct mp200_v4l2_device *dev,
+				 struct v4l2_crop *vc);
+static int mp200_v4l2_ioc_s_crop(struct mp200_v4l2_device *dev,
+				 struct v4l2_crop *vc);
+static int mp200_v4l2_ioc_g_ctrl(struct mp200_v4l2_device *dev,
+				 struct v4l2_control *vc);
+static int mp200_v4l2_ioc_s_ctrl(struct mp200_v4l2_device *dev,
+				 struct v4l2_control *vc);
+static int mp200_v4l2_ioc_g_effect(struct mp200_v4l2_device *dev,
+				   struct v4l2_effect *vef);
+static int mp200_v4l2_ioc_s_effect(struct mp200_v4l2_device *dev,
+				   struct v4l2_effect *vef);
+static inline int mp200_v4l2_ioc_reqbufs(struct mp200_v4l2_device *dev,
+					 struct videobuf_queue *vbq,
+					 struct v4l2_requestbuffers *req);
+static inline int mp200_v4l2_ioc_qbuf(struct mp200_v4l2_device *dev,
+				      struct videobuf_queue *vbq,
+				      struct v4l2_buffer *vb);
+static inline int mp200_v4l2_ioc_dqbuf(struct mp200_v4l2_device *dev,
+				       struct videobuf_queue *vbq,
+				       struct v4l2_buffer *vb,
+				       int f_flags);
+static int mp200_v4l2_ioc_streamon(struct mp200_v4l2_fh *fh,
+				   struct mp200_v4l2_device *dev);
+static int mp200_v4l2_ioc_streamoff(struct mp200_v4l2_fh *fh,
+				    struct mp200_v4l2_device *dev);
+static int mp200_v4l2_core_do_ioctl(struct inode *inode,
+				    struct file *file,
+				    unsigned int cmd,
+				    void *arg);
+static inline int mp200_v4l2_core_ioctl(struct inode *inode,
+					struct file *file,
+					unsigned int cmd,
+					unsigned long arg);
+static inline unsigned int mp200_v4l2_core_poll(struct file *file,
+						struct poll_table_struct *wait);
+static int mp200_v4l2_core_release(struct inode *inode, struct file *file);
+static int mp200_v4l2_core_open(struct inode *inode, struct file *file);
+#if defined(CONFIG_PM) || defined(CONFIG_DPM)
+static int mp200_v4l2_core_suspend(struct platform_device *pdev,
+				    pm_message_t state);
+static int mp200_v4l2_core_resume(struct platform_device *pdev);
+#endif /* CONFIG_PM || CONFIG_DPM */
+
+
+/*===============================================================*/
+/* file_operations						 */
+/*===============================================================*/
+static struct file_operations mp200_v4l2_core_fops = {
+	.owner		= THIS_MODULE,
+	.llseek		= no_llseek,
+	.ioctl		= mp200_v4l2_core_ioctl,
+	.poll		= mp200_v4l2_core_poll,
+	.open		= mp200_v4l2_core_open,
+	.release	= mp200_v4l2_core_release,
+};
+
+
+/*===============================================================*/
+/* device_driver						 */
+/*===============================================================*/
+static struct platform_driver mp200_v4l2_core_driver = {
+	.probe		= NULL,
+	.remove		= NULL,
+	.shutdown	= NULL,
+
+#if defined(CONFIG_PM) || defined(CONFIG_DPM)
+	.suspend	= mp200_v4l2_core_suspend,
+	.resume		= mp200_v4l2_core_resume,
+#else
+	.suspend	= NULL,
+	.resume		= NULL,
+#endif /* CONFIG_PM || CONFIG_DPM */
+
+	.driver.name	= DEV_NAME,
+	.driver.bus	= &platform_bus_type,
+};
+
+
+/*===============================================================*/
+/* platform_device						 */
+/*===============================================================*/
+static struct platform_device mp200_v4l2_core_device = {
+	.name	= DEV_NAME,
+	.dev	= {
+			.release	= NULL,
+		  },
+	.id	= 0,
+};
+
+
+/*===============================================================*/
+/* module parameters						 */
+/*===============================================================*/
+struct mp200_v4l2_device *mp200_dev;
+static int video_nr = -1;	/* video device minor (-1 ==> auto assign) */
+
+
+/*===============================================================*/
+/* kernel thread function					 */
+/*===============================================================*/
+/*****************************************************************************
+* MODULE   : mp200_v4l2_thread_startup
+* FUNCTION :
+* RETURN   :
+* NOTE	   :
+* CREATE   : 2008/01/15 M.Haguro
+* UPDATE   :
+******************************************************************************/
+static int mp200_v4l2_thread_startup(struct mp200_v4l2_device *dev)
+{
+	mp200_v4l2_thread_init(dev);
+
+	init_waitqueue_head(&dev->th_rot.th_idle);
+	init_waitqueue_head(&dev->th_rot.th_busy);
+	init_waitqueue_head(&dev->th_img.th_idle);
+	init_waitqueue_head(&dev->th_img.th_busy);
+	init_waitqueue_head(&dev->th_tmr.th_idle);
+	init_waitqueue_head(&dev->th_tmr.th_busy);
+	init_waitqueue_head(&dev->th_lcd.th_idle);
+	init_waitqueue_head(&dev->th_lcd.th_busy);
+
+	/*----------------------*/
+	/* create kernel thread */
+	/*----------------------*/
+	dev->th_rot.th = kthread_run(mp200_v4l2_thread_rot,
+				     dev,
+				     dev->th_rot.th_name);
+	if (IS_ERR(dev->th_rot.th))
+		return -1;
+
+	dev->th_img.th = kthread_run(mp200_v4l2_thread_img,
+				     dev,
+				     dev->th_img.th_name);
+	if (IS_ERR(dev->th_img.th))
+		return -1;
+
+	dev->th_tmr.th = kthread_run(mp200_v4l2_thread_tmr,
+				     dev,
+				     dev->th_tmr.th_name);
+	if (IS_ERR(dev->th_tmr.th))
+		return -1;
+
+	dev->th_lcd.th = kthread_run(mp200_v4l2_thread_lcd,
+				     dev,
+				     dev->th_lcd.th_name);
+	if (IS_ERR(dev->th_lcd.th))
+		return -1;
+
+	return 0;
+}
+
+
+/*****************************************************************************
+* MODULE   : mp200_v4l2_thread_cleanup
+* FUNCTION :
+* RETURN   :
+* NOTE	   :
+* CREATE   : 2008/01/15 M.Haguro
+* UPDATE   :
+******************************************************************************/
+static void mp200_v4l2_thread_cleanup(struct mp200_v4l2_device *dev)
+{
+	mp200_v4l2_thread_init(dev);
+
+	/*-------------------------*/
+	/* discreate kernel thread */
+	/*-------------------------*/
+	wake_up_interruptible(&dev->th_rot.th_idle);
+	wake_up_interruptible(&dev->th_rot.th_buf->buf_busy);
+	wake_up_interruptible(&dev->th_rot.th_busy);
+	wake_up_interruptible(&dev->th_img.th_idle);
+	wake_up_interruptible(&dev->th_img.th_buf->buf_busy);
+	wake_up_interruptible(&dev->th_img.th_busy);
+	wake_up_interruptible(&dev->th_tmr.th_idle);
+	wake_up_interruptible(&dev->th_tmr.th_busy);
+	wake_up_interruptible(&dev->th_lcd.th_idle);
+	wake_up_interruptible(&dev->th_lcd.th_busy);
+
+	/*-------------------------*/
+	/* ROT thread uninitialize */
+	/*-------------------------*/
+	if (dev->th_rot.th)
+		kthread_stop(dev->th_rot.th);
+	kfree(dev->th_rot.th_buf);
+	memset(&dev->th_rot, 0, sizeof(struct th_object));
+
+	/*-------------------------*/
+	/* IMG thread uninitialize */
+	/*-------------------------*/
+	if (dev->th_img.th)
+		kthread_stop(dev->th_img.th);
+	kfree(dev->th_img.th_buf);
+	memset(&dev->th_img, 0, sizeof(struct th_object));
+
+	/*-------------------------*/
+	/* TMR thread uninitialize */
+	/*-------------------------*/
+	if (dev->th_tmr.th)
+		kthread_stop(dev->th_tmr.th);
+	memset(&dev->th_tmr, 0, sizeof(struct th_object));
+
+	/*-------------------------*/
+	/* LCD thread uninitialize */
+	/*-------------------------*/
+	if (dev->th_lcd.th)
+		kthread_stop(dev->th_lcd.th);
+	memset(&dev->th_lcd, 0, sizeof(struct th_object));
+}
+
+
+/*****************************************************************************
+* MODULE   : mp200_v4l2_thread_init
+* FUNCTION :
+* RETURN   :
+* NOTE	   :
+* CREATE   : 2008/01/15 M.Haguro
+* UPDATE   :
+******************************************************************************/
+static void mp200_v4l2_thread_init(struct mp200_v4l2_device *dev)
+{
+	int i;
+
+	/*-----------------------*/
+	/* ROT thread initialize */
+	/*-----------------------*/
+	dev->th_rot.th_name		      = "kv4l2_rot";
+	dev->th_rot.th_idle_flag	      = STATE_QUEUED_IDLE;
+	dev->th_rot.th_idle_fixed	      = STATE_QUEUED_ROT_PREPARED;
+	dev->th_rot.th_busy_fixed	      = STATE_QUEUED_ROT_QUEUED;
+	dev->th_rot.call_request	      = (void *)mp200_v4l2_rot_request;
+	/* ROT temp buffer init */
+	if (dev->th_rot.th_buf == NULL) {
+		dev->th_rot.th_buf = kmalloc(sizeof(struct buf_object),
+					      GFP_KERNEL);
+	}
+	memset(dev->th_rot.th_buf, 0, sizeof(struct buf_object));
+	init_waitqueue_head(&dev->th_rot.th_buf->buf_busy);
+
+	for (i = 0; i < NUM_BUF_V4L2; i++) {
+		dev->th_rot.th_buf->buf[i].state  = TMPBUF_IDLE;
+		dev->th_rot.th_buf->buf[i].paddr  = dev->workbuf.rot_addr
+		 + (((dev->workbuf.rot_size / NUM_BUF_V4L2) & ~0x3) * i);
+	}
+	dev->th_rot.th_buf->make_request      = (void *)mp200_v4l2_rot_make_req;
+	dev->th_rot.th_buf->callback	      = (void *)mp200_v4l2_rot_callback;
+	dev->th_rot.th_buf->ipu_hw_func	      = IPU_HW_FUNC_ROT;
+
+	/*-----------------------*/
+	/* IMG thread initialize */
+	/*-----------------------*/
+	dev->th_img.th_name		      = "kv4l2_img";
+	dev->th_img.th_idle_flag	      = STATE_QUEUED_IDLE;
+	dev->th_img.th_idle_fixed	      = STATE_QUEUED_IMG_PREPARED;
+	dev->th_img.th_busy_fixed	      = STATE_QUEUED_IMG_QUEUED;
+	dev->th_img.call_request	      = (void *)mp200_v4l2_img_request;
+	/* IMG temp buffer init */
+	if (dev->th_img.th_buf == NULL) {
+		dev->th_img.th_buf = kmalloc(sizeof(struct buf_object),
+					      GFP_KERNEL);
+	}
+	memset(dev->th_img.th_buf, 0, sizeof(struct buf_object));
+	init_waitqueue_head(&dev->th_img.th_buf->buf_busy);
+
+	for (i = 0; i < NUM_BUF_V4L2; i++) {
+		dev->th_img.th_buf->buf[i].state  = TMPBUF_IDLE;
+		dev->th_img.th_buf->buf[i].paddr  = dev->workbuf.img_addr
+		 + (((dev->workbuf.img_size / NUM_BUF_V4L2) & ~0x3) * i);
+	}
+	dev->th_img.th_buf->make_request      = (void *)mp200_v4l2_img_make_req;
+	dev->th_img.th_buf->callback	      = (void *)mp200_v4l2_img_callback;
+	dev->th_img.th_buf->ipu_hw_func	      = IPU_HW_FUNC_IMG;
+
+	/*-----------------------*/
+	/* TMR thread initialize */
+	/*-----------------------*/
+	dev->th_tmr.th_name		      = "kv4l2_tmr";
+	dev->th_tmr.th_idle_flag	      = STATE_QUEUED_IDLE;
+	dev->th_tmr.th_idle_fixed	      = STATE_QUEUED_TMR_PREPARED;
+	dev->th_tmr.th_busy_fixed	      = STATE_QUEUED_TMR_QUEUED;
+	dev->th_tmr.call_request	      = (void *)mp200_v4l2_tmr_request;
+	/* temp buffer not used */
+	dev->th_tmr.th_buf		      = NULL;
+
+	/*-----------------------*/
+	/* LCD thread initialize */
+	/*-----------------------*/
+	dev->th_lcd.th_name		      = "kv4l2_lcd";
+	dev->th_lcd.th_idle_flag	      = STATE_QUEUED_IDLE;
+	dev->th_lcd.th_idle_fixed	      = STATE_QUEUED_LCD_PREPARED;
+	dev->th_lcd.th_busy_fixed	      = STATE_QUEUED_LCD_QUEUED;
+	dev->th_lcd.call_request	      = (void *)mp200_v4l2_lcd_request;
+	/* temp buffer not used */
+	dev->th_lcd.th_buf		      = NULL;
+}
+
+
+/*****************************************************************************
+* MODULE   : mp200_v4l2_thread_main
+* FUNCTION :
+* RETURN   :
+* NOTE	   :
+* CREATE   : 2008/01/15 M.Haguro
+* UPDATE   :
+******************************************************************************/
+static void mp200_v4l2_thread_main(struct mp200_v4l2_device *dev,
+ struct th_object *th_obj)
+{
+	struct videobuf_buffer *vb;
+
+#if defined(CONFIG_PM) || defined(CONFIG_DPM)
+	try_to_freeze();
+#endif /* CONFIG_PM || CONFIG_DPM */
+
+	vb = mp200_v4l2_reschedule(dev, th_obj);
+	if (vb == NULL) {
+		/* Queue is free */
+		wait_event_interruptible(th_obj->th_idle,
+		 (th_obj->th_idle_flag == th_obj->th_idle_fixed));
+	} else {
+		if (th_obj->th_buf) {
+			int i;
+			for (i = 0; i < NUM_BUF_V4L2; i++) {
+				if (th_obj->th_buf->buf[i].state == TMPBUF_IDLE)
+					break;
+			}
+			if (i >= NUM_BUF_V4L2) {
+#if (NUM_BUF_V4L2 == 3)
+				wait_event_interruptible(
+					th_obj->th_buf->buf_busy,
+					(th_obj->th_buf->buf[BUF_A].state ==
+					TMPBUF_IDLE ||
+					th_obj->th_buf->buf[BUF_B].state ==
+					TMPBUF_IDLE ||
+					th_obj->th_buf->buf[BUF_C].state ==
+					TMPBUF_IDLE));
+#else /* (NUM_BUF_V4L2 == 2) */
+				wait_event_interruptible(
+					th_obj->th_buf->buf_busy,
+					(th_obj->th_buf->buf[BUF_A].state ==
+					TMPBUF_IDLE ||
+					th_obj->th_buf->buf[BUF_B].state ==
+					TMPBUF_IDLE));
+#endif
+			}
+		}
+
+		/* call request function */
+		if (!th_obj->call_request(dev, vb, STREAM_PLAYBACK)) {
+			/* processing request */
+			wait_event_interruptible(th_obj->th_busy,
+			 (vb->state_queued != th_obj->th_busy_fixed));
+		}
+	}
+}
+
+/*****************************************************************************
+* MODULE   : mp200_v4l2_thread_rot
+* FUNCTION : start to run request in IPU-ROT Request's queue.(ROT thread)
+* RETURN   : 0
+* NOTE	   :
+* CREATE   : 2008/01/15 M.Haguro
+* UPDATE   :
+******************************************************************************/
+static inline int mp200_v4l2_thread_rot(void *dev)
+{
+	/* set thread priority */
+#if _V4L2_RT_THREAD /* RT thread */
+	struct sched_param param = { .sched_priority = V4L2_THREAD_PRIORITY };
+	sched_setscheduler(current, SCHED_FIFO, &param);
+#else /* Normal thread */
+	set_user_nice(current, V4L2_THREAD_NICE);
+#endif
+
+	while (!kthread_should_stop()) {
+		mp200_v4l2_thread_main(dev,
+		 &((struct mp200_v4l2_device *)dev)->th_rot);
+	}
+	return 0;
+}
+
+
+/*****************************************************************************
+* MODULE   : mp200_v4l2_thread_img
+* FUNCTION : start to run request in IPU-IMG Request's queue.(IMG thread)
+* RETURN   : 0
+* NOTE	   :
+* CREATE   : 2008/01/15 M.Haguro
+* UPDATE   :
+******************************************************************************/
+static inline int mp200_v4l2_thread_img(void *dev)
+{
+	/* set thread priority */
+#if _V4L2_RT_THREAD /* RT thread */
+	struct sched_param param = { .sched_priority = V4L2_THREAD_PRIORITY };
+	sched_setscheduler(current, SCHED_FIFO, &param);
+#else /* Normal thread */
+	set_user_nice(current, V4L2_THREAD_NICE);
+#endif
+
+	while (!kthread_should_stop()) {
+		mp200_v4l2_thread_main(dev,
+		 &((struct mp200_v4l2_device *)dev)->th_img);
+	}
+	return 0;
+}
+
+
+/*****************************************************************************
+* MODULE   : mp200_v4l2_thread_tmr
+* FUNCTION : start to run request in TIMER Request's queue.(TMR thread)
+* RETURN   : 0
+* NOTE	   :
+* CREATE   : 2008/01/15 M.Haguro
+* UPDATE   :
+******************************************************************************/
+static inline int mp200_v4l2_thread_tmr(void *dev)
+{
+	/* set thread priority */
+#if _V4L2_RT_THREAD /* RT thread */
+	struct sched_param param = { .sched_priority = V4L2_THREAD_PRIORITY };
+	sched_setscheduler(current, SCHED_FIFO, &param);
+#else /* Normal thread */
+	set_user_nice(current, V4L2_THREAD_NICE);
+#endif
+
+	while (!kthread_should_stop()) {
+		mp200_v4l2_thread_main(dev,
+		 &((struct mp200_v4l2_device *)dev)->th_tmr);
+	}
+	return 0;
+}
+
+
+/*****************************************************************************
+* MODULE   : mp200_v4l2_thread_lcd
+* FUNCTION : start to run request in LCD Request's queue.(LCD thread)
+* RETURN   : 0
+* NOTE	   :
+* CREATE   : 2008/01/15 M.Haguro
+* UPDATE   :
+******************************************************************************/
+static inline int mp200_v4l2_thread_lcd(void *dev)
+{
+	/* set thread priority */
+#if _V4L2_RT_THREAD /* RT thread */
+	struct sched_param param = { .sched_priority = V4L2_THREAD_PRIORITY };
+	sched_setscheduler(current, SCHED_FIFO, &param);
+#else /* Normal thread */
+	set_user_nice(current, V4L2_THREAD_NICE);
+#endif
+
+	while (!kthread_should_stop()) {
+		mp200_v4l2_thread_main(dev,
+		 &((struct mp200_v4l2_device *)dev)->th_lcd);
+	}
+	return 0;
+}
+
+
+/*****************************************************************************
+* MODULE   : mp200_v4l2_reschedule
+* FUNCTION : call next queue.
+* RETURN   : -
+* NOTE	   :
+* CREATE   : 2008/01/15 M.Haguro
+* UPDATE   :
+******************************************************************************/
+static void *mp200_v4l2_reschedule(struct mp200_v4l2_device *dev,
+	struct th_object *th_obj)
+{
+	struct videobuf_queue  *q  = NULL;
+	struct videobuf_buffer *vb = NULL;
+	struct list_head       *list;
+	unsigned long flags;
+
+	spin_lock_irqsave(&dev->vbq_lock, flags);
+
+	if (dev->streaming) {
+		q = &dev->streaming->vbq;
+		list_for_each(list, &q->stream)
+		{
+			vb = list_entry(list, struct videobuf_buffer, stream);
+			switch (vb->state) {
+			case VIDEOBUF_PREPARED:
+				vb->state = VIDEOBUF_QUEUED;
+				mp200_v4l2_next_proccess(dev, vb, 0,
+				 RESCHEDULE);
+				/* FALL THROUGH */
+			case VIDEOBUF_QUEUED:
+				if (vb->state_queued < th_obj->th_idle_fixed) {
+					/* don't process it for status_queued
+					  that is smaller than call_function. */
+					th_obj->th_idle_flag =
+						STATE_QUEUED_IDLE;
+					spin_unlock_irqrestore(&dev->vbq_lock,
+					 flags);
+					return NULL;
+				} else if (vb->state_queued ==
+					th_obj->th_idle_fixed) {
+					spin_unlock_irqrestore(&dev->vbq_lock,
+					 flags);
+					return vb;
+				} else{
+					/* search next queue */
+					break;
+				}
+			case VIDEOBUF_CANCELED:
+				if (vb->state_queued != STATE_QUEUED_DONE) {
+					if (vb->state_queued ==
+						th_obj->th_idle_fixed) {
+						spin_unlock_irqrestore(
+							&dev->vbq_lock, flags);
+						return vb;
+					}
+				}
+				break;
+			default:
+				/* search next queue */
+				break;
+			}
+		}
+	}
+
+	th_obj->th_idle_flag = STATE_QUEUED_IDLE;
+	spin_unlock_irqrestore(&dev->vbq_lock, flags);
+	return NULL;
+}
+
+
+/*****************************************************************************
+* MODULE   : mp200_v4l2_next_proccess
+* FUNCTION : Allocate & Set next Queue status.
+* RETURN   :
+* NOTE	   : request() & callback() allways call this function.
+* CREATE   : 2008/01/15 M.Haguro
+* UPDATE   :
+******************************************************************************/
+static int mp200_v4l2_next_proccess(struct mp200_v4l2_device *dev,
+ struct videobuf_buffer *vb, enum buffer_select buf_sel,
+ enum call_func_num call_func)
+{
+	unsigned long flags;
+	spin_lock_irqsave(&dev->vbq_lock, flags);
+
+	if (call_func == VBQ_DQUEUE) {
+		vb->state_queued    = STATE_QUEUED_IDLE;
+		vb->state_proccess |= STATE_PROCCESS_IDLE;
+		spin_unlock_irqrestore(&dev->vbq_lock, flags);
+		return -1;
+	}
+
+	/* phase1 **************/
+	/* check CANCELED task */
+	if ((vb->state == VIDEOBUF_CANCELED || vb->state == VIDEOBUF_ERROR) ||
+	   (vb->state == VIDEOBUF_DQBUF_PERMIT && dev->vb_old == NULL)) {
+
+		/* initialize buffer */
+		switch (vb->state_queued) {
+		case STATE_QUEUED_LCD_PREPARED:	/* FALL THROUGH */
+		case STATE_QUEUED_TMR_QUEUED:	/* FALL THROUGH */
+		case STATE_QUEUED_TMR_PREPARED:	/* FALL THROUGH */
+		case STATE_QUEUED_IMG_QUEUED:	/* FALL THROUGH */
+		case STATE_QUEUED_DONE:
+			/* free buffer for IMG */
+			if (vb->img_buf) {
+				vb->img_buf->state = TMPBUF_IDLE;
+				vb->img_buf	   = NULL;
+			}
+			break;
+		default:
+			break;
+		}
+		switch (vb->state_queued) {
+		case STATE_QUEUED_LCD_PREPARED:	/* FALL THROUGH */
+		case STATE_QUEUED_TMR_QUEUED:	/* FALL THROUGH */
+		case STATE_QUEUED_TMR_PREPARED:	/* FALL THROUGH */
+		case STATE_QUEUED_IMG_QUEUED:	/* FALL THROUGH */
+		case STATE_QUEUED_IMG_PREPARED:	/* FALL THROUGH */
+		case STATE_QUEUED_ROT_QUEUED:	/* FALL THROUGH */
+		case STATE_QUEUED_DONE:
+			/* free buffer for ROT */
+			if (vb->rot_buf) {
+				vb->rot_buf->state = TMPBUF_IDLE;
+				vb->rot_buf	   = NULL;
+			}
+			break;
+		default:
+			break;
+		}
+
+		/* to next proccess */
+		switch (call_func) {
+		case ROT_REQUEST: /* FALL THROUGH */
+		case ROT_CALLBACK:
+			DEL_MIXING(ROT_MIXING, ROT_MIXING_SFT);
+			if (vb->state_proccess & STATE_PROCCESS_ROT_COMPLETE
+			 || vb->state_proccess & STATE_PROCCESS_ROT_QUEUED) {
+				wake_up_interruptible(
+					&dev->th_rot.th_buf->buf_busy);
+			}
+			wake_up_interruptible(&dev->th_rot.th_busy);
+			break;
+		case IMG_REQUEST: /* FALL THROUGH */
+		case IMG_CALLBACK:
+			DEL_MIXING(IMG_MIXING, IMG_MIXING_SFT);
+			if (vb->state_proccess & STATE_PROCCESS_IMG_COMPLETE
+			 || vb->state_proccess & STATE_PROCCESS_IMG_QUEUED) {
+				wake_up_interruptible(
+					&dev->th_img.th_buf->buf_busy);
+			}
+			if (vb->state_proccess & STATE_PROCCESS_ROT_COMPLETE
+			 || vb->state_proccess & STATE_PROCCESS_ROT_QUEUED) {
+				wake_up_interruptible(
+					&dev->th_rot.th_buf->buf_busy);
+			}
+			wake_up_interruptible(&dev->th_img.th_busy);
+			break;
+		case TMR_REQUEST: /* FALL THROUGH */
+		case TMR_CALLBACK:
+			DEL_MIXING(TMR_MIXING, TMR_MIXING_SFT);
+			if (vb->state_proccess & STATE_PROCCESS_IMG_COMPLETE
+			 || vb->state_proccess & STATE_PROCCESS_IMG_QUEUED) {
+				wake_up_interruptible(
+					&dev->th_img.th_buf->buf_busy);
+			}
+			if (vb->state_proccess & STATE_PROCCESS_ROT_COMPLETE
+			 || vb->state_proccess & STATE_PROCCESS_ROT_QUEUED) {
+				wake_up_interruptible(
+					&dev->th_rot.th_buf->buf_busy);
+			}
+			wake_up_interruptible(&dev->th_tmr.th_busy);
+			break;
+		case LCD_REQUEST: /* FALL THROUGH */
+		case LCD_CALLBACK:
+			DEL_MIXING(LCD_MIXING, LCD_MIXING_SFT);
+			if (vb->state_proccess & STATE_PROCCESS_IMG_COMPLETE
+			 || vb->state_proccess & STATE_PROCCESS_IMG_QUEUED) {
+				wake_up_interruptible(
+					&dev->th_img.th_buf->buf_busy);
+			}
+			if (vb->state_proccess & STATE_PROCCESS_ROT_COMPLETE
+			 || vb->state_proccess & STATE_PROCCESS_ROT_QUEUED) {
+				wake_up_interruptible(
+					&dev->th_rot.th_buf->buf_busy);
+			}
+			wake_up_interruptible(&dev->th_lcd.th_busy);
+			break;
+		default:
+			break;
+		}
+
+		vb->state_queued    = STATE_QUEUED_DONE;
+		vb->state_proccess |= STATE_PROCCESS_LCD_COMPLETE;
+		spin_unlock_irqrestore(&dev->vbq_lock, flags);
+		return -1;
+	} else if (vb->state != VIDEOBUF_PREPARED
+		 && vb->state != VIDEOBUF_QUEUED
+		 && vb->state != VIDEOBUF_ACTIVE
+		 && vb->state != VIDEOBUF_DONE) {
+		switch (call_func) {
+		case ROT_REQUEST: /* FALL THROUGH */
+		case ROT_CALLBACK:
+			DEL_MIXING(ROT_MIXING, ROT_MIXING_SFT);
+			break;
+		case IMG_REQUEST: /* FALL THROUGH */
+		case IMG_CALLBACK:
+			DEL_MIXING(IMG_MIXING, IMG_MIXING_SFT);
+			break;
+		case TMR_REQUEST: /* FALL THROUGH */
+		case TMR_CALLBACK:
+			DEL_MIXING(TMR_MIXING, TMR_MIXING_SFT);
+			break;
+		case LCD_REQUEST: /* FALL THROUGH */
+		case LCD_CALLBACK:
+			DEL_MIXING(LCD_MIXING, LCD_MIXING_SFT);
+			break;
+		default:
+			break;
+		}
+		spin_unlock_irqrestore(&dev->vbq_lock, flags);
+		return 0;
+	}
+
+	/* phase2 ********************/
+	/* set flag to next proccess */
+	switch (call_func) {
+	case VBQ_DQUEUE:
+		break;
+
+	case LCD_CALLBACK:
+		DEL_MIXING(LCD_MIXING, LCD_MIXING_SFT);
+		if (dev->vb_old_refresh) {
+			if (dev->vb_old_refresh->img_buf
+			 && (dev->vb_old_refresh->state_proccess
+			     & STATE_PROCCESS_IMG_COMPLETE)) {
+				dev->vb_old_refresh->img_buf->state =
+					TMPBUF_IDLE;
+				dev->vb_old_refresh->img_buf	    = NULL;
+			} else if (dev->vb_old_refresh->rot_buf
+			 && (dev->vb_old_refresh->state_proccess
+			     & STATE_PROCCESS_ROT_COMPLETE)) {
+				dev->vb_old_refresh->rot_buf->state =
+					TMPBUF_IDLE;
+				dev->vb_old_refresh->rot_buf	    = NULL;
+			}
+		}
+		dev->vb_old_refresh = vb;
+		if (vb->img_buf
+		 && (vb->state_proccess & STATE_PROCCESS_IMG_COMPLETE)) {
+			vb->img_buf->state = TMPBUF_LCD_WRITE;
+		} else if (vb->rot_buf
+		 && (vb->state_proccess & STATE_PROCCESS_ROT_COMPLETE)) {
+			vb->rot_buf->state = TMPBUF_LCD_WRITE;
+		}
+		vb->state_queued    = STATE_QUEUED_DONE;
+		vb->state_proccess |= STATE_PROCCESS_LCD_COMPLETE;
+		break;
+
+	case VBQ_COMPLETE:
+		break;
+
+	case ROT_REQUEST:
+		ADD_MIXING(ROT_MIXING, ROT_MIXING_SFT);
+		vb->state_queued    = STATE_QUEUED_ROT_QUEUED;
+		vb->state_proccess |= STATE_PROCCESS_ROT_QUEUED;
+
+		vb->rot_buf	    = &dev->th_rot.th_buf->buf[buf_sel];
+		vb->rot_buf->state  = TMPBUF_ROT_WRITE;
+		break;
+	case IMG_REQUEST:
+		ADD_MIXING(IMG_MIXING, IMG_MIXING_SFT);
+		vb->state_queued    = STATE_QUEUED_IMG_QUEUED;
+		vb->state_proccess |= STATE_PROCCESS_IMG_QUEUED;
+
+		vb->img_buf	    = &dev->th_img.th_buf->buf[buf_sel];
+		vb->img_buf->state  = TMPBUF_IMG_WRITE;
+		break;
+	case TMR_REQUEST:
+		ADD_MIXING(TMR_MIXING, TMR_MIXING_SFT);
+		vb->state_queued    = STATE_QUEUED_TMR_QUEUED;
+		vb->state_proccess |= STATE_PROCCESS_TMR_QUEUED;
+		break;
+	case LCD_REQUEST:
+		ADD_MIXING(LCD_MIXING, LCD_MIXING_SFT);
+		vb->state_queued    = STATE_QUEUED_LCD_QUEUED;
+		vb->state_proccess |= STATE_PROCCESS_LCD_QUEUED;
+		break;
+
+	case VBQ_QUEUE:
+		/* FALL THROUGH */
+	case RESCHEDULE:
+		vb->state_proccess = STATE_PROCCESS_IDLE;
+
+		if (vb->save_effect.movie_angle) {
+			/* next process is IPU-ROT */
+			vb->state_queued	 = STATE_QUEUED_ROT_PREPARED;
+			dev->th_rot.th_idle_flag = dev->th_rot.th_idle_fixed;
+			break;
+		}
+		/* FALL THROUGH */
+	case ROT_CALLBACK:
+		if (call_func == ROT_CALLBACK) {
+			DEL_MIXING(ROT_MIXING, ROT_MIXING_SFT);
+			vb->state_proccess |= STATE_PROCCESS_ROT_COMPLETE;
+		}
+		if (mp200_v4l2_chk_ipuimg(dev, vb)) {
+			/* next process is IPU-IMG */
+			if (vb->state_proccess & STATE_PROCCESS_ROT_COMPLETE)
+				vb->rot_buf->state = TMPBUF_IMG_READ;
+
+			vb->state_queued	 = STATE_QUEUED_IMG_PREPARED;
+			dev->th_img.th_idle_flag = dev->th_img.th_idle_fixed;
+			break;
+		}
+		/* FALL THROUGH */
+	case IMG_CALLBACK:
+		if (call_func == IMG_CALLBACK) {
+			DEL_MIXING(IMG_MIXING, IMG_MIXING_SFT);
+			if (vb->state_proccess & STATE_PROCCESS_ROT_COMPLETE) {
+				vb->rot_buf->state = TMPBUF_IDLE;
+				vb->rot_buf	   = NULL;
+			}
+			vb->state_proccess |= STATE_PROCCESS_IMG_COMPLETE;
+		}
+		if (vb->state_frame != STATE_FRAME_IMMEDIATE) {
+			/* next process is TIMER */
+			vb->state_queued	 = STATE_QUEUED_TMR_PREPARED;
+			dev->th_tmr.th_idle_flag = dev->th_tmr.th_idle_fixed;
+			break;
+		}
+		/* FALL THROUGH */
+	case TMR_CALLBACK:
+		if (call_func == TMR_CALLBACK) {
+			DEL_MIXING(TMR_MIXING, TMR_MIXING_SFT);
+			vb->state_proccess |= STATE_PROCCESS_TMR_COMPLETE;
+		}
+		/* next process is LCD */
+		if (vb->state_proccess & STATE_PROCCESS_IMG_COMPLETE)
+			vb->img_buf->state = TMPBUF_LCD_READ;
+		else if (vb->state_proccess & STATE_PROCCESS_ROT_COMPLETE)
+			vb->rot_buf->state = TMPBUF_LCD_READ;
+
+		vb->state_queued	 = STATE_QUEUED_LCD_PREPARED;
+		dev->th_lcd.th_idle_flag = dev->th_lcd.th_idle_fixed;
+		break;
+	}
+
+	/* phase3 ******************/
+	/* wakeup to next proccess */
+	switch (call_func) {
+	case VBQ_DQUEUE:
+		break;
+
+	case LCD_CALLBACK:
+		if (vb->output == V4L2_OUTPUT_LCD)
+			wake_up_interruptible(&dev->th_lcd.th_busy);
+
+		if (vb->state_proccess & STATE_PROCCESS_IMG_COMPLETE)
+			wake_up_interruptible(&dev->th_img.th_buf->buf_busy);
+		else if (vb->state_proccess & STATE_PROCCESS_ROT_COMPLETE)
+			wake_up_interruptible(&dev->th_rot.th_buf->buf_busy);
+
+		break;
+
+	case VBQ_COMPLETE:
+		if (vb->output != V4L2_OUTPUT_LCD)
+			wake_up_interruptible(&dev->th_lcd.th_busy);
+
+		break;
+
+	case ROT_REQUEST:
+		break;
+	case IMG_REQUEST:
+		break;
+	case TMR_REQUEST:
+		break;
+	case LCD_REQUEST:
+		break;
+
+	case VBQ_QUEUE:
+		/* FALL THROUGH */
+	case RESCHEDULE:
+		if (vb->save_effect.movie_angle) {
+			/* next process is IPU-ROT */
+			wake_up_interruptible(&dev->th_rot.th_idle);
+			break;
+		}
+		/* FALL THROUGH */
+	case ROT_CALLBACK:
+		if (call_func == ROT_CALLBACK)
+			wake_up_interruptible(&dev->th_rot.th_busy);
+
+		if (mp200_v4l2_chk_ipuimg(dev, vb)) {
+			/* next process is IPU-IMG */
+			wake_up_interruptible(&dev->th_img.th_idle);
+			break;
+		}
+		/* FALL THROUGH */
+	case IMG_CALLBACK:
+		if (call_func == IMG_CALLBACK) {
+			if (vb->state_proccess & STATE_PROCCESS_ROT_COMPLETE)
+				wake_up_interruptible(
+					&dev->th_rot.th_buf->buf_busy);
+
+			wake_up_interruptible(&dev->th_img.th_busy);
+		}
+		if (vb->state_frame != STATE_FRAME_IMMEDIATE) {
+			/* next process is TIMER */
+			wake_up_interruptible(&dev->th_tmr.th_idle);
+			break;
+		}
+		/* FALL THROUGH */
+	case TMR_CALLBACK:
+		if (call_func == TMR_CALLBACK)
+			wake_up_interruptible(&dev->th_tmr.th_busy);
+
+		/* next process is LCD */
+		wake_up_interruptible(&dev->th_lcd.th_idle);
+		break;
+	}
+
+	spin_unlock_irqrestore(&dev->vbq_lock, flags);
+	return 0;
+}
+
+
+/*****************************************************************************
+* MODULE   : mp200_v4l2_chk_ipuimg
+* FUNCTION :
+* RETURN   : -
+* NOTE	   :
+* CREATE   : 2007/12/06 M.Haguro
+* UPDATE   :
+******************************************************************************/
+static int mp200_v4l2_chk_ipuimg(struct mp200_v4l2_device *dev,
+ struct videobuf_buffer *vb)
+{
+	unsigned long width, height;
+
+	if (vb->state_proccess & STATE_PROCCESS_ROT_COMPLETE) {
+		/* use IPU-ROT */
+		width  = vb->rot_buf->dst_data.hsize;
+		height = vb->rot_buf->dst_data.vsize;
+	} else{
+		/* not use IPU-ROT */
+		width  = vb->save_effect.source_crop.width;
+		height = vb->save_effect.source_crop.height;
+	}
+
+	if ((vb->save_effect.screen.width != 0)
+	 && (vb->save_effect.screen.height != 0)) {
+		if (vb->output == V4L2_OUTPUT_LCD) {
+			/* output LCD */
+			if ((vb->save_effect.screen.width != width)
+			 || (vb->save_effect.screen.height != height)) {
+				switch (vb->pixelformat) {
+#if VF_YUV422PL
+				/* YUV422 Planar *//* FALL THROUGH */
+				case V4L2_PIX_FMT_YUV422P:
+#endif
+				/* YUV420 Planar */
+				case V4L2_PIX_FMT_YVU420:
+					/* Resize & Color Format Convert
+					   for IMG */
+					return IMG_OP_MODE_03_BIT;
+				default:
+					/* Resize for IMG */
+					return IMG_OP_MODE_03_BIT;
+				}
+			}
+		}
+	}
+
+	return 0;
+}
+
+
+/*===============================================================*/
+/* kernel timer function					 */
+/*===============================================================*/
+/*****************************************************************************
+* MODULE   : mp200_v4l2_tmr_cmpare_time
+* FUNCTION : wait to call LCD driver function.
+* RETURN   : -
+* NOTE	   :
+* CREATE   : 2009/04/06 M.Haguro
+* UPDATE   :
+******************************************************************************/
+static inline long mp200_v4l2_tmr_cmpare_time(struct timeval *start,
+ struct timeval *end)
+{
+	long delta = 0;
+
+	if (end->tv_sec > start->tv_sec) {
+		delta = (end->tv_sec - start->tv_sec) * 1000;
+		if (end->tv_usec > start->tv_usec)
+			delta += (end->tv_usec - start->tv_usec) / 1000;
+		else
+			delta -= (start->tv_usec - end->tv_usec) / 1000;
+
+	} else if (end->tv_sec == start->tv_sec) {
+		if (end->tv_usec > start->tv_usec)
+			delta = (end->tv_usec - start->tv_usec) / 1000;
+		else
+			delta = STATE_FRAME_IMMEDIATE;
+
+	} else
+		delta = STATE_FRAME_IMMEDIATE;
+
+	return delta;
+}
+
+
+/*****************************************************************************
+* MODULE   : mp200_v4l2_tmr_calc_waittime
+* FUNCTION : wait to call LCD driver function.
+* RETURN   : -
+* NOTE	   :
+* CREATE   : 2008/01/17 M.Haguro
+* UPDATE   :
+******************************************************************************/
+static inline long mp200_v4l2_tmr_calc_waittime(struct mp200_v4l2_device *dev,
+ struct videobuf_buffer *vb)
+{
+	long adjust_time;
+
+	do_gettimeofday(&dev->timer.now_time);
+	dev->timer.wait_time =
+		mp200_v4l2_tmr_cmpare_time(&dev->timer.now_time, &vb->ts);
+	if (vb->output == V4L2_OUTPUT_LCD)
+		adjust_time = dev->timer.adjust_time_lcd;
+	else
+		adjust_time = dev->timer.adjust_time_ntsc;
+
+	return adjust_time;
+}
+
+
+/*****************************************************************************
+* MODULE   : mp200_v4l2_tmr_chk_waittime
+* FUNCTION : wait to call LCD driver function.
+* RETURN   : -
+* NOTE	   :
+* CREATE   : 2009/04/10 M.Haguro
+* UPDATE   :
+******************************************************************************/
+static inline void mp200_v4l2_tmr_chk_waittime(struct mp200_v4l2_device *dev,
+ struct videobuf_buffer *vb)
+{
+	long adjust_time = mp200_v4l2_tmr_calc_waittime(dev, vb);
+	long roundup;
+
+	if (vb->output == V4L2_OUTPUT_LCD)
+		roundup = ROUNDUP_ADJUST_LCD;
+	else if (vb->output == V4L2_OUTPUT_NTSC)
+		roundup = ROUNDUP_ADJUST_NTSC;
+	else
+		roundup = ROUNDUP_ADJUST_PAL;
+
+	adjust_time += roundup;
+
+	if (dev->timer.wait_time >= adjust_time)
+		dev->timer.wait_time -= adjust_time;
+	else
+		dev->timer.wait_time = STATE_FRAME_IMMEDIATE;
+}
+
+
+/*****************************************************************************
+* MODULE   : mp200_v4l2_tmr_calc_adjusttime
+* FUNCTION : wait to call LCD driver function.
+* RETURN   : -
+* NOTE	   :
+* CREATE   : 2008/01/17 M.Haguro
+* UPDATE   :
+******************************************************************************/
+static inline long mp200_v4l2_tmr_calc_adjusttime(struct mp200_v4l2_device *dev)
+{
+	long adjust_time;
+
+	do_gettimeofday(&dev->timer.comp_time);
+	adjust_time = mp200_v4l2_tmr_cmpare_time(&dev->timer.do_time,
+	 &dev->timer.comp_time);
+
+	return adjust_time;
+}
+
+
+/*****************************************************************************
+* MODULE   : mp200_v4l2_tmr_init
+* FUNCTION : wait to call LCD driver init function.
+* RETURN   : -
+* NOTE	   :
+* CREATE   : 2008/01/17 M.Haguro
+* UPDATE   :
+******************************************************************************/
+static inline void mp200_v4l2_tmr_init(struct mp200_v4l2_device *dev)
+{
+	dev->timer.adjust_time_lcd  = DEFAULT_ADJUST_LCD;
+	dev->timer.adjust_time_ntsc = DEFAULT_ADJUST_NTSC;
+
+	init_timer(&dev->timer.wait_timer);
+	dev->timer.wait_timer.function = mp200_v4l2_tmr_callback_top;
+	dev->timer.wait_timer.data = (unsigned long)dev;
+}
+
+
+/*****************************************************************************
+* MODULE   : mp200_v4l2_tmr_request
+* FUNCTION : wait to call LCD driver function.
+* RETURN   : 0: success
+* NOTE	   :
+* CREATE   : 2008/01/17 M.Haguro
+* UPDATE   :
+******************************************************************************/
+static int mp200_v4l2_tmr_request(struct mp200_v4l2_device *dev,
+	struct videobuf_buffer *vb, int dummy)
+{
+	int ret = 0;
+	unsigned long flags;
+
+	down(&dev->sem_lcdout);
+
+	spin_lock_irqsave(&dev->vbq_lock, flags);
+
+	/* check next queue status */
+	if (mp200_v4l2_next_proccess(dev, vb, 0, TMR_REQUEST)) {
+		ret = -1;
+		up(&dev->sem_lcdout); /* release semafore */
+	} else{
+		mp200_v4l2_tmr_chk_waittime(dev, vb);
+		dev->timer.vb	= vb;
+		vb->state_frame = STATE_FRAME_DONE;
+
+		if (dev->timer.wait_time >= 10) {
+			dev->timer.wait_timer.expires = jiffies
+			 + (dev->timer.wait_time * HZ / 1000);
+			add_timer(&dev->timer.wait_timer);
+		} else{
+#if ENABLE_DELAY
+			queue_work(dev->v4l2_workqueue,
+			 &dev->wk_tmr_callback_bottom);
+#else
+			mp200_v4l2_tmr_callback_bottom_do(dev);
+#endif
+		}
+	}
+	spin_unlock_irqrestore(&dev->vbq_lock, flags);
+	return ret;
+}
+
+
+/*****************************************************************************
+* MODULE   : mp200_v4l2_tmr_callback_top
+* FUNCTION : wait to call LCD driver function.
+* RETURN   : -
+* NOTE	   :
+* CREATE   : 2008/01/17 M.Haguro
+* UPDATE   :
+******************************************************************************/
+static inline void mp200_v4l2_tmr_callback_top(unsigned long data)
+{
+	struct mp200_v4l2_device *dev = (struct mp200_v4l2_device *)data;
+
+#if ENABLE_DELAY
+	queue_work(dev->v4l2_workqueue, &dev->wk_tmr_callback_bottom);
+#else
+	mp200_v4l2_tmr_callback_bottom_do(dev);
+#endif
+}
+
+
+/*****************************************************************************
+* MODULE   : mp200_v4l2_tmr_callback_bottom_do
+* FUNCTION : wait to call LCD driver function.
+* RETURN   : -
+* NOTE	   :
+* CREATE   : 2008/01/17 M.Haguro
+* UPDATE   :
+******************************************************************************/
+#if ENABLE_DELAY
+static void mp200_v4l2_tmr_callback_bottom_do(struct work_struct *num)
+{
+	struct mp200_v4l2_device *dev =
+		container_of(num, struct mp200_v4l2_device,
+			wk_tmr_callback_bottom);
+	struct videobuf_buffer	 *vb  = dev->timer.vb;
+	unsigned long flags;
+	long wait_time;
+#else
+static inline void
+mp200_v4l2_tmr_callback_bottom_do(struct mp200_v4l2_device *dev)
+{
+	struct videobuf_buffer *vb = dev->timer.vb;
+#endif
+	dev->timer.vb = NULL;
+
+#if ENABLE_DELAY
+	spin_lock_irqsave(&dev->vbq_lock, flags);
+	mp200_v4l2_tmr_chk_waittime(dev, vb);
+	wait_time = dev->timer.wait_time;
+	spin_unlock_irqrestore(&dev->vbq_lock, flags);
+
+	if (wait_time > 10)
+		msleep((unsigned int)wait_time);
+
+#endif
+
+	/* check next queue status */
+	if (mp200_v4l2_next_proccess(dev, vb, 0, TMR_CALLBACK)) {
+		if (down_trylock(&dev->sem_lcdout))
+			;
+
+		up(&dev->sem_lcdout); /* release semafore */
+	}
+}
+
+
+/*===============================================================*/
+/* IPU proccessing function prottyped				 */
+/*===============================================================*/
+/*****************************************************************************
+* MODULE   : mp200_v4l2_ipu_callback_main
+* FUNCTION : IPU-ROT driver callback function.
+* RETURN   : -
+* NOTE	   : When the animation rotation is completed/error,
+*	   : the IPU-ROT driver calls this function.
+* CREATE   : 2008/01/15 M.Haguro
+* UPDATE   :
+******************************************************************************/
+static void mp200_v4l2_ipu_callback_main(struct mp200_v4l2_device *dev,
+ struct th_object *th_obj, enum call_func_num call_func, int flag)
+{
+	unsigned long flags;
+	struct videobuf_buffer *vb = th_obj->th_buf->vb;
+
+	spin_lock_irqsave(&dev->vbq_lock, flags);
+	th_obj->th_buf->vb = NULL;
+
+	/* check callback flag */
+	if (flag != IPU_CALLBACK_SUCCESS)
+		vb->state = VIDEOBUF_CANCELED;
+
+	/* check next queue status */
+	if (mp200_v4l2_next_proccess(dev, vb, 0, call_func))
+		;
+
+	spin_unlock_irqrestore(&dev->vbq_lock, flags);
+}
+
+
+/*****************************************************************************
+* MODULE   : mp200_v4l2_ipu_request_main
+* FUNCTION : request to IPU driver function.
+* RETURN   :  0: success
+*	   : -1: buffer busy
+* NOTE	   : This function the movie rotation demand to the IPU driver.
+* CREATE   : 2008/01/17 M.Haguro
+* UPDATE   :
+******************************************************************************/
+static int mp200_v4l2_ipu_request_main(struct mp200_v4l2_device *dev,
+ struct videobuf_buffer *vb, struct th_object *th_obj,
+ enum call_func_num call_func)
+{
+	enum buffer_select  buf_sel;
+	int index = -1;
+	unsigned long flags;
+	int i;
+
+	spin_lock_irqsave(&dev->vbq_lock, flags);
+
+	/* check use buffer */
+	for (i = 0; i < NUM_BUF_V4L2; i++) {
+		if (th_obj->th_buf->buf[i].state == TMPBUF_IDLE) {
+			buf_sel = i;
+			break;
+		}
+	}
+	if (i >= NUM_BUF_V4L2) {
+		spin_unlock_irqrestore(&dev->vbq_lock, flags);
+		return -1;
+	}
+
+	/* check next queue status */
+	if (mp200_v4l2_next_proccess(dev, vb, buf_sel, call_func)) {
+		spin_unlock_irqrestore(&dev->vbq_lock, flags);
+		return -1;
+	}
+
+	/* make IPU request data */
+	if (th_obj->th_buf->make_request(dev, vb, index, buf_sel)) {
+		/* check next queue status */
+		if (mp200_v4l2_next_proccess(dev, vb, 0, VBQ_COMPLETE)) {
+			/* CANCELED */
+			spin_unlock_irqrestore(&dev->vbq_lock, flags);
+			return -1;
+		}
+		mp200_v4l2_core_vbq_complete(dev, vb, 1);
+		printk_info("IPU request data making error.\n\n");
+		spin_unlock_irqrestore(&dev->vbq_lock, flags);
+		return -1;
+	}
+
+	/* set pointer to callback function from rot driver */
+	th_obj->th_buf->ipu_request.callback	= th_obj->th_buf->callback;
+	th_obj->th_buf->ipu_request.ipu_hw_func = th_obj->th_buf->ipu_hw_func;
+	/* set pointer to Device information into dev->req.data */
+	th_obj->th_buf->ipu_request.data	= (unsigned long)dev;
+	th_obj->th_buf->vb			= (void *)vb;
+
+	/* call IPU driver */
+	mp200_ipu_regist(
+		(struct mp200_ipu_req *)(&th_obj->th_buf->ipu_request));
+
+	spin_unlock_irqrestore(&dev->vbq_lock, flags);
+	return 0;
+}
+
+
+/*****************************************************************************
+* MODULE   : mp200_v4l2_rot_callback
+* FUNCTION : IPU-ROT driver callback function.
+* RETURN   : -
+* NOTE	   : When the animation rotation is completed/error,
+*	   : the IPU-ROT driver calls this function.
+* CREATE   : 2008/01/15 M.Haguro
+* UPDATE   :
+******************************************************************************/
+static inline void mp200_v4l2_rot_callback(unsigned long sequence, int flag)
+{
+	struct mp200_v4l2_device *dev = mp200_dev;
+
+	/* IPU callback main function */
+	mp200_v4l2_ipu_callback_main(dev, &dev->th_rot, ROT_CALLBACK, flag);
+}
+
+
+/*****************************************************************************
+* MODULE   : mp200_v4l2_rot_request
+* FUNCTION : request to IPU-ROT driver function.
+* RETURN   :  0: success
+*	   : -1: buffer busy
+* NOTE	   : This function the movie rotation demand to the IPU-ROT driver.
+* CREATE   : 2008/01/15 M.Haguro
+* UPDATE   :
+******************************************************************************/
+static inline int mp200_v4l2_rot_request(struct mp200_v4l2_device *dev,
+ struct videobuf_buffer *vb, int dummy)
+{
+	return mp200_v4l2_ipu_request_main(dev, vb, &dev->th_rot, ROT_REQUEST);
+}
+
+
+/*****************************************************************************
+* MODULE   : mp200_v4l2_rot_make_req
+* FUNCTION : make rotate request data to ROT driver.
+* RETURN   :  0: success
+*	   : -1: error
+* NOTE	   : The register information table make, requested to the ROT driver.
+* CREATE   : 2006/06/06 M.Haguro
+* UPDATE   : 2006/06/14 M.Haguro
+******************************************************************************/
+static int mp200_v4l2_rot_make_req(struct mp200_v4l2_device *dev,
+ struct videobuf_buffer *vb, int index, enum buffer_select buf_sel)
+{
+	struct buf_object  *rot_buf  = dev->th_rot.th_buf;
+	struct _IMAGE_DATA *rot_data = &vb->rot_buf->dst_data;
+	unsigned long base_addr;
+	unsigned long src_yrgbaddr = 0, src_uvaddr = 0, src_vaddr = 0;
+	unsigned long rot_mode, format;
+	int index_req = 0;
+	int bpp_y, bpp_uv, bpp_v; /* bit par pixel  */
+	int ppl_y, ppl_uv, ppl_v; /* pixel par line */
+
+	/* init IPU request data */
+	memset(&rot_buf->ipu_request, 0, sizeof(struct mp200_ipu_req_v4l2));
+	memset(rot_data, 0, sizeof(struct _IMAGE_DATA));
+
+	/*******************************
+	    set ROT_MODE
+	********************************/
+	rot_mode = (ROT_NEWEN_BIT | ROT_MODE_SRCENDIAN_LITTLE
+		    | ROT_MODE_DSTENDIAN_LITTLE);
+
+	switch (vb->save_effect.movie_angle) {
+	default:
+	case ROT_MODE_ROT_MOD_0: /*   0 deg */
+		return -1;
+	case ROT_MODE_ROT_MOD_90: /*  90 deg */
+		rot_mode |= ROT_MODE_ROT_MOD_90;
+		break;
+	case ROT_MODE_ROT_MOD_180: /* 180 deg */
+		rot_mode |= ROT_MODE_ROT_MOD_180;
+		break;
+	case ROT_MODE_ROT_MOD_270: /* 270 deg */
+		rot_mode |= ROT_MODE_ROT_MOD_270;
+		break;
+	}
+
+	/*******************************
+	    set ROT_FORMAT
+	********************************/
+	switch (vb->pixelformat) {
+	case V4L2_PIX_FMT_NV12:	   /* YUV420 Semi-Planar */
+		format = ROT_DSTFMT_YUV420_SEMI_PLANAR
+		       | ROT_SRCFMT_YUV420_SEMI_PLANAR;
+		bpp_y = 8;  bpp_uv = 8; bpp_v = 0;
+		ppl_y = 1; ppl_uv = 2; ppl_v = 0;
+		break;
+	case V4L2_PIX_FMT_NV422:   /* YUV422 Semi-Planar */
+		format = ROT_DSTFMT_YUV422_SEMI_PLANAR
+		       | ROT_SRCFMT_YUV422_SEMI_PLANAR;
+		bpp_y = 8;  bpp_uv = 8; bpp_v = 0;
+		ppl_y = 1; ppl_uv = 1; ppl_v = 0;
+		break;
+	case V4L2_PIX_FMT_YVU420:  /* YUV420 Planar      */
+		format = ROT_DSTFMT_YUV420_PLANAR
+		       | ROT_SRCFMT_YUV420_PLANAR;
+		bpp_y = 8;  bpp_uv = 4; bpp_v = 4;
+		ppl_y = 1; ppl_uv = 2; ppl_v = 2;
+		break;
+#if VF_YUV422PL
+	case V4L2_PIX_FMT_YUV422P: /* YUV422 Planar      */
+		format = ROT_DSTFMT_YUV422_PLANAR
+		       | ROT_SRCFMT_YUV422_PLANAR;
+		bpp_y = 8;  bpp_uv = 8; bpp_v = 8;
+		ppl_y = 1; ppl_uv = 2; ppl_v = 2;
+		break;
+#endif
+#if VF_YUV422PX
+	case V4L2_PIX_FMT_UYVY:   /* YUV422 Interleave   */
+		format = ROT_DSTFMT_YUV422_INTERLEAVE
+		       | ROT_SRCFMT_YUV422_INTERLEAVE;
+		bpp_y = 16; bpp_uv = 0; bpp_v = 0;
+		ppl_y = 1; ppl_uv = 0; ppl_v = 0;
+		break;
+#endif
+	default:
+		return -1;
+	}
+
+	/*******************************
+	    set ROT request data
+	********************************/
+	if (vb->save_effect.movie_angle == ROT_MODE_ROT_MOD_180) {
+		rot_data->hsize = vb->save_effect.source_crop.width;
+		rot_data->vsize = vb->save_effect.source_crop.height;
+		rot_data->size	= vb->save_effect.source_crop.width * bpp_y / 8;
+	} else{
+		rot_data->hsize = vb->save_effect.source_crop.height;
+		rot_data->vsize = vb->save_effect.source_crop.width;
+		rot_data->size	= vb->save_effect.source_crop.height
+		 * bpp_y / 8;
+	}
+	vb->rot_buf->pixelformat = vb->pixelformat;
+
+	/* check next destination buffer */
+	base_addr = vb->rot_buf->paddr;
+	switch (vb->pixelformat) {
+#if VF_YUV422PX
+	case V4L2_PIX_FMT_UYVY:	   /* YUV422 Interleave  */
+		/* src */
+		src_yrgbaddr	   = vb->base_addr.PhysAddr_Y
+		  + vb->save_effect.source_crop.top
+		   * vb->bytesperline * bpp_y  / 8 / ppl_y
+		    + vb->save_effect.source_crop.left * bpp_y  / 8;
+		src_uvaddr	   = 0;
+		src_vaddr	   = 0;
+		/* dst */
+		rot_data->yrgbaddr = base_addr;
+		rot_data->uvaddr   = 0;
+		rot_data->vaddr	   = 0;
+		break;
+#endif
+	case V4L2_PIX_FMT_NV422:   /* YUV422 Semi-Planar */
+	case V4L2_PIX_FMT_NV12:	   /* YUV420 Semi-Planar */
+		/* src */
+		src_yrgbaddr	   = vb->base_addr.PhysAddr_Y
+		  + vb->save_effect.source_crop.top
+		   * vb->bytesperline * bpp_y  / 8 / ppl_y
+		    + vb->save_effect.source_crop.left * bpp_y  / 8;
+		src_uvaddr	   = vb->base_addr.PhysAddr_UV
+		  + vb->save_effect.source_crop.top
+		   * vb->bytesperline * bpp_uv / 8 / ppl_uv
+		    + vb->save_effect.source_crop.left * bpp_uv / 8;
+		src_vaddr	   = 0;
+		/* dst */
+		rot_data->yrgbaddr = base_addr;
+		rot_data->uvaddr   = rot_data->yrgbaddr
+		  + rot_data->vsize * rot_data->hsize * bpp_y  / 8 / ppl_y;
+		rot_data->vaddr	   = 0;
+		break;
+#if VF_YUV422PL
+	case V4L2_PIX_FMT_YUV422P: /* YUV422 Planar      */
+#endif
+	case V4L2_PIX_FMT_YVU420:  /* YUV420 Planar      */
+		/* src */
+		src_yrgbaddr	   = vb->base_addr.PhysAddr_Y
+		  + vb->save_effect.source_crop.top
+		   * vb->bytesperline * bpp_y  / 8 / ppl_y
+		    + vb->save_effect.source_crop.left * bpp_y  / 8;
+		src_uvaddr	   = vb->base_addr.PhysAddr_UV
+		  + vb->save_effect.source_crop.top
+		   * vb->bytesperline * bpp_uv / 8 / ppl_uv
+		    + vb->save_effect.source_crop.left * bpp_uv / 8;
+		src_vaddr	   = vb->base_addr.PhysAddr_V
+		  + vb->save_effect.source_crop.top
+		   * vb->bytesperline * bpp_v  / 8 / ppl_v
+		    + vb->save_effect.source_crop.left * bpp_v  / 8;
+		/* dst */
+		rot_data->yrgbaddr = base_addr;
+		rot_data->uvaddr   = rot_data->yrgbaddr
+		 + rot_data->vsize * rot_data->hsize * bpp_y  / 8 / ppl_y;
+		rot_data->vaddr	   = rot_data->uvaddr
+		 + rot_data->vsize * rot_data->hsize * bpp_uv / 8 / ppl_uv;
+		break;
+	}
+
+	/*******************************
+	    set ROT register
+	********************************/
+	/*==============================
+	    ROT_MODE
+	================================*/
+	RotRequest(rot_mode,			       ROT_MODE);
+	RotRequest(0x05,			       ROT_FRAME);
+	RotRequest(format,			       ROT_FORMAT);
+
+	/*==============================
+	    source image
+	================================*/
+	RotRequest(src_yrgbaddr,		       ROT_SRCYADR_A);
+	RotRequest(src_uvaddr,			       ROT_SRCUVADR_A);
+	RotRequest(src_vaddr,			       ROT_SRCVADR_A);
+	RotRequest(vb->bytesperline,		       ROT_SRCSIZE);
+	RotRequest(vb->save_effect.source_crop.width,  ROT_SRCHSIZE);
+	RotRequest(vb->save_effect.source_crop.height, ROT_SRCVSIZE);
+
+	/*==============================
+	    destination image
+	================================*/
+	RotRequest(rot_data->yrgbaddr,		       ROT_DSTYADR_A);
+	RotRequest(rot_data->uvaddr,		       ROT_DSTUVADR_A);
+	RotRequest(rot_data->vaddr,		       ROT_DSTVADR_A);
+	RotRequest(rot_data->size,		       ROT_DSTSIZE);
+
+	/*==============================
+	    Start ROT
+	================================*/
+	RotRequest(ROT_REQ_BIT,			       ROT_REQ);
+
+	/*==============================
+	    end mark
+	================================*/
+	RotRequest(-1, -1);
+
+	return 0;
+}
+
+
+/*****************************************************************************
+* MODULE   : mp200_v4l2_img_callback
+* FUNCTION : IPU-ROT driver callback function.
+* RETURN   : -
+* NOTE	   : When the animation rotation is completed/error,
+*	   : the IPU-IMG driver calls this function.
+* CREATE   : 2008/01/15 M.Haguro
+* UPDATE   :
+******************************************************************************/
+static inline void mp200_v4l2_img_callback(unsigned long sequence, int flag)
+{
+	struct mp200_v4l2_device *dev = mp200_dev;
+
+	/* IPU callback main function */
+	mp200_v4l2_ipu_callback_main(dev, &dev->th_img, IMG_CALLBACK, flag);
+}
+
+
+/*****************************************************************************
+* MODULE   : mp200_v4l2_img_request
+* FUNCTION : request to IPU-IMG driver function.
+* RETURN   :  0: success
+*	   : -1: buffer busy
+* NOTE	   : This function the movie rotation demand to the IPU-IMG driver.
+* CREATE   : 2008/01/15 M.Haguro
+* UPDATE   :
+******************************************************************************/
+static inline int mp200_v4l2_img_request(struct mp200_v4l2_device *dev,
+ struct videobuf_buffer *vb, int dummy)
+{
+	return mp200_v4l2_ipu_request_main(dev, vb, &dev->th_img, IMG_REQUEST);
+}
+
+
+/*****************************************************************************
+* MODULE   : mp200_v4l2_img_make_req
+* FUNCTION : make rotate request data to IPU-IMG driver.
+* RETURN   :  0: success
+*	   : -1: error
+* NOTE	   : The register information table make, requested to the ROT driver.
+* CREATE   : 2007/12/06 M.Haguro
+* UPDATE   :
+******************************************************************************/
+static int mp200_v4l2_img_make_req(struct mp200_v4l2_device *dev,
+ struct videobuf_buffer *vb, int index, enum buffer_select buf_sel)
+{
+	struct buf_object  *img_buf  = dev->th_img.th_buf;
+	struct _IMAGE_DATA *img_data = &vb->img_buf->dst_data;
+	struct _IMAGE_DATA  src_data;
+
+	unsigned long base_addr;
+	unsigned long img_mode, format;
+	int index_req = 0;
+	int bpp_y, bpp_uv, bpp_v; /* bit par pixel  */
+	int ppl_y, ppl_uv, ppl_v; /* pixel par line */
+
+	unsigned long	endian = IMG_PEL_ENDIAN_IN_ENDI_LITTLE
+	 | IMG_PEL_ENDIAN_OUT_ENDI_LITTLE;
+
+	/* init IPU request data */
+	memset(&img_buf->ipu_request, 0, sizeof(struct mp200_ipu_req_v4l2));
+	memset(img_data,  0, sizeof(struct _IMAGE_DATA));
+	memset(&src_data, 0, sizeof(struct _IMAGE_DATA));
+
+	/*******************************
+	    set IMG_MODE
+	********************************/
+	img_mode  = IMG_NEWEN_BIT;
+	img_mode |= mp200_v4l2_chk_ipuimg(dev, vb);
+
+	switch (vb->pixelformat) {
+	case V4L2_PIX_FMT_NV12:	  /* YUV420 Semi-Planar */
+		format = IMG_FORMAT_DSTFMT_YUV420_SEMI_PLANAR
+		 | IMG_FORMAT_SRCFMT_B_YUV420_SEMI_PLANAR;
+		bpp_y = 8; bpp_uv = 8; bpp_v = 0;
+		ppl_y = 1; ppl_uv = 2; ppl_v = 0;
+		break;
+	case V4L2_PIX_FMT_YVU420: /* YUV420 Planar      */
+		format = IMG_FORMAT_DSTFMT_YUV420_SEMI_PLANAR
+		 | IMG_FORMAT_SRCFMT_B_YUV420_PLANAR;
+		bpp_y = 8; bpp_uv = 4; bpp_v = 4;
+		ppl_y = 1; ppl_uv = 2; ppl_v = 2;
+		break;
+	case V4L2_PIX_FMT_NV422:  /* YUV422 Semi-Planar */
+		format = IMG_FORMAT_DSTFMT_YUV422_SEMI_PLANAR
+		 | IMG_FORMAT_SRCFMT_B_YUV422_SEMI_PLANAR;
+		bpp_y = 8; bpp_uv = 8; bpp_v = 0;
+		ppl_y = 1; ppl_uv = 1; ppl_v = 0;
+		break;
+#if VF_YUV422PL
+	case V4L2_PIX_FMT_YUV422P: /* YUV422 Planar     */
+		format = IMG_FORMAT_DSTFMT_YUV422_SEMI_PLANAR
+		 | IMG_FORMAT_SRCFMT_B_YUV422_PLANAR;
+		bpp_y = 8; bpp_uv = 8; bpp_v = 8;
+		ppl_y = 1; ppl_uv = 2; ppl_v = 2;
+		break;
+#endif
+#if VF_YUV422PX
+	case V4L2_PIX_FMT_UYVY:	  /* YUV422 Interleave  */
+		format = IMG_FORMAT_DSTFMT_YUV422_INTERLEAVE
+		 | IMG_FORMAT_SRCFMT_B_YUV422_INTERLEAVE;
+		bpp_y = 16; bpp_uv = 0; bpp_v = 0;
+		ppl_y = 1; ppl_uv = 0; ppl_v = 0;
+		break;
+#endif
+	default:
+		return -1;
+	}
+
+	/*******************************
+	    set IMG request data
+	********************************/
+	/* check next destination buffer */
+	base_addr = vb->img_buf->paddr;
+
+	if (vb->state_proccess & STATE_PROCCESS_ROT_COMPLETE) {
+		memcpy(&src_data, &vb->rot_buf->dst_data,
+		       sizeof(struct _IMAGE_DATA));
+		vb->img_buf->pixelformat = vb->rot_buf->pixelformat;
+	} else {
+		/* not use IPU-ROT */
+		src_data.yrgbaddr = vb->base_addr.PhysAddr_Y;
+		src_data.uvaddr	  = vb->base_addr.PhysAddr_UV;
+		src_data.vaddr	  = vb->base_addr.PhysAddr_V;
+		src_data.x	  = vb->save_effect.source_crop.left;
+		src_data.y	  = vb->save_effect.source_crop.top;
+		src_data.hsize	  = vb->save_effect.source_crop.width;
+		src_data.vsize	  = vb->save_effect.source_crop.height;
+		src_data.size	  = vb->bytesperline;
+		vb->img_buf->pixelformat = vb->pixelformat;
+	}
+
+	switch (vb->img_buf->pixelformat) {
+#if VF_YUV422PX
+	case V4L2_PIX_FMT_UYVY:	   /* YUV422 Interleave  */
+		/* src */
+		src_data.yrgbaddr  = src_data.yrgbaddr
+		  + src_data.y * src_data.size * bpp_y  / 8 / ppl_y
+		  + src_data.x * bpp_y / 8;
+		src_data.uvaddr	   = 0;
+		src_data.vaddr	   = 0;
+		/* dst */
+		img_data->yrgbaddr = base_addr;
+		img_data->uvaddr   = 0;
+		img_data->vaddr	   = 0;
+		break;
+#endif
+	case V4L2_PIX_FMT_NV12:	   /* YUV420 Semi-Planar */
+	case V4L2_PIX_FMT_NV422:   /* YUV422 Semi-Planar */
+		/* src */
+		src_data.yrgbaddr  = src_data.yrgbaddr
+		  + src_data.y * src_data.size * bpp_y  / 8 / ppl_y
+		  + src_data.x * bpp_y	/ 8;
+		src_data.uvaddr    = src_data.uvaddr
+		  + src_data.y * src_data.size * bpp_uv / 8 / ppl_uv
+		  + src_data.x * bpp_uv / 8;
+		src_data.vaddr	   = 0;
+		/* dst */
+		img_data->yrgbaddr = base_addr;
+		img_data->uvaddr   = img_data->yrgbaddr
+		  + vb->save_effect.screen.width
+		   * vb->save_effect.screen.height * bpp_y / 8 / ppl_y;
+		img_data->vaddr	   = 0;
+		break;
+	case V4L2_PIX_FMT_YVU420:  /* YUV420 Planar      */
+#if VF_YUV422PL
+	case V4L2_PIX_FMT_YUV422P: /* YUV422 Planar      */
+#endif
+		/* src */
+		src_data.yrgbaddr  = src_data.yrgbaddr
+		  + src_data.y * src_data.size * bpp_y  / 8 / ppl_y
+		  + src_data.x * bpp_y	/ 8;
+		src_data.uvaddr    = src_data.uvaddr
+		  + src_data.y * src_data.size * bpp_uv / 8 / ppl_uv
+		  + src_data.x * bpp_uv / 8;
+		src_data.vaddr	   = src_data.vaddr
+		  + src_data.y * src_data.size * bpp_v  / 8 / ppl_v
+		  + src_data.x * bpp_v	/ 8;
+		/* dst */
+		img_data->yrgbaddr = base_addr;
+		img_data->uvaddr   = img_data->yrgbaddr
+		  + vb->save_effect.screen.width
+		   * vb->save_effect.screen.height * bpp_y / 8 / ppl_y;
+		img_data->vaddr	   = 0;
+
+		if (vb->img_buf->pixelformat == V4L2_PIX_FMT_YVU420) {
+			/* YUV420 Semi-Planar */
+			vb->img_buf->pixelformat = V4L2_PIX_FMT_NV12;
+		}
+#if VF_YUV422PL
+		else{
+			/* YUV422 Semi-Planar */
+			vb->img_buf->pixelformat = V4L2_PIX_FMT_NV422;
+		}
+#endif
+		break;
+	}
+
+	img_data->hsize = vb->save_effect.screen.width;
+	img_data->vsize = vb->save_effect.screen.height;
+	img_data->size	= img_data->hsize * bpp_y / 8;
+
+	/*******************************
+	    set IMG register
+	********************************/
+	/*==============================
+	    IMG_MODE
+	================================*/
+	ImgRequest(img_mode,				IMG_MODE);
+	ImgRequest(format,				IMG_FORMAT);
+
+	/*==============================
+	    source image
+	================================*/
+	ImgRequest(src_data.yrgbaddr,			IMG_SRCYRGBADR_B);
+	ImgRequest(src_data.uvaddr,			IMG_SRCUVADR_B);
+	ImgRequest(src_data.vaddr,			IMG_SRCVADR_B);
+	ImgRequest(src_data.size,			IMG_SRCSIZE_B);
+	ImgRequest(src_data.hsize,			IMG_SRCHSIZE_B);
+	ImgRequest(src_data.vsize,			IMG_SRCVSIZE_B);
+
+	/*==============================
+	    destination image
+	================================*/
+	ImgRequest(img_data->yrgbaddr,			IMG_DSTYRGBADR);
+	ImgRequest(img_data->uvaddr,			IMG_DSTUVADR);
+	ImgRequest(img_data->vaddr,			IMG_DSTVADR);
+	ImgRequest(img_data->size,			IMG_DSTSIZE);
+
+	if ((img_mode & IMG_OP_MODE_BIT) == IMG_OP_MODE_03_BIT) {
+		unsigned long step_h, step_v, fold_h, fold_v;
+
+		/* resize */
+		ImgRequest(img_data->hsize,		IMG_DSTHSIZE);
+		ImgRequest(img_data->vsize,		IMG_DSTVSIZE);
+
+		/* step */
+		step_h = src_data.hsize * 256 / img_data->hsize;
+		step_v = src_data.vsize * 256 / img_data->vsize;
+		ImgRequest(step_h,			IMG_HSTEP);
+		ImgRequest(step_v,			IMG_VSTEP);
+
+		/* fold */
+		fold_h = img_data->hsize * 64 / src_data.hsize;
+		fold_v = img_data->vsize * 64 / src_data.vsize;
+		ImgRequest(fold_h,			IMG_HFOLD);
+		ImgRequest(fold_v,			IMG_VFOLD);
+	}
+
+	ImgRequest(endian,				IMG_PEL_ENDIAN);
+
+	/*==============================
+	    Start IMG
+	================================*/
+	ImgRequest(IMG_REQ_BIT,				IMG_REQ);
+
+	/*==============================
+	    end mark
+	================================*/
+	ImgRequest(-1, -1);
+
+	return 0;
+}
+
+
+/*===============================================================*/
+/* LCD proccessing function prottyped				 */
+/*===============================================================*/
+/*****************************************************************************
+* MODULE   : mp200_v4l2_lcd_stop_do
+* FUNCTION : wait to call LCD driver function.
+* RETURN   : -
+* NOTE	   :
+* CREATE   : 2008/01/18 M.Haguro
+* UPDATE   :
+******************************************************************************/
+static void mp200_v4l2_lcd_stop_do(struct work_struct *num)
+{
+	struct mp200_v4l2_device *dev;
+
+	dev = container_of(num, struct mp200_v4l2_device, wk_lcd_stop);
+	if (dev->mixing) {
+		/* call lcd driver function. */
+		queue_work(dev->v4l2_workqueue, &dev->wk_lcd_stop);
+	} else {
+		/* call lcd driver function. */
+		mp200_v4l2_lcd_request(dev, NULL, STREAM_STOP);
+	}
+}
+
+
+/*****************************************************************************
+* MODULE   : mp200_v4l2_lcd_callback
+* FUNCTION : LCD driver callback function.
+* RETURN   : -
+* NOTE	   : When the animation rotation is completed/error,
+*	   : the LCD driver calls this function.
+* CREATE   : 2008/01/15 M.Haguro
+* UPDATE   :
+******************************************************************************/
+void mp200_v4l2_lcd_callback(FRAME_DATA frame_data)
+{
+	struct mp200_v4l2_device *dev;
+	struct videobuf_buffer	 *vb;
+	unsigned long flags;
+
+	dev = (struct mp200_v4l2_device *)frame_data.dev;
+	vb  = (struct videobuf_buffer *)frame_data.buf;
+
+	spin_lock_irqsave(&dev->vbq_lock, flags);
+	if (vb->output != V4L2_OUTPUT_LCD
+	 && vb->state_frame != STATE_FRAME_IMMEDIATE) {
+		if (down_trylock(&dev->sem_lcdout))
+			;
+
+		up(&dev->sem_lcdout); /* release semafore */
+	}
+
+#if CALC_ADJUST
+	if (vb->output == V4L2_OUTPUT_LCD)
+		dev->timer.adjust_time_lcd =
+			mp200_v4l2_tmr_calc_adjusttime(dev);
+#endif
+
+	mp200_v4l2_core_vbq_complete(dev, vb, 0);
+	spin_unlock_irqrestore(&dev->vbq_lock, flags);
+}
+
+
+/*****************************************************************************
+* MODULE   : mp200_v4l2_lcd_refresh_callback
+* FUNCTION : LCD driver callback function.
+* RETURN   : -
+* NOTE	   : When the animation rotation is completed/error,
+*	   : the LCD driver calls this function.
+* CREATE   : 2008/01/15 M.Haguro
+* UPDATE   :
+******************************************************************************/
+void mp200_v4l2_lcd_refresh_callback(FRAME_DATA frame_data)
+{
+	struct mp200_v4l2_device *dev;
+	struct videobuf_buffer	 *vb;
+	unsigned long flags;
+
+	dev = (struct mp200_v4l2_device *)frame_data.dev;
+	vb  = (struct videobuf_buffer *)frame_data.buf;
+
+	spin_lock_irqsave(&dev->vbq_lock, flags);
+
+	if (vb->output == V4L2_OUTPUT_LCD
+	 && vb->state_frame != STATE_FRAME_IMMEDIATE) {
+		if (down_trylock(&dev->sem_lcdout))
+			;
+
+		up(&dev->sem_lcdout); /* release semafore */
+	}
+
+	/* check next queue status */
+	if (mp200_v4l2_next_proccess(dev, vb, 0, LCD_CALLBACK)) {
+		/* CANCELED */
+		;
+	}
+	spin_unlock_irqrestore(&dev->vbq_lock, flags);
+}
+
+
+/*****************************************************************************
+* MODULE   : mp200_v4l2_ntsc_ready_callback
+* FUNCTION : NTSC driver callback function. when finished IPU-IMG.
+* RETURN   : -
+* NOTE	   :
+* CREATE   : 2009/04/03 M.Haguro
+* UPDATE   :
+******************************************************************************/
+void mp200_v4l2_ntsc_ready_callback(FRAME_DATA frame_data)
+{
+	struct mp200_v4l2_device *dev;
+	struct videobuf_buffer	 *vb;
+	unsigned long flags;
+
+	dev = (struct mp200_v4l2_device *)frame_data.dev;
+	vb  = (struct videobuf_buffer *)frame_data.buf;
+
+	spin_lock_irqsave(&dev->vbq_lock, flags);
+
+	if (vb->output == V4L2_OUTPUT_NTSC || vb->output == V4L2_OUTPUT_PAL)
+		dev->timer.adjust_time_ntsc =
+			mp200_v4l2_tmr_calc_adjusttime(dev);
+
+	spin_unlock_irqrestore(&dev->vbq_lock, flags);
+}
+
+
+/*****************************************************************************
+* MODULE   : mp200_v4l2_lcd_set_outfunc
+* FUNCTION : request to LCD driver function.
+* RETURN   :  0: success
+* NOTE	   : This function the drawing demand to the LCD driver.
+* CREATE   : 2008/01/17 M.Haguro
+* UPDATE   :
+******************************************************************************/
+static inline void *mp200_v4l2_lcd_set_outfunc(int output)
+{
+#ifdef CONFIG_MP200_NTS
+	if (output == V4L2_OUTPUT_LCD) {
+		/* LCD driver call */
+		return (void *)mp200_lcd_set_v4l2_image;
+	} else{
+		/* NTS driver call */
+		return (void *)mp200_nts_set_v4l2_image;
+	}
+#else
+	/* LCD driver call */
+	return (void *)mp200_lcd_set_v4l2_image;
+#endif /* CONFIG_MP200_NTS */
+}
+
+
+/*****************************************************************************
+* MODULE   : mp200_v4l2_lcd_request
+* FUNCTION : request to LCD driver function.
+* RETURN   :  0: success
+* NOTE	   : This function the drawing demand to the LCD driver.
+* CREATE   : 2008/01/17 M.Haguro
+* UPDATE   :
+******************************************************************************/
+static int mp200_v4l2_lcd_request(struct mp200_v4l2_device *dev,
+ struct videobuf_buffer *vb, int call_flg)
+{
+	int			 ret = 0;
+	unsigned long		 flags;
+	unsigned long		 pixelformat = 0;
+
+	struct _V4L2_IMAGE_INFO	 image_info;
+	int (*call_outfunc)(V4L2_IMAGE_INFO *);
+
+	switch (call_flg) {
+	case STREAM_PLAYBACK:
+#if CALC_ADJUST
+		do_gettimeofday(&dev->timer.do_time);
+#else
+		if ((vb->output == V4L2_OUTPUT_NTSC)
+		  || (vb->output == V4L2_OUTPUT_PAL)) {
+			do_gettimeofday(&dev->timer.do_time);
+		}
+#endif
+
+		/* LCD driver's request information making */
+		spin_lock_irqsave(&dev->vbq_lock, flags);
+
+		/* check next queue status */
+		if (mp200_v4l2_next_proccess(dev, vb, 0, LCD_REQUEST)) {
+			if (vb->state_frame != STATE_FRAME_IMMEDIATE) {
+				if (down_trylock(&dev->sem_lcdout))
+					;
+
+				up(&dev->sem_lcdout); /* release semafore */
+			}
+			spin_unlock_irqrestore(&dev->vbq_lock, flags);
+			return -1;
+		}
+
+		if (vb->state == VIDEOBUF_QUEUED)
+			vb->state = VIDEOBUF_ACTIVE;
+
+		/* movie reproduction processing */
+		if (vb->state_proccess & STATE_PROCCESS_IMG_COMPLETE) {
+			memcpy(&image_info.image_data,
+			 &vb->img_buf->dst_data, sizeof(struct _IMAGE_DATA));
+			pixelformat = vb->img_buf->pixelformat;
+		} else if (vb->state_proccess & STATE_PROCCESS_ROT_COMPLETE) {
+			memcpy(&image_info.image_data, &vb->rot_buf->dst_data,
+			 sizeof(struct _IMAGE_DATA));
+			pixelformat = vb->rot_buf->pixelformat;
+		} else{
+			image_info.image_data.size = vb->bytesperline;
+			image_info.image_data.yrgbaddr =
+				vb->base_addr.PhysAddr_Y;
+			image_info.image_data.uvaddr =
+				vb->base_addr.PhysAddr_UV;
+			image_info.image_data.vaddr =
+				vb->base_addr.PhysAddr_V;
+			image_info.image_data.x =
+				vb->save_effect.source_crop.left;
+			image_info.image_data.y =
+				vb->save_effect.source_crop.top;
+			image_info.image_data.hsize =
+				vb->save_effect.source_crop.width;
+			image_info.image_data.vsize =
+				vb->save_effect.source_crop.height;
+			pixelformat = vb->pixelformat;
+		}
+
+		image_info.screen_data.x     = vb->save_effect.screen.left;
+		image_info.screen_data.y     = vb->save_effect.screen.top;
+		image_info.screen_data.hsize = vb->save_effect.screen.width;
+		image_info.screen_data.vsize = vb->save_effect.screen.height;
+
+		switch (pixelformat) {
+		case V4L2_PIX_FMT_NV12:	   /* YUV420 Semi-Planar */
+			image_info.yuvfmt = V4L2_FORMAT_YUV420Pl2;
+			break;
+		case V4L2_PIX_FMT_NV422:   /* YUV422 Semi-Planar */
+			image_info.yuvfmt = V4L2_FORMAT_YUV422Pl2;
+			break;
+		case V4L2_PIX_FMT_YVU420:  /* YUV420 Planar      */
+			image_info.yuvfmt = V4L2_FORMAT_YUV420Pl;
+			break;
+#if VF_YUV422PL
+		case V4L2_PIX_FMT_YUV422P: /* YUV422 Planar      */
+			image_info.yuvfmt = V4L2_FORMAT_YUV422Pl;
+			break;
+#endif
+#if VF_YUV422PX
+		case V4L2_PIX_FMT_UYVY:	   /* YUV422 Interleave  */
+			image_info.yuvfmt = V4L2_FORMAT_YUV422Px;
+			break;
+#endif
+		default:
+			if (vb->state_frame != STATE_FRAME_IMMEDIATE) {
+				if (down_trylock(&dev->sem_lcdout))
+					;
+
+				up(&dev->sem_lcdout); /* release semafore */
+			}
+			spin_unlock_irqrestore(&dev->vbq_lock, flags);
+			return -1;
+		}
+
+		image_info.endian	  = V4L2_LITTLE_ENDIAN;
+		image_info.frame_data.dev = (void *)dev;
+		image_info.frame_data.buf = (void *)vb;
+
+		spin_unlock_irqrestore(&dev->vbq_lock, flags);
+		break;
+
+	default:
+	case STREAM_STOP:
+		/* movie stop processing */
+		memset(&image_info, 0, sizeof(struct _IMAGE_DATA));
+		break;
+	}
+
+#ifdef CONFIG_FB_MP200
+	if (call_flg != STREAM_STOP)
+		call_outfunc = mp200_v4l2_lcd_set_outfunc(vb->output);
+	else
+		call_outfunc = mp200_v4l2_lcd_set_outfunc(dev->output);
+
+	if (call_outfunc(&image_info)) {
+		if (call_flg != STREAM_STOP) {
+			/* check next queue status */
+			spin_lock_irqsave(&dev->vbq_lock, flags);
+			if (mp200_v4l2_next_proccess(dev,
+				vb, 0, VBQ_COMPLETE)) {
+				/* CANCELED */
+				;
+			} else
+				mp200_v4l2_core_vbq_complete(dev, vb, 1);
+
+			spin_unlock_irqrestore(&dev->vbq_lock, flags);
+			ret = -1;
+		}
+	}
+#endif
+	return ret;
+}
+
+
+/* ------------------ videobuf_queue_ops ----------------------------------- */
+/*****************************************************************************
+* MODULE   : mp200_v4l2_core_vbq_release
+* FUNCTION :
+* RETURN   : -
+* NOTE	   : This function is called a videobuf_buffer release.
+* CREATE   :
+* UPDATE   :
+******************************************************************************/
+static inline void mp200_v4l2_core_vbq_release(struct videobuf_queue *q,
+ struct videobuf_buffer *vb)
+{
+	videobuf_waiton(vb, 0, 0);
+	mp200_v4l2_core_vbq_dqueue(q, vb);
+	vb->state = VIDEOBUF_NEEDS_INIT;
+}
+
+
+/*****************************************************************************
+* MODULE   : mp200_v4l2_core_vbq_dqueue
+* FUNCTION :
+* RETURN   : -
+* NOTE	   : This function executes video buffer information.
+* CREATE   : 08/01/24 M.Haguro
+* UPDATE   :
+******************************************************************************/
+static inline void mp200_v4l2_core_vbq_dqueue(struct videobuf_queue *q,
+ struct videobuf_buffer *vb)
+{
+	struct mp200_v4l2_device *dev = q->priv_data;
+	unsigned long flags;
+	spin_lock_irqsave(&dev->vbq_lock, flags);
+	mp200_v4l2_next_proccess(dev, vb, 0, VBQ_DQUEUE);
+	spin_unlock_irqrestore(&dev->vbq_lock, flags);
+}
+
+
+/*****************************************************************************
+* MODULE   : mp200_v4l2_core_vbq_cancel
+* FUNCTION :
+* RETURN   : 0: success
+*	   : 1: stop timer
+* NOTE	   : This function registers information to video buffer.
+* CREATE   :
+* UPDATE   : 06/07/03 M.Haguro
+******************************************************************************/
+static int mp200_v4l2_core_vbq_cancel(struct videobuf_queue *q,
+ struct videobuf_buffer *vb)
+{
+	struct mp200_v4l2_device *dev = q->priv_data;
+	unsigned long flags;
+	unsigned int  retval = 0;
+
+	spin_lock_irqsave(&dev->vbq_lock, flags);
+
+	if (vb->state_queued == STATE_QUEUED_TMR_QUEUED) {
+		del_timer_sync(&dev->timer.wait_timer);
+		vb->state_frame	 = STATE_FRAME_CANCELED;
+		vb->state	 = VIDEOBUF_CANCELED;
+		vb->state_queued = STATE_QUEUED_DONE;
+		mp200_v4l2_next_proccess(dev, vb, 0, TMR_CALLBACK);
+
+		if (down_trylock(&dev->sem_lcdout))
+			;
+
+		up(&dev->sem_lcdout); /* release semafore */
+	} else{
+		if (vb->state == VIDEOBUF_QUEUED)
+			retval = 1;
+
+		if (vb->state_queued == STATE_QUEUED_IDLE) {
+			vb->state_queued = STATE_QUEUED_DONE;
+			retval = 0;
+		}
+		if (dev->vb_old_refresh)
+			retval = 1;
+	}
+
+	spin_unlock_irqrestore(&dev->vbq_lock, flags);
+
+	return retval;
+}
+
+
+/*****************************************************************************
+* MODULE   : mp200_v4l2_core_vbq_complete
+* FUNCTION :
+* RETURN   : -
+* NOTE	   : This function is called from interrupt context
+*	   : when a IMG transferof a videobuf_buffer completes.
+* CREATE   :
+* UPDATE   :
+******************************************************************************/
+static void mp200_v4l2_core_vbq_complete(void *arg1, void *arg, int err_flg)
+{
+	struct mp200_v4l2_device *dev = (struct mp200_v4l2_device *)arg1;
+	struct videobuf_buffer	 *vb  = (struct videobuf_buffer *)arg;
+
+	vb->field_count	  = dev->field_count;
+	dev->field_count += 2;
+
+	/* check next queue status */
+	if (mp200_v4l2_next_proccess(dev, vb, 0, VBQ_COMPLETE)) {
+		/* CANCELED */
+		return;
+	}
+
+	if (err_flg) {
+		if (dev->vb_old_refresh) {
+			vb->state = VIDEOBUF_CANCELED;
+		} else{
+			vb->state = VIDEOBUF_DQBUF_PERMIT;
+			wake_up(&vb->done);
+			wake_up(&vb->clear_done);
+		}
+	} else {
+		vb->state = VIDEOBUF_DONE;
+
+		if (dev->vb_old) {
+			if (dev->vb_old->state == VIDEOBUF_DONE
+			 || dev->vb_old->state == VIDEOBUF_CANCELED)
+				dev->vb_old->state = VIDEOBUF_DQBUF_PERMIT;
+
+			mp200_v4l2_core_vbq_complete_skipped(
+				&dev->vb_old->stream);
+			wake_up(&dev->vb_old->done);
+		} else{
+			mp200_v4l2_core_vbq_complete_skipped(
+				&((struct videobuf_queue *)
+				(&dev->streaming->vbq))->stream);
+		}
+		dev->vb_old = vb;
+		wake_up(&vb->clear_done);
+	}
+}
+
+
+/*****************************************************************************
+* MODULE   : mp200_v4l2_core_vbq_complete_skipped
+* FUNCTION :
+* RETURN   : -
+* NOTE	   : This function is called from interrupt context
+*	   : when a IMG transferof a videobuf_buffer completes.
+* CREATE   :
+* UPDATE   : 09/04/02 M.Haguro
+******************************************************************************/
+static inline void
+mp200_v4l2_core_vbq_complete_skipped(struct list_head *vbq_stream)
+{
+	struct list_head       *list;
+	struct videobuf_buffer *buf;
+
+	list_for_each(list, vbq_stream) {
+		buf = list_entry(list, struct videobuf_buffer, stream);
+		if (buf->state == VIDEOBUF_DONE) {
+			break;
+		} else if (buf->state == VIDEOBUF_CANCELED) {
+			if (buf->state_frame == STATE_FRAME_DONE
+			 || buf->state_frame == STATE_FRAME_IMMEDIATE)
+				buf->state_frame = STATE_FRAME_CANCELED;
+
+			buf->state = VIDEOBUF_DQBUF_PERMIT;
+			wake_up(&buf->done);
+		}
+	}
+}
+
+
+/*****************************************************************************
+* MODULE   : mp200_v4l2_core_vbq_queue
+* FUNCTION :
+* RETURN   : -
+* NOTE	   : This function executes video buffer information.
+* CREATE   :
+* UPDATE   : 06/06/16 M.Haguro
+******************************************************************************/
+static void mp200_v4l2_core_vbq_queue(struct videobuf_queue *q,
+ struct videobuf_buffer *vb)
+{
+	struct mp200_v4l2_device *dev = q->priv_data;
+	unsigned long flags;
+
+	spin_lock_irqsave(&dev->vbq_lock, flags);
+
+	if (dev->suspend == 0 && dev->mixing == 0 && dev->streamoff == NULL) {
+
+		vb->state = VIDEOBUF_QUEUED;
+		mp200_v4l2_next_proccess(dev, vb, 0, VBQ_QUEUE);
+	}
+	spin_unlock_irqrestore(&dev->vbq_lock, flags);
+}
+
+
+/*****************************************************************************
+* MODULE   : mp200_v4l2_core_vbq_prepare
+* FUNCTION :
+* RETURN   :	   0: success
+*	   : -EINVAL: error
+* NOTE	   : This function registers information to video buffer.
+* CREATE   :
+* UPDATE   : 06/06/12 M.Haguro
+******************************************************************************/
+static int mp200_v4l2_core_vbq_prepare(struct videobuf_queue *q,
+ struct videobuf_buffer *vb, enum v4l2_field field)
+{
+	struct mp200_v4l2_device *dev = q->priv_data;
+	unsigned long flags;
+	unsigned int  retval = 0;
+
+	spin_lock_irqsave(&dev->vbq_lock, flags);
+	if (dev->pix.sizeimage > vb->bsize) {
+		spin_unlock_irqrestore(&dev->vbq_lock, flags);
+		return -EINVAL;
+	}
+	vb->field  = field;
+
+	if (
+	   /* YUV420 Semi-Planar */
+	      (dev->pix.pixelformat != V4L2_PIX_FMT_NV12)
+	   /* YUV422 Semi-Planar */
+	   && (dev->pix.pixelformat != V4L2_PIX_FMT_NV422)
+	   /* YUV420 Planar      */
+	   && (dev->pix.pixelformat != V4L2_PIX_FMT_YVU420)
+#if VF_YUV422PL
+	   /* YUV422 Planar      */
+	   && (dev->pix.pixelformat != V4L2_PIX_FMT_YUV422P)
+#endif
+#if VF_YUV422PX
+	   /* YUV422 Interleave  */
+	   && (dev->pix.pixelformat != V4L2_PIX_FMT_UYVY)
+#endif
+	) {
+		spin_unlock_irqrestore(&dev->vbq_lock, flags);
+		printk_info("error! pixelformat is incorrect.\n\n");
+		return -EINVAL;
+	}
+
+	memcpy(&vb->save_effect, &dev->efct, sizeof(struct v4l2_effect));
+	vb->pixelformat = dev->pix.pixelformat;
+	vb->output	= dev->output;
+
+	/* call size check function */
+	if (mp200_v4l2_core_vbq_sizecheck(q, vb)) {
+		spin_unlock_irqrestore(&dev->vbq_lock, flags);
+		return -EINVAL;
+	}
+
+	if (mp200_v4l2_core_wkb_chksize(dev, vb)) {
+		spin_unlock_irqrestore(&dev->vbq_lock, flags);
+		return -EINVAL;
+	}
+
+	q->sequence++;
+	if (q->sequence == 0)
+		q->sequence++;
+
+	dev->efct.sequence = q->sequence;
+
+	vb->sequence	= q->sequence;
+	vb->state	= VIDEOBUF_PREPARED;
+
+	if ((vb->ts.tv_sec == STATE_FRAME_IMMEDIATE)
+	 || (vb->ts.tv_usec == STATE_FRAME_IMMEDIATE))
+		vb->state_frame = STATE_FRAME_IMMEDIATE;
+	else
+		vb->state_frame = STATE_FRAME_DONE;
+
+	spin_unlock_irqrestore(&dev->vbq_lock, flags);
+
+	return retval;
+}
+
+
+/*****************************************************************************
+* MODULE   : mp200_v4l2_core_vbq_sizecheck_pix
+* FUNCTION :
+* RETURN   :  0: success
+*	   : -1: error
+* NOTE	   : This function registers information to video buffer.
+* CREATE   : 06/07/20 H.Haguro
+* UPDATE   :
+******************************************************************************/
+static int mp200_v4l2_core_vbq_sizecheck_pix(struct videobuf_buffer *vb)
+{
+	unsigned int image_width_aline, image_height_aline;
+
+	switch (vb->pixelformat) {
+	default:
+	case V4L2_PIX_FMT_NV12:	   /* YUV420 Semi-Planar */
+	case V4L2_PIX_FMT_NV422:   /* YUV422 Semi-Planar */
+		image_width_aline  = IMAGE_WIDTH_ALINE_SP;
+		image_height_aline = IMAGE_HEIGHT_ALINE_SP;
+		break;
+	case V4L2_PIX_FMT_YVU420:  /* YUV420 Planar      */
+#if VF_YUV422PL
+	case V4L2_PIX_FMT_YUV422P: /* YUV422 Planar      */
+#endif
+		image_width_aline  = IMAGE_WIDTH_ALINE_PL;
+		image_height_aline = IMAGE_HEIGHT_ALINE_PL;
+		break;
+#if VF_YUV422PX
+	case V4L2_PIX_FMT_UYVY:	   /* YUV422 Interleave  */
+		image_width_aline  = IMAGE_WIDTH_ALINE_IL;
+		image_height_aline = IMAGE_HEIGHT_ALINE_IL;
+		break;
+#endif
+	}
+
+	if ((vb->width < IMAGE_WIDTH_MIN) ||
+	   (vb->width > IMAGE_WIDTH_MAX) ||
+	   (vb->width & image_width_aline) != 0) {
+		printk_info("error! width(%3d) is incorrect.\n\n", vb->width);
+		return -1;
+	}
+	if ((vb->height < IMAGE_HEIGHT_MIN) ||
+	   (vb->height > IMAGE_HEIGHT_MAX) ||
+	   (vb->height & image_height_aline) != 0) {
+		printk_info("error! height(%3d) is incorrect.\n\n", vb->height);
+		return -1;
+	}
+	if ((vb->width * vb->height) > IMAGE_AREA_MAX) {
+		printk_info("error! width*height(%3d)*(%3d) is incorrect.\n\n",
+		 vb->width, vb->height);
+		return -1;
+	}
+	if ((vb->bytesperline < vb->width)     ||
+	   (vb->bytesperline > IMAGE_WIDTH_MAX) ||
+	   (vb->bytesperline & image_width_aline) != 0) {
+		printk_info("error! bytesperline(%3d) is incorrect.\n\n",
+		 vb->bytesperline);
+		return -1;
+	}
+	return 0;
+}
+
+
+/*****************************************************************************
+* MODULE   : mp200_v4l2_core_vbq_sizecheck_crop
+* FUNCTION :
+* RETURN   :  0: success
+*	   : -1: error
+* NOTE	   : This function registers information to video buffer.
+* CREATE   : 06/07/20 H.Haguro
+* UPDATE   :
+******************************************************************************/
+static int mp200_v4l2_core_vbq_sizecheck_crop(struct videobuf_buffer *vb)
+{
+	unsigned int image_width_aline, image_height_aline;
+
+	switch (vb->pixelformat) {
+	default:
+	case V4L2_PIX_FMT_NV12:	   /* YUV420 Semi-Planar */
+	case V4L2_PIX_FMT_NV422:   /* YUV422 Semi-Planar */
+		image_width_aline  = IMAGE_WIDTH_ALINE_SP;
+		image_height_aline = IMAGE_HEIGHT_ALINE_SP;
+		break;
+	case V4L2_PIX_FMT_YVU420:  /* YUV420 Planar      */
+#if VF_YUV422PL
+	case V4L2_PIX_FMT_YUV422P: /* YUV422 Planar      */
+#endif
+		image_width_aline  = IMAGE_WIDTH_ALINE_PL;
+		image_height_aline = IMAGE_HEIGHT_ALINE_PL;
+		break;
+#if VF_YUV422PX
+	case V4L2_PIX_FMT_UYVY:	   /* YUV422 Interleave  */
+		image_width_aline  = IMAGE_WIDTH_ALINE_IL;
+		image_height_aline = IMAGE_HEIGHT_ALINE_IL;
+		break;
+#endif
+	}
+
+	if ((vb->save_effect.source_crop.left < IMAGE_LEFT_MIN) ||
+	   (vb->save_effect.source_crop.left > vb->width)      ||
+	   (vb->save_effect.source_crop.left & IMAGE_LEFT_ALINE) != 0) {
+		printk_info("error! source_crop.left(%3d) is incorrect.\n\n",
+		 vb->save_effect.source_crop.left);
+		return -1;
+	}
+	if ((vb->save_effect.source_crop.top < IMAGE_TOP_MIN) ||
+	   (vb->save_effect.source_crop.top > vb->height)    ||
+	   (vb->save_effect.source_crop.top & IMAGE_TOP_ALINE) != 0) {
+		printk_info("error! source_crop.top(%3d) is incorrect.\n\n",
+		 vb->save_effect.source_crop.top);
+		return -1;
+	}
+
+	if ((vb->save_effect.source_crop.width < IMAGE_WIDTH_MIN) ||
+	   (vb->save_effect.source_crop.width > vb->width)	 ||
+	   (vb->save_effect.source_crop.width & image_width_aline) != 0) {
+		printk_info("error! source_crop.width(%3d) is incorrect.\n\n",
+		 vb->save_effect.source_crop.width);
+		return -1;
+	}
+
+	if ((vb->save_effect.source_crop.height < IMAGE_HEIGHT_MIN) ||
+	   (vb->save_effect.source_crop.height > vb->height)	   ||
+	   (vb->save_effect.source_crop.height & image_height_aline) != 0) {
+		printk_info("error! source_crop.height(%3d) is incorrect.\n\n",
+		 vb->save_effect.source_crop.height);
+		return -1;
+	}
+
+	if ((vb->save_effect.source_crop.left +
+		vb->save_effect.source_crop.width) > vb->width) {
+		printk_info(
+			"error! source_crop.left+width(%3d) is incorrect.\n\n",
+			vb->save_effect.source_crop.left +
+			vb->save_effect.source_crop.width);
+		return -1;
+	}
+	if ((vb->save_effect.source_crop.top +
+		vb->save_effect.source_crop.height) > vb->height) {
+		printk_info(
+			"error! source_crop.top+height(%3d) is incorrect.\n\n",
+			vb->save_effect.source_crop.top +
+			vb->save_effect.source_crop.height);
+		return -1;
+	}
+	return 0;
+}
+
+
+/*****************************************************************************
+* MODULE   : mp200_v4l2_core_vbq_sizecheck
+* FUNCTION :
+* RETURN   :  0: success
+*	   : -1: error
+* NOTE	   : This function registers information to video buffer.
+* CREATE   : 06/06/16 H.Nagashima
+* UPDATE   :
+******************************************************************************/
+static int mp200_v4l2_core_vbq_sizecheck(struct videobuf_queue *q,
+ struct videobuf_buffer *vb)
+{
+	unsigned int src_size, dst_size, dst_pos;
+	unsigned int src_org_size_w, src_org_size_h;
+	unsigned int image_width_aline, image_height_aline;
+	unsigned int image_width_aline_out, image_height_aline_out;
+	unsigned int front_width, front_height;
+
+	switch (vb->pixelformat) {
+	default:
+	case V4L2_PIX_FMT_NV12:	   /* YUV420 Semi-Planar */
+	case V4L2_PIX_FMT_NV422:   /* YUV422 Semi-Planar */
+		image_width_aline      = IMAGE_WIDTH_ALINE_SP;
+		image_height_aline     = IMAGE_HEIGHT_ALINE_SP;
+		image_width_aline_out  = IMAGE_WIDTH_ALINE_SP;
+		image_height_aline_out = IMAGE_HEIGHT_ALINE_SP;
+		break;
+	case V4L2_PIX_FMT_YVU420:  /* YUV420 Planar      */
+#if VF_YUV422PL
+	case V4L2_PIX_FMT_YUV422P: /* YUV422 Planar      */
+#endif
+		image_width_aline      = IMAGE_WIDTH_ALINE_PL;
+		image_height_aline     = IMAGE_HEIGHT_ALINE_PL;
+		image_width_aline_out  = IMAGE_WIDTH_ALINE_SP;	/* PL -> SP */
+		image_height_aline_out = IMAGE_HEIGHT_ALINE_SP; /* PL -> SP */
+		break;
+#if VF_YUV422PX
+	case V4L2_PIX_FMT_UYVY:	   /* YUV422 Interleave  */
+		image_width_aline      = IMAGE_WIDTH_ALINE_IL;
+		image_height_aline     = IMAGE_HEIGHT_ALINE_IL;
+		image_width_aline_out  = IMAGE_WIDTH_ALINE_IL;
+		image_height_aline_out = IMAGE_HEIGHT_ALINE_IL;
+		break;
+#endif
+	}
+
+	switch (vb->output) {
+	default:
+	case V4L2_OUTPUT_LCD:
+		front_width  = FRONT_WIDTH_V;
+		front_height = FRONT_HEIGHT_V;
+		break;
+#ifdef CONFIG_MP200_NTS
+	case V4L2_OUTPUT_NTSC:
+		front_width  = NTSC_WIDTH;
+		front_height = NTSC_HEIGHT;
+		break;
+	case V4L2_OUTPUT_PAL:
+		front_width  = PAL_WIDTH;
+		front_height = PAL_HEIGHT;
+		break;
+#endif
+	}
+
+	/* pix size check */
+	if (mp200_v4l2_core_vbq_sizecheck_pix(vb))
+		return -1;
+
+	/* crop size check */
+	if (mp200_v4l2_core_vbq_sizecheck_crop(vb))
+		return -1;
+
+	/* angle check */
+	if (vb->save_effect.movie_angle < ROT_MODE_ROT_MOD_0
+	 || vb->save_effect.movie_angle > ROT_MODE_ROT_MOD_270) {
+		printk_info("error! movie_angle(%d) is incorrect.\n\n",
+		 vb->save_effect.movie_angle);
+		return -1;
+	}
+
+	/* address check */
+	if ((vb->base_addr.PhysAddr_Y & IMAGE_PADDR_ALINE) != 0
+	 || vb->base_addr.PhysAddr_Y == IMAGE_PADDR_NULL) {
+		printk_info("error! PhysAddrY(0x%lx) is incorrect.\n\n",
+		 vb->base_addr.PhysAddr_Y);
+		return -1;
+	}
+	if (((vb->base_addr.PhysAddr_UV & IMAGE_PADDR_ALINE) != 0
+	 || vb->base_addr.PhysAddr_UV == IMAGE_PADDR_NULL)
+#if VF_YUV422PX
+	   && (vb->pixelformat != V4L2_PIX_FMT_UYVY)	/* YUV422 Interleave  */
+#endif
+	) {
+		printk_info("error! PhysAddrUV(0x%lx) is incorrect.\n\n",
+		 vb->base_addr.PhysAddr_UV);
+		return -1;
+	}
+	if (((vb->pixelformat == V4L2_PIX_FMT_YUV420) /* YUV420 Planar */
+#if VF_YUV422PL
+	 || (vb->pixelformat == V4L2_PIX_FMT_YUV422P) /* YUV422 Planar */
+#endif
+	   ) && ((vb->base_addr.PhysAddr_V & IMAGE_PADDR_ALINE) != 0
+	    || vb->base_addr.PhysAddr_V == IMAGE_PADDR_NULL)) {
+		printk_info("error! PhysAddrV(0x%lx) is incorrect.\n\n",
+		 vb->base_addr.PhysAddr_V);
+		return -1;
+	}
+
+	/* dest size check */
+	vb->save_effect.screen.width  -=
+		vb->save_effect.screen.width  & image_width_aline_out;
+	vb->save_effect.screen.height -=
+		vb->save_effect.screen.height & image_height_aline_out;
+
+	/* revise LCD output size */
+	if (vb->save_effect.screen.left > front_width
+	 || vb->save_effect.screen.top > front_height) {
+		vb->save_effect.screen.width  = 0;
+		vb->save_effect.screen.height = 0;
+		return 0;
+	}
+
+	src_org_size_w = vb->save_effect.source_crop.left
+	 + vb->save_effect.source_crop.width;
+	src_org_size_h = vb->save_effect.source_crop.top
+	 + vb->save_effect.source_crop.height;
+
+	if (vb->save_effect.screen.left + vb->save_effect.screen.width >
+		front_width) {
+		dst_pos	 = vb->save_effect.screen.left;
+		dst_size = vb->save_effect.screen.width;
+		vb->save_effect.screen.width = (front_width - dst_pos)
+		 & ~image_width_aline_out;
+		vb->save_effect.screen.left  =
+			front_width - vb->save_effect.screen.width;
+		if (vb->save_effect.movie_angle == ROT_MODE_ROT_MOD_0
+		 || vb->save_effect.movie_angle == ROT_MODE_ROT_MOD_180) {
+			src_size = vb->save_effect.source_crop.width;
+			vb->save_effect.source_crop.width  =
+				vb->save_effect.screen.width *
+				src_size / dst_size;
+			vb->save_effect.source_crop.width -=
+				(vb->save_effect.source_crop.width &
+				image_width_aline);
+			if (vb->save_effect.movie_angle == ROT_MODE_ROT_MOD_180)
+				vb->save_effect.source_crop.left =
+					src_org_size_w -
+					vb->save_effect.source_crop.width;
+
+		} else {
+			src_size = vb->save_effect.source_crop.height;
+			vb->save_effect.source_crop.height  =
+				vb->save_effect.screen.width *
+				src_size / dst_size;
+			vb->save_effect.source_crop.height -=
+				(vb->save_effect.source_crop.height &
+				image_height_aline);
+			if (vb->save_effect.movie_angle == ROT_MODE_ROT_MOD_90)
+				vb->save_effect.source_crop.top =
+					src_org_size_h -
+					vb->save_effect.source_crop.height;
+
+		}
+	}
+	if (vb->save_effect.screen.top + vb->save_effect.screen.height >
+		 front_height) {
+		dst_pos	 = vb->save_effect.screen.top;
+		dst_size = vb->save_effect.screen.height;
+		vb->save_effect.screen.height = (front_height - dst_pos)
+		 & ~image_height_aline_out;
+		vb->save_effect.screen.top = front_height
+		 - vb->save_effect.screen.height;
+		if (vb->save_effect.movie_angle == ROT_MODE_ROT_MOD_0
+		 || vb->save_effect.movie_angle == ROT_MODE_ROT_MOD_180) {
+			src_size = vb->save_effect.source_crop.height;
+			vb->save_effect.source_crop.height  =
+				vb->save_effect.screen.height *
+				src_size / dst_size;
+			vb->save_effect.source_crop.height -=
+				(vb->save_effect.source_crop.height &
+				image_height_aline);
+			if (vb->save_effect.movie_angle == ROT_MODE_ROT_MOD_180)
+				vb->save_effect.source_crop.top =
+					src_org_size_h -
+					vb->save_effect.source_crop.height;
+
+		} else {
+			src_size = vb->save_effect.source_crop.width;
+			vb->save_effect.source_crop.width  =
+				vb->save_effect.screen.height *
+				src_size / dst_size;
+			vb->save_effect.source_crop.width -=
+				(vb->save_effect.source_crop.width &
+				image_width_aline);
+			if (vb->save_effect.movie_angle == ROT_MODE_ROT_MOD_270)
+				vb->save_effect.source_crop.left =
+					src_org_size_w -
+					vb->save_effect.source_crop.width;
+
+		}
+	}
+
+	/* IMG not support dest size check */
+	if (vb->save_effect.screen.width < DEST_WIDTH_MIN
+	 || vb->save_effect.screen.height < DEST_HEIGHT_MIN) {
+		vb->save_effect.screen.width  = 0;
+		vb->save_effect.screen.height = 0;
+	} else if (vb->save_effect.source_crop.height < IMAGE_HEIGHT_MIN
+	 || vb->save_effect.source_crop.width < IMAGE_WIDTH_MIN) {
+		printk_info(
+			"error! source_crop.width(%3d) or "
+			"source_crop.height(%3d) is incorrect.\n\n",
+			vb->save_effect.source_crop.width,
+			vb->save_effect.source_crop.height);
+		return -1;
+	}
+
+#if RESIZE_CHECK
+	/* resize scaling check */
+	if (vb->save_effect.movie_angle == ROT_MODE_ROT_MOD_0
+	 || vb->save_effect.movie_angle == ROT_MODE_ROT_MOD_180) {
+		if (((RESIZE_WIDTH_MIN * vb->save_effect.screen.width) <
+			vb->save_effect.source_crop.width) ||
+			(vb->save_effect.screen.width >
+			(RESIZE_WIDTH_MAX *
+			vb->save_effect.source_crop.width))) {
+			printk_info(
+				"error! source_crop.width(%3d) or "
+				"screen.width(%3d) is incorrect.\n",
+				vb->save_effect.source_crop.width,
+				vb->save_effect.screen.width);
+			return -1;
+		}
+		if (((RESIZE_HEIGHT_MIN * vb->save_effect.screen.height) <
+			vb->save_effect.source_crop.height) ||
+			(vb->save_effect.screen.height >
+			(RESIZE_HEIGHT_MAX *
+			vb->save_effect.source_crop.height))) {
+			printk_info(
+				"error! source_crop.height(%3d) or "
+				"screen.height(%3d) is incorrect.\n",
+				vb->save_effect.source_crop.height,
+				vb->save_effect.screen.height);
+			return -1;
+		}
+	} else {
+		if (((RESIZE_WIDTH_MIN * vb->save_effect.screen.width) <
+			vb->save_effect.source_crop.height) ||
+			(vb->save_effect.screen.width >
+			(RESIZE_WIDTH_MAX *
+			vb->save_effect.source_crop.height))) {
+			printk_info(
+				"error! source_crop.height(%3d) or "
+				"screen.width(%3d) is incorrect.\n",
+				vb->save_effect.source_crop.height,
+				vb->save_effect.screen.width);
+			return -1;
+		}
+		if (((RESIZE_HEIGHT_MIN * vb->save_effect.screen.height) <
+			vb->save_effect.source_crop.width) ||
+		    (vb->save_effect.screen.height >
+		    (RESIZE_HEIGHT_MAX *
+		    vb->save_effect.source_crop.width))) {
+			printk_info(
+				"error! source_crop.width(%3d) or "
+				"screen.height(%3d) is incorrect.\n",
+				vb->save_effect.source_crop.width,
+				b->save_effect.screen.height);
+			return -1;
+		}
+	}
+#endif
+
+	return 0;
+}
+
+
+/*****************************************************************************
+* MODULE   : mp200_v4l2_core_vbq_setup
+* FUNCTION :
+* RETURN   : 0: success
+* NOTE	   : Limit the number of available kernel image capture buffers based
+*	   : on the number requested, the currently selected image size,
+*	   : and the maximum amount of memory permitted for kernel buffers.
+* CREATE   :
+* UPDATE   :
+******************************************************************************/
+static int mp200_v4l2_core_vbq_setup(struct videobuf_queue *q,
+ unsigned int *cnt, unsigned int *size)
+{
+	int retval = 0;
+	struct mp200_v4l2_device *dev = q->priv_data;
+	unsigned long flags;
+
+	spin_lock_irqsave(&dev->vbq_lock, flags);
+
+	if (*cnt <= 0)
+		*cnt = VIDEO_MAX_FRAME; /* supply a default number of buffers */
+
+	if (*cnt > VIDEO_MAX_FRAME)
+		*cnt = VIDEO_MAX_FRAME;
+
+	*size = dev->pix.sizeimage;
+
+	if (dev->pix.sizeimage <= 0)
+		retval = -1;
+
+	spin_unlock_irqrestore(&dev->vbq_lock, flags);
+	return retval;
+}
+
+
+/* ------------------ work_buffer_ops -------------------------------------- */
+/*****************************************************************************
+* MODULE   : mp200_v4l2_core_wkb_init
+* FUNCTION :
+* RETURN   :
+* NOTE	   : this function is substance of the ioctl system call.
+*	   :	VIDIOC_S_FMT
+* CREATE   : 2008/06/05 M.Haguro
+* UPDATE   :
+******************************************************************************/
+static inline void mp200_v4l2_core_wkb_init(struct mp200_v4l2_device *dev)
+{
+	if (dev->workbuf.active == WORKBUF_NO_INIT) { /* not init */
+		dev->workbuf.rot_addr = ROT_SMEM_START;
+		dev->workbuf.rot_size = ROT_SMEM_LENGTH;
+		dev->workbuf.img_addr = IMG_SMEM_START;
+		dev->workbuf.img_size = IMG_SMEM_LENGTH;
+		dev->workbuf.active   = WORKBUF_INIT;
+	}
+}
+
+
+/*****************************************************************************
+* MODULE   : mp200_v4l2_core_wkb_active
+* FUNCTION :
+* RETURN   :	   0: success
+*	   : -EINVAL: misstype argument
+* NOTE	   : this function is substance of the ioctl system call.
+*	   :	VIDIOC_S_FMT
+* CREATE   : 2008/06/05 M.Haguro
+* UPDATE   :
+******************************************************************************/
+static int mp200_v4l2_core_wkb_active(struct mp200_v4l2_device *dev,
+ unsigned int cmd, void *arg)
+{
+	mp200_v4l2_core_wkb_init(dev);
+
+	if (cmd == VIDIOC_G_FMT || cmd == VIDIOC_G_CROP
+	 || cmd == VIDIOC_G_CTRL || cmd == VIDIOC_G_EFFECT) {
+		/* ioctl(VIDIOC_G_FMT) || ioctl(VIDIOC_G_CROP)
+		 || ioctl(VIDIOC_G_CTRL) || ioctl(VIDIOC_G_EFFECT) */
+		;
+	} else if (cmd == VIDIOC_S_FMT) {
+		/* ioctl(VIDIOC_S_FMT) */
+		if (((struct v4l2_format *)arg)->type
+		 == V4L2_BUF_TYPE_PRIVATE) {
+			if (dev->workbuf.active == WORKBUF_ACTIVE) {
+				printk_info(
+					"error! this ioctl(VIDIOC_S_FMT) "
+					"is invalid.\n");
+				return -EPERM;
+			}
+	} else{
+			/* other type */
+			dev->workbuf.active = WORKBUF_ACTIVE;
+		}
+	} else{
+		/* other ioctl */
+		dev->workbuf.active = WORKBUF_ACTIVE;
+	}
+	return 0;
+}
+
+
+/*****************************************************************************
+* MODULE   : mp200_v4l2_core_wkb_chkbuf
+* FUNCTION :
+* RETURN   :	   0: success
+*	   : -EINVAL: misstype argument
+* NOTE	   : this function is substance of the ioctl system call.
+*	   :	VIDIOC_S_FMT
+* CREATE   : 2008/06/05 M.Haguro
+* UPDATE   :
+******************************************************************************/
+static int mp200_v4l2_core_wkb_chkbuf(struct v4l2_workbuffer *wbuf)
+{
+	/* check workbuffer size */
+	if (wbuf->rot_size < 0)
+		return -EINVAL;
+
+	if (wbuf->img_size < 0)
+		return -EINVAL;
+
+	/* check workbuffer area */
+	if (wbuf->rot_addr < wbuf->img_addr) {
+		if (wbuf->rot_addr + wbuf->rot_size > wbuf->img_addr)
+			return -EFAULT;
+	} else{
+		if (wbuf->img_addr + wbuf->img_size > wbuf->rot_addr)
+			return -EFAULT;
+	}
+	return 0;
+}
+
+
+/*****************************************************************************
+* MODULE   : mp200_v4l2_core_wkb_chksize
+* FUNCTION :
+* RETURN   :	   0: success
+*	   : -EINVAL: misstype argument
+* NOTE	   : this function is substance of the ioctl system call.
+*	   :	VIDIOC_QBUF
+* CREATE   : 2008/06/05 M.Haguro
+* UPDATE   :
+******************************************************************************/
+static int mp200_v4l2_core_wkb_chksize(struct mp200_v4l2_device *dev,
+ struct videobuf_buffer *vb)
+{
+	int bpp = 0;
+
+	if (vb->pixelformat == V4L2_PIX_FMT_NV12
+	 || vb->pixelformat == V4L2_PIX_FMT_YVU420) {
+		bpp = 12;	/* YUV420 Semi-Planar || YUV420 Planar */
+	} else if (vb->pixelformat == V4L2_PIX_FMT_NV422
+#if VF_YUV422PL
+		|| vb->pixelformat == V4L2_PIX_FMT_YUV422P
+#endif
+#if VF_YUV422PX
+		|| vb->pixelformat == V4L2_PIX_FMT_UYVY
+#endif
+	) {
+		bpp = 16;	/* YUV422 Semi-Planar */
+	} else{
+		return -EINVAL;
+	}
+
+	/* check use ROT */
+	if (vb->save_effect.movie_angle != ROT_MODE_ROT_MOD_0) {
+		if ((vb->save_effect.source_crop.width *
+			vb->save_effect.source_crop.height * bpp / 8) >
+			((dev->workbuf.rot_size / NUM_BUF_V4L2) & ~0x3)) {
+			printk_info(
+				"error! WorkBuffer(IPU-ROT) is insufficient.  "
+				">>> crop(%d*%d =0x%x) > workbuf(0x%x)\n\n",
+				vb->save_effect.source_crop.width,
+				vb->save_effect.source_crop.height,
+				(vb->save_effect.source_crop.width *
+				vb->save_effect.source_crop.height * bpp / 8),
+				((dev->workbuf.rot_size / NUM_BUF_V4L2) &
+				~0x3));
+			return -EINVAL;
+		}
+	}
+
+	if (vb->output == V4L2_OUTPUT_LCD) {
+		/* check use IMG */
+		if (vb->save_effect.movie_angle == ROT_MODE_ROT_MOD_0
+		 || vb->save_effect.movie_angle == ROT_MODE_ROT_MOD_180) {
+			if ((vb->save_effect.source_crop.width
+			 != vb->save_effect.screen.width)
+			  || (vb->save_effect.source_crop.height
+			   != vb->save_effect.screen.height)) { /* resize */
+				if ((vb->save_effect.screen.width *
+					vb->save_effect.screen.height * bpp /
+					8) > ((dev->workbuf.img_size /
+					NUM_BUF_V4L2) & ~0x3)) {
+					printk_info(
+						"error! WorkBuffer(IPU-IMG) "
+						"is insufficient.  >>> screen"
+						"(%d*%d =0x%x) > workbuf(0x%x)"
+						"\n\n",
+						vb->save_effect.screen.width,
+						vb->save_effect.screen.height,
+						(vb->save_effect.screen.width *
+						vb->save_effect.screen.height *
+						bpp / 8),
+						((dev->workbuf.img_size /
+						NUM_BUF_V4L2) & ~0x3));
+					return -EINVAL;
+				}
+			}
+		} else{
+		    /* vb->save_effect.movie_angle == ROT_MODE_ROT_MOD_90
+		    || vb->save_effect.movie_angle == ROT_MODE_ROT_MOD_270 */
+			if ((vb->save_effect.source_crop.width
+			 != vb->save_effect.screen.height)
+			  || (vb->save_effect.source_crop.height
+			   != vb->save_effect.screen.width))  { /* resize */
+				if ((vb->save_effect.screen.width *
+					vb->save_effect.screen.height *
+					bpp / 8) > ((dev->workbuf.img_size /
+					NUM_BUF_V4L2) & ~0x3)) {
+					printk_info(
+						"error! WorkBuffer(IPU-IMG) "
+						"is insufficient.  >>> screen"
+						"(%d*%d =0x%x) > workbuf(0x%x)"
+						"\n\n",
+						vb->save_effect.screen.width,
+						vb->save_effect.screen.height,
+						(vb->save_effect.screen.width *
+						vb->save_effect.screen.height *
+						bpp / 8),
+						((dev->workbuf.img_size /
+						NUM_BUF_V4L2) & ~0x3));
+					return -EINVAL;
+				}
+			}
+		}
+	}
+
+	return 0;
+}
+
+
+/* ------------------ system_call_ops -------------------------------------- */
+/*****************************************************************************
+* MODULE   : mp200_v4l2_ioc_g_output
+* FUNCTION : sub function of mp200_v4l2_core_do_ioctl()
+* RETURN   :	   0: success
+* NOTE	   : this function is substance of the ioctl system call.
+*	   :	VIDIOC_G_OUTPUT
+* CREATE   : 2008/11/18 M.Haguro
+* UPDATE   :
+******************************************************************************/
+static inline int mp200_v4l2_ioc_g_output(struct mp200_v4l2_fh *fh,
+ unsigned int *output)
+{
+	*output = ((struct mp200_v4l2_device *)fh->dev)->output;
+	return 0;
+}
+
+
+/*****************************************************************************
+* MODULE   : mp200_v4l2_ioc_s_output
+* FUNCTION : sub function of mp200_v4l2_core_do_ioctl()
+* RETURN   :	   0: success
+*	   : -EINVAL: misstype *output
+*	   :	-EIO: error
+* NOTE	   : this function is substance of the ioctl system call.
+*	   :	VIDIOC_S_OUTPUT
+* CREATE   : 2008/11/18 M.Haguro
+* UPDATE   :
+******************************************************************************/
+static int mp200_v4l2_ioc_s_output(struct mp200_v4l2_fh *fh,
+ unsigned int *output)
+{
+	struct mp200_v4l2_device *dev = fh->dev;
+	int retval = 0;
+	unsigned long flags;
+
+	spin_lock_irqsave(&dev->vbq_lock, flags);
+
+	switch (*output) {
+	case V4L2_OUTPUT_LCD:
+#ifdef CONFIG_MP200_NTS
+		if (dev->output != V4L2_OUTPUT_LCD) {
+			spin_unlock_irqrestore(&dev->vbq_lock, flags);
+			if (dev->streaming) {
+				mp200_v4l2_ioc_streamoff(fh, dev);
+				mp200_nts_release(NTS_ACTIVE_V4L2);
+				dev->output = *output;
+				mp200_v4l2_ioc_streamon(fh, dev);
+			} else{
+				mp200_nts_release(NTS_ACTIVE_V4L2);
+			}
+			spin_lock_irqsave(&dev->vbq_lock, flags);
+		}
+#endif /* CONFIG_MP200_NTS */
+		dev->output = *output;
+		break;
+#ifdef CONFIG_MP200_NTS
+	case V4L2_OUTPUT_NTSC:
+	case V4L2_OUTPUT_PAL:
+		retval = mp200_nts_getmode();
+		if (retval != V4L2_OUTPUT_LCD && retval != *output) {
+			/* NTS reserved in other mode. */
+			retval = -EIO;
+		} else{
+			spin_unlock_irqrestore(&dev->vbq_lock, flags);
+			if (dev->streaming) {
+				mp200_v4l2_ioc_streamoff(fh, dev);
+				retval = mp200_nts_reserve(NTS_ACTIVE_V4L2,
+				 *output);
+				mp200_v4l2_ioc_streamon(fh, dev);
+			} else{
+				retval = mp200_nts_reserve(NTS_ACTIVE_V4L2,
+				 *output);
+			}
+			spin_lock_irqsave(&dev->vbq_lock, flags);
+			if (retval) {
+				retval = -EIO;
+			} else{
+				/* success NTS reserve */
+				dev->output = *output;
+			}
+		}
+		break;
+#endif /* CONFIG_MP200_NTS */
+	default:
+		retval = -EINVAL;
+		break;
+	}
+
+	spin_unlock_irqrestore(&dev->vbq_lock, flags);
+	return retval;
+}
+
+
+/*****************************************************************************
+* MODULE   : mp200_v4l2_ioc_g_fmt
+* FUNCTION : sub function of mp200_v4l2_core_do_ioctl()
+* RETURN   :	   0: success
+*	   : -EINVAL: misstype fmt->type
+* NOTE	   : this function is substance of the ioctl system call.
+*	   :	VIDIOC_G_FMT
+* CREATE   : 2008/02/28 M.Haguro
+* UPDATE   :
+******************************************************************************/
+static int mp200_v4l2_ioc_g_fmt(struct mp200_v4l2_device *dev,
+ struct v4l2_format *fmt)
+{
+	struct v4l2_workbuffer *wbuf;
+	int retval = 0;
+	unsigned long flags;
+
+	wbuf = (struct v4l2_workbuffer *)fmt->fmt.raw_data;
+
+	spin_lock_irqsave(&dev->vbq_lock, flags);
+	if (fmt->type == V4L2_BUF_TYPE_VIDEO_OUTPUT) {
+		/* get the current format */
+		fmt->fmt.pix = dev->pix;
+	} else if (fmt->type == V4L2_BUF_TYPE_VIDEO_OVERLAY) {
+		/* get overlay info */
+		fmt->fmt.win.w = dev->efct.screen;
+	} else if (fmt->type == V4L2_BUF_TYPE_PRIVATE) {
+		/* get workbuffer info */
+		memcpy(wbuf, &dev->workbuf, sizeof(struct v4l2_workbuffer));
+	} else{
+		retval = -EINVAL;
+	}
+	spin_unlock_irqrestore(&dev->vbq_lock, flags);
+	return retval;
+}
+
+
+/*****************************************************************************
+* MODULE   : mp200_v4l2_ioc_s_fmt
+* FUNCTION : sub function of mp200_v4l2_core_do_ioctl()
+* RETURN   :	   0: success
+*	   : -EINVAL: misstype fmt->type
+* NOTE	   : this function is substance of the ioctl system call.
+*	   :	VIDIOC_S_FMT
+* CREATE   : 2008/02/28 M.Haguro
+* UPDATE   :
+******************************************************************************/
+static int mp200_v4l2_ioc_s_fmt(struct mp200_v4l2_device *dev,
+ struct v4l2_format *fmt)
+{
+	int retval = 0;
+	unsigned long flags;
+
+	spin_lock_irqsave(&dev->vbq_lock, flags);
+	if (fmt->type == V4L2_BUF_TYPE_VIDEO_OUTPUT) {
+		/* set image info */
+		dev->pix.sizeimage    = sizeof(struct videobuf_buffer);
+		dev->pix.width	      = fmt->fmt.pix.width;
+		dev->pix.height	      = fmt->fmt.pix.height;
+		dev->pix.pixelformat  = fmt->fmt.pix.pixelformat;
+		dev->pix.bytesperline = fmt->fmt.pix.bytesperline;
+	} else if (fmt->type == V4L2_BUF_TYPE_VIDEO_OVERLAY) {
+		if (dev->efct.source_crop.width &&
+			dev->efct.source_crop.height) {
+			if ((dev->efct.source_crop.width !=
+				fmt->fmt.win.w.width ||
+				dev->efct.source_crop.height !=
+				fmt->fmt.win.w.height) &&
+				(!dev->workbuf.img_addr ||
+				!dev->workbuf.img_size)) {
+				retval = -ENOMEM;
+				goto err_ret;
+			}
+		}
+		/* set overlay info */
+		dev->efct.screen.left	= fmt->fmt.win.w.left;
+		dev->efct.screen.top	= fmt->fmt.win.w.top;
+		dev->efct.screen.width	= fmt->fmt.win.w.width;
+		dev->efct.screen.height = fmt->fmt.win.w.height;
+	} else if (fmt->type == V4L2_BUF_TYPE_PRIVATE) {
+		struct v4l2_workbuffer *wbuf;
+
+		wbuf = (struct v4l2_workbuffer *)fmt->fmt.raw_data;
+		if (mp200_v4l2_core_wkb_chkbuf(wbuf)) {
+			retval = -EINVAL;
+			goto err_ret;
+		}
+		/* set workbuffer info */
+		dev->workbuf.rot_addr = wbuf->rot_addr;
+		dev->workbuf.rot_size = wbuf->rot_size;
+		dev->workbuf.img_addr = wbuf->img_addr;
+		dev->workbuf.img_size = wbuf->img_size;
+	} else{
+		retval = -EINVAL;
+	}
+err_ret:
+	spin_unlock_irqrestore(&dev->vbq_lock, flags);
+	return retval;
+}
+
+
+/*****************************************************************************
+* MODULE   : mp200_v4l2_ioc_g_crop
+* FUNCTION : sub function of mp200_v4l2_core_do_ioctl()
+* RETURN   :	   0: success
+*	   : -EINVAL: misstype vc->type
+* NOTE	   : this function is substance of the ioctl system call.
+*	   :	VIDIOC_G_CROP
+* CREATE   : 2008/02/28 M.Haguro
+* UPDATE   :
+******************************************************************************/
+static int mp200_v4l2_ioc_g_crop(struct mp200_v4l2_device *dev,
+ struct v4l2_crop *vc)
+{
+	int retval = 0;
+	unsigned long flags;
+
+	spin_lock_irqsave(&dev->vbq_lock, flags);
+	if (vc->type == V4L2_BUF_TYPE_VIDEO_OVERLAY) {
+		/* get crop data of original movie */
+		vc->c.left   = dev->efct.source_crop.left;
+		vc->c.top    = dev->efct.source_crop.top;
+		vc->c.width  = dev->efct.source_crop.width;
+		vc->c.height = dev->efct.source_crop.height;
+	} else{
+		retval = -EINVAL;
+	}
+	spin_unlock_irqrestore(&dev->vbq_lock, flags);
+	return retval;
+}
+
+
+/*****************************************************************************
+* MODULE   : mp200_v4l2_ioc_s_crop
+* FUNCTION : sub function of mp200_v4l2_core_do_ioctl()
+* RETURN   :	   0: success
+*	   : -EINVAL: misstype vc->type
+* NOTE	   : this function is substance of the ioctl system call.
+*	   :	VIDIOC_S_CROP
+* CREATE   : 2008/02/28 M.Haguro
+* UPDATE   :
+******************************************************************************/
+static int mp200_v4l2_ioc_s_crop(struct mp200_v4l2_device *dev,
+ struct v4l2_crop *vc)
+{
+	int retval = 0;
+	unsigned long flags;
+
+	spin_lock_irqsave(&dev->vbq_lock, flags);
+	if (vc->type == V4L2_BUF_TYPE_VIDEO_OVERLAY) {
+		if (dev->efct.screen.width && dev->efct.screen.height) {
+			if ((dev->efct.screen.width != vc->c.width
+			 || dev->efct.screen.height != vc->c.height)
+			  && (!dev->workbuf.img_addr
+			   || !dev->workbuf.img_size)) {
+				retval = -ENOMEM;
+				goto err_ret;
+			}
+		}
+		/* set crop data of original movie */
+		dev->efct.source_crop.left   = vc->c.left;
+		dev->efct.source_crop.top    = vc->c.top;
+		dev->efct.source_crop.width  = vc->c.width;
+		dev->efct.source_crop.height = vc->c.height;
+	} else{
+		retval = -EINVAL;
+	}
+err_ret:
+	spin_unlock_irqrestore(&dev->vbq_lock, flags);
+	return retval;
+}
+
+
+/*****************************************************************************
+* MODULE   : mp200_v4l2_ioc_g_ctrl
+* FUNCTION : sub function of mp200_v4l2_core_do_ioctl()
+* RETURN   :	   0: success
+*	   : -EINVAL: misstype vc->id
+* NOTE	   : this function is substance of the ioctl system call.
+*	   :	VIDIOC_G_CTRL
+* CREATE   : 2008/02/28 M.Haguro
+* UPDATE   :
+******************************************************************************/
+static int mp200_v4l2_ioc_g_ctrl(struct mp200_v4l2_device *dev,
+ struct v4l2_control *vc)
+{
+	int retval = 0;
+	unsigned long flags;
+
+	spin_lock_irqsave(&dev->vbq_lock, flags);
+	if (vc->id == V4L2_MOVIE_DISPLAY_ANGLE) {
+		/* get current rotation angle */
+		vc->value = dev->efct.movie_angle;
+	} else{
+		retval = -EINVAL;
+	}
+	spin_unlock_irqrestore(&dev->vbq_lock, flags);
+	return retval;
+}
+
+
+/*****************************************************************************
+* MODULE   : mp200_v4l2_ioc_s_ctrl
+* FUNCTION : sub function of mp200_v4l2_core_do_ioctl()
+* RETURN   :	   0: success
+*	   : -EINVAL: misstype vc->id
+* NOTE	   : this function is substance of the ioctl system call.
+*	   :	VIDIOC_S_CTRL
+* CREATE   : 2008/02/28 M.Haguro
+* UPDATE   :
+******************************************************************************/
+static int mp200_v4l2_ioc_s_ctrl(struct mp200_v4l2_device *dev,
+ struct v4l2_control *vc)
+{
+	int retval = 0;
+	unsigned long flags;
+
+	spin_lock_irqsave(&dev->vbq_lock, flags);
+	if (vc->id == V4L2_MOVIE_DISPLAY_ANGLE) {
+		if (vc->value != ROT_MODE_ROT_MOD_0
+		 && (!dev->workbuf.rot_addr || !dev->workbuf.rot_size)) {
+			retval = -ENOMEM;
+		} else{
+			/* set rotation angle */
+			dev->efct.movie_angle = vc->value;
+		}
+	} else{
+		retval = -EINVAL;
+	}
+	spin_unlock_irqrestore(&dev->vbq_lock, flags);
+	return retval;
+}
+
+
+/*****************************************************************************
+* MODULE   : mp200_v4l2_ioc_g_effect
+* FUNCTION : sub function of mp200_v4l2_core_do_ioctl()
+* RETURN   :	   0: success
+* NOTE	   : this function is substance of the ioctl system call.
+*	   :	VIDIOC_G_EFFECT
+* CREATE   : 2008/02/28 M.Haguro
+* UPDATE   :
+******************************************************************************/
+static int mp200_v4l2_ioc_g_effect(struct mp200_v4l2_device *dev,
+ struct v4l2_effect *vef)
+{
+	int retval = 0;
+	unsigned long flags;
+
+	spin_lock_irqsave(&dev->vbq_lock, flags);
+	/* get current effect infomation */
+	vef->sequence		= dev->efct.sequence;
+	vef->source_crop.left	= dev->efct.source_crop.left;
+	vef->source_crop.top	= dev->efct.source_crop.top;
+	vef->source_crop.width	= dev->efct.source_crop.width;
+	vef->source_crop.height = dev->efct.source_crop.height;
+	vef->movie_angle	= dev->efct.movie_angle;
+	vef->screen.left	= dev->efct.screen.left;
+	vef->screen.top		= dev->efct.screen.top;
+	vef->screen.width	= dev->efct.screen.width;
+	vef->screen.height	= dev->efct.screen.height;
+	spin_unlock_irqrestore(&dev->vbq_lock, flags);
+	return retval;
+}
+
+
+/*****************************************************************************
+* MODULE   : mp200_v4l2_ioc_s_effect
+* FUNCTION : sub function of mp200_v4l2_core_do_ioctl()
+* RETURN   :	   0: success
+* NOTE	   : this function is substance of the ioctl system call.
+*	   :	VIDIOC_S_EFFECT
+* CREATE   : 2008/02/28 M.Haguro
+* UPDATE   :
+******************************************************************************/
+static int mp200_v4l2_ioc_s_effect(struct mp200_v4l2_device *dev,
+ struct v4l2_effect *vef)
+{
+	int retval = 0;
+	unsigned long flags;
+
+	spin_lock_irqsave(&dev->vbq_lock, flags);
+
+	if ((vef->screen.width != vef->source_crop.width
+	 || vef->screen.height != vef->source_crop.height)
+	  && (!dev->workbuf.img_addr || !dev->workbuf.img_size)) {
+		retval = -ENOMEM;
+		goto err_ret;
+	}
+	if (vef->movie_angle != ROT_MODE_ROT_MOD_0
+	 && (!dev->workbuf.rot_addr || !dev->workbuf.rot_size)) {
+		retval = -ENOMEM;
+		goto err_ret;
+	}
+
+	/* set effect infomation */
+	dev->efct.sequence	     = 0;
+	dev->efct.source_crop.left   = vef->source_crop.left;
+	dev->efct.source_crop.top    = vef->source_crop.top;
+	dev->efct.source_crop.width  = vef->source_crop.width;
+	dev->efct.source_crop.height = vef->source_crop.height;
+	dev->efct.movie_angle	     = vef->movie_angle;
+	dev->efct.screen.left	     = vef->screen.left;
+	dev->efct.screen.top	     = vef->screen.top;
+	dev->efct.screen.width	     = vef->screen.width;
+	dev->efct.screen.height	     = vef->screen.height;
+
+err_ret:
+	spin_unlock_irqrestore(&dev->vbq_lock, flags);
+	return retval;
+}
+
+
+/*****************************************************************************
+* MODULE   : mp200_v4l2_ioc_reqbufs
+* FUNCTION : sub function of mp200_v4l2_core_do_ioctl()
+* RETURN   :	   0: success
+* NOTE	   : this function is substance of the ioctl system call.
+*	   :	VIDIOC_REQBUFS
+* CREATE   : 2008/02/28 M.Haguro
+* UPDATE   :
+******************************************************************************/
+static inline int mp200_v4l2_ioc_reqbufs(struct mp200_v4l2_device *dev,
+ struct videobuf_queue *vbq, struct v4l2_requestbuffers *req)
+{
+	/* request memory for queue */
+	return videobuf_reqbufs(vbq, req);
+}
+
+
+/*****************************************************************************
+* MODULE   : mp200_v4l2_ioc_qbuf
+* FUNCTION : sub function of mp200_v4l2_core_do_ioctl()
+* RETURN   :	   0: success
+* NOTE	   : this function is substance of the ioctl system call.
+*	   :	VIDIOC_QBUF
+* CREATE   : 2008/02/28 M.Haguro
+* UPDATE   :
+******************************************************************************/
+static inline int mp200_v4l2_ioc_qbuf(struct mp200_v4l2_device *dev,
+ struct videobuf_queue *vbq, struct v4l2_buffer *vb)
+{
+	/* enqueue videoframe-buffer */
+	return videobuf_qbuf(vbq, vb);
+}
+
+
+/*****************************************************************************
+* MODULE   : mp200_v4l2_ioc_dqbuf
+* FUNCTION : sub function of mp200_v4l2_core_do_ioctl()
+* RETURN   :	   0: success
+* NOTE	   : this function is substance of the ioctl system call.
+*	   :	VIDIOC_DQBUF
+* CREATE   : 2008/02/28 M.Haguro
+* UPDATE   :
+******************************************************************************/
+static inline int mp200_v4l2_ioc_dqbuf(struct mp200_v4l2_device *dev,
+ struct videobuf_queue *vbq, struct v4l2_buffer *vb, int f_flags)
+{
+	/* dequeue videoframe-buffer */
+	return videobuf_dqbuf(vbq, vb, f_flags & O_NONBLOCK);
+}
+
+
+/*****************************************************************************
+* MODULE   : mp200_v4l2_ioc_streamon
+* FUNCTION : sub function of mp200_v4l2_core_do_ioctl()
+* RETURN   :	   0: success
+*	   :  -EBUSY:
+* NOTE	   : this function is substance of the ioctl system call.
+*	   :	VIDIOC_STREAMON
+* CREATE   : 2008/02/28 M.Haguro
+* UPDATE   :
+******************************************************************************/
+static int mp200_v4l2_ioc_streamon(struct mp200_v4l2_fh *fh,
+ struct mp200_v4l2_device *dev)
+{
+	int retval = 0;
+	unsigned long flags;
+
+	spin_lock_irqsave(&dev->vbq_lock, flags);
+	if (dev->streaming) {
+		retval = -EBUSY;
+		spin_unlock_irqrestore(&dev->vbq_lock, flags);
+	} else {
+		dev->streaming = fh;
+		dev->vb_old_refresh = NULL;
+		dev->vb_old = NULL;
+		dev->mixing = 0;
+
+		/* init thread info */
+		mp200_v4l2_thread_init(dev);
+
+		/* init timer */
+		mp200_v4l2_tmr_init(dev);
+		spin_unlock_irqrestore(&dev->vbq_lock, flags);
+
+		retval = videobuf_streamon(&fh->vbq);
+	}
+	return retval;
+}
+
+
+/*****************************************************************************
+* MODULE   : mp200_v4l2_ioc_streamoff
+* FUNCTION : sub function of mp200_v4l2_core_do_ioctl()
+* RETURN   :	   0: success
+*	   :	 err:
+* NOTE	   : this function is substance of the ioctl system call.
+*	   :	VIDIOC_STREAMOFF
+* CREATE   : 2008/02/28 M.Haguro
+* UPDATE   :
+******************************************************************************/
+static int mp200_v4l2_ioc_streamoff(struct mp200_v4l2_fh *fh,
+ struct mp200_v4l2_device *dev)
+{
+	int retval = 0;
+	unsigned long flags;
+
+	spin_lock_irqsave(&dev->vbq_lock, flags);
+
+	dev->streamoff = fh;
+	spin_unlock_irqrestore(&dev->vbq_lock, flags);
+
+	/* streamoff */
+	retval = videobuf_streamoff(&fh->vbq);
+	if (retval < 0) {
+		spin_lock_irqsave(&dev->vbq_lock, flags);
+		dev->streamoff = NULL;
+		spin_unlock_irqrestore(&dev->vbq_lock, flags);
+	} else{
+		spin_lock_irqsave(&dev->vbq_lock, flags);
+
+		/* init thread info */
+		mp200_v4l2_thread_init(dev);
+		wake_up_interruptible(&dev->th_rot.th_busy);
+		wake_up_interruptible(&dev->th_rot.th_buf->buf_busy);
+		wake_up_interruptible(&dev->th_img.th_busy);
+		wake_up_interruptible(&dev->th_img.th_buf->buf_busy);
+		wake_up_interruptible(&dev->th_tmr.th_busy);
+		wake_up_interruptible(&dev->th_lcd.th_busy);
+
+		if (dev->streaming == fh) {
+			/* stop timer */
+			del_timer_sync(&dev->timer.wait_timer);
+
+			/* call lcd driver function. */
+			spin_unlock_irqrestore(&dev->vbq_lock, flags);
+			mp200_v4l2_lcd_request(dev, NULL, STREAM_STOP);
+			spin_lock_irqsave(&dev->vbq_lock, flags);
+
+			dev->streaming = NULL;
+			dev->vb_old_refresh = NULL;
+			dev->vb_old    = NULL;
+			dev->mixing    = 0;
+		}
+		/* video-buffer-queue sequence number initialize */
+		fh->vbq.sequence = 0;
+		dev->streamoff	 = NULL;
+
+		spin_unlock_irqrestore(&dev->vbq_lock, flags);
+	}
+	return retval;
+}
+
+
+/*****************************************************************************
+* MODULE   : mp200_v4l2_core_do_ioctl
+* FUNCTION :
+* RETURN   :	   0: success
+*	   : -EINVAL: Argument error
+* NOTE	   : this function is substance of the ioctl system call.
+*	   : @@ supported ioctl command
+*	   :	VIDIOC_S_FMT,	    VIDIOC_G_FMT,	VIDIOC_S_CROP,
+*	   :	VIDIOC_G_CROP,	    VIDIOC_S_CTRL,	VIDIOC_G_CTRL,
+*	   :	VIDIOC_REQBUFS,	    VIDIOC_S_EFFECT,	VIDIOC_G_EFFECT,
+*	   :	VIDIOC_STREAMON,    VIDIOC_STREAMOFF,	VIDIOC_QBUF,
+*	   :	VIDIOC_DQBUF
+*	   : @@ not supported ioctl command
+*	   :	VIDIOC_ENUMINPUT,   VIDIOC_G_INPUT,	VIDIOC_S_INPUT,
+*	   :	VIDIOC_ENUM_FMT,    VIDIOC_TRY_FMT,	VIDIOC_QUERYCTRL,
+*	   :	VIDIOC_G_FBUF,	    VIDIOC_S_FBUF,	VIDIOC_OVERLAY,
+*	   :	VIDIOC_ENUMSTD,	    VIDIOC_G_STD,	VIDIOC_S_STD,
+*	   :	VIDIOC_QUERYSTD,    VIDIOC_G_AUDIO,	VIDIOC_S_AUDIO
+*	   :	VIDIOC_G_AUDOUT,    VIDIOC_S_AUDOUT,	VIDIOC_G_JPEGCOMP,
+*	   :	VIDIOC_S_JPEGCOMP,  VIDIOC_G_TUNER,	VIDIOC_S_TUNER,
+*	   :	VIDIOC_G_MODULATOR, VIDIOC_S_MODULATOR, VIDIOC_G_FREQUENCY,
+*	   :	VIDIOC_S_FREQUENCY, VIDIOC_QUERYCAP,	VIDIOC_ENUMOUTPUT,
+*	   :	VIDIOC_G_OUTPUT,    VIDIOC_S_OUTPUT,	VIDIOC_QUERYBUF
+* CREATE   :
+* UPDATE   : 2006/06/16 M.Haguro
+******************************************************************************/
+static int mp200_v4l2_core_do_ioctl(struct inode *inode, struct file *file,
+ unsigned int cmd, void *arg)
+{
+	struct mp200_v4l2_fh	 *fh  = file->private_data;
+	struct mp200_v4l2_device *dev = fh->dev;
+
+
+	/* check IMG/ROT workbuffer */
+	if (mp200_v4l2_core_wkb_active(dev, cmd, arg))
+		return -EPERM;
+
+	switch (cmd) {
+	case VIDIOC_G_OUTPUT:
+		return mp200_v4l2_ioc_g_output(fh, arg);
+
+	case VIDIOC_S_OUTPUT:
+		return mp200_v4l2_ioc_s_output(fh, arg);
+
+	case VIDIOC_G_FMT:
+		return mp200_v4l2_ioc_g_fmt(dev, arg);
+
+	case VIDIOC_S_FMT:
+		return mp200_v4l2_ioc_s_fmt(dev, arg);
+
+	case VIDIOC_G_CROP:
+		return mp200_v4l2_ioc_g_crop(dev, arg);
+
+	case VIDIOC_S_CROP:
+		return mp200_v4l2_ioc_s_crop(dev, arg);
+
+	case VIDIOC_G_CTRL:
+		return mp200_v4l2_ioc_g_ctrl(dev, arg);
+
+	case VIDIOC_S_CTRL:
+		return mp200_v4l2_ioc_s_ctrl(dev, arg);
+
+	case VIDIOC_G_EFFECT:
+		return mp200_v4l2_ioc_g_effect(dev, arg);
+
+	case VIDIOC_S_EFFECT:
+		return mp200_v4l2_ioc_s_effect(dev, arg);
+
+	case VIDIOC_REQBUFS:
+		return mp200_v4l2_ioc_reqbufs(dev, &fh->vbq, arg);
+
+	case VIDIOC_QBUF:
+		return mp200_v4l2_ioc_qbuf(dev, &fh->vbq, arg);
+
+	case VIDIOC_DQBUF:
+		return mp200_v4l2_ioc_dqbuf(dev, &fh->vbq, arg, file->f_flags);
+
+	case VIDIOC_STREAMON:
+		return mp200_v4l2_ioc_streamon(fh, dev);
+
+	case VIDIOC_STREAMOFF:
+		return mp200_v4l2_ioc_streamoff(fh, dev);
+
+	/*--- not supported ---*/
+	case VIDIOC_QUERYBUF:
+		/* not supported */
+		return -EINVAL;
+
+	case VIDIOC_ENUMINPUT:	/* FALL THROUGH */
+	case VIDIOC_G_INPUT:	/* FALL THROUGH */
+	case VIDIOC_S_INPUT:	/* FALL THROUGH */
+	case VIDIOC_ENUM_FMT:	/* FALL THROUGH */
+	case VIDIOC_TRY_FMT:	/* FALL THROUGH */
+	case VIDIOC_QUERYCTRL:
+		/* not supported */
+		return -EINVAL;
+
+	case VIDIOC_QUERYCAP:	/* FALL THROUGH */
+	/* FALL THROUGH Get the frame buffer parameters */
+	case VIDIOC_G_FBUF:
+	/* FALL THROUGH set the frame buffer parameters */
+	case VIDIOC_S_FBUF:
+	case VIDIOC_OVERLAY:
+		/* not supported */
+		return -EINVAL;
+
+	case VIDIOC_ENUMSTD:	/* FALL THROUGH */
+	case VIDIOC_G_STD:	/* FALL THROUGH */
+	case VIDIOC_S_STD:	/* FALL THROUGH */
+	case VIDIOC_QUERYSTD:
+		/* we don't have an analog video standard,
+		 * so we don't need to implement these ioctls.
+		 */
+		 return -EINVAL;
+
+	case VIDIOC_G_AUDIO:	/* FALL THROUGH */
+	case VIDIOC_S_AUDIO:	/* FALL THROUGH */
+	case VIDIOC_G_AUDOUT:	/* FALL THROUGH */
+	case VIDIOC_S_AUDOUT:
+		/* we don't have any audio inputs or outputs */
+		return -EINVAL;
+
+	case VIDIOC_G_JPEGCOMP:	/* FALL THROUGH */
+	case VIDIOC_S_JPEGCOMP:
+		/* JPEG compression is not supported */
+		return -EINVAL;
+
+	case VIDIOC_G_TUNER:		/* FALL THROUGH */
+	case VIDIOC_S_TUNER:		/* FALL THROUGH */
+	case VIDIOC_G_MODULATOR:	/* FALL THROUGH */
+	case VIDIOC_S_MODULATOR:	/* FALL THROUGH */
+	case VIDIOC_G_FREQUENCY:	/* FALL THROUGH */
+	case VIDIOC_S_FREQUENCY:
+		/* we don't have a tuner or modulator */
+		return -EINVAL;
+
+	case VIDIOC_ENUMOUTPUT:
+		/* not supported */
+		return -EINVAL;
+
+	default:
+		/* unrecognized ioctl */
+		return -ENOIOCTLCMD;
+	}
+	return 0;
+}
+
+
+/*****************************************************************************
+* MODULE   : mp200_v4l2_core_ioctl
+* FUNCTION : a stub function of ioctl
+* RETURN   :	   0: success
+*	   : -EINVAL: Argument error
+* NOTE	   :
+* CREATE   :
+* UPDATE   :
+******************************************************************************/
+static inline int mp200_v4l2_core_ioctl(struct inode *inode,
+ struct file *file, unsigned int cmd,  unsigned long arg)
+{
+	return video_usercopy(inode, file, cmd, arg, mp200_v4l2_core_do_ioctl);
+}
+
+
+/*****************************************************************************
+* MODULE   : mp200_v4l2_core_poll
+* FUNCTION : a system call function of poll & select
+* RETURN   :	   0: success
+*	   : -EINVAL: Argument error
+* NOTE	   :
+* CREATE   : 06/06/09 Y.Hara
+* UPDATE   : 06/06/13 M.Haguro
+******************************************************************************/
+static inline unsigned int mp200_v4l2_core_poll(struct file *file,
+ struct poll_table_struct *wait)
+{
+	struct mp200_v4l2_fh *fh = file->private_data;
+
+	return videobuf_poll_stream(file, &fh->vbq, wait);
+}
+
+
+/*****************************************************************************
+* MODULE   : mp200_v4l2_core_release
+* FUNCTION : v4l2 driver's close processing function.
+* RETURN   : 0: success
+* NOTE	   :
+* CREATE   :
+* UPDATE   : 06/06/14 M.Haguro
+******************************************************************************/
+static int mp200_v4l2_core_release(struct inode *inode, struct file *file)
+{
+	struct mp200_v4l2_fh	 *fh  = file->private_data;
+	struct mp200_v4l2_device *dev = fh->dev;
+	unsigned long flags;
+	unsigned int  lcdout = V4L2_OUTPUT_LCD;
+	int err;
+
+	mp200_v4l2_ioc_streamoff(fh, dev);
+
+	spin_lock_irqsave(&dev->vbq_lock, flags);
+
+	if (fh->vbq.read_buf) {
+		mp200_v4l2_core_vbq_release(&fh->vbq, fh->vbq.read_buf);
+		kfree(fh->vbq.read_buf);
+	}
+
+	spin_unlock_irqrestore(&dev->vbq_lock, flags);
+	err = mp200_v4l2_ioc_s_output(fh, &lcdout);
+	spin_lock_irqsave(&dev->vbq_lock, flags);
+	if (err)
+		printk_err("NTS out disable failed.\n\n");
+
+	err = videobuf_mmap_free(&fh->vbq);
+	if (err)
+		printk_err("videobuf_free failed.\n\n");
+
+	file->private_data = NULL;
+	kfree(fh->vbq.int_ops);
+	kfree(fh);
+	spin_unlock_irqrestore(&dev->vbq_lock, flags);
+
+	/* workqueue uninitialize */
+	destroy_workqueue(dev->v4l2_workqueue);
+
+	dev->vb_old_refresh = NULL;
+	dev->vb_old = NULL;
+	memset(&dev->pix,     0, sizeof(dev->pix));
+	memset(&dev->efct,    0, sizeof(dev->efct));
+	memset(&dev->workbuf, 0, sizeof(dev->workbuf));
+
+	/* v4l2 unactive */
+	dev->active = 0;
+	return 0;
+}
+
+
+/*****************************************************************************
+* MODULE   : mp200_v4l2_core_open
+* FUNCTION : v4l2 driver's open processing function.
+* RETURN   :	   0: success
+*	   : -ENODEV: corresponding device doesn't exist.
+*	   : -ENOMEM: memory that can be used for the kernel is insufficient.
+*	   : -EPERM : no privilege in the call origin.
+* NOTE	   :
+* CREATE   :
+* UPDATE   : 06/06/14 M.Haguro
+******************************************************************************/
+static int mp200_v4l2_core_open(struct inode *inode, struct file *file)
+{
+	int minor = iminor(inode);
+	struct mp200_v4l2_device *dev = mp200_dev;
+	struct mp200_v4l2_fh	 *fh;
+	struct videobuf_qtype_ops  *int_ops;
+	unsigned long flags;
+
+	if (!dev || !dev->vfd || (dev->vfd->minor != minor))
+		return -ENODEV;
+
+	/* allocate per-filehandle data */
+	fh = kmalloc(sizeof(*fh), GFP_KERNEL);
+	if (NULL == fh)
+		return -ENOMEM;
+
+	int_ops = kmalloc(sizeof(*int_ops), GFP_KERNEL);
+	if (NULL == int_ops) {
+		kfree(fh);
+		return -ENOMEM;
+	}
+
+	file->private_data = fh;
+	fh->dev = dev;
+	fh->type = V4L2_BUF_TYPE_VIDEO_OUTPUT;
+	int_ops->magic = MAGIC_QTYPE_OPS;
+	fh->vbq.int_ops = int_ops;
+
+	spin_lock_irqsave(&dev->vbq_lock, flags);
+	if (dev->active == 1) {
+		printk_err("v4l2 device Active\n");
+		spin_unlock_irqrestore(&dev->vbq_lock, flags);
+		kfree(fh);
+		kfree(int_ops);
+		return -EPERM;
+	}
+	dev->active = 1;
+	spin_unlock_irqrestore(&dev->vbq_lock, flags);
+
+	videobuf_queue_core_init(&fh->vbq, &dev->vbq_ops, NULL, &dev->vbq_lock,
+	 fh->type, V4L2_FIELD_NONE, sizeof(struct videobuf_buffer), fh->dev,
+	 fh->vbq.int_ops);
+
+	/* workqueue initialize */
+	dev->v4l2_workqueue = create_singlethread_workqueue("v4l2");
+	INIT_WORK(&dev->wk_lcd_stop, mp200_v4l2_lcd_stop_do);
+#if ENABLE_DELAY
+	INIT_WORK(&dev->wk_tmr_callback_bottom,
+	 mp200_v4l2_tmr_callback_bottom_do);
+#endif
+
+	/* video-buffer-queue index & sequence number initialize */
+	fh->vbq.index_max = 0;
+	fh->vbq.sequence  = 0;
+
+	return 0;
+}
+
+#if defined(CONFIG_PM) || defined(CONFIG_DPM)
+/*****************************************************************************
+* MODULE   : mp200_v4l2_core_suspend
+* FUNCTION : callback function when to suspend.
+* RETURN   :
+* NOTE	   : unsupport
+* CREATE   :
+* UPDATE   :
+******************************************************************************/
+static int  mp200_v4l2_core_suspend(struct platform_device *pdev,
+ pm_message_t state)
+{
+	int ret;
+	struct mp200_v4l2_device *dev = dev_get_drvdata(&pdev->dev);
+
+	if (state.event == DEV_SUSPEND_IDLE_1) {
+		ret = 0;
+	} else { /* state.event == PM_EVENT_SUSPEND */
+		if (!mp200_sleep_while_idle) {
+			if (dev->streaming) {
+				del_timer_sync(&dev->timer.wait_timer);
+
+				if (down_trylock(&dev->sem_lcdout))
+					;
+				up(&dev->sem_lcdout); /* release semafore */
+			}
+			dev->suspend = 1;
+		}
+		ret = 0;
+	}
+	return ret;
+}
+
+
+/*****************************************************************************
+* MODULE   : mp200_v4l2_core_resume
+* FUNCTION : callback function when to resume.
+* RETURN   :
+* NOTE	   : unsupport
+* CREATE   :
+* UPDATE   :
+******************************************************************************/
+static int  mp200_v4l2_core_resume(struct platform_device *pdev)
+{
+	struct mp200_v4l2_device *dev = dev_get_drvdata(&pdev->dev);
+	struct videobuf_queue	 *q   = &dev->streaming->vbq;
+	struct videobuf_buffer	 *vb;
+	struct list_head	 *list;
+
+	if (dev->suspend) {
+		if (dev->streaming) {
+			list_for_each(list, &q->stream) {
+				vb = list_entry(list, struct videobuf_buffer,
+					stream);
+				if ((vb->state == VIDEOBUF_QUEUED) &&
+					(vb->state_queued ==
+					STATE_QUEUED_TMR_QUEUED))
+					vb->state_queued =
+						STATE_QUEUED_TMR_PREPARED;
+			}
+		}
+		dev->suspend = 0;
+	}
+	return 0;
+}
+#endif /* CONFIG_PM || CONFIG_DPM */
+
+
+/*****************************************************************************
+* MODULE   : mp200_v4l2_core_cleanup
+* FUNCTION : cleanup module
+* RETURN   :	   0: success
+*	   : -ENODEV: corresponding device doesn't exist.
+* NOTE	   : v4l2 driver cleanup function, when to driver ends.
+* CREATE   :
+* UPDATE   :
+******************************************************************************/
+void mp200_v4l2_core_cleanup(void)
+{
+	struct mp200_v4l2_device *dev = mp200_dev;
+	struct video_device	 *vfd;
+
+	if (!dev)
+		return;
+
+	vfd = dev->vfd;
+	if (vfd) {
+		if (vfd->minor == -1) {
+			/* The device never got registered, so release the
+			** video_device struct directly
+			*/
+			video_device_release(vfd);
+		} else {
+			/* The unregister function will release the video_device
+			** struct as well as unregistering it.
+			*/
+			video_unregister_device(vfd);
+			platform_driver_unregister(&mp200_v4l2_core_driver);
+			platform_device_unregister(&mp200_v4l2_core_device);
+		}
+		dev->vfd = NULL;
+	}
+
+	/* uninitialize kernel thread */
+	mp200_v4l2_thread_cleanup(dev);
+
+	kfree(dev);
+	mp200_dev = NULL;
+
+	return;
+}
+
+
+/*****************************************************************************
+* MODULE   : mp200_v4l2_core_init
+* FUNCTION : initialize module
+* RETURN   :	   0: success
+*	   : -ENODEV: corresponding device doesn't exist.
+* NOTE	   : v4l2 driver initialize function, when to driver starts.
+* CREATE   :
+* UPDATE   :
+******************************************************************************/
+int __init mp200_v4l2_core_init(void)
+{
+	struct mp200_v4l2_device *dev;
+	struct video_device	 *vfd;
+
+	dev = kmalloc(sizeof(struct mp200_v4l2_device), GFP_KERNEL);
+	if (!dev) {
+		printk_err("could not allocate memory\n");
+		goto init_error;
+	}
+	memset(dev, 0, sizeof(struct mp200_v4l2_device));
+
+	/* Save the pointer to device in a global variable */
+	mp200_dev = dev;
+
+	/* initialize the video_device struct */
+	vfd = dev->vfd = video_device_alloc();
+	if (!vfd) {
+		printk_err("could not allocate video device struct\n");
+		goto init_error;
+	}
+
+	vfd->release = video_device_release;
+
+	strlcpy(vfd->name, DEV_NAME, sizeof(vfd->name));
+
+	vfd->fops     = &mp200_v4l2_core_fops;
+	video_set_drvdata(vfd, dev);
+	vfd->minor    = -1;
+
+	/* initialize the semafore */
+	sema_init(&dev->sem_lcdout, 1);
+
+	/* initialize the spinlock used to image parameters */
+	spin_lock_init(&dev->vbq_lock);
+
+	mp200_v4l2_core_wkb_init(dev);
+
+	/* initialize the kernel thread */
+	if (mp200_v4l2_thread_startup(dev)) {
+		printk_err("failed create thread\n");
+		goto init_error;
+	}
+
+	/* initialize the kernel timer */
+	mp200_v4l2_tmr_init(dev);
+
+	/* initialize the videobuf queue ops */
+	dev->vbq_ops.buf_setup	 = mp200_v4l2_core_vbq_setup;
+	dev->vbq_ops.buf_prepare = mp200_v4l2_core_vbq_prepare;
+	dev->vbq_ops.buf_queue	 = mp200_v4l2_core_vbq_queue;
+	dev->vbq_ops.buf_release = mp200_v4l2_core_vbq_release;
+	dev->vbq_ops.buf_cancel	 = mp200_v4l2_core_vbq_cancel;
+	dev->vbq_ops.buf_dqueue	 = mp200_v4l2_core_vbq_dqueue;
+
+	dev_set_drvdata(&mp200_v4l2_core_device.dev, (void *)dev);
+	if (platform_device_register(&mp200_v4l2_core_device) < 0) {
+		printk_err("could not register platform_device\n");
+		goto init_error;
+	}
+
+	if (platform_driver_register(&mp200_v4l2_core_driver) < 0) {
+		printk_err("could not register driver\n");
+		platform_device_unregister(&mp200_v4l2_core_device);
+		goto init_error;
+	}
+	if (video_register_device(vfd, VFL_TYPE_GRABBER, video_nr) < 0) {
+		printk_err("could not register Video for Linux device\n");
+		platform_device_unregister(&mp200_v4l2_core_device);
+		platform_driver_unregister(&mp200_v4l2_core_driver);
+		goto init_error;
+	}
+
+	printk(KERN_INFO DEV_NAME ": registered device video%d [v4l2]\n",
+	 vfd->minor);
+	return 0;
+
+init_error:
+	mp200_v4l2_core_cleanup();
+	return -ENODEV;
+}
+
+
+MODULE_AUTHOR("NEC Electronics Corporation.");
+MODULE_DESCRIPTION("EM1 Video for Linux2 driver");
+MODULE_LICENSE("GPL");
+module_param(video_nr, int, 0);
+MODULE_PARM_DESC(video_nr,
+ "Minor number for video device (-1 ==> auto assign)");
+
+module_init(mp200_v4l2_core_init);
+module_exit(mp200_v4l2_core_cleanup);
+
+
diff --git a/drivers/media/video/mp200/mp200_v4l2_core.h b/drivers/media/video/mp200/mp200_v4l2_core.h
new file mode 100644
index 0000000..65d4a55
--- /dev/null
+++ b/drivers/media/video/mp200/mp200_v4l2_core.h
@@ -0,0 +1,322 @@
+/*
+ * File Name       : drivers/media/video/mp200/mp200_v4l2_core.h
+ * Function        : Video for Linux driver for EM1 driver core
+ * Release Version :
+ * Release Date    : 2009.10.21
+ *
+ * Copyright (C) NEC Electronics Corporation 2009
+ *
+ *
+ * This program is free software;you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by Free Softwere
+ * Foundation; either version 2 of License, or (at your option) any later
+ * version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warrnty of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
+ * details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; If not, write to the Free Software Foundation, Inc., 59 Temple
+ * Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#ifndef MP200_V4L2_CORE__H
+#define MP200_V4L2_CORE__H
+
+
+#include <media/videobuf-dma-sg.h>
+#include <linux/scatterlist.h>
+
+#include "mp200_v4l2_ipu.h"
+#include "mp200_v4l2_time.h"
+
+
+struct mp200_v4l2_fh;
+struct mp200_v4l2_device;
+
+
+/*===============================================================*/
+/* next_step_do() call function                                  */
+/*===============================================================*/
+enum call_func_num {
+	VBQ_QUEUE,
+	RESCHEDULE,
+	ROT_REQUEST,
+	ROT_CALLBACK,
+	IMG_REQUEST,
+	IMG_CALLBACK,
+	TMR_REQUEST,
+	TMR_CALLBACK,
+	LCD_REQUEST,
+	LCD_CALLBACK,
+	VBQ_COMPLETE,
+	VBQ_DQUEUE,
+};
+
+
+/*===============================================================*/
+/* main thread definition structure                              */
+/*===============================================================*/
+enum thread_control {
+	TH_IDLE,
+	TH_RUNNING,
+};
+
+/* ROT|IMG temporary buffer */
+enum buffer_select {
+	BUF_A,
+	BUF_B,
+#if (NUM_BUF_V4L2 == 3)
+	BUF_C,
+#endif
+};
+
+enum buffer_state {
+	TMPBUF_IDLE,
+	TMPBUF_ROT_WRITE,
+	TMPBUF_IMG_READ,
+	TMPBUF_IMG_WRITE,
+	TMPBUF_LCD_READ,
+	TMPBUF_LCD_WRITE,
+};
+
+/* temporary buffer infomation structure ------------------------*/
+struct temp_buffer {
+	enum buffer_state  state;
+	unsigned long      paddr;
+
+	/* temporary image data (from mp200_common.h) */
+	unsigned long      pixelformat;
+	struct _IMAGE_DATA dst_data;
+};
+
+/* temporary buffer control structure ---------------------------*/
+struct buf_object {
+	/** temporary buffer data **/
+	/* temporary buffer infomation structure */
+	struct temp_buffer          buf[NUM_BUF_V4L2];
+	wait_queue_head_t           buf_busy;
+
+	/** use mp200_v4l2_ipu_callback_main() **/
+	/* callback function (from IPU driver) */
+	ipu_callback_func           callback;
+	/* H/W Function (use IPU processing) */
+	int                         ipu_hw_func;
+	int (*make_request)(struct mp200_v4l2_device *,
+	 struct videobuf_buffer *, int, enum buffer_select);
+
+	struct videobuf_buffer     *vb;
+	/* request structure (to IPU driver) */
+	struct mp200_ipu_req_v4l2   ipu_request;
+};
+
+
+/* main structure -----------------------------------------------*/
+struct th_object {
+	struct task_struct         *th;
+	char                       *th_name;       /* thread name */
+	int (*call_request)(struct mp200_v4l2_device *,
+	 struct videobuf_buffer *, int); /* main function to thread*/
+
+	wait_queue_head_t           th_idle;
+	/* peculiar idle state flag to thread */
+	enum videobuf_state_queued  th_idle_fixed;
+	enum videobuf_state_queued  th_idle_flag;
+	wait_queue_head_t           th_busy;
+	/* peculiar busy state flag to thread */
+	enum videobuf_state_queued  th_busy_fixed;
+
+	/* temporary buffer control structure */
+	struct buf_object          *th_buf;
+};
+
+
+#if _V4L2_RT_THREAD /* RT thread */
+#define V4L2_THREAD_PRIORITY  1 /* thread priority */
+#else /* Normal thread */
+#define V4L2_THREAD_NICE    -20 /* thread priority */
+#endif
+
+
+/*===============================================================*/
+/* mixing flag (member of mp200_v4l2_device)                     */
+/*===============================================================*/
+#define ROT_MIXING	0x000F
+#define IMG_MIXING	0x00F0
+#define TMR_MIXING	0x0F00
+#define LCD_MIXING	0xF000
+#define ROT_MIXING_SFT	0x00
+#define IMG_MIXING_SFT	0x04
+#define TMR_MIXING_SFT	0x08
+#define LCD_MIXING_SFT	0x0C
+
+#define ADD_MIXING(BIT, SFT) \
+	do { \
+		dev->mixing = (dev->mixing & ~BIT) | ((1 << SFT) & BIT); \
+	} while (0)
+
+#define DEL_MIXING(BIT, SFT) \
+	do { \
+		dev->mixing = (dev->mixing & ~BIT) | ((0 << SFT) & BIT); \
+	} while (0)
+
+
+/*===============================================================*/
+/* per-device data structure                                     */
+/*===============================================================*/
+struct mp200_v4l2_device {
+	struct device             dev;
+	struct video_device      *vfd;
+
+	struct semaphore          sem_lcdout;   /* semafore for lcdout */
+
+	/* spinlock for videobuf queues */
+	spinlock_t                vbq_lock;
+	/* videobuf queue operations    */
+	struct videobuf_queue_ops vbq_ops;
+	/* field counter for videobuf_buffer */
+	unsigned long             field_count;
+	struct videobuf_buffer   *vb_old_refresh;
+	struct videobuf_buffer   *vb_old;
+
+	/* v4l2_workqueue defines the v4l2 driver to LCD driver or ROT driver
+	 * working task.
+	 */
+	struct workqueue_struct  *v4l2_workqueue;
+	struct work_struct        wk_lcd_stop;
+	struct work_struct        wk_tmr_callback_bottom;
+
+	/* The img_lock is used to serialize access to the image parameters for
+	 * overlay and capture.  Need to use spin_lock_irq when writing to the
+	 * reading, streaming, and previewing parameters.  A regular spin_lock
+	 * will suffice for all other cases.
+	 */
+
+	/* We allow streaming from at most one filehandle at a time.
+	 * non-NULL means streaming is in progress.
+	*/
+	struct mp200_v4l2_fh     *streaming;
+	struct mp200_v4l2_fh     *streamoff;
+	unsigned long             mixing;
+
+	/* revise time data */
+	struct mp200_v4l2_time    timer;
+
+	/* kernel thread data */
+	struct th_object          th_rot;
+	struct th_object          th_img;
+	struct th_object          th_tmr;
+	struct th_object          th_lcd;
+
+
+	/* pix defines the size and pixel format of the image captured by the
+	 * sensor.  This also defines the size of the framebuffers.  The
+	 * same pool of framebuffers is used for video capture and video
+	 * overlay.  These parameters are set/queried by the
+	 * VIDIOC_S_FMT/VIDIOC_G_FMT ioctls with a CAPTURE buffer type.
+	 */
+	struct v4l2_pix_format    pix;
+
+	/* saving effet data */
+	struct v4l2_effect        efct;
+
+	/* saving waork buffer data */
+	struct v4l2_workbuffer    workbuf;
+
+	/* saving output device data */
+	unsigned int              output;
+
+	char                      suspend;
+	char                      active;
+};
+
+
+/*===============================================================*/
+/* per-filehandle data structure                                 */
+/*===============================================================*/
+struct mp200_v4l2_fh {
+	struct mp200_v4l2_device *dev;
+	enum   v4l2_buf_type      type;
+	struct videobuf_queue     vbq;
+};
+
+
+/*===============================================================*/
+/* V4L2 streaming state flag. (need to LCD request)              */
+/*===============================================================*/
+#define STREAM_STOP         0
+#define STREAM_PLAYBACK     1
+#define STREAM_PLAYBACK_ROT 2
+
+
+/*===============================================================*/
+/* use image sizes check.                                        */
+/*===============================================================*/
+#ifdef	CONFIG_MP200_EM1_DKIT
+#define INPUT_WIDTH         2048
+#define INPUT_HEIGHT        1536
+#else
+#define D1_WIDTH            720
+#define D1_HEIGHT           480
+#define INPUT_WIDTH         D1_WIDTH
+#define INPUT_HEIGHT        D1_HEIGHT
+#endif
+#define INPUT_MAX  (INPUT_WIDTH > INPUT_HEIGHT ? INPUT_WIDTH : INPUT_HEIGHT)
+#define LCD_MAX    (FRONT_WIDTH > FRONT_HEIGHT ? FRONT_WIDTH : FRONT_HEIGHT)
+
+
+#define IMAGE_WIDTH_MIN      8
+#define IMAGE_WIDTH_MAX      (LCD_MAX > INPUT_MAX ? LCD_MAX : INPUT_MAX)
+#define IMAGE_WIDTH_ALINE_IL 0x1
+#define IMAGE_WIDTH_ALINE_SP 0x3
+#define IMAGE_WIDTH_ALINE_PL 0x7
+
+#define IMAGE_HEIGHT_MIN      8
+#define IMAGE_HEIGHT_MAX      (LCD_MAX > INPUT_MAX ? LCD_MAX : INPUT_MAX)
+#define IMAGE_HEIGHT_ALINE_IL 0x1
+#define IMAGE_HEIGHT_ALINE_SP 0x3
+#define IMAGE_HEIGHT_ALINE_PL 0x7
+
+#define IMAGE_AREA_MAX \
+     ((FRONT_WIDTH  > INPUT_WIDTH  ? FRONT_WIDTH  : INPUT_WIDTH) *  \
+      (FRONT_HEIGHT > INPUT_HEIGHT ? FRONT_HEIGHT : INPUT_HEIGHT))
+
+#define IMAGE_LEFT_MIN      0
+#define IMAGE_LEFT_MAX      IMAGE_WIDTH_MAX
+#define IMAGE_LEFT_ALINE    0x1
+#define IMAGE_TOP_MIN       0
+#define IMAGE_TOP_MAX       IMAGE_HEIGHT_MAX
+#define IMAGE_TOP_ALINE     0x1
+
+#define IMAGE_PADDR_NULL    0
+#define IMAGE_PADDR_ALINE   0x3
+
+#define DEST_WIDTH_MIN      16
+#define DEST_HEIGHT_MIN     16
+
+#define RESIZE_WIDTH_MIN    40 /* *(1/40) */
+#define RESIZE_WIDTH_MAX    4  /* *4      */
+#define RESIZE_HEIGHT_MIN   40 /* *(1/40) */
+#define RESIZE_HEIGHT_MAX   4  /* *4      */
+
+
+/*===============================================================*/
+/* device name definetion                                        */
+/*===============================================================*/
+#define DEV_NAME "mp200_v4l2"
+
+/*===============================================================*/
+/* functions                                                     */
+/*===============================================================*/
+
+void mp200_v4l2_core_cleanup(void);
+int __init  mp200_v4l2_core_init(void);
+void mp200_v4l2_ntsc_ready_callback(FRAME_DATA frame_data);
+void mp200_v4l2_lcd_refresh_callback(FRAME_DATA frame_data);
+void mp200_v4l2_lcd_callback(FRAME_DATA frame_data);
+
+
+#endif /* MP200_V4L2_CORE__H */
diff --git a/drivers/media/video/mp200/mp200_v4l2_debug.h b/drivers/media/video/mp200/mp200_v4l2_debug.h
new file mode 100644
index 0000000..e69de29
diff --git a/drivers/media/video/mp200/mp200_v4l2_ipu.h b/drivers/media/video/mp200/mp200_v4l2_ipu.h
new file mode 100644
index 0000000..1528aaf
--- /dev/null
+++ b/drivers/media/video/mp200/mp200_v4l2_ipu.h
@@ -0,0 +1,100 @@
+/*
+ * File Name       : drivers/media/video/mp200/mp200_v4l2_rot.h
+ * Function        : Video for Linux driver for EM1 driver core
+ * Release Version :
+ * Release Date    : 2009.10.21
+ *
+ * Copyright (C) NEC Electronics Corporation 2009
+ *
+ *
+ * This program is free software;you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by Free Softwere
+ * Foundation; either version 2 of License, or (at your option) any later
+ * version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warrnty of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
+ * details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; If not, write to the Free Software Foundation, Inc., 59 Temple
+ * Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#ifndef MP200_V4L2_IPU__H
+#define MP200_V4L2_IPU__H
+
+
+struct mp200_ipu_req_v4l2;
+
+
+/*===============================================================*/
+/* IPU driver request information structure                      */
+/*===============================================================*/
+struct mp200_ipu_req_v4l2 {
+	/* sequence No */
+	unsigned long sequence;
+	/* Status of IPU request (used by IPU driver) */
+	int status;
+	/* callback function */
+	ipu_callback_func callback;
+	/* optional data (used by caller) */
+	unsigned long data;
+	int ipu_hw_func;	/* H/W Function (processing demand) */
+				/*     IMG Function   : IPU_HW_FUNC_IMG */
+				/*     ROT Function   : IPU_HW_FUNC_ROT */
+				/*     GDMA Function  : IPU_HW_FUNC_GDMA */
+				/*     1PASS Function : IPU_HW_FUNC_1PASS */
+				/*     2PASS Function : IPU_HW_FUNC_2PASS */
+
+	/* IPU register setting informations */
+	struct mp200_ipu_reg_info ipu_reg_info[MAX_SIZE_MP200_IPU_REQ];
+		/* repeat until end condition (max 230 pairs)        */
+		/*  end condition :                                  */
+		/*     set 0x00000001 to IMG_REQ/ROT_REQ/GDMA_REQ    */
+		/*                    (request to start IPU process) */
+		/*     reg=IMG_REQ/ROT_REQ/GDMA_REQ data=0x00000001, */
+		/*                             or reg=-1(0xFFFFFFFF) */
+};
+
+
+/*******************************************************/
+/* request data structure defintion. to IPU-ROT driver */
+#define RotRequest(DATA, REG) \
+	do { \
+		rot_buf->ipu_request.ipu_reg_info[index_req].reg  = REG;  \
+		rot_buf->ipu_request.ipu_reg_info[index_req].data = DATA; \
+		index_req++; \
+	} while (0)
+
+
+/*******************************************************/
+/* request data structure defintion. to IPU-IMG driver */
+#define ImgRequest(DATA, REG) \
+	do { \
+		img_buf->ipu_request.ipu_reg_info[index_req].reg  = REG;  \
+		img_buf->ipu_request.ipu_reg_info[index_req].data = DATA; \
+		index_req++; \
+	} while (0)
+
+
+/*********************************/
+/* ROT register data  <ROT_MODE> */
+#define ROT_MODE_SRCENDIAN_BIG    0x00000000
+#define ROT_MODE_SRCENDIAN_LITTLE 0x00000010
+
+#define ROT_MODE_DSTENDIAN_BIG    0x00000000
+#define ROT_MODE_DSTENDIAN_LITTLE 0x00000008
+
+#define ROT_MODE_SRCYUV_422       0x00000000
+#define ROT_MODE_SRCYUV_420       0x00000004
+
+#define ROT_MODE_ROT_MOD_0        0x00000000
+#define ROT_MODE_ROT_MOD_90       0x00000001
+#define ROT_MODE_ROT_MOD_180      0x00000002
+#define ROT_MODE_ROT_MOD_270      0x00000003
+
+
+#endif /* MP200_V4L2_IPU__H */
diff --git a/drivers/media/video/mp200/mp200_v4l2_perf.h b/drivers/media/video/mp200/mp200_v4l2_perf.h
new file mode 100644
index 0000000..e69de29
diff --git a/drivers/media/video/mp200/mp200_v4l2_time.h b/drivers/media/video/mp200/mp200_v4l2_time.h
new file mode 100644
index 0000000..c5b314a
--- /dev/null
+++ b/drivers/media/video/mp200/mp200_v4l2_time.h
@@ -0,0 +1,63 @@
+/*
+ * File Name       : drivers/media/video/mp200/mp200_v4l2_time.h
+ * Function        : Video for Linux driver for EM1 driver core
+ * Release Version :
+ * Release Date    : 2009.10.21
+ *
+ * Copyright (C) NEC Electronics Corporation 2009
+ *
+ *
+ * This program is free software;you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by Free Softwere
+ * Foundation; either version 2 of License, or (at your option) any later
+ * version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warrnty of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
+ * details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; If not, write to the Free Software Foundation, Inc., 59 Temple
+ * Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#ifndef MP200_V4L2_TIME__H
+#define MP200_V4L2_TIME__H
+
+
+struct mp200_v4l2_time;
+
+
+/*===============================================================*/
+/* make option definetion					 */
+/*===============================================================*/
+#define CALC_ADJUST	     0	/* 1: adjust(LCD-IMC process) enable
+				   0: adjust(LCD-IMC process) disable */
+#define ENABLE_DELAY	     0	/* 1: delay enable
+				 * 0: delay disable */
+
+#define ROUNDUP_ADJUST_LCD  16
+#define ROUNDUP_ADJUST_NTSC 32
+#define ROUNDUP_ADJUST_PAL  39
+#define DEFAULT_ADJUST_LCD   0 /* adjust(LCD-IMC process)  time [msec] */
+#define DEFAULT_ADJUST_NTSC 17 /* adjust(NTSC-IMG process) time [msec] */
+
+
+/*===============================================================*/
+/* rotate data structure                                         */
+/*===============================================================*/
+struct mp200_v4l2_time {
+	struct timer_list       wait_timer;
+	struct timeval		now_time;
+	struct timeval		do_time;
+	struct timeval		comp_time;
+	long			wait_time;
+	long			adjust_time_lcd;
+	long			adjust_time_ntsc;
+	void			*vb;
+};
+
+
+#endif /* MP200_V4L2_TIME__H */
diff --git a/drivers/media/video/videobuf-core.c b/drivers/media/video/videobuf-core.c
index b7b0584..c2ab6a0 100644
--- a/drivers/media/video/videobuf-core.c
+++ b/drivers/media/video/videobuf-core.c
@@ -23,10 +23,14 @@
 #include <media/videobuf-core.h>
 
 #define MAGIC_BUFFER 0x20070728
-#define MAGIC_CHECK(is, should) do {					   \
-	if (unlikely((is) != (should))) {				   \
-	printk(KERN_ERR "magic mismatch: %x (expected %x)\n", is, should); \
-	BUG(); } } while (0)
+#define MAGIC_CHECK(is, should) \
+	do {					   \
+		if (unlikely((is) != (should))) {		\
+			printk(KERN_ERR "magic mismatch: %x (expected %x)\n", \
+				is, should); \
+			BUG(); \
+		} \
+	} while (0)
 
 static int debug;
 module_param(debug, int, 0644);
@@ -35,9 +39,20 @@ MODULE_DESCRIPTION("helper module to manage video4linux buffers");
 MODULE_AUTHOR("Mauro Carvalho Chehab <mchehab@infradead.org>");
 MODULE_LICENSE("GPL");
 
-#define dprintk(level, fmt, arg...) do {			\
-	if (debug >= level) 					\
-	printk(KERN_DEBUG "vbuf: " fmt , ## arg); } while (0)
+#define dprintk(level, fmt, arg...) \
+	do {			\
+		if (debug >= level) 					\
+			printk(KERN_DEBUG "vbuf: " fmt , ## arg); \
+	} while (0)
+
+#ifdef CONFIG_VIDEO_MP200
+#define _POLL_DBG 0
+#define _QBUF_DBG 0
+
+#define dbg_printk(level, fmt, arg...) \
+	if (level > 0) \
+		printk(KERN_DEBUG " @vbq: " fmt, ## arg)
+#endif
 
 /* --------------------------------------------------------------------- */
 
@@ -49,24 +64,56 @@ void *videobuf_alloc(struct videobuf_queue *q)
 	struct videobuf_buffer *vb;
 
 	BUG_ON(q->msize < sizeof(*vb));
-
+#ifndef CONFIG_VIDEO_MP200
 	if (!q->int_ops || !q->int_ops->alloc) {
-		printk(KERN_ERR "No specific ops defined!\n");
 		BUG();
 	}
 
 	vb = q->int_ops->alloc(q->msize);
+#else
+	vb = kzalloc(q->msize, GFP_KERNEL);
+#endif
 
 	if (NULL != vb) {
+#ifdef CONFIG_VIDEO_MP200
+		init_waitqueue_head(&vb->clear_done);
+#endif /* CONFIG_VIDEO_MP200 */
 		init_waitqueue_head(&vb->done);
 		vb->magic     = MAGIC_BUFFER;
 	}
 
 	return vb;
 }
-
-#define WAITON_CONDITION (vb->state != VIDEOBUF_ACTIVE &&\
+#if CONFIG_VIDEO_MP200
+#define WAITON_CONDITION ((vb->state != VIDEOBUF_ACTIVE          &&\
+				vb->state != VIDEOBUF_QUEUED)           &&\
+				(vb->state_queued == STATE_QUEUED_IDLE  ||\
+				vb->state_queued == STATE_QUEUED_DONE))
+
+#define __mp200_wait_event_timeout(wq, condition, ret)                \
+do {                                                                  \
+	DEFINE_WAIT(__wait);                                          \
+	for (;;) {                                                    \
+		prepare_to_wait(&wq, &__wait, TASK_UNINTERRUPTIBLE);  \
+		if (condition)                                        \
+			break;                                        \
+		schedule_timeout(ret);                                \
+	}                                                             \
+	finish_wait(&wq, &__wait);                                    \
+} while (0)
+
+#define mp200_wait_event_timeout(wq, condition, timeout)              \
+({                                                                    \
+	long __ret = timeout;                                         \
+	if (!(condition))                                             \
+		__mp200_wait_event_timeout(wq, condition, __ret);      \
+	__ret;                                                        \
+})
+#else
+#define WAITON_CONDITION(vb->state != VIDEOBUF_ACTIVE &&\
 				vb->state != VIDEOBUF_QUEUED)
+#endif
+
 int videobuf_waiton(struct videobuf_buffer *vb, int non_blocking, int intr)
 {
 	MAGIC_CHECK(vb->magic, MAGIC_BUFFER);
@@ -79,13 +126,57 @@ int videobuf_waiton(struct videobuf_buffer *vb, int non_blocking, int intr)
 	}
 
 	if (intr)
+#if CONFIG_VIDEO_MP200
+		return wait_event_interruptible(vb->clear_done,
+			WAITON_CONDITION);
+#else
 		return wait_event_interruptible(vb->done, WAITON_CONDITION);
+#endif
 	else
+#if CONFIG_VIDEO_MP200
+		mp200_wait_event_timeout(vb->clear_done, WAITON_CONDITION,
+			msecs_to_jiffies(10));
+#else
 		wait_event(vb->done, WAITON_CONDITION);
+#endif
 
 	return 0;
 }
 
+
+#ifdef CONFIG_VIDEO_MP200
+int videobuf_waiton_dqbuf(struct videobuf_buffer *vb,
+	int non_blocking, int intr)
+{
+	int tout_ms = 10;
+	int tout_cnt = 0;
+	int retval = 0;
+	DECLARE_WAITQUEUE(wait, current);
+
+	MAGIC_CHECK(vb->magic, MAGIC_BUFFER);
+	add_wait_queue(&vb->done, &wait);
+	while (vb->state != VIDEOBUF_DQBUF_PERMIT) {
+		if (non_blocking || tout_cnt == 5) {
+			retval = -EAGAIN;
+			break;
+		}
+		set_current_state(intr  ? TASK_INTERRUPTIBLE
+					: TASK_UNINTERRUPTIBLE);
+		if (vb->state != VIDEOBUF_DQBUF_PERMIT)
+			schedule_timeout(msecs_to_jiffies(tout_ms));
+		set_current_state(TASK_RUNNING);
+		if (intr && signal_pending(current)) {
+			dprintk(1, "buffer waiton: -EINTR\n");
+			retval = -EINTR;
+			break;
+		}
+		tout_cnt++;
+	}
+	remove_wait_queue(&vb->done, &wait);
+	return retval;
+}
+#endif
+
 int videobuf_iolock(struct videobuf_queue *q, struct videobuf_buffer *vb,
 		    struct v4l2_framebuffer *fbuf)
 {
@@ -198,11 +289,21 @@ void videobuf_queue_cancel(struct videobuf_queue *q)
 	for (i = 0; i < VIDEO_MAX_FRAME; i++) {
 		if (NULL == q->bufs[i])
 			continue;
+#if CONFIG_VIDEO_MP200
+		if (q->bufs[i]->state == VIDEOBUF_PREPARED ||
+		   q->bufs[i]->state == VIDEOBUF_QUEUED) {
+			if (q->ops->buf_cancel(q, q->bufs[i]))
+				q->bufs[i]->state = VIDEOBUF_CANCELED;
+			else
+				q->bufs[i]->state = VIDEOBUF_DQBUF_PERMIT;
+		}
+#else	/* CONFIG_VIDEO_MP200 */
 		if (q->bufs[i]->state == VIDEOBUF_QUEUED) {
 			list_del(&q->bufs[i]->queue);
 			q->bufs[i]->state = VIDEOBUF_ERROR;
 			wake_up_all(&q->bufs[i]->done);
 		}
+#endif	/* CONFIG_VIDEO_MP200 */
 	}
 	spin_unlock_irqrestore(q->irqlock, flags);
 
@@ -215,6 +316,39 @@ void videobuf_queue_cancel(struct videobuf_queue *q)
 	INIT_LIST_HEAD(&q->stream);
 }
 
+#ifdef CONFIG_VIDEO_MP200
+void
+videobuf_queue_clear(struct videobuf_queue *q)
+{
+	unsigned long flags;
+	struct list_head *list;
+	struct videobuf_buffer *vb;
+
+	/* remove queued buffers from list */
+	spin_lock_irqsave(q->irqlock, flags);
+
+	list_for_each(list, &q->stream) {
+		vb = list_entry(list, struct videobuf_buffer, stream);
+		if (vb->state_frame != STATE_FRAME_IMMEDIATE) {
+			if (vb->state == VIDEOBUF_PREPARED ||
+				vb->state == VIDEOBUF_QUEUED) {
+				if (q->ops->buf_cancel(q, vb))
+					vb->state = VIDEOBUF_CANCELED;
+				else
+					vb->state = VIDEOBUF_DQBUF_PERMIT;
+			}
+		}
+		dbg_printk(_QBUF_DBG,
+			"clear: (%p) ->prev(%p) ->next(%p) "
+			"->state(%d) ->sequence(%d)\n",
+			&vb->stream, vb->stream.prev,
+			vb->stream.next, vb->state, vb->sequence);
+	}
+
+	spin_unlock_irqrestore(q->irqlock, flags);
+}
+#endif
+
 /* --------------------------------------------------------------------- */
 
 /* Locking: Caller holds q->vb_lock */
@@ -238,12 +372,14 @@ enum v4l2_field videobuf_next_field(struct videobuf_queue *q)
 
 /* Locking: Caller holds q->vb_lock */
 static void videobuf_status(struct videobuf_queue *q, struct v4l2_buffer *b,
-			    struct videobuf_buffer *vb, enum v4l2_buf_type type)
+			   struct videobuf_buffer *vb, enum v4l2_buf_type type)
 {
 	MAGIC_CHECK(vb->magic, MAGIC_BUFFER);
 	MAGIC_CHECK(q->int_ops->magic, MAGIC_QTYPE_OPS);
 
+#ifndef CONFIG_VIDEO_MP200
 	b->index    = vb->i;
+#endif
 	b->type     = type;
 
 	b->memory   = vb->memory;
@@ -259,9 +395,29 @@ static void videobuf_status(struct videobuf_queue *q, struct v4l2_buffer *b,
 	case V4L2_MEMORY_OVERLAY:
 		b->m.offset  = vb->boff;
 		break;
+#ifdef CONFIG_VIDEO_MP200
+	case V4L2_MEMORY_PHYSADDR:
+		break;
+#endif
 	}
 
 	b->flags    = 0;
+#ifdef CONFIG_VIDEO_MP200
+	switch (vb->state_frame) {
+	case STATE_FRAME_DONE:
+	case STATE_FRAME_IMMEDIATE:
+		b->flags |= V4L2_BUF_FLAG_DONE;
+		break;
+	case STATE_FRAME_CANCELED:
+		b->flags |= V4L2_BUF_FLAG_CANCELED;
+		break;
+	case STATE_FRAME_SKIPPED:
+		b->flags |= V4L2_BUF_FLAG_SKIPPED;
+		break;
+	default:
+		break;
+	}
+#else
 	if (vb->map)
 		b->flags |= V4L2_BUF_FLAG_MAPPED;
 
@@ -280,6 +436,7 @@ static void videobuf_status(struct videobuf_queue *q, struct v4l2_buffer *b,
 		/* nothing */
 		break;
 	}
+#endif /* CONFIG_VIDEO_MP200 */
 
 	if (vb->input != UNSET) {
 		b->flags |= V4L2_BUF_FLAG_INPUT;
@@ -289,28 +446,38 @@ static void videobuf_status(struct videobuf_queue *q, struct v4l2_buffer *b,
 	b->field     = vb->field;
 	b->timestamp = vb->ts;
 	b->bytesused = vb->size;
+#ifdef CONFIG_VIDEO_MP200
+	b->sequence  = vb->sequence;
+#else
 	b->sequence  = vb->field_count >> 1;
+#endif
 }
 
 /* Locking: Caller holds q->vb_lock */
 static int __videobuf_mmap_free(struct videobuf_queue *q)
 {
 	int i;
+#ifndef CONFIG_VIDEO_MP200
 	int rc;
-
+#else
+	int rc = 0;
+#endif
 	if (!q)
 		return 0;
 
 	MAGIC_CHECK(q->int_ops->magic, MAGIC_QTYPE_OPS);
-
-
+#ifndef CONFIG_VIDEO_MP200
 	rc  = CALL(q, mmap_free, q);
-
 	q->is_mmapped = 0;
 
 	if (rc < 0)
 		return rc;
-
+#else
+	for (i = 0; i < VIDEO_MAX_FRAME; i++)
+		if (q->bufs[i] && q->bufs[i]->map) {
+			return -EBUSY;
+		}
+#endif
 	for (i = 0; i < VIDEO_MAX_FRAME; i++) {
 		if (NULL == q->bufs[i])
 			continue;
@@ -364,6 +531,13 @@ int __videobuf_mmap_setup(struct videobuf_queue *q,
 		case V4L2_MEMORY_OVERLAY:
 			/* nothing */
 			break;
+#ifdef CONFIG_VIDEO_MP200
+		case V4L2_MEMORY_PHYSADDR:
+			if (q->bufs[i] == NULL)
+				return -EINVAL;
+
+			break;
+#endif
 		}
 	}
 
@@ -372,8 +546,11 @@ int __videobuf_mmap_setup(struct videobuf_queue *q,
 
 	dprintk(1, "mmap setup: %d buffers, %d bytes each\n",
 		i, bsize);
-
+#ifndef CONFIG_VIDEO_MP200
 	return i;
+#else	/* CONFIG_VIDEO_MP200 */
+	return 0;
+#endif	/* CONFIG_VIDEO_MP200 */
 }
 
 int videobuf_mmap_setup(struct videobuf_queue *q,
@@ -400,6 +577,9 @@ int videobuf_reqbufs(struct videobuf_queue *q,
 
 	if (req->memory != V4L2_MEMORY_MMAP     &&
 	    req->memory != V4L2_MEMORY_USERPTR  &&
+#ifdef CONFIG_VIDEO_MP200
+	    req->memory != V4L2_MEMORY_PHYSADDR &&
+#endif
 	    req->memory != V4L2_MEMORY_OVERLAY) {
 		dprintk(1, "reqbufs: memory type invalid\n");
 		return -EINVAL;
@@ -427,7 +607,13 @@ int videobuf_reqbufs(struct videobuf_queue *q,
 	if (count > VIDEO_MAX_FRAME)
 		count = VIDEO_MAX_FRAME;
 	size = 0;
+#ifdef CONFIG_VIDEO_MP200
+	retval = q->ops->buf_setup(q, &count, &size);
+	if (retval < 0)
+		goto done;
+#else
 	q->ops->buf_setup(q, &count, &size);
+#endif
 	size = PAGE_ALIGN(size);
 	dprintk(1, "reqbufs: bufs=%d, size=0x%x [%d pages total]\n",
 		count, size, (count*size)>>PAGE_SHIFT);
@@ -439,6 +625,9 @@ int videobuf_reqbufs(struct videobuf_queue *q,
 	}
 
 	req->count = retval;
+#ifdef CONFIG_VIDEO_MP200
+	q->index_max = count;
+#endif
 
  done:
 	mutex_unlock(&q->vb_lock);
@@ -478,6 +667,9 @@ int videobuf_qbuf(struct videobuf_queue *q,
 	enum v4l2_field field;
 	unsigned long flags = 0;
 	int retval;
+#ifdef CONFIG_VIDEO_MP200
+	int index;
+#endif
 
 	MAGIC_CHECK(q->int_ops->magic, MAGIC_QTYPE_OPS);
 
@@ -486,6 +678,21 @@ int videobuf_qbuf(struct videobuf_queue *q,
 
 	mutex_lock(&q->vb_lock);
 	retval = -EBUSY;
+
+#ifdef CONFIG_VIDEO_MP200
+	for (index = 0; index < q->index_max; index++) {
+		buf = q->bufs[index];
+		if (NULL == buf)
+			continue;
+
+		if (buf->state == VIDEOBUF_NEEDS_INIT ||
+		    buf->state == VIDEOBUF_ERROR ||
+		    buf->state == VIDEOBUF_IDLE)
+			goto index_done;
+	}
+	goto done;
+ index_done:
+#endif
 	if (q->reading) {
 		dprintk(1, "qbuf: Reading running...\n");
 		goto done;
@@ -495,6 +702,8 @@ int videobuf_qbuf(struct videobuf_queue *q,
 		dprintk(1, "qbuf: Wrong type.\n");
 		goto done;
 	}
+
+#ifndef CONFIG_VIDEO_MP200
 	if (b->index < 0 || b->index >= VIDEO_MAX_FRAME) {
 		dprintk(1, "qbuf: index out of range.\n");
 		goto done;
@@ -504,16 +713,18 @@ int videobuf_qbuf(struct videobuf_queue *q,
 		dprintk(1, "qbuf: buffer is null.\n");
 		goto done;
 	}
+#endif
 	MAGIC_CHECK(buf->magic, MAGIC_BUFFER);
 	if (buf->memory != b->memory) {
 		dprintk(1, "qbuf: memory type is wrong.\n");
 		goto done;
 	}
+#ifndef CONFIG_VIDEO_MP200
 	if (buf->state != VIDEOBUF_NEEDS_INIT && buf->state != VIDEOBUF_IDLE) {
 		dprintk(1, "qbuf: buffer is already queued or active.\n");
 		goto done;
 	}
-
+#endif
 	if (b->flags & V4L2_BUF_FLAG_INPUT) {
 		if (b->input >= q->inputs) {
 			dprintk(1, "qbuf: wrong input.\n");
@@ -545,6 +756,10 @@ int videobuf_qbuf(struct videobuf_queue *q,
 	case V4L2_MEMORY_OVERLAY:
 		buf->boff = b->m.offset;
 		break;
+#ifdef CONFIG_VIDEO_MP200
+	case V4L2_MEMORY_PHYSADDR:
+		break;
+#endif
 	default:
 		dprintk(1, "qbuf: wrong memory type\n");
 		goto done;
@@ -552,13 +767,42 @@ int videobuf_qbuf(struct videobuf_queue *q,
 
 	dprintk(1, "qbuf: requesting next field\n");
 	field = videobuf_next_field(q);
+#ifdef CONFIG_VIDEO_MP200
+	memcpy(&buf->base_addr, &b->m.phys_add, sizeof(struct v4l2_phys_add));
+	buf->ts           = b->timestamp;
+	buf->width        = b->width;
+	buf->height       = b->height;
+	buf->bytesperline = b->d_width;
+
+	retval = q->ops->buf_prepare(q, buf, field);
+	if (0 > retval) {
+		dprintk(1, "qbuf: buffer_prepare returned %d\n", retval);
+		goto done;
+	}
+
+	b->sequence   = q->sequence;
+	b->index      = index;
+
+	if (buf->state_frame == STATE_FRAME_IMMEDIATE)
+		videobuf_queue_clear(q);
+#else
 	retval = q->ops->buf_prepare(q, buf, field);
 	if (0 != retval) {
 		dprintk(1, "qbuf: buffer_prepare returned %d\n", retval);
 		goto done;
 	}
+#endif
 
 	list_add_tail(&buf->stream, &q->stream);
+
+#ifdef CONFIG_VIDEO_MP200
+	dbg_printk(_QBUF_DBG,
+		"qbuf: (%p) ->prev(%p) ->next(%p) "
+		"->state(%d) ->sequence(%d)\n",
+		&buf->stream, buf->stream.prev, buf->stream.next,
+		buf->state, buf->sequence);
+#endif
+
 	if (q->streaming) {
 		spin_lock_irqsave(q->irqlock, flags);
 		q->ops->buf_queue(q, buf);
@@ -569,6 +813,25 @@ int videobuf_qbuf(struct videobuf_queue *q,
 	wake_up_interruptible_sync(&q->wait);
 
  done:
+
+#if _QBUF_DBG
+	if (retval) {
+		int i;
+		for (i = 0; i < VIDEO_MAX_FRAME; i++) {
+			if (q->bufs[i]->state != STATE_NEEDS_INIT &&
+				q->bufs[i]->state != STATE_IDLE) {
+				printk(KERN_INFO
+				" @vbq: qbuf: %2d(%p) ->prev(%p) "
+				"->next(%p) ->state(%d) ->sequence(%d)\n",
+				i, &q->bufs[i]->stream,
+				q->bufs[i]->stream.prev,
+				q->bufs[i]->stream.next,
+				q->bufs[i]->state, q->bufs[i]->sequence);
+			}
+		}
+		printk(KERN_INFO "\n");
+	}
+#endif
 	mutex_unlock(&q->vb_lock);
 
 	if (b->memory == V4L2_MEMORY_MMAP)
@@ -634,7 +897,11 @@ static int stream_next_buffer(struct videobuf_queue *q,
 		goto done;
 
 	buf = list_entry(q->stream.next, struct videobuf_buffer, stream);
+#ifdef CONFIG_VIDEO_MP200
+	retval = videobuf_waiton_dqbuf(buf, nonblocking, 1);
+#else
 	retval = videobuf_waiton(buf, nonblocking, 1);
+#endif
 	if (retval < 0)
 		goto done;
 
@@ -663,12 +930,21 @@ int videobuf_dqbuf(struct videobuf_queue *q,
 	case VIDEOBUF_ERROR:
 		dprintk(1, "dqbuf: state is error\n");
 		retval = -EIO;
+#ifdef CONFIG_VIDEO_MP200
+		q->ops->buf_dqueue(q, buf);
+		buf->state = VIDEOBUF_IDLE;
+		break;
+	case VIDEOBUF_DQBUF_PERMIT:
+		dprintk(1, "dqbuf: state is dqbuf permit\n");
+		q->ops->buf_dqueue(q, buf);
+#else
 		CALL(q, sync, q, buf);
 		buf->state = VIDEOBUF_IDLE;
 		break;
 	case VIDEOBUF_DONE:
 		dprintk(1, "dqbuf: state is done\n");
 		CALL(q, sync, q, buf);
+#endif
 		buf->state = VIDEOBUF_IDLE;
 		break;
 	default:
@@ -676,11 +952,37 @@ int videobuf_dqbuf(struct videobuf_queue *q,
 		retval = -EINVAL;
 		goto done;
 	}
+
+#ifdef CONFIG_VIDEO_MP200
+	dbg_printk(_QBUF_DBG,
+	"dqbuf: (%p) ->prev(%p) ->next(%p) ->state(%d) ->sequence(%d)\n",
+	&buf->stream, buf->stream.prev, buf->stream.next,
+	buf->state, buf->sequence);
+#endif
+
 	list_del(&buf->stream);
 	memset(b, 0, sizeof(*b));
 	videobuf_status(q, b, buf, q->type);
 
  done:
+#if _QBUF_DBG
+	if (retval) {
+		int i;
+		for (i = 0; i < VIDEO_MAX_FRAME; i++) {
+			if (q->bufs[i]->state != STATE_NEEDS_INIT &&
+				q->bufs[i]->state != STATE_IDLE) {
+				printk(KERN_INFO
+				" @vbq: dqbuf: %2d(%p) ->prev(%p) ->next(%p) "
+				"->state(%d) ->sequence(%d)\n",
+				i, &q->bufs[i]->stream,
+				q->bufs[i]->stream.prev,
+				q->bufs[i]->stream.next, q->bufs[i]->state,
+				q->bufs[i]->sequence);
+			}
+		}
+		printk("\n");
+	}
+#endif
 	mutex_unlock(&q->vb_lock);
 	return retval;
 }
@@ -702,7 +1004,14 @@ int videobuf_streamon(struct videobuf_queue *q)
 	spin_lock_irqsave(q->irqlock, flags);
 	list_for_each_entry(buf, &q->stream, stream)
 		if (buf->state == VIDEOBUF_PREPARED)
+#ifdef CONFIG_VIDEO_MP200
+		{
+			q->ops->buf_queue(q, buf);
+			break;
+		}
+#else
 			q->ops->buf_queue(q, buf);
+#endif
 	spin_unlock_irqrestore(q->irqlock, flags);
 
 	wake_up_interruptible_sync(&q->wait);
@@ -1034,6 +1343,7 @@ unsigned int videobuf_poll_stream(struct file *file,
 			buf = list_entry(q->stream.next,
 					 struct videobuf_buffer, stream);
 	} else {
+#ifndef CONFIG_VIDEO_MP200
 		if (!q->reading)
 			__videobuf_read_start(q);
 		if (!q->reading) {
@@ -1046,7 +1356,30 @@ unsigned int videobuf_poll_stream(struct file *file,
 			q->read_off = 0;
 		}
 		buf = q->read_buf;
+#endif
+	}
+#ifdef CONFIG_VIDEO_MP200
+	if (!buf) {
+		mutex_unlock(&q->vb_lock);
+		return rc;
 	}
+
+	if (0 == rc) {
+		if (buf->state == VIDEOBUF_DQBUF_PERMIT ||
+		    buf->state == VIDEOBUF_ERROR) {
+			rc = POLLIN|POLLRDNORM;
+			goto done;
+		}
+		dbg_printk(_POLL_DBG,
+			"poll:  (%p) ->done(%p) ->state(%d)\n",
+			&buf->stream, &buf->done, buf->state);
+		poll_wait(file, &buf->done, wait);
+		if (buf->state == VIDEOBUF_DQBUF_PERMIT ||
+		    buf->state == VIDEOBUF_ERROR)
+			rc = POLLIN|POLLRDNORM;
+	}
+ done:
+#else
 	if (!buf)
 		rc = POLLERR;
 
@@ -1056,6 +1389,7 @@ unsigned int videobuf_poll_stream(struct file *file,
 		    buf->state == VIDEOBUF_ERROR)
 			rc = POLLIN|POLLRDNORM;
 	}
+#endif
 	mutex_unlock(&q->vb_lock);
 	return rc;
 }
diff --git a/include/linux/videodev2.h b/include/linux/videodev2.h
index 303d93f..d190c13 100644
--- a/include/linux/videodev2.h
+++ b/include/linux/videodev2.h
@@ -179,6 +179,9 @@ enum v4l2_memory {
 	V4L2_MEMORY_MMAP             = 1,
 	V4L2_MEMORY_USERPTR          = 2,
 	V4L2_MEMORY_OVERLAY          = 3,
+#ifdef CONFIG_VIDEO_MP200
+	V4L2_MEMORY_PHYSADDR         = 4,
+#endif
 };
 
 /* see also http://vektor.theorem.ca/graphics/ycbcr/ */
@@ -304,6 +307,10 @@ struct v4l2_pix_format {
 /* two planes -- one Y, one Cr + Cb interleaved  */
 #define V4L2_PIX_FMT_NV12    v4l2_fourcc('N', 'V', '1', '2') /* 12  Y/CbCr 4:2:0  */
 #define V4L2_PIX_FMT_NV21    v4l2_fourcc('N', 'V', '2', '1') /* 12  Y/CrCb 4:2:0  */
+#ifdef CONFIG_VIDEO_MP200
+#define V4L2_PIX_FMT_NV422 \
+	v4l2_fourcc('N', 'V', '4', '2') /* 12  Y/CbCr 4:2:2  */
+#endif
 
 /*  The following formats are not defined in the V4L2 specification */
 #define V4L2_PIX_FMT_YUV410  v4l2_fourcc('Y', 'U', 'V', '9') /*  9  YUV 4:1:0     */
@@ -487,6 +494,14 @@ struct v4l2_requestbuffers {
 	__u32			reserved[2];
 };
 
+#ifdef CONFIG_VIDEO_MP200
+struct v4l2_phys_add {
+	unsigned long		PhysAddr_Y;
+	unsigned long		PhysAddr_UV;
+	unsigned long		PhysAddr_V;
+};
+#endif
+
 struct v4l2_buffer {
 	__u32			index;
 	enum v4l2_buf_type      type;
@@ -497,17 +512,36 @@ struct v4l2_buffer {
 	struct v4l2_timecode	timecode;
 	__u32			sequence;
 
+#ifdef CONFIG_VIDEO_MP200
+	unsigned short	width;    /* Decipherment image(width)  */
+	unsigned short	height;   /* Decipherment image(height) */
+	unsigned short	d_width;  /* Decipherment image(Effective area) */
+#endif
+
 	/* memory location */
 	enum v4l2_memory        memory;
 	union {
 		__u32           offset;
 		unsigned long   userptr;
+#ifdef CONFIG_VIDEO_MP200
+		struct v4l2_phys_add phys_add;
+#endif
 	} m;
 	__u32			length;
 	__u32			input;
 	__u32			reserved;
 };
 
+#ifdef CONFIG_VIDEO_MP200
+struct v4l2_effect {
+	__u32			sequence;
+	struct v4l2_rect	source_crop;	/* VIDIOC_S_CROP */
+	__s32			movie_angle;	/* VIDIOC_S_CTRL */
+	struct v4l2_rect	screen;		/* VIDIOC_S_FMT  */
+};
+#endif
+
+
 /*  Flags for 'flags' field */
 #define V4L2_BUF_FLAG_MAPPED	0x0001  /* Buffer is mapped (flag) */
 #define V4L2_BUF_FLAG_QUEUED	0x0002	/* Buffer is queued for processing */
@@ -517,6 +551,10 @@ struct v4l2_buffer {
 #define V4L2_BUF_FLAG_BFRAME	0x0020	/* Image is a B-frame */
 #define V4L2_BUF_FLAG_TIMECODE	0x0100	/* timecode field is valid */
 #define V4L2_BUF_FLAG_INPUT     0x0200  /* input field is valid */
+#ifdef CONFIG_VIDEO_MP200
+#define V4L2_BUF_FLAG_CANCELED  0x4000  /* this frame is canceled */
+#define V4L2_BUF_FLAG_SKIPPED   0x8000  /* this frame is skipped  */
+#endif /* CONFIG_VIDEO_MP200 */
 
 /*
  *	O V E R L A Y   P R E V I E W
@@ -756,6 +794,12 @@ struct v4l2_output {
 #define V4L2_OUTPUT_TYPE_ANALOG			2
 #define V4L2_OUTPUT_TYPE_ANALOGVGAOVERLAY	3
 
+#ifdef CONFIG_VIDEO_MP200
+#define V4L2_OUTPUT_LCD  0
+#define V4L2_OUTPUT_NTSC 1
+#define V4L2_OUTPUT_PAL  2
+#endif
+
 /*
  *	C O N T R O L S
  */
@@ -764,6 +808,10 @@ struct v4l2_control {
 	__s32		     value;
 };
 
+#ifdef CONFIG_VIDEO_MP200
+#define V4L2_MOVIE_DISPLAY_ANGLE		99
+#endif
+
 struct v4l2_ext_control {
 	__u32 id;
 	__u32 reserved2[2];
@@ -1296,6 +1344,24 @@ struct v4l2_sliced_vbi_data {
 	__u8    data[48];
 };
 
+#ifdef CONFIG_VIDEO_MP200
+/* v4l2 work buffer(for IPU) setting */
+enum workbuf_active{
+	WORKBUF_NO_INIT = 0,
+	WORKBUF_INIT    = 1,
+	WORKBUF_ACTIVE  = 2,
+};
+
+struct v4l2_workbuffer /* V4L2_BUF_TYPE_PRIVATE */
+{
+	enum workbuf_active  active;
+	__u32	rot_addr; /* (IPU-ROT work buffer) start physical address */
+	__u32	rot_size; /* (IPU-ROT work buffer) buffer size            */
+	__u32	img_addr; /* (IPU-IMG work buffer) start physical address */
+	__u32	img_size; /* (IPU-IMG work buffer) buffer size            */
+};
+#endif /* CONFIG_VIDEO_MP200 */
+
 /*
  *	A G G R E G A T E   S T R U C T U R E S
  */
@@ -1426,6 +1492,11 @@ struct v4l2_chip_ident {
 #endif
 #define VIDIOC_S_HW_FREQ_SEEK	 _IOW('V', 82, struct v4l2_hw_freq_seek)
 
+#ifdef CONFIG_VIDEO_MP200
+#define VIDIOC_G_EFFECT         _IOR('V', 83, struct v4l2_effect)
+#define VIDIOC_S_EFFECT         _IOW('V', 84, struct v4l2_effect)
+#endif
+
 #ifdef __OLD_VIDIOC_
 /* for compatibility, will go away some day */
 #define VIDIOC_OVERLAY_OLD     	_IOWR('V', 14, int)
diff --git a/include/media/videobuf-core.h b/include/media/videobuf-core.h
index 874f134..fdd26fd 100644
--- a/include/media/videobuf-core.h
+++ b/include/media/videobuf-core.h
@@ -64,10 +64,51 @@ enum videobuf_state {
 	VIDEOBUF_QUEUED     = 2,
 	VIDEOBUF_ACTIVE     = 3,
 	VIDEOBUF_DONE       = 4,
+#ifdef CONFIG_VIDEO_MP200
+	VIDEOBUF_CANCELED   = 5,
+	VIDEOBUF_DQBUF_PERMIT = 6,
+	VIDEOBUF_ERROR      = 7,
+	VIDEOBUF_IDLE       = 8,
+#else
 	VIDEOBUF_ERROR      = 5,
 	VIDEOBUF_IDLE       = 6,
+#endif
+};
+
+
+#ifdef CONFIG_VIDEO_MP200
+/* state_queued flag */ /*** executing process is set. ***/
+enum videobuf_state_queued{
+	STATE_QUEUED_IDLE,
+	STATE_QUEUED_ROT_PREPARED,
+	STATE_QUEUED_ROT_QUEUED,
+	STATE_QUEUED_IMG_PREPARED,
+	STATE_QUEUED_IMG_QUEUED,
+	STATE_QUEUED_TMR_PREPARED,
+	STATE_QUEUED_TMR_QUEUED,
+	STATE_QUEUED_LCD_PREPARED,
+	STATE_QUEUED_LCD_QUEUED,
+	STATE_QUEUED_DONE,
 };
 
+/* state_proccess flag */ /*** executed process is set. ***/
+#define STATE_PROCCESS_IDLE         0x00
+#define STATE_PROCCESS_ROT_QUEUED   0x01
+#define STATE_PROCCESS_ROT_COMPLETE 0x02
+#define STATE_PROCCESS_IMG_QUEUED   0x04
+#define STATE_PROCCESS_IMG_COMPLETE 0x08
+#define STATE_PROCCESS_TMR_QUEUED   0x10
+#define STATE_PROCCESS_TMR_COMPLETE 0x20
+#define STATE_PROCCESS_LCD_QUEUED   0x40
+#define STATE_PROCCESS_LCD_COMPLETE 0x80
+
+/* for state_frame */ /*** executed process is set. ***/
+#define STATE_FRAME_DONE       0
+#define STATE_FRAME_IMMEDIATE -1
+#define STATE_FRAME_CANCELED  -2
+#define STATE_FRAME_SKIPPED   -3
+#endif
+
 struct videobuf_buffer {
 	unsigned int            i;
 	u32                     magic;
@@ -106,6 +147,22 @@ struct videobuf_buffer {
 	/* Private pointer to allow specific methods to store their data */
 	int			privsize;
 	void                    *priv;
+#ifdef CONFIG_VIDEO_MP200
+	enum videobuf_state_queued state_queued; /* executed process is set. */
+	unsigned long		state_proccess;  /* executed process is set. */
+	long			state_frame;     /* executed process is set. */
+
+	struct temp_buffer	*rot_buf;        /* pointer to ROT buffer */
+	struct temp_buffer	*img_buf;        /* pointer to IMG buffer */
+
+	struct v4l2_phys_add	base_addr;
+	struct v4l2_effect	save_effect;	/* the latest set value*/
+	__u32	         	pixelformat;
+
+	__u32	         	output;
+	__u32			sequence;
+	wait_queue_head_t       clear_done;
+#endif
 };
 
 struct videobuf_queue_ops {
@@ -118,6 +175,12 @@ struct videobuf_queue_ops {
 			  struct videobuf_buffer *vb);
 	void (*buf_release)(struct videobuf_queue *q,
 			    struct videobuf_buffer *vb);
+#ifdef CONFIG_VIDEO_MP200
+	int (*buf_cancel)(struct videobuf_queue *q,
+			    struct videobuf_buffer *vb);
+	void (*buf_dqueue)(struct videobuf_queue *q,
+			   struct videobuf_buffer *vb);
+#endif
 };
 
 #define MAGIC_QTYPE_OPS	0x12261003
@@ -181,6 +244,10 @@ struct videobuf_queue {
 
 	/* driver private data */
 	void                       *priv_data;
+#ifdef CONFIG_VIDEO_MP200
+	__u32                      index_max;
+	__u32                      sequence;
+#endif
 };
 
 int videobuf_waiton(struct videobuf_buffer *vb, int non_blocking, int intr);
-- 
1.6.5.2

