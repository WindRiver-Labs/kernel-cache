From c819b6a7f5a59573e547f3ed4eb257707736894f Mon Sep 17 00:00:00 2001
From: Kazuya Tsukamoto <kazuya.tsukamoto@necel.com>
Date: Mon, 9 Nov 2009 11:53:13 +0900
Subject: [PATCH 08/29] nec_em1: add pdma driver

pdma : control pdma and pcm interrupt handler for access
       from cpu and dsp.

When the interrupt of PDMA and PCM is generated, the interrupt
function registered by this driver is called. When two or more
registration is generated, the interrupt function registered
at the end becomes effective.

Signed-off-by: Kazuya Tsukamoto <kazuya.tsukamoto@necel.com>
---
 arch/arm/mach-mp200/include/mach/pcm_irq.h |   45 ++++
 arch/arm/mach-mp200/mp200_pdma.c           |  316 ++++++++++++++++++++++++++++
 arch/arm/mach-mp200/pcm_irq.c              |  196 +++++++++++++++++
 3 files changed, 557 insertions(+), 0 deletions(-)
 create mode 100644 arch/arm/mach-mp200/include/mach/pcm_irq.h
 create mode 100644 arch/arm/mach-mp200/mp200_pdma.c
 create mode 100644 arch/arm/mach-mp200/pcm_irq.c

diff --git a/arch/arm/mach-mp200/include/mach/pcm_irq.h b/arch/arm/mach-mp200/include/mach/pcm_irq.h
new file mode 100644
index 0000000..b8d2197
--- /dev/null
+++ b/arch/arm/mach-mp200/include/mach/pcm_irq.h
@@ -0,0 +1,45 @@
+/*
+ *  File Name	    : linux/include/asm-arm/arch-mp200/pcm_irq.h
+ *  Function	    : Power Management
+ *  Release Version : Ver 1.01
+ *  Release Date    : 2009/11/06
+ *
+ *  Copyright (C) NEC Electronics Corporation 2009
+ *
+ *
+ *  This program is free software;you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by Free
+ * Softwere Foundation; either version 2 of License, or (at your option) any
+ * later version.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY;
+ *  without even the implied warrnty of MERCHANTABILITY or FITNESS FOR A
+ * PARTICULAR PURPOSE.
+ *  See the GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ * with this program;
+ *  If not, write to the Free Software Foundation, Inc., 59 Temple Place -
+ * Suite 330, Boston,
+ *  MA 02111-1307, USA.
+ *
+ */
+#ifndef __ASM_ARM_ARCH_MP200_PCM_IRQ_H
+#define __ASM_ARM_ARCH_MP200_PCM_IRQ_H
+
+#define MP200_PCMMODE_NONE	0
+#define MP200_PCMMODE_ALSA	1
+#define MP200_PCMMODE_DSP	2
+
+typedef irqreturn_t (*pcm_callback_t)(int irq_no, void *data);
+
+extern int mp200_pcm0_request_irq(irq_handler_t handler, unsigned long irqflags,
+	const char *devname, void *dev_id, unsigned int pcmmode);
+extern void mp200_pcm0_free_irq(void *dev_id, unsigned int pcmmode);
+extern int mp200_pdma_request_irq(irq_handler_t handler, unsigned long irqflags,
+	const char *devname, void *dev_id, unsigned int pcmmode);
+extern void mp200_pdma_free_irq(void *dev_id, unsigned int pcmmode);
+
+extern unsigned int mp200_pcm0_get_pcmmode(void);
+#endif /* __ASM_ARM_ARCH_MP200_PCM_IRQ_H */
diff --git a/arch/arm/mach-mp200/mp200_pdma.c b/arch/arm/mach-mp200/mp200_pdma.c
new file mode 100644
index 0000000..a559124
--- /dev/null
+++ b/arch/arm/mach-mp200/mp200_pdma.c
@@ -0,0 +1,316 @@
+/*
+ *  File Name	    : linux/arch/arm/mach-mp200/mp200_pdma.c
+ *  Function	    : MP200 PCM Direct interface
+ *  Release Version : Ver 1.11
+ *  Release Date    : 2009/11/06
+ *
+ *  Copyright (C) NEC Electronics Corporation 2008, 2009
+ *
+ *
+ *  This program is free software;you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by Free
+ * Softwere Foundation; either version 2 of License, or (at your option) any
+ * later version.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY;
+ *  without even the implied warrnty of MERCHANTABILITY or FITNESS FOR A
+ * PARTICULAR PURPOSE.
+ *  See the GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ * with this program;
+ *  If not, write to the Free Software Foundation, Inc., 59 Temple Place -
+ * Suite 330, Boston,
+ *  MA 02111-1307, USA.
+ *
+ */
+
+/*============================================================*/
+/* include header                                             */
+/*============================================================*/
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/kthread.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/fs.h>
+
+#include <mach/io.h>
+#include <mach/pm.h>
+#include <mach/pmu.h>
+
+#include <mach/pcm_irq.h>
+
+/*============================================================*/
+/* constant definition                                        */
+/*============================================================*/
+#define DRIVER_NAME	"mp200_pdma"
+#define DRIVER_MAJOR	251
+
+#define	INTC_IT0_BASE	IO_ADDRESS(MP200_INTC_ACPU_BASE)
+#define	INTC_IT0_RAW0	(INTC_IT0_BASE + 0x0010)
+#define	INTC_IT_LIIS	(INTC_IT0_BASE + 0x0320)
+#define	INTC_IT_LIIR	(INTC_IT0_BASE + 0x0324)
+
+/* #define PDMA_DEBUG_LOG */
+#ifdef PDMA_DEBUG_LOG
+#define DPRINTK(format, args...) printk(format, ##args)
+#else
+#define DPRINTK(format, args...)
+#endif
+
+/*============================================================*/
+/* static function definition                                 */
+/*============================================================*/
+static int mp200_pdma_open(struct inode *inode, struct file *filp);
+static int mp200_pdma_release(struct inode *inode, struct file *filp);
+static irqreturn_t mp200_pdma_interrupt(int irq, void *dev_id);
+static irqreturn_t mp200_pcm0_interrupt(int irq, void *dev_id);
+static irqreturn_t mp200_sw_interrupt(int irq, void *dev_id);
+
+/*============================================================*/
+/* static variable definition                                 */
+/*============================================================*/
+static char *pdma_id = "PDMA_interrupt";
+static char *pcm_id = "PCM_interrupt";
+
+#ifdef PDMA_DEBUG_LOG
+static int pdma_int_ct;
+static int pcm0_int_ct;
+static int sw_int_ct;
+#endif
+static int mp200_pdma_drv_open;
+
+/*============================================================*/
+/*  interrupt Handler                                         */
+/*============================================================*/
+static irqreturn_t mp200_pdma_interrupt(int irq, void *dev_id)
+{
+	/* disable PDMA/PCM0 interrupt */
+	disable_irq(INT_PCM0);
+	disable_irq(INT_PDMA);
+
+#ifdef PDMA_DEBUG_LOG
+	pdma_int_ct++;
+	DPRINTK("** PDMA_INTERRUPT %d **\n", pdma_int_ct);
+#endif
+	mp200_pm_pdma_suspend_disable();
+
+	/* clear SW interrupt 2 */
+	__raw_writel(0x00000004, INTC_IT_LIIR);
+	/* set SW interrupt 0 */
+	__raw_writel(0x00000001, INTC_IT_LIIS);
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t mp200_pcm0_interrupt(int irq, void *dev_id)
+{
+	/* disable PDMA/PCM0 interrupt */
+	disable_irq(INT_PDMA);
+	disable_irq(INT_PCM0);
+
+#ifdef PDMA_DEBUG_LOG
+	pcm0_int_ct++;
+	DPRINTK("** PCM0_INTERRUPT %d **\n", pcm0_int_ct);
+#endif
+	mp200_pm_pdma_suspend_disable();
+
+	/* clear SW interrupt 3 */
+	__raw_writel(0x00000008, INTC_IT_LIIR);
+	/* set SW interrupt 1 */
+	__raw_writel(0x00000002, INTC_IT_LIIS);
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t mp200_sw_interrupt(int irq, void *dev_id)
+{
+#ifdef PDMA_DEBUG_LOG
+	sw_int_ct++;
+	DPRINTK("** SW_INTERRUPT%d %d **\n", (irq - INT_SSD0), sw_int_ct);
+#endif
+	/* clear SW interrupt 2 or 3 */
+	__raw_writel((0x00000001 << (irq - INT_SSD0)), INTC_IT_LIIR);
+	mp200_pm_pdma_suspend_enable();
+
+	enable_irq(INT_PDMA);
+	enable_irq(INT_PCM0);
+
+	return IRQ_HANDLED;
+}
+
+/*============================================================*/
+/*  open/close function                                       */
+/*============================================================*/
+/* ----------------------------------------------------------
+    FUNCTION : mp200_pdma_open
+    IMPORT   : inode, filp
+    RETURN   : 0      : success
+	       -EBUSY : fale
+    NOTE     : none
+    UPDATE   : 2009.7.7
+   ---------------------------------------------------------- */
+static int mp200_pdma_open(struct inode *inode, struct file *filp)
+{
+	int ret = 0, err = 0;
+
+	DPRINTK(KERN_INFO "%s\n", __func__);
+
+	mp200_pm_pdma_suspend_disable();
+	if (mp200_pdma_drv_open) {
+		DPRINTK(KERN_INFO "mp200_pdma is being opened.\n");
+		return -EBUSY;
+	}
+
+	/* sw interrupt clear */
+	__raw_writel(0x0000000f, INTC_IT_LIIR);
+	/* request irq */
+	/* PDMA */
+	ret = mp200_pdma_request_irq(mp200_pdma_interrupt, IRQF_DISABLED,
+	 pdma_id, NULL, MP200_PCMMODE_DSP);
+	DPRINTK("-- request_irq (INT_PDMA) ret = 0x%08x\n", ret);
+	if (!ret) {
+		/* PCM0 */
+		ret = mp200_pcm0_request_irq(mp200_pcm0_interrupt,
+		 IRQF_DISABLED, pcm_id, NULL, MP200_PCMMODE_DSP);
+		DPRINTK("-- request_irq (INT_PCM0) ret = 0x%08x\n", ret);
+	} else {
+		err = 1;
+	}
+	if (!ret) {
+		/*  */
+		ret = request_irq(INT_SSD2, &mp200_sw_interrupt, 0,
+		 "SW_INT2_interrupt", NULL);
+		DPRINTK("-- request_irq (INT_SSD2) ret = 0x%08x\n", ret);
+	} else if (!err) {
+		err = 2;
+	}
+	if (!ret) {
+		ret = request_irq(INT_SSD3, &mp200_sw_interrupt, 0,
+		 "SW_INT3_interrupt", NULL);
+		DPRINTK("-- request_irq (INT_SSD3) ret = 0x%08x\n", ret);
+	} else if (!err) {
+		err = 3;
+	}
+	if (ret && !err)
+		err = 4;
+
+	switch (err) {
+	case 4:
+		free_irq(INT_SSD2, NULL);
+	case 3:
+		mp200_pcm0_free_irq(NULL, MP200_PCMMODE_DSP);
+	case 2:
+		mp200_pdma_free_irq(NULL, MP200_PCMMODE_DSP);
+	case 1:
+		ret = -EBUSY;
+		break;
+	default:
+		mp200_pdma_drv_open = 1;
+#ifdef PDMA_DEBUG_LOG
+		pdma_int_ct = 0;
+		pcm0_int_ct = 0;
+		sw_int_ct = 0;
+#endif
+		break;
+    }
+
+	return ret;
+}
+
+
+/* ----------------------------------------------------------
+    FUNCTION : mp200_pdma_release
+    IMPORT   : inode, filp
+    RETURN   : 0 : success
+    NOTE     : none
+    UPDATE   : 2009.7.7
+  ----------------------------------------------------------- */
+static int mp200_pdma_release(struct inode *inode, struct file *filp)
+{
+	DPRINTK(KERN_INFO "%s\n", __func__);
+#ifdef PDMA_DEBUG_LOG
+	DPRINTK(KERN_INFO "pdma_int = %d, pcm0_int = %d, sw_int = %d\n",
+	 pdma_int_ct, pcm0_int_ct, sw_int_ct);
+#endif
+
+	if (mp200_pdma_drv_open) {
+		mp200_pm_pdma_suspend_disable();
+		/* sw interrupt clear */
+		__raw_writel(0x0000000f, INTC_IT_LIIR);
+		/* free irq */
+		mp200_pdma_free_irq(NULL, MP200_PCMMODE_DSP);
+		mp200_pcm0_free_irq(NULL, MP200_PCMMODE_DSP);
+		free_irq(INT_SSD2, NULL);
+		free_irq(INT_SSD3, NULL);
+		mp200_pdma_drv_open = 0;
+	}
+
+	return 0;
+}
+
+
+/*============================================================*/
+/*  init/end function                                         */
+/*============================================================*/
+
+static struct file_operations mp200_pdma_dev = {
+	.owner   = THIS_MODULE,
+	.open    = mp200_pdma_open,
+	.release = mp200_pdma_release,
+};
+
+/* ----------------------------------------------------------
+    FUNCTION : mp200_pdma_init
+    IMPORT   : none
+    RETURN   : 0 : success
+    NOTE     : none
+    UPDATE   : 2009.7.7
+   ---------------------------------------------------------- */
+static int __init mp200_pdma_init(void)
+{
+	if (register_chrdev(DRIVER_MAJOR, DRIVER_NAME, &mp200_pdma_dev)) {
+		printk(KERN_INFO "%s : register_chrdev failed\n", __func__);
+		return -EBUSY;
+	}
+
+#ifdef PDMA_DEBUG_LOG
+	pdma_int_ct = 0;
+	pcm0_int_ct = 0;
+	sw_int_ct = 0;
+#endif
+	mp200_pdma_drv_open = 0;
+	DPRINTK(KERN_INFO "%s : loaded  into kernel\n", __func__);
+
+	return 0;
+}
+
+
+/* ----------------------------------------------------------
+    FUNCTION : mp200_pdma_exit
+    IMPORT   : none
+    RETURN   : none
+    NOTE     : none
+    UPDATE   : 2009.7.7
+  ----------------------------------------------------------- */
+static void __exit mp200_pdma_exit(void)
+{
+	unregister_chrdev(DRIVER_MAJOR, DRIVER_NAME);
+
+	DPRINTK(KERN_INFO "%s : removed from kernel\n", __func__);
+}
+
+
+/*============================================================*/
+/*  module definition                                         */
+/*============================================================*/
+module_init(mp200_pdma_init);
+module_exit(mp200_pdma_exit);
+
+MODULE_DESCRIPTION("MP200 PDMA driver for PCM Direct");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS(DRIVER_NAME);
+MODULE_AUTHOR("NEC Electronics");
diff --git a/arch/arm/mach-mp200/pcm_irq.c b/arch/arm/mach-mp200/pcm_irq.c
new file mode 100644
index 0000000..68a5310
--- /dev/null
+++ b/arch/arm/mach-mp200/pcm_irq.c
@@ -0,0 +1,196 @@
+	/*
+ *  File Name	    : linux/arch/arm/mach-mp200/pcm_irq.c
+ *  Function	    : MP200 PCM Direct interface
+ *  Release Version : Ver 1.01
+ *  Release Date    : 2008/11/06
+ *
+ *  Copyright (C) NEC Electronics Corporation 2008,2009
+ *
+ *
+ *  This program is free software;you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by Free
+ * Softwere Foundation; either version 2 of License, or (at your option) any
+ * later version.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY;
+ *  without even the implied warrnty of MERCHANTABILITY or FITNESS FOR A
+ * PARTICULAR PURPOSE.
+ *  See the GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ * with this program;
+ *  If not, write to the Free Software Foundation, Inc., 59 Temple Place -
+ * Suite 330, Boston,
+ *  MA 02111-1307, USA.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <mach/pcm_irq.h>
+
+/* #define DEBUG_PDMA */
+#ifdef DEBUG_PDMA
+#define DPRINT(fmt, args...) \
+	printk(KERN_INFO "####%s:%d: " fmt, __func__, __LINE__, ## args);
+#else
+#define DPRINT(fmt, args...)
+#endif
+
+#define DRIVER_NAME	"pcm_irq"
+
+#define PCMMODE_NUM	2
+#define MP200_INT_PCM0		INT_PCM0
+#define MP200_INT_PDMA		INT_PDMA
+
+struct irq_info {
+	unsigned int pcmmode;
+	irq_handler_t handler;
+	unsigned long irqflags;
+	const char *devname;
+	void *dev_id;
+};
+
+#define VALID_PCMMODE(x)	\
+	((x == MP200_PCMMODE_ALSA) || (x == MP200_PCMMODE_DSP))
+#define MODE_TO_IDX(x)		(x - 1)
+#define GET_MODEINFO(x,y)	\
+	((x == MP200_INT_PCM0) ? &pcm0_info[y] : &pdma_info[y])
+
+static struct irq_info pcm0_info[PCMMODE_NUM];
+static struct irq_info pdma_info[PCMMODE_NUM];
+
+static unsigned int current_mode = MP200_PCMMODE_NONE;
+
+static int do_request_irq(unsigned int irq, irq_handler_t handler,
+	unsigned long irqflags, const char *devname, void *dev_id,
+	unsigned int pcmmode)
+{
+	int err = 0;
+	struct irq_info *info;
+	DPRINT("irq = %d, dev_id = %x, pcmmode = %d\n", irq,
+		(unsigned int)dev_id, pcmmode);
+	if (!VALID_PCMMODE(pcmmode))
+		return -EINVAL;
+
+	info = GET_MODEINFO(irq, MODE_TO_IDX(pcmmode));
+
+	if (info->handler)
+		return -EBUSY;
+
+	if (can_request_irq(irq, IRQF_DISABLED) == 0) {
+		struct irq_info *info2 =
+				GET_MODEINFO(irq, !MODE_TO_IDX(pcmmode));
+		if (info2->handler)
+			free_irq(irq, info2->dev_id);
+		else
+			return -EBUSY;
+	}
+	err = request_irq(irq, handler, irqflags, devname, dev_id);
+
+	if (err != 0) {
+		printk(KERN_INFO "%s(): unable to request IRQ %d (%s)\n",
+			  __func__, irq, devname);
+		return err;
+	}
+
+	info->devname = devname;
+	info->irqflags = irqflags;
+	info->dev_id = dev_id;
+	info->handler = handler;
+	info->pcmmode = pcmmode;
+
+	DPRINT("info->devname = %x\n", info->devname);
+	DPRINT("info->irqflags = %x\n", info->irqflags);
+	DPRINT("info->dev_id = %x\n", info->dev_id);
+	DPRINT("info->handler = %x\n", info->handler);
+	DPRINT("info->pcmmode = %d\n", info->pcmmode);
+
+	if (irq == MP200_INT_PCM0)
+		current_mode = pcmmode;
+
+	DPRINT("current_mode = %d\n", current_mode);
+	return 0;
+}
+
+static void do_free_irq(unsigned int irq, void *dev_id, unsigned int pcmmode)
+{
+	int err = 0;
+	struct irq_info *info;
+
+	if (!VALID_PCMMODE(pcmmode))
+		return;
+
+	info = GET_MODEINFO(irq, MODE_TO_IDX(pcmmode));
+	if (info->handler == 0)
+		return;
+
+	if ((irq != MP200_INT_PCM0) || (current_mode == pcmmode)) {
+		struct irq_info *info2 =
+			GET_MODEINFO(irq, !MODE_TO_IDX(pcmmode));
+
+		free_irq(irq, info->dev_id);
+		if (info2->handler) {
+			err = request_irq(irq, info2->handler,
+				info2->irqflags, info2->devname, info2->dev_id);
+			if (err != 0) {
+				printk(KERN_INFO
+					"%s(): unable to request IRQ %d (%s)\n",
+					__func__, irq, info2->devname);
+			}
+		}
+		if (irq == MP200_INT_PCM0)
+			current_mode = info2->pcmmode;
+	}
+
+	info->pcmmode = MP200_PCMMODE_NONE;
+	info->handler = 0;
+	info->dev_id = 0;
+	info->devname = 0;
+	info->irqflags = 0;
+
+	return;
+}
+
+int mp200_pcm0_request_irq(irq_handler_t handler, unsigned long irqflags,
+	const char *devname, void *dev_id, unsigned int pcmmode)
+{
+	return do_request_irq(MP200_INT_PCM0, handler, irqflags,
+			devname, dev_id, pcmmode);
+}
+EXPORT_SYMBOL(mp200_pcm0_request_irq);
+
+void mp200_pcm0_free_irq(void *dev_id, unsigned int pcmmode)
+{
+	do_free_irq(MP200_INT_PCM0, dev_id, pcmmode);
+}
+EXPORT_SYMBOL(mp200_pcm0_free_irq);
+
+int mp200_pdma_request_irq(irq_handler_t handler, unsigned long irqflags,
+	const char *devname, void *dev_id, unsigned int pcmmode)
+{
+	return do_request_irq(MP200_INT_PDMA, handler, irqflags,
+			devname, dev_id, pcmmode);
+}
+EXPORT_SYMBOL(mp200_pdma_request_irq);
+
+void mp200_pdma_free_irq(void *dev_id, unsigned int pcmmode)
+{
+	do_free_irq(MP200_INT_PDMA, dev_id, pcmmode);
+}
+EXPORT_SYMBOL(mp200_pdma_free_irq);
+
+unsigned int mp200_pcm0_get_pcmmode(void)
+{
+	return current_mode;
+}
+EXPORT_SYMBOL(mp200_pcm0_get_pcmmode);
+
+
+
+MODULE_DESCRIPTION("pcm_irq_driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS(DRIVER_NAME);
+MODULE_AUTHOR("NEC Electronics");
-- 
1.6.5.2

