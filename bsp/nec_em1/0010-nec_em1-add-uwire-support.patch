From e34c4bab33a1231ede575ad0455961415916d0f5 Mon Sep 17 00:00:00 2001
From: Kazuya Tsukamoto <kazuya.tsukamoto@necel.com>
Date: Mon, 9 Nov 2009 12:01:32 +0900
Subject: [PATCH 10/29] nec_em1: add uwire support

note: the lines of uwire is not available in EMMA Mobile
Develpment Kit Board. So this driver cannot be operated in the board.

Signed-off-by: Kazuya Tsukamoto <kazuya.tsukamoto@necel.com>
---
 arch/arm/mach-mp200/include/mach/uwire.h |   51 +++
 arch/arm/mach-mp200/uwire.c              |  496 ++++++++++++++++++++++++++++++
 arch/arm/mach-mp200/uwire.h              |   88 ++++++
 3 files changed, 635 insertions(+), 0 deletions(-)
 create mode 100644 arch/arm/mach-mp200/include/mach/uwire.h
 create mode 100644 arch/arm/mach-mp200/uwire.c
 create mode 100644 arch/arm/mach-mp200/uwire.h

diff --git a/arch/arm/mach-mp200/include/mach/uwire.h b/arch/arm/mach-mp200/include/mach/uwire.h
new file mode 100644
index 0000000..b6c78ea
--- /dev/null
+++ b/arch/arm/mach-mp200/include/mach/uwire.h
@@ -0,0 +1,51 @@
+/*
+ *  File Name       : linux/include/asm-arm/arch-mp200/uwire.h
+ *  Function        : uwire
+ *  Release Version : Ver 1.00
+ *  Release Date    : 2005/05/16
+ *
+ *  Copyright (C) NEC Electronics Corporation 2005
+ *
+ *
+ *  This program is free software;you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License as published by Free
+ *  Softwere Foundation; either version 2 of License, or (at your option) any
+ *  later version.
+ *
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warrnty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; If not, write to the Free Software Foundation, Inc., 59
+ *  Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#ifndef __ASM_ARM_ARCH_MP200_UWIRE_H
+#define __ASM_ARM_ARCH_MP200_UWIRE_H
+
+#define UWIRE_CS0 		0
+#define UWIRE_CS1 		1
+
+#define	UWIRE_CS_PWC		UWIRE_CS0
+#define UWIRE_CS_BOARD_B  	UWIRE_CS1
+
+#define UWIRE_SCLOCK_1500KHz	0
+#define UWIRE_SCLOCK_3MHz	1
+#define UWIRE_SCLOCK_6MHz	2
+#define UWIRE_SCLOCK_12MHz	3
+#define UWIRE_SCLOCK_24MHz	4
+#define UWIRE_SCLOCK_48MHz	5
+#define UWIRE_SCLOCK_ANY	(-1)
+
+extern int uwire_read(int cs, u_char addr, u_char *data);
+extern int uwire_write(int cs, u_char addr, u_char data);
+
+extern int uwire_set_active_level(int cs, int high);
+
+extern int uwire_vl_read(int cs, int clk, u_char addr, u_int len, u_long *data);
+extern int uwire_vl_write(int cs, int clk, u_char addr, u_int len, u_long data);
+
+#endif				/* __ASM_ARM_ARCH_MP200_UWIRE_H */
diff --git a/arch/arm/mach-mp200/uwire.c b/arch/arm/mach-mp200/uwire.c
new file mode 100644
index 0000000..7f937f6
--- /dev/null
+++ b/arch/arm/mach-mp200/uwire.c
@@ -0,0 +1,496 @@
+/*
+ *  File Name       : linux/arch/arm/mach-mp200/uwire.c
+ *  Function        : uwire
+ *  Release Version : Ver 1.01
+ *  Release Date    : 2006/01/31
+ *
+ *  Copyright (C) NEC Electronics Corporation 2005-2006
+ *
+ *
+ *  This program is free software;you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License as published by Free
+ *  Softwere Foundation; either version 2 of License, or (at your option) any
+ *  later version.
+ *
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warrnty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; If not, write to the Free Software Foundation, Inc., 59
+ *  Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <mach/hardware.h>
+#include <mach/uwire.h>
+#include <mach/smu.h>
+#include <mach/pmu.h>
+#include <linux/io.h>
+#include "uwire.h"
+
+/*
+ * Solution Board
+ */
+static int uwire_cs0_active_level = 1;
+static int uwire_cs1_active_level;
+
+static DEFINE_SPINLOCK(lck);
+
+static int uwire_init_flag = 1;
+
+/* PLL3 229.376MHz : 237.568MHz */
+static unsigned int mwi_plldiv_table[] = {
+	SMU_DIV160, /* 1500KHz(1434KHz : 1485KHz) */
+	SMU_DIV80, /* 3MHz   (2.87MHz : 2.97MHz) */
+	SMU_DIV40, /* 6MHz   (5.73MHz : 5.94MHz) */
+	SMU_DIV20, /* 12MHz  (11.47MHz: 11.88MHz) */
+	SMU_DIV10, /* 24MHz  (22.94MHz: 23.76MHz) */
+	SMU_DIV6, /* 48MHz  (38.23MHz: 39.59MHz) */
+};
+
+/*
+ * SMU Control
+ */
+
+static inline void uwire_pclock_start(void)
+{
+	mp200_pmu_open_clockgate(MP200_CLOCKGATE_MWI_PCLK);
+}
+
+static inline void uwire_pclock_stop(void)
+{
+	mp200_pmu_close_clockgate(MP200_CLOCKGATE_MWI_PCLK);
+}
+
+static inline void uwire_sclock_start(void)
+{
+	mp200_pmu_open_clockgate(MP200_CLOCKGATE_MWI_SCLK);
+}
+
+static inline void uwire_sclock_stop(void)
+{
+	mp200_pmu_close_clockgate(MP200_CLOCKGATE_MWI_SCLK);
+}
+
+static inline void uwire_clock_start(void)
+{
+	mp200_pmu_open_clockgate(MP200_CLOCKGATE_MWI_PCLK);
+	mp200_pmu_open_clockgate(MP200_CLOCKGATE_MWI_SCLK);
+}
+
+static inline void uwire_clock_stop(void)
+{
+	mp200_pmu_close_clockgate(MP200_CLOCKGATE_MWI_PCLK);
+	mp200_pmu_close_clockgate(MP200_CLOCKGATE_MWI_SCLK);
+}
+
+static inline void uwire_dev_unreset(void)
+{
+	mp200_pmu_unreset_device(MP200_RESETDEVICE_MWI);
+}
+static inline void uwire_clkctrl_on(void)
+{
+	mp200_pmu_clkctrl_on(MP200_CLKCTRL_MWIPCLK);
+	mp200_pmu_clkctrl_on(MP200_CLKCTRL_MWISCLK);
+}
+
+static inline void uwire_clkctrl_off(void)
+{
+	mp200_pmu_clkctrl_off(MP200_CLKCTRL_MWIPCLK);
+	mp200_pmu_clkctrl_off(MP200_CLKCTRL_MWISCLK);
+}
+
+
+/*
+   setting frequency devider function
+   argument is positive integer 1-256
+ */
+
+static inline void uwire_set_divisor(u_int sclk)
+{
+
+	switch (sclk) {
+	case UWIRE_SCLOCK_1500KHz:
+	case UWIRE_SCLOCK_3MHz:
+	case UWIRE_SCLOCK_6MHz:
+	case UWIRE_SCLOCK_12MHz:
+	case UWIRE_SCLOCK_24MHz:
+	case UWIRE_SCLOCK_48MHz:
+		break;
+	default:
+		return;
+	}
+
+	outl(mwi_plldiv_table[sclk], SMU_DIVMWISCLK);
+
+}
+
+/*
+ * cs control
+ */
+static inline u_int sl_board_cs_fixup(int cs)
+{
+	if (cs == UWIRE_CS0) {
+		return (CS0_EN | (uwire_cs0_active_level ? CS0 : 0))
+			| (CS1_EN | (uwire_cs1_active_level ? 0 : CS1));
+	}
+	if (cs == UWIRE_CS1) {
+		return (CS0_EN | (uwire_cs0_active_level ? 0 : CS0))
+			| (CS1_EN | (uwire_cs1_active_level ? CS1 : 0));
+	}
+	return (CS0_EN | (uwire_cs0_active_level ? 0 : CS0))
+		| (CS1_EN | (uwire_cs1_active_level ? 0 : CS1));
+}
+
+int uwire_set_active_level(int cs, int high)
+{
+	int org_level;
+
+	/* uwire initialize error check */
+	if (uwire_init_flag) {
+		printk(KERN_INFO "uwire_set_active_level(): "
+		       "uwire initialize error\n");
+		return -EPERM;
+	}
+
+	if (cs == UWIRE_CS0) {
+		org_level = uwire_cs0_active_level;
+		uwire_cs0_active_level = high;
+	} else if (cs == UWIRE_CS1) {
+		org_level = uwire_cs1_active_level;
+		uwire_cs1_active_level = high;
+	} else {
+		return -EINVAL;
+	}
+	return org_level;
+}
+EXPORT_SYMBOL(uwire_set_active_level);
+
+
+/*
+ * uWire I/O
+ */
+
+int uwire_vl_read(int cs, int sclk, u_char addr, u_int len, u_long *data)
+{
+	u_int uwire_tick;
+	u_long cpu_flags;
+	u_long mask;
+	u_int org_sclk = ~0U;
+
+	/* uwire initialize error check */
+	if (uwire_init_flag) {
+		printk(KERN_INFO "uwire_vl_read(): "
+		       "uwire initialize error\n");
+		return -EPERM;
+	}
+#ifdef UWIRE_DEBUG
+	printk(KERN_DEBUG "uwire_vl_read(): CS%d read.\n", cs);
+	printk(KERN_DEBUG "uwire_vl_read(): addr=0x%x\n", addr);
+#endif
+
+	/* Check CS Number */
+	if ((UWIRE_CS0 != cs) && (UWIRE_CS1 != cs)) {
+		printk(KERN_INFO "uwire_vl_read(): #CS(%d) is invalid number\n",
+		       cs);
+		return -EINVAL;
+	}
+
+	if ((len < 1) || (UWIRE_MAX_BIT_LEN < len)) {
+		printk(KERN_INFO "uwire_vl_read(): data length invalid(%u)\n",
+		       len);
+		return -EINVAL;
+	} else if (len == UWIRE_MAX_BIT_LEN) {
+		mask = ~0UL;
+	} else {
+		mask = (1UL << len) - 1;
+	}
+
+	spin_lock_irqsave(&lck, cpu_flags);
+
+	if (sclk != -1) {
+		org_sclk = inl(SMU_DIVMWISCLK);
+		uwire_set_divisor(sclk);
+	}
+
+	uwire_sclock_start();   /* SCLK start */
+
+	/* clear */
+	outl(MWI_FFCLR, MWI_INTFFCLR);  /* MWI_STATUS clear */
+
+	/* int clear check */
+	while (inl(MWI_INTRAW) & MWI_RAW)
+		;
+
+	outl(sl_board_cs_fixup(-1), MWI_CONT);
+
+	/* start transmit&receive */
+	if (UWIRE_CS0 == cs)
+		outl(MWI_EDGE, MWI_CS0);
+	else
+		outl(MWI_EDGE, MWI_CS1);
+
+	outl(MWI_SEQUENTIAL_MODE | ((len - 1) << UWIRE_BIT_RX_SHIFT) |
+	     sl_board_cs_fixup(cs), MWI_CONT);
+
+	outl((addr << 24), MWI_TXQA);   /* MSB shift (31-24 <-- 7-0) */
+	outl(MWI_START_FLAG, MWI_START);
+
+	/* wait end transmit */
+	uwire_tick = 0;
+	while ((inl(MWI_INTRAW) & MWI_RAW) == 0) {
+		if (++uwire_tick > UWIRE_MAX_WAIT) {
+#ifdef UWIRE_DEBUG
+			printk(KERN_DEBUG "uwire_vl_read(): raw=%x\n",
+					inl(MWI_INTRAW));
+#endif
+			uwire_sclock_stop();
+			outl(MWI_FFCLR, MWI_INTFFCLR);  /* MWI_STATUS clear */
+
+			/* Select CS Inactive : CSx_EN | CSx(0) x=0or1 */
+			outl(sl_board_cs_fixup(-1), MWI_CONT);
+
+			if (org_sclk != ~0U)
+				outl(org_sclk, SMU_DIVMWISCLK);
+
+			spin_unlock_irqrestore(&lck, cpu_flags);
+			printk(KERN_INFO "uwire_vl_read(): busy\n");
+
+			return -EBUSY;
+		}
+	}
+
+	*data = inl(MWI_RXQ) & mask;
+
+	outl(MWI_FFCLR, MWI_INTFFCLR);  /* MWI_STATUS clear */
+	uwire_sclock_stop();    /* SCLK stop */
+
+	if (org_sclk != ~0U)
+		outl(org_sclk, SMU_DIVMWISCLK);
+
+	/* int clear check */
+	while (inl(MWI_INTRAW) & MWI_RAW)
+		;
+
+	/* Select CS Inactive : CSx_EN | CSx(0) x=0or1 */
+	outl(sl_board_cs_fixup(-1), MWI_CONT);
+
+	spin_unlock_irqrestore(&lck, cpu_flags);
+
+#ifdef UWIRE_DEBUG
+	printk(KERN_DEBUG "uwire_vl_read(): CS%d read data=%x\n", cs, *data);
+#endif
+	return 0;
+}
+EXPORT_SYMBOL(uwire_vl_read);
+
+int uwire_read(int cs, u_char addr, u_char *data)
+{
+	u_long r_data;
+	int ret;
+
+	ret = uwire_vl_read(cs, UWIRE_SCLOCK_ANY, addr, 8, &r_data);
+	if (ret == 0)
+		*data = (u_char) r_data;
+
+	return ret;
+}
+EXPORT_SYMBOL(uwire_read);
+
+int uwire_vl_write(int cs, int sclk, u_char addr, u_int len, u_long data)
+{
+	u_int uwire_tick;
+	u_long cpu_flags;
+	u_int org_sclk = ~0U;
+
+	/* uwire initialize error check */
+	if (uwire_init_flag) {
+		printk(KERN_INFO "uwire_vl_write(): "
+		       "uwire initialize error\n");
+		return -EPERM;
+	}
+#ifdef UWIRE_DEBUG
+	printk(KERN_DEBUG "uwire_vl_write(): CS%d write.\n", cs);
+	printk(KERN_DEBUG "uwire_vl_write(): addr=0x%x\n", addr);
+#endif
+
+	/* Check CS Number */
+	if ((UWIRE_CS0 != cs) && (UWIRE_CS1 != cs)) {
+		printk(KERN_INFO
+		       "uwire_vl_write(): #CS(%d) is invalid number\n", cs);
+		return -EINVAL;
+	}
+
+	if ((len < 1) || (UWIRE_MAX_BIT_LEN < len)) {
+		printk(KERN_INFO "uwire_vl_write(): data length invalid(%u)\n",
+		       len);
+		return -EINVAL;
+	}
+
+	spin_lock_irqsave(&lck, cpu_flags);
+
+	if (sclk != -1) {
+		org_sclk = inl(SMU_DIVMWISCLK);
+		uwire_set_divisor(sclk);
+	}
+
+	uwire_sclock_start();   /* SCLK start */
+
+	/* clear */
+	outl(MWI_FFCLR, MWI_INTFFCLR);  /* MWI_STATUS clear */
+
+	/* int clear check */
+	while (inl(MWI_INTRAW) & MWI_RAW)
+		;
+
+	outl(sl_board_cs_fixup(-1), MWI_CONT);
+
+	/* start transmit */
+	if (UWIRE_CS0 == cs)
+		outl(MWI_EDGE, MWI_CS0);
+	else
+		outl(MWI_EDGE, MWI_CS1);
+
+	outl(MWI_PACKAGE_MODE | ((len - 1) << UWIRE_BIT_DTX_SHIFT) |
+	     sl_board_cs_fixup(cs), MWI_CONT);
+	outl((addr << 24), MWI_TXQA);   /* MSB shift (31-24 <-- 7-0) */
+	outl((data << (32 - len)), MWI_TXQ);    /* MSB shift (31-24 <-- 7-0) */
+	outl(MWI_START_FLAG, MWI_START);
+
+	/* wait end transmit */
+	uwire_tick = 0;
+	while ((inl(MWI_INTRAW) & MWI_RAW) == 0) {
+		if (++uwire_tick > UWIRE_MAX_WAIT) {
+#ifdef UWIRE_DEBUG
+			printk(KERN_DEBUG "uwire_vl_write(): raw=%x\n",
+					inl(MWI_INTRAW));
+#endif
+			outl(MWI_FFCLR, MWI_INTFFCLR);  /* MWI_STATUS clear */
+			uwire_sclock_stop();
+
+			/* Select CS Inactive : CSx_EN | CSx(0) x=0or1 */
+			outl(sl_board_cs_fixup(-1), MWI_CONT);
+
+			if (org_sclk != ~0U)
+				outl(org_sclk, SMU_DIVMWISCLK);
+
+			spin_unlock_irqrestore(&lck, cpu_flags);
+			printk(KERN_INFO "uwire_vl_write(): busy\n");
+
+			return -EBUSY;
+		}
+	}
+
+	outl(MWI_FFCLR, MWI_INTFFCLR);  /* MWI_STATUS clear */
+	uwire_sclock_stop();    /* SCLK stop */
+
+	if (org_sclk != ~0U)
+		outl(org_sclk, SMU_DIVMWISCLK);
+
+	/* int clear check */
+	while (inl(MWI_INTRAW) & MWI_RAW)
+		;
+
+	/* Select CS Inactive : CSx_EN | CSx(0) x=0or1 */
+	outl(sl_board_cs_fixup(-1), MWI_CONT);
+
+	spin_unlock_irqrestore(&lck, cpu_flags);
+
+	return 0;
+}
+EXPORT_SYMBOL(uwire_vl_write);
+
+int uwire_write(int cs, u_char addr, u_char data)
+{
+	int ret;
+
+	ret = uwire_vl_write(cs, UWIRE_SCLOCK_ANY, addr, 8, data);
+
+	return ret;
+}
+EXPORT_SYMBOL(uwire_write);
+
+static int __init cs0_setup(char *sel)
+{
+	if (*sel == '0')
+		uwire_cs0_active_level = 0;
+	else
+		uwire_cs0_active_level = 1;
+
+	return 0;
+}
+
+static int __init cs1_setup(char *sel)
+{
+	if (*sel == '0')
+		uwire_cs1_active_level = 0;
+	else
+		uwire_cs1_active_level = 1;
+
+	return 0;
+}
+
+__setup("uwire_cs0=", cs0_setup);
+__setup("uwire_cs1=", cs1_setup);
+
+static int __init uwire_init(void)
+{
+	u_long flags;
+
+	printk(KERN_INFO "Starting uwire.\n");
+
+	spin_lock_irqsave(&lck, flags);
+	uwire_clock_stop();     /* PCLK/SCLK stop */
+
+/*
+    determin clock and set a devisor at valid value
+ */
+
+	uwire_set_divisor(UWIRE_SCLOCK_3MHz);
+
+
+	/* PCLK stop is possible, but we get going that just in case */
+	uwire_clock_start();    /* CLK start */
+	uwire_clkctrl_off();    /* AUTO CLK OFF */
+	uwire_dev_unreset();    /* UNRESET */
+	uwire_clkctrl_on();     /* AUTO CLK ON */
+	spin_unlock_irqrestore(&lck, flags);
+
+	uwire_init_flag = 0;
+
+#ifdef UWIRE_DEBUG
+	{
+		u_int cs0, cs1, non;
+		cs0 = sl_board_cs_fixup(UWIRE_CS0);
+		cs1 = sl_board_cs_fixup(UWIRE_CS1);
+		non = sl_board_cs_fixup(-1);
+		printk(KERN_INFO "uWire: CS0=0x%02x, CS1=0x%02x, INI=0x%02x\n",
+		       cs0, cs1, non);
+	}
+#endif
+
+	return 0;
+}
+
+
+static void __exit uwire_exit(void)
+{
+	u_long flags;
+
+	spin_lock_irqsave(&lck, flags);
+	uwire_clock_stop();
+	spin_unlock_irqrestore(&lck, flags);
+
+	uwire_init_flag = 1;
+
+	return;
+}
+
+arch_initcall(uwire_init);
+module_exit(uwire_exit);
diff --git a/arch/arm/mach-mp200/uwire.h b/arch/arm/mach-mp200/uwire.h
new file mode 100644
index 0000000..cbe0a7a
--- /dev/null
+++ b/arch/arm/mach-mp200/uwire.h
@@ -0,0 +1,88 @@
+/*
+ *  File Name       : linux/arch/arm/mach-mp200/uwire.h
+ *  Function        : uwire
+ *  Release Version : Ver 1.00
+ *  Release Date    : 2005/05/16
+ *
+ *  Copyright (C) NEC Electronics Corporation 2005
+ *
+ *
+ *  This program is free software;you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License as published by Free
+ *  Softwere Foundation; either version 2 of License, or (at your option) any
+ *  later version.
+ *
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warrnty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; If not, write to the Free Software Foundation, Inc., 59
+ *  Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#ifndef __ARCH_ARM_MACH_MP200_UWIRE_H
+#define __ARCH_ARM_MACH_MP200_UWIRE_H
+
+#include <linux/delay.h>
+
+#define UWIRE_MAX_WAIT	((loops_per_jiffy / 200) + 1)	/* wait for ready */
+#define UWIRE_MAX_BIT_LEN	32
+#define UWIRE_BIT_RX_SHIFT	24
+#define UWIRE_BIT_DTX_SHIFT	8
+
+/*
+ * devide value of PLL,OSC12M those supply clock
+ * recommended value is quarter clock(current 12M) of PWC(FPGA)
+ * * if clock is big, there is potential messing clock up
+ */
+
+/*
+ * address
+ */
+#define MWI_ADDRESS		MP200_MWI_BASE
+
+/* MWI_CONT */
+#define CS1_EN			(1U<<5)
+#define CS0_EN			(1U<<4)
+#define CS1			(1U<<3)	/* active value of CS1 is 1 */
+#define CS0			(1U<<2)	/* active value of CS0 is 1 */
+
+/*
+ * MWI
+ */
+
+#define MWI_CONT		(IO_ADDRESS(MWI_ADDRESS) + 0x00)
+#define MWI_CS0			(IO_ADDRESS(MWI_ADDRESS) + 0x04)
+#define MWI_CS1			(IO_ADDRESS(MWI_ADDRESS) + 0x08)
+#define MWI_START		(IO_ADDRESS(MWI_ADDRESS) + 0x0C)
+#define MWI_INTSTATUS		(IO_ADDRESS(MWI_ADDRESS) + 0x20)
+#define MWI_INTRAW		(IO_ADDRESS(MWI_ADDRESS) + 0x24)
+#define MWI_INTFFCLR		(IO_ADDRESS(MWI_ADDRESS) + 0x28)
+#define MWI_INTENSET		(IO_ADDRESS(MWI_ADDRESS) + 0x2C)
+#define MWI_INTENCLR		(IO_ADDRESS(MWI_ADDRESS) + 0x30)
+#define MWI_TXQA		(IO_ADDRESS(MWI_ADDRESS) + 0x40)
+#define MWI_TXQ			(IO_ADDRESS(MWI_ADDRESS) + 0x50)
+#define MWI_RXQ			(IO_ADDRESS(MWI_ADDRESS) + 0x60)
+
+/* MWI_CS */
+#define MWI_EDGE		(0x01)	/* RX_EDGE(up) | TX_EDGE(down) */
+
+/* read : BITRX_EN | BITATX_EN | BIT_ATX(8) | RX_EN | TX_EN */
+#define MWI_SEQUENTIAL_MODE	(0x20270003)
+/* write : BITATX_EN | BIT_ATX(8) | BITDTX_EN | TX_EN */
+#define MWI_PACKAGE_MODE	(0x00272001)
+/* read-write : BITRX_EN | BITDTX_EN | RX_EN | TX_EN */
+#define MWI_SIMULTANEOUS_MODE	(0x20002003)
+
+/* Used for MWI_INTFFCLR */
+#define MWI_FFCLR		1	/* Interrupts Clear */
+
+/* Used for MWI_START */
+#define MWI_START_FLAG		1	/* Transmit Start */
+
+/* Ued for MWI_INTRAW */
+#define MWI_RAW			1	/* Interrupts Data Outbreak */
+#endif				/* ARCH_ARM_MACH_MP200_UWIRE_H */
-- 
1.6.5.2

