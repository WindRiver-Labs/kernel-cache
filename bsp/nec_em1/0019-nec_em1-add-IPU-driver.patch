From 9908235363505841617dded4e15a92174f84382c Mon Sep 17 00:00:00 2001
From: Kazuya Tsukamoto <kazuya.tsukamoto@necel.com>
Date: Mon, 9 Nov 2009 12:24:52 +0900
Subject: [PATCH 19/29] nec_em1: add IPU driver

Add the em1 specific ipu driver.

Signed-off-by: Kazuya Tsukamoto <kazuya.tsukamoto@necel.com>
---
 arch/arm/mach-mp200/include/mach/gdma.h     |  705 ++++++
 arch/arm/mach-mp200/include/mach/img.h      | 1101 +++++++++
 arch/arm/mach-mp200/include/mach/ipu.h      |  170 ++
 arch/arm/mach-mp200/include/mach/ipu_user.h |  410 ++++
 arch/arm/mach-mp200/include/mach/mmu.h      |  206 ++
 arch/arm/mach-mp200/include/mach/rot.h      |  729 ++++++
 drivers/ipu/Kconfig                         |   21 +
 drivers/ipu/Makefile                        |    7 +
 drivers/ipu/mp200_img_convert.h             | 1781 +++++++++++++++
 drivers/ipu/mp200_ipu.c                     | 3240 +++++++++++++++++++++++++++
 drivers/ipu/mp200_ipu.h                     |  319 +++
 drivers/ipu/mp200_ipu_user.c                |  603 +++++
 drivers/ipu/mp200_rot_rotation.h            |  672 ++++++
 13 files changed, 9964 insertions(+), 0 deletions(-)
 create mode 100644 arch/arm/mach-mp200/include/mach/gdma.h
 create mode 100644 arch/arm/mach-mp200/include/mach/img.h
 create mode 100644 arch/arm/mach-mp200/include/mach/ipu.h
 create mode 100644 arch/arm/mach-mp200/include/mach/ipu_user.h
 create mode 100644 arch/arm/mach-mp200/include/mach/mmu.h
 create mode 100644 arch/arm/mach-mp200/include/mach/rot.h
 create mode 100644 drivers/ipu/Kconfig
 create mode 100644 drivers/ipu/Makefile
 create mode 100644 drivers/ipu/mp200_img_convert.h
 create mode 100644 drivers/ipu/mp200_ipu.c
 create mode 100644 drivers/ipu/mp200_ipu.h
 create mode 100644 drivers/ipu/mp200_ipu_user.c
 create mode 100644 drivers/ipu/mp200_rot_rotation.h

diff --git a/arch/arm/mach-mp200/include/mach/gdma.h b/arch/arm/mach-mp200/include/mach/gdma.h
new file mode 100644
index 0000000..fb98c77
--- /dev/null
+++ b/arch/arm/mach-mp200/include/mach/gdma.h
@@ -0,0 +1,705 @@
+/*
+*  File Name       : /include/asm-arm/arch-mp200/GDMA.h
+*  Function        : DMA MMIO definitions, and Driver - Driver I/F of IPU driver
+*  Release Version : Ver 1.00
+*  Release Date    : 2006/11/20
+*
+*  Copyright (C) NEC Electronics Corporation 2006
+*
+*
+*  This program is free software;you can redistribute it and/or modify
+*  it under the terms of the GNU General Public License as published by
+*  Free Softwere Foundation; either version 2 of License,
+*  or (at your option) any later version.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY;
+*  without even the implied warrnty of MERCHANTABILITY or
+*  FITNESS FOR A PARTICULAR PURPOSE.
+*  See the GNU General Public License for more details.
+*
+*  You should have received a copy of the GNU General Public License
+*  along with this program;
+*  If not, write to the Free Software Foundation,
+*  Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+*
+*/
+
+/* History */
+/*-----------+------+------------------+-------------------+--------------*/
+/* Date      |Rev.No|Name              |KeyWord            | Reason       */
+/*-----------+------+------------------+-------------------+--------------*/
+/* 2006/11/20| 1.00 | M.Sasaki         |                   |              */
+/*-----------+------+------------------+-------------------+--------------*/
+/* 2008/03/13|      | M.Sasaki         |                   |              */
+/*-----------+------+------------------+-------------------+--------------*/
+
+#ifndef _DMA_H_
+#define _DMA_H_
+
+
+/*===============================================================*/
+/* GDMA MMIO definitions   for uPD77601                          */
+/*===============================================================*/
+#include <mach/hardware.h>
+#define GDMA_OFFSET    MP200_IPUDMA_OFFSET
+#define GDMA_BASE      MP200_IPUDMA_BASE
+#define GDMA_SIZE      MP200_IPUDMA_SIZE
+
+
+/*===============================================================*/
+/* DMA register definitions   for uPD77601                       */
+/*===============================================================*/
+/*                                                  R/W   Bit  Reset */
+/* Mode for DMA                                     R/W   7:0  0x00 */
+#define DMA_MODE                 (0x00)
+
+/* DMA Request                                       W    0:0  0x0 */
+#define DMA_REQ                  (0x04)
+
+/* Current Processing Status                         R    0:0  0x0 */
+#define DMA_ACK                  (0x08)
+
+/* Status for DMA                                    R    8:0  0x0 */
+#define DMA_STATUS               (0x0C)
+
+/* Interuppt Raw Status                              R    8:0  0x0 */
+#define DMA_RAWSTATUS            (0x10)
+
+/* Interuppt Enable Set                             R/W   8:0  0x0 */
+#define DMA_ENSET                (0x14)
+
+/* Interuppt Enable Clear                            W    8:0  0x0 */
+#define DMA_ENCLR                (0x18)
+
+/* Interuppt FF Clear                                W    8:0  0x0 */
+#define DMA_FFCLR                (0x1C)
+
+/* Address increment value for the source1 image    R/W  14:0  0x000 */
+#define DMA_SRCSIZE_1            (0x20)
+
+/* Address increment value for the source2 image    R/W  14:0  0x000 */
+#define DMA_SRCSIZE_2            (0x24)
+
+/* Address increment value for the destination imageR/W  14:0  0x000 */
+#define DMA_DSTSIZE              (0x28)
+
+/* Y/RGB Plane Address for the source1 image        R/W  31:0  0x0000_0000 */
+#define DMA_SRCYRGBADR_1         (0x30)
+
+/* Y/RGB Plane Address for the source2 image        R/W  31:0  0x0000_0000 */
+#define DMA_SRCYRGBADR_2         (0x34)
+
+/* Y/RGB Plane Address for the destination image    R/W  31:0  0x0000_0000 */
+#define DMA_DSTYRGBADR           (0x38)
+
+/* UV Plane Address for the source1 image           R/W  31:0  0x0000_0000 */
+#define DMA_SRCUVADR_1           (0x40)
+
+/* UV Plane Address for the source2 image           R/W  31:0  0x0000_0000 */
+#define DMA_SRCUVADR_2           (0x44)
+
+/* UV Plane Address for the destination image       R/W  31:0  0x0000_0000 */
+#define DMA_DSTUVADR             (0x48)
+
+/* V Plane Address for the source1 image            R/W  31:0  0x0000_0000 */
+#define DMA_SRCVADR_1            (0x50)
+
+/* V Plane Address for the source2 image            R/W  31:0  0x0000_0000 */
+#define DMA_SRCVADR_2            (0x54)
+
+/* V Plane Address for the destination image        R/W  31:0  0x0000_0000 */
+#define DMA_DSTVADR              (0x58)
+
+/* Horizontal size for output image                 R/W  12:0  0x008 */
+#define DMA_HSIZE                (0x60)
+
+/* Vartical size for output image                   R/W  12:0  0x008 */
+#define DMA_VSIZE                (0x64)
+
+/* Mask Color                                       R/W  23  0x0000 */
+#define DMA_MASKCOLR             (0x68)
+
+/* Painting out data                                R/W  31:0  0x0000 */
+#define DMA_FILLDATA             (0x6C)
+
+/* Image format                                     R/W  11:0  0x0000 */
+#define DMA_FORMAT               (0x70)
+
+/* BYTE lane for the source1 image                  R/W   7:0  0xE4 */
+#define DMA_SRCBYTE_1            (0x74)
+
+/* BYTE lane for the source2 image                  R/W   7:0  0xE4 */
+#define DMA_SRCBYTE_2            (0x78)
+
+/* BYTE lane for the destination image              R/W   7:0  0xE4 */
+#define DMA_DSTBYTE              (0x7C)
+
+/* Register update reservation setting              R/W   0:0  0x0000 */
+#define DMA_DUAL_FF              (0x80)
+
+/* BYTE lane for the source1 image                  R/W  15:0  0xE4E4 */
+#define DMA_SRCBYTE_1_CMP        (0x90)
+
+/* BYTE lane for the source2 image                  R/W  15:0  0xE4E4 */
+#define DMA_SRCBYTE_2_CMP        (0x94)
+
+/* BYTE lane for the destination image              R/W  15:0  0xE4E4 */
+#define DMA_DSTBYTE_CMP          (0x98)
+
+/* Auto Scan                                        R/W  25:0  0x0 */
+#define DMA_AUTO_SCAN            (0xA0)
+
+
+/*===============================================================*/
+/* DMA register bit assigns                                      */
+/*===============================================================*/
+
+/*------------------------------*/
+/* DMA_MODE                     */
+/*------------------------------*/
+#define DMA_MASKOBJ_BIT         0x00000080
+#define DMA_MASKOBJ_SFT         0x7
+#define DMA_MASKOBJ_SRC1        0x00000000
+#define DMA_MASKOBJ_SRC2        0x00000080
+
+#define DMA_KEY_BIT             0x00000040
+#define DMA_KEY_SFT             0x6
+#define DMA_KEY_MASK_OFF        0x00000000
+#define DMA_KEY_MASK_ON         0x00000040
+
+#define DMA_OP_BIT              0x00000030
+#define DMA_OP_SFT              0x4
+#define DMA_OP_FILL             0x00000000
+#define DMA_OP_ROP              0x00000020
+
+#define DMA_ROP_BIT             0x0000000F
+#define DMA_ROP_SFT             0x0
+#define DMA_ROP_ALL0            0x00000000
+#define DMA_ROP_SRC1_NOR_SRC2   0x00000001
+#define DMA_ROP_NSRC1_AND_SRC2  0x00000002
+#define DMA_ROP_NSRC1           0x00000003
+#define DMA_ROP_SRC1_AND_NSRC2  0x00000004
+#define DMA_ROP_NSRC2           0x00000005
+#define DMA_ROP_SRC1_XOR_SRC2   0x00000006
+#define DMA_ROP_SRC1_NAND_SRC2  0x00000007
+#define DMA_ROP_SRC1_AND_SRC2   0x00000008
+#define DMA_ROP_SRC1_XNOR_SRC2  0x00000009
+#define DMA_ROP_SRC2            0x0000000A
+#define DMA_ROP_NSRC1_OR_SRC2   0x0000000B
+#define DMA_ROP_SRC1            0x0000000C
+#define DMA_ROP_SRC1_OR_NSRC2   0x0000000D
+#define DMA_ROP_SRC1_OR_SRC2    0x0000000E
+#define DMA_ROP_ALL1            0x0000000F
+
+
+/*------------------------------*/
+/* DMA_REQ                      */
+/*------------------------------*/
+#define DMA_REQ_BIT             0x00000001
+#define DMA_REQ_SFT             0x0
+
+
+/*------------------------------*/
+/* DMA_ACK                      */
+/*------------------------------*/
+#define DMA_ACK_BIT             0x00000001
+#define DMA_ACK_SFT             0x0
+
+
+/*------------------------------*/
+/* DMA_STATUS                   */
+/*------------------------------*/
+#define DMA_AHBERR_BIT          0x00000100
+#define DMA_AHBERR_SFT          0x8
+
+#define DMA_ACTIVE_BIT          0x00000004
+#define DMA_ACTIVE_SFT          0x2
+
+#define DMA_DFF_RSV_BIT         0x00000002
+#define DMA_DFF_RSV_SFT         0x1
+
+#define DMA_STAT_BIT            0x00000001
+#define DMA_STAT_SFT            0x0
+
+
+/*------------------------------*/
+/* DMA_RAWSTATUS                */
+/*------------------------------*/
+#define DMA_RAWAHBERR_BIT       0x00000100
+#define DMA_RAWAHBERR_SFT       0x8
+
+#define DMA_RAWSTAT_BIT         0x00000001
+#define DMA_RAWSTAT_SFT         0x0
+
+
+/*------------------------------*/
+/* DMA_ENSET                    */
+/*------------------------------*/
+#define DMA_ENSETAHBERR_BIT     0x00000100
+#define DMA_ENSETAHBERR_SFT     0x8
+
+#define DMA_ENSETSTAT_BIT       0x00000001
+#define DMA_ENSETSTAT_SFT       0x0
+
+
+/*------------------------------*/
+/* DMA_ENCLR                    */
+/*------------------------------*/
+#define DMA_ENCLRAHBERR_BIT     0x00000100
+#define DMA_ENCLRAHBERR_SFT     0x8
+
+#define DMA_ENCLRSTAT_BIT       0x00000001
+#define DMA_ENCLRSTAT_SFT       0x0
+
+
+/*------------------------------*/
+/* DMA_FFCLR                    */
+/*------------------------------*/
+#define DMA_FFCLRAHBERR_BIT     0x00000100
+#define DMA_FFCLRAHBERR_SFT     0x8
+
+#define DMA_FFCLRSTAT_BIT       0x00000001
+#define DMA_FFCLRSTAT_SFT       0x0
+
+
+/*------------------------------*/
+/* DMA_SRCSIZE_1                */
+/*------------------------------*/
+#define DMA_SRCSIZE_1_BIT       0x00007FFF
+#define DMA_SRCSIZE_1_SFT       0x00
+
+
+/*------------------------------*/
+/* DMA_SRCSIZE_2                */
+/*------------------------------*/
+#define DMA_SRCSIZE_2_BIT       0x00007FFF
+#define DMA_SRCSIZE_2_SFT       0x00
+
+
+/*------------------------------*/
+/* DMA_DSTSIZE                  */
+/*------------------------------*/
+#define DMA_DSTSIZE_BIT         0x00007FFF
+#define DMA_DSTSIZE_SFT         0x00
+
+
+/*------------------------------*/
+/* DMA_SRCYRGBADR_1             */
+/*------------------------------*/
+#define DMA_SRCYRGBADR_1_BIT    0xFFFFFFFF
+#define DMA_SRCYRGBADR_1_SFT    0x00
+
+
+/*------------------------------*/
+/* DMA_SRCYRGBADR_2             */
+/*------------------------------*/
+#define DMA_SRCYRGBADR_2_BIT    0xFFFFFFFF
+#define DMA_SRCYRGBADR_2_SFT    0x00
+
+
+/*------------------------------*/
+/* DMA_DSTYRGBADR               */
+/*------------------------------*/
+#define DMA_DSTYRGBADR_BIT      0xFFFFFFFF
+#define DMA_DSTYRGBADR_SFT      0x00
+
+
+/*------------------------------*/
+/* DMA_SRCUVADR_1               */
+/*------------------------------*/
+#define DMA_SRCUVADR_1_BIT      0xFFFFFFFF
+#define DMA_SRCUVADR_1_SFT      0x00
+
+
+/*------------------------------*/
+/* DMA_SRCUVADR_2               */
+/*------------------------------*/
+#define DMA_SRCUVADR_2_BIT      0xFFFFFFFF
+#define DMA_SRCUVADR_2_SFT      0x00
+
+
+/*------------------------------*/
+/* DMA_DSTUVADR                 */
+/*------------------------------*/
+#define DMA_DSTUVADR_BIT        0xFFFFFFFF
+#define DMA_DSTUVADR_SFT        0x00
+
+
+/*------------------------------*/
+/* DMA_SRCVADR_1                */
+/*------------------------------*/
+#define DMA_SRCVBADR_1_BIT      0xFFFFFFFF
+#define DMA_SRCVADR_1_SFT       0x00
+
+
+/*------------------------------*/
+/* DMA_SRCVADR_2                */
+/*------------------------------*/
+#define DMA_SRCVADR_2_BIT       0xFFFFFFFF
+#define DMA_SRCVADR_2_SFT       0x00
+
+
+/*------------------------------*/
+/* DMA_DSTVRGBADR               */
+/*------------------------------*/
+#define DMA_DSTVADR_BIT         0xFFFFFFFF
+#define DMA_DSTVADR_SFT         0x00
+
+
+/*------------------------------*/
+/* DMA_HSIZE                    */
+/*------------------------------*/
+#define DMA_HSIZE_BIT           0x00001FFF
+#define DMA_HSIZE_SFT           0x00
+
+
+/*------------------------------*/
+/* DMA_VSIZE                    */
+/*------------------------------*/
+#define DMA_VSIZE_BIT           0x00001FFF
+#define DMA_VSIZE_SFT           0x00
+
+
+/*------------------------------*/
+/* DMA_MASKCOLR                 */
+/*------------------------------*/
+#define DMA_MASKCOLR_BIT        0x00FFFFFF
+#define DMA_MASKCOLR_SFT        0x00
+
+
+/*------------------------------*/
+/* DMA_FORMAT                   */
+/*------------------------------*/
+#define DMA_FORMAT_BIT                  0x0000000F
+#define DMA_FORMAT_SFT                  0x0
+#define DMA_FORMAT_RGB888               0x00000000
+#define DMA_FORMAT_RGB666               0x00000001
+#define DMA_FORMAT_RGB565               0x00000002
+#define DMA_FORMAT_YUV420_PLANAR        0x00000004
+#define DMA_FORMAT_YUV420_SEMI_PLANAR   0x00000005
+#define DMA_FORMAT_YUV422_PLANAR        0x00000008
+#define DMA_FORMAT_YUV422_SEMI_PLANAR   0x00000009
+#define DMA_FORMAT_YUV422_INTERLEAVE    0x0000000A
+
+
+/*------------------------------*/
+/* BYTELANE                     */
+/* (temporary declaration)      */
+/*------------------------------*/
+#define DMA_BYTELANE_DATAx_BYTE0   0x0
+#define DMA_BYTELANE_DATAx_BYTE1   0x1
+#define DMA_BYTELANE_DATAx_BYTE2   0x2
+#define DMA_BYTELANE_DATAx_BYTE3   0x3
+
+/*------------------------------*/
+/* DMA_SRCBYTE_1                */
+/*------------------------------*/
+#define DMA_SRCBYTE_1_DATA3_BIT 0x000000C0
+#define DMA_SRCBYTE_1_DATA3_SFT 0x6
+#define DMA_SRCBYTE_1_DATA3_BYTE0 \
+	(DMA_BYTELANE_DATAx_BYTE0 << DMA_SRCBYTE_1_DATA3_SFT)
+#define DMA_SRCBYTE_1_DATA3_BYTE1 \
+	(DMA_BYTELANE_DATAx_BYTE1 << DMA_SRCBYTE_1_DATA3_SFT)
+#define DMA_SRCBYTE_1_DATA3_BYTE2 \
+	(DMA_BYTELANE_DATAx_BYTE2 << DMA_SRCBYTE_1_DATA3_SFT)
+#define DMA_SRCBYTE_1_DATA3_BYTE3 \
+	(DMA_BYTELANE_DATAx_BYTE3 << DMA_SRCBYTE_1_DATA3_SFT)
+
+#define DMA_SRCBYTE_1_DATA2_BIT 0x00000030
+#define DMA_SRCBYTE_1_DATA2_SFT 0x4
+#define DMA_SRCBYTE_1_DATA2_BYTE0 \
+	(DMA_BYTELANE_DATAx_BYTE0 << DMA_SRCBYTE_1_DATA2_SFT)
+#define DMA_SRCBYTE_1_DATA2_BYTE1 \
+	(DMA_BYTELANE_DATAx_BYTE1 << DMA_SRCBYTE_1_DATA2_SFT)
+#define DMA_SRCBYTE_1_DATA2_BYTE2 \
+	(DMA_BYTELANE_DATAx_BYTE2 << DMA_SRCBYTE_1_DATA2_SFT)
+#define DMA_SRCBYTE_1_DATA2_BYTE3 \
+	(DMA_BYTELANE_DATAx_BYTE3 << DMA_SRCBYTE_1_DATA2_SFT)
+
+#define DMA_SRCBYTE_1_DATA1_BIT 0x0000000C
+#define DMA_SRCBYTE_1_DATA1_SFT 0x2
+#define DMA_SRCBYTE_1_DATA1_BYTE0 \
+	(DMA_BYTELANE_DATAx_BYTE0 << DMA_SRCBYTE_1_DATA1_SFT)
+#define DMA_SRCBYTE_1_DATA1_BYTE1 \
+	(DMA_BYTELANE_DATAx_BYTE1 << DMA_SRCBYTE_1_DATA1_SFT)
+#define DMA_SRCBYTE_1_DATA1_BYTE2 \
+	(DMA_BYTELANE_DATAx_BYTE2 << DMA_SRCBYTE_1_DATA1_SFT)
+#define DMA_SRCBYTE_1_DATA1_BYTE3 \
+	(DMA_BYTELANE_DATAx_BYTE3 << DMA_SRCBYTE_1_DATA1_SFT)
+
+#define DMA_SRCBYTE_1_DATA0_BIT 0x00000003
+#define DMA_SRCBYTE_1_DATA0_SFT 0x0
+#define DMA_SRCBYTE_1_DATA0_BYTE0 \
+	(DMA_BYTELANE_DATAx_BYTE0 << DMA_SRCBYTE_1_DATA0_SFT)
+#define DMA_SRCBYTE_1_DATA0_BYTE1 \
+	(DMA_BYTELANE_DATAx_BYTE1 << DMA_SRCBYTE_1_DATA0_SFT)
+#define DMA_SRCBYTE_1_DATA0_BYTE2 \
+	(DMA_BYTELANE_DATAx_BYTE2 << DMA_SRCBYTE_1_DATA0_SFT)
+#define DMA_SRCBYTE_1_DATA0_BYTE3 \
+	(DMA_BYTELANE_DATAx_BYTE3 << DMA_SRCBYTE_1_DATA0_SFT)
+
+
+/*------------------------------*/
+/* DMA_SRCBYTE_2                */
+/*------------------------------*/
+#define DMA_SRCBYTE_2_DATA3_BIT 0x000000C0
+#define DMA_SRCBYTE_2_DATA3_SFT 0x6
+#define DMA_SRCBYTE_2_DATA3_BYTE0 \
+	(DMA_BYTELANE_DATAx_BYTE0 << DMA_SRCBYTE_2_DATA3_SFT)
+#define DMA_SRCBYTE_2_DATA3_BYTE1 \
+	(DMA_BYTELANE_DATAx_BYTE1 << DMA_SRCBYTE_2_DATA3_SFT)
+#define DMA_SRCBYTE_2_DATA3_BYTE2 \
+	(DMA_BYTELANE_DATAx_BYTE2 << DMA_SRCBYTE_2_DATA3_SFT)
+#define DMA_SRCBYTE_2_DATA3_BYTE3 \
+	(DMA_BYTELANE_DATAx_BYTE3 << DMA_SRCBYTE_2_DATA3_SFT)
+
+#define DMA_SRCBYTE_2_DATA2_BIT 0x00000030
+#define DMA_SRCBYTE_2_DATA2_SFT 0x4
+#define DMA_SRCBYTE_2_DATA2_BYTE0 \
+	(DMA_BYTELANE_DATAx_BYTE0 << DMA_SRCBYTE_2_DATA2_SFT)
+#define DMA_SRCBYTE_2_DATA2_BYTE1 \
+	(DMA_BYTELANE_DATAx_BYTE1 << DMA_SRCBYTE_2_DATA2_SFT)
+#define DMA_SRCBYTE_2_DATA2_BYTE2 \
+	(DMA_BYTELANE_DATAx_BYTE2 << DMA_SRCBYTE_2_DATA2_SFT)
+#define DMA_SRCBYTE_2_DATA2_BYTE3 \
+	(DMA_BYTELANE_DATAx_BYTE3 << DMA_SRCBYTE_2_DATA2_SFT)
+
+#define DMA_SRCBYTE_2_DATA1_BIT 0x0000000C
+#define DMA_SRCBYTE_2_DATA1_SFT 0x2
+#define DMA_SRCBYTE_2_DATA1_BYTE0 \
+	(DMA_BYTELANE_DATAx_BYTE0 << DMA_SRCBYTE_2_DATA1_SFT)
+#define DMA_SRCBYTE_2_DATA1_BYTE1 \
+	(DMA_BYTELANE_DATAx_BYTE1 << DMA_SRCBYTE_2_DATA1_SFT)
+#define DMA_SRCBYTE_2_DATA1_BYTE2 \
+	(DMA_BYTELANE_DATAx_BYTE2 << DMA_SRCBYTE_2_DATA1_SFT)
+#define DMA_SRCBYTE_2_DATA1_BYTE3 \
+	(DMA_BYTELANE_DATAx_BYTE3 << DMA_SRCBYTE_2_DATA1_SFT)
+
+#define DMA_SRCBYTE_2_DATA0_BIT 0x00000003
+#define DMA_SRCBYTE_2_DATA0_SFT 0x0
+#define DMA_SRCBYTE_2_DATA0_BYTE0 \
+	(DMA_BYTELANE_DATAx_BYTE0 << DMA_SRCBYTE_2_DATA0_SFT)
+#define DMA_SRCBYTE_2_DATA0_BYTE1 \
+	(DMA_BYTELANE_DATAx_BYTE1 << DMA_SRCBYTE_2_DATA0_SFT)
+#define DMA_SRCBYTE_2_DATA0_BYTE2 \
+	(DMA_BYTELANE_DATAx_BYTE2 << DMA_SRCBYTE_2_DATA0_SFT)
+#define DMA_SRCBYTE_2_DATA0_BYTE3 \
+	(DMA_BYTELANE_DATAx_BYTE3 << DMA_SRCBYTE_2_DATA0_SFT)
+
+
+/*------------------------------*/
+/* DMA_DSTBYTE                  */
+/*------------------------------*/
+#define DMA_DSTBYTE_DATA3_BIT 0x000000C0
+#define DMA_DSTBYTE_DATA3_SFT 0x6
+#define DMA_DSTBYTE_DATA3_BYTE0 \
+	(DMA_BYTELANE_DATAx_BYTE0 << DMA_DSTBYTE_DATA3_SFT)
+#define DMA_DSTBYTE_DATA3_BYTE1 \
+	(DMA_BYTELANE_DATAx_BYTE1 << DMA_DSTBYTE_DATA3_SFT)
+#define DMA_DSTBYTE_DATA3_BYTE2 \
+	(DMA_BYTELANE_DATAx_BYTE2 << DMA_DSTBYTE_DATA3_SFT)
+#define DMA_DSTBYTE_DATA3_BYTE3 \
+	(DMA_BYTELANE_DATAx_BYTE3 << DMA_DSTBYTE_DATA3_SFT)
+
+#define DMA_DSTBYTE_DATA2_BIT 0x00000030
+#define DMA_DSTBYTE_DATA2_SFT 0x4
+#define DMA_DSTBYTE_DATA2_BYTE0 \
+	(DMA_BYTELANE_DATAx_BYTE0 << DMA_DSTBYTE_DATA2_SFT)
+#define DMA_DSTBYTE_DATA2_BYTE1 \
+	(DMA_BYTELANE_DATAx_BYTE1 << DMA_DSTBYTE_DATA2_SFT)
+#define DMA_DSTBYTE_DATA2_BYTE2 \
+	(DMA_BYTELANE_DATAx_BYTE2 << DMA_DSTBYTE_DATA2_SFT)
+#define DMA_DSTBYTE_DATA2_BYTE3 \
+	(DMA_BYTELANE_DATAx_BYTE3 << DMA_DSTBYTE_DATA2_SFT)
+
+#define DMA_DSTBYTE_DATA1_BIT 0x0000000C
+#define DMA_DSTBYTE_DATA1_SFT 0x2
+#define DMA_DSTBYTE_DATA1_BYTE0 \
+	(DMA_BYTELANE_DATAx_BYTE0 << DMA_DSTBYTE_DATA1_SFT)
+#define DMA_DSTBYTE_DATA1_BYTE1 \
+	(DMA_BYTELANE_DATAx_BYTE1 << DMA_DSTBYTE_DATA1_SFT)
+#define DMA_DSTBYTE_DATA1_BYTE2 \
+	(DMA_BYTELANE_DATAx_BYTE2 << DMA_DSTBYTE_DATA1_SFT)
+#define DMA_DSTBYTE_DATA1_BYTE3 \
+	(DMA_BYTELANE_DATAx_BYTE3 << DMA_DSTBYTE_DATA1_SFT)
+
+#define DMA_DSTBYTE_DATA0_BIT 0x00000003
+#define DMA_DSTBYTE_DATA0_SFT 0x0
+#define DMA_DSTBYTE_DATA0_BYTE0 \
+	(DMA_BYTELANE_DATAx_BYTE0 << DMA_DSTBYTE_DATA0_SFT)
+#define DMA_DSTBYTE_DATA0_BYTE1 \
+	(DMA_BYTELANE_DATAx_BYTE1 << DMA_DSTBYTE_DATA0_SFT)
+#define DMA_DSTBYTE_DATA0_BYTE2 \
+	(DMA_BYTELANE_DATAx_BYTE2 << DMA_DSTBYTE_DATA0_SFT)
+#define DMA_DSTBYTE_DATA0_BYTE3 \
+	(DMA_BYTELANE_DATAx_BYTE3 << DMA_DSTBYTE_DATA0_SFT)
+
+
+/*------------------------------*/
+/* DMA_SRCBYTE_1_CMP            */
+/*------------------------------*/
+/* DMA_SRCBYTE_2_CMP            */
+/*------------------------------*/
+/* DMA_DSTBYTE_CMP              */
+/*------------------------------*/
+#define DMA_BYTE_DATA3_UV_BIT 0x0000C000
+#define DMA_BYTE_DATA3_UV_SFT 0xE
+#define DMA_BYTE_DATA3_UV_BYTE0 \
+	(DMA_BYTELANE_DATAx_BYTE0 << DMA_BYTE_DATA3_UV_SFT)
+#define DMA_BYTE_DATA3_UV_BYTE1 \
+	(DMA_BYTELANE_DATAx_BYTE1 << DMA_BYTE_DATA3_UV_SFT)
+#define DMA_BYTE_DATA3_UV_BYTE2 \
+	(DMA_BYTELANE_DATAx_BYTE2 << DMA_BYTE_DATA3_UV_SFT)
+#define DMA_BYTE_DATA3_UV_BYTE3 \
+	(DMA_BYTELANE_DATAx_BYTE3 << DMA_BYTE_DATA3_UV_SFT)
+
+#define DMA_BYTE_DATA2_UV_BIT 0x00003000
+#define DMA_BYTE_DATA2_UV_SFT 0xC
+#define DMA_BYTE_DATA2_UV_BYTE0 \
+	(DMA_BYTELANE_DATAx_BYTE0 << DMA_BYTE_DATA2_UV_SFT)
+#define DMA_BYTE_DATA2_UV_BYTE1 \
+	(DMA_BYTELANE_DATAx_BYTE1 << DMA_BYTE_DATA2_UV_SFT)
+#define DMA_BYTE_DATA2_UV_BYTE2 \
+	(DMA_BYTELANE_DATAx_BYTE2 << DMA_BYTE_DATA2_UV_SFT)
+#define DMA_BYTE_DATA2_UV_BYTE3 \
+	(DMA_BYTELANE_DATAx_BYTE3 << DMA_BYTE_DATA2_UV_SFT)
+
+#define DMA_BYTE_DATA1_UV_BIT 0x00000C00
+#define DMA_BYTE_DATA1_UV_SFT 0xA
+#define DMA_BYTE_DATA1_UV_BYTE0 \
+	(DMA_BYTELANE_DATAx_BYTE0 << DMA_BYTE_DATA1_UV_SFT)
+#define DMA_BYTE_DATA1_UV_BYTE1 \
+	(DMA_BYTELANE_DATAx_BYTE1 << DMA_BYTE_DATA1_UV_SFT)
+#define DMA_BYTE_DATA1_UV_BYTE2 \
+	(DMA_BYTELANE_DATAx_BYTE2 << DMA_BYTE_DATA1_UV_SFT)
+#define DMA_BYTE_DATA1_UV_BYTE3 \
+	(DMA_BYTELANE_DATAx_BYTE3 << DMA_BYTE_DATA1_UV_SFT)
+
+#define DMA_BYTE_DATA0_UV_BIT 0x00000300
+#define DMA_BYTE_DATA0_UV_SFT 0x8
+#define DMA_BYTE_DATA0_UV_BYTE0 \
+	(DMA_BYTELANE_DATAx_BYTE0 << DMA_BYTE_DATA0_UV_SFT)
+#define DMA_BYTE_DATA0_UV_BYTE1 \
+	(DMA_BYTELANE_DATAx_BYTE1 << DMA_BYTE_DATA0_UV_SFT)
+#define DMA_BYTE_DATA0_UV_BYTE2 \
+	(DMA_BYTELANE_DATAx_BYTE2 << DMA_BYTE_DATA0_UV_SFT)
+#define DMA_BYTE_DATA0_UV_BYTE3 \
+	(DMA_BYTELANE_DATAx_BYTE3 << DMA_BYTE_DATA0_UV_SFT)
+
+#define DMA_BYTE_DATA3_Y_BIT  0x000000C0
+#define DMA_BYTE_DATA3_Y_SFT  0x6
+#define DMA_BYTE_DATA3_Y_BYTE0 \
+	 (DMA_BYTELANE_DATAx_BYTE0 << DMA_BYTE_DATA3_Y_SFT)
+#define DMA_BYTE_DATA3_Y_BYTE1 \
+	 (DMA_BYTELANE_DATAx_BYTE1 << DMA_BYTE_DATA3_Y_SFT)
+#define DMA_BYTE_DATA3_Y_BYTE2 \
+	 (DMA_BYTELANE_DATAx_BYTE2 << DMA_BYTE_DATA3_Y_SFT)
+#define DMA_BYTE_DATA3_Y_BYTE3 \
+	 (DMA_BYTELANE_DATAx_BYTE3 << DMA_BYTE_DATA3_Y_SFT)
+
+#define DMA_BYTE_DATA2_Y_BIT  0x00000030
+#define DMA_BYTE_DATA2_Y_SFT  0x4
+#define DMA_BYTE_DATA2_Y_BYTE0 \
+	 (DMA_BYTELANE_DATAx_BYTE0 << DMA_BYTE_DATA2_Y_SFT)
+#define DMA_BYTE_DATA2_Y_BYTE1 \
+	 (DMA_BYTELANE_DATAx_BYTE1 << DMA_BYTE_DATA2_Y_SFT)
+#define DMA_BYTE_DATA2_Y_BYTE2 \
+	 (DMA_BYTELANE_DATAx_BYTE2 << DMA_BYTE_DATA2_Y_SFT)
+#define DMA_BYTE_DATA2_Y_BYTE3 \
+	 (DMA_BYTELANE_DATAx_BYTE3 << DMA_BYTE_DATA2_Y_SFT)
+
+#define DMA_BYTE_DATA1_Y_BIT  0x0000000C
+#define DMA_BYTE_DATA1_Y_SFT  0x2
+#define DMA_BYTE_DATA1_Y_BYTE0 \
+	 (DMA_BYTELANE_DATAx_BYTE0 << DMA_BYTE_DATA1_Y_SFT)
+#define DMA_BYTE_DATA1_Y_BYTE1 \
+	 (DMA_BYTELANE_DATAx_BYTE1 << DMA_BYTE_DATA1_Y_SFT)
+#define DMA_BYTE_DATA1_Y_BYTE2 \
+	 (DMA_BYTELANE_DATAx_BYTE2 << DMA_BYTE_DATA1_Y_SFT)
+#define DMA_BYTE_DATA1_Y_BYTE3 \
+	 (DMA_BYTELANE_DATAx_BYTE3 << DMA_BYTE_DATA1_Y_SFT)
+
+#define DMA_BYTE_DATA0_Y_BIT  0x00000003
+#define DMA_BYTE_DATA0_Y_SFT  0x0
+#define DMA_BYTE_DATA0_Y_BYTE0 \
+	 (DMA_BYTELANE_DATAx_BYTE0 << DMA_BYTE_DATA0_Y_SFT)
+#define DMA_BYTE_DATA0_Y_BYTE1 \
+	 (DMA_BYTELANE_DATAx_BYTE1 << DMA_BYTE_DATA0_Y_SFT)
+#define DMA_BYTE_DATA0_Y_BYTE2 \
+	 (DMA_BYTELANE_DATAx_BYTE2 << DMA_BYTE_DATA0_Y_SFT)
+#define DMA_BYTE_DATA0_Y_BYTE3 \
+	 (DMA_BYTELANE_DATAx_BYTE3 << DMA_BYTE_DATA0_Y_SFT)
+
+
+/*------------------------------*/
+/* DMA_FILLDATA                 */
+/*------------------------------*/
+#define DMA_FILL_DATA_BIT       0xFFFFFFFF
+#define DMA_FILL_DATA_SFT       0x00
+
+
+/*------------------------------*/
+/* DMA_DUAL_FF                  */
+/*------------------------------*/
+#define DMA_REG_EN_BIT          0x00000001
+#define DMA_REG_EN_SFT          0x00
+
+
+/*------------------------------*/
+/* DMA_AUTO_SCAN                */
+/*------------------------------*/
+#define DMA_AUTO_SCAN_SRC1_Y_BIT  0x03000000
+#define DMA_AUTO_SCAN_SRC1_Y_SFT  0x18
+#define DMA_AUTO_SCAN_SRC1_Y_0    0x00000000
+#define DMA_AUTO_SCAN_SRC1_Y_1    0x01000000
+#define DMA_AUTO_SCAN_SRC1_Y_2    0x02000000
+#define DMA_AUTO_SCAN_SRC1_Y_3    0x03000000
+
+#define DMA_AUTO_SCAN_SRC1_U_BIT  0x00300000
+#define DMA_AUTO_SCAN_SRC1_U_SFT  0x14
+#define DMA_AUTO_SCAN_SRC1_U_0    0x00000000
+#define DMA_AUTO_SCAN_SRC1_U_1    0x00100000
+#define DMA_AUTO_SCAN_SRC1_U_2    0x00200000
+#define DMA_AUTO_SCAN_SRC1_U_3    0x00300000
+
+#define DMA_AUTO_SCAN_SRC1_V_BIT  0x00030000
+#define DMA_AUTO_SCAN_SRC1_V_SFT  0x10
+#define DMA_AUTO_SCAN_SRC1_V_0    0x00000000
+#define DMA_AUTO_SCAN_SRC1_V_1    0x00010000
+#define DMA_AUTO_SCAN_SRC1_V_2    0x00020000
+#define DMA_AUTO_SCAN_SRC1_V_3    0x00030000
+
+#define DMA_AUTO_SCAN_SRC2_Y_BIT  0x00000300
+#define DMA_AUTO_SCAN_SRC2_Y_SFT  0x8
+#define DMA_AUTO_SCAN_SRC2_Y_0    0x00000000
+#define DMA_AUTO_SCAN_SRC2_Y_1    0x00000100
+#define DMA_AUTO_SCAN_SRC2_Y_2    0x00000200
+#define DMA_AUTO_SCAN_SRC2_Y_3    0x00000300
+
+#define DMA_AUTO_SCAN_SRC2_U_BIT  0x00000030
+#define DMA_AUTO_SCAN_SRC2_U_SFT  0x4
+#define DMA_AUTO_SCAN_SRC2_U_0    0x00000000
+#define DMA_AUTO_SCAN_SRC2_U_1    0x00000010
+#define DMA_AUTO_SCAN_SRC2_U_2    0x00000020
+#define DMA_AUTO_SCAN_SRC2_U_3    0x00000030
+
+#define DMA_AUTO_SCAN_SRC2_V_BIT  0x00000003
+#define DMA_AUTO_SCAN_SRC2_V_SFT  0x0
+#define DMA_AUTO_SCAN_SRC2_V_0    0x00000000
+#define DMA_AUTO_SCAN_SRC2_V_1    0x00000001
+#define DMA_AUTO_SCAN_SRC2_V_2    0x00000002
+#define DMA_AUTO_SCAN_SRC2_V_3    0x00000003
+
+
+/*===============================================================*/
+/* DMA register reset                                            */
+/*===============================================================*/
+#define DMA_MODE_RESET          0x00000000
+#define DMA_SRCBYTE_1_RESET     0x000000E4
+#define DMA_SRCBYTE_2_RESET     0x000000E4
+#define DMA_DSTBYTE_RESET       0x000000E4
+#define DMA_DUAL_FF_RESET       0x00000000
+#define DMA_AUTO_SCAN_RESET     0x02220222
+
+#endif /* _DMA_H_ */
diff --git a/arch/arm/mach-mp200/include/mach/img.h b/arch/arm/mach-mp200/include/mach/img.h
new file mode 100644
index 0000000..a414e2a
--- /dev/null
+++ b/arch/arm/mach-mp200/include/mach/img.h
@@ -0,0 +1,1101 @@
+/*
+*  File Name       : include/mach/img.h
+*  Function        : IMG MMIO definitions, and Driver - Driver I/F of IPU driver
+*  Release Version : Ver 1.01
+*  Release Date    : 2009/07/27
+*
+*  Copyright (C) NEC Electronics Corporation 2009
+*
+*
+*  This program is free software;you can redistribute it and/or modify it
+*  under the terms of the GNU General Public License as published by Free
+*  Softwere Foundation; either version 2 of License, or (at your option) any
+*  later version.
+*
+*  This program is distributed in the hope that it will be useful, but WITHOUT
+*  ANY WARRANTY; without even the implied warrnty of MERCHANTABILITY or
+*  FITNESS FOR A PARTICULAR PURPOSE.
+*  See the GNU General Public License for more details.
+*
+*  You should have received a copy of the GNU General Public License along
+*  with this program; If not, write to the Free Software Foundation, Inc., 59
+*  Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+*
+*/
+
+
+#ifndef _IMG_H_
+#define _IMG_H_
+
+/*===============================================================*/
+/* IMG MMIO definitions   for uPD77601                           */
+/*===============================================================*/
+#include <mach/hardware.h>
+
+#define IMAGEPROC_OFFSET    MP200_IMAGEPROC_OFFSET
+#define IMAGEPROC_BASE      MP200_IMAGEPROC_BASE
+#define IMAGEPROC_SIZE      MP200_IMAGEPROC_SIZE
+
+
+/*===============================================================*/
+/* IMG register definitions   for uPD77601                       */
+/*===============================================================*/
+/*                                                           R/W  Bit   Reset */
+/* Functions                                                 R/W  21:0  0x0 */
+#define IMG_MODE            (0x00)
+
+/* Request for Processing                                     W    0:0  0x0 */
+#define IMG_REQ             (0x04)
+
+/* Current Processing Status                                  R    0:0  0x0 */
+#define IMG_ACK             (0x08)
+
+/* Interuppt Status                                           R    5:0  0x0 */
+#define IMG_STATUS          (0x0C)
+
+/* Interuppt Raw Status                                       R    3:0  0x0 */
+#define IMG_RAWSTATUS       (0x10)
+
+/* Interuppt Enable Set                                      R/W   3:0  0x0 */
+#define IMG_ENSET           (0x14)
+
+/* Interuppt Enable Clear                                     W    3:0  0x0 */
+#define IMG_ENCLR           (0x18)
+
+/* Interuppt FF Clear                                         W    3:0  0x0 */
+#define IMG_FFCLR           (0x1C)
+
+/* Address increment value for the source back image         R/W  14:2  0x000 */
+#define IMG_SRCSIZE_B       (0x20)
+
+/* Address increment value for the source front image        R/W  14:2  0x000 */
+#define IMG_SRCSIZE_F       (0x24)
+
+/* Address increment value for the destination image         R/W  14:2  0x000 */
+#define IMG_DSTSIZE         (0x28)
+
+/* Y/RGB Plane Address for the source image		R/W 31:2  0x0000_0000 */
+#define IMG_SRCYRGBADR_B    (0x30)
+
+/* Y/RGB Plane Address for the source image		R/W 31:2  0x0000_0000 */
+#define IMG_SRCYRGBADR_F    (0x34)
+
+/* Y/RGB Plane Address for the destination image	R/W 31:2  0x0000_0000 */
+#define IMG_DSTYRGBADR      (0x38)
+
+/* UV Plane Address for the source image		R/W 31:2  0x0000_0000 */
+#define IMG_SRCUVADR_B      (0x40)
+
+/* UV Plane Address for the source image		R/W 31:2  0x0000_0000 */
+#define IMG_SRCUVADR_F      (0x44)
+
+/* UV Plane Address for the destination image		R/W 31:2  0x0000_0000 */
+#define IMG_DSTUVADR        (0x48)
+
+/* Horizontal size for the source image			R/W  12:0  0x008 */
+#define IMG_SRCHSIZE_B      (0x50)
+
+/* Horizontal size for the source image			R/W  12:0  0x008 */
+#define IMG_SRCHSIZE_F      (0x54)
+
+/* Vartical size of the source image			R/W  12:0  0x008 */
+#define IMG_SRCVSIZE_B      (0x58)
+
+/* Vartical size of the source image			R/W  12:0  0x008 */
+#define IMG_SRCVSIZE_F      (0x5C)
+
+/* Horizontal location offset				R/W  12:0  0x000 */
+#define IMG_OFFSETX         (0x60)
+
+/* Vertical location offset				R/W  12:0  0x000 */
+#define IMG_OFFSETY         (0x64)
+
+/* Mask Color						R/W  15:0  0x0000 */
+#define IMG_MASKCOLR        (0x68)
+
+/* Transpearency					R/W  7:0  0xFF */
+#define IMG_ALPHA           (0x6C)
+
+/* Horizontal size for output image			R/W  12:0  0x008 */
+#define IMG_DSTHSIZE        (0x70)
+
+/* Vartical size for output image			R/W  12:0  0x008 */
+#define IMG_DSTVSIZE        (0x74)
+
+/* Horizontal Enlargement and Reduction steps for resizing   R/W  13:0  0x100 */
+#define IMG_HSTEP           (0x78)
+
+/* Vertical Enlargement and Reducation steps for resizing    R/W  13:0  0x100 */
+#define IMG_VSTEP           (0x7C)
+
+/* Horizontal Enlargement and Reduction rate for resizing    R/W   8:0  0x40 */
+#define IMG_HFOLD           (0x80)
+
+/* Vertical Enlargement and Reducation rate for resizing     R/W   8:0  0x40 */
+#define IMG_VFOLD           (0x84)
+
+/* Pixel Endian Component				R/W   1:0  0x0 */
+#define IMG_PEL_ENDIAN      (0xAC)
+
+/* HADDR for debuging					R/W  31:0  0x0 */
+#define IMG_DBG_HADDR       (0xB0)
+
+/* Color Conversion Matrix Configuratin (RGB->YUV)	R/W   0:0  0x0 */
+#define IMG_RGBYUV_CONF     (0xC0)
+
+/* Color Conversion Matrix (RGB->YUV) 00 Component	R/W  11:0  0x04D */
+#define IMG_RGBYUV00        (0xC4)
+
+/* Color Conversion Matrix (RGB->YUV) 01 Component	R/W  11:0  0x096 */
+#define IMG_RGBYUV01        (0xC8)
+
+/* Color Conversion Matrix (RGB->YUV) 02 Component	R/W  11:0  0x01D */
+#define IMG_RGBYUV02        (0xCC)
+
+/* Color Conversion Matrix (RGB->YUV) 10 Component	R/W  11:0  0x82C */
+#define IMG_RGBYUV10        (0xD0)
+
+/* Color Conversion Matrix (RGB->YUV) 11 Component	R/W  11:0  0x857 */
+#define IMG_RGBYUV11        (0xD4)
+
+/* Color Conversion Matrix (RGB->YUV) 12 Component	R/W  11:0  0x083 */
+#define IMG_RGBYUV12        (0xD8)
+
+/* Color Conversion Matrix (RGB->YUV) 20 Component	R/W  11:0  0x083 */
+#define IMG_RGBYUV20        (0xDC)
+
+/* Color Conversion Matrix (RGB->YUV) 21 Component	R/W  11:0  0x86E */
+#define IMG_RGBYUV21        (0xE0)
+
+/* Color Conversion Matrix (RGB->YUV) 22 Component	R/W  11:0  0x815 */
+#define IMG_RGBYUV22        (0xE4)
+
+/* Color Conversion Matrix Configuratin (YUV->RGB)	R/W   0:0  0x0 */
+#define IMG_YUVRGB_CONF     (0xE8)
+
+/* Color Conversion Matrix (YUV->RGB) 00 Component	R/W  11:0  0x100 */
+#define IMG_YUVRGB00        (0xEC)
+
+/* Color Conversion Matrix (YUV->RGB) 01 Component	R/W  11:0  0x0 */
+#define IMG_YUVRGB01        (0xF0)
+
+/* Color Conversion Matrix (YUV->RGB) 02 Component	R/W  11:0  0x15F */
+#define IMG_YUVRGB02        (0xF4)
+
+/* Color Conversion Matrix (YUV->RGB) 10 Component	R/W  11:0  0x100 */
+#define IMG_YUVRGB10        (0xF8)
+
+/* Color Conversion Matrix (YUV->RGB) 11 Component	R/W  11:0  0x856 */
+#define IMG_YUVRGB11        (0xFC)
+
+/* Color Conversion Matrix (YUV->RGB) 12 Component	R/W  11:0  0x8B3 */
+#define IMG_YUVRGB12        (0x100)
+
+/* Color Conversion Matrix (YUV->RGB) 20 Component	R/W  11:0  0x100 */
+#define IMG_YUVRGB20        (0x104)
+
+/* Color Conversion Matrix (YUV->RGB) 21 Component	R/W  11:0  0x1BB */
+#define IMG_YUVRGB21        (0x108)
+
+/* Color Conversion Matrix (YUV->RGB) 22 Component	R/W  11:0  0x000 */
+#define IMG_YUVRGB22        (0x10C)
+
+/* Image format						R/W  11:0  0x0000 */
+#define IMG_FORMAT          (0x110)
+
+/* IN BYTE lane for the source image			R/W   7:0  0xE4 */
+#define IMG_INDATABYTE      (0x114)
+
+/* OUT BYTE lane for the destination image		R/W   7:0  0xE4 */
+#define IMG_OUTDATABYTE     (0x118)
+
+/* V Plane Address for the source image			R/W 31:2  0x0000_0000 */
+#define IMG_SRCVADR_B       (0x11C)
+
+/* V Plane Address for the source image			R/W 31:2  0x0000_0000 */
+#define IMG_SRCVADR_F       (0x120)
+
+/* V Plane Address for the destination image		R/W 31:2  0x0000_0000 */
+#define IMG_DSTVADR         (0x124)
+
+/* Register update reservation setting			R/W   0:0  0x0000 */
+#define IMG_DUAL_FF         (0x128)
+
+/* IN BYTE lane for the source back image		R/W  15:0  0xE4E4 */
+#define IMG_INDATABYTE_B_CMP (0x130)
+
+/* IN BYTE lane for the source front image		R/W  15:0  0xE4E4 */
+#define IMG_INDATABYTE_F_CMP (0x134)
+
+/* OUT BYTE lane for the destination image		R/W  15:0  0xE4E4 */
+#define IMG_OUTDATABYTE_CMP  (0x138)
+
+/* R BRITNESS set					R/W  10:0  0x00 */
+#define IMG_R_BRITNESS       (0x13C)
+
+/* G BRITNESS set					R/W  10:0  0x00 */
+#define IMG_G_BRITNESS       (0x140)
+
+/* B BRITNESS set					R/W  10:0  0x00 */
+#define IMG_B_BRITNESS       (0x144)
+
+
+
+/*===============================================================*/
+/* IMG register bit assigns                                      */
+/*===============================================================*/
+
+/*------------------------------*/
+/* IMG_MODE                     */
+/*------------------------------*/
+#define IMG_NEWEN_BIT           0x00100000
+#define IMG_NEWEN_SFT           20
+
+#define IMG_MASK_COL_BIT        0x00080000
+#define IMG_MASK_COL_SFT        19
+
+#define IMG_RLINV_BIT           0x00040000
+#define IMG_RLINV_SFT           18
+
+#define IMG_UDINV_BIT           0x00020000
+#define IMG_UDINV_SFT           17
+
+#define IMG_OP_MODE_00_BIT      0x00000000
+#define IMG_OP_MODE_01_BIT      0x00001000
+#define IMG_OP_MODE_02_BIT      0x00002000
+#define IMG_OP_MODE_03_BIT      0x00003000
+#define IMG_OP_MODE_04_BIT      0x00004000
+#define IMG_OP_MODE_05_BIT      0x00005000
+#define IMG_OP_MODE_06_BIT      0x00006000
+#define IMG_OP_MODE_07_BIT      0x00007000
+#define IMG_OP_MODE_08_BIT      0x00010200
+#define IMG_OP_MODE_09_BIT      0x00010500
+#define IMG_OP_MODE_10_BIT      0x00011300
+#define IMG_OP_MODE_11_BIT      0x00011400
+#define IMG_OP_MODE_12_BIT      0x00012000
+#define IMG_OP_MODE_13_BIT      0x00012700
+#define IMG_OP_MODE_14_BIT      0x00013100
+#define IMG_OP_MODE_15_BIT      0x00013600
+#define IMG_OP_MODE_16_BIT      0x00014100
+#define IMG_OP_MODE_17_BIT      0x00014600
+#define IMG_OP_MODE_18_BIT      0x00015000
+#define IMG_OP_MODE_19_BIT      0x00015700
+#define IMG_OP_MODE_20_BIT      0x00016300
+#define IMG_OP_MODE_21_BIT      0x00016400
+#define IMG_OP_MODE_22_BIT      0x00017200
+#define IMG_OP_MODE_23_BIT      0x00017500
+#define IMG_OP_MODE_24_BIT      0x00008000
+#define IMG_OP_MODE_25_BIT      0x00009000
+#define IMG_OP_MODE_26_BIT      0x0000a000
+
+#define IMG_OVERLAY_BIT         0x00010000
+#define IMG_OVERLAY_SFT         0x10
+
+#define IMG_OP_MODE_BIT         0x0001FF00
+#define IMG_OP_MODE_SFT         0x8
+
+#define IMG_OPB_BIT             0x0000F000
+#define IMG_OPB_SFT             0xC
+
+#define IMG_OPF_BIT             0x00000F00
+#define IMG_OPF_SFT             0x8
+
+#define IMG_RFILTER_B_BIT       0x00000080
+#define IMG_RFILTER_B_SFT       0x7
+
+#define IMG_RFILTER_F_BIT       0x00000040
+#define IMG_RFILTER_F_SFT       0x6
+
+#define IMG_PELPACK_BIT         0x00000020
+#define IMG_PELPACK_SFT         0x5
+
+#define IMG_DITHER_B_BIT        0x00000010
+#define IMG_DITHER_B_SFT        0x4
+
+#define IMG_DITHER_F_BIT        0x00000008
+#define IMG_DITHER_F_SFT        0x3
+
+#define IMG_DSTFMT_BIT          0x00000004
+#define IMG_DSTFMT_SFT          0x2
+
+#define IMG_SRCFMT_B_BIT        0x00000002
+#define IMG_SRCFMT_B_SFT        0x1
+
+#define IMG_SRCFMT_F_BIT        0x00000001
+#define IMG_SRCFMT_F_SFT        0x0
+
+
+/*------------------------------*/
+/* IMG_REQ                      */
+/*------------------------------*/
+#define IMG_REQ_BIT             0x00000001
+#define IMG_REQ_SFT             0x0
+
+
+/*------------------------------*/
+/* IMG_ACK                      */
+/*------------------------------*/
+#define IMG_ACK_BIT             0x00000001
+#define IMG_ACK_SFT             0x0
+
+
+/*------------------------------*/
+/* IMG_STATUS                   */
+/*------------------------------*/
+#define IMG_ACTIVE_BIT          0x00000020
+#define IMG_ACTIVE_SFT          0x5
+
+#define IMG_DFF_RSV_BIT         0x00000010
+#define IMG_DFF_RSV_SFT         0x4
+
+#define IMG_FLT_BIT             0x00000008
+#define IMG_FLT_SFT             0x3
+
+#define IMG_STOP_BIT            0x00000004
+#define IMG_STOP_SFT            0x2
+
+#define IMG_ERROR_BIT           0x00000002
+#define IMG_ERROR_SFT           0x1
+
+#define IMG_STAT_BIT            0x00000001
+#define IMG_STAT_SFT            0x0
+
+
+/*------------------------------*/
+/* IMG_RAWSTATUS                */
+/*------------------------------*/
+#define IMG_RAWFLT_BIT          0x00000008
+#define IMG_RAWFLT_SFT          0x3
+
+#define IMG_RAWSTOP_BIT         0x00000004
+#define IMG_RAWSTOP_SFT         0x2
+
+#define IMG_RAWERROR_BIT        0x00000002
+#define IMG_RAWERROR_SFT        0x1
+
+#define IMG_RAWSTAT_BIT         0x00000001
+#define IMG_RAWSTAT_SFT         0x0
+
+
+/*------------------------------*/
+/* IMG_ENSET                    */
+/*------------------------------*/
+#define IMG_ENSETFLT_BIT        0x00000008
+#define IMG_ENSETFLT_SFT        0x3
+
+#define IMG_ENSETSTOP_BIT       0x00000004
+#define IMG_ENSETSTOP_SFT       0x2
+
+#define IMG_ENSETERROR_BIT      0x00000002
+#define IMG_ENSETERROR_SFT      0x1
+
+#define IMG_ENSETSTAT_BIT       0x00000001
+#define IMG_ENSETSTAT_SFT       0x0
+
+
+/*------------------------------*/
+/* IMG_ENCLR                    */
+/*------------------------------*/
+#define IMG_ENCLRFLT_BIT        0x00000008
+#define IMG_ENCLRFLT_SFT        0x3
+
+#define IMG_ENCLRSTOP_BIT       0x00000004
+#define IMG_ENCLRSTOP_SFT       0x2
+
+#define IMG_ENCLRERROR_BIT      0x00000002
+#define IMG_ENCLRERROR_SFT      0x1
+
+#define IMG_ENCLRSTAT_BIT       0x00000001
+#define IMG_ENCLRSTAT_SFT       0x0
+
+
+/*------------------------------*/
+/* IMG_FFCLR                    */
+/*------------------------------*/
+#define IMG_FFCLRFLT_BIT        0x00000008
+#define IMG_FFCLRFLT_SFT        0x3
+
+#define IMG_FFCLRSTOP_BIT       0x00000004
+#define IMG_FFCLRSTOP_SFT       0x2
+
+#define IMG_FFCLRERROR_BIT      0x00000002
+#define IMG_FFCLRERROR_SFT      0x1
+
+#define IMG_FFCLRSTAT_BIT       0x00000001
+#define IMG_FFCLRSTAT_SFT       0x0
+
+
+/*------------------------------*/
+/* IMG_SRCSIZE_B                */
+/*------------------------------*/
+#define IMG_SRCSIZE_B_BIT       0x00007FFF
+#define IMG_SRCSIZE_B_SFT       0x0
+
+
+/*------------------------------*/
+/* IMG_SRCSIZE_F                */
+/*------------------------------*/
+#define IMG_SRCSIZE_F_BIT       0x00007FFF
+#define IMG_SRCSIZE_F_SFT       0x0
+
+
+/*------------------------------*/
+/* IMG_DSTSIZE                  */
+/*------------------------------*/
+#define IMG_DSTSIZE_BIT         0x00007FFF
+#define IMG_DSTSIZE_SFT         0x0
+
+
+/*------------------------------*/
+/* IMG_SRCYRGBADR_B             */
+/*------------------------------*/
+#define IMG_SRCYRGBADR_B_BIT    0xFFFFFFFF
+#define IMG_SRCYRGBADR_B_SFT    0x0
+
+
+/*------------------------------*/
+/* IMG_SRCYRGBADR_F             */
+/*------------------------------*/
+#define IMG_SRCYRGBADR_F_BIT    0xFFFFFFFF
+#define IMG_SRCYRGBADR_F_SFT    0x0
+
+
+/*------------------------------*/
+/* IMG_DSTYRGBADR               */
+/*------------------------------*/
+#define IMG_DSTYRGBADR_BIT      0xFFFFFFFF
+#define IMG_DSTYRGBADR_SFT      0x0
+
+
+/*------------------------------*/
+/* IMG_SRCUVADR_B               */
+/*------------------------------*/
+#define IMG_SRCUVADR_B_BIT      0xFFFFFFFF
+#define IMG_SRCUVADR_B_SFT      0x0
+
+
+/*------------------------------*/
+/* IMG_SRCUVADR_F               */
+/*------------------------------*/
+#define IMG_SRCUVADR_F_BIT      0xFFFFFFFF
+#define IMG_SRCUVADR_F_SFT      0x0
+
+
+/*------------------------------*/
+/* IMG_DSTUVADR                 */
+/*------------------------------*/
+#define IMG_DSTUVADR_BIT        0xFFFFFFFF
+#define IMG_DSTUVADR_SFT        0x0
+
+/*------------------------------*/
+/* IMG_SRCVADR_B               */
+/*------------------------------*/
+#define IMG_SRCVADR_B_BIT       0xFFFFFFFF
+#define IMG_SRCVADR_B_SFT       0x0
+
+
+/*------------------------------*/
+/* IMG_SRCVADR_F               */
+/*------------------------------*/
+#define IMG_SRCVADR_F_BIT       0xFFFFFFFF
+#define IMG_SRCVADR_F_SFT       0x0
+
+
+/*------------------------------*/
+/* IMG_DSTVADR                 */
+/*------------------------------*/
+#define IMG_DSTVADR_BIT         0xFFFFFFFF
+#define IMG_DSTVADR_SFT         0x0
+
+
+/*------------------------------*/
+/* IMG_SRCHSIZE_B               */
+/*------------------------------*/
+#define IMG_SRCHSIZE_B_BIT      0x00001FFF
+#define IMG_SRCHSIZE_B_SFT      0x0
+
+
+/*------------------------------*/
+/* IMG_SRCHSIZE_F               */
+/*------------------------------*/
+#define IMG_SRCHSIZE_F_BIT      0x00001FFF
+#define IMG_SRCHSIZE_F_SFT      0x0
+
+
+/*------------------------------*/
+/* IMG_SRCVSIZE_B               */
+/*------------------------------*/
+#define IMG_SRCVSIZE_B_BIT      0x00001FFF
+#define IMG_SRCVSIZE_B_SFT      0x0
+
+
+/*------------------------------*/
+/* IMG_SRCVSIZE_F               */
+/*------------------------------*/
+#define IMG_SRCVSIZE_F_BIT      0x00001FFF
+#define IMG_SRCVSIZE_F_SFT      0x0
+
+
+/*------------------------------*/
+/* IMG_OFFSETX                  */
+/*------------------------------*/
+#define IMG_OFFSETX_BIT         0x00001FFF
+#define IMG_OFFSETX_SFT         0x0
+
+/*------------------------------*/
+/* IMG_OFFSETY                  */
+/*------------------------------*/
+#define IMG_OFFSETY_BIT         0x00001FFF
+#define IMG_OFFSETY_SFT         0x0
+
+/*------------------------------*/
+/* IMG_MASKCOLR                 */
+/*------------------------------*/
+#define IMG_MASKCOLR_BIT        0x0000FFFF
+#define IMG_MASKCOLR_SFT        0x0
+
+/*------------------------------*/
+/* IMG_ALPHA                    */
+/*------------------------------*/
+#define IMG_ALPHA_BIT           0x000000FF
+#define IMG_ALPHA_SFT           0x0
+
+
+/*------------------------------*/
+/* IMG_DSTHSIZE                 */
+/*------------------------------*/
+#define IMG_DSTHSIZE_BIT        0x00001FFF
+#define IMG_DSTHSIZE_SFT        0x0
+
+
+/*------------------------------*/
+/* IMG_DSTVSIZE                 */
+/*------------------------------*/
+#define IMG_DSTVSIZE_BIT        0x00001FFF
+#define IMG_DSTVSIZE_SFT        0x0
+
+
+/*------------------------------*/
+/* IMG_HSTEP                    */
+/*------------------------------*/
+#define IMG_HSTEP_BIT           0x00003FFF
+#define IMG_HSTEP_SFT           0x0
+
+
+/*------------------------------*/
+/* IMG_VSTEP                    */
+/*------------------------------*/
+#define IMG_VSTEP_BIT           0x00003FFF
+#define IMG_VSTEP_SFT           0x0
+
+
+/*------------------------------*/
+/* IMG_HFOLD                    */
+/*------------------------------*/
+#define IMG_HFOLD_BIT           0x000001FF
+#define IMG_HFOLD_SFT           0x0
+
+
+/*------------------------------*/
+/* IMG_VFOLD                    */
+/*------------------------------*/
+#define IMG_VFOLD_BIT           0x000001FF
+#define IMG_VFOLD_SFT           0x0
+
+
+/*------------------------------*/
+/* IMG_PEL_ENDIAN               */
+/*------------------------------*/
+#define IMG_PEL_ENDIAN_BIT             0x00000003
+#define IMG_PEL_ENDIAN_IN_ENDI_LITTLE  0x1
+#define IMG_PEL_ENDIAN_IN_ENDI_BIG     0x0
+#define IMG_PEL_ENDIAN_OUT_ENDI_LITTLE 0x2
+#define IMG_PEL_ENDIAN_OUT_ENDI_BIG    0x0
+#define IMG_PEL_ENDIAN_IN_ENDI_SFT     0x0
+#define IMG_PEL_ENDIAN_OUT_ENDI_SFT    0x1
+
+
+
+/*------------------------------*/
+/* IMG_DBG_HADDR                */
+/*------------------------------*/
+#define IMG_DBG_HADDR_BIT       0xFFFFFFFF
+#define IMG_DBG_HADDR_SFT       0x0
+
+
+/*------------------------------*/
+/* IMG_RGBYUV00                 */
+/*------------------------------*/
+#define IMG_RGBYUV00_BIT        0x00000FFF
+#define IMG_RGBYUV00_SFT        0x0
+
+
+/*------------------------------*/
+/* IMG_RGBYUV01                 */
+/*------------------------------*/
+#define IMG_RGBYUV01_BIT        0x00000FFF
+#define IMG_RGBYUV01_SFT        0x0
+
+
+/*------------------------------*/
+/* IMG_RGBYUV02                 */
+/*------------------------------*/
+#define IMG_RGBYUV02_BIT        0x00000FFF
+#define IMG_RGBYUV02_SFT        0x0
+
+
+/*------------------------------*/
+/* IMG_RGBYUV10                 */
+/*------------------------------*/
+#define IMG_RGBYUV10_BIT        0x00000FFF
+#define IMG_RGBYUV10_SFT        0x0
+
+
+/*------------------------------*/
+/* IMG_RGBYUV11                 */
+/*------------------------------*/
+#define IMG_RGBYUV11_BIT        0x00000FFF
+#define IMG_RGBYUV11_SFT        0x0
+
+
+/*------------------------------*/
+/* IMG_RGBYUV12                 */
+/*------------------------------*/
+#define IMG_RGBYUV12_BIT        0x00000FFF
+#define IMG_RGBYUV12_SFT        0x0
+
+
+/*------------------------------*/
+/* IMG_RGBYUV20                 */
+/*------------------------------*/
+#define IMG_RGBYUV20_BIT        0x00000FFF
+#define IMG_RGBYUV20_SFT        0x0
+
+
+/*------------------------------*/
+/* IMG_RGBYUV21                 */
+/*------------------------------*/
+#define IMG_RGBYUV21_BIT        0x00000FFF
+#define IMG_RGBYUV21_SFT        0x0
+
+
+/*------------------------------*/
+/* IMG_RGBYUV22                 */
+/*------------------------------*/
+#define IMG_RGBYUV22_BIT        0x00000FFF
+#define IMG_RGBYUV22_SFT        0x0
+
+
+/*------------------------------*/
+/* IMG_YUVRGB00                 */
+/*------------------------------*/
+#define IMG_YUVRGB00_BIT        0x00000FFF
+#define IMG_YUVRGB00_SFT        0x0
+
+
+/*------------------------------*/
+/* IMG_YUVRGB01                 */
+/*------------------------------*/
+#define IMG_YUVRGB01_BIT        0x00000FFF
+#define IMG_YUVRGB01_SFT        0x0
+
+
+/*------------------------------*/
+/* IMG_YUVRGB02                 */
+/*------------------------------*/
+#define IMG_YUVRGB02_BIT        0x00000FFF
+#define IMG_YURGBV02_SFT        0x0
+
+
+/*------------------------------*/
+/* IMG_YUVRGB10                 */
+/*------------------------------*/
+#define IMG_YUVRGB10_BIT        0x00000FFF
+#define IMG_YUVRGB10_SFT        0x0
+
+
+/*------------------------------*/
+/* IMG_YUVRGB11                 */
+/*------------------------------*/
+#define IMG_YUVRGB11_BIT        0x00000FFF
+#define IMG_YUVRGB11_SFT        0x0
+
+
+/*------------------------------*/
+/* IMG_YUVRGB12                 */
+/*------------------------------*/
+#define IMG_YUVRGB12_BIT        0x00000FFF
+#define IMG_YUVRGB12_SFT        0x0
+
+
+/*------------------------------*/
+/* IMG_YUVRGB20                 */
+/*------------------------------*/
+#define IMG_YUVRGB20_BIT        0x00000FFF
+#define IMG_YUVRGB20_SFT        0x0
+
+
+/*------------------------------*/
+/* IMG_YUVRGB21                 */
+/*------------------------------*/
+#define IMG_YUVRGB21_BIT        0x00000FFF
+#define IMG_YUVRGB21_SFT        0x0
+
+
+/*------------------------------*/
+/* IMG_YUVRGB22                 */
+/*------------------------------*/
+#define IMG_YUVRGB22_BIT        0x00000FFF
+#define IMG_YUVRGB22_SFT        0x0
+
+
+/*------------------------------*/
+/* IMG_RGBYUV_CONF              */
+/*------------------------------*/
+#define IMG_RGBYUV_YOFFSET_VALID_BIT    0x00000001
+#define IMG_RGBYUV_YOFFSET_VALID_SFT    0x0
+
+
+/*------------------------------*/
+/* IMG_YUVRGB_CONF              */
+/*------------------------------*/
+#define IMG_YUVRGB_YOFFSET_VALID_BIT    0x00000001
+#define IMG_YUVRGB_YOFFSET_VALID_SFT    0x0
+
+
+/*------------------------------*/
+/* IMG_FORMAT                   */
+/* (temporary declaration)      */
+/*------------------------------*/
+#define IMG_FORMAT_RGB888                      0x0
+#define IMG_FORMAT_RGB666                      0x1
+#define IMG_FORMAT_RGB565                      0x2
+#define IMG_FORMAT_YUV420_PLANAR               0x4
+#define IMG_FORMAT_YUV420_SEMI_PLANAR          0x5
+#define IMG_FORMAT_YUV422_PLANAR               0x8
+#define IMG_FORMAT_YUV422_SEMI_PLANAR          0x9
+#define IMG_FORMAT_YUV422_INTERLEAVE           0xA
+
+/*------------------------------*/
+/* IMG_FORMAT                   */
+/*------------------------------*/
+#define IMG_FORMAT_DSTFMT_BIT                  0x00000F00
+#define IMG_FORMAT_DSTFMT_SFT                  0x8
+#define IMG_FORMAT_DSTFMT_RGB888               (IMG_FORMAT_RGB888 \
+						<< IMG_FORMAT_DSTFMT_SFT)
+#define IMG_FORMAT_DSTFMT_RGB666               (IMG_FORMAT_RGB666 \
+						<< IMG_FORMAT_DSTFMT_SFT)
+#define IMG_FORMAT_DSTFMT_RGB565               (IMG_FORMAT_RGB565 \
+						<< IMG_FORMAT_DSTFMT_SFT)
+#define IMG_FORMAT_DSTFMT_YUV420_PLANAR        (IMG_FORMAT_YUV420_PLANAR \
+						<< IMG_FORMAT_DSTFMT_SFT)
+#define IMG_FORMAT_DSTFMT_YUV420_SEMI_PLANAR   (IMG_FORMAT_YUV420_SEMI_PLANAR \
+						<< IMG_FORMAT_DSTFMT_SFT)
+#define IMG_FORMAT_DSTFMT_YUV422_PLANAR        (IMG_FORMAT_YUV422_PLANAR \
+						<< IMG_FORMAT_DSTFMT_SFT)
+#define IMG_FORMAT_DSTFMT_YUV422_SEMI_PLANAR   (IMG_FORMAT_YUV422_SEMI_PLANAR \
+						<< IMG_FORMAT_DSTFMT_SFT)
+#define IMG_FORMAT_DSTFMT_YUV422_INTERLEAVE    (IMG_FORMAT_YUV422_INTERLEAVE \
+						 << IMG_FORMAT_DSTFMT_SFT)
+
+#define IMG_FORMAT_SRCFMT_B_BIT                0x000000F0
+#define IMG_FORMAT_SRCFMT_B_SFT                0x4
+#define IMG_FORMAT_SRCFMT_B_RGB888             (IMG_FORMAT_RGB888 \
+						<< IMG_FORMAT_SRCFMT_B_SFT)
+#define IMG_FORMAT_SRCFMT_B_RGB565             (IMG_FORMAT_RGB565 \
+						<< IMG_FORMAT_SRCFMT_B_SFT)
+#define IMG_FORMAT_SRCFMT_B_YUV420_PLANAR      (IMG_FORMAT_YUV420_PLANAR \
+						<< IMG_FORMAT_SRCFMT_B_SFT)
+#define IMG_FORMAT_SRCFMT_B_YUV420_SEMI_PLANAR (IMG_FORMAT_YUV420_SEMI_PLANAR \
+						<< IMG_FORMAT_SRCFMT_B_SFT)
+#define IMG_FORMAT_SRCFMT_B_YUV422_PLANAR      (IMG_FORMAT_YUV422_PLANAR \
+						<< IMG_FORMAT_SRCFMT_B_SFT)
+#define IMG_FORMAT_SRCFMT_B_YUV422_SEMI_PLANAR (IMG_FORMAT_YUV422_SEMI_PLANAR \
+						<< IMG_FORMAT_SRCFMT_B_SFT)
+#define IMG_FORMAT_SRCFMT_B_YUV422_INTERLEAVE  (IMG_FORMAT_YUV422_INTERLEAVE \
+						<< IMG_FORMAT_SRCFMT_B_SFT)
+
+#define IMG_FORMAT_SRCFMT_F_BIT                0x0000000F
+#define IMG_FORMAT_SRCFMT_F_SFT                0x0
+#define IMG_FORMAT_SRCFMT_F_RGB888             (IMG_FORMAT_RGB888 \
+						<< IMG_FORMAT_SRCFMT_F_SFT)
+#define IMG_FORMAT_SRCFMT_F_RGB565             (IMG_FORMAT_RGB565 \
+						<< IMG_FORMAT_SRCFMT_F_SFT)
+#define IMG_FORMAT_SRCFMT_F_YUV420_PLANAR      (IMG_FORMAT_YUV420_PLANAR \
+						<< IMG_FORMAT_SRCFMT_F_SFT)
+#define IMG_FORMAT_SRCFMT_F_YUV420_SEMI_PLANAR (IMG_FORMAT_YUV420_SEMI_PLANAR \
+						<< IMG_FORMAT_SRCFMT_F_SFT)
+#define IMG_FORMAT_SRCFMT_F_YUV422_PLANAR      (IMG_FORMAT_YUV422_PLANAR \
+						<< IMG_FORMAT_SRCFMT_F_SFT)
+#define IMG_FORMAT_SRCFMT_F_YUV422_SEMI_PLANAR (IMG_FORMAT_YUV422_SEMI_PLANAR \
+						<< IMG_FORMAT_SRCFMT_F_SFT)
+#define IMG_FORMAT_SRCFMT_F_YUV422_INTERLEAVE  (IMG_FORMAT_YUV422_INTERLEAVE \
+						<< IMG_FORMAT_SRCFMT_F_SFT)
+
+
+/*------------------------------*/
+/* BYTELANE                     */
+/* (temporary declaration)      */
+/*------------------------------*/
+#define IMG_BYTELANE_DATAx_BYTE0    0x0
+#define IMG_BYTELANE_DATAx_BYTE1    0x1
+#define IMG_BYTELANE_DATAx_BYTE2    0x2
+#define IMG_BYTELANE_DATAx_BYTE3    0x3
+
+/*------------------------------*/
+/* IMG_INDATABYTE               */
+/*------------------------------*/
+#define IMG_INDATABYTE_DATA3_BIT    0x000000C0
+#define IMG_INDATABYTE_DATA3_SFT    0x6
+#define IMG_INDATABYTE_DATA3_BYTE0  (IMG_BYTELANE_DATAx_BYTE0 \
+					<< IMG_INDATABYTE_DATA3_SFT)
+#define IMG_INDATABYTE_DATA3_BYTE1  (IMG_BYTELANE_DATAx_BYTE1 \
+					<< IMG_INDATABYTE_DATA3_SFT)
+#define IMG_INDATABYTE_DATA3_BYTE2  (IMG_BYTELANE_DATAx_BYTE2 \
+					<< IMG_INDATABYTE_DATA3_SFT)
+#define IMG_INDATABYTE_DATA3_BYTE3  (IMG_BYTELANE_DATAx_BYTE3 \
+					<< IMG_INDATABYTE_DATA3_SFT)
+
+#define IMG_INDATABYTE_DATA2_BIT    0x00000030
+#define IMG_INDATABYTE_DATA2_SFT    0x4
+#define IMG_INDATABYTE_DATA2_BYTE0  (IMG_BYTELANE_DATAx_BYTE0 \
+					<< IMG_INDATABYTE_DATA2_SFT)
+#define IMG_INDATABYTE_DATA2_BYTE1  (IMG_BYTELANE_DATAx_BYTE1 \
+					<< IMG_INDATABYTE_DATA2_SFT)
+#define IMG_INDATABYTE_DATA2_BYTE2  (IMG_BYTELANE_DATAx_BYTE2 \
+					<< IMG_INDATABYTE_DATA2_SFT)
+#define IMG_INDATABYTE_DATA2_BYTE3  (IMG_BYTELANE_DATAx_BYTE3 \
+					<< IMG_INDATABYTE_DATA2_SFT)
+
+#define IMG_INDATABYTE_DATA1_BIT    0x0000000C
+#define IMG_INDATABYTE_DATA1_SFT    0x2
+#define IMG_INDATABYTE_DATA1_BYTE0  (IMG_BYTELANE_DATAx_BYTE0 \
+					<< IMG_INDATABYTE_DATA1_SFT)
+#define IMG_INDATABYTE_DATA1_BYTE1  (IMG_BYTELANE_DATAx_BYTE1 \
+					<< IMG_INDATABYTE_DATA1_SFT)
+#define IMG_INDATABYTE_DATA1_BYTE2  (IMG_BYTELANE_DATAx_BYTE2 \
+					<< IMG_INDATABYTE_DATA1_SFT)
+#define IMG_INDATABYTE_DATA1_BYTE3  (IMG_BYTELANE_DATAx_BYTE3 \
+					<< IMG_INDATABYTE_DATA1_SFT)
+
+#define IMG_INDATABYTE_DATA0_BIT    0x00000003
+#define IMG_INDATABYTE_DATA0_SFT    0x0
+#define IMG_INDATABYTE_DATA0_BYTE0  (IMG_BYTELANE_DATAx_BYTE0 \
+					<< IMG_INDATABYTE_DATA0_SFT)
+#define IMG_INDATABYTE_DATA0_BYTE1  (IMG_BYTELANE_DATAx_BYTE1 \
+					<< IMG_INDATABYTE_DATA0_SFT)
+#define IMG_INDATABYTE_DATA0_BYTE2  (IMG_BYTELANE_DATAx_BYTE2 \
+					<< IMG_INDATABYTE_DATA0_SFT)
+#define IMG_INDATABYTE_DATA0_BYTE3  (IMG_BYTELANE_DATAx_BYTE3 \
+					<< IMG_INDATABYTE_DATA0_SFT)
+
+
+/*------------------------------*/
+/* IMG_OUTDATABYTE              */
+/*------------------------------*/
+#define IMG_OUTDATABYTE_DATA3_BIT   0x000000C0
+#define IMG_OUTDATABYTE_DATA3_SFT   0x6
+#define IMG_OUTDATABYTE_DATA3_BYTE0 (IMG_BYTELANE_DATAx_BYTE0 \
+					<< IMG_OUTDATABYTE_DATA3_SFT)
+#define IMG_OUTDATABYTE_DATA3_BYTE1 (IMG_BYTELANE_DATAx_BYTE1 \
+					<< IMG_OUTDATABYTE_DATA3_SFT)
+#define IMG_OUTDATABYTE_DATA3_BYTE2 (IMG_BYTELANE_DATAx_BYTE2 \
+					<< IMG_OUTDATABYTE_DATA3_SFT)
+#define IMG_OUTDATABYTE_DATA3_BYTE3 (IMG_BYTELANE_DATAx_BYTE3 \
+					<< IMG_OUTDATABYTE_DATA3_SFT)
+
+#define IMG_OUTDATABYTE_DATA2_BIT   0x00000030
+#define IMG_OUTDATABYTE_DATA2_SFT   0x4
+#define IMG_OUTDATABYTE_DATA2_BYTE0 (IMG_BYTELANE_DATAx_BYTE0 \
+					<< IMG_OUTDATABYTE_DATA2_SFT)
+#define IMG_OUTDATABYTE_DATA2_BYTE1 (IMG_BYTELANE_DATAx_BYTE1 \
+					<< IMG_OUTDATABYTE_DATA2_SFT)
+#define IMG_OUTDATABYTE_DATA2_BYTE2 (IMG_BYTELANE_DATAx_BYTE2 \
+					<< IMG_OUTDATABYTE_DATA2_SFT)
+#define IMG_OUTDATABYTE_DATA2_BYTE3 (IMG_BYTELANE_DATAx_BYTE3 \
+					<< IMG_OUTDATABYTE_DATA2_SFT)
+
+#define IMG_OUTDATABYTE_DATA1_BIT   0x0000000C
+#define IMG_OUTDATABYTE_DATA1_SFT   0x2
+#define IMG_OUTDATABYTE_DATA1_BYTE0 (IMG_BYTELANE_DATAx_BYTE0 \
+					<< IMG_OUTDATABYTE_DATA1_SFT)
+#define IMG_OUTDATABYTE_DATA1_BYTE1 (IMG_BYTELANE_DATAx_BYTE1 \
+					<< IMG_OUTDATABYTE_DATA1_SFT)
+#define IMG_OUTDATABYTE_DATA1_BYTE2 (IMG_BYTELANE_DATAx_BYTE2 \
+					<< IMG_OUTDATABYTE_DATA1_SFT)
+#define IMG_OUTDATABYTE_DATA1_BYTE3 (IMG_BYTELANE_DATAx_BYTE3 \
+					<< IMG_OUTDATABYTE_DATA1_SFT)
+
+#define IMG_OUTDATABYTE_DATA0_BIT   0x00000003
+#define IMG_OUTDATABYTE_DATA0_SFT   0x0
+#define IMG_OUTDATABYTE_DATA0_BYTE0 (IMG_BYTELANE_DATAx_BYTE0 \
+					<< IMG_OUTDATABYTE_DATA0_SFT)
+#define IMG_OUTDATABYTE_DATA0_BYTE1 (IMG_BYTELANE_DATAx_BYTE1 \
+					<< IMG_OUTDATABYTE_DATA0_SFT)
+#define IMG_OUTDATABYTE_DATA0_BYTE2 (IMG_BYTELANE_DATAx_BYTE2 \
+					<< IMG_OUTDATABYTE_DATA0_SFT)
+#define IMG_OUTDATABYTE_DATA0_BYTE3 (IMG_BYTELANE_DATAx_BYTE3 \
+					<< IMG_OUTDATABYTE_DATA0_SFT)
+
+
+/*------------------------------*/
+/* IMG_INDATABYTE_B_CMP         */
+/*------------------------------*/
+/* IMG_INDATABYTE_F_CMP         */
+/*------------------------------*/
+/* IMG_OUTDATABYTE_CMP          */
+/*------------------------------*/
+#define IMG_DATABYTE_DATA3_UV_BIT   0x0000C000
+#define IMG_DATABYTE_DATA3_UV_SFT   0xE
+#define IMG_DATABYTE_DATA3_UV_BYTE0 (IMG_BYTELANE_DATAx_BYTE0 \
+					<< IMG_INDATABYTE_B_DATA3_UV_SFT)
+#define IMG_DATABYTE_DATA3_UV_BYTE1 (IMG_BYTELANE_DATAx_BYTE1 \
+					<< IMG_INDATABYTE_B_DATA3_UV_SFT)
+#define IMG_DATABYTE_DATA3_UV_BYTE2 (IMG_BYTELANE_DATAx_BYTE2 \
+					<< IMG_INDATABYTE_B_DATA3_UV_SFT)
+#define IMG_DATABYTE_DATA3_UV_BYTE3 (IMG_BYTELANE_DATAx_BYTE3 \
+					<< IMG_INDATABYTE_B_DATA3_UV_SFT)
+
+#define IMG_DATABYTE_DATA2_UV_BIT   0x00003000
+#define IMG_DATABYTE_DATA2_UV_SFT   0xC
+#define IMG_DATABYTE_DATA2_UV_BYTE0 (IMG_BYTELANE_DATAx_BYTE0 \
+					<< IMG_INDATABYTE_B_DATA2_UV_SFT)
+#define IMG_DATABYTE_DATA2_UV_BYTE1 (IMG_BYTELANE_DATAx_BYTE1 \
+					<< IMG_INDATABYTE_B_DATA2_UV_SFT)
+#define IMG_DATABYTE_DATA2_UV_BYTE2 (IMG_BYTELANE_DATAx_BYTE2 \
+					<< IMG_INDATABYTE_B_DATA2_UV_SFT)
+#define IMG_DATABYTE_DATA2_UV_BYTE3 (IMG_BYTELANE_DATAx_BYTE3 \
+					<< IMG_INDATABYTE_B_DATA2_UV_SFT)
+
+#define IMG_DATABYTE_DATA1_UV_BIT   0x00000C00
+#define IMG_DATABYTE_DATA1_UV_SFT   0xA
+#define IMG_DATABYTE_DATA1_UV_BYTE0 (IMG_BYTELANE_DATAx_BYTE0 \
+					<< IMG_INDATABYTE_B_DATA1_UV_SFT)
+#define IMG_DATABYTE_DATA1_UV_BYTE1 (IMG_BYTELANE_DATAx_BYTE1 \
+					<< IMG_INDATABYTE_B_DATA1_UV_SFT)
+#define IMG_DATABYTE_DATA1_UV_BYTE2 (IMG_BYTELANE_DATAx_BYTE2 \
+					<< IMG_INDATABYTE_B_DATA1_UV_SFT)
+#define IMG_DATABYTE_DATA1_UV_BYTE3 (IMG_BYTELANE_DATAx_BYTE3 \
+					<< IMG_INDATABYTE_B_DATA1_UV_SFT)
+
+#define IMG_DATABYTE_DATA0_UV_BIT   0x00000300
+#define IMG_DATABYTE_DATA0_UV_SFT   0x8
+#define IMG_DATABYTE_DATA0_UV_BYTE0 (IMG_BYTELANE_DATAx_BYTE0 \
+					<< IMG_INDATABYTE_B_DATA0_UV_SFT)
+#define IMG_DATABYTE_DATA0_UV_BYTE1 (IMG_BYTELANE_DATAx_BYTE1 \
+					<< IMG_INDATABYTE_B_DATA0_UV_SFT)
+#define IMG_DATABYTE_DATA0_UV_BYTE2 (IMG_BYTELANE_DATAx_BYTE2 \
+					<< IMG_INDATABYTE_B_DATA0_UV_SFT)
+#define IMG_DATABYTE_DATA0_UV_BYTE3 (IMG_BYTELANE_DATAx_BYTE3 \
+					<< IMG_INDATABYTE_B_DATA0_UV_SFT)
+
+#define IMG_DATABYTE_DATA3_Y_BIT    0x000000C0
+#define IMG_DATABYTE_DATA3_Y_SFT    0x6
+#define IMG_DATABYTE_DATA3_Y_BYTE0  (IMG_BYTELANE_DATAx_BYTE0 \
+					<< IMG_INDATABYTE_B_DATA3_Y_SFT)
+#define IMG_DATABYTE_DATA3_Y_BYTE1  (IMG_BYTELANE_DATAx_BYTE1 \
+					<< IMG_INDATABYTE_B_DATA3_Y_SFT)
+#define IMG_DATABYTE_DATA3_Y_BYTE2  (IMG_BYTELANE_DATAx_BYTE2 \
+					<< IMG_INDATABYTE_B_DATA3_Y_SFT)
+#define IMG_DATABYTE_DATA3_Y_BYTE3  (IMG_BYTELANE_DATAx_BYTE3 \
+					<< IMG_INDATABYTE_B_DATA3_Y_SFT)
+
+#define IMG_DATABYTE_DATA2_Y_BIT    0x00000030
+#define IMG_DATABYTE_DATA2_Y_SFT    0x4
+#define IMG_DATABYTE_DATA2_Y_BYTE0  (IMG_BYTELANE_DATAx_BYTE0 \
+					<< IMG_INDATABYTE_B_DATA2_Y_SFT)
+#define IMG_DATABYTE_DATA2_Y_BYTE1  (IMG_BYTELANE_DATAx_BYTE1 \
+					<< IMG_INDATABYTE_B_DATA2_Y_SFT)
+#define IMG_DATABYTE_DATA2_Y_BYTE2  (IMG_BYTELANE_DATAx_BYTE2 \
+					<< IMG_INDATABYTE_B_DATA2_Y_SFT)
+#define IMG_DATABYTE_DATA2_Y_BYTE3  (IMG_BYTELANE_DATAx_BYTE3 \
+					<< IMG_INDATABYTE_B_DATA2_Y_SFT)
+
+#define IMG_DATABYTE_DATA1_Y_BIT    0x0000000C
+#define IMG_DATABYTE_DATA1_Y_SFT    0x2
+#define IMG_DATABYTE_DATA1_Y_BYTE0  (IMG_BYTELANE_DATAx_BYTE0 \
+					<< IMG_INDATABYTE_B_DATA1_Y_SFT)
+#define IMG_DATABYTE_DATA1_Y_BYTE1  (IMG_BYTELANE_DATAx_BYTE1 \
+					<< IMG_INDATABYTE_B_DATA1_Y_SFT)
+#define IMG_DATABYTE_DATA1_Y_BYTE2  (IMG_BYTELANE_DATAx_BYTE2 \
+					<< IMG_INDATABYTE_B_DATA1_Y_SFT)
+#define IMG_DATABYTE_DATA1_Y_BYTE3  (IMG_BYTELANE_DATAx_BYTE3 \
+					<< IMG_INDATABYTE_B_DATA1_Y_SFT)
+
+#define IMG_DATABYTE_DATA0_Y_BIT    0x00000003
+#define IMG_DATABYTE_DATA0_Y_SFT    0x0
+#define IMG_DATABYTE_DATA0_Y_BYTE0  (IMG_BYTELANE_DATAx_BYTE0 \
+					<< IMG_INDATABYTE_B_DATA0_Y_SFT)
+#define IMG_DATABYTE_DATA0_Y_BYTE1  (IMG_BYTELANE_DATAx_BYTE1 \
+					<< IMG_INDATABYTE_B_DATA0_Y_SFT)
+#define IMG_DATABYTE_DATA0_Y_BYTE2  (IMG_BYTELANE_DATAx_BYTE2 \
+					<< IMG_INDATABYTE_B_DATA0_Y_SFT)
+#define IMG_DATABYTE_DATA0_Y_BYTE3  (IMG_BYTELANE_DATAx_BYTE3 \
+					<< IMG_INDATABYTE_B_DATA0_Y_SFT)
+
+
+/*------------------------------*/
+/* IMG_DUAL_FF                  */
+/*------------------------------*/
+#define IMG_REG_EN_BIT          0x00000001
+#define IMG_REG_EN_SFT          0x0
+
+
+/*------------------------------*/
+/* IMG_R_BRITNESS               */
+/*------------------------------*/
+#define IMG_R_BRITNESS_BIT      0x000007FF
+#define IMG_R_BRITNESS_SFT      0x0
+
+
+/*------------------------------*/
+/* IMG_G_BRITNESS               */
+/*------------------------------*/
+#define IMG_G_BRITNESS_BIT      0x000007FF
+#define IMG_G_BRITNESS_SFT      0x0
+
+
+/*------------------------------*/
+/* IMG_B_BRITNESS               */
+/*------------------------------*/
+#define IMG_B_BRITNESS_BIT      0x000007FF
+#define IMG_B_BRITNESS_SFT      0x0
+
+
+/*===============================================================*/
+/* IMG register reset                                            */
+/*===============================================================*/
+#define IMG_MODE_RESET              0x00000000
+#define IMG_HSTEP_RESET             0x00000100
+#define IMG_VSTEP_RESET             0x00000100
+#define IMG_HFOLD_RESET             0x00000040
+#define IMG_VFOLD_RESET             0x00000040
+#define IMG_INDATABYTE_RESET        0x000000E4
+#define IMG_OUTDATABYTE_RESET       0x000000E4
+#define IMG_DUAL_FF_RESET           0x00000000
+
+#define IMG_RGBYUV_CONF_RESET       0x00000000
+#define IMG_RGBYUV00_RESET          0x0000004D
+#define IMG_RGBYUV01_RESET          0x00000096
+#define IMG_RGBYUV02_RESET          0x0000001D
+#define IMG_RGBYUV10_RESET          0x0000082C
+#define IMG_RGBYUV11_RESET          0x00000857
+#define IMG_RGBYUV12_RESET          0x00000083
+#define IMG_RGBYUV20_RESET          0x00000083
+#define IMG_RGBYUV21_RESET          0x0000086E
+#define IMG_RGBYUV22_RESET          0x00000815
+#define IMG_YUVRGB_CONF_RESET       0x00000000
+#define IMG_YUVRGB00_RESET          0x00000100
+#define IMG_YUVRGB01_RESET          0x00000000
+#define IMG_YUVRGB02_RESET          0x0000015F
+#define IMG_YUVRGB10_RESET          0x00000100
+#define IMG_YUVRGB11_RESET          0x00000856
+#define IMG_YUVRGB12_RESET          0x000008B3
+#define IMG_YUVRGB20_RESET          0x00000100
+#define IMG_YUVRGB21_RESET          0x000001BB
+#define IMG_YUVRGB22_RESET          0x00000000
+#define IMG_R_BRITNESS_RESET        0x00000000
+#define IMG_G_BRITNESS_RESET        0x00000000
+#define IMG_B_BRITNESS_RESET        0x00000000
+
+#endif /* _IMG_H_ */
diff --git a/arch/arm/mach-mp200/include/mach/ipu.h b/arch/arm/mach-mp200/include/mach/ipu.h
new file mode 100644
index 0000000..af35230
--- /dev/null
+++ b/arch/arm/mach-mp200/include/mach/ipu.h
@@ -0,0 +1,170 @@
+/*
+*  File Name       : include/mach/ipu.h
+*  Function        : IPU MMIO definitions, and Driver - Driver I/F of IPU driver
+*  Release Version : Ver 1.01
+*  Release Date    : 2009/07/27
+*
+*  Copyright (C) NEC Electronics Corporation 2009
+*
+*
+*  This program is free software;you can redistribute it and/or modify it
+*  under the terms of the GNU General Public License as published by Free
+*  Softwere Foundation; either version 2 of License, or (at your option) any
+*  later version.
+*
+*  This program is distributed in the hope that it will be useful, but WITHOUT
+*  ANY WARRANTY; without even the implied warrnty of MERCHANTABILITY or
+*  FITNESS FOR A PARTICULAR PURPOSE.
+*  See the GNU General Public License for more details.
+*
+*  You should have received a copy of the GNU General Public License along
+*  with this program; If not, write to the Free Software Foundation, Inc., 59
+*  Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+*
+*/
+
+
+#ifndef _IPU_H_
+#define _IPU_H_
+
+#include <mach/img.h>
+#include <mach/rot.h>
+#include <mach/gdma.h>
+
+
+/*===============================================================*/
+/* IPU Driver Definitions                                        */
+/*===============================================================*/
+
+/* H/W Function of mp200_ipu_req(h/w function) */
+#define IPU_HW_FUNC_IMG		0x01	/* Image Processor Function */
+#define IPU_HW_FUNC_ROT		0x02	/* Image Rotator Function */
+#define IPU_HW_FUNC_GDMA	0x04	/* GraphicsDMA Function */
+#define IPU_HW_FUNC_ALL		(IPU_HW_FUNC_IMG | IPU_HW_FUNC_ROT \
+				 | IPU_HW_FUNC_GDMA)
+				/* IPU Function */
+
+/* Statuses of IPU request */
+#define IPU_REQ_STATUS_REGISTERED   1	/* registered                        */
+#define IPU_REQ_STATUS_RUNNING      2	/* running                           */
+#define IPU_REQ_STATUS_WAIT_CANCEL  3	/* waiting for cancelled request to
+					   be done   */
+#define IPU_REQ_STATUS_CANCELLED    4	/* cancelled                         */
+#define IPU_REQ_STATUS_DONE         5	/* done                              */
+#define IPU_REQ_STATUS_ERROR        6	/* failed                            */
+#define IPU_REQ_STATUS_IDLE         8	/* unregistration                    */
+#define IPU_REQ_STATUS_CANCEL       9	/* cancel start                      */
+
+/* Parameters of mp200_ipu_regist (regist request) */
+#define IPU_REQ_REGISTERED          0	/* the request is registed           */
+#define IPU_REQ_BUSY         (-EBUSY)	/* fail to register the request busy */
+#define IPU_REQ_PARAMERR    (-EINVAL)	/* fail to register the request
+					   parameter */
+
+/* Parameters of mp200_ipu_cancel (cancel request) */
+#define IPU_CANCEL_SYNC             1	/* SYNC flag for cancel request */
+
+/* Returns of mp200_ipu_cancel (cancel request) */
+#define IPU_CANCEL_DONE             0	/* cancelled */
+#define IPU_CANCEL_WAIT             1	/* waiting for cancelled request to
+					   be done   */
+#define IPU_CANCEL_NO_REQ           2	/* target request does not exist */
+
+/* Parameters of callback function */
+#define IPU_CALLBACK_SUCCESS        0	/* IPU process is completed
+					   (Success) */
+#define IPU_CALLBACK_SET_PARAM      1	/* set values to IPU registers
+					   (Success) */
+#define IPU_CALLBACK_CANCEL         2	/* cancelled request is done
+					   (Success) */
+#define IPU_CALLBACK_FAIL        (-1)	/* can't start IPU process (Error) */
+#define IPU_CALLBACK_IPU_ERROR   (-2)	/* IPU ERROR interrupt (Error) */
+#define IPU_CALLBACK_IPU_STOP    (-3)	/* IPU RETRY/SPLIT interrupt (Error) */
+
+
+struct mp200_ipu_req;	/* Declaration of structure tag (incomplete type) */
+struct mp200_ipu_queue;
+
+/*===============================================================*/
+/* Callback function type                                        */
+/*===============================================================*/
+typedef void (*ipu_callback_func)(unsigned long sequence, int flag);
+
+
+/*===============================================================*/
+/* IPU register setting information structure                    */
+/*===============================================================*/
+struct mp200_ipu_reg_info {
+	unsigned long reg;	/* offset to IPU register */
+	unsigned long data;	/* data to set            */
+};
+#define SIZE_MP200_IPU_REG_INFO 8
+
+#define IPU_REG_INFO_END -1
+
+/*===============================================================*/
+/* IPU request information structure                             */
+/*===============================================================*/
+/* max number of IPU register setting informations   */
+#define IPU_REG_INFO_MAX  230
+
+struct mp200_ipu_req {
+	/* sequence No             */
+	unsigned long sequence;
+	/* Status of IPU request (used by IPU driver)        */
+	int status;
+	/* callback function                                 */
+	ipu_callback_func callback;
+	/* optional data (used by caller)                    */
+	unsigned long       data;
+	/* H/W Function (processing demand)                  */
+	/*          IMG Function   : IPU_HW_FUNC_IMG         */
+	/*          ROT Function   : IPU_HW_FUNC_ROT         */
+	/*          GDMA Function  : IPU_HW_FUNC_GDMA        */
+	int                 ipu_hw_func;
+	/* IPU register setting informations                 */
+	/* repeat until end condition (max 230 pairs)        */
+	/*  end condition :                                  */
+	/*     set 0x00000001 to IMG_REQ/ROT_REQ/GDMA_REQ    */
+	/*                    (request to start IPU process) */
+	/*     reg=IMG_REQ/ROT_REQ/GDMA_REQ data=0x00000001, */
+	/*                             or reg=-1(0xFFFFFFFF) */
+	struct mp200_ipu_reg_info ipu_reg_info[];
+};
+#define MAX_SIZE_MP200_IPU_REQ \
+	(20 + (SIZE_MP200_IPU_REG_INFO * IPU_REG_INFO_MAX))
+
+
+#ifndef _IPU_USER_H_
+/*===============================================================*/
+/* extern declarations of public functions                       */
+/*===============================================================*/
+extern int mp200_ipu_regist(struct mp200_ipu_req *p);
+extern int mp200_ipu_cancel(unsigned long sequence, int flag);
+
+/****************************************************************************/
+/* Prototype declarations                                                   */
+/****************************************************************************/
+int mp200_ipu_open(struct inode *inode, struct file *file);
+int mp200_ipu_close(struct inode *inode, struct file *file);
+int mp200_ipu_ioctl(struct inode *inode, struct file *file,
+	 unsigned int request, unsigned long arg);
+int mp200_ipu_mmap(struct file *file, struct vm_area_struct *vma);
+
+/*===============================================================*/
+/* callback function                                             */
+/*===============================================================*/
+void mp200_ipu_callback_img(unsigned long data, int flag);
+void mp200_ipu_callback_rot(unsigned long data, int flag);
+void mp200_ipu_callback_gdma(unsigned long data, int flag);
+
+/* ------------------------------------------- */
+/*   Public functions                          */
+/* ------------------------------------------- */
+int mp200_ipu_regist(struct mp200_ipu_req *p);
+int mp200_ipu_cancel(unsigned long sequence, int flag);
+
+
+#endif /* _IPU_USER_H_ */
+
+#endif /* _IPU_H_ */
diff --git a/arch/arm/mach-mp200/include/mach/ipu_user.h b/arch/arm/mach-mp200/include/mach/ipu_user.h
new file mode 100644
index 0000000..a4e0ecc
--- /dev/null
+++ b/arch/arm/mach-mp200/include/mach/ipu_user.h
@@ -0,0 +1,410 @@
+/*
+*  File Name       : include/mach/ipu_user.h
+*  Function        : User - Driver I/F of IPU driver
+*  Release Version : Ver 1.01
+*  Release Date    : 2009/07/27
+*
+*  Copyright (C) NEC Electronics Corporation 2009
+*
+*
+*  This program is free software;you can redistribute it and/or modify it
+*  under the terms of the GNU General Public License as published by Free
+*  Softwere Foundation; either version 2 of License, or (at your option) any
+*  later version.
+*
+*  This program is distributed in the hope that it will be useful, but WITHOUT
+*  ANY WARRANTY; without even the implied warrnty of MERCHANTABILITY or
+*  FITNESS FOR A PARTICULAR PURPOSE.
+*  See the GNU General Public License for more details.
+*
+*  You should have received a copy of the GNU General Public License along
+*  with this program; If not, write to the Free Software Foundation, Inc., 59
+*  Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+*
+*/
+
+#ifndef _IPU_USER_H_
+#define _IPU_USER_H_
+
+#include <mach/ipu.h>
+
+
+/*===============================================================*/
+/* IOCTLs to IPU driver. 0x4E is 'N' for NEC.                    */
+/*===============================================================*/
+#define IMGIO_CONVERT			0x4E01	/* composite & forward image
+						   with IMG */
+#define ROTIO_ROTATION			0x4E02	/* rotate image with ROT */
+#define IPUIO_MP200_IPU_REGIST		0x4E12	/* regist  IPU request */
+#define IPUIO_MP200_IPU_CALLBACK	0x4E13	/* waiting IPU request to
+						   finish */
+#define IPUIO_MP200_IPU_CANCEL		0x4E14	/* cancel  IPU request */
+
+
+/*=============================================================================
+* IOCTL    : IPUIO_MP200_IPU_REGIST
+* FUNCTION : register IPU request in Normal Request's queue.
+*            can't register a new request before registered request is done.
+*            open() without O_NONBLOCK :
+*              register the IPU request, wait for the request to be done
+*              (BLOCK), and return.
+*            open() with O_NONBLOCK :
+*              register the IPU request, and return immediately (non BLOCK).
+*              not wait for the request to be done.
+* INPUT    : pointer to IPU request information
+* OUTPUT   : Returns
+*              IPU_REQ_REGISTERED(0) : the request is registered
+*              IPU_REQ_COMPLETE  (1) : the request is registered and done
+*              IPU_REQ_CANCELLED (2) : the request is registered and cancelled
+*              -1                    : fail to register the request
+*                errno = EBUSY       :   busy
+*                errno = EINVAL      :   parameter error
+*            result_data(Status of IPU process)
+*              <without O_NONBLOCK and return=1(the request is registered
+*               and done)>
+*              IPU_CALLBACK_SUCCESS      : IPU process is completed (Success)
+*              IPU_CALLBACK_SET_PARAM    : set values to IPU registers (Success)
+*              IPU_CALLBACK_CANCEL       : cancelled request is done (Success)
+*              IPU_CALLBACK_FAIL         : can't start IPU process (Error)
+*              IPU_CALLBACK_IPU_ERROR    : IPU ERROR interrupt (Error)
+*              IPU_CALLBACK_IPU_STOP     : IPU RETRY/SPLIT interrupt (Error)
+*============================================================================*/
+struct _IPUIO_MP200_IPU_REGIST{
+	/* size of data pointed by request_arg */
+	size_t request_length;
+
+	/* pointer to IPU request information */
+	struct mp200_ipu_req *request_arg;
+
+	/* processing result */
+	long result_data;
+};
+#define SIZE_IPUIO_MP200_IPU_REGIST 12
+
+
+#ifndef IPU_REQ_REGISTERED
+#define IPU_REQ_REGISTERED 0	/* the request is registered               */
+#endif
+#define IPU_REQ_COMPLETE   1	/* the request is registered and done      */
+#define IPU_REQ_CANCELLED  2	/* the request is registered and cancelled */
+#ifndef IPU_REQ_BUSY
+#define IPU_REQ_BUSY	(-EBUSY)	/* fail to register the request busy */
+#endif
+#ifndef IPU_REQ_PARAMERR
+#define IPU_REQ_PARAMERR   (-EINVAL)	/* fail to register the request
+					   parameter */
+#endif
+
+
+/*=============================================================================
+* IOCTL    : IPUIO_MP200_IPU_CALLBACK
+* FUNCTION : wait for the registered IPU request to be done, or get status of
+*            the request.
+*            open() without O_NONBLOCK :
+*              wait for the request to be done (BLOCK), and return.
+*            open() with O_NONBLOCK :
+*              return immediately (non BLOCK). not wait for the request to be
+*              done.
+* INPUT    : pointer to IPU request information
+* OUTPUT   : Returns
+*              IPU_STATUS_DONE(0)         : IPU process is completed
+*              IPU_STATUS_WAIT(1)         : IPU process is running
+*                                           (already registered)
+*              IPU_STATUS_NO_REQ(2)       : target request does not exist
+*              IPU_STATUS_CANCELLED(3)    : target request is cancelled
+*            result_data(status of IPU process)
+*              <return=0(IPU request had been done)>
+*              IPU_CALLBACK_SUCCESS       : IPU process is completed (Success)
+*              IPU_CALLBACK_SET_PARAM     : set values to IPU registers
+*                                           (Success)
+*              IPU_CALLBACK_CANCEL        : cancelled request is done (Success)
+*              IPU_CALLBACK_FAIL          : can't start IPU process (Error)
+*              IPU_CALLBACK_IPU_ERROR     : IPU ERROR interrupt (Error)
+*              IPU_CALLBACK_IPU_STOP      : IPU RETRY/SPLIT interrupt (Error)
+*              <return=1(IPU request is running)>
+*              IPU_REQ_STATUS_REGISTERED  : registered (before running)
+*              IPU_REQ_STATUS_RUNNING     : running (running)
+*              IPU_REQ_STATUS_WAIT_CANCEL : waiting for cancelled request to be
+*                                           done (running)
+*============================================================================*/
+struct _IPUIO_MP200_IPU_CALLBACK{
+	unsigned long sequence;	/* sequence number of ipu processing demand */
+	long result_data;	/* processing result                        */
+};
+#define SIZE_IPUIO_MP200_IPU_CALLBACK 8
+
+#define IPU_STATUS_DONE      0	/* IPU process is completed */
+#define IPU_STATUS_WAIT      1	/* IPU process is running
+				       (already registered) */
+#define IPU_STATUS_NO_REQ    2	/* target request does not exist */
+#define IPU_STATUS_CANCELLED 3	/* target request is cancelled   */
+
+
+
+/*=============================================================================
+* IOCTL    : IPUIO_MP200_IPU_CANCEL
+* FUNCTION : cancel registered IPU request
+*            target IPU request has not been started :
+*                remove the target request from the queue.
+*            target IPU request has been started (running) :
+*              without IPU_CANCEL_SYNC :
+*                set IPU_CANCEL_WAIT to the status of the request,
+*                and wait for the request to be done.
+*                Then set IPU_CALLBACK_CANCEL to result_data
+*                as return of IPUIO_MP200_IPU_CALLBACK.
+*              with IPU_CANCEL_SYNC    :
+*                remove the target request from the queue immediately.
+*                and skip waiting for the request to be done
+*                (IPUIO_MP200_IPU_CALLBACK)
+* INPUT    : pointer to IPU request information
+*            SYNC flag
+* OUTPUT   : Returns
+*              IPU_CANCEL_DONE(0)   : cancelled
+*              IPU_CANCEL_WAIT(1)   : waiting for cancelled request to be done
+*              IPU_CANCEL_NO_REQ(2) : target request does not exist
+*============================================================================*/
+struct _IPUIO_MP200_IPU_CANCEL{
+	unsigned long sequence;	/* sequence number of ipu processing demand */
+	int flag;
+	long result_data;	/* processing result                        */
+};
+#define SIZE_IPUIO_MP200_IPU_CANCEL 8
+
+
+/*============================================================================
+* IOCTL    : IMGIO_CONVERT
+* FUNCTION : composite & forward image with IMG
+* INPUT    : input data address, width, height, format, endian, rotation angle,
+*            output data address, endian
+* OUTPUT   :
+*            Return
+*              IMG_COMPLETE(0) : Success
+*              IMG_ERROR(-1)   : Fail
+*=============================================================================*/
+struct _IMG_MODE{
+	unsigned char srcfmt_f;		/* input  image format(FRONT) */
+	unsigned char srcfmt_b;		/* input  image format(BACK) */
+	unsigned char dstfmt;		/* output image format */
+	unsigned char dither_f;		/* enable dither
+					   (in front color depth downsize) */
+	unsigned char dither_b;		/* enable dither
+					   (in back color depth downsize) */
+	unsigned char rfilter_f;	/* enable smooth filter
+					   (in front image zoom) */
+	unsigned char rfilter_b;	/* enable smooth filter
+					   (in back image zoom) */
+	unsigned int  op_mode;		/* op_mode */
+	unsigned char udinv;		/* enable UP/DOWN mirroring */
+	unsigned char rlinv;		/* enable RIGHT/LEFT mirroring */
+	unsigned char msk_col;		/* enable mask color */
+};
+#define SIZE_IMG_MODE 15
+
+struct _IMAGE_DATA{
+	unsigned int  size;	/* image data pitch */
+	unsigned long yrgbadr;	/* Y/RGB data start address (physical) */
+	unsigned long uvadr;	/* UV data start address    (physical) */
+	unsigned long vadr;	/* V data start address     (physical) */
+	unsigned int x;		/* image data x position               */
+	unsigned int y;		/* image data y position               */
+	unsigned int hsize;	/* image data height                   */
+	unsigned int vsize;	/* image data width                    */
+};
+#define SIZE_IMAGE_DATA 32
+
+struct _IMGIO_CONVERT{
+	struct _IMG_MODE     img_mode;	  /* img_mode                        */
+	struct _IMAGE_DATA   src_b_image; /* input  image data(BACK)         */
+	struct _IMAGE_DATA   src_f_image; /* input  image data(FRONT)        */
+	struct _IMAGE_DATA   dest_image;  /* output image data               */
+	unsigned int  offsetx;     /* image offset x
+				      (in front & back composite) */
+	unsigned int  offsety;     /* image offset y
+				      (in front & back composite) */
+	unsigned int  maskcolr;    /* mask color                             */
+	unsigned int  alpha;       /* alpha blending (on maskcolor)          */
+	unsigned long in_byte;     /* input byte                             */
+	unsigned long out_byte;    /* output bute                            */
+	unsigned int  set_matrix;  /* flag if set color-space conversion
+				      matrix */
+				   /*  TRUE: set matrix_conf and matrix[9] */
+				   /* FALSE: use IMG initial value */
+	unsigned long matrix_conf; /* color-space conversion matrix
+					   configuration */
+	unsigned long matrix[9];   /* color-space conversion matrix */
+};
+#define SIZE_IMGIO_CONVERT (SIZE_IMG_MODE+(SIZE_IMAGE_DATA*3)+24+44)
+
+
+/*======================================================================*/
+/* _IMG_MODE  definitions                                               */
+/*======================================================================*/
+/* input front data format & input back data format & output data format*/
+#define IPU_FORM_RGB888             0x0 /* 0000 */
+#define IPU_FORM_RGB666             0x1 /* 0001 */
+#define IPU_FORM_RGB565             0x2 /* 0010 */
+#define IPU_FORM_YUV420_PLANAR      0x4 /* 0100 */
+#define IPU_FORM_YUV420_SEMI_PLANAR 0x5 /* 0101 */
+#define IPU_FORM_YUV422_PLANAR      0x8 /* 1000 */
+#define IPU_FORM_YUV422_SEMI_PLANAR 0x9 /* 1001 */
+#define IPU_FORM_YUV422_INTERLEAVE  0xA /* 1010 */
+
+#define IMG_FORM_RGB888             IPU_FORM_RGB888
+#define IMG_FORM_RGB666             IPU_FORM_RGB666
+#define IMG_FORM_RGB565             IPU_FORM_RGB565
+#define IMG_FORM_YUV420_PLANAR      IPU_FORM_YUV420_PLANAR
+#define IMG_FORM_YUV420_SEMI_PLANAR IPU_FORM_YUV420_SEMI_PLANAR
+#define IMG_FORM_YUV422_PLANAR      IPU_FORM_YUV422_PLANAR
+#define IMG_FORM_YUV422_SEMI_PLANAR IPU_FORM_YUV422_SEMI_PLANAR
+#define IMG_FORM_YUV422_INTERLEAVE  IPU_FORM_YUV422_INTERLEAVE
+
+
+/* input front deta dithering & input back data dithering */
+#define IMG_SET_DITHER_OFF         0x0
+#define IMG_SET_DITHER_ON          0x1
+
+/* filter  */
+#define IMG_SET_RADICAL_FILTER     0x0
+#define IMG_SET_LINEAR_FILTER      0x0
+#define IMG_SET_SMOOTH_FILTER      0x1
+
+/* img mode */
+#define IMG_SET_OP_MODE_00         0x000
+#define IMG_SET_OP_MODE_01         0x010
+#define IMG_SET_OP_MODE_02         0x020
+#define IMG_SET_OP_MODE_03         0x030
+#define IMG_SET_OP_MODE_04         0x040
+#define IMG_SET_OP_MODE_05         0x050
+#define IMG_SET_OP_MODE_06         0x060
+#define IMG_SET_OP_MODE_07         0x070
+#define IMG_SET_OP_MODE_08         0x102
+#define IMG_SET_OP_MODE_09         0x105
+#define IMG_SET_OP_MODE_10         0x113
+#define IMG_SET_OP_MODE_11         0x114
+#define IMG_SET_OP_MODE_12         0x120
+#define IMG_SET_OP_MODE_13         0x127
+#define IMG_SET_OP_MODE_14         0x131
+#define IMG_SET_OP_MODE_15         0x136
+#define IMG_SET_OP_MODE_16         0x141
+#define IMG_SET_OP_MODE_17         0x146
+#define IMG_SET_OP_MODE_18         0x150
+#define IMG_SET_OP_MODE_19         0x157
+#define IMG_SET_OP_MODE_20         0x163
+#define IMG_SET_OP_MODE_21         0x164
+#define IMG_SET_OP_MODE_22         0x172
+#define IMG_SET_OP_MODE_23         0x175
+
+/* output data up-down inverse & output data right-left inverse */
+#define IMG_SET_MIRROR_OFF         0x0
+#define IMG_SET_MIRROR_ON          0x1
+
+/* input front data color no-mask */
+#define IMG_SET_MASKCOLOR_ON       0x0
+#define IMG_SET_MASKCOLOR_OFF      0x1
+
+
+/*======================================================================*/
+/* _IMGIO_CONVERT  definitions                                          */
+/*======================================================================*/
+
+/* input data endian & output data endian  */
+#define IMG_SET_ENDI_BIG           0xB1
+#define IMG_SET_ENDI_LITTLE        0xE4
+
+/*======================================================================*/
+/* IMGIO_CONVERT return definitions                                     */
+/*======================================================================*/
+#define IMG_COMPLETE  0
+#define IMG_ERROR    -1
+
+
+/*============================================================================
+* IOCTL    : ROTIO_ROTATION
+* FUNCTION : rotate image with IPU
+* INPUT    : input data address, width, height, format, endian, rotation angle,
+*            output data address, endian
+* OUTPUT   :
+*            Return
+*              ROT_COMPLETE(0) : Success
+*              ROT_ERROR(-1)   : Fail (IPU busy or parameter error)
+*=============================================================================*/
+struct _ROTIO_ROTATION{
+	unsigned long input_data_addr_y;    /* input Y data  start address
+					       (physical) */
+	unsigned long input_data_addr_uv;   /* input UV data start address
+					       (physical) */
+	unsigned long input_data_addr_v;    /* input V data  start address
+					       (physical) */
+	unsigned int  input_data_size;      /* input data pitch */
+	unsigned int  input_data_width;     /* input data width */
+	unsigned int  input_data_height;    /* input data height */
+	unsigned int  input_data_format;    /* input data format */
+					    /*   ROT_FORM_RGB888 : RGB888   */
+					    /*   ROT_FORM_RGB565 : RGB565   */
+					    /*   ROT_FORM_YUV420_PLANAR
+							: YUV420PLANAR      */
+					    /*   ROT_FORM_YUV420_SEMI_PLANAR
+							: YUV420SEMI_PLANAR */
+					    /*   ROT_FORM_YUV422_SEMI_PLANAR
+							: YUV422SEMI_PLANAR */
+					    /*   ROT_FORM_YUV422_INTERLEAVE
+							: YUV422INTERLEAVE  */
+	unsigned long input_byte;	    /* input bytelane */
+					    /*   ROT_ENDIAN_BIG
+							: big endian        */
+					    /*   ROT_ENDIAN_LITTLE
+							: little endian     */
+	unsigned int  rotation_angle;	    /* rotation angle               */
+					    /*   ROT_ANGLE_0   :  0 degrees */
+					    /*   ROT_ANGLE_90  : 90 degrees */
+					    /*   ROT_ANGLE_180 :180 degrees */
+					    /*   ROT_ANGLE_270 :270 degrees */
+	unsigned long output_data_addr_y;   /* output Y data start address
+					       (physical) */
+	unsigned long output_data_addr_uv;  /* output UV data start address
+					       (physical) */
+	unsigned long output_data_addr_v;   /* output V data start address
+					       (physical) */
+	unsigned int  output_data_size;     /* output data pitch */
+	unsigned int  output_data_format;   /* output data format */
+					    /*   ROT_FORM_RGB888 : RGB888 */
+					    /*   ROT_FORM_RGB565 : RGB565 */
+					    /*   ROT_FORM_YUV420_PLANAR
+							: YUV420PLANAR      */
+					    /*   ROT_FORM_YUV420_SEMI_PLANAR
+							: YUV420SEMI_PLANAR */
+					    /*   ROT_FORM_YUV422_SEMI_PLANAR
+							: YUV422SEMI_PLANAR */
+					    /*   ROT_FORM_YUV422_INTERLEAVE
+							: YUV422INTERLEAVE  */
+	unsigned long output_byte;	    /* output bytelane              */
+					    /*   ROT_ENDIAN_BIG
+							: big endian */
+					    /*   ROT_ENDIAN_LITTLE
+							: little endian */
+};
+#define SIZE_ROTIO_ROTATION 52
+
+
+#define ROT_FORM_RGB888             IPU_FORM_RGB888
+#define ROT_FORM_RGB565             IPU_FORM_RGB565
+#define ROT_FORM_YUV420_PLANAR      IPU_FORM_YUV420_PLANAR
+#define ROT_FORM_YUV420_SEMI_PLANAR IPU_FORM_YUV420_SEMI_PLANAR
+#define ROT_FORM_YUV422_SEMI_PLANAR IPU_FORM_YUV422_SEMI_PLANAR
+#define ROT_FORM_YUV422_INTERLEAVE  IPU_FORM_YUV422_INTERLEAVE
+
+#define ROT_ENDIAN_BIG              0xB1
+#define ROT_ENDIAN_LITTLE           0xE4
+
+#define ROT_ANGLE_0                 0
+#define ROT_ANGLE_90                1
+#define ROT_ANGLE_180               2
+#define ROT_ANGLE_270               3
+
+#define ROT_COMPLETE  0
+#define ROT_ERROR    -1
+
+
+#define MAX_SIZE_IPUIOCTL SIZE_IMGIO_CONVERT
+
+#endif /* _IPU_USER_H_ */
diff --git a/arch/arm/mach-mp200/include/mach/mmu.h b/arch/arm/mach-mp200/include/mach/mmu.h
new file mode 100644
index 0000000..a4c2229
--- /dev/null
+++ b/arch/arm/mach-mp200/include/mach/mmu.h
@@ -0,0 +1,206 @@
+/*
+*  File Name       : /include/asm-arm/arch-mp200/MMU.h
+*  Function        : IPU MMIO definitions, and Driver - Driver I/F of IPU driver
+*  Release Version : Ver 1.00
+*  Release Date    : 2006/11/20
+*
+*  Copyright (C) NEC Electronics Corporation 2006
+*
+*
+*  This program is free software;you can redistribute it and/or modify it
+*  under the terms of the GNU General Public License as published by Free
+*  Softwere Foundation; either version 2 of License, or (at your option)
+*  any later version.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY;
+*  without even the implied warrnty of MERCHANTABILITY or
+*  FITNESS FOR A PARTICULAR PURPOSE.
+*  See the GNU General Public License for more details.
+*
+*  You should have received a copy of the GNU General Public License
+*  along with this program;
+*  If not, write to the Free Software Foundation, Inc.,
+*  59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+*
+*/
+
+/* History */
+/*-----------+------+------------------+-------------------+-----------------*/
+/* Date      |Rev.No|Name              |KeyWord            | Reason          */
+/*-----------+------+------------------+-------------------+-----------------*/
+/* 2006/11/20| 1.00 | M.Sasaki         |                   |                 */
+/*-----------+------+------------------+-------------------+-----------------*/
+/* 2007/02/22|      | Y.Utsuhara       |                   |                 */
+/*-----------+------+------------------+-------------------+-----------------*/
+
+#ifndef _MMU_H_
+#define _MMU_H_
+
+
+/*===============================================================*/
+/* MMU register bit assigns                                      */
+/*===============================================================*/
+
+/*------------------------------*/
+/* IMG_MMU_MODE                 */
+/*------------------------------*/
+#define IMG_MMU_DST_EN_BIT          0x00040000
+#define IMG_MMU_DST_EN_SFT          18
+
+#define IMG_MMU_SRC2_EN_BIT         0x00020000
+#define IMG_MMU_SRC2_EN_SFT         17
+
+#define IMG_MMU_SRC1_EN_BIT         0x00010000
+#define IMG_MMU_SRC1_EN_SFT         16
+
+#define IMG_MMU_CHK_PERMISSION_BIT  0x00000020
+#define IMG_MMU_CHK_PERMISSION_SFT  5
+
+#define IMG_MMU_CHK_PAGEMODE_BIT    0x00000010
+#define IMG_MMU_CHK_PAGEMODE_SFT    4
+
+#define IMG_MMU_PRMMODE_BIT         0x00000008
+#define IMG_MMU_PRMMODE_SFT         3
+
+#define IMG_MMU_ARMMODE_BIT         0x00000004
+#define IMG_MMU_ARMMODE_SFT         2
+
+#define IMG_MMU_PAGEMODE_BIT        0x00000002
+#define IMG_MMU_PAGEMODE_SFT        1
+
+#define IMG_MMU_EN_BIT              0x00000001
+#define IMG_MMU_EN_SFT              0
+
+
+/*------------------------------*/
+/* ROT_MMU_MODE                 */
+/*------------------------------*/
+#define ROT_MMU_DST_EN_BIT          0x00020000
+#define ROT_MMU_DST_EN_SFT          17
+
+#define ROT_MMU_SRC_EN_BIT          0x00010000
+#define ROT_MMU_SRC_EN_SFT          16
+
+#define ROT_MMU_CHK_PERMISSION_BIT  0x00000020
+#define ROT_MMU_CHK_PERMISSION_SFT  5
+
+#define ROT_MMU_CHK_PAGEMODE_BIT    0x00000010
+#define ROT_MMU_CHK_PAGEMODE_SFT    4
+
+#define ROT_MMU_PRMMODE_BIT         0x00000008
+#define ROT_MMU_PRMMODE_SFT         3
+
+#define ROT_MMU_ARMMODE_BIT         0x00000004
+#define ROT_MMU_ARMMODE_SFT         2
+
+#define ROT_MMU_PAGEMODE_BIT        0x00000002
+#define ROT_MMU_PAGEMODE_SFT        1
+
+#define ROT_MMU_EN_BIT              0x00000001
+#define ROT_MMU_EN_SFT              0
+
+
+/*------------------------------*/
+/* DMA_MMU_MODE                 */
+/*------------------------------*/
+#define DMA_MMU_DST_EN_BIT          0x00040000
+#define DMA_MMU_DST_EN_SFT          18
+
+#define DMA_MMU_SRC2_EN_BIT         0x00020000
+#define DMA_MMU_SRC2_EN_SFT         17
+
+#define DMA_MMU_SRC1_EN_BIT         0x00010000
+#define DMA_MMU_SRC1_EN_SFT         16
+
+#define DMA_MMU_CHK_PERMISSION_BIT  0x00000020
+#define DMA_MMU_CHK_PERMISSION_SFT  5
+
+#define DMA_MMU_CHK_PAGEMODE_BIT    0x00000010
+#define DMA_MMU_CHK_PAGEMODE_SFT    4
+
+#define DMA_MMU_PRMMODE_BIT         0x00000008
+#define DMA_MMU_PRMMODE_SFT         3
+
+#define DMA_MMU_ARMMODE_BIT         0x00000004
+#define DMA_MMU_ARMMODE_SFT         2
+
+#define DMA_MMU_PAGEMODE_BIT        0x00000002
+#define DMA_MMU_PAGEMODE_SFT        1
+
+#define DMA_MMU_EN_BIT              0x00000001
+#define DMA_MMU_EN_SFT              0
+
+
+/*------------------------------*/
+/* IMG_MMU_STATUS1              */
+/* ROT_MMU_STATUS1              */
+/* DMA_MMU_STATUS1              */
+/*------------------------------*/
+#define MMU_STATUS1_VA_BIT          0xFFFFFFFF
+#define MMU_STATUS1_VA_SFT          0
+
+
+/*------------------------------*/
+/* IMG_MMU_STATUS2              */
+/* ROT_MMU_STATUS2              */
+/* DMA_MMU_STATUS2              */
+/*------------------------------*/
+#define MMU_STATUS2_SBA_BIT         0xFFFFF000
+#define MMU_STATUS2_SBA_SFT         12
+
+#define MMU_STATUS2_SAP_BIT         0x0000000C
+#define MMU_STATUS2_SAP_SFT         2
+
+#define MMU_STATUS2_SPM_BIT         0x00000001
+#define MMU_STATUS2_SPM_SFT         0
+
+
+/*------------------------------*/
+/* IMG_MMU_CTRL                 */
+/* ROT_MMU_CTRL                 */
+/* DMA_MMU_CTRL                 */
+/*------------------------------*/
+#define MMU_CTRL_IAE_BIT            0x00000001
+#define MMU_CTRL_IAE_SFT            0
+
+
+/*------------------------------*/
+/* IMG_MMU_1Dx                  */
+/* ROT_MMU_1Dx                  */
+/* DMA_MMU_1Dx                  */
+/*------------------------------*/
+#define MMU_F_BA_x_BIT              0xFFFFFC00
+#define MMU_F_BA_x_SFT              10
+
+
+/*------------------------------*/
+/* IMG_MMU_INDEXx               */
+/* ROT_MMU_INDEXx               */
+/* DMA_MMU_INDEXx               */
+/*------------------------------*/
+#define MMU_F_INDX_x_BIT            0xFFF00000
+#define MMU_F_INDX_x_SFT            20
+
+#define MMU_F_VLD_x_BIT             0x00000001
+#define MMU_F_VLD_x_SFT             0
+
+
+#define IMG_MMU_MODE_PRESET         (1 << IMG_MMU_CHK_PERMISSION_SFT | \
+				     1 << IMG_MMU_CHK_PAGEMODE_SFT   | \
+				     0 << IMG_MMU_PRMMODE_SFT        |	\
+				     0 << IMG_MMU_ARMMODE_SFT        |	\
+				     0 << IMG_MMU_PAGEMODE_SFT)
+#define ROT_MMU_MODE_PRESET         (1 << ROT_MMU_CHK_PERMISSION_SFT | \
+				     1 << ROT_MMU_CHK_PAGEMODE_SFT   | \
+				     0 << ROT_MMU_PRMMODE_SFT        | \
+				     0 << ROT_MMU_ARMMODE_SFT        |	\
+				     0 << ROT_MMU_PAGEMODE_SFT)
+#define DMA_MMU_MODE_PRESET         (1 << DMA_MMU_CHK_PERMISSION_SFT | \
+				     1 << DMA_MMU_CHK_PAGEMODE_SFT   | \
+				     0 << DMA_MMU_PRMMODE_SFT        | \
+				     0 << DMA_MMU_ARMMODE_SFT        |	\
+				     0 << DMA_MMU_PAGEMODE_SFT)
+
+
+#endif /* _MMU_H_ */
diff --git a/arch/arm/mach-mp200/include/mach/rot.h b/arch/arm/mach-mp200/include/mach/rot.h
new file mode 100644
index 0000000..cbb6918
--- /dev/null
+++ b/arch/arm/mach-mp200/include/mach/rot.h
@@ -0,0 +1,729 @@
+/*
+*  File Name       : /include/asm-arm/arch-mp200/IPU.h
+*  Function        : ROT MMIO definitions, and Driver - Driver I/F of IPU driver
+*  Release Version : Ver 1.00
+*  Release Date    : 2006/11/20
+*
+*  Copyright (C) NEC Electronics Corporation 2006
+*
+*
+*  This program is free software;you can redistribute it and/or modify it
+*  under the terms of
+*  the GNU General Public License as published by Free Softwere Foundation;
+*  either version 2 of License, or (at your option) any later version.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY;
+*  without even the implied warrnty of MERCHANTABILITY or
+*  FITNESS FOR A PARTICULAR PURPOSE.
+*  See the GNU General Public License for more details.
+*
+*  You should have received a copy of the GNU General Public
+*  License along with this program;
+*  If not, write to the Free Software Foundation,
+*  Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+*
+*/
+
+/* History */
+/*-----------+------+------------------+-------------------+---------------*/
+/* Date      |Rev.No|Name              |KeyWord            | Reason        */
+/*-----------+------+------------------+-------------------+---------------*/
+/* 2006/11/20| 1.00 | M.Sasaki         |                   |               */
+/*-----------+------+------------------+-------------------+---------------*/
+/* 2008/03/13|      | M.Sasaki         |                   |               */
+/*-----------+------+------------------+-------------------+---------------*/
+
+#ifndef _ROT_H_
+#define _ROT_H_
+
+/*===============================================================*/
+/* ROT MMIO definitions   for uPD77601                           */
+/*===============================================================*/
+#include <mach/hardware.h>
+#define ROTATOR_OFFSET    MP200_ROTATOR_OFFSET
+#define ROTATOR_BASE      MP200_ROTATOR_BASE
+#define ROTATOR_SIZE      MP200_ROTATOR_SIZE
+
+
+/*===============================================================*/
+/* ROT register definitions   for uPD77601                       */
+/*===============================================================*/
+/*                                       R/W   Bit  Reset */
+/* Mode for ROTATOR                      R/W   5:0  0x00 */
+#define ROT_MODE                 (0x00)
+
+/* Frame Select                          R/W   3:0  0x5 */
+#define ROT_FRAME                (0x04)
+
+/* Rotate Request                         W    0:0  0x0 */
+#define ROT_REQ                  (0x08)
+
+/* Status for ROTATOR                     R    0:0  0x0 */
+#define ROT_STATUS               (0x0C)
+
+/* Original Address Size                 R/W  10:2  0x000 */
+#define ROT_SRCSIZE              (0x20)
+
+/* Rotate Address Size                   R/W  10:2  0x000 */
+#define ROT_DSTSIZE              (0x24)
+
+/* Original Y Address for A Frame        R/W  30:2  0x0000_0000 */
+#define ROT_SRCYADR_A            (0x30)
+
+/* Original Y Address for B Frame        R/W  30:2  0x0000_0000 */
+#define ROT_SRCYADR_B            (0x34)
+
+/* Original Y Address for C Frame        R/W  30:2  0x0000_0000 */
+#define ROT_SRCYADR_C            (0x38)
+
+/* Rotate Y Address for A Frame          R/W  30:2  0x0000_0000 */
+#define ROT_DSTYADR_A            (0x40)
+
+/* Rotate Y Address for B Frame          R/W  30:2  0x0000_0000 */
+#define ROT_DSTYADR_B            (0x44)
+
+/* Rotate Y Address for C Frame          R/W  30:2  0x0000_0000 */
+#define ROT_DSTYADR_C            (0x48)
+
+/* Original UV Address for A Frame       R/W  30:2  0x0000_0000 */
+#define ROT_SRCUVADR_A           (0x60)
+
+/* Original UV Address for B Frame       R/W  30:2  0x0000_0000 */
+#define ROT_SRCUVADR_B           (0x64)
+
+/* Original UV Address for C Frame       R/W  30:2  0x0000_0000 */
+#define ROT_SRCUVADR_C           (0x68)
+
+/* Rotate UV Address for A Frame         R/W  30:2  0x0000_0000 */
+#define ROT_DSTUVADR_A           (0x70)
+
+/* Rotate UV Address for B Frame         R/W  30:2  0x0000_0000 */
+#define ROT_DSTUVADR_B           (0x74)
+
+/* Rotate UV Address for C Frame         R/W  30:2  0x0000_0000 */
+#define ROT_DSTUVADR_C           (0x78)
+
+/* Horizontal Size                       R/W  10:2  0x008 */
+#define ROT_SRCHSIZE             (0x90)
+
+/* Vertical Size                         R/W  10:2  0x008 */
+#define ROT_SRCVSIZE             (0xA0)
+
+/* Interrupt Status                       R    4:0  0x0 */
+#define ROT_INTSTATUS            (0xB0)
+
+/* Interrupt Raw Status                   R    2:0  0x0 */
+#define ROT_INTRAWSTATUS         (0xB4)
+
+/* Interrupt Enable Set                  R/W   2:0  0x0 */
+#define ROT_INTENSET             (0xB8)
+
+/* Interrupt Enable Clear                 W    2:0  0x0 */
+#define ROT_INTENCLR             (0xBC)
+
+/* Interrupt Status Clear                 W    2:0  0x0 */
+#define ROT_INTFFCLR             (0xC0)
+
+/* DMA Error Respons Address             R/W  31:0  0x0000_0000 */
+#define ROT_ERRORADR             (0xC4)
+
+/* Image format                          R/W   7:0  0x0 */
+#define ROT_FORMAT               (0xC8)
+
+/* BYTE lane for the source image        R/W   7:0  0xE4 */
+#define ROT_SRCBYTE              (0xCC)
+
+/* BYTE lane for the destination image   R/W   7:0  0xE4 */
+#define ROT_DSTBYTE              (0xD0)
+
+/* V Plane Address for the source image  R/W  30:2  0x0000_0000 */
+#define ROT_SRCVADR_A            (0xD4)
+
+/* V Plane Address for the source image  R/W  30:2  0x0000_0000 */
+#define ROT_SRCVADR_B            (0xD8)
+
+/* V Plane Address for the source image  R/W  30:2  0x0000_0000 */
+#define ROT_SRCVADR_C            (0xDC)
+
+/* V Plane Address for the rotator image R/W  30:2  0x0000_0000 */
+#define ROT_DSTVADR_A            (0xE0)
+
+/* V Plane Address for the rotator image R/W  30:2  0x0000_0000 */
+#define ROT_DSTVADR_B            (0xE4)
+
+/* V Plane Address for the rotator image R/W  30:2  0x0000_0000 */
+#define ROT_DSTVADR_C            (0xE8)
+
+/* Register update reservation setting   R/W   0:0  0x0 */
+#define ROT_DUAL_FF              (0xEC)
+
+/* BYTE lane for the source image        R/W  15:0  0xE4E4 */
+#define ROT_SRCBYTE_CMP          (0xF0)
+
+/* BYTE lane for the destination image   R/W  15:0  0xE4E4 */
+#define ROT_DSTBYTE_CMP          (0xF4)
+
+
+
+/*===============================================================*/
+/* ROT register bit assigns                                      */
+/*===============================================================*/
+
+/*------------------------------*/
+/* ROT_MODE                     */
+/*------------------------------*/
+#define ROT_NEWEN_BIT           0x00000020
+#define ROT_NEWEN_SFT           0x5
+
+#define ROT_SRCENDIAN_BIT       0x00000010
+#define ROT_SRCENDIAN_SFT       0x4
+#define ROT_SRCENDIAN_BIG       0x00000000
+#define ROT_SRCENDIAN_LITTLE    0x00000010
+
+#define ROT_DSTENDIAN_BIT       0x00000008
+#define ROT_DSTENDIAN_SFT       0x3
+#define ROT_DSTENDIAN_BIG       0x00000000
+#define ROT_DSTENDIAN_LITTLE    0x00000008
+
+#define ROT_SRCYUV_BIT          0x00000004
+#define ROT_SRCYUV_SFT          0x2
+#define ROT_SRCYUV_YUV422       0x00000000
+#define ROT_SRCYUV_YUV420       0x00000004
+
+#define ROT_MOD_BIT             0x00000003
+#define ROT_MOD_SFT             0x0
+#define ROT_MOD_0               0x00000000
+#define ROT_MOD_90              0x00000001
+#define ROT_MOD_180             0x00000002
+#define ROT_MOD_270             0x00000003
+
+
+/*------------------------------*/
+/* ROT_FRAME                    */
+/*------------------------------*/
+#define ROT_DSTSEL_BIT          0x0000000C
+#define ROT_DSTSEL_SFT          0x2
+#define ROT_DSTSEL_FRAME_A      0x00000004
+#define ROT_DSTSEL_FRAME_B      0x00000008
+#define ROT_DSTSEL_FRAME_C      0x0000000C
+
+#define ROT_SRCSEL_BIT          0x00000003
+#define ROT_SRCSEL_SFT          0x0
+#define ROT_SRCSEL_FRAME_A      0x00000001
+#define ROT_SRCSEL_FRAME_B      0x00000002
+#define ROT_SRCSEL_FRAME_C      0x00000003
+
+
+/*------------------------------*/
+/* ROT_REQ                      */
+/*------------------------------*/
+#define ROT_REQ_BIT             0x00000001
+#define ROT_REQ_SFT             0x0
+
+
+/*------------------------------*/
+/* ROT_STATUS                   */
+/*------------------------------*/
+#define ROT_STATUS_BIT          0x00000001
+#define ROT_STATUS_SFT          0x0
+
+
+/*------------------------------*/
+/* ROT_SRCSIZE                  */
+/*------------------------------*/
+#define ROT_SRCSIZE_BIT         0x00000FFF
+#define ROT_SRCSIZE_SFT         0x2
+
+
+/*------------------------------*/
+/* ROT_DSTSIZE                  */
+/*------------------------------*/
+#define ROT_DSTSIZE_BIT         0x00000FFF
+#define ROT_DSTSIZE_SFT         0x2
+
+
+/*------------------------------*/
+/* ROT_SRCYADR_A                */
+/*------------------------------*/
+#define ROT_SRCYADR_A_BIT       0xFFFFFFFFF
+#define ROT_SRCYADR_A_SFT       0x2
+
+
+/*------------------------------*/
+/* ROT_DSTYADR_A                */
+/*------------------------------*/
+#define ROT_DSTYADR_A_BIT       0xFFFFFFFFF
+#define ROT_DSTYADR_A_SFT       0x2
+
+
+/*------------------------------*/
+/* ROT_SRCYADR_B                */
+/*------------------------------*/
+#define ROT_SRCYADR_B_BIT       0xFFFFFFFFF
+#define ROT_SRCYADR_B_SFT       0x2
+
+
+/*------------------------------*/
+/* ROT_DSTYADR_B                */
+/*------------------------------*/
+#define ROT_DSTYADR_B_BIT       0xFFFFFFFFF
+#define ROT_DSTYADR_B_SFT       0x2
+
+
+/*------------------------------*/
+/* ROT_SRCYADR_C                */
+/*------------------------------*/
+#define ROT_SRCYADR_C_BIT       0xFFFFFFFFF
+#define ROT_SRCYADR_C_SFT       0x2
+
+
+/*------------------------------*/
+/* ROT_DSTYADR_C                */
+/*------------------------------*/
+#define ROT_DSTYADR_C_BIT       0xFFFFFFFFF
+#define ROT_DSTYADR_C_SFT       0x2
+
+
+/*------------------------------*/
+/* ROT_SRCUVADR_A                */
+/*------------------------------*/
+#define ROT_SRCUVADR_A_BIT      0xFFFFFFFFF
+#define ROT_SRCUVADR_A_SFT      0x2
+
+
+/*------------------------------*/
+/* ROT_DSTUVADR_A                */
+/*------------------------------*/
+#define ROT_DSTUVADR_A_BIT      0xFFFFFFFFF
+#define ROT_DSTUVADR_A_SFT      0x2
+
+
+/*------------------------------*/
+/* ROT_SRCUVADR_B                */
+/*------------------------------*/
+#define ROT_SRCUVADR_B_BIT      0xFFFFFFFFF
+#define ROT_SRCUVADR_B_SFT      0x2
+
+
+/*------------------------------*/
+/* ROT_DSTUVADR_B                */
+/*------------------------------*/
+#define ROT_DSTUVADR_B_BIT      0xFFFFFFFFF
+#define ROT_DSTUVADR_B_SFT      0x2
+
+
+/*------------------------------*/
+/* ROT_SRCUVADR_C                */
+/*------------------------------*/
+#define ROT_SRCUVADR_C_BIT      0xFFFFFFFFF
+#define ROT_SRCUVADR_C_SFT      0x2
+
+
+/*------------------------------*/
+/* ROT_DSTUVADR_C                */
+/*------------------------------*/
+#define ROT_DSTUVADR_C_BIT      0xFFFFFFFFF
+#define ROT_DSTUVADR_C_SFT      0x2
+
+
+/*------------------------------*/
+/* ROT_SRCVADR_A                */
+/*------------------------------*/
+#define ROT_SRCVADR_A_BIT       0xFFFFFFFFF
+#define ROT_SRCVADR_A_SFT       0x2
+
+
+/*------------------------------*/
+/* ROT_DSTVADR_A                */
+/*------------------------------*/
+#define ROT_DSTVADR_A_BIT       0xFFFFFFFFF
+#define ROT_DSTVADR_A_SFT       0x2
+
+
+/*------------------------------*/
+/* ROT_SRCVADR_B                */
+/*------------------------------*/
+#define ROT_SRCVADR_B_BIT       0xFFFFFFFFF
+#define ROT_SRCVADR_B_SFT       0x2
+
+
+/*------------------------------*/
+/* ROT_DSTVADR_B                */
+/*------------------------------*/
+#define ROT_DSTVADR_B_BIT       0xFFFFFFFFF
+#define ROT_DSTVADR_B_SFT       0x2
+
+
+/*------------------------------*/
+/* ROT_SRCVADR_C                */
+/*------------------------------*/
+#define ROT_SRCVADR_C_BIT       0xFFFFFFFFF
+#define ROT_SRCVADR_C_SFT       0x2
+
+
+/*------------------------------*/
+/* ROT_DSTVADR_C                */
+/*------------------------------*/
+#define ROT_DSTVADR_C_BIT       0xFFFFFFFFF
+#define ROT_DSTVADR_C_SFT       0x2
+
+
+/*------------------------------*/
+/* ROT_SRCHSIZE                 */
+/*------------------------------*/
+#define ROT_SRCHSIZE_BIT        0x00000FFF
+#define ROT_SRCHSIZE_SFT        0x2
+
+
+/*------------------------------*/
+/* ROT_SRCVSIZE                 */
+/*------------------------------*/
+#define ROT_SRCVSIZE_BIT        0x00000FFF
+#define ROT_SRCVSIZE_SFT        0x2
+
+
+/*------------------------------*/
+/* ROT_INTSTATUS                */
+/*------------------------------*/
+#define ROT_ACTIVE_BIT          0x00000010
+#define ROT_ACTIVE_SFT          0x04
+
+#define ROT_DFF_RSV_BIT         0x00000008
+#define ROT_DFF_RSV_SFT         0x03
+
+#define ROT_DMASTOP_BIT         0x00000004
+#define ROT_DMASTOP_SFT         0x02
+
+#define ROT_DMAERR_BIT          0x00000002
+#define ROT_DMAERR_SFT          0x01
+
+#define ROT_ROTEND_BIT          0x00000001
+#define ROT_ROTEND_SFT          0x00
+
+
+/*------------------------------*/
+/* ROT_INTRAWSTATUS             */
+/*------------------------------*/
+#define ROT_DMASTOPRAW_BIT      0x00000004
+#define ROT_DMASTOPRAW_SFT      0x02
+
+#define ROT_DMAERRRAW_BIT       0x00000002
+#define ROT_DMAERRRAW_SFT       0x01
+
+#define ROT_ROTENDRAW_BIT       0x00000001
+#define ROT_ROTENDRAW_SFT       0x00
+
+
+/*------------------------------*/
+/* ROT_INTENSET                 */
+/*------------------------------*/
+#define ROT_DMASTOPEN_BIT       0x00000004
+#define ROT_DMASTOPEN_SFT       0x02
+
+#define ROT_DMAERREN_BIT        0x00000002
+#define ROT_DMAERREN_SFT        0x01
+
+#define ROT_ROTENDEN_BIT        0x00000001
+#define ROT_ROTENDEN_SFT        0x00
+
+
+/*------------------------------*/
+/* ROT_INTENCLR                 */
+/*------------------------------*/
+#define ROT_DMASTOPMASK_BIT     0x00000004
+#define ROT_DMASTOPMASK_SFT     0x02
+
+#define ROT_DMAERRMASK_BIT      0x00000002
+#define ROT_DMAERRMASK_SFT      0x01
+
+#define ROT_ROTENDMASK_BIT      0x00000001
+#define ROT_ROTENDMASK_SFT      0x00
+
+
+/*------------------------------*/
+/* ROT_INTFFCLR                 */
+/*------------------------------*/
+#define ROT_DMASTOPCLR_BIT      0x00000004
+#define ROT_DMASTOPCLR_SFT      0x02
+
+#define ROT_DMAERRCLR_BIT       0x00000002
+#define ROT_DMAERRCLR_SFT       0x01
+
+#define ROT_ROTENDCLR_BIT       0x00000001
+#define ROT_ROTENDCLR_SFT       0x00
+
+
+/*------------------------------*/
+/* ROT_ERRORADR                 */
+/*------------------------------*/
+#define ROT_ERRADR_BIT          0xFFFFFFFC
+#define ROT_ERRADR_SFT          0x2
+
+#define ROT_LOCK_BIT            0x00000001
+#define ROT_LOCK_SFT            0x0
+
+
+/*------------------------------*/
+/* ROT_FORMAT                   */
+/* (temporary declaration)      */
+/*------------------------------*/
+#define ROT_FORMAT_RGB888             0x0
+#define ROT_FORMAT_RGB565             0x2
+#define ROT_FORMAT_YUV420_PLANAR      0x4
+#define ROT_FORMAT_YUV420_SEMI_PLANAR 0x5
+#define ROT_FORMAT_YUV422_SEMI_PLANAR 0x9
+#define ROT_FORMAT_YUV422_INTERLEAVE  0xA
+
+/*------------------------------*/
+/* ROT_FORMAT                   */
+/*------------------------------*/
+#define ROT_DSTFMT_BIT 0x000000F0
+#define ROT_DSTFMT_SFT 0x4
+#define ROT_DSTFMT_RGB888 \
+	(ROT_FORMAT_RGB888 << ROT_DSTFMT_SFT)
+#define ROT_DSTFMT_RGB565 \
+	(ROT_FORMAT_RGB565 << ROT_DSTFMT_SFT)
+#define ROT_DSTFMT_YUV420_PLANAR \
+	(ROT_FORMAT_YUV420_PLANAR << ROT_DSTFMT_SFT)
+#define ROT_DSTFMT_YUV420_SEMI_PLANAR \
+	(ROT_FORMAT_YUV420_SEMI_PLANAR << ROT_DSTFMT_SFT)
+#define ROT_DSTFMT_YUV422_SEMI_PLANAR \
+	(ROT_FORMAT_YUV422_SEMI_PLANAR << ROT_DSTFMT_SFT)
+#define ROT_DSTFMT_YUV422_INTERLEAVE \
+	(ROT_FORMAT_YUV422_INTERLEAVE << ROT_DSTFMT_SFT)
+
+#define ROT_SRCFMT_BIT 0x0000000F
+#define ROT_SRCFMT_SFT 0x0
+#define ROT_SRCFMT_RGB888 \
+	(ROT_FORMAT_RGB888 << ROT_SRCFMT_SFT)
+#define ROT_SRCFMT_RGB565 \
+	(ROT_FORMAT_RGB565 << ROT_SRCFMT_SFT)
+#define ROT_SRCFMT_YUV420_PLANAR \
+	(ROT_FORMAT_YUV420_PLANAR << ROT_SRCFMT_SFT)
+#define ROT_SRCFMT_YUV420_SEMI_PLANAR  \
+	(ROT_FORMAT_YUV420_SEMI_PLANAR << ROT_SRCFMT_SFT)
+#define ROT_SRCFMT_YUV422_SEMI_PLANAR \
+	(ROT_FORMAT_YUV422_SEMI_PLANAR << ROT_SRCFMT_SFT)
+#define ROT_SRCFMT_YUV422_INTERLEAVE \
+	(ROT_FORMAT_YUV422_INTERLEAVE << ROT_SRCFMT_SFT)
+
+
+/*------------------------------*/
+/* BYTELANE                     */
+/* (temporary declaration)      */
+/*------------------------------*/
+#define ROT_BYTELANE_DATAx_BYTE0  0x0
+#define ROT_BYTELANE_DATAx_BYTE1  0x1
+#define ROT_BYTELANE_DATAx_BYTE2  0x2
+#define ROT_BYTELANE_DATAx_BYTE3  0x3
+
+/*------------------------------*/
+/* ROT_SRCBYTE                  */
+/*------------------------------*/
+#define ROT_SRCBYTE_DATA3_BIT 0x000000C0
+#define ROT_SRCBYTE_DATA3_SFT 0x6
+#define ROT_SRCBYTE_DATA3_BYTE0 \
+	(ROT_BYTELANE_DATAx_BYTE0 << ROT_SRCBYTE_DATA3_SFT)
+#define ROT_SRCBYTE_DATA3_BYTE1 \
+	(ROT_BYTELANE_DATAx_BYTE1 << ROT_SRCBYTE_DATA3_SFT)
+#define ROT_SRCBYTE_DATA3_BYTE2 \
+	(ROT_BYTELANE_DATAx_BYTE2 << ROT_SRCBYTE_DATA3_SFT)
+#define ROT_SRCBYTE_DATA3_BYTE3 \
+	(ROT_BYTELANE_DATAx_BYTE3 << ROT_SRCBYTE_DATA3_SFT)
+
+#define ROT_SRCBYTE_DATA2_BIT 0x00000030
+#define ROT_SRCBYTE_DATA2_SFT 0x4
+#define ROT_SRCBYTE_DATA2_BYTE0 \
+	(ROT_BYTELANE_DATAx_BYTE0 << ROT_SRCBYTE_DATA2_SFT)
+#define ROT_SRCBYTE_DATA2_BYTE1 \
+	(ROT_BYTELANE_DATAx_BYTE1 << ROT_SRCBYTE_DATA2_SFT)
+#define ROT_SRCBYTE_DATA2_BYTE2 \
+	(ROT_BYTELANE_DATAx_BYTE2 << ROT_SRCBYTE_DATA2_SFT)
+#define ROT_SRCBYTE_DATA2_BYTE3 \
+	(ROT_BYTELANE_DATAx_BYTE3 << ROT_SRCBYTE_DATA2_SFT)
+
+#define ROT_SRCBYTE_DATA1_BIT 0x0000000C
+#define ROT_SRCBYTE_DATA1_SFT 0x2
+#define ROT_SRCBYTE_DATA1_BYTE0 \
+	(ROT_BYTELANE_DATAx_BYTE0 << ROT_SRCBYTE_DATA1_SFT)
+#define ROT_SRCBYTE_DATA1_BYTE1 \
+	(ROT_BYTELANE_DATAx_BYTE1 << ROT_SRCBYTE_DATA1_SFT)
+#define ROT_SRCBYTE_DATA1_BYTE2 \
+	(ROT_BYTELANE_DATAx_BYTE2 << ROT_SRCBYTE_DATA1_SFT)
+#define ROT_SRCBYTE_DATA1_BYTE3 \
+	(ROT_BYTELANE_DATAx_BYTE3 << ROT_SRCBYTE_DATA1_SFT)
+
+#define ROT_SRCBYTE_DATA0_BIT 0x00000003
+#define ROT_SRCBYTE_DATA0_SFT 0x0
+#define ROT_SRCBYTE_DATA0_BYTE0 \
+	(ROT_BYTELANE_DATAx_BYTE0 << ROT_SRCBYTE_DATA0_SFT)
+#define ROT_SRCBYTE_DATA0_BYTE1 \
+	(ROT_BYTELANE_DATAx_BYTE1 << ROT_SRCBYTE_DATA0_SFT)
+#define ROT_SRCBYTE_DATA0_BYTE2 \
+	(ROT_BYTELANE_DATAx_BYTE2 << ROT_SRCBYTE_DATA0_SFT)
+#define ROT_SRCBYTE_DATA0_BYTE3 \
+	(ROT_BYTELANE_DATAx_BYTE3 << ROT_SRCBYTE_DATA0_SFT)
+
+
+/*------------------------------*/
+/* ROT_DSTBYTE                  */
+/*------------------------------*/
+#define ROT_DSTBYTE_DATA3_BIT 0x000000C0
+#define ROT_DSTBYTE_DATA3_SFT 0x6
+#define ROT_DSTBYTE_DATA3_BYTE0 \
+	(ROT_BYTELANE_DATAx_BYTE0 << ROT_DSTBYTE_DATA3_SFT)
+#define ROT_DSTBYTE_DATA3_BYTE1 \
+	(ROT_BYTELANE_DATAx_BYTE1 << ROT_DSTBYTE_DATA3_SFT)
+#define ROT_DSTBYTE_DATA3_BYTE2 \
+	(ROT_BYTELANE_DATAx_BYTE2 << ROT_DSTBYTE_DATA3_SFT)
+#define ROT_DSTBYTE_DATA3_BYTE3 \
+	(ROT_BYTELANE_DATAx_BYTE3 << ROT_DSTBYTE_DATA3_SFT)
+
+#define ROT_DSTBYTE_DATA2_BIT 0x00000030
+#define ROT_DSTBYTE_DATA2_SFT 0x4
+#define ROT_DSTBYTE_DATA2_BYTE0 \
+	(ROT_BYTELANE_DATAx_BYTE0 << ROT_DSTBYTE_DATA2_SFT)
+#define ROT_DSTBYTE_DATA2_BYTE1 \
+	(ROT_BYTELANE_DATAx_BYTE1 << ROT_DSTBYTE_DATA2_SFT)
+#define ROT_DSTBYTE_DATA2_BYTE2 \
+	(ROT_BYTELANE_DATAx_BYTE2 << ROT_DSTBYTE_DATA2_SFT)
+#define ROT_DSTBYTE_DATA2_BYTE3 \
+	(ROT_BYTELANE_DATAx_BYTE3 << ROT_DSTBYTE_DATA2_SFT)
+
+#define ROT_DSTBYTE_DATA1_BIT 0x0000000C
+#define ROT_DSTBYTE_DATA1_SFT 0x2
+#define ROT_DSTBYTE_DATA1_BYTE0 \
+	(ROT_BYTELANE_DATAx_BYTE0 << ROT_DSTBYTE_DATA1_SFT)
+#define ROT_DSTBYTE_DATA1_BYTE1 \
+	(ROT_BYTELANE_DATAx_BYTE1 << ROT_DSTBYTE_DATA1_SFT)
+#define ROT_DSTBYTE_DATA1_BYTE2 \
+	(ROT_BYTELANE_DATAx_BYTE2 << ROT_DSTBYTE_DATA1_SFT)
+#define ROT_DSTBYTE_DATA1_BYTE3 \
+	(ROT_BYTELANE_DATAx_BYTE3 << ROT_DSTBYTE_DATA1_SFT)
+
+#define ROT_DSTBYTE_DATA0_BIT 0x00000003
+#define ROT_DSTBYTE_DATA0_SFT 0x0
+#define ROT_DSTBYTE_DATA0_BYTE0 \
+	(ROT_BYTELANE_DATAx_BYTE0 << ROT_DSTBYTE_DATA0_SFT)
+#define ROT_DSTBYTE_DATA0_BYTE1 \
+	(ROT_BYTELANE_DATAx_BYTE1 << ROT_DSTBYTE_DATA0_SFT)
+#define ROT_DSTBYTE_DATA0_BYTE2 \
+	(ROT_BYTELANE_DATAx_BYTE2 << ROT_DSTBYTE_DATA0_SFT)
+#define ROT_DSTBYTE_DATA0_BYTE3 \
+	(ROT_BYTELANE_DATAx_BYTE3 << ROT_DSTBYTE_DATA0_SFT)
+
+
+/*------------------------------*/
+/* ROT_SRCBYTE_CMP              */
+/*------------------------------*/
+/* ROT_DSTBYTE_CMP              */
+/*------------------------------*/
+#define ROT_BYTE_DATA3_UV_BIT 0x0000C000
+#define ROT_BYTE_DATA3_UV_SFT 0xE
+#define ROT_BYTE_DATA3_UV_BYTE0 \
+	(ROT_BYTELANE_DATAx_BYTE0 << ROT_BYTE_DATA3_UV_SFT)
+#define ROT_BYTE_DATA3_UV_BYTE1 \
+	(ROT_BYTELANE_DATAx_BYTE1 << ROT_BYTE_DATA3_UV_SFT)
+#define ROT_BYTE_DATA3_UV_BYTE2 \
+	(ROT_BYTELANE_DATAx_BYTE2 << ROT_BYTE_DATA3_UV_SFT)
+#define ROT_BYTE_DATA3_UV_BYTE3 \
+	(ROT_BYTELANE_DATAx_BYTE3 << ROT_BYTE_DATA3_UV_SFT)
+
+#define ROT_BYTE_DATA2_UV_BIT 0x00003000
+#define ROT_BYTE_DATA2_UV_SFT 0xC
+#define ROT_BYTE_DATA2_UV_BYTE0 \
+	(ROT_BYTELANE_DATAx_BYTE0 << ROT_BYTE_DATA2_UV_SFT)
+#define ROT_BYTE_DATA2_UV_BYTE1 \
+	(ROT_BYTELANE_DATAx_BYTE1 << ROT_BYTE_DATA2_UV_SFT)
+#define ROT_BYTE_DATA2_UV_BYTE2 \
+	(ROT_BYTELANE_DATAx_BYTE2 << ROT_BYTE_DATA2_UV_SFT)
+#define ROT_BYTE_DATA2_UV_BYTE3 \
+	(ROT_BYTELANE_DATAx_BYTE3 << ROT_BYTE_DATA2_UV_SFT)
+
+#define ROT_BYTE_DATA1_UV_BIT 0x00000C00
+#define ROT_BYTE_DATA1_UV_SFT 0xA
+#define ROT_BYTE_DATA1_UV_BYTE0 \
+	(ROT_BYTELANE_DATAx_BYTE0 << ROT_BYTE_DATA1_UV_SFT)
+#define ROT_BYTE_DATA1_UV_BYTE1 \
+	(ROT_BYTELANE_DATAx_BYTE1 << ROT_BYTE_DATA1_UV_SFT)
+#define ROT_BYTE_DATA1_UV_BYTE2 \
+	(ROT_BYTELANE_DATAx_BYTE2 << ROT_BYTE_DATA1_UV_SFT)
+#define ROT_BYTE_DATA1_UV_BYTE3 \
+	(ROT_BYTELANE_DATAx_BYTE3 << ROT_BYTE_DATA1_UV_SFT)
+
+#define ROT_BYTE_DATA0_UV_BIT 0x00000300
+#define ROT_BYTE_DATA0_UV_SFT  0x8
+#define ROT_BYTE_DATA0_UV_BYTE0 \
+	(ROT_BYTELANE_DATAx_BYTE0 << ROT_BYTE_DATA0_UV_SFT)
+#define ROT_BYTE_DATA0_UV_BYTE1 \
+	(ROT_BYTELANE_DATAx_BYTE1 << ROT_BYTE_DATA0_UV_SFT)
+#define ROT_BYTE_DATA0_UV_BYTE2 \
+	(ROT_BYTELANE_DATAx_BYTE2 << ROT_BYTE_DATA0_UV_SFT)
+#define ROT_BYTE_DATA0_UV_BYTE3 \
+	(ROT_BYTELANE_DATAx_BYTE3 << ROT_BYTE_DATA0_UV_SFT)
+
+#define ROT_BYTE_DATA3_Y_BIT 0x000000C0
+#define ROT_BYTE_DATA3_Y_SFT 0x6
+#define ROT_BYTE_DATA3_Y_BYTE0 \
+	 (ROT_BYTELANE_DATAx_BYTE0 << ROT_BYTE_DATA3_Y_SFT)
+#define ROT_BYTE_DATA3_Y_BYTE1 \
+	 (ROT_BYTELANE_DATAx_BYTE1 << ROT_BYTE_DATA3_Y_SFT)
+#define ROT_BYTE_DATA3_Y_BYTE2 \
+	 (ROT_BYTELANE_DATAx_BYTE2 << ROT_BYTE_DATA3_Y_SFT)
+#define ROT_BYTE_DATA3_Y_BYTE3 \
+	 (ROT_BYTELANE_DATAx_BYTE3 << ROT_BYTE_DATA3_Y_SFT)
+
+#define ROT_BYTE_DATA2_Y_BIT 0x00000030
+#define ROT_BYTE_DATA2_Y_SFT 0x4
+#define ROT_BYTE_DATA2_Y_BYTE0 \
+	 (ROT_BYTELANE_DATAx_BYTE0 << ROT_BYTE_DATA2_Y_SFT)
+#define ROT_BYTE_DATA2_Y_BYTE1 \
+	 (ROT_BYTELANE_DATAx_BYTE1 << ROT_BYTE_DATA2_Y_SFT)
+#define ROT_BYTE_DATA2_Y_BYTE2 \
+	 (ROT_BYTELANE_DATAx_BYTE2 << ROT_BYTE_DATA2_Y_SFT)
+#define ROT_BYTE_DATA2_Y_BYTE3 \
+	 (ROT_BYTELANE_DATAx_BYTE3 << ROT_BYTE_DATA2_Y_SFT)
+
+#define ROT_BYTE_DATA1_Y_BIT 0x0000000C
+#define ROT_BYTE_DATA1_Y_SFT 0x2
+#define ROT_BYTE_DATA1_Y_BYTE0 \
+	 (ROT_BYTELANE_DATAx_BYTE0 << ROT_BYTE_DATA1_Y_SFT)
+#define ROT_BYTE_DATA1_Y_BYTE1 \
+	 (ROT_BYTELANE_DATAx_BYTE1 << ROT_BYTE_DATA1_Y_SFT)
+#define ROT_BYTE_DATA1_Y_BYTE2 \
+	 (ROT_BYTELANE_DATAx_BYTE2 << ROT_BYTE_DATA1_Y_SFT)
+#define ROT_BYTE_DATA1_Y_BYTE3 \
+	 (ROT_BYTELANE_DATAx_BYTE3 << ROT_BYTE_DATA1_Y_SFT)
+
+#define ROT_BYTE_DATA0_Y_BIT 0x00000003
+#define ROT_BYTE_DATA0_Y_SFT 0x0
+#define ROT_BYTE_DATA0_Y_BYTE0 \
+	 (ROT_BYTELANE_DATAx_BYTE0 << ROT_BYTE_DATA0_Y_SFT)
+#define ROT_BYTE_DATA0_Y_BYTE1 \
+	 (ROT_BYTELANE_DATAx_BYTE1 << ROT_BYTE_DATA0_Y_SFT)
+#define ROT_BYTE_DATA0_Y_BYTE2 \
+	 (ROT_BYTELANE_DATAx_BYTE2 << ROT_BYTE_DATA0_Y_SFT)
+#define ROT_BYTE_DATA0_Y_BYTE3 \
+	 (ROT_BYTELANE_DATAx_BYTE3 << ROT_BYTE_DATA0_Y_SFT)
+
+
+/*------------------------------*/
+/* ROT_DUAL_FF                  */
+/*------------------------------*/
+#define ROT_DUAL_FF_MODE_BIT    0x00000002
+#define ROT_DUAL_FF_MODE_SFT    0x1
+
+#define ROT_REG_EN_BIT          0x00000001
+#define ROT_REG_EN_SFT          0x0
+
+
+/*===============================================================*/
+/* ROT register reset                                            */
+/*===============================================================*/
+#define ROT_MODE_RESET         0x00000000
+#define ROT_SRCBYTE_RESET      0x000000E4
+#define ROT_DSTBYTE_RESET      0x000000E4
+#define ROT_DUAL_FF_RESET      0x00000000
+
+#endif /* _ROT_H_ */
diff --git a/drivers/ipu/Kconfig b/drivers/ipu/Kconfig
new file mode 100644
index 0000000..8d5de43
--- /dev/null
+++ b/drivers/ipu/Kconfig
@@ -0,0 +1,21 @@
+#
+# IPU dricer configuration
+#
+
+menu "MP200 IPU support"
+        depends on ARCH_MP200
+
+config MP200_IPU
+	bool "MP200 IPU support"
+	default y
+	help
+          This is the IPU device driver for EM1 boards.
+
+config MP200_IPU_DUAL
+	bool "DUAL request running support"
+        depends on MP200_IPU
+	default y
+	help
+          This is the IPU device driver for EM1 boards.
+
+endmenu
diff --git a/drivers/ipu/Makefile b/drivers/ipu/Makefile
new file mode 100644
index 0000000..60f5369
--- /dev/null
+++ b/drivers/ipu/Makefile
@@ -0,0 +1,7 @@
+#
+# Makefile for IPU driver
+#
+
+obj-$(CONFIG_MP200_IPU) += mp200_ipu.o mp200_ipu_user.o
+
+#include $(TOPDIR)/Rules.make
diff --git a/drivers/ipu/mp200_img_convert.h b/drivers/ipu/mp200_img_convert.h
new file mode 100644
index 0000000..459fd6a
--- /dev/null
+++ b/drivers/ipu/mp200_img_convert.h
@@ -0,0 +1,1781 @@
+/*
+*  File Name       : /drivers/ipu/mp200_img_convert.h
+*  Function        : IPU Driver
+*  Release Version : Ver 1.00
+*  Release Date    : 2006/11/20
+*
+*  Copyright (C) NEC Electronics Corporation 2006
+*
+*
+*  This program is free software;you can redistribute it and/or modify it
+*  under the terms of the GNU General Public License as published by Free
+*  Softwere Foundation; either version 2 of License, or (at your option) any
+*  later version.
+*
+*  This program is distributed in the hope that it will be useful, but WITHOUT
+*  ANY WARRANTY; without even the implied warrnty of MERCHANTABILITY or
+*  FITNESS FOR A PARTICULAR PURPOSE.
+*  See the GNU General Public License for more details.
+*
+*  You should have received a copy of the GNU General Public License along
+*  with this program; If not, write to the Free Software Foundation, Inc., 59
+*  Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+*
+*/
+
+#ifndef _MP200_IMG_CONVERT_H_
+#define _MP200_IMG_CONVERT_H_
+
+/****************************************************************************/
+/* Macro                                                                    */
+/****************************************************************************/
+#define ERR_PRINT(num, data) \
+	printk(KERN_INFO \
+		" @ipu: IMGIO_CONVERT: Error! %s is incorrect. %s = 0x%lx\n", \
+		num, num, (long)data);
+
+#define ImgRequest(DATA, REG)                        \
+do {                                                 \
+	pReq->ipu_reg_info[index_req].reg  = (REG);  \
+	pReq->ipu_reg_info[index_req].data = (DATA); \
+	index_req++;                                 \
+} while (0)
+
+
+/****************************************************************************/
+/* Flags                                                                    */
+/****************************************************************************/
+/* ------------------------------------------- */
+/*   internal flags                            */
+/* ------------------------------------------- */
+static unsigned long img_mode;
+static unsigned long ulSrcStarAddrYRGB, ulSrcStarAddrU, ulSrcStarAddrV_B,
+	ulSrcScreenWidth, src_x, src_y, src_width , src_height;
+static unsigned long ulSrcStarAddrYRGB_F, ulSrcStarAddrU_F, ulSrcStarAddrV_F,
+	ulSrcScreenWidth_F, src_x_F, src_y_F, src_width_F, src_height_F;
+static unsigned long ulDestStarAddrYRGB, ulDestStarAddrU, ulDestStarAddrV,
+	ulDestScreenWidth, dest_x, dest_y, dest_width , dest_height;
+static unsigned long offset_x, offset_y, step_h, step_v, fold_h, fold_v;
+static unsigned long ulSrc, ulSrcU, ulSrcV, ulSrc_F;
+static unsigned long ulSrcU_F, ulSrcV_F, ulDest, ulDestU, ulDestV;
+static unsigned long format, src_format_b, src_format_f, dst_format;
+static unsigned long in_byte, out_byte, endian;
+#if _IPU_COLCONV
+static unsigned long matrix_flag, matrix_conf, matrix[9];
+#endif
+static int mask_color, mask_alpha;
+
+static int src_yuv_front, src_yuv_back, dest_yuv;
+static int img_resize, mix_front_image, img_maskcolor;
+static int bits_par_pixel_F, bits_par_pixel_B, bits_par_pixel_D;
+
+
+/* ------------------------------------------- */
+/*   definetion                                */
+/* ------------------------------------------- */
+/* mix_front_image */
+#define MIX_OFF           0
+#define MIX_ON            1
+/* img_maskcolor */
+#define MASK_OFF          0
+#define MASK_ON           1
+/* img_resize */
+#define RESIZE_OFF        0
+#define RESIZE_ON_BACK    1
+#define RESIZE_ON_FRONT   2
+/* src_yuv_front, src_yuv_back, dest_yuv */
+#define RGB_IMAGE         0
+#define YUV_IMAGE         1
+
+/* bits_par_pixel_F, bits_par_pixel_B, bits_par_pixel_D */
+#define BPP_YUV420_422    8
+#define BPP_YUV422_INTER 16  /* Interleave */
+#define BPP_RGB565       16
+#define BPP_RGB666       18
+#define BPP_RGB888       24
+
+#define MAX_SCREEN_WIDTH 0x7FFC
+
+/* pitch of back image must be less than 0x2000 because of IPU Errata  */
+#define MAX_SCREEN_WIDTH_BACK 0x1FFC
+
+/****************************************************************************/
+/* Prototype declarations                                                   */
+/****************************************************************************/
+/* ------------------------------------------- */
+/*   Private functions                         */
+/* ------------------------------------------- */
+static int  mp200_img_convert(MP200_IPU_DEV_INFO *dev_info,
+	struct _IMGIO_CONVERT *p);
+static int  mp200_img_mkreq(struct mp200_ipu_req *pReq, int index);
+static int  mp200_img_mkdata(struct _IMGIO_CONVERT *p);
+static int  mp200_img_chkdata(struct _IMGIO_CONVERT *p);
+static int  mp200_img_chkbytelane(struct _IMGIO_CONVERT *p);
+static int  mp200_img_chkstatus(void);
+static int  mp200_img_chksize(unsigned long back_size,
+	unsigned long front_size, unsigned long dest_size, char *num_size);
+static int  mp200_img_chksize_sub(unsigned long size,
+	unsigned long mode_fmt_bit, unsigned long mode_fmt_sft, char *num_size);
+static int  mp200_img_chkcoordinate(void);
+static int  mp200_img_chkcoordinate_sub(unsigned long mode_fmt_bit,
+	unsigned long mode_fmt_sft);
+static int  mp200_img_chkcoordinate_x_sub(unsigned long pos,
+	unsigned long mode_fmt_bit, unsigned long mode_fmt_sft);
+static int  mp200_img_chkcoordinate_y_sub(unsigned long pos,
+	unsigned long mode_fmt_bit, unsigned long mode_fmt_sft);
+static int  mp200_img_chkaddr(void);
+static int  mp200_img_setaddr(void);
+
+
+/*****************************************************************************
+* MODULE   : mp200_img_convert
+* FUNCTION : ioctl IMGIO_CONVERT sub function.
+* RETURN   : IMG_COMPLETE(0) : Success
+*            -EINVAL         : Fail (parameter error)
+*            -EBUSY          : Fail (IMG busy)
+*            -EIO            : Fail (IMG error, or convert is not completed)
+*            -ERESTARTSYS    : Fail (device busy)
+* NOTE     : none
+* CREATE   : 2006/11/09 M.Sasaki
+* UPDATE   : 2008/03/14 M.Sasaki
+******************************************************************************/
+static int mp200_img_convert(MP200_IPU_DEV_INFO *dev_info,
+		struct _IMGIO_CONVERT *p)
+{
+	struct mp200_ipu_req *pReq;
+	int ret;
+
+	/* make IMG data. */
+	if (mp200_img_mkdata(p) == FALSE)
+		return -EINVAL;
+
+	if (dev_info->status != IPU_STATUS_NO_REQ)
+		return -EBUSY;
+
+	if (down_interruptible(&dev_info->sem))            /* get semafore */
+		return -ERESTARTSYS;
+
+
+	/* set IMG data to register. */
+	pReq = &dev_info->req;
+	mp200_img_mkreq(pReq, 0);
+
+	/* set pointer to Device information into dev_info->req.data */
+	pReq->data = (unsigned long)dev_info;
+
+	/* set callback function into dev_info->req.callback */
+	pReq->callback = (void *)mp200_ipu_callback_img;
+
+	/* set hw_func */
+	pReq->ipu_hw_func = IPU_HW_FUNC_IMG;
+
+	/* update status of IPU request process */
+	dev_info->status = IPU_STATUS_WAIT;	/* running */
+
+	ret = mp200_ipu_regist(pReq);		/* register request (reserve)*/
+	if (ret != IPU_REQ_REGISTERED) {
+		/* target request does not exist */
+		dev_info->status = IPU_STATUS_NO_REQ;
+		/* release semafore */
+		up(&dev_info->sem);
+		return ret;
+	}
+
+wait_img:
+	dev_info->sleep_mode = TRUE;
+	/* wait until IMG process is completed */
+	wait_event_interruptible(dev_info->wait_que,
+		(dev_info->status != IPU_STATUS_WAIT));
+	dev_info->sleep_mode = FALSE;
+
+	switch (dev_info->status) {
+	/* wake up by IMG_STATUS_DONE */
+	case IPU_STATUS_DONE:
+		switch (dev_info->req.status) {
+		case IPU_CALLBACK_SUCCESS:
+			ret = IMG_COMPLETE;
+			break;
+
+		case IPU_CALLBACK_IPU_ERROR:
+		case IPU_CALLBACK_IPU_STOP:
+			printk(KERN_INFO
+				" @ipu: IMGIO_CONVERT: IMG Error! "
+				"callback flag = %d\n",
+				dev_info->req.status);
+			ret = -EIO;
+			break;
+
+		case IPU_CALLBACK_SET_PARAM:
+		case IPU_CALLBACK_CANCEL:
+		case IPU_CALLBACK_FAIL:
+		default:
+			printk(KERN_INFO
+			" @ipu: IMGIO_CONVERT: convert is not completed! "
+			"callback flag = %d\n", dev_info->req.status);
+			ret = -EIO;
+			break;
+		}
+		break;
+
+	/* wake up by IMG_STATUS_CANCELLED */
+	case IPU_STATUS_CANCELLED:
+		printk(KERN_INFO
+			" @ipu: IMGIO_CONVERT: "
+			"convert process is cancelled!\n");
+	ret = -EIO;
+	break;
+
+	/* wake up by signal */
+	case IPU_STATUS_WAIT:
+	default:
+		printk(KERN_INFO
+			" @ipu: IMGIO_CONVERT: wake up by signal. "
+			"retry to wait until IMG process is completed\n");
+		goto wait_img;
+		break;
+	}
+	/* update status of IPU request process */
+	/* target request does not exist */
+	dev_info->status = IPU_STATUS_NO_REQ;
+	up(&dev_info->sem);			/* release semafore */
+
+	return ret;
+}
+
+
+/*****************************************************************************
+* MODULE   : mp200_img_mkreq
+* FUNCTION : make IMG request data
+* IMPORT   :
+* RETURN   :
+* NOTE     : none
+* CREATE   : 2006/11/09 M.Sasaki
+* UPDATE   : 2008/03/14 M.Sasaki
+******************************************************************************/
+static int mp200_img_mkreq(struct mp200_ipu_req *pReq, int index)
+{
+	int index_req = index;
+
+	/*******************************
+		set IMG register
+	********************************/
+	/*==============================
+		IMG_MODE
+	================================*/
+	ImgRequest(img_mode,	IMG_MODE);
+
+	/*==============================
+		source image (back)
+	================================*/
+	ImgRequest(ulSrcStarAddrYRGB,	IMG_SRCYRGBADR_B);
+	ImgRequest(ulSrcStarAddrU,	IMG_SRCUVADR_B);
+	ImgRequest(ulSrcStarAddrV_B,	IMG_SRCVADR_B);
+	ImgRequest(ulSrcScreenWidth,	IMG_SRCSIZE_B);
+	ImgRequest(src_width,		IMG_SRCHSIZE_B);
+	ImgRequest(src_height,		IMG_SRCVSIZE_B);
+
+	/*==============================
+		source image (front)
+	================================*/
+	if (mix_front_image) {
+		ImgRequest(ulSrcStarAddrYRGB_F, IMG_SRCYRGBADR_F);
+		ImgRequest(ulSrcStarAddrU_F,	IMG_SRCUVADR_F);
+		ImgRequest(ulSrcStarAddrV_F,	IMG_SRCVADR_F);
+		ImgRequest(ulSrcScreenWidth_F,  IMG_SRCSIZE_F);
+		ImgRequest(src_width_F,		IMG_SRCHSIZE_F);
+		ImgRequest(src_height_F,	IMG_SRCVSIZE_F);
+		/*------------------------------
+		   offset
+		--------------------------------*/
+		ImgRequest(offset_x,		IMG_OFFSETX);
+		ImgRequest(offset_y,		IMG_OFFSETY);
+		/*------------------------------
+			mask color
+		--------------------------------*/
+		if (img_maskcolor) {
+			ImgRequest(mask_color,	IMG_MASKCOLR);
+			ImgRequest(mask_alpha,	IMG_ALPHA);
+		}
+	}
+
+	/*==============================
+		destination image
+	================================*/
+	ImgRequest(ulDestStarAddrYRGB,	IMG_DSTYRGBADR);
+	ImgRequest(ulDestStarAddrU,	IMG_DSTUVADR);
+	ImgRequest(ulDestStarAddrV,	IMG_DSTVADR);
+	ImgRequest(ulDestScreenWidth,	IMG_DSTSIZE);
+
+	/*==============================
+		resize
+	================================*/
+	if (img_resize) {
+		ImgRequest(dest_width,	IMG_DSTHSIZE);
+		ImgRequest(dest_height,	IMG_DSTVSIZE);
+		/*------------------------------
+		   H/VSTEP,H/VFOLD
+		--------------------------------*/
+		ImgRequest(step_h,	IMG_HSTEP);
+		ImgRequest(step_v,	IMG_VSTEP);
+		ImgRequest(fold_h,	IMG_HFOLD);
+		ImgRequest(fold_v,	IMG_VFOLD);
+	}
+
+	/*==============================
+		format
+	================================*/
+	ImgRequest(format,		IMG_FORMAT);
+
+	/*==============================
+		bytelane
+	================================*/
+	ImgRequest(in_byte,		IMG_INDATABYTE);
+	ImgRequest(out_byte,		IMG_OUTDATABYTE);
+	ImgRequest(endian,		IMG_PEL_ENDIAN);
+
+#if _IPU_COLCONV
+	/*==============================
+		color-space conversion
+	================================*/
+	if (matrix_flag) {
+		int i;
+		ImgRequest(matrix_conf, matrix_flag);
+		for (i = 0; i < 9; i++)
+			ImgRequest(matrix[i], matrix_flag + (i + 1) * 4);
+
+	}
+#endif
+
+	/*==============================
+		Start IMG
+	================================*/
+	ImgRequest(IMG_REQ_BIT,		IMG_REQ);
+
+	/*==============================
+		end mark
+	================================*/
+	ImgRequest(IPU_REG_INFO_END, -1);
+
+	return index_req;
+}
+
+
+/*****************************************************************************
+* MODULE   : mp200_img_mkdata
+* FUNCTION : make IMG register data
+* IMPORT   : struct _IMGIO_CONVERT
+* RETURN   : TRUE  : check OK
+*          : FALSE : check NG
+* NOTE     : none
+* CREATE   : 2006/10/18 M.Sasaki
+* UPDATE   : 2008/03/14 M.Sasaki
+******************************************************************************/
+static int mp200_img_mkdata(struct _IMGIO_CONVERT *p)
+{
+	/*******************************
+		check import data
+	********************************/
+	if (mp200_img_chkdata(p) == FALSE)
+		return FALSE;
+
+	src_x        = p->src_b_image.x;
+	src_y        = p->src_b_image.y;
+	src_width    = p->src_b_image.hsize;
+	src_height   = p->src_b_image.vsize;
+	src_x_F      = p->src_f_image.x;
+	src_y_F      = p->src_f_image.y;
+	src_width_F  = p->src_f_image.hsize;
+	src_height_F = p->src_f_image.vsize;
+	dest_x       = p->dest_image.x;
+	dest_y       = p->dest_image.y;
+	dest_width   = p->dest_image.hsize;
+	dest_height  = p->dest_image.vsize;
+
+	offset_x     = p->offsetx;
+	offset_y     = p->offsety;
+	mask_color   = p->maskcolr;
+	mask_alpha   = p->alpha;
+
+	ulSrc              = p->src_b_image.yrgbadr;
+	ulSrcU             = p->src_b_image.uvadr;
+	ulSrcV             = p->src_b_image.vadr;
+	ulSrc_F            = p->src_f_image.yrgbadr;
+	ulSrcU_F           = p->src_f_image.uvadr;
+	ulSrcV_F           = p->src_f_image.vadr;
+	ulDest             = p->dest_image.yrgbadr;
+	ulDestU            = p->dest_image.uvadr;
+	ulDestV            = p->dest_image.vadr;
+	ulSrcScreenWidth   = p->src_b_image.size;
+	ulSrcScreenWidth_F = p->src_f_image.size;
+	ulDestScreenWidth  = p->dest_image.size;
+
+	src_format_b = p->img_mode.srcfmt_b;
+	src_format_f = p->img_mode.srcfmt_f;
+	dst_format   = p->img_mode.dstfmt;
+
+	/*******************************
+		make IMG_MODE
+	********************************/
+	img_mode  = IMG_NEWEN_BIT;
+	if ((p->img_mode.dstfmt == IMG_FORM_RGB666) ||
+			(p->img_mode.dstfmt == IMG_FORM_RGB565)) {
+		if (mix_front_image)
+			img_mode |= (p->img_mode.dither_f << IMG_DITHER_F_SFT);
+
+		img_mode |= (p->img_mode.dither_b  << IMG_DITHER_B_SFT);
+	}
+	if (img_resize == RESIZE_ON_FRONT)
+		img_mode |= (p->img_mode.rfilter_f << IMG_RFILTER_F_SFT);
+
+	if (img_resize == RESIZE_ON_BACK)
+		img_mode |= (p->img_mode.rfilter_b << IMG_RFILTER_B_SFT);
+
+	img_mode |= (p->img_mode.op_mode   << IMG_OP_MODE_SFT);
+
+	if ((p->img_mode.op_mode == IMG_SET_OP_MODE_12)
+		  || (p->img_mode.op_mode == IMG_SET_OP_MODE_18)) {
+		img_mode |= (p->img_mode.msk_col   << IMG_MASK_COL_SFT);
+	}
+	img_mode |= (p->img_mode.udinv	 << IMG_UDINV_SFT);
+	img_mode |= (p->img_mode.rlinv	 << IMG_RLINV_SFT);
+
+	/*******************************
+		check IMG_MODE
+	********************************/
+	if (mp200_img_chkstatus() == FALSE)
+		return FALSE;
+
+	/*******************************
+		set format
+	********************************/
+	format  = (src_format_b << IMG_FORMAT_SRCFMT_B_SFT);
+	format |= (dst_format   << IMG_FORMAT_DSTFMT_SFT);
+	if (mix_front_image)
+		format |= (src_format_f << IMG_FORMAT_SRCFMT_F_SFT);
+
+	/*******************************
+		check image size
+	********************************/
+	if (mp200_img_chksize(src_width, src_width_F, dest_width,
+		  "hsize") == FALSE)
+		return FALSE;
+
+	if (mp200_img_chksize(src_height, src_height_F, dest_height,
+		  "vsize") == FALSE)
+		return FALSE;
+
+	if (img_resize) {
+		unsigned long sw, sh;
+		if (img_resize == RESIZE_ON_BACK) {
+			sw = src_width;
+			sh = src_height;
+		} else {
+			/* RESIZE_ON_FRONT */
+			sw = src_width_F;
+			sh = src_height_F;
+		}
+		/* H/VSTEP */
+		step_h = (sw * 256 / dest_width);
+		step_v = (sh * 256 / dest_height);
+		/* H/VFOLD */
+		fold_h = (dest_width  * 64 / sw);
+		fold_v = (dest_height * 64 / sh);
+	}
+
+	/*******************************
+		check (x,y)coordinate
+	********************************/
+	if (mp200_img_chkcoordinate() == FALSE)
+		return FALSE;
+
+	/*******************************
+		check address
+	********************************/
+	if (mp200_img_chkaddr() == FALSE)
+		return FALSE;
+
+	/*******************************
+		set IMG address
+	********************************/
+	if (mp200_img_setaddr() == FALSE)
+		return FALSE;
+
+	/*******************************
+		check bytelane
+	********************************/
+	if (mp200_img_chkbytelane(p) == FALSE)
+		return FALSE;
+
+	/*******************************
+		set bytelane
+	********************************/
+	in_byte  = p->in_byte;
+	out_byte = p->out_byte;
+
+	return TRUE;
+
+}
+
+
+/*****************************************************************************
+* MODULE   : mp200_img_chkbytelane
+* FUNCTION : check image bytelane
+* IMPORT   : struct _IMGIO_CONVERT
+* RETURN   : TRUE  : check OK
+*          : FALSE : check NG
+* NOTE     : none
+* CREATE   : 2006/10/18 M.Sasaki
+* UPDATE   : 2008/03/14 M.Sasaki
+******************************************************************************/
+static int mp200_img_chkbytelane(struct _IMGIO_CONVERT *p)
+{
+	/* check input bytelane */
+	if ((p->in_byte & IMG_INDATABYTE_DATA0_BIT) ==
+	((p->in_byte & IMG_INDATABYTE_DATA1_BIT) >> IMG_INDATABYTE_DATA1_SFT) ||
+	 (p->in_byte & IMG_INDATABYTE_DATA0_BIT) ==
+	((p->in_byte & IMG_INDATABYTE_DATA2_BIT) >> IMG_INDATABYTE_DATA2_SFT) ||
+	 (p->in_byte & IMG_INDATABYTE_DATA0_BIT) ==
+	((p->in_byte & IMG_INDATABYTE_DATA3_BIT) >> IMG_INDATABYTE_DATA3_SFT) ||
+	((p->in_byte & IMG_INDATABYTE_DATA1_BIT) >> IMG_INDATABYTE_DATA1_SFT) ==
+	((p->in_byte & IMG_INDATABYTE_DATA2_BIT) >> IMG_INDATABYTE_DATA2_SFT) ||
+	((p->in_byte & IMG_INDATABYTE_DATA1_BIT) >> IMG_INDATABYTE_DATA1_SFT) ==
+	((p->in_byte & IMG_INDATABYTE_DATA3_BIT) >> IMG_INDATABYTE_DATA3_SFT) ||
+	((p->in_byte & IMG_INDATABYTE_DATA2_BIT) >> IMG_INDATABYTE_DATA2_SFT) ==
+	((p->in_byte & IMG_INDATABYTE_DATA3_BIT) >> IMG_INDATABYTE_DATA3_SFT)) {
+		printk(KERN_INFO
+		" @ipu: IMGIO_IMAGE: Error! input_byte is incorrect.\n");
+		printk(KERN_INFO
+			" in_byte IMG_INDATABYTE_DATA0_BIT = %ld\n",
+			(p->in_byte &
+			IMG_INDATABYTE_DATA0_BIT) >> IMG_INDATABYTE_DATA0_SFT);
+		printk(KERN_INFO " in_byte IMG_INDATABYTE_DATA1_BIT = %ld\n",
+			(p->in_byte &
+			IMG_INDATABYTE_DATA1_BIT) >> IMG_INDATABYTE_DATA1_SFT);
+		printk(KERN_INFO
+			" in_byte IMG_INDATABYTE_DATA2_BIT = %ld\n",
+			(p->in_byte &
+			IMG_INDATABYTE_DATA2_BIT) >> IMG_INDATABYTE_DATA2_SFT);
+		printk(KERN_INFO
+			" in_byte IMG_INDATABYTE_DATA3_BIT = %ld\n",
+			(p->in_byte &
+			IMG_INDATABYTE_DATA3_BIT) >> IMG_INDATABYTE_DATA3_SFT);
+		return FALSE;
+	}
+	/* check output bytelane */
+	if ((p->out_byte & IMG_OUTDATABYTE_DATA0_BIT) ==
+	   ((p->out_byte & IMG_OUTDATABYTE_DATA1_BIT) >>
+		IMG_OUTDATABYTE_DATA1_SFT) ||
+	    (p->out_byte & IMG_OUTDATABYTE_DATA0_BIT) ==
+	   ((p->out_byte & IMG_OUTDATABYTE_DATA2_BIT) >>
+		IMG_OUTDATABYTE_DATA2_SFT) ||
+	    (p->out_byte & IMG_OUTDATABYTE_DATA0_BIT) ==
+	   ((p->out_byte & IMG_OUTDATABYTE_DATA3_BIT) >>
+		IMG_OUTDATABYTE_DATA3_SFT) ||
+	   ((p->out_byte & IMG_OUTDATABYTE_DATA1_BIT) >>
+		IMG_OUTDATABYTE_DATA1_SFT) ==
+	   ((p->out_byte & IMG_OUTDATABYTE_DATA2_BIT) >>
+		IMG_OUTDATABYTE_DATA2_SFT) ||
+	   ((p->out_byte & IMG_OUTDATABYTE_DATA1_BIT) >>
+		IMG_OUTDATABYTE_DATA1_SFT) ==
+	   ((p->out_byte & IMG_OUTDATABYTE_DATA3_BIT) >>
+		IMG_OUTDATABYTE_DATA3_SFT) ||
+	   ((p->out_byte & IMG_OUTDATABYTE_DATA2_BIT) >>
+		IMG_OUTDATABYTE_DATA2_SFT) ==
+	   ((p->out_byte & IMG_OUTDATABYTE_DATA3_BIT) >>
+		IMG_OUTDATABYTE_DATA3_SFT)) {
+		printk(KERN_INFO
+		" @ipu: IMGIO_IMAGE: Error! output_byte is incorrect.\n");
+		printk(KERN_INFO
+		" out_byte IMG_OUTDATABYTE_DATA0_BIT = %ld\n",
+		(p->out_byte &
+		IMG_OUTDATABYTE_DATA0_BIT) >> IMG_OUTDATABYTE_DATA0_SFT);
+		printk(KERN_INFO
+		" out_byte IMG_OUTDATABYTE_DATA1_BIT = %ld\n",
+		(p->out_byte &
+		IMG_OUTDATABYTE_DATA1_BIT) >> IMG_OUTDATABYTE_DATA1_SFT);
+		printk(KERN_INFO
+		" out_byte IMG_OUTDATABYTE_DATA2_BIT = %ld\n",
+		(p->out_byte &
+		IMG_OUTDATABYTE_DATA2_BIT) >> IMG_OUTDATABYTE_DATA2_SFT);
+		printk(KERN_INFO
+		" out_byte IMG_OUTDATABYTE_DATA3_BIT = %ld\n",
+		(p->out_byte &
+		IMG_OUTDATABYTE_DATA3_BIT) >> IMG_OUTDATABYTE_DATA3_SFT);
+		return FALSE;
+	}
+
+	endian = IMG_PEL_ENDIAN_IN_ENDI_LITTLE | IMG_PEL_ENDIAN_OUT_ENDI_LITTLE;
+
+	return TRUE;
+}
+
+
+/*****************************************************************************
+* MODULE   : mp200_img_chkdata
+* FUNCTION : check ioctl IMGIO_CONVERT arg
+* IMPORT   : struct _IMGIO_CONVERT
+* RETURN   : TRUE  : check OK
+*          : FALSE : check NG
+* NOTE     : none
+* CREATE   : 2006/10/18 M.Sasaki
+* UPDATE   : 2008/03/14 M.Sasaki
+******************************************************************************/
+static int mp200_img_chkdata(struct _IMGIO_CONVERT *p)
+{
+/*====================*/
+/* Image Mode check */
+/*====================*/
+	/* check OP_MODE flag */
+	if ((p->img_mode.op_mode != IMG_SET_OP_MODE_00) &&
+	    (p->img_mode.op_mode != IMG_SET_OP_MODE_01) &&
+	    (p->img_mode.op_mode != IMG_SET_OP_MODE_02) &&
+	    (p->img_mode.op_mode != IMG_SET_OP_MODE_03) &&
+	    (p->img_mode.op_mode != IMG_SET_OP_MODE_04) &&
+	    (p->img_mode.op_mode != IMG_SET_OP_MODE_05) &&
+	    (p->img_mode.op_mode != IMG_SET_OP_MODE_06) &&
+	    (p->img_mode.op_mode != IMG_SET_OP_MODE_07) &&
+	    (p->img_mode.op_mode != IMG_SET_OP_MODE_08) &&
+	    (p->img_mode.op_mode != IMG_SET_OP_MODE_09) &&
+	    (p->img_mode.op_mode != IMG_SET_OP_MODE_10) &&
+	    (p->img_mode.op_mode != IMG_SET_OP_MODE_11) &&
+	    (p->img_mode.op_mode != IMG_SET_OP_MODE_12) &&
+	    (p->img_mode.op_mode != IMG_SET_OP_MODE_13) &&
+	    (p->img_mode.op_mode != IMG_SET_OP_MODE_14) &&
+	    (p->img_mode.op_mode != IMG_SET_OP_MODE_15) &&
+	    (p->img_mode.op_mode != IMG_SET_OP_MODE_16) &&
+	    (p->img_mode.op_mode != IMG_SET_OP_MODE_17) &&
+	    (p->img_mode.op_mode != IMG_SET_OP_MODE_18) &&
+	    (p->img_mode.op_mode != IMG_SET_OP_MODE_19) &&
+	    (p->img_mode.op_mode != IMG_SET_OP_MODE_20) &&
+	    (p->img_mode.op_mode != IMG_SET_OP_MODE_21) &&
+	    (p->img_mode.op_mode != IMG_SET_OP_MODE_22) &&
+	    (p->img_mode.op_mode != IMG_SET_OP_MODE_23)) {
+		ERR_PRINT("img_mode.op_mode", p->img_mode.op_mode);
+		return FALSE;
+	}
+
+	/* check src image(FRONT) */
+	if ((p->img_mode.op_mode << IMG_OP_MODE_SFT) & IMG_OVERLAY_BIT)
+		mix_front_image = MIX_ON;
+	else
+		mix_front_image = MIX_OFF;
+
+
+	/* chack resize */
+	if ((p->img_mode.op_mode == IMG_SET_OP_MODE_02)
+		 || (p->img_mode.op_mode == IMG_SET_OP_MODE_03)
+		 || (p->img_mode.op_mode == IMG_SET_OP_MODE_04)
+		 || (p->img_mode.op_mode == IMG_SET_OP_MODE_05)
+		 || (p->img_mode.op_mode == IMG_SET_OP_MODE_12)
+		 || (p->img_mode.op_mode == IMG_SET_OP_MODE_13)
+		 || (p->img_mode.op_mode == IMG_SET_OP_MODE_14)
+		 || (p->img_mode.op_mode == IMG_SET_OP_MODE_15)
+		 || (p->img_mode.op_mode == IMG_SET_OP_MODE_16)
+		 || (p->img_mode.op_mode == IMG_SET_OP_MODE_17)
+		 || (p->img_mode.op_mode == IMG_SET_OP_MODE_18)
+		 || (p->img_mode.op_mode == IMG_SET_OP_MODE_19)) {
+		/* back image resize on */
+		img_resize = RESIZE_ON_BACK;
+	} else if ((p->img_mode.op_mode == IMG_SET_OP_MODE_08)
+		 || (p->img_mode.op_mode == IMG_SET_OP_MODE_09)
+		 || (p->img_mode.op_mode == IMG_SET_OP_MODE_10)
+		 || (p->img_mode.op_mode == IMG_SET_OP_MODE_11)
+		 || (p->img_mode.op_mode == IMG_SET_OP_MODE_20)
+		 || (p->img_mode.op_mode == IMG_SET_OP_MODE_21)
+		 || (p->img_mode.op_mode == IMG_SET_OP_MODE_22)
+		 || (p->img_mode.op_mode == IMG_SET_OP_MODE_23)) {
+		/* front image resize on */
+		img_resize = RESIZE_ON_FRONT;
+	} else {
+		/* no resize */
+		img_resize = RESIZE_OFF;
+	}
+
+	/* check mask */
+	if ((p->img_mode.op_mode == IMG_SET_OP_MODE_12)
+		 || (p->img_mode.op_mode == IMG_SET_OP_MODE_18)) {
+		/* check mask color flag */
+		if (p->img_mode.msk_col == IMG_SET_MASKCOLOR_ON) {
+			if ((p->img_mode.dstfmt == IMG_FORM_RGB666)
+				 || (p->img_mode.dstfmt == IMG_FORM_RGB565)) {
+				img_maskcolor = MASK_ON;
+			} else
+				img_maskcolor = MASK_OFF;
+
+		} else if (p->img_mode.msk_col == IMG_SET_MASKCOLOR_OFF) {
+			img_maskcolor = MASK_OFF;
+		} else {
+			ERR_PRINT("img_mode.msk_col", p->img_mode.msk_col);
+			return FALSE;
+		}
+	}
+
+	if ((p->img_mode.dstfmt == IMG_FORM_RGB666)
+		 || (p->img_mode.dstfmt == IMG_FORM_RGB565)) {
+		if (mix_front_image) {
+			/* check enable dither(FRONT) flag */
+			if (p->img_mode.dither_f  > (char)IMG_SET_DITHER_ON) {
+				ERR_PRINT("img_mode.dither_f",
+					p->img_mode.dither_f);
+				return FALSE;
+			}
+		}
+		/* check enable dither(BACK) flag */
+		if (p->img_mode.dither_b  > (char)IMG_SET_DITHER_ON) {
+			ERR_PRINT("img_mode.dither_b", p->img_mode.dither_b);
+			return FALSE;
+		}
+	}
+
+	if (img_resize == RESIZE_ON_FRONT) {
+		/* check filter(FRONT) flag */
+		if (p->img_mode.rfilter_f > (char)IMG_SET_SMOOTH_FILTER) {
+			ERR_PRINT("img_mode.rfilter_f", p->img_mode.rfilter_f);
+			return FALSE;
+		}
+	}
+	if (img_resize == RESIZE_ON_BACK) {
+		/* check filter(BACK) flag */
+		if (p->img_mode.rfilter_b > (char)IMG_SET_SMOOTH_FILTER) {
+			ERR_PRINT("img_mode.rfilter_b", p->img_mode.rfilter_b);
+			return FALSE;
+		}
+	}
+
+	/* check up/down mirroring flag */
+	if (p->img_mode.udinv > (char)IMG_SET_MIRROR_ON) {
+		ERR_PRINT("img_mode.udinv", p->img_mode.udinv);
+		return FALSE;
+	}
+	/* check right/left mirroring flag */
+	if (p->img_mode.rlinv > (char)IMG_SET_MIRROR_ON) {
+		ERR_PRINT("img_mode.rlinv", p->img_mode.rlinv);
+		return FALSE;
+	}
+
+/*====================*/
+/* Image Format check */
+/*====================*/
+	if (mix_front_image) {
+		/* check src image(FRONT) */
+		if ((p->img_mode.op_mode == IMG_SET_OP_MODE_09)
+			  || (p->img_mode.op_mode == IMG_SET_OP_MODE_10)
+			  || (p->img_mode.op_mode == IMG_SET_OP_MODE_13)
+			  || (p->img_mode.op_mode == IMG_SET_OP_MODE_14)
+			  || (p->img_mode.op_mode == IMG_SET_OP_MODE_16)
+			  || (p->img_mode.op_mode == IMG_SET_OP_MODE_19)
+			  || (p->img_mode.op_mode == IMG_SET_OP_MODE_20)
+			  || (p->img_mode.op_mode == IMG_SET_OP_MODE_23)) {
+			/* src image(FRONT) YUV422/420 */
+			src_yuv_front = YUV_IMAGE;
+			if ((p->img_mode.srcfmt_f != IMG_FORM_YUV420_PLANAR)
+			  && (p->img_mode.srcfmt_f != IMG_FORM_YUV422_PLANAR)
+			  && (p->img_mode.srcfmt_f !=
+				IMG_FORM_YUV420_SEMI_PLANAR)
+			  && (p->img_mode.srcfmt_f !=
+				IMG_FORM_YUV422_SEMI_PLANAR)
+			  && (p->img_mode.srcfmt_f !=
+				IMG_FORM_YUV422_INTERLEAVE)) {
+				ERR_PRINT("img_mode.srcfmt_f",
+					p->img_mode.srcfmt_f);
+				return FALSE;
+			}
+		} else {
+			/* src image(FRONT) RGB888/565 */
+			src_yuv_front = RGB_IMAGE;
+			if ((p->img_mode.srcfmt_f != IMG_FORM_RGB888)
+			  && (p->img_mode.srcfmt_f != IMG_FORM_RGB565)) {
+				ERR_PRINT("img_mode.srcfmt_f",
+					p->img_mode.srcfmt_f);
+				return FALSE;
+			}
+		}
+
+		if ((p->img_mode.srcfmt_b == IMG_FORM_YUV420_PLANAR)
+		  || (p->img_mode.srcfmt_b == IMG_FORM_YUV422_PLANAR)
+		  || (p->img_mode.srcfmt_f == IMG_FORM_YUV420_PLANAR)
+		  || (p->img_mode.srcfmt_f == IMG_FORM_YUV422_PLANAR)) {
+			if (p->img_mode.srcfmt_f != p->img_mode.srcfmt_b) {
+				printk(KERN_INFO
+				" @ipu: IMGIO_IMAGE: Error! combination of "
+				"img_mode.srcfmt_b and img_mode.srcfmt_f "
+				"is incorrect.\n");
+				return FALSE;
+			}
+		} else if (p->img_mode.srcfmt_b == IMG_FORM_YUV422_INTERLEAVE) {
+			if ((p->img_mode.srcfmt_f !=
+			IMG_FORM_YUV422_INTERLEAVE) && (p->img_mode.srcfmt_f !=
+			IMG_FORM_RGB565)) {
+				printk(KERN_INFO
+				" @ipu: IMGIO_IMAGE: Error! combination of "
+				"img_mode.srcfmt_b and img_mode.srcfmt_f is "
+				"incorrect.\n");
+				return FALSE;
+			}
+		} else if (p->img_mode.srcfmt_f == IMG_FORM_YUV422_INTERLEAVE) {
+			if ((p->img_mode.srcfmt_b !=
+				IMG_FORM_YUV422_INTERLEAVE) &&
+				(p->img_mode.srcfmt_b !=
+				IMG_FORM_RGB565)) {
+				printk(KERN_INFO
+				" @ipu: IMGIO_IMAGE: Error! combination of "
+				"img_mode.srcfmt_b and img_mode.srcfmt_f is "
+				"incorrect.\n");
+				return FALSE;
+			}
+		}
+	}
+
+	/* check src image(BACK) */
+	if ((p->img_mode.op_mode == IMG_SET_OP_MODE_01)
+	  || (p->img_mode.op_mode == IMG_SET_OP_MODE_03)
+	  || (p->img_mode.op_mode == IMG_SET_OP_MODE_05)
+	  || (p->img_mode.op_mode == IMG_SET_OP_MODE_07)
+	  || (p->img_mode.op_mode == IMG_SET_OP_MODE_10)
+	  || (p->img_mode.op_mode == IMG_SET_OP_MODE_11)
+	  || (p->img_mode.op_mode == IMG_SET_OP_MODE_14)
+	  || (p->img_mode.op_mode == IMG_SET_OP_MODE_15)
+	  || (p->img_mode.op_mode == IMG_SET_OP_MODE_18)
+	  || (p->img_mode.op_mode == IMG_SET_OP_MODE_19)
+	  || (p->img_mode.op_mode == IMG_SET_OP_MODE_22)
+	  || (p->img_mode.op_mode == IMG_SET_OP_MODE_23)) {
+		/* src image(BACK) YUV422/420 */
+		src_yuv_back = YUV_IMAGE;
+		if ((p->img_mode.srcfmt_b != IMG_FORM_YUV420_PLANAR)
+		  && (p->img_mode.srcfmt_b != IMG_FORM_YUV422_PLANAR)
+		  && (p->img_mode.srcfmt_b != IMG_FORM_YUV420_SEMI_PLANAR)
+		  && (p->img_mode.srcfmt_b != IMG_FORM_YUV422_SEMI_PLANAR)
+		  && (p->img_mode.srcfmt_b != IMG_FORM_YUV422_INTERLEAVE)) {
+			ERR_PRINT("img_mode.srcfmt_b", p->img_mode.srcfmt_b);
+			return FALSE;
+		}
+	} else {
+		/* src image(BACK) RGB888/565 */
+		src_yuv_back = RGB_IMAGE;
+		if ((p->img_mode.srcfmt_b != IMG_FORM_RGB888)
+		  && (p->img_mode.srcfmt_b != IMG_FORM_RGB565)) {
+			ERR_PRINT("img_mode.srcfmt_b", p->img_mode.srcfmt_b);
+			return FALSE;
+		}
+	}
+
+	/* check dest image */
+	if ((p->img_mode.op_mode == IMG_SET_OP_MODE_01)
+	  || (p->img_mode.op_mode == IMG_SET_OP_MODE_03)
+	  || (p->img_mode.op_mode == IMG_SET_OP_MODE_04)
+	  || (p->img_mode.op_mode == IMG_SET_OP_MODE_06)
+	  || (p->img_mode.op_mode == IMG_SET_OP_MODE_10)
+	  || (p->img_mode.op_mode == IMG_SET_OP_MODE_11)
+	  || (p->img_mode.op_mode == IMG_SET_OP_MODE_14)
+	  || (p->img_mode.op_mode == IMG_SET_OP_MODE_15)
+	  || (p->img_mode.op_mode == IMG_SET_OP_MODE_16)
+	  || (p->img_mode.op_mode == IMG_SET_OP_MODE_17)
+	  || (p->img_mode.op_mode == IMG_SET_OP_MODE_20)
+	  || (p->img_mode.op_mode == IMG_SET_OP_MODE_21)) {
+		/* dest image YUV422/420 */
+		dest_yuv = YUV_IMAGE;
+		if ((p->img_mode.dstfmt != IMG_FORM_YUV420_PLANAR)
+		  && (p->img_mode.dstfmt != IMG_FORM_YUV422_PLANAR)
+		  && (p->img_mode.dstfmt != IMG_FORM_YUV420_SEMI_PLANAR)
+		  && (p->img_mode.dstfmt != IMG_FORM_YUV422_SEMI_PLANAR)
+		  && (p->img_mode.dstfmt != IMG_FORM_YUV422_INTERLEAVE)) {
+			ERR_PRINT("img_mode.dstfmt", p->img_mode.dstfmt);
+			return FALSE;
+		}
+	} else {
+		/* dest image RGB888/666/565 */
+		dest_yuv = RGB_IMAGE;
+		if ((p->img_mode.dstfmt != IMG_FORM_RGB888)
+		  && (p->img_mode.dstfmt != IMG_FORM_RGB666)
+		  && (p->img_mode.dstfmt != IMG_FORM_RGB565)) {
+			ERR_PRINT("img_mode.dstfmt", p->img_mode.dstfmt);
+			return FALSE;
+		}
+	}
+
+#if _IPU_COLCONV
+/*========================*/
+/* color-space conversion */
+/*========================*/
+	if (src_yuv_back != dest_yuv) {
+		if (src_yuv_back == YUV_IMAGE)
+			matrix_flag = IMG_YUVRGB_CONF;
+		else
+			matrix_flag = IMG_RGBYUV_CONF;
+
+	} else if (mix_front_image && src_yuv_front != dest_yuv) {
+		if (src_yuv_front == YUV_IMAGE)
+			matrix_flag = IMG_YUVRGB_CONF;
+		else
+			matrix_flag = IMG_RGBYUV_CONF;
+
+	} else {
+		matrix_flag = 0;
+	}
+
+	/* set_matrix == FALSE is IMG initial value */
+	if (matrix_flag && !p->set_matrix)
+		matrix_flag = 0;
+
+	if (matrix_flag) {
+		int i;
+		matrix_conf = p->matrix_conf;
+		for (i = 0; i < 9; i++)
+			matrix[i] = p->matrix[i];
+
+	}
+#endif
+
+	return TRUE;
+}
+
+
+/*****************************************************************************
+* MODULE   : mp200_img_chkstatus
+* FUNCTION : check IMG_MODE to internal flag
+* IMPORT   : none
+* RETURN   : TRUE  : check OK
+*          : FALSE : check NG
+* NOTE     : none
+* CREATE   : 2006/10/18 M.Sasaki
+* UPDATE   :
+******************************************************************************/
+static int mp200_img_chkstatus(void)
+{
+	if (img_maskcolor) {
+		if (src_format_f == IMG_FORM_RGB888) {
+			/* RGB888 */
+			if (mask_color > 0xFFFFFF)
+				goto fail_maskcolor;
+		} else {
+			/* RGB565 */
+			if (mask_color > 0xFFFF)
+				goto fail_maskcolor;
+		}
+		if (mask_alpha > IMG_ALPHA_BIT)
+			goto fail_alpha;
+	}
+
+	if (img_resize == RESIZE_OFF) {
+		/* no resize */
+		dest_width  = src_width;
+		dest_height = src_height;
+	}
+
+	/* pixel size */
+	if (src_yuv_back) {
+		if (src_format_b == IMG_FORM_YUV422_INTERLEAVE)
+			bits_par_pixel_B = BPP_YUV422_INTER;
+		else
+			bits_par_pixel_B = BPP_YUV420_422;
+	} else {
+		if (src_format_b == IMG_FORM_RGB888)
+			bits_par_pixel_B = BPP_RGB888;
+		else
+			bits_par_pixel_B = BPP_RGB565;
+
+	}
+	if (src_yuv_front) {
+		if (src_format_f == IMG_FORM_YUV422_INTERLEAVE)
+			bits_par_pixel_F = BPP_YUV422_INTER;
+		else
+			bits_par_pixel_F = BPP_YUV420_422;
+	} else {
+		if (src_format_f == IMG_FORM_RGB888)
+			bits_par_pixel_F = BPP_RGB888;
+		else
+			bits_par_pixel_F = BPP_RGB565;
+	}
+
+	if (dest_yuv) {
+		if (dst_format == IMG_FORM_YUV422_INTERLEAVE)
+			bits_par_pixel_D = BPP_YUV422_INTER;
+		else
+			bits_par_pixel_D = BPP_YUV420_422;
+	} else {
+		if (dst_format == IMG_FORM_RGB888)
+			bits_par_pixel_D = BPP_RGB888;
+		else if (dst_format == IMG_FORM_RGB666)
+			bits_par_pixel_D = BPP_RGB666;
+		else
+			bits_par_pixel_D = BPP_RGB565;
+	}
+
+	return TRUE;
+
+fail_maskcolor:
+	ERR_PRINT("maskcolr", mask_color);
+	return FALSE;
+fail_alpha:
+	ERR_PRINT("alpha", mask_alpha);
+	return FALSE;
+}
+
+
+/*****************************************************************************
+* MODULE   : mp200_img_chksize
+* FUNCTION : check image size
+* IMPORT   : unsigned long back_size
+*          : unsigned long front_size
+*          : unsigned long dest_size
+* RETURN   : TRUE  : check OK
+*          : FALSE : check NG
+* NOTE     : none
+* CREATE   : 2006/10/18 M.Sasaki
+* UPDATE   :
+******************************************************************************/
+static int mp200_img_chksize(unsigned long back_size, unsigned long front_size,
+		unsigned long dest_size, char *num_size)
+{
+	/* src image(BACK) size check */
+	if (mp200_img_chksize_sub(back_size, IMG_FORMAT_SRCFMT_B_BIT,
+			IMG_FORMAT_SRCFMT_B_SFT, num_size) == FALSE) {
+		return FALSE;
+	}
+
+	/* src image(FRONT) size check */
+	if (mix_front_image) {
+		if (mp200_img_chksize_sub(front_size, IMG_FORMAT_SRCFMT_F_BIT,
+				IMG_FORMAT_SRCFMT_F_SFT, num_size) == FALSE)
+			return FALSE;
+
+		/* src image(FRONT) > src image(BACK) is incorrect.
+		 * except (OP_MODE12 or OP_MODE18)
+		 */
+		if (((img_mode & IMG_OP_MODE_BIT) != IMG_OP_MODE_12_BIT) &&
+			((img_mode & IMG_OP_MODE_BIT) != IMG_OP_MODE_18_BIT)) {
+			if (img_resize == RESIZE_ON_BACK) {
+				/* back image resize */
+				if (front_size > dest_size) {
+					printk(KERN_INFO
+					" @ipu: IMGIO_CONVERT: Error! "
+					"src_f_image.%s > dest_image.%s "
+					"is incorrect. (%ld > %ld)\n",
+					num_size, num_size,
+					front_size, dest_size);
+					return FALSE;
+				}
+			} else if (img_resize == RESIZE_ON_FRONT) {
+				/* front image resize */
+				if (dest_size > back_size) {
+					printk(KERN_INFO
+					" @ipu: IMGIO_CONVERT: Error! "
+					"dest_image.%s > src_b_image.%s is "
+					"incorrect. (%ld > %ld)\n",
+					num_size, num_size,
+					dest_size, back_size);
+					return FALSE;
+				}
+			} else {
+				/* no resize */
+				if (front_size > back_size) {
+					printk(KERN_INFO
+					" @ipu: IMGIO_CONVERT: Error! "
+					"src_f_image.%s > src_b_image.%s "
+					"is incorrect. (%ld > %ld)\n",
+					num_size, num_size,
+					front_size, back_size);
+					return FALSE;
+				}
+			}
+		}
+	}
+	/* dest image size check
+	 * dest_width is always checked,
+	 * because it's necessary for checking pitch.
+	 * dest_height is checked only at resize.
+	 */
+	if (strcmp(num_size, "hsize") == 0 || img_resize) {
+		if (mp200_img_chksize_sub(dest_size, IMG_FORMAT_DSTFMT_BIT,
+		  IMG_FORMAT_DSTFMT_SFT, num_size) == FALSE)
+			return FALSE;
+	}
+
+	/* resize check */
+	if (img_resize) {
+		unsigned long calc_size, max_rng, min_rng;
+		int  src_yuv;
+		char *num;
+
+		if (img_resize == RESIZE_ON_BACK) {
+			/* back image */
+			num	   = "src_b_image.";
+			src_yuv   = src_yuv_back;
+			calc_size = back_size;
+		} else {
+			/* front image */
+			num	   = "src_f_image.";
+			src_yuv   = src_yuv_front;
+			calc_size = front_size;
+		}
+
+		if (strcmp(num_size, "hsize") == 0)
+			min_rng = 40; /* width  min range x1/40 */
+		else
+			min_rng = 40; /* height min range x1/40 */
+
+		max_rng = 4;	/* max range x4 */
+
+		if (((min_rng * dest_size) < calc_size)
+		  || (dest_size > (max_rng * calc_size))) {
+			printk(KERN_INFO
+			" @ipu: IMGIO_CONVERT: Error! "
+			"dest_image.%s / %s%s(%ld/%ld) "
+			"(1/%ld - *%ld)\n",
+			num_size, num, num_size, dest_size,
+			calc_size, min_rng, max_rng);
+			return FALSE;
+		}
+	}
+
+	return TRUE;
+}
+
+
+/*****************************************************************************
+* MODULE   : mp200_img_chksize_sub
+* FUNCTION : check image size
+* IMPORT   : unsigned long size
+*          : unsigned long mode_fmt_bit
+*          : unsigned long mode_fmt_sft
+*          : char         *num_size
+* RETURN   : TRUE  : check OK
+*          : FALSE : check NG
+* NOTE     : none
+* CREATE   : 2006/11/07 M.Haguro
+* UPDATE   :
+******************************************************************************/
+static int mp200_img_chksize_sub(unsigned long size, unsigned long mode_fmt_bit,
+		unsigned long mode_fmt_sft, char *num_size)
+{
+	int   yuv_flag;
+	char  *num;
+	unsigned int min_size;
+
+	if (mode_fmt_bit == IMG_FORMAT_SRCFMT_B_BIT) {
+		/* src back */
+		yuv_flag = src_yuv_back;
+		min_size = 8;
+		num	  = "src_b_image.";
+	} else if (mode_fmt_bit == IMG_FORMAT_SRCFMT_F_BIT) {
+		/* src front */
+		yuv_flag = src_yuv_front;
+		min_size = 8;
+		num	  = "src_f_image.";
+	} else {
+		/* IMG_FORMAT_DSTFMT_BIT */
+		yuv_flag = dest_yuv;
+		min_size = 16;
+		num	  = "dst_image.";
+	}
+
+	if (size < min_size || size > 8188)
+		goto fail_size;
+
+	if (yuv_flag) {
+		/* YUV422/YUV420 */
+		if ((((format & mode_fmt_bit) >> mode_fmt_sft) ==
+				IMG_FORM_YUV420_PLANAR) ||
+			(((format & mode_fmt_bit) >> mode_fmt_sft) ==
+				IMG_FORM_YUV422_PLANAR)) {
+			if (size & 0x7)
+				goto fail_size;
+		} else if (((format & mode_fmt_bit) >> mode_fmt_sft) ==
+				IMG_FORM_YUV422_INTERLEAVE) {
+			/* YUV422-InterLeave */
+			if (size & 0x1)
+				goto fail_size;
+		} else {
+			/* YUV422-SemiPlanar/YUV420-SemiPlanar */
+			if (size & 0x3)
+				goto fail_size;
+		}
+	} else {
+		/* RGB565/RGB666/RGB888 */
+		if (((format & mode_fmt_bit) >> mode_fmt_sft) ==
+				IMG_FORM_RGB888) {
+			/* RGB888 */
+			if (size & 0x3)
+				goto fail_size;
+		} else if (((format & mode_fmt_bit) >> mode_fmt_sft) ==
+				IMG_FORM_RGB666) {
+			/* RGB666 */
+			if (size & 0xF)
+				goto fail_size;
+		} else {
+			/* RGB565 */
+			if (size & 0x1)
+				goto fail_size;
+		}
+	}
+
+	return TRUE;
+
+fail_size:
+	printk(KERN_INFO
+	" @ipu: IMGIO_CONVERT: Error! %s%s is incorrect. %s%s = 0x%lx\n",
+	num, num_size, num, num_size, size);
+	return FALSE;
+}
+
+
+/*****************************************************************************
+* MODULE   : mp200_img_chkcoordinate
+* FUNCTION : check image (x,y)chkcoordinate
+* IMPORT   :
+* RETURN   : TRUE  : check OK
+*          : FALSE : check NG
+* NOTE     : none
+* CREATE   : 2006/10/18 M.Sasaki
+* UPDATE   : 2008/03/14 M.Sasaki
+******************************************************************************/
+static int mp200_img_chkcoordinate(void)
+{
+	/* check pitch or x ,over width, by 4 pixel */
+	/* input data(BACK) check */
+	if (mp200_img_chkcoordinate_sub(IMG_FORMAT_SRCFMT_B_BIT,
+	  IMG_FORMAT_SRCFMT_B_SFT) == FALSE)
+		return FALSE;
+
+	/* input data(FRONT) check */
+	if (mix_front_image) {
+		if (mp200_img_chkcoordinate_sub(IMG_FORMAT_SRCFMT_F_BIT,
+		  IMG_FORMAT_SRCFMT_F_SFT) == FALSE)
+			return FALSE;
+
+	}
+	/* output data check */
+	if (mp200_img_chkcoordinate_sub(IMG_FORMAT_DSTFMT_BIT,
+	  IMG_FORMAT_DSTFMT_SFT) == FALSE)
+		return FALSE;
+
+
+	/* check x & check y by 2 pixel */
+	/* input data(BACK) check */
+	if (mp200_img_chkcoordinate_x_sub(src_x, IMG_FORMAT_SRCFMT_B_BIT,
+	  IMG_FORMAT_SRCFMT_B_SFT) == FALSE)
+		return FALSE;
+
+	if (mp200_img_chkcoordinate_y_sub(src_y, IMG_FORMAT_SRCFMT_B_BIT,
+	  IMG_FORMAT_SRCFMT_B_SFT) == FALSE)
+		return FALSE;
+
+	/* input data(FRONT) check */
+	if (mix_front_image) {
+		if (mp200_img_chkcoordinate_x_sub(src_x_F,
+		  IMG_FORMAT_SRCFMT_F_BIT, IMG_FORMAT_SRCFMT_F_SFT) == FALSE)
+			return FALSE;
+
+		if (mp200_img_chkcoordinate_y_sub(src_y_F,
+		  IMG_FORMAT_SRCFMT_F_BIT, IMG_FORMAT_SRCFMT_F_SFT) == FALSE)
+			return FALSE;
+
+	}
+
+	/* output data check */
+	if (mp200_img_chkcoordinate_x_sub(dest_x, IMG_FORMAT_DSTFMT_BIT,
+	  IMG_FORMAT_DSTFMT_SFT) == FALSE)
+		return FALSE;
+	if (mp200_img_chkcoordinate_y_sub(dest_y, IMG_FORMAT_DSTFMT_BIT,
+	  IMG_FORMAT_DSTFMT_SFT) == FALSE)
+		return FALSE;
+
+	/* check offset */
+	if (mix_front_image) {
+		unsigned long sw, sh;
+		if (img_resize == RESIZE_ON_BACK) {
+			/* back image resize */
+			sw = src_width_F;
+			sh = src_height_F;
+		} else {
+			sw = src_width;
+			sh = src_height;
+		}
+
+		if (dest_yuv) {
+			if (offset_x & 0x1)
+				goto fail_offset_x;
+			if (offset_y & 0x1)
+				goto fail_offset_y;
+		}
+
+		if ((dest_width == sw) && (dest_height == sh)) {
+			/* no offset */
+			if (offset_x != 0)
+				goto fail_offset_x;
+			if (offset_y != 0)
+				goto fail_offset_y;
+		} else if ((dest_width >= sw) && (dest_height >= sh)) {
+			if (offset_x > (dest_width  - sw))
+				goto fail_offset_x;
+			if (offset_y > (dest_height - sh))
+				goto fail_offset_y;
+		} else if ((dest_width <= sw) && (dest_height <= sh)) {
+			if (offset_x > (sw - dest_width))
+				goto fail_offset_x;
+			if (offset_y > (sh - dest_height))
+				goto fail_offset_y;
+		} else {
+			goto fail_ops;
+		}
+	}
+
+	return TRUE;
+
+fail_offset_x:
+	ERR_PRINT("offsetx", offset_x);
+	return FALSE;
+fail_offset_y:
+	ERR_PRINT("offsety", offset_y);
+	return FALSE;
+fail_ops:
+	printk(KERN_INFO
+	" @ipu: IMGIO_CONVERT: Error! This image position, "
+	"doesn't included even to BACK and FRONT any.\n");
+	return FALSE;
+}
+
+/*****************************************************************************
+* MODULE   : mp200_img_chkcoordinate_sub
+* FUNCTION : check memory size(pitch)
+* IMPORT   : unsigned long mode_fmt_bit
+*          : unsigned long mode_fmt_sft
+* RETURN   : TRUE  : check OK
+*          : FALSE : check NG
+* NOTE     : none
+* CREATE   : 2007/03/19 M.Haguro
+* UPDATE   :
+******************************************************************************/
+static int mp200_img_chkcoordinate_sub(unsigned long mode_fmt_bit,
+	unsigned long mode_fmt_sft)
+{
+	unsigned long size, x, w, max_size;
+	int  bpp, pix_dist;
+	char *num1, *num2;
+
+	if (mode_fmt_bit == IMG_FORMAT_SRCFMT_B_BIT) {
+		size	 = ulSrcScreenWidth;
+		x	 = src_x;
+		w	 = src_width;
+		max_size = MAX_SCREEN_WIDTH_BACK;
+		bpp	 = bits_par_pixel_B;
+		num1	 = "src_b_image.size";
+		num2	 = "src_b_image.x";
+	} else if (mode_fmt_bit == IMG_FORMAT_SRCFMT_F_BIT) {
+		size	 = ulSrcScreenWidth_F;
+		x	 = src_x_F;
+		w	 = src_width_F;
+		max_size = MAX_SCREEN_WIDTH;
+		bpp	 = bits_par_pixel_F;
+		num1	 = "src_f_image.size";
+		num2	 = "src_f_image.x";
+	} else {
+		/* IMG_FORMAT_DSTFMT_BIT */
+		size	 = ulDestScreenWidth;
+		x	 = dest_x;
+		w	 = dest_width;
+		max_size = MAX_SCREEN_WIDTH;
+		bpp	 = bits_par_pixel_D;
+		num1	 = "dest_image.size";
+		num2	 = "dest_image.x";
+	}
+
+	switch ((format & mode_fmt_bit) >> mode_fmt_sft) {
+	case IMG_FORM_YUV420_PLANAR:
+	case IMG_FORM_YUV422_PLANAR:
+		pix_dist  = 8 * bpp / 8;
+		break;
+	case IMG_FORM_YUV422_INTERLEAVE:
+	case IMG_FORM_RGB565:
+		pix_dist  = 2 * bpp / 8;
+		break;
+	case IMG_FORM_RGB666:
+		pix_dist  = 16 * bpp / 8;
+		break;
+	default:
+		/* YUV420-Semi-Planar / YUV422-Semi-Planar / RGB888 */
+		pix_dist  = 4 * bpp / 8;
+		break;
+	}
+	max_size = max_size / pix_dist * pix_dist;
+
+	/* check */
+	if ((size / (bpp / 8)) < (x + w)) {
+		printk(KERN_INFO
+		" @ipu: IMGIO_CONVERT: Error! %s or %s is incorrect. "
+		"size = %ld, x = %ld\n", num1, num2, size, x);
+		return FALSE;
+	}
+	if (size > max_size) {
+		ERR_PRINT(num1, size);
+		return FALSE;
+	}
+	if (size % pix_dist) {
+		ERR_PRINT(num1, size);
+		return FALSE;
+	}
+
+	return TRUE;
+}
+
+/*****************************************************************************
+* MODULE   : mp200_img_chkcoordinate_x_sub
+* FUNCTION : check image x coordinate
+* IMPORT   : unsigned long pos
+*          : unsigned long mode_fmt_bit
+*          : unsigned long mode_fmt_sft
+* RETURN   : TRUE  : check OK
+*          : FALSE : check NG
+* NOTE     : none
+* CREATE   : 2006/04/17 M.Haguro
+* UPDATE   :
+******************************************************************************/
+static int mp200_img_chkcoordinate_x_sub(unsigned long pos,
+	unsigned long mode_fmt_bit, unsigned long mode_fmt_sft)
+{
+	int   yuv_flag;
+	char *num;
+
+	if (mode_fmt_bit == IMG_FORMAT_SRCFMT_B_BIT) {
+		yuv_flag = src_yuv_back;
+		num	  = "src_b_image.x";
+	} else if (mode_fmt_bit == IMG_FORMAT_SRCFMT_F_BIT) {
+		yuv_flag = src_yuv_front;
+		num	  = "src_f_image.x";
+	} else {
+		/* IMG_FORMAT_DSTFMT_BIT */
+		yuv_flag = dest_yuv;
+		num	  = "dest_image.x";
+	}
+
+	if (yuv_flag) {
+		/* YUV422/YUV420 */
+		if (((format & mode_fmt_bit) >> mode_fmt_sft) ==
+				IMG_FORM_YUV420_PLANAR) {
+			/* YUV420-Planar */
+			if (pos & 0x7)
+				goto fail_pos;
+
+		} else {
+			/* YUV422-SemiPlanar/YUV422-InterLeave/
+			   YUV420-SemiPlanar */
+			if (pos & 0x3)
+				goto fail_pos;
+
+		}
+	} else {
+		/* RGB565/RGB888/RGB666 */
+		if (((format & mode_fmt_bit) >> mode_fmt_sft) ==
+				IMG_FORM_RGB888) {
+			/* RGB888 */
+			if (pos & 0x3)
+				goto fail_pos;
+
+		} else if (((format & mode_fmt_bit) >> mode_fmt_sft) ==
+				IMG_FORM_RGB666) {
+			/* RGB666 */
+			if (pos & 0xF)
+				goto fail_pos;
+
+		} else {
+			/* RGB565 */
+			if (pos & 0x1)
+				goto fail_pos;
+
+		}
+	}
+
+	return TRUE;
+
+fail_pos:
+	ERR_PRINT(num, pos);
+	return FALSE;
+}
+
+
+/*****************************************************************************
+* MODULE   : mp200_img_chkcoordinate_y_sub
+* FUNCTION : check image y coordinate
+* IMPORT   : unsigned long pos
+*          : unsigned long mode_fmt_bit
+*          : unsigned long mode_fmt_sft
+* RETURN   : TRUE  : check OK
+*          : FALSE : check NG
+* NOTE     : none
+* CREATE   : 2006/05/9 M.Haguro
+* UPDATE   :
+******************************************************************************/
+static int mp200_img_chkcoordinate_y_sub(unsigned long pos,
+	unsigned long mode_fmt_bit, unsigned long mode_fmt_sft)
+{
+	int   yuv_flag;
+	char *num;
+
+	if (mode_fmt_bit == IMG_FORMAT_SRCFMT_B_BIT) {
+		yuv_flag = src_yuv_back;
+		num	  = "src_b_image.y";
+	} else if (mode_fmt_bit == IMG_FORMAT_SRCFMT_F_BIT) {
+		yuv_flag = src_yuv_front;
+		num	  = "src_f_image.y";
+	} else {
+		/* IMG_FORMAT_DSTFMT_BIT */
+		yuv_flag = dest_yuv;
+		num	  = "dest_image.y";
+	}
+
+	if ((((format & mode_fmt_bit) >> mode_fmt_sft) ==
+		IMG_FORM_YUV420_PLANAR) ||
+	     (((format & mode_fmt_bit) >> mode_fmt_sft) ==
+	     IMG_FORM_YUV420_SEMI_PLANAR)) {
+		if (pos & 0x1)
+			goto fail_pos;
+
+	}
+
+	return TRUE;
+
+fail_pos:
+	ERR_PRINT(num, pos);
+	return FALSE;
+}
+
+
+/*****************************************************************************
+* MODULE   : mp200_img_chkaddr
+* FUNCTION : check image address
+* IMPORT   : none
+* RETURN   : TRUE  : check OK
+*          : FALSE : check NG
+* NOTE     : none
+* CREATE   : 2006/11/09 M.Sasaki
+* UPDATE   : 2008/03/14 M.Sasaki
+******************************************************************************/
+static int mp200_img_chkaddr(void)
+{
+	/* check input(BACK) Y/RGB data start address by 4 byte */
+	if (ulSrc == 0 || (ulSrc & 0x3) != 0) {
+		ERR_PRINT("src_b_image.yrgbadr", ulSrc);
+		return FALSE;
+	}
+
+	/* check input(BACK) UV data start address by 4 byte */
+	if (src_yuv_back && (src_format_b != IMG_FORM_YUV422_INTERLEAVE)) {
+		if (ulSrcU == 0 || (ulSrcU & 0x3) != 0) {
+			ERR_PRINT("src_b_image.uvadr", ulSrcU);
+			return FALSE;
+		}
+	}
+
+	/* check input(BACK) V data start address by 4 byte */
+	if (src_format_b == IMG_FORM_YUV420_PLANAR
+	  || src_format_b == IMG_FORM_YUV422_PLANAR) {
+		if (ulSrcV == 0 || (ulSrcV & 0x3) != 0) {
+			ERR_PRINT("src_b_image.vadr", ulSrcV);
+			return FALSE;
+		}
+	}
+
+	/* check input(FRONT) Y/RGB data start address by 4 byte */
+	if (mix_front_image) {
+		if (ulSrc_F == 0 || (ulSrc_F & 0x3) != 0) {
+			ERR_PRINT("src_f_image.yrgbadr", ulSrc_F);
+			return FALSE;
+		}
+
+		/* check input(FRONT) UV data start address by 4 byte */
+		if (src_yuv_front
+		  && (src_format_f != IMG_FORM_YUV422_INTERLEAVE)) {
+			if (ulSrcU_F == 0 || (ulSrcU_F & 0x3) != 0) {
+				ERR_PRINT("src_f_image.uvadr", ulSrcU_F);
+				return FALSE;
+			}
+		}
+
+		/* check input(FRONT) V data start address by 4 byte */
+		if (src_format_f == IMG_FORM_YUV420_PLANAR
+		  || src_format_f == IMG_FORM_YUV422_PLANAR) {
+			if (ulSrcV_F == 0 || (ulSrcV_F & 0x3) != 0) {
+				ERR_PRINT("src_f_image.vadr", ulSrcV_F);
+				return FALSE;
+			}
+		}
+	}
+
+	/* check output Y/RGB data start address by 4 byte */
+	if (ulDest == 0 || (ulDest & 0x3) != 0) {
+		ERR_PRINT("dest_image.yrgbadr", ulDest);
+		return FALSE;
+	}
+
+	/* check output UV data start address by 4 byte */
+	if (dest_yuv && (dst_format != IMG_FORM_YUV422_INTERLEAVE)) {
+		if (ulDestU == 0 || (ulDestU & 0x3) != 0) {
+			ERR_PRINT("dest_image.uvadr", ulDestU);
+			return FALSE;
+		}
+	}
+
+	/* check output V data start address by 4 byte */
+	if (dst_format == IMG_FORM_YUV420_PLANAR
+	  || dst_format == IMG_FORM_YUV422_PLANAR) {
+		if (ulDestV == 0 || (ulDestV & 0x3) != 0) {
+			ERR_PRINT("dest_image.vadr", ulDestV);
+			return FALSE;
+		}
+	}
+
+	return TRUE;
+}
+
+
+/*****************************************************************************
+* MODULE   : mp200_img_setaddr
+* FUNCTION : set image address
+* IMPORT   : none
+* RETURN   : TRUE  : check OK
+*          : FALSE : check NG
+* NOTE     : none
+* CREATE   : 2006/11/09 M.Sasaki
+* UPDATE   :
+******************************************************************************/
+static int mp200_img_setaddr(void)
+{
+	/* set src image address(BACK) */
+	ulSrcStarAddrYRGB = ulSrc + src_x  * bits_par_pixel_B / 8
+	  + src_y * ulSrcScreenWidth;
+	switch (src_format_b) {
+	/* YUV422 Semi-Planar */
+	case IMG_FORM_YUV422_SEMI_PLANAR:
+		ulSrcStarAddrU   = ulSrcU + src_x + src_y * ulSrcScreenWidth;
+		ulSrcStarAddrV_B = 0L;
+		break;
+
+	/* YUV420 Semi-Planar */
+	case IMG_FORM_YUV420_SEMI_PLANAR:
+		ulSrcStarAddrU   = ulSrcU + src_x
+		  + src_y / 2 * ulSrcScreenWidth;
+		ulSrcStarAddrV_B = 0L;
+		break;
+
+	/* YUV422 Planar */
+	case IMG_FORM_YUV422_PLANAR:
+		ulSrcStarAddrU   = ulSrcU + (src_x / 2)
+		  + src_y * ulSrcScreenWidth;
+		ulSrcStarAddrV_B = ulSrcV + (src_x / 2)
+		  + src_y * ulSrcScreenWidth;
+		break;
+
+	/* YUV420 Planar */
+	case IMG_FORM_YUV420_PLANAR:
+		ulSrcStarAddrU   = ulSrcU + (src_x / 2)
+		  + src_y / 2 * ulSrcScreenWidth;
+		ulSrcStarAddrV_B = ulSrcV + (src_x / 2)
+		  + src_y / 2 * ulSrcScreenWidth;
+		break;
+
+	/* YUV422 Interleave */
+	case IMG_FORM_YUV422_INTERLEAVE:
+	/* RGB565/888 */
+	case IMG_FORM_RGB888:
+	case IMG_FORM_RGB565:
+		ulSrcStarAddrU   = 0L;
+		ulSrcStarAddrV_B = 0L;
+		break;
+	}
+
+	/* set src image address(FRONT) */
+	if (mix_front_image) {
+		ulSrcStarAddrYRGB_F  = ulSrc_F
+		  + src_x_F * bits_par_pixel_F / 8
+		  + src_y_F * ulSrcScreenWidth_F;
+		switch (src_format_f) {
+		/* YUV422 Semi-Planar */
+		case IMG_FORM_YUV422_SEMI_PLANAR:
+			ulSrcStarAddrU_F = ulSrcU_F + src_x_F
+			  + src_y_F * ulSrcScreenWidth_F;
+			ulSrcStarAddrV_F = 0L;
+			break;
+
+		/* YUV420 Semi-Planar */
+		case IMG_FORM_YUV420_SEMI_PLANAR:
+			ulSrcStarAddrU_F = ulSrcU_F + src_x_F
+			  + src_y_F / 2 * ulSrcScreenWidth_F;
+			ulSrcStarAddrV_F = 0L;
+			break;
+
+		/* YUV422 Planar */
+		case IMG_FORM_YUV422_PLANAR:
+			ulSrcStarAddrU_F = ulSrcU_F + (src_x_F / 2)
+			  + src_y_F * ulSrcScreenWidth_F;
+			ulSrcStarAddrV_F = ulSrcV_F + (src_x_F / 2)
+			  + src_y_F * ulSrcScreenWidth_F;
+			break;
+
+		/* YUV420 Planar */
+		case IMG_FORM_YUV420_PLANAR:
+			ulSrcStarAddrU_F = ulSrcU_F + (src_x_F / 2)
+			  + src_y_F / 2 * ulSrcScreenWidth_F;
+			ulSrcStarAddrV_F = ulSrcV_F + (src_x_F / 2)
+			  + src_y_F / 2 * ulSrcScreenWidth_F;
+			break;
+
+		/* YUV422 Interleave */
+		case IMG_FORM_YUV422_INTERLEAVE:
+		/* RGB565/888 */
+		case IMG_FORM_RGB888:
+		case IMG_FORM_RGB565:
+			ulSrcStarAddrU_F = 0L;
+			ulSrcStarAddrV_F = 0L;
+			break;
+		}
+	}
+
+	/* set dest image address */
+	ulDestStarAddrYRGB = ulDest + dest_x * bits_par_pixel_D / 8
+	  + dest_y * ulDestScreenWidth;
+	switch (dst_format) {
+	/* YUV422 Semi-Planar */
+	case IMG_FORM_YUV422_SEMI_PLANAR:
+		ulDestStarAddrU = ulDestU + dest_x + dest_y * ulDestScreenWidth;
+		ulDestStarAddrV = 0L;
+		break;
+
+	/* YUV420 Semi-Planar */
+	case IMG_FORM_YUV420_SEMI_PLANAR:
+		ulDestStarAddrU = ulDestU + dest_x
+		  + dest_y / 2 * ulDestScreenWidth;
+		ulDestStarAddrV = 0L;
+		break;
+
+	/* YUV422 Planar */
+	case IMG_FORM_YUV422_PLANAR:
+		ulDestStarAddrU = ulDestU + (dest_x / 2)
+		  + dest_y * ulDestScreenWidth;
+		ulDestStarAddrV = ulDestV + (dest_x / 2)
+		  + dest_y * ulDestScreenWidth;
+		break;
+
+	/* YUV420 Planar */
+	case IMG_FORM_YUV420_PLANAR:
+		ulDestStarAddrU = ulDestU + (dest_x / 2)
+		  + dest_y / 2 * ulDestScreenWidth;
+		ulDestStarAddrV = ulDestV + (dest_x / 2)
+		  + dest_y / 2 * ulDestScreenWidth;
+		break;
+
+	/* YUV422 Interleave */
+	case IMG_FORM_YUV422_INTERLEAVE:
+	/* RGB565/666/888 */
+	case IMG_FORM_RGB888:
+	case IMG_FORM_RGB666:
+	case IMG_FORM_RGB565:
+		ulDestStarAddrU	 = 0L;
+		ulDestStarAddrV	 = 0L;
+		break;
+	}
+
+	return TRUE;
+}
+
+
+#endif /* _MP200_IMG_CONVERT_H_ */
diff --git a/drivers/ipu/mp200_ipu.c b/drivers/ipu/mp200_ipu.c
new file mode 100644
index 0000000..4a43946
--- /dev/null
+++ b/drivers/ipu/mp200_ipu.c
@@ -0,0 +1,3240 @@
+/*
+*  File Name       : /drivers/ipu/mp200_ipu.c
+*  Function        : IPU Driver
+*  Release Version : Ver 1.00
+*  Release Date    : 2006/11/20
+*
+*  Copyright (C) NEC Electronics Corporation 2006
+*
+*
+*  This program is free software;you can redistribute it and/or modify it
+*  under the terms of the GNU General Public License as published by Free
+*  Softwere Foundation; either version 2 of License, or (at your option) any
+*  later version.
+*
+*  This program is distributed in the hope that it will be useful, but WITHOUT
+*  ANY WARRANTY; without even the implied warrnty of MERCHANTABILITY or
+*  FITNESS FOR A PARTICULAR PURPOSE.
+*  See the GNU General Public License for more details.
+*
+*  You should have received a copy of the GNU General Public License along
+*  with this program; If not, write to the Free Software Foundation, Inc., 59
+*  Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+*
+*/
+
+#include <linux/kthread.h>
+#include "mp200_ipu.h"
+
+#define DRV_IPU DRV_IPU_IMG
+
+
+/****************************************************************************/
+/* Flags                                                                    */
+/****************************************************************************/
+#if defined(CONFIG_PM) || defined(CONFIG_DPM)
+static int DPM_suspend_flg = -1;
+#endif /* CONFIG_PM || CONFIG_DPM */
+static int img_empty_flg = 1;
+static int rot_empty_flg = 1;
+static int gdma_empty_flg = 1;
+
+#define TEMPBUF_LOG_PADDR  0x37F1C300
+#define TEMPBUF_LOG_LENGTH 0xE3D00
+
+/* IMG MMIO */
+static ulong IMGMmio		= IMAGEPROC_BASE;	/* paddr */
+static char *IMGMmioV;					/* vaddr */
+
+/* ROT MMIO */
+static ulong ROTMmio		= ROTATOR_BASE;	  /* paddr */
+static char *ROTMmioV;				/* vaddr */
+
+/* GDMA MMIO */
+static ulong GDMAMmio		= GDMA_BASE;	/* paddr */
+static char *GDMAMmioV;				/* vaddr */
+
+/* thread flag */
+static int thread_img_flag  = 1;		/* img  flag */
+static int thread_rot_flag  = 1;		/* rot  flag */
+static int thread_gdma_flag = 1;		/* gdma flag */
+
+static unsigned int dev_major = 194;
+static char *ipu_dev_name = "mp200_ipu";	 /* ipu_dev_name */
+
+MP200_IPU_DEV	*mp200_ipu_devices;	  /* allocated in mp200_ipu_init  */
+MP200_IPU_REQ_REGIST *mp200_ipu_req_bufs; /* allocated in mp200_ipu_init  */
+MP200_IPU_QUEUE	  *mp200_ipu_que;	  /* allocated in mp200_ipu_init  */
+
+int mp200_ipu_devs = MP200_IPU_DEVS;	  /* number of bare IPU devices	*/
+
+
+/****************************************************************************/
+/* Spinlock								    */
+/****************************************************************************/
+static spinlock_t ipu_lock;
+
+
+/****************************************************************************/
+/* IPU request informations						    */
+/****************************************************************************/
+#ifdef CONFIG_MP200_IPU_DUAL
+#define INDEX_MAX 2
+
+/* Informations of first IPU request */
+struct list_head  index_img;
+struct list_head  index_rot;
+struct list_head  index_gdma;
+
+/* Informations of execution IPU request */
+#define REQ_FREE 0
+#define REQ_USED 1
+
+struct mp200_ipu_task{
+	struct list_head req_list;
+	struct mp200_ipu_req_regist *request;	  /* request running flag */
+	int status;
+};
+
+/* Informations of last IPU request */
+static struct mp200_ipu_task request_img[INDEX_MAX];
+static struct mp200_ipu_task request_rot[INDEX_MAX];
+static struct mp200_ipu_task request_gdma[INDEX_MAX];
+#else
+/* Informations of last IPU request */
+/*  request running img  flag*/
+static struct mp200_ipu_req_regist *request_img;
+/*  request running rot  flag*/
+static struct mp200_ipu_req_regist *request_rot;
+/*  request running gdma flag*/
+static struct mp200_ipu_req_regist *request_gdma;
+#endif
+
+/* Informations of IPU request which suspended with left callback */
+struct mp200_ipu_req_leftcall {
+	ipu_callback_func   callback;
+	unsigned long       sequence;
+	unsigned long       data;
+	int                 ipu_hw_func;
+	int                 flag;
+};
+static struct mp200_ipu_req_leftcall IPU_REQ_leftcall;
+
+
+/****************************************************************************/
+/* Prototype declarations                                                   */
+/****************************************************************************/
+
+/* ------------------------------------------- */
+/* file_operations                             */
+/* ------------------------------------------- */
+static struct file_operations mp200_ipu_fops = {
+	.owner   = THIS_MODULE,
+	.ioctl   = mp200_ipu_ioctl,
+	.mmap	= mp200_ipu_mmap,
+	.open	= mp200_ipu_open,
+	.release = mp200_ipu_close,
+};
+
+static struct class		*mp200_ipu_class;
+static struct device *mp200_ipu_class_dev;
+			  dev_t		 t_dev;
+
+/* cdev fops */
+static struct cdev mp200_ipu_cdev = {
+	.owner =  THIS_MODULE,
+	.ops   = &mp200_ipu_fops,
+};
+
+
+/* ------------------------------------------- */
+/*   Initialize function                       */
+/* ------------------------------------------- */
+static int  mp200_ipu_init(void);
+
+
+/* ------------------------------------------- */
+/*   Private functions                         */
+/* ------------------------------------------- */
+/* initialize function */
+static int  mp200_ipu_hw_init(void);
+static int  mp200_ipu_reschedule_img(void *);
+static int  mp200_ipu_reschedule_rot(void *);
+static int  mp200_ipu_reschedule_gdma(void *);
+static void mp200_ipu_hw_int_enable(int ipu_hw_func);
+static void mp200_ipu_hw_int_disable(int ipu_hw_func);
+#ifdef CONFIG_MP200_IPU_DUAL
+static void mp200_ipu_hw_int_ffclr(int ipu_hw_func);
+#endif
+/* Queue operation function */
+static int  mp200_ipu_init_queue(void);
+static int  mp200_ipu_regist_queue(struct mp200_ipu_queue **pQueue,
+	struct mp200_ipu_req *p);
+static void mp200_ipu_remove_queue(unsigned long sequence, int ipu_hw_func);
+static void mp200_ipu_release_buf(struct mp200_ipu_req_regist *p);
+static struct mp200_ipu_req_regist *mp200_ipu_search_queue(
+	unsigned long sequence, int ipu_hw_func);
+static struct mp200_ipu_req_regist *mp200_ipu_search_queue_func(
+	unsigned long sequence, struct list_head *list);
+#ifdef CONFIG_MP200_IPU_DUAL
+/* Queue operation function for "DUAL_FF" */
+static void mp200_ipu_reqqueue_addtail(struct list_head *index,
+	struct mp200_ipu_task *request, struct mp200_ipu_req_regist *new_req);
+static void mp200_ipu_reqqueue_del(struct mp200_ipu_task *request);
+static void mp200_ipu_reqqueue_del_next_sequence(
+	struct mp200_ipu_task *request, unsigned long sequence);
+#if defined(CONFIG_PM) || defined(CONFIG_DPM)
+static int  mp200_ipu_reqqueue_search_empty(struct list_head *index);
+#endif /* CONFIG_PM || CONFIG_DPM */
+static int  mp200_ipu_reqqueue_search_index(struct mp200_ipu_task *request);
+static int  mp200_ipu_reqqueue_search_sequence(struct mp200_ipu_task *request,
+	unsigned long sequence);
+#endif
+/* request function */
+static int  mp200_ipu_request(struct mp200_ipu_req_regist *p);
+static void mp200_ipu_request_sub(struct mp200_ipu_req_regist *p,
+	int callback_flag);
+static void mp200_ipu_request_remove_sub(struct mp200_ipu_req_regist *p);
+static void mp200_ipu_request_release_sub(int ipu_hw_func);
+static void mp200_ipu_request_wakeup(int ipu_hw_func);
+
+static int mp200_ipu_req_finalize_img(struct mp200_ipu_req_regist *p);
+static int mp200_ipu_req_finalize_rot(struct mp200_ipu_req_regist *p);
+static int mp200_ipu_req_finalize_gdma(struct mp200_ipu_req_regist *p);
+static void mp200_ipu_req_finalize(struct mp200_ipu_req_regist *p, int *ret);
+
+
+#if defined(CONFIG_PM) || defined(CONFIG_DPM)
+/* ------------------------------------------- */
+/*   DPM functions							 */
+/* ------------------------------------------- */
+static int  mp200_ipu_suspend(struct platform_device *dev, pm_message_t state);
+static int  mp200_ipu_suspend_late(struct platform_device *dev,
+	pm_message_t state);
+static int  mp200_ipu_resume_early(struct platform_device *dev);
+static int  mp200_ipu_resume(struct platform_device *dev);
+
+#ifdef CONFIG_MP200_IPU_DUAL
+static int mp200_ipu_suspend_set_hwreq_flg(struct list_head *list_hw);
+static void mp200_ipu_resume_kick_next(struct list_head *list_hw, int irq);
+#else
+static int mp200_ipu_suspend_set_hwreq_flg(
+	struct mp200_ipu_req_regist *request_hw);
+static void mp200_ipu_resume_kick_next(
+	struct mp200_ipu_req_regist *request_hw, int irq);
+#endif /* CONFIG_MP200_IPU_DUAL */
+static void mp200_ipu_resume_kick(unsigned long num);
+static void mp200_ipu_resume_kick_finalize(void *task, int irq);
+static void mp200_ipu_resume_kick_wakeup(int hw_func);
+
+
+static struct platform_driver mp200_ipu_driver = {
+		.driver.name  = "mp200_image",
+		.driver.bus   = &platform_bus_type,
+		.suspend      = mp200_ipu_suspend,
+		.suspend_late = mp200_ipu_suspend_late,
+		.resume_early = mp200_ipu_resume_early,
+		.resume	   = mp200_ipu_resume,
+};
+
+
+static struct platform_device mp200_ipu_device = {
+		.name		= "MP200 IPU",
+		.dev.release = NULL,
+		.id		  = 0,
+};
+
+
+/* Tasklet */
+static DECLARE_TASKLET(ipu_nexttask, mp200_ipu_resume_kick, 0);
+
+
+
+/* Macros */
+static int ctrl_func = -1;
+#define Call_StatusCtrlFunc_ON() \
+		do {			\
+			ctrl_func = 1;	\
+		} while (0)
+#ifdef CONFIG_MP200_IPU_DUAL
+#define Call_StatusCtrlFunc_OFF() \
+		do {							   \
+			if (mp200_ipu_reqqueue_search_empty(&index_img) && \
+			   mp200_ipu_reqqueue_search_empty(&index_rot) &&  \
+			   mp200_ipu_reqqueue_search_empty(&index_gdma)) { \
+				ctrl_func = 0;				   \
+			}						   \
+		} while (0)
+#else  /* CONFIG_MP200_IPU_DUAL */
+#define Call_StatusCtrlFunc_OFF() \
+		do {							   \
+			if (!request_img && !request_rot && !request_gdma) {\
+				ctrl_func = 0;				   \
+			}						   \
+		} while (0)
+#endif /* CONFIG_MP200_IPU_DUAL */
+#else
+#define Call_StatusCtrlFunc_ON()
+#define Call_StatusCtrlFunc_OFF()
+#endif /* CONFIG_PM || CONFIG_DPM */
+
+
+/* ------------------------------------------- */
+/*   Interrupt Management functions	       */
+/* ------------------------------------------- */
+/* IPU interrupt handler */
+static irqreturn_t mp200_ipu_irq_handler(int irq, void *dev_id);
+static void mp200_ipu_irq_handler_sub(int irq, void *dev_id);
+
+
+/*****************************************************************************
+* MODULE   : mp200_ipu_regist
+* FUNCTION : register request in IPU Request's queue by other drivers.
+* RETURN   : IPU_REQ_REGISTERED(0) : the request is registered
+*          : IPU_REQ_BUSY(-1)	  : fail to registered request busy
+*          : IPU_REQ_PARAMERR(-2)  : fail to registered request Parameter error
+* NOTE     : none
+* CREATE   : 2006/10/02 M.Sasaki
+* UPDATE   :
+******************************************************************************/
+int mp200_ipu_regist(struct mp200_ipu_req *p)
+{
+	struct mp200_ipu_dev *dev = mp200_ipu_devices;
+	struct mp200_ipu_queue *pQueue = mp200_ipu_que;
+	int ret;
+	unsigned long flags;
+
+	dbg_GetStartTime(2);
+
+	if (p == NULL) {
+		printk(KERN_INFO
+		" @ipu: mp200_ipu_regist() Error! p(%p) is incorrect.\n", p);
+		return IPU_REQ_PARAMERR;
+	}
+	if ((p->ipu_hw_func != IPU_HW_FUNC_IMG) &&
+		(p->ipu_hw_func != IPU_HW_FUNC_ROT) &&
+		(p->ipu_hw_func != IPU_HW_FUNC_GDMA)) {
+		printk(KERN_INFO
+			" @ipu: mp200_ipu_regist() Error! "
+			"p->ipu_hw_func(%d) is incorrect.\n",
+			p->ipu_hw_func);
+		return IPU_REQ_PARAMERR;
+	}
+
+	spin_lock_irqsave(&ipu_lock, flags);	/* prohibit interrupts */
+	ret = mp200_ipu_regist_queue(&pQueue, p);	/* register request */
+	if (ret == IPU_REQ_REGISTERED) {
+		switch (p->ipu_hw_func) {	/* kernel thread wakeup */
+		case IPU_HW_FUNC_IMG:
+			img_empty_flg = 0;
+			break;
+		case IPU_HW_FUNC_ROT:
+			rot_empty_flg = 0;
+			break;
+		case IPU_HW_FUNC_GDMA:
+			gdma_empty_flg = 0;
+			break;
+		}
+	}
+	spin_unlock_irqrestore(&ipu_lock, flags);	/* permit interrupts */
+	if (ret != IPU_REQ_REGISTERED) {
+		printk(KERN_INFO " @ipu: mp200_ipu_regist() Error! "
+		"mp200_ipu_regist_queue(%d) is incorrect.\n", ret);
+		return ret;
+	}
+
+	switch (p->ipu_hw_func) {
+	/* kernel thread wakeup */
+	case IPU_HW_FUNC_IMG:
+		wake_up_interruptible(&dev->wait_idle_img);
+		break;
+	case IPU_HW_FUNC_ROT:
+		wake_up_interruptible(&dev->wait_idle_rot);
+		break;
+	case IPU_HW_FUNC_GDMA:
+		wake_up_interruptible(&dev->wait_idle_gdma);
+		break;
+	}
+	return ret;
+}
+EXPORT_SYMBOL(mp200_ipu_regist);
+
+
+/*****************************************************************************
+* MODULE   : mp200_ipu_cancel
+* FUNCTION : cancel registered IPU request
+*    target IPU request has not been started :
+*      remove the target request from the queue.
+*    target IPU request has been started (running) :
+*      without IPU_CANCEL_SYNC :
+*        set IPU_CANCEL_WAIT to the status of the request,
+*        and wait for the request to be done.
+*        Then call the callback function with IPU_CALLBACK_CANCEL flag.
+*      with IPU_CANCEL_SYNC    :
+*        remove the target request from the queue immediately.
+*        and clear callback_flag (don't call the callback function).
+* RETURN   : IPU_CANCEL_DONE(0)   : cancelled
+*            IPU_CANCEL_WAIT(1)   : waiting for cancelled request to be done
+*            IPU_CANCEL_NO_REQ(2) : target request does not exist
+* NOTE     :1) Pay attention to the exclusive control between mp200_ipu_cancel
+*             and mp200_ipu_irq_handler.
+*             ex.)prohibit interrupts while updating the status.
+*           2) if serious delay problem occurs with Preferred Request, It should
+*             be required to add new function which resets IPU through SMU.
+* CREATE   : 2006/10/02 M.Sasaki
+* UPDATE   :
+******************************************************************************/
+int mp200_ipu_cancel(unsigned long sequence, int flag)
+{
+	struct mp200_ipu_req_regist *p_tmp;
+	unsigned long flags;
+	int ret;
+
+	if (!sequence)
+		return IPU_CANCEL_NO_REQ;
+
+	/* prohibit interrupts */
+	/* disable interrupts */
+	spin_lock_irqsave(&ipu_lock, flags);
+
+	/* target request all search */
+	p_tmp = mp200_ipu_search_queue(sequence, IPU_HW_FUNC_ALL);
+	if (p_tmp != NULL) {
+		if (p_tmp->ipu_req.status == IPU_REQ_STATUS_RUNNING) {
+			/* target request is running */
+			if (flag == IPU_CANCEL_SYNC) {
+				/* cansel(remove)start */
+				p_tmp->ipu_req.status =
+					IPU_REQ_STATUS_CANCEL;
+				mp200_ipu_remove_queue(sequence,
+					p_tmp->ipu_req.ipu_hw_func);
+				p_tmp->ipu_req.status =
+					IPU_REQ_STATUS_CANCELLED;
+
+				p_tmp->callback_flag = FALSE;
+				ret = IPU_CANCEL_DONE;	  /* cancelled */
+			} else {
+				p_tmp->ipu_req.status =
+					IPU_REQ_STATUS_WAIT_CANCEL;
+				/* waiting for cancelled request to be done */
+				ret = IPU_CANCEL_WAIT;
+			}
+		} else {
+			/* target request is not running */
+			/* cansel(remove)start */
+			p_tmp->ipu_req.status = IPU_REQ_STATUS_CANCEL;
+			mp200_ipu_remove_queue(sequence,
+				p_tmp->ipu_req.ipu_hw_func);
+			p_tmp->ipu_req.status = IPU_REQ_STATUS_CANCELLED;
+			mp200_ipu_release_buf(p_tmp);
+			ret = IPU_CANCEL_DONE;		  /* cancelled */
+		}
+	} else {
+		/* target request does not exist */
+		ret = IPU_CANCEL_NO_REQ;
+	}
+
+	/* permit interrupts */
+	spin_unlock_irqrestore(&ipu_lock, flags);	/* enable interrupts */
+
+	return ret;
+}
+EXPORT_SYMBOL(mp200_ipu_cancel);
+
+
+/* ------------------------------------------- */
+/*   kernel-thread main function			   */
+/* ------------------------------------------- */
+#if _IPU_RT_THREAD /* RT thread */
+#define IPU_THREAD_PRIORITY 1
+#else /* Normal thread */
+#define IPU_THREAD_PRIORITY 99
+#endif
+/*****************************************************************************
+* MODULE   : mp200_ipu_reschedule_img
+* FUNCTION : start to run request in IMG Request's queue.(IMG thread)
+* RETURN   : 0
+* NOTE     : none
+* CREATE   : 2006/10/04 M.Sasaki
+* UPDATE   :
+******************************************************************************/
+static int mp200_ipu_reschedule_img(void *dev_p)
+{
+	static int isfirst_img = 1;	 /* flag for request_irq(INT_IMG) */
+#if _IPU_RT_THREAD /* RT thread */
+	struct sched_param param = { .sched_priority = IPU_THREAD_PRIORITY };
+#endif
+	struct mp200_ipu_dev *dev = dev_p;
+	struct mp200_ipu_queue *pQueue = mp200_ipu_que;
+	struct mp200_ipu_req_regist *p_tmp = NULL;
+	struct list_head *list_queue;
+	unsigned long flags;
+	int ret;
+#ifdef CONFIG_MP200_IPU_DUAL
+	int req_index = -1;
+	int find_list = 0;
+#endif
+
+	strcpy(current->comm, "kipu_img");
+#if _IPU_RT_THREAD /* RT thread */
+	sched_setscheduler(current, SCHED_FIFO, &param);
+#else /* Normal thread */
+	current->static_prio = IPU_THREAD_PRIORITY;
+#endif
+
+	do {
+		if (!thread_img_flag)
+			break;
+
+#if defined(CONFIG_PM) || defined(CONFIG_DPM)
+		try_to_freeze();
+#endif /* CONFIG_PM || CONFIG_DPM */
+
+#ifdef CONFIG_MP200_IPU_DUAL
+		req_index = mp200_ipu_reqqueue_search_index(request_img);
+		if (req_index == -1) {	/* IMG task is running full */
+#else
+		if (request_img) {		/* IMG is running */
+#endif
+			/* waiting (executing operaion) */
+			dbg_SetSleepStatus(SLEEP_2);
+#ifdef CONFIG_MP200_IPU_DUAL
+			wait_event_interruptible(dev->wait_busy_img,
+			  (mp200_ipu_reqqueue_search_index(request_img) != -1));
+#else
+			wait_event_interruptible(dev->wait_busy_img,
+			  (request_img == NULL));
+#endif
+			dbg_ClrSleepStatus(SLEEP_2);
+		} else {
+			/* prohibit interrupts */
+			/* disable interrupts */
+			spin_lock_irqsave(&ipu_lock, flags);
+
+#ifdef CONFIG_MP200_IPU_DUAL
+			find_list = 0;
+#endif
+			/* not exist:1  exist:0 */
+			if (!list_empty(&pQueue->ipu_queue_img)) {
+				/* Requests exist */
+				list_for_each(
+					list_queue, &pQueue->ipu_queue_img) {
+					p_tmp = list_entry(list_queue,
+						struct mp200_ipu_req_regist,
+						ipu_req_regist);
+					if (p_tmp->ipu_req.status ==
+						IPU_REQ_STATUS_REGISTERED) {
+						Call_StatusCtrlFunc_ON();
+#ifdef CONFIG_MP200_IPU_DUAL
+						find_list = 1;
+						break;
+					}
+				}
+#else
+						request_img = p_tmp;
+						p_tmp->callback_flag  =
+							TRUE;
+						/* update status */
+						p_tmp->ipu_req.status =
+							IPU_REQ_STATUS_RUNNING;
+						break;
+					}
+				}
+#endif
+
+#ifdef CONFIG_MP200_IPU_DUAL
+				if (find_list) {
+					/* permit interrupts */
+					/* enable interrupts */
+					spin_unlock_irqrestore(
+						&ipu_lock, flags);
+
+					/* disable interrupts */
+					spin_lock_irqsave(&ipu_lock, flags);
+					p_tmp->callback_flag  = TRUE;
+					/* update status */
+					p_tmp->ipu_req.status =
+						IPU_REQ_STATUS_RUNNING;
+					mp200_ipu_reqqueue_addtail(
+						&index_img,
+						&request_img[req_index],
+						p_tmp);
+					/* enable interrupts */
+					spin_unlock_irqrestore(
+						&ipu_lock, flags);
+
+					if (isfirst_img) {
+						mp200_ipu_hw_int_disable(
+							IPU_HW_FUNC_IMG);
+						ret = request_irq(
+							INT_IMG,
+							mp200_ipu_irq_handler,
+							0, ipu_dev_name, NULL);
+						if (ret < 0) {
+							/* -- */
+							printk(KERN_ERR
+							" @ipu: fail in "
+							"request_irq(%d)\n",
+							INT_IMG);
+						}
+						isfirst_img = 0;
+					}
+					/* set IPU registers & run IPU */
+					ret = mp200_ipu_request(p_tmp);
+					if (ret == -2) {
+						/* disable interrupts */
+						spin_lock_irqsave(
+							&ipu_lock, flags);
+						mp200_ipu_reqqueue_del(
+						&request_img[req_index]);
+						/* STATUS_RUNNING
+						   -> STATUS_REGISTERED */
+						p_tmp->ipu_req.status =
+						IPU_REQ_STATUS_REGISTERED;
+						/* enable interrupts */
+						spin_unlock_irqrestore(
+							&ipu_lock, flags);
+					}
+					schedule();
+				} else {
+					goto img_empty;
+				}
+#else
+				/* permit interrupts */
+				/* enable interrupts */
+				spin_unlock_irqrestore(&ipu_lock, flags);
+
+				if (request_img) {
+					if (isfirst_img) {
+						mp200_ipu_hw_int_disable(
+							IPU_HW_FUNC_IMG);
+						ret = request_irq(
+							INT_IMG,
+							mp200_ipu_irq_handler,
+							0, ipu_dev_name, NULL);
+						if (ret < 0) {
+							/* -- */
+							printk(KERN_ERR
+							" @ipu: fail in "
+							"request_irq(%d)\n",
+							INT_IMG);
+						}
+						isfirst_img = 0;
+					}
+					/* set IPU registers & run IPU */
+					mp200_ipu_request(p_tmp);
+				}
+#endif
+			} else {
+			/* Requests not exist */
+#ifdef CONFIG_MP200_IPU_DUAL
+img_empty:
+#endif
+				img_empty_flg = 1;
+
+				/* permit interrupts */
+				/* enable interrupts */
+				spin_unlock_irqrestore(&ipu_lock, flags);
+
+				dbg_SetSleepStatus(SLEEP_4);
+				wait_event_interruptible(dev->wait_idle_img,
+					(img_empty_flg == 0));
+				dbg_ClrSleepStatus(SLEEP_4);
+			}
+		}
+	} while (1);
+
+	return 0;
+}
+
+
+/*****************************************************************************
+* MODULE   : mp200_ipu_reschedule_rot
+* FUNCTION : start to run request in ROT Request's queue.(ROT thread)
+* RETURN   : 0
+* NOTE     : none
+* CREATE   : 2006/10/04 M.Sasaki
+* UPDATE   :
+******************************************************************************/
+static int mp200_ipu_reschedule_rot(void *dev_p)
+{
+	static int isfirst_rot = 1;	 /* flag for request_irq(INT_ROT) */
+#if _IPU_RT_THREAD /* RT thread */
+	struct sched_param param = { .sched_priority = IPU_THREAD_PRIORITY };
+#endif
+	struct mp200_ipu_dev *dev = dev_p;
+	struct mp200_ipu_queue *pQueue = mp200_ipu_que;
+	struct mp200_ipu_req_regist *p_tmp = NULL;
+	struct list_head *list_queue;
+	unsigned long flags;
+	int ret;
+#ifdef CONFIG_MP200_IPU_DUAL
+	int req_index = -1;
+	int find_list = 0;
+#endif
+
+	strcpy(current->comm, "kipu_rot");
+#if _IPU_RT_THREAD /* RT thread */
+	sched_setscheduler(current, SCHED_FIFO, &param);
+#else /* Normal thread */
+	current->static_prio = IPU_THREAD_PRIORITY;
+#endif
+
+	do {
+		if (!thread_rot_flag)
+			break;
+
+#if defined(CONFIG_PM) || defined(CONFIG_DPM)
+		try_to_freeze();
+#endif /* CONFIG_PM || CONFIG_DPM */
+
+#ifdef CONFIG_MP200_IPU_DUAL
+		req_index = mp200_ipu_reqqueue_search_index(request_rot);
+		if (req_index == -1) {	/* ROT task is running full */
+#else
+		if (request_rot) {		/* ROT is running */
+#endif
+			/* waiting (executing operaion) */
+			dbg_SetSleepStatus(SLEEP_6);
+#ifdef CONFIG_MP200_IPU_DUAL
+			wait_event_interruptible(dev->wait_busy_rot,
+			 (mp200_ipu_reqqueue_search_index(request_rot) != -1));
+#else
+			wait_event_interruptible(dev->wait_busy_rot,
+			 (request_rot == NULL));
+#endif
+			dbg_ClrSleepStatus(SLEEP_6);
+		} else {
+			/* prohibit interrupts */
+			/* disable interrupts */
+			spin_lock_irqsave(&ipu_lock, flags);
+
+#ifdef CONFIG_MP200_IPU_DUAL
+			find_list = 0;
+#endif
+			/* not exist:1  exist:0 */
+			if (!list_empty(&pQueue->ipu_queue_rot)) {
+				/* Requests exist */
+				list_for_each(
+					list_queue, &pQueue->ipu_queue_rot) {
+					p_tmp = list_entry(
+						list_queue,
+						struct mp200_ipu_req_regist,
+						ipu_req_regist);
+					if (p_tmp->ipu_req.status ==
+						IPU_REQ_STATUS_REGISTERED) {
+						Call_StatusCtrlFunc_ON();
+#ifdef CONFIG_MP200_IPU_DUAL
+						mp200_ipu_reqqueue_addtail(
+							&index_rot,
+							&request_rot[req_index],
+							p_tmp);
+						find_list = 1;
+#else
+						request_rot = p_tmp;
+#endif
+						p_tmp->callback_flag  = TRUE;
+						/* update status */
+						p_tmp->ipu_req.status =
+							IPU_REQ_STATUS_RUNNING;
+						break;
+					}
+				}
+#ifdef CONFIG_MP200_IPU_DUAL
+				if (find_list) {
+					/* permit interrupts */
+					/* enable interrupts */
+					spin_unlock_irqrestore(
+						&ipu_lock, flags);
+
+					if (isfirst_rot) {
+						mp200_ipu_hw_int_disable(
+							IPU_HW_FUNC_ROT);
+						ret = request_irq(
+							INT_ROT,
+							mp200_ipu_irq_handler,
+							0, ipu_dev_name, NULL);
+						if (ret < 0) {
+							/* -- */
+							printk(KERN_ERR
+							" @ipu: fail in "
+							"request_irq(%d)\n",
+							INT_ROT);
+						}
+						isfirst_rot = 0;
+					}
+					/* set IPU registers & run IPU */
+					ret = mp200_ipu_request(p_tmp);
+					if (ret == -2) {
+						/* disable interrupts */
+						spin_lock_irqsave(
+							&ipu_lock, flags);
+						mp200_ipu_reqqueue_del(
+						&request_rot[req_index]);
+						p_tmp->ipu_req.status =
+						IPU_REQ_STATUS_REGISTERED;
+						/* enable interrupts */
+						spin_unlock_irqrestore(
+							&ipu_lock, flags);
+					}
+					schedule();
+				} else {
+					goto rot_empty;
+				}
+#else
+				/* permit interrupts */
+				/* enable interrupts */
+				spin_unlock_irqrestore(&ipu_lock, flags);
+
+				if (request_rot) {
+					if (isfirst_rot) {
+						mp200_ipu_hw_int_disable(
+							IPU_HW_FUNC_ROT);
+						ret = request_irq(INT_ROT,
+							mp200_ipu_irq_handler,
+							0, ipu_dev_name, NULL);
+						if (ret < 0) {
+							/* -- */
+							printk(KERN_ERR
+							" @ipu: fail in "
+							"request_irq(%d)\n",
+							INT_ROT);
+						}
+						isfirst_rot = 0;
+					}
+					/* set IPU registers & run IPU */
+					mp200_ipu_request(p_tmp);
+				}
+#endif
+			} else {
+				/* Requests not exist */
+#ifdef CONFIG_MP200_IPU_DUAL
+rot_empty:
+#endif
+				rot_empty_flg = 1;
+
+				/* permit interrupts */
+				/* enable interrupts */
+				spin_unlock_irqrestore(&ipu_lock, flags);
+
+				dbg_SetSleepStatus(SLEEP_8);
+				wait_event_interruptible(dev->wait_idle_rot,
+					(rot_empty_flg == 0));
+				dbg_ClrSleepStatus(SLEEP_8);
+			}
+		}
+	} while (1);
+
+	return 0;
+}
+
+
+/*****************************************************************************
+* MODULE   : mp200_ipu_reschedule_gdma
+* FUNCTION : start to run request in GDMA Request's queue.(GDMA thread)
+* RETURN   : 0
+* NOTE     : none
+* CREATE   : 2006/10/04 M.Sasaki
+* UPDATE   :
+******************************************************************************/
+static int mp200_ipu_reschedule_gdma(void *dev_p)
+{
+	static int isfirst_gdma = 1;	/* flag for request_irq(INT_IPU_DMA) */
+#if _IPU_RT_THREAD /* RT thread */
+	struct sched_param param = { .sched_priority = IPU_THREAD_PRIORITY };
+#endif
+	struct mp200_ipu_dev *dev = dev_p;
+	struct mp200_ipu_queue *pQueue = mp200_ipu_que;
+	struct mp200_ipu_req_regist *p_tmp = NULL;
+	struct list_head *list_queue;
+	unsigned long flags;
+	int ret;
+#ifdef CONFIG_MP200_IPU_DUAL
+	int req_index = -1;
+	int find_list = 0;
+#endif
+
+	strcpy(current->comm, "kipu_gdma");
+#if _IPU_RT_THREAD /* RT thread */
+	sched_setscheduler(current, SCHED_FIFO, &param);
+#else /* Normal thread */
+	current->static_prio = IPU_THREAD_PRIORITY;
+#endif
+
+	do {
+		if (!thread_gdma_flag)
+			break;
+
+#if defined(CONFIG_PM) || defined(CONFIG_DPM)
+		try_to_freeze();
+#endif /* CONFIG_PM || CONFIG_DPM */
+
+#ifdef CONFIG_MP200_IPU_DUAL
+		req_index = mp200_ipu_reqqueue_search_index(request_gdma);
+		/* GDMA task is running full */
+		if (req_index == -1) {
+#else
+		/* GDMA is running */
+		if (request_gdma) {
+#endif
+			/* waiting (executing operaion) */
+			dbg_SetSleepStatus(SLEEP_10);
+#ifdef CONFIG_MP200_IPU_DUAL
+			wait_event_interruptible(dev->wait_busy_gdma,
+			 (mp200_ipu_reqqueue_search_index(request_gdma)
+				!= -1));
+#else
+			wait_event_interruptible(dev->wait_busy_gdma,
+			 (request_gdma == NULL));
+#endif
+			dbg_ClrSleepStatus(SLEEP_10);
+		} else {
+			/* prohibit interrupts */
+			/* disable interrupts */
+			spin_lock_irqsave(&ipu_lock, flags);
+
+#ifdef CONFIG_MP200_IPU_DUAL
+			find_list = 0;
+#endif
+			/* not exist:1  exist:0 */
+			if (!list_empty(&pQueue->ipu_queue_gdma)) {
+				/* Requests exist */
+				list_for_each(list_queue,
+					&pQueue->ipu_queue_gdma) {
+					p_tmp = list_entry(list_queue,
+					  struct mp200_ipu_req_regist,
+					  ipu_req_regist);
+					if (p_tmp->ipu_req.status ==
+						IPU_REQ_STATUS_REGISTERED) {
+						Call_StatusCtrlFunc_ON();
+#ifdef CONFIG_MP200_IPU_DUAL
+						mp200_ipu_reqqueue_addtail(
+						&index_gdma,
+						&request_gdma[req_index],
+						p_tmp);
+						find_list = 1;
+#else
+						request_gdma = p_tmp;
+#endif
+						p_tmp->callback_flag  =
+							TRUE;
+						/* update status */
+						p_tmp->ipu_req.status =
+							IPU_REQ_STATUS_RUNNING;
+						break;
+					}
+				}
+
+#ifdef CONFIG_MP200_IPU_DUAL
+				if (find_list) {
+					/* permit interrupts */
+					/* enable interrupts */
+					spin_unlock_irqrestore(&ipu_lock,
+						flags);
+
+					if (isfirst_gdma) {
+						mp200_ipu_hw_int_disable(
+							IPU_HW_FUNC_GDMA);
+						ret = request_irq(INT_IPU_DMA,
+							mp200_ipu_irq_handler,
+							0, ipu_dev_name, NULL);
+						if (ret < 0) {
+							/* -- */
+							printk(KERN_ERR
+							" @ipu: fail in "
+							"request_irq(%d)\n",
+							INT_IPU_DMA);
+						}
+						isfirst_gdma = 0;
+					}
+					/* set IPU registers & run IPU */
+					ret = mp200_ipu_request(p_tmp);
+					if (ret == -2) {
+						/* disable interrupts */
+						spin_lock_irqsave(&ipu_lock,
+							flags);
+						mp200_ipu_reqqueue_del(
+						  &request_gdma[req_index]);
+						p_tmp->ipu_req.status =
+						IPU_REQ_STATUS_REGISTERED;
+						/* enable interrupts */
+						spin_unlock_irqrestore(
+							&ipu_lock, flags);
+					}
+					schedule();
+				} else {
+					goto gdma_empty;
+				}
+#else
+				/* permit interrupts */
+				/* enable interrupts */
+				spin_unlock_irqrestore(&ipu_lock, flags);
+
+				if (request_gdma) {
+					if (isfirst_gdma) {
+						mp200_ipu_hw_int_disable(
+							IPU_HW_FUNC_GDMA);
+						ret = request_irq(INT_IPU_DMA,
+							mp200_ipu_irq_handler,
+							0, ipu_dev_name, NULL);
+						if (ret < 0) {
+							/* -- */
+							printk(KERN_ERR
+							" @ipu: fail in "
+							"request_irq(%d)\n",
+							INT_IPU_DMA);
+						}
+						isfirst_gdma = 0;
+					}
+					/* set IPU registers & run IPU */
+					mp200_ipu_request(p_tmp);
+				}
+#endif
+			} else {
+			/* Requests not exist */
+#ifdef CONFIG_MP200_IPU_DUAL
+gdma_empty:
+#endif
+				gdma_empty_flg = 1;
+
+				/* permit interrupts */
+				/* enable interrupts */
+				spin_unlock_irqrestore(&ipu_lock, flags);
+
+				dbg_SetSleepStatus(SLEEP_11);
+				wait_event_interruptible(dev->wait_idle_gdma,
+					(gdma_empty_flg == 0));
+				dbg_ClrSleepStatus(SLEEP_11);
+			}
+		}
+	} while (1);
+
+	return 0;
+}
+
+
+/* ------------------------------------------- */
+/*   Initialize function                       */
+/* ------------------------------------------- */
+/*****************************************************************************
+* MODULE   : mp200_ipu_init_queue
+* FUNCTION : initialize IPU Queue
+* RETURN   :        0 : success
+*          : negative : fail
+* NOTE     : none
+* CREATE   : 2006/10/02 M.Sasaki
+* UPDATE   :
+******************************************************************************/
+static int mp200_ipu_init_queue(void)
+{
+	MP200_IPU_REQ_REGIST *que_regist;
+	size_t size_que;
+	int ret = 0;
+	int i;
+
+	/* queue struct */
+	size_que = sizeof(MP200_IPU_QUEUE);
+	mp200_ipu_que = kmalloc(size_que, GFP_KERNEL);
+	if (!mp200_ipu_que) {
+		ret = -ENOMEM;
+		goto fail_que;
+	}
+	memset(mp200_ipu_que, 0, size_que);
+	INIT_LIST_HEAD(&mp200_ipu_que->ipu_queue_img);
+	INIT_LIST_HEAD(&mp200_ipu_que->ipu_queue_rot);
+	INIT_LIST_HEAD(&mp200_ipu_que->ipu_queue_gdma);
+	mp200_ipu_que->sequence = 0;
+
+#ifdef CONFIG_MP200_IPU_DUAL
+	/* Informations of execution IPU request */
+	INIT_LIST_HEAD(&index_img);
+	INIT_LIST_HEAD(&index_rot);
+	INIT_LIST_HEAD(&index_gdma);
+
+	memset(request_img,  0, sizeof(struct mp200_ipu_task) * INDEX_MAX);
+	memset(request_rot,  0, sizeof(struct mp200_ipu_task) * INDEX_MAX);
+	memset(request_gdma, 0, sizeof(struct mp200_ipu_task) * INDEX_MAX);
+#endif
+
+	/* queue request struct */
+	mp200_ipu_req_bufs = kmalloc(MAX_SIZE_MP200_IPU_REQ_REGIST
+				     * IPU_BUFS_MAX, GFP_KERNEL);
+	if (!mp200_ipu_req_bufs) {
+		ret = -ENOMEM;
+		goto fail_regist;
+	}
+	memset(mp200_ipu_req_bufs, 0,
+		MAX_SIZE_MP200_IPU_REQ_REGIST * IPU_BUFS_MAX);
+	que_regist = mp200_ipu_req_bufs;
+	for (i = 0; i < IPU_BUFS_MAX; i++) {
+		mp200_ipu_que->bufs[i] = que_regist;
+		INIT_LIST_HEAD(&que_regist->ipu_req_regist);
+		que_regist->ipu_req.status = IPU_REQ_STATUS_IDLE;
+		que_regist = (MP200_IPU_REQ_REGIST *)((char *)que_regist
+			     + MAX_SIZE_MP200_IPU_REQ_REGIST);
+	}
+
+	goto success;
+
+ fail_regist:
+	 kfree(mp200_ipu_que);
+
+ fail_que:
+
+ success:
+
+	return ret;
+}
+
+
+/*****************************************************************************
+* MODULE   : mp200_ipu_init
+* FUNCTION : initialize IPU Driver
+* RETURN   :        0 : success
+*          : negative : fail
+* NOTE     : none
+* CREATE   : 2006/10/04 M.Sasaki
+* UPDATE   :
+******************************************************************************/
+static int mp200_ipu_init(void)
+{
+	MP200_IPU_DEV	  *dev;
+	MP200_IPU_DEV_INFO *dev_info;
+	int ret = 0;
+	int i;
+	struct task_struct *task_img = NULL;
+	struct task_struct *task_rot = NULL;
+	struct task_struct *task_gdma = NULL;
+
+
+	/* allocate and initialize Device Information Structure */
+	size_t size_dev_info = sizeof(MP200_IPU_DEV_INFO)
+			       + sizeof(struct mp200_ipu_reg_info) *
+			       IPU_REG_INFO_MAX;
+	size_t size_dev = sizeof(MP200_IPU_DEV)
+			  + size_dev_info * mp200_ipu_devs;
+
+	mp200_ipu_devices = kmalloc(size_dev, GFP_KERNEL);
+
+	if (!mp200_ipu_devices) {
+		ret = -ENOMEM;
+		printk(KERN_ERR
+		" @ipu: allocate failure Device Information Structure\n");
+		goto fail_malloc;
+	}
+	memset(mp200_ipu_devices, 0, size_dev);
+	dev = mp200_ipu_devices;
+	dev_info = dev->ipu_dev_info;
+	for (i = 0; i < mp200_ipu_devs; i++) {
+		sema_init(&dev_info->sem, 1);
+		sema_init(&dev_info->sem_vm, 1);
+		init_waitqueue_head(&dev_info->wait_que);
+		dev_info = (MP200_IPU_DEV_INFO *)((char *)dev_info
+			   + size_dev_info);
+	}
+
+	init_waitqueue_head(&dev->wait_idle_img);
+	init_waitqueue_head(&dev->wait_idle_rot);
+	init_waitqueue_head(&dev->wait_idle_gdma);
+	init_waitqueue_head(&dev->wait_busy_img);
+	init_waitqueue_head(&dev->wait_busy_rot);
+	init_waitqueue_head(&dev->wait_busy_gdma);
+
+
+	/* IMG Mmio */
+	IMGMmioV = (char *)IO_ADDRESS(IMGMmio);
+	/* ROT Mmio */
+	ROTMmioV = (char *)IO_ADDRESS(ROTMmio);
+	/* DMA Mmio */
+	GDMAMmioV = (char *)IO_ADDRESS(GDMAMmio);
+
+#if defined(CONFIG_PM) || defined(CONFIG_DPM)
+	dev_set_drvdata(&mp200_ipu_device.dev, (void *)dev);
+	if (platform_device_register(&mp200_ipu_device) < 0) {
+		printk(KERN_ERR " @ipu: could not register platform_device\n");
+		goto fail_platform_device;
+	}
+	if (platform_driver_register(&mp200_ipu_driver) < 0) {
+		printk(KERN_ERR " @ipu: could not register platform_driver\n");
+		goto fail_platform_driver;
+	}
+#endif /* CONFIG_PM || CONFIG_DPM */
+
+	/*------------------------------*/
+	/* Create kernel threads        */
+	/*------------------------------*/
+	task_img = kthread_create(mp200_ipu_reschedule_img, dev, "mp200_img");
+	if (IS_ERR(task_img)) {
+		printk(KERN_ERR "Could not create the mp200_img thread.\n");
+		ret = -1;
+		goto fail_init;
+	}
+	task_rot = kthread_create(mp200_ipu_reschedule_rot, dev, "mp200_rot");
+	if (IS_ERR(task_rot)) {
+		printk(KERN_ERR "Could not create the mp200_rot thread.\n");
+		ret = -1;
+		goto fail_init;
+	}
+	task_gdma = kthread_create(mp200_ipu_reschedule_gdma, dev,
+		"mp200_gdma");
+	if (IS_ERR(task_gdma)) {
+		printk(KERN_ERR "Could not create the mp200_gdma thread.\n");
+		ret = -1;
+		goto fail_init;
+	}
+
+
+	/* initialize IPU register settings */
+	ret = mp200_ipu_hw_init();
+	if (ret < 0)
+		goto fail_init;
+
+	/* initialize IPU Queue settings */
+	ret = mp200_ipu_init_queue();
+	if (ret < 0)
+		goto fail_init;
+
+	/* initialize spinlock */
+	spin_lock_init(&ipu_lock);
+
+	IPU_REQ_leftcall.callback = NULL;	/* no suspended request */
+
+	/*------------------------------*/
+	/* kernel thread Start          */
+	/*------------------------------*/
+
+	wake_up_process(task_img);
+	wake_up_process(task_rot);
+	wake_up_process(task_gdma);
+
+/*----------------------------*/
+/* Create a kernel thread End */
+/*----------------------------*/
+
+	goto success;
+
+
+fail_init:
+	if (!IS_ERR(task_img)) {
+		thread_img_flag = 0;		/* 0 is thread loop break */
+		wake_up_process(task_img);	/* process finish */
+	}
+	if (!IS_ERR(task_rot)) {
+		thread_rot_flag = 0;		/* 0 is thread loop break */
+		wake_up_process(task_rot);	/* process finish */
+	}
+	if (!IS_ERR(task_gdma)) {
+		thread_gdma_flag = 0;		/* 0 is thread loop break */
+		wake_up_process(task_gdma);	/* process finish */
+	}
+
+#if defined(CONFIG_PM) || defined(CONFIG_DPM)
+	platform_driver_unregister(&mp200_ipu_driver);
+fail_platform_driver:
+	platform_device_unregister(&mp200_ipu_device);
+fail_platform_device:
+#endif /* CONFIG_PM || CONFIG_DPM */
+	kfree(mp200_ipu_devices);
+
+fail_malloc:
+success:
+
+	return ret;
+}
+
+
+/* ------------------------------------------- */
+/*   Private functions (initialize)            */
+/* ------------------------------------------- */
+/******************************************************************************
+* MODULE   : mp200_ipu_hw_init
+* FUNCTION : initialize IPU register settings (only essential parameters)
+* RETURN   :  0 : success
+*          : -1 : fail (IPU is running)
+* NOTE     : none
+* CREATE   : 2006/10/02 M.Sasaki
+* UPDATE   :
+******************************************************************************/
+static int mp200_ipu_hw_init(void)
+{
+	unsigned long ulRegVal32_IMG, ulRegVal32_ROT, ulRegVal32_DMA;
+
+	/* Unreset IMG */
+	mp200_pmu_clkctrl_off(MP200_CLKCTRL_IPUIMG1);
+	mp200_pmu_clkctrl_off(MP200_CLKCTRL_IPUIMG2);
+	mp200_pmu_clkctrl_off(MP200_CLKCTRL_IPUIMGPCLK);
+	mp200_pmu_open_clockgate(MP200_CLOCKGATE_IMG_1_CLK);
+	mp200_pmu_open_clockgate(MP200_CLOCKGATE_IMG_2_CLK);
+	mp200_pmu_open_clockgate(MP200_CLOCKGATE_IMG_PCLK);
+	mp200_pmu_unreset_device(MP200_RESETDEVICE_IPUIMG);
+	mp200_pmu_clkctrl_on(MP200_CLKCTRL_IPUIMG1);
+	mp200_pmu_clkctrl_on(MP200_CLKCTRL_IPUIMG2);
+	mp200_pmu_clkctrl_on(MP200_CLKCTRL_IPUIMGPCLK);
+
+	/* Unreset ROT */
+	mp200_pmu_clkctrl_off(MP200_CLKCTRL_IPUROT);
+	mp200_pmu_clkctrl_off(MP200_CLKCTRL_IPUROTPCLK);
+	mp200_pmu_open_clockgate(MP200_CLOCKGATE_ROT_CLK);
+	mp200_pmu_open_clockgate(MP200_CLOCKGATE_ROT_PCLK);
+	mp200_pmu_unreset_device(MP200_RESETDEVICE_IPUROT);
+	mp200_pmu_clkctrl_on(MP200_CLKCTRL_IPUROT);
+	mp200_pmu_clkctrl_on(MP200_CLKCTRL_IPUROTPCLK);
+
+	/* Unreset DMA */
+	mp200_pmu_clkctrl_off(MP200_CLKCTRL_IPUDMA);
+	mp200_pmu_clkctrl_off(MP200_CLKCTRL_IPUDMACLK);
+	mp200_pmu_open_clockgate(MP200_CLOCKGATE_IPUDMA_CLK);
+	mp200_pmu_open_clockgate(MP200_CLOCKGATE_IPUDMA_PCLK);
+	mp200_pmu_unreset_device(MP200_RESETDEVICE_IPUDMA);
+	mp200_pmu_clkctrl_on(MP200_CLKCTRL_IPUDMA);
+	mp200_pmu_clkctrl_on(MP200_CLKCTRL_IPUDMACLK);
+
+	/* Unreset IPUAHB */
+	mp200_pmu_clkctrl_off(MP200_CLKCTRL_IPUAHB);
+	mp200_pmu_open_clockgate(MP200_CLOCKGATE_IPUAHB_CLK);
+	mp200_pmu_unreset_device(MP200_RESETDEVICE_IPUAHB);
+	mp200_pmu_clkctrl_on(MP200_CLKCTRL_IPUAHB);
+
+	/* check img working */
+	ulRegVal32_IMG = readl(IMGMmioV + IMG_ACK);
+	if ((ulRegVal32_IMG & IMG_ACK_BIT) == IMG_ACK_BIT) {
+		printk(KERN_ERR " @ipu: img working now... cannot use img\n");
+		return -1;
+	}
+	/* check rot working */
+	ulRegVal32_ROT = readl(ROTMmioV + ROT_STATUS);
+	if ((ulRegVal32_ROT & ROT_STATUS_BIT) == ROT_STATUS_BIT) {
+		printk(KERN_ERR " @ipu: rot working now... cannot use rot\n");
+		return -1;
+	}
+	/* check dma working */
+	ulRegVal32_DMA = readl(GDMAMmioV + DMA_ACK);
+	if ((ulRegVal32_DMA & DMA_STAT_BIT) == DMA_ACK_BIT) {
+		printk(KERN_ERR " @ipu: dma working now... cannot use dma\n");
+		return -1;
+	}
+
+	mp200_ipu_hw_int_disable(IPU_HW_FUNC_ALL);
+
+	return 0;
+}
+
+
+/*******************************************************************************
+* MODULE   : mp200_ipu_hw_int_enable
+* FUNCTION : permit IPU interrupts
+* RETURN   : none
+* NOTE     : none
+* CREATE   : 2006/10/02 M.Sasaki
+* UPDATE   :
+*******************************************************************************/
+static void mp200_ipu_hw_int_enable(int ipu_hw_func)
+{
+	/* Interuppt Enable Set */
+	switch (ipu_hw_func) {
+	case IPU_HW_FUNC_ALL:
+	case IPU_HW_FUNC_IMG:
+		writel(IMG_ENSETSTAT_BIT | IMG_ENSETERROR_BIT
+			| IMG_ENSETSTOP_BIT, IMGMmioV + IMG_ENSET);
+		if (ipu_hw_func == IPU_HW_FUNC_IMG)
+			break;
+		/* FALL THROUGH */
+	case IPU_HW_FUNC_ROT:
+		writel(ROT_DMASTOPEN_BIT  | ROT_DMAERREN_BIT
+			| ROT_ROTENDEN_BIT,  ROTMmioV + ROT_INTENSET);
+		if (ipu_hw_func == IPU_HW_FUNC_ROT)
+			break;
+		/* FALL THROUGH */
+	case IPU_HW_FUNC_GDMA:
+		writel(DMA_ENSETAHBERR_BIT | DMA_ENSETSTAT_BIT,
+			GDMAMmioV + DMA_ENSET);
+		break;
+	}
+}
+
+
+/*******************************************************************************
+* MODULE   : mp200_ipu_hw_int_disable
+* FUNCTION : prohibit IPU interrupts
+* RETURN   : none
+* NOTE     : none
+* CREATE   : 2006/10/02 M.Sasaki
+* UPDATE   : 2007/02/26 Y.Utsuhara
+*******************************************************************************/
+static void mp200_ipu_hw_int_disable(int ipu_hw_func)
+{
+	/* Interuppt Enable Clear and Interuppt Status Clear */
+	switch (ipu_hw_func) {
+	case IPU_HW_FUNC_ALL:
+	case IPU_HW_FUNC_IMG:
+		writel(IMG_ENCLRSTAT_BIT | IMG_ENCLRERROR_BIT
+			| IMG_ENCLRSTOP_BIT, IMGMmioV + IMG_ENCLR);
+		writel(IMG_FFCLRSTAT_BIT | IMG_FFCLRERROR_BIT
+			| IMG_FFCLRSTOP_BIT, IMGMmioV + IMG_FFCLR);
+		if (ipu_hw_func == IPU_HW_FUNC_IMG)
+			break;
+		/* FALL THROUGH */
+	case IPU_HW_FUNC_ROT:
+		writel(ROT_DMASTOPMASK_BIT | ROT_DMAERRMASK_BIT
+			| ROT_ROTENDMASK_BIT, ROTMmioV + ROT_INTENCLR);
+		writel(ROT_DMASTOPCLR_BIT  | ROT_DMAERRCLR_BIT
+			| ROT_ROTENDCLR_BIT,  ROTMmioV + ROT_INTFFCLR);
+		if (ipu_hw_func == IPU_HW_FUNC_ROT)
+			break;
+		/* FALL THROUGH */
+	case IPU_HW_FUNC_GDMA:
+		writel(DMA_ENCLRAHBERR_BIT | DMA_ENCLRSTAT_BIT,
+			GDMAMmioV + DMA_ENCLR);
+		writel(DMA_FFCLRAHBERR_BIT | DMA_FFCLRSTAT_BIT,
+			GDMAMmioV + DMA_FFCLR);
+		break;
+	}
+}
+
+
+#ifdef CONFIG_MP200_IPU_DUAL
+/*******************************************************************************
+* MODULE   : mp200_ipu_hw_int_ffclr
+* FUNCTION : prohibit IPU interrupts
+* RETURN   : none
+* NOTE     : none
+* CREATE   : 2007/05/24 M.Haguro
+* UPDATE   :
+*******************************************************************************/
+static void mp200_ipu_hw_int_ffclr(int ipu_hw_func)
+{
+	/* Interuppt Enable Clear and Interuppt Status Clear */
+	switch (ipu_hw_func) {
+	case IPU_HW_FUNC_ALL:
+	case IPU_HW_FUNC_IMG:
+		writel(IMG_FFCLRSTAT_BIT | IMG_FFCLRERROR_BIT
+			| IMG_FFCLRSTOP_BIT, IMGMmioV + IMG_FFCLR);
+		if (ipu_hw_func == IPU_HW_FUNC_IMG)
+			break;
+		/* FALL THROUGH */
+	case IPU_HW_FUNC_ROT:
+		writel(ROT_DMASTOPCLR_BIT | ROT_DMAERRCLR_BIT
+			| ROT_ROTENDCLR_BIT,  ROTMmioV + ROT_INTFFCLR);
+		if (ipu_hw_func == IPU_HW_FUNC_ROT)
+			break;
+		/* FALL THROUGH */
+	case IPU_HW_FUNC_GDMA:
+		writel(DMA_FFCLRAHBERR_BIT | DMA_FFCLRSTAT_BIT,
+			GDMAMmioV + DMA_FFCLR);
+		break;
+	}
+}
+#endif
+
+
+/* ------------------------------------------- */
+/*   Private functions (Queue operation)       */
+/* ------------------------------------------- */
+/*****************************************************************************
+* MODULE   : mp200_ipu_regist_queue
+* FUNCTION : regist the IPU request in target queue
+* RETURN   : IPU_REQ_REGISTERED(0) : the request is registered
+*          : IPU_REQ_BUSY(-1)	  : fail to registered request busy
+*          : IPU_REQ_PARAMERR(-2)  : fail to registered request Parameter error
+* NOTE     : none
+* CREATE   : 2006/10/02 M.Sasaki
+* UPDATE   :
+******************************************************************************/
+static int mp200_ipu_regist_queue(struct mp200_ipu_queue **pQueue,
+	struct mp200_ipu_req *p)
+{
+
+	struct mp200_ipu_req_regist *buf;
+	struct list_head			*list_queue = NULL;
+
+	int index;
+
+	for (index = 0; index < IPU_BUFS_MAX; index++) {
+		buf = (*pQueue)->bufs[index];
+		if (NULL == buf)
+			continue;
+
+		if (buf->ipu_req.status == IPU_REQ_STATUS_IDLE)
+			goto index_regist;
+
+	}
+	goto done;
+
+ index_regist:
+
+	/* copy of request */
+	for (index = 0 ; index < IPU_REG_INFO_MAX ; index++) {
+		buf->ipu_req.ipu_reg_info[index].reg =
+			p->ipu_reg_info[index].reg;
+		buf->ipu_req.ipu_reg_info[index].data =
+			p->ipu_reg_info[index].data;
+		if (buf->ipu_req.ipu_reg_info[index].reg ==
+			IPU_REG_INFO_END) {
+			break;
+		}
+	}
+	if (index <= 0 || index >= IPU_REG_INFO_MAX) {
+		mp200_ipu_release_buf(buf);
+		return IPU_REQ_PARAMERR;
+	}
+
+	(*pQueue)->sequence++;
+	if ((*pQueue)->sequence == 0)
+		(*pQueue)->sequence = 1;
+
+	p->sequence = (*pQueue)->sequence;
+	p->status = IPU_REQ_STATUS_REGISTERED;
+	buf->ipu_req.sequence = p->sequence;
+	buf->ipu_req.data	 = p->data;
+	buf->ipu_req.status   = p->status;
+	buf->ipu_req.callback = p->callback;
+	buf->ipu_req.ipu_hw_func = p->ipu_hw_func;
+
+	switch (buf->ipu_req.ipu_hw_func) {
+	case IPU_HW_FUNC_IMG:
+		list_queue = &(*pQueue)->ipu_queue_img;
+		break;
+	case IPU_HW_FUNC_ROT:
+		list_queue = &(*pQueue)->ipu_queue_rot;
+		break;
+	case IPU_HW_FUNC_GDMA:
+		list_queue = &(*pQueue)->ipu_queue_gdma;
+		break;
+	}
+	list_add_tail(&buf->ipu_req_regist, list_queue);
+
+	return IPU_REQ_REGISTERED;
+
+done:
+
+	return IPU_REQ_BUSY;
+}
+
+
+/*****************************************************************************
+* MODULE   : mp200_ipu_remove_queue
+* FUNCTION : remove the IPU requeest from target queue
+* RETURN   : none
+* NOTE     : none
+* CREATE   : 2006/10/02 M.Sasaki
+* UPDATE   :
+******************************************************************************/
+static void mp200_ipu_remove_queue(unsigned long sequence, int ipu_hw_func)
+{
+	struct mp200_ipu_req_regist *p;
+
+	p = mp200_ipu_search_queue(sequence, ipu_hw_func);
+	if (p == NULL)
+		return;
+
+	list_del(&p->ipu_req_regist);
+}
+
+
+/*****************************************************************************
+* MODULE   : mp200_ipu_release_buf
+* FUNCTION : release the IPU requeest buffer
+* RETURN   : none
+* NOTE     : none
+* CREATE   : 2006/12/01 M.Sasaki
+* UPDATE   :
+******************************************************************************/
+static void mp200_ipu_release_buf(struct mp200_ipu_req_regist *p)
+{
+	if (p == NULL)
+		return;
+
+	p->ipu_req.status = IPU_REQ_STATUS_IDLE;
+	/* Initialization of mp200_ipu_reg_info */
+	memset(p->ipu_req.ipu_reg_info, 0,
+		SIZE_MP200_IPU_REG_INFO * IPU_REG_INFO_MAX);
+}
+
+
+/*****************************************************************************
+* MODULE   : mp200_ipu_search_queue
+* FUNCTION : search the IPU request from queues
+* RETURN   : NULL    : target request does not exist
+*          : pointer : pointer to the top of queue containing target request
+* NOTE     : none
+* CREATE   : 2006/10/02 M.Sasaki
+* UPDATE   :
+******************************************************************************/
+static struct mp200_ipu_req_regist *mp200_ipu_search_queue(
+	unsigned long sequence, int ipu_hw_func)
+{
+	struct mp200_ipu_queue *pQueue = mp200_ipu_que;
+	struct mp200_ipu_req_regist *ret = NULL;
+
+	switch (ipu_hw_func) {
+	case IPU_HW_FUNC_IMG:
+		ret = mp200_ipu_search_queue_func(sequence,
+			&pQueue->ipu_queue_img);
+		break;
+	case IPU_HW_FUNC_ROT:
+		ret = mp200_ipu_search_queue_func(sequence,
+			&pQueue->ipu_queue_rot);
+		break;
+	case IPU_HW_FUNC_GDMA:
+		ret = mp200_ipu_search_queue_func(sequence,
+			&pQueue->ipu_queue_gdma);
+		break;
+	case IPU_HW_FUNC_ALL:
+		ret = mp200_ipu_search_queue_func(sequence,
+			&pQueue->ipu_queue_img);
+		if (ret == NULL) {
+			ret = mp200_ipu_search_queue_func(sequence,
+				&pQueue->ipu_queue_rot);
+			if (ret == NULL) {
+				ret = mp200_ipu_search_queue_func(sequence,
+					&pQueue->ipu_queue_gdma);
+			}
+		}
+		break;
+	}
+	return ret;
+}
+
+
+/*****************************************************************************
+* MODULE   : mp200_ipu_search_queue_func
+* FUNCTION : search the IPU request from queues(sub)
+* RETURN   : NULL    : target request does not exist
+*          : pointer : pointer to the top of queue containing target request
+* NOTE     : none
+* CREATE   : 2006/10/02 M.Sasaki
+* UPDATE   :
+******************************************************************************/
+static struct mp200_ipu_req_regist *mp200_ipu_search_queue_func(
+	unsigned long sequence, struct list_head *list)
+{
+	struct mp200_ipu_req_regist *ret = NULL;
+	struct mp200_ipu_req_regist *buf;
+	struct list_head *list_queue;
+
+	list_for_each(list_queue, list) {
+		buf = list_entry(list_queue, struct mp200_ipu_req_regist,
+			ipu_req_regist);
+
+		if (buf->ipu_req.sequence == sequence) {
+			ret = buf;
+			break;
+		}
+	}
+	return ret;
+}
+
+
+#ifdef CONFIG_MP200_IPU_DUAL
+/* --------------------------------------------------- */
+/*   Private functions (Queue operation for "DUAL_FF") */
+/* --------------------------------------------------- */
+/*****************************************************************************
+* MODULE   : mp200_ipu_reqqueue_addtail
+* FUNCTION :
+* RETURN   : none
+* NOTE     : none
+* CREATE   : 2007/05/16 M.Haguro
+* UPDATE   :
+******************************************************************************/
+static void mp200_ipu_reqqueue_addtail(struct list_head *index,
+	struct mp200_ipu_task *request, struct mp200_ipu_req_regist *new_req)
+{
+	request->status  = REQ_USED;
+	request->request = new_req;
+	list_add_tail(&request->req_list, index);
+}
+
+
+/*****************************************************************************
+* MODULE   : mp200_ipu_reqqueue_del
+* FUNCTION :
+* RETURN   : none
+* NOTE     : none
+* CREATE   : 2007/05/16 M.Haguro
+* UPDATE   :
+******************************************************************************/
+static void mp200_ipu_reqqueue_del(struct mp200_ipu_task *request)
+{
+	list_del(&request->req_list);
+	request->request->callback_flag = FALSE;
+	request->request->request_flag  = FALSE;
+	request->request->hw_req_flag   = NO_HW_REQ; /* IPU running flag */
+	request->request				= NULL;
+	request->status				 = REQ_FREE;
+}
+
+
+/*****************************************************************************
+* MODULE   : mp200_ipu_reqqueue_del_next_sequence
+* FUNCTION :
+* RETURN   : none
+* NOTE     : none
+* CREATE   : 2007/06/07 M.Haguro
+* UPDATE   :
+******************************************************************************/
+static void mp200_ipu_reqqueue_del_next_sequence(
+	struct mp200_ipu_task *request, unsigned long sequence)
+{
+	if (mp200_ipu_reqqueue_search_index(request) == -1) {
+		struct mp200_ipu_task *p_tmp;
+		int index;
+		index = mp200_ipu_reqqueue_search_sequence(request, sequence);
+		if (index != -1) {
+			p_tmp = &request[((index+1) % INDEX_MAX)];
+			if (p_tmp->request) {
+				if (p_tmp->request->request_flag) {
+					p_tmp->request->ipu_req.status
+					   = IPU_REQ_STATUS_REGISTERED;
+					mp200_ipu_reqqueue_del(p_tmp);
+				}
+			}
+		}
+	}
+}
+
+
+#if defined(CONFIG_PM) || defined(CONFIG_DPM)
+/*****************************************************************************
+* MODULE   : mp200_ipu_reqqueue_search_empty
+* FUNCTION :
+* RETURN   : 1 : empty
+*          : 0 : not empty
+* NOTE     : none
+* CREATE   : 2007/05/16 M.Haguro
+* UPDATE   :
+******************************************************************************/
+static int mp200_ipu_reqqueue_search_empty(struct list_head *index)
+{
+	int ret;
+
+	ret = (list_empty(index) ? 1 : 0);
+	return ret;
+}
+#endif /* CONFIG_PM || CONFIG_DPM */
+
+
+/*****************************************************************************
+* MODULE   : mp200_ipu_reqqueue_search_index
+* FUNCTION :
+* RETURN   : i : free index no.
+*              : -1: error
+* NOTE     : none
+* CREATE   : 2007/05/16 M.Haguro
+* UPDATE   :
+******************************************************************************/
+static int mp200_ipu_reqqueue_search_index(struct mp200_ipu_task *request)
+{
+	int i;
+
+	for (i = 0; i < INDEX_MAX; i++) {
+		if (request[i].status == REQ_FREE)
+			return i;
+
+	}
+	return -1;
+}
+
+
+/*****************************************************************************
+* MODULE   : mp200_ipu_reqqueue_search_sequence
+* FUNCTION :
+* RETURN   : i : index no.
+*          : -1: error
+* NOTE     : none
+* CREATE   : 2007/05/24 M.Haguro
+* UPDATE   :
+******************************************************************************/
+static int mp200_ipu_reqqueue_search_sequence(struct mp200_ipu_task *request,
+	unsigned long sequence)
+{
+	int i;
+
+	for (i = 0; i < INDEX_MAX; i++) {
+		if (request[i].request->ipu_req.sequence == sequence) {
+			if (request[i].request->ipu_req.status
+				== IPU_REQ_STATUS_RUNNING
+			    || request[i].request->ipu_req.status
+				== IPU_REQ_STATUS_WAIT_CANCEL
+			    || request[i].request->ipu_req.status
+				== IPU_REQ_STATUS_CANCELLED)
+				return i;
+		}
+	}
+	return -1;
+}
+#endif
+
+
+/* ------------------------------------------- */
+/*   Private functions (request)               */
+/* ------------------------------------------- */
+/*****************************************************************************
+* MODULE   : mp200_ipu_request
+* FUNCTION : set IPU registers & run IPU
+* RETURN   :  0 : success
+*          : -1 : fail
+* NOTE     : none
+* CREATE   : 2006/10/02 M.Sasaki
+* UPDATE   :
+******************************************************************************/
+static int mp200_ipu_request(struct mp200_ipu_req_regist *p)
+{
+	int write_req = 0;	/* flag for writing IMG_REQ */
+
+	struct mp200_ipu_reg_info *ipu_reg_info;
+	unsigned long ulRegVal32;
+	unsigned long IPU_REQ = IMG_REQ, IPU_REQ_BIT = IMG_REQ_BIT;
+	char *IPUMmioV = IMGMmioV;
+	int  INT_IPU = INT_IMG;
+	int  reg_cnt = 0;
+	int  ret = 0;
+#ifdef CONFIG_MP200_IPU_DUAL
+	unsigned long  flags;
+
+	spin_lock_irqsave(&ipu_lock, flags);	  /* disable interrupts */
+	p->request_flag = TRUE;
+#endif
+
+	/* initialize register */
+	switch (p->ipu_req.ipu_hw_func) {
+	case IPU_HW_FUNC_IMG:
+	default:
+#ifdef CONFIG_MP200_IPU_DUAL
+		/* check img working */
+		ulRegVal32 = readl(IMGMmioV + IMG_STATUS);
+		if ((ulRegVal32 & IMG_DFF_RSV_BIT) == IMG_DFF_RSV_BIT) {
+			printk(KERN_ERR " @ipu: IMG WORKING NOW\n");
+			ret = -2;
+#else
+		/* check img working */
+		ulRegVal32 = readl(IMGMmioV + IMG_ACK);
+		if ((ulRegVal32 & IMG_ACK_BIT) == IMG_ACK_BIT) {
+			printk(KERN_ERR " @ipu: IMG WORKING NOW\n");
+			ret = -1;
+#endif
+			goto error_ret;
+		}
+		/* initialize img register */
+		writel(IMG_MODE_RESET,		IMGMmioV + IMG_MODE);
+		writel(IMG_HSTEP_RESET,	   IMGMmioV + IMG_HSTEP);
+		writel(IMG_VSTEP_RESET,	   IMGMmioV + IMG_VSTEP);
+		writel(IMG_HFOLD_RESET,	   IMGMmioV + IMG_HFOLD);
+		writel(IMG_VFOLD_RESET,	   IMGMmioV + IMG_VFOLD);
+		writel(IMG_INDATABYTE_RESET,  IMGMmioV + IMG_INDATABYTE);
+		writel(IMG_OUTDATABYTE_RESET, IMGMmioV + IMG_OUTDATABYTE);
+#ifdef CONFIG_MP200_IPU_DUAL
+		writel(IMG_REG_EN_BIT,	IMGMmioV + IMG_DUAL_FF);
+#else
+		writel(IMG_DUAL_FF_RESET,	 IMGMmioV + IMG_DUAL_FF);
+#endif
+#if _IPU_COLCONV
+		writel(IMG_RGBYUV_CONF_RESET, IMGMmioV + IMG_RGBYUV_CONF);
+		writel(IMG_RGBYUV00_RESET,	IMGMmioV + IMG_RGBYUV00);
+		writel(IMG_RGBYUV01_RESET,	IMGMmioV + IMG_RGBYUV01);
+		writel(IMG_RGBYUV02_RESET,	IMGMmioV + IMG_RGBYUV02);
+		writel(IMG_RGBYUV10_RESET,	IMGMmioV + IMG_RGBYUV10);
+		writel(IMG_RGBYUV11_RESET,	IMGMmioV + IMG_RGBYUV11);
+		writel(IMG_RGBYUV12_RESET,	IMGMmioV + IMG_RGBYUV12);
+		writel(IMG_RGBYUV20_RESET,	IMGMmioV + IMG_RGBYUV20);
+		writel(IMG_RGBYUV21_RESET,	IMGMmioV + IMG_RGBYUV21);
+		writel(IMG_RGBYUV22_RESET,	IMGMmioV + IMG_RGBYUV22);
+		writel(IMG_YUVRGB_CONF_RESET, IMGMmioV + IMG_YUVRGB_CONF);
+		writel(IMG_YUVRGB00_RESET,	IMGMmioV + IMG_YUVRGB00);
+		writel(IMG_YUVRGB01_RESET,	IMGMmioV + IMG_YUVRGB01);
+		writel(IMG_YUVRGB02_RESET,	IMGMmioV + IMG_YUVRGB02);
+		writel(IMG_YUVRGB10_RESET,	IMGMmioV + IMG_YUVRGB10);
+		writel(IMG_YUVRGB11_RESET,	IMGMmioV + IMG_YUVRGB11);
+		writel(IMG_YUVRGB12_RESET,	IMGMmioV + IMG_YUVRGB12);
+		writel(IMG_YUVRGB20_RESET,	IMGMmioV + IMG_YUVRGB20);
+		writel(IMG_YUVRGB21_RESET,	IMGMmioV + IMG_YUVRGB21);
+		writel(IMG_YUVRGB22_RESET,	IMGMmioV + IMG_YUVRGB22);
+#endif
+		/* IMG Variable set */
+		IPU_REQ	 = IMG_REQ;
+		IPU_REQ_BIT = IMG_REQ_BIT;
+		IPUMmioV	= IMGMmioV;
+		INT_IPU	 = INT_IMG;
+		break;
+	case IPU_HW_FUNC_ROT:
+#ifdef CONFIG_MP200_IPU_DUAL
+		/* check rot working */
+		ulRegVal32 = readl(ROTMmioV + ROT_INTSTATUS);
+		if ((ulRegVal32 & ROT_DFF_RSV_BIT) == ROT_DFF_RSV_BIT) {
+			printk(KERN_ERR " @ipu: ROT WORKING NOW\n");
+			ret = -2;
+#else
+		/* check rot working */
+		ulRegVal32 = readl(ROTMmioV + ROT_STATUS);
+		if ((ulRegVal32 & ROT_STATUS_BIT) == ROT_STATUS_BIT) {
+			printk(KERN_ERR " @ipu: ROT WORKING NOW\n");
+			ret = -1;
+#endif
+			goto error_ret;
+		}
+		/* initialize rot register */
+		writel(ROT_MODE_RESET,	 ROTMmioV + ROT_MODE);
+		writel(ROT_SRCBYTE_RESET,  ROTMmioV + ROT_SRCBYTE);
+		writel(ROT_DSTBYTE_RESET,  ROTMmioV + ROT_DSTBYTE);
+#ifdef CONFIG_MP200_IPU_DUAL
+		writel(ROT_REG_EN_BIT,	 ROTMmioV + ROT_DUAL_FF);
+#else
+		writel(ROT_DUAL_FF_RESET,  ROTMmioV + ROT_DUAL_FF);
+#endif
+		/* ROT Variable set */
+		IPU_REQ	 = ROT_REQ;
+		IPU_REQ_BIT = ROT_REQ_BIT;
+		IPUMmioV	= ROTMmioV;
+		INT_IPU	 = INT_ROT;
+		break;
+	case IPU_HW_FUNC_GDMA:
+#ifdef CONFIG_MP200_IPU_DUAL
+		/* check gdma working */
+		ulRegVal32 = readl(GDMAMmioV + DMA_STATUS);
+		if ((ulRegVal32 & DMA_DFF_RSV_BIT) == DMA_DFF_RSV_BIT) {
+			printk(KERN_ERR " @ipu: GDMA WORKING NOW\n");
+			ret = -2;
+#else
+		/* check gdma working */
+		ulRegVal32 = readl(GDMAMmioV + DMA_ACK);
+		if ((ulRegVal32 & DMA_ACK_BIT) == DMA_ACK_BIT) {
+			printk(KERN_ERR " @ipu: GDMA WORKING NOW\n");
+			ret = -1;
+#endif
+			goto error_ret;
+		}
+		/* initialize gdma register */
+		writel(DMA_MODE_RESET,	  GDMAMmioV + DMA_MODE);
+		writel(DMA_SRCBYTE_1_RESET, GDMAMmioV + DMA_SRCBYTE_1);
+		writel(DMA_SRCBYTE_2_RESET, GDMAMmioV + DMA_SRCBYTE_2);
+		writel(DMA_DSTBYTE_RESET,   GDMAMmioV + DMA_DSTBYTE);
+#ifdef CONFIG_MP200_IPU_DUAL
+		writel(DMA_REG_EN_BIT,	  GDMAMmioV + DMA_DUAL_FF);
+#else
+		writel(DMA_DUAL_FF_RESET,   GDMAMmioV + DMA_DUAL_FF);
+#endif
+		writel(DMA_AUTO_SCAN_RESET, GDMAMmioV + DMA_AUTO_SCAN);
+		/* GDMA Variable set */
+		IPU_REQ	 = DMA_REQ;
+		IPU_REQ_BIT = DMA_REQ_BIT;
+		IPUMmioV	= GDMAMmioV;
+		INT_IPU	 = INT_IPU_DMA;
+		break;
+	}
+
+	ipu_reg_info = p->ipu_req.ipu_reg_info;
+
+	/* loop of register settings */
+	/* read IPU register setting information structure,
+	   and set IPU registers */
+	for (reg_cnt = 0 ; reg_cnt < IPU_REG_INFO_MAX ;
+			reg_cnt++, ipu_reg_info++) {
+		if (ipu_reg_info->reg == IPU_REG_INFO_END) {
+			/* end of IPU register setting information structure */
+#ifdef CONFIG_MP200_IPU_DUAL
+			/* enable interrupts */
+			spin_unlock_irqrestore(&ipu_lock, flags);
+			mp200_ipu_request_sub(p, IPU_CALLBACK_SET_PARAM);
+			/* disable interrupts */
+			spin_lock_irqsave(&ipu_lock, flags);
+#else
+			mp200_ipu_request_sub(p, IPU_CALLBACK_SET_PARAM);
+#endif
+			Call_StatusCtrlFunc_OFF();
+
+			/* start the next request */
+			mp200_ipu_request_wakeup(p->ipu_req.ipu_hw_func);
+			break;
+		}
+
+		/* skip accessing registers which are concerned
+		   with interrupt, or read-only, or out of scope */
+		switch (p->ipu_req.ipu_hw_func) {
+		case IPU_HW_FUNC_IMG:
+			if ((ipu_reg_info->reg >= IMG_ACK
+				   && ipu_reg_info->reg <= IMG_FFCLR)
+				 || (ipu_reg_info->reg >  IMG_DSTSIZE
+				   && ipu_reg_info->reg <  IMG_SRCYRGBADR_B)
+				 || (ipu_reg_info->reg >  IMG_DSTYRGBADR
+				   && ipu_reg_info->reg <  IMG_SRCUVADR_B)
+				 || (ipu_reg_info->reg >  IMG_DSTUVADR
+				   && ipu_reg_info->reg <  IMG_SRCHSIZE_B)
+				 || (ipu_reg_info->reg >  IMG_VFOLD
+				   && ipu_reg_info->reg <  IMG_PEL_ENDIAN)
+				 || (ipu_reg_info->reg >  IMG_PEL_ENDIAN
+				   && ipu_reg_info->reg <  IMG_RGBYUV_CONF)
+				 || (ipu_reg_info->reg >= IMG_DUAL_FF
+				   && ipu_reg_info->reg < IMG_INDATABYTE_B_CMP)
+				 || (ipu_reg_info->reg >  IMG_B_BRITNESS)) {
+				continue;
+			}
+			break;
+
+		case IPU_HW_FUNC_ROT:
+			if ((ipu_reg_info->reg >= ROT_STATUS &&
+			     ipu_reg_info->reg <  ROT_SRCSIZE) ||
+			    (ipu_reg_info->reg >  ROT_DSTSIZE &&
+			     ipu_reg_info->reg <  ROT_SRCYADR_A) ||
+			    (ipu_reg_info->reg >  ROT_SRCYADR_C &&
+			     ipu_reg_info->reg <  ROT_DSTYADR_A) ||
+			    (ipu_reg_info->reg >  ROT_DSTYADR_C &&
+			     ipu_reg_info->reg <  ROT_SRCUVADR_A) ||
+			    (ipu_reg_info->reg >  ROT_SRCUVADR_C &&
+			     ipu_reg_info->reg <  ROT_DSTUVADR_A) ||
+			    (ipu_reg_info->reg >  ROT_DSTUVADR_C &&
+			     ipu_reg_info->reg <  ROT_SRCHSIZE) ||
+			    (ipu_reg_info->reg >  ROT_SRCHSIZE &&
+			     ipu_reg_info->reg <  ROT_SRCVSIZE) ||
+			    (ipu_reg_info->reg >  ROT_SRCVSIZE &&
+			     ipu_reg_info->reg <  ROT_FORMAT) ||
+			    (ipu_reg_info->reg == ROT_DUAL_FF) ||
+			    (ipu_reg_info->reg >  ROT_DSTBYTE_CMP)) {
+				continue;
+			}
+			break;
+
+		case IPU_HW_FUNC_GDMA:
+			if ((ipu_reg_info->reg >= DMA_ACK &&
+			     ipu_reg_info->reg <= DMA_FFCLR) ||
+			    (ipu_reg_info->reg >  DMA_DSTSIZE &&
+			     ipu_reg_info->reg <  DMA_SRCYRGBADR_1) ||
+			    (ipu_reg_info->reg >  DMA_DSTYRGBADR &&
+			     ipu_reg_info->reg <  DMA_SRCUVADR_1) ||
+			    (ipu_reg_info->reg >  DMA_DSTUVADR &&
+			     ipu_reg_info->reg <  DMA_SRCVADR_1) ||
+			    (ipu_reg_info->reg >  DMA_DSTVADR &&
+			     ipu_reg_info->reg <  DMA_HSIZE) ||
+			    (ipu_reg_info->reg >= DMA_DUAL_FF &&
+			     ipu_reg_info->reg <  DMA_SRCBYTE_1_CMP) ||
+			    (ipu_reg_info->reg >  DMA_DSTBYTE_CMP)) {
+				continue;
+			}
+			break;
+		}
+
+		if (ipu_reg_info->reg == IPU_REQ) {
+			/* setting IPU_REQ means end of IPU register setting
+			 * information structure
+			 */
+			if (ipu_reg_info->data != IPU_REQ_BIT) {
+				/* return error if IPU_REQ = 0 */
+#ifdef CONFIG_MP200_IPU_DUAL
+				/* enable interrupts */
+				spin_unlock_irqrestore(&ipu_lock, flags);
+				mp200_ipu_request_sub(p, IPU_CALLBACK_FAIL);
+				/* disable interrupts */
+				spin_lock_irqsave(&ipu_lock, flags);
+#else
+				mp200_ipu_request_sub(p, IPU_CALLBACK_FAIL);
+#endif
+				Call_StatusCtrlFunc_OFF();
+
+				switch (INT_IPU) {
+				case INT_IMG:
+					printk(KERN_INFO
+						" @ipu: request data error. "
+						"'IMG_REQ data 0x%08x'\n",
+						(unsigned int)
+						ipu_reg_info->data);
+					break;
+				case INT_ROT:
+					printk(KERN_INFO
+						" @ipu: request data error. "
+						"'ROT_REQ data 0x%08x'\n",
+						(unsigned int)
+						ipu_reg_info->data);
+					break;
+				case INT_IPU_DMA:
+					printk(KERN_INFO
+						" @ipu: request data error."
+						"'GDMA_REQ data 0x%08x'\n",
+						(unsigned int)
+						ipu_reg_info->data);
+					break;
+				}
+				ret = -1;
+				/* start the next request */
+				mp200_ipu_request_wakeup(
+					p->ipu_req.ipu_hw_func);
+				break;
+			} else {
+				switch (INT_IPU) {
+				case INT_IMG:
+					mp200_ipu_hw_int_enable(
+						IPU_HW_FUNC_IMG);
+					break;
+				case INT_ROT:
+					mp200_ipu_hw_int_enable(
+						IPU_HW_FUNC_ROT);
+					break;
+				case INT_IPU_DMA:
+					mp200_ipu_hw_int_enable(
+						IPU_HW_FUNC_GDMA);
+					break;
+				}
+				p->hw_req_flag = SET_HW_REQ; /* IPU running */
+				write_req = 1;
+			}
+		}
+
+
+#if _IPU_PERF == 1
+		if ((INT_IPU == INT_IMG
+			  && ipu_reg_info->reg == IMG_REQ
+			  && ipu_reg_info->data == IMG_REQ_BIT)
+			|| (INT_IPU == INT_ROT
+			  && ipu_reg_info->reg == ROT_REQ
+			  && ipu_reg_info->data == ROT_REQ_BIT)
+			|| (INT_IPU == INT_IPU_DMA
+			  && ipu_reg_info->reg == DMA_REQ
+			  && ipu_reg_info->data == DMA_REQ_BIT)) {
+			/* -- */
+			dbg_GetStartTime(1);
+		}
+#endif
+
+		writel(ipu_reg_info->data, IPUMmioV + ipu_reg_info->reg);
+		if (write_req)
+			break;
+
+	}
+
+	if (reg_cnt >= IPU_REG_INFO_MAX) {
+#ifdef CONFIG_MP200_IPU_DUAL
+		/* enable interrupts */
+		spin_unlock_irqrestore(&ipu_lock, flags);
+
+		mp200_ipu_request_sub(p, IPU_CALLBACK_FAIL);
+		/* disable interrupts */
+		spin_lock_irqsave(&ipu_lock, flags);
+#else
+		mp200_ipu_request_sub(p, IPU_CALLBACK_FAIL);
+#endif
+		Call_StatusCtrlFunc_OFF();
+		printk(KERN_INFO
+			" @ipu: request data error. 'over 230 request'\n");
+		ret = -1;
+		/* start the next request */
+		mp200_ipu_request_wakeup(p->ipu_req.ipu_hw_func);
+	}
+
+error_ret:
+#ifdef CONFIG_MP200_IPU_DUAL
+	spin_unlock_irqrestore(&ipu_lock, flags); /* enable interrupts */
+#endif
+	return ret;
+}
+
+
+/*****************************************************************************
+* MODULE   : mp200_ipu_request_sub
+* FUNCTION : finalize the IPU requeest buffer
+*            (mp200_ipu_request sub function)
+* RETURN   : none
+* NOTE     : none
+* CREATE   : 2006/12/14 M.Haguro
+* UPDATE   :
+******************************************************************************/
+static void mp200_ipu_request_sub(struct mp200_ipu_req_regist *p,
+	int callback_flag)
+{
+	struct mp200_ipu_req_leftcall illegal_leftcall;
+
+	/* callback */
+	illegal_leftcall.callback	= p->ipu_req.callback;
+	illegal_leftcall.sequence	= p->ipu_req.sequence;
+	illegal_leftcall.data		= p->ipu_req.data;
+	illegal_leftcall.ipu_hw_func = p->ipu_req.ipu_hw_func;
+	illegal_leftcall.flag		= callback_flag;
+
+	/* calback is required */
+	if (((illegal_leftcall.ipu_hw_func == IPU_HW_FUNC_IMG)
+			&& (p->callback_flag == TRUE))
+		 || ((illegal_leftcall.ipu_hw_func == IPU_HW_FUNC_ROT)
+			&& (p->callback_flag == TRUE))
+		 || ((illegal_leftcall.ipu_hw_func == IPU_HW_FUNC_GDMA)
+			&& (p->callback_flag == TRUE))) {
+		mp200_ipu_request_remove_sub(p);
+
+		/* request running flag initialize */
+		mp200_ipu_request_release_sub(illegal_leftcall.ipu_hw_func);
+
+		if (*(illegal_leftcall.callback)) {
+			if ((*(illegal_leftcall.callback)
+				    == (void *)mp200_ipu_callback_img)
+				 || (*(illegal_leftcall.callback)
+				    == (void *)mp200_ipu_callback_rot)
+				 || (*(illegal_leftcall.callback)
+				    == (void *)mp200_ipu_callback_gdma)) {
+				/* callback (can't start IPU process (Error)) */
+				(*(illegal_leftcall.callback))(
+					illegal_leftcall.data,
+					illegal_leftcall.flag);
+			} else {
+				/* callback (can't start IPU process (Error)) */
+				(*(illegal_leftcall.callback))(
+					illegal_leftcall.sequence,
+					illegal_leftcall.flag);
+			}
+		}
+	} else {
+		/* request running flag initialize */
+		mp200_ipu_request_release_sub(illegal_leftcall.ipu_hw_func);
+	}
+}
+
+
+/*****************************************************************************
+* MODULE   : mp200_ipu_request_remove_sub
+* FUNCTION : remove the IPU requeest from target queue
+*            (mp200_ipu_request sub function)
+* RETURN   : none
+*          :
+* NOTE     : none
+* CREATE   : 2006/10/02 M.Sasaki
+* UPDATE   :
+******************************************************************************/
+static void mp200_ipu_request_remove_sub(struct mp200_ipu_req_regist *p)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&ipu_lock, flags);	/* prohibit interrupts */
+
+	/* remove from queue */
+	p->ipu_req.status = IPU_REQ_STATUS_DONE;
+	mp200_ipu_remove_queue(p->ipu_req.sequence, p->ipu_req.ipu_hw_func);
+	/* permit interrupts */
+	spin_unlock_irqrestore(&ipu_lock, flags);
+}
+
+
+/*****************************************************************************
+* MODULE   : mp200_ipu_request_release_sub
+* FUNCTION : release the IPU requeest buffer
+*            (mp200_ipu_request sub function)
+* RETURN   : none
+*          :
+* NOTE     : none
+* CREATE   : 2006/12/14 M.Haguro
+* UPDATE   :
+******************************************************************************/
+static void mp200_ipu_request_release_sub(int ipu_hw_func)
+{
+#ifdef CONFIG_MP200_IPU_DUAL
+	struct mp200_ipu_task *p_tmp;
+#endif
+
+	switch (ipu_hw_func) {
+	case IPU_HW_FUNC_IMG:
+#ifdef CONFIG_MP200_IPU_DUAL
+		p_tmp = list_entry(index_img.next, struct mp200_ipu_task,
+			req_list);
+		mp200_ipu_release_buf(p_tmp->request);
+		mp200_ipu_reqqueue_del(p_tmp);
+#else
+		mp200_ipu_release_buf(request_img);
+		request_img = NULL;
+#endif
+		break;
+	case IPU_HW_FUNC_ROT:
+#ifdef CONFIG_MP200_IPU_DUAL
+		p_tmp = list_entry(index_rot.next, struct mp200_ipu_task,
+			req_list);
+		mp200_ipu_release_buf(p_tmp->request);
+		mp200_ipu_reqqueue_del(p_tmp);
+#else
+		mp200_ipu_release_buf(request_rot);
+		request_rot = NULL;
+#endif
+		break;
+	case IPU_HW_FUNC_GDMA:
+#ifdef CONFIG_MP200_IPU_DUAL
+		p_tmp = list_entry(index_gdma.next, struct mp200_ipu_task,
+			req_list);
+		mp200_ipu_release_buf(p_tmp->request);
+		mp200_ipu_reqqueue_del(p_tmp);
+#else
+		mp200_ipu_release_buf(request_gdma);
+		request_gdma = NULL;
+#endif
+		break;
+	}
+}
+
+
+/*****************************************************************************
+* MODULE   : mp200_ipu_request_wakeup
+* FUNCTION : start of processing instruction(thread wakeup)
+*            (mp200_ipu_request sub function)
+* RETURN   : none
+*          :
+* NOTE     : none
+* CREATE   : 2006/10/02 M.Sasaki
+* UPDATE   :
+******************************************************************************/
+static void mp200_ipu_request_wakeup(int ipu_hw_func)
+{
+	struct mp200_ipu_dev *dev = mp200_ipu_devices;
+
+	switch (ipu_hw_func) {
+	case IPU_HW_FUNC_IMG:
+		wake_up_interruptible(&dev->wait_busy_img);
+		break;
+	case IPU_HW_FUNC_ROT:
+		wake_up_interruptible(&dev->wait_busy_rot);
+		break;
+	case IPU_HW_FUNC_GDMA:
+		wake_up_interruptible(&dev->wait_busy_gdma);
+		break;
+	}
+}
+
+
+/* ------------------------------------------- */
+/*   Interrupt Management functions            */
+/* ------------------------------------------- */
+/*****************************************************************************
+* MODULE   : mp200_ipu_irq_handler
+* FUNCTION : IPU interrupt handler
+*            analyze the cause of IPU interrupt and execute each operations
+* RETURN   : none
+* NOTE     : none
+* CREATE   : 2006/10/03 M.Sasaki
+* UPDATE   :
+******************************************************************************/
+static irqreturn_t mp200_ipu_irq_handler(int irq, void *dev_id)
+{
+	unsigned long flags;
+
+	/* prohibit interrupts  */
+	spin_lock_irqsave(&ipu_lock, flags);
+	mp200_ipu_irq_handler_sub(irq, dev_id);
+	/* prohibit interrupts  */
+	spin_unlock_irqrestore(&ipu_lock, flags);
+	return IRQ_HANDLED;
+}
+
+
+/*****************************************************************************
+* MODULE   : mp200_ipu_irq_handler_sub
+* FUNCTION : IPU interrupt handler
+*            analyze the cause of IPU interrupt and execute each operations
+* RETURN   : none
+* NOTE     : none
+* CREATE   : 2007/07/06 M.Haguro
+* UPDATE   :
+******************************************************************************/
+static void mp200_ipu_irq_handler_sub(int irq, void *dev_id)
+{
+	struct mp200_ipu_dev *dev = mp200_ipu_devices;
+	int status_tmp;
+#ifdef CONFIG_MP200_IPU_DUAL
+	struct mp200_ipu_task *p_tmp;
+#endif
+	int	tmp_hw_func = 0;
+
+	switch (irq) {
+	case INT_IMG:
+		dbg_GetStopTime(1, "IMG");
+#ifdef CONFIG_MP200_IPU_DUAL
+		p_tmp = list_entry(index_img.next, struct mp200_ipu_task,
+			req_list);
+		status_tmp = mp200_ipu_req_finalize_img(p_tmp->request);
+#else
+		status_tmp = mp200_ipu_req_finalize_img(request_img);
+		tmp_hw_func = request_img->ipu_req.ipu_hw_func;
+#endif
+
+		break;
+	case INT_ROT:
+		dbg_GetStopTime(1, "ROT");
+#ifdef CONFIG_MP200_IPU_DUAL
+		p_tmp = list_entry(index_rot.next, struct mp200_ipu_task,
+			req_list);
+		status_tmp = mp200_ipu_req_finalize_rot(p_tmp->request);
+#else
+		status_tmp = mp200_ipu_req_finalize_rot(request_rot);
+		tmp_hw_func = request_rot->ipu_req.ipu_hw_func;
+#endif
+		break;
+	case INT_IPU_DMA:
+		dbg_GetStopTime(1, "GDMA");
+#ifdef CONFIG_MP200_IPU_DUAL
+		p_tmp = list_entry(index_gdma.next, struct mp200_ipu_task,
+			req_list);
+		status_tmp = mp200_ipu_req_finalize_gdma(p_tmp->request);
+#else
+		status_tmp = mp200_ipu_req_finalize_gdma(request_gdma);
+		tmp_hw_func = request_gdma->ipu_req.ipu_hw_func;
+#endif
+		break;
+	default:
+		status_tmp = 0;
+		return;
+	}
+
+#ifdef CONFIG_MP200_IPU_DUAL
+	tmp_hw_func = p_tmp->request->ipu_req.ipu_hw_func;
+#endif
+
+	/* request running flag initialize and release buffer */
+#ifdef CONFIG_MP200_IPU_DUAL
+	mp200_ipu_release_buf(p_tmp->request);
+	mp200_ipu_reqqueue_del(p_tmp);
+#else
+	switch (irq) {
+	case INT_IMG:
+		mp200_ipu_release_buf(request_img);
+		request_img = NULL;
+		break;
+	case INT_ROT:
+		mp200_ipu_release_buf(request_rot);
+		request_rot = NULL;
+		break;
+	case INT_IPU_DMA:
+		mp200_ipu_release_buf(request_gdma);
+		request_gdma = NULL;
+		break;
+	}
+#endif
+
+	if (IPU_REQ_leftcall.callback) {
+		/* with callback*/
+		dbg_GetStopTime(2, "callback");
+		if ((IPU_REQ_leftcall.callback
+				== (void *)mp200_ipu_callback_img)
+			  || (IPU_REQ_leftcall.callback
+				== (void *)mp200_ipu_callback_rot)
+			  || (IPU_REQ_leftcall.callback
+				== (void *)mp200_ipu_callback_gdma)) {
+			(IPU_REQ_leftcall.callback)(IPU_REQ_leftcall.data,
+				IPU_REQ_leftcall.flag);
+		} else {
+			(IPU_REQ_leftcall.callback)(IPU_REQ_leftcall.sequence,
+				IPU_REQ_leftcall.flag);
+		}
+
+		IPU_REQ_leftcall.callback = NULL;
+	}
+
+	Call_StatusCtrlFunc_OFF();
+
+	/* start to run request in IPU Request's queue */
+	switch (tmp_hw_func) {
+	case IPU_HW_FUNC_IMG:
+		wake_up_interruptible(&dev->wait_busy_rot);
+		wake_up_interruptible(&dev->wait_busy_gdma);
+		wake_up_interruptible(&dev->wait_busy_img);
+		break;
+	case IPU_HW_FUNC_ROT:
+		wake_up_interruptible(&dev->wait_busy_gdma);
+		wake_up_interruptible(&dev->wait_busy_img);
+		wake_up_interruptible(&dev->wait_busy_rot);
+		break;
+	case IPU_HW_FUNC_GDMA:
+		wake_up_interruptible(&dev->wait_busy_img);
+		wake_up_interruptible(&dev->wait_busy_rot);
+		wake_up_interruptible(&dev->wait_busy_gdma);
+		break;
+	}
+}
+
+
+/*****************************************************************************
+* MODULE   : mp200_ipu_req_finalize
+* FUNCTION : finalize the request without callback
+* RETURN   : none
+* NOTE     : none
+* CREATE   : 2006/10/03 M.Sasaki
+* UPDATE   :
+******************************************************************************/
+static void mp200_ipu_req_finalize(struct mp200_ipu_req_regist *p, int *ret)
+{
+	int flag_tmp = ret[0];
+	int status_tmp = ret[1];
+
+	if (p) {
+		char *cHW = "";
+		switch (p->ipu_req.ipu_hw_func) {
+		case IPU_HW_FUNC_IMG:
+			cHW = "IMG";
+			break;
+		case IPU_HW_FUNC_ROT:
+			cHW = "ROT";
+			break;
+		case IPU_HW_FUNC_GDMA:
+			cHW = "GDMA";
+			break;
+		}
+	}
+	if ((p != NULL)
+		&& (((p->ipu_req.ipu_hw_func == IPU_HW_FUNC_IMG)
+			&& (p->callback_flag == TRUE))
+		 || ((p->ipu_req.ipu_hw_func == IPU_HW_FUNC_ROT)
+			&& (p->callback_flag == TRUE))
+		 || ((p->ipu_req.ipu_hw_func == IPU_HW_FUNC_GDMA)
+			&& (p->callback_flag == TRUE)))) {
+		/* callback is required */
+		if ((flag_tmp == IPU_CALLBACK_SUCCESS) &&
+			  (p->ipu_req.status == IPU_REQ_STATUS_WAIT_CANCEL)) {
+			flag_tmp = IPU_CALLBACK_CANCEL;
+		}
+
+		/* update status */
+		p->ipu_req.status = status_tmp;
+
+		/* callback */
+		IPU_REQ_leftcall.callback	= p->ipu_req.callback;
+		IPU_REQ_leftcall.sequence	= p->ipu_req.sequence;
+		IPU_REQ_leftcall.data		= p->ipu_req.data;
+		IPU_REQ_leftcall.ipu_hw_func = p->ipu_req.ipu_hw_func;
+		IPU_REQ_leftcall.flag		= flag_tmp;
+
+		/* remove from queue */
+		mp200_ipu_remove_queue(p->ipu_req.sequence,
+			p->ipu_req.ipu_hw_func);
+	}
+	return;
+}
+
+
+/*****************************************************************************
+* MODULE   : mp200_ipu_req_finalize_img
+* FUNCTION : finalize the request without callback(IMG)
+* RETURN   : status of request
+*            success : IPU_REQ_STATUS_DONE
+*            fail    : IPU_REQ_STATUS_ERROR
+* NOTE     : none
+* CREATE   : 2006/10/03 M.Sasaki
+* UPDATE   :
+******************************************************************************/
+static int mp200_ipu_req_finalize_img(struct mp200_ipu_req_regist *p)
+{
+	int ret[2] = {IPU_CALLBACK_SUCCESS, IPU_REQ_STATUS_DONE};
+
+	/* check Interuppt Status */
+	unsigned long ulRegVal32 = readl(IMGMmioV + IMG_STATUS);
+
+	/* interrupt by ERROR of inner bus I/F and KERNEL */
+	/* interrupt by RETRY/SPLIT of inner bus I/F */
+	if ((ulRegVal32 & IMG_ERROR_BIT) == IMG_ERROR_BIT
+		|| (ulRegVal32 & IMG_FLT_BIT) == IMG_FLT_BIT
+		|| (ulRegVal32 & IMG_STOP_BIT) == IMG_STOP_BIT) {
+
+#ifdef CONFIG_MP200_IPU_DUAL
+		/* remove next request */
+		mp200_ipu_reqqueue_del_next_sequence(request_img,
+			p->ipu_req.sequence);
+#endif
+
+		/* Reset IMG */
+		mp200_pmu_clkctrl_off(MP200_CLKCTRL_IPUIMG1);
+		mp200_pmu_clkctrl_off(MP200_CLKCTRL_IPUIMG2);
+		mp200_pmu_clkctrl_off(MP200_CLKCTRL_IPUIMGPCLK);
+		mp200_pmu_reset_device(MP200_RESETDEVICE_IPUIMG);
+		mp200_pmu_close_clockgate(MP200_CLOCKGATE_IMG_1_CLK);
+		mp200_pmu_close_clockgate(MP200_CLOCKGATE_IMG_2_CLK);
+		mp200_pmu_close_clockgate(MP200_CLOCKGATE_IMG_PCLK);
+		/* Unreset IMG */
+		mp200_pmu_open_clockgate(MP200_CLOCKGATE_IMG_1_CLK);
+		mp200_pmu_open_clockgate(MP200_CLOCKGATE_IMG_2_CLK);
+		mp200_pmu_open_clockgate(MP200_CLOCKGATE_IMG_PCLK);
+		mp200_pmu_unreset_device(MP200_RESETDEVICE_IPUIMG);
+		mp200_pmu_clkctrl_on(MP200_CLKCTRL_IPUIMG1);
+		mp200_pmu_clkctrl_on(MP200_CLKCTRL_IPUIMG2);
+		mp200_pmu_clkctrl_on(MP200_CLKCTRL_IPUIMGPCLK);
+
+		/* Error Message */
+		if ((ulRegVal32 & IMG_ERROR_BIT) == IMG_ERROR_BIT)
+			printk(KERN_INFO " @ipu: IMG AHB ERROR. Reset IMG.\n");
+		else if ((ulRegVal32 & IMG_FLT_BIT) == IMG_FLT_BIT) {
+			printk(KERN_INFO
+				" @ipu: IMG KERNEL ACCESS_ERROR. Reset IMG.\n");
+		} else if ((ulRegVal32 & IMG_STOP_BIT) == IMG_STOP_BIT) {
+			printk(KERN_INFO
+				" @ipu: IMG AHB RETRY/SPLIT. Reset IMG.\n");
+		}
+		if ((ulRegVal32 & IMG_STOP_BIT) == IMG_STOP_BIT) {
+			/* flag of callback  */
+			ret[0] = IPU_CALLBACK_IPU_STOP;
+		} else {
+			/* flag of callback  */
+			ret[0] = IPU_CALLBACK_IPU_ERROR;
+		}
+		ret[1] = IPU_REQ_STATUS_ERROR;	  /* status of request */
+	} else if ((ulRegVal32 & IMG_STAT_BIT) == IMG_STAT_BIT) {
+		/* interrupt that IMG process is completed */
+#ifdef CONFIG_MP200_IPU_DUAL
+		/* Interuppt Enable Clear and Interuppt Status Clear */
+		mp200_ipu_hw_int_ffclr(IPU_HW_FUNC_IMG);
+#else
+		/* Interuppt Enable Clear and Interuppt Status Clear */
+		mp200_ipu_hw_int_disable(IPU_HW_FUNC_IMG);
+#endif
+		/* flag of callback  */
+		ret[0] = IPU_CALLBACK_SUCCESS;
+		/* status of request */
+		ret[1] = IPU_REQ_STATUS_DONE;
+	}
+	mp200_ipu_req_finalize(p, ret);
+
+	return ret[1];
+}
+
+
+/*****************************************************************************
+* MODULE   : mp200_ipu_req_finalize_rot
+* FUNCTION : finalize the request without callback(ROT)
+* RETURN   : status of request
+*              success : IPU_REQ_STATUS_DONE
+*              fail    : IPU_REQ_STATUS_ERROR
+* NOTE     : none
+* CREATE   : 2006/10/03 M.Sasaki
+* UPDATE   :
+******************************************************************************/
+static int mp200_ipu_req_finalize_rot(struct mp200_ipu_req_regist *p)
+{
+	int ret[2] = {IPU_CALLBACK_SUCCESS, IPU_REQ_STATUS_DONE};
+
+	/* check Interuppt Status */
+	unsigned long ulRegVal32 = readl(ROTMmioV + ROT_INTSTATUS);
+
+	if ((ulRegVal32 & ROT_DMAERR_BIT) == ROT_DMAERR_BIT
+		 || (ulRegVal32 & ROT_DMASTOP_BIT) == ROT_DMASTOP_BIT) {
+		/* interrupt by ERROR of inner bus I/F	   */
+		/* interrupt by RETRY/SPLIT of inner bus I/F */
+#ifdef CONFIG_MP200_IPU_DUAL
+		/* remove next request */
+		mp200_ipu_reqqueue_del_next_sequence(request_rot,
+			p->ipu_req.sequence);
+#endif
+
+		/* Reset ROT */
+		mp200_pmu_clkctrl_off(MP200_CLKCTRL_IPUROT);
+		mp200_pmu_clkctrl_off(MP200_CLKCTRL_IPUROTPCLK);
+		mp200_pmu_reset_device(MP200_RESETDEVICE_IPUROT);
+		mp200_pmu_close_clockgate(MP200_CLOCKGATE_ROT_CLK);
+		mp200_pmu_close_clockgate(MP200_CLOCKGATE_ROT_PCLK);
+		/* Unreset ROT */
+		mp200_pmu_open_clockgate(MP200_CLOCKGATE_ROT_CLK);
+		mp200_pmu_open_clockgate(MP200_CLOCKGATE_ROT_PCLK);
+		mp200_pmu_unreset_device(MP200_RESETDEVICE_IPUROT);
+		mp200_pmu_clkctrl_on(MP200_CLKCTRL_IPUROT);
+		mp200_pmu_clkctrl_on(MP200_CLKCTRL_IPUROTPCLK);
+
+		/* Error Message */
+		if ((ulRegVal32 & ROT_DMAERR_BIT) == ROT_DMAERR_BIT)
+			printk(KERN_INFO " @ipu: ROT AHB ERROR. Reset ROT.\n");
+		else if ((ulRegVal32 & ROT_DMASTOP_BIT) == ROT_DMASTOP_BIT)
+			printk(KERN_INFO
+				" @ipu: ROT AHB RETRY/SPLIT. Reset ROT.\n");
+
+		if ((ulRegVal32 & ROT_DMASTOP_BIT) == ROT_DMASTOP_BIT) {
+			/* flag of callback  */
+			ret[0] = IPU_CALLBACK_IPU_STOP;
+		} else {
+			/* flag of callback  */
+			ret[0] = IPU_CALLBACK_IPU_ERROR;
+		}
+		/* status of request */
+		ret[1] = IPU_REQ_STATUS_ERROR;
+	} else if ((ulRegVal32 & ROT_ROTEND_BIT) == ROT_ROTEND_BIT) {
+		/* interrupt that ROT process is completed */
+#ifdef CONFIG_MP200_IPU_DUAL
+		/* Interuppt Enable Clear and Interuppt Status Clear */
+		mp200_ipu_hw_int_ffclr(IPU_HW_FUNC_ROT);
+#else
+		/* Interuppt Enable Clear and Interuppt Status Clear */
+		mp200_ipu_hw_int_disable(IPU_HW_FUNC_ROT);
+#endif
+		ret[0] = IPU_CALLBACK_SUCCESS;	/* flag of callback  */
+		ret[1] = IPU_REQ_STATUS_DONE;	/* status of request */
+	}
+	mp200_ipu_req_finalize(p, ret);
+
+	return ret[1];
+}
+
+
+/*****************************************************************************
+* MODULE   : mp200_ipu_req_finalize_gdma
+* FUNCTION : finalize the request without callback(GDMA)
+* RETURN   : status of request
+*            success : IPU_REQ_STATUS_DONE
+* NOTE     : none
+* CREATE   : 2006/10/03 M.Sasaki
+* UPDATE   :
+******************************************************************************/
+static int mp200_ipu_req_finalize_gdma(struct mp200_ipu_req_regist *p)
+{
+	int ret[2] = {IPU_CALLBACK_SUCCESS, IPU_REQ_STATUS_DONE};
+
+	/* check Interuppt Status */
+	unsigned long ulRegVal32 = readl(GDMAMmioV + DMA_STATUS);
+
+	if ((ulRegVal32 & DMA_AHBERR_BIT) == DMA_AHBERR_BIT) {
+		/* interrupt by ERROR of inner bus I/F */
+#ifdef CONFIG_MP200_IPU_DUAL
+		/* remove next request */
+		mp200_ipu_reqqueue_del_next_sequence(request_gdma,
+			p->ipu_req.sequence);
+#endif
+
+		/* Reset GDMA */
+		mp200_pmu_clkctrl_off(MP200_CLKCTRL_IPUDMA);
+		mp200_pmu_clkctrl_off(MP200_CLKCTRL_IPUDMACLK);
+		mp200_pmu_reset_device(MP200_RESETDEVICE_IPUDMA);
+		mp200_pmu_close_clockgate(MP200_CLOCKGATE_IPUDMA_CLK);
+		mp200_pmu_close_clockgate(MP200_CLOCKGATE_IPUDMA_PCLK);
+		/* Unreset GDMA */
+		mp200_pmu_open_clockgate(MP200_CLOCKGATE_IPUDMA_CLK);
+		mp200_pmu_open_clockgate(MP200_CLOCKGATE_IPUDMA_PCLK);
+		mp200_pmu_unreset_device(MP200_RESETDEVICE_IPUDMA);
+		mp200_pmu_clkctrl_on(MP200_CLKCTRL_IPUDMA);
+		mp200_pmu_clkctrl_on(MP200_CLKCTRL_IPUDMACLK);
+
+		/* Error Message */
+		if ((ulRegVal32 & DMA_AHBERR_BIT) == DMA_AHBERR_BIT)
+			printk(KERN_INFO " @ipu: DMA AHB ERROR. Reset DMA.\n");
+
+		ret[0] = IPU_CALLBACK_IPU_ERROR;	/* flag of callback  */
+		ret[1] = IPU_REQ_STATUS_ERROR;		/* status of request */
+	} else if ((ulRegVal32 & DMA_STAT_BIT) == DMA_STAT_BIT) {
+		/* interrupt that GDMA process is completed */
+#ifdef CONFIG_MP200_IPU_DUAL
+		/* Interuppt Enable Clear and Interuppt Status Clear */
+		mp200_ipu_hw_int_ffclr(IPU_HW_FUNC_GDMA);
+#else
+		/* Interuppt Enable Clear and Interuppt Status Clear */
+		mp200_ipu_hw_int_disable(IPU_HW_FUNC_GDMA);
+#endif
+		ret[0] = IPU_CALLBACK_SUCCESS;	/* flag of callback  */
+		ret[1] = IPU_REQ_STATUS_DONE;	/* status of request */
+	}
+	mp200_ipu_req_finalize(p, ret);
+
+	return ret[1];
+}
+
+
+#if defined(CONFIG_PM) || defined(CONFIG_DPM)
+/* ------------------------------------------- */
+/*   DPM functions							 */
+/* ------------------------------------------- */
+/*****************************************************************************
+* MODULE   : mp200_ipu_suspend
+* FUNCTION : callback function when to suspend
+* RETURN   : 0
+* NOTE     : none
+* CREATE   : 2006/10/05 M.Sasaki
+* UPDATE   :
+******************************************************************************/
+static int  mp200_ipu_suspend(struct platform_device *dev, pm_message_t state)
+{
+	if (state.event == DEV_SUSPEND_IDLE_1) {
+		if (ctrl_func)
+			return -EBUSY;
+		else
+			return 0;
+
+	} else {
+		/* state.event == PM_EVENT_SUSPEND */
+		return 0;
+	}
+}
+
+
+/*****************************************************************************
+* MODULE   : mp200_ipu_suspend_set_hwreq_flag
+* FUNCTION : search the IPU request from queues(sub)
+* RETURN   : NULL    : target request does not exist
+*          : pointer : pointer to the top of queue containing target request
+* NOTE     : none
+* CREATE   : 2006/11/21 M.Haguro
+* UPDATE   :
+******************************************************************************/
+#ifdef CONFIG_MP200_IPU_DUAL
+static int mp200_ipu_suspend_set_hwreq_flg(struct list_head *list_hw)
+{
+	struct mp200_ipu_req_regist *request_hw;
+	struct list_head *list_queue;
+	int ret = 0;
+
+	list_for_each(list_queue, list_hw) {
+		request_hw = list_entry(list_queue,
+			struct mp200_ipu_req_regist, ipu_req_regist);
+		if (request_hw->hw_req_flag == SET_HW_REQ) {
+			request_hw->hw_req_flag = DONE_HW_REQ;
+			ret = 1;
+		}
+	}
+
+	return ret;
+}
+#else
+static int mp200_ipu_suspend_set_hwreq_flg(
+	struct mp200_ipu_req_regist *request_hw)
+{
+	int ret = 0;
+
+	if (request_hw->hw_req_flag == SET_HW_REQ) {
+		request_hw->hw_req_flag = DONE_HW_REQ;
+		ret = 1;
+	}
+
+	return ret;
+}
+#endif
+
+
+/*****************************************************************************
+* MODULE   : mp200_ipu_suspend_late
+* FUNCTION : callback function when to suspend_late
+* RETURN   : 0
+* NOTE     : none
+* CREATE   : 2007/11/20 M.Haguro
+* UPDATE   :
+******************************************************************************/
+static int mp200_ipu_suspend_late(struct platform_device *dev,
+	pm_message_t state)
+{
+	int i = 0;
+	int ret_i, ret_r, ret_g;
+	unsigned long ulRegVal32_i = 0, ulRegVal32_r = 0, ulRegVal32_g = 0;
+	unsigned long flags;
+#ifdef CONFIG_MP200_IPU_DUAL
+	struct mp200_ipu_queue	  *pQueue = mp200_ipu_que;
+#endif /* CONFIG_MP200_IPU_DUAL */
+
+	if (!mp200_sleep_while_idle) {
+		DPM_suspend_flg = 1;
+		/* disable interrupts */
+		spin_lock_irqsave(&ipu_lock, flags);
+
+#ifdef CONFIG_MP200_IPU_DUAL
+		ret_i = mp200_ipu_suspend_set_hwreq_flg(
+			&pQueue->ipu_queue_img);
+		ret_r = mp200_ipu_suspend_set_hwreq_flg(
+			&pQueue->ipu_queue_rot);
+		ret_g = mp200_ipu_suspend_set_hwreq_flg(
+			&pQueue->ipu_queue_gdma);
+#else
+		ret_i = mp200_ipu_suspend_set_hwreq_flg(request_img);
+		ret_r = mp200_ipu_suspend_set_hwreq_flg(request_rot);
+		ret_g = mp200_ipu_suspend_set_hwreq_flg(request_gdma);
+#endif /* CONFIG_MP200_IPU_DUAL */
+
+		do {
+			if (ret_i)
+				ulRegVal32_i = readl(IMGMmioV  + IMG_ACK);
+
+			if (ret_r)
+				ulRegVal32_r = readl(ROTMmioV  + ROT_STATUS);
+
+			if (ret_g)
+				ulRegVal32_g = readl(GDMAMmioV + DMA_ACK);
+
+			if (ulRegVal32_i || ulRegVal32_r || ulRegVal32_g)
+				mdelay(16);
+			else
+				break;
+			i++;
+		} while (i < 5);
+
+		/* enable interrupts */
+		spin_unlock_irqrestore(&ipu_lock, flags);
+	}
+	return 0;
+}
+
+
+/*****************************************************************************
+* MODULE   : mp200_ipu_resume
+* FUNCTION : callback function when to resume
+* RETURN   : 0
+* NOTE     : none
+* CREATE   : 2006/10/05 M.Sasaki
+* UPDATE   :
+******************************************************************************/
+static int  mp200_ipu_resume(struct platform_device *dev)
+{
+	if (DPM_suspend_flg == 1) {
+		/* start to run request in IMG Request's queue */
+		wake_up_interruptible(&mp200_ipu_devices->wait_busy_img);
+		/* start to run request in ROT Request's queue */
+		wake_up_interruptible(&mp200_ipu_devices->wait_busy_rot);
+		/* start to run request in GDMA Request's queue */
+		wake_up_interruptible(&mp200_ipu_devices->wait_busy_gdma);
+		tasklet_schedule(&ipu_nexttask); /* start the next request */
+	}
+	return 0;
+}
+
+
+/*****************************************************************************
+* MODULE   : mp200_ipu_resume_early
+* FUNCTION : callback function when to resume
+* RETURN   : 0
+* NOTE     : none
+* CREATE   : 2006/11/21 M.Sasaki
+* UPDATE   :
+******************************************************************************/
+static int  mp200_ipu_resume_early(struct platform_device *dev)
+{
+	return 0;
+}
+
+
+/*****************************************************************************
+* MODULE   : mp200_ipu_resume_kick
+* FUNCTION : start the next request
+* RETURN   : none
+* NOTE     : none
+* CREATE   : 2007/11/21 M.Haguro
+* UPDATE   :
+******************************************************************************/
+static void mp200_ipu_resume_kick(unsigned long num)
+{
+#ifdef CONFIG_MP200_IPU_DUAL
+	struct mp200_ipu_queue *pQueue = mp200_ipu_que;
+	mp200_ipu_resume_kick_next(&pQueue->ipu_queue_img,  INT_IMG);
+	mp200_ipu_resume_kick_next(&pQueue->ipu_queue_rot,  INT_ROT);
+	mp200_ipu_resume_kick_next(&pQueue->ipu_queue_gdma, INT_IPU_DMA);
+#else
+	mp200_ipu_resume_kick_next(request_img,  INT_IMG);
+	mp200_ipu_resume_kick_next(request_rot,  INT_ROT);
+	mp200_ipu_resume_kick_next(request_gdma, INT_IPU_DMA);
+#endif
+}
+
+
+/*****************************************************************************
+* MODULE   : mp200_ipu_resume_kick_next
+* FUNCTION : start the next request
+* RETURN   : none
+* NOTE     : none
+* CREATE   : 2007/11/21 M.Haguro
+* UPDATE   :
+******************************************************************************/
+#ifdef CONFIG_MP200_IPU_DUAL
+static void mp200_ipu_resume_kick_next(struct list_head *list_hw, int irq)
+{
+	struct mp200_ipu_req_regist *request_hw;
+	struct list_head			*list_queue;
+	int	tmp_hw_func;
+
+	list_for_each(list_queue, list_hw) {
+		request_hw  = list_entry(list_queue,
+			struct mp200_ipu_req_regist, ipu_req_regist);
+		if (request_hw->hw_req_flag == DONE_HW_REQ) {
+			tmp_hw_func = request_hw->ipu_req.ipu_hw_func;
+			mp200_ipu_resume_kick_finalize((void *)request_hw, irq);
+		}
+	}
+}
+#else
+static void mp200_ipu_resume_kick_next(
+	struct mp200_ipu_req_regist *request_hw, int irq)
+{
+	int	tmp_hw_func;
+
+	if (request_hw->hw_req_flag == DONE_HW_REQ) {
+		tmp_hw_func = request_hw->ipu_req.ipu_hw_func;
+		mp200_ipu_resume_kick_finalize((void *)request_hw, irq);
+	}
+}
+#endif
+
+
+
+
+/*****************************************************************************
+* MODULE   : mp200_ipu_resume_kick_finalize
+* FUNCTION : start the next request
+* RETURN   : none
+* NOTE     : none
+* CREATE   : 2007/11/21 M.Haguro
+* UPDATE   :
+******************************************************************************/
+static void mp200_ipu_resume_kick_finalize(void *task, int irq)
+{
+	int ret[2]	 = {IPU_CALLBACK_SUCCESS, IPU_REQ_STATUS_DONE};
+	int status_tmp = ret[1];
+	int	tmp_hw_func;
+#ifdef CONFIG_MP200_IPU_DUAL
+	struct mp200_ipu_task *p_tmp;
+#else
+	struct mp200_ipu_req_regist *p_tmp;
+#endif /* CONFIG_MP200_IPU_DUAL */
+
+
+#ifdef CONFIG_MP200_IPU_DUAL
+	p_tmp = (struct mp200_ipu_task *)task;
+	tmp_hw_func = p_tmp->request->ipu_req.ipu_hw_func;
+#else
+	p_tmp = (struct mp200_ipu_req_regist *)task;
+	tmp_hw_func = p_tmp->ipu_req.ipu_hw_func;
+#endif /* CONFIG_MP200_IPU_DUAL */
+
+
+	switch (irq) {
+	case INT_IMG:
+		dbg_GetStopTime(1, "IMG");
+#ifdef CONFIG_MP200_IPU_DUAL
+		mp200_ipu_req_finalize(p_tmp->request, ret);
+#else
+		mp200_ipu_req_finalize(p_tmp, ret);
+#endif
+		break;
+	case INT_ROT:
+		dbg_GetStopTime(1, "ROT");
+#ifdef CONFIG_MP200_IPU_DUAL
+		mp200_ipu_req_finalize(p_tmp->request, ret);
+#else
+		mp200_ipu_req_finalize(p_tmp, ret);
+#endif
+		break;
+	case INT_IPU_DMA:
+		dbg_GetStopTime(1, "GDMA");
+#ifdef CONFIG_MP200_IPU_DUAL
+		mp200_ipu_req_finalize(p_tmp->request, ret);
+#else
+		mp200_ipu_req_finalize(p_tmp, ret);
+#endif
+		break;
+	default:
+		status_tmp = 0;
+		return;
+	}
+
+	/* request running flag initialize and release buffer */
+#ifdef CONFIG_MP200_IPU_DUAL
+	mp200_ipu_release_buf(p_tmp->request);
+	mp200_ipu_reqqueue_del(p_tmp);
+#else
+	mp200_ipu_release_buf(p_tmp);
+	p_tmp = NULL;
+#endif /* CONFIG_MP200_IPU_DUAL */
+
+	Call_StatusCtrlFunc_OFF();
+
+	if (IPU_REQ_leftcall.callback) {
+		/* with callback*/
+		dbg_GetStopTime(2, "callback");
+		if ((IPU_REQ_leftcall.callback
+				== (void *)mp200_ipu_callback_img)
+			|| (IPU_REQ_leftcall.callback
+				== (void *)mp200_ipu_callback_rot)
+			|| (IPU_REQ_leftcall.callback
+				== (void *)mp200_ipu_callback_gdma)) {
+
+			(IPU_REQ_leftcall.callback)(IPU_REQ_leftcall.data,
+				IPU_REQ_leftcall.flag);
+		} else {
+			(IPU_REQ_leftcall.callback)(IPU_REQ_leftcall.sequence,
+				IPU_REQ_leftcall.flag);
+		}
+		memset(&IPU_REQ_leftcall, 0,
+			sizeof(struct mp200_ipu_req_leftcall));
+	}
+
+	mp200_ipu_resume_kick_wakeup(tmp_hw_func);
+
+	return;
+}
+
+
+/*****************************************************************************
+* MODULE   : mp200_ipu_resume_kick_wakeup
+* FUNCTION : start the next request
+* RETURN   : none
+* NOTE     : none
+* CREATE   : 2007/11/21 M.Haguro
+* UPDATE   :
+******************************************************************************/
+static void mp200_ipu_resume_kick_wakeup(int hw_func)
+{
+	struct mp200_ipu_dev *dev = mp200_ipu_devices;
+
+	/* start to run request in IPU Request's queue */
+	switch (hw_func) {
+	case IPU_HW_FUNC_IMG:
+		wake_up_interruptible(&dev->wait_busy_rot);
+		wake_up_interruptible(&dev->wait_busy_gdma);
+		wake_up_interruptible(&dev->wait_busy_img);
+		break;
+	case IPU_HW_FUNC_ROT:
+		wake_up_interruptible(&dev->wait_busy_gdma);
+		wake_up_interruptible(&dev->wait_busy_img);
+		wake_up_interruptible(&dev->wait_busy_rot);
+		break;
+	case IPU_HW_FUNC_GDMA:
+		wake_up_interruptible(&dev->wait_busy_img);
+		wake_up_interruptible(&dev->wait_busy_rot);
+		wake_up_interruptible(&dev->wait_busy_gdma);
+		break;
+	}
+}
+#endif /* CONFIG_PM || CONFIG_DPM */
+
+
+/*****************************************************************************
+* MODULE   : mp200_ipu_init_module
+* FUNCTION : initialize module
+* RETURN   :        0 : success
+*          : negative : fail
+* NOTE     : none
+* CREATE   : 2006/10/05 M.Sasaki
+* UPDATE   :
+******************************************************************************/
+int mp200_ipu_init_module(void)
+{
+	int result;
+
+	ctrl_func = 0;
+#ifndef CONFIG_MP200_IPU_DUAL
+	request_img = NULL;
+	request_rot  = NULL;
+	request_gdma = NULL;
+#endif
+#if defined(CONFIG_PM) || defined(CONFIG_DPM)
+	DPM_suspend_flg = 0;
+#endif /* CONFIG_PM || CONFIG_DPM */
+
+
+	if (dev_major) {
+		t_dev  = MKDEV(dev_major, 0);
+		result = register_chrdev_region(t_dev, 1, ipu_dev_name);
+	} else {
+		result = alloc_chrdev_region(&t_dev, 0, 1, ipu_dev_name);
+		dev_major  = MAJOR(t_dev);
+	}
+	if (result < 0) {
+		printk(KERN_ERR "mp200_ipu: can't get major number.\n");
+		goto fail_get_major;
+	}
+
+	cdev_init(&mp200_ipu_cdev, &mp200_ipu_fops);
+	mp200_ipu_cdev.owner = THIS_MODULE;
+	result = cdev_add(&mp200_ipu_cdev, t_dev, 1);
+	if (result) {
+		/* -- */
+		goto fail_cdev_add;
+	}
+
+	mp200_ipu_class = class_create(THIS_MODULE, ipu_dev_name);
+	if (IS_ERR(mp200_ipu_class)) {
+		printk(KERN_ERR "mp200_ipu: Unable to create ipu class.\n");
+		result = PTR_ERR(mp200_ipu_class);
+		goto fail_class_create;
+	}
+	mp200_ipu_class_dev = device_create(mp200_ipu_class, NULL, t_dev,
+		NULL, "ipu");
+	if (IS_ERR(mp200_ipu_class_dev)) {
+		printk(KERN_ERR "mp200_ipu: Unable to create class_device.\n");
+		result = PTR_ERR(mp200_ipu_class_dev);
+		goto fail_class_device_create;
+	}
+
+	/* initialize ipu driver */
+	result = mp200_ipu_init();
+	if (result < 0) {
+		printk(KERN_ERR "mp200_ipu: ipu driver initialize <failed>\n");
+		goto fail_ipu_init;
+	}
+
+	printk(KERN_INFO "mp200_ipu: registered device ipu [ipu]\n");
+	goto success;
+
+fail_ipu_init:
+	device_destroy(mp200_ipu_class, MKDEV(dev_major, 0));
+fail_class_device_create:
+	class_destroy(mp200_ipu_class);
+fail_class_create:
+	cdev_del(&mp200_ipu_cdev);
+fail_cdev_add:
+	unregister_chrdev(dev_major, ipu_dev_name);
+fail_get_major:
+success:
+
+	return result;
+}
+
+
+#ifdef MODULE
+/*****************************************************************************
+* MODULE   : mp200_ipu_cleanup_module
+* FUNCTION : cleanup module
+* RETURN   : none
+* NOTE     : none
+* CREATE   : 2006/10/05 M.Sasaki
+* UPDATE   :
+******************************************************************************/
+void mp200_ipu_cleanup_module(void)
+{
+
+	thread_img_flag = 0;			/* thread exit IMG  */
+	thread_rot_flag = 0;			/* thread exit ROT  */
+	thread_gdma_flag = 0;			/* thread exit GDMA */
+
+	mp200_ipu_hw_int_disable(IPU_HW_FUNC_ALL);
+	free_irq(INT_IMG, NULL);
+	free_irq(INT_ROT, NULL);
+	free_irq(INT_IPU_DMA, NULL);
+
+	/* Reset IMG */
+	mp200_pmu_clkctrl_off(MP200_CLKCTRL_IPUIMG1);
+	mp200_pmu_clkctrl_off(MP200_CLKCTRL_IPUIMG2);
+	mp200_pmu_clkctrl_off(MP200_CLKCTRL_IPUIMGPCLK);
+	mp200_pmu_reset_device(MP200_RESETDEVICE_IPUIMG);
+	mp200_pmu_close_clockgate(MP200_CLOCKGATE_IMG_1_CLK);
+	mp200_pmu_close_clockgate(MP200_CLOCKGATE_IMG_2_CLK);
+	mp200_pmu_close_clockgate(MP200_CLOCKGATE_IMG_PCLK);
+
+	/* Reset ROT */
+	mp200_pmu_clkctrl_off(MP200_CLKCTRL_IPUROT);
+	mp200_pmu_clkctrl_off(MP200_CLKCTRL_IPUROTPCLK);
+	mp200_pmu_reset_device(MP200_RESETDEVICE_IPUROT);
+	mp200_pmu_close_clockgate(MP200_CLOCKGATE_ROT_CLK);
+	mp200_pmu_close_clockgate(MP200_CLOCKGATE_ROT_PCLK);
+
+	/* Reset GDMA */
+	mp200_pmu_clkctrl_off(MP200_CLKCTRL_IPUDMA);
+	mp200_pmu_clkctrl_off(MP200_CLKCTRL_IPUDMACLK);
+	mp200_pmu_reset_device(MP200_RESETDEVICE_IPUDMA);
+	mp200_pmu_close_clockgate(MP200_CLOCKGATE_IPUDMA_CLK);
+	mp200_pmu_close_clockgate(MP200_CLOCKGATE_IPUDMA_PCLK);
+
+	/* Reset IPUAHB */
+	mp200_pmu_clkctrl_off(MP200_CLKCTRL_IPUAHB);
+	mp200_pmu_reset_device(MP200_RESETDEVICE_IPUAHB);
+	mp200_pmu_close_clockgate(MP200_CLOCKGATE_IPUAHB_CLK);
+
+#if defined(CONFIG_PM) || defined(CONFIG_DPM)
+	platform_driver_unregister(&mp200_ipu_driver);
+	platform_device_unregister(&mp200_ipu_device);
+#endif /* CONFIG_PM || CONFIG_DPM */
+
+	class_device_unregister(mp200_ipu_class_dev);
+	class_destroy(mp200_ipu_class);
+	cdev_del(&mp200_ipu_cdev);
+	unregister_chrdev(dev_major, ipu_dev_name);
+
+	kfree(mp200_ipu_devices);
+	kfree(mp200_ipu_req_bufs);
+	kfree(mp200_ipu_que);
+}
+
+
+module_init(mp200_ipu_init_module);
+module_exit(mp200_ipu_cleanup_module);
+#else
+device_initcall(mp200_ipu_init_module);
+#endif
+
+
+
+MODULE_AUTHOR("NEC Electronics Corporation.");
+MODULE_DESCRIPTION("IPU control driver");
+MODULE_LICENSE("GPL");
+
diff --git a/drivers/ipu/mp200_ipu.h b/drivers/ipu/mp200_ipu.h
new file mode 100644
index 0000000..3953bfa
--- /dev/null
+++ b/drivers/ipu/mp200_ipu.h
@@ -0,0 +1,319 @@
+/*
+*  File Name       : /drivers/ipu/mp200_ipu.h
+*  Function        : IPU Driver
+*  Release Version : Ver 1.00
+*  Release Date    : 2006/11/20
+*
+*  Copyright (C) NEC Electronics Corporation 2006
+*
+*
+*  This program is free software;you can redistribute it and/or modify it
+*  under the terms of the GNU General Public License as published by Free
+*  Softwere Foundation; either version 2 of License, or (at your option) any
+*  later version.
+*
+*  This program is distributed in the hope that it will be useful, but WITHOUT
+*  ANY WARRANTY; without even the implied warrnty of MERCHANTABILITY or
+*  FITNESS FOR A PARTICULAR PURPOSE.
+*  See the GNU General Public License for more details.
+*
+*  You should have received a copy of the GNU General Public License along
+*  with this program; If not, write to the Free Software Foundation, Inc., 59
+*  Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+*
+*/
+
+
+#ifndef _MP200_IPU_H_
+#define _MP200_IPU_H_
+
+#define _IPU_COLCONV 1 /* 1:enable  0:disable */
+#define _IPU_RT_THREAD 1 /* 1:enable  0:disable */
+
+#ifndef TRUE
+#define TRUE 1
+#endif /* TRUE */
+#ifndef FALSE
+#define FALSE 0
+#endif /* FALSE */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/version.h>
+#include <linux/fs.h>
+#include <linux/proc_fs.h>  /* using /proc file system */
+#include <linux/errno.h>
+#include <linux/string.h>
+
+#include <linux/mm.h>
+#include <linux/tty.h>
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+#include <linux/cdev.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/spinlock.h>
+#include <linux/uaccess.h>
+#include <linux/fb.h>
+#include <linux/init.h>
+#include <linux/ioport.h>
+#include <linux/timer.h>
+#include <linux/sched.h>
+
+#include <linux/semaphore.h>
+#include <linux/completion.h>
+#include <linux/wait.h>
+#include <linux/list.h>
+#if _IPU_RT_THREAD
+#include <linux/sched.h>
+#endif
+
+/* to provide ioctl */
+#include <linux/ioctl.h>
+#include <linux/types.h>
+#include <linux/io.h>
+
+
+#include <linux/platform_device.h>
+
+/* platform related */
+#include <mach/ipu.h>
+#include <mach/ipu_user.h>
+
+#include <mach/irqs.h>		/* #define INT_IMG     22
+				 * #define INT_ROT     23
+				 * #define INT_IPU_DMA 37
+				 */
+#include <mach/pmu.h>
+
+#if defined(CONFIG_PM) || defined(CONFIG_DPM)
+#include <linux/freezer.h>
+#include <mach/pm.h>
+#endif /* CONFIG_PM || CONFIG_DPM */
+
+#define _DEBUG_IPU_LOG	0 /* 1:enable  0:disable */
+#define _IPU_PERF	0	/*  0: disable
+				 *  1: enable IMG/ROT/GDMA
+				 *  2: enable regist - callback
+				 *  3: enable ioctl  - return
+				 *  4: enable DMA
+				 */
+
+/****************************************************************************/
+/* File information structure                                               */
+/****************************************************************************/
+struct mp200_ipu_dev_info {
+	int flag;			/* status of device information
+					 *  structure
+					 *   FALSE(0):usable
+					 *   TRUE(1) :used
+					 */
+	int vmas;			/* active mappings */
+	struct semaphore sem_vm;	/* exclusive resource (for mmap) */
+	struct semaphore sem;		/* exclusive resource            */
+	wait_queue_head_t wait_que;	/* wait queue                    */
+	int sleep_mode;			/* sleep status
+					 *   FALSE(0):wakeup
+					 *   TRUE(1):sleep
+					 */
+	int status;			/* status of IPU request process
+					 *  IPU_STATUS_DONE(0)  : done
+					 *  IPU_STATUS_WAIT(1)  : running
+					 *  IPU_STATUS_NO_REQ(2): no request
+					 */
+	struct mp200_ipu_req req;	/* IPU request structure
+					 *  sequence: request sequence no
+					 *  status: status of IPU request
+					 *  callback: callback function
+					 *  data: optional data
+					 *  ipu_hw_func: request H/W
+					 *  ipu_reg_info: IPU register
+					 *                setting info
+					 */
+};
+#define MP200_IPU_DEV_INFO struct mp200_ipu_dev_info
+
+/****************************************************************************/
+/* Device information structure                                             */
+/****************************************************************************/
+struct mp200_ipu_dev {
+    wait_queue_head_t    wait_idle_img;  /* wait queue img(idle)            */
+    wait_queue_head_t    wait_idle_rot;  /* wait queue rot(idle)            */
+    wait_queue_head_t    wait_idle_gdma; /* wait queue gdma(idle)           */
+    wait_queue_head_t    wait_busy_img;  /* wait queue img(busy)            */
+    wait_queue_head_t    wait_busy_rot;  /* wait queue rot(busy)            */
+    wait_queue_head_t    wait_busy_gdma; /* wait queue gdma(busy)           */
+    struct mp200_ipu_dev_info ipu_dev_info[];
+};
+#define MP200_IPU_DEV struct mp200_ipu_dev
+#define MP200_IPU_DEVS 8              /* mp200_ipu0 through mp200_ipu  */
+
+
+/*===============================================================*/
+/* IPU request information queue structure                       */
+/*===============================================================*/
+enum hw_req {
+	NO_HW_REQ,   /* 0 */
+	SET_HW_REQ,  /* 1 */
+	DONE_HW_REQ, /* 2 */
+};
+
+struct mp200_ipu_req_regist {
+	struct list_head ipu_req_regist;	/* head of IPU request
+						 * information structure is
+						 * secured
+						 */
+	int callback_flag;		/* TRUE  : callback is required
+					 * FALSE : callback is not required
+					 */
+	enum hw_req hw_req_flag;	/* NO_HW_REQ : REQ(HW) is not set
+					 * SET_HW_REQ: REQ(HW) is set
+					 * DONE_HW_REQ: REQ(HW) is complete
+					 */
+#ifdef CONFIG_MP200_IPU_DUAL
+	int request_flag;		/* TRUE  : request is set
+					 * FALSE : request is not set
+					 */
+#endif
+	struct mp200_ipu_req  ipu_req;	/* IPU request information */
+};
+#define MP200_IPU_REQ_REGIST struct mp200_ipu_req_regist
+
+#ifdef CONFIG_MP200_IPU_DUAL
+#define MAX_SIZE_MP200_IPU_REQ_REGIST \
+	(sizeof(struct list_head) + sizeof(int) + sizeof(enum hw_req) \
+	+ sizeof(int) + (MAX_SIZE_MP200_IPU_REQ))
+#else
+#define MAX_SIZE_MP200_IPU_REQ_REGIST \
+	(sizeof(struct list_head) + sizeof(int) + sizeof(enum hw_req) \
+	+ (MAX_SIZE_MP200_IPU_REQ))
+#endif
+
+
+/*===============================================================*/
+/* IPU queue structure                                           */
+/*===============================================================*/
+#define IPU_BUFS_MAX 32		/* max number of IPU request queue structure */
+				/* setting informations */
+
+struct mp200_ipu_queue {
+	/* sequence No                                          */
+	unsigned long		sequence;
+	/* head of IPU request information structure is secured */
+	struct list_head	ipu_queue_img;
+	/* head of IPU request information structure is secured */
+	struct list_head	ipu_queue_rot;
+	/* head of IPU request information structure is secured */
+	struct list_head	ipu_queue_gdma;
+	/* IPU request information structure Size */
+	struct mp200_ipu_req_regist *bufs[IPU_BUFS_MAX];
+};
+#define MP200_IPU_QUEUE struct mp200_ipu_queue
+
+#define SIZE_MP200_IPU_QUEUE (28 + 4 * IPU_BUFS_MAX)
+
+
+/****************************************************************************/
+/* debug option                                                             */
+/****************************************************************************/
+/*===============================================================*/
+/* performance measurement                                       */
+/*===============================================================*/
+#if _DEBUG_IPU_LOG > 0
+#ifdef _DEBUG_IPU
+       ulong *sleep_status;
+#else
+extern ulong *sleep_status;
+#endif
+
+#define SLEEP_1    0x00000001
+#define SLEEP_2    0x00000002
+#define SLEEP_3    0x00000004
+#define SLEEP_4    0x00000008
+#define SLEEP_5    0x00000010
+#define SLEEP_6    0x00000020
+#define SLEEP_7    0x00000040
+#define SLEEP_8    0x00000080
+#define SLEEP_9    0x00000100
+#define SLEEP_10   0x00000200
+#define SLEEP_11   0x00000400
+#define SLEEP_12   0x00000800
+#define SLEEP_13   0x00001000
+#define SLEEP_14   0x00002000
+#define SLEEP_15   0x00004000
+#define SLEEP_16   0x00008000
+#define WAIT_DMA_1 0x00010000
+#define WAIT_DMA_2 0x00020000
+
+#define dbg_SetSleepStatus(FLG) *sleep_status |= FLG;
+#define dbg_ClrSleepStatus(FLG) *sleep_status &= ~FLG;
+#else
+#define dbg_SetSleepStatus(FLG) ;
+#define dbg_ClrSleepStatus(FLG) ;
+#endif
+
+
+/*===============================================================*/
+/* performance measurement                                       */
+/*===============================================================*/
+#if _IPU_PERF > 0
+#ifdef _DEBUG_IPU
+       struct timeval  tv_start, tv_stop;
+       struct timezone tz;
+unsigned long   delta;
+#else
+extern struct timeval  tv_start, tv_stop;
+extern struct timezone tz;
+extern unsigned long   delta;
+#endif
+
+#define dbg_CalcTime(num)                                                     \
+	do {                                                                  \
+		if (tv_stop.tv_sec > tv_start.tv_sec) {                       \
+			delta = (tv_stop.tv_sec - tv_start.tv_sec) *          \
+			  1000 * 1000; \
+			if (tv_stop.tv_usec > tv_start.tv_usec) {             \
+				delta += (tv_stop.tv_usec - tv_start.tv_usec);\
+			} else {                                              \
+				delta -= (tv_start.tv_usec - tv_stop.tv_usec);\
+			}                                                     \
+		} else if (tv_stop.tv_sec == tv_start.tv_sec) {               \
+			if (tv_stop.tv_usec > tv_start.tv_usec) {             \
+				delta = (tv_stop.tv_usec - tv_start.tv_usec); \
+			} else {                                              \
+				delta = 0;                                    \
+			}                                                     \
+		} else {                                                      \
+			delta = 0;                                            \
+		}                                                             \
+		printk(KERN_DEBUG \
+		  " @ipu: " num ": ->cycle(%ld.%03ld)msec" \
+		  "  ->start(%ld)  ->end(%ld)\n",          \
+		  delta / 1000, delta % 1000, tv_start.tv_usec, \
+		  tv_stop.tv_usec); \
+	} while (0);
+
+#define dbg_GetStartTime(level)  \
+	if (_IPU_PERF == level) { \
+		do_gettimeofday(&tv_start); \
+	}
+
+#define dbg_GetStopTime(level, num)        \
+	if (_IPU_PERF == level) {            \
+		do_gettimeofday(&tv_stop); \
+		dbg_CalcTime(num);         \
+	}
+#else
+#define dbg_GetStartTime(level)      ;
+#define dbg_GetStopTime(level, num)  ;
+#endif /* _IPU_PERF */
+
+
+/* ------------------------------------------- */
+/*   external flags                            */
+/* ------------------------------------------- */
+extern MP200_IPU_DEV *mp200_ipu_devices; /* allocated in mp200_ipu_init */
+extern int mp200_ipu_devs; /* number of bare IPU devices */
+
+#endif /* _MP200_IPU_H_ */
+
diff --git a/drivers/ipu/mp200_ipu_user.c b/drivers/ipu/mp200_ipu_user.c
new file mode 100644
index 0000000..4d9381a
--- /dev/null
+++ b/drivers/ipu/mp200_ipu_user.c
@@ -0,0 +1,603 @@
+/*
+*  File Name       : /drivers/ipu/mp200_ipu_user.c
+*  Function        : IPU Driver
+*  Release Version : Ver 1.00
+*  Release Date    : 2006/11/20
+*
+*  Copyright (C) NEC Electronics Corporation 2006
+*
+*
+*  This program is free software;you can redistribute it and/or modify it
+*  under the terms of the GNU General Public License as published by Free
+*  Softwere Foundation; either version 2 of License, or (at your option) any
+*  later version.
+*
+*  This program is distributed in the hope that it will be useful, but WITHOUT
+*  ANY WARRANTY; without even the implied warrnty of MERCHANTABILITY or
+*  FITNESS FOR A PARTICULAR PURPOSE.
+*  See the GNU General Public License for more details.
+*
+*  You should have received a copy of the GNU General Public License along
+*  with this program; If not, write to the Free Software Foundation, Inc., 59
+*  Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+*
+*/
+
+
+#define _DEBUG_IPU_AP	0x00	/* 00008401(bit) */
+				/* 1: debug function in
+				 * 4: debug mmap
+				 * 8: debug function out
+				 */
+#if _DEBUG_IPU_AP > 0
+#define dbg_printk(level, fmt, arg...) \
+	if (level > 0) \
+		printk(KERN_DEBUG " @ipu: " fmt, ## arg);
+#else
+#define dbg_printk(level, fmt, arg...) \
+	;
+#endif
+
+#include "mp200_ipu.h"		/* include <mach/ipu.h> */
+
+
+/****************************************************************************/
+/* Flags                                                                    */
+/****************************************************************************/
+
+
+#include "mp200_img_convert.h"
+#include "mp200_rot_rotation.h"
+
+
+/* ------------------------------------------- */
+/*   Callback function                         */
+/* ------------------------------------------- */
+/*****************************************************************************
+* MODULE   : mp200_ipu_callback_img
+* FUNCTION : Callback function for IPUIO_MP200_IPU_REGIST
+*            (register IPU request by User Process)
+* RETURN   : none
+* NOTE     : none
+* CREATE   : 2006/10/03 M.Sasaki
+* UPDATE   :
+******************************************************************************/
+void mp200_ipu_callback_img(unsigned long data, int flag)
+{
+	MP200_IPU_DEV_INFO *dev_info; /* device information */
+
+	dbg_printk((_DEBUG_IPU_AP & 0x1), "mp200_ipu_callback_img() <start>\n");
+	dbg_printk((_DEBUG_IPU_AP), "mp200_ipu_callback_img() data = 0x%lx\n",
+		data);
+
+	/* get pointer to device information structure */
+	dev_info = (MP200_IPU_DEV_INFO *)data;
+
+	/* update status of IPU request process to IPU_STATUS_DONE */
+	dev_info->status = IPU_STATUS_DONE;
+
+	/* update status of IPU request */
+	dev_info->req.status = flag;
+
+	if (dev_info->sleep_mode == TRUE) {
+		/* wake up from IPU_STATUS_WAIT */
+		wake_up_interruptible(&dev_info->wait_que);
+	}
+
+	dbg_printk((_DEBUG_IPU_AP & 0x8), "mp200_ipu_callback_img() <end>\n");
+}
+
+
+/*****************************************************************************
+* MODULE   : mp200_ipu_callback_rot
+* FUNCTION : Callback function for IPUIO_MP200_IPU_REGIST
+*            (register IPU request by User Process)
+* RETURN   : none
+* NOTE     : none
+* CREATE   : 2006/10/03 M.Sasaki
+* UPDATE   :
+******************************************************************************/
+void mp200_ipu_callback_rot(unsigned long data, int flag)
+{
+	MP200_IPU_DEV_INFO *dev_info; /* device information */
+
+	dbg_printk((_DEBUG_IPU_AP & 0x1), "mp200_ipu_callback_rot() <start>\n");
+
+	/* get pointer to device information structure */
+	dev_info = (MP200_IPU_DEV_INFO *)data;
+
+	/* update status of IPU request process to IPU_STATUS_DONE */
+	dev_info->status = IPU_STATUS_DONE;
+
+	/* update status of IPU request */
+	dev_info->req.status = flag;
+
+	if (dev_info->sleep_mode == TRUE) {
+		/* wake up from IPU_STATUS_WAIT */
+		wake_up_interruptible(&dev_info->wait_que);
+	}
+	dbg_printk((_DEBUG_IPU_AP & 0x8), "mp200_ipu_callback_rot() <end>\n");
+}
+
+
+/*****************************************************************************
+* MODULE   : mp200_ipu_callback_gdma
+* FUNCTION : Callback function for IPUIO_MP200_IPU_REGIST
+*            (register IPU request by User Process)
+* RETURN   : none
+* NOTE     : none
+* CREATE   : 2006/10/03 M.Sasaki
+* UPDATE   :
+******************************************************************************/
+void mp200_ipu_callback_gdma(unsigned long data, int flag)
+{
+	MP200_IPU_DEV_INFO *dev_info; /* device information */
+
+	dbg_printk((_DEBUG_IPU_AP & 0x1),
+		"mp200_ipu_callback_gdma() <start>\n");
+
+	/* get pointer to device information structure */
+	dev_info = (MP200_IPU_DEV_INFO *)data;
+
+	/* update status of IPU request process to IPU_STATUS_DONE */
+	dev_info->status = IPU_STATUS_DONE;
+
+	/* update status of IPU request */
+	dev_info->req.status = flag;
+
+	if (dev_info->sleep_mode == TRUE) {
+		/* wake up from IPU_STATUS_WAIT */
+		wake_up_interruptible(&dev_info->wait_que);
+	}
+
+	dbg_printk((_DEBUG_IPU_AP & 0x8), "mp200_ipu_callback_gdma() <end>\n");
+}
+
+
+/* ------------------------------------------- */
+/*   Module Entries                            */
+/* ------------------------------------------- */
+/*****************************************************************************
+* MODULE   : mp200_ipu_open
+* FUNCTION : open IPU device
+* RETURN   :       0 : success
+*          : -ENODEV : fail
+* NOTE     : none
+* CREATE   : 2006/10/04 M.Sasaki
+* UPDATE   :
+******************************************************************************/
+int mp200_ipu_open(struct inode *inode, struct file *file)
+{
+	MP200_IPU_DEV *dev = NULL;                  /* device information */
+	MP200_IPU_DEV_INFO *dev_info = NULL;        /* device information */
+	size_t size_dev_info;
+	int i;
+
+	dbg_printk((_DEBUG_IPU_AP & 0x1), " @ipu: mp200_ipu_open() <start>");
+	dbg_printk((_DEBUG_IPU_AP & 0x1),
+		"         file->f_version     : %lu \n", file->f_version);
+	dbg_printk((_DEBUG_IPU_AP & 0x1),
+		"         MINOR(inode->i_rdev): %d \n", MINOR(inode->i_rdev));
+
+	size_dev_info = sizeof(MP200_IPU_DEV_INFO)
+			+ sizeof(struct mp200_ipu_reg_info) * IPU_REG_INFO_MAX;
+	dev = mp200_ipu_devices;
+	dev_info = dev->ipu_dev_info;
+	for (i = 0; i < mp200_ipu_devs; i++) {
+		if (dev_info->flag == FALSE) { /* search unused device
+						  information structure */
+			break;
+		}
+		dev_info = (MP200_IPU_DEV_INFO *)((char *)dev_info
+			+ size_dev_info);
+	}
+	if (i >= mp200_ipu_devs)
+		return -ENODEV;
+
+	memset(dev_info, 0, size_dev_info);
+	dev_info->flag = TRUE;           /* set used */
+
+	sema_init(&dev_info->sem, 1);
+	sema_init(&dev_info->sem_vm, 1);
+	init_waitqueue_head(&dev_info->wait_que);
+	dev_info->sleep_mode = FALSE;
+	dev_info->status = IPU_STATUS_NO_REQ;
+
+	/* and use file->private_data to point to the device data */
+	file->private_data = dev_info;
+	return 0;
+}
+
+
+/*****************************************************************************
+* MODULE   : mp200_ipu_close
+* FUNCTION : close IPU device
+* RETURN   : 0 :
+* NOTE     : none
+* CREATE   : 2006/10/04 M.Sasaki
+* UPDATE   :
+******************************************************************************/
+int mp200_ipu_close(struct inode *inode, struct file *file)
+{
+	MP200_IPU_DEV_INFO *dev_info = file->private_data;
+
+	dbg_printk((_DEBUG_IPU_AP & 0x1),
+		" @ipu: mp200_ipu_close() <start>");
+	dbg_printk((_DEBUG_IPU_AP & 0x1),
+		"         file->f_version     : %lu \n", file->f_version);
+
+	dev_info->flag = FALSE;                     /* set unused */
+	return 0;
+}
+
+/*****************************************************************************
+* MODULE   : mp200_ipu_ioctl
+* FUNCTION : IOCTL main function.
+*            analyze IOCTL request and execute each operations.
+* RETURN   : positive : status
+*            negative : fail
+* NOTE     : none
+* CREATE   : 2006/10/05 M.Sasaki
+* UPDATE   : 2008/03/13 M.Sasaki
+******************************************************************************/
+int mp200_ipu_ioctl(struct inode *inode, struct file *file,
+	unsigned int request, unsigned long arg)
+{
+	int   ret = -1;
+	void *alloc_obj;
+	size_t request_size;
+
+	signed char buf_data[MAX_SIZE_IPUIOCTL];	/* max size :      */
+					/* struct _IPUIO_MP200_IPU_REGIST */
+					/* struct _IPUIO_MP200_IPU_CALLBACK */
+					/* struct _IPUIO_MP200_IPU_CANCEL  */
+					/* _IMGIO_CONVERT            */
+					/* struct struct _IMGIO_CONVERT */
+	MP200_IPU_DEV_INFO *dev_info = file->private_data;
+
+	dbg_printk((_DEBUG_IPU_AP & 0x1),
+		" @ipu: mp200_ipu_ioctl() <requset = 0x%x>\n", request);
+
+	switch (request) {
+	case IPUIO_MP200_IPU_REGIST:
+		dbg_GetStartTime(3);
+		alloc_obj = &buf_data[0];
+		if (copy_from_user(alloc_obj, (void *)arg,
+			  sizeof(struct _IPUIO_MP200_IPU_REGIST))) {
+			return -EFAULT;
+		}
+
+		request_size =
+		((struct _IPUIO_MP200_IPU_REGIST *)alloc_obj)->request_length;
+		if (request_size > (sizeof(struct mp200_ipu_req)
+		+ sizeof(struct mp200_ipu_reg_info) * IPU_REG_INFO_MAX)) {
+			printk(KERN_INFO
+				" @ipu: mp200_ipu_ioctl() Error! "
+				"request_length is too big. "
+				"<request_length = %d>\n", request_size);
+			return -EINVAL;
+		}
+
+		if (dev_info->status != IPU_STATUS_NO_REQ)
+			return -EBUSY;
+
+		if (down_interruptible(&dev_info->sem)) { /* get semafore */
+			return -ERESTARTSYS;
+		}
+
+		/* copy IPU request information from user memory area */
+		if (copy_from_user(&dev_info->req,
+		((struct _IPUIO_MP200_IPU_REGIST *)alloc_obj)->request_arg,
+		request_size)) {
+			up(&dev_info->sem);		/* release semafore */
+			return -EFAULT;
+		}
+
+		/* set pointer to Device information into dev_info->req.data */
+		dev_info->req.data = (unsigned long)dev_info;
+
+		/* set callback function into dev->req.callback */
+		switch (dev_info->req.ipu_hw_func) {
+		case IPU_HW_FUNC_IMG:
+			dev_info->req.callback =
+				(void *)mp200_ipu_callback_img;
+			break;
+		case IPU_HW_FUNC_ROT:
+			dev_info->req.callback =
+				(void *)mp200_ipu_callback_rot;
+			break;
+		case IPU_HW_FUNC_GDMA:
+			dev_info->req.callback =
+				(void *)mp200_ipu_callback_gdma;
+			break;
+		default:
+			printk(KERN_INFO
+				" @ipu: mp200_ipu_ioctl() Error! "
+				"arg->request_arg->ipu_hw_func(%d) "
+				"is incorrect.\n",
+				dev_info->req.ipu_hw_func);
+			up(&dev_info->sem);		/* release semafore */
+			return -EINVAL;
+		}
+
+		/* update status of IPU request process */
+		dev_info->status = IPU_STATUS_WAIT;	/* running */
+
+		/* regist IPU request */
+		ret = mp200_ipu_regist(&dev_info->req);
+		if (ret != IPU_REQ_REGISTERED) {	/* Registration
+							   failure */
+			dev_info->status = IPU_STATUS_NO_REQ;
+			up(&dev_info->sem);		/* release semafore */
+			break;
+		}
+
+		/* copy dev_info->req.sequence */
+		if (copy_to_user(
+		((struct _IPUIO_MP200_IPU_REGIST *)alloc_obj)->request_arg, &
+		dev_info->req, sizeof(struct mp200_ipu_req))) {
+			up(&dev_info->sem);		/* release semafore */
+			return -EFAULT;
+		}
+
+		if (file->f_flags & O_NONBLOCK) {	/* non block */
+			ret = IPU_REQ_REGISTERED;
+		} else {	/* block until IPU process is completed */
+			dev_info->sleep_mode = TRUE;
+			/* wait until IPU process is completed */
+			wait_event_interruptible(dev_info->wait_que,
+				 (dev_info->status != IPU_STATUS_WAIT));
+			dev_info->sleep_mode = FALSE;
+
+			if (dev_info->status == IPU_STATUS_DONE) {
+				/* wake up by IPU_STATUS_DONE */
+				/* set result of Write request information
+				   structure */
+				((struct _IPUIO_MP200_IPU_REGIST *)alloc_obj)->
+					result_data = dev_info->req.status;
+				if (copy_to_user(
+				&((struct _IPUIO_MP200_IPU_REGIST *)arg)->
+					result_data,
+				&((struct _IPUIO_MP200_IPU_REGIST *)alloc_obj)->
+					result_data,
+				sizeof(((struct _IPUIO_MP200_IPU_REGIST *)arg)->
+					result_data))) {
+					up(&dev_info->sem);	/* release
+								   semafore */
+					return -EFAULT;
+				}
+
+				/* update status of IPU request process */
+				/* target request does not exist */
+				dev_info->status = IPU_STATUS_NO_REQ;
+
+				up(&dev_info->sem);	/* release semafore */
+				ret = IPU_REQ_COMPLETE;
+			} else if (dev_info->status == IPU_STATUS_CANCELLED) {
+				/* update status of IPU request process */
+				/* target request does not exist */
+				dev_info->status = IPU_STATUS_NO_REQ;
+
+				up(&dev_info->sem);	/* release semeafore */
+				ret = IPU_REQ_CANCELLED;
+			} else {			/* wake up by signal */
+				ret = IPU_REQ_REGISTERED;
+			}
+		}
+		dbg_GetStopTime(3, "IPU_REGIST");
+		break;
+
+	case IPUIO_MP200_IPU_CALLBACK:
+		alloc_obj = &buf_data[0];
+		switch (dev_info->status) {
+		case IPU_STATUS_DONE:	/* IPU operation is done */
+			/* update status of IPU request process */
+			/* target request does not exist */
+			dev_info->status = IPU_STATUS_NO_REQ;
+
+			up(&dev_info->sem);	/* release semafore */
+			ret = IPU_STATUS_DONE;
+			break;
+
+		case IPU_STATUS_WAIT:	/* waiting (executing operation) */
+			if (file->f_flags & O_NONBLOCK) {	/* non block */
+
+				ret = IPU_STATUS_WAIT;
+			} else {
+				/* block until IPU operation is finished */
+				dev_info->sleep_mode = TRUE;
+				/* waiting (executing operaion) */
+				wait_event_interruptible(dev_info->wait_que,
+					(dev_info->status != IPU_STATUS_WAIT));
+				dev_info->sleep_mode = FALSE;
+
+				if (dev_info->status == IPU_STATUS_DONE) {
+					/* wake up by IPU_STATUS_DONE */
+					/* update status of IPU request
+					   process */
+					/* target request does not exist */
+					dev_info->status = IPU_STATUS_NO_REQ;
+
+					/* release semafore */
+					up(&dev_info->sem);
+					ret = IPU_STATUS_DONE;
+				} else if (dev_info->status ==
+					IPU_STATUS_CANCELLED) {
+					/* update status of IPU
+					   request process */
+					/* target request does not exist */
+					dev_info->status = IPU_STATUS_NO_REQ;
+
+					/* release semafore */
+					up(&dev_info->sem);
+					ret = IPU_STATUS_CANCELLED;
+				} else { /* wake up by signal */
+					ret = IPU_STATUS_WAIT;
+				}
+			}
+			break;
+
+		case IPU_STATUS_NO_REQ:	/* target request does not exist */
+			ret = IPU_STATUS_NO_REQ;
+			break;
+
+		default:
+			break;
+		}
+		if ((ret == IPU_STATUS_DONE) || (ret == IPU_STATUS_WAIT)) {
+			/* set result of Write request information structure */
+			((struct _IPUIO_MP200_IPU_CALLBACK *)alloc_obj)->
+				result_data = dev_info->req.status;
+			if (copy_to_user(
+			&((struct _IPUIO_MP200_IPU_CALLBACK *)arg)->result_data,
+			&((struct _IPUIO_MP200_IPU_CALLBACK *)alloc_obj)->
+				result_data,
+			sizeof(((struct _IPUIO_MP200_IPU_CALLBACK *)arg)->
+				result_data)
+			)) {
+				/* -- */
+				return -EFAULT;
+			 }
+		}
+		break;
+
+	case IPUIO_MP200_IPU_CANCEL:
+		alloc_obj = &buf_data[0];
+		switch (dev_info->status) {
+		case IPU_STATUS_DONE:	/* IPU process is completed */
+			ret = IPU_CANCEL_DONE;
+
+			/* update status of IPU request process */
+			/* target request does not exist */
+			dev_info->status = IPU_STATUS_NO_REQ;
+
+			up(&dev_info->sem);	/* release semafore */
+			break;
+
+		/* IPU process is running (already registered) */
+		case IPU_STATUS_WAIT:
+			ret = mp200_ipu_cancel(dev_info->req.sequence,
+				((struct _IPUIO_MP200_IPU_CANCEL *)alloc_obj)->
+					flag);
+
+			if (ret == IPU_CANCEL_DONE) {
+				/* update status of IPU request process */
+				if (dev_info->sleep_mode == TRUE) {
+					/* target request is cancelled */
+					dev_info->status = IPU_STATUS_CANCELLED;
+				}
+				wake_up_interruptible(&dev_info->wait_que);
+			} else {
+				/* update status of IPU request process */
+				/* target request does not exist */
+				dev_info->status = IPU_STATUS_NO_REQ;
+
+				up(&dev_info->sem);	/* release semafore */
+			}
+			break;
+
+		case IPU_STATUS_NO_REQ:
+			/* target request does not exist */
+			ret = IPU_CANCEL_NO_REQ;
+			break;
+		}
+		if ((ret == IPU_STATUS_DONE) || (ret == IPU_STATUS_WAIT)) {
+			/* set result of Write request information structure */
+			((struct _IPUIO_MP200_IPU_CANCEL *)alloc_obj)->
+				result_data =
+				dev_info->req.status;
+			if (copy_to_user(
+			&((struct _IPUIO_MP200_IPU_CANCEL *)arg)->result_data,
+			&((struct _IPUIO_MP200_IPU_CANCEL *)alloc_obj)->
+				result_data,
+			sizeof(((struct _IPUIO_MP200_IPU_CANCEL *)arg)->
+				result_data)))
+				return -EFAULT;
+
+		}
+		break;
+
+	case IMGIO_CONVERT:
+		dbg_GetStartTime(3);
+		alloc_obj = &buf_data[0];
+		if (copy_from_user(alloc_obj, (void *)arg,
+			  sizeof(struct _IMGIO_CONVERT))) {
+			return -EFAULT;
+		}
+		ret = mp200_img_convert(
+			dev_info, (struct _IMGIO_CONVERT *)alloc_obj);
+		dbg_GetStopTime(3, "IMGIO_CONVERT");
+		break;
+
+	case ROTIO_ROTATION:
+		dbg_GetStartTime(3);
+		alloc_obj = &buf_data[0];
+		if (copy_from_user(alloc_obj, (void *)arg,
+			  sizeof(struct _ROTIO_ROTATION))) {
+			return -EFAULT;
+		}
+		ret = mp200_rot_rotation(dev_info,
+			 (struct _ROTIO_ROTATION *)alloc_obj);
+		dbg_GetStopTime(3, "ROTIO_ROTATION");
+		break;
+
+	default:
+		ret = -EINVAL;
+		break;
+	}
+	return ret;
+}
+
+
+/*****************************************************************************
+* MODULE   : mp200_ipu_mmap
+* FUNCTION : mmap main function.
+*            allocate I/O buffer and map it to user area
+*              with physical address    :
+*                map target memory area to user area
+*              without physical address :
+*                allocate free area of RAM and map it to user area
+* INPUT    : physical address (or 0)
+*          : range (byte)
+* RETURN   : user area virtual address
+* NOTE     : none
+* CREATE   : 2006/10/06 M.Sasaki
+* UPDATE   : 2007/03/12 Y.Utsuhara
+******************************************************************************/
+int mp200_ipu_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	unsigned long offset = vma->vm_pgoff << PAGE_SHIFT;
+
+	dbg_printk((_DEBUG_IPU_AP & 0x4), " @ipu: mp200_ipu_mmap() <start>\n");
+	dbg_printk((_DEBUG_IPU_AP & 0x4), "         vma->vm_start: 0x%x\n",
+		(unsigned int)vma->vm_start);
+	dbg_printk((_DEBUG_IPU_AP & 0x4), "         vma->vm_end  : 0x%x\n",
+		(unsigned int)vma->vm_end);
+	dbg_printk((_DEBUG_IPU_AP & 0x4), "         offset       : 0x%x\n",
+		(unsigned int)offset);
+
+	/*
+	 * Accessing memory above the top the kernel knows about or
+	 * through a file pointer that was marked O_SYNC will be
+	 * done non-cached.
+	 */
+	vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
+
+	/* Don't try to swap out physical pages.. */
+	vma->vm_flags |= VM_RESERVED;
+
+	/*
+	 * Dump addresses that are real memory to a core file.
+	 */
+	if (offset >= __pa(high_memory) || (file->f_flags & O_SYNC))
+		vma->vm_flags |= VM_IO;
+
+	if (remap_pfn_range(vma, vma->vm_start, vma->vm_pgoff,
+		 vma->vm_end-vma->vm_start, vma->vm_page_prot)) {
+		return -EAGAIN;
+	}
+
+	dbg_printk((_DEBUG_IPU_AP & 0x4), " @ipu: mp200_ipu_mmap() <end>\n");
+	return 0;
+}
+
diff --git a/drivers/ipu/mp200_rot_rotation.h b/drivers/ipu/mp200_rot_rotation.h
new file mode 100644
index 0000000..be60c98
--- /dev/null
+++ b/drivers/ipu/mp200_rot_rotation.h
@@ -0,0 +1,672 @@
+/*
+*  File Name       : /drivers/ipu/mp200_rot_rotation.h
+*  Function        : IPU Driver
+*  Release Version : Ver 1.01
+*  Release Date    : 2009/07/23
+*
+*  Copyright (C) NEC Electronics Corporation 2009
+*
+*
+*  This program is free software;you can redistribute it and/or modify it
+*  under the terms of the GNU General Public License as published by Free
+*  Softwere Foundation; either version 2 of License, or (at your option) any
+*  later version.
+*
+*  This program is distributed in the hope that it will be useful, but WITHOUT
+*  ANY WARRANTY; without even the implied warrnty of MERCHANTABILITY or
+*  FITNESS FOR A PARTICULAR PURPOSE.
+*  See the GNU General Public License for more details.
+*
+*  You should have received a copy of the GNU General Public License along
+*  with this program; If not, write to the Free Software Foundation, Inc., 59
+*  Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+*
+*/
+
+#ifndef _MP200_ROT_ROTATION_H_
+#define _MP200_ROT_ROTATION_H_
+
+
+/************************************************************************/
+/* Macro								*/
+/************************************************************************/
+#define RotRequest(DATA, REG)				\
+do {							\
+	pReq->ipu_reg_info[index_req].reg  = (REG);	\
+	pReq->ipu_reg_info[index_req].data = (DATA);	\
+	index_req++;					\
+} while (0)
+
+
+/************************************************************************/
+/* Flags								*/
+/************************************************************************/
+/* ------------------------------------ */
+/*   internal flags			*/
+/* ------------------------------------ */
+static unsigned long rot_mode;
+static unsigned long ulSrcStarAddrY, ulSrcStarAddrUV, ulSrcStarAddrV;
+static unsigned long ulDstStarAddrY, ulDstStarAddrUV, ulDstStarAddrV;
+static unsigned long ulSrcPitch, ulDstPitch;
+static unsigned long rot_src_width, rot_src_height;
+static unsigned long in_bytelane, out_bytelane;
+static unsigned long rot_format_in, rot_format_out, rot_format;
+
+
+/* ------------------------------------ */
+/*   definition				*/
+/* ------------------------------------ */
+#define MAX_ROT_SCREEN_WIDTH	  0x3FFC
+#define MAX_ROT_SCREEN_WIDTH_ES1x 0xFFC
+
+
+/************************************************************************/
+/* Prototype declarations						*/
+/************************************************************************/
+/* -------------------------------------*/
+/*   Private functions			*/
+/* -------------------------------------*/
+static int mp200_rot_rotation(MP200_IPU_DEV_INFO *dev_info,
+	struct _ROTIO_ROTATION *p);
+static int mp200_rot_mkdata(struct _ROTIO_ROTATION *p);
+static int mp200_rot_mkreq(struct mp200_ipu_req *pReq, int index);
+
+
+/*****************************************************************************
+* MODULE   : mp200_rot_rotation
+* FUNCTION : ioctl ROTIO_ROTATION sub function. rotate image with IPU.
+* RETURN   : ROT_COMPLETE(0) : Success
+*	    -EINVAL		: Fail (parameter error)
+*	    -EBUSY		: Fail (ROT busy)
+*	    -EIO		: Fail (ROT error, or rotation is not completed)
+*	    -ERESTARTSYS	: Fail (device busy)
+* NOTE	 : none
+* CREATE   : 2006/10/05 M.Sasaki
+* UPDATE   : 2008/03/13 M.Sasaki
+******************************************************************************/
+static int mp200_rot_rotation(MP200_IPU_DEV_INFO *dev_info,
+	struct _ROTIO_ROTATION *p)
+{
+	struct mp200_ipu_req *pReq;
+	int ret;
+
+	/* make ROT data. */
+	if (mp200_rot_mkdata(p) == FALSE)
+		return -EINVAL;
+
+	if (dev_info->status != IPU_STATUS_NO_REQ)
+		return -EBUSY;
+
+	if (down_interruptible(&dev_info->sem)) {	/* get semafore */
+		return -ERESTARTSYS;
+	}
+
+	/* set ROT data to register. */
+	pReq = &dev_info->req;
+	mp200_rot_mkreq(pReq, 0);
+
+	/* set pointer to Device information into dev_info->req.data */
+	pReq->data = (unsigned long)dev_info;
+
+	/* set callback function into dev_info->req.callback */
+	pReq->callback = (void *)mp200_ipu_callback_rot;
+
+	/* set hw_func */
+	pReq->ipu_hw_func = IPU_HW_FUNC_ROT;
+
+	/* update status of IPU request process */
+	dev_info->status = IPU_STATUS_WAIT;	/* running */
+
+	ret = mp200_ipu_regist(pReq);		/* register request (reserve)*/
+	if (ret != IPU_REQ_REGISTERED) {
+		dev_info->status = IPU_STATUS_NO_REQ;	/* target request
+							   does not exist */
+		up(&dev_info->sem);			/* release semafore */
+		return ret;
+	}
+
+wait_rot:
+	dev_info->sleep_mode = TRUE;
+	/* wait until IPU process is completed */
+	wait_event_interruptible(dev_info->wait_que,
+	  (dev_info->status != IPU_STATUS_WAIT));
+	dev_info->sleep_mode = FALSE;
+
+	switch (dev_info->status) {
+	/* wake up by IPU_STATUS_DONE */
+	case IPU_STATUS_DONE:
+		switch (dev_info->req.status) {
+		case IPU_CALLBACK_SUCCESS:
+			ret = ROT_COMPLETE;
+			break;
+
+		case IPU_CALLBACK_IPU_ERROR:
+		case IPU_CALLBACK_IPU_STOP:
+			printk(KERN_INFO
+				" @ipu: ROTIO_ROTATION: ROT Error! "
+				"callback flag = %d\n", dev_info->req.status);
+			ret = -EIO;
+			break;
+
+		case IPU_CALLBACK_SET_PARAM:
+		case IPU_CALLBACK_CANCEL:
+		case IPU_CALLBACK_FAIL:
+		default:
+			printk(KERN_INFO
+				" @ipu: ROTIO_ROTATION: rotation is "
+				"not completed! callback flag = %d\n",
+				dev_info->req.status);
+			ret = -EIO;
+			break;
+		}
+		break;
+
+	case IPU_STATUS_CANCELLED: /* wake up by IPU_STATUS_CANCELLED */
+		printk(KERN_INFO
+			" @ipu: ROTIO_ROTATION: "
+			"rotation process is cancelled!\n");
+		ret = -EIO;
+		break;
+
+	case IPU_STATUS_WAIT:			   /* wake up by signal */
+	default:
+		printk(KERN_INFO
+			" @ipu: ROTIO_ROTATION: wake up by signal. "
+			"retry to wait until ROT process is completed\n");
+		goto wait_rot;
+		break;
+	}
+	/* update status of IPU request process */
+	dev_info->status = IPU_STATUS_NO_REQ;	/* target request
+						   does not exist */
+	up(&dev_info->sem);			/* release semafore */
+	return ret;
+}
+
+
+/*****************************************************************************
+* MODULE   : mp200_rot_mkreq
+* FUNCTION : make ROT request data
+* IMPORT   :
+* RETURN   :
+* NOTE	 : none
+* CREATE   : 2006/11/07 M.Sasaki
+* UPDATE   : 2008/03/13 M.Sasaki
+******************************************************************************/
+static int mp200_rot_mkreq(struct mp200_ipu_req *pReq, int index)
+{
+	int index_req = index;
+
+/*******************************
+	set ROT register
+********************************/
+	/*==============================
+	ROT_MODE
+	================================*/
+	RotRequest(rot_mode,		ROT_MODE);
+
+	/*==============================
+	image frame
+	================================*/
+	RotRequest(ROT_SRCSEL_FRAME_A | ROT_DSTSEL_FRAME_A, ROT_FRAME);
+
+
+	/*==============================
+	source image
+	================================*/
+	RotRequest(ulSrcPitch,		ROT_SRCSIZE);
+	RotRequest(ulSrcStarAddrY,	ROT_SRCYADR_A);
+	RotRequest(ulSrcStarAddrUV,	ROT_SRCUVADR_A);
+	RotRequest(ulSrcStarAddrV,	ROT_SRCVADR_A);
+	RotRequest(rot_src_width,	ROT_SRCHSIZE);
+	RotRequest(rot_src_height,	ROT_SRCVSIZE);
+
+	/*==============================
+	destination image
+	================================*/
+	RotRequest(ulDstPitch,		  ROT_DSTSIZE);
+	RotRequest(ulDstStarAddrY,	  ROT_DSTYADR_A);
+	RotRequest(ulDstStarAddrUV,	 ROT_DSTUVADR_A);
+	RotRequest(ulDstStarAddrV,	  ROT_DSTVADR_A);
+
+	/*==============================
+	format
+	================================*/
+	rot_format  = (rot_format_in  << ROT_SRCFMT_SFT);
+	rot_format |= (rot_format_out << ROT_DSTFMT_SFT);
+	RotRequest(rot_format,		  ROT_FORMAT);
+
+	/*==============================
+	bytelane
+	================================*/
+	RotRequest(in_bytelane,	 ROT_SRCBYTE);
+	RotRequest(out_bytelane,		ROT_DSTBYTE);
+
+	/*==============================
+	Start ROT
+	================================*/
+	RotRequest(ROT_REQ_BIT,	 ROT_REQ);
+
+	/*==============================
+	end mark
+	================================*/
+	RotRequest(IPU_REG_INFO_END,	-1);
+
+	return index_req;
+}
+
+
+/*****************************************************************************
+* MODULE   : mp200_rot_mkdata
+* FUNCTION : make ROT register data
+* IMPORT   : struct _ROTIO_ROTATION
+* RETURN   : TRUE  : check OK
+*	  : FALSE : check NG
+* NOTE	 : none
+* CREATE   : 2006/11/07 M.Sasaki
+* UPDATE   : 2008/03/13 M.Sasaki
+******************************************************************************/
+static int mp200_rot_mkdata(struct _ROTIO_ROTATION *p)
+{
+	int input_bpp, output_bpp;
+
+	rot_mode	   = ROT_NEWEN_BIT;
+
+	rot_format_in	= p->input_data_format;
+	rot_format_out   = p->output_data_format;
+
+	rot_src_width	= p->input_data_width;
+	rot_src_height   = p->input_data_height;
+	ulSrcStarAddrY   = p->input_data_addr_y;
+	ulSrcStarAddrUV  = p->input_data_addr_uv;
+	ulSrcStarAddrV   = p->input_data_addr_v;
+	ulDstStarAddrY   = p->output_data_addr_y;
+	ulDstStarAddrUV  = p->output_data_addr_uv;
+	ulDstStarAddrV   = p->output_data_addr_v;
+
+	in_bytelane	 = p->input_byte;
+	out_bytelane	= p->output_byte;
+
+/*====================*/
+/* Image Format check */
+/*====================*/
+	if ((rot_format_in != ROT_FORM_RGB888)
+		 && (rot_format_in != ROT_FORM_RGB565)
+		 && (rot_format_in != ROT_FORM_YUV420_PLANAR)
+		 && (rot_format_in != ROT_FORM_YUV420_SEMI_PLANAR)
+		 && (rot_format_in != ROT_FORM_YUV422_SEMI_PLANAR)
+		 && (rot_format_in != ROT_FORM_YUV422_INTERLEAVE)) {
+		printk(KERN_INFO
+			" @ipu: ROTIO_ROTATION: Error! "
+			"input_data_format is incorrect. "
+			"intput_data_format = 0x%lx\n", rot_format_in);
+	}
+
+	if ((rot_format_out != ROT_FORM_RGB888)
+		 && (rot_format_out != ROT_FORM_RGB565)
+		 && (rot_format_out != ROT_FORM_YUV420_PLANAR)
+		 && (rot_format_out != ROT_FORM_YUV420_SEMI_PLANAR)
+		 && (rot_format_out != ROT_FORM_YUV422_SEMI_PLANAR)
+		 && (rot_format_out != ROT_FORM_YUV422_INTERLEAVE)) {
+		printk(KERN_INFO
+			" @ipu: ROTIO_ROTATION: Error! "
+			"output_data_format is incorrect. "
+			"output_data_format = 0x%lx\n", rot_format_out);
+	}
+
+	if (rot_format_in == ROT_FORM_YUV422_SEMI_PLANAR) {
+		if ((rot_format_out != ROT_FORM_YUV422_SEMI_PLANAR) &&
+			(rot_format_out != ROT_FORM_YUV420_SEMI_PLANAR)) {
+			/* -- */
+			printk(KERN_INFO
+				" @ipu: ROTIO_ROTATION: Error! "
+				"input_data_format and output_data_format is "
+				"incorrect.\n intput_data_format = 0x%lx "
+				"output_data_format = 0x%lx\n",
+				rot_format_in, rot_format_out);
+		}
+	} else {
+		if (rot_format_in != rot_format_out) {
+			/* -- */
+			printk(KERN_INFO
+				" @ipu: ROTIO_ROTATION: Error! "
+				"input_data_format and output_data_format is "
+				"incorrect.\n intput_data_format = 0x%lx "
+				"output_data_format = 0x%lx\n",
+				rot_format_in, rot_format_out);
+		}
+	}
+
+/*===============*/
+/* Address check */
+/*===============*/
+	/* check input Y/RGB data start address by 4 byte */
+	if (ulSrcStarAddrY == 0 || (ulSrcStarAddrY & 0x3) != 0) {
+		printk(KERN_INFO
+			" @ipu: ROTIO_ROTATION: Error! "
+			"input_data_addr_y is incorrect. "
+			"input_data_addr_y = 0x%lx\n", ulSrcStarAddrY);
+		return FALSE;
+	}
+
+	/* check input UV data start address by 4 byte */
+	if ((rot_format_in == ROT_FORM_YUV420_PLANAR)
+		 || (rot_format_in == ROT_FORM_YUV420_SEMI_PLANAR)
+		 || (rot_format_in == ROT_FORM_YUV422_SEMI_PLANAR)) {
+		if (ulSrcStarAddrUV == 0 || (ulSrcStarAddrUV & 0x3) != 0) {
+			printk(KERN_INFO
+				" @ipu: ROTIO_ROTATION: Error! "
+				"input_data_addr_uv is incorrect. "
+				"input_data_addr_uv = 0x%lx\n",
+				ulSrcStarAddrUV);
+			return FALSE;
+		}
+	}
+
+	/* check input V data start address by 4 byte */
+	if ((rot_format_in == ROT_FORM_YUV420_PLANAR)) {
+		if (ulSrcStarAddrV == 0 || (ulSrcStarAddrV & 0x3) != 0) {
+			printk(KERN_INFO
+				" @ipu: ROTIO_ROTATION: Error! "
+				"input_data_addr_v is incorrect. "
+				"input_data_addr_v = 0x%lx\n",
+				ulSrcStarAddrV);
+			return FALSE;
+		}
+	}
+
+	/* check output Y/RGB data start address by 4 byte */
+	if (ulDstStarAddrY == 0 || (ulDstStarAddrY  & 0x3) != 0) {
+		printk(KERN_INFO
+			" @ipu: ROTIO_ROTATION: Error! "
+			"output_data_addr_y is incorrect. "
+			"output_data_addr_y = 0x%lx\n", ulDstStarAddrY);
+		return FALSE;
+	}
+
+	/* check output UV data start address by 4 byte */
+	if ((rot_format_out == ROT_FORM_YUV420_PLANAR)
+		 || (rot_format_out == ROT_FORM_YUV420_SEMI_PLANAR)
+		 || (rot_format_out == ROT_FORM_YUV422_SEMI_PLANAR)) {
+		if (ulDstStarAddrUV == 0 || (ulDstStarAddrUV  & 0x3) != 0) {
+			printk(KERN_INFO
+				" @ipu: ROTIO_ROTATION: Error! "
+				"output_data_addr_uv is incorrect. "
+				"output_data_addr_uv = 0x%lx\n",
+				ulDstStarAddrUV);
+			return FALSE;
+		}
+	}
+
+	/* check output V data start address by 4 byte */
+	if ((rot_format_out == ROT_FORM_YUV420_PLANAR)) {
+		if (ulDstStarAddrV == 0 || (ulDstStarAddrV & 0x3) != 0) {
+			printk(KERN_INFO
+				" @ipu: ROTIO_ROTATION: Error! "
+				"output_data_addr_v is incorrect. "
+				"output_data_addr_u = 0x%lx\n",
+				ulDstStarAddrV);
+			return FALSE;
+		}
+	}
+
+/*==================*/
+/* Image Size check */
+/*==================*/
+	/* source width check */
+	if (rot_src_width < 8 || rot_src_width > 4092)
+		goto fail_size_width;
+
+	if (rot_format_in == ROT_FORM_YUV420_PLANAR) {
+		if (rot_src_width & 0x7)
+			goto fail_size_width;
+
+	} else if (rot_format_in == ROT_FORM_YUV422_INTERLEAVE
+		 || rot_format_in == ROT_FORM_RGB565) {
+		if (rot_src_width & 0x1)
+			goto fail_size_width;
+
+	} else {
+		if (rot_src_width & 0x3)
+			goto fail_size_width;
+
+	}
+
+	/* source height check */
+	if (rot_src_height < 8 || rot_src_height > 4092)
+		goto fail_size_height;
+
+	if (rot_format_in == ROT_FORM_YUV420_PLANAR) {
+		if (rot_src_height & 0x7)
+			goto fail_size_height;
+
+	} else if (rot_format_in == ROT_FORM_YUV422_INTERLEAVE
+		 || rot_format_in == ROT_FORM_RGB565) {
+		if (rot_src_height & 0x1)
+			goto fail_size_height;
+
+	} else {
+		if (rot_src_height & 0x3)
+			goto fail_size_height;
+
+	}
+
+/*======================*/
+/* Rotation Angle check */
+/*======================*/
+	switch (p->rotation_angle) {
+	case ROT_ANGLE_0:
+		rot_mode |= ROT_MOD_0;
+		ulDstPitch = rot_src_width;
+		break;
+	case ROT_ANGLE_90:
+		rot_mode |= ROT_MOD_90;
+		ulDstPitch = rot_src_height;
+		break;
+	case ROT_ANGLE_180:
+		rot_mode |= ROT_MOD_180;
+		ulDstPitch = rot_src_width;
+		break;
+	case ROT_ANGLE_270:
+		rot_mode |= ROT_MOD_270;
+		ulDstPitch = rot_src_height;
+		break;
+	default:
+		printk(KERN_INFO
+			" @ipu: ROTIO_ROTATION: Error! "
+			"rotation_angle is incorrect. "
+			"rotation_angle = %d\n", p->rotation_angle);
+		return FALSE;
+		break;
+	}
+
+/*=============*/
+/* pitch check */
+/*=============*/
+	/* input image pitch */
+	if (rot_format_in == ROT_FORM_RGB888)
+		input_bpp = 3;
+	else if ((rot_format_in == ROT_FORM_RGB565)
+		 || (rot_format_in == ROT_FORM_YUV422_INTERLEAVE)) {
+		input_bpp = 2;
+	} else
+		input_bpp = 1;
+
+	ulSrcPitch = rot_src_width * input_bpp;
+
+	if (p->input_data_size < ulSrcPitch
+	  || p->input_data_size > MAX_ROT_SCREEN_WIDTH) {
+		printk(KERN_INFO
+			" @ipu: ROTIO_ROTATION: Error! "
+			"input_data_size is incorrect. "
+			"input_data_size = %d\n", p->input_data_size);
+		return FALSE;
+	}
+
+	if (rot_format_in == ROT_FORM_YUV420_PLANAR) {
+		if (p->input_data_size & 0x7) {
+			printk(KERN_INFO
+				" @ipu: ROTIO_ROTATION: Error! "
+				"input_data_size is incorrect."
+				"input_data_size = %d\n",
+				p->input_data_size);
+			return FALSE;
+		}
+	} else if (rot_format_in == ROT_FORM_RGB888) {
+		if (p->input_data_size % 0xC) {
+			printk(KERN_INFO
+				" @ipu: ROTIO_ROTATION: Error! "
+				"input_data_size is incorrect. "
+				"input_data_size = %d\n",
+				p->input_data_size);
+			return FALSE;
+		}
+	} else {
+		if (p->input_data_size & 0x3) {
+			printk(KERN_INFO
+				" @ipu: ROTIO_ROTATION: Error! "
+				"input_data_size is incorrect. "
+				"input_data_size = %d\n", p->input_data_size);
+			return FALSE;
+		}
+	}
+	ulSrcPitch = p->input_data_size;
+
+	/* output image pitch */
+	if (rot_format_out == ROT_FORM_RGB888)
+		output_bpp = 3;
+	else if ((rot_format_out == ROT_FORM_RGB565)
+		  || (rot_format_out == ROT_FORM_YUV422_INTERLEAVE)) {
+		output_bpp = 2;
+	} else
+		output_bpp = 1;
+
+	ulDstPitch *= output_bpp;
+
+	if (p->output_data_size < ulDstPitch
+	  || p->output_data_size > MAX_ROT_SCREEN_WIDTH) {
+		printk(KERN_INFO
+			" @ipu: ROTIO_ROTATION: Error! "
+			"output_data_size is incorrect. "
+			"output_data_size = %d\n", p->output_data_size);
+		return FALSE;
+	}
+	if (rot_format_out == ROT_FORM_YUV420_PLANAR) {
+		if (p->output_data_size & 0x7) {
+			printk(KERN_INFO
+				" @ipu: ROTIO_ROTATION: Error! "
+				"output_data_size is incorrect. "
+				"output_data_size = %d\n",
+				p->output_data_size);
+			return FALSE;
+		}
+	} else if (rot_format_out == ROT_FORM_RGB888) {
+		if (p->output_data_size % 0xC) {
+			printk(KERN_INFO
+				" @ipu: ROTIO_ROTATION: Error! "
+				"output_data_size is incorrect. "
+				"output_data_size = %d\n",
+				p->output_data_size);
+			return FALSE;
+		}
+	} else {
+		if (p->output_data_size & 0x3) {
+			printk(KERN_INFO
+				" @ipu: ROTIO_ROTATION: Error! "
+				"output_data_size is incorrect. "
+				"output_data_size = %d\n",
+				p->output_data_size);
+			return FALSE;
+		}
+	}
+	ulDstPitch = p->output_data_size;
+
+/*================*/
+/* Bytelane check */
+/*================*/
+	/* input_bytelane */
+	if ((in_bytelane & ROT_SRCBYTE_DATA0_BIT) ==
+	    ((in_bytelane & ROT_SRCBYTE_DATA1_BIT) >>
+	    ROT_SRCBYTE_DATA1_SFT) || (in_bytelane & ROT_SRCBYTE_DATA0_BIT) ==
+	    ((in_bytelane & ROT_SRCBYTE_DATA2_BIT) >> ROT_SRCBYTE_DATA2_SFT) ||
+	    (in_bytelane & ROT_SRCBYTE_DATA0_BIT) ==
+	    ((in_bytelane & ROT_SRCBYTE_DATA3_BIT) >> ROT_SRCBYTE_DATA3_SFT) ||
+	    ((in_bytelane & ROT_SRCBYTE_DATA1_BIT) >> ROT_SRCBYTE_DATA1_SFT) ==
+	    ((in_bytelane & ROT_SRCBYTE_DATA2_BIT) >> ROT_SRCBYTE_DATA2_SFT) ||
+	    ((in_bytelane & ROT_SRCBYTE_DATA1_BIT) >> ROT_SRCBYTE_DATA1_SFT) ==
+	    ((in_bytelane & ROT_SRCBYTE_DATA3_BIT) >> ROT_SRCBYTE_DATA3_SFT) ||
+	    ((in_bytelane & ROT_SRCBYTE_DATA2_BIT) >> ROT_SRCBYTE_DATA2_SFT) ==
+	    ((in_bytelane & ROT_SRCBYTE_DATA3_BIT) >> ROT_SRCBYTE_DATA3_SFT)) {
+		/* -- */
+		printk(KERN_INFO
+			" @ipu: ROTIO_ROTATION: Error! "
+			"input_byte is incorrect.\n");
+		printk(KERN_INFO " input_byte ROT_SRCBYTE_DATA0 = 0x%lx\n",
+		 (in_bytelane & ROT_SRCBYTE_DATA0_BIT));
+		printk(KERN_INFO " input_byte ROT_SRCBYTE_DATA1 = 0x%lx\n",
+		 (in_bytelane &
+			ROT_SRCBYTE_DATA1_BIT) >> ROT_SRCBYTE_DATA1_SFT);
+		printk(KERN_INFO " input_byte ROT_SRCBYTE_DATA2 = 0x%lx\n",
+		 (in_bytelane &
+			ROT_SRCBYTE_DATA2_BIT) >> ROT_SRCBYTE_DATA2_SFT);
+		printk(KERN_INFO " input_byte ROT_SRCBYTE_DATA3 = 0x%lx\n",
+		 (in_bytelane &
+			ROT_SRCBYTE_DATA3_BIT) >> ROT_SRCBYTE_DATA3_SFT);
+	   return FALSE;
+	}
+
+	/* output_bytelane */
+	if ((out_bytelane & ROT_DSTBYTE_DATA0_BIT) ==
+	    ((out_bytelane & ROT_DSTBYTE_DATA1_BIT) >> ROT_SRCBYTE_DATA1_SFT) ||
+	    (out_bytelane & ROT_DSTBYTE_DATA0_BIT) ==
+	    ((out_bytelane & ROT_DSTBYTE_DATA2_BIT) >> ROT_SRCBYTE_DATA2_SFT) ||
+	    (out_bytelane & ROT_DSTBYTE_DATA0_BIT) ==
+	    ((out_bytelane & ROT_DSTBYTE_DATA3_BIT) >> ROT_SRCBYTE_DATA3_SFT) ||
+	    ((out_bytelane & ROT_DSTBYTE_DATA1_BIT) >> ROT_SRCBYTE_DATA1_SFT) ==
+	    ((out_bytelane & ROT_DSTBYTE_DATA2_BIT) >> ROT_SRCBYTE_DATA2_SFT) ||
+	    ((out_bytelane & ROT_DSTBYTE_DATA1_BIT) >> ROT_SRCBYTE_DATA1_SFT) ==
+	    ((out_bytelane & ROT_DSTBYTE_DATA3_BIT) >> ROT_SRCBYTE_DATA3_SFT) ||
+	    ((out_bytelane & ROT_DSTBYTE_DATA2_BIT) >> ROT_SRCBYTE_DATA2_SFT) ==
+	    ((out_bytelane & ROT_DSTBYTE_DATA3_BIT) >> ROT_SRCBYTE_DATA3_SFT)) {
+		printk(KERN_INFO
+		" @ipu: ROTIO_ROTATION: Error! output_byte is incorrect.\n");
+		printk(KERN_INFO
+			" output_byte ROT_DSTBYTE_DATA0 = 0x%lx\n",
+			(out_bytelane & ROT_DSTBYTE_DATA0_BIT));
+		printk(KERN_INFO
+			" output_byte ROT_DSTBYTE_DATA1 = 0x%lx\n",
+			(out_bytelane &
+			ROT_DSTBYTE_DATA1_BIT) >> ROT_SRCBYTE_DATA1_SFT);
+		printk(KERN_INFO
+			" output_byte ROT_DSTBYTE_DATA2 = 0x%lx\n",
+			(out_bytelane &
+			ROT_DSTBYTE_DATA2_BIT) >> ROT_SRCBYTE_DATA2_SFT);
+		printk(KERN_INFO
+			" output_byte ROT_DSTBYTE_DATA3 = 0x%lx\n",
+			(out_bytelane &
+			ROT_DSTBYTE_DATA3_BIT) >> ROT_SRCBYTE_DATA3_SFT);
+	   return FALSE;
+	}
+
+	rot_mode |= (ROT_SRCENDIAN_LITTLE | ROT_DSTENDIAN_LITTLE);
+
+	return TRUE;
+
+fail_size_width:
+	printk(KERN_INFO
+		" @ipu: ROTIO_ROTATION: Error! "
+		"src_width is incorrect. src_width = 0x%lx\n",
+		rot_src_width);
+	return FALSE;
+
+fail_size_height:
+	printk(KERN_INFO
+		" @ipu: ROTIO_ROTATION: Error! "
+		"src_height is incorrect. src_height = 0x%lx\n",
+		rot_src_height);
+	return FALSE;
+}
+
+
+#endif /* _MP200_ROT_ROTATION_H_ */
+
-- 
1.6.5.2

