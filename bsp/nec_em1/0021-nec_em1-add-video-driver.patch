From 3ac78f49b9f13d236df66fb2d6f5aa4b89537f06 Mon Sep 17 00:00:00 2001
From: Kazuya Tsukamoto <kazuya.tsukamoto@necel.com>
Date: Mon, 9 Nov 2009 13:51:38 +0900
Subject: [PATCH 21/29] nec_em1: add video driver

Note the size that can be displayed when you change LCD
connected withthe EMMA Mobile 1 board and update the source
appropriately.

The setting of the LCD size and the FB use memory area
is defined by arch/arm/mach-mp200/include/mach/em1_mem.h .

The current setting assumes that LCD of WVGA(800x480) is connected.
In addition, there is header file for QVGA(em1_mem_qvga.h)
and WQVGA(em1_mem_wqvga.h).

Please rename it to em1_mem.h when you want to use these.

Signed-off-by: Kazuya Tsukamoto <kazuya.tsukamoto@necel.com>
---
 arch/arm/mach-mp200/include/mach/fbcommon.h |  137 ++
 drivers/video/Kconfig                       |    4 +
 drivers/video/Makefile                      |    1 +
 drivers/video/mp200/Kconfig                 |   40 +
 drivers/video/mp200/Makefile                |   12 +
 drivers/video/mp200/imc.h                   |  754 ++++++++
 drivers/video/mp200/lcdc.h                  |  324 ++++
 drivers/video/mp200/mp200_common.h          |  142 ++
 drivers/video/mp200/mp200_fb.c              | 2669 +++++++++++++++++++++++++++
 drivers/video/mp200/mp200_fb.h              |   50 +
 drivers/video/mp200/mp200_imc.c             | 1210 ++++++++++++
 drivers/video/mp200/mp200_imc.h             |  191 ++
 drivers/video/mp200/mp200_lcd.c             | 1470 +++++++++++++++
 drivers/video/mp200/mp200_lcd.h             |   76 +
 drivers/video/mp200/mp200_lcd_common.h      |   84 +
 drivers/video/mp200/mp200_lcdhw.c           | 1881 +++++++++++++++++++
 drivers/video/mp200/mp200_lcdhw.h           |   88 +
 drivers/video/mp200/nts/Kconfig             |   31 +
 drivers/video/mp200/nts/Makefile            |   11 +
 drivers/video/mp200/nts/adv7179.h           |  295 +++
 drivers/video/mp200/nts/mp200_adv7179.c     |  341 ++++
 drivers/video/mp200/nts/mp200_adv7179.h     |   40 +
 drivers/video/mp200/nts/mp200_nts.c         | 1456 +++++++++++++++
 drivers/video/mp200/nts/mp200_nts.h         |   55 +
 drivers/video/mp200/nts/mp200_nts_common.h  |  139 ++
 drivers/video/mp200/nts/mp200_ntshw.c       | 1009 ++++++++++
 drivers/video/mp200/nts/mp200_ntshw.h       |   77 +
 drivers/video/mp200/nts/mp200_ntsipu.c      | 1917 +++++++++++++++++++
 drivers/video/mp200/nts/mp200_ntsipu.h      |   59 +
 drivers/video/mp200/nts/ntsc.h              |  302 +++
 30 files changed, 14865 insertions(+), 0 deletions(-)
 create mode 100644 arch/arm/mach-mp200/include/mach/fbcommon.h
 create mode 100644 drivers/video/mp200/Kconfig
 create mode 100644 drivers/video/mp200/Makefile
 create mode 100644 drivers/video/mp200/imc.h
 create mode 100644 drivers/video/mp200/lcdc.h
 create mode 100644 drivers/video/mp200/mp200_common.h
 create mode 100644 drivers/video/mp200/mp200_fb.c
 create mode 100644 drivers/video/mp200/mp200_fb.h
 create mode 100644 drivers/video/mp200/mp200_imc.c
 create mode 100644 drivers/video/mp200/mp200_imc.h
 create mode 100644 drivers/video/mp200/mp200_lcd.c
 create mode 100644 drivers/video/mp200/mp200_lcd.h
 create mode 100644 drivers/video/mp200/mp200_lcd_common.h
 create mode 100644 drivers/video/mp200/mp200_lcd_perf.h
 create mode 100644 drivers/video/mp200/mp200_lcdhw.c
 create mode 100644 drivers/video/mp200/mp200_lcdhw.h
 create mode 100644 drivers/video/mp200/nts/Kconfig
 create mode 100644 drivers/video/mp200/nts/Makefile
 create mode 100644 drivers/video/mp200/nts/adv7179.h
 create mode 100644 drivers/video/mp200/nts/mp200_adv7179.c
 create mode 100644 drivers/video/mp200/nts/mp200_adv7179.h
 create mode 100644 drivers/video/mp200/nts/mp200_nts.c
 create mode 100644 drivers/video/mp200/nts/mp200_nts.h
 create mode 100644 drivers/video/mp200/nts/mp200_nts_common.h
 create mode 100644 drivers/video/mp200/nts/mp200_nts_debug.h
 create mode 100644 drivers/video/mp200/nts/mp200_ntshw.c
 create mode 100644 drivers/video/mp200/nts/mp200_ntshw.h
 create mode 100644 drivers/video/mp200/nts/mp200_ntsipu.c
 create mode 100644 drivers/video/mp200/nts/mp200_ntsipu.h
 create mode 100644 drivers/video/mp200/nts/ntsc.h

diff --git a/arch/arm/mach-mp200/include/mach/fbcommon.h b/arch/arm/mach-mp200/include/mach/fbcommon.h
new file mode 100644
index 0000000..6535552
--- /dev/null
+++ b/arch/arm/mach-mp200/include/mach/fbcommon.h
@@ -0,0 +1,137 @@
+/*
+ * File Name       : /include/asm-arm/arch-mp200/fbcommon.h
+ * Function        : Common parameters for Frame Buffer Driver
+ * Release Version :
+ * Release Date    : 2008.11.26
+ *
+ * Copyright (C) NEC Electronics Corporation 2005-2008
+ *
+ *
+ * This program is free software;you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by Free Softwere
+ * Foundation; either version 2 of License, or (at your option) any later
+ * version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warrnty of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
+ * details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; If not, write to the Free Software Foundation, Inc., 59 Temple
+ * Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#ifndef _FBCOMMON_H_
+#define _FBCOMMON_H_
+
+
+/********************************************************
+ * Include Files                                        *
+ *******************************************************/
+#include <linux/ioctl.h>
+#include <linux/types.h>
+
+
+/********************************************************
+ * Structures                                           *
+ *******************************************************/
+/* Image infomation (use I/F fb <-> 2D API) */
+struct scrn_modes {
+	int   tc_enable; /* enable(1)/disable(0) transparent color         */
+	int   t_color;	 /* transparent color (16bpp RGB565)               */
+	int   alpha;	 /* alpha ratio (0 - 255)                          */
+	int   page; /* 2D framebuffer page(0/1)                            */
+	int   rot; /* LCD image rotation(0/1=180deg.)                      */
+	int   update; /* absolutely update(1) / update only 2D mix mode(0) */
+		      /* when MP200_FB_SET_MODES ,this value is no effect  */
+};
+
+
+/* frame buffer page infomation (use I/F fb <-> 2D API) */
+struct scrn_mode{
+	int   timeout; /* waiting time for any frame ready(0) (10mS)          */
+	int   page0; /* page 0 is out of display(0)/waiting for on display(1) */
+	int   page1; /* page 1 is out of display(0)/waiting for on display(1) */
+};
+
+
+/* frame buffer update timer infomation (use I/F fb <-> 2D API) */
+struct update_timer{
+	int   timerflag;	/* auto update off(0) / auto update on(1) */
+	int   timeout;		/* timeout timer value */
+};
+
+
+/* frame buffer tv infomation (use I/F fb <-> 2D API) */
+enum EM1_TV_MODE{
+    EM1_TV_MODE_OFF,
+    EM1_TV_MODE_NTS,
+    EM1_TV_MODE_PAL
+};
+
+
+/********************************************************
+ *  Definitions                                         *
+ *******************************************************/
+/*
+ * scrn modes
+ */
+/* enable/disable transparent color */
+#define TC_COLOR_DISABLE	1
+#define TC_COLOR_ENABLE		0
+
+/* frame buffer page No. */
+#define DISP_BUFA		0
+#define DISP_BUFB		1
+#define NOT_DISP_ON_YET		2
+
+/* inverse mode */
+#define NO_INVERSE		0
+#define UDRL_INVERSE		1
+
+/* absolutely update flag status */
+#define UPDATE_FLAG_OFF		0
+#define UPDATE_FLAG_ON		1
+
+
+/*
+ * scrn mode
+ */
+/* frame buffer page status */
+#define OUT_OF_DISPLAY		0
+#define WAITING_FOR_ON_DISPLAY	1
+
+/* timeout */
+#define CHKSCRN_TIMEOUT		-1
+
+
+/* FB device number */
+#define EM1_FB_DEVICE_LCD	0
+#define EM1_FB_DEVICE_NTS	1
+
+/*
+ * IOCTLs to D77601 fb driver. 0x4E is 'N' for NEC.
+ */
+#define IOC_MP200_FB_MAGIC	('N')
+
+#define MP200_FB_CHKSCRN \
+	_IOR(IOC_MP200_FB_MAGIC, 0x00, struct scrn_mode)
+#define MP200_FB_UPDATE_SCRN \
+	_IOW(IOC_MP200_FB_MAGIC, 0x01, struct scrn_modes)
+#define MP200_FB_SET_MODES \
+	_IOW(IOC_MP200_FB_MAGIC, 0x02, struct scrn_modes)
+#define MP200_FB_GET_MODES \
+	_IOR(IOC_MP200_FB_MAGIC, 0x03, struct scrn_modes)
+#define MP200_FB_UPDATE_TIMER \
+	_IOR(IOC_MP200_FB_MAGIC, 0x04, struct update_timer)
+#ifdef CONFIG_FB_MP200_NTS
+#define MP200_FB_SET_OUTPUT \
+	_IOW(IOC_MP200_FB_MAGIC, 0x05, enum EM1_TV_MODE)
+#define MP200_FB_GET_OUTPUT \
+	_IOR(IOC_MP200_FB_MAGIC, 0x06, enum EM1_TV_MODE)
+#endif /* CONFIG_FB_MP200_NTS */
+
+
+#endif /* _FBCOMMON_H_ */
diff --git a/drivers/video/Kconfig b/drivers/video/Kconfig
index b1e6689..502d6f4 100644
--- a/drivers/video/Kconfig
+++ b/drivers/video/Kconfig
@@ -2046,6 +2046,10 @@ source "drivers/video/omap/Kconfig"
 source "drivers/video/backlight/Kconfig"
 source "drivers/video/display/Kconfig"
 
+source "drivers/video/mp200/Kconfig"
+
+source "drivers/video/mp200/nts/Kconfig"
+
 if VT
 	source "drivers/video/console/Kconfig"
 endif
diff --git a/drivers/video/Makefile b/drivers/video/Makefile
index a6b5529..d75cd26 100644
--- a/drivers/video/Makefile
+++ b/drivers/video/Makefile
@@ -131,6 +131,7 @@ obj-$(CONFIG_FB_VGA16)            += vga16fb.o
 obj-$(CONFIG_FB_OF)               += offb.o
 obj-$(CONFIG_FB_BF54X_LQ043)	  += bf54x-lq043fb.o
 obj-$(CONFIG_FB_BFIN_T350MCQB)	  += bfin-t350mcqb-fb.o
+obj-$(CONFIG_FB_MP200)            += mp200/ cfbcopyarea.o cfbfillrect.o cfbimgblt.o
 
 # the test framebuffer is last
 obj-$(CONFIG_FB_VIRTUAL)          += vfb.o
diff --git a/drivers/video/mp200/Kconfig b/drivers/video/mp200/Kconfig
new file mode 100644
index 0000000..efa6c23
--- /dev/null
+++ b/drivers/video/mp200/Kconfig
@@ -0,0 +1,40 @@
+#
+# MP200_fb driver configuration
+#
+
+menu "MP200 Video subsystem"
+        depends on FB && ARCH_MP200
+
+config MP200_VIDEO
+	bool "MP200 Video subsystem"
+        depends on FB && ARCH_MP200
+	default y
+        help
+          This is the Video subsystem for MP200 seriase boards.
+
+config FB_MP200
+	bool "MP200 FB support"
+        depends on MP200_VIDEO
+	default y
+        help
+          This is the frame buffer device driver for MP200 seriase boards.
+
+config MP200_LCD_RGB666
+        bool "MP200 LCD RGB666 support"
+        depends on FB_MP200
+        default y
+        help
+          This is the RGB666 display out for MP200 seriase boards.
+
+config MP200_IMC
+        bool "MP200 IMC support"
+        depends on FB_MP200
+        default y
+
+config FB_MP200_NTS
+	bool "MP200 NTSC FB-out support"
+        depends on FB_MP200 && MP200_NTS
+	default y
+        help
+          This is the TV out subsystem for MP200 seriase boards.
+endmenu
diff --git a/drivers/video/mp200/Makefile b/drivers/video/mp200/Makefile
new file mode 100644
index 0000000..dd80a0e
--- /dev/null
+++ b/drivers/video/mp200/Makefile
@@ -0,0 +1,12 @@
+#
+# Makefile for the MP200 framebuffer device driver
+#
+
+obj-$(CONFIG_FB_MP200)  += mp200_fb.o
+obj-$(CONFIG_FB_MP200)  += mp200_lcd.o
+obj-$(CONFIG_FB_MP200)  += mp200_lcdhw.o
+obj-$(CONFIG_FB_MP200)  += mp200_imc.o
+obj-$(CONFIG_MP200_NTS) += nts/
+
+mp200fb-objs := mp200_fblcd.o
+
diff --git a/drivers/video/mp200/imc.h b/drivers/video/mp200/imc.h
new file mode 100644
index 0000000..13bbb41
--- /dev/null
+++ b/drivers/video/mp200/imc.h
@@ -0,0 +1,754 @@
+/*
+ * File Name       : /drivers/video/mp200/imc.h
+ * Function        : IMC MMIO definitions
+ * Release Version : Ver 1.01
+ * Release Date    : 2009/10/21
+ *
+ * Copyright (C) NEC Electronics Corporation 2009
+ *
+ *
+ * This program is free software;you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by Free Softwere
+ * Foundation; either version 2 of License, or (at your option) any later
+ * version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warrnty of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
+ * details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; If not, write to the Free Software Foundation, Inc., 59 Temple
+ * Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#ifndef _IMC_H_
+#define _IMC_H_
+
+
+/*****************************************************************************
+ * IMC MMIO definitions
+ *****************************************************************************/
+
+#include <mach/hardware.h>
+#define IMC_OFFSET	MP200_IMC_OFFSET
+#define IMC_BASE	MP200_IMC_BASE
+#define IMC_SIZE	MP200_IMC_SIZE
+
+
+/*                                                         R/W   Bit  Reset */
+/*----------------------------------------------------------------------------
+ * Function Settings Register
+ */
+/* Control for IMC                                         R/W  31:0  0x0000 */
+#define IMC_CONTROL             (0x00)
+
+/* Update Reservation for IMC                              R/W   0:0  0x0000 */
+#define IMC_REFRESH             (0x04)
+
+/*----------------------------------------------------------------------------
+ * Synthetic Start Register
+ */
+/* Start to IMC                                            R/W   0:0  0x0000 */
+#define IMC_START               (0x10)
+
+/* Status for IMC                                           R    1:0  0x0000 */
+#define IMC_STATUS              (0x14)
+
+/* Double Buffer Control                                   R/W   0:0  0x0000 */
+#define IMC_CPUBUFSEL           (0x18)
+
+/*----------------------------------------------------------------------------
+ * Gamma Control Register
+ */
+/* Gamma Correction Control                                R/W   0:0  0x0000 */
+#define IMC_GAMMA_EN            (0x20)
+
+/* Gamma Control Table Address                             R/W   5:0  0x0000 */
+#define IMC_GAMMA_ADR           (0x24)
+
+/* Gamma Control Table Data                                R/W  21:0  0x0000 */
+#define IMC_GAMMA_DATA          (0x28)
+
+/*----------------------------------------------------------------------------
+ * Start Exclusive Use Immediately Setting Register
+ */
+/* Display Area Address                                    R/W  31:0  0x0000 */
+#define IMC_WB_AREADDR          (0x40)
+
+/* Address Increment Value                                 R/W  12:4  0x0000 */
+#define IMC_WB_HOFFSET          (0x44)
+
+/* Format                                                  R/W   0:0  0x0000 */
+#define IMC_WB_FORMAT           (0x48)
+
+/* Image Size                                              R/W  26:0  0x0000 */
+#define IMC_WB_SIZE             (0x4C)
+
+/*----------------------------------------------------------------------------
+ * All Layer Setting Register
+ */
+/* Horizontal, Vertical Mirroring Control                  R/W   1:0  0x0000 */
+#define IMC_MIRROR              (0x100)
+
+/* Y Gain Offset                                           R/W  15:0  0x0000 */
+#define IMC_YGAINOFFSET         (0x104)
+
+/* U Gain Offset                                           R/W  15:0  0x0000 */
+#define IMC_UGAINOFFSET         (0x108)
+
+/* V Gain Offset                                           R/W  15:0  0x0000 */
+#define IMC_VGAINOFFSET         (0x10C)
+
+/* YUV to RGB Conversion method                            R/W   8:0  0x0000 */
+#define IMC_YUV2RGB             (0x110)
+
+/* Custom factor (Coef R0)                                 R/W  10:0  0x0000 */
+#define IMC_COEF_R0             (0x114)
+
+/* Custom factor (Coef R1)                                 R/W  10:0  0x0000 */
+#define IMC_COEF_R1             (0x118)
+
+/* Custom factor (Coef R2)                                 R/W  10:0  0x0000 */
+#define IMC_COEF_R2             (0x11C)
+
+/* Custom factor (Coef R3)                                 R/W  10:0  0x0000 */
+#define IMC_COEF_R3             (0x120)
+
+/* Custom factor (Coef G0)                                 R/W  10:0  0x0000 */
+#define IMC_COEF_G0             (0x124)
+
+/* Custom factor (Coef G1)                                 R/W  10:0  0x0000 */
+#define IMC_COEF_G1             (0x128)
+
+/* Custom factor (Coef G2)                                 R/W  10:0  0x0000 */
+#define IMC_COEF_G2             (0x12C)
+
+/* Custom factor (Coef G3)                                 R/W  10:0  0x0000 */
+#define IMC_COEF_G3             (0x130)
+
+/* Custom factor (Coef B0)                                 R/W  10:0  0x0000 */
+#define IMC_COEF_B0             (0x134)
+
+/* Custom factor (Coef B1)                                 R/W  10:0  0x0000 */
+#define IMC_COEF_B1             (0x138)
+
+/* Custom factor (Coef B2)                                 R/W  10:0  0x0000 */
+#define IMC_COEF_B2             (0x13C)
+
+/* Custom factor (Coef B3)                                 R/W  10:0  0x0000 */
+#define IMC_COEF_B3             (0x140)
+
+/*----------------------------------------------------------------------------
+ * Layer0 Setting Register
+ */
+/* Layer0 Control                                          R/W   0:0  0x0000 */
+#define IMC_L0_CONTROL          (0x200)
+
+/* Layer0 Format                                           R/W   0:0  0x0000 */
+#define IMC_L0_FORMAT           (0x204)
+
+/* Layer0 Color Key Control                                R/W   0:0  0x0000 */
+#define IMC_L0_KEYENABLE        (0x210)
+
+/* Layer0 Color Key                                        R/W  21:0  0x0000 */
+#define IMC_L0_KEYCOLOR         (0x214)
+
+/* Layer0 Alpha                                            R/W   8:0  0x0000 */
+#define IMC_L0_ALPHA            (0x218)
+
+/* Layer0 Resize                                           R/W   0:0  0x0000 */
+#define IMC_L0_RESIZE           (0x220)
+
+/* Layer0 Address increment value                          R/W   9:0  0x0000 */
+#define IMC_L0_OFFSET           (0x230)
+
+/* Layer0 Address                                          R/W  31:0  0x0000 */
+#define IMC_L0_FRAMEADR         (0x234)
+
+/* Layer0 LCD Out Positon                                  R/W  23:0  0x0000 */
+#define IMC_L0_POSITION         (0x250)
+
+/* Layer0 LCD Out Size                                     R/W   7:0  0x0000 */
+#define IMC_L0_SIZE             (0x254)
+
+/*----------------------------------------------------------------------------
+ * Layer1A Setting Register
+ */
+/* Layer1A Control                                         R/W   0:0  0x0000 */
+#define IMC_L1A_CONTROL         (0x300)
+
+/* Layer1X Format                                          R/W   0:0  0x0000 */
+#define IMC_L1X_FORMAT          (0x304)
+
+/* Layer1A Color Key Control                               R/W   0:0  0x0000 */
+#define IMC_L1A_KEYENABLE       (0x310)
+
+/* Layer1X Color Key                                       R/W  21:0  0x0000 */
+#define IMC_L1X_KEYCOLOR        (0x314)
+
+/* Layer1A Alpha                                           R/W   8:0  0x0000 */
+#define IMC_L1A_ALPHA           (0x318)
+
+/* Layer1X Resize                                          R/W   0:0  0x0000 */
+#define IMC_L1X_RESIZE          (0x320)
+
+/* Layer1X Address increment value                         R/W  10:0  0x0000 */
+#define IMC_L1X_OFFSET          (0x330)
+
+/* Layer1A Address                                         R/W  31:0  0x0000 */
+#define IMC_L1A_FRAMEADR        (0x334)
+
+/* Layer1A LCD Out Positon                                 R/W  26:0  0x0000 */
+#define IMC_L1A_POSITION        (0x350)
+
+/* Layer1A LCD Out Size                                    R/W   9:0  0x0000 */
+#define IMC_L1A_SIZE            (0x354)
+
+/*----------------------------------------------------------------------------
+ * Layer1B Setting Register
+ */
+/* Layer1B Control                                         R/W   0:0  0x0000 */
+#define IMC_L1B_CONTROL         (0x400)
+
+/* Layer1B Color Key Control                               R/W   0:0  0x0000 */
+#define IMC_L1B_KEYENABLE       (0x410)
+
+/* Layer1B Alpha                                           R/W   8:0  0x0000 */
+#define IMC_L1B_ALPHA           (0x418)
+
+/* Layer1B Address                                         R/W  31:0  0x0000 */
+#define IMC_L1B_FRAMEADR        (0x434)
+
+/* Layer1B LCD Out Positon                                 R/W  26:0  0x0000 */
+#define IMC_L1B_POSITION        (0x450)
+
+/* Layer1B LCD Out Size                                    R/W   9:0  0x0000 */
+#define IMC_L1B_SIZE            (0x454)
+
+/*----------------------------------------------------------------------------
+ * Layer1C Setting Register
+ */
+/* Layer1C Control                                         R/W   0:0  0x0000 */
+#define IMC_L1C_CONTROL         (0x500)
+
+/* Layer1C Color Key Control                               R/W   0:0  0x0000 */
+#define IMC_L1C_KEYENABLE       (0x510)
+
+/* Layer1C Alpha                                           R/W   8:0  0x0000 */
+#define IMC_L1C_ALPHA           (0x518)
+
+/* Layer1C Address                                         R/W  31:0  0x0000 */
+#define IMC_L1C_FRAMEADR        (0x534)
+
+/* Layer1C LCD Out Positon                                 R/W  26:0  0x0000 */
+#define IMC_L1C_POSITION        (0x550)
+
+/* Layer1C LCD Out Size                                    R/W   9:0  0x0000 */
+#define IMC_L1C_SIZE            (0x554)
+
+/*----------------------------------------------------------------------------
+ * Layer2A Setting Register
+ */
+/* Layer2A Control                                         R/W   0:0  0x0000 */
+#define IMC_L2A_CONTROL          (0x600)
+
+/* Layer2A Format                                          R/W   2:0  0x0000 */
+#define IMC_L2A_FORMAT           (0x604)
+
+/* Layer2A Double Buffer Control                           R/W   0:0  0x0000 */
+#define IMC_L2A_BUFSEL           (0x608)
+
+/* Layer2A Bytelane                                        R/W   0:0  0x0000 */
+#define IMC_L2A_BYTELANE         (0x60C)
+
+/* Layer2A Resize                                          R/W   0:0  0x0000 */
+#define IMC_L2A_RESIZE           (0x620)
+
+/* Layer2A Horizontal, Vertical Mirroring Control          R/W   0:0  0x0000 */
+#define IMC_L2A_MIRROR           (0x624)
+
+/* Layer2A Address increment value                         R/W  12:0  0x0000 */
+#define IMC_L2A_OFFSET           (0x630)
+
+/* Layer2A Address (YP)                                    R/W  31:0  0x0000 */
+#define IMC_L2A_FRAMEADR_YP      (0x634)
+
+/* Layer2A Address (UP)                                    R/W  31:0  0x0000 */
+#define IMC_L2A_FRAMEADR_UP      (0x638)
+
+/* Layer2A Address (VP)                                    R/W  31:0  0x0000 */
+#define IMC_L2A_FRAMEADR_VP      (0x63C)
+
+/* Layer2A Address (YQ)                                    R/W  31:0  0x0000 */
+#define IMC_L2A_FRAMEADR_YQ      (0x640)
+
+/* Layer2A Address (UQ)                                    R/W  31:0  0x0000 */
+#define IMC_L2A_FRAMEADR_UQ      (0x644)
+
+/* Layer2A Address (VQ)                                    R/W  31:0  0x0000 */
+#define IMC_L2A_FRAMEADR_VQ      (0x648)
+
+/* Layer2A LCD Out Positon                                 R/W  23:0  0x0000 */
+#define IMC_L2A_POSITION         (0x650)
+
+/* Layer2A LCD Out Size                                    R/W  10:0  0x0000 */
+#define IMC_L2A_SIZE             (0x654)
+
+/*----------------------------------------------------------------------------
+ * Layer2B Setting Register
+ */
+/* Layer2B Control                                         R/W   0:0  0x0000 */
+#define IMC_L2B_CONTROL          (0x700)
+
+/* Layer2B Format                                          R/W   2:0  0x0000 */
+#define IMC_L2B_FORMAT           (0x704)
+
+/* Layer2B Double Buffer Control                           R/W   0:0  0x0000 */
+#define IMC_L2B_BUFSEL           (0x708)
+
+/* Layer2B Bytelane                                        R/W   0:0  0x0000 */
+#define IMC_L2B_BYTELANE         (0x70C)
+
+/* Layer2B Resize                                          R/W   0:0  0x0000 */
+#define IMC_L2B_RESIZE           (0x720)
+
+/* Layer2B Horizontal, Vertical Mirroring Control          R/W   0:0  0x0000 */
+#define IMC_L2B_MIRROR           (0x724)
+
+/* Layer2B Address increment value                         R/W  12:0  0x0000 */
+#define IMC_L2B_OFFSET           (0x730)
+
+/* Layer2B Address (YP)                                    R/W  31:0  0x0000 */
+#define IMC_L2B_FRAMEADR_YP      (0x734)
+
+/* Layer2B Address (UP)                                    R/W  31:0  0x0000 */
+#define IMC_L2B_FRAMEADR_UP      (0x738)
+
+/* Layer2B Address (VP)                                    R/W  31:0  0x0000 */
+#define IMC_L2B_FRAMEADR_VP      (0x73C)
+
+/* Layer2B Address (YQ)                                    R/W  31:0  0x0000 */
+#define IMC_L2B_FRAMEADR_YQ      (0x740)
+
+/* Layer2B Address (UQ)                                    R/W  31:0  0x0000 */
+#define IMC_L2B_FRAMEADR_UQ      (0x744)
+
+/* Layer2B Address (VQ)                                    R/W  31:0  0x0000 */
+#define IMC_L2B_FRAMEADR_VQ      (0x748)
+
+/* Layer2B LCD Out Positon                                 R/W  23:0  0x0000 */
+#define IMC_L2B_POSITION         (0x750)
+
+/* Layer2B LCD Out Size                                    R/W  10:0  0x0000 */
+#define IMC_L2B_SIZE             (0x754)
+
+/*----------------------------------------------------------------------------
+ * LayerBG Setting Register
+ */
+/* LayerBG Format                                          R/W   2:0  0x0000 */
+#define IMC_BG_FORMAT            (0x804)
+
+/* LayerBG Resize                                          R/W   0:0  0x0000 */
+#define IMC_BG_RESIZE            (0x820)
+
+/* LayerBG Address increment value                         R/W  12:0  0x0000 */
+#define IMC_BG_OFFSET            (0x830)
+
+/* Layer2B Address (YP)                                    R/W  31:0  0x0000 */
+#define IMC_BG_FRAMEADR          (0x834)
+
+/*----------------------------------------------------------------------------
+ * Interuppt Setting Register
+ */
+/* Interuppt Status                                         R    4:0  0x0000 */
+#define IMC_INTSTATUS            (0x900)
+
+/* Interuppt Raw Status                                     R    4:0  0x0000 */
+#define IMC_INTRAWSTATUS         (0x904)
+
+/* Interuppt Enable Set                                    R/W   4:0  0x0000 */
+#define IMC_INTENSET             (0x908)
+
+/* Interuppt Enable Clear                                   W    4:0  0x0000 */
+#define IMC_INTENCLR             (0x90C)
+
+/* Interuppt FF Clear                                       W    4:0  0x0000 */
+#define IMC_INTFFCLR             (0x910)
+
+/* AHB(R) Error Address                                    R/W   1:0  0x0000 */
+#define IMC_ERRORADR_R           (0x914)
+
+/* AHB(W) Error Address                                    R/W   1:0  0x0000 */
+#define IMC_ERRORADR_W           (0x918)
+
+
+
+
+
+
+
+
+
+
+/*----------------------------------------------------------------------------
+ * Function Settings Register
+ */
+/*------------------------------*/
+/* IMC_CONTROL                  */
+/*------------------------------*/
+#define IMC_DBGMODE_BIT		0x80000000
+#define IMC_DBGMODE_SFT		0x1F
+
+#define IMC_CLKCNT_BIT		0x00001F00
+#define IMC_CLKCNT_SFT		0x08
+#define IMC_CLKCNT_FRONT_ON	0x0100
+#define IMC_CLKCNT_MIDDLE_ON	0x0200
+#define IMC_CLKCNT_Y2R_ON	0x0400
+#define IMC_CLKCNT_GAMMA_ON	0x0800
+#define IMC_CLKCNT_WB_ON	0x1000
+#define IMC_CLKCNT_ALL_ON \
+	(IMC_CLKCNT_Y2R_ON | IMC_CLKCNT_FRONT_ON | \
+	IMC_CLKCNT_MIDDLE_ON | IMC_CLKCNT_GAMMA_ON | IMC_CLKCNT_WB_ON)
+
+#define IMC_FORMAT_BIT		0x00000002
+#define IMC_FORMAT_SFT		0x01
+#define IMC_FORMAT_RGB565	0x02
+#define IMC_FORMAT_RGB666	0x00
+
+#define IMC_START_MODE_BIT	0x80000001
+#define IMC_START_MODE_SFT	0x00
+#define IMC_START_MODE_NOSYNC	0x01
+#define IMC_START_MODE_SYNCHRO	0x00
+
+
+/*------------------------------*/
+/* IMC_REFRESH                  */
+/*------------------------------*/
+#define IMC_UPDATE_BIT		0x00000001
+#define IMC_UPDATE_SFT		0x00
+
+#define IMC_UPDATE_ON		0x01
+#define IMC_UPDATE_OFF		0x00
+
+
+/*----------------------------------------------------------------------------
+ * Synthetic Start Register
+ */
+/*------------------------------*/
+/* IMC_START                    */
+/*------------------------------*/
+#define IMC_IMCSTART_BIT	0x00000001
+#define IMC_IMCSTART_SFT	0x00
+
+#define IMC_IMCSTART_ON		0x01
+#define IMC_IMCSTART_OFF	0x00
+
+/*------------------------------*/
+/* IMC_STATUS                   */
+/*------------------------------*/
+#define IMC_STATUS_BIT		0x00000003
+#define IMC_STATUS_SFT		0x00
+
+#define IMC_STATUS_SINGLE_WB	0x03
+#define IMC_STATUS_LCDOUT_WB	0x02
+#define IMC_STATUS_LCDOUT	0x01
+#define IMC_STATUS_STOP		0x00
+
+/*------------------------------*/
+/* IMC_CPUBUFSEL                */
+/*------------------------------*/
+
+/*----------------------------------------------------------------------------
+ * Gamma Control Register
+ */
+/*------------------------------*/
+/* IMC_GAMMA_EN                 */
+/*------------------------------*/
+#define IMC_GAMMAEN_BIT		0x00000001
+#define IMC_GAMMAEN_SFT		0x00
+
+#define IMC_GAMMAEN_ON		0x01
+#define IMC_GAMMAEN_OFF		0x00
+
+/*------------------------------*/
+/* IMC_GAMMA_ADR                */
+/*------------------------------*/
+#define IMC_GAMMA_ADR_BIT	0x0000002F
+#define IMC_GAMMA_ADR_SFT	0x00
+
+/*------------------------------*/
+/* IMC_GAMMA_DATA               */
+/*------------------------------*/
+#define IMC_GAMMA_RED_BIT	0x002F0000
+#define IMC_GAMMA_RED_SFT	0x10
+#define IMC_GAMMA_GREEN_BIT	0x00002F00
+#define IMC_GAMMA_GREEN_SFT	0x08
+#define IMC_GAMMA_BLUE_BIT	0x0000002F
+#define IMC_GAMMA_BLUE_SFT	0x00
+
+/*----------------------------------------------------------------------------
+ * Start Exclusive Use Immediately Setting Register
+ */
+/*------------------------------*/
+/* IMC_WB_AREADDR               */
+/*------------------------------*/
+#define IMC_WB_AREADDR_BIT	0xFFFFFFFFC
+#define IMC_WB_AREADDR_SFT	0x00
+
+/*------------------------------*/
+/* IMC_WB_HOFFSET               */
+/*------------------------------*/
+#define IMC_WB_HOFFSET_BIT	0x00001FFC
+#define IMC_WB_HOFFSET_SFT	0x00
+
+/*------------------------------*/
+/* IMC_WB_FORMAT                */
+/*------------------------------*/
+#define IMC_WB_FORMAT_BIT	0x00000001
+#define IMC_WB_FORMAT_SFT	0x00
+
+#define IMC_WB_FORMAT_RGB565	0x01
+#define IMC_WB_FORMAT_RGB666	0x00
+
+/*------------------------------*/
+/* IMC_WB_SIZE                  */
+/*------------------------------*/
+#define IMC_WB_VSIZE_BIT	0x07FF0000
+#define IMC_WB_VSIZE_SFT	0x10
+
+#define IMC_WB_HSIZE_BIT	0x000007FE
+#define IMC_WB_HSIZE_SFT	0x00
+
+
+/*----------------------------------------------------------------------------
+ * All Layer Setting Register
+ */
+/*------------------------------*/
+/* IMC_MIRROR                   */
+/*------------------------------*/
+#define IMC_MIRROR_BIT		0x00000003
+#define IMC_MIRROR_SFT		0x00
+
+#define IMC_MIRROR_LRUD		0x03
+#define IMC_MIRROR_UD		0x02
+#define IMC_MIRROR_LR		0x01
+#define IMC_MIRROR_OFF		0x00
+
+/*------------------------------*/
+/* IMC_Y/U/VGAINOFFSET          */
+/*------------------------------*/
+#define IMC_YUVGAIN_OFFSET_BIT	0x0000FF00
+#define IMC_YUVGAIN_OFFSET_SFT	0x10
+#define IMC_YUVGAIN_GAIN_BIT	0x000000FF
+#define IMC_YUVGAIN_GAIN_SFT	0x00
+
+/*------------------------------*/
+/* IMC_YUV2RGB                  */
+/*------------------------------*/
+#define IMC_DITHER_BIT		0x00000100
+#define IMC_DITHER_SFT		0x08
+
+#define IMC_DITHER_ON		0x01
+#define IMC_DITHER_OFF		0x00
+
+
+#define IMC_TRANS_MODE_BIT	0x00000003
+#define IMC_TRANS_MODE_SFT	0x00
+
+#define IMC_TRANS_MODE_CUSTOM2	0x03
+#define IMC_TRANS_MODE_CUSTOM1	0x02
+#define IMC_TRANS_MODE_BT709	0x01
+#define IMC_TRANS_MODE_BT601	0x00
+
+
+/*----------------------------------------------------------------------------
+ * LayerX Setting Register
+ */
+/*------------------------------*/
+/* IMC_L0/1A/1B/1C/2A/2B_CONTROL */
+/*------------------------------*/
+#define IMC_Lx_CONTROL_BIT	0x00000001
+#define IMC_Lx_CONTROL_SFT	0x00
+#define IMC_Lx_CONTROL_ON	0x01
+#define IMC_Lx_CONTROL_OFF	0x00
+
+/*------------------------------*/
+/* IMC_L0/1A/1B/1C/2A/2B_FORMAT */
+/*------------------------------*/
+#define IMC_L0_FORMAT_BIT	0x00000001
+#define IMC_L1x_FORMAT_BIT	0x00000001
+#define IMC_L2x_FORMAT_BIT	0x00000003
+#define IMC_Lx_FORMAT_SFT	0x00
+#define IMC_Lx_FORMAT_YUV420Pl	0x06
+#define IMC_Lx_FORMAT_YUV420Pl2	0x05
+#define IMC_Lx_FORMAT_YUV422Pl	0x04
+#define IMC_Lx_FORMAT_YUV422Pl2	0x03
+#define IMC_Lx_FORMAT_YUV422Px	0x02
+#define IMC_Lx_FORMAT_RGB565	0x01
+#define IMC_Lx_FORMAT_RGB666	0x00
+
+/*------------------------------*/
+/* IMC_BG_FORMAT                */
+/*------------------------------*/
+#define IMC_LBG_FORMAT_BIT	0x00000002
+#define IMC_LBG_FORMAT_SFT	0x00
+#define IMC_LBG_FORMAT_OPTIONAL	0x03
+#define IMC_LBG_FORMAT_BLACK	0x02
+#define IMC_LBG_FORMAT_RGB565	0x01
+#define IMC_LBG_FORMAT_RGB666	0x00
+
+/*------------------------------*/
+/* IMC_L0/1A/1B/1C_KEYENABLE    */
+/*------------------------------*/
+#define IMC_Lx_KEYEN_BIT	0x00000001
+#define IMC_Lx_KEYEN_SFT	0x00
+#define IMC_Lx_KEYEN_ENABLE	0x01
+#define IMC_Lx_KEYEN_DISABLE	0x00
+
+/*------------------------------*/
+/* IMC_L0/1X_KEYCOLOR           */
+/*------------------------------*/
+#define IMC_Lx_KEYR_BIT		0x002F0000
+#define IMC_Lx_KEYR_SFT		0x10
+#define IMC_Lx_KEYG_BIT		0x00002F00
+#define IMC_Lx_KEYG_SFT		0x08
+#define IMC_Lx_KEYB_BIT		0x0000002F
+#define IMC_Lx_KEYB_SFT		0x00
+
+/*------------------------------*/
+/* IMC_L0/1A/1B/1C_ALPHA        */
+/*------------------------------*/
+#define IMC_Lx_REVERSE_BIT		0x00000100
+#define IMC_Lx_REVERSE_SFT		0x08
+#define IMC_Lx_ALPHA_BIT		0x0000002F
+#define IMC_Lx_ALPHA_SFT		0x00
+#define IMC_Lx_ALPHA_OPAQUE		0x2F
+#define IMC_Lx_ALPHA_TRANSPARENT	0x00
+
+/*------------------------------*/
+/* IMC_L0/1X/2A/2B/BG_RESIZE    */
+/*------------------------------*/
+#define IMC_Lx_RESIZE_BIT	0x00000001
+#define IMC_Lx_RESIZE_SFT	0x00
+#define IMC_Lx_RESIZE_ENABLE	0x01
+#define IMC_Lx_RESIZE_DISABLE	0x00
+
+/*------------------------------*/
+/* IMC_L0/1X/2A/2B_POSITION     */
+/*------------------------------*/
+#define IMC_Lx_POSY_BIT		0x07FF0000
+#define IMC_Lx_POSY_SFT		0x10
+#define IMC_Lx_POSX_BIT		0x000007FF
+#define IMC_Lx_POSX_SFT		0x00
+
+/*------------------------------*/
+/* IMC_L0/1X/2A/2B_SIZE         */
+/*------------------------------*/
+#define IMC_L0_SIZEY_BIT	0x00FF0000
+#define IMC_L0_SIZEX_BIT	0x000000FF
+#define IMC_L1_SIZEY_BIT	0x07FF0000
+#define IMC_L1_SIZEX_BIT	0x000002FF
+#define IMC_L2_SIZEY_BIT	0x07FF0000
+#define IMC_L2_SIZEX_BIT	0x000002FF
+
+#define IMC_Lx_SIZEY_SFT	0x10
+#define IMC_Lx_SIZEX_SFT	0x00
+
+/*------------------------------*/
+/* IMC_L2A/2B_BYTELANE          */
+/*------------------------------*/
+#define IMC_L2x_BYTELANE_Y_BIT  0x0000FF00
+#define IMC_L2x_BYTELANE_Y_SFT  0x08
+#define IMC_L2x_BYTELANE_UV_BIT 0x000000FF
+#define IMC_L2x_BYTELANE_UV_SFT 0x00
+
+#define IMC_L2x_BYTELANE_422PX_YYUV 0xE400
+#define IMC_L2x_BYTELANE_422PX_YUYV 0xD800
+#define IMC_L2x_BYTELANE_INIT       0xE4E4
+
+/*------------------------------*/
+/* IMC_L2A/2B_MIRROR            */
+/*------------------------------*/
+#define IMC_L2x_MIRROR_BIT	0x00000003
+#define IMC_L2x_MIRROR_SFT	0x00
+
+#define IMC_L2x_MIRROR_LRUD	0x03
+#define IMC_L2x_MIRROR_UD	0x02
+#define IMC_L2x_MIRROR_LR	0x01
+#define IMC_L2x_MIRROR_OFF	0x00
+
+
+/*----------------------------------------------------------------------------
+ * Interuppt Control Register
+ */
+/*------------------------------*/
+/* IMC_INTSTATUS                */
+/*------------------------------*/
+#define IMC_AHBRERR_BIT		0x00000010
+#define IMC_AHBRERR_SFT		0x04
+#define IMC_AHBWERR_BIT		0x00000008
+#define IMC_AHBWERR_SFT		0x03
+#define IMC_WBEND_BIT		0x00000004
+#define IMC_WBEND_SFT		0x02
+#define IMC_OVERRUN_BIT		0x00000002
+#define IMC_OVERRUN_SFT		0x01
+#define IMC_REFRESH_BIT		0x00000001
+#define IMC_REFRESH_SFT		0x00
+
+/*------------------------------*/
+/* IMC_INTENSET                 */
+/*------------------------------*/
+#define IMC_AHBRERR_EN_BIT	0x00000010
+#define IMC_AHBRERR_EN_SFT	0x04
+#define IMC_AHBWERR_EN_BIT	0x00000008
+#define IMC_AHBWERR_EN_SFT	0x03
+#define IMC_WBEND_EN_BIT	0x00000004
+#define IMC_WBEND_EN_SFT	0x02
+#define IMC_OVERRUN_EN_BIT	0x00000002
+#define IMC_OVERRUN_EN_SFT	0x01
+#define IMC_REFRESH_EN_BIT	0x00000001
+#define IMC_REFRESH_EN_SFT	0x00
+
+#define IMC_INTENSET_ALL_BIT \
+	(IMC_AHBRERR_EN_BIT | IMC_AHBWERR_EN_BIT | \
+	IMC_WBEND_EN_BIT | IMC_OVERRUN_EN_BIT | IMC_REFRESH_EN_BIT)
+
+/*------------------------------*/
+/* IMC_INTENCLR                 */
+/*------------------------------*/
+#define IMC_AHBRERR_MASK_BIT	0x00000010
+#define IMC_AHBRERR_MASK_SFT	0x04
+#define IMC_AHBWERR_MASK_BIT	0x00000008
+#define IMC_AHBWERR_MASK_SFT	0x03
+#define IMC_WBEND_MASK_BIT	0x00000004
+#define IMC_WBEND_MASK_SFT	0x02
+#define IMC_OVERRUN_MASK_BIT	0x00000002
+#define IMC_OVERRUN_MASK_SFT	0x01
+#define IMC_REFRESH_MASK_BIT	0x00000001
+#define IMC_REFRESH_MASK_SFT	0x00
+
+#define IMC_INTENCLR_ALL_BIT \
+	(IMC_AHBRERR_MASK_BIT | IMC_AHBWERR_MASK_BIT | \
+	IMC_WBEND_MASK_BIT | IMC_OVERRUN_MASK_BIT | IMC_REFRESH_MASK_BIT)
+
+/*------------------------------*/
+/* IMC_INTFFCLR                 */
+/*------------------------------*/
+#define IMC_AHBRERR_CLR_BIT	0x00000010
+#define IMC_AHBRERR_CLR_SFT	0x04
+#define IMC_AHBWERR_CLR_BIT	0x00000008
+#define IMC_AHBWERR_CLR_SFT	0x03
+#define IMC_WBEND_CLR_BIT	0x00000004
+#define IMC_WBEND_CLR_SFT	0x02
+#define IMC_OVERRUN_CLR_BIT	0x00000002
+#define IMC_OVERRUN_CLR_SFT	0x01
+#define IMC_REFRESH_CLR_BIT	0x00000001
+#define IMC_REFRESH_CLR_SFT	0x00
+
+#define IMC_INTFFCLR_ALL_BIT \
+	(IMC_AHBRERR_CLR_BIT | IMC_AHBWERR_CLR_BIT | \
+	IMC_WBEND_CLR_BIT | IMC_OVERRUN_CLR_BIT | IMC_REFRESH_CLR_BIT)
+
+#endif /* _IMC_H_ */
diff --git a/drivers/video/mp200/lcdc.h b/drivers/video/mp200/lcdc.h
new file mode 100644
index 0000000..581939c
--- /dev/null
+++ b/drivers/video/mp200/lcdc.h
@@ -0,0 +1,324 @@
+/*
+ * File Name       : /drivers/video/mp200/lcdc.h
+ * Function        : LCDC MMIO definitions
+ * Release Version : Ver 1.01
+ * Release Date    : 2009/10/21
+ *
+ * Copyright (C) NEC Electronics Corporation 2009
+ *
+ *
+ * This program is free software;you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by Free Softwere
+ * Foundation; either version 2 of License, or (at your option) any later
+ * version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warrnty of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
+ * details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; If not, write to the Free Software Foundation, Inc., 59 Temple
+ * Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#ifndef _LCDC_H_
+#define _LCDC_H_
+
+
+/*****************************************************************************
+ * LCDC MMIO definitions
+ *****************************************************************************/
+
+#include <mach/hardware.h>
+#define LCDC_OFFSET	MP200_LCD_OFFSET
+#define LCDC_BASE	MP200_LCD_BASE
+#define LCDC_SIZE	MP200_LCD_SIZE
+
+
+/*                                                      R/W   Bit  Reset */
+/*----------------------------------------------------------------------------
+ * Function Settings Register
+ */
+/* Control for LCDC                                     R/W   4:0  0x00 */
+#define LCD_CONTROL             (0x00)
+
+/* QoS for LCDC Register                                R/W   8:0  0x000 */
+#define LCD_QOS                 (0x04)
+
+/* Data Request for LCDC Register                       R/W   2:0  0x0 */
+#define LCD_DATAREQ             (0x08)
+
+/*----------------------------------------------------------------------------
+ * Output Settings Register
+ */
+/* LCD Output                                           R/W   0:0  0x0 */
+#define LCD_LCDOUT              (0x10)
+
+/* Access Bus Select                                    R/W   2:0  0x0 */
+#define LCD_BUSSEL              (0x14)
+
+/* Status for LCDC                                       R   10:0  0x000 */
+#define LCD_STATUS              (0x18)
+
+/* LCD BackGround Color                                 R/W  21:0  0x0 */
+#define LCD_BACKCOLOR           (0x1C)
+
+/*----------------------------------------------------------------------------
+ * Frame Buffer Settings Register
+ */
+/* Input Format select                                  R/W   0:0  0x0 */
+#define LCD_IFORMAT             (0x28)
+
+/*----------------------------------------------------------------------------
+ * Output Settings Register
+ */
+/* Horizontal Synchronizing Signal Total Width          R/W  11:0  0x000 */
+#define LCD_HTOTAL              (0x30)
+
+/* Horizontal Display Area Width                        R/W  10:4  0x000 */
+#define LCD_HAREA               (0x34)
+
+/* Horizontal Synchronizing Signal Edge Point 1         R/W  11:0  0x000 */
+#define LCD_HEDGE1              (0x38)
+
+/* Horizontal Synchronizing Signal Edge Point 2         R/W  11:0  0x000 */
+#define LCD_HEDGE2              (0x3C)
+
+/* Vertical Synchronizing Signal Total Width            R/W  11:0  0x000 */
+#define LCD_VTOTAL              (0x40)
+
+/* Vertical Display Area Width                          R/W  10:0  0x000 */
+#define LCD_VAREA               (0x44)
+
+/* Vertical Synchronizing Signal Edge Point 1           R/W  11:0  0x000 */
+#define LCD_VEDGE1              (0x48)
+
+/* Vertical Synchronizing Signal Edge Point 2           R/W  11:0  0x000 */
+#define LCD_VEDGE2              (0x4C)
+
+/*----------------------------------------------------------------------------
+ * Interuppt Setting Register
+ */
+/* Interrupt Status                                      R    4:0  0x0 */
+#define LCD_INTSTATUS           (0x60)
+
+/* Interrupt Raw Status                                  R    4:0  0x0 */
+#define LCD_INTRAWSTATUS        (0x64)
+
+/* Interrupt Enable Set                                 R/W   4:0  0x0 */
+#define LCD_INTENSET            (0x68)
+
+/* Interrupt Enable Clear                                W    4:0  0x0 */
+#define LCD_INTENCLR            (0x6C)
+
+/* Interrupt Status Clear                                W    4:0  0x0 */
+#define LCD_INTFFCLR            (0x70)
+
+/* Interrupt for Framecount                             R/W  24:0  0x0000000 */
+#define LCD_FRAMECOUNT          (0x74)
+
+
+
+
+
+
+
+
+
+
+/*----------------------------------------------------------------------------
+ * Function Settings Register
+ */
+/*------------------------------*/
+/* LCD_CONTROL                  */
+/*------------------------------*/
+#define LCD_OFORMAT_BIT		0x00000010
+#define LCD_OFORMAT_SFT		0x04
+#define LCD_OFORMAT_RGB565	0x10
+#define LCD_OFORMAT_RGB666	0x00
+
+#define LCD_CLKPOL_BIT		0x00000008
+#define LCD_CLKPOL_SFT		0x03
+#define LCD_HPOL_BIT		0x00000004
+#define LCD_HPOL_SFT		0x02
+#define LCD_VPOL_BIT		0x00000002
+#define LCD_VPOL_SFT		0x01
+#define LCD_ENPOL_BIT		0x00000001
+#define LCD_ENPOL_SFT		0x00
+
+/*------------------------------*/
+/* LCD_QOS                      */
+/*------------------------------*/
+#define LCD_QOSEN_BIT		0x00000100
+#define LCD_QOSEN_SFT		0x08
+#define LCD_QOSEN_ENABLE	0x100
+#define LCD_QOSEN_DISABLE	0x000
+#define LCD_QOSVALUE_BIT	0x000000FF
+#define LCD_QOSVALUE_SFT	0x00
+
+/*------------------------------*/
+/* LCD_DATAREQ                  */
+/*------------------------------*/
+#define LCD_DATAREQ_BIT		0x00000007
+#define LCD_DATAREQ_SFT		0x00
+
+/*----------------------------------------------------------------------------
+ * Output Settings Register
+ */
+/*------------------------------*/
+/* LCD_LCDOUT                   */
+/*------------------------------*/
+#define LCD_LCDOUT_BIT		0x00000001
+#define LCD_LCDOUT_SFT		0x00
+#define LCD_LCDOUT_ENABLE	0x1
+#define LCD_LCDOUT_DISABLE	0x0
+
+/*------------------------------*/
+/* LCD_BUSSEL                   */
+/*------------------------------*/
+#define LCD_BUSSEL_BIT		0x00000007
+#define LCD_BUSSEL_SFT		0x00
+#define LCD_BUSSEL_BACKCOLOR	0x5
+#define LCD_BUSSEL_BLACK	0x4
+#define LCD_BUSSEL_WB_LOCAL	0x2
+#define LCD_BUSSEL_LOCAL	0x0
+
+/*------------------------------*/
+/* LCD_STATUS                   */
+/*------------------------------*/
+#define LCD_MODSTATUS_BIT	0x00000700
+#define LCD_MODSTATUS_SFT	0x08
+#define LCD_MODSTATUS_BACKCOLOR	0x0500
+#define LCD_MODSTATUS_BLACK	0x0400
+#define LCD_MODSTATUS_WB_LOCAL	0x0200
+#define LCD_MODSTATUS_LOCAL	0x0000
+
+#define LCD_STATUS_BIT		0x00000001
+#define LCD_STATUS_SFT		0x00
+#define LCD_STATUS_ON		0x01
+#define LCD_STATUS_OFF		0x00
+
+/*------------------------------*/
+/* LCD_BACKCOLOR                */
+/*------------------------------*/
+#define LCD_BGRED_BIT		0x003F0000
+#define LCD_BGRED_SFT		0x10
+#define LCD_BGGREEN_BIT		0x00003F00
+#define LCD_BGGREEN_SFT		0x08
+#define LCD_BGBLUE_BIT		0x0000003F
+#define LCD_BGBLUE_SFT		0x00
+
+/*----------------------------------------------------------------------------
+ * Frame Buffer Settings Register
+ */
+/*------------------------------*/
+/* LCD_IFORMAT                  */
+/*------------------------------*/
+#define LCD_IFORMAT_BIT		0x00000001
+#define LCD_IFORMAT_SFT		0x00
+#define LCD_IFORMAT_RGB565	0x1
+#define LCD_IFORMAT_RGB666	0x0
+
+/*----------------------------------------------------------------------------
+ * Interuppt Setting Register
+ */
+/*------------------------------*/
+/* LCD_INTSTATUS                */
+/*------------------------------*/
+#define LCD_WBTRACE_BIT		0x00000010
+#define LCD_WBTRACE_SFT		0x04
+#define LCD_FRMCOUNT_BIT	0x00000008
+#define LCD_FRMCOUNT_SFT	0x03
+#define LCD_LCDSTOP_BIT		0x00000004
+#define LCD_LCDSTOP_SFT		0x02
+#define LCD_UNDERRUN_BIT	0x00000002
+#define LCD_UNDERRUN_SFT	0x01
+#define LCD_LCDVS_BIT		0x00000001
+#define LCD_LCDVS_SFT		0x00
+
+/*------------------------------*/
+/* LCD_INTRAWSTATUS             */
+/*------------------------------*/
+#define LCD_WBTRACERAW_BIT	0x00000010
+#define LCD_WBTRACERAW_SFT	0x04
+#define LCD_FRMCOUNTRAW_BIT	0x00000008
+#define LCD_FRMCOUNTRAW_SFT	0x03
+#define LCD_LCDSTOPRAW_BIT	0x00000004
+#define LCD_LCDSTOPRAW_SFT	0x02
+#define LCD_UNDERRUNRAW_BIT	0x00000002
+#define LCD_UNDERRUNRAW_SFT	0x01
+#define LCD_LCDVSRAW_BIT	0x00000001
+#define LCD_LCDVSRAW_SFT	0x00
+
+/*------------------------------*/
+/* LCD_INTENSET                 */
+/*------------------------------*/
+#define LCD_WBTRACEEN_BIT	0x00000010
+#define LCD_WBTRACEEN_SFT	0x04
+#define LCD_FRMCOUNTEN_BIT	0x00000008
+#define LCD_FRMCOUNTEN_SFT	0x03
+#define LCD_LCDSTOPEN_BIT	0x00000004
+#define LCD_LCDSTOPEN_SFT	0x02
+#define LCD_UNDERRUNEN_BIT	0x00000002
+#define LCD_UNDERRUNEN_SFT	0x01
+#define LCD_LCDVSEN_BIT		0x00000001
+#define LCD_LCDVSEN_SFT		0x00
+
+#define LCD_INTENSET_ALL_BIT \
+	(LCD_WBTRACEEN_BIT | LCD_FRMCOUNTEN_BIT | \
+	LCD_LCDSTOPEN_BIT | LCD_UNDERRUNEN_BIT | LCD_LCDVSEN_BIT)
+
+/*------------------------------*/
+/* LCD_INTENCLR                 */
+/*------------------------------*/
+#define LCD_WBTRACEMASK_BIT	0x00000010
+#define LCD_WBTRACEMASK_SFT	0x04
+#define LCD_FRMCOUNTMASK_BIT	0x00000008
+#define LCD_FRMCOUNTMASK_SFT	0x03
+#define LCD_LCDSTOPMASK_BIT	0x00000004
+#define LCD_LCDSTOPMASK_SFT	0x02
+#define LCD_UNDERRUNMASK_BIT	0x00000002
+#define LCD_UNDERRUNMASK_SFT	0x01
+#define LCD_LCDVSMASK_BIT	0x00000001
+#define LCD_LCDVSMASK_SFT	0x00
+
+#define LCD_INTENCLR_ALL_BIT \
+	(LCD_WBTRACEMASK_BIT | LCD_FRMCOUNTMASK_BIT | \
+	LCD_LCDSTOPMASK_BIT | LCD_UNDERRUNMASK_BIT | LCD_LCDVSMASK_BIT)
+
+/*------------------------------*/
+/* LCD_INTFFCLR                 */
+/*------------------------------*/
+#define LCD_WBTRACECLR_BIT	0x00000010
+#define LCD_WBTRACECLR_SFT	0x04
+#define LCD_FRMCOUNTCLR_BIT	0x00000008
+#define LCD_FRMCOUNTCLR_SFT	0x03
+#define LCD_LCDSTOPCLR_BIT	0x00000004
+#define LCD_LCDSTOPCLR_SFT	0x02
+#define LCD_UNDERRUNCLR_BIT	0x00000002
+#define LCD_UNDERRUNCLR_SFT	0x01
+#define LCD_LCDVSCLR_BIT	0x00000001
+#define LCD_LCDVSCLR_SFT	0x00
+
+#define LCD_INTFFCLR_ALL_BIT \
+	(LCD_WBTRACECLR_BIT | LCD_FRMCOUNTCLR_BIT | \
+	LCD_LCDSTOPCLR_BIT | LCD_UNDERRUNCLR_BIT | LCD_LCDVSCLR_BIT)
+
+/*------------------------------*/
+/* LCD_FRAMECOUNT               */
+/*------------------------------*/
+#define LCD_FCCLR_BIT		0x01000000
+#define LCD_FCCLR_SFT		0x18
+#define LCD_FCEN_BIT		0x00010000
+#define LCD_FCEN_SFT		0x10
+#define LCD_ACTF_BIT		0x0000FF00
+#define LCD_ACTF_SFT		0x08
+#define LCD_INTF_BIT		0x000000FF
+#define LCD_INTF_SFT		0x00
+
+
+
+
+#endif /* _LCDC_H_ */
diff --git a/drivers/video/mp200/mp200_common.h b/drivers/video/mp200/mp200_common.h
new file mode 100644
index 0000000..0c5cb92
--- /dev/null
+++ b/drivers/video/mp200/mp200_common.h
@@ -0,0 +1,142 @@
+/*
+ * File Name       : /drivers/video/mp200/mp200_common.h
+ * Function        : Common parameters for LCD Driver
+ * Release Version :
+ * Release Date    :
+ *
+ * Copyright (C) NEC Electronics Corporation 2005
+ *
+ *
+ * This program is free software;you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by Free Softwere
+ * Foundation; either version 2 of License, or (at your option) any later
+ * version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warrnty of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
+ * details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; If not, write to the Free Software Foundation, Inc., 59 Temple
+ * Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#ifndef _MP200_COMMON_H_
+#define _MP200_COMMON_H_
+
+
+/********************************************************
+ *  Include Files                                       *
+ *******************************************************/
+#include <mach/img.h>
+#include <mach/fbcommon.h>
+
+
+/********************************************************
+ *  Definitions                                         *
+ *******************************************************/
+/* image infomation from V4L2 */
+/* YUV format */
+#define V4L2_FORMAT_YUV420Pl	IMG_FORMAT_YUV420_PLANAR
+#define V4L2_FORMAT_YUV420Pl2	IMG_FORMAT_YUV420_SEMI_PLANAR
+#define V4L2_FORMAT_YUV422Pl	IMG_FORMAT_YUV422_PLANAR
+#define V4L2_FORMAT_YUV422Pl2	IMG_FORMAT_YUV422_SEMI_PLANAR
+#define V4L2_FORMAT_YUV422Px	IMG_FORMAT_YUV422_INTERLEAVE
+/* endian */
+#define V4L2_BIG_ENDIAN		0
+#define V4L2_LITTLE_ENDIAN	1
+
+
+/* image infomation from fb driver */
+#define FB_MASK_COLOR_DISP_OFF	TC_COLOR_DISABLE
+#define FB_MASK_COLOR_DISP_ON	TC_COLOR_ENABLE
+
+
+/* mix_image_mode */
+#define ONLY_2D_MODE		0
+#define DSP_AND_2D_MODE		1
+
+
+/* fb data update ON/OFF */
+#define FB_UPDATE_OFF		0
+#define FB_UPDATE_ON		1
+#define FB_ABSOLUTERY_UPDATE	2
+
+
+/********************************************************
+ *  NTS Definitions                                     *
+ *******************************************************/
+/*     mp200_nts_reserve(int iActiveDevice, int iSetOutmode); */
+/*     ntshw_reserve(int iSetOutmode); */
+/* for iActiveDevice */
+#define NTS_NONACTIVE		0x00
+#define NTS_ACTIVE_FB		0x01
+#define NTS_ACTIVE_V4L2		0x02
+
+/* for iSetOutmode */
+#define NTS_OUTPUT_DISABLE	0
+#define NTS_OUTPUT_NTSC		1
+#define NTS_OUTPUT_PAL		2
+
+
+/********************************************************
+ *  Structure                                           *
+ *******************************************************/
+/* Image data (use I/F V4L2 -> LCD  or  fb -> LCD) */
+struct _IMAGE_DATA {
+	unsigned int  size;		/* address addition               */
+	unsigned long yrgbaddr;		/* Y  plane address               */
+	unsigned long uvaddr;		/* UV plane address               */
+	unsigned long vaddr;		/* V  plane address               */
+	unsigned int  x;		/* x start pixcel                 */
+	unsigned int  y;		/* y start pixcel                 */
+	unsigned int  hsize;		/* image width                    */
+	unsigned int  vsize;		/* image height                   */
+};
+#define IMAGE_DATA struct _IMAGE_DATA
+
+struct _SCREEN_DATA {
+	unsigned int  x;		/* x outputt pixcel               */
+	unsigned int  y;		/* y outputt pixcel               */
+	unsigned int  hsize;		/* output width                   */
+	unsigned int  vsize;		/* output height                  */
+};
+#define SCREEN_DATA struct _SCREEN_DATA
+
+
+struct _FRAME_DATA {
+	void *dev;			/* mp200_v4l2_device               */
+	void *buf;			/* videobuf_buffer                 */
+};
+#define FRAME_DATA struct _FRAME_DATA
+
+
+/* Image data from V4L2   (use I/F V4L2 -> LCD) */
+struct _V4L2_IMAGE_INFO {
+	IMAGE_DATA    image_data;	/* input  image data from v4l2     */
+	SCREEN_DATA   screen_data;	/* output image data to LCD/NTSC   */
+	FRAME_DATA    frame_data;	/* v4l2 data delivery              */
+	unsigned int  yuvfmt;		/* input image data format         */
+/*	unsigned long offsetx;	*/	/* offset x                        */
+/*	unsigned long offsety;	*/	/* offset y                        */
+	unsigned int  endian;		/* endian type                     */
+};
+#define V4L2_IMAGE_INFO struct _V4L2_IMAGE_INFO
+
+
+/* Image data from fb driver  (use I/F fb -> LCD) */
+struct _FB_IMAGE_INFO {
+	IMAGE_DATA    image_data;	/* input image data from fb driver */
+	unsigned int  maskcolr;		/* maskcolor                       */
+	unsigned int  maskcolrflg;	/* maskcolor flag                  */
+	unsigned int  alpha;		/* alpha                           */
+	unsigned int  invflg;		/* inverse mode flag               */
+	unsigned int  mix_buf_page;	/* mix 2D buffer frame page        */
+	unsigned int  update_flag;	/* update flag ON/Off              */
+};
+#define FB_IMAGE_INFO struct _FB_IMAGE_INFO
+
+
+#endif /* _MP200_COMMON_H_ */
diff --git a/drivers/video/mp200/mp200_fb.c b/drivers/video/mp200/mp200_fb.c
new file mode 100644
index 0000000..f212a3d
--- /dev/null
+++ b/drivers/video/mp200/mp200_fb.c
@@ -0,0 +1,2669 @@
+/*
+ * File Name       : /drivers/video/mp200/mp200_fb.c
+ * Function        : FraemBuffer Driver corresponding to V4L2
+ * Release Version :
+ * Release Date    : 2009.10.21
+ *
+ * Copyright (C) NEC Electronics Corporation 2009
+ *
+ *
+ * This program is free software;you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by Free Softwere
+ * Foundation; either version 2 of License, or (at your option) any later
+ * version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warrnty of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
+ * details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; If not, write to the Free Software Foundation, Inc., 59 Temple
+ * Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+/*
+ *
+ *  framebuffer driver for D77601 -- based on vfb.c
+ *
+ */
+
+/*
+ *  linux/drivers/video/vfb.c -- Virtual frame buffer device
+ *
+ *      Copyright (C) 2002 James Simmons
+ *
+ *	Copyright (C) 1997 Geert Uytterhoeven
+ *
+ *  This file is subject to the terms and conditions of the GNU General Public
+ *  License. See the file COPYING in the main directory of this archive for
+ *  more details.
+ */
+
+
+/********************************************************
+ *  Include Files                                       *
+ *******************************************************/
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/version.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/tty.h>
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/fb.h>
+#include <linux/init.h>
+#include <linux/ioport.h>
+#include <linux/timer.h>
+#include <linux/sched.h>
+
+#include <linux/platform_device.h>
+#if defined(CONFIG_PM) || defined(CONFIG_DPM)
+#include <mach/pm.h>
+#endif /* CONFIG_PM || CONFIG_DPM */
+
+#include <linux/uaccess.h>
+#include <mach/hardware.h>
+#include <mach/irqs.h>
+#include <mach/em1_mem.h>
+#include <mach/fbcommon.h>
+
+#include "mp200_common.h"
+#include "mp200_fb.h"
+#include "mp200_imc.h"
+#include "mp200_lcd.h"
+#include "mp200_lcdhw.h"
+#include "nts/mp200_nts.h"
+
+
+
+/********************************************************
+ *  Definitions                                         *
+ *******************************************************/
+#define _DEBUG_FB 0x00 /* 00008421(bit) */
+		       /* 0x01: debug function in
+			* 0x02: debug function out
+			* 0x04: debug buffer
+			* 0x08: debug frame buffer status
+			* 0x10: debug update timer
+			*/
+
+#define TIMEOUT_MSLEEP	0
+
+
+/********************************************************
+ *  Definitions                                         *
+ *******************************************************/
+#define DEV_NAME "mp200_fb"
+
+
+/********************************************************
+ *  Macros                                              *
+ *******************************************************/
+#define printk_err(fmt, arg...) \
+	do {                     \
+		printk(KERN_ERR DEV_NAME ": %s: " fmt, __func__, ## arg); \
+	} while (0)
+
+#define printk_wrn(fmt, arg...) \
+	do {                     \
+		printk(KERN_WARNING DEV_NAME ": %s: " fmt, __func__, ## arg); \
+	} while (0)
+
+#define printk_info(fmt, arg...) \
+	do {                      \
+		printk(KERN_INFO DEV_NAME ": " fmt, ## arg); \
+	} while (0)
+
+#if _DEBUG_FB
+#define printk_dbg(level, fmt, arg...) \
+	do {                            \
+		if (level > 0) \
+			printk(KERN_DEBUG DEV_NAME ": %s: " fmt, \
+				__func__, ## arg); \
+	} while (0)
+#else
+#define printk_dbg(level, fmt, arg...) \
+	;
+#endif
+
+
+/********************************************************
+ *  Definitions                                         *
+ *******************************************************/
+/* init function */
+#define FB_INIT_ERROR__SMEM_NOT_RESERVE		-1
+#define FB_INIT_ERROR__SMEM_NOT_REMAP		-2
+#define FB_INIT_ERROR__FB_NOT_ALLOC		-3
+#define FB_INIT_ERROR__FB_CMAP_NOT_ALLOC	-4
+#define FB_INIT_ERROR__FB_NOT_REGIST		-5
+#define FB_INIT_ERROR__LCD_NOT_INITIALIZE	-6
+
+/* frame buffer page */
+#define FB_NO_A				0
+#define FB_NO_B				1
+
+/* frame buffer status */
+#define IS_NODATA			0
+#define NOW_WRITING_TO_FB		1
+#define ALREADY_DISPLAY			2
+#define ENABLE_WRITE			3
+
+/* timer */
+#define TIMER_OFF			0
+#define TIMER_ON			1
+#define TIMEOUT_TIME			60 /* (ms) */
+#define FB_TIMER_STOP			0
+#define FB_TIMER_START			1
+
+/* CHK_SCRN timer */
+#define RECHK_TIME			10  /* (ms) */
+
+/* timer default setting */
+#define DEFALT_UPDATE_TIMER_LCD		TIMER_OFF
+#ifdef CONFIG_FB_MP200_NTS
+#define DEFALT_UPDATE_TIMER_NTS		TIMER_ON
+#endif /* CONFIG_FB_MP200_NTS */
+
+/* mmap */
+#define MP200_FB_MMAP_MAX_SIZE	FB_FRAME_BUFFER_SIZE
+
+
+/* Number of FB devices */
+#ifdef CONFIG_FB_MP200_NTS
+#define EM1_FB_DEVICES			2
+#else	/* CONFIG_FB_MP200_NTS */
+#define EM1_FB_DEVICES			1
+#endif	/* CONFIG_FB_MP200_NTS */
+
+
+#if 0
+void ............Structure................() {}
+#endif
+/********************************************************
+ *  Structure                                           *
+ *******************************************************/
+/* image infomation from 2D API */
+struct fb_other_image_info {
+	int  iMaskColFlg;
+	int  iMaskCol;
+	int  iAlpha;
+	int  iInvFlg;
+	int  iPage;
+	int  iUpDate;
+};
+#define FB_OTHER_IMAGE_INFO struct fb_other_image_info
+
+/* image infomation from 2D API */
+struct _mp200_fb_par {
+	struct fb_info          *fb_inf;
+	atomic_t                 use_count;
+	struct semaphore         sem_fb_image_info;	/* semafore for
+							   fb_image_info */
+	struct semaphore         sem_fb_other_info_A;	/* semafore for
+							   fb_other_info_A */
+	struct semaphore         sem_fb_other_info_B;	/* semafore for
+							   fb_other_info_B */
+	struct semaphore         sem_tvmode;	/* semafore for tvmode */
+	spinlock_t               fb_lock;	/* spin lock fb timer flag */
+#if (TIMEOUT_MSLEEP == 0)
+	wait_queue_head_t        wait_fb_chk_scrn;
+#endif
+	struct workqueue_struct *mp200_fb_workqueue;
+	struct work_struct       wk_timeout_update_bottom_half;
+	u32                      pseudo_palette[256];
+	int                      devflag; /* 0 : /dev/fb0   1 : /dev/fb1  */
+};
+#define mp200_fb_par struct _mp200_fb_par
+
+/* screen infomation default data */
+static struct fb_var_screeninfo mp200_fb_default = {
+	.xres           = FRONT_WIDTH,
+	.yres           = FRONT_HEIGHT,
+	.xres_virtual   = FRONT_WIDTH_V,
+	.yres_virtual   = FRONT_HEIGHT_V,
+	.xoffset        = 0,
+	.yoffset        = 0,
+	.grayscale      = 0,
+	.bits_per_pixel = 16,
+	.red            = {11, 5, 0},
+	.green          = {5, 6, 0},
+	.blue           = {0, 5, 0},
+	.transp         = {0, 0, 0},
+	.activate       = 0,
+	.height         = -1,
+	.width          = -1,
+	.pixclock       = 0,
+	.left_margin    = 0,
+	.right_margin   = 0,
+	.upper_margin   = 0,
+	.lower_margin   = 0,
+	.hsync_len      = 24,
+	.vsync_len      = 4,
+	.sync           = FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
+	.vmode          = FB_VMODE_NONINTERLACED,
+};
+
+#ifdef CONFIG_FB_MP200_NTS
+/* screen  tv infomation default data */
+static struct fb_var_screeninfo mp200_fb_tv_default = {
+	.xres           = NTS_WIDTH,
+	.yres           = NTS_HEIGHT,
+	.xres_virtual   = NTS_WIDTH_V,
+	.yres_virtual   = NTS_HEIGHT_V,
+	.xoffset        = 0,
+	.yoffset        = 0,
+	.grayscale      = 0,
+	.bits_per_pixel = 16,
+	.red            = {11, 5, 0},
+	.green          = {5, 6, 0},
+	.blue           = {0, 5, 0},
+	.transp         = {0, 0, 0},
+	.activate       = 0,
+	.height         = -1,
+	.width          = -1,
+	.pixclock       = 0,
+	.left_margin    = 0,
+	.right_margin   = 0,
+	.upper_margin   = 0,
+	.lower_margin   = 0,
+	.hsync_len      = 24,
+	.vsync_len      = 4,
+	.sync           = FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
+	.vmode          = FB_VMODE_NONINTERLACED,
+};
+#endif /* CONFIG_FB_MP200_NTS */
+
+
+/* screen infomation fix data */
+static struct fb_fix_screeninfo mp200_fb_fix __initdata =
+{
+	.id        = "MP200 FB",
+	.type      = FB_TYPE_PACKED_PIXELS,
+	.visual    = FB_VISUAL_TRUECOLOR,
+	.xpanstep  = 1,
+	.ypanstep  = 1,
+	.ywrapstep = 1,
+	.accel     = FB_ACCEL_NONE,
+};
+
+struct mp200_fb_struct {
+	int                   is_first;
+	/* image infomation to LCD */
+	FB_IMAGE_INFO         fb_image_info;
+	/* frame buffer A */
+	FB_OTHER_IMAGE_INFO   fb_other_info_A;
+	/* frame buffer B */
+	FB_OTHER_IMAGE_INFO   fb_other_info_B;
+
+	/* Disp Buffer (2D) */
+	ulong   DispBufA;
+	ulong   DispBufB;
+	ulong   DispBufLength;
+	char   *DispBufBV;
+	char   *DispBufAV;
+
+	/* Timer */
+	struct timer_list     mp200_fb_timer;
+	int                   iTimeoutTime;
+	mp200_fb_par          *mp200_fb_dev;
+	/* flags */
+	int                   iFBStatus_A;
+	int                   iFBStatus_B;
+	int                   iNowDispPage;   /* now on display page */
+	int                   iNextDispPage;  /* next display page   */
+	int                   iMixModeFlg;
+	int                   iUpdateTimerFlag;
+	int                   iTimerStatusFlag;
+	int                   iDpmSuspendFlag;
+};
+#define MP200_FB_STRUCT struct mp200_fb_struct
+
+struct mp200_fb_drvdata {
+	struct fb_info *info[2];
+};
+#define MP200_FB_DRVDATA struct mp200_fb_drvdata
+
+#if 0
+void ............Variables................() {}
+#endif
+/********************************************************
+ *  Variables                                           *
+ *******************************************************/
+static MP200_FB_STRUCT    fb_data[2];
+static enum EM1_TV_MODE   tvmode;
+static MP200_FB_DRVDATA   drvdata;
+/* Smem */
+static  ulong             Smem       = SMEM_START;
+static  ulong             SmemLength = SMEM_LENGTH;
+	char             *SmemV;
+static  ulong             DispBufAllLength = MP200_FB_MMAP_MAX_SIZE;
+
+/********************************************************
+ *  Prototype declarations of local function            *
+ *******************************************************/
+static int mp200_fb_ioc_chk_scrn(struct fb_info *info, unsigned long arg);
+static int mp200_fb_ioc_get_modes(struct fb_info *info, unsigned long arg);
+static int mp200_fb_ioc_set_modes(struct fb_info *info, unsigned int cmd,
+ unsigned long arg);
+static int mp200_fb_ioc_update_scrn(struct fb_info *info, unsigned int cmd,
+ unsigned long arg);
+static int mp200_fb_ioc_update_timer(struct fb_info *info, unsigned long arg);
+#ifdef CONFIG_FB_MP200_NTS
+static int mp200_fb_ioc_set_output(struct fb_info *info, unsigned long arg);
+static int mp200_fb_ioc_get_output(struct fb_info *info, unsigned long arg);
+#endif /* CONFIG_FB_MP200_NTS */
+
+static int set_image_info_to_2DAPI(int iFBNo, struct scrn_modes *fb_scrn_modes,
+ struct fb_info *info);
+static int chk_fb_status(int iFBStatus);
+static int chk_input_modes(struct scrn_modes fb_scrn_modes);
+static int set_image_info_from_2DAPI(int iFBNo,
+	struct scrn_modes *fb_scrn_modes, struct fb_info *info);
+static int set_image_info_to_LCD(int iFBNo, struct fb_info *info);
+static int chk_input_update_timer(struct update_timer *fb_timer);
+#ifdef CONFIG_FB_MP200_NTS
+static void set_tv_size(enum EM1_TV_MODE mode, mp200_fb_par *par);
+static void set_tv_var(enum EM1_TV_MODE mode, mp200_fb_par *par);
+#endif /* CONFIG_FB_MP200_NTS */
+static int mp200_fb_open(struct fb_info *info, int user);
+static int mp200_fb_release(struct fb_info *info, int user);
+static  u_long get_line_length(int xres_virtual, int bpp);
+static int mp200_fb_check_var(struct fb_var_screeninfo *var,
+ struct fb_info *info);
+static int mp200_fb_set_par(struct fb_info *info);
+static int mp200_fb_setcolreg(u_int regno, u_int red, u_int green, u_int blue,
+ u_int transp, struct fb_info *info);
+static int mp200_fb_blank(int blank_mode, struct fb_info *info);
+static int mp200_fb_pan_display(struct fb_var_screeninfo *var,
+ struct fb_info *info);
+static int mp200_fb_remove(struct platform_device *device);
+static int  __init mp200_fb_probe(struct platform_device *device);
+static void __init mp200_fb_probe_error(int iErrorMode,
+ struct fb_info *info_0, struct fb_info *info_1, int fb_num);
+static void set_buffer_address(int fb_num);
+static void set_info(struct fb_info *info, mp200_fb_par **par, int fb_num);
+static void set_flag_init(int fb_num);
+static void set_val_init(struct fb_info *info, int fb_num);
+static void timer_init(struct fb_info *info);
+static void timeout_update(unsigned long data);
+#if defined(CONFIG_PM) || defined(CONFIG_DPM)
+static int mp200_fb_suspend(struct platform_device *dev, pm_message_t state);
+static int mp200_fb_suspend_sub(struct platform_device *dev,
+ pm_message_t state, int fb_num);
+static int mp200_fb_resume(struct platform_device *dev);
+static int mp200_fb_resume_sub(struct platform_device *dev, int fb_num);
+#endif /* CONFIG_PM || CONFIG_DPM */
+
+/* workqueue function */
+static void timeout_update_bottom_half_do(struct work_struct *num);
+
+
+/********************************************************
+ *  Function Structure                                  *
+ *******************************************************/
+/* fb ops */
+static struct fb_ops mp200_fb_ops = {
+	.owner          = THIS_MODULE,
+	.fb_open        = mp200_fb_open,
+	.fb_release     = mp200_fb_release,
+	.fb_check_var   = mp200_fb_check_var,
+	.fb_set_par     = mp200_fb_set_par,
+	.fb_setcolreg   = mp200_fb_setcolreg,
+	.fb_blank       = mp200_fb_blank,
+	.fb_pan_display = mp200_fb_pan_display,
+	.fb_fillrect    = cfb_fillrect,  /* fb common function */
+	.fb_copyarea    = cfb_copyarea,  /* fb common function */
+	.fb_imageblit   = cfb_imageblit, /* fb common function */
+#ifdef CONFIG_FRAMEBUFFER_CONSOLE
+	.fb_cursor      = soft_cursor,   /* fb common function */
+#endif /* CONFIG_FRAMEBUFFER_CONSOLE */
+	.fb_ioctl       = mp200_fb_ioctl,
+	.fb_mmap        = mp200_fb_mmap,
+};
+
+/* platform driver */
+static struct platform_driver mp200_fb_driver = {
+	.probe       = mp200_fb_probe,
+	.remove      = mp200_fb_remove,
+
+#if defined(CONFIG_PM) || defined(CONFIG_DPM)
+	.suspend     = mp200_fb_suspend,
+	.resume      = mp200_fb_resume,
+#endif /* CONFIG_PM || CONFIG_DPM */
+
+	.driver.name = DEV_NAME,
+	.driver.bus  = &platform_bus_type,
+};
+
+
+#if 0
+void ............ioctl................() {}
+#endif
+/********************************************************
+ *  Function Definitions                                *
+ *******************************************************/
+/******************************************************************************
+* MODULE   : mp200_fb_ioctl
+* FUNCTION : frame buffer driver ioctl
+* RETURN   :  0      : success
+*            -1      :
+*            -EFAULT :
+*            -EBUSY  :
+*            -ENXIO  :
+*            -ENOIOCTLCMD:
+* NOTE     : none
+* CREATE   : 2006.05.26 H.Nagashima
+* UPDATE   : 2008.11.25 J.Manabe
+******************************************************************************/
+int mp200_fb_ioctl(struct fb_info *info, unsigned int cmd, unsigned long arg)
+{
+	switch (cmd) {
+	case MP200_FB_CHKSCRN:
+		/* check frame buffer status        */
+		return mp200_fb_ioc_chk_scrn(info, arg);
+
+	case MP200_FB_GET_MODES:
+		/* get frame buffer infomation      */
+		return mp200_fb_ioc_get_modes(info, arg);
+
+	case MP200_FB_SET_MODES:
+		/* Set or Update frame buffer infomation   */
+		return mp200_fb_ioc_set_modes(info, cmd, arg);
+
+	case MP200_FB_UPDATE_SCRN:
+		return mp200_fb_ioc_update_scrn(info, cmd, arg);
+
+	case MP200_FB_UPDATE_TIMER:
+		/* update timer infomation          */
+		return mp200_fb_ioc_update_timer(info, arg);
+
+#ifdef CONFIG_FB_MP200_NTS
+	case MP200_FB_SET_OUTPUT:
+		return mp200_fb_ioc_set_output(info, arg);
+
+	case MP200_FB_GET_OUTPUT:
+		return mp200_fb_ioc_get_output(info, arg);
+#endif /* CONFIG_FB_MP200_NTS */
+
+	default:
+		printk_dbg((_DEBUG_FB & 0x01),
+		 "ioctl(*** unknown request ***)\n");
+		return -ENOIOCTLCMD;
+	}
+}
+
+
+/******************************************************************************
+* MODULE   : mp200_fb_ioc_chk_scrn
+* FUNCTION : frame buffer driver ioctl
+* RETURN   :  0      : success
+*            -EFAULT :
+* NOTE     : none
+* CREATE   : 2008.04.03 M.Haguro
+* UPDATE   : 2008.12.10 J.Manabe
+******************************************************************************/
+static int mp200_fb_ioc_chk_scrn(struct fb_info *info, unsigned long arg)
+{
+#if (TIMEOUT_MSLEEP == 0)
+	int             iWaitTime  = 0;
+	int             iTotalTime = 0;
+	struct scrn_mode FBScrnMode;
+	mp200_fb_par   *par  = (mp200_fb_par *)info->par;
+#else /* TIMEOUT_MSLEEP==1 */
+	int             iTotalTime = 0;
+	struct scrn_mode FBScrnMode;
+	struct timeval  tStartTime;
+	struct timeval  tNowTime;
+	mp200_fb_par   *par  = (mp200_fb_par *)info->par;
+
+	/* get start time */
+	do_gettimeofday(&tStartTime);
+#endif
+	printk_dbg((_DEBUG_FB & 0x01), "ioctl(CHKSCRN) <start>\n");
+
+	down(&par->sem_tvmode);
+	/* TVMODE Check */
+	if ((par->devflag == EM1_FB_DEVICE_NTS)
+	 && (tvmode == EM1_TV_MODE_OFF)) {
+		up(&par->sem_tvmode);
+		return -EIO;
+	}
+
+	/* get scrn mode info */
+	if (copy_from_user(&FBScrnMode,
+		(struct scrn_mode *) arg, sizeof(struct scrn_mode))) {
+		up(&par->sem_tvmode);
+		return -EFAULT;
+	}
+
+	/* check frame buffer status */
+	FBScrnMode.page0 = chk_fb_status(fb_data[par->devflag].iFBStatus_A);
+	FBScrnMode.page1 = chk_fb_status(fb_data[par->devflag].iFBStatus_B);
+
+	/* if arg->timeout=0, then break */
+	if (FBScrnMode.timeout <= 0) {
+		if (copy_to_user((struct scrn_mode *) arg,
+			&FBScrnMode, sizeof(struct scrn_mode))) {
+			up(&par->sem_tvmode);
+			return -EFAULT;
+		}
+		up(&par->sem_tvmode);
+		return 0;
+	}
+
+	/* if both A and B states are "WAITING_FOR_ON_DISPLAY", */
+	/*    then waits during the time specified by "timeout" */
+	if (FBScrnMode.page0 == WAITING_FOR_ON_DISPLAY
+	 && FBScrnMode.page1 == WAITING_FOR_ON_DISPLAY) {
+#if (TIMEOUT_MSLEEP == 0)
+		/* loop until timeout or enable write */
+		do {
+			/* timeout time (msec to jiffies) */
+			iWaitTime = (RECHK_TIME + 1000/HZ-1) / (1000/HZ);
+
+			wait_event_interruptible_timeout(par->wait_fb_chk_scrn,
+			((fb_data[par->devflag].iFBStatus_A == IS_NODATA) ||
+			(fb_data[par->devflag].iFBStatus_A == ENABLE_WRITE) ||
+			(fb_data[par->devflag].iFBStatus_B == IS_NODATA) ||
+			(fb_data[par->devflag].iFBStatus_B == ENABLE_WRITE)),
+			iWaitTime);
+
+			iTotalTime += RECHK_TIME;
+
+			/* re-check frame buffer status */
+			FBScrnMode.page0 =
+				chk_fb_status(
+					fb_data[par->devflag].iFBStatus_A);
+			FBScrnMode.page1 =
+				chk_fb_status(
+					fb_data[par->devflag].iFBStatus_B);
+
+			/* when over timeout time, return */
+			if (iTotalTime > FBScrnMode.timeout)
+				break;
+
+		} while (FBScrnMode.page0 == WAITING_FOR_ON_DISPLAY
+		 && FBScrnMode.page1 == WAITING_FOR_ON_DISPLAY);
+#else /* TIMEOUT_MSLEEP==1 */
+		/* loop until timeout or enable write */
+		do {
+			/* sleep 10ms */
+			msleep(RECHK_TIME);
+
+			/* get time */
+			do_gettimeofday(&tNowTime);
+			if (tNowTime.tv_sec > tStartTime.tv_sec) {
+				iTotalTime =
+					(tNowTime.tv_sec - tStartTime.tv_sec) *
+					1000;
+				if (tNowTime.tv_usec > tStartTime.tv_usec)
+					iTotalTime +=
+						(tNowTime.tv_usec -
+						tStartTime.tv_usec) / 1000;
+				else
+					iTotalTime -=
+						(tStartTime.tv_usec -
+						tNowTime.tv_usec) / 1000;
+
+			else
+				iTotalTime =
+					(tNowTime.tv_usec -
+					tStartTime.tv_usec) / 1000;
+
+			/* re-check frame buffer status */
+			FBScrnMode.page0 =
+				chk_fb_status(
+					fb_data[par->devflag].iFBStatus_A);
+			FBScrnMode.page1 =
+				chk_fb_status(
+					fb_data[par->devflag].iFBStatus_B);
+
+			/* when over timeout time, return */
+			if (iTotalTime > FBScrnMode.timeout)
+				break;
+
+		} while (FBScrnMode.page0 == WAITING_FOR_ON_DISPLAY
+		 && FBScrnMode.page1 == WAITING_FOR_ON_DISPLAY);
+#endif
+	}
+	printk_dbg((_DEBUG_FB & 0x08),
+		"ioctl(CHKSCRN): A(%d) B(%d)\n",
+		FBScrnMode.page0, FBScrnMode.page1);
+
+	/* return scrn mode info */
+	if (copy_to_user((struct scrn_mode *) arg,
+		&FBScrnMode, sizeof(struct scrn_mode))) {
+		up(&par->sem_tvmode);
+		return -EFAULT;
+	}
+	if (FBScrnMode.page0 == WAITING_FOR_ON_DISPLAY
+	 && FBScrnMode.page1 == WAITING_FOR_ON_DISPLAY) {
+		up(&par->sem_tvmode);
+		return FBScrnMode.timeout;
+	}
+
+	up(&par->sem_tvmode);
+
+	printk_dbg((_DEBUG_FB & 0x02), "ioctl(CHKSCRN) <end>\n");
+	return 0;
+}
+
+
+/******************************************************************************
+* MODULE   : mp200_fb_ioc_get_modes
+* FUNCTION : frame buffer driver ioctl
+* RETURN   :  0      : success
+*            -EFAULT :
+* NOTE     : none
+* CREATE   : 2008.04.03 M.Haguro
+* UPDATE   : 2008.12.10 J.Manabe
+******************************************************************************/
+static int mp200_fb_ioc_get_modes(struct fb_info *info, unsigned long arg)
+{
+	struct scrn_modes    FBScrnModes;
+	mp200_fb_par *par  = (mp200_fb_par *)info->par;
+
+	printk_dbg((_DEBUG_FB & 0x01), "ioctl(GET_MODES) <start>\n");
+
+	down(&par->sem_tvmode);
+	/* TVMODE Check */
+	if ((par->devflag == EM1_FB_DEVICE_NTS)
+	 && (tvmode == EM1_TV_MODE_OFF)) {
+		up(&par->sem_tvmode);
+		return -EIO;
+	}
+
+	/* set now on display infomation */
+	set_image_info_to_2DAPI(fb_data[par->devflag].iNowDispPage,
+	 &FBScrnModes, info);
+
+	/* copy to user scrn mode infomation */
+	if (copy_to_user((struct scrn_modes *) arg,
+		&FBScrnModes, sizeof(struct scrn_modes))) {
+		up(&par->sem_tvmode);
+		return -EFAULT;
+	}
+
+	up(&par->sem_tvmode);
+
+	printk_dbg((_DEBUG_FB & 0x02), "(ioctl(GET_MODES) <end>\n");
+	return 0;
+}
+
+
+/******************************************************************************
+* MODULE   : mp200_fb_ioc_set_modes
+* FUNCTION : frame buffer driver ioctl
+* RETURN   :  0      : success
+*            -1      :
+*            -EBUSY  :
+*            -ENXIO  :
+*            -EFAULT :
+* NOTE     : none
+* CREATE   : 2008.04.03 M.Haguro
+* UPDATE   :
+******************************************************************************/
+static int mp200_fb_ioc_set_modes(struct fb_info *info, unsigned int cmd,
+ unsigned long arg)
+{
+	return mp200_fb_ioc_update_scrn(info, cmd, arg);
+}
+
+
+/******************************************************************************
+* MODULE   : mp200_fb_ioc_update_scrn
+* FUNCTION : frame buffer driver ioctl
+* RETURN   :  0      : success
+*            -1      :
+*            -EBUSY  :
+*            -ENXIO  :
+*            -EFAULT :
+* NOTE     : none
+* CREATE   : 2008.04.03 M.Haguro
+* UPDATE   : 2008.12.10 J.Manabe
+******************************************************************************/
+static int mp200_fb_ioc_update_scrn(struct fb_info *info, unsigned int cmd,
+ unsigned long arg)
+{
+	struct scrn_modes    FBSrcnModes;
+	mp200_fb_par *par = (mp200_fb_par *)info->par;
+
+	printk_dbg((_DEBUG_FB & 0x01), "ioctl(UPDATE_SCRN) <start>\n");
+
+	down(&par->sem_tvmode);
+	/* TVMODE Check */
+	if ((par->devflag == EM1_FB_DEVICE_NTS)
+	 && (tvmode == EM1_TV_MODE_OFF)) {
+		up(&par->sem_tvmode);
+		return -EIO;
+	}
+	/* copy fb image info from 2D API */
+	if (copy_from_user(&FBSrcnModes, (struct scrn_modes *) arg,
+	 sizeof(struct scrn_modes))) {
+		up(&par->sem_tvmode);
+		return -EFAULT;
+	}
+
+	/* check fb image infomation from 2D API */
+	if (chk_input_modes(FBSrcnModes)) {
+		up(&par->sem_tvmode);
+		return -1;
+	}
+
+	down(&par->sem_fb_image_info);		/* lock fb_image_info */
+
+	/* set fb image infomation from 2D API */
+	set_image_info_from_2DAPI(FBSrcnModes.page, &FBSrcnModes, info);
+
+	/* set fb image infomaition to LCD */
+	set_image_info_to_LCD(FBSrcnModes.page, info);
+
+	fb_data[par->devflag].iNextDispPage = FBSrcnModes.page;
+
+	/* when cmd is MP200_FB_SET_MODES, set fb image update flag off */
+	if (cmd == MP200_FB_SET_MODES)
+		fb_data[par->devflag].fb_image_info.update_flag = FB_UPDATE_OFF;
+	else {
+		/* when cmd is MP200_FB_UPDATE_MODES,
+		   set fb image update flag on */
+		/* absolutely update data */
+		if (FBSrcnModes.update == UPDATE_FLAG_ON)
+			fb_data[par->devflag].fb_image_info.update_flag =
+				FB_ABSOLUTERY_UPDATE;
+		else {
+			/* when ONLY_2D_MODE, update data */
+			fb_data[par->devflag].fb_image_info.update_flag =
+				FB_UPDATE_ON;
+		}
+	}
+
+	/* set image infomation to LCD driver */
+	printk_dbg((_DEBUG_FB & 0x10), "ioctl(UPDATE_SCRN): request LCD\n");
+
+#ifdef CONFIG_FB_MP200_NTS
+	if (par->devflag == EM1_FB_DEVICE_LCD) {
+#endif /* CONFIG_FB_MP200_NTS */
+		printk_dbg((_DEBUG_FB & 0x02), "toLCD: PaddrYRGB(%lx)\n",
+		 fb_data[par->devflag].fb_image_info.image_data.yrgbaddr);
+		if (mp200_lcd_set_fb_image(
+			&fb_data[par->devflag].fb_image_info)) {
+			up(&par->sem_fb_image_info); /* unlock fb_image_info */
+			up(&par->sem_tvmode);
+			return -EBUSY;
+		}
+#ifdef CONFIG_FB_MP200_NTS
+	} else {
+		printk_dbg((_DEBUG_FB & 0x02), "toNTSC: PaddrYRGB(%lx)\n",
+		fb_data[par->devflag].fb_image_info.image_data.yrgbaddr);
+		if (mp200_nts_set_fb_image(
+			&fb_data[par->devflag].fb_image_info)) {
+			up(&par->sem_fb_image_info); /* unlock fb_image_info */
+			up(&par->sem_tvmode);
+			return -EBUSY;
+		}
+	}
+#endif /* CONFIG_FB_MP200_NTS */
+
+	up(&par->sem_fb_image_info);		/* unlock fb_image_info */
+
+	if (FBSrcnModes.page == DISP_BUFA)
+		info->screen_base =
+			(char __iomem *)fb_data[par->devflag].DispBufAV;
+	else
+		info->screen_base =
+			(char __iomem *)fb_data[par->devflag].DispBufBV;
+
+	up(&par->sem_tvmode);
+
+	printk_dbg((_DEBUG_FB & 0x02), "ioctl(UPDATE_SCRN) <end>\n");
+	return 0;
+}
+
+
+/******************************************************************************
+* MODULE   : mp200_fb_ioc_update_timer
+* FUNCTION : frame buffer driver ioctl
+* RETURN   :  0      : success
+*            -EFAULT :
+* NOTE     : none
+* CREATE   : 2008.04.03 M.Haguro
+* UPDATE   : 2008.12.10 J.Manabe
+******************************************************************************/
+static int mp200_fb_ioc_update_timer(struct fb_info *info, unsigned long arg)
+{
+	unsigned long flags;
+	struct update_timer   FbUpdateTimer;
+	mp200_fb_par *par = (mp200_fb_par *)info->par;
+
+	printk_dbg((_DEBUG_FB & 0x01), "ioctl(UPDATE_TIMER) <start>\n");
+
+	down(&par->sem_tvmode);
+	/* TVMODE Check */
+	if ((par->devflag == EM1_FB_DEVICE_NTS)
+	 && (tvmode == EM1_TV_MODE_OFF)) {
+		up(&par->sem_tvmode);
+		return -EIO;
+	}
+
+	/* copy from update timer info from 2D API */
+	if (copy_from_user(&FbUpdateTimer, (struct update_timer *) arg,
+	 sizeof(struct update_timer))) {
+		up(&par->sem_tvmode);
+		return -EFAULT;
+	}
+
+	/* fb timer stop */
+	spin_lock_irqsave(&fb_data[par->devflag].mp200_fb_dev->fb_lock, flags);
+	del_timer(&fb_data[par->devflag].mp200_fb_timer);
+	fb_data[par->devflag].iTimerStatusFlag = FB_TIMER_STOP;
+	spin_unlock_irqrestore(&fb_data[par->devflag].mp200_fb_dev->fb_lock,
+	 flags);
+
+	/* check input value */
+	if (chk_input_update_timer(&FbUpdateTimer)) {
+		up(&par->sem_tvmode);
+		return -1;
+	}
+
+	/* set update structure info */
+	fb_data[par->devflag].iUpdateTimerFlag = FbUpdateTimer.timerflag;
+	fb_data[par->devflag].iTimeoutTime     = FbUpdateTimer.timeout;
+
+	/* fb timer start */
+	if ((fb_data[par->devflag].iUpdateTimerFlag == TIMER_ON)
+	 && (fb_data[par->devflag].iMixModeFlg == ONLY_2D_MODE)) {
+		spin_lock_irqsave(
+			&fb_data[par->devflag].mp200_fb_dev->fb_lock, flags);
+		if (fb_data[par->devflag].iTimerStatusFlag == FB_TIMER_STOP) {
+			printk_dbg((_DEBUG_FB & 0x10),
+			 "ioctl(UPDATE_TIMER): add_timer\n");
+			fb_data[par->devflag].mp200_fb_timer.expires = jiffies
+			 + (fb_data[par->devflag].iTimeoutTime * HZ / 1000);
+			add_timer(&fb_data[par->devflag].mp200_fb_timer);
+			fb_data[par->devflag].iTimerStatusFlag = FB_TIMER_START;
+		}
+		spin_unlock_irqrestore(
+			&fb_data[par->devflag].mp200_fb_dev->fb_lock, flags);
+	}
+
+	up(&par->sem_tvmode);
+
+	printk_dbg((_DEBUG_FB & 0x02), "ioctl(UPDATE_TIMER) <end>\n");
+	return 0;
+}
+
+
+#ifdef CONFIG_FB_MP200_NTS
+/******************************************************************************
+* MODULE   : mp200_fb_ioc_set_output
+* FUNCTION : frame buffer driver ioctl
+* RETURN   :  0      : success
+*            -EINVAL : input value error
+*            -EIO    :
+* NOTE     : none
+* CREATE   : 2009.01.06 J.Manabe
+* UPDATE   :
+******************************************************************************/
+static int mp200_fb_ioc_set_output(struct fb_info *info, unsigned long arg)
+{
+	int ret = 0;
+	enum EM1_TV_MODE mode;
+	mp200_fb_par *par  = (mp200_fb_par *)info->par;
+
+	printk_dbg((_DEBUG_FB & 0x01), "<start>\n");
+
+	/* fb device check */
+	if (par->devflag != EM1_FB_DEVICE_NTS) {
+		printk_dbg((_DEBUG_FB & 0x01), "fb1 IF only!\n");
+		return -EIO;
+	}
+
+	/* copy fb image info from 2D API */
+	if (copy_from_user(&mode, (enum EM1_TV_MODE *) arg,
+		sizeof(enum EM1_TV_MODE)))
+		return -EFAULT;
+
+	down(&par->sem_tvmode);
+
+	/* MODE CHECK */
+	if ((mode != EM1_TV_MODE_OFF) &&
+		(mode != EM1_TV_MODE_NTS) &&
+		(mode != EM1_TV_MODE_PAL)) {
+		up(&par->sem_tvmode);
+		return -EINVAL;
+	}
+
+	/* ERROR CHECK */
+	if (tvmode == mode) {
+		up(&par->sem_tvmode);
+		return 0;
+	} else if ((tvmode == EM1_TV_MODE_NTS) && (mode == EM1_TV_MODE_PAL)) {
+		up(&par->sem_tvmode);
+		return -EIO;
+	} else if ((tvmode == EM1_TV_MODE_PAL) && (mode == EM1_TV_MODE_NTS)) {
+		up(&par->sem_tvmode);
+		return -EIO;
+	}
+
+	/* NTS SET */
+	if (mode == EM1_TV_MODE_OFF) {
+		fb_data[par->devflag].iFBStatus_A = IS_NODATA;
+		fb_data[par->devflag].iFBStatus_B = IS_NODATA;
+
+		del_timer(&fb_data[par->devflag].mp200_fb_timer);
+		fb_data[par->devflag].iTimerStatusFlag = FB_TIMER_STOP;
+
+		/* NTS SET(OFF) */
+		mp200_nts_release(NTS_ACTIVE_FB);
+	} else {
+		del_timer(&fb_data[par->devflag].mp200_fb_timer);
+		fb_data[par->devflag].iTimerStatusFlag = FB_TIMER_STOP;
+
+		/* NTS SET(NTS/PAL) */
+		ret = mp200_nts_reserve(NTS_ACTIVE_FB, (int)mode);
+		if (ret < 0) {
+			printk_dbg((_DEBUG_FB & 0x01),
+			 "nts_reserve err [%d]\n", ret);
+			up(&par->sem_tvmode);
+			return ret;
+		}
+
+		/* Set tv size */
+		set_tv_size(mode, par);
+
+		/* timer set */
+		if (fb_data[par->devflag].iMixModeFlg == ONLY_2D_MODE) {
+			if (fb_data[par->devflag].iUpdateTimerFlag ==
+				TIMER_ON) {
+				printk_dbg((_DEBUG_FB & 0x10), "add_timer()\n");
+				/* start timer interrupt */
+				add_timer(
+					&fb_data[par->devflag].mp200_fb_timer);
+				fb_data[par->devflag].iTimerStatusFlag =
+					FB_TIMER_START;
+			} else {
+				printk_dbg((_DEBUG_FB & 0x10),
+				 "queue_work()\n");
+				queue_work(par->mp200_fb_workqueue,
+				 &par->wk_timeout_update_bottom_half);
+			}
+		}
+	}
+	set_tv_var(mode, par);
+
+	/* set output mode */
+	tvmode = mode;
+	up(&par->sem_tvmode);
+
+	printk_dbg((_DEBUG_FB & 0x01), "< end >\n");
+	return 0;
+}
+
+
+/******************************************************************************
+* MODULE   : mp200_fb_ioc_get_output
+* FUNCTION : frame buffer driver ioctl
+* RETURN   :  0      : success
+*            -EFAULT :
+* NOTE     : none
+* CREATE   : 2008.12.25 J.Manabe
+* UPDATE   :
+******************************************************************************/
+static int mp200_fb_ioc_get_output(struct fb_info *info, unsigned long arg)
+{
+	enum EM1_TV_MODE mode;
+	mp200_fb_par *par = (mp200_fb_par *)info->par;
+	printk_dbg((_DEBUG_FB & 0x01), "<start>\n");
+
+	/* fb device check */
+	if (par->devflag != EM1_FB_DEVICE_NTS) {
+		printk_dbg((_DEBUG_FB & 0x01), "fb1 IF only!\n");
+		return -EIO;
+	}
+
+	down(&par->sem_tvmode);
+	mode = tvmode;
+	/* copy to user EM1_TV_MODE infomation */
+	if (copy_to_user((enum EM1_TV_MODE *) arg,
+		&mode, sizeof(enum EM1_TV_MODE))) {
+		up(&par->sem_tvmode);
+		return -EFAULT;
+	}
+	up(&par->sem_tvmode);
+
+	printk_dbg((_DEBUG_FB & 0x01), "< end >\n");
+	return 0;
+}
+#endif /* CONFIG_FB_MP200_NTS */
+
+
+#if 0
+void ............set_status................() {}
+#endif
+/******************************************************************************
+* MODULE   : set_image_info_to_2DAPI
+* FUNCTION : set other image infomation (frame bufferA/B) to 2D API
+* RETURN   : 0 : success
+* NOTE     : none
+* CREATE   : 2006.05.26 H.Nagashima
+* UPDATE   : 2008.11.14 J.Manabe
+******************************************************************************/
+static int set_image_info_to_2DAPI(int iFBNo, struct scrn_modes *fb_scrn_modes,
+			struct fb_info *info)
+{
+	mp200_fb_par *par = (mp200_fb_par *)info->par;
+
+	/* set fb A other image infomation */
+	if (iFBNo == FB_NO_A) {
+		down(&par->sem_fb_other_info_A); /* lock fb_other_info_A */
+		fb_scrn_modes->tc_enable =
+			fb_data[par->devflag].fb_other_info_A.iMaskColFlg;
+		fb_scrn_modes->t_color   =
+			fb_data[par->devflag].fb_other_info_A.iMaskCol;
+		fb_scrn_modes->alpha     =
+			fb_data[par->devflag].fb_other_info_A.iAlpha;
+		fb_scrn_modes->rot       =
+			fb_data[par->devflag].fb_other_info_A.iInvFlg;
+		fb_scrn_modes->page      =
+			fb_data[par->devflag].fb_other_info_A.iPage;
+		fb_scrn_modes->update    =
+			fb_data[par->devflag].fb_other_info_A.iUpDate;
+		up(&par->sem_fb_other_info_A);	/* unlock fb_other_info_A */
+	} else {
+	/* set fb B other image infomation */
+		down(&par->sem_fb_other_info_B); /* lock fb_other_info_B */
+		fb_scrn_modes->tc_enable =
+			fb_data[par->devflag].fb_other_info_B.iMaskColFlg;
+		fb_scrn_modes->t_color   =
+			fb_data[par->devflag].fb_other_info_B.iMaskCol;
+		fb_scrn_modes->alpha     =
+			fb_data[par->devflag].fb_other_info_B.iAlpha;
+		fb_scrn_modes->rot       =
+			fb_data[par->devflag].fb_other_info_B.iInvFlg;
+		fb_scrn_modes->page      =
+			fb_data[par->devflag].fb_other_info_B.iPage;
+		fb_scrn_modes->update    =
+			fb_data[par->devflag].fb_other_info_B.iUpDate;
+		up(&par->sem_fb_other_info_B);	/* unlock fb_other_info_B */
+	}
+	return 0;
+}
+
+
+/******************************************************************************
+* MODULE   : chk_fb_status
+* FUNCTION : check frame buffer (A/B) status
+* RETURN   : 0 : update enable
+*            1 : update disable
+* NOTE     : none
+* CREATE   : 2006.05.26 H.Nagashima
+* UPDATE   : 2008.11.14 J.Manabe
+******************************************************************************/
+static int chk_fb_status(int iFBStatus)
+{
+	int iRet;
+
+	/* check frame buffer status */
+	if (iFBStatus == IS_NODATA || iFBStatus == ENABLE_WRITE)
+		iRet = OUT_OF_DISPLAY;
+	else
+		iRet = WAITING_FOR_ON_DISPLAY;
+
+	return iRet;
+}
+
+
+/******************************************************************************
+* MODULE   : chk_input_modes
+* FUNCTION : check input scrn_modes value from 2D API
+* RETURN   : 0       : correct
+*            -EINVAL : incorrect
+* NOTE     : none
+* CREATE   : 2006.06.05 H.Nagashima
+* UPDATE   :
+******************************************************************************/
+static int chk_input_modes(struct scrn_modes fb_scrn_modes)
+{
+	/* check mask color flag */
+	if ((fb_scrn_modes.tc_enable != FB_MASK_COLOR_DISP_OFF)
+	 && (fb_scrn_modes.tc_enable != FB_MASK_COLOR_DISP_ON)) {
+		printk_wrn("mask color flag incorrect  tc_enable = %d\n",
+		 fb_scrn_modes.tc_enable);
+		return -EINVAL;
+	}
+
+	/* check mask color */
+	if ((fb_scrn_modes.t_color < 0x00)
+	 || (0xFFFF < fb_scrn_modes.t_color)) {
+		printk_wrn("mask color incorrect  t_color = %d\n",
+		 fb_scrn_modes.t_color);
+		return -EINVAL;
+	}
+
+	/* check alpha */
+	if ((fb_scrn_modes.alpha < 0x00) || (0xFF < fb_scrn_modes.alpha)) {
+		printk_wrn("alpha incorrect  alpha = %d\n",
+		 fb_scrn_modes.alpha);
+		return -EINVAL;
+	}
+
+	/* check rot */
+	if ((fb_scrn_modes.rot != NO_INVERSE)
+	 && (fb_scrn_modes.rot != UDRL_INVERSE)) {
+		printk_wrn("rot incorrect  rot = %d\n", fb_scrn_modes.rot);
+		return -EINVAL;
+	}
+
+	/* check page */
+	if ((fb_scrn_modes.page != FB_NO_A)
+	 && (fb_scrn_modes.page != FB_NO_B)) {
+		printk_wrn("page incorrect  page = %d\n", fb_scrn_modes.page);
+		return -EINVAL;
+	}
+
+	/* check update */
+	if ((fb_scrn_modes.update != UPDATE_FLAG_OFF)
+	 && (fb_scrn_modes.update != UPDATE_FLAG_ON)) {
+		printk_wrn("update incorrect  update = %d\n",
+		 fb_scrn_modes.update);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+
+/******************************************************************************
+* MODULE   : set_image_info_from_2DAPI
+* FUNCTION : set image infomation from LCD to fb local
+* RETURN   : 0 : success
+* NOTE     : none
+* CREATE   : 2006.05.26 H.Nagashima
+* UPDATE   :
+******************************************************************************/
+static int set_image_info_from_2DAPI(int iFBNo,
+	struct scrn_modes *fb_scrn_modes, struct fb_info *info)
+{
+	mp200_fb_par *par = (mp200_fb_par *)info->par;
+
+	/* set FB_A image infomation from 2D API */
+	if (iFBNo == FB_NO_A) {
+		fb_data[par->devflag].iFBStatus_A = NOW_WRITING_TO_FB;
+
+		down(&par->sem_fb_other_info_A);/* lock fb_other_info_A */
+		fb_data[par->devflag].fb_other_info_A.iMaskColFlg =
+			fb_scrn_modes->tc_enable;
+		fb_data[par->devflag].fb_other_info_A.iMaskCol    =
+			fb_scrn_modes->t_color;
+		fb_data[par->devflag].fb_other_info_A.iAlpha      =
+			fb_scrn_modes->alpha;
+		fb_data[par->devflag].fb_other_info_A.iInvFlg     =
+			fb_scrn_modes->rot;
+		fb_data[par->devflag].fb_other_info_A.iPage       =
+			fb_scrn_modes->page;
+		fb_data[par->devflag].fb_other_info_A.iUpDate     =
+			fb_scrn_modes->update;
+		up(&par->sem_fb_other_info_A);	/* unlock fb_other_info_A */
+	} else {
+	/* set FB_B image infomation from 2D API */
+		fb_data[par->devflag].iFBStatus_B = NOW_WRITING_TO_FB;
+
+		down(&par->sem_fb_other_info_B); /* lock fb_other_info_B */
+		fb_data[par->devflag].fb_other_info_B.iMaskColFlg =
+			fb_scrn_modes->tc_enable;
+		fb_data[par->devflag].fb_other_info_B.iMaskCol    =
+			fb_scrn_modes->t_color;
+		fb_data[par->devflag].fb_other_info_B.iAlpha      =
+			fb_scrn_modes->alpha;
+		fb_data[par->devflag].fb_other_info_B.iInvFlg     =
+			fb_scrn_modes->rot;
+		fb_data[par->devflag].fb_other_info_B.iPage       =
+			fb_scrn_modes->page;
+		fb_data[par->devflag].fb_other_info_B.iUpDate     =
+			fb_scrn_modes->update;
+		up(&par->sem_fb_other_info_B);	/* unlock fb_other_info_B */
+	}
+	printk_dbg((_DEBUG_FB & 0x08), "[> set_2DAPI:   A(%d) B(%d)\n",
+	 fb_data[par->devflag].iFBStatus_A, fb_data[par->devflag].iFBStatus_B);
+
+	return 0;
+}
+
+
+/******************************************************************************
+* MODULE   : set_image_info_to_LCD
+* FUNCTION : set image infomation to LCD
+* RETURN   : 0 : success
+* NOTE     : none
+* CREATE   : 2006.05.26 H.Nagashima
+* UPDATE   : 2008.11.14 J.Manabe
+******************************************************************************/
+static int set_image_info_to_LCD(int iFBNo, struct fb_info *info)
+{
+	mp200_fb_par *par = (mp200_fb_par *)info->par;
+
+	/* set fb A infomation */
+	if (iFBNo == DISP_BUFA) {
+		printk_dbg((_DEBUG_FB & 0x04), "DispBufA(%08lx)\n",
+		 fb_data[par->devflag].DispBufA);
+		fb_data[par->devflag].fb_image_info.image_data.yrgbaddr =
+			fb_data[par->devflag].DispBufA;
+
+		/* set other image infomation */
+		down(&par->sem_fb_other_info_A);/* lock fb_other_info_A */
+		fb_data[par->devflag].fb_image_info.maskcolr     =
+			fb_data[par->devflag].fb_other_info_A.iMaskCol;
+		fb_data[par->devflag].fb_image_info.maskcolrflg  =
+			fb_data[par->devflag].fb_other_info_A.iMaskColFlg;
+		fb_data[par->devflag].fb_image_info.alpha        =
+			fb_data[par->devflag].fb_other_info_A.iAlpha;
+		fb_data[par->devflag].fb_image_info.invflg       =
+			fb_data[par->devflag].fb_other_info_A.iInvFlg;
+		fb_data[par->devflag].fb_image_info.mix_buf_page =
+			fb_data[par->devflag].fb_other_info_A.iPage;
+		up(&par->sem_fb_other_info_A);	/* unlock fb_other_info_A */
+	} else {
+	/* set fb B infomation */
+		printk_dbg((_DEBUG_FB & 0x04), "DispBufB(%08lx)\n",
+			 fb_data[par->devflag].DispBufB);
+		fb_data[par->devflag].fb_image_info.image_data.yrgbaddr =
+			fb_data[par->devflag].DispBufB;
+
+		/* set other image infomation */
+		down(&par->sem_fb_other_info_B); /* lock fb_other_info_B */
+		fb_data[par->devflag].fb_image_info.maskcolr     =
+			fb_data[par->devflag].fb_other_info_B.iMaskCol;
+		fb_data[par->devflag].fb_image_info.maskcolrflg  =
+			fb_data[par->devflag].fb_other_info_B.iMaskColFlg;
+		fb_data[par->devflag].fb_image_info.alpha        =
+			fb_data[par->devflag].fb_other_info_B.iAlpha;
+		fb_data[par->devflag].fb_image_info.invflg       =
+			fb_data[par->devflag].fb_other_info_B.iInvFlg;
+		fb_data[par->devflag].fb_image_info.mix_buf_page =
+			fb_data[par->devflag].fb_other_info_B.iPage;
+		up(&par->sem_fb_other_info_B);	/* unlock fb_other_info_B */
+	}
+
+	return 0;
+}
+
+
+/******************************************************************************
+* MODULE   : chk_input_update_timer
+* FUNCTION : check update timer value from 2D API
+* RETURN   : 0       : success
+	   : -EINVAL : input value error
+* NOTE     : none
+* CREATE   : 2006.05.26 H.Nagashima
+* UPDATE   :
+******************************************************************************/
+static int chk_input_update_timer(struct update_timer *fb_timer)
+{
+	/* check update mode value */
+	if ((fb_timer->timerflag != TIMER_OFF)
+	 && (fb_timer->timerflag != TIMER_ON)) {
+		printk_wrn("timerflag value incorrect  timerflag = %d\n",
+		 fb_timer->timerflag);
+		return -EINVAL;
+	}
+
+	/* check update mode value */
+	if (fb_timer->timeout < 33) {
+		printk_wrn("timeout value incorrect  timeout = %d\n",
+		 fb_timer->timeout);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+
+#ifdef CONFIG_FB_MP200_NTS
+/******************************************************************************
+* MODULE   : set_tv_size
+* FUNCTION : tvmode change
+* RETURN   : 0 : success
+* NOTE     : none
+* CREATE   : 2008.12.04 J.Manabe
+* UPDATE   :
+******************************************************************************/
+static void set_tv_size(enum EM1_TV_MODE mode, mp200_fb_par *par)
+{
+	printk_dbg((_DEBUG_FB & 0x01), "<start>\n");
+
+	down(&par->sem_fb_image_info);
+
+	switch (mode) {
+	case EM1_TV_MODE_NTS:
+		fb_data[par->devflag].fb_image_info.image_data.hsize    =
+			NTSC_WIDTH;
+		fb_data[par->devflag].fb_image_info.image_data.vsize    =
+			NTSC_HEIGHT;
+		fb_data[par->devflag].fb_image_info.image_data.size     =
+			NTSC_WIDTH * BYTES_PER_PIXEL;
+		break;
+	case EM1_TV_MODE_PAL:
+		fb_data[par->devflag].fb_image_info.image_data.hsize    =
+			PAL_WIDTH;
+		fb_data[par->devflag].fb_image_info.image_data.vsize    =
+			PAL_HEIGHT;
+		fb_data[par->devflag].fb_image_info.image_data.size     =
+			 PAL_WIDTH * BYTES_PER_PIXEL;
+		break;
+	default:
+	/* EM1_TV_MODE_OFF */
+	break;
+	}
+
+	up(&par->sem_fb_image_info);
+
+	printk_dbg((_DEBUG_FB & 0x01), "< end >\n");
+}
+
+
+/******************************************************************************
+* MODULE   : set_tv_var
+* FUNCTION : tvmode change
+* RETURN   : 0 : success
+* NOTE     : none
+* CREATE   : 2009.1.19 M.haguro
+* UPDATE   :
+******************************************************************************/
+static void set_tv_var(enum EM1_TV_MODE mode, mp200_fb_par *par)
+{
+	printk_dbg((_DEBUG_FB & 0x01), "<start>\n");
+
+	down(&par->sem_fb_image_info);
+
+	switch (mode) {
+	case EM1_TV_MODE_NTS:
+		par->fb_inf->var = mp200_fb_tv_default;
+		par->fb_inf->var.xres         = NTSC_WIDTH;
+		par->fb_inf->var.yres         = NTSC_HEIGHT;
+		par->fb_inf->var.xres_virtual = NTS_WIDTH_V;
+		par->fb_inf->var.yres_virtual = NTS_HEIGHT_V;
+		par->fb_inf->var.bits_per_pixel = 16;
+		break;
+	case EM1_TV_MODE_PAL:
+		par->fb_inf->var = mp200_fb_tv_default;
+		par->fb_inf->var.xres         = PAL_WIDTH;
+		par->fb_inf->var.yres         = PAL_HEIGHT;
+		par->fb_inf->var.xres_virtual = NTS_WIDTH_V;
+		par->fb_inf->var.yres_virtual = NTS_HEIGHT_V;
+		par->fb_inf->var.bits_per_pixel = 16;
+		break;
+	default:
+		/* EM1_TV_MODE_OFF */
+		goto failed;
+	}
+	mp200_fb_set_par(par->fb_inf);
+
+failed:
+	up(&par->sem_fb_image_info);
+
+	printk_dbg((_DEBUG_FB & 0x01), "< end >\n");
+}
+#endif /* CONFIG_FB_MP200_NTS */
+
+
+
+#if 0
+void ............fb_ops................() {}
+#endif
+/******************************************************************************
+* MODULE   : mp200_fb_mmap
+* FUNCTION : mmap
+* RETURN   : 0       : success
+*          : -EINVAL : input value error
+*          : -EAGAIN : run again
+* NOTE     : none
+* CREATE   :
+* UPDATE   : 2006.11.16 H.Nagashima
+* UPDATE   : 2008.11.27 J.Manabe
+******************************************************************************/
+int mp200_fb_mmap(struct fb_info *info, struct vm_area_struct *vma)
+{
+	unsigned long start;
+	unsigned long off;
+	u32 len;
+
+	if (vma->vm_pgoff > (~0UL >> PAGE_SHIFT))
+		return -EINVAL;
+
+	off = vma->vm_pgoff << PAGE_SHIFT;
+	if (off < DispBufAllLength) {
+		start = (unsigned long)Smem;
+		len = PAGE_ALIGN((start & ~PAGE_MASK) + DispBufAllLength);
+	} else
+		return -EINVAL;
+
+	start &= PAGE_MASK;
+	if ((vma->vm_end - vma->vm_start + off) > len)
+		return -EINVAL;
+
+	off += start;
+	vma->vm_pgoff = off >> PAGE_SHIFT;
+
+	/* Accessing memory will be done non-cached. */
+	vma->vm_page_prot = __pgprot(pgprot_val(vma->vm_page_prot)
+	 | L_PTE_BUFFERABLE);
+	vma->vm_page_prot = __pgprot(pgprot_val(vma->vm_page_prot)
+	 & ~L_PTE_CACHEABLE);
+
+	/* To stop the swapper from even considering these pages */
+	vma->vm_flags |= (VM_IO | VM_RESERVED);
+
+	if (remap_pfn_range(vma, vma->vm_start, vma->vm_pgoff,
+	 vma->vm_end - vma->vm_start, vma->vm_page_prot)) {
+		return -EAGAIN;
+	}
+
+	return 0;
+}
+
+
+/******************************************************************************
+* MODULE   : mp200_fb_open
+* FUNCTION : open qfb driver
+* RETURN   : 0      : success
+*            -EBUSY : LCD initialize failed
+* NOTE     : none
+* CREATE   :
+* UPDATE   : 2006.05.29 H.Nagashima
+* UPDATE   : 2008.11.14 J.Manabe
+******************************************************************************/
+static int mp200_fb_open(struct fb_info *info, int user)
+{
+	mp200_fb_par *par      = (mp200_fb_par *)info->par;
+
+	if (fb_data[par->devflag].is_first) {
+		if (par->devflag == EM1_FB_DEVICE_LCD) {
+			/* initialize LCD driver */
+			if (init_lcdhw() != 0) {
+				printk_wrn("initialize LCD failed.\n");
+				return -EBUSY;
+			}
+
+			printk_dbg((_DEBUG_FB & 0x10), "queue_work\n");
+			queue_work(par->mp200_fb_workqueue,
+			 &par->wk_timeout_update_bottom_half);
+		}
+		timer_init(info);
+		fb_data[par->devflag].is_first = 0;
+	}
+
+	atomic_inc(&par->use_count);
+
+	return 0;
+}
+
+
+/******************************************************************************
+* MODULE   : mp200_fb_release
+* FUNCTION : close qfb driver
+* RETURN   : 0       : success
+*            -EINVAL :
+* NOTE     : none
+* CREATE   :
+* UPDATE   : 2006.05.29 H.Nagashima
+* UPDATE   : 2009.01.06 J.Manabe
+******************************************************************************/
+static int mp200_fb_release(struct fb_info *info, int user)
+{
+	mp200_fb_par *par = (mp200_fb_par *)info->par;
+	u32           count;
+	unsigned long flags;
+
+	down(&par->sem_tvmode);
+
+	down(&par->sem_fb_image_info);		/* lock fb_image_info */
+	count = atomic_read(&par->use_count);
+	if (count == 0) {
+		up(&par->sem_fb_image_info);	/* unlock fb_image_info */
+		up(&par->sem_tvmode);
+		return -EINVAL;
+	}
+
+	if (count == 1) {
+		if (par->devflag == EM1_FB_DEVICE_LCD) {
+			fb_data[par->devflag].iUpdateTimerFlag =
+				DEFALT_UPDATE_TIMER_LCD;
+			fb_data[par->devflag].iTimeoutTime     = TIMEOUT_TIME;
+			del_timer(&fb_data[par->devflag].mp200_fb_timer);
+			fb_data[par->devflag].iTimerStatusFlag = FB_TIMER_STOP;
+			if ((fb_data[par->devflag].iUpdateTimerFlag ==
+				TIMER_ON) &&
+				(fb_data[par->devflag].iMixModeFlg ==
+				ONLY_2D_MODE)) {
+				fb_data[par->devflag].mp200_fb_timer.expires =
+					jiffies +
+					(fb_data[par->devflag].iTimeoutTime *
+					HZ / 1000);
+				add_timer(
+					&fb_data[par->devflag].mp200_fb_timer);
+				fb_data[par->devflag].iTimerStatusFlag =
+					FB_TIMER_START;
+			}
+		} else {
+			spin_lock_irqsave(
+				&fb_data[par->devflag].mp200_fb_dev->fb_lock,
+				flags);
+			/* default timer on */
+			fb_data[par->devflag].iUpdateTimerFlag = TIMER_ON;
+			fb_data[par->devflag].iTimeoutTime     = TIMEOUT_TIME;
+			del_timer(&fb_data[par->devflag].mp200_fb_timer);
+			fb_data[par->devflag].iTimerStatusFlag = FB_TIMER_STOP;
+			spin_unlock_irqrestore(
+				&fb_data[par->devflag].mp200_fb_dev->fb_lock,
+				flags);
+
+#ifdef CONFIG_FB_MP200_NTS
+			/* NTS SET(OFF) */
+			mp200_nts_release(NTS_ACTIVE_FB);
+#endif /* CONFIG_FB_MP200_NTS */
+			tvmode = EM1_TV_MODE_OFF;
+
+			fb_data[par->devflag].iFBStatus_A = IS_NODATA;
+			fb_data[par->devflag].iFBStatus_B = IS_NODATA;
+		}
+	}
+
+	atomic_dec(&par->use_count);
+	up(&par->sem_fb_image_info);		/* unlock fb_image_info */
+	up(&par->sem_tvmode);
+	return 0;
+}
+
+
+/******************************************************************************
+* MODULE   : get_line_length
+* FUNCTION : get line length
+* RETURN   : length
+* NOTE     : none
+* CREATE   :
+* UPDATE   :
+******************************************************************************/
+static u_long get_line_length(int xres_virtual, int bpp)
+{
+	u_long length;
+
+	length = xres_virtual * bpp;
+	length = (length + 31) & ~31;
+	length >>= 3;
+	return length;
+}
+
+
+/******************************************************************************
+* MODULE   : mp200_fb_check_var
+* FUNCTION : variable check
+* RETURN   : 0       : success
+*            -EINVAL : input value incorrect
+*            -ENOMEM :
+* NOTE     : none
+* CREATE   :
+* UPDATE   : 2006.05.29 H.Nagashima
+* UPDATE   : 2008.11.14 J.Manabe
+******************************************************************************/
+static int mp200_fb_check_var(struct fb_var_screeninfo *var,
+ struct fb_info *info)
+{
+	u_long line_length;
+	mp200_fb_par *par  = (mp200_fb_par *)info->par;
+
+	if (var->vmode & FB_VMODE_CONUPDATE) {
+		var->vmode |= FB_VMODE_YWRAP;
+		var->xoffset = info->var.xoffset;
+		var->yoffset = info->var.yoffset;
+	}
+
+	/* Some very basic checks */
+	if (!var->xres)
+		var->xres = 1;
+	if (!var->yres)
+		var->yres = 1;
+	if (var->xres > var->xres_virtual)
+		var->xres_virtual = var->xres;
+	if (var->yres > var->yres_virtual)
+		var->yres_virtual = var->yres;
+	if (var->bits_per_pixel <= 1)
+		var->bits_per_pixel = 1;
+	else if (var->bits_per_pixel <= 8)
+		var->bits_per_pixel = 8;
+	else if (var->bits_per_pixel <= 16)
+		var->bits_per_pixel = 16;
+	else if (var->bits_per_pixel <= 24)
+		var->bits_per_pixel = 24;
+	else if (var->bits_per_pixel <= 32)
+		var->bits_per_pixel = 32;
+	else
+		return -EINVAL;
+
+	if (var->xres_virtual < var->xoffset + var->xres)
+		var->xres_virtual = var->xoffset + var->xres;
+
+	if (var->yres_virtual < var->yoffset + var->yres)
+		var->yres_virtual = var->yoffset + var->yres;
+
+	/* Memory limit */
+	line_length = get_line_length(var->xres_virtual, var->bits_per_pixel);
+	if (line_length * var->yres_virtual >
+		fb_data[par->devflag].DispBufLength)
+		return -ENOMEM;
+
+	/* check var */
+	switch (var->bits_per_pixel) {
+	case 1:	/* FALL THROUGH */
+	case 8:
+		{
+			var->red.offset    = 0;
+			var->red.length    = 8;
+			var->green.offset  = 0;
+			var->green.length  = 8;
+			var->blue.offset   = 0;
+			var->blue.length   = 8;
+			var->transp.offset = 0;
+			var->transp.length = 0;
+			break;
+		}
+	case 16:		/* RGBA 5551 */
+		{
+			if (var->transp.length) {
+				var->red.offset    = 0;
+				var->red.length    = 5;
+				var->green.offset  = 5;
+				var->green.length  = 5;
+				var->blue.offset   = 10;
+				var->blue.length   = 5;
+				var->transp.offset = 15;
+				var->transp.length = 1;
+			} else {		/* RGB 565 */
+				var->red.offset    = 11;
+				var->red.length    = 5;
+				var->green.offset  = 5;
+				var->green.length  = 6;
+				var->blue.offset   = 0;
+				var->blue.length   = 5;
+				var->transp.offset = 0;
+				var->transp.length = 0;
+			}
+			break;
+		}
+	case 24:		/* RGB 888 */
+		{
+			var->red.offset    = 0;
+			var->red.length    = 8;
+			var->green.offset  = 8;
+			var->green.length  = 8;
+			var->blue.offset   = 16;
+			var->blue.length   = 8;
+			var->transp.offset = 0;
+			var->transp.length = 0;
+			break;
+		}
+	case 32:		/* RGBA 8888 */
+		{
+			var->red.offset    = 0;
+			var->red.length    = 8;
+			var->green.offset  = 8;
+			var->green.length  = 8;
+			var->blue.offset   = 16;
+			var->blue.length   = 8;
+			var->transp.offset = 24;
+			var->transp.length = 8;
+			break;
+		}
+	}
+	var->red.msb_right    = 0;
+	var->green.msb_right  = 0;
+	var->blue.msb_right   = 0;
+	var->transp.msb_right = 0;
+
+	return 0;
+}
+
+/******************************************************************************
+* MODULE   : mp200_fb_set_par
+* FUNCTION : set qfb parameter
+* RETURN   : 0 : success
+* NOTE     : none
+* CREATE   :
+* UPDATE   : 2006.05.29 H.Nagashima
+******************************************************************************/
+static int mp200_fb_set_par(struct fb_info *info)
+{
+	info->fix.line_length = get_line_length(info->var.xres_virtual,
+	 info->var.bits_per_pixel);
+	return 0;
+}
+
+
+/******************************************************************************
+* MODULE   : mp200_fb_setcolreg
+* FUNCTION : set qfb color
+* RETURN   : 0 : success
+*            1 :
+* NOTE     : none
+* CREATE   :
+* UPDATE   : 2006.05.29 H.Nagashima
+******************************************************************************/
+static int mp200_fb_setcolreg(u_int regno, u_int red, u_int green, u_int blue,
+ u_int transp, struct fb_info *info)
+{
+	/* No. of hw registers */
+	if (regno >= 256)
+		return 1;
+
+	/* grayscale works only partially under directcolor */
+	if (info->var.grayscale) {
+		/* grayscale = 0.30*R + 0.59*G + 0.11*B */
+		red = green = blue = (red * 77 + green * 151 + blue * 28) >> 8;
+	}
+
+#define CNVT_TOHW(val, width) ((((val)<<(width))+0x7FFF-(val))>>16)
+	switch (info->fix.visual) {
+	case FB_VISUAL_TRUECOLOR:	/* FALL THROUGH */
+	case FB_VISUAL_PSEUDOCOLOR:
+	{
+		red = CNVT_TOHW(red, info->var.red.length);
+		green = CNVT_TOHW(green, info->var.green.length);
+		blue = CNVT_TOHW(blue, info->var.blue.length);
+		transp = CNVT_TOHW(transp, info->var.transp.length);
+		break;
+	}
+	case FB_VISUAL_DIRECTCOLOR:
+	{
+		red = CNVT_TOHW(red, 8);	/* expect 8 bit DAC */
+		green = CNVT_TOHW(green, 8);
+		blue = CNVT_TOHW(blue, 8);
+		/* hey, there is bug in transp handling... */
+		transp = CNVT_TOHW(transp, 8);
+		break;
+	}
+	}
+#undef CNVT_TOHW
+	/* Truecolor has hardware independent palette */
+	if (info->fix.visual == FB_VISUAL_TRUECOLOR) {
+		u32 v;
+
+		if (regno >= 16)
+			return 1;
+
+		v = (red << info->var.red.offset)
+		  | (green << info->var.green.offset)
+		  | (blue << info->var.blue.offset)
+		  | (transp << info->var.transp.offset);
+		switch (info->var.bits_per_pixel) {
+		case 16:	/* FALL THROUGH */
+		case 24:	/* FALL THROUGH */
+		case 32:
+		{
+			((u32 *) (info->pseudo_palette))[regno] = v;
+			break;
+		}
+		case 8:		/* FALL THROUGH */
+		default:
+		{
+			break;
+		}
+		}
+	}
+	return 0;
+}
+
+/******************************************************************************
+* MODULE   : mp200_fb_blank
+* FUNCTION : FBIOBLANK
+* RETURN   : 0       : success
+*            -EINVAL : input value incorrect
+* NOTE     : none
+* CREATE   : 2009.9.14 Y.Utsuhara
+* UPDATE   :
+******************************************************************************/
+static int mp200_fb_blank(int blank_mode, struct fb_info *info)
+{
+	mp200_fb_par *par  = (mp200_fb_par *)info->par;
+
+	if (par->devflag == EM1_FB_DEVICE_LCD)
+		return mp200_lcd_blank(blank_mode);
+	else
+		return mp200_nts_blank(blank_mode);
+
+}
+
+/******************************************************************************
+* MODULE   : mp200_fb_pan_display
+* FUNCTION :
+* RETURN   : 0       : success
+*            -EINVAL : input value incorrect
+* NOTE     : none
+* CREATE   :
+* UPDATE   : 2006.05.29 H.Nagashima
+******************************************************************************/
+static int mp200_fb_pan_display(struct fb_var_screeninfo *var,
+ struct fb_info *info)
+{
+	if (var->vmode & FB_VMODE_YWRAP) {
+		if (var->yoffset < 0
+		 || var->yoffset >= info->var.yres_virtual || var->xoffset) {
+			return -EINVAL;
+		}
+	} else {
+		if (var->xoffset + var->xres > info->var.xres_virtual ||
+		    var->yoffset + var->yres > info->var.yres_virtual) {
+			return -EINVAL;
+		}
+	}
+	info->var.xoffset = var->xoffset;
+	info->var.yoffset = var->yoffset;
+	if (var->vmode & FB_VMODE_YWRAP)
+		info->var.vmode |= FB_VMODE_YWRAP;
+	else
+		info->var.vmode &= ~FB_VMODE_YWRAP;
+
+	return 0;
+}
+
+
+/******************************************************************************
+* MODULE   : mp200_fb_callback
+* FUNCTION : call back from LCD driver
+* RETURN   : none
+* NOTE     : public function
+* CREATE   : 2006.05.27 H.Nagashima
+* UPDATE   : 2008.11.14 J.Manabe
+******************************************************************************/
+void mp200_fb_callback(int iWrittenFBNo, int iMixModeStatus, int fb_num)
+{
+	printk_dbg((_DEBUG_FB & 0x01), "fb(%d) status(%d) from(%d)\n",
+	 iWrittenFBNo, iMixModeStatus, fb_num);
+	fb_data[fb_num].iMixModeFlg = iMixModeStatus;
+
+	/* fb timer stop */
+	del_timer(&fb_data[fb_num].mp200_fb_timer);
+	fb_data[fb_num].iTimerStatusFlag = FB_TIMER_STOP;
+
+	/* change FB (A/B) status */
+	if (iWrittenFBNo == FB_NO_A) {
+		fb_data[fb_num].iNowDispPage = FB_NO_A;
+		fb_data[fb_num].iFBStatus_A  = ALREADY_DISPLAY;
+		if (fb_data[fb_num].iNextDispPage != FB_NO_B) {
+			fb_data[fb_num].iFBStatus_B = ENABLE_WRITE;
+#if (TIMEOUT_MSLEEP == 0)
+			wake_up_interruptible(
+			&fb_data[fb_num].mp200_fb_dev->wait_fb_chk_scrn);
+#endif
+		}
+	} else {
+		fb_data[fb_num].iNowDispPage = FB_NO_B;
+		fb_data[fb_num].iFBStatus_B  = ALREADY_DISPLAY;
+		if (fb_data[fb_num].iNextDispPage != FB_NO_A) {
+			fb_data[fb_num].iFBStatus_A = ENABLE_WRITE;
+#if (TIMEOUT_MSLEEP == 0)
+			wake_up_interruptible(
+			&fb_data[fb_num].mp200_fb_dev->wait_fb_chk_scrn);
+#endif
+		}
+	}
+	printk_dbg((_DEBUG_FB & 0x08), "<] callback:    A(%d) B(%d)\n",
+	 fb_data[fb_num].iFBStatus_A, fb_data[fb_num].iFBStatus_B);
+
+	/* start timer */
+	if ((fb_data[fb_num].iUpdateTimerFlag == TIMER_ON) &&
+		(fb_data[fb_num].iMixModeFlg == ONLY_2D_MODE)
+#if defined(CONFIG_PM) || defined(CONFIG_DPM)
+	    && !fb_data[fb_num].iDpmSuspendFlag
+#endif /* CONFIG_PM || CONFIG_DPM */
+	) {
+		printk_dbg((_DEBUG_FB & 0x10), "resume: callback: add_timer\n");
+		fb_data[fb_num].mp200_fb_timer.expires = jiffies
+		 + (fb_data[fb_num].iTimeoutTime * HZ / 1000);
+		add_timer(&fb_data[fb_num].mp200_fb_timer);
+		fb_data[fb_num].iTimerStatusFlag = FB_TIMER_START;
+	}
+}
+EXPORT_SYMBOL(mp200_fb_callback);
+
+
+#if 0
+void ............Init_Function................() {}
+#endif
+/********************************************************
+ *  Init Function Definitions                           *
+ *******************************************************/
+/******************************************************************************
+* MODULE   : mp200_fb_init_module
+* FUNCTION : frame buffer driver init function
+* RETURN   : 0      : success
+*            -ENXIO : fail
+* NOTE     : none
+* CREATE   :
+* UPDATE   : 2006.05.27 H.Nagashima
+******************************************************************************/
+int __init mp200_fb_init_module(void)
+{
+	int   iRet   = 0;
+
+	iRet = platform_driver_register(&mp200_fb_driver);
+	if (!iRet)
+		return iRet;
+
+	return 0;
+}
+
+
+/******************************************************************************
+* MODULE   : mp200_fb_probe
+* FUNCTION : frame buffer driver probe function
+* RETURN   : 0       : success
+*            -ENOMEM : mem error
+*            -EBUSY  : other driver init error
+* NOTE     : none
+* CREATE   :
+* UPDATE   : 2006.05.27 H.Nagashima
+* UPDATE   : 2008.12.04 J.Manabe
+******************************************************************************/
+static int __init mp200_fb_probe(struct platform_device *dev)
+{
+	struct fb_info         *info = NULL;
+	struct fb_info         *info_0 = NULL;
+	struct fb_info         *info_1 = NULL;
+	mp200_fb_par           *par  = NULL;
+	int                     iRet = -ENOMEM;
+	int                     fb_num = 0;
+
+	/* reserve region Smem */
+	if (!request_mem_region(Smem, SmemLength, "qfb")) {
+		printk_wrn("cannot reserve smem\n");
+		mp200_fb_probe_error(FB_INIT_ERROR__SMEM_NOT_RESERVE, info_0,
+		 info_1, fb_num);
+		return -ENOMEM;
+	}
+
+	/* remap SmemV */
+	SmemV = ioremap_nocache(Smem, SmemLength);
+	if (!SmemV) {
+		printk_wrn("cannot ioremap_nocache smem\n");
+		mp200_fb_probe_error(FB_INIT_ERROR__SMEM_NOT_REMAP, info_0,
+		 info_1, fb_num);
+		return -ENOMEM;
+	}
+	printk_dbg((_DEBUG_FB),
+	 " Smem    (0x%lx)  SmemV    (0x%p)  SmemLength    (0x%lx)\n",
+	 Smem, SmemV, SmemLength);
+
+	for (fb_num = 0; fb_num < EM1_FB_DEVICES; fb_num++) {
+
+		/* alloc framebuffer */
+		info = framebuffer_alloc(sizeof(mp200_fb_par), &dev->dev);
+		if (!info) {
+			printk_wrn("cannot framebuffer alloc\n");
+			mp200_fb_probe_error(FB_INIT_ERROR__FB_NOT_ALLOC,
+			 info_0, info_1, fb_num);
+			return -ENOMEM;
+		} else {
+			if (fb_num == 0)
+				info_0 = info;
+			else
+				info_1 = info;
+		}
+
+		/* flag initialize */
+		set_flag_init(fb_num);
+
+		/* set buffer address */
+		set_buffer_address(fb_num);
+
+		/* set infomation */
+		set_info(info, &par, fb_num);
+
+		/* device flag set */
+		par->devflag = fb_num;
+
+		/* alloc cmap */
+		iRet = fb_alloc_cmap(&info->cmap, 256, 0);
+		if (iRet < 0) {
+			printk_wrn("cannot framebuffer alloc cmap\n");
+			mp200_fb_probe_error(FB_INIT_ERROR__FB_CMAP_NOT_ALLOC,
+			 info_0, info_1, fb_num);
+			return -ENOMEM;
+		}
+
+		/* regist frame buffer */
+		iRet = register_framebuffer(info);
+		if (iRet < 0) {
+			printk_wrn("cannot regist framebuffer\n");
+			mp200_fb_probe_error(FB_INIT_ERROR__FB_NOT_REGIST,
+			 info_0, info_1, fb_num);
+			return -EBUSY;
+		}
+
+		/* spinlock initialize */
+		spin_lock_init(&par->fb_lock);
+
+		/* semaphore initialize */
+		sema_init(&par->sem_fb_image_info, 1);
+		sema_init(&par->sem_fb_other_info_A, 1);
+		sema_init(&par->sem_fb_other_info_B, 1);
+		sema_init(&par->sem_tvmode, 1);
+
+#if (TIMEOUT_MSLEEP == 0)
+		/* wait_event initialize */
+		init_waitqueue_head(&par->wait_fb_chk_scrn);
+#endif
+
+		/* workqueue initialize */
+		par->mp200_fb_workqueue =
+			create_singlethread_workqueue(DEV_NAME);
+		INIT_WORK(&par->wk_timeout_update_bottom_half,
+		 timeout_update_bottom_half_do);
+
+		/* variable initialize */
+		set_val_init(info, fb_num);
+
+		/* set drvdata */
+		drvdata.info[fb_num] = info;
+
+		/* for callback function */
+		fb_data[fb_num].mp200_fb_dev = par;
+	}
+	fb_num--;
+
+	/*initialize LCD driver */
+	if (mp200_lcd_init_module() != 0) {
+		printk_wrn("cannot initialize LCD\n");
+		mp200_fb_probe_error(FB_INIT_ERROR__LCD_NOT_INITIALIZE,
+		 info_0, info_1, fb_num);
+		return -EBUSY;
+	}
+
+	/* set drvdate */
+	dev_set_drvdata(&dev->dev, &drvdata);
+
+	printk_info("registered device fb\n");
+	return 0;
+}
+
+
+/******************************************************************************
+* MODULE   : mp200_fb_probe_error
+* FUNCTION : When probe error, cleanup
+* RETURN   : none
+* NOTE     :
+* CREATE   : 2006.05.27 H.Nagashima
+* UPDATE   :
+******************************************************************************/
+static void __init  mp200_fb_probe_error(int iErrorMode,
+ struct fb_info *info_0, struct fb_info *info_1, int fb_num)
+{
+	if (fb_num > 0) {
+		switch (iErrorMode) {
+		case FB_INIT_ERROR__LCD_NOT_INITIALIZE:
+			unregister_framebuffer(info_1);
+		case FB_INIT_ERROR__FB_NOT_REGIST:
+			fb_dealloc_cmap(&info_1->cmap);
+		case FB_INIT_ERROR__FB_CMAP_NOT_ALLOC:
+			framebuffer_release(info_1);
+		case FB_INIT_ERROR__FB_NOT_ALLOC:
+		default:
+			break;
+		}
+		unregister_framebuffer(info_0);
+		fb_dealloc_cmap(&info_0->cmap);
+		framebuffer_release(info_0);
+		iounmap(SmemV);
+		release_mem_region(Smem, DispBufAllLength);
+	} else {
+		switch (iErrorMode) {
+		case FB_INIT_ERROR__LCD_NOT_INITIALIZE:
+			unregister_framebuffer(info_0);
+		case FB_INIT_ERROR__FB_NOT_REGIST:
+			fb_dealloc_cmap(&info_0->cmap);
+		case FB_INIT_ERROR__FB_CMAP_NOT_ALLOC:
+			framebuffer_release(info_0);
+		case FB_INIT_ERROR__FB_NOT_ALLOC:
+			iounmap(SmemV);
+		case FB_INIT_ERROR__SMEM_NOT_REMAP:
+			release_mem_region(Smem, DispBufAllLength);
+		case FB_INIT_ERROR__SMEM_NOT_RESERVE:
+		default:
+			break;
+		}
+	}
+}
+
+
+/******************************************************************************
+* MODULE   : set_buffer_address
+* FUNCTION : set frame buffer (A/B) address
+* RETURN   : none
+* NOTE     :
+* CREATE   : 2006.05.27 H.Nagashima
+* UPDATE   : 2008.12.04 J.Manabe
+******************************************************************************/
+static void set_buffer_address(int fb_num)
+{
+#ifdef CONFIG_FB_MP200_NTS
+	if (fb_num == EM1_FB_DEVICE_LCD) {
+#endif /* CONFIG_FB_MP200_NTS */
+		/* set & clean DispBufA(2D) address */
+		fb_data[fb_num].DispBufAV = SmemV + DISPBUF_A_OFFSET;
+		memset_io((char __iomem *)fb_data[fb_num].DispBufAV, 0,
+		 fb_data[fb_num].DispBufLength);
+
+		/* set & clean DispBufB(2D) address */
+		fb_data[fb_num].DispBufBV = SmemV + DISPBUF_B_OFFSET;
+		memset_io((char __iomem *)fb_data[fb_num].DispBufBV, 0,
+		 fb_data[fb_num].DispBufLength);
+#ifdef CONFIG_FB_MP200_NTS
+	} else {
+		fb_data[fb_num].DispBufAV = SmemV + NTSCBUF_A_OFFSET;
+		memset_io((char __iomem *)fb_data[fb_num].DispBufAV, 0,
+		 fb_data[fb_num].DispBufLength);
+
+		/* set & clean DispBufB(2D) address */
+		fb_data[fb_num].DispBufBV = SmemV + NTSCBUF_B_OFFSET;
+		memset_io((char __iomem *)fb_data[fb_num].DispBufBV, 0,
+		 fb_data[fb_num].DispBufLength);
+	}
+#endif /* CONFIG_FB_MP200_NTS */
+}
+
+
+/******************************************************************************
+* MODULE   : set_info
+* FUNCTION : set frame buffer driver infomation
+* RETURN   : none
+* NOTE     :
+* CREATE   : 2006.05.30 H.Nagashima
+* UPDATE   : 2008.11.13 J.Manabe
+******************************************************************************/
+static void set_info(struct fb_info *info, mp200_fb_par **par, int fb_num)
+{
+	*par                  = (mp200_fb_par *)info->par;
+	(*par)->fb_inf        = info;
+
+	info->screen_base     = (char __iomem *)fb_data[fb_num].DispBufAV;
+	info->screen_size     = fb_data[fb_num].DispBufLength;
+	info->fbops           = &mp200_fb_ops;
+
+#ifdef CONFIG_FB_MP200_NTS
+	if (fb_num == EM1_FB_DEVICE_LCD)
+		info->var     = mp200_fb_default;
+	else
+		info->var     = mp200_fb_tv_default;
+
+#else
+	info->var             = mp200_fb_default;
+#endif /* CONFIG_FB_MP200_NTS */
+
+	info->fix             = mp200_fb_fix;
+	info->fix.line_length = info->var.xres_virtual
+	 * info->var.bits_per_pixel / 8;
+	info->fix.smem_start  = fb_data[fb_num].DispBufA;
+	info->fix.smem_len    = fb_data[fb_num].DispBufLength;
+	info->pseudo_palette  = (*par)->pseudo_palette;
+	info->flags           = FBINFO_FLAG_DEFAULT;
+}
+
+
+/******************************************************************************
+* MODULE   : set_flag_init
+* FUNCTION : flag initialize
+* RETURN   : none
+* NOTE     :
+* CREATE   : 2006.05.30 H.Nagashima
+* UPDATE   : 2008.11.14 J.Manabe
+******************************************************************************/
+static void set_flag_init(int fb_num)
+{
+	fb_data[fb_num].iFBStatus_A      = IS_NODATA;
+	fb_data[fb_num].iFBStatus_B      = IS_NODATA;
+	printk_dbg((_DEBUG_FB & 0x08), "A(%d) B(%d)\n",
+	 fb_data[fb_num].iFBStatus_A, fb_data[fb_num].iFBStatus_B);
+	fb_data[fb_num].iNowDispPage     = DISP_BUFA;
+	fb_data[fb_num].iNextDispPage    = DISP_BUFA;
+
+#ifdef CONFIG_FB_MP200_NTS
+	if (fb_num == EM1_FB_DEVICE_NTS) {
+		fb_data[fb_num].iUpdateTimerFlag = DEFALT_UPDATE_TIMER_NTS;
+
+		/* tvmode default set */
+		tvmode = EM1_TV_MODE_OFF;
+		/* struct init */
+		fb_data[EM1_FB_DEVICE_NTS].DispBufA = SMEM_START
+		 + NTSCBUF_A_OFFSET;
+		fb_data[EM1_FB_DEVICE_NTS].DispBufB = SMEM_START
+		 + NTSCBUF_B_OFFSET;
+		fb_data[EM1_FB_DEVICE_NTS].DispBufLength = NTSCBUF_LENGTH;
+	} else {
+#endif /* CONFIG_FB_MP200_NTS */
+		fb_data[fb_num].iUpdateTimerFlag = DEFALT_UPDATE_TIMER_LCD;
+		fb_data[fb_num].DispBufA = SMEM_START + DISPBUF_A_OFFSET;
+		fb_data[fb_num].DispBufB = SMEM_START + DISPBUF_B_OFFSET;
+		fb_data[fb_num].DispBufLength = DISPBUF_LENGTH;
+#ifdef CONFIG_FB_MP200_NTS
+	}
+#endif /* CONFIG_FB_MP200_NTS */
+
+	fb_data[fb_num].iMixModeFlg      = ONLY_2D_MODE;
+	fb_data[fb_num].iDpmSuspendFlag  = 0;
+
+	fb_data[fb_num].is_first         = 1;
+
+}
+
+
+/******************************************************************************
+* MODULE   : set_val_init
+* FUNCTION : variable initialize
+* RETURN   : none
+* NOTE     :
+* CREATE   : 2006.06.05 H.Nagashima
+* UPDATE   : 2008.11.14 J.Manabe
+******************************************************************************/
+static void set_val_init(struct fb_info *info, int fb_num)
+{
+	/* fb A val init */
+	fb_data[fb_num].fb_other_info_A.iMaskColFlg = TC_COLOR_DISABLE;
+	fb_data[fb_num].fb_other_info_A.iMaskCol    = 0x0020;
+	fb_data[fb_num].fb_other_info_A.iAlpha      = 0xFF;
+	fb_data[fb_num].fb_other_info_A.iInvFlg     = NO_INVERSE;
+	fb_data[fb_num].fb_other_info_A.iPage       = DISP_BUFA;
+	fb_data[fb_num].fb_other_info_A.iUpDate     = UPDATE_FLAG_OFF;
+
+	/* fb B val init */
+	fb_data[fb_num].fb_other_info_B.iMaskColFlg = TC_COLOR_DISABLE;
+	fb_data[fb_num].fb_other_info_B.iMaskCol    = 0x0020;
+	fb_data[fb_num].fb_other_info_B.iAlpha      = 0xFF;
+	fb_data[fb_num].fb_other_info_B.iInvFlg     = NO_INVERSE;
+	fb_data[fb_num].fb_other_info_B.iPage       = DISP_BUFB;
+	fb_data[fb_num].fb_other_info_B.iUpDate     = UPDATE_FLAG_OFF;
+
+	/* fb data init (to LCD) */
+	fb_data[fb_num].fb_image_info.image_data.hsize    = info->var.xres;
+	fb_data[fb_num].fb_image_info.image_data.vsize    = info->var.yres;
+	fb_data[fb_num].fb_image_info.image_data.size     =
+		info->var.xres_virtual * info->var.bits_per_pixel / 8;
+	fb_data[fb_num].fb_image_info.image_data.yrgbaddr =
+		fb_data[fb_num].DispBufA;
+	fb_data[fb_num].fb_image_info.image_data.uvaddr   = 0x00000000;
+	fb_data[fb_num].fb_image_info.image_data.x        = 0;
+	fb_data[fb_num].fb_image_info.image_data.y        = 0;
+
+	/* fb info init (to LCD) */
+	fb_data[fb_num].fb_image_info.maskcolrflg  = FB_MASK_COLOR_DISP_OFF;
+	fb_data[fb_num].fb_image_info.maskcolr     = 0x0020;
+	fb_data[fb_num].fb_image_info.alpha        = 0xFF;
+	fb_data[fb_num].fb_image_info.invflg       = NO_INVERSE;
+	fb_data[fb_num].fb_image_info.mix_buf_page = DISP_BUFA;
+	fb_data[fb_num].fb_image_info.update_flag  = FB_UPDATE_OFF;
+
+	/* timer */
+	fb_data[fb_num].iTimeoutTime               = TIMEOUT_TIME;
+}
+
+
+#if 0
+void ............Timer_Function................() {}
+#endif
+/********************************************************
+ *  Timer Function Definitions                          *
+ *******************************************************/
+/******************************************************************************
+* MODULE   : timer_init
+* FUNCTION : call back from LCD driver
+* RETURN   : none
+* NOTE     : public function
+* CREATE   : 2006.06.07 H.Nagashima
+* UPDATE   : 2008.11.14 J.Manabe
+******************************************************************************/
+static void timer_init(struct fb_info *info)
+{
+	mp200_fb_par *par = (mp200_fb_par *)info->par;
+
+	init_timer(&fb_data[par->devflag].mp200_fb_timer);
+	fb_data[par->devflag].mp200_fb_timer.function = timeout_update;
+	fb_data[par->devflag].mp200_fb_timer.entry.next = NULL;
+	fb_data[par->devflag].mp200_fb_timer.data = (unsigned long)info;
+	down(&par->sem_tvmode);
+	if (par->devflag == EM1_FB_DEVICE_LCD || tvmode != EM1_TV_MODE_OFF) {
+		if ((fb_data[par->devflag].iUpdateTimerFlag == TIMER_ON)
+		 && (fb_data[par->devflag].iMixModeFlg == ONLY_2D_MODE)) {
+			printk_dbg((_DEBUG_FB & 0x10), "add_timer\n");
+			fb_data[par->devflag].mp200_fb_timer.expires = jiffies
+			 + (TIMEOUT_TIME * HZ / 1000);
+			add_timer(&fb_data[par->devflag].mp200_fb_timer);
+			fb_data[par->devflag].iTimerStatusFlag = FB_TIMER_START;
+			printk_dbg((_DEBUG_FB & 0x01), "%d <start>\n",
+			 __LINE__);
+		}
+	}
+	up(&par->sem_tvmode);
+}
+
+
+/******************************************************************************
+* MODULE   : timeout_update
+* FUNCTION : when Timer timeout, update execution
+* RETURN   : none
+* NOTE     : public function
+* CREATE   : 2006.06.07 H.Nagashima
+* UPDATE   : 2008.11.14 J.Manabe
+******************************************************************************/
+static void timeout_update(unsigned long data)
+{
+	unsigned long        flags;
+	struct fb_info      *info;
+	mp200_fb_par *par;
+
+	printk_dbg((_DEBUG_FB & 0x10), "\n");
+
+	info = (struct fb_info *)data;
+	par  = (mp200_fb_par *)info->par;
+
+	/* fb timer stop */
+	spin_lock_irqsave(&fb_data[par->devflag].mp200_fb_dev->fb_lock, flags);
+	del_timer(&fb_data[par->devflag].mp200_fb_timer);
+	fb_data[par->devflag].iTimerStatusFlag = FB_TIMER_STOP;
+	spin_unlock_irqrestore(&fb_data[par->devflag].mp200_fb_dev->fb_lock,
+			flags);
+
+	printk_dbg((_DEBUG_FB & 0x10), "queue_work\n");
+	queue_work(par->mp200_fb_workqueue,
+	 &par->wk_timeout_update_bottom_half);
+
+	/* start timer */
+	if ((fb_data[par->devflag].iUpdateTimerFlag == TIMER_ON)
+	 && (fb_data[par->devflag].iMixModeFlg == ONLY_2D_MODE)) {
+		spin_lock_irqsave(&fb_data[par->devflag].mp200_fb_dev->fb_lock,
+				flags);
+		if (fb_data[par->devflag].iTimerStatusFlag == FB_TIMER_STOP) {
+			printk_dbg((_DEBUG_FB & 0x10), "add_timer\n");
+			fb_data[par->devflag].mp200_fb_timer.expires =
+				jiffies + (fb_data[par->devflag].iTimeoutTime *
+				HZ / 1000);
+			add_timer(&fb_data[par->devflag].mp200_fb_timer);
+			fb_data[par->devflag].iTimerStatusFlag = FB_TIMER_START;
+		}
+		spin_unlock_irqrestore(
+			&fb_data[par->devflag].mp200_fb_dev->fb_lock, flags);
+	}
+}
+
+
+/******************************************************************************
+* MODULE   : timeout_update_bottom_half_do
+* FUNCTION : when Timer timeout, update execution
+* RETURN   : none
+* NOTE     : private function
+* CREATE   : 2006.07.10 Y.Utsuhara
+* UPDATE   : 2008.11.14 J.Manabe
+******************************************************************************/
+static void timeout_update_bottom_half_do(struct work_struct *num)
+{
+	mp200_fb_par *par;
+	struct fb_info *info;
+
+	printk_dbg((_DEBUG_FB & 0x10), "\n");
+
+	par = container_of(num, mp200_fb_par, wk_timeout_update_bottom_half);
+	info = par->fb_inf;
+	if (down_trylock(&par->sem_fb_image_info))	/* lock fb_image_info */
+		return;
+
+	/* set image infomation to LCD */
+	set_image_info_to_LCD(fb_data[par->devflag].iNextDispPage, info);
+
+	/* udpate on (normal MP200_FB_UPDATE_SCRN exe) */
+	fb_data[par->devflag].fb_image_info.update_flag = FB_UPDATE_ON;
+
+#ifdef CONFIG_FB_MP200_NTS
+	if (par->devflag == EM1_FB_DEVICE_LCD) {
+#endif /* CONFIG_FB_MP200_NTS */
+		/* call fb function */
+		printk_dbg((_DEBUG_FB & 0x10), "request LCD\n");
+		mp200_lcd_set_fb_image(&fb_data[par->devflag].fb_image_info);
+#ifdef CONFIG_FB_MP200_NTS
+	} else {
+		/* call fb1 function */
+		printk_dbg((_DEBUG_FB & 0x10), "request NTS\n");
+		mp200_nts_set_fb_image(&fb_data[par->devflag].fb_image_info);
+	}
+#endif /* CONFIG_FB_MP200_NTS */
+
+	up(&par->sem_fb_image_info);		/* unlock fb_image_info */
+}
+
+
+#if 0
+void ............Exit_Function................() {}
+#endif
+/********************************************************
+ *  Exit Function Definitions                           *
+ *******************************************************/
+/******************************************************************************
+* MODULE   : mp200_fb_remove
+* FUNCTION : remove
+* RETURN   : 0 : success
+* NOTE     : none
+* CREATE   :
+* UPDATE   : 2006.05.27 H.Nagashima
+* UPDATE   : 2008.12.09 J.Manabe
+******************************************************************************/
+static int mp200_fb_remove(struct platform_device *device)
+{
+	MP200_FB_DRVDATA *drvdata = platform_get_drvdata(device);
+	struct fb_info *info;
+	int i;
+
+	for (i = 0; i < EM1_FB_DEVICES; i++) {
+		/* remove frame buffer */
+		info = drvdata->info[i];
+		if (info) {
+			unregister_framebuffer(info);
+			fb_dealloc_cmap(&info->cmap);
+			framebuffer_release(info);
+		}
+	}
+
+	/* lcd remove */
+	mp200_lcd_exit_module();
+
+	/* remove Smem */
+	iounmap(SmemV);
+	release_mem_region(Smem, SmemLength);
+
+	return 0;
+}
+
+
+#if defined(CONFIG_PM) || defined(CONFIG_DPM)
+/********************************************************
+ *  Suspend/Resume Function Definitions                 *
+ *******************************************************/
+/******************************************************************************
+* MODULE   : mp200_fb_suspend
+* FUNCTION : suspend frame buffer driver
+* RETURN   :  0 : success
+*          : -1 : faile
+* NOTE     : none
+* CREATE   :
+* UPDATE   : 2006.05.29 H.Nagashima
+* UPDATE   : 2008.12.05 J.Manabe
+******************************************************************************/
+static int mp200_fb_suspend(struct platform_device *dev, pm_message_t state)
+{
+	/*** this module suspend ***/
+	if (!fb_data[EM1_FB_DEVICE_LCD].is_first) {
+		/*** this module suspend ***/
+		/* call fb suspend function  */
+		if (mp200_fb_suspend_sub(dev, state, EM1_FB_DEVICE_LCD))
+			goto fail_fb_lcd;
+
+		/*** relational module suspend ***/
+		/* call LCD suspend function */
+		if (mp200_lcd_suspend(dev, state))
+			goto fail_lcd;
+
+		/* call IMC suspend function */
+		if (mp200_imc_suspend(dev, state))
+			goto fail_imc;
+
+	}
+#ifdef CONFIG_MP200_NTS
+#ifdef CONFIG_FB_MP200_NTS
+	/*** this module suspend ***/
+	if (!fb_data[EM1_FB_DEVICE_NTS].is_first) {
+		/* call fb suspend function  */
+		if (mp200_fb_suspend_sub(dev, state, EM1_FB_DEVICE_NTS))
+			goto fail_fb_nts;
+
+	}
+#endif /* CONFIG_FB_MP200_NTS */
+	/*** relational module suspend ***/
+	if (mp200_nts_suspend(dev, state)) {	/* call NTS suspend function */
+		goto fail_nts;
+	}
+#endif /* CONFIG_MP200_NTS */
+	return 0;
+
+#ifdef CONFIG_MP200_NTS
+fail_nts:
+#ifdef CONFIG_FB_MP200_NTS
+	mp200_fb_resume_sub(dev, EM1_FB_DEVICE_NTS);
+fail_fb_nts:
+#endif /* CONFIG_FB_MP200_NTS */
+	mp200_imc_resume(dev);
+#endif /* CONFIG_MP200_NTS */
+fail_imc:
+	mp200_lcd_resume(dev);
+fail_lcd:
+	mp200_fb_resume_sub(dev, EM1_FB_DEVICE_LCD);
+fail_fb_lcd:
+	return -EBUSY;
+}
+
+
+/******************************************************************************
+* MODULE   : mp200_fb_suspend_sub
+* FUNCTION : suspend frame buffer driver
+* RETURN   : 0 : success
+* NOTE     : none
+* CREATE   :
+* UPDATE   : 2007.11.28 M.Haguro
+* UPDATE   : 2008.12.04 J.Manabe
+******************************************************************************/
+static int mp200_fb_suspend_sub(struct platform_device *dev,
+ pm_message_t state, int fb_num)
+{
+	int ret;
+
+	if (state.event == DEV_SUSPEND_IDLE_1) {
+		ret = 0;
+	} else {/* state.event == PM_EVENT_SUSPEND */
+		if (!mp200_sleep_while_idle) {
+			/*** this module suspend ***/
+			fb_data[fb_num].iDpmSuspendFlag = 1;
+			/* stop timer interrupt */
+			del_timer(&fb_data[fb_num].mp200_fb_timer);
+		}
+		ret = 0;
+	}
+	return ret;
+}
+
+
+/******************************************************************************
+* MODULE   : mp200_fb_resume
+* FUNCTION : resume frame buffer driver
+* RETURN   : 0 : success
+* NOTE     : none
+* CREATE   :
+* UPDATE   : 2006.05.29 H.Nagashima
+* UPDATE   : 2008.12.04 J.Manabe
+******************************************************************************/
+static int mp200_fb_resume(struct platform_device *dev)
+{
+	if (!fb_data[EM1_FB_DEVICE_LCD].is_first) {
+		/*** relathional module resume ***/
+		/* call IMC resume function */
+		mp200_imc_resume(dev);
+		/* call LCD resume function */
+		mp200_lcd_resume(dev);
+		/* call fb  resume function */
+		mp200_fb_resume_sub(dev, EM1_FB_DEVICE_LCD);
+	}
+#ifdef CONFIG_MP200_NTS
+	mp200_nts_resume(dev);	/* call NTS resume function */
+#ifdef CONFIG_FB_MP200_NTS
+	if (!fb_data[EM1_FB_DEVICE_NTS].is_first) {
+		/* call fb  resume function */
+		mp200_fb_resume_sub(dev, EM1_FB_DEVICE_NTS);
+	}
+#endif /* CONFIG_FB_MP200_NTS */
+#endif /* CONFIG_MP200_NTS */
+	return 0;
+}
+
+
+/******************************************************************************
+* MODULE   : mp200_fb_resume_sub
+* FUNCTION : resume frame buffer driver
+* RETURN   : 0 : success
+* NOTE     : none
+* CREATE   :
+* UPDATE   : 2007.11.28 M.Haguro
+* UPDATE   : 2008.12.04 J.Manabe
+******************************************************************************/
+static int mp200_fb_resume_sub(struct platform_device *dev, int fb_num)
+{
+	MP200_FB_DRVDATA *drvdata = platform_get_drvdata(dev);
+	struct fb_info *info;
+	mp200_fb_par *par;
+
+	if (fb_data[fb_num].iDpmSuspendFlag) {
+		/*** this module resume ***/
+		fb_data[fb_num].iDpmSuspendFlag = 0;
+
+		if (fb_num == EM1_FB_DEVICE_LCD || tvmode != EM1_TV_MODE_OFF) {
+			if (fb_data[fb_num].iMixModeFlg == ONLY_2D_MODE) {
+				if (fb_data[fb_num].iUpdateTimerFlag ==
+					TIMER_ON) {
+					printk_dbg((_DEBUG_FB & 0x10),
+					 "add_timer\n");
+					/* start timer interrupt */
+					add_timer(
+					&fb_data[fb_num].mp200_fb_timer);
+				} else {
+					info = drvdata->info[fb_num];
+					par  = (mp200_fb_par *)info->par;
+
+					printk_dbg((_DEBUG_FB & 0x10),
+					 "queue_work\n");
+					queue_work(par->mp200_fb_workqueue,
+					&par->wk_timeout_update_bottom_half);
+				}
+			}
+		}
+	}
+	return 0;
+}
+#endif /* CONFIG_PM || CONFIG_DPM */
+
+
+MODULE_AUTHOR("NEC Electronics Corporation.");
+MODULE_DESCRIPTION("EM1 framebuffer driver");
+MODULE_LICENSE("GPL");
+
+
+/* function alias  */
+module_init(mp200_fb_init_module);
+
+
diff --git a/drivers/video/mp200/mp200_fb.h b/drivers/video/mp200/mp200_fb.h
new file mode 100644
index 0000000..8b65df4
--- /dev/null
+++ b/drivers/video/mp200/mp200_fb.h
@@ -0,0 +1,50 @@
+/*
+ * File Name       : /drivers/video/mp200/mp200_fb.h
+ * Function        : Frame Buffer Driver corresponding to V4L2  definitions
+ * Release Version :
+ * Release Date    : 2009.10.21
+ *
+ * Copyright (C) NEC Electronics Corporation 2009
+ *
+ *
+ * This program is free software;you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by Free Softwere
+ * Foundation; either version 2 of License, or (at your option) any later
+ * version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warrnty of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
+ * details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; If not, write to the Free Software Foundation, Inc., 59 Temple
+ * Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#ifndef _MP200_FB_H_
+#define _MP200_FB_H_
+
+
+/********************************************************
+ *  Variables                                           *
+ *******************************************************/
+/* image infomation to LCD */
+extern FB_IMAGE_INFO  fb_image_info;
+
+/* Smem */
+extern char   *SmemV;
+
+
+/********************************************************
+ *  Prototype declarations of function                  *
+ *******************************************************/
+
+extern int mp200_fb_ioctl(struct fb_info *info, unsigned int cmd,
+ unsigned long arg);
+extern int mp200_fb_mmap(struct fb_info *info, struct vm_area_struct *vma);
+extern void mp200_fb_callback(int iWrittenFBNo, int iMixModeStatus, int fb_num);
+extern int __init mp200_fb_init_moddule(void);
+
+#endif /* _MP200_FB_H_ */
diff --git a/drivers/video/mp200/mp200_imc.c b/drivers/video/mp200/mp200_imc.c
new file mode 100644
index 0000000..b7729a9
--- /dev/null
+++ b/drivers/video/mp200/mp200_imc.c
@@ -0,0 +1,1210 @@
+/*
+ * File Name       : /drivers/video/mp200/mp200_imc.c
+ * Function        : IMC driver corresponding to V4L2
+ * Release Version :
+ * Release Date    : 2009.10.21
+ *
+ * Copyright (C) NEC Electronics Corporation 2009
+ *
+ *
+ * This program is free software;you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by Free Softwere
+ * Foundation; either version 2 of License, or (at your option) any later
+ * version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warrnty of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
+ * details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; If not, write to the Free Software Foundation, Inc., 59 Temple
+ * Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+/********************************************************
+ *  Include Files                                       *
+ *******************************************************/
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/version.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/init.h>
+#include <linux/ioport.h>
+#include <linux/device.h>
+#include <linux/err.h>
+#include <linux/platform_device.h>
+#include <linux/io.h>
+
+#if defined(CONFIG_PM) || defined(CONFIG_DPM)
+#include <mach/pm.h>
+#endif /* CONFIG_PM || CONFIG_DPM */
+
+#include <mach/hardware.h>
+#include <mach/irqs.h>
+#include <mach/pmu.h>
+#include <mach/em1_mem.h>
+
+#include "imc.h"
+#include "mp200_imc.h"
+#include "mp200_common.h"
+
+
+/********************************************************
+ *  Definitions                                         *
+ *******************************************************/
+#define _DEBUG_IMC  0x00 /* 00008421(bit) */
+			 /* 0x01: debug function in
+			  * 0x02: debug function out
+			  */
+
+#define LCD_ASYNCHRONOUS 0 /* 0: LCD-IMC synchronous mode
+			    * 1: LCD-IMC asynchronous mode
+			    */
+
+
+/********************************************************
+ *  Definitions                                         *
+ *******************************************************/
+#define DEV_NAME "mp200_imc"
+#define DPM_SUSPEND_FLG_INIT 0
+#define CTRL_FUNC_INIT 0
+
+
+/********************************************************
+ *  Macros                                              *
+ *******************************************************/
+#define printk_err(fmt, arg...) \
+	do {                     \
+		printk(KERN_ERR DEV_NAME ": %s: " fmt, __func__, ## arg); \
+	} while (0)
+
+#define printk_info(fmt, arg...) \
+	do {                      \
+		printk(KERN_INFO DEV_NAME ": " fmt, ## arg); \
+	} while (0)
+
+#if _DEBUG_IMC
+#define printk_dbg(level, fmt, arg...) \
+	do {                            \
+		if (level > 0) \
+			printk(KERN_DEBUG DEV_NAME ": %s: " fmt, \
+				__func__, ## arg); \
+	} while (0)
+#else
+#define printk_dbg(level, fmt, arg...) \
+	;
+#endif
+
+/********************************************************
+ *  Structure                                           *
+ *******************************************************/
+struct mp200_imc_device {
+	unsigned long             IMCMmio;
+	unsigned long             IMCMmioLength;
+	char                     *IMCMmioV;
+
+	spinlock_t                imc_hw_lock;
+
+	int                       chk_preset;
+
+	imc_callback_func_refresh callback_func_refresh;
+	imc_callback_func_wb      callback_func_wb;
+};
+
+
+/********************************************************
+ *  Variables                                           *
+ *******************************************************/
+static struct mp200_imc_device *dev;
+
+
+/********************************************************
+ *  Prototype declarations of local function            *
+ *******************************************************/
+/* ----- internal function --------------------------- */
+static int         imc_hw_init(void);
+static void        imc_hw_int_enable(void);
+static void        imc_hw_int_disable(void);
+#if LCD_ASYNCHRONOUS /* this function checked to IMC-LCD asynchronous mode. */
+static int         imc_hw_chk_startmode(void);
+#endif
+static int         imc_hw_chk_busy(void);
+#if defined(CONFIG_PM) || defined(CONFIG_DPM)
+static int         imc_hw_chk_status(void);
+#endif /* CONFIG_PM || CONFIG_DPM */
+
+/* ----- IMC IRQ handler ----------------------------- */
+static irqreturn_t imc_irq_handler(int irq, void *dev_id);
+static void        imc_irq_handler_sub(int irq, void *dev_id);
+
+/* ----- suspend/resume function ------------------------------------------- */
+#if defined(CONFIG_PM) || defined(CONFIG_DPM)
+static void        imc_resume_kick(unsigned long num);
+
+/* Tasklet */
+static DECLARE_TASKLET(imc_nexttask, imc_resume_kick, 0);
+
+/* Flags */
+static int DPM_suspend_flg = DPM_SUSPEND_FLG_INIT;
+static int ctrl_func       = CTRL_FUNC_INIT;
+
+/* Macro */
+#define Call_StatusCtrlFunc_ON()  \
+	do { ctrl_func = 1; } while (0)
+#define Call_StatusCtrlFunc_OFF() \
+	do { ctrl_func = 0; } while (0)
+#else
+#define Call_StatusCtrlFunc_ON()
+#define Call_StatusCtrlFunc_OFF()
+#endif /* CONFIG_PM || CONFIG_DPM */
+
+
+/* ----- external function ------------------------------------------------- */
+/******************************************************************************
+* MODULE   : mp200_imc_set_preset
+* FUNCTION :
+* RETURN   :   0: success
+*          : -16: EBUSY
+*          : -22: EINVAL
+* NOTE     : none
+* CREATE   : 2007.06.21 M.Haguro
+* UPDATE   :
+******************************************************************************/
+int  mp200_imc_set_preset(struct mp200_imc_preset *imc_preset, int setmode)
+{
+	unsigned long flags;
+	int    gamma_cnt = 0;
+
+	printk_dbg((_DEBUG_IMC & 0x01), "in\n");
+
+	if (!imc_preset) {
+		printk_err("error! imc_preset(NULL)\n");
+		return -EINVAL;
+	}
+
+	if (setmode) {
+		/* IMC STATUS STOP WAITING */
+		while (readl(dev->IMCMmioV + IMC_STATUS) != IMC_STATUS_STOP)
+			msleep(1);
+	}
+
+	/*>>>>>> interuppt disable */
+	spin_lock_irqsave(&dev->imc_hw_lock, flags);
+
+	/* Function Settings Register */
+	if (imc_preset->imc_control) {
+		/* IMC Control                  */
+		writel(*imc_preset->imc_control, dev->IMCMmioV + IMC_CONTROL);
+	}
+
+	if (imc_preset->gamma) {
+		unsigned long *data = imc_preset->gamma->data;
+		/* Gamma Control Register */
+		if (imc_preset->gamma->en == IMC_GAMMAEN_ON) {
+			unsigned long ulRegVal;
+
+			ulRegVal = readl(dev->IMCMmioV + IMC_CONTROL);
+
+			/* IMC Control                  */
+			writel(ulRegVal & ~IMC_CLKCNT_GAMMA_ON,
+			 dev->IMCMmioV + IMC_CONTROL);
+			/* Gamma Correction Control     */
+			writel(IMC_GAMMAEN_OFF, dev->IMCMmioV + IMC_GAMMA_EN);
+
+			/* Gamma Control Table */
+			/* Gamma Control Table Address  */
+			writel(imc_preset->gamma->adr,
+			 dev->IMCMmioV + IMC_GAMMA_ADR);
+			for (gamma_cnt = 0; gamma_cnt < 64;
+				gamma_cnt++ , data++) {
+				/* Gamma Control Table Data     */
+				writel(*data, dev->IMCMmioV + IMC_GAMMA_DATA);
+			}
+
+			/* IMC Control                  */
+			writel(ulRegVal, dev->IMCMmioV + IMC_CONTROL);
+		}
+		/* Gamma Correction Control     */
+		writel(imc_preset->gamma->en, dev->IMCMmioV + IMC_GAMMA_EN);
+	}
+
+#if LCD_ASYNCHRONOUS /* this function checked to IMC-LCD asynchronous mode. */
+	if (imc_preset->wb && imc_hw_chk_startmode()) {
+#else
+	if (imc_preset->wb) {
+#endif
+		unsigned long wb_size;
+
+		wb_size = ((imc_preset->wb->vsize << IMC_WB_VSIZE_SFT)
+		 | imc_preset->wb->hsize);
+
+		/* Start Exclusive Use Immediately Setting Register */
+		/* WB Display Area Address      */
+		writel(imc_preset->wb->areaadr, dev->IMCMmioV + IMC_WB_AREADDR);
+		/* WB Address Increment Value   */
+		writel(imc_preset->wb->hoffset, dev->IMCMmioV + IMC_WB_HOFFSET);
+		/* WB Format                    */
+		writel(imc_preset->wb->format, dev->IMCMmioV + IMC_WB_FORMAT);
+		/* WB Image Size                */
+		writel(wb_size, dev->IMCMmioV + IMC_WB_SIZE);
+	}
+
+	if (imc_preset->yuv) {
+		/* All Layer Setting Register */
+		/* Y Gain Offset                */
+		writel(imc_preset->yuv->ygain, dev->IMCMmioV + IMC_YGAINOFFSET);
+		/* U Gain Offset                */
+		writel(imc_preset->yuv->ugain, dev->IMCMmioV + IMC_UGAINOFFSET);
+		/* V Gain Offset                */
+		writel(imc_preset->yuv->vgain, dev->IMCMmioV + IMC_VGAINOFFSET);
+		/* YUV to RGB Conversion method */
+		writel(imc_preset->yuv->yuv2rgb, dev->IMCMmioV + IMC_YUV2RGB);
+
+		if ((imc_preset->yuv->yuv2rgb & IMC_TRANS_MODE_BIT) ==
+			IMC_TRANS_MODE_CUSTOM1 ||
+			(imc_preset->yuv->yuv2rgb & IMC_TRANS_MODE_BIT) ==
+			IMC_TRANS_MODE_CUSTOM2) {
+			/* IMC_YUV2RGB Register selected Custom factor */
+			/* Custom factor (Coef R0)      */
+			writel(imc_preset->yuv->coef_r[0],
+			 dev->IMCMmioV + IMC_COEF_R0);
+			/* Custom factor (Coef R1)      */
+			writel(imc_preset->yuv->coef_r[1],
+			 dev->IMCMmioV + IMC_COEF_R1);
+			/* Custom factor (Coef R2)      */
+			writel(imc_preset->yuv->coef_r[2],
+			 dev->IMCMmioV + IMC_COEF_R2);
+			/* Custom factor (Coef R3)      */
+			writel(imc_preset->yuv->coef_r[3],
+			 dev->IMCMmioV + IMC_COEF_R3);
+
+			/* Custom factor (Coef G0)      */
+			writel(imc_preset->yuv->coef_g[0],
+			 dev->IMCMmioV + IMC_COEF_G0);
+			/* Custom factor (Coef G1)      */
+			writel(imc_preset->yuv->coef_g[1],
+			 dev->IMCMmioV + IMC_COEF_G1);
+			/* Custom factor (Coef G2)      */
+			writel(imc_preset->yuv->coef_g[2],
+			 dev->IMCMmioV + IMC_COEF_G2);
+			/* Custom factor (Coef G3)      */
+			writel(imc_preset->yuv->coef_g[3],
+			 dev->IMCMmioV + IMC_COEF_G3);
+
+			/* Custom factor (Coef B0)      */
+			writel(imc_preset->yuv->coef_b[0],
+			 dev->IMCMmioV + IMC_COEF_B0);
+			/* Custom factor (Coef B1)      */
+			writel(imc_preset->yuv->coef_b[1],
+			 dev->IMCMmioV + IMC_COEF_B1);
+			/* Custom factor (Coef B2)      */
+			writel(imc_preset->yuv->coef_b[2],
+			 dev->IMCMmioV + IMC_COEF_B2);
+			/* Custom factor (Coef B3)      */
+			writel(imc_preset->yuv->coef_b[3],
+			 dev->IMCMmioV + IMC_COEF_B3);
+		}
+	}
+
+	if (imc_preset->keycolor) {
+		/* Colorkey Register(Layer0, Layer1X) */
+		/* Layer0  Color Key            */
+		writel(imc_preset->keycolor->l0_keycolor,
+		 dev->IMCMmioV + IMC_L0_KEYCOLOR);
+		/* Layer1x Color Key            */
+		writel(imc_preset->keycolor->l1x_keycolor,
+		 dev->IMCMmioV + IMC_L1X_KEYCOLOR);
+		printk_dbg((_DEBUG_IMC & 0x04), "l0_keycolor(%08lx)\n",
+		 imc_preset->keycolor->l0_keycolor);
+		printk_dbg((_DEBUG_IMC & 0x04), "l1_keycolor(%08lx)\n",
+		 imc_preset->keycolor->l1x_keycolor);
+	}
+
+	if (imc_preset->bytelane) {
+		/* Bytelane Register(Layer2a, Layer2b) */
+		/* Layer2A Bytelane             */
+		writel(imc_preset->bytelane->l2a_bytelane,
+		 dev->IMCMmioV + IMC_L2A_BYTELANE);
+		/* Layer2B Bytelane             */
+		writel(imc_preset->bytelane->l2b_bytelane,
+		 dev->IMCMmioV + IMC_L2B_BYTELANE);
+		printk_dbg((_DEBUG_IMC & 0x04), "l2a_bytelane(%08lx)\n",
+		 imc_preset->bytelane->l2a_bytelane);
+		printk_dbg((_DEBUG_IMC & 0x04), "l2b_bytelane(%08lx)\n",
+		 imc_preset->bytelane->l2b_bytelane);
+	}
+
+	dev->chk_preset = 1;
+
+	/*<<<<<< interuppt enable */
+	spin_unlock_irqrestore(&dev->imc_hw_lock, flags);
+
+	printk_dbg((_DEBUG_IMC & 0x02), "out\n");
+	return 0;
+}
+
+
+/******************************************************************************
+* MODULE   : mp200_imc_set_update_vsync
+* FUNCTION :
+* RETURN   :   0: success
+*          : -13: EACCESS
+*          : -22: EINVAL
+* NOTE     : none
+* CREATE   : 2007.06.21 M.Haguro
+* UPDATE   :
+******************************************************************************/
+int  mp200_imc_set_update_vsync(struct mp200_imc_update_vsync *imc_vsync)
+{
+	unsigned long flags;
+
+	printk_dbg((_DEBUG_IMC & 0x01), "in\n");
+
+	if (!imc_vsync) {
+		printk_err("error! imc_vsync(NULL)\n");
+		return -EINVAL;
+	}
+
+	if (!dev->chk_preset) {
+		printk_err("error! need to \"mp200_imc_preset()\"\n");
+		return -EACCES;
+	}
+
+	/*>>>>>> interuppt disable */
+	spin_lock_irqsave(&dev->imc_hw_lock, flags);
+
+	/* Double Buffer Control                  */
+	writel(imc_vsync->cpubufsel,	dev->IMCMmioV + IMC_CPUBUFSEL);
+	/* Horizontal, Vertical Mirroring Control */
+	writel(imc_vsync->mirror,	dev->IMCMmioV + IMC_MIRROR);
+
+	/*<<<<<< interuppt enable */
+	spin_unlock_irqrestore(&dev->imc_hw_lock, flags);
+
+	printk_dbg((_DEBUG_IMC & 0x02), "out\n");
+	return 0;
+}
+
+
+/******************************************************************************
+* MODULE   : mp200_imc_set_update_reserve
+* FUNCTION :
+* RETURN   :   0: success
+*          : -13: EACCESS
+*          : -16: EBUSY
+*          : -22: EINVAL
+* NOTE     : none
+* CREATE   : 2007.06.21 M.Haguro
+* UPDATE   :
+******************************************************************************/
+int  mp200_imc_set_update_reserve(struct mp200_imc_update_reserve *imc_reserve,
+ imc_callback_func_refresh callback_refresh)
+{
+	unsigned long flags;
+
+	printk_dbg((_DEBUG_IMC & 0x01), "in\n");
+
+	/* register REFRESH */
+	writel(IMC_UPDATE_OFF,	dev->IMCMmioV + IMC_REFRESH);
+
+	if (!imc_reserve) {
+		printk_err("error! imc_reserve(NULL)\n");
+		return -EINVAL;
+	}
+
+	if (!dev->chk_preset) {
+		printk_err("error! need to \"mp200_imc_preset()\"\n");
+		return -EACCES;
+	}
+
+	if (!callback_refresh) {
+		printk_err("error! imc_callback_func_refresh "
+		"		is invalid address\n");
+		return -EINVAL;
+	}
+
+	/*>>>>>> interuppt disable */
+	spin_lock_irqsave(&dev->imc_hw_lock, flags);
+
+	if (imc_reserve->lo) {
+		/*** Layer0 Setting Register ***/
+		/* Layer0 Control                  */
+		writel(imc_reserve->lo->control,
+		 dev->IMCMmioV + IMC_L0_CONTROL);
+		/* Layer0 Format                   */
+		writel(imc_reserve->lo->format, dev->IMCMmioV + IMC_L0_FORMAT);
+		/* Layer0 Color Key Control        */
+		writel(imc_reserve->lo->keyenable,
+		 dev->IMCMmioV + IMC_L0_KEYENABLE);
+		/* Layer0 Alpha                    */
+		writel(imc_reserve->lo->alpha, dev->IMCMmioV + IMC_L0_ALPHA);
+		/* Layer0 Resize                   */
+		writel(imc_reserve->lo->resize, dev->IMCMmioV + IMC_L0_RESIZE);
+		/* Layer0 Address increment value  */
+		writel(imc_reserve->lo->offset, dev->IMCMmioV + IMC_L0_OFFSET);
+		/* Layer0 Address                  */
+		writel(imc_reserve->lo->frameadr,
+		 dev->IMCMmioV + IMC_L0_FRAMEADR);
+		/* Layer0 LCD Out Positon          */
+		writel(imc_reserve->lo->position,
+		 dev->IMCMmioV + IMC_L0_POSITION);
+		/* Layer0 LCD Out Size             */
+		writel(imc_reserve->lo->size, dev->IMCMmioV + IMC_L0_SIZE);
+	}
+
+	if (imc_reserve->l1a) {
+		/*** Layer1a Setting Register ***/
+		/* Layer1A Control                 */
+		writel(imc_reserve->l1a->control,
+		 dev->IMCMmioV + IMC_L1A_CONTROL);
+		/* Layer1A Format                  */
+		writel(imc_reserve->l1a->format,
+		 dev->IMCMmioV + IMC_L1X_FORMAT);
+		/* Layer1A Color Key Control       */
+		writel(imc_reserve->l1a->keyenable,
+		 dev->IMCMmioV + IMC_L1A_KEYENABLE);
+		/* Layer1A Alpha                   */
+		writel(imc_reserve->l1a->alpha, dev->IMCMmioV + IMC_L1A_ALPHA);
+		/* Layer1A Resize                  */
+		writel(imc_reserve->l1a->resize,
+		 dev->IMCMmioV + IMC_L1X_RESIZE);
+		/* Layer1A Address increment value */
+		writel(imc_reserve->l1a->offset,
+		 dev->IMCMmioV + IMC_L1X_OFFSET);
+		/* Layer1A Address                 */
+		writel(imc_reserve->l1a->frameadr,
+		 dev->IMCMmioV + IMC_L1A_FRAMEADR);
+		/* Layer1A LCD Out Positon         */
+		writel(imc_reserve->l1a->position,
+		 dev->IMCMmioV + IMC_L1A_POSITION);
+		/* Layer1A LCD Out Size            */
+		writel(imc_reserve->l1a->size, dev->IMCMmioV + IMC_L1A_SIZE);
+	}
+
+	if (imc_reserve->l1b) {
+		/*** Layer1b Setting Register ***/
+		/* Layer1B Control                 */
+		writel(imc_reserve->l1b->control,
+		 dev->IMCMmioV + IMC_L1B_CONTROL);
+		/* Layer1B Color Key Control       */
+		writel(imc_reserve->l1b->keyenable,
+		 dev->IMCMmioV + IMC_L1B_KEYENABLE);
+		/* Layer1B Alpha                   */
+		writel(imc_reserve->l1b->alpha, dev->IMCMmioV + IMC_L1B_ALPHA);
+		/* Layer1B Address                 */
+		writel(imc_reserve->l1b->frameadr,
+		 dev->IMCMmioV + IMC_L1B_FRAMEADR);
+		/* Layer1B LCD Out Positon         */
+		writel(imc_reserve->l1b->position,
+		 dev->IMCMmioV + IMC_L1B_POSITION);
+		/* Layer1B LCD Out Size            */
+		writel(imc_reserve->l1b->size, dev->IMCMmioV + IMC_L1B_SIZE);
+	}
+
+	if (imc_reserve->l1c) {
+		/*** Layer1c Setting Register ***/
+		/* Layer1C Control                 */
+		writel(imc_reserve->l1c->control,
+		 dev->IMCMmioV + IMC_L1C_CONTROL);
+		/* Layer1C Color Key Control       */
+		writel(imc_reserve->l1c->keyenable,
+		 dev->IMCMmioV + IMC_L1C_KEYENABLE);
+		/* Layer1C Alpha                   */
+		writel(imc_reserve->l1c->alpha, dev->IMCMmioV + IMC_L1C_ALPHA);
+		/* Layer1C Address                 */
+		writel(imc_reserve->l1c->frameadr,
+		 dev->IMCMmioV + IMC_L1C_FRAMEADR);
+		/* Layer1C LCD Out Positon         */
+		writel(imc_reserve->l1c->position,
+		 dev->IMCMmioV + IMC_L1C_POSITION);
+		/* Layer1C LCD Out Size            */
+		writel(imc_reserve->l1c->size, dev->IMCMmioV + IMC_L1C_SIZE);
+	}
+
+	if (imc_reserve->l2a) {
+		/*** Layer2a Setting Register ***/
+		/* Layer2A Control                 */
+		writel(imc_reserve->l2a->control,
+		 dev->IMCMmioV + IMC_L2A_CONTROL);
+		/* Layer2A Format                  */
+		writel(imc_reserve->l2a->format,
+		 dev->IMCMmioV + IMC_L2A_FORMAT);
+		/* Layer2A Double Buffer Control   */
+		writel(imc_reserve->l2a->bufsel,
+		 dev->IMCMmioV + IMC_L2A_BUFSEL);
+		/* Layer2A Resize                  */
+		writel(imc_reserve->l2a->resize,
+		 dev->IMCMmioV + IMC_L2A_RESIZE);
+		/* Layer2A Horizontal, Vertical Mirroring Control */
+		writel(imc_reserve->l2a->mirror,
+		 dev->IMCMmioV + IMC_L2A_MIRROR);
+		/* Layer2A Address increment value */
+		writel(imc_reserve->l2a->offset,
+		 dev->IMCMmioV + IMC_L2A_OFFSET);
+		/* Layer2A Address (YP)            */
+		writel(imc_reserve->l2a->frameadr_yp,
+		 dev->IMCMmioV + IMC_L2A_FRAMEADR_YP);
+		/* Layer2A Address (UP)            */
+		writel(imc_reserve->l2a->frameadr_up,
+		 dev->IMCMmioV + IMC_L2A_FRAMEADR_UP);
+		/* Layer2A Address (VP)            */
+		writel(imc_reserve->l2a->frameadr_vp,
+		 dev->IMCMmioV + IMC_L2A_FRAMEADR_VP);
+		/* Layer2A Address (YQ)            */
+		writel(imc_reserve->l2a->frameadr_yq,
+		 dev->IMCMmioV + IMC_L2A_FRAMEADR_YQ);
+		/* Layer2A Address (UQ)            */
+		writel(imc_reserve->l2a->frameadr_uq,
+		 dev->IMCMmioV + IMC_L2A_FRAMEADR_UQ);
+		/* Layer2A Address (VQ)            */
+		writel(imc_reserve->l2a->frameadr_vq,
+		 dev->IMCMmioV + IMC_L2A_FRAMEADR_VQ);
+		/* Layer2A LCD Out Positon         */
+		writel(imc_reserve->l2a->position,
+		 dev->IMCMmioV + IMC_L2A_POSITION);
+		/* Layer2A LCD Out Size            */
+		writel(imc_reserve->l2a->size, dev->IMCMmioV + IMC_L2A_SIZE);
+	}
+
+	if (imc_reserve->l2b) {
+		/*** Layer2b Setting Register ***/
+		/* Layer2B Control                 */
+		writel(imc_reserve->l2b->control,
+		 dev->IMCMmioV + IMC_L2B_CONTROL);
+		/* Layer2B Format                  */
+		writel(imc_reserve->l2b->format,
+		 dev->IMCMmioV + IMC_L2B_FORMAT);
+		/* Layer2B Double Buffer Control   */
+		writel(imc_reserve->l2b->bufsel,
+		 dev->IMCMmioV + IMC_L2B_BUFSEL);
+		/* Layer2B Resize                  */
+		writel(imc_reserve->l2b->resize,
+		 dev->IMCMmioV + IMC_L2B_RESIZE);
+		/* Layer2B Horizontal, Vertical Mirroring Control */
+		writel(imc_reserve->l2b->mirror,
+		 dev->IMCMmioV + IMC_L2B_MIRROR);
+		/* Layer2B Address increment value */
+		writel(imc_reserve->l2b->offset,
+		 dev->IMCMmioV + IMC_L2B_OFFSET);
+		/* Layer2B Address (YP)            */
+		writel(imc_reserve->l2b->frameadr_yp,
+		 dev->IMCMmioV + IMC_L2B_FRAMEADR_YP);
+		/* Layer2B Address (UP)            */
+		writel(imc_reserve->l2b->frameadr_up,
+		 dev->IMCMmioV + IMC_L2B_FRAMEADR_UP);
+		/* Layer2B Address (VP)            */
+		writel(imc_reserve->l2b->frameadr_vp,
+		 dev->IMCMmioV + IMC_L2B_FRAMEADR_VP);
+		/* Layer2B Address (YQ)            */
+		writel(imc_reserve->l2b->frameadr_yq,
+		 dev->IMCMmioV + IMC_L2B_FRAMEADR_YQ);
+		/* Layer2B Address (UQ)            */
+		writel(imc_reserve->l2b->frameadr_uq,
+		 dev->IMCMmioV + IMC_L2B_FRAMEADR_UQ);
+		/* Layer2B Address (VQ)            */
+		writel(imc_reserve->l2b->frameadr_vq,
+		 dev->IMCMmioV + IMC_L2B_FRAMEADR_VQ);
+		/* Layer2B LCD Out Positon         */
+		writel(imc_reserve->l2b->position,
+		 dev->IMCMmioV + IMC_L2B_POSITION);
+		/* Layer2B LCD Out Size            */
+		writel(imc_reserve->l2b->size, dev->IMCMmioV + IMC_L2B_SIZE);
+	}
+
+	if (imc_reserve->bg) {
+		/*** LayerBG Setting Register ***/
+		/* LayerBG Format                  */
+		writel(imc_reserve->bg->format, dev->IMCMmioV + IMC_BG_FORMAT);
+		/* LayerBG Resize                  */
+		writel(imc_reserve->bg->resize, dev->IMCMmioV + IMC_BG_RESIZE);
+		/* LayerBG Address increment value */
+		writel(imc_reserve->bg->offset, dev->IMCMmioV + IMC_BG_OFFSET);
+		/* LayerBG Address                 */
+		writel(imc_reserve->bg->frameadr,
+		 dev->IMCMmioV + IMC_BG_FRAMEADR);
+	}
+
+	dev->callback_func_refresh = callback_refresh;
+
+	imc_hw_int_enable();
+
+	/* register REFRESH */
+	writel(IMC_UPDATE_ON,	dev->IMCMmioV + IMC_REFRESH);
+
+	/*<<<<<< interuppt enable */
+	spin_unlock_irqrestore(&dev->imc_hw_lock, flags);
+
+	printk_dbg((_DEBUG_IMC & 0x02), "out\n");
+	return 0;
+}
+
+
+#if LCD_ASYNCHRONOUS /* this function checked to IMC-LCD asynchronous mode. */
+/******************************************************************************
+* MODULE   : mp200_imc_start
+* FUNCTION : this function used in IMC-LCD asynchronous mode.
+* RETURN   :   0: success
+*          : -13: EACCES
+*          : -16: EBUSY
+* NOTE     : none
+* CREATE   : 2007.06.21 M.Haguro
+* UPDATE   :
+******************************************************************************/
+int  mp200_imc_start(void)
+{
+	unsigned long flags;
+
+	printk_dbg((_DEBUG_IMC & 0x01), "in\n");
+
+	if (!imc_hw_chk_startmode()) {
+		printk_err("error! IMC_CONTROL is \"LCD SYNCRO MODE\"\n");
+		return -EACCES;
+	}
+
+	if (!dev->chk_preset) {
+		printk_err("error! need to \"mp200_imc_preset()\"\n");
+		return -EACCES;
+	}
+
+	if (imc_hw_chk_busy()) {
+		/* IMC running */
+		printk_err("IMC WORKING NOW\n");
+		return -EBUSY;
+	}
+
+	/*>>>>>> interuppt disable */
+	spin_lock_irqsave(&dev->imc_hw_lock, flags);
+
+	imc_hw_int_enable();
+
+	/* Start to IMC */
+	writel(IMC_IMCSTART_ON, dev->IMCMmioV + IMC_START);
+
+	/*<<<<<< interuppt enable */
+	spin_unlock_irqrestore(&dev->imc_hw_lock, flags);
+
+	printk_dbg((_DEBUG_IMC & 0x02), "out\n");
+	return 0;
+}
+#endif
+
+
+/******************************************************************************
+* MODULE   : mp200_imc_set_callback
+* FUNCTION :
+* RETURN   :   0: success
+*          : -22: EINVAL : callback is invalid adrress
+* NOTE     : none
+* CREATE   : 2007.06.21 M.Haguro
+* UPDATE   :
+******************************************************************************/
+int mp200_imc_set_callback(imc_callback_func_refresh callback_refresh,
+ imc_callback_func_wb callback_wb)
+{
+	printk_dbg((_DEBUG_IMC & 0x01), "in\n");
+
+	if (!callback_refresh) {
+		printk_err("error! imc_callback_func_refresh is "
+			"invalid address\n");
+		return -EINVAL;
+	}
+	if (!callback_wb) {
+		printk_err("error! imc_callback_func_wb is invalid address\n");
+		return -EINVAL;
+	}
+
+	dev->callback_func_refresh = callback_refresh;
+	dev->callback_func_wb      = callback_wb;
+	printk_dbg((_DEBUG_IMC & 0x02), "out\n");
+	return 0;
+}
+
+
+/* ----- internal function ------------------------------------------------- */
+/******************************************************************************
+* MODULE   : imc_hw_init
+* FUNCTION :
+* RETURN   :   0: success
+*          : -16: EBUSY
+* NOTE     : none
+* CREATE   : 2007.06.15 M.Haguro
+* UPDATE   :
+******************************************************************************/
+static int imc_hw_init(void)
+{
+	unsigned long flags;
+
+	printk_dbg((_DEBUG_IMC & 0x01), "in\n");
+
+	if (imc_hw_chk_busy()) {
+		/* IMC running */
+		printk_err("IMC WORKING NOW\n");
+		return -EBUSY;
+	}
+
+	/*>>>>>> interuppt disable */
+	spin_lock_irqsave(&dev->imc_hw_lock, flags);
+
+	imc_hw_unreset();
+
+	imc_hw_int_disable();
+
+	/*<<<<<< interuppt enable */
+	spin_unlock_irqrestore(&dev->imc_hw_lock, flags);
+
+	printk_dbg((_DEBUG_IMC & 0x02), "out\n");
+	return 0;
+}
+
+
+/******************************************************************************
+* MODULE   : imc_hw_reset
+* FUNCTION : reset IMC module
+* RETURN   : none
+* NOTE     : none
+* CREATE   : 2007.06.18 M.Haguro
+* UPDATE   :
+******************************************************************************/
+void imc_hw_reset(void)
+{
+	printk_dbg((_DEBUG_IMC & 0x01), "in\n");
+
+	/* Reset IMC */
+	mp200_pmu_clkctrl_off(MP200_CLKCTRL_IMC);
+	mp200_pmu_clkctrl_off(MP200_CLKCTRL_IMCPCLK);
+	mp200_pmu_reset_device(MP200_RESETDEVICE_IMC);
+	mp200_pmu_close_clockgate(MP200_CLOCKGATE_IMC_CLK);
+	mp200_pmu_close_clockgate(MP200_CLOCKGATE_IMC_PCLK);
+
+	printk_dbg((_DEBUG_IMC & 0x02), "out\n");
+}
+
+
+/******************************************************************************
+* MODULE   : imc_hw_unreset
+* FUNCTION : un-reset IMC module
+* RETURN   : none
+* NOTE     : none
+* CREATE   : 2007.06.18 M.Haguro
+* UPDATE   :
+******************************************************************************/
+void imc_hw_unreset(void)
+{
+	printk_dbg((_DEBUG_IMC & 0x01), "in\n");
+
+	/* UnReset IMC */
+	mp200_pmu_open_clockgate(MP200_CLOCKGATE_IMC_PCLK);
+	mp200_pmu_open_clockgate(MP200_CLOCKGATE_IMC_CLK);
+	mp200_pmu_clkctrl_off(MP200_CLKCTRL_IMC);
+	mp200_pmu_clkctrl_off(MP200_CLKCTRL_IMCPCLK);
+	mp200_pmu_unreset_device(MP200_RESETDEVICE_IMC);
+	mp200_pmu_clkctrl_on(MP200_CLKCTRL_IMC);
+	mp200_pmu_clkctrl_on(MP200_CLKCTRL_IMCPCLK);
+
+	printk_dbg((_DEBUG_IMC & 0x02), "out\n");
+}
+
+
+/******************************************************************************
+* MODULE   : imc_hw_int_enable
+* FUNCTION :
+* RETURN   : none
+* NOTE     : none
+* CREATE   : 2007.06.20 M.Haguro
+* UPDATE   :
+******************************************************************************/
+static void imc_hw_int_enable(void)
+{
+
+	printk_dbg((_DEBUG_IMC & 0x01), "in\n");
+
+	/* Interuppt Control Register */
+	/* Interuppt Enable Set   */
+	writel(IMC_INTENSET_ALL_BIT, dev->IMCMmioV + IMC_INTENSET);
+
+	printk_dbg((_DEBUG_IMC & 0x02), "out\n");
+}
+
+
+/******************************************************************************
+* MODULE   : imc_hw_int_disable
+* FUNCTION :
+* RETURN   : none
+* NOTE     : none
+* CREATE   : 2007.06.20 M.Haguro
+* UPDATE   :
+******************************************************************************/
+static void imc_hw_int_disable(void)
+{
+	printk_dbg((_DEBUG_IMC & 0x01), "in\n");
+
+	/* Interuppt Control Register */
+	/* Interuppt Enable Clear */
+	writel(IMC_INTENCLR_ALL_BIT, dev->IMCMmioV + IMC_INTENCLR);
+	/* Interuppt FF Clear     */
+	writel(IMC_INTFFCLR_ALL_BIT, dev->IMCMmioV + IMC_INTFFCLR);
+
+	printk_dbg((_DEBUG_IMC & 0x02), "out\n");
+}
+
+
+#if LCD_ASYNCHRONOUS /* this function checked to IMC-LCD asynchronous mode. */
+/******************************************************************************
+* MODULE   : imc_hw_chk_startmode
+* FUNCTION :
+* RETURN   : 0: LCD Syncro
+*          : 1: No Sync
+* NOTE     : none
+* CREATE   : 2007.06.22 M.Haguro
+* UPDATE   :
+******************************************************************************/
+static int imc_hw_chk_startmode(void)
+{
+	int iRet;
+	/* Control for IMC */
+	unsigned long ulRegVal32 = readl(dev->IMCMmioV + IMC_CONTROL);
+
+	printk_dbg((_DEBUG_IMC & 0x01), "in\n");
+	iRet = (((ulRegVal32 & IMC_START_MODE_BIT) == IMC_START_MODE_NOSYNC)
+			? 1 : 0);
+	printk_dbg((_DEBUG_IMC & 0x02), "out\n");
+
+	return iRet;
+}
+#endif
+
+
+/******************************************************************************
+* MODULE   : imc_hw_chk_busy
+* FUNCTION :
+* RETURN   :  0: IMC stop
+*          : -1: IMC busy
+* NOTE     : none
+* CREATE   : 2007.06.22 M.Haguro
+* UPDATE   :
+******************************************************************************/
+static int imc_hw_chk_busy(void)
+{
+	int iRet;
+	/* Status for IMC */
+	unsigned long ulRegVal32 = readl(dev->IMCMmioV + IMC_STATUS);
+
+	printk_dbg((_DEBUG_IMC & 0x01), "in\n");
+	iRet = (((ulRegVal32 & IMC_STATUS_BIT) == IMC_STATUS_STOP) ? 0 : -1);
+	printk_dbg((_DEBUG_IMC & 0x02), "out\n");
+
+	return iRet;
+}
+
+
+#if defined(CONFIG_PM) || defined(CONFIG_DPM)
+/******************************************************************************
+* MODULE   : imc_hw_chk_status
+* FUNCTION : enabled suspend
+* RETURN   :  0 : success
+*            -1 : failed
+* NOTE     : none
+* CREATE   : 2007.11.19 M.Haguro
+* UPDATE   :
+******************************************************************************/
+static int imc_hw_chk_status()
+{
+	int iRet, i = 0;
+
+	do {
+		iRet = imc_hw_chk_busy();
+		if (iRet == 0) {
+			i = 5;
+		} else if (i == 4) {
+			printk_err("imc_hw_chk_status\n");
+			Call_StatusCtrlFunc_OFF();
+			return -1;
+		} else {
+			Call_StatusCtrlFunc_ON();
+			mdelay(16);
+			i++;
+		}
+	} while (i < 5);
+
+	return 0;
+}
+#endif /* CONFIG_PM || CONFIG_DPM */
+
+
+/* ----- IMC IRQ handler --------------------------------------------------- */
+/******************************************************************************
+* MODULE   : imc_irq_handler
+* FUNCTION :
+* RETURN   : none
+* NOTE     : none
+* CREATE   : 2007.06.22 M.Haguro
+* UPDATE   :
+******************************************************************************/
+static irqreturn_t imc_irq_handler(int irq, void *dev_id)
+{
+	imc_irq_handler_sub(irq, dev_id);
+	return IRQ_HANDLED;
+}
+
+
+/******************************************************************************
+* MODULE   : imc_irq_handler_sub
+* FUNCTION :
+* RETURN   : none
+* NOTE     : none
+* CREATE   : 2007.07.06 M.Haguro
+* UPDATE   :
+******************************************************************************/
+static void imc_irq_handler_sub(int irq, void *dev_id)
+{
+	unsigned long ulRegVal32 = readl(dev->IMCMmioV + IMC_INTSTATUS);
+
+	printk_dbg((_DEBUG_IMC & 0x01), "in\n");
+
+	if (ulRegVal32 & (IMC_REFRESH_BIT | IMC_WBEND_BIT)) {
+		if (ulRegVal32 & IMC_REFRESH_BIT) {
+			printk_dbg((_DEBUG_IMC & 0x02), "IMC_REFRESH\n");
+			/* Interuppt FF Clear     */
+			writel(IMC_REFRESH_CLR_BIT,
+			 dev->IMCMmioV + IMC_INTFFCLR);
+			if (dev->callback_func_refresh)
+				(dev->callback_func_refresh)();
+#if LCD_ASYNCHRONOUS /* this function checked to IMC-LCD asynchronous mode. */
+			if (dev->callback_func_wb)
+				(dev->callback_func_wb)(ulRegVal32);
+#else
+		}
+		if (ulRegVal32 & IMC_WBEND_BIT) {
+			printk_dbg((_DEBUG_IMC & 0x02), "IMC_WBEND\n");
+			/* Interuppt FF Clear     */
+			writel(IMC_WBEND_CLR_BIT, dev->IMCMmioV + IMC_INTFFCLR);
+			if (dev->callback_func_wb)
+				(dev->callback_func_wb)(ulRegVal32);
+#endif
+		}
+	}
+
+	/* error interrupt */
+	else if (ulRegVal32 & IMC_AHBRERR_BIT) {
+		printk_err("IMC AHBR ERROR. Reset IMC.\n");
+		/* Interuppt FF Clear     */
+		writel(IMC_AHBRERR_CLR_BIT,	dev->IMCMmioV + IMC_INTFFCLR);
+		imc_hw_reset();
+		imc_hw_unreset();
+		dev->chk_preset = 0;
+		if (dev->callback_func_wb)
+			(dev->callback_func_wb)(ulRegVal32);
+
+	} else if (ulRegVal32 & IMC_AHBWERR_BIT) {
+		printk_err("IMC AHBW ERROR. Reset IMC.\n");
+		/* Interuppt FF Clear     */
+		writel(IMC_AHBWERR_CLR_BIT,	dev->IMCMmioV + IMC_INTFFCLR);
+		imc_hw_reset();
+		imc_hw_unreset();
+		dev->chk_preset = 0;
+		if (dev->callback_func_wb)
+			(dev->callback_func_wb)(ulRegVal32);
+
+	} else if (ulRegVal32 & IMC_OVERRUN_BIT) {
+		printk_err("IMC OVERRUN ERROR. Retry IMC.\n");
+		/* Interuppt FF Clear     */
+		writel(IMC_OVERRUN_CLR_BIT,	dev->IMCMmioV + IMC_INTFFCLR);
+	}
+
+	printk_dbg((_DEBUG_IMC & 0x02), "out\n");
+}
+
+
+
+
+#if defined(CONFIG_PM) || defined(CONFIG_DPM)
+/* ----- suspend/resume function ------------------------------------------- */
+/******************************************************************************
+* MODULE   : mp200_imc_suspend
+* FUNCTION : suspend IMC driver
+* RETURN   : none
+* NOTE     : none
+* CREATE   : 2007.11.06 M.haguro
+* UPDATE   :
+******************************************************************************/
+int mp200_imc_suspend(struct platform_device *dev, pm_message_t state)
+{
+	if (state.event == DEV_SUSPEND_IDLE_1) {
+		if (imc_hw_chk_busy())
+			return -EBUSY;
+		else
+			return 0;
+	} else {/* state.event == PM_EVENT_SUSPEND */
+
+		if (mp200_sleep_while_idle) {
+			return 0;
+		} else {
+			if (imc_hw_chk_status())
+				return -1;
+
+			DPM_suspend_flg = 1;
+			imc_hw_reset(); /* Reset IMC */
+			return 0;
+		}
+	}
+}
+
+
+/******************************************************************************
+* MODULE   : mp200_imc_resume
+* FUNCTION : suspend IMC driver
+* RETURN   : none
+* NOTE     : none
+* CREATE   : 2007.11.06 M.haguro
+* UPDATE   :
+******************************************************************************/
+int mp200_imc_resume(struct platform_device *dev)
+{
+	if (DPM_suspend_flg) {
+		DPM_suspend_flg = 0;
+		imc_hw_unreset(); /* UnReset IMC */
+
+		if (ctrl_func) {
+			/* start the next request */
+			tasklet_schedule(&imc_nexttask);
+		}
+	}
+	return 0;
+}
+
+
+/******************************************************************************
+* MODULE   : imc_resume_kick
+* FUNCTION : suspend IMC driver. call TASKLET
+* RETURN   : none
+* NOTE     : none
+* CREATE   : 2007.11.06 M.haguro
+* UPDATE   :
+******************************************************************************/
+static void imc_resume_kick(unsigned long num)
+{
+	Call_StatusCtrlFunc_OFF();
+
+	if (dev->callback_func_wb) {
+		printk_dbg((_DEBUG_IMC & 0x02), "\n");
+		(dev->callback_func_wb)(IMC_WBEND_BIT);
+	}
+}
+#endif /* CONFIG_PM || CONFIG_DPM */
+
+
+/* ----- init function ----------------------------------------------------- */
+/******************************************************************************
+* MODULE   : mp200_imc_init_module
+* FUNCTION :
+* RETURN   : 0    : success
+*            other: fail
+* NOTE     : none
+* CREATE   : 2007.06.15 M.Haguro
+* UPDATE   :
+******************************************************************************/
+int mp200_imc_init_module(void)
+{
+	int iRet = 0;
+
+	printk_dbg((_DEBUG_IMC & 0x01), "in\n");
+
+	/* allocate device infomation */
+	dev = kmalloc(sizeof(struct mp200_imc_device), GFP_KERNEL);
+	if (!dev) {
+		printk_err("could not allocate memory\n");
+		iRet = -ENOMEM;
+		goto alloc_err;
+	}
+	memset(dev, 0, sizeof(struct mp200_imc_device));
+	dev->IMCMmio       = IMC_BASE;
+	dev->IMCMmioLength = IMC_SIZE;
+
+	/* ioremap IMCMmio */
+#ifdef IO_ADDRESS
+	dev->IMCMmioV = (char *)IO_ADDRESS(dev->IMCMmio);
+#else
+	dev->IMCMmioV = ioremap_nocache(dev->IMCMmio, dev->IMCMmioLength);
+	if (!dev->IMCMmioV) {
+		printk_err("cannot ioremap_nocache IMCMmio\n");
+		iRet = -ENOMEM;
+		goto ioremap_err;
+	}
+#endif
+	printk_dbg((_DEBUG_IMC),
+	 "IMCMmio (0x%lx)  IMCMmioV (0x%p)  IMCMmioLength (0x%lx)\n",
+	  dev->IMCMmio, dev->IMCMmioV, dev->IMCMmioLength);
+
+	/* IMC initialize */
+	iRet = imc_hw_init();
+	if (iRet)
+		goto init_hw_err;
+
+	/* spinlock initialize */
+	spin_lock_init(&dev->imc_hw_lock);
+
+	/* install IMC irq handler */
+	iRet = request_irq(INT_IMC, imc_irq_handler, 0, DEV_NAME, NULL);
+	if (iRet) {
+		printk_err("fail in request_irq(INT_IMC)\n");
+		goto init_hw_err;
+	}
+
+	goto init_success;
+
+init_hw_err:
+#ifndef IO_ADDRESS
+	iounmap(dev->IMCMmioV);
+ioremap_err:
+#endif
+	kfree(dev);
+alloc_err:
+init_success:
+
+	printk_dbg((_DEBUG_IMC & 0x02), "out\n");
+	return iRet;
+}
+
+
+#ifdef MODULE
+/******************************************************************************
+* MODULE   : mp200_imc_exit_module
+* FUNCTION :
+* RETURN   : none
+* NOTE     : none
+* CREATE   : 2007.06.18 M.Haguro
+* UPDATE   :
+******************************************************************************/
+void mp200_imc_exit_module(void)
+{
+	printk_dbg((_DEBUG_IMC & 0x01), "in\n");
+
+	imc_hw_int_disable();
+	free_irq(INT_IMC, NULL);
+	imc_hw_reset();
+#ifndef IO_ADDRESS
+	iounmap(dev->IMCMmioV);
+#endif
+	kfree(dev);
+
+	printk_dbg((_DEBUG_IMC & 0x02), "out\n");
+}
+
+
+module_init(mp200_imc_init_module);
+module_exit(mp200_imc_exit_module);
+#else
+device_initcall(mp200_imc_init_module);
+#endif
+
+
+MODULE_AUTHOR("NEC Electronics Corporation.");
+MODULE_DESCRIPTION("EM1 IMC control driver");
+MODULE_LICENSE("GPL");
+
diff --git a/drivers/video/mp200/mp200_imc.h b/drivers/video/mp200/mp200_imc.h
new file mode 100644
index 0000000..db56c7c
--- /dev/null
+++ b/drivers/video/mp200/mp200_imc.h
@@ -0,0 +1,191 @@
+/*
+ * File Name       : /drivers/video/mp200/mp200_imc.h
+ * Function        : IMC Driver corresponding to V4L2  definitions
+ * Release Version :
+ * Release Date    : 2009.10.21
+ *
+ * Copyright (C) NEC Electronics Corporation 2009
+ *
+ *
+ * This program is free software;you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by Free Softwere
+ * Foundation; either version 2 of License, or (at your option) any later
+ * version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warrnty of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
+ * details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; If not, write to the Free Software Foundation, Inc., 59 Temple
+ * Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#ifndef _MP200_IMC_H_
+#define _MP200_IMC_H_
+
+
+/********************************************************
+ *  Definitions                                         *
+ *******************************************************/
+#define SET_UPDATE_ATTR 1
+#define SET_INIT_ATTR   0
+
+
+/********************************************************
+ *  Macros                                              *
+ *******************************************************/
+
+
+/********************************************************
+ *  Sub Structure                                       *
+ *******************************************************/
+/* ----- IMC GAMMA Set Structure --------------------- */
+struct imc_gamma_param {
+	unsigned long en;
+	unsigned long adr;
+	unsigned long *data;
+};
+
+/* ----- IMC WB Set Structure ------------------------ */
+struct imc_wb_param {
+	unsigned long areaadr;
+	unsigned long hoffset;
+	unsigned long format;
+	unsigned long hsize;
+	unsigned long vsize;
+};
+
+/* ----- IMC all Layer Set Structure ----------------- */
+struct imc_yuv_param {
+	unsigned long ygain;
+	unsigned long ugain;
+	unsigned long vgain;
+	unsigned long yuv2rgb;
+	unsigned long coef_r[4];
+	unsigned long coef_g[4];
+	unsigned long coef_b[4];
+};
+
+/* ----- IMC Kercolor Structure ---------------------- */
+struct imc_keycolor_param {
+	unsigned long l0_keycolor;
+	unsigned long l1x_keycolor;
+};
+
+/* ----- IMC Bytelane Structure ---------------------- */
+struct imc_bytelane_param {
+	unsigned long l2a_bytelane;
+	unsigned long l2b_bytelane;
+};
+
+/* ----- IMC Layer0/1 Set Structure ------------------ */
+struct l01_param {
+	unsigned long control;
+	unsigned long format;
+	unsigned long keyenable;
+/*	unsigned long keycolor; */
+	unsigned long alpha;
+	unsigned long resize;
+	unsigned long offset;
+	unsigned long frameadr;
+	unsigned long position;
+	unsigned long size;
+};
+
+/* ----- IMC Layer2 Set Structure -------------------- */
+struct l2_param {
+	unsigned long control;
+	unsigned long format;
+	unsigned long bufsel;
+	unsigned long resize;
+	unsigned long mirror;
+	unsigned long offset;
+	unsigned long frameadr_yp;
+	unsigned long frameadr_up;
+	unsigned long frameadr_vp;
+	unsigned long frameadr_yq;
+	unsigned long frameadr_uq;
+	unsigned long frameadr_vq;
+	unsigned long position;
+	unsigned long size;
+};
+
+/* ----- IMC LayerBG Set Structure ------------------- */
+struct bg_param {
+	unsigned long format;
+	unsigned long resize;
+	unsigned long offset;
+	unsigned long frameadr;
+};
+
+
+/********************************************************
+ *  Main Structure                                      *
+ *******************************************************/
+/* ----- IMC Pre-Ser Structure ----------------------- */
+struct mp200_imc_preset {
+	unsigned long             *imc_control;
+	struct imc_gamma_param    *gamma;
+	struct imc_wb_param       *wb;
+	struct imc_yuv_param      *yuv;
+	struct imc_keycolor_param *keycolor;
+	struct imc_bytelane_param *bytelane;
+};
+
+/* ----- IMC Update VSYNC Structure ------------------ */
+struct mp200_imc_update_vsync {
+	unsigned long cpubufsel;
+	unsigned long mirror;
+};
+
+/* ----- IMC Update Reserve Structure ---------------- */
+struct mp200_imc_update_reserve {
+	struct l01_param *lo;
+	struct l01_param *l1a;
+	struct l01_param *l1b;
+	struct l01_param *l1c;
+	struct l2_param  *l2a;
+	struct l2_param  *l2b;
+	struct bg_param  *bg;
+};
+
+
+
+
+/********************************************************
+ *  Variables                                           *
+ *******************************************************/
+typedef void (*imc_callback_func_refresh)(void);
+typedef void (*imc_callback_func_wb)(int status);
+
+
+/********************************************************
+ *  external function                                   *
+ *******************************************************/
+extern int  mp200_imc_init_module(void);
+extern void mp200_imc_exit_module(void);
+extern int  mp200_imc_set_preset(struct mp200_imc_preset *imc_preset,
+ int setmode);
+extern int mp200_imc_set_update_vsync(struct mp200_imc_update_vsync *imc_vsync);
+extern int  mp200_imc_set_update_reserve(
+	struct mp200_imc_update_reserve *imc_reserve,
+	imc_callback_func_refresh callback_refresh);
+extern int  mp200_imc_set_callback(imc_callback_func_refresh callback_refresh,
+ imc_callback_func_wb callback_wb);
+#if 0 /* this function used in IMC-LCD asynchronous mode. */
+extern int  mp200_imc_start(void);
+#endif
+#if defined(CONFIG_PM) || defined(CONFIG_DPM)
+extern int  mp200_imc_suspend(struct platform_device *dev, pm_message_t state);
+extern int  mp200_imc_resume(struct platform_device *dev);
+#endif /* CONFIG_PM || CONFIG_DPM */
+
+extern void imc_hw_reset(void);
+extern void imc_hw_unreset(void);
+
+
+
+#endif /* _MP200_FB_H_ */
diff --git a/drivers/video/mp200/mp200_lcd.c b/drivers/video/mp200/mp200_lcd.c
new file mode 100644
index 0000000..9e58f57
--- /dev/null
+++ b/drivers/video/mp200/mp200_lcd.c
@@ -0,0 +1,1470 @@
+/*
+ * File Name       : /drivers/video/mp200/mp200_lcd.c
+ * Function        : LCD driver corresponding to V4L2
+ * Release Version :
+ * Release Date    : 2009.10.20
+ *
+ * Copyright (C) NEC Electronics Corporation 2009
+ *
+ *
+ * This program is free software;you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by Free Softwere
+ * Foundation; either version 2 of License, or (at your option) any later
+ * version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warrnty of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
+ * details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; If not, write to the Free Software Foundation, Inc., 59 Temple
+ * Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+
+/********************************************************
+ *  Include Files                                       *
+ *******************************************************/
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/version.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/tty.h>
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/fb.h>
+#include <linux/init.h>
+#include <linux/ioport.h>
+#include <linux/timer.h>
+#include <linux/sched.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+
+#if defined(CONFIG_PM) || defined(CONFIG_DPM)
+#include <mach/pm.h>
+#endif /* CONFIG_PM || CONFIG_DPM */
+
+#include <linux/uaccess.h>
+#include <mach/hardware.h>
+#include <mach/irqs.h>
+#include <mach/pmu.h>
+#include <mach/em1_mem.h>
+
+#include "mp200_common.h"
+#include "mp200_fb.h"
+
+#include "lcdc.h"
+#include "mp200_lcd_common.h"
+#include "mp200_lcdhw.h"
+#include "mp200_lcd.h"
+
+#include "imc.h"
+#include "mp200_imc.h"
+
+
+/********************************************************
+ *  Definitions                                         *
+ *******************************************************/
+#define _DEBUG_LCD  0x00 /* 00008421(bit) */
+			 /* 0x01: debug function in
+			  * 0x02: debug function out
+			  * 0x40: debug FBIOBLANK
+			  * 0x80: debug semafore
+			  */
+
+
+/********************************************************
+ *  Definitions                                         *
+ *******************************************************/
+#define DEV_NAME "mp200_lcd"
+#define DPM_SUSPEND_FLG_INIT 0
+#define INDEX_LCD_VAR_NEXT_INIT 0
+
+
+/********************************************************
+ *  Macros                                              *
+ *******************************************************/
+#define printk_err(fmt, arg...) \
+	do {                     \
+		printk(KERN_ERR DEV_NAME ": %s: " fmt, __func__, ## arg); \
+	} while (0)
+
+#define printk_wrn(fmt, arg...) \
+	do {                     \
+		printk(KERN_WARNING DEV_NAME ": %s: " fmt, __func__, ## arg); \
+	} while (0)
+
+#define printk_info(fmt, arg...) \
+	do {                      \
+		printk(KERN_INFO DEV_NAME ": " fmt, ## arg); \
+	} while (0)
+
+#if _DEBUG_LCD
+#define printk_dbg(level, fmt, arg...) \
+	do {                            \
+		if (level > 0) \
+			printk(KERN_DEBUG DEV_NAME ": %s: " fmt, \
+			__func__, ## arg); \
+	} while (0)
+#else
+#define printk_dbg(level, fmt, arg...) \
+	;
+#endif
+
+
+/********************************************************
+ *  Structure                                           *
+ *******************************************************/
+/* structure lcd device status */
+struct mp200_lcd_dev {
+	/* semafore v4l2/fb/img local data */
+	struct semaphore      sem_image_data;
+	/* semafore IMC refresh */
+	struct semaphore      sem_image_refresh;
+	/* spin lock LCD timer flag        */
+	spinlock_t	      lcd_lock;
+};
+
+#define MP200_LCD_DEV struct mp200_lcd_dev
+
+
+/********************************************************
+ *  Variables                                           *
+ *******************************************************/
+
+/* input image data from fb driver */
+/* (2D) name of mix frame buffer temp   */
+static  unsigned int  uiMixFrameBufferPage_tmp;
+
+/* other img infomation */
+static  unsigned int  uiMaskColor_tmp;		/* mask color */
+static  unsigned int  uiAlpha_tmp;		/* alpha      */
+
+/* Flags */
+static           int  iMixDSPFlg_tmp;		/* DSP mix ON/OFF            */
+static           int  iDSPPauseFlg;		/* DSP pause status          */
+static  unsigned int  uiMaskColorFlag_tmp;	/* mask color ON/OFF Flag    */
+static  unsigned int  uiAbsolutelyUpFlag;	/* absolutely update flag    */
+	unsigned int  uiInverseFlag_tmp;	/* inverse mode Flag         */
+
+/*
+ * Smem
+ */
+/* LCDC MMIO */
+static  unsigned long LCDCMmio       = LCDC_BASE;
+static  unsigned long LCDCMmioLength = LCDC_SIZE;
+	char         *LCDCMmioV;
+
+#if 0
+/* FrameBuf(LCD) */
+/*     unsigned long FrameBuf       = SMEM_START + FRAMEBUF_OFFSET; */
+/*     unsigned long FrameBufLength = FRAMEBUF_LENGTH; */
+/*     char         *FrameBufV; */
+#endif
+
+/* LCD device status */
+static MP200_LCD_DEV       lcd_dev;
+
+/*
+ * V4L2 dev data
+ */
+static void *pvDevData_tmp;		/* mp200_v4l2_device               */
+static void *pvVideoBuf_tmp;		/* videobuf_buffer                 */
+
+/*
+ * timer
+ */
+static  struct timer_list lcd_timer;
+static  int               iTimerFlag;
+
+/* lcd_refresh_flg */
+enum imc_refresh_status {
+	IMC_R_IDLE         = 0,
+	IMC_R_WAIT_REFRESH = 1,
+	IMC_R_REFRESHED    = 2,
+	IMC_R_DISPLAYED    = 3,
+};
+
+struct mp200_lcd_var {
+	struct list_head      list;
+	/* semafore v4l2/fb/img local flag */
+	struct semaphore      sem_image_flag;
+
+	/* input image data from fb driver */
+	/* (2D) name of mix frame buffer        */
+	unsigned int  uiMixFrameBufferPage;
+	/* Flags */
+	int  iMixDSPFlgToFB;		/* return FB DSP mix ON/OFF  */
+	int  iCallbackV4L2Flg;		/* need to callback to V4L2  */
+	/* V4L2 dev data */
+	void *pvDevData;		/* mp200_v4l2_device               */
+	void *pvVideoBuf;		/* videobuf_buffer                 */
+
+	enum imc_refresh_status lcd_refresh_flg;
+
+#if defined(CONFIG_PM) || defined(CONFIG_DPM)
+	int          ctrl_func;
+#endif /* CONFIG_PM || CONFIG_DPM */
+};
+#define MP200_LCD_VAR struct mp200_lcd_var
+
+static MP200_LCD_VAR lcd_var[2];
+static int index_lcd_var_next = INDEX_LCD_VAR_NEXT_INIT;
+
+static struct list_head list_lcd_var;
+
+/* FBIOBLANK */
+struct lcd_blank_state {
+	int current_mode;
+	int lcd_backlight;
+	int lcd_output;
+	int lcd_clock;
+};
+#define LCD_BLANK_STATE struct lcd_blank_state
+
+static LCD_BLANK_STATE blank_state;
+
+/********************************************************
+ *  Prototype declarations of function                  *
+ *******************************************************/
+/*
+ * LCD Driver
+ */
+/* Public function */
+static void         mp200_lcd_remove(void);
+#if defined(CONFIG_PM) || defined(CONFIG_DPM)
+static int          lcd_suspend_chk_lcdout(void);
+
+       int          IMC_reset_flg   = 0;
+#endif /* CONFIG_PM || CONFIG_DPM */
+static int          DPM_suspend_flg = DPM_SUSPEND_FLG_INIT;
+
+/* Private function */
+static void         mix_image(int iCallbackV4L2_tmp, int update, int type);
+static void         lcd_irq_handler_callback(void);
+
+static void         set_val_init(void);
+static int          lcd_probe(void);
+static void         lcd_probe_error(int iErrorMode);
+static void         lcd_timer_init(void);
+static void         lcd_timeout(unsigned long data);
+
+/*
+ * work queue
+ */
+static struct workqueue_struct *mp200_lcd_workqueue;
+static struct work_struct       wk_timeout_bottom_half;
+static void         lcd_timeout_bottom_half_do(struct work_struct *num);
+
+
+/********************************************************
+ *  Function Definitions                                *
+ *******************************************************/
+/******************************************************************************
+* MODULE   : mp200_lcd_blank
+* FUNCTION : FBIOBLANK
+* RETURN   : 0       : success
+*            -EINVAL : input value incorrect
+* NOTE     : none
+* CREATE   : 2009.9.14 Y.Utsuhara
+* UPDATE   :
+******************************************************************************/
+int mp200_lcd_blank(int blank_mode)
+{
+	int backlight, output, clock;
+	int lock = 0;
+	unsigned long flags = 0;
+
+	printk_dbg((_DEBUG_LCD & 0x40), "<start>\n");
+
+	switch (blank_mode) {
+	case FB_BLANK_UNBLANK:
+		/* Screen: On,  HSync: On,  VSync: On */
+		printk_dbg((_DEBUG_LCD & 0x40), "<FB_BLANK_UNBLANK>\n");
+		backlight = 1;
+		output    = 1;
+		clock     = 1;
+		break;
+	case FB_BLANK_NORMAL:
+		/* Screen: Off, HSync: On,  VSync: On */
+		printk_dbg((_DEBUG_LCD & 0x40), "<FB_BLANK_NORMAL>\n");
+		backlight = 0;
+		output    = 1;
+		clock     = 1;
+		break;
+	case FB_BLANK_VSYNC_SUSPEND:
+		/* Screen: Off, HSync: On,  VSync: Off */
+		printk_dbg((_DEBUG_LCD & 0x40), "<FB_BLANK_VSYNC_SUSPEND>\n");
+		backlight = 0;
+		output    = 0;
+		clock     = 1;
+		break;
+	case FB_BLANK_HSYNC_SUSPEND:
+		/* Screen: Off, HSync: Off, VSync: On */
+		printk_dbg((_DEBUG_LCD & 0x40), "<FB_BLANK_HSYNC_SUSPEND>\n");
+		backlight = 0;
+		output    = 0;
+		clock     = 1;
+		break;
+	case FB_BLANK_POWERDOWN:
+		/* Screen: Off, HSync: Off, VSync: Off */
+		printk_dbg((_DEBUG_LCD & 0x40), "<FB_BLANK_POWERDOWN>\n");
+		backlight = 0;
+		output    = 0;
+		clock     = 0;
+		break;
+	default:
+		printk_dbg((_DEBUG_LCD & 0x40), "<failed(%d)>\n", -EINVAL);
+		return -EINVAL;
+	}
+
+	if ((backlight == 0) && (blank_state.lcd_backlight == 1)) {
+		/* backlight On -> Off */
+		printk_dbg((_DEBUG_LCD & 0x40), "<backlight On -> Off>\n");
+		blank_state.lcd_backlight = 0;
+		lcd_hw_backlight_off();
+	}
+
+	if (((output    == 0) && (blank_state.lcd_output    == 1)) ||
+	    ((output    == 1) && (blank_state.lcd_output    == 0))) {
+		down(&lcd_dev.sem_image_data);
+		down(&lcd_dev.sem_image_refresh);
+		down(&lcd_var[0].sem_image_flag);
+		down(&lcd_var[1].sem_image_flag);
+		spin_lock_irqsave(&lcd_dev.lcd_lock, flags);
+		lock = 1;
+	}
+
+	if ((output    == 0) && (blank_state.lcd_output    == 1)) {
+		/* output    On -> Off */
+		printk_dbg((_DEBUG_LCD & 0x40), "<output    On -> Off>\n");
+		blank_state.lcd_output    = 0;
+		writel(LCD_BUSSEL_BLACK, LCDCMmioV + LCD_BUSSEL);
+		lcd_suspend_chk_lcdout();
+		lcd_hw_stop();
+	}
+	if ((clock     == 0) && (blank_state.lcd_clock     == 1)) {
+		/* clock     On -> Off */
+		printk_dbg((_DEBUG_LCD & 0x40), "<clock     On -> Off>\n");
+		blank_state.lcd_clock     = 0;
+		lcd_hw_save_reg();
+		lcd_hw_reset();
+	}
+	if ((clock     == 1) && (blank_state.lcd_clock     == 0)) {
+		/* clock     Off -> On */
+		printk_dbg((_DEBUG_LCD & 0x40), "<clock     Off -> On>\n");
+		blank_state.lcd_clock     = 1;
+		lcd_hw_unreset();
+		lcd_hw_restore_reg();	/* LCD_BUSSEL_BLACK is
+					   set to LCD_BUSSEL*/
+	}
+	if ((output    == 1) && (blank_state.lcd_output    == 0)) {
+		/* output    Off -> on */
+		printk_dbg((_DEBUG_LCD & 0x40), "<output    Off -> On>\n");
+		blank_state.lcd_output    = 1;
+		writel(LCD_BUSSEL_LOCAL, LCDCMmioV + LCD_BUSSEL);
+		lcd_hw_start();
+	}
+
+	if (lock == 1) {
+		spin_unlock_irqrestore(&lcd_dev.lcd_lock, flags);
+		up(&lcd_dev.sem_image_data);
+		up(&lcd_dev.sem_image_refresh);
+		up(&lcd_var[0].sem_image_flag);
+		up(&lcd_var[1].sem_image_flag);
+	}
+
+	if ((backlight == 1) && (blank_state.lcd_backlight == 0)) {
+		/* backlight Off -> On */
+		printk_dbg((_DEBUG_LCD & 0x40), "<backlight Off -> On>\n");
+		blank_state.lcd_backlight = 1;
+		lcd_hw_backlight_on();
+	}
+
+	blank_state.current_mode = blank_mode;
+	return 0;
+}
+EXPORT_SYMBOL(mp200_lcd_blank);
+
+
+/******************************************************************************
+* MODULE   : mp200_lcd_set_v4l2_image
+* FUNCTION : set image data from v4l2 to LCD local
+* RETURN   : 0 : success
+* NOTE     : none
+* CREATE   : 2006.05.25 H.Nagashima
+* UPDATE   :
+******************************************************************************/
+int mp200_lcd_set_v4l2_image(V4L2_IMAGE_INFO *v4l2_image_info)
+{
+	unsigned long flags;
+
+	int bpp_y, bpp_uv, bpp_v; /* bit par pixel  */
+	int ppl_y, ppl_uv, ppl_v; /* pixel par line */
+
+	printk_dbg((_DEBUG_LCD & 0x01), "<start>\n");
+
+	/* Stop pause timer */
+	spin_lock_irqsave(&lcd_dev.lcd_lock, flags);
+	del_timer(&lcd_timer);
+	iTimerFlag = LCD_TIMER_STOP;
+	spin_unlock_irqrestore(&lcd_dev.lcd_lock, flags);
+	iDSPPauseFlg = PAUSE_DSP_OFF;
+
+	/* get v4l2 data semafore */
+	down(&lcd_dev.sem_image_data);
+	printk_dbg((_DEBUG_LCD & 0x80), "down(A) set_v4l2\n");
+
+	if (init_is_first) {
+		/* LCD not initialize */
+		up(&lcd_dev.sem_image_data);
+		printk_dbg((_DEBUG_LCD & 0x80), "up(A) set_v4l2\n");
+		return -1;
+	}
+
+	/* DSP stop */
+	if (v4l2_image_info->image_data.yrgbaddr == 0) {
+		printk_dbg((_DEBUG_LCD & 0x01), "<stop DSP>\n");
+		/* movie off */
+		iMixDSPFlg_tmp = MIX_DSP_OFF;
+		/* update Layer data */
+		mix_image(CALLBACK_V4L2_OFF, UPDATE_ON, CLR_LAYER_V4L2);
+		return 0;
+	}
+
+	/* select 2D(1) */
+	memset(&v4l2_layer, 0, sizeof(struct l2_param));
+
+	/* movie on */
+	iMixDSPFlg_tmp   = MIX_DSP_ON;
+
+	v4l2_layer.offset      = v4l2_image_info->image_data.size;
+	/* y, x */
+	v4l2_layer.position    =
+		(v4l2_image_info->screen_data.y << IMC_Lx_POSY_SFT |
+		v4l2_image_info->screen_data.x << IMC_Lx_POSX_SFT);
+	/* h, w */
+	v4l2_layer.size        =
+		(v4l2_image_info->screen_data.vsize << IMC_Lx_SIZEY_SFT |
+		v4l2_image_info->screen_data.hsize << IMC_Lx_SIZEX_SFT);
+	v4l2_layer.control     = IMC_Lx_CONTROL_ON;
+	v4l2_layer.resize      = IMC_Lx_RESIZE_DISABLE;
+	v4l2_layer.mirror      = IMC_L2x_MIRROR_OFF;
+
+	switch (v4l2_image_info->yuvfmt) {
+	case V4L2_FORMAT_YUV420Pl2: /* YUV420 Semi-Planar */
+		printk_dbg((_DEBUG_LCD & 0x02), "format(YUV420Pl2)\n");
+		bpp_y = 8;  bpp_uv = 8; bpp_v = 0;
+		ppl_y = 1; ppl_uv = 2; ppl_v = 0;
+		v4l2_layer.format      = IMC_Lx_FORMAT_YUV420Pl2;
+		v4l2_layer.frameadr_yp =
+			v4l2_image_info->image_data.yrgbaddr +
+			v4l2_image_info->image_data.y * v4l2_layer.offset *
+			bpp_y / 8 / ppl_y +
+			v4l2_image_info->image_data.x * bpp_y  / 8;
+		v4l2_layer.frameadr_up =
+			v4l2_image_info->image_data.uvaddr +
+			v4l2_image_info->image_data.y * v4l2_layer.offset *
+			bpp_uv / 8 / ppl_uv +
+			v4l2_image_info->image_data.x * bpp_uv / 8;
+		v4l2_layer.frameadr_vp = 0;
+		break;
+	case V4L2_FORMAT_YUV422Pl2: /* YUV422 Semi-Planar */
+		printk_dbg((_DEBUG_LCD & 0x02), "format(YUV422Pl2)\n");
+		bpp_y = 8;  bpp_uv = 8; bpp_v = 0;
+		ppl_y = 1; ppl_uv = 1; ppl_v = 0;
+		v4l2_layer.format      = IMC_Lx_FORMAT_YUV422Pl2;
+		v4l2_layer.frameadr_yp =
+			v4l2_image_info->image_data.yrgbaddr +
+			v4l2_image_info->image_data.y * v4l2_layer.offset *
+			bpp_y  / 8 / ppl_y +
+			v4l2_image_info->image_data.x * bpp_y  / 8;
+		v4l2_layer.frameadr_up =
+			v4l2_image_info->image_data.uvaddr +
+			v4l2_image_info->image_data.y * v4l2_layer.offset *
+			bpp_uv / 8 / ppl_uv +
+			v4l2_image_info->image_data.x * bpp_uv / 8;
+		v4l2_layer.frameadr_vp = 0;
+		break;
+	case V4L2_FORMAT_YUV420Pl: /* YUV420 Planar      */
+		printk_dbg((_DEBUG_LCD & 0x02), "format(YUV420Pl)\n");
+		bpp_y = 8;  bpp_uv = 4; bpp_v = 4;
+		 ppl_y = 1; ppl_uv = 4; ppl_v = 4;
+		v4l2_layer.format      = IMC_Lx_FORMAT_YUV420Pl;
+		v4l2_layer.frameadr_yp =
+			v4l2_image_info->image_data.yrgbaddr +
+			v4l2_image_info->image_data.y * v4l2_layer.offset *
+			bpp_y  / 8 / ppl_y +
+			v4l2_image_info->image_data.x * bpp_y  / 8;
+		v4l2_layer.frameadr_up =
+			v4l2_image_info->image_data.uvaddr +
+			v4l2_image_info->image_data.y * v4l2_layer.offset *
+			bpp_uv / 8 / ppl_uv +
+			v4l2_image_info->image_data.x * bpp_uv / 8;
+		v4l2_layer.frameadr_vp =
+			v4l2_image_info->image_data.vaddr +
+			v4l2_image_info->image_data.y * v4l2_layer.offset *
+			bpp_v / 8 / ppl_v +
+			v4l2_image_info->image_data.x * bpp_v  / 8;
+		break;
+	case V4L2_FORMAT_YUV422Px: /* YUV422 Interleave  */
+		printk_dbg((_DEBUG_LCD & 0x02), "format(YUV422Px)\n");
+		bpp_y = 16; bpp_uv = 0; bpp_v = 0;
+		ppl_y = 1; ppl_uv = 0; ppl_v = 0;
+		v4l2_layer.format      = IMC_Lx_FORMAT_YUV422Px;
+		v4l2_layer.frameadr_yp =
+			v4l2_image_info->image_data.yrgbaddr +
+			v4l2_image_info->image_data.y * v4l2_layer.offset *
+			bpp_y / 8 / ppl_y +
+			v4l2_image_info->image_data.x * bpp_y  / 8;
+		v4l2_layer.frameadr_up = 0;
+		v4l2_layer.frameadr_vp = 0;
+		break;
+	default:
+		printk_dbg((_DEBUG_LCD & 0x02), "format(%ld)\n",
+		 v4l2_layer.format);
+		up(&lcd_dev.sem_image_data); /* release data semafore */
+		printk_dbg((_DEBUG_LCD & 0x80), "up(A) set_v4l2\n");
+		return -1;
+	}
+	v4l2_layer.frameadr_yq = 0;
+	v4l2_layer.frameadr_uq = 0;
+	v4l2_layer.frameadr_vq = 0;
+
+	/* set frame data from V4L2 */
+	pvDevData_tmp  = v4l2_image_info->frame_data.dev;
+	pvVideoBuf_tmp = v4l2_image_info->frame_data.buf;
+
+	/* mix - image data from v4l2 and image data
+	   from fb driver (DSP and 2D) */
+	mix_image(CALLBACK_V4L2_ON, UPDATE_ON, SET_LAYER_V4L2);
+
+	/* start PAUSE timer */
+	spin_lock_irqsave(&lcd_dev.lcd_lock, flags);
+	if (iTimerFlag == LCD_TIMER_STOP && !DPM_suspend_flg) {
+		lcd_timer.expires = jiffies
+		 + (MIX_DSP_TIMEOUT * 10 * HZ / 1000);
+		add_timer(&lcd_timer);
+		iTimerFlag = LCD_TIMER_START;
+	}
+	spin_unlock_irqrestore(&lcd_dev.lcd_lock, flags);
+
+	return 0;
+}
+EXPORT_SYMBOL(mp200_lcd_set_v4l2_image);
+
+
+/******************************************************************************
+* MODULE   : mp200_lcd_set_fb_image
+* FUNCTION : set image data from Frame Buffer to LCD local
+* RETURN   :  0 : success
+*            -1 : faile
+* NOTE     : none
+* CREATE   : 2006.05.25 H.Nagashima
+* UPDATE   :
+******************************************************************************/
+int mp200_lcd_set_fb_image(FB_IMAGE_INFO *fb_image_info)
+{
+	printk_dbg((_DEBUG_LCD & 0x01), "<start>\n");
+
+	/* get data semafore */
+	down(&lcd_dev.sem_image_data);
+	printk_dbg((_DEBUG_LCD & 0x80), "down(A) set_fb\n");
+
+	/* Set other infomation of input data from fb */
+	uiAlpha_tmp              = fb_image_info->alpha;
+	uiInverseFlag_tmp        = fb_image_info->invflg;
+	uiMixFrameBufferPage_tmp = fb_image_info->mix_buf_page;
+	printk_dbg((_DEBUG_LCD & 0x01), "MixFrameBuffer(%d)\n",
+	 uiMixFrameBufferPage_tmp);
+
+	uiMaskColorFlag_tmp      = fb_image_info->maskcolrflg;
+	uiMaskColor_tmp          = fb_image_info->maskcolr;
+	uiMaskColor_tmp          =
+		(((((uiMaskColor_tmp & 0xF800) >> 11) << 1) +
+		((uiMaskColor_tmp & 0x8000) >> 15)) << IMC_Lx_KEYR_SFT) |
+		(((uiMaskColor_tmp & 0x07E0) >> 5) << IMC_Lx_KEYG_SFT) |
+		(((((uiMaskColor_tmp & 0x001F) >>  0) << 1) +
+		((uiMaskColor_tmp & 0x0010) >>  4)) << IMC_Lx_KEYB_SFT);
+
+	/* select 2D(1) */
+	memset(&fb_layer, 0, sizeof(struct l01_param));
+
+	fb_layer.format   = IMC_Lx_FORMAT_RGB565;
+	fb_layer.resize   = IMC_Lx_RESIZE_DISABLE;
+	fb_layer.offset   = fb_image_info->image_data.size;
+	fb_layer.control  = IMC_Lx_CONTROL_ON;
+	if (fb_image_info->maskcolrflg == TC_COLOR_ENABLE)
+		fb_layer.keyenable = IMC_Lx_KEYEN_ENABLE;
+	else
+		fb_layer.keyenable = IMC_Lx_KEYEN_DISABLE;
+
+	fb_layer.alpha    =
+		(uiAlpha_tmp * ((1UL << 6) - 1) + ((1UL << 8) - 1) / 2) /
+		((1UL << 8) - 1); /* 8bit to 6bit */
+	fb_layer.position =
+		(fb_image_info->image_data.y << IMC_Lx_POSY_SFT |
+		fb_image_info->image_data.x << IMC_Lx_POSX_SFT);  /* y, x */
+	fb_layer.size     =
+		(fb_image_info->image_data.vsize << IMC_Lx_SIZEY_SFT |
+		fb_image_info->image_data.hsize << IMC_Lx_SIZEX_SFT); /* h, w */
+
+	/* image area Y/RGB plane address */
+	fb_layer.frameadr = fb_image_info->image_data.yrgbaddr;
+
+	/* check update flag */
+	switch (fb_image_info->update_flag) {
+	case FB_UPDATE_ON:  /*    ioctl(MP200_FB_UPDATE_SCRN) & update = 0 */
+			    /* or interval update                          */
+		printk_dbg((_DEBUG_LCD & 0x02), "FB_UPDATE_ON\n");
+
+		/* movie on */
+		if (iMixDSPFlg_tmp == MIX_DSP_ON) {
+			/* pause status */
+			if (iDSPPauseFlg == PAUSE_DSP_ON) {
+				mix_image(CALLBACK_V4L2_OFF, UPDATE_ON,
+				 SET_LAYER_2D);
+			} else {
+				/* not pause status */
+				mix_image(CALLBACK_V4L2_OFF, UPDATE_OFF,
+				 SET_LAYER_2D);
+			}
+		} else {
+			/* movie off */
+			mix_image(CALLBACK_V4L2_OFF, UPDATE_ON, SET_LAYER_2D);
+		}
+		break;
+	/* ioctl(MP200_FB_UPDATE_SCRN) & update = 1 */
+	case FB_ABSOLUTERY_UPDATE:
+		printk_dbg((_DEBUG_LCD & 0x02), "FB_ABSOLUTERY_UPDATE\n");
+		/* movie on */
+		mix_image(CALLBACK_V4L2_OFF, UPDATE_ON, SET_LAYER_2D);
+		break;
+	case FB_UPDATE_OFF:  /* ioctl(MP200_FB_SET_MODES) */
+	default:  /* other                     */
+		printk_dbg((_DEBUG_LCD & 0x02), "FB_UPDATE_OFF\n");
+		mix_image(CALLBACK_V4L2_OFF, UPDATE_OFF, SET_LAYER_2D);
+		break;
+	}
+
+	printk_dbg((_DEBUG_LCD & 0x02), "<end>\n");
+	return 0;
+}
+EXPORT_SYMBOL(mp200_lcd_set_fb_image);
+
+
+/******************************************************************************
+* MODULE   : mix_image
+* FUNCTION : By using IMG, mix 2D (and DSP) image
+* RETURN   :  0 : success
+*          : -1 : failed
+* NOTE     : none
+* CREATE   : 2006.05.25 H.Nagashima
+* UPDATE   :
+******************************************************************************/
+static void mix_image(int iCallbackV4L2_tmp, int update, int type)
+{
+	unsigned long flags;
+	int i = 0;
+
+	if (update == UPDATE_ON) {
+		/* get refresh semafore */
+		down(&lcd_dev.sem_image_refresh);
+		printk_dbg((_DEBUG_LCD & 0x80), "down(C) mix_image\n");
+
+		spin_lock_irqsave(&lcd_dev.lcd_lock, flags);
+		i = index_lcd_var_next;
+		index_lcd_var_next++;
+		if (index_lcd_var_next == 2)
+			index_lcd_var_next = 0;
+		spin_unlock_irqrestore(&lcd_dev.lcd_lock, flags);
+
+		/* get flag semafore */
+		down(&lcd_var[i].sem_image_flag);
+		printk_dbg((_DEBUG_LCD & 0x80), "down(B) mix_image\n");
+
+		lcd_var[i].lcd_refresh_flg = IMC_R_IDLE;
+
+		/* set flag and temp data */
+		lcd_var[i].iCallbackV4L2Flg      = iCallbackV4L2_tmp;
+		lcd_var[i].uiMixFrameBufferPage  = uiMixFrameBufferPage_tmp;
+		lcd_var[i].iMixDSPFlgToFB        = iMixDSPFlg_tmp;
+
+		if (lcd_var[i].iCallbackV4L2Flg == CALLBACK_V4L2_ON) {
+			/* set frame data from V4L2 */
+			lcd_var[i].pvDevData  = pvDevData_tmp;
+			lcd_var[i].pvVideoBuf = pvVideoBuf_tmp;
+		}
+	}
+
+	if (iMixDSPFlg_tmp == MIX_DSP_OFF) {
+		/* 8bit to 6bit */
+		fb_layer.alpha  = (0xFF * ((1UL << 6) - 1)
+		 + ((1UL << 8) - 1) / 2) / ((1UL << 8) - 1);
+
+		ImcNxtKeycol.l1x_keycolor = uiMaskColor_tmp;
+
+		/* update colorkey data */
+		if (imc_hw_set_update_keycolor(&ImcNxtKeycol))
+			printk_wrn("IMC update_keycolor() failed.\n");
+	} else {
+		fb_layer.alpha  =
+			(uiAlpha_tmp * ((1UL << 6) - 1) +
+			((1UL << 8) - 1) / 2) /
+			((1UL << 8) - 1); /* 8bit to 6bit */
+
+		if (v4l2_layer.format == IMC_Lx_FORMAT_YUV422Px) {
+			ImcNxtBytelane.l2a_bytelane = IMC_L2x_BYTELANE_INIT;
+			ImcNxtBytelane.l2b_bytelane =
+				IMC_L2x_BYTELANE_422PX_YUYV;
+		} else {
+			ImcNxtBytelane.l2a_bytelane = IMC_L2x_BYTELANE_INIT;
+			ImcNxtBytelane.l2b_bytelane = IMC_L2x_BYTELANE_INIT;
+		}
+
+		/* update bytelane data */
+		if (imc_hw_set_update_bytelane(&ImcNxtBytelane))
+			printk_wrn("IMC update_bytelane() failed.\n");
+	}
+
+	spin_lock_irqsave(&lcd_dev.lcd_lock, flags);
+#if defined(CONFIG_PM) || defined(CONFIG_DPM)
+	if (update == UPDATE_ON)
+		lcd_var[i].ctrl_func = 2;
+#endif /* CONFIG_PM || CONFIG_DPM */
+
+	if (update == UPDATE_ON) {
+		lcd_var[i].lcd_refresh_flg = IMC_R_WAIT_REFRESH;
+		list_add_tail(&lcd_var[i].list, &list_lcd_var);
+	}
+
+	/* update Layer data */
+	if (imc_hw_set_update_reserve(type, iMixDSPFlg_tmp, update))
+		printk_dbg((_DEBUG_LCD & 0x02), "update_reserve() failed.\n");
+
+	if (update == UPDATE_ON) {
+		/* set IMC all layer data */
+		ImcNxtVsync.mirror = uiInverseFlag_tmp;
+		if (imc_hw_set_update_vsync(&ImcNxtVsync))
+			printk_wrn("IMC update_vsync() failed.\n");
+	}
+
+	if (update == UPDATE_ON)
+		change_frame();
+
+	/* release data semafore */
+	up(&lcd_dev.sem_image_data);
+	printk_dbg((_DEBUG_LCD & 0x80), "up(A) mix_image\n");
+
+	spin_unlock_irqrestore(&lcd_dev.lcd_lock, flags);
+
+	if ((update == UPDATE_ON) && (blank_state.lcd_output == 0)) {
+		printk_dbg((_DEBUG_LCD & 0x40),
+		 "call lcd_callback_imc_refresh(): current blank mode = %d\n",
+		 blank_state.current_mode);
+		lcd_callback_imc_refresh();
+	}
+}
+
+
+/*****************************************************************************
+* MODULE   : lcd_irq_handler_callback
+* FUNCTION : LCDC interrupt handler
+* RETURN   :
+* NOTE     : none
+* CREATE   : 2007/07/09 M.Haguro
+* UPDATE   :
+******************************************************************************/
+static void lcd_irq_handler_callback(void)
+{
+	FRAME_DATA frame_data;
+	MP200_LCD_VAR *p_lcd_var;
+	unsigned long flags;
+
+	printk_dbg((_DEBUG_LCD & 0x01), "<start>\n");
+
+	if (list_empty(&list_lcd_var))
+		return;
+
+	spin_lock_irqsave(&lcd_dev.lcd_lock, flags);
+
+	p_lcd_var = list_entry(list_lcd_var.next, struct mp200_lcd_var, list);
+	list_del(&p_lcd_var->list);
+
+	p_lcd_var->lcd_refresh_flg = IMC_R_DISPLAYED;
+
+	/* when kick mix_image by V4L2 */
+	if (p_lcd_var->iCallbackV4L2Flg == CALLBACK_V4L2_ON) {
+		p_lcd_var->iCallbackV4L2Flg = CALLBACK_V4L2_OFF;
+		/* set frame date to V4L2 */
+		frame_data.dev = p_lcd_var->pvDevData;
+		frame_data.buf = p_lcd_var->pvVideoBuf;
+
+		printk_dbg((_DEBUG_LCD & 0x02), "-> v4l2\n");
+		/*call v4l2 callback function */
+		mp200_v4l2_lcd_callback(frame_data);
+	}
+
+#if defined(CONFIG_PM) || defined(CONFIG_DPM)
+	p_lcd_var->ctrl_func = 0;
+#endif /* CONFIG_PM || CONFIG_DPM */
+
+	/* release semafore */
+	up(&p_lcd_var->sem_image_flag);
+	printk_dbg((_DEBUG_LCD & 0x80), "up(B) lcd_irq\n");
+
+	spin_unlock_irqrestore(&lcd_dev.lcd_lock, flags);
+
+	printk_dbg((_DEBUG_LCD & 0x02), "<end>\n");
+}
+
+
+/*****************************************************************************
+* MODULE   : lcd_irq_handler
+* FUNCTION : LCDC interrupt handler
+* RETURN   : IRQ_HANDLED
+* NOTE     : none
+* CREATE   : 2006/07/14 Y.Utsuhara
+* UPDATE   : 2009.10.21
+******************************************************************************/
+irqreturn_t lcd_irq_handler(int irq, void *dev_id)
+{
+	unsigned long ulRegVal32;
+	unsigned long flags;
+	spin_lock_irqsave(&lcd_dev.lcd_lock, flags);
+
+	/*  check Interuppt Status */
+	ulRegVal32 = lcd_hw_chk_int_status();
+
+	/* Interrupt Status Clear */
+	lcd_hw_int_factor_clr();
+
+	if (ulRegVal32 & LCD_UNDERRUN_BIT) {
+		/* printk_err("LCDC UNDERRUN ERROR. Reset LCDC and IMC.\n");*/
+
+		/* LCD display off */
+		lcd_hw_stop();
+
+		/* Reset LCD */
+		lcd_hw_reset();
+		/* UnReset LCD */
+		lcd_hw_unreset();
+		/* Restore LCD H/W register data */
+		lcd_hw_restore_reg();
+
+		imc_hw_reset(); /* Reset IMC */
+		imc_hw_unreset(); /* UnReset IMC */
+
+		IMC_reset_flg = 1;
+		imc_hw_restore_reg();
+
+		{
+			struct list_head *list_tmp;
+			MP200_LCD_VAR *p_lcd_var;
+			void (*callback_func[4])(void) =
+				{NULL, NULL, NULL, NULL};
+			int i = 0;
+
+			list_for_each(list_tmp, &list_lcd_var) {
+				p_lcd_var =
+					list_entry(list_tmp,
+						struct mp200_lcd_var, list);
+				switch (p_lcd_var->ctrl_func) {
+				case 2:
+					callback_func[i] =
+						lcd_callback_imc_refresh;
+					i++;
+					/* FALL THROUGH */
+				case 0:
+				default:
+					break;
+				}
+			}
+
+			for (i = 0; i < 4; i++) {
+				if (callback_func[i] == NULL)
+					break;
+				else
+					callback_func[i]();
+			}
+			/*  Interuppt Enable Set */
+			writel(LCD_UNDERRUNEN_BIT, LCDCMmioV + LCD_INTENSET);
+		}
+		/* LCD display on */
+		lcd_hw_start();
+	}
+
+	spin_unlock_irqrestore(&lcd_dev.lcd_lock, flags);
+	return IRQ_HANDLED;
+}
+
+/******************************************************************************
+* MODULE   : lcd_callback_imc_refresh
+* FUNCTION :
+* RETURN   : none
+* NOTE     : none
+* CREATE   : 2007.07.09 M.Haguro
+* UPDATE   :
+******************************************************************************/
+void lcd_callback_imc_refresh(void)
+{
+	FRAME_DATA    frame_data;
+	unsigned long flags;
+	struct list_head *list_tmp;
+	MP200_LCD_VAR *p_lcd_var;
+	int find = 0;
+
+	spin_lock_irqsave(&lcd_dev.lcd_lock, flags);
+	printk_dbg((_DEBUG_LCD & 0x01), "<start>\n");
+
+	list_for_each(list_tmp, &list_lcd_var) {
+		p_lcd_var = list_entry(list_tmp, struct mp200_lcd_var, list);
+		if (p_lcd_var->lcd_refresh_flg == IMC_R_WAIT_REFRESH) {
+			find = 1;
+			break;
+		}
+	}
+
+	if (find) {
+		/* release refresh semafore */
+		up(&lcd_dev.sem_image_refresh);
+		printk_dbg((_DEBUG_LCD & 0x80),
+		 "up(C) lcd_callback_imc_refresh\n");
+
+		/* call FB Driver function "mp200_fb_callback" */
+		mp200_fb_callback((int)p_lcd_var->uiMixFrameBufferPage,
+		 p_lcd_var->iMixDSPFlgToFB, EM1_FB_DEVICE_LCD);
+
+		/* when kick mix_image by V4L2 */
+		if (p_lcd_var->iCallbackV4L2Flg == CALLBACK_V4L2_ON) {
+			/* set frame date to V4L2 */
+			frame_data.dev = p_lcd_var->pvDevData;
+			frame_data.buf = p_lcd_var->pvVideoBuf;
+
+			printk_dbg((_DEBUG_LCD & 0x02), "-> v4l2\n");
+			/* call v4l2 callback function */
+			mp200_v4l2_lcd_refresh_callback(frame_data);
+		}
+
+		p_lcd_var->lcd_refresh_flg = IMC_R_REFRESHED;
+
+		lcd_irq_handler_callback();
+	}
+
+	printk_dbg((_DEBUG_LCD & 0x02), "<end>\n");
+	spin_unlock_irqrestore(&lcd_dev.lcd_lock, flags);
+}
+
+
+/*****************************************************************************
+* MODULE   : lcd_callback_imc_wb
+* FUNCTION :
+* RETURN   : none
+* NOTE     : none
+* CREATE   : 2007.07.09 M.Haguro
+* UPDATE   :
+******************************************************************************/
+void lcd_callback_imc_wb(int status)
+{
+	;
+}
+
+
+/********************************************************
+ *                                                      *
+ *  Init Function Definitions                           *
+ *                                                      *
+ *******************************************************/
+
+/******************************************************************************
+* MODULE   : mp200_lcd_init_module
+* FUNCTION : initialize LCD Driver
+* RETURN   : 0     : success
+*            other : fail
+* NOTE     : none
+* CREATE   : 2006.05.25 H.Nagashima
+* UPDATE   :
+******************************************************************************/
+int __init mp200_lcd_init_module(void)
+{
+	int iRet;
+
+	/* lcd device memset */
+	memset(&lcd_dev, 0, sizeof(MP200_LCD_DEV));
+
+	/* semafore initialize */
+	sema_init(&lcd_dev.sem_image_data, 1);
+	sema_init(&lcd_dev.sem_image_refresh, 1);
+
+	/* list head initialize */
+	INIT_LIST_HEAD(&list_lcd_var);
+
+	/* spin lock initialize */
+	spin_lock_init(&lcd_dev.lcd_lock);
+
+	/* call lcd_probe */
+	iRet = lcd_probe();
+	if (iRet) {
+		printk_err("lcd probe error\n");
+		lcd_probe_error(iRet);
+		return iRet;
+	}
+
+	/* variable initialized */
+	set_val_init();
+
+	/* timer initiarize */
+	lcd_timer_init();
+
+	return 0;
+}
+
+/******************************************************************************
+* MODULE   : lcd_probe
+* FUNCTION : LCD Driver probe
+* RETURN   : 0     : success
+*            other : fail
+* NOTE     : none
+* CREATE   : 2006.05.25 H.Nagashima
+* UPDATE   :
+******************************************************************************/
+static int lcd_probe()
+{
+	/* reserve LCDC Mmio region */
+#ifdef IO_ADDRESS
+	LCDCMmioV = (char *)IO_ADDRESS(LCDCMmio);
+#else
+	if (!request_mem_region(LCDCMmio, LCDCMmioLength, DEV_NAME)) {
+		printk_wrn("cannnot request LCDC mem region\n");
+		return LCD_INIT_ERROR__LCDC_MMIO_NOT_RESERVE;
+	}
+	LCDCMmioV = ioremap_nocache(LCDCMmio, LCDCMmioLength);
+	if (!LCDCMmioV) {
+		printk_wrn("cannot ioremap_nocache LCDC mmio\n");
+		return LCD_INIT_ERROR__LCDC_MMIO_NOT_REMAP;
+	}
+#endif
+	printk_dbg((_DEBUG_LCD),
+	 "LCDCMmio(0x%08lx)  LCDCMmioV(0x%p)  LCDCMmioLength(0x%lx)\n",
+	 LCDCMmio, LCDCMmioV, LCDCMmioLength);
+
+	/* initiarize work queue */
+	mp200_lcd_workqueue = create_singlethread_workqueue(DEV_NAME);
+	INIT_WORK(&wk_timeout_bottom_half, lcd_timeout_bottom_half_do);
+
+	return 0;
+}
+
+
+/******************************************************************************
+* MODULE   : lcd_probe_error
+* FUNCTION : When fail in lcd_probe, remove lcd resource
+* RETURN   : none
+* NOTE     : none
+* CREATE   : 2006.05.25 H.Nagashima
+* UPDATE   :
+******************************************************************************/
+static void lcd_probe_error(int iErrorMode)
+{
+	switch (iErrorMode) {
+	case LCD_INIT_ERROR__LCDM_START:		/* FALL THROUGH */
+	case LCD_INIT_ERROR__LCD_IRQ_NOT_REQUEST:	/* FALL THROUGH */
+	case LCD_INIT_ERROR__IMC_INIT:			/* FALL THROUGH */
+	case LCD_INIT_ERROR__LCDM_INIT:			/* FALL THROUGH */
+		exit_lcdhw();
+		free_irq(INT_LCD, NULL);
+		/* Reset LCD */
+		lcd_hw_reset();
+#ifndef IO_ADDRESS
+		iounmap(LCDCMmioV);
+	case LCD_INIT_ERROR__LCDC_MMIO_NOT_REMAP:	/* FALL THROUGH */
+		release_mem_region(LCDCMmio, LCDCMmioLength);
+	case LCD_INIT_ERROR__LCDC_MMIO_NOT_RESERVE:	/* FALL THROUGH */
+#endif
+	default:
+		break;
+	}
+
+	return;
+}
+
+
+/******************************************************************************
+* MODULE   : set_val_init
+* FUNCTION : variable default set
+* RETURN   : none
+* NOTE     : none
+* CREATE   : 2006.05.25 H.Nagashima
+* UPDATE   :
+******************************************************************************/
+static void set_val_init(void)
+{
+	int i;
+
+	/* other img infomation */
+	uiMaskColor_tmp      = 0x0020;
+	uiAlpha_tmp          = 0xFF;
+
+	/* flags */
+	iMixDSPFlg_tmp       = MIX_DSP_OFF;
+	iDSPPauseFlg         = PAUSE_DSP_OFF;
+	uiMaskColorFlag_tmp  = FB_MASK_COLOR_DISP_OFF;
+	uiAbsolutelyUpFlag   = FB_UPDATE_OFF;
+
+	for (i = 0; i < 2; i++) {
+		sema_init(&lcd_var[i].sem_image_flag, 1);
+
+		/* input image data from fb driver */
+		lcd_var[i].uiMixFrameBufferPage = DISPLAY_FRAME_NO_A;
+
+		/* flags */
+		lcd_var[i].iMixDSPFlgToFB       = MIX_DSP_OFF;
+		lcd_var[i].iCallbackV4L2Flg     = CALLBACK_V4L2_OFF;
+
+		/* frame data */
+		lcd_var[i].pvDevData            = 0x00;
+		lcd_var[i].pvVideoBuf           = 0x00;
+
+		lcd_var[i].lcd_refresh_flg = IMC_R_IDLE;
+#if defined(CONFIG_PM) || defined(CONFIG_DPM)
+		lcd_var[i].ctrl_func       = 0;
+#endif /* CONFIG_PM || CONFIG_DPM */
+	}
+
+	blank_state.current_mode  = FB_BLANK_UNBLANK;
+	blank_state.lcd_backlight = 1;
+	blank_state.lcd_output    = 1;
+	blank_state.lcd_clock     = 1;
+
+	return;
+}
+
+
+/********************************************************
+ *  Timer Function Definitions                          *
+ *******************************************************/
+/******************************************************************************
+* MODULE   : lcd_timer_init
+* FUNCTION : timer function init
+* RETURN   : none
+* NOTE     : private function
+* CREATE   : 2006.06.07 H.Nagashima
+* UPDATE   :
+******************************************************************************/
+static void lcd_timer_init(void)
+{
+	init_timer(&lcd_timer);
+	lcd_timer.function = lcd_timeout;
+	lcd_timer.data = 0;
+	iTimerFlag = LCD_TIMER_STOP;
+
+	return;
+}
+
+
+/******************************************************************************
+* MODULE   : lcd_timeout
+* FUNCTION : when call mp200_fb_call_timer
+* RETURN   : none
+* NOTE     : public function
+* CREATE   : 2006.06.07 H.Nagashimia
+* UPDATE   :
+******************************************************************************/
+static void lcd_timeout(unsigned long data)
+{
+	/* change LCD status to PAUSE */
+	iDSPPauseFlg = PAUSE_DSP_ON;
+
+	queue_work(mp200_lcd_workqueue, &wk_timeout_bottom_half);
+	return;
+}
+
+
+/******************************************************************************
+* MODULE   : lcd_timeout_bottom_half_do
+* FUNCTION : when call mp200_fb_call_timer
+* RETURN   : none
+* NOTE     : public function
+* CREATE   : 2006.07.21 M.Haguro
+* UPDATE   :
+******************************************************************************/
+static void lcd_timeout_bottom_half_do(struct work_struct *num)
+{
+	/* get semafore */
+	down(&lcd_dev.sem_image_data);
+	printk_dbg((_DEBUG_LCD & 0x80), "down(A) lcd_timeout\n");
+
+	/* mix image */
+	mix_image(CALLBACK_V4L2_OFF, UPDATE_ON, SET_LAYER_2D);
+
+	return;
+}
+
+
+/********************************************************
+ *  Exit Function Definitions                           *
+ *******************************************************/
+/******************************************************************************
+* MODULE   : mp200_lcd_exit_module
+* FUNCTION : cleanup LCD module
+* RETURN   : none
+* NOTE     : none
+* CREATE   : 2006.05.25 H.Nagashima
+* UPDATE   :
+******************************************************************************/
+void mp200_lcd_exit_module()
+{
+	lcd_hw_stop();
+	mp200_lcd_remove();
+}
+
+
+/******************************************************************************
+* MODULE   : mp200_lcd_remove
+* FUNCTION : release LCD resource
+* RETURN   : none
+* NOTE     : none
+* CREATE   : 2006.05.29 H.Nagashima
+* UPDATE   :
+******************************************************************************/
+static void mp200_lcd_remove()
+{
+	/* power off LCD */
+	lcd_hw_backlight_off();
+	lcd_hw_power_off();
+
+	free_irq(INT_LCD, NULL);
+	iounmap(LCDCMmioV);
+	release_mem_region(LCDCMmio, LCDCMmioLength);
+
+	/* Reset LCD */
+	lcd_hw_reset();
+
+	return;
+}
+
+
+#if defined(CONFIG_PM) || defined(CONFIG_DPM)
+/********************************************************
+ *  Suspend/Resume Function Definitions                 *
+ *******************************************************/
+/******************************************************************************
+* MODULE   : mp200_lcd_suspend
+* FUNCTION : suspend LCD driver
+* RETURN   : 0 : success
+* NOTE     : none
+* CREATE   : 2006.08.15 H.Nagashima
+* UPDATE   :
+******************************************************************************/
+int mp200_lcd_suspend(struct platform_device *dev, pm_message_t state)
+{
+	unsigned long ulRegVal32, ulBUSSEL_save;
+
+	if ((state.event == DEV_SUSPEND_IDLE_1) &&
+	    ((lcd_var[0].ctrl_func | lcd_var[1].ctrl_func) != 0)) {
+		return -EBUSY;
+	}
+
+	if (blank_state.lcd_output == 1) {
+		ulRegVal32 = lcd_hw_chk_bussel();
+		ulBUSSEL_save = ulRegVal32;
+		switch (ulRegVal32 & LCD_BUSSEL_BIT) {
+		case LCD_BUSSEL_BACKCOLOR:	/* FALL THROUGH */
+		case LCD_BUSSEL_BLACK:
+			break;
+		case LCD_BUSSEL_WB_LOCAL:	/* FALL THROUGH */
+		case LCD_BUSSEL_LOCAL:		/* FALL THROUGH */
+		default:
+			writel(LCD_BUSSEL_BLACK, LCDCMmioV + LCD_BUSSEL);
+			break;
+		}
+	}
+
+	if (state.event == DEV_SUSPEND_IDLE_1) {
+		if (blank_state.lcd_output == 1) {
+			ulRegVal32 = lcd_hw_chk_status();
+			switch (ulRegVal32 & LCD_MODSTATUS_BIT) {
+			case LCD_MODSTATUS_BACKCOLOR:	/* FALL THROUGH */
+			case LCD_MODSTATUS_BLACK:
+				return 0;
+			case LCD_MODSTATUS_WB_LOCAL:	/* FALL THROUGH */
+			case LCD_MODSTATUS_LOCAL:	/* FALL THROUGH */
+			default:
+				return -EBUSY;
+			}
+		} else
+			return 0;
+
+	} else { /* state.event == PM_EVENT_SUSPEND */
+		if (mp200_sleep_while_idle) {
+			/* Restore IMC H/W register data after resume */
+			IMC_reset_flg = 1;
+			return 0;
+		} else {
+			DPM_suspend_flg = 1;
+			/* LCD timer stop */
+			del_timer(&lcd_timer);
+			if (blank_state.lcd_output == 1) {
+				/* LCD status check */
+				lcd_suspend_chk_lcdout();
+				if (blank_state.lcd_backlight == 1) {
+					/* BackLight OFF  */
+					lcd_hw_backlight_off();
+				}
+				/* LCD display off */
+				lcd_hw_stop();
+			}
+			if (blank_state.lcd_clock == 1) {
+				/* Save LCD H/W register data */
+				lcd_hw_save_reg();
+
+				/* Reset LCD */
+				lcd_hw_reset();
+			}
+			/* Restore IMC H/W register data after resume */
+			IMC_reset_flg = 1;
+			return 0;
+		}
+	}
+}
+
+
+/******************************************************************************
+* MODULE   : lcd_suspend_chk_lcdout
+* FUNCTION : enabled suspend
+* RETURN   :  0 : success
+*            -1 : failed
+* NOTE     : none
+* CREATE   : 2008.10.09 M.Haguro
+* UPDATE   :
+******************************************************************************/
+int lcd_suspend_chk_lcdout(void)
+{
+	int i = 0;
+	int iRet = -1;
+	int wait_max  = 32; /* ms */
+	int wait_time = 2;  /* ms */
+	int wait_cnt  = wait_max / wait_time;
+	unsigned long ulRegVal32;
+
+	do {
+		ulRegVal32 = lcd_hw_chk_status();
+		switch (ulRegVal32 & LCD_MODSTATUS_BIT) {
+		case LCD_MODSTATUS_BACKCOLOR:	/* FALL THROUGH */
+		case LCD_MODSTATUS_BLACK:	/* FALL THROUGH */
+			i    = wait_cnt;
+			iRet = 0;
+			break;
+		case LCD_MODSTATUS_WB_LOCAL:	/* FALL THROUGH */
+		case LCD_MODSTATUS_LOCAL:
+		default:
+			if (i == wait_cnt) {
+				printk_dbg((_DEBUG_LCD & 0x01),
+				 "failed(%08lx)\n", ulRegVal32);
+			} else {
+				mdelay(wait_time);
+			}
+			break;
+		}
+		i++;
+	} while (i <= wait_cnt);
+
+	return iRet;
+}
+
+
+/******************************************************************************
+* MODULE   : mp200_lcd_resume
+* FUNCTION : suspend LCD driver
+* RETURN   : 0 : success
+* NOTE     : none
+* CREATE   : 2006.08.15 H.Nagashima
+* UPDATE   :
+******************************************************************************/
+int mp200_lcd_resume(struct platform_device *dev)
+{
+	struct list_head *list_tmp;
+	MP200_LCD_VAR *p_lcd_var;
+	void (*callback_func[4])(void) = {NULL, NULL, NULL, NULL};
+	int i = 0;
+
+	if (DPM_suspend_flg) {
+		/* Restore IMC H/W register data */
+		if (IMC_reset_flg)
+			imc_hw_restore_reg();
+
+		if (blank_state.lcd_clock == 1) {
+			/* UnReset LCD */
+			lcd_hw_unreset();
+
+			/* Restore LCD H/W register data */
+			lcd_hw_restore_reg();
+		}
+		if (blank_state.lcd_output == 1) {
+			/* LCD display on */
+			lcd_hw_start();
+		}
+		if (blank_state.lcd_backlight == 1) {
+			/* BackLight ON */
+			lcd_hw_backlight_on();
+		}
+
+		/* LCD timer start */
+		if ((iTimerFlag == LCD_TIMER_START)
+		 && (iMixDSPFlg_tmp == MIX_DSP_ON)) {
+			lcd_timer.expires = jiffies
+			 + (MIX_DSP_TIMEOUT * 10 * HZ / 1000);
+			add_timer(&lcd_timer);
+		}
+
+		if (blank_state.lcd_output == 1) {
+			list_for_each(list_tmp, &list_lcd_var) {
+				p_lcd_var = list_entry(list_tmp,
+				 struct mp200_lcd_var, list);
+				switch (p_lcd_var->ctrl_func) {
+				case 2:
+					callback_func[i] =
+						lcd_callback_imc_refresh;
+					i++;
+					/* FALL THROUGH */
+				case 0:
+				default:
+					break;
+				}
+			}
+
+			for (i = 0; i < 4; i++) {
+				if (callback_func[i] == NULL)
+					break;
+				else
+					callback_func[i]();
+			}
+		}
+
+		DPM_suspend_flg = 0;
+	}
+	return 0;
+}
+#endif /* CONFIG_PM || CONFIG_DPM */
+
+
+MODULE_AUTHOR("NEC Electronics Corporation.");
+MODULE_DESCRIPTION("EM1 LCD control driver");
+MODULE_LICENSE("GPL");
+
+
+/* module alias */
+#ifdef MODULE
+module_init(mp200_lcd_init_module);
+module_exit(mp200_lcd_exit_module);
+#else
+#ifndef CONFIG_FB_MP200
+device_initcall(mp200_lcd_init_module);
+#endif
+#endif
diff --git a/drivers/video/mp200/mp200_lcd.h b/drivers/video/mp200/mp200_lcd.h
new file mode 100644
index 0000000..b051478
--- /dev/null
+++ b/drivers/video/mp200/mp200_lcd.h
@@ -0,0 +1,76 @@
+/*
+ * File Name       : /drivers/video/mp200/mp200_lcd.h
+ * Function        : LCD driver corresponding to V4L2
+ * Release Version :
+ * Release Date    : 2009.10.21
+ *
+ * Copyright (C) NEC Electronics Corporation 2009
+ *
+ *
+ * This program is free software;you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by Free Softwere
+ * Foundation; either version 2 of License, or (at your option) any later
+ * version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warrnty of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
+ * details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; If not, write to the Free Software Foundation, Inc., 59 Temple
+ * Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+
+#ifndef _MP200_LCD_H_
+#define _MP200_LCD_H_
+
+
+
+/********************************************************
+ *  Variables                                           *
+ *******************************************************/
+extern unsigned int  uiInverseFlag_tmp;	/* inverse mode Flag */
+
+/* LCDC MMIO */
+extern char         *LCDCMmioV;
+
+/* FrameBuf(LCD) */
+extern unsigned long FrameBufLength;
+extern char         *FrameBufV;		/* vaddr */
+
+
+#if defined(CONFIG_PM) || defined(CONFIG_DPM)
+extern int     IMC_reset_flg;
+#endif /* CONFIG_PM || CONFIG_DPM */
+
+
+/********************************************************
+ *  Prototype declarations of function                  *
+ *******************************************************/
+extern int          mp200_lcd_blank(int blank_mode);
+extern int          mp200_lcd_set_v4l2_image(V4L2_IMAGE_INFO *v4l2_image_info);
+extern int          mp200_lcd_set_fb_image(FB_IMAGE_INFO *fb_image_info);
+extern int  __init  mp200_lcd_init_module(void);
+extern void         mp200_lcd_exit_module(void);
+#if defined(CONFIG_PM) || defined(CONFIG_DPM)
+extern int          mp200_lcd_suspend(struct platform_device *dev,
+		     pm_message_t state);
+extern int          mp200_lcd_resume(struct platform_device *dev);
+#endif /* CONFIG_PM || CONFIG_DPM */
+extern int          mp200_lcd_blank(int blank_mode);
+
+/*** Private function ***/
+/* VSYNC interrupt handler */
+extern irqreturn_t  lcd_irq_handler(int irq, void *dev_id);
+
+extern void         lcd_callback_imc_refresh(void);
+extern void         lcd_callback_imc_wb(int status);
+
+extern void         mp200_v4l2_lcd_callback(FRAME_DATA frame_data);
+extern void         mp200_v4l2_lcd_refresh_callback(FRAME_DATA frame_data);
+
+
+#endif /* _MP200_LCD_H_ */
diff --git a/drivers/video/mp200/mp200_lcd_common.h b/drivers/video/mp200/mp200_lcd_common.h
new file mode 100644
index 0000000..8172acd
--- /dev/null
+++ b/drivers/video/mp200/mp200_lcd_common.h
@@ -0,0 +1,84 @@
+/*
+ * File Name       : /drivers/video/mp200/mp200_lcd_common.h
+ * Function        : LCD Driver corresponding to V4L2 only definitions
+ * Release Version :
+ * Release Date    :
+ *
+ * Copyright (C) NEC Electronics Corporation 2006
+ *
+ *
+ * This program is free software;you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by Free Softwere
+ * Foundation; either version 2 of License, or (at your option) any later
+ * version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warrnty of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
+ * details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; If not, write to the Free Software Foundation, Inc., 59 Temple
+ * Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#ifndef _MP200_LCD_COMMON_H_
+#define _MP200_LCD_COMMON_H_
+
+/********************************************************
+ *  Definitions                                         *
+ *******************************************************/
+/*
+ * Flags
+ */
+/* DSP mix ON/OFF */
+#define MIX_DSP_OFF		0
+#define MIX_DSP_ON		1
+/* DSP pause status */
+#define PAUSE_DSP_OFF		0
+#define PAUSE_DSP_ON		1
+/* callback to V4L2 status */
+#define CALLBACK_V4L2_OFF	0
+#define CALLBACK_V4L2_ON	1
+/* update screen status */
+#define UPDATE_OFF		0
+#define UPDATE_ON		1
+/* display frame */
+#define DISPLAY_FRAME_NO_A	0
+#define DISPLAY_FRAME_NO_B	1
+
+/* IMC layer setup */
+#define SET_LAYER_2D		1
+#define SET_LAYER_V4L2		4
+#define CLR_LAYER_BIT		8
+#define CLR_LAYER_V4L2		(CLR_LAYER_BIT | SET_LAYER_V4L2)
+
+/*
+ * Error type
+ */
+#define LCD_SUCCESS					0
+#define LCD_INIT_ERROR__LCDC_MMIO_NOT_RESERVE		-1
+#define LCD_INIT_ERROR__LCDC_MMIO_NOT_REMAP		-2
+#define LCD_INIT_ERROR__LCDM_INIT			-3
+#define LCD_INIT_ERROR__IMC_INIT			-4
+#define LCD_INIT_ERROR__LCD_IRQ_NOT_REQUEST		-5
+#define LCD_INIT_ERROR__LCDM_START			-6
+
+
+/*
+ * LCD H/W define
+ */
+#define LCD_FLAME_A				0x00000001
+#define LCD_FLAME_B				0x00000002
+
+
+/*
+ * timer
+ */
+#define MIX_DSP_TIMEOUT 10	/* (MIX_DSP_TIMEOUT * 10ms) is waittime */
+#define LCD_TIMER_STOP  0
+#define LCD_TIMER_START 1
+
+
+#endif /* _MP200_LCD_COMMON_H_ */
diff --git a/drivers/video/mp200/mp200_lcd_perf.h b/drivers/video/mp200/mp200_lcd_perf.h
new file mode 100644
index 0000000..e69de29
diff --git a/drivers/video/mp200/mp200_lcdhw.c b/drivers/video/mp200/mp200_lcdhw.c
new file mode 100644
index 0000000..ca9474d
--- /dev/null
+++ b/drivers/video/mp200/mp200_lcdhw.c
@@ -0,0 +1,1881 @@
+/*
+ * File Name       : /drivers/video/mp200/mp200_lcdhw.c
+ * Function        : LCD Driver corresponding to V4L2 (H/W Control)
+ * Release Version :
+ * Release Date    : 2009.10.21
+ *
+ * Copyright (C) NEC Electronics Corporation 2009
+ *
+ *
+ * This program is free software;you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by Free Softwere
+ * Foundation; either version 2 of License, or (at your option) any later
+ * version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warrnty of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
+ * details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; If not, write to the Free Software Foundation, Inc., 59 Temple
+ * Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+
+/********************************************************
+ *  Definitions                                         *
+ *******************************************************/
+#define _DEBUG_LCDHW  0x00 /* 00008421(bit) */
+			   /* 0x01: debug function in
+			    * 0x02: debug function out
+			    * 0x04: debug IMC
+			    * 0x08: debug frame change
+			    * 0x40: debug FBIOBLANK
+			    */
+
+
+/********************************************************
+ *  Definitions                                         *
+ *******************************************************/
+#define DEV_NAME "mp200_lcdhw"
+
+
+/********************************************************
+ *  Macros                                              *
+ *******************************************************/
+#define printk_err(fmt, arg...) \
+	do {                     \
+		printk(KERN_ERR DEV_NAME ": %s: " fmt, __func__, ## arg); \
+	} while (0)
+
+#define printk_wrn(fmt, arg...) \
+	do {                     \
+		printk(KERN_WARNING DEV_NAME ": %s: " fmt, __func__, ## arg); \
+	} while (0)
+
+#define printk_info(fmt, arg...) \
+	do {                      \
+		printk(KERN_INFO DEV_NAME ": " fmt, ## arg); \
+	} while (0)
+
+#if _DEBUG_LCDHW
+#define printk_dbg(level, fmt, arg...) \
+	do {                            \
+		if (level > 0) \
+			printk(KERN_DEBUG DEV_NAME ": %s: " fmt, \
+			__func__, ## arg); \
+	} while (0)
+#else
+#define printk_dbg(level, fmt, arg...) \
+	;
+#endif
+
+
+/********************************************************
+ *  Include Files                                       *
+ *******************************************************/
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/version.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/io.h>
+#include <linux/delay.h>
+
+#include <mach/irqs.h>
+#include <mach/spi.h>
+#include <mach/smu.h>
+#include <mach/pmu.h>
+#include <mach/em1_mem.h>
+
+#include <mach/gpio.h>
+
+#include "lcdc.h"
+#include "imc.h"
+#include "mp200_common.h"
+#include "mp200_lcd_common.h"
+#include "mp200_lcdhw.h"
+#include "mp200_lcd.h"
+#include "mp200_imc.h"
+
+
+/********************************************************
+ *  IMC request structure                               *
+ *******************************************************/
+struct mp200_imc_param {
+	unsigned long			imc_control;
+	struct mp200_imc_preset		imc_preset;
+	struct mp200_imc_update_vsync	imc_vsync;
+	struct mp200_imc_update_reserve	imc_reserve;
+
+	struct imc_gamma_param		param_gamma;
+	struct imc_wb_param		param_wb;
+	struct imc_yuv_param		param_yuv;
+	struct imc_keycolor_param	param_keycolor;
+	struct imc_bytelane_param	param_bytelane;
+	struct l01_param		param_l0;
+	struct l01_param		param_l1a;
+	struct l01_param		param_l1b;
+	struct l01_param		param_l1c;
+	struct l2_param			param_l2a;
+	struct l2_param			param_l2b;
+	struct bg_param			param_bg;
+
+	imc_callback_func_refresh	callback_refresh;
+	imc_callback_func_wb		callback_wb;
+};
+
+static struct mp200_imc_param          *imc_param;
+static struct mp200_imc_preset         *imc_preset;
+static struct mp200_imc_update_vsync   *imc_vsync;
+static struct mp200_imc_update_reserve *imc_reserve;
+
+       struct l01_param			fb_layer;
+       struct l2_param			v4l2_layer;
+       struct mp200_imc_update_vsync	ImcNxtVsync;
+       struct imc_keycolor_param	ImcNxtKeycol;
+       struct imc_bytelane_param	ImcNxtBytelane;
+
+
+/********************************************************
+ * IMC register initialize                              *
+ *******************************************************/
+#define IMC_CPUBUFSEL_INIT		0x00000000
+#define IMC_GAMMA_ADR_INIT		0x00000000
+#define IMC_GAMMA_DATA_INIT		0x00000000
+
+#define IMC_L0_KEYCOLOR_INIT		0x00000000
+#define IMC_L1x_KEYCOLOR_INIT		0x00000000
+#define IMC_L2A_BYTELANE_INIT		0x0000E4E4
+#define IMC_L2B_BYTELANE_INIT		0x0000E4E4
+
+#define IMC_YGAIN_OFFSET_INIT		0x00000080
+#define IMC_UGAIN_OFFSET_INIT		0x00000080
+#define IMC_VGAIN_OFFSET_INIT		0x00000080
+
+#define IMC_COEF_R0_INIT		0x00000000
+#define IMC_COEF_R1_INIT		0x00000000
+#define IMC_COEF_R2_INIT		0x00000000
+#define IMC_COEF_R3_INIT		0x00000000
+#define IMC_COEF_G0_INIT		0x00000000
+#define IMC_COEF_G1_INIT		0x00000000
+#define IMC_COEF_G2_INIT		0x00000000
+#define IMC_COEF_G3_INIT		0x00000000
+#define IMC_COEF_B0_INIT		0x00000000
+#define IMC_COEF_B1_INIT		0x00000000
+#define IMC_COEF_B2_INIT		0x00000000
+#define IMC_COEF_B3_INIT		0x00000000
+
+#define IMC_L0_CONTROL_INIT		0x00000000
+#define IMC_L0_FORMAT_INIT		0x00000000
+#define IMC_L0_KEYENABLE_INIT		0x00000000
+#define IMC_L0_ALPHA_INIT		0x00000000
+#define IMC_L0_RESIZE_INIT		0x00000000
+#define IMC_L0_OFFSET_INIT		0x00000000
+#define IMC_L0_FRAMEADR_INIT		0x00000000
+#define IMC_L0_POSITION_INIT		0x00000000
+#define IMC_L0_SIZE_INIT		0x00000000
+
+#define IMC_L1A_CONTROL_INIT		0x00000000
+#define IMC_L1A_FORMAT_INIT		0x00000000
+#define IMC_L1A_KEYENABLE_INIT		0x00000000
+#define IMC_L1A_ALPHA_INIT		0x00000000
+#define IMC_L1A_RESIZE_INIT		0x00000000
+#define IMC_L1A_OFFSET_INIT		0x00000000
+#define IMC_L1A_FRAMEADR_INIT		0x00000000
+#define IMC_L1A_POSITION_INIT		0x00000000
+#define IMC_L1A_SIZE_INIT		0x00000000
+
+#define IMC_L1B_CONTROL_INIT		0x00000000
+#define IMC_L1B_KEYENABLE_INIT		0x00000000
+#define IMC_L1B_ALPHA_INIT		0x00000000
+#define IMC_L1B_FRAMEADR_INIT		0x00000000
+#define IMC_L1B_POSITION_INIT		0x00000000
+#define IMC_L1B_SIZE_INIT		0x00000000
+
+#define IMC_L1C_CONTROL_INIT		0x00000000
+#define IMC_L1C_KEYENABLE_INIT		0x00000000
+#define IMC_L1C_ALPHA_INIT		0x00000000
+#define IMC_L1C_FRAMEADR_INIT		0x00000000
+#define IMC_L1C_POSITION_INIT		0x00000000
+#define IMC_L1C_SIZE_INIT		0x00000000
+
+#define IMC_L2A_CONTROL_INIT		0x00000000
+#define IMC_L2A_FORMAT_INIT		0x00000000
+#define IMC_L2A_BUFSEL_INIT		0x00000000
+#define IMC_L2A_RESIZE_INIT		0x00000000
+#define IMC_L2A_MIRROR_INIT		0x00000000
+#define IMC_L2A_OFFSET_INIT		0x00000000
+#define IMC_L2A_FRAMEADR_YP_INIT	0x00000000
+#define IMC_L2A_FRAMEADR_UP_INIT	0x00000000
+#define IMC_L2A_FRAMEADR_YQ_INIT	0x00000000
+#define IMC_L2A_FRAMEADR_UQ_INIT	0x00000000
+#define IMC_L2A_POSITION_INIT		0x00000000
+#define IMC_L2A_SIZE_INIT		0x00000000
+
+#define IMC_L2B_CONTROL_INIT		0x00000000
+#define IMC_L2B_FORMAT_INIT		0x00000000
+#define IMC_L2B_BUFSEL_INIT		0x00000000
+#define IMC_L2B_RESIZE_INIT		0x00000000
+#define IMC_L2B_MIRROR_INIT		0x00000000
+#define IMC_L2B_OFFSET_INIT		0x00000000
+#define IMC_L2B_FRAMEADR_YP_INIT	0x00000000
+#define IMC_L2B_FRAMEADR_UP_INIT	0x00000000
+#define IMC_L2B_FRAMEADR_YQ_INIT	0x00000000
+#define IMC_L2B_FRAMEADR_UQ_INIT	0x00000000
+#define IMC_L2B_POSITION_INIT		0x00000000
+#define IMC_L2B_SIZE_INIT		0x00000000
+
+#define IMC_BG_FORMAT_INIT		0x00000000
+#define IMC_BG_RESIZE_INIT		0x00000000
+#define IMC_BG_OFFSET_INIT		0x00000000
+#define IMC_BG_FRAMEADR_INIT		0x00000000
+
+
+/********************************************************
+ * LCD Module timing                                    *
+ *******************************************************/
+#define LCD_HAREA_VAL		FRONT_WIDTH
+#define LCD_HPULSE		1
+#define LCD_HFRONTP		6
+#define LCD_HBACKP		4
+#define LCD_HBLANK_VAL		(LCD_HFRONTP + LCD_HPULSE + LCD_HBACKP)
+#define LCD_VAREA_VAL		FRONT_HEIGHT
+#define LCD_VPULSE		1
+#define LCD_VFRONTP		3
+#define LCD_VBACKP		6
+#define LCD_VBLANK_VAL		(LCD_VFRONTP + LCD_VPULSE + LCD_VBACKP)
+
+
+/********************************************************
+ * LCDC register initialize                             *
+ *******************************************************/
+#if defined(CONFIG_MP200_LCD_RGB666)
+/* Control for LCDC      : RGB666 output */
+#define LCD_CONTROL_INIT	LCD_OFORMAT_RGB666
+/* Input Format select   : RGB666 input  */
+#define LCD_IFORMAT_INIT	LCD_IFORMAT_RGB666
+#else
+/* Control for LCDC      : RGB565 output */
+#define LCD_CONTROL_INIT	LCD_OFORMAT_RGB565
+/* Input Format select   : RGB565 input  */
+#define LCD_IFORMAT_INIT	LCD_IFORMAT_RGB565
+#endif /* CONFIG_MP200_LCD_RGB666 */
+
+/* Horizontal Synchronizing Signal Total Width : 811 */
+#define LCD_HTOTAL_INIT		(LCD_HAREA_VAL + LCD_HBLANK_VAL)
+/* Horizontal Display Area Width               : 800 */
+#define LCD_HAREA_INIT		(LCD_HAREA_VAL)
+/* Horizontal Synchronizing Signal Edge1       :   6 */
+#define LCD_HEDGE1_INIT		(LCD_HFRONTP)
+/* Horizontal Synchronizing Signal Edge2       :   7 */
+#define LCD_HEDGE2_INIT		(LCD_HFRONTP + LCD_HPULSE)
+/* Vertical Synchronizing Signal Total Width   : 488 */
+#define LCD_VTOTAL_INIT		(LCD_VAREA_VAL + LCD_VBLANK_VAL)
+/* Vertical Display Area Width                 : 480 */
+#define LCD_VAREA_INIT		(LCD_VAREA_VAL)
+/* Vertical Synchronizing Signal Edge1         :   3 */
+#define LCD_VEDGE1_INIT		(LCD_VFRONTP)
+/* Vertical Synchronizing Signal Edge2         :   4 */
+#define LCD_VEDGE2_INIT		(LCD_VFRONTP + LCD_VPULSE)
+
+#define LCD_QOS_INIT		0x00000180
+/* Access Bus Select             : Local Bus         */
+#define LCD_BUSSEL_UPDATE	LCD_BUSSEL_LOCAL
+/* Access Bus Select             : Black Only        */
+#define LCD_BUSSEL_INIT		LCD_BUSSEL_BLACK
+/* AREA Address for Frame Buffer :                   */
+#define LCD_AREAADR_INIT	0x00
+#define LCD_BACKCOL_INIT \
+ (0x00 << LCD_BGRED_SFT | 0x00 << LCD_BGGREEN_SFT | 0x00 << LCD_BGBLUE_SFT)
+
+
+/********************************************************
+ * LCD Module initialize command                        *
+ *******************************************************/
+#define LCDM_SPI_CMD_POWERON	81
+#define LCDM_SPI_CMD_START	1
+#define LCDM_SPI_CMD_POWEROFF	4
+#define LCDM_SPI_CMD_STANDBY	1
+#define LCDM_SPI_CMD_WAKEUP	1
+
+const unsigned int lcdm_spi_cmd_poweron[LCDM_SPI_CMD_POWERON][2] = {
+	{0x03, 0x01}, {0x00, 0x00}, {0x01, 0x01}, {0x04, 0x00}, {0x05, 0x14},
+	{0x06, 0x24}, {0x10, 0xd7}, {0x11, 0x00}, {0x12, 0x00}, {0x13, 0x55},
+	{0x14, 0x01}, {0x15, 0x70}, {0x16, 0x1e}, {0x17, 0x25}, {0x18, 0x25},
+	{0x19, 0x02}, {0x1a, 0x02}, {0x1b, 0xa0}, {0x20, 0x2f}, {0x21, 0x0f},
+	{0x22, 0x0f}, {0x23, 0x0f}, {0x24, 0x0f}, {0x25, 0x0f}, {0x26, 0x0f},
+	{0x27, 0x00}, {0x28, 0x02}, {0x29, 0x02}, {0x2a, 0x02}, {0x2b, 0x0f},
+	{0x2c, 0x0f}, {0x2d, 0x0f}, {0x2e, 0x0f}, {0x2f, 0x0f}, {0x30, 0x0f},
+	{0x31, 0x0f}, {0x32, 0x00}, {0x33, 0x02}, {0x34, 0x02}, {0x35, 0x02},
+	{0x50, 0x0c}, {0x53, 0x42}, {0x54, 0x42}, {0x55, 0x41}, {0x56, 0x14},
+	{0x59, 0x88}, {0x5a, 0x01}, {0x5b, 0x00}, {0x5c, 0x02}, {0x5d, 0x0c},
+	{0x5e, 0x1c}, {0x5f, 0x27}, {0x62, 0x49}, {0x63, 0x27}, {0x66, 0x76},
+	{0x67, 0x27}, {0x70, 0x01}, {0x71, 0x0e}, {0x72, 0x02}, {0x73, 0x0c},
+	{0x76, 0x0c}, {0x79, 0x30}, {0x82, 0x00}, {0x83, 0x00}, {0x84, 0xfc},
+	{0x86, 0x00}, {0x88, 0x00}, {0x8a, 0x00}, {0x8b, 0x00}, {0x8c, 0x00},
+	{0x8d, 0xfc}, {0x8f, 0x00}, {0x91, 0x00}, {0x93, 0x00}, {0x94, 0x00},
+	{0x95, 0x00}, {0x96, 0xfc}, {0x98, 0x00}, {0x9a, 0x00}, {0x9c, 0x00},
+	{0x9d, 0x00}
+};
+
+const unsigned int lcdm_spi_cmd_start[LCDM_SPI_CMD_START][2] = {
+	{0x02, 0x00}
+};
+
+const unsigned int lcdm_spi_cmd_poweroff[LCDM_SPI_CMD_POWEROFF][2] = {
+	{0x10, 0x05}, {0x10, 0x01}, {0x10, 0x00}, {0x03, 0x01}
+};
+
+
+/********************************************************
+ * LCDC register initialize                             *
+ *******************************************************/
+#define CHG_PINSEL_G48_LCD_BIT  0xFFFFFFF0
+#define CHG_PINSEL_G48_LCD_INIT 0x55555550
+#define CHG_PINSEL_G64_LCD_BIT  0x0000FFFF
+#define CHG_PINSEL_G64_LCD_INIT 0x00005555
+
+
+/********************************************************
+ *  Variables                                           *
+ *******************************************************/
+       int init_is_first   = 1;
+
+
+/********************************************************
+ * to calculate vertical frequency cycle                *
+ *******************************************************/
+#define REFERENCE_CLOCK	32768		/* Hz */
+#define LCD_LCLK_TYP	23800		/* kHz */
+#define TV_TYP		16630		/* us */
+#define LCD_VTOTAL_TYP	488
+
+
+/********************************************************
+ *  Prototype declarations of local function            *
+ *******************************************************/
+/*
+ * LCD Driver (H/W)
+ */
+
+/* ------------------ LCD initialize function ------------------------------ */
+static void lcd_hw_init(void);
+static void lcd_controller_hw_init(void);
+static inline void lcd_controller_hw_init_lcdsize(void);
+
+/* ------------------ LCD module initialize function ----------------------- */
+static int lcd_module_hw_init(void);
+static void lcd_module_hw_unreset(void);
+static int lcd_module_hw_power_on(void);
+static int lcd_module_hw_power_off(void);
+static int lcd_module_hw_start(void);
+static int lcd_module_hw_spiw(unsigned char cmd, unsigned char param);
+
+/* ------------------ IMC initialize function ------------------------------ */
+static int  imc_hw_init(void);
+
+static void *imc_hw_init_preset_gamma(struct imc_gamma_param *param_gamma);
+static void *imc_hw_init_preset_wb(struct imc_wb_param *param_wb);
+static void *imc_hw_init_preset_yuv(struct imc_yuv_param *param_yuv);
+static void
+ *imc_hw_init_preset_keycolor(struct imc_keycolor_param *param_keycolor);
+static void
+ *imc_hw_init_preset_bytelane(struct imc_bytelane_param *param_bytelane);
+static void *imc_hw_init_reserve_l0(struct l01_param *param_l0);
+static void *imc_hw_init_reserve_l1a(struct l01_param *param_l1a);
+static void *imc_hw_init_reserve_l1b(struct l01_param *param_l1b);
+static void *imc_hw_init_reserve_l1c(struct l01_param *param_l1c);
+static void *imc_hw_init_reserve_l2a(struct l2_param *param_l2a);
+static void *imc_hw_init_reserve_l2b(struct l2_param *param_l2b);
+static void *imc_hw_init_reserve_bg(struct bg_param *param_bg);
+
+
+
+
+
+/* ------------------ inline function -------------------------------------- */
+inline void chk_errno(int errno, char **cnum)
+{
+	switch (errno) {
+	case ENODEV:
+		*cnum = "ENODEV";
+		break;
+	case EINVAL:
+	*cnum = "EINVAL";
+		break;
+	case EPERM:
+		*cnum = "EPERM";
+		break;
+	case EIO:
+		*cnum = "EIO";
+		break;
+	case EAGAIN:
+		*cnum = "EAGAIN";
+		break;
+	default:
+		*cnum = "****";
+		break;
+	}
+}
+
+
+/* ------------------ LCD control function --------------------------------- */
+/******************************************************************************
+* MODULE   : change_frame
+* FUNCTION : change LCD display page
+* RETURN   : 0 : success
+* NOTE     : none
+* CREATE   : 2006.05.25 H.Nagashima
+* UPDATE   :
+******************************************************************************/
+int change_frame(void)
+{
+	printk_dbg((_DEBUG_LCDHW & 0x01), "\n");
+
+	writel(LCD_BUSSEL_UPDATE,  LCDCMmioV + LCD_BUSSEL);
+
+	return 0;
+}
+
+
+/******************************************************************************
+* MODULE   : init_lcdhw
+* FUNCTION : LCD(H/W) initialized
+* RETURN   : 0     : success
+*            other : fail
+* NOTE     : none
+* CREATE   : 2006.05.25 H.Nagashima
+* UPDATE   :
+******************************************************************************/
+int init_lcdhw(void)
+{
+	printk_dbg((_DEBUG_LCDHW & 0x01), "\n");
+
+	/* initialize static parameters */
+	imc_param   = NULL;
+	imc_preset  = NULL;
+	imc_vsync   = NULL;
+	imc_reserve = NULL;
+
+	/* LCD Module initialize */
+	if (lcd_module_hw_init()) {
+		printk_err("fail in LCD module initialize\n");
+		return LCD_INIT_ERROR__LCDM_INIT;
+	}
+
+	/* LCDC initialize */
+	lcd_hw_init();
+
+	/* LCDC register initialize */
+	lcd_controller_hw_init();
+
+	/* lcd display size set */
+	lcd_controller_hw_init_lcdsize();
+
+	/* disable LCDC interrupts */
+	lcd_hw_int_factor_clr();
+	lcd_hw_int_disable();
+
+	/* IMC initialize */
+	if (imc_hw_init()) {
+		printk_err("fail in IMC initialize\n");
+		return LCD_INIT_ERROR__IMC_INIT;
+	}
+
+	/* install LCDC irq handler */
+	if (request_irq(INT_LCD, lcd_irq_handler, 0, DEV_NAME, NULL)) {
+		printk_err("fail in request_irq(INT_LCD)\n");
+		return LCD_INIT_ERROR__LCD_IRQ_NOT_REQUEST;
+	}
+	/*  Interuppt Enable Set */
+	writel(LCD_UNDERRUNEN_BIT, LCDCMmioV + LCD_INTENSET);
+
+	/* LCDC start */
+	lcd_hw_start();
+
+	/* LCD Module start */
+	if (lcd_module_hw_start()) {
+		printk_err("fail in LCD module start\n");
+		return LCD_INIT_ERROR__LCDM_START;
+	}
+
+	/* Power & BackLight */
+	lcd_hw_power_on();
+	lcd_hw_backlight_on();
+
+	return 0;
+}
+
+
+/******************************************************************************
+* MODULE   : exit_lcdhw
+* FUNCTION : LCD(H/W) initialized
+* RETURN   : none
+* NOTE     : none
+* CREATE   : 2007.07.05
+* UPDATE   :
+******************************************************************************/
+void exit_lcdhw(void)
+{
+	printk_dbg((_DEBUG_LCDHW & 0x01), "\n");
+
+	lcd_hw_backlight_off();
+	lcd_hw_power_off();
+
+	kfree(imc_param);	/* NULL check is inside */
+}
+
+
+/* ------------------ LCD H/W control function ----------------------------- */
+/********************************************************
+ *  save/restore Function Definitions                   *
+ *******************************************************/
+/******************************************************************************
+* MODULE   : lcd_hw_save_reg
+* FUNCTION : save LCD(H/W) register data
+* RETURN   : 0     : success
+* NOTE     : none
+* CREATE   : 2006.08.17 H.Nagashima
+* UPDATE   :
+******************************************************************************/
+void lcd_hw_save_reg(void)
+{
+	printk_dbg((_DEBUG_LCDHW & 0x01), "\n");
+}
+
+
+/******************************************************************************
+* MODULE   : lcd_hw_restore_reg
+* FUNCTION : restore LCD(H/W) register data
+* RETURN   : 0     : success
+* NOTE     : none
+* CREATE   : 2006.08.17 H.Nagashima
+* UPDATE   :
+******************************************************************************/
+void lcd_hw_restore_reg(void)
+{
+	printk_dbg((_DEBUG_LCDHW & 0x01), "\n");
+
+	/* restore LCD framebuffer address */
+	lcd_controller_hw_init();
+
+	/* init LCD size */
+	lcd_controller_hw_init_lcdsize();
+}
+
+
+/******************************************************************************
+* MODULE   : lcd_hw_start
+* FUNCTION : start LCD(H/W)
+* RETURN   : none
+* NOTE     : none
+* CREATE   : 2006.05.25 H.Nagashima
+* UPDATE   :
+******************************************************************************/
+void lcd_hw_start(void)
+{
+	printk_dbg((_DEBUG_LCDHW & 0x01), "\n");
+	printk_dbg((_DEBUG_LCDHW & 0x40), "<start LCDOUT>\n");
+
+	/* enable auto frequency control */
+	/* unmask LCD (bit0=0) */
+	writel((readl(SMU_DFS_FIFO_REQMASK) & ~(1 << 0)),
+	 SMU_DFS_FIFO_REQMASK);
+	/* OFF control of IMG (bit12=1) */
+	writel((readl(SMU_AUTO_FRQ_MASK0)   |  (1 << 12)), SMU_AUTO_FRQ_MASK0);
+
+	writel(LCD_LCDOUT_ENABLE, LCDCMmioV + LCD_LCDOUT);
+}
+
+
+/******************************************************************************
+* MODULE   : lcd_hw_stop
+* FUNCTION : stop LCD(H/W)
+* RETURN   : 0     : success
+* NOTE     : none
+* CREATE   : 2006.05.25 H.Nagashima
+* UPDATE   :
+******************************************************************************/
+void lcd_hw_stop(void)
+{
+	unsigned long ulRegVal32;
+	int wait_max = 16;
+	int wait_cnt = 0;
+
+	printk_dbg((_DEBUG_LCDHW & 0x01), "\n");
+	printk_dbg((_DEBUG_LCDHW & 0x40), "<stop LCDOUT>\n");
+	writel(LCD_LCDOUT_DISABLE, LCDCMmioV + LCD_LCDOUT);
+
+	/* wait for LCD disp off (max 16ms) */
+	do {
+		ulRegVal32 = lcd_hw_chk_int_rawstatus();
+		if (ulRegVal32 & LCD_LCDSTOPRAW_BIT) {
+			printk_dbg((_DEBUG_LCDHW & 0x01), "wait(%dms)\n",
+			 wait_cnt);
+			wait_cnt = wait_max;
+		} else {
+			if (wait_cnt < wait_max)
+				mdelay(1);
+		}
+		wait_cnt++;
+	} while (wait_cnt <= wait_max);
+
+	/*** disable auto frequency control ***/
+	/* mask LCD (bit0=1) */
+	writel((readl(SMU_DFS_FIFO_REQMASK) |  (1 << 0)), SMU_DFS_FIFO_REQMASK);
+	/* ON control of IMG (bit12=0) */
+	writel((readl(SMU_AUTO_FRQ_MASK0)   & ~(1 << 12)), SMU_AUTO_FRQ_MASK0);
+
+}
+
+
+/******************************************************************************
+* MODULE   : lcd_hw_reset
+* FUNCTION : LCD(H/W) reset
+* RETURN   : none
+* NOTE     : none
+* CREATE   : 2007.11.29 M.Haguro
+* UPDATE   :
+******************************************************************************/
+void lcd_hw_reset(void)
+{
+	printk_dbg((_DEBUG_LCDHW & 0x01), "\n");
+	printk_dbg((_DEBUG_LCDHW & 0x40), "<reset and close clockgate>\n");
+
+	/* Reset LCD */
+	mp200_pmu_clkctrl_off(MP200_CLKCTRL_LCD);
+	mp200_pmu_clkctrl_off(MP200_CLKCTRL_LCDCCK);
+	mp200_pmu_clkctrl_off(MP200_CLKCTRL_LCDPCLK);
+	mp200_pmu_reset_device(MP200_RESETDEVICE_LCD);
+	mp200_pmu_close_clockgate(MP200_CLOCKGATE_LCD_CCLK);
+	mp200_pmu_close_clockgate(MP200_CLOCKGATE_LCD_LCLK);
+	mp200_pmu_close_clockgate(MP200_CLOCKGATE_LCD_PCLK);
+	mp200_pmu_close_clockgate(MP200_CLOCKGATE_LCD_CLK);
+}
+
+
+/******************************************************************************
+* MODULE   : lcd_hw_unreset
+* FUNCTION : LCD(H/W) unreset
+* RETURN   : none
+* NOTE     : none
+* CREATE   : 2007.11.29 M.Haguro
+* UPDATE   :
+******************************************************************************/
+void lcd_hw_unreset(void)
+{
+	printk_dbg((_DEBUG_LCDHW & 0x01), "\n");
+	printk_dbg((_DEBUG_LCDHW & 0x40), "<open clockgate and unreset>\n");
+
+	/* UnReset LCD */
+	mp200_pmu_open_clockgate(MP200_CLOCKGATE_LCD_CCLK);
+	mp200_pmu_open_clockgate(MP200_CLOCKGATE_LCD_LCLK);
+	mp200_pmu_open_clockgate(MP200_CLOCKGATE_LCD_PCLK);
+	mp200_pmu_open_clockgate(MP200_CLOCKGATE_LCD_CLK);
+	mp200_pmu_clkctrl_off(MP200_CLKCTRL_LCD);
+	mp200_pmu_clkctrl_off(MP200_CLKCTRL_LCDCCK);
+	mp200_pmu_clkctrl_off(MP200_CLKCTRL_LCDPCLK);
+	mp200_pmu_unreset_device(MP200_RESETDEVICE_LCD);
+	mp200_pmu_clkctrl_on(MP200_CLKCTRL_LCD);
+	mp200_pmu_clkctrl_on(MP200_CLKCTRL_LCDCCK);
+	mp200_pmu_clkctrl_on(MP200_CLKCTRL_LCDPCLK);
+}
+
+
+/******************************************************************************
+* MODULE   : lcd_hw_power_off
+* FUNCTION : LCD(H/W) power control(off)
+* RETURN   : none
+* NOTE     : none
+* CREATE   : 2007.07.09 M.Haguro
+* UPDATE   :
+******************************************************************************/
+void lcd_hw_power_off(void)
+{
+	/* LCD Module power off */
+	lcd_module_hw_power_off();
+}
+
+
+/******************************************************************************
+* MODULE   : lcd_hw_power_on
+* FUNCTION : LCD(H/W) power control(on)
+* RETURN   : none
+* NOTE     : none
+* CREATE   : 2007.07.09 M.Haguro
+* UPDATE   :
+******************************************************************************/
+void lcd_hw_power_on(void)
+{
+	;
+}
+
+
+
+/******************************************************************************
+* MODULE   : lcd_hw_backlight_off
+* FUNCTION : LCD(H/W) backlight control(off)
+* RETURN   : none
+* NOTE     : none
+* CREATE   : 2007.07.05 M.Haguro
+* UPDATE   :
+******************************************************************************/
+void lcd_hw_backlight_off(void)
+{
+	printk_dbg((_DEBUG_LCDHW & 0x01), "\n");
+	printk_dbg((_DEBUG_LCDHW & 0x40), "<backlight Off>\n");
+#ifdef	CONFIG_MP200_EM1_DKIT
+	/* LED1_EN:OFF LED1_RAMP:OFF LED2_EN:OFF LED2_RAMP:OFF */
+	pwc_write(DA9052_LEDCONT_REG, 0x00, 0x0f);
+	/* BOOST_EN:OFF LED1_IN_EN:OFF LED2_IN_EN:OFF */
+	pwc_write(DA9052_BOOST_REG, 0x00, 0x07);
+#else
+	gpio_direction_output(GPIO_LCD_PD, 0x0); /* GIO_P2 output Low */
+#endif
+}
+
+
+/******************************************************************************
+* MODULE   : lcd_hw_backlight_on
+* FUNCTION : LCD(H/W) backlight control(on)
+* RETURN   : none
+* NOTE     : none
+* CREATE   : 2007.07.05 M.Haguro
+* UPDATE   :
+******************************************************************************/
+void lcd_hw_backlight_on(void)
+{
+	printk_dbg((_DEBUG_LCDHW & 0x01), "\n");
+	printk_dbg((_DEBUG_LCDHW & 0x40), "<backlight On>\n");
+	mdelay(110);
+#ifdef	CONFIG_MP200_EM1_DKIT
+	/* BOOST_EN:ON LED1_IN_EN:ON LED2_IN_EN:ON */
+	pwc_write(DA9052_BOOST_REG, 0x07, 0x07);
+	 /* LED1_EN:ON LED1_RAMP:ON LED2_EN:ON LED2_RAMP:ON */
+	pwc_write(DA9052_LEDCONT_REG, 0x0f, 0x0f);
+#else
+	gpio_direction_output(GPIO_LCD_PD, 0x1); /* GIO_P2 output High */
+#endif
+}
+
+
+/* ------------------ LCDC rgister check function -------------------------- */
+/*****************************************************************************
+* MODULE   : lcd_hw_chk_status
+* FUNCTION : check LCDC status
+* RETURN   :  0 : success
+*            -1 : failed
+* NOTE     : none
+* CREATE   : 2007.11.19 M.Haguro
+* UPDATE   :
+*****************************************************************************/
+unsigned long lcd_hw_chk_status(void)
+{
+	printk_dbg((_DEBUG_LCDHW & 0x01), "\n");
+	/* check lcd status */
+	return (unsigned long)readl(LCDCMmioV + LCD_STATUS);
+}
+
+
+/*****************************************************************************
+* MODULE   : lcd_hw_chk_int_status
+* FUNCTION : check LCDC bussel
+* RETURN   : none
+* NOTE     : none
+* CREATE   : 2008.10.09 M.Haguro
+* UPDATE   :
+******************************************************************************/
+unsigned long lcd_hw_chk_bussel(void)
+{
+	printk_dbg((_DEBUG_LCDHW & 0x01), "\n");
+	/*  check bussel */
+	return (unsigned long)readl(LCDCMmioV + LCD_BUSSEL);
+}
+
+
+/*****************************************************************************
+* MODULE   : lcd_hw_chk_int_status
+* FUNCTION : check LCDC interrupt status
+* RETURN   : none
+* NOTE     : none
+* CREATE   : 2008.10.09 M.Haguro
+* UPDATE   :
+******************************************************************************/
+unsigned long lcd_hw_chk_int_status(void)
+{
+	printk_dbg((_DEBUG_LCDHW & 0x01), "\n");
+	/*  check Interuppt Status */
+	return (unsigned long)readl(LCDCMmioV + LCD_INTSTATUS);
+}
+
+
+/*****************************************************************************
+* MODULE   : lcd_hw_chk_int_rawstatus
+* FUNCTION : check LCDC interrupt RAW status
+* RETURN   : none
+* NOTE     : none
+* CREATE   : 2008.10.09 M.Haguro
+* UPDATE   :
+******************************************************************************/
+unsigned long lcd_hw_chk_int_rawstatus(void)
+{
+	printk_dbg((_DEBUG_LCDHW & 0x01), "\n");
+	/*  check Interuppt RAW Status */
+	return (unsigned long)readl(LCDCMmioV + LCD_INTRAWSTATUS);
+}
+
+
+/* ------------------ LCDC interruput control function --------------------- */
+/*****************************************************************************
+* MODULE   : lcd_hw_int_enable
+* FUNCTION : enable LCDC VSYNC interrupt
+* RETURN   : none
+* NOTE     : none
+* CREATE   : 2006.07.14 Y.Utsuhara
+* UPDATE   :
+******************************************************************************/
+void lcd_hw_int_enable(void)
+{
+	printk_dbg((_DEBUG_LCDHW & 0x01), "\n");
+
+	/*  Interuppt Enable Set */
+	writel(LCD_LCDVSEN_BIT, LCDCMmioV + LCD_INTENSET);
+}
+
+
+/*****************************************************************************
+* MODULE   : lcd_hw_int_disable
+* FUNCTION : disable LCDC interrupts
+* RETURN   : none
+* NOTE     : none
+* CREATE   : 2006.07.14 Y.Utsuhara
+* UPDATE   :
+******************************************************************************/
+void lcd_hw_int_disable(void)
+{
+	printk_dbg((_DEBUG_LCDHW & 0x01), "\n");
+
+	/* Interrupt Enable Clear */
+	writel(LCD_INTENCLR_ALL_BIT, LCDCMmioV + LCD_INTENCLR);
+}
+
+
+/*****************************************************************************
+* MODULE   : lcd_hw_int_factor_clr
+* FUNCTION : disable LCDC interrupts
+* RETURN   : none
+* NOTE     : none
+* CREATE   : 2006.07.14 Y.Utsuhara
+* UPDATE   :
+******************************************************************************/
+void lcd_hw_int_factor_clr(void)
+{
+	printk_dbg((_DEBUG_LCDHW & 0x01), "\n");
+
+	/* Interrupt Status Clear */
+	writel(LCD_INTFFCLR_ALL_BIT, LCDCMmioV + LCD_INTFFCLR);
+}
+
+
+/* ------------------ LCD initialize function ------------------------------ */
+/*****************************************************************************
+* MODULE   : lcd_hw_init
+* FUNCTION : LCD(H/W) initialized
+* RETURN   : none
+* NOTE     : none
+* CREATE   : 2007.06.25 M.Haguro
+* UPDATE   :
+******************************************************************************/
+static void lcd_hw_init(void)
+{
+	printk_dbg((_DEBUG_LCDHW & 0x01), "\n");
+
+	/********************************/
+	/* port / terminal switching    */
+	/********************************/
+	writel((readl(CHG_PINSEL_G48) & ~CHG_PINSEL_G48_LCD_BIT)
+	 | CHG_PINSEL_G48_LCD_INIT, CHG_PINSEL_G48);
+	writel((readl(CHG_PINSEL_G64) & ~CHG_PINSEL_G64_LCD_BIT)
+	 | CHG_PINSEL_G64_LCD_INIT, CHG_PINSEL_G64);
+
+	/********************************/
+	/* clock supply                 */
+	/********************************/
+	/* LCD_CCLK       -> ON */
+	mp200_pmu_open_clockgate(MP200_CLOCKGATE_LCD_CCLK);
+	/* LCD_LCLK       -> ON */
+	mp200_pmu_open_clockgate(MP200_CLOCKGATE_LCD_LCLK);
+	/* LCD_PCLK       -> ON */
+	mp200_pmu_open_clockgate(MP200_CLOCKGATE_LCD_PCLK);
+	/* LCD_CLK        -> ON */
+	mp200_pmu_open_clockgate(MP200_CLOCKGATE_LCD_CLK);
+
+	/********************************/
+	/* clock auto control -> OFF    */
+	/********************************/
+	mp200_pmu_clkctrl_off(MP200_CLKCTRL_LCD);
+	mp200_pmu_clkctrl_off(MP200_CLKCTRL_LCDCCK);
+	mp200_pmu_clkctrl_off(MP200_CLKCTRL_LCDPCLK);
+
+	/********************************/
+	/* LCDC unreset                 */
+	/********************************/
+	mp200_pmu_unreset_device(MP200_RESETDEVICE_LCD);
+
+	/********************************/
+	/* clock auto control -> ON     */
+	/********************************/
+	mp200_pmu_clkctrl_on(MP200_CLKCTRL_LCD);
+	mp200_pmu_clkctrl_on(MP200_CLKCTRL_LCDCCK);
+	mp200_pmu_clkctrl_on(MP200_CLKCTRL_LCDPCLK);
+}
+
+
+/******************************************************************************
+* MODULE   : lcd_controller_hw_init
+* FUNCTION : LCD(H/W) initialized
+* RETURN   : none
+* NOTE     : none
+* CREATE   : 2007.06.25 M.Haguro
+* UPDATE   :
+******************************************************************************/
+static void lcd_controller_hw_init(void)
+{
+	printk_dbg((_DEBUG_LCDHW & 0x01), "\n");
+
+	/* Control for LCDC  */
+	writel(LCD_CONTROL_INIT, LCDCMmioV + LCD_CONTROL);
+	/* QoS for LCDC      */
+	writel(LCD_QOS_INIT,     LCDCMmioV + LCD_QOS);
+	/* Input Format      */
+	writel(LCD_IFORMAT_INIT, LCDCMmioV + LCD_IFORMAT);
+	/* Background color  */
+	writel(LCD_BACKCOL_INIT, LCDCMmioV + LCD_BACKCOLOR);
+	/* Access Bus Select */
+	writel(LCD_BUSSEL_INIT,  LCDCMmioV + LCD_BUSSEL);
+	init_is_first = 0;
+}
+
+
+/******************************************************************************
+* MODULE   : lcd_controller_hw_init_lcdsize
+* FUNCTION : LCD(H/W) size initialize
+* RETURN   : none
+* NOTE     : none
+* CREATE   : 2006.05.25 H.Nagashima
+* UPDATE   :
+******************************************************************************/
+static inline void lcd_controller_hw_init_lcdsize(void)
+{
+	printk_dbg((_DEBUG_LCDHW & 0x01), "\n");
+
+	/* Horizontal Synchronizing Signal Total Width  */
+	writel(LCD_HTOTAL_INIT,  LCDCMmioV + LCD_HTOTAL);
+	/* Horizontal Display Area Width                */
+	writel(LCD_HAREA_INIT,   LCDCMmioV + LCD_HAREA);
+	/* Horizontal Synchronizing Signal Edge Point 1 */
+	writel(LCD_HEDGE1_INIT,  LCDCMmioV + LCD_HEDGE1);
+	/* Horizontal Synchronizing Signal Edge Point 2 */
+	writel(LCD_HEDGE2_INIT,  LCDCMmioV + LCD_HEDGE2);
+	/* Vertical Synchronizing Signal Total Width    */
+	writel(LCD_VTOTAL_INIT,  LCDCMmioV + LCD_VTOTAL);
+	/* Vertical Display Area Width                  */
+	writel(LCD_VAREA_INIT,   LCDCMmioV + LCD_VAREA);
+	/* Vertical Synchronizing Signal Edge Point 1   */
+	writel(LCD_VEDGE1_INIT,  LCDCMmioV + LCD_VEDGE1);
+	/* Vertical Synchronizing Signal Edge Point 2   */
+	writel(LCD_VEDGE2_INIT,  LCDCMmioV + LCD_VEDGE2);
+}
+
+
+/* ------------------ LCD module initialize function ----------------------- */
+/******************************************************************************
+* MODULE   : lcd_module_hw_init
+* FUNCTION : LCD(H/W) initialized
+* RETURN   :    0 : success
+*          : other: failed
+* NOTE     : none
+* CREATE   : 2007.07.10 M.Haguro
+* UPDATE   :
+******************************************************************************/
+static int lcd_module_hw_init(void)
+{
+	int iRet = 0;
+	printk_dbg((_DEBUG_LCDHW & 0x01), "\n");
+
+	/********************************/
+	/* LCD Module unreset           */
+	/********************************/
+	lcd_module_hw_unreset();
+	mdelay(1);
+
+	/********************************/
+	/* LCD Module Initialize        */
+	/********************************/
+	iRet = lcd_module_hw_power_on();
+	if (!iRet)
+		udelay(20);
+
+	return iRet;
+}
+
+
+/*****************************************************************************
+* MODULE   : lcd_module_hw_unreset
+* FUNCTION :
+* RETURN   : none
+* NOTE     : none
+* CREATE   : 2007.06.25 M.Haguro
+* UPDATE   :
+******************************************************************************/
+static void lcd_module_hw_unreset(void)
+{
+	printk_dbg((_DEBUG_LCDHW & 0x01), "\n");
+	gpio_direction_output(GPIO_LCD_RST, 0x1); /* GIO_P3 output High */
+}
+
+
+/*****************************************************************************
+* MODULE   : lcd_module_hw_power_on
+* FUNCTION :
+* RETURN   : none
+* NOTE     : none
+* CREATE   : 2008.10.09 M.Haguro
+* UPDATE   :
+******************************************************************************/
+static int lcd_module_hw_power_on(void)
+{
+	int iRet = 0, i;
+	printk_dbg((_DEBUG_LCDHW & 0x01), "\n");
+
+	for (i = 0; i < LCDM_SPI_CMD_POWERON; i++) {
+		iRet = lcd_module_hw_spiw(lcdm_spi_cmd_poweron[i][0],
+		 lcdm_spi_cmd_poweron[i][1]);
+		if (iRet < 0) {
+			printk_err("LCD Module power on failed!\n");
+			return iRet;
+		}
+	}
+	return iRet;
+}
+
+
+/*****************************************************************************
+* MODULE   : lcd_module_hw_power_off
+* FUNCTION :
+* RETURN   : none
+* NOTE     : none
+* CREATE   : 2008.10.09 M.Haguro
+* UPDATE   :
+******************************************************************************/
+static int lcd_module_hw_power_off(void)
+{
+	int iRet = 0, i;
+	printk_dbg((_DEBUG_LCDHW & 0x01), "\n");
+
+	for (i = 0; i < LCDM_SPI_CMD_POWEROFF; i++) {
+		iRet = lcd_module_hw_spiw(lcdm_spi_cmd_poweroff[i][0],
+		 lcdm_spi_cmd_poweroff[i][1]);
+		if (iRet < 0) {
+			printk_err("LCD Module power off failed!\n");
+			return iRet;
+		}
+	}
+	return iRet;
+}
+
+
+/*****************************************************************************
+* MODULE   : lcd_module_hw_start
+* FUNCTION :
+* RETURN   : none
+* NOTE     : none
+* CREATE   : 2009.3.24 M.Haguro
+* UPDATE   :
+******************************************************************************/
+static int lcd_module_hw_start(void)
+{
+	int iRet = 0, i;
+	printk_dbg((_DEBUG_LCDHW & 0x01), "\n");
+
+	for (i = 0; i < LCDM_SPI_CMD_START; i++) {
+		iRet = lcd_module_hw_spiw(lcdm_spi_cmd_start[i][0],
+		 lcdm_spi_cmd_start[i][1]);
+		if (iRet < 0) {
+			printk_err("LCD Module power on failed!\n");
+			return iRet;
+		}
+	}
+	return iRet;
+}
+
+
+/* ------------------ spi control function --------------------------------- */
+/*****************************************************************************
+* MODULE   : lcd_module_hw_spiw
+* FUNCTION :
+* RETURN   :    0 : success
+*          : other: failed
+* NOTE     : none
+* CREATE   : 2007.06.25 M.Haguro
+* UPDATE   :
+******************************************************************************/
+static int lcd_module_hw_spiw(unsigned char cmd, unsigned char param)
+{
+	char *cRet;
+	int   iRet;
+	SPI_CONFIG spi_conf;
+	unsigned int tx_data =
+		(0 << 24) | (cmd << 16) | (1 << 8) | (param << 0);
+
+	spi_conf.dev    = SPI_DEV_SP0;
+	spi_conf.nbw    = SPI_NB_32BIT;
+	spi_conf.nbr    = 0;
+	spi_conf.cs_sel = SPI_CS_SEL_CS1;
+	spi_conf.m_s    = SPI_M_S_MASTER;
+	spi_conf.dma    = SPI_DMA_OFF;
+	spi_conf.pol    = (SPI_CSW_8CLK | SPI_CK_DLY_ON | SPI_CK_POL_POS
+	 | SPI_CS_POL_NEG); /*SPI_POL_SP0_CS1*/
+	spi_conf.sclk   = SPI_SCLK_3MHZ;
+	spi_conf.tiecs  = SPI_TIECS_NORMAL;
+
+	iRet = spi_write(&spi_conf, (char *)&tx_data, 0, 4, 0);
+	if (iRet < 0) {
+		chk_errno(iRet, &cRet);
+		printk_err("spi_write(%s) error\n", cRet);
+		return iRet;
+	}
+	printk_dbg((_DEBUG_LCDHW & 0x01), "->cmd(0x%02x) ->param(0x%02x)\n",
+	 cmd, param);
+	return 0;
+}
+
+
+
+/* ------------------ IMC initialize function ------------------------------ */
+/*****************************************************************************
+* MODULE   : imc_hw_init
+* FUNCTION : IMC(H/W) initialized
+* RETURN   : 0     : success
+*            other : fail
+* NOTE     : none
+* CREATE   : 2007.06.28 M.Haguro
+* UPDATE   :
+******************************************************************************/
+static int imc_hw_init(void)
+{
+	unsigned long sync, format;
+	int iRet;
+
+	printk_dbg((_DEBUG_LCDHW & 0x01), "\n");
+
+	if (!imc_param) {
+		imc_param = kmalloc(sizeof(struct mp200_imc_param), GFP_KERNEL);
+		if (!imc_param) {
+			printk_err("could not allocate memory "
+				"for \"IMC info\"\n");
+			return -ENOMEM;
+		}
+		memset(imc_param, 0, sizeof(struct mp200_imc_param));
+
+		imc_preset  = &imc_param->imc_preset;
+		imc_vsync   = &imc_param->imc_vsync;
+		imc_reserve = &imc_param->imc_reserve;
+
+		/* set callback function */
+		imc_param->callback_refresh = lcd_callback_imc_refresh;
+		imc_param->callback_wb      = lcd_callback_imc_wb;
+		printk_dbg((_DEBUG_LCDHW & 0x04), "kmalloc()\n");
+	}
+
+	/**********************
+	 * set_callback
+	 **********************/
+	mp200_imc_set_callback(imc_param->callback_refresh,
+	 imc_param->callback_wb);
+	printk_dbg((_DEBUG_LCDHW & 0x04), "set_callback()\n");
+
+	/**********************
+	 * set_preset
+	 **********************/
+	sync   = IMC_START_MODE_SYNCHRO;	/* VSYNC syncro mode */
+#if defined(CONFIG_MP200_LCD_RGB666)
+	format = IMC_FORMAT_RGB666;
+#else
+	format = IMC_FORMAT_RGB565;
+#endif /* CONFIG_MP200_LCD_RGB666 */
+
+	imc_param->imc_control  = (format | sync | IMC_CLKCNT_ALL_ON);
+	imc_preset->imc_control = &imc_param->imc_control;
+	imc_preset->gamma       =
+		imc_hw_init_preset_gamma(&imc_param->param_gamma);
+	imc_preset->wb          = imc_hw_init_preset_wb(&imc_param->param_wb);
+	imc_preset->yuv         =
+		imc_hw_init_preset_yuv(&imc_param->param_yuv);
+	imc_preset->keycolor    =
+		imc_hw_init_preset_keycolor(&imc_param->param_keycolor);
+	imc_preset->bytelane    =
+		imc_hw_init_preset_bytelane(&imc_param->param_bytelane);
+
+	iRet = mp200_imc_set_preset(imc_preset, SET_INIT_ATTR);
+	if (iRet)
+		return -1;
+
+	printk_dbg((_DEBUG_LCDHW & 0x04), "set_preset()\n");
+
+	/**********************
+	 * set_update_vsync
+	 **********************/
+	ImcNxtVsync.cpubufsel = IMC_CPUBUFSEL_INIT;
+	ImcNxtVsync.mirror    = uiInverseFlag_tmp = IMC_MIRROR_OFF;
+	iRet = imc_hw_set_update_vsync(&ImcNxtVsync);
+	if (iRet)
+		return -1;
+
+	printk_dbg((_DEBUG_LCDHW & 0x04), "update_vsync()\n");
+
+	/**********************
+	 * set_update_reserve
+	 **********************/
+	imc_reserve->lo  = imc_hw_init_reserve_l0(&imc_param->param_l0);
+	imc_reserve->l1a = imc_hw_init_reserve_l1a(&imc_param->param_l1a);
+	imc_reserve->l1b = imc_hw_init_reserve_l1b(&imc_param->param_l1b);
+	imc_reserve->l1c = imc_hw_init_reserve_l1c(&imc_param->param_l1c);
+	imc_reserve->l2a = imc_hw_init_reserve_l2a(&imc_param->param_l2a);
+	imc_reserve->l2b = imc_hw_init_reserve_l2b(&imc_param->param_l2b);
+	imc_reserve->bg  = imc_hw_init_reserve_bg(&imc_param->param_bg);
+
+	iRet = mp200_imc_set_update_reserve(imc_reserve,
+	 imc_param->callback_refresh);
+	if (iRet)
+		return -1;
+
+	printk_dbg((_DEBUG_LCDHW & 0x04), "update_reserve()\n");
+
+	return 0;
+}
+
+
+#if defined(CONFIG_PM) || defined(CONFIG_DPM)
+/******************************************************************************
+* MODULE   : imc_hw_restore_reg
+* FUNCTION : restore IMC(H/W) register
+* RETURN   : 0     : success
+*            other : fail
+* NOTE     : none
+* CREATE   : 2007.11.19 M.Haguro
+* UPDATE   :
+******************************************************************************/
+int imc_hw_restore_reg(void)
+{
+	printk_dbg((_DEBUG_LCDHW & 0x01), "\n");
+
+	if (!imc_param) {
+		printk_err("not allocate memory for \"IMC info\"\n");
+		return -ENOMEM;
+	}
+
+	/**********************
+	 * set_preset
+	 **********************/
+	if (mp200_imc_set_preset(imc_preset, SET_INIT_ATTR)) {
+		printk_err("set_preset() failed!\n");
+		return -1;
+	}
+	printk_dbg((_DEBUG_LCDHW & 0x04), "set_preset()\n");
+
+	/**********************
+	 * set_update_vsync
+	 **********************/
+	if (imc_hw_set_update_vsync(&ImcNxtVsync)) {
+		printk_err("set_update_vsync() failed!\n");
+		return -1;
+	}
+	printk_dbg((_DEBUG_LCDHW & 0x04), "set_update_vsync()\n");
+
+	IMC_reset_flg = 0;
+	return 0;
+}
+#endif /* CONFIG_PM || CONFIG_DPM */
+
+
+/*****************************************************************************
+* MODULE   : imc_hw_init_preset_gamma
+* FUNCTION :
+* RETURN   : char *
+* NOTE     : none
+* CREATE   : 2007.06.29 M.Haguro
+* UPDATE   :
+******************************************************************************/
+static void *imc_hw_init_preset_gamma(struct imc_gamma_param *param_gamma)
+{
+	printk_dbg((_DEBUG_LCDHW & 0x01), "\n");
+
+	if (!param_gamma)
+		return NULL;
+	memset(param_gamma, 0, sizeof(struct imc_gamma_param));
+
+	param_gamma->en   = IMC_GAMMAEN_OFF;
+	param_gamma->adr  = IMC_GAMMA_ADR_INIT;
+	param_gamma->data = IMC_GAMMA_DATA_INIT;
+
+	return param_gamma;
+}
+
+
+/*****************************************************************************
+* MODULE   : imc_hw_init_preset_wb
+* FUNCTION :
+* RETURN   : char *
+* NOTE     : none
+* CREATE   : 2007.06.29 M.Haguro
+* UPDATE   :
+******************************************************************************/
+static void *imc_hw_init_preset_wb(struct imc_wb_param *param_wb)
+{
+	printk_dbg((_DEBUG_LCDHW & 0x01), "\n");
+
+	if (!param_wb)
+		return NULL;
+	memset(param_wb, 0, sizeof(struct imc_wb_param));
+
+#if defined(CONFIG_MP200_LCD_RGB666)
+	param_wb->format  = IMC_WB_FORMAT_RGB666;
+#else
+	param_wb->format  = IMC_WB_FORMAT_RGB565;
+#endif /* CONFIG_MP200_LCD_RGB666 */
+	param_wb->areaadr = LCD_AREAADR_INIT;
+	param_wb->hsize   = FRONT_WIDTH;
+	param_wb->vsize   = FRONT_HEIGHT;
+	param_wb->hoffset = param_wb->hsize * BITS_PER_PIXEL / 8;
+
+	return param_wb;
+}
+
+
+/*****************************************************************************
+* MODULE   : imc_hw_init_preset_yuv
+* FUNCTION :
+* RETURN   : char *
+* NOTE     : none
+* CREATE   : 2007.06.29 M.Haguro
+* UPDATE   :
+******************************************************************************/
+static void *imc_hw_init_preset_yuv(struct imc_yuv_param *param_yuv)
+{
+	printk_dbg((_DEBUG_LCDHW & 0x01), "\n");
+
+	if (!param_yuv)
+		return NULL;
+	memset(param_yuv, 0, sizeof(struct imc_yuv_param));
+
+	param_yuv->ygain   = IMC_YGAIN_OFFSET_INIT;
+	param_yuv->ugain   = IMC_UGAIN_OFFSET_INIT;
+	param_yuv->vgain   = IMC_VGAIN_OFFSET_INIT;
+	param_yuv->yuv2rgb = (IMC_DITHER_OFF | IMC_TRANS_MODE_BT601);
+	if (param_yuv->yuv2rgb == IMC_TRANS_MODE_CUSTOM1 ||
+	   param_yuv->yuv2rgb == IMC_TRANS_MODE_CUSTOM2) {
+		param_yuv->coef_r[0] = IMC_COEF_R0_INIT;
+		param_yuv->coef_r[1] = IMC_COEF_R1_INIT;
+		param_yuv->coef_r[2] = IMC_COEF_R2_INIT;
+		param_yuv->coef_r[3] = IMC_COEF_R3_INIT;
+		param_yuv->coef_g[0] = IMC_COEF_G0_INIT;
+		param_yuv->coef_g[1] = IMC_COEF_G1_INIT;
+		param_yuv->coef_g[2] = IMC_COEF_G2_INIT;
+		param_yuv->coef_g[3] = IMC_COEF_G3_INIT;
+		param_yuv->coef_b[0] = IMC_COEF_B0_INIT;
+		param_yuv->coef_b[1] = IMC_COEF_B1_INIT;
+		param_yuv->coef_b[2] = IMC_COEF_B2_INIT;
+		param_yuv->coef_b[3] = IMC_COEF_B3_INIT;
+	}
+
+	return param_yuv;
+}
+
+
+/*****************************************************************************
+* MODULE   : imc_hw_init_preset_keycolor
+* FUNCTION :
+* RETURN   : char *
+* NOTE     : none
+* CREATE   : 2007.12.17 M.Haguro
+* UPDATE   :
+******************************************************************************/
+static void *
+imc_hw_init_preset_keycolor(struct imc_keycolor_param *param_keycolor)
+{
+	printk_dbg((_DEBUG_LCDHW & 0x01), "\n");
+
+	if (!param_keycolor)
+		return NULL;
+	memset(param_keycolor, 0, sizeof(struct imc_keycolor_param));
+
+	param_keycolor->l0_keycolor  = IMC_L0_KEYCOLOR_INIT;
+	param_keycolor->l1x_keycolor = IMC_L1x_KEYCOLOR_INIT;
+
+	ImcNxtKeycol.l0_keycolor  = param_keycolor->l0_keycolor;
+	ImcNxtKeycol.l1x_keycolor = param_keycolor->l1x_keycolor;
+
+	return param_keycolor;
+}
+
+
+/*****************************************************************************
+* MODULE   : imc_hw_init_preset_bytelane
+* FUNCTION :
+* RETURN   : char *
+* NOTE     : none
+* CREATE   : 2007.12.17 M.Haguro
+* UPDATE   :
+******************************************************************************/
+static void *
+imc_hw_init_preset_bytelane(struct imc_bytelane_param *param_bytelane)
+{
+	printk_dbg((_DEBUG_LCDHW & 0x01), "\n");
+
+	if (!param_bytelane)
+		return NULL;
+	memset(param_bytelane, 0, sizeof(struct imc_bytelane_param));
+
+	param_bytelane->l2a_bytelane = IMC_L2A_BYTELANE_INIT;
+	param_bytelane->l2b_bytelane = IMC_L2B_BYTELANE_INIT;
+
+	return param_bytelane;
+}
+
+
+/*****************************************************************************
+* MODULE   : imc_hw_init_reserve_l0
+* FUNCTION :
+* RETURN   : char *
+* NOTE     : none
+* CREATE   : 2007.06.29 M.Haguro
+* UPDATE   :
+******************************************************************************/
+static void *imc_hw_init_reserve_l0(struct l01_param *param_l0)
+{
+	printk_dbg((_DEBUG_LCDHW & 0x01), "\n");
+
+	if (!param_l0)
+		return NULL;
+	memset(param_l0, 0, sizeof(struct l01_param));
+
+	param_l0->control   = IMC_L0_CONTROL_INIT;
+	param_l0->format    = IMC_L0_FORMAT_INIT;
+	param_l0->keyenable = IMC_L0_KEYENABLE_INIT;
+	param_l0->alpha     = IMC_L0_ALPHA_INIT;
+	param_l0->resize    = IMC_L0_RESIZE_INIT;
+	param_l0->offset    = IMC_L0_OFFSET_INIT;
+	param_l0->frameadr  = IMC_L0_FRAMEADR_INIT;
+	param_l0->position  = IMC_L0_POSITION_INIT;
+	param_l0->size      = IMC_L0_SIZE_INIT;
+
+	return param_l0;
+}
+
+
+/*****************************************************************************
+* MODULE   : imc_hw_init_reserve_l1a
+* FUNCTION :
+* RETURN   : char *
+* NOTE     : none
+* CREATE   : 2007.06.29 M.Haguro
+* UPDATE   :
+******************************************************************************/
+static void *imc_hw_init_reserve_l1a(struct l01_param *param_l1a)
+{
+	printk_dbg((_DEBUG_LCDHW & 0x01), "\n");
+
+	if (!param_l1a)
+		return NULL;
+	memset(param_l1a, 0, sizeof(struct l01_param));
+
+	/* Layer1x public setting */
+#if defined(CONFIG_MP200_LCD_RGB666)
+	param_l1a->format    = IMC_Lx_FORMAT_RGB666;
+#else
+	param_l1a->format    = IMC_Lx_FORMAT_RGB565;
+#endif /* CONFIG_MP200_LCD_RGB666 */
+	param_l1a->resize    = IMC_Lx_RESIZE_DISABLE;
+	param_l1a->offset    = FRONT_WIDTH * BITS_PER_PIXEL / 8;
+
+	/* Layer1A private setting */
+	param_l1a->control   = IMC_L1A_CONTROL_INIT;
+	param_l1a->keyenable = IMC_L1A_KEYENABLE_INIT;
+	param_l1a->alpha     = IMC_L1A_ALPHA_INIT;
+	param_l1a->frameadr  = IMC_L1A_FRAMEADR_INIT;
+	param_l1a->position  = IMC_L1A_POSITION_INIT;
+	param_l1a->size      = IMC_L1A_SIZE_INIT;
+
+	return param_l1a;
+}
+
+
+/*****************************************************************************
+* MODULE   : imc_hw_init_reserve_l1b
+* FUNCTION :
+* RETURN   : char *
+* NOTE     : none
+* CREATE   : 2007.06.29 M.Haguro
+* UPDATE   :
+******************************************************************************/
+static void *imc_hw_init_reserve_l1b(struct l01_param *param_l1b)
+{
+	printk_dbg((_DEBUG_LCDHW & 0x01), "\n");
+
+	if (!param_l1b)
+		return NULL;
+	memset(param_l1b, 0, sizeof(struct l01_param));
+
+	param_l1b->control   = IMC_L1B_CONTROL_INIT;
+	param_l1b->keyenable = IMC_L1B_KEYENABLE_INIT;
+	param_l1b->alpha     = IMC_L1B_ALPHA_INIT;
+	param_l1b->frameadr  = IMC_L1B_FRAMEADR_INIT;
+	param_l1b->position  = IMC_L1B_POSITION_INIT;
+	param_l1b->size      = IMC_L1B_SIZE_INIT;
+
+	return param_l1b;
+}
+
+
+/*****************************************************************************
+* MODULE   : imc_hw_init_reserve_l1c
+* FUNCTION :
+* RETURN   : char *
+* NOTE     : none
+* CREATE   : 2007.06.29 M.Haguro
+* UPDATE   :
+******************************************************************************/
+static void *imc_hw_init_reserve_l1c(struct l01_param *param_l1c)
+{
+	printk_dbg((_DEBUG_LCDHW & 0x01), "\n");
+
+	if (!param_l1c)
+		return NULL;
+	memset(param_l1c, 0, sizeof(struct l01_param));
+
+	param_l1c->control   = IMC_L1C_CONTROL_INIT;
+	param_l1c->keyenable = IMC_L1C_KEYENABLE_INIT;
+	param_l1c->alpha     = IMC_L1C_ALPHA_INIT;
+	param_l1c->frameadr  = IMC_L1C_FRAMEADR_INIT;
+	param_l1c->position  = IMC_L1C_POSITION_INIT;
+	param_l1c->size      = IMC_L1C_SIZE_INIT;
+
+	return param_l1c;
+}
+
+
+/*****************************************************************************
+* MODULE   : imc_hw_init_reserve_l2a
+* FUNCTION :
+* RETURN   : char *
+* NOTE     : none
+* CREATE   : 2007.07.02 M.Haguro
+* UPDATE   :
+******************************************************************************/
+static void *imc_hw_init_reserve_l2a(struct l2_param *param_l2a)
+{
+	printk_dbg((_DEBUG_LCDHW & 0x01), "\n");
+
+	if (!param_l2a)
+		return NULL;
+	memset(param_l2a, 0, sizeof(struct l2_param));
+
+	param_l2a->control     = IMC_L2A_CONTROL_INIT;
+	param_l2a->format      = IMC_L2A_FORMAT_INIT;
+	param_l2a->bufsel      = IMC_L2A_BUFSEL_INIT;
+	param_l2a->resize      = IMC_L2A_RESIZE_INIT;
+	param_l2a->mirror      = IMC_L2A_MIRROR_INIT;
+	param_l2a->offset      = IMC_L2A_OFFSET_INIT;
+	param_l2a->frameadr_yp = IMC_L2A_FRAMEADR_YP_INIT;
+	param_l2a->frameadr_up = IMC_L2A_FRAMEADR_UP_INIT;
+	param_l2a->frameadr_yq = IMC_L2A_FRAMEADR_YQ_INIT;
+	param_l2a->frameadr_uq = IMC_L2A_FRAMEADR_UQ_INIT;
+	param_l2a->position    = IMC_L2A_POSITION_INIT;
+	param_l2a->size        = IMC_L2A_SIZE_INIT;
+
+	return param_l2a;
+}
+
+
+/*****************************************************************************
+* MODULE   : imc_hw_init_reserve_l2b
+* FUNCTION :
+* RETURN   : char *
+* NOTE     : none
+* CREATE   : 2007.07.02 M.Haguro
+* UPDATE   :
+******************************************************************************/
+static void *imc_hw_init_reserve_l2b(struct l2_param *param_l2b)
+{
+	printk_dbg((_DEBUG_LCDHW & 0x01), "\n");
+
+	if (!param_l2b)
+		return NULL;
+	memset(param_l2b, 0, sizeof(struct l2_param));
+
+	param_l2b->control     = IMC_L2B_CONTROL_INIT;
+	param_l2b->format      = IMC_L2B_FORMAT_INIT;
+	param_l2b->bufsel      = IMC_L2B_BUFSEL_INIT;
+	param_l2b->resize      = IMC_L2B_RESIZE_INIT;
+	param_l2b->mirror      = IMC_L2B_MIRROR_INIT;
+	param_l2b->offset      = IMC_L2B_OFFSET_INIT;
+	param_l2b->frameadr_yp = IMC_L2B_FRAMEADR_YP_INIT;
+	param_l2b->frameadr_up = IMC_L2B_FRAMEADR_UP_INIT;
+	param_l2b->frameadr_yq = IMC_L2B_FRAMEADR_YQ_INIT;
+	param_l2b->frameadr_uq = IMC_L2B_FRAMEADR_UQ_INIT;
+	param_l2b->position    = IMC_L2B_POSITION_INIT;
+	param_l2b->size        = IMC_L2B_SIZE_INIT;
+
+	return param_l2b;
+}
+
+
+/*****************************************************************************
+* MODULE   : imc_hw_init_reserve_bg
+* FUNCTION :
+* RETURN   : char *
+* NOTE     : none
+* CREATE   : 2007.07.02 M.Haguro
+* UPDATE   :
+******************************************************************************/
+static void *imc_hw_init_reserve_bg(struct bg_param *param_bg)
+{
+	printk_dbg((_DEBUG_LCDHW & 0x01), "\n");
+
+	if (!param_bg)
+		return NULL;
+	memset(param_bg, 0, sizeof(struct bg_param));
+
+	param_bg->format   = IMC_LBG_FORMAT_OPTIONAL;
+	param_bg->resize   = IMC_Lx_RESIZE_DISABLE;
+	param_bg->offset   = FRONT_WIDTH * BITS_PER_PIXEL / 8;
+	param_bg->frameadr = 0;
+
+	return param_bg;
+}
+
+
+/*****************************************************************************
+* MODULE   : imc_hw_set_update_vsync
+* FUNCTION :
+* RETURN   :  0: success
+*          : -1: failed
+* NOTE     : none
+* CREATE   : 2007.08.01 M.Haguro
+* UPDATE   :
+******************************************************************************/
+int imc_hw_set_update_vsync(struct mp200_imc_update_vsync *vsync)
+{
+	static int chg_flg = 1;
+	printk_dbg((_DEBUG_LCDHW & 0x01), "in\n");
+
+	if (imc_vsync->cpubufsel != vsync->cpubufsel)
+		chg_flg = 1;
+
+	if (imc_vsync->mirror == IMC_MIRROR_OFF
+	 && vsync->mirror != NO_INVERSE) {
+		vsync->mirror = (IMC_MIRROR_UD | IMC_MIRROR_LR);
+		chg_flg = 1;
+	} else if (imc_vsync->mirror != IMC_MIRROR_OFF
+	 && vsync->mirror == NO_INVERSE) {
+		vsync->mirror = IMC_MIRROR_OFF;
+		chg_flg = 1;
+	}
+
+	if (chg_flg) {
+		chg_flg = 0;
+		if (mp200_imc_set_update_vsync(vsync)) {
+			printk_dbg((_DEBUG_LCDHW & 0x04),
+			 "mp200_imc_set_update_vsync() failed\n");
+			return -1;
+		}
+		printk_dbg((_DEBUG_LCDHW & 0x04),
+		 "mp200_imc_set_update_vsync() success\n");
+		imc_vsync->cpubufsel = vsync->cpubufsel;
+		imc_vsync->mirror    = vsync->mirror;
+	}
+
+	printk_dbg((_DEBUG_LCDHW & 0x02), "out\n");
+	return 0;
+}
+
+
+/*****************************************************************************
+* MODULE   : imc_hw_set_update_keycolor
+* FUNCTION :
+* RETURN   :  0: success
+*          : -1: failed
+* NOTE     : none
+* CREATE   : 2007.12.17 M.Haguro
+* UPDATE   :
+******************************************************************************/
+int imc_hw_set_update_keycolor(struct imc_keycolor_param *keycolor)
+{
+	int chg_flg = 0;
+	struct mp200_imc_preset   preset;
+	struct imc_keycolor_param save_keycol;
+	printk_dbg((_DEBUG_LCDHW & 0x01), "in\n");
+
+	memset(&preset, 0, sizeof(struct mp200_imc_preset));
+	preset.keycolor = &imc_param->param_keycolor;
+	memcpy(&save_keycol, preset.keycolor,
+	 sizeof(struct imc_keycolor_param));
+
+	if (preset.keycolor->l0_keycolor != keycolor->l0_keycolor) {
+		/* change Layer0 colorkey */
+		preset.keycolor->l0_keycolor = keycolor->l0_keycolor;
+		printk_dbg((_DEBUG_LCDHW & 0x02), "l0_keycolor(%06lx)\n",
+		 keycolor->l0_keycolor);
+		chg_flg = 1;
+	}
+	if (preset.keycolor->l1x_keycolor != keycolor->l1x_keycolor) {
+		/* change Layer1 colorkey */
+		preset.keycolor->l1x_keycolor = keycolor->l1x_keycolor;
+		printk_dbg((_DEBUG_LCDHW & 0x02), "l1x_keycolor(%06lx)\n",
+		 keycolor->l1x_keycolor);
+		chg_flg = 1;
+	}
+
+	if (chg_flg) {
+		if (mp200_imc_set_preset(&preset, SET_INIT_ATTR)) {
+			printk_dbg((_DEBUG_LCDHW & 0x04),
+			 "mp200_imc_set_prest() failed\n");
+			memcpy(preset.keycolor, &save_keycol,
+			 sizeof(struct imc_keycolor_param));
+			return -1;
+		}
+		printk_dbg((_DEBUG_LCDHW & 0x04),
+		 "mp200_imc_set_prest() success\n");
+		/* save state */
+		imc_preset->keycolor->l0_keycolor  = keycolor->l0_keycolor;
+		/* save state */
+		imc_preset->keycolor->l1x_keycolor = keycolor->l1x_keycolor;
+	}
+
+	printk_dbg((_DEBUG_LCDHW & 0x02), "out\n");
+	return 0;
+}
+
+
+/*****************************************************************************
+* MODULE   : imc_hw_set_update_bytelane
+* FUNCTION :
+* RETURN   :  0: success
+*          : -1: failed
+* NOTE     : none
+* CREATE   : 2008.10.24 M.Haguro
+* UPDATE   :
+******************************************************************************/
+int imc_hw_set_update_bytelane(struct imc_bytelane_param *bytelane)
+{
+	int chg_flg = 0;
+	struct mp200_imc_preset   preset;
+	struct imc_bytelane_param save_bytelane;
+	printk_dbg((_DEBUG_LCDHW & 0x01), "in\n");
+
+	memset(&preset, 0, sizeof(struct mp200_imc_preset));
+	preset.bytelane = &imc_param->param_bytelane;
+	memcpy(&save_bytelane, preset.bytelane,
+	 sizeof(struct imc_bytelane_param));
+
+	if (preset.bytelane->l2a_bytelane != bytelane->l2a_bytelane) {
+		/* change Layer2a bytealne */
+		preset.bytelane->l2a_bytelane = bytelane->l2a_bytelane;
+		printk_dbg((_DEBUG_LCDHW & 0x02), "l2a_bytelane(%04lx)\n",
+		 bytelane->l2a_bytelane);
+		chg_flg = 1;
+	}
+	if (preset.bytelane->l2b_bytelane != bytelane->l2b_bytelane) {
+		/* change Layer2b bytealne */
+		preset.bytelane->l2b_bytelane = bytelane->l2b_bytelane;
+		printk_dbg((_DEBUG_LCDHW & 0x02), "l2b_bytelane(%04lx)\n",
+		 bytelane->l2b_bytelane);
+		chg_flg = 1;
+	}
+
+	if (chg_flg) {
+		if (mp200_imc_set_preset(&preset, SET_INIT_ATTR)) {
+			printk_dbg((_DEBUG_LCDHW & 0x04),
+			 "mp200_imc_set_prest() failed\n");
+			memcpy(preset.bytelane, &save_bytelane,
+			 sizeof(struct imc_bytelane_param));
+			return -1;
+		}
+		printk_dbg((_DEBUG_LCDHW & 0x04),
+		 "mp200_imc_set_prest() success\n");
+		/* save state */
+		imc_preset->bytelane->l2a_bytelane = bytelane->l2a_bytelane;
+		/* save state */
+		imc_preset->bytelane->l2b_bytelane = bytelane->l2b_bytelane;
+	}
+
+	printk_dbg((_DEBUG_LCDHW & 0x02), "out\n");
+	return 0;
+}
+
+
+/*****************************************************************************
+* MODULE   : imc_hw_set_update_reserve
+* FUNCTION :
+* RETURN   :  0: success
+*          : -1: failed
+* NOTE     : none
+* CREATE   : 2007.07.27 M.Haguro
+* UPDATE   :
+******************************************************************************/
+int imc_hw_set_update_reserve(int type, int mixdsp, int update)
+{
+	static struct l01_param tmp_fb_layer;
+	int iRet;
+	printk_dbg((_DEBUG_LCDHW & 0x01), "in\n");
+
+	/**********************
+	 * set_update_reserve
+	 **********************/
+	if (type == SET_LAYER_2D) {
+		memcpy(&tmp_fb_layer, &fb_layer, sizeof(struct l01_param));
+		if (mixdsp != MIX_DSP_ON)
+			tmp_fb_layer.keyenable = IMC_Lx_KEYEN_DISABLE;
+
+		/* set 2D(DispBuffer) layer */
+		printk_dbg((_DEBUG_LCDHW & 0x04), "   set2D\n");
+		imc_reserve->l1a = &tmp_fb_layer;
+	} else if (type == SET_LAYER_V4L2) {
+		/* set v4l2 layer */
+		printk_dbg((_DEBUG_LCDHW & 0x04), "   setV4L2\n");
+		imc_reserve->l1a = &fb_layer;
+		imc_reserve->l2b = &v4l2_layer;
+	} else if (type == CLR_LAYER_V4L2) {
+		memcpy(&tmp_fb_layer, &fb_layer, sizeof(struct l01_param));
+		if (mixdsp != MIX_DSP_ON)
+			tmp_fb_layer.keyenable = IMC_Lx_KEYEN_DISABLE;
+
+		/* clr v4l2 layer */
+		printk_dbg((_DEBUG_LCDHW & 0x04), "   clrV4L2\n");
+		imc_reserve->l1a = &tmp_fb_layer;
+		imc_reserve->l2b =
+			imc_hw_init_reserve_l2b(&imc_param->param_l2b);
+	} else {
+		printk_dbg((_DEBUG_LCDHW & 0x04), "   set----\n");
+		return -1;
+	}
+
+	if (update ==  UPDATE_ON) {
+		iRet = mp200_imc_set_update_reserve(imc_reserve,
+		 imc_param->callback_refresh);
+		if (iRet)
+			return -1;
+	}
+	printk_dbg((_DEBUG_LCDHW & 0x02), "out\n");
+
+	return 0;
+}
+
+
+
diff --git a/drivers/video/mp200/mp200_lcdhw.h b/drivers/video/mp200/mp200_lcdhw.h
new file mode 100644
index 0000000..7f6b384
--- /dev/null
+++ b/drivers/video/mp200/mp200_lcdhw.h
@@ -0,0 +1,88 @@
+/*
+ * File Name       : /drivers/video/mp200/mp200_lcdhw.h
+ * Function        : LCD Driver corresponding to V4L2 (H/W Control)
+ * Release Version :
+ * Release Date    : 2009.10.21
+ *
+ * Copyright (C) NEC Electronics Corporation 2009
+ *
+ *
+ * This program is free software;you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by Free Softwere
+ * Foundation; either version 2 of License, or (at your option) any later
+ * version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warrnty of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
+ * details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; If not, write to the Free Software Foundation, Inc., 59 Temple
+ * Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+
+#ifndef _MP200_LCDHW_H_
+#define _MP200_LCDHW_H_
+
+
+
+/********************************************************
+ *  Variables                                           *
+ *******************************************************/
+extern int init_is_first;
+
+/* IMC layer */
+extern struct l01_param			fb_layer;
+extern struct l2_param			v4l2_layer;
+extern struct mp200_imc_update_vsync	ImcNxtVsync;
+extern struct imc_keycolor_param	ImcNxtKeycol;
+extern struct imc_bytelane_param	ImcNxtBytelane;
+
+
+/********************************************************
+ *  Prototype declarations of function                  *
+ *******************************************************/
+/* ------------------ LCD control function --------------------------------- */
+extern int           change_frame(void);
+extern int           init_lcdhw(void);
+extern void          exit_lcdhw(void);
+
+/* ------------------ LCD H/W control function ----------------------------- */
+extern void          lcd_hw_save_reg(void);
+extern void          lcd_hw_restore_reg(void);
+extern void          lcd_hw_start(void);
+extern void          lcd_hw_stop(void);
+extern void          lcd_hw_reset(void);
+extern void          lcd_hw_unreset(void);
+extern void          lcd_hw_power_off(void);
+extern void          lcd_hw_power_on(void);
+extern void          lcd_hw_backlight_off(void);
+extern void          lcd_hw_backlight_on(void);
+
+/* ------------------ LCDC rgister check function ------------------------- */
+extern unsigned long lcd_hw_chk_status(void);
+extern unsigned long lcd_hw_chk_bussel(void);
+extern unsigned long lcd_hw_chk_int_status(void);
+extern unsigned long lcd_hw_chk_int_rawstatus(void);
+
+/* ------------------ LCDC interruput control function --------------------- */
+extern void          lcd_hw_int_enable(void);
+extern void          lcd_hw_int_disable(void);
+extern void          lcd_hw_int_factor_clr(void);
+
+/* ------------------ IMC initialize function ------------------------------ */
+extern int           imc_hw_restore_reg(void);
+
+/* ------------------ IMC control function --------------------------------- */
+extern int imc_hw_set_update_vsync(struct mp200_imc_update_vsync *vsync);
+extern int imc_hw_set_update_keycolor(struct imc_keycolor_param *keycolor);
+extern int imc_hw_set_update_bytelane(struct imc_bytelane_param *bytelane);
+extern int imc_hw_set_update_reserve(int type, int mixdsp, int update);
+
+
+
+#endif /* _MP200_LCDHW_H_ */
+
diff --git a/drivers/video/mp200/nts/Kconfig b/drivers/video/mp200/nts/Kconfig
new file mode 100644
index 0000000..bd5d3f6
--- /dev/null
+++ b/drivers/video/mp200/nts/Kconfig
@@ -0,0 +1,31 @@
+#
+# NTS driver configuration
+#
+
+menu "MP200 Video-out support"
+        depends on FB_MP200
+
+config MP200_NTS
+	bool "MP200 NTSC Video-out support"
+        depends on VIDEO_MP200
+	default y
+        help
+          This is the TV out subsystem for MP200 seriase boards.
+
+choice
+	prompt "Video-Encoder option"
+        depends on MP200_NTS
+	default MP200_NTS_PAL
+
+config MP200_NTS_PAL
+	bool "PAL B/D/G/H/I/N"
+        help
+          Selected this configuration is support PAL B/D/G/H/I/N.
+
+config MP200_NTS_PAL60
+	bool "PAL-60"
+        help
+          Selected this configuration is support PAL-60.
+endchoice
+
+endmenu
diff --git a/drivers/video/mp200/nts/Makefile b/drivers/video/mp200/nts/Makefile
new file mode 100644
index 0000000..7354089
--- /dev/null
+++ b/drivers/video/mp200/nts/Makefile
@@ -0,0 +1,11 @@
+#
+# Makefile for the EM1 NTSC framebuffer device driver
+#
+
+obj-$(CONFIG_MP200_NTS) += mp200_nts.o
+obj-$(CONFIG_MP200_NTS) += mp200_ntshw.o
+obj-$(CONFIG_MP200_NTS) += mp200_ntsipu.o
+obj-$(CONFIG_MP200_NTS) += mp200_adv7179.o
+
+mp200fb-objs := mp200_fblcd.o
+
diff --git a/drivers/video/mp200/nts/adv7179.h b/drivers/video/mp200/nts/adv7179.h
new file mode 100644
index 0000000..16f1273
--- /dev/null
+++ b/drivers/video/mp200/nts/adv7179.h
@@ -0,0 +1,295 @@
+/*
+ * File Name       : /drivers/video/mp200/nts/ADV7179.h
+ * Function        : ADV7179 definitions
+ * Release Version : Ver 1.00
+ * Release Date    : 2008/11/28
+ *
+ * Copyright (C) NEC Electronics Corporation 2007
+ *
+ *
+ * This program is free software;you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by Free Softwere
+ * Foundation; either version 2 of License, or (at your option) any later
+ * version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warrnty of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
+ * details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; If not, write to the Free Software Foundation, Inc., 59 Temple
+ * Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#ifndef _ADV7179_H_
+#define _ADV7179_H_
+
+
+/*****************************************************************************
+ * ADV7179 definitions
+ *****************************************************************************/
+
+/*                                                           R/W   Bit  Reset */
+/*----------------------------------------------------------------------------
+ * Function Settings Register
+ */
+/* Mode Register 0                                           R/W   7:0  0x00 */
+#define ADV7179_MODE0				(0x00)
+
+/* Mode Register 1                                           R/W   7:0  0x10 */
+#define ADV7179_MODE1				(0x01)
+
+/* Mode Register 2                                           R/W   7:0  0x00 */
+#define ADV7179_MODE2				(0x02)
+
+/* Mode Register 3                                           R/W   7:0  0x00 */
+#define ADV7179_MODE3				(0x03)
+
+/* Mode Register 4                                           R/W   7:0  0x10 */
+#define ADV7179_MODE4				(0x04)
+
+/* Timing Register 0                                         R/W   7:0  0x00 */
+#define ADV7179_TIMING0				(0x07)
+
+/* Timing Register 1                                         R/W   7:0  0x00 */
+#define ADV7179_TIMING1				(0x08)
+
+/* Subcareer frequency Register 0                            R/W   7:0  0x16 */
+#define ADV7179_SUBCAREER_FREQUENCY0		(0x09)
+
+/* Subcareer frequency Register 1                            R/W   7:0  0x7C */
+#define ADV7179_SUBCAREER_FREQUENCY1		(0x0A)
+
+/* Subcareer frequency Register 2                            R/W   7:0  0xF0 */
+#define ADV7179_SUBCAREER_FREQUENCY2		(0x0B)
+
+/* Subcareer frequency Register 3                            R/W   7:0  0x21 */
+#define ADV7179_SUBCAREER_FREQUENCY3		(0x0C)
+
+/* Subcareer phase Register                                  R/W   7:0  0x00 */
+#define ADV7179_SUBCAREER_PHASE			(0x0D)
+
+/* Closed capshoning ext Register 0                          R/W   7:0  0x00 */
+#define ADV7179_CLOSED_CAPSHONING_EXT0		(0x0E)
+
+/* Closed capshoning ext Register 1                          R/W   7:0  0x00 */
+#define ADV7179_CLOSED_CAPSHONING_EXT1		(0x0F)
+
+/* Closed capshoning Register 0                              R/W   7:0  0x00 */
+#define ADV7179_CLOSED_CAPSHONING0		(0x10)
+
+/* Closed capshoning Register 1                              R/W   7:0  0x00 */
+#define ADV7179_CLOSED_CAPSHONING1		(0x11)
+
+/* Pedestal control Register 0                               R/W   7:0  0x00 */
+#define ADV7179_PEDESTAL_CONTROL0		(0x12)
+
+/* Pedestal control Register 1                               R/W   7:0  0x00 */
+#define ADV7179_PEDESTAL_CONTROL1		(0x13)
+
+/* Pedestal control Register 2                               R/W   7:0  0x00 */
+#define ADV7179_PEDESTAL_CONTROL2		(0x14)
+
+/* Pedestal control Register 3                               R/W   7:0  0x00 */
+#define ADV7179_PEDESTAL_CONTROL3		(0x15)
+
+/* CGMS WSS Register 0                                       R/W   7:0  0x00 */
+#define ADV7179_CGMS_WSS0			(0x16)
+
+/* CGMS WSS Register 1                                       R/W   7:0  0x00 */
+#define ADV7179_CGMS_WSS1			(0x17)
+
+/* CGMS WSS Register 2                                       R/W   7:0  0x00 */
+#define ADV7179_CGMS_WSS2			(0x18)
+
+/* Teletext request control Register                         R/W   7:0  0x00 */
+#define ADV7179_TELETEXT_REQUEST_CONTROL	(0x19)
+
+#define ADV7179_REG_MAX				ADV7179_TELETEXT_REQUEST_CONTROL
+
+
+
+
+
+
+/*----------------------------------------------------------------------------
+ * Function Settings Register
+ */
+/*------------------------------*/
+/* ADV7179_MODE0                */
+/*------------------------------*/
+#define MODE0_CHROMA_FILTER_SELECT_BIT			0xE0
+#define MODE0_CHROMA_FILTER_SELECT_SFT			0x05
+#define MODE0_CHROMA_FILTER_SELECT_1_3MHZ_LOWPASS	0x00
+#define MODE0_CHROMA_FILTER_SELECT_0_65MHZ_LOWPASS	0x20
+#define MODE0_CHROMA_FILTER_SELECT_1_0MHZ_LOWPASS	0x40
+#define MODE0_CHROMA_FILTER_SELECT_2_0MHZ_LOWPASS	0x60
+#define MODE0_CHROMA_FILTER_SELECT_CIF			0xA0
+#define MODE0_CHROMA_FILTER_SELECT_QCIF			0xC0
+
+#define MODE0_LUMA_FILTER_SELECT_BIT			0x1C
+#define MODE0_LUMA_FILTER_SELECT_SFT			0x02
+#define MODE0_LUMA_FILTER_SELECT_LOWPASS_NTSC		0x00
+#define MODE0_LUMA_FILTER_SELECT_LOWPASS_PAL		0x04 /* ? */
+#define MODE0_LUMA_FILTER_SELECT_NOTCH_NTSC		0x08
+#define MODE0_LUMA_FILTER_SELECT_NOTCH_PAL		0x04 /* ? */
+#define MODE0_LUMA_FILTER_SELECT_EXTENDED_MODE		0x10
+#define MODE0_LUMA_FILTER_SELECT_CIF			0x14
+#define MODE0_LUMA_FILTER_SELECT_QCIF			0x18
+
+#define MODE0_OUTPUT_VIDEO_SELECT_BIT			0x03
+#define MODE0_OUTPUT_VIDEO_SELECT_SFT			0x00
+#define MODE0_OUTPUT_VIDEO_SELECT_NTSC			0x00
+#define MODE0_OUTPUT_VIDEO_SELECT_PAL			0x01
+#define MODE0_OUTPUT_VIDEO_SELECT_PAL_M			0x02
+
+
+/*------------------------------*/
+/* ADV7179_MODE1                */
+/*------------------------------*/
+#define MODE1_COLORBAR_CONTROL_BIT			0x80
+#define MODE1_COLORBAR_CONTROL_SFT			0x07
+#define MODE1_COLORBAR_CONTROL_DISABLE			0x00
+#define MODE1_COLORBAR_CONTROL_ENABLE			0x80
+
+#define MODE1_DAC_A_CONTROL_BIT				0x40
+#define MODE1_DAC_A_CONTROL_SFT				0x06
+#define MODE1_DAC_A_CONTROL_NORMAL			0x00
+#define MODE1_DAC_A_CONTROL_POWERDOWN			0x40
+
+#define MODE1_DAC_B_CONTROL_BIT				0x20
+#define MODE1_DAC_B_CONTROL_SFT				0x05
+#define MODE1_DAC_B_CONTROL_NORMAL			0x00
+#define MODE1_DAC_B_CONTROL_POWERDOWN			0x20
+
+#define MODE1_DAC_C_CONTROL_BIT				0x08
+#define MODE1_DAC_C_CONTROL_SFT				0x03
+#define MODE1_DAC_C_CONTROL_NORMAL			0x00
+#define MODE1_DAC_C_CONTROL_POWERDOWN			0x08
+
+#define MODE1_CLOSED_CAPTIONING_FIELD_BIT		0x06
+#define MODE1_CLOSED_CAPTIONING_FIELD_SFT		0x01
+#define MODE1_CLOSED_CAPTIONING_FIELD_NO_DATAOUT	0x00
+#define MODE1_CLOSED_CAPTIONING_FIELD_ODD_ONLY		0x02
+#define MODE1_CLOSED_CAPTIONING_FIELD_EVEN_ONLY		0x04
+#define MODE1_CLOSED_CAPTIONING_FIELD_DATAOUT		0x06
+
+#define MODE1_INTERLACE_CONTROL_BIT			0x01
+#define MODE1_INTERLACE_CONTROL_SFT			0x00
+#define MODE1_INTERLACE_CONTROL_INTERLACED		0x00
+#define MODE1_INTERLACE_CONTROL_NONINTERLACED		0x01
+
+
+/*------------------------------*/
+/* ADV7179_MODE2                */
+/*------------------------------*/
+#define MODE2_LOW_POWER_MODE_BIT			0x40
+#define MODE2_LOW_POWER_MODE_SFT			0x06
+#define MODE2_LOW_POWER_MODE_DISABLE			0x00
+#define MODE2_LOW_POWER_MODE_ENABLE			0x40
+
+#define MODE2_BURST_CONTROL_BIT				0x20
+#define MODE2_BURST_CONTROL_SFT				0x05
+#define MODE2_BURST_CONTROL_ENABLE			0x00
+#define MODE2_BURST_CONTROL_DISABLE			0x20
+
+#define MODE2_CHROMINANCE_CONTROL_BIT			0x10
+#define MODE2_CHROMINANCE_CONTROL_SFT			0x04
+#define MODE2_CHROMINANCE_CONTROL_ENABLE		0x00
+#define MODE2_CHROMINANCE_CONTROL_DISABLE		0x10
+
+#define MODE2_ACTIVEVIDEO_LINE_BIT			0x08
+#define MODE2_ACTIVEVIDEO_LINE_SFT			0x03
+#define MODE2_ACTIVEVIDEO_LINE_720PIX			0x00
+#define MODE2_ACTIVEVIDEO_LINE_710_702PIX		0x08
+
+#define MODE2_GENLOCK_CONTROL_BIT			0x06
+#define MODE2_GENLOCK_CONTROL_SFT			0x01
+#define MODE2_GENLOCK_CONTROL_DISABLE			0x00
+#define MODE2_GENLOCK_CONTROL_SUBCARRIER_RESET_PIN	0x02
+#define MODE2_GENLOCK_CONTROL_RTC_PIN			0x06
+
+#define MODE2_AQUARE_PIXEL_CONTROL_BIT			0x01
+#define MODE2_AQUARE_PIXEL_CONTROL_SFT			0x00
+#define MODE2_AQUARE_PIXEL_CONTROL_DISABLE		0x00
+#define MODE2_AQUARE_PIXEL_CONTROL_ENABLE		0x01
+
+
+/*------------------------------*/
+/* ADV7179_MODE3                */
+/*------------------------------*/
+#define MODE3_INPUT_DEFAULT_COLOR_BIT			0x80
+#define MODE3_INPUT_DEFAULT_COLOR_SFT			0x07
+#define MODE3_INPUT_DEFAULT_COLOR_DISABLE		0x00
+#define MODE3_INPUT_DEFAULT_COLOR_ENABLE		0x80
+
+#define MODE3_TTXREQ_BIT_MODE_CONTROL_BIT		0x40
+#define MODE3_TTXREQ_BIT_MODE_CONTROL_SFT		0x06
+#define MODE3_TTXREQ_BIT_MODE_CONTROL_DISABLE		0x00
+#define MODE3_TTXREQ_BIT_MODE_CONTROL_ENABLE		0x40
+
+#define MODE3_TELETEXT_BIT				0x20
+#define MODE3_TELETEXT_SFT				0x05
+#define MODE3_TELETEXT_DISABLE				0x00
+#define MODE3_TELETEXT_ENABLE				0x20
+
+#define MODE3_CHROMA_OUTPUT_SELECT_BIT			0x10
+#define MODE3_CHROMA_OUTPUT_SELECT_SFT			0x04
+#define MODE3_CHROMA_OUTPUT_SELECT_DISABLE		0x00
+#define MODE3_CHROMA_OUTPUT_SELECT_ENABLE		0x10
+
+#define MODE3_DAC_OUTPUT_BIT				0x08
+#define MODE3_DAC_OUTPUT_SFT				0x03
+#define MODE3_DAC_OUTPUT_SCART				0x00
+#define MODE3_DAC_OUTPUT_EUROSCART			0x08
+
+#define MODE3_VBI_OPEN_BIT				0x04
+#define MODE3_VBI_OPEN_SFT				0x02
+#define MODE3_VBI_OPEN_DISABLE				0x00
+#define MODE3_VBI_OPEN_ENABLE				0x04
+
+
+/*------------------------------*/
+/* ADV7179_MODE4                */
+/*------------------------------*/
+#define MODE4_PEDESTAL_CONTROL_BIT			0x10
+#define MODE4_PEDESTAL_CONTROL_SFT			0x04
+#define MODE4_PEDESTAL_CONTROL_OFF			0x00
+#define MODE4_PEDESTAL_CONTROL_ON			0x10
+
+#define MODE4_VSYNC_3H_BIT				0x08
+#define MODE4_VSYNC_3H_SFT				0x03
+#define MODE4_VSYNC_3H_DISABLE				0x00
+#define MODE4_VSYNC_3H_ENABLE				0x08
+
+#define MODE4_RGB_SYNC_BIT				0x04
+#define MODE4_RGB_SYNC_SFT				0x02
+#define MODE4_RGB_SYNC_DISABLE				0x00
+#define MODE4_RGB_SYNC_ENABLE				0x04
+
+#define MODE4_RGBYUV_CONTROL_BIT			0x02
+#define MODE4_RGBYUV_CONTROL_SFT			0x01
+#define MODE4_RGBYUV_CONTROL_RGBOUTPUT			0x00
+#define MODE4_RGBYUV_CONTROL_YUVOUTPUT			0x02
+
+#define MODE4_OUTPUT_SELECT_BIT				0x01
+#define MODE4_OUTPUT_SELECT_SFT				0x00
+#define MODE4_OUTPUT_SELECT_YCOUTPUT			0x00
+#define MODE4_OUTPUT_SELECT_RGBYUVOUTPUT		0x01
+
+
+/*------------------------------*/
+/* ADV7179_SUBCAREER_FREQUENCY0-3 */
+/*------------------------------*/
+#define SUBCAREER_FREQUENCY_BIT				0xFF
+#define SUBCAREER_FREQUENCY_SFT				0x00
+
+
+
+
+
+#endif /* _ADV7179_H_ */
+
+
diff --git a/drivers/video/mp200/nts/mp200_adv7179.c b/drivers/video/mp200/nts/mp200_adv7179.c
new file mode 100644
index 0000000..fd07a18
--- /dev/null
+++ b/drivers/video/mp200/nts/mp200_adv7179.c
@@ -0,0 +1,341 @@
+/*
+ *  File Name       : /drivers/video/mp200/nts/mp200_adv7179.c
+ *  Function        : adv7179 video encoder for NTSC I/F Driver
+ *  Release Version : Ver 1.02
+ *  Release Date    : 2009/10/19
+ *
+ *  Copyright (C) NEC Electronics Corporation 2009
+ *
+ *
+ * This program is free software;you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by Free Softwere
+ * Foundation; either version 2 of License, or (at your option) any later
+ * version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warrnty of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
+ * details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; If not, write to the Free Software Foundation, Inc., 59 Temple
+ * Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+/***************************************************************************/
+/*    Include Header Files                                                 */
+/***************************************************************************/
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/fs.h>
+#include <linux/kernel.h>
+#include <linux/major.h>
+#include <linux/slab.h>
+#include <linux/mm.h>
+#include <linux/pci.h>
+#include <linux/signal.h>
+#include <linux/sched.h>
+#include <linux/types.h>
+#include <linux/device.h>
+/* #include <linux/videodev.h>*/
+#include <linux/video_encoder.h>
+#include <linux/version.h>
+#include <linux/i2c.h>
+#include <linux/platform_device.h>
+
+#include <linux/io.h>
+#include <asm/pgtable.h>
+#include <asm/page.h>
+#include <asm/segment.h>
+#include <linux/uaccess.h>
+
+#include "../mp200_common.h"
+#include "adv7179.h"
+#include "mp200_nts_common.h"
+#include "mp200_nts.h"
+
+
+/***************************************************************************/
+/*    Definitions                                                          */
+/***************************************************************************/
+#define I2C_ADV7179_CLIENT_INIT NULL
+
+
+/***************************************************************************/
+/*    structure                                                            */
+/***************************************************************************/
+struct adv7179 {
+	int norm;
+	int enable;
+};
+
+
+/***************************************************************************/
+/*    function                                                             */
+/***************************************************************************/
+static int i2c_adv7179_probe(struct i2c_client *client,
+ const struct i2c_device_id *id);
+static int i2c_adv7179_remove(struct i2c_client *client);
+
+/***************************************************************************/
+/*    variable                                                             */
+/***************************************************************************/
+static char			adv7179_name[] = "ADV7179 video encoder";
+static struct encoder_reg	*encoder_adv7179;
+
+static struct i2c_device_id i2c_adv7179_idtable[] = {
+	{ "adv7179", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, i2c_adv7179_idtable);
+static struct i2c_driver i2c_adv7179_driver = {
+	.driver = {
+		.name	= "i2c for adv7179",
+		.owner	= THIS_MODULE,
+	},
+	.id_table	= i2c_adv7179_idtable,
+	.probe		= i2c_adv7179_probe,
+	.remove		= i2c_adv7179_remove,
+};
+
+static struct i2c_client *i2c_adv7179_client = I2C_ADV7179_CLIENT_INIT;
+
+/* i2c functions */
+static int i2c_adv7179_probe(struct i2c_client *client,
+ const struct i2c_device_id *id)
+{
+	if (!i2c_check_functionality(client->adapter,
+		I2C_FUNC_SMBUS_WRITE_BYTE_DATA | I2C_FUNC_SMBUS_BYTE)) {
+		printk(KERN_INFO
+			"[Error] %s: i2c_check_functionality() error.\n",
+			__func__);
+		return -1;
+	}
+
+	i2c_adv7179_client = client;
+	return 0;
+}
+static int i2c_adv7179_remove(struct i2c_client *client)
+{
+	i2c_adv7179_client = NULL;
+	return 0;
+}
+
+static int i2c_adv7179_cleanup(void)
+{
+	i2c_del_driver(&i2c_adv7179_driver);
+	return 0;
+}
+
+static int i2c_adv7179_init(void)
+{
+	int ret;
+	ret = i2c_add_driver(&i2c_adv7179_driver);
+	if (ret != 0) {
+		printk(KERN_INFO "[Error] %s: i2c_add_driver() error.\n",
+		 __func__);
+	}
+	return ret;
+}
+
+static int i2c_adv7179_write(unsigned char reg, unsigned char data)
+{
+	unsigned char i2c_data[2];
+
+	i2c_data[0] = reg;
+	i2c_data[1] = data;
+
+	return i2c_master_send(i2c_adv7179_client, i2c_data, sizeof(i2c_data));
+}
+
+
+static int mp200_adv7179_command(unsigned int cmd, void *arg)
+{
+	int ret = 0;
+	struct adv7179 *encoder;
+
+	encoder = (struct adv7179 *)encoder_adv7179->private_data;
+
+	if (encoder == NULL)
+		return -1;
+
+	switch (cmd) {
+	case ENCODER_SET_NORM:
+	{
+		int iarg = *(int *) arg;
+		int i;
+		unsigned char reg[6];
+		unsigned char data[6];
+
+		switch (iarg) {
+		case NTS_OUTPUT_NTSC:
+			reg[0]  = ADV7179_MODE0;
+			data[0] = MODE0_CHROMA_FILTER_SELECT_1_3MHZ_LOWPASS
+			 | MODE0_LUMA_FILTER_SELECT_LOWPASS_NTSC
+			 | MODE0_OUTPUT_VIDEO_SELECT_NTSC;
+			reg[1]  = ADV7179_MODE4;
+			data[1] = MODE4_PEDESTAL_CONTROL_ON;
+			reg[2]  = ADV7179_SUBCAREER_FREQUENCY0;
+			data[2] = 0x16;
+			reg[3]  = ADV7179_SUBCAREER_FREQUENCY1;
+			data[3] = 0x7C;
+			reg[4]  = ADV7179_SUBCAREER_FREQUENCY2;
+			data[4] = 0xF0;
+			reg[5]  = ADV7179_SUBCAREER_FREQUENCY3;
+			data[5] = 0x21;
+			break;
+		case NTS_OUTPUT_PAL:
+#ifdef CONFIG_MP200_NTS_PAL /* PAL B/D/G/H/I/N */
+			reg[0]  = ADV7179_MODE0;
+			data[0] = MODE0_CHROMA_FILTER_SELECT_1_3MHZ_LOWPASS
+			 | MODE0_LUMA_FILTER_SELECT_LOWPASS_PAL
+			 | MODE0_OUTPUT_VIDEO_SELECT_PAL;
+			reg[1]  = ADV7179_MODE4;
+			data[1] = MODE4_PEDESTAL_CONTROL_OFF;
+			reg[2]  = ADV7179_SUBCAREER_FREQUENCY0;
+			data[2] = 0xCB;
+			reg[3]  = ADV7179_SUBCAREER_FREQUENCY1;
+			data[3] = 0x8A;
+			reg[4]  = ADV7179_SUBCAREER_FREQUENCY2;
+			data[4] = 0x09;
+			reg[5]  = ADV7179_SUBCAREER_FREQUENCY3;
+			data[5] = 0x2A;
+#endif
+#ifdef CONFIG_MP200_NTS_PAL60 /* PAL-60 */
+			reg[0]  = ADV7179_MODE0;
+			data[0] = MODE0_CHROMA_FILTER_SELECT_1_3MHZ_LOWPASS
+			 | MODE0_LUMA_FILTER_SELECT_LOWPASS_PAL;
+			reg[1]  = ADV7179_MODE4;
+			data[1] = MODE4_PEDESTAL_CONTROL_OFF;
+			reg[2]  = ADV7179_SUBCAREER_FREQUENCY0;
+			data[2] = 0xCB;
+			reg[3]  = ADV7179_SUBCAREER_FREQUENCY1;
+			data[3] = 0x8A;
+			reg[4]  = ADV7179_SUBCAREER_FREQUENCY2;
+			data[4] = 0x09;
+			reg[5]  = ADV7179_SUBCAREER_FREQUENCY3;
+			data[5] = 0x2A;
+#endif
+			break;
+		default:
+			return -EINVAL;
+		}
+
+		for (i = 0; i < 6; i++)
+			ret = i2c_adv7179_write(reg[i], data[i]);
+
+		break;
+	}
+	case ENCODER_SET_INPUT:
+	{
+		int *iarg = arg;
+		/* not much choice of inputs */
+		if (*iarg != 0)
+			return -EINVAL;
+		break;
+	}
+	case ENCODER_SET_OUTPUT:
+	{
+		int *iarg = arg;
+		/* not much choice of outputs */
+		if (*iarg != 0)
+			return -EINVAL;
+		break;
+	}
+	case ENCODER_ENABLE_OUTPUT:
+	{
+		int *iarg = arg;
+		encoder->enable = !!*iarg;
+		break;
+	}
+	default:
+		return -EINVAL;
+	}
+
+	return ret;
+}
+
+static void mp200_adv7179_shutdown(void *dummy)
+{
+	struct adv7179 *encoder;
+
+	encoder = (struct adv7179 *)encoder_adv7179->private_data;
+
+	kfree(encoder);		/* NULL check is inside. */
+	encoder_adv7179->private_data = (void *)NULL;
+
+	i2c_adv7179_cleanup();
+
+	return;
+}
+
+
+#include "mach/pwc.h"
+
+static int mp200_adv7179_init(void *dummy)
+{
+	int ret = 0;
+	struct adv7179 *encoder;
+
+	if (i2c_adv7179_init() != 0) {
+		printk(KERN_INFO "[Error] %s: i2c initialize error.\n",
+		 __func__);
+		return -ENODEV;
+	}
+
+	encoder = kmalloc(sizeof(struct adv7179), GFP_KERNEL);
+	if (encoder == NULL) {
+		printk(KERN_INFO "[Error] %s: memory allocate error.\n",
+		 __func__);
+		i2c_adv7179_cleanup();
+		return -ENOMEM;
+	}
+	memset(encoder, 0, sizeof(struct adv7179));
+	encoder->norm = NTS_OUTPUT_NTSC;
+	encoder->enable = 1;
+
+	ret = i2c_adv7179_write(ADV7179_MODE1, 0x10);
+	if (ret <= 0) {
+		printk(KERN_INFO "[Error] %s: i2c_master_send() error.\n",
+		 __func__);
+		i2c_adv7179_cleanup();
+		kfree(encoder);
+		return ret;
+	}
+
+	encoder_adv7179->private_data = (void *)encoder;
+	return 0;
+}
+
+int adv7179_init(struct mp200_nts_dev *ntsc)
+{
+	encoder_adv7179 = kmalloc(sizeof(struct encoder_reg), GFP_KERNEL);
+	if (encoder_adv7179 == NULL)
+		return -ENOMEM;
+
+	memset(encoder_adv7179, 0, sizeof(struct encoder_reg));
+	strcpy(encoder_adv7179->name, adv7179_name);
+	encoder_adv7179->hw_init	= mp200_adv7179_init;
+	encoder_adv7179->hw_shutdown	= mp200_adv7179_shutdown;
+	encoder_adv7179->hw_command	= mp200_adv7179_command;
+
+	ntsc->encoder = encoder_adv7179;
+	return 0;
+}
+
+void adv7179_exit(struct mp200_nts_dev *ntsc)
+{
+	if (encoder_adv7179) {
+		if (encoder_adv7179->private_data) {
+			void *dummy = 0;
+			mp200_adv7179_shutdown(dummy);
+		}
+		kfree(encoder_adv7179);
+		encoder_adv7179 = NULL;
+	}
+
+	ntsc->encoder = NULL;
+}
diff --git a/drivers/video/mp200/nts/mp200_adv7179.h b/drivers/video/mp200/nts/mp200_adv7179.h
new file mode 100644
index 0000000..9c5a27c
--- /dev/null
+++ b/drivers/video/mp200/nts/mp200_adv7179.h
@@ -0,0 +1,40 @@
+/*
+ *  File Name       : /drivers/video/mp200/nts/mp200_adv7179.h
+ *  Function        : adv7179 video encoder for NTSC I/F Driver
+ *  Release Version : Ver 1.01
+ *  Release Date    : 2009/10/19
+ *
+ *  Copyright (C) NEC Electronics Corporation 2009
+ *
+ *
+ * This program is free software;you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by Free Softwere
+ * Foundation; either version 2 of License, or (at your option) any later
+ * version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warrnty of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
+ * details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; If not, write to the Free Software Foundation, Inc., 59 Temple
+ * Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+
+#ifndef _MP200_ADV7179_H_
+#define _MP200_ADV7179_H_
+
+
+/********************************************************
+ *  Prototype declarations of function                  *
+ *******************************************************/
+extern int  adv7179_init(struct mp200_nts_dev *ntsc);
+extern void adv7179_exit(struct mp200_nts_dev *ntsc);
+
+
+
+#endif /* _MP200_ADV7179_H_ */
+
diff --git a/drivers/video/mp200/nts/mp200_nts.c b/drivers/video/mp200/nts/mp200_nts.c
new file mode 100644
index 0000000..221483c
--- /dev/null
+++ b/drivers/video/mp200/nts/mp200_nts.c
@@ -0,0 +1,1456 @@
+/*
+ * File Name       : /drivers/video/mp200/nts/mp200_nts.c
+ * Function        : NTSC Driver corresponding to V4L2
+ * Release Version : Ver 1.00
+ * Release Date    : 2008/11/13
+ *
+ * Copyright (C) NEC Electronics Corporation 2008
+ *
+ *
+ * This program is free software;you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by Free Softwere
+ * Foundation; either version 2 of License, or (at your option) any later
+ * version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warrnty of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
+ * details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; If not, write to the Free Software Foundation, Inc., 59 Temple
+ * Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+
+/********************************************************
+ *  Include Files                                       *
+ *******************************************************/
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/version.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/tty.h>
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/fb.h>
+#include <linux/init.h>
+#include <linux/ioport.h>
+#include <linux/timer.h>
+#include <linux/sched.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/video_encoder.h>
+#include <linux/uaccess.h>
+
+#if defined(CONFIG_PM) || defined(CONFIG_DPM)
+#include <mach/pm.h>
+#endif /* CONFIG_PM || CONFIG_DPM */
+
+#include <mach/hardware.h>
+#include <mach/irqs.h>
+#include <mach/pmu.h>
+#include <mach/em1_mem.h>
+
+#include "../mp200_common.h"
+#include "../mp200_lcd_common.h"
+#include "../mp200_lcd.h"
+#include "../mp200_fb.h"
+#include "ntsc.h"
+#include "mp200_nts_common.h"
+#include "mp200_ntshw.h"
+#include "mp200_nts.h"
+#include "mp200_ntsipu.h"
+#include "mp200_adv7179.h"
+
+
+/********************************************************
+ *  debug parameters                                    *
+ *******************************************************/
+#define _DEBUG_NTS  0x00 /* 00008421(bit) */
+			 /* 0x01: debug function in
+			  * 0x02: debug function out
+			  * 0x40: debug FBIOBLANK
+			  * 0x80: debug semafore
+			  */
+
+
+#define printk_err(fmt, arg...) \
+	do {                     \
+		printk(KERN_ERR DEV_NAME ": %s: " fmt, __func__, ## arg); \
+	} while (0)
+
+#define printk_wrn(fmt, arg...) \
+	do {                     \
+		printk(KERN_WARNING DEV_NAME ": %s: " fmt, __func__, ## arg); \
+	} while (0)
+
+#define printk_info(fmt, arg...) \
+	do {                      \
+		printk(KERN_INFO DEV_NAME ": " fmt, ## arg); \
+	} while (0)
+
+#if _DEBUG_NTS
+#define printk_dbg(level, fmt, arg...) \
+	do {                            \
+		if (level > 0) \
+			printk(KERN_DEBUG DEV_NAME ": %s: " fmt, \
+				__func__, ## arg); \
+	} while (0)
+#else
+#define printk_dbg(level, fmt, arg...) \
+	;
+#endif
+
+
+/********************************************************
+ *  Definitions                                         *
+ *******************************************************/
+#define DEV_NAME "mp200_nts"
+
+/* V4L2 mix ON/OFF */
+#define V4L2_MIX_OFF		0
+#define V4L2_MIX_ON		1
+/* V4L2 pause status */
+#define V4L2_PAUSE_OFF		0
+#define V4L2_PAUSE_ON		1
+/* callback to V4L2 status */
+#define V4L2_CALLBACK_OFF	0
+#define V4L2_CALLBACK_ON	1
+
+/*** waite timer status ***/
+/* (MIX_V4L2_TIMEOUT * 10ms) is waittime */
+#define MIX_V4L2_TIMEOUT	10
+#define NTS_TIMER_STOP		0
+#define NTS_TIMER_START		1
+
+/* nts_probe() */
+#define NTS_SUCCESS		0
+#define NTS_FAILED_REQUESTIRQ	-1
+
+#define DPM_SUSPEND_FLG_INIT 0
+#define CTRL_FUNC_INIT 0
+
+
+/********************************************************
+ *  Macros                                              *
+ *******************************************************/
+
+
+/********************************************************
+ *  Structure                                           *
+ *******************************************************/
+
+
+/********************************************************
+ *  Variables                                           *
+ *******************************************************/
+struct mp200_nts_dev *ntsc;
+
+
+/********************************************************
+ *  Prototype declarations of local function            *
+ *******************************************************/
+#if defined(CONFIG_PM) || defined(CONFIG_DPM)
+static int          DPM_suspend_flg = DPM_SUSPEND_FLG_INIT;
+static int          ctrl_func       = CTRL_FUNC_INIT;
+#endif /* CONFIG_PM || CONFIG_DPM */
+
+/* Private function */
+static int          nts_set_v4l2_image(V4L2_IMAGE_INFO *v4l2_info);
+static int          nts_set_fb_image(FB_IMAGE_INFO *fb_image_info);
+static void         nts_mix_image(int iMixMode, int iCallbackV4L2);
+       /* VSYNC interrupt handler */
+static irqreturn_t  nts_irq_handler(int irq, void *dev_id);
+
+static void         nts_init_flags(struct mp200_nts_dev *ntsc);
+static void         nts_init_val(struct mp200_nts_dev *ntsc);
+static int          nts_probe(void);
+static void         nts_tmr_init(void);
+static void         nts_tmr_add(void);
+static void         nts_tmr_timeout(unsigned long data);
+static void         nts_tmr_timeout_bottom_do(struct work_struct *num);
+
+static int  __init  mp200_nts_init_module(void);
+#ifdef MODULE
+static void __exit  mp200_nts_exit_module(void);
+static void         mp200_nts_remove(void);
+#endif /* MODULE */
+
+
+/******************************************************************************
+* MODULE   : mp200_nts_blank
+* FUNCTION : FBIOBLANK
+* RETURN   : 0       : success
+*            -EINVAL : input value incorrect
+* NOTE     : none
+* CREATE   : 2009.9.14 Y.Utsuhara
+* UPDATE   :
+******************************************************************************/
+int mp200_nts_blank(int blank_mode)
+{
+	int backlight, output, clock;
+	unsigned long flags;
+
+	printk_dbg((_DEBUG_NTS & 0x40), "<start>\n");
+
+	switch (blank_mode) {
+	/* Screen: On,  HSync: On,  VSync: On */
+	case FB_BLANK_UNBLANK:
+		printk_dbg((_DEBUG_NTS & 0x40), "<FB_BLANK_UNBLANK>\n");
+		backlight = 1;
+		output    = 1;
+		clock     = 1;
+		break;
+	/* Screen: Off, HSync: On,  VSync: On */
+	case FB_BLANK_NORMAL:
+		printk_dbg((_DEBUG_NTS & 0x40), "<FB_BLANK_NORMAL>\n");
+		backlight = 0;
+		output    = 1;
+		clock     = 1;
+		break;
+	/* Screen: Off, HSync: On,  VSync: Off */
+	case FB_BLANK_VSYNC_SUSPEND:
+		printk_dbg((_DEBUG_NTS & 0x40), "<FB_BLANK_VSYNC_SUSPEND>\n");
+		backlight = 0;
+		output    = 0;
+		clock     = 1;
+		break;
+	/* Screen: Off, HSync: Off, VSync: On */
+	case FB_BLANK_HSYNC_SUSPEND:
+		printk_dbg((_DEBUG_NTS & 0x40), "<FB_BLANK_HSYNC_SUSPEND>\n");
+		backlight = 0;
+		output    = 0;
+		clock     = 1;
+		break;
+	/* Screen: Off, HSync: Off, VSync: Off */
+	case FB_BLANK_POWERDOWN:
+		printk_dbg((_DEBUG_NTS & 0x40), "<FB_BLANK_POWERDOWN>\n");
+		backlight = 0;
+		output    = 0;
+		clock     = 0;
+		break;
+	default:
+		printk_dbg((_DEBUG_NTS & 0x40), "<failed(%d)>\n", -EINVAL);
+		return -EINVAL;
+	}
+
+	if (ntsc->iOutmodeFlg == NTS_OUTPUT_DISABLE) {
+		ntsc->blank_state.nts_backlight = backlight;
+		ntsc->blank_state.nts_output    = output;
+		ntsc->blank_state.nts_clock     = clock;
+		ntsc->blank_state.current_mode  = blank_mode;
+		return 0;
+	}
+
+	down(&ntsc->sem_img_data);
+	down(&ntsc->sem_img_flag);
+	spin_lock_irqsave(&ntsc->nts_lock, flags);
+
+	/* output    On -> Off */
+	if ((output == 0) && (ntsc->blank_state.nts_output == 1)) {
+		/* backlight On -> Off */
+		if ((backlight == 0)
+		 && (ntsc->blank_state.nts_backlight == 1)) {
+			printk_dbg((_DEBUG_NTS & 0x40),
+			 "<backlight On -> Off>\n");
+			ntsc->blank_state.nts_backlight = 0;
+		}
+		printk_dbg((_DEBUG_NTS & 0x40), "<output    On -> Off>\n");
+		ntsc->blank_state.nts_output    = 0;
+		if (ntsc->ntsout_flg != NTS_NTSOUT_DISABLE)
+			ntshw_start(NTSHW_STOP);
+
+	} else {
+		/* backlight On -> Off */
+		if ((backlight == 0)
+		 && (ntsc->blank_state.nts_backlight == 1)) {
+			printk_dbg((_DEBUG_NTS & 0x40),
+			 "<backlight On -> Off>\n");
+			ntsc->blank_state.nts_backlight = 0;
+			if (ntsc->ntsout_flg == NTS_NTSOUT_ENABLE)
+				ntshw_set_ntsout(NTS_NTSOUT_ENABLE_BLACK);
+		}
+	}
+
+	/* clock     On -> Off */
+	if ((clock == 0) && (ntsc->blank_state.nts_clock == 1)) {
+		printk_dbg((_DEBUG_NTS & 0x40), "<clock     On -> Off>\n");
+		ntsc->blank_state.nts_clock     = 0;
+		/* Do not reset NTSC because it's unnecessary
+		   and because reseting before waiting NTS out is disabled
+		   causes BUS hung up. */
+	}
+	/* clock     Off -> On */
+	if ((clock == 1) && (ntsc->blank_state.nts_clock == 0)) {
+		printk_dbg((_DEBUG_NTS & 0x40), "<clock     Off -> On>\n");
+		ntsc->blank_state.nts_clock     = 1;
+	}
+
+	/* backlight Off -> On */
+	if ((backlight == 1) && (ntsc->blank_state.nts_backlight == 0)) {
+		/* output    Off -> on */
+		if ((output == 1) && (ntsc->blank_state.nts_output == 0)) {
+			printk_dbg((_DEBUG_NTS & 0x40),
+			 "<output    Off -> on>\n");
+			ntsc->blank_state.nts_output    = 1;
+		}
+		printk_dbg((_DEBUG_NTS & 0x40), "<backlight Off -> On>\n");
+		ntsc->blank_state.nts_backlight = 1;
+#if (_DEBUG_NTS & 0x40)
+		if (ntsc->ntsout_flg == NTS_NTSOUT_ENABLE)
+			printk_dbg((_DEBUG_NTS & 0x40),
+			 "<set NTSOUT On (Normal)>\n");
+#endif
+		ntshw_set_ntsout(ntsc->ntsout_flg);
+	} else {
+		/* output    Off -> on */
+		if ((output == 1) && (ntsc->blank_state.nts_output == 0)) {
+			printk_dbg((_DEBUG_NTS & 0x40),
+			 "<output    Off -> on>\n");
+			ntsc->blank_state.nts_output    = 1;
+			if (ntsc->ntsout_flg == NTS_NTSOUT_ENABLE)
+				ntshw_set_ntsout(NTS_NTSOUT_ENABLE_BLACK);
+		}
+	}
+
+	spin_unlock_irqrestore(&ntsc->nts_lock, flags);
+	up(&ntsc->sem_img_data);
+	up(&ntsc->sem_img_flag);
+
+	ntsc->blank_state.current_mode = blank_mode;
+	return 0;
+}
+EXPORT_SYMBOL(mp200_nts_blank);
+
+
+/******************************************************************************
+* MODULE   : mp200_nts_reserve
+* FUNCTION :
+* RETURN   :       0 : success
+*          : -EINVAL : misstype argument
+*          :    -EIO :
+* NOTE     : none
+* CREATE   : 2008.11.13 M.Haguro
+* UPDATE   :
+******************************************************************************/
+int mp200_nts_reserve(int iActiveDevice, int iSetOutmode)
+{
+	int iRet = 0;
+	printk_dbg((_DEBUG_NTS & 0x01),
+	 "%d: iActiveDevice(%x)  iSetOutmode(%x)\n", __LINE__, iActiveDevice,
+	 iSetOutmode);
+
+	/* check argument */
+	if (iActiveDevice < NTS_ACTIVE_FB || iActiveDevice > NTS_ACTIVE_V4L2) {
+		iRet = -EINVAL;
+		goto failed;
+	}
+	if (iSetOutmode < NTS_OUTPUT_NTSC || iSetOutmode > NTS_OUTPUT_PAL) {
+		iRet = -EINVAL;
+		goto failed;
+	}
+
+	down(&ntsc->sem_img_data);
+	printk_dbg((_DEBUG_NTS & 0x80), "down(A)\n");
+
+	if (!ntsc->iNtsActive || ntsc->iOutmodeFlg == iSetOutmode) {
+		if (!ntsc->iNtsActive) {
+			/* NTSC initialize */
+			iRet = ntshw_reserve(iSetOutmode);
+			if (iRet || !ntsc->encoder->hw_init) {
+				iRet = -EIO;
+			} else {
+				int dummy;
+				/* ADV7179 initialize */
+				iRet = ntsc->encoder->hw_init(&dummy);
+				if (iRet) {
+					ntshw_release();
+					iRet = -EIO;
+				} else {
+					/* install NTSC irq handler */
+					iRet = request_irq(INT_NTSC,
+						nts_irq_handler, 0,
+						DEV_NAME, NULL);
+					if (iRet) {
+						if (ntsc->encoder->
+							hw_shutdown) {
+							int dummy;
+							ntsc->encoder->
+								hw_shutdown(
+									&dummy);
+						}
+						ntshw_release();
+						iRet = -EIO;
+					} else {
+						int iZero = 0;
+						ntsc->encoder->hw_command(
+							ENCODER_SET_NORM,
+							 &iSetOutmode);
+						ntsc->encoder->hw_command(
+							ENCODER_SET_INPUT,
+							&iZero);
+
+						/* start NTSC output */
+						ntsc->iOutmodeFlg = iSetOutmode;
+						ntsc->ntsout_flg =
+							NTS_NTSOUT_ENABLE_BLACK;
+						if (ntsc->blank_state.nts_output
+							== 1) {
+							ntshw_start(
+								NTSHW_START);
+						} else {
+							printk_dbg(
+							(_DEBUG_NTS &
+							0x40),
+							"set NTSOUT disable: "
+							"current blank mode = "
+							"%d\n",
+							ntsc->blank_state.
+							current_mode);
+							ntshw_set_ntsout(
+							NTS_NTSOUT_DISABLE);
+						}
+					}
+				}
+			}
+		}
+
+		if (!iRet) {
+			if (iActiveDevice == NTS_ACTIVE_FB) {
+				memset(&ntsc->from_fb, 0,
+				 sizeof(FB_IMAGE_INFO));
+			}
+			ntsc->iNtsActive |= iActiveDevice;
+			printk_dbg((_DEBUG_NTS & 0x01),
+			 "%d: iNtsActive(%04x)\n", __LINE__, ntsc->iNtsActive);
+		}
+	} else {
+		iRet = -EIO;
+	}
+
+	up(&ntsc->sem_img_data);
+	printk_dbg((_DEBUG_NTS & 0x80), "up(A)\n");
+
+failed:
+	return iRet;
+}
+EXPORT_SYMBOL(mp200_nts_reserve);
+
+
+/******************************************************************************
+* MODULE   : mp200_nts_release
+* FUNCTION :
+* RETURN   :       0 : success
+*          : -EINVAL : misstype argument
+* NOTE     : none
+* CREATE   : 2008.11.13 M.Haguro
+* UPDATE   :
+******************************************************************************/
+int mp200_nts_release(int iActiveDevice)
+{
+	int iRet = 0;
+	printk_dbg((_DEBUG_NTS & 0x01), "%d: iActiveDevice(%x)\n", __LINE__,
+	 iActiveDevice);
+
+	/* check argument */
+	if (iActiveDevice < NTS_ACTIVE_FB || iActiveDevice > NTS_ACTIVE_V4L2) {
+		iRet = -EINVAL;
+		goto failed;
+	}
+
+	down(&ntsc->sem_img_data);
+	printk_dbg((_DEBUG_NTS & 0x80), "down(A)\n");
+	down(&ntsc->sem_img_flag);
+	printk_dbg((_DEBUG_NTS & 0x80), "down(B)\n");
+
+	if (ntsc->iNtsActive & iActiveDevice) {
+		if (ntsc->iNtsActive == (NTS_ACTIVE_FB | NTS_ACTIVE_V4L2)) {
+			/* fb1 & v4l2 mixing mode */
+			if (iActiveDevice == NTS_ACTIVE_FB) {
+				/* fb1 disable */
+				ntsc->iMixImageMode = (ntsc->iMixImageMode
+				 & ~FB_BIT) | FB_OFF;
+				memset(&ntsc->from_fb, 0,
+					sizeof(FB_IMAGE_INFO));
+
+				if (ntsc->iMixImageMode != FB_V4L2_OFF) {
+					if (ntsc->iFrameNoNow ==
+						NTS_DISP_FRAME_A) {
+						ntshw_clr_framebuf(
+							NTS_DISP_FRAME_B);
+						ntsc->img_complete = 0;
+						ntsipu_img_request();
+						wait_event_interruptible(
+							ntsc->wait_img,
+							ntsc->img_complete);
+						ntshw_clr_framebuf(
+							NTS_DISP_FRAME_A);
+					} else {	/* NTS_DISP_FRAME_B */
+						ntshw_clr_framebuf(
+							NTS_DISP_FRAME_A);
+						ntsc->img_complete = 0;
+						ntsipu_img_request();
+						wait_event_interruptible(
+							ntsc->wait_img,
+							ntsc->img_complete);
+						ntshw_clr_framebuf(
+							NTS_DISP_FRAME_B);
+					}
+				} else {
+					up(&ntsc->sem_img_flag);
+					printk_dbg((_DEBUG_NTS & 0x80),
+					 "up(B)\n");
+				}
+			} else if (iActiveDevice == NTS_ACTIVE_V4L2) {
+				/* v4l2 disable */
+				ntsc->iMixImageMode = (ntsc->iMixImageMode
+				 & ~V4L2_BIT) | V4L2_OFF;
+				memset(&ntsc->from_v4l2, 0,
+				 sizeof(V4L2_IMAGE_INFO));
+
+				if (ntsc->iMixImageMode != FB_V4L2_OFF) {
+					ntsc->img_complete = 0;
+					ntsipu_img_request();
+					wait_event_interruptible(ntsc->wait_img,
+					 ntsc->img_complete);
+				} else {
+					up(&ntsc->sem_img_flag);
+					printk_dbg((_DEBUG_NTS & 0x80),
+					 "up(B)\n");
+				}
+			} else {
+				up(&ntsc->sem_img_flag);
+				printk_dbg((_DEBUG_NTS & 0x80), "up(B)\n");
+			}
+		} else {
+			up(&ntsc->sem_img_flag);
+			printk_dbg((_DEBUG_NTS & 0x80), "up(B)\n");
+		}
+
+		ntsc->iNtsActive &= ~iActiveDevice;
+		printk_dbg((_DEBUG_NTS & 0x01), "%d: iNtsActive(%04x)\n",
+		 __LINE__, ntsc->iNtsActive);
+
+		if (!ntsc->iNtsActive) {
+			ntsc->iOutmodeFlg = NTS_OUTPUT_DISABLE;
+			ntsc->ntsout_flg = NTS_NTSOUT_DISABLE;
+			ntshw_start(NTSHW_STOP);
+			free_irq(INT_NTSC, NULL);
+			ntshw_release();
+
+			if (ntsc->encoder->hw_shutdown) {
+				int dummy;
+				ntsc->encoder->hw_shutdown(&dummy);
+			}
+			nts_init_flags(ntsc);
+		}
+	} else {
+		up(&ntsc->sem_img_flag);
+		printk_dbg((_DEBUG_NTS & 0x80), "up(B)\n");
+	}
+
+	up(&ntsc->sem_img_data);
+	printk_dbg((_DEBUG_NTS & 0x80), "up(A)\n");
+
+failed:
+	return iRet;
+}
+EXPORT_SYMBOL(mp200_nts_release);
+
+
+/******************************************************************************
+* MODULE   : mp200_nts_getmode
+* FUNCTION :
+* RETURN   : 0 : non active
+*          : 1 : active & NTSC
+*          : 2 : active & PAL
+* NOTE     : none
+* CREATE   : 2008.11.13 M.Haguro
+* UPDATE   :
+******************************************************************************/
+int mp200_nts_getmode(void)
+{
+	printk_dbg((_DEBUG_NTS & 0x01), "\n");
+	return ntsc->iOutmodeFlg;
+}
+EXPORT_SYMBOL(mp200_nts_getmode);
+
+
+/******************************************************************************
+* MODULE   : mp200_nts_set_v4l2_image
+* FUNCTION : set image data from v4l2 to NTSC local
+* RETURN   :  0 : success
+*            -1 : faile
+* NOTE     : none
+* CREATE   : 2008.11.20 M.Haguro
+* UPDATE   :
+******************************************************************************/
+int mp200_nts_set_v4l2_image(V4L2_IMAGE_INFO *v4l2_info)
+{
+	unsigned long flags;
+	int ret = 0;
+
+	printk_dbg((_DEBUG_NTS & 0x01), "\n");
+
+	/* Stop pause timer */
+	spin_lock_irqsave(&ntsc->lock_tmr, flags);
+	del_timer(&ntsc->nts_timer);
+	ntsc->iTimerFlag    = NTS_TIMER_STOP;
+	spin_unlock_irqrestore(&ntsc->lock_tmr, flags);
+	ntsc->iV4L2PauseFlg = V4L2_PAUSE_OFF;
+
+	down(&ntsc->sem_img_data);	/* get data semafore */
+	printk_dbg((_DEBUG_NTS & 0x80), "down(A)\n");
+
+	if (ntsc->iNtsActive & NTS_ACTIVE_V4L2) {
+		/* V4L2 active */
+		nts_set_v4l2_image(v4l2_info);
+	} else {
+		/* V4L2 not active */
+		ret = -EACCES;
+	}
+	up(&ntsc->sem_img_data);	/* release data semafore */
+	printk_dbg((_DEBUG_NTS & 0x80), "up(A)\n");
+	return ret;
+}
+EXPORT_SYMBOL(mp200_nts_set_v4l2_image);
+
+
+/******************************************************************************
+* MODULE   : mp200_nts_set_fb_image
+* FUNCTION : set image data from Frame Buffer to NTSC local
+* RETURN   :  0 : success
+*            -1 : faile
+* NOTE     : none
+* CREATE   : 2008.11.20 M.Haguroq
+* UPDATE   :
+******************************************************************************/
+int mp200_nts_set_fb_image(FB_IMAGE_INFO *fb_info)
+{
+	int ret = 0;
+	printk_dbg((_DEBUG_NTS & 0x01), "\n");
+
+	down(&ntsc->sem_img_data);	/* get data semafore */
+	printk_dbg((_DEBUG_NTS & 0x80), "down(A)\n");
+
+	if (ntsc->iNtsActive & NTS_ACTIVE_FB) {
+		/* fb1 active */
+		nts_set_fb_image(fb_info);
+	} else {
+		/* fb1 not active */
+		ret = -EACCES;
+	}
+	up(&ntsc->sem_img_data);	/* release data semafore */
+	printk_dbg((_DEBUG_NTS & 0x80), "up(A)\n");
+	return ret;
+}
+EXPORT_SYMBOL(mp200_nts_set_fb_image);
+
+
+/******************************************************************************
+* MODULE   : nts_set_v4l2_image
+* FUNCTION : set image data from v4l2 to NTSC local
+* RETURN   : 0 : success
+* NOTE     : none
+* CREATE   : 2008.11.13 M.Haguro
+* UPDATE   :
+******************************************************************************/
+static int nts_set_v4l2_image(V4L2_IMAGE_INFO *v4l2_info)
+{
+	unsigned long flags;
+
+	printk_dbg((_DEBUG_NTS & 0x01), "\n");
+
+	/* DSP stop */
+	if (v4l2_info->image_data.yrgbaddr == 0) {
+		printk_dbg((_DEBUG_NTS & 0x01), "<stop V4L2>\n");
+		/* movie off */
+		ntsc->iMixDSPFlg = V4L2_MIX_OFF;
+		/* update Layer data */
+		nts_mix_image(V4L2_OFF, V4L2_CALLBACK_OFF);
+		return 0;
+	}
+
+	/* movie on */
+	ntsc->iMixDSPFlg = V4L2_MIX_ON;
+
+	memcpy(&ntsc->from_v4l2, v4l2_info, sizeof(V4L2_IMAGE_INFO));
+
+	/* mix - image data from v4l2 and image data
+	 from fb driver (DSP and 2D) */
+	if (ntsc->from_v4l2.screen_data.hsize == 0) {
+		printk_dbg((_DEBUG_NTS & 0x01), "<V4L2_OFF>\n");
+		nts_mix_image(V4L2_OFF, V4L2_CALLBACK_ON);
+	} else {
+		printk_dbg((_DEBUG_NTS & 0x01), "<V4L2_ON>\n");
+		nts_mix_image(V4L2_ON,  V4L2_CALLBACK_ON);
+	}
+
+	/* PAUSE check timer start */
+	spin_lock_irqsave(&ntsc->lock_tmr, flags);
+	if (ntsc->iTimerFlag == NTS_TIMER_STOP
+#if defined(CONFIG_PM) || defined(CONFIG_DPM)
+			&& !DPM_suspend_flg
+#endif /* CONFIG_PM || CONFIG_DPM */
+	) {
+		nts_tmr_add();
+		ntsc->iTimerFlag = NTS_TIMER_START;
+	}
+	spin_unlock_irqrestore(&ntsc->lock_tmr, flags);
+	return 0;
+}
+
+
+/******************************************************************************
+* MODULE   : nts_set_fb_image
+* FUNCTION : set image data from Frame Buffer to NTSC local
+* RETURN   :  0 : success
+*            -1 : faile
+* NOTE     : none
+* CREATE   : 2008.11.20 M.Haguro
+* UPDATE   :
+******************************************************************************/
+static int nts_set_fb_image(FB_IMAGE_INFO *fb_info)
+{
+	int iRet = 0;
+
+	printk_dbg((_DEBUG_NTS & 0x01), "\n");
+
+	memcpy(&ntsc->from_fb, fb_info, sizeof(FB_IMAGE_INFO));
+
+	/* check update flag */
+	switch (ntsc->from_fb.update_flag) {
+	case FB_UPDATE_ON:  /*    ioctl(MP200_FB_UPDATE_SCRN) & update = 0 */
+			    /* or interval update                          */
+		printk_dbg((_DEBUG_NTS & 0x02), "FB_UPDATE_ON\n");
+
+		if (ntsc->iMixDSPFlg == V4L2_MIX_ON
+		 && ntsc->iV4L2PauseFlg == V4L2_PAUSE_OFF) {
+			/* movie on.  and not pause status */
+			iRet = -1;
+		} else {
+			/* movie off. or movie pause status */
+			nts_mix_image(FB_ON, V4L2_CALLBACK_OFF);
+		}
+		break;
+	case FB_ABSOLUTERY_UPDATE:
+	/* ioctl(MP200_FB_UPDATE_SCRN) & update = 1 */
+		printk_dbg((_DEBUG_NTS & 0x02), "FB_ABSOLUTERY_UPDATE\n");
+		nts_mix_image(FB_ON, V4L2_CALLBACK_OFF);
+		break;
+	case FB_UPDATE_OFF:  /* ioctl(MP200_FB_SET_MODES) */
+	default:             /* other */
+		printk_dbg((_DEBUG_NTS & 0x02), "FB_UPDATE_OFF\n");
+		iRet = -1;
+		break;
+	}
+	return iRet;
+}
+
+
+/******************************************************************************
+* MODULE   : nts_mix_image
+* FUNCTION : By using IMG, mix 2D (and DSP) image
+* RETURN   :  0 : success
+*          : -1 : failed
+* NOTE     : none
+* CREATE   : 2008.11.14 M.Haguro
+* UPDATE   :
+******************************************************************************/
+static void nts_mix_image(int iMixMode, int iCallbackV4L2)
+{
+	printk_dbg((_DEBUG_NTS & 0x01), "\n");
+
+	/* get flag semafore */
+	down(&ntsc->sem_img_flag);
+	printk_dbg((_DEBUG_NTS & 0x80), "down(B)\n");
+
+	/* set flag and temp data */
+	ntsc->iV4L2CallbackFlg     = iCallbackV4L2;
+	ntsc->uiMixFrameBufferPage = ntsc->from_fb.mix_buf_page;
+	ntsc->iMixDSPFlg_toFb      = ntsc->iMixDSPFlg;
+
+	if (iMixMode & FB_BIT) {
+		ntsc->iMixImageMode = (ntsc->iMixImageMode & ~FB_BIT)
+		 | iMixMode;
+		if ((ntsc->iNtsActive & NTS_ACTIVE_V4L2)
+		 && ntsc->from_v4l2.image_data.yrgbaddr) {
+			ntsc->iMixImageMode = (ntsc->iMixImageMode & ~V4L2_BIT)
+			 | V4L2_ON;
+		} else{
+			ntsc->iMixImageMode = (ntsc->iMixImageMode & ~V4L2_BIT)
+			 | V4L2_OFF;
+		}
+	} else {
+		ntsc->iMixImageMode = (ntsc->iMixImageMode & ~V4L2_BIT)
+		 | iMixMode;
+		if ((ntsc->iNtsActive & NTS_ACTIVE_FB)
+		 && ntsc->from_fb.image_data.yrgbaddr) {
+			ntsc->iMixImageMode = (ntsc->iMixImageMode & ~FB_BIT)
+			 | FB_ON;
+		} else{
+			ntsc->iMixImageMode = (ntsc->iMixImageMode & ~FB_BIT)
+			 | FB_OFF;
+		}
+
+		if (ntsc->iV4L2CallbackFlg == V4L2_CALLBACK_ON) {
+			/* set frame data from V4L2 */
+			memcpy(&ntsc->v4l2_callback_data,
+			 &ntsc->from_v4l2.frame_data,
+			 sizeof(struct _FRAME_DATA));
+		}
+	}
+
+	if (ntsc->iMixImageMode == FB_V4L2_OFF) {
+		printk_dbg((_DEBUG_NTS & 0x02),
+		 "iMixImageMode(%d) -> Black screen\n", ntsc->iMixImageMode);
+
+		/* Black Screen */
+		ntsc->ntsout_flg = NTS_NTSOUT_ENABLE_BLACK;
+		if (ntsc->blank_state.nts_output == 1) {
+			ntshw_set_ntsout(NTS_NTSOUT_ENABLE_BLACK);
+		} else {
+			printk_dbg((_DEBUG_NTS & 0x40),
+			 "set NTSOUT disable: current blank mode = %d\n",
+			 ntsc->blank_state.current_mode);
+			ntshw_set_ntsout(NTS_NTSOUT_DISABLE);
+		}
+		nts_return_callback_refresh();
+		nts_return_callback();
+	} else {
+		printk_dbg((_DEBUG_NTS & 0x02), "iMixImageMode(%d)\n",
+		 ntsc->iMixImageMode);
+		printk_dbg((_DEBUG_NTS & 0x02), "ntsipu_img_request() call\n");
+		/* regist img request to IPU Driver */
+		if (ntsipu_img_request()) {
+			printk_dbg((_DEBUG_NTS & 0x02),
+			 "ntsipu_img_request() failed\n");
+			nts_return_callback_refresh();
+			nts_return_callback();
+		}
+	}
+}
+
+
+/*****************************************************************************
+* MODULE   : nts_irq_handler
+* FUNCTION : NTSC interrupt handler
+* RETURN   : IRQ_HANDLED
+* NOTE     : none
+* CREATE   : 2008/11/17 M.Haguro
+* UPDATE   :
+******************************************************************************/
+static irqreturn_t nts_irq_handler(int irq, void *dev_id)
+{
+	unsigned long ulRegVal32, flags;
+
+	printk_dbg((_DEBUG_NTS & 0x01), "\n");
+	spin_lock_irqsave(&ntsc->lock_tmr, flags);
+
+	/*  check Interuppt Status */
+	ulRegVal32 = ntshw_chk_intstatus();
+
+	/* Interrupt Status Clear */
+	ntshw_set_interruput(NTSHW_INTFFCLR);
+
+	if (ulRegVal32 & NTS_NTSVS_BIT)
+		nts_irq_handler_sub();
+
+	spin_unlock_irqrestore(&ntsc->lock_tmr, flags);
+	printk_dbg((_DEBUG_NTS & 0x02), "<end>\n");
+
+	return IRQ_HANDLED;
+}
+
+
+/*****************************************************************************
+* MODULE   : nts_irq_handler_sub
+* FUNCTION : NTSC interrupt handler
+* RETURN   :
+* NOTE     : none
+* CREATE   : 2008/11/17 M.Haguro
+* UPDATE   :
+******************************************************************************/
+void nts_irq_handler_sub(void)
+{
+	unsigned long ulRegVal32;
+
+	printk_dbg((_DEBUG_NTS & 0x01), "\n");
+
+	if (ntsc->blank_state.nts_output == 1) {
+		/* check AREASTATUS */
+		ulRegVal32 = ntshw_chk_framesel();
+
+		if (((ntsc->iFrameNoNext == NTS_DISP_FRAME_A) &&
+			((ulRegVal32 & NTS_AREASTATUS_BIT) ==
+			NTS_AREASTATUS_BUFA)) || ((ntsc->iFrameNoNext ==
+			NTS_DISP_FRAME_B) && ((ulRegVal32 &
+			NTS_AREASTATUS_BIT) == NTS_AREASTATUS_BUFB))) {
+			/* disable NTSC interrupts */
+			ntshw_set_interruput(NTSHW_INTENCLR);
+
+			ntsc->iFrameNoNow = ntsc->iFrameNoNext;
+
+			nts_return_callback();
+		}
+	} else {
+		/* disable NTSC interrupts */
+		ntshw_set_interruput(NTSHW_INTENCLR);
+
+		ntsc->iFrameNoNow = ntsc->iFrameNoNext;
+
+		nts_return_callback();
+	}
+	printk_dbg((_DEBUG_NTS & 0x02), "<end>\n");
+}
+
+
+/*****************************************************************************
+* MODULE   : nts_return_callback
+* FUNCTION : NTSC interrupt handler
+* RETURN   :
+* NOTE     : none
+* CREATE   : 2008/11/17 M.Haguro
+* UPDATE   :
+******************************************************************************/
+void nts_return_callback(void)
+{
+	printk_dbg((_DEBUG_NTS & 0x01), "\n");
+
+	/* when kick nts_mix_image by V4L2 */
+	if (ntsc->iV4L2CallbackFlg == V4L2_CALLBACK_ON) {
+		ntsc->iV4L2CallbackFlg = V4L2_CALLBACK_OFF;
+
+		printk_dbg((_DEBUG_NTS & 0x02), "-> v4l2\n");
+		/* call v4l2 callback function */
+		mp200_v4l2_lcd_callback(ntsc->v4l2_callback_data);
+		memset(&ntsc->v4l2_callback_data, 0,
+		 sizeof(struct _FRAME_DATA));
+	}
+
+#if defined(CONFIG_PM) || defined(CONFIG_DPM)
+	ctrl_func = 0;
+#endif /* CONFIG_PM || CONFIG_DPM */
+
+	ntsc->img_complete = 1;
+	wake_up_interruptible(&ntsc->wait_img);
+
+	/* release semafore */
+	up(&ntsc->sem_img_flag);
+	printk_dbg((_DEBUG_NTS & 0x80), "up(B)\n");
+}
+
+
+/*****************************************************************************
+* MODULE   : nts_return_callback_refresh
+* FUNCTION :
+* RETURN   : none
+* NOTE     : none
+* CREATE   : 2008/12/05 M.Haguro
+* UPDATE   :
+******************************************************************************/
+void nts_return_callback_refresh(void)
+{
+	unsigned long flags;
+	spin_lock_irqsave(&ntsc->lock_callback, flags);
+	printk_dbg((_DEBUG_NTS & 0x01), "\n");
+
+	if (ntsc->iNtsActive & NTS_ACTIVE_FB) {
+		/* call FB Driver function "mp200_fb_callback" */
+		mp200_fb_callback((int)ntsc->uiMixFrameBufferPage,
+		 ntsc->iMixDSPFlg_toFb, EM1_FB_DEVICE_NTS);
+	}
+
+	/* when kick nts_mix_image by V4L2 */
+	if (ntsc->iV4L2CallbackFlg == CALLBACK_V4L2_ON) {
+		printk_dbg((_DEBUG_NTS & 0x02), "-> v4l2\n");
+		/* call v4l2 callback function */
+		mp200_v4l2_lcd_refresh_callback(ntsc->v4l2_callback_data);
+	}
+
+#if defined(CONFIG_PM) || defined(CONFIG_DPM)
+	ctrl_func = 1;
+#endif /* CONFIG_PM || CONFIG_DPM */
+	spin_unlock_irqrestore(&ntsc->lock_callback, flags);
+}
+
+
+/*****************************************************************************
+* MODULE   : nts_return_callback_ready
+* FUNCTION :
+* RETURN   : none
+* NOTE     : none
+* CREATE   : 2009/04/06 M.Haguro
+* UPDATE   :
+******************************************************************************/
+void nts_return_callback_ready(void)
+{
+	unsigned long flags;
+	spin_lock_irqsave(&ntsc->lock_callback, flags);
+	printk_dbg((_DEBUG_NTS & 0x01), "\n");
+
+	/* when kick nts_mix_image by V4L2 */
+	if (ntsc->iV4L2CallbackFlg == CALLBACK_V4L2_ON) {
+		printk_dbg((_DEBUG_NTS & 0x02), "-> v4l2\n");
+		/* call v4l2 callback function */
+		mp200_v4l2_ntsc_ready_callback(ntsc->v4l2_callback_data);
+	}
+	spin_unlock_irqrestore(&ntsc->lock_callback, flags);
+}
+
+
+/********************************************************
+ *  Timer Function Definitions                          *
+ *******************************************************/
+/******************************************************************************
+* MODULE   : nts_tmr_init
+* FUNCTION : timer function init
+* RETURN   : none
+* NOTE     : private function
+* CREATE   : 2008.11.13 M.Haguro
+* UPDATE   :
+******************************************************************************/
+static void nts_tmr_init(void)
+{
+	printk_dbg((_DEBUG_NTS & 0x01), "\n");
+
+	init_timer(&ntsc->nts_timer);
+	ntsc->nts_timer.function = nts_tmr_timeout;
+	ntsc->nts_timer.data     = 0;
+	ntsc->iTimerFlag         = NTS_TIMER_STOP;
+}
+
+
+/******************************************************************************
+* MODULE   : nts_tmr_add
+* FUNCTION : timer function add_timer
+* RETURN   : none
+* NOTE     : private function
+* CREATE   : 2008.11.13 M.Haguro
+* UPDATE   :
+******************************************************************************/
+static void nts_tmr_add(void)
+{
+	printk_dbg((_DEBUG_NTS & 0x01), "\n");
+
+	ntsc->nts_timer.expires = jiffies + (MIX_V4L2_TIMEOUT * 10 * HZ / 1000);
+	add_timer(&ntsc->nts_timer);
+}
+
+
+/******************************************************************************
+* MODULE   : nts_tmr_timeout
+* FUNCTION : when call mp200_fb_call_timer
+* RETURN   : none
+* NOTE     : public function
+* CREATE   : 2008.11.13 M.Haguro
+* UPDATE   :
+******************************************************************************/
+static void nts_tmr_timeout(unsigned long data)
+{
+	printk_dbg((_DEBUG_NTS & 0x01), "\n");
+
+	/* change NTSC status to PAUSE */
+	ntsc->iV4L2PauseFlg = V4L2_PAUSE_ON;
+	queue_work(ntsc->mp200_nts_workqueue, &ntsc->wk_timeout_bottom_half);
+}
+
+
+/******************************************************************************
+* MODULE   : nts_tmr_timeout_bottom_do
+* FUNCTION : when call mp200_fb_call_timer
+* RETURN   : none
+* NOTE     : public function
+* CREATE   : 2008.11.13 M.Haguro
+* UPDATE   :
+******************************************************************************/
+static void nts_tmr_timeout_bottom_do(struct work_struct *num)
+{
+	printk_dbg((_DEBUG_NTS & 0x01), "\n");
+
+	down(&ntsc->sem_img_data);	/* get semafore */
+	printk_dbg((_DEBUG_NTS & 0x80), "down(A)\n");
+
+	/* mix image */
+	if (ntsc->from_v4l2.screen_data.hsize == 0) {
+		printk_dbg((_DEBUG_NTS & 0x01), "<V4L2_OFF>\n");
+		nts_mix_image(V4L2_OFF, V4L2_CALLBACK_OFF);
+	} else {
+		printk_dbg((_DEBUG_NTS & 0x01), "<V4L2_ON>\n");
+		nts_mix_image(V4L2_ON, V4L2_CALLBACK_OFF);
+	}
+
+	up(&ntsc->sem_img_data);	/* release data semafore */
+	printk_dbg((_DEBUG_NTS & 0x80), "up(A)\n");
+}
+
+
+#if defined(CONFIG_PM) || defined(CONFIG_DPM)
+/********************************************************
+ *  Suspend/Resume Function Definitions                 *
+ *******************************************************/
+/******************************************************************************
+* MODULE   : mp200_nts_suspend
+* FUNCTION : suspend NTSC driver
+* RETURN   : 0 : success
+* NOTE     : none
+* CREATE   : 2006.08.15 H.Nagashima
+* UPDATE   :
+******************************************************************************/
+int mp200_nts_suspend(struct platform_device *dev, pm_message_t state)
+{
+	if (ntsc->iOutmodeFlg == NTS_OUTPUT_DISABLE) {
+		return 0;
+	} else {
+		if (state.event == DEV_SUSPEND_IDLE_1) {
+			return -EBUSY;
+		} else{	/* state.event == PM_EVENT_SUSPEND */
+			if (!mp200_sleep_while_idle) {
+				DPM_suspend_flg = 1;
+
+				/* NTSC timer stop */
+				del_timer(&ntsc->nts_timer);
+
+				if (ntsc->blank_state.nts_output == 1) {
+					/* NTSC POWER OFF */
+					ntshw_start(NTSHW_STOP);
+				}
+
+				/* Save NTSC H/W register data */
+				ntshw_save_reg();
+
+				/* Reset NTSC */
+				ntshw_reset(NTSHW_RESET);
+			}
+		}
+		return 0;
+	}
+}
+
+
+/******************************************************************************
+* MODULE   : mp200_nts_resume
+* FUNCTION : suspend NTSC driver
+* RETURN   : 0 : success
+* NOTE     : none
+* CREATE   : 2006.08.15 H.Nagashima
+* UPDATE   :
+******************************************************************************/
+int mp200_nts_resume(struct platform_device *dev)
+{
+	if (ntsc->iOutmodeFlg == NTS_OUTPUT_DISABLE) {
+		return 0;
+	} else {
+		if (DPM_suspend_flg) {
+			DPM_suspend_flg = 0;
+
+			/* UnReset NTSC */
+			ntshw_reset(NTSHW_UNRESET);
+
+			/* Restore NTSC H/W register data */
+			ntshw_restore_reg();
+
+			if (ntsc->blank_state.nts_output == 1) {
+				/* NTSC POWER ON */
+				ntshw_start(NTSHW_START);
+			}
+
+			/* NTSC timer start */
+			if (ntsc->iTimerFlag == NTS_TIMER_START)
+				nts_tmr_add();
+
+			switch (ctrl_func) {
+/*			case 2: */
+/*				nts_return_callback_refresh(); */
+				/* FALL THROUGH */
+			case 1:
+				nts_return_callback();
+				break;
+			case 0:
+			default:
+				break;
+			}
+		}
+		return 0;
+	}
+}
+#endif /* CONFIG_PM || CONFIG_DPM */
+
+
+/********************************************************
+ *  Init Function Definitions                           *
+ *******************************************************/
+/******************************************************************************
+* MODULE   : nts_probe
+* FUNCTION : NTSC Driver probe
+* RETURN   : 0     : success
+*            other : fail
+* NOTE     : none
+* CREATE   : 2008.11.17 M.Haguro
+* UPDATE   :
+******************************************************************************/
+static int nts_probe(void)
+{
+	int iRet;
+	printk_dbg((_DEBUG_NTS & 0x01), "\n");
+
+	/* initiarize ipu request */
+	iRet = ntsipu_initialize(ntsc);
+	if (iRet)
+		goto err_ret;
+
+	/* initialize semafore */
+	sema_init(&ntsc->sem_img_data, 1);
+	sema_init(&ntsc->sem_img_flag, 1);
+
+	/* initialize spin lock */
+	spin_lock_init(&ntsc->nts_lock);
+	spin_lock_init(&ntsc->lock_tmr);
+	spin_lock_init(&ntsc->lock_callback);
+
+	/* initiarize work queue */
+	ntsc->mp200_nts_workqueue = create_singlethread_workqueue(DEV_NAME);
+	INIT_WORK(&ntsc->wk_timeout_bottom_half, nts_tmr_timeout_bottom_do);
+
+	init_waitqueue_head(&ntsc->wait_img);
+
+	ntsc->blank_state.current_mode  = FB_BLANK_UNBLANK;
+	ntsc->blank_state.nts_backlight = 1;
+	ntsc->blank_state.nts_output    = 1;
+	ntsc->blank_state.nts_clock     = 1;
+	ntsc->ntsout_flg                = NTS_NTSOUT_DISABLE;
+
+err_ret:
+	return iRet;
+}
+
+
+/******************************************************************************
+* MODULE   : nts_init_flags
+* FUNCTION : variable default set
+* RETURN   : none
+* NOTE     : none
+* CREATE   : 2009.1.6 M.Haguro
+* UPDATE   :
+******************************************************************************/
+static void nts_init_flags(struct mp200_nts_dev *ntsc)
+{
+	printk_dbg((_DEBUG_NTS & 0x01), "\n");
+	ntsc->iNtsActive           = 0;
+
+	/*** input image data from fb driver ***/
+	/* next frame buffer (2D)         */
+	ntsc->uiMixFrameBufferPage = NTS_DISP_FRAME_A;
+	/* absolutely update flag         */
+	ntsc->uiAbsolutelyUpFlag   = FB_UPDATE_OFF;
+
+	/*** flags ***/
+	/* movie & UI mix ON/OFF          */
+	ntsc->iMixDSPFlg           = V4L2_MIX_OFF;
+	/* movie & UI mix ON/OFF (for FB) */
+	ntsc->iMixDSPFlg_toFb      = V4L2_MIX_OFF;
+
+	/* V4L2 pause status flag         */
+	ntsc->iV4L2PauseFlg        = V4L2_PAUSE_OFF;
+	/* need to callback to V4L2       */
+	ntsc->iV4L2CallbackFlg     = V4L2_CALLBACK_OFF;
+	memset(&ntsc->v4l2_callback_data, 0, sizeof(struct _FRAME_DATA));
+
+	/* now display frame no           */
+	ntsc->iFrameNoNow          = NTS_DISP_INIT;
+	/* set change frame no            */
+	ntsc->iFrameNoNext         = NTS_DISP_INIT;
+
+	/* output i/f                     */
+	ntsc->iOutmodeFlg          = NTS_OUTPUT_DISABLE;
+	ntsc->iMixImageMode        = FB_OFF | V4L2_OFF;
+
+	memset(&ntsc->from_fb,   0, sizeof(FB_IMAGE_INFO));
+	memset(&ntsc->from_v4l2, 0, sizeof(V4L2_IMAGE_INFO));
+}
+
+
+/******************************************************************************
+* MODULE   : nts_init_val
+* FUNCTION : variable default set
+* RETURN   : none
+* NOTE     : none
+* CREATE   : 2008.11.17 M.Haguro
+* UPDATE   :
+******************************************************************************/
+static void nts_init_val(struct mp200_nts_dev *ntsc)
+{
+	printk_dbg((_DEBUG_NTS & 0x01), "\n");
+	memset(ntsc, 0, sizeof(struct mp200_nts_dev));
+
+	/* input image data from fb driver */
+	nts_init_flags(ntsc);
+}
+
+
+/******************************************************************************
+* MODULE   : nts_alloc_dev
+* FUNCTION : variable default set
+* RETURN   : none
+* NOTE     : none
+* CREATE   : 2008.11.17 M.Haguro
+* UPDATE   :
+******************************************************************************/
+static void *nts_alloc_dev(void)
+{
+	void *alloc_dev;
+
+	printk_dbg((_DEBUG_NTS & 0x01), "\n");
+
+	alloc_dev = kmalloc(sizeof(struct mp200_nts_dev), GFP_KERNEL);
+	if (!alloc_dev) {
+		;
+	} else {
+		/* variable initialized */
+		nts_init_val((struct mp200_nts_dev *)alloc_dev);
+	}
+	return alloc_dev;
+}
+
+
+/******************************************************************************
+* MODULE   : nts_free_dev
+* FUNCTION : variable default set
+* RETURN   : none
+* NOTE     : none
+* CREATE   : 2008.11.17 M.Haguro
+* UPDATE   :
+******************************************************************************/
+static void nts_free_dev(void)
+{
+	if (ntsc) {
+		memset(ntsc, 0, sizeof(struct mp200_nts_dev));
+		kfree(ntsc);
+	}
+}
+
+
+/******************************************************************************
+* MODULE   : mp200_nts_init_module
+* FUNCTION : initialize NTSC Driver
+* RETURN   : 0     : success
+*            other : fail
+* NOTE     : none
+* CREATE   : 2008.11.17 M.Haguro
+* UPDATE   :
+******************************************************************************/
+static int __init mp200_nts_init_module(void)
+{
+	int iRet;
+
+	printk_dbg((_DEBUG_NTS & 0x01), "\n");
+
+	/* nts_device memset */
+	ntsc = (struct mp200_nts_dev *)nts_alloc_dev();
+	if (!ntsc) {
+		printk_err("memory allocate error\n");
+		iRet = -ENOMEM;
+		goto fail_nts_alloc_dev;
+	}
+
+	/* initialize ADV7179 */
+	iRet = adv7179_init(ntsc);
+	if (iRet) {
+		printk_err("adv7179 initalize error\n");
+		goto fail_adv7179_init;
+	}
+
+	/* initialize NTSC */
+	iRet = ntshw_init();
+	if (iRet) {
+		printk_err("ntshw initalize error\n");
+		goto fail_ntshw_init;
+	}
+
+	/* call nts_probe */
+	nts_probe();
+	if (iRet) {
+		printk_err("nts probe error\n");
+		goto fail_nts_probe;
+	}
+
+	/* timer initiarize */
+	nts_tmr_init();
+
+	printk_info("registered device ntsc\n");
+	iRet = 0;
+	goto success;
+
+fail_nts_probe:
+	ntshw_exit();
+fail_ntshw_init:
+	adv7179_exit(ntsc);
+fail_adv7179_init:
+	nts_free_dev();
+fail_nts_alloc_dev:
+success:
+	return iRet;
+}
+
+
+/********************************************************
+ *  Exit Function Definitions                           *
+ *******************************************************/
+#ifdef MODULE
+/******************************************************************************
+* MODULE   : mp200_nts_exit_module
+* FUNCTION : cleanup NTSC module
+* RETURN   : none
+* NOTE     : none
+* CREATE   : 2008.11.17 M.Haguro
+* UPDATE   :
+******************************************************************************/
+static void __exit mp200_nts_exit_module(void)
+{
+	printk_dbg((_DEBUG_NTS & 0x01), "\n");
+
+	mp200_nts_remove();
+
+	/* disable NTSC */
+	ntshw_exit();
+
+	adv7179_exit(ntsc);
+	nts_free_dev();
+}
+
+
+/******************************************************************************
+* MODULE   : mp200_nts_remove
+* FUNCTION : release NTSC resource
+* RETURN   : none
+* NOTE     : none
+* CREATE   : 2008.11.17 M.Haguro
+* UPDATE   :
+******************************************************************************/
+static void mp200_nts_remove(void)
+{
+	printk_dbg((_DEBUG_NTS & 0x01), "\n");
+
+	/* workqueue uninitialize */
+	destroy_workqueue(ntsc->mp200_nts_workqueue);
+
+	ntsipu_finitialize();
+}
+#endif /* MODULE */
+
+
+/* module alias */
+#ifdef MODULE
+module_init(mp200_nts_init_module);
+module_exit(mp200_nts_exit_module);
+#else
+device_initcall(mp200_nts_init_module);
+#endif
+
+
diff --git a/drivers/video/mp200/nts/mp200_nts.h b/drivers/video/mp200/nts/mp200_nts.h
new file mode 100644
index 0000000..7489cfc
--- /dev/null
+++ b/drivers/video/mp200/nts/mp200_nts.h
@@ -0,0 +1,55 @@
+/*
+ * File Name       : /drivers/video/mp200/nts/mp200_nts.h
+ * Function        : NTSC Driver corresponding to V4L2
+ * Release Version : Ver 1.01
+ * Release Date    : 2009/10/19
+ *
+ * Copyright (C) NEC Electronics Corporation 2009
+ *
+ *
+ * This program is free software;you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by Free Softwere
+ * Foundation; either version 2 of License, or (at your option) any later
+ * version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warrnty of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
+ * details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; If not, write to the Free Software Foundation, Inc., 59 Temple
+ * Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+
+#ifndef _MP200_NTS_H_
+#define _MP200_NTS_H_
+
+
+
+/********************************************************
+ *  Prototype declarations of function                  *
+ *******************************************************/
+extern int          mp200_nts_blank(int blank_mode);
+extern int          mp200_nts_reserve(int iActiveDevice, int iSetOutmode);
+extern int          mp200_nts_release(int iActiveDevice);
+extern int          mp200_nts_getmode(void);
+extern int          mp200_nts_set_v4l2_image(V4L2_IMAGE_INFO *v4l2_info);
+extern int          mp200_nts_set_fb_image(FB_IMAGE_INFO *fb_info);
+extern void         nts_irq_handler_sub(void);
+extern void         nts_return_callback(void);
+extern void         nts_return_callback_refresh(void);
+extern void         nts_return_callback_ready(void);
+
+#if defined(CONFIG_PM) || defined(CONFIG_DPM)
+extern int          mp200_nts_suspend(struct platform_device *dev,
+ pm_message_t state);
+extern int          mp200_nts_resume(struct platform_device *dev);
+#endif /* CONFIG_PM || CONFIG_DPM */
+
+extern void         mp200_v4l2_ntsc_ready_callback(FRAME_DATA frame_data);
+
+
+#endif /* _MP200_NTS_H_ */
diff --git a/drivers/video/mp200/nts/mp200_nts_common.h b/drivers/video/mp200/nts/mp200_nts_common.h
new file mode 100644
index 0000000..8846354
--- /dev/null
+++ b/drivers/video/mp200/nts/mp200_nts_common.h
@@ -0,0 +1,139 @@
+/*
+ * File Name       : /drivers/video/mp200/nts/mp200_nts_common.h
+ * Function        : NTSC Driver corresponding to V4L2
+ * Release Version : Ver 1.01
+ * Release Date    : 2009/10/19
+ *
+ * Copyright (C) NEC Electronics Corporation 2009
+ *
+ *
+ * This program is free software;you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by Free Softwere
+ * Foundation; either version 2 of License, or (at your option) any later
+ * version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warrnty of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
+ * details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; If not, write to the Free Software Foundation, Inc., 59 Temple
+ * Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+
+#ifndef _MP200_NTS_COMMON_H_
+#define _MP200_NTS_COMMON_H_
+
+
+/********************************************************
+ *  Definitions                                         *
+ *******************************************************/
+/* for iOutmodeFlg */
+#define FB_OFF			0x01
+#define FB_ON			0x02
+#define V4L2_OFF		0x04
+#define V4L2_ON			0x08
+
+#define FB_V4L2_OFF		0x05
+#define FB_ONLY			0x06
+#define V4L2_ONLY		0x09
+#define FB_V4L2_ON		0x0A
+
+#define FB_BIT			0x03
+#define V4L2_BIT		0x0C
+
+/* display frame no. for iFrameNoNow/iFrameNoNext */
+#define NTS_DISP_INIT		NTS_AREASEL_BUFDISABLE
+#define NTS_DISP_FRAME_A	NTS_AREASEL_BUFA
+#define NTS_DISP_FRAME_B	NTS_AREASEL_BUFB
+#define NTS_DISP_FRAME_C	NTS_AREASEL_BUFC
+
+
+/********************************************************
+ *  Structure                                           *
+ *******************************************************/
+/* structure video endcoder */
+struct encoder_reg {
+	char   name[32];
+	int    (*hw_init)(void *);
+	void   (*hw_shutdown)(void *);
+	int    (*hw_command)(unsigned int cmd, void *arg);
+	void  *private_data;
+};
+#define ENCODER_REG struct encoder_reg
+
+/* structure FBIOBLANK status */
+struct nts_blank_state {
+	int current_mode;
+	int nts_backlight;
+	int nts_output;
+	int nts_clock;
+};
+#define NTS_BLANK_STATE struct nts_blank_state
+
+/* structure nts device status */
+struct mp200_nts_dev {
+	/* semafore */
+	 /* semafore v4l2/fb/img local data */
+	struct semaphore         sem_img_data;
+	 /* semafore v4l2/fb/img local flag */
+	struct semaphore         sem_img_flag;
+	/* spinlock */
+	 /* spin lock for NTS               */
+	spinlock_t               nts_lock;
+	 /* spin lock for NTS timer         */
+	spinlock_t               lock_tmr;
+	 /* spin lock for callback          */
+	spinlock_t               lock_callback;
+	/* work queue */
+	struct workqueue_struct *mp200_nts_workqueue;
+	struct work_struct       wk_timeout_bottom_half;
+
+	/* waite timer. movie is pause state */
+	struct timer_list        nts_timer;
+	int                      iTimerFlag;	/* timer operation status */
+
+	/* wait queue */
+	wait_queue_head_t        wait_img;
+	int                      img_complete;
+
+	/* flags */
+	int                      iNtsActive;
+	/* next frame buffer (2D)          */
+	unsigned int             uiMixFrameBufferPage;
+
+	/* movie & UI mix ON/OFF           */
+	int                      iMixDSPFlg;
+	/* movie & UI mix ON/OFF (for FB)  */
+	int                      iMixDSPFlg_toFb;
+
+	/* V4L2 pause status flag          */
+	int                      iV4L2PauseFlg;
+	/* need to callback to V4L2        */
+	int                      iV4L2CallbackFlg;
+	struct _FRAME_DATA       v4l2_callback_data;
+
+	int                      iFrameNoNow;	/* now display frame no  */
+	int                      iFrameNoNext;	/* set change frame no   */
+
+	int                      iOutmodeFlg;	/* output i/f            */
+	int                      iMixImageMode;	/*  */
+
+	/* absolutely update flag    */
+	unsigned int             uiAbsolutelyUpFlag;
+
+	FB_IMAGE_INFO            from_fb;
+	V4L2_IMAGE_INFO          from_v4l2;
+
+	/* NTSC Encoder */
+	ENCODER_REG             *encoder;
+
+	/* FBIOBLANK */
+	NTS_BLANK_STATE          blank_state;
+	int                      ntsout_flg;
+};
+
+#endif /* _MP200_NTS_COMMON_H_ */
diff --git a/drivers/video/mp200/nts/mp200_nts_debug.h b/drivers/video/mp200/nts/mp200_nts_debug.h
new file mode 100644
index 0000000..e69de29
diff --git a/drivers/video/mp200/nts/mp200_ntshw.c b/drivers/video/mp200/nts/mp200_ntshw.c
new file mode 100644
index 0000000..4f644e7
--- /dev/null
+++ b/drivers/video/mp200/nts/mp200_ntshw.c
@@ -0,0 +1,1009 @@
+/*
+ * File Name       : /drivers/video/mp200/nts/mp200_ntshw.c
+ * Function        : NTSC Driver corresponding to V4L2 (H/W Control)
+ * Release Version : Ver 1.01
+ * Release Date    : 2009/10/19
+ *
+ * Copyright (C) NEC Electronics Corporation 2009
+ *
+ *
+ * This program is free software;you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by Free Softwere
+ * Foundation; either version 2 of License, or (at your option) any later
+ * version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warrnty of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
+ * details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; If not, write to the Free Software Foundation, Inc., 59 Temple
+ * Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+
+/********************************************************
+ *  Include Files                                       *
+ *******************************************************/
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/version.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/io.h>
+#include <linux/delay.h>
+
+#include <mach/irqs.h>
+#include <mach/smu.h>
+#include <mach/pmu.h>
+#include <mach/em1_mem.h>
+#include <mach/gdma.h>
+
+#include <mach/gpio.h>
+
+#include "../mp200_common.h"
+#include "ntsc.h"
+#include "mp200_nts_common.h"
+#include "mp200_ntsipu.h"
+#include "mp200_ntshw.h"
+
+
+/********************************************************
+ *  Definitions                                         *
+ *******************************************************/
+#define DEV_NAME "mp200_ntshw"
+
+
+/********************************************************
+ *  debug parameters                                    *
+ *******************************************************/
+#define _DEBUG_NTSHW  0x00 /* 00008421(bit) */
+			   /* 0x01: debug function in
+			    * 0x02: debug function out
+			    * 0x04: debug IMC
+			    * 0x08: debug frame change
+			    * 0x40: debug FBIOBLANK
+			    */
+
+
+#define printk_err(fmt, arg...) \
+	do {                     \
+		printk(KERN_ERR DEV_NAME ": %s: " fmt, __func__, ## arg); \
+	} while (0)
+
+#define printk_wrn(fmt, arg...) \
+	do {                     \
+		printk(KERN_WARNING DEV_NAME ": %s: " fmt, __func__, ## arg); \
+	} while (0)
+
+#define printk_info(fmt, arg...) \
+	do {                      \
+		printk(KERN_INFO DEV_NAME ": " fmt, ## arg); \
+	} while (0)
+
+#if _DEBUG_NTSHW
+#define printk_dbg(level, fmt, arg...) \
+	do {                            \
+		if (level > 0) \
+			printk(KERN_DEBUG DEV_NAME ": %s: " fmt, \
+				__func__, ## arg); \
+	} while (0)
+#else
+#define printk_dbg(level, fmt, arg...) \
+	;
+#endif
+
+
+/********************************************************
+ *  Macros                                              *
+ *******************************************************/
+
+
+/********************************************************
+ * NTSC register initialize                             *
+ *******************************************************/
+#define CHG_PINSEL_G64_NTS_BIT  0xFFFF0000
+#define CHG_PINSEL_G64_NTS_INIT 0x55550000
+#define CHG_PINSEL_G80_NTS_BIT  0x0000003F
+#define CHG_PINSEL_G80_NTS_INIT 0x00000015
+
+#define CHG_PULL_G72_NTS_BIT    0xFFFFFFFF
+#define CHG_PULL_G72_NTS_INIT   0x00000004
+#define CHG_PULL_G80_NTS_BIT    0xFFFFFFFF
+#define CHG_PULL_G80_NTS_INIT   0x00000000
+
+
+/********************************************************
+ *  Variables                                           *
+ *******************************************************/
+
+
+/********************************************************
+ *  Structure                                           *
+ *******************************************************/
+struct mp200_ntshw {
+	/* output mode */
+	int           Outmode;
+
+	/* NTSC MMIO */
+	unsigned long NTSCMmio;
+	unsigned long NTSCMmioLength;
+	char         *NTSCMmioV;
+
+	/* NTSC framebuffer */
+	unsigned long NtscFrameA_Y;
+	unsigned long NtscFrameA_UV;
+	unsigned long NtscFrameB_Y;
+	unsigned long NtscFrameB_UV;
+	unsigned long NtscFrameC_Y;
+	unsigned long NtscFrameC_UV;
+	unsigned long NtscFrameLength;
+	char         *NtscFrameAV;
+	char         *NtscFrameBV;
+
+	/* Smem (common memory to LCD) */
+	unsigned long Smem;
+	unsigned long SmemLength;
+	char         *SmemV;
+};
+static struct mp200_ntshw *ntshw;
+
+
+/********************************************************
+ *  Prototype declarations of local function            *
+ *******************************************************/
+/* ------------------ NTSC rgister set function ---------------------------- */
+#ifdef NOT_USE_FUNC
+static int           ntshw_set_control_upscale(int iSetUpscaleFlg);
+#endif /* NOT_USE_FUNC */
+static int           ntshw_set_control_outmode(int iSetOutmodeFlg);
+static int           ntshw_set_areaad(int iSetAreaFlg, unsigned long ulSetAddrY,
+ unsigned long ulSetAddrUV);
+static int           ntshw_set_hoffset(unsigned long ulSetOffset);
+static int           ntshw_set_register(int iSetOutmode);
+/* ------------------ NTSC rgister check function -------------------------- */
+#ifdef NOT_USE_FUNC
+static unsigned long ntshw_chk_intrawstatus(void);
+#endif /* NOT_USE_FUNC */
+/* ------------------ NTSC initialize function ------------------------------ */
+static int           ntshw_init_framebuf(void);
+static void          ntshw_exit_framebuf(void);
+static void         *ntshw_init_val(void);
+
+
+
+
+
+/* ------------------ NTSC H/W control function ----------------------------- */
+/******************************************************************************
+* MODULE   : ntshw_start
+* FUNCTION : start NTS(H/W)
+* RETURN   : none
+* NOTE     : none
+* CREATE   : 2008.10.29 M.Haguro
+* UPDATE   :
+******************************************************************************/
+void ntshw_start(int iStartFlg)
+{
+	if (iStartFlg == NTSHW_START) {
+		printk_dbg((_DEBUG_NTSHW & 0x01), "NTSHW_START\n");
+		ntshw_set_ntsout(NTS_NTSOUT_ENABLE_BLACK);
+	} else {
+		printk_dbg((_DEBUG_NTSHW & 0x01), "NTSHW_STOP\n");
+		ntshw_set_ntsout(NTS_NTSOUT_DISABLE);
+		while ((ntshw_chk_status() & NTS_STATUS_BIT)
+		 != NTS_STATUS_DISABLE) {
+			;
+		}
+	}
+}
+
+
+/******************************************************************************
+* MODULE   : ntshw_reset
+* FUNCTION : NTS(H/W) reset
+* RETURN   : none
+* NOTE     : none
+* CREATE   : 2008.10.29 M.Haguro
+* UPDATE   :
+******************************************************************************/
+void ntshw_reset(int iResetFlg)
+{
+	if (iResetFlg == NTSHW_RESET) {
+#if 0	/* Do not reset NTSC because it's unnecessary
+	   and because reseting before waiting NTS out is disabled
+	   causes BUS hung up.             (2009.05.07 Y.Utsuhara) */
+		/* Reset NTSC */
+		printk_dbg((_DEBUG_NTSHW & 0x01), "NTSHW_RESET\n");
+
+		/* clock auto control -> OFF    */
+		mp200_pmu_clkctrl_off(MP200_CLKCTRL_NTS);
+		mp200_pmu_clkctrl_off(MP200_CLKCTRL_NTSPCLK);
+		/* NTSC reset                   */
+		mp200_pmu_reset_device(MP200_RESETDEVICE_NTS);
+		/* clock demand                 */
+		mp200_pmu_close_clockgate(MP200_CLOCKGATE_NTS_PCLK);
+		mp200_pmu_close_clockgate(MP200_CLOCKGATE_NTS_CLK);
+#endif
+	} else {
+		/* UnReset NTSC */
+		printk_dbg((_DEBUG_NTSHW & 0x01), "NTSHW_UNRESET\n");
+
+		/* clock supply                 */
+		mp200_pmu_open_clockgate(MP200_CLOCKGATE_NTS_PCLK);
+		mp200_pmu_open_clockgate(MP200_CLOCKGATE_NTS_CLK);
+		/* clock auto control -> OFF    */
+		mp200_pmu_clkctrl_off(MP200_CLKCTRL_NTS);
+		mp200_pmu_clkctrl_off(MP200_CLKCTRL_NTSPCLK);
+		/* NTSC unreset                 */
+		mp200_pmu_unreset_device(MP200_RESETDEVICE_NTS);
+		/* clock auto control -> ON     */
+		mp200_pmu_clkctrl_on(MP200_CLKCTRL_NTS);
+		mp200_pmu_clkctrl_on(MP200_CLKCTRL_NTSPCLK);
+	}
+}
+
+
+/******************************************************************************
+* MODULE   : ntshw_module_reset
+* FUNCTION : NTS(H/W) reset
+* RETURN   : none
+* NOTE     : none
+* CREATE   : 2008.12.15 M.Haguro
+* UPDATE   :
+******************************************************************************/
+void ntshw_module_reset(int iResetFlg)
+{
+	if (iResetFlg == NTSHW_RESET) {
+		/* Reset NTSC Module */
+		printk_dbg((_DEBUG_NTSHW & 0x01), "NTSHW_RESET\n");
+		gpio_direction_output(GPIO_NTSC_RESET, 0);
+	} else {
+		/* UnReset NTSC Module */
+		printk_dbg((_DEBUG_NTSHW & 0x01), "NTSHW_UNRESET\n");
+		gpio_direction_output(GPIO_NTSC_RESET, 1);
+	}
+}
+
+
+/* ------------------ NTSC rgister set function ----------------------------- */
+/*****************************************************************************
+* MODULE   : ntshw_set_interruput
+* FUNCTION : enable NTSC VSYNC interrupt
+* RETURN   : none
+* NOTE     : none
+* CREATE   : 2008.10.29 M.Haguro
+ UPDATE   :
+******************************************************************************/
+void ntshw_set_interruput(int iIntFlg)
+{
+	if (iIntFlg == NTSHW_INTENSET) {
+		printk_dbg((_DEBUG_NTSHW & 0x01), "NTSHW_INTENSET\n");
+
+		/* Interuppt Enable Set */
+		writel(NTS_NTSVSEN_BIT, ntshw->NTSCMmioV + NTS_INTENSET);
+	} else if (iIntFlg == NTSHW_INTENCLR) {
+		printk_dbg((_DEBUG_NTSHW & 0x01), "NTSHW_INTENCLR\n");
+
+		/* Interrupt Enable Clear */
+		writel(NTS_INTENCLR_ALL_BIT, ntshw->NTSCMmioV + NTS_INTENCLR);
+	} else {
+		printk_dbg((_DEBUG_NTSHW & 0x01), "NTSHW_INTFFCLR\n");
+
+		/* Interrupt Status Clear */
+		writel(NTS_INTFFCLR_ALL_BIT, ntshw->NTSCMmioV + NTS_INTFFCLR);
+	}
+}
+
+
+/******************************************************************************
+* MODULE   : ntshw_set_framesel
+* FUNCTION : change NTSC display buffer
+* RETURN   : 0     : success
+*            other : fail
+* NOTE     : none
+* CREATE   : 2008.10.29 M.Haguro
+* UPDATE   :
+******************************************************************************/
+int ntshw_set_framesel(int iSetFrameNo)
+{
+	int iRet;
+	printk_dbg((_DEBUG_NTSHW & 0x01), "\n");
+
+	switch (iSetFrameNo) {
+	case NTS_AREASEL_BUFA:	/* frame change -> A       FALL THROUGH */
+	case NTS_AREASEL_BUFB:	/* frame change -> B       FALL THROUGH */
+	case NTS_AREASEL_BUFC:	/* frame change -> C */
+		writel(iSetFrameNo, ntshw->NTSCMmioV + NTS_FRAMESEL);
+		iRet = 0;
+		break;
+	case NTS_AREASEL_BUFDISABLE:	/* FALL THROUGH */
+	default:
+		iRet = -EINVAL;
+		break;
+	}
+	return iRet;
+}
+
+
+/******************************************************************************
+* MODULE   : ntshw_set_ntsout
+* FUNCTION : change NTSC output mode
+* RETURN   : 0     : success
+*            other : fail
+* NOTE     : none
+* CREATE   : 2008.10.29 M.Haguro
+* UPDATE   :
+******************************************************************************/
+int ntshw_set_ntsout(int iSetNtsoutFlg)
+{
+	int iRet;
+	printk_dbg((_DEBUG_NTSHW & 0x01), "(%d)\n", iSetNtsoutFlg);
+
+	switch (iSetNtsoutFlg) {
+	case NTS_NTSOUT_ENABLE:
+		/* ntsout -> external screen */ /* FALL THROUGH */
+		iRet = 0;
+		break;
+	case NTS_NTSOUT_ENABLE_BLUE:
+		/* ntsout -> blue screen     */ /* FALL THROUGH */
+		printk_dbg((_DEBUG_NTSHW & 0x40),
+		 "<set NTSOUT On (BlueBack)>\n");
+		iRet = 0;
+		break;
+	case NTS_NTSOUT_ENABLE_BLACK:
+		/* ntsout -> black screen    */ /* FALL THROUGH */
+		printk_dbg((_DEBUG_NTSHW & 0x40),
+		 "<set NTSOUT On (BlackBack)>\n");
+		iRet = 0;
+		break;
+	case NTS_NTSOUT_DISABLE:
+		/* ntsout -> stop            */
+		printk_dbg((_DEBUG_NTSHW & 0x40), "<set NTSOUT Off>\n");
+		iRet = 0;
+		break;
+	default:
+		iRet = -EINVAL;
+		break;
+	}
+	if (iRet == 0)
+		writel(iSetNtsoutFlg, ntshw->NTSCMmioV + NTS_OUT);
+
+	return iRet;
+}
+
+
+/******************************************************************************
+* MODULE   : ntshw_set_control_upscale
+* FUNCTION : change NTS_CONTROL upscale register
+* RETURN   : 0     : success
+*            other : fail
+* NOTE     : none
+* CREATE   : 2008.11.13 M.Haguro
+* UPDATE   :
+******************************************************************************/
+#ifdef NOT_USE_FUNC
+static int ntshw_set_control_upscale(int iSetUpscaleFlg)
+{
+	int iRet;
+	unsigned long ulRegVal32;
+
+	printk_dbg((_DEBUG_NTSHW & 0x01), "(%d)\n", iSetUpscaleFlg);
+
+	switch (iSetUpscaleFlg) {
+	case NTS_UPSCALE_ON:	/* upscale -> ON       FALL THROUGH */
+	case NTS_UPSCALE_OFF:	/* upscale -> OFF */
+		ulRegVal32 = readl(ntshw->NTSCMmioV + NTS_CONTROL);
+		ulRegVal32 = (ulRegVal32 & ~NTS_UPSCALE_BIT) | (iSetUpscaleFlg);
+		writel(ulRegVal32, ntshw->NTSCMmioV + NTS_CONTROL);
+		iRet = 0;
+		break;
+	default:
+		iRet = -EINVAL;
+		break;
+	}
+	return iRet;
+}
+#endif /* NOT_USE_FUNC */
+
+
+/******************************************************************************
+* MODULE   : ntshw_set_control_outmode
+* FUNCTION : change NTS_CONTROL outmode register
+* RETURN   : 0     : success
+*            other : fail
+* NOTE     : none
+* CREATE   : 2008.10.29 M.Haguro
+* UPDATE   :
+******************************************************************************/
+static int ntshw_set_control_outmode(int iSetOutmodeFlg)
+{
+	int iRet;
+	unsigned long ulRegVal32;
+
+	printk_dbg((_DEBUG_NTSHW & 0x01), "(%d)\n", iSetOutmodeFlg);
+
+	switch (iSetOutmodeFlg) {
+	case NTS_OUTMODE_PAL:	/* outmode -> PAL       FALL THROUGH */
+	case NTS_OUTMODE_NTSC:	/* outmode -> NTSC */
+		ulRegVal32 = readl(ntshw->NTSCMmioV + NTS_CONTROL);
+		ulRegVal32 = (ulRegVal32 & ~NTS_OUTMODE_BIT) | (iSetOutmodeFlg);
+		writel(ulRegVal32, ntshw->NTSCMmioV + NTS_CONTROL);
+		ntshw->Outmode =
+			iSetOutmodeFlg ? NTS_OUTPUT_PAL : NTS_OUTPUT_NTSC;
+		iRet = 0;
+		break;
+	default:
+		ntshw->Outmode = NTS_OUTPUT_DISABLE;
+		iRet = -EINVAL;
+		break;
+	}
+	return iRet;
+}
+
+
+/******************************************************************************
+* MODULE   : ntshw_set_areaad
+* FUNCTION : change NTS_AREAAD register
+* RETURN   : 0     : success
+*            other : fail
+* NOTE     : none
+* CREATE   : 2008.11.13 M.Haguro
+* UPDATE   :
+******************************************************************************/
+static int ntshw_set_areaad(int iSetAreaFlg, unsigned long ulSetAddrY,
+ unsigned long ulSetAddrUV)
+{
+	int iRet;
+	printk_dbg((_DEBUG_NTSHW & 0x01), "(%d) Y(%08lx) UV(%08lx)\n",
+	 iSetAreaFlg, ulSetAddrY, ulSetAddrUV);
+
+	switch (iSetAreaFlg) {
+	case NTS_AREAAD_A:	/* framebuffer area -> A       FALL THROUGH */
+	case NTS_AREAAD_B:	/* framebuffer area -> B       FALL THROUGH */
+	case NTS_AREAAD_C:	/* framebuffer area -> C */
+		writel(ulSetAddrY,  ntshw->NTSCMmioV + NTS_YAREAAD_A
+		 + iSetAreaFlg);
+		writel(ulSetAddrUV, ntshw->NTSCMmioV + NTS_UVAREAAD_A
+		 + iSetAreaFlg);
+		iRet = 0;
+		break;
+	default:
+		iRet = -EINVAL;
+		break;
+	}
+	return iRet;
+}
+
+
+/******************************************************************************
+* MODULE   : ntshw_set_hoffset
+* FUNCTION : change NTS_HOFFSET register
+* RETURN   : 0     : success
+* NOTE     : none
+* CREATE   : 2008.11.18 M.Haguro
+* UPDATE   :
+******************************************************************************/
+static int ntshw_set_hoffset(unsigned long ulSetOffset)
+{
+	printk_dbg((_DEBUG_NTSHW & 0x01), "(%lx)\n", ulSetOffset);
+
+	writel(ulSetOffset,  ntshw->NTSCMmioV + NTS_HOFFSET);
+	return 0;
+}
+
+
+/******************************************************************************
+* MODULE   : ntshw_set_register
+* FUNCTION : register initialize & restore
+* RETURN   :
+* NOTE     : none
+* CREATE   : 2009.3.11 M.Haguro
+* UPDATE   :
+******************************************************************************/
+static int ntshw_set_register(int iSetOutmode)
+{
+	int iRet;
+
+	/* disable NTSC interrupts      */
+	ntshw_set_interruput(NTSHW_INTFFCLR);
+	ntshw_set_interruput(NTSHW_INTENCLR);
+
+	/* set AreaAddress              */
+	if (ntshw_set_areaad(NTS_AREAAD_A, ntshw->NtscFrameA_Y,
+	 ntshw->NtscFrameA_UV)) {
+		iRet = -EINVAL;
+		goto fail_areaad_a;
+	}
+	if (ntshw_set_areaad(NTS_AREAAD_B, ntshw->NtscFrameB_Y,
+	 ntshw->NtscFrameB_UV)) {
+		iRet = -EINVAL;
+		goto fail_areaad_b;
+	}
+	if (ntshw_set_areaad(NTS_AREAAD_C, ntshw->NtscFrameC_Y,
+	 ntshw->NtscFrameC_UV)) {
+		iRet = -EINVAL;
+		goto fail_areaad_c;
+	}
+
+	/* set HOFFSET                  */
+	if (ntshw_set_hoffset(NTS_WIDTH)) {
+		iRet = -EINVAL;
+		goto fail_hoffset;
+	}
+
+	/* set output mode              */
+	switch (iSetOutmode) {
+	case NTS_OUTPUT_NTSC:
+		iRet = ntshw_set_control_outmode(NTS_OUTMODE_NTSC);
+		break;
+	case NTS_OUTPUT_PAL:
+		iRet = ntshw_set_control_outmode(NTS_OUTMODE_PAL);
+		break;
+	default:
+		iRet = -EINVAL;
+		goto fail_outputmode;
+	}
+	goto success;
+
+fail_outputmode:
+	ntshw_set_hoffset(0);
+fail_hoffset:
+	ntshw_set_areaad(NTS_AREAAD_C, 0, 0);
+fail_areaad_c:
+	ntshw_set_areaad(NTS_AREAAD_B, 0, 0);
+fail_areaad_b:
+	ntshw_set_areaad(NTS_AREAAD_A, 0, 0);
+fail_areaad_a:
+success:
+	return iRet;
+}
+
+
+/* ------------------ NTSC rgister check function -------------------------- */
+/******************************************************************************
+* MODULE   : ntshw_chk_control
+* FUNCTION : check NTSC control
+* RETURN   :
+* NOTE     : none
+* CREATE   : 2009.3.26 M.Haguro
+* UPDATE   :
+******************************************************************************/
+unsigned long ntshw_chk_control(void)
+{
+	printk_dbg((_DEBUG_NTSHW & 0x01), "\n");
+	/* check nts control */
+	return (unsigned long)readl(ntshw->NTSCMmioV + NTS_CONTROL);
+}
+
+
+/******************************************************************************
+* MODULE   : ntshw_chk_status
+* FUNCTION : check NTSC status
+* RETURN   :
+* NOTE     : none
+* CREATE   : 2008.10.29 M.Haguro
+* UPDATE   :
+******************************************************************************/
+unsigned long ntshw_chk_status(void)
+{
+	printk_dbg((_DEBUG_NTSHW & 0x01), "\n");
+	/* check nts status */
+	return (unsigned long)readl(ntshw->NTSCMmioV + NTS_STATUS);
+}
+
+
+/*****************************************************************************
+* MODULE   : ntshw_chk_framesel
+* FUNCTION : check NTSC framesel
+* RETURN   :
+* NOTE     : none
+* CREATE   : 2008.10.09 M.Haguro
+* UPDATE   :
+******************************************************************************/
+unsigned long ntshw_chk_framesel(void)
+{
+	printk_dbg((_DEBUG_NTSHW & 0x01), "\n");
+	/*  check framesel */
+	return (unsigned long)readl(ntshw->NTSCMmioV + NTS_FRAMESEL);
+}
+
+
+/*****************************************************************************
+* MODULE   : ntshw_chk_intstatus
+* FUNCTION : check NTSC interrupt status
+* RETURN   :
+* NOTE     : none
+* CREATE   : 2008.10.09 M.Haguro
+* UPDATE   :
+******************************************************************************/
+unsigned long ntshw_chk_intstatus(void)
+{
+	printk_dbg((_DEBUG_NTSHW & 0x01), "\n");
+	/*  check Interuppt Status */
+	return (unsigned long)readl(ntshw->NTSCMmioV + NTS_INTSTATUS);
+}
+
+
+/*****************************************************************************
+* MODULE   : ntshw_chk_intrawstatus
+* FUNCTION : check NTSC interrupt RAW status
+* RETURN   :
+* NOTE     : none
+* CREATE   : 2008.10.09 M.Haguro
+* UPDATE   :
+******************************************************************************/
+#ifdef NOT_USE_FUNC
+static unsigned long ntshw_chk_intrawstatus(void)
+{
+	printk_dbg((_DEBUG_NTSHW & 0x01), "\n");
+	/*  check Interuppt RAW Status */
+	return (unsigned long)readl(ntshw->NTSCMmioV + NTS_INTRAWSTATUS);
+}
+#endif /* NOT_USE_FUNC */
+
+
+/******************************************************************************
+* MODULE   : ntshw_save_reg
+* FUNCTION : save NTS(H/W) register data
+* RETURN   : none
+* NOTE     : none
+* CREATE   : 2008.10.29 M.Haguro
+* UPDATE   :
+******************************************************************************/
+void ntshw_save_reg(void)
+{
+	printk_dbg((_DEBUG_NTSHW & 0x01), "\n");
+}
+
+
+/******************************************************************************
+* MODULE   : ntshw_restore_reg
+* FUNCTION : restore NTS(H/W) register data
+* RETURN   : none
+* NOTE     : none
+* CREATE   : 2008.10.29 M.Haguro
+* UPDATE   :
+******************************************************************************/
+void ntshw_restore_reg(void)
+{
+	printk_dbg((_DEBUG_NTSHW & 0x01), "\n");
+	ntshw_set_register(ntshw->Outmode);
+}
+
+
+/* ------------------ NTSC initialize function ------------------------------ */
+/******************************************************************************
+* MODULE   : ntshw_reserve
+* FUNCTION : NTS(H/W) initialized
+* RETURN   : 0     : success
+*            other : fail
+* NOTE     : none
+* CREATE   : 2008.10.29 M.Haguro
+* UPDATE   :
+******************************************************************************/
+int ntshw_reserve(int iSetOutmode)
+{
+	int iRet = -1;
+	printk_dbg((_DEBUG_NTSHW & 0x01), "\n");
+
+	/********************************/
+	/* port / terminal switching    */
+	/********************************/
+	writel((readl(CHG_PINSEL_G64) & ~CHG_PINSEL_G64_NTS_BIT)
+	 | CHG_PINSEL_G64_NTS_INIT, CHG_PINSEL_G64);
+	writel((readl(CHG_PINSEL_G80) & ~CHG_PINSEL_G80_NTS_BIT)
+	 | CHG_PINSEL_G80_NTS_INIT, CHG_PINSEL_G80);
+
+	/********************************/
+	/* UnReset Module               */
+	/********************************/
+	ntshw_module_reset(NTSHW_UNRESET);
+
+	/********************************/
+	/* UnReset Device               */
+	/********************************/
+	ntshw_reset(NTSHW_UNRESET);
+
+	/********************************/
+	/* Set NTSC register             */
+	/********************************/
+	iRet = ntshw_set_register(iSetOutmode);
+
+	/********************************/
+	/* clear frame buffer           */
+	/********************************/
+	ntshw_clr_framebuf(NTS_DISP_FRAME_A);
+	ntshw_clr_framebuf(NTS_DISP_FRAME_B);
+
+	return iRet;
+}
+
+
+/******************************************************************************
+* MODULE   : ntshw_release
+* FUNCTION : NTS(H/W) initialized
+* RETURN   : none
+* NOTE     : none
+* CREATE   : 2008.10.29 M.Haguro
+* UPDATE   :
+******************************************************************************/
+void ntshw_release(void)
+{
+	/********************************/
+	/* Set NTSC register             */
+	/********************************/
+	ntshw_set_hoffset(0);
+	ntshw_set_areaad(NTS_AREAAD_A, 0, 0);
+	ntshw_set_areaad(NTS_AREAAD_B, 0, 0);
+	ntshw_set_areaad(NTS_AREAAD_C, 0, 0);
+
+	/********************************/
+	/* Reset Module/Device          */
+	/********************************/
+	ntshw_reset(NTSHW_RESET);
+	ntshw_module_reset(NTSHW_RESET);
+}
+
+
+/******************************************************************************
+* MODULE   : ntshw_clr_framebuf
+* FUNCTION : NTS(H/W) initialized
+* RETURN   : none
+* NOTE     : none
+* CREATE   : 2009.1.13 M.Haguro
+* UPDATE   :
+******************************************************************************/
+void ntshw_clr_framebuf(int iClrFrameNo)
+{
+	struct image_data buffdata;
+	printk_dbg((_DEBUG_NTSHW & 0x01), "\n");
+
+	buffdata.uiFormat      = DMA_FORMAT_YUV422_SEMI_PLANAR;
+	buffdata.uiX           = 0;
+	buffdata.uiY           = 0;
+	buffdata.uiWidth       = NTS_WIDTH;
+	buffdata.uiHeight      = NTS_HEIGHT;
+	buffdata.uiScreenWidth = NTS_WIDTH;
+	buffdata.uiEndian      = IMG_PEL_ENDIAN_OUT_ENDI_LITTLE;
+
+	if (iClrFrameNo == NTS_DISP_FRAME_A) {
+		buffdata.ulPhysAddrYRGB = ntshw->NtscFrameA_Y;
+		buffdata.ulPhysAddrUV   = ntshw->NtscFrameA_UV;
+	} else { /* NTS_DISP_FRAME_B */
+		buffdata.ulPhysAddrYRGB = ntshw->NtscFrameB_Y;
+		buffdata.ulPhysAddrUV   = ntshw->NtscFrameB_UV;
+	}
+	buffdata.ulPhysAddrV = 0;
+
+	/* memory clear. use IPU-GDMA */
+	ntsipu_clr_framebuf(&buffdata);
+}
+
+
+/******************************************************************************
+* MODULE   : ntshw_init_framebuf
+* FUNCTION : NTS(H/W) initialized
+* RETURN   : 0     : success
+*            other : fail
+* NOTE     : none
+* CREATE   : 2008.11.17 M.Haguro
+* UPDATE   :
+******************************************************************************/
+static int ntshw_init_framebuf(void)
+{
+	int iRet = 0;
+
+	printk_dbg((_DEBUG_NTSHW & 0x01), "\n");
+
+	ntshw->SmemV = ioremap_nocache(ntshw->Smem, ntshw->SmemLength);
+	if (!ntshw->SmemV) {
+		printk_wrn("cannot ioremap_nocache smem\n");
+		iRet = -ENOMEM;
+		goto fail_ioremap;
+	}
+	ntshw->NtscFrameAV = ntshw->SmemV + NTSCFRAME_A_OFFSET;
+	ntshw->NtscFrameBV = ntshw->SmemV + NTSCFRAME_B_OFFSET;
+	printk_dbg((_DEBUG_NTSHW),
+	 "NtscFrameA(0x%lx)  NtscFrameAV(0x%p)  NtscFrameLength (0x%lx)\n",
+	 ntshw->NtscFrameA_Y, ntshw->NtscFrameAV, ntshw->NtscFrameLength);
+	printk_dbg((_DEBUG_NTSHW),
+	 "NtscFrameB(0x%lx)  NtscFrameBV(0x%p)  NtscFrameLength (0x%lx)\n",
+	 ntshw->NtscFrameB_Y, ntshw->NtscFrameBV, ntshw->NtscFrameLength);
+
+	iRet = 0;
+	goto success;
+
+fail_ioremap:
+success:
+	return iRet;
+}
+
+
+/******************************************************************************
+* MODULE   : ntshw_exit_framebuf
+* FUNCTION : NTS(H/W) initialized
+* RETURN   : none
+* NOTE     : none
+* CREATE   : 2008.11.17 M.Haguro
+* UPDATE   :
+******************************************************************************/
+static void ntshw_exit_framebuf(void)
+{
+	printk_dbg((_DEBUG_NTSHW & 0x01), "\n");
+
+	ntshw_set_areaad(NTS_AREAAD_A, 0, 0);
+	ntshw_set_areaad(NTS_AREAAD_B, 0, 0);
+	ntshw_set_areaad(NTS_AREAAD_C, 0, 0);
+	ntshw_set_hoffset(0);
+
+	if (ntshw->NtscFrameAV)
+		iounmap(ntshw->NtscFrameAV);
+	if (ntshw->NtscFrameBV)
+		iounmap(ntshw->NtscFrameBV);
+	if (ntshw->SmemV)
+		iounmap(ntshw->SmemV);
+
+	ntshw->NtscFrameAV = NULL;
+	ntshw->NtscFrameBV = NULL;
+	ntshw->SmemV     = NULL;
+}
+
+
+/******************************************************************************
+* MODULE   : ntshw_init_val
+* FUNCTION : NTS(H/W) initialized
+* RETURN   : none
+* NOTE     : none
+* CREATE   : 2008.11.17 M.Haguro
+* UPDATE   :
+******************************************************************************/
+static void *ntshw_init_val(void)
+{
+	void *alloc_val;
+
+	printk_dbg((_DEBUG_NTSHW & 0x01), "\n");
+
+	alloc_val = kmalloc(sizeof(struct mp200_ntshw), GFP_KERNEL);
+	if (!alloc_val) {
+		;
+	} else {
+		memset(alloc_val, 0, sizeof(struct mp200_ntshw));
+
+		/* NTSC MMIO */
+		((struct mp200_ntshw *)alloc_val)->NTSCMmio        = NTSC_BASE;
+		((struct mp200_ntshw *)alloc_val)->NTSCMmioLength  = NTSC_SIZE;
+		((struct mp200_ntshw *)alloc_val)->NTSCMmioV       = NULL;
+
+		/* NTSC framebuffer */
+		((struct mp200_ntshw *)alloc_val)->NtscFrameA_Y    =
+			SMEM_START + NTSCFRAME_A_OFFSET;
+		((struct mp200_ntshw *)alloc_val)->NtscFrameA_UV   =
+			((struct mp200_ntshw *)alloc_val)->NtscFrameA_Y +
+			NTS_WIDTH * NTS_HEIGHT;
+		((struct mp200_ntshw *)alloc_val)->NtscFrameB_Y    =
+			SMEM_START + NTSCFRAME_B_OFFSET;
+		((struct mp200_ntshw *)alloc_val)->NtscFrameB_UV   =
+			((struct mp200_ntshw *)alloc_val)->NtscFrameB_Y +
+			NTS_WIDTH * NTS_HEIGHT;
+		((struct mp200_ntshw *)alloc_val)->NtscFrameC_Y    = 0l;
+		((struct mp200_ntshw *)alloc_val)->NtscFrameC_UV   = 0l;
+		((struct mp200_ntshw *)alloc_val)->NtscFrameLength =
+			NTSCFRAME_LENGTH;
+		((struct mp200_ntshw *)alloc_val)->NtscFrameBV     = NULL;
+		((struct mp200_ntshw *)alloc_val)->NtscFrameAV     = NULL;
+
+		/* Smem (common memory to LCD) */
+		((struct mp200_ntshw *)alloc_val)->Smem            = SMEM_START;
+		((struct mp200_ntshw *)alloc_val)->SmemLength      =
+			SMEM_LENGTH;
+		((struct mp200_ntshw *)alloc_val)->SmemV           = NULL;
+	}
+	return alloc_val;
+}
+
+
+/******************************************************************************
+* MODULE   : ntshw_init
+* FUNCTION : NTS(H/W) initialized
+* RETURN   : 0     : success
+*            other : fail
+* NOTE     : none
+* CREATE   : 2008.10.29 M.Haguro
+* UPDATE   :
+******************************************************************************/
+int ntshw_init(void)
+{
+	int iRet = 0;
+
+	printk_dbg((_DEBUG_NTSHW & 0x01), "\n");
+
+	ntshw = (struct mp200_ntshw *)ntshw_init_val();
+	if (!ntshw) {
+		printk_wrn("failed ntshw_init_val\n");
+		goto fail_alloc_val;
+	}
+
+	/* reserve NTSMmio */
+#ifdef IO_ADDRESS
+	ntshw->NTSCMmioV = (char *)IO_ADDRESS(ntshw->NTSCMmio);
+#else
+	if (!request_mem_region(NTSCMmio, NTSCMmioLength, DEV_NAME)) {
+		printk_wrn("cannnot request NTSMmio\n");
+		goto fail_mmio_reserve;
+	}
+	ntshw->NTSCMmioV = ioremap_nocache(NTSCMmio, NTSCMmioLength);
+	if (!ntshw->NTSCMmioV) {
+		printk_wrn("cannot ioremap_nocache NTSMmio\n");
+		goto fail_mmio_ioremap;
+	}
+#endif /* IO_ADDRESS */
+	printk_dbg((_DEBUG_NTSHW),
+	 "NTSCMmio(0x%08lx)  NTSCMmioV(0x%p)  NTSCMmioLength(0x%lx)\n",
+	 ntshw->NTSCMmio, ntshw->NTSCMmioV, ntshw->NTSCMmioLength);
+
+	/* init framebuffer */
+	if (ntshw_init_framebuf()) {
+		printk_wrn("failed ntshw_init_framebuf\n");
+		goto fail_init_framebuf;
+	}
+	goto success;
+
+fail_init_framebuf:
+#ifndef IO_ADDRESS
+	iounmap(ntshw->NTSCMmioV);
+fail_mmio_ioremap:
+	release_mem_region(ntshw->NTSCMmio, ntshw->NTSCMmioLength);
+fail_mmio_reserve:
+#endif /* IO_ADDRESS */
+	kfree(ntshw);	/* NULL check is inside. */
+fail_alloc_val:
+	iRet = -ENOMEM;
+
+success:
+	return iRet;
+}
+
+
+/******************************************************************************
+* MODULE   : ntshw_exit
+* FUNCTION : NTS(H/W) initialized
+* RETURN   : none
+* NOTE     : none
+* CREATE   : 2008.11.13 M.Haguro
+* UPDATE   :
+******************************************************************************/
+void ntshw_exit(void)
+{
+	printk_dbg((_DEBUG_NTSHW & 0x01), "\n");
+
+	/* disable NTS_OUT */
+	ntshw_start(NTSHW_STOP);
+
+	/* disable NTSC interrupts */
+	ntshw_set_interruput(NTSHW_INTFFCLR);
+	ntshw_set_interruput(NTSHW_INTENCLR);
+
+	/* Reset Module/Device */
+	ntshw_reset(NTSHW_RESET);
+	ntshw_module_reset(NTSHW_RESET);
+
+	if (ntshw) {
+		ntshw_exit_framebuf();
+
+#ifndef IO_ADDRESS
+		iounmap(ntshw->NTSCMmioV);
+		release_mem_region(ntshw->NTSCMmio, ntshw->NTSCMmioLength);
+#endif /* IO_ADDRESS */
+
+		memset(ntshw, 0, sizeof(struct mp200_ntshw));
+		kfree(ntshw);
+	}
+	ntshw = NULL;
+}
+
+
diff --git a/drivers/video/mp200/nts/mp200_ntshw.h b/drivers/video/mp200/nts/mp200_ntshw.h
new file mode 100644
index 0000000..04c37ca
--- /dev/null
+++ b/drivers/video/mp200/nts/mp200_ntshw.h
@@ -0,0 +1,77 @@
+/*
+ * File Name       : /drivers/video/mp200/nts/mp200_ntshw.h
+ * Function        : NTSC Driver corresponding to V4L2 (H/W Control)
+ * Release Version : Ver 1.01
+ * Release Date    : 2009/10/15
+ *
+ * Copyright (C) NEC Electronics Corporation 2008,2009
+ *
+ *
+ * This program is free software;you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by Free Softwere
+ * Foundation; either version 2 of License, or (at your option) any later
+ * version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warrnty of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
+ * details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; If not, write to the Free Software Foundation, Inc., 59 Temple
+ * Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+
+#ifndef _MP200_NTSHW_H_
+#define _MP200_NTSHW_H_
+
+
+
+/********************************************************
+ *  Variables                                           *
+ *******************************************************/
+
+
+/********************************************************
+ *  Prototype declarations of function                  *
+ *******************************************************/
+/* ------------------ NTSC H/W control function ---------------------------- */
+extern void          ntshw_start(int iStartFlg);
+#define NTSHW_START 0
+#define NTSHW_STOP  1
+
+extern void          ntshw_reset(int iResetFlg);
+#define NTSHW_RESET   0
+#define NTSHW_UNRESET 1
+
+extern void          ntshw_module_reset(int iResetFlg);
+
+
+/* ------------------ NTSC rgister set function ---------------------------- */
+extern void          ntshw_set_interruput(int iIntFlg);
+#define NTSHW_INTENSET 0
+#define NTSHW_INTENCLR 1
+#define NTSHW_INTFFCLR 2
+extern int           ntshw_set_framesel(int iSetFrameNo);
+extern int           ntshw_set_ntsout(int iSetNtsoutFlg);
+/* ------------------ NTSC rgister check function -------------------------- */
+extern unsigned long ntshw_chk_control(void);
+extern unsigned long ntshw_chk_status(void);
+extern unsigned long ntshw_chk_framesel(void);
+extern unsigned long ntshw_chk_intstatus(void);
+/* ------------------ NTSC rgister backup function ------------------------- */
+extern void          ntshw_save_reg(void);
+extern void          ntshw_restore_reg(void);
+/* ------------------ NTSC initialize function ----------------------------- */
+extern int           ntshw_reserve(int iSetOutmode);
+extern void          ntshw_release(void);
+extern void          ntshw_clr_framebuf(int iClrFrameNo);
+extern int           ntshw_init(void);
+extern void          ntshw_exit(void);
+
+
+
+#endif /* _MP200_NTSHW_H_ */
+
diff --git a/drivers/video/mp200/nts/mp200_ntsipu.c b/drivers/video/mp200/nts/mp200_ntsipu.c
new file mode 100644
index 0000000..4c1b703
--- /dev/null
+++ b/drivers/video/mp200/nts/mp200_ntsipu.c
@@ -0,0 +1,1917 @@
+/*
+ * File Name       : /drivers/video/mp200/nts/mp200_ntsipu.c
+ * Function        : NTSC Driver corresponding to V4L2 (IPU Control)
+ * Release Version : Ver 1.01
+ * Release Date    : 2009/10/19
+ *
+ * Copyright (C) NEC Electronics Corporation 2009
+ *
+ *
+ * This program is free software;you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by Free Softwere
+ * Foundation; either version 2 of License, or (at your option) any later
+ * version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warrnty of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
+ * details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; If not, write to the Free Software Foundation, Inc., 59 Temple
+ * Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+
+/********************************************************
+ *  Include Files                                       *
+ *******************************************************/
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/version.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/tty.h>
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/fb.h>
+#include <linux/init.h>
+#include <linux/ioport.h>
+#include <linux/timer.h>
+#include <linux/sched.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/uaccess.h>
+
+#if defined(CONFIG_PM) || defined(CONFIG_DPM)
+#include <mach/pm.h>
+#endif /* CONFIG_PM || CONFIG_DPM */
+
+#include <mach/hardware.h>
+#include <mach/irqs.h>
+#include <mach/pmu.h>
+#include <mach/em1_mem.h>
+#include <mach/ipu.h>
+#include <mach/img.h>
+#include <mach/gdma.h>
+
+#include "../mp200_common.h"
+#include "ntsc.h"
+#include "mp200_nts_common.h"
+#include "mp200_nts.h"
+#include "mp200_ntshw.h"
+#include "mp200_ntsipu.h"
+
+
+/********************************************************
+ *  Definitions                                         *
+ *******************************************************/
+#define DEV_NAME "mp200_ntsipu"
+#define NTSC_ERRATA 1
+
+
+/********************************************************
+ *  debug parameters                                    *
+ *******************************************************/
+#define _DEBUG_NTSIPU  0x00 /* 00008421(bit) */
+			    /* 0x01: debug function in
+			     * 0x02: debug function out
+			     * 0x40: debug FBIOBLANK
+			     * 0x80: debug semafore
+			     */
+
+
+#define printk_err(fmt, arg...) \
+	do {                     \
+		printk(KERN_ERR DEV_NAME ": %s: " fmt, __func__, ## arg); \
+	} while (0)
+
+#define printk_wrn(fmt, arg...) \
+	do {                     \
+		printk(KERN_WARNING DEV_NAME ": %s: " fmt, __func__, ## arg); \
+	} while (0)
+
+#define printk_info(fmt, arg...) \
+	do {                      \
+		printk(KERN_INFO DEV_NAME ": " fmt, ## arg); \
+	} while (0)
+
+#if _DEBUG_NTSIPU
+#define printk_dbg(level, fmt, arg...) \
+	do {                            \
+		if (level > 0) \
+			printk(KERN_DEBUG DEV_NAME ": %s: " fmt, \
+				__func__, ## arg); \
+	} while (0)
+#else
+#define printk_dbg(level, fmt, arg...) \
+	;
+#endif
+
+
+/********************************************************
+ *  Macros                                              *
+ *******************************************************/
+/* request data. for IPU driver */
+#define IPU_REQUEST_MAX 2
+
+#define IpuRequest(DATA, REG)                                              \
+do {                                                                       \
+	ntsipu->ipu_request[index]->ipu_reg_info[index_req].reg  = (REG);  \
+	ntsipu->ipu_request[index]->ipu_reg_info[index_req].data = (DATA); \
+	index_req++;                                                       \
+} while (0)
+
+
+/********************************************************
+ *  Structure                                           *
+ *******************************************************/
+enum old_frame_max {
+	OLD_FRAME_A = 0,
+	OLD_FRAME_B = 1,
+	OLD_MAX     = 2,
+};
+
+/* request data. from fb/V4L2 driver */
+enum img_max {
+	IMG_SRC_B = 0,
+	IMG_SRC_F = 1,
+	IMG_DST   = 2,
+	IMG_MAX   = 3,
+};
+
+enum gdma_max {
+	GDMA_FILL1 = 0,
+	GDMA_MAX   = 1,
+};
+
+/* request data. for IPU driver */
+struct mp200_ntsipu {
+	struct mp200_nts_dev *ntsc;
+	wait_queue_head_t     wait_gdma;
+	int                   gdma_complete;
+
+	struct image_data    *old[OLD_MAX];
+	struct image_data    *img[IMG_MAX];
+	struct image_data    *gdma[GDMA_MAX];
+	/* queue info for IPU */
+	struct mp200_ipu_req *ipu_request[IPU_REQUEST_MAX];
+};
+static struct mp200_ntsipu *ntsipu;
+
+
+/********************************************************
+ *  Prototype declarations of local function                  *
+ *******************************************************/
+/* ------------------ private function < IMG > ------------------------------ */
+static void          ntsipu_callback_yuv422(unsigned long sequence, int flag);
+static void          ntsipu_callback_yuv422_bottom(void);
+static void          ntsipu_callback_yuv422_return_ntsc(void);
+static void          ntsipu_callback_rgb565(unsigned long sequence, int flag);
+static int           ntsipu_chk_ipuimg(void);
+static int           ntsipu_chk_ipuimg_bottom(void);
+static unsigned long ntsipu_set_imgmode(void);
+static unsigned long ntsipu_set_format(void);
+static int           ntsipu_set_ipuimg(int index, int img_mode);
+/* ------------------ private function < GDMA > ----------------------------- */
+static void          ntsipu_callback_ipugdma(unsigned long sequence, int flag);
+static int           ntsipu_chk_ipugdma(void);
+static int           ntsipu_gdma_request(int index);
+static int           ntsipu_set_ipugdma(int index);
+
+
+#ifdef NTSC_ERRATA
+#include <mach/dma.h>
+#define NTSC_DMA_CALLBACK_COMP 0x01
+
+struct mp200_ntsc_errata{
+	int               ntsc_upscale;
+	int               ntsc_dma_stat;
+	wait_queue_head_t queue_p;
+
+	dma_regs_t       *dma_regs;
+	dma_addr_t        srcV;
+	dma_addr_t        destV;
+
+	struct workqueue_struct *ntsipu_workqueue;
+	struct work_struct       wk_dma_request_bottom;
+};
+static struct mp200_ntsc_errata *errata;
+
+static int  ntsipu_dma_request(void);
+static void ntsipu_dma_request_bottom(struct work_struct *num);
+
+static void ntsipu_dma_callback(void *data, int intsts, int intrawsts)
+{
+	errata->ntsc_dma_stat = NTSC_DMA_CALLBACK_COMP;
+	wake_up_interruptible(&errata->queue_p);
+}
+#endif /* NTSC_ERRATA */
+
+
+/* ------------------ public function -------------------------------------- */
+/******************************************************************************
+* MODULE   : ntsipu_initialize
+* FUNCTION :
+* RETURN   :        0 : success
+	   : -ENOEMEM : failed
+* NOTE     : none
+* CREATE   : 2008.11.17 M.Haguro
+* UPDATE   :
+******************************************************************************/
+int ntsipu_initialize(struct mp200_nts_dev *ntsc)
+{
+	int i, iRet;
+
+	printk_dbg((_DEBUG_NTSIPU & 0x01), "\n");
+
+	/* allocate request data. from fb/V4L2 driver */
+	ntsipu = kmalloc(sizeof(struct mp200_ntsipu), GFP_KERNEL);
+	if (!ntsipu)
+		goto fail_alloc_mem;
+
+	memset(ntsipu, 0, sizeof(struct mp200_ntsipu));
+	ntsipu->ntsc = ntsc;
+
+	/* allocate old request data. from fb/V4L2 driver */
+	for (i = 0; i < OLD_MAX; i++) {
+		ntsipu->old[i] = kmalloc(sizeof(struct image_data), GFP_KERNEL);
+		if (!ntsipu->old[i])
+			goto fail_alloc_mem;
+
+		memset(ntsipu->old[i], 0, sizeof(struct image_data));
+	}
+	/* allocate request data. from fb/V4L2 driver */
+	for (i = IMG_SRC_B; i < IMG_MAX; i++) {
+		ntsipu->img[i] = kmalloc(sizeof(struct image_data), GFP_KERNEL);
+		if (!ntsipu->img[i])
+			goto fail_alloc_mem;
+
+		memset(ntsipu->img[i], 0, sizeof(struct image_data));
+	}
+	/* allocate request data. from fb/V4L2 driver */
+	for (i = GDMA_FILL1; i < GDMA_MAX; i++) {
+		ntsipu->gdma[i] = kmalloc(sizeof(struct image_data),
+		 GFP_KERNEL);
+		if (!ntsipu->gdma[i])
+			goto fail_alloc_mem;
+
+		memset(ntsipu->gdma[i], 0, sizeof(struct image_data));
+	}
+
+	/* allocate request data. for IPU-IMG driver */
+	for (i = 0; i < IPU_REQUEST_MAX; i++) {
+		ntsipu->ipu_request[i] = kmalloc(MAX_SIZE_MP200_IPU_REQ,
+		 GFP_KERNEL);
+		if (!ntsipu->ipu_request[i])
+			goto fail_alloc_mem;
+
+		memset(ntsipu->ipu_request[i], 0, MAX_SIZE_MP200_IPU_REQ);
+	}
+
+#ifdef NTSC_ERRATA
+	errata = kmalloc(sizeof(struct mp200_ntsc_errata), GFP_KERNEL);
+	if (!errata)
+		goto fail_alloc_mem;
+
+	memset(errata, 0, sizeof(struct mp200_ntsc_errata));
+
+	mp200_request_dma(MP200_DMAC_M2M_ACPU_LCH3, "NTSC M2M",
+	 ntsipu_dma_callback, (void *)0, &errata->dma_regs);
+	init_waitqueue_head(&errata->queue_p);
+
+	/* workqueue initialize */
+	errata->ntsipu_workqueue = create_singlethread_workqueue(DEV_NAME);
+	INIT_WORK(&errata->wk_dma_request_bottom, ntsipu_dma_request_bottom);
+#endif /* NTSC_ERRATA */
+
+	init_waitqueue_head(&ntsipu->wait_gdma);
+	iRet = 0;
+	goto success;
+
+fail_alloc_mem:
+	printk_wrn("memory allocate err");
+	ntsipu_finitialize();
+	iRet = -ENOMEM;
+success:
+	return iRet;
+}
+
+
+/******************************************************************************
+* MODULE   : ntsipu_finitialize
+* FUNCTION :
+* RETURN   : none
+* NOTE     : none
+* CREATE   : 2008.11.17 M.Haguro
+* UPDATE   :
+******************************************************************************/
+void ntsipu_finitialize(void)
+{
+	printk_dbg((_DEBUG_NTSIPU & 0x01), "\n");
+
+#ifdef NTSC_ERRATA
+	if (errata) {
+		/* workqueue uninitialize */
+		destroy_workqueue(errata->ntsipu_workqueue);
+		memset(errata, 0, sizeof(struct mp200_ntsc_errata));
+		kfree(errata);
+	}
+#endif /* NTSC_ERRATA */
+
+	if (ntsipu) {
+		int i;
+
+		/* free request data. for IPU driver */
+		for (i = 0; i < IPU_REQUEST_MAX; i++) {
+			if (ntsipu->ipu_request[i]) {
+				memset(ntsipu->ipu_request[i], 0,
+				 sizeof(MAX_SIZE_MP200_IPU_REQ));
+				kfree(ntsipu->ipu_request[i]);
+			}
+		}
+		/* free request data. from fb/V4L2 driver */
+		for (i = GDMA_FILL1; i < GDMA_MAX; i++) {
+			if (ntsipu->gdma[i]) {
+				memset(ntsipu->gdma[i], 0,
+				 sizeof(struct image_data));
+				kfree(ntsipu->gdma[i]);
+			}
+		}
+		/* free request data. from fb/V4L2 driver */
+		for (i = IMG_SRC_B; i < IMG_MAX; i++) {
+			if (ntsipu->img[i]) {
+				memset(ntsipu->img[i], 0,
+				 sizeof(struct image_data));
+				kfree(ntsipu->img[i]);
+			}
+		}
+		/* allocate old request data. from fb/V4L2 driver */
+		for (i = 0; i < OLD_MAX; i++) {
+			if (ntsipu->old[i]) {
+				memset(ntsipu->old[i], 0,
+				 sizeof(struct image_data));
+				kfree(ntsipu->old[i]);
+			}
+		}
+		memset(ntsipu, 0, sizeof(struct mp200_ntsipu));
+		kfree(ntsipu);
+	}
+}
+
+
+/*****************************************************************************
+* MODULE   : ntsipu_clr_framebuf
+* FUNCTION :
+* RETURN   : -
+* NOTE     :
+* CREATE   : 2009.1.22 M.Haguro
+* UPDATE   :
+******************************************************************************/
+int ntsipu_clr_framebuf(struct image_data *buff)
+{
+	int index = 0;
+
+	memcpy(ntsipu->gdma[index], buff, sizeof(struct image_data));
+
+	return ntsipu_gdma_request(index);
+}
+
+
+/******************************************************************************
+* MODULE   : ntsipu_img_request
+* FUNCTION : changing frame and callback to fb and v4l2
+* RETURN   :       0 : success
+	   : -EINVAL : failed
+* NOTE     : none
+* CREATE   : 2008.12.08 M.Haguro
+* UPDATE   :
+******************************************************************************/
+int ntsipu_img_request(void)
+{
+	int i, index = 0;
+	int iRet;
+
+	printk_dbg((_DEBUG_NTSIPU & 0x01), "\n");
+	ntsipu->ntsc->img_complete = 0;
+
+#ifdef NTSC_ERRATA
+	errata->ntsc_upscale = (int)(ntshw_chk_control() & NTS_UPSCALE_BIT);
+#endif /* NTSC_ERRATA */
+
+	for (i = IMG_SRC_B; i < IMG_MAX; i++)
+		memset(ntsipu->img[i], 0, sizeof(struct image_data));
+
+	for (i = 0; i < IPU_REQUEST_MAX; i++) {
+		memset(ntsipu->ipu_request[i], 0,
+		 sizeof(MAX_SIZE_MP200_IPU_REQ));
+	}
+
+	/* 1st request */
+	iRet = ntsipu_chk_ipuimg();
+	if (iRet != -EINVAL) {
+		iRet = ntsipu_set_ipuimg(index, iRet);
+		if (iRet) {
+			printk_dbg((_DEBUG_NTSIPU & 0x02), "(%d) error\n",
+			 __LINE__);
+			goto failed;
+		}
+
+		ntsipu->ipu_request[index]->callback  = ntsipu_callback_yuv422;
+		ntsipu->ipu_request[index]->ipu_hw_func = IPU_HW_FUNC_IMG;
+		ntsipu->ipu_request[index]->data = 0l;
+		index++;
+
+		/* 2nd request */
+		iRet = ntsipu_chk_ipuimg_bottom();
+		if (iRet != -EINVAL) {
+			iRet = ntsipu_set_ipuimg(index, iRet);
+			if (iRet) {
+				printk_dbg((_DEBUG_NTSIPU & 0x02),
+				 "(%d) error\n", __LINE__);
+				goto failed;
+			}
+
+			ntsipu->ipu_request[index - 1]->callback =
+				ntsipu_callback_rgb565;
+			ntsipu->ipu_request[index]->callback     =
+				ntsipu_callback_yuv422;
+			ntsipu->ipu_request[index]->ipu_hw_func  =
+				IPU_HW_FUNC_IMG;
+			ntsipu->ipu_request[index]->data         = 0l;
+			index++;
+		}
+		iRet = 0;
+
+		for (i = 0; i < index; i++) {
+			/* request IPU */
+			iRet = mp200_ipu_regist(
+			(struct mp200_ipu_req *)(ntsipu->ipu_request[i]));
+			if (iRet) {
+				printk_dbg((_DEBUG_NTSIPU & 0x02),
+				 "ipu_regist(%d)\n", iRet);
+				goto failed;
+			}
+		}
+	}
+failed:
+	return iRet;
+}
+
+
+/* ------------------ private function < IMG > ------------------------------ */
+#ifdef NTSC_ERRATA
+/******************************************************************************
+* MODULE   : ntsipu_dma_request
+* FUNCTION :
+* RETURN   :
+* NOTE     :
+* CREATE   : 2009.3.24 M.Haguro
+* UPDATE   :
+******************************************************************************/
+static int ntsipu_dma_request(void)
+{
+	int ret;
+	printk_dbg((_DEBUG_NTSIPU & 0x01), "\n");
+
+	if (ntsipu->ntsc->iFrameNoNow == NTS_DISP_FRAME_A)
+		errata->srcV = errata->destV =
+			SMEM_START + NTSCFRAME_B_OFFSET +
+			(ntsipu->img[IMG_DST]->uiY) *
+			ntsipu->img[IMG_DST]->uiScreenWidth;
+	else
+		errata->srcV =
+			errata->destV = SMEM_START + NTSCFRAME_A_OFFSET +
+			(ntsipu->img[IMG_DST]->uiY) *
+			ntsipu->img[IMG_DST]->uiScreenWidth;
+
+	if (ntsipu->img[IMG_DST]->uiY % 2) {
+		errata->srcV  += NTSC_WIDTH;
+		errata->destV -= NTSC_WIDTH;
+	} else {
+		errata->srcV  += NTSC_WIDTH*2;
+		errata->destV += 0;
+	}
+
+	/* copy Y plane data */
+	errata->dma_regs->aadd = errata->srcV;
+	errata->dma_regs->badd = errata->destV;
+	errata->dma_regs->aoff = NTSC_WIDTH;
+	errata->dma_regs->boff = NTSC_WIDTH;
+	errata->dma_regs->size = NTSC_WIDTH;
+	errata->dma_regs->leng =
+		NTSC_WIDTH * (ntsipu->img[IMG_DST]->uiHeight/2 + 1);
+	errata->dma_regs->mode = MP200_DMAC_DEFMODE_32BIT;
+	errata->ntsc_dma_stat  = 0;
+	ret = mp200_start_dma(MP200_DMAC_M2M_ACPU_LCH3, errata->srcV, 0,
+	 errata->destV, MP200_DMAC_INT_ERROR_EN | MP200_DMAC_INT_LENG_EN);
+	if (ret != 0) {
+		unsigned long flags;
+		spin_lock_irqsave(&ntsipu->ntsc->lock_callback, flags);
+		printk(KERN_INFO
+		 "[Error]ntsipu_callback_yuv422 : mp200_start_dma(Y Plane)\n");
+		ntsipu_callback_yuv422_return_ntsc();
+		spin_unlock_irqrestore(&ntsipu->ntsc->lock_callback, flags);
+	} else {
+		queue_work(errata->ntsipu_workqueue,
+		 &errata->wk_dma_request_bottom);
+	}
+	return ret;
+}
+
+
+static void ntsipu_dma_request_bottom(struct work_struct *num)
+{
+	int ret;
+	printk_dbg((_DEBUG_NTSIPU & 0x01), "\n");
+
+	wait_event_interruptible(errata->queue_p,
+	 (errata->ntsc_dma_stat == NTSC_DMA_CALLBACK_COMP));
+
+	/* copy UV interleave data */
+	errata->srcV           = errata->srcV  + NTS_WIDTH * NTS_HEIGHT;
+	errata->destV          = errata->destV + NTS_WIDTH * NTS_HEIGHT;
+	errata->dma_regs->aadd = errata->srcV;
+	errata->dma_regs->badd = errata->destV;
+	errata->ntsc_dma_stat  = 0;
+	ret = mp200_start_dma(MP200_DMAC_M2M_ACPU_LCH3, errata->srcV, 0,
+	 errata->destV, MP200_DMAC_INT_ERROR_EN | MP200_DMAC_INT_LENG_EN);
+	if (ret != 0) {
+		unsigned long flags;
+		spin_lock_irqsave(&ntsipu->ntsc->lock_callback, flags);
+		printk(KERN_INFO
+		 "[Error]ntsipu_callback_yuv422 : mp200_start_dma(UV Plane)\n");
+		ntsipu_callback_yuv422_return_ntsc();
+		spin_unlock_irqrestore(&ntsipu->ntsc->lock_callback, flags);
+	} else {
+		wait_event_interruptible(errata->queue_p,
+		 (errata->ntsc_dma_stat == NTSC_DMA_CALLBACK_COMP));
+
+		ntsipu_callback_yuv422_bottom();
+	}
+}
+#endif /* NTSC_ERRATA */
+
+
+/******************************************************************************
+* MODULE   : ntsipu_callback_yuv422
+* FUNCTION : changing frame and callback to fb and v4l2
+* RETURN   : none
+* NOTE     : none
+* CREATE   : 2008.11.14 M.Haguro
+* UPDATE   :
+******************************************************************************/
+static void ntsipu_callback_yuv422(unsigned long sequence, int flag)
+{
+	unsigned long flags;
+	spin_lock_irqsave(&ntsipu->ntsc->lock_callback, flags);
+	printk_dbg((_DEBUG_NTSIPU & 0x01), "\n");
+
+	/* if IMG success, change frame execute */
+	if (flag) {
+		/* IMG error */
+		ntsipu_callback_yuv422_return_ntsc();
+	} else {
+#ifdef NTSC_ERRATA
+		if (ntsipu->ntsc->iMixImageMode == V4L2_ONLY
+		 || ntsipu->ntsc->iMixImageMode == FB_ONLY) {
+			/* refresh callback
+			   (informed v4l2 or fb1 of budder free) */
+			nts_return_callback_refresh();
+		}
+
+		if (ntsipu->ntsc->iOutmodeFlg == NTS_OUTPUT_NTSC
+		 && errata->ntsc_upscale == NTS_UPSCALE_OFF) {
+			ntsipu_dma_request();
+		} else{
+			ntsipu_callback_yuv422_bottom();
+		}
+#else
+		ntsipu_callback_yuv422_bottom();
+#endif /* NTSC_ERRATA */
+	}
+	spin_unlock_irqrestore(&ntsipu->ntsc->lock_callback, flags);
+}
+
+
+static void ntsipu_callback_yuv422_bottom(void)
+{
+	unsigned long flags;
+	spin_lock_irqsave(&ntsipu->ntsc->lock_callback, flags);
+	printk_dbg((_DEBUG_NTSIPU & 0x01), "\n");
+
+	/* frame change */
+	if (ntsipu->ntsc->iFrameNoNow == NTS_DISP_FRAME_A) {
+		ntsipu->ntsc->iFrameNoNext = NTS_DISP_FRAME_B;
+		printk_dbg((_DEBUG_NTSIPU & 0x02), "now(A) -> next(B)\n");
+	} else {
+		ntsipu->ntsc->iFrameNoNext = NTS_DISP_FRAME_A;
+		printk_dbg((_DEBUG_NTSIPU & 0x02), "now(B) -> next(A)\n");
+	}
+	ntshw_set_framesel(ntsipu->ntsc->iFrameNoNext);
+	ntsipu->ntsc->ntsout_flg = NTS_NTSOUT_ENABLE;
+	if (ntsipu->ntsc->blank_state.nts_backlight == 1) {
+		ntshw_set_ntsout(NTS_NTSOUT_ENABLE);
+	} else if (ntsipu->ntsc->blank_state.nts_output == 1) {
+		printk_dbg((_DEBUG_NTSIPU & 0x40),
+		 "set NTSOUT black: current blank mode = %d\n",
+		 ntsipu->ntsc->blank_state.current_mode);
+		ntshw_set_ntsout(NTS_NTSOUT_ENABLE_BLACK);
+	} else {
+		printk_dbg((_DEBUG_NTSIPU & 0x40),
+		 "set NTSOUT disable: current blank mode = %d\n",
+		 ntsipu->ntsc->blank_state.current_mode);
+		ntshw_set_ntsout(NTS_NTSOUT_DISABLE);
+	}
+
+	/* enable NTSC VSYNC interrupt */
+	ntshw_set_interruput(NTSHW_INTENSET);
+
+	if (ntsipu->ntsc->iMixImageMode == V4L2_ONLY
+	 || ntsipu->ntsc->iMixImageMode == FB_V4L2_ON) {
+		/* ready callback (informed v4l2 of IPU complete time) */
+		nts_return_callback_ready();
+	}
+#ifndef NTSC_ERRATA
+	if (ntsipu->ntsc->iMixImageMode == V4L2_ONLY
+	 || ntsipu->ntsc->iMixImageMode == FB_ONLY) {
+		/* refresh callback (informed v4l2 or fb1 of budder free) */
+		nts_return_callback_refresh();
+	}
+#endif /* NTSC_ERRATA */
+
+	spin_unlock_irqrestore(&ntsipu->ntsc->lock_callback, flags);
+
+	if (ntsipu->ntsc->blank_state.nts_output == 0) {
+		printk_dbg((_DEBUG_NTSIPU & 0x40),
+		 "call nts_irq_handler_sub(): current blank mode = %d\n",
+		 ntsipu->ntsc->blank_state.current_mode);
+		nts_irq_handler_sub();
+	}
+}
+
+
+static void ntsipu_callback_yuv422_return_ntsc(void)
+{
+	printk_dbg((_DEBUG_NTSIPU & 0x01), "\n");
+
+	if (ntsipu->ntsc->iMixImageMode == V4L2_ONLY
+	 || ntsipu->ntsc->iMixImageMode == FB_ONLY) {
+		/* refresh callback (informed v4l2 or fb1 of budder free) */
+		nts_return_callback_refresh();
+		nts_return_callback();
+	} else { /* ntsipu->ntsc->iMixImageMode == FB_V4L2_ON */
+		if (ntsipu->ntsc->img_complete == 0)
+			nts_return_callback();
+
+	}
+}
+
+
+/******************************************************************************
+* MODULE   : ntsipu_callback_rgb565
+* FUNCTION : changing frame and callback to fb and v4l2
+* RETURN   : none
+* NOTE     : none
+* CREATE   : 2008.12.08 M.Haguro
+* UPDATE   :
+******************************************************************************/
+static void ntsipu_callback_rgb565(unsigned long sequence, int flag)
+{
+	unsigned long flags;
+	spin_lock_irqsave(&ntsipu->ntsc->lock_callback, flags);
+	printk_dbg((_DEBUG_NTSIPU & 0x01), "\n");
+
+	/* refresh callback (informed v4l2 or fb1 of budder free) */
+	nts_return_callback_refresh();
+	if (flag) {
+		/* IMG error */
+		nts_return_callback();
+	}
+	spin_unlock_irqrestore(&ntsipu->ntsc->lock_callback, flags);
+}
+
+
+/*****************************************************************************
+* MODULE   : ntsipu_chk_ipuimg
+* FUNCTION :
+* RETURN   : -
+* NOTE     :
+* CREATE   : 2008.11.14 M.Haguro
+* UPDATE   :
+******************************************************************************/
+static int ntsipu_chk_ipuimg(void)
+{
+	int iRet;
+
+	printk_dbg((_DEBUG_NTSIPU & 0x01), "\n");
+
+	switch (ntsipu->ntsc->iMixImageMode) {
+	case V4L2_ONLY:
+		/* copy Src(Back) data */
+		ntsipu->img[IMG_SRC_B]->uiWidth        =
+			ntsipu->ntsc->from_v4l2.image_data.hsize;
+		ntsipu->img[IMG_SRC_B]->uiHeight       =
+			ntsipu->ntsc->from_v4l2.image_data.vsize;
+		ntsipu->img[IMG_SRC_B]->uiX            =
+			ntsipu->ntsc->from_v4l2.image_data.x;
+		ntsipu->img[IMG_SRC_B]->uiY            =
+			ntsipu->ntsc->from_v4l2.image_data.y;
+		ntsipu->img[IMG_SRC_B]->uiScreenWidth  =
+			ntsipu->ntsc->from_v4l2.image_data.size;
+		ntsipu->img[IMG_SRC_B]->uiFormat       =
+			ntsipu->ntsc->from_v4l2.yuvfmt;
+		ntsipu->img[IMG_SRC_B]->uiEndian       =
+			ntsipu->ntsc->from_v4l2.endian <<
+			IMG_PEL_ENDIAN_IN_ENDI_SFT;
+
+		ntsipu->img[IMG_SRC_B]->ulPhysAddrYRGB =
+			ntsipu->ntsc->from_v4l2.image_data.yrgbaddr;
+		ntsipu->img[IMG_SRC_B]->ulPhysAddrUV   =
+			ntsipu->ntsc->from_v4l2.image_data.uvaddr;
+		ntsipu->img[IMG_SRC_B]->ulPhysAddrV    =
+			ntsipu->ntsc->from_v4l2.image_data.vaddr;
+
+		/* copy Destination data */
+		ntsipu->img[IMG_DST]->uiWidth          =
+			ntsipu->ntsc->from_v4l2.screen_data.hsize;
+		ntsipu->img[IMG_DST]->uiHeight         =
+			ntsipu->ntsc->from_v4l2.screen_data.vsize;
+		ntsipu->img[IMG_DST]->uiX              =
+			ntsipu->ntsc->from_v4l2.screen_data.x;
+		ntsipu->img[IMG_DST]->uiY              =
+			ntsipu->ntsc->from_v4l2.screen_data.y;
+		ntsipu->img[IMG_DST]->uiScreenWidth    =
+			NTS_WIDTH;
+		ntsipu->img[IMG_DST]->uiFormat         =
+			IMG_FORMAT_YUV422_SEMI_PLANAR;
+		ntsipu->img[IMG_DST]->uiEndian         =
+			IMG_PEL_ENDIAN_OUT_ENDI_LITTLE;
+
+		if (ntsipu->ntsc->iFrameNoNow == NTS_DISP_FRAME_A) {
+			ntsipu->img[IMG_DST]->ulPhysAddrYRGB = SMEM_START
+			 + NTSCFRAME_B_OFFSET;
+		} else {
+			ntsipu->img[IMG_DST]->ulPhysAddrYRGB = SMEM_START
+			 + NTSCFRAME_A_OFFSET;
+		}
+		ntsipu->img[IMG_DST]->ulPhysAddrUV     =
+			ntsipu->img[IMG_DST]->ulPhysAddrYRGB +
+			NTS_WIDTH * NTS_HEIGHT;
+		ntsipu->img[IMG_DST]->ulPhysAddrV      = 0;
+
+		if ((ntsipu->img[IMG_SRC_B]->uiWidth ==
+			ntsipu->img[IMG_DST]->uiWidth) &&
+			(ntsipu->img[IMG_SRC_B]->uiHeight ==
+			ntsipu->img[IMG_DST]->uiHeight)) {
+			/* IMG -- Color Format Convert */
+			printk_dbg((_DEBUG_NTSIPU & 0x02),
+			 "V4L2 -- Color Format Convert\n");
+			iRet = IMG_OP_MODE_01_BIT;
+		} else {
+			/* IMG -- Resize & Color Format Convert */
+			printk_dbg((_DEBUG_NTSIPU & 0x02),
+			 "V4L2 -- Resize & Color Format Convert\n");
+			iRet = IMG_OP_MODE_03_BIT;
+		}
+		printk_dbg((_DEBUG_NTSIPU & 0x02),
+			"=== ntsipu_chk_ipuimg(V4L2_ONLY) "
+			"=============================\n");
+		printk_dbg((_DEBUG_NTSIPU & 0x02),
+		 " SRC_B | Y(%08lx)  U(%08lx)  V(%08lx)\n",
+		  ntsipu->img[IMG_SRC_B]->ulPhysAddrYRGB,
+		  ntsipu->img[IMG_SRC_B]->ulPhysAddrUV,
+		  ntsipu->img[IMG_SRC_B]->ulPhysAddrV);
+		printk_dbg((_DEBUG_NTSIPU & 0x02),
+		 "       | p(%3d)  w(%3d)  h(%3d)   x(%3d)  y(%3d)\n",
+		 ntsipu->img[IMG_SRC_B]->uiScreenWidth,
+		 ntsipu->img[IMG_SRC_B]->uiWidth,
+		 ntsipu->img[IMG_SRC_B]->uiHeight,
+		 ntsipu->img[IMG_SRC_B]->uiX,
+		 ntsipu->img[IMG_SRC_B]->uiY);
+		printk_dbg((_DEBUG_NTSIPU & 0x02),
+			"-------+-----------------------"
+			"-------------------------------\n");
+		printk_dbg((_DEBUG_NTSIPU & 0x02),
+		 " DST   | Y(%08lx)  U(%08lx)  V(%08lx)\n",
+		 ntsipu->img[IMG_DST]->ulPhysAddrYRGB,
+		 ntsipu->img[IMG_DST]->ulPhysAddrUV,
+		 ntsipu->img[IMG_DST]->ulPhysAddrV);
+		printk_dbg((_DEBUG_NTSIPU & 0x02),
+		 "       | p(%3d)  w(%3d)  h(%3d)   x(%3d)  y(%3d)\n",
+		 ntsipu->img[IMG_DST]->uiScreenWidth,
+		 ntsipu->img[IMG_DST]->uiWidth,
+		 ntsipu->img[IMG_DST]->uiHeight,
+		 ntsipu->img[IMG_DST]->uiX,
+		 ntsipu->img[IMG_DST]->uiY);
+		printk_dbg((_DEBUG_NTSIPU & 0x02),
+			"==============================="
+			"===============================\n\n");
+
+		/* check framebuffer fillrect to GDMA */
+		ntsipu_chk_ipugdma();
+		break;
+#ifdef CONFIG_FB_MP200_NTS
+	case FB_ONLY:
+		/* copy Src(Back) data */
+		ntsipu->img[IMG_SRC_B]->uiWidth        =
+			ntsipu->ntsc->from_fb.image_data.hsize;
+		ntsipu->img[IMG_SRC_B]->uiHeight       =
+			ntsipu->ntsc->from_fb.image_data.vsize;
+		ntsipu->img[IMG_SRC_B]->uiX            =
+			ntsipu->ntsc->from_fb.image_data.x;
+		ntsipu->img[IMG_SRC_B]->uiY            =
+			ntsipu->ntsc->from_fb.image_data.y;
+		ntsipu->img[IMG_SRC_B]->uiScreenWidth  =
+			ntsipu->ntsc->from_fb.image_data.size;
+		ntsipu->img[IMG_SRC_B]->uiFormat       =
+			IMG_FORMAT_RGB565;
+		ntsipu->img[IMG_SRC_B]->uiEndian       =
+			IMG_PEL_ENDIAN_IN_ENDI_LITTLE;
+
+		ntsipu->img[IMG_SRC_B]->ulPhysAddrYRGB =
+			ntsipu->ntsc->from_fb.image_data.yrgbaddr;
+		ntsipu->img[IMG_SRC_B]->ulPhysAddrUV   = 0;
+		ntsipu->img[IMG_SRC_B]->ulPhysAddrV    = 0;
+
+		/* copy Destination data */
+		ntsipu->img[IMG_DST]->uiWidth          =
+			ntsipu->ntsc->from_fb.image_data.hsize;
+		ntsipu->img[IMG_DST]->uiHeight         =
+			ntsipu->ntsc->from_fb.image_data.vsize;
+		ntsipu->img[IMG_DST]->uiX              = 0;
+		ntsipu->img[IMG_DST]->uiY              = 0;
+		ntsipu->img[IMG_DST]->uiScreenWidth    = NTS_WIDTH;
+		ntsipu->img[IMG_DST]->uiFormat         =
+			IMG_FORMAT_YUV422_SEMI_PLANAR;
+		ntsipu->img[IMG_DST]->uiEndian         =
+			IMG_PEL_ENDIAN_OUT_ENDI_LITTLE;
+
+		if (ntsipu->ntsc->iFrameNoNow == NTS_DISP_FRAME_A) {
+			ntsipu->img[IMG_DST]->ulPhysAddrYRGB = SMEM_START
+			 + NTSCFRAME_B_OFFSET;
+		} else {
+			ntsipu->img[IMG_DST]->ulPhysAddrYRGB = SMEM_START
+			 + NTSCFRAME_A_OFFSET;
+		}
+		ntsipu->img[IMG_DST]->ulPhysAddrUV     =
+			ntsipu->img[IMG_DST]->ulPhysAddrYRGB +
+			NTS_WIDTH * NTS_HEIGHT;
+		ntsipu->img[IMG_DST]->ulPhysAddrV      = 0;
+
+		/* IMG -- Color Format Convert */
+		printk_dbg((_DEBUG_NTSIPU & 0x02),
+			"FB -- Color Format Conver\n");
+		iRet = IMG_OP_MODE_06_BIT;
+
+		printk_dbg((_DEBUG_NTSIPU & 0x02),
+			"=== ntsipu_chk_ipuimg(FB_ONLY) "
+			"===============================\n");
+		printk_dbg((_DEBUG_NTSIPU & 0x02),
+		 " SRC_B | Y(%08lx)  U(%08lx)  V(%08lx)\n",
+		 ntsipu->img[IMG_SRC_B]->ulPhysAddrYRGB,
+		 ntsipu->img[IMG_SRC_B]->ulPhysAddrUV,
+		 ntsipu->img[IMG_SRC_B]->ulPhysAddrV);
+		printk_dbg((_DEBUG_NTSIPU & 0x02),
+		 "       | p(%3d)  w(%3d)  h(%3d)   x(%3d)  y(%3d)\n",
+		 ntsipu->img[IMG_SRC_B]->uiScreenWidth,
+		 ntsipu->img[IMG_SRC_B]->uiWidth,
+		 ntsipu->img[IMG_SRC_B]->uiHeight,
+		 ntsipu->img[IMG_SRC_B]->uiX,
+		  ntsipu->img[IMG_SRC_B]->uiY);
+		printk_dbg((_DEBUG_NTSIPU & 0x02),
+			"-------+-----------------------"
+			"-------------------------------\n");
+		printk_dbg((_DEBUG_NTSIPU & 0x02),
+		 " DST   | Y(%08lx)  U(%08lx)  V(%08lx)\n",
+		 ntsipu->img[IMG_DST]->ulPhysAddrYRGB,
+		 ntsipu->img[IMG_DST]->ulPhysAddrUV,
+		 ntsipu->img[IMG_DST]->ulPhysAddrV);
+		printk_dbg((_DEBUG_NTSIPU & 0x02),
+		 "       | p(%3d)  w(%3d)  h(%3d)   x(%3d)  y(%3d)\n",
+		 ntsipu->img[IMG_DST]->uiScreenWidth,
+		 ntsipu->img[IMG_DST]->uiWidth,
+		 ntsipu->img[IMG_DST]->uiHeight,
+		 ntsipu->img[IMG_DST]->uiX,
+		 ntsipu->img[IMG_DST]->uiY);
+		printk_dbg((_DEBUG_NTSIPU & 0x02),
+			"==============================="
+			"===============================\n\n");
+		break;
+	case FB_V4L2_ON:
+		/* copy Src(Front) data */
+		ntsipu->img[IMG_SRC_F]->uiWidth        =
+			ntsipu->ntsc->from_fb.image_data.hsize;
+		ntsipu->img[IMG_SRC_F]->uiHeight       =
+			ntsipu->ntsc->from_fb.image_data.vsize;
+		ntsipu->img[IMG_SRC_F]->uiX            =
+			ntsipu->ntsc->from_fb.image_data.x;
+		ntsipu->img[IMG_SRC_F]->uiY            =
+			ntsipu->ntsc->from_fb.image_data.y;
+		ntsipu->img[IMG_SRC_F]->uiScreenWidth  =
+			ntsipu->ntsc->from_fb.image_data.size;
+		ntsipu->img[IMG_SRC_F]->uiFormat       =
+			IMG_FORMAT_RGB565;
+		ntsipu->img[IMG_SRC_F]->uiEndian       =
+			IMG_PEL_ENDIAN_IN_ENDI_LITTLE;
+
+		ntsipu->img[IMG_SRC_F]->ulPhysAddrYRGB =
+			ntsipu->ntsc->from_fb.image_data.yrgbaddr;
+		ntsipu->img[IMG_SRC_F]->ulPhysAddrUV   = 0;
+		ntsipu->img[IMG_SRC_F]->ulPhysAddrV    = 0;
+
+		/* copy Src(Back) data */
+		ntsipu->img[IMG_SRC_B]->uiWidth        =
+			ntsipu->ntsc->from_v4l2.image_data.hsize;
+		ntsipu->img[IMG_SRC_B]->uiHeight       =
+			ntsipu->ntsc->from_v4l2.image_data.vsize;
+		ntsipu->img[IMG_SRC_B]->uiX            =
+			ntsipu->ntsc->from_v4l2.image_data.x;
+		ntsipu->img[IMG_SRC_B]->uiY            =
+			ntsipu->ntsc->from_v4l2.image_data.y;
+		ntsipu->img[IMG_SRC_B]->uiScreenWidth  =
+			ntsipu->ntsc->from_v4l2.image_data.size;
+		ntsipu->img[IMG_SRC_B]->uiFormat       =
+			ntsipu->ntsc->from_v4l2.yuvfmt;
+		ntsipu->img[IMG_SRC_B]->uiEndian       =
+			ntsipu->ntsc->from_v4l2.endian <<
+			IMG_PEL_ENDIAN_IN_ENDI_SFT;
+
+		ntsipu->img[IMG_SRC_B]->ulPhysAddrYRGB =
+			ntsipu->ntsc->from_v4l2.image_data.yrgbaddr;
+		ntsipu->img[IMG_SRC_B]->ulPhysAddrUV   =
+			ntsipu->ntsc->from_v4l2.image_data.uvaddr;
+		ntsipu->img[IMG_SRC_B]->ulPhysAddrV    =
+			ntsipu->ntsc->from_v4l2.image_data.vaddr;
+
+		/* copy Destination data */
+		ntsipu->img[IMG_DST]->uiWidth          =
+			ntsipu->ntsc->from_v4l2.screen_data.hsize;
+		ntsipu->img[IMG_DST]->uiHeight         =
+			ntsipu->ntsc->from_v4l2.screen_data.vsize;
+		ntsipu->img[IMG_DST]->uiX              =
+			ntsipu->ntsc->from_v4l2.screen_data.x;
+		ntsipu->img[IMG_DST]->uiY              =
+			ntsipu->ntsc->from_v4l2.screen_data.y;
+		ntsipu->img[IMG_DST]->uiScreenWidth    =
+			NTS_WIDTH*2;
+		ntsipu->img[IMG_DST]->uiFormat         =
+			IMG_FORMAT_RGB565;
+		ntsipu->img[IMG_DST]->uiEndian         =
+			IMG_PEL_ENDIAN_OUT_ENDI_LITTLE;
+
+		ntsipu->img[IMG_DST]->ulPhysAddrYRGB   =
+			SMEM_START + NTSCWORK_OFFSET;
+		ntsipu->img[IMG_DST]->ulPhysAddrUV     = 0;
+		ntsipu->img[IMG_DST]->ulPhysAddrV      = 0;
+
+		/* IMG -- Resize & Color Format Convert & Alpha bleading */
+		printk_dbg((_DEBUG_NTSIPU & 0x02),
+			"FB & V4L2 -- Resize & Color Format "
+			"Convert & Alpha bleading\n");
+		iRet = IMG_OP_MODE_18_BIT;
+
+		printk_dbg((_DEBUG_NTSIPU & 0x02),
+			"=== ntsipu_chk_ipuimg(FB_V4L2_ON) "
+			"============================\n");
+		printk_dbg((_DEBUG_NTSIPU & 0x02),
+		 " SRC_F | Y(%08lx)  U(%08lx)  V(%08lx)\n",
+		 ntsipu->img[IMG_SRC_F]->ulPhysAddrYRGB,
+		 ntsipu->img[IMG_SRC_F]->ulPhysAddrUV,
+		 ntsipu->img[IMG_SRC_F]->ulPhysAddrV);
+		printk_dbg((_DEBUG_NTSIPU & 0x02),
+		 "       | p(%3d)  w(%3d)  h(%3d)   x(%3d)  y(%3d)\n",
+		 ntsipu->img[IMG_SRC_F]->uiScreenWidth,
+		 ntsipu->img[IMG_SRC_F]->uiWidth,
+		 ntsipu->img[IMG_SRC_F]->uiHeight,
+		 ntsipu->img[IMG_SRC_F]->uiX,
+		 ntsipu->img[IMG_SRC_F]->uiY);
+		printk_dbg((_DEBUG_NTSIPU & 0x02),
+			"-------+-----------------------"
+			"-------------------------------\n");
+		printk_dbg((_DEBUG_NTSIPU & 0x02),
+		 " SRC_B | Y(%08lx)  U(%08lx)  V(%08lx)\n",
+		 ntsipu->img[IMG_SRC_B]->ulPhysAddrYRGB,
+		 ntsipu->img[IMG_SRC_B]->ulPhysAddrUV,
+		 ntsipu->img[IMG_SRC_B]->ulPhysAddrV);
+		printk_dbg((_DEBUG_NTSIPU & 0x02),
+		 "       | p(%3d)  w(%3d)  h(%3d)   x(%3d)  y(%3d)\n",
+		 ntsipu->img[IMG_SRC_B]->uiScreenWidth,
+		 ntsipu->img[IMG_SRC_B]->uiWidth,
+		 ntsipu->img[IMG_SRC_B]->uiHeight,
+		 ntsipu->img[IMG_SRC_B]->uiX, ntsipu->img[IMG_SRC_B]->uiY);
+		printk_dbg((_DEBUG_NTSIPU & 0x02),
+			"-------+-----------------------"
+			"-------------------------------\n");
+		printk_dbg((_DEBUG_NTSIPU & 0x02),
+		 " DST   | Y(%08lx)  U(%08lx)  V(%08lx)\n",
+		 ntsipu->img[IMG_DST]->ulPhysAddrYRGB,
+		 ntsipu->img[IMG_DST]->ulPhysAddrUV,
+		 ntsipu->img[IMG_DST]->ulPhysAddrV);
+		printk_dbg((_DEBUG_NTSIPU & 0x02),
+		 "       | p(%3d)  w(%3d)  h(%3d)   x(%3d)  y(%3d)\n",
+		 ntsipu->img[IMG_DST]->uiScreenWidth,
+		 ntsipu->img[IMG_DST]->uiWidth,
+		 ntsipu->img[IMG_DST]->uiHeight,
+		 ntsipu->img[IMG_DST]->uiX,
+		 ntsipu->img[IMG_DST]->uiY);
+		printk_dbg((_DEBUG_NTSIPU & 0x02),
+			"==============================="
+			"===============================\n\n");
+		break;
+#endif /* CONFIG_FB_MP200_NTS */
+	default:
+		iRet = -EINVAL;
+		break;
+	}
+	printk_dbg((_DEBUG_NTSIPU & 0x02),
+		"mode(%d)  return(%x)\n", ntsipu->ntsc->iMixImageMode, iRet);
+	return iRet;
+}
+
+
+/*****************************************************************************
+* MODULE   : ntsipu_chk_ipuimg_bottom
+* FUNCTION :
+* RETURN   : -
+* NOTE     :
+* CREATE   : 2008.12.04 M.Haguro
+* UPDATE   :
+******************************************************************************/
+static int ntsipu_chk_ipuimg_bottom(void)
+{
+	int iRet;
+	printk_dbg((_DEBUG_NTSIPU & 0x01), "\n");
+
+	switch (ntsipu->ntsc->iMixImageMode) {
+#ifdef CONFIG_FB_MP200_NTS
+	case FB_V4L2_ON:
+		/* copy Src(Back) data */
+		ntsipu->img[IMG_SRC_B]->uiWidth        =
+			ntsipu->ntsc->from_fb.image_data.hsize;
+		ntsipu->img[IMG_SRC_B]->uiHeight       =
+			ntsipu->ntsc->from_fb.image_data.vsize;
+		ntsipu->img[IMG_SRC_B]->uiX            = 0;
+		ntsipu->img[IMG_SRC_B]->uiY            = 0;
+		ntsipu->img[IMG_SRC_B]->uiScreenWidth  =
+			ntsipu->img[IMG_DST]->uiScreenWidth;
+		ntsipu->img[IMG_SRC_B]->uiFormat       =
+			ntsipu->img[IMG_DST]->uiFormat;
+		ntsipu->img[IMG_SRC_B]->uiEndian       =
+			ntsipu->img[IMG_DST]->uiEndian;
+
+		ntsipu->img[IMG_SRC_B]->ulPhysAddrYRGB =
+			ntsipu->img[IMG_DST]->ulPhysAddrYRGB;
+		ntsipu->img[IMG_SRC_B]->ulPhysAddrUV   =
+			ntsipu->img[IMG_DST]->ulPhysAddrUV;
+		ntsipu->img[IMG_SRC_B]->ulPhysAddrV    =
+			ntsipu->img[IMG_DST]->ulPhysAddrV;
+
+		/* copy Destination data */
+		ntsipu->img[IMG_DST]->uiWidth          =
+			ntsipu->ntsc->from_fb.image_data.hsize;
+		ntsipu->img[IMG_DST]->uiHeight         =
+			ntsipu->ntsc->from_fb.image_data.vsize;
+		ntsipu->img[IMG_DST]->uiX              = 0;
+		ntsipu->img[IMG_DST]->uiY              = 0;
+		ntsipu->img[IMG_DST]->uiScreenWidth    =
+			NTS_WIDTH;
+		ntsipu->img[IMG_DST]->uiFormat         =
+			IMG_FORMAT_YUV422_SEMI_PLANAR;
+		ntsipu->img[IMG_DST]->uiEndian         =
+			IMG_PEL_ENDIAN_OUT_ENDI_LITTLE;
+
+		if (ntsipu->ntsc->iFrameNoNow == NTS_DISP_FRAME_A) {
+			ntsipu->img[IMG_DST]->ulPhysAddrYRGB = SMEM_START
+			 + NTSCFRAME_B_OFFSET;
+		} else {
+			ntsipu->img[IMG_DST]->ulPhysAddrYRGB = SMEM_START
+			 + NTSCFRAME_A_OFFSET;
+		}
+		ntsipu->img[IMG_DST]->ulPhysAddrUV     =
+			ntsipu->img[IMG_DST]->ulPhysAddrYRGB +
+			NTS_WIDTH * NTS_HEIGHT;
+		ntsipu->img[IMG_DST]->ulPhysAddrV      = 0;
+
+		/* IMG -- Color Format Convert */
+		printk_dbg((_DEBUG_NTSIPU & 0x02),
+		 "FB & V4L2 -- Color Format Conver\n");
+		iRet = IMG_OP_MODE_06_BIT;
+
+		printk_dbg((_DEBUG_NTSIPU & 0x02),
+			"=== ntsipu_chk_ipuimg() "
+			"======================================\n");
+		printk_dbg((_DEBUG_NTSIPU & 0x02),
+		 " SRC_B | Y(%08lx)  U(%08lx)  V(%08lx)\n",
+		 ntsipu->img[IMG_SRC_B]->ulPhysAddrYRGB,
+		 ntsipu->img[IMG_SRC_B]->ulPhysAddrUV,
+		 ntsipu->img[IMG_SRC_B]->ulPhysAddrV);
+		printk_dbg((_DEBUG_NTSIPU & 0x02),
+		 "       | p(%3d)  w(%3d)  h(%3d)   x(%3d)  y(%3d)\n",
+		 ntsipu->img[IMG_SRC_B]->uiScreenWidth,
+		 ntsipu->img[IMG_SRC_B]->uiWidth,
+		 ntsipu->img[IMG_SRC_B]->uiHeight,
+		 ntsipu->img[IMG_SRC_B]->uiX,
+		  ntsipu->img[IMG_SRC_B]->uiY);
+		printk_dbg((_DEBUG_NTSIPU & 0x02),
+		"-------+-----------------------"
+		"-------------------------------\n");
+		printk_dbg((_DEBUG_NTSIPU & 0x02),
+		 " DST   | Y(%08lx)  U(%08lx)  V(%08lx)\n",
+		 ntsipu->img[IMG_DST]->ulPhysAddrYRGB,
+		 ntsipu->img[IMG_DST]->ulPhysAddrUV,
+		 ntsipu->img[IMG_DST]->ulPhysAddrV);
+		printk_dbg((_DEBUG_NTSIPU & 0x02),
+		 "       | p(%3d)  w(%3d)  h(%3d)   x(%3d)  y(%3d)\n",
+		 ntsipu->img[IMG_DST]->uiScreenWidth,
+		 ntsipu->img[IMG_DST]->uiWidth,
+		 ntsipu->img[IMG_DST]->uiHeight,
+		 ntsipu->img[IMG_DST]->uiX,
+		 ntsipu->img[IMG_DST]->uiY);
+		printk_dbg((_DEBUG_NTSIPU & 0x02),
+		"==============================="
+		"===============================\n\n");
+		break;
+#endif /* CONFIG_FB_MP200_NTS */
+	default:
+		iRet = -EINVAL;
+		break;
+	}
+	printk_dbg((_DEBUG_NTSIPU & 0x02), "mode(%d)  return(%x)\n",
+	 ntsipu->ntsc->iMixImageMode, iRet);
+	return iRet;
+}
+
+
+/******************************************************************************
+* MODULE   : ntsipu_set_imgmode
+* FUNCTION : set IMG_MODE
+* RETURN   : none
+* NOTE     : none
+* CREATE   : 2008.11.14 M.Haguro
+* UPDATE   :
+******************************************************************************/
+static unsigned long ntsipu_set_imgmode(void)
+{
+	unsigned long ulImgMode;
+
+	printk_dbg((_DEBUG_NTSIPU & 0x01), "\n");
+
+	ulImgMode = IMG_NEWEN_BIT;
+
+	/* vanish mask color */
+	if (ntsipu->ntsc->from_fb.maskcolrflg == FB_MASK_COLOR_DISP_OFF)
+		ulImgMode |= IMG_MASK_COL_BIT;
+
+	/* up/down and right/left inverse (180 rotate) */
+	if (ntsipu->ntsc->from_fb.invflg == UDRL_INVERSE)
+		ulImgMode |= (IMG_UDINV_BIT | IMG_RLINV_BIT);
+
+	return ulImgMode;
+}
+
+
+/******************************************************************************
+* MODULE   : ntsipu_set_format
+* FUNCTION : set IMG_MODE
+* RETURN   : none
+* NOTE     : none
+* CREATE   : 2008.11.14 M.Haguro
+* UPDATE   :
+******************************************************************************/
+static unsigned long ntsipu_set_format(void)
+{
+	int bpp_y, bpp_uv, bpp_v; /* bit par pixel  */
+	int ppl_y, ppl_uv, ppl_v; /* pixel par line */
+	unsigned int uiScreenPixcelWidthY;
+	unsigned int uiScreenPixcelWidthUV;
+	unsigned int uiScreenPixcelWidthV;
+
+	printk_dbg((_DEBUG_NTSIPU & 0x01), "\n");
+
+	/*
+	 * Source(Back) image
+	 */
+	switch (ntsipu->img[IMG_SRC_B]->uiFormat) {
+	case IMG_FORMAT_YUV420_SEMI_PLANAR: /* YUV420 Semi-Planar */
+		printk_dbg((_DEBUG_NTSIPU & 0x02), "src_b_format(YUV420Pl2)\n");
+		bpp_y = 8;  bpp_uv = 8; bpp_v = 0;
+		ppl_y = 1; ppl_uv = 2; ppl_v = 0;
+		break;
+	case IMG_FORMAT_YUV420_PLANAR:      /* YUV420 Planar      */
+		printk_dbg((_DEBUG_NTSIPU & 0x02), "src_b_format(YUV420Pl)\n");
+		bpp_y = 8;  bpp_uv = 4; bpp_v = 4;
+		ppl_y = 1; ppl_uv = 2; ppl_v = 2;
+		break;
+	case IMG_FORMAT_YUV422_SEMI_PLANAR: /* YUV422 Semi-Planar */
+		printk_dbg((_DEBUG_NTSIPU & 0x02), "src_b_format(YUV422Pl2)\n");
+		bpp_y = 8;  bpp_uv = 8; bpp_v = 0;
+		ppl_y = 1; ppl_uv = 1; ppl_v = 0;
+		break;
+	case IMG_FORMAT_YUV422_PLANAR:      /* YUV422 Planar      */
+		printk_dbg((_DEBUG_NTSIPU & 0x02), "src_b_format(YUV422Pl)\n");
+		bpp_y = 8;  bpp_uv = 8; bpp_v = 8;
+		ppl_y = 1; ppl_uv = 2; ppl_v = 2;
+		break;
+	case IMG_FORMAT_YUV422_INTERLEAVE:  /* YUV422 Interleave  */
+		printk_dbg((_DEBUG_NTSIPU & 0x02), "src_b_format(YUV422Px)\n");
+		bpp_y = 16; bpp_uv = 0; bpp_v = 0;
+		ppl_y = 1; ppl_uv = 0; ppl_v = 0;
+		break;
+	case IMG_FORMAT_RGB565:             /* RGB565             */
+		printk_dbg((_DEBUG_NTSIPU & 0x02), "src_b_format(RGB565)\n");
+		bpp_y = 16; bpp_uv = 0; bpp_v = 0;
+		ppl_y = 1; ppl_uv = 0; ppl_v = 0;
+		break;
+	case IMG_FORMAT_RGB888:             /* RGB888             */
+		printk_dbg((_DEBUG_NTSIPU & 0x02), "src_b_format(RGB888)\n");
+		bpp_y = 24; bpp_uv = 0; bpp_v = 0;
+		ppl_y = 1; ppl_uv = 0; ppl_v = 0;
+		break;
+	default:
+		printk_dbg((_DEBUG_NTSIPU & 0x02),
+			"src_b_format(%d)\n", ntsipu->img[IMG_SRC_B]->uiFormat);
+		return (unsigned long)-EINVAL;
+	}
+	uiScreenPixcelWidthY =
+			ntsipu->img[IMG_SRC_B]->uiScreenWidth / bpp_y  * 8;
+	if (bpp_uv)
+		uiScreenPixcelWidthUV =
+			ntsipu->img[IMG_SRC_B]->uiScreenWidth / bpp_uv * 8;
+	else
+		uiScreenPixcelWidthUV = 0;
+	if (bpp_v)
+		uiScreenPixcelWidthV  =
+			ntsipu->img[IMG_SRC_B]->uiScreenWidth / bpp_v  * 8;
+	else
+		uiScreenPixcelWidthV  = 0;
+
+	switch (ntsipu->img[IMG_SRC_B]->uiFormat) {
+	case IMG_FORMAT_RGB565:             /* RGB565             */
+	case IMG_FORMAT_RGB888:             /* RGB888             */
+	case IMG_FORMAT_YUV422_INTERLEAVE:  /* YUV422 Interleave  */
+		ntsipu->img[IMG_SRC_B]->ulPhysAddrYRGB =
+			ntsipu->img[IMG_SRC_B]->ulPhysAddrYRGB +
+			ntsipu->img[IMG_SRC_B]->uiY * uiScreenPixcelWidthY /
+			ppl_y  +
+			ntsipu->img[IMG_SRC_B]->uiX * bpp_y  / 8;
+		ntsipu->img[IMG_SRC_B]->ulPhysAddrUV   = 0;
+		ntsipu->img[IMG_SRC_B]->ulPhysAddrV    = 0;
+		break;
+	case IMG_FORMAT_YUV420_SEMI_PLANAR: /* YUV420 Semi-Planar */
+	case IMG_FORMAT_YUV422_SEMI_PLANAR: /* YUV422 Semi-Planar */
+		ntsipu->img[IMG_SRC_B]->ulPhysAddrYRGB =
+			ntsipu->img[IMG_SRC_B]->ulPhysAddrYRGB +
+			ntsipu->img[IMG_SRC_B]->uiY * uiScreenPixcelWidthY /
+			ppl_y +
+			ntsipu->img[IMG_SRC_B]->uiX * bpp_y  / 8;
+		ntsipu->img[IMG_SRC_B]->ulPhysAddrUV =
+			ntsipu->img[IMG_SRC_B]->ulPhysAddrUV +
+			ntsipu->img[IMG_SRC_B]->uiY * uiScreenPixcelWidthUV /
+			ppl_uv +
+			ntsipu->img[IMG_SRC_B]->uiX * bpp_uv / 8;
+		ntsipu->img[IMG_SRC_B]->ulPhysAddrV    = 0;
+		break;
+	case IMG_FORMAT_YUV420_PLANAR:      /* YUV420 Planar      */
+	case IMG_FORMAT_YUV422_PLANAR:      /* YUV422 Planar      */
+		ntsipu->img[IMG_SRC_B]->ulPhysAddrYRGB =
+			ntsipu->img[IMG_SRC_B]->ulPhysAddrYRGB +
+			ntsipu->img[IMG_SRC_B]->uiY * uiScreenPixcelWidthY /
+			ppl_y +
+			ntsipu->img[IMG_SRC_B]->uiX * bpp_y  / 8;
+		ntsipu->img[IMG_SRC_B]->ulPhysAddrUV   =
+			ntsipu->img[IMG_SRC_B]->ulPhysAddrUV +
+			ntsipu->img[IMG_SRC_B]->uiY * uiScreenPixcelWidthUV /
+			ppl_uv +
+			ntsipu->img[IMG_SRC_B]->uiX * bpp_uv / 8;
+		ntsipu->img[IMG_SRC_B]->ulPhysAddrV    =
+			ntsipu->img[IMG_SRC_B]->ulPhysAddrV +
+			ntsipu->img[IMG_SRC_B]->uiY * uiScreenPixcelWidthV /
+			ppl_v +
+			ntsipu->img[IMG_SRC_B]->uiX * bpp_v  / 8;
+		break;
+	default:
+		printk_dbg((_DEBUG_NTSIPU & 0x02),
+			"src_b_format(%d)\n", ntsipu->img[IMG_SRC_B]->uiFormat);
+		return (unsigned long)-EINVAL;
+	}
+
+	/*
+	 * Source(Front) image
+	 */
+	switch (ntsipu->ntsc->iMixImageMode) {
+	case FB_V4L2_ON:
+		switch (ntsipu->img[IMG_SRC_F]->uiFormat) {
+		case IMG_FORMAT_RGB565:             /* RGB565             */
+			printk_dbg((_DEBUG_NTSIPU & 0x02),
+				"src_f_format(RGB565)\n");
+			bpp_y = 16; bpp_uv = 0; bpp_v = 0;
+			ppl_y = 1; ppl_uv = 0; ppl_v = 0;
+			break;
+		default:
+			printk_dbg((_DEBUG_NTSIPU & 0x02),
+				"src_f_format(%d)\n",
+				ntsipu->img[IMG_SRC_F]->uiFormat);
+			return (unsigned long)-EINVAL;
+		}
+		uiScreenPixcelWidthY  =
+			ntsipu->img[IMG_SRC_F]->uiScreenWidth / bpp_y  * 8;
+		if (bpp_uv)
+			uiScreenPixcelWidthUV =
+				ntsipu->img[IMG_SRC_F]->uiScreenWidth /
+				bpp_uv * 8;
+		else
+			uiScreenPixcelWidthUV = 0;
+		if (bpp_y)
+			uiScreenPixcelWidthV  =
+				ntsipu->img[IMG_SRC_F]->uiScreenWidth /
+				bpp_v  * 8;
+		else
+			uiScreenPixcelWidthV  = 0;
+
+		switch (ntsipu->img[IMG_SRC_F]->uiFormat) {
+		case IMG_FORMAT_RGB565:             /* RGB565             */
+			ntsipu->img[IMG_SRC_F]->ulPhysAddrYRGB =
+				ntsipu->img[IMG_SRC_F]->ulPhysAddrYRGB +
+				ntsipu->img[IMG_SRC_F]->uiY *
+				uiScreenPixcelWidthY / ppl_y +
+				ntsipu->img[IMG_SRC_F]->uiX * bpp_y  / 8;
+			ntsipu->img[IMG_SRC_F]->ulPhysAddrUV   = 0;
+			ntsipu->img[IMG_SRC_F]->ulPhysAddrV    = 0;
+			break;
+		default:
+			printk_dbg((_DEBUG_NTSIPU & 0x02),
+				"src_f_format(%d)\n",
+				ntsipu->img[IMG_SRC_F]->uiFormat);
+			return (unsigned long)-EINVAL;
+		}
+		break;
+	case V4L2_ONLY:
+	case FB_ONLY:
+		break;
+	default:
+		return (unsigned long)-EINVAL;
+	}
+
+	/*
+	 * Destination image
+	 */
+	switch (ntsipu->ntsc->iMixImageMode) {
+	case V4L2_ONLY:
+	case FB_ONLY:
+		switch (ntsipu->img[IMG_DST]->uiFormat) {
+		case IMG_FORMAT_YUV422_SEMI_PLANAR: /* YUV422 Semi-Planar */
+			printk_dbg((_DEBUG_NTSIPU & 0x02),
+				"dst_format(YUV422Pl2)\n");
+			bpp_y = 8;  bpp_uv = 8; bpp_v = 0;
+			ppl_y = 1; ppl_uv = 1; ppl_v = 0;
+			break;
+		default:
+			printk_dbg((_DEBUG_NTSIPU & 0x02),
+				"dst_format(%d)\n",
+				ntsipu->img[IMG_DST]->uiFormat);
+			return (unsigned long)-EINVAL;
+		}
+		uiScreenPixcelWidthY =
+			ntsipu->img[IMG_DST]->uiScreenWidth / bpp_y  * 8;
+		if (bpp_uv)
+			uiScreenPixcelWidthUV =
+				ntsipu->img[IMG_DST]->uiScreenWidth /
+				bpp_uv * 8;
+		else
+			uiScreenPixcelWidthUV = 0;
+		if (bpp_v)
+			uiScreenPixcelWidthV  =
+				ntsipu->img[IMG_DST]->uiScreenWidth /
+				bpp_v  * 8;
+		else
+			uiScreenPixcelWidthV  = 0;
+
+		switch (ntsipu->img[IMG_DST]->uiFormat) {
+		case IMG_FORMAT_YUV422_SEMI_PLANAR: /* YUV422 Semi-Planar */
+			ntsipu->img[IMG_DST]->ulPhysAddrYRGB =
+				ntsipu->img[IMG_DST]->ulPhysAddrYRGB +
+				ntsipu->img[IMG_DST]->uiY *
+				uiScreenPixcelWidthY / ppl_y +
+				ntsipu->img[IMG_DST]->uiX * bpp_y / 8;
+			ntsipu->img[IMG_DST]->ulPhysAddrUV   =
+				ntsipu->img[IMG_DST]->ulPhysAddrUV +
+				ntsipu->img[IMG_DST]->uiY *
+				uiScreenPixcelWidthUV / ppl_uv +
+				ntsipu->img[IMG_DST]->uiX * bpp_uv / 8;
+			ntsipu->img[IMG_DST]->ulPhysAddrV    = 0;
+			break;
+		default:
+			printk_dbg((_DEBUG_NTSIPU & 0x02),
+				"dst_format(%d)\n",
+				ntsipu->img[IMG_DST]->uiFormat);
+			return (unsigned long)-EINVAL;
+		}
+		break;
+	case FB_V4L2_ON:
+		switch (ntsipu->img[IMG_DST]->uiFormat) {
+		case IMG_FORMAT_YUV422_SEMI_PLANAR: /* YUV422 Semi-Planar */
+			printk_dbg((_DEBUG_NTSIPU & 0x02),
+			 "dst_format(YUV422Pl2)\n");
+			break;
+		case IMG_FORMAT_RGB888:             /* RGB888             */
+			printk_dbg((_DEBUG_NTSIPU & 0x02),
+			 "dst_format(RGB888)\n");
+			break;
+		case IMG_FORMAT_RGB565:             /* RGB565             */
+			printk_dbg((_DEBUG_NTSIPU & 0x02),
+			 "dst_format(RGB565)\n");
+			break;
+		default:
+			printk_dbg((_DEBUG_NTSIPU & 0x02),
+			 "dst_format(%d)\n", ntsipu->img[IMG_DST]->uiFormat);
+			return (unsigned long)-EINVAL;
+		}
+		break;
+	default:
+		return (unsigned long)-EINVAL;
+	}
+
+	return (unsigned long)(ntsipu->img[IMG_DST]->uiFormat <<
+		IMG_FORMAT_DSTFMT_SFT) | (ntsipu->img[IMG_SRC_F]->uiFormat <<
+		IMG_FORMAT_SRCFMT_F_SFT) | (ntsipu->img[IMG_SRC_B]->uiFormat <<
+		IMG_FORMAT_SRCFMT_B_SFT);
+}
+
+
+/*****************************************************************************
+* MODULE   : ntsipu_set_ipuimg
+* FUNCTION : make rotate request data to IPU-IMG driver.
+* RETURN   :  0: success
+*          : -1: error
+* NOTE     : The register information table make, requested to the IMG driver.
+* CREATE   : 2008.11.13 M.Haguro
+* UPDATE   :
+******************************************************************************/
+static int ntsipu_set_ipuimg(int index, int img_op_mode)
+{
+	unsigned long ulImgMode, ulFormat, ulEndian;
+	int index_req = 0;
+
+	printk_dbg((_DEBUG_NTSIPU & 0x01), "index(%d)\n", index);
+
+	/*******************************
+	    set IMG_MODE
+	********************************/
+	ulImgMode = (unsigned long)img_op_mode | ntsipu_set_imgmode();
+
+	/*******************************
+	    set ENDIAN
+	********************************/
+	ulEndian = ntsipu->img[IMG_SRC_B]->uiEndian
+	 | ntsipu->img[IMG_DST]->uiEndian;
+
+	/*******************************
+	    set IMG_FORMAT
+	********************************/
+	ulFormat = ntsipu_set_format();
+	if (ulFormat == (unsigned long)-EINVAL) {
+		printk_dbg((_DEBUG_NTSIPU & 0x02), "(%d) error\n", __LINE__);
+		return (int)ulFormat;
+	}
+
+	/*******************************
+	    set IMG request data
+	********************************/
+	/*==============================
+	    IMG_MODE
+	================================*/
+	IpuRequest(ulImgMode,                                IMG_MODE);
+	IpuRequest(ulFormat,                                 IMG_FORMAT);
+	IpuRequest(ulEndian,                                 IMG_PEL_ENDIAN);
+
+	/*==============================
+	    source Back image
+	================================*/
+	IpuRequest(ntsipu->img[IMG_SRC_B]->ulPhysAddrYRGB,   IMG_SRCYRGBADR_B);
+	IpuRequest(ntsipu->img[IMG_SRC_B]->ulPhysAddrUV,     IMG_SRCUVADR_B);
+	IpuRequest(ntsipu->img[IMG_SRC_B]->ulPhysAddrV,      IMG_SRCVADR_B);
+	IpuRequest(ntsipu->img[IMG_SRC_B]->uiScreenWidth,    IMG_SRCSIZE_B);
+	IpuRequest(ntsipu->img[IMG_SRC_B]->uiWidth,          IMG_SRCHSIZE_B);
+	IpuRequest(ntsipu->img[IMG_SRC_B]->uiHeight,         IMG_SRCVSIZE_B);
+
+	/*==============================
+	    destination image
+	================================*/
+#ifdef NTSC_ERRATA
+	if (ntsipu->ntsc->iOutmodeFlg == NTS_OUTPUT_NTSC &&
+		errata->ntsc_upscale == NTS_UPSCALE_OFF &&
+		ntsipu->img[IMG_DST]->uiFormat ==
+		IMG_FORMAT_YUV422_SEMI_PLANAR) {
+		IpuRequest(ntsipu->img[IMG_DST]->ulPhysAddrYRGB + NTSC_WIDTH,
+			IMG_DSTYRGBADR);
+		IpuRequest(ntsipu->img[IMG_DST]->ulPhysAddrUV + NTSC_WIDTH,
+			IMG_DSTUVADR);
+		IpuRequest(ntsipu->img[IMG_DST]->ulPhysAddrV, IMG_DSTVADR);
+	} else {
+		IpuRequest(ntsipu->img[IMG_DST]->ulPhysAddrYRGB,
+			IMG_DSTYRGBADR);
+		IpuRequest(ntsipu->img[IMG_DST]->ulPhysAddrUV, IMG_DSTUVADR);
+		IpuRequest(ntsipu->img[IMG_DST]->ulPhysAddrV,  IMG_DSTVADR);
+	}
+#else
+	IpuRequest(ntsipu->img[IMG_DST]->ulPhysAddrYRGB,       IMG_DSTYRGBADR);
+	IpuRequest(ntsipu->img[IMG_DST]->ulPhysAddrUV,         IMG_DSTUVADR);
+	IpuRequest(ntsipu->img[IMG_DST]->ulPhysAddrV,          IMG_DSTVADR);
+#endif /* NTSC_ERRATA */
+	IpuRequest(ntsipu->img[IMG_DST]->uiScreenWidth,        IMG_DSTSIZE);
+
+	if (((ulImgMode & IMG_OP_MODE_BIT) == IMG_OP_MODE_03_BIT)
+	 || ((ulImgMode & IMG_OP_MODE_BIT) == IMG_OP_MODE_18_BIT)) {
+		unsigned long step_h, step_v, fold_h, fold_v;
+
+		/* resize */
+		IpuRequest(ntsipu->img[IMG_DST]->uiWidth,        IMG_DSTHSIZE);
+		IpuRequest(ntsipu->img[IMG_DST]->uiHeight,       IMG_DSTVSIZE);
+
+		/* step */
+		step_h =
+			ntsipu->img[IMG_SRC_B]->uiWidth  * 256 /
+			ntsipu->img[IMG_DST]->uiWidth;
+		step_v =
+			ntsipu->img[IMG_SRC_B]->uiHeight * 256 /
+			ntsipu->img[IMG_DST]->uiHeight;
+		IpuRequest(step_h,                                 IMG_HSTEP);
+		IpuRequest(step_v,                                 IMG_VSTEP);
+
+		/* fold */
+		fold_h =
+			ntsipu->img[IMG_DST]->uiWidth  * 64 /
+			ntsipu->img[IMG_SRC_B]->uiWidth;
+		fold_v =
+			ntsipu->img[IMG_DST]->uiHeight * 64 /
+			ntsipu->img[IMG_SRC_B]->uiHeight;
+		IpuRequest(fold_h,                                 IMG_HFOLD);
+		IpuRequest(fold_v,                                 IMG_VFOLD);
+	}
+
+	if (ulImgMode & IMG_OVERLAY_BIT) {
+		/*==============================
+		    source Front image
+		================================*/
+		IpuRequest(ntsipu->img[IMG_SRC_F]->ulPhysAddrYRGB,
+			IMG_SRCYRGBADR_F);
+		IpuRequest(ntsipu->img[IMG_SRC_F]->ulPhysAddrUV,
+			IMG_SRCUVADR_F);
+		IpuRequest(ntsipu->img[IMG_SRC_F]->ulPhysAddrV,
+			IMG_SRCVADR_F);
+		IpuRequest(ntsipu->img[IMG_SRC_F]->uiScreenWidth,
+			IMG_SRCSIZE_F);
+		IpuRequest(ntsipu->img[IMG_SRC_F]->uiWidth,
+			IMG_SRCHSIZE_F);
+		IpuRequest(ntsipu->img[IMG_SRC_F]->uiHeight,
+			IMG_SRCVSIZE_F);
+
+		/* overlay */
+		IpuRequest(ntsipu->img[IMG_DST]->uiX,              IMG_OFFSETX);
+		IpuRequest(ntsipu->img[IMG_DST]->uiY,              IMG_OFFSETY);
+
+		if (((ulImgMode & IMG_OP_MODE_BIT) == IMG_OP_MODE_12_BIT) ||
+			((ulImgMode & IMG_OP_MODE_BIT) == IMG_OP_MODE_18_BIT)) {
+			/* maskcolor */
+			IpuRequest(ntsipu->ntsc->from_fb.maskcolr,
+				IMG_MASKCOLR);
+			IpuRequest(ntsipu->ntsc->from_fb.alpha,    IMG_ALPHA);
+		}
+	}
+
+	/*==============================
+	    Start IMG
+	================================*/
+	IpuRequest(IMG_REQ_BIT, IMG_REQ);
+
+	/*==============================
+	    end mark
+	================================*/
+	IpuRequest(IPU_REG_INFO_END, IPU_REG_INFO_END);
+
+#if _DEBUG_NTSIPU
+	printk_dbg((_DEBUG_NTSIPU & 0x02),
+	 "=== mp200_ipu_regist() =======================================\n");
+	printk_dbg((_DEBUG_NTSIPU & 0x02), " IMG_MODE(0x%08lx)\n", ulImgMode);
+	if (ulImgMode & IMG_OVERLAY_BIT) {
+		printk_dbg((_DEBUG_NTSIPU & 0x02),
+			 "-------+----------------------"
+			 "--------------------------------\n");
+		printk_dbg((_DEBUG_NTSIPU & 0x02),
+			" SRC_F | Y(%08lx)  U(%08lx)  V(%08lx)\n",
+			ntsipu->img[IMG_SRC_F]->ulPhysAddrYRGB,
+			ntsipu->img[IMG_SRC_F]->ulPhysAddrUV,
+			ntsipu->img[IMG_SRC_F]->ulPhysAddrV);
+		printk_dbg((_DEBUG_NTSIPU & 0x02),
+			"       | p(%3d)  w(%3d)  h(%3d)   x(%3d)  y(%3d)\n",
+			ntsipu->img[IMG_SRC_F]->uiScreenWidth,
+			ntsipu->img[IMG_SRC_F]->uiWidth,
+			ntsipu->img[IMG_SRC_F]->uiHeight,
+			ntsipu->img[IMG_SRC_F]->uiX,
+			ntsipu->img[IMG_SRC_F]->uiY);
+	}
+	printk_dbg((_DEBUG_NTSIPU & 0x02),
+	 "-------+------------------------------------------------------\n");
+	printk_dbg((_DEBUG_NTSIPU & 0x02),
+	 " SRC_B | Y(%08lx)  U(%08lx)  V(%08lx)\n",
+	 ntsipu->img[IMG_SRC_B]->ulPhysAddrYRGB,
+	 ntsipu->img[IMG_SRC_B]->ulPhysAddrUV,
+	 ntsipu->img[IMG_SRC_B]->ulPhysAddrV);
+	printk_dbg((_DEBUG_NTSIPU & 0x02),
+	 "       | p(%3d)  w(%3d)  h(%3d)   x(%3d)  y(%3d)\n",
+	 ntsipu->img[IMG_SRC_B]->uiScreenWidth,
+	 ntsipu->img[IMG_SRC_B]->uiWidth,
+	 ntsipu->img[IMG_SRC_B]->uiHeight,
+	 ntsipu->img[IMG_SRC_B]->uiX,
+	 ntsipu->img[IMG_SRC_B]->uiY);
+	printk_dbg((_DEBUG_NTSIPU & 0x02),
+	 "-------+------------------------------------------------------\n");
+	printk_dbg((_DEBUG_NTSIPU & 0x02),
+	 " DST   | Y(%08lx)  U(%08lx)  V(%08lx)\n",
+	 ntsipu->img[IMG_DST]->ulPhysAddrYRGB,
+	 ntsipu->img[IMG_DST]->ulPhysAddrUV,
+	 ntsipu->img[IMG_DST]->ulPhysAddrV);
+	printk_dbg((_DEBUG_NTSIPU & 0x02),
+	 "       | p(%3d)  w(%3d)  h(%3d)   x(%3d)  y(%3d)\n",
+	 ntsipu->img[IMG_DST]->uiScreenWidth,
+	 ntsipu->img[IMG_DST]->uiWidth,
+	 ntsipu->img[IMG_DST]->uiHeight,
+	 ntsipu->img[IMG_DST]->uiX, ntsipu->img[IMG_DST]->uiY);
+	printk_dbg((_DEBUG_NTSIPU & 0x02),
+	 "==============================================================\n\n");
+#endif
+	return 0;
+}
+
+
+/* ------------------ private function < GDMA > ---------------------------- */
+/******************************************************************************
+* MODULE   : ntsipu_callback_ipugdma
+* FUNCTION : changing frame and callback to fb and v4l2
+* RETURN   : none
+* NOTE     : none
+* CREATE   : 2009.1.15 M.Haguro
+* UPDATE   :
+******************************************************************************/
+static void ntsipu_callback_ipugdma(unsigned long sequence, int flag)
+{
+	unsigned long flags;
+	spin_lock_irqsave(&ntsipu->ntsc->lock_callback, flags);
+	printk_dbg((_DEBUG_NTSIPU & 0x01), "\n");
+
+	/* wakeup mainhandle */
+	ntsipu->gdma_complete = 1;
+	wake_up_interruptible(&ntsipu->wait_gdma);
+
+	spin_unlock_irqrestore(&ntsipu->ntsc->lock_callback, flags);
+}
+
+
+/*****************************************************************************
+* MODULE   : ntsipu_chk_ipugdma
+* FUNCTION :
+* RETURN   : -
+* NOTE     :
+* CREATE   : 2009.1.13 M.Haguro
+* UPDATE   :
+******************************************************************************/
+static int ntsipu_chk_ipugdma(void)
+{
+	struct image_data *old = NULL;
+	int index = 0, iRet = 0;
+
+	printk_dbg((_DEBUG_NTSIPU & 0x01), "\n");
+
+	if (ntsipu->ntsc->iFrameNoNow == NTS_DISP_FRAME_A) {
+		old = ntsipu->old[OLD_FRAME_B];
+		if (old->uiWidth == 0)
+			goto failed;
+
+	} else { /* NTS_DISP_FRAME_B */
+		old = ntsipu->old[OLD_FRAME_A];
+		if (old->uiWidth == 0)
+			goto failed;
+
+	}
+
+	if (ntsipu->gdma[index]->uiX == old->uiX
+	 && ntsipu->gdma[index]->uiWidth == old->uiWidth
+	 && ntsipu->gdma[index]->uiY == old->uiY
+	 && ntsipu->gdma[index]->uiHeight == old->uiHeight) {
+		goto failed;
+	}
+
+	if (ntsipu->img[IMG_DST]->uiY > old->uiY) {
+		/* need fillrect */
+		iRet = 1;
+	}
+	if (ntsipu->img[IMG_DST]->uiX > old->uiX) {
+		/* need fillrect */
+		iRet = 1;
+	}
+	if (ntsipu->img[IMG_DST]->uiX + ntsipu->img[IMG_DST]->uiWidth
+	 < old->uiX + old->uiWidth) {
+		/* need fillrect */
+		iRet = 1;
+	}
+	if (ntsipu->img[IMG_DST]->uiY + ntsipu->img[IMG_DST]->uiHeight
+	 < old->uiY + old->uiHeight) {
+		/* need fillrect */
+		iRet = 1;
+	}
+
+	if (iRet) {
+		printk_dbg((_DEBUG_NTSIPU & 0x02), "all fill\n");
+		memcpy(ntsipu->gdma[index], ntsipu->img[IMG_DST],
+			sizeof(struct image_data));
+
+		ntsipu->gdma[index]->uiX      = old->uiX;
+		ntsipu->gdma[index]->uiY      = old->uiY;
+		ntsipu->gdma[index]->uiWidth  = old->uiWidth;
+		ntsipu->gdma[index]->uiHeight = old->uiHeight;
+
+		/* request IPU-GDMA */
+		iRet = ntsipu_gdma_request(index);
+		if (iRet) {
+			printk_dbg((_DEBUG_NTSIPU & 0x02), "gdma_request(%d)\n",
+			 iRet);
+		}
+	}
+
+failed:
+	memcpy(old, ntsipu->img[IMG_DST], sizeof(struct image_data));
+
+	return iRet;
+}
+
+
+/*****************************************************************************
+* MODULE   : ntsipu_gdma_request
+* FUNCTION :
+* RETURN   : -
+* NOTE     :
+* CREATE   : 2009.1.22 M.Haguro
+* UPDATE   :
+******************************************************************************/
+static int ntsipu_gdma_request(int index)
+{
+	int iRet;
+
+	iRet = ntsipu_set_ipugdma(index);
+	if (iRet) {
+		printk_dbg((_DEBUG_NTSIPU & 0x02), "(%d) error\n", __LINE__);
+		goto failed;
+	}
+	ntsipu->ipu_request[index]->callback    = ntsipu_callback_ipugdma;
+	ntsipu->ipu_request[index]->ipu_hw_func = IPU_HW_FUNC_GDMA;
+	ntsipu->ipu_request[index]->data        = 0l;
+
+	/* request IPU */
+	ntsipu->gdma_complete = 0;
+	iRet = mp200_ipu_regist(
+		(struct mp200_ipu_req *)(ntsipu->ipu_request[index]));
+	if (iRet) {
+		printk_dbg((_DEBUG_NTSIPU & 0x02), "ipu_regist(%d)\n", iRet);
+		goto failed;
+	}
+	wait_event_interruptible(ntsipu->wait_gdma, ntsipu->gdma_complete);
+
+failed:
+	memset(ntsipu->gdma[index],        0, sizeof(struct image_data));
+	memset(ntsipu->ipu_request[index], 0, sizeof(MAX_SIZE_MP200_IPU_REQ));
+	return iRet;
+}
+
+
+/*****************************************************************************
+* MODULE   : ntsipu_set_ipugdma
+* FUNCTION :
+* RETURN   : -
+* NOTE     :
+* CREATE   : 2009.1.14 M.Haguro
+* UPDATE   :
+******************************************************************************/
+static int ntsipu_set_ipugdma(int index)
+{
+	unsigned long ulGdmaMode, ulFillData;
+	unsigned int  uiScreenPixcelWidthY;
+	unsigned int  uiScreenPixcelWidthUV;
+	unsigned int  uiScreenPixcelWidthV;
+	int bpp_y, bpp_uv, bpp_v; /* bit par pixel  */
+	int ppl_y, ppl_uv, ppl_v; /* pixel par line */
+	int index_req = 0;
+
+	printk_dbg((_DEBUG_NTSIPU & 0x01), "index(%d)\n", index);
+
+	/*******************************
+	    set GDMA register
+	********************************/
+	ulGdmaMode = DMA_OP_FILL;
+	ulFillData = 0x80008000; /* black */
+
+
+	switch (ntsipu->gdma[index]->uiFormat) {
+	case DMA_FORMAT_YUV422_SEMI_PLANAR: /* YUV422 Semi-Planar */
+		printk_dbg((_DEBUG_NTSIPU & 0x02), "src_b_format(YUV422Pl2)\n");
+		bpp_y = 8;  bpp_uv = 8; bpp_v = 0;
+		ppl_y = 1; ppl_uv = 1; ppl_v = 0;
+		uiScreenPixcelWidthY  =
+			ntsipu->gdma[index]->uiScreenWidth / bpp_y  * 8;
+		uiScreenPixcelWidthUV =
+			ntsipu->gdma[index]->uiScreenWidth / bpp_uv * 8;
+		uiScreenPixcelWidthV  = 0;
+		ntsipu->gdma[index]->ulPhysAddrYRGB =
+			ntsipu->gdma[index]->ulPhysAddrYRGB +
+			ntsipu->gdma[index]->uiY * uiScreenPixcelWidthY /
+			ppl_y  + ntsipu->gdma[index]->uiX * bpp_y  / 8;
+		ntsipu->gdma[index]->ulPhysAddrUV   =
+			ntsipu->gdma[index]->ulPhysAddrUV +
+			ntsipu->gdma[index]->uiY * uiScreenPixcelWidthUV /
+			ppl_uv + ntsipu->gdma[index]->uiX * bpp_uv / 8;
+		ntsipu->gdma[index]->ulPhysAddrYRGB &= ~0x03;
+		ntsipu->gdma[index]->ulPhysAddrUV   &= ~0x03;
+		ntsipu->gdma[index]->ulPhysAddrV    = 0;
+
+
+		printk_dbg((_DEBUG_NTSIPU & 0x02),
+			"=== mp200_ipu_regist() "
+			"=======================================\n");
+		printk_dbg((_DEBUG_NTSIPU & 0x02),
+			" DMA_MODE(0x%08lx)\n", ulGdmaMode);
+		printk_dbg((_DEBUG_NTSIPU & 0x02),
+			"-------+-----------------------"
+			"-------------------------------\n");
+		printk_dbg((_DEBUG_NTSIPU & 0x02),
+			" DST   | Y(%08lx)  U(%08lx)  V(%08lx)\n",
+			ntsipu->gdma[index]->ulPhysAddrYRGB,
+			ntsipu->gdma[index]->ulPhysAddrUV,
+			ntsipu->gdma[index]->ulPhysAddrV);
+		printk_dbg((_DEBUG_NTSIPU & 0x02),
+			"       | p(%3d)  w(%3d)  h(%3d)   x(%3d)  y(%3d)\n",
+			ntsipu->gdma[index]->uiScreenWidth,
+			ntsipu->gdma[index]->uiWidth,
+			ntsipu->gdma[index]->uiHeight,
+			ntsipu->gdma[index]->uiX, ntsipu->gdma[index]->uiY);
+		printk_dbg((_DEBUG_NTSIPU & 0x02),
+			"==============================="
+			"===============================\n\n");
+		break;
+	default:
+		return -1;
+	}
+
+
+	/*==============================
+	    GDMA_MODE
+	================================*/
+	IpuRequest(ulGdmaMode,                          DMA_MODE);
+	IpuRequest(ulFillData,                          DMA_FILLDATA);
+
+	/*==============================
+	    destination image
+	================================*/
+	IpuRequest(ntsipu->gdma[index]->uiFormat,       DMA_FORMAT);
+	IpuRequest(ntsipu->gdma[index]->uiWidth,        DMA_HSIZE);
+#ifdef NTSC_ERRATA
+	if (ntsipu->ntsc->iOutmodeFlg == NTS_OUTPUT_NTSC &&
+		errata->ntsc_upscale == NTS_UPSCALE_OFF) {
+		if (ntsipu->gdma[index]->uiY % 2) {
+			IpuRequest(ntsipu->gdma[index]->uiHeight + 2,
+			 DMA_VSIZE);
+			ntsipu->gdma[index]->ulPhysAddrYRGB -=
+				ntsipu->gdma[index]->uiScreenWidth;
+			ntsipu->gdma[index]->ulPhysAddrUV   -=
+				ntsipu->gdma[index]->uiScreenWidth;
+		} else {
+			IpuRequest(ntsipu->gdma[index]->uiHeight,    DMA_VSIZE);
+		}
+	} else {
+		IpuRequest(ntsipu->gdma[index]->uiHeight, DMA_VSIZE);
+	}
+#else
+	IpuRequest(ntsipu->gdma[index]->uiHeight,       DMA_VSIZE);
+#endif /* NTSC_ERRATA */
+	IpuRequest(ntsipu->gdma[index]->uiScreenWidth,  DMA_DSTSIZE);
+	IpuRequest(ntsipu->gdma[index]->ulPhysAddrYRGB, DMA_DSTYRGBADR);
+	IpuRequest(ntsipu->gdma[index]->ulPhysAddrUV,   DMA_DSTUVADR);
+	IpuRequest(ntsipu->gdma[index]->ulPhysAddrV,    DMA_DSTVADR);
+
+	/*==============================
+	    Start GDMA
+	================================*/
+	IpuRequest(DMA_REQ_BIT,                         DMA_REQ);
+
+	/*==============================
+	    end mark
+	================================*/
+	IpuRequest(IPU_REG_INFO_END,                    IPU_REG_INFO_END);
+
+	return 0;
+}
+
+
diff --git a/drivers/video/mp200/nts/mp200_ntsipu.h b/drivers/video/mp200/nts/mp200_ntsipu.h
new file mode 100644
index 0000000..ff02986
--- /dev/null
+++ b/drivers/video/mp200/nts/mp200_ntsipu.h
@@ -0,0 +1,59 @@
+/*
+ * File Name       : /drivers/video/mp200/nts/mp200_ntsipu.h
+ * Function        : NTSC Driver corresponding to V4L2 (IPU Control)
+ * Release Version : Ver 1.00
+ * Release Date    : 2008/10/29
+ *
+ * Copyright (C) NEC Electronics Corporation 2008
+ *
+ *
+ * This program is free software;you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by Free Softwere
+ * Foundation; either version 2 of License, or (at your option) any later
+ * version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warrnty of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
+ * details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; If not, write to the Free Software Foundation, Inc., 59 Temple
+ * Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+
+#ifndef _MP200_NTSIPU_H_
+#define _MP200_NTSIPU_H_
+
+
+
+/********************************************************
+ *  Structure                                           *
+ *******************************************************/
+struct image_data {
+	unsigned long ulPhysAddrYRGB;
+	unsigned long ulPhysAddrUV;
+	unsigned long ulPhysAddrV;
+	unsigned int  uiWidth;
+	unsigned int  uiHeight;
+	unsigned int  uiX;
+	unsigned int  uiY;
+	unsigned int  uiScreenWidth;
+	unsigned int  uiFormat;
+	unsigned int  uiEndian;
+};
+
+
+/********************************************************
+ *  Prototype declarations of function                  *
+ *******************************************************/
+extern int  ntsipu_initialize(struct mp200_nts_dev *ntsc);
+extern void ntsipu_finitialize(void);
+extern int  ntsipu_img_request(void);
+extern int  ntsipu_clr_framebuf(struct image_data *buff);
+
+
+
+#endif /* _MP200_NTSIPU_H_ */
diff --git a/drivers/video/mp200/nts/ntsc.h b/drivers/video/mp200/nts/ntsc.h
new file mode 100644
index 0000000..271e232
--- /dev/null
+++ b/drivers/video/mp200/nts/ntsc.h
@@ -0,0 +1,302 @@
+/*
+ * File Name       : /drivers/video/mp200/nts/ntsc.h
+ * Function        : NTS MMIO definitions
+ * Release Version : Ver 1.01
+ * Release Date    : 2009/10/19
+ *
+ * Copyright (C) NEC Electronics Corporation 2009
+ *
+ *
+ * This program is free software;you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by Free Softwere
+ * Foundation; either version 2 of License, or (at your option) any later
+ * version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warrnty of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
+ * details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; If not, write to the Free Software Foundation, Inc., 59 Temple
+ * Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#ifndef _NTS_H_
+#define _NTS_H_
+
+
+/*****************************************************************************
+ * NTSC MMIO definitions
+ *****************************************************************************/
+
+#include <mach/hardware.h>
+#define NTSC_OFFSET	MP200_NTSC_OFFSET
+#define NTSC_BASE	MP200_NTSC_BASE
+#define NTSC_SIZE	MP200_NTSC_SIZE
+
+
+/*                                                     R/W   Bit  Reset */
+/*----------------------------------------------------------------------------
+ * Output Settings Register
+ */
+/* Control for NTSC                                    R/W   3:0  0x0 */
+#define NTS_CONTROL             (0x00)
+
+/* NTS Output                                          R/W   1:0  0x0 */
+#define NTS_OUT                 (0x04)
+
+/* Status for NTSC                                      R    1:0  0x0 */
+#define NTS_STATUS              (0x08)
+
+/* AREA Address for Frame Buffer A (Y Plane)           R/W  31:2  0x0000_0000 */
+#define NTS_YAREAAD_A           (0x0C)
+
+/* AREA Address for Frame Buffer B (Y Plane)           R/W  31:2  0x0000_0000 */
+#define NTS_YAREAAD_B           (0x10)
+
+/* AREA Address for Frame Buffer C (Y Plane)           R/W  31:2  0x0000_0000 */
+#define NTS_YAREAAD_C           (0x14)
+
+/* AREA Address for Frame Buffer A (UV Interleave)     R/W  31:2  0x0000_0000 */
+#define NTS_UVAREAAD_A          (0x18)
+
+/* AREA Address for Frame Buffer B (UV Interleave)     R/W  31:2  0x0000_0000 */
+#define NTS_UVAREAAD_B          (0x1C)
+
+/* AREA Address for Frame Buffer C (UV Interleave)     R/W  31:2  0x0000_0000 */
+#define NTS_UVAREAAD_C          (0x20)
+
+/* Horizontal OFFSET Size                              R/W  12:2  0x0000 */
+#define NTS_HOFFSET             (0x24)
+
+/* Frame Select                                        R/W   1:0  0x1 */
+#define NTS_FRAMESEL            (0x28)
+
+/*----------------------------------------------------------------------------
+ * Interuppt Setting Register
+ */
+/* Interrupt Status                                     R    4:0  0x0 */
+#define NTS_INTSTATUS           (0x60)
+
+/* Interrupt Raw Status                                 R    4:0  0x0 */
+#define NTS_INTRAWSTATUS        (0x64)
+
+/* Interrupt Enable Set                                R/W   4:0  0x0 */
+#define NTS_INTENSET            (0x68)
+
+/* Interrupt Enable Clear                               W    4:0  0x0 */
+#define NTS_INTENCLR            (0x6C)
+
+/* Interrupt Status Clear                               W    4:0  0x0 */
+#define NTS_INTFFCLR            (0x70)
+
+/* Error Address                                       R/W  31:0  0x0000_0000 */
+#define NTS_ERRORADR            (0x74)
+
+/* NTS Software Reset                                  R/W   0:0  0x0 */
+#define NTS_SWRESET             (0x78)
+
+
+
+
+
+
+
+
+
+
+/*----------------------------------------------------------------------------
+ * Output Settings Register
+ */
+/*------------------------------*/
+/* NTS_CONTROL                  */
+/*------------------------------*/
+#define NTS_UPSCALE_BIT		0x00000008
+#define NTS_UPSCALE_SFT		0x03
+#define NTS_UPSCALE_ON		0x08
+#define NTS_UPSCALE_OFF		0x00
+
+#define NTS_OUTMODE_BIT		0x00000004
+#define NTS_OUTMODE_SFT		0x02
+#define NTS_OUTMODE_PAL		0x04
+#define NTS_OUTMODE_NTSC	0x00
+
+#define NTS_CLKPOL_BIT		0x00000002
+#define NTS_CLKPOL_SFT		0x01
+
+#define NTS_ENDIAN_BIT		0x00000001
+#define NTS_ENDIAN_SFT		0x00
+#define NTS_ENDIAN_BIGEN	0x01
+#define NTS_ENDIAN_LITTLEEN	0x00
+
+/*------------------------------*/
+/* NTS_OUT                      */
+/*------------------------------*/
+#define NTS_NTSOUT_BIT		0x00000003
+#define NTS_NTSOUT_SFT		0x00
+#define NTS_NTSOUT_ENABLE	0x03
+#define NTS_NTSOUT_ENABLE_BLUE	0x02
+#define NTS_NTSOUT_ENABLE_BLACK	0x01
+#define NTS_NTSOUT_DISABLE	0x00
+
+/*------------------------------*/
+/* NTS_STATUS                   */
+/*------------------------------*/
+#define NTS_STATUS_BIT		0x00000003
+#define NTS_STATUS_SFT		0x00
+#define NTS_STATUS_ENABLE	0x03
+#define NTS_STATUS_ENABLE_BLUE	0x02
+#define NTS_STATUS_ENABLE_BLACK	0x01
+#define NTS_STATUS_DISABLE	0x00
+
+/*------------------------------*/
+/* NTS_AREAAD                   */
+/*------------------------------*/
+#define NTS_AREAAD_A		0x00
+#define NTS_AREAAD_B		0x04
+#define NTS_AREAAD_C		0x08
+
+/*------------------------------*/
+/* NTS_YAREAAD                  */
+/*------------------------------*/
+#define NTS_YAREAADR_BIT	0xFFFFFFFF
+#define NTS_YAREAADR_SFT	0x00
+#define NTS_YAREAADR_ALINE	0x03
+
+/*------------------------------*/
+/* NTS_UVAREAAD                 */
+/*------------------------------*/
+#define NTS_UVAREAADR_BIT	0xFFFFFFFF
+#define NTS_UVAREAADR_SFT	0x00
+#define NTS_UVAREAADR_ALINE	0x03
+
+/*------------------------------*/
+/* NTS_HOFFSET                  */
+/*------------------------------*/
+#define NTS_HOFFSET_BIT		0x00001FFF
+#define NTS_HOFFSET_SFT		0x00
+#define NTS_HOFFSET_ALINE	0x03
+
+/*------------------------------*/
+/* NTS_FRAMESEL                 */
+/*------------------------------*/
+#define NTS_AREASTATUS_BIT	0x0000000C
+#define NTS_AREASTATUS_SFT	0x02
+#define NTS_AREASTATUS_BUFC	0x0C
+#define NTS_AREASTATUS_BUFB	0x08
+#define NTS_AREASTATUS_BUFA	0x04
+#define NTS_AREASTATUS_BUFINIT	0x00
+
+#define NTS_AREASEL_BIT		0x00000003
+#define NTS_AREASEL_SFT		0x00
+#define NTS_AREASEL_BUFC	0x03
+#define NTS_AREASEL_BUFB	0x02
+#define NTS_AREASEL_BUFA	0x01
+#define NTS_AREASEL_BUFDISABLE	0x00
+
+/*----------------------------------------------------------------------------
+ * Interuppt Setting Register
+ */
+#define INT_UNDERRUN_BIT	0x00000008
+#define INT_UNDERRUN_SFT	0x03
+#define INT_DMASTOP_BIT		0x00000004
+#define INT_DMASTOP_SFT		0x02
+#define INT_DMAERR_BIT		0x00000002
+#define INT_DMAERR_SFT		0x01
+#define INT_NTSVS_BIT		0x00000001
+#define INT_NTSVS_SFT		0x00
+
+/*------------------------------*/
+/* NTS_INTSTATUS                */
+/*------------------------------*/
+#define NTS_UNDERRUN_BIT	INT_UNDERRUN_BIT
+#define NTS_UNDERRUN_SFT	INT_UNDERRUN_SFT
+#define NTS_DMASTOP_BIT		INT_DMASTOP_BIT
+#define NTS_DMASTOP_SFT		INT_DMASTOP_SFT
+#define NTS_DMAERR_BIT		INT_DMAERR_BIT
+#define NTS_DMAERR_SFT		INT_DMAERR_SFT
+#define NTS_NTSVS_BIT		INT_NTSVS_BIT
+#define NTS_NTSVS_SFT		INT_NTSVS_SFT
+
+/*------------------------------*/
+/* NTS_INTRAWSTATUS             */
+/*------------------------------*/
+#define NTS_UNDERRUNRAW_BIT	INT_UNDERRUN_BIT
+#define NTS_UNDERRUNRAW_SFT	INT_UNDERRUN_SFT
+#define NTS_DMASTOPRAW_BIT	INT_DMASTOP_BIT
+#define NTS_DMASTOPRAW_SFT	INT_DMASTOP_SFT
+#define NTS_DMAERRRAW_BIT	INT_DMAERR_BIT
+#define NTS_DMAERRRAW_SFT	INT_DMAERR_SFT
+#define NTS_NTSVSRAW_BIT	INT_NTSVS_BIT
+#define NTS_NTSVSRAW_SFT	INT_NTSVS_SFT
+
+/*------------------------------*/
+/* NTS_INTENSET                 */
+/*------------------------------*/
+#define NTS_UNDERRUNEN_BIT	INT_UNDERRUN_BIT
+#define NTS_UNDERRUNEN_SFT	INT_UNDERRUN_SFT
+#define NTS_DMASTOPEN_BIT	INT_DMASTOP_BIT
+#define NTS_DMASTOPEN_SFT	INT_DMASTOP_SFT
+#define NTS_DMAERREN_BIT	INT_DMAERR_BIT
+#define NTS_DMAERREN_SFT	INT_DMAERR_SFT
+#define NTS_NTSVSEN_BIT		INT_NTSVS_BIT
+#define NTS_NTSVSEN_SFT		INT_NTSVS_SFT
+
+#define NTS_INTENSET_ALL_BIT \
+	(NTS_UNDERRUNEN_BIT | NTS_DMASTOPEN_BIT | \
+	NTS_DMAERREN_BIT | NTS_NTSVSEN_BIT)
+
+/*------------------------------*/
+/* NTS_INTENCLR                 */
+/*------------------------------*/
+#define NTS_UNDERRUNMASK_BIT	INT_UNDERRUN_BIT
+#define NTS_UNDERRUNMASK_SFT	INT_UNDERRUN_SFT
+#define NTS_DMASTOPMASK_BIT	INT_DMASTOP_BIT
+#define NTS_DMASTOPMASK_SFT	INT_DMASTOP_SFT
+#define NTS_DMAERRMASK_BIT	INT_DMAERR_BIT
+#define NTS_DMAERRMASK_SFT	INT_DMAERR_SFT
+#define NTS_NTSVSMASK_BIT	INT_NTSVS_BIT
+#define NTS_NTSVSMASK_SFT	INT_NTSVS_SFT
+
+#define NTS_INTENCLR_ALL_BIT \
+	(NTS_UNDERRUNMASK_BIT | NTS_DMASTOPMASK_BIT | \
+	NTS_DMAERRMASK_BIT | NTS_NTSVSMASK_BIT)
+
+/*------------------------------*/
+/* NTS_INTFFCLR                 */
+/*------------------------------*/
+#define NTS_UNDERRUNCLR_BIT	INT_UNDERRUN_BIT
+#define NTS_UNDERRUNCLR_SFT	INT_UNDERRUN_SFT
+#define NTS_DMASTOPCLR_BIT	INT_DMASTOP_BIT
+#define NTS_DMASTOPCLR_SFT	INT_DMASTOP_SFT
+#define NTS_DMAERRCLR_BIT	INT_DMAERR_BIT
+#define NTS_DMAERRCLR_SFT	INT_DMAERR_SFT
+#define NTS_NTSVSCLR_BIT	INT_NTSVS_BIT
+#define NTS_NTSVSCLR_SFT	INT_NTSVS_SFT
+
+#define NTS_INTFFCLR_ALL_BIT \
+	(NTS_UNDERRUNCLR_BIT | NTS_DMASTOPCLR_BIT | \
+	NTS_DMAERRCLR_BIT | NTS_NTSVSCLR_BIT)
+
+/*------------------------------*/
+/* NTS_ERRORADR                 */
+/*------------------------------*/
+#define NTS_ERRADR_BIT		0xFFFFFFFC
+#define NTS_FCCLR_SFT		0x02
+
+#define NTS_LOCK_BIT		0x00000001
+#define NTS_LOCK_SFT		0x00
+
+/*------------------------------*/
+/* NTS_SWRESET                  */
+/*------------------------------*/
+#define NTS_SWRESET_BIT		0x00000001
+#define NTS_SWRESET_SFT		0x00
+#define NTS_SWRESET_ON		0x01
+#define NTS_SWRESET_OFF		0x00
+
+
+
+#endif /* _NTS_H_ */
-- 
1.6.5.2

