From 08b4c2159f8c77c22f71e03a0b93a195db949f21 Mon Sep 17 00:00:00 2001
From: Kazuya Tsukamoto <kazuya.tsukamoto@necel.com>
Date: Mon, 9 Nov 2009 11:25:30 +0900
Subject: [PATCH 05/29] nec_em1: add dma driver

The EMMA mobile 1 DMAC has a restriction that there is an upper bound
in the size that can be set at mp200_start_dma.

Note: a part of function might be deleted, because it will be not used
on the system of target in the future.

Signed-off-by: Kazuya Tsukamoto <kazuya.tsukamoto@necel.com>
---
 arch/arm/mach-mp200/dma.c              | 1071 ++++++++++++++++++++++++++++++++
 arch/arm/mach-mp200/dma.h              |  130 ++++
 arch/arm/mach-mp200/include/mach/dma.h |  344 ++++++++++
 3 files changed, 1545 insertions(+), 0 deletions(-)
 create mode 100644 arch/arm/mach-mp200/dma.c
 create mode 100644 arch/arm/mach-mp200/dma.h
 create mode 100644 arch/arm/mach-mp200/include/mach/dma.h

diff --git a/arch/arm/mach-mp200/dma.c b/arch/arm/mach-mp200/dma.c
new file mode 100644
index 0000000..8c0fbdb
--- /dev/null
+++ b/arch/arm/mach-mp200/dma.c
@@ -0,0 +1,1071 @@
+/*
+ *  File Name		: linux/arch/arm/mach-mp200/dma.c
+ *  Function		: dmac
+ *  Release Version 	: Ver 1.02
+ *  Release Date	: 2009/07/22
+ *
+ *  Copyright (C) NEC Electronics Corporation 2009
+ *
+ *  This program is free software;you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License as published by Free
+ *  Softwere Foundation; either version 2 of License, or (at your option) any
+ *  later version.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY;
+ *  without even the implied warrnty of MERCHANTABILITY or FITNESS FOR A
+ *  PARTICULAR PURPOSE.
+ *  See the GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program;
+ *  If not, write to the Free Software Foundation, Inc., 59 Temple Place -
+ *  Suite 330, Boston,
+ *  MA 02111-1307, USA.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <asm/irq.h>
+#include <asm/dma.h>
+
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <mach/pmu.h>
+
+#include "dma.h"
+
+/****  Prototype definition  ****/
+
+static int setup_M2M(dma_regs_t *regs, dma_addr_t src_ptr, u_int size,
+	dma_addr_t dst_ptr, u_int32_t mode);
+static int setup_M2P(dma_regs_t *regs, dma_addr_t src_ptr, u_int size,
+	dma_addr_t dst_ptr, u_int32_t mode);
+static int setup_P2M(dma_regs_t *regs, dma_addr_t src_ptr, u_int size,
+	dma_addr_t dst_ptr, u_int32_t mode);
+
+/****  Global variables (within this file)  ****/
+static int dma_tclk_users;	/* Number of TCLK users. */
+
+/****  Structured data definition  ****/
+
+/* for physical channel #0 */
+mp200_dmal_t dma_pch0_lch[MP200_DMAC_P0_MAX_L_CHANNELS] = {
+	{
+		.name    = "ARM M->M0",
+		.defmode = MP200_DMAC_DEFMODE_32BIT,
+		.special = 0,
+	},
+	{
+		.name    = "ARM M->M1",
+		.defmode = MP200_DMAC_DEFMODE_32BIT,
+		.special = 0,
+	},
+	{
+		.name    = "ARM M->M2",
+		.defmode = MP200_DMAC_DEFMODE_32BIT,
+		.special = 0,
+	},
+	{
+		.name    = "ARM M->M3",
+		.defmode = MP200_DMAC_DEFMODE_32BIT,
+		.special = 0,
+	},
+};
+
+/* for physical channel #2 */
+mp200_dmal_t dma_pch2_lch[MP200_DMAC_P2_MAX_L_CHANNELS] = {
+	{
+		.name    = "M->P0",
+		.defmode = MP200_DMAC_DEFMODE_8BIT,
+		.special = SPEC_TIMEOUT,
+	},
+	{
+		.name    = "M->P1",
+		.defmode = MP200_DMAC_DEFMODE_8BIT,
+		.special = SPEC_TIMEOUT,
+	},
+	{
+		.name    = "M->P2",
+		.defmode = MP200_DMAC_DEFMODE_8BIT,
+		.special = SPEC_TIMEOUT,
+	},
+	{
+		.name    = "M->P3",
+		.defmode = MP200_DMAC_DEFMODE_16BIT,
+		.special = SPEC_TIMEOUT,
+	},
+	{
+		.name    = "M->P4",
+		.defmode = MP200_DMAC_DEFMODE_16BIT,
+		.special = 0,
+	},
+	{
+		.name    = "M->P5",
+		.defmode = MP200_DMAC_DEFMODE_16BIT,
+		.special = 0,
+	},
+	{ /* dummy */
+		.name    = "M->P6",
+		.defmode = MP200_DMAC_DEFMODE_32BIT,
+		.special = 0,
+	},
+	{
+		.name    = "M->P7",
+		.defmode = MP200_DMAC_DEFMODE_32BIT,
+		.special = SPEC_TIMEOUT,
+	},
+	{ /* dummy */
+		.name    = "M->P8",
+		.defmode = MP200_DMAC_DEFMODE_32BIT,
+		.special = 0,
+	},
+	{
+		.name    = "M->P9",
+		.defmode = MP200_DMAC_DEFMODE_32BIT,
+		.special = 0,
+	},
+	{
+		.name    = "M->P10",
+		.defmode = MP200_DMAC_DEFMODE_32BIT,
+		.special = 0,
+	},
+	{
+		.name    = "M->P11",
+		.defmode = MP200_DMAC_DEFMODE_32BIT,
+		.special = 0,
+	},
+	{
+		.name    = "M->P12",
+		.defmode = MP200_DMAC_DEFMODE_32BIT,
+		.special = 0,
+	},
+	{
+		.name    = "M->P13",
+		.defmode = MP200_DMAC_DEFMODE_32BIT,
+		.special = 0,
+	},
+	{
+		.name    = "M->P14",
+		.defmode = MP200_DMAC_DEFMODE_32BIT,
+		.special = 0,
+	},
+};
+/* for physical channel #3 */
+mp200_dmal_t dma_pch3_lch[MP200_DMAC_P3_MAX_L_CHANNELS] = {
+	{
+		.name    = "P->M0",
+		.defmode = MP200_DMAC_DEFMODE_8BIT,
+		.special = SPEC_TIMEOUT,
+	},
+	{
+		.name    = "P->M1",
+		.defmode = MP200_DMAC_DEFMODE_8BIT,
+		.special = SPEC_TIMEOUT,
+	},
+	{
+		.name    = "P->M2",
+		.defmode = MP200_DMAC_DEFMODE_8BIT,
+		.special = SPEC_TIMEOUT,
+	},
+	{
+		.name    = "P->M3",
+		.defmode = MP200_DMAC_DEFMODE_16BIT,
+		.special = SPEC_TIMEOUT,
+	},
+	{
+		.name    = "P->M4",
+		.defmode = MP200_DMAC_DEFMODE_16BIT,
+		.special = 0,
+	},
+	{
+		.name    = "P->M5",
+		.defmode = MP200_DMAC_DEFMODE_16BIT,
+		.special = 0,
+	},
+	{ /* dummy */
+		.name    = "P->M6",
+		.defmode = MP200_DMAC_DEFMODE_16BIT,
+		.special = 0,
+	},
+	{
+		.name    = "P->M7",
+		.defmode = MP200_DMAC_DEFMODE_16BIT,
+		.special = SPEC_TIMEOUT,
+	},
+	{ /* dummy */
+		.name    = "M->P8",
+		.defmode = MP200_DMAC_DEFMODE_32BIT,
+		.special = 0,
+	},
+	{
+		.name    = "P->M9",
+		.defmode = MP200_DMAC_DEFMODE_32BIT,
+		.special = 0,
+	},
+	{
+		.name    = "P->M10",
+		.defmode = MP200_DMAC_DEFMODE_32BIT,
+		.special = 0,
+	},
+	{
+		.name    = "P->M11",
+		.defmode = MP200_DMAC_DEFMODE_32BIT,
+		.special = 0,
+	},
+	{
+		.name    = "P->M12",
+		.defmode = MP200_DMAC_DEFMODE_32BIT,
+		.special = 0,
+	},
+	{
+		.name    = "P->M13",
+		.defmode = MP200_DMAC_DEFMODE_32BIT,
+		.special = 0,
+	},
+	{
+		.name    = "P->M14",
+		.defmode = MP200_DMAC_DEFMODE_32BIT,
+		.special = 0,
+	},
+};
+
+/* for every physical channels (4ch) */
+mp200_dmap_t dma_pch[MP200_DMAC_MAX_P_CHANNELS] = {
+	{ /* PCH #0 */
+		.control   = (cntsts_t *)IO_ADDRESS(MP200_DMAC_BASE),
+		.intstat   = (intparm_t *)IO_ADDRESS(MP200_DMAC_BASE + 0x0100),
+		.intsel    = (intdest_t *)IO_ADDRESS(MP200_DMAC_BASE + 0x0800),
+		.parbase   = (dma_regs_t *)IO_ADDRESS(MP200_DMAC_BASE + 0x1000),
+		.lch       = dma_pch0_lch,
+		.lchno     = MP200_DMAC_P0_MAX_L_CHANNELS,
+		.not_int   = ~(MP200_DMAC_INT_LENG_RD
+				| MP200_DMAC_INT_BLOCK_RD),
+		.setup_dma = setup_M2M,
+	},
+	{ /* PCH #1 dummy */
+		.lchno     = MP200_DMAC_P1_MAX_L_CHANNELS,
+	},
+	{ /* PCH #2 */
+		.control   = (cntsts_t *)IO_ADDRESS(MP200_DMAC_BASE + 0x4000),
+		.intstat   = (intparm_t *)IO_ADDRESS(MP200_DMAC_BASE + 0x4100),
+		.intsel    = (intdest_t *)IO_ADDRESS(MP200_DMAC_BASE + 0x4800),
+		.parbase   = (dma_regs_t *)IO_ADDRESS(MP200_DMAC_BASE + 0x5000),
+		.lch       = dma_pch2_lch,
+		.lchno     = MP200_DMAC_P2_MAX_L_CHANNELS,
+		.not_int   = ~(MP200_DMAC_INT_LENG_RD),
+		.setup_dma = setup_M2P,
+	},
+	{ /* PCH #3 */
+		.control   = (cntsts_t *)IO_ADDRESS(MP200_DMAC_BASE + 0x6000),
+		.intstat   = (intparm_t *)IO_ADDRESS(MP200_DMAC_BASE + 0x6100),
+		.intsel    = (intdest_t *)IO_ADDRESS(MP200_DMAC_BASE + 0x6800),
+		.parbase   = (dma_regs_t *)IO_ADDRESS(MP200_DMAC_BASE + 0x7000),
+		.lch       = dma_pch3_lch,
+		.lchno     = MP200_DMAC_P3_MAX_L_CHANNELS,
+		.not_int   = ~(MP200_DMAC_INT_LENG_RD),
+		.setup_dma = setup_P2M,
+	},
+};
+
+
+/*
+ * Check channel number
+ */
+static inline int check_validity_channel(int channel)
+{
+	unsigned int pchno;
+	unsigned int lchno;
+
+	pchno = MP200_DMAC_PCHNO(channel);
+	lchno = MP200_DMAC_LCHNO(channel);
+
+	if ((channel & ~(MP200_DMAC_MASK_CHNO | MP200_DMAC_MASK_OWNER)) == 0) {
+		if (((pchno == 0) && (lchno < MP200_DMAC_P0_MAX_L_CHANNELS))
+		  || ((pchno == 2) && (lchno < MP200_DMAC_P2_MAX_L_CHANNELS))
+		  || ((pchno == 3) && (lchno < MP200_DMAC_P3_MAX_L_CHANNELS))) {
+			return 0;
+		}
+	}
+
+	return 1;
+}
+
+/*
+ * Functions for default settings.
+ *
+ * Each function sets DMA up to appropriate default setting when
+ * `size' is not 0. Skip parameter settings except source and destination
+ * addresses when `size' is 0 so that client driver can use special mode
+ * like repeat transfer, timeout, etc.
+ */
+
+/* PCH #0 */
+static int setup_M2M(dma_regs_t *regs, dma_addr_t src_ptr, u_int size,
+		dma_addr_t dst_ptr, u_int32_t mode)
+{
+	u_int blocksize, offset;
+
+	if (size == 0) {	/* short cut for special transfer mode */
+		regs->aadd = src_ptr;
+		regs->badd = dst_ptr;
+		return 0;
+	}
+
+	/*
+	 * size != 0
+	 * Handle just two contiguous memory region, source and destination.
+	 * Simple transfer, but these may be overlapped.
+	 */
+	if ((size & ~MP200_DMAC_MASK_LENGTH) != 0)
+		return 1;
+
+	/*
+	 * Determine which mode to use.
+	 */
+	offset = 0 | MP200_DMAC_OFFSET_ADD; /* default is forward transfer */
+
+	 /* ignore wrap-around case */
+	if (dst_ptr <= src_ptr && src_ptr < dst_ptr + size) {
+		if (src_ptr < dst_ptr + MP200_DMAC_SIZE_BLKSIZES) {
+			/* Difference between src_ptr and dst_ptr must be
+			   greater than MP200_DMAC_SIZE_BLKSIZES. */
+			return 1;
+		}
+		/*
+		 * overlap, copy forward
+		 * It may not need to use multi-block transfer.
+		 */
+		if (src_ptr < dst_ptr + MP200_DMAC_SIZE_BLKSIZEL)
+			blocksize = MP200_DMAC_SIZE_BLKSIZES;
+		else
+			blocksize = MP200_DMAC_SIZE_BLKSIZEL;
+
+	/* ignore wrap-around case */
+	} else if (src_ptr < dst_ptr && dst_ptr < src_ptr + size) {
+		u_int sharesize, isolatesize;
+
+		isolatesize = dst_ptr - src_ptr;
+		if (isolatesize < MP200_DMAC_SIZE_BLKSIZES) {
+			/* Difference between src_ptr and dst_ptr must be
+			   greater than MP200_DMAC_SIZE_BLKSIZES. */
+			return 1;
+		}
+		sharesize = size - isolatesize;
+		/*
+		 * overlap, copy backward
+		 */
+		if (size % isolatesize == 0) {
+			/*
+			 * It's most likely that backward copy is used for video
+			 * console back scroll.
+			 * In that case, offset between source and destination
+			 * is equal to one line, and size, most likely, can be
+			 * divided by it. (Assume one line, does not fit for
+			 * scrolling multiple lines.)
+			 */
+			 blocksize = isolatesize;
+		} else {
+			/*
+			 * Copy with block size MP200_DMAC_SIZE_BLKSIZEMIN.
+			 * This will cause inefficiency around bus traffic.
+			 * It may be better that this case does not exist and
+			 * handle as error.
+			 */
+			blocksize = MP200_DMAC_SIZE_BLKSIZEMIN;
+		}
+		src_ptr += size - blocksize;
+		dst_ptr += size - blocksize;
+		offset = blocksize * 2 | MP200_DMAC_OFFSET_SUB;
+	} else if ((size & ~MP200_DMAC_MASK_BLKSIZE) == 0) {
+		/*
+		 * does not overlap, small enough to use single block transfer
+		 */
+		blocksize = size;
+	} else {
+		/*
+		 * does not overlap, greater than 65534, use multiple block
+		 * transfer
+		 */
+		blocksize = MP200_DMAC_SIZE_BLKSIZEL;
+	}
+	/*
+	 * setup DMAC registers
+	 */
+	regs->aadd = src_ptr;
+	regs->badd = dst_ptr;
+	regs->aoff = offset;
+	regs->boff = offset;
+	regs->asize_count = 0;
+	regs->bsize_count = 0;
+	regs->leng = size;
+	regs->size = blocksize;
+	regs->mode = mode;
+
+	return 0;
+}
+
+/* PCH #2 */
+static int setup_M2P(dma_regs_t *regs, dma_addr_t src_ptr, u_int size,
+		   dma_addr_t dst_ptr, u_int32_t mode)
+{
+	u_int blocksize;
+
+	if (size == 0) {	/* short cut for special transfer mode */
+		regs->aadd = src_ptr;
+		regs->badd = dst_ptr;
+		return 0;
+	}
+
+	if ((size & ~MP200_DMAC_MASK_LENGTH) != 0)
+		return 1;
+
+	if ((size & ~MP200_DMAC_MASK_BLKSIZE) == 0) {
+		/* use single block transfer */
+		blocksize = size;
+	} else {
+		/* use multiple block transfer */
+		blocksize = MP200_DMAC_SIZE_BLKSIZEL;
+	}
+	regs->aadd = src_ptr;
+	regs->badd = dst_ptr;
+	regs->aoff = 0;
+	regs->asize_count = 0;
+	regs->asize = blocksize;
+	regs->leng = size;
+	regs->mode = mode;
+
+	return 0;
+}
+
+/* PCH #3 */
+static int setup_P2M(dma_regs_t *regs, dma_addr_t src_ptr, u_int size,
+		   dma_addr_t dst_ptr, u_int32_t mode)
+{
+	u_int blocksize;
+
+	if (size == 0) {	/* short cut for special transfer mode */
+		regs->aadd = src_ptr;
+		regs->badd = dst_ptr;
+		return 0;
+	}
+
+	if ((size & ~MP200_DMAC_MASK_LENGTH) != 0)
+		return 1;
+
+	if ((size & ~MP200_DMAC_MASK_BLKSIZE) == 0) {
+		/* use single block transfer */
+		blocksize = size;
+	} else {
+		/* use multiple block transfer */
+		blocksize = MP200_DMAC_SIZE_BLKSIZEL;
+	}
+
+	regs->aadd = src_ptr;
+	regs->badd = dst_ptr;
+	regs->boff = 0;
+	regs->bsize_count = 0;
+	regs->bsize = blocksize;
+	regs->leng = size;
+	regs->mode = mode;
+
+	return 0;
+}
+
+/*
+ * Interrupt Handler
+ */
+static irqreturn_t dma_irq_handler(int irq, void *dev_id)
+{
+	mp200_dmap_t *pch;
+	mp200_dmal_t *lch;
+	dma_regs_t   *regs = dev_id;
+	int           chno;
+	int           stshift;
+	intparm_t    *intcnt;
+	unsigned int  sts;
+	unsigned int  rawsts;
+	int           err;
+
+	/*
+	 * We can compute channel number from address of control registers
+	 */
+	chno = MP200_DMAC_PARBASE2CHNO(regs);
+	err = check_validity_channel(chno);
+	if (err != 0)
+		return IRQ_NONE;
+
+	pch = &dma_pch[MP200_DMAC_PCHNO(chno)];
+
+	/*
+	 * Check interrupt status.
+	 *  If it's not for this channel then return.
+	 */
+	intcnt = pch->intstat + MP200_DMAC_LCHNO(chno) / 4;
+
+	stshift = (MP200_DMAC_LCHNO(chno) % 4) * 8;
+	sts = (intcnt->stat >> stshift) & 0xff;
+	/* Some bits are not cause of interrupt. */
+	if ((sts & pch->not_int) == 0)
+		return IRQ_NONE; /* there is no interrupt */
+
+	rawsts = (intcnt->raw_stat >> stshift) & 0xff;
+
+	/* clear interrupt status */
+	intcnt->clear = sts << stshift;
+
+	/* call client driver's interrupt handling routine */
+	lch = pch->lch + MP200_DMAC_LCHNO(chno);
+	lch->callback(lch->data, sts, rawsts);
+
+	return IRQ_HANDLED;
+}
+
+
+/****  External functions  ****/
+
+/*
+ * Acquire DMA channel
+ *   mp200_request_dma()
+ */
+int mp200_request_dma(int channel, const char *device_id,
+	 dma_callback_t callback, void *data, dma_regs_t **dma_regs)
+{
+	mp200_dmap_t *pch;
+	mp200_dmal_t *lch;
+	dma_regs_t   *regs;
+	unsigned int  intdest;
+	int           err;
+	int           owner;
+
+	err = check_validity_channel(channel);
+	if (err != 0)
+		return -ENODEV;
+
+	pch = &dma_pch[MP200_DMAC_PCHNO(channel)];
+	if (pch->lch == NULL)
+		return -ENODEV;
+
+	lch = pch->lch + MP200_DMAC_LCHNO(channel);
+	if (lch->in_use != DMA_NO_USE)
+		return -EBUSY;
+
+	regs = pch->parbase + MP200_DMAC_LCHNO(channel);
+	owner = MP200_DMAC_OWNER(channel);
+
+	/*
+	 * Stop desired DMA channel to make it sure before
+	 * interrupt related settings.
+	 */
+#if 0 /* Because of errata, can't stop DMA here. */
+	mp200_clear_dma(channel);
+#endif
+
+	if (owner == MP200_DMAC_OWNER(MP200_DMAC_OWNER_ACPU)) {
+		err = request_irq(INT_DMAPE0, dma_irq_handler,
+			(IRQF_SHARED | IRQF_DISABLED), device_id, regs);
+		if (err != 0) {
+			printk(KERN_INFO "%s(): unable to request IRQ %d for DMA channel (%s)\n",
+				__func__, INT_DMAPE0, device_id);
+			return err;
+		}
+	}
+
+	/*
+	 * Set interrupt output line to the PE which executing this routine.
+	 * XXX needs mutual exclusion between PE's
+	 */
+	intdest = pch->intsel->intdest;
+	intdest &= ~(3 << (MP200_DMAC_LCHNO(channel) * 2));
+	intdest |= owner << (MP200_DMAC_LCHNO(channel) * 2);
+	pch->intsel->intdest = intdest;
+
+	/*
+	 * Supply TCLK if needed.
+	 */
+	if (lch->special & SPEC_TIMEOUT) {
+		if (dma_tclk_users == 0)
+			mp200_pmu_open_clockgate(MP200_CLOCKGATE_DMA_TCLK);
+		dma_tclk_users++;
+	}
+
+	/*
+	 * RESET does not initialize some DMAC registers.
+	 * Set DMA channel to known state (for single block transfer) here
+	 * so that stabilizing phenomena caused by client code
+	 * lacks register setting (bug).
+	 * Use cold start address where most likely boot ROM exists.
+	 */
+	(void)pch->setup_dma(regs, 0x0, 0x1000, 0x0, lch->defmode);
+
+	/*
+	 * Hold information for further DMAC operations.
+	 */
+	lch->in_use = DMA_USE;
+	lch->owner = owner;
+	lch->callback = callback;
+	lch->data = data;
+
+	/*
+	 * return pointer to control registers.
+	 */
+	if (dma_regs != NULL)
+		*dma_regs = regs;
+
+	return 0;
+}
+EXPORT_SYMBOL(mp200_request_dma);
+
+/*
+ * Release DMA channel
+ */
+void mp200_free_dma(int channel)
+{
+	mp200_dmap_t  *pch;
+	mp200_dmal_t  *lch;
+	dma_regs_t    *regs;
+	int            err;
+
+	err = check_validity_channel(channel);
+	if (err != 0)
+		return;
+
+	pch = &dma_pch[MP200_DMAC_PCHNO(channel)];
+	if (pch->lch == NULL)
+		return;
+
+	lch = pch->lch + MP200_DMAC_LCHNO(channel);
+	if (lch->in_use != DMA_USE)
+		return;
+
+	if (lch->owner != MP200_DMAC_OWNER(channel))
+		return;
+
+	/*
+	 * Stop DMA
+	 */
+	mp200_clear_dma(channel);
+
+	/*
+	 * Stop TCLK if possible.
+	 */
+	if (lch->special & SPEC_TIMEOUT) {
+		dma_tclk_users--;
+		if (dma_tclk_users == 0)
+			mp200_pmu_close_clockgate(MP200_CLOCKGATE_DMA_TCLK);
+	}
+
+	/*
+	 * Release interrupt
+	 */
+	if (lch->owner == MP200_DMAC_OWNER(MP200_DMAC_OWNER_ACPU)) {
+		regs = pch->parbase + MP200_DMAC_LCHNO(channel);
+		free_irq(INT_DMAPE0, regs);
+	}
+
+	lch->in_use = DMA_NO_USE;
+	lch->callback = NULL;
+	lch->data = NULL;
+
+	return;
+}
+EXPORT_SYMBOL(mp200_free_dma);
+
+/*
+ * Setup and enable DMA.
+ */
+int mp200_start_dma(int channel, dma_addr_t src_ptr, u_int size,
+			   dma_addr_t dst_ptr, int intmask)
+{
+	mp200_dmap_t *pch;
+	mp200_dmal_t *lch;
+	dma_regs_t   *regs;
+	int           stshift;
+	intparm_t    *intcnt;
+	cntsts_t     *base;
+	int           err;
+
+	err = check_validity_channel(channel);
+	if (err != 0)
+		return -ENODEV;
+
+	if ((intmask & ~MP200_DMAC_MASK_INT) != 0)
+		return -EINVAL;
+
+	pch = &dma_pch[MP200_DMAC_PCHNO(channel)];
+	if (pch->lch == NULL)
+		return -ENODEV;
+
+	lch = pch->lch + MP200_DMAC_LCHNO(channel);
+	if (lch->in_use != DMA_USE)
+		return -ENXIO;
+
+	if (lch->owner != MP200_DMAC_OWNER(channel))
+		return -ENODEV;
+
+	if ((intmask != 0) && (lch->callback == NULL))
+		return -EINVAL;
+
+	/*
+	 * Set DMA channel up to appropriate default setting.
+	 */
+	regs = pch->parbase + MP200_DMAC_LCHNO(channel);
+	err = pch->setup_dma(regs, src_ptr, size, dst_ptr, lch->defmode);
+	if (err != 0)
+		return -EINVAL;
+
+	/*
+	 * When size > 65534 or overlapped source and destination, we need to
+	 * use multiple block transfer.
+	 * But we don't need block interrupt, so mask it when size != 0.
+	 */
+	if (size != 0)
+		intmask &= ~MP200_DMAC_INT_BLOCK_EN;
+
+	/*
+	 * Enable interrupt.
+	 * At first, disable all interrupt, then enable desired interrupt.
+	 */
+	intcnt = pch->intstat + MP200_DMAC_LCHNO(channel) / 4;
+
+	stshift = (MP200_DMAC_LCHNO(channel) % 4) * 8;
+	intcnt->disable = 0xff << stshift;
+	intcnt->clear = 0xff << stshift;
+	intcnt->enable = (unsigned char)intmask << stshift;
+
+	/*
+	 * Enable DMA.
+	 */
+	base = pch->control;
+	base->start = 1 << MP200_DMAC_LCHNO(channel);
+
+	return 0;
+}
+EXPORT_SYMBOL(mp200_start_dma);
+
+/*
+ * Acquire DMA channel status.
+ */
+int mp200_dma_status(int channel)
+{
+	mp200_dmap_t *pch;
+	mp200_dmal_t *lch;
+	int           stat;
+	cntsts_t     *base;
+	int           err;
+
+	err = check_validity_channel(channel);
+	if (err != 0)
+		return -ENODEV;
+
+	pch = &dma_pch[MP200_DMAC_PCHNO(channel)];
+	if (pch->lch == NULL)
+		return -ENODEV;
+
+	lch = pch->lch + MP200_DMAC_LCHNO(channel);
+	/* does not check `in_use'. can read status of any DMA channel */
+
+	/*
+	 * Read status register, return corresponding bit.
+	 */
+	base = pch->control;
+	stat = (base->status >> MP200_DMAC_LCHNO(channel)) & 1;
+
+	return stat;
+}
+EXPORT_SYMBOL(mp200_dma_status);
+
+/*
+ * Acquire DMA channel status (register writable flag).
+ */
+int mp200_dma_writable_flag(int channel)
+{
+	mp200_dmap_t *pch;
+	mp200_dmal_t *lch;
+	int           stat;
+	cntsts_t     *base;
+	int           err;
+
+	err = check_validity_channel(channel);
+	if (err != 0)
+		return -ENODEV;
+
+	pch = &dma_pch[MP200_DMAC_PCHNO(channel)];
+	if (pch->lch == NULL)
+		return -ENODEV;
+
+	lch = pch->lch + MP200_DMAC_LCHNO(channel);
+	/* does not check `in_use'. can read status of any DMA channel */
+
+	/*
+	 * Read status register, return corresponding bit.
+	 */
+	base = pch->control;
+	stat = (base->status >> (16 + MP200_DMAC_LCHNO(channel))) & 1;
+
+	return stat;
+}
+EXPORT_SYMBOL(mp200_dma_writable_flag);
+
+/*
+ * Acquire all DMA channel status.
+ * check all DMA channels,
+ * return 1 if there is enabled channel.
+ * Don't start DMA channel while calling this function.
+ */
+int mp200_dma_busy(void)
+{
+	int p;
+	int l;
+	cntsts_t     *base;
+	mp200_dmal_t *lch;
+
+	for (p = 0 ; p < MP200_DMAC_MAX_P_CHANNELS ; p++) {
+		for (l = 0 ; l < dma_pch[p].lchno ; l++) {
+			lch = dma_pch[p].lch + l;
+			if (lch->in_use == DMA_USE) {
+				base = dma_pch[p].control;
+				if (((base->status >> l) & 1) != 0)
+					return 1;
+
+			}
+		}
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(mp200_dma_busy);
+
+/*
+ * Stop DMA channel.
+ */
+void mp200_clear_dma(int channel)
+{
+	mp200_dmap_t *pch;
+	mp200_dmal_t *lch;
+	cntsts_t     *base;
+	intparm_t    *intcnt;
+	int stshift;
+	int err;
+	int stat;
+
+	err = check_validity_channel(channel);
+	if (err != 0)
+		return;
+
+	pch = &dma_pch[MP200_DMAC_PCHNO(channel)];
+	if (pch->lch == NULL)
+		return;
+
+	lch = pch->lch + MP200_DMAC_LCHNO(channel);
+	if (lch->in_use != DMA_USE)
+		return;
+	if (lch->owner != MP200_DMAC_OWNER(channel))
+		return;
+
+	/*
+	 * disable all interrupt
+	 */
+	intcnt = pch->intstat + MP200_DMAC_LCHNO(channel) / 4;
+
+	stshift = (MP200_DMAC_LCHNO(channel) % 4) * 8;
+	intcnt->disable = 0xff << stshift;
+	intcnt->clear = 0xff << stshift;
+
+	/*
+	 * stop DMA
+	 */
+	base = pch->control;
+	base->stop = 1 << MP200_DMAC_LCHNO(channel);
+	/* Until DMA stops, polling */
+	for (stat = 1; stat != 0;)
+		stat = (base->status >> MP200_DMAC_LCHNO(channel)) & 1 ;
+}
+EXPORT_SYMBOL(mp200_clear_dma);
+
+/*
+ * Stop DMA channel too.
+ */
+void mp200_reset_dma(int channel)
+{
+	mp200_clear_dma(channel);
+}
+EXPORT_SYMBOL(mp200_reset_dma);
+
+/*
+ * Retrieve current DMA position.
+ */
+dma_addr_t mp200_get_dma_pos(int channel)
+{
+	mp200_dmap_t *pch;
+	mp200_dmal_t *lch;
+	dma_regs_t   *regs;
+	int err;
+
+	err = check_validity_channel(channel);
+	if (err != 0)
+		return 0;
+
+	pch = &dma_pch[MP200_DMAC_PCHNO(channel)];
+	if (pch->lch == NULL)
+		return 0;
+
+	lch = pch->lch + MP200_DMAC_LCHNO(channel);
+	/* does not check `in_use'. can read position of any DMA channel */
+	regs = pch->parbase + MP200_DMAC_LCHNO(channel);
+
+	switch (MP200_DMAC_PCHNO(channel)) {
+	case 0:
+	case 1:
+	case 2:
+		return regs->aadp;
+		break;
+	case 3:
+		return regs->badp;
+		break;
+	default:
+		break;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(mp200_get_dma_pos);
+
+/*
+ * Stop DMA.
+ * We'd like to suspend DMA instead of stopping, if we can.
+ * Unfortunately, DMAC on MP200 can't suspend, we stop DMA at this moment.
+ * (can't resume)
+ */
+void mp200_stop_dma(int channel)
+{
+	mp200_dmap_t *pch;
+	mp200_dmal_t *lch;
+	cntsts_t     *base;
+	intparm_t    *intcnt;
+	int stshift;
+	int err;
+	int stat;
+
+	err = check_validity_channel(channel);
+	if (err != 0)
+		return;
+
+	pch = &dma_pch[MP200_DMAC_PCHNO(channel)];
+	if (pch->lch == NULL)
+		return;
+
+	lch = pch->lch + MP200_DMAC_LCHNO(channel);
+	if (lch->in_use != DMA_USE)
+		return;
+
+	if (lch->owner != MP200_DMAC_OWNER(channel))
+		return;
+
+	/*
+	 * disable all interrupt
+	 */
+	intcnt = pch->intstat + MP200_DMAC_LCHNO(channel) / 4;
+
+	stshift = (MP200_DMAC_LCHNO(channel) % 4) * 8;
+	intcnt->disable = 0xff << stshift;
+	intcnt->clear = 0xff << stshift;
+
+	/*
+	 * stop DMA
+	 */
+	base = pch->control;
+	base->stop = 1 << MP200_DMAC_LCHNO(channel);
+	/* Until DMA stops, polling */
+	for (stat = 1; stat != 0;)
+		stat = (base->status >> MP200_DMAC_LCHNO(channel)) & 1 ;
+
+}
+EXPORT_SYMBOL(mp200_stop_dma);
+
+static int dma_suspend(struct platform_device *dev, pm_message_t state)
+{
+	switch (state.event) {
+	case DEV_SUSPEND_IDLE_1:
+	case PM_EVENT_SUSPEND:
+		if (mp200_dma_busy())
+			return -EBUSY;
+		break;
+	default:
+		break;
+	}
+	return 0;
+}
+
+static int dma_resume(struct platform_device *dev)
+{
+	return 0;
+}
+
+static int dma_probe(struct platform_device *dev)
+{
+	int i;
+
+	/* open all clock gate for DMAC (except TCLK) */
+	mp200_pmu_open_clockgate(MP200_CLOCKGATE_DMA_PCLK);
+	mp200_pmu_open_clockgate(MP200_CLOCKGATE_DMA_PCH0_CLK);
+	mp200_pmu_open_clockgate(MP200_CLOCKGATE_DMA_PCH2_CLK);
+	mp200_pmu_open_clockgate(MP200_CLOCKGATE_DMA_PCH3_CLK);
+	/* disable automatic clock supply control (for reset). */
+	mp200_pmu_clkctrl_off(MP200_CLKCTRL_DMAPCLK);
+	mp200_pmu_clkctrl_off(MP200_CLKCTRL_DMAPCH0);
+	mp200_pmu_clkctrl_off(MP200_CLKCTRL_DMAPCH2);
+	mp200_pmu_clkctrl_off(MP200_CLKCTRL_DMAPCH3);
+	/* release reset */
+	mp200_pmu_unreset_device(MP200_RESETDEVICE_DMA);
+	/* mp200_pmu_unreset_device() waits apropriate period.
+	   Now, we can enable automatic clock control. */
+	mp200_pmu_clkctrl_on(MP200_CLKCTRL_DMAPCLK);
+	mp200_pmu_clkctrl_on(MP200_CLKCTRL_DMAPCH0);
+	mp200_pmu_clkctrl_on(MP200_CLKCTRL_DMAPCH2);
+	mp200_pmu_clkctrl_on(MP200_CLKCTRL_DMAPCH3);
+
+	for (i = 0 ; i < MP200_DMAC_P0_MAX_L_CHANNELS ; i++) {
+		dma_pch0_lch[i].callback = NULL;
+		dma_pch0_lch[i].data = NULL;
+		dma_pch0_lch[i].in_use = DMA_NO_USE;
+	}
+	for (i = 0 ; i < MP200_DMAC_P2_MAX_L_CHANNELS ; i++) {
+		dma_pch2_lch[i].callback = NULL;
+		dma_pch2_lch[i].data = NULL;
+		dma_pch2_lch[i].in_use = DMA_NO_USE;
+	}
+	for (i = 0 ; i < MP200_DMAC_P3_MAX_L_CHANNELS ; i++) {
+		dma_pch3_lch[i].callback = NULL;
+		dma_pch3_lch[i].data = NULL;
+		dma_pch3_lch[i].in_use = DMA_NO_USE;
+	}
+
+	return 0;
+}
+
+static struct platform_driver dma_driver = {
+	.probe   = dma_probe,
+	.suspend = dma_suspend,
+	.resume  = dma_resume,
+	.driver  = {
+		.name  = "dma",
+		.owner = THIS_MODULE,
+	},
+};
+
+
+/*
+ * Initialize
+ */
+static int __init mp200_dma_init(void)
+{
+	dma_tclk_users = 0;	/* Number of TCLK users. */
+
+	return platform_driver_register(&dma_driver);
+}
+
+arch_initcall(mp200_dma_init);
+
diff --git a/arch/arm/mach-mp200/dma.h b/arch/arm/mach-mp200/dma.h
new file mode 100644
index 0000000..1f48048
--- /dev/null
+++ b/arch/arm/mach-mp200/dma.h
@@ -0,0 +1,130 @@
+/*
+ *  File Name	    : linux/arch/arm/mach-mp200/dma.h
+ *  Function	    : dmac
+ *  Release Version : Ver 1.02
+ *  Release Date    : 2009/07/22
+ *
+ *  Copyright (C) NEC Electronics Corporation 2009
+ *
+ *
+ *  This program is free software;you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License as published by Free
+ *  Softwere Foundation; either version 2 of License, or (at your option) any
+ *  later version.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY;
+ *  without even the implied warrnty of MERCHANTABILITY or FITNESS FOR A
+ *  PARTICULAR PURPOSE.
+ *  See the GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program;
+ *  If not, write to the Free Software Foundation, Inc., 59 Temple Place -
+ *  Suite 330, Boston,
+ *  MA 02111-1307, USA.
+ *
+ */
+
+#ifndef __ARCH_ARM_MACH_MP200_DMA_H
+#define __ARCH_ARM_MACH_MP200_DMA_H
+
+
+/****  Macro definition  ****/
+
+#define MP200_DMAC_MASK_CHNO		0x000000ef
+#define	MP200_DMAC_MASK_OWNER		0x03000000
+#define MP200_DMAC_MASK_BLKSIZE 	0x0000ffff
+#define MP200_DMAC_MASK_LENGTH		0x00ffffff
+#define MP200_DMAC_MASK_INT		(MP200_DMAC_INT_TIME_EN \
+					| MP200_DMAC_INT_ERROR_EN \
+					| MP200_DMAC_INT_BLOCK_EN \
+					| MP200_DMAC_INT_LENG_EN)
+#define	MP200_DMAC_SIZE_BLKSIZEL	0x00001000
+#define	MP200_DMAC_SIZE_BLKSIZES	0x00000080
+#define	MP200_DMAC_SIZE_BLKSIZEMIN	0x00000001
+
+
+/****  Macro function  ****/
+
+#define MP200_DMAC_PCHNO(x)        (((x) & 0xe0) >> 5)
+#define MP200_DMAC_LCHNO(x)        ((x) & 0x0f)
+#define MP200_DMAC_PARBASE2CHNO(x) ((((long)(x)) >> 8) & MP200_DMAC_MASK_CHNO)
+#define MP200_DMAC_OWNER(x)        (((x) & MP200_DMAC_MASK_OWNER) >> 24)
+
+
+/****  Structure definition  ****/
+
+/*
+ * MP200 DMAC register arrangement
+ */
+#define reg_volatile	volatile
+
+/* control registers */
+struct cntsts_ {
+    reg_volatile u_int32_t	start;	/* +0x00 DMA start control */
+    reg_volatile u_int32_t	status; /* +0x04 DMA status */
+    reg_volatile u_int32_t	stop;	/* +0x08 DMA stop control */
+};
+#define cntsts_t	struct cntsts_
+
+/*
+ * interrupt related parameter registers
+ */
+struct intparm_ {
+    reg_volatile u_int32_t	stat;		/* +0x00 interrupt status */
+    reg_volatile u_int32_t	raw_stat;	/* +0x04 interrupt raw status */
+    reg_volatile u_int32_t	enable; 	/* +0x08 interrupt enable */
+    reg_volatile u_int32_t	disable;	/* +0x0c interrupt disable */
+    reg_volatile u_int32_t	clear;		/* +0x10 interrupt clear */
+    reg_volatile u_int32_t	rsv[3];		/* +0x14,0x18,0x1c Reserved */
+};
+#define intparm_t	struct intparm_
+
+/*
+ * interrupt destination setting register
+ */
+struct intdest_ {
+    reg_volatile u_int32_t intdest;	/* +0x00 interrupt destination */
+} intdest_t;
+#define intdest_t	struct intdest_
+
+/*
+ * Data for managing logical DMA channels
+ */
+struct mp200_dmal_ {
+    const char      *name;		/* irq name of L-channel. */
+    dma_callback_t  callback;	/* call-back function from interrupt. */
+    void            *data;		/* argument of call-back function. */
+    u_int32_t       defmode;	/* default transfer mode. */
+    u_int8_t        special; 	/* Special ability for this LCH. */
+#define	SPEC_TIMEOUT	1	/* This LCH has timeout function. */
+    u_int8_t        in_use; 	/* DMA in use flag. */
+    u_int8_t        owner; 	/* Holder of this LCH. (ACPU/CCPU/DSP) */
+};
+#define mp200_dmal_t	struct mp200_dmal_
+
+/* for `in_use' setting */
+#define DMA_NO_USE	0
+#define DMA_USE 	1
+
+/*
+ * Data for managing physical DMA channels
+ */
+struct mp200_dmap_ {
+	cntsts_t     *control;	/* control/status regs. */
+	intparm_t    *intstat;	/* interrupt control regs. */
+	intdest_t    *intsel;	/* interrupt destination setting reg. */
+	dma_regs_t   *parbase;	/* base of parameter registers array. */
+	mp200_dmal_t *lch;	/* control structures for logical CH. */
+	u_int32_t    lchno;	/* No. of logical channel. */
+	u_int32_t    not_int;	/* Interrupt status register contains
+				   some bits that are not cause of
+				   interrupt, just indicate status.
+				   We must mask out them. How stupid! */
+	int          (*setup_dma)(dma_regs_t *, dma_addr_t, u_int, dma_addr_t,
+				u_int32_t);
+};
+#define mp200_dmap_t	struct mp200_dmap_
+
+#endif /* __ARCH_ARM_MACH_MP200_DMA_H */
diff --git a/arch/arm/mach-mp200/include/mach/dma.h b/arch/arm/mach-mp200/include/mach/dma.h
new file mode 100644
index 0000000..4d5fed2
--- /dev/null
+++ b/arch/arm/mach-mp200/include/mach/dma.h
@@ -0,0 +1,344 @@
+/*
+ *  File Name	    : linux/include/asm-arm/arch-mp200/dma.h
+ *  Function	    : dmac
+ *  Release Version : Ver 1.01
+ *  Release Date    : 2009/07.23
+ *
+ *  Copyright (C) NEC Electronics Corporation 2006-2009
+ *
+ *
+ *  This program is free software;you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License as published by Free
+ *  Softwere Foundation; either version 2 of License, or (at your option) any
+ *  later version.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY;
+ *  without even the implied warrnty of MERCHANTABILITY or FITNESS FOR A
+ *  PARTICULAR PURPOSE.
+ *  See the GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; If not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#ifndef __ASM_ARM_ARCH_MP200_DMA_H
+#define __ASM_ARM_ARCH_MP200_DMA_H
+
+#define MAX_DMA_ADDRESS 		0xffffffff
+#define MAX_DMA_CHANNELS		0	/* don't use standard DMA I/F */
+
+#define MP200_DMAC_MAX_P_CHANNELS	4
+
+#define	MP200_DMAC_OWNER_ACPU		0x00000000
+#define	MP200_DMAC_OWNER_CCPU		0x01000000
+#define	MP200_DMAC_OWNER_DSP		0x03000000
+
+/* DMAC logical channel ID */
+
+/* P0 for ACPU */
+#define MP200_DMAC_M2M_ACPU_LCH0	(0x00|MP200_DMAC_OWNER_ACPU) /* M2M */
+#define MP200_DMAC_ARM_LCH0		MP200_DMAC_M2M_ACPU_LCH0
+#define MP200_DMAC_M2M_ACPU_LCH1	(0x01|MP200_DMAC_OWNER_ACPU) /* M2M */
+#define MP200_DMAC_ARM_LCH1		MP200_DMAC_M2M_ACPU_LCH1
+#define MP200_DMAC_M2M_ACPU_LCH2	(0x02|MP200_DMAC_OWNER_ACPU) /* M2M */
+#define MP200_DMAC_ARM_LCH2		MP200_DMAC_M2M_ACPU_LCH2
+#define MP200_DMAC_M2M_ACPU_LCH3	(0x03|MP200_DMAC_OWNER_ACPU) /* M2M */
+#define MP200_DMAC_ARM_LCH3		MP200_DMAC_M2M_ACPU_LCH3
+/* P0 for CCPU */
+#define MP200_DMAC_M2M_CCPU_LCH0	(0x00|MP200_DMAC_OWNER_CCPU) /* M2M */
+#define MP200_DMAC_M2M_CCPU_LCH1	(0x01|MP200_DMAC_OWNER_CCPU) /* M2M */
+#define MP200_DMAC_M2M_CCPU_LCH2	(0x02|MP200_DMAC_OWNER_CCPU) /* M2M */
+#define MP200_DMAC_M2M_CCPU_LCH3	(0x03|MP200_DMAC_OWNER_CCPU) /* M2M */
+/* P0 for DSP */
+#define MP200_DMAC_M2M_DSP_LCH0		(0x00|MP200_DMAC_OWNER_DSP) /* M2M */
+#define MP200_DMAC_M2M_DSP_LCH1		(0x01|MP200_DMAC_OWNER_DSP) /* M2M */
+#define MP200_DMAC_M2M_DSP_LCH2		(0x02|MP200_DMAC_OWNER_DSP) /* M2M */
+#define MP200_DMAC_M2M_DSP_LCH3		(0x03|MP200_DMAC_OWNER_DSP) /* M2M */
+#define MP200_DMAC_P0_MAX_L_CHANNELS	4
+
+/* P1 dummy */
+#define MP200_DMAC_P1_MAX_L_CHANNELS	0
+
+/* P2 for ACPU */
+#define MP200_DMAC_M2P_ACPU_LCH0	(0x40|MP200_DMAC_OWNER_ACPU) /* U70 */
+#define MP200_DMAC_M2P_LCH0		MP200_DMAC_M2P_ACPU_LCH0
+#define MP200_DMAC_M2P_ACPU_LCH1	(0x41|MP200_DMAC_OWNER_ACPU) /* U71 */
+#define MP200_DMAC_M2P_LCH1		MP200_DMAC_M2P_ACPU_LCH1
+#define MP200_DMAC_M2P_ACPU_LCH2	(0x42|MP200_DMAC_OWNER_ACPU) /* U72 */
+#define MP200_DMAC_M2P_LCH2		MP200_DMAC_M2P_ACPU_LCH2
+#define MP200_DMAC_M2P_ACPU_LCH3	(0x43|MP200_DMAC_OWNER_ACPU) /* U73 */
+#define MP200_DMAC_M2P_LCH3		MP200_DMAC_M2P_ACPU_LCH3
+					/* MOD1/MOD0 not secure */
+#define MP200_DMAC_M2P_ACPU_LCH4	(0x44|MP200_DMAC_OWNER_ACPU)
+#define MP200_DMAC_M2P_LCH4		MP200_DMAC_M2P_ACPU_LCH4
+					/* MMM/MOD0 secure */
+#define MP200_DMAC_M2P_ACPU_LCH5	(0x45|MP200_DMAC_OWNER_ACPU)
+#define MP200_DMAC_M2P_LCH5		MP200_DMAC_M2P_ACPU_LCH5
+#define MP200_DMAC_M2P_ACPU_LCH7	(0x47|MP200_DMAC_OWNER_ACPU) /* SI1 */
+#define MP200_DMAC_M2P_LCH7		MP200_DMAC_M2P_ACPU_LCH7
+#define MP200_DMAC_M2P_ACPU_LCH9	(0x49|MP200_DMAC_OWNER_ACPU) /* PM0 */
+#define MP200_DMAC_M2P_LCH9		MP200_DMAC_M2P_ACPU_LCH9
+#define MP200_DMAC_M2P_ACPU_LCH10	(0x4a|MP200_DMAC_OWNER_ACPU) /* PM1 */
+#define MP200_DMAC_M2P_LCH10		MP200_DMAC_M2P_ACPU_LCH10
+#define MP200_DMAC_M2P_ACPU_LCH11	(0x4b|MP200_DMAC_OWNER_ACPU) /* PM2 */
+#define MP200_DMAC_M2P_LCH11		MP200_DMAC_M2P_ACPU_LCH11
+#define MP200_DMAC_M2P_ACPU_LCH12	(0x4c|MP200_DMAC_OWNER_ACPU) /* SP0 */
+#define MP200_DMAC_M2P_LCH12		MP200_DMAC_M2P_ACPU_LCH12
+#define MP200_DMAC_M2P_ACPU_LCH13	(0x4d|MP200_DMAC_OWNER_ACPU) /* SP1 */
+#define MP200_DMAC_M2P_LCH13		MP200_DMAC_M2P_ACPU_LCH13
+#define MP200_DMAC_M2P_ACPU_LCH14	(0x4e|MP200_DMAC_OWNER_ACPU) /* SP2 */
+#define MP200_DMAC_M2P_LCH14		MP200_DMAC_M2P_ACPU_LCH14
+/* P2 for CCPU */
+#define MP200_DMAC_M2P_CCPU_LCH0	(0x40|MP200_DMAC_OWNER_CCPU) /* U70 */
+#define MP200_DMAC_M2P_CCPU_LCH1	(0x41|MP200_DMAC_OWNER_CCPU) /* U71 */
+#define MP200_DMAC_M2P_CCPU_LCH2	(0x42|MP200_DMAC_OWNER_CCPU) /* U72 */
+#define MP200_DMAC_M2P_CCPU_LCH3	(0x43|MP200_DMAC_OWNER_CCPU) /* U73 */
+					/* MOD1/MOD0 not secure */
+#define MP200_DMAC_M2P_CCPU_LCH4	(0x44|MP200_DMAC_OWNER_CCPU)
+					/* MMM/MOD0 secure */
+#define MP200_DMAC_M2P_CCPU_LCH5	(0x45|MP200_DMAC_OWNER_CCPU)
+#define MP200_DMAC_M2P_CCPU_LCH7	(0x47|MP200_DMAC_OWNER_CCPU) /* SI1 */
+#define MP200_DMAC_M2P_CCPU_LCH9	(0x49|MP200_DMAC_OWNER_CCPU) /* PM0 */
+#define MP200_DMAC_M2P_CCPU_LCH10	(0x4a|MP200_DMAC_OWNER_CCPU) /* PM1 */
+#define MP200_DMAC_M2P_CCPU_LCH11	(0x4b|MP200_DMAC_OWNER_CCPU) /* PM2 */
+#define MP200_DMAC_M2P_CCPU_LCH12	(0x4c|MP200_DMAC_OWNER_CCPU) /* SP0 */
+#define MP200_DMAC_M2P_CCPU_LCH13	(0x4d|MP200_DMAC_OWNER_CCPU) /* SP1 */
+#define MP200_DMAC_M2P_CCPU_LCH14	(0x4e|MP200_DMAC_OWNER_CCPU) /* SP2 */
+/* P2 for DSP */
+#define MP200_DMAC_M2P_DSP_LCH0		(0x40|MP200_DMAC_OWNER_DSP) /* U70 */
+#define MP200_DMAC_M2P_DSP_LCH1		(0x41|MP200_DMAC_OWNER_DSP) /* U71 */
+#define MP200_DMAC_M2P_DSP_LCH2		(0x42|MP200_DMAC_OWNER_DSP) /* U72 */
+#define MP200_DMAC_M2P_DSP_LCH3		(0x43|MP200_DMAC_OWNER_DSP) /* U73 */
+					/* MOD1/MOD0 not secure */
+#define MP200_DMAC_M2P_DSP_LCH4		(0x44|MP200_DMAC_OWNER_DSP)
+					/* MMM/MOD0 secure */
+#define MP200_DMAC_M2P_DSP_LCH5		(0x45|MP200_DMAC_OWNER_DSP)
+#define MP200_DMAC_M2P_DSP_LCH7		(0x47|MP200_DMAC_OWNER_DSP) /* SI1 */
+#define MP200_DMAC_M2P_DSP_LCH9		(0x49|MP200_DMAC_OWNER_DSP) /* PM0 */
+#define MP200_DMAC_M2P_DSP_LCH10	(0x4a|MP200_DMAC_OWNER_DSP) /* PM1 */
+#define MP200_DMAC_M2P_DSP_LCH11	(0x4b|MP200_DMAC_OWNER_DSP) /* PM2 */
+#define MP200_DMAC_M2P_DSP_LCH12	(0x4c|MP200_DMAC_OWNER_DSP) /* SP0 */
+#define MP200_DMAC_M2P_DSP_LCH13	(0x4d|MP200_DMAC_OWNER_DSP) /* SP1 */
+#define MP200_DMAC_M2P_DSP_LCH14	(0x4e|MP200_DMAC_OWNER_DSP) /* SP2 */
+#define MP200_DMAC_P2_MAX_L_CHANNELS	15	/* includes dummy LCH6 and 8 */
+
+/* P3 for ACPU */
+#define MP200_DMAC_P2M_ACPU_LCH0	(0x60|MP200_DMAC_OWNER_ACPU) /* U70 */
+#define MP200_DMAC_P2M_LCH0		MP200_DMAC_P2M_ACPU_LCH0
+#define MP200_DMAC_P2M_ACPU_LCH1	(0x61|MP200_DMAC_OWNER_ACPU) /* U71 */
+#define MP200_DMAC_P2M_LCH1		MP200_DMAC_P2M_ACPU_LCH1
+#define MP200_DMAC_P2M_ACPU_LCH2	(0x62|MP200_DMAC_OWNER_ACPU) /* U72 */
+#define MP200_DMAC_P2M_LCH2		MP200_DMAC_P2M_ACPU_LCH2
+#define MP200_DMAC_P2M_ACPU_LCH3	(0x63|MP200_DMAC_OWNER_ACPU) /* U73 */
+#define MP200_DMAC_P2M_LCH3		MP200_DMAC_P2M_ACPU_LCH3
+					/* MOD1/MOD0 not secure */
+#define MP200_DMAC_P2M_ACPU_LCH4	(0x64|MP200_DMAC_OWNER_ACPU)
+#define MP200_DMAC_P2M_LCH4		MP200_DMAC_P2M_ACPU_LCH4
+					/* MMM/MOD0 secure */
+#define MP200_DMAC_P2M_ACPU_LCH5	(0x65|MP200_DMAC_OWNER_ACPU)
+#define MP200_DMAC_P2M_LCH5		MP200_DMAC_P2M_ACPU_LCH5
+#define MP200_DMAC_P2M_ACPU_LCH7	(0x67|MP200_DMAC_OWNER_ACPU) /* SI1 */
+#define MP200_DMAC_P2M_LCH7		MP200_DMAC_P2M_ACPU_LCH7
+#define MP200_DMAC_P2M_ACPU_LCH9	(0x69|MP200_DMAC_OWNER_ACPU) /* PM0 */
+#define MP200_DMAC_P2M_LCH9		MP200_DMAC_P2M_ACPU_LCH9
+#define MP200_DMAC_P2M_ACPU_LCH10	(0x6a|MP200_DMAC_OWNER_ACPU) /* PM1 */
+#define MP200_DMAC_P2M_LCH10		MP200_DMAC_P2M_ACPU_LCH10
+#define MP200_DMAC_P2M_ACPU_LCH11	(0x6b|MP200_DMAC_OWNER_ACPU) /* PM2 */
+#define MP200_DMAC_P2M_LCH11		MP200_DMAC_P2M_ACPU_LCH11
+#define MP200_DMAC_P2M_ACPU_LCH12	(0x6c|MP200_DMAC_OWNER_ACPU) /* SP0 */
+#define MP200_DMAC_P2M_LCH12		MP200_DMAC_P2M_ACPU_LCH12
+#define MP200_DMAC_P2M_ACPU_LCH13	(0x6d|MP200_DMAC_OWNER_ACPU) /* SP1 */
+#define MP200_DMAC_P2M_LCH13		MP200_DMAC_P2M_ACPU_LCH13
+#define MP200_DMAC_P2M_ACPU_LCH14	(0x6e|MP200_DMAC_OWNER_ACPU) /* SP2 */
+#define MP200_DMAC_P2M_LCH14		MP200_DMAC_P2M_ACPU_LCH14
+/* P3 for CCPU */
+#define MP200_DMAC_P2M_CCPU_LCH0	(0x60|MP200_DMAC_OWNER_CCPU) /* U70 */
+#define MP200_DMAC_P2M_CCPU_LCH1	(0x61|MP200_DMAC_OWNER_CCPU) /* U71 */
+#define MP200_DMAC_P2M_CCPU_LCH2	(0x62|MP200_DMAC_OWNER_CCPU) /* U72 */
+#define MP200_DMAC_P2M_CCPU_LCH3	(0x63|MP200_DMAC_OWNER_CCPU) /* U73 */
+					/* MOD1/MOD0 not secure */
+#define MP200_DMAC_P2M_CCPU_LCH4	(0x64|MP200_DMAC_OWNER_CCPU)
+					/* MMM/MOD0 secure */
+#define MP200_DMAC_P2M_CCPU_LCH5	(0x65|MP200_DMAC_OWNER_CCPU)
+#define MP200_DMAC_P2M_CCPU_LCH7	(0x67|MP200_DMAC_OWNER_CCPU) /* SI1 */
+#define MP200_DMAC_P2M_CCPU_LCH9	(0x69|MP200_DMAC_OWNER_CCPU) /* PM0 */
+#define MP200_DMAC_P2M_CCPU_LCH10	(0x6a|MP200_DMAC_OWNER_CCPU) /* PM1 */
+#define MP200_DMAC_P2M_CCPU_LCH11	(0x6b|MP200_DMAC_OWNER_CCPU) /* PM2 */
+#define MP200_DMAC_P2M_CCPU_LCH12	(0x6c|MP200_DMAC_OWNER_CCPU) /* SP0 */
+#define MP200_DMAC_P2M_CCPU_LCH13	(0x6d|MP200_DMAC_OWNER_CCPU) /* SP1 */
+#define MP200_DMAC_P2M_CCPU_LCH14	(0x6e|MP200_DMAC_OWNER_CCPU) /* SP2 */
+/* P3 for DSP */
+#define MP200_DMAC_P2M_DSP_LCH0		(0x60|MP200_DMAC_OWNER_DSP) /* U70 */
+#define MP200_DMAC_P2M_DSP_LCH1		(0x61|MP200_DMAC_OWNER_DSP) /* U71 */
+#define MP200_DMAC_P2M_DSP_LCH2		(0x62|MP200_DMAC_OWNER_DSP) /* U72 */
+#define MP200_DMAC_P2M_DSP_LCH3		(0x63|MP200_DMAC_OWNER_DSP) /* U73 */
+					/* MOD1/MOD0 not secure */
+#define MP200_DMAC_P2M_DSP_LCH4		(0x64|MP200_DMAC_OWNER_DSP)
+					/* MMM/MOD0 secure */
+#define MP200_DMAC_P2M_DSP_LCH5		(0x65|MP200_DMAC_OWNER_DSP)
+#define MP200_DMAC_P2M_DSP_LCH7		(0x67|MP200_DMAC_OWNER_DSP) /* SI1 */
+#define MP200_DMAC_P2M_DSP_LCH9		(0x69|MP200_DMAC_OWNER_DSP) /* PM0 */
+#define MP200_DMAC_P2M_DSP_LCH10	(0x6a|MP200_DMAC_OWNER_DSP) /* PM1 */
+#define MP200_DMAC_P2M_DSP_LCH11	(0x6b|MP200_DMAC_OWNER_DSP) /* PM2 */
+#define MP200_DMAC_P2M_DSP_LCH12	(0x6c|MP200_DMAC_OWNER_DSP) /* SP0 */
+#define MP200_DMAC_P2M_DSP_LCH13	(0x6d|MP200_DMAC_OWNER_DSP) /* SP1 */
+#define MP200_DMAC_P2M_DSP_LCH14	(0x6e|MP200_DMAC_OWNER_DSP) /* SP2 */
+#define MP200_DMAC_P3_MAX_L_CHANNELS	15	/* includes dummy LCH6 and 8 */
+
+#define reg_volatile	volatile
+
+struct dma_regs {
+    reg_volatile u32    aadd;	/* +0x00 source (start) address */
+    reg_volatile u32    aadp;	/* +0x04 source address pointer */
+    reg_volatile u32    aoff;	/* +0x08 source address offset (lower 16bit) */
+    reg_volatile u32    asize;	/* +0x0c source block size (lower 16bit) */
+    reg_volatile u32    asize_count;/* +0x10 source block count (lower 4bit) */
+    reg_volatile u32    rfu0;	/* +0x14 */
+    reg_volatile u32    rfu1;	/* +0x18 */
+    reg_volatile u32    rfu2;	/* +0x1c */
+    reg_volatile u32    badd;	/* +0x20 destination (start) address */
+    reg_volatile u32    badp;	/* +0x24 destination address pointer */
+    reg_volatile u32    boff;	/* +0x28 destination address offset
+					 (lower 16bit) */
+    reg_volatile u32    bsize;	/* +0x2c destination block size (lower 16bit) */
+				/* +0x30 destination block count (lower 4bit) */
+    reg_volatile u32    bsize_count;
+    reg_volatile u32    rfu3;	/* +0x34 */
+    reg_volatile u32    rfu4;	/* +0x38 */
+    reg_volatile u32    rfu5;	/* +0x3c */
+    reg_volatile u32    leng;	/* +0x40 length (lower 24bit) */
+    reg_volatile u32    rcount;	/* +0x44 read length count (lower 24bit) */
+    reg_volatile u32    wcount;	/* +0x48 write length count (lower 24bit) */
+    reg_volatile u32    size;	/* +0x4c block size (lower 16bit) */
+    reg_volatile u32    mode;	/* +0x50 mode (lower 2bit and bit8) */
+    reg_volatile u32    time;	/* +0x54 timer (lower 24bit) */
+    reg_volatile u32    time_count; /* +0x58 timer count (lower 24bit) */
+    reg_volatile u32    rfu6[64 - 23];	/* +0x5c fill up to offset of 0xff */
+};
+#define dma_regs_t	struct dma_regs
+
+/* for `aoff' `boff' setting */
+#define MP200_DMAC_OFFSET_ADD	0x00000000
+#define MP200_DMAC_OFFSET_SUB	0x00010000
+
+/* for `mode' setting */
+#define MP200_DMAC_BMODE_REPEAT 0x100
+#define MP200_DMAC_AMODE_BIT32	(0x0 << 4)
+#define MP200_DMAC_AMODE_BIT16	(0x1 << 4)
+#define MP200_DMAC_AMODE_BIT8	(0x2 << 4)
+#define MP200_DMAC_AMODE_TIME	0x4
+
+#define MP200_DMAC_AMODE_REPEAT 0x1
+
+#define MP200_DMAC_DEFMODE_32BIT (MP200_DMAC_AMODE_BIT32 | \
+				  MP200_DMAC_ENDI_R3210 | \
+				  MP200_DMAC_ENDI_W3210)
+#define MP200_DMAC_DEFMODE_16BIT (MP200_DMAC_AMODE_BIT16 | \
+				  MP200_DMAC_ENDI_R10 | \
+				  MP200_DMAC_ENDI_W10)
+#define MP200_DMAC_DEFMODE_8BIT MP200_DMAC_AMODE_BIT8
+
+/* Endian conversion (byte lane selections) */
+#define MP200_DMAC_ENDI_R		16
+#define MP200_DMAC_ENDI_W		24
+#define MP200_DMAC_ENDI(HH, HL, LH, LL, RW)	\
+		((((HH) << 6) | ((HL) << 4) | ((LH) << 2) | (LL)) << (RW))
+/* Endian(Read) for 32bit */
+#define MP200_DMAC_ENDI_R0123	MP200_DMAC_ENDI(0, 1, 2, 3, MP200_DMAC_ENDI_R)
+#define MP200_DMAC_ENDI_R0132	MP200_DMAC_ENDI(0, 1, 3, 2, MP200_DMAC_ENDI_R)
+#define MP200_DMAC_ENDI_R0213	MP200_DMAC_ENDI(0, 2, 1, 3, MP200_DMAC_ENDI_R)
+#define MP200_DMAC_ENDI_R0231	MP200_DMAC_ENDI(0, 2, 3, 1, MP200_DMAC_ENDI_R)
+#define MP200_DMAC_ENDI_R0312	MP200_DMAC_ENDI(0, 3, 1, 2, MP200_DMAC_ENDI_R)
+#define MP200_DMAC_ENDI_R0321	MP200_DMAC_ENDI(0, 3, 2, 1, MP200_DMAC_ENDI_R)
+#define MP200_DMAC_ENDI_R1023	MP200_DMAC_ENDI(1, 0, 2, 3, MP200_DMAC_ENDI_R)
+#define MP200_DMAC_ENDI_R1032	MP200_DMAC_ENDI(1, 0, 3, 2, MP200_DMAC_ENDI_R)
+#define MP200_DMAC_ENDI_R1203	MP200_DMAC_ENDI(1, 2, 0, 3, MP200_DMAC_ENDI_R)
+#define MP200_DMAC_ENDI_R1230	MP200_DMAC_ENDI(1, 2, 3, 0, MP200_DMAC_ENDI_R)
+#define MP200_DMAC_ENDI_R1302	MP200_DMAC_ENDI(1, 3, 0, 2, MP200_DMAC_ENDI_R)
+#define MP200_DMAC_ENDI_R1320	MP200_DMAC_ENDI(1, 3, 2, 0, MP200_DMAC_ENDI_R)
+#define MP200_DMAC_ENDI_R2013	MP200_DMAC_ENDI(2, 0, 1, 3, MP200_DMAC_ENDI_R)
+#define MP200_DMAC_ENDI_R2031	MP200_DMAC_ENDI(2, 0, 3, 1, MP200_DMAC_ENDI_R)
+#define MP200_DMAC_ENDI_R2103	MP200_DMAC_ENDI(2, 1, 0, 3, MP200_DMAC_ENDI_R)
+#define MP200_DMAC_ENDI_R2130	MP200_DMAC_ENDI(2, 1, 3, 0, MP200_DMAC_ENDI_R)
+#define MP200_DMAC_ENDI_R2301	MP200_DMAC_ENDI(2, 3, 0, 1, MP200_DMAC_ENDI_R)
+#define MP200_DMAC_ENDI_R2310	MP200_DMAC_ENDI(2, 3, 1, 0, MP200_DMAC_ENDI_R)
+#define MP200_DMAC_ENDI_R3012	MP200_DMAC_ENDI(3, 0, 1, 2, MP200_DMAC_ENDI_R)
+#define MP200_DMAC_ENDI_R3021	MP200_DMAC_ENDI(3, 0, 2, 1, MP200_DMAC_ENDI_R)
+#define MP200_DMAC_ENDI_R3102	MP200_DMAC_ENDI(3, 1, 0, 2, MP200_DMAC_ENDI_R)
+#define MP200_DMAC_ENDI_R3120	MP200_DMAC_ENDI(3, 1, 2, 0, MP200_DMAC_ENDI_R)
+#define MP200_DMAC_ENDI_R3201	MP200_DMAC_ENDI(3, 2, 0, 1, MP200_DMAC_ENDI_R)
+#define MP200_DMAC_ENDI_R3210	MP200_DMAC_ENDI(3, 2, 1, 0, MP200_DMAC_ENDI_R)
+/* Endian(Write) for 32bit */
+#define MP200_DMAC_ENDI_W0123	MP200_DMAC_ENDI(0, 1, 2, 3, MP200_DMAC_ENDI_W)
+#define MP200_DMAC_ENDI_W0132	MP200_DMAC_ENDI(0, 1, 3, 2, MP200_DMAC_ENDI_W)
+#define MP200_DMAC_ENDI_W0213	MP200_DMAC_ENDI(0, 2, 1, 3, MP200_DMAC_ENDI_W)
+#define MP200_DMAC_ENDI_W0231	MP200_DMAC_ENDI(0, 2, 3, 1, MP200_DMAC_ENDI_W)
+#define MP200_DMAC_ENDI_W0312	MP200_DMAC_ENDI(0, 3, 1, 2, MP200_DMAC_ENDI_W)
+#define MP200_DMAC_ENDI_W0321	MP200_DMAC_ENDI(0, 3, 2, 1, MP200_DMAC_ENDI_W)
+#define MP200_DMAC_ENDI_W1023	MP200_DMAC_ENDI(1, 0, 2, 3, MP200_DMAC_ENDI_W)
+#define MP200_DMAC_ENDI_W1032	MP200_DMAC_ENDI(1, 0, 3, 2, MP200_DMAC_ENDI_W)
+#define MP200_DMAC_ENDI_W1203	MP200_DMAC_ENDI(1, 2, 0, 3, MP200_DMAC_ENDI_W)
+#define MP200_DMAC_ENDI_W1230	MP200_DMAC_ENDI(1, 2, 3, 0, MP200_DMAC_ENDI_W)
+#define MP200_DMAC_ENDI_W1302	MP200_DMAC_ENDI(1, 3, 0, 2, MP200_DMAC_ENDI_W)
+#define MP200_DMAC_ENDI_W1320	MP200_DMAC_ENDI(1, 3, 2, 0, MP200_DMAC_ENDI_W)
+#define MP200_DMAC_ENDI_W2013	MP200_DMAC_ENDI(2, 0, 1, 3, MP200_DMAC_ENDI_W)
+#define MP200_DMAC_ENDI_W2031	MP200_DMAC_ENDI(2, 0, 3, 1, MP200_DMAC_ENDI_W)
+#define MP200_DMAC_ENDI_W2103	MP200_DMAC_ENDI(2, 1, 0, 3, MP200_DMAC_ENDI_W)
+#define MP200_DMAC_ENDI_W2130	MP200_DMAC_ENDI(2, 1, 3, 0, MP200_DMAC_ENDI_W)
+#define MP200_DMAC_ENDI_W2301	MP200_DMAC_ENDI(2, 3, 0, 1, MP200_DMAC_ENDI_W)
+#define MP200_DMAC_ENDI_W2310	MP200_DMAC_ENDI(2, 3, 1, 0, MP200_DMAC_ENDI_W)
+#define MP200_DMAC_ENDI_W3012	MP200_DMAC_ENDI(3, 0, 1, 2, MP200_DMAC_ENDI_W)
+#define MP200_DMAC_ENDI_W3021	MP200_DMAC_ENDI(3, 0, 2, 1, MP200_DMAC_ENDI_W)
+#define MP200_DMAC_ENDI_W3102	MP200_DMAC_ENDI(3, 1, 0, 2, MP200_DMAC_ENDI_W)
+#define MP200_DMAC_ENDI_W3120	MP200_DMAC_ENDI(3, 1, 2, 0, MP200_DMAC_ENDI_W)
+#define MP200_DMAC_ENDI_W3201	MP200_DMAC_ENDI(3, 2, 0, 1, MP200_DMAC_ENDI_W)
+#define MP200_DMAC_ENDI_W3210	MP200_DMAC_ENDI(3, 2, 1, 0, MP200_DMAC_ENDI_W)
+/* Endian(Read) for 16bit */
+#define MP200_DMAC_ENDI_R01	MP200_DMAC_ENDI_R2301
+#define MP200_DMAC_ENDI_R10	MP200_DMAC_ENDI_R3210
+/* Endian(Write) for 16bit */
+#define MP200_DMAC_ENDI_W01	MP200_DMAC_ENDI_W2301
+#define MP200_DMAC_ENDI_W10	MP200_DMAC_ENDI_W3210
+
+/* for checking interrupt status */
+#define MP200_DMAC_INT_TIME_WR		0x80
+#define MP200_DMAC_INT_ERROR_WR 	0x40
+#define MP200_DMAC_INT_BLOCK_WR 	0x20
+#define MP200_DMAC_INT_LENG_WR		0x10
+#define MP200_DMAC_INT_TIME_RD		0x08
+#define MP200_DMAC_INT_ERROR_RD 	0x04
+#define MP200_DMAC_INT_BLOCK_RD 	0x02	/* Just indicate status
+						   on PCH0, Cause INT
+						   on only PCH2. */
+#define MP200_DMAC_INT_LENG_RD		0x01	/* Never cause INT
+						   on any PCH's.
+						   Just indicate status. */
+
+/* for setting interrupt mask */
+#define MP200_DMAC_INT_TIME_EN		0x08
+#define MP200_DMAC_INT_ERROR_EN 	0x04
+#define MP200_DMAC_INT_BLOCK_EN 	0x02
+#define MP200_DMAC_INT_LENG_EN		0x01
+
+typedef void	(*dma_callback_t)(void *data, int intsts, int intrawsts);
+
+
+extern int		mp200_request_dma(int channel, const char *device_id,
+					  dma_callback_t callback, void *data,
+					  dma_regs_t **dma_regs);
+extern void		mp200_free_dma(int channel);
+extern int		mp200_start_dma(int channel, dma_addr_t src_ptr,
+					u_int size, dma_addr_t dst_ptr,
+					int intmask);
+extern int		mp200_dma_status(int channel);
+extern int		mp200_dma_busy(void);
+extern void		mp200_clear_dma(int channel);
+extern void		mp200_reset_dma(int channel);
+extern dma_addr_t	mp200_get_dma_pos(int channel);
+extern void		mp200_stop_dma(int channel);
+extern int		mp200_dma_writable_flag(int channel);
+
+#endif /* __ASM_ARM_ARCH_MP200_DMA_H */
-- 
1.6.5.2

