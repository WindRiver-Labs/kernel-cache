From 21180dd0c0dc9eb8bb3ac88d97f4aa24880a5caa Mon Sep 17 00:00:00 2001
From: Kazuya Tsukamoto <kazuya.tsukamoto@necel.com>
Date: Mon, 9 Nov 2009 11:55:39 +0900
Subject: [PATCH 09/29] nec_em1: timer driver

This driver controls one system timer and six general timers.

Signed-off-by: Kazuya Tsukamoto <kazuya.tsukamoto@necel.com>
---
 arch/arm/mach-mp200/include/mach/timer.h |   88 ++++
 arch/arm/mach-mp200/include/mach/timex.h |   40 ++
 arch/arm/mach-mp200/time.c               |  810 ++++++++++++++++++++++++++++++
 arch/arm/mach-mp200/time.h               |   95 ++++
 4 files changed, 1033 insertions(+), 0 deletions(-)
 create mode 100644 arch/arm/mach-mp200/include/mach/timer.h
 create mode 100644 arch/arm/mach-mp200/include/mach/timex.h
 create mode 100644 arch/arm/mach-mp200/time.c
 create mode 100644 arch/arm/mach-mp200/time.h

diff --git a/arch/arm/mach-mp200/include/mach/timer.h b/arch/arm/mach-mp200/include/mach/timer.h
new file mode 100644
index 0000000..b483198
--- /dev/null
+++ b/arch/arm/mach-mp200/include/mach/timer.h
@@ -0,0 +1,88 @@
+/*
+ *  File Name	    : linux/include/asm-arm/arch-mp200/timer.h
+ *  Function	    : timer
+ *  Release Version : Ver 1.04
+ *  Release Date    : 2007/08/08
+ *
+ *  Copyright (C) NEC Electronics Corporation 2007
+ *
+ *
+ *  This program is free software;you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License as published by Free
+ *  Softwere Foundation; either version 2 of License, or (at your option) any
+ *  later version.
+ *
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warrnty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; If not, write to the Free Software Foundation, Inc., 59
+ *  Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#ifndef __ASM_ARM_ARCH_MP200_TIMER_H
+#define __ASM_ARM_ARCH_MP200_TIMER_H
+
+#define	TIMER_TG0		0
+#define	TIMER_TG1		1
+#define	TIMER_TG2		2
+#define	TIMER_TG3		3
+#define	TIMER_TG4		4
+#define	TIMER_TG5		5
+#define	TIMER_TI0		6
+#define	TIMER_TI1		7
+#define	TIMER_TI2		8
+#define	TIMER_TI3		9
+#define	TIMER_TW0		10
+#define	TIMER_TW1		11
+#define	TIMER_TW2		12
+#define	TIMER_TW3		13
+
+#define TIMER_MAX_NUM		4
+#define TIMER_TG_MAX_NUM	6
+
+
+#define TIMER_MIN_USECS		1
+#define TIMER_MAX_USECS		748982856
+#define TIMER_MAX_COUNT         0xffffffff
+#define TIMER_DEFAULT_TIME	TIMER_MAX_USECS
+
+#ifdef CONFIG_PLL3_238MHZ
+#define TIMER_CLOCK_TICK_RATE_PLL3	5939200
+#else
+#define TIMER_CLOCK_TICK_RATE_PLL3	5734400
+#endif
+
+#define TIMER_CLOCK_TICK_RATE_32K	32000
+
+#define TW_MIN_USECS		157
+#define TW_MAX_USECS		4294967282U
+#define TW_DEFAULT_TIME		32000000	/* 32sec */
+#define TW_CLOCK_TICK_RATE	32000
+
+#include <mach/timex.h>
+
+
+#include <linux/interrupt.h>
+
+extern irqreturn_t(*timer_cb_t(int, void *));
+
+extern int mp200_timer_start(unsigned int timer);
+extern int mp200_timer_stop(unsigned int timer);
+extern int mp200_timer_set_period(unsigned int timer, unsigned int usecs);
+extern int mp200_timer_get_period(unsigned int timer, unsigned int *usecs);
+extern int mp200_timer_get_usecs(unsigned int timer, unsigned int *usecs);
+extern int mp200_timer_get_counts(unsigned int timer, unsigned int *counts);
+extern int mp200_timer_register_cb(unsigned int timer, char *devname,
+				   irqreturn_t (*cb)(int, void *),
+				   void *dev_id);
+extern int mp200_timer_unregister_cb(unsigned int timer, void *dev_id);
+extern int mp200_wdt_set_timeout(unsigned int usecs);
+extern void mp200_wdt_ping(void);
+extern void mp200_wdt_enable(void);
+extern void mp200_wdt_disable(void);
+extern void mp200_wdt_setup(void);
+#endif	/* __ASM_ARM_ARCH_MP200_TIMER_H */
diff --git a/arch/arm/mach-mp200/include/mach/timex.h b/arch/arm/mach-mp200/include/mach/timex.h
new file mode 100644
index 0000000..e659e20
--- /dev/null
+++ b/arch/arm/mach-mp200/include/mach/timex.h
@@ -0,0 +1,40 @@
+/*
+ *  File Name       : linux/include/asm-arm/arch-mp200/timex.h
+ *  Function        : timex
+ *  Release Version : Ver 1.01
+ *  Release Date    : 2007/06/18
+ *
+ *  Copyright (C) NEC Electronics Corporation 2005-2007
+ *
+ *
+ *  This program is free software;you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License as published by Free
+ *  Softwere Foundation; either version 2 of License, or (at your option) any
+ *  later version.
+ *
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warrnty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; If not, write to the Free Software Foundation, Inc., 59
+ *  Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#ifndef __ASM_ARCH_MP200_TIMEX_H
+#define __ASM_ARCH_MP200_TIMEX_H
+
+#define CLOCK_TICK_RATE		32000
+
+#ifdef CONFIG_PLL3_238MHZ
+#define CLOCK_TICK_RATE_PLL3    5939200
+#else
+#define CLOCK_TICK_RATE_PLL3    5734400
+#endif
+
+#define CLOCK_TICK_RATE_32K     32000
+
+
+#endif	/* __ASM_ARCH_MP200_TIMEX_H */
diff --git a/arch/arm/mach-mp200/time.c b/arch/arm/mach-mp200/time.c
new file mode 100644
index 0000000..cf0c46d
--- /dev/null
+++ b/arch/arm/mach-mp200/time.c
@@ -0,0 +1,810 @@
+/*
+ *  File Name       : linux/arch/arm/mach-mp200/time.c
+ *  Function        : time
+ *  Release Version : Ver 1.04
+ *  Release Date    : 2007/08/08
+ *
+ *  Copyright (C) NEC Electronics Corporation 2007
+ *
+ *
+ *  This program is free software;you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License as published by Free
+ *  Softwere Foundation; either version 2 of License, or (at your option) any
+ *  later version.
+ *
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warrnty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; If not, write to the Free Software Foundation, Inc., 59
+ *  Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/errno.h>
+#include <linux/delay.h>
+#include <linux/irq.h>
+#include <linux/clocksource.h>
+#include <linux/clockchips.h>
+
+#include <linux/io.h>
+#include <asm/div64.h>
+#include <asm/mach/time.h>
+
+#include <mach/smu.h>
+#include <mach/pmu.h>
+#include <mach/timer.h>
+
+#include "time.h"
+
+static DEFINE_SPINLOCK(timer_spinlock);
+
+static struct tm_param_t tm_param[] = {
+	/* TIMER_TGn */
+	{.usecs = TIMER_DEFAULT_TIME, },
+	{.usecs = TIMER_DEFAULT_TIME, },
+	{.usecs = TIMER_DEFAULT_TIME, },
+	{.usecs = TIMER_DEFAULT_TIME, },
+	{.usecs = TIMER_DEFAULT_TIME, },
+	{.usecs = TIMER_DEFAULT_TIME, },
+	/* TIMER_TIn */
+	{.usecs = TIMER_DEFAULT_TIME, },
+	{.usecs = TIMER_DEFAULT_TIME, },
+	{.usecs = TIMER_DEFAULT_TIME, },
+	{.usecs = TIMER_DEFAULT_TIME, },
+	/* TIMER_TWn */
+	{.usecs = TW_DEFAULT_TIME, },
+	{.usecs = TIMER_DEFAULT_TIME, },
+	{.usecs = TIMER_DEFAULT_TIME, },
+	{.usecs = TIMER_DEFAULT_TIME, },
+};
+
+static const struct tm_reg_t tm_reg[] = {
+	/* TIMER_TGn */
+	{
+		.irq    = INT_TG0,
+		.tm_op  = IO_ADDRESS(MP200_TG0_BASE) + 0x0000,
+		.tm_clr = IO_ADDRESS(MP200_TG0_BASE) + 0x0004,
+		.tm_set = IO_ADDRESS(MP200_TG0_BASE) + 0x0008,
+		.rcr    = IO_ADDRESS(MP200_TG0_BASE) + 0x000c,
+		.tm_sclr = IO_ADDRESS(MP200_TG0_BASE) + 0x0014,
+		.clkdev = MP200_CLOCKGATE_TG0_TIN,
+		.rstdev = MP200_RESETDEVICE_TG0,
+	},
+	{
+		.irq    = INT_TG1,
+		.tm_op  = IO_ADDRESS(MP200_TG1_BASE) + 0x0000,
+		.tm_clr = IO_ADDRESS(MP200_TG1_BASE) + 0x0004,
+		.tm_set = IO_ADDRESS(MP200_TG1_BASE) + 0x0008,
+		.rcr    = IO_ADDRESS(MP200_TG1_BASE) + 0x000c,
+		.tm_sclr = IO_ADDRESS(MP200_TG1_BASE) + 0x0014,
+		.clkdev = MP200_CLOCKGATE_TG1_TIN,
+		.rstdev = MP200_RESETDEVICE_TG1,
+	},
+	{
+		.irq    = INT_TG2,
+		.tm_op  = IO_ADDRESS(MP200_TG2_BASE) + 0x0000,
+		.tm_clr = IO_ADDRESS(MP200_TG2_BASE) + 0x0004,
+		.tm_set = IO_ADDRESS(MP200_TG2_BASE) + 0x0008,
+		.rcr    = IO_ADDRESS(MP200_TG2_BASE) + 0x000c,
+		.tm_sclr = IO_ADDRESS(MP200_TG2_BASE) + 0x0014,
+		.clkdev = MP200_CLOCKGATE_TG2_TIN,
+		.rstdev = MP200_RESETDEVICE_TG2,
+	},
+	{
+		.irq    = INT_TG3,
+		.tm_op  = IO_ADDRESS(MP200_TG3_BASE) + 0x0000,
+		.tm_clr = IO_ADDRESS(MP200_TG3_BASE) + 0x0004,
+		.tm_set = IO_ADDRESS(MP200_TG3_BASE) + 0x0008,
+		.rcr    = IO_ADDRESS(MP200_TG3_BASE) + 0x000c,
+		.tm_sclr = IO_ADDRESS(MP200_TG3_BASE) + 0x0014,
+		.clkdev = MP200_CLOCKGATE_TG3_TIN,
+		.rstdev = MP200_RESETDEVICE_TG3,
+	},
+	{
+		.irq    = INT_TG4,
+		.tm_op  = IO_ADDRESS(MP200_TG4_BASE) + 0x0000,
+		.tm_clr = IO_ADDRESS(MP200_TG4_BASE) + 0x0004,
+		.tm_set = IO_ADDRESS(MP200_TG4_BASE) + 0x0008,
+		.rcr    = IO_ADDRESS(MP200_TG4_BASE) + 0x000c,
+		.tm_sclr = IO_ADDRESS(MP200_TG4_BASE) + 0x0014,
+		.clkdev = MP200_CLOCKGATE_TG4_TIN,
+		.rstdev = MP200_RESETDEVICE_TG4,
+	},
+	{
+		.irq    = INT_TG5,
+		.tm_op  = IO_ADDRESS(MP200_TG5_BASE) + 0x0000,
+		.tm_clr = IO_ADDRESS(MP200_TG5_BASE) + 0x0004,
+		.tm_set = IO_ADDRESS(MP200_TG5_BASE) + 0x0008,
+		.rcr    = IO_ADDRESS(MP200_TG5_BASE) + 0x000c,
+		.tm_sclr = IO_ADDRESS(MP200_TG5_BASE) + 0x0014,
+		.clkdev = MP200_CLOCKGATE_TG5_TIN,
+		.rstdev = MP200_RESETDEVICE_TG5,
+	},
+	/* TIMER_TIn */
+	{
+		.irq    = INT_TIMER0, /* 54 */
+		.tm_op  = IO_ADDRESS(MP200_TIMER0_BASE) + 0x0000,
+		.tm_clr = IO_ADDRESS(MP200_TIMER0_BASE) + 0x0004,
+		.tm_set = IO_ADDRESS(MP200_TIMER0_BASE) + 0x0008,
+		.rcr    = IO_ADDRESS(MP200_TIMER0_BASE) + 0x000c,
+		.tm_sclr = IO_ADDRESS(MP200_TIMER0_BASE) + 0x0014,
+		.clkdev = MP200_CLOCKGATE_TI0_TIN,
+		.rstdev = MP200_RESETDEVICE_TI0,
+	},
+	{
+		.irq    = INT_TIMER1, /* 55 */
+		.tm_op  = IO_ADDRESS(MP200_TIMER1_BASE) + 0x0000,
+		.tm_clr = IO_ADDRESS(MP200_TIMER1_BASE) + 0x0004,
+		.tm_set = IO_ADDRESS(MP200_TIMER1_BASE) + 0x0008,
+		.rcr    = IO_ADDRESS(MP200_TIMER1_BASE) + 0x000c,
+		.tm_sclr = IO_ADDRESS(MP200_TIMER1_BASE) + 0x0014,
+		.clkdev = MP200_CLOCKGATE_TI1_TIN,
+		.rstdev = MP200_RESETDEVICE_TI1,
+	},
+	{
+		.irq    = INT_TIMER2, /* 56 */
+		.tm_op  = IO_ADDRESS(MP200_TIMER2_BASE) + 0x0000,
+		.tm_clr = IO_ADDRESS(MP200_TIMER2_BASE) + 0x0004,
+		.tm_set = IO_ADDRESS(MP200_TIMER2_BASE) + 0x0008,
+		.rcr    = IO_ADDRESS(MP200_TIMER2_BASE) + 0x000c,
+		.tm_sclr = IO_ADDRESS(MP200_TIMER2_BASE) + 0x0014,
+		.clkdev = MP200_CLOCKGATE_TI2_TIN,
+		.rstdev = MP200_RESETDEVICE_TI2,
+	},
+	{
+		.irq    = INT_TIMER3, /* 57 */
+		.tm_op  = IO_ADDRESS(MP200_TIMER3_BASE) + 0x0000,
+		.tm_clr = IO_ADDRESS(MP200_TIMER3_BASE) + 0x0004,
+		.tm_set = IO_ADDRESS(MP200_TIMER3_BASE) + 0x0008,
+		.rcr    = IO_ADDRESS(MP200_TIMER3_BASE) + 0x000c,
+		.tm_sclr = IO_ADDRESS(MP200_TIMER3_BASE) + 0x0014,
+		.clkdev = MP200_CLOCKGATE_TI3_TIN,
+		.rstdev = MP200_RESETDEVICE_TI3,
+	},
+	/* TIMER_TWn */
+	{
+		.irq    = INT_WDT0,
+		.tm_op  = IO_ADDRESS(MP200_WDT0_BASE) + 0x0000,
+		.tm_clr = IO_ADDRESS(MP200_WDT0_BASE) + 0x0004,
+		.tm_set = IO_ADDRESS(MP200_WDT0_BASE) + 0x0008,
+		.rcr    = IO_ADDRESS(MP200_WDT0_BASE) + 0x000c,
+		.clkdev = MP200_CLOCKGATE_TW0_TIN,
+		.rstdev = MP200_RESETDEVICE_TW0,
+		.tin_sel = SMU_TI0TIN_SEL,
+	},
+	{
+		.irq    = INT_WDT1, /* 59 */
+		.tm_op  = IO_ADDRESS(MP200_WDT1_BASE) + 0x0000,
+		.tm_clr = IO_ADDRESS(MP200_WDT1_BASE) + 0x0004,
+		.tm_set = IO_ADDRESS(MP200_WDT1_BASE) + 0x0008,
+		.rcr    = IO_ADDRESS(MP200_WDT1_BASE) + 0x000c,
+		.clkdev = MP200_CLOCKGATE_TW1_TIN,
+		.rstdev = MP200_RESETDEVICE_TW1,
+		.tin_sel = SMU_TI1TIN_SEL,
+	},
+	{
+		.irq    = INT_WDT2, /* 60 */
+		.tm_op  = IO_ADDRESS(MP200_WDT2_BASE) + 0x0000,
+		.tm_clr = IO_ADDRESS(MP200_WDT2_BASE) + 0x0004,
+		.tm_set = IO_ADDRESS(MP200_WDT2_BASE) + 0x0008,
+		.rcr    = IO_ADDRESS(MP200_WDT2_BASE) + 0x000c,
+		.clkdev = MP200_CLOCKGATE_TW2_TIN,
+		.rstdev = MP200_RESETDEVICE_TW2,
+		.tin_sel = SMU_TI2TIN_SEL,
+	},
+	{
+		.irq    = INT_WDT3, /* 61 */
+		.tm_op  = IO_ADDRESS(MP200_WDT3_BASE) + 0x0000,
+		.tm_clr = IO_ADDRESS(MP200_WDT3_BASE) + 0x0004,
+		.tm_set = IO_ADDRESS(MP200_WDT3_BASE) + 0x0008,
+		.rcr    = IO_ADDRESS(MP200_WDT3_BASE) + 0x000c,
+		.clkdev = MP200_CLOCKGATE_TW3_TIN,
+		.rstdev = MP200_RESETDEVICE_TW3,
+		.tin_sel = SMU_TI3TIN_SEL,
+	},
+};
+
+static const unsigned int intc_raw1 = VA_INTC + MP200_INTC_IT0_RAW1;
+
+/* inline function */
+inline int check_validity_channel(unsigned int timer)
+{
+	if ((TIMER_MIN <= timer) && (timer <= TIMER_MAX))
+		return 0;
+	else
+		return -ENODEV;
+}
+
+inline unsigned int get_count_value(unsigned timer, unsigned int usecs)
+{
+
+	uint64_t counts;
+
+	if (usecs == TIMER_MAX_COUNT)
+		return TIMER_MAX_COUNT;
+
+	if (!(inl(SMU_TGNTIN_SEL) & (0x3 << (timer * 4)))) {
+		/* 12MHz */
+		counts = (uint64_t)usecs * TIMER_CLOCK_TICK_RATE_PLL3;
+	} else {
+		/* 32KHz */
+		counts = (uint64_t)usecs * TIMER_CLOCK_TICK_RATE_32K;
+	}
+	do_div(counts, 1000000);
+	counts--;
+
+	return (unsigned int)counts;
+
+}
+static inline unsigned int
+get_tw_count_value(unsigned timer, unsigned int usecs)
+{
+
+	uint64_t counts;
+	if ((inl(tm_reg[timer].tin_sel) & MASK_TWNTIN_SEL) ==
+	    TWNTIN_SEL_32K) {
+		/* 32KHz */
+		counts = (uint64_t)usecs * TIMER_CLOCK_TICK_RATE_32K;
+	} else {
+		/* 12MHz */
+		counts = (uint64_t)usecs * TIMER_CLOCK_TICK_RATE_PLL3;
+	}
+
+	do_div(counts, 1000000);
+	counts--;
+
+	return (unsigned int)counts;
+
+}
+
+
+inline unsigned int get_usec_value(unsigned timer, unsigned int counts)
+{
+
+	uint64_t usecs;
+
+	usecs = (uint64_t)counts * 1000000;
+
+	if (!(inl(SMU_TGNTIN_SEL) & (0x3 << (timer * 4)))) {
+		/* 12MHz */
+		do_div(usecs, TIMER_CLOCK_TICK_RATE_PLL3);
+	} else {
+		/* 32KHz */
+		do_div(usecs, TIMER_CLOCK_TICK_RATE_32K);
+	}
+
+	return (unsigned int)usecs;
+
+}
+
+unsigned long mp200_system_timer_read(int nr)
+{
+
+	return inl(tm_reg[nr].rcr);
+
+}
+
+void mp200_system_timer_start(int nr, unsigned int mode)
+{
+	outl((TSTART | TM_EN | mode), tm_reg[nr].tm_op);
+}
+
+static unsigned long timer_interval = TIMER_INTERVAL_PLL3;
+
+unsigned long mp200_timer_ticks_to_usecs(unsigned long nr_ticks)
+{
+	uint64_t usecs;
+
+	usecs = (uint64_t)nr_ticks * 1000000;
+
+	if (timer_interval == TIMER_INTERVAL_32K) {
+		/* 32KHz */
+		do_div(usecs, TIMER_CLOCK_TICK_RATE_32K);
+
+	} else {
+		/* 12MHz */
+		do_div(usecs, TIMER_CLOCK_TICK_RATE_PLL3);
+	}
+
+	return (unsigned int)usecs;
+
+}
+
+/*
+ * Returns number of ms since last clock interrupt.
+ * Note that interrupts will have been disabled by do_gettimeoffset().
+ */
+static unsigned long mp200_gettimeoffset(void)
+{
+	unsigned long ticks;
+	unsigned long status1;
+	unsigned long status2;
+
+	/* This function will be called with interrupt disabled.
+	 * Check interrupt RAW register before and after reading counter.
+	 * If counter is saturated and interrupt is not occurred,
+	 * wait a few PCLK after reading counter to ensure
+	 * whether interrupt handling is or is not done.
+	 * (Determine we are called whether before or after interrupt
+	 *  handler execution.)
+	 */
+
+	status1 = inl(intc_raw1) & (1 << (tm_reg[TIMER_SYSTEM].irq - 32));
+
+	ticks = mp200_system_timer_read(TIMER_SYSTEM);
+
+
+	/* counter saturated, but not interrupt */
+	if ((ticks == 0) && (status1 == 0)) {
+		/* wait for about 3 PCLK */
+		__asm__ __volatile__ ("nop");
+		__asm__ __volatile__ ("nop");
+		__asm__ __volatile__ ("nop");
+		__asm__ __volatile__ ("nop");
+		__asm__ __volatile__ ("nop");
+		__asm__ __volatile__ ("nop");
+	}
+
+	status2 = inl(intc_raw1) & (1 << (tm_reg[TIMER_SYSTEM].irq - 32));
+
+	/* If interrupt is occurred, we need to add 1 tick because
+	 * jiffies is not updated yet.
+	 */
+	if (status2 != 0) {
+		if (ticks < (timer_interval / 2))
+			ticks += (timer_interval + 1);
+	}
+
+	return mp200_timer_ticks_to_usecs(ticks);
+
+}
+
+/*
+ * IRQ handler for the timer
+ */
+static irqreturn_t mp200_timer_interrupt(int irq, void *dev_id)
+{
+	timer_tick();
+
+	return IRQ_HANDLED;
+}
+
+static struct irqaction mp200_tick_count_timer_irq = {
+	.name    = "mp200_timer",
+	.flags   = IRQF_DISABLED | IRQF_TIMER,
+	.handler = mp200_timer_interrupt
+};
+
+
+/*
+ * Set up timer interrupt, and return the current time in seconds.
+ */
+static void __init mp200_init_timer(void)
+{
+
+	timer_set_clock_parm(TIMER_FULLSPEED);
+	timer_set_clock(TIMER_INIT);
+
+	setup_irq(tm_reg[TIMER_SYSTEM].irq, &mp200_tick_count_timer_irq);
+	mp200_timer.offset = mp200_gettimeoffset;
+
+	mp200_system_timer_start(TIMER_SYSTEM, TO_EN);
+}
+
+struct sys_timer mp200_timer = {
+	.init = mp200_init_timer,
+	.offset = NULL,         /* Initialized later */
+};
+
+/*
+ * Change internal timer parameter
+ */
+void timer_set_clock_parm(unsigned int mode)
+{
+#if 0
+	switch (mode) {
+	case TIMER_RESUME:
+	case TIMER_FULLSPEED:
+		timer_interval = TIMER_INTERVAL_PLL3;
+		break;
+	case TIMER_SUSPEND:
+	case TIMER_ECONOMY:
+		timer_interval = TIMER_INTERVAL_32K;
+		break;
+	default:
+		break;
+	}
+#endif
+}
+
+static unsigned int tg_tm_op[] = { 0, 0, 0, 0, 0, 0 };
+
+void timer_set_clock(unsigned int mode)
+{
+	int i;
+	unsigned int count;
+	unsigned int tm_delay = 0;
+
+	/* delay value set */
+	tm_delay = TIMER_DELAY(TIMER_CLOCK_TICK_RATE_32K);
+
+	switch (mode) {
+	case TIMER_SUSPEND:
+		/* close clockgate */
+		mp200_pmu_close_clockgate(tm_reg[TIMER_SYSTEM].clkdev);
+		mp200_pmu_close_clockgate(tm_reg[TIMER_WDT].clkdev);
+		mp200_pmu_close_clockgate(tm_reg[TIMER_DSP].clkdev);
+		for (i = 0; i < TIMER_TG_MAX_NUM; i++) {
+			if (tg_tm_op[i] == 1)
+				mp200_pmu_close_clockgate(
+					tm_reg[TIMER_TG0 + i].clkdev);
+		}
+		break;
+	case TIMER_SUSPEND_PDMA:
+		/* close clockgate */
+		mp200_pmu_close_clockgate(tm_reg[TIMER_SYSTEM].clkdev);
+		mp200_pmu_close_clockgate(tm_reg[TIMER_WDT].clkdev);
+		mp200_pmu_close_clockgate(tm_reg[TIMER_DSP].clkdev);
+		for (i = 0; i <= TIMER_MAX; i++) {
+			if (tg_tm_op[i] == 1)
+				mp200_pmu_close_clockgate(
+					tm_reg[TIMER_TG0 + i].clkdev);
+		}
+		break;
+
+	case TIMER_RESUME:
+		mp200_pmu_open_clockgate(tm_reg[TIMER_SYSTEM].clkdev);
+		mp200_pmu_open_clockgate(tm_reg[TIMER_WDT].clkdev);
+		mp200_pmu_open_clockgate(tm_reg[TIMER_DSP].clkdev);
+
+		for (i = 0; i < TIMER_TG_MAX_NUM; i++) {
+			if (tg_tm_op[i] == 1)
+				mp200_pmu_open_clockgate(
+					tm_reg[TIMER_TG0 + i].clkdev);
+		}
+		break;
+
+	case TIMER_RESUME_PDMA:
+		mp200_pmu_open_clockgate(tm_reg[TIMER_SYSTEM].clkdev);
+		mp200_pmu_open_clockgate(tm_reg[TIMER_WDT].clkdev);
+		mp200_pmu_open_clockgate(tm_reg[TIMER_DSP].clkdev);
+
+		for (i = 0; i <= TIMER_MAX; i++) {
+			if (tg_tm_op[i] == 1)
+				mp200_pmu_open_clockgate(
+					tm_reg[TIMER_TG0 + i].clkdev);
+		}
+		break;
+
+	case TIMER_INIT:
+		mp200_pmu_open_clockgate(MP200_CLOCKGATE_ATIM_PCLK);
+
+		mp200_pmu_open_clockgate(tm_reg[TIMER_SYSTEM].clkdev);
+		mp200_pmu_unreset_device(tm_reg[TIMER_SYSTEM].rstdev);
+		mp200_pmu_unreset_device(tm_reg[TIMER_TI2].rstdev);
+
+		for (i = 0; i < TIMER_TG_MAX_NUM; i++)
+			mp200_pmu_unreset_device(tm_reg[TIMER_TG0 + i].rstdev);
+
+		outl(TSTOP, tm_reg[TIMER_SYSTEM].tm_op);
+		outl(TSTOP, tm_reg[TIMER_WDT].tm_op);
+		outl(TSTOP, tm_reg[TIMER_DSP].tm_op);
+		outl(TCR_CLR, tm_reg[TIMER_SYSTEM].tm_clr);
+		outl(TCR_CLR, tm_reg[TIMER_WDT].tm_clr);
+		outl(TCR_CLR, tm_reg[TIMER_DSP].tm_clr);
+
+		outl(TSTOP, tm_reg[TIMER_TI2].tm_op);
+		outl(0xffffffff, tm_reg[TIMER_TI2].tm_set);
+
+		/* select TIN clock */
+		outl(TINTIN_SEL_PLL3 | TWNTIN_SEL_32K, SMU_TI0TIN_SEL);
+		outl(TINTIN_SEL_PLL3 | TWNTIN_SEL_PLL3, SMU_TI1TIN_SEL);
+		outl(TINTIN_SEL_PLL3 | TWNTIN_SEL_PLL3, SMU_TI2TIN_SEL);
+		outl(TINTIN_SEL_32K | TWNTIN_SEL_PLL3, SMU_TI3TIN_SEL);
+		outl(TGNTIN_SEL_PLL3, SMU_TGNTIN_SEL);
+
+		/* DIVTIMTIN Register set */
+		outl(SMU_DIV40, SMU_DIVTIMTIN);
+
+		/* set counter */
+		outl(COUNTER_MAXVAL, tm_reg[TIMER_SYSTEM].tm_set);
+		count = get_tw_count_value(TIMER_WDT,
+				tm_param[TIMER_WDT].usecs);
+		outl(count, tm_reg[TIMER_WDT].tm_set);
+		outl(TIMER_INTERVAL_DSP, tm_reg[TIMER_DSP].tm_set);
+
+		for (i = 0; i < TIMER_TG_MAX_NUM; i++) {
+			count = get_count_value(i,
+					tm_param[TIMER_TG0 + i].usecs);
+			outl(count, tm_reg[TIMER_TG0 + i].tm_set);
+		}
+
+		/* Auto clock ON */
+		mp200_pmu_clkctrl_on(MP200_CLKCTRL_TIMPCLK);
+		break;
+	default:
+		printk(KERN_INFO "%s(): set clock error mode = %d.\n",
+		       __func__, mode);
+		break;
+	}
+}
+
+
+int mp200_timer_start(unsigned int timer)
+{
+	int ret = 0;
+	unsigned long flags;
+
+	ret = check_validity_channel(timer);
+	if (ret != 0)
+		return ret;
+
+	spin_lock_irqsave(&timer_spinlock, flags);
+
+	mp200_pmu_open_clockgate(tm_reg[TIMER_TG0 + timer].clkdev);
+	tg_tm_op[timer] = 1;
+
+	/* Timer start */
+	outl((TSTART | TM_EN | TO_EN), tm_reg[TIMER_TG0 + timer].tm_op);
+
+	spin_unlock_irqrestore(&timer_spinlock, flags);
+
+	return 0;
+}
+EXPORT_SYMBOL(mp200_timer_start);
+
+int mp200_timer_stop(unsigned int timer)
+{
+	int ret = 0;
+	unsigned int tm_delay = 0;
+	unsigned long flags;
+
+	ret = check_validity_channel(timer);
+	if (ret != 0)
+		return ret;
+
+	/* delay value set */
+	tm_delay = TIMER_DELAY(TIMER_CLOCK_TICK_RATE_PLL3);
+
+	spin_lock_irqsave(&timer_spinlock, flags);
+
+	/* Timer stop */
+	outl(TSTOP, tm_reg[TIMER_TG0 + timer].tm_op);
+
+	udelay(tm_delay);
+
+	mp200_pmu_close_clockgate(tm_reg[TIMER_TG0 + timer].clkdev);
+	tg_tm_op[timer] = 0;
+
+	spin_unlock_irqrestore(&timer_spinlock, flags);
+
+	return 0;
+}
+EXPORT_SYMBOL(mp200_timer_stop);
+
+int mp200_timer_set_period(unsigned int timer, unsigned int usecs)
+{
+	int ret = 0, regval = 0;
+	unsigned long flags;
+	unsigned int tm_delay = 0;
+
+	ret = check_validity_channel(timer);
+	if (ret != 0)
+		return ret;
+
+	if ((usecs < TIMER_MIN_USECS) || (TIMER_MAX_USECS < usecs))
+		return -EINVAL;
+
+	/* 4clk x2 wait value */
+	tm_delay = TIMER_DELAY(TIMER_CLOCK_TICK_RATE_PLL3) * 2;
+
+	spin_lock_irqsave(&timer_spinlock, flags);
+
+	if (inl(tm_reg[timer].tm_op) & TSTART) {
+		spin_unlock_irqrestore(&timer_spinlock, flags);
+		return -EBUSY;
+	}
+
+	mp200_pmu_open_clockgate(tm_reg[TIMER_TG0 + timer].clkdev);
+	udelay(tm_delay);
+
+	tm_param[TIMER_TG0 + timer].usecs = usecs;
+
+	/* set counter */
+	regval = get_count_value(timer, usecs);
+	outl(regval, tm_reg[TIMER_TG0 + timer].tm_set);
+
+	mp200_pmu_close_clockgate(tm_reg[TIMER_TG0 + timer].clkdev);
+	spin_unlock_irqrestore(&timer_spinlock, flags);
+
+	return 0;
+}
+EXPORT_SYMBOL(mp200_timer_set_period);
+
+int mp200_timer_get_period(unsigned int timer, unsigned int *usecs)
+{
+	int ret = 0;
+
+	ret = check_validity_channel(timer);
+	if (ret != 0)
+		return ret;
+
+	if (usecs == NULL)
+		return -EINVAL;
+
+	*usecs = tm_param[TIMER_TG0 + timer].usecs;
+
+	return 0;
+}
+EXPORT_SYMBOL(mp200_timer_get_period);
+
+int mp200_timer_get_usecs(unsigned int timer, unsigned int *usecs)
+{
+	unsigned int regval = 0;
+	int ret = 0;
+
+	ret = check_validity_channel(timer);
+	if (ret != 0)
+		return ret;
+
+	if (usecs == NULL)
+		return -EINVAL;
+
+	regval = inl(tm_reg[TIMER_TG0 + timer].rcr);
+	*usecs = get_usec_value(timer, regval);
+
+	return 0;
+}
+EXPORT_SYMBOL(mp200_timer_get_usecs);
+
+int mp200_timer_register_cb(unsigned int timer, char *devname,
+			    irqreturn_t (*cb)(int, void *), void *dev_id)
+{
+	unsigned int irq = 0;
+	int ret = 0;
+
+	ret = check_validity_channel(timer);
+	if (ret != 0)
+		return ret;
+
+	if (inl(tm_reg[timer].tm_op) & TSTART)
+		return -EBUSY;
+
+	irq = tm_reg[TIMER_TG0 + timer].irq;
+	ret = request_irq(irq, cb, IRQF_SHARED | IRQF_DISABLED, devname,
+			dev_id);
+	if (ret != 0)
+		return ret;
+
+	return 0;
+}
+EXPORT_SYMBOL(mp200_timer_register_cb);
+
+int mp200_timer_unregister_cb(unsigned int timer, void *dev_id)
+{
+	unsigned int irq = 0;
+	int ret = 0;
+
+	ret = check_validity_channel(timer);
+	if (ret != 0)
+		return ret;
+
+	if (inl(tm_reg[timer].tm_op) & TSTART)
+		return -EBUSY;
+
+	irq = tm_reg[TIMER_TG0 + timer].irq;
+	free_irq(irq, dev_id);
+
+	return 0;
+}
+EXPORT_SYMBOL(mp200_timer_unregister_cb);
+
+static DEFINE_SPINLOCK(wdt_spinlock);
+/*
+ * WatchDog Timer Function
+ */
+int mp200_wdt_set_timeout(unsigned int usecs)
+{
+	int ret = 0, val_tm_op, regval;
+	unsigned int tm_delay = 0;
+
+	if ((usecs < TW_MIN_USECS) || (TW_MAX_USECS < usecs))
+		return -EINVAL;
+
+	tm_delay = TIMER_DELAY(TW_CLOCK_TICK_RATE) * 2;
+
+	spin_lock(&wdt_spinlock);
+
+	/* get tm_op */
+	val_tm_op = inl(tm_reg[TIMER_WDT].tm_op);
+
+	/* timer stop */
+	outl(TSTOP, tm_reg[TIMER_WDT].tm_op);
+
+	/* set counter */
+	regval = get_tw_count_value(TIMER_WDT, usecs);
+
+	udelay(tm_delay);
+	outl(regval, tm_reg[TIMER_WDT].tm_set);
+
+	/* timer start (restore tm_op) */
+	outl(val_tm_op, tm_reg[TIMER_WDT].tm_op);
+
+	spin_unlock(&wdt_spinlock);
+
+	return ret;
+}
+EXPORT_SYMBOL(mp200_wdt_set_timeout);
+
+/* Clear watchdog timer. */
+void mp200_wdt_ping(void)
+{
+	unsigned int tm_delay = TIMER_DELAY(TW_CLOCK_TICK_RATE);
+
+	spin_lock(&wdt_spinlock);
+	outl(TCR_CLR, tm_reg[TIMER_WDT].tm_clr);
+	udelay(tm_delay);
+	spin_unlock(&wdt_spinlock);
+}
+EXPORT_SYMBOL(mp200_wdt_ping);
+
+/* Start watchdog timer counting. */
+void mp200_wdt_enable(void)
+{
+	spin_lock(&wdt_spinlock);
+	outl(TM_EN | TSTART | TO_EN, tm_reg[TIMER_WDT].tm_op);
+	spin_unlock(&wdt_spinlock);
+}
+EXPORT_SYMBOL(mp200_wdt_enable);
+
+/* Stop watchdog timer counting. */
+void mp200_wdt_disable(void)
+{
+	unsigned int tm_delay = TIMER_DELAY(TW_CLOCK_TICK_RATE);
+
+	spin_lock(&wdt_spinlock);
+	outl(TSTOP, tm_reg[TIMER_WDT].tm_op);
+	udelay(tm_delay);
+	spin_unlock(&wdt_spinlock);
+}
+EXPORT_SYMBOL(mp200_wdt_disable);
+
+/* Setup watchdog timer. */
+void mp200_wdt_setup(void)
+{
+	unsigned int regval;
+	unsigned int tm_delay = 0;
+
+	tm_delay = TIMER_DELAY(TW_CLOCK_TICK_RATE) * 2;
+	spin_lock(&wdt_spinlock);
+
+	outl(inl(SMU_WDT_INT_RESET) | 0x00000101, SMU_WDT_INT_RESET);
+
+	regval = inl(SMU_TI0TIN_SEL) & ~MASK_TWNTIN_SEL;
+	outl(regval | TWNTIN_SEL_32K, SMU_TI0TIN_SEL);
+
+	/* Auto clock OFF */
+	mp200_pmu_open_clockgate(MP200_CLOCKGATE_ATIM_PCLK);
+	mp200_pmu_open_clockgate(tm_reg[TIMER_WDT].clkdev);
+	mp200_pmu_unreset_device(tm_reg[TIMER_WDT].rstdev);
+	/* Auto clock ON */
+	mp200_pmu_clkctrl_on(MP200_CLKCTRL_TIMPCLK);
+
+	/* stop timer for sure. */
+	outl(TSTOP, tm_reg[TIMER_WDT].tm_op);
+
+	/* set counter */
+	regval = get_tw_count_value(TIMER_WDT, tm_param[TIMER_WDT].usecs);
+	udelay(tm_delay);
+	outl(regval, tm_reg[TIMER_WDT].tm_set);
+
+	spin_unlock(&wdt_spinlock);
+
+}
+EXPORT_SYMBOL(mp200_wdt_setup);
diff --git a/arch/arm/mach-mp200/time.h b/arch/arm/mach-mp200/time.h
new file mode 100644
index 0000000..2c04ce4
--- /dev/null
+++ b/arch/arm/mach-mp200/time.h
@@ -0,0 +1,95 @@
+/*
+ *  File Name	    : linux/arch/arm/mach-mp200/time.h
+ *  Function	    : time
+ *  Release Version : Ver 1.04
+ *  Release Date    : 2009/08/20
+ *
+ *  Copyright (C) NEC Electronics Corporation 2009
+ *
+ *
+ *  This program is free software;you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License as published by Free
+ *  Softwere Foundation; either version 2 of License, or (at your option) any
+ *  later version.
+ *
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warrnty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; If not, write to the Free Software Foundation, Inc., 59
+ *  Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#ifndef __ARCH_ARM_MACH_MP200_TIME_H
+#define __ARCH_ARM_MACH_MP200_TIME_H
+
+/*
+ * General Timer
+ */
+#define TM_EN			0x00000001
+#define TSTART			0x00000002
+#define TO_EN			0x00000004
+#define TCR_CLR			0x00000002
+#define TSTOP			0x00000000
+
+/*
+ * Timer clock condition
+ */
+#define TIMER_SUSPEND		0
+#define TIMER_RESUME		1
+#define TIMER_FULLSPEED		2
+#define TIMER_ECONOMY		3
+#define TIMER_INIT		4
+#define TIMER_SUSPEND_PDMA	5
+#define TIMER_RESUME_PDMA	6
+
+
+#define TIMER_WDT		TIMER_TW0
+
+#define TIMER_MIN		TIMER_TG0
+#define TIMER_MAX		TIMER_TG5
+
+#define TIMER_SYSTEM		TIMER_TI0
+#define TIMER_DSP		TIMER_TI3
+
+#ifdef CONFIG_PLL3_238MHZ
+#define TIMER_INTERVAL_PLL3     (59392 - 1)
+#else
+#define TIMER_INTERVAL_PLL3     (57344 - 1)
+#endif
+
+#define TIMER_INTERVAL_32K      (320 - 1)
+#define TIMER_INTERVAL_DSP      (32 - 1)
+
+#define COUNTER_MAXVAL          TIMER_INTERVAL_PLL3
+
+/* x:clock source value	*/
+#define TIMER_DELAY(x)		((40000000 / x)/10 + 1)
+
+struct tm_param_t {
+	unsigned int usecs;
+	unsigned int tm_op;
+};
+
+struct tm_reg_t {
+	unsigned int irq;
+	unsigned int tm_op;
+	unsigned int tm_clr;
+	unsigned int tm_set;
+	unsigned int rcr;
+	unsigned int tm_sclr;
+	unsigned int clkdev;
+	unsigned int rstdev;
+	unsigned int tin_sel;
+};
+
+
+extern struct sys_timer mp200_timer;
+
+extern void timer_set_clock_parm(unsigned int mode);
+extern void timer_set_clock(unsigned int mode);
+
+#endif
-- 
1.6.5.2

