From 82e0e35ee2b2966218c1c0970bc0ac7f2f74330e Mon Sep 17 00:00:00 2001
From: Kazuya Tsukamoto <kazuya.tsukamoto@necel.com>
Date: Mon, 9 Nov 2009 14:14:08 +0900
Subject: [PATCH 23/29] nec_em1: add watchdog timer driver

Although this is watchdog timer driver of EM it is invalid in
EMMA Mobile Develpment Kit Board.
So default setting is "CONFIG_MP200_WATCHDOG is not set".

Signed-off-by: Kazuya Tsukamoto <kazuya.tsukamoto@necel.com>
---
 drivers/watchdog/Kconfig     |    4 +
 drivers/watchdog/Makefile    |    1 +
 drivers/watchdog/mp200_wdt.c |  260 ++++++++++++++++++++++++++++++++++++++++++
 3 files changed, 265 insertions(+), 0 deletions(-)
 create mode 100644 drivers/watchdog/mp200_wdt.c

diff --git a/drivers/watchdog/Kconfig b/drivers/watchdog/Kconfig
index 8b5bfde..18c92e8 100644
--- a/drivers/watchdog/Kconfig
+++ b/drivers/watchdog/Kconfig
@@ -217,6 +217,10 @@ config DAVINCI_WATCHDOG
 	  NOTE: once enabled, this timer cannot be disabled.
 	  Say N if you are unsure.
 
+config MP200_WATCHDOG
+	tristate "MP200 Watchdog"
+	depends on ARCH_MP200
+
 # ARM26 Architecture
 
 # AVR32 Architecture
diff --git a/drivers/watchdog/Makefile b/drivers/watchdog/Makefile
index 0a32c33..0005cee 100644
--- a/drivers/watchdog/Makefile
+++ b/drivers/watchdog/Makefile
@@ -39,6 +39,7 @@ obj-$(CONFIG_EP93XX_WATCHDOG) += ep93xx_wdt.o
 obj-$(CONFIG_PNX4008_WATCHDOG) += pnx4008_wdt.o
 obj-$(CONFIG_IOP_WATCHDOG) += iop_wdt.o
 obj-$(CONFIG_DAVINCI_WATCHDOG) += davinci_wdt.o
+obj-$(CONFIG_MP200_WATCHDOG) += mp200_wdt.o
 
 # ARM26 Architecture
 
diff --git a/drivers/watchdog/mp200_wdt.c b/drivers/watchdog/mp200_wdt.c
new file mode 100644
index 0000000..587b178
--- /dev/null
+++ b/drivers/watchdog/mp200_wdt.c
@@ -0,0 +1,260 @@
+/*
+ *  File Name       : linux/drivers/char/mp200_wdt.c
+ *  Function        : MP200 Watchdog driver
+ *  Release Version : Ver 1.00
+ *  Release Date    : 2007/09/27
+ *
+ *  Copyright (C) NEC Electronics Corporation 2007
+ *
+ *
+ *  This program is free software;you can redistribute it and/or modify itunder
+ *  the terms of the GNU General Public License as published by Free Softwere
+ *  Foundation;either version 2 of License, or (at your option) any later
+ *  version.
+ *
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warrnty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; If not, write to the Free Software Foundation, Inc., 59
+ *  Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/types.h>
+#include <linux/miscdevice.h>
+#include <linux/watchdog.h>
+#include <linux/ioport.h>
+#include <linux/notifier.h>
+#include <linux/reboot.h>
+#include <linux/init.h>
+#include <linux/fs.h>
+
+#include <linux/uaccess.h>
+#include <linux/io.h>
+
+#include <mach/pwc.h>
+#include <mach/timer.h>
+
+/* PWC register parameter */
+#define RDET_EN			0x01
+
+#define WDT_MIN_TIMEOUT	1
+#define WDT_MAX_TIMEOUT	4294
+#define DEFAULT_TIMEOUT 32	/* 32 sec default timeout */
+
+/* module parameters */
+static int timeout = DEFAULT_TIMEOUT;
+module_param(timeout, int, 0);
+MODULE_PARM_DESC(timeout, "Watchdog timeout in seconds. "
+	"(1<timeout<4294, default=" __MODULE_STRING(DEFAULT_TIMEOUT) ")");
+
+static int nowayout = WATCHDOG_NOWAYOUT;
+module_param(nowayout, int, 0);
+MODULE_PARM_DESC(nowayout, "Watchdog cannot be stopped once started "
+	"(default=CONFIG_WATCHDOG_NOWAYOUT)");
+
+static unsigned long opened;
+static char expect_close;
+
+static int mp200_wdt_open(struct inode *inode, struct file *file)
+{
+	if (test_and_set_bit(0, &opened))
+		return -EBUSY;
+
+	mp200_wdt_enable();
+
+	return nonseekable_open(inode, file);
+}
+
+static int mp200_wdt_release(struct inode *inode, struct file *file)
+{
+	/*
+	 *	Shut off the timer.
+	 * 	Lock it in if it's a module and we set nowayout
+	 */
+	if (expect_close == 42) {
+		mp200_wdt_disable();
+	} else {
+		printk(KERN_CRIT "unexpected close, not stopping watchdog!\n");
+		mp200_wdt_ping();
+	}
+
+	clear_bit(0, &opened);
+	expect_close = 0;
+
+	return 0;
+}
+
+static ssize_t
+mp200_wdt_write(struct file *file, const char *data, size_t len, loff_t *ppos)
+{
+	/* Refresh the timer. */
+	if (len) {
+		if (!nowayout) {
+			size_t i;
+
+			/* In case it was set long ago */
+			expect_close = 0;
+
+			/*
+			 * scan to see whether or not we got the magic
+			 * character
+			 */
+			for (i = 0; i != len; i++) {
+				char c;
+				if (get_user(c, data+i))
+					return -EFAULT;
+				if (c == 'V')
+					expect_close = 42;
+			}
+		}
+		mp200_wdt_ping();
+	}
+	return len;
+}
+
+static int
+mp200_wdt_ioctl(struct inode *inode, struct file *file,
+		unsigned int cmd, unsigned long arg)
+{
+	void __user *argp = (void __user *)arg;
+	int __user *p = argp;
+	static struct watchdog_info ident = {
+		.options = WDIOF_KEEPALIVEPING | WDIOF_SETTIMEOUT
+				| WDIOF_MAGICCLOSE,
+		.firmware_version = 0,
+		.identity = "mp200 Watchdog",
+	};
+	int new_margin, new_options;
+	int ret;
+
+	switch (cmd) {
+	case WDIOC_GETSUPPORT:
+		return copy_to_user(argp, &ident, sizeof(ident)) ? -EFAULT : 0;
+
+	case WDIOC_GETSTATUS:
+	case WDIOC_GETBOOTSTATUS:
+			return put_user(0, p);
+
+	case WDIOC_KEEPALIVE:
+		mp200_wdt_ping();
+		return 0;
+
+	case WDIOC_SETOPTIONS:
+		ret = -EINVAL;
+		if (get_user(new_options, p))
+			return -EFAULT;
+
+		if (new_options & WDIOS_DISABLECARD) {
+			mp200_wdt_disable();
+			ret = 0;
+		}
+
+		if (new_options & WDIOS_ENABLECARD) {
+			mp200_wdt_enable();
+			ret = 0;
+		}
+
+		return ret;
+
+	case WDIOC_SETTIMEOUT:
+		if (get_user(new_margin, p))
+			return -EFAULT;
+
+		timeout = new_margin;
+		if ((new_margin < WDT_MIN_TIMEOUT)
+		    || (new_margin > WDT_MAX_TIMEOUT)) {
+			timeout = DEFAULT_TIMEOUT;
+		}
+		mp200_wdt_set_timeout(timeout * SEC_1);
+		/* Fall */
+	case WDIOC_GETTIMEOUT:
+		return put_user(timeout, p);
+
+	default:
+		return -ENOTTY;
+	}
+}
+
+static int
+mp200_notify_sys(struct notifier_block *this, unsigned long code, void *unused)
+{
+	if (code == SYS_DOWN || code == SYS_HALT) {
+		/* Turn the WDT off */
+		mp200_wdt_disable();
+	}
+
+	return NOTIFY_DONE;
+}
+
+static const struct file_operations mp200_wdt_fops = {
+	.owner   = THIS_MODULE,
+	.llseek  = no_llseek,
+	.ioctl   = mp200_wdt_ioctl,
+	.write   = mp200_wdt_write,
+	.open    = mp200_wdt_open,
+	.release = mp200_wdt_release,
+};
+
+static struct miscdevice mp200_wdt_miscdev = {
+	.minor = WATCHDOG_MINOR,
+	.name  = "watchdog",
+	.fops  = &mp200_wdt_fops,
+};
+
+static struct notifier_block mp200_notifier = {
+	.notifier_call = mp200_notify_sys,
+};
+
+
+static int __init mp200_wdt_init(void)
+{
+	int ret;
+
+	printk(KERN_INFO "Starting wdt.\n");
+
+	ret = misc_register(&mp200_wdt_miscdev);
+	if (ret != 0)
+		return ret;
+
+	ret = register_reboot_notifier(&mp200_notifier);
+	if (ret != 0) {
+		printk(KERN_ERR "cannot register reboot notifier (err=%d)\n",
+				ret);
+		misc_deregister(&mp200_wdt_miscdev);
+		return ret;
+	}
+
+	/* Init WatchDog timer */
+	mp200_wdt_setup();
+	mp200_wdt_set_timeout(timeout * SEC_1);
+
+#ifdef	CONFIG_MP200_EM1_DKIT
+#else
+	pwc_write(PWC_RDET_EN, RDET_EN, RDET_EN);
+#endif
+
+	return 0;
+}
+
+static void __exit mp200_wdt_exit(void)
+{
+	mp200_wdt_disable();
+
+	unregister_reboot_notifier(&mp200_notifier);
+	misc_deregister(&mp200_wdt_miscdev);
+}
+
+module_init(mp200_wdt_init);
+module_exit(mp200_wdt_exit);
+
+MODULE_AUTHOR("NECEL");
+MODULE_DESCRIPTION("MP200 Watchdog Device Driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS_MISCDEV(WATCHDOG_MINOR);
-- 
1.6.5.2

