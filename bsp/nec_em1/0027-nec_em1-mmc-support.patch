From 04728a293472d3d7427261b3469e10bf6447a1cb Mon Sep 17 00:00:00 2001
From: Kazuya Tsukamoto <kazuya.tsukamoto@necel.com>
Date: Mon, 9 Nov 2009 15:11:54 +0900
Subject: [PATCH 27/29] nec_em1: mmc support

mmc : support card slot and eMMC.

Notes:
 - In eMMC, there is no detection interrupt.
 - because device removal is done when suspending, the power
   supply of the device can be stopped while suspending it.

Signed-off-by: Kazuya Tsukamoto <kazuya.tsukamoto@necel.com>
---
 drivers/mmc/card/block.c        |   34 ++-
 drivers/mmc/card/queue.c        |   41 ++-
 drivers/mmc/card/queue.h        |    4 +
 drivers/mmc/core/core.c         |   10 +
 drivers/mmc/core/host.c         |    5 +
 drivers/mmc/core/mmc.c          |  215 +++++++++-
 drivers/mmc/core/mmc_ops.c      |   18 +-
 drivers/mmc/core/sd.c           |   65 +++-
 drivers/mmc/core/sd_ops.c       |    5 +-
 drivers/mmc/core/sdio.c         |   57 +++-
 drivers/mmc/core/sdio_irq.c     |    4 +
 drivers/mmc/host/Kconfig        |    9 +
 drivers/mmc/host/Makefile       |    2 +
 drivers/mmc/host/mp200_mmc.c    |  817 ++++++++++++++++++++++++++++++++++++
 drivers/mmc/host/mp200_mmc.h    |  233 +++++++++++
 drivers/mmc/host/mp200_mmc_sd.c |  882 +++++++++++++++++++++++++++++++++++++++
 include/linux/mmc/host.h        |    8 +
 17 files changed, 2376 insertions(+), 33 deletions(-)
 create mode 100644 drivers/mmc/host/mp200_mmc.c
 create mode 100644 drivers/mmc/host/mp200_mmc.h
 create mode 100644 drivers/mmc/host/mp200_mmc_sd.c

diff --git a/drivers/mmc/card/block.c b/drivers/mmc/card/block.c
index ebc8b9d..762b575 100644
--- a/drivers/mmc/card/block.c
+++ b/drivers/mmc/card/block.c
@@ -29,6 +29,7 @@
 #include <linux/blkdev.h>
 #include <linux/mutex.h>
 #include <linux/scatterlist.h>
+#include <linux/uaccess.h>
 
 #include <linux/mmc/card.h>
 #include <linux/mmc/host.h>
@@ -36,7 +37,10 @@
 #include <linux/mmc/sd.h>
 
 #include <asm/system.h>
-#include <asm/uaccess.h>
+
+#ifdef CONFIG_PM
+#include <mach/pm.h>
+#endif
 
 #include "queue.h"
 
@@ -210,6 +214,9 @@ static u32 mmc_sd_num_wr_blocks(struct mmc_card *card)
 	return blocks;
 }
 
+#ifdef CONFIG_ARCH_MP200
+#include "../core/mmc_ops.h"
+#endif
 static int mmc_blk_issue_rq(struct mmc_queue *mq, struct request *req)
 {
 	struct mmc_blk_data *md = mq->data;
@@ -220,6 +227,9 @@ static int mmc_blk_issue_rq(struct mmc_queue *mq, struct request *req)
 
 	mmc_claim_host(card->host);
 
+#ifdef CONFIG_ARCH_MP200
+	mmc_select_card(card);
+#endif
 	do {
 		struct mmc_command cmd;
 		u32 readcmd, writecmd;
@@ -357,11 +367,11 @@ static int mmc_blk_issue_rq(struct mmc_queue *mq, struct request *req)
 
 	return 1;
 
- cmd_err:
- 	/*
- 	 * If this is an SD card and we're writing, we can first
- 	 * mark the known good sectors as ok.
- 	 *
+cmd_err:
+	/*
+	 * If this is an SD card and we're writing, we can first
+	 * mark the known good sectors as ok.
+	 *
 	 * If the card is not SD, we can still ok written sectors
 	 * as reported by the controller (which might be less than
 	 * the real number of written sectors, but never more).
@@ -512,6 +522,9 @@ mmc_blk_set_blksize(struct mmc_blk_data *md, struct mmc_card *card)
 		return 0;
 
 	mmc_claim_host(card->host);
+#ifdef CONFIG_ARCH_MP200
+	mmc_select_card(card);
+#endif
 	cmd.opcode = MMC_SET_BLOCKLEN;
 	cmd.arg = 1 << md->block_bits;
 	cmd.flags = MMC_RSP_SPI_R1 | MMC_RSP_R1 | MMC_CMD_AC;
@@ -583,7 +596,11 @@ static int mmc_blk_suspend(struct mmc_card *card, pm_message_t state)
 	struct mmc_blk_data *md = mmc_get_drvdata(card);
 
 	if (md) {
+#ifdef CONFIG_ARCH_MP200
+		return mmc_queue_suspend(&md->queue, state);
+#else
 		mmc_queue_suspend(&md->queue);
+#endif
 	}
 	return 0;
 }
@@ -593,7 +610,12 @@ static int mmc_blk_resume(struct mmc_card *card)
 	struct mmc_blk_data *md = mmc_get_drvdata(card);
 
 	if (md) {
+#ifdef CONFIG_ARCH_MP200
+		if (!mp200_sleep_while_idle)
+			mmc_blk_set_blksize(md, card);
+#else
 		mmc_blk_set_blksize(md, card);
+#endif
 		mmc_queue_resume(&md->queue);
 	}
 	return 0;
diff --git a/drivers/mmc/card/queue.c b/drivers/mmc/card/queue.c
index 3dee97e..3676b0d 100644
--- a/drivers/mmc/card/queue.c
+++ b/drivers/mmc/card/queue.c
@@ -198,12 +198,11 @@ int mmc_init_queue(struct mmc_queue *mq, struct mmc_card *card, spinlock_t *lock
 	}
 
 	return 0;
- free_bounce_sg:
- 	if (mq->bounce_sg)
- 		kfree(mq->bounce_sg);
- 	mq->bounce_sg = NULL;
- cleanup_queue:
- 	if (mq->sg)
+free_bounce_sg:
+	kfree(mq->bounce_sg);
+	mq->bounce_sg = NULL;
+cleanup_queue:
+	if (mq->sg)
 		kfree(mq->sg);
 	mq->sg = NULL;
 	if (mq->bounce_buf)
@@ -229,9 +228,8 @@ void mmc_cleanup_queue(struct mmc_queue *mq)
 	/* Then terminate our worker thread */
 	kthread_stop(mq->thread);
 
- 	if (mq->bounce_sg)
- 		kfree(mq->bounce_sg);
- 	mq->bounce_sg = NULL;
+	kfree(mq->bounce_sg);
+	mq->bounce_sg = NULL;
 
 	kfree(mq->sg);
 	mq->sg = NULL;
@@ -254,7 +252,11 @@ EXPORT_SYMBOL(mmc_cleanup_queue);
  * complete any outstanding requests.  This ensures that we
  * won't suspend while a request is being processed.
  */
+#ifdef CONFIG_ARCH_MP200
+int mmc_queue_suspend(struct mmc_queue *mq, pm_message_t state)
+#else
 void mmc_queue_suspend(struct mmc_queue *mq)
+#endif
 {
 	struct request_queue *q = mq->queue;
 	unsigned long flags;
@@ -266,8 +268,29 @@ void mmc_queue_suspend(struct mmc_queue *mq)
 		blk_stop_queue(q);
 		spin_unlock_irqrestore(q->queue_lock, flags);
 
+#ifdef CONFIG_ARCH_MP200
+		switch (state.event) {
+		case DEV_SUSPEND_IDLE_1:
+			if (down_trylock(&mq->thread_sem)) {
+				mq->flags &= ~MMC_QUEUE_SUSPENDED;
+				spin_lock_irqsave(q->queue_lock, flags);
+				blk_start_queue(q);
+				spin_unlock_irqrestore(q->queue_lock, flags);
+				return -EBUSY;
+			}
+			break;
+		case PM_EVENT_SUSPEND:
+			down(&mq->thread_sem);
+			break;
+		default:
+			break;
+		}
+	}
+	return 0;
+#else
 		down(&mq->thread_sem);
 	}
+#endif
 }
 
 /**
diff --git a/drivers/mmc/card/queue.h b/drivers/mmc/card/queue.h
index 64e66e0..3617911 100644
--- a/drivers/mmc/card/queue.h
+++ b/drivers/mmc/card/queue.h
@@ -21,7 +21,11 @@ struct mmc_queue {
 
 extern int mmc_init_queue(struct mmc_queue *, struct mmc_card *, spinlock_t *);
 extern void mmc_cleanup_queue(struct mmc_queue *);
+#ifdef CONFIG_ARCH_MP200
+extern int mmc_queue_suspend(struct mmc_queue *, pm_message_t);
+#else
 extern void mmc_queue_suspend(struct mmc_queue *);
+#endif
 extern void mmc_queue_resume(struct mmc_queue *);
 
 extern unsigned int mmc_queue_map_sg(struct mmc_queue *);
diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index f7284b9..9d389c5 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -737,6 +737,9 @@ void mmc_stop_host(struct mmc_host *host)
 	host->removed = 1;
 	spin_unlock_irqrestore(&host->lock, flags);
 #endif
+#ifdef CONFIG_ARCH_MP200
+	int i;
+#endif
 
 	mmc_flush_scheduled_work();
 
@@ -751,7 +754,12 @@ void mmc_stop_host(struct mmc_host *host)
 	}
 	mmc_bus_put(host);
 
+#ifdef CONFIG_ARCH_MP200
+	for (i = 0; i < host->card_num; i++)
+		BUG_ON(host->card[i]);
+#else
 	BUG_ON(host->card);
+#endif
 
 	mmc_power_off(host);
 }
@@ -797,7 +805,9 @@ int mmc_resume_host(struct mmc_host *host)
 {
 	mmc_bus_get(host);
 	if (host->bus_ops && !host->bus_dead) {
+		mmc_claim_host(host);
 		mmc_power_up(host);
+		mmc_release_host(host);
 		BUG_ON(!host->bus_ops->resume);
 		host->bus_ops->resume(host);
 	}
diff --git a/drivers/mmc/core/host.c b/drivers/mmc/core/host.c
index 6da80fd..c9e7fd2 100644
--- a/drivers/mmc/core/host.c
+++ b/drivers/mmc/core/host.c
@@ -97,6 +97,11 @@ struct mmc_host *mmc_alloc_host(int extra, struct device *dev)
 	host->max_blk_size = 512;
 	host->max_blk_count = PAGE_CACHE_SIZE / 512;
 
+#ifdef CONFIG_ARCH_MP200
+	host->card_num = 1;
+	host->select = 0xffffffff;
+#endif
+
 	return host;
 
 free:
diff --git a/drivers/mmc/core/mmc.c b/drivers/mmc/core/mmc.c
index fdd7c76..283c5f0 100644
--- a/drivers/mmc/core/mmc.c
+++ b/drivers/mmc/core/mmc.c
@@ -39,7 +39,7 @@ static const unsigned int tacc_mant[] = {
 	35,	40,	45,	50,	55,	60,	70,	80,
 };
 
-#define UNSTUFF_BITS(resp,start,size)					\
+#define UNSTUFF_BITS(resp, start, size)					\
 	({								\
 		const int __size = size;				\
 		const u32 __mask = (__size < 32 ? 1 << __size : 0) - 1;	\
@@ -107,6 +107,9 @@ static int mmc_decode_cid(struct mmc_card *card)
 	return 0;
 }
 
+#ifdef CONFIG_ARCH_MP200
+static unsigned int s_csd_struct = -1;
+#endif
 /*
  * Given a 128-bit response, decode to our card CSD structure.
  */
@@ -121,10 +124,24 @@ static int mmc_decode_csd(struct mmc_card *card)
 	 * v1.2 has extra information in bits 15, 11 and 10.
 	 */
 	csd_struct = UNSTUFF_BITS(resp, 126, 2);
+#ifdef CONFIG_ARCH_MP200
+	s_csd_struct = csd_struct;
+#endif
+
 	if (csd_struct != 1 && csd_struct != 2) {
+#ifdef CONFIG_ARCH_MP200
+		s_csd_struct = -1;
+		if (csd_struct != 3) {
+			printk(KERN_ERR "%s: unrecognised CSD structure version %d\n",
+			mmc_hostname(card->host), csd_struct);
+			return -EINVAL;
+		}
+		/* check csd_struct in ext_csd */
+#else
 		printk(KERN_ERR "%s: unrecognised CSD structure version %d\n",
 			mmc_hostname(card->host), csd_struct);
 		return -EINVAL;
+#endif
 	}
 
 	csd->mmca_vsn	 = UNSTUFF_BITS(resp, 122, 4);
@@ -164,8 +181,13 @@ static int mmc_read_ext_csd(struct mmc_card *card)
 
 	BUG_ON(!card);
 
+#ifdef CONFIG_ARCH_MP200
+	if (s_csd_struct != -1 && card->csd.mmca_vsn < CSD_SPEC_VER_4)
+		return 0;
+#else
 	if (card->csd.mmca_vsn < CSD_SPEC_VER_4)
 		return 0;
+#endif
 
 	/*
 	 * As the ext_csd is so large and mostly unused, we don't store the
@@ -207,7 +229,20 @@ static int mmc_read_ext_csd(struct mmc_card *card)
 		goto out;
 	}
 
+#ifdef CONFIG_ARCH_MP200
+	ext_csd_struct = ext_csd[194];
+	if (s_csd_struct == -1) {
+		/* check csd_struct */
+		s_csd_struct = ext_csd_struct;
+		if (s_csd_struct != 1 && s_csd_struct != 2) {
+			printk(KERN_ERR "%s: unrecognised CSD structure version %d in ext_csd\n",
+				mmc_hostname(card->host), s_csd_struct);
+			return -EINVAL;
+		}
+	}
+#else
 	ext_csd_struct = ext_csd[EXT_CSD_REV];
+#endif
 	if (ext_csd_struct > 2) {
 		printk(KERN_ERR "%s: unrecognised EXT_CSD structure "
 			"version %d\n", mmc_hostname(card->host),
@@ -222,7 +257,11 @@ static int mmc_read_ext_csd(struct mmc_card *card)
 			ext_csd[EXT_CSD_SEC_CNT + 1] << 8 |
 			ext_csd[EXT_CSD_SEC_CNT + 2] << 16 |
 			ext_csd[EXT_CSD_SEC_CNT + 3] << 24;
+#ifdef CONFIG_ARCH_MP200
+		if (card->ext_csd.sectors > 0x400000)
+#else
 		if (card->ext_csd.sectors)
+#endif
 			mmc_card_set_blockaddr(card);
 	}
 
@@ -292,15 +331,29 @@ static struct device_type mmc_type = {
  * we're trying to reinitialise.
  */
 static int mmc_init_card(struct mmc_host *host, u32 ocr,
+#ifdef CONFIG_ARCH_MP200
+	struct mmc_card **oldcard)
+#else
 	struct mmc_card *oldcard)
+#endif
 {
 	struct mmc_card *card;
 	int err;
 	u32 cid[4];
 	unsigned int max_dtr;
+#ifdef CONFIG_ARCH_MP200
+	int i;
+#endif
 
 	BUG_ON(!host);
 	WARN_ON(!host->claimed);
+#ifdef CONFIG_ARCH_MP200
+	BUG_ON(host->card_num > MMC_CARD_MAX_NUM);
+	BUG_ON(oldcard && !oldcard[0]);
+
+	/* initialize select state */
+	host->select = 0xffffffff;
+#endif
 
 	/*
 	 * Since we're changing the OCR value, we seem to
@@ -315,6 +368,51 @@ static int mmc_init_card(struct mmc_host *host, u32 ocr,
 	if (err)
 		goto err;
 
+#ifdef CONFIG_ARCH_MP200
+	for (i = 0; i < host->card_num; i++) {
+		err = mmc_all_send_cid(host, cid);
+		if (err) {
+			if (i == 0) {
+				printk(KERN_ERR "%s:%d: Error \n",
+							__func__, __LINE__);
+				goto err;
+			} else {
+				host->card_num = i;
+				break;
+			}
+		}
+
+		if (oldcard) {
+			if (memcmp(cid, oldcard[i]->raw_cid,
+							sizeof(cid)) != 0) {
+				err = -ENOENT;
+				printk(KERN_ERR "%s:%d: Error \n",
+							__func__, __LINE__);
+				goto err;
+			}
+			host->card[i] = oldcard[i];
+		} else {
+			/*
+			 * Allocate card structure.
+			 */
+			host->card[i] = mmc_alloc_card(host, &mmc_type);
+			if (IS_ERR(host->card[i])) {
+				err = PTR_ERR(host->card[i]);
+				goto err;
+			}
+
+			host->card[i]->type = MMC_TYPE_MMC;
+			host->card[i]->rca = i+1;
+			memcpy(host->card[i]->raw_cid, cid, sizeof(cid));
+		}
+		/*
+		 * Set card RCA.
+		 */
+		err = mmc_set_relative_addr(host->card[i]);
+		if (err)
+			goto free_card;
+	}
+#else
 	/*
 	 * For SPI, enable CRC as appropriate.
 	 */
@@ -363,10 +461,17 @@ static int mmc_init_card(struct mmc_host *host, u32 ocr,
 		err = mmc_set_relative_addr(card);
 		if (err)
 			goto free_card;
-
+#endif /* CONFIG_ARCH_MP200 */
+#ifdef CONFIG_ARCH_MP200
+	if (!mmc_host_is_spi(host)) {
+#endif
 		mmc_set_bus_mode(host, MMC_BUSMODE_PUSHPULL);
 	}
 
+#ifdef CONFIG_ARCH_MP200
+	for (i = 0; i < host->card_num; i++) {
+		card = host->card[i];
+#endif
 	if (!oldcard) {
 		/*
 		 * Fetch CSD from card.
@@ -396,9 +501,21 @@ static int mmc_init_card(struct mmc_host *host, u32 ocr,
 		/*
 		 * Fetch and process extended CSD.
 		 */
+#ifdef CONFIG_ARCH_MP200
+		if (i == 0) {
+			err = mmc_read_ext_csd(card);
+			if (err)
+				goto free_card;
+		} else {
+			host->card[i]->ext_csd = host->card[0]->ext_csd;
+			if (host->card[i]->ext_csd.sectors)
+				mmc_card_set_blockaddr(card);
+		}
+#else
 		err = mmc_read_ext_csd(card);
 		if (err)
 			goto free_card;
+#endif
 	}
 
 	/*
@@ -442,15 +559,25 @@ static int mmc_init_card(struct mmc_host *host, u32 ocr,
 
 		mmc_set_bus_width(card->host, MMC_BUS_WIDTH_4);
 	}
-
+#ifdef CONFIG_ARCH_MP200
+	} /* for */
+#else
 	if (!oldcard)
 		host->card = card;
+#endif
 
 	return 0;
 
 free_card:
+#ifdef CONFIG_ARCH_MP200
+	if (!oldcard) {
+		for (i = 0; i < host->card_num; i++)
+			mmc_remove_card(host->card[i]);
+	}
+#else
 	if (!oldcard)
 		mmc_remove_card(card);
+#endif
 err:
 
 	return err;
@@ -461,11 +588,22 @@ err:
  */
 static void mmc_remove(struct mmc_host *host)
 {
+#ifdef CONFIG_ARCH_MP200
+	int i;
+#endif
 	BUG_ON(!host);
+#ifdef CONFIG_ARCH_MP200
+	for (i = 0; i < host->card_num; i++) {
+		BUG_ON(!host->card[i]);
+		mmc_remove_card(host->card[i]);
+		host->card[i] = NULL;
+	}
+#else
 	BUG_ON(!host->card);
 
 	mmc_remove_card(host->card);
 	host->card = NULL;
+#endif
 }
 
 /*
@@ -473,18 +611,31 @@ static void mmc_remove(struct mmc_host *host)
  */
 static void mmc_detect(struct mmc_host *host)
 {
-	int err;
+	int err = 0;
+#ifdef CONFIG_ARCH_MP200
+	int i;
+#endif
 
 	BUG_ON(!host);
+#ifndef CONFIG_ARCH_MP200
 	BUG_ON(!host->card);
+#endif
 
 	mmc_claim_host(host);
 
 	/*
 	 * Just check if our card has been removed.
 	 */
+#ifdef CONFIG_ARCH_MP200
+	if (host->ios.power_mode != MMC_POWER_OFF) {
+		for (i = 0; i < host->card_num; i++) {
+			if (host->card[i])
+				err |= mmc_send_status(host->card[i], NULL);
+		}
+	}
+#else
 	err = mmc_send_status(host->card, NULL);
-
+#endif
 	mmc_release_host(host);
 
 	if (err) {
@@ -503,13 +654,26 @@ static void mmc_detect(struct mmc_host *host)
  */
 static void mmc_suspend(struct mmc_host *host)
 {
+#ifdef CONFIG_ARCH_MP200
+	int i;
+#endif
 	BUG_ON(!host);
+#ifdef CONFIG_ARCH_MP200
+	for (i = 0; i < host->card_num; i++)
+		BUG_ON(!host->card[i]);
+#else
 	BUG_ON(!host->card);
+#endif
 
 	mmc_claim_host(host);
 	if (!mmc_host_is_spi(host))
 		mmc_deselect_cards(host);
+#ifdef CONFIG_ARCH_MP200
+	for (i = 0; i < host->card_num; i++)
+		host->card[i]->state &= ~MMC_STATE_HIGHSPEED;
+#else
 	host->card->state &= ~MMC_STATE_HIGHSPEED;
+#endif
 	mmc_release_host(host);
 }
 
@@ -521,15 +685,35 @@ static void mmc_suspend(struct mmc_host *host)
  */
 static void mmc_resume(struct mmc_host *host)
 {
-	int err;
+	int err = 0;
+#ifdef CONFIG_ARCH_MP200
+	int i, skip_flag = 0;
+#endif
 
 	BUG_ON(!host);
+#ifndef CONFIG_ARCH_MP200
 	BUG_ON(!host->card);
+#endif
 
 	mmc_claim_host(host);
+#ifdef CONFIG_ARCH_MP200
+	for (i = 0; i < host->card_num; i++) {
+		if (host->card[i] == NULL)
+			skip_flag = 1;
+	}
+	if (!skip_flag) {
+		err = mmc_init_card(host, host->ocr, host->card);
+		if (err) {
+			mmc_remove(host);
+			mmc_detach_bus(host);
+		}
+	}
+#else
 	err = mmc_init_card(host, host->ocr, host->card);
+#endif
 	mmc_release_host(host);
 
+#ifndef CONFIG_ARCH_MP200
 	if (err) {
 		mmc_remove(host);
 
@@ -537,6 +721,7 @@ static void mmc_resume(struct mmc_host *host)
 		mmc_detach_bus(host);
 		mmc_release_host(host);
 	}
+#endif
 
 }
 
@@ -560,6 +745,9 @@ static const struct mmc_bus_ops mmc_ops = {
 int mmc_attach_mmc(struct mmc_host *host, u32 ocr)
 {
 	int err;
+#ifdef CONFIG_ARCH_MP200
+	int i;
+#endif
 
 	BUG_ON(!host);
 	WARN_ON(!host->claimed);
@@ -605,15 +793,30 @@ int mmc_attach_mmc(struct mmc_host *host, u32 ocr)
 
 	mmc_release_host(host);
 
+#ifdef CONFIG_ARCH_MP200
+	for (i = 0; i < host->card_num; i++) {
+		err = mmc_add_card(host->card[i]);
+		if (err)
+			goto remove_card;
+	}
+#else
 	err = mmc_add_card(host->card);
 	if (err)
 		goto remove_card;
+#endif
 
 	return 0;
 
 remove_card:
+#ifdef CONFIG_ARCH_MP200
+	for (i = 0; i < host->card_num; i++) {
+		mmc_remove_card(host->card[i]);
+		host->card[i] = NULL;
+	}
+#else
 	mmc_remove_card(host->card);
 	host->card = NULL;
+#endif
 	mmc_claim_host(host);
 err:
 	mmc_detach_bus(host);
diff --git a/drivers/mmc/core/mmc_ops.c b/drivers/mmc/core/mmc_ops.c
index 64b05c6..e0475de 100644
--- a/drivers/mmc/core/mmc_ops.c
+++ b/drivers/mmc/core/mmc_ops.c
@@ -33,10 +33,17 @@ static int _mmc_select_card(struct mmc_host *host, struct mmc_card *card)
 	if (card) {
 		cmd.arg = card->rca << 16;
 		cmd.flags = MMC_RSP_R1 | MMC_CMD_AC;
+#ifdef CONFIG_ARCH_MP200
+		if (host->select == cmd.arg)
+			return 0; /* through */
+#endif
 	} else {
 		cmd.arg = 0;
 		cmd.flags = MMC_RSP_NONE | MMC_CMD_AC;
 	}
+#ifdef CONFIG_ARCH_MP200
+	host->select = cmd.arg;
+#endif
 
 	err = mmc_wait_for_cmd(host, &cmd, MMC_CMD_RETRIES);
 	if (err)
@@ -276,7 +283,7 @@ int mmc_send_csd(struct mmc_card *card, u32 *csd)
 	if (ret)
 		return ret;
 
-	for (i = 0;i < 4;i++)
+	for (i = 0; i < 4; i++)
 		csd[i] = be32_to_cpu(csd[i]);
 
 	return 0;
@@ -289,15 +296,20 @@ int mmc_send_cid(struct mmc_host *host, u32 *cid)
 	if (!mmc_host_is_spi(host)) {
 		if (!host->card)
 			return -EINVAL;
+#ifdef CONFIG_ARCH_MP200
+		return mmc_send_cxd_native(host, host->card[0]->rca << 16,
+				cid, MMC_SEND_CID);
+#else
 		return mmc_send_cxd_native(host, host->card->rca << 16,
 				cid, MMC_SEND_CID);
+#endif
 	}
 
 	ret = mmc_send_cxd_data(NULL, host, MMC_SEND_CID, cid, 16);
 	if (ret)
 		return ret;
 
-	for (i = 0;i < 4;i++)
+	for (i = 0; i < 4; i++)
 		cid[i] = be32_to_cpu(cid[i]);
 
 	return 0;
@@ -360,7 +372,7 @@ int mmc_switch(struct mmc_card *card, u8 set, u8 index, u8 value)
 		  set;
 	cmd.flags = MMC_RSP_SPI_R1B | MMC_RSP_R1B | MMC_CMD_AC;
 
-	err = mmc_wait_for_cmd(card->host, &cmd, MMC_CMD_RETRIES);
+	err = mmc_wait_for_cmd(card->host, &cmd, 0);
 	if (err)
 		return err;
 
diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index 26fc098..c927e7a 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -41,7 +41,7 @@ static const unsigned int tacc_mant[] = {
 	35,	40,	45,	50,	55,	60,	70,	80,
 };
 
-#define UNSTUFF_BITS(resp,start,size)					\
+#define UNSTUFF_BITS(resp, start, size)					\
 	({								\
 		const int __size = size;				\
 		const u32 __mask = (__size < 32 ? 1 << __size : 0) - 1;	\
@@ -336,10 +336,18 @@ static int mmc_sd_init_card(struct mmc_host *host, u32 ocr,
 	int err;
 	u32 cid[4];
 	unsigned int max_dtr;
+#ifdef CONFIG_MMC_PARANOID_SD_INIT
+	int retries;
+#endif
 
 	BUG_ON(!host);
 	WARN_ON(!host->claimed);
+#ifdef CONFIG_ARCH_MP200
+	BUG_ON(host->card_num > 1);
 
+	/* initialize select state */
+	host->select = 0xffffffff;
+#endif
 	/*
 	 * Since we're changing the OCR value, we seem to
 	 * need to tell some cards to go back to the idle
@@ -505,8 +513,13 @@ static int mmc_sd_init_card(struct mmc_host *host, u32 ocr,
 		}
 	}
 
+#ifdef CONFIG_ARCH_MP200
+	if (!oldcard)
+		host->card[0] = card;
+#else
 	if (!oldcard)
 		host->card = card;
+#endif
 
 	return 0;
 
@@ -524,10 +537,17 @@ err:
 static void mmc_sd_remove(struct mmc_host *host)
 {
 	BUG_ON(!host);
+#ifdef CONFIG_ARCH_MP200
+	BUG_ON(!host->card[0]);
+
+	mmc_remove_card(host->card[0]);
+	host->card[0] = NULL;
+#else
 	BUG_ON(!host->card);
 
 	mmc_remove_card(host->card);
 	host->card = NULL;
+#endif
 }
 
 /*
@@ -535,18 +555,26 @@ static void mmc_sd_remove(struct mmc_host *host)
  */
 static void mmc_sd_detect(struct mmc_host *host)
 {
-	int err;
+	int err = 0;
 
 	BUG_ON(!host);
+#ifndef CONFIG_ARCH_MP200
 	BUG_ON(!host->card);
+#endif
 
 	mmc_claim_host(host);
 
 	/*
 	 * Just check if our card has been removed.
 	 */
+#ifdef CONFIG_ARCH_MP200
+	if (host->ios.power_mode != MMC_POWER_OFF) {
+		if (host->card[0])
+			err = mmc_send_status(host->card[0], NULL);
+	}
+#else
 	err = mmc_send_status(host->card, NULL);
-
+#endif
 	mmc_release_host(host);
 
 	if (err) {
@@ -566,12 +594,20 @@ static void mmc_sd_detect(struct mmc_host *host)
 static void mmc_sd_suspend(struct mmc_host *host)
 {
 	BUG_ON(!host);
+#ifdef CONFIG_ARCH_MP200
+	BUG_ON(!host->card[0]);
+#else
 	BUG_ON(!host->card);
+#endif
 
 	mmc_claim_host(host);
 	if (!mmc_host_is_spi(host))
 		mmc_deselect_cards(host);
+#ifdef CONFIG_ARCH_MP200
+	host->card[0]->state &= ~MMC_STATE_HIGHSPEED;
+#else
 	host->card->state &= ~MMC_STATE_HIGHSPEED;
+#endif
 	mmc_release_host(host);
 }
 
@@ -586,12 +622,25 @@ static void mmc_sd_resume(struct mmc_host *host)
 	int err;
 
 	BUG_ON(!host);
+#ifndef CONFIG_ARCH_MP200
 	BUG_ON(!host->card);
+#endif
 
 	mmc_claim_host(host);
+#ifdef CONFIG_ARCH_MP200
+	if (host->card[0]) {
+		err = mmc_sd_init_card(host, host->ocr, host->card[0]);
+		if (err) {
+			mmc_sd_remove(host);
+			mmc_detach_bus(host);
+		}
+	}
+#else
 	err = mmc_sd_init_card(host, host->ocr, host->card);
+#endif
 	mmc_release_host(host);
 
+#ifndef CONFIG_ARCH_MP200
 	if (err) {
 		mmc_sd_remove(host);
 
@@ -599,6 +648,7 @@ static void mmc_sd_resume(struct mmc_host *host)
 		mmc_detach_bus(host);
 		mmc_release_host(host);
 	}
+#endif
 
 }
 
@@ -676,15 +726,24 @@ int mmc_attach_sd(struct mmc_host *host, u32 ocr)
 
 	mmc_release_host(host);
 
+#ifdef CONFIG_ARCH_MP200
+	err = mmc_add_card(host->card[0]);
+#else
 	err = mmc_add_card(host->card);
+#endif
 	if (err)
 		goto remove_card;
 
 	return 0;
 
 remove_card:
+#ifdef CONFIG_ARCH_MP200
+	mmc_remove_card(host->card[0]);
+	host->card[0] = NULL;
+#else
 	mmc_remove_card(host->card);
 	host->card = NULL;
+#endif
 	mmc_claim_host(host);
 err:
 	mmc_detach_bus(host);
diff --git a/drivers/mmc/core/sd_ops.c b/drivers/mmc/core/sd_ops.c
index 0d96080..a285643 100644
--- a/drivers/mmc/core/sd_ops.c
+++ b/drivers/mmc/core/sd_ops.c
@@ -51,7 +51,7 @@ static int mmc_app_cmd(struct mmc_host *host, struct mmc_card *card)
 
 /**
  *	mmc_wait_for_app_cmd - start an application command and wait for
- 			       completion
+ *  completion
  *	@host: MMC host to start command
  *	@card: Card to send MMC_APP_CMD to
  *	@cmd: MMC command to start
@@ -78,7 +78,7 @@ int mmc_wait_for_app_cmd(struct mmc_host *host, struct mmc_card *card,
 	 * We have to resend MMC_APP_CMD for each attempt so
 	 * we cannot use the retries field in mmc_command.
 	 */
-	for (i = 0;i <= retries;i++) {
+	for (i = 0; i <= retries; i++) {
 		memset(&mrq, 0, sizeof(struct mmc_request));
 
 		err = mmc_app_cmd(host, card);
@@ -327,6 +327,7 @@ int mmc_sd_switch(struct mmc_card *card, int mode, int group,
 	cmd.arg &= ~(0xF << (group * 4));
 	cmd.arg |= value << (group * 4);
 	cmd.flags = MMC_RSP_SPI_R1 | MMC_RSP_R1 | MMC_CMD_ADTC;
+	cmd.retries = MMC_CMD_RETRIES;
 
 	data.blksz = 64;
 	data.blocks = 1;
diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index 4eab79e..717c1ef 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -172,9 +172,22 @@ static void mmc_sdio_remove(struct mmc_host *host)
 	int i;
 
 	BUG_ON(!host);
+#ifdef CONFIG_ARCH_MP200
+	BUG_ON(!host->card[0]);
+
+	for (i = 0; i < host->card[0]->sdio_funcs; i++) {
+		if (host->card[0]->sdio_func[i]) {
+			sdio_remove_func(host->card[0]->sdio_func[i]);
+			host->card[0]->sdio_func[i] = NULL;
+		}
+	}
+
+	mmc_remove_card(host->card[0]);
+	host->card[0] = NULL;
+#else
 	BUG_ON(!host->card);
 
-	for (i = 0;i < host->card->sdio_funcs;i++) {
+	for (i = 0; i < host->card->sdio_funcs; i++) {
 		if (host->card->sdio_func[i]) {
 			sdio_remove_func(host->card->sdio_func[i]);
 			host->card->sdio_func[i] = NULL;
@@ -183,6 +196,7 @@ static void mmc_sdio_remove(struct mmc_host *host)
 
 	mmc_remove_card(host->card);
 	host->card = NULL;
+#endif
 }
 
 /*
@@ -193,14 +207,22 @@ static void mmc_sdio_detect(struct mmc_host *host)
 	int err;
 
 	BUG_ON(!host);
+#ifdef CONFIG_ARCH_MP200
+	BUG_ON(!host->card[0]);
+#else
 	BUG_ON(!host->card);
+#endif
 
 	mmc_claim_host(host);
 
 	/*
 	 * Just check if our card has been removed.
 	 */
+#ifdef CONFIG_ARCH_MP200
+	err = mmc_select_card(host->card[0]);
+#else
 	err = mmc_select_card(host->card);
+#endif
 
 	mmc_release_host(host);
 
@@ -231,6 +253,9 @@ int mmc_attach_sdio(struct mmc_host *host, u32 ocr)
 
 	BUG_ON(!host);
 	WARN_ON(!host->claimed);
+#ifdef CONFIG_ARCH_MP200
+	BUG_ON(host->card_num > 1);
+#endif
 
 	mmc_attach_bus(host, &mmc_sdio_ops);
 
@@ -261,6 +286,10 @@ int mmc_attach_sdio(struct mmc_host *host, u32 ocr)
 		err = -EINVAL;
 		goto err;
 	}
+#ifdef CONFIG_ARCH_MP200
+	/* initialize select state */
+	host->select = 0xffffffff;
+#endif
 
 	/*
 	 * Inform the card of the voltage
@@ -296,7 +325,11 @@ int mmc_attach_sdio(struct mmc_host *host, u32 ocr)
 	card->type = MMC_TYPE_SDIO;
 	card->sdio_funcs = funcs;
 
+#ifdef CONFIG_ARCH_MP200
+	host->card[0] = card;
+#else
 	host->card = card;
+#endif
 
 	/*
 	 * For native busses:  set card RCA and quit open drain mode.
@@ -348,8 +381,12 @@ int mmc_attach_sdio(struct mmc_host *host, u32 ocr)
 	/*
 	 * Initialize (but don't add) all present functions.
 	 */
-	for (i = 0;i < funcs;i++) {
-		err = sdio_init_func(host->card, i + 1);
+	for (i = 0; i < funcs; i++) {
+#ifdef CONFIG_ARCH_MP200
+			err = sdio_init_func(host->card[0], i + 1);
+#else
+			err = sdio_init_func(host->card, i + 1);
+#endif
 		if (err)
 			goto remove;
 	}
@@ -359,15 +396,23 @@ int mmc_attach_sdio(struct mmc_host *host, u32 ocr)
 	/*
 	 * First add the card to the driver model...
 	 */
+#ifdef CONFIG_ARCH_MP200
+	err = mmc_add_card(host->card[0]);
+#else
 	err = mmc_add_card(host->card);
+#endif
 	if (err)
 		goto remove_added;
 
 	/*
 	 * ...then the SDIO functions.
 	 */
-	for (i = 0;i < funcs;i++) {
+	for (i = 0; i < funcs; i++) {
+#ifdef CONFIG_ARCH_MP200
+		err = sdio_add_func(host->card[0]->sdio_func[i]);
+#else
 		err = sdio_add_func(host->card->sdio_func[i]);
+#endif
 		if (err)
 			goto remove_added;
 	}
@@ -381,7 +426,11 @@ remove_added:
 	mmc_claim_host(host);
 remove:
 	/* And with lock if it hasn't been added. */
+#ifdef CONFIG_ARCH_MP200
+	if (host->card[0])
+#else
 	if (host->card)
+#endif
 		mmc_sdio_remove(host);
 err:
 	mmc_detach_bus(host);
diff --git a/drivers/mmc/core/sdio_irq.c b/drivers/mmc/core/sdio_irq.c
index c292e12..5ac6e7c 100644
--- a/drivers/mmc/core/sdio_irq.c
+++ b/drivers/mmc/core/sdio_irq.c
@@ -102,7 +102,11 @@ static int sdio_irq_thread(void *_host)
 		ret = __mmc_claim_host(host, &host->sdio_irq_thread_abort);
 		if (ret)
 			break;
+#ifdef CONFIG_ARCH_MP200
+		ret = process_sdio_pending_irqs(host->card[0]);
+#else
 		ret = process_sdio_pending_irqs(host->card);
+#endif
 		mmc_release_host(host);
 
 		/*
diff --git a/drivers/mmc/host/Kconfig b/drivers/mmc/host/Kconfig
index bf90350..92e75c6 100644
--- a/drivers/mmc/host/Kconfig
+++ b/drivers/mmc/host/Kconfig
@@ -192,3 +192,12 @@ config MMC_TMIO
 	help
 	  This provides support for the SD/MMC cell found in TC6393XB,
 	  T7L66XB and also ipaq ASIC3
+
+config MMC_MP200
+	tristate "MP200 eMMC Interface support"
+	depends on ARCH_MP200
+
+config MMC_SD_MP200
+	tristate "MP200 SD Card Interface support"
+	depends on ARCH_MP200
+
diff --git a/drivers/mmc/host/Makefile b/drivers/mmc/host/Makefile
index ba477bc..3193d7c 100644
--- a/drivers/mmc/host/Makefile
+++ b/drivers/mmc/host/Makefile
@@ -23,4 +23,6 @@ obj-$(CONFIG_MMC_SPI)		+= mmc_spi.o
 obj-$(CONFIG_MMC_S3C)   	+= s3cmci.o
 obj-$(CONFIG_MMC_SDRICOH_CS)	+= sdricoh_cs.o
 obj-$(CONFIG_MMC_TMIO)		+= tmio_mmc.o
+obj-$(CONFIG_MMC_MP200)		+= mp200_mmc.o
+obj-$(CONFIG_MMC_SD_MP200)	+= mp200_mmc_sd.o
 
diff --git a/drivers/mmc/host/mp200_mmc.c b/drivers/mmc/host/mp200_mmc.c
new file mode 100644
index 0000000..c8251d2
--- /dev/null
+++ b/drivers/mmc/host/mp200_mmc.c
@@ -0,0 +1,817 @@
+/*
+ *  File Name		: linux/drivers/mmc/host/mp200_mmc.c
+ *  Function		: MMC
+ *  Release Version : Ver 1.00
+ *  Release Date	: 2007/12/20
+ *
+ *  Copyright (C) NEC Electronics Corporation 2007
+ *
+ *
+ *  This program is free software;you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License as published by Free
+ *  Softwere Foundation; either version 2 of License, or (at your option) any
+ *  later version.
+ *
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warrnty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; If not, write to the Free Software Foundation, Inc., 59
+ *  Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/dma-mapping.h>
+#include <linux/platform_device.h>
+#include <linux/mutex.h>
+#include <linux/workqueue.h>
+#include <linux/timer.h>
+#include <linux/mmc/mmc.h>
+#include <linux/mmc/host.h>
+#include <linux/mmc/sd.h>
+#include <linux/mmc/core.h>
+#include <linux/mmc/card.h>
+#include <linux/io.h>
+
+#include <asm/irq.h>
+#include <asm/mach/irq.h>
+#include <mach/dma.h>
+#include <mach/hardware.h>
+
+#include <mach/smu.h>
+#include <mach/pmu.h>
+#include <mach/pwc.h>
+
+#ifdef CONFIG_PM
+#include <linux/notifier.h>
+#include <linux/pm.h>
+#endif
+
+#include "mp200_mmc.h"
+
+#define DRIVER_NAME	"mp200_mmc"
+
+#define MP200_MMC_BASE	(IO_ADDRESS(MP200_SDIC_BASE))
+#define MP200_MMC_DMASD		(MP200_SDIC_BASE + 0x300)
+
+#define MMC_CLK_ON	mp200_pmu_open_clockgate(MP200_CLOCKGATE_SDIC_CLK)
+#define MMC_CLK_OFF	mp200_pmu_close_clockgate(MP200_CLOCKGATE_SDIC_CLK)
+
+/* #define MMC_SPEED_NORMAL */
+/* #define MMC_DETECT_ENABLE */		 /* eMMC is disable */
+
+/* #define DEBUG_PRINT */
+#ifdef DEBUG_PRINT
+#define FUNC_PRINT(FMT, ARGS...)	\
+		printk(KERN_INFO "%s(): " FMT, __func__, ##ARGS)
+#else
+#define FUNC_PRINT(FMT, ARGS...)
+#endif
+
+static inline u32 mp200_mmc_info_read(void)
+{
+	u32 info;
+
+	info = inl(MP200_MMC_INFO1) & 0xffff;
+	info |= ((inl(MP200_MMC_INFO2) & 0xffff) << 16);
+
+	return info;
+}
+
+/*
+ * Notify the core about command completion
+ */
+static void
+mp200_mmc_data_done(struct mp200_mmc_host *host, struct mmc_command *cmd)
+{
+	outl(MMC_STOP_STOP, MP200_MMC_STOP);
+	outl(MMC_CC_EXT_MODE_FIFO, MP200_MMC_CC_EXT_MODE);
+
+	if (host->data != NULL) {
+		dma_unmap_sg(mmc_dev(host->mmc), host->data->sg,
+						host->dma_num, host->dma_dir);
+
+		if (!host->data->error)
+			host->data->bytes_xfered = host->data_len;
+	}
+	host->data_len = 0;
+
+	host->data = NULL;
+	host->cmd = NULL;
+	host->req = NULL;
+	host->stop = NULL;
+
+	/* Clear interrupt */
+	outl(0, MP200_MMC_INFO1);
+	outl(0, MP200_MMC_INFO2);
+	host->info_mask = MMC_INFO_MASK;
+	outl(MMC_INFO_MASK & 0xffff, MP200_MMC_INFO1_MASK);
+	MMC_CLK_OFF;
+
+	mmc_request_done(host->mmc, cmd->mrq);
+}
+
+/*
+ * Notify the core about command completion
+ */
+static void
+mp200_mmc_cmd_done(struct mp200_mmc_host *host, struct mmc_command *cmd)
+{
+	u32 val;
+
+	if (cmd->flags & MMC_RSP_PRESENT) {
+		if (cmd->flags & MMC_RSP_136) {
+			/* response type 2 */
+			val = inl(MP200_MMC_RSP0);
+			cmd->resp[3] = val << 8;
+			val = inl(MP200_MMC_RSP1);
+			cmd->resp[3] |= (val & 0xff) << 24;
+			cmd->resp[2] = val >> 8;
+			val = inl(MP200_MMC_RSP2);
+			cmd->resp[2] |= val << 8;
+			val = inl(MP200_MMC_RSP3);
+			cmd->resp[2] |= (val & 0xff) << 24;
+			cmd->resp[1] = val >> 8;
+			val = inl(MP200_MMC_RSP4);
+			cmd->resp[1] |= val << 8;
+			val = inl(MP200_MMC_RSP5);
+			cmd->resp[1] |= (val & 0xff) << 24;
+			cmd->resp[0] = val >> 8;
+			val = inl(MP200_MMC_RSP6);
+			cmd->resp[0] |= val << 8;
+			val = inl(MP200_MMC_RSP7);
+			cmd->resp[0] |= (val & 0xff) << 24;
+			FUNC_PRINT("%s: CMD=%d RSP %x %x %x %x\n",
+				__func__, cmd->opcode, cmd->resp[0],
+				cmd->resp[1], cmd->resp[2], cmd->resp[3]);
+		} else {
+			/* response types 1, 1b, 3, 4, 5, 6 */
+			cmd->resp[0] = inl(MP200_MMC_RSP0);
+			cmd->resp[0] |= (inl(MP200_MMC_RSP1) << 16);
+			FUNC_PRINT("%s: CMD=%d RSP %x\n", __func__,
+						cmd->opcode, cmd->resp[0]);
+		}
+	}
+
+	if (cmd->flags & MMC_RSP_BUSY) {
+		/* wait DATA0 == 1 */
+		while (!(mp200_mmc_info_read() & MMC_INFO_DAT0))
+			;
+	}
+
+
+	if (host->app_mode)
+		host->app_mode = 0;
+	else if (cmd->opcode == 55)
+		host->app_mode = 1;
+
+	if (host->data == NULL) {
+		/* Clear interrupt */
+		outl(0, MP200_MMC_INFO1);
+		outl(0, MP200_MMC_INFO2);
+		MMC_CLK_OFF;
+		host->req = NULL;
+		host->cmd = NULL;
+		mmc_request_done(host->mmc, cmd->mrq);
+	} else if (host->data->error) {
+		mp200_mmc_data_done(host, host->cmd);
+	} else {
+		val = inl(MP200_MMC_INFO1_MASK) | MMC_INFO_EOC;
+		host->info_mask = val;
+		outl(val, MP200_MMC_INFO1_MASK);
+	}
+}
+
+/*
+ * Configure the Responce type
+ */
+static void
+mp200_mmc_start_cmd(struct mp200_mmc_host *host,
+			struct mmc_command *cmd, u16 cmddat)
+{
+	u32 val;
+
+	host->cmd = cmd;
+
+	cmddat |= cmd->opcode;
+
+	switch (mmc_resp_type(cmd)) {
+	case MMC_RSP_R1: /* short CRC, OPCODE */
+		cmddat |= MMC_CMD_RSP_R1;
+		break;
+	case MMC_RSP_R1B:/* short CRC, OPCODE, BUSY */
+		cmddat |= MMC_CMD_RSP_R1B;
+		break;
+	case MMC_RSP_R2: /* long 136 bit + CRC */
+		cmddat |= MMC_CMD_RSP_R2;
+		break;
+	case MMC_RSP_R3: /* short */
+		cmddat |= MMC_CMD_RSP_R3;
+		break;
+	}
+
+	if (host->app_mode)
+		cmddat |= MMC_CMD_ACMD;
+
+	val = inl(MP200_MMC_STOP) & ~MMC_STOP_STOP;
+	outl(val, MP200_MMC_STOP);
+
+	outl(cmd->arg & 0xffff, MP200_MMC_ARG0);
+	outl(cmd->arg >> 16,    MP200_MMC_ARG1);
+
+	FUNC_PRINT("CMD %d %x %x %x %x\n",
+		cmd->opcode, cmd->arg, cmd->flags, cmd->retries, cmddat);
+
+/*
+	printk("CMD %d %x %x %x %x\n",
+		cmd->opcode, cmd->arg, cmd->flags, cmd->retries, cmddat);
+*/
+
+	/* Send command */
+	outl(cmddat, MP200_MMC_CMD);
+}
+
+/*
+ * DMA clean up for command errors
+ */
+static void mp200_mmc_dma_cleanup(struct mp200_mmc_host *host)
+{
+	struct mmc_data *data = host->data;
+
+	if (host->dma_ch != -1) {
+		dma_unmap_sg(mmc_dev(host->mmc), data->sg,
+					host->dma_num, host->dma_dir);
+		mp200_reset_dma(host->dma_ch);
+		host->dma_ch = -1;
+	}
+}
+
+/*
+ * MMC controller IRQ handler
+ */
+static irqreturn_t
+mp200_mmc_irq(int irq, void *dev_id)
+{
+	struct mp200_mmc_host *host = (struct mp200_mmc_host *)dev_id;
+	u32 info, end_trans = 0;
+
+	info = mp200_mmc_info_read() & ~host->info_mask;
+
+/*
+	printk("%s: %x\n", __FUNCTION__, info);
+*/
+	if (host->cmd == NULL) {
+		outl(0, MP200_MMC_INFO1);
+		outl(0, MP200_MMC_INFO2);
+		return IRQ_HANDLED;
+	}
+
+	if (info & MMC_INFO_ALLERR) {
+		end_trans = 1;
+		if (info & MMC_INFO_CTO) {
+			FUNC_PRINT("%s: CMD=%d CMD Timeout\n",
+					__func__, host->cmd->opcode);
+			host->cmd->error = -ETIMEDOUT;
+		} else if (info & MMC_INFO_CRCERR) {
+			FUNC_PRINT("%s: CMD=%d CRC error\n",
+					__func__, host->cmd->opcode);
+			host->cmd->error = -EILSEQ;
+		} else {
+			FUNC_PRINT("%s: CMD=%d Other error.(0x%x)\n",
+					__func__, host->cmd->opcode, info);
+			host->cmd->error = -EILSEQ;
+		}
+		if (host->data) {
+			if (info & MMC_INFO_DTO) {
+				FUNC_PRINT("%s: CMD=%d DATA Timeout\n",
+						__func__, host->cmd->opcode);
+				host->data->error = -ETIMEDOUT;
+			} else {
+				FUNC_PRINT("%s: CMD=%d Other error.(0x%x)\n",
+					__func__, host->cmd->opcode, info);
+				host->data->error = -EILSEQ;
+			}
+			mp200_mmc_dma_cleanup(host);
+		}
+	}
+
+	if ((info & MMC_INFO_EOC) || end_trans) {
+		mp200_mmc_cmd_done(host, host->cmd);
+		return IRQ_HANDLED;
+	}
+	if ((info & MMC_INFO_RWEND)) {
+		mp200_mmc_data_done(host, host->cmd);
+		return IRQ_HANDLED;
+	}
+
+	return IRQ_HANDLED;
+}
+
+/*
+ * IRQ for handling card insertion and removal
+ */
+#ifdef MMC_DETECT_ENABLE
+static irqreturn_t
+mp200_mmc_detect_irq(int irq, void *dev_id)
+{
+	struct mp200_mmc_host *host = (struct mp200_mmc_host *)dev_id;
+	mmc_detect_change(host->mmc, (HZ * 50) / 1000);
+
+	return IRQ_HANDLED;
+}
+#endif
+
+static void mp200_mmc_dma_cb(void *data, int intsts, int intrawsts)
+{
+	struct mp200_mmc_host *host = (struct mp200_mmc_host *)data;
+	u32 val;
+
+	host->dma_count++;
+
+	if (host->dma_count >= host->dma_num) {
+		val = inl(MP200_MMC_INFO1_MASK) & ~MMC_INFO_RWEND;
+		host->info_mask = val;
+		outl(val, MP200_MMC_INFO1_MASK);
+		host->dma_ch = -1;
+	} else if (host->dma_ch == host->dma_rx_ch) {
+		mp200_start_dma(host->dma_rx_ch, MP200_MMC_DMASD,
+			host->dma_len[host->dma_count],
+			host->dma_address[host->dma_count],
+			MP200_DMAC_INT_ERROR_EN | MP200_DMAC_INT_LENG_EN);
+	} else {
+		mp200_start_dma(host->dma_tx_ch,
+			host->dma_address[host->dma_count],
+			host->dma_len[host->dma_count], MP200_MMC_DMASD,
+			MP200_DMAC_INT_ERROR_EN | MP200_DMAC_INT_LENG_EN);
+	}
+}
+
+/*
+ * Configure block leangth for MMC/SD cards and intiate the transfer.
+ */
+static void
+mp200_mmc_setup_data(struct mp200_mmc_host *host, struct mmc_data *data)
+{
+	int i;
+
+	host->data = data;
+
+	host->data_len = data->blksz * data->blocks;
+
+	FUNC_PRINT("MMC: DATA: size=%d num=%d flags=0x%x\n",
+				data->blksz, data->blocks, data->flags);
+
+	outl(data->blksz,  MP200_MMC_SIZE);
+	outl(data->blocks, MP200_MMC_SECCNT);
+
+	host->dma_dir = (data->flags & MMC_DATA_WRITE) ?
+				DMA_TO_DEVICE : DMA_FROM_DEVICE;
+
+	host->dma_num = dma_map_sg(mmc_dev(host->mmc), data->sg,
+				data->sg_len, host->dma_dir);
+
+	for (i = 0; i < host->dma_num; i++) {
+		host->dma_address[i] = sg_dma_address(&data->sg[i]);
+		host->dma_len[i] = sg_dma_len(&data->sg[i]);
+	}
+
+	outl(MMC_CC_EXT_MODE_SD_DMA, MP200_MMC_CC_EXT_MODE);
+
+	host->dma_count = 0;
+
+	if (data->flags & MMC_DATA_READ) {
+		host->dma_ch = host->dma_rx_ch;
+		mp200_start_dma(host->dma_rx_ch, MP200_MMC_DMASD,
+			host->dma_len[0], host->dma_address[0],
+			MP200_DMAC_INT_ERROR_EN | MP200_DMAC_INT_LENG_EN);
+	} else {
+		host->dma_ch = host->dma_tx_ch;
+		mp200_start_dma(host->dma_tx_ch, host->dma_address[0],
+			host->dma_len[0], MP200_MMC_DMASD,
+			MP200_DMAC_INT_ERROR_EN | MP200_DMAC_INT_LENG_EN);
+	}
+
+/*
+	printk("MMC: dma_num=%d sg_len=%d\n", host->dma_num, data->sg_len);
+*/
+}
+
+/*
+ * Request function. for read/write operation
+ */
+static void
+mp200_mmc_request(struct mmc_host *mmc, struct mmc_request *req)
+{
+	struct mp200_mmc_host *host = mmc_priv(mmc);
+	u16 cmddat = 0;
+	u32 info;
+
+	host->req = req;
+	host->stop = req->stop;
+
+	MMC_CLK_ON;
+	info = mp200_mmc_info_read();
+
+	/* Clear stat */
+	outl(0, MP200_MMC_INFO1);
+	outl(0, MP200_MMC_INFO2);
+	req->cmd->error = 0;
+
+	if (req->data) {
+		req->data->error = 0;
+		mp200_mmc_setup_data(host, req->data);
+
+		cmddat |= MMC_CMD_DATA;
+
+		if (host->data->flags & MMC_DATA_READ)
+			cmddat |= MMC_CMD_READ;
+
+		if (host->data->blocks > 1) {
+			cmddat |= MMC_CMD_MULTI;
+			outl(MMC_STOP_MULTI, MP200_MMC_STOP);
+		}
+	}
+
+	mp200_mmc_start_cmd(host, req->cmd, cmddat);
+}
+
+static void mp200_mmc_power(struct mp200_mmc_host *host, u32 power_on)
+{
+	if (power_on) {
+		MMC_CLK_ON;
+		mp200_pmu_unreset_device(MP200_RESETDEVICE_SDIC);
+
+		outl(MMC_SDWAITCTRL_VAL,     SMU_AB1_SDICWAITCTRL);
+		outl(MMC_SDREADCTRL_VAL,     SMU_AB1_SDICREADCTRL);
+		outl(MMC_USER_VAL,           MP200_MMC_USER);
+		outl(MMC_USER2_VAL,          MP200_MMC_USER2);
+
+		outl(MMC_SOFT_RST_RESET,     MP200_MMC_SOFT_RST);
+		outl(MMC_SOFT_RST_UNRESET,   MP200_MMC_SOFT_RST);
+		outl(MMC_CC_EXT_MODE_FIFO,   MP200_MMC_CC_EXT_MODE);
+		outl(MMC_INFO_MASK,          MP200_MMC_INFO1_MASK);
+		outl(MMC_INFO_MASK >> 16,    MP200_MMC_INFO2_MASK);
+
+		outl(0, MP200_MMC_INFO1);
+		outl(0, MP200_MMC_INFO2);
+		outl(0, MP200_SDIO_INFO1);
+		outl(MMC_SDIO_INFO1_MASK, MP200_SDIO_INFO1_MASK);
+		outl(MMC_STOP_STOP, MP200_MMC_STOP);
+		outl(0x80EE, MP200_MMC_OPTION);
+
+		MMC_CLK_OFF;
+	} else {
+		host->clock = 0;
+		host->bus_width = 0;
+		MMC_CLK_ON;
+		mp200_pmu_reset_device(MP200_RESETDEVICE_SDIC);
+		MMC_CLK_OFF;
+	}
+}
+
+
+/*
+ * Configuring clock values.
+ */
+static void
+mp200_mmc_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
+{
+	struct mp200_mmc_host *host = mmc_priv(mmc);
+	u32 val, wDiv;
+
+/*
+	printk("%s: %d %x %d %d\n", __FUNCTION__,
+		ios->clock, ios->power_mode, ios->bus_width, ios->timing);
+*/
+	if ((host->bus_width != ios->bus_width)
+				&& (host->power_mode != MMC_POWER_OFF)) {
+		MMC_CLK_ON;
+		val = inl(MP200_MMC_OPTION);
+		if (ios->bus_width == MMC_BUS_WIDTH_4) {
+			host->bus_width = MMC_BUS_WIDTH_4;
+			val &= ~MMC_OPTION_WIDTH4;
+		} else {
+			host->bus_width = MMC_BUS_WIDTH_1;
+			val |= MMC_OPTION_WIDTH4;
+		}
+		outl(val, MP200_MMC_OPTION);
+		MMC_CLK_OFF;
+	}
+
+	if ((ios->clock != host->clock)
+				&& (host->power_mode != MMC_POWER_OFF)) {
+		MMC_CLK_ON;
+		/* Stop clock */
+		outl(0, MP200_MMC_CLK_CTRL);
+
+		if (ios->clock >= 40000000) {
+			wDiv = MMC_CLOCK_HIGH   | MMC_CLOCK_OFFEN;
+			outl(MMC_USER2_HIGH_VAL, MP200_MMC_USER2);
+		} else if (ios->clock >= 20000000) {
+			wDiv = MMC_CLOCK_DIV4   | MMC_CLOCK_OFFEN;
+		} else if (ios->clock >= 10000000) {
+			wDiv = MMC_CLOCK_DIV8   | MMC_CLOCK_OFFEN;
+		} else if (ios->clock >=  5000000) {
+			wDiv = MMC_CLOCK_DIV16  | MMC_CLOCK_OFFEN;
+		} else if (ios->clock >=  2500000) {
+			wDiv = MMC_CLOCK_DIV32  | MMC_CLOCK_OFFEN;
+		} else if (ios->clock >=  1250000) {
+			wDiv = MMC_CLOCK_DIV64  | MMC_CLOCK_OFFEN;
+		} else if (ios->clock >=   625000) {
+			wDiv = MMC_CLOCK_DIV128 | MMC_CLOCK_OFFEN;
+		} else {
+			wDiv = MMC_CLOCK_DIV256;
+		}
+
+		wDiv |= MMC_CLOCK_EN;
+
+		/* Start clock */
+		outl(wDiv, MP200_MMC_CLK_CTRL);
+		MMC_CLK_OFF;
+		host->clock = ios->clock;
+	}
+
+	if (host->power_mode != ios->power_mode) {
+		switch (ios->power_mode) {
+		case MMC_POWER_OFF:
+			mp200_mmc_power(host, 0);
+			FUNC_PRINT("power off\n");
+			break;
+		case MMC_POWER_UP:
+			mp200_mmc_power(host, 1);
+			FUNC_PRINT("power up\n");
+			break;
+		case MMC_POWER_ON:
+			FUNC_PRINT("power on\n");
+			break;
+		}
+		host->power_mode = ios->power_mode;
+	}
+}
+
+static struct mmc_host_ops mp200_mmc_ops = {
+	.request	= mp200_mmc_request,
+	.set_ios	= mp200_mmc_set_ios,
+};
+
+static int
+mp200_mmc_probe(struct platform_device *pdev)
+{
+	struct mmc_host *mmc;
+	struct mp200_mmc_host *host = NULL;
+	int ret = 0;
+
+	mmc = mmc_alloc_host(sizeof(struct mp200_mmc_host), &pdev->dev);
+	if (!mmc) {
+		ret = -ENOMEM;
+		goto err;
+	}
+
+	mmc->ops   = &mp200_mmc_ops;
+	mmc->f_min = 400000;
+#ifdef MMC_SPEED_NORMAL
+	mmc->f_max = 25000000;
+#else
+	mmc->f_max = 50000000;
+#endif
+	mmc->ocr_avail = MMC_VDD_28_29;
+#ifdef MMC_SPEED_NORMAL
+	mmc->caps = MMC_CAP_4_BIT_DATA;
+#else
+	mmc->caps = MMC_CAP_4_BIT_DATA |
+				MMC_CAP_MMC_HIGHSPEED | MMC_CAP_SD_HIGHSPEED;
+#endif
+#if 1
+	mmc->card_num = 2;
+#endif
+
+	/* MMC core transfer sizes tunable parameters */
+	mmc->max_hw_segs   = MP200_MAX_SEGS;
+	mmc->max_phys_segs = MP200_MAX_SEGS;
+	mmc->max_seg_size  = MP200_MAX_SEGS * 512;
+	mmc->max_req_size  = MP200_MAX_SEGS * 512;
+	mmc->max_blk_size  = 512;
+	mmc->max_blk_count = 65535;
+
+	host      = mmc_priv(mmc);
+	host->mmc = mmc;
+	host->irq = INT_SDIC_SD;
+#ifdef MMC_DETECT_ENABLE
+	host->detect_irq = INT_PWC_SDDET;
+#endif
+	host->power_mode = MMC_POWER_OFF;
+	host->info_mask = MMC_INFO_MASK;
+	mutex_init(&host->mutex);
+
+	/* DMA setting */
+	host->dma_rx_ch = MP200_DMAC_P2M_LCH5;
+	host->dma_tx_ch = MP200_DMAC_M2P_LCH5;
+
+	ret = mp200_request_dma(host->dma_rx_ch, DRIVER_NAME,
+			mp200_mmc_dma_cb, (void *)host, &host->dma_rx_regs);
+	if (ret < 0)
+		goto err;
+
+	ret = mp200_request_dma(host->dma_tx_ch, DRIVER_NAME,
+			mp200_mmc_dma_cb, (void *)host, &host->dma_tx_regs);
+	if (ret < 0)
+		goto err_dma;
+
+	/* Request IRQ for MMC operations */
+	ret = request_irq(host->irq, mp200_mmc_irq,
+					IRQF_DISABLED, pdev->name, host);
+	if (ret) {
+		FUNC_PRINT("Unable to IRQ");
+		goto err_irq;
+	}
+
+#ifdef MMC_DETECT_ENABLE
+	/* Request IRQ for MMC card detect */
+	ret = request_irq(host->detect_irq, mp200_mmc_detect_irq,
+					IRQF_DISABLED, pdev->name, host);
+	if (ret) {
+		FUNC_PRINT("Unable to Card detect IRQ");
+		goto err_irq2;
+	}
+#endif
+	platform_set_drvdata(pdev, host);
+	mmc_add_host(mmc);
+
+	return 0;
+
+#ifdef MMC_DETECT_ENABLE
+err_irq2:
+	free_irq(host->irq, host);
+#endif
+err_irq:
+	mp200_free_dma(host->dma_tx_ch);
+err_dma:
+	mp200_free_dma(host->dma_rx_ch);
+
+err:
+	printk("%s: error!!(%d)\n", __func__, ret);
+	if (host)
+		mmc_free_host(mmc);
+	return ret;
+
+}
+
+static int
+mp200_mmc_remove(struct platform_device *pdev)
+{
+	struct mp200_mmc_host *host = platform_get_drvdata(pdev);
+
+	platform_set_drvdata(pdev, NULL);
+	if (host) {
+		flush_scheduled_work();
+
+		mmc_remove_host(host->mmc);
+
+		mp200_mmc_power(host, 0);
+
+#ifdef MMC_DETECT_ENABLE
+		free_irq(host->detect_irq, host);
+#endif
+		free_irq(host->irq, host);
+
+		mp200_free_dma(host->dma_rx_ch);
+		mp200_free_dma(host->dma_tx_ch);
+
+		mmc_free_host(host->mmc);
+	}
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static unsigned int mmc_save[IDX_REGS_NUM];
+
+static void mmc_reg_save(void)
+{
+	mmc_save[IDX_CLK_CTRL] = inl(MP200_MMC_CLK_CTRL);
+	mmc_save[IDX_OPTION] = inl(MP200_MMC_OPTION);
+	mmc_save[IDX_SDIO_INFO1_MASK] = inl(MP200_SDIO_INFO1_MASK);
+	mmc_save[IDX_INFO2_MASK] = inl(MP200_MMC_INFO2_MASK);
+	mmc_save[IDX_INFO1_MASK] = inl(MP200_MMC_INFO1_MASK);
+	mmc_save[IDX_USER2] = inl(MP200_MMC_USER2);
+	mmc_save[IDX_USER] = inl(MP200_MMC_USER);
+
+	return;
+}
+
+static void mmc_reg_restore(void)
+{
+	outl(mmc_save[IDX_USER], MP200_MMC_USER);
+	outl(mmc_save[IDX_USER2], MP200_MMC_USER2);
+
+	outl(MMC_SOFT_RST_RESET,     MP200_MMC_SOFT_RST);
+	outl(MMC_SOFT_RST_UNRESET,   MP200_MMC_SOFT_RST);
+	outl(MMC_CC_EXT_MODE_FIFO,   MP200_MMC_CC_EXT_MODE);
+
+	outl(0, MP200_MMC_INFO1);
+	outl(0, MP200_MMC_INFO2);
+	outl(0, MP200_SDIO_INFO1);
+	outl(mmc_save[IDX_INFO1_MASK], MP200_MMC_INFO1_MASK);
+	outl(mmc_save[IDX_INFO2_MASK], MP200_MMC_INFO2_MASK);
+	outl(mmc_save[IDX_SDIO_INFO1_MASK], MP200_SDIO_INFO1_MASK);
+
+	outl(mmc_save[IDX_OPTION], MP200_MMC_OPTION);
+	outl(mmc_save[IDX_CLK_CTRL], MP200_MMC_CLK_CTRL);
+
+	return;
+}
+
+static int
+mp200_mmc_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	struct mp200_mmc_host *host = platform_get_drvdata(pdev);
+	int ret = 0;
+/*
+	printk("%s: %x\n", __FUNCTION__, state.event);
+*/
+	if (host && host->suspended)
+		return 0;
+
+	if (host) {
+		if (!mp200_sleep_while_idle) {
+			ret = mmc_suspend_host(host->mmc, state);
+			if (ret == 0)
+				host->suspended = 1;
+		} else {
+			MMC_CLK_ON;
+			mmc_reg_save();
+			MMC_CLK_OFF;
+			host->suspended = 1;
+		}
+	}
+	return ret;
+}
+
+/* Routine to resume the MMC device */
+static int
+mp200_mmc_resume(struct platform_device *pdev)
+{
+	struct mp200_mmc_host *host = platform_get_drvdata(pdev);
+	int ret = 0;
+
+	if (host && !host->suspended)
+		return 0;
+
+	if (host) {
+		if (!mp200_sleep_while_idle) {
+			ret = mmc_resume_host(host->mmc);
+			if (ret == 0)
+				host->suspended = 0;
+		} else {
+			MMC_CLK_ON;
+			mmc_reg_restore();
+			MMC_CLK_OFF;
+			host->suspended = 0;
+		}
+	}
+	return ret;
+}
+#else
+#define mp200_mmc_suspend	NULL
+#define mp200_mmc_resume	NULL
+#endif
+
+static struct platform_driver mp200_mmc_driver = {
+	.probe		= mp200_mmc_probe,
+	.remove		= mp200_mmc_remove,
+	.suspend	= mp200_mmc_suspend,
+	.resume		= mp200_mmc_resume,
+	.driver		= {
+			.name = DRIVER_NAME,
+	},
+};
+
+static int __init mp200_mmc_init(void)
+{
+	/* Register the MMC driver */
+	if (platform_driver_register(&mp200_mmc_driver)) {
+		printk(KERN_ERR ": Failed to register MMC driver\n");
+		return -ENODEV;
+	}
+	return 0;
+}
+
+static void __exit mp200_mmc_cleanup(void)
+{
+	/* Unregister MMC driver */
+	platform_driver_unregister(&mp200_mmc_driver);
+}
+
+module_init(mp200_mmc_init);
+module_exit(mp200_mmc_cleanup);
+
+MODULE_DESCRIPTION("MP200 High Speed Multimedia Card driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS(DRIVER_NAME);
+MODULE_AUTHOR("NEC Electronics");
diff --git a/drivers/mmc/host/mp200_mmc.h b/drivers/mmc/host/mp200_mmc.h
new file mode 100644
index 0000000..b7e77f9
--- /dev/null
+++ b/drivers/mmc/host/mp200_mmc.h
@@ -0,0 +1,233 @@
+/*
+ *  File Name		: linux/drivers/mmc/host/mp200_mmc.h
+ *  Function		: MMC
+ *  Release Version : Ver 1.00
+ *  Release Date	: 2007/12/20
+ *
+ *  Copyright (C) NEC Electronics Corporation 2007
+ *
+ *
+ *  This program is free software;you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License as published by Free
+ *  Softwere Foundation; either version 2 of License, or (at your option) any
+ *  later version.
+ *
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warrnty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; If not, write to the Free Software Foundation, Inc., 59
+ *  Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#ifndef __DRIVERS_MMC_MP200_MMC_H
+#define __DRIVERS_MMC_MP200_MMC_H
+
+#include <linux/io.h>
+
+#include <asm/irq.h>
+#include <asm/dma.h>
+#include <mach/hardware.h>
+
+#include <mach/smu.h>
+#include <mach/pmu.h>
+#include <mach/pwc.h>
+
+#ifdef CONFIG_PM
+#include <linux/notifier.h>
+#include <linux/pm.h>
+#include <mach/pm.h>
+#endif
+
+
+
+/* MMC Registers */
+/* SD Command */
+#define MP200_MMC_CMD			(MP200_MMC_BASE + 0x00)
+/* Command Argument0 */
+#define MP200_MMC_ARG0			(MP200_MMC_BASE + 0x08)
+/* Command Argument1 */
+#define MP200_MMC_ARG1			(MP200_MMC_BASE + 0x0C)
+/* Stop internal action */
+#define MP200_MMC_STOP			(MP200_MMC_BASE + 0x10)
+/* Transfer sector count register */
+#define MP200_MMC_SECCNT		(MP200_MMC_BASE + 0x14)
+/* Response0 */
+#define MP200_MMC_RSP0			(MP200_MMC_BASE + 0x18)
+/* Response1 */
+#define MP200_MMC_RSP1			(MP200_MMC_BASE + 0x1C)
+/* Response2 */
+#define MP200_MMC_RSP2			(MP200_MMC_BASE + 0x20)
+/* Response3 */
+#define MP200_MMC_RSP3			(MP200_MMC_BASE + 0x24)
+/* Response4 */
+#define MP200_MMC_RSP4			(MP200_MMC_BASE + 0x28)
+/* Response5 */
+#define MP200_MMC_RSP5			(MP200_MMC_BASE + 0x2C)
+/* Response6 */
+#define MP200_MMC_RSP6			(MP200_MMC_BASE + 0x30)
+/* Response7 */
+#define MP200_MMC_RSP7			(MP200_MMC_BASE + 0x34)
+/* Card Status(MP200_MMC_BASE + detect,write protect,etc.) */
+#define MP200_MMC_INFO1			(MP200_MMC_BASE + 0x38)
+/* SD Buffer control & Error */
+#define MP200_MMC_INFO2			(MP200_MMC_BASE + 0x3C)
+/* Mask of MP200_MMC_INFO1 register interrupt */
+#define MP200_MMC_INFO1_MASK		(MP200_MMC_BASE + 0x40)
+/* Mask of MP200_MMC_INFO2 register interrupt */
+#define MP200_MMC_INFO2_MASK		(MP200_MMC_BASE + 0x44)
+/* SD Card Clock Control */
+#define MP200_MMC_CLK_CTRL		(MP200_MMC_BASE + 0x48)
+/* SD Card Data transfer size */
+#define MP200_MMC_SIZE			(MP200_MMC_BASE + 0x4C)
+/* Option set up for SD Card */
+#define MP200_MMC_OPTION		(MP200_MMC_BASE + 0x50)
+/* Error status1(MP200_MMC_BASE + Command,CRC,End) */
+#define MP200_MMC_ERR_STS1		(MP200_MMC_BASE + 0x58)
+/* Error status2(MP200_MMC_BASE + Timeout) */
+#define MP200_MMC_ERR_STS2		(MP200_MMC_BASE + 0x5C)
+/* SD Data port0 */
+#define MP200_MMC_BUF0			(MP200_MMC_BASE + 0x60)
+/* Select SDIO mode */
+#define MP200_SDIO_MODE			(MP200_MMC_BASE + 0x68)
+/* IRQ from SDIO card 0 */
+#define MP200_SDIO_INFO1		(MP200_MMC_BASE + 0x6C)
+/* MASK IRQ from SDIO card 0 */
+#define MP200_SDIO_INFO1_MASK		(MP200_MMC_BASE + 0x70)
+
+#define MP200_MMC_CC_EXT_MODE		(MP200_MMC_BASE + 0x1B0)
+#define MP200_MMC_SOFT_RST		(MP200_MMC_BASE + 0x1C0)
+
+#define MP200_MMC_USER			(MP200_MMC_BASE + 0x200)
+#define MP200_MMC_USER2			(MP200_MMC_BASE + 0x204)
+
+
+/* Command */
+#define MMC_CMD_ACMD		(1 << 6)
+#define MMC_CMD_RSP_NONE	(3 << 8)
+#define MMC_CMD_RSP_R1		(4 << 8)
+#define MMC_CMD_RSP_R1B		(5 << 8)
+#define MMC_CMD_RSP_R2		(6 << 8)
+#define MMC_CMD_RSP_R3		(7 << 8)
+#define MMC_CMD_DATA		(1 << 11)
+#define MMC_CMD_READ		(1 << 12)
+#define MMC_CMD_MULTI		(1 << 13)
+
+/* Stop */
+#define MMC_STOP_STOP		(1 << 0)
+#define MMC_STOP_MULTI		(1 << 8)
+
+/* Interrupts */
+#define MMC_INFO_EOC		(1 << 0)
+#define MMC_INFO_RWEND		(1 << 2)
+
+#define MMC_INFO_CMDERR		(1 << (0+16))
+#define MMC_INFO_CRCERR		(1 << (1+16))
+#define MMC_INFO_ENDERR		(1 << (2+16))
+#define MMC_INFO_DTO		(1 << (3+16))
+#define MMC_INFO_ILAW		(1 << (4+16))
+#define MMC_INFO_ILAR		(1 << (5+16))
+#define MMC_INFO_CTO		(1 << (6+16))
+#define MMC_INFO_DAT0		(1 << (7+16))
+#define MMC_INFO_BRE		(1 << (8+16))
+#define MMC_INFO_BWE		(1 << (9+16))
+#define MMC_INFO_CB			(1 << (14+16))
+#define MMC_INFO_ILA		(1 << (15+16))
+
+#define MMC_INFO_ALLERR		0x807F0000
+/* #define MMC_INFO_MASK		0x0300FFFA */
+#define MMC_INFO_MASK		0x0300FFFE
+
+#define MMC_SDIO_INFO1_MASK	0xFFFF
+
+/* Clock */
+#define MMC_CLOCK_DIV2		(0 << 0)
+#define MMC_CLOCK_DIV4		(1 << 0)
+#define MMC_CLOCK_DIV8		(2 << 0)
+#define MMC_CLOCK_DIV16		(4 << 0)
+#define MMC_CLOCK_DIV32		(8 << 0)
+#define MMC_CLOCK_DIV64		(16 << 0)
+#define MMC_CLOCK_DIV128	(32 << 0)
+#define MMC_CLOCK_DIV256	(64 << 0)
+#define MMC_CLOCK_DIV512	(128 << 0)
+#define MMC_CLOCK_EN		(1 << 8)
+#define MMC_CLOCK_OFFEN		(1 << 9)
+#define MMC_CLOCK_HIGH		(1 << 10)
+#define MMC_CLOCK_DIV_MASK	0xFF
+
+/* Option */
+#define MMC_OPTION_WIDTH4	(1 << 15) /* 0:WIDTH14 1:WIDTH1 */
+
+/* Buffer mode */
+#define MMC_CC_EXT_MODE_FIFO	0x0000
+#define MMC_CC_EXT_MODE_SD_DMA	0x0002
+
+/* Reset */
+#define MMC_SOFT_RST_RESET		0x0000
+#define MMC_SOFT_RST_UNRESET	0x0007
+
+/* User */
+#define MMC_USER_VAL		0x8004
+#define MMC_USER2_VAL		0x0301
+#define MMC_USER2_HIGH_VAL	0x0001
+
+#define MMC_SDWAITCTRL_VAL		0x0300
+#define MMC_SDREADCTRL_VAL		0x0000
+
+
+#define MP200_MAX_SEGS	128	/* MAX 64KByte */
+
+/* Private structure */
+struct mp200_mmc_host {
+	struct	device		*dev;
+	struct	mmc_host	*mmc;
+	struct	mmc_request	*req;
+	struct	mmc_command	*cmd;
+	struct	mmc_data	*data;
+	struct	mmc_command	*stop;
+
+	struct	mutex		mutex;
+
+	u8		bus_width;
+	u8		app_mode;
+	u32		power_mode;
+	u32		clock;
+
+	u32		info_mask;
+
+	u32		dma_num;
+	u32		dma_count;
+	u32		dma_len[MP200_MAX_SEGS];
+	u32		dma_dir;
+	u32		data_len;
+	u32		dma_address[MP200_MAX_SEGS];
+	u16		*buffer;
+
+	dma_regs_t *dma_rx_regs;	/* dma rx register */
+	dma_regs_t *dma_tx_regs;	/* dma tx register */
+	int		dma_rx_ch;
+	int		dma_tx_ch;
+	int		dma_ch;
+
+	int		suspended;
+	int		irq;
+	int		detect_irq;
+	int		connect;
+};
+
+enum {
+  IDX_INFO1_MASK = 0,	/* +0040 */
+  IDX_INFO2_MASK,	/* +0044 */
+  IDX_CLK_CTRL,		/* +0048 */
+  IDX_OPTION,		/* +0050 */
+  IDX_SDIO_INFO1_MASK,	/* +0070 */
+  IDX_USER,		/* +0200 */
+  IDX_USER2,		/* +0204 */
+
+  IDX_REGS_NUM,
+};
+
+#endif /* __DRIVERS_MMC_MP200_MMC_H */
diff --git a/drivers/mmc/host/mp200_mmc_sd.c b/drivers/mmc/host/mp200_mmc_sd.c
new file mode 100644
index 0000000..9e4d9c2
--- /dev/null
+++ b/drivers/mmc/host/mp200_mmc_sd.c
@@ -0,0 +1,882 @@
+/*
+ *  File Name		: linux/drivers/mmc/host/mp200_mmc_sd.c
+ *  Function		: MMC
+ *  Release Version : Ver 1.01
+ *  Release Date	: 2009/02/04
+ *
+ *  Copyright (C) NEC Electronics Corporation 2009
+ *
+ *
+ *  This program is free software;you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License as published by Free
+ *  Softwere Foundation; either version 2 of License, or (at your option) any
+ *  later version.
+ *
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warrnty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; If not, write to the Free Software Foundation, Inc., 59
+ *  Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/dma-mapping.h>
+#include <linux/platform_device.h>
+#include <linux/mutex.h>
+#include <linux/workqueue.h>
+#include <linux/timer.h>
+#include <linux/mmc/mmc.h>
+#include <linux/mmc/host.h>
+#include <linux/mmc/sd.h>
+#include <linux/mmc/core.h>
+#include <linux/mmc/card.h>
+#include <linux/io.h>
+
+#include <asm/mach/irq.h>
+#include <mach/dma.h>
+#include <mach/hardware.h>
+
+#include <mach/smu.h>
+#include <mach/pmu.h>
+#include <mach/pwc.h>
+#include <mach/gpio.h>
+
+#ifdef CONFIG_PM
+#include <linux/notifier.h>
+#include <linux/pm.h>
+#endif
+
+#define MMC_WP_DISABLE
+
+#include "mp200_mmc.h"
+
+#define DRIVER_NAME	"mp200_mmc_sd"
+
+#define MP200_MMC_BASE	(IO_ADDRESS(MP200_SDIA_BASE))
+#define MP200_MMC_DMASD		(MP200_SDIA_BASE + 0x300)
+
+#define MMC_CLK_ON	mp200_pmu_open_clockgate(MP200_CLOCKGATE_SDIA_CLK)
+#define MMC_CLK_OFF	mp200_pmu_close_clockgate(MP200_CLOCKGATE_SDIA_CLK)
+
+/* #define DEBUG_PRINT */
+#ifdef DEBUG_PRINT
+#define FUNC_PRINT(FMT, ARGS...)	\
+		printk(KERN_INFO "%s(): " FMT, __func__, ##ARGS)
+#else
+#define FUNC_PRINT(FMT, ARGS...)
+#endif
+
+static inline u32 mp200_mmc_info_read(void)
+{
+	u32 info;
+
+	info = inl(MP200_MMC_INFO1) & 0xffff;
+	info |= ((inl(MP200_MMC_INFO2) & 0xffff) << 16);
+
+	return info;
+}
+
+/*
+ * Notify the core about command completion
+ */
+static void
+mp200_mmc_data_done(struct mp200_mmc_host *host, struct mmc_command *cmd)
+{
+	outl(MMC_STOP_STOP, MP200_MMC_STOP);
+	outl(MMC_CC_EXT_MODE_FIFO, MP200_MMC_CC_EXT_MODE);
+
+	if (host->data != NULL) {
+		dma_unmap_sg(mmc_dev(host->mmc), host->data->sg,
+						host->dma_num, host->dma_dir);
+
+		if (!host->data->error)
+			host->data->bytes_xfered = host->data_len;
+	}
+	host->data_len = 0;
+
+	host->data = NULL;
+	host->cmd = NULL;
+	host->req = NULL;
+	host->stop = NULL;
+
+	/* Clear interrupt */
+	outl(0, MP200_MMC_INFO1);
+	outl(0, MP200_MMC_INFO2);
+	host->info_mask = MMC_INFO_MASK;
+	outl(MMC_INFO_MASK & 0xffff, MP200_MMC_INFO1_MASK);
+	MMC_CLK_OFF;
+
+	mmc_request_done(host->mmc, cmd->mrq);
+}
+
+/*
+ * Notify the core about command completion
+ */
+static void
+mp200_mmc_cmd_done(struct mp200_mmc_host *host, struct mmc_command *cmd)
+{
+	u32 val;
+
+	if (cmd->flags & MMC_RSP_PRESENT) {
+		if (cmd->flags & MMC_RSP_136) {
+			/* response type 2 */
+			val = inl(MP200_MMC_RSP0);
+			cmd->resp[3] = val << 8;
+			val = inl(MP200_MMC_RSP1);
+			cmd->resp[3] |= (val & 0xff) << 24;
+			cmd->resp[2] = val >> 8;
+			val = inl(MP200_MMC_RSP2);
+			cmd->resp[2] |= val << 8;
+			val = inl(MP200_MMC_RSP3);
+			cmd->resp[2] |= (val & 0xff) << 24;
+			cmd->resp[1] = val >> 8;
+			val = inl(MP200_MMC_RSP4);
+			cmd->resp[1] |= val << 8;
+			val = inl(MP200_MMC_RSP5);
+			cmd->resp[1] |= (val & 0xff) << 24;
+			cmd->resp[0] = val >> 8;
+			val = inl(MP200_MMC_RSP6);
+			cmd->resp[0] |= val << 8;
+			val = inl(MP200_MMC_RSP7);
+			cmd->resp[0] |= (val & 0xff) << 24;
+			FUNC_PRINT("%s: CMD=%d RSP %x %x %x %x\n",
+				__func__, cmd->opcode, cmd->resp[0],
+				cmd->resp[1], cmd->resp[2], cmd->resp[3]);
+		} else {
+			/* response types 1, 1b, 3, 4, 5, 6 */
+			cmd->resp[0] = inl(MP200_MMC_RSP0);
+			cmd->resp[0] |= (inl(MP200_MMC_RSP1) << 16);
+			FUNC_PRINT("%s: CMD=%d RSP %x\n", __func__,
+						cmd->opcode, cmd->resp[0]);
+		}
+	}
+
+	if (cmd->flags & MMC_RSP_BUSY) {
+		/* wait DATA0 == 1 */
+		while (!(mp200_mmc_info_read() & MMC_INFO_DAT0))
+			;
+	}
+
+	if (host->app_mode)
+		host->app_mode = 0;
+	else if (cmd->opcode == 55)
+		host->app_mode = 1;
+
+	if (host->data == NULL) {
+		/* Clear interrupt */
+		outl(0, MP200_MMC_INFO1);
+		outl(0, MP200_MMC_INFO2);
+		MMC_CLK_OFF;
+		host->req = NULL;
+		host->cmd = NULL;
+		mmc_request_done(host->mmc, cmd->mrq);
+	} else if (host->data->error) {
+		mp200_mmc_data_done(host, host->cmd);
+	} else {
+		val = inl(MP200_MMC_INFO1_MASK) | MMC_INFO_EOC;
+		host->info_mask = val;
+		outl(val, MP200_MMC_INFO1_MASK);
+	}
+}
+
+/*
+ * Configure the Responce type
+ */
+static void
+mp200_mmc_start_cmd(struct mp200_mmc_host *host,
+			struct mmc_command *cmd, u16 cmddat)
+{
+	u32 val;
+
+	host->cmd = cmd;
+
+	cmddat |= cmd->opcode;
+
+	switch (mmc_resp_type(cmd)) {
+	case MMC_RSP_R1: /* short CRC, OPCODE */
+		cmddat |= MMC_CMD_RSP_R1;
+		break;
+	case MMC_RSP_R1B:/* short CRC, OPCODE, BUSY */
+		cmddat |= MMC_CMD_RSP_R1B;
+		break;
+	case MMC_RSP_R2: /* long 136 bit + CRC */
+		cmddat |= MMC_CMD_RSP_R2;
+		break;
+	case MMC_RSP_R3: /* short */
+		cmddat |= MMC_CMD_RSP_R3;
+		break;
+	}
+
+	if (host->app_mode)
+		cmddat |= MMC_CMD_ACMD;
+
+	val = inl(MP200_MMC_STOP) & ~MMC_STOP_STOP;
+	outl(val, MP200_MMC_STOP);
+
+	outl(cmd->arg & 0xffff, MP200_MMC_ARG0);
+	outl(cmd->arg >> 16,    MP200_MMC_ARG1);
+
+	FUNC_PRINT("CMD %d %x %x %x %x\n",
+		cmd->opcode, cmd->arg, cmd->flags, cmd->retries, cmddat);
+
+/*
+	printk("CMD %d %x %x %x %x\n",
+		cmd->opcode, cmd->arg, cmd->flags, cmd->retries, cmddat);
+*/
+
+	/* Send command */
+	outl(cmddat, MP200_MMC_CMD);
+}
+
+/*
+ * DMA clean up for command errors
+ */
+static void mp200_mmc_dma_cleanup(struct mp200_mmc_host *host)
+{
+	struct mmc_data *data = host->data;
+
+	if (host->dma_ch != -1) {
+		dma_unmap_sg(mmc_dev(host->mmc), data->sg,
+					host->dma_num, host->dma_dir);
+		mp200_reset_dma(host->dma_ch);
+		host->dma_ch = -1;
+	}
+}
+
+/*
+ * MMC controller IRQ handler
+ */
+static irqreturn_t
+mp200_mmc_irq(int irq, void *dev_id)
+{
+	struct mp200_mmc_host *host = (struct mp200_mmc_host *)dev_id;
+	u32 info, end_trans = 0;
+
+	info = mp200_mmc_info_read() & ~host->info_mask;
+
+/*
+	printk("%s: %x\n", __FUNCTION__, info);
+*/
+	if (host->cmd == NULL) {
+		outl(0, MP200_MMC_INFO1);
+		outl(0, MP200_MMC_INFO2);
+		return IRQ_HANDLED;
+	}
+
+	if (info & MMC_INFO_ALLERR) {
+		end_trans = 1;
+		if (info & MMC_INFO_CTO) {
+			FUNC_PRINT("%s: CMD=%d CMD Timeout\n",
+					__func__, host->cmd->opcode);
+			host->cmd->error = -ETIMEDOUT;
+		} else if (info & MMC_INFO_CRCERR) {
+			FUNC_PRINT("%s: CMD=%d CRC error\n",
+					__func__, host->cmd->opcode);
+			host->cmd->error = -EILSEQ;
+		} else {
+			FUNC_PRINT("%s: CMD=%d Other error.(0x%x)\n",
+					__func__, host->cmd->opcode, info);
+			host->cmd->error = -EILSEQ;
+		}
+		if (host->data) {
+			if (info & MMC_INFO_DTO) {
+				FUNC_PRINT("%s: CMD=%d DATA Timeout\n",
+						__func__, host->cmd->opcode);
+				host->data->error = -ETIMEDOUT;
+			} else {
+				FUNC_PRINT("%s: CMD=%d Other error.(0x%x)\n",
+					__func__, host->cmd->opcode, info);
+				host->data->error = -EILSEQ;
+			}
+			mp200_mmc_dma_cleanup(host);
+		}
+	}
+
+	if ((info & MMC_INFO_EOC) || end_trans) {
+		mp200_mmc_cmd_done(host, host->cmd);
+		return IRQ_HANDLED;
+	}
+	if ((info & MMC_INFO_RWEND)) {
+		mp200_mmc_data_done(host, host->cmd);
+		return IRQ_HANDLED;
+	}
+
+	return IRQ_HANDLED;
+}
+
+/*
+ * IRQ for handling card insertion and removal
+ */
+static irqreturn_t
+mp200_mmc_detect_irq(int irq, void *dev_id)
+{
+	struct mp200_mmc_host *host = (struct mp200_mmc_host *)dev_id;
+	unsigned int tmp_data;
+
+	FUNC_PRINT("\n");
+#ifdef	CONFIG_MP200_EM1_DKIT
+	tmp_data = gpio_get_value(GPIO_SD0CD);
+	if (tmp_data)
+		host->connect = 0;
+	else
+		host->connect = 1;
+#else
+	pwc_read(PWC_IOIN2, &tmp_data);
+	if (tmp_data & 0x40) {
+		/* fall edge */
+		pwc_write(PWC_DETMOD2H, 0x20, 0x30);
+		host->connect = 0;
+	} else {
+		/* rise edge */
+		pwc_write(PWC_DETMOD2H, 0x10, 0x30);
+		host->connect = 1;
+	}
+#endif
+	mmc_detect_change(host->mmc, msecs_to_jiffies(100));
+
+	return IRQ_HANDLED;
+}
+
+static void mp200_mmc_dma_cb(void *data, int intsts, int intrawsts)
+{
+	struct mp200_mmc_host *host = (struct mp200_mmc_host *)data;
+	u32 val;
+
+	host->dma_count++;
+
+	if (host->dma_count >= host->dma_num) {
+		val = inl(MP200_MMC_INFO1_MASK) & ~MMC_INFO_RWEND;
+		host->info_mask = val;
+		outl(val, MP200_MMC_INFO1_MASK);
+		host->dma_ch = -1;
+	} else if (host->dma_ch == host->dma_rx_ch) {
+		mp200_start_dma(host->dma_rx_ch, MP200_MMC_DMASD,
+			host->dma_len[host->dma_count],
+			host->dma_address[host->dma_count],
+			MP200_DMAC_INT_ERROR_EN | MP200_DMAC_INT_LENG_EN);
+	} else {
+		mp200_start_dma(host->dma_tx_ch,
+			host->dma_address[host->dma_count],
+			host->dma_len[host->dma_count], MP200_MMC_DMASD,
+			MP200_DMAC_INT_ERROR_EN | MP200_DMAC_INT_LENG_EN);
+	}
+}
+
+/*
+ * Configure block leangth for MMC/SD cards and intiate the transfer.
+ */
+static void
+mp200_mmc_setup_data(struct mp200_mmc_host *host, struct mmc_data *data)
+{
+	int i;
+
+	host->data = data;
+
+	host->data_len = data->blksz * data->blocks;
+
+	FUNC_PRINT("MMC: DATA: size=%d num=%d flags=0x%x\n",
+				data->blksz, data->blocks, data->flags);
+
+	outl(data->blksz,  MP200_MMC_SIZE);
+	outl(data->blocks, MP200_MMC_SECCNT);
+
+	host->dma_dir = (data->flags & MMC_DATA_WRITE) ?
+				DMA_TO_DEVICE : DMA_FROM_DEVICE;
+
+	host->dma_num = dma_map_sg(mmc_dev(host->mmc), data->sg,
+				data->sg_len, host->dma_dir);
+
+	for (i = 0; i < host->dma_num; i++) {
+		host->dma_address[i] = sg_dma_address(&data->sg[i]);
+		host->dma_len[i] = sg_dma_len(&data->sg[i]);
+	}
+
+	outl(MMC_CC_EXT_MODE_SD_DMA, MP200_MMC_CC_EXT_MODE);
+
+	host->dma_count = 0;
+
+	if (data->flags & MMC_DATA_READ) {
+		host->dma_ch = host->dma_rx_ch;
+		mp200_start_dma(host->dma_rx_ch, MP200_MMC_DMASD,
+			host->dma_len[0], host->dma_address[0],
+			MP200_DMAC_INT_ERROR_EN | MP200_DMAC_INT_LENG_EN);
+	} else {
+		host->dma_ch = host->dma_tx_ch;
+		mp200_start_dma(host->dma_tx_ch, host->dma_address[0],
+			host->dma_len[0], MP200_MMC_DMASD,
+			MP200_DMAC_INT_ERROR_EN | MP200_DMAC_INT_LENG_EN);
+	}
+
+/*
+	printk("MMC: dma_num=%d sg_len=%d\n", host->dma_num, data->sg_len);
+*/
+}
+
+/*
+ * Request function. for read/write operation
+ */
+static void
+mp200_mmc_request(struct mmc_host *mmc, struct mmc_request *req)
+{
+	struct mp200_mmc_host *host = mmc_priv(mmc);
+	u16 cmddat = 0;
+	u32 info;
+
+	if (host->connect == 0) {
+		req->cmd->error = -ENOMEDIUM;
+		mmc_request_done(mmc, req);
+		return;
+	}
+
+	host->req = req;
+	host->stop = req->stop;
+
+	MMC_CLK_ON;
+	info = mp200_mmc_info_read();
+
+	/* Clear stat */
+	outl(0, MP200_MMC_INFO1);
+	outl(0, MP200_MMC_INFO2);
+	req->cmd->error = 0;
+
+	if (req->data) {
+		req->data->error = 0;
+		mp200_mmc_setup_data(host, req->data);
+
+		cmddat |= MMC_CMD_DATA;
+
+		if (host->data->flags & MMC_DATA_READ)
+			cmddat |= MMC_CMD_READ;
+
+		if (host->data->blocks > 1) {
+			cmddat |= MMC_CMD_MULTI;
+			outl(MMC_STOP_MULTI, MP200_MMC_STOP);
+		}
+	}
+
+	mp200_mmc_start_cmd(host, req->cmd, cmddat);
+}
+
+static void mp200_mmc_power(struct mp200_mmc_host *host, u32 power_on)
+{
+	if (power_on) {
+		MMC_CLK_ON;
+		mp200_pmu_unreset_device(MP200_RESETDEVICE_SDIA);
+
+		outl(MMC_SDWAITCTRL_VAL,     SMU_AB1_SDIAWAITCTRL);
+		outl(MMC_SDREADCTRL_VAL,     SMU_AB1_SDIAREADCTRL);
+		outl(MMC_USER_VAL,           MP200_MMC_USER);
+		outl(MMC_USER2_VAL,          MP200_MMC_USER2);
+
+		outl(MMC_SOFT_RST_RESET,     MP200_MMC_SOFT_RST);
+		outl(MMC_SOFT_RST_UNRESET,   MP200_MMC_SOFT_RST);
+		outl(MMC_CC_EXT_MODE_FIFO,   MP200_MMC_CC_EXT_MODE);
+		outl(MMC_INFO_MASK,          MP200_MMC_INFO1_MASK);
+		outl(MMC_INFO_MASK >> 16,    MP200_MMC_INFO2_MASK);
+
+		outl(0, MP200_MMC_INFO1);
+		outl(0, MP200_MMC_INFO2);
+		outl(0, MP200_SDIO_INFO1);
+		outl(MMC_SDIO_INFO1_MASK, MP200_SDIO_INFO1_MASK);
+		outl(MMC_STOP_STOP, MP200_MMC_STOP);
+		outl(0x80EE, MP200_MMC_OPTION);
+
+		MMC_CLK_OFF;
+	} else {
+		host->clock = 0;
+		host->bus_width = 0;
+		MMC_CLK_ON;
+		mp200_pmu_reset_device(MP200_RESETDEVICE_SDIA);
+		MMC_CLK_OFF;
+	}
+}
+
+
+/*
+ * Configuring clock values.
+ */
+static void
+mp200_mmc_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
+{
+	struct mp200_mmc_host *host = mmc_priv(mmc);
+	u32 val, wDiv;
+
+/*
+	printk("%s: %d %x %d %d\n", __FUNCTION__,
+		ios->clock, ios->power_mode, ios->bus_width, ios->timing);
+*/
+	if ((host->bus_width != ios->bus_width)
+				&& (host->power_mode != MMC_POWER_OFF)) {
+		MMC_CLK_ON;
+		val = inl(MP200_MMC_OPTION);
+		if (ios->bus_width == MMC_BUS_WIDTH_4) {
+			host->bus_width = MMC_BUS_WIDTH_4;
+			val &= ~MMC_OPTION_WIDTH4;
+		} else {
+			host->bus_width = MMC_BUS_WIDTH_1;
+			val |= MMC_OPTION_WIDTH4;
+		}
+		outl(val, MP200_MMC_OPTION);
+		MMC_CLK_OFF;
+	}
+
+	if ((ios->clock != host->clock)
+				&& (host->power_mode != MMC_POWER_OFF)) {
+		MMC_CLK_ON;
+		/* Stop clock */
+		outl(0, MP200_MMC_CLK_CTRL);
+
+		if (ios->clock >= 40000000) {
+			wDiv = MMC_CLOCK_HIGH   | MMC_CLOCK_OFFEN;
+			outl(MMC_USER2_HIGH_VAL, MP200_MMC_USER2);
+		} else if (ios->clock >= 20000000) {
+			wDiv = MMC_CLOCK_DIV4   | MMC_CLOCK_OFFEN;
+		} else if (ios->clock >= 10000000) {
+			wDiv = MMC_CLOCK_DIV8   | MMC_CLOCK_OFFEN;
+		} else if (ios->clock >=  5000000) {
+			wDiv = MMC_CLOCK_DIV16  | MMC_CLOCK_OFFEN;
+		} else if (ios->clock >=  2500000) {
+			wDiv = MMC_CLOCK_DIV32  | MMC_CLOCK_OFFEN;
+		} else if (ios->clock >=  1250000) {
+			wDiv = MMC_CLOCK_DIV64  | MMC_CLOCK_OFFEN;
+		} else if (ios->clock >=   625000) {
+			wDiv = MMC_CLOCK_DIV128 | MMC_CLOCK_OFFEN;
+		} else {
+			wDiv = MMC_CLOCK_DIV256;
+		}
+
+		wDiv |= MMC_CLOCK_EN;
+
+		/* Start clock */
+		outl(wDiv, MP200_MMC_CLK_CTRL);
+		MMC_CLK_OFF;
+		host->clock = ios->clock;
+	}
+
+	if (host->power_mode != ios->power_mode) {
+		switch (ios->power_mode) {
+		case MMC_POWER_OFF:
+			mp200_mmc_power(host, 0);
+			FUNC_PRINT("power off\n");
+			break;
+		case MMC_POWER_UP:
+			mp200_mmc_power(host, 1);
+			FUNC_PRINT("power up\n");
+			break;
+		case MMC_POWER_ON:
+			FUNC_PRINT("power on\n");
+			break;
+		}
+		host->power_mode = ios->power_mode;
+	}
+}
+
+#ifndef MMC_WP_DISABLE
+static int mp200_mmc_get_ro(struct mmc_host *mmc)
+{
+	int ret;
+
+	ret = gpio_get_value(GPIO_SDWP);
+	dev_dbg(mmc_dev(mmc), "write protect = %d\n", ret);
+
+	return ret;
+}
+#endif
+
+static struct mmc_host_ops mp200_mmc_ops = {
+	.request	= mp200_mmc_request,
+	.set_ios	= mp200_mmc_set_ios,
+#ifndef MMC_WP_DISABLE
+	.get_ro		= mp200_mmc_get_ro,
+#endif
+};
+
+static int
+mp200_mmc_probe(struct platform_device *pdev)
+{
+	struct mmc_host *mmc;
+	struct mp200_mmc_host *host = NULL;
+	int ret = 0;
+	unsigned int tmp_data;
+
+	mmc = mmc_alloc_host(sizeof(struct mp200_mmc_host), &pdev->dev);
+	if (!mmc) {
+		ret = -ENOMEM;
+		goto err;
+	}
+
+	mmc->ops   = &mp200_mmc_ops;
+	mmc->f_min = 400000;
+	mmc->f_max = 50000000;
+	mmc->ocr_avail = MMC_VDD_28_29;
+	mmc->caps = MMC_CAP_4_BIT_DATA |
+				MMC_CAP_MMC_HIGHSPEED | MMC_CAP_SD_HIGHSPEED;
+
+	/* MMC core transfer sizes tunable parameters */
+	mmc->max_hw_segs   = MP200_MAX_SEGS;
+	mmc->max_phys_segs = MP200_MAX_SEGS;
+	mmc->max_seg_size  = MP200_MAX_SEGS * 512;
+	mmc->max_req_size  = MP200_MAX_SEGS * 512;
+	mmc->max_blk_size  = 512;
+	mmc->max_blk_count = 65535;
+
+	host      = mmc_priv(mmc);
+	host->mmc = mmc;
+	host->irq = INT_SDIASD;
+#ifdef	CONFIG_MP200_EM1_DKIT
+	host->detect_irq = INT_GPIO_SD0CD_INT;
+#else
+	host->detect_irq = INT_PWC_IO14;
+#endif
+	host->power_mode = MMC_POWER_OFF;
+	host->info_mask = MMC_INFO_MASK;
+	mutex_init(&host->mutex);
+
+	/* DMA setting */
+	host->dma_rx_ch = MP200_DMAC_P2M_LCH3;
+	host->dma_tx_ch = MP200_DMAC_M2P_LCH3;
+
+	ret = mp200_request_dma(host->dma_rx_ch, DRIVER_NAME,
+			mp200_mmc_dma_cb, (void *)host, &host->dma_rx_regs);
+	if (ret < 0)
+		goto err;
+
+	ret = mp200_request_dma(host->dma_tx_ch, DRIVER_NAME,
+			mp200_mmc_dma_cb, (void *)host, &host->dma_tx_regs);
+	if (ret < 0)
+		goto err_dma;
+
+	/* Request IRQ for MMC operations */
+	ret = request_irq(host->irq, mp200_mmc_irq,
+				IRQF_DISABLED, pdev->name, host);
+	if (ret) {
+		FUNC_PRINT("Unable to IRQ");
+		goto err_irq;
+	}
+
+	/* chattering ON */
+#ifdef	CONFIG_MP200_EM1_DKIT
+	set_irq_type(host->detect_irq, IRQ_TYPE_EDGE_BOTH);
+
+	tmp_data = gpio_get_value(GPIO_SD0CD);
+	if (tmp_data)
+		host->connect = 0;
+	else
+		host->connect = 1;
+#else
+	pwc_write(PWC_STATE2, 0x40, 0x40);
+
+	pwc_read(PWC_IOIN2, &tmp_data);
+	if (tmp_data & 0x40) {
+		/* fall edge */
+		set_irq_type(host->detect_irq, IRQ_TYPE_EDGE_FALLING);
+		host->connect = 0;
+	} else {
+		/* rise edge */
+		set_irq_type(host->detect_irq, IRQ_TYPE_EDGE_RISING);
+		host->connect = 1;
+	}
+#endif
+
+	/* Request IRQ for MMC card detect */
+	ret = request_irq(host->detect_irq, mp200_mmc_detect_irq,
+					IRQF_DISABLED, pdev->name, host);
+	if (ret) {
+		FUNC_PRINT("Unable to Card detect IRQ");
+		goto err_irq2;
+	}
+	platform_set_drvdata(pdev, host);
+	mmc_add_host(mmc);
+
+	return 0;
+
+err_irq2:
+	free_irq(host->irq, host);
+err_irq:
+	mp200_free_dma(host->dma_tx_ch);
+err_dma:
+	mp200_free_dma(host->dma_rx_ch);
+
+err:
+	printk("%s: error!!(%d)\n", __func__, ret);
+	if (host)
+		mmc_free_host(mmc);
+	return ret;
+
+}
+
+static int
+mp200_mmc_remove(struct platform_device *pdev)
+{
+	struct mp200_mmc_host *host = platform_get_drvdata(pdev);
+
+	platform_set_drvdata(pdev, NULL);
+	if (host) {
+		flush_scheduled_work();
+
+		mmc_remove_host(host->mmc);
+
+		mp200_mmc_power(host, 0);
+
+		free_irq(host->detect_irq, host);
+		free_irq(host->irq, host);
+
+		mp200_free_dma(host->dma_rx_ch);
+		mp200_free_dma(host->dma_tx_ch);
+
+		mmc_free_host(host->mmc);
+	}
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static unsigned int mmc_save[IDX_REGS_NUM];
+
+static void mmc_reg_save(void)
+{
+	mmc_save[IDX_CLK_CTRL] = inl(MP200_MMC_CLK_CTRL);
+	mmc_save[IDX_OPTION] = inl(MP200_MMC_OPTION);
+	mmc_save[IDX_SDIO_INFO1_MASK] = inl(MP200_SDIO_INFO1_MASK);
+	mmc_save[IDX_INFO2_MASK] = inl(MP200_MMC_INFO2_MASK);
+	mmc_save[IDX_INFO1_MASK] = inl(MP200_MMC_INFO1_MASK);
+	mmc_save[IDX_USER2] = inl(MP200_MMC_USER2);
+	mmc_save[IDX_USER] = inl(MP200_MMC_USER);
+
+	return;
+}
+
+static void mmc_reg_restore(void)
+{
+	outl(mmc_save[IDX_USER], MP200_MMC_USER);
+	outl(mmc_save[IDX_USER2], MP200_MMC_USER2);
+
+	outl(MMC_SOFT_RST_RESET,     MP200_MMC_SOFT_RST);
+	outl(MMC_SOFT_RST_UNRESET,   MP200_MMC_SOFT_RST);
+	outl(MMC_CC_EXT_MODE_FIFO,   MP200_MMC_CC_EXT_MODE);
+
+	outl(0, MP200_MMC_INFO1);
+	outl(0, MP200_MMC_INFO2);
+	outl(0, MP200_SDIO_INFO1);
+	outl(mmc_save[IDX_INFO1_MASK], MP200_MMC_INFO1_MASK);
+	outl(mmc_save[IDX_INFO2_MASK], MP200_MMC_INFO2_MASK);
+	outl(mmc_save[IDX_SDIO_INFO1_MASK], MP200_SDIO_INFO1_MASK);
+
+	outl(mmc_save[IDX_OPTION], MP200_MMC_OPTION);
+	outl(mmc_save[IDX_CLK_CTRL], MP200_MMC_CLK_CTRL);
+
+	return;
+}
+
+static int
+mp200_mmc_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	struct mp200_mmc_host *host = platform_get_drvdata(pdev);
+/*
+	printk("%s: %x\n", __FUNCTION__, state.event);
+*/
+	if (!host || host->suspended)
+		return 0;
+
+	if (!mp200_sleep_while_idle) {
+		/* detect interrupt disable */
+		disable_irq(host->detect_irq);
+
+		FUNC_PRINT("in\n");
+		mmc_suspend_host(host->mmc, state);
+		host->suspended = 1;
+		FUNC_PRINT("out\n");
+	} else if (host->clock) {
+		MMC_CLK_ON;
+		mmc_reg_save();
+		MMC_CLK_OFF;
+		host->suspended = 1;
+	}
+	return 0;
+}
+
+/* Routine to resume the MMC device */
+static int
+mp200_mmc_resume(struct platform_device *pdev)
+{
+	struct mp200_mmc_host *host = platform_get_drvdata(pdev);
+#ifndef	CONFIG_MP200_EM1_DKIT
+	unsigned int tmp_data;
+	unsigned long flag;
+#endif
+
+	if (host) {
+		if (!mp200_sleep_while_idle) {
+			/* detect interrupt enable */
+			enable_irq(host->detect_irq);
+
+#ifndef	CONFIG_MP200_EM1_DKIT
+			local_irq_save(flag);
+			pwc_read(PWC_IOIN2, &tmp_data);
+			if (tmp_data & 0x40) {
+				/* fall edge */
+				pwc_write(PWC_DETMOD2H, 0x20, 0x30);
+				host->connect = 0;
+			} else {
+				/* rise edge */
+				pwc_write(PWC_DETMOD2H, 0x10, 0x30);
+				host->connect = 1;
+			}
+			local_irq_restore(flag);
+#endif
+
+			mmc_resume_host(host->mmc);
+		} else if (host->suspended) {
+			MMC_CLK_ON;
+			mmc_reg_restore();
+			MMC_CLK_OFF;
+		}
+		host->suspended = 0;
+	}
+	return 0;
+}
+#else
+#define mp200_mmc_suspend	NULL
+#define mp200_mmc_resume	NULL
+#endif
+
+static struct platform_driver mp200_mmc_driver = {
+	.probe		= mp200_mmc_probe,
+	.remove		= mp200_mmc_remove,
+	.suspend	= mp200_mmc_suspend,
+	.resume		= mp200_mmc_resume,
+	.driver		= {
+			.name = DRIVER_NAME,
+	},
+};
+
+static int __init mp200_mmc_init(void)
+{
+	/* Register the MMC driver */
+	if (platform_driver_register(&mp200_mmc_driver)) {
+		printk(KERN_ERR ": Failed to register MMC driver\n");
+		return -ENODEV;
+	}
+	return 0;
+}
+
+static void __exit mp200_mmc_cleanup(void)
+{
+	/* Unregister MMC driver */
+	platform_driver_unregister(&mp200_mmc_driver);
+}
+
+module_init(mp200_mmc_init);
+module_exit(mp200_mmc_cleanup);
+
+MODULE_DESCRIPTION("MP200 High Speed Multimedia Card driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS(DRIVER_NAME);
+MODULE_AUTHOR("NEC Electronics");
diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 9c288c9..7288b22 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -140,7 +140,15 @@ struct mmc_host {
 	unsigned int		removed:1;	/* host is being removed */
 #endif
 
+#ifdef CONFIG_ARCH_MP200
+#define MMC_CARD_MAX_NUM	4
+	/* device attached to this host */
+	struct mmc_card		*card[MMC_CARD_MAX_NUM];
+	unsigned char 		card_num;	/* card num */
+	unsigned int 		select;		/* select card status */
+#else
 	struct mmc_card		*card;		/* device attached to this host */
+#endif
 
 	wait_queue_head_t	wq;
 
-- 
1.6.5.2

