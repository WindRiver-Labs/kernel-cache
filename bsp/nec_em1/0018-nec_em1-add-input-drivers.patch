From 1886103645ef6aa7b83dae2d6f3eb9ccbffd92b8 Mon Sep 17 00:00:00 2001
From: Kazuya Tsukamoto <kazuya.tsukamoto@necel.com>
Date: Mon, 9 Nov 2009 12:19:54 +0900
Subject: [PATCH 18/29] nec_em1: add input drivers

Add the keyboard and touchpanel drivers, both use the standard
Linux input system.

keyboard driver reads a signal from the matrix of the signal of
PowerIC(DA9052) and MAX7324.
The key code of KEY_F1~KEY_F14 is given to the key to SW1~14.

TouchPanel driver reads the signal from TouchPanel device connected
with PowerIC(DA9052).

Signed-off-by: Kazuya Tsukamoto <kazuya.tsukamoto@necel.com>
---
 drivers/input/keyboard/Kconfig           |    8 +
 drivers/input/keyboard/Makefile          |    3 +
 drivers/input/keyboard/mp200_max7324.c   |  418 ++++++++++++++++++++++++++++++
 drivers/input/keyboard/mp200_max7324.h   |   48 ++++
 drivers/input/touchscreen/Kconfig        |   62 ++---
 drivers/input/touchscreen/Makefile       |    8 +-
 drivers/input/touchscreen/mp200_da9052.c |  292 +++++++++++++++++++++
 7 files changed, 793 insertions(+), 46 deletions(-)
 create mode 100644 drivers/input/keyboard/mp200_max7324.c
 create mode 100644 drivers/input/keyboard/mp200_max7324.h
 create mode 100644 drivers/input/touchscreen/mp200_da9052.c

diff --git a/drivers/input/keyboard/Kconfig b/drivers/input/keyboard/Kconfig
index e4d0436..38575ce 100644
--- a/drivers/input/keyboard/Kconfig
+++ b/drivers/input/keyboard/Kconfig
@@ -356,4 +356,12 @@ config KEYBOARD_SH_KEYSC
 
 	  To compile this driver as a module, choose M here: the
 	  module will be called sh_keysc.
+
+config KEYBOARD_MP200
+	tristate "mp200 button support"
+	depends on ARCH_MP200 && !MP200_EM1_DKIT && INPUT_KEYBOARD
+
+config KEYBOARD_MAX7324
+	tristate "EM1 DKIT Board button support"
+	depends on MP200_EM1_DKIT && INPUT_KEYBOARD
 endif
diff --git a/drivers/input/keyboard/Makefile b/drivers/input/keyboard/Makefile
index ae47fff..e08baa6 100644
--- a/drivers/input/keyboard/Makefile
+++ b/drivers/input/keyboard/Makefile
@@ -31,3 +31,6 @@ obj-$(CONFIG_KEYBOARD_HP7XX)		+= jornada720_kbd.o
 obj-$(CONFIG_KEYBOARD_MAPLE)		+= maple_keyb.o
 obj-$(CONFIG_KEYBOARD_BFIN)		+= bf54x-keys.o
 obj-$(CONFIG_KEYBOARD_SH_KEYSC)		+= sh_keysc.o
+obj-$(CONFIG_KEYBOARD_MP200)		+= mp200_btn.o
+obj-$(CONFIG_KEYBOARD_MAX7324)		+= mp200_max7324.o
+
diff --git a/drivers/input/keyboard/mp200_max7324.c b/drivers/input/keyboard/mp200_max7324.c
new file mode 100644
index 0000000..a2c189e
--- /dev/null
+++ b/drivers/input/keyboard/mp200_max7324.c
@@ -0,0 +1,418 @@
+/*
+ *  linux/drivers/input/touchscreen/mp200_max7324.c
+ *
+ *  Copyright (C) NEC Electronics Corporation 2009
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/input.h>
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/i2c.h>
+
+#include <asm/mach/irq.h>
+
+#include "mp200_max7324.h"
+
+/* #define BUTTON_DEBUG */
+
+static const int irq_pwc_gpio_key[] = {
+	INT_PWC_GPIO_KEY_DATA0, INT_PWC_GPIO_KEY_DATA1,
+	INT_PWC_GPIO_KEY_DATA2, INT_PWC_GPIO_KEY_DATA3
+};
+
+/**** Global parameters ****/
+static unsigned int scan_delay = BTN_CHAT_GUARDTIME;
+static unsigned int scan_interval = BTN_SCAN_INTERVAL;
+
+static struct input_dev *mp200_max7324_dev;
+
+/* work queue */
+static struct workqueue_struct *mp200_max7324_workqueue;
+static struct delayed_work mp200_max7324_work;
+
+static int mp200_max7324_initialized;
+
+static unsigned long last_bcode;	/* store last button matrix state */
+static unsigned long black_bcode;	/* the button should be abandoned */
+
+/* Translation table from the got data to keycode */
+static struct mp200_btn_table mp200_max7324_code_tbl[] = {
+	/* KEY_OUT0 */
+	{.scancode = KEY_F4, .btn_id_bit = (1 << 0), },	/* SW4 */
+	{.scancode = KEY_F8, .btn_id_bit = (1 << 1), },	/* SW8 */
+	{.scancode = KEY_F11, .btn_id_bit = (1 << 2), },	/* SW11 */
+	{.scancode = KEY_F14, .btn_id_bit = (1 << 4), },	/* SW14 */
+
+	/* KEY_OUT1 */
+	{.scancode = KEY_F3, .btn_id_bit = (1 << 8), },	/* SW3 */
+	{.scancode = KEY_F7, .btn_id_bit = (1 << 9), },	/* SW7 */
+	{.scancode = KEY_F19, .btn_id_bit = (1 << 10), },	/* SW10 */
+	{.scancode = KEY_F13, .btn_id_bit = (1 << 12), },	/* SW13 */
+
+	/* KEY_OUT2 */
+	{.scancode = KEY_F2, .btn_id_bit = (1 << 16), },	/* SW2 */
+	{.scancode = KEY_F6, .btn_id_bit = (1 << 17), },	/* SW6 */
+	{.scancode = KEY_F9, .btn_id_bit = (1 << 18), },	/* SW9 */
+	{.scancode = KEY_F12, .btn_id_bit = (1 << 20), },	/* SW12 */
+
+	/* KEY_OUT3 */
+	{.scancode = KEY_F1, .btn_id_bit = (1 << 26), },	/* SW1 */
+	{.scancode = KEY_F5, .btn_id_bit = (1 << 28), },	/* SW5 */
+
+	{.scancode = 0, .btn_id_bit = 0, },
+};
+
+/*
+ * mp200_max7324_scan_core
+ *    scan button matrix, and judge valid pressing
+ */
+static void mp200_max7324_scan_core(struct work_struct *work)
+{
+	int btn_push_cnt = 0;
+	unsigned long chg_bcode;
+	unsigned long tmp_bcode;
+	unsigned long btncode = 0;
+	unsigned long val1 = 0, val2 = 0, val3 = 0, val4 = 0;
+	struct input_dev *btn_dev = mp200_max7324_dev;
+
+	struct mp200_btn_table *bst;
+
+#ifdef BUTTON_DEBUG
+	printk(KERN_INFO "%s(): time=%ld\n", __func__, jiffies);
+#endif
+
+#define I2C_MAX7324_DELAY_TIME 64
+
+	extio_write(EXTIO_OUT, 0x01, 0x0f);
+	udelay(I2C_MAX7324_DELAY_TIME);
+	pwc_read(DA9052_STATUSD_REG , (unsigned int *)&val1);
+
+	extio_write(EXTIO_OUT, 0x02, 0x0f);
+	udelay(I2C_MAX7324_DELAY_TIME);
+	pwc_read(DA9052_STATUSD_REG , (unsigned int *)&val2);
+
+	extio_write(EXTIO_OUT, 0x04, 0x0f);
+	udelay(I2C_MAX7324_DELAY_TIME);
+	pwc_read(DA9052_STATUSD_REG , (unsigned int *)&val3);
+
+	extio_write(EXTIO_OUT, 0x08, 0x0f);
+	udelay(I2C_MAX7324_DELAY_TIME);
+	pwc_read(DA9052_STATUSD_REG , (unsigned int *)&val4);
+
+	btncode = ((val4 << 24) | (val3 << 16) |
+			(val2 << 8) | val1) & BTN_DATA_MASK;
+
+#ifdef BUTTON_DEBUG
+	printk(KERN_INFO "%s(): button bit =0x%08lx\n", __func__, btncode);
+#endif
+
+	/* check out pressed button number */
+	bst = mp200_max7324_code_tbl;
+	tmp_bcode = btncode;
+
+	while ((bst->btn_id_bit != 0) && (tmp_bcode != 0)) {
+		if ((btncode & bst->btn_id_bit) != 0) {
+			btn_push_cnt++;
+			tmp_bcode &= ~(bst->btn_id_bit);
+		}
+		bst++;
+	}
+
+	chg_bcode = last_bcode ^ btncode;
+
+	/* if total pressed button number is invalid, ignore it */
+	if (btn_push_cnt > 1) {
+		tmp_bcode = (chg_bcode & btncode);
+		black_bcode |= (tmp_bcode & ~last_bcode);
+	}
+
+	/* which button released ? */
+	tmp_bcode = (chg_bcode & last_bcode);
+	if ((tmp_bcode & ~black_bcode) != 0) {
+		bst = mp200_max7324_code_tbl;
+		while (bst->btn_id_bit != 0) {
+			/* check out which button */
+			if ((tmp_bcode & bst->btn_id_bit) != 0) {
+				/* button release */
+				input_report_key(btn_dev, bst->scancode, 0);
+#ifdef BUTTON_DEBUG
+				printk(KERN_INFO "%s(): RELEASE %d time=%ld\n",
+				       __func__, bst->scancode, jiffies);
+#endif
+				break;
+			}
+			bst++;
+		}
+	}
+
+	/* which button pressed ? */
+	tmp_bcode = (chg_bcode & btncode);
+	if ((tmp_bcode & ~black_bcode) != 0) {
+		bst = mp200_max7324_code_tbl;
+		while (bst->btn_id_bit != 0) {
+			/* check out which button */
+			if ((tmp_bcode & bst->btn_id_bit) != 0) {
+				/* button press */
+				input_report_key(btn_dev, bst->scancode, 1);
+#ifdef BUTTON_DEBUG
+				printk(KERN_INFO "%s(): PRESS %d time=%ld\n",
+				       __func__, bst->scancode, jiffies);
+#endif
+				break;
+			}
+			bst++;
+		}
+	}
+
+	/* make a record for legal button */
+	last_bcode = btncode & ~black_bcode;
+
+	/* try to clear black bit */
+	black_bcode &= btncode;
+
+	if (btncode != 0) {
+		queue_delayed_work(mp200_max7324_workqueue,
+				&mp200_max7324_work, scan_interval);
+	} else {
+		/* button int unmask */
+		/* DEBOUNCING time 10msec */
+		pwc_write(DA9052_CONTROLC_REG, 0x04, 0x1C);
+
+		/* button scan all on */
+		extio_write(EXTIO_OUT, 0xf, 0x0f);
+
+		/* pwc_write(DA9052_EVENTD_REG, 0x17, 0x17); */
+
+		enable_irq(INT_PWC_GPIO_KEY_DATA0);
+		enable_irq(INT_PWC_GPIO_KEY_DATA1);
+		enable_irq(INT_PWC_GPIO_KEY_DATA2);
+		enable_irq(INT_PWC_GPIO_KEY_DATA3);
+	}
+
+	return;
+}
+
+/*
+ * mp200_max7324_interrupt
+ *     button interrupt handler for all buttons
+ */
+static irqreturn_t
+mp200_max7324_interrupt(int irq, void *dev_id)
+{
+#ifdef BUTTON_DEBUG
+	printk(KERN_INFO "%s(): irq %d, time=%ld\n",
+					__func__, irq - INT_PWC_BASE,  jiffies);
+#endif
+
+	/* button int unmask */
+	disable_irq(INT_PWC_GPIO_KEY_DATA0);
+	disable_irq(INT_PWC_GPIO_KEY_DATA1);
+	disable_irq(INT_PWC_GPIO_KEY_DATA2);
+	disable_irq(INT_PWC_GPIO_KEY_DATA3);
+
+	/* DEBOUNCING time 0msec */
+	pwc_write(DA9052_CONTROLC_REG, 0x00,  0x1C);
+
+	queue_delayed_work(mp200_max7324_workqueue,
+			&mp200_max7324_work, scan_delay);
+
+	return IRQ_HANDLED;
+}
+
+
+static int mp200_max7324_start(void)
+{
+	int err;
+	struct mp200_btn_table *bst;
+	int irq = 0;
+	int irq_count;
+
+	/* input device & irq init */
+	mp200_max7324_dev = input_allocate_device();
+	if (!mp200_max7324_dev) {
+		printk(KERN_ERR "mp200_max7324.c: Not enough memory for input device\n");
+		return -ENOMEM;
+	}
+
+	/* work queue */
+	INIT_DELAYED_WORK(&mp200_max7324_work, mp200_max7324_scan_core);
+
+	/* setup input device */
+	set_bit(EV_KEY, mp200_max7324_dev->evbit);
+	set_bit(EV_REP, mp200_max7324_dev->evbit);
+
+	bst = mp200_max7324_code_tbl;
+	while (bst->btn_id_bit != 0) {
+		set_bit(bst->scancode, mp200_max7324_dev->keybit);
+		bst++;
+	}
+
+	mp200_max7324_dev->name = MP200_BTN_NAME;
+
+	err = input_register_device(mp200_max7324_dev);
+	if (err < 0) {
+		printk(KERN_ERR "Unable to register mp200_max7324 input device\n");
+		goto out_input_free_device;
+	}
+
+	gpio_set_value(GPIO_EXT1_P12, 1);
+
+	/* DEBOUNCING time 10msec */
+	pwc_write(DA9052_CONTROLC_REG, 0x04, 0x1C);
+
+	/* button scan all on */
+	extio_write(EXTIO_OUT, 0x0f, 0x0f);
+
+	/* key interrupt clear */
+	pwc_write(DA9052_EVENTD_REG, 0x17, 0x17);
+
+	irq_count = sizeof(irq_pwc_gpio_key) / sizeof(irq_pwc_gpio_key[0]);
+	for (; irq < irq_count; irq++) {
+		/* set interrupt high level */
+		set_irq_type(irq_pwc_gpio_key[irq], IRQ_TYPE_LEVEL_HIGH);
+
+		/* request interrupt handler */
+		err = request_irq(irq_pwc_gpio_key[irq],
+				mp200_max7324_interrupt,
+				IRQF_DISABLED, MP200_BTN_NAME, NULL);
+		if (err != 0) {
+			printk(KERN_INFO
+			       "%s(): reuest_irq(%#x, %p, IRQF_DISABLED, %s, 0)"
+			       "failed (%d)\n",
+			       __func__, irq_pwc_gpio_key[irq],
+			       mp200_max7324_interrupt, MP200_BTN_NAME, err);
+			goto out_free_irq;
+		}
+	}
+
+	mp200_max7324_initialized = 1;
+
+	return 0;
+
+out_free_irq:
+	for (irq--; irq >= 0; irq--)
+		free_irq(irq_pwc_gpio_key[irq], 0);
+
+	input_unregister_device(mp200_max7324_dev);
+
+out_input_free_device:
+	input_free_device(mp200_max7324_dev);
+
+	return err;
+}
+
+static int wait_count;
+static void mp200_max7324_start_wait(struct work_struct *work)
+{
+	int ret;
+
+	if (mp200_extio_initialized == 0) {
+		if (wait_count++ < 10)
+			queue_delayed_work(mp200_max7324_workqueue,
+			&mp200_max7324_work, 10);
+	} else {
+		ret = mp200_max7324_start();
+	}
+}
+
+
+/*
+ * mp200_max7324_init
+ */
+static int __init mp200_max7324_init(void)
+{
+	int err;
+
+	printk(KERN_INFO "Starting button.\n");
+
+	/* work queue */
+	mp200_max7324_workqueue = create_singlethread_workqueue(MP200_BTN_NAME);
+
+	if (mp200_extio_initialized == 0) {
+		INIT_DELAYED_WORK(&mp200_max7324_work,
+				mp200_max7324_start_wait);
+		queue_delayed_work(mp200_max7324_workqueue,
+				&mp200_max7324_work, 10);
+	} else {
+		err = mp200_max7324_start();
+		if (err != 0)
+			return err;
+	}
+	/* set scan delay */
+	scan_delay = scan_delay * HZ / 1000;
+	if (scan_delay < 1)
+		scan_delay = BTN_CHAT_GUARDTIME * HZ / 1000;
+
+	/* set scan interval */
+	scan_interval = scan_interval * HZ / 1000;
+	if (scan_interval < 1)
+		scan_interval = BTN_SCAN_INTERVAL * HZ / 1000;
+
+	return 0;
+}
+
+/*
+ * mp200_max7324_exit
+ */
+static void __exit mp200_max7324_exit(void)
+{
+	int irq;
+	int irq_count;
+
+	extio_write(EXTIO_OUT, 0, 0x0f);	/* button scan all off */
+
+	if (mp200_max7324_initialized) {
+		irq_count = sizeof(irq_pwc_gpio_key) /
+				sizeof(irq_pwc_gpio_key[0]);
+		for (irq = 0; irq < irq_count; irq++)
+			free_irq(irq_pwc_gpio_key[irq], 0);
+		input_unregister_device(mp200_max7324_dev);
+		input_free_device(mp200_max7324_dev);
+	}
+
+	destroy_workqueue(mp200_max7324_workqueue);
+}
+
+#ifndef MODULE
+/*
+ * boot command line parameters
+ * button=scan_delay[mS],scan_interval[mS]
+ */
+static int __init mp200_max7324_setup(char *str)
+{
+	int inkb[3];
+
+	get_options(str, ARRAY_SIZE(inkb), inkb);
+
+	if ((inkb[0] >= 1) && (inkb[1] > 0))
+		scan_delay = (unsigned int)inkb[1];
+
+	if ((inkb[0] >= 2) && (inkb[2] > 0))
+		scan_interval = (unsigned int)inkb[2];
+
+	return 0;
+}
+
+__setup("button=", mp200_max7324_setup);
+#endif
+
+module_init(mp200_max7324_init);
+module_exit(mp200_max7324_exit);
+
+module_param(scan_delay, uint, 0644);
+MODULE_PARM_DESC(scan_delay, "mp200 button chattering guard time [ms]");
+
+module_param(scan_interval, uint, 0644);
+MODULE_PARM_DESC(scan_interval, "mp200 button scan interval time [ms]");
+
+MODULE_LICENSE("GPL");
+
+
diff --git a/drivers/input/keyboard/mp200_max7324.h b/drivers/input/keyboard/mp200_max7324.h
new file mode 100644
index 0000000..5bd07d3
--- /dev/null
+++ b/drivers/input/keyboard/mp200_max7324.h
@@ -0,0 +1,48 @@
+/*
+ *  File Name       : linux/drivers/input/keyboard/mp200_btn.h
+ *  Function        : button Interface
+ *  Release Version : Ver 1.00
+ *  Release Date    : 2008/07/07
+ *
+ *  Copyright (C) NEC Electronics Corporation 2005-2008
+ *
+ *
+ *  This program is free software;you can redistribute it and/or modify
+ *  itunder the terms of the GNU General Public License as published by
+ *  Free Softwere Foundation;either version 2 of License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY;
+ *  without even the implied warrnty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.
+ *  See the GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program;
+ *  If not, write to the Free Software Foundation, Inc., 59 Temple
+ *  Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#ifndef __MP200_MAX7324_H__
+#define __MP200_MAX7324_H__
+
+#include <mach/irqs.h>
+#include <mach/gpio.h>
+
+/* key scan default parameter */
+#define BTN_CHAT_GUARDTIME	20	/* 20ms */
+#define BTN_SCAN_INTERVAL	30	/* 30ms */
+
+/* KEYSCAN */
+#define BTN_DATA_MASK		0x14171717
+
+#define MP200_BTN_NAME		"mp200_button"
+
+struct mp200_btn_table {
+	unsigned int scancode;	/* keycode */
+	unsigned long btn_id_bit;	/* button id bit */
+};
+
+#endif /* __MP200_MAX7324_H__ */
diff --git a/drivers/input/touchscreen/Kconfig b/drivers/input/touchscreen/Kconfig
index 84ba956..424582b 100644
--- a/drivers/input/touchscreen/Kconfig
+++ b/drivers/input/touchscreen/Kconfig
@@ -181,6 +181,12 @@ config TOUCHSCREEN_MIGOR
 	  To compile this driver as a module, choose M here: the
 	  module will be called migor_ts.
 
+config TOUCHSCREEN_SYNAPTICS_I2C_RMI
+	tristate "Synaptics i2c touchscreen"
+	depends on I2C
+	help
+	  This enables support for Synaptics RMI over I2C based touchscreens.
+
 config TOUCHSCREEN_TOUCHRIGHT
 	tristate "Touchright serial touchscreen"
 	select SERIO
@@ -217,47 +223,6 @@ config TOUCHSCREEN_ATMEL_TSADCC
 	  To compile this driver as a module, choose M here: the
 	  module will be called atmel_tsadcc.
 
-config TOUCHSCREEN_TSC2005
-	tristate "TSC2005 touchscreen support"
-	depends on SPI_MASTER
-	help
-	  Say Y here for if you are using the touchscreen features of TSC2005.
-
-config TOUCHSCREEN_TSC2102
-	tristate "TSC 2102 based touchscreens"
-	depends on SPI_MASTER
-	select SPI_TSC2102
-	help
-	  Say Y here if you have a touchscreen interface using the
-	  TI TSC 2102 controller, and your board-specific initialization
-	  code includes that in its table of SPI devices.  Also make
-	  sure the proper SPI controller is selected.
-
-	  If unsure, say N (but it's safe to say "Y").
-
-	  To compile this driver as a module, choose M here: the
-	  module will be called tsc2102_ts.
-
-config TOUCHSCREEN_TSC210X
-	tristate "TI TSC210x based touchscreens"
-	depends on SPI_MASTER
-	select SPI_TSC210X
-	help
-	  Say Y here if you have a touchscreen interface using a
-	  TI TSC210x controller, and your board-specific initialisation
-	  code includes that in its table of SPI devices.
-
-	  If unsure, say N (but it's safe to say "Y").
-
-	  To compile this driver as a module, choose M here: the
-	  module will be called tsc210x_ts.
-
-config TOUCHSCREEN_TSC2301
-	tristate "TSC2301 touchscreen support"
-	depends on SPI_TSC2301
-	help
-	  Say Y here for if you are using the touchscreen features of TSC2301.
-
 config TOUCHSCREEN_UCB1400
 	tristate "Philips UCB1400 touchscreen"
 	select AC97_BUS
@@ -412,4 +377,19 @@ config TOUCHSCREEN_TOUCHIT213
 	  To compile this driver as a module, choose M here: the
 	  module will be called touchit213.
 
+config TOUCHSCREEN_TSC2007
+	tristate "TSC2007 based touchscreens"
+	depends on I2C
+	help
+	  Say Y here if you have a TSC2007 based touchscreen.
+
+	  If unsure, say N.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called tsc2007.
+
+config TOUCHSCREEN_DA9052
+	tristate "DA9052 touch input driver"
+	depends on MP200_EM1_DKIT
+
 endif
diff --git a/drivers/input/touchscreen/Makefile b/drivers/input/touchscreen/Makefile
index 0c31dfa..fa94ed6 100644
--- a/drivers/input/touchscreen/Makefile
+++ b/drivers/input/touchscreen/Makefile
@@ -22,17 +22,15 @@ obj-$(CONFIG_TOUCHSCREEN_HP7XX)		+= jornada720_ts.o
 obj-$(CONFIG_TOUCHSCREEN_HTCPEN)	+= htcpen.o
 obj-$(CONFIG_TOUCHSCREEN_USB_COMPOSITE)	+= usbtouchscreen.o
 obj-$(CONFIG_TOUCHSCREEN_PENMOUNT)	+= penmount.o
+obj-$(CONFIG_TOUCHSCREEN_SYNAPTICS_I2C_RMI)	+= synaptics_i2c_rmi.o
 obj-$(CONFIG_TOUCHSCREEN_TOUCHIT213)	+= touchit213.o
 obj-$(CONFIG_TOUCHSCREEN_TOUCHRIGHT)	+= touchright.o
 obj-$(CONFIG_TOUCHSCREEN_TOUCHWIN)	+= touchwin.o
 obj-$(CONFIG_TOUCHSCREEN_UCB1400)	+= ucb1400_ts.o
-obj-$(CONFIG_TOUCHSCREEN_TSC2005)	+= tsc2005.o
-obj-$(CONFIG_TOUCHSCREEN_TSC2102)	+= tsc2102_ts.o
-obj-$(CONFIG_TOUCHSCREEN_OMAP)	+= omap/
-obj-$(CONFIG_TOUCHSCREEN_TSC210X)	+= tsc210x_ts.o
-obj-$(CONFIG_TOUCHSCREEN_TSC2301)	+= tsc2301_ts.o
 obj-$(CONFIG_TOUCHSCREEN_WM97XX)	+= wm97xx-ts.o
 wm97xx-ts-$(CONFIG_TOUCHSCREEN_WM9705)	+= wm9705.o
 wm97xx-ts-$(CONFIG_TOUCHSCREEN_WM9712)	+= wm9712.o
 wm97xx-ts-$(CONFIG_TOUCHSCREEN_WM9713)	+= wm9713.o
 obj-$(CONFIG_TOUCHSCREEN_WM97XX_MAINSTONE)	+= mainstone-wm97xx.o
+obj-$(CONFIG_TOUCHSCREEN_TSC2007)	+= tsc2007.o
+obj-$(CONFIG_TOUCHSCREEN_DA9052)    += mp200_da9052.o
diff --git a/drivers/input/touchscreen/mp200_da9052.c b/drivers/input/touchscreen/mp200_da9052.c
new file mode 100644
index 0000000..1361f28
--- /dev/null
+++ b/drivers/input/touchscreen/mp200_da9052.c
@@ -0,0 +1,292 @@
+/*
+ *  linux/drivers/input/touchscreen/mp200-da9052.c
+ *
+ *  Copyright (C) NEC Electronics Corporation 2009
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/device.h>
+#include <linux/input.h>
+#include <linux/platform_device.h>
+
+#include <asm/irq.h>
+#include <mach/pwc.h>
+
+static u32 debug;
+module_param(debug, int, 0644);
+MODULE_PARM_DESC(debug, "mp200 touch debug level");
+
+#define DS9052_TS_SCAN_TIME	10
+static unsigned int scan_interval = DS9052_TS_SCAN_TIME;
+module_param(scan_interval, uint, 0644);
+MODULE_PARM_DESC(scan_interval, "mp200 touch scan interval time [ms]");
+
+#define DA9052_NAME	"da9052-ts"
+
+#define DA9052_TS_DOWN_IRQ	INT_PWC_E_PEN_DOWN
+#define DA9052_TS_READY_IRQ	INT_PWC_E_TSI_READY
+
+#define	MAX_10BIT	((1 << 10) - 1)
+
+#ifdef CONFIG_MP200_ANDROID
+#define X_MIN	20
+#define X_MAX	1000
+#define Y_MIN	40
+#define Y_MAX	980
+#else
+#define X_MIN	0
+#define X_MAX	MAX_10BIT
+#define Y_MIN	0
+#define Y_MAX	MAX_10BIT
+#endif
+
+struct da9052_ts {
+	struct input_dev *dev;
+
+	struct timer_list	timer;
+
+	int down_irq;
+	int ready_irq;
+
+	u8	pen_down;
+};
+
+static void da9052_ts_pwr_up(struct da9052_ts *ts)
+{
+	pwc_reg_write(DA9052_LDO9_REG, 0x59);
+	pwc_reg_write(DA9052_TSICONTA_REG, 0xe3);
+	pwc_write(DA9052_ADCCONT_REG, 0x40, 0x40);
+}
+
+static void da9052_ts_pwr_down(struct da9052_ts *ts)
+{
+	pwc_reg_write(DA9052_LDO9_REG, 0x19);
+	pwc_reg_write(DA9052_TSICONTA_REG, 0xe2);
+	pwc_write(DA9052_ADCCONT_REG, 0x00, 0x40);
+}
+
+static int da9052_get_data(struct da9052_ts *ts)
+{
+	unsigned int x, y, z, tmp;
+	int pressure = 0;
+
+	pwc_read(DA9052_TSIXMSB_REG, &x);
+	pwc_read(DA9052_TSIYMSB_REG, &y);
+	pwc_read(DA9052_TSIZMSB_REG, &z);
+	pwc_read(DA9052_TSILSB_REG, &tmp);
+	pwc_write(DA9052_EVENTB_REG, 0xC0, 0xC0);
+
+	x = (x << 2) | ((tmp & 0x03) >> 0);
+	y = (y << 2) | ((tmp & 0x0c) >> 2);
+	z = (z << 2) | ((tmp & 0x30) >> 4);
+
+	if (z != 0) {
+		pressure = 685*x*(1024 - z) - (159*z*(1024-y));
+		pressure /= (z*1024);
+	}
+
+	if (debug)
+		printk(KERN_INFO "%s: x=%d y=%d z=%d p=%d (%s)\n",
+			__func__, x, y, z, pressure,
+			(tmp & 0x40) ? "P" : "R");
+
+#ifdef CONFIG_MP200_ANDROID
+		{
+			int y2 = (Y_MIN + Y_MAX) - y;
+			if (y2 < 0)
+				y = Y_MIN;
+			else
+				y = y2;
+		}
+#endif
+
+	if (tmp & 0x40) {
+		input_report_abs(ts->dev, ABS_X, x);
+		input_report_abs(ts->dev, ABS_Y, y);
+		input_report_abs(ts->dev, ABS_PRESSURE, pressure);
+		if (ts->pen_down == 0) {
+			input_report_key(ts->dev, BTN_TOUCH, 1);
+			ts->pen_down = 1;
+		}
+		input_sync(ts->dev);
+		return 0;
+	} else {
+		input_report_abs(ts->dev, ABS_PRESSURE, 0);
+		if (ts->pen_down) {
+			input_report_key(ts->dev, BTN_TOUCH, 0);
+			input_sync(ts->dev);
+			ts->pen_down = 0;
+		}
+		return -1;
+	}
+}
+
+static void da9052_timer_handler(unsigned long data)
+{
+	struct da9052_ts *ts = (struct da9052_ts *)data;
+	int ret;
+
+	ret = da9052_get_data(ts);
+	if (ret == 0) {
+		mod_timer(&ts->timer,
+			jiffies + msecs_to_jiffies(scan_interval));
+	} else {
+		/* Change Low-power mode */
+		da9052_ts_pwr_down(ts);
+		enable_irq(ts->down_irq);
+		enable_irq(ts->ready_irq);
+	}
+}
+
+static irqreturn_t da9052_irq_handler(int irq, void *dev_id)
+{
+	struct da9052_ts *ts = dev_id;
+	int ret;
+
+	if (irq == ts->down_irq) {
+		/* Change Active mode */
+		da9052_ts_pwr_up(ts);
+		disable_irq(ts->down_irq);
+	} else {
+		ret = da9052_get_data(ts);
+		if (ret == 0) {
+			disable_irq(ts->ready_irq);
+			mod_timer(&ts->timer,
+				jiffies + msecs_to_jiffies(scan_interval*2));
+		}
+	}
+	return IRQ_HANDLED;
+}
+
+static int __init da9052_ts_probe(struct platform_device *pdev)
+{
+	int ret;
+	struct input_dev *dev;
+	struct da9052_ts *ts;
+
+	ts = kzalloc(sizeof(*ts), GFP_KERNEL);
+	if (ts == NULL)
+		return -ENOMEM;
+
+	dev = input_allocate_device();
+	if (!dev) {
+		printk(KERN_INFO
+			"%s: error allocating memory for input structure\n",
+			__func__);
+		ret = -ENOMEM;
+		goto err_alloc_dev;
+	}
+
+	dev->name = DA9052_NAME;
+	dev->dev.parent = &pdev->dev;
+	dev->id.bustype = BUS_HOST;
+	dev->id.vendor = 0x10b7;
+	dev->id.product = 0x0001;
+	dev->id.version = 0x0001;
+
+	dev->evbit[0] = BIT(EV_KEY) | BIT(EV_ABS);
+	dev->keybit[BIT_WORD(BTN_TOUCH)] |= BIT_MASK(BTN_TOUCH);
+	dev->absbit[0] = BIT(ABS_X) | BIT(ABS_Y) | BIT(ABS_PRESSURE);
+
+	/* value based on board measurement */
+	input_set_abs_params(dev, ABS_X,    X_MIN,     X_MAX, 0, 0);
+	input_set_abs_params(dev, ABS_Y,    Y_MIN,     Y_MAX, 0, 0);
+	input_set_abs_params(dev, ABS_PRESSURE, 0, MAX_10BIT, 0, 0);
+
+	init_timer(&ts->timer);
+	setup_timer(&ts->timer, da9052_timer_handler, (unsigned long)ts);
+
+	ts->dev = dev;
+	ts->down_irq = DA9052_TS_DOWN_IRQ;
+	ts->ready_irq = DA9052_TS_READY_IRQ;
+
+	pwc_reg_write(DA9052_TSICONTB_REG, 0x80);
+	da9052_ts_pwr_down(ts);
+
+	ret = request_irq(ts->ready_irq, da9052_irq_handler,
+			IRQF_DISABLED, DA9052_NAME, ts);
+	if (ret < 0) {
+		printk(KERN_INFO "%s: failed to register the irq (%d)\n",
+				DA9052_NAME, DA9052_TS_READY_IRQ);
+		goto err_ready_irq;
+	}
+	ret = request_irq(ts->down_irq, da9052_irq_handler,
+			IRQF_DISABLED, DA9052_NAME, ts);
+	if (ret < 0) {
+		printk(KERN_INFO "%s: failed to register the irq (%d)\n",
+				DA9052_NAME, DA9052_TS_READY_IRQ);
+		goto err_down_irq;
+	}
+
+	ret = input_register_device(dev);
+	if (ret != 0) {
+		printk(KERN_INFO "%s: error registering with input system\n",
+				DA9052_NAME);
+		goto err_register;
+	}
+
+	platform_set_drvdata(pdev, ts);
+
+	printk(KERN_INFO "%s: initialised\n", DA9052_NAME);
+
+	return 0;
+
+err_register:
+	free_irq(ts->down_irq, ts);
+err_down_irq:
+	free_irq(ts->ready_irq, ts);
+err_ready_irq:
+	input_free_device(dev);
+err_alloc_dev:
+	kfree(ts);
+
+	return ret;
+}
+
+static void __exit da9052_ts_remove(struct platform_device *pdev)
+{
+	struct da9052_ts *ts = platform_get_drvdata(pdev);
+
+	free_irq(ts->ready_irq, ts);
+	free_irq(ts->down_irq, ts);
+
+	input_unregister_device(ts->dev);
+	input_free_device(ts->dev);
+
+	kfree(ts);
+}
+
+static struct platform_driver da9052_ts_driver = {
+	.probe		= da9052_ts_probe,
+	.remove		= __exit_p(da9052_ts_remove),
+	.driver		= {
+		.name	= DA9052_NAME,
+		.owner	= THIS_MODULE,
+	},
+};
+
+static int __init da9052_ts_init(void)
+{
+	return platform_driver_register(&da9052_ts_driver);
+}
+
+static void __exit da9052_ts_exit(void)
+{
+	platform_driver_unregister(&da9052_ts_driver);
+}
+
+module_init(da9052_ts_init);
+module_exit(da9052_ts_exit);
+
+MODULE_AUTHOR("NECEL");
+MODULE_DESCRIPTION("Driver for the DS9052 Touch Screen Controller");
+MODULE_LICENSE("GPL");
+
-- 
1.6.5.2

