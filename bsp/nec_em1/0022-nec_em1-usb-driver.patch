From ad7119e55769119b39c4d262d2b4f914ae450126 Mon Sep 17 00:00:00 2001
From: Kazuya Tsukamoto <kazuya.tsukamoto@necel.com>
Date: Mon, 9 Nov 2009 14:02:41 +0900
Subject: [PATCH 22/29] nec_em1: usb driver

This drivers supports the SMSC USB332x. A wait was inserted at
initialize for USB PHY, since the ULPI had assumptions from
and old cord.

Signed-off-by: Kazuya Tsukamoto <kazuya.tsukamoto@necel.com>
---
 drivers/usb/Kconfig               |    1 +
 drivers/usb/core/Kconfig          |    1 -
 drivers/usb/gadget/Kconfig        |   13 +
 drivers/usb/gadget/Makefile       |    1 +
 drivers/usb/gadget/gadget_chips.h |   57 +-
 drivers/usb/gadget/mp200_udc.c    | 4470 +++++++++++++++++++++++++++++++++++++
 drivers/usb/gadget/mp200_udc.h    | 1255 +++++++++++
 drivers/usb/host/ehci-hcd.c       |  280 ++--
 drivers/usb/host/ehci-mp200.c     |  766 +++++++
 drivers/usb/host/ehci-mp200.h     |  920 ++++++++
 10 files changed, 7608 insertions(+), 156 deletions(-)
 create mode 100644 drivers/usb/gadget/mp200_udc.c
 create mode 100644 drivers/usb/gadget/mp200_udc.h
 create mode 100644 drivers/usb/host/ehci-mp200.c
 create mode 100644 drivers/usb/host/ehci-mp200.h

diff --git a/drivers/usb/Kconfig b/drivers/usb/Kconfig
index 3265afe..57ce198 100644
--- a/drivers/usb/Kconfig
+++ b/drivers/usb/Kconfig
@@ -56,6 +56,7 @@ config USB_ARCH_HAS_EHCI
 	default y if SOC_AU1200
 	default y if ARCH_IXP4XX
 	default y if ARCH_OMAP34XX
+	default y if ARCH_MP200
 	default PCI
 
 # ARM SA1111 chips have a non-PCI based "OHCI-compatible" USB host interface.
diff --git a/drivers/usb/core/Kconfig b/drivers/usb/core/Kconfig
index cc9f397..a8a2fa2 100644
--- a/drivers/usb/core/Kconfig
+++ b/drivers/usb/core/Kconfig
@@ -106,7 +106,6 @@ config USB_OTG
 	bool
 	depends on USB && EXPERIMENTAL
 	select USB_SUSPEND
-	default n
 
 
 config USB_OTG_WHITELIST
diff --git a/drivers/usb/gadget/Kconfig b/drivers/usb/gadget/Kconfig
index 222edf1..39a891e 100644
--- a/drivers/usb/gadget/Kconfig
+++ b/drivers/usb/gadget/Kconfig
@@ -94,6 +94,19 @@ choice
 	   Many controller drivers are platform-specific; these
 	   often need board-specific hooks.
 
+config USB_GADGET_MP200
+	boolean "MP200 USB Device Controller"
+	depends on ARCH_MP200
+	select USB_GADGET_DUALSPEED
+	help
+	   It is making it.
+
+config USB_MP200
+	tristate
+	depends on USB_GADGET_MP200
+	default USB_GADGET
+	select USB_GADGET_SELECTED
+
 config USB_GADGET_AMD5536UDC
 	boolean "AMD5536 UDC"
 	depends on PCI
diff --git a/drivers/usb/gadget/Makefile b/drivers/usb/gadget/Makefile
index fcb5cb9..1701a40 100644
--- a/drivers/usb/gadget/Makefile
+++ b/drivers/usb/gadget/Makefile
@@ -18,6 +18,7 @@ obj-$(CONFIG_USB_AT91)		+= at91_udc.o
 obj-$(CONFIG_USB_ATMEL_USBA)	+= atmel_usba_udc.o
 obj-$(CONFIG_USB_FSL_USB2)	+= fsl_usb2_udc.o
 obj-$(CONFIG_USB_M66592)	+= m66592-udc.o
+obj-$(CONFIG_USB_MP200)		+= mp200_udc.o
 
 #
 # USB gadget drivers
diff --git a/drivers/usb/gadget/gadget_chips.h b/drivers/usb/gadget/gadget_chips.h
index 17d9905..385b2a5 100644
--- a/drivers/usb/gadget/gadget_chips.h
+++ b/drivers/usb/gadget/gadget_chips.h
@@ -16,109 +16,109 @@
 #define __GADGET_CHIPS_H
 
 #ifdef CONFIG_USB_GADGET_NET2280
-#define	gadget_is_net2280(g)	!strcmp("net2280", (g)->name)
+#define	gadget_is_net2280(g)	(!strcmp("net2280", (g)->name))
 #else
 #define	gadget_is_net2280(g)	0
 #endif
 
 #ifdef CONFIG_USB_GADGET_AMD5536UDC
-#define	gadget_is_amd5536udc(g)	!strcmp("amd5536udc", (g)->name)
+#define	gadget_is_amd5536udc(g)	(!strcmp("amd5536udc", (g)->name))
 #else
 #define	gadget_is_amd5536udc(g)	0
 #endif
 
 #ifdef CONFIG_USB_GADGET_DUMMY_HCD
-#define	gadget_is_dummy(g)	!strcmp("dummy_udc", (g)->name)
+#define	gadget_is_dummy(g)	(!strcmp("dummy_udc", (g)->name))
 #else
 #define	gadget_is_dummy(g)	0
 #endif
 
 #ifdef CONFIG_USB_GADGET_PXA25X
-#define	gadget_is_pxa(g)	!strcmp("pxa25x_udc", (g)->name)
+#define	gadget_is_pxa(g)	(!strcmp("pxa25x_udc", (g)->name))
 #else
 #define	gadget_is_pxa(g)	0
 #endif
 
 #ifdef CONFIG_USB_GADGET_GOKU
-#define	gadget_is_goku(g)	!strcmp("goku_udc", (g)->name)
+#define	gadget_is_goku(g)	(!strcmp("goku_udc", (g)->name))
 #else
 #define	gadget_is_goku(g)	0
 #endif
 
 /* SH3 UDC -- not yet ported 2.4 --> 2.6 */
 #ifdef CONFIG_USB_GADGET_SUPERH
-#define	gadget_is_sh(g)		!strcmp("sh_udc", (g)->name)
+#define	gadget_is_sh(g)		(!strcmp("sh_udc", (g)->name))
 #else
 #define	gadget_is_sh(g)		0
 #endif
 
 /* not yet stable on 2.6 (would help "original Zaurus") */
 #ifdef CONFIG_USB_GADGET_SA1100
-#define	gadget_is_sa1100(g)	!strcmp("sa1100_udc", (g)->name)
+#define	gadget_is_sa1100(g)	(!strcmp("sa1100_udc", (g)->name))
 #else
 #define	gadget_is_sa1100(g)	0
 #endif
 
 #ifdef CONFIG_USB_GADGET_LH7A40X
-#define	gadget_is_lh7a40x(g)	!strcmp("lh7a40x_udc", (g)->name)
+#define	gadget_is_lh7a40x(g)	(!strcmp("lh7a40x_udc", (g)->name))
 #else
 #define	gadget_is_lh7a40x(g)	0
 #endif
 
 /* handhelds.org tree (?) */
 #ifdef CONFIG_USB_GADGET_MQ11XX
-#define	gadget_is_mq11xx(g)	!strcmp("mq11xx_udc", (g)->name)
+#define	gadget_is_mq11xx(g)	(!strcmp("mq11xx_udc", (g)->name))
 #else
 #define	gadget_is_mq11xx(g)	0
 #endif
 
 #ifdef CONFIG_USB_GADGET_OMAP
-#define	gadget_is_omap(g)	!strcmp("omap_udc", (g)->name)
+#define	gadget_is_omap(g)	(!strcmp("omap_udc", (g)->name))
 #else
 #define	gadget_is_omap(g)	0
 #endif
 
 /* not yet ported 2.4 --> 2.6 */
 #ifdef CONFIG_USB_GADGET_N9604
-#define	gadget_is_n9604(g)	!strcmp("n9604_udc", (g)->name)
+#define	gadget_is_n9604(g)	(!strcmp("n9604_udc", (g)->name))
 #else
 #define	gadget_is_n9604(g)	0
 #endif
 
 /* various unstable versions available */
 #ifdef CONFIG_USB_GADGET_PXA27X
-#define	gadget_is_pxa27x(g)	!strcmp("pxa27x_udc", (g)->name)
+#define	gadget_is_pxa27x(g)	(!strcmp("pxa27x_udc", (g)->name))
 #else
 #define	gadget_is_pxa27x(g)	0
 #endif
 
 #ifdef CONFIG_USB_GADGET_ATMEL_USBA
-#define gadget_is_atmel_usba(g)	!strcmp("atmel_usba_udc", (g)->name)
+#define gadget_is_atmel_usba(g)	(!strcmp("atmel_usba_udc", (g)->name))
 #else
 #define gadget_is_atmel_usba(g)	0
 #endif
 
 #ifdef CONFIG_USB_GADGET_S3C2410
-#define gadget_is_s3c2410(g)    !strcmp("s3c2410_udc", (g)->name)
+#define gadget_is_s3c2410(g)    (!strcmp("s3c2410_udc", (g)->name))
 #else
 #define gadget_is_s3c2410(g)    0
 #endif
 
 #ifdef CONFIG_USB_GADGET_AT91
-#define gadget_is_at91(g)	!strcmp("at91_udc", (g)->name)
+#define gadget_is_at91(g)	(!strcmp("at91_udc", (g)->name))
 #else
 #define gadget_is_at91(g)	0
 #endif
 
 /* status unclear */
 #ifdef CONFIG_USB_GADGET_IMX
-#define gadget_is_imx(g)	!strcmp("imx_udc", (g)->name)
+#define gadget_is_imx(g)	(!strcmp("imx_udc", (g)->name))
 #else
 #define gadget_is_imx(g)	0
 #endif
 
 #ifdef CONFIG_USB_GADGET_FSL_USB2
-#define gadget_is_fsl_usb2(g)	!strcmp("fsl-usb2-udc", (g)->name)
+#define gadget_is_fsl_usb2(g)	(!strcmp("fsl-usb2-udc", (g)->name))
 #else
 #define gadget_is_fsl_usb2(g)	0
 #endif
@@ -126,36 +126,43 @@
 /* Mentor high speed function controller */
 /* from Montavista kernel (?) */
 #ifdef CONFIG_USB_GADGET_MUSBHSFC
-#define gadget_is_musbhsfc(g)	!strcmp("musbhsfc_udc", (g)->name)
+#define gadget_is_musbhsfc(g)	(!strcmp("musbhsfc_udc", (g)->name))
 #else
 #define gadget_is_musbhsfc(g)	0
 #endif
 
 /* Mentor high speed "dual role" controller, in peripheral role */
 #ifdef CONFIG_USB_GADGET_MUSB_HDRC
-#define gadget_is_musbhdrc(g)	!strcmp("musb_hdrc", (g)->name)
+#define gadget_is_musbhdrc(g)	(!strcmp("musb_hdrc", (g)->name))
 #else
 #define gadget_is_musbhdrc(g)	0
 #endif
 
 /* from Montavista kernel (?) */
 #ifdef CONFIG_USB_GADGET_MPC8272
-#define gadget_is_mpc8272(g)	!strcmp("mpc8272_udc", (g)->name)
+#define gadget_is_mpc8272(g)	(!strcmp("mpc8272_udc", (g)->name))
 #else
 #define gadget_is_mpc8272(g)	0
 #endif
 
 #ifdef CONFIG_USB_GADGET_M66592
-#define	gadget_is_m66592(g)	!strcmp("m66592_udc", (g)->name)
+#define	gadget_is_m66592(g)	(!strcmp("m66592_udc", (g)->name))
 #else
 #define	gadget_is_m66592(g)	0
 #endif
 
+#ifdef CONFIG_USB_GADGET_MP200
+#define gadget_is_mp200(g)	(!strcmp("mp200_udc", (g)->name))
+#define MANY_ENDPOINTS
+#else
+#define gadget_is_mp200(g)	0
+#endif
 
-// CONFIG_USB_GADGET_SX2
-// CONFIG_USB_GADGET_AU1X00
-// ...
 
+/* CONFIG_USB_GADGET_SX2
+ * CONFIG_USB_GADGET_AU1X00
+ * ...
+ */
 
 /**
  * usb_gadget_controller_number - support bcdDevice id convention
@@ -216,6 +223,8 @@ static inline int usb_gadget_controller_number(struct usb_gadget *gadget)
 		return 0x20;
 	else if (gadget_is_m66592(gadget))
 		return 0x21;
+	else if (gadget_is_mp200(gadget))
+		return 0x22;
 	return -ENOENT;
 }
 
diff --git a/drivers/usb/gadget/mp200_udc.c b/drivers/usb/gadget/mp200_udc.c
new file mode 100644
index 0000000..6e0b83f
--- /dev/null
+++ b/drivers/usb/gadget/mp200_udc.c
@@ -0,0 +1,4470 @@
+/*
+ * mp200_udc.c -- for MP200 High speed USB device controller.
+ *	This driver doesn't support OTG.
+ *
+ *	Copyright (C) NEC Electronics Corporation 2008, 2009
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+
+/* #define UDC_FS */
+/* #define DUMMY_PRIME */
+/* #define DUMMY_PRIME_NOT_EP0 */
+/* #define DUMMY_PRIME_NAK_INT */
+/* #define DEBUG_COUNT */
+/* #define DEBUG_LOG */
+/* #define MEMORY_LOG */
+
+#undef	DEBUG
+#undef	VERBOSE
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/ioport.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/timer.h>
+#include <linux/list.h>
+#include <linux/interrupt.h>
+#include <linux/proc_fs.h>
+#include <linux/mm.h>
+#include <linux/moduleparam.h>
+#include <linux/device.h>
+#include <linux/usb/ch9.h>
+#include <linux/usb/gadget.h>
+#include <linux/usb/otg.h>
+#include <linux/dma-mapping.h>
+#include <linux/clk.h>
+#include <linux/seq_file.h>
+#include <linux/irq.h>
+#include <linux/platform_device.h>
+#include <linux/bitops.h>
+#include <linux/io.h>
+#include <linux/signal.h>
+
+/* #include <asm/errno.h> */
+/* #include <linux/errno.h>*/
+#include <mach/pmu.h>
+#include <mach/irqs.h>
+#include <mach/hardware.h>
+#include <mach/spi.h>
+#include <asm/irq.h>
+#include <mach/smu.h>
+#include <mach/pwc.h>
+#include <mach/gpio.h>
+#include <mach/pm.h>
+
+#include "mp200_udc.h"
+
+/* ISO too */
+#ifdef DUMMY_PRIME
+ #undef		USE_ISO
+#else /* DUMMY_PRIME */
+ #define	USE_ISO
+#endif /* DUMMY_PRIME */
+
+#define	DRIVER_DESC	"MP200 UDC driver"
+#define	DRIVER_VERSION	"20080526"
+
+#define	DMA_ADDR_INVALID	(~(dma_addr_t)0)
+
+static const char proc_filename[] = "driver/udc";
+static const char driver_name[] = "mp200_udc";
+static const char driver_desc[] = DRIVER_DESC;
+
+/* context */
+static struct mp200_udc g_udc = {{0} };
+
+/* prototype */
+static int
+ mp200_udcgad_get_frame(struct usb_gadget *pgadget);
+static int
+ mp200_udcgad_wakeup(struct usb_gadget *pgadget);
+static int
+ mp200_udcgad_set_selfpowered(struct usb_gadget *pgadget, int is_selfpowered);
+static int
+ mp200_udcgad_vbus_session(struct usb_gadget *pgadget, int is_active);
+static int
+ mp200_udcgad_vbus_draw(struct usb_gadget *pgadget, unsigned mA);
+static int
+ mp200_udcgad_pullup(struct usb_gadget *pgadget, int is_on);
+static int
+ mp200_udcgad_ioctl(struct usb_gadget *pgadget,
+			unsigned code, unsigned long param);
+
+static int
+ mp200_udcep_ep_enable(struct usb_ep *puep,
+			   const struct usb_endpoint_descriptor *pdesc);
+static int mp200st_udc_create_CBI_dTD(struct mp200_udc *pudc,
+			struct mp200_ep *pep,
+			struct mp200_req *preq,
+			T_MEMORY_VP_INFO *pdTD_mem,
+			u8 ep_adrs);
+static int mp200st_udc_create_ISO_dTD(struct mp200_udc *pudc,
+			struct mp200_ep *pep,
+			struct mp200_req *preq,
+			T_MEMORY_VP_INFO *pdTD_mem,
+			u8 ep_adrs);
+static int mp200st_udc_create_dTD(struct mp200_udc *pudc,
+			struct mp200_ep *pep,
+			struct mp200_req *preq,
+			T_MEMORY_VP_INFO *pdTD_mem,
+			u8 ep_adrs);
+static void
+ mp200st_udc_delete_dTD(struct mp200_udc *pudc, u8 ep_adrs);
+static void
+ mp200st_udc_cancel_dTD(struct mp200_udc *pudc, u8 ep_adrs);
+static int
+ mp200st_udc_link_dTD(struct mp200_udc *pudc,
+			  struct mp200_req *preq,
+			  T_MEMORY_VP_INFO *pdTD_mem,
+			  u8 ep_adrs);
+static int
+ mp200st_udc_unlink_dTD(struct mp200_udc *pudc, u8 ep_adrs);
+static int
+ mp200st_udc_done_transfer(struct mp200_udc *pudc, u8 ep_adrs);
+static int
+ mp200st_udc_set_start_dTD(struct mp200_udc *pudc,
+			   struct mp200_ep *pep,
+			   struct mp200_req *preq,
+			   u8 ep_adrs);
+static int
+ mp200st_udc_submit_dTD(struct mp200_udc *pudc, struct mp200_ep *pep);
+static int
+ mp200st_udc_abort_dTD(struct mp200_udc *pudc, u8 ep_adrs);
+static void
+ mp200st_udc_done_callback(struct mp200_udc *pudc,
+			   struct mp200_ep *pep,
+			   struct mp200_req *preq,
+			   int comp_status,
+			   bool bstart_next);
+static void
+ mp200st_udc_nuke(struct mp200_udc *pudc, struct mp200_ep *pep, int status);
+static void
+ mp200st_udc_quiesce(struct mp200_udc *pudc);
+static int
+ mp200_udcep_ep_disable(struct usb_ep *puep);
+static struct usb_request *
+ mp200_udcep_alloc_request(struct usb_ep *puep, gfp_t gfp_flags);
+static void
+ mp200_udcep_free_request(struct usb_ep *puep, struct usb_request *pureq);
+static int
+ mp200st_udc_list_add_and_submit_dTD(struct mp200_udc *pudc,
+					 struct mp200_ep *pep,
+					 struct mp200_req *preq);
+static int
+ mp200_udcep_ep_queue(struct usb_ep *puep,
+			  struct usb_request *pureq,
+			  gfp_t gfp_flags);
+static int
+ mp200_udcep_ep_dequeue(struct usb_ep *puep, struct usb_request *pureq);
+static int
+ mp200_udcep_ep_set_halt(struct usb_ep *puep, int bstall);
+static int
+ mp200st_udc_get_ep_req_actual_length(struct mp200_udc *pudc,
+					u8 ep_adrs,
+					u32 use_flag,
+					struct mp200_ep **pep_ret,
+					struct mp200_req **preq_ret);
+static int
+ mp200_udcep_fifo_status(struct usb_ep *puep);
+static void
+ mp200_udcep_fifo_flush(struct usb_ep *puep);
+
+static int
+ mp200st_udcprc_proc_udc_show(struct seq_file *s, void *pram);
+static int
+ mp200_udcprc_proc_udc_open(struct inode *inode, struct file *file);
+#ifdef DEBUG
+static ssize_t mp200_udcprc_proc_udc_write(struct file *fd,
+	const char __user *buf, size_t len, loff_t *ptr);
+#endif /* DEBUG */
+static T_ENDPOINT_QUEUE_HEAD *mp200st_udc_ep_get_dQH_adrs(
+	struct mp200_udc *pudc,
+	u8 ep_adrs,
+	bool bphy);
+static bool mp200st_udc_get_endpoint_stall(
+	struct mp200_udc *pudc,
+	u8 ep_adrs);
+static void mp200st_udc_set_endpoint_stall(
+	struct mp200_udc *pudc,
+	u8 ep_adrs,
+	bool bstall);
+static void mp200st_udcint_EP0_complete(
+	struct usb_ep *puep,
+	struct usb_request *pureq);
+static irqreturn_t mp200_udcint_irq(int irq, void *id_udc);
+static irqreturn_t mp200_udcint_vbus_irq(int irq, void *id_udc);
+static int __init mp200_udcdev_probe(struct platform_device *pdev);
+static void mp200_udcgaddev_release(struct device *pgaddev);
+static int __exit mp200_udcdev_remove(struct platform_device *pdev);
+static int mp200_udcdev_suspend(
+	struct platform_device *pdev,
+	pm_message_t message);
+static int mp200_udcdev_resume(struct platform_device *pdev);
+static int __init mp200_udc_init(void);
+static void __exit mp200_udc_exit(void);
+
+static void mp200st_udc_set_ep_ctrlreg(
+	struct mp200_udc *pudc,
+	u8 ep_adrs,
+	u8 bm_attributes
+	);
+
+/* inline */
+
+/*-------------------------------------------------------------------------*/
+static inline int mp200st_udcint_data_packet(
+	struct mp200_udc *pudc,
+	void *pbuf,
+	unsigned length,
+	dma_addr_t dma)
+{
+	memset(&pudc->ep0_req, 0, sizeof(struct mp200_req));
+	pudc->ep0_req.req.buf		= pbuf;
+	pudc->ep0_req.req.length	= length;
+	pudc->ep0_req.req.dma		= dma;
+	pudc->ep0_req.req.zero		= TRUE;
+	pudc->ep0_req.req.complete	= mp200st_udcint_EP0_complete;
+	pudc->ep0_req.req.status	= -EINPROGRESS;
+	mp200st_udc_list_add_and_submit_dTD(pudc, &pudc->ep[0], &pudc->ep0_req);
+
+	return 0;
+}
+
+/*-------------------------------------------------------------------------*/
+static inline int mp200st_udc_ep_clear_dQH(
+	struct mp200_udc *pudc,
+	u8 ep_adrs)
+{
+	T_ENDPOINT_QUEUE_HEAD	*p_ep_dQH;
+
+	p_ep_dQH = mp200st_udc_ep_get_dQH_adrs(pudc, ep_adrs, FALSE);
+
+	/* clear */
+	memset(p_ep_dQH, 0, sizeof(T_ENDPOINT_QUEUE_HEAD));
+
+	return 0;
+}
+
+/*-------------------------------------------------------------------------*/
+static inline void mp200st_udc_clear_EP0(struct mp200_udc *pudc)
+{
+	/* EP0 out(setup) */
+	mp200st_udc_ep_clear_dQH(pudc, (0 | USB_DIR_OUT));
+
+	/* EP0 in */
+	mp200st_udc_ep_clear_dQH(pudc, (0 | USB_DIR_IN));
+
+	return;
+}
+
+/*-------------------------------------------------------------------------*/
+static inline void mp200st_udc_pullup_enable(struct mp200_udc *pudc)
+{
+	mp200st_udc_set_bit(&pudc->pfc_reg->USBCMD, USBCMD_RS);
+	return;
+}
+
+/*-------------------------------------------------------------------------*/
+static inline void mp200st_udc_pullup_disable(struct mp200_udc *pudc)
+{
+	mp200st_udc_clear_bit(&pudc->pfc_reg->USBCMD, USBCMD_RS);
+	return;
+}
+
+/*-------------------------------------------------------------------------*/
+static inline void mp200st_udc_interrupt_enable(struct mp200_udc *pudc)
+{
+#ifdef UDC_FS
+	/* USB1.1(FS) */
+	mp200st_udc_ulc_chk_set_bit(pudc, &pudc->pfc_reg->PORTSC[0],
+		PORTSC_PFSC);
+#endif /* UDC_FS */
+
+#ifdef DUMMY_PRIME
+ #ifdef DUMMY_PRIME_NAK_INT
+	mp200st_udc_writel(&pudc->pfc_reg->USBINTR,
+		USB_FC_INT_ENABLE | USBINTR_NAKE);
+ #else /* DUMMY_PRIME_NAK_INT */
+	mp200st_udc_writel(&pudc->potg_reg->GPTIMER0LD, 374);
+	mp200st_udc_writel(&pudc->potg_reg->GPTIMER0CTRL, 0xc1000000);
+	mp200st_udc_writel(&pudc->pfc_reg->USBINTR,
+		USB_FC_INT_ENABLE | USBINTR_TIE0);
+ #endif /* DUMMY_PRIME_NAK_INT */
+#else /* DUMMY_PRIME */
+	mp200st_udc_writel(&pudc->pfc_reg->USBINTR, USB_FC_INT_ENABLE);
+#endif /* DUMMY_PRIME */
+	return;
+}
+
+/*-------------------------------------------------------------------------*/
+static inline void mp200st_udc_interrupt_disable(struct mp200_udc *pudc)
+{
+	mp200st_udc_writel(&pudc->pfc_reg->USBINTR, 0);
+	return;
+}
+
+/*-------------------------------------------------------------------------*/
+static inline void mp200st_udc_reset(struct mp200_udc *pudc)
+{
+	/* --------------------------------------------------------------- */
+	/*  Link disable */
+	mp200_pmu_reset_device(MP200_RESETDEVICE_USB);		/*  Reset ON */
+	mp200_pmu_close_clockgate(MP200_CLOCKGATE_USB_CLK);	/*  CLK OFF */
+
+	/* --------------------------------------------------------------- */
+	/*  PHY disable */
+	if (system_rev & 0x40)
+		gpio_direction_output(UDC_PHY_CS, 0);	/*  RESETB */
+	else
+		gpio_direction_output(UDC_PHY_CS, 1);	/*  CS */
+#ifndef	CONFIG_MP200_EM1_DKIT
+	pwc_write(PWC_PSCNT1, 0, PHY_POWER_BIT);	/*  Power OFF */
+#endif
+
+/* --------------------------------------------------------------- */
+/* 	clock auto change(resume status) */
+/* 	outl(pudc->clk_reg, SMU_AUTO_FRQ_CHANGE); */
+
+	return;
+}
+
+/*-------------------------------------------------------------------------*/
+static inline void mp200st_udc_unreset(struct mp200_udc *pudc)
+{
+	int	status;
+
+/* --------------------------------------------------------------- */
+/* clock auto change OFF */
+/* 	pudc->clk_reg = inl(SMU_AUTO_FRQ_CHANGE); */
+/* 	outl(pudc->clk_reg & 0xFFFFFFFE, SMU_AUTO_FRQ_CHANGE); */
+
+	/* --------------------------------------------------------------- */
+	/*  PHY */
+#ifndef	CONFIG_MP200_EM1_DKIT
+	pwc_write(PWC_PSCNT1, PHY_POWER_BIT, PHY_POWER_BIT);	/*  Power ON */
+#endif
+	if (system_rev & 0x40)
+		gpio_direction_output(UDC_PHY_CS, 1);	/*  RESETB */
+	else
+		gpio_direction_output(UDC_PHY_CS, 0);	/*  CS */
+
+	mdelay(UDC_PHY_CS_MDELAY);
+
+	/* --------------------------------------------------------------- */
+	/*  Link */
+	/*  CLK ON */
+	status = mp200_pmu_open_clockgate(MP200_CLOCKGATE_USB_CLK);
+	if (status < 0)
+		DBG("mp200_pmu_open_clockgate ERR\n");
+
+	/*  Reset OFF */
+	status = mp200_pmu_unreset_device(MP200_RESETDEVICE_USB);
+	if (status < 0)
+		DBG("mp200_pmu_unreset_device ERR\n");
+
+	mdelay(UDC_LINK_UNRESET_MDELAY);
+
+	/* --------------------------------------------------------------- */
+	/*  Link */
+	/* 	 Setting for Device(Function) */
+	mp200st_udc_set_bit(&pudc->pfc_reg->USBMODE,
+		UDBMODE_CM_FC | USBMODE_SLOM);
+	mp200st_udc_mask_set_bit(&pudc->pfc_reg->USBCMD, USBCMD_ITC,
+		USBCMD_ITC_01);	/* 1 uFrame interrupt */
+
+	status = mp200st_udc_ulc_chk_writel(pudc,
+			&pudc->pfc_reg->ENDPOINTLISTADDR,
+			(u32)pudc->dQH.padrs);
+	if (status < 0)
+		DBG("mp200st_udc_ulc_chk_writel ERR\n");
+
+	/* VbusValid Rise INT Disable */
+	mp200st_udc_ulpi_write(pudc, 0x0F, BIT01);
+	/* VbusValid Fall INT Disable */
+	mp200st_udc_ulpi_write(pudc, 0x12, BIT01);
+
+	return;
+}
+
+/*-------------------------------------------------------------------------*/
+static inline int mp200st_udc_ep_set_dQH(
+	struct mp200_udc *pudc,
+	u8 ep_adrs,
+	u8 bm_attributes,
+	u16 w_max_packet_size)
+{
+	T_ENDPOINT_QUEUE_HEAD	*p_ep_dQH;
+
+	p_ep_dQH = mp200st_udc_ep_get_dQH_adrs(pudc, ep_adrs, FALSE);
+
+	/* clear */
+	p_ep_dQH->max_length = 0;
+
+	/*	no zero length */
+	p_ep_dQH->max_length |= EQH_ZLT;
+
+	/*	max data */
+	p_ep_dQH->max_length |= ((w_max_packet_size
+	 & USB_ENDPOINT_MPS_SIZE_MASK) << EQH_MPLENGTH_BIT_POS);
+
+#ifdef USE_ISO
+	/*	Multi */
+	if ((bm_attributes & USB_ENDPOINT_XFERTYPE_MASK)
+	 == USB_ENDPOINT_XFER_ISOC) {
+		switch (w_max_packet_size & USB_ENDPOINT_MPS_MULTI_MASK) {
+		case USB_ENDPOINT_MPS_MULTI_NONE:
+			p_ep_dQH->max_length |= EQH_MPS_ISO_MULTI_NONE;
+			break;
+
+		case USB_ENDPOINT_MPS_MULTI_1ADD:
+			p_ep_dQH->max_length |= EQH_MPS_ISO_MULTI_1ADD;
+			break;
+
+		case USB_ENDPOINT_MPS_MULTI_2ADD:
+			p_ep_dQH->max_length |= EQH_MPS_ISO_MULTI_2ADD;
+			break;
+
+		default:
+			ERR("Isochronous MULTI error\n");
+			p_ep_dQH->max_length = 0;
+			return -EINVAL;
+		}
+	}
+#endif /* USE_ISO */
+
+	/*	SETUP */
+	if ((bm_attributes & USB_ENDPOINT_XFERTYPE_MASK)
+	 == USB_ENDPOINT_XFER_CONTROL)
+		p_ep_dQH->max_length |= EQH_SETUP_INT;
+
+	return 0;
+}
+
+/*-------------------------------------------------------------------------*/
+static inline void mp200st_udc_set_EP0(struct mp200_udc *pudc)
+{
+
+	/* EP0 out(setup) */
+	mp200st_udc_ep_set_dQH(pudc, (0 | USB_DIR_OUT),
+		USB_ENDPOINT_XFER_CONTROL, UDC_EP0_MAXPACKETSIZE);
+
+	/* EP0 in */
+	mp200st_udc_ep_set_dQH(pudc, (0 | USB_DIR_IN),
+		USB_ENDPOINT_XFER_CONTROL, UDC_EP0_MAXPACKETSIZE);
+	return;
+}
+
+/*-------------------------------------------------------------------------*/
+static inline int __init mp200st_udcdev_dtd_dqh_mem_init(
+	struct mp200_udc *pudc,
+	struct platform_device *pdev,
+	T_MEMORY_VP_INFO *p_align_mem,
+	T_MEMORY_VP_INFO *p_mem,
+	size_t alloc_mem_size,
+	size_t align_size)
+{
+	u32		mem_alignment;
+
+	/* allocate DMA memory */
+	p_align_mem->p_vadrs = dma_alloc_coherent(&pdev->dev,
+						  alloc_mem_size,
+						  &p_align_mem->padrs,
+						  GFP_KERNEL|__GFP_DMA);
+
+	/* check allocate ERROR */
+	if (p_align_mem->p_vadrs == NULL)
+		return -ENOMEM;
+
+	MEM_LOG(pudc, "%s dma_alloc_coherent(%08x)\n", __func__,
+		(int)p_align_mem->p_vadrs);
+
+	/* check memory alignment */
+	mem_alignment = (u32)p_align_mem->padrs & (align_size - 1);
+	if (mem_alignment > 0) {
+		/* shift phy address */
+		p_mem->padrs = p_align_mem->padrs
+			+ (align_size - mem_alignment);
+		/* shift virtual address */
+		p_mem->p_vadrs = (u32 *)(((u8 *)p_align_mem->p_vadrs)
+			+ (align_size - mem_alignment));
+	} else{
+		/* no shift address (struct copy) */
+		memcpy(p_mem, p_align_mem, sizeof(T_MEMORY_VP_INFO));
+	}
+
+	/* clear DMA memory */
+	memset(p_mem->p_vadrs , 0, (alloc_mem_size - align_size));
+
+	return 0;
+}
+
+/*-------------------------------------------------------------------------*/
+static inline bool mp200st_udc_can_pullup(struct mp200_udc *pudc)
+{
+	if ((pudc->pdriver != NULL) && pudc->softconnect
+		&& pudc->vbus_active && (pudc->linux_suspended == 0)) {
+		return TRUE;
+	} else {
+		return FALSE;
+	}
+}
+
+/*-------------------------------------------------------------------------*/
+static inline void mp200st_udc_device_start(struct mp200_udc *pudc)
+{
+	if (mp200st_udc_can_pullup(pudc)) {
+		mp200st_udc_set_EP0(pudc);
+		mp200st_udc_unreset(pudc);
+		mp200st_udc_interrupt_enable(pudc);
+		mp200st_udc_pullup_enable(pudc);
+	}
+
+	return;
+}
+
+/*-------------------------------------------------------------------------*/
+static inline void mp200st_udc_device_stop(struct mp200_udc *pudc)
+{
+#ifdef DUMMY_PRIME
+	pudc->dummy_prime_transferring = 0;
+	pudc->dummy_prime_waiting = 0;
+#endif /* DUMMY_PRIME */
+
+	mp200st_udc_pullup_disable(pudc);
+	mp200st_udc_interrupt_disable(pudc);
+	mp200st_udc_reset(pudc);
+	mp200st_udc_clear_EP0(pudc);
+
+	/* clear devstate */
+	pudc->devstate		= USB_STATE_NOTATTACHED;
+
+	return;
+}
+
+/*-------------------------------------------------------------------------*/
+static inline void mp200st_udcint_req_feature_complete(struct mp200_udc *pudc,
+	bool bset)
+{
+	u32	data;
+
+	if ((pudc->ctrl.bRequestType & USB_RECIP_MASK) == USB_RECIP_DEVICE) {
+
+		switch (le16_to_cpu(pudc->ctrl.wValue)) {
+		case USB_DEVICE_TEST_MODE:
+			if (bset) {
+				data = ((le16_to_cpu(pudc->ctrl.wIndex)) << 8)
+				 & PORTSC_PTC;
+				mp200st_udc_ulc_chk_set_bit(pudc,
+					&pudc->pfc_reg->PORTSC[0], data);
+			}
+			break;
+		default:
+			break;
+		}
+	}
+
+	return ;
+}
+
+/*-------------------------------------------------------------------------*/
+static inline int mp200st_udcint_status_packet(struct mp200_udc *pudc)
+{
+	return mp200st_udcint_data_packet(pudc, NULL, 0, DMA_ADDR_INVALID);
+}
+
+/*-------------------------------------------------------------------------*/
+static inline enum usb_device_speed mp200st_udcint_get_speed(
+	struct mp200_udc *pudc)
+{
+	enum usb_device_speed speed;
+
+	switch (mp200st_udc_readl(&pudc->pfc_reg->PORTSC[0]) & PORTSC_PSPD) {
+	case PORTSC_PSPD_FS:
+		speed = USB_SPEED_FULL;
+		break;
+
+	case PORTSC_PSPD_LS:
+		speed = USB_SPEED_LOW;
+		break;
+
+	case PORTSC_PSPD_HS:
+		speed = USB_SPEED_HIGH;
+		break;
+
+	default:
+		speed = USB_SPEED_UNKNOWN;
+		ERR("PORTSC speed ERR\n");
+		break;
+	}
+
+	return speed;
+}
+
+/*-------------------------------------------------------------------------*/
+static inline void mp200st_udc_soft_connect_change(
+	struct mp200_udc *pudc, bool is_on)
+{
+	/* Already status change */
+	if ((!pudc->softconnect) == (!is_on)) {
+		DBG("%s  Already status change\n", __func__);
+		return;
+	}
+
+	pudc->usb_suspended = 0;
+	if (is_on) {
+		/* soft connect */
+		pudc->softconnect = 1;
+
+		mp200st_udc_device_start(pudc);
+	} else{
+		/* soft disconnect */
+		pudc->softconnect = 0;
+
+		/* callback */
+		if ((pudc->linux_suspended == 0) && pudc->vbus_active
+				&& (pudc->pdriver->disconnect != NULL)) {
+			spin_unlock(&pudc->lock);
+			pudc->pdriver->disconnect(&pudc->gadget);
+			spin_lock(&pudc->lock);
+		}
+
+		mp200st_udc_quiesce(pudc);
+		mp200st_udc_device_stop(pudc);
+	}
+
+	return;
+}
+
+/*-------------------------------------------------------------------------*/
+static inline void mp200st_udc_vbus_change(
+	struct mp200_udc *pudc,
+	bool bvbus_on)
+{
+	/* Already status change */
+	if ((!pudc->vbus_active) == (!bvbus_on)) {
+		DBG("%s  Already status change\n", __func__);
+		if (pudc->linux_resume) {
+			pudc->linux_resume = 0;
+			mp200st_udc_device_start(pudc);
+		}
+		return;
+	}
+
+	pudc->usb_suspended		= 0;
+	if (bvbus_on) {
+		/* vbus active */
+		mdelay(VBUS_CHATTERING_RETRY_MDELAY);	/*  ULPI Wait */
+		pudc->vbus_active = 1;
+		pudc->devstate = USB_STATE_POWERED;
+		mp200st_udc_device_start(pudc);
+	} else{
+		/* vbus inactive */
+		pudc->vbus_active = 0;
+		pudc->devstate = USB_STATE_ATTACHED;
+		pudc->remote_wakeup = 0;
+
+		/* callback */
+		if ((pudc->linux_suspended == 0) && (pudc->softconnect != 0)) {
+			spin_unlock(&pudc->lock);
+			if (pudc->pdriver->disconnect != NULL)
+				pudc->pdriver->disconnect(&pudc->gadget);
+
+			spin_lock(&pudc->lock);
+		}
+
+		mp200st_udc_quiesce(pudc);
+		mp200st_udc_device_stop(pudc);
+	}
+
+	return;
+}
+
+#ifdef DUMMY_PRIME
+/*-------------------------------------------------------------------------*/
+static inline void mp200st_udc_set_dmy_prime_transferring(
+	struct mp200_udc *pudc,
+	u32 bit_pos)
+{
+ #ifdef DEBUG
+	if (!(pudc->dummy_prime_waiting & bit_pos))
+		DBG("%s pit_pos(%08x) dummy_prime_waiting(%08x) bug.\n",
+			__func__, bit_pos, pudc->dummy_prime_waiting);
+ #endif /* DEBUG */
+
+	/* set */
+	pudc->dummy_prime_transferring |= bit_pos;
+	pudc->dummy_prime_waiting &= ~(bit_pos);
+
+ #if !defined(DUMMY_PRIME_NOT_EP0)
+	/* EP0 && SETUP Receiving */
+	if (bit_pos & (ENDPT_BIT_POS(0 | USB_DIR_IN)
+	    | ENDPT_BIT_POS(0 | USB_DIR_OUT))) {
+		if (mp200st_udc_readl(&pudc->pfc_reg->ENDPTSETUPSTAT)
+		    & ENDPTSETUPSTAT_ENDPTSETUPSTAT_EP0) {
+			DBG("%s Receiving ENDPTSETUPSTAT_EP0 (3)(%08x)\n",
+				__func__, bit_pos);
+			return;
+		}
+	}
+ #endif /* !defined(DUMMY_PRIME_NOT_EP0) */
+	/* prime */
+	mp200st_udc_writel(&pudc->pfc_reg->ENDPTPRIME,
+		pudc->dummy_prime_transferring);
+	DBG_LOG(pudc, "PRIME5(%08x)\n", pudc->dummy_prime_transferring);
+
+	return;
+}
+#endif /* DUMMY_PRIME */
+
+#ifdef DUMMY_PRIME
+/*-------------------------------------------------------------------------*/
+static inline void mp200st_udc_set_dummy_prime_waiting(
+	struct mp200_udc *pudc,
+	u32 bit_pos)
+{
+	pudc->dummy_prime_waiting |= bit_pos;
+ #ifdef DUMMY_PRIME_NAK_INT
+	if (pudc->dummy_prime_transferring == 0) {
+		mp200st_udc_ulc_chk_writel(pudc, &pudc->pfc_reg->ENDPTNAK,
+			bit_pos);
+		mp200st_udc_ulc_chk_set_bit(pudc, &pudc->pfc_reg->ENDPTNAKEN,
+			bit_pos);
+	}
+ #endif /* DUMMY_PRIME_NAK_INT */
+
+	return;
+}
+#endif /* DUMMY_PRIME */
+
+/* function */
+
+/*-------------------------------------------------------------------------*/
+static struct usb_gadget_ops mp200_gadget_ops = {
+	.get_frame		= mp200_udcgad_get_frame,
+	.wakeup			= mp200_udcgad_wakeup,
+	.set_selfpowered	= mp200_udcgad_set_selfpowered,
+	.vbus_session		= mp200_udcgad_vbus_session,
+	.vbus_draw		= mp200_udcgad_vbus_draw,
+	.pullup			= mp200_udcgad_pullup,
+	.ioctl			= mp200_udcgad_ioctl,
+};
+
+/*-------------------------------------------------------------------------*/
+static inline void mp200st_udc_linux_suspended_change(
+	struct mp200_udc *pudc,
+	bool is_suspended)
+{
+	/* Already status change */
+	if ((!pudc->linux_suspended) == (!is_suspended)) {
+		DBG("%s  Already status change\n", __func__);
+		return;
+	}
+
+	pudc->usb_suspended		= 0;
+	if (is_suspended == FALSE) {
+		/* resume */
+		pudc->linux_suspended = 0;
+		mp200st_udc_device_start(pudc);
+	} else{
+		/* suspend */
+		pudc->linux_suspended = 1;
+
+		/* callback */
+		if (pudc->softconnect && pudc->vbus_active
+				&& (pudc->pdriver->disconnect != NULL)) {
+			spin_unlock(&pudc->lock);
+			pudc->pdriver->disconnect(&pudc->gadget);
+			spin_lock(&pudc->lock);
+		}
+
+		mp200st_udc_quiesce(pudc);
+		mp200st_udc_device_stop(pudc);
+	}
+
+	return;
+}
+
+/*-------------------------------------------------------------------------*/
+static int
+ mp200_udcgad_get_frame(struct usb_gadget *pgadget)
+{
+	struct mp200_udc	*pudc;
+
+	if (pgadget == NULL) {
+		ERR("%s, bad param\n", __func__);
+		return -EINVAL;
+	}
+
+	pudc = container_of(pgadget, struct mp200_udc, gadget);
+
+	return (int)(mp200st_udc_readl(&pudc->pfc_reg->FRINDEX)
+	 & FRINDEX_FRINDEX);
+}
+
+/*-------------------------------------------------------------------------*/
+static int
+ mp200_udcgad_wakeup(struct usb_gadget *pgadget)
+{
+	struct mp200_udc	*pudc;
+	unsigned long		flags;
+	u32			data;
+	int			status = -EHOSTUNREACH;
+
+	if (pgadget == NULL) {
+		ERR("%s, bad param\n", __func__);
+		return -EINVAL;
+	}
+
+	pudc = container_of(pgadget, struct mp200_udc, gadget);
+
+	spin_lock_irqsave(&pudc->lock, flags);
+
+	if (!pudc->remote_wakeup) {
+		DBG("%s fail(EHOSTUNREACH)", __func__);
+		spin_unlock_irqrestore(&pudc->lock, flags);
+		return status;
+	}
+
+	/* check suspend */
+	data = mp200st_udc_readl(&pudc->pfc_reg->PORTSC[0]) & PORTSC_SUSP;
+	if (data != 0) {
+		/* remote wakeup */
+		mp200st_udc_set_bit(&pudc->pfc_reg->PORTSC[0], PORTSC_FPR);
+		status = 0;
+	}
+
+	spin_unlock_irqrestore(&pudc->lock, flags);
+
+	return status;
+}
+
+/*-------------------------------------------------------------------------*/
+static int mp200_udcgad_set_selfpowered(
+	struct usb_gadget *pgadget,
+	int is_selfpowered)
+{
+	struct mp200_udc	*pudc;
+	unsigned long		flags;
+
+	if (pgadget == NULL) {
+		ERR("%s, bad param\n", __func__);
+		return -EINVAL;
+	}
+
+	pudc = container_of(pgadget, struct mp200_udc, gadget);
+
+	spin_lock_irqsave(&pudc->lock, flags);
+	pudc->self_powered = (is_selfpowered != 0);
+	spin_unlock_irqrestore(&pudc->lock, flags);
+
+	return 0;
+}
+
+/*-------------------------------------------------------------------------*/
+/*
+ * Called by whatever detects VBUS sessions:  external transceiver
+ * driver, or maybe GPIO0 VBUS IRQ.  May request 48 MHz clock.
+ */
+static int mp200_udcgad_vbus_session(struct usb_gadget *pgadget, int is_active)
+{
+	struct mp200_udc	*pudc;
+	unsigned long		flags;
+
+	if (pgadget == NULL) {
+		ERR("%s, bad param\n", __func__);
+		return -EINVAL;
+	}
+
+	pudc = container_of(pgadget, struct mp200_udc, gadget);
+
+	spin_lock_irqsave(&pudc->lock, flags);
+	mp200st_udc_vbus_change(pudc, (bool)is_active);
+	spin_unlock_irqrestore(&pudc->lock, flags);
+
+	return 0;
+}
+
+/*-------------------------------------------------------------------------*/
+static int
+ mp200_udcgad_vbus_draw(struct usb_gadget *pgadget, unsigned mA)
+{
+	struct mp200_udc	*pudc;
+	unsigned long		flags;
+
+	if (pgadget == NULL) {
+		ERR("%s, bad param\n", __func__);
+		return -EINVAL;
+	}
+
+	pudc = container_of(pgadget, struct mp200_udc, gadget);
+
+	spin_lock_irqsave(&pudc->lock, flags);
+	pudc->mA = mA;
+	spin_unlock_irqrestore(&pudc->lock, flags);
+
+	return 0;
+}
+
+/*-------------------------------------------------------------------------*/
+static int mp200_udcgad_ioctl(
+	struct usb_gadget *pgadget,
+	unsigned code,
+	unsigned long param)
+{
+	if (pgadget == NULL) {
+		ERR("%s, bad param\n", __func__);
+		return -EINVAL;
+	}
+
+	return -EOPNOTSUPP;
+}
+
+/*-------------------------------------------------------------------------*/
+static int mp200_udcgad_pullup(struct usb_gadget *pgadget, int is_on)
+{
+	struct mp200_udc	*pudc;
+	unsigned long		flags;
+
+	if (pgadget == NULL) {
+		ERR("%s, bad param\n", __func__);
+		return -EINVAL;
+	}
+
+	pudc = container_of(pgadget, struct mp200_udc, gadget);
+
+	spin_lock_irqsave(&pudc->lock, flags);
+	mp200st_udc_soft_connect_change(pudc, (bool)is_on);
+	spin_unlock_irqrestore(&pudc->lock, flags);
+
+	return 0;
+}
+
+/*-------------------------------------------------------------------------*/
+
+static struct usb_ep_ops mp200_ep_ops = {
+	.enable		= mp200_udcep_ep_enable,
+	.disable	= mp200_udcep_ep_disable,
+
+	.alloc_request	= mp200_udcep_alloc_request,
+	.free_request	= mp200_udcep_free_request,
+
+	.queue		= mp200_udcep_ep_queue,
+	.dequeue	= mp200_udcep_ep_dequeue,
+
+	.set_halt	= mp200_udcep_ep_set_halt,
+	.fifo_status	= mp200_udcep_fifo_status,
+	.fifo_flush	= mp200_udcep_fifo_flush,
+};
+
+/*-------------------------------------------------------------------------*/
+static int mp200_udcep_ep_enable(
+	struct usb_ep *puep,
+	const struct usb_endpoint_descriptor *pdesc)
+{
+	struct mp200_ep		*pep;
+	struct mp200_udc	*pudc;
+	unsigned long		flags;
+	int			status;
+
+	/* catch various bogus parameters */
+	if ((puep == NULL) || (pdesc == NULL)) {
+		ERR("%s, bad param\n", __func__);
+		return -EINVAL;
+	}
+
+	pep = container_of(puep, struct mp200_ep, ep);
+
+	/* udc */
+	pudc = pep->pudc;
+
+	spin_lock_irqsave(&pudc->lock, flags);
+
+	if ((pep == &pudc->ep[0])
+	   || (pep->pdesc != NULL)
+	   || (pdesc->bDescriptorType != USB_DT_ENDPOINT)) {
+
+		DBG("%s descriptor(EINVAL)", __func__);
+		spin_unlock_irqrestore(&pudc->lock, flags);
+		return -EINVAL;
+	}
+
+	/* connect */
+	if ((pudc->pdriver == NULL)
+	   || (pudc->gadget.speed == USB_SPEED_UNKNOWN)) {
+
+		DBG("%s, bogus device state\n", __func__);
+		spin_unlock_irqrestore(&pudc->lock, flags);
+		return -ESHUTDOWN;
+	}
+
+	/* check */
+#if defined(DUMMY_PRIME) || !defined(USE_ISO)
+	if ((pdesc->bmAttributes | USB_ENDPOINT_XFERTYPE_MASK)
+	 == USB_ENDPOINT_XFER_ISOC) {
+		DBG("%s, not Support Isochronous\n", __func__);
+		spin_unlock_irqrestore(&pudc->lock, flags);
+		return -EINVAL;
+	}
+#endif /* defined(DUMMY_PRIME) || !defined(USE_ISO) */
+#ifdef USB_TRANS_DIVISION
+	if (pdesc->wMaxPacketSize > USB_DIVISION_SIZE) {
+		DBG("%s, USB_TRANS_DIVISION not Support wMaxPacketSize"
+		" > 512\n", __func__);
+		spin_unlock_irqrestore(&pudc->lock, flags);
+		return -EINVAL;
+	}
+#endif /* USB_TRANS_DIVISION */
+
+	pep->pdesc = pdesc;
+
+	/* set endpoint to initial state */
+
+	status = mp200st_udc_ep_set_dQH(pudc,
+					pdesc->bEndpointAddress,
+					pdesc->bmAttributes,
+					le16_to_cpu(pdesc->wMaxPacketSize));
+
+	if (status < 0) {
+		DBG("%s, bogus dQH\n", __func__);
+		spin_unlock_irqrestore(&pudc->lock, flags);
+		return status;
+	}
+
+	mp200st_udc_set_ep_ctrlreg(pudc,
+				   pdesc->bEndpointAddress,
+				   pdesc->bmAttributes);
+
+
+
+	/* IO<->DMA memory alloc */
+	if (pep->mem.p_vadrs == NULL) {
+		VDBG("%s auto DMA allocate\n", __func__);
+		pep->mem.p_vadrs = dma_alloc_coherent(&pudc->pdev->dev,
+			UDC_EP_AUTO_BUFSIZE, &pep->mem.padrs,
+			GFP_ATOMIC|__GFP_DMA);
+
+		if (pep->mem.p_vadrs == NULL) {
+			ERR("%s dma_alloc_coherent NOMEM)\n", __func__);
+			spin_unlock_irqrestore(&pudc->lock, flags);
+			return -ENOMEM;
+		}
+		MEM_LOG(pudc, "%s dma_alloc_coherent(%08x)\n", __func__,
+			(int)pep->mem.p_vadrs);
+	} else{
+		VDBG("%s Already auto DMA memory allocated\n", __func__);
+	}
+	spin_unlock_irqrestore(&pudc->lock, flags);
+	VDBG("%s enabled\n", puep->name);
+
+	return 0;
+}
+
+/*-------------------------------------------------------------------------*/
+static int
+ mp200_udcep_ep_disable(struct usb_ep *puep)
+{
+	struct mp200_ep		*pep;
+	struct mp200_udc	*pudc;
+	unsigned long		flags;
+
+	if (puep == NULL) {
+		ERR("%s, bad param\n", __func__);
+		return -EINVAL;
+	}
+
+	pep = container_of(puep, struct mp200_ep, ep);
+
+	/* udc */
+	pudc = pep->pudc;
+
+	spin_lock_irqsave(&pudc->lock, flags);
+
+	if ((pep == &pudc->ep[0])
+	   || (pep->pdesc == NULL)) {
+		DBG("%s descriptor(EINVAL)", __func__);
+		spin_unlock_irqrestore(&pudc->lock, flags);
+		return -EINVAL;
+	}
+
+	/* clear dQH */
+	mp200st_udc_ep_clear_dQH(pudc, pep->pdesc->bEndpointAddress);
+
+	/* dequeue */
+	DBG_LOG(pudc, "EP DISABLE NUKE\n");
+	mp200st_udc_nuke(pudc, pep, -ESHUTDOWN);
+	pep->pdesc = NULL;
+
+	spin_unlock_irqrestore(&pudc->lock, flags);
+
+	return 0;
+}
+
+/*-------------------------------------------------------------------------*/
+static struct usb_request *
+ mp200_udcep_alloc_request(struct usb_ep *puep, gfp_t gfp_flags)
+{
+	struct mp200_req	*preq;
+	struct mp200_ep		*pep;
+	struct mp200_udc	*pudc;
+
+	if (puep == NULL) {
+		ERR("%s, bad param\n", __func__);
+		return NULL;
+	}
+
+	pep = container_of(puep, struct mp200_ep, ep);
+
+	/* udc */
+	pudc = pep->pudc;
+
+	preq = kzalloc(sizeof(struct mp200_req), gfp_flags);
+
+	if (preq == NULL) {
+		DBG("%s memory(NOMEM)", __func__);
+		return NULL;
+	}
+	MEM_LOG(pudc, "%s kzalloc(%08x)\n", __func__, (int)preq);
+
+	preq->req.dma = DMA_ADDR_INVALID;
+	INIT_LIST_HEAD(&preq->queue);
+
+	return &preq->req;
+}
+
+/*-------------------------------------------------------------------------*/
+static void
+ mp200_udcep_free_request(struct usb_ep *puep, struct usb_request *pureq)
+{
+	struct mp200_req	*preq;
+	struct mp200_ep		*pep;
+	struct mp200_udc	*pudc;
+
+	if (puep == NULL) {
+		ERR("%s, bad param\n", __func__);
+		return;
+	}
+
+	pep = container_of(puep, struct mp200_ep, ep);
+
+	/* udc */
+	pudc = pep->pudc;
+
+	if (pureq != NULL) {
+		preq = container_of(pureq, struct mp200_req, req);
+		MEM_LOG(pudc, "%s kfree(%08x)\n", __func__, (int)preq);
+		kfree(preq);
+	}
+	return;
+}
+
+/*-------------------------------------------------------------------------*/
+static int mp200_udcep_ep_queue(
+	struct usb_ep *puep,
+	struct usb_request *pureq,
+	gfp_t gfp_flags)
+{
+	struct mp200_ep		*pep;
+	struct mp200_req	*preq;
+	struct mp200_udc	*pudc;
+	unsigned long		flags;
+
+	/* catch various bogus parameters */
+	if ((pureq == NULL) || (puep == NULL)) {
+		ERR("%s, bad param\n", __func__);
+		return -EINVAL;
+	}
+
+	preq = container_of(pureq, struct mp200_req, req);
+
+	if ((preq->req.complete == NULL)
+	   || (preq->req.buf == NULL)
+	   || !list_empty(&preq->queue)) {
+
+		ERR("%s, bad req\n", __func__);
+		return -EINVAL;
+	}
+
+	pep = container_of(puep, struct mp200_ep, ep);
+
+	/* udc */
+	pudc = pep->pudc;
+
+	/* length check */
+	if ((preq->req.dma == DMA_ADDR_INVALID) || (preq->req.dma == 0)) {
+		if (preq->req.length > UDC_EP_AUTO_BUFSIZE) {
+			ERR("%s length size over! %s size=%d\n", __func__,
+				pep->name, preq->req.length);
+			return -EMSGSIZE;
+		}
+	}
+
+	/* normal EP check (EP0 threw) */
+	if (pep != &pudc->ep[0]) {
+		if (pep->pdesc == NULL) {
+			ERR("(pep->pdesc == NULL)\n");
+			return -EINVAL;
+		}
+
+		if ((pep->pdesc->bmAttributes | USB_ENDPOINT_XFERTYPE_MASK)
+		 == USB_ENDPOINT_XFER_ISOC) {
+			if (preq->req.length > (le16_to_cpu(
+			 pep->pdesc->wMaxPacketSize)
+			  | USB_ENDPOINT_MPS_SIZE_MASK)) {
+				ERR("USB_ENDPOINT_XFER_ISOC length > "
+				"wMaxPacketSize \n");
+				return -EMSGSIZE;
+			}
+		}
+	}
+
+
+	VDBG("%s queue req %p, len %d buf %p\n",
+		pep->ep.name, pureq, pureq->length, pureq->buf);
+
+	spin_lock_irqsave(&pudc->lock, flags);
+	if ((pudc->pdriver == NULL)
+			|| (pudc->gadget.speed == USB_SPEED_UNKNOWN)) {
+		spin_unlock_irqrestore(&pudc->lock, flags);
+		return -ESHUTDOWN;
+	}
+
+	preq->req.status = -EINPROGRESS;
+	preq->req.actual = 0;
+
+#ifdef USB_TRANS_DIVISION
+	preq->act_len = 0;
+	if ((pep != &pudc->ep[0])
+			&& (pep->pdesc->bEndpointAddress & USB_DIR_IN)) {
+		if (pep->pdesc->wMaxPacketSize == 512) {
+			/* -------------------------------------------------- */
+			/*  division transport support only High Speed */
+			preq->division_len = USB_DIVISION_SIZE;
+		} else{
+			preq->division_len = 0;
+		}
+	}
+#endif /* USB_TRANS_DIVISION */
+	VDBG("%s %s length=%d\n", __func__ , pep->name, preq->req.length);
+
+	mp200st_udc_list_add_and_submit_dTD(pudc, pep, preq);
+
+	spin_unlock_irqrestore(&pudc->lock, flags);
+
+	return 0;
+}
+
+/*-------------------------------------------------------------------------*/
+static int
+ mp200_udcep_ep_dequeue(struct usb_ep *puep, struct usb_request *pureq)
+{
+	struct mp200_ep		*pep;
+	struct mp200_req	*preq;
+	struct mp200_udc	*pudc;
+	unsigned long		flags;
+	int			status;
+
+	if ((puep == NULL) || (pureq == NULL)) {
+		ERR("%s, bad param\n", __func__);
+		return -EINVAL;
+	}
+
+	pep = container_of(puep, struct mp200_ep, ep);
+
+	/* udc */
+	pudc = pep->pudc;
+
+	spin_lock_irqsave(&pudc->lock, flags);
+
+	/* make sure it's actually queued on this endpoint */
+	list_for_each_entry(preq, &pep->queue, queue) {
+		if (&preq->req == pureq)
+			break;
+	}
+	if (&preq->req != pureq) {
+		spin_unlock_irqrestore(&pudc->lock, flags);
+		DBG("%s no queue(EINVAL)", __func__);
+		return -EINVAL;
+	}
+
+	/* fowarding */
+	if (pep->queue.next == &preq->queue) {
+		status = mp200st_udc_abort_dTD(pudc,
+			pep->pdesc->bEndpointAddress);
+		if (status < 0) {
+			DBG("%s abort fail(%d)", __func__, status);
+			spin_unlock_irqrestore(&pep->pudc->lock, flags);
+			return status;
+		}
+	}
+
+	DBG_LOG(pudc, "DEQUEUE(%02x)\n", pep->pdesc->bEndpointAddress);
+
+	mp200st_udc_done_callback(pudc, pep, preq, -ECONNABORTED, TRUE);
+
+	spin_unlock_irqrestore(&pep->pudc->lock, flags);
+
+	return 0;
+}
+
+/*-------------------------------------------------------------------------*/
+static int
+ mp200_udcep_ep_set_halt(struct usb_ep *puep, int bstall)
+{
+	struct mp200_ep		*pep;
+	unsigned long		flags;
+	struct mp200_udc	*pudc;
+	u8			ep_adrs;
+
+	if (puep == NULL) {
+		ERR("%s, bad param\n", __func__);
+		return -EINVAL;
+	}
+
+	pep = container_of(puep, struct mp200_ep, ep);
+
+	/* udc */
+	pudc = pep->pudc;
+
+	spin_lock_irqsave(&pudc->lock, flags);
+
+	if (pep == &pudc->ep[0]) {
+		ep_adrs = 0;
+	} else{
+		if (pep->pdesc == NULL) {
+			spin_unlock_irqrestore(&pudc->lock, flags);
+			return -EINVAL;
+		}
+
+		ep_adrs = pep->pdesc->bEndpointAddress;
+	}
+
+	if ((bstall) && (!list_empty(&pep->queue))) {
+		spin_unlock_irqrestore(&pudc->lock, flags);
+		return -EAGAIN;
+	}
+
+	if (ep_adrs == 0) {
+		mp200st_udc_set_endpoint_stall(pudc, (0 | USB_DIR_OUT),
+			(bool)bstall);
+		mp200st_udc_set_endpoint_stall(pudc, (0 | USB_DIR_IN),
+			(bool)bstall);
+	} else{
+		mp200st_udc_set_endpoint_stall(pudc, ep_adrs, (bool)bstall);
+	}
+
+	spin_unlock_irqrestore(&pudc->lock, flags);
+
+	return 0;
+}
+
+/*-------------------------------------------------------------------------*/
+static int
+ mp200_udcep_fifo_status(struct usb_ep *puep)
+{
+	struct mp200_ep		*pep;
+	struct mp200_ep		*pep_ret = NULL;
+	struct mp200_udc	*pudc;
+	struct mp200_req	*preq = NULL;
+	int			status;
+	u8			ep_adrs;
+	unsigned long		flags;
+
+	if (puep == NULL) {
+		ERR("%s, bad param\n", __func__);
+		return -EINVAL;
+	}
+
+	pep = container_of(puep, struct mp200_ep, ep);
+
+	/* udc */
+	pudc = pep->pudc;
+
+	spin_lock_irqsave(&pudc->lock, flags);
+
+	if (pep->pdesc == NULL) {
+		spin_unlock_irqrestore(&pudc->lock, flags);
+		return 0;
+	}
+
+	ep_adrs = pep->pdesc->bEndpointAddress;
+
+	status = mp200st_udc_get_ep_req_actual_length(
+			pudc,
+			ep_adrs,
+			DTD_MANAGEMENT_USE, /* not change */
+			&pep_ret,
+			&preq);
+
+	if (pep_ret == NULL) {
+		spin_unlock_irqrestore(&pudc->lock, flags);
+		return 0;
+	}
+
+	/* not match */
+	if (pep != pep_ret) {
+		spin_unlock_irqrestore(&pudc->lock, flags);
+		ERR("%s mp200st_udc_get_ep_req_actual_length  pep(%08x)"
+		"!=pep_ret(%08x)\n", __func__, (int)pep, (int)pep_ret);
+		return -EINVAL;
+	}
+
+	/* error */
+	if ((status < 0) || (preq == NULL)) {
+		spin_unlock_irqrestore(&pudc->lock, flags);
+		ERR("%s status = %d preq(%08x)\n", __func__, status, (int)preq);
+		return status;
+	}
+
+	spin_unlock_irqrestore(&pudc->lock, flags);
+
+	return preq->req.actual;
+}
+
+/*-------------------------------------------------------------------------*/
+static void
+ mp200_udcep_fifo_flush(struct usb_ep *puep)
+{
+	struct mp200_ep		*pep;
+	struct mp200_udc	*pudc;
+	unsigned long	flags;
+
+	if (puep == NULL) {
+		ERR("%s, bad param\n", __func__);
+		return;
+	}
+
+	pep = container_of(puep, struct mp200_ep, ep);
+
+	/* udc */
+	pudc = pep->pudc;
+
+	spin_lock_irqsave(&pudc->lock, flags);
+
+	if (pep == &pudc->ep[0] || (pep->pdesc == NULL)
+			|| !list_empty(&pep->queue)) {
+		spin_unlock_irqrestore(&pudc->lock, flags);
+		DBG("%s, bad ep\n", __func__);
+		return;
+	}
+
+	/* FLUSH */
+	mp200st_udc_delete_dTD(pudc, pep->pdesc->bEndpointAddress);
+
+	spin_unlock_irqrestore(&pudc->lock, flags);
+
+	return;
+}
+
+
+/*-------------------------------------------------------------------------*/
+static void mp200st_udc_enable_endpoint(struct mp200_udc *pudc, u8 ep_adrs)
+{
+	u32	data;
+	u32	epnum;
+
+	epnum = (ep_adrs & USB_ENDPOINT_NUMBER_MASK);
+
+	if (ep_adrs & USB_DIR_IN)
+		data = ENDPTCTRL_TXE | ENDPTCTRL_TXR;
+	else
+		data = ENDPTCTRL_RXE | ENDPTCTRL_RXR;
+
+	mp200st_udc_ulc_chk_set_bit(pudc, &pudc->pfc_reg->ENDPTCTRL[epnum],
+		data);
+
+	return;
+}
+
+/*-------------------------------------------------------------------------*/
+static void
+ mp200st_udc_set_ep_ctrlreg(
+	struct mp200_udc *pudc,
+	u8 ep_adrs,
+	u8 bm_attributes)
+{
+	u32		data;
+	u32		epnum;
+	u32		type;
+
+	epnum = (ep_adrs & USB_ENDPOINT_NUMBER_MASK);
+	data = mp200st_udc_readl(&pudc->pfc_reg->ENDPTCTRL[epnum]);
+
+	type = (bm_attributes & USB_ENDPOINT_XFERTYPE_MASK);
+
+	if (ep_adrs & USB_DIR_IN) {
+		if (data & ENDPTCTRL_RXT) {
+			data = (type << ENDPTCTRL_TXT_SHIFT);
+		} else{
+			data = (type << ENDPTCTRL_TXT_SHIFT)
+				| (type << ENDPTCTRL_RXT_SHIFT);
+		}
+	} else{
+		if (data & ENDPTCTRL_TXT) {
+			data = (type << ENDPTCTRL_RXT_SHIFT);
+		} else{
+			data = (type << ENDPTCTRL_TXT_SHIFT)
+				| (type << ENDPTCTRL_RXT_SHIFT);
+		}
+	}
+
+	mp200st_udc_ulc_chk_set_bit(pudc, &pudc->pfc_reg->ENDPTCTRL[epnum],
+		data);
+	mp200st_udc_enable_endpoint(pudc, ep_adrs);
+
+	return;
+}
+
+/*-------------------------------------------------------------------------*/
+static int
+ mp200st_udc_create_CBI_dTD(
+	struct mp200_udc *pudc,
+	struct mp200_ep *pep,
+	struct mp200_req *preq,
+	T_MEMORY_VP_INFO *pdTD_mem,
+	u8 ep_adrs)
+{
+	int			i, k;
+	u8			direct, epnum;
+	bool			bdTD_mem_set = FALSE;
+	u32			data_len, len_tmp;
+	u32			buffer_addr, offset_addr;
+	T_DTD_MANAGEMENT	*p_dTD_m;
+	T_EP_TRANS_DESC		*p_dTD, *p_tmp_dTD;
+
+	/* dTD */
+	p_tmp_dTD = NULL;
+	epnum	= ep_adrs & USB_ENDPOINT_NUMBER_MASK;
+	direct	= (ep_adrs & USB_ENDPOINT_DIR_MASK) >> UDC_DIRECTION_SHIFT;
+#ifdef USB_TRANS_DIVISION
+	if (preq->division_len != 0) {
+		data_len = min(preq->req.length - preq->act_len,
+			preq->division_len);
+	} else {
+		data_len = preq->req.length;
+	}
+
+	if (data_len == 0) {
+		buffer_addr = preq->req.dma & DTD_BUFFER_PTR;
+		offset_addr = preq->req.dma & DTD_CURR_OFFSET;
+	} else{
+		buffer_addr = (preq->req.dma + preq->act_len) & DTD_BUFFER_PTR;
+		offset_addr = (preq->req.dma + preq->act_len) & DTD_CURR_OFFSET;
+	}
+#else /* USB_TRANS_DIVISION */
+	data_len	= preq->req.length;
+	buffer_addr = preq->req.dma & DTD_BUFFER_PTR;
+	offset_addr = preq->req.dma & DTD_CURR_OFFSET;
+#endif /* USB_TRANS_DIVISION */
+
+	for (k = 0; k < SUPPORT_DTD_NUM; k++) {
+		p_dTD_m = &pudc->dTD_Manage[direct][epnum][k];
+		if (p_dTD_m->use_flag == 0) {
+
+			p_dTD_m->use_flag  = DTD_MANAGEMENT_RESERVE;
+			p_dTD_m->p_context = pep;
+
+			if (bdTD_mem_set == FALSE) {
+				*pdTD_mem = p_dTD_m->mem_info;
+				bdTD_mem_set = TRUE;
+			}
+
+			/* clear dTD memory */
+			p_dTD = (T_EP_TRANS_DESC *)p_dTD_m->mem_info.p_vadrs;
+			memset(p_dTD, 0, sizeof(T_EP_TRANS_DESC));
+
+			/* Data length */
+			if (data_len > DTD_MAX_TRANSFER_SIZE)
+				len_tmp = DTD_MAX_TRANSFER_SIZE;
+			else
+				len_tmp = data_len;
+
+			data_len -= len_tmp;
+
+			/* Terminal */
+			p_dTD->next_ptr = DTD_NEXT_TERMINATE;
+
+			/* Total Byte */
+			p_dTD->total_bytes = ((len_tmp << DTD_LENGTH_BIT_POS)
+			 | DTD_STATUS_ACTIVE);
+
+			/* Buffer Pointer & Offset */
+			p_dTD->buf_ptr[0] = buffer_addr + offset_addr;
+			for (i = 1; i < 5; i++) {
+				buffer_addr += 0x1000;
+				p_dTD->buf_ptr[i] = buffer_addr;
+			}
+
+			/* Next Link Pointer */
+			if (p_tmp_dTD != NULL) {
+				p_tmp_dTD->next_ptr
+				 = (u32)p_dTD_m->mem_info.padrs;
+			}
+
+			p_tmp_dTD = p_dTD;
+			if (data_len == 0) {
+				p_dTD->total_bytes |= DTD_IOC;	/* Interrupt */
+				break;
+			}
+		}
+	}
+
+	return 0;
+}
+
+/*-------------------------------------------------------------------------*/
+static int
+ mp200st_udc_create_ISO_dTD(
+	struct mp200_udc *pudc,
+	struct mp200_ep *pep,
+	struct mp200_req *preq,
+	T_MEMORY_VP_INFO *pdTD_mem,
+	u8 ep_adrs)
+{
+	int			i, k;
+	u8			direct, epnum;
+	bool			bdTD_mem_set = FALSE;
+	u32			data_len, len_tmp;
+	u32			buffer_addr, offset_addr;
+	T_DTD_MANAGEMENT	*p_dTD_m;
+	T_EP_TRANS_DESC		*p_dTD, *p_tmp_dTD;
+
+	/* dTD */
+	p_tmp_dTD = NULL;
+	epnum	= ep_adrs & USB_ENDPOINT_NUMBER_MASK;
+	direct	= (ep_adrs & USB_ENDPOINT_DIR_MASK) >> UDC_DIRECTION_SHIFT;
+
+	data_len	= preq->req.length;
+	buffer_addr = preq->req.dma & DTD_BUFFER_PTR;
+	offset_addr = preq->req.dma & DTD_CURR_OFFSET;
+
+	for (k = 0; k < SUPPORT_DTD_NUM; k++) {
+		p_dTD_m = &pudc->dTD_Manage[direct][epnum][k];
+		if (p_dTD_m->use_flag == 0) {
+
+			p_dTD_m->use_flag  = DTD_MANAGEMENT_RESERVE;
+			p_dTD_m->p_context = pep;
+
+			if (bdTD_mem_set == FALSE) {
+				*pdTD_mem = p_dTD_m->mem_info;
+				bdTD_mem_set = TRUE;
+			}
+
+			/* clear dTD memory */
+			p_dTD = (T_EP_TRANS_DESC *)p_dTD_m->mem_info.p_vadrs;
+			memset(p_dTD, 0, sizeof(T_EP_TRANS_DESC));
+
+			/* Data length */
+			if (data_len > DTD_MAX_TRANSFER_SIZE)
+				len_tmp = DTD_MAX_TRANSFER_SIZE;
+			else
+				len_tmp = data_len;
+
+			data_len -= len_tmp;
+
+			/* Terminal */
+			p_dTD->next_ptr = DTD_NEXT_TERMINATE;
+
+			/* Total Byte */
+			p_dTD->total_bytes = ((len_tmp << DTD_LENGTH_BIT_POS)
+			 | DTD_STATUS_ACTIVE);
+
+			/* Buffer Pointer & Offset */
+			p_dTD->buf_ptr[0] = buffer_addr + offset_addr;
+			for (i = 1; i < 5; i++) {
+				buffer_addr += 0x1000;
+				p_dTD->buf_ptr[i] = buffer_addr;
+			}
+
+			/* Next Link Pointer */
+			if (p_tmp_dTD != NULL) {
+				p_tmp_dTD->next_ptr
+				 = (u32)p_dTD_m->mem_info.padrs;
+			}
+			p_tmp_dTD = p_dTD;
+
+			if (data_len == 0) {
+				p_dTD->total_bytes |= DTD_IOC;	/* Interrupt */
+				break;
+			}
+		}
+	}
+
+	return 0;
+}
+
+/*-------------------------------------------------------------------------*/
+static int
+ mp200st_udc_create_dTD(
+	struct mp200_udc *pudc,
+	struct mp200_ep *pep,
+	struct mp200_req *preq,
+	T_MEMORY_VP_INFO *pdTD_mem,
+	u8 ep_adrs)
+{
+	int			k;
+	u8			direct, epnum;
+	u16			dTD_num = 0;
+	u32			data_len;
+	T_DTD_MANAGEMENT	*p_dTD_m;
+
+	/* search empty dtd num */
+	epnum	= ep_adrs & USB_ENDPOINT_NUMBER_MASK;
+	direct	= (ep_adrs & USB_ENDPOINT_DIR_MASK) >> UDC_DIRECTION_SHIFT;
+	for (k = 0; k < SUPPORT_DTD_NUM; k++) {
+		p_dTD_m = &pudc->dTD_Manage[direct][epnum][k];
+		if (p_dTD_m->use_flag == 0)
+			dTD_num++;
+	}
+
+	/* check transfer size */
+	data_len = dTD_num * DTD_MAX_TRANSFER_SIZE;
+	if (preq->req.length > data_len)
+		return -EINVAL;
+
+	if ((pep != &pudc->ep[0])
+	   && (pep->pdesc != NULL)
+	   && ((pep->pdesc->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK)
+	   == USB_ENDPOINT_XFER_ISOC)) {
+
+		/* Isochronous */
+		mp200st_udc_create_ISO_dTD(pudc, pep, preq, pdTD_mem, ep_adrs);
+	} else{
+		/* Control Bulk Interrupt */
+		mp200st_udc_create_CBI_dTD(pudc, pep, preq, pdTD_mem, ep_adrs);
+	}
+
+	return 0;
+}
+
+#define DEL_DTD_REPEATED_WCOUNT	10
+#define DEL_DTD_REPEATED_RCOUNT	1000
+/*-------------------------------------------------------------------------*/
+static void
+ mp200st_udc_delete_dTD(struct mp200_udc *pudc, u8 ep_adrs)
+{
+	u32	bit_pos;
+	u32	data;
+	int	i, j;
+
+	bit_pos = ENDPT_BIT_POS(ep_adrs);
+	for (i = 0; i < DEL_DTD_REPEATED_WCOUNT; i++) {
+		mp200st_udc_writel(&pudc->pfc_reg->ENDPTFLUSH, bit_pos);
+		for (j = 0; j < DEL_DTD_REPEATED_RCOUNT; j++) {
+			data = mp200st_udc_readl(&pudc->pfc_reg->ENDPTFLUSH);
+			if (data == 0)
+				break;
+		}
+
+		data = mp200st_udc_readl(&pudc->pfc_reg->ENDPTSTATUS) & bit_pos;
+		if (data == 0)
+			break;
+	}
+
+	if (i >= DEL_DTD_REPEATED_WCOUNT)
+		DBG("%s fail\n", __func__);
+
+	return;
+}
+
+/*-------------------------------------------------------------------------*/
+static void
+ mp200st_udc_cancel_dTD(struct mp200_udc *pudc, u8 ep_adrs)
+{
+	int k;
+	T_DTD_MANAGEMENT *p_dTD_m;
+	u8 epnum = ep_adrs & USB_ENDPOINT_NUMBER_MASK;
+	u8 direct = (ep_adrs & USB_ENDPOINT_DIR_MASK) >> UDC_DIRECTION_SHIFT;
+
+	for (k = 0; k < SUPPORT_DTD_NUM; k++) {
+		p_dTD_m = &pudc->dTD_Manage[direct][epnum][k];
+		if (p_dTD_m->use_flag == DTD_MANAGEMENT_RESERVE)
+			p_dTD_m->use_flag = 0;
+	}
+
+	return;
+}
+
+/*-------------------------------------------------------------------------*/
+static int mp200st_udc_link_dTD(
+	struct mp200_udc *pudc,
+	struct mp200_req *preq,
+	T_MEMORY_VP_INFO *pdTD_mem,
+	u8 ep_adrs)
+{
+	int			k;
+	u8			direct, epnum;
+	u32			bit_pos;
+	u32			data;
+	T_ENDPOINT_QUEUE_HEAD	*p_dQH;
+	T_EP_TRANS_DESC		*p_dTD;
+	T_DTD_MANAGEMENT	*p_dTD_m, *p_dTD_m_tails;
+
+	epnum	= ep_adrs & USB_ENDPOINT_NUMBER_MASK;
+	direct	= (ep_adrs & USB_ENDPOINT_DIR_MASK) >> UDC_DIRECTION_SHIFT;
+	bit_pos = ENDPT_BIT_POS(ep_adrs);
+
+	p_dQH = mp200st_udc_ep_get_dQH_adrs(pudc, ep_adrs, FALSE);
+
+	p_dTD_m_tails = NULL;
+	for (k = 0; k < SUPPORT_DTD_NUM; k++) {
+		p_dTD_m = &pudc->dTD_Manage[direct][epnum][k];
+		switch (p_dTD_m->use_flag) {
+		case DTD_MANAGEMENT_RESERVE:
+			p_dTD_m->use_flag = DTD_MANAGEMENT_USE;
+			break;
+
+		case DTD_MANAGEMENT_USE:
+			p_dTD_m_tails = p_dTD_m;
+			break;
+
+		default:
+			break;
+		}
+	}
+
+	if (p_dTD_m_tails == NULL) {
+		/* not transfer */
+#ifdef USB_TRANS_DIVISION
+
+		if (preq->division_len != 0) {
+			p_dQH->max_length |= EQH_ZLT;
+		} else{
+			if (preq->req.zero)
+				p_dQH->max_length &= ~(EQH_ZLT);
+			else
+				p_dQH->max_length |= EQH_ZLT;
+		}
+
+#else /* USB_TRANS_DIVISION */
+		if (preq->req.zero)
+			p_dQH->max_length &= ~(EQH_ZLT);
+		else
+			p_dQH->max_length |= EQH_ZLT;
+
+#endif /* USB_TRANS_DIVISION */
+		p_dQH->next_ptr = (u32)pdTD_mem->padrs;
+		p_dQH->total_bytes = 0;
+
+		if (epnum == 0) {
+			if (mp200st_udc_readl(&pudc->pfc_reg->ENDPTSETUPSTAT)
+			 & ENDPTSETUPSTAT_ENDPTSETUPSTAT_EP0) {
+				DBG("%s Receiving ENDPTSETUPSTAT_EP0"
+				" (1)(%08x)\n", __func__, bit_pos);
+				return 0;
+			}
+		}
+#ifdef DUMMY_PRIME
+ #ifdef DUMMY_PRIME_NOT_EP0
+		if (epnum == 0) {
+			mp200st_udc_writel(&pudc->pfc_reg->ENDPTPRIME, bit_pos);
+			if (bit_pos)
+				DBG_LOG(pudc, "PRIME1(%08x)\n", bit_pos);
+
+		} else{
+			mp200st_udc_set_dummy_prime_waiting(pudc, bit_pos);
+		}
+ #else /* DUMMY_PRIME_NOT_EP0 */
+		mp200st_udc_set_dummy_prime_waiting(pudc, bit_pos);
+ #endif /* DUMMY_PRIME_NOT_EP0 */
+#else /* DUMMY_PRIME */
+		mp200st_udc_writel(&pudc->pfc_reg->ENDPTPRIME, bit_pos);
+		if (bit_pos)
+			DBG_LOG(pudc, "PRIME2(%08x)\n", bit_pos);
+#endif /* DUMMY_PRIME */
+
+		return 0;
+	} else{
+		/* transfer */
+		p_dTD = (T_EP_TRANS_DESC *)p_dTD_m_tails->mem_info.p_vadrs;
+		p_dTD->next_ptr = pdTD_mem->padrs;
+
+		data = mp200st_udc_readl(&pudc->pfc_reg->ENDPTPRIME);
+		if (data & bit_pos)
+			return 0;
+
+		mp200st_udc_set_bit(&pudc->pfc_reg->USBCMD, USBCMD_ATDTW);
+		data = mp200st_udc_readl(&pudc->pfc_reg->ENDPTSTATUS);
+		mp200st_udc_clear_bit(&pudc->pfc_reg->USBCMD, USBCMD_ATDTW);
+
+		if (data & bit_pos) {
+			return 0;
+		} else{
+#ifdef USB_TRANS_DIVISION
+
+			if (preq->division_len != 0) {
+				p_dQH->max_length |= EQH_ZLT;
+			} else{
+				if (preq->req.zero)
+					p_dQH->max_length &= ~(EQH_ZLT);
+				else
+					p_dQH->max_length |= EQH_ZLT;
+			}
+
+#else /* USB_TRANS_DIVISION */
+			if (preq->req.zero)
+				p_dQH->max_length &= ~(EQH_ZLT);
+			else
+				p_dQH->max_length |= EQH_ZLT;
+
+#endif /* USB_TRANS_DIVISION */
+			p_dQH->next_ptr = (u32)pdTD_mem->padrs;
+			p_dQH->total_bytes = 0;
+
+			if (epnum == 0) {
+				if (mp200st_udc_readl(
+				  &pudc->pfc_reg->ENDPTSETUPSTAT)
+				  & ENDPTSETUPSTAT_ENDPTSETUPSTAT_EP0) {
+					DBG("%s Receiving ENDPTSETUPSTAT_EP0"
+					" (2)(%08x)\n", __func__, bit_pos);
+					return 0;
+				}
+			}
+#ifdef DUMMY_PRIME
+ #ifdef DUMMY_PRIME_NOT_EP0
+			if (epnum == 0) {
+				mp200st_udc_writel(&pudc->pfc_reg->ENDPTPRIME,
+					bit_pos);
+				if (bit_pos) {
+					DBG_LOG(pudc, "PRIME3(%08x)\n",
+					bit_pos);
+				}
+			} else{
+				mp200st_udc_set_dummy_prime_waiting(pudc,
+				bit_pos);
+			}
+ #else /* DUMMY_PRIME_NOT_EP0 */
+			mp200st_udc_set_dummy_prime_waiting(pudc, bit_pos);
+ #endif /* DUMMY_PRIME_NOT_EP0 */
+#else /* DUMMY_PRIME */
+			mp200st_udc_writel(&pudc->pfc_reg->ENDPTPRIME, bit_pos);
+			if (bit_pos)
+				DBG_LOG(pudc, "PRIME4(%08x)\n", bit_pos);
+#endif /* DUMMY_PRIME */
+
+			return 0;
+		}
+	}
+
+	return 0;
+}
+
+/*-------------------------------------------------------------------------*/
+static int
+ mp200st_udc_unlink_dTD(struct mp200_udc *pudc, u8 ep_adrs)
+{
+	int			k;
+	T_DTD_MANAGEMENT	*p_dTD_m;
+	T_EP_TRANS_DESC		*p_dTD;
+	u8			epnum = ep_adrs & USB_ENDPOINT_NUMBER_MASK;
+	u8			direct;
+
+	direct = (ep_adrs & USB_ENDPOINT_DIR_MASK) >> UDC_DIRECTION_SHIFT;
+
+#ifdef DUMMY_PRIME
+ #ifdef DUMMY_PRIME_NAK_INT
+	u32			epnaken;
+ #endif /* DUMMY_PRIME_NAK_INT */
+#endif/* DUMMY_PRIME */
+
+#ifdef DUMMY_PRIME
+	pudc->dummy_prime_transferring &= ~(ENDPT_BIT_POS(ep_adrs));
+	pudc->dummy_prime_waiting &= ~(ENDPT_BIT_POS(ep_adrs));
+ #ifdef DUMMY_PRIME_NAK_INT
+	epnaken = mp200st_udc_readl(&pudc->pfc_reg->ENDPTNAKEN);
+
+	if ((pudc->dummy_prime_transferring == 0)
+			&& (epnaken != pudc->dummy_prime_waiting)) {
+		mp200st_udc_ulc_chk_writel(pudc, &pudc->pfc_reg->ENDPTNAKEN,
+			pudc->dummy_prime_waiting);
+	}
+
+ #endif /* DUMMY_PRIME_NAK_INT */
+#endif/* DUMMY_PRIME */
+
+	for (k = 0; k < SUPPORT_DTD_NUM; k++) {
+		p_dTD_m = &pudc->dTD_Manage[direct][epnum][k];
+		p_dTD_m->use_flag = 0;
+		p_dTD = (T_EP_TRANS_DESC *)p_dTD_m->mem_info.p_vadrs;
+		p_dTD->total_bytes = 0;
+		p_dTD->next_ptr = DTD_NEXT_TERMINATE;
+	}
+
+	return 0;
+}
+
+/*-------------------------------------------------------------------------*/
+static int
+ mp200st_udc_done_transfer(struct mp200_udc *pudc, u8 ep_adrs)
+{
+	struct mp200_ep		*pep = NULL;
+	struct mp200_req	*preq = NULL;
+	int			status;
+
+	status = mp200st_udc_get_ep_req_actual_length(pudc,
+							ep_adrs,
+							DTD_MANAGEMENT_FREE,
+							&pep,
+							&preq);
+
+	if (status < 0) {
+		if ((ep_adrs & USB_ENDPOINT_NUMBER_MASK) == 0)
+			return 0;
+	}
+
+	mp200st_udc_done_callback(pudc, pep, preq, status, TRUE);
+
+	return status;
+}
+
+/*-------------------------------------------------------------------------*/
+static int mp200st_udc_set_start_dTD(
+	struct mp200_udc *pudc,
+	struct mp200_ep *pep,
+	struct mp200_req *preq,
+	u8 ep_adrs)
+{
+	T_MEMORY_VP_INFO	dTD_mem;
+	int			status;
+
+	dTD_mem.p_vadrs = NULL;
+	dTD_mem.padrs = DMA_ADDR_INVALID;
+
+	status = mp200st_udc_create_dTD(pudc, pep, preq, &dTD_mem, ep_adrs);
+	if (status < 0) {
+		mp200st_udc_cancel_dTD(pudc, ep_adrs);
+		ERR("%s fail ep=%02x\n", __func__, ep_adrs);
+		return status;
+	}
+
+	status = mp200st_udc_link_dTD(pudc, preq, &dTD_mem, ep_adrs);
+
+	return status;
+}
+
+/*-------------------------------------------------------------------------*/
+static void mp200st_udcint_dummy_EP0_complete(struct usb_ep *puep,
+	struct usb_request *pureq)
+{
+	return ;
+}
+
+/*-------------------------------------------------------------------------*/
+static int
+ mp200st_udc_submit_dTD(struct mp200_udc *pudc, struct mp200_ep *pep)
+{
+	int			status = -EINVAL;
+	struct mp200_req	*preq;
+	u8			ep_adrs;
+
+	if (list_empty(&pep->queue)) {
+		ERR("%s list_empty\n", __func__);
+		return status;
+	}
+
+	if (pudc->vbus_active == 0) {
+		DBG("%s VBUS OFF\n", __func__);
+		return -ESHUTDOWN;
+	}
+
+	preq = list_entry(pep->queue.next, struct mp200_req, queue);
+
+	/* check EP0 */
+	if (pep != &pudc->ep[0]) {
+		/* not EP0 */
+		ep_adrs = pep->pdesc->bEndpointAddress;
+
+		/* not DMA mem */
+		if ((preq->req.dma == DMA_ADDR_INVALID)
+				|| (preq->req.dma == 0)) {
+			if (preq->req.length > UDC_EP_AUTO_BUFSIZE) {
+				ERR("%s length size over! ep=%02x size=%d\n",
+					__func__, ep_adrs, preq->req.length);
+				return -EINVAL;
+			}
+			preq->req.dma = pep->mem.padrs;
+			if (ep_adrs & USB_DIR_IN) {
+				memcpy(pep->mem.p_vadrs, preq->req.buf,
+					preq->req.length);
+			}
+		}
+
+		status = mp200st_udc_set_start_dTD(pudc, pep, preq, ep_adrs);
+		if (status < 0)
+			DBG("%s data in ERR\n", __func__);
+
+	} else{
+		/* make dummy req */
+		memset(&pudc->null_packet_req, 0, sizeof(struct mp200_req));
+		pudc->null_packet_req.req.buf		= NULL;
+		pudc->null_packet_req.req.length	= 0;
+		pudc->null_packet_req.req.dma		= DMA_ADDR_INVALID;
+		pudc->null_packet_req.req.zero	= FALSE;
+		pudc->null_packet_req.req.complete
+		 = mp200st_udcint_dummy_EP0_complete;
+		pudc->null_packet_req.req.status	= -EINPROGRESS;
+
+		if (pudc->ctrl.bRequestType & USB_DIR_IN) {
+			/* data in -> status out */
+			ep_adrs = (0 | USB_DIR_IN);
+			/* not DMA mem */
+			if ((preq->req.dma == DMA_ADDR_INVALID)
+			 || (preq->req.dma == 0)) {
+				if (UDC_EP_AUTO_BUFSIZE < preq->req.length) {
+					ERR("%s length size over!"
+					" ep=%02x size=%d\n", __func__,
+					ep_adrs, preq->req.length);
+					return -EINVAL;
+				}
+				preq->req.dma = pep->mem.padrs;
+				memcpy(pep->mem.p_vadrs, preq->req.buf,
+				 preq->req.length);
+			}
+			status = mp200st_udc_set_start_dTD(pudc, pep, preq,
+			 (0 | USB_DIR_IN));
+			if (status < 0)
+				DBG("%s data in ERR\n", __func__);
+
+			status = mp200st_udc_set_start_dTD(pudc, pep,
+			 &pudc->null_packet_req, (0 | USB_DIR_OUT));
+			if (status < 0)
+				DBG("%s data in -> status out ERR\n", __func__);
+
+		} else{
+			if (pudc->ctrl.wLength) {
+				ep_adrs = (0 | USB_DIR_OUT);
+				/* not DMA mem */
+				if ((preq->req.dma == DMA_ADDR_INVALID)
+				 || (preq->req.dma == 0)) {
+					if (UDC_EP_AUTO_BUFSIZE
+					 < preq->req.length) {
+						ERR("%s length size over!"
+						" ep=%02x size=%d\n",
+						__func__, ep_adrs,
+						preq->req.length);
+						return -EINVAL;
+					}
+					preq->req.dma = pep->mem.padrs;
+				}
+				status = mp200st_udc_set_start_dTD(pudc, pep,
+				 preq, (0 | USB_DIR_OUT));
+				if (status < 0)
+					DBG("%s data out ERR\n", __func__);
+
+				status = mp200st_udc_set_start_dTD(pudc, pep,
+				 &pudc->null_packet_req, (0 | USB_DIR_IN));
+				if (status < 0)
+					DBG("%s data out -> status in ERR\n",
+					 __func__);
+			} else{
+				/* status_in */
+				status = mp200st_udc_set_start_dTD(pudc, pep,
+				 preq, (0 | USB_DIR_IN));
+				if (status < 0)
+					DBG("%s status_in ERR\n", __func__);
+			}
+		}
+	}
+
+	return status;
+}
+
+/*-------------------------------------------------------------------------*/
+static int
+ mp200st_udc_abort_dTD(struct mp200_udc *pudc, u8 ep_adrs)
+{
+	/* check comp */
+	if (mp200st_udc_readl(&pudc->pfc_reg->ENDPTCOMPLETE)
+			& ENDPT_BIT_POS(ep_adrs)) {
+		return -EBUSY;
+	}
+
+	/* flush */
+	mp200st_udc_delete_dTD(pudc, ep_adrs);
+
+	/* check comp */
+	if (mp200st_udc_readl(&pudc->pfc_reg->ENDPTCOMPLETE)
+			& ENDPT_BIT_POS(ep_adrs)) {
+		return -EBUSY;
+	}
+	/* unlink */
+	mp200st_udc_unlink_dTD(pudc, ep_adrs);
+
+	return 0;
+}
+
+/*-------------------------------------------------------------------------*/
+static void mp200st_udc_done_callback(
+	struct mp200_udc *pudc,
+	struct mp200_ep *pep,
+	struct mp200_req *preq,
+	int comp_status,
+	bool bstart_next)
+{
+	bool	bdel_queue_head_next;
+	int	status;
+
+	if (!pudc || !pep || !preq) {
+		DBG("%s -EINVAL (%08x,%08x,%08x)\n", __func__, (int)pudc,
+			(int)pep, (int)preq);
+		return;
+	}
+
+	/* check NULL empty */
+	if (list_empty(&pep->queue))
+		return;
+
+	/* check queue head element */
+	bdel_queue_head_next = (pep->queue.next == &preq->queue);
+
+#ifdef USB_TRANS_DIVISION
+
+	/* set status */
+	if (preq->req.status == -EINPROGRESS)
+		preq->req.status = comp_status;
+	else
+		DBG("req.status != -EINPROGRESS (%d)\n", preq->req.status);
+
+	if (comp_status == 0) {
+
+		/* auto DMA */
+		if (preq->req.dma == pep->mem.padrs) {
+			if (pep->pdesc != NULL) {
+				if (!(pep->pdesc->bEndpointAddress
+				 & USB_DIR_IN)) {
+					if (preq->division_len != 0) {
+						memcpy(preq->req.buf
+						 + preq->act_len,
+						 ((u8 *)pep->mem.p_vadrs)
+						 + preq->act_len,
+						 preq->req.actual);
+					} else{
+						memcpy(preq->req.buf,
+							pep->mem.p_vadrs,
+							preq->req.actual);
+					}
+				}
+			} else{
+				if (!(pudc->ctrl.bRequestType & USB_DIR_IN))
+					memcpy(preq->req.buf,
+						pep->mem.p_vadrs,
+						preq->req.actual);
+			}
+			preq->req.dma = DMA_ADDR_INVALID;
+		}
+
+		preq->act_len += preq->req.actual;
+	}
+
+	{
+		bool	bEnd = TRUE;
+
+		if ((preq->division_len != 0) && pep != &pudc->ep[0]) {
+			if (preq->req.actual != 0) {
+				if (preq->act_len == preq->req.length) {
+					if ((preq->req.zero != 0)
+					 && ((preq->req.actual
+					  % pep->pdesc->wMaxPacketSize)
+					   == 0)) {
+						/* Zero Length Packet
+						 * Flag Clear
+						 */
+						preq->req.zero = 0;
+						/* Zero Length Packet
+						 * Restart
+						 */
+						bEnd = FALSE;
+					}
+				} else{
+					if ((preq->division_len
+					 == preq->req.actual)) {
+						/* MaxPacketSize Restart */
+						bEnd = FALSE;
+					}
+
+				}
+			}
+		}
+
+		if (bEnd == FALSE) {
+			preq->req.status = -EINPROGRESS;
+			mp200st_udc_submit_dTD(pudc, pep);	/* Restart */
+		} else {
+			/* list del */
+			list_del_init(&preq->queue);
+ #ifdef DEBUG_COUNT
+			pep->done_count++;
+ #endif /* DEBUG_COUNT */
+
+			/* next start */
+			if (!list_empty(&pep->queue) && bstart_next
+					&& bdel_queue_head_next) {
+				status = mp200st_udc_submit_dTD(pudc, pep);
+				if (status < 0)
+					DBG("next start fail\n");
+			}
+
+ #ifdef DEBUG_COUNT
+			pep->done_callback_count++;
+			if (preq->req.status == 0)
+				pep->done_callback_ok_count++;
+			else if (preq->req.status == -ECONNRESET)
+				pep->done_callback_reset_count++;
+			else
+				pep->done_callback_fail_count++;
+			}
+ #endif /* DEBUG_COUNT */
+
+			preq->req.actual = preq->act_len;
+
+			/* don't modify queue heads during
+			 * completion callback
+			 */
+			spin_unlock(&pudc->lock);
+			preq->req.complete(&pep->ep, &preq->req);
+			spin_lock(&pudc->lock);
+		}
+	}
+
+#else /* USB_TRANS_DIVISION */
+
+	/* list del */
+	list_del_init(&preq->queue);
+ #ifdef DEBUG_COUNT
+	pep->done_count++;
+ #endif /* DEBUG_COUNT */
+
+	/* set status */
+	if (preq->req.status == -EINPROGRESS)
+		preq->req.status = comp_status;
+	else
+		DBG("req.status != -EINPROGRESS (%d)\n", preq->req.status);
+
+
+	/* auto DMA */
+	if (preq->req.dma == pep->mem.padrs) {
+		if (pep->pdesc != NULL) {
+			if (!(pep->pdesc->bEndpointAddress & USB_DIR_IN))
+				memcpy(preq->req.buf, pep->mem.p_vadrs,
+					preq->req.actual);
+		} else{
+			if (!(pudc->ctrl.bRequestType & USB_DIR_IN))
+				memcpy(preq->req.buf, pep->mem.p_vadrs,
+					preq->req.actual);
+		}
+		preq->req.dma = DMA_ADDR_INVALID;
+	}
+
+#ifdef DEBUG_COUNT
+	pep->done_callback_count++;
+	if (preq->req.status == 0) {
+		/* ok */
+		pep->done_callback_ok_count++;
+	} else if (preq->req.status == -ECONNRESET) {
+		/* reset */
+		pep->done_callback_reset_count++;
+	} else{
+		/* fail */
+		pep->done_callback_fail_count++;
+	}
+*/
+ #endif /* DEBUG_COUNT */
+
+	/* next start */
+	if (!list_empty(&pep->queue) && bstart_next && bdel_queue_head_next) {
+		status = mp200st_udc_submit_dTD(pudc, pep);
+		if (status < 0)
+			DBG("next start fail\n");
+	}
+
+	/* don't modify queue heads during completion callback */
+	spin_unlock(&pudc->lock);
+	preq->req.complete(&pep->ep, &preq->req);
+	spin_lock(&pudc->lock);
+#endif	/* USB_TRANS_DIVISION */
+
+	return;
+}
+
+/*-------------------------------------------------------------------------*/
+static void
+ mp200st_udc_nuke(struct mp200_udc *pudc, struct mp200_ep *pep, int status)
+{
+	struct mp200_req	*preq;
+
+	if (pep->pdesc != NULL) {
+		mp200st_udc_abort_dTD(pudc, pep->pdesc->bEndpointAddress);
+	} else{
+		mp200st_udc_abort_dTD(pudc, (0 | USB_DIR_OUT));
+		mp200st_udc_abort_dTD(pudc, (0 | USB_DIR_IN));
+	}
+
+	while (!list_empty(&pep->queue)) {
+		preq = list_entry(pep->queue.next, struct mp200_req, queue);
+		mp200st_udc_done_callback(pudc, pep, preq, status, FALSE);
+	}
+
+	return;
+}
+
+/*-------------------------------------------------------------------------*/
+static void
+ mp200st_udc_quiesce(struct mp200_udc *pudc)
+{
+	struct mp200_ep		*pep;
+
+	pudc->gadget.speed = USB_SPEED_UNKNOWN;
+
+	DBG_LOG(pudc, "UDC QUIESCE NUKE\n");
+	/* Endpoint0 */
+	mp200st_udc_nuke(pudc, &pudc->ep[0], -ESHUTDOWN);
+
+	/* Endpoint1-15 */
+	list_for_each_entry(pep, &pudc->gadget.ep_list, ep.ep_list) {
+		mp200st_udc_nuke(pudc, pep, -ESHUTDOWN);
+	}
+
+	return;
+}
+
+/*-------------------------------------------------------------------------*/
+static int
+ mp200st_udc_list_add_and_submit_dTD(
+	struct mp200_udc *pudc,
+	struct mp200_ep *pep,
+	struct mp200_req *preq)
+{
+	bool	b_able_transfer;
+	int	status = -EBUSY;
+
+	/* check able_transfer */
+	b_able_transfer = list_empty(&pep->queue);
+
+	/* maybe kickstart non-iso i/o queues */
+	list_add_tail(&preq->queue, &pep->queue);
+#ifdef DEBUG_COUNT
+	pep->start_count++;
+#endif /* DEBUG_COUNT */
+
+	if (b_able_transfer)
+		status = mp200st_udc_submit_dTD(pudc, pep);
+
+	return status;
+}
+
+/*-------------------------------------------------------------------------*/
+static int
+ mp200st_udc_get_ep_req_actual_length(
+	struct mp200_udc *pudc,
+	u8 ep_adrs,
+	u32 use_flag,
+	struct mp200_ep **pep_ret,
+	struct mp200_req **preq_ret)
+{
+	int			k;
+	int			done_num = 0;
+	u32			status_data = 0;
+	u32			data_len = 0;
+	T_DTD_MANAGEMENT	*p_dTD_m;
+	T_EP_TRANS_DESC		*p_dTD;
+	int			status = 0;
+	u8			epnum;
+	u8			direct;
+
+	epnum = ep_adrs & USB_ENDPOINT_NUMBER_MASK;
+	direct = (ep_adrs & USB_ENDPOINT_DIR_MASK) >> UDC_DIRECTION_SHIFT;
+
+	for (k = 0; k < SUPPORT_DTD_NUM; k++) {
+		p_dTD_m = &pudc->dTD_Manage[direct][epnum][k];
+		if (p_dTD_m->use_flag == DTD_MANAGEMENT_USE) {
+			p_dTD = (T_EP_TRANS_DESC *)p_dTD_m->mem_info.p_vadrs;
+			status_data |= (p_dTD->total_bytes & DTD_STATUS);
+			data_len += ((p_dTD->total_bytes
+				& DTD_TOTAL_BYTES) >> DTD_LENGTH_BIT_POS);
+			done_num++;
+			*pep_ret = (struct mp200_ep *)p_dTD_m->p_context;
+			if (list_empty(&(*pep_ret)->queue))
+				*preq_ret = NULL;
+			else
+				*preq_ret = list_entry((*pep_ret)->queue.next,
+					struct mp200_req, queue);
+
+			p_dTD_m->use_flag = use_flag;
+		}
+	}
+
+	/* check err */
+	if (done_num == 0) {
+		/*	transfer ABORT */
+		DBG("%s (done_num == 0) -ECONNABORTED ep=%02x\n", __func__,
+			ep_adrs);
+		DBG_LOG(pudc, "(done_num == 0) ep=%02x\n", ep_adrs);
+		return -ECONNABORTED;
+	} else if (*preq_ret == NULL) {
+		if (epnum == 0)
+			return -EINVAL;
+
+		ERR("%s (*preq_ret == NULL) -EINVAL ep=%02x\n", __func__,
+			ep_adrs);
+		return -EINVAL;
+	}
+
+
+	/* set actual length and status */
+	if (status_data == 0) {
+#ifdef USB_TRANS_DIVISION
+		if ((*preq_ret)->division_len != 0) {
+			u32		len;
+
+			len = min((*preq_ret)->division_len,
+				 (*preq_ret)->req.length
+				  - (*preq_ret)->act_len);
+			(*preq_ret)->req.actual = len - data_len;
+		} else{
+			(*preq_ret)->req.actual = (*preq_ret)->req.length
+							- data_len;
+		}
+#else /* USB_TRANS_DIVISION */
+		(*preq_ret)->req.actual = (*preq_ret)->req.length - data_len;
+#endif /* USB_TRANS_DIVISION */
+	} else{
+		if (!(status_data & (DTD_STATUS_DATA_BUFFER_ERR
+				| DTD_STATUS_TRANSACION_ERR))) {
+			/* ABORT */
+			DBG("%s ABORT -ECONNABORTED ep=%02x\n", __func__,
+				ep_adrs);
+			status = -ECONNABORTED;
+		} else if (status_data & DTD_STATUS_DATA_BUFFER_ERR) {
+			/* DATA_BUFFER_ERR */
+			ERR("%s DATA_BUFFER_ERR -EOVERFLOW ep=%02x\n",
+				__func__, ep_adrs);
+			status = -EOVERFLOW;
+		} else if (status_data & DTD_STATUS_TRANSACION_ERR) {
+			/* TRANSACION_ERR */
+			ERR("%s TRANSACION_ERR -EIO ep=%02x\n", __func__,
+				ep_adrs);
+			status = -EIO;
+		} else{
+			/* UNKNOWN */
+			ERR("%s UNKNOWN -EBADMSG ep=%02x\n", __func__, ep_adrs);
+			status = -EBADMSG;
+		}
+	}
+
+	return status;
+}
+
+/*-------------------------------------------------------------------------*/
+/* ULPI */
+#define ULPI_VID_READ_L		0x00	/* VendorID Low */
+#define ULPI_VID_READ_H		0x01	/* VendorID High */
+#define ULPI_PID_READ_L		0x02	/* ProductID Low */
+#define ULPI_PID_READ_H		0x03	/* ProductID High */
+#define ULPI_VID_WRITE_L	0x30	/* VendorID Low */
+#define ULPI_VID_WRITE_H	0x31	/* VendorID High */
+#define ULPI_PID_WRITE_L	0x32	/* ProductID Low */
+#define ULPI_PID_WRITE_H	0x33	/* ProductID High */
+/*-------------------------------------------------------------------------*/
+static int mp200st_udcprc_proc_udc_show(struct seq_file *s, void *pram)
+{
+	struct mp200_udc	*pudc = &g_udc;
+	unsigned long	flags;
+	u8	ndata;
+	unsigned char tmp[100];
+	u32 reg_data;
+	int i;
+
+	if (pudc == NULL) {
+		ERR("%s pudc == NULL\n", __func__);
+		return -ENODEV;
+	}
+
+	spin_lock_irqsave(&pudc->lock, flags); /* DI */
+
+	/* USB REG dump */
+	if (mp200st_udc_can_pullup(pudc)) {
+		spin_unlock_irqrestore(&pudc->lock, flags); /* EI */
+		seq_printf(s, "\n-USB REG-\n");
+		for (i = 0x80 ; i < 0x200 ; i += 16) {
+			reg_data = mp200st_udc_readl(
+				(u32 *)IO_ADDRESS(MP200_USB_BASE + i));
+			sprintf(tmp, "USB%04x =%08x", i, (int)reg_data);
+			seq_printf(s, tmp);
+
+			reg_data = mp200st_udc_readl(
+				(u32 *)IO_ADDRESS(MP200_USB_BASE + i + 4));
+			sprintf(tmp, " %08x", (int)reg_data);
+			seq_printf(s, tmp);
+
+			reg_data = mp200st_udc_readl(
+				(u32 *)IO_ADDRESS(MP200_USB_BASE + i + 8));
+			sprintf(tmp, " %08x", (int)reg_data);
+			seq_printf(s, tmp);
+
+			reg_data = mp200st_udc_readl(
+				(u32 *)IO_ADDRESS(MP200_USB_BASE + i + 12));
+			sprintf(tmp, " %08x\n", (int)reg_data);
+			seq_printf(s, tmp);
+
+		}
+
+		/* ULPI */
+		seq_printf(s, "\n-ULPI REG-\n");
+
+		ndata = mp200st_udc_ulpi_read(pudc, ULPI_VID_READ_L);
+		sprintf(tmp, "VID_L = %02x\n", ndata);
+		seq_printf(s, tmp);
+
+		ndata = mp200st_udc_ulpi_read(pudc, ULPI_VID_READ_H);
+		sprintf(tmp, "VID_H = %02x\n", ndata);
+		seq_printf(s, tmp);
+
+		ndata = mp200st_udc_ulpi_read(pudc, ULPI_PID_READ_L);
+		sprintf(tmp, "PID_L = %02x\n", ndata);
+		seq_printf(s, tmp);
+
+		ndata = mp200st_udc_ulpi_read(pudc, ULPI_PID_READ_H);
+		sprintf(tmp, "PID_H = %02x\n", ndata);
+		seq_printf(s, tmp);
+
+		ndata = mp200st_udc_ulpi_read(pudc, 0x04);
+		sprintf(tmp, "ULPI 0x04 = %02x\n", ndata);
+		seq_printf(s, tmp);
+
+		ndata = mp200st_udc_ulpi_read(pudc, 0x07);
+		sprintf(tmp, "ULPI 0x07 = %02x\n", ndata);
+		seq_printf(s, tmp);
+
+		ndata = mp200st_udc_ulpi_read(pudc, 0x15);
+		sprintf(tmp, "ULPI 0x15 = %02x\n", ndata);
+		seq_printf(s, tmp);
+
+		ndata = mp200st_udc_ulpi_read(pudc, 0x16);
+		sprintf(tmp, "ULPI 0x16 = %02x\n", ndata);
+		seq_printf(s, tmp);
+	} else{
+		spin_unlock_irqrestore(&pudc->lock, flags); /* EI */
+		seq_printf(s, "\n-PULLUP OFF no USB REG-\n");
+	}
+
+	{
+		u32	*g_dqh_ptr = pudc->dQH.p_vadrs;
+		int	g_dqh_len = DQH_MEMORY_SIZE;
+		int	ep_count = -1;
+		int	direct_count = -1;
+
+		/* DQH dump */
+		if (g_dqh_ptr != NULL) {
+			sprintf(tmp, "\n-DQH size=%d (%08x)-\n", g_dqh_len,
+			 (int)g_dqh_ptr);
+			seq_printf(s, tmp);
+			for (i = 0x0 ; i < g_dqh_len ; i += 16) {
+
+				if ((i % (sizeof(T_ENDPOINT_QUEUE_HEAD)
+				 * NUM_DIRECTIONS))  == 0) {
+					ep_count++;
+					direct_count = -1;
+				}
+				if ((i % (sizeof(T_ENDPOINT_QUEUE_HEAD)))  == 0)
+					direct_count++;
+
+				if ((*((u32 *)(((u8 *)g_dqh_ptr) + i))
+				 & ~(BIT00))
+				 || *((u32 *)(((u8 *)g_dqh_ptr) + i + 4))
+				 || *((u32 *)(((u8 *)g_dqh_ptr) + i + 8))
+				 || *((u32 *)(((u8 *)g_dqh_ptr) + i + 12))) {
+
+					if ((i % (sizeof(
+					 T_ENDPOINT_QUEUE_HEAD)))  == 0) {
+						sprintf(tmp, "** EP =%d **\n",
+						 ep_count);
+						seq_printf(s, tmp);
+						sprintf(tmp,
+						 "** DIRECT =%d **\n",
+						 direct_count);
+						seq_printf(s, tmp);
+					}
+
+					reg_data = *((u32 *)(((u8 *)g_dqh_ptr)
+					 + i));
+					sprintf(tmp, "DQH%04x =%08x", i,
+					 (int)reg_data);
+					seq_printf(s, tmp);
+
+					reg_data = *((u32 *)(((u8 *)g_dqh_ptr)
+					 + i + 4));
+					sprintf(tmp, " %08x", (int)reg_data);
+					seq_printf(s, tmp);
+
+					reg_data = *((u32 *)(((u8 *)g_dqh_ptr)
+					 + i + 8));
+					sprintf(tmp, " %08x", (int)reg_data);
+					seq_printf(s, tmp);
+
+					reg_data = *((u32 *)(((u8 *)g_dqh_ptr)
+					 + i + 12));
+					sprintf(tmp, " %08x\n", (int)reg_data);
+					seq_printf(s, tmp);
+				}
+
+			}
+		} else{
+			seq_printf(s, "\n--dqh_ptr == NULL no DQH--\n");
+		}
+	}
+
+	{
+		u32	*g_dtd_ptr = pudc->dTD.p_vadrs;
+		int	g_dtd_len = DTD_MEMORY_SIZE;
+		int	ep_count = -1;
+		int	direct_count = -1;
+		int	dtd_count = -1;
+
+		/* DTD dump */
+		if (g_dtd_ptr != NULL) {
+			sprintf(tmp, "\n-DTD size=%d (%08x)-\n", g_dtd_len,
+			 (int)g_dtd_ptr);
+			seq_printf(s, tmp);
+			for (i = 0x0 ; i < g_dtd_len ; i += 16) {
+
+				if ((i % (sizeof(T_EP_TRANS_DESC)
+				 * SUPPORT_DTD_NUM * NUM_ENDPOINTS)) == 0) {
+					direct_count++;
+					ep_count = -1;
+				}
+				if ((i % (sizeof(T_EP_TRANS_DESC)
+				 * SUPPORT_DTD_NUM)) == 0) {
+					ep_count++;
+					dtd_count = -1;
+				}
+				if ((i % (sizeof(T_EP_TRANS_DESC))) == 0)
+					dtd_count++;
+
+				if ((*((u32 *)(((u8 *)g_dtd_ptr) + i))
+				 & ~(BIT00))
+				 || *((u32 *)(((u8 *)g_dtd_ptr) + i + 4))
+				 || *((u32 *)(((u8 *)g_dtd_ptr) + i + 8))
+				 || *((u32 *)(((u8 *)g_dtd_ptr) + i + 12))) {
+
+					if ((i % (sizeof(T_EP_TRANS_DESC)
+					 * SUPPORT_DTD_NUM)) == 0) {
+						sprintf(tmp, "** EP =%d **\n",
+						 ep_count);
+						seq_printf(s, tmp);
+						sprintf(tmp,
+						 "** DIRECT =%d **\n",
+						  direct_count);
+						seq_printf(s, tmp);
+					}
+					if ((i % (sizeof(T_EP_TRANS_DESC)))
+					 == 0) {
+						sprintf(tmp,
+						 "** DTD =%d **\n", dtd_count);
+						seq_printf(s, tmp);
+					}
+
+					reg_data = *((u32 *)(((u8 *)g_dtd_ptr)
+					 + i));
+					sprintf(tmp, "DTD%04x =%08x", i,
+					 (int)reg_data);
+					seq_printf(s, tmp);
+
+					reg_data = *((u32 *)(((u8 *)g_dtd_ptr)
+					 + i + 4));
+					sprintf(tmp, " %08x", (int)reg_data);
+					seq_printf(s, tmp);
+
+					reg_data = *((u32 *)(((u8 *)g_dtd_ptr)
+					 + i + 8));
+					sprintf(tmp, " %08x", (int)reg_data);
+					seq_printf(s, tmp);
+
+					reg_data = *((u32 *)(((u8 *)g_dtd_ptr)
+					 + i + 12));
+					sprintf(tmp, " %08x\n", (int)reg_data);
+					seq_printf(s, tmp);
+				}
+
+
+			}
+		} else{
+			seq_printf(s, "\n--dqh_ptr == NULL no DTD--\n");
+		}
+	}
+
+#ifdef DEBUG_COUNT
+	sprintf(tmp, "\n-EP COMP -\n");
+	seq_printf(s, tmp);
+	for (i = 0 ; i < ((NUM_ENDPOINTS)*(NUM_DIRECTIONS) - 1) ; i++) {
+		if ((pudc->ep[i].name[0] != 0) && (pudc->ep[i].start_count)) {
+			sprintf(tmp, " %s\n", pudc->ep[i].name);
+			seq_printf(s, tmp);
+			sprintf(tmp, "  start=%d (n=%d)  done=%d   comp=%d"
+			"(ok=%d reset=%d fail=%d)\n",
+				 pudc->ep[i].start_count,
+				 pudc->ep[i].normal_start_count,
+				 pudc->ep[i].done_count,
+				 pudc->ep[i].done_callback_count,
+				 pudc->ep[i].done_callback_ok_count,
+				 pudc->ep[i].done_callback_reset_count,
+				 pudc->ep[i].done_callback_fail_count);
+
+			seq_printf(s, tmp);
+		}
+	}
+
+#endif /* DEBUG_COUNT */
+
+#ifdef DUMMY_PRIME
+	sprintf(tmp,
+		"\n dummy_prime_waiting=%08x   dummy_prime_transferring=%08x\n",
+		 pudc->dummy_prime_waiting,
+		 pudc->dummy_prime_transferring);
+
+	seq_printf(s, tmp);
+
+#endif /* DUMMY_PRIME */
+
+#ifdef DEBUG_LOG
+	{
+		seq_printf(s, "\ndbg_log[%d]:\n", pudc->dbg_log_count);
+		seq_printf(s, pudc->dbg_log);
+
+	}
+#endif /* DEBUG_LOG */
+#ifdef MEMORY_LOG
+	{
+		seq_printf(s, "\nmem_log[%d]:\n", pudc->mem_log_count);
+		seq_printf(s, pudc->mem_log);
+
+	}
+#endif /* MEMORY_LOG */
+
+	return 0;
+}
+
+/*-------------------------------------------------------------------------*/
+static int
+ mp200_udcprc_proc_udc_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, mp200st_udcprc_proc_udc_show, &g_udc);
+}
+
+#ifdef DEBUG
+/*-------------------------------------------------------------------------*/
+static ssize_t
+ mp200_udcprc_proc_udc_write(
+	struct file *fd,
+	const char __user *buf,
+	size_t len,
+	loff_t *ptr)
+{
+	struct mp200_udc	*pudc = &g_udc;
+#ifdef DEBUG_LOG
+	unsigned long	flags;
+#endif /* DEBUG_LOG */
+
+	if (pudc == NULL) {
+		ERR("%s pudc == NULL\n", __func__);
+		return -ENODEV;
+	}
+
+#ifdef DEBUG_LOG
+	spin_lock_irqsave(&pudc->lock, flags); /* DI */
+	pudc->dbg_log[0] = '\0';
+	pudc->dbg_log_count = 0;
+	spin_unlock_irqrestore(&pudc->lock, flags); /* EI */
+#endif /* DEBUG_LOG */
+
+	return len;
+}
+#endif	/* DEBUG */
+
+/*-------------------------------------------------------------------------*/
+static const struct file_operations proc_ops = {
+	.open		= mp200_udcprc_proc_udc_open,
+	.read		= seq_read,
+#ifdef DEBUG
+	.write		= mp200_udcprc_proc_udc_write,
+#endif	/* DEBUG */
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+/*-------------------------------------------------------------------------*/
+static inline void mp200st_udcdev_remove_proc_file(void)
+{
+	remove_proc_entry(proc_filename, NULL);
+
+	return;
+}
+
+/*-------------------------------------------------------------------------*/
+static inline void mp200st_udcdev_create_proc_file(void)
+{
+	struct proc_dir_entry *pde;
+
+	pde = create_proc_entry(proc_filename, 0, NULL);
+	if (pde)
+		pde->proc_fops = &proc_ops;
+
+	return;
+}
+
+/*-------------------------------------------------------------------------*/
+static struct platform_driver udc_driver = {
+	.probe		= mp200_udcdev_probe,
+	.remove		= __exit_p(mp200_udcdev_remove),
+	.suspend	= mp200_udcdev_suspend,
+	.resume		= mp200_udcdev_resume,
+	.driver		= {
+		.owner	= THIS_MODULE,
+		.name	= (char *) driver_name,
+	},
+};
+
+/*-------------------------------------------------------------------------*/
+static inline void __init mp200st_udcdev_ep_init(
+	struct mp200_udc *pudc,
+	struct mp200_ep *pep,
+	u8 *pname)
+{
+	INIT_LIST_HEAD(&pep->queue);
+	strcpy(pep->name, pname);
+	pep->pudc		= pudc;
+	pep->pdesc		= NULL;
+
+	pep->ep.driver_data	= NULL;
+	pep->ep.name		= pep->name;
+	pep->ep.ops		= &mp200_ep_ops;
+#ifdef USB_TRANS_DIVISION
+	pep->ep.maxpacket	= 512;
+#else /* USB_TRANS_DIVISION */
+	pep->ep.maxpacket	= 1024;
+#endif /* USB_TRANS_DIVISION */
+
+	return;
+}
+
+/*-------------------------------------------------------------------------*/
+static char g_ep0_name[]    = "ep0";
+static char g_ep1in_name[]  = "ep1in";
+static char g_ep1out_name[] = "ep1out";
+static char g_ep2in_name[]  = "ep2in";
+static char g_ep2out_name[] = "ep2out";
+static char g_ep3in_name[]  = "ep3in";
+static char g_ep3out_name[] = "ep3out";
+static char g_ep4in_name[]  = "ep4in";
+static char g_ep4out_name[] = "ep4out";
+static char g_ep5in_name[]  = "ep5in";
+static char g_ep5out_name[] = "ep5out";
+static char g_ep6in_name[]  = "ep6in";
+static char g_ep6out_name[] = "ep6out";
+static char g_ep7in_name[]  = "ep7in";
+static char g_ep7out_name[] = "ep7out";
+static char g_ep8in_name[]  = "ep8in";
+static char g_ep8out_name[] = "ep8out";
+static char g_ep9in_name[]  = "ep9in";
+static char g_ep9out_name[] = "ep9out";
+static char g_epain_name[]  = "epain";
+static char g_epaout_name[] = "epaout";
+static char g_epbin_name[]  = "epbin";
+static char g_epbout_name[] = "epbout";
+static char g_epcin_name[]  = "epcin";
+static char g_epcout_name[] = "epcout";
+static char g_epdin_name[]  = "epdin";
+static char g_epdout_name[] = "epdout";
+static char g_epein_name[]  = "epein";
+static char g_epeout_name[] = "epeout";
+static char g_epfin_name[]  = "epfin";
+static char g_epfout_name[] = "epfout";
+
+/*-------------------------------------------------------------------------*/
+static char *gp_ep_name[((NUM_ENDPOINTS)*(NUM_DIRECTIONS) - 1)] = {
+	g_ep0_name,
+	g_ep1out_name,
+	g_ep1in_name,
+	g_ep2out_name,
+	g_ep2in_name,
+	g_ep3out_name,
+	g_ep3in_name,
+	g_ep4out_name,
+	g_ep4in_name,
+	g_ep5out_name,
+	g_ep5in_name,
+	g_ep6out_name,
+	g_ep6in_name,
+	g_ep7out_name,
+	g_ep7in_name,
+	g_ep8out_name,
+	g_ep8in_name,
+	g_ep9out_name,
+	g_ep9in_name,
+	g_epaout_name,
+	g_epain_name,
+	g_epbout_name,
+	g_epbin_name,
+	g_epcout_name,
+	g_epcin_name,
+	g_epdout_name,
+	g_epdin_name,
+	g_epeout_name,
+	g_epein_name,
+	g_epfout_name,
+	g_epfin_name,
+};
+
+/*-------------------------------------------------------------------------*/
+static inline int __init mp200st_udcdev_udc_context_init(
+	struct mp200_udc *pudc,
+	struct platform_device *pdev)
+{
+	int	i;
+	struct mp200_ep *pep = &pudc->ep[0];
+
+	/* init irq lock */
+	spin_lock_init(&pudc->lock);
+	pudc->potg_reg		= (T_OTG_REGS *)IO_ADDRESS(MP200_USB_BASE);
+	pudc->softconnect	= 0;
+	pudc->usb_suspended	= 0;
+	pudc->linux_suspended	= 0;
+	pudc->self_powered	= 1;
+	pudc->remote_wakeup	= 0;
+	pudc->devstate		= USB_STATE_NOTATTACHED;
+	pudc->pfc_reg		= (T_FC_REGS *)(&pudc->potg_reg->USBCMD);
+	pudc->pdev		= pdev;
+	pudc->mA		= 0;
+
+
+	/* init EP0 (IN OUT Both) */
+	mp200st_udcdev_ep_init(pudc, &pudc->ep[0], gp_ep_name[0]);
+
+	pudc->ep[0].ep.maxpacket = 64;
+
+	pudc->pdev->dev.coherent_dma_mask = 0xFFFFFFFF;
+
+	/* init gadget */
+	pudc->gadget.ops = &mp200_gadget_ops;
+	pudc->gadget.ep0 = &pudc->ep[0].ep;
+	pudc->gadget.speed = USB_SPEED_UNKNOWN;
+	pudc->gadget.name = driver_name;
+	pudc->gadget.is_dualspeed = 1;
+
+	/* init dev */
+	device_initialize(&pudc->gadget.dev);
+
+	/* init gadget dev */
+	strcpy(pudc->gadget.dev.bus_id, "gadget");
+	pudc->gadget.dev.release = mp200_udcgaddev_release;
+	pudc->gadget.dev.parent = &pdev->dev;
+	pudc->gadget.dev.dma_mask = pdev->dev.dma_mask;
+
+	/* init EP0_list (no use)*/
+	INIT_LIST_HEAD(&pudc->gadget.ep0->ep_list);
+
+	/* init EP1-15_list */
+	INIT_LIST_HEAD(&pudc->gadget.ep_list);
+
+	/* init EP1-15 (IN OUT) */
+	for (i = 1 ; i < ((NUM_ENDPOINTS)*(NUM_DIRECTIONS) - 1) ; i++) {
+		mp200st_udcdev_ep_init(pudc, &pudc->ep[i], gp_ep_name[i]);
+		list_add_tail(&pudc->ep[i].ep.ep_list, &pudc->gadget.ep_list);
+	}
+
+	/*	IO<->DMA memory alloc */
+	if (pep->mem.p_vadrs == NULL) {
+		pep->mem.p_vadrs = dma_alloc_coherent(&pudc->pdev->dev,
+			UDC_EP_AUTO_BUFSIZE, &pep->mem.padrs,
+			GFP_KERNEL|__GFP_DMA);
+
+		if (pep->mem.p_vadrs == NULL) {
+			ERR("%s dma_alloc_coherent NOMEM\n", __func__);
+			return -ENOMEM;
+		}
+		MEM_LOG(pudc, "%s dma_alloc_coherent(%08x)\n", __func__,
+			(int)pep->mem.p_vadrs);
+	}
+
+	return 0;
+}
+
+/*-------------------------------------------------------------------------*/
+static inline int __init mp200st_udcdev_dtd_manage_init(
+	struct mp200_udc *pudc,
+	struct platform_device *pdev,
+	T_DTD_MANAGEMENT dTD_Manage[NUM_DIRECTIONS][
+		NUM_ENDPOINTS][SUPPORT_DTD_NUM],
+	T_MEMORY_VP_INFO *p_align_mem,
+	T_MEMORY_VP_INFO *p_mem,
+	size_t alloc_mem_size,
+	size_t align_size)
+{
+	int			i, j, k;
+	int			status;
+	dma_addr_t		padrs;		/* phy address */
+	u8			*p_vadrs;	/* virtual address */
+	T_DTD_MANAGEMENT	*p_dTD_m;
+
+	/* dTD */
+	status = mp200st_udcdev_dtd_dqh_mem_init(pudc, pdev, p_align_mem,
+		p_mem, alloc_mem_size, align_size);
+	if (status < 0)
+		return status;
+
+	/* init dTD MANAGEMENT */
+	padrs  = p_mem->padrs;
+	p_vadrs = (u8 *)p_mem->p_vadrs;
+
+	for (i = 0; i < NUM_DIRECTIONS; i++) {
+		for (j = 0; j < NUM_ENDPOINTS; j++) {
+			for (k = 0; k < SUPPORT_DTD_NUM; k++) {
+				p_dTD_m = &(dTD_Manage[i][j][k]);
+				p_dTD_m->mem_info.padrs = padrs;
+				p_dTD_m->mem_info.p_vadrs = (u32 *)p_vadrs;
+
+				padrs += sizeof(T_EP_TRANS_DESC);
+				p_vadrs += sizeof(T_EP_TRANS_DESC);
+			}
+		}
+	}
+
+	return 0;
+}
+
+/*-------------------------------------------------------------------------*/
+static T_ENDPOINT_QUEUE_HEAD *
+ mp200st_udc_ep_get_dQH_adrs(
+	struct mp200_udc *pudc,
+	u8 ep_adrs,
+	bool bphy)
+{
+	u32		data;
+	T_ENDPOINT_QUEUE_HEAD *p_ep_dQH;
+
+	data = (ep_adrs & USB_ENDPOINT_NUMBER_MASK) << 1;
+	if (ep_adrs & USB_DIR_IN)
+		data++;
+
+	if (bphy == FALSE)
+		p_ep_dQH = (T_ENDPOINT_QUEUE_HEAD *)pudc->dQH.p_vadrs;
+	else
+		p_ep_dQH = (T_ENDPOINT_QUEUE_HEAD *)pudc->dQH.padrs;
+
+	p_ep_dQH += data;
+
+	return p_ep_dQH;
+}
+
+/*-------------------------------------------------------------------------*/
+static inline void mp200st_udc_check_vbus(struct mp200_udc *pudc)
+{
+	int		nret;
+	int		is_active;
+	u8		pwc_state = 0;
+
+#ifdef	CONFIG_MP200_EM1_DKIT
+	nret = mp200st_udc_trans_read(DA9052_STATUSA_REG, &pwc_state);
+	if (nret < 0)
+		return;
+
+	if (pwc_state & PWC_PSW_VBUS) {
+		/*  VBUS ON */
+		is_active = 1;
+	} else{
+		/*  VBUS OFF */
+		is_active = 0;
+	}
+#else
+	/* --------------------------------------------------------------- */
+	/*  interrupt clear */
+	pwc_write(PWC_CLRFACT3, PWC_CLRFACT3_VBUS, PWC_CLRFACT3_VBUS);
+
+	/* --------------------------------------------------------------- */
+	/*  VBUS Check */
+	nret = mp200st_udc_trans_read(PWC_PSW_STATE, &pwc_state);
+	if (nret < 0)
+		return;
+
+	/* --------------------------------------------------------------- */
+	/*  interrupt setting */
+	if (pwc_state & PWC_PSW_VBUS) {
+		/*  edge of fall down */
+		pwc_write(PWC_DETMOD3H,
+			PWC_VBUS_FALLING_EDGE,
+			PWC_DETMOD3H_VBUS_MASK);
+	} else{
+		/*  edge of stand up */
+		pwc_write(PWC_DETMOD3H,
+			PWC_VBUS_RISING_EDGE,
+			PWC_DETMOD3H_VBUS_MASK);
+	}
+
+	/* --------------------------------------------------------------- */
+	/*  chattering */
+	mdelay(VBUS_CHATTERING_MDELAY);
+	nret = mp200st_udc_trans_read(PWC_PSW_STATE, &pwc_state);
+	if (nret < 0)
+		return;
+
+	if (pwc_state & PWC_PSW_VBUS) {
+		/* ---------------------------------------------------------- */
+		/*  VBUS ON */
+		pwc_write(PWC_DETMOD3H, PWC_VBUS_FALLING_EDGE,
+			PWC_DETMOD3H_VBUS_MASK);	/*  edge of fall down */
+		is_active = 1;
+	} else{
+		/* ---------------------------------------------------------- */
+		/*  VBUS OFF */
+		pwc_write(PWC_DETMOD3H, PWC_VBUS_RISING_EDGE,
+			PWC_DETMOD3H_VBUS_MASK);	/*  edge of stand up */
+		is_active = 0;
+	}
+#endif
+
+	mp200st_udc_vbus_change(pudc, is_active);
+
+	return;
+}
+
+#define CTRL_REQUEST_REPEATED_COUNT	100000
+
+/*-------------------------------------------------------------------------*/
+/*	SetupDevReqRead */
+static inline void mp200st_udcint_read_ctrl_request(
+	struct mp200_udc *pudc,
+	u8 ep_adrs,
+	struct usb_ctrlrequest *pctrl)
+{
+	u32			data;
+	T_ENDPOINT_QUEUE_HEAD	*p_dQH;
+	int			i;
+
+	for (i = 0; i < CTRL_REQUEST_REPEATED_COUNT; i++) {
+		mp200st_udc_set_bit(&pudc->pfc_reg->USBCMD, USBCMD_SUTW);
+
+		p_dQH = mp200st_udc_ep_get_dQH_adrs(pudc, ep_adrs, FALSE);
+
+		/*	read device request */
+		memcpy(pctrl, p_dQH->setup_buf, sizeof(struct usb_ctrlrequest));
+
+		data = mp200st_udc_readl(&pudc->pfc_reg->USBCMD);
+		if (data & USBCMD_SUTW)
+			break;
+	}
+
+	mp200st_udc_clear_bit(&pudc->pfc_reg->USBCMD, USBCMD_SUTW);
+
+	return;
+}
+
+/*-------------------------------------------------------------------------*/
+static inline int mp200st_udcint_set_address(
+	struct mp200_udc *pudc,
+	u8 devaddr,
+	bool bafter_ep0in)
+{
+	u32	data;
+
+	/*	DevStat */
+	if (devaddr > 0)
+		pudc->devstate = USB_STATE_ADDRESS;
+	else
+		pudc->devstate = USB_STATE_DEFAULT;
+
+
+	/*	EP0 status in after SetAddress */
+	if (bafter_ep0in) {
+		data = ((devaddr << DEVICEADDR_USBADR_SHIFT)
+			| DEVICEADDR_USBADRA);
+	} else {
+		data = ((devaddr << DEVICEADDR_USBADR_SHIFT));
+	}
+
+	return mp200st_udc_ulc_chk_writel(pudc, &pudc->pfc_reg->DEVICEADDR,
+	 data);
+}
+
+/*-------------------------------------------------------------------------*/
+static inline int mp200st_udcint_req_set_address(struct mp200_udc *pudc)
+{
+	u8	devaddr = UDC_LE16_GET_L(pudc->ctrl.wValue);
+	int	status;
+
+	status = mp200st_udcint_set_address(pudc, devaddr, TRUE);
+
+	if (status < 0)
+		return status;
+
+	/*	make req */
+	mp200st_udcint_status_packet(pudc);
+
+	return 0;
+}
+
+/*-------------------------------------------------------------------------*/
+static inline void mp200st_udcint_req_set_configuration(
+	struct mp200_udc *pudc)
+{
+	u8	confnum = UDC_LE16_GET_L(pudc->ctrl.wValue);
+
+	if (confnum > 0)
+		pudc->devstate = USB_STATE_CONFIGURED;
+	else
+		pudc->devstate = USB_STATE_ADDRESS;
+
+	return;
+}
+
+
+/*-------------------------------------------------------------------------*/
+/*	Endpoint STALL get */
+static bool
+ mp200st_udc_get_endpoint_stall(
+	struct mp200_udc *pudc,
+	u8 ep_adrs)
+{
+	u32	data;
+	bool	bstall = FALSE;
+
+	data = mp200st_udc_readl(&pudc->pfc_reg->ENDPTCTRL[(ep_adrs
+			& USB_ENDPOINT_NUMBER_MASK)]);
+
+	if ((ep_adrs & USB_ENDPOINT_DIR_MASK) == USB_DIR_OUT) {
+		if (data & ENDPTCTRL_RXS)
+			bstall = TRUE;
+	} else{
+		if (data & ENDPTCTRL_TXS)
+			bstall = TRUE;
+	}
+
+	return bstall;
+}
+
+/*-------------------------------------------------------------------------*/
+/*	Endpoint STALL set */
+static void mp200st_udc_set_endpoint_stall(
+	struct mp200_udc *pudc,
+	u8 ep_adrs,
+	bool bstall)
+{
+	u32	data;
+
+	if ((ep_adrs & USB_ENDPOINT_DIR_MASK) == USB_DIR_OUT)
+		data = ENDPTCTRL_RXS;
+	else
+		data = ENDPTCTRL_TXS;
+
+	if (bstall) {
+		mp200st_udc_ulc_chk_set_bit(
+			pudc,
+			&pudc->pfc_reg->ENDPTCTRL[(ep_adrs
+				& USB_ENDPOINT_NUMBER_MASK)],
+			data);
+	} else {
+		mp200st_udc_ulc_chk_clear_bit(
+			pudc,
+			&pudc->pfc_reg->ENDPTCTRL[(ep_adrs
+				& USB_ENDPOINT_NUMBER_MASK)],
+			data);
+	}
+
+	return;
+}
+
+/*-------------------------------------------------------------------------*/
+static void mp200st_udc_set_endpoint_toggle_reset(struct mp200_udc *pudc,
+	u8 ep_adrs)
+{
+	u32	data;
+
+	if ((ep_adrs & USB_ENDPOINT_DIR_MASK) == USB_DIR_OUT)
+		data = ENDPTCTRL_RXR;
+	else
+		data = ENDPTCTRL_TXR;
+
+	mp200st_udc_ulc_chk_set_bit(pudc,
+		&pudc->pfc_reg->ENDPTCTRL[(ep_adrs & USB_ENDPOINT_NUMBER_MASK)],
+		data);
+
+	return;
+}
+
+/*-------------------------------------------------------------------------*/
+static void mp200st_udcint_EP0_complete(struct usb_ep *puep,
+	struct usb_request *pureq)
+{
+	struct mp200_ep		*pep;
+	struct mp200_req	*preq;
+	struct mp200_udc	*pudc;
+
+	if ((puep == NULL) || (pureq == NULL))
+		return ;
+
+	if (pureq->status != 0) {
+		DBG("%s (pureq->status != 0)(%d)\n", __func__, pureq->status);
+		return ;
+	}
+
+	pep = container_of(puep, struct mp200_ep, ep);
+	preq = container_of(pureq, struct mp200_req, req);
+
+	/* udc */
+	pudc = pep->pudc;
+
+	/* status after */
+	if ((pudc->ctrl.bRequestType & USB_TYPE_MASK) == USB_TYPE_STANDARD) {
+		switch (pudc->ctrl.bRequest) {
+		case USB_REQ_SET_FEATURE:
+			mp200st_udcint_req_feature_complete(pudc, TRUE);
+			break;
+		default:
+			break;
+		}
+	}
+
+	return ;
+}
+
+/*-------------------------------------------------------------------------*/
+static inline int mp200st_udcint_req_feature(
+	struct mp200_udc *pudc,
+	bool bset)
+{
+
+	if ((pudc->ctrl.bRequestType & USB_RECIP_MASK) == USB_RECIP_DEVICE) {
+
+		switch (le16_to_cpu(pudc->ctrl.wValue)) {
+		case USB_DEVICE_TEST_MODE:
+			if (!bset)
+				return -EOPNOTSUPP;
+			break;
+		case USB_DEVICE_REMOTE_WAKEUP:
+			pudc->remote_wakeup = bset;
+			break;
+		case USB_DEVICE_B_HNP_ENABLE:
+			pudc->gadget.b_hnp_enable = bset;
+			break;
+		case USB_DEVICE_A_HNP_SUPPORT:
+			pudc->gadget.a_hnp_support = bset;
+			break;
+		case USB_DEVICE_A_ALT_HNP_SUPPORT:
+			pudc->gadget.a_alt_hnp_support = bset;
+			break;
+		default:
+			return -EOPNOTSUPP;
+		}
+
+	} else if ((pudc->ctrl.bRequestType
+			& USB_RECIP_MASK) == USB_RECIP_ENDPOINT) {
+		/* clear endpoint halt */
+		mp200st_udc_set_endpoint_stall(pudc,
+			UDC_LE16_GET_L(pudc->ctrl.wIndex), bset);
+		if (bset == FALSE) {
+			mp200st_udc_set_endpoint_toggle_reset(pudc,
+				UDC_LE16_GET_L(pudc->ctrl.wIndex));
+		}
+	} else{
+		return -EOPNOTSUPP;
+	}
+
+	/*	status in (Not STALL) */
+	mp200st_udcint_status_packet(pudc);
+
+	return 0;
+}
+
+/*-------------------------------------------------------------------------*/
+static inline int mp200st_udcint_req_get_status(struct mp200_udc *pudc)
+{
+	u16		req_status_data = 0;
+	unsigned	length;
+
+	/*	Data Low */
+	if ((pudc->ctrl.bRequestType & USB_RECIP_MASK) == USB_RECIP_DEVICE) {
+
+		if (pudc->self_powered)
+			req_status_data |= (1 << USB_DEVICE_SELF_POWERED);
+
+		if (pudc->remote_wakeup)
+			req_status_data |= (1 << USB_DEVICE_REMOTE_WAKEUP);
+
+	} else if ((pudc->ctrl.bRequestType
+			& USB_RECIP_MASK) == USB_RECIP_ENDPOINT) {
+		/* endpoint halt */
+
+		/* check EP */
+		if (mp200st_udc_get_endpoint_stall(pudc,
+				UDC_LE16_GET_L(pudc->ctrl.wIndex))) {
+			req_status_data |= (1 << USB_ENDPOINT_HALT);
+		}
+	}
+
+	/*	copy DMA mem */
+	*((u16 *)pudc->ep0_mem.p_vadrs) = cpu_to_le16(req_status_data);
+
+	length = min((u16)le16_to_cpu(pudc->ctrl.wLength),
+		(u16)UDC_EP0_BUFSIZE);
+
+	/* data in (Not STALL) */
+	mp200st_udcint_data_packet(pudc, pudc->ep0_mem.p_vadrs, length,
+		pudc->ep0_mem.padrs);
+
+	return 0;
+}
+
+/*-------------------------------------------------------------------------*/
+static inline void mp200st_udcint_EP0_setup_done(struct mp200_udc *pudc)
+{
+	int	status = -EINVAL;
+	bool	bcall_driver_setup = TRUE;
+
+	DBG_LOG(pudc, "SETUP DONE NUKE\n");
+	mp200st_udc_nuke(pudc, &pudc->ep[0], -ETIME);
+
+	/*	device request */
+	mp200st_udcint_read_ctrl_request(pudc, (0 | USB_DIR_OUT), &pudc->ctrl);
+
+	/*	driver->setup before */
+	if ((pudc->ctrl.bRequestType & USB_TYPE_MASK) == USB_TYPE_STANDARD) {
+		switch (pudc->ctrl.bRequest) {
+		case USB_REQ_SET_ADDRESS:
+			bcall_driver_setup = FALSE;
+			status = mp200st_udcint_req_set_address(pudc);
+			break;
+
+		case USB_REQ_CLEAR_FEATURE:
+			bcall_driver_setup = FALSE;
+			status = mp200st_udcint_req_feature(pudc, FALSE);
+			break;
+
+		case USB_REQ_SET_FEATURE:
+			bcall_driver_setup = FALSE;
+			status = mp200st_udcint_req_feature(pudc, TRUE);
+			break;
+
+		case USB_REQ_GET_STATUS:
+			bcall_driver_setup = FALSE;
+			status = mp200st_udcint_req_get_status(pudc);
+			break;
+
+		default:
+			break;
+		}
+	}
+
+	if (bcall_driver_setup) {
+		spin_unlock(&pudc->lock);
+		status = pudc->pdriver->setup(&pudc->gadget, &pudc->ctrl);
+		spin_lock(&pudc->lock);
+	}
+
+	/*	driver->setup after */
+	if ((pudc->ctrl.bRequestType & USB_TYPE_MASK) == USB_TYPE_STANDARD) {
+		switch (pudc->ctrl.bRequest) {
+		case USB_REQ_SET_CONFIGURATION:
+			/* udc needs to know when ep != 0 is valid */
+			if (status >= 0)
+				mp200st_udcint_req_set_configuration(pudc);
+			break;
+
+		default:
+			break;
+		}
+	}
+
+	if (status < 0) {
+		/* stall */
+		mp200st_udc_set_endpoint_stall(pudc, (0 | USB_DIR_OUT), TRUE);
+		mp200st_udc_set_endpoint_stall(pudc, (0 | USB_DIR_IN), TRUE);
+	}
+
+	return;
+}
+
+/*-------------------------------------------------------------------------*/
+/*  Device Resume */
+static inline void mp200st_udcint_resume_device(struct mp200_udc *pudc)
+{
+	if (pudc->usb_suspended != 0) {
+		pudc->usb_suspended = 0;
+
+		/* ---------------------------------------------------------- */
+		/*  Power Save Mode */
+#ifdef	CONFIG_MP200_EM1_DKIT
+		pwc_write(DA9052_INPUTCONT_REG, 0, PWC_MODESET1_VUSBPS);
+#else
+		pwc_write(PWC_MODESET1, 0, PWC_MODESET1_VUSBPS);
+#endif
+		udelay(POWER_SAVE_MODE_WAIT_TIME);
+
+		/* ---------------------------------------------------------- */
+		/*  Link */
+		mp200st_udc_set_bit(&pudc->pfc_reg->PORTSC[0], PORTSC_FPR);
+		mp200st_udc_writel(&pudc->pfc_reg->USBINTR, USB_FC_INT_ENABLE);
+	}
+}
+
+/*-------------------------------------------------------------------------*/
+static inline void mp200st_udcint_bus_reset(struct mp200_udc *pudc)
+{
+	mp200st_udcint_resume_device(pudc);
+
+	pudc->devstate		= USB_STATE_DEFAULT;
+	pudc->remote_wakeup	= 0;
+
+	mp200st_udc_quiesce(pudc);
+
+	return;
+}
+
+/*-------------------------------------------------------------------------*/
+static inline void mp200st_udcint_resume(struct mp200_udc *pudc)
+{
+	mp200st_udcint_resume_device(pudc);
+
+	if (pudc->pdriver->resume) {
+		spin_unlock(&pudc->lock);
+		pudc->pdriver->resume(&pudc->gadget);
+		spin_lock(&pudc->lock);
+	}
+
+	return;
+}
+
+/*-------------------------------------------------------------------------*/
+/*  USB Suspend */
+static inline void mp200st_udcint_suspend(struct mp200_udc *pudc)
+{
+	u32		data;
+	u32		*p_port;
+
+	/* --------------------------------------------------------------- */
+	/*  VBUS */
+	if (pudc->vbus_active == 0)
+		return;
+
+	switch (pudc->timer_mode[1]) {
+	case TIMER_MODE_INIT:
+	case TIMER_MODE_END:
+		/* ---------------------------------------------------------- */
+		/*  if Device is Default_State then don't care */
+		if (pudc->devstate == USB_STATE_DEFAULT)
+			break;
+
+		/* ---------------------------------------------------------- */
+		/*  Timer Start */
+		pudc->timer_mode[1] = TIMER_MODE_SUSPEND;
+		data = TIMER_COUNT_2_SEC;
+		mp200st_udc_writel(&pudc->potg_reg->GPTIMER1LD, data);
+
+		data = GPTIMER1CTRL_GPTRUN | GPTIMER1CTRL_GPTRST;
+		mp200st_udc_writel(&pudc->potg_reg->GPTIMER1CTRL, data);
+		break;
+
+	case TIMER_MODE_SUSPEND:
+		pudc->timer_mode[1] = TIMER_MODE_END;
+		p_port = &pudc->pfc_reg->PORTSC[0];
+		data = mp200st_udc_readl(p_port);
+		if (data & PORTSC_SUSP) {
+			/* -------------------------------------------------- */
+			/*  Low Power Mode */
+			mp200st_udc_set_bit(p_port, PORTSC_PHCD);
+
+			/* -------------------------------------------------- */
+			/*  SOF interrupt ON */
+			mp200st_udc_writel(&pudc->pfc_reg->USBINTR,
+				USB_FC_INT_SUS_ENABLE);
+
+			/* -------------------------------------------------- */
+			/*  Power Save Mode */
+#ifdef	CONFIG_MP200_EM1_DKIT
+			pwc_write(DA9052_INPUTCONT_REG, PWC_MODESET1_VUSBPS,
+				PWC_MODESET1_VUSBPS);
+#else
+			pwc_write(PWC_MODESET1, PWC_MODESET1_VUSBPS,
+				PWC_MODESET1_VUSBPS);
+#endif
+
+			pudc->usb_suspended = 1;
+			if (pudc->pdriver->suspend) {
+				spin_unlock(&pudc->lock);
+				pudc->pdriver->suspend(&pudc->gadget);
+				spin_lock(&pudc->lock);
+			}
+		} else{
+			pudc->usb_suspended = 0;
+		}
+		break;
+
+	default:
+		break;
+	}
+}
+
+/*-------------------------------------------------------------------------*/
+static inline void mp200st_udcint_timer_1(struct mp200_udc *pudc)
+{
+	switch (pudc->timer_mode[1]) {
+	case TIMER_MODE_SUSPEND:
+		mp200st_udcint_suspend(pudc);
+		break;
+
+	default:
+		break;
+	}
+}
+
+#ifdef DUMMY_PRIME
+/*-------------------------------------------------------------------------*/
+static inline void mp200st_udcint_dummy_prime_complete(
+	struct mp200_udc *pudc,
+	u8 ep_adrs)	/*  __fn__ */
+{
+#ifdef DUMMY_PRIME_NAK_INT
+	u32	epnak;
+#endif /* DUMMY_PRIME_NAK_INT */
+#ifdef DUMMY_PRIME_NOT_EP0
+	u8	epnum = ep_adrs & USB_ENDPOINT_NUMBER_MASK;
+#endif /* DUMMY_PRIME_NAK_INT */
+
+	/*	check */
+
+#ifdef DUMMY_PRIME_NOT_EP0
+
+	if (epnum != 0) {
+		mp200st_udc_ulc_chk_writel(pudc, &pudc->pfc_reg->ENDPTNAK,
+			ENDPT_BIT_POS(ep_adrs));
+		pudc->dummy_prime_transferring &= ~(ENDPT_BIT_POS(ep_adrs));
+
+  #ifdef DUMMY_PRIME_NAK_INT
+		epnak = mp200st_udc_readl(&pudc->pfc_reg->ENDPTNAK);
+		epnak &= ~(ENDPT_BIT_POS(0 | USB_DIR_IN)
+			| ENDPT_BIT_POS(0 | USB_DIR_OUT));
+
+		if (!(epnak & pudc->dummy_prime_waiting))
+			mp200st_udc_ulc_chk_writel(pudc,
+				&pudc->pfc_reg->ENDPTNAKEN,
+				pudc->dummy_prime_waiting);
+  #endif /* DUMMY_PRIME_NAK_INT */
+
+	}
+
+#else /* DUMMY_PRIME_NOT_EP0 */
+
+	mp200st_udc_ulc_chk_writel(pudc, &pudc->pfc_reg->ENDPTNAK,
+		ENDPT_BIT_POS(ep_adrs));
+	pudc->dummy_prime_transferring &= ~(ENDPT_BIT_POS(ep_adrs));
+
+  #ifdef DUMMY_PRIME_NAK_INT
+	epnak = mp200st_udc_readl(&pudc->pfc_reg->ENDPTNAK);
+	if (!(epnak & pudc->dummy_prime_waiting)) {
+		mp200st_udc_ulc_chk_writel(pudc, &pudc->pfc_reg->ENDPTNAKEN,
+			pudc->dummy_prime_waiting);
+	}
+  #endif /* DUMMY_PRIME_NAK_INT */
+
+#endif /* DUMMY_PRIME_NOT_EP0 */
+}
+
+/*-------------------------------------------------------------------------*/
+static inline void mp200st_udcint_dummy_prime_check(
+	struct mp200_udc *pudc)
+{
+	int		i;
+	u32		epnak;
+	u32		epnak_prime;
+	u32		ep_adrs;
+
+	if (pudc->dummy_prime_transferring == 0) {
+		epnak = mp200st_udc_readl(&pudc->pfc_reg->ENDPTNAK);
+		epnak_prime = epnak & pudc->dummy_prime_waiting;
+
+		if (epnak_prime != 0) {
+ #ifdef DUMMY_PRIME_NAK_INT
+			mp200st_udc_ulc_chk_writel(pudc,
+				&pudc->pfc_reg->ENDPTNAKEN, 0);
+ #endif /* DUMMY_PRIME_NAK_INT */
+
+			/* in (EP0-EP15) */
+			for (i = 0; (i < NUM_ENDPOINTS); i++) {
+
+				/*	IN check */
+				ep_adrs = (i | USB_DIR_IN);
+
+				if (epnak_prime & ENDPT_BIT_POS(ep_adrs)) {
+					mp200st_udc_set_dmy_prime_transferring(
+					 pudc, ENDPT_BIT_POS(ep_adrs));
+					break;
+				}
+
+				/* OUT check */
+				ep_adrs = (i | USB_DIR_OUT);
+
+				if (epnak_prime & ENDPT_BIT_POS(ep_adrs)) {
+					mp200st_udc_set_dmy_prime_transferring(
+					 pudc, ENDPT_BIT_POS(ep_adrs));
+					break;
+				}
+			}
+		}
+
+	}
+}
+#endif	/*  DUMMY_PRIME */
+
+/*-------------------------------------------------------------------------*/
+static inline void mp200st_udcint_endpt_complete(struct mp200_udc *pudc,
+	u8 ep_adrs)
+{
+
+#ifdef DUMMY_PRIME
+	mp200st_udcint_dummy_prime_complete(pudc, ep_adrs);
+#endif	/*  DUMMY_PRIME */
+
+	mp200st_udc_done_transfer(pudc, ep_adrs);
+
+	return;
+}
+
+
+/*-------------------------------------------------------------------------*/
+static inline void mp200st_udcint_usb_interrupt(struct mp200_udc *pudc)
+{
+	u32	intr_status;
+	u32	endpt_setup;
+	u32	endpt_complete;
+	int	i;
+
+	/* --------------------------------------------------------------- */
+	/*  Read & Clear Interrupt Status */
+	intr_status = mp200st_udc_readl(&pudc->pfc_reg->USBSTS);
+	mp200st_udc_writel(&pudc->pfc_reg->USBSTS, intr_status);
+
+	endpt_setup = mp200st_udc_readl(&pudc->pfc_reg->ENDPTSETUPSTAT);
+	mp200st_udc_writel(&pudc->pfc_reg->ENDPTSETUPSTAT, endpt_setup);
+
+	endpt_complete = mp200st_udc_readl(&pudc->pfc_reg->ENDPTCOMPLETE);
+	mp200st_udc_writel(&pudc->pfc_reg->ENDPTCOMPLETE, endpt_complete);
+
+	/* --------------------------------------------------------------- */
+	/*  Debug Message */
+	if (endpt_setup)
+		DBG_LOG(pudc, "SETUP(%08x)\n", endpt_setup);
+
+	if (endpt_complete)
+		DBG_LOG(pudc, "COMP(%08x)\n", endpt_complete);
+
+	/* --------------------------------------------------------------- */
+	/*  Endpoint Complete */
+	if (endpt_complete) {
+		u32	out_done;
+		u32	in_done;
+
+		out_done = (endpt_complete & ENDPTCOMPLETE_ERCE)
+		 >> ENDPTCOMPLETE_ERCE_SHIFT;
+		in_done = (endpt_complete & ENDPTCOMPLETE_ETCE)
+		 >> ENDPTCOMPLETE_ETCE_SHIFT;
+
+		if (pudc->ctrl.bRequestType & USB_DIR_IN) {
+			for (i = 0; (out_done | in_done) > 0; i++) {
+				if (in_done & 0x01) {
+					mp200st_udcint_endpt_complete(pudc,
+						(i | USB_DIR_IN));
+				}
+				if (out_done & 0x01) {
+					mp200st_udcint_endpt_complete(pudc,
+						(i | USB_DIR_OUT));
+				}
+				out_done = out_done >> 1;
+				in_done = in_done >> 1;
+			}
+		} else{
+			for (i = 0; (out_done | in_done) > 0; i++) {
+				if (out_done & 0x01) {
+					mp200st_udcint_endpt_complete(pudc,
+						(i | USB_DIR_OUT));
+				}
+				if (in_done & 0x01) {
+					mp200st_udcint_endpt_complete(pudc,
+						(i | USB_DIR_IN));
+				}
+				out_done = out_done >> 1;
+				in_done = in_done >> 1;
+			}
+		}
+	}
+
+	/* SETUP interrupt (High Frequency) (EP0 only) */
+	if (endpt_setup & ENDPTSETUPSTAT_ENDPTSETUPSTAT_EP0)
+		mp200st_udcint_EP0_setup_done(pudc);
+
+	/* BUS RESET interrupt (Low Frequency) */
+	if (intr_status & USBSTS_URI) {
+		mp200st_udcint_bus_reset(pudc);
+	} else if (intr_status & USBSTS_TI1) {
+		mp200st_udcint_timer_1(pudc);
+		intr_status = 0;
+	}
+
+	if (intr_status & USBSTS_SLI) {
+		if (pudc->usb_suspended == 0)
+			mp200st_udcint_suspend(pudc);
+		else
+			DBG("SUSPEND -> SUSPEND ERR\n");
+	}
+
+	/* PORT CHANGE(RESUME) interrupt (Low Frequency) */
+	if (intr_status & USBSTS_PCI) {
+		if (pudc->gadget.speed == USB_SPEED_UNKNOWN)
+			pudc->gadget.speed = mp200st_udcint_get_speed(pudc);
+
+		if (pudc->usb_suspended)
+			mp200st_udcint_resume(pudc);
+	}
+
+	/* --------------------------------------------------------------- */
+	/*  Suspend -> Resume */
+	if (intr_status & USBSTS_SRI) {
+		if (pudc->usb_suspended)
+			mp200st_udcint_resume(pudc);
+	}
+
+#ifdef DUMMY_PRIME
+	mp200st_udcint_dummy_prime_check(pudc);
+#endif	/*  DUMMY_PRIME */
+
+	return;
+}
+
+/*-------------------------------------------------------------------------*/
+static irqreturn_t mp200_udcint_irq(int irq, void *id_udc)
+{
+	struct mp200_udc	*pudc = &g_udc;
+	unsigned long		flags;
+
+	spin_lock_irqsave(&pudc->lock, flags);
+
+	if (pudc->vbus_active == 0) {
+		spin_unlock_irqrestore(&pudc->lock, flags);
+		return IRQ_NONE;
+	}
+
+	mp200st_udcint_usb_interrupt(pudc);
+
+	spin_unlock_irqrestore(&pudc->lock, flags);
+
+	return IRQ_HANDLED;
+}
+
+/*-------------------------------------------------------------------------*/
+static irqreturn_t mp200_udcint_vbus_irq(int irq, void *id_udc)
+{
+	struct mp200_udc	*pudc = &g_udc;
+	unsigned long		flags;
+
+	spin_lock_irqsave(&pudc->lock, flags);
+	mp200st_udc_check_vbus(pudc);
+	spin_unlock_irqrestore(&pudc->lock, flags);
+
+	return IRQ_HANDLED;
+}
+
+/*-------------------------------------------------------------------------*/
+static int __init mp200_udcdev_probe(struct platform_device *pdev)
+{
+	struct mp200_udc	*pudc = &g_udc;
+	int			status = -ENODEV;
+	unsigned long		flags;
+	struct mp200_ep *pep = &pudc->ep[0];
+
+	memset(pudc, 0, sizeof(struct mp200_udc));
+
+	/* set device_data */
+	platform_set_drvdata(pdev, pudc);
+
+	/* NOTE:  "knows" the order of the resources! */
+	if (!request_mem_region(MP200_USB_BASE, sizeof(T_OTG_REGS),
+			driver_name)) {
+		ERR("request_mem_region failed\n");
+		return -EBUSY;
+	}
+
+	/* a "gadget" abstracts/virtualizes the controller */
+	status = mp200st_udcdev_udc_context_init(pudc, pdev);
+	if (status != 0) {
+		ERR("can't mp200st_udcdev_udc_context_init, err %d\n", status);
+		goto cleanup1;
+	}
+
+	/* dQH */
+	status = mp200st_udcdev_dtd_dqh_mem_init(pudc,
+						 pdev,
+						 &pudc->dQH_align_mem,
+						 &pudc->dQH,
+						 DQH_ALLOC_MEMORY_SIZE,
+						 DQH_MEMORY_SIZE);
+	if (status != 0) {
+		ERR("can't mp200st_udcdev_dtd_dqh_mem_init dQH, err %d\n",
+			status);
+		goto cleanup2;
+	}
+
+	/* dTD */
+	status = mp200st_udcdev_dtd_manage_init(pudc,
+						 pdev,
+						 pudc->dTD_Manage,
+						 &pudc->dTD_align_mem,
+						 &pudc->dTD,
+						 DTD_ALLOC_MEMORY_SIZE,
+						 DTD_STRUCT_SIZE);
+	if (status != 0) {
+		ERR("can't mp200st_udcdev_dtd_manage_init dTD, err %d\n",
+			status);
+		goto cleanup3;
+	}
+
+	/* EP0 buf */
+	pudc->ep0_mem.p_vadrs = dma_alloc_coherent(&pudc->pdev->dev,
+						UDC_EP0_BUFSIZE,
+						&pudc->ep0_mem.padrs,
+						GFP_KERNEL|__GFP_DMA);
+	if (pudc->ep0_mem.p_vadrs == NULL) {
+		status = -ENOMEM;
+		ERR("can't dma_alloc_coherent ep0 buf, err %d\n", status);
+		goto cleanup4;
+	}
+	MEM_LOG(pudc, "%s dma_alloc_coherent(%08x)\n", __func__,
+		(int)pudc->ep0_mem.p_vadrs);
+
+	/* USB general purpose IRQ:  ep0, state changes, dma, etc */
+	status = request_irq(
+		UDC_USB_INT,
+		mp200_udcint_irq,
+		IRQF_DISABLED,
+		driver_name,
+		pudc
+	);
+	if (status != 0) {
+		ERR("can't get irq %d, err %d\n", UDC_USB_INT, status);
+		goto cleanup5;
+	}
+
+#ifdef	CONFIG_MP200_EM1_DKIT
+	/*  Clear VBUS Interrupts */
+	pwc_write(DA9052_EVENTA_REG, 0x0a, 0x0a);
+#endif
+	/* USB "VBUS(USBINT)" IRQ */
+	status = request_irq(
+		UDC_VBUS_INT,
+		mp200_udcint_vbus_irq,
+		IRQF_DISABLED,
+		"USB VBUS",
+		pudc
+	);
+	if (status != 0) {
+		ERR("can't get irq %d, err %d\n", UDC_VBUS_INT, status);
+		goto cleanup6;
+	}
+
+#ifdef	CONFIG_MP200_EM1_DKIT
+	status = request_irq(
+		UDC_VBUS_REM_INT,
+		mp200_udcint_vbus_irq,
+		IRQF_DISABLED,
+		"USB VBUS_REM",
+		pudc
+	);
+	if (status != 0) {
+		ERR("can't get irq %d, err %d\n", UDC_VBUS_REM_INT, status);
+		goto cleanup61;
+	}
+#endif
+
+	pudc->usbint_intno = UDC_VBUS_INT;
+
+	/* proc (info) */
+	mp200st_udcdev_create_proc_file();
+
+	/* gadget dev add */
+	status = device_add(&pudc->gadget.dev);
+	if (status != 0) {
+		ERR("can't device_add gadget.dev err %d\n", status);
+		goto cleanup7;
+	}
+
+	/* --------------------------------------------------------------- */
+	/*  VBUS check */
+	/*  at first, checks already connected USB, and already supply VBUS */
+	/*   */
+	spin_lock_irqsave(&pudc->lock, flags);
+	mp200st_udc_check_vbus(pudc);
+	spin_unlock_irqrestore(&pudc->lock, flags);
+
+	/* --------------------------------------------------------------- */
+	/*  VBUS interrupt start */
+#ifndef	CONFIG_MP200_EM1_DKIT
+	pwc_write(PWC_BMASK3, PWC_BMASK3_VBUS, PWC_BMASK3_VBUS);
+#endif
+
+	return 0;
+
+	/* err */
+cleanup7:
+	mp200st_udcdev_remove_proc_file();
+#ifdef	CONFIG_MP200_EM1_DKIT
+	free_irq(UDC_VBUS_REM_INT, pudc);
+cleanup61:
+#endif
+	free_irq(pudc->usbint_intno, pudc);
+
+cleanup6:
+	free_irq(UDC_USB_INT, pudc);
+
+cleanup5:
+	MEM_LOG(pudc, "%s dma_free_coherent(%08x)\n", __func__,
+		(int)pudc->ep0_mem.p_vadrs);
+	dma_free_coherent(&pudc->pdev->dev,
+			  UDC_EP0_BUFSIZE,
+			  pudc->ep0_mem.p_vadrs,
+			  pudc->ep0_mem.padrs);
+	pudc->ep0_mem.p_vadrs = NULL;
+	pudc->ep0_mem.padrs = DMA_ADDR_INVALID;
+
+cleanup4:
+	MEM_LOG(pudc, "%s dma_free_coherent(%08x)\n", __func__,
+		(int)pudc->dTD_align_mem.p_vadrs);
+	dma_free_coherent(&pudc->pdev->dev,
+			  DTD_ALLOC_MEMORY_SIZE,
+			  pudc->dTD_align_mem.p_vadrs,
+			  pudc->dTD_align_mem.padrs);
+	pudc->dTD_align_mem.p_vadrs = NULL;
+	pudc->dTD_align_mem.padrs = DMA_ADDR_INVALID;
+	pudc->dTD.p_vadrs = NULL;
+	pudc->dTD.padrs = DMA_ADDR_INVALID;
+
+cleanup3:
+	MEM_LOG(pudc, "%s dma_free_coherent(%08x)\n", __func__,
+		(int)pudc->dQH_align_mem.p_vadrs);
+	dma_free_coherent(&pudc->pdev->dev,
+			  DQH_ALLOC_MEMORY_SIZE,
+			  pudc->dQH_align_mem.p_vadrs,
+			  pudc->dQH_align_mem.padrs);
+	pudc->dQH_align_mem.p_vadrs = NULL;
+	pudc->dQH_align_mem.padrs = DMA_ADDR_INVALID;
+	pudc->dQH.p_vadrs = NULL;
+	pudc->dQH.padrs = DMA_ADDR_INVALID;
+
+cleanup2:
+	if (pep->mem.p_vadrs != NULL) {
+		MEM_LOG(pudc, "%s dma_free_coherent(%08x)\n", __func__,
+			(int)pep->mem.p_vadrs);
+		dma_free_coherent(&pudc->pdev->dev, UDC_EP_AUTO_BUFSIZE,
+			pep->mem.p_vadrs, pep->mem.padrs);
+		pep->mem.p_vadrs = NULL;
+		pep->mem.padrs = DMA_ADDR_INVALID;
+	}
+	release_mem_region(MP200_USB_BASE, sizeof(T_OTG_REGS));
+
+cleanup1:
+	return status;
+}
+
+/*-------------------------------------------------------------------------*/
+static void mp200_udcgaddev_release(struct device *pgaddev)
+{
+	struct mp200_udc	*pudc;
+
+	pudc = container_of(container_of(pgaddev, struct usb_gadget, dev),
+		struct mp200_udc, gadget);
+	/* gadget exit done */
+	complete(pudc->pdone);
+
+	return;
+}
+
+/*-------------------------------------------------------------------------*/
+static int __exit mp200_udcdev_remove(struct platform_device *pdev)
+{
+	struct mp200_udc	*pudc = platform_get_drvdata(pdev);
+	struct mp200_ep *pep;
+	DECLARE_COMPLETION_ONSTACK(dev_done);
+
+	/* gadget started */
+	if (pudc->pdriver != NULL) {
+		DBG("%s -EBUSY", __func__);
+		return -EBUSY;
+	}
+
+	/* gadget comp wait */
+	pudc->pdone = &dev_done;
+
+	/* proc (info) */
+	mp200st_udcdev_remove_proc_file();
+
+	/* --------------------------------------------------------------- */
+#ifndef	CONFIG_MP200_EM1_DKIT
+	/*  VBUS interrupt end. */
+	pwc_write(PWC_BMASK3, 0, PWC_BMASK3_VBUS);
+#endif
+
+	/* USB "VBUS(USBINT)" IRQ */
+	free_irq(pudc->usbint_intno, pudc);
+#ifdef	CONFIG_MP200_EM1_DKIT
+	free_irq(UDC_VBUS_REM_INT, pudc);
+#endif
+	/* USB general purpose IRQ:  ep0, state changes, dma, etc */
+	free_irq(UDC_USB_INT, pudc);
+
+	/* EP0 buf */
+	MEM_LOG(pudc, "%s dma_free_coherent(%08x)\n", __func__,
+		(int)pudc->ep0_mem.p_vadrs);
+	dma_free_coherent(&pudc->pdev->dev,
+			  UDC_EP0_BUFSIZE,
+			  pudc->ep0_mem.p_vadrs,
+			  pudc->ep0_mem.padrs);
+	pudc->ep0_mem.p_vadrs = NULL;
+	pudc->ep0_mem.padrs = DMA_ADDR_INVALID;
+
+	/* dTD */
+	MEM_LOG(pudc, "%s dma_free_coherent(%08x)\n", __func__,
+		(int)pudc->dTD_align_mem.p_vadrs);
+	dma_free_coherent(&pudc->pdev->dev,
+			  DTD_ALLOC_MEMORY_SIZE,
+			  pudc->dTD_align_mem.p_vadrs,
+			  pudc->dTD_align_mem.padrs);
+	pudc->dTD_align_mem.p_vadrs = NULL;
+	pudc->dTD_align_mem.padrs = DMA_ADDR_INVALID;
+	pudc->dTD.p_vadrs = NULL;
+	pudc->dTD.padrs = DMA_ADDR_INVALID;
+
+	/* dQH */
+	MEM_LOG(pudc, "%s dma_free_coherent(%08x)\n", __func__,
+		(int)pudc->dQH_align_mem.p_vadrs);
+	dma_free_coherent(&pudc->pdev->dev,
+			  DQH_ALLOC_MEMORY_SIZE,
+			  pudc->dQH_align_mem.p_vadrs,
+			  pudc->dQH_align_mem.padrs);
+	pudc->dQH_align_mem.p_vadrs = NULL;
+	pudc->dQH_align_mem.padrs = DMA_ADDR_INVALID;
+	pudc->dQH.p_vadrs = NULL;
+	pudc->dQH.padrs = DMA_ADDR_INVALID;
+
+	/* EP0 buf free */
+	if (pudc->ep[0].mem.p_vadrs != NULL) {
+		MEM_LOG(pudc, "%s dma_free_coherent(%08x)\n", __func__,
+			(int)pudc->ep[0].mem.p_vadrs);
+		dma_free_coherent(&pudc->pdev->dev, UDC_EP_AUTO_BUFSIZE,
+			pudc->ep[0].mem.p_vadrs, pudc->ep[0].mem.padrs);
+		pudc->ep[0].mem.p_vadrs = NULL;
+		pudc->ep[0].mem.padrs = DMA_ADDR_INVALID;
+	}
+
+	/* EP1-15 buf free */
+	list_for_each_entry(pep, &pudc->gadget.ep_list, ep.ep_list) {
+		if (pep->mem.p_vadrs != NULL) {
+			MEM_LOG(pudc, "%s dma_free_coherent(%08x)\n",
+				__func__, (int)pep->mem.p_vadrs);
+			dma_free_coherent(&pudc->pdev->dev,
+				UDC_EP_AUTO_BUFSIZE, pep->mem.p_vadrs,
+				pep->mem.padrs);
+			pep->mem.p_vadrs = NULL;
+			pep->mem.padrs = DMA_ADDR_INVALID;
+		}
+	}
+
+	/* NOTE: release "knows" the order of the resources! */
+	release_mem_region(MP200_USB_BASE, sizeof(T_OTG_REGS));
+
+	/* gadget device_unregister */
+	device_unregister(&pudc->gadget.dev);
+	/* gadget exit comp wait */
+	wait_for_completion(&dev_done);
+
+#ifdef MEMORY_LOG
+	{
+		char tmp[101];
+		int i;
+
+		for (i = 0; i < pudc->mem_log_count; i += 100) {
+			memcpy(tmp, pudc->mem_log+i, 100);
+			tmp[100] = '\0';
+			printk(KERN_DBG "%s", tmp);
+		}
+	}
+#endif /* MEMORY_LOG */
+
+	return 0;
+}
+
+/*-------------------------------------------------------------------------*/
+static int mp200_udcdev_suspend(struct platform_device *pdev,
+	pm_message_t message)
+{
+	struct mp200_udc	*pudc = &g_udc;
+	unsigned long		flags;
+
+	spin_lock_irqsave(&pudc->lock, flags);
+
+	if ((message.event == DEV_SUSPEND_IDLE_1)
+		&& mp200st_udc_can_pullup(pudc)) {
+
+		spin_unlock_irqrestore(&pudc->lock, flags);
+
+		/* USB PULLUP(VBUS ON) & DEV_SUSPEND_IDLE_1 */
+		DBG("%s -EBUSY", __func__);
+		return -EBUSY;
+	}
+	DBG("%s suspend", __func__);
+
+	/* USB STOP */
+	mp200st_udc_linux_suspended_change(pudc, TRUE);
+
+	spin_unlock_irqrestore(&pudc->lock, flags);
+
+	return 0;
+}
+
+/*-------------------------------------------------------------------------*/
+static int mp200_udcdev_resume(struct platform_device *pdev)
+{
+	struct mp200_udc	*pudc = &g_udc;
+	unsigned long		flags;
+
+	spin_lock_irqsave(&pudc->lock, flags);
+	DBG("%s call resume", __func__);
+	/* USB START */
+	pudc->linux_resume = 1;
+	mp200st_udc_linux_suspended_change(pudc, FALSE);
+	spin_unlock_irqrestore(&pudc->lock, flags);
+
+	return 0;
+}
+
+/*-------------------------------------------------------------------------*/
+int usb_gadget_register_driver(struct usb_gadget_driver *pdriver)
+{
+	struct mp200_udc	*pudc = &g_udc;
+	int			status = -ENODEV;
+	unsigned long		flags;
+
+	/* basic sanity tests */
+	if ((pdriver == NULL)
+	   /*  FIXME if otg, check:  driver->is_otg */
+	   || (pdriver->speed < USB_SPEED_FULL)
+	   || (pdriver->bind == NULL)
+	   || (pdriver->setup == NULL)) {
+
+		DBG("%s -EINVAL", __func__);
+		return -EINVAL;
+	}
+
+	if (pudc->potg_reg == NULL) {
+		DBG("%s -ENODEV", __func__);
+		return -ENODEV;
+	}
+
+	spin_lock_irqsave(&pudc->lock, flags);
+
+	if (pudc->pdriver != NULL) {
+		spin_unlock_irqrestore(&pudc->lock, flags);
+		DBG("%s -EBUSY", __func__);
+		return -EBUSY;
+	}
+
+	/* hook up the driver */
+	pdriver->driver.bus = NULL;
+	pudc->pdriver = pdriver;
+	pudc->gadget.dev.driver = &pdriver->driver;
+
+	spin_unlock_irqrestore(&pudc->lock, flags);
+
+	status = pdriver->bind(&pudc->gadget);
+	if (status < 0) {
+		DBG("bind to %s --> %d\n", pdriver->driver.name, status);
+		pudc->gadget.dev.driver = NULL;
+		pudc->pdriver = NULL;
+		return status;
+	}
+	DBG("bound to driver %s\n", pdriver->driver.name);
+
+	/* connect to bus through transceiver */
+	/* reset state */
+	spin_lock_irqsave(&pudc->lock, flags);
+
+	mp200st_udc_soft_connect_change(pudc, TRUE);
+
+	spin_unlock_irqrestore(&pudc->lock, flags);
+
+	return status;
+}
+EXPORT_SYMBOL(usb_gadget_register_driver);
+
+
+/*-------------------------------------------------------------------------*/
+int usb_gadget_unregister_driver(struct usb_gadget_driver *pdriver)
+{
+	struct mp200_udc	*pudc = &g_udc;
+	unsigned long		flags;
+
+	if ((pdriver == NULL)
+	   || (pdriver != pudc->pdriver)
+	   || (pdriver->unbind == NULL)) {
+
+		return -EINVAL;
+	}
+
+	if (pudc->potg_reg == NULL)
+		return -ENODEV;
+
+	spin_lock_irqsave(&pudc->lock, flags);
+
+	mp200st_udc_soft_connect_change(pudc, FALSE);
+
+	spin_unlock_irqrestore(&pudc->lock, flags);
+
+	pdriver->unbind(&pudc->gadget);
+	pudc->gadget.dev.driver = NULL;
+	pudc->pdriver = NULL;
+
+	DBG("unregistered driver '%s'\n", pdriver->driver.name);
+
+	return 0;
+}
+EXPORT_SYMBOL(usb_gadget_unregister_driver);
+
+/*-------------------------------------------------------------------------*/
+static int __init mp200_udc_init(void)
+{
+	return platform_driver_register(&udc_driver);
+}
+
+/*-------------------------------------------------------------------------*/
+static void __exit mp200_udc_exit(void)
+{
+	platform_driver_unregister(&udc_driver);
+
+	return;
+}
+
+module_init(mp200_udc_init);
+module_exit(mp200_udc_exit);
+
+MODULE_DESCRIPTION(DRIVER_DESC);
+MODULE_LICENSE("GPL");
diff --git a/drivers/usb/gadget/mp200_udc.h b/drivers/usb/gadget/mp200_udc.h
new file mode 100644
index 0000000..ea4d784
--- /dev/null
+++ b/drivers/usb/gadget/mp200_udc.h
@@ -0,0 +1,1255 @@
+/*
+ * mp200_udc.h -- for MP200 High speed USB device controller.
+ *  This driver doesn't support OTG.
+ *
+ *  Copyright (C) NEC Electronics Corporation 2009
+ *
+ */
+
+/* ------------------------------------------------------------------------- */
+#ifndef __MP200_UDC_H
+#define __MP200_UDC_H
+
+/* ------------------------------------------------------------------------- */
+/* normal off */
+/*#define	USB_TRANS_DIVISION	*/	/* transfer divide */
+#ifdef USB_TRANS_DIVISION
+	#define	USB_DIVISION_SIZE		(512)
+#endif	/* USB_TRANS_DIVISION */
+
+
+#ifndef bool
+ #define bool int
+#endif
+
+#ifndef TRUE
+ #define TRUE 1
+#endif
+
+#ifndef FALSE
+ #define FALSE 0
+#endif
+
+/*-------------------------------------------------------------------------*/
+
+#ifdef DEBUG
+ #define DBG(stuff...)		printk(KERN_DEBUG "udc: " stuff)
+#else
+ #define DBG(stuff...)		do {} while (0)
+#endif
+
+#ifdef VERBOSE
+ #define VDBG			DBG
+#else
+ #define VDBG(stuff...)		do {} while (0)
+#endif
+
+#define ERR(stuff...)		printk(KERN_ERR "udc: " stuff)
+#define USB_WARN(stuff...)		printk(KERN_WARNING "udc: " stuff)
+#define INFO(stuff...)		printk(KERN_INFO "udc: " stuff)
+
+/*-------------------------------------------------------------------------*/
+/*  BITs */
+#define BIT00		(0x00000001)
+#define BIT01		(0x00000002)
+#define BIT02		(0x00000004)
+#define BIT03		(0x00000008)
+#define BIT04		(0x00000010)
+#define BIT05		(0x00000020)
+#define BIT06		(0x00000040)
+#define BIT07		(0x00000080)
+#define BIT08		(0x00000100)
+#define BIT09		(0x00000200)
+#define BIT10		(0x00000400)
+#define BIT11		(0x00000800)
+#define BIT12		(0x00001000)
+#define BIT13		(0x00002000)
+#define BIT14		(0x00004000)
+#define BIT15		(0x00008000)
+#define BIT16		(0x00010000)
+#define BIT17		(0x00020000)
+#define BIT18		(0x00040000)
+#define BIT19		(0x00080000)
+#define BIT20		(0x00100000)
+#define BIT21		(0x00200000)
+#define BIT22		(0x00400000)
+#define BIT23		(0x00800000)
+#define BIT24		(0x01000000)
+#define BIT25		(0x02000000)
+#define BIT26		(0x04000000)
+#define BIT27		(0x08000000)
+#define BIT28		(0x10000000)
+#define BIT29		(0x20000000)
+#define BIT30		(0x40000000)
+#define BIT31		(0x80000000)
+
+#define BIT31_28	(0xF0000000)
+#define BIT27_24	(0x0F000000)
+#define BIT23_20	(0x00F00000)
+#define BIT19_16	(0x000F0000)
+#define BIT15_12	(0x0000F000)
+#define BIT11_08	(0x00000F00)
+#define BIT07_04	(0x000000F0)
+#define BIT03_00	(0x0000000F)
+
+#define BIT31_24	(0xFF000000)
+#define BIT23_16	(0x00FF0000)
+#define BIT15_08	(0x0000FF00)
+#define BIT07_00	(0x000000FF)
+
+#define BIT31_16	(0xFFFF0000)
+#define BIT15_00	(0x0000FFFF)
+
+#define BIT31_00	(0xFFFFFFFF)
+
+#define BIT31_30	(BIT31|BIT30)
+#define BIT30_29	(BIT30|BIT29)
+#define BIT29_28	(BIT29|BIT28)
+#define BIT28_27	(BIT28|BIT27)
+#define BIT27_26	(BIT27|BIT26)
+#define BIT19_18	(BIT19|BIT18)
+#define BIT15_14	(BIT15|BIT14)
+#define BIT12_11	(BIT12|BIT11)
+#define BIT11_10	(BIT11|BIT10)
+#define BIT03_02	(BIT03|BIT02)
+#define BIT01_00	(BIT01|BIT00)
+
+#define BIT31_25	(0xFE000000)
+#define BIT31_17	(0xFFFE0000)
+#define BIT31_12	(0xFFFFF000)
+#define BIT31_11	(0xFFFFE000)
+#define BIT31_05	(0xFFFFFFE0)
+#define BIT30_24	(0x7F000000)
+#define BIT30_16	(0x7FFF0000)
+#define BIT26_24	(0x07000000)
+#define BIT26_16	(0x07FF0000)
+#define BIT23_17	(0x00FE0000)
+#define BIT23_00	(0x00FFFFFF)
+#define BIT21_16	(0x003F0000)
+#define BIT15_01	(0x0000FFFE)
+#define BIT13_08	(0x00003F00)
+#define BIT13_00	(0x00003FFF)
+#define BIT12_08	(0x00001F00)
+#define BIT11_00	(0x00000FFF)
+#define BIT10_00	(0x000007FF)
+#define BIT07_01	(0x000000FE)
+#define BIT05_00	(0x0000003F)
+#define BIT05_01	(0x0000003E)
+#define BIT04_00	(0x0000001F)
+#define BIT03_01	(0x0000000E)
+
+#define UDC_LE16_GET_L(wValue)	((u8)(((le16_to_cpu(wValue))&(BIT07_00))>>0))
+#define UDC_LE16_GET_H(wValue)	((u8)(((le16_to_cpu(wValue))&(BIT15_08))>>8))
+
+/*-------------------------------------------------------------------------*/
+#define UDC_CHG_PINSEL_USB	CHG_PINSEL_USB
+#define UDC_CHG_PINSEL_USB_HZ	0x00000000
+#define UDC_CHG_PINSEL_USB_USB	0x00000001
+
+#ifdef	CONFIG_MP200_EM1_DKIT
+#define	UDC_USB_INT		INT_USB
+#define	UDC_VBUS_INT		INT_PWC_E_VBUS_DET
+#define	UDC_VBUS_REM_INT	INT_PWC_E_VBUS_REM
+#define UDC_USB_WAKEUP_INT	INT_PWC_IO02
+#else
+#define	UDC_USB_INT		INT_USB
+#define	UDC_VBUS_INT		INT_PWC_DETUSBINT
+#define UDC_USB_WAKEUP_INT	INT_PWC_USBWAKINT
+#endif
+
+#define UDC_PHY_CS		GPIO_USB_CSN
+
+/* ------------------------------------------------------------------------- */
+#ifdef	CONFIG_MP200_EM1_DKIT
+#define PWC_PSW_VBUS		(BIT04)
+#define PWC_MODESET1_VUSBPS	(BIT04)
+
+#else
+#define PWC_PSW_VBUS		(BIT05)
+
+#define PWC_CLRFACT3_VBUS	(BIT07)
+#define PWC_BMASK3_VBUS		(BIT07)
+
+#define PWC_CLRFACT3_WAKEUP	(BIT04)
+#define PWC_BMASK3_WAKEUP	(BIT04)
+
+#define PWC_VBUS_FALLING_EDGE	(BIT07)
+#define PWC_VBUS_RISING_EDGE	(BIT06)
+#define PWC_DETMOD3H_VBUS_MASK	(PWC_VBUS_FALLING_EDGE | PWC_VBUS_RISING_EDGE)
+
+#define PWC_WAKEUP_FALLING_EDGE		(BIT01)
+#define PWC_WAKEUP_RISING_EDGE		(BIT00)
+#define PWC_DETMOD3H_WAKEUP_MASK	(PWC_WAKEUP_FALLING_EDGE | \
+					 PWC_WAKEUP_RISING_EDGE)
+
+#define PWC_MODESET1_VUSBPS		(BIT03)
+
+#define PHY_POWER_BIT			(BIT03)
+#endif
+
+#define POWER_SAVE_MODE_WAIT_TIME	(150)	/* usec */
+
+#define VBUS_CHATTERING_MDELAY		1	/* ms */
+#define VBUS_CHATTERING_RETRY_MDELAY	20	/* ms */
+#define VBUS_POWER_SAVE_MODE_UDELAY	150	/* us */
+
+#define UDC_PHY_CS_MDELAY		1	/* ms */
+#define UDC_LINK_UNRESET_MDELAY		4	/* 150 */
+
+
+/*-------------------------------------------------------------------------*/
+/* ----- (0x000) Identification Register */
+/*  Read Only */
+#define ID_REVISION			(BIT23_16)
+#define ID_NID				(BIT13_08)
+#define ID_ID				(BIT05_00)
+
+/*  ---- (0x004) General Hardware Parameters */
+/*  Read Only */
+#define HWGENERAL_SM			(BIT09)
+#define HWGENERAL_PHYM			(BIT08 | BIT07)
+#define HWGENERAL_PHYW			(BIT06 | BIT05)
+#define HWGENERAL_BWT			(BIT04 | BIT03)
+#define HWGENERAL_CLKC			(BIT02 | BIT01)
+#define HWGENERAL_RT			(BIT00)
+
+/*  ---- (0x008) Host Hardware Parameters */
+/*  Read Only */
+#define HWHOST_TTPER			(BIT31_24)
+#define HWHOST_TTASY			(BIT23_16)
+#define HWHOST_NPORT			(BIT03_01)
+#define HWHOST_HC			(BIT00)
+
+/*  ---- (0x00C) Device Hardware Parameters */
+/*  Read Only */
+#define HWDEVICE_DEVEP			(BIT05_01)
+#define HWDEVICE_DC			(BIT00)
+
+/*  ---- (0x010) TX Buffer Hadware Parameters */
+/*  Read Only */
+#define HWTXBUF_TXLCR			(BIT31)
+#define HWTXBUF_TXCHANADD		(BIT23_16)
+#define HWTXBUF_TXADD			(BIT15_08)
+#define HWTXBUF_TXBURST			(BIT07_00)
+
+/*  ---- (0x014) RX Buffer Hadware Parameters */
+/*  Read Only */
+#define HWRXBUF_RXADD			(BIT15_08)
+#define HWRXBUF_RXBURST			(BIT07_00)
+
+/*  ---- (0x100) Capability Register Length & Host Interface Version Number */
+/*  Read Only */
+#define CH_CAPLENGTH			(BIT07_00)
+#define CH_HCIVERSION			(BIT31_16)
+
+/*  ---- (0x104) Host Control Structural Parameters */
+/*  Read Only */
+#define HCSPARAMS_N_TT			(BIT27_24)
+#define HCSPARAMS_N_PTT			(BIT23_20)
+#define HCSPARAMS_PI			(BIT16)
+#define HCSPARAMS_N_CC			(BIT15_12)
+#define HCSPARAMS_N_PCC			(BIT11_08)
+#define HCSPARAMS_PPC			(BIT04)
+#define HCSPARAMS_N_PORTS		(BIT03_00)
+
+/*  ---- (0x108) Host Control Capability Parameters */
+/*  Read Only */
+#define HCCPARAMS_EECP	(BIT15_08)	/*  EHCI Extended Capabilities
+					    Pointer */
+#define HCCPARAMS_IST	(BIT07_04)	/*  Isochronous Scheduling Threshold */
+#define HCCPARAMS_ASP	(BIT02)		/*  Asynchronous Schedule Park
+					    Capability */
+#define HCCPARAMS_PFL	(BIT01)		/*  Programmable Frame List Flag */
+#define HCCPARAMS_ADC	(BIT00)		/*  64-bit Addressing Capability */
+
+/*  ---- (0x080) General Purpose Timer 0 Load Register */
+/*  Read/Write */
+#define GPTIMER0LD_GPTLD	(BIT23_00)
+
+/*  ---- (0x084) General Purpose Timer 0 Control Register */
+/*  Read Only, Write Only, Read/Write */
+#define GPTIMER0CTRL_GPTRUN	(BIT31)		/*  General Purpose
+						    Timer Run */
+#define GPTIMER0CTRL_GPTRST	(BIT30)		/*  General Purpose
+						    Timer Reset */
+#define GPTIMER0CTRL_GPTMODE	(BIT24)		/*  General Purpose
+						    Timer Mode */
+#define GPTIMER0CTRL_GPTCNT	(BIT23_00)	/*  General Purpose
+						    Timer Counter */
+
+/*  ---- (0x088) General Purpose Timer 1 Load Register */
+/*  Read/Write */
+#define GPTIMER1LD_GPTLD		(BIT23_00)
+
+#define TIMER_COUNT_1_SEC	(1000*1000-1)
+#define TIMER_COUNT_2_SEC	(1000*2000-1)
+
+enum TIMER_MODE {
+	TIMER_MODE_INIT = 0,
+	TIMER_MODE_SUSPEND,
+	TIMER_MODE_RESUME,
+	TIMER_MODE_END
+};
+
+/*  ---- (0x08C) General Purpose Timer 1 Control Register */
+/*  Read Only, Write Only, Read/Write */
+#define GPTIMER1CTRL_GPTRUN	(BIT31)		/*  General Purpose
+						    Timer Run */
+#define GPTIMER1CTRL_GPTRST	(BIT30)		/*  General Purpose
+						    Timer Reset */
+#define GPTIMER1CTRL_GPTMODE	(BIT24)		/*  General Purpose
+						    Timer Mode */
+#define GPTIMER1CTRL_GPTCNT	(BIT23_00)	/*  General Purpose
+						    Timer Counter */
+
+/*  ---- (0x120) Device Interface Version Number */
+/*  Read Only */
+#define DCIVERSION_DCIVERSION	(BIT15_00)
+
+/*  ---- (0x124) Device Control Capability Parameters */
+/*  Read Only */
+#define DCCPARAMS_HC	(BIT08)		/*  Host Capable */
+#define DCCPARAMS_DC	(BIT07)		/*  Device Capable */
+#define DCCPARAMS_DEN	(BIT03_00)	/*  Device Endpoint Number */
+
+/*  ---- (0x140) USB Command Register */
+/*  Read Only, Write Only, Read/Write */
+#define USBCMD_ITC	(BIT23_16)	/*  Inerrupt Threshold Control */
+#define USBCMD_FS2	(BIT15)		/*  Frame List Size */
+#define USBCMD_SUTW	(BIT13)		/*  Setup Trip Wire */
+#define USBCMD_ATDTW	(BIT12)		/*  Add dTD TripWire */
+#define USBCMD_ASPE	(BIT11)		/*  Asynchronous Schedule Park Mode
+					    Enable */
+#define USBCMD_ASP	(BIT09_08)	/*  Asynchronous Schedule Park Mode
+					    Count */
+#define USBCMD_LR	(BIT07)		/*  Light Host/Device Controller
+					    Reset */
+#define USBCMD_IAA	(BIT06)		/*  Interrupt on Async Advanse
+					    Doorbell */
+#define USBCMD_ASE	(BIT05)		/*  Asynchronous Schedule Enable */
+#define USBCMD_PSE	(BIT04)		/*  Periodic Schedule Enable */
+#define USBCMD_FS	(BIT03_02)	/*  Frame List Size */
+#define USBCMD_RST	(BIT01)		/*  Controller Reset */
+#define USBCMD_RS	(BIT00)		/*  Run/Stop */
+
+#define USBCMD_ITC_01	(BIT16)
+
+/*  ---- (0x144) USB Status Register */
+/*  Read Only, Read/Write, -Clear */
+#define USBSTS_TI1	(BIT25)		/*  General Purpose Timer Interrupt 1 */
+#define USBSTS_TI0	(BIT24)		/*  General Purpose Timer Interrupt 0 */
+#define USBSTS_UPI	(BIT19)		/*  USB Host Periodic Interrupt */
+#define USBSTS_UAI	(BIT18)		/*  USB Host Asynchronous Inetrrupt */
+#define USBSTS_NAKI	(BIT16)		/*  NAK Interrupt */
+#define USBSTS_AS	(BIT15)		/*  Asynchronous Schedule Status */
+#define USBSTS_PS	(BIT14)		/*  Periodic Schedule Status */
+#define USBSTS_RCL	(BIT13)		/*  Reclamation */
+#define USBSTS_HCH	(BIT12)		/*  HCHaited */
+#define USBSTS_ULPII	(BIT10)		/*  ULPI Interrupt */
+#define USBSTS_SLI	(BIT08)		/*  DC Suspend */
+#define USBSTS_SRI	(BIT07)		/*  SOF Received */
+#define USBSTS_URI	(BIT06)		/*  USB Reset Received */
+#define USBSTS_AAI	(BIT05)		/*  Interrupt on Async Advance */
+#define USBSTS_SEI	(BIT04)		/*  System Error */
+#define USBSTS_FRI	(BIT03)		/*  Frame List Rollover */
+#define USBSTS_PCI	(BIT02)		/*  Port Change Detect */
+#define USBSTS_UEI	(BIT01)		/*  USB Error Interrupt */
+#define USBSTS_UI	(BIT00)		/*  USB Interrupt */
+
+/*  ---- (0x148) USB Interrupt Enable Register */
+/*  Read/Write */
+#define USBINTR_TIE1	(BIT25)		/*  General Purpose Timer Interrupt
+					    Enable 1 */
+#define USBINTR_TIE0	(BIT24)		/*  General Purpose Timer Interrupt
+					    Enable 0 */
+#define USBINTR_UPIE	(BIT19)		/*  USB Host Periodic Interrupt
+					    Enable */
+#define USBINTR_UAIE	(BIT18)		/*  USB Host Asynchronous Inetrrupt
+					    Enable */
+#define USBINTR_NAKE	(BIT16)		/*  NAK Interrupt Enable */
+#define USBINTR_ULPIE	(BIT10)		/*  ULPI Interrupt Enable */
+#define USBINTR_SLE	(BIT08)		/*  DC Suspend Enable */
+#define USBINTR_SRE	(BIT07)		/*  SOF Received Enable */
+#define USBINTR_URE	(BIT06)		/*  USB Reset Received Enable */
+#define USBINTR_AAE	(BIT05)		/*  Interrupt on Async Advance Enable */
+#define USBINTR_SEE	(BIT04)		/*  System Error Enable */
+#define USBINTR_FRE	(BIT03)		/*  Frame List Rollover Enable */
+#define USBINTR_PCE	(BIT02)		/*  Port Change Detect Enable */
+#define USBINTR_UEE	(BIT01)		/*  USB Error Interrupt Enable */
+#define USBINTR_UE	(BIT00)		/*  USB Interrupt Enable */
+
+#define USB_FC_INT_ENABLE	(USBINTR_TIE1 | USBINTR_SLE | USBINTR_URE \
+				 | USBINTR_PCE | USBINTR_UEE | USBINTR_UE)
+
+#define USB_FC_INT_SUS_ENABLE	(USB_FC_INT_ENABLE | USBINTR_SRE)
+
+
+/*  ---- (0x14C) USB Frame Index Register */
+/*    Host:Read/Write */
+/*  Device:Read Only */
+#define FRINDEX_FRINDEX		(BIT13_00)	/*  Frame Index */
+
+/*  ---- (0x154) Host Controller Frame List Base Address */
+/*  ---- (0x154) Device Controller USB Device Address */
+/*  Read/Write */
+#define PERIODICLISTBASE_PERBASE	(BIT31_12)	/*  Base Address(Low) */
+
+#define DEVICEADDR_USBADR		(BIT31_25)	/*  Device Address */
+#define DEVICEADDR_USBADR_SHIFT		(25)		/*  Device
+							    Address_Position */
+#define DEVICEADDR_USBADRA		(BIT24)		/*  Device Address
+							    Advance */
+
+/*  ---- (0x158) Host Controller next Asynchronous Address */
+/*  ---- (0x158) Device Controller Endpoint List Address */
+/*  Read/Write */
+#define ASYNCLISTADDR_ASYBASE	(BIT31_05)	/*  Link Pointer Low(LPL) */
+
+#define ENDPOINTLISTADDR_EPBASE	(BIT31_11)	/*  Endpoint List
+						    Pointer(Low) */
+
+/*  ---- (0x15C) Host Controller Embedded TT Asynchronous Buffer Control */
+/*  Read/Write */
+#define TTCTRL_TTHA		(BIT30_24)
+
+/*  ---- (0x160) Host Controller Embedded TT Asynchronous Buffer Status */
+/*  Read/Write */
+#define BURSTSIZE_TXPBURST	(BIT15_08)	/*  Programmable TX
+						    Burst Length */
+#define BURSTSIZE_RXPBURST	(BIT07_00)	/*  Programmable RX
+						    Burst Length */
+
+/*  ---- (0x164) TX Full Tuning */
+/*  Read/Write */
+#define TXFILLTUNING_TXFIFOTHRES	(BIT21_16)
+#define TXFILLTUNING_TXSCHHEALTH	(BIT12_08)
+#define TXFILLTUNING_TXSCHOH		(BIT07_00)
+
+/*  ---- (0x170) ULPI Viewport */
+/*  Read/Write */
+#define ULPIVIEWPORT_ULPIWU	(BIT31)		/*  ULPI Wakeup */
+#define ULPIVIEWPORT_ULPIRUN	(BIT30)		/*  ULPI Read/Write Run */
+#define ULPIVIEWPORT_ULPIRW	(BIT29)		/*  ULPI Read/Write Control */
+#define ULPIVIEWPORT_ULPISS	(BIT27)		/*  ULPI Sync State */
+#define ULPIVIEWPORT_ULPIPORT	(BIT26_24)	/*  ULPI Port Number */
+#define ULPIVIEWPORT_ULPIADDR	(BIT23_16)	/*  ULPI Data Address */
+#define ULPIVIEWPORT_ULPIDATRD	(BIT15_08)	/*  ULPI Data Read */
+#define ULPIVIEWPORT_ULPIDATWR	(BIT07_00)	/*  ULPI Data Write */
+
+/*  ---- (0x178) Endpoint NACK Received */
+/*  Read/Write Clear */
+#define ENDPTNAK_TXEPTN	(BIT31_16)		/*  TX Endpoint NAK */
+#define ENDPTNAK_RXEPTN	(BIT15_00)		/*  RX Endpoint NAK */
+
+/*  ---- (0x17C) Endpoint NACK Received Interrupt Enable */
+/*  Read/Write Clear */
+#define ENDPTNAKEN_TXEPTNE	(BIT31_16)	/*  TX Endpoint NAK */
+#define ENDPTNAKEN_RXEPTNE	(BIT15_00)	/*  RX Endpoint NAK */
+
+/*  ---- (0x180) Configuration Flag Register */
+
+/*  ---- (0x184_1A0) Port Status */
+/*  ---- (0x184_1A0) Port Status Control */
+/*  Read Only, Read/Write, R/WC */
+#define PORTSC_PTS	(BIT31_30)	/*  Parallel Transceiver Select */
+#define PORTSC_STS	(BIT29)		/*  Serial Transceiver Select */
+#define PORTSC_PTW	(BIT28)		/*  Parallel Transceiver Wide */
+#define PORTSC_PSPD	(BIT27_26)	/*  Port Speed */
+#define PORTSC_PFSC	(BIT24)		/*  Port Force Full Speed Connect */
+#define PORTSC_PHCD	(BIT23)		/*  PHY Low Power Suspned -
+					    Clock Disable */
+#define PORTSC_WKOC	(BIT22)		/*  Wake on Over Current Enable */
+#define PORTSC_WKDC	(BIT21)		/*  Wake on Disconnect Enable */
+#define PORTSC_WKCN	(BIT20)		/*  Wake on Connect Enable */
+#define PORTSC_PTC	(BIT19_16)	/*  Port Test Control */
+#define PORTSC_PIC	(BIT15_14)	/*  Port Indicator Control */
+#define PORTSC_PO	(BIT13)		/*  Port Owner */
+#define PORTSC_PP	(BIT12)		/*  Port Power */
+#define PORTSC_LS	(BIT11_10)	/*  Line Status */
+#define PORTSC_HSP	(BIT09)		/*  High-Speed Port */
+#define PORTSC_PR	(BIT08)		/*  Port Reset */
+#define PORTSC_SUSP	(BIT07)		/*  Suspned */
+#define PORTSC_FPR	(BIT06)		/*  Force Port Resume */
+#define PORTSC_OCC	(BIT05)		/*  Over Current Change */
+#define PORTSC_OCA	(BIT04)		/*  Over Current Active */
+#define PORTSC_PEC	(BIT03)		/*  Port Enable/Disable Change */
+#define PORTSC_PE	(BIT02)		/*  Port Enabled/Disabled */
+#define PORTSC_CSC	(BIT01)		/*  Connect Status Change */
+#define PORTSC_CCS	(BIT00)		/*  Current Connect Status */
+
+#define PORTSC_PSPD_FS	(0)
+#define PORTSC_PSPD_LS	(BIT26)
+#define PORTSC_PSPD_HS	(BIT27)
+
+/*  ---- (0x1A4) OTG Status Control Register */
+/*  Read Only, Read/Write, R/WC */
+#define OTGSC_DPIE	(BIT30)	/*  Data Pulse Interrupt Enable */
+#define OTGSC_1msE	(BIT29)	/*  1 milisecond timer interrupt Enable */
+#define OTGSC_BSEIE	(BIT28)	/*  B Session End Interrupt Enable */
+#define OTGSC_BSVIE	(BIT27)	/*  B Session Valid Interrupt Enable */
+#define OTGSC_ASVIE	(BIT26)	/*  A Session Valid Interrupt Enable */
+#define OTGSC_AVVIE	(BIT25)	/*  A VBus Valid Interrupt Enable */
+#define OTGSC_IDIE	(BIT24)	/*  USB ID Interrupt Enable */
+#define OTGSC_DPIS	(BIT22)	/*  Data Pulse Interrupt Status */
+#define OTGSC_1msS	(BIT21)	/*  1 milisecond timer interrupt Status */
+#define OTGSC_BSEIS	(BIT20)	/*  B Session End Interrupt Status */
+#define OTGSC_BSVIS	(BIT19)	/*  B Session Valid Interrupt Status */
+#define OTGSC_ASVIS	(BIT18)	/*  A Session Valid Interrupt Status */
+#define OTGSC_AVVIS	(BIT17)	/*  A VBus Valid Interrupt Status */
+#define OTGSC_IDIS	(BIT16)	/*  USB ID Interrupt Status */
+#define OTGSC_DPS	(BIT14)	/*  Data Bus Pulsing Status */
+#define OTGSC_1msT	(BIT13)	/*  1 milisecond timer toggle */
+#define OTGSC_BSE	(BIT12)	/*  B Session End */
+#define OTGSC_BSV	(BIT11)	/*  B Session Valid */
+#define OTGSC_ASV	(BIT10)	/*  A Session Valid */
+#define OTGSC_AVV	(BIT09)	/*  A VBus Valid */
+#define OTGSC_ID	(BIT08)	/*  USB ID */
+#define OTGSC_HABA	(BIT07)	/*  Hardware Assist B-Disconnect to A-Connect */
+#define OTGSC_HADP	(BIT06)	/*  Hardware Assist Data-Pulse-Write to Set */
+#define OTGSC_IDPU	(BIT05)	/*  ID Pullup */
+#define OTGSC_DP	(BIT04)	/*  Data Pulsing */
+#define OTGSC_OT	(BIT03)	/*  OTG Termination */
+#define OTGSC_HAAR	(BIT02)	/*  Hardware Assist Auto-Reset */
+#define OTGSC_VC	(BIT01)	/*  VBUS Charge */
+#define OTGSC_VD	(BIT00)	/*  VBUS Discharge */
+
+#define OTG_INT_ENABLE	(OTGSC_BSEIE|OTGSC_BSVIE|OTGSC_ASVIE|OTGSC_AVVIE)
+#define OTG_POWER_INT	(OTGSC_BSEIS|OTGSC_BSVIS|OTGSC_ASVIS|OTGSC_AVVIS)
+
+/*  ---- (0x1A8) USB Deivce Mode Register */
+/*  Read/Write, Read Only */
+#define USBMODE_VBPS	(BIT05)			/*  VBus Power Select */
+#define USBMODE_SDIS	(BIT04)			/*  Stream Disable Mode */
+#define USBMODE_SLOM	(BIT03)			/*  Setup Lockout Mode */
+#define USBMODE_ES	(BIT02)			/*  Endian Select */
+#define USBMODE_CM	(BIT01_00)		/*  Controller Mode */
+
+#define UDBMODE_CM_FC	(BIT01)			/*  Function Mode */
+#define UDBMODE_CM_HC	(BIT01_00)		/*  Host Mode */
+
+/*  ---- (0x1AC) Endpoint Setup Status Register */
+/*  R/WC */
+#define ENDPTSETUPSTAT_ENDPTSETUPSTAT	(BIT15_00)	/* Setup Endpoint
+							   Status */
+#define ENDPTSETUPSTAT_ENDPTSETUPSTAT_EP0	(BIT00)	/* Setup Endpoint
+							   Status EP0 */
+
+/*  ---- (0x1B0) Endpoint Initializetion Register */
+/*  R/WS */
+#define ENDPTPRIME_PETB		(BIT31_16)	/* Prime Endpoint
+						   Transmit Buffer */
+#define ENDPTPRIME_PERB		(BIT15_00)	/* Prime Endpoint
+						   Receive Buffer */
+
+/*  ---- (0x1B4) Endpoint De-Initialize Register */
+/*  R/WS */
+#define ENDPTFLUSH_FETB		(BIT31_16)	/* Flush Endpoint
+						   Transmit Buffer */
+#define ENDPTFLUSH_FERB		(BIT15_00)	/* Flush Endpoint
+						   Receive Buffer */
+
+/*  ---- (0x1B8) Endpoint Status Register */
+/*  Read Only */
+#define ENDPTSTATUS_ETBR	(BIT31_16)	/*  Endpoint Transmit
+						    Buffer Ready */
+#define ENDPTSTATUS_ERBR	(BIT15_00)	/*  Endpoint Receive
+						    Buffer Ready */
+
+/*  ---- (0x1BC) Endpoint Complete Register */
+/*  R/WC */
+#define ENDPTCOMPLETE_ETCE		(BIT31_16)	/* Endpoint Transmit
+							   Complete Event(IN) */
+#define ENDPTCOMPLETE_ERCE		(BIT15_00)	/* Endpoint Receive
+							   Complete Event(OUT)
+							 */
+#define ENDPTCOMPLETE_ETCE_SHIFT	(16)		/* Endpoint Transmit
+							   Complete Event
+							   Position */
+#define ENDPTCOMPLETE_ERCE_SHIFT	(0)		/* Endpoint Receive
+							   Complete Event
+							   Position */
+
+/* ENDPT_BIT_POS macro Introduction */
+/*
+static inline u32
+ ENDPT_BIT_POS(u8 bEndpointAddress)
+{
+	bit_pos = 1 << (bEndpointAddress & USB_ENDPOINT_NUMBER_MASK);
+
+	if ((bEndpointAddress & USB_ENDPOINT_DIR_MASK) == USB_DIR_IN) {
+		bit_pos <<= ENDPTCOMPLETE_ETCE_SHIFT;
+	} else {
+		bit_pos <<= ENDPTCOMPLETE_ERCE_SHIFT;
+	}
+	return bit_pos;
+}
+*/
+
+#define ENDPT_BIT_POS(bEndpointAddress)\
+	((1 << ((bEndpointAddress) & USB_ENDPOINT_NUMBER_MASK)) \
+	<< ((((bEndpointAddress) & USB_ENDPOINT_DIR_MASK) == USB_DIR_IN) \
+		? ENDPTCOMPLETE_ETCE_SHIFT : ENDPTCOMPLETE_ERCE_SHIFT))
+
+/*  ---- (0x1C0) Endpoint Control Register */
+/*  R/WC */
+#define ENDPTCTRL_TXE		(BIT23)		/*  TX Endpoint Enable */
+#define ENDPTCTRL_TXR		(BIT22)		/*  TX Data Toggle Reset */
+#define ENDPTCTRL_TXI		(BIT21)		/*  TX Data Toggle inhibit */
+#define ENDPTCTRL_TXT		(BIT19_18)	/*  TX Endpoint Type */
+#define ENDPTCTRL_TXD		(BIT17)		/*  TX Endpoint Data Source */
+#define ENDPTCTRL_TXS		(BIT16)		/*  TX Endpoint Stall */
+#define ENDPTCTRL_RXE		(BIT07)		/*  RX Endpoint Enable */
+#define ENDPTCTRL_RXR		(BIT06)		/*  RX Data Toggle Reset */
+#define ENDPTCTRL_RXI		(BIT05)		/*  RX Data Toggle inhibit */
+#define ENDPTCTRL_RXT		(BIT03_02)	/*  RX Endpoint Type */
+#define ENDPTCTRL_RXD		(BIT01)		/*  RX Endpoint Data Sink */
+#define ENDPTCTRL_RXS		(BIT00)		/*  RX Endpoint Stall */
+
+#define ENDPTCTRL_TXT_SHIFT	(18)
+#define ENDPTCTRL_RXT_SHIFT	(2)
+
+/*  OTG Control Registers */
+struct _T_OTG_REGS {	/*  ----- offset */
+	u32 ID;			/*  (0x000) Identification Register */
+	u32 HWGENERAL;		/*  (0x004) General Hardware Parameters */
+	u32 HWHOST;		/*  (0x008) Host Hardware Parameters */
+	u32 HWDEVICE;		/*  (0x00C) Device Hardware Parameters */
+	u32 HWTXBUF;		/*  (0x010) TX Buffer Hadware Parameters */
+	u32 HWRXBUF;		/*  (0x014) RX Buffer Hadware Parameters */
+	u32 HWTTTXBUF;		/*  (0x018) TT TX Buffer Hadware Parameters */
+	u32 HWTTRXBUF;		/*  (0x01C) TT RX Buffer Hadware Parameters */
+	u32 Reserved020[24];
+	u32 GPTIMER0LD;		/*  (0x080) General Purpose Timer 0
+					    Load Register */
+	u32 GPTIMER0CTRL;	/*  (0x084) General Purpose Timer 0
+					    Control Register */
+	u32 GPTIMER1LD;		/*  (0x088) General Purpose Timer 1
+					    Load Register */
+	u32 GPTIMER1CTRL;	/*  (0x08C) General Purpose Timer 1
+					    Control Register */
+	u32 Reserved090[28];
+
+	u32 CAPLENGTH_HCIVERSION;	/*  (0x100) Capability Register Length
+					    & Host Interface Version Number */
+	u32 HCSPARAMS;		/*  (0x104) Host Control Structural
+					    Parameters */
+	u32 HCCPARAMS;		/*  (0x108) Host Control Capability
+					    Parameters */
+	u32 Reserved10C[5];
+	u32 DCIVERSION;		/*  (0x120) Device Interface Version Number */
+	u32 DCCPARAMS;		/*  (0x124) Device Control Capability
+					    Parameters */
+	u32 Reserved128[6];
+
+	u32 USBCMD;		/*  (0x140) USB Command Register */
+	u32 USBSTS;		/*  (0x144) USB Status Register */
+	u32 USBINTR;		/*  (0x148) USB Interrupt Enable Register */
+	u32 FRINDEX;		/*  (0x14C) USB Frame Index Register */
+	u32 Reserved150;
+	u32 PERIODICLISTBASE_DEVICEADDR;	/*  (0x154) Host Controller
+						    Frame List Base Address */
+				/*  (0x154) Device Controller USB Device
+					    Address */
+	u32 ASYNCLISTADDR_ENDPOINTLISTADDR;	/*  (0x158) Host Controller
+						    next Asynchronous Address */
+				/*  (0x158) Device Controller Endpoint List
+					    Address */
+	u32 TTCTRL;		/*  (0x15C) Host Controller Embedded TT
+					    Asynchronous Buffer Control */
+	u32 BURSTSIZE;		/*  (0x160) Host Controller Embedded TT
+					    Asynchronous Buffer Status */
+	u32 TXFILLTUNING;	/*  (0x164) TX Full Tuning */
+	u32 TXTTFILLTUNING;	/*  (0x168) TT TX Full Tuning */
+	u32 Reserved16C;
+	u32 ULPIVIEWPORT;	/*  (0x170) ULPI Viewport */
+	u32 Reserved174;
+	u32 ENDPTNAK;		/*  (0x178) Endpoint NACK Received */
+	u32 ENDPTNAKEN;		/*  (0x17C) Endpoint NACK Received Interrupt
+					    Enable */
+	u32 CONFIGFLAG;		/*  (0x180) Configuration Flag Register */
+	u32 PORTSC[8];		/*  (0x184_1A0) Port Status */
+	u32 OTGSC;		/*  (0x1A4) OTG Status Control Register */
+	u32 USBMODE;		/*  (0x1A8) USB Deivce Mode Register */
+	u32 ENDPTSETUPSTAT;	/*  (0x1AC) Endpoint Setup Status Register */
+	u32 ENDPTPRIME;		/*  (0x1B0) Endpoint Initializetion Register */
+	u32 ENDPTFLUSH;		/*  (0x1B4) Endpoint De-Initialize Register */
+	u32 ENDPTSTATUS;	/*  (0x1B8) Endpoint Status Register */
+	u32 ENDPTCOMPLETE;	/*  (0x1BC) Endpoint Complete Register */
+	u32 ENDPTCTRL[16];	/*  (0x1C0) Endpoint Control Register */
+} __attribute__ ((aligned(32)));
+#define T_OTG_REGS	struct _T_OTG_REGS
+
+
+/*-------------------------------------------------------------------------*/
+/*  Function Registers */
+struct _T_FC_REGS {
+	u32 USBCMD;		/*  (0x140) USB Command Register */
+	u32 USBSTS;		/*  (0x144) USB Status Register */
+	u32 USBINTR;		/*  (0x148) USB Interrupt Enable Register */
+	u32 FRINDEX;		/*  (0x14C) USB Frame Index Register */
+	u32 Reserved150;
+	u32 DEVICEADDR;		/*  (0x154) Device Controller USB Device
+					    Address */
+	u32 ENDPOINTLISTADDR;	/*  (0x158) Device Controller Endpoint List
+					    Address */
+	u32 TTCTRL;		/*  (0x15C) Host Controller Embedded TT
+					    Asynchronous Buffer Control */
+	u32 BURSTSIZE;		/*  (0x160) Host Controller Embedded TT
+					    Asynchronous Buffer Status */
+	u32 TXFILLTUNING;	/*  (0x164) TX Full Tuning */
+	u32 TXTTFILLTUNING;	/*  (0x168) TT TX Full Tuning */
+	u32 Reserved16C;
+	u32 ULPIVIEWPORT;	/*  (0x170) ULPI Viewport */
+	u32 Reserved174;
+	u32 ENDPTNAK;		/*  (0x178) Endpoint NACK Received */
+	u32 ENDPTNAKEN;		/*  (0x17C) Endpoint NACK Received Interrupt
+					    Enable */
+	u32 CONFIGFLAG;		/*  (0x180) Configuration Flag Register */
+	u32 PORTSC[8];		/*  (0x184_1A0) Port Status */
+	u32 OTGSC;		/*  (0x1A4) OTG Status Control Register */
+	u32 USBMODE;		/*  (0x1A8) USB Deivce Mode Register */
+	u32 ENDPTSETUPSTAT;	/*  (0x1AC) Endpoint Setup Status Register */
+	u32 ENDPTPRIME;		/*  (0x1B0) Endpoint Initializetion Register */
+	u32 ENDPTFLUSH;		/*  (0x1B4) Endpoint De-Initialize Register */
+	u32 ENDPTSTATUS;	/*  (0x1B8) Endpoint Status Register */
+	u32 ENDPTCOMPLETE;	/*  (0x1BC) Endpoint Complete Register */
+	u32 ENDPTCTRL[16];	/*  (0x1C0) Endpoint Control Register */
+} __attribute__ ((aligned(32)));
+#define T_FC_REGS	struct _T_FC_REGS
+
+/*-------------------------------------------------------------------------*/
+/*  Host Registers */
+struct _T_HC_REGS {
+	u32 USBCMD;		/*  (0x140) USB Command Register */
+	u32 USBSTS;		/*  (0x144) USB Status Register */
+	u32 USBINTR;		/*  (0x148) USB Interrupt Enable Register */
+	u32 FRINDEX;		/*  (0x14C) USB Frame Index Register */
+	u32 Reserved150;
+	u32 PERIODICLISTBASE;	/*  (0x154) Host Controller Frame List Base
+					    Address */
+	u32 ASYNCLISTADDR;	/*  (0x158) Host Controller next Asynchronous
+					    Address */
+	u32 TTCTRL;		/*  (0x15C) Host Controller Embedded TT
+					    Asynchronous Buffer Control */
+	u32 BURSTSIZE;		/*  (0x160) Host Controller Embedded TT
+					    Asynchronous Buffer Status */
+	u32 TXFILLTUNING;	/*  (0x164) TX Full Tuning */
+	u32 TXTTFILLTUNING;	/*  (0x168) TT TX Full Tuning */
+	u32 Reserved16C;
+	u32 ULPIVIEWPORT;	/*  (0x170) ULPI Viewport */
+	u32 Reserved174;
+	u32 ENDPTNAK;		/*  (0x178) Endpoint NACK Received */
+	u32 ENDPTNAKEN;		/*  (0x17C) Endpoint NACK Received
+					    Interrupt Enable */
+	u32 CONFIGFLAG;		/*  (0x180) Configuration Flag Register */
+	u32 PORTSC[8];		/*  (0x184_1A0) Port Status */
+	u32 OTGSC;		/*  (0x1A4) OTG Status Control Register */
+	u32 USBMODE;		/*  (0x1A8) USB Deivce Mode Register */
+	u32 ENDPTSETUPSTAT;	/*  (0x1AC) Endpoint Setup Status Register */
+	u32 ENDPTPRIME;		/*  (0x1B0) Endpoint Initializetion Register */
+	u32 ENDPTFLUSH;		/*  (0x1B4) Endpoint De-Initialize Register */
+	u32 ENDPTSTATUS;	/*  (0x1B8) Endpoint Status Register */
+	u32 ENDPTCOMPLETE;	/*  (0x1BC) Endpoint Complete Register */
+	u32 ENDPTCTRL[16];	/*  (0x1C0) Endpoint Control Register */
+} __attribute__ ((aligned(32)));
+#define T_HC_REGS	struct _T_HC_REGS
+
+/*-------------------------------------------------------------------------*/
+/*  Endpoint Qurere Head (dQH) */
+#define EQH_MULTI		(BIT31_30)	/*  Multi */
+#define EQH_ZLT			(BIT29)		/*  Zero Length Termination
+						 *  Select
+						 */
+#define EQH_MAXPL		(BIT26_16)	/*  Maximum Packet Length */
+#define EQH_SETUP_INT		(BIT15)		/*  Interrupt On Setup */
+
+#define EQH_MPLENGTH_BIT_POS	(16)		/*  Isochronous Multi Pos */
+#define EQH_MPS_ISO_MULTI_NONE	(BIT30)		/*  Isochronous Multi None */
+#define EQH_MPS_ISO_MULTI_1ADD	(BIT31)		/*  Isochronous Multi 2 */
+#define EQH_MPS_ISO_MULTI_2ADD	(BIT31_30)	/*  Isochronous Multi 3 */
+
+#define EQH_CURR_DTD_PTR	(BIT31_05)	/*  Current dTD pointer */
+
+#define EQH_NEXT_DTD_PTR	(BIT31_05)	/*  Next dTD pointer */
+#define EQH_T			(BIT00)		/*  Terminate */
+
+#define EQH_TOTAL_BYTES		(BIT30_16)	/*  Total Bytes */
+#define EQH_COMPLETE_INT	(BIT15)		/*  Interrupt On Complete */
+#define EQH_MULTI_OVER		(BIT11_10)	/*  Multiplier Override */
+#define EQH_STATUS		(BIT07_00)	/*  Status */
+
+#define EQH_BUF_PTR		(BIT31_12)	/*  Buffer Pointer */
+#define EQH_CURR_OFFSET		(BIT11_00)	/*  Cuurent Offset */
+
+
+struct _T_ENDPOINT_QUEUE_HEAD {
+	u32	max_length;	/*  Bits 16..26 Bit 15 is Interrupt */
+				/*  On Setup */
+	u32	curr_ptr;	/*  Current dTD Pointer */
+	u32	next_ptr;	/*  Next dTD Pointer */
+	u32	total_bytes;	/*  Total bytes (16..30), IOC (15) */
+				/*  INT (8), STS (0-7) */
+	u32	buf_ptr[5];	/*  Buffer pointer Page 0-4 */
+	u32	RESERVED1;
+	u32	setup_buf[2];	/*  8 bytes of setup data
+				 *  that follows the Setup PID
+				 */
+	u32		RESERVED2[4];
+} __attribute__ ((aligned(32)));
+#define T_ENDPOINT_QUEUE_HEAD	struct _T_ENDPOINT_QUEUE_HEAD
+
+
+/*-------------------------------------------------------------------------*/
+/*  Endpoint Transfer Descriptor (dTD) */
+#define DTD_NEXT_LINK_PTR		(BIT31_05)	/*  Next Link Pointer */
+#define DTD_T				(BIT00)		/*  Terminate */
+
+#define DTD_TOTAL_BYTES			(BIT30_16)	/*  Total Bytes */
+#define DTD_COMPLETE_INT		(BIT15)		/*  Interrupt On
+							 *   Complete
+							 */
+#define DTD_MULTI_OVER			(BIT11_10)	/*  Multiplier
+							 *  Override
+							 */
+#define DTD_STATUS			(BIT07_00)	/*  Status */
+
+#define DTD_BUFFER_PTR			(BIT31_12)	/*  Buffer Pointer */
+#define DTD_CURR_OFFSET			(BIT11_00)	/*  Cuurent Offset */
+#define DTD_FRAME_NUMBER		(BIT10_00)	/*  Frame Number */
+
+#define  DTD_NEXT_TERMINATE		(0x00000001)
+#define  DTD_IOC			(0x00008000)
+#define  DTD_STATUS_ACTIVE		(0x00000080)
+#define  DTD_STATUS_HALTED		(0x00000040)
+#define  DTD_RESERVED_FIELDS		(0x00007F00)
+#define  DTD_ERROR_MASK			(0x68)
+#define  DTD_ADDR_MASK			(0xFFFFFFE0)
+#define  DTD_LENGTH_BIT_POS		(16)
+#define  DTD_STATUS_DATA_BUFFER_ERR	(BIT05)
+#define  DTD_STATUS_TRANSACION_ERR	(BIT03)
+
+struct _T_EP_TRANS_DESC {
+	u32	next_ptr;		/*  Next Link Pointer */
+					/*  Terminate */
+	u32	total_bytes;		/*  Total Bytes, ioc, MultiO, Status */
+	u32	buf_ptr[6];		/*  Buffer pointer Page 0-4 */
+} __attribute__ ((aligned(32)));
+#define T_EP_TRANS_DESC		struct _T_EP_TRANS_DESC
+
+/*-------------------------------------------------------------------------*/
+#define	UDC_EP0_MAXPACKETSIZE		64
+#define	UDC_EP0_BUFSIZE			PAGE_SIZE
+#define	UDC_EP_AUTO_BUFSIZE		(PAGE_SIZE*4)
+
+#define USB_ENDPOINT_MPS_SIZE_MASK	(BIT10_00)
+#define USB_ENDPOINT_MPS_MULTI_MASK	(BIT12_11)
+#define USB_ENDPOINT_MPS_MULTI_NONE	(0)
+#define USB_ENDPOINT_MPS_MULTI_1ADD	(BIT11)
+#define USB_ENDPOINT_MPS_MULTI_2ADD	(BIT12)
+
+#define UDC_TRANS_STATE1		PWC_STATE1
+#define UDC_TRANS_FACTOR1		PWC_FACTOR1
+#define UDC_TRANS_CLRFACT1		PWC_CLRFACT1
+#define UDC_TRANS_1_USBINT		(1<<7)
+#define UDC_TRANS_USBSEL		PWC_USBSEL
+#define UDC_TRANS_USBSEL_USBSEL		(1<<7)
+#define UDC_TRANS_USBSEL_SUSFIX		(1<<4)
+#define UDC_TRANS_USBSEL_USBPLLON	(1<<3)
+#define UDC_TRANS_USBSEL_ULPINI		(1<<2)
+#define UDC_TRANS_USBSEL_REFSEL		(1<<1)
+#define UDC_TRANS_USBSEL_MODESEL	(1<<0)
+#define UDC_TRANS_USBSEL_DEFAULT	(0)
+
+#define	NUM_ENDPOINTS			(16)
+#define	NUM_DIRECTIONS			(2)
+#define	UDC_DIRECTION_SHIFT		(7)
+#define DQH_MEMORY_SIZE			(2048)			/*  2K */
+#define DQH_ALLOC_MEMORY_SIZE		(DQH_MEMORY_SIZE*2)	/*  2K * 2 */
+
+#define SUPPORT_DTD_NUM			(8)
+
+#define DTD_STRUCT_SIZE			(0x20)
+#define DTD_MEMORY_SIZE			(DTD_STRUCT_SIZE * NUM_DIRECTIONS * \
+					NUM_ENDPOINTS * SUPPORT_DTD_NUM)
+#define DTD_ALLOC_MEMORY_SIZE		(DTD_MEMORY_SIZE + DTD_STRUCT_SIZE)
+
+#define DTD_MAX_TRANSFER_SIZE		(0x1000 * 4)
+
+#define DTD_MANAGEMENT_FREE		(0)
+#define DTD_MANAGEMENT_RESERVE		(1)
+#define DTD_MANAGEMENT_USE		(2)
+#define DTD_MANAGEMENT_COMPLETE		(3)
+
+struct mp200_req {
+	struct usb_request		req;
+	struct list_head		queue;
+
+	u32				division_len;
+	u32				act_len;
+};
+
+struct _T_MEMORY_VP_INFO {
+	dma_addr_t			padrs;			/*  phy */
+	u32				*p_vadrs;		/*  virtual */
+};
+#define T_MEMORY_VP_INFO	struct _T_MEMORY_VP_INFO
+
+struct mp200_ep {
+	struct usb_ep				ep;
+	struct list_head			queue;
+	const struct usb_endpoint_descriptor	*pdesc;
+	char					name[14];
+	struct mp200_udc			*pudc;
+	T_MEMORY_VP_INFO			mem;
+#ifdef DEBUG_COUNT
+	int					start_count;
+	int					normal_start_count;
+	int					dummy_start_count;
+	int					done_count;
+	int					done_callback_count;
+	int					done_callback_ok_count;
+	int					done_callback_reset_count;
+	int					done_callback_fail_count;
+#endif /* DEBUG_COUNT */
+};
+
+struct _T_DTD_MANAGEMENT {
+	T_MEMORY_VP_INFO		mem_info;
+	u32				use_flag;
+	void				*p_context;
+};
+#define T_DTD_MANAGEMENT	struct _T_DTD_MANAGEMENT
+
+
+struct mp200_udc {
+	struct usb_gadget		gadget;
+	struct usb_gadget_driver	*pdriver;
+	spinlock_t			lock;
+	struct mp200_ep		ep[(NUM_ENDPOINTS)*(NUM_DIRECTIONS) - 1];
+	unsigned			softconnect:1;
+	unsigned			vbus_active:1;
+	unsigned			linux_suspended:1;
+	unsigned			linux_resume:1;
+	unsigned			usb_suspended:1;
+	unsigned			self_powered:1;
+	unsigned			remote_wakeup:1;
+	unsigned			mA;
+	enum usb_device_state 		devstate;
+
+	struct usb_ctrlrequest		ctrl;
+	struct mp200_req		ep0_req;
+	struct mp200_req		null_packet_req;
+	T_MEMORY_VP_INFO		ep0_mem;
+
+	struct completion		*pdone;
+	int				usbint_intno;
+	int				usb_wakeup_intno;
+	struct platform_device		*pdev;
+	T_OTG_REGS			*potg_reg;
+	T_FC_REGS			*pfc_reg;
+
+	T_MEMORY_VP_INFO		dQH_align_mem;		/*  2K */
+	T_MEMORY_VP_INFO		dQH;			/*  dQH */
+
+	T_MEMORY_VP_INFO		dTD_align_mem;		/*  32 byte */
+	T_MEMORY_VP_INFO		dTD;			/*  dTD */
+
+	T_DTD_MANAGEMENT		dTD_Manage[NUM_DIRECTIONS][
+					NUM_ENDPOINTS][SUPPORT_DTD_NUM];
+
+	u32		clk_reg;
+	u32		timer_mode[2];
+
+#ifdef DUMMY_PRIME
+	u32		dummy_prime_waiting;
+	u32		dummy_prime_transferring;
+#endif	/* DUMMY_PRIME */
+
+#ifdef DEBUG_LOG
+	int		dbg_log_count;
+	u8		dbg_log[50000];
+#endif /* DEBUG_LOG */
+#ifdef MEMORY_LOG
+	int		mem_log_count;
+	u8		mem_log[50000];
+#endif /* MEMORY_LOG */
+
+};
+
+#ifdef DEBUG_LOG
+/*-------------------------------------------------------------------------*/
+ #define DBG_LOG(pudc,stuff...)	do {\
+	u8 tmp[257];\
+	\
+	if ((pudc)->dbg_log_count > (sizeof((pudc)->dbg_log) - sizeof(tmp))) {\
+		break;\
+	} \
+	\
+	sprintf(tmp, stuff);\
+	(pudc)->dbg_log_count += strlen(tmp);\
+	strcat((pudc)->dbg_log, tmp);\
+	\
+\
+ } while (0)
+#else
+
+ #define DBG_LOG(pudc,stuff...)	do {\
+ } while (0)
+
+#endif /* DEBUG_LOG */
+#ifdef MEMORY_LOG
+/*-------------------------------------------------------------------------*/
+ #define MEM_LOG(pudc,stuff...)	do {\
+	u8 tmp[257];\
+	\
+	if ((pudc)->mem_log_count > (sizeof((pudc)->mem_log) - sizeof(tmp))) {\
+		break;\
+	} \
+	\
+	sprintf(tmp, stuff);\
+	(pudc)->mem_log_count += strlen(tmp);\
+	strcat((pudc)->mem_log, tmp);\
+	\
+\
+ } while (0)
+#else
+
+ #define MEM_LOG(pudc,stuff...)	do {\
+ } while (0)
+
+#endif /* MEMORY_LOG */
+
+#define TRANS_REPEATED_COUNT		3
+/*-------------------------------------------------------------------------*/
+static inline int mp200st_udc_trans_read(u8 addr, u8 *pdata)
+{
+	int	status;
+	int	repeated_count = TRANS_REPEATED_COUNT;
+	unsigned int	tmp_data;
+
+	do {
+		status = pwc_read(addr, &tmp_data);
+		repeated_count--;
+	} while ((status < 0) && (repeated_count > 0));
+
+	if (status >= 0)
+		*pdata = (u8)tmp_data;
+
+	return status;
+}
+
+/*-------------------------------------------------------------------------*/
+static inline int mp200st_udc_trans_read_modification_write(u8 addr, u8 mask,
+	u8 data)
+{
+	int	status;
+	int	repeated_count = TRANS_REPEATED_COUNT;
+
+	do {
+		status = pwc_write(addr, data, mask);
+		repeated_count--;
+	} while ((status < 0) && (repeated_count > 0));
+
+	return status;
+}
+
+/*-------------------------------------------------------------------------*/
+static inline int mp200st_udc_trans_write(u8 addr, u8 data)
+{
+	return mp200st_udc_trans_read_modification_write(addr, 0xFF, data);
+}
+
+/*-------------------------------------------------------------------------*/
+/*  read(DWORD) */
+static inline u32 mp200st_udc_readl(u32 *adrs)
+{
+	return ioread32(adrs);
+}
+
+/*-------------------------------------------------------------------------*/
+/*  write(DWORD) */
+static inline void mp200st_udc_writel(u32 *adrs, u32 data)
+{
+	iowrite32((data), (adrs));
+}
+
+/*-------------------------------------------------------------------------*/
+/*  maskget */
+static inline u32 mp200st_udc_mask_get_bit(u32 *adrs, u32 mask)
+{
+	return mp200st_udc_readl(adrs) & mask;
+}
+
+/*-------------------------------------------------------------------------*/
+/*  maskset */
+static inline void mp200st_udc_mask_set_bit(u32 *adrs, u32 mask, u32 data)
+{
+	u32	tmp;
+	tmp = (mp200st_udc_readl(adrs) & ~mask) | data;
+	mp200st_udc_writel(adrs, tmp);
+}
+
+/*-------------------------------------------------------------------------*/
+/*  bitclear */
+static inline void mp200st_udc_clear_bit(u32 *adrs, u32 data)
+{
+	u32	tmp;
+	tmp = mp200st_udc_readl(adrs) & ~data;
+	mp200st_udc_writel(adrs, tmp);
+}
+
+/*-------------------------------------------------------------------------*/
+/*  bitset */
+static inline void mp200st_udc_set_bit(u32 *adrs, u32 data)
+{
+	u32	tmp;
+	tmp = mp200st_udc_readl(adrs) | data;
+	mp200st_udc_writel(adrs, tmp);
+}
+
+/*-------------------------------------------------------------------------*/
+/*  ULPI CLK (VBUS) Check write(DWORD) */
+static inline int mp200st_udc_ulc_chk_writel(struct mp200_udc *pudc,
+	u32 *adrs, u32 data)
+{
+	int	status;
+	u8	pwc_state = 0;
+	u32	reg_data;
+
+	if (pudc->vbus_active) {
+#ifdef	CONFIG_MP200_EM1_DKIT
+		status = mp200st_udc_trans_read(DA9052_STATUSA_REG, &pwc_state);
+#else
+		status = mp200st_udc_trans_read(PWC_PSW_STATE, &pwc_state);
+#endif
+		if (status < 0) {
+			ERR("**** mp200st_udc_trans_read(1) err ***\n");
+			return status;
+		}
+
+		reg_data = mp200st_udc_readl(&pudc->pfc_reg->PORTSC[0]);
+		if ((((pwc_state & PWC_PSW_VBUS) == 0)
+			 || (reg_data & PORTSC_SUSP) != 0)) {
+			USB_WARN("before VBUS=%d PORTSC=%08x\n",
+				((pwc_state & PWC_PSW_VBUS) == PWC_PSW_VBUS),
+				reg_data);
+			USB_WARN("ulpi off writel %08x = %08x\n", (int)adrs,
+				(int)data);
+			return -EIO;
+		}
+
+		mp200st_udc_writel(adrs, data);
+
+#ifdef	CONFIG_MP200_EM1_DKIT
+		status = mp200st_udc_trans_read(DA9052_STATUSA_REG, &pwc_state);
+#else
+		status = mp200st_udc_trans_read(PWC_PSW_STATE, &pwc_state);
+#endif
+		if (status < 0) {
+			ERR("**** mp200st_udc_trans_read(2) err ***\n");
+			return status;
+		}
+
+		reg_data = mp200st_udc_readl(&pudc->pfc_reg->PORTSC[0]);
+		if ((((pwc_state & PWC_PSW_VBUS) == 0)
+			 || (reg_data & PORTSC_SUSP) != 0)) {
+			USB_WARN("before VBUS=%d PORTSC=%08x\n",
+				((pwc_state & PWC_PSW_VBUS) == PWC_PSW_VBUS),
+				reg_data);
+			USB_WARN("ulpi off writel %08x = %08x\n", (int)adrs,
+				(int)data);
+			return -EIO;
+		}
+
+		return 0;
+	} else {
+		return -EIO;
+	}
+}
+
+/*-------------------------------------------------------------------------*/
+/*  ULPI CLK (VBUS) Check maskset */
+static inline int mp200st_udc_ulc_chk_mask_set_bit(struct mp200_udc *pudc,
+	u32 *adrs, u32 mask, u32 data)
+{
+	u32	tmp;
+	tmp = (mp200st_udc_readl(adrs) & ~mask) | data;
+	return mp200st_udc_ulc_chk_writel(pudc, adrs, tmp);
+}
+
+/*-------------------------------------------------------------------------*/
+/*  ULPI CLK (VBUS) Check bitclear */
+static inline int mp200st_udc_ulc_chk_clear_bit(struct mp200_udc *pudc,
+	u32 *adrs, u32 data)
+{
+	u32	tmp;
+	tmp = mp200st_udc_readl(adrs) & ~data;
+	return mp200st_udc_ulc_chk_writel(pudc, adrs, tmp);
+}
+
+/*-------------------------------------------------------------------------*/
+/*  ULPI CLK (VBUS) Check bitset */
+static inline int mp200st_udc_ulc_chk_set_bit(struct mp200_udc *pudc,
+	u32 *adrs, u32 data)
+{
+	u32	tmp;
+	tmp = mp200st_udc_readl(adrs) | data;
+	return mp200st_udc_ulc_chk_writel(pudc, adrs, tmp);
+}
+
+#define ULPI_REPEATED_COUNT	100
+
+/*-------------------------------------------------------------------------*/
+/*  ULPI Read */
+static inline int mp200st_udc_ulpi_read(struct mp200_udc *pudc, u8 adrs)
+{
+	int		i, status = -EIO;
+	u32		tmp_viewport;
+
+	tmp_viewport = ULPIVIEWPORT_ULPIRUN | (adrs << 16);
+	mp200st_udc_ulc_chk_writel(pudc, &pudc->pfc_reg->ULPIVIEWPORT,
+		tmp_viewport);
+
+	for (i = 0; i < ULPI_REPEATED_COUNT; i++) {
+		tmp_viewport = mp200st_udc_readl(&pudc->pfc_reg->ULPIVIEWPORT);
+		if (tmp_viewport & ULPIVIEWPORT_ULPIRUN)
+			continue;
+		else {
+			status = (((tmp_viewport
+				& ULPIVIEWPORT_ULPIDATRD) >> 8) & 0xFF);
+			break;
+		}
+	}
+
+	return status;
+}
+
+/*-------------------------------------------------------------------------*/
+/*  ULPI Write */
+static inline int mp200st_udc_ulpi_write(struct mp200_udc *pudc, u8 adrs,
+	u8 data)
+{
+	int	i, status = -EIO;
+	u32	tmp_viewport;
+
+	tmp_viewport = ULPIVIEWPORT_ULPIRUN | ULPIVIEWPORT_ULPIRW
+		 | (adrs << 16) | data;
+	mp200st_udc_ulc_chk_writel(pudc, &pudc->pfc_reg->ULPIVIEWPORT,
+		tmp_viewport);
+
+	for (i = 0; i < ULPI_REPEATED_COUNT; i++) {
+		tmp_viewport = mp200st_udc_readl(&pudc->pfc_reg->ULPIVIEWPORT);
+		if ((tmp_viewport & ULPIVIEWPORT_ULPIRUN) == 0) {
+			status = 0;
+			break;
+		}
+	}
+
+	return status;
+}
+
+extern int usb_gadget_register_driver(struct usb_gadget_driver *pdriver);
+extern int usb_gadget_unregister_driver(struct usb_gadget_driver *pdriver);
+
+
+#endif /* __MP200_UDC_H */
diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index fd666ce..4878078 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -37,8 +37,6 @@
 
 #include "../core/hcd.h"
 
-#include <asm/byteorder.h>
-#include <asm/io.h>
 #include <asm/irq.h>
 #include <asm/system.h>
 #include <asm/unaligned.h>
@@ -63,7 +61,7 @@
 #define DRIVER_AUTHOR "David Brownell"
 #define DRIVER_DESC "USB 2.0 'Enhanced' Host Controller (EHCI) Driver"
 
-static const char	hcd_name [] = "ehci_hcd";
+static const char	hcd_name[] = "ehci_hcd";
 
 
 #undef VERBOSE_DEBUG
@@ -87,19 +85,19 @@ static const char	hcd_name [] = "ehci_hcd";
 #define EHCI_SHRINK_FRAMES	5		/* async qh unlink delay */
 
 /* Initial IRQ latency:  faster than hw default */
-static int log2_irq_thresh = 0;		// 0 to 6
-module_param (log2_irq_thresh, int, S_IRUGO);
-MODULE_PARM_DESC (log2_irq_thresh, "log2 IRQ latency, 1-64 microframes");
+static int log2_irq_thresh;		/* 0 to 6 */
+module_param(log2_irq_thresh, int, S_IRUGO);
+MODULE_PARM_DESC(log2_irq_thresh, "log2 IRQ latency, 1-64 microframes");
 
 /* initial park setting:  slower than hw default */
-static unsigned park = 0;
-module_param (park, uint, S_IRUGO);
-MODULE_PARM_DESC (park, "park setting; 1-3 back-to-back async packets");
+static unsigned park;
+module_param(park, uint, S_IRUGO);
+MODULE_PARM_DESC(park, "park setting; 1-3 back-to-back async packets");
 
 /* for flakey hardware, ignore overcurrent indicators */
-static int ignore_oc = 0;
-module_param (ignore_oc, bool, S_IRUGO);
-MODULE_PARM_DESC (ignore_oc, "ignore bogus hardware overcurrent indications");
+static int ignore_oc;
+module_param(ignore_oc, bool, S_IRUGO);
+MODULE_PARM_DESC(ignore_oc, "ignore bogus hardware overcurrent indications");
 
 #define	INTR_MASK (STS_IAA | STS_FATAL | STS_PCD | STS_ERR | STS_INT)
 
@@ -127,7 +125,7 @@ MODULE_PARM_DESC (ignore_oc, "ignore bogus hardware overcurrent indications");
  * before driver shutdown. But it also seems to be caused by bugs in cardbus
  * bridge shutdown:  shutting down the bridge before the devices using it.
  */
-static int handshake (struct ehci_hcd *ehci, void __iomem *ptr,
+static int handshake(struct ehci_hcd *ehci, void __iomem *ptr,
 		      u32 mask, u32 done, int usec)
 {
 	u32	result;
@@ -139,14 +137,14 @@ static int handshake (struct ehci_hcd *ehci, void __iomem *ptr,
 		result &= mask;
 		if (result == done)
 			return 0;
-		udelay (1);
+		udelay(1);
 		usec--;
 	} while (usec > 0);
 	return -ETIMEDOUT;
 }
 
 /* force HC to halt state from unknown (EHCI spec section 2.3) */
-static int ehci_halt (struct ehci_hcd *ehci)
+static int ehci_halt(struct ehci_hcd *ehci)
 {
 	u32	temp = ehci_readl(ehci, &ehci->regs->status);
 
@@ -159,7 +157,7 @@ static int ehci_halt (struct ehci_hcd *ehci)
 	temp = ehci_readl(ehci, &ehci->regs->command);
 	temp &= ~CMD_RUN;
 	ehci_writel(ehci, temp, &ehci->regs->command);
-	return handshake (ehci, &ehci->regs->status,
+	return handshake(ehci, &ehci->regs->status,
 			  STS_HALT, STS_HALT, 16 * 125);
 }
 
@@ -180,7 +178,7 @@ static int handshake_on_error_set_halt(struct ehci_hcd *ehci, void __iomem *ptr,
 }
 
 /* put TDI/ARC silicon into EHCI mode */
-static void tdi_reset (struct ehci_hcd *ehci)
+static void tdi_reset(struct ehci_hcd *ehci)
 {
 	u32 __iomem	*reg_ptr;
 	u32		tmp;
@@ -198,36 +196,36 @@ static void tdi_reset (struct ehci_hcd *ehci)
 }
 
 /* reset a non-running (STS_HALT == 1) controller */
-static int ehci_reset (struct ehci_hcd *ehci)
+static int ehci_reset(struct ehci_hcd *ehci)
 {
 	int	retval;
 	u32	command = ehci_readl(ehci, &ehci->regs->command);
 
 	command |= CMD_RESET;
-	dbg_cmd (ehci, "reset", command);
+	dbg_cmd(ehci, "reset", command);
 	ehci_writel(ehci, command, &ehci->regs->command);
 	ehci_to_hcd(ehci)->state = HC_STATE_HALT;
 	ehci->next_statechange = jiffies;
-	retval = handshake (ehci, &ehci->regs->command,
+	retval = handshake(ehci, &ehci->regs->command,
 			    CMD_RESET, 0, 250 * 1000);
 
 	if (retval)
 		return retval;
 
 	if (ehci_is_TDI(ehci))
-		tdi_reset (ehci);
+		tdi_reset(ehci);
 
 	return retval;
 }
 
 /* idle the controller (from running) */
-static void ehci_quiesce (struct ehci_hcd *ehci)
+static void ehci_quiesce(struct ehci_hcd *ehci)
 {
 	u32	temp;
 
 #ifdef DEBUG
-	if (!HC_IS_RUNNING (ehci_to_hcd(ehci)->state))
-		BUG ();
+	if (!HC_IS_RUNNING(ehci_to_hcd(ehci)->state))
+		BUG();
 #endif
 
 	/* wait for any schedule enables/disables to take effect */
@@ -264,7 +262,7 @@ static void ehci_iaa_watchdog(unsigned long param)
 	struct ehci_hcd		*ehci = (struct ehci_hcd *) param;
 	unsigned long		flags;
 
-	spin_lock_irqsave (&ehci->lock, flags);
+	spin_lock_irqsave(&ehci->lock, flags);
 
 	/* Lost IAA irqs wedge things badly; seen first with a vt8235.
 	 * So we need this watchdog, but must protect it against both
@@ -295,7 +293,7 @@ static void ehci_iaa_watchdog(unsigned long param)
 		 */
 		status = ehci_readl(ehci, &ehci->regs->status);
 		if ((status & STS_IAA) || !(cmd & CMD_IAAD)) {
-			COUNT (ehci->stats.lost_iaa);
+			COUNT(ehci->stats.lost_iaa);
 			ehci_writel(ehci, STS_IAA, &ehci->regs->status);
 		}
 
@@ -315,13 +313,13 @@ static void ehci_watchdog(unsigned long param)
 	spin_lock_irqsave(&ehci->lock, flags);
 
 	/* stop async processing after it's idled a bit */
-	if (test_bit (TIMER_ASYNC_OFF, &ehci->actions))
-		start_unlink_async (ehci, ehci->async);
+	if (test_bit(TIMER_ASYNC_OFF, &ehci->actions))
+		start_unlink_async(ehci, ehci->async);
 
 	/* ehci could run by timer, without IRQs ... */
-	ehci_work (ehci);
+	ehci_work(ehci);
 
-	spin_unlock_irqrestore (&ehci->lock, flags);
+	spin_unlock_irqrestore(&ehci->lock, flags);
 }
 
 /* On some systems, leaving remote wakeup enabled prevents system shutdown.
@@ -369,15 +367,15 @@ static void ehci_shutdown(struct usb_hcd *hcd)
 	spin_unlock_irq(&ehci->lock);
 }
 
-static void ehci_port_power (struct ehci_hcd *ehci, int is_on)
+static void ehci_port_power(struct ehci_hcd *ehci, int is_on)
 {
 	unsigned port;
 
-	if (!HCS_PPC (ehci->hcs_params))
+	if (!HCS_PPC(ehci->hcs_params))
 		return;
 
-	ehci_dbg (ehci, "...power%s ports...\n", is_on ? "up" : "down");
-	for (port = HCS_N_PORTS (ehci->hcs_params); port > 0; )
+	ehci_dbg(ehci, "...power%s ports...\n", is_on ? "up" : "down");
+	for (port = HCS_N_PORTS(ehci->hcs_params); port > 0; )
 		(void) ehci_hub_control(ehci_to_hcd(ehci),
 				is_on ? SetPortFeature : ClearPortFeature,
 				USB_PORT_FEAT_POWER,
@@ -393,9 +391,9 @@ static void ehci_port_power (struct ehci_hcd *ehci, int is_on)
  * ehci_work is called from some interrupts, timers, and so on.
  * it calls driver completion functions, after dropping ehci->lock.
  */
-static void ehci_work (struct ehci_hcd *ehci)
+static void ehci_work(struct ehci_hcd *ehci)
 {
-	timer_action_done (ehci, TIMER_IO_WATCHDOG);
+	timer_action_done(ehci, TIMER_IO_WATCHDOG);
 
 	/* another CPU may drop ehci->lock during a schedule scan while
 	 * it reports urb completions.  this flag guards against bogus
@@ -404,61 +402,61 @@ static void ehci_work (struct ehci_hcd *ehci)
 	if (ehci->scanning)
 		return;
 	ehci->scanning = 1;
-	scan_async (ehci);
+	scan_async(ehci);
 	if (ehci->next_uframe != -1)
-		scan_periodic (ehci);
+		scan_periodic(ehci);
 	ehci->scanning = 0;
 
 	/* the IO watchdog guards against hardware or driver bugs that
 	 * misplace IRQs, and should let us run completely without IRQs.
 	 * such lossage has been observed on both VT6202 and VT8235.
 	 */
-	if (HC_IS_RUNNING (ehci_to_hcd(ehci)->state) &&
+	if (HC_IS_RUNNING(ehci_to_hcd(ehci)->state) &&
 			(ehci->async->qh_next.ptr != NULL ||
 			 ehci->periodic_sched != 0))
-		timer_action (ehci, TIMER_IO_WATCHDOG);
+		timer_action(ehci, TIMER_IO_WATCHDOG);
 }
 
 /*
  * Called when the ehci_hcd module is removed.
  */
-static void ehci_stop (struct usb_hcd *hcd)
+static void ehci_stop(struct usb_hcd *hcd)
 {
-	struct ehci_hcd		*ehci = hcd_to_ehci (hcd);
+	struct ehci_hcd		*ehci = hcd_to_ehci(hcd);
 
-	ehci_dbg (ehci, "stop\n");
+	ehci_dbg(ehci, "stop\n");
 
 	/* no more interrupts ... */
-	del_timer_sync (&ehci->watchdog);
+	del_timer_sync(&ehci->watchdog);
 	del_timer_sync(&ehci->iaa_watchdog);
 
 	spin_lock_irq(&ehci->lock);
-	if (HC_IS_RUNNING (hcd->state))
-		ehci_quiesce (ehci);
+	if (HC_IS_RUNNING(hcd->state))
+		ehci_quiesce(ehci);
 
 	ehci_silence_controller(ehci);
-	ehci_reset (ehci);
+	ehci_reset(ehci);
 	spin_unlock_irq(&ehci->lock);
 
 	remove_companion_file(ehci);
-	remove_debug_files (ehci);
+	remove_debug_files(ehci);
 
 	/* root hub is shut down separately (first, when possible) */
-	spin_lock_irq (&ehci->lock);
+	spin_lock_irq(&ehci->lock);
 	if (ehci->async)
-		ehci_work (ehci);
-	spin_unlock_irq (&ehci->lock);
-	ehci_mem_cleanup (ehci);
+		ehci_work(ehci);
+	spin_unlock_irq(&ehci->lock);
+	ehci_mem_cleanup(ehci);
 
 #ifdef	EHCI_STATS
-	ehci_dbg (ehci, "irq normal %ld err %ld reclaim %ld (lost %ld)\n",
+	ehci_dbg(ehci, "irq normal %ld err %ld reclaim %ld (lost %ld)\n",
 		ehci->stats.normal, ehci->stats.error, ehci->stats.reclaim,
 		ehci->stats.lost_iaa);
-	ehci_dbg (ehci, "complete %ld unlink %ld\n",
+	ehci_dbg(ehci, "complete %ld unlink %ld\n",
 		ehci->stats.complete, ehci->stats.unlink);
 #endif
 
-	dbg_status (ehci, "ehci_stop completed",
+	dbg_status(ehci, "ehci_stop completed",
 		    ehci_readl(ehci, &ehci->regs->status));
 }
 
@@ -486,14 +484,15 @@ static int ehci_init(struct usb_hcd *hcd)
 	 */
 	ehci->periodic_size = DEFAULT_I_TDPS;
 	INIT_LIST_HEAD(&ehci->cached_itd_list);
-	if ((retval = ehci_mem_init(ehci, GFP_KERNEL)) < 0)
+	retval = ehci_mem_init(ehci, GFP_KERNEL);
+	if (retval < 0)
 		return retval;
 
 	/* controllers may cache some of the periodic schedule ... */
 	hcc_params = ehci_readl(ehci, &ehci->caps->hcc_params);
-	if (HCC_ISOC_CACHE(hcc_params))		// full frame cache
+	if (HCC_ISOC_CACHE(hcc_params))		/* full frame cache */
 		ehci->i_thresh = 8;
-	else					// N microframes cached
+	else					/* N microframes cached */
 		ehci->i_thresh = 2 + HCC_ISOC_THRES(hcc_params);
 
 	ehci->reclaim = NULL;
@@ -539,10 +538,17 @@ static int ehci_init(struct usb_hcd *hcd)
 		temp &= ~(3 << 2);
 		temp |= (EHCI_TUNE_FLS << 2);
 		switch (EHCI_TUNE_FLS) {
-		case 0: ehci->periodic_size = 1024; break;
-		case 1: ehci->periodic_size = 512; break;
-		case 2: ehci->periodic_size = 256; break;
-		default:	BUG();
+		case 0:
+			ehci->periodic_size = 1024;
+			break;
+		case 1:
+			ehci->periodic_size = 512;
+			break;
+		case 2:
+			ehci->periodic_size = 256;
+			break;
+		default:
+			BUG();
 		}
 	}
 	ehci->command = temp;
@@ -551,9 +557,9 @@ static int ehci_init(struct usb_hcd *hcd)
 }
 
 /* start HC running; it's halted, ehci_init() has been run (once) */
-static int ehci_run (struct usb_hcd *hcd)
+static int ehci_run(struct usb_hcd *hcd)
 {
-	struct ehci_hcd		*ehci = hcd_to_ehci (hcd);
+	struct ehci_hcd		*ehci = hcd_to_ehci(hcd);
 	int			retval;
 	u32			temp;
 	u32			hcc_params;
@@ -562,7 +568,8 @@ static int ehci_run (struct usb_hcd *hcd)
 	hcd->poll_rh = 0;
 
 	/* EHCI spec section 4.1 */
-	if ((retval = ehci_reset(ehci)) != 0) {
+	retval = ehci_reset(ehci);
+	if (retval != 0) {
 		ehci_mem_cleanup(ehci);
 		return retval;
 	}
@@ -585,19 +592,20 @@ static int ehci_run (struct usb_hcd *hcd)
 	if (HCC_64BIT_ADDR(hcc_params)) {
 		ehci_writel(ehci, 0, &ehci->regs->segment);
 #if 0
-// this is deeply broken on almost all architectures
+		/* this is deeply broken on almost all architectures */
 		if (!dma_set_mask(hcd->self.controller, DMA_64BIT_MASK))
 			ehci_info(ehci, "enabled 64bit DMA\n");
 #endif
 	}
 
 
-	// Philips, Intel, and maybe others need CMD_RUN before the
-	// root hub will detect new devices (why?); NEC doesn't
+	/* Philips, Intel, and maybe others need CMD_RUN before the
+	 * root hub will detect new devices (why?); NEC doesn't
+	 */
 	ehci->command &= ~(CMD_LRESET|CMD_IAAD|CMD_PSE|CMD_ASE|CMD_RESET);
 	ehci->command |= CMD_RUN;
 	ehci_writel(ehci, ehci->command, &ehci->regs->command);
-	dbg_cmd (ehci, "init", ehci->command);
+	dbg_cmd(ehci, "init", ehci->command);
 
 	/*
 	 * Start, enabling full USB 2.0 functionality ... usb 1.1 devices
@@ -621,7 +629,7 @@ static int ehci_run (struct usb_hcd *hcd)
 	up_write(&ehci_cf_port_reset_rwsem);
 
 	temp = HC_VERSION(ehci_readl(ehci, &ehci->caps->hc_capbase));
-	ehci_info (ehci,
+	ehci_info(ehci,
 		"USB %x.%x started, EHCI %x.%02x, driver %s%s\n",
 		((ehci->sbrn & 0xf0)>>4), (ehci->sbrn & 0x0f),
 		temp >> 8, temp & 0xff, DRIVER_VERSION,
@@ -642,19 +650,19 @@ static int ehci_run (struct usb_hcd *hcd)
 
 /*-------------------------------------------------------------------------*/
 
-static irqreturn_t ehci_irq (struct usb_hcd *hcd)
+static irqreturn_t ehci_irq(struct usb_hcd *hcd)
 {
-	struct ehci_hcd		*ehci = hcd_to_ehci (hcd);
+	struct ehci_hcd		*ehci = hcd_to_ehci(hcd);
 	u32			status, masked_status, pcd_status = 0, cmd;
 	int			bh;
 
-	spin_lock (&ehci->lock);
+	spin_lock(&ehci->lock);
 
 	status = ehci_readl(ehci, &ehci->regs->status);
 
 	/* e.g. cardbus physical eject */
 	if (status == ~(u32) 0) {
-		ehci_dbg (ehci, "device removed\n");
+		ehci_dbg(ehci, "device removed\n");
 		goto dead;
 	}
 
@@ -671,17 +679,17 @@ static irqreturn_t ehci_irq (struct usb_hcd *hcd)
 
 #ifdef	VERBOSE_DEBUG
 	/* unrequested/ignored: Frame List Rollover */
-	dbg_status (ehci, "irq", status);
+	dbg_status(ehci, "irq", status);
 #endif
 
 	/* INT, ERR, and IAA interrupt rates can be throttled */
 
 	/* normal [4.15.1.2] or error [4.15.1.1] completion */
-	if (likely ((status & (STS_INT|STS_ERR)) != 0)) {
-		if (likely ((status & STS_ERR) == 0))
-			COUNT (ehci->stats.normal);
+	if (likely((status & (STS_INT | STS_ERR)) != 0)) {
+		if (likely((status & STS_ERR) == 0))
+			COUNT(ehci->stats.normal);
 		else
-			COUNT (ehci->stats.error);
+			COUNT(ehci->stats.error);
 		bh = 1;
 	}
 
@@ -702,7 +710,7 @@ static irqreturn_t ehci_irq (struct usb_hcd *hcd)
 
 	/* remote wakeup [4.3.1] */
 	if (status & STS_PCD) {
-		unsigned	i = HCS_N_PORTS (ehci->hcs_params);
+		unsigned	i = HCS_N_PORTS(ehci->hcs_params);
 
 		/* kick root hub later */
 		pcd_status = status;
@@ -713,30 +721,30 @@ static irqreturn_t ehci_irq (struct usb_hcd *hcd)
 
 		while (i--) {
 			int pstatus = ehci_readl(ehci,
-						 &ehci->regs->port_status [i]);
+						 &ehci->regs->port_status[i]);
 
 			if (pstatus & PORT_OWNER)
 				continue;
 			if (!(pstatus & PORT_RESUME)
-					|| ehci->reset_done [i] != 0)
+					|| ehci->reset_done[i] != 0)
 				continue;
 
 			/* start 20 msec resume signaling from this port,
 			 * and make khubd collect PORT_STAT_C_SUSPEND to
 			 * stop that signaling.
 			 */
-			ehci->reset_done [i] = jiffies + msecs_to_jiffies (20);
-			ehci_dbg (ehci, "port %d remote wakeup\n", i + 1);
+			ehci->reset_done[i] = jiffies + msecs_to_jiffies(20);
+			ehci_dbg(ehci, "port %d remote wakeup\n", i + 1);
 			mod_timer(&hcd->rh_timer, ehci->reset_done[i]);
 		}
 	}
 
 	/* PCI errors [4.15.2.4] */
-	if (unlikely ((status & STS_FATAL) != 0)) {
+	if (unlikely((status & STS_FATAL) != 0)) {
 		ehci_err(ehci, "fatal error\n");
-		dbg_cmd (ehci, "fatal", ehci_readl(ehci,
+		dbg_cmd(ehci, "fatal", ehci_readl(ehci,
 						   &ehci->regs->command));
-		dbg_status (ehci, "fatal", status);
+		dbg_status(ehci, "fatal", status);
 		ehci_halt(ehci);
 dead:
 		ehci_reset(ehci);
@@ -748,8 +756,8 @@ dead:
 	}
 
 	if (bh)
-		ehci_work (ehci);
-	spin_unlock (&ehci->lock);
+		ehci_work(ehci);
+	spin_unlock(&ehci->lock);
 	if (pcd_status)
 		usb_hcd_poll_rh_status(hcd);
 	return IRQ_HANDLED;
@@ -769,17 +777,17 @@ dead:
  * NOTE:  control, bulk, and interrupt share the same code to append TDs
  * to a (possibly active) QH, and the same QH scanning code.
  */
-static int ehci_urb_enqueue (
+static int ehci_urb_enqueue(
 	struct usb_hcd	*hcd,
 	struct urb	*urb,
 	gfp_t		mem_flags
 ) {
-	struct ehci_hcd		*ehci = hcd_to_ehci (hcd);
+	struct ehci_hcd		*ehci = hcd_to_ehci(hcd);
 	struct list_head	qtd_list;
 
-	INIT_LIST_HEAD (&qtd_list);
+	INIT_LIST_HEAD(&qtd_list);
 
-	switch (usb_pipetype (urb->pipe)) {
+	switch (usb_pipetype(urb->pipe)) {
 	case PIPE_CONTROL:
 		/* qh_completions() code doesn't handle all the fault cases
 		 * in multi-TD control transfers.  Even 1KB is rare anyway.
@@ -789,24 +797,24 @@ static int ehci_urb_enqueue (
 		/* FALLTHROUGH */
 	/* case PIPE_BULK: */
 	default:
-		if (!qh_urb_transaction (ehci, urb, &qtd_list, mem_flags))
+		if (!qh_urb_transaction(ehci, urb, &qtd_list, mem_flags))
 			return -ENOMEM;
 		return submit_async(ehci, urb, &qtd_list, mem_flags);
 
 	case PIPE_INTERRUPT:
-		if (!qh_urb_transaction (ehci, urb, &qtd_list, mem_flags))
+		if (!qh_urb_transaction(ehci, urb, &qtd_list, mem_flags))
 			return -ENOMEM;
 		return intr_submit(ehci, urb, &qtd_list, mem_flags);
 
 	case PIPE_ISOCHRONOUS:
 		if (urb->dev->speed == USB_SPEED_HIGH)
-			return itd_submit (ehci, urb, mem_flags);
+			return itd_submit(ehci, urb, mem_flags);
 		else
-			return sitd_submit (ehci, urb, mem_flags);
+			return sitd_submit(ehci, urb, mem_flags);
 	}
 }
 
-static void unlink_async (struct ehci_hcd *ehci, struct ehci_qh *qh)
+static void unlink_async(struct ehci_hcd *ehci, struct ehci_qh *qh)
 {
 	/* failfast */
 	if (!HC_IS_RUNNING(ehci_to_hcd(ehci)->state) && ehci->reclaim)
@@ -829,7 +837,7 @@ static void unlink_async (struct ehci_hcd *ehci, struct ehci_qh *qh)
 
 	/* start IAA cycle */
 	} else
-		start_unlink_async (ehci, qh);
+		start_unlink_async(ehci, qh);
 }
 
 /* remove from hardware lists
@@ -838,19 +846,19 @@ static void unlink_async (struct ehci_hcd *ehci, struct ehci_qh *qh)
 
 static int ehci_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)
 {
-	struct ehci_hcd		*ehci = hcd_to_ehci (hcd);
+	struct ehci_hcd		*ehci = hcd_to_ehci(hcd);
 	struct ehci_qh		*qh;
 	unsigned long		flags;
 	int			rc;
 
-	spin_lock_irqsave (&ehci->lock, flags);
+	spin_lock_irqsave(&ehci->lock, flags);
 	rc = usb_hcd_check_unlink_urb(hcd, urb, status);
 	if (rc)
 		goto done;
 
-	switch (usb_pipetype (urb->pipe)) {
-	// case PIPE_CONTROL:
-	// case PIPE_BULK:
+	switch (usb_pipetype(urb->pipe)) {
+	/* case PIPE_CONTROL: */
+	/* case PIPE_BULK: */
 	default:
 		qh = (struct ehci_qh *) urb->hcpriv;
 		if (!qh)
@@ -876,20 +884,20 @@ static int ehci_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)
 			break;
 		switch (qh->qh_state) {
 		case QH_STATE_LINKED:
-			intr_deschedule (ehci, qh);
+			intr_deschedule(ehci, qh);
 			/* FALL THROUGH */
 		case QH_STATE_IDLE:
-			qh_completions (ehci, qh);
+			qh_completions(ehci, qh);
 			break;
 		default:
-			ehci_dbg (ehci, "bogus qh %p state %d\n",
+			ehci_dbg(ehci, "bogus qh %p state %d\n",
 					qh, qh->qh_state);
 			goto done;
 		}
 
 		/* reschedule QH iff another request is queued */
-		if (!list_empty (&qh->qtd_list)
-				&& HC_IS_RUNNING (hcd->state)) {
+		if (!list_empty(&qh->qtd_list)
+				&& HC_IS_RUNNING(hcd->state)) {
 			rc = qh_schedule(ehci, qh);
 
 			/* An error here likely indicates handshake failure
@@ -906,25 +914,26 @@ static int ehci_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)
 		break;
 
 	case PIPE_ISOCHRONOUS:
-		// itd or sitd ...
+		/* itd or sitd ... */
 
-		// wait till next completion, do it then.
-		// completion irqs can wait up to 1024 msec,
+		/* wait till next completion, do it then.
+		 * completion irqs can wait up to 1024 msec,
+		 */
 		break;
 	}
 done:
-	spin_unlock_irqrestore (&ehci->lock, flags);
+	spin_unlock_irqrestore(&ehci->lock, flags);
 	return rc;
 }
 
 /*-------------------------------------------------------------------------*/
 
-// bulk qh holds the data toggle
+/* bulk qh holds the data toggle */
 
 static void
-ehci_endpoint_disable (struct usb_hcd *hcd, struct usb_host_endpoint *ep)
+ehci_endpoint_disable(struct usb_hcd *hcd, struct usb_host_endpoint *ep)
 {
-	struct ehci_hcd		*ehci = hcd_to_ehci (hcd);
+	struct ehci_hcd		*ehci = hcd_to_ehci(hcd);
 	unsigned long		flags;
 	struct ehci_qh		*qh, *tmp;
 
@@ -932,7 +941,7 @@ ehci_endpoint_disable (struct usb_hcd *hcd, struct usb_host_endpoint *ep)
 	/* ASSERT:  nobody can be submitting urbs for this any more */
 
 rescan:
-	spin_lock_irqsave (&ehci->lock, flags);
+	spin_lock_irqsave(&ehci->lock, flags);
 	qh = ep->hcpriv;
 	if (!qh)
 		goto done;
@@ -941,11 +950,11 @@ rescan:
 	 * accelerate iso completions ... so spin a while.
 	 */
 	if (qh->hw_info1 == 0) {
-		ehci_vdbg (ehci, "iso delay\n");
+		ehci_vdbg(ehci, "iso delay\n");
 		goto idle_timeout;
 	}
 
-	if (!HC_IS_RUNNING (hcd->state))
+	if (!HC_IS_RUNNING(hcd->state))
 		qh->qh_state = QH_STATE_IDLE;
 	switch (qh->qh_state) {
 	case QH_STATE_LINKED:
@@ -956,17 +965,17 @@ rescan:
 		/* periodic qh self-unlinks on empty */
 		if (!tmp)
 			goto nogood;
-		unlink_async (ehci, qh);
+		unlink_async(ehci, qh);
 		/* FALL THROUGH */
 	case QH_STATE_UNLINK:		/* wait for hw to finish? */
 	case QH_STATE_UNLINK_WAIT:
 idle_timeout:
-		spin_unlock_irqrestore (&ehci->lock, flags);
+		spin_unlock_irqrestore(&ehci->lock, flags);
 		schedule_timeout_uninterruptible(1);
 		goto rescan;
 	case QH_STATE_IDLE:		/* fully unlinked */
-		if (list_empty (&qh->qtd_list)) {
-			qh_put (qh);
+		if (list_empty(&qh->qtd_list)) {
+			qh_put(qh);
 			break;
 		}
 		/* else FALL THROUGH */
@@ -975,20 +984,20 @@ nogood:
 		/* caller was supposed to have unlinked any requests;
 		 * that's not our job.  just leak this memory.
 		 */
-		ehci_err (ehci, "qh %p (#%02x) state %d%s\n",
+		ehci_err(ehci, "qh %p (#%02x) state %d%s\n",
 			qh, ep->desc.bEndpointAddress, qh->qh_state,
-			list_empty (&qh->qtd_list) ? "" : "(has tds)");
+			list_empty(&qh->qtd_list) ? "" : "(has tds)");
 		break;
 	}
 	ep->hcpriv = NULL;
 done:
-	spin_unlock_irqrestore (&ehci->lock, flags);
+	spin_unlock_irqrestore(&ehci->lock, flags);
 	return;
 }
 
-static int ehci_get_frame (struct usb_hcd *hcd)
+static int ehci_get_frame(struct usb_hcd *hcd)
 {
-	struct ehci_hcd		*ehci = hcd_to_ehci (hcd);
+	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
 	return (ehci_readl(ehci, &ehci->regs->frame_index) >> 3) %
 		ehci->periodic_size;
 }
@@ -997,9 +1006,9 @@ static int ehci_get_frame (struct usb_hcd *hcd)
 
 #define DRIVER_INFO DRIVER_VERSION " " DRIVER_DESC
 
-MODULE_DESCRIPTION (DRIVER_INFO);
-MODULE_AUTHOR (DRIVER_AUTHOR);
-MODULE_LICENSE ("GPL");
+MODULE_DESCRIPTION(DRIVER_INFO);
+MODULE_AUTHOR(DRIVER_AUTHOR);
+MODULE_LICENSE("GPL");
 
 #ifdef CONFIG_PCI
 #include "ehci-pci.c"
@@ -1046,6 +1055,11 @@ MODULE_LICENSE ("GPL");
 #define	PLATFORM_DRIVER		ixp4xx_ehci_driver
 #endif
 
+#ifdef CONFIG_ARCH_MP200
+#include "ehci-mp200.c"
+#define	PLATFORM_DRIVER		ehci_mp200_driver
+#endif
+
 #if !defined(PCI_DRIVER) && !defined(PLATFORM_DRIVER) && \
     !defined(PS3_SYSTEM_BUS_DRIVER) && !defined(OF_PLATFORM_DRIVER)
 #error "missing bus glue for ehci-hcd"
@@ -1055,6 +1069,10 @@ static int __init ehci_hcd_init(void)
 {
 	int retval = 0;
 
+	park = 0;
+	ignore_oc = 0;
+	log2_irq_thresh = 0;
+
 	set_bit(USB_EHCI_LOADED, &usb_hcds_loaded);
 	if (test_bit(USB_UHCI_LOADED, &usb_hcds_loaded) ||
 			test_bit(USB_OHCI_LOADED, &usb_hcds_loaded))
diff --git a/drivers/usb/host/ehci-mp200.c b/drivers/usb/host/ehci-mp200.c
new file mode 100644
index 0000000..8531c5a
--- /dev/null
+++ b/drivers/usb/host/ehci-mp200.c
@@ -0,0 +1,766 @@
+/*
+ * EHCI HCD (Host Controller Driver) for MP200 High speed USB Host controller.
+ *
+ *  Copyright (C) NEC Electronics Corporation 2009
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+
+#include <mach/pmu.h>
+#include <mach/smu.h>
+#include <mach/pwc.h>
+#include <mach/gpio.h>
+#include <mach/pm.h>
+
+
+/*----------------------------------*/
+/* Debug message */
+/*#define USE_DEBUG_MESSAGE_ALL  */
+/*#define USE_DEBUG_MESSAGE      */
+/*#define USE_INFOMATION_MESSAGE */
+
+#include "ehci-mp200.h"
+
+/*---------------------------------------------------------------------------*/
+/* */
+static const char driver_name[] = "mp200-ehci-driver";
+
+#ifdef USE_PHY_TYPE
+static T_PHY_TYPE g_phy_type[] = {
+	 /*  PHY      VID     PID  */
+	{UNKNOWN_PHY, 0x0000, 0x0000},
+	{    NXP_PHY, 0x04cc, 0x0000},		/* NXP */
+	{   SMSC_PHY, 0x0424, 0x0000},		/* SMSC */
+};
+#endif	/* USE_PHY_TYPE */
+
+/* ----- Work ----- */
+struct mp200_hcd_work	*pg_hcd_work;
+
+/*---------------------------------------------------------------------------*/
+/* Function */
+static int _mp200_init(struct platform_device *pdev);
+static int _mp200_exit(struct platform_device *pdev);
+static void _mp200_vbus_control(struct usb_hcd *hcd, int on_flag);
+static void _mp200_enable_controller(struct usb_hcd *hcd);
+static void _mp200_disable_controller(void);
+
+#ifdef USE_DUMP_REGISTER
+/*-------------------------------------------------------------------------*/
+/*
+ * PHY Register Dump
+*/
+static void _mp200_dump_phy_reg(struct usb_hcd *hcd)
+{
+	int		ndata;
+	T_OTG_REGS	*p_regs = (T_OTG_REGS *)hcd->regs;
+
+	ndata = mp200st_udc_ulpi_read(&p_regs->ULPIVIEWPORT, 0x00);
+	if (ndata < 0) {
+		ERR_MSG("***** ULPI Read Error!!");
+		return;
+	}
+	INFO_MSG("MP200-EHCI(PHY) : Vendor ID Low = 0x%02x", ndata);
+
+	ndata = mp200st_udc_ulpi_read(&p_regs->ULPIVIEWPORT, 0x01);
+	INFO_MSG("MP200-EHCI(PHY) : Vendor ID High = 0x%02x", ndata);
+
+	ndata = mp200st_udc_ulpi_read(&p_regs->ULPIVIEWPORT, 0x02);
+	INFO_MSG("MP200-EHCI(PHY) : Product ID Low = 0x%02x", ndata);
+
+	ndata = mp200st_udc_ulpi_read(&p_regs->ULPIVIEWPORT, 0x03);
+	INFO_MSG("MP200-EHCI(PHY) : Product ID High = 0x%02x", ndata);
+
+	ndata = mp200st_udc_ulpi_read(&p_regs->ULPIVIEWPORT, 0x04);
+	INFO_MSG("MP200-EHCI(PHY) : Function Control = 0x%02x", ndata);
+
+	ndata = mp200st_udc_ulpi_read(&p_regs->ULPIVIEWPORT, 0x0A);
+	INFO_MSG("MP200-EHCI(PHY) : OTG Control = 0x%02x", ndata);
+
+	ndata = mp200st_udc_ulpi_read(&p_regs->ULPIVIEWPORT, 0x0D);
+	INFO_MSG("MP200-EHCI(PHY) : USB Interrupt Enable = 0x%02x", ndata);
+}
+
+/*-------------------------------------------------------------------------*/
+/*
+ * Link Register Dump
+*/
+static void _mp200_dump_controller_reg(struct usb_hcd *hcd)
+{
+	int		i;
+	u32 reg_data;
+
+	for (i = 0x100 ; i < 0x200 ; i += 16) {
+		reg_data = mp200st_udc_readl(
+			(u32 *)IO_ADDRESS(MP200_USB_BASE + i));
+		printk(KERN_INFO "MP200-EHCI(HC) : USB%04x = %08x", i,
+			(int)reg_data);
+
+		reg_data = mp200st_udc_readl(
+			(u32 *)IO_ADDRESS(MP200_USB_BASE + i+4));
+		printk(KERN_INFO " %08x", (int)reg_data);
+
+		reg_data = mp200st_udc_readl(
+			(u32 *)IO_ADDRESS(MP200_USB_BASE + i+8));
+		printk(KERN_INFO " %08x", (int)reg_data);
+
+		reg_data = mp200st_udc_readl(
+			(u32 *)IO_ADDRESS(MP200_USB_BASE + i+12));
+		printk(KERN_INFO " %08x\n", (int)reg_data);
+	}
+}
+#endif	/* USE_DUMP_REGISTER */
+
+/*-------------------------------------------------------------------------*/
+/*
+ * initialize
+ *   initialize for Work area
+*/
+static int _mp200_init(struct platform_device *pdev)
+{
+	int	nret = 0;
+	struct mp200_hcd_work	*p_work;
+
+	pg_hcd_work = NULL;	/* global */
+
+	p_work = kzalloc(sizeof(struct mp200_hcd_work), GFP_KERNEL);
+	if (p_work != NULL) {
+		pg_hcd_work = p_work;
+
+		spin_lock_init(&p_work->lock);
+		p_work->dma_mask = DMA_32BIT_MASK;
+
+		/*-----------------------------------------------------------*/
+		/* DMA parameter setting */
+		pdev->dev.dma_mask = &p_work->dma_mask;
+		pdev->dev.coherent_dma_mask = DMA_32BIT_MASK;
+
+#ifdef USE_PHY_TYPE
+		p_work->phy_type = UNKNOWN_PHY;
+#endif	/* USE_PHY_TYPE */
+	} else {
+		nret = -ENOMEM;
+	}
+
+	return nret;
+}
+
+/*-------------------------------------------------------------------------*/
+/*
+ * end
+ *   Work area memory free
+*/
+static int _mp200_exit(struct platform_device *pdev)
+{
+	int		nret = 0;
+
+	if (pg_hcd_work != NULL) {
+		kfree(pg_hcd_work);
+		pg_hcd_work = NULL;
+	}
+
+	return nret;
+}
+
+#ifdef USE_PHY_TYPE
+/*-------------------------------------------------------------------------*/
+/*
+ * get PHY ID
+*/
+static u16 _mp200_get_phy_id(struct usb_hcd *hcd)
+{
+	int		ndata;
+	__u16		phyid;
+	T_OTG_REGS	*p_regs = (T_OTG_REGS *)hcd->regs;
+
+	ndata = mp200st_udc_ulpi_read(&p_regs->ULPIVIEWPORT,
+			PHY_VENDOR_ID_HIGH);
+	if (ndata == -EIO)
+		return 0;
+
+	phyid = (u16)((ndata & 0xFF) << 8);
+
+	ndata = mp200st_udc_ulpi_read(&p_regs->ULPIVIEWPORT, PHY_VENDOR_ID_LOW);
+	if (ndata == -EIO)
+		return 0;
+
+	phyid |= (u16)(ndata & 0xFF);
+
+	return phyid;
+}
+
+/*-------------------------------------------------------------------------*/
+/*
+ * get PHY Type
+*/
+static int _mp200_get_phy_type(
+	struct mp200_hcd_work *p_work,
+	struct usb_hcd *hcd)
+{
+	int	i, nret = -1;
+	__u16	phyid;
+	PT_PHY_TYPE	p_phy_type = g_phy_type;
+
+	phyid = _mp200_get_phy_id(hcd);
+	INFO_MSG("------ PHY Vendor ID = 0x%04x", phyid);
+
+	for (i = 0; i < END_PHY; i++) {
+		if (phyid == p_phy_type->vendorID) {
+			p_work->phy_type = p_phy_type->phy_type;
+			nret = 0;
+			break;
+		}
+		p_phy_type++;
+	}
+
+	return nret;
+}
+#endif	/* USE_PHY_TYPE */
+
+
+/*-------------------------------------------------------------------------*/
+/*
+ * VBUS ON/OFF
+ *
+ * on_flag
+ *    0    : VBUS OFF
+ *  !=0    : VBUS ON
+*/
+static void _mp200_vbus_control(struct usb_hcd *hcd, int on_flag)
+{
+	T_OTG_REGS	*p_regs = (T_OTG_REGS *)hcd->regs;
+	__u8		data;
+
+
+	if (system_rev & 0x40) {
+		if (on_flag == 0)
+			gpio_direction_output(GPIO_CN9_1PIN, 1);
+		else
+			gpio_direction_output(GPIO_CN9_1PIN, 0);
+	} else {
+#ifdef USE_PHY_TYPE
+		switch (pg_hcd_work->phy_type) {
+		case SMSC_PHY:
+			data = (BIT06 | BIT05);
+			break;
+
+		case NXP_PHY:
+		default:
+			data = BIT06;
+			break;
+		}
+#else	/* !USE_PHY_TYPE */
+		data = BIT06;
+#endif	/* USE_PHY_TYPE */
+
+		if (on_flag == 0) {
+			DBG_MSG(" --- VBUS OFF");
+			mp200st_udc_ulpi_write(&p_regs->ULPIVIEWPORT,
+				PHY_OTG_CONTROL_C, data);
+		} else {
+			DBG_MSG(" --- VBUS ON");
+			mp200st_udc_ulpi_write(&p_regs->ULPIVIEWPORT,
+				PHY_OTG_CONTROL_S, data);
+		}
+	}
+}
+
+/*-------------------------------------------------------------------------*/
+/*
+ * USB Controller Enable
+*/
+static void _mp200_enable_controller(struct usb_hcd *hcd)
+{
+	T_OTG_REGS	*p_regs = (T_OTG_REGS *)hcd->regs;
+
+	INFO_MSG("mp200_enable_controller() Enter");
+
+	/*---------------------------------------------------------------*/
+	/* PHY */
+#ifndef	CONFIG_MP200_EM1_DKIT
+	pwc_write(PWC_PSCNT1, PHY_POWER_BIT, PHY_POWER_BIT);	/* Power ON */
+#endif
+	if (system_rev & 0x40)
+		gpio_direction_output(UDC_PHY_CS, 1);		/* RESETB */
+	else
+		gpio_direction_output(UDC_PHY_CS, 0);		/* CS */
+
+	mdelay(UDC_PHY_CS_MDELAY);
+
+	/*---------------------------------------------------------------*/
+	/* Link */
+	/* CLK supply ON */
+	mp200_pmu_open_clockgate(MP200_CLOCKGATE_USB_CLK);
+	/* Reset OFF */
+	mp200_pmu_unreset_device(MP200_RESETDEVICE_USB);
+
+	udelay(UDC_LINK_UNRESET_UDELAY);
+
+	/*---------------------------------------------------------------*/
+	/* set to Host */
+	/* Host Mode */
+	mp200st_udc_set_bit(&p_regs->USB_MODE, UDBMODE_CM_HC);
+
+#ifdef USE_PHY_TYPE
+	_mp200_get_phy_type(pg_hcd_work, hcd);
+#endif	/* USE_PHY_TYPE */
+
+}
+
+/*-------------------------------------------------------------------------*/
+/*
+ * USB Controller Disable
+*/
+static void _mp200_disable_controller(void)
+{
+	INFO_MSG("mp200_disable_controller() Enter");
+
+	/*---------------------------------------------------------------*/
+	/* Link disable */
+	/* Reset ON */
+	mp200_pmu_reset_device(MP200_RESETDEVICE_USB);
+	/* CLK supply OFF */
+	mp200_pmu_close_clockgate(MP200_CLOCKGATE_USB_CLK);
+
+	/*---------------------------------------------------------------*/
+	/* PHY disable */
+
+	if (system_rev & 0x40)
+		gpio_direction_output(UDC_PHY_CS, 0);	/* RESETB */
+	else
+		gpio_direction_output(UDC_PHY_CS, 1);	/* CS */
+
+#ifndef	CONFIG_MP200_EM1_DKIT
+	/* Power OFF */
+	pwc_write(PWC_PSCNT1, 0, PHY_POWER_BIT);
+#endif
+}
+
+/*-------------------------------------------------------------------------*/
+/*
+ * USB Controller Reset
+*/
+static int mp200_ehci_hc_reset(struct usb_hcd *hcd)
+{
+	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
+	int		retval;
+
+	INFO_MSG("mp200_ehci_hc_reset() Enter");
+
+	if (ehci == NULL) {
+		ERR_MSG("ehci == NULL !!");
+		return -EFAULT;
+	}
+
+	/*---------------------------------------------------------------*/
+	/* set USB Controller enable, and set any paramters */
+	_mp200_enable_controller(hcd);
+
+	ehci->caps = hcd->regs + MP200_EHCI_CAPLENGTH_OFFSET;
+	ehci->regs = hcd->regs + MP200_EHCI_CAPLENGTH_OFFSET +
+			HC_LENGTH(ehci_readl(ehci, &ehci->caps->hc_capbase));
+	ehci->hcs_params = ehci_readl(ehci, &ehci->caps->hcs_params);
+	ehci->sbrn = 0x20;
+	hcd->has_tt = 1;
+
+	/*---------------------------------------------------------------*/
+	/* stop EHCI */
+	retval = ehci_halt(ehci);
+	if (retval != 0) {
+		ERR_MSG("ehci_halt() !!");
+		return retval;
+	}
+
+	/*---------------------------------------------------------------*/
+	/* initialize EHCI */
+	retval = ehci_init(hcd);
+	if (retval != 0) {
+		ERR_MSG("ehci_init() !!");
+		return retval;
+	}
+
+	/*---------------------------------------------------------------*/
+	/* Port Power OFF */
+	ehci_port_power(ehci, 0);
+
+	return retval;
+}
+
+
+/*-------------------------------------------------------------------------*/
+/*
+ * USB Controller Start(Run)
+*/
+static int mp200_ehci_hc_start(struct usb_hcd *hcd)
+{
+	int		retval;
+	T_OTG_REGS	*p_regs = (T_OTG_REGS *)hcd->regs;
+
+	INFO_MSG("mp200_ehci_hc_start() Enter");
+
+	retval = ehci_run(hcd);
+
+	/*---------------------------------------------------------------*/
+	/* set Host mode                                            */
+	/*   call reset in ehci_run() function. that is reset Link. */
+	/*   this Link is disable host mode by reset, */
+	/*   need re-setting. */
+	mp200st_udc_set_bit(&p_regs->USB_MODE, UDBMODE_CM_HC);	/* Host Mode */
+
+#ifdef USE_DUMP_REGISTER
+	_mp200_dump_phy_reg(hcd);
+	_mp200_dump_controller_reg(hcd);
+#endif	/* USE_DUMP_REGISTER */
+
+	return retval;
+}
+
+/*-------------------------------------------------------------------------*/
+/*
+ * Root HUB Control
+*/
+static int mp200_ehci_hub_control(
+	struct usb_hcd	*hcd,
+	u16		typeReq,
+	u16		wValue,
+	u16		wIndex,
+	char	*buf,
+	u16		wLength
+)
+{
+	int		retval;
+
+	INFO_MSG("mp200_ehci_hub_control() Enter");
+
+	retval = ehci_hub_control(hcd, typeReq, wValue, wIndex, buf, wLength);
+
+	/*---------------------------------------------------------------*/
+	/* VBUS ON/OFF control */
+	if (retval == 0) {
+		if (wValue == USB_PORT_FEAT_POWER) {
+			if (typeReq == SetPortFeature)
+				_mp200_vbus_control(hcd, 1);
+			else if (typeReq == ClearPortFeature)
+				_mp200_vbus_control(hcd, 0);
+
+		}
+	}
+
+	return retval;
+}
+
+/*-------------------------------------------------------------------------*/
+
+static const struct hc_driver ehci_mp200_hc_driver = {
+	.description = hcd_name,
+	.product_desc = "MP200 EHCI Host Controller",
+	.hcd_priv_size = sizeof(struct ehci_hcd),
+
+	/*
+	 * generic hardware linkage
+	 */
+	.irq = ehci_irq,
+	.flags = HCD_MEMORY | HCD_USB2,
+
+	/*
+	 * basic lifecycle operations
+	 */
+	.reset = mp200_ehci_hc_reset,
+	.start = mp200_ehci_hc_start,
+	.stop = ehci_stop,
+	.shutdown = ehci_shutdown,
+
+	/*
+	 * managing i/o requests and associated device resources
+	 */
+	.urb_enqueue = ehci_urb_enqueue,
+	.urb_dequeue = ehci_urb_dequeue,
+	.endpoint_disable = ehci_endpoint_disable,
+
+	/*
+	 * scheduling support
+	 */
+	.get_frame_number = ehci_get_frame,
+
+	/*
+	 * root hub support
+	 */
+	.hub_status_data = ehci_hub_status_data,
+	.hub_control = mp200_ehci_hub_control,
+
+#ifdef	CONFIG_PM
+	.bus_suspend = ehci_bus_suspend,
+	.bus_resume = ehci_bus_resume,
+#endif
+
+	.relinquish_port = ehci_relinquish_port,
+	.port_handed_over = ehci_port_handed_over,
+
+};
+
+/*-------------------------------------------------------------------------*/
+/*
+ * Probe
+*/
+static int mp200_ehci_pd_probe(struct platform_device *pdev)
+{
+	struct usb_hcd *hcd = NULL;
+	const struct hc_driver *driver = &ehci_mp200_hc_driver;
+	int		retval = 0;
+
+	dev_dbg(&pdev->dev, "mp200_ehci_pd_probe() Enter\n");
+
+	/*---------------------------------------------------------------*/
+	if (usb_disabled()) {
+		dev_err(&pdev->dev, "***** USB Dissabled !!\n");
+		return -ENODEV;
+	}
+
+	/*---------------------------------------------------------------*/
+	/* get Work */
+	retval = _mp200_init(pdev);
+	if (retval != 0) {
+		dev_err(&pdev->dev, "***** _mp200_init() Error !!\n");
+		return retval;
+	}
+
+	/*---------------------------------------------------------------*/
+	/* make HCD memory */
+	hcd = usb_create_hcd(driver, &pdev->dev, pdev->dev.bus_id);
+	if (hcd == NULL) {
+		dev_err(&pdev->dev, "***** usb_create_hcd() Error !!\n");
+		retval = -ENOMEM;
+		goto err_create_hcd;
+	}
+
+	/*---------------------------------------------------------------*/
+	/* setting HCD parameters */
+	hcd->rsrc_start = MP200_USB_BASE;
+	hcd->rsrc_len = MP200_USB_SIZE;
+
+	DBG_MSG(" --- hcd->rsrc_start = 0x%08x", (u32)hcd->rsrc_start);
+	DBG_MSG(" --- hcd->rsrc_len   = 0x%08x", (u32)hcd->rsrc_len);
+
+	/*---------------------------------------------------------------*/
+	/* HCD Register */
+	if (!request_mem_region(hcd->rsrc_start, hcd->rsrc_len, driver_name)) {
+		dev_err(&pdev->dev, "***** request_mem_region() Error !!\n");
+		retval = -EBUSY;
+		goto err_mem_region;
+	}
+
+	/*---------------------------------------------------------------*/
+	/* memory map for HCD Register */
+	hcd->regs = ioremap(hcd->rsrc_start, hcd->rsrc_len);
+	if (hcd->regs == NULL) {
+		dev_err(&pdev->dev, "***** ioremap() Error !!\n");
+		retval = -EFAULT;
+		goto err_ioremap;
+	}
+
+	/*---------------------------------------------------------------*/
+	/* add HCD */
+	retval = usb_add_hcd(hcd, UDC_USB_INT, IRQF_SHARED|IRQF_DISABLED);
+	if (retval != 0) {
+		dev_err(&pdev->dev, "***** usb_add_hcd() Error !!\n");
+		goto err_add_hcd;
+	}
+
+	return retval;
+
+err_add_hcd:
+	iounmap(hcd->regs);
+
+err_ioremap:
+	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
+
+err_mem_region:
+	usb_put_hcd(hcd);
+
+err_create_hcd:
+	_mp200_exit(pdev);
+
+	dev_err(&pdev->dev, "***** mp200_ehci_pd_probe(%d) Retern\n", retval);
+
+	return retval;
+}
+
+/*-------------------------------------------------------------------------*/
+/*
+ * Remove
+*/
+static int mp200_ehci_pd_remove(struct platform_device *pdev)
+{
+	struct usb_hcd *hcd = platform_get_drvdata(pdev);
+
+	dev_dbg(&pdev->dev, "mp200_ehci_pd_remove() Enter\n");
+
+	/*---------------------------------------------------------------*/
+	/* remove HDC */
+	usb_remove_hcd(hcd);
+
+	/*---------------------------------------------------------------*/
+	/* disable memory map */
+	iounmap(hcd->regs);
+
+	/*---------------------------------------------------------------*/
+	/* release memory */
+	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
+
+	/*---------------------------------------------------------------*/
+	/* release HCD */
+	usb_put_hcd(hcd);
+
+	/*---------------------------------------------------------------*/
+	/* disable HCD */
+	_mp200_disable_controller();
+
+	/*---------------------------------------------------------------*/
+	/* free Work area */
+	_mp200_exit(pdev);
+
+	return 0;
+}
+
+/*-------------------------------------------------------------------------*/
+/*
+ * Suspend
+*/
+static int mp200_ehci_pd_suspend(
+	struct platform_device *pdev,
+	pm_message_t message)
+{
+#if 0
+	struct usb_hcd *hcd = platform_get_drvdata(pdev);
+	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
+	unsigned long flags;
+	int rc = 0;
+
+	dev_dbg(&pdev->dev, "mp200_ehci_pd_suspend() Enter\n");
+
+	if (time_before(jiffies, ehci->next_statechange))
+		msleep(10);
+
+	spin_lock_irqsave(&ehci->lock, flags);
+	if (hcd->state != HC_STATE_SUSPENDED) {
+		rc = -EINVAL;
+		goto bail;
+	}
+	ehci_writel(ehci, 0, &ehci->regs->intr_enable);
+	(void)ehci_readl(ehci, &ehci->regs->intr_enable);
+
+	if (message.event == PM_EVENT_PRETHAW) {
+		ehci_halt(ehci);
+		ehci_reset(ehci);
+	}
+
+	clear_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);
+
+	_mp200_disable_controller();
+
+ bail:
+	spin_unlock_irqrestore(&ehci->lock, flags);
+
+	/* could save FLADJ in case of Vaux power loss */
+	/* ... we'd only use it to handle clock skew   */
+
+	return rc;
+#else
+	return -EBUSY;
+#endif
+}
+
+/*-------------------------------------------------------------------------*/
+/*
+ * Resume
+*/
+static int mp200_ehci_pd_resume(struct platform_device *pdev)
+{
+	struct usb_hcd *hcd = platform_get_drvdata(pdev);
+	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
+
+	dev_dbg(&pdev->dev, "mp200_ehci_pd_resume() Enter\n");
+
+	_mp200_enable_controller(hcd);
+
+	/* maybe restore FLADJ */
+
+	if (time_before(jiffies, ehci->next_statechange))
+		msleep(100);
+
+	/* Mark hardware accessible again as we are out of D3 state by now */
+	set_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);
+
+	/* If CF is still set, we maintained PCI Vaux power.
+	 * Just undo the effect of ehci_pci_suspend().
+	 */
+	if (ehci_readl(ehci, &ehci->regs->configured_flag) == FLAG_CF) {
+		int	mask = INTR_MASK;
+
+		if (!hcd->self.root_hub->do_remote_wakeup)
+			mask &= ~STS_PCD;
+		ehci_writel(ehci, mask, &ehci->regs->intr_enable);
+		ehci_readl(ehci, &ehci->regs->intr_enable);
+		return 0;
+	}
+
+	ehci_dbg(ehci, "lost power, restarting\n");
+	usb_root_hub_lost_power(hcd->self.root_hub);
+
+	/* Else reset, to cope with power loss or flush-to-storage
+	 * style "resume" having let BIOS kick in during reboot.
+	 */
+	(void) ehci_halt(ehci);
+	(void) ehci_reset(ehci);
+
+	/* emptying the schedule aborts any urbs */
+	spin_lock_irq(&ehci->lock);
+	if (ehci->reclaim)
+		end_unlink_async(ehci);
+	ehci_work(ehci);
+	spin_unlock_irq(&ehci->lock);
+
+	ehci_writel(ehci, ehci->command, &ehci->regs->command);
+	ehci_writel(ehci, FLAG_CF, &ehci->regs->configured_flag);
+	ehci_readl(ehci, &ehci->regs->command);	/* unblock posted writes */
+
+	/* here we "know" root ports should always stay powered */
+	ehci_port_power(ehci, 1);
+
+	hcd->state = HC_STATE_SUSPENDED;
+
+	return 0;
+}
+
+
+MODULE_ALIAS("mp200-ehci");
+
+
+static struct platform_driver ehci_mp200_driver = {
+	.probe    = mp200_ehci_pd_probe,
+	.remove   = mp200_ehci_pd_remove,
+	.shutdown = usb_hcd_platform_shutdown,
+	.suspend  = mp200_ehci_pd_suspend,
+	.resume   = mp200_ehci_pd_resume,
+	.driver = {
+		.owner = THIS_MODULE,
+		.name  = (char *) driver_name,
+	}
+};
+
diff --git a/drivers/usb/host/ehci-mp200.h b/drivers/usb/host/ehci-mp200.h
new file mode 100644
index 0000000..d4c70f2
--- /dev/null
+++ b/drivers/usb/host/ehci-mp200.h
@@ -0,0 +1,920 @@
+/*
+ * ehci-mp200.h -- for MP200 High speed USB Host controller.
+ *
+ *  Copyright (C) NEC Electronics Corporation 2009
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+
+/*-------------------------------------------------------------------------*/
+#ifndef __EHCI_MP200_H
+#define __EHCI_MP200_H
+
+
+/*-------------------------------------------------------------------------*/
+/* Default DEFINE */
+
+/*-------------------------------------------------------------------------*/
+/* Default UNDEF */
+#undef  USE_DUMP_REGISTER
+#undef  USE_PHY_TYPE
+
+/*-------------------------------------------------------------------------*/
+/*  BITs */
+#define BIT00		0x00000001
+#define BIT01		0x00000002
+#define BIT02		0x00000004
+#define BIT03		0x00000008
+#define BIT04		0x00000010
+#define BIT05		0x00000020
+#define BIT06		0x00000040
+#define BIT07		0x00000080
+#define BIT08		0x00000100
+#define BIT09		0x00000200
+#define BIT10		0x00000400
+#define BIT11		0x00000800
+#define BIT12		0x00001000
+#define BIT13		0x00002000
+#define BIT14		0x00004000
+#define BIT15		0x00008000
+#define BIT16		0x00010000
+#define BIT17		0x00020000
+#define BIT18		0x00040000
+#define BIT19		0x00080000
+#define BIT20		0x00100000
+#define BIT21		0x00200000
+#define BIT22		0x00400000
+#define BIT23		0x00800000
+#define BIT24		0x01000000
+#define BIT25		0x02000000
+#define BIT26		0x04000000
+#define BIT27		0x08000000
+#define BIT28		0x10000000
+#define BIT29		0x20000000
+#define BIT30		0x40000000
+#define BIT31		0x80000000
+
+#define BIT31_28	0xF0000000
+#define BIT27_24	0x0F000000
+#define BIT23_20	0x00F00000
+#define BIT19_16	0x000F0000
+#define BIT15_12	0x0000F000
+#define BIT11_08	0x00000F00
+#define BIT07_04	0x000000F0
+#define BIT03_00	0x0000000F
+
+#define BIT31_24	0xFF000000
+#define BIT23_16	0x00FF0000
+#define BIT15_08	0x0000FF00
+#define BIT07_00	0x000000FF
+
+#define BIT31_16	0xFFFF0000
+#define BIT15_00	0x0000FFFF
+
+#define BIT31_00	0xFFFFFFFF
+
+#define BIT31_30	(BIT31|BIT30)
+#define BIT30_29	(BIT30|BIT29)
+#define BIT29_28	(BIT29|BIT28)
+#define BIT28_27	(BIT28|BIT27)
+#define BIT27_26	(BIT27|BIT26)
+#define BIT19_18	(BIT19|BIT18)
+#define BIT15_14	(BIT15|BIT14)
+#define BIT12_11	(BIT12|BIT11)
+#define BIT11_10	(BIT11|BIT10)
+#define BIT03_02	(BIT03|BIT02)
+#define BIT01_00	(BIT01|BIT00)
+
+#define BIT31_25	0xFE000000
+#define BIT31_17	0xFFFE0000
+#define BIT31_12	0xFFFFF000
+#define BIT31_11	0xFFFFE000
+#define BIT31_05	0xFFFFFFE0
+#define BIT30_24	0x7F000000
+#define BIT30_16	0x7FFF0000
+#define BIT26_24	0x07000000
+#define BIT26_16	0x07FF0000
+#define BIT23_17	0x00FE0000
+#define BIT23_00	0x00FFFFFF
+#define BIT21_16	0x003F0000
+#define BIT15_01	0x0000FFFE
+#define BIT13_08	0x00003F00
+#define BIT13_00	0x00003FFF
+#define BIT12_08	0x00001F00
+#define BIT11_00	0x00000FFF
+#define BIT10_00	0x000007FF
+#define BIT07_01	0x000000FE
+#define BIT05_00	0x0000003F
+#define BIT05_01	0x0000003E
+#define BIT04_00	0x0000001F
+#define BIT03_01	0x0000000E
+
+#define UDC_LE16_GET_L(wValue)	((u8)(((le16_to_cpu(wValue))&(BIT07_00))>>0))
+#define UDC_LE16_GET_H(wValue)	((u8)(((le16_to_cpu(wValue))&(BIT15_08))>>8))
+
+/*-------------------------------------------------------------------------*/
+#define UDC_CHG_PINSEL_USB		CHG_PINSEL_USB
+#define UDC_CHG_PINSEL_USB_HZ		0x00000000
+#define UDC_CHG_PINSEL_USB_USB		0x00000001
+
+#define	UDC_USB_INT			INT_USB
+#define	UDC_VBUS_INT			INT_PWC_DETUSBINT
+#define UDC_USB_WAKEUP_INT		INT_PWC_USBWAKINT
+
+#define UDC_PHY_CS			GPIO_USB_CSN
+
+/*---------------------------------------------------------------------------*/
+#define PWC_PSW_VBUS			BIT05
+
+#define PWC_CLRFACT3_VBUS		BIT07
+#define PWC_BMASK3_VBUS			BIT07
+
+#define PWC_CLRFACT3_WAKEUP		BIT04
+#define PWC_BMASK3_WAKEUP		BIT04
+
+#define PWC_VBUS_FALLING_EDGE		BIT07
+#define PWC_VBUS_RISING_EDGE		BIT06
+#define PWC_DETMOD3H_VBUS_MASK		(PWC_VBUS_FALLING_EDGE \
+						|PWC_VBUS_RISING_EDGE)
+
+#define PWC_WAKEUP_FALLING_EDGE		BIT01
+#define PWC_WAKEUP_RISING_EDGE		BIT00
+#define PWC_DETMOD3H_WAKEUP_MASK	(PWC_WAKEUP_FALLING_EDGE \
+						|PWC_WAKEUP_RISING_EDGE)
+
+#define PWC_MODESET1_VUSBPS		BIT03
+
+#define PHY_POWER_BIT			BIT03
+
+#define POWER_SAVE_MODE_WAIT_TIME	150	/* usec */
+
+#define VBUS_CHATTERING_MDELAY		1	/* ms   */
+#define VBUS_CHATTERING_RETRY_MDELAY	20	/* ms   */
+#define VBUS_POWER_SAVE_MODE_UDELAY	150	/* us   */
+
+#define UDC_PHY_CS_MDELAY		1	/* ms   */
+#define UDC_LINK_UNRESET_UDELAY		150	/* us   */
+
+
+/*-------------------------------------------------------------------------*/
+/* ---- (0x000) Identification Register */
+/*  Read Only */
+#define ID_REVISION		BIT23_16
+#define ID_NID			BIT13_08
+#define ID_ID			BIT05_00
+
+/*  ---- (0x004) General Hardware Parameters */
+/*  Read Only */
+#define HWGENERAL_SM		(BIT09)
+#define HWGENERAL_PHYM		(BIT08 | BIT07)
+#define HWGENERAL_PHYW		(BIT06 | BIT05)
+#define HWGENERAL_BWT		(BIT04 | BIT03)
+#define HWGENERAL_CLKC		(BIT02 | BIT01)
+#define HWGENERAL_RT		(BIT00)
+
+/*  ---- (0x008) Host Hardware Parameters */
+/*  Read Only */
+#define HWHOST_TTPER		BIT31_24
+#define HWHOST_TTASY		BIT23_16
+#define HWHOST_NPORT		BIT03_01
+#define HWHOST_HC		BIT00
+
+/*  ---- (0x00C) Device Hardware Parameters */
+/*  Read Only */
+#define HWDEVICE_DEVEP		BIT05_01
+#define HWDEVICE_DC		BIT00
+
+/*  ---- (0x010) TX Buffer Hadware Parameters */
+/*  Read Only */
+#define HWTXBUF_TXLCR		BIT31
+#define HWTXBUF_TXCHANADD	BIT23_16
+#define HWTXBUF_TXADD		BIT15_08
+#define HWTXBUF_TXBURST		BIT07_00
+
+/*  ---- (0x014) RX Buffer Hadware Parameters */
+/*  Read Only */
+#define HWRXBUF_RXADD		BIT15_08
+#define HWRXBUF_RXBURST		BIT07_00
+
+/*  ---- (0x100) Capability Register Length & Host Interface Version Number */
+/*  Read Only */
+#define CH_CAPLENGTH		BIT07_00
+#define CH_HCIVERSION		BIT31_16
+
+/*  ---- (0x104) Host Control Structural Parameters */
+/*  Read Only */
+#define HCSPARAMS_N_TT		BIT27_24
+#define HCSPARAMS_N_PTT		BIT23_20
+#define HCSPARAMS_PI		BIT16
+#define HCSPARAMS_N_CC		BIT15_12
+#define HCSPARAMS_N_PCC		BIT11_08
+#define HCSPARAMS_PPC		BIT04
+#define HCSPARAMS_N_PORTS	BIT03_00
+
+/*  ---- (0x108) Host Control Capability Parameters */
+/*  Read Only */
+#define HCCPARAMS_EECP	BIT15_08   /*  EHCI Extended Capabilities Pointer */
+#define HCCPARAMS_IST	BIT07_04   /*  Isochronous Scheduling Threshold */
+#define HCCPARAMS_ASP	BIT02	   /*  Asynchronous Schedule Park Capability */
+#define HCCPARAMS_PFL	BIT01	   /*  Programmable Frame List Flag */
+#define HCCPARAMS_ADC	BIT00	   /*  64-bit Addressing Capability */
+
+/*  ---- (0x080) General Purpose Timer 0 Load Register */
+/*  Read/Write */
+#define GPTIMER0LD_GPTLD	BIT23_00
+
+/*  ---- (0x084) General Purpose Timer 0 Control Register */
+/*  Read Only, Write Only, Read/Write */
+#define GPTIMER0CTRL_GPTRUN	BIT31	   /*  General Purpose Timer Run */
+#define GPTIMER0CTRL_GPTRST	BIT30	   /*  General Purpose Timer Reset */
+#define GPTIMER0CTRL_GPTMODE	BIT24	   /*  General Purpose Timer Mode */
+#define GPTIMER0CTRL_GPTCNT	BIT23_00   /*  General Purpose Timer Counter */
+
+/*  ---- (0x088) General Purpose Timer 1 Load Register */
+/*  Read/Write */
+#define GPTIMER1LD_GPTLD	BIT23_00
+
+#define TIMER_COUNT_1_SEC	(1000*1000-1)
+#define TIMER_COUNT_2_SEC	(1000*2000-1)
+
+enum TIMER_MODE {
+	TIMER_MODE_INIT = 0,
+	TIMER_MODE_SUSPEND,
+	TIMER_MODE_RESUME,
+	TIMER_MODE_END
+};
+
+/*  ---- (0x08C) General Purpose Timer 1 Control Register */
+/*  Read Only, Write Only, Read/Write */
+#define GPTIMER1CTRL_GPTRUN	BIT31	   /*  General Purpose Timer Run */
+#define GPTIMER1CTRL_GPTRST	BIT30	   /*  General Purpose Timer Reset */
+#define GPTIMER1CTRL_GPTMODE	BIT24	   /*  General Purpose Timer Mode */
+#define GPTIMER1CTRL_GPTCNT	BIT23_00   /*  General Purpose Timer Counter */
+
+/*  ---- (0x120) Device Interface Version Number */
+/*  Read Only */
+#define DCIVERSION_DCIVERSION	BIT15_00
+
+/*  ---- (0x124) Device Control Capability Parameters */
+/*  Read Only */
+#define DCCPARAMS_HC	BIT08		/*  Host Capable */
+#define DCCPARAMS_DC	BIT07		/*  Device Capable */
+#define DCCPARAMS_DEN	BIT03_00	/*  Device Endpoint Number */
+
+/*  ---- (0x140) USB Command Register */
+/*  Read Only, Write Only, Read/Write */
+#define USBCMD_ITC	BIT23_16   /*  Inerrupt Threshold Control */
+#define USBCMD_FS2	BIT15	   /*  Frame List Size */
+#define USBCMD_SUTW	BIT13	   /*  Setup Trip Wire */
+#define USBCMD_ATDTW	BIT12	   /*  Add dTD TripWire */
+#define USBCMD_ASPE	BIT11	   /*  Asynchronous Schedule Park Mode Enable */
+#define USBCMD_ASP	BIT09_08   /*  Asynchronous Schedule Park Mode Count */
+#define USBCMD_LR	BIT07	   /*  Light Host/Device Controller Reset */
+#define USBCMD_IAA	BIT06	   /*  Interrupt on Async Advanse Doorbell */
+#define USBCMD_ASE	BIT05	   /*  Asynchronous Schedule Enable */
+#define USBCMD_PSE	BIT04	   /*  Periodic Schedule Enable */
+#define USBCMD_FS	BIT03_02   /*  Frame List Size */
+#define USBCMD_RST	BIT01	   /*  Controller Reset */
+#define USBCMD_RS	BIT00	   /*  Run/Stop */
+
+#define USBCMD_ITC_01	BIT16
+
+/*  ---- (0x144) USB Status Register */
+/*  Read Only, Read/Write, -Clear */
+#define USBSTS_TI1	BIT25	/*  General Purpose Timer Interrupt 1 */
+#define USBSTS_TI0	BIT24	/*  General Purpose Timer Interrupt 0 */
+#define USBSTS_UPI	BIT19	/*  USB Host Periodic Interrupt */
+#define USBSTS_UAI	BIT18	/*  USB Host Asynchronous Inetrrupt */
+#define USBSTS_NAKI	BIT16	/*  NAK Interrupt */
+#define USBSTS_AS	BIT15	/*  Asynchronous Schedule Status */
+#define USBSTS_PS	BIT14	/*  Periodic Schedule Status */
+#define USBSTS_RCL	BIT13	/*  Reclamation */
+#define USBSTS_HCH	BIT12	/*  HCHaited */
+#define USBSTS_ULPII	BIT10	/*  ULPI Interrupt */
+#define USBSTS_SLI	BIT08	/*  DC Suspend */
+#define USBSTS_SRI	BIT07	/*  SOF Received */
+#define USBSTS_URI	BIT06	/*  USB Reset Received */
+#define USBSTS_AAI	BIT05	/*  Interrupt on Async Advance */
+#define USBSTS_SEI	BIT04	/*  System Error */
+#define USBSTS_FRI	BIT03	/*  Frame List Rollover */
+#define USBSTS_PCI	BIT02	/*  Port Change Detect */
+#define USBSTS_UEI	BIT01	/*  USB Error Interrupt */
+#define USBSTS_UI	BIT00	/*  USB Interrupt */
+
+/*  ---- (0x148) USB Interrupt Enable Register */
+/*  Read/Write */
+#define USBINTR_TIE1	BIT25	/*  General Purpose Timer Interrupt Enable 1 */
+#define USBINTR_TIE0	BIT24	/*  General Purpose Timer Interrupt Enable 0 */
+#define USBINTR_UPIE	BIT19	/*  USB Host Periodic Interrupt Enable */
+#define USBINTR_UAIE	BIT18	/*  USB Host Asynchronous Inetrrupt Enable */
+#define USBINTR_NAKE	BIT16	/*  NAK Interrupt Enable */
+#define USBINTR_ULPIE	BIT10	/*  ULPI Interrupt Enable */
+#define USBINTR_SLE	BIT08	/*  DC Suspend Enable */
+#define USBINTR_SRE	BIT07	/*  SOF Received Enable */
+#define USBINTR_URE	BIT06	/*  USB Reset Received Enable */
+#define USBINTR_AAE	BIT05	/*  Interrupt on Async Advance Enable */
+#define USBINTR_SEE	BIT04	/*  System Error Enable */
+#define USBINTR_FRE	BIT03	/*  Frame List Rollover Enable */
+#define USBINTR_PCE	BIT02	/*  Port Change Detect Enable */
+#define USBINTR_UEE	BIT01	/*  USB Error Interrupt Enable */
+#define USBINTR_UE	BIT00	/*  USB Interrupt Enable */
+
+#define USB_FC_INT_ENABLE	(USBINTR_TIE1|USBINTR_SLE|USBINTR_URE \
+					|USBINTR_PCE|USBINTR_UEE|USBINTR_UE)
+
+#define USB_FC_INT_SUS_ENABLE	(USB_FC_INT_ENABLE|USBINTR_SRE)
+
+
+/*  ---- (0x14C) USB Frame Index Register */
+/*    Host:Read/Write */
+/*  Device:Read Only */
+#define FRINDEX_FRINDEX			BIT13_00	/*  Frame Index */
+
+/*  ---- (0x154) Host Controller Frame List Base Address */
+/*  ---- (0x154) Device Controller USB Device Address */
+/*  Read/Write */
+#define PERIODICLISTBASE_PERBASE	BIT31_12  /*  Base Address(Low) */
+
+#define DEVICEADDR_USBADR		BIT31_25  /*  Device Address */
+#define DEVICEADDR_USBADR_SHIFT		25	  /*  Device Address_Position */
+#define DEVICEADDR_USBADRA		BIT24	  /*  Device Address Advance */
+
+/*  ---- (0x158) Host Controller next Asynchronous Address */
+/*  ---- (0x158) Device Controller Endpoint List Address */
+/*  Read/Write */
+#define ASYNCLISTADDR_ASYBASE	BIT31_05   /* Link Pointer Low(LPL) */
+
+#define ENDPOINTLISTADDR_EPBASE	BIT31_11   /* Endpoint List Pointer(Low) */
+
+/*  ---- (0x15C) Host Controller Embedded TT Asynchronous Buffer Control */
+/*  Read/Write */
+#define TTCTRL_TTHA		BIT30_24
+
+/*  ---- (0x160) Host Controller Embedded TT Asynchronous Buffer Status */
+/*  Read/Write */
+#define BURSTSIZE_TXPBURST	BIT15_08   /*  Programmable TX Burst Length */
+#define BURSTSIZE_RXPBURST	BIT07_00   /*  Programmable RX Burst Length */
+
+/*  ---- (0x164) TX Full Tuning */
+/*  Read/Write */
+#define TXFILLTUNING_TXFIFOTHRES	BIT21_16
+#define TXFILLTUNING_TXSCHHEALTH	BIT12_08
+#define TXFILLTUNING_TXSCHOH		BIT07_00
+
+/*  ---- (0x170) ULPI Viewport */
+/*  Read/Write */
+#define ULPIVIEWPORT_ULPIWU	BIT31		/*  ULPI Wakeup */
+#define ULPIVIEWPORT_ULPIRUN	BIT30		/*  ULPI Read/Write Run */
+#define ULPIVIEWPORT_ULPIRW	BIT29		/*  ULPI Read/Write Control */
+#define ULPIVIEWPORT_ULPISS	BIT27		/*  ULPI Sync State */
+#define ULPIVIEWPORT_ULPIPORT	BIT26_24	/*  ULPI Port Number */
+#define ULPIVIEWPORT_ULPIADDR	BIT23_16	/*  ULPI Data Address */
+#define ULPIVIEWPORT_ULPIDATRD	BIT15_08	/*  ULPI Data Read */
+#define ULPIVIEWPORT_ULPIDATWR	BIT07_00	/*  ULPI Data Write */
+
+/*  ---- (0x178) Endpoint NACK Received */
+/*  Read/Write Clear */
+#define ENDPTNAK_TXEPTN		BIT31_16	/*  TX Endpoint NAK */
+#define ENDPTNAK_RXEPTN		BIT15_00	/*  RX Endpoint NAK */
+
+/*  ---- (0x17C) Endpoint NACK Received Interrupt Enable */
+/*  Read/Write Clear */
+#define ENDPTNAKEN_TXEPTNE	BIT31_16	/*  TX Endpoint NAK */
+#define ENDPTNAKEN_RXEPTNE	BIT15_00	/*  RX Endpoint NAK */
+
+/*  ---- (0x180) Configuration Flag Register */
+
+/*  ---- (0x184_1A0) Port Status */
+/*  ---- (0x184_1A0) Port Status Control */
+/*  Read Only, Read/Write, R/WC */
+#define PORTSC_PTS	BIT31_30    /*  Parallel Transceiver Select */
+#define PORTSC_STS	BIT29	    /*  Serial Transceiver Select */
+#define PORTSC_PTW	BIT28	    /*  Parallel Transceiver Wide */
+#define PORTSC_PSPD	BIT27_26    /*  Port Speed */
+#define PORTSC_PFSC	BIT24	    /*  Port Force Full Speed Connect */
+#define PORTSC_PHCD	BIT23	    /*  PHY Low Power Suspned - Clock Disable */
+#define PORTSC_WKOC	BIT22	    /*  Wake on Over Current Enable */
+#define PORTSC_WKDC	BIT21	    /*  Wake on Disconnect Enable */
+#define PORTSC_WKCN	BIT20	    /*  Wake on Connect Enable */
+#define PORTSC_PTC	BIT19_16    /*  Port Test Control */
+#define PORTSC_PIC	BIT15_14    /*  Port Indicator Control */
+#define PORTSC_PO	BIT13	    /*  Port Owner */
+#define PORTSC_PP	BIT12	    /*  Port Power */
+#define PORTSC_LS	BIT11_10    /*  Line Status */
+#define PORTSC_HSP	BIT09	    /*  High-Speed Port */
+#define PORTSC_PR	BIT08	    /*  Port Reset */
+#define PORTSC_SUSP	BIT07	    /*  Suspned */
+#define PORTSC_FPR	BIT06	    /*  Force Port Resume */
+#define PORTSC_OCC	BIT05	    /*  Over Current Change */
+#define PORTSC_OCA	BIT04	    /*  Over Current Active */
+#define PORTSC_PEC	BIT03	    /*  Port Enable/Disable Change */
+#define PORTSC_PE	BIT02	    /*  Port Enabled/Disabled */
+#define PORTSC_CSC	BIT01	    /*  Connect Status Change */
+#define PORTSC_CCS	BIT00	    /*  Current Connect Status */
+
+#define PORTSC_PSPD_FS	(0)
+#define PORTSC_PSPD_LS	BIT26
+#define PORTSC_PSPD_HS	BIT27
+
+/*  ---- (0x1A4) OTG Status Control Register */
+/*  Read Only, Read/Write, R/WC */
+#define OTGSC_DPIE	BIT30	/*  Data Pulse Interrupt Enable */
+#define OTGSC_1msE	BIT29	/*  1 milisecond timer interrupt Enable */
+#define OTGSC_BSEIE	BIT28	/*  B Session End Interrupt Enable */
+#define OTGSC_BSVIE	BIT27	/*  B Session Valid Interrupt Enable */
+#define OTGSC_ASVIE	BIT26	/*  A Session Valid Interrupt Enable */
+#define OTGSC_AVVIE	BIT25	/*  A VBus Valid Interrupt Enable */
+#define OTGSC_IDIE	BIT24	/*  USB ID Interrupt Enable */
+#define OTGSC_DPIS	BIT22	/*  Data Pulse Interrupt Status */
+#define OTGSC_1msS	BIT21	/*  1 milisecond timer interrupt Status */
+#define OTGSC_BSEIS	BIT20	/*  B Session End Interrupt Status */
+#define OTGSC_BSVIS	BIT19	/*  B Session Valid Interrupt Status */
+#define OTGSC_ASVIS	BIT18	/*  A Session Valid Interrupt Status */
+#define OTGSC_AVVIS	BIT17	/*  A VBus Valid Interrupt Status */
+#define OTGSC_IDIS	BIT16	/*  USB ID Interrupt Status */
+#define OTGSC_DPS	BIT14	/*  Data Bus Pulsing Status */
+#define OTGSC_1msT	BIT13	/*  1 milisecond timer toggle */
+#define OTGSC_BSE	BIT12	/*  B Session End */
+#define OTGSC_BSV	BIT11	/*  B Session Valid */
+#define OTGSC_ASV	BIT10	/*  A Session Valid */
+#define OTGSC_AVV	BIT09	/*  A VBus Valid */
+#define OTGSC_ID	BIT08	/*  USB ID */
+#define OTGSC_HABA	BIT07	/*  Hardware Assist B-Disconnect to A-Connect */
+#define OTGSC_HADP	BIT06	/*  Hardware Assist Data-Pulse-Write to Set */
+#define OTGSC_IDPU	BIT05	/*  ID Pullup */
+#define OTGSC_DP	BIT04	/*  Data Pulsing */
+#define OTGSC_OT	BIT03	/*  OTG Termination */
+#define OTGSC_HAAR	BIT02	/*  Hardware Assist Auto-Reset */
+#define OTGSC_VC	BIT01	/*  VBUS Charge */
+#define OTGSC_VD	BIT00	/*  VBUS Discharge */
+
+#define OTG_INT_ENABLE	(OTGSC_BSEIE|OTGSC_BSVIE|OTGSC_ASVIE|OTGSC_AVVIE)
+#define OTG_POWER_INT	(OTGSC_BSEIS|OTGSC_BSVIS|OTGSC_ASVIS|OTGSC_AVVIS)
+
+/*  ---- (0x1A8) USB Deivce Mode Register */
+/*  Read/Write, Read Only */
+#define USBMODE_VBPS	BIT05		/*  VBus Power Select */
+/*#define USBMODE_SDIS	BIT04*/		/*  Stream Disable Mode */
+#define USBMODE_SLOM	BIT03		/*  Setup Lockout Mode */
+#define USBMODE_ES	BIT02		/*  Endian Select */
+#define USBMODE_CM	BIT01_00	/*  Controller Mode */
+
+#define UDBMODE_CM_FC	BIT01		/*  Function Mode */
+#define UDBMODE_CM_HC	BIT01_00	/*  Host Mode */
+
+/*  ---- (0x1AC) Endpoint Setup Status Register */
+/*  R/WC */
+#define ENDPTSETUPSTAT_ENDPTSETUPSTAT		BIT15_00 /*  Setup Endpoint
+							     Status */
+#define ENDPTSETUPSTAT_ENDPTSETUPSTAT_EP0	BIT00    /*  Setup Endpoint
+							     Status EP0 */
+
+/*  ---- (0x1B0) Endpoint Initializetion Register */
+/*  R/WS */
+#define ENDPTPRIME_PETB		BIT31_16   /*  Prime Endpoint Transmit Buffer */
+#define ENDPTPRIME_PERB		BIT15_00   /*  Prime Endpoint Receive Buffer */
+
+/*  ---- (0x1B4) Endpoint De-Initialize Register */
+/*  R/WS */
+#define ENDPTFLUSH_FETB		BIT31_16   /*  Flush Endpoint Transmit Buffer */
+#define ENDPTFLUSH_FERB		BIT15_00   /*  Flush Endpoint Receive Buffer */
+
+/*  ---- (0x1B8) Endpoint Status Register */
+/*  Read Only */
+#define ENDPTSTATUS_ETBR	BIT31_16   /*  Endpoint Transmit Buffer Ready */
+#define ENDPTSTATUS_ERBR	BIT15_00   /*  Endpoint Receive Buffer Ready */
+
+/*  ---- (0x1BC) Endpoint Complete Register */
+/*  R/WC */
+#define ENDPTCOMPLETE_ETCE		BIT31_16 /*  Endpoint Transmit
+						     Complete Event(IN) */
+#define ENDPTCOMPLETE_ERCE		BIT15_00 /*  Endpoint Receive
+						     Complete Event(OUT) */
+#define ENDPTCOMPLETE_ETCE_SHIFT	16	 /*  Endpoint Transmit
+						     Complete Event Position */
+#define ENDPTCOMPLETE_ERCE_SHIFT	0	 /*  Endpoint Receive Complete
+						     Event Position */
+
+/* ENDPT_BIT_POS macro Introduction */
+
+#define ENDPT_BIT_POS(bEndpointAddress)\
+	((1 << ((bEndpointAddress) & USB_ENDPOINT_NUMBER_MASK)) \
+	    << ((((bEndpointAddress) & USB_ENDPOINT_DIR_MASK) == USB_DIR_IN) \
+			? ENDPTCOMPLETE_ETCE_SHIFT : ENDPTCOMPLETE_ERCE_SHIFT))
+
+/*  ---- (0x1C0) Endpoint Control Register */
+/*  R/WC */
+#define ENDPTCTRL_TXE		BIT23		/*  TX Endpoint Enable */
+#define ENDPTCTRL_TXR		BIT22		/*  TX Data Toggle Reset */
+#define ENDPTCTRL_TXI		BIT21		/*  TX Data Toggle inhibit */
+#define ENDPTCTRL_TXT		BIT19_18	/*  TX Endpoint Type */
+#define ENDPTCTRL_TXD		BIT17		/*  TX Endpoint Data Source */
+#define ENDPTCTRL_TXS		BIT16		/*  TX Endpoint Stall */
+#define ENDPTCTRL_RXE		BIT07		/*  RX Endpoint Enable */
+#define ENDPTCTRL_RXR		BIT06		/*  RX Data Toggle Reset */
+#define ENDPTCTRL_RXI		BIT05		/*  RX Data Toggle inhibit */
+#define ENDPTCTRL_RXT		BIT03_02	/*  RX Endpoint Type */
+#define ENDPTCTRL_RXD		BIT01		/*  RX Endpoint Data Sink */
+#define ENDPTCTRL_RXS		BIT00		/*  RX Endpoint Stall */
+
+#define ENDPTCTRL_TXT_SHIFT	18
+#define ENDPTCTRL_RXT_SHIFT	2
+
+
+
+/*---------------------------------------------------------------------------*/
+/* PHY Register */
+#define PHY_VENDOR_ID_LOW		0x00 /* Vendor ID Low register */
+#define PHY_VENDOR_ID_HIGH		0x01 /* Vendor ID High register */
+#define PHY_PRODUCT_ID_LOW		0x02 /* Product ID Low register */
+#define PHY_PRODUCT_ID_HIGH		0x03 /* Product ID High register */
+#define PHY_FUCTION_CONTROL		0x04 /* Function Control register */
+#define PHY_FUCTION_CONTROL_S		0x05 /* Function Control register Set */
+#define PHY_FUCTION_CONTROL_C		0x06 /* Function Control register
+						Clear */
+#define PHY_INTERFACE_CONTROL		0x07 /* Interface Control register */
+#define PHY_INTERFACE_CONTROL_S		0x08 /* Interface Control register
+						Set */
+#define PHY_INTERFACE_CONTROL_C		0x09 /* Interface Control register
+						Clear */
+#define PHY_OTG_CONTROL			0x0a /* OTG Control register */
+#define PHY_OTG_CONTROL_S		0x0b /* OTG Control register Set */
+#define PHY_OTG_CONTROL_C		0x0c /* OTG Control register Clear */
+#define PHY_INTERRUPT_ENABLE_RISING	0x0d /* USB Interrupt Enable
+						Rising register */
+#define PHY_INTERRUPT_ENABLE_RISING_S	0x0e /* USB Interrupt Enable
+						Rising register Set */
+#define PHY_INTERRUPT_ENABLE_RISING_C	0x0f /* USB Interrupt Enable
+						Rising register Clear */
+#define PHY_INTERRUPT_ENABLE_FALLING	0x10 /* USB Interrupt Enable
+						Falling register */
+#define PHY_INTERRUPT_ENABLE_FALLING_S	0x11 /* USB Interrupt Enable
+						Falling register Set */
+#define PHY_INTERRUPT_ENABLE_FALLING_C	0x12 /* USB Interrupt Enable
+						Falling register Clear */
+#define PHY_INTERRUPT_STATUS		0x13 /* USB Interrupt Status register */
+#define PHY_INTERRUPT_LATCH		0x14 /* USB Interrupt Latch register */
+
+/*---------------------------------------------------------------------------*/
+/*  OTG Control Registers */
+struct _T_OTG_REGS {	/*  ----- offset */
+	u32 ID;			/*  (0x000) Identification Register */
+	u32 HWGENERAL;		/*  (0x004) General Hardware Parameters */
+	u32 HWHOST;		/*  (0x008) Host Hardware Parameters */
+	u32 HWDEVICE;		/*  (0x00C) Device Hardware Parameters */
+	u32 HWTXBUF;		/*  (0x010) TX Buffer Hadware Parameters */
+	u32 HWRXBUF;		/*  (0x014) RX Buffer Hadware Parameters */
+	u32 HWTTTXBUF;		/*  (0x018) TT TX Buffer Hadware Parameters */
+	u32 HWTTRXBUF;		/*  (0x01C) TT RX Buffer Hadware Parameters */
+	u32 Reserved020[24];
+	u32 GPTIMER0LD;		/*  (0x080) General Purpose
+					    Timer 0 Load Register */
+	u32 GPTIMER0CTRL;	/*  (0x084) General Purpose
+					    Timer 0 Control Register */
+	u32 GPTIMER1LD;		/*  (0x088) General Purpose
+					    Timer 1 Load Register */
+	u32 GPTIMER1CTRL;	/*  (0x08C) General Purpose
+					    Timer 1 Control Register */
+	u32 Reserved090[28];
+
+	u32 CAPLENGTH_HCIVERSION; /*  (0x100) Capability Register Length
+					      & Host Interface Version Number */
+	u32 HCSPARAMS;		/*  (0x104) Host Control Structural
+					    Parameters */
+	u32 HCCPARAMS;		/*  (0x108) Host Control Capability
+					    Parameters */
+	u32 Reserved10C[5];
+	u32 DCIVERSION;		/*  (0x120) Device Interface Version Number */
+	u32 DCCPARAMS;		/*  (0x124) Device Control Capability
+					    Parameters */
+	u32 Reserved128[6];
+
+	u32 USBCMD;		/*  (0x140) USB Command Register */
+	u32 USBSTS;		/*  (0x144) USB Status Register */
+	u32 USBINTR;		/*  (0x148) USB Interrupt Enable Register */
+	u32 FRINDEX;		/*  (0x14C) USB Frame Index Register */
+	u32 Reserved150;
+	u32 PERIODICLISTBASE_DEVICEADDR; /*  (0x154) Host Controller Frame List
+						     Base Address */
+					 /*  (0x154) Device Controller USB
+						     Device Address */
+	u32 ASYNCLISTADDR_ENDPOINTLISTADDR; /*  (0x158) Host Controller next
+							Asynchronous Address */
+					    /*  (0x158) Device Controller
+							Endpoint List Address */
+	u32 TTCTRL;		/*  (0x15C) Host Controller Embedded TT
+					    Asynchronous Buffer Control */
+	u32 BURSTSIZE;		/*  (0x160) Host Controller Embedded TT
+					    Asynchronous Buffer Status */
+	u32 TXFILLTUNING;	/*  (0x164) TX Full Tuning */
+	u32 TXTTFILLTUNING;	/*  (0x168) TT TX Full Tuning */
+	u32 Reserved16C;
+	u32 ULPIVIEWPORT;	/*  (0x170) ULPI Viewport */
+	u32 Reserved174;
+	u32 ENDPTNAK;		/*  (0x178) Endpoint NACK Received */
+	u32 ENDPTNAKEN;		/*  (0x17C) Endpoint NACK Received Interrupt
+					    Enable */
+	u32 CONFIGFLAG;		/*  (0x180) Configuration Flag Register */
+	u32 PORTSC[8];		/*  (0x184_1A0) Port Status */
+	u32 OTGSC;		/*  (0x1A4) OTG Status Control Register */
+	u32 USB_MODE;		/*  (0x1A8) USB Deivce Mode Register */
+	u32 ENDPTSETUPSTAT;	/*  (0x1AC) Endpoint Setup Status Register */
+	u32 ENDPTPRIME;		/*  (0x1B0) Endpoint Initializetion Register */
+	u32 ENDPTFLUSH;		/*  (0x1B4) Endpoint De-Initialize Register */
+	u32 ENDPTSTATUS;	/*  (0x1B8) Endpoint Status Register */
+	u32 ENDPTCOMPLETE;	/*  (0x1BC) Endpoint Complete Register */
+	u32 ENDPTCTRL[16];	/*  (0x1C0) Endpoint Control Register */
+} __attribute__ ((aligned(32)));
+#define T_OTG_REGS	struct _T_OTG_REGS
+
+#define MP200_EHCI_CAPLENGTH_OFFSET	0x100
+#define MP200_EHCI_USBCMD_OFFSET	0x140
+
+/*-------------------------------------------------------------------------*/
+/*  Function Registers */
+struct _T_FC_REGS {
+	u32 USBCMD;		/*  (0x140) USB Command Register */
+	u32 USBSTS;		/*  (0x144) USB Status Register */
+	u32 USBINTR;		/*  (0x148) USB Interrupt Enable Register */
+	u32 FRINDEX;		/*  (0x14C) USB Frame Index Register */
+	u32 Reserved150;
+	u32 DEVICEADDR;		/*  (0x154) Device Controller USB Device
+					    Address */
+	u32 ENDPOINTLISTADDR;	/*  (0x158) Device Controller Endpoint List
+					    Address */
+	u32 TTCTRL;		/*  (0x15C) Host Controller Embedded TT
+					    Asynchronous Buffer Control */
+	u32 BURSTSIZE;		/*  (0x160) Host Controller Embedded TT
+					    Asynchronous Buffer Status */
+	u32 TXFILLTUNING;	/*  (0x164) TX Full Tuning */
+	u32 TXTTFILLTUNING;	/*  (0x168) TT TX Full Tuning */
+	u32 Reserved16C;
+	u32 ULPIVIEWPORT;	/*  (0x170) ULPI Viewport */
+	u32 Reserved174;
+	u32 ENDPTNAK;		/*  (0x178) Endpoint NACK Received */
+	u32 ENDPTNAKEN;		/*  (0x17C) Endpoint NACK Received Interrupt
+					    Enable */
+	u32 CONFIGFLAG;		/*  (0x180) Configuration Flag Register */
+	u32 PORTSC[8];		/*  (0x184_1A0) Port Status */
+	u32 OTGSC;		/*  (0x1A4) OTG Status Control Register */
+	u32 USB_MODE;		/*  (0x1A8) USB Deivce Mode Register */
+	u32 ENDPTSETUPSTAT;	/*  (0x1AC) Endpoint Setup Status Register */
+	u32 ENDPTPRIME;		/*  (0x1B0) Endpoint Initializetion Register */
+	u32 ENDPTFLUSH;		/*  (0x1B4) Endpoint De-Initialize Register */
+	u32 ENDPTSTATUS;	/*  (0x1B8) Endpoint Status Register */
+	u32 ENDPTCOMPLETE;	/*  (0x1BC) Endpoint Complete Register */
+	u32 ENDPTCTRL[16];	/*  (0x1C0) Endpoint Control Register */
+} __attribute__ ((aligned(32))) T_FC_REGS, *PT_FC_REGS;
+
+/*-------------------------------------------------------------------------*/
+/*  Host Registers */
+struct _T_HC_REGS {
+	u32 USBCMD;		/*  (0x140) USB Command Register */
+	u32 USBSTS;		/*  (0x144) USB Status Register */
+	u32 USBINTR;		/*  (0x148) USB Interrupt Enable Register */
+	u32 FRINDEX;		/*  (0x14C) USB Frame Index Register */
+	u32 Reserved150;
+	u32 PERIODICLISTBASE;	/*  (0x154) Host Controller
+					    Frame List Base Address */
+	u32 ASYNCLISTADDR;	/*  (0x158) Host Controller
+					    next Asynchronous Address */
+	u32 TTCTRL;		/*  (0x15C) Host Controller Embedded TT
+					    Asynchronous Buffer Control */
+	u32 BURSTSIZE;		/*  (0x160) Host Controller Embedded TT
+					    Asynchronous Buffer Status */
+	u32 TXFILLTUNING;	/*  (0x164) TX Full Tuning */
+	u32 TXTTFILLTUNING;	/*  (0x168) TT TX Full Tuning */
+	u32 Reserved16C;
+	u32 ULPIVIEWPORT;	/*  (0x170) ULPI Viewport */
+	u32 Reserved174;
+	u32 ENDPTNAK;		/*  (0x178) Endpoint NACK Received */
+	u32 ENDPTNAKEN;		/*  (0x17C) Endpoint NACK Received
+					    Interrupt Enable */
+	u32 CONFIGFLAG;		/*  (0x180) Configuration Flag Register */
+	u32 PORTSC[8];		/*  (0x184_1A0) Port Status */
+	u32 OTGSC;		/*  (0x1A4) OTG Status Control Register */
+	u32 USB_MODE;		/*  (0x1A8) USB Deivce Mode Register */
+	u32 ENDPTSETUPSTAT;	/*  (0x1AC) Endpoint Setup Status Register */
+	u32 ENDPTPRIME;		/*  (0x1B0) Endpoint Initializetion Register */
+	u32 ENDPTFLUSH;		/*  (0x1B4) Endpoint De-Initialize Register */
+	u32 ENDPTSTATUS;	/*  (0x1B8) Endpoint Status Register */
+	u32 ENDPTCOMPLETE;	/*  (0x1BC) Endpoint Complete Register */
+	u32 ENDPTCTRL[16];	/*  (0x1C0) Endpoint Control Register */
+} __attribute__ ((aligned(32))) T_HC_REGS, *PT_HC_REGS;
+
+/*-------------------------------------------------------------------------*/
+#ifdef USE_PHY_TYPE
+enum _TAG_PHY_TYPE {
+	UNKNOWN_PHY = 0,
+	NXP_PHY,
+	SMSC_PHY,
+	END_PHY
+} ENUM_PHY_TYPE;
+
+
+struct _T_PHY_TYPE {
+	ENUM_PHY_TYPE	phy_type;	/* PHY TYPE   */
+	u16		vendorID;	/* Vendor ID  */
+	u16		productID;	/* Product ID */
+} T_PHY_TYPE, *PT_PHY_TYPE;
+#endif	/* USE_PHY_TYPE */
+
+struct mp200_hcd_work {
+	spinlock_t lock;
+
+	int	idint_irq;		/* Interrupt number of terminal ID */
+
+	u64	dma_mask;
+
+	void __iomem *addr_reg;
+	void __iomem *data_reg;
+
+#ifdef USE_PHY_TYPE
+	ENUM_PHY_TYPE	phy_type;	/* PHY TYPE */
+#endif	/* USE_PHY_TYPE */
+};
+
+
+
+
+
+
+/*-------------------------------------------------------------------------*/
+static inline struct mp200_hcd *hcd_to_mp200_hcd(struct usb_hcd *hcd)
+{
+	return (struct mp200_hcd *)(hcd->hcd_priv);
+}
+
+static inline struct usb_hcd *mp200_hcd_to_hcd(struct mp200_hcd *mp200_hcd)
+{
+	return container_of((void *)mp200_hcd, struct usb_hcd, hcd_priv);
+}
+
+
+
+/*-------------------------------------------------------------------------*/
+/*  read(DWORD) */
+static inline u32 mp200st_udc_readl(u32 *adrs)
+{
+	return ioread32(adrs);
+}
+
+/*-------------------------------------------------------------------------*/
+/*  write(DWORD) */
+static inline void mp200st_udc_writel(u32 *adrs, u32 data)
+{
+	iowrite32((data), (adrs));
+}
+
+/*-------------------------------------------------------------------------*/
+/*  maskget */
+static inline u32 mp200st_udc_mask_get_bit(u32 *adrs, u32 mask)
+{
+	return mp200st_udc_readl(adrs) & mask;
+}
+
+/*-------------------------------------------------------------------------*/
+/*  maskset */
+static inline void mp200st_udc_mask_set_bit(u32 *adrs, u32 mask, u32 data)
+{
+	u32	tmp;
+	tmp = (mp200st_udc_readl(adrs) & ~mask) | data;
+	mp200st_udc_writel(adrs, tmp);
+}
+
+/*-------------------------------------------------------------------------*/
+/*  bitclear */
+static inline void mp200st_udc_clear_bit(u32 *adrs, u32 data)
+{
+	u32	tmp;
+	tmp = mp200st_udc_readl(adrs) & ~data;
+	mp200st_udc_writel(adrs, tmp);
+}
+
+/*-------------------------------------------------------------------------*/
+/*  bitset */
+static inline void mp200st_udc_set_bit(u32 *adrs, u32 data)
+{
+	u32	tmp;
+	tmp = mp200st_udc_readl(adrs) | data;
+	mp200st_udc_writel(adrs, tmp);
+}
+
+#define ULPI_REPEATED_COUNT	100
+
+/*-------------------------------------------------------------------------*/
+/*  ULPI Read */
+static inline int mp200st_udc_ulpi_read(u32 *adrs, u8 phy_adrs)
+{
+	int	i, status = -EIO;
+	u32	tmp_viewport;
+
+	tmp_viewport = ULPIVIEWPORT_ULPIRUN | (phy_adrs << 16);
+	mp200st_udc_writel(adrs, tmp_viewport);
+
+	for (i = 0; i < ULPI_REPEATED_COUNT; i++) {
+		tmp_viewport = mp200st_udc_readl(adrs);
+		if (tmp_viewport & ULPIVIEWPORT_ULPIRUN) {
+			continue;
+		} else {
+			status = (((tmp_viewport
+				& ULPIVIEWPORT_ULPIDATRD) >> 8) & 0xFF);
+			break;
+		}
+	}
+
+	return status;
+}
+
+/*-------------------------------------------------------------------------*/
+/*  ULPI Write */
+static inline int mp200st_udc_ulpi_write(u32 *adrs, u8 phy_adrs, u8 data)
+{
+	int		i, status = -EIO;
+	u32		tmp_viewport;
+
+	tmp_viewport = ULPIVIEWPORT_ULPIRUN | ULPIVIEWPORT_ULPIRW
+		| (phy_adrs << 16) | data;
+	mp200st_udc_writel(adrs, tmp_viewport);
+
+	for (i = 0; i < ULPI_REPEATED_COUNT; i++) {
+		tmp_viewport = mp200st_udc_readl(adrs);
+		if ((tmp_viewport & ULPIVIEWPORT_ULPIRUN) == 0) {
+			status = 0;
+			break;
+		}
+	}
+
+	return status;
+}
+
+/*-------------------------------------------------------------------------*/
+static inline char *usb_debug_get_file_name(char *p_filename)
+{
+	int		pos, len, i;
+	char *p;
+
+	pos = 0;
+	p = p_filename;
+	len = strlen(p);
+
+	for (i = 0; i < len; i++) {
+		if (p[i] == '/')
+			pos = i+1;
+	}
+
+	p = p + pos;
+
+	return p;
+}
+
+#ifdef USE_DEBUG_MESSAGE_ALL
+
+	#ifdef USE_DEBUG_MESSAGE
+		#define DBG_MSG(format, arg...) \
+			printk(KERN_DEBUG "%s : " format "\n", \
+				usb_debug_get_file_name(__FILE__), ## arg)
+	#else
+		#define DBG_MSG(format, arg...) do {} while (0)
+	#endif
+
+	#define DBG_MSGG(format, arg...) do {} while (0)
+
+	#ifdef USE_INFOMATION_MESSAGE
+		#define INFO_MSG(format, arg...) \
+			printk(KERN_INFO "%s : " format "\n", \
+				usb_debug_get_file_name(__FILE__), ## arg)
+	#else
+		#define INFO_MSG(format, arg...) do {} while (0)
+	#endif
+	#define INFO_MSGG(format, arg...) do {} while (0)
+
+#else	/* !USE_DEBUG_MESSAGE_ALL */
+
+	#define DBG_MSG(format, arg...) do {} while (0)
+	#define DBG_MSGG(format, arg...) do {} while (0)
+	#define INFO_MSG(format, arg...) do {} while (0)
+	#define INFO_MSGG(format, arg...) do {} while (0)
+
+#endif	/* USE_DEBUG_MESSAGE_ALL */
+
+#define ERR_MSG(format, arg...) \
+	printk(KERN_ERR "%s : *** Error *** " format "\n", \
+		usb_debug_get_file_name(__FILE__), ## arg)
+#define WARN_MSG(format, arg...) \
+	printk(KERN_WARNING "%s : === Warning === " format "\n", \
+		usb_debug_get_file_name(__FILE__), ## arg)
+
+#endif /* __EHCI_MP200_H */
-- 
1.6.5.2

