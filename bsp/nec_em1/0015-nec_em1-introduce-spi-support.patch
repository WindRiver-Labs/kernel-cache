From 70c4544a2199698e373e3792421b533b8721068b Mon Sep 17 00:00:00 2001
From: Kazuya Tsukamoto <kazuya.tsukamoto@necel.com>
Date: Mon, 9 Nov 2009 12:10:01 +0900
Subject: [PATCH 15/29] nec_em1: introduce spi support

SPI is used in EMMA Mobile Develpment Kit Board for pwc,lcd,etc

This introduces the spi driver and the kbuild bindings. If
new drivers are being added, this Makefile and Kconfig can
be used as the base.

Signed-off-by: Kazuya Tsukamoto <kazuya.tsukamoto@necel.com>
---
 arch/arm/mach-mp200/include/mach/spi.h |  338 +++++
 drivers/char/Kconfig                   |   69 +
 drivers/char/Makefile                  |    8 +
 drivers/char/mp200_spi.c               | 2422 ++++++++++++++++++++++++++++++++
 drivers/char/mp200_spi.h               |  254 ++++
 drivers/char/mp200_spi0.c              | 1143 +++++++++++++++
 drivers/char/mp200_spi0.h              |  228 +++
 drivers/char/mp200_spi_kern.c          |  322 +++++
 drivers/char/mp200_spi_kern.h          |  169 +++
 9 files changed, 4953 insertions(+), 0 deletions(-)
 create mode 100644 arch/arm/mach-mp200/include/mach/spi.h
 create mode 100644 drivers/char/mp200_spi.c
 create mode 100644 drivers/char/mp200_spi.h
 create mode 100644 drivers/char/mp200_spi0.c
 create mode 100644 drivers/char/mp200_spi0.h
 create mode 100644 drivers/char/mp200_spi_kern.c
 create mode 100644 drivers/char/mp200_spi_kern.h

diff --git a/arch/arm/mach-mp200/include/mach/spi.h b/arch/arm/mach-mp200/include/mach/spi.h
new file mode 100644
index 0000000..7d7a3e3
--- /dev/null
+++ b/arch/arm/mach-mp200/include/mach/spi.h
@@ -0,0 +1,338 @@
+/*
+ *  File Name	    : linux/include/asm-arm/arch-mp200/spi.h
+ *  Function	    : MP200 SPI interface
+ *  Release Version : Ver 0.01
+ *  Release Date    : 2007/07/11
+ *
+ *  Copyright (C) NEC Electronics Corporation 2005-2006
+ *
+ *
+ *  This program is free software;you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License as published by Free
+ *  Softwere Foundation; either version 2 of License, or (at your option) any
+ *  later version.
+ *
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warrnty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; If not, write to the Free Software Foundation, Inc., 59
+ *  Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#ifndef __ASM_ARM_ARCH_MP200_SPI_H
+#define __ASM_ARM_ARCH_MP200_SPI_H
+
+
+#if defined(CONFIG_MP200_SPI) || defined(CONFIG_MP200_SPI0) \
+	|| defined(CONFIG_MP200_SPI_KERN)
+
+/* SPI_CONFIG */
+struct spi_config_t{
+	unsigned char dev;      /* device */
+	unsigned int pol;       /* poll */
+	unsigned int sclk;      /* clock */
+
+/* spi_write_without_intr only */
+	unsigned int size;      /* byte size */
+	unsigned int mode;      /* mode */
+
+/* spi_read/spi_write/spi_cmd_read only */
+	unsigned int nbr;       /* bit length (read) */
+	unsigned int nbw;       /* bit length (write) */
+	unsigned int cs_sel;    /* chip select */
+	unsigned int m_s;       /* master/slave */
+	unsigned int dma;       /* dma on/off */
+	unsigned int tiecs;     /* tiecs */
+};
+
+#define SPI_CONFIG struct spi_config_t
+
+/* SPI_CONFIG.nbr/nbw (8 to 32) */
+/* spi_mode_t.nb */
+#define SPI_NB_8BIT              8
+#define SPI_NB_16BIT            16
+#define SPI_NB_24BIT            24
+#define SPI_NB_32BIT            32
+
+/* SPI_CONFIG.cs_sel */
+/* spi_mode_t.cs_sel */
+#define SPI_CS_SEL_CS0          0
+#define SPI_CS_SEL_CS1          1
+#define SPI_CS_SEL_CS2          2
+#define SPI_CS_SEL_CS3          3
+#define SPI_CS_SEL_CS4          4
+#define SPI_CS_SEL_CS5          5
+
+/* SPI_CONFIG.m_s */
+/* spi_mode_t.m_s */
+#define SPI_M_S_MASTER          0
+#define SPI_M_S_SLAVE           1
+
+/* SPI_CONFIG.dma */
+/* spi_mode_t.dma */
+#define SPI_DMA_OFF             0
+#define SPI_DMA_ON              1
+
+/* SPI_CONFIG.sclk */
+/* spi_mode_t.sclk */
+#define SPI_SCLK_1500KHZ        0
+#define SPI_SCLK_3MHZ           1
+#define SPI_SCLK_6MHZ           2
+#define SPI_SCLK_12MHZ          3
+#define SPI_SCLK_24MHZ          4
+#define SPI_SCLK_48MHZ          5
+
+/* SPI_CONFIG.tiecs */
+#define SPI_TIECS_NORMAL        0
+#define SPI_TIECS_FIXED         1
+
+/* flags */
+#define SPI_BLOCK               0
+#define SPI_NONBLOCK            1
+#define SPI_RW_2CYCLE           2
+
+#endif /* defined(CONFIG_MP200_SPI) || defined(CONFIG_MP200_SPI0) \
+	  || defined(CONFIG_MP200_SPI_KERN) */
+
+#if defined(CONFIG_MP200_SPI) || defined(CONFIG_MP200_SPI_KERN)
+
+/* SPI_CONFIG.dev */
+#define SPI_DEV_SPI0            0
+#define SPI_DEV_SPI1            1
+#define SPI_DEV_SPI2            2
+
+/* SPI_CONFIG.pol */
+#define SPI_POL_CSW_16SCLK      (0x0F << 12)
+#define SPI_POL_CSW_8SCLK       (0x07 << 12)
+#define SPI_POL_CSW_4SCLK       (0x03 << 12)
+#define SPI_POL_CSW_2SCLK       (0x01 << 12)
+
+#define SPI_POL_CK5_DLY_ON      (0x01 << 21)
+#define SPI_POL_CK5_DLY_OFF     (0x00 << 21)
+#define SPI_POL_CK5_POL_NEG     (0x01 << 20)
+#define SPI_POL_CK5_POL_POS     (0x00 << 20)
+#define SPI_POL_CS5_POL_NEG     (0x01 << 19)
+#define SPI_POL_CS5_POL_POS     (0x00 << 19)
+
+#define SPI_POL_CK4_DLY_ON      (0x01 << 18)
+#define SPI_POL_CK4_DLY_OFF     (0x00 << 18)
+#define SPI_POL_CK4_POL_NEG     (0x01 << 17)
+#define SPI_POL_CK4_POL_POS     (0x00 << 17)
+#define SPI_POL_CS4_POL_NEG     (0x01 << 16)
+#define SPI_POL_CS4_POL_POS     (0x00 << 16)
+
+#define SPI_POL_CK3_DLY_ON      (0x01 << 11)
+#define SPI_POL_CK3_DLY_OFF     (0x00 << 11)
+#define SPI_POL_CK3_POL_NEG     (0x01 << 10)
+#define SPI_POL_CK3_POL_POS     (0x00 << 10)
+#define SPI_POL_CS3_POL_NEG     (0x01 << 9)
+#define SPI_POL_CS3_POL_POS     (0x00 << 9)
+
+#define SPI_POL_CK2_DLY_ON      (0x01 << 8)
+#define SPI_POL_CK2_DLY_OFF     (0x00 << 8)
+#define SPI_POL_CK2_POL_NEG     (0x01 << 7)
+#define SPI_POL_CK2_POL_POS     (0x00 << 7)
+#define SPI_POL_CS2_POL_NEG     (0x01 << 6)
+#define SPI_POL_CS2_POL_POS     (0x00 << 6)
+
+#define SPI_POL_CK1_DLY_ON      (0x01 << 5)
+#define SPI_POL_CK1_DLY_OFF     (0x00 << 5)
+#define SPI_POL_CK1_POL_NEG     (0x01 << 4)
+#define SPI_POL_CK1_POL_POS     (0x00 << 4)
+#define SPI_POL_CS1_POL_NEG     (0x01 << 3)
+#define SPI_POL_CS1_POL_POS     (0x00 << 3)
+
+#define SPI_POL_CK0_DLY_ON      (0x01 << 2)
+#define SPI_POL_CK0_DLY_OFF     (0x00 << 2)
+#define SPI_POL_CK0_POL_NEG     (0x01 << 1)
+#define SPI_POL_CK0_POL_POS     (0x00 << 1)
+#define SPI_POL_CS0_POL_NEG     (0x01 << 0)
+#define SPI_POL_CS0_POL_POS     (0x00 << 0)
+
+/* SPI_POL: default value */
+#define SPI_POL_VAL_SPI0        (SPI_POL_CSW_8SCLK | \
+		SPI_POL_CK5_DLY_OFF | SPI_POL_CK5_POL_NEG | \
+		SPI_POL_CS5_POL_NEG | SPI_POL_CK4_DLY_OFF | \
+		SPI_POL_CK4_POL_NEG | SPI_POL_CS4_POL_NEG | \
+		SPI_POL_CK3_DLY_OFF | SPI_POL_CK3_POL_NEG | \
+		SPI_POL_CS3_POL_NEG | SPI_POL_CK2_DLY_OFF | \
+		SPI_POL_CK2_POL_POS | SPI_POL_CS2_POL_NEG | \
+		SPI_POL_CK1_DLY_ON  | SPI_POL_CK1_POL_POS | \
+		SPI_POL_CS1_POL_NEG | SPI_POL_CK0_DLY_ON  | \
+		SPI_POL_CK0_POL_POS | SPI_POL_CS0_POL_POS)
+
+#define SPI_POL_VAL_SPI1        (SPI_POL_CSW_8SCLK | \
+		SPI_POL_CK5_DLY_OFF | SPI_POL_CK5_POL_NEG | \
+		SPI_POL_CS5_POL_NEG | SPI_POL_CK4_DLY_OFF | \
+		SPI_POL_CK4_POL_NEG | SPI_POL_CS4_POL_NEG | \
+		SPI_POL_CK3_DLY_OFF | SPI_POL_CK3_POL_NEG | \
+		SPI_POL_CS3_POL_NEG | SPI_POL_CK2_DLY_OFF | \
+		SPI_POL_CK2_POL_NEG | SPI_POL_CS2_POL_NEG | \
+		SPI_POL_CK1_DLY_OFF | SPI_POL_CK1_POL_NEG | \
+		SPI_POL_CS1_POL_NEG | SPI_POL_CK0_DLY_OFF | \
+		SPI_POL_CK0_POL_NEG | SPI_POL_CS0_POL_NEG)
+
+#define SPI_POL_VAL_SPI2        (SPI_POL_CSW_8SCLK | \
+		SPI_POL_CK5_DLY_OFF | SPI_POL_CK5_POL_NEG | \
+		SPI_POL_CS5_POL_NEG | SPI_POL_CK4_DLY_OFF | \
+		SPI_POL_CK4_POL_NEG | SPI_POL_CS4_POL_NEG | \
+		SPI_POL_CK3_DLY_OFF | SPI_POL_CK3_POL_NEG | \
+		SPI_POL_CS3_POL_NEG | SPI_POL_CK2_DLY_OFF | \
+		SPI_POL_CK2_POL_NEG | SPI_POL_CS2_POL_NEG | \
+		SPI_POL_CK1_DLY_OFF | SPI_POL_CK1_POL_NEG | \
+		SPI_POL_CS1_POL_NEG | SPI_POL_CK0_DLY_OFF | \
+		SPI_POL_CK0_POL_NEG | SPI_POL_CS0_POL_NEG)
+
+/* rst_flag */
+#define SPI_RESET_OFF           0
+#define SPI_RESET_ON            1
+
+extern int
+spi_write_without_intr(const SPI_CONFIG *config, const char *buf, int rst_flag);
+
+/*
+ * spi mode info
+ */
+struct spi_mode_info{
+	unsigned int nb;        /* bit length */
+	unsigned int cs_sel;    /* chip select */
+	unsigned int m_s;       /* master/slave */
+	unsigned int dma;       /* dma on/off */
+	unsigned int blksize;   /* block size */
+	unsigned int sclk;      /* clock */
+};
+
+#define spi_mode_t struct spi_mode_info
+
+/* SPI_CONFIG.mode */
+#define SPI_MODE_NB_8BIT        (0x07 << 8)
+#define SPI_MODE_NB_16BIT       (0x0F << 8)
+#define SPI_MODE_NB_24BIT       (0x17 << 8)
+#define SPI_MODE_NB_32BIT       (0x1F << 8)
+
+#define SPI_MODE_CS_SEL_CS0     (0x00 << 4)
+#define SPI_MODE_CS_SEL_CS1     (0x01 << 4)
+#define SPI_MODE_CS_SEL_CS2     (0x02 << 4)
+#define SPI_MODE_CS_SEL_CS3     (0x03 << 4)
+#define SPI_MODE_CS_SEL_CS4     (0x04 << 4)
+#define SPI_MODE_CS_SEL_CS5     (0x05 << 4)
+
+#define SPI_MODE_M_S_MASTER     (0x00 << 1)
+#define SPI_MODE_M_S_SLAVE      (0x01 << 1)
+
+#define SPI_MODE_DMA_OFF        (0x00 << 0)
+#define SPI_MODE_DMA_ON         (0x01 << 0)
+
+/* read/write mode*/
+#define SPI_READ_MODE      1
+#define SPI_WRITE_MODE     2
+
+/*
+ * operation command
+ */
+#define SPI_CMD_RX_START        _IO('s', 0x01)
+#define SPI_CMD_RX_STOP         _IO('s', 0x02)
+
+/*
+ * setting command
+ */
+#define SPI_CMD_GET_MODE        _IOR('s', 0x11, spi_mode_t)
+#define SPI_CMD_SET_MODE        _IOW('s', 0x12, spi_mode_t)
+
+#endif /* defined(CONFIG_MP200_SPI) || defined(CONFIG_MP200_SPI_KERN) */
+
+#ifdef CONFIG_MP200_SPI
+extern int mp201_spi_read(unsigned char dev, char *buf,
+			  unsigned int count, unsigned char block_mode);
+
+extern int mp201_spi_write(unsigned char dev, const char *buf,
+			   unsigned int count, unsigned char block_mode);
+
+extern int mp201_spi_init(unsigned char dev, unsigned char rw_mode);
+
+extern int mp201_spi_end(unsigned char dev);
+
+extern int mp201_spi_setmode(unsigned char dev, spi_mode_t *mode);
+
+extern int mp201_spi_getmode(unsigned char dev, spi_mode_t *mode);
+#endif /* CONFIG_MP200_SPI */
+
+
+#ifdef CONFIG_MP200_SPI0
+
+/* SPI_CONFIG.dev */
+#define SPI_DEV_SP0             0
+#define SPI_DEV_SP1             1
+#define SPI_DEV_SP2             2
+
+/* SPI_CONFIG.pol */
+#define SPI_CSW_1CLK            (0 << 12)
+#define SPI_CSW_2CLK            (1 << 12)
+#define SPI_CSW_4CLK            (3 << 12)
+#define SPI_CSW_8CLK            (7 << 12)
+#define SPI_CSW_16CLK           (15 << 12)
+
+#define SPI_CK_DLY_OFF          (0 << 2)
+#define SPI_CK_DLY_ON           (1 << 2)
+
+#define SPI_CK_POL_POS          (0 << 1)
+#define SPI_CK_POL_NEG          (1 << 1)
+
+#define SPI_CS_POL_POS          (0 << 0)
+#define SPI_CS_POL_NEG          (1 << 0)
+
+/* SPI_CONFIG.pol : default value */
+#define SPI_POL_SP0_CS0		\
+	(SPI_CSW_8CLK | SPI_CK_DLY_ON | SPI_CK_POL_POS | SPI_CS_POL_POS)
+#define SPI_POL_SP0_CS1		\
+	(SPI_CSW_8CLK | SPI_CK_DLY_ON | SPI_CK_POL_POS | SPI_CS_POL_NEG)
+#define SPI_POL_SP0_CS2		\
+	(SPI_CSW_8CLK | SPI_CK_DLY_OFF | SPI_CK_POL_POS | SPI_CS_POL_NEG)
+#define SPI_POL_SP0_CS3		\
+	(SPI_CSW_8CLK | SPI_CK_DLY_OFF | SPI_CK_POL_NEG | SPI_CS_POL_NEG)
+#define SPI_POL_SP0_CS4		\
+	(SPI_CSW_8CLK | SPI_CK_DLY_OFF | SPI_CK_POL_NEG | SPI_CS_POL_NEG)
+#define SPI_POL_SP0_CS5		\
+	(SPI_CSW_8CLK | SPI_CK_DLY_OFF | SPI_CK_POL_NEG | SPI_CS_POL_NEG)
+
+#define SPI_POL_SP1_CS0		\
+	(SPI_CSW_8CLK | SPI_CK_DLY_OFF | SPI_CK_POL_NEG | SPI_CS_POL_NEG)
+#define SPI_POL_SP1_CS1		\
+	(SPI_CSW_8CLK | SPI_CK_DLY_OFF | SPI_CK_POL_NEG | SPI_CS_POL_NEG)
+#define SPI_POL_SP1_CS2		\
+	(SPI_CSW_8CLK | SPI_CK_DLY_OFF | SPI_CK_POL_NEG | SPI_CS_POL_NEG)
+#define SPI_POL_SP1_CS3		\
+	(SPI_CSW_8CLK | SPI_CK_DLY_OFF | SPI_CK_POL_NEG | SPI_CS_POL_NEG)
+#define SPI_POL_SP1_CS4		\
+	(SPI_CSW_8CLK | SPI_CK_DLY_OFF | SPI_CK_POL_NEG | SPI_CS_POL_NEG)
+#define SPI_POL_SP1_CS5		\
+	(SPI_CSW_8CLK | SPI_CK_DLY_OFF | SPI_CK_POL_NEG | SPI_CS_POL_NEG)
+
+#define SPI_POL_SP2_CS0		\
+	(SPI_CSW_8CLK | SPI_CK_DLY_OFF | SPI_CK_POL_NEG | SPI_CS_POL_NEG)
+#define SPI_POL_SP2_CS1		\
+	(SPI_CSW_8CLK | SPI_CK_DLY_OFF | SPI_CK_POL_NEG | SPI_CS_POL_NEG)
+#define SPI_POL_SP2_CS2		\
+	(SPI_CSW_8CLK | SPI_CK_DLY_OFF | SPI_CK_POL_NEG | SPI_CS_POL_NEG)
+#define SPI_POL_SP2_CS3		\
+	(SPI_CSW_8CLK | SPI_CK_DLY_OFF | SPI_CK_POL_NEG | SPI_CS_POL_NEG)
+#define SPI_POL_SP2_CS4		\
+	(SPI_CSW_8CLK | SPI_CK_DLY_OFF | SPI_CK_POL_NEG | SPI_CS_POL_NEG)
+#define SPI_POL_SP2_CS5		\
+	(SPI_CSW_8CLK | SPI_CK_DLY_OFF | SPI_CK_POL_NEG | SPI_CS_POL_NEG)
+
+extern int spi_read(SPI_CONFIG *config, char *buf, unsigned long phys,
+		    unsigned int count, unsigned int flags);
+extern int spi_write(SPI_CONFIG *config, char *buf, unsigned long phys,
+		     unsigned int count, unsigned int flags);
+extern int spi_cmd_read(SPI_CONFIG *config, char *cmd, char *buf,
+			unsigned int flags);
+
+#endif /* CONFIG_MP200_SPI0 */
+
+
+#endif                          /* __ASM_ARM_ARCH_MP200_SPI_H */
diff --git a/drivers/char/Kconfig b/drivers/char/Kconfig
index caff851..e1281d0 100644
--- a/drivers/char/Kconfig
+++ b/drivers/char/Kconfig
@@ -812,6 +812,46 @@ config JS_RTC
 	  To compile this driver as a module, choose M here: the
 	  module will be called js-rtc.
 
+config RTC_HISTOGRAM
+	bool "Real Time Clock Histogram Support"
+	default n
+	depends on RTC
+	---help---
+	  If you say Y here then the kernel will track the delivery and
+	  wakeup latency of /dev/rtc using tasks and will report a
+	  histogram to the kernel log when the application closes /dev/rtc.
+
+config BLOCKER
+	tristate "Priority Inheritance Debugging (Blocker) Device Support"
+	depends on X86
+	default y
+	---help---
+	  If you say Y here then a device will be created that the userspace
+	  pi_test suite uses to test and measure kernel locking primitives.
+
+config LPPTEST
+	tristate "Parallel Port Based Latency Measurement Device"
+	depends on !PARPORT && X86
+	default y
+	---help---
+	  If you say Y here then a device will be created that the userspace
+	  testlpp utility uses to measure IRQ latencies of a target system
+	  from an independent measurement system.
+
+	  NOTE: this code assumes x86 PCs and that the parallel port is
+	  bidirectional and is on IRQ 7.
+
+	  to use the device, both the target and the source system needs to
+	  run a kernel with CONFIG_LPPTEST enabled. To measure latencies,
+	  use the scripts/testlpp utility in your kernel source directory,
+	  and run it (as root) on the source system - it will start printing
+	  out the latencies it took to get a response from the target system:
+
+	    Latency of response: 12.2 usecs (121265 cycles)
+
+	  then generate various workloads on the target system to see how
+	  (worst-case-) latencies are impacted.
+
 config SGI_DS1286
 	tristate "SGI DS1286 RTC support"
 	depends on SGI_HAS_DS1286
@@ -874,6 +914,35 @@ config DS1302
 
 endif # RTC_LIB
 
+config MP200_SPI0
+	tristate "MP200 SPI0 Driver"
+	depends on ARCH_MP200
+
+config MP200_SPI
+	tristate "MP200 SPI Driver"
+	depends on ARCH_MP200
+
+config MP200_SPI_KERN
+	tristate "MP200 SPI_KERN Driver"
+	depends on ARCH_MP200
+
+config MP200_PWM
+	tristate "MP200 PWM support"
+	depends on ARCH_MP200
+
+config MP200_PWC
+	tristate "EM1 PWC Driver"
+	depends on ARCH_MP200
+
+config MP200_DTV
+        tristate "MP200 DTV Interface support"
+        depends on ARCH_MP200
+
+config MP200_DTV_BUFFERSIZE
+        int "DMA buffer size (752-)[byte]"
+        depends on MP200_DTV
+        default "8192"
+
 config DTLK
 	tristate "Double Talk PC internal speech card support"
 	depends on ISA
diff --git a/drivers/char/Makefile b/drivers/char/Makefile
index 6850f6d..ddc19cc 100644
--- a/drivers/char/Makefile
+++ b/drivers/char/Makefile
@@ -77,6 +77,12 @@ obj-$(CONFIG_EFI_RTC)		+= efirtc.o
 obj-$(CONFIG_SGI_DS1286)	+= ds1286.o
 obj-$(CONFIG_SGI_IP27_RTC)	+= ip27-rtc.o
 obj-$(CONFIG_DS1302)		+= ds1302.o
+obj-$(CONFIG_MP200_SPI_KERN)	+= mp200_spi_kern.o
+obj-$(CONFIG_MP200_SPI0)	+= mp200_spi0.o
+obj-$(CONFIG_MP200_SPI)		+= mp200_spi.o
+obj-$(CONFIG_MP200_PWC)		+= mp200_pwc.o
+obj-$(CONFIG_MP200_PWM)		+= mp200_pwm.o
+obj-$(CONFIG_MP200_DTV)         += mp200_dtv.o
 obj-$(CONFIG_XILINX_HWICAP)	+= xilinx_hwicap/
 ifeq ($(CONFIG_GENERIC_NVRAM),y)
   obj-$(CONFIG_NVRAM)	+= generic_nvram.o
@@ -87,6 +93,8 @@ obj-$(CONFIG_TOSHIBA)		+= toshiba.o
 obj-$(CONFIG_I8K)		+= i8k.o
 obj-$(CONFIG_DS1620)		+= ds1620.o
 obj-$(CONFIG_HW_RANDOM)		+= hw_random/
+obj-$(CONFIG_BLOCKER)		+= blocker.o
+obj-$(CONFIG_LPPTEST)		+= lpptest.o
 obj-$(CONFIG_PPDEV)		+= ppdev.o
 obj-$(CONFIG_NWBUTTON)		+= nwbutton.o
 obj-$(CONFIG_NWFLASH)		+= nwflash.o
diff --git a/drivers/char/mp200_spi.c b/drivers/char/mp200_spi.c
new file mode 100644
index 0000000..293b5bb
--- /dev/null
+++ b/drivers/char/mp200_spi.c
@@ -0,0 +1,2422 @@
+/*
+ *  File Name       : linux/drivers/char/mp200_spi.c
+ *  Function        : MP200 SPI interface
+ *  Release Version : Ver 1.03
+ *  Release Date    : 2009/02/04
+ *
+ *  Copyright (C) NEC Electronics Corporation 2009
+ *
+ *
+ *  This program is free software;you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License as published by Free
+ *  Softwere Foundation; either version 2 of License, or (at your option) any
+ *  later version.
+ *
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warrnty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; If not, write to the Free Software Foundation, Inc., 59
+ *  Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/poll.h>
+#include <linux/delay.h>
+#include <linux/dma-mapping.h>
+#include <linux/interrupt.h>
+#include <linux/cdev.h>
+#include <linux/platform_device.h>
+
+#include <linux/io.h>
+#include <mach/dma.h>
+#include <mach/smu.h>
+#include <mach/pmu.h>
+
+#include "mp200_spi.h"
+
+static void spi_interrupt_dma_rx(void *, int, int);
+static void spi_interrupt_dma_tx(void *, int, int);
+
+int spi_write_without_intr(const SPI_CONFIG *, const char *, int)
+__attribute__ ((weak));
+
+static int spi_open_chrdev(struct inode *inode, struct file *file);
+
+static int spi_major;
+static int spi_sleep_flag;
+
+static struct class        *spi_class;
+static dev_t t_dev;
+
+static const struct file_operations spi_fops = {
+	.owner   = THIS_MODULE,
+	.open    = spi_open_chrdev,
+};
+static struct cdev spi_cdev;
+
+static unsigned int spi_clock_table[] = {
+	1433,           /* (1434KHz) */
+	2867,           /* (2.87MHz) */
+	5734,           /* (5.73MHz) */
+	11468,          /* (11.47MHz) */
+	22937,          /* (22.94MHz) */
+	38229,          /* (38.23MHz) */
+};
+
+static unsigned int spi_plldiv_table[] = {
+	SMU_DIV160,     /* 1500KHz(1434KHz) */
+	SMU_DIV80,      /* 3MHz   (2.87MHz) */
+	SMU_DIV40,      /* 6MHz   (5.73MHz) */
+	SMU_DIV20,      /* 12MHz  (11.47MHz) */
+	SMU_DIV10,      /* 24MHz  (22.94MHz) */
+	SMU_DIV6,       /* 48MHz  (38.23MHz) */
+};
+
+/* spi mode info (SPI1) */
+static spi_mode_t mode_spi1 = {
+	.nb = SPI_NB_32BIT,
+	.cs_sel = SPI_CS_SEL_CS0,
+	.m_s = SPI_M_S_MASTER,
+	.dma = SPI_DMA_ON,
+	.sclk = SPI_SCLK_3MHZ,
+	.blksize = SPI_BLKSIZE,
+};
+
+/* spi mode info (SPI2) */
+static spi_mode_t mode_spi2 = {
+	.nb = SPI_NB_32BIT,
+	.cs_sel = SPI_CS_SEL_CS0,
+	.m_s = SPI_M_S_MASTER,
+	.dma = SPI_DMA_ON,
+	.sclk = SPI_SCLK_3MHZ,
+	.blksize = SPI_BLKSIZE,
+};
+
+/* transfer info (SPI1) */
+static spi_trans_t trans_spi1 = {
+	.dma_regs = NULL,
+	.rx_lch = MP200_DMAC_P2M_LCH13,
+	.tx_lch = MP200_DMAC_M2P_LCH13,
+	.rx_data = SPx_RX_DATA_PHYS(MP200_SP1_BASE),
+	.tx_data = SPx_TX_DATA_PHYS(MP200_SP1_BASE),
+	.int_spi = INT_SP1,
+	.dma_err = 0,
+	.spi_err = 0,
+	.state = SPI_STOP,
+	.spinlock = __SPIN_LOCK_UNLOCKED(trans_spi1.spinlock),
+};
+
+/* transfer info (SPI2) */
+static spi_trans_t trans_spi2 = {
+	.dma_regs = NULL,
+	.rx_lch = MP200_DMAC_P2M_LCH14,
+	.tx_lch = MP200_DMAC_M2P_LCH14,
+	.rx_data = SPx_RX_DATA_PHYS(MP200_SP2_BASE),
+	.tx_data = SPx_TX_DATA_PHYS(MP200_SP2_BASE),
+	.int_spi = INT_SP2,
+	.dma_err = 0,
+	.spi_err = 0,
+	.state = SPI_STOP,
+	.spinlock = __SPIN_LOCK_UNLOCKED(trans_spi2.spinlock),
+};
+
+/* smu info (SPI1) */
+static spi_smu_t smu_spi1 = {
+	.pclk = MP200_CLOCKGATE_SP1_PCLK,
+	.sclk = MP200_CLOCKGATE_SP1_SCLK,
+	.pclk_ctrl = MP200_CLKCTRL_SP1PCLK,
+	.sclk_ctrl = MP200_CLKCTRL_SP1SCLK,
+	.reset = MP200_RESETDEVICE_SP1,
+	.div_sclk = SMU_DIVSP1SCLK,
+};
+
+/* smu info (SPI2) */
+static spi_smu_t smu_spi2 = {
+	.pclk = MP200_CLOCKGATE_SP2_PCLK,
+	.sclk = MP200_CLOCKGATE_SP2_SCLK,
+	.pclk_ctrl = MP200_CLKCTRL_SP2PCLK,
+	.sclk_ctrl = MP200_CLKCTRL_SP2SCLK,
+	.reset = MP200_RESETDEVICE_SP2,
+	.div_sclk = SMU_DIVSP2SCLK,
+};
+
+/* spi data info */
+static spi_data_t spi_private[] = {
+	{
+		/* SP0 is Unsupported (Dummy) */
+	},
+	{
+		/* SP1 */
+		.regs = (spi_regs *)(SP1_ADDR),
+		.mode = &mode_spi1,
+		.pol = SPx_POL_VAL_SPI1,
+		.smu = &smu_spi1,
+		.trans = &trans_spi1,
+		.opened = 0,
+		.k_flag = 0,
+	},
+	{
+		/* SP2 */
+		.regs = (spi_regs *)(SP2_ADDR),
+		.mode = &mode_spi2,
+		.pol = SPx_POL_VAL_SPI2,
+		.smu = &smu_spi2,
+		.trans = &trans_spi2,
+		.opened = 0,
+		.k_flag = 0,
+	},
+};
+
+/*
+ * software reset
+ */
+static void spi_sft_reset(spi_data_t *spi)
+{
+	spi->regs->control |= SPx_CONTROL_RST;
+	udelay((4000 / spi_clock_table[spi->mode->sclk]) + 1);
+	spi->regs->control &= ~SPx_CONTROL_RST;
+}
+
+/*
+ * reset on/off
+ */
+static void spi_reset_ctrl(spi_data_t *spi, unsigned char onoff)
+{
+	if (spi_write_without_intr != 0)
+		return;
+
+	if ((onoff != SPI_OFF) && (onoff != SPI_ON) && (onoff != SPI_RESET))
+		return;
+
+	/* auto clock off */
+	mp200_pmu_clkctrl_off(spi->smu->sclk_ctrl);
+	mp200_pmu_clkctrl_off(spi->smu->pclk_ctrl);
+
+	/* clock on */
+	mp200_pmu_open_clockgate(spi->smu->pclk);
+	mp200_pmu_open_clockgate(spi->smu->sclk);
+
+	switch (onoff) {
+	case SPI_OFF:
+		/* reset off */
+		mp200_pmu_unreset_device(spi->smu->reset);
+		break;
+
+	case SPI_ON:
+		/* reset on */
+		/* clock off */
+		mp200_pmu_close_clockgate(spi->smu->sclk);
+		mp200_pmu_close_clockgate(spi->smu->pclk);
+		break;
+
+	case SPI_RESET:
+		/* reset on -> off */
+		mp200_pmu_unreset_device(spi->smu->reset);
+		break;
+
+	default:
+		break;
+	}
+
+	/* auto clock on */
+	mp200_pmu_clkctrl_on(spi->smu->pclk_ctrl);
+	mp200_pmu_clkctrl_on(spi->smu->sclk_ctrl);
+}
+
+static unsigned int spi_unit(spi_data_t *spi, unsigned int bit)
+{
+	if (bit == 0)
+		return 0;
+	else if (bit <= SPI_NB_8BIT)
+		return 1;
+	else if (bit <= SPI_NB_16BIT)
+		return 2;
+	else if ((bit <= SPI_NB_24BIT) && (spi->mode->dma == SPI_DMA_OFF))
+		return 3;
+	else
+		return 4;
+}
+
+static int spi_set_sclk_div(spi_data_t *spi, unsigned int sclk)
+{
+	switch (sclk) {
+	case SPI_SCLK_1500KHZ:
+	case SPI_SCLK_3MHZ:
+	case SPI_SCLK_6MHZ:
+	case SPI_SCLK_12MHZ:
+	case SPI_SCLK_24MHZ:
+	case SPI_SCLK_48MHZ:
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	outl(spi_plldiv_table[sclk], spi->smu->div_sclk);
+
+	return 0;
+}
+
+/*
+ * initialize data
+ */
+static void spi_init_data(spi_data_t *spi)
+{
+	spi->trans->buf.dma_ptr = 0;
+	spi->trans->buf.usr_ptr = 0;
+	spi->trans->buf.state = SPI_BUFF_EMPTY;
+	spi->trans->spi_err = 0;
+	spi->trans->dma_err = 0;
+}
+
+/*
+ * allocate DMA buffer
+ */
+static int spi_allocate_buffer(spi_data_t *spi, unsigned int blksize)
+{
+	dma_addr_t phys;
+	unsigned int blknum;
+	void *virt;
+
+	if (spi->trans->buf.dma_addr == 0) {
+		blknum = SPI_BUFSIZE_MAX / blksize;
+		if (blknum > SPI_BLKNUM_MAX)
+			blknum = SPI_BLKNUM_MAX;
+
+		virt = dma_alloc_coherent(NULL, (blksize * blknum), &phys, 0);
+		if (virt == NULL) {
+			printk(KERN_INFO "%s: memory allocation error\n",
+			       SPI_NAME);
+			return -ENOMEM;
+		}
+		spi->trans->buf.blknum = blknum;
+		spi->trans->buf.dma_addr = phys;
+		spi->trans->buf.top = (unsigned long)virt;
+		spi->trans->buf.end = (unsigned long)virt + (blksize * blknum);
+		spi_init_data(spi);
+	}
+
+	return 0;
+}
+
+/*
+ * free DMA buffer
+ */
+static void spi_free_buffer(spi_data_t *spi)
+{
+	if (spi->trans->buf.dma_addr != 0) {
+		dma_free_coherent(NULL,
+				  (spi->mode->blksize * spi->trans->buf.blknum),
+				  (void *)(spi->trans->buf.top),
+				  spi->trans->buf.dma_addr);
+		spi->trans->buf.blknum = 0;
+		spi->trans->buf.dma_addr = 0;
+		spi->trans->buf.top = 0;
+		spi->trans->buf.end = 0;
+		spi_init_data(spi);
+	}
+}
+
+/*
+ * request DMA interrupt
+ */
+static int spi_request_dma(spi_data_t *spi)
+{
+	int ret = 0;
+
+	if (spi->trans->dma_regs == NULL) {
+		if (spi->opened & FMODE_READ) {
+			ret =
+				mp200_request_dma(spi->trans->rx_lch,
+						  SPI_NAME,
+						  spi_interrupt_dma_rx,
+						  (void *)spi,
+						  &spi->trans->dma_regs);
+		} else {
+			ret =
+				mp200_request_dma(spi->trans->tx_lch,
+						  SPI_NAME,
+						  spi_interrupt_dma_tx,
+						  (void *)spi,
+						  &spi->trans->dma_regs);
+		}
+	}
+#ifdef SPI_DEBUG
+	if (ret < 0)
+		printk(KERN_INFO "%s(): error\n", __func__);
+#endif
+
+	return ret;
+}
+
+/*
+ * free DMA interrupt
+ */
+static void spi_free_dma(spi_data_t *spi)
+{
+	if (spi->trans->dma_regs != NULL) {
+		if (spi->opened & FMODE_READ)
+			mp200_free_dma(spi->trans->rx_lch);
+		else
+			mp200_free_dma(spi->trans->tx_lch);
+		spi->trans->dma_regs = NULL;
+	}
+}
+
+/*
+ * copy from user
+ */
+static int spi_copy_from_user(char *dst, const char *src, unsigned int size)
+{
+	int ret = 0;
+
+	ret = copy_from_user(dst, src, size);
+	if (ret < 0) {
+#ifdef SPI_DEBUG
+		printk(KERN_INFO "%s(): copy error\n", __func__);
+#endif
+		return -EFAULT;
+	}
+
+	return 0;
+}
+
+/*
+ * copy to user
+ */
+static int spi_copy_to_user(char *dst, char *src, unsigned int size)
+{
+	int ret = 0;
+
+	ret = copy_to_user(dst, src, size);
+	if (ret < 0) {
+#ifdef SPI_DEBUG
+		printk(KERN_INFO "%s(): copy error\n", __func__);
+#endif
+		return -EFAULT;
+	}
+
+	return 0;
+}
+
+/*
+ * set mode
+ */
+static int spi_set_mode(spi_data_t *spi, spi_mode_t *mode)
+{
+	unsigned int mode_val = 0;
+	unsigned int control2 = 0;
+
+	int ret = 0;
+
+	/* bit length */
+	if ((SPI_NB_8BIT <= mode->nb) && (mode->nb <= SPI_NB_32BIT))
+		mode_val |= ((mode->nb - 1) << 8);
+	else
+		return -EINVAL;
+
+	if (mode->dma == SPI_DMA_ON) {
+		switch (mode->nb) {
+		case SPI_NB_8BIT:
+		case SPI_NB_16BIT:
+		case SPI_NB_32BIT:
+			break;
+		default:
+			return -EINVAL;
+		}
+	}
+
+	/* chip select */
+	switch (mode->cs_sel) {
+	case SPI_CS_SEL_CS0:
+	case SPI_CS_SEL_CS1:
+	case SPI_CS_SEL_CS2:
+	case SPI_CS_SEL_CS3:
+	case SPI_CS_SEL_CS4:
+	case SPI_CS_SEL_CS5:
+		mode_val |= (mode->cs_sel << 4);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	mode_val |= (mode->m_s << 1);
+
+	/* dma on/off */
+	switch (mode->dma) {
+	case SPI_DMA_OFF:
+		if ((spi->opened & FMODE_READ)
+		    || ((spi->opened & FMODE_WRITE)
+			&& (mode->m_s == SPI_M_S_SLAVE))) {
+			mode->dma = SPI_DMA_ON;
+		}
+	/* through */
+	case SPI_DMA_ON:
+		mode_val |= (mode->dma << 0);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	if ((mode->dma == SPI_DMA_ON) && (mode->m_s == SPI_M_S_MASTER))
+		control2 = SPx_CONTROL2_TX_STOP_MODE;
+
+	/* block size */
+	if ((mode->blksize == 0) || (mode->blksize > SPI_BLKSIZE_MAX) ||
+	    ((mode->blksize % 4) != 0)) {
+		return -EINVAL;
+	}
+
+	/* sclk */
+	switch (mode->sclk) {
+	case SPI_SCLK_1500KHZ:
+	case SPI_SCLK_3MHZ:
+	case SPI_SCLK_6MHZ:
+	case SPI_SCLK_12MHZ:
+	case SPI_SCLK_24MHZ:
+	case SPI_SCLK_48MHZ:
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	/* set sclk */
+	if (spi_set_sclk_div(spi, mode->sclk) < 0)
+		return -EINVAL;
+
+	/* set SPx_MODE */
+	spi->regs->mode = mode_val;
+
+	/* set SPx_POL */
+	spi->regs->pol = spi->pol;
+
+	/* set SPx_CONTROL2 */
+	spi->regs->control2 = control2;
+
+	/* software reset */
+	spi_sft_reset(spi);
+
+	if (mode->blksize != spi->mode->blksize)
+		spi_free_buffer(spi);
+	ret = spi_allocate_buffer(spi, mode->blksize);
+	if (ret < 0)
+		return ret;
+
+	if (mode->dma == SPI_DMA_ON)
+		ret = spi_request_dma(spi);
+	else
+		spi_free_dma(spi);
+
+	return ret;
+}
+
+/*
+ * SPI stop
+ */
+static void spi_stop(spi_data_t *spi)
+{
+	if (spi->trans->state == SPI_STOP)
+		return;
+
+	if (spi->mode->dma == SPI_DMA_ON) {
+		if (spi->mode->m_s == SPI_M_S_MASTER) {
+			if (spi->regs->control & SPx_CONTROL_START) {
+				spi->regs->control |= SPx_CONTROL_STOP;
+				udelay(((1000 * 32) /
+					spi_clock_table[spi->mode->sclk]) + 1);
+			}
+		}
+	}
+
+	/* interrupt disable */
+	spi->regs->enclr = SPx_ENCLR_ALL_MASK;
+
+	/* status to stop */
+	spi->trans->state = SPI_STOP;
+}
+
+/*
+ * RX stop
+ */
+static void spi_rx_stop(spi_data_t *spi)
+{
+	if (spi->mode->dma == SPI_DMA_ON) {
+		/* SPI stop */
+		spi_stop(spi);
+		/* DMA stop */
+		mp200_stop_dma(spi->trans->rx_lch);
+
+		if (spi->mode->m_s == SPI_M_S_MASTER) {
+			spi->regs->control2 &=  ~(SPx_CONTROL2_RX_STOP_MODE
+					  | SPx_CONTROL2_RX_FIFO_FULL_MASK);
+		}
+	} else {
+		/* SPI stop */
+		spi_stop(spi);
+	}
+}
+
+/*
+ * TX stop
+ */
+static void spi_tx_stop(spi_data_t *spi)
+{
+	if (spi->mode->dma == SPI_DMA_ON) {
+		/* SPI stop */
+		spi_stop(spi);
+
+		/* DMA stop */
+		mp200_stop_dma(spi->trans->tx_lch);
+
+		if (spi->mode->m_s == SPI_M_S_MASTER)
+			spi->regs->control2 &= ~SPx_CONTROL2_TX_STOP_MODE;
+	} else {
+		/* SPI stop */
+		spi_stop(spi);
+	}
+}
+
+/*
+ * RX start
+ */
+static int spi_rx_start(spi_data_t *spi, int size)
+{
+	int intmask = 0;
+	int ret = 0;
+
+	/* status to active */
+	spi->trans->state = SPI_ACTIVE;
+
+	/* initialize error status */
+	spi->regs->ffclr = SPx_FFCLR_ALL_CLR;
+
+	/* interrupt enable (TERR/TX_UDR/RX_OVR) */
+	spi->regs->enset |= SPx_ENSET_ALLERR_EN;
+
+	if (spi->mode->dma == SPI_DMA_ON) {
+		unsigned int mode = 0;
+		switch (spi->mode->nb) {
+		case SPI_NB_8BIT:
+			mode = MP200_DMAC_DEFMODE_8BIT;
+			break;
+		case SPI_NB_16BIT:
+			mode = MP200_DMAC_DEFMODE_16BIT;
+			break;
+		case SPI_NB_32BIT:
+			mode = MP200_DMAC_DEFMODE_32BIT;
+			break;
+		default:
+			return -EINVAL;
+		}
+
+		if (spi->mode->m_s == SPI_M_S_MASTER) {
+			/* DMA start (length) */
+			spi->trans->dma_regs->mode = mode;
+			spi->trans->dma_regs->boff = 0;
+			spi->trans->dma_regs->leng = size;
+			spi->trans->dma_regs->bsize =
+				(size > SPI_DMA_BLOCK_SIZE_MAX) ?
+					SPI_DMA_BLOCK_SIZE_MAX : size;
+			spi->trans->dma_regs->bsize_count = 0;
+			intmask = MP200_DMAC_INT_ERROR_EN |
+					MP200_DMAC_INT_LENG_EN;
+		} else {
+			/* DMA start (infinity length) */
+			spi->trans->dma_regs->mode =
+				MP200_DMAC_BMODE_REPEAT | mode;
+			spi->trans->dma_regs->boff = 0;
+			spi->trans->dma_regs->leng = 0;
+			spi->trans->dma_regs->bsize = spi->mode->blksize;
+			spi->trans->dma_regs->bsize_count =
+				spi->trans->buf.blknum - 1;
+			intmask = MP200_DMAC_INT_ERROR_EN |
+					MP200_DMAC_INT_BLOCK_EN;
+		}
+		ret = mp200_start_dma(spi->trans->rx_lch, spi->trans->rx_data,
+				0, spi->trans->buf.dma_addr, intmask);
+		if (ret < 0) {
+			spi_rx_stop(spi);
+#ifdef SPI_DEBUG
+			printk(KERN_INFO "%s(): dma error\n", __func__);
+#endif
+			return ret;
+		}
+
+		if (spi->mode->m_s == SPI_M_S_MASTER) {
+			unsigned int full =
+				((size / spi_unit(spi, spi->mode->nb)) - 1);
+			if (full < 0x10000) {
+				spi->regs->control2 &=
+					~SPx_CONTROL2_RX_FIFO_FULL_MASK;
+
+				spi->regs->control2 |=
+					(((full & 0xff00) << 8) | (full & 0xff)
+					 | SPx_CONTROL2_RX_STOP_MODE);
+			}
+		}
+	}
+
+	/* RX start */
+	spi->regs->control |= (SPx_CONTROL_RD | SPx_CONTROL_START);
+
+	return 0;
+}
+
+/*
+ * TX start
+ */
+static int spi_tx_start(spi_data_t *spi)
+{
+	unsigned int addr = 0;
+	unsigned int bufsize = 0;
+	int intmask = 0;
+	int size = 0;
+	int ret = 0;
+
+	/* buffer is empty */
+	if (spi->trans->buf.state & SPI_BUFF_EMPTY)
+		return 0;
+
+	/* status to active */
+	spi->trans->state = SPI_ACTIVE;
+
+	bufsize = spi->mode->blksize * spi->trans->buf.blknum;
+	size = spi->trans->buf.usr_ptr - spi->trans->buf.dma_ptr;
+	if (size <= 0)
+		size = bufsize - spi->trans->buf.dma_ptr;
+
+	/* initialize error status */
+	spi->regs->ffclr = SPx_FFCLR_ALL_CLR;
+
+	/* interrupt enable (TERR/TX_UDR/RX_OVR) */
+	spi->regs->enset |= SPx_ENSET_ALLERR_EN;
+
+	if (spi->mode->dma == SPI_DMA_ON) {
+		unsigned int mode = 0;
+		switch (spi->mode->nb) {
+		case SPI_NB_8BIT:
+			mode = MP200_DMAC_DEFMODE_8BIT;
+			break;
+		case SPI_NB_16BIT:
+			mode = MP200_DMAC_DEFMODE_16BIT;
+			break;
+		case SPI_NB_32BIT:
+			mode = MP200_DMAC_DEFMODE_32BIT;
+			break;
+		default:
+			return -EINVAL;
+		}
+		spi->trans->dma_regs->mode = mode;
+		spi->trans->dma_regs->aoff = 0;
+		spi->trans->dma_regs->leng = size;
+		spi->trans->dma_regs->asize =
+			(size > SPI_DMA_BLOCK_SIZE_MAX) ?
+			SPI_DMA_BLOCK_SIZE_MAX : size;
+		spi->trans->dma_regs->asize_count = 0;
+		intmask = MP200_DMAC_INT_ERROR_EN | MP200_DMAC_INT_LENG_EN;
+
+		if (spi->mode->m_s == SPI_M_S_MASTER) {
+			/* interrupt enable (TX_STOP) */
+			spi->regs->enset |= SPx_ENSET_TX_STOP_EN;
+		}
+		ret =
+			mp200_start_dma(spi->trans->tx_lch,
+					spi->trans->buf.dma_addr +
+					spi->trans->buf.dma_ptr, 0,
+					spi->trans->tx_data, intmask);
+		if (ret < 0) {
+			spi_tx_stop(spi);
+#ifdef SPI_DEBUG
+			printk(KERN_INFO "%s(): dma error\n", __func__);
+#endif
+			return ret;
+		}
+	} else {
+		/* interrupt enable (END) */
+		spi->regs->enset |= SPx_ENSET_END_EN;
+
+		/* set data */
+		addr = spi->trans->buf.top + spi->trans->buf.dma_ptr;
+		spi->regs->tx_data = *(unsigned int *)addr;
+	}
+
+	/* TX start */
+	spi->regs->control |= (SPx_CONTROL_WRT | SPx_CONTROL_START);
+
+	return 0;
+}
+
+/*
+ * SPI interrupt callback
+ */
+static irqreturn_t spi_interrupt(int irq, void *dev_id)
+{
+	spi_data_t *spi;
+	unsigned int status = 0;
+	unsigned int bufsize = 0;
+	int ret = 0;
+
+	if (dev_id == NULL)
+		return IRQ_NONE;
+	spi = (spi_data_t *) dev_id;
+
+	/* interrupt status */
+	status = spi->regs->status;
+
+	/* initialize interrupt status */
+	spi->regs->ffclr |= status;
+
+	/* error check (TERR/TX_UDR/RX_OVR) */
+	if (status & SPx_STATUS_ALLERR) {
+		spi->trans->spi_err = (status & SPx_STATUS_ALLERR);
+		if (status & SPx_STATUS_TX_UDR) {
+			if (spi->mode->m_s == SPI_M_S_MASTER) {
+				spi_tx_stop(spi);
+			} else {
+				if (spi->trans->dma_regs->wcount == 0) {
+					spi->trans->spi_err &=
+						~(SPx_STATUS_TX_UDR);
+					if (spi->trans->buf.state
+					    & SPI_BUFF_EMPTY) {
+						spi_tx_stop(spi);
+					} else {
+						ret = spi_tx_start(spi);
+						if (ret < 0)
+							spi_tx_stop(spi);
+					}
+				} else {
+					spi_tx_stop(spi);
+				}
+			}
+		}
+		if (status & SPx_STATUS_RX_OVR) {
+			if (spi->mode->m_s == SPI_M_S_MASTER) {
+				if (spi->trans->dma_regs->rcount == 0) {
+					spi->trans->spi_err &=
+						~(SPx_STATUS_RX_OVR);
+					spi_stop(spi);
+					return IRQ_HANDLED;
+				} else {
+					spi_rx_stop(spi);
+				}
+			} else {
+				spi_rx_stop(spi);
+			}
+		}
+		if (status & SPx_STATUS_TERR)
+			spi_rx_stop(spi);
+		if (waitqueue_active(&spi->trans->wait))
+			wake_up_interruptible(&spi->trans->wait);
+#ifdef SPI_DEBUG
+		printk(KERN_INFO "%s(): status = %08x\n", __func__, status);
+#endif
+		return IRQ_HANDLED;
+	}
+#ifdef SPI_DEBUG
+	if (status & SPx_STATUS_RDV) {
+		printk(KERN_INFO "%s(): RDV is not supported\n", __func__);
+		return IRQ_NONE;
+	}
+#endif
+
+	if (status & SPx_STATUS_TX_STOP) { /* master only */
+		if (spi->regs->control & SPx_CONTROL_TX_EMP) {
+			if (spi->trans->buf.state & SPI_BUFF_EMPTY) {
+				spi_tx_stop(spi);
+			} else {
+				ret = spi_tx_start(spi);
+				if (ret < 0)
+					spi_tx_stop(spi);
+			}
+		} else { /* error */
+			spi->trans->spi_err = SPx_STATUS_TX_STOP;
+			spi_tx_stop(spi);
+		}
+		if (waitqueue_active(&spi->trans->wait))
+			wake_up_interruptible(&spi->trans->wait);
+#ifdef SPI_DEBUG
+		printk(KERN_INFO "%s(): status = %08x\n", __func__, status);
+#endif
+		return IRQ_HANDLED;
+	}
+
+	/* CPU write */
+	if (status & SPx_STATUS_END) {
+		/* update dma pointer */
+		bufsize = spi->mode->blksize * spi->trans->buf.blknum;
+		spi->trans->buf.dma_ptr = spi->trans->buf.dma_ptr + 4;
+		if (spi->trans->buf.dma_ptr == bufsize)
+			spi->trans->buf.dma_ptr = 0;
+
+		/* update buffer status */
+		if (spi->trans->buf.dma_ptr == spi->trans->buf.usr_ptr)
+			spi->trans->buf.state |= SPI_BUFF_EMPTY;
+		if (spi->trans->buf.state & SPI_BUFF_FULL)
+			spi->trans->buf.state &= ~(SPI_BUFF_FULL);
+
+		if (spi->trans->buf.state & SPI_BUFF_EMPTY) {
+			spi_tx_stop(spi);
+			if (waitqueue_active(&spi->trans->wait))
+				wake_up_interruptible(&spi->trans->wait);
+		} else {
+			ret = spi_tx_start(spi);
+			if (ret < 0) {
+				spi_tx_stop(spi);
+				if (waitqueue_active(&spi->trans->wait)) {
+					wake_up_interruptible(&spi->trans->
+							      wait);
+				}
+				return IRQ_HANDLED;
+			}
+		}
+	}
+
+	return IRQ_HANDLED;
+}
+
+/*
+ * DMA interrupt callback (RX)
+ */
+static void spi_interrupt_dma_rx(void *data, int intsts, int intrawsts)
+{
+	spi_data_t *spi;
+	unsigned int dma_pos = 0;
+	unsigned int bufsize = 0;
+	int size = 0;
+	int blanksize = 0;
+
+	if (data == NULL)
+		return;
+	spi = (spi_data_t *) data;
+
+	/* error check */
+	if (intsts & (MP200_DMAC_INT_ERROR_WR | MP200_DMAC_INT_ERROR_RD)) {
+		spi->trans->dma_err =
+			(intsts &
+			 (MP200_DMAC_INT_ERROR_WR | MP200_DMAC_INT_ERROR_RD));
+		spi_rx_stop(spi);
+		if (waitqueue_active(&spi->trans->wait))
+			wake_up_interruptible(&spi->trans->wait);
+#ifdef SPI_DEBUG
+		printk(KERN_INFO "%s(): intsts = %08x\n", __func__, intsts);
+#endif
+		return;
+	}
+
+	if (((spi->mode->m_s == SPI_M_S_MASTER)
+	     && (intsts & MP200_DMAC_INT_LENG_WR))
+	    || ((spi->mode->m_s == SPI_M_S_SLAVE)
+		&& (intsts & MP200_DMAC_INT_BLOCK_WR))) {
+		bufsize = spi->mode->blksize * spi->trans->buf.blknum;
+		dma_pos = mp200_get_dma_pos(spi->trans->rx_lch);
+		dma_pos = dma_pos - spi->trans->buf.dma_addr;
+		size = dma_pos - spi->trans->buf.dma_ptr;
+		if (size <= 0)
+			size = size + bufsize;
+
+		/* calculate blank size */
+		if (spi->trans->buf.state & SPI_BUFF_FULL) {
+			blanksize = 0;
+		} else {
+			blanksize = spi->trans->buf.usr_ptr -
+					spi->trans->buf.dma_ptr;
+			if (blanksize <= 0)
+				blanksize = blanksize + bufsize;
+		}
+
+		/* update dma counter */
+		spi->trans->buf.dma_ptr = spi->trans->buf.dma_ptr + size;
+		if (spi->trans->buf.dma_ptr >= bufsize) {
+			spi->trans->buf.dma_ptr =
+				spi->trans->buf.dma_ptr - bufsize;
+		}
+
+		/* update buffer status */
+		if (blanksize < size) {
+			spi->trans->buf.state |=
+				(SPI_BUFF_FULL | SPI_BUFF_OVER_ERR);
+			spi_rx_stop(spi);
+#ifdef SPI_DEBUG
+			printk(KERN_INFO "%s(): buffer overwrited\n",
+			       __func__);
+#endif
+		} else {
+			if (spi->trans->buf.dma_ptr == spi->trans->buf.usr_ptr)
+				spi->trans->buf.state |= SPI_BUFF_FULL;
+			if (spi->trans->buf.state & SPI_BUFF_EMPTY)
+				spi->trans->buf.state &= ~(SPI_BUFF_EMPTY);
+		}
+
+		if (spi->mode->m_s == SPI_M_S_MASTER)
+			spi_rx_stop(spi);
+
+		if (waitqueue_active(&spi->trans->wait))
+			wake_up_interruptible(&spi->trans->wait);
+	}
+}
+
+/*
+ * DMA interrupt callback (TX)
+ */
+static void spi_interrupt_dma_tx(void *data, int intsts, int intrawsts)
+{
+	spi_data_t *spi;
+	if (data == NULL)
+		return;
+	spi = (spi_data_t *) data;
+
+	/* error check */
+	if (intsts & (MP200_DMAC_INT_ERROR_WR | MP200_DMAC_INT_ERROR_RD)) {
+		spi->trans->dma_err =
+			(intsts &
+			 (MP200_DMAC_INT_ERROR_WR | MP200_DMAC_INT_ERROR_RD));
+		spi_tx_stop(spi);
+		if (waitqueue_active(&spi->trans->wait))
+			wake_up_interruptible(&spi->trans->wait);
+#ifdef SPI_DEBUG
+		printk(KERN_INFO "%s(): intsts = %08x\n", __func__, intsts);
+#endif
+		return;
+	}
+
+	if (intsts & MP200_DMAC_INT_LENG_WR) {
+		spi->trans->buf.dma_ptr =
+			mp200_get_dma_pos(spi->trans->tx_lch)
+			- spi->trans->buf.dma_addr;
+		if (spi->trans->buf.dma_ptr ==
+		    (spi->mode->blksize * spi->trans->buf.blknum)) {
+			spi->trans->buf.dma_ptr = 0;
+		}
+#ifdef SPI_DEBUG
+		printk(KERN_INFO "%s(): dma ptr = %d\n", __func__,
+		       (spi->trans->buf.dma_ptr));
+#endif
+		/* update buffer status */
+		if (spi->trans->buf.dma_ptr == spi->trans->buf.usr_ptr)
+			spi->trans->buf.state |= SPI_BUFF_EMPTY;
+		if (spi->trans->buf.state & SPI_BUFF_FULL)
+			spi->trans->buf.state &= ~(SPI_BUFF_FULL);
+
+		if (waitqueue_active(&spi->trans->wait))
+			wake_up_interruptible(&spi->trans->wait);
+	}
+}
+
+/*
+ * read
+ */
+static ssize_t spi_read_func(unsigned char dev, struct file *file,
+		char __user *buf, size_t count, loff_t *ppos)
+{
+	DECLARE_WAITQUEUE(wait, current);
+	spi_data_t *spi;
+	unsigned int errsts;
+	unsigned int dma_ptr;
+	unsigned int usr_ptr;
+	unsigned int end;
+	unsigned int cpsize;
+	unsigned int bufsize;
+	unsigned int len = 0;
+	int size = 0;
+	int ret = 0;
+
+#ifdef SPI_DEBUG
+	printk(KERN_INFO "%s(): count = %d\n", __func__, count);
+#endif
+
+	/* device is not found */
+	if (DEVNO_IS_INVALID(dev))
+		return -ENODEV;
+
+	spi = &spi_private[dev];
+
+	/* seek is not supported */
+	if (*ppos != file->f_pos)
+		return -ESPIPE;
+
+	/* size check */
+	if (count == 0)
+		return 0;
+	if (count < 4)
+		return -EINVAL;
+	if ((count % 4) != 0)
+		count = (count / 4) * 4;
+
+	/* RX start */
+	bufsize = spi->mode->blksize * spi->trans->buf.blknum;
+	add_wait_queue(&spi->trans->wait, &wait);
+	while ((count - len) > 0) {
+		set_current_state(TASK_INTERRUPTIBLE);
+
+		spin_lock_irq(&spi->trans->spinlock);
+		errsts = spi->trans->spi_err;
+		spi->trans->spi_err = 0;
+		spin_unlock_irq(&spi->trans->spinlock);
+		if (errsts != 0) {
+			ret = -EIO;
+			break;
+		}
+		/* DMA error check */
+		spin_lock_irq(&spi->trans->spinlock);
+		errsts = spi->trans->dma_err;
+		spi->trans->dma_err = 0;
+		spin_unlock_irq(&spi->trans->spinlock);
+		if (errsts != 0) {
+			ret = -EIO;
+			break;
+		}
+		/* buffer error check */
+		spin_lock_irq(&spi->trans->spinlock);
+		errsts = spi->trans->buf.state & SPI_BUFF_OVER_ERR;
+		spi->trans->buf.state &= ~SPI_BUFF_OVER_ERR;
+		spin_unlock_irq(&spi->trans->spinlock);
+		if (errsts != 0) {
+			ret = -EIO;
+			break;
+		}
+
+		if (!(spi->trans->state == SPI_ACTIVE)
+		    && (spi->trans->buf.state & SPI_BUFF_EMPTY)) {
+			ret = spi_allocate_buffer(spi, spi->mode->blksize);
+			if (ret < 0)
+				return ret;
+			if (spi->mode->dma == SPI_DMA_ON) {
+				ret = spi_request_dma(spi);
+				if (ret < 0)
+					return ret;
+			}
+			spi_init_data(spi);
+
+			if (spi->mode->m_s == SPI_M_S_MASTER) {
+				size =
+					((count - len) > bufsize) ?
+					bufsize : (count - len);
+			} else {
+				size = 0;
+			}
+			ret = spi_rx_start(spi, size);
+			if (ret < 0)
+				return ret;
+		}
+
+		/* readable */
+		if (!(spi->trans->buf.state & SPI_BUFF_EMPTY)) {
+			dma_ptr = spi->trans->buf.top + spi->trans->buf.dma_ptr;
+			usr_ptr = spi->trans->buf.top + spi->trans->buf.usr_ptr;
+			end = spi->trans->buf.end;
+			cpsize = (dma_ptr > usr_ptr) ?
+					(dma_ptr - usr_ptr) : (end - usr_ptr);
+			if (cpsize > (count - len))
+				cpsize = count - len;
+			ret =
+				spi_copy_to_user((char *)(buf + len),
+						 (char *)usr_ptr, cpsize);
+			if (ret < 0)
+				break;
+			len = len + cpsize;
+
+			/* update user pointer */
+
+			spin_lock_irq(&spi->trans->spinlock);
+			spi->trans->buf.usr_ptr =
+				spi->trans->buf.usr_ptr + cpsize;
+			if (spi->trans->buf.usr_ptr == bufsize)
+				spi->trans->buf.usr_ptr = 0;
+
+			/* update buffer status */
+			if (spi->trans->buf.usr_ptr == spi->trans->buf.dma_ptr)
+				spi->trans->buf.state |= SPI_BUFF_EMPTY;
+			if (spi->trans->buf.state & SPI_BUFF_FULL)
+				spi->trans->buf.state &= ~(SPI_BUFF_FULL);
+			spin_unlock_irq(&spi->trans->spinlock);
+			if (spi->mode->m_s == SPI_M_S_MASTER) {
+				size =
+					((count - len) >
+					 bufsize) ? bufsize : (count - len);
+				if (size > 0) {
+					spi_init_data(spi);
+					ret = spi_rx_start(spi, size);
+					if (ret < 0)
+						break;
+				}
+			}
+		} else {
+			if (file->f_flags & O_NONBLOCK) {
+				if (len == 0)
+					ret = -EAGAIN;
+				break;
+			}
+			if (signal_pending(current)) {
+				ret = -ERESTARTSYS;
+				break;
+			}
+			schedule();
+		}
+	}
+	remove_wait_queue(&spi->trans->wait, &wait);
+	set_current_state(TASK_RUNNING);
+
+	if (ret < 0) {
+		if (ret != -EAGAIN) {
+			if (spi->trans->state == SPI_ACTIVE)
+				spi_rx_stop(spi);
+		}
+		return ret;
+	}
+
+	/* return copy size */
+	return len;
+}
+
+int
+mp201_spi_read(unsigned char dev, char *buf, unsigned int count,
+		unsigned char block_mode)
+{
+	DECLARE_WAITQUEUE(wait, current);
+	spi_data_t *spi;
+	unsigned int errsts;
+	unsigned int dma_ptr;
+	unsigned int usr_ptr;
+	unsigned int end;
+	unsigned int cpsize;
+	unsigned int bufsize;
+	unsigned int len = 0;
+	int size = 0;
+	int ret = 0;
+
+#ifdef SPI_DEBUG
+	printk(KERN_INFO "%s(): count = %d\n", __func__, count);
+#endif
+
+	if (DEVNO_IS_INVALID(dev))
+		return -EACCES;
+
+	spi = &spi_private[dev];
+
+	if (spi->k_flag != SPI_READ_MODE)
+		return -EACCES;
+
+	/* size check */
+	if (count == 0)
+		return 0;
+	if (count < 4)
+		return -EINVAL;
+	if ((count % 4) != 0)
+		count = (count / 4) * 4;
+
+	if (down_interruptible(&spi->sem_rw))
+		return -ERESTARTSYS;
+
+	/* RX start */
+	bufsize = spi->mode->blksize * spi->trans->buf.blknum;
+	add_wait_queue(&spi->trans->wait, &wait);
+	while ((count - len) > 0) {
+		set_current_state(TASK_INTERRUPTIBLE);
+
+		spin_lock_irq(&spi->trans->spinlock);
+		errsts = spi->trans->spi_err;
+		spi->trans->spi_err = 0;
+		spin_unlock_irq(&spi->trans->spinlock);
+		if (errsts != 0) {
+			ret = -EIO;
+			break;
+		}
+		/* DMA error check */
+		spin_lock_irq(&spi->trans->spinlock);
+		errsts = spi->trans->dma_err;
+		spi->trans->dma_err = 0;
+		spin_unlock_irq(&spi->trans->spinlock);
+		if (errsts != 0) {
+			ret = -EIO;
+			break;
+		}
+		/* buffer error check */
+		spin_lock_irq(&spi->trans->spinlock);
+		errsts = spi->trans->buf.state & SPI_BUFF_OVER_ERR;
+		spi->trans->buf.state &= ~SPI_BUFF_OVER_ERR;
+		spin_unlock_irq(&spi->trans->spinlock);
+		if (errsts != 0) {
+			ret = -EIO;
+			break;
+		}
+
+		if (!(spi->trans->state == SPI_ACTIVE)
+		    && (spi->trans->buf.state & SPI_BUFF_EMPTY)) {
+			ret = spi_allocate_buffer(spi, spi->mode->blksize);
+			if (ret < 0) {
+				up(&spi->sem_rw);
+				return ret;
+			}
+			if (spi->mode->dma == SPI_DMA_ON) {
+				ret = spi_request_dma(spi);
+				if (ret < 0) {
+					up(&spi->sem_rw);
+					return ret;
+				}
+			}
+			spi_init_data(spi);
+
+			if (spi->mode->m_s == SPI_M_S_MASTER) {
+				size =
+					((count - len) > bufsize) ?
+					bufsize : (count - len);
+			} else {
+				size = 0;
+			}
+			ret = spi_rx_start(spi, size);
+			if (ret < 0) {
+				up(&spi->sem_rw);
+				return ret;
+			}
+		}
+
+		/* readable */
+		if (!(spi->trans->buf.state & SPI_BUFF_EMPTY)) {
+			dma_ptr = spi->trans->buf.top + spi->trans->buf.dma_ptr;
+			usr_ptr = spi->trans->buf.top + spi->trans->buf.usr_ptr;
+			end = spi->trans->buf.end;
+			cpsize = (dma_ptr > usr_ptr) ?
+					(dma_ptr - usr_ptr) : (end - usr_ptr);
+			if (cpsize > (count - len))
+				cpsize = count - len;
+			memcpy((char *)(buf + len),
+			       (char *)usr_ptr, cpsize);
+
+			len = len + cpsize;
+
+			/* update user pointer */
+			spin_lock_irq(&spi->trans->spinlock);
+
+			spi->trans->buf.usr_ptr =
+				spi->trans->buf.usr_ptr + cpsize;
+			if (spi->trans->buf.usr_ptr == bufsize)
+				spi->trans->buf.usr_ptr = 0;
+
+			/* update buffer status */
+			if (spi->trans->buf.usr_ptr == spi->trans->buf.dma_ptr)
+				spi->trans->buf.state |= SPI_BUFF_EMPTY;
+			if (spi->trans->buf.state & SPI_BUFF_FULL)
+				spi->trans->buf.state &= ~(SPI_BUFF_FULL);
+			spin_unlock_irq(&spi->trans->spinlock);
+			if (spi->mode->m_s == SPI_M_S_MASTER) {
+				size =
+					((count - len) >
+					 bufsize) ? bufsize : (count - len);
+				if (size > 0) {
+					spi_init_data(spi);
+					ret = spi_rx_start(spi, size);
+					if (ret < 0)
+						break;
+				}
+			}
+		} else {
+			if (block_mode & SPI_NONBLOCK) {
+				if (len == 0)
+					ret = -EAGAIN;
+				break;
+			}
+			if (signal_pending(current)) {
+				ret = -ERESTARTSYS;
+				break;
+			}
+			schedule();
+		}
+	}
+	remove_wait_queue(&spi->trans->wait, &wait);
+	set_current_state(TASK_RUNNING);
+
+	if (ret < 0) {
+		if (ret != -EAGAIN) {
+			if (spi->trans->state == SPI_ACTIVE)
+				spi_rx_stop(spi);
+		}
+		up(&spi->sem_rw);
+		return ret;
+	}
+
+	/* return copy size */
+	up(&spi->sem_rw);
+	return len;
+}
+EXPORT_SYMBOL(mp201_spi_read);
+
+
+/*
+ * write
+ */
+static ssize_t spi_write_func(unsigned char dev, struct file *file,
+		const char __user *buf, size_t count, loff_t *ppos)
+{
+	DECLARE_WAITQUEUE(wait, current);
+	spi_data_t *spi;
+	unsigned int errsts;
+	unsigned int dma_ptr;
+	unsigned int usr_ptr;
+	unsigned int end;
+	unsigned int cpsize;
+	unsigned int bufsize;
+	unsigned int len = 0;
+	int ret = 0;
+
+#ifdef SPI_DEBUG
+	printk(KERN_INFO "%s(): count = %d\n", __func__, count);
+#endif
+
+	/* device is not found */
+	if (DEVNO_IS_INVALID(dev))
+		return -ENODEV;
+
+	spi = &spi_private[dev];
+
+	/* seek is not supported */
+	if (*ppos != file->f_pos)
+		return -ESPIPE;
+
+	/* size check */
+	if (count == 0)
+		return 0;
+	if (count < 4)
+		return -EINVAL;
+	if ((count % 4) != 0)
+		count = (count / 4) * 4;
+
+	add_wait_queue(&spi->trans->wait, &wait);
+	while ((count - len) > 0) {
+		set_current_state(TASK_INTERRUPTIBLE);
+
+		spin_lock_irq(&spi->trans->spinlock);
+		errsts = spi->trans->spi_err;
+		spi->trans->spi_err = 0;
+		spin_unlock_irq(&spi->trans->spinlock);
+		if (errsts != 0) {
+			ret = -EIO;
+			break;
+		}
+		/* DMA error check */
+		spin_lock_irq(&spi->trans->spinlock);
+		errsts = spi->trans->dma_err;
+		spi->trans->dma_err = 0;
+		spin_unlock_irq(&spi->trans->spinlock);
+		if (errsts != 0) {
+			ret = -EIO;
+			break;
+		}
+
+		if (!(spi->trans->state == SPI_ACTIVE)
+		    && (spi->trans->buf.state & SPI_BUFF_EMPTY)) {
+			ret = spi_allocate_buffer(spi, spi->mode->blksize);
+			if (ret < 0)
+				return ret;
+			if (spi->mode->dma == SPI_DMA_ON) {
+				ret = spi_request_dma(spi);
+				if (ret < 0)
+					return ret;
+			}
+			spi_init_data(spi);
+		}
+
+		/* writable */
+		if (!(spi->trans->buf.state & SPI_BUFF_FULL)) {
+			dma_ptr = spi->trans->buf.top + spi->trans->buf.dma_ptr;
+			usr_ptr = spi->trans->buf.top + spi->trans->buf.usr_ptr;
+			end = spi->trans->buf.end;
+			cpsize = (dma_ptr > usr_ptr) ?
+					(dma_ptr - usr_ptr) : (end - usr_ptr);
+			if (cpsize > (count - len))
+				cpsize = count - len;
+			ret = spi_copy_from_user((char *)usr_ptr,
+					(const char *)(buf + len), cpsize);
+			if (ret < 0)
+				break;
+			len = len + cpsize;
+
+			/* update user pointer */
+			spin_lock_irq(&spi->trans->spinlock);
+			spi->trans->buf.usr_ptr =
+				spi->trans->buf.usr_ptr + cpsize;
+			bufsize = spi->mode->blksize * spi->trans->buf.blknum;
+			if (spi->trans->buf.usr_ptr == bufsize)
+				spi->trans->buf.usr_ptr = 0;
+
+			/* update buffer status */
+			if (spi->trans->buf.usr_ptr == spi->trans->buf.dma_ptr)
+				spi->trans->buf.state |= SPI_BUFF_FULL;
+			if (spi->trans->buf.state & SPI_BUFF_EMPTY)
+				spi->trans->buf.state &= ~(SPI_BUFF_EMPTY);
+			spin_unlock_irq(&spi->trans->spinlock);
+
+			/* TX start */
+			if (!(spi->trans->state == SPI_ACTIVE)) {
+				ret = spi_tx_start(spi);
+				if (ret < 0)
+					break;
+			}
+		} else {
+			if (file->f_flags & O_NONBLOCK) {
+				if (len == 0)
+					ret = -EAGAIN;
+				break;
+			}
+			if (signal_pending(current)) {
+				ret = -ERESTARTSYS;
+				break;
+			}
+			schedule();
+		}
+	}
+	remove_wait_queue(&spi->trans->wait, &wait);
+	set_current_state(TASK_RUNNING);
+
+	if (ret < 0) {
+		if (ret != -EAGAIN) {
+			if (spi->trans->state == SPI_ACTIVE)
+				spi_tx_stop(spi);
+		}
+		return ret;
+	}
+
+	/* return copy size */
+	return len;
+}
+
+int
+mp201_spi_write(unsigned char dev, const char *buf,  unsigned int count,
+		unsigned char block_mode)
+{
+	DECLARE_WAITQUEUE(wait, current);
+	spi_data_t *spi;
+	unsigned int errsts;
+	unsigned int dma_ptr;
+	unsigned int usr_ptr;
+	unsigned int end;
+	unsigned int cpsize;
+	unsigned int bufsize;
+	unsigned int len = 0;
+	int ret = 0;
+
+#ifdef SPI_DEBUG
+	printk(KERN_INFO "%s(): count = %d\n", __func__, count);
+#endif
+
+	/* device is not found */
+	if (DEVNO_IS_INVALID(dev))
+		return -EACCES;
+
+	spi = &spi_private[dev];
+
+	if (spi->k_flag != SPI_WRITE_MODE)
+		return -EACCES;
+
+	/* size check */
+	if (count == 0)
+		return 0;
+	if (count < 4)
+		return -EINVAL;
+	if ((count % 4) != 0)
+		count = (count / 4) * 4;
+
+	if (down_interruptible(&spi->sem_rw))
+		return -ERESTARTSYS;
+	add_wait_queue(&spi->trans->wait, &wait);
+	while ((count - len) > 0) {
+		set_current_state(TASK_INTERRUPTIBLE);
+
+		spin_lock_irq(&spi->trans->spinlock);
+		errsts = spi->trans->spi_err;
+		spi->trans->spi_err = 0;
+		spin_unlock_irq(&spi->trans->spinlock);
+		if (errsts != 0) {
+			ret = -EIO;
+			break;
+		}
+		/* DMA error check */
+		spin_lock_irq(&spi->trans->spinlock);
+		errsts = spi->trans->dma_err;
+		spi->trans->dma_err = 0;
+		spin_unlock_irq(&spi->trans->spinlock);
+		if (errsts != 0) {
+			ret = -EIO;
+			break;
+		}
+
+		if (!(spi->trans->state == SPI_ACTIVE)
+		    && (spi->trans->buf.state & SPI_BUFF_EMPTY)) {
+			ret = spi_allocate_buffer(spi, spi->mode->blksize);
+			if (ret < 0) {
+				up(&spi->sem_rw);
+				return ret;
+			}
+			if (spi->mode->dma == SPI_DMA_ON) {
+				ret = spi_request_dma(spi);
+				if (ret < 0) {
+					up(&spi->sem_rw);
+					return ret;
+				}
+			}
+			spi_init_data(spi);
+		}
+
+		/* writable */
+		if (!(spi->trans->buf.state & SPI_BUFF_FULL)) {
+			dma_ptr = spi->trans->buf.top + spi->trans->buf.dma_ptr;
+			usr_ptr = spi->trans->buf.top + spi->trans->buf.usr_ptr;
+			end = spi->trans->buf.end;
+			cpsize = (dma_ptr > usr_ptr) ?
+					(dma_ptr - usr_ptr) : (end - usr_ptr);
+			if (cpsize > (count - len))
+				cpsize = count - len;
+			memcpy((char *)usr_ptr,
+			       (char *)(buf + len), cpsize);
+
+			len = len + cpsize;
+
+			/* update user pointer */
+			spin_lock_irq(&spi->trans->spinlock);
+			spi->trans->buf.usr_ptr =
+				spi->trans->buf.usr_ptr + cpsize;
+			bufsize = spi->mode->blksize * spi->trans->buf.blknum;
+			if (spi->trans->buf.usr_ptr == bufsize)
+				spi->trans->buf.usr_ptr = 0;
+
+			/* update buffer status */
+			if (spi->trans->buf.usr_ptr == spi->trans->buf.dma_ptr)
+				spi->trans->buf.state |= SPI_BUFF_FULL;
+			if (spi->trans->buf.state & SPI_BUFF_EMPTY)
+				spi->trans->buf.state &= ~(SPI_BUFF_EMPTY);
+			spin_unlock_irq(&spi->trans->spinlock);
+
+			/* TX start */
+			if (!(spi->trans->state == SPI_ACTIVE)) {
+				ret = spi_tx_start(spi);
+				if (ret < 0)
+					break;
+			}
+		} else {
+			if (block_mode & SPI_NONBLOCK) {
+				if (len == 0)
+					ret = -EAGAIN;
+				break;
+			}
+			if (signal_pending(current)) {
+				ret = -ERESTARTSYS;
+				break;
+			}
+			schedule();
+		}
+	}
+	remove_wait_queue(&spi->trans->wait, &wait);
+	set_current_state(TASK_RUNNING);
+
+	if (ret < 0) {
+		if (ret != -EAGAIN) {
+			if (spi->trans->state == SPI_ACTIVE)
+				spi_tx_stop(spi);
+		}
+		up(&spi->sem_rw);
+		return ret;
+	}
+	up(&spi->sem_rw);
+	/* return copy size */
+	return len;
+}
+EXPORT_SYMBOL(mp201_spi_write);
+
+/*
+ * poll
+ */
+static unsigned int spi_poll(unsigned char dev, struct file *file,
+			     poll_table *wait)
+{
+	spi_data_t *spi;
+	unsigned int mask = 0;
+
+	/* device is not found */
+	if (DEVNO_IS_INVALID(dev)) {
+		/* error */
+		return POLLERR;
+	}
+
+	spi = &spi_private[dev];
+
+	poll_wait(file, &spi->trans->wait, wait);
+
+	/* readable */
+	if (spi->opened & FMODE_READ) {
+		if (!(spi->trans->buf.state & SPI_BUFF_EMPTY))
+			mask |= (POLLIN | POLLRDNORM);
+	}
+
+	/* writable */
+	if (spi->opened & FMODE_WRITE) {
+		if (!(spi->trans->buf.state & SPI_BUFF_FULL))
+			mask |= (POLLOUT | POLLWRNORM);
+	}
+
+	/* error check */
+	if ((spi->trans->spi_err != 0) || (spi->trans->dma_err != 0) ||
+	    (spi->trans->buf.state & SPI_BUFF_OVER_ERR)) {
+		mask |= POLLERR;
+	}
+#ifdef SPI_DEBUG
+	printk(KERN_INFO "%s(): mask = %s%s\n", __func__,
+	       (mask & POLLIN) ? "r" : "", (mask & POLLOUT) ? "w" : "");
+#endif
+
+	return mask;
+}
+
+/*
+ * ioctl
+ */
+static int spi_ioctl(unsigned char dev, struct inode *inode, struct file *file,
+		     unsigned int cmd, unsigned long arg)
+{
+	spi_data_t *spi;
+	spi_mode_t mode;
+	int ret = 0;
+
+	/* device is not found */
+	if (DEVNO_IS_INVALID(dev))
+		return -ENODEV;
+
+	spi = &spi_private[dev];
+
+	if (_IOC_DIR(cmd) == _IOC_WRITE) {
+		if (spi->trans->state == SPI_ACTIVE)
+			return -EBUSY;
+	}
+
+	switch (cmd) {
+	case SPI_CMD_RX_START:
+		if ((file->f_mode & FMODE_READ)
+		    && (spi->mode->m_s == SPI_M_S_SLAVE)) {
+			if (!(spi->trans->state == SPI_ACTIVE)) {
+				ret =
+					spi_allocate_buffer(spi,
+							    spi->mode->blksize);
+				if (ret < 0)
+					break;
+				if (spi->mode->dma == SPI_DMA_ON) {
+					ret = spi_request_dma(spi);
+					if (ret < 0)
+						return ret;
+				}
+				spi_init_data(spi);
+				ret = spi_rx_start(spi, 0);
+			}
+		}
+		break;
+
+	case SPI_CMD_RX_STOP:
+		if ((file->f_mode & FMODE_READ)
+		    && (spi->mode->m_s == SPI_M_S_SLAVE)) {
+			if (spi->trans->state == SPI_ACTIVE)
+				spi_rx_stop(spi);
+		}
+		break;
+
+	case SPI_CMD_GET_MODE:
+		if (copy_to_user((char *)arg, (char *)spi->mode,
+					sizeof(spi_mode_t))) {
+#ifdef SPI_DEBUG
+			printk(KERN_INFO "%s(): copy error\n", __func__);
+#endif
+			ret = -EFAULT;
+		}
+		break;
+
+	case SPI_CMD_SET_MODE:
+		if (copy_from_user((char *)&mode, (char *)arg,
+					sizeof(spi_mode_t))) {
+#ifdef SPI_DEBUG
+			printk(KERN_INFO "%s(): copy error\n", __func__);
+#endif
+			ret = -EFAULT;
+			break;
+		}
+
+		ret = spi_set_mode(spi, &mode);
+		if (ret < 0)
+			break;
+		memcpy((char *)spi->mode, (char *)&mode, sizeof(spi_mode_t));
+		break;
+
+	default:
+		/* error */
+		ret = -EINVAL;
+		break;
+	}
+
+	return ret;
+}
+
+/*
+ * open
+ */
+static int spi_open(unsigned char dev, struct inode *inode, struct file *file)
+{
+	spi_data_t *spi;
+	int ret;
+
+	/* device is not found */
+	if (DEVNO_IS_INVALID(dev))
+		return -ENODEV;
+
+	spi = &spi_private[dev];
+
+	if (down_interruptible(&spi->sem_open))
+		return -ERESTARTSYS;
+
+	/* device is busy */
+	if (spi->opened != 0) {
+#ifdef SPI_DEBUG
+		printk(KERN_INFO "%s(): device is busy\n", __func__);
+#endif
+		ret = -EBUSY;
+		goto err;
+	}
+
+	/* R/W mode is not supported */
+	if ((file->f_mode & FMODE_READ) && (file->f_mode & FMODE_WRITE)) {
+		ret = -EACCES;
+		goto err;
+	}
+
+	spi->opened = file->f_mode;
+
+	memset(&spi->trans->buf, 0x00, sizeof(spi_buf_t));
+	spi->trans->dma_regs = NULL;
+
+	/* initialize data */
+	spi_init_data(spi);
+
+	/* sleep disable */
+	spi_sleep_flag++;
+
+	/* reset off */
+	spi_reset_ctrl(spi, SPI_OFF);
+
+	/* request SPI interrupt */
+	ret =
+		request_irq(spi->trans->int_spi, spi_interrupt, IRQF_DISABLED,
+			    SPI_NAME, (void *)spi);
+	if (ret < 0) {
+#ifdef SPI_DEBUG
+		printk(KERN_INFO "%s(): request irq error\n", __func__);
+#endif
+		goto err1;
+	}
+
+	/* set mode */
+	ret = spi_set_mode(spi, spi->mode);
+	if (ret < 0)
+		goto err2;
+
+	init_waitqueue_head(&spi->trans->wait);
+
+	up(&spi->sem_open);
+
+	return 0;
+
+err2:
+	spi_free_buffer(spi);
+	free_irq(spi->trans->int_spi, (void *)spi);
+err1:
+	spi_reset_ctrl(spi, SPI_ON);
+	spi_sleep_flag--;
+	spi->opened = 0;
+err:
+	up(&spi->sem_open);
+
+	return ret;
+}
+
+/*
+ * same open
+ */
+int
+mp201_spi_init(unsigned char dev, unsigned char rw_mode)
+{
+	spi_data_t *spi;
+	int ret;
+
+	/* device is not found */
+	if (DEVNO_IS_INVALID(dev))
+		return -EACCES;
+	/* R/W mode is not supported */
+	if (rw_mode != SPI_READ_MODE && rw_mode != SPI_WRITE_MODE)
+		return -EACCES;
+
+	spi = &spi_private[dev];
+
+	if (down_interruptible(&spi->sem_open))
+		return -ERESTARTSYS;
+
+	/* device is busy */
+	if (spi->opened != 0) {
+#ifdef SPI_DEBUG
+		printk(KERN_INFO "%s(): device is busy\n", __func__);
+#endif
+		ret = -EBUSY;
+		goto err;
+	}
+
+	if (rw_mode == SPI_READ_MODE) {
+		spi->opened = FMODE_READ;
+		spi->k_flag = SPI_READ_MODE;
+	} else{
+		spi->opened = FMODE_WRITE;
+		spi->k_flag = SPI_WRITE_MODE;
+	}
+
+	memset(&spi->trans->buf, 0x00, sizeof(spi_buf_t));
+	spi->trans->dma_regs = NULL;
+
+	/* initialize data */
+	spi_init_data(spi);
+
+	/* sleep disable */
+	spi_sleep_flag++;
+
+	/* reset off */
+	spi_reset_ctrl(spi, SPI_OFF);
+
+	/* request SPI interrupt */
+	ret =
+		request_irq(spi->trans->int_spi, spi_interrupt, IRQF_DISABLED,
+			    SPI_NAME, (void *)spi);
+	if (ret < 0) {
+#ifdef SPI_DEBUG
+		printk(KERN_INFO "%s(): request irq error\n", __func__);
+#endif
+		goto err1;
+	}
+
+	/* set mode */
+	ret = spi_set_mode(spi, spi->mode);
+	if (ret < 0)
+		goto err2;
+
+	init_waitqueue_head(&spi->trans->wait);
+
+	up(&spi->sem_open);
+
+	return 0;
+
+err2:
+	spi_free_buffer(spi);
+	free_irq(spi->trans->int_spi, (void *)spi);
+err1:
+	spi_reset_ctrl(spi, SPI_ON);
+	spi_sleep_flag--;
+	spi->opened = 0;
+	spi->k_flag = 0;
+err:
+	up(&spi->sem_open);
+
+	return ret;
+}
+EXPORT_SYMBOL(mp201_spi_init);
+
+/*
+ * release
+ */
+static int spi_release(unsigned char dev, struct inode *inode,
+		       struct file *file)
+{
+	spi_data_t *spi;
+
+	/* device is not found */
+	if (DEVNO_IS_INVALID(dev))
+		return -ENODEV;
+
+	spi = &spi_private[dev];
+
+	if (down_interruptible(&spi->sem_open))
+		return -ERESTARTSYS;
+
+	if (file->f_mode & FMODE_READ) {
+		if (spi->trans->state == SPI_ACTIVE) {
+			/* RX stop */
+			spi_rx_stop(spi);
+		}
+	}
+	if (file->f_mode & FMODE_WRITE) {
+		if (spi->trans->state == SPI_ACTIVE) {
+			/* sync of TX buffer */
+			DECLARE_WAITQUEUE(wait, current);
+			add_wait_queue(&spi->trans->wait, &wait);
+			while (spi->trans->state == SPI_ACTIVE) {
+				set_current_state(TASK_INTERRUPTIBLE);
+				if (signal_pending(current) != 0) {
+					spi_tx_stop(spi);
+					break;
+				}
+				schedule();
+			}
+			remove_wait_queue(&spi->trans->wait, &wait);
+			set_current_state(TASK_RUNNING);
+		}
+	}
+
+	spi_free_dma(spi);
+
+	spi_free_buffer(spi);
+
+	free_irq(spi->trans->int_spi, (void *)spi);
+
+	/* reset on */
+	spi_reset_ctrl(spi, SPI_ON);
+
+	/* sleep enable */
+	spi_sleep_flag--;
+
+	/* initialize data */
+	spi_init_data(spi);
+
+	spi->opened = 0;
+
+	up(&spi->sem_open);
+
+	return 0;
+}
+
+/*
+ * same release
+ */
+int
+mp201_spi_end(unsigned char dev)
+{
+	spi_data_t *spi;
+
+	/* device is not found */
+	if (DEVNO_IS_INVALID(dev))
+		return -EACCES;
+	spi = &spi_private[dev];
+
+	if (spi->k_flag != SPI_READ_MODE && spi->k_flag != SPI_WRITE_MODE)
+		return -EACCES;
+
+	if (down_interruptible(&spi->sem_open))
+		return -ERESTARTSYS;
+
+	if (spi->opened & FMODE_READ) {
+		if (spi->trans->state == SPI_ACTIVE) {
+			/* RX stop */
+			spi_rx_stop(spi);
+		}
+	}
+	if (spi->opened & FMODE_WRITE) {
+		if (spi->trans->state == SPI_ACTIVE) {
+			/* sync of TX buffer */
+			DECLARE_WAITQUEUE(wait, current);
+			add_wait_queue(&spi->trans->wait, &wait);
+			while (spi->trans->state == SPI_ACTIVE) {
+				set_current_state(TASK_INTERRUPTIBLE);
+				if (signal_pending(current) != 0) {
+					spi_tx_stop(spi);
+					break;
+				}
+				schedule();
+			}
+			remove_wait_queue(&spi->trans->wait, &wait);
+			set_current_state(TASK_RUNNING);
+		}
+	}
+
+	spi_free_dma(spi);
+
+	spi_free_buffer(spi);
+
+	free_irq(spi->trans->int_spi, (void *)spi);
+
+	/* reset on */
+	spi_reset_ctrl(spi, SPI_ON);
+
+	/* sleep enable */
+	spi_sleep_flag--;
+
+	/* initialize data */
+	spi_init_data(spi);
+
+	spi->opened = 0;
+	spi->k_flag = 0;
+
+	up(&spi->sem_open);
+
+	return 0;
+}
+EXPORT_SYMBOL(mp201_spi_end);
+
+int
+mp201_spi_setmode(unsigned char dev, spi_mode_t *mode)
+{
+	spi_data_t *spi;
+	int ret;
+
+	/* device is not found */
+	if (DEVNO_IS_INVALID(dev))
+		return -EACCES;
+
+	spi = &spi_private[dev];
+
+	if (spi->k_flag != SPI_READ_MODE && spi->k_flag != SPI_WRITE_MODE)
+		return -EACCES;
+	ret = spi_set_mode(spi, mode);
+	if (ret < 0)
+		return -EFAULT;
+
+	memcpy((char *)spi->mode, (char *)mode, sizeof(spi_mode_t));
+
+	return 0;
+}
+EXPORT_SYMBOL(mp201_spi_setmode);
+
+int
+mp201_spi_getmode(unsigned char dev, spi_mode_t *mode)
+{
+	spi_data_t *spi;
+
+	/* device is not found */
+	if (DEVNO_IS_INVALID(dev))
+		return -EACCES;
+
+	if (mode == NULL)
+		return -EACCES;
+
+	spi = &spi_private[dev];
+	memcpy((char *)mode, (char *)spi->mode, sizeof(spi_mode_t));
+
+	return 0;
+}
+EXPORT_SYMBOL(mp201_spi_getmode);
+
+/*
+ * read (SPI1)
+ */
+static ssize_t spi_read_spi1(struct file *file, char *buf, size_t count,
+			     loff_t *ppos)
+{
+	return spi_read_func(SPI_DEV_SPI1, file, buf, count, ppos);
+}
+
+/*
+ * read (SPI2)
+ */
+static ssize_t spi_read_spi2(struct file *file, char *buf, size_t count,
+			     loff_t *ppos)
+{
+	return spi_read_func(SPI_DEV_SPI2, file, buf, count, ppos);
+}
+
+/*
+ * write (SPI1)
+ */
+static ssize_t spi_write_spi1(struct file *file, const char *buf, size_t count,
+			      loff_t *ppos)
+{
+	return spi_write_func(SPI_DEV_SPI1, file, buf, count, ppos);
+}
+
+/*
+ * write (SPI2)
+ */
+static ssize_t spi_write_spi2(struct file *file, const char *buf, size_t count,
+			      loff_t *ppos)
+{
+	return spi_write_func(SPI_DEV_SPI2, file, buf, count, ppos);
+}
+
+/*
+ * poll (SPI1)
+ */
+static unsigned int spi_poll_spi1(struct file *file, poll_table *wait)
+{
+	return spi_poll(SPI_DEV_SPI1, file, wait);
+}
+
+/*
+ * poll (SPI2)
+ */
+static unsigned int spi_poll_spi2(struct file *file, poll_table *wait)
+{
+	return spi_poll(SPI_DEV_SPI2, file, wait);
+}
+
+/*
+ * ioctl (SPI1)
+ */
+static int spi_ioctl_spi1(struct inode *inode, struct file *file,
+			  unsigned int cmd, unsigned long arg)
+{
+	return spi_ioctl(SPI_DEV_SPI1, inode, file, cmd, arg);
+}
+
+/*
+ * ioctl (SPI2)
+ */
+static int spi_ioctl_spi2(struct inode *inode, struct file *file,
+			  unsigned int cmd, unsigned long arg)
+{
+	return spi_ioctl(SPI_DEV_SPI2, inode, file, cmd, arg);
+}
+
+/*
+ * open (SPI1)
+ */
+static int spi_open_spi1(struct inode *inode, struct file *file)
+{
+	return spi_open(SPI_DEV_SPI1, inode, file);
+}
+
+/*
+ * open (SPI2)
+ */
+static int spi_open_spi2(struct inode *inode, struct file *file)
+{
+	return spi_open(SPI_DEV_SPI2, inode, file);
+}
+
+/*
+ * release (SPI1)
+ */
+static int spi_release_spi1(struct inode *inode, struct file *file)
+{
+	return spi_release(SPI_DEV_SPI1, inode, file);
+}
+
+/*
+ * release (SPI2)
+ */
+static int spi_release_spi2(struct inode *inode, struct file *file)
+{
+	return spi_release(SPI_DEV_SPI2, inode, file);
+}
+
+/* file operations info (SPI1) */
+static const struct file_operations spi_fops_spi1 = {
+	.read = spi_read_spi1,
+	.write = spi_write_spi1,
+	.poll = spi_poll_spi1,
+	.ioctl = spi_ioctl_spi1,
+	.open = spi_open_spi1,
+	.release = spi_release_spi1,
+	.owner = THIS_MODULE,
+};
+
+/* file operations info (SPI2) */
+static const struct file_operations spi_fops_spi2 = {
+	.read = spi_read_spi2,
+	.write = spi_write_spi2,
+	.poll = spi_poll_spi2,
+	.ioctl = spi_ioctl_spi2,
+	.open = spi_open_spi2,
+	.release = spi_release_spi2,
+	.owner = THIS_MODULE,
+};
+
+/*
+ * open
+ */
+static int spi_open_chrdev(struct inode *inode, struct file *file)
+{
+	int minor = MINOR(inode->i_rdev);
+
+	switch (minor) {
+	/* SPI1 */
+	case SPI_MINOR_SPI1:
+		file->f_op = &spi_fops_spi1;
+		break;
+	/* SPI2 */
+	case SPI_MINOR_SPI2:
+		file->f_op = &spi_fops_spi2;
+		break;
+	default:
+		/* error */
+		return -ENODEV;
+	}
+
+	if (file->f_op->open != 0)
+		return (*file->f_op->open)(inode, file);
+
+	return 0;
+}
+
+/*
+ * register of device
+ */
+static int spi_probe(struct platform_device *dev)
+{
+	int result = 0;
+	struct device *spi_class_dev;
+	dev_t t_dev_temp;
+
+	if (DEVNO_IS_INVALID(dev->id)) {
+		/* Unsupported */
+		return result;
+	}
+
+	init_MUTEX(&spi_private[dev->id].sem_rw);
+	init_MUTEX(&spi_private[dev->id].sem_open);
+
+	t_dev_temp = MKDEV(MAJOR(t_dev), dev->id);
+	spi_class_dev = device_create(spi_class, NULL, t_dev_temp, NULL,
+			"spi%d", dev->id);
+	if (IS_ERR(spi_class_dev)) {
+		printk(KERN_ERR "spi: Unable to create class_device.\n");
+		result = PTR_ERR(spi_class_dev);
+	}
+
+	return result;
+}
+
+/*
+ * unregister of device
+ */
+static int spi_remove(struct platform_device *dev)
+{
+	if (DEVNO_IS_INVALID(dev->id))
+		return -ENODEV;
+
+	device_destroy(spi_class, MKDEV(spi_major, dev->id));
+
+	return 0;
+}
+
+static int  spi_suspend(struct platform_device *dev, pm_message_t state)
+{
+#ifdef SPI_DEBUG
+	printk(KERN_INFO "%s(): id=%d state.event=%d\n",
+	       __func__, dev->id, state.event);
+#endif
+
+	if (DEVNO_IS_INVALID(dev->id))
+		return 0;
+
+	switch (state.event) {
+	case DEV_SUSPEND_IDLE_1:
+	case PM_EVENT_SUSPEND:
+		if (spi_sleep_flag != 0)
+			return -EBUSY;
+		break;
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+static int  spi_resume(struct platform_device *dev)
+{
+#ifdef SPI_DEBUG
+	printk(KERN_INFO "%s(): id=%d\n",
+	       __func__, dev->id);
+#endif
+
+	if (DEVNO_IS_INVALID(dev->id))
+		return 0;
+
+	return 0;
+}
+
+static struct platform_driver spi_drv = {
+	.driver.name  = SPI_NAME,
+	.driver.bus   = &platform_bus_type,
+	.probe        = spi_probe,
+	.remove       = spi_remove,
+	.suspend      = spi_suspend,
+	.resume       = spi_resume,
+};
+
+/*
+ * initialize
+ */
+static int __init spi_init(void)
+{
+	int result = 0;
+	int minor_num_start = 1;
+	int dev_count = 2; /* SPI1,SPI2 */
+
+	printk(KERN_INFO "Starting %s.\n", SPI_NAME);
+
+	if (spi_major) {
+		t_dev  = MKDEV(spi_major, minor_num_start);
+		result = register_chrdev_region(t_dev, dev_count, SPI_NAME);
+	} else{
+		result = alloc_chrdev_region(&t_dev, minor_num_start,
+				dev_count, SPI_NAME);
+		spi_major  = MAJOR(t_dev);
+	}
+	if (result < 0) {
+		printk(KERN_ERR "spi: can't get major number.\n");
+		goto fail_get_major;
+	}
+
+	cdev_init(&spi_cdev, &spi_fops);
+	spi_cdev.owner = THIS_MODULE;
+	result = cdev_add(&spi_cdev, t_dev, dev_count);
+	if (result)
+		goto fail_cdev_add;
+
+	spi_class = class_create(THIS_MODULE, SPI_NAME);
+	if (IS_ERR(spi_class)) {
+		printk(KERN_ERR "spi: Unable to create spi class.\n");
+		result = PTR_ERR(spi_class);
+		goto fail_class_create;
+	}
+
+	if (platform_driver_register(&spi_drv) < 0) {
+		result = -1;
+		printk(KERN_ERR " @spi: could not register platform_driver\n");
+		goto fail_platform_driver;
+	}
+
+	printk(KERN_INFO "spi: registered device spi [spi]\n");
+
+	goto success;
+
+fail_platform_driver:
+	class_destroy(spi_class);
+fail_class_create:
+	cdev_del(&spi_cdev);
+fail_cdev_add:
+	unregister_chrdev(spi_major, SPI_NAME);
+fail_get_major:
+success:
+
+	return result;
+}
+
+/*
+ * exit
+ */
+static void __exit spi_exit(void)
+{
+	platform_driver_unregister(&spi_drv);
+
+	class_destroy(spi_class);
+	cdev_del(&spi_cdev);
+	unregister_chrdev(spi_major, SPI_NAME);
+}
+
+#ifdef SPI_DEBUG
+unsigned int get_spi_k_flag(unsigned char dev)
+{
+	return spi_private[dev].k_flag;
+}
+EXPORT_SYMBOL(get_spi_k_flag);
+
+void set_spi_k_flag(unsigned char dev, unsigned int k_flag)
+{
+	spi_private[dev].k_flag = k_flag;
+}
+EXPORT_SYMBOL(set_spi_k_flag);
+#endif
+
+module_init(spi_init);
+module_exit(spi_exit);
+MODULE_LICENSE("GPL");
diff --git a/drivers/char/mp200_spi.h b/drivers/char/mp200_spi.h
new file mode 100644
index 0000000..0993706
--- /dev/null
+++ b/drivers/char/mp200_spi.h
@@ -0,0 +1,254 @@
+/*
+ *  File Name       : linux/drivers/char/mp200_spi.h
+ *  Function        : MP200 SPI interface
+ *  Release Version : Ver 1.02
+ *  Release Date    : 2006/03/06
+ *
+ *  Copyright (C) NEC Electronics Corporation 2005-2006
+ *
+ *
+ *  This program is free software;you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License as published by Free
+ *  Softwere Foundation; either version 2 of License, or (at your option) any
+ *  later version.
+ *
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warrnty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; If not, write to the Free Software Foundation, Inc., 59
+ *  Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#ifndef __DRIVERS_CHAR_MP200_SPI_H
+#define __DRIVERS_CHAR_MP200_SPI_H
+
+#include <mach/spi.h>
+
+/*
+ * SPI register
+ */
+#define SP0_ADDR  IO_ADDRESS(MP200_SP0_BASE)
+#define SP1_ADDR  IO_ADDRESS(MP200_SP1_BASE)
+#define SP2_ADDR  IO_ADDRESS(MP200_SP2_BASE)
+
+#define SPx_TX_DATA_PHYS(ADDR)          ((ADDR) + 0x00000010)
+#define SPx_RX_DATA_PHYS(ADDR)          ((ADDR) + 0x00000014)
+
+#define SPx_POL_VAL_SPI0                SPI_POL_VAL_SPI0
+#define SPx_POL_VAL_SPI1                SPI_POL_VAL_SPI1
+#define SPx_POL_VAL_SPI2                SPI_POL_VAL_SPI2
+
+#define SPx_CONTROL_TX_EMP              (0x01 << 15)
+#define SPx_CONTROL_RX_FULL             (0x01 << 14)
+#define SPx_CONTROL_RST                 (0x01 << 8)
+#define SPx_CONTROL_TX_FULL             (0x01 << 7)
+#define SPx_CONTROL_RX_EMP              (0x01 << 6)
+#define SPx_CONTROL_WRT                 (0x01 << 3)
+#define SPx_CONTROL_RD                  (0x01 << 2)
+#define SPx_CONTROL_STOP                (0x01 << 1)
+#define SPx_CONTROL_START               (0x01 << 0)
+
+#define SPx_STATUS_TX_STOP              (0x01 << 6)
+#define SPx_STATUS_RX_STOP              (0x01 << 5)
+#define SPx_STATUS_TERR                 (0x01 << 4)
+#define SPx_STATUS_RDV                  (0x01 << 3)
+#define SPx_STATUS_END                  (0x01 << 2)
+#define SPx_STATUS_TX_UDR               (0x01 << 1)
+#define SPx_STATUS_RX_OVR               (0x01 << 0)
+#define SPx_STATUS_ALLERR               (SPx_STATUS_TERR | \
+					 SPx_STATUS_TX_UDR | \
+					 SPx_STATUS_RX_OVR)
+
+#define SPx_RAW_STATUS_TX_STOP_RAW      (0x01 << 6)
+#define SPx_RAW_STATUS_RX_STOP_RAW      (0x01 << 5)
+#define SPx_RAW_STATUS_TERR_RAW         (0x01 << 4)
+#define SPx_RAW_STATUS_RDV_RAW          (0x01 << 3)
+#define SPx_RAW_STATUS_END_RAW          (0x01 << 2)
+#define SPx_RAW_STATUS_TX_UDR_RAW       (0x01 << 1)
+#define SPx_RAW_STATUS_RX_OVR_RAW       (0x01 << 0)
+
+#define SPx_ENSET_TX_STOP_EN            (0x01 << 6)
+#define SPx_ENSET_RX_STOP_EN            (0x01 << 5)
+#define SPx_ENSET_TERR_EN               (0x01 << 4)
+#define SPx_ENSET_RDV_EN                (0x01 << 3)
+#define SPx_ENSET_END_EN                (0x01 << 2)
+#define SPx_ENSET_TX_UDR_EN             (0x01 << 1)
+#define SPx_ENSET_RX_OVR_EN             (0x01 << 0)
+#define SPx_ENSET_ALLERR_EN             (SPx_ENSET_TERR_EN | \
+					 SPx_ENSET_TX_UDR_EN | \
+					 SPx_ENSET_RX_OVR_EN)
+
+#define SPx_ENCLR_TX_STOP_MASK          (0x01 << 6)
+#define SPx_ENCLR_RX_STOP_MASK          (0x01 << 5)
+#define SPx_ENCLR_TERR_MASK             (0x01 << 4)
+#define SPx_ENCLR_RDV_MASK              (0x01 << 3)
+#define SPx_ENCLR_END_MASK              (0x01 << 2)
+#define SPx_ENCLR_TX_UDR_MASK           (0x01 << 1)
+#define SPx_ENCLR_RX_OVR_MASK           (0x01 << 0)
+#define SPx_ENCLR_ALLERR_MASK           (SPx_ENCLR_TERR_MASK | \
+					 SPx_ENCLR_TX_UDR_MASK | \
+					 SPx_ENCLR_RX_OVR_MASK)
+#define SPx_ENCLR_ALL_MASK              (SPx_ENCLR_TX_STOP_MASK	  \
+					 | SPx_ENCLR_RX_STOP_MASK \
+					 | SPx_ENCLR_TERR_MASK	  \
+					 | SPx_ENCLR_RDV_MASK	  \
+					 | SPx_ENCLR_END_MASK	  \
+					 | SPx_ENCLR_TX_UDR_MASK  \
+					 | SPx_ENCLR_RX_OVR_MASK)
+
+#define SPx_FFCLR_TX_STOP_CLR           (0x01 << 6)
+#define SPx_FFCLR_RX_STOP_CLR           (0x01 << 5)
+#define SPx_FFCLR_TERR_CLR              (0x01 << 4)
+#define SPx_FFCLR_RDV_CLR               (0x01 << 3)
+#define SPx_FFCLR_END_CLR               (0x01 << 2)
+#define SPx_FFCLR_TX_UDR_CLR            (0x01 << 1)
+#define SPx_FFCLR_RX_OVR_CLR            (0x01 << 0)
+#define SPx_FFCLR_ALL_CLR               (SPx_FFCLR_TX_STOP_CLR	 \
+					 | SPx_FFCLR_RX_STOP_CLR \
+					 | SPx_FFCLR_TERR_CLR	 \
+					 | SPx_FFCLR_RDV_CLR	 \
+					 | SPx_FFCLR_END_CLR	 \
+					 | SPx_FFCLR_TX_UDR_CLR	 \
+					 | SPx_FFCLR_RX_OVR_CLR)
+
+#define SPx_CONTROL2_TX_STOP_MODE       (0x01 << 9)
+#define SPx_CONTROL2_RX_STOP_MODE       (0x01 << 8)
+#define SPx_CONTROL2_RX_FIFO_FULL_MASK  ((0xFF << 16) | (0xFF << 0))
+
+#define DEVNO_IS_INVALID(dev_no)        (dev_no != SPI_DEV_SPI1 && \
+					 dev_no != SPI_DEV_SPI2)
+
+/*
+ * device info
+ */
+#define SPI_NAME                        "spi"
+#define SPI_DIR                         "spi"
+
+#if 0
+/* SPI0 is Unsupported */
+#define SPI_MINOR_SPI0                  0
+#endif
+#define SPI_MINOR_SPI1                  1
+#define SPI_MINOR_SPI2                  2
+
+/*
+ * transfer status
+ */
+#define SPI_STOP                        0
+#define SPI_ACTIVE                      1
+
+/*
+ * buffer status
+ */
+#define SPI_BUFF_FULL                   (0x01 << 0)
+#define SPI_BUFF_EMPTY                  (0x01 << 1)
+#define SPI_BUFF_OVER_ERR               (0x01 << 2)
+
+/*
+ * other define
+ */
+#define SPI_BUFSIZE_MAX                 65536   /* buffer size max [byte] */
+#define SPI_BLKSIZE_MAX                 32768   /* block size max [byte] */
+#define SPI_BLKNUM_MAX                  16      /* block number max */
+#define SPI_BLKSIZE                     1024    /* block size default [byte] */
+
+#define SPI_OFF                         0       /* clock/reset off */
+#define SPI_ON                          1       /* clock/reset on */
+#define SPI_RESET                       2       /* reset on->off */
+
+#define SPI_FIFO_MAX                    32      /* fifo count max */
+#define SPI_DMA_BLOCK_SIZE_MAX          65534   /* dma block size max [byte] */
+
+/*
+ * spi register info
+ */
+struct spi_regs_t{
+	volatile unsigned int mode;             /* SPx_MODE       (0x00) */
+	volatile unsigned int pol;              /* SPx_POL        (0x04) */
+	volatile unsigned int control;          /* SPx_CONTROL    (0x08) */
+	unsigned int:32;                       /* reserved       (0x0c) */
+	volatile unsigned int tx_data;          /* SPx_TX_DATA    (0x10) */
+	volatile unsigned int rx_data;          /* SPx_RX_DATA    (0x14) */
+	volatile unsigned int status;           /* SPx_STATUS     (0x18) */
+	volatile unsigned int raw_status;       /* SPx_RAW_STATUS (0x1c) */
+	volatile unsigned int enset;            /* SPx_ENSET      (0x20) */
+	volatile unsigned int enclr;            /* SPx_ENCLR      (0x24) */
+	volatile unsigned int ffclr;            /* SPx_FFCLR      (0x28) */
+	unsigned int:32;                       /* reserved       (0x2c) */
+	unsigned int:32;                       /* reserved       (0x30) */
+	volatile unsigned int control2;         /* SPx_CONTROL2   (0x34) */
+	volatile unsigned int tiecs;            /* SPx_TIECS      (0x38) */
+};
+
+#define spi_regs struct spi_regs_t
+
+/*
+ * buffer info
+ */
+struct spi_buf_info{
+	dma_addr_t dma_addr;    /* dma transfer start address (physics) */
+	unsigned int top;       /* buffer top address (virtual) */
+	unsigned int end;       /* buffer end address (virtual) */
+	unsigned int dma_ptr;   /* buffer pointer for dma/cpu transfer */
+	unsigned int usr_ptr;   /* buffer pointer for read/write */
+	unsigned int blknum;    /* block number */
+	unsigned int state;     /* buffer status */
+};
+
+#define spi_buf_t struct spi_buf_info
+
+/*
+ * transfer info
+ */
+struct spi_trans_info{
+	dma_regs_t *dma_regs;   /* dma_regs_t */
+	int const rx_lch;       /* dma rx channel no */
+	int const tx_lch;       /* dma tx channel no */
+	unsigned int const rx_data;     /* rx data transfer address (physics) */
+	unsigned int const tx_data;     /* tx data transfer address (physics) */
+	unsigned int int_spi;   /* int spi no */
+	unsigned int dma_err;   /* dma error status */
+	unsigned int spi_err;   /* spi error status */
+	unsigned int state;     /* transfer status */
+	wait_queue_head_t wait; /* wait queue */
+	spinlock_t spinlock;    /* spin lock */
+	spi_buf_t buf;          /* buffer info */
+};
+
+#define spi_trans_t struct spi_trans_info
+
+/*
+ * smu info
+ */
+struct spi_smu_info{
+	unsigned int pclk;      /* pclk */
+	unsigned int sclk;      /* sclk */
+	unsigned int pclk_ctrl; /* pclk ctrl */
+	unsigned int sclk_ctrl; /* sclk ctrl */
+	unsigned int reset;     /* reset */
+	unsigned int div_sclk;  /* divsclk */
+};
+
+#define spi_smu_t struct spi_smu_info
+/*
+ * spi data info
+ */
+struct spi_data_info{
+	spi_regs   *regs;       /* spi register info */
+	spi_mode_t *mode;       /* spi mode info */
+	unsigned int pol;       /* spi pol info */
+	spi_smu_t *smu;         /* smu info */
+	spi_trans_t *trans;     /* transfer info */
+	mode_t opened;          /* open flag */
+	unsigned int k_flag;            /* kernel flag */
+	struct semaphore sem_rw;        /* semaphore for open/release */
+	struct semaphore sem_open;      /* semaphore for open/release */
+};
+
+#define spi_data_t struct spi_data_info
+
+#endif                          /* __DRIVERS_CHAR_MP200_SPI_H */
diff --git a/drivers/char/mp200_spi0.c b/drivers/char/mp200_spi0.c
new file mode 100644
index 0000000..b5ba4c3
--- /dev/null
+++ b/drivers/char/mp200_spi0.c
@@ -0,0 +1,1143 @@
+/*
+ *	File Name		: linux/drivers/char/mp200_spi0.c
+ *	Function		: MP200 SPI0 interface
+ *	Release Version : Ver 1.00
+ *	Release Date	: 2007/07/04
+ *
+ *	Copyright (C) NEC Electronics Corporation 2005-2006
+ *
+ *
+ *	This program is free software;you can redistribute it and/or modify it
+ *	under the terms of the GNU General Public License as published by Free
+ *	Softwere Foundation; either version 2 of License, or (at your option)
+ *	any later version.
+ *
+ *	This program is distributed in the hope that it will be useful, but
+ *	WITHOUT ANY WARRANTY; without even the implied warrnty of
+ *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *	General Public License for more details.
+ *
+ *	You should have received a copy of the GNU General Public License along
+ *	with this program; If not, write to the Free Software Foundation, Inc.,
+ *	59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/dma-mapping.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/io.h>
+#include <asm/irq.h>
+#include <mach/dma.h>
+#include <mach/smu.h>
+#include <mach/pmu.h>
+
+#include "mp200_spi0.h"
+
+#if defined(SPI_DEBUG)
+#define DEB(fmt, args...) \
+	printk(KERN_DEBUG "%s: " fmt, __func__, ## args);
+#else
+#define DEB(fmt, args...)
+#endif
+
+static void spi_interrupt_dma_rx(void *, int, int);
+static void spi_interrupt_dma_tx(void *, int, int);
+
+/* unsigned int sp0_excl = CONFIG_MP200_SPI_EXCL_SP0; */
+unsigned int sp0_excl = 1;
+EXPORT_SYMBOL(sp0_excl); /* for spi_kern */
+/*module_param(sp0_excl, uint, 0644);*/
+
+int spi_write_without_intr(const SPI_CONFIG *, const char *, int)
+__attribute__ ((weak));
+
+/* transfer info (SP0) */
+static struct spi_trans trans_sp0 = {
+	.rx_lch = MP200_DMAC_P2M_LCH12,
+	.tx_lch = MP200_DMAC_M2P_LCH12,
+	.rx_data = SPx_RX_DATA_PHYS(MP200_SP0_BASE),
+	.tx_data = SPx_TX_DATA_PHYS(MP200_SP0_BASE),
+	.int_spi = INT_SP0,
+	.state = SPI_UNUSED,
+	.spinlock = __SPIN_LOCK_UNLOCKED(trans_sp0.spinlock),
+};
+
+/* spi config info (SP0) */
+static SPI_CONFIG config_sp0 = {
+	.dev = SPI_DEV_SP0,
+	.nbr = SPI_NB_16BIT,
+	.nbw = SPI_NB_16BIT,
+	.cs_sel = SPI_CS_SEL_CS0,
+	.m_s = SPI_M_S_MASTER,
+	.dma = SPI_DMA_OFF,
+	.pol = SPI_POL_SP0_CS0,
+	.sclk = SPI_SCLK_3MHZ,
+	.tiecs = SPI_TIECS_NORMAL
+};
+
+/* smu info (SP0) */
+static struct spi_smu smu_sp0 = {
+	.pclk = MP200_CLOCKGATE_SP0_PCLK,
+	.sclk = MP200_CLOCKGATE_SP0_SCLK,
+	.pclk_ctrl = MP200_CLKCTRL_SP0PCLK,
+	.sclk_ctrl = MP200_CLKCTRL_SP0SCLK,
+	.reset = MP200_RESETDEVICE_SP0,
+	.sclk_div = SMU_DIVSP0SCLK,
+};
+
+/* spi private data info */
+static struct spi_data spi_private[] = {
+	{
+		.regs = (struct spi_regs *)(SP0_ADDR),
+		.trans = &trans_sp0,
+		.config = &config_sp0,
+		.smu = &smu_sp0,
+		.probe = 0,
+		.pol = SPI_POL_SP0,
+	},
+};
+
+static unsigned int spi_clock_table[] = {
+	1433,           /* (1434KHz) */
+	2867,           /* (2.87MHz) */
+	5734,           /* (5.73MHz) */
+	11468,          /* (11.47MHz) */
+	22937,          /* (22.94MHz) */
+	38229,          /* (38.23MHz) */
+};
+
+static unsigned int spi_plldiv_table[] = {
+	SMU_DIV160,     /* 1500KHz(1434KHz) */
+	SMU_DIV80,      /* 3MHz   (2.87MHz) */
+	SMU_DIV40,      /* 6MHz   (5.73MHz) */
+	SMU_DIV20,      /* 12MHz  (11.47MHz) */
+	SMU_DIV10,      /* 24MHz  (22.94MHz) */
+	SMU_DIV6,       /* 48MHz  (38.23MHz) */
+};
+
+static void spi_sft_reset(struct spi_data *spi)
+{
+	spi->regs->control |= SPx_CONTROL_RST;
+	udelay((1000 * 4 / spi_clock_table[spi->config->sclk]) + 1);
+	spi->regs->control &= ~(SPx_CONTROL_RST);
+}
+
+static void spi_power_on(struct spi_data *spi)
+{
+	if (spi_write_without_intr != 0)
+		return;
+
+	mp200_pmu_clkctrl_off(spi->smu->sclk_ctrl);
+	mp200_pmu_clkctrl_off(spi->smu->pclk_ctrl);
+	mp200_pmu_open_clockgate(spi->smu->pclk);
+	mp200_pmu_open_clockgate(spi->smu->sclk);
+	mp200_pmu_unreset_device(spi->smu->reset);
+	mp200_pmu_clkctrl_on(spi->smu->pclk_ctrl);
+	mp200_pmu_clkctrl_on(spi->smu->sclk_ctrl);
+}
+
+static void spi_power_off(struct spi_data *spi)
+{
+	if (spi_write_without_intr != 0)
+		return;
+
+	mp200_pmu_clkctrl_off(spi->smu->sclk_ctrl);
+	mp200_pmu_clkctrl_off(spi->smu->pclk_ctrl);
+	mp200_pmu_reset_device(spi->smu->reset);
+	mp200_pmu_close_clockgate(spi->smu->sclk);
+	mp200_pmu_close_clockgate(spi->smu->pclk);
+}
+
+static int spi_set_sclk_div(struct spi_data *spi, unsigned int sclk)
+{
+
+	switch (sclk) {
+	case SPI_SCLK_1500KHZ:
+	case SPI_SCLK_3MHZ:
+	case SPI_SCLK_6MHZ:
+	case SPI_SCLK_12MHZ:
+	case SPI_SCLK_24MHZ:
+	case SPI_SCLK_48MHZ:
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	outl(spi_plldiv_table[sclk], spi->smu->sclk_div);
+
+	DEB("sclk = %d[KHz]\n", spi_clock_table[sclk]);
+
+	return 0;
+}
+
+static unsigned int spi_unit(struct spi_data *spi, unsigned int bit)
+{
+	if (bit == 0)
+		return 0;
+	else if (bit <= SPI_NB_8BIT)
+		return 1;
+	else if (bit <= SPI_NB_16BIT)
+		return 2;
+	else if ((bit <= SPI_NB_24BIT) && (spi->config->dma == SPI_DMA_OFF))
+		return 3;
+	else
+		return 4;
+}
+
+static void spi_init_data(struct spi_data *spi)
+{
+	spi->trans->dma_err = 0;
+	spi->trans->spi_err = 0;
+	spi->trans->size = 0;
+}
+
+static int spi_request_dma(struct spi_data *spi)
+{
+	int ret;
+
+	ret = mp200_request_dma(spi->trans->rx_lch, SPI_NAME,
+				spi_interrupt_dma_rx, (void *)spi,
+				&spi->trans->dma_rx_regs);
+	if (ret < 0) {
+		DEB("error\n");
+		return ret;
+	}
+
+	ret = mp200_request_dma(spi->trans->tx_lch, SPI_NAME,
+				spi_interrupt_dma_tx, (void *)spi,
+				&spi->trans->dma_tx_regs);
+	if (ret < 0) {
+		DEB("error\n");
+		mp200_free_dma(spi->trans->rx_lch);
+		return ret;
+	}
+
+	return 0;
+}
+
+static void spi_free_dma(struct spi_data *spi)
+{
+	mp200_free_dma(spi->trans->tx_lch);
+	mp200_free_dma(spi->trans->rx_lch);
+}
+
+static int spi_config(struct spi_data *spi, SPI_CONFIG *config)
+{
+	unsigned int mode = 0;
+	unsigned int pol = 0;
+	unsigned int pol_bit = 0;
+	unsigned int csw = 0;
+	unsigned int csw_pol = 0;
+	unsigned int nb = 0;
+	unsigned int tiecs = 0;
+
+	/* bit length */
+	if (spi->trans->state == SPI_READ)
+		nb = config->nbr;
+	else if (spi->trans->state == SPI_WRITE)
+		nb = config->nbw;
+	else if (spi->trans->state == SPI_RW)
+		nb = config->nbr + config->nbw;
+	else
+		nb = SPI_NB_16BIT;
+	if ((nb < SPI_NB_8BIT) || (SPI_NB_32BIT < nb))
+		return -EINVAL;
+	mode |= ((nb - 1) << 8);
+
+	/* chip select */
+	switch (config->cs_sel) {
+	case SPI_CS_SEL_CS0:
+	case SPI_CS_SEL_CS1:
+	case SPI_CS_SEL_CS2:
+	case SPI_CS_SEL_CS3:
+	case SPI_CS_SEL_CS4:
+	case SPI_CS_SEL_CS5:
+		mode |= (config->cs_sel << 4);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	/* master/slave */
+	if ((config->m_s == SPI_M_S_MASTER)
+	    || (config->m_s == SPI_M_S_SLAVE)) {
+		mode |= (config->m_s << 1);
+	} else {
+		return -EINVAL;
+	}
+
+	/* dma on/off */
+	if ((config->dma == SPI_DMA_OFF) || (config->dma == SPI_DMA_ON))
+		mode |= (config->dma  << 0);
+	else
+		return -EINVAL;
+
+	/* tiecs */
+	if ((config->tiecs == SPI_TIECS_NORMAL)
+	    || (config->tiecs == SPI_TIECS_FIXED)) {
+		tiecs = config->tiecs << config->cs_sel;
+	} else {
+		return -EINVAL;
+	}
+
+	/* pol */
+	csw = (config->pol & SPI_CSW_MASK);
+	if (SPI_CSW_16CLK < csw)
+		return -EINVAL;
+
+	switch (config->cs_sel) {
+	case SPI_CS_SEL_CS0:
+	case SPI_CS_SEL_CS1:
+	case SPI_CS_SEL_CS2:
+	case SPI_CS_SEL_CS3:
+		pol_bit = config->cs_sel * 3;
+		break;
+	case SPI_CS_SEL_CS4:
+	case SPI_CS_SEL_CS5:
+		pol_bit = 16 + ((config->cs_sel - 4) * 3);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	pol = (config->pol & SPI_POL_MASK);
+
+	if (config->dev == SPI_DEV_SP0) {
+		csw_pol = spi->pol;
+		csw_pol &= ~(SPI_CSW_MASK | (SPI_POL_MASK << pol_bit));
+		csw_pol |= (csw | (pol << pol_bit));
+	} else {
+		return -EINVAL;
+	}
+
+	/* set sclk */
+	if (spi_set_sclk_div(spi, config->sclk) < 0)
+		return -EINVAL;
+
+	/* set SPx_MODE */
+	spi->regs->mode = mode;
+	/* set SPx_TIECS */
+	spi->regs->tiecs = tiecs;
+	/* set SPx_POL */
+	spi->regs->pol = csw_pol;
+
+	spi->pol = csw_pol;
+
+	/* software reset */
+	spi_sft_reset(spi);
+
+	memcpy(spi->config, config, sizeof(SPI_CONFIG));
+
+	return 0;
+}
+
+static void spi_config_release(struct spi_data *spi)
+{
+	if (spi->config->tiecs == SPI_TIECS_FIXED) {
+		if (spi->config->dev == SPI_DEV_SP0) {
+			spi->regs->tiecs = 0x00000000; /* all normal */
+		} else {
+			/* Unsupported */
+			return;
+		}
+	}
+}
+
+static int spi_xferbytes(struct spi_data *spi, char *buf, unsigned int count,
+		unsigned int flags)
+{
+	unsigned int data = 0;
+	int ret = 0;
+
+	if (count == 0)
+		return 0;
+
+	if (flags == SPI_READ) {
+		spi->regs->control = (SPx_CONTROL_RD | SPx_CONTROL_START);
+		while ((spi->regs->
+			control & (SPx_CONTROL_START | SPx_CONTROL_RX_EMP)) !=
+		       0) {
+			if ((spi->regs->
+			     raw_status & SPx_RAW_STATUS_RX_ALLERR_RAW) != 0) {
+				ret = -EIO;
+				break;
+			}
+		}
+		data = spi->regs->rx_data;
+		memcpy(buf, (char *)&data, count);
+	} else if (flags == SPI_WRITE) {
+		memcpy((char *)&data, buf, count);
+		spi->regs->tx_data = data;
+		spi->regs->control = (SPx_CONTROL_WRT | SPx_CONTROL_START);
+		while ((spi->regs->control & SPx_CONTROL_START) != 0) {
+			if ((spi->regs->
+			     raw_status & SPx_RAW_STATUS_TX_ALLERR_RAW) != 0) {
+				ret = -EIO;
+				break;
+			}
+		}
+	} else if (flags == SPI_RW) {
+		memcpy((char *)&data, buf, count);
+		spi->regs->tx_data = data;
+		spi->regs->control =
+			(SPx_CONTROL_RD | SPx_CONTROL_WRT | SPx_CONTROL_START);
+		while ((spi->regs->
+			control & (SPx_CONTROL_START | SPx_CONTROL_RX_EMP)) !=
+		       0) {
+			if ((spi->regs->
+			     raw_status & SPx_RAW_STATUS_ALLERR_RAW) != 0) {
+				ret = -EIO;
+				break;
+			}
+		}
+		data = spi->regs->rx_data;
+		memcpy(buf, (char *)&data, count);
+	}
+
+	return ret;
+}
+
+static void spi_rx_stop(struct spi_data *spi)
+{
+	if (spi->config->dma == SPI_DMA_ON) {
+		if (spi->config->m_s == SPI_M_S_MASTER) {
+			if ((spi->regs->control & SPx_CONTROL_START) != 0) {
+				spi->regs->control |= SPx_CONTROL_STOP;
+				udelay((1000 * spi->config->nbr /
+				    spi_clock_table[spi->config->sclk]) + 1);
+			}
+			spi->regs->control2 &=  ~(SPx_CONTROL2_RX_STOP_MODE
+					|  SPx_CONTROL2_RX_FIFO_FULL_MASK);
+		}
+		mp200_stop_dma(spi->trans->rx_lch);
+		spi->regs->enclr = SPx_ENCLR_RX_ALL_MASK;
+	}
+	spi_sft_reset(spi);
+}
+
+static void spi_tx_stop(struct spi_data *spi)
+{
+	if (spi->config->dma == SPI_DMA_ON) {
+		if (spi->config->m_s == SPI_M_S_MASTER) {
+			if ((spi->regs->control & SPx_CONTROL_START) != 0) {
+				spi->regs->control |= SPx_CONTROL_STOP;
+				udelay((1000 * spi->config->nbw /
+				    spi_clock_table[spi->config->sclk]) + 1);
+			}
+			spi->regs->control2 &= ~(SPx_CONTROL2_TX_STOP_MODE);
+		}
+		mp200_stop_dma(spi->trans->tx_lch);
+		spi->regs->enclr = SPx_ENCLR_TX_ALL_MASK;
+	}
+
+	spi_sft_reset(spi);
+}
+
+static int spi_rx_start(struct spi_data *spi, unsigned int size)
+{
+	int ret;
+
+	if (size == 0)
+		return 0;
+
+	if (spi->config->dma == SPI_DMA_ON) {
+		int intmask;
+
+		if (spi->config->nbr <= SPI_NB_8BIT) {
+			spi->trans->dma_rx_regs->mode =
+				MP200_DMAC_DEFMODE_8BIT;
+		} else if (spi->config->nbr <= SPI_NB_16BIT) {
+			spi->trans->dma_rx_regs->mode =
+				MP200_DMAC_DEFMODE_16BIT;
+		} else {
+			spi->trans->dma_rx_regs->mode =
+				MP200_DMAC_DEFMODE_32BIT;
+		}
+		spi->trans->dma_rx_regs->boff = 0;
+		spi->trans->dma_rx_regs->bsize =
+			(size > SPI_DMA_BLOCK_MAXSIZE) ?
+			SPI_DMA_BLOCK_MAXSIZE : size;
+		spi->trans->dma_rx_regs->bsize_count = 0;
+		spi->trans->dma_rx_regs->leng = size;
+		intmask = (MP200_DMAC_INT_ERROR_EN | MP200_DMAC_INT_LENG_EN);
+
+		DEB("addr=0x%08x mode=0x%08x bsize=0x%08x leng=0x%08x "
+		    "intmask=0x%08x \n", spi->trans->buf.dma_addr,
+		    spi->trans->dma_rx_regs->mode,
+		    spi->trans->dma_rx_regs->bsize,
+		    spi->trans->dma_rx_regs->leng, intmask);
+
+		ret = mp200_start_dma(spi->trans->rx_lch, spi->trans->rx_data,
+				0, spi->trans->buf.dma_addr, intmask);
+		if (ret < 0) {
+			DEB("dma error\n");
+			return ret;
+		}
+		if (spi->config->m_s == SPI_M_S_MASTER) {
+			unsigned int full =
+				((size / spi_unit(spi, spi->config->nbr)) - 1);
+			if (full < 0x10000) {
+				spi->regs->control2 &=
+					~SPx_CONTROL2_RX_FIFO_FULL_MASK;
+				spi->regs->control2 |=
+					(((full & 0xff00) << 8) | (full & 0xff)
+					 | SPx_CONTROL2_RX_STOP_MODE);
+			}
+		}
+		spi->regs->enset = SPx_ENSET_RX_ALLERR_EN;
+		spi->regs->control = (SPx_CONTROL_RD | SPx_CONTROL_START);
+	} else {
+		int i;
+		unsigned int unit;
+		char *buf;
+
+		unit = spi_unit(spi, spi->config->nbr);
+		for (i = 0; i < size; i += unit) {
+			buf = (char *)(spi->trans->buf.addr + i);
+			ret = spi_xferbytes(spi, buf, unit, SPI_READ);
+			if (ret < 0) {
+				spi_sft_reset(spi);
+				return ret;
+			}
+		}
+	}
+
+	return 0;
+}
+
+static int spi_tx_start(struct spi_data *spi, unsigned int size)
+{
+	int ret;
+
+	if (size == 0)
+		return 0;
+
+	if (spi->config->dma == SPI_DMA_ON) {
+		int intmask;
+
+		if (spi->config->nbw <= SPI_NB_8BIT) {
+			spi->trans->dma_tx_regs->mode =
+				MP200_DMAC_DEFMODE_8BIT;
+		} else if (spi->config->nbw <= SPI_NB_16BIT) {
+			spi->trans->dma_tx_regs->mode =
+				MP200_DMAC_DEFMODE_16BIT;
+		} else {
+			spi->trans->dma_tx_regs->mode =
+				MP200_DMAC_DEFMODE_32BIT;
+		}
+		spi->trans->dma_tx_regs->aoff = 0;
+		spi->trans->dma_tx_regs->asize =
+			(size > SPI_DMA_BLOCK_MAXSIZE) ?
+			SPI_DMA_BLOCK_MAXSIZE : size;
+		spi->trans->dma_tx_regs->asize_count = 0;
+		spi->trans->dma_tx_regs->leng = size;
+		intmask = (MP200_DMAC_INT_ERROR_EN | MP200_DMAC_INT_LENG_EN);
+
+		DEB("addr=0x%08x mode=0x%08x asize=0x%08x leng=0x%08x "
+		    "intmask=0x%08x \n", spi->trans->buf.dma_addr,
+		    spi->trans->dma_tx_regs->mode,
+		    spi->trans->dma_tx_regs->asize,
+		    spi->trans->dma_tx_regs->leng, intmask);
+
+		ret = mp200_start_dma(spi->trans->tx_lch,
+				      spi->trans->buf.dma_addr, 0,
+				      spi->trans->tx_data, intmask);
+		if (ret < 0) {
+			DEB("dma error\n");
+			spi->trans->size = 0;
+			return ret;
+		}
+
+		if (spi->config->m_s == SPI_M_S_MASTER)
+			spi->regs->control2 |= SPx_CONTROL2_TX_STOP_MODE;
+		spi->regs->enset =
+			(SPx_ENSET_TX_ALLERR_EN | SPx_ENSET_TX_STOP_EN);
+		spi->regs->control = (SPx_CONTROL_WRT | SPx_CONTROL_START);
+	} else {
+		int i;
+		unsigned int unit;
+		char *buf;
+
+		unit = spi_unit(spi, spi->config->nbw);
+		for (i = 0; i < size; i += unit) {
+			buf = (char *)(spi->trans->buf.addr + i);
+			ret = spi_xferbytes(spi, buf, unit, SPI_WRITE);
+			if (ret < 0) {
+				spi_sft_reset(spi);
+				return ret;
+			}
+		}
+	}
+
+	return 0;
+}
+
+static irqreturn_t spi_interrupt(int irq, void *dev_id)
+{
+	struct spi_data *spi;
+	unsigned int status;
+
+	if (dev_id == NULL)
+		return IRQ_NONE;
+
+	spi = (struct spi_data *) dev_id;
+
+	status = spi->regs->status;
+	spi->regs->ffclr = status;
+
+	DEB("status = %08x\n", status);
+
+	/* error */
+	if ((status & SPx_STATUS_ALLERR) != 0) {
+		spi->trans->spi_err = (status & SPx_STATUS_ALLERR);
+		if ((status & (SPx_STATUS_TERR | SPx_STATUS_RX_OVR)) != 0)
+			spi_rx_stop(spi);
+		if ((status & SPx_STATUS_TX_UDR) != 0) {
+			/* slave */
+			if (spi->trans->dma_tx_regs->wcount == 0)
+				spi->trans->spi_err &= ~(SPx_STATUS_TX_UDR);
+			spi_tx_stop(spi);
+		}
+		if (waitqueue_active(&spi->trans->wait))
+			wake_up_interruptible(&spi->trans->wait);
+		return IRQ_HANDLED;
+	}
+
+	/* tx stop (dma master only) */
+	if ((status & SPx_STATUS_TX_STOP) != 0) {
+		if ((spi->trans->dma_tx_regs->wcount != 0) ||
+		    ((spi->regs->control & SPx_CONTROL_TX_EMP) == 0)) {
+			/* error */
+			spi->trans->spi_err |= SPx_STATUS_TX_STOP;
+		}
+		spi_tx_stop(spi);
+		if (waitqueue_active(&spi->trans->wait))
+			wake_up_interruptible(&spi->trans->wait);
+		return IRQ_HANDLED;
+	}
+
+	return IRQ_HANDLED;
+}
+
+static void spi_interrupt_dma_rx(void *data, int intsts, int intrawsts)
+{
+	struct spi_data *spi;
+
+	if (data == NULL)
+		return;
+
+	DEB("intsts = %08x\n", intsts);
+
+	spi = (struct spi_data *) data;
+
+	if (intsts & (MP200_DMAC_INT_ERROR_WR | MP200_DMAC_INT_ERROR_RD)) {
+		spi->trans->dma_err =
+			(intsts &
+			 (MP200_DMAC_INT_ERROR_WR | MP200_DMAC_INT_ERROR_RD));
+	} else if (intsts & MP200_DMAC_INT_LENG_WR) {
+		spi->trans->size =
+			mp200_get_dma_pos(spi->trans->rx_lch) -
+			spi->trans->buf.dma_addr;
+		DEB("size = %d\n", spi->trans->size);
+	} else {
+		return;
+	}
+
+	spi_rx_stop(spi);
+
+	if (waitqueue_active(&spi->trans->wait))
+		wake_up_interruptible(&spi->trans->wait);
+}
+
+static void spi_interrupt_dma_tx(void *data, int intsts, int intrawsts)
+{
+	struct spi_data *spi;
+
+	if (data == NULL)
+		return;
+
+	DEB("intsts = %08x\n", intsts);
+
+	spi = (struct spi_data *) data;
+
+	if (intsts & (MP200_DMAC_INT_ERROR_WR | MP200_DMAC_INT_ERROR_RD)) {
+		spi->trans->dma_err =
+			(intsts &
+			 (MP200_DMAC_INT_ERROR_WR | MP200_DMAC_INT_ERROR_RD));
+	} else if (intsts & MP200_DMAC_INT_LENG_WR) {
+		spi->trans->size =
+			mp200_get_dma_pos(spi->trans->tx_lch) -
+			spi->trans->buf.dma_addr;
+
+		DEB("size = %d\n", spi->trans->size);
+		return;
+	} else {
+		return;
+	}
+
+	spi_tx_stop(spi);
+
+	if (waitqueue_active(&spi->trans->wait))
+		wake_up_interruptible(&spi->trans->wait);
+}
+
+int spi_read(SPI_CONFIG *config, char *buf, unsigned long phys,
+	     unsigned int count, unsigned int flags)
+{
+	struct spi_data *spi;
+	unsigned int len = 0;
+	unsigned int unit;
+	int ret = 0;
+	unsigned long lock_flags = 0;
+
+	if ((config == NULL) ||
+	    ((buf == NULL) && (config->dma == SPI_DMA_OFF)) ||
+	    ((phys == 0) && (config->dma == SPI_DMA_ON))) {
+		return -EINVAL;
+	}
+
+	if (config->dev != SPI_DEV_SP0)
+		return -ENODEV;
+
+	spi = &spi_private[config->dev];
+
+	if (spi->probe == 0)
+		return -EPERM;
+
+	if (spi->excl) {
+		/* dma/slave is unsupported */
+		if (config->dma == SPI_DMA_ON
+		    || config->m_s == SPI_M_S_SLAVE) {
+			return -EINVAL;
+		}
+		spin_lock_irqsave(&spi->trans->spinlock, lock_flags);
+	} else {
+		/* cpu slave is unsupported */
+		if (config->dma == SPI_DMA_OFF
+		    && config->m_s == SPI_M_S_SLAVE) {
+			return -EINVAL;
+		}
+		if ((flags & SPI_NONBLOCK) != 0) {
+			if (down_trylock(&spi->sem) != 0)
+				return -EAGAIN;
+		} else {
+			if (down_interruptible(&spi->sem) != 0)
+				return -ERESTARTSYS;
+		}
+	}
+	spi->trans->state = SPI_READ;
+	ret = spi_config(spi, config);
+	if (ret < 0)
+		goto out;
+
+	unit = spi_unit(spi, config->nbr);
+	count = (count / unit) * unit;
+
+	DEB("count = %d\n", count);
+
+	if (spi->config->dma == SPI_DMA_OFF) {
+		spi->trans->buf.addr = (unsigned int)buf;
+		ret = spi_rx_start(spi, count);
+		if (ret == 0)
+			ret = count;
+	} else {
+		DECLARE_WAITQUEUE(wait, current);
+		unsigned int spi_err;
+		unsigned int dma_err;
+		int size;
+
+		spi->trans->size = 0;
+
+		add_wait_queue(&spi->trans->wait, &wait);
+		while ((count - len) > 0) {
+			set_current_state(TASK_INTERRUPTIBLE);
+			spin_lock_irq(&spi->trans->spinlock);
+			spi_err = spi->trans->spi_err;
+			dma_err = spi->trans->dma_err;
+			size = spi->trans->size;
+			spi->trans->size = 0;
+			spin_unlock_irq(&spi->trans->spinlock);
+			if ((spi_err != 0) || (dma_err != 0)) {
+				spi_init_data(spi);
+				ret = -EIO;
+				break;
+			}
+
+			if (size > 0) {
+				if ((count - len) < size)
+					size = count - len;
+				len = len + size;
+				ret = len;
+			} else {
+				if ((count - len) > SPI_DMA_MAXSIZE)
+					size = SPI_DMA_MAXSIZE;
+				else
+					size = count - len;
+
+				spi->trans->buf.dma_addr = phys + len;
+				ret = spi_rx_start(spi, size);
+				if (ret < 0)
+					break;
+
+				if (signal_pending(current)) {
+					spi_rx_stop(spi);
+					ret = -ERESTARTSYS;
+					break;
+				}
+				schedule();
+			}
+		}
+		remove_wait_queue(&spi->trans->wait, &wait);
+		set_current_state(TASK_RUNNING);
+	}
+
+	spi_config_release(spi);
+
+out:
+	spi->trans->state = SPI_UNUSED;
+
+	if (spi->excl)
+		spin_unlock_irqrestore(&spi->trans->spinlock, lock_flags);
+	else
+		up(&spi->sem);
+
+	return ret;
+}
+EXPORT_SYMBOL(spi_read);
+
+int spi_write(SPI_CONFIG *config, char *buf, unsigned long phys,
+	      unsigned int count, unsigned int flags)
+{
+	struct spi_data *spi;
+	unsigned int len = 0;
+	unsigned int unit;
+	int ret = 0;
+	unsigned long lock_flags = 0;
+
+	if ((config == NULL) ||
+	    ((buf == NULL) && (config->dma == SPI_DMA_OFF)) ||
+	    ((phys == 0) && (config->dma == SPI_DMA_ON))) {
+		return -EINVAL;
+	}
+
+	if (config->dev != SPI_DEV_SP0)
+		return -ENODEV;
+
+	spi = &spi_private[config->dev];
+
+	if (spi->probe == 0)
+		return -EPERM;
+
+	if (spi->excl) {
+		/* dma/slave is unsupported */
+		if (config->dma == SPI_DMA_ON
+		    || config->m_s == SPI_M_S_SLAVE) {
+			return -EINVAL;
+		}
+
+		spin_lock_irqsave(&spi->trans->spinlock, lock_flags);
+	} else {
+		/* cpu slave is unsupported */
+		if (config->dma == SPI_DMA_OFF
+		    && config->m_s == SPI_M_S_SLAVE) {
+			return -EINVAL;
+		}
+		if ((flags & SPI_NONBLOCK) != 0) {
+			if (down_trylock(&spi->sem) != 0)
+				return -EAGAIN;
+		} else {
+			if (down_interruptible(&spi->sem) != 0)
+				return -ERESTARTSYS;
+		}
+	}
+
+	spi->trans->state = SPI_WRITE;
+
+	ret = spi_config(spi, config);
+	if (ret < 0)
+		goto out;
+
+	unit = spi_unit(spi, config->nbw);
+	count = (count / unit) * unit;
+
+	DEB("count = %d\n", count);
+
+	spi->trans->size = 0;
+
+	if (spi->config->dma == SPI_DMA_OFF) {
+		spi->trans->buf.addr = (unsigned int)buf;
+		ret = spi_tx_start(spi, count);
+		if (ret == 0)
+			ret = count;
+	} else {
+		DECLARE_WAITQUEUE(wait, current);
+		unsigned int spi_err;
+		unsigned int dma_err;
+		int size;
+
+		add_wait_queue(&spi->trans->wait, &wait);
+		while ((count - len) > 0) {
+			set_current_state(TASK_INTERRUPTIBLE);
+			spin_lock_irq(&spi->trans->spinlock);
+			spi_err = spi->trans->spi_err;
+			dma_err = spi->trans->dma_err;
+			size = spi->trans->size;
+			spi->trans->size = 0;
+			spin_unlock_irq(&spi->trans->spinlock);
+			if ((spi_err != 0) || (dma_err != 0)) {
+				spi_init_data(spi);
+				ret = -EIO;
+				break;
+			}
+
+			if (size > 0) {
+				if ((count - len) < size)
+					size = count - len;
+				len = len + size;
+				ret = len;
+			} else {
+				if ((count - len) > SPI_DMA_MAXSIZE)
+					size = SPI_DMA_MAXSIZE;
+				else
+					size = count - len;
+
+				spi->trans->buf.dma_addr = phys + len;
+				ret = spi_tx_start(spi, size);
+				if (ret < 0)
+					break;
+
+				if (signal_pending(current)) {
+					spi_tx_stop(spi);
+					ret = -ERESTARTSYS;
+					break;
+				}
+				schedule();
+			}
+		}
+		remove_wait_queue(&spi->trans->wait, &wait);
+		set_current_state(TASK_RUNNING);
+	}
+	spi_config_release(spi);
+	spi->trans->state = SPI_UNUSED;
+
+out:
+	if (spi->excl)
+		spin_unlock_irqrestore(&spi->trans->spinlock, lock_flags);
+	else
+		up(&spi->sem);
+
+	return ret;
+}
+EXPORT_SYMBOL(spi_write);
+
+int spi_cmd_read(SPI_CONFIG *config, char *cmd, char *buf, unsigned int flags)
+{
+	struct spi_data *spi;
+	unsigned int unit;
+	unsigned int data = 0;
+	unsigned long lock_flags = 0;
+	int ret = 0;
+
+	if ((config == NULL) || (cmd == NULL) || (buf == NULL))
+		return -EINVAL;
+
+	if (config->dev != SPI_DEV_SP0)
+		return -ENODEV;
+
+	spi = &spi_private[config->dev];
+
+	if (spi->probe == 0)
+		return -EPERM;
+
+	DEB("cmd = %08x\n", *(unsigned int *)cmd);
+
+	/* dma/slave is unsupported */
+	if (config->dma == SPI_DMA_ON || config->m_s == SPI_M_S_SLAVE)
+		return -EINVAL;
+
+	if (spi->excl) {
+		spin_lock_irqsave(&spi->trans->spinlock, lock_flags);
+	} else {
+		if ((flags & SPI_NONBLOCK) != 0) {
+			if (down_trylock(&spi->sem) != 0)
+				return -EAGAIN;
+		} else {
+			if (down_interruptible(&spi->sem) != 0)
+				return -ERESTARTSYS;
+		}
+
+	}
+
+	while (1) {
+		if ((flags & SPI_RW_2CYCLE) != 0) {
+			spi->trans->state = SPI_WRITE;
+			ret = spi_config(spi, config);
+			if (ret < 0)
+				break;
+			unit = spi_unit(spi, spi->config->nbw);
+			ret = spi_xferbytes(spi, cmd, unit, SPI_WRITE);
+			if (ret < 0)
+				break;
+
+			spi->trans->state = SPI_READ;
+			ret = spi_config(spi, config);
+			if (ret < 0)
+				break;
+			unit = spi_unit(spi, spi->config->nbr);
+			ret = spi_xferbytes(spi, buf, unit, SPI_READ);
+			if (ret < 0)
+				break;
+		} else {
+			spi->trans->state = SPI_RW;
+			ret = spi_config(spi, config);
+			if (ret < 0)
+				break;
+			memcpy((char *)&data, cmd,
+					spi_unit(spi, spi->config->nbw));
+			data = (data << spi->config->nbr);
+			unit = spi_unit(spi,
+					spi->config->nbr + spi->config->nbw);
+			ret = spi_xferbytes(spi, (char *)&data, unit, SPI_RW);
+			if (ret < 0)
+				break;
+			memcpy(buf, (char *)&data,
+					spi_unit(spi, spi->config->nbr));
+		}
+		break;
+	}
+
+	if (ret < 0)
+		spi_sft_reset(spi);
+
+	spi_config_release(spi);
+	spi->trans->state = SPI_UNUSED;
+
+	if (spi->excl)
+		spin_unlock_irqrestore(&spi->trans->spinlock, lock_flags);
+	else
+		up(&spi->sem);
+
+	return ret;
+}
+EXPORT_SYMBOL(spi_cmd_read);
+
+static int spi_probe(struct platform_device *dev)
+{
+	struct spi_data *spi;
+	int ret;
+
+	if (dev->id != SPI_DEV_SP0)
+		return -ENODEV;
+	spi = &spi_private[dev->id];
+
+	if (spi->probe == 0) {
+		spi_power_on(spi);
+		ret = spi_request_dma(spi);
+		if (ret < 0) {
+			spi_power_off(spi);
+			return ret;
+		}
+
+		ret =
+			request_irq(spi->trans->int_spi, spi_interrupt,
+				    IRQF_DISABLED, SPI_NAME, (void *)spi);
+		if (ret < 0) {
+			spi_free_dma(spi);
+			spi_power_off(spi);
+			return ret;
+		}
+
+		ret = spi_config(spi, spi->config);
+		if (ret < 0) {
+			free_irq(spi->trans->int_spi, (void *)spi);
+			spi_free_dma(spi);
+			spi_power_off(spi);
+			return ret;
+		}
+
+		init_waitqueue_head(&spi->trans->wait);
+		sema_init(&spi->sem, 1);
+		spi_init_data(spi);
+
+		spi->excl = sp0_excl;
+
+		spi->probe = 1;
+	}
+
+	return 0;
+}
+
+static int spi_remove(struct platform_device *dev)
+{
+	struct spi_data *spi;
+
+	if (dev->id != SPI_DEV_SP0)
+		return -ENODEV;
+	spi = &spi_private[dev->id];
+
+	if (spi->probe != 0) {
+		spi->probe = 0;
+		free_irq(spi->trans->int_spi, (void *)spi);
+		spi_free_dma(spi);
+		spi_power_off(spi);
+	}
+
+	return 0;
+}
+
+static int spi_suspend(struct platform_device *dev, pm_message_t state)
+{
+	struct spi_data *spi;
+
+	switch (state.event) {
+	case DEV_SUSPEND_IDLE_1:
+	case PM_EVENT_SUSPEND:
+		if (dev->id != SPI_DEV_SP0)
+			return -ENODEV;
+		spi = &spi_private[dev->id];
+		if (spi->trans->state != SPI_UNUSED)
+			return -EBUSY;
+		break;
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+static int spi_resume(struct platform_device *dev)
+{
+	return 0;
+}
+
+static struct platform_driver spi_drv = {
+	.driver = {
+		.name = SPI_NAME,
+		.owner = THIS_MODULE,
+	},
+	.probe = spi_probe,
+	.remove = spi_remove,
+	.suspend = spi_suspend,
+	.resume = spi_resume,
+};
+
+static int __init spi_init(void)
+{
+	printk(KERN_INFO "Starting %s.\n", SPI_NAME);
+
+	return platform_driver_register(&spi_drv);
+}
+
+static void __exit spi_exit(void)
+{
+	platform_driver_unregister(&spi_drv);
+
+}
+
+module_init(spi_init);
+module_exit(spi_exit);
+MODULE_LICENSE("GPL");
diff --git a/drivers/char/mp200_spi0.h b/drivers/char/mp200_spi0.h
new file mode 100644
index 0000000..3950df4
--- /dev/null
+++ b/drivers/char/mp200_spi0.h
@@ -0,0 +1,228 @@
+/*
+ *  File Name	    : linux/drivers/char/mp200_spi0.h
+ *  Function	    : MP200 SPI0 interface
+ *  Release Version : Ver 1.00
+ *  Release Date    : 2006/07/09
+ *
+ *  Copyright (C) NEC Electronics Corporation 2005-2006
+ *
+ *
+ *  This program is free software;you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License as published by Free
+ *  Softwere Foundation; either version 2 of License, or (at your option) any
+ *  later version.
+ *
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warrnty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; If not, write to the Free Software Foundation, Inc., 59
+ *  Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#ifndef __DRIVERS_CHAR_MP200_SPI_H
+#define __DRIVERS_CHAR_MP200_SPI_H
+
+#include <mach/spi.h>
+
+/*
+ * SPI register
+ */
+#define SP0_ADDR  IO_ADDRESS(MP200_SP0_BASE)
+
+#define SPx_TX_DATA_PHYS(ADDR)          ((ADDR) + 0x00000010)
+#define SPx_RX_DATA_PHYS(ADDR)          ((ADDR) + 0x00000014)
+
+#define SPx_CONTROL_TX_EMP              (0x01 << 15)
+#define SPx_CONTROL_RX_FULL             (0x01 << 14)
+#define SPx_CONTROL_RST                 (0x01 << 8)
+#define SPx_CONTROL_TX_FULL             (0x01 << 7)
+#define SPx_CONTROL_RX_EMP              (0x01 << 6)
+#define SPx_CONTROL_WRT                 (0x01 << 3)
+#define SPx_CONTROL_RD                  (0x01 << 2)
+#define SPx_CONTROL_STOP                (0x01 << 1)
+#define SPx_CONTROL_START               (0x01 << 0)
+
+#define SPx_STATUS_TX_STOP              (0x01 << 6)
+#define SPx_STATUS_RX_STOP              (0x01 << 5)
+#define SPx_STATUS_TERR                 (0x01 << 4)
+#define SPx_STATUS_RDV                  (0x01 << 3)
+#define SPx_STATUS_END                  (0x01 << 2)
+#define SPx_STATUS_TX_UDR               (0x01 << 1)
+#define SPx_STATUS_RX_OVR               (0x01 << 0)
+#define SPx_STATUS_TX_ALLERR            (SPx_STATUS_TX_UDR)
+#define SPx_STATUS_RX_ALLERR            (SPx_STATUS_TERR \
+					 | SPx_STATUS_RX_OVR)
+#define SPx_STATUS_ALLERR               (SPx_STATUS_TX_ALLERR \
+					 | SPx_STATUS_RX_ALLERR)
+
+#define SPx_RAW_STATUS_TX_STOP_RAW      (0x01 << 6)
+#define SPx_RAW_STATUS_RX_STOP_RAW      (0x01 << 5)
+#define SPx_RAW_STATUS_TERR_RAW         (0x01 << 4)
+#define SPx_RAW_STATUS_RDV_RAW          (0x01 << 3)
+#define SPx_RAW_STATUS_END_RAW          (0x01 << 2)
+#define SPx_RAW_STATUS_TX_UDR_RAW       (0x01 << 1)
+#define SPx_RAW_STATUS_RX_OVR_RAW       (0x01 << 0)
+#define SPx_RAW_STATUS_TX_ALLERR_RAW    (SPx_RAW_STATUS_TX_UDR_RAW)
+#define SPx_RAW_STATUS_RX_ALLERR_RAW    (SPx_RAW_STATUS_TERR_RAW \
+					 | SPx_RAW_STATUS_RX_OVR_RAW)
+#define SPx_RAW_STATUS_ALLERR_RAW       (SPx_RAW_STATUS_TX_ALLERR_RAW \
+					 | SPx_RAW_STATUS_RX_ALLERR_RAW)
+
+#define SPx_ENSET_TX_STOP_EN            (0x01 << 6)
+#define SPx_ENSET_RX_STOP_EN            (0x01 << 5)
+#define SPx_ENSET_TERR_EN               (0x01 << 4)
+#define SPx_ENSET_RDV_EN                (0x01 << 3)
+#define SPx_ENSET_END_EN                (0x01 << 2)
+#define SPx_ENSET_TX_UDR_EN             (0x01 << 1)
+#define SPx_ENSET_RX_OVR_EN             (0x01 << 0)
+#define SPx_ENSET_TX_ALLERR_EN          (SPx_ENSET_TX_UDR_EN)
+#define SPx_ENSET_RX_ALLERR_EN          (SPx_ENSET_TERR_EN \
+					 | SPx_ENSET_RX_OVR_EN)
+
+#define SPx_ENCLR_TX_STOP_MASK          (0x01 << 6)
+#define SPx_ENCLR_RX_STOP_MASK          (0x01 << 5)
+#define SPx_ENCLR_TERR_MASK             (0x01 << 4)
+#define SPx_ENCLR_RDV_MASK              (0x01 << 3)
+#define SPx_ENCLR_END_MASK              (0x01 << 2)
+#define SPx_ENCLR_TX_UDR_MASK           (0x01 << 1)
+#define SPx_ENCLR_RX_OVR_MASK           (0x01 << 0)
+#define SPx_ENCLR_TX_ALLERR_MASK        (SPx_ENCLR_TX_UDR_MASK)
+#define SPx_ENCLR_RX_ALLERR_MASK        (SPx_ENCLR_TERR_MASK \
+					 | SPx_ENCLR_RX_OVR_MASK)
+#define SPx_ENCLR_TX_ALL_MASK           (SPx_ENCLR_TX_STOP_MASK	\
+					 | SPx_ENCLR_END_MASK	\
+					 | SPx_ENCLR_TX_ALLERR_MASK)
+#define SPx_ENCLR_RX_ALL_MASK           (SPx_ENCLR_RX_STOP_MASK	\
+					 | SPx_ENCLR_RDV_MASK	\
+					 | SPx_ENCLR_RX_ALLERR_MASK)
+
+#define SPx_FFCLR_TX_STOP_CLR           (0x01 << 6)
+#define SPx_FFCLR_RX_STOP_CLR           (0x01 << 5)
+#define SPx_FFCLR_TERR_CLR              (0x01 << 4)
+#define SPx_FFCLR_RDV_CLR               (0x01 << 3)
+#define SPx_FFCLR_END_CLR               (0x01 << 2)
+#define SPx_FFCLR_TX_UDR_CLR            (0x01 << 1)
+#define SPx_FFCLR_RX_OVR_CLR            (0x01 << 0)
+#define SPx_FFCLR_ALL_CLR               (SPx_FFCLR_TX_STOP_CLR	 \
+					 | SPx_FFCLR_RX_STOP_CLR \
+					 | SPx_FFCLR_TERR_CLR	 \
+					 | SPx_FFCLR_RDV_CLR	 \
+					 | SPx_FFCLR_END_CLR	 \
+					 | SPx_FFCLR_TX_UDR_CLR	 \
+					 | SPx_FFCLR_RX_OVR_CLR)
+
+#define SPx_CONTROL2_TX_STOP_MODE       (0x01 << 9)
+#define SPx_CONTROL2_RX_STOP_MODE       (0x01 << 8)
+
+#define SPx_CONTROL2_RX_FIFO_FULL_MASK  ((0xFF << 16) | (0xFF << 0))
+
+
+/*
+ * device info
+ */
+#define SPI_NAME                        "spi0"
+
+/*
+ * transfer status
+ */
+#define SPI_UNUSED                      0
+#define SPI_READ                        1
+#define SPI_WRITE                       2
+#define SPI_RW                          (SPI_READ | SPI_WRITE)
+
+/*
+ * other define
+ */
+#define SPI_DMA_MAXSIZE                 0x00FFFFFC
+#define SPI_DMA_BLOCK_MAXSIZE           0x0000FFFC
+
+#define SPI_CSW_MASK                    0x0000F000      /* csw */
+#define SPI_POL_MASK                    0x00000007      /* pol */
+
+#define SPI_POL_SP0	\
+	(((SPI_POL_SP0_CS5 & SPI_POL_MASK) << 19) |	   \
+	((SPI_POL_SP0_CS4 & SPI_POL_MASK) << 16) | \
+	((SPI_POL_SP0_CS3 & SPI_POL_MASK) << 9)  | \
+	((SPI_POL_SP0_CS2 & SPI_POL_MASK) << 6)  | \
+	((SPI_POL_SP0_CS1 & SPI_POL_MASK) << 3)  | \
+	(SPI_POL_SP0_CS0))
+/*
+ * spi register info
+ */
+struct spi_regs {
+	volatile unsigned int mode;             /* SPx_MODE       (0x00) */
+	volatile unsigned int pol;              /* SPx_POL        (0x04) */
+	volatile unsigned int control;          /* SPx_CONTROL    (0x08) */
+	unsigned int:32;                       /* reserved       (0x0c) */
+	volatile unsigned int tx_data;          /* SPx_TX_DATA    (0x10) */
+	volatile unsigned int rx_data;          /* SPx_RX_DATA    (0x14) */
+	volatile unsigned int status;           /* SPx_STATUS     (0x18) */
+	volatile unsigned int raw_status;       /* SPx_RAW_STATUS (0x1c) */
+	volatile unsigned int enset;            /* SPx_ENSET      (0x20) */
+	volatile unsigned int enclr;            /* SPx_ENCLR      (0x24) */
+	volatile unsigned int ffclr;            /* SPx_FFCLR      (0x28) */
+	unsigned int:32;                       /* reserved       (0x2c) */
+	unsigned int:32;                       /* reserved       (0x30) */
+	volatile unsigned int control2;         /* SPx_CONTROL2   (0x34) */
+	volatile unsigned int tiecs;            /* SPx_TIECS      (0x38) */
+};
+
+/*
+ * buffer info
+ */
+struct spi_buf {
+	dma_addr_t dma_addr;    /* physics address */
+	unsigned int addr;      /* virtual address */
+};
+
+/*
+ * transfer info
+ */
+struct spi_trans {
+	dma_regs_t *dma_rx_regs;        /* dma rx register */
+	dma_regs_t *dma_tx_regs;        /* dma tx register */
+	int const rx_lch;               /* dma rx channel no */
+	int const tx_lch;               /* dma tx channel no */
+	unsigned int const rx_data;     /* rx data transfer address (physics) */
+	unsigned int const tx_data;     /* tx data transfer address (physics) */
+	unsigned int int_spi;           /* int spi no */
+	unsigned int dma_err;           /* dma error status */
+	unsigned int spi_err;           /* spi error status */
+	unsigned int size;              /* transfer size */
+	unsigned int state;             /* transfer status */
+	wait_queue_head_t wait;         /* wait queue */
+	spinlock_t spinlock;            /* spin lock */
+	struct spi_buf buf;             /* buffer info */
+};
+
+/*
+ * smu info
+ */
+struct spi_smu {
+	unsigned int pclk;      /* pclk */
+	unsigned int sclk;      /* sclk */
+	unsigned int pclk_ctrl; /* pclk ctrl */
+	unsigned int sclk_ctrl; /* sclk ctrl */
+	unsigned int reset;     /* reset */
+	unsigned int sclk_div;  /* SPIx_SCLK_DIV */
+};
+
+/*
+ * spi data info
+ */
+struct spi_data {
+	struct spi_regs *regs;          /* spi register info */
+	struct spi_trans *trans;        /* transfer info */
+	SPI_CONFIG *config;             /* spi config info */
+	struct spi_smu *smu;            /* smu info */
+	struct semaphore sem;           /* semaphore */
+	unsigned int probe;             /* probe */
+	unsigned int excl;              /* exclusive control method */
+	unsigned int pol;               /* pol */
+};
+
+#endif                          /* __DRIVERS_CHAR_MP200_SPI_H */
diff --git a/drivers/char/mp200_spi_kern.c b/drivers/char/mp200_spi_kern.c
new file mode 100644
index 0000000..adac678
--- /dev/null
+++ b/drivers/char/mp200_spi_kern.c
@@ -0,0 +1,322 @@
+/*
+ *  File Name       : linux/drivers/char/mp200_spi_kern.c
+ *  Function        : MP200 SPI interface
+ *  Release Version : Ver 0.01
+ *  Release Date    : 2006/06/02
+ *
+ *  Copyright (C) NEC Electronics Corporation 2005-2006
+ *
+ *
+ *  This program is free software;you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License as published by Free
+ *  Softwere Foundation; either version 2 of License, or (at your option) any
+ *  later version.
+ *
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warrnty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; If not, write to the Free Software Foundation, Inc., 59
+ *  Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+
+#include <linux/io.h>
+#include <mach/smu.h>
+#include <mach/pmu.h>
+
+#define SPI_DEBUG_PARAM
+
+#include "mp200_spi_kern.h"
+
+#ifdef SPI_DEBUG
+#define DPRINTK(fmt, args...) printk(KERN_INFO "\n  %s: %s: " fmt, \
+		__FILE__, __func__, ## args)
+#else
+#define DPRINTK(fmt, args...)
+#endif
+
+#define RETRY_COUNT(x)  ((loops_per_jiffy * x) / (1000000 / HZ)) /* x us */
+
+static unsigned int spi_clock_table[] = {
+	1433,           /* (1434KHz) */
+	2867,           /* (2.87MHz) */
+	5734,           /* (5.73MHz) */
+	11468,          /* (11.47MHz) */
+	22937,          /* (22.94MHz) */
+	38229,          /* (38.23MHz) */
+};
+
+static unsigned int spi_plldiv_table[] = {
+	SMU_DIV160,     /* 1500KHz(1434KHz) */
+	SMU_DIV80,      /* 3MHz   (2.87MHz) */
+	SMU_DIV40,      /* 6MHz   (5.73MHz) */
+	SMU_DIV20,      /* 12MHz  (11.47MHz) */
+	SMU_DIV10,      /* 24MHz  (22.94MHz) */
+	SMU_DIV6,       /* 48MHz  (38.23MHz) */
+};
+
+static spi_data_t spi_private[] = {
+	{
+		.regs = (spi_regs *)(SP0_ADDR),
+		.pol  = SPI_POL_VAL_SPI0,
+		.div_sclk = SMU_DIVSP0SCLK,
+		.lock = __SPIN_LOCK_UNLOCKED(spi_private.lock),
+	},
+	{
+		.regs = (spi_regs *)(SP1_ADDR),
+		.pol  = SPI_POL_VAL_SPI1,
+		.div_sclk = SMU_DIVSP1SCLK,
+		.lock = __SPIN_LOCK_UNLOCKED(spi_private.lock),
+	},
+	{
+		.regs = (spi_regs *)(SP2_ADDR),
+		.pol  = SPI_POL_VAL_SPI2,
+		.div_sclk = SMU_DIVSP2SCLK,
+		.lock = __SPIN_LOCK_UNLOCKED(spi_private.lock),
+	},
+};
+
+static int spi_set_sclk_div(spi_data_t *spi, unsigned int sclk)
+{
+	switch (sclk) {
+	case SPI_SCLK_1500KHZ:
+	case SPI_SCLK_3MHZ:
+	case SPI_SCLK_6MHZ:
+	case SPI_SCLK_12MHZ:
+	case SPI_SCLK_24MHZ:
+	case SPI_SCLK_48MHZ:
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	outl(spi_plldiv_table[sclk], spi->div_sclk);
+
+	return 0;
+}
+
+static inline int send_data(spi_regs *spi, unsigned int data, unsigned int cnt)
+{
+	spi->tx_data = data;
+	spi->control = (SPx_CONTROL_WRT | SPx_CONTROL_START);
+	while ((spi->control & SPx_CONTROL_START) && (--cnt > 0))
+		;
+	if (cnt == 0) {
+		DPRINTK(" timeout! \n");
+		return -1; /* timeout */
+	}
+	return 0;
+}
+
+int
+spi_write_without_intr(const SPI_CONFIG *config, const char *buf, int rst_flag)
+{
+	spi_data_t *s;
+	unsigned long flag;
+	unsigned int count, time, nb = 0;
+	int i, ret = 0;
+
+	if (config == 0)
+		return -EINVAL;
+
+#ifdef SPI_DEBUG_PARAM
+	/* dev check*/
+	if (DEVNO_IS_INVALID(config->dev))
+		return -EINVAL;
+#endif
+
+	s = &spi_private[config->dev];
+	nb = ((config->mode & SPx_MODE_NB_MASK) >> 8) + 1;
+
+#ifdef SPI_DEBUG_PARAM
+	/* m_s check */
+	if (config->mode & SPx_MODE_M_S_MASK) { /* slave */
+		return -EINVAL;
+	}
+
+	/* dma check */
+	if (config->mode & SPx_MODE_DMA_MASK) { /* dma on */
+		return -EINVAL;
+	}
+
+	/* nb check */
+	if ((nb < SPI_NB_8BIT) || (nb > SPI_NB_32BIT))
+		return -EINVAL;
+
+	/* sclk check */
+	switch (config->sclk) {
+	case SPI_SCLK_1500KHZ:
+	case SPI_SCLK_3MHZ:
+	case SPI_SCLK_6MHZ:
+	case SPI_SCLK_12MHZ:
+	case SPI_SCLK_24MHZ:
+	case SPI_SCLK_48MHZ:
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	/* reset flag check */
+	if ((rst_flag != SPI_RESET_OFF) && (rst_flag != SPI_RESET_ON))
+		return -EINVAL;
+#endif
+
+	count = config->size;
+	time = RETRY_COUNT(
+		(((100000 / spi_clock_table[config->sclk]) * nb) / 10) + 1);
+
+	spin_lock_irqsave(&s->lock, flag); /* lock */
+	spi_set_sclk_div(s, config->sclk);
+	/* clear */
+	s->regs->ffclr = SPx_FFCLR_ALL_CLR;
+	s->regs->enclr = SPx_ENCLR_ALL_MASK;
+	/* parameters */
+	s->regs->mode   = config->mode;
+	s->regs->pol    = config->pol;
+
+	/* spi soft reset */
+	if (rst_flag == SPI_RESET_ON) { /* reset on */
+		s->regs->control |= SPx_CONTROL_RST;
+		udelay((1000 * 4 / spi_clock_table[config->sclk]) + 1);
+		s->regs->control &= ~SPx_CONTROL_RST;
+	}
+	if (buf == 0)
+		goto out;
+
+	/* send */
+	if (nb > (SPI_NB_8BIT + SPI_NB_16BIT)) { /* 25~32 */
+		unsigned int *data = (unsigned int *)buf;
+		count = count / 4;
+		for (i = 0; i < count; i++) {
+			if (send_data(s->regs, data[i], time)) {
+				ret = -EBUSY;
+				goto out;
+			}
+		}
+	} else if (nb > SPI_NB_16BIT)   { /* 17~24*/
+		unsigned char *data = (unsigned char *)buf;
+		count = (count / 3) * 3;
+		for (i = 0; i < count; i += 3) {
+			if (send_data(s->regs,
+				      ((data[i] << 16) |
+				       (data[i + 1] << 8) |
+				       (data[i + 2])), time)) {
+				ret = -EBUSY;
+				goto out;
+			}
+		}
+	} else if ((nb > SPI_NB_8BIT) && (nb <= SPI_NB_16BIT))   { /* 9~16*/
+		unsigned short *data = (unsigned short *)buf;
+		count = count / 2;
+		for (i = 0; i < count; i++) {
+			if (send_data(s->regs, data[i], time)) {
+				ret = -EBUSY;
+				goto out;
+			}
+		}
+	} else if (nb == SPI_NB_8BIT)   { /* 8 */
+		unsigned char *data = (unsigned char *)buf;
+		for (i = 0; i < count; i++) {
+			if (send_data(s->regs, data[i], time)) {
+				ret = -EBUSY;
+				goto out;
+			}
+		}
+	}
+out:
+	/* end */
+	spin_unlock_irqrestore(&s->lock, flag); /* unlock */
+
+	return ret;
+}
+EXPORT_SYMBOL(spi_write_without_intr);
+
+static int __init spi_init(void)
+{
+	spi_data_t *s0;
+	spi_data_t *s1;
+	spi_data_t *s2;
+
+	printk(KERN_INFO "Starting %s.\n", SPI_NAME);
+
+	mp200_pmu_clkctrl_off(MP200_CLKCTRL_SP0SCLK);
+	mp200_pmu_clkctrl_off(MP200_CLKCTRL_SP1SCLK);
+	mp200_pmu_clkctrl_off(MP200_CLKCTRL_SP2SCLK);
+	mp200_pmu_clkctrl_off(MP200_CLKCTRL_SP0PCLK);
+	mp200_pmu_clkctrl_off(MP200_CLKCTRL_SP1PCLK);
+	mp200_pmu_clkctrl_off(MP200_CLKCTRL_SP2PCLK);
+	mp200_pmu_open_clockgate(MP200_CLOCKGATE_SP0_PCLK);
+	mp200_pmu_open_clockgate(MP200_CLOCKGATE_SP1_PCLK);
+	mp200_pmu_open_clockgate(MP200_CLOCKGATE_SP2_PCLK);
+	mp200_pmu_open_clockgate(MP200_CLOCKGATE_SP0_SCLK);
+	mp200_pmu_open_clockgate(MP200_CLOCKGATE_SP1_SCLK);
+	mp200_pmu_open_clockgate(MP200_CLOCKGATE_SP2_SCLK);
+	mp200_pmu_unreset_device(MP200_RESETDEVICE_SP0);
+	mp200_pmu_unreset_device(MP200_RESETDEVICE_SP1);
+	mp200_pmu_unreset_device(MP200_RESETDEVICE_SP2);
+	mp200_pmu_clkctrl_on(MP200_CLKCTRL_SP0PCLK);
+	mp200_pmu_clkctrl_on(MP200_CLKCTRL_SP1PCLK);
+	mp200_pmu_clkctrl_on(MP200_CLKCTRL_SP2PCLK);
+	mp200_pmu_clkctrl_on(MP200_CLKCTRL_SP0SCLK);
+	mp200_pmu_clkctrl_on(MP200_CLKCTRL_SP1SCLK);
+	mp200_pmu_clkctrl_on(MP200_CLKCTRL_SP2SCLK);
+
+	s0 = &spi_private[SPI_DEV_SPI0];
+	/* POL setting */
+	s0->regs->pol = s0->pol;
+
+	s1 = &spi_private[SPI_DEV_SPI1];
+	/* POL setting */
+	s1->regs->pol = s1->pol;
+
+	s2 = &spi_private[SPI_DEV_SPI2];
+	/* POL setting */
+	s2->regs->pol = s2->pol;
+
+	/* software reset */
+	s0->regs->control |= SPx_CONTROL_RST;
+	s1->regs->control |= SPx_CONTROL_RST;
+	s2->regs->control |= SPx_CONTROL_RST;
+	udelay(5);
+	s0->regs->control &= ~SPx_CONTROL_RST;
+	s1->regs->control &= ~SPx_CONTROL_RST;
+	s2->regs->control &= ~SPx_CONTROL_RST;
+
+	return 0;
+}
+
+/*
+ * exit
+ */
+static void __exit spi_exit(void)
+{
+
+	mp200_pmu_clkctrl_off(MP200_CLKCTRL_SP0SCLK);
+	mp200_pmu_clkctrl_off(MP200_CLKCTRL_SP1SCLK);
+	mp200_pmu_clkctrl_off(MP200_CLKCTRL_SP2SCLK);
+	mp200_pmu_clkctrl_off(MP200_CLKCTRL_SP0PCLK);
+	mp200_pmu_clkctrl_off(MP200_CLKCTRL_SP1PCLK);
+	mp200_pmu_clkctrl_off(MP200_CLKCTRL_SP2PCLK);
+	mp200_pmu_reset_device(MP200_RESETDEVICE_SP0);
+	mp200_pmu_reset_device(MP200_RESETDEVICE_SP1);
+	mp200_pmu_reset_device(MP200_RESETDEVICE_SP2);
+	mp200_pmu_close_clockgate(MP200_CLOCKGATE_SP0_SCLK);
+	mp200_pmu_close_clockgate(MP200_CLOCKGATE_SP1_SCLK);
+	mp200_pmu_close_clockgate(MP200_CLOCKGATE_SP2_SCLK);
+	mp200_pmu_close_clockgate(MP200_CLOCKGATE_SP0_PCLK);
+	mp200_pmu_close_clockgate(MP200_CLOCKGATE_SP1_PCLK);
+	mp200_pmu_close_clockgate(MP200_CLOCKGATE_SP2_PCLK);
+
+	return;
+}
+
+module_init(spi_init);
+module_exit(spi_exit);
+MODULE_LICENSE("GPL");
diff --git a/drivers/char/mp200_spi_kern.h b/drivers/char/mp200_spi_kern.h
new file mode 100644
index 0000000..eb4d973
--- /dev/null
+++ b/drivers/char/mp200_spi_kern.h
@@ -0,0 +1,169 @@
+/*
+ *  File Name       : linux/drivers/char/mp200_spi_kern.h
+ *  Function        : MP200 SPI interface
+ *  Release Version : Ver 0.01
+ *  Release Date    : 2006/06/02
+ *
+ *  Copyright (C) NEC Electronics Corporation 2005-2006
+ *
+ *
+ *  This program is free software;you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License as published by Free
+ *  Softwere Foundation; either version 2 of License, or (at your option) any
+ *  later version.
+ *
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warrnty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; If not, write to the Free Software Foundation, Inc., 59
+ *  Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#ifndef __DRIVERS_CHAR_MP200_SPI_KERN_H
+#define __DRIVERS_CHAR_MP200_SPI_KERN_H
+
+#include <mach/spi.h>
+
+/*
+ * SPI register
+ */
+#define SP0_ADDR  IO_ADDRESS(MP200_SP0_BASE)
+#define SP1_ADDR  IO_ADDRESS(MP200_SP1_BASE)
+#define SP2_ADDR  IO_ADDRESS(MP200_SP2_BASE)
+
+#define SPx_TX_DATA_PHYS(ADDR)          ((ADDR) + 0x00000010)
+#define SPx_RX_DATA_PHYS(ADDR)          ((ADDR) + 0x00000014)
+
+#define SPx_CONTROL_TX_EMP              (0x01 << 15)
+#define SPx_CONTROL_RX_FULL             (0x01 << 14)
+#define SPx_CONTROL_RST                 (0x01 << 8)
+#define SPx_CONTROL_TX_FULL             (0x01 << 7)
+#define SPx_CONTROL_RX_EMP              (0x01 << 6)
+#define SPx_CONTROL_WRT                 (0x01 << 3)
+#define SPx_CONTROL_RD                  (0x01 << 2)
+#define SPx_CONTROL_STOP                (0x01 << 1)
+#define SPx_CONTROL_START               (0x01 << 0)
+
+#define SPx_STATUS_TX_STOP              (0x01 << 6)
+#define SPx_STATUS_RX_STOP              (0x01 << 5)
+#define SPx_STATUS_TERR                 (0x01 << 4)
+#define SPx_STATUS_RDV                  (0x01 << 3)
+#define SPx_STATUS_END                  (0x01 << 2)
+#define SPx_STATUS_TX_UDR               (0x01 << 1)
+#define SPx_STATUS_RX_OVR               (0x01 << 0)
+#define SPx_STATUS_ALLERR               (SPx_STATUS_TERR | \
+					 SPx_STATUS_TX_UDR | \
+					 SPx_STATUS_RX_OVR)
+
+#define SPx_RAW_STATUS_TX_STOP_RAW      (0x01 << 6)
+#define SPx_RAW_STATUS_RX_STOP_RAW      (0x01 << 5)
+#define SPx_RAW_STATUS_TERR_RAW         (0x01 << 4)
+#define SPx_RAW_STATUS_RDV_RAW          (0x01 << 3)
+#define SPx_RAW_STATUS_END_RAW          (0x01 << 2)
+#define SPx_RAW_STATUS_TX_UDR_RAW       (0x01 << 1)
+#define SPx_RAW_STATUS_RX_OVR_RAW       (0x01 << 0)
+
+#define SPx_ENSET_TX_STOP_EN            (0x01 << 6)
+#define SPx_ENSET_RX_STOP_EN            (0x01 << 5)
+#define SPx_ENSET_TERR_EN               (0x01 << 4)
+#define SPx_ENSET_RDV_EN                (0x01 << 3)
+#define SPx_ENSET_END_EN                (0x01 << 2)
+#define SPx_ENSET_TX_UDR_EN             (0x01 << 1)
+#define SPx_ENSET_RX_OVR_EN             (0x01 << 0)
+#define SPx_ENSET_ALLERR_EN             (SPx_ENSET_TERR_EN | \
+					 SPx_ENSET_TX_UDR_EN | \
+					 SPx_ENSET_RX_OVR_EN)
+
+#define SPx_ENCLR_TX_STOP_MASK          (0x01 << 6)
+#define SPx_ENCLR_RX_STOP_MASK          (0x01 << 5)
+#define SPx_ENCLR_TERR_MASK             (0x01 << 4)
+#define SPx_ENCLR_RDV_MASK              (0x01 << 3)
+#define SPx_ENCLR_END_MASK              (0x01 << 2)
+#define SPx_ENCLR_TX_UDR_MASK           (0x01 << 1)
+#define SPx_ENCLR_RX_OVR_MASK           (0x01 << 0)
+#define SPx_ENCLR_ALLERR_MASK           (SPx_ENCLR_TERR_MASK | \
+					 SPx_ENCLR_TX_UDR_MASK | \
+					 SPx_ENCLR_RX_OVR_MASK)
+#define SPx_ENCLR_ALL_MASK              (SPx_ENCLR_TX_STOP_MASK	  \
+					 | SPx_ENCLR_RX_STOP_MASK \
+					 | SPx_ENCLR_TERR_MASK	  \
+					 | SPx_ENCLR_RDV_MASK	  \
+					 | SPx_ENCLR_END_MASK	  \
+					 | SPx_ENCLR_TX_UDR_MASK  \
+					 | SPx_ENCLR_RX_OVR_MASK)
+
+#define SPx_FFCLR_TX_STOP_CLR           (0x01 << 6)
+#define SPx_FFCLR_RX_STOP_CLR           (0x01 << 5)
+#define SPx_FFCLR_TERR_CLR              (0x01 << 4)
+#define SPx_FFCLR_RDV_CLR               (0x01 << 3)
+#define SPx_FFCLR_END_CLR               (0x01 << 2)
+#define SPx_FFCLR_TX_UDR_CLR            (0x01 << 1)
+#define SPx_FFCLR_RX_OVR_CLR            (0x01 << 0)
+
+#define SPx_FFCLR_ALL_CLR               (SPx_FFCLR_TX_STOP_CLR	 \
+					 | SPx_FFCLR_RX_STOP_CLR \
+					 | SPx_FFCLR_TERR_CLR	 \
+					 | SPx_FFCLR_RDV_CLR	 \
+					 | SPx_FFCLR_END_CLR	 \
+					 | SPx_FFCLR_TX_UDR_CLR	 \
+					 | SPx_FFCLR_RX_OVR_CLR)
+
+#define SPx_CONTROL2_TX_STOP_MODE       (0x01 << 9)
+#define SPx_CONTROL2_RX_STOP_MODE       (0x01 << 8)
+#define SPx_CONTROL2_RX_FIFO_FULL       (0x1F << 0)
+
+/**  ADD FOR spi_write_without_intr **/
+#define SPx_MODE_DMA_MASK               (0x01 << 0)
+#define SPx_MODE_M_S_MASK               (0x01 << 1)
+#define SPx_MODE_NB_MASK                (0x1f << 8)
+/**  ADD FOR spi_write_without_intr END **/
+
+/*
+ * device info
+ */
+#define SPI_NAME                        "spi_kern"
+
+#define DEVNO_IS_INVALID(dev_no)        (dev_no != SPI_DEV_SPI0 && \
+					  dev_no != SPI_DEV_SPI1 && \
+					  dev_no != SPI_DEV_SPI2)
+
+/*
+ * spi register info
+ */
+struct spi_reg_info{
+	volatile unsigned int mode;             /* SPx_MODE       (0x00) */
+	volatile unsigned int pol;              /* SPx_POL        (0x04) */
+	volatile unsigned int control;          /* SPx_CONTROL    (0x08) */
+	unsigned int:32;                       /* reserved       (0x0c) */
+	volatile unsigned int tx_data;          /* SPx_TX_DATA    (0x10) */
+	volatile unsigned int rx_data;          /* SPx_RX_DATA    (0x14) */
+	volatile unsigned int status;           /* SPx_STATUS     (0x18) */
+	volatile unsigned int raw_status;       /* SPx_RAW_STATUS (0x1c) */
+	volatile unsigned int enset;            /* SPx_ENSET      (0x20) */
+	volatile unsigned int enclr;            /* SPx_ENCLR      (0x24) */
+	volatile unsigned int ffclr;            /* SPx_FFCLR      (0x28) */
+	unsigned int:32;                       /* reserved       (0x2c) */
+	unsigned int:32;                       /* reserved       (0x30) */
+	volatile unsigned int control2;         /* SPx_CONTROL2   (0x34) */
+	volatile unsigned int tiecs;            /* SPx_TIECS      (0x38) */
+};
+
+#define spi_regs struct spi_reg_info
+
+/*
+ * spi data info
+ */
+struct spi_data_info{
+	spi_regs *regs;
+	unsigned int pol;
+	unsigned int div_sclk;
+	spinlock_t lock;
+};
+
+#define spi_data_t struct spi_data_info
+
+#endif                          /* __DRIVERS_CHAR_MP200_SPI_KERN_H */
-- 
1.6.5.2

